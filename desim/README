Concepts
========

sim is a very simple discrete event simulator, geared toward
simulation of distributed systems.

In sim a model consists of state machines, representing entities in a
system being simulated. Software (a client cache, a kernel disc
elevator, a thread etc.) as well as hardware (a volatile memory, a
hard disc, a network, etc.) entities can be simulated.

A state machine maintains some internal state, receives input events,
and sends output messages to state machines. The core task of
simulator is to arrange events in the chronological order, given that
state transitions and event deliveries take some time, specified by
the model. While for some system message exchanging state machines are
a natural device of simulation, the most common control flow
mechanism---a function call is awkward to express this way. sim
provides a built-in support for synchronous state machine interaction.

Data types and interfaces
=========================

The most fundamental components of sim are logical time (struct sim)
and a future event (struct sim_callout), defined in sim.h.

struct sim represents an instance of simulation, it contains a current
logical time (sim::ss_bolt) and a queue of future events
(sim::ss_future). sim_run() function executes main simulation loop: it
removes an event from head of the future events list and calls its
callback function repeatedly until the future queue is empty. Callback
functions populate the queue by creating new future events (by calling
sim_timer_add()), that are added to the queue in chronological order.

struct sim_callout represents a parametrized event scheduled for some
future time ("callout" is a traditional UNIX name for this).

Sequential threads are simulated with two more data types: 

struct sim_thread represents a simulated thread. struct sim_chan
represents a channel (in UNIX kernel sense) that threads can
synchronize on. sim_thread is relatively lightweight. Current
implementation is based on ucontext_t calls (getcontext(3),
swapcontext(3), etc.). Overhead depends on platform. Mac OS X requires
a minimum stack of 32K (4K on Linux).

Threading introduces two distinct modes of execution: in-thread and
call-back. Call-back is a code executed on the stack of main
simulation loop. All timer code runs in call-backs. Mode of execution
can be distinguished by result of sim_thread_current() function which
is non-null only in a thread. New threads can be created only from
call-backs.

A "counter" is a simple statistical and measurement interface. A
counter (struct cnt) is named on creation. A "measurement" can be
added to a counter by a call to cnt_mod(). When simulation finishes,
values of all alive counters are dumped onto standard output. A
counter reports average and standard deviation (a square root of
difference between average of squared measurements and squared
average). A counter optionally has a parent counter to which it
replicates all its measurements. This can be used to accumulate data
across a number of short-lived objects (like RPCs). Histogram
capabilities should be added.