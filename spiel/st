#!/bin/bash
set -eu

#set -x
export PS4='+ ${FUNCNAME[0]:+${FUNCNAME[0]}():}line ${LINENO}: '

## CAUTION: This path will be removed by superuser.
SANDBOX_DIR=${SANDBOX_DIR:-/var/mero/sandbox.spiel-st}

TRACE_MASK=${M0_TRACE_IMMEDIATE_MASK:-!rpc,formation,fop,memory,conf}
TRACE_LEVEL=${M0_TRACE_LEVEL:-call+}
TRACE_CONTEXT=${M0_TRACE_PRINT_CONTEXT:-}

MAX_RPC_MSG_SIZE=163840
TM_MIN_RECV_QUEUE_LEN=2
DEV_NR=4
DEV_SIZE=$((1024 *1024))

die() { echo "$@" >&2; exit 1; }
error() { echo "$@" >&2; stop 1; }

M0_CORE_DIR=`readlink -f $0`
M0_CORE_DIR=${M0_CORE_DIR%/*/*}

. $M0_CORE_DIR/m0t1fs/linux_kernel/st/common_service_fids_inc.sh

## Path to the file with configuration string for confd.
CONF_FILE=$SANDBOX_DIR/conf.txt

PROC_FID_CNTR=0x7200000000000001
PROC_FID_KEY=3
PROC_FID_KEY2=4
PROC_FID="<$PROC_FID_CNTR:$PROC_FID_KEY>"
PROC_FID2="<$PROC_FID_CNTR:$PROC_FID_KEY2>"
PROF_OPT="<0x7000000000000001:0>"

iosloopdevs() {
    cat > $SANDBOX_DIR/disks.conf << EOF
    Device:
EOF
    for i in $(seq 1 $DEV_NR)
    do
        dd if=/dev/zero of=$SANDBOX_DIR/${i}.img bs=$DEV_SIZE seek=$DEV_SIZE count=1
        losetup /dev/loop$i $SANDBOX_DIR/${i}.img
        cat >> $SANDBOX_DIR/disks.conf << EOF
       - id: $i
         filename: /dev/loop$i
EOF
    done
}

start() {
    # install "mero" Python module required by m0spiel tool
    cd $M0_CORE_DIR/utils/m0spiel
    python setup.py install > /dev/null || die 'Cannot install Python "mero" module'
    cd $M0_CORE_DIR
    _init
    m0d_with_rms_start
}

stop() {
    local rc=${1:-$?}
    if `mount | grep -q "m0t1fs"`; then umount $SANDBOX_DIR/mnt; fi
    services_stop
    sleep 3
    _fini
    [ $rc -eq 0 ] || say "spiel: test status: FAILED"
    exit $rc
}

_init() {
    lnet_up
    modules_insert
    sandbox_init
}

_fini() {
    sandbox_fini
    modules_remove
}

sandbox_init() {
    rm -rf $SANDBOX_DIR
    mkdir -p $SANDBOX_DIR/mnt
    iosloopdevs
}

sandbox_fini() {
    if [ -d $SANDBOX_DIR/mnt ]; then
        rmdir $SANDBOX_DIR/mnt
    fi
    ## Note that the script does not delete $SANDBOX_DIR itself:
    ## developers may want to analyze the logs contained there.
    for i in $(seq 1 $DEV_NR)
    do
        losetup -d /dev/loop$i
    done
}

### XXX Code duplication!
### There is an identical function in conf/st.
### TODO: Move this code to `scripts/functions'
modules_insert() {
    insmod $M0_CORE_DIR/extra-libs/gf-complete/src/linux_kernel/m0gf.ko ||
        die 'Inserting m0gf.ko failed'

    insmod $M0_CORE_DIR/mero/m0mero.ko \
    local_addr=$M0T1FS_ENDPOINT \
    max_rpc_msg_size=$MAX_RPC_MSG_SIZE \
    tm_recv_queue_min_len=$TM_MIN_RECV_QUEUE_LEN \
    ${TRACE_MASK:+trace_immediate_mask=$TRACE_MASK} \
    ${TRACE_LEVEL:+trace_level=$TRACE_LEVEL} \
    ${TRACE_CONTEXT:+trace_print_context=$TRACE_CONTEXT} \
    || {
    rmmod m0gf
    die 'Inserting m0mero.ko failed'
    }
}

### XXX Code duplication!
### There is an identical function in conf/st.
### TODO: Move this code to `scripts/functions'.
modules_remove() {
    rmmod m0mero
    rmmod m0gf
}

### XXX Code duplication!
### There is an identical function in conf/st.
### TODO: Move this code to `scripts/functions'.
export_endpoints() {
    local LNET_NID=`lctl list_nids | head -1`

    ## LNet endpoint address format (see net/lnet/lnet.h):
    ##     NID:PID:Portal:TMID
    ##
    ## The PID value of 12345 is used by Lustre in the kernel and is
    ## the only value currently supported.
    export M0T1FS_ENDPOINT="$LNET_NID:12345:34:"
    export SERVER1_ENDPOINT="$LNET_NID:12345:34:1001"
    export SERVER2_ENDPOINT="$LNET_NID:12345:34:1002"
    export SPIEL_ENDPOINT="$LNET_NID:12345:34:2001"
}

### Starts LNET. (Note that the script never stops LNET.)
### XXX Code duplication!
### There is an identical function in conf/st.
### TODO: Move this code to `scripts/functions'.
lnet_up() {
    modprobe lnet
    lctl network up >/dev/null
    export_endpoints
}

stub_confdb() {
    cat <<EOF
(root-0 verno=1 profiles=[profile-0])
(profile-0 filesystem=filesystem-0)
(filesystem-0 rootfid=(11, 22) redundancy=2
    params=["pool_width=3", "nr_data_units=1", "nr_parity_units=1",
            "unit_size=4096"]
    mdpool=pool-0 nodes=[node-0] pools=[pool-0] racks=[])
(node-0 memsize=16000 nr_cpu=2 last_state=3 flags=2 pool_id=pool-0
    processes=[process-0])
(process-0 cores=[3] mem_limit_as=0 mem_limit_rss=0 mem_limit_stack=0
    mem_limit_memlock=0 endpoint="$SERVER1_ENDPOINT"
    services=[service-0, service-1, service-2, service-3, service-4, service-5])
(service-0 type=4 endpoints=["$SERVER1_ENDPOINT"] sdevs=[])
(service-1 type=7 endpoints=["$SERVER1_ENDPOINT"] sdevs=[])
(service-2 type=6 endpoints=["$SERVER1_ENDPOINT"] sdevs=[sdev-1, sdev-2, sdev-3,
    sdev-4])
(service-3 type=1 endpoints=["$SERVER1_ENDPOINT"] sdevs=[sdev-0])
(service-4 type=3 endpoints=["$SERVER1_ENDPOINT"] sdevs=[])
(service-5 type=10 endpoints=["$SERVER1_ENDPOINT"] sdevs=[])
(pool-0 order=0 pvers=[pver-0])
(pver-0 ver=0 N=2 K=1 P=4 nr_failures=[0, 0, 0, 0, 1] rackvs=[objv-0])
(objv-0 real=rack-0 children=[objv-1])
(objv-1 real=enclosure-0 children=[objv-2])
(objv-2 real=controller-0 children=[objv-3, objv-4, objv-5, objv-6])
(objv-3 real=disk-0 children=[])
(objv-4 real=disk-1 children=[])
(objv-5 real=disk-2 children=[])
(objv-6 real=disk-3 children=[])
(rack-0 encls=[enclosure-0] pvers=[pver-0])
(enclosure-0 ctrls=[controller-0] pvers=[pver-0])
(controller-0 node=node-0 disks=[disk-0, disk-1, disk-2, disk-3] pvers=[pver-0])
(disk-0 dev=sdev-1)
(disk-1 dev=sdev-2)
(disk-2 dev=sdev-3)
(disk-3 dev=sdev-4)
(sdev-0 iface=4 media=1 bsize=4096 size=596000000000 last_state=3 flags=4
    filename="/dev/sdev0")
(sdev-1 iface=4 media=1 bsize=4096 size=596000000000 last_state=3 flags=4
    filename="/dev/sdev1")
(sdev-2 iface=7 media=2 bsize=8192 size=320000000000 last_state=2 flags=4
    filename="/dev/sdev2")
(sdev-3 iface=7 media=2 bsize=8192 size=320000000000 last_state=2 flags=4
    filename="/dev/sdev3")
(sdev-4 iface=7 media=2 bsize=8192 size=320000000000 last_state=2 flags=4
    filename="/dev/sdev4")
EOF
}

### m0_spiel_start requires endpoint of RM service. This function starts the
### first m0d instance with rmservice. All Spiel commands from command
### interface part will affect to second m0d instance. Spiel commands from
### configuration management part may affect to both m0d.
m0d_with_rms_start() {
    local OPTS="-F -D $SANDBOX_DIR/db -T AD -S $SANDBOX_DIR/stobs\
    -A linuxstob:$SANDBOX_DIR/addb-stobs -e lnet:$SERVER1_ENDPOINT\
    -m $MAX_RPC_MSG_SIZE -q $TM_MIN_RECV_QUEUE_LEN -c $CONF_FILE\
    -w 3 -P $PROF_OPT -f $PROC_FID -E -d $SANDBOX_DIR/disks.conf"

    stub_confdb | $M0_CORE_DIR/utils/m0confgen >$CONF_FILE

    echo "--- `date` ---" >>$SANDBOX_DIR/m0d.log
    cd $SANDBOX_DIR

    ## m0mkfs should be executed only once. It is usually executed
    ## during cluster initial setup.
    echo $M0_CORE_DIR/utils/mkfs/m0mkfs $OPTS
    $M0_CORE_DIR/utils/mkfs/m0mkfs $OPTS >>$SANDBOX_DIR/mkfs.log ||
    error 'm0mkfs failed'

    echo $M0_CORE_DIR/mero/m0d $OPTS
    $M0_CORE_DIR/mero/m0d $OPTS >>$SANDBOX_DIR/m0d.log 2>&1 &
    local PID=$!
    sleep 1
    kill -0 $PID 2>/dev/null ||
    error "Failed to start m0d. See $SANDBOX_DIR/m0d.log for details."
}

test_m0d_start() {
    local CONFD_SPEC="-s confd:<$CONF_FID_CON:2> "
    local OPTS="-D $SANDBOX_DIR/db -T AD -S $SANDBOX_DIR/stobs\
    -A linuxstob:$SANDBOX_DIR/addb-stobs -e lnet:$SERVER2_ENDPOINT -c $CONF_FILE\
    -m $MAX_RPC_MSG_SIZE -q $TM_MIN_RECV_QUEUE_LEN -w 3 -P $PROF_OPT\
    -f $PROC_FID2 -E -d $SANDBOX_DIR/disks.conf"

    cd $SANDBOX_DIR

    echo $M0_CORE_DIR/mero/m0d $OPTS
    $M0_CORE_DIR/mero/m0d $OPTS >>$SANDBOX_DIR/m0d.log 2>&1 &
    local PID=$!
    sleep 1
    kill -0 $PID 2>/dev/null ||
    error "Failed to start m0d. See $SANDBOX_DIR/m0d.log for details."
}

services_stop() { killall -q lt-m0d && wait || true; }

export_vars() {
    export M0_SPIEL_OPTS="
    -l $M0_CORE_DIR/mero/.libs/libmero.so --server $SERVER1_ENDPOINT
    --client $SPIEL_ENDPOINT --rmservice $SERVER1_ENDPOINT"

    export M0_SPIEL_OPTS2="
    -l $M0_CORE_DIR/mero/.libs/libmero.so --server $SERVER2_ENDPOINT
    --client $SPIEL_ENDPOINT --rmservice $SERVER1_ENDPOINT"

    export FIDS_LIST="
fids = {'profile'       : Fid(0x7000000000000001, 0),
        'fs'            : Fid(0x6600000000000001, 1),
        'node'          : Fid(0x6e00000000000001, 2),
        'pool'          : Fid(0x6f00000000000001, 9),
        'rack'          : Fid(0x6100000000000001, 6),
        'encl'          : Fid(0x6500000000000001, 7),
        'ctrl'          : Fid(0x6300000000000001, 8),
        'disk0'         : Fid(0x6b00000000000001, 2),
        'disk1'         : Fid(0x6b00000000000001, 3),
        'disk2'         : Fid(0x6b00000000000001, 4),
        'disk3'         : Fid(0x6b00000000000001, 5),
        'pver'          : Fid(0x7600000000000001, 10),
        'rackv'         : Fid(0x6a00000000000001, 2),
        'enclv'         : Fid(0x6a00000000000001, 3),
        'ctrlv'         : Fid(0x6a00000000000001, 4),
        'diskv0'        : Fid(0x6a00000000000001, 5),
        'diskv1'        : Fid(0x6a00000000000001, 6),
        'diskv2'        : Fid(0x6a00000000000001, 7),
        'diskv3'        : Fid(0x6a00000000000001, 8),
        'process'       : Fid($PROC_FID_CNTR, $PROC_FID_KEY),
        'process2'      : Fid($PROC_FID_CNTR, $PROC_FID_KEY2),
        'ios'           : Fid(0x7300000000000002, 0),
        'mds'           : Fid(0x7300000000000002, 2),
        'mds2'          : Fid(0x7300000000000002, 3),
        'addb2'         : Fid(0x7300000000000002, 5),
        'sns_repair'    : Fid(0x7300000000000002, 6),
        'sns_rebalance' : Fid(0x7300000000000002, 7),
        'confd'         : Fid(0x7300000000000002, 8),
        'confd2'        : Fid(0x7300000000000002, 9),
        'sdev0'         : Fid(0x6400000000000009, 0),
        'sdev1'         : Fid(0x6400000000000009, 1),
        'sdev2'         : Fid(0x6400000000000009, 2),
        'sdev3'         : Fid(0x6400000000000009, 3),
        'rms'           : Fid(0x7300000000000004, 0),
        'ha'            : Fid(0x7300000000000004, 4)
}
"
    export SERVICES="
services = ['ios', 'mds2', 'sns_repair', 'sns_rebalance']
"
### enum of service health statuses. see m0_service_health in reqh/reqh_service.h
    export HEALTH="
HEALTH_GOOD, HEALTH_BAB, HEALTH_INACTIVE, HEALTH_UNKNOWN = range(4)
"
}

construct_db() {
    $M0_CORE_DIR/utils/m0spiel/m0spiel $M0_SPIEL_OPTS <<EOF
$FIDS_LIST
N = 2
K = 1
P = 4
mask = c_uint64(3)
cores = Bitmap(1, pointer(mask))

tx = SpielTx(spiel.spiel)
spiel.tx_open(tx)

conf_objs_add = [('profile_add', tx, fids['profile']),
                 ('filesystem_add', tx, fids['fs'], fids['profile'], 10,
                  fids['profile'], fids['pool'], ["{0} {1} {2}".format(P,N,K)]),
                 ('pool_add', tx, fids['pool'], fids['fs'], 2),
                 ('rack_add', tx, fids['rack'], fids['fs']),
                 ('enclosure_add', tx, fids['encl'], fids['rack']),
                 ('node_add', tx, fids['node'], fids['fs'], 256L, 2, 10L,
                  0xff00ff00L, fids['pool']),
                 ('controller_add', tx, fids['ctrl'], fids['encl'],
                  fids['node']),
                 ('disk_add', tx, fids['disk0'], fids['ctrl']),
                 ('disk_add', tx, fids['disk1'], fids['ctrl']),
                 ('disk_add', tx, fids['disk2'], fids['ctrl']),
                 ('disk_add', tx, fids['disk3'], fids['ctrl']),
                 ('pool_version_add', tx, fids['pver'], fids['pool'],
                  [0, 0, 0, 0, 1],
                  PdclustAttr(N, K, P, 1024*1024, Fid(0x01, 0x02))),
                 ('rack_v_add', tx, fids['rackv'], fids['pver'],
                  fids['rack']),
                 ('enclosure_v_add', tx, fids['enclv'], fids['rackv'],
                  fids['encl']),
                 ('controller_v_add', tx, fids['ctrlv'], fids['enclv'],
                  fids['ctrl']),
                 ('disk_v_add', tx, fids['diskv0'], fids['ctrlv'],
                  fids['disk0']),
                 ('disk_v_add', tx, fids['diskv1'], fids['ctrlv'],
                  fids['disk1']),
                 ('disk_v_add', tx, fids['diskv2'], fids['ctrlv'],
                  fids['disk2']),
                 ('disk_v_add', tx, fids['diskv3'], fids['ctrlv'],
                  fids['disk3']),
                 ('process_add', tx, fids['process'], fids['node'], cores,
                  0L, 0L, 0L, 0L, "$SERVER1_ENDPOINT"),
                 ('process_add', tx, fids['process2'], fids['node'],
                  cores, 0L, 0L, 0L, 0L, "$SERVER2_ENDPOINT"),
                 ('service_add', tx, fids['confd'], fids['process'], M0_CST_MGS,
                  ["$SERVER1_ENDPOINT"], ServiceInfoParameters(confdb_path =
		  "$SERVER1_ENDPOINT")),
                 ('service_add', tx, fids['confd2'], fids['process2'], M0_CST_MGS,
                  ["$SERVER2_ENDPOINT"], ServiceInfoParameters(confdb_path =
		  "$SERVER2_ENDPOINT")),
                 ('service_add', tx, fids['rms'], fids['process'], M0_CST_RMS,
                  ["$SERVER1_ENDPOINT"], ServiceInfoParameters()),
                 ('service_add', tx, fids['ha'], fids['process2'], M0_CST_HA,
                  ["$SERVER2_ENDPOINT"], ServiceInfoParameters()),
                 ('service_add', tx, fids['ios'], fids['process2'], M0_CST_IOS,
                  ["$SERVER2_ENDPOINT"], ServiceInfoParameters()),
                 ('service_add', tx, fids['sns_repair'], fids['process2'],
                  M0_CST_SNS_REP, ["$SERVER2_ENDPOINT"], ServiceInfoParameters()),
                 ('service_add', tx, fids['addb2'], fids['process2'],
                  M0_CST_ADDB2, ["$SERVER2_ENDPOINT"], ServiceInfoParameters()),
                 ('service_add', tx, fids['sns_rebalance'], fids['process2'],
                  M0_CST_SNS_REB, ["$SERVER2_ENDPOINT"], ServiceInfoParameters()),
                 ('service_add', tx, fids['mds'], fids['process'], M0_CST_MDS,
                  ["$SERVER1_ENDPOINT"], ServiceInfoParameters()),
                 ('service_add', tx, fids['mds2'], fids['process2'], M0_CST_MDS,
                  ["$SERVER2_ENDPOINT"], ServiceInfoParameters()),
                 ('device_add', tx, fids['sdev0'], fids['mds2'],
                  fids['disk0'], M0_CFG_DEVICE_INTERFACE_SCSI,
		  M0_CFG_DEVICE_MEDIA_SSD, 1024, $((2 * DEV_SIZE))L, 123L, 0x55L,
                  "dev/loop0"),
                 ('device_add', tx, fids['sdev1'], fids['ios'],
                  fids['disk1'], M0_CFG_DEVICE_INTERFACE_SCSI,
		  M0_CFG_DEVICE_MEDIA_SSD, 1024, $((2 * DEV_SIZE))L, 123L, 0x55L,
                  "dev/loop1"),
                 ('device_add', tx, fids['sdev2'], fids['ios'],
                  fids['disk2'], M0_CFG_DEVICE_INTERFACE_SCSI,
                  M0_CFG_DEVICE_MEDIA_SSD, 1024, $((2 * DEV_SIZE))L, 123L, 0x55L,
                  "dev/loop2"),
                 ('device_add', tx, fids['sdev3'], fids['ios'],
                  fids['disk3'], M0_CFG_DEVICE_INTERFACE_SCSI,
                  M0_CFG_DEVICE_MEDIA_SSD, 1024, $((2 * DEV_SIZE))L, 123L, 0x55L,
                  "dev/loop3"),
                 ('tx_commit', tx)
]

error = False
for conf_obj_add in conf_objs_add:
    try:
        rc = getattr(spiel, conf_obj_add[0])(*conf_obj_add[1:])
        if rc != 0:
            sys.exit("error {0} while {1} executing".format(rc, conf_obj_add[0]))
    except:
        sys.exit("an error occurred while {0} executing: {1}".format(
                 conf_obj_add[0], sys.exc_info()[0]))

spiel.tx_close(tx)
EOF
}

validate_health() {
    $M0_CORE_DIR/utils/m0spiel/m0spiel $M0_SPIEL_OPTS2 <<EOF
$FIDS_LIST
$SERVICES
$HEALTH

if spiel.cmd_profile_set(str(fids['profile'])) != 0:
    sys.exit('can not set profile {0}'.format(fids['profile']))

for key in services:
    rc = spiel.service_health(fids[key])
    if rc not in [HEALTH_GOOD, HEALTH_UNKNOWN]:
        sys.exit('an error occurred while checking health of {0} service with\
              fid {1}, result code = {2}'.format(key, fids[key], rc))

rc = spiel.process_health(fids['process'])
if rc not in [HEALTH_GOOD, HEALTH_UNKNOWN]:
    sys.exit('an error occurred while checking health of process wwith fid {0},\
             result code {1}'.format(fids[process], rc))
EOF
}

restart_services() {
    $M0_CORE_DIR/utils/m0spiel/m0spiel $M0_SPIEL_OPTS2 <<EOF
$FIDS_LIST
$SERVICES

from itertools import product

if spiel.cmd_profile_set(str(fids['profile'])) != 0:
    sys.exit('can not set profile {0}'.format(fids['profile']))

service_commands = list(product(['service_quiesce', 'service_stop',
                                 'service_init', 'service_start'],
                                [fids[x] for x in services]))
for command in service_commands:
    try:
        if getattr(spiel, command[0])(*command[1:]) != 0:
            sys.exit("an error occurred while {0} executing, service fid\
                     {1}".format(command[0], command[1]))
    except:
        sys.exit("an error occurred while {0} executing, service fid \
                 {1}".format(command[0], command[1]))

EOF
}

reconfig_process() {
    $M0_CORE_DIR/utils/m0spiel/m0spiel $M0_SPIEL_OPTS2 <<EOF
$FIDS_LIST

if spiel.cmd_profile_set(str(fids['profile'])) != 0:
    sys.exit('can not set profile {0}'.format(fids['profile']))

rc = spiel.process_reconfig(fids['process2'])
if rc != 0:
    sys.exit('Error: process reconfig for process {0}\
             (status {1})'.format(fids['process2'], rc))
EOF
}

perform_io() {
    #local TEST_STR="`head -c 512 /dev/urandom`"
    local TEST_STR="Hello world"
    local TEST_FILE=$SANDBOX_DIR/mnt/file.txt
    #local TEST_FILE=$SANDBOX_DIR/mnt/test.txt

    ls $SANDBOX_DIR/mnt
    touch $TEST_FILE || die "m0t1fs: Can't touch file"
    setfattr -n lid -v 5 $TEST_FILE || die "m0t1fs: Can't set an attribute"
    echo $TEST_STR > $TEST_FILE || die "m0t1fs: Can't write to file"
    [ "`cat $TEST_FILE`" == "$TEST_STR" ] || die "IO error"
}

fs_stats_fetch() {
    $M0_CORE_DIR/utils/m0spiel/m0spiel $M0_SPIEL_OPTS2 <<EOF
$FIDS_LIST

if spiel.cmd_profile_set(str(fids['profile'])) != 0:
    sys.exit('can not set profile {0}'.format(fids['profile']))

fs_stats = FsStats()
rc = spiel.filesystem_stats_fetch(fids['fs'], fs_stats)
if rc != 0:
	sys.exit('Error: filesystem stats fetch for fs {0}\
                 (status {1})'.format(fids['fs'], rc))

print("free space  {0:>20}".format(fs_stats.fs_free))
print("total space {0:>20}".format(fs_stats.fs_total))
EOF
}

_mount() {
    mkdir -p $SANDBOX_DIR/mnt
    local MOUNT_OPTS="-t m0t1fs -o profile=$PROF_OPT,confd=$SERVER2_ENDPOINT \
none $SANDBOX_DIR/mnt"
    echo "mount $MOUNT_OPTS"
    mount $MOUNT_OPTS || return $?
}

## Keep the audience engaged.
say() { echo "$@" | tee -a $SANDBOX_DIR/m0d.log; }

usage() {
    cat <<EOF
Usage: ${0##*/} [COMMAND]

Supported commands:
  run      run system tests (default command)
  insmod   insert Mero kernel modules: m0mero.ko, m0gf.ko
  rmmod    remove Mero kernel modules
  sstart   start Mero user-space services
  sstop    stop Mero user-space services
  help     display this help and exit
EOF
}

## -------------------------------------------------------------------
## main()
## -------------------------------------------------------------------

[ `id -u` -eq 0 ] || die 'Must be run by superuser'

case "${1:-}" in
    run|'') ;;
    insmod) lnet_up; modules_insert; exit;;
    rmmod) modules_remove; exit;;
    sstart) start; exit;;
    sstop) stop; exit;;
    help) usage; exit;;
    *) usage >&2; die;;
esac

trap stop EXIT

echo "Test start"
start

echo 8 >/proc/sys/kernel/printk  # Print kernel messages to the console.

export_vars

say "Construct confc db"
construct_db

test_m0d_start

say "Validate health"
validate_health

say "Fetch filesystem stats"
fs_stats_fetch

say "Restart services"
restart_services

say "Validate health"
validate_health

say "Reconfig Process"
reconfig_process
say "wait for reconfigure"
sleep 10
grep -q "Restarting" $SANDBOX_DIR/m0d.log || die "Reconfigure is not finished"

say "Validate health"
validate_health

_mount || stop $?

say "Perform IO"
perform_io

say "Validate health"
validate_health

say "spiel: test status: SUCCESS"
