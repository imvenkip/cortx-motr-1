/* -*- C -*- */
/*
 * COPYRIGHT 2012 XYRATEX TECHNOLOGY LIMITED
 *
 * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
 * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
 * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
 * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
 * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
 * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
 * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
 *
 * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
 * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
 * http://www.xyratex.com/contact
 *
 * Original author: Amit Jambure <amit_jambure@xyratex.com>
 * Original creation date: 10/31/2012
 */

#pragma once

#ifndef __COLIBRI_RPC_CONN_H__
#define __COLIBRI_RPC_CONN_H__

#include "lib/tlist.h"
#include "lib/time.h"          /* c2_time_t */
#include "sm/sm.h"
#include "rpc/rpc_onwire.h"    /* c2_rpc_sender_uuid */

/* Imports */
struct c2_rpc_machine;
struct c2_rpc_service;
struct c2_rpc_chan;
struct c2_cob;
struct c2_net_end_point;

/* Exports */
struct c2_rpc_conn;

/**
   @addtogroup rpc_session

   @{
 */

enum c2_rpc_conn_state {
	/**
	  All the fields of conn are initialised locally. But the connection
	  is not yet established.
	 */
	C2_RPC_CONN_INITIALISED,

	/**
	   When sender is waiting for receiver reply to get its sender ID it is
	   in CONNECTING state.
	 */
	C2_RPC_CONN_CONNECTING,

	/**
	   When initialization is successfull connection enters in ACTIVE state.
	   It stays in this state for until termination.
	 */
	C2_RPC_CONN_ACTIVE,

	/**
	   If conn init or terminate fails or time-outs connection enters in
	   FAILED state. c2_rpc_conn::c_sm::sm_rc contains reason for failure.
	*/
	C2_RPC_CONN_FAILED,

	/**
	   When sender calls c2_rpc_conn_terminate() on c2_rpc_conn object
	   a FOP is sent to the receiver side to terminate the rpc connection.
	   Until reply is received, c2_rpc_conn object stays in TERMINATING
	   state
	 */
	C2_RPC_CONN_TERMINATING,

	/**
	   When sender receives reply for conn_terminate FOP and reply FOP
	   specifies the conn_terminate operation is successful then
	   the object of c2_rpc_conn enters in TERMINATED state
	 */
	C2_RPC_CONN_TERMINATED,

	/** After c2_rpc_conn_fini() the RPC connection instance is moved to
	    FINALISED state.
	 */
	C2_RPC_CONN_FINALISED,
};

/**
   RPC Connection flags
 */
enum c2_rpc_conn_flags {
	RCF_SENDER_END = 1 << 0,
	RCF_RECV_END   = 1 << 1
};

/**
   A rpc connection identifies a sender to the receiver. It acts as a parent
   object within which sessions are created. rpc connection has two
   identifiers.

   - UUID: Uniquely Identifies of the rpc connection globally within the
           cluster. UUID is generated by sender.

   - SenderID: A sender id is assigned by receiver. Sender Id uniquely
               identifies a rpc connection on receiver side.
               Same sender has different sender_id to communicate with
               different receiver.

   UUID being larger in size compared to SenderID, it is efficient to use
   sender id to locate rpc connection object.

   c2_rpc_machine maintains two lists of c2_rpc_conn
   - rm_outgoing_conns: list of c2_rpc_conn objects for which this node is
     sender
   - rm_incoming_conns: list of c2_rpc_conn object for which this node is
     receiver

   Instance of c2_rpc_conn stores a list of all sessions currently active with
   the service.

   At the time of creation of a c2_rpc_conn, a "special" session with
   SESSION_ID_0 is also created. It is special in the sense that it is
   "hand-made" and there is no need to communicate to receiver in order to
   create this session. Receiver assumes that there always exists a session 0
   for each rpc connection.
   Session 0 always have exactly 1 slot within it.
   Receiver creates session 0 while creating the rpc connection itself.
   Session 0 is required to send special fops like
   - conn_establish or conn_terminate FOP
   - session_establish or session_terminate FOP.

   <B> State transition diagram: </B>

   @verbatim
                                    | c2_rpc_conn_init()
   c2_rpc_conn_establish() != 0     V
         +---------------------INITIALISED
         |                          |
         |                          |  c2_rpc_conn_establish()
         |                          |
         |                          V
         +---------------------- CONNECTING
         | time-out ||              |
         |     reply.rc != 0        | c2_rpc_conn_establish_reply_received() &&
         |                          |    reply.rc == 0
         V                          |
       FAILED                       |
         |  ^                       V
         |  |                    ACTIVE
         |  |                       |
         |  |                       | c2_rpc_conn_terminate()
         |  | failed || timeout     |
         |  |                       V
         |  +-------------------TERMINATING
	 |                          |
         |                          | c2_rpc_conn_terminate_reply_received() &&
         |                          |              rc== 0
	 |                          V
	 |			TERMINATED
	 |                          |
	 |c2_rpc_conn_fini()        V  c2_rpc_conn_fini()
	 +--------------------->FINALISED

  @endverbatim

  <B> Liveness and Concurrency: </B>
  - Sender side allocation and deallocation of c2_rpc_conn object is
    entirely handled by user (c2_rpc_conn object is not reference counted).
  - On receiver side, user is not expected to allocate or deallocate
    c2_rpc_conn objects explicitly.
  - Receiver side c2_rpc_conn object will be instantiated in response to
    rpc connection establish request and is deallocated while terminating the
    rpc connection.
  - User is not expected to take lock on c2_rpc_conn object. Session module
    will internally synchronise access to c2_rpc_conn.
  - c2_rpc_conn::c_mutex protects all but c_link fields of c2_rpc_conn.
  - Locking order:
    - slot->sl_mutex
    - session->s_mutex
    - conn->c_mutex
    - rpc_machine->rm_session_mutex, rpc_machine->rm_ready_slots_mutex (As of
      now, there is no case where these two mutex are held together. If such
      need arises then ordering of these two mutex should be decided.)

  <B> Typical sequence of API execution </B>
  Note: error checking is omitted.

  @code
  // ALLOCATE CONN
  struct c2_rpc_conn *conn;
  C2_ALLOC_PTR(conn);

  // INITIALISE CONN
  rc = c2_rpc_conn_init(conn, tgt_end_point, rpc_machine);
  C2_ASSERT(ergo(rc == 0, conn_state(conn) == C2_RPC_CONN_INITIALISED));

  // ESTABLISH RPC CONNECTION
  rc = c2_rpc_conn_establish(conn);

  if (rc != 0) {
	// some error occured. Cannot establish connection.
        // handle the situation and return
  }
  // WAIT UNTIL CONNECTION IS ESTABLISHED
  rc = c2_rpc_conn_timedwait(conn, C2_BITS(C2_RPC_CONN_ACTIVE,
					   C2_RPC_CONN_FAILED),
			     absolute_timeout);
  if (rc == 0) {
	if (conn_state(conn) == C2_RPC_CONN_ACTIVE)
		// connection is established and is ready to be used
	else
		// connection establishing failed
  } else {
	// timeout
  }
  // Assuming connection is established.
  // Create one or more sessions using this connection. @see c2_rpc_session

  // TERMINATING CONNECTION
  // Make sure that all the sessions that were created on this connection are
  // terminated
  C2_ASSERT(conn->c_nr_sessions == 0);

  rc = c2_rpc_conn_terminate(conn);

  // WAIT UNTIL CONNECTION IS TERMINATED
  rc = c2_rpc_conn_timedwait(conn, C2_BITS(C2_RPC_CONN_TERMINATED,
					   C2_RPC_CONN_FAILED),
			     absolute_timeout);
  if (rc == 0) {
	if (conn_state(conn) == C2_RPC_CONN_TERMINATED)
		// conn is successfully terminated
	else
		// conn terminate has failed
  } else {
	// timeout
  }
  // assuming conn is terminated
  c2_rpc_conn_fini(conn);
  c2_free(conn);

  @endcode

  On receiver side, user is not expected to call any of these APIs.
  Receiver side rpc-layer will internally allocate/deallocate and manage
  all the state transitions of conn internally.
 */
struct c2_rpc_conn {
	/** Sender ID unique on receiver */
	uint64_t                  c_sender_id;

	/** Globally unique ID of rpc connection */
	struct c2_rpc_sender_uuid c_uuid;

	/** @see c2_rpc_conn_flags for list of flags */
	uint64_t                  c_flags;

	/** rpc_machine with which this conn is associated */
	struct c2_rpc_machine    *c_rpc_machine;

	/** list_link to put c2_rpc_conn in either
	    c2_rpc_machine::rm_incoming_conns or
	    c2_rpc_machine::rm_outgoing_conns.
	    List descriptor: rpc_conn
	 */
	struct c2_tlink		  c_link;

	/** Counts number of sessions (excluding session 0) */
	uint64_t                  c_nr_sessions;

	/** List of all the sessions created under this rpc connection.
	    c2_rpc_session objects are placed in this list using
	    c2_rpc_session::s_link.
	    List descriptor: session
	 */
	struct c2_tl              c_sessions;

	struct c2_rpc_service    *c_service;

	/** A c2_rpc_chan structure that will point to the transfer
	    machine used by this c2_rpc_conn.
	 */
	struct c2_rpc_chan       *c_rpcchan;

	/** cob representing the connection */
	struct c2_cob            *c_cob;

	/** RPC connection state machine
	    @see c2_rpc_conn_state, conn_conf
	 */
	struct c2_sm		  c_sm;

	/** C2_RPC_CONN_MAGIC */
	uint64_t		  c_magic;
};

/**
   Initialises @conn object and associates it with @machine.
   No network communication is involved.

   Note: c2_rpc_conn_init() can fail with -ENOMEM, -EINVAL.
	 if c2_rpc_conn_init() fails, conn is left in undefined state.

   @pre conn != NULL && ep != NULL && machine != NULL
   @post ergo(rc == 0, conn_state(conn) == C2_RPC_CONN_INITIALISED &&
			conn->c_machine == machine &&
			conn->c_sender_id == SENDER_ID_INVALID &&
			(conn->c_flags & RCF_SENDER_END) != 0)
 */
C2_INTERNAL int c2_rpc_conn_init(struct c2_rpc_conn *conn,
				 struct c2_net_end_point *ep,
				 struct c2_rpc_machine *machine,
				 uint64_t max_rpcs_in_flight);

/**
    Sends handshake CONN_ESTABLISH fop to the remote end.
    When reply to CONN_ESTABLISH is received,
    c2_rpc_conn_establish_reply_received() is called.

    @pre conn_state(conn) == C2_RPC_CONN_INITIALISED
    @post ergo(result != 0, conn_state(conn) == C2_RPC_CONN_FAILED)
 */
C2_INTERNAL int c2_rpc_conn_establish(struct c2_rpc_conn *conn);

/**
 * Same as c2_rpc_conn_establish(), but in addition uses c2_rpc_conn_timedwait()
 * to ensure that connection is in active state after c2_rpc_conn_establish()
 * call.
 *
 * @param conn        A connection object to operate on.
 * @param timeout_sec How much time in seconds to wait for connection
 *                    to become active.
 *
 * @pre  conn_state(conn) == C2_RPC_CONN_INITIALISED
 * @post conn_state(conn) == C2_RPC_CONN_ACTIVE
 */
C2_INTERNAL int c2_rpc_conn_establish_sync(struct c2_rpc_conn *conn,
					   uint32_t timeout_sec);

/**
 * A combination of c2_rpc_conn_init() and c2_rpc_conn_establish_sync() in a
 * single routine - initialize connection object, establish a connection and
 * wait until it become active.
 */
C2_INTERNAL int c2_rpc_conn_create(struct c2_rpc_conn *conn,
				   struct c2_net_end_point *ep,
				   struct c2_rpc_machine *rpc_machine,
				   uint64_t max_rpcs_in_flight,
				   uint32_t timeout_sec);

/**
   Sends "conn_terminate" FOP to receiver.
   c2_rpc_conn_terminate() is a no-op if @conn is already in TERMINATING
   state.
   c2_rpc_conn_terminate_reply_received() is called when reply to
   CONN_TERMINATE is received.

   @pre (conn_state(conn) == C2_RPC_CONN_ACTIVE && conn->c_nr_sessions == 0 &&
	 conn->c_service == NULL) ||
	 conn_state(conn) == C2_RPC_CONN_TERMINATING
   @post ergo(rc != 0, conn_state(conn) == C2_RPC_CONN_FAILED)
 */
C2_INTERNAL int c2_rpc_conn_terminate(struct c2_rpc_conn *conn);

/**
 * Same as c2_rpc_conn_terminate(), but in addition uses c2_rpc_conn_timedwait()
 * to ensure that connection is in terminated state after c2_rpc_conn_terminate()
 * call.
 *
 * @param conn        A connection object to operate on.
 * @param timeout_sec How much time in seconds to wait for connection
 *                    to become terminated.
 *
 * @pre (conn_state(conn) == C2_RPC_CONN_ACTIVE && conn->c_nr_sessions == 0) ||
 *       conn_state(conn) == C2_RPC_CONN_TERMINATING
 * @post conn_state(conn) == C2_RPC_CONN_TERMINATED
 */
C2_INTERNAL int c2_rpc_conn_terminate_sync(struct c2_rpc_conn *conn,
					   uint32_t timeout_sec);

/**
   Finalises c2_rpc_conn.
   No network communication involved.
   @pre conn_state(conn) == C2_RPC_CONN_FAILED ||
	conn_state(conn) == C2_RPC_CONN_INITIALISED ||
	conn_state(conn) == C2_RPC_CONN_TERMINATED
 */
C2_INTERNAL void c2_rpc_conn_fini(struct c2_rpc_conn *conn);

/**
 * A combination of c2_rpc_conn_terminate_sync() and c2_rpc_conn_fini() in a
 * single routine - terminate the connection, wait until it switched to
 * terminated state and finalize connection object.
 */
C2_INTERNAL int c2_rpc_conn_destroy(struct c2_rpc_conn *conn,
				    uint32_t timeout_sec);

/**
    Waits until @conn reaches in any one of states specified by @state_flags.
    @param state_flags can specify multiple states by ORing

    @param abs_timeout should not sleep past abs_timeout waiting for conn
		to reach in desired state.
    @return 0 if @conn reaches in one of the state(s) specified by
                @state_flags
            -ETIMEDOUT if time out has occured before @conn reaches in desired
                state.
 */
C2_INTERNAL int c2_rpc_conn_timedwait(struct c2_rpc_conn *conn,
				      uint64_t state_flags,
				      const c2_time_t abs_timeout);

/** @}  End of rpc_session group */
#endif /* __COLIBRI_RPC_CONN_H__ */
