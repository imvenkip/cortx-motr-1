CORE_SRCDIR     = @abs_top_srcdir@
BUILD_DIR       = $(CORE_SRCDIR)/build_kernel_modules
KERNEL_BUILDDIR = @LINUX_OBJ@

KBUILD_EXTRA_SYMBOLS = $(BUILD_DIR)/Lustre.symvers @GALOIS_SYMVERS@

GCOV_PROFILE    = @K_ENABLE_COVERAGE@

testdirs        = ../net/lnet/st/linux_kernel/ \
                  ../net/test/linux_kernel/    \
                  ../rpc/it/linux_kernel/      \
                  ../utils/linux_kernel/

EXTRA_CFLAGS    = -DHAVE_CONFIG_H -iquote . -iquote $(CORE_SRCDIR) \
                  @M0_KCPPFLAGS@ @M0_KCFLAGS@ @KCFLAGS@ \
                  -I@LUSTRE@/lnet/include -I@LUSTRE@/libcfs/include

#       NOTE:
#       It is assumed that user space build is done before starting to
#       build kernel modules.

#       Below is the directory listing from which we have to create m0mero.ko
#       To add a new directory 'd' to this list, add directory name
#       to $(dirs); then add the names of '.c' files to d_SOURCES and the
#       headers to d_HEADERS.

# Please maintain the lexicographical order.
dirs  =                        \
        addb                   \
        addb/addbff            \
        addb/linux_kernel      \
        m0t1fs/linux_kernel    \
        m0t1fs/linux_kernel/ut \
        cob                    \
        mero                \
        conf                   \
        conf/objs              \
        db                     \
        db/linux_kernel        \
        dtm                    \
        fid                    \
        fol                    \
        fop                    \
        ioservice              \
        mdservice              \
        ioservice/ut           \
        layout                 \
        layout/ut              \
        lib                    \
        lib/linux_kernel       \
        lib/ut                 \
        net                    \
        net/bulk_emulation/ut  \
        net/lnet/ut            \
        net/test               \
        net/test/ut            \
        net/ut                 \
        pool                   \
        reqh                   \
        rpc                    \
        rpc/ut                 \
        sm                     \
        sm/ut                  \
        sns                    \
        stob                   \
        ut                     \
        xcode                  \
        xcode/ut

# Source Listing

# NOTE: Currently due to the way `.ff' files are processed, a `*_ff.c' file
#       searches for its corresponding `*_ff.h' in the same directory; So only
#       headers that need to be included in following listing are those of
#       type `*_ff.h'; rest of the headers will be assumed relative to `core/'

addb_SOURCES                    := addb.c addb_fop.c
addb_addbff_SOURCES             := addb_ff.c
addb_addbff_HEADERS             := addb_ff.h

addb_linux_kernel_SOURCES       := addb_console.c

#       If there's a directory 'd' in $(dirs) then the listing of files given
#       for d_SOURCES is relative to $(CORE_SRCDIR)/d;

m0t1fs_linux_kernel_SOURCES     := m0t1fs.c super.c inode.c dir.c
m0t1fs_linux_kernel_ut_SOURCES  := file.c

m0t1fs_linux_kernel_m0loop_SOURCES     := m0loop.c
m0t1fs_linux_kernel_ut_m0loop_SOURCES  := m0loop.c

cob_SOURCES                     := cob.c

mero_SOURCES                 := init.c

db_SOURCES                      := db_common.c

db_linux_kernel_SOURCES         := db.c

dtm_SOURCES                     := verno.c dtm.c verno_xc.c
dtm_HEADERS                     := verno.h verno_xc.h

fid_SOURCES                     := fid.c fid_xc.c
fid_HEADERS                     := fid.h fid_xc.h

fol_SOURCES                     := fol.c

fop_SOURCES                     := fop.c fom.c fop_item_type.c fom_long_lock.c \
                                   fom_generic.c fom_generic_ff.c

fop_HEADERS                     := fom_generic_ff.h

ioservice_SOURCES               := io_fops.c io_fops_ff.c
ioservice_HEADERS               := io_fops_ff.h

mdservice_SOURCES               := md_fops.c md_fops_ff.c
mdservice_HEADERS               := md_fops_ff.h

ioservice_ut_SOURCES            := bulkio_client.c

layout_SOURCES                  := layout.c layout_db.c pdclust.c composite.c \
                                   list_enum.c linear_enum.c

layout_ut_SOURCES               := layout.c

lib_SOURCES                     := bitstring.c getopts.c vec.c list.c queue.c \
                                   refs.c time.c bitmap.c chan.c misc.c buf.c \
                                   cond.c thread.c tlist.c bob.c trace.c      \
                                   finject.c vec_xc.c vec.c buf_xc.c buf.c    \
                                   m0lib.c cookie.c ext.c

lib_HEADERS                     := vec.h vec_xc.h buf.h buf_xc.h

lib_linux_kernel_SOURCES        := memory.c mutex.c rwlock.c ktime.c timer.c \
                                   kthread.c semaphore.c processor.c kvec.c  \
                                   ktrace.c finject_init.c ut.c main.c       \
                                   kcookie.c

lib_ut_SOURCES                  := rwlock.c bitmap.c tlist.c chan.c list.c  \
                                   mutex.c queue.c refs.c tlist.c time.c    \
                                   vec.c zerovec.c thread.c bob.c trace.c   \
                                   memory.c finject.c buf.c cookie.c misc.c

net_SOURCES                     := buf.c buffer_pool.c domain.c ep.c net.c \
                                   tm.c net_otw_types_ff.c tm_provision.c

net_HEADERS                     := net_otw_types_ff.h

net_bulk_emulation_ut_SOURCES   := bulk_mem_ut.c

net_lnet_ut_SOURCES             := lnet_ut.c

net_test_SOURCES                := commands.c console.c network.c node_bulk.c \
                                   node.c node_ping.c ringbuf.c serialize.c   \
                                   service.c slist.c stats.c str.c
net_test_HEADERS                := commands.h console.h network.h node_bulk.h \
                                   node.h node_ping.h ringbuf.h serialize.h   \
                                   service.h slist.h stats.h str.h

net_test_ut_SOURCES             := client_server.c commands.c main.c          \
                                   network.c ringbuf.c serialize.c service.c  \
                                   slist.c stats.c str.c

net_ut_SOURCES                  := bulk_if.c buffer_pool_ut.c
net_ut_HEADERS                  := tm_provision_ut.c

pool_SOURCES                    := pool.c

reqh_SOURCES                    := reqh.c reqh_service.c

rpc_SOURCES                     := rpc.c service.c \
                                   session.c session_foms.c conn.c slot.c \
                                   session_utils.c session_fops.c \
                                   rpc_onwire.c session_ff.c rpclib.c \
                                   formation2.c frmops.c packet.c item.c \
                                   bulk.c rpc_machine.c rpc_onwire_xc.c

rpc_HEADERS                     := session_ff.h rpc_onwire.h rpc_onwire_xc.h

rpc_ut_SOURCES                  := service.c formation2.c conn.c rpc_machine.c \
                                   session.c packet.c

sm_SOURCES                      := sm.c
sm_ut_SOURCES                   := sm.c

sns_SOURCES                     := ls_solve.c matvec.c parity_math.c \
                                   parity_ops.c

stob_SOURCES                    := stob.c stob_id.c

ut_SOURCES                      := rpc.c

xcode_SOURCES                   := xcode.c string.c
xcode_ut_SOURCES                := xcode.c

conf_SOURCES                    := buf_ext.c confc.c obj.c obj_ops.c preload.c \
                                   reg.c onwire_xc.c reg_debug.c conf_xcode.c  \
                                   conf_fop.c

conf_HEADERS                    := onwire.h onwire_xc.h

conf_objs_SOURCES               := common.c dir.c profile.c filesystem.c \
                                   service.c node.c nic.c sdev.c partition.c


#       Following lines create the list of objects required for creating
#       m0mero by putting %.o for each %.c file listed for each target of
#       $(dirs). The following definition of m0mero_objects is functionally
#       equivalent to following shell script code snippet
#       for d in $(dirs); do
#               var=`echo $d | sed 's/\//_/'`
#               varsrc="${var}_SOURCES"
#               for f in ${!varsrc}; do
#                       objfname=`basename $f | sed 's/.c$/.o'`
#                       m0mero_objects = "$m0mero_objects $d/$objfname"
#               done
#       done
#       $(notdir names...)
#               extracts all but the directory-part of each file name in names
#       e.g. $(notdir src/foo.c hacks) Produces the result 'foo.c hacks'

m0mero_objects = $(foreach d, $(dirs), $(foreach f,                         \
                        $($(subst /,_,$(d))_SOURCES), $(addprefix $(d)/,      \
                                $(subst .c,.o, $(notdir $(f))))))

m0loop_objects = $(foreach d, $(dirs), $(foreach f,                         \
                    $($(subst /,_,$(d))_m0loop_SOURCES), $(addprefix $(d)/, \
                                $(subst .c,.o, $(notdir $(f))))))

obj-m += m0mero.o m0loop.o

m0mero-y += main.o dummy_init_fini.o $(m0mero_objects)

m0loop-y += $(m0loop_objects)

#       Besides the m0mero.ko, the UT's would be build separately by
#       recursing into directories specified by $(testdirs)

obj-y += $(testdirs)

create_links = $(shell ln -s $(CORE_SRCDIR)/$(d)/$(f) $(d)/$(notdir $(f))     \
                2> /dev/null)

all:
	@echo $(m0mero-y)
	for s in $(testdirs); do $(MAKE) -C $$s prepare; done
#	Following line is commented out until a lustre devel RPM is available
#	ln -fs @LUSTRE@/config.h lustre_config.h
#       Following lines create links to files from core/ tree to
#       build_kernel_modules/ tree if links does not already exists.
#       for d in $(dirs); do
#               for f in $(d)_SOURCES; do
#                   ln -sf core/$(d)/$(f) core/build_kernel_modules/$(d)/$(f)
#               done
#       done

	$(foreach d, $(dirs), $(shell  [ -d $(d) ] || mkdir -p $(d)))
	$(foreach d, $(dirs), $(foreach f, $($(subst /,_,$(d))_SOURCES),      \
		$(create_links)))
	$(foreach d, $(dirs), $(foreach f, $($(subst /,_,$(d))_HEADERS),      \
		$(create_links)))
	$(foreach d, $(dirs), $(foreach f, $($(subst /,_,$(d))_m0loop_SOURCES),\
		$(create_links)))
#       DO NOT append 'modules' target to the following $(MAKE)
	$(MAKE) -C $(KERNEL_BUILDDIR) M=`pwd`

install modules_install:
	$(MAKE) INSTALL_MOD_DIR=kernel/fs/mero -C $(KERNEL_BUILDDIR) M=`pwd` modules_install

uninstall:
	su -c "$(RM) -r @LINUX_MOD@/kernel/fs/mero && \
	       $(RM) -r @LINUX_MOD@/kernel/fs/utils && \
	       $(RM) -r @LINUX_MOD@/kernel/fs/rpc && \
	       $(RM) -r @LINUX_MOD@/kernel/fs/net && /sbin/depmod -a"

dist distdir:
	cp -v dummy_init_fini.[ch] main.c Makefile.in \
		lustre_config.h Lustre.symvers \
		@top_builddir@/@PACKAGE@-@PACKAGE_VERSION@/build_kernel_modules

clean distclean:
	$(MAKE) -C $(KERNEL_BUILDDIR) M=`pwd` clean
#	$(RM) lustre_config.h
	$(RM) Module.markers modules.order
	$(foreach d, $(dirs), $(shell rm -rf $(firstword $(subst /, , $(d)))))
	for s in $(testdirs) ;do $(MAKE) -C $$s clean ;done
