#!/usr/bin/env python

from __future__ import print_function  # print to sys.stderr
import code
import optparse
import unittest
import sys
import traceback
import atexit
from subprocess import Popen, PIPE
from mero import *
from ctypes import *


def address_get():
    try:
        p = Popen(['lctl', 'list_nids'], stdin=PIPE, stdout=PIPE, stderr=PIPE)
        output, err = p.communicate()
    except OSError:
        return ''
    # When the tool is executing without sudo privileges (i. e. with "--help"
    # option) then lctl output will be an empty string)
    return output.split()[0] if output else ''


default_libmero_path = '../../mero/.libs/libmero.so'
addr = address_get()
default_ha_ep = addr + ':12345:34:1001'
default_client_ep = addr + ":12345:34:200"


# Helper function to check the type of the function parameter. This is useful
# when we want to make sure that user execute a Spiel command with correct
# parameter types. Here is quote from ctypes documentation: "ctypes tries to
# protect you from calling functions with the wrong number of arguments or the
# wrong calling convention. Unfortunately this only works on Windows. It does
# this by examining the stack after the function returns, so although an error
# is raised the function has been called: To find out the correct calling
# convention you have to look into the C header file or the documentation for
# the function you want to call."
#
# It will be executed before annotated function. Helper takes a dictionary
# where key is parameter name and value is required parameter type. If all
# parameters pass type checking then the target function will be called,
# otherwise TypeError will be raised with error message containing information
# about invalid parameter.
#
# Example of usage:
# @require(fid=Fid)
# service_init(self, fid)
def require(**params):
    def check_types(func, params=params):
        def modified(*args, **kw):
            arg_names = func.func_code.co_varnames
            kw.update(zip(arg_names, args))
            for name, type in params.iteritems():
                param = kw[name]
                param_valid = param is None or isinstance(param, type)
                if not param_valid:
                    raise TypeError("Parameter'{0}' should be type '{1}'"
                                    .format(name, type.__name__))
            return func(**kw)
        return modified
    return check_types


# enum m0_conf_service_type
service_types = list(range(1, 11))
M0_CST_MDS, M0_CST_IOS, M0_CST_MGS, M0_CST_RMS, M0_CST_STS, M0_CST_HA,\
    M0_CST_SSS, M0_CST_SNS_REP, M0_CST_SNS_REB, M0_CST_ADDB2 = service_types


# enum m0_cfg_storage_device_interface_type
storage_device_interface = list(range(1, 8))
M0_CFG_DEVICE_INTERFACE_ATA, M0_CFG_DEVICE_INTERFACE_SATA,\
    M0_CFG_DEVICE_INTERFACE_SCSI, M0_CFG_DEVICE_INTERFACE_SATA2,\
    M0_CFG_DEVICE_INTERFACE_SCSI2, M0_CFG_DEVICE_INTERFACE_SAS,\
    M0_CFG_DEVICE_INTERFACE_SAS2 = storage_device_interface


# enum m0_cfg_storage_device_media_type
storage_device_media_type = list(range(1, 5))
M0_CFG_DEVICE_MEDIA_DISK, M0_CFG_DEVICE_MEDIA_SSD, M0_CFG_DEVICE_MEDIA_TAPE,\
    M0_CFG_DEVICE_MEDIA_ROM = storage_device_media_type


#enum m0_sns_cm_status
sns_status = list(range(5))
SNS_CM_STATUS_INVALID, SNS_CM_STATUS_IDLE, SNS_CM_STATUS_STARTED,\
    SNS_CM_STATUS_FAILED, SNS_CM_STATUS_PAUSED = sns_status


# struct m0_fid
class Fid(Structure):
    _fields_ = [("f_container", c_uint64), ("f_key", c_uint64)]

    def __str__(self):
        return "<" + hex(self.f_container)[:-1] + ":" + str(self.f_key) + ">"


spiel_rms_fid = Fid(0x7300000000000004, 100)


# struct m0_bitmap
class Bitmap(Structure):
    _fields_ = [("b_nr", c_uint32), ("b_words", POINTER(c_uint64))]


# struct m0_net_xprt
class NetXprt(Structure):
    _fields_ = [('nx_name', c_char_p), ('nx_ops', c_void_p)]


#struct m0_reqh_init_args
class ReqhInitArgs(Structure):
    _fields_ = [('rhia_dtm', c_void_p), ('rhia_db', c_void_p),
                ('rhia_mdstore', c_void_p), ('rhia_pc', c_void_p),
                ('rhia_fid', POINTER(Fid))]


# struct m0_pdclust_attr
class PdclustAttr(Structure):
    _fields_ = [('pa_Na', c_uint32), ('pa_K', c_uint32), ('pa_P', c_uint32),
                ('pa_unit_size', c_uint64), ('pa_seed', Fid)]


# Different service-specific parameters
# m0_spiel_service_info::svi_u
class ServiceInfoParameters(Union):
    _fields_ = [('repair_limits', c_uint32), ('addb_stobid', Fid),
                ('confdb_path', c_char_p)]


# struct m0_spiel_service_info
class ServiceInfo(Structure):
    _fields_ = [('svi_type', c_uint),
                ('svi_endpoints', POINTER(POINTER(c_char))),
                ('svi_u', ServiceInfoParameters)]


# struct m0_spiel_tx
class SpielTx:
    def __init__(self, spiel):
        self.data = None


class SpielSnsStatus(Structure):
    _fields_ = [('sss_fid', Fid),
                ('sss_state', c_uint),
                ('sss_progress', c_uint)]


class FsStats(Structure):
    _fields_ = [('fs_free', c_uint64),
                ('fs_total', c_uint64)]


class RunningServices(Structure):
    _fields_ = [('spls_fid', Fid), ('spls_name', c_char_p)]


class SpielWrapper:
    def __init__(self, mero):
        self.mero = CDLL(mero)
        self.mero.malloc.restype = c_void_p

    def spiel_init(self, client, ha):
        self.client_ep = c_char_p(client) if client is not None else c_char_p(
            default_client_ep)
        self.ha_ep = c_char_p(ha) if ha is not None else c_char_p(
            default_ha_ep)
        self.__init_m0_instance()
        self.domain = self.__init_net_domain()
        self.buffer_pool = self.__net_buffer_pool_setup(self.domain)
        self.reqh = self.__init_reqh()
        self.rpc_machine = self.__init_rpc_machine(self.domain, self.reqh,
                                                   self.buffer_pool)
        self.__ha_session_init()
        self.spiel = self.__spiel_init(self.reqh)

    def spiel_fini(self):
        self.mero.m0_spiel_fini(self.spiel)
        self.__free(self.spiel)
        self.mero.m0_ha_state_fini()
        self.mero.m0_sns_cm_repair_trigger_fop_fini()
        self.mero.m0_sns_cm_rebalance_trigger_fop_fini()
        self.mero.m0_rpc_session_destroy(self.ha_session, ~0L)
        self.__free(self.ha_session)
        self.mero.m0_rpc_conn_destroy(self.ha_conn, ~0L)
        self.__free(self.ha_conn)
        self.mero.m0_rpc_machine_fini(self.rpc_machine)
        self.__free(self.rpc_machine)
        self.mero.m0_reqh_services_terminate(self.reqh);
        self.mero.m0_reqh_fini(self.reqh)
        self.__free(self.reqh)
        self.mero.m0_rpc_net_buffer_pool_cleanup(self.buffer_pool)
        self.__free(self.buffer_pool)
        self.mero.m0_net_domain_fini(self.domain)
        self.__free(self.domain)
        self.mero.m0_fini(self.m0)
        self.__free(self.m0)

    @require(spiel_tx=SpielTx)
    def tx_open(self, spiel_tx):
        spiel_tx.data = self.allocate_memory(m0_spiel_tx__size())
        self.mero.m0_spiel_tx_open(self.spiel, spiel_tx.data)

    @require(spiel_tx=SpielTx)
    def tx_commit(self, spiel_tx):
        return self.mero.m0_spiel_tx_commit(spiel_tx.data)

    @require(spiel_tx=SpielTx)
    def tx_close(self, spiel_tx):
        self.mero.m0_spiel_tx_close(spiel_tx.data)
        self.__free(spiel_tx.data)

    @require(spiel_tx=SpielTx, fid=Fid)
    def profile_add(self, spiel_tx, fid):
        return self.mero.m0_spiel_profile_add(spiel_tx.data, byref(fid))

    @require(spiel_tx=SpielTx, fid=Fid, parent=Fid, redundancy=int,
             rootfid=Fid, mdpool=Fid, fs_params=list)
    def filesystem_add(self, spiel_tx, fid, parent, redundancy, rootfid,
                       mdpool, fs_params):
        # fs_params must be list of strings. Unfortunately ctypes can't
        # automatically convert list (or array) of strings to something
        # compatible with char**. The code below do this.

        # The line below is similar to:
        # char *fs_params[N], where N equals to len(fs_params)
        fs_params_p = (c_char_p * len(fs_params))()
        # The following line is similar to:
        # fs_params_p[0] = fs_params[0]
        # ...
        # fs_params_p[N] = fs_params[N]
        fs_params_p[:] = fs_params
        # Now ctypes can convert fs_params_p to char **
        return self.mero.m0_spiel_filesystem_add(spiel_tx.data, byref(fid),
                                                 byref(parent), redundancy,
                                                 byref(rootfid), byref(mdpool),
                                                 fs_params_p)

    @require(spiel_tx=SpielTx, fid=Fid, parent=Fid, memsize=long, nr_cpu=int,
             last_state=long, flags=long, pool_fid=Fid)
    def node_add(self, spiel_tx, fid, parent, memsize, nr_cpu, last_state,
                 flags, pool_fid):
        return self.mero.m0_spiel_node_add(spiel_tx.data, byref(fid),
                                           byref(parent), memsize, nr_cpu,
                                           last_state, flags, byref(pool_fid))

    @require(spiel_tx=SpielTx, fid=Fid, parent=Fid, cores=Bitmap,
             memory_limit_as=long, memory_limit_rss=long,
             memory_limit_stack=long, memory_limit_memlock=long, endpoint=str)
    def process_add(self, spiel_tx, fid, parent, cores, memory_limit_as,
                    memory_limit_rss, memory_limit_stack,
                    memory_limit_memlock, endpoint):
        return self.mero.m0_spiel_process_add(spiel_tx.data, byref(fid),
                                              byref(parent), byref(cores),
                                              c_uint64(memory_limit_as),
                                              c_uint64(memory_limit_rss),
                                              c_uint64(memory_limit_memlock),
                                              c_uint64(memory_limit_stack),
                                              endpoint)

    @require(spiel_tx=SpielTx, fid=Fid, parent=Fid, svc_type=int,
             svc_endpoints=list, svc_params=ServiceInfoParameters)
    def service_add(self, spiel_tx, fid, parent, svc_type, svc_endpoints,
                    svc_params):
        if svc_type not in service_types:
            print("Invalid service type" + str(svc_type), file=sys.stderr)
            sys.exit(1)
        endpoints_p = (c_char_p * len(svc_endpoints))()
        endpoints_p[:] = svc_endpoints
        svc_info = ServiceInfo(svc_type, cast(endpoints_p,
                               POINTER(POINTER(c_char))), svc_params)
        return self.mero.m0_spiel_service_add(spiel_tx.data, byref(fid),
                                              byref(parent), byref(svc_info))

    @require(spiel_tx=SpielTx, fid=Fid, parent=Fid, iface=int, media=int,
             bsize=int, size=long, last_state=long, flags=long, filename=str)
    def device_add(self, spiel_tx, fid, parent, disk, dev_idx, iface, media,
                   bsize, size, last_state, flags, filename):
        if iface not in storage_device_interface:
            print("Invalid storage device interface " + str(iface))
            sys.exit(1)
        if media not in storage_device_media_type:
            print("Invalid storage device media type " + str(media))
            sys.exit(1)
        return self.mero.m0_spiel_device_add(spiel_tx.data, byref(fid),
                                             byref(parent), byref(disk),
                                             dev_idx, iface, media, bsize,
                                             size, last_state, flags, filename)

    @require(spiel_tx=SpielTx, fid=Fid, parent=Fid, order=int)
    def pool_add(self, spiel_tx, fid, parent, order):
        return self.mero.m0_spiel_pool_add(spiel_tx.data, byref(fid),
                                           byref(parent), order)

    @require(spiel_tx=SpielTx, fid=Fid, parent=Fid)
    def rack_add(self, spiel_tx, fid, parent):
        return self.mero.m0_spiel_rack_add(spiel_tx.data, byref(fid),
                                           byref(parent))

    @require(spiel_tx=SpielTx, fid=Fid, parent=Fid)
    def enclosure_add(self, spiel_tx, fid, parent):
        return self.mero.m0_spiel_enclosure_add(spiel_tx.data, byref(fid),
                                                byref(parent))

    @require(spiel_tx=SpielTx, fid=Fid, parent=Fid, node=Fid)
    def controller_add(self, spiel_tx, fid, parent, node):
        return self.mero.m0_spiel_controller_add(spiel_tx.data, byref(fid),
                                                 byref(parent), byref(node))

    @require(spiel_tx=SpielTx, fid=Fid, parent=Fid)
    def disk_add(self, spiel_tx, fid, parent):
        return self.mero.m0_spiel_disk_add(spiel_tx.data, byref(fid),
                                           byref(parent))

    @require(spiel_tx=SpielTx, fid=Fid, parent=Fid, nr_failures=list,
             attrs=PdclustAttr)
    def pool_version_add(self, spiel_tx, fid, parent, nr_failures, attrs):
        nr_failures_p = (c_uint32 * len(nr_failures))()
        nr_failures_p[:] = nr_failures
        return self.mero.m0_spiel_pool_version_add(spiel_tx.data, byref(fid),
                                                   byref(parent),
                                                   nr_failures_p,
                                                   c_uint32(len(nr_failures)),
                                                   byref(attrs))

    @require(spiel_tx=SpielTx, fid=Fid, parent=Fid, real=Fid)
    def rack_v_add(self, spiel_tx, fid, parent, real):
        return self.mero.m0_spiel_rack_v_add(spiel_tx.data, byref(fid),
                                             byref(parent), byref(real))

    @require(spiel_tx=SpielTx, fid=Fid, parent=Fid, real=Fid)
    def enclosure_v_add(self, spiel_tx, fid, parent, real):
        return self.mero.m0_spiel_enclosure_v_add(spiel_tx.data, byref(fid),
                                                  byref(parent), byref(real))

    @require(spiel_tx=SpielTx, fid=Fid, parent=Fid, real=Fid)
    def controller_v_add(self, spiel_tx, fid, parent, real):
        return self.mero.m0_spiel_controller_v_add(spiel_tx.data, byref(fid),
                                                   byref(parent), byref(real))

    @require(spiel_tx=SpielTx, fid=Fid, parent=Fid, real=Fid)
    def disk_v_add(self, spiel_tx, fid, parent, real):
        return self.mero.m0_spiel_disk_v_add(spiel_tx.data, byref(fid),
                                             byref(parent), byref(real))

    @require(spiel_tx=SpielTx, fid=Fid)
    def pool_version_done(self, spiel_tx, fid):
        return self.mero.m0_spiel_pool_version_done(spiel_tx.data, byref(fid))

    @require(spiel_tx=SpielTx, fid=Fid)
    def element_del(self, spiel_tx, fid):
        return self.mero.m0_spiel_element_del(spiel_tx.data, byref(fid))
#############################################################################
#                                                                           #
#                              Command Interface                            #
#                                                                           #
#############################################################################

    def rconfc_start(self):
        return self.mero.m0_spiel_rconfc_start(self.spiel)

    def rconfc_stop(self):
        self.mero.m0_spiel_rconfc_stop(self.spiel)

    @require(profile=str)
    def cmd_profile_set(self, profile):
        return self.mero.m0_spiel_cmd_profile_set(self.spiel, profile)

    @require(fid=Fid)
    def service_init(self, fid):
        return self.mero.m0_spiel_service_init(self.spiel, byref(fid))

    @require(fid=Fid)
    def service_start(self, fid):
        return self.mero.m0_spiel_service_start(self.spiel, byref(fid))

    @require(fid=Fid)
    def service_quiesce(self, fid):
        return self.mero.m0_spiel_service_quiesce(self.spiel, byref(fid))

    @require(fid=Fid)
    def service_stop(self, fid):
        return self.mero.m0_spiel_service_stop(self.spiel, byref(fid))

    @require(fid=Fid)
    def service_health(self, fid):
        return self.mero.m0_spiel_service_health(self.spiel, byref(fid))

    @require(fid=Fid)
    def device_attach(self, fid):
        return self.mero.m0_spiel_device_attach(self.spiel, byref(fid))

    @require(fid=Fid)
    def device_detach(self, fid):
        return self.mero.m0_spiel_device_detach(self.spiel, byref(fid))

    @require(fid=Fid)
    def device_format(self, fid):
        return self.mero.m0_spiel_device_format(self.spiel, byref(fid))

    @require(fid=Fid)
    def process_stop(self, fid):
        return self.mero.m0_spiel_process_stop(self.spiel, byref(fid))

    @require(fid=Fid)
    def process_reconfig(self, fid):
        return self.mero.m0_spiel_process_reconfig(self.spiel, byref(fid))

    @require(fid=Fid)
    def process_health(self, fid):
        return self.mero.m0_spiel_process_health(self.spiel, byref(fid))

    @require(fid=Fid)
    def process_quiesce(self, fid):
        return self.mero.m0_spiel_process_quiesce(self.spiel, byref(fid))

    @require(fid=Fid)
    def process_list_services(self, fid, svc_list=POINTER(RunningServices)):
        return self.mero.m0_spiel_process_list_services(self.spiel, byref(fid),
                                                        byref(svc_list))

    @require(fid=Fid)
    def pool_repair_start(self, fid):
        return self.mero.m0_spiel_pool_repair_start(self.spiel, byref(fid))

    @require(fid=Fid)
    def pool_repair_abort(self, fid):
        return self.mero.m0_spiel_pool_repair_abort(self.spiel, byref(fid))


    @require(fid=Fid)
    def pool_repair_quiesce(self, fid):
        return self.mero.m0_spiel_pool_repair_quiesce(self.spiel, byref(fid))

    @require(fid=Fid)
    def pool_repair_continue(self, fid):
        return self.mero.m0_spiel_pool_repair_continue(self.spiel, byref(fid))

    @require(fid=Fid, ppstatus=POINTER(SpielSnsStatus))
    def pool_repair_status(self, fid, ppstatus):
        return self.mero.m0_spiel_pool_repair_status(self.spiel, byref(fid),
                                                     byref(ppstatus))

    @require(fid=Fid)
    def pool_rebalance_start(self, fid):
        return self.mero.m0_spiel_pool_rebalance_start(self.spiel, byref(fid))

    @require(fid=Fid)
    def pool_rebalance_quiesce(self, fid):
        return self.mero.m0_spiel_pool_rebalance_quiesce(self.spiel,
                                                         byref(fid))
    @require(fid=Fid)
    def pool_rebalance_continue(self, fid):
        return self.mero.m0_spiel_pool_rebalance_continue(self.spiel,
                                                          byref(fid))

    @require(fid=Fid, ppstatus=POINTER(SpielSnsStatus))
    def pool_rebalance_status(self, fid, ppstatus):
        return self.mero.m0_spiel_pool_rebalance_status(self.spiel, byref(fid),
                                                        byref(ppstatus))

    @require(fid=Fid, stats=FsStats)
    def filesystem_stats_fetch(self, fid, stats):
        return self.mero.m0_spiel_filesystem_stats_fetch(self.spiel,
                                                         byref(fid),
                                                         byref(stats))

    def __init_m0_instance(self):
        self.m0 = self.allocate_memory(m0__size())
        result = self.mero.m0_init(self.m0)
        if result != 0:
            raise RuntimeError("m0_init failed, rc = " + str(result))

    def __init_net_domain(self):
        domain = self.allocate_memory(m0_net_domain__size())
        xprt = NetXprt.in_dll(self.mero, 'm0_net_lnet_xprt')
        xprt_p = pointer(xprt)
        result = self.mero.m0_net_domain_init(domain, xprt_p)
        if result != 0:
            raise RuntimeError("m0_net_domain_init failed, rc = " +
                               str(result))
        return domain

    def __net_buffer_pool_setup(self, domain):
        buffer_pool = self.allocate_memory(m0_net_buffer_pool__size())
        result = self.mero.m0_rpc_net_buffer_pool_setup(domain, buffer_pool,
                                                        c_uint32(2),
                                                        c_uint32(1))
        if result != 0:
            raise RuntimeError("m0_rpc_net_buffer_pool_setup, rc = " +
                               str(result))
        return buffer_pool

    def __init_reqh(self):
        reqh = self.allocate_memory(m0_reqh__size())
        reqh_args = ReqhInitArgs()
        reqh_args.rhia_fid = pointer(Fid(0x7200000000000001, 5))
        reqh_args.rhia_mdstore = 1
        result = self.mero.m0_reqh_init(reqh, byref(reqh_args))
        if result != 0:
            raise RuntimeError("m0_reqh_init, rc = " + str(result))
        self.__free(reqh_args)
        self.mero.m0_reqh_start(reqh)
        rms = self.allocate_memory(m0_reqh_service__size())
        rms_p = cast(rms, c_void_p)
        result = self.mero.m0_reqh_service_setup(rms_p,
                                                 self.mero.m0_rms_type,
                                                 reqh, None,
                                                 byref(spiel_rms_fid))
        if result != 0:
            raise RuntimeError("RM service start failed, rc = " + str(result))
        return reqh

    def __init_rpc_machine(self, domain, reqh, buffer_pool):
        rpc_machine = self.allocate_memory(m0_rpc_machine__size())
        result = self.mero.m0_rpc_machine_init(rpc_machine, domain,
                                               self.client_ep, reqh,
                                               buffer_pool, c_uint(~0),
                                               c_uint(1 << 17), c_uint(2))
        if result != 0:
            raise RuntimeError("m0_rpc_machine_init, rc = " + str(result))
        return rpc_machine

    def __ha_session_init(self):
        self.ha_conn = self.allocate_memory(m0_rpc_conn__size())
        self.ha_session = self.allocate_memory(m0_rpc_session__size())
        rc = self.mero.m0_rpc_client_connect(self.ha_conn, self.ha_session,
                                             self.rpc_machine, self.ha_ep,
                                             2)
        if rc != 0:
            raise RuntimeError("failed to initialise HA session, rc = " +
                               str(result))
        self.mero.m0_ha_state_init(self.ha_session)

    def __spiel_init(self, reqh):
        spiel = self.allocate_memory(m0_spiel__size())
        result = self.mero.m0_spiel_init(spiel, reqh)
        if result != 0:
            raise RuntimeError("m0_spiel_start, rc = " + str(result))
        self.mero.m0_sns_cm_repair_trigger_fop_init()
        self.mero.m0_sns_cm_rebalance_trigger_fop_init()

        return spiel

    def allocate_memory(self, size):
        ptr = self.mero.malloc(size)
        memset(ptr, 0, size)
        return ptr

    def __free(self, ptr):
        self.mero.free(ptr)


class SpielTool:
    def __init__(self, mero, client):
        self.spiel = SpielWrapper(mero)

    def interactive_console_create(self):
        vars = globals()
        vars.update({'spiel': tool.spiel})
        return code.InteractiveConsole(vars)


class SpielToolTest(unittest.TestCase):
    def setUp(self):
        self.spiel = tool.spiel
        self.spielTx = SpielTx(self.spiel.spiel)
        self.Bitmap = Bitmap(1, pointer(c_uint64(3)))

    def test_typed_parameters(self):
        self.assertRaises(TypeError, self.spiel.tx_open, "Wrong type")

    def test_spiel_functions(self):
        # Self check is intended to reveal errors caused by python dynamic
        # type system. It has no goal to check the functionality of spiel.
        # Tests tuple format:
        # 1st element - method name
        # 2nd element - True if method return some value
        # 3rd element - method arguments
        tests = [('tx_open', False, self.spielTx),
                 ('profile_add', True, self.spielTx,
                  Fid(0x7000000000000001, 0)),
                 ('filesystem_add', True, self.spielTx,
                  Fid(0x6600000000000001, 1), Fid(0x7000000000000001, 0),
                  1, Fid(3, 3), Fid(0x6f00000000000001, 9),
                  [b'param1', b'param2']),
                 ('node_add', True, self.spielTx, Fid(0x6e00000000000001, 2),
                  Fid(0x6600000000000001, 1), 1L, 1, 1L, 1L,
                  Fid(0x6f00000000000001, 9)),
                 ('process_add', True, self.spielTx, Fid(0x7200000000000001,
                                                         3),
                  Fid(0x6e00000000000001, 2), self.Bitmap, 1L, 2L, 3L, 4L),
                 ('service_add', True, self.spielTx, Fid(0x7300000000000002,
                                                         0),
                  Fid(0x7200000000000001, 3), M0_CST_IOS,
                  ["10.0.2.2@tcp:12345:12:12"], ServiceInfoParameters()),
                 ('device_add', True, self.spielTx, Fid(0x6400000000000009, 9),
                  Fid(0x7300000000000002, 0), Fid(0x6b00000000000001, 1),
                  1, 1, 1, 1, 1L, 1L, 1L, "device"),
                 ('pool_add', True, self.spielTx, Fid(0x6f00000000000001, 9),
                  Fid(0x6600000000000001, 1), 1),
                 ('rack_add', True, self.spielTx, Fid(0x6100000000000001, 6),
                  Fid(0x6600000000000001, 1)),
                 ('enclosure_add', True, self.spielTx,
                  Fid(0x6500000000000001, 7), Fid(0x6100000000000001, 6)),
                 ('controller_add', True, self.spielTx,
                  Fid(0x6300000000000001, 8), Fid(0x6500000000000001, 7),
                  Fid(0x6e00000000000001, 2)),
                 ('disk_add', True, self.spielTx, Fid(0x6b00000000000001, 1),
                  Fid(0x6300000000000001, 8)),
                 ('pool_version_add', True, self.spielTx,
                  Fid(0x7600000000000001, 10), Fid(0x6f00000000000001, 9),
                  [0, 0, 0, 0, 1], PdclustAttr()),
                 ('rack_v_add', True, self.spielTx, Fid(0x6a00000000000001, 2),
                  Fid(0x7600000000000001, 10), Fid(0x6100000000000001, 6)),
                 ('enclosure_v_add', True, self.spielTx,
                  Fid(0x6a00000000000001, 3), Fid(0x6a00000000000001, 2),
                  Fid(0x6500000000000001, 7)),
                 ('controller_v_add', True, self.spielTx,
                  Fid(0x6a00000000000001, 4), Fid(0x6a00000000000001, 3),
                  Fid(0x6300000000000001, 8)),
                 ('disk_v_add', True, self.spielTx, Fid(0x6a00000000000001, 5),
                  Fid(0x6a00000000000001, 4), Fid(0x6b00000000000001, 1)),
                 ('pool_version_done', True, self.spielTx,
                  Fid(0x7600000000000001, 10)),
                 ('element_del', True, self.spielTx,
                  Fid(0x7300000000000002, 10001)),
                 ('tx_close', False, self.spielTx),
                 ('service_init', True, Fid(0x7300000000000002, 156)),
                 ('service_start', True, Fid(0x7300000000000002, 156)),
                 ('service_quiesce', True, Fid(0x7300000000000002, 156)),
                 ('service_stop', True, Fid(0x7300000000000002, 156)),
                 ('service_health', True, Fid(0x7300000000000002, 156)),
                 ('device_attach', True, Fid(0x6b00000000000001, 166)),
                 ('device_detach', True, Fid(0x6b00000000000001, 166)),
                 ('device_format', True, Fid(0x6b00000000000001, 166)),
                 ('process_stop', True, Fid(0x7200000000000001, 145)),
                 ('process_reconfig', True, Fid(0x7200000000000001, 145)),
                 ('process_health', True, Fid(0x7200000000000001, 145)),
                 ('process_quiesce', True, Fid(0x7200000000000001, 145)),
                 ('process_list_services', True, Fid(0x7200000000000001, 145),
                  pointer(RunningServices())),
                 ('pool_repair_start', True, Fid(0x6f00000000000001, 199)),
                 ('pool_repair_quiesce', True, Fid(0x6f00000000000001, 199)),
                 ('pool_rebalance_start', True, Fid(0x6f00000000000001, 199)),
                 ('pool_rebalance_quiesce', True, Fid(0x6f00000000000001,
                                                      199)),
                 ('filesystem_stats_fetch', True, Fid(0x6600000000000001, 1),
                  FsStats())
                 ]
        try:
            for t in tests:
                print('{0}...'.format(t[0]))
                if t[1]:
                    self.assertNotEqual(getattr(self.spiel, t[0])(*t[2:]),
                                        None)
                else:
                    getattr(self.spiel, t[0])(*t[2:])
        except AssertionError:
            print('Failed test: ' + t[0])
            raise


class MyParser(optparse.OptionParser):
    def format_usage(self, formatter):
        return self.usage


def create_arguments_parser():
    parser = MyParser(usage='''sudo ./m0spiel [options]

Spiel commands interpreter.

The tool must be executed with sudo command and RPC server must be started
before the tool execution:

\tsudo m0t1fs/linux_kernel/st/m0t1fs_server.sh start default
\tcd utils/m0spiel
\tsudo ./m0spiel

Internally the tool has a number of classes that match corresponding C
structures. Spiel functions work with the following Mero objects:
\t1. Fid (struct m0_fid)
\t3. PdclustAttr (struct m0_pdclust_attr)
\t4. ServiceInfo (struct m0_spiel_service_info)
\t5. SpielTx (struct m0_spiel_tx)
User can create an instance of any class listed above and pass it to a spiel
function.

After the tool is initialized, user has access to object named "spiel" and may
call a function from Spiel library. Each wrapper function is similar to the
corresponding function from C except that user doesn't need to pass Spiel
(m0_spiel) instance.

The following example illustrates usage of the tool:

Execute commands from command line:

\techo -e 'print(spiel_service_init(Fid(1,1)))' | sudo ./m0spiel''')
    parser.add_option('--self-check', action='store_true',
                      help='Run unit tests and exit')
    parser.add_option('--ha', '-s', default=default_ha_ep,
                      help='HA endpoint. Default value: ' +
                      default_ha_ep)
    parser.add_option('--client', '-c', default=default_client_ep,
                      help='Client endpoint. Default value: ' +
                      default_client_ep)
    parser.add_option('-l', default=default_libmero_path, dest='mero',
                      help='Path to libmero.so. Default value: ' +
                      default_libmero_path)
    return parser


if __name__ == "__main__":
    parser = create_arguments_parser()
    args, _ = parser.parse_args()
    try:
        tool = SpielTool(args.mero, args.client)
        atexit.register(tool.spiel.spiel_fini)
        tool.spiel.spiel_init(args.client, args.ha)
    except RuntimeError as e:
        print('an error occurred: ' + str(e), file=sys.stderr)
        print('-' * 80, file=sys.stderr)
        traceback.print_exc(file=sys.stderr)
        print('-' * 80, file=sys.stderr)
        sys.exit(1)
    if args.self_check:
        unittest.main(argv=sys.argv[:1])
    else:
        interpreter = tool.interactive_console_create()
        prompt = '> ' if sys.stdin.isatty() else ''
        while 1:
            try:
                s = raw_input(prompt)
                res = interpreter.push(s)
            except (EOFError, KeyboardInterrupt):
                break
