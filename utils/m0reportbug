#!/bin/bash
set -eu
# set -x
export PS4='+ [${FUNCNAME[0]:+${FUNCNAME[0]}:}${LINENO}] '

VERSION=0.11
###
### History:
###
### Date       Version Description
### ---------- ------- ----------------------------------------------------
### 2016-02-04 0.11    * Collect /etc/mero/genders.
###                    * Get stack of `mount' process.
###
### 2016-02-02 0.10.2  Add `df -h' probe.
###
### 2016-01-27 0.10.1  * _path_src() is able to handle `lt-m0d'.
###                    * Compare VERSION with that of the topmost History
###                      entry. Fail if the values differ.
###
### 2016-01-19 0.10    Create .tar.gz archive. bzip2 is not always available.
###
### 2016-01-05 0.9.2   * Do not collect ADDB data unless `--addb' option
###                      is provided. (Collection of ADDB data may hang.)
###                    * Don't tolerate invalid CLI options.
###                    * Perform optional ADDB collection at the very end
###                      of the execution.
###
### 2015-12-31 0.9.1   [fix] gdb_bt(): Do not call `dirname' without argument.
###
### 2015-12-29 0.9     * Collect addb data.
###                    * Add `journalctl` probe.
###                    * Do not fetch binaries unless there is a core dump
###                      or `-b' CLI option is provided.
###                    * Show duration of slow stages.
###                    * [bugfix] _path_rpm(): Use proper quotes.
###
### 2015-12-24 0.8.1   Do not attach gdb to dd and fio processes.
###
### 2015-12-10 0.8     * Require superuser privileges; drop sudo-s.
###                    * Fetch binaries: libmero.so, m0mkfs, m0d, lt-m0ut, etc.
###                    * Pack results into .tar.bz2 archive.
###                    * gdb_bt(): Show `info sharedlibrary'.
###
### 2015-12-08 0.7.1   * Core dumps and m0trace files may be not world-readable.
###                      Run `touch -r' with sudo.
###                    * Canonicalize $IN_DIR to allow symbolic links.
###
### 2015-12-04 0.7     * Use preset paths, different for rpm and non-rpm
###                      (source) installations.
###                    * Tolerate the absence of gdb.
###                    * Collect no more than 20 most recent m0trace files.
###                    * Limit the size of _compressed_ core dump file,
###                      not the original file.
###                    * gdb_bt(): set solib-search-path to obtain meaningful
###                      backtraces at Jenkins nodes.
###                    * backtraces_live(): Don't fail if a process disappears.
###                    * Add `--path' CLI option.
###
### 2015-11-25 0.6     * Add more probes.
###                    * Collect stderr output of probes.
###                    * Get stacks of `dd' and `fio' processes.
###                    * Update backtraces_cores() to work on Jenkins nodes.
###                    * Add `--version' CLI option.
###                    * [bugfix] backtraces_live(): Make `lt-' prefix optional.
###
### 2015-11-15 0.5.1   Specify input directory via CLI argument.
###
### 2015-11-03 0.4     * Delete old $OUT_DIR without asking user.
###                    * Let the packed m0trace files have timestamps
###                      of original files.
###                    * [bugfix] Fix the issue of `find_exec' not working
###                      properly with relative paths.
###
### 2015-10-31 0.3     Process raw m0traces with `m0tracedump'.
###
### 2015-10-27 0.2     `m0version' calls `m0d -v'.
###
### 2015-10-19 0.1     Initial release: system probes, backtraces (running
###                    lt-m0* processes, core dumps), m0traces.
###

IN_DIR=/var/mero # default value; overruled by CLI argument
OUT_DIR=m0reportbug-data
OUTPUT=m0reportbug.txt # the file is created in $OUT_DIR/
MERO_PACKAGE_VERSION=0.1.0 # must correspond to `M0_VERSION' in configure.ac
M0TRACES_MAX=20 # how many most recently modified m0trace files to collect
ADDB_TAIL=100000 # limit each m0addb2dump output file to that many lines
STAGE_TIME_LIMIT=10 # seconds; if a stage runs longer, show its duration

umask 0002

main() {
    local g t
    local stages=(
        probes
        backtraces_live
        backtraces_cores # must precede `binaries' stage
        m0traces
        binaries # will be skipped unless COLLECT_BINARIES_P=1
        addb # Should go after `m0traces' stage (m0addb2dump creates new
             # m0traces, which we do not want to collect).
    )

    [ `id -u` -eq 0 ] || die 'Must be run by superuser'
    optparse "$@"
    [ -d "$IN_DIR" ] || die "$IN_DIR: no such directory"

    ## `find $IN_DIR` would return nothing if $IN_DIR is a link.
    ## `find -H $IN_DIR` would depend on $PWD if $IN_DIR is a relative path.
    IN_DIR=$(readlink -f $IN_DIR)

    mkcd $OUT_DIR
    echo m0reportbug $VERSION >$OUTPUT
    echo IN_DIR=$IN_DIR >>$OUTPUT

    for g in "${stages[@]}"; do
        case $g in
            addb) [ ${COLLECT_ADDB_P:-0} -eq 1 ] || continue;;
            binaries) [ ${COLLECT_BINARIES_P:-0} -eq 1 ] || continue;;
        esac
        echo -n "$g... " >&2
        section "[$g]"
        t=$(date +%s)
        $g
        echo "OK$(_time $t)" >&2
    done >>$OUTPUT
    cd ..
    tar --remove-files -czf $OUT_DIR.tar.gz $OUT_DIR
    echo "Please attach $OUT_DIR.tar.gz to the bug report." >&2
}

probes() {
    local p
    local probes=(
        'date -u --rfc-3339=seconds'
        'hostname'
        'uptime'
        'm0version'
        'rpm -qi mero'
        'cat /etc/mero/genders'
        'uname -a'
        'cat /proc/cmdline'
        'cat /proc/cpuinfo'
        'cat /proc/diskstats'
        'cat /proc/interrupts'
        'cat /proc/mdstat'
        'cat /proc/meminfo'
        'cat /proc/partitions'
        'cat /proc/vmstat'
        'free'
        'mount'
        'df -h'
        'lspci'
        'gcc --version'
        'ip addr'
        'ip -s link'
        'cat /etc/modprobe.d/lnet.conf'
        'cat /sys/kernel/debug/mero/trace/stat'
        'lsmod'
        'ps -e f'
        'ps auxH'
        'ls /dev/disk/by-*'
        'dmesg'
        'journalctl -b -0'
        'find /var/mero'
    )
    for p in "${probes[@]}"; do
        section $p
        $p 2>&1 || true
    done
}

die() { echo "$@" >&2; exit 1; }
warn() { echo "*WARNING* $@" >&2; }

section() { echo "----- $@ -----"; }

mkcd() {
    local dir=$1

    rm -rf $dir # Bye-bye, the output of previous call!
    mkdir $dir
    cd $dir
}

_time() {
    local start=$1
    local limit=${STAGE_TIME_LIMIT:-0}
    local t=$(($(date +%s) - start))

    if [ $limit -ne 0 -a $t -gt $limit ]; then
        printf ' (%um%us)' $((t / 60)) $((t % 60))
    fi
}

program_from_core() {
    ## Sample output of `file' command:
    ##
    ##   $ file /var/mero/ios1/core.1271
    ##   /var/mero/ios1/core.1271: ELF 64-bit LSB core file x86-64, version 1 (SYSV), SVR4-style, from 'm0d -e lnet:10.22.192.32@tcp:12345:42:401 -f <0x7200000000000001:4> -T ad -D db'
    file $1 | cut -d\' -f2 | cut -d' ' -f1 | xargs basename
}

### Since $0 may be a relative path (e.g., 'utils/m0reportbug'),
### we might not be able to canonicalize it after cd-ing to $OUT_DIR.
PROG=$(readlink -f $0)

_path_rpm() {
    [ $# -eq 1 ] || die "Usage: ${FUNCNAME[0]} <name>"
    local name=$1

    case $name in
        m0d|m0mkfs|m0tracedump) echo "/usr/bin/$name";;
        m0addb2dump) echo "/usr/sbin/$name";;
        libmero.so) echo "/usr/lib64/libmero-${MERO_PACKAGE_VERSION}.so";;
        m0mero.ko) echo "/lib/module/$(uname -r)/kernel/fs/mero/$name";;
        libmero-ut.so|libmero-xcode-ff2c.so) echo "/usr/lib64/$name.0.0.0";;
        libgf_complete.so) echo "/usr/lib64/$name.1.0.0";;
        *) die "${FUNCNAME[0]}: Unsupported argument: $name";;
    esac
}

_path_src() {
    [ $# -eq 2 -a -z "${2%.libs/}" ] ||
        die "Usage: ${FUNCNAME[0]}: <name> [.libs/]"
    local name=$1
    local subdir="$2"

    local src="$(echo $PROG | sed -n 's:/utils/m0reportbug$::p')"
    [ -n "$src" ] || die "${FUNCNAME[0]}: Impossible happened"

    case $name in
        m0d|lt-m0d) echo "$src/mero/${subdir}$name";;
        m0mkfs) echo "$src/utils/mkfs/${subdir}$name";;
        m0tracedump)
            [ -z "$subdir" ] || die "${FUNCNAME[0]}: Unexpected argument"
            echo "$src/utils/trace/$name";;
        m0addb2dump)
            [ -z "$subdir" ] || die "${FUNCNAME[0]}: Unexpected argument"
            echo "$src/addb2/$name";;
        libmero.so) echo "$src/mero/.libs/libmero-${MERO_PACKAGE_VERSION}.so";;
        m0mero.ko) echo "$src/mero/$name";;
        lt-m0ut) echo "$src/ut/.libs/$name";;
        libmero-ut.so) echo "$src/ut/.libs/$name.0.0.0";;
        libmero-xcode-ff2c.so) echo "$src/xcode/ff2c/.libs/$name.0.0.0";;
        libgf_complete.so)
            echo "$src/extra-libs/gf-complete/src/.libs/$name.1.0.0";;
        *) die "${FUNCNAME[0]}: Unsupported argument: $name";;
    esac
}

path() {
    [ $# -ge 1 -a -n "$1" -a -z "${2:-}" -o "${2:-}" = binary ] ||
        die "Usage: ${FUNCNAME[0]} <name> [binary]"
    local name=$1
    local subdir="${2:+.libs/}"
    local result

    if [ "$(dirname $PROG)" = '/usr/sbin' ]; then
        result=$(_path_rpm $name) # installed from rpm
    else
        result=$(_path_src $name "$subdir") # being run from sources
    fi

    if [ -z "$result" ]; then
        warn "${FUNCNAME[0]}: Unable to find $name"
    elif ! [ -a "$result" ]; then
        warn "${FUNCNAME[0]}: $result: No such file"
    elif [ "${2:-}" = binary -a \
           "$(file -bi $result | cut -d= -f2)" != binary ]; then
        warn "${FUNCNAME[0]}: $name is not a binary file"
    else
        echo $result
    fi
}

m0version() { $(path m0d) -v; }

GDB=$(which gdb 2>/dev/null || true)

gdb_bt() {
    [ -n "$GDB" ] || die "${FUNCNAME[0]} cannot be used"
    [ $# -eq 2 ] || die 'Usage: ${FUNCNAME[0]} <prog> {<core>|<pid>}>'

    [ -n "$1" ] || return 0 # do nothing if `prog' argument is empty
    {
        cat <<EOF
echo "set solib-search-path .:$(dirname '$(path libmero.so)')"
set pagination off
p "### bt"
bt
p "### thread apply all bt"
thread apply all bt
p "### thread apply all bt full"
thread apply all bt full
p "### info sharedlibrary"
info sharedlibrary
quit
EOF
    } | $GDB -nx $@ 2>&1 || true
    echo
}

backtraces_live() {
    local pid task

    pgrep '\<(lt-)?m0|\<(dd|fio|mount)\>' | while read pid; do
        local args="$(ps h -o args $pid)"
        [ -n "$args" ] || continue # the process may be gone
        local prog=$(echo $args | cut -d' ' -f1)

        section /proc/$pid/stack
        echo args: $args
        cat /proc/$pid/stack 2>&1 || true # the process may be gone

        { ls /proc/$pid/task 2>&1 || true; } | while read task; do
            section /proc/$pid/task/$task/stack
            cat /proc/$pid/task/$task/stack 2>&1 || true
        done

        [ "${prog#[}" = "$prog" ] || continue # skip kernel threads
        case $(basename $prog) in
            bash|sh|dd|fio) # skip these as well
                continue;;
        esac

        section $pid $(basename $prog)
        [ -z "$GDB" ] || gdb_bt $prog $pid
    done
}

backtraces_cores() {
    local outdir=cores
    local core

    ## Print backtraces.
    if [ -n "$GDB" ]; then
        find "$IN_DIR" -type f -name core.\* | while read core; do
            section $core
            gdb_bt "$(path $(program_from_core $core) binary)" $core
        done
    fi

    ## Pack core dumps.
    section core dumps
    (outdir=$(readlink -f .)/$outdir
     cd "$IN_DIR"
     find . -type f -name core.\* | cut -c3- | while read core; do
         [ -d $outdir/$(dirname $core) ] || mkdir -p $outdir/$(dirname $core)
         ls -sh $core # print size
         gzip -c $core | {
             local err
             ## Write no more than 64 MB.
             if ! err=$(dd ibs=8k count=8k of=$outdir/$core.gz 2>&1); then
                 echo $err
                 continue
             fi
             ## Is there anything left in the input stream?
             if [ $(dd bs=1 count=1 2>/dev/null | wc -c) -gt 0 ]; then
                 echo "Skipping $core: the compressed file is too large"
                 rm $outdir/$core.gz
             else
                 touch -r $core $outdir/$core.gz
             fi
         }
     done)
    if [ -d $outdir ]; then
        COLLECT_BINARIES_P=1
    fi
}

m0traces() {
    local outdir=m0traces
    local path

    local m0tracedump=$(path m0tracedump)
    (outdir=$(readlink -f .)/$outdir
     cd "$IN_DIR"
     find . -type f -name m0trace.\* | cut -c3- | {
         if [ -z "${M0TRACES_MAX:-}" ]; then
             cat
         else
             xargs -r stat -c '%Y %n' | sort -nr -k1,1 |
                 head -n $M0TRACES_MAX | cut -d' ' -f2-
         fi
     } | while read path; do
         [ -d $outdir/$(dirname $path) ] || mkdir -p $outdir/$(dirname $path)
         ##
         ## Disable stderr output to suppress these messages:
         ##
         ## > lt-m0tracedump: Warning: skipping non-existing trace
         ## > descriptor 0x7f977d0bdb00 (orig 0x7ff6ad5c9b00)
         $m0tracedump -s -i $path 2>/dev/null | gzip >$outdir/$path.yaml.gz
         touch -r $path $outdir/$path.yaml.gz
         echo $path.yaml.gz
     done)
}

addb() {
    local outdir=addb
    local dir path

    local m0addb2dump=$(path m0addb2dump)
    (outdir=$(readlink -f .)/$outdir
     cd "$IN_DIR"
     find . -type d -name addb-stobs | cut -c3- | while read dir; do
         find $dir/o -type f -name \*:2 | while read path; do
             [ -d $outdir/$(dirname $path) ] ||
                 mkdir -p $outdir/$(dirname $path)
             ##
             ## "$PWD/" prefix is needed to make an absolute path.
             ## m0addb2dump fails if a relative path is provided:
             ##
             ## > lt-m0addb2dump: Cannot create stob: -2: No such file
             ## > or directory
             $m0addb2dump $PWD/$path | tail -$ADDB_TAIL |
                 gzip >$outdir/$path.gz
             touch -r $path $outdir/$path.gz
             echo $path.gz
         done
     done)
}

binaries() {
    local -r libs=(
        libmero.so
        libmero-xcode-ff2c.so
        libmero-ut.so
        libgf_complete.so
    )
    local f s

    mkdir binaries
    ## Note, that we intentionally skip `m0mero.ko' as it's too big (42M).
    for f in m0mkfs m0d lt-m0ut ${libs[@]}; do
        s=$(path $f binary)
        if [ -n "$s" ]; then
            ## Strip `.0.0' suffix when copying.
            f=$(basename $s)
            cp -pv $s binaries/${f%.0.0}
            ## RATIONALE: Shared libraries, required by a binary, have
            ## `.0.0' suffix stripped.
            ##
            ##     $ objdump -p lt-m0ut | awk '/NEEDED/ {print $2}' | head -2
            ##     libmero-ut.so.0
            ##     libmero-xcode-ff2c.so.0
            ##
            ## By stripping `.0.0' suffixes, we let developers load
            ## shared library symbol files by executing
            ## `set solib-search-path m0reportbug-data/binaries' GDB command.
            ## If the full name of shared library was preserved (e.g.,
            ## `libmero-ut.so.0.0.0'), gdb would not be able to find this
            ## library.
        fi
    done
}

usage() {
    cat <<EOF
Usage: ${0##*/} [OPTION] [INPUT_DIR]
Gather forensic data, which can be used for investigating Mero issues,
from INPUT_DIR and its subdirectories.

Options:
    -h, --help      Show this help and exit.
    --addb          Collect ADDB data.
    -b, --binaries  Collect Mero binaries even if there are no core dumps.
    -p, --path      Show locations of Mero binaries: m0d, m0mero.ko, etc.
    -V, --version   Show version number and exit.

INPUT_DIR defaults to '$IN_DIR'.
EOF
}

optparse() {
    ##
    ## We do not want the program to proceed if invalid CLI options
    ## are provided.
    ##
    ## If TEMP variable was given a value at the place of its declaration
    ## (i.e. if we used `local TEMP=$(getopt ...)' expression), the program
    ## would ignore getopt errors!  On the contrary, when variable
    ## declaration and initialization are separated, any error of `getopt'
    ## command (e.g., invalid option) will result in program failure.
    ##
    local TEMP # do not assign value here
    TEMP=$(getopt -o hpbV --long help,addb,binaries,path,version \
                  -n "${0##*/}" -- "$@")
    eval set -- "$TEMP"
    while true; do
        case "$1" in
            -h|--help) usage; exit 0;;
            --addb) COLLECT_ADDB_P=1;;
            -b|--binaries) COLLECT_BINARIES_P=1;;
            -p|--path)
                for f in m0mkfs m0d m0tracedump m0addb2dump m0mero.ko \
                         libmero{,-xcode-ff2c,-ut}.so libgf_complete.so; do
                    path $f
                done
                exit 0;;
            -V|--version) echo m0reportbug $VERSION; exit 0;;
            --) shift; break;;
            *) break;;
        esac
        shift
    done

    if [ $# -gt 1 ]; then
        die 'Too many arguments'
    elif [ $# -eq 1 ]; then
        IN_DIR="$1"
    fi
}

[ $VERSION = "$(grep -A2 '^### Date' $PROG | tail -1 | cut -d' ' -f3)" ] ||
    die 'VERSION must be updated'
main "$@"
