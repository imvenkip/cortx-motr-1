#!/bin/bash
set -eu
# set -x
# export PS4='+ ${FUNCNAME[0]:+${FUNCNAME[0]}():}line ${LINENO}: '

VERSION=0.7
###
### History:
###
### Date       Version Description
### ---------- ------- ----------------------------------------------------
### 2015-12-04 0.7     * Use preset paths, different for rpm and non-rpm
###                      (source) installations.
###                    * Tolerate the absence of gdb.
###                    * Collect no more than 20 most recent m0trace files.
###                    * Limit the size of _compressed_ core dump file,
###                      not the original file.
###                    * gdb_bt(): set solib-search-path to obtain meaningful
###                      backtraces at Jenkins nodes.
###                    * backtraces_live(): Don't fail if a process disappears.
###                    * Add `--path' CLI option.
###
### 2015-11-25 0.6     * Add more probes.
###                    * Collect stderr output of probes.
###                    * Get stacks of `dd' and `fio' processes.
###                    * Update backtraces_cores() to work on Jenkins nodes.
###                    * Add `--version' CLI option.
###                    * [bugfix] backtraces_live(): Make `lt-' prefix optional.
###
### 2015-11-15 0.5.1   Specify input directory via CLI argument.
###
### 2015-11-03 0.4     * Delete old $OUT_DIR without asking user.
###                    * Let the packed m0trace files have timestamps
###                      of original files.
###                    * [bugfix] Fix the issue of `find_exec' not working
###                      properly with relative paths.
###
### 2015-10-31 0.3     Process raw m0traces with `m0tracedump'.
###
### 2015-10-27 0.2     `m0version' calls `m0d -v'.
###
### 2015-10-19 0.1     Initial release: system probes, backtraces (running
###                    lt-m0* processes, core dumps), m0traces.
###

IN_DIR=/var/mero # default value; overruled by CLI argument
OUT_DIR=m0reportbug-data
OUTPUT=m0reportbug.txt # the file is created in $OUT_DIR/
MERO_PACKAGE_VERSION=0.1.0 # must correspond to `M0_VERSION' in configure.ac
M0TRACES_MAX=20 # how many most recently modified m0trace files to collect

main() {
    local g
    local stages=(
        probes
        backtraces_live
        backtraces_cores
        m0traces
    )

    optparse "$@"

    mkcd $OUT_DIR
    echo m0reportbug $VERSION >$OUTPUT
    echo IN_DIR=$IN_DIR >>$OUTPUT

    for g in "${stages[@]}"; do
        echo -n "$g... " >&2
        section "[$g]"
        $g
        echo 'OK' >&2
    done >>$OUTPUT
    echo "Please attach $OUT_DIR/* files to a bug report." >&2
}

probes() {
    local p
    local probes=(
        'date -u --rfc-3339=seconds'
        'hostname'
        'uptime'
        'm0version'
        'rpm -qi mero'
        'uname -a'
        'cat /proc/cmdline'
        'cat /proc/cpuinfo'
        'cat /proc/diskstats'
        'cat /proc/interrupts'
        'cat /proc/mdstat'
        'cat /proc/meminfo'
        'cat /proc/partitions'
        'cat /proc/vmstat'
        'free'
        'mount'
        'lspci'
        'gcc --version'
        'ip addr'
        'ip -s link'
        'cat /etc/modprobe.d/lnet.conf'
        'sudo cat /sys/kernel/debug/mero/trace/stat'
        'lsmod'
        'ps -e f'
        'ps auxH'
        'ls /dev/disk/by-*'
        'dmesg'
        'sudo find /var/mero'
    )
    for p in "${probes[@]}"; do
        section $p
        $p 2>&1 || true
    done
}

die() { echo "$@" >&2; exit 1; }
warn() { echo "*WARNING* $@" >&2; }

section() { echo "----- $@ -----"; }

mkcd() {
    local dir=$1

    rm -rf $dir # Bye-bye, the output of previous call!
    mkdir $dir
    cd $dir
}

program_from_core() {
    ## Sample output of `file' command:
    ##
    ##   $ sudo file /var/mero/ios1/core.1271
    ##   /var/mero/ios1/core.1271: ELF 64-bit LSB core file x86-64, version 1 (SYSV), SVR4-style, from 'm0d -e lnet:10.22.192.32@tcp:12345:42:401 -f <0x7200000000000001:4> -T ad -D db'
    sudo file $1 | cut -d\' -f2 | cut -d' ' -f1 | xargs basename
}

### Since $0 may be a relative path (e.g., 'utils/m0reportbug'),
### we might not be able to canonicalize it after cd-ing to $OUT_DIR.
PROG=$(readlink -f $0)

_path_rpm() {
    [ $# -eq 1 ] || die "Usage: ${FUNCNAME[0]} <name>"
    local name=$1

    case $name in
        m0d|m0mkfs|m0tracedump) echo "/usr/bin/$name";;
        libmero.so) echo "/usr/lib64/libmero-${MERO_PACKAGE_VERSION}.so";;
        m0mero.ko) echo "/lib/module/$(uname -r)/kernel/fs/mero/m0mero.ko";;
        *) die "${FUNCNAME[0]}: Unsupported argument: $name";;
    esac
}

_path_src() {
    [ $# -eq 2 -a -z "${2%.libs/}" ]||
        die "Usage: ${FUNCNAME[0]}: <name> [.libs/]"
    local name=$1
    local subdir="$2"

    local src="$(echo $PROG | sed -n 's:/utils/m0reportbug$::p')"
    [ -n "$src" ] || die "${FUNCNAME[0]}: Impossible happened"

    case $name in
        m0d) echo "$src/mero/${subdir}$name";;
        m0mkfs) echo "$src/utils/mkfs/${subdir}$name";;
        m0tracedump)
            [ -z "$subdir" ] || die "${FUNCNAME[0]}: Unexpected argument"
            echo "$src/utils/trace/$name";;
        libmero.so) echo "$src/mero/.libs/libmero-${MERO_PACKAGE_VERSION}.so";;
        m0mero.ko) echo "$src/mero/m0mero.ko";;
        lt-m0ut) echo "$src/ut/.libs/lt-m0ut";;
        *) die "${FUNCNAME[0]}: Unsupported argument: $name";;
    esac
}

path() {
    [ $# -ge 1 -a -n "$1" -a -z "${2:-}" -o "${2:-}" = binary ] ||
        die "Usage: ${FUNCNAME[0]} <name> [binary]"
    local name=$1
    local subdir="${2:+.libs/}"
    local result

    if [ "$(dirname $PROG)" = '/usr/sbin' ]; then
        result=$(_path_rpm $name) # installed from rpm
    else
        result=$(_path_src $name "$subdir") # being run from sources
    fi

    if [ -z "$result" ]; then
        warn "${FUNCNAME[0]}: Unable to find $name"
    elif ! [ -a "$result" ]; then
        warn "${FUNCNAME[0]}: $result: No such file"
    elif [ "${2:-}" = binary -a \
           "$(file -bi $result | cut -d= -f2)" != binary ]; then
        warn "${FUNCNAME[0]}: $name is not a binary file"
    else
        echo $result
    fi
}

m0version() { $(path m0d) -v; }

GDB=$(which gdb 2>/dev/null || true)

gdb_bt() {
    [ -n "$GDB" ] || die "${FUNCNAME[0]} cannot be used"
    [ $# -eq 2 ] || die 'Usage: ${FUNCNAME[0]} <prog> {<core>|<pid>}>'

    [ -n "$1" ] || return 0 # do nothing if `prog' argument is empty
    {
        cat <<EOF
set solib-search-path .:$(dirname $(path libmero.so))
set pagination off
p "### bt"
bt
p "### thread apply all bt"
thread apply all bt
p "### thread apply all bt full"
thread apply all bt full
quit
EOF
    } | sudo $GDB -nx $@ 2>&1 || true
    echo
}

backtraces_live() {
    local pid task

    pgrep '\<(lt-)?m0|\<(dd|fio)\>' | while read pid; do
        local args="$(ps h -o args $pid)"
        [ -n "$args" ] || continue # the process may be gone
        local prog=$(echo $args | cut -d' ' -f1)

        section /proc/$pid/stack
        echo args: $args
        sudo cat /proc/$pid/stack 2>&1 || true # the process may be gone

        { sudo ls /proc/$pid/task 2>&1 || true; } | while read task; do
            section /proc/$pid/task/$task/stack
            sudo cat /proc/$pid/task/$task/stack 2>&1 || true
        done

        ## Skip kernel threads and shell scripts -- we cannot gdb_bt them.
        [ "${prog#[}" = "$prog" ] || continue
        [ "$prog" != '/bin/bash' -a "$prog" != '/bin/sh' ] || continue

        section $pid $(basename $prog)
        [ -z "$GDB" ] || gdb_bt $prog $pid
    done
}

backtraces_cores() {
    local outdir=cores
    local core

    ## Print backtraces.
    if [ -n "$GDB" ]; then
        sudo find "$IN_DIR" -type f -name core.\* | while read core; do
            section $core
            gdb_bt "$(path $(program_from_core $core) binary)" $core
        done
    fi

    ## Pack core dumps.
    section core dumps
    (outdir=$(readlink -f .)/$outdir
     cd "$IN_DIR"
     sudo find . -type f -name core.\* | cut -c3- | while read core; do
         [ -d $outdir/$(dirname $core) ] || mkdir -p $outdir/$(dirname $core)
         sudo ls -sh $core # print size
         sudo gzip -c $core | {
             local err
             ## Write no more than 64 MB.
             if ! err=$(dd ibs=8k count=8k of=$outdir/$core.gz 2>&1); then
                 echo $err
                 continue
             fi
             ## Is there anything left in the input stream?
             if [ $(dd bs=1 count=1 2>/dev/null | wc -c) -gt 0 ]; then
                 echo "Skipping $core: the compressed file is too large"
                 rm $outdir/$core.gz
             else
                 touch -r $core $outdir/$core.gz
             fi
         }
     done)
}

m0traces() {
    local outdir=m0traces
    local path

    local m0tracedump=$(path m0tracedump)
    (outdir=$(readlink -f .)/$outdir
     cd "$IN_DIR"
     sudo find . -type f -name m0trace.\* | cut -c3- | {
         if [ -z "${M0TRACES_MAX:-}" ]; then
             cat
         else
             xargs -r stat -c '%Y %n' | sort -nr -k1,1 |
                 head -n $M0TRACES_MAX | cut -d' ' -f2-
         fi
     } | while read path; do
         [ -d $outdir/$(dirname $path) ] || mkdir -p $outdir/$(dirname $path)
         ##
         ## Disable stderr output to suppress these messages:
         ##
         ## > lt-m0tracedump: Warning: skipping non-existing trace
         ## > descriptor 0x7f977d0bdb00 (orig 0x7ff6ad5c9b00)
         sudo $m0tracedump -s -i $path 2>/dev/null | gzip >$outdir/$path.yaml.gz
         touch -r $path $outdir/$path.yaml.gz
         echo $path.yaml.gz
     done)
}

usage() {
    cat <<EOF
Usage: ${0##*/} [OPTION] [INPUT_DIR]
Gather forensic data, which can be used for investigating Mero issues,
from INPUT_DIR and its subdirectories.

    -h, --help      Show this help and exit.
    -p, --path      Show locations of Mero binaries: m0d, m0mero.ko, etc.
    -V, --version   Show version number and exit.

INPUT_DIR defaults to '$IN_DIR'.
EOF
}

optparse() {
    local TEMP=$(getopt -o hpV --long help,path,version -n "${0##*/}" -- "$@")
    eval set -- "$TEMP"
    while true; do
        case "$1" in
            -h|--help) usage; exit 0;;
            -p|--path)
                for f in m0d m0mkfs libmero.so m0mero.ko m0tracedump; do
                    path $f
                done | sort
                exit 0;;
            -V|--version) echo m0reportbug $VERSION; exit 0;;
            --) shift; break;;
            *) break;;
        esac
    done

    if [ $# -gt 1 ]; then
        die 'Too many arguments'
    elif [ $# -eq 1 ]; then
        IN_DIR="$(readlink -f $1)"
    fi
    [ -d "$IN_DIR" ] || die "$IN_DIR: no such directory"
}

main "$@"
