#!/bin/bash
set -eu
# set -x
# export PS4='+ ${FUNCNAME[0]:+${FUNCNAME[0]}():}line ${LINENO}: '

VERSION=0.6
###
### History:
###
### Date       Version Description
### ---------- ------- ----------------------------------------------------
### 2015-11-25 0.6     * Add more probes.
###                    * Collect stderr output of probes.
###                    * Get stacks of `dd' and `fio' processes.
###                    * Update backtraces_cores() to work on Jenkins nodes.
###                    * Add `--version' CLI option.
###                    * [bugfix] backtraces_live(): Make `lt-' prefix optional.
###
### 2015-11-15 0.5.1   Specify input directory via CLI argument.
###
### 2015-11-03 0.4     * Delete old $OUT_DIR without asking user.
###                    * Let the packed m0trace files have timestamps
###                      of original files.
###                    * [bugfix] Fix the issue of `find_exec' not working
###                      properly with relative paths.
###
### 2015-10-31 0.3     Process raw m0traces with `m0tracedump'.
###
### 2015-10-27 0.2     `m0version' calls `m0d -v'.
###
### 2015-10-19 0.1     Initial release: system probes, backtraces (running
###                    lt-m0* processes, core dumps), m0traces.
###

IN_DIR=/var/mero # default value; overruled by CLI argument
OUT_DIR=m0reportbug-data
OUTPUT=m0reportbug.txt # the file is created in $OUT_DIR/
MAX_CORE_SIZE=512 # MB

main() {
    local g
    local stages=(
        probes
        backtraces_live
        backtraces_cores
        m0traces
    )

    optparse "$@"

    mkcd $OUT_DIR
    echo m0reportbug $VERSION >$OUTPUT
    echo IN_DIR=$IN_DIR >>$OUTPUT

    for g in "${stages[@]}"; do
        echo -n "$g... " >&2
        $g
        echo 'OK' >&2
    done >>$OUTPUT
    echo "Please attach $OUT_DIR/* files to a bug report." >&2
}

probes() {
    local p
    local probes=(
        'date -u --rfc-3339=seconds'
        'hostname'
        'uptime'
        'm0version'
        'rpm -qi mero'
        'uname -a'
        'cat /proc/cmdline'
        'cat /proc/cpuinfo'
        'cat /proc/diskstats'
        'cat /proc/interrupts'
        'cat /proc/mdstat'
        'cat /proc/meminfo'
        'cat /proc/partitions'
        'cat /proc/vmstat'
        'free'
        'mount'
        'lspci'
        'gcc --version'
        'ip addr'
        'ip -s link'
        'cat /etc/modprobe.d/lnet.conf'
        'sudo cat /sys/kernel/debug/mero/trace/stat'
        'lsmod'
        'ps -e f'
        'ps auxH'
        'ls /dev/disk/by-*'
        'dmesg'
        'sudo find /var/mero'
    )
    for p in "${probes[@]}"; do
        section $p
        $p 2>&1 || true
    done
}

die() { echo "$@" >&2; exit 1; }
warn() { echo "*WARNING* $@" >&2; }

section() { echo "----- $@ -----"; }

mkcd() {
    local dir=$1

    rm -rf $dir # Bye-bye, the output of previous call!
    mkdir $dir
    cd $dir
}

program_from_core() { sudo file $1 | cut -d\' -f2 | cut -d' ' -f1; }
program_from_pid() { ps h -o args $1 | cut -d' ' -f1; }

### Since $0 may be a relative path (e.g., 'utils/m0reportbug'),
### we might not be able to canonicalize it after cd-ing to $OUT_DIR.
PROG=$(readlink -f $0)

### Try to find a path to executable, given its name.
###
### Example:
###   $ find_exec m0d
###   ==> /path/to/workdir/src/mero/m0d
###   $ find_exec /path/to/workdir/src/mero/m0d
###   ==> /path/to/workdir/src/mero/m0d
###
### See also `binary'.
find_exec() {
    local name=$1
    local dir=$(dirname $PROG)
    local s

    ## First try to find the executable in m0reportbug's directory.
    if [ -x $dir/$name ]; then
        readlink -f $dir/$name
        return
    fi

    ## Try to guess the path from core dumps.
    sudo find "$IN_DIR" -type f -name core.\* | while read s; do
        s=$(program_from_core $s | sed -rn "s:/\.libs/(lt-)?$name:/$name:p")
        if [ -n "$s" -a -x "$s" ]; then
            echo $s
            return
        fi
    done

    ## Try to guess the path from running processes.
    pgrep '\<(lt-)?m0' | while read s; do
        s=$(program_from_pid $s | sed -rn "s:/\.libs/(lt-)?$name:/$name:p")
        if [ -n "$s" -a -x "$s" ]; then
            echo $s
            return
        fi
    done

    ## Last resort.
    which $name 2>/dev/null || warn "$name executable not found"
}

### Try to deduce a path to binary, given path to an executable file,
### which may be a shell script (ASCII text).
###
### Example:
###   $ binary /path/to/workdir/src/mero/m0d
###   ==> /path/to/workdir/src/mero/.libs/m0d
###
### See also `find_exec'.
binary() {
    local f="${1:-}"
    [ -n "$f" -a -x "$f" ] || return

    for f in "$f" "$(dirname $f)/.libs/$(basename $f)"; do
        if [ "$(file -bi $f | cut -d= -f2)" = 'binary' ]; then
            echo $f
            return
        fi
    done
}

m0version() {
    local m0d=$(find_exec m0d)

    if [ -n "$m0d" ]; then
        $m0d -v
    fi
}

gdb_bt() {
    [ $# -eq 2 ] || die 'Usage: gdb_bt <prog> {<core>|<pid>}>'
    sudo gdb -nx $@ <<EOF
set pagination off
bt
p "###"
thread apply all bt
p "###"
thread apply all bt full
quit
EOF
    echo
}

backtraces_live() {
    local pid task

    pgrep '\<(lt-)?m0|\<(dd|fio)\>' | while read pid; do
        local args="$(ps h -o args $pid)"
        local prog=$(echo $args | cut -d' ' -f1)

        section /proc/$pid/stack
        sudo cat /proc/$pid/stack

        sudo ls /proc/$pid/task | while read task; do
            section /proc/$pid/task/$task/stack
            sudo cat /proc/$pid/task/$task/stack
        done

        ## Skip kernel threads and bash scripts -- we cannot gdb_bt them.
        [ "${prog#[}" = "$prog" -a "$prog" != '/bin/bash' ] || continue

        section $pid $(basename $prog)
        echo $args
        gdb_bt $prog $pid
    done
}

backtraces_cores() {
    local tmp=/tmp/m0reportbug_$$.tmp
    local out=cores.tar.gz
    local core

    trap "rm -f $tmp" 0
    sudo find "$IN_DIR" -type f -name core.\* | while read core; do
        local mb=$(sudo du -BM $core | cut -dM -f1)
        echo $((mb <= $MAX_CORE_SIZE)) $core  # <include?> <path>
    done >$tmp
    [ -s $tmp ] || return 0  # No core dumps. Nothing to do.

    ## Print backtraces.
    cut -d' ' -f2 $tmp | while read core; do
        section $core
        gdb_bt $(binary $(find_exec $(program_from_core $core))) $core 2>&1
    done

    ## Pack core dumps.
    section core dumps
    grep '^0 ' $tmp | cut -d' ' -f2 | while read core; do
        echo "Skipping $core: the file is too large" \
             "($(sudo du -h $core | cut -f1))"
    done
    if grep -q '^1 ' $tmp; then
        (cd "$IN_DIR"
         grep '^1 ' $tmp | cut -d' ' -f2 | cut -d/ -f4- |
             sudo tar -T - -czf - || true) >$out
        sha1sum $out
    fi
}

m0traces() {
    local out=m0traces
    local path

    section $out
    local m0tracedump=$(find_exec m0tracedump)
    if [ -n "$m0tracedump" ]; then
        (out=$(readlink -f .)/$out
         cd "$IN_DIR"
         sudo find . -type f -name m0trace.\* | cut -c3- | while read path; do
             [ -d $out/$(dirname $path) ] || mkdir -p $out/$(dirname $path)
             ##
             ## Disable stderr output to suppress these messages:
             ##
             ## > lt-m0tracedump: Warning: skipping non-existing trace
             ## > descriptor 0x7f977d0bdb00 (orig 0x7ff6ad5c9b00)
             sudo $m0tracedump -s -i $path 2>/dev/null |
                 gzip >$out/$path.yaml.gz
             touch -r $path $out/$path.yaml.gz
         done)
    else
        (cd "$IN_DIR"
         sudo find . -type f -name m0trace.\* | sudo tar -T - -czf - || true) \
            >$out.tar.gz
    fi
    if [ -d $out ]; then
        find $out -type f -exec sha1sum {} +
    fi
}

usage() {
    cat <<EOF
Usage: ${0##*/} [OPTION] [INPUT_DIR]
Gather forensic data, which can be used for investigating Mero issues,
from INPUT_DIR and its subdirectories.

    -h, --help      Show this help and exit.
    -V, --version   Show version number and exit.

INPUT_DIR defaults to '$IN_DIR'.
EOF
}

optparse() {
    local TEMP=$(getopt -o hV --long help,version -n "${0##*/}" -- "$@")
    eval set -- "$TEMP"
    while true; do
        case "$1" in
            -h|--help) usage; exit 0;;
            -V|--version) echo m0reportbug $VERSION; exit 0;;
            --) shift; break;;
            *) break;;
        esac
    done

    if [ $# -gt 1 ]; then
        die 'Too many arguments'
    elif [ $# -eq 1 ]; then
        IN_DIR="$(readlink -f $1)"
    fi
    [ -d "$IN_DIR" ] || die "$IN_DIR: no such directory"
}

main "$@"
