#!/bin/bash
set -eu
# set -x
# export PS4='+ ${FUNCNAME[0]:+${FUNCNAME[0]}():}line ${LINENO}: '

VERSION='0.4'
###
### History:
###
### Date       Version Description
### ---------- ------- ----------------------------------------------------
### 2015-11-03 0.4     Delete old $DATA_DIR without asking user.
###                    Let the packed m0trace files have timestamps of original
###                    files.  Fix the issue of `find_exec' not working
###                    properly with relative paths.
###
### 2015-10-31 0.3     Process raw m0traces with `m0tracedump'.
###
### 2015-10-27 0.2     `m0version' calls `m0d -v'.
###
### 2015-10-19 0.1     Initial release: system probes, backtraces (running
###                    lt-m0* processes, core dumps), m0traces.
###

DATA_DIR=m0reportbug-data
OUTPUT=m0reportbug.txt # the file is created in $DATA_DIR/
MAX_CORE_SIZE=512 # MB

main() {
    local g
    local stages=(
        probes
        backtraces_live
        backtraces_cores
        m0traces
    )

    mkcd $DATA_DIR
    echo m0reportbug $VERSION >$OUTPUT
    for g in "${stages[@]}"; do
        echo -n "$g... " >&2
        $g
        echo 'OK' >&2
    done >>$OUTPUT
    echo "Please attach $DATA_DIR/* files to a bug report." >&2
}

probes() {
    local p
    local probes=(
        'date -u --rfc-3339=seconds'
        'hostname'
        'uptime'
        'm0version'
        'rpm -qi mero'
        'uname -a'
        'cat /proc/cmdline'
        'cat /proc/cpuinfo'
        'cat /proc/partitions'
        'cat /proc/diskstats'
        'cat /proc/vmstat'
        'free'
        'mount'
        'lspci'
        'gcc --version'
        'ip addr'
        'ip -s link'
        'cat /etc/modprobe.d/lnet.conf'
        'lsmod'
        'ps -e f'
        'ps auxH'
        'ls /dev/disk/by-*'
        'dmesg'
    )
    for p in "${probes[@]}"; do
        section $p
        $p || true
    done
}

die() { echo "$@" >&2; exit 1; }
warn() { echo "*WARNING* $@" >&2; }

section() { echo "----- $@ -----"; }

mkcd() {
    local dir=$1

    rm -rf $dir # Bye-bye, the output of previous call!
    mkdir $dir
    cd $dir
}

program_from_core() { sudo file $1 | cut -d\' -f2 | cut -d' ' -f1; }
program_from_pid() { ps h -o args $1 | cut -d' ' -f1; }

### Since $0 may be a relative path (e.g., 'utils/m0reportbug'),
### we might not be able to canonicalize it after cd-ing to $DATA_DIR.
PROG=$(readlink -f $0)

find_exec() {
    local name=$1
    local dir=$(dirname $PROG)
    local s

    ## First try to find the executable in m0reportbug's directory.
    if [ -x $dir/$name ]; then
        echo $dir/$name
        return
    fi

    ## Try to guess the path from core dumps.
    sudo find /var/mero -type f -name core.\* | while read s; do
        s=$(program_from_core $s | sed -n "s:/\.libs/lt-$name:/$name:p")
        if [ -n "$s" ]; then
            echo $s
            return
        fi
    done

    ## Try to guess the path from running processes.
    pgrep lt-m0 | while read s; do
        s=$(program_from_pid $s | sed -n "s:/\.libs/lt-$name:/$name:p")
        if [ -n "$s" ]; then
            echo $s
            return
        fi
    done

    ## Last resort.
    which $name 2>/dev/null
}

m0version() {
    local m0d=$(find_exec m0d)

    if [ -n "$m0d" ]; then
        $m0d -v
    else
        warn 'm0d executable not found'
    fi
}

gdb_bt() {
    [ $# -eq 2 ] || die 'Usage: gdb_bt <prog> {<core>|<pid>}>'
    sudo gdb -nx $@ <<EOF
set pagination off
bt
p "###"
thread apply all bt
p "###"
thread apply all bt full
quit
EOF
    echo
}

backtraces_live() {
    local pid task

    pgrep lt-m0 | while read pid; do
        local args="$(ps h -o args $pid)"
        local prog=$(echo $args | cut -d' ' -f1)

        section /proc/$pid/stack
        sudo cat /proc/$pid/stack

        sudo ls /proc/$pid/task | while read task; do
            section /proc/$pid/task/$task/stack
            sudo cat /proc/$pid/task/$task/stack
        done

        section $pid $(basename $prog)
        echo $args
        gdb_bt $prog $pid
    done
}

backtraces_cores() {
    local tmp=/tmp/m0reportbug_$$.tmp
    local out=cores.tar.gz
    local core

    trap "rm -f $tmp" 0
    sudo find /var/mero -type f -name core.\* | while read core; do
        local mb=$(sudo du -BM $core | cut -dM -f1)
        echo $((mb <= $MAX_CORE_SIZE)) $core  # <include?> <path>
    done >$tmp
    [ -s $tmp ] || return 0  # No core dumps. Nothing to do.

    ## Print backtraces.
    cut -d' ' -f2 $tmp | while read core; do
        section $core
        gdb_bt $(program_from_core $core) $core
    done

    ## Pack core dumps.
    section core dumps
    grep '^0 ' $tmp | cut -d' ' -f2 | while read core; do
        echo "Skipping $core: the file is too large" \
             "($(sudo du -h $core | cut -f1))"
    done
    if grep -q '^1 ' $tmp; then
        (cd /var/mero
         grep '^1 ' $tmp | cut -d' ' -f2 | cut -d/ -f4- |
             sudo tar -T - -czf - || true) >$out
        sha1sum $out
    fi
}

m0traces() {
    local m0tracedump=$(find_exec m0tracedump)
    local out=m0traces
    local path

    section $out
    if [ -n "$m0tracedump" ]; then
        (out=$(readlink -f .)/$out
         cd /var/mero
         sudo find . -type f -name m0trace.\* | cut -c3- | while read path; do
             [ -d $out/$(dirname $path) ] || mkdir -p $out/$(dirname $path)
             ##
             ## Disable stderr output to suppress these messages:
             ##
             ## > lt-m0tracedump: Warning: skipping non-existing trace
             ## > descriptor 0x7f977d0bdb00 (orig 0x7ff6ad5c9b00)
             sudo $m0tracedump -s -i $path 2>/dev/null |
                 gzip >$out/$path.yaml.gz
             touch -r $path $out/$path.yaml.gz
         done)
    else
        warn 'm0tracedump executable not found'
        (cd /var/mero
         sudo find . -type f -name m0trace.\* | sudo tar -T - -czf - || true) \
            >$out.tar.gz
    fi
    if [ -d $out ]; then
        find $out -type f -exec sha1sum {} +
    fi
}

main
