#!/usr/bin/env python

from __future__ import print_function  # print to sys.stderr
import code
import readline
import optparse
import unittest
import sys
import traceback
import atexit
from subprocess import Popen, PIPE
from mero import *
from ctypes import *


def address_get():
    try:
        p = Popen(['lctl', 'list_nids'], stdin=PIPE, stdout=PIPE, stderr=PIPE)
        output, err = p.communicate()
    except OSError:
        return ''
    # When the tool is executing without sudo privileges (i. e. with "--help"
    # option) then lctl output will be an empty string)
    return output.split()[0] if output else ''


default_libmero_path = '../../mero/.libs/libmero.so'
addr = address_get()
default_confd_ep = addr + ':12345:33:100'
default_rm_ep = addr + ':12345:33:100'
default_client_ep = addr + ":12345:33:200"


# Helper function to check the type of the function parameter. This is useful
# when we want to make sure that user execute a Spiel command with correct
# parameter types. Here is quote from ctypes documentation: "ctypes tries to
# protect you from calling functions with the wrong number of arguments or the
# wrong calling convention. Unfortunately this only works on Windows. It does
# this by examining the stack after the function returns, so although an error
# is raised the function has been called: To find out the correct calling
# convention you have to look into the C header file or the documentation for
# the function you want to call."
#
# It will be executed before annotated function. Helper takes a dictionary
# where key is parameter name and value is required parameter type. If all
# parameters pass type checking then the target function will be called,
# otherwise TypeError will be raised with error message containing information
# about invalid parameter.
#
# Example of usage:
# @require(fid=Fid)
# service_init(self, fid)
def require(**params):
    def check_types(func, params=params):
        def modified(*args, **kw):
            arg_names = func.func_code.co_varnames
            kw.update(zip(arg_names, args))
            for name, type in params.iteritems():
                param = kw[name]
                param_valid = param is None or isinstance(param, type)
                if not param_valid:
                    raise TypeError("Parameter'{0}' should be type '{1}'"
                                    .format(name, type.__name__))
            return func(**kw)
        return modified
    return check_types


# enum m0_conf_service_type
service_types = list(range(1, 10))
M0_CST_MDS, M0_CST_IOS, M0_CST_MGS, M0_CST_RMS, M0_CST_STS, M0_CST_HA,\
    M0_CST_SSS, M0_CST_SNS_REP, M0_CST_SNS_REB = service_types


# enum m0_cfg_storage_device_interface_type
storage_device_interface = list(range(1, 8))
M0_CFG_DEVICE_INTERFACE_ATA, M0_CFG_DEVICE_INTERFACE_SATA,\
    M0_CFG_DEVICE_INTERFACE_SCSI, M0_CFG_DEVICE_INTERFACE_SATA2,\
    M0_CFG_DEVICE_INTERFACE_SCSI2, M0_CFG_DEVICE_INTERFACE_SAS,\
    M0_CFG_DEVICE_INTERFACE_SAS2 = storage_device_interface


# enum m0_cfg_storage_device_media_type
storage_device_media_type = list(range(1, 5))
M0_CFG_DEVICE_MEDIA_DISK, M0_CFG_DEVICE_MEDIA_SSD, M0_CFG_DEVICE_MEDIA_TAPE,\
    M0_CFG_DEVICE_MEDIA_ROM = storage_device_media_type


#enum m0_sns_cm_status
sns_status = list(range(5))
SNS_CM_STATUS_INVALID, SNS_CM_STATUS_IDLE, SNS_CM_STATUS_STARTED,\
    SNS_CM_STATUS_FAILED, SNS_CM_STATUS_PAUSED = sns_status


# struct m0_fid
class Fid(Structure):
    _fields_ = [("f_container", c_uint64), ("f_key", c_uint64)]

    def __str__(self):
        return "<" + hex(self.f_container)[:-1] + ":" + str(self.f_key) + ">"


# struct m0_bitmap
class Bitmap(Structure):
    _fields_ = [("b_nr", c_uint32), ("b_words", POINTER(c_uint64))]


# struct m0_net_xprt
class NetXprt(Structure):
    _fields_ = [('nx_name', c_char_p), ('nx_ops', c_void_p)]


#struct m0_reqh_init_args
class ReqhInitArgs(Structure):
    _fields_ = [('rhia_dtm', c_void_p), ('rhia_db', c_void_p),
                ('rhia_mdstore', c_void_p), ('rhia_pc', c_void_p),
                ('rhia_fid', POINTER(Fid))]


# struct m0_pdclust_attr
class PdclustAttr(Structure):
    _fields_ = [('pa_Na', c_uint32), ('pa_K', c_uint32), ('pa_P', c_uint32),
                ('pa_unit_size', c_uint64), ('pa_seed', Fid)]


# Different service-specific parameters
# m0_spiel_service_info::svi_u
class ServiceInfoParameters(Union):
    _fields_ = [('repair_limits', c_uint32), ('addb_stobid', Fid),
                ('confdb_path', c_char_p)]


# struct m0_spiel_service_info
class ServiceInfo(Structure):
    _fields_ = [('svi_type', c_uint),
                ('svi_endpoints', POINTER(POINTER(c_char))),
                ('svi_u', ServiceInfoParameters)]


# struct m0_spiel_tx
class SpielTx:
    def __init__(self, spiel):
        self.data = None


class SpielSnsStatus(Structure):
    _fields_ = [('sss_fid', Fid),
                ('sss_state', c_uint),
                ('sss_progress', c_uint)]


class RunningServices(Structure):
    _fields_ = [('spls_fid', Fid), ('spls_name', c_char_p)]


class SpielWrapper:
    def __init__(self, mero):
        self.mero = CDLL(mero)
        self.mero.malloc.restype = c_void_p

    def spiel_start(self, server, client, rm_ep):
        self.confd_eps = c_char_p(server) if server is not None else c_char_p(
            default_confd_ep)
        self.client_ep = c_char_p(client) if client is not None else c_char_p(
            default_client_ep)
        self.rm_ep = c_char_p(rm_ep) if rm_ep is not None else c_char_p(
            default_rm_ep)
        self.__init_m0_instance()
        self.domain = self.__init_net_domain()
        self.buffer_pool = self.__net_buffer_pool_setup(self.domain)
        self.reqh = self.__init_reqh()
        self.rpc_machine = self.__init_rpc_machine(self.domain, self.reqh,
                                                   self.buffer_pool)
        self.spiel = self.__spiel_start(self.reqh)

    def spiel_stop(self):
        self.mero.m0_spiel_stop(self.spiel)
        self.__free(self.spiel)
        self.mero.m0_rpc_machine_fini(self.rpc_machine)
        self.__free(self.rpc_machine)
        self.mero.m0_reqh_fini(self.reqh)
        self.__free(self.reqh)
        self.mero.m0_rpc_net_buffer_pool_cleanup(self.buffer_pool)
        self.__free(self.buffer_pool)
        self.mero.m0_net_domain_fini(self.domain)
        self.__free(self.domain)
        self.mero.m0_fini(self.m0)
        self.__free(self.m0)

    @require(spiel_tx=SpielTx)
    def tx_open(self, spiel_tx):
        spiel_tx.data = self.allocate_memory(m0_spiel_tx__size())
        self.mero.m0_spiel_tx_open(self.spiel, spiel_tx.data)

    @require(spiel_tx=SpielTx)
    def tx_commit(self, spiel_tx):
        return self.mero.m0_spiel_tx_commit(spiel_tx.data)

    @require(spiel_tx=SpielTx)
    def tx_close(self, spiel_tx):
        rc = self.mero.m0_spiel_tx_close(spiel_tx.data)
        self.__free(spiel_tx.data)
        return rc

    @require(spiel_tx=SpielTx, fid=Fid)
    def profile_add(self, spiel_tx, fid):
        return self.mero.m0_spiel_profile_add(spiel_tx.data, byref(fid))

    @require(spiel_tx=SpielTx, fid=Fid, parent=Fid, redundancy=int,
             rootfid=Fid, mdpool=Fid, fs_params=list)
    def filesystem_add(self, spiel_tx, fid, parent, redundancy, rootfid, mdpool,
                       fs_params):
        # fs_params must be list of strings. Unfortunately ctypes can't
        # automatically convert list (or array) of strings to something
        # compatible with char**. The code below do this.

        # The line below is similar to:
        # char *fs_params[N], where N equals to len(fs_params)
        fs_params_p = (c_char_p * len(fs_params))()
        # The following line is similar to:
        # fs_params_p[0] = fs_params[0]
        # ...
        # fs_params_p[N] = fs_params[N]
        fs_params_p[:] = fs_params
        # Now ctypes can convert fs_params_p to char **
        return self.mero.m0_spiel_filesystem_add(spiel_tx.data, byref(fid),
                                                 byref(parent), redundancy,
                                                 byref(rootfid), byref(mdpool),
                                                 fs_params_p)

    @require(spiel_tx=SpielTx, fid=Fid, parent=Fid, memsize=long, nr_cpu=int,
             last_state=long, flags=long, pool_fid=Fid)
    def node_add(self, spiel_tx, fid, parent, memsize, nr_cpu, last_state,
                 flags, pool_fid):
        return self.mero.m0_spiel_node_add(spiel_tx.data, byref(fid),
                                           byref(parent), memsize, nr_cpu,
                                           last_state, flags, byref(pool_fid))

    @require(spiel_tx=SpielTx, fid=Fid, parent=Fid, cores=Bitmap,
             memory_limit_as=long, memory_limit_rss=long,
             memory_limit_stack=long, memory_limit_memlock=long)
    def process_add(self, spiel_tx, fid, parent, cores, memory_limit_as,
                    memory_limit_rss, memory_limit_stack,
                    memory_limit_memlock):
        return self.mero.m0_spiel_process_add(spiel_tx.data, byref(fid),
                                              byref(parent), byref(cores),
                                              c_uint64(memory_limit_as),
                                              c_uint64(memory_limit_rss),
                                              c_uint64(memory_limit_memlock),
                                              c_uint64(memory_limit_stack))

    @require(spiel_tx=SpielTx, fid=Fid, parent=Fid, svc_type=int,
             svc_endpoints=list, svc_params=ServiceInfoParameters)
    def service_add(self, spiel_tx, fid, parent, svc_type, svc_endpoints,
                    svc_params):
        if svc_type not in service_types:
            print("Invalid service type" + str(svc_type), file=sys.stderr)
            sys.exit(1)
        endpoints_p = (c_char_p * len(svc_endpoints))()
        endpoints_p[:] = svc_endpoints
        svc_info = ServiceInfo(svc_type, cast(endpoints_p,
                               POINTER(POINTER(c_char))), svc_params)
        return self.mero.m0_spiel_service_add(spiel_tx.data, byref(fid),
                                              byref(parent), byref(svc_info))

    @require(spiel_tx=SpielTx, fid=Fid, parent=Fid, iface=int, media=int,
             bsize=int, size=long, last_state=long, flags=long, filename=str)
    def device_add(self, spiel_tx, fid, parent, disk, iface, media, bsize,
                   size, last_state, flags, filename):
        if iface not in storage_device_interface:
            print("Invalid storage device interface " + str(iface))
            sys.exit(1)
        if media not in storage_device_media_type:
            print("Invalid storage device media type " + str(media))
            sys.exit(1)
        return self.mero.m0_spiel_device_add(spiel_tx.data, byref(fid),
                                             byref(parent), byref(disk), iface,
                                             media, bsize, size, last_state,
                                             flags, filename)

    @require(spiel_tx=SpielTx, fid=Fid, parent=Fid, order=int)
    def pool_add(self, spiel_tx, fid, parent, order):
        return self.mero.m0_spiel_pool_add(spiel_tx.data, byref(fid),
                                           byref(parent), order)

    @require(spiel_tx=SpielTx, fid=Fid, parent=Fid)
    def rack_add(self, spiel_tx, fid, parent):
        return self.mero.m0_spiel_rack_add(spiel_tx.data, byref(fid),
                                           byref(parent))

    @require(spiel_tx=SpielTx, fid=Fid, parent=Fid)
    def enclosure_add(self, spiel_tx, fid, parent):
        return self.mero.m0_spiel_enclosure_add(spiel_tx.data, byref(fid),
                                                byref(parent))

    @require(spiel_tx=SpielTx, fid=Fid, parent=Fid, node=Fid)
    def controller_add(self, spiel_tx, fid, parent, node):
        return self.mero.m0_spiel_controller_add(spiel_tx.data, byref(fid),
                                                 byref(parent), byref(node))

    @require(spiel_tx=SpielTx, fid=Fid, parent=Fid)
    def disk_add(self, spiel_tx, fid, parent):
        return self.mero.m0_spiel_disk_add(spiel_tx.data, byref(fid),
                                           byref(parent))

    @require(spiel_tx=SpielTx, fid=Fid, parent=Fid, attrs=PdclustAttr)
    def pool_version_add(self, spiel_tx, fid, parent, attrs):
        return self.mero.m0_spiel_pool_version_add(spiel_tx.data, byref(fid),
                                                   byref(parent), byref(attrs))

    @require(spiel_tx=SpielTx, fid=Fid, parent=Fid, real=Fid)
    def rack_v_add(self, spiel_tx, fid, parent, real):
        return self.mero.m0_spiel_rack_v_add(spiel_tx.data, byref(fid),
                                             byref(parent), byref(real))

    @require(spiel_tx=SpielTx, fid=Fid, parent=Fid, real=Fid)
    def enclosure_v_add(self, spiel_tx, fid, parent, real):
        return self.mero.m0_spiel_enclosure_v_add(spiel_tx.data, byref(fid),
                                                  byref(parent), byref(real))

    @require(spiel_tx=SpielTx, fid=Fid, parent=Fid, real=Fid)
    def controller_v_add(self, spiel_tx, fid, parent, real):
        return self.mero.m0_spiel_controller_v_add(spiel_tx.data, byref(fid),
                                                   byref(parent), byref(real))

    @require(spiel_tx=SpielTx, fid=Fid, parent=Fid, real=Fid)
    def disk_v_add(self, spiel_tx, fid, parent, real):
        return self.mero.m0_spiel_disk_v_add(spiel_tx.data, byref(fid),
                                             byref(parent), byref(real))

    @require(spiel_tx=SpielTx, fid=Fid)
    def pool_version_done(self, spiel_tx, fid):
        return self.mero.m0_spiel_pool_version_done(spiel_tx.data, byref(fid))

    @require(spiel_tx=SpielTx, fid=Fid)
    def element_del(self, spiel_tx, fid):
        return self.mero.m0_spiel_element_del(spiel_tx.data, byref(fid))

    @require(profile=str)
    def cmd_profile_set(self, profile):
        return self.mero.m0_spiel_cmd_profile_set(self.spiel, profile)

    @require(fid=Fid)
    def service_init(self, fid):
        return self.mero.m0_spiel_service_init(self.spiel, byref(fid))

    @require(fid=Fid)
    def service_start(self, fid):
        return self.mero.m0_spiel_service_start(self.spiel, byref(fid))

    @require(fid=Fid)
    def service_quiesce(self, fid):
        return self.mero.m0_spiel_service_quiesce(self.spiel, byref(fid))

    @require(fid=Fid)
    def service_stop(self, fid):
        return self.mero.m0_spiel_service_stop(self.spiel, byref(fid))

    @require(fid=Fid)
    def service_health(self, fid):
        return self.mero.m0_spiel_service_health(self.spiel, byref(fid))

    @require(fid=Fid)
    def device_attach(self, fid):
        return self.mero.m0_spiel_device_attach(self.spiel, byref(fid))

    @require(fid=Fid)
    def device_detach(self, fid):
        return self.mero.m0_spiel_device_detach(self.spiel, byref(fid))

    @require(fid=Fid)
    def device_format(self, fid):
        return self.mero.m0_spiel_device_format(self.spiel, byref(fid))

    @require(fid=Fid)
    def process_stop(self, fid):
        return self.mero.m0_spiel_process_stop(self.spiel, byref(fid))

    @require(fid=Fid)
    def process_reconfig(self, fid):
        return self.mero.m0_spiel_process_reconfig(self.spiel, byref(fid))

    @require(fid=Fid)
    def process_health(self, fid):
        return self.mero.m0_spiel_process_health(self.spiel, byref(fid))

    @require(fid=Fid)
    def process_quiesce(self, fid):
        return self.mero.m0_spiel_process_quiesce(self.spiel, byref(fid))

    @require(fid=Fid)
    def process_list_services(self, fid, svc_list=RunningServices):
        return self.mero.m0_spiel_process_list_services(self.spiel, byref(fid),
                                                        byref(svc_list))

    @require(fid=Fid)
    def pool_repair_start(self, fid):
        return self.mero.m0_spiel_pool_repair_start(self.spiel, fid)

    @require(fid=Fid)
    def pool_repair_quiesce(self, fid):
        return self.mero.m0_spiel_pool_repair_quiesce(self.spiel, fid)

    @require(fid=Fid)
    def pool_repair_continue(self, fid):
        return self.mero.m0_spiel_pool_repair_continue(self.spiel, fid)

    @require(fid=Fid, status=SpielSnsStatus)
    def pool_repair_status(self, fid, status):
        return self.mero.m0_spiel_pool_repair_continue(self.spiel, fid,
                                                       byref(status))

    @require(fid=Fid)
    def pool_rebalance_start(self, fid):
        return self.mero.m0_spiel_pool_rebalance_start(self.spiel, fid)

    @require(fid=Fid)
    def pool_rebalance_quiesce(self, fid):
        return self.mero.m0_spiel_pool_rebalance_quiesce(self.spiel, fid)

    @require(fid=Fid)
    def pool_rebalance_continue(self, fid):
        return self.mero.m0_spiel_pool_rebalance_continue(self.spiel, fid)

    @require(fid=Fid, status=SpielSnsStatus)
    def pool_rebalance_status(self, fid, status):
        return self.mero.m0_spiel_pool_repair_continue(self.spiel, fid,
                                                       byref(status))

    def __init_m0_instance(self):
        self.m0 = self.allocate_memory(m0__size())
        result = self.mero.m0_init(self.m0)
        if result != 0:
            raise RuntimeError("m0_init failed, rc = " + str(result))

    def __init_net_domain(self):
        domain = self.allocate_memory(m0_net_domain__size())
        xprt = NetXprt.in_dll(self.mero, 'm0_net_lnet_xprt')
        xprt_p = pointer(xprt)
        result = self.mero.m0_net_domain_init(domain, xprt_p)
        if result != 0:
            raise RuntimeError("m0_net_domain_init failed, rc = " +
                               str(result))
        return domain

    def __net_buffer_pool_setup(self, domain):
        buffer_pool = self.allocate_memory(m0_net_buffer_pool__size())
        result = self.mero.m0_rpc_net_buffer_pool_setup(domain, buffer_pool,
                                                        c_uint32(2),
                                                        c_uint32(1))
        if result != 0:
            raise RuntimeError("m0_rpc_net_buffer_pool_setup, rc = " +
                               str(result))
        return buffer_pool

    def __init_reqh(self):
        reqh = self.allocate_memory(m0_reqh__size())
        reqh_args = ReqhInitArgs()
        reqh_args.rhia_fid = pointer(Fid(0x7200000000000001, 5))
        reqh_args.rhia_mdstore = 1
        result = self.mero.m0_reqh_init(reqh, byref(reqh_args))
        if result != 0:
            raise RuntimeError("m0_reqh_init, rc = " + str(result))
        self.__free(reqh_args)
        return reqh

    def __init_rpc_machine(self, domain, reqh, buffer_pool):
        rpc_machine = self.allocate_memory(m0_rpc_machine__size())
        result = self.mero.m0_rpc_machine_init(rpc_machine, domain,
                                               self.client_ep, reqh,
                                               buffer_pool, c_uint(~0),
                                               c_uint(1 << 17), c_uint(2))
        if result != 0:
            raise RuntimeError("m0_rpc_machine_init, rc = " + str(result))
        return rpc_machine

    def __spiel_start(self, reqh):
        spiel = self.allocate_memory(m0_spiel__size())
        confd_eps_p = pointer(self.confd_eps)
        result = self.mero.m0_spiel_start(spiel, reqh, confd_eps_p,
                                          self.rm_ep)
        if result != 0:
            raise RuntimeError("m0_spiel_start, rc = " + str(result))
        return spiel

    def allocate_memory(self, size):
        ptr = self.mero.malloc(size)
        memset(ptr, 0, size)
        return ptr

    def __free(self, ptr):
        self.mero.free(ptr)


class SpielTool:
    def __init__(self, mero, server, client, rm_ep):
        self.spiel = SpielWrapper(mero)
        #self.spiel.spiel_start(server, client, profile)

    #def __del__(self):
        #self.spiel.spiel_stop()

    def interactive_console_create(self):
        #vars = globals()
        #vars.update({'spiel': tool.spiel})
        #readline.set_completer(rlcompleter.Completer(vars).complete)
        #readline.parse_and_bind("tab: complete")
        #self.shell = code.InteractiveConsole(vars)
        #self.shell.interact()
        vars = globals()
        vars.update({'spiel': tool.spiel})
        return code.InteractiveConsole(vars)


class SpielToolTest(unittest.TestCase):
    def setUp(self):
        self.spiel = tool.spiel
        self.spielTx = SpielTx(self.spiel.spiel)
        self.svc_fid = Fid(0x7300000000000001, 1)
        self.fid = Fid(1, 1)
        self.parent = Fid(2, 2)
        self.real = Fid(1, 2)
        self.Bitmap = Bitmap(32, 0)
        self.Bitmap.b_words = allocate_memory(32)

    def test_typed_parameters(self):
        self.assertRaises(TypeError, self.spiel.tx_open, "Wrong type")

    def test_spiel_functions(self):
        tests = [('tx_open', self.spielTx),
                 ('tx_commit', self.spielTx),
                 ('tx_close', self.spielTx),
                 ('profile_add', self.spielTx, self.fid),
                 ('filesystem_add', self.spielTx, self.fid, self.parent, 1,
                  Fid(3, 3), [b'param1', b'param2']),
                 ('node_add', self.spielTx, self.fid, self.parent, 1L, 1, 1L,
                  1L, Fid(4, 4)),
                 ('process_add', self.spielTx, self.fid, self.parent,
                  self.Bitmap, 1L, 2, 3, 4),
                 ('service_add', self.spielTx, self.fid, self.parent,
                  ServiceInfo()),
                 ('device_add', self.spielTx, self.fid, self.parent, 1, 1, 1,
                  1L, 1L, 1L, "device"),
                 ('pool_add', self.spielTx, self.fid, self.parent, 1),
                 ('rack_add', self.spielTx, self.fid, self.parent),
                 ('enclosure_add', self.spielTx, self.fid, self.parent),
                 ('controller_add', self.spielTx, self.fid, Fid(5, 5),
                  self.parent),
                 ('disk_add', self.spielTx, self.fid, self.parent),
                 ('pool_version_add', self.spielTx, self.fid, self.parent,
                  PdclustAttr()),
                 ('rack_v_add', self.spielTx, self.fid, self.parent,
                  self.real),
                 ('enclosure_v_add', self.spielTx, self.fid, self.parent,
                  self.real),
                 ('controller_v_add', self.spielTx, self.fid, self.parent,
                  self.real),
                 ('disk_v_add', self.spielTx, self.fid, self.parent,
                  self.real),
                 ('pool_version_done', self.spielTx, self.fid),
                 ('element_del', self.spielTx, self.fid),
                 ('service_init', self.svc_fid),
                 ('service_start', self.svc_fid),
                 ('service_quiesce', self.svc_fid),
                 ('service_stop', self.svc_fid),
                 ('service_health', self.svc_fid),
                 ('device_attach', self.fid),
                 ('device_detach', self.fid),
                 ('device_format', self.fid),
                 ('process_stop', self.fid),
                 ('process_reconfig', self.fid),
                 ('process_health', self.fid),
                 ('process_quiesce', self.fid),
                 ('process_list_services', self.fid, None),
                 ('pool_repair_start', self.fid),
                 ('pool_repair_quiesce', self.fid),
                 ('pool_repair_continue', self.fid),
                 ('pool_rebalance_start', self.fid),
                 ('pool_rebalance_quiesce', self.fid),
                 ('pool_rebalance_continue', self.fid)]
        try:
            for t in tests:
                self.assertNotEqual(getattr(self.spiel, t[0])(*t[1:]), None)
        except AssertionError:
            print('Failed test: ' + t[0])
            raise


class MyParser(optparse.OptionParser):
    def format_usage(self, formatter):
        return self.usage


def create_arguments_parser():
    parser = MyParser(usage='''sudo ./m0spiel [options]

Spiel commands interpreter.

The tool must be executed with sudo command and RPC server must be started
before the tool execution:

\tsudo m0t1fs/linux_kernel/st/m0t1fs_server.sh start default
\tcd utils/m0spiel
\tsudo ./m0spiel

Internally the tool has a number of classes that match corresponding C
structures. Spiel functions work with the following Mero objects:
\t1. Fid (struct m0_fid)
\t3. PdclustAttr (struct m0_pdclust_attr)
\t4. ServiceInfo (struct m0_spiel_service_info)
\t5. SpielTx (struct m0_spiel_tx)
User can create an instance of any class listed above and pass it to a spiel
function.

After the tool is initialized, user has access to object named "spiel" and may
call a function from Spiel library. Each wrapper function is similar to the
corresponding function from C except that user doesn't need to pass Spiel
(m0_spiel) instance.

The following example illustrates usage of the tool:

Execute commands from command line:

\techo -e 'print(spiel_service_init(Fid(1,1)))' | sudo ./m0spiel''')
    parser.add_option('--self-check', action='store_true',
                      help='Run unit tests and exit')
    parser.add_option('--server', '-s', default=default_confd_ep,
                      help='Confd endpoint. Default value: ' +
                      default_confd_ep)
    parser.add_option('--client', '-c', default=default_client_ep,
                      help='Client endpoint. Default value: ' +
                      default_client_ep)
    parser.add_option('-l', default=default_libmero_path, dest='mero',
                      help='Path to libmero.so. Default value: ' +
                      default_libmero_path)
    parser.add_option('--rmservice', '-r', default=default_rm_ep, dest='rm_ep',
                      help='Default endpoint of RM service. Default value: ' +
                      default_rm_ep)
    return parser


if __name__ == "__main__":
    parser = create_arguments_parser()
    args, _ = parser.parse_args()
    try:
        tool = SpielTool(args.mero, args.server, args.client, args.rm_ep)
        atexit.register(tool.spiel.spiel_stop)
        tool.spiel.spiel_start(args.server, args.client, args.rm_ep)
    except RuntimeError as e:
        print('an error occurred: ' + str(e), file=sys.stderr)
        print('-' * 80, file=sys.stderr)
        traceback.print_exc(file=sys.stderr)
        print('-' * 80, file=sys.stderr)
        sys.exit(1)
    if args.self_check:
        unittest.main(argv=sys.argv[:1])
    else:
        interpreter = tool.interactive_console_create()
        prompt = '> ' if sys.stdin.isatty() else ''
        while 1:
            try:
                s = raw_input(prompt)
                res = interpreter.push(s)
            except (EOFError, KeyboardInterrupt):
                break
