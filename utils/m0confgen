#!/usr/bin/env python

from __future__ import print_function

from ply import lex, yacc
from optparse import OptionParser  # TODO: use `argparse'
import textwrap
import unittest
import sys
from errno import EPIPE


__copyright__ = """COPYRIGHT 2017 XYRATEX TECHNOLOGY LIMITED

THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.

YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
http://www.xyratex.com/contact
"""
__author__ = 'Valery V. Vorotyntsev <valery.vorotyntsev@seagate.com>'
__version__ = '1.6.5'
__all__ = ['conf_objs_encode', 'conf_obj_encode']
__doc__ = """Configuration string generator.

Generates configuration string in xcode_read format from its
human-friendly description.

%(input_format)s
"""


input_format = """Input format:

    input   = [ seq(obj) ]
    seq(t)  = *( t )
    csv(t)  = t | csv(t) "," t
    obj     = "(" objid *( attr ) ")"
    objid   = objtype "-" [ NUMBER ":" ] NUMBER
    attr    = ID "=" ( NUMBER | STRING | fid | objid | list )
    fid     = "(" NUMBER "," NUMBER ")"
    list    = "[" [ csv(NUMBER) | csv(STRING) | csv(objid) ] "]"
    objtype = { %(objtypes)s }

Notes on objid specification:

    Generic descriptor
        <objtype>-<container>:<key>
    may be shortened to
        <objtype>-<key>
    when the <container> part is 1.

Examples:

    (root-0 verno=1 profiles=[profile-2:3])
    (profile-2:3 filesystem=filesystem-1)
    (filesystem-1 rootfid=(11, 12) redundancy=41212
        params=["param-0", "param-1", "param-2"]
        mdpool=pool-4 imeta_pver=(0, 0)
        nodes=[node-2] pools=[pool-4, pool-5] racks=[])

Configuration object types and attributes:

    %(attrs)s"""


class Error(Exception):
    pass

# --------------------------------------------------------------------
# Conf

# NOTE: These definitions should be in sync with m0_confx_* structures
# in conf/onwire.h.
#
# The attributes included in DOT output are marked with '!'.
conf_obj_types = {
    'root': ('t',  # 0x74
             'verno=NUMBER !profiles=[objid]'),
    'profile': ('p',  # 0x70
                '!filesystem=objid'),
    'filesystem': ('f',  # 0x66
                   'rootfid=fid redundancy=NUMBER params=[STRING]'
                   ' mdpool=objid imeta_pver=fid'
                   ' !nodes=[objid] !pools=[objid] !racks=[objid]'),
    'pool': ('o',  # 0x6f
             'order=NUMBER !pvers=[objid]'),
    'pver': ('v',  # 0x76 -- actual pver
             '0|N=NUMBER K=NUMBER P=NUMBER tolerance=[NUMBER]'
             ' !rackvs=[objid]'),
    'pver_f': ('v',  # 0x76 -- formulaic pver
               '1|id=NUMBER base=objid allowance=[NUMBER]'),
    'objv': ('j',  # 0x6a
             'real=objid !children=[objid]'),
    'node': ('n',  # 0x6e
             'memsize=NUMBER nr_cpu=NUMBER last_state=NUMBER flags=NUMBER'
             ' pool_id=objid !processes=[objid]'),
    'process': ('r',  # 0x72
                'cores=[NUMBER] mem_limit_as=NUMBER mem_limit_rss=NUMBER'
                ' mem_limit_stack=NUMBER mem_limit_memlock=NUMBER'
                ' endpoint=STRING !services=[objid]'),
    'service': ('s',  # 0x73
                'type=NUMBER endpoints=[STRING] !sdevs=[objid]'),
    'sdev': ('d',  # 0x64
             'dev_idx=NUMBER iface=NUMBER media=NUMBER bsize=NUMBER'
             ' size=NUMBER last_state=NUMBER flags=NUMBER filename=STRING'),
    'rack': ('a',  # 0x61
             '!encls=[objid] pvers=[objid]'),
    'enclosure': ('e',  # 0x65
                  '!ctrls=[objid] pvers=[objid]'),
    'controller': ('c',  # 0x63
                   'node=objid !disks=[objid] pvers=[objid]'),
    'disk': ('k',  # 0x6b
             'dev=objid pvers=[objid]')
}


def maybe_conf_fid(fid):
    """Tries to convert given fid into a conf_fid.

    Returns None if conversion is not possible, i.e. if the fid is not
    of a conf object.

    Otherwise returns conf_fid in one of the following formats:
      (<objtype>, (<container>, <key>)) # <container> != 1
      (<objtype>, <key>)                # <container> == 1
    """
    container, key = fid
    fid_type = chr(container >> 56)  # see M0_FID_TCONTAINER()
    container &= 0x00ffffffffffffff

    if fid_type not in char_to_objtype:
        return None
    t = char_to_objtype[fid_type]

    if type(t) is tuple:
        # XXX Anomaly.
        t = filter(lambda x: container >> 54 == conf_obj_types[x].union_tag,
                   t)
        if not t:
            return None
        assert len(t) == 1 and t[0].startswith('pver')
        t = t[0]
        container &= 0x003fffffffffffff

    if container == 1:
        return t, key
    else:
        return t, (container, key)


def fid_scan(s):  # see m0_fid_sscanf()
    def int16(x):
        return int(x, base=16)

    try:
        fid = tuple(map(int16, s.strip('<>').split(':', 1)))
    except ValueError:
        fid = []
    if len(fid) != 2:
        raise Error('Invalid fid: ' + s)
    return fid


def fid_translate(fid):
    x = maybe_conf_fid(fid)
    if x is not None:
        return conf_fid_encode(x, from_xcode=True)
    container, key = fid
    if container >> 56 == 0x44:  # 'D'
        # m0_conf_dir; see dir_id_build()
        parent_id = (container & 0xffffffffff, key)
        if parent_id[0] == 1:
            parent_id = key  # otherwise conf_fid_encode() would fail

        def _flatten(t):
            if type(t) is tuple:
                # Anomaly.
                assert all([x.startswith('pver') for x in t])
                return 'pver'
            return t

        parent_type = _flatten(char_to_objtype[chr(container >> 48 & 0xff)])
        children_type = _flatten(char_to_objtype[chr(container >> 40 & 0xff)])
        return 'dir_{}_{}'.format(
            conf_fid_encode((parent_type, parent_id), from_xcode=True),
            children_type)


def list_encode(xs, sep=' ', from_xcode=False):
    assert xs == [] or set(map(type, xs)) == set([str]), 'xs :: [str]'
    # ['a', 'b', 'c']
    if from_xcode:
        return '[' + (',' + sep).join(xs) + ']'  # ==> '[a, b, c]'
    return '[{}:{}{}]'.format(len(xs), sep, (',' + sep).join(xs)) if xs \
        else '[0]'  # ==> '[3: a, b, c]'


def fid_encode(fid, from_xcode=False):
    if type(fid[0]) is int:
        # (9, 10) ==> '(0x9, 0xa)'
        return '(%#x, %#x)' % fid
    return conf_fid_encode(fid, from_xcode)


def conf_fid_encode(conf_fid, from_xcode=False):
    a, b = conf_fid
    assert a in conf_obj_types.keys()  # only conf_fids are accepted
    if type(b) is tuple:
        assert b[0] != 1
    else:
        b = (1, b)
    if from_xcode:
        return a + '-' + ('{1}' if b[0] == 1 else '{0}:{1}').format(*b)
    if a == 'pver_f':
        # XXX Anomaly.
        return '^%c|0x%x:%u' % (ord(conf_obj_types[a].ft_id),
                                1 << 54 | b[0],
                                b[1])
    return '^%c|%u:%u' % ((conf_obj_types[a].ft_id,) + b)


def _check_attrs(obj, from_xcode):
    objid, actual = obj
    assert type(actual) is (list if from_xcode else dict)
    expected = conf_obj_types[objid[0]].attrs
    if from_xcode:
        if len(actual) != len(expected):
            raise Error("""Invalid '{}' specification
Expected {} attributes, got {}""".format(objid[0], len(expected), len(actual)))
    else:
        actual = set(actual.keys())
        expected = set([a.name for a in expected])
        if actual != expected:
            diff = {'Missing': expected.difference(actual),
                    'Unknown': actual.difference(expected)}
            assert diff['Missing'] or diff['Unknown']
            msg = "Invalid '%s' specification" % objid[0]
            for adj, xs in diff.items():
                if xs:
                    msg += '\n{} attribute{}: {}'.format(
                        adj,
                        's' if len(xs) > 1 else '',
                        ', '.join(map(repr, xs)))
            raise Error(msg)


def conf_obj_encode(obj, from_xcode=False, enc=None):
    _check_attrs(obj, from_xcode)
    objid, attrs = obj
    otype = conf_obj_types[objid[0]]
    if from_xcode:
        attrs = dict([(a.name, v) for v, a in zip(attrs, otype.attrs)])

    if enc is None:
        enc = encode_from_xcode if from_xcode else encode_to_xcode
    else:
        assert callable(enc)
    return enc(objid, attrs, otype)


def encode_to_xcode(objid, attrs, otype):
    if hasattr(otype, 'union_tag'):
        fmt = '{{0x{ft_id:x}| (({fid}), {{{0.union_tag}| ({attrs})}})}}'
    else:
        fmt = '{{0x{ft_id:x}| (({fid}), {attrs})}}'
    return fmt.format(
        otype, ft_id=ord(otype.ft_id), fid=conf_fid_encode(objid),
        attrs=', '.join(a.encode(attrs[a.name]) for a in otype.attrs))


def encode_from_xcode(objid, attrs, otype):
        return '(%s %s)' % (
            conf_fid_encode(objid, from_xcode=True),
            ' '.join(['%s=%s' % (a.name,
                                 a.encode(attrs[a.name], from_xcode=True))
                      for a in otype.attrs]))


def encode_to_dot(objid, attrs, otype):
    indent = ' '*4
    fid = conf_fid_encode(objid, from_xcode=True)
    s = ''
    for a in otype.attrs:
        if not a.visualize_p:
            continue
        if type(attrs[a.name]) is list:
            # directory
            if not attrs[a.name] and objid[0] == 'objv':
                # XXX Anomaly.
                # objv's directory is empty ==> we consider this objv
                # to be a disk-v.  There is no directory linked to a disk-v
                # object (m0_conf_objv::cv_children pointer is NULL), and we
                # should not draw one.
                s += """\
{indent}"{fid}";
""".format(indent=indent, fid=fid)
                break
            dir_id = 'dir_%s_%s' % (fid, a.name)
            s += """\
{indent}"{dir_id}" [height=0.15, width=0.15, label=""];
{indent}"{fid}" -> "{dir_id}" [label={relation}];
""".format(indent=indent, dir_id=dir_id, fid=fid, relation=a.name)
            for objid in attrs[a.name]:
                s += """\
{indent}"{dir_id}" -> "{fid}";
""".format(indent=indent, dir_id=dir_id,
           fid=conf_fid_encode(objid, from_xcode=True))
        else:
            # not a directory
            s += """\
{indent}"{fid}" -> "{target}" [label={relation}];
""".format(indent=indent, fid=fid,
           target=conf_fid_encode(attrs[a.name], from_xcode=True),
           relation=a.name)
    return s


def encode_to_dot_simplified(objid, attrs, otype):
    if objid[0] not in ('node', 'process', 'service'):
        return
    indent = ' '*4
    fid = conf_fid_encode(objid, from_xcode=True)
    s = ''
    xlabel = dot_simplified_xlabel(objid[0], attrs)
    if xlabel:
        s += """\
{indent}"{fid}" [label="{fid}\\n{xlabel}"];
""".format(indent=indent, fid=fid, xlabel=xlabel)
    if objid[0] == 'service':
        return s  # leaf level
    for a in otype.attrs:
        if not a.visualize_p:
            continue
        if type(attrs[a.name]) is list:
            # directory
            for objid in attrs[a.name]:
                s += """\
{indent}"{parent}" -> "{child}";
""".format(indent=indent, parent=fid,
           child=conf_fid_encode(objid, from_xcode=True))
        else:
            # not a directory
            s += """\
{indent}"{fid}" -> "{target}" [label={relation}];
""".format(indent=indent, fid=fid,
           target=conf_fid_encode(attrs[a.name], from_xcode=True),
           relation=a.name)
    return s


# See m0_conf_service_type.
conf_service_types = (
    'MDS',  # = 1
    'IOS', 'MGS', 'RMS', 'STS', 'HA', 'SSS', 'SNS_REP', 'SNS_REB', 'ADDB2',
    'CAS',
    '_DS1', '_DS2'  # UT-specific
)


def dot_simplified_xlabel(objtype, attrs):
    if objtype == 'process':
        return attrs['endpoint']
    if objtype == 'service':
        t = attrs['type']
        if 0 < t <= len(conf_service_types):
            s = conf_service_types[t-1]
        else:
            s = '?%d?' % t
        if attrs['sdevs']:
            return '%s, %u sdevs' % (s, len(attrs['sdevs']))
        return s
    assert objtype == 'node'


def all_unique(xs):
    """Returns True iff all entries of the sequence are unique."""
    return len(xs) == len(set(xs))


def check_ids(xs):
    if not all_unique(xs):
        duplicates = set([x for x in xs if xs.count(x) > 1])
        assert duplicates
        raise Error('Duplicated identifier%s: %s' % (
            's' if len(duplicates) > 1 else '',
            ', '.join(map(str, duplicates))))


def conf_objs_encode(objs, from_xcode=False, enc=None):
    check_ids([objid for objid, _ in objs])
    objs = map(lambda x: conf_obj_encode(x, from_xcode=from_xcode, enc=enc),
               objs)
    if enc is not None:
        return '\n'.join(filter(None, objs))
    return '\n'.join(objs) if from_xcode else list_encode(objs, sep='\n ')


def conf_objs_encode_to_dot(objs, from_xcode=False, mode='full'):
    enc = {
        'full': encode_to_dot,
        'simplified': encode_to_dot_simplified
    }[mode]
    return """\
digraph x {
    edge [arrowhead=open, fontsize=11];

%s}""" % conf_objs_encode(objs, from_xcode, enc)


def quote(s, from_xcode=False):
    return '"%s"' % s


def conf_type2enc(t):
    list_p = False
    if t[0] == '[':
        assert t[-1] == ']'
        list_p = True
        t = t[1:-1]
    enc = {
        'NUMBER': lambda n, from_xcode=False: str(n),
        'STRING': quote,
        'fid': fid_encode,
        'objid': conf_fid_encode
    }[t]
    if list_p:
        def list_enc(xs, from_xcode=False):
            xs = map(lambda x: enc(x, from_xcode=from_xcode), xs)
            return list_encode(xs, from_xcode=from_xcode)
        return list_enc
    else:
        return enc


class ConfObjAttr(object):
    def __init__(self, key, value):
        self.encode = conf_type2enc(value)
        if key.startswith('!'):
            self.name = key[1:]  # drop leading '!'
            self.visualize_p = True
        else:
            self.name = key
            self.visualize_p = False


class ConfObjType(object):
    def __init__(self, ft_id, desc):
        self.ft_id = ft_id
        if desc[1] == '|':
            self.union_tag = int(desc[0])
            desc = desc[2:]
        self.attrs = [ConfObjAttr(*a.split('=', 1)) for a in desc.split()]
        self.desc = desc.replace('!', '')


conf_obj_types = dict((t, ConfObjType(*v)) for t, v in conf_obj_types.items())


# Mapping from ft_id to objtype: { 'a': 'rack', 'c': 'controller', ... }
char_to_objtype = {}
for t, v in conf_obj_types.items():
    if v.ft_id in char_to_objtype:
        x = char_to_objtype[v.ft_id]
        # XXX Anomaly.
        assert t.startswith('pver')
        assert type(x) is str
        char_to_objtype[v.ft_id] = (x, t)
    else:
        char_to_objtype[v.ft_id] = t


input_format = input_format % {
    'objtypes': ' | '.join(map(quote, sorted(conf_obj_types.keys()))),
    'attrs': '\n    '.join('%-14s%s' % (
        t + ':',
        textwrap.fill(v.desc, width=60, subsequent_indent=' '*22,
                      break_long_words=False))
                           for t, v in sorted(conf_obj_types.items()))
}
__doc__ = __doc__ % {'input_format': input_format}

# --------------------------------------------------------------------
# Lexer


class Lexer(object):

    tokens = ('HEXNUM', 'OCTNUM', 'DECNUM', 'STRING', 'ID')
    literals = '()[]-=,:'
    t_ignore = ' \t\r\v'
    t_ID = r'\b[a-zA-Z]\w*\b'

    def __init__(self, **kwargs):
        self.lexer = lex.lex(module=self, **kwargs)
        self.input = self.lexer.input
        self.token = self.lexer.token
        self.lineno = self.lexer.lineno
        self.lexpos = self.lexer.lexpos

    def t_HEXNUM(self, t):
        r'\b0[xX][0-9a-fA-F]+\b'
        t.value = int(t.value, 16)
        return t

    def t_OCTNUM(self, t):
        r'\b0[0-7]+\b'
        t.value = int(t.value, 8)
        return t

    def t_DECNUM(self, t):
        r'\b\d+\b'
        t.value = int(t.value)
        return t

    def t_STRING(self, t):
        r'"[^"]*"'
        t.value = t.value[1:-1]
        return t

    def t_comment(self, t):
        r'\#.*'

    def t_newline(self, t):
        r'\n+'
        t.lexer.lineno += len(t.value)

    def t_error(self, t):
        raise Error("Illegal character '%s' at byte %u" % (t.value[0],
                                                           t.lexpos + 1))

    def test(self, data):
        self.input(data)
        while True:
            t = self.token()
            if t is None:
                break
            print(t, file=sys.stderr)


class XCLexer(Lexer):

    literals = Lexer.literals + '{}|^'

# --------------------------------------------------------------------
# Parsers

# According to PLY documentation [6.12 Miscellaneous Yacc Notes;
# http://www.dabeaz.com/ply/ply.html#ply_nn36]:
#
# | [...] be aware that only one parser may be defined in a single module
# | (source file). There are various error checks and validation steps
# | that may issue confusing error messages if you try to define multiple
# | parsers in the same source file.
#
# That is why there is no global `parser' variable defined.


class _BaseParser(object):

    debug = False  # create `parser.out'?
    write_tables = False  # create `parsetab.py'?
    tracking = True  # track positions of all grammar symbols, not only tokens?

    def __init__(self, **kwargs):
        assert hasattr(self, 'lexer')
        assert hasattr(self, 'start')
        self.tokens = Lexer.tokens
        kwargs.setdefault('debug', self.debug)
        kwargs.setdefault('write_tables', self.write_tables)
        self.parser = yacc.yacc(module=self, **kwargs)

    def parse(self, *args, **kwargs):
        kwargs.setdefault('lexer', self.lexer)
        kwargs.setdefault('tracking', self.tracking)
        return self.parser.parse(*args, **kwargs)

    def p_empty(self, p):
        """empty :"""

    def p_number(self, p):
        """number : DECNUM
                  | HEXNUM
                  | OCTNUM
        """
        p[0] = p[1]

    def p_fid(self, p):
        """fid : '(' number ',' number ')'"""
        p[0] = p[2], p[4]

    def p__ns(self, p):
        """numbers : number
                   | numbers ',' number
           strings : STRING
                   | strings ',' STRING
        """
        if len(p) == 2:
            p[0] = [p[1]]
        else:
            p[0] = p[1] + [p[3]]

    def position(self, p, n):
        return ' at byte %u' % (p.lexpos(n) + 1) if self.tracking else ''

    # Note that the argument is a token, not a parser.
    def p_error(self, t):
        if t is None:
            raise Error('Unexpected EOF')
        raise Error('Syntax error at byte %u' % (t.lexpos + 1))


class Parser(_BaseParser):
    """Parses string in "m0confgen" format."""

    def __init__(self, **kwargs):
        self.lexer = Lexer()
        self.start = 'maybe_objs'
        super(Parser, self).__init__(**kwargs)

    def p_maybe_objs(self, p):
        """maybe_objs : objs
                      | empty
        """
        p[0] = [] if p[1] is None else p[1]

    def p_objs(self, p):
        """objs : obj
                | objs obj
        """
        if len(p) == 2:
            p[0] = [p[1]]
        else:
            p[0] = p[1] + [p[2]]

    def p_obj(self, p):
        """obj : '(' objid attrs ')'"""
        assert all_unique([k for k, _ in p[3]]), 'Attribute reassignment'
        p[0] = p[2], dict(p[3])

    def p_objid(self, p):
        """objid : ID '-' number
                 | ID '-' number ':' number
        """
        assert p[1] in conf_obj_types.keys()
        if len(p) == 4:
            p[0] = p[1], p[3]
        else:
            p[0] = p[1], (p[3], p[5])

    def p_attrs(self, p):
        """attrs : attr
                 | attrs attr
        """
        if len(p) == 2:
            p[0] = [p[1]]
        else:
            p[0] = p[1] + [p[2]]

    def p_attr(self, p):
        """attr : ID '=' number
                | ID '=' STRING
                | ID '=' objid
                | ID '=' fid
                | ID '=' list
        """
        p[0] = p[1], p[3]

    def p_list(self, p):
        """list : '[' ']'
                | '[' numbers ']'
                | '[' strings ']'
                | '[' objids ']'
        """
        p[0] = [] if p[2] == ']' else p[2]

    def p_objids(self, p):
        """objids : objid
                  | objids ',' objid
        """
        if len(p) == 2:
            p[0] = [p[1]]
        else:
            p[0] = p[1] + [p[3]]


class XCParser(_BaseParser):
    """Parses string in "xcode" format."""

    def __init__(self, **kwargs):
        self.lexer = XCLexer()
        self.start = 'xlist_xobj'
        super(XCParser, self).__init__(**kwargs)

    def _check_xlist_len(self, position, expected, actual):
        if expected != actual:
            raise Error("""Bad list{}
Length ({}) != number of elements ({})""".format(position, expected, actual))

    def p_xlist_xobj(self, p):
        """xlist_xobj : xlist_empty
                     | '[' number ':' xobjs ']'
                     | empty
        """
        if len(p) == 6:
            self._check_xlist_len(self.position(p, 1), p[2], len(p[4]))
            p[0] = p[4]
        else:
            p[0] = []

    def p_xobjs(self, p):
        """xobjs : xobj
                 | xobjs ',' xobj
        """
        if len(p) == 2:
            p[0] = [p[1]]
        else:
            p[0] = p[1] + [p[3]]

    def p_xobj(self, p):
        """xobj : '{' number '|' '(' '(' xobjid ')' ',' union_xattrs ')' '}'"""
        t1, objid = p[2], p[6]
        union_tag, attrs = p[9]
        otype = conf_obj_types[objid[0]]
        t2 = ord(otype.ft_id)
        if t1 != t2:
            raise Error("""Inconsistent object type{}
{t1:#x} != {t2:#x} ('{t2:c}')""".format(self.position(p, 2), t1=t1, t2=t2))
        if union_tag != getattr(otype, 'union_tag', None):
            raise Error('Invalid union specification' + self.position(p, 9))
        p[0] = objid, attrs

    def p_xobjid(self, p):
        """xobjid : xfid"""
        if type(p[1][0]) is not str:
            raise Error('Invalid conf_fid' + self.position(p, 1))
        p[0] = p[1]

    def p_xfid(self, p):
        """xfid : fid
                | xfid_custom
        """
        conf_fid = maybe_conf_fid(p[1])
        p[0] = p[1] if conf_fid is None else conf_fid

    # Custom format is only used for conf_fids at the moment.
    def p_xfid_custom(self, p):
        """xfid_custom : '^' ID '|' number ':' number"""
        fid_type, container, key = p[2], p[4], p[6]
        try:
            # See M0_FID_TCONTAINER().
            p[0] = (ord(fid_type) << 56 | container & 0x00ffffffffffffff), key
        except TypeError:  # thrown by ord(s) when len(s) > 1
            raise Error('Invalid conf_fid' + self.position(p, 1))

    def p_union_xattrs(self, p):
        """union_xattrs : xattrs
                        | '{' number '|' '(' xattrs ')' '}'
        """
        if len(p) == 2:
            p[0] = None, p[1]
        else:
            p[0] = p[2], p[5]

    def p_xattrs(self, p):
        """xattrs : xattr
                  | xattrs ',' xattr
        """
        if len(p) == 2:
            p[0] = [p[1]]
        else:
            p[0] = p[1] + [p[3]]

    def p_xattr(self, p):
        """xattr : number
                 | STRING
                 | xfid
                 | xlist
        """
        p[0] = p[1]

    def p_xlist(self, p):
        """xlist : xlist_empty
                 | '[' number ':' numbers ']'
                 | '[' number ':' strings ']'
                 | '[' number ':' xobjids ']'
        """
        if p[1] == '[':
            nr, xs = p[2], p[4]
            self._check_xlist_len(self.position(p, 1), nr, len(xs))
            if nr > 1:
                assert len(set(map(type, xs))) == 1
                if type(xs[0]) is tuple and len(set([conf_obj_types[t].ft_id
                                                     for t, _ in xs])) > 1:
                    # xs is a list of xobjids; obj types differ
                    raise Error('Heterogeneous list' + self.position(p, 1))
            p[0] = xs
        else:
            p[0] = []

    def p_xlist_empty(self, p):
        """xlist_empty : '[' number ']'"""
        if p[2] != 0:
            raise Error("""Bad list%s
The length is non-zero, but there are no elements""" % self.position(p, 1))

    def p_xobjids(self, p):
        """xobjids : xobjid
                   | xobjids ',' xobjid
        """
        if len(p) == 2:
            p[0] = [p[1]]
        else:
            p[0] = p[1] + [p[3]]

# --------------------------------------------------------------------
# Tests


class TestHelpers(unittest.TestCase):

    def test_maybe_conf_fid(self):
        self.assertIsNone(maybe_conf_fid((11, 22)))
        self.assertEqual(maybe_conf_fid((0x6400000000000001, 2)), ('sdev', 2))
        self.assertEqual(maybe_conf_fid((0x6400000000000000, 1)),
                         ('sdev', (0, 1)))
        self.assertEqual(maybe_conf_fid((0x7600000000000001, 5)), ('pver', 5))
        self.assertEqual(maybe_conf_fid((0x7640000000000001, 6)),
                         ('pver_f', 6))

    def test_fid_scan(self):
        self.assertEqual(fid_scan('7000000000000001:0'),
                         (0x7000000000000001, 0))
        self.assertEqual(fid_scan('<446a6a0000000001:3b>'),
                         (0x446a6a0000000001, 0x3b))
        self.assertEqual(fid_scan('<7640000000000001:41>'),
                         (0x7640000000000001, 0x41))
        self.assertRaises(Error, fid_scan, '')
        self.assertRaises(Error, fid_scan, 'garbage')
        self.assertRaises(Error, fid_scan, '<446a6a00000000')

    def test_fid_translate(self):
        self.assertEqual(fid_translate((0x7000000000000001, 0)), 'profile-0')
        self.assertEqual(fid_translate((0x4473640000000001, 9)),
                         'dir_service-9_sdev')
        self.assertEqual(fid_translate((0x446a6a0000000001, 0x3b)),
                         'dir_objv-59_objv')
        self.assertEqual(fid_translate((0x7640000000000001, 0x41)),
                         'pver_f-65')
        self.assertEqual(fid_translate((0x7600000000000002, 8)), 'pver-2:8')
        self.assertEqual(fid_translate((0x44766a0000000001, 8)),
                         'dir_pver-8_objv')


class TestParser(unittest.TestCase):

    def setUp(self):
        self.parser = Parser()
        self.parse = self.parser.parse

    def test_parse(self):
        self.assertEqual(self.parse(''), [])
        self.assertEqual(self.parse('(profile-0 filesystem=filesystem-1:2)'),
                         [(('profile', 0),
                           dict(filesystem=('filesystem', (1, 2))))])
        self.assertEqual(self.parse(
            '(root-10 verno=0xa profiles=[profile-012])'),
                         [(('root', 10),
                           dict(verno=10, profiles=[('profile', 10)]))])
        self.assertEqual(self.parse("""\
(filesystem-1 rootfid=(11, 12) redundancy=41212
    params=["param-0", "param-1", "param-2"]
    mdpool=pool-4 imeta_pver=(0, 0)
    nodes=[node-2] pools=[pool-4] racks=[])
"""),
                         [(('filesystem', 1), dict(
                             rootfid=(11, 12),
                             redundancy=41212,
                             params=['param-0', 'param-1', 'param-2'],
                             mdpool=('pool', 4),
                             imeta_pver=(0, 0),
                             nodes=[('node', 2)],
                             pools=[('pool', 4)],
                             racks=[]))])
        self.assertEqual(self.parse("""\
(pver-57 N=3 K=1 P=5 tolerance=[0, 0, 0, 1] rackvs=[objv-58])
(pver_f-65 id=0 base=pver-57 allowance=[0, 0, 1, 1])
"""),
                         [(('pver', 57), dict(
                             N=3, K=1, P=5, tolerance=[0, 0, 0, 1],
                             rackvs=[('objv', 58)])),
                          (('pver_f', 65), dict(
                              id=0, base=('pver', 57),
                              allowance=[0, 0, 1, 1]))])
        self.assertEqual(self.parse("""(profile-2:3 filesystem=filesystem-1)
(filesystem-1 rootfid=(11, 12) redundancy=41212
    params=["param-0", "param-1", "param-2"]
    mdpool=pool-4 imeta_pver=pver-0
    nodes=[node-2] pools=[pool-4] racks=[rack-3])
"""),
                         [(('profile', (2, 3)),
                           dict(filesystem=('filesystem', 1))),
                          (('filesystem', 1), dict(
                              rootfid=(11, 12),
                              redundancy=41212,
                              params=['param-0', 'param-1', 'param-2'],
                              mdpool=('pool', 4),
                              imeta_pver=('pver', 0),
                              nodes=[('node', 2)],
                              pools=[('pool', 4)],
                              racks=[('rack', 3)]))])


class TestEncoders(unittest.TestCase):

    def _test(self, encode):
        def test(internal, xcode, confgen=None):
            # internal -- internal representation of conf data, produced
            #             by a parser
            # xcode    -- expected result of encoding to "xcode" format
            # confgen  -- expected result of encoding to "confgen" format
            #             (default is the value of xcode)
            self.assertEqual(encode(internal), xcode)
            self.assertEqual(encode(internal, from_xcode=True),
                             xcode if confgen is None else confgen)
        return test

    def test_type2enc(self):
        def test(t):
            return self._test(conf_type2enc(t))

        test('NUMBER')(42, '42')
        test('STRING')('abc', '"abc"')
        test('fid')((11, 22), '(0xb, 0x16)')
        for t in ('fid', 'objid'):
            test(t)(('node', 4), '^n|1:4', 'node-4')
            test(t)(('node', (4, 1)), '^n|4:1', 'node-4:1')
        # 'objid' encoding accepts conf_fids only; (11, 22) is not a conf_fid
        self.assertRaises(AssertionError, conf_type2enc('objid'), (11, 22))
        self.assertRaises(AssertionError, conf_type2enc('objid'), (11, 22),
                          from_xcode=True)
        for t in ('NUMBER', 'STRING', 'fid', 'objid'):
            test('[%s]' % t)([], '[0]', '[]')
        test('[NUMBER]')([3, 4], '[2: 3, 4]', '[3, 4]')
        test('[STRING]')('abc', '[3: "a", "b", "c"]', '["a", "b", "c"]')
        test('[fid]')([(11, 22)], '[1: (0xb, 0x16)]', '[(0xb, 0x16)]')
        for t in ('[fid]', '[objid]'):
            test(t)([('node', 4)], '[1: ^n|1:4]', '[node-4]')
            test(t)([('node', (4, 1))], '[1: ^n|4:1]', '[node-4:1]')
            test(t)([('sdev', 2), ('sdev', (3, 4))], '[2: ^d|1:2, ^d|3:4]',
                    '[sdev-2, sdev-3:4]')

    def test_fid_encode(self):
        test_fid = self._test(fid_encode)
        for test in test_fid, self._test(conf_fid_encode):
            test(('service', 42), '^s|1:42', 'service-42')
            test(('service', (4, 2)), '^s|4:2', 'service-4:2')
            test(('pver', 186), '^v|1:186', 'pver-186')
            test(('pver', (10, 186)), '^v|10:186', 'pver-10:186')
            test(('pver_f', 187), '^v|0x40000000000001:187', 'pver_f-187')
            test(('pver_f', (10, 187)), '^v|0x4000000000000a:187',
                 'pver_f-10:187')
        test_fid((9, 10), '(0x9, 0xa)')
        self.assertRaises(AssertionError, conf_fid_encode, (5, 1))
        self.assertRaises(AssertionError, conf_fid_encode, (5, 1),
                          from_xcode=True)

    def test_list_encode(self):
        test = self._test(list_encode)
        test([], '[0]', '[]')
        test(['foo'], '[1: foo]', '[foo]')
        test(['foo', 'bar'], '[2: foo, bar]', '[foo, bar]')

    def test_obj_encode(self):
        # CG -> XC
        self.assertEqual(conf_obj_encode(
            (('root', 0), dict(
                verno=1, profiles=[('profile', 0), ('profile', (2, 3))]))),
                         '{0x74| ((^t|1:0), 1, [2: ^p|1:0, ^p|2:3])}')
        self.assertEqual(conf_obj_encode(
            (('objv', 19), dict(real=('disk', 16), children=[]))),
                         '{0x6a| ((^j|1:19), ^k|1:16, [0])}')
        self.assertEqual(conf_obj_encode(
            (('pver', 57), dict(
                N=3, K=1, P=5, tolerance=[0, 0, 0, 1],
                rackvs=[('objv', 58)]))),
                         '{0x76| ((^v|1:57), {0| (3, 1, 5, [4: 0, 0, 0, 1],'
                         ' [1: ^j|1:58])})}')
        self.assertEqual(conf_obj_encode(
            (('pver_f', 65), dict(
                id=0, base=('pver', 57), allowance=[0, 0, 1, 1]))),
                         '{0x76| ((^v|0x40000000000001:65), {1| (0, ^v|1:57,'
                         ' [4: 0, 0, 1, 1])})}')
        # XC -> CG
        self.assertEqual(conf_obj_encode(
            (('root', 0), [1, [('profile', (2, 3))]]), from_xcode=True),
                         '(root-0 verno=1 profiles=[profile-2:3])')
        self.assertEqual(conf_obj_encode(
            (('objv', 19), [('disk', 16), []]), from_xcode=True),
                         '(objv-19 real=disk-16 children=[])')

    def test_obj_encode_errors(self):
        self.assertRaisesRegexp(Error, """Invalid 'root' specification
Missing attribute: 'profiles'""", conf_obj_encode, (('root', 0), {'verno': 1}))
        self.assertRaisesRegexp(
            Error, """Invalid 'root' specification
Unknown attributes: 'a', 'b'""",
            conf_obj_encode,
            (('root', 0), dict(verno=1, profiles=[], a=9, b=9)))
        self.assertRaisesRegexp(Error, """Invalid 'root' specification
Unknown attribute: 'ver'
Missing attribute: 'verno'""", conf_obj_encode, (('root', 0),
                                                 dict(ver=1, profiles=[])))
        self.assertRaisesRegexp(Error, """Invalid 'root' specification
Expected 2 attributes, got 1""", conf_obj_encode,
                                (('root', 0), [1]), from_xcode=True)
        self.assertRaisesRegexp(Error, """Invalid 'root' specification
Expected 2 attributes, got 3""", conf_obj_encode,
                                (('root', 0), [1, [], 0]), from_xcode=True)

    def test_encode(self):
        self.assertEqual(conf_objs_encode([]), '[0]')
        self.assertEqual(conf_objs_encode([
            (('root', 0), dict(verno=1, profiles=[('profile', (2, 3))])),
            (('profile', (2, 3)), dict(filesystem=('filesystem', 1))),
            (('filesystem', 1), dict(rootfid=(11, 22), redundancy=41212,
                                     params=["param-0", "param-1", "param-2"],
                                     mdpool=('pool', 4), imeta_pver=(0, 0),
                                     nodes=[('node', 2)], pools=[('pool', 4)],
                                     racks=[('rack', 3)])),
            (('objv', 19), dict(real=('disk', 16), children=[]))]),
                         """[4:
 {0x74| ((^t|1:0), 1, [1: ^p|2:3])},
 {0x70| ((^p|2:3), ^f|1:1)},
 {0x66| ((^f|1:1), (0xb, 0x16), 41212, [3: "param-0", "param-1", "param-2"],\
 ^o|1:4, (0x0, 0x0), [1: ^n|1:2], [1: ^o|1:4], [1: ^a|1:3])},
 {0x6a| ((^j|1:19), ^k|1:16, [0])}]""")
        self.assertEqual(conf_objs_encode([], from_xcode=True), '')
        self.assertEqual(conf_objs_encode([
            (('root', 0), [1, [('profile', (2, 3))]]),
            (('profile', (2, 3)), [('filesystem', 1)]),
            (('filesystem', 1),
             [(11, 22), 41212, ["param-0", "param-1", "param-2"],
              ('pool', 4), ('pver', 0), [('node', 2)], [('pool', 4)],
              [('rack', 3)]]),
            (('objv', 19), [('disk', 16), []])], from_xcode=True), """\
(root-0 verno=1 profiles=[profile-2:3])
(profile-2:3 filesystem=filesystem-1)
(filesystem-1 rootfid=(0xb, 0x16) redundancy=41212\
 params=["param-0", "param-1", "param-2"] mdpool=pool-4 imeta_pver=pver-0\
 nodes=[node-2] pools=[pool-4] racks=[rack-3])
(objv-19 real=disk-16 children=[])""")
        # There and Back Again.
        confgen = """\
(root-0 verno=1 profiles=[profile-2:3])
(profile-2:3 filesystem=filesystem-1)"""
        xcode = conf_objs_encode(Parser().parse(confgen))
        self.assertEqual(conf_objs_encode(XCParser().parse(xcode),
                                          from_xcode=True), confgen)

    def test_encode_duplicates(self):
        self.assertRaisesRegexp(Error, "Duplicated identifier: \('root', 0\)",
                                conf_objs_encode,
                                [(('root', 0), dict(verno=1, profiles=[]))]*2)
        self.assertRaisesRegexp(Error,
                                "Duplicated identifier: \('profile', 0\)",
                                conf_objs_encode,
                                [(('profile', 0), [('filesystem', 1)])] * 2,
                                from_xcode=True)

    def test_dot(self):
        self.assertEqual(conf_obj_encode(
            (('root', 0),
             dict(verno=1, profiles=[('profile', 0), ('profile', (2, 3))])),
            enc=encode_to_dot),
                         """\
    "dir_root-0_profiles" [height=0.15, width=0.15, label=""];
    "root-0" -> "dir_root-0_profiles" [label=profiles];
    "dir_root-0_profiles" -> "profile-0";
    "dir_root-0_profiles" -> "profile-2:3";
""")
        self.assertEqual(conf_obj_encode((('profile', (2, 3)),
                                          dict(filesystem=('filesystem', 1))),
                                         enc=encode_to_dot),
                         """\
    "profile-2:3" -> "filesystem-1" [label=filesystem];
""")
        self.assertEqual(conf_obj_encode(
            (('filesystem', 1),
             dict(rootfid=(11, 22), redundancy=41212, params=["param-0"],
                  mdpool=('pool', 4), imeta_pver=(0, 0),
                  nodes=[('node', 1), ('node', (2, 3))],
                  pools=[('pool', 4)], racks=[('rack', 5)])),
            enc=encode_to_dot),
                         """\
    "dir_filesystem-1_nodes" [height=0.15, width=0.15, label=""];
    "filesystem-1" -> "dir_filesystem-1_nodes" [label=nodes];
    "dir_filesystem-1_nodes" -> "node-1";
    "dir_filesystem-1_nodes" -> "node-2:3";
    "dir_filesystem-1_pools" [height=0.15, width=0.15, label=""];
    "filesystem-1" -> "dir_filesystem-1_pools" [label=pools];
    "dir_filesystem-1_pools" -> "pool-4";
    "dir_filesystem-1_racks" [height=0.15, width=0.15, label=""];
    "filesystem-1" -> "dir_filesystem-1_racks" [label=racks];
    "dir_filesystem-1_racks" -> "rack-5";
""")
        self.assertEqual(conf_obj_encode(
            (('objv', 9),
             dict(real=('controller', 2), children=[('objv', 10)])),
            enc=encode_to_dot),
                         """\
    "dir_objv-9_children" [height=0.15, width=0.15, label=""];
    "objv-9" -> "dir_objv-9_children" [label=children];
    "dir_objv-9_children" -> "objv-10";
""")
        self.assertEqual(conf_obj_encode(
            (('objv', 10), dict(real=('disk', 4), children=[])),
            enc=encode_to_dot),
                         """\
    "objv-10";
""")
        self.assertEqual(conf_obj_encode(
            (('root', 0), [1, [('profile', (2, 3))]]), from_xcode=True,
            enc=encode_to_dot),
                         """\
    "dir_root-0_profiles" [height=0.15, width=0.15, label=""];
    "root-0" -> "dir_root-0_profiles" [label=profiles];
    "dir_root-0_profiles" -> "profile-2:3";
""")
        self.assertEqual(conf_obj_encode(
            (('profile', (2, 3)), [('filesystem', 1)]), from_xcode=True,
            enc=encode_to_dot),
                         """\
    "profile-2:3" -> "filesystem-1" [label=filesystem];
""")
        self.assertEqual(conf_objs_encode_to_dot([
            (('profile', (2, 3)), dict(filesystem=('filesystem', 1))),
            (('objv', 19), dict(real=('disk', 16), children=[]))]),
                         """\
digraph x {
    edge [arrowhead=open, fontsize=11];

    "profile-2:3" -> "filesystem-1" [label=filesystem];

    "objv-19";
}""")

    def test_custom_encoder(self):
        def enc(objid, attrs, otype):
            if objid[0] == 'node':
                return repr(objid)

        self.assertIsNone(conf_obj_encode(
            (('root', 0), dict(verno=1, profiles=[('profile', 0)])),
            enc=enc))
        self.assertEqual(conf_obj_encode(
            (('node', 14),
             dict(memsize=64230, nr_cpu=20, last_state=0, flags=0,
                  pool_id=('pool', 2), processes=[])),
            enc=enc),
                         "('node', 14)")
        self.assertEqual(conf_objs_encode(
            [(('root', 0), [1, [('profile', 0)]]),
             (('node', 1), [64230, 20, 0, 0, ('pool', 1), []]),
             (('node', 2), [64230, 20, 0, 0, ('pool', 2), []])],
            from_xcode=True, enc=enc),
                         "('node', 1)\n('node', 2)")


class TestXCParser(unittest.TestCase):

    def setUp(self):
        self.parser = XCParser()
        self.parse = self.parser.parse

    def test_parse(self):
        self.assertEqual(self.parse(''), [])
        self.assertEqual(self.parse('[0]'), [])
        self.assertEqual(self.parse("""[1:
{0x74| (((0x7400000000000001, 0)), 1, [1: (0x7000000000000002, 3)])}]"""),
                         [(('root', 0), [1, [('profile', (2, 3))]])])
        self.assertEqual(self.parse('[1: {0x74| ((^t|1:0), 1, [1: ^p|1:0])}]'),
                         [(('root', 0), [1, [('profile', 0)]])])
        self.assertEqual(
            self.parse("""[4:
# (disk-55 dev=sdev-51 pvers=[pver-57])
{0x6b| ((^k|1:55), ^d|1:51, [1: ^v|1:57])},
# (pool-56 order=0 pvers=[pver-57, pver_f-65])
{0x6f| ((^o|1:56), 0, [2: ^v|1:57, ^v|0x40000000000001:65])},
# (pver-57 N=8 K=2 P=15 tolerance=[0 0 1 2] rackvs=[objv-58])
{0x76| ((^v|1:57), {0| (8, 2, 15, [4: 0, 0, 1, 2], [1: ^j|1:58])})},
# (pver_f-65 id=0 base=pver-57 allowance=[0 0 1 1])
{0x76| ((^v|0x40000000000001:65), {1| (0, ^v|1:57, [4: 0, 0, 1, 1])})}]"""),
            [(('disk', 55), [('sdev', 51), [('pver', 57)]]),
             (('pool', 56), [0, [('pver', 57), ('pver_f', 65)]]),
             (('pver', 57), [8, 2, 15, [0, 0, 1, 2], [('objv', 58)]]),
             (('pver_f', 65), [0, ('pver', 57), [0, 0, 1, 1]])])

    def test_errors(self):
        self.assertRaisesRegexp(Error, """Bad list.*
The length is non-zero, but there are no elements""", self.parse, '[1]')
        self.assertRaisesRegexp(Error, """Bad list.*
Length \(2\) != number of elements \(1\)""", self.parse,
                                ' [2: {0x74| ((^t|1:0), 1, [0])}]')
        self.assertRaisesRegexp(Error, 'Invalid conf_fid.*',
                                self.parse, '[1: {0x58| ((^X|1:0), [0])}]')
        self.assertRaisesRegexp(
            Error, 'Invalid conf_fid.*', self.parse,
            '[1: {0x58| (((0x5800000000000001, 0)), [0])}]')
        self.assertRaisesRegexp(Error, 'Invalid conf_fid.*',
                                self.parse, '[1: {0x58| ((^XY|1:0), [0])}]')
        self.assertRaisesRegexp(Error, """Inconsistent object type.*
0x70 != 0x66 \('f'\)""",
                                self.parse, '[1: {0x70| ((^f|1:0), ^f|1:0)}]')
        self.assertRaisesRegexp(Error, '^Heterogeneous list', self.parse,
                                """[1:
{0x6a| ((^j|1:1), ^a|1:2,
        # xlist may not contain elements of different types
        [2: ^j|1:3, ^a|1:4])}]""")

        # Unexpected union.
        self.assertRaisesRegexp(Error, 'Invalid union specification',
                                self.parse, """[1:
{0x73| ((^s|1:21), {0| (10, [1: "0@lo:12345:34:1"], [0])})}]""")
        # Union is missing.
        self.assertRaisesRegexp(Error, 'Invalid union specification',
                                self.parse, """[1:
{0x76| ((^v|1:8), 3, 1, 5, [4: 0, 0, 0, 1], [1: ^j|1:12])}]""")
        # Wrong union tag.
        self.assertRaisesRegexp(Error, 'Invalid union specification',
                                self.parse, """[1:
{0x76| ((^v|1:8), {1| (3, 1, 5, [4: 0, 0, 0, 1], [1: ^j|1:12])})}]""")
        self.assertRaisesRegexp(Error, 'Invalid union specification',
                                self.parse, """[1:
{0x76| ((^v|0x40000000000001:65), {0| (0, ^v|1:57, [4: 0, 0, 0, 1])})}]""")

# --------------------------------------------------------------------
# main


def encode_and_print(s, from_xcode, dot_mode):
    try:
        p = XCParser() if from_xcode else Parser()
        if dot_mode:
            print(conf_objs_encode_to_dot(p.parse(s), from_xcode=from_xcode,
                                          mode=dot_mode))
        else:
            print(conf_objs_encode(p.parse(s), from_xcode=from_xcode))
    except Error, e:
        print(e, file=sys.stderr)
        return 1
    except IOError, e:
        if e.errno == EPIPE:
            return e.errno
        raise


def translate_fids():
    while True:
        try:
            s = raw_input('> ' if sys.stdin.isatty() else '').rstrip('\r')
            for s in s.split():  # allow several fids per line
                print(' '.join(filter(None, [s, fid_translate(fid_scan(s))])))
        except Error, e:
            print(e, file=sys.stderr)
            continue
        except (EOFError, KeyboardInterrupt):
            return


def main():
    op = OptionParser(usage='%prog [OPTION]... [FILE]',
                      description='Generates configuration string in "xcode"'
                      ' format from its human-friendly description.',
                      epilog='  FILE    Input file. With no FILE, or when FILE'
                      ' is -, read standard input.',
                      version='%prog ' + __version__)
    op.add_option('--help-format',
                  help='Print input format documentation and exit.',
                  action='store_true')
    op.add_option('-x', '--from-xcode', help='Convert conf string from "xcode"'
                  ' format to "confgen" format.', action='store_true')
    op.add_option('--dot', help='Generate DOT output. Supported MODEs:'
                  " 'full' - all conf objects are shown; 'simplified'"
                  ' - only node, process and service objects are.',
                  type='choice', choices=['full', 'simplified'],
                  metavar='MODE')
    op.add_option('--types', help='Print conf object types and exit.',
                  action='store_true')
    op.add_option('--svc-types', help='Print service types and exit.',
                  action='store_true')
    op.add_option('--fids', help='Read FIDs from stdin and translate them to'
                  ' human-readable format.', action='store_true')
    op.add_option('--self-check', help='Run unit tests and exit.',
                  action='store_true')
    opts, args = op.parse_args()
    if len(args) > 1:
        op.error("Invalid arguments\nUse `--help'.")

    if opts.help_format:
        print(input_format)
        return
    if opts.types:
        types = conf_obj_types.items()
        types.sort(key=lambda kv: kv[1].ft_id)
        for k, v in types:
            print('{} {:#x} {}'.format(v.ft_id, ord(v.ft_id), k))
        return
    if opts.svc_types:
        for i, s in enumerate(conf_service_types):
            if not s.startswith('_'):
                print('{} {}'.format(i+1, s))
        return
    if opts.fids:
        return translate_fids()
    if opts.self_check:
        unittest.main(argv=sys.argv[:1])

    if not args or args[0] == '-':
        f = sys.stdin
    else:
        try:
            f = file(args[0])
        except IOError, e:
            print(e, file=sys.stderr)
            return e.errno
    return encode_and_print(f.read(), opts.from_xcode, opts.dot)


if __name__ == '__main__':
    sys.exit(main())
