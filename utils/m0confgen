#!/usr/bin/env python

from __future__ import print_function

from ply import lex, yacc
import argparse
import textwrap
import sys
import json
from collections import OrderedDict
from curses import ascii
from errno import EPIPE
import unittest


__copyright__ = """COPYRIGHT 2017 XYRATEX TECHNOLOGY LIMITED

THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.

YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
http://www.xyratex.com/contact
"""
__author__ = 'Valery V. Vorotyntsev <valery.vorotyntsev@seagate.com>'
__version__ = '2.0'
__doc__ = """Configuration string converter.

Converts configuration string from one format into another.

Input formats: {input_formats}.
Output formats: {output_formats}.
"""
__all__ = ['Fid', 'ConfObj', 'conf_objs_from_str', 'conf_objs_to_str',
           'conf_obj_types', 'Error']

# NOTE: These definitions should be in sync with m0_confx_* structures
# in conf/onwire.h.
#
# Relation attributes (references to other objects) are marked either
# with '*' (solid line on visualisation) or '!' (dashed line).
#
# XXX TODO: s/objid/fid/g ?
conf_obj_types = {
    'root': ('t', 'verno=NUMBER *profiles=[objid]'),
    'profile': ('p', '*filesystem=objid'),
    'filesystem': ('f', 'rootfid=fid redundancy=NUMBER params=[STRING]'
                   ' mdpool=objid imeta_pver=fid'
                   ' *nodes=[objid] *pools=[objid] *racks=[objid]'),
    'pool': ('o', 'order=NUMBER *pvers=[objid]'),
    'pver': ('v:0',  # actual pver
             'N=NUMBER K=NUMBER P=NUMBER tolerance=[NUMBER]'
             ' *rackvs=[objid]'),
    'pver_f': ('v:1',  # formulaic pver
               'id=NUMBER !base=objid allowance=[NUMBER]'),
    'objv': ('j', '!real=objid *children=[objid]'),
    'node': ('n', 'memsize=NUMBER nr_cpu=NUMBER last_state=NUMBER flags=NUMBER'
             ' pool_id=objid *processes=[objid]'),
    'process': ('r', 'cores=[NUMBER] mem_limit_as=NUMBER mem_limit_rss=NUMBER'
                ' mem_limit_stack=NUMBER mem_limit_memlock=NUMBER'
                ' endpoint=STRING *services=[objid]'),
    'service': ('s', 'type=NUMBER endpoints=[STRING] *sdevs=[objid]'),
    'sdev': ('d', 'dev_idx=NUMBER iface=NUMBER media=NUMBER bsize=NUMBER'
             ' size=NUMBER last_state=NUMBER flags=NUMBER filename=STRING'),
    'rack': ('a', '*encls=[objid] pvers=[objid]'),
    'enclosure': ('e', '*ctrls=[objid] pvers=[objid]'),
    'controller': ('c', '!node=objid *disks=[objid] pvers=[objid]'),
    'disk': ('k', '!dev=objid pvers=[objid]')
}

# NOTE: Should be in sync with m0_conf_service_type in conf/schema.h.
conf_service_types = (
    'MDS',  # = 1
    'IOS', 'MGS', 'RMS', 'STS', 'HA', 'SSS', 'SNS_REP', 'SNS_REB', 'ADDB2',
    'CAS', 'DIX_REP', 'DIX_REB',
    '_DS1', '_DS2',  # UT-specific
    'FIS'
)


# --------------------------------------------------------------------
# Helpers

class Error(Exception):
    pass


def all_unique(xs):
    """Returns True iff all entries of the sequence are unique."""
    return len(xs) == len(set(xs))


def bits(num, start_bit, nr_bits):
    """Returns `nr_bits' of `num', starting at `start_bit'."""
    return num >> start_bit & 2**nr_bits - 1


def delete_chars(s, deletechars):
    assert type(deletechars) is str
    if sys.version_info.major < 3:
        return s.translate(None, deletechars)  # Python 2 version
    return s.translate({ord(c): None for c in deletechars})


# --------------------------------------------------------------------
# Internal representation

class Fid(object):

    def __init__(self, container, key):
        # see M0_FID_TCONTAINER() in fid/fid.h
        if type(container) is tuple:
            car, cdr = container
            if type(car) is str:
                car = ord(car)
            assert car >= 0 and car.bit_length() <= 8
            assert cdr >= 0 and cdr.bit_length() <= 56
            self.tcontainer = car, cdr
        else:
            assert container >= 0
            self.tcontainer = (container >> 56,
                               container & 0x00ffffffffffffff)
        assert key >= 0
        self.key = key

    def __repr__(self):
        if self.typebyte() == 0:
            return '{}({}, {})'.format(self.__class__.__name__,
                                       self.tcontainer[1], self.key)
        ft_id = self.typebyte()
        if ascii.isprint(ft_id):
            ft_id = repr(chr(ft_id))
        return '{}(({}, {}), {})'.format(self.__class__.__name__,
                                         ft_id, self.tcontainer[1], self.key)

    def __eq__(self, other):
        return self.tcontainer == other.tcontainer and self.key == other.key

    def typebyte(self):  # aka "ft_id"
        return self.tcontainer[0]

    def container(self):
        return self.tcontainer[0] << 56 | self.tcontainer[1]


class ConfObjType(object):

    def __init__(self, name, ft_id, desc):
        assert all([type(x) is str for x in (name, ft_id, desc)])
        self.name = name
        self.ft_id = ft_id[0]
        self.union_tag = None
        if ft_id[1:]:
            assert ft_id[1] == ':'
            self.union_tag = int(ft_id[2:])
        self.attrs = [ConfObjAttrType(*a.split('=', 1)) for a in desc.split()]
        self.desc = desc

    def __repr__(self):
        ft_id = self.ft_id
        if self.union_tag is not None:
            ft_id += ':' + str(self.union_tag)
        return '{}({!r}, {!r}, {!r})'.format(self.__class__.__name__,
                                             self.name, ft_id, self.desc)

    def to_fid(self, container, key):
        if self.union_tag is None:
            return Fid((self.ft_id, container), key)
        assert self.union_tag.bit_length() <= 2
        if container & 0x00c0000000000000:
            raise Error('Union tag bits are not zero: {:#x}'.format(container))
        assert container.bit_length() <= 56
        return Fid(ord(self.ft_id) << 56 | self.union_tag << 54 | container,
                   key)

    @staticmethod
    def from_fid(fid):
        assert type(fid) is Fid
        ts = [t for t in conf_obj_types.values()
              if t.ft_id == chr(fid.typebyte())]
        if not ts:
            return None  # not a conf fid
        if ts[1:]:
            assert all([t.union_tag is not None for t in ts])
            ts = [t for t in ts
                  if bits(fid.tcontainer[1], 54, 2) == t.union_tag]
            if len(ts) != 1:
                raise Error('Unsupported union tag: {:#x}'.format(
                    fid.container()))
        t = ts[0]
        if t.union_tag is None:
            assert t.to_fid(fid.tcontainer[1], fid.key) == fid
        else:
            # clear union tag bits
            assert t.to_fid(fid.tcontainer[1] & ~0x00c0000000000000,
                            fid.key) == fid
        return t


class ConfObjAttrType(object):

    def __init__(self, name, type_desc):
        if name[0] in '*!':
            self.relation, self.name = name[0], name[1:]
        else:
            self.relation, self.name = '', name
        self.type_desc = type_desc

    def __repr__(self):
        return '{}({!r}, {!r})'.format(self.__class__.__name__,
                                       self.relation + self.name,
                                       self.type_desc)


conf_obj_types = dict((name, ConfObjType(name, *desc))
                      for name, desc in conf_obj_types.items())
assert all([k == t.name for k, t in conf_obj_types.items()])
assert all_unique([(t.ft_id, t.union_tag) for t in conf_obj_types.values()])


class ConfObj(object):

    def __init__(self, objid, attrs):
        otype = ConfObjType.from_fid(objid)
        attrs = list(attrs)
        assert attrs
        assert all([type(x) is tuple and len(x) == 2 for x in attrs])
        anames = set([k for k, _ in attrs])
        assert len(attrs) == len(list(anames)), 'Attribute reassignment'
        otype_anames = set([a.name for a in otype.attrs])
        if anames != otype_anames:
            missing = [a for a in otype_anames - anames]
            unknown = [a for a in anames - otype_anames]
            err = '{}: Invalid attributes'.format(objid)
            if missing:
                err += '\n  missing: ' + ', '.join(sorted(missing))
            if unknown:
                err += '\n  unknown: ' + ', '.join(unknown)
            raise Error(err)
        self.objid = objid
        attrs = dict(attrs)
        self.attrs = [attrs[a.name] for a in otype.attrs]

    def __repr__(self):
        otype = ConfObjType.from_fid(self.objid)
        return '{}({!r}, {!r})'.format(
            self.__class__.__name__, self.objid,
            list(zip([a.name for a in otype.attrs], self.attrs)))

    def __eq__(self, other):
        return self.objid == other.objid and self.attrs == other.attrs


# --------------------------------------------------------------------
# Encoding (internal representation -> string)

output_formats = ['confgen', 'xcode', 'json', 'html', 'dot']


class BaseEncoder(object):

    @classmethod
    def typed(cls, desc):
        """Selects encoder given the description of the kind of input data.
        """
        assert type(desc) is str
        list_p = False
        if desc[0] == '[':
            assert desc[-1] == ']'
            list_p = True
            desc = desc[1:-1]
        enc = {
            'NUMBER': cls.encode_NUMBER,
            'STRING': cls.encode_STRING,
            'fid': cls.encode_Fid,
            'objid': cls.encode_objid,
        }[desc]
        if list_p:
            return lambda xs: cls.encode_list(list(map(enc, xs)))
        return enc

    @classmethod
    def encode(cls, objs):
        assert type(objs) is list
        assert all([type(x) is ConfObj for x in objs])
        return cls.head(objs) + cls.body(objs) + cls.tail if objs else ''

    @classmethod
    def body(cls, objs):
        return cls.separator.join([cls.indentation + cls.encode_ConfObj(obj)
                                   for obj in objs])

    @staticmethod
    def hex_big(n):
        return str(n) if n < 100 else hex(n)

    @classmethod
    def encode_NUMBER(cls, n):
        assert type(n) is int
        return cls.hex_big(n)

    @staticmethod
    def encode_STRING(s):
        assert type(s) is str
        return '"{}"'.format(s)

    @classmethod
    def encode_Fid(cls, fid):
        if ConfObjType.from_fid(fid) is None:
            return '({}, {})'.format(*map(cls.hex_big,
                                          [fid.container(), fid.key]))
        return cls.encode_Fid__conf(fid)

    @classmethod
    def encode_objid(cls, fid):
        if ConfObjType.from_fid(fid) is None:
            raise Error('Conf fid expected: {}'.format(fid))
        return cls.encode_Fid__conf(fid)


class Encoder_xc(BaseEncoder):

    @staticmethod
    def head(objs):
        return '[{}:\n'.format(len(objs))

    indentation = ' '
    separator = ',\n'
    tail = ']'

    @staticmethod
    def encode_list(xs):
        assert type(xs) is list
        return '[{}: {}]'.format(len(xs), ', '.join(xs)) if xs else '[0]'

    @classmethod
    def encode_Fid__conf(cls, fid):
        otype = ConfObjType.from_fid(fid)
        assert otype is not None
        assert ord(otype.ft_id) == fid.typebyte()
        return '^{}|{}:{}'.format(
            otype.ft_id, *map(cls.hex_big, [fid.tcontainer[1], fid.key]))

    @classmethod
    def encode_ConfObj(cls, obj):
        assert type(obj) is ConfObj
        otype = ConfObjType.from_fid(obj.objid)
        assert len(otype.attrs) == len(obj.attrs)
        return '{{{ft_id:#x}| (({objid}), {union_begin}{attrs}{union_end})}}'.\
            format(
                ft_id=ord(otype.ft_id), objid=cls.encode_objid(obj.objid),
                union_begin=('' if otype.union_tag is None else
                             '{{{}| ('.format(otype.union_tag)),
                attrs=', '.join([cls.typed(ta.type_desc)(a)
                                 for ta, a in zip(otype.attrs, obj.attrs)]),
                union_end=('' if otype.union_tag is None else ')}'))


class Encoder_cg(BaseEncoder):

    @staticmethod
    def head(objs):
        return ''

    indentation = ''
    separator = '\n'
    tail = ''

    @staticmethod
    def encode_list(xs):
        assert type(xs) is list
        return '[{}]'.format(', '.join(xs))

    @classmethod
    def encode_Fid__conf(cls, fid):
        otype = ConfObjType.from_fid(fid)
        assert otype is not None
        container = fid.tcontainer[1]
        if otype.union_tag is not None:
            assert bits(container, 54, 2) == otype.union_tag
            container &= 0x003fffffffffffff  # clear union_tag bits
        return '{type}-{container}{key}'.format(
            type=otype.name,
            container=('' if container == 1 else cls.hex_big(container) + ':'),
            key=cls.hex_big(fid.key))

    @classmethod
    def encode_ConfObj(cls, obj):
        assert type(obj) is ConfObj
        otype = ConfObjType.from_fid(obj.objid)
        assert len(otype.attrs) == len(obj.attrs)
        return '({objid} {attrs})'.format(
            objid=cls.encode_objid(obj.objid),
            attrs=' '.join([ta.name + '=' + cls.typed(ta.type_desc)(a)
                            for ta, a in zip(otype.attrs, obj.attrs)]))


class Encoder_json(Encoder_cg):

    @staticmethod
    def head(objs):
        return '[\n'

    indentation = ' '
    separator = ',\n'
    tail = '\n]'

    @staticmethod
    def encode_list(xs):
        assert type(xs) is list
        return xs

    @staticmethod
    def encode_NUMBER(n):
        assert type(n) is int
        return n

    @staticmethod
    def encode_STRING(s):
        assert type(s) is str
        return s

    @classmethod
    def encode_Fid(cls, fid):
        if ConfObjType.from_fid(fid) is None:
            return fid.container(), fid.key
        return cls.encode_Fid__conf(fid)

    @classmethod
    def encode_ConfObj(cls, obj):
        assert type(obj) is ConfObj
        otype = ConfObjType.from_fid(obj.objid)
        assert len(otype.attrs) == len(obj.attrs)
        return json.dumps(OrderedDict(
            [('objid', cls.encode_objid(obj.objid))] +
            [(ta.name, cls.typed(ta.type_desc)(a))
             for ta, a in zip(otype.attrs, obj.attrs)]))


class Encoder_html(Encoder_cg):

    @staticmethod
    def head(objs):
        return """\
<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>conf</title>
    <style>
        body {
            color: #d3d3d3;
            font: 12pt arial;
            background-color: #222222;
        }
        #network {
            width: 1000px;
            height: 500px;
            border: 1px solid #444444;
            background-color: #222222;
        }
        table {
            border-collapse: collapse;
        }
        table td {
            border: 1px solid;
        }
    </style>
    <script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.19.1/vis.min.js">
    </script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.19.1/vis.min.css"
        rel="stylesheet" type="text/css">
</head>
<body>
<div id="network">
<script type="text/javascript">
"""

    @classmethod
    def array_entries(cls, obj):
        """ConfObj -> (string, [string])

        Returns a tuple of
        - `nodes' array entry;
        - list of `edges' array entries.
        """
        otype = ConfObjType.from_fid(obj.objid)
        assert otype is not None
        fid = cls.encode_objid(obj.objid)

        def edge_to(target, relation):
            edge = OrderedDict([('from', fid),
                                ('to', cls.encode_objid(target))])
            if relation == '!':
                edge['dashes'] = True
            else:
                assert relation == '*'
            return edge

        node = OrderedDict([('id', fid), ('label', fid), ('group', otype.name),
                            ('_attrs', OrderedDict())])
        edges = []
        for ta, a in zip(otype.attrs, obj.attrs):
            node['_attrs'][ta.name] = cls.typed(ta.type_desc)(a)
            if ta.relation:
                if type(a) is list:
                    edges += [edge_to(x, ta.relation) for x in a]
                else:
                    edges.append(edge_to(a, ta.relation))
        return json.dumps(node), list(map(json.dumps, edges))

    indentation = ' '*4
    separator = ',\n'

    @classmethod
    def body(cls, objs):
        nodes, edges = zip(*map(cls.array_entries, objs))
        edges = reduce(list.__add__, edges)
        return """\
{indent}var nodes = [
{nodes}
{indent}];
{indent}var edges = [
{edges}
{indent}];
""".format(indent=cls.indentation,
           nodes=cls.separator.join([cls.indentation*2 + s for s in nodes]),
           edges=cls.separator.join([cls.indentation*2 + s for s in edges]))

    tail = """
    var container = document.getElementById("network");
    var data = {
        nodes: nodes,
        edges: edges
    };
    var options = {
        edges: {
            arrows: {
                to: {enabled: true}
            }
        }
    };
    network = new vis.Network(container, data, options);

    network.on("selectNode", function (params) {
        var obj_id = params.nodes[0];
        var obj_attrs = nodes.find(function (x) {
            return x.id == obj_id;
        })._attrs;

        table_delete();
        var table = document.createElement("table");
        var caption = document.createElement("caption");
        caption.appendChild(document.createTextNode(obj_id));
        table.appendChild(caption);
        for (var k in obj_attrs) {
            var tr = table.insertRow();
            var td = tr.insertCell();
            td.appendChild(document.createTextNode(k));
            var td = tr.insertCell();
            td.appendChild(document.createTextNode(obj_attrs[k]));
        }
        document.body.appendChild(table);
    });

    network.on("deselectNode", function (params) {
        table_delete();
    });

    function table_delete() {
        var elem = document.getElementsByTagName("table")[0];
        if (elem) {
            elem.parentNode.removeChild(elem);
        }
    }
</script>
</body>
</html>"""


class Encoder_dot(Encoder_cg):

    @staticmethod
    def head(objs):
        return """digraph conf {
    edge [arrowhead=open, fontsize=11];
"""
    indentation = ''
    separator = '\n'
    tail = '\n}'

    @classmethod
    def encode_ConfObj(cls, obj):
        assert type(obj) is ConfObj
        otype = ConfObjType.from_fid(obj.objid)
        assert len(otype.attrs) == len(obj.attrs)
        objid = cls.encode_Fid__conf(obj.objid)
        rows = ['"{}";'.format(objid)]
        for ta, a in zip(otype.attrs, obj.attrs):
            if ta.relation != '*':
                continue
            if type(a) is not list:
                rows.append('"{}" -> "{}" [label="{}"];'.format(
                    objid, cls.encode_Fid__conf(a), ta.name))
                continue
            if not a:
                continue  # don't show empty directories
            dirid = 'dir_{}_{}'.format(objid, ta.name)
            rows.append('"{}" [height=0.15, width=0.15, label=""];'.format(
                dirid))
            rows.append('"{}" -> "{}" [label="{}"];'.format(
                objid, dirid, ta.name))
            for child in a:
                rows.append('"{}" -> "{}";'.format(
                    dirid, cls.encode_Fid__conf(child)))
        return cls.separator.join([''] + [' '*4 + r for r in rows])


def fid_translate(fid):
    assert type(fid) is Fid
    if chr(fid.typebyte()) == 'D':
        # Byte 7 of fid.container() = type of dir's parent.
        # Byte 6 of fid.container() = type of dir's children.
        # See conf_dir_id_build() in conf/dir.c.
        parent = Fid((fid.tcontainer[1] >> 48 & 0xff,
                      fid.tcontainer[1] & 0xffffffffff),
                     fid.key)
        child = Fid((fid.tcontainer[1] >> 40 & 0xff, 1), 0)  # a counterfeit
        if all([ConfObjType.from_fid(x) is not None for x in (parent, child)]):
            return 'dir_{}_{}'.format(Encoder_cg.encode_Fid(parent),
                                      ConfObjType.from_fid(child).name)
    if ConfObjType.from_fid(fid) is not None:
        return Encoder_cg.encode_Fid(fid)


def fids_translate():
    while True:
        try:
            s = raw_input('> ' if sys.stdin.isatty() else '').rstrip('\r')
            for s in s.split():  # allow several fids per line
                print(' '.join(filter(None, [s, fid_translate(fid_scan(s))])))
        except Error as e:
            print(e, file=sys.stderr)
            continue
        except (EOFError, KeyboardInterrupt):
            return


def conf_objs_to_str(objs, to_fmt):
    """conf_objs_to_str(conf_objs, format) -> string

    Converts a list of conf objects (ConfObj) into a string of
    specific format.
    """
    encoders = OrderedDict([('confgen', Encoder_cg.encode),
                            ('xcode', Encoder_xc.encode),
                            ('json', Encoder_json.encode),
                            ('html', Encoder_html.encode),
                            ('dot', Encoder_dot.encode)])
    assert list(encoders.keys()) == output_formats
    return encoders[to_fmt](objs)


# --------------------------------------------------------------------
# Decoding (string -> internal representation)

input_formats = ['confgen', 'xcode']

confgen_doc = """"confgen" format:

    input   = [ seq(obj) ]
    seq(t)  = *( t )
    csv(t)  = t | csv(t) "," t
    obj     = "(" objid *( attr ) ")"
    objid   = objtype "-" [ NUMBER ":" ] NUMBER
    attr    = ID "=" ( NUMBER | STRING | fid | objid | list )
    fid     = "(" NUMBER "," NUMBER ")"
    list    = "[" [ csv(NUMBER) | csv(STRING) | csv(objid) ] "]"
    objtype = { %(objtypes)s }

Notes on objid specification:

    Generic descriptor
        <objtype>-<container>:<key>
    may be shortened to
        <objtype>-<key>
    when the <container> part is 1.

Examples:

    (root-0 verno=1 profiles=[profile-2:3])
    (profile-2:3 filesystem=filesystem-1)
    (filesystem-1 rootfid=(11, 12) redundancy=41212
        params=["param-0", "param-1", "param-2"]
        mdpool=pool-4 imeta_pver=(0, 0)
        nodes=[node-2] pools=[pool-4, pool-5] racks=[])

Configuration object types and attributes:

    %(attrs)s""" % {
        'objtypes': textwrap.fill(
            ' | '.join(map('"{}"'.format, sorted(conf_obj_types.keys()))),
            width=63, subsequent_indent=' '*16),
        'attrs': '\n    '.join('{:14}{}'.format(
            k + ':',
            textwrap.fill(delete_chars(t.desc, '*!'),
                          width=60,
                          subsequent_indent=' '*22))
                               for k, t in sorted(conf_obj_types.items()))
    }


class Lexer(object):

    tokens = ('HEXNUM', 'OCTNUM', 'DECNUM', 'STRING', 'ID')
    literals = '()[]-=,:'
    t_ignore = ' \t\r\v'
    t_ID = r'\b[a-zA-Z]\w*\b'

    def __init__(self, **kwargs):
        self.lexer = lex.lex(module=self, **kwargs)
        self.input = self.lexer.input
        self.token = self.lexer.token
        self.lineno = self.lexer.lineno
        self.lexpos = self.lexer.lexpos

    def t_HEXNUM(self, t):
        r'\b0[xX][0-9a-fA-F]+\b'
        t.value = int(t.value, 16)
        return t

    def t_OCTNUM(self, t):
        r'\b0[0-7]+\b'
        t.value = int(t.value, 8)
        return t

    def t_DECNUM(self, t):
        r'\b\d+\b'
        t.value = int(t.value)
        return t

    def t_STRING(self, t):
        r'"[^"]*"'
        t.value = t.value[1:-1]
        return t

    def t_comment(self, t):
        r'\#.*'

    def t_newline(self, t):
        r'\n+'
        t.lexer.lineno += len(t.value)

    def t_error(self, t):
        raise Error("Illegal character '%s' at byte %u" % (t.value[0],
                                                           t.lexpos + 1))

    def test(self, data):
        self.input(data)
        while True:
            t = self.token()
            if t is None:
                break
            print(t, file=sys.stderr)


class Lexer_xc(Lexer):

    literals = Lexer.literals + '{}|^'


# According to PLY documentation [6.12 Miscellaneous Yacc Notes;
# http://www.dabeaz.com/ply/ply.html#ply_nn36]:
#
# | [...] be aware that only one parser may be defined in a single module
# | (source file). There are various error checks and validation steps
# | that may issue confusing error messages if you try to define multiple
# | parsers in the same source file.
#
# That is why there is no global `parser' variable defined.

class BaseParser(object):

    debug = False  # create `parser.out'?
    write_tables = False  # create `parsetab.py'?
    tracking = True  # track positions of all grammar symbols, not only tokens?

    def __init__(self, **kwargs):
        assert hasattr(self, 'lexer')
        assert hasattr(self, 'start')
        self.tokens = Lexer.tokens
        kwargs.setdefault('debug', self.debug)
        kwargs.setdefault('write_tables', self.write_tables)
        self.parser = yacc.yacc(module=self, **kwargs)

    def parse(self, *args, **kwargs):
        kwargs.setdefault('lexer', self.lexer)
        kwargs.setdefault('tracking', self.tracking)
        return self.parser.parse(*args, **kwargs)

    def p_empty(self, p):
        """empty :"""

    def p_number(self, p):
        """number : DECNUM
                  | HEXNUM
                  | OCTNUM
        """
        p[0] = p[1]

    def p_fid(self, p):
        """fid : '(' number ',' number ')'"""
        p[0] = Fid(p[2], p[4])

    def p__ns(self, p):
        """numbers : number
                   | numbers ',' number
           strings : STRING
                   | strings ',' STRING
        """
        if len(p) == 2:
            p[0] = [p[1]]
        else:
            p[0] = p[1] + [p[3]]

    def position(self, p, n):
        return ' at byte %u' % (p.lexpos(n) + 1) if self.tracking else ''

    # Note that the argument is a token, not a parser.
    def p_error(self, t):
        if t is None:
            raise Error('Unexpected EOF')
        raise Error('Syntax error at byte %u' % (t.lexpos + 1))


class Parser_cg(BaseParser):
    """Parses string in "m0confgen" format."""

    def __init__(self, **kwargs):
        self.lexer = Lexer()
        self.start = 'maybe_objs'
        super(self.__class__, self).__init__(**kwargs)

    def p_maybe_objs(self, p):
        """maybe_objs : objs
                      | empty
        """
        p[0] = [] if p[1] is None else p[1]

    def p_objs(self, p):
        """objs : obj
                | objs obj
        """
        if len(p) == 2:
            p[0] = [p[1]]
        else:
            p[0] = p[1] + [p[2]]

    def p_obj(self, p):
        """obj : '(' objid attrs ')'"""
        if not all_unique([k for k, _ in p[3]]):
            raise Error('Attribute reassignment' + self.position(p, 3))
        p[0] = ConfObj(p[2], p[3])

    def p_objid(self, p):
        """objid : ID '-' number
                 | ID '-' number ':' number
        """
        try:
            otype = conf_obj_types[p[1]]
        except KeyError:
            raise Error('Unknown conf object type {!r}{}'.format(
                p[1], self.position(p, 1)))
        if len(p) == 4:
            p[0] = otype.to_fid(1, p[3])
        else:
            p[0] = otype.to_fid(p[3], p[5])

    def p_attrs(self, p):
        """attrs : attr
                 | attrs attr
        """
        if len(p) == 2:
            p[0] = [p[1]]
        else:
            p[0] = p[1] + [p[2]]

    def p_attr(self, p):
        """attr : ID '=' number
                | ID '=' STRING
                | ID '=' objid
                | ID '=' fid
                | ID '=' list
        """
        p[0] = p[1], p[3]

    def p_list(self, p):
        """list : '[' ']'
                | '[' numbers ']'
                | '[' strings ']'
                | '[' objids ']'
        """
        p[0] = [] if p[2] == ']' else p[2]

    def p_objids(self, p):
        """objids : objid
                  | objids ',' objid
        """
        if len(p) == 2:
            p[0] = [p[1]]
        else:
            p[0] = p[1] + [p[3]]


class Parser_xc(BaseParser):
    """Parses string in "xcode" format."""

    def __init__(self, **kwargs):
        self.lexer = Lexer_xc()
        self.start = 'xlist_xobj'
        super(self.__class__, self).__init__(**kwargs)

    def _check_xlist_len(self, position, expected, actual):
        if expected != actual:
            raise Error("""Bad list{}
Length ({}) != number of elements ({})""".format(position, expected, actual))

    def p_xlist_xobj(self, p):
        """xlist_xobj : xlist_empty
                     | '[' number ':' xobjs ']'
                     | empty
        """
        if len(p) == 6:
            self._check_xlist_len(self.position(p, 1), p[2], len(p[4]))
            p[0] = p[4]
        else:
            p[0] = []

    def p_xobjs(self, p):
        """xobjs : xobj
                 | xobjs ',' xobj
        """
        if len(p) == 2:
            p[0] = [p[1]]
        else:
            p[0] = p[1] + [p[3]]

    def p_xobj(self, p):
        """xobj : '{' number '|' '(' '(' xobjid ')' ',' union_xattrs ')' '}'
        """
        t1, objid = p[2], p[6]
        union_tag, attrs = p[9]
        otype = ConfObjType.from_fid(objid)
        t2 = ord(otype.ft_id)
        if t1 != t2:
            raise Error("""Inconsistent object type{}
{t1:#x} != {t2:#x} ('{t2:c}')""".format(self.position(p, 2), t1=t1, t2=t2))
        if union_tag != otype.union_tag:
            raise Error('Invalid union specification' + self.position(p, 9))
        if len(attrs) != len(otype.attrs):
            raise Error('Wrong number of attributes' + self.position(p, 1))
        p[0] = ConfObj(objid, zip([a.name for a in otype.attrs], attrs))

    def p_xobjid(self, p):
        """xobjid : xfid
        """
        if ConfObjType.from_fid(p[1]) is None:
            raise Error('Invalid conf fid {}{}'.format(
                p[1], self.position(p, 1)))
        p[0] = p[1]

    def p_xfid(self, p):
        """xfid : fid
                | xfid_custom
        """
        p[0] = p[1]

    # Custom format is only used for conf_fids at the moment.
    def p_xfid_custom(self, p):
        """xfid_custom : '^' ID '|' number ':' number
        """
        p[0] = Fid((p[2], p[4]), p[6])

    def p_union_xattrs(self, p):
        """union_xattrs : xattrs
                        | '{' number '|' '(' xattrs ')' '}'
        """
        if len(p) == 2:
            p[0] = None, p[1]
        else:
            p[0] = p[2], p[5]

    def p_xattrs(self, p):
        """xattrs : xattr
                  | xattrs ',' xattr
        """
        if len(p) == 2:
            p[0] = [p[1]]
        else:
            p[0] = p[1] + [p[3]]

    def p_xattr(self, p):
        """xattr : number
                 | STRING
                 | xfid
                 | xlist
        """
        p[0] = p[1]

    def p_xlist(self, p):
        """xlist : xlist_empty
                 | '[' number ':' numbers ']'
                 | '[' number ':' strings ']'
                 | '[' number ':' xobjids ']'
        """
        if p[1] == '[':
            nr, xs = p[2], p[4]
            self._check_xlist_len(self.position(p, 1), nr, len(xs))
            if nr > 1:
                assert len(set(map(type, xs))) == 1
                if type(xs[0]) is tuple and len(set([conf_obj_types[t].ft_id
                                                     for t, _ in xs])) > 1:
                    # xs is a list of xobjids; obj types differ
                    raise Error('Heterogeneous list' + self.position(p, 1))
            p[0] = xs
        else:
            p[0] = []

    def p_xlist_empty(self, p):
        """xlist_empty : '[' number ']'"""
        if p[2] != 0:
            raise Error("""Bad list%s
The length is non-zero, but there are no elements""" % self.position(p, 1))

    def p_xobjids(self, p):
        """xobjids : xobjid
                   | xobjids ',' xobjid
        """
        if len(p) == 2:
            p[0] = [p[1]]
        else:
            p[0] = p[1] + [p[3]]


# See m0_fid_sscanf(), FID_F().
def fid_scan(s):
    """str -> Fid

    Parses a string in FID_F format.
    """
    assert type(s) is str
    try:
        container, key = [int(x, base=16) for x in s.strip('<>').split(':', 1)]
    except ValueError:
        raise Error('Invalid fid: ' + s)
    return Fid(container, key)


def conf_objs_from_str(s, from_fmt):
    """conf_objs_from_str(string, format) -> list of ConfObj

    Converts input string of given format into a list of conf objects.
    """
    parsers = OrderedDict([('confgen', Parser_cg), ('xcode', Parser_xc)])
    assert list(parsers.keys()) == input_formats
    return parsers[from_fmt]().parse(s)


# --------------------------------------------------------------------
# Tests

if sys.version_info.major < 3:
    # unittest.TestCase.assertRaisesRegex does not exist in Python 2.
    # unittest.TestCase.assertRaisesRegexp is deprecated in Python 3.
    # Solve this issue by creating `assertRaisesRegex' alias for Python 2.
    unittest.TestCase.assertRaisesRegex = unittest.TestCase.assertRaisesRegexp


class TestInternalRepr(unittest.TestCase):

    def test_Fid(self):
        x = Fid(1, 2)
        self.assertEqual(x.tcontainer, (0, 1))
        self.assertEqual(x.typebyte(), 0)
        self.assertEqual(x.container(), 1)
        self.assertEqual(x.key, 2)
        self.assertEqual(repr(x), 'Fid(1, 2)')
        self.assertEqual(repr(x), str(x))
        self.assertEqual(x, Fid(1, 2))
        self.assertEqual(x, Fid((0, 1), 2))
        self.assertNotEqual(x, Fid(1, 1))

        y = Fid(('t', 1), 2)
        self.assertEqual(y.tcontainer, (0x74, 1))
        self.assertEqual(y.typebyte(), 0x74)
        self.assertEqual(y.container(), 0x7400000000000001)
        self.assertEqual(y.key, 2)
        self.assertEqual(repr(y), "Fid(('t', 1), 2)")
        self.assertEqual(repr(Fid((9, 1), 2)), 'Fid((9, 1), 2)')  # !isprint
        self.assertEqual(repr(Fid((0x23, 1), 2)), "Fid(('#', 1), 2)")
        self.assertEqual(y, Fid((0x74, 1), 2))
        self.assertEqual(y, Fid(0x7400000000000001, 2))
        self.assertNotEqual(y, x)
        self.assertEqual(Fid(('v', 0x40000000000002), 3),
                         Fid(0x7640000000000002, 3))

    def test_ConfObjType(self):
        self.assertEqual(repr(conf_obj_types['root']),
                         "ConfObjType('root', 't', 'verno=NUMBER"
                         " *profiles=[objid]')")
        self.assertEqual(repr(conf_obj_types['pver_f']),
                         "ConfObjType('pver_f', 'v:1', 'id=NUMBER"
                         " !base=objid allowance=[NUMBER]')")
        # to_fid()
        self.assertEqual(conf_obj_types['service'].to_fid(2, 3),
                         Fid(('s', 2), 3))
        self.assertEqual(conf_obj_types['pver'].to_fid(2, 3),
                         Fid(('v', 2), 3))
        self.assertEqual(conf_obj_types['pver_f'].to_fid(2, 3),
                         Fid(('v', 0x40000000000002), 3))
        self.assertRaisesRegex(
            Error, 'Union tag bits are not zero: 0x40000000000000',
            conf_obj_types['pver'].to_fid, 0x0040000000000000, 0)
        self.assertRaises(AssertionError, conf_obj_types['pver'].to_fid,
                          0x7600000000000000, 0)
        # from_fid()
        self.assertIsNone(ConfObjType.from_fid(Fid(1, 1)))
        self.assertEqual(ConfObjType.from_fid(Fid(('t', 1), 2)),
                         conf_obj_types['root'])
        self.assertEqual(ConfObjType.from_fid(Fid(('v', 1), 4)),
                         conf_obj_types['pver'])
        self.assertEqual(ConfObjType.from_fid(Fid(0x7600000000000001, 4)),
                         conf_obj_types['pver'])
        self.assertEqual(ConfObjType.from_fid(Fid(0x7640000000000001, 5)),
                         conf_obj_types['pver_f'])
        self.assertRaisesRegex(
            Error, 'Unsupported union tag: 0x7680000000000001',
            ConfObjType.from_fid, Fid(0x7680000000000001, 5))

    def test_ConfObjAttrType(self):
        self.assertEqual(repr(conf_obj_types['filesystem'].attrs[5]),
                         "ConfObjAttrType('*nodes', '[objid]')")

    def test_ConfObj(self):
        root_0 = Fid(('t', 1), 0)
        x = ConfObj(root_0, [('verno', 1), ('profiles', [])])
        self.assertEqual(repr(x), "ConfObj(Fid(('t', 1), 0),"
                         " [('verno', 1), ('profiles', [])])")
        self.assertRaisesRegex(Error, """\
Fid\(\('t', 1\), 0\): Invalid attributes
  missing: profiles, verno
  unknown: abc""", ConfObj, root_0, [('abc', 0)])
        self.assertEqual(x.attrs, [1, []])
        # Test __eq__() method.
        self.assertEqual(x, ConfObj(root_0, [('verno', 1), ('profiles', [])]))
        # The order of attributes does not matter.
        self.assertEqual(x, ConfObj(root_0, [('profiles', []), ('verno', 1)]))
        self.assertNotEqual(x, ConfObj(
            root_0, [('verno', 1), ('profiles', [Fid(('p', 1), 1)])]))


class TestEncoding(unittest.TestCase):

    def test_typed(self):
        def test(desc, x, xcode, confgen):
            self.assertEqual(Encoder_xc.typed(desc)(x), xcode)
            self.assertEqual(Encoder_cg.typed(desc)(x), confgen)

        test('NUMBER', 99, '99', '99')
        test('NUMBER', 100, '0x64', '0x64')
        test('STRING', 'abc', '"abc"', '"abc"')
        test('STRING', '', '""', '""')
        test('fid', Fid(1, 2), '(1, 2)', '(1, 2)'),
        test('fid', Fid(99, 100), '(99, 0x64)', '(99, 0x64)'),
        test('fid', Fid(('t', 1), 0), '^t|1:0', 'root-0'),
        test('objid', Fid(('t', 1), 0), '^t|1:0', 'root-0'),
        test('objid', Fid(('t', 0), 1), '^t|0:1', 'root-0:1'),
        test('objid', Fid(('v', 10), 11), '^v|10:11', 'pver-10:11'),
        test('objid', Fid(0x7640000000000001, 8),
             '^v|0x40000000000001:8', 'pver_f-8'),
        test('objid', Fid(('t', 100), 1), '^t|0x64:1', 'root-0x64:1'),
        test('objid', Fid(0x7640000000000001, 100),
             '^v|0x40000000000001:0x64', 'pver_f-0x64')
        for E in Encoder_xc, Encoder_cg:
            self.assertRaisesRegex(Error, 'Conf fid expected: Fid\(1, 2\)',
                                   E.typed('objid'), Fid(1, 2))
        for t in 'NUMBER', 'STRING', 'fid', 'objid':
            test('[' + t + ']', [], '[0]', '[]')
        test('[NUMBER]', [0, 1, 2], '[3: 0, 1, 2]', '[0, 1, 2]')
        test('[STRING]', ['a', 'b'], '[2: "a", "b"]', '["a", "b"]')
        test('[fid]', [Fid(1, 2), Fid(('p', 1), 1)],
             '[2: (1, 2), ^p|1:1]', '[(1, 2), profile-1]')

    def test_encode(self):
        def test(objs, xcode, confgen):
            self.assertEqual(Encoder_xc.encode(objs), xcode)
            self.assertEqual(Encoder_cg.encode(objs), confgen)

        test([], '', '')
        test([ConfObj(Fid(('t', 1), 0),
                      [('verno', 1), ('profiles', [Fid(('p', 1), 0)])]),
              ConfObj(Fid(('p', 1), 0), [('filesystem', Fid(('f', 1), 1))]),
              ConfObj(Fid(('f', 1), 1), [
                  ('rootfid', Fid(11, 22)), ('redundancy', 0),
                  ('params', ['param-0', 'param-1', 'param-2']),
                  ('mdpool', Fid(('o', 1), 5)), ('imeta_pver', Fid(0, 0)),
                  ('nodes', [Fid(('n', 1), 2), Fid(('n', 1), 48)]),
                  ('pools', [Fid(('o', 1), 4), Fid(('o', 1), 5)]),
                  ('racks', [Fid(('a', 1), 3)])])],
             """[3:
 {0x74| ((^t|1:0), 1, [1: ^p|1:0])},
 {0x70| ((^p|1:0), ^f|1:1)},
 {0x66| ((^f|1:1), (11, 22), 0, [3: "param-0", "param-1", "param-2"],\
 ^o|1:5, (0, 0), [2: ^n|1:2, ^n|1:48], [2: ^o|1:4, ^o|1:5], [1: ^a|1:3])}]""",
             """(root-0 verno=1 profiles=[profile-0])
(profile-0 filesystem=filesystem-1)
(filesystem-1 rootfid=(11, 22) redundancy=0\
 params=["param-0", "param-1", "param-2"] mdpool=pool-5 imeta_pver=(0, 0)\
 nodes=[node-2, node-48] pools=[pool-4, pool-5] racks=[rack-3])""")
        test([ConfObj(Fid(('v', 1), 8), [
            ('N', 1), ('K', 1), ('P', 5), ('tolerance', [0, 0, 0, 0, 1]),
            ('rackvs', [Fid(('j', 1), 12)])])],
             """[1:
 {0x76| ((^v|1:8), {0| (1, 1, 5, [5: 0, 0, 0, 0, 1], [1: ^j|1:12])})}]""",
             '(pver-8 N=1 K=1 P=5 tolerance=[0, 0, 0, 0, 1] rackvs=[objv-12])')
        test([ConfObj(Fid(0x7640000000000001, 9), [
            ('id', 0), ('base', Fid(('v', 1), 8)),
            ('allowance', [0, 0, 0, 0, 1])])],
             """[1:
 {0x76| ((^v|0x40000000000001:9), {1| (0, ^v|1:8, [5: 0, 0, 0, 0, 1])})}]""",
             '(pver_f-9 id=0 base=pver-8 allowance=[0, 0, 0, 0, 1])')

    def test_json(self):
        self.assertEqual(Encoder_json.encode([
            ConfObj(Fid(('t', 1), 0),
                    [('verno', 1), ('profiles', [Fid(('p', 1), 0)])]),
            ConfObj(Fid(('p', 1), 0), [('filesystem', Fid(('f', 1), 100))]),
            ConfObj(Fid(('f', 1), 100),
                    [('rootfid', Fid(11, 22)),
                     ('redundancy', 0),
                     ('params', ['param-0', 'param-1', 'param-2']),
                     ('mdpool', Fid(('o', 1), 5)),
                     ('imeta_pver', Fid(0, 0)),
                     ('nodes', [Fid(('n', 1), 2), Fid(('n', 1), 48)]),
                     ('pools', []), ('racks', [])])]),
                         """[
 {"objid": "root-0", "verno": 1, "profiles": ["profile-0"]},
 {"objid": "profile-0", "filesystem": "filesystem-0x64"},
 {"objid": "filesystem-0x64", "rootfid": [11, 22], "redundancy": 0,\
 "params": ["param-0", "param-1", "param-2"], "mdpool": "pool-5",\
 "imeta_pver": [0, 0], "nodes": ["node-2", "node-48"], "pools": [],\
 "racks": []}
]""")

    def test_html(self):
        self.assertEqual(Encoder_html.array_entries(
            ConfObj(Fid(('p', 1), 0), [('filesystem', Fid(('f', 1), 1))])),
                         ('{"id": "profile-0", "label": "profile-0",\
 "group": "profile", "_attrs": {"filesystem": "filesystem-1"}}',
                          ['{"from": "profile-0", "to": "filesystem-1"}']))

    def test_dot(self):
        self.assertEqual(Encoder_dot.encode_ConfObj(
            ConfObj(Fid(('t', 1), 0),
                    [('verno', 1), ('profiles', [Fid(('p', 1), 0)])])),
                         """
    "root-0";
    "dir_root-0_profiles" [height=0.15, width=0.15, label=""];
    "root-0" -> "dir_root-0_profiles" [label="profiles"];
    "dir_root-0_profiles" -> "profile-0";""")
        self.assertEqual(Encoder_dot.encode_ConfObj(
            ConfObj(Fid(('p', 1), 0), [('filesystem', Fid(('f', 1), 1))])),
                         """
    "profile-0";
    "profile-0" -> "filesystem-1" [label="filesystem"];""")
        self.assertEqual(Encoder_dot.encode([
            ConfObj(Fid(('p', 2), 3), [('filesystem', Fid(('f', 1), 1))]),
            ConfObj(Fid(('j', 1), 19),
                    [('real', Fid(('k', 1), 16)), ('children', [])])]),
                         """digraph conf {
    edge [arrowhead=open, fontsize=11];

    "profile-2:3";
    "profile-2:3" -> "filesystem-1" [label="filesystem"];

    "objv-19";
}""")

    def test_fid_translate(self):
        self.assertEqual(fid_translate(Fid(('p', 1), 0)), 'profile-0')
        self.assertEqual(fid_translate(Fid(1, 2)), None)
        self.assertEqual(fid_translate(Fid(('D', 0x73640000000001), 9)),
                         'dir_service-9_sdev')
        self.assertEqual(fid_translate(Fid(('D', 0x6a6a0000000001), 59)),
                         'dir_objv-59_objv')
        self.assertEqual(fid_translate(Fid(('D', 0x6a780000000001), 59)), None)
        self.assertEqual(fid_translate(Fid(('v', 0x40000000000001), 65)),
                         'pver_f-65')
        self.assertEqual(fid_translate(Fid(('v', 2), 8)), 'pver-2:8')
        self.assertEqual(fid_translate(Fid(('D', 0x766a0000000001), 8)),
                         'dir_pver-8_objv')
        self.assertEqual(fid_translate(Fid(('s', 0x73650000000001), 7)),
                         'service-0x73650000000001:7')


class TestDecoding(unittest.TestCase):

    def test_Parser_cg(self):
        decode = Parser_cg().parse
        self.assertEqual(decode(''), [])
        self.assertEqual(decode('# comment'), [])
        self.assertEqual(decode('(root-0 verno=2 profiles=[profile-0])'),
                         [ConfObj(Fid(('t', 1), 0), [
                             ('verno', 2), ('profiles', [Fid(('p', 1), 0)])])])
        self.assertEqual(decode(
            '(pver-10 N=2 K=1 P=4 tolerance=[0, 0, 0, 0, 1] rackvs=[objv-2])'),
                         [ConfObj(Fid(('v', 1), 10), [
                             ('N', 2), ('K', 1), ('P', 4),
                             ('tolerance', [0, 0, 0, 0, 1]),
                             ('rackvs', [Fid(('j', 1), 2)])])])
        self.assertEqual(decode(
            '(pver_f-66 id=0 base=pver-8 allowance=[0, 0, 0, 0, 1])'),
                         [ConfObj(Fid(('v', 0x40000000000001), 66), [
                             ('id', 0), ('base', Fid(('v', 1), 8)),
                             ('allowance', [0, 0, 0, 0, 1])])])
        self.assertRaisesRegex(
            Error, "Unknown conf object type 'woot' at byte \d+",
            decode, '(woot-0 verno=1 profiles=[])')
        self.assertRaisesRegex(Error, 'Attribute reassignment at byte \d+',
                               decode, '(root-0 verno=1 verno=2 profiles=[])')
        # The order of attributes does not matter.
        self.assertEqual(decode('(root-0 verno=2 profiles=[profile-0])'),
                         decode('(root-0 profiles=[profile-0] verno=2)'))

    def test_Parser_xc(self):
        decode = Parser_xc().parse
        self.assertEqual(decode(''), [])
        self.assertEqual(decode('# comment'), [])
        self.assertEqual(decode('[0]'), [])
        self.assertEqual(decode("""[1:
 {0x74| (((0x7400000000000001, 0)), 1, [1: (0x7000000000000002, 3)])}]"""),
                         [ConfObj(Fid(('t', 1), 0),
                                  [('verno', 1),
                                   ('profiles', [Fid(('p', 2), 3)])])])
        self.assertRaisesRegex(
            Error, "Invalid conf fid Fid\(\('X', 1\), 0\) at byte \d+",
            decode, '[1: {0x58| (((0x5800000000000001, 0)), 1, [0])}]')
        self.assertRaisesRegex(
            Error, 'Wrong number of attributes at byte \d+',
            decode, '[1: {0x74| (((0x7400000000000001, 0)), 1)}]')

    def test_fid_scan(self):
        self.assertEqual(fid_scan('7000000000000001:0'), Fid(('p', 1), 0))
        self.assertEqual(fid_scan('<446a6a0000000001:3b>'),
                         Fid(('D', 0x6a6a0000000001), 59))
        self.assertEqual(fid_scan('<7640000000000001:41>'),
                         Fid(('v', 0x40000000000001), 65))
        self.assertRaises(Error, fid_scan, '')
        self.assertRaisesRegex(Error, 'Invalid fid: garbage',
                               fid_scan, 'garbage')
        self.assertRaises(Error, fid_scan, '<446a6a00000000')


# --------------------------------------------------------------------
# main()

def main(argv=None):
    p = argparse.ArgumentParser(
        usage='%(prog)s [OPTION]... [FILE]',
        description='Converts configuration string from one format into'
        ' another.')
    p._optionals.title = 'Options'
    p.add_argument('--help-format',
                   help='print confgen format description and exit',
                   action='store_true')
    p.add_argument('-f', '--from', metavar='FMT', choices=input_formats,
                   dest='from_fmt', default='confgen',
                   help="input format: {}; default is `confgen'".format(
                       ', '.join(input_formats)))
    p.add_argument('-t', '--to', metavar='FMT', choices=output_formats,
                   dest='to_fmt', default='xcode',
                   help="output format: {}; default is `xcode'".format(
                       ', '.join(output_formats)))
    g = p.add_mutually_exclusive_group()
    g.add_argument('--types', help='print conf object types and exit',
                   action='store_true')
    g.add_argument('--svc-types', help='print service types and exit',
                   action='store_true')
    g.add_argument('--fids', help='read FIDs from stdin and show them in'
                   ' human-friendly format', action='store_true')
    g.add_argument('--self-check', help='run unit tests and exit',
                   action='store_true')
    g.add_argument('-V', '--version', action='version',
                   version='%(prog)s ' + __version__)
    g = p.add_argument_group('Positional argument')
    g.add_argument('file', metavar='FILE', nargs='?', default='-',
                   help='Input file. With no FILE, or when FILE is -,'
                   ' read standard input.')
    args = p.parse_args(argv)

    if args.self_check:
        unittest.main(argv=sys.argv[:1])  # calls sys.exit()

    if args.help_format:
        print(confgen_doc)
        return
    if args.types:
        types = conf_obj_types.items()
        types.sort(key=lambda kv: kv[1].ft_id)
        for k, v in types:
            print('{} {:#x} {}'.format(v.ft_id, ord(v.ft_id), k))
        return
    if args.svc_types:
        for i, s in enumerate(conf_service_types):
            print('{} {}'.format(i+1, s))
        return
    if args.fids:
        return fids_translate()

    if args.file == '-':
        f = sys.stdin
    else:
        try:
            f = open(args.file)
        except IOError as e:
            print(e, file=sys.stderr)
            return e.errno

    try:
        print(conf_objs_to_str(conf_objs_from_str(f.read(), args.from_fmt),
                               args.to_fmt))
    except Error as e:
        print(e, file=sys.stderr)
        return 1
    except IOError as e:
        if e.errno == EPIPE:
            return e.errno
        raise


__doc__ = __doc__.format(input_formats=', '.join(input_formats),
                         output_formats=', '.join(output_formats))


if __name__ == '__main__':
    sys.exit(main())

    # # Coverage testing:
    # for mode in '--help-format', '--types', '--svc-types':
    #     assert main([mode]) is None
    # for to_fmt in output_formats:
    #     assert main(['-f', 'confgen', '-t', to_fmt, 'ut/conf.cg']) is None
    #     assert main(['-f', 'xcode', '-t', to_fmt, 'ut/conf.xc']) is None
    # assert main(['--self-check']) is None
