#!/usr/bin/env python
from __future__ import print_function

### TODO:
###  - Profile.
###  - Parser: handle errors gracefully, do not `assert'.
###  - ? Change fid format:
###        fid = NUMBER ":" NUMBER
###  - ? Default values.
###  - ? Random values a-la QuickCheck.

from ply import lex, yacc
from optparse import OptionParser  # no argparse on devvm
import textwrap
import unittest
import sys
from errno import EPIPE

__version__ = '1.5.1'

__all__ = ['conf_objs_encode', 'conf_obj_encode']

__doc__ = """Configuration string generator.

Generates configuration string in xcode_read format from its
human-friendly description.

%(input_format)s
"""

input_format = """Input format:

    input   = [ seq(obj) ]
    seq(t)  = *( t )
    csv(t)  = t | csv(t) "," t
    obj     = "(" objid *( attr ) ")"
    objid   = objtype "-" [ NUMBER ":" ] NUMBER
    attr    = ID "=" ( NUMBER | STRING | fid | objid | list )
    fid     = "(" NUMBER "," NUMBER ")"
    list    = "[" [ csv(NUMBER) | csv(STRING) | csv(objid) ] "]"
    objtype = { %(objtypes)s }

Notes on objid specification:

    Generic descriptor
        <objtype>-<container>:<key>
    may be shortened to
        <objtype>-<key>
    when the <container> part is 1.

Examples:

    (root-0 verno=1 profiles=[profile-2:3])
    (profile-2:3 filesystem=filesystem-1)
    (filesystem-1 rootfid=(11, 12) redundancy=41212
        params=["param-0", "param-1", "param-2"]
        mdpool=pool-4
        nodes=[node-2] pools=[pool-4, pool-5] racks=[])

Configuration object types and attributes:

    %(attrs)s"""

class Error(Exception):
    pass

### ------------------------------------------------------------------
### Conf

### NOTE: These definitions should be in sync with m0_confx_* structures
### in conf/onwire.h.
###
### The attributes included in DOT output are marked with '!'.
conf_obj_types = {
    'root': ('t', # 0x74
             'verno=NUMBER !profiles=[objid]'),
    'profile': ('p', # 0x70
                '!filesystem=objid'),
    'filesystem': ('f', # 0x66
                   'rootfid=fid redundancy=NUMBER params=[STRING] mdpool=objid'
                   ' !nodes=[objid] !pools=[objid] !racks=[objid]'),
    'pool': ('o', # 0x6f
             'order=NUMBER !pvers=[objid]'),
    'pver': ('v', # 0x76
             'ver=NUMBER N=NUMBER K=NUMBER P=NUMBER nr_failures=[NUMBER]'
             ' !rackvs=[objid]'),
    'objv': ('j', # 0x6a
             'real=objid !children=[objid]'),
    'node': ('n', # 0x6e
             'memsize=NUMBER nr_cpu=NUMBER last_state=NUMBER flags=NUMBER'
             ' pool_id=objid !processes=[objid]'),
    'process': ('r', # 0x72
                'cores=[NUMBER] mem_limit_as=NUMBER mem_limit_rss=NUMBER'
                ' mem_limit_stack=NUMBER mem_limit_memlock=NUMBER'
                ' endpoint=STRING !services=[objid]'),
    'service': ('s', # 0x73
                'type=NUMBER endpoints=[STRING] !sdevs=[objid]'),
    'sdev': ('d', # 0x64
             'dev_idx=NUMBER iface=NUMBER media=NUMBER bsize=NUMBER'
             ' size=NUMBER last_state=NUMBER flags=NUMBER filename=STRING'),
    'rack': ('a', # 0x61
             '!encls=[objid] pvers=[objid]'),
    'enclosure': ('e', # 0x65
                  '!ctrls=[objid] pvers=[objid]'),
    'controller': ('c', # 0x63
                   'node=objid !disks=[objid] pvers=[objid]'),
    'disk': ('k', # 0x6b
             'dev=objid pvers=[objid]')
}


def maybe_conf_fid(fid):
    """Tries to convert given fid into a conf_fid.

    Returns None if conversion is not possible, i.e. if the fid is not
    of a conf object.

    Otherwise returns conf_fid in one of the following formats:
      (<objtype>, (<container>, <key>)) # <container> != 1
      (<objtype>, <key>)                # <container> == 1
    """
    container, key = fid
    fid_type = chr(container >> 56) # see M0_FID_TCONTAINER()
    container &= 0x00ffffffffffffff
    for t, v in conf_obj_types.items():
        if fid_type == v.ft_id:
            if container == 1:
                return t, key
            else:
                return t, (container, key)


def list_encode(xs, sep=' ', from_xcode=False):
    assert xs == [] or set(map(type, xs)) == set([str]), 'xs :: [str]'
    ## ['a', 'b', 'c']
    if from_xcode:
        return '[' + (',' + sep).join(xs) + ']' # ==> '[a, b, c]'
    return '[{}:{}{}]'.format(len(xs), sep, (',' + sep).join(xs)) if xs \
        else '[0]' # ==> '[3: a, b, c]'


def fid_encode(fid, from_xcode=False):
    if type(fid[0]) is int:
        ## (9, 10) ==> '(0x9, 0xa)'
        return '(%#x, %#x)' % fid
    return conf_fid_encode(fid, from_xcode)


def conf_fid_encode(conf_fid, from_xcode=False):
    a, b = conf_fid
    assert a in conf_obj_types.keys() # only conf_fids are accepted
    if type(b) is tuple:
        ## ('service', (4, 2))
        assert b[0] != 1
        if from_xcode:
            return a + '-%u:%u' % b # ==> '(service-4:2)'
        return '^%c|%u:%u' % ((ord(conf_obj_types[a].ft_id),) + b) #==> '^s|4:2'
    ## ('service', 42)
    if from_xcode:
        return a + '-' + str(b) # ==> '(service-42)'
    return '^%c|1:%u' % (ord(conf_obj_types[a].ft_id), b) # ==> '^s|1:42'


def _check_attrs(obj, from_xcode):
    objid, actual = obj
    assert type(actual) is (list if from_xcode else dict)
    expected = conf_obj_types[objid[0]].attrs
    if from_xcode:
        if len(actual) != len(expected):
            raise Error("""Invalid '{}' specification
Expected {} attributes, got {}""".format(objid[0], len(expected), len(actual)))
    else:
        actual = set(actual.keys())
        expected = set([a.name for a in expected])
        if actual != expected:
            diff = {'Missing': expected.difference(actual),
                    'Unknown': actual.difference(expected)}
            assert diff['Missing'] or diff['Unknown']
            msg = "Invalid '%s' specification" % objid[0]
            for adj, xs in diff.items():
                if xs:
                    msg += '\n{} attribute{}: {}'.format(
                        adj,
                        's' if len(xs) > 1 else '',
                        ', '.join(map(repr, xs)))
            raise Error(msg)


def conf_obj_encode(obj, from_xcode=False, enc=None):
    _check_attrs(obj, from_xcode)
    objid, attrs = obj
    otype = conf_obj_types[objid[0]]
    if from_xcode:
        attrs = dict([(a.name, v) for v, a in zip(attrs, otype.attrs)])

    if enc is None:
        enc = encode_from_xcode if from_xcode else encode_to_xcode
    else:
        assert callable(enc)
    return enc(objid, attrs, otype)


def encode_to_xcode(objid, attrs, otype):
    return '{0x%x| ((%s), %s)}' % (
        ord(otype.ft_id), conf_fid_encode(objid),
        ', '.join([a.encode(attrs[a.name]) for a in otype.attrs]))


def encode_from_xcode(objid, attrs, otype):
        return '(%s %s)' % (
            conf_fid_encode(objid, from_xcode=True),
            ' '.join(['%s=%s' % (a.name,
                                 a.encode(attrs[a.name], from_xcode=True))
                      for a in otype.attrs]))


def encode_to_dot(objid, attrs, otype):
    indent = ' '*4
    fid = conf_fid_encode(objid, from_xcode=True)
    s = ''
    for a in otype.attrs:
        if not a.visualize_p:
            continue
        if type(attrs[a.name]) is list:
            ## directory
            dir_id = 'dir_%s_%s' % (fid, a.name)
            s += """\
{indent}"{dir_id}" [height=0.15, width=0.15, label=""];
{indent}"{fid}" -> "{dir_id}" [label={relation}];
""".format(indent=indent, dir_id=dir_id, fid=fid, relation=a.name)
            for objid in attrs[a.name]:
                s += """\
{indent}"{dir_id}" -> "{fid}";
""".format(indent=indent, dir_id=dir_id,
           fid=conf_fid_encode(objid, from_xcode=True))
        else:
            ## not a directory
            s += """\
{indent}"{fid}" -> "{target}" [label={relation}];
""".format(indent=indent, fid=fid,
           target=conf_fid_encode(attrs[a.name], from_xcode=True),
           relation=a.name)
    return s


def encode_to_dot_simplified(objid, attrs, otype):
    if objid[0] not in ('node', 'process', 'service'):
        return
    indent = ' '*4
    fid = conf_fid_encode(objid, from_xcode=True)
    s = ''
    xlabel = dot_simplified_xlabel(objid[0], attrs)
    if xlabel:
        s += """\
{indent}"{fid}" [label="{fid}\\n{xlabel}"];
""".format(indent=indent, fid=fid, xlabel=xlabel)
    if objid[0] == 'service':
        return s # leaf level
    for a in otype.attrs:
        if not a.visualize_p:
            continue
        if type(attrs[a.name]) is list:
            ## directory
            for objid in attrs[a.name]:
                s += """\
{indent}"{parent}" -> "{child}";
""".format(indent=indent, parent=fid,
           child=conf_fid_encode(objid, from_xcode=True))
        else:
            ## not a directory
            s += """\
{indent}"{fid}" -> "{target}" [label={relation}];
""".format(indent=indent, fid=fid,
           target=conf_fid_encode(attrs[a.name], from_xcode=True),
           relation=a.name)
    return s


## See m0_conf_service_type.
conf_service_types = (
    'MDS', # = 1
    'IOS', 'MGS', 'RMS', 'STS', 'HA', 'SSS', 'SNS_REP', 'SNS_REB', 'ADDB2',
    '_DS1', '_DS2' # UT-specific
)

def dot_simplified_xlabel(objtype, attrs):
    if objtype == 'process':
        return attrs['endpoint']
    if objtype == 'service':
        t = attrs['type']
        if 0 < t <= len(conf_service_types):
            s = conf_service_types[t-1]
        else:
            s = '?%d?' % t
        if attrs['sdevs']:
            return '%s, %u sdevs' % (s, len(attrs['sdevs']))
        return s
    assert objtype == 'node'


def all_unique(xs):
    """Returns True iff all entries of the sequence are unique."""
    return len(xs) == len(set(xs))


def check_ids(xs):
    if not all_unique(xs):
        duplicates = set([x for x in xs if xs.count(x) > 1])
        assert duplicates
        raise Error('Duplicated identifier%s: %s' % (
            's' if len(duplicates) > 1 else '',
            ', '.join(map(str, duplicates))))


def conf_objs_encode(objs, from_xcode=False, enc=None):
    check_ids([objid for objid, _ in objs])
    objs = map(lambda obj: conf_obj_encode(obj, from_xcode=from_xcode, enc=enc),
               objs)
    if enc is not None:
        return '\n'.join(filter(None, objs))
    return '\n'.join(objs) if from_xcode else list_encode(objs, sep='\n ')


def conf_objs_encode_to_dot(objs, from_xcode=False, mode='full'):
    enc = {
        'full': encode_to_dot,
        'simplified': encode_to_dot_simplified
    }[mode]
    return """\
digraph x {
    edge [arrowhead=open, fontsize=11];

%s}""" % conf_objs_encode(objs, from_xcode, enc)


quote = lambda s, from_xcode=False: '"%s"' % s


def conf_type2enc(t):
    list_p = False
    if t[0] == '[':
        assert t[-1] == ']'
        list_p = True
        t = t[1:-1]
    enc = {
        'NUMBER': lambda n, from_xcode=False: str(n),
        'STRING': quote,
        'fid': fid_encode,
        'objid': conf_fid_encode
    }[t]
    if list_p:
        def list_enc(xs, from_xcode=False):
            xs = map(lambda x: enc(x, from_xcode=from_xcode), xs)
            return list_encode(xs, from_xcode=from_xcode)
        return list_enc
    else:
        return enc


class ConfObjAttr(object):
    def __init__(self, key, value):
        self.encode = conf_type2enc(value)
        if key.startswith('!'):
            self.name = key[1:]
            self.visualize_p = True
        else:
            self.name = key
            self.visualize_p = False


class ConfObjType(object):
    def __init__(self, ft_id, desc):
        self.ft_id = ft_id
        self.attrs = [ConfObjAttr(*kv) for kv in [a.split('=', 1)
                                                  for a in desc.split()]]
        self.desc = desc.replace('!', '')

conf_obj_types = dict((t, ConfObjType(*v)) for t, v in conf_obj_types.items())

input_format = input_format % {
    'objtypes': ' | '.join(map(quote, sorted(conf_obj_types.keys()))),
    'attrs': '\n    '.join(['%-14s%s' % (
        t + ':',
        textwrap.fill(v.desc, width=60, subsequent_indent=' '*22,
                      break_long_words=False))
                            for t, v in sorted(conf_obj_types.items())])
}
__doc__ = __doc__ % { 'input_format' : input_format }

### ------------------------------------------------------------------
### Lexer

class Lexer(object):

    tokens = ('HEXNUM', 'OCTNUM', 'DECNUM', 'STRING', 'ID')
    literals = '()[]-=,:'
    t_ignore = ' \t\r\v'
    t_ID = r'\b[a-zA-Z]\w*\b'

    def __init__(self, **kwargs):
        self.lexer = lex.lex(module=self, **kwargs)
        self.input = self.lexer.input
        self.token = self.lexer.token
        self.lineno = self.lexer.lineno
        self.lexpos = self.lexer.lexpos

    def t_HEXNUM(self, t):
        r'\b0[xX][0-9a-fA-F]+\b'
        t.value = int(t.value[2:], 16)
        return t

    def t_OCTNUM(self, t):
        r'\b0[0-7]+\b'
        t.value = int(t.value[1:], 8)
        return t

    def t_DECNUM(self, t):
        r'\b\d+\b'
        t.value = int(t.value)
        return t

    def t_STRING(self, t):
        r'"[^"]*"'
        t.value = t.value[1:-1]
        return t

    def t_comment(self, t):
        r'\#.*'

    def t_newline(self, t):
        r'\n+'
        t.lexer.lineno += len(t.value)

    def t_error(self, t):
        raise Error("Illegal character '%s' at byte %u" % (t.value[0],
                                                           t.lexpos + 1))

    def test(self, data):
        self.input(data)
        while True:
            t = self.token()
            if t is None:
                break
            print(t, file=sys.stderr)


class XCLexer(Lexer):

    literals = Lexer.literals + '{}|^'

### ------------------------------------------------------------------
### Parsers

## According to PLY documentation [6.12 Miscellaneous Yacc Notes;
## http://www.dabeaz.com/ply/ply.html#ply_nn36]:
##
## | [...] be aware that only one parser may be defined in a single module
## | (source file). There are various error checks and validation steps
## | that may issue confusing error messages if you try to define multiple
## | parsers in the same source file.
##
## That is why there is no global `parser' variable defined.

class _BaseParser(object):

    debug = False # create `parser.out'?
    write_tables = False # create `parsetab.py'?
    tracking = True # track positions of all grammar symbols, not only tokens?

    def __init__(self, **kwargs):
        assert hasattr(self, 'lexer')
        assert hasattr(self, 'start')
        self.tokens = Lexer.tokens
        kwargs.setdefault('debug', self.debug)
        kwargs.setdefault('write_tables', self.write_tables)
        self.parser = yacc.yacc(module=self, **kwargs)

    def parse(self, *args, **kwargs):
        kwargs.setdefault('lexer', self.lexer)
        kwargs.setdefault('tracking', self.tracking)
        return self.parser.parse(*args, **kwargs)

    def p_empty(self, p):
        """empty :"""

    def p_number(self, p):
        """number : DECNUM
                  | HEXNUM
                  | OCTNUM
        """
        p[0] = p[1]

    def p_fid(self, p):
        """fid : '(' number ',' number ')'"""
        p[0] = p[2], p[4]

    def p__ns(self, p):
        """numbers : number
                   | numbers ',' number
           strings : STRING
                   | strings ',' STRING
        """
        if len(p) == 2:
            p[0] = [p[1]]
        else:
            p[0] = p[1] + [p[3]]

    def position(self, p, n):
        return ' at byte %u' % (p.lexpos(n) + 1) if self.tracking else ''

    ## Note that the argument is a token, not a parser.
    def p_error(self, t):
        raise Error('Syntax error at byte %u' % (t.lexpos + 1))


class Parser(_BaseParser):
    """Parses string in "m0confgen" format."""

    def __init__(self, **kwargs):
        self.lexer = Lexer()
        self.start = 'maybe_objs'
        super(Parser, self).__init__(**kwargs)

    def p_maybe_objs(self, p):
        """maybe_objs : objs
                      | empty
        """
        p[0] = [] if p[1] is None else p[1]

    def p_objs(self, p):
        """objs : obj
                | objs obj
        """
        if len(p) == 2:
            p[0] = [p[1]]
        else:
            p[0] = p[1] + [p[2]]

    def p_obj(self, p):
        """obj : '(' objid attrs ')'"""
        assert all_unique([k for k, _ in p[3]]), 'Attribute reassignment'
        p[0] = p[2], dict(p[3])

    def p_objid(self, p):
        """objid : ID '-' number
                 | ID '-' number ':' number
        """
        assert p[1] in conf_obj_types.keys()
        if len(p) == 4:
            p[0] = p[1], p[3]
        else:
            p[0] = p[1], (p[3], p[5])

    def p_attrs(self, p):
        """attrs : attr
                 | attrs attr
        """
        if len(p) == 2:
            p[0] = [p[1]]
        else:
            p[0] = p[1] + [p[2]]

    def p_attr(self, p):
        """attr : ID '=' number
                | ID '=' STRING
                | ID '=' objid
                | ID '=' fid
                | ID '=' list
        """
        p[0] = p[1], p[3]

    def p_list(self, p):
        """list : '[' ']'
                | '[' numbers ']'
                | '[' strings ']'
                | '[' objids ']'
        """
        p[0] = [] if p[2] == ']' else p[2]

    def p_objids(self, p):
        """objids : objid
                  | objids ',' objid
        """
        if len(p) == 2:
            p[0] = [p[1]]
        else:
            p[0] = p[1] + [p[3]]


class XCParser(_BaseParser):
    """Parses string in "xcode" format."""

    def __init__(self, **kwargs):
        self.lexer = XCLexer()
        self.start = 'xlist_xobj'
        super(XCParser, self).__init__(**kwargs)

    def _check_xlist_len(self, position, expected, actual):
        if expected != actual:
            raise Error("""Bad list{}
Length ({}) != number of elements ({})""".format(position, expected, actual))

    def p_xlist_xobj(self, p):
        """xlist_xobj : xlist_empty
                     | '[' number ':' xobjs ']'
                     | empty
        """
        if len(p) == 6:
            self._check_xlist_len(self.position(p, 1), p[2], len(p[4]))
            p[0] = p[4]
        else:
            p[0] = []

    def p_xobjs(self, p):
        """xobjs : xobj
                 | xobjs ',' xobj
        """
        if len(p) == 2:
            p[0] = [p[1]]
        else:
            p[0] = p[1] + [p[3]]

    def p_xobj(self, p):
        """xobj : '{' number '|' '(' '(' xobjid ')' ',' xattrs ')' '}'"""
        t1, objid, attrs = p[2], p[6], p[9]
        t2 = ord(conf_obj_types[objid[0]].ft_id)
        if t1 != t2:
            raise Error("""Inconsistent object type{}
{t1:#x} != {t2:#x} ('{t2:c}')""".format(self.position(p, 2), t1=t1, t2=t2))
        p[0] = objid, attrs

    def p_xobjid(self, p):
        """xobjid : xfid"""
        if type(p[1][0]) is not str:
            raise Error('Invalid conf_fid' + self.position(p, 1))
        p[0] = p[1]

    def p_xfid(self, p):
        """xfid : fid
                | xfid_custom
        """
        conf_fid = maybe_conf_fid(p[1])
        p[0] = p[1] if conf_fid is None else conf_fid

    ## Custom format is only used for conf_fids at the moment.
    def p_xfid_custom(self, p):
        """xfid_custom : '^' ID '|' number ':' number"""
        fid_type, container, key = p[2], p[4], p[6]
        try:
            ## See M0_FID_TCONTAINER().
            p[0] = (ord(fid_type) << 56 | container & 0x00ffffffffffffff), key
        except TypeError: # thrown by ord(s) when len(s) > 1
            raise Error('Invalid conf_fid' + self.position(p, 1))

    def p_xattrs(self, p):
        """xattrs : xattr
                  | xattrs ',' xattr
        """
        if len(p) == 2:
            p[0] = [p[1]]
        else:
            p[0] = p[1] + [p[3]]

    def p_xattr(self, p):
        """xattr : number
                 | STRING
                 | xfid
                 | xlist
        """
        p[0] = p[1]

    def p_xlist(self, p):
        """xlist : xlist_empty
                 | '[' number ':' numbers ']'
                 | '[' number ':' strings ']'
                 | '[' number ':' xobjids ']'
        """
        if p[1] == '[':
            nr, xs = p[2], p[4]
            self._check_xlist_len(self.position(p, 1), nr, len(xs))
            if nr > 1:
                assert len(set(map(type, xs))) == 1
                if type(xs[0]) is tuple and len(set([t for t, _ in xs])) > 1:
                    ## xs is a list of xobjids; obj types differ
                    raise Error('Heterogeneous list' + self.position(p, 1))
            p[0] = xs
        else:
            p[0] = []

    def p_xlist_empty(self, p):
        """xlist_empty : '[' number ']'"""
        if p[2] != 0:
            raise Error("""Bad list%s
The length is non-zero, but there are no elements""" % self.position(p, 1))

    def p_xobjids(self, p):
        """xobjids : xobjid
                   | xobjids ',' xobjid
        """
        if len(p) == 2:
            p[0] = [p[1]]
        else:
            p[0] = p[1] + [p[3]]

### ------------------------------------------------------------------
### Tests

class TestHelpers(unittest.TestCase):

    def test_helpers(self):
        self.assertIsNone(maybe_conf_fid((11, 22)))
        self.assertEqual(maybe_conf_fid((0x6400000000000001, 2)), ('sdev', 2))
        self.assertEqual(maybe_conf_fid((0x6400000000000000, 1)),
                         ('sdev', (0, 1)))

class TestParser(unittest.TestCase):

    def setUp(self):
        self.parser = Parser()
        self.parse = self.parser.parse

    def test_parse(self):
        self.assertEqual(self.parse(''), [])
        self.assertEqual(self.parse('(profile-0 filesystem=filesystem-1:2)'),
                         [(('profile', 0),
                           dict(filesystem=('filesystem', (1, 2))))])
        self.assertEqual(self.parse(
            '(root-10 verno=0xa profiles=[profile-012])'),
                         [(('root', 10),
                           dict(verno=10, profiles=[('profile', 10)]))])
        self.assertEqual(self.parse(
"""(filesystem-1 rootfid=(11, 12) redundancy=41212
    params=["param-0", "param-1", "param-2"]
    mdpool=pool-4
    nodes=[node-2] pools=[pool-4] racks=[])
"""),
                         [(('filesystem', 1), dict(
                             rootfid=(11, 12),
                             redundancy=41212,
                             params=['param-0', 'param-1', 'param-2'],
                             mdpool=('pool', 4),
                             nodes=[('node', 2)],
                             pools=[('pool', 4)],
                             racks=[]))])
        self.assertEqual(self.parse("""(profile-2:3 filesystem=filesystem-1)
(filesystem-1 rootfid=(11, 12) redundancy=41212
    params=["param-0", "param-1", "param-2"]
    mdpool=pool-4
    nodes=[node-2] pools=[pool-4] racks=[rack-3])
"""),
                         [(('profile', (2, 3)),
                           dict(filesystem=('filesystem', 1))),
                          (('filesystem', 1), dict(
                              rootfid=(11, 12),
                              redundancy=41212,
                              params=['param-0', 'param-1', 'param-2'],
                              mdpool=('pool', 4),
                              nodes=[('node', 2)],
                              pools=[('pool', 4)],
                              racks=[('rack', 3)]))])
        self.assertEqual(69, len(self.parse(file('ut/conf.cg').read())))


class TestEncoders(unittest.TestCase):

    def _test(self, encode):
        def test(internal, xcode, confgen=None):
            ## internal -- internal representation of conf data, produced
            ##             by a parser
            ## xcode    -- expected result of encoding to "xcode" format
            ## confgen  -- expected result of encoding to "confgen" format
            ##             (default is the value of xcode)
            self.assertEqual(encode(internal), xcode)
            self.assertEqual(encode(internal, from_xcode=True),
                             xcode if confgen is None else confgen)
        return test

    def test_type2enc(self):
        test = lambda t: self._test(conf_type2enc(t))
        test('NUMBER')(42, '42')
        test('STRING')('abc', '"abc"')
        test('fid')((11, 22), '(0xb, 0x16)')
        for t in ('fid', 'objid'):
            test(t)(('node', 4), '^n|1:4', 'node-4')
            test(t)(('node', (4, 1)), '^n|4:1', 'node-4:1')
        ## 'objid' encoding accepts conf_fids only; (11, 22) is not a conf_fid
        self.assertRaises(AssertionError, conf_type2enc('objid'), (11, 22))
        self.assertRaises(AssertionError, conf_type2enc('objid'), (11, 22),
                          from_xcode=True)
        for t in ('NUMBER', 'STRING', 'fid', 'objid'):
            test('[%s]' % t)([], '[0]', '[]')
        test('[NUMBER]')([3, 4], '[2: 3, 4]', '[3, 4]')
        test('[STRING]')('abc', '[3: "a", "b", "c"]', '["a", "b", "c"]')
        test('[fid]')([(11, 22)], '[1: (0xb, 0x16)]', '[(0xb, 0x16)]')
        for t in ('[fid]', '[objid]'):
            test(t)([('node', 4)], '[1: ^n|1:4]', '[node-4]')
            test(t)([('node', (4, 1))], '[1: ^n|4:1]', '[node-4:1]')
            test(t)([('sdev', 2), ('sdev', (3, 4))], '[2: ^d|1:2, ^d|3:4]',
                    '[sdev-2, sdev-3:4]')

    def test_fid_encode(self):
        test_fid = self._test(fid_encode)
        for test in test_fid, self._test(conf_fid_encode):
            test(('service', 42), '^s|1:42', 'service-42')
            test(('service', (4, 2)), '^s|4:2', 'service-4:2')
        test_fid((9, 10), '(0x9, 0xa)')
        self.assertRaises(AssertionError, conf_fid_encode, (5, 1))
        self.assertRaises(AssertionError, conf_fid_encode, (5, 1),
                          from_xcode=True)

    def test_list_encode(self):
        test = self._test(list_encode)
        test([], '[0]', '[]')
        test(['foo'], '[1: foo]', '[foo]')
        test(['foo', 'bar'], '[2: foo, bar]', '[foo, bar]')

    def test_obj_encode(self):
        self.assertEqual(conf_obj_encode(
            (('root', 0),
             dict(verno=1, profiles=[('profile', 0), ('profile', (2, 3))]))),
                         '{0x74| ((^t|1:0), 1, [2: ^p|1:0, ^p|2:3])}')
        self.assertEqual(conf_obj_encode(
            (('objv', 19), dict(real=('disk', 16), children=[]))),
                         '{0x6a| ((^j|1:19), ^k|1:16, [0])}')
        self.assertEqual(conf_obj_encode(
            (('root', 0), [1, [('profile', (2, 3))]]), from_xcode=True),
                         '(root-0 verno=1 profiles=[profile-2:3])')
        self.assertEqual(conf_obj_encode((('objv', 19), [('disk', 16), []]),
                                         from_xcode=True),
                         '(objv-19 real=disk-16 children=[])')

    def test_obj_encode_errors(self):
        self.assertRaisesRegexp(Error, """Invalid 'root' specification
Missing attribute: 'profiles'""", conf_obj_encode, (('root', 0), {'verno': 1}))
        self.assertRaisesRegexp(Error, """Invalid 'root' specification
Unknown attributes: 'a', 'b'""", conf_obj_encode, (
    ('root', 0), dict(verno=1, profiles=[], a=9, b=9)))
        self.assertRaisesRegexp(Error, """Invalid 'root' specification
Unknown attribute: 'ver'
Missing attribute: 'verno'""", conf_obj_encode, (('root', 0),
                                                 dict(ver=1, profiles=[])))
        self.assertRaisesRegexp(Error, """Invalid 'root' specification
Expected 2 attributes, got 1""", conf_obj_encode,
                                (('root', 0), [1]), from_xcode=True)
        self.assertRaisesRegexp(Error, """Invalid 'root' specification
Expected 2 attributes, got 3""", conf_obj_encode,
                                (('root', 0), [1, [], 0]), from_xcode=True)

    def test_encode(self):
        self.assertEqual(conf_objs_encode([]), '[0]')
        self.assertEqual(conf_objs_encode([
            (('root', 0), dict(verno=1, profiles=[('profile', (2, 3))])),
            (('profile', (2, 3)), dict(filesystem=('filesystem', 1))),
            (('filesystem', 1), dict(rootfid=(11, 22), redundancy=41212,
                                     params=["param-0", "param-1", "param-2"],
                                     mdpool=('pool', 4), nodes=[('node', 2)],
                                     pools=[('pool', 4)], racks=[('rack', 3)])),
            (('objv', 19), dict(real=('disk', 16), children=[]))]),
                         """[4:
 {0x74| ((^t|1:0), 1, [1: ^p|2:3])},
 {0x70| ((^p|2:3), ^f|1:1)},
 {0x66| ((^f|1:1), (0xb, 0x16), 41212, [3: "param-0", "param-1", "param-2"],\
 ^o|1:4, [1: ^n|1:2], [1: ^o|1:4], [1: ^a|1:3])},
 {0x6a| ((^j|1:19), ^k|1:16, [0])}]""")
        self.assertEqual(conf_objs_encode([], from_xcode=True), '')
        self.assertEqual(conf_objs_encode([
            (('root', 0), [1, [('profile', (2, 3))]]),
            (('profile', (2, 3)), [('filesystem', 1)]),
            (('filesystem', 1),
             [(11, 22), 41212, ["param-0", "param-1", "param-2"],
              ('pool', 4), [('node', 2)], [('pool', 4)], [('rack', 3)]]),
            (('objv', 19), [('disk', 16), []])], from_xcode=True), """\
(root-0 verno=1 profiles=[profile-2:3])
(profile-2:3 filesystem=filesystem-1)
(filesystem-1 rootfid=(0xb, 0x16) redundancy=41212\
 params=["param-0", "param-1", "param-2"] mdpool=pool-4 nodes=[node-2]\
 pools=[pool-4] racks=[rack-3])
(objv-19 real=disk-16 children=[])""")
        ## There and Back Again.
        confgen = """\
(root-0 verno=1 profiles=[profile-2:3])
(profile-2:3 filesystem=filesystem-1)"""
        xcode = conf_objs_encode(Parser().parse(confgen))
        self.assertEqual(conf_objs_encode(XCParser().parse(xcode),
                                          from_xcode=True), confgen)

    def test_encode_duplicates(self):
        self.assertRaisesRegexp(Error, "Duplicated identifier: \('root', 0\)",
                                conf_objs_encode,
                                [(('root', 0), dict(verno=1, profiles=[]))] * 2)
        self.assertRaisesRegexp(Error,
                                "Duplicated identifier: \('profile', 0\)",
                                conf_objs_encode,
                                [(('profile', 0), [('filesystem', 1)])] * 2,
                                from_xcode=True)

    def test_file(self):
        conf_objs_encode(Parser().parse(file('ut/conf.cg').read()))
        conf_objs_encode(XCParser().parse(file('ut/conf.xc').read()),
                         from_xcode=True)

    def test_dot(self):
        self.assertEqual(conf_obj_encode(
            (('root', 0),
             dict(verno=1, profiles=[('profile', 0), ('profile', (2, 3))])),
            enc=encode_to_dot),
                         """\
    "dir_root-0_profiles" [height=0.15, width=0.15, label=""];
    "root-0" -> "dir_root-0_profiles" [label=profiles];
    "dir_root-0_profiles" -> "profile-0";
    "dir_root-0_profiles" -> "profile-2:3";
""")
        self.assertEqual(conf_obj_encode((('profile', (2, 3)),
                                          dict(filesystem=('filesystem', 1))),
                                         enc=encode_to_dot),
                         """\
    "profile-2:3" -> "filesystem-1" [label=filesystem];
""")
        self.assertEqual(conf_obj_encode(
            (('filesystem', 1),
             dict(rootfid=(11, 22), redundancy=41212, params=["param-0"],
                  mdpool=('pool', 4), nodes=[('node', 1), ('node', (2, 3))],
                  pools=[('pool', 4)], racks=[('rack', 5)])),
            enc=encode_to_dot),
                         """\
    "dir_filesystem-1_nodes" [height=0.15, width=0.15, label=""];
    "filesystem-1" -> "dir_filesystem-1_nodes" [label=nodes];
    "dir_filesystem-1_nodes" -> "node-1";
    "dir_filesystem-1_nodes" -> "node-2:3";
    "dir_filesystem-1_pools" [height=0.15, width=0.15, label=""];
    "filesystem-1" -> "dir_filesystem-1_pools" [label=pools];
    "dir_filesystem-1_pools" -> "pool-4";
    "dir_filesystem-1_racks" [height=0.15, width=0.15, label=""];
    "filesystem-1" -> "dir_filesystem-1_racks" [label=racks];
    "dir_filesystem-1_racks" -> "rack-5";
""")
        self.assertEqual(conf_obj_encode(
            (('objv', 19), dict(real=('disk', 16), children=[])),
            enc=encode_to_dot),
                         """\
    "dir_objv-19_children" [height=0.15, width=0.15, label=""];
    "objv-19" -> "dir_objv-19_children" [label=children];
""")
        self.assertEqual(conf_obj_encode(
            (('root', 0), [1, [('profile', (2, 3))]]), from_xcode=True,
            enc=encode_to_dot),
                         """\
    "dir_root-0_profiles" [height=0.15, width=0.15, label=""];
    "root-0" -> "dir_root-0_profiles" [label=profiles];
    "dir_root-0_profiles" -> "profile-2:3";
""")
        self.assertEqual(conf_obj_encode(
            (('profile', (2, 3)), [('filesystem', 1)]), from_xcode=True,
            enc=encode_to_dot),
                         """\
    "profile-2:3" -> "filesystem-1" [label=filesystem];
""")
        self.assertEqual(conf_objs_encode_to_dot([
            (('profile', (2, 3)), dict(filesystem=('filesystem', 1))),
            (('objv', 19), dict(real=('disk', 16), children=[]))]),
                         """\
digraph x {
    edge [arrowhead=open, fontsize=11];

    "profile-2:3" -> "filesystem-1" [label=filesystem];

    "dir_objv-19_children" [height=0.15, width=0.15, label=""];
    "objv-19" -> "dir_objv-19_children" [label=children];
}""")

    def test_custom_encoder(self):
        def enc(objid, attrs, otype):
            if objid[0] == 'node':
                return repr(objid)

        self.assertIsNone(conf_obj_encode(
            (('root', 0), dict(verno=1, profiles=[('profile', 0)])),
            enc=enc))
        self.assertEqual(conf_obj_encode(
            (('node', 14),
             dict(memsize=64230, nr_cpu=20, last_state=0, flags=0,
                  pool_id=('pool', 2), processes=[])),
            enc=enc),
                         "('node', 14)")
        self.assertEqual(conf_objs_encode(
            [(('root', 0), [1, [('profile', 0)]]),
             (('node', 1), [64230, 20, 0, 0, ('pool', 1), []]),
             (('node', 2), [64230, 20, 0, 0, ('pool', 2), []])],
            from_xcode=True, enc=enc),
                         "('node', 1)\n('node', 2)")


class TestXCParser(unittest.TestCase):

    def setUp(self):
        self.parser = XCParser()
        self.parse = self.parser.parse

    def test_parse(self):
        self.assertEqual(self.parse(''), [])
        self.assertEqual(self.parse('[0]'), [])
        self.assertEqual(self.parse("""[1:
{0x74| (((0x7400000000000001, 0)), 1, [1: (0x7000000000000002, 3)])}]"""),
                         [(('root', 0), [1, [('profile', (2, 3))]])])
        self.assertEqual(self.parse("""[1:
{0x74| (((0x7400000000000001, 0)), 1, [1: (0x7000000000000002, 3)])}]"""),
                         [(('root', 0), [1, [('profile', (2, 3))]])])
        self.assertEqual(self.parse('[1: {0x74| ((^t|1:0), 1, [1: ^p|1:0])}]'),
                         [(('root', 0), [1, [('profile', 0)]])])
        self.assertEqual(self.parse("""[3:
# (disk-55 dev=sdev-51 pvers=[pver-57])
{0x6b| ((^k|1:55), ^d|1:51, [1: ^v|1:57])},
# (pool-56 order=0 pvers=[pver-57])
{0x6f| ((^o|1:56), 0, [1: ^v|1:57])},
# (pver-57 ver=0 N=8 K=2 P=15 nr_failures=[] rackvs=[objv-58])
{0x76| ((^v|1:57), 0, 8, 2, 15, [0], [1: ^j|1:58])}]"""), [
    (('disk', 55), [('sdev', 51), [('pver', 57)]]),
    (('pool', 56), [0, [('pver', 57)]]),
    (('pver', 57), [0, 8, 2, 15, [], [('objv', 58)]])])
        self.assertEqual(69, len(self.parse(file('ut/conf.xc').read())))

    def test_errors(self):
        self.assertRaisesRegexp(Error, """Bad list.*
The length is non-zero, but there are no elements""", self.parse, '[1]')
        self.assertRaisesRegexp(Error, """Bad list.*
Length \(2\) != number of elements \(1\)""", self.parse,
                                ' [2: {0x74| ((^t|1:0), 1, [0])}]')
        self.assertRaisesRegexp(Error, 'Invalid conf_fid.*',
                                self.parse, '[1: {0x58| ((^X|1:0), [0])}]')
        self.assertRaisesRegexp(Error, 'Invalid conf_fid.*', self.parse,
                                '[1: {0x58| (((0x5800000000000001, 0)), [0])}]')
        self.assertRaisesRegexp(Error, 'Invalid conf_fid.*',
                                self.parse, '[1: {0x58| ((^XY|1:0), [0])}]')
        self.assertRaisesRegexp(Error, """Inconsistent object type.*
0x70 != 0x66 \('f'\)""",
                                self.parse, '[1: {0x70| ((^f|1:0), ^f|1:0)}]')
        self.assertRaisesRegexp(Error, '^Heterogeneous list', self.parse,
                                """[1:
{0x6a| ((^j|1:1), ^a|1:2,
        # xlist may not contain elements of different types
        [2: ^j|1:3, ^a|1:4])}]""")

### ------------------------------------------------------------------
### main

def encode_and_print(s, from_xcode, dot_mode):
    try:
        p = XCParser() if from_xcode else Parser()
        if dot_mode:
            print(conf_objs_encode_to_dot(p.parse(s), from_xcode=from_xcode,
                                          mode=dot_mode))
        else:
            print(conf_objs_encode(p.parse(s), from_xcode=from_xcode))
    except Error, e:
        print(e, file=sys.stderr)
        return 1
    except IOError, e:
        if e.errno == EPIPE:
            return e.errno
        raise


def main():
    op = OptionParser(usage='%prog [OPTION]... [FILE]',
                      description='Generates configuration string in "xcode"'
                      ' format from its human-friendly description.',
                      epilog='  FILE    Input file. With no FILE, or when FILE'
                      ' is -, read standard input.',
                      version='%prog ' + __version__)
    op.add_option('--help-format',
                  help='Print input format documentation and exit.',
                  action='store_true')
    op.add_option('-x', '--from-xcode', help='Convert conf string from "xcode"'
                  ' format to "confgen" format.', action='store_true')
    op.add_option('--dot', help='Generate DOT output.' \
                  " Supported MODEs: 'full' - all conf objects are shown;"
                  " 'simplified' - only node, process and service objects are.",
                  type='choice', choices=['full', 'simplified'], metavar='MODE')
    op.add_option('--types', help='Print conf object types and exit.',
                  action='store_true')
    op.add_option('--svc-types', help='Print service types and exit.',
                  action='store_true')
    op.add_option('--self-check', help='Run unit tests and exit.',
                  action='store_true')
    opts, args = op.parse_args()
    if len(args) > 1:
        op.error("Invalid arguments\nUse `--help'.")

    if opts.help_format:
        print(input_format)
        return
    if opts.types:
        types = conf_obj_types.items()
        types.sort(key=lambda kv: kv[1].ft_id)
        for k, v in types:
            print('{} {:#x} {}'.format(v.ft_id, ord(v.ft_id), k))
        return
    if opts.svc_types:
        for i, s in enumerate(conf_service_types):
            if not s.startswith('_'):
                print('{} {}'.format(i+1, s))
        return
    if opts.self_check:
        unittest.main(argv=sys.argv[:1])

    if not args or args[0] == '-':
        f = sys.stdin
    else:
        try:
            f = file(args[0])
        except IOError, e:
            print(e, file=sys.stderr)
            return e.errno
    return encode_and_print(f.read(), opts.from_xcode, opts.dot)


if __name__ == '__main__':
    sys.exit(main())
