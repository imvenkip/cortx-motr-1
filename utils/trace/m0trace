#!/usr/bin/env perl

# COPYRIGHT 2012 XYRATEX TECHNOLOGY LIMITED
#
# THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
# HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
# LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
# THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
# BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
# USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
# EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
# THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
# http://www.xyratex.com/contact
#
# Original author: Dmitriy Chumak <dmitriy_chumak@xyratex.com>
# Original creation date: 28-Dec-2012


# This program displays Mero trace log in human friendly form, allowing to
# filter log entries by various parameters, like log level, subsystem, file,
# func name, etc.

# For detailed description and usage information please refer to the POD
# documentation at the end of file, after the __END__ marker.


# enable all features of Modern Perl, almost the same as done by Modern::Perl
# module, but doesn't require it as dependency
use 5.010;
use strict;
use warnings;
use autodie;


# check that all required external modules are available and display a hint to
# the user about how they can be installed using default package management
# system, if they are missing
BEGIN {

    my @required_modules = (
        {
            name       => 'YAML::XS',
            debian_pkg => 'libyaml-libyaml-perl',
            redhat_pkg => 'perl-YAML-LibYAML'
        },
        {
            name       => 'DateTime',
            debian_pkg => 'libdatetime-perl',
            redhat_pkg => 'perl-DateTime'
        },
        {
            name       => 'File::Which',
            debian_pkg => 'libfile-which-perl',
            redhat_pkg => 'perl-File-Which'
        },
        {
            name       => 'List::MoreUtils',
            debian_pkg => 'liblist-moreutils-perl',
            redhat_pkg => 'perl-List-MoreUtils'
        },
    );
    my $some_module_is_missing = 0;

    for my $m (@required_modules) {

        my $module = $m->{name};

        $module =~ s#::#/#g;
        $module .= '.pm';

        no warnings 'uninitialized';
        if (eval { require $module; 1; } ne 1) {
            use warnings 'uninitialized';
            $some_module_is_missing = 1;
            print "$m->{name} perl module is missing\n"
                  . "   It can be installed manually or using package management system:\n"
                  . "     debian based:  apt-get install $m->{debian_pkg}\n"
                  . "     red-hat based: yum install $m->{redhat_pkg}\n"
                  . "     manually:      cpanm $m->{name}\n\n";
        }
    }

    die "Please, install all required modules\n"
        if $some_module_is_missing;
}


package Tie::Array::Lazy::YAMLstream;
{
    use base qw( Tie::Array );

    use Carp;
    use Try::Tiny;
    use English qw( -no_match_vars ); # avoids regex performance penalty
    use POSIX qw( INT_MAX );
    #use Data::Dumper;

    our $VERSION = '1.002001';
    $VERSION = eval $VERSION;


    sub TIEARRAY
    {
        my $class = shift;
        my $file  = shift;

        open my $stream, "$file";

        my $self = {
            stream        => $stream,
            current_index => 0,
        };

        if (not eof $self->{stream}) {
            local $INPUT_RECORD_SEPARATOR = '---';

            my $doc = readline $self->{stream};
            chomp $doc;

            try {
                $self->{current} = YAML::XS::Load( $doc );
            }
            catch {
                carp "malformed YAML data: $_";
            };
        }

        return bless $self, $class;;
    }

    sub DESTROY
    {
        my $self = shift;

        close $self->{stream};
    }

    sub FETCH
    {
        my $self  = shift;
        my $index = shift;


        if ($self->{current_index} == $index) {

            croak "Internal error in package " . __PACKAGE__ . " - no current"
                  . " element for index $index\n"
                if !exists $self->{current};

            return $self->{current};
        }
        else {
            $self->{current_index} = $index;
        }

        while (not eof $self->{stream}) {
            local $INPUT_RECORD_SEPARATOR = "---\n";

            my $doc = readline $self->{stream};
            chomp $doc;

            try {
                $self->{current} = YAML::XS::Load( $doc );
            }
            catch {
                my ($doc_without_msg) = $doc =~ /^(.*)(?=msg:)/xms;
                carp "malformed YAML data: $_\n"
                     . "guilty trace record:\n$doc_without_msg";
                $self->{current} = undef;
            };

            return $self->{current}
                if defined $self->{current};
        }

        return;
    }

    sub FETCHSIZE
    {
        my $self = shift;

        return defined $self->{current} ? INT_MAX : 0;
    }
}


package main;

# core modules
use English qw( -no_match_vars ); # avoids regex performance penalty
use Getopt::Long qw( :config no_ignore_case bundling );
use Pod::Usage;
use IO::Handle;
use Term::ANSIColor;
use File::Temp qw( tempfile );
use File::Spec;
use File::Copy;

# external modules (not included into base perl distribution)
use YAML::XS;
use DateTime;
use File::Which;
use List::MoreUtils qw( any none );
#use IPC::System::Simple qw( run capture );

# debuging
#use Data::Dumper;


# global variables
my %cli_option = (
    input_file      => '-', # STDIN by default
    output_file     => '-', # STDOUT by default
    stream_mode     => 1,
    use_pager       => 1,
    flush_output    => 0,
    log_dir         => '/var/log/mero',
    mero_dir        => '/var/mero',
    color           => 'auto',
    format          => 'med',
    level           => 'call+',
    subsys          => 'all',
    relpath         => 1,
    column_width    => 50,
    stackaddr_width => 7,
    stackaddr_hl    => 2,
    func            => undef, # all funcs
);

my %level = (
    'call'    => qr/ ^ CALL $ /xms,
    'debug'   => qr/ ^ DEBUG $ /xms,
    'info'    => qr/ ^ INFO $ /xms,
    'notice'  => qr/ ^ NOTICE $ /xms,
    'warn'    => qr/ ^ WARN $ /xms,
    'error'   => qr/ ^ ERROR $ /xms,
    'fatal'   => qr/ ^ FATAL $ /xms,
    'always'  => qr/ ^ ALWAYS $ /xms,
    'call+'   => qr/ ^ CALL   | DEBUG  | INFO   | NOTICE | WARN  | ERROR | FATAL | ALWAYS $ /xms,
    'debug+'  => qr/ ^ DEBUG  | INFO   | NOTICE | WARN   | ERROR | FATAL | ALWAYS $ /xms,
    'info+'   => qr/ ^ INFO   | NOTICE | WARN   | ERROR  | FATAL | ALWAYS $ /xms,
    'notice+' => qr/ ^ NOTICE | WARN   | ERROR  | FATAL  | ALWAYS $ /xms,
    'warn+'   => qr/ ^ WARN   | ERROR  | FATAL  | ALWAYS $ /xms,
    'error+'  => qr/ ^ ERROR  | FATAL  | ALWAYS $ /xms,
    'fatal+'  => qr/ ^ FATAL  | ALWAYS $ /xms,
    'always+' => qr/ ^ ALWAYS $ /xms,
);

my $kernel_trace_records_file = '/sys/kernel/debug/mero/trace/records';
my $kernel_trace_buffer_file  = '/sys/kernel/debug/mero/trace/buffer';
my $kernel_module_core_file   = '/sys/kernel/debug/mero/core';

sub validate_trace_record
{
    my $tr = shift;

    my @required_fields = qw(
        record_num timestamp pid stack_addr subsystem level func file line msg
    );

    for my $field (@required_fields) {
        die "Incorrect format of input data: trace record doesn't have required"
            . " field '$field' or it's empty\n"
            if !exists $tr->{$field} || !defined $tr->{$field};
    }
}

sub validate_format
{
    my $format = shift;

    my @allowed_format_values = qw( short med full custom:<string> );

    die "Incorrect value '$cli_option{format}' of configuration option"
        . " -f|--format, allowed values are: @allowed_format_values\n"
        if $format !~ / (?: ^ short | med | full $ ) | ^custom: /xms;
}

sub validate_level
{
    my $level  = shift;

    my @allowed_levels = qw( call debug info notice warn error fatal always );
    my $level_token = join '|', @allowed_levels;

    $level_token = qr/ \b (?: $level_token ) \b \+? /ixms;

    die "Invalid value of -L|--level option: '$level', it should be in form"
        . " of 'level[+][,level[+]]', where 'level' is one of: @allowed_levels\n"
        if $level !~ / ^ $level_token (?: ,$level_token )* $ /xms;
}

sub validate_subsys
{
    my $subsys  = shift;

    my @allowed_subsys = sort qw(
        addb       balloc     cm      cob   conf  fop
        formation  ioservice  layout  lnet  m0d   m0t1fs
        memory     mgmt       net     pool  rm    rpc
        sns        snscm      stob    adstob      extmap
        all
    );
    my $subsys_token = join '|', @allowed_subsys;

    $subsys_token = qr/ \b (?: $subsys_token ) \b /ixms;

    die "Invalid value of -s|--subsys option: '$subsys', it should be in form"
        . " of '[!]subsys[,subsys]', where 'subsys' is one of: @allowed_subsys\n"
        if $subsys !~ / ^ !? $subsys_token (?: ,$subsys_token )* $ /xms;
}

sub match_level
{
    my $tr = shift;

    if ( !exists $level{ lc $tr->{level} } ) {
        warn "Invalid trace record level '$tr->{level}', record skipped\n";
        return 0;
    }

    return any { $tr->{level} =~ / $level{$_} /ixms }
               split( /,/, $cli_option{level} );
}

sub is_error_level
{
    my $tr = shift;
    my $err_lvl = shift;

    return $tr->{level} =~ / $level{$err_lvl} /ixms;
}

sub match_subsys
{
    my $tr = shift;

    if ( $cli_option{subsys} =~ / ^! /xms ) {
        return none { uc $tr->{subsystem} eq uc $_ }
                    split( /,/, substr($cli_option{subsys}, 1) );
    } else {
        return lc $cli_option{subsys} eq 'all'
               || any { uc $tr->{subsystem} eq uc $_ }
                      split( /,/, $cli_option{subsys} );
    }
}

sub match_file
{
    my $tr = shift;

    return 1
        if !defined $cli_option{file};

    return $tr->{file} =~ /$cli_option{file}/ms;
}

sub match_func
{
    my $tr = shift;

    return 1
        if !defined $cli_option{func};

    return $tr->{func} =~ /$cli_option{func}/ms;
}

sub match_msg
{
    my $tr = shift;

    return 1
        if !defined $cli_option{msg};

    my $highlighted_msg = ( $tr->{msg}
        =~ s/($cli_option{msg})/color('red') . $1 . color('bright_white')/grems );

    return $tr->{msg} =~ /$cli_option{msg}/ms && ($tr->{msg} = $highlighted_msg);
}

sub level_color
{
    my $tr = shift;

    my $level = $tr->{level};
    my %level_color;

    %level_color = (
        CALL    => 'white',
        DEBUG   => 'cyan',
        INFO    => 'green',
        NOTICE  => 'bold blue',
        WARN    => $Term::ANSIColor::VERSION < 3.00 ? 'bold yellow' : 'bright_yellow',
        ERROR   => $Term::ANSIColor::VERSION < 3.00 ? 'red'         : 'bright_red',
        FATAL   => 'bold red',
        ALWAYS  => 'magenta',
    );

    die "Invalid value '$level' of trace record field 'level'\n"
        if !exists $level_color{$level};

    return $level_color{$level};
}

my @color_map = qw(
    red         green        yellow        blue        magenta        cyan white
    bright_red  bright_green bright_yellow bright_blue bright_magenta
    bright_cyan bright_white
);


sub time_of
{
    my $tr = shift;

    state %color;
    state $next_color = 2;

    # TODO: currently, libmero stores time as rdtsc(), consider changing to
    # something meaning, like epoch or other with more precision
    #my $dt   = DateTime->from_epoch( epoch => $tr->{timestamp} );
    #my $time = $dt->month_abbr . '-' . $dt->day . ' ' . $dt->hms . '.'
               #. $dt->nanosecond . ' ';
    #return $time;

    my $rdtsc = $tr->{timestamp};
    if (defined $ENV{ANSI_COLORS_DISABLED} and $ENV{ANSI_COLORS_DISABLED} == 1) {
        $rdtsc = substr($rdtsc, 0, (length $rdtsc) - 9) . '.'
                 . substr($rdtsc, -9, 3) . '.' . substr($rdtsc, -6);
    }
    else {
        my $base = substr($rdtsc, -9, 3);
        if (not exists $color{$base}) {
            $color{$base} = $next_color++;
            if ($next_color > $#color_map) {
                $next_color = 0;
            }
        }
        $rdtsc = substr($rdtsc, 0, (length $rdtsc) - 9) . '.'
                 . color( $color_map[ $color{$base} ] ) . $base
                 . color( level_color($tr) ) . '.' . substr($rdtsc, -6);
    }

    return $rdtsc;
}

my $format_placeholder = qr/
                             %[
                                n # \n
                                t # \t
                                N # record_Num
                                T # Timestamp
                                p # pid
                                a # stack_Addr
                                s # Subsystem
                                l # Level
                                f # Func
                                F # File
                                L # Line
                                m # Msg
                              ]
                           /xms;

sub expand_format_placeholder
{
    my $placeholder = shift;
    my $tr          = shift;

    die "Invalid format placeholder '$placeholder' for custom format option\n"
        if $placeholder !~ m/^$format_placeholder$/xms;

    given ($placeholder) {
        when ('%n') {
            return "\n";
        }
        when ('%t') {
            return "\t";
        }
        when ('%N') {
            return "$tr->{record_num}";
        }
        when ('%T') {
            return time_of($tr);
        }
        when ('%p') {
            return "$tr->{pid}";
        }
        when ('%a') {
            return "$tr->{stack_addr}";
        }
        when ('%s') {
            return "$tr->{subsystem}";
        }
        when ('%l') {
            return "$tr->{level}";
        }
        when ('%f') {
            return "$tr->{func}";
        }
        when ('%F') {
            return file_of($tr);
        }
        when ('%L') {
            return "$tr->{line}";
        }
        when ('%m') {
            return "$tr->{msg}";
        }
    };

    return;
}

sub stack_addr_of
{
    my $trace_record = shift;

    state %color;
    state $next_color = 0;

    if (defined $ENV{ANSI_COLORS_DISABLED} and $ENV{ANSI_COLORS_DISABLED} == 1) {
        return $trace_record->{stack_addr};
    }
    else {
        my $addr = substr $trace_record->{stack_addr}, -$cli_option{stackaddr_width};
        my ($base, $offset) = ( substr($addr, 0, $cli_option{stackaddr_hl})
                                , substr($addr, $cli_option{stackaddr_hl}) );

        if (! exists $color{$base}) {
            $color{$base} = $next_color++;
            if ($next_color > $#color_map) {
                $next_color = 0;
            }
        }

        return color( $color_map[$color{$base}] ) . $base
               . color( level_color($trace_record) ) . $offset;
    }
}

sub file_of
{
    my $trace_record = shift;

    my ($relpath) = $trace_record->{file}
        =~ m#^.*/?mero(?:-(?:\d|\w)(?:\.(?:\d|\w)){2,5})?/(.*)#xms;
    $relpath = defined $relpath ? $relpath : $trace_record->{file};
    return $cli_option{relpath} ? $relpath : $trace_record->{file};
}

sub file_line_func_of
{
    my $trace_record = shift;

    my $flf = file_of($trace_record) . ':' . $trace_record->{line} . ':'
              . $trace_record->{func};
    return $flf . ' ' x ($cli_option{column_width} - length $flf)
}

sub func_of
{
    my $trace_record = shift;

    return $trace_record->{func} . ' ' x (30 - length $trace_record->{func})
}

sub print_trace_record
{
    my $output_file = shift;
    my $tr          = shift;

    my $buf;

    given ($cli_option{format}) {

        when ('short') {
            $buf = color( level_color($tr) )
                   . sprintf('%6s  ',       $tr->{level})
                   . "[" . file_of($tr) . ":$tr->{line}:$tr->{func}]  "
                   . "$tr->{msg}"
                   . color('reset')
                   . "\n";
        }

        when ('med') {
            $buf = color( level_color($tr) )
                   . sprintf('%-4u  ',  $tr->{record_num})
                   . sprintf('%-8s  ',  time_of($tr))
                   . sprintf('%s  ',    stack_addr_of($tr))
                   . sprintf('%-6s  ',  $tr->{level})
                   . sprintf('%s  ',    file_line_func_of($tr))
                   . color('bright_white') . "$tr->{msg}"
                   . color('reset')
                   . "\n";
        }

        when ('full') {
            $buf = color( level_color($tr) )
                   . sprintf('%-7u  ',  $tr->{record_num})
                   . sprintf('%-18s  ', time_of($tr))
                   . sprintf('%-6s  ',  $tr->{level})
                   . sprintf('%-10s  ', $tr->{subsystem})
                   . sprintf('%-6s  ',  $tr->{pid})
                   . "$tr->{stack_addr}  "
                   . "$tr->{func}  "
                   . file_of($tr) . ":$tr->{line}"
                   . color('reset')
                   . "\n"
                   . color( level_color($tr) )
                   . "    $tr->{msg}"
                   . color('reset')
                   . "\n\n";
        }

        when (/^custom:/xms) {
            my ($format) = $cli_option{format} =~ m/^custom:(.*)$/xms;

            $format =~ s/
                          ($format_placeholder)
                        /
                          expand_format_placeholder($1, $tr)
                        /egxms;

            $buf = color( level_color($tr) ) . $format . color('reset') . "\n";
        }

        default {
            my @allowed_format_values = qw( short med full custom:<string> );
            die "Incorrect value '$cli_option{format}' of configuration option"
                . " -f|--format, allowed values are: @allowed_format_values\n";
        }
    }

    $output_file->print($buf);
}

sub locate_m0_binary
{
    my $binary_name       = shift;
    my $skip_if_not_found = shift;

    my $binary_path;
    my (undef, undef, $basename) = File::Spec->splitpath( $PROGRAM_NAME );

    # check whether we are running from source tree
    if ( $PROGRAM_NAME =~ m#
                             (?: utils/(?:trace/)? | ^./(?:trace/)? )
                             $basename $
                           #xms )
    {
        ($binary_path = $PROGRAM_NAME) =~ s# $basename $ #$binary_name#xms;

        if ( ! -x $binary_path ) {
            $binary_path =~ s# /trace(?=/) ##xms;

            if ( ! -x $binary_path ) {
                $binary_path = which($binary_name);
            }
        }
    }
    else
    {
        $binary_path = which($binary_name);
    }

    if ( $cli_option{use_usrbin_binary} ) {
        $binary_path = "/usr/bin/$binary_name";
    }

    return $binary_name
        if (!defined $binary_path or ! -x $binary_path)
            and defined $skip_if_not_found;

    die "Failed to find '$binary_name' utility in PATH or in the development"
        . " tree next to ourselves\n"
        if !defined $binary_path;

    die "Can't use $binary_path: no such file or it's not an executable\n"
        if ! -x $binary_path;

    return $binary_path;
}

sub create_tempfile_for
{
    my $file_name = shift;
    my $suffix    = shift // '.yml';

    my (undef, undef, $basename)
        = File::Spec->splitpath( $file_name );

    my $temp_file = File::Temp->new(TEMPLATE => 'm0trace-' . $basename . '-XXXXX',
                                    SUFFIX   => $suffix,
                                    UNLINK   => 1);

    return $temp_file;
}

sub prepare_input_file
{
    my $input_file;

    if ( $cli_option{input_file} eq '-' # assume that STDIN is always ASCII
         or $cli_option{input_file} =~ m/ \. (?: yml | yaml | log ) $ /xms
         or $cli_option{input_file} eq $kernel_trace_records_file
         or -T $cli_option{input_file} )
    {
        $input_file = "<$cli_option{input_file}";
    }
    elsif ( $cli_option{input_file} # compressed log files files like *.yml.gz
                =~ m/ \. (?: yml | yaml | log ) \. (?<ztype> gz | bz2 ) $ /xms )
    {
        given ( $+{ztype} ) {
            when ('gz') {
                $input_file = "gunzip -c $cli_option{input_file} |";
            }
            when ('bz2') {
                $input_file = "bunzip2 -c $cli_option{input_file} |";
            }
        }
    }
    else # input file is in binary format
    {
        # if it's a kerner crash dump it requires preprocessing by C<m0kdump2trace>
        if ($cli_option{kdump}) {
            my $m0kdump2trace = locate_m0_binary('m0kdump2trace');

            my $module_img = create_tempfile_for( $cli_option{input_file}, '.modcore' );
            system "$m0kdump2trace -f -m $cli_option{input_file} $module_img";

            my $trace_buf = create_tempfile_for( $cli_option{input_file}, '.tracebuf' );
            system "$m0kdump2trace -f $cli_option{input_file} $trace_buf";

            $cli_option{input_file}   = $trace_buf;
            $cli_option{module_image} = $module_img;
        }

        my $m0ut        = locate_m0_binary('m0ut', 'skip-if-not-found');
        my $m0traced    = locate_m0_binary('m0traced');
        my $m0tracedump = locate_m0_binary('m0tracedump');
        my $dump_opt    = defined $cli_option{module_image}
                              ? "-k $cli_option{module_image}" : '';

        if ($cli_option{dump_header}) {
            $input_file = "$m0tracedump -H -i $cli_option{input_file} |";
        }
        elsif ($cli_option{follow}) {
            $cli_option{use_pager}    = 0;
            $cli_option{flush_output} = 1;
            $input_file = "$m0traced -p -S -i $cli_option{input_file} "
                          . "| $m0tracedump -s $dump_opt |";
        }
        elsif ($cli_option{stream_mode}) {
            $input_file = $cli_option{input_file} =~ m#m0ut/m0trace#xms ?
                              "$m0ut -T < $cli_option{input_file} |"
                            : "$m0tracedump -s $dump_opt -i $cli_option{input_file} |";
        }
        else {
            my $temp_file = create_tempfile_for( $cli_option{input_file} );

            system "$m0tracedump -S $dump_opt -i $cli_option{input_file} -o $temp_file";
            $input_file = $temp_file;
        }
    }

    return $input_file;
}


sub usage
{
    pod2usage(-verbose => 0);
}

sub help
{
    pod2usage(-verbose => 1);
}

sub man
{
    pod2usage(-verbose => 2);
}

sub process_cli_options
{
    usage() if !GetOptions(
        'i|input=s'            =>  \$cli_option{input_file},
        'o|output=s'           =>  \$cli_option{output_file},
        'S|stream-mode!'       =>  \$cli_option{stream_mode},
        'Y|yaml-output'        =>  \$cli_option{yaml_output},
        'pager!'               =>  \$cli_option{use_pager},
        'flush-output'         =>  \$cli_option{flush_output},
        'color=s'              =>  \$cli_option{color},
        'c'                    =>  sub { $cli_option{color} = 'always' },
        'C'                    =>  sub { $cli_option{color} = 'never' },
        'd'                    =>  \$cli_option{use_usrbin_binary},
        'k|kdump'              =>  \$cli_option{kdump},
        'I|module-image=s'     =>  \$cli_option{module_image},
        'L|log-dir'            =>  \$cli_option{log_dir},
        'H|dump-header'        =>  sub { $cli_option{dump_header} = 1; $cli_option{use_pager} = 0 },
        'F|follow'             =>  sub { $cli_option{follow} = $cli_option{stream_mode} = 1 },
        'M|match-only'         =>  \$cli_option{match_only},
        'r|relpath!'           =>  \$cli_option{relpath},
        'w|column-width=i'     =>  \$cli_option{column_width},
        'a|stackaddr-width=i'  =>  \$cli_option{stackaddr_width},
        'A|stackaddr-hl=i'     =>  \$cli_option{stackaddr_hl},
        'f|format=s'           =>  \$cli_option{format},
        'l|level=s'            =>  \$cli_option{level},
        's|subsys=s'           =>  \$cli_option{subsys},
        'e|file=s'             =>  \$cli_option{file},
        'u|func=s'             =>  \$cli_option{func},
        'm|msg=s'              =>  \$cli_option{msg},

        'h|help'    =>  \&help,
        'usage'     =>  \&usage,
        'man'       =>  \&man
    );

    if ($cli_option{color} eq 'auto'
        and ($cli_option{output_file} ne '-' or ! -t STDOUT)
        or $cli_option{color} eq 'never')
    {
        $ENV{ANSI_COLORS_DISABLED} = 1;
    }

    die "Option '-A|--stackaddr-hl' value ($cli_option{stackaddr_hl})"
        . " can't be greater than value of '-a|--stackaddr-width' option"
        . " ($cli_option{stackaddr_width})\n"
        if ($cli_option{stackaddr_hl} > $cli_option{stackaddr_width});

    validate_format( $cli_option{format} );
    validate_level( $cli_option{level} );
    validate_subsys( $cli_option{subsys} );

    # handle arguments
    if (defined $ARGV[0] and $cli_option{input_file} eq '-') {
        my $file_pattern;

        die "Error: -F|--follow option is allowed only for '*-buf' targets\n"
            if $cli_option{follow} && $ARGV[0] !~ m/-buf$/xms;

        given ($ARGV[0]) {
            when ('kernel') {
                $file_pattern = "trace-m0mero~*.bin";
            }
            when ('kernel-buf') {
                my $module_img = create_tempfile_for('m0mero.ko', '.img');
                copy($kernel_module_core_file, $module_img);

                $cli_option{module_image} = $module_img;
                $cli_option{input_file}   = $kernel_trace_buffer_file;

                return;
            }
            when ('kernel-live') {
                $cli_option{input_file}   = $kernel_trace_records_file;
                $cli_option{use_pager}    = 0;
                $cli_option{flush_output} = 1;
                return;
            }
            when (/^(?:confd|ha|(?:mds|ios)\d*)$/)   {
                $file_pattern = "trace-m0d-$ARGV[0]-*.bin";
            }
            when (/^m0d-.*$/)   {
                $file_pattern = "trace-$ARGV[0]-*.bin";
            }
            when (/^(?:confd|ha|(?:rms|mds|ios)\d*)-buf$/) {
                $file_pattern = "m0trace.*";
                $ARGV[0] =~ m/^(?<sname>.*)-buf$/xms;
                $cli_option{log_dir} = "$cli_option{mero_dir}/$+{sname}";
            }
            when ('ut') {
                $file_pattern = "m0trace.*";
                $cli_option{log_dir} = '/var/mero/m0ut';
            }
            default {
                die "Unknown type of requested trace log: '$ARGV[0]',"
                    . " supported values should match pattern:"
                    . " '<kernel|confd|ha|rms*|mds*|ios*|m0d-*>[-buf]',"
                    . " for example 'confd', 'mds-buf', 'ios2', 'ios2-buf'\n";
            }
        }

        $cli_option{input_file}
            = qx(bash -c 'ls -1t $cli_option{log_dir}/$file_pattern 2>/dev/null | head -n1');

        die "No trace logs found for '$ARGV[0]' in $cli_option{log_dir}\n"
            if !$cli_option{input_file};

        chomp $cli_option{input_file};
    }

    return;
}

sub main
{
    process_cli_options();

    my $input_file = prepare_input_file();

    my @trace_records;

    if ( $cli_option{stream_mode} ) {
        tie @trace_records, 'Tie::Array::Lazy::YAMLstream', $input_file;
    }
    elsif ( !$cli_option{dump_header} ) {
        my $yaml_data = YAML::XS::LoadFile( $input_file );

        die "Incorrect format of input data: root entry 'trace_records' not found\n"
            if !exists $yaml_data->{trace_records};

        die "No trace records available\n"
            if !defined $yaml_data->{trace_records};

        @trace_records = @{ $yaml_data->{trace_records} }
    }

    my $output_fh;

    if ($cli_option{output_file} eq '-' and $cli_option{use_pager}) {
        open $output_fh, "| less -RSM";
    }
    else {
        open $output_fh, ">$cli_option{output_file}";
    }

    if ($cli_option{flush_output}) {
        $output_fh->autoflush(1);
    }

    if ($cli_option{yaml_output}
        or $cli_option{dump_header} and !$cli_option{stream_mode})
    {
        open my $input_fh, "$input_file";
        copy($input_fh, $output_fh);
        close $input_fh;
    }
    elsif ($cli_option{dump_header}) {
        print {$output_fh} YAML::XS::Dump( $trace_records[0]->{header} );
    }
    else {
        READ_RECORDS:
        for my $tr (@trace_records) {
            last READ_RECORDS
                if !defined $tr;

            validate_trace_record($tr);

            # dereference msg's value if it's formatted as a "!str |" YAML tag
            if (ref $tr->{msg}) {
                $tr->{msg} = ${ $tr->{msg} };
                chomp $tr->{msg};
            }

            if ((match_level($tr) and match_subsys($tr) and match_file($tr)
                 and match_func($tr) and match_msg($tr))
                or (!defined($cli_option{match_only}) and is_error_level($tr, 'warn+')))
            {
                print_trace_record($output_fh, $tr);
            }
        }
    }

    close $output_fh;

    return;
}

main();


__END__

=head1 NAME

m0trace - display Mero trace logs in human friendly form

=head1 SYNOPSIS

m0trace  kernel[-buf] | confd[-buf] | iosX[-buf] | mdsX[-buf]

m0trace  [-i|--input <ifile>] [-o|--output <ofile>]
         [-S|--stream-mode] [-Y|--yaml-output] [--no-pager] [--no-relpath]
         [-w|--column-width <num>] [-c|-C|--color=MODE] [-d] [-k|--kdump]
         [--flush-output] [-I|--module-image=<FILE>] [-L|--log-dir=DIR]
         [-H|--dump-header] [-F|--follow] [-M|--match-only] [-f|--format=FMT]
         [-a|--stackaddr-width] [-A|--stackaddr-hl] [-l|--level=LVL]
         [-s|--subsys=SBS] [-e|--file=FL] [-u|--func=FUN] [-m|--msg=MSG]
         [-h|--help] [--usage] [--man]

=head1 DESCRIPTION

This program displays Mero trace log in human friendly form, allowing to
filter log entries by various parameters, like log level, subsystem, file,
func name, etc.

It accepts trace log data on STDIN or from file, in binary or in YAML format,
see B<-i|--input> option.

=head1 ARGUMENTS

A mero service name can be provided as an optional argument, like I<kernel>,
I<confd>, I<ha>, I<mds> or I<ios>. If specified, C<m0trace> will automatically
pick a latest trace file for that service. Additionally to that, a service name
can be followed by C<-buf> suffix, in that case C<m0trace> will use the
I<mmaped> trace buffer of C<m0d> process directly.

=head1 OPTIONS

=over 8

=item B<-i|--input=I<ifile>>

Input file name, if omitted then STDIN is used by default. If input comes from
STDIN or input file has *.yml *.yaml or *.log extension, then it's assumed to be
a text file in YAML format (it's possible to use compressed logs if filename has
*.yml.gz or *.yml.bz2 extension). Otherwise it's assumed to be a raw binary
trace data and in this case it will be converted into YAML format first, with
the help of B<m0tracedump> utility, which creates a temporary file in the
current directory.  Temporary file is not used if m0trace operates in "stream
mode"(see B<-s|--stream-mode> option below).

=item B<-o|--output=I<ofile>>

Output file name, if omitted then STDOUT is used by default.

=item B<-S|--stream-mode>

By default, B<m0trace> expects that YAML log contains all trace records
formatted as a single YAML document, which requires to read a whole YAML log,
before it can be processed (displayed, filtered, etc.). With this option,
B<m0trace> expects that each trace record in log file is represented as a
separate YAML document, which allows to read each trace record from log file one
by one and display/filter them immediately. This is handy when reading trace log
from STDIN and not from file.

This option implies that YAML trace log was produces by B<m0tracedump> with
B<-s> option.

=item B<-Y|--yaml-output>

Don't perform any parsing of input stream, simply redirect it into output. As
input is always in YAML format, this produces a raw YAML output as well.

=item B<--no-pager>

Don't use pager (less) to display results.

=item B<--flush-output>

Flush output file after writing each trace record.

=item B<--no-relpath>

Use full path when displaying name of a source file to which a trace record
belongs.

=item B<-w|--column-width <num>>

Set column width for columns which support it (so far there is only one -
file/line/func from 'med' format). Use C<-w0> for minimal width. By default it's
set to 30.

=item B<--color=I<MODE>|-c|-C>

Controls, whether to colorize output, depending on trace level of each record.
MODE can be:

=over 4

=item *
I<auto> - detect type of output file (terminal, file, or pipe) and use colors if
output goes to a terminal, this is a default;

=item *
I<always> - always use colors no matter what is the type of output file;

=item *
I<never> - never use colors.

=back

=item B<-d>

Use hard-coded '/usr/bin' path for m0tracedump (it can be handy when there are
two versions of m0tracedump in the PATH - one from rpm and one from workdir).

=item B<-L|--log-dir=I<DIR>>

Path to a directory where to look for trace files, by default is '/var/log/mero'.

=item B<-k|--kdump>

Indicates that input file is a kernel crash dump, produced by C<kdump> service.

=item B<-I|--module-image=I<FILE>>

Core image of m0mero.ko module, required to analize kernel space trace logs.

=item B<-H|--dump-header>

Only print trace file header and exit. Option --no-pager is ignored.

=item B<-F|--follow>

Monitor trace file and print trace records as soon as they appear in the file.
Starts at a current position in the trace buffer. Implies B<-S|--stream-mode>.

=item B<-M|--match-only>

By default, trace records with level I<warn+> are always printed disregarding
whether they match filters (like B<--file>, B<--func>, B<--msg>, etc.) or not.
With this option, only matched trace records are printed, no matter which level
they have.

=item B<-f|--format=I<FMT>>

Controls amount of information, which is displayed for each trace record, and
how it looks. Possible values for FMT are: I<short>, I<med> (default one),
I<full> and I<custom:STR>. I<custom> format is special, it accepts a format
string, which goes after a colon, and it may have the following placeholders:

=over 4

=item *
%n:  newline

=item *
%t:  horizontal tab

=item *
%N:  record_Num

=item *
%T:  Timestamp

=item *
%p:  pid

=item *
%a:  stack_Addr

=item *
%s:  Subsystem

=item *
%l:  Level

=item *
%f:  Func

=item *
%F:  File

=item *
%L:  Line

=item *
%m:  Msg

=back

Example:

  m0trace --format=med
  m0trace --format='custom:Num[%N] Stack[%a]: %t%m'

=item B<-a|--stackaddr-width>

Width of stack-address column.

=item B<-A|--stackaddr-hl>

Number of color-highlight positions in stack adress.

=item B<-l|--level=I<LVL>>

Display only trace records with specified log level. LVL is a coma separated
list of log levels, where each level can be one of:

=over 4

=item *
I<fatal>

=item *
I<error>

=item *
I<warn>

=item *
I<notice>

=item *
I<info>

=item *
I<debug>

=item *
I<call>

=back

A special log levels with '+' at the end of level name can be used. They mean
"all levels from current and above". For example, I<warn+> means display I<warn>
I<error> and I<fatal> levels. A default one is I<call+>, which means display
trace records from all levels.

Example:

  m0trace --format=call,error+

=item B<-s|--subsys=I<SBS>>

Display only trace records from specified Mero subsystem. SBS is a coma
separated list of subsystem names. If SBS starts with I<!> it means reverse -
display all subsystems except specified. A special subsystem I<all> means
display all subsystems (this is a default).

=item B<-e|--file=I<FL>>

Display only trace records from specified source file. FL is a perl regex.

Example:

  m0trace -F 'init\.c'
  m0trace -F '^fop/|^fom/'

=item B<-u|--func=I<FUN>>

Display only trace records from specified function. FUN is a perl regex.

Example:

  m0trace -U '^m0_alloc$'
  m0trace -U '(?<!m0_)(?:alloc|free)'

=item B<-m|--msg=I<MSG>>

Display only trace records, which have specified message. MSG is a perl regex.

Example:

  m0trace -M 'Sesstion created'
  m0trace -M 'slot \x+ nr_items [1-3]'

=item B<-h|--help>

Print this help summary.

=item B<--usage>

Print usage line of this summary.

=item B<--man>

Print the complete manpage.

=back

=cut
