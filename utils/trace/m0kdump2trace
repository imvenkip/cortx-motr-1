#!/usr/bin/env bash

# This script extracts trace buffer of Mero kernel module from linux kernel
# crash dump (vmcore), produced by kdump service. Essentially, it's a wrapper
# around `crash` utility.


#
# Global vars
#

# constants
readonly PROG_NAME=$(basename $0)
readonly THIS_SCRIPT=$(readlink -f $0)
readonly stdin='/dev/fd/0'
readonly stdout='/dev/fd/1'
readonly vmlinux="/usr/lib/debug/lib/modules/$(uname -r)/vmlinux"

# variables
verbose=false
force=false
module_img=false
cli_args=
infile=$stdin
outfile=$stdout


#
# Usage
#

help()
{
    [[ $1 == stdout ]] && usage || usage >&2
    exit 1
}

usage()
{
    cat <<USAGE_END
Usage: $PROG_NAME [-h|--help] [-v|--verbose] [-f|--force] [-m|--module-image]
                  [vmcore] [trace_buffer|module_image]

  Arguments are optional. If not specified, STDIN and STDOUT are used by default.

    vmcore          Kernel crash dump image, generated by kdump.

    trace_buffer    Output file, where binary Mero trace buffer is stored.
    module_image    If '-m|--module-image' is used, then instead of a trace
                    buffer, a m0mero.ko module image is extracted.

  OPTIONS:

    -f|--force      Don't ask to overwrite if output file <trace_buffer> already
                    exists.

    -m|--module-image

                    Extract m0mero.ko module image instead of a trace buffer.
                    This image is required on the next step by m0tracedump to
                    decode trace buffer.

    -v|--verbose    Print what's going on to STDERR.

    -h|--help       Print this help screen.
USAGE_END
}


#
# Parse CLI options
#

parse_cli_options()
{
    # Note that we use `"$@"' to let each command-line parameter expand to a
    # separate word. The quotes around `$@' are essential!
    # We need TEMP as the `eval set --' would nuke the return value of getopt.
    TEMP=$( getopt --options hvfm \
                   --longoptions help,verbose,force,module-image \
                   --name "$PROG_NAME" -- "$@" )

    [[ $? -ne 0 ]] && help

    # Note the quotes around `$TEMP': they are essential!
    eval set -- "$TEMP"

    while true ; do
        case "$1" in
            -h|--help)          help stdout ;;
            -v|--verbose)       verbose=true; shift ;;
            -f|--force)         force=true; shift ;;
            -m|--module-image)  module_img=true; shift ;;
            --)                 shift; break ;;
            *)                  echo 'getopt: internal error...'; exit 1 ;;
        esac
    done

    # remaining command line arguments
    cli_args="$@"
}


#
# Utility functions
#

echo_err()
{
    echo -e "$*" >&2
}

die()
{
    echo_err "$PROG_NAME:  ERROR:  $*"
    exit 1
}

log()
{
    ! $verbose || echo_err "$PROG_NAME: $@"
}

run_crash_cmd()
{
    local cmd=$1

    local cmd_file=$(mktemp $PROG_NAME.XXXX.cmd)
    local result=

    echo "$cmd" > $cmd_file

    result=$(echo -e "exit\n" | crash -s -i $cmd_file $vmlinux $infile)
    rm $cmd_file
    echo "$result"
}

m0tracedump()
{
    local trace_dump=

    case $THIS_SCRIPT in
        /usr/bin/*)      trace_dump=/usr/bin/m0tracedump ;;
        */mero/utils/*)  trace_dump="$(dirname $THIS_SCRIPT)/m0tracedump" ;;
        *)               die "m0tracedump cannot be found in the PATH" ;;
    esac

    $trace_dump "$@"
}

crash_log=
get_value_from_crash_log()
{
    local log_entry=$1

    if [[ -z $crash_log ]] ; then
        crash_log=$(run_crash_cmd 'log')
    fi

    local value=$(echo "$crash_log" |
                 perl -e "while (<>) {
                            /mero: $log_entry: ((?:0x)?[0-9a-fA-F]+)/;
                            \$value = \$1 if \$1;
                          }
                          END{ print \$value; }")
    echo "$value"
}

#
# Main
#

# exit immediately if one the commands exits with a non-zero status
set -e

parse_cli_options "$@"
eval set -- "$cli_args"

#
# sanity checks

[[ -e $vmlinux ]] ||
    die "$vmlinux file doesn't exist, please install 'kernel-debug' package!"

[[ -z $1 ]] || infile=$1
[[ -z $2 ]] || outfile=$2

if (! $force) && [[ $outfile != $stdout && -e $outfile ]] ; then
    echo -n 'Warning, '$outfile' already exists, overwrite? [y/N] '
    read answer
    [[ $answer =~ [yY] ]] || exit 0
fi

if $module_img ; then
    #
    # dump m0mero.ko image

    log 'finding memory location of m0mero.ko core image..'
    m0mero_core_addr=$(get_value_from_crash_log 'module core address')
    m0mero_core_size=$(get_value_from_crash_log 'module core size')
    log "m0mero.ko core address: $m0mero_core_addr"
    log "m0mero.ko core size: $m0mero_core_size"

    log 'dumping m0mero.ko core image..'
    m0mero_core_end_addr=$(printf 0x%x $(($m0mero_core_addr + $m0mero_core_size)))
    run_crash_cmd "dump binary memory $outfile $m0mero_core_addr $m0mero_core_end_addr" > /dev/null
    log 'done'
else
    #
    # dump trace buffer

    log 'finding memory location of a trace header...'
    trace_hdr_addr=$(get_value_from_crash_log 'trace header address')
    log "trace header address: $trace_hdr_addr"

    log 'dumping trace header..'
    trace_hdr_end_addr=$(printf 0x%x $(($trace_hdr_addr + 4 * 1024)))
    trace_header=$(mktemp $PROG_NAME.XXXX.hdr)
    trap "rm $trace_header" EXIT
    run_crash_cmd "dump binary memory $trace_header $trace_hdr_addr $trace_hdr_end_addr" > /dev/null

    log 'getting actual size of header and buffer..'
    hdr_size=$(m0tracedump -H -i $trace_header |
               perl -ne 'print $1 if /header_size:\s+(\d+)/' )
    buf_size=$(m0tracedump -H -i $trace_header |
               perl -ne 'print $1 if /buffer_size:\s+(\d+)/' )
    log "trace header size: $hdr_size"
    log "trace buffer size: $buf_size"

    log 'dumping trace buffer..'
    trace_buf_end_addr=$(printf 0x%x $(($trace_hdr_addr + $hdr_size + $buf_size)))
    run_crash_cmd "dump binary memory $outfile $trace_hdr_addr $trace_buf_end_addr" > /dev/null
    log 'done'
fi
