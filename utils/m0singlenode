#!/usr/bin/env bash

### set up a working environment and control mero-singlenode services

#
# Global vars
#

# constants
readonly PROG_NAME=$(basename $0)
readonly self=$(readlink -f $0)
readonly base_dir=$(dirname $self)
readonly singlenonde_services='
    mero-kernel
    mero-server-ha
    mero-server-confd
    mero-server@mds
    mero-server@ios1
    mero-server@cas1
    mero
    mero-client
    mero-singlenode
'

# variables
verbose=false
cli_args=

# colors
RED=$(tput setaf 1)
GREEN=$(tput setaf 2)
NC=$(tput sgr0)

#
# Usage
#

help()
{
    [[ $1 == stdout ]] && usage || usage >&2
    exit 1
}

usage()
{
    cat <<USAGE_END
Usage: $PROG_NAME [options] <action>

  Where <action> is one of:

    activate    - Activate mero-singlenode services, as initially they are
                  masked. This needs to be done once, after mero.rpm installation
                  or upgrade.

    enable      - Enable mero-singlenode services to be loaded on system startup.

    disable     - Disable mero-singlenode services from being loaded on system
                  startup.

    start       - Start mero-singlenode services.
    stop        - Stop mero-singlenode services.
    restart     - Re-start mero-singlenode services.
    status      - Show present status of mero-singlenode services.

  Options are:

    -v|--verbose            Enable verbose output.

    -h|--help               Print this help screen.
USAGE_END
}

#
# Parse CLI options
#

parse_cli_options()
{
    # Note that we use `"$@"' to let each command-line parameter expand to a
    # separate word. The quotes around `$@' are essential!
    # We need TEMP as the `eval set --' would nuke the return value of getopt.
    TEMP=$( getopt --options hv \
                   --longoptions help,verbose \
                   --name "$PROG_NAME" -- "$@" )

    [[ $? -ne 0 ]] && help

    # Note the quotes around `$TEMP': they are essential!
    eval set -- "$TEMP"

    while true ; do
        case "$1" in
            -h|--help)          help stdout ;;
            -v)                 verbose=true;         shift   ;;
            --)                 shift; break ;;
            *)                  echo 'getopt: internal error...'; exit 1 ;;
        esac
    done

    # remaining command line arguments
    cli_args="$@"
}

#
# Utility functions
#

log()
{
    echo "--->  $*"
}

logn()
{
    echo -n "--->  $*"
}

debug()
{
    ! $verbose || echo -e "$PROG_NAME:  DEBUG:  $*"
}

warn()
{
    echo "$PROG_NAME: WARNING: $*"
}

die()
{
    echo "$PROG_NAME:  ERROR:  $*" >&2
    exit 1
}

path_of()
{
    echo "$base_dir/$1"
}

get_cursor()
{
    # based on stackoverflow.com/questions/2575037/how-to-get-the-cursor-position-in-bash
    # based on a script from invisible-island.net/xterm/xterm.faq.html

    exec < /dev/tty
    oldstty=$(stty -g)
    stty raw -echo min 0
    echo -en "\033[6n" > /dev/tty
    IFS=';' read -r -d R -a pos
    stty $oldstty
    # change from one-based to zero based so they work with: tput cup $row $col
    row=$((${pos[0]:2} - 1))    # strip off the esc-[
    col=$((${pos[1]} - 1))

    echo "$row $col"
}

get_param_of()
{
    local service=$1
    local param=$2

    systemctl show "$service" | grep -Po "(?<=^$param=).*"
}

start_singlenode()
{
    log 'Starting LNet'
    # in some situations 'lnet' service can be started but lnet modules may be
    # unloaded so systemd won't know it needs to load them them back, in such
    # condition other services that depend on lnet will fail on start; the
    # workaround is to re-load lnet modules, which is done by 'restart'
    systemctl restart lnet

    log 'Starting mero-singlenode services'
    systemctl start mero-singlenode &

    local status_col=45

    for s in $singlenonde_services ; do
        logn "  waiting for $s  "

        while ! systemctl is-failed -q $s && ! systemctl is-active -q $s ; do
            sleep 1 ; echo -n .
        done

        local cursor_pos=(0 0)
        if [[ -t 1 ]] ; then
            cursor_pos=( $(get_cursor) )
        fi
        if [[ ${cursor_pos[1]} -gt $status_col ]] ; then
            status_col=${cursor_pos[1]}
        fi
        # move cursor to status column position
        if [[ ${cursor_pos[0]} -ne 0 && -t 1 ]] ; then
            tput cup ${cursor_pos[0]} $status_col
        fi

        if systemctl is-failed -q $s ; then
            echo "  [${RED}FAILED${NC}]"
            trap "systemctl status $s" EXIT
            die  "Service '$s' failed to start."
        fi

        systemctl is-active -q $s && echo "  [  ${GREEN}OK${NC}  ]"
    done

    for i in $(jobs -p) ; do
        wait $i
    done
}

stop_singlenode()
{
    log 'Stopping mero-singlenode services'
    systemctl stop mero-singlenode &

    local status_col=57

    for s in mero-singlenode mero-client mero-server@cas1 mero-server@ios1 \
        mero-server@mds mero-server-confd mero-server-ha mero mero-kernel
    do
        logn "  waiting for $s  "

        while ! systemctl is-failed -q $s \
              && [[ ! $(systemctl is-active $s) =~ inactive|unknown ]]
        do
            sleep 1 ; echo -n .
        done

        local cursor_pos=(0 0)
        if [[ -t 1 ]] ; then
            cursor_pos=( $(get_cursor) )
        fi
        if [[ ${cursor_pos[1]} -gt $status_col ]] ; then
            status_col=${cursor_pos[1]}
        fi
        # move cursor to status column position
        if [[ -t 1 ]] ; then
            tput cup ${cursor_pos[0]} $status_col
        fi

        if systemctl is-failed -q $s ; then
            echo "  [${RED}FAILED${NC}]"
            echo '----------------------------------------------------------'
            systemctl status -o cat $s || true
            echo '----------------------------------------------------------'
        else
            ! systemctl is-active -q $s && echo "  [  ${GREEN}OK${NC}  ]"
        fi
    done

    for i in $(jobs -p) ; do
        wait $i
    done
}

singlenode_status()
{
    local color=$NC
    local atime=

    echo '### Global state --------------------------------'

    local loadstate=$(get_param_of mero-singlenode LoadState)
    case $loadstate in
        loaded) color=$GREEN ;;
        masked) color=$RED   ;;
        *)      color=$NC    ;;
    esac
    echo " State:                  $color$loadstate$NC"

    local autostart=$(get_param_of mero-singlenode UnitFileState)
    case $autostart in
        enabled)  color=$GREEN ;;
        disabled) color=$RED   ;;
        *)        color=$NC    ;;
    esac
    echo " Autostart:              $color$autostart$NC"

    local lnet=$(get_param_of lnet ActiveState)
    local lnet_nid=
    case $lnet in
        active)   color=$GREEN
                  lnet_nid=$(lctl list_nids)
                  atime=$(get_param_of lnet ActiveEnterTimestamp)
                  ;;
        failed)   color=$RED ; atime=$(get_param_of lnet InactiveEnterTimestamp) ;;
        inactive) color=$NC  ; atime= ;;
        *)        color=$NC  ; atime= ;;
    esac
    echo " LNet:                   $color$lnet$NC    $atime"
    echo ' LNet Network ID:       ' $lnet_nid

    echo
    echo '### Kernel --------------------------------------'

    local kernel=$(get_param_of mero-kernel ActiveState)
    case $kernel in
        active)   color=$GREEN ; atime=$(get_param_of mero-kernel ActiveEnterTimestamp)  ;;
        failed)   color=$RED   ; atime=$(get_param_of mero-kernel InactiveEnterTimestamp) ;;
        inactive) color=$NC    ; atime= ;;
        *)        color=$NC    ; atime= ;;
    esac
    echo " mero-kernel             $color$kernel$NC    $atime"
    lsmod | grep m0 | awk '{ print "   " $LN }'

    echo
    echo '### Servers -------------------------------------'

    for stype in '-ha   ' '-confd' '@mds  ' @ios{1..9}' ' @cas{1..9}' ' ; do
        atiem=
        color=$NC
        local pid=
        local padding='    '
        local state=$(get_param_of mero-server$stype ActiveState)

        case $state in
            active)   atime=$(get_param_of mero-server$stype ActiveEnterTimestamp)
                      pid=$(get_param_of mero-server$stype MainPID)
                      color=$GREEN ;;
            failed)   atime=$(get_param_of mero-server$stype InactiveEnterTimestamp)
                      color=$RED   ;;
            inactive) padding='  ' ;;
        esac

        if [[ (! $stype =~ @ios[2-9] && ! $stype =~ @cas[2-9]) || $state =~ ^(active|failed)$ ]] ; then
            echo " mero-server$stype       $color$state$NC$padding$atime    ${pid:+PID:$pid}"
        fi
    done

    echo
    echo '### Trace ---------------------------------------'

    for stype in kernel 'ha    ' 'confd ' 'mds   ' ios{1..9}'  ' cas{1..9}'  ' ; do
        atiem=
        color=$NC
        local state=$(get_param_of mero-trace@$stype ActiveState)

        case $state in
            active) atime=$(get_param_of mero-trace@$stype ActiveEnterTimestamp)
                    color=$GREEN ;;
            failed) atime=$(get_param_of mero-trace@$stype InactiveEnterTimestamp)
                    color=$RED   ;;
        esac

        if [[ $state =~ ^(active|failed)$ ]] ; then
            echo " mero-trace@$stype       $color$state$NC    $atime"
        fi
    done
}

#
# Main
#

# exit immediately if one the commands exits with a non-zero status
set -e

parse_cli_options "$@"
eval set -- "$cli_args"

[[ $UID -eq 0 ]] ||
    die 'Please, run this script with "root" privileges.'

# check color support, disable colored output if STDOUT isn't a terminal
[[ -t 1 ]] || {
    RED=
    GREEN=
    NC=
}

m0setup=$(path_of m0setup)
action="$1"; shift

case $action in

    activate)  $m0setup -A ;;
    enable)    systemctl enable mero-singlenode ;;
    disable)   systemctl disable mero-singlenode ;;
    start)     start_singlenode ;;
    stop)      stop_singlenode ;;
    restart)   stop_singlenode ; sleep 1 ; start_singlenode ;;
    status)    singlenode_status ;;

    *) die "Unsupported action '$action', available actions are: " \
           "activate|enable|disable|start|stop|restart|status"
       ;;
esac
