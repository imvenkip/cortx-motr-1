#!/usr/bin/env bash
set -eu
# set -x
export PS4='+ [${FUNCNAME[0]:+${FUNCNAME[0]}:}${LINENO}] '

## CAUTION: This path will be removed by superuser.
SANDBOX_DIR=${SANDBOX_DIR:-/var/mero/sandbox.m0mount-fail-st}

TRACE_MASK=${M0_TRACE_IMMEDIATE_MASK:-all}
TRACE_LEVEL=${M0_TRACE_LEVEL:-warn+}
TRACE_CONTEXT=${M0_TRACE_PRINT_CONTEXT:-}

MAX_RPC_MSG_SIZE=163840
TM_MIN_RECV_QUEUE_LEN=2
PROFILE='<0x7000000000000001:0>'        # profile-0
PROCESS_M0D='<0x7200000000000001:0>'    # process-0
PROCESS_M0T1FS='<0x7200000000000001:4>' # process-4

error() { echo "$@" >&2; stop 1; }

M0_SRC_DIR=`readlink -f $0`
M0_SRC_DIR=${M0_SRC_DIR%/*/*}

. $M0_SRC_DIR/utils/functions # die, sandbox_init, report_and_exit

start() {
    _init
    m0d_start
}

stop() {
    local rc=${1:-$?}

    trap - EXIT
    m0d_stop
    _fini $rc
    report_and_exit mount-fail $rc
}

_init() {
    lnet_up
    modules_insert
    sandbox_init # changes current directory to $SANDBOX_DIR
    mkdir mnt
}

_fini() {
    rmdir mnt
    sandbox_fini ${1:-}
    modules_remove
}

### XXX Code duplication!
### There is an identical function in conf/st.
### TODO: Move this code to `utils/functions'
modules_insert() {
    insmod $M0_SRC_DIR/extra-libs/gf-complete/src/linux_kernel/m0gf.ko ||
        die 'Inserting m0gf.ko failed'

    insmod $M0_SRC_DIR/mero/m0mero.ko \
        local_addr=$M0T1FS_ENDPOINT \
        max_rpc_msg_size=$MAX_RPC_MSG_SIZE \
        tm_recv_queue_min_len=$TM_MIN_RECV_QUEUE_LEN \
        ${TRACE_MASK:+trace_immediate_mask=$TRACE_MASK} \
        ${TRACE_LEVEL:+trace_level=$TRACE_LEVEL} \
        ${TRACE_CONTEXT:+trace_print_context=$TRACE_CONTEXT} \
        || {
        rmmod m0gf
        die 'Inserting m0mero.ko failed'
    }
}

### XXX Code duplication!
### There is an identical function in conf/st.
### TODO: Move this code to `utils/functions'.
modules_remove() {
    rmmod m0mero
    rmmod m0gf
}

### XXX Code duplication!
### There is an identical function in conf/st.
### TODO: Move this code to `utils/functions'.
export_endpoints() {
    local LNET_NID=`lctl list_nids | head -1`

    ## LNet endpoint address format (see net/lnet/lnet.h):
    ##     NID:PID:Portal:TMID
    ##
    ## The PID value of 12345 is used by Lustre in the kernel and is
    ## the only value currently supported.
    export M0T1FS_ENDPOINT="$LNET_NID:12345:34:"
    export SERVER1_ENDPOINT="$LNET_NID:12345:34:1001"
    export SERVER2_ENDPOINT="$LNET_NID:12345:34:1002"
    export SPIEL_ENDPOINT="$LNET_NID:12345:34:2001"
}

### Starts LNET. (Note that the script never stops LNET.)
### XXX Code duplication!
### There is an identical function in conf/st.
### TODO: Move this code to `utils/functions'.
lnet_up() {
    modprobe lnet
    lctl network up >/dev/null
    export_endpoints
}

# The generated configuration does not include RMS. This is a to cause
# m0t1fs' rconfc to fail while starting, and as the result, prevent m0t1fs
# from successful mounting.
conf_without_rms() {
    cat <<EOF
(root-0 verno=1 profiles=[profile-0])
(profile-0 filesystem=filesystem-0)
(filesystem-0 rootfid=(11, 22) redundancy=2
    params=["pool_width=3", "nr_data_units=1", "nr_parity_units=1",
            "unit_size=4096"]
    mdpool=pool-0 nodes=[node-0] pools=[pool-0] racks=[rack-0])
(node-0 memsize=16000 nr_cpu=2 last_state=3 flags=2 pool_id=pool-0
    processes=[process-0])
(process-0 cores=[3] mem_limit_as=0 mem_limit_rss=0 mem_limit_stack=0
    mem_limit_memlock=0 endpoint="$SERVER1_ENDPOINT"
    services=[service-1, service-2, service-3, service-4, service-5])
(service-1 type=6 endpoints=["$SERVER1_ENDPOINT"] sdevs=[])
(service-2 type=2 endpoints=["$SERVER1_ENDPOINT"] sdevs=[sdev-1, sdev-2, sdev-3,
    sdev-4])
(service-3 type=1 endpoints=["$SERVER1_ENDPOINT"] sdevs=[sdev-0])
(service-4 type=3 endpoints=["$SERVER1_ENDPOINT"] sdevs=[])
(service-5 type=7 endpoints=["$SERVER1_ENDPOINT"] sdevs=[])
(pool-0 order=0 pvers=[pver-0])
(pver-0 ver=0 N=2 K=1 P=4 nr_failures=[0, 0, 0, 0, 1] rackvs=[objv-0])
(objv-0 real=rack-0 children=[objv-1])
(objv-1 real=enclosure-0 children=[objv-2])
(objv-2 real=controller-0 children=[objv-3, objv-4, objv-5, objv-6])
(objv-3 real=disk-0 children=[])
(objv-4 real=disk-1 children=[])
(objv-5 real=disk-2 children=[])
(objv-6 real=disk-3 children=[])
(rack-0 encls=[enclosure-0] pvers=[pver-0])
(enclosure-0 ctrls=[controller-0] pvers=[pver-0])
(controller-0 node=node-0 disks=[disk-0, disk-1, disk-2, disk-3] pvers=[pver-0])
(disk-0 dev=sdev-1 pvers=[pver-0])
(disk-1 dev=sdev-2 pvers=[pver-0])
(disk-2 dev=sdev-3 pvers=[pver-0])
(disk-3 dev=sdev-4 pvers=[pver-0])
(sdev-0 dev_idx=0 iface=4 media=1 bsize=4096 size=596000000000 last_state=3
    flags=4 filename="/dev/sdev0")
(sdev-1 dev_idx=0 iface=4 media=1 bsize=4096 size=596000000000 last_state=3
    flags=4 filename="/dev/sdev1")
(sdev-2 dev_idx=1 iface=7 media=2 bsize=8192 size=320000000000 last_state=2
    flags=4 filename="/dev/sdev2")
(sdev-3 dev_idx=2 iface=7 media=2 bsize=8192 size=320000000000 last_state=2
    flags=4 filename="/dev/sdev3")
(sdev-4 dev_idx=3 iface=7 media=2 bsize=8192 size=320000000000 last_state=2
    flags=4 filename="/dev/sdev4")
EOF
}

m0d_start() {
    local CONF_FILE=conf.xc
    local OPTS="-P $PROFILE -f $PROCESS_M0D
-m $MAX_RPC_MSG_SIZE -q $TM_MIN_RECV_QUEUE_LEN -F -D db -T AD -S stobs
-A linuxstob:addb-stobs -e lnet:$SERVER1_ENDPOINT -c $CONF_FILE -w 3"

    conf_without_rms | $M0_SRC_DIR/utils/m0confgen >$CONF_FILE ||
        error 'm0confgen failed'

    $M0_SRC_DIR/utils/mkfs/m0mkfs $OPTS &>mkfs.log || error 'm0mkfs failed'

    echo $M0_SRC_DIR/mero/m0d $OPTS >m0d.log
    $M0_SRC_DIR/mero/m0d $OPTS &>>m0d.log &
    local PID=$!
    sleep 2
    kill -0 $PID 2>/dev/null ||
        error "Failed to start m0d. See $SANDBOX_DIR/m0d.log for details."
}

m0d_stop() { killall -q lt-m0d && wait || true; }

mount_fail() {
    local OPTS='-t m0t1fs'
    OPTS+=" -o pfid=$PROCESS_M0T1FS,profile=$PROFILE,ha=$SERVER1_ENDPOINT"
    OPTS+=" none $SANDBOX_DIR/mnt"

    echo mount $OPTS >mount.log
    if mount $OPTS &>>mount.log; then
        echo 'mount failed to fail' | tee -a mount.log >&2
        umount $SANDBOX_DIR/mnt
        return 1
    else
        echo "mount failed as expected" &>>mount.log
    fi
}

## -------------------------------------------------------------------
## main()
## -------------------------------------------------------------------

[ `id -u` -eq 0 ] || die 'Must be run by superuser'

trap stop EXIT
start

echo 8 >/proc/sys/kernel/printk  # Print kernel messages to the console.
mount_fail

stop
