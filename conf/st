#!/bin/bash
set -eu

### XXX TODO:
### 0. Add failure tests. They are very useful in finding deficiencies
###    of Mero error-handling code.
###    - See m0t1fs/linux_kernel/st/st in git history for how they used
###      to be implemented.
###    - Add a failure test corresponding to MERO-322.
###    - Add a scenario that will guard against MERO-804 regressions.
### 1. Restore "autoconf" test case.

## CAUTION: This path will be removed by superuser.
SANDBOX_DIR=${SANDBOX_DIR:-~/_sandbox.conf-st}

TRACE_MASK=${M0_TRACE_IMMEDIATE_MASK:-!rpc,formation,fop,memory}
TRACE_LEVEL=${M0_TRACE_LEVEL:-info+}
TRACE_CONTEXT=${M0_TRACE_PRINT_CONTEXT:-}

MAX_RPC_MSG_SIZE=163840
TM_MIN_RECV_QUEUE_LEN=2

die() { echo "$@" >&2; exit 1; }
error() { echo "$@" >&2; stop 1; }

M0_CORE_DIR=`readlink -f $0`
M0_CORE_DIR=${M0_CORE_DIR%/*/*}

## Path to the file with configuration string for confd.
CONF_FILE=$SANDBOX_DIR/conf.txt

start() {
   _init
   services_start
}

stop() {
   services_stop
   _fini
   exit ${1:-$?}
}

_init() {
    lnet_up
    modules_insert
    sandbox_init
}

_fini() {
    sandbox_fini
    modules_remove
}

sandbox_init() {
    rm -rf $SANDBOX_DIR
    mkdir -p $SANDBOX_DIR/mnt
}

sandbox_fini() {
    if [ -d $SANDBOX_DIR/mnt ]; then
	rmdir $SANDBOX_DIR/mnt
    fi
    ## Note that the script does not delete $SANDBOX_DIR itself:
    ## developers may want to analyze the logs contained there.
}

modules_insert() {
    insmod $M0_CORE_DIR/extra-libs/gf-complete/src/linux_kernel/m0gf.ko || \
	die 'Inserting m0gf.ko failed'

    insmod $M0_CORE_DIR/mero/m0mero.ko \
	local_addr=$M0T1FS_ENDPOINT \
	max_rpc_msg_size=$MAX_RPC_MSG_SIZE \
	tm_recv_queue_min_len=$TM_MIN_RECV_QUEUE_LEN \
	${TRACE_MASK:+trace_immediate_mask=$TRACE_MASK} \
	${TRACE_LEVEL:+trace_level=$TRACE_LEVEL} \
	${TRACE_CONTEXT:+trace_print_context=$TRACE_CONTEXT} \
	|| {
	rmmod m0gf
	die 'Inserting m0mero.ko failed'
    }
}

modules_remove() {
    rmmod m0mero
    rmmod m0gf
}

export_endpoints() {
    local LNET_NID=`lctl list_nids | head -1`

    ## LNet endpoint address format (see net/lnet/lnet.h):
    ##     NID:PID:Portal:TMID
    ##
    ## The PID value of 12345 is used by Lustre in the kernel and is
    ## the only value currently supported.
    export M0T1FS_ENDPOINT="$LNET_NID:12345:34:"
    export IOS0_ENDPOINT="$LNET_NID:12345:34:1001"
    export IOS1_ENDPOINT="$LNET_NID:12345:34:1002"
    export CONFD_ENDPOINT="$IOS0_ENDPOINT"
    export SSS_ENDPOINT="$IOS0_ENDPOINT"
    export RMS_ENDPOINT="$IOS0_ENDPOINT"
    export MDS_ENDPOINT="$IOS0_ENDPOINT"
}

### Starts LNET. (Note that the script never stops LNET.)
lnet_up() {
    modprobe lnet
    lctl network up >/dev/null
    export_endpoints
}

confdb() {
	cat <<EOF
(root-0 verno=1 profiles=[profile-0, profile-10])
(profile-0 filesystem=filesystem-0)
(filesystem-0 rootfid=(11, 22) redundancy=2
    params=["pool_width=3", "nr_data_units=1", "nr_parity_units=1",
            "unit_size=4096"]
    mdpool=pool-0 nodes=[node-0] pools=[pool-0] racks=[rack-0])
(node-0 memsize=16000 nr_cpu=2 last_state=3 flags=2 pool_id=pool-0
    processes=[process-0, process-1, process-2, process-3])
(process-0 mem_limit=4000 cores=2 services=[service-0])
(process-1 mem_limit=4000 cores=2 services=[service-1])
(process-2 mem_limit=4000 cores=1 services=[service-2])
(process-3 mem_limit=4000 cores=2 services=[service-3])
(service-0 type=5 endpoints=["$SSS_ENDPOINT"] sdevs=[])
(service-1 type=4 endpoints=["$RMS_ENDPOINT"] sdevs=[])
(service-2 type=1 endpoints=["$MDS_ENDPOINT"] sdevs=[sdev-0])
(service-3 type=2 endpoints=["$IOS0_ENDPOINT"] sdevs=[sdev-1, sdev-2])
(sdev-0 iface=4 media=1 bsize=4096 size=596000000000 last_state=3 flags=4
    filename="/dev/sdev0")
(sdev-1 iface=4 media=1 bsize=4096 size=596000000000 last_state=3 flags=4
    filename="/dev/sdev1")
(sdev-2 iface=7 media=2 bsize=8192 size=320000000000 last_state=2 flags=4
    filename="/dev/sdev2")
(rack-0 encls=[enclosure-0] pvers=[pver-0])
(enclosure-0 ctrls=[controller-0] pvers=[pver-0])
(controller-0 node=node-0 disks=[disk-0] pvers=[pver-0])
(disk-0 dev=sdev-2)
(pool-0 order=0 pvers=[pver-0])
(pver-0 ver=0 N=8 K=2 P=15 permutations=[1, 2, 4] nr_failures=[]
    rackvs=[objv-0])
(objv-0 real=rack-0 children=[objv-1])
(objv-1 real=enclosure-0 children=[objv-2])
(objv-2 real=controller-0 children=[objv-3])
(objv-3 real=disk-0 children=[])
# --------------------
(profile-10 filesystem=filesystem-10)
(filesystem-10 rootfid=(33, 44) redundancy=2
    params=["-T", "linux", "-D", "db", "-S", "stobs",
            "-A", "linuxstob:addb-stobs", "-w", "3"]
    mdpool=pool-10 nodes=[node-10] pools=[pool-10] racks=[])
(node-10 memsize=16000 nr_cpu=2 last_state=3 flags=2 pool_id=pool-10
    processes=[process-10])
(process-10 mem_limit=4000 cores=2 services=[service-10])
(service-10 type=2 endpoints=["$IOS1_ENDPOINT"] sdevs=[sdev-10])
(sdev-10 iface=4 media=2 bsize=8192 size=0 last_state=2 flags=4
    filename="/dev/null")
(pool-10 order=0 pvers=[])
EOF
}

###
### Starts Mero services.
###
### There are two modes of operation:
###
###   services_start
###       m0d starts "confd" and several other services.
###
###   services_start autoconf
###       m0d starts with minimal set of options and configures itself.
###
services_start() {
    [ $# -eq 0 -o "${1:-}" = autoconf ] || error 'Invalid argument'
    local MODE="${1:-}"

    local PROF_AC_OPT='<0x7000000000000001:10>' # "profile-10"
    local CONFD_SPEC="-s confd -c $CONF_FILE"
    local OPTS=

    if [ "$MODE" = autoconf ]; then
	OPTS="-C $CONFD_ENDPOINT -P $PROF_AC_OPT
-e lnet:$IOS1_ENDPOINT -s ioservice
-m $MAX_RPC_MSG_SIZE -q $TM_MIN_RECV_QUEUE_LEN"
    else
	OPTS="
-F -D $SANDBOX_DIR/db -T linux -S $SANDBOX_DIR/stobs
-A linuxstob:$SANDBOX_DIR/addb-stobs
-e lnet:$IOS0_ENDPOINT $CONFD_SPEC -s mdservice -s addb -s addb2 -s ioservice
-m $MAX_RPC_MSG_SIZE -q $TM_MIN_RECV_QUEUE_LEN -w 3"
    fi

    confdb | $M0_CORE_DIR/utils/m0confgen >$CONF_FILE

    echo "--- `date` ---" >>$SANDBOX_DIR/m0d.log
    cd $SANDBOX_DIR

    [ "$MODE" = autoconf ] || {
	## m0mkfs should be executed only once. It is usually executed
	## during cluster initial setup.
	$M0_CORE_DIR/utils/mkfs/m0mkfs $OPTS >>$SANDBOX_DIR/mkfs.log || \
	    error 'm0mkfs failed'
    }

    $M0_CORE_DIR/mero/m0d $OPTS >>$SANDBOX_DIR/m0d.log 2>&1 &
    local PID=$!
    sleep 1
    kill -0 $PID 2>/dev/null || \
	error "Failed to start m0d. See $SANDBOX_DIR/m0d.log for details."
}

services_stop() { killall -q lt-m0d && wait || true; }

_mount() {
    local PROF_OPT='<0x7000000000000001:0>' # "profile-0"
    mount -t m0t1fs -o profile="$PROF_OPT",confd=$CONFD_ENDPOINT \
	  none $SANDBOX_DIR/mnt || return $?
}

## Keep the audience engaged.
say() { echo "$@" | tee -a $SANDBOX_DIR/m0d.log; }

usage() {
    cat <<EOF
Usage: ${0##*/} [COMMAND]

Supported commands:
  run      run system tests (default command)
  insmod   insert Mero kernel modules: m0mero.ko, m0gf.ko
  rmmod    remove Mero kernel modules
  sstart   start Mero user-space services
  sstop    stop Mero user-space services
  help     display this help and exit
EOF
}

## -------------------------------------------------------------------
## main()
## -------------------------------------------------------------------

[ `id -u` -eq 0 ] || die 'Must be run by superuser'

case "${1:-}" in
    run|'') ;;
    insmod) lnet_up; modules_insert; exit;;
    rmmod) modules_remove; exit;;
    sstart) start; exit;;
    sstop) services_stop; sleep 3; _fini; exit;;
    help) usage; exit;;
    *) usage >&2; die;;
esac

start

echo 8 >/proc/sys/kernel/printk  # Print kernel messages to the console.

say 'Test: m0t1fs'
_mount || stop $?
umount $SANDBOX_DIR/mnt

if false; then # XXX DEBUGME
## "conf-reqh" demo: start another instance of m0d, which configures
## itself retrieving data from confd.
say 'Test: reqh'
services_start autoconf
fi

stop
