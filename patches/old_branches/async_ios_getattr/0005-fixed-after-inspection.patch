From b3e54729b6cef6d2eed0e9c1d9477930685b3b2e Mon Sep 17 00:00:00 2001
From: Hua Huang <hua_huang@xyratex.com>
Date: Tue, 6 Aug 2013 22:27:26 +0800
Subject: [PATCH 5/7] fixed after inspection: save out pointer and copy
 returned data to out before calling callback.

---
 ioservice/io_service.c | 26 +++++++++++++++++++-------
 ioservice/io_service.h |  9 +++------
 sns/cm/cm_utils.c      | 41 ++++++++++++++++-------------------------
 3 files changed, 38 insertions(+), 38 deletions(-)

diff --git a/ioservice/io_service.c b/ioservice/io_service.c
index 0869ccb..5980fa5 100644
--- a/ioservice/io_service.c
+++ b/ioservice/io_service.c
@@ -891,6 +891,9 @@ struct mds_op {
 	struct m0_fop               mo_fop;
 	struct m0_cm_callback_info *mo_cb_info;
 
+	/** saved out pointer. returned data will be copied here */
+	void *mo_out;
+
 	/* These arguments are saved in async call and used in callback */
 	void *mo_p1;   /* saved param1 */
 	void *mo_p2;   /* saved param2 */
@@ -903,7 +906,7 @@ static void getattr_rpc_item_reply_cb(struct m0_rpc_item *item)
 	struct m0_fop               *rep;
 	struct m0_fop_getattr_rep   *getattr_rep;
 	struct m0_fop_cob           *rep_fop_cob;
-	struct m0_cob_attr           attr;
+	struct m0_cob_attr          *attr;
 	struct m0_cm_callback_info  *cb_info;
 	int                          rc;
 
@@ -911,6 +914,7 @@ static void getattr_rpc_item_reply_cb(struct m0_rpc_item *item)
 	req = m0_rpc_item_to_fop(item);
 	mdsop = container_of(req, struct mds_op, mo_fop);
 	cb_info = mdsop->mo_cb_info;
+	attr = mdsop->mo_out;
 
 	rc = item->ri_error;
 
@@ -920,12 +924,12 @@ static void getattr_rpc_item_reply_cb(struct m0_rpc_item *item)
 		getattr_rep = m0_fop_data(rep);
 		rep_fop_cob = &getattr_rep->g_body;
 		if (rep_fop_cob->b_rc == 0)
-			m0_md_cob_wire2mem(&attr, rep_fop_cob);
+			m0_md_cob_wire2mem(attr, rep_fop_cob);
 		else
 			rc = rep_fop_cob->b_rc;
 	}
 
-	cb_info->ci_cb(cb_info->ci_arg, rc, &attr);
+	cb_info->ci_cb(cb_info->ci_arg, rc);
 }
 
 const struct m0_rpc_item_ops getattr_fop_rpc_item_ops = {
@@ -937,6 +941,7 @@ const struct m0_rpc_item_ops getattr_fop_rpc_item_ops = {
  */
 M0_INTERNAL int m0_ios_mds_getattr_async(struct m0_reqh *reqh,
 				         const struct m0_fid *gfid,
+					 struct m0_cob_attr  *attr,
 					 struct m0_cm_callback_info *cb_info)
 {
 	struct m0_ios_mds_conn    *imc;
@@ -968,6 +973,8 @@ M0_INTERNAL int m0_ios_mds_getattr_async(struct m0_reqh *reqh,
 	}
 
 	mdsop->mo_cb_info = cb_info;
+	mdsop->mo_out     = attr;
+
 	getattr = m0_fop_data(req);
 	req_fop_cob = &getattr->g_body;
 	req_fop_cob->b_tfid = *gfid;
@@ -992,6 +999,7 @@ static void getlayout_rpc_item_reply_cb(struct m0_rpc_item *item)
 	struct m0_layout_domain    *ldom;
 	uint64_t                    lid;
 	struct m0_layout           *l;
+	struct m0_layout          **l_out;
 	struct m0_cm_callback_info *cb_info;
 	int                         rc;
 
@@ -999,6 +1007,7 @@ static void getlayout_rpc_item_reply_cb(struct m0_rpc_item *item)
 	req = m0_rpc_item_to_fop(item);
 	mdsop = container_of(req, struct mds_op, mo_fop);
 	cb_info = mdsop->mo_cb_info;
+	l_out = mdsop->mo_out;
 
 	ldom = mdsop->mo_p1;
 	lid  = (uint64_t)mdsop->mo_p2;
@@ -1025,14 +1034,15 @@ static void getlayout_rpc_item_reply_cb(struct m0_rpc_item *item)
 			rc = m0_layout_decode(l, &cur, M0_LXO_BUFFER_OP, NULL);
 			/* release lock held by ->lto_allocate() */
 			m0_mutex_unlock(&l->l_lock);
-			if (rc != 0)
+			if (rc == 0) {
+				*l_out = l;
+			} else {
 				m0_layout_put(l);
+			}
 		}
 	}
 
-	cb_info->ci_cb(cb_info, rc, l);
-	if (rc == 0)
-		m0_layout_put(l);
+	cb_info->ci_cb(cb_info, rc);
 }
 
 const struct m0_rpc_item_ops getlayout_fop_rpc_item_ops = {
@@ -1043,6 +1053,7 @@ const struct m0_rpc_item_ops getlayout_fop_rpc_item_ops = {
 M0_INTERNAL int m0_ios_mds_layout_get_async(struct m0_reqh *reqh,
 					    struct m0_layout_domain *ldom,
 					    uint64_t lid,
+					    struct m0_layout **l_out,
 					    struct m0_cm_callback_info *cb_info)
 {
 	struct m0_ios_mds_conn *imc;
@@ -1073,6 +1084,7 @@ M0_INTERNAL int m0_ios_mds_layout_get_async(struct m0_reqh *reqh,
 	}
 
 	mdsop->mo_cb_info = cb_info;
+	mdsop->mo_out = l_out;
 	mdsop->mo_p1 = ldom;
 	mdsop->mo_p2 = (void *)lid;
 	layout = m0_fop_data(req);
diff --git a/ioservice/io_service.h b/ioservice/io_service.h
index 9bb18f4..04ae98a 100644
--- a/ioservice/io_service.h
+++ b/ioservice/io_service.h
@@ -136,23 +136,20 @@ M0_INTERNAL int m0_ios_mds_layout_get(struct m0_reqh *reqh,
 struct m0_cm_callback_info {
 	/** @param arg caller provided, pass it back to caller.
 	 *  @param rc return value on this async call.
-	 *  @param data call specific data returned, only valid when rc is zero.
-	 *         This data may have different meaning for different call.
-	 *         It is invalid after this cb is retured. If caller wants
-	 *         to use it later, it needs to be copied out, or get
-	 *         reference increased.
 	 */
-	void (*ci_cb)(void *arg, int rc, void *data);
+	void (*ci_cb)(void *arg, int rc);
 	/** caller provided argument */
 	void *ci_arg;
 };
 
 M0_INTERNAL int m0_ios_mds_getattr_async(struct m0_reqh *reqh,
 				         const struct m0_fid *gfid,
+					 struct m0_cob_attr  *attr,
 					 struct m0_cm_callback_info *cb_info);
 M0_INTERNAL int m0_ios_mds_layout_get_async(struct m0_reqh *reqh,
 					    struct m0_layout_domain *ldom,
 					    uint64_t lid,
+					    struct m0_layout **l_out,
 					    struct m0_cm_callback_info *cbinfo);
 /** @} end of io_service */
 
diff --git a/sns/cm/cm_utils.c b/sns/cm/cm_utils.c
index e5015de..e95f5cc 100644
--- a/sns/cm/cm_utils.c
+++ b/sns/cm/cm_utils.c
@@ -364,16 +364,12 @@ m0_sns_cm_file_size_layout_fetch(struct m0_cm *cm,
  * Note: The following code are only for sample purpose to use async getattr.
  *
  */
-static void getattr_callback(void *arg, int rc, void *data)
+static void getattr_callback(void *arg, int rc)
 {
-	struct m0_cm       *cm   = arg;
-	struct m0_cob_attr *attr = data;
+	struct m0_cm *cm = arg;
 
 	if (rc == 0) {
-		/* getattr succeeded.
-		 * copy out the attr for later use.
-		 */
-		(void)attr;
+		/* getattr succeeded. */
 	}
 	/* TODO:
 	 * To inform the original caller to continue execution.
@@ -399,7 +395,8 @@ struct m0_cm_callback_info getattr_cb_info = {
  */
 M0_INTERNAL int
 m0_sns_cm_file_attr_fetch_async(struct m0_cm *cm,
-				struct m0_fid *gfid)
+				struct m0_fid *gfid,
+				struct m0_cob_attr *attr)
 {
 	struct m0_reqh *reqh = cm->cm_service.rs_reqh;
 	int             rc;
@@ -408,28 +405,19 @@ m0_sns_cm_file_attr_fetch_async(struct m0_cm *cm,
 	M0_PRE(gfid != NULL);
 	M0_PRE(m0_cm_is_locked(cm));
 
-	getattr_cb_info.ci_arg = cm; /* if needed, this can be gfid, too */
+	/* Caller can save anything here. It will passed to callback. */
+	getattr_cb_info.ci_arg = cm;
 
-	rc = m0_ios_mds_getattr_async(reqh, gfid, &getattr_cb_info);
+	rc = m0_ios_mds_getattr_async(reqh, gfid, attr, &getattr_cb_info);
 	return rc;
 }
 
-static void layout_callback(void *arg, int rc, void *data)
+static void layout_callback(void *arg, int rc)
 {
-	struct m0_pdclust_layout  *pdl    = NULL;
-	struct m0_cm              *cm     = arg;
-	struct m0_layout          *layout = data;
+	struct m0_cm *cm = arg;
 
 	if (rc == 0) {
-		/* getlayout succeeded.
-		 * get a new ref on the returned ayout for later use.
-		 */
-		m0_layout_get(layout);
-		pdl = m0_layout_to_pdl(layout);
-		/* Copy this pld to somewhere else, or use it here.
-		 * Ref on this layout must be released later with m0_layout_put.
-		 */
-		(void)pdl;
+		/* getlayout succeeded. */
 	}
 	/* TODO:
 	 * To inform the original caller to continue execution.
@@ -446,7 +434,8 @@ struct m0_cm_callback_info layout_cb_info = {
  */
 M0_INTERNAL int
 m0_sns_cm_file_layout_fetch_async(struct m0_cm *cm,
-				  uint64_t lid)
+				  uint64_t lid,
+				  struct m0_layout **l_out)
 {
 	struct m0_layout_domain  *ldom;
 	struct m0_reqh           *reqh = cm->cm_service.rs_reqh;
@@ -456,9 +445,11 @@ m0_sns_cm_file_layout_fetch_async(struct m0_cm *cm,
 	M0_PRE(m0_cm_is_locked(cm));
 
 	ldom = &reqh->rh_ldom;
+
+	/* Caller can save anything here. It will passed to callback. */
 	layout_cb_info.ci_arg = cm;
 
-	rc = m0_ios_mds_layout_get_async(reqh, ldom, lid, &layout_cb_info);
+	rc = m0_ios_mds_layout_get_async(reqh, ldom, lid, l_out, &layout_cb_info);
 	return rc;
 }
 
-- 
1.8.3.2

