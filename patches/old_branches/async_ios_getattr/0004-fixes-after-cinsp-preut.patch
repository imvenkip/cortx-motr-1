From a779cad85be929f1c652534856eed186392ed8b6 Mon Sep 17 00:00:00 2001
From: Hua Huang <hua_huang@xyratex.com>
Date: Mon, 5 Aug 2013 23:45:21 +0800
Subject: [PATCH 4/7] fixes after cinsp-preut: define a struct mds_op to
 contain a fop. simplied sample code to use async getattr

---
 ioservice/io_service.c | 80 +++++++++++++++++++++++++++++++++++---------------
 ioservice/io_service.h | 25 +++++-----------
 rpc/item.h             |  3 --
 sns/cm/cm_utils.c      | 56 +++++++++++++++--------------------
 sns/cm/cm_utils.h      | 10 -------
 5 files changed, 88 insertions(+), 86 deletions(-)

diff --git a/ioservice/io_service.c b/ioservice/io_service.c
index d9da574..0869ccb 100644
--- a/ioservice/io_service.c
+++ b/ioservice/io_service.c
@@ -871,9 +871,7 @@ M0_INTERNAL int m0_ios_mds_layout_get(struct m0_reqh *reqh,
 }
 
 static int _rpc_post(struct m0_fop                *fop,
-		     struct m0_rpc_session        *session,
-		     const struct m0_rpc_item_ops *ri_ops,
-		     struct m0_cm_callback_info   *cb_info)
+		     struct m0_rpc_session        *session)
 {
 	struct m0_rpc_item *item;
 
@@ -881,29 +879,38 @@ static int _rpc_post(struct m0_fop                *fop,
 	M0_PRE(session != NULL);
 
 	item                     = &fop->f_item;
-	item->ri_ops             = ri_ops;
 	item->ri_session         = session;
 	item->ri_prio            = M0_RPC_ITEM_PRIO_MID;
 	item->ri_deadline        = 0;
 	item->ri_resend_interval = M0_TIME_NEVER;
-	item->ri_private         = cb_info;
 
 	return m0_rpc_post(item);
 }
 
+struct mds_op {
+	struct m0_fop               mo_fop;
+	struct m0_cm_callback_info *mo_cb_info;
+
+	/* These arguments are saved in async call and used in callback */
+	void *mo_p1;   /* saved param1 */
+	void *mo_p2;   /* saved param2 */
+};
 
 static void getattr_rpc_item_reply_cb(struct m0_rpc_item *item)
 {
+	struct mds_op               *mdsop;
+	struct m0_fop               *req;
 	struct m0_fop               *rep;
 	struct m0_fop_getattr_rep   *getattr_rep;
 	struct m0_fop_cob           *rep_fop_cob;
-        struct m0_cob_attr           attr;
+	struct m0_cob_attr           attr;
 	struct m0_cm_callback_info  *cb_info;
 	int                          rc;
 
 	M0_PRE(item != NULL);
-	M0_ASSERT(item->ri_private != NULL);
-	cb_info = item->ri_private;
+	req = m0_rpc_item_to_fop(item);
+	mdsop = container_of(req, struct mds_op, mo_fop);
+	cb_info = mdsop->mo_cb_info;
 
 	rc = item->ri_error;
 
@@ -918,14 +925,13 @@ static void getattr_rpc_item_reply_cb(struct m0_rpc_item *item)
 			rc = rep_fop_cob->b_rc;
 	}
 
-	cb_info->ci_cb(cb_info, rc, &attr);
+	cb_info->ci_cb(cb_info->ci_arg, rc, &attr);
 }
 
 const struct m0_rpc_item_ops getattr_fop_rpc_item_ops = {
 	.rio_replied = getattr_rpc_item_reply_cb,
 };
 
-
 /**
  * getattr from mdservice asynchronously.
  */
@@ -934,6 +940,7 @@ M0_INTERNAL int m0_ios_mds_getattr_async(struct m0_reqh *reqh,
 					 struct m0_cm_callback_info *cb_info)
 {
 	struct m0_ios_mds_conn    *imc;
+	struct mds_op             *mdsop;
 	struct m0_fop             *req;
 	struct m0_fop_getattr     *getattr;
 	struct m0_fop_cob         *req_fop_cob;
@@ -946,10 +953,21 @@ M0_INTERNAL int m0_ios_mds_getattr_async(struct m0_reqh *reqh,
 	if (!imc->imc_connected)
 		return -ENODEV;
 
-	req = m0_fop_alloc(&m0_fop_getattr_fopt, NULL);
-	if (req == NULL)
+	M0_ALLOC_PTR(mdsop);
+	if (mdsop == NULL)
 		return -ENOMEM;
 
+	req = &mdsop->mo_fop;
+	m0_fop_init(req, &m0_fop_getattr_fopt, NULL, NULL);
+	rc = m0_fop_data_alloc(req);
+	if (rc == 0) {
+		req->f_item.ri_ops = &getattr_fop_rpc_item_ops;
+	} else {
+		m0_free(mdsop);
+		return rc;
+	}
+
+	mdsop->mo_cb_info = cb_info;
 	getattr = m0_fop_data(req);
 	req_fop_cob = &getattr->g_body;
 	req_fop_cob->b_tfid = *gfid;
@@ -958,8 +976,7 @@ M0_INTERNAL int m0_ios_mds_getattr_async(struct m0_reqh *reqh,
 			 (unsigned long long)gfid->f_container,
 			 (unsigned long long)gfid->f_key);
 
-	rc = _rpc_post(req, &imc->imc_session, &getattr_fop_rpc_item_ops,
-		       cb_info);
+	rc = _rpc_post(req, &imc->imc_session);
 	M0_LOG(M0_DEBUG, "ios getattr sent asynchronously: rc = %d", rc);
 
 	m0_fop_put(req);
@@ -968,6 +985,8 @@ M0_INTERNAL int m0_ios_mds_getattr_async(struct m0_reqh *reqh,
 
 static void getlayout_rpc_item_reply_cb(struct m0_rpc_item *item)
 {
+	struct mds_op              *mdsop;
+	struct m0_fop              *req;
 	struct m0_fop              *rep;
 	struct m0_fop_layout_rep   *layout_rep;
 	struct m0_layout_domain    *ldom;
@@ -977,10 +996,12 @@ static void getlayout_rpc_item_reply_cb(struct m0_rpc_item *item)
 	int                         rc;
 
 	M0_PRE(item != NULL);
-	M0_PRE(item->ri_private != NULL);
-	cb_info = item->ri_private;
-	ldom = cb_info->ci_p1;
-	lid  = (uint64_t)cb_info->ci_p2;
+	req = m0_rpc_item_to_fop(item);
+	mdsop = container_of(req, struct mds_op, mo_fop);
+	cb_info = mdsop->mo_cb_info;
+
+	ldom = mdsop->mo_p1;
+	lid  = (uint64_t)mdsop->mo_p2;
 
 	rc = item->ri_error;
 
@@ -1025,6 +1046,7 @@ M0_INTERNAL int m0_ios_mds_layout_get_async(struct m0_reqh *reqh,
 					    struct m0_cm_callback_info *cb_info)
 {
 	struct m0_ios_mds_conn *imc;
+	struct mds_op          *mdsop;
 	struct m0_fop          *req;
 	struct m0_fop_layout   *layout;
 	int                     rc;
@@ -1036,20 +1058,30 @@ M0_INTERNAL int m0_ios_mds_layout_get_async(struct m0_reqh *reqh,
 	if (!imc->imc_connected)
 		return -ENODEV;
 
-	req = m0_fop_alloc(&m0_fop_layout_fopt, NULL);
-	if (req == NULL)
+	M0_ALLOC_PTR(mdsop);
+	if (mdsop == NULL)
 		return -ENOMEM;
 
+	req = &mdsop->mo_fop;
+	m0_fop_init(req, &m0_fop_getattr_fopt, NULL, NULL);
+	rc = m0_fop_data_alloc(req);
+	if (rc == 0) {
+		req->f_item.ri_ops = &getlayout_fop_rpc_item_ops;
+	} else {
+		m0_free(mdsop);
+		return rc;
+	}
+
+	mdsop->mo_cb_info = cb_info;
+	mdsop->mo_p1 = ldom;
+	mdsop->mo_p2 = (void *)lid;
 	layout = m0_fop_data(req);
 	layout->l_op  = M0_LAYOUT_OP_LOOKUP;
 	layout->l_lid = lid;
 
 	M0_LOG(M0_DEBUG, "ios getlayout for %llu",
 			 (unsigned long long)lid);
-	cb_info->ci_p1 = ldom;
-	cb_info->ci_p2 = (void *)lid;
-	rc = _rpc_post(req, &imc->imc_session, &getlayout_fop_rpc_item_ops,
-		       cb_info);
+	rc = _rpc_post(req, &imc->imc_session);
 	M0_LOG(M0_DEBUG, "ios getlayout for %llu sent: rc %d",
 			 (unsigned long long)lid, rc);
 	m0_fop_put(req);
diff --git a/ioservice/io_service.h b/ioservice/io_service.h
index e601330..9bb18f4 100644
--- a/ioservice/io_service.h
+++ b/ioservice/io_service.h
@@ -134,26 +134,17 @@ M0_INTERNAL int m0_ios_mds_layout_get(struct m0_reqh *reqh,
 
 /** callback information for async getattr & getlayout request to mdservice */
 struct m0_cm_callback_info {
-	/** @param arg1 caller provided.
+	/** @param arg caller provided, pass it back to caller.
 	 *  @param rc return value on this async call.
 	 *  @param data call specific data returned, only valid when rc is zero.
-	 *  	   This data may have different meaning for different call.
-	 *  	   It is invalid after this cb is retured. If caller wants
-	 *  	   to use it later, it needs to be copied out, or get
-	 *  	   reference increased.
+	 *         This data may have different meaning for different call.
+	 *         It is invalid after this cb is retured. If caller wants
+	 *         to use it later, it needs to be copied out, or get
+	 *         reference increased.
 	 */
-	void (*ci_cb)(struct m0_cm_callback_info *ci, int rc, void *data);
-	void *ci_arg; /* caller provided */
-
-	/** returned data stored here */
-	void *ci_out;
-
-	/** return value stored here */
-	int  *ci_rc;
-
-	/* for callee use only */
-	void *ci_p1;   /* saved param1 */
-	void *ci_p2;   /* saved param2 */
+	void (*ci_cb)(void *arg, int rc, void *data);
+	/** caller provided argument */
+	void *ci_arg;
 };
 
 M0_INTERNAL int m0_ios_mds_getattr_async(struct m0_reqh *reqh,
diff --git a/rpc/item.h b/rpc/item.h
index 18a6bc3..6ebdbd2 100644
--- a/rpc/item.h
+++ b/rpc/item.h
@@ -249,9 +249,6 @@ struct m0_rpc_item {
 	/** One of m0_rpc_frm::f_itemq[], in which this item is placed. */
 	struct m0_tl                    *ri_itemq;
 	struct m0_rpc_frm               *ri_frm;
-
-	/* private. Used as m0_cm_callback_info now */
-	void                            *ri_private;
 	/** M0_RPC_ITEM_MAGIC */
 	uint64_t			 ri_magic;
 };
diff --git a/sns/cm/cm_utils.c b/sns/cm/cm_utils.c
index ea195d3..e5015de 100644
--- a/sns/cm/cm_utils.c
+++ b/sns/cm/cm_utils.c
@@ -358,24 +358,26 @@ m0_sns_cm_file_size_layout_fetch(struct m0_cm *cm,
 /**
  * Callback for async getattr.
  *
- * This callback should tell the original cm the result and post event to ask it
+ * This callback should tell the original cm the result and post event to let it
  * continue execution.
+ *
+ * Note: The following code are only for sample purpose to use async getattr.
+ *
  */
-static void getattr_callback(struct m0_cm_callback_info *ci, int rc, void *data)
+static void getattr_callback(void *arg, int rc, void *data)
 {
-	struct m0_cob_attr *out  = ci->ci_out;
-	struct m0_cm       *cm   = ci->ci_arg;
+	struct m0_cm       *cm   = arg;
 	struct m0_cob_attr *attr = data;
 
-	*(ci->ci_rc) = rc;
 	if (rc == 0) {
 		/* getattr succeeded.
 		 * copy out the attr for later use.
 		 */
-		*out = *attr;
+		(void)attr;
 	}
-	/* inform caller that the callback is done. E.g.: */
-	/* cm_contunie_run(cm); or m0_fom_wakeup(some_fom); */
+	/* TODO:
+	 * To inform the original caller to continue execution.
+	 */
 	(void)cm;
 }
 
@@ -397,45 +399,41 @@ struct m0_cm_callback_info getattr_cb_info = {
  */
 M0_INTERNAL int
 m0_sns_cm_file_attr_fetch_async(struct m0_cm *cm,
-				struct m0_fid *gfid,
-				struct m0_cob_attr *out_attr,
-				int *out_rc)
+				struct m0_fid *gfid)
 {
-	struct m0_reqh           *reqh = cm->cm_service.rs_reqh;
-	int                       rc;
+	struct m0_reqh *reqh = cm->cm_service.rs_reqh;
+	int             rc;
 
 	M0_PRE(cm != NULL);
 	M0_PRE(gfid != NULL);
-	M0_PRE(out_attr != NULL);
-	M0_PRE(out_rc != NULL);
 	M0_PRE(m0_cm_is_locked(cm));
 
-	getattr_cb_info.ci_arg = cm;
-	getattr_cb_info.ci_out = out_attr;
-	getattr_cb_info.ci_rc  = out_rc;
+	getattr_cb_info.ci_arg = cm; /* if needed, this can be gfid, too */
 
 	rc = m0_ios_mds_getattr_async(reqh, gfid, &getattr_cb_info);
 	return rc;
 }
 
-static void layout_callback(struct m0_cm_callback_info *ci, int rc, void *data)
+static void layout_callback(void *arg, int rc, void *data)
 {
 	struct m0_pdclust_layout  *pdl    = NULL;
-	struct m0_pdclust_layout **out    = ci->ci_out;
-	struct m0_cm              *cm     = ci->ci_arg;
+	struct m0_cm              *cm     = arg;
 	struct m0_layout          *layout = data;
 
-	*(ci->ci_rc) = rc;
 	if (rc == 0) {
 		/* getlayout succeeded.
 		 * get a new ref on the returned ayout for later use.
 		 */
 		m0_layout_get(layout);
 		pdl = m0_layout_to_pdl(layout);
-		*out = pdl;
+		/* Copy this pld to somewhere else, or use it here.
+		 * Ref on this layout must be released later with m0_layout_put.
+		 */
+		(void)pdl;
 	}
-	/* inform caller that the callback is done. e.g.: */
-	/* cm_contunie_run(cm); or m0_fom_wakeup(some_fom); */
+	/* TODO:
+	 * To inform the original caller to continue execution.
+	 */
 	(void)cm;
 }
 
@@ -448,23 +446,17 @@ struct m0_cm_callback_info layout_cb_info = {
  */
 M0_INTERNAL int
 m0_sns_cm_file_layout_fetch_async(struct m0_cm *cm,
-				  uint64_t lid,
-				  struct m0_pdclust_layout **out_layout,
-				  int *out_rc)
+				  uint64_t lid)
 {
 	struct m0_layout_domain  *ldom;
 	struct m0_reqh           *reqh = cm->cm_service.rs_reqh;
 	int                       rc;
 
 	M0_PRE(cm != NULL);
-	M0_PRE(out_layout != NULL);
-	M0_PRE(out_rc != NULL);
 	M0_PRE(m0_cm_is_locked(cm));
 
 	ldom = &reqh->rh_ldom;
 	layout_cb_info.ci_arg = cm;
-	layout_cb_info.ci_out = out_layout;
-	layout_cb_info.ci_rc  = out_rc;
 
 	rc = m0_ios_mds_layout_get_async(reqh, ldom, lid, &layout_cb_info);
 	return rc;
diff --git a/sns/cm/cm_utils.h b/sns/cm/cm_utils.h
index 73f1ff9..c73e411 100644
--- a/sns/cm/cm_utils.h
+++ b/sns/cm/cm_utils.h
@@ -179,16 +179,6 @@ M0_INTERNAL bool m0_sns_cm_ag_local_is_done(const struct m0_cm_aggr_group *ag);
 M0_INTERNAL bool
 m0_sns_cm_ag_accumulator_is_full(const struct m0_sns_cm_ag *sag, int acc_idx);
 
-M0_INTERNAL int
-m0_sns_cm_file_attr_fetch_async(struct m0_cm *cm,
-				struct m0_fid *gfid,
-				struct m0_cob_attr *out_attr,
-				int *out_rc);
-M0_INTERNAL int
-m0_sns_cm_file_layout_fetch_async(struct m0_cm *cm,
-				  uint64_t lid,
-				  struct m0_pdclust_layout **out_layout,
-				  int *out_rc);
 /** @} endgroup SNSCM */
 
 /* __MERO_SNS_CM_UTILS_H__ */
-- 
1.8.3.2

