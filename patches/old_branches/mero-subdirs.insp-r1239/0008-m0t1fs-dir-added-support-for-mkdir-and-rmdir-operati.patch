From 0b8aef3ce20f92edda59f60f59ab22ec8040ff5c Mon Sep 17 00:00:00 2001
From: Alexander Gattin <alexander_gattin@xyratex.com>
Date: Sat, 9 Feb 2013 23:16:44 +0200
Subject: [PATCH 08/25] m0t1fs/dir: added support for mkdir and rmdir
 operations

* properly retabulated all m0t1fs/linux_kernel/dir.c file
* changed copyright to 2013
* process S_ISDIR files differently from S_ISREG ones in m0t1fs_crate
* create files/dirs with current uid/gid instead of hardcoded 0/0 ownership,
  and take into account SGID flag on parent directory
* fill mo.mo_attr.ca_pfid with correct fid (fid of parent directory)
* implement m0t1fs_mkdir via m0t1fs_create
* implement m0t1fs_rmdir via m0t1fs_unlink
* replace inc_nlink() + mark_inode_dirty() with single
  inode_inc_link_count() call in m0t1fs_link()
---
 m0t1fs/linux_kernel/dir.c | 1438 +++++++++++++++++++++++----------------------
 1 file changed, 737 insertions(+), 701 deletions(-)

diff --git a/m0t1fs/linux_kernel/dir.c b/m0t1fs/linux_kernel/dir.c
index 36b9cad..90badb2 100644
--- a/m0t1fs/linux_kernel/dir.c
+++ b/m0t1fs/linux_kernel/dir.c
@@ -1,5 +1,5 @@
 /*
- * COPYRIGHT 2012 XYRATEX TECHNOLOGY LIMITED
+ * COPYRIGHT 2013 XYRATEX TECHNOLOGY LIMITED
  *
  * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
  * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
@@ -54,9 +54,12 @@ static int m0t1fs_unlink(struct inode *dir, struct dentry *dentry);
 static int m0t1fs_link(struct dentry *old, struct inode *dir,
 		       struct dentry *new);
 
+static int m0t1fs_mkdir(struct inode *dir, struct dentry *dentry, int mode);
+static int m0t1fs_rmdir(struct inode *dir, struct dentry *dentry);
+
 static int m0t1fs_component_objects_op(struct m0t1fs_inode *ci,
 				       int (*func)(struct m0t1fs_sb *csb,
-					           const struct m0_fid *cfid,
+						   const struct m0_fid *cfid,
 						   const struct m0_fid *gfid,
 						   uint32_t cob_idx));
 
@@ -87,7 +90,7 @@ const struct file_operations m0t1fs_dir_file_operations = {
 	.open    = m0t1fs_opendir,
 	.release = m0t1fs_releasedir,
 	.readdir = m0t1fs_readdir,
-	.fsync   = simple_fsync,	/* provided by linux kernel */
+	.fsync   = simple_fsync,        /* provided by linux kernel */
 	.llseek  = generic_file_llseek, /* provided by linux kernel */
 };
 
@@ -96,46 +99,48 @@ const struct inode_operations m0t1fs_dir_inode_operations = {
 	.lookup  = m0t1fs_lookup,
 	.unlink  = m0t1fs_unlink,
 	.link    = m0t1fs_link,
-        .setattr = m0t1fs_setattr,
-        .getattr = m0t1fs_getattr
+	.mkdir   = m0t1fs_mkdir,
+	.rmdir   = m0t1fs_rmdir,
+	.setattr = m0t1fs_setattr,
+	.getattr = m0t1fs_getattr
 };
 
 static int name_mem2wire(struct m0_fop_str *tgt,
-                         const struct m0_buf *name)
+			 const struct m0_buf *name)
 {
-        tgt->s_buf = m0_alloc(name->b_nob);
-        if (tgt->s_buf == NULL)
-                return -ENOMEM;
-        memcpy(tgt->s_buf, name->b_addr, (int)name->b_nob);
-        tgt->s_len = name->b_nob;
-        return 0;
+	tgt->s_buf = m0_alloc(name->b_nob);
+	if (tgt->s_buf == NULL)
+		return -ENOMEM;
+	memcpy(tgt->s_buf, name->b_addr, (int)name->b_nob);
+	tgt->s_len = name->b_nob;
+	return 0;
 }
 
 static void body_mem2wire(struct m0_fop_cob *body,
-                          const struct m0_cob_attr *attr,
-                          int valid)
+			  const struct m0_cob_attr *attr,
+			  int valid)
 {
-        if (valid & M0_COB_ATIME)
-                body->b_atime = attr->ca_atime;
-        if (valid & M0_COB_CTIME)
-                body->b_ctime = attr->ca_ctime;
-        if (valid & M0_COB_MTIME)
-                body->b_mtime = attr->ca_mtime;
-        if (valid & M0_COB_BLOCKS)
-                body->b_blocks = attr->ca_blocks;
-        if (valid & M0_COB_SIZE)
-                body->b_size = attr->ca_size;
-        if (valid & M0_COB_MODE)
-                body->b_mode = attr->ca_mode;
-        if (valid & M0_COB_UID)
-                body->b_uid = attr->ca_uid;
-        if (valid & M0_COB_GID)
-                body->b_gid = attr->ca_gid;
-        if (valid & M0_COB_BLOCKS)
-                body->b_blocks = attr->ca_blocks;
-        if (valid & M0_COB_NLINK)
-                body->b_nlink = attr->ca_nlink;
-        body->b_valid = valid;
+	if (valid & M0_COB_ATIME)
+		body->b_atime = attr->ca_atime;
+	if (valid & M0_COB_CTIME)
+		body->b_ctime = attr->ca_ctime;
+	if (valid & M0_COB_MTIME)
+		body->b_mtime = attr->ca_mtime;
+	if (valid & M0_COB_BLOCKS)
+		body->b_blocks = attr->ca_blocks;
+	if (valid & M0_COB_SIZE)
+		body->b_size = attr->ca_size;
+	if (valid & M0_COB_MODE)
+		body->b_mode = attr->ca_mode;
+	if (valid & M0_COB_UID)
+		body->b_uid = attr->ca_uid;
+	if (valid & M0_COB_GID)
+		body->b_gid = attr->ca_gid;
+	if (valid & M0_COB_BLOCKS)
+		body->b_blocks = attr->ca_blocks;
+	if (valid & M0_COB_NLINK)
+		body->b_nlink = attr->ca_nlink;
+	body->b_valid = valid;
 }
 
 
@@ -152,15 +157,15 @@ static struct m0_fid m0t1fs_fid_alloc(struct m0t1fs_sb *csb)
 	struct m0_fid fid;
 
 	M0_PRE(m0t1fs_fs_is_locked(csb));
-        m0_fid_set(&fid, 0, csb->csb_next_key++);
+	m0_fid_set(&fid, 0, csb->csb_next_key++);
 
 	return fid;
 }
 
 static int m0t1fs_create(struct inode     *dir,
-                         struct dentry    *dentry,
-                         int               mode,
-                         struct nameidata *nd)
+			 struct dentry    *dentry,
+			 int               mode,
+			 struct nameidata *nd)
 {
 	struct super_block       *sb = dir->i_sb;
 	struct m0t1fs_sb         *csb = M0T1FS_SB(sb);
@@ -171,10 +176,10 @@ static int m0t1fs_create(struct inode     *dir,
 	int                       rc;
 
 	M0_ENTRY();
-	M0_LOG(M0_INFO, "Creating \"%s\"", dentry->d_name.name);
-
-	/* Flat file system. create allowed only on root directory */
-	M0_ASSERT(m0t1fs_inode_is_root(dir));
+	M0_LOG(M0_INFO, "Creating \"%s\" in pdir %lu[%llu:%llu]",
+	       dentry->d_name.name, dir->i_ino,
+	       M0T1FS_I(dir)->ci_fid.f_container,
+	       M0T1FS_I(dir)->ci_fid.f_key);
 
 	/* new_inode() will call m0t1fs_alloc_inode() using super_operations */
 	inode = new_inode(sb);
@@ -185,13 +190,23 @@ static int m0t1fs_create(struct inode     *dir,
 
 	m0t1fs_fs_lock(csb);
 
-	inode->i_uid    = 0;
-	inode->i_gid    = 0;
-	inode->i_mtime  = inode->i_atime = inode->i_ctime = CURRENT_TIME_SEC;
+	inode->i_mode = mode;
+	inode->i_uid = current_fsuid();
+	if (dir->i_mode & S_ISGID) {
+		inode->i_gid = dir->i_gid;
+		if (S_ISDIR(mode))
+			inode->i_mode |= S_ISGID;
+	} else
+		inode->i_gid = current_fsgid();
+	inode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME_SEC;
 	inode->i_blocks = 0;
-	inode->i_op     = &m0t1fs_reg_inode_operations;
-	inode->i_fop    = &m0t1fs_reg_file_operations;
-	inode->i_mode   = mode;
+	if (S_ISDIR(mode)) {
+		inode->i_op  = &m0t1fs_dir_inode_operations;
+		inode->i_fop = &m0t1fs_dir_file_operations;
+	} else {
+		inode->i_op  = &m0t1fs_reg_inode_operations;
+		inode->i_fop = &m0t1fs_reg_file_operations;
+	}
 
 	ci               = M0T1FS_I(inode);
 	ci->ci_fid       = m0t1fs_fid_alloc(csb);
@@ -204,26 +219,27 @@ static int m0t1fs_create(struct inode     *dir,
 	if (rc != 0)
 		goto out;
 
-        /** No hierarchy so far, all live in root */
-        M0_SET0(&mo);
-        mo.mo_attr.ca_uid       = inode->i_uid;
-        mo.mo_attr.ca_gid       = inode->i_gid;
-        mo.mo_attr.ca_atime     = inode->i_atime.tv_sec;
-        mo.mo_attr.ca_ctime     = inode->i_ctime.tv_sec;
-        mo.mo_attr.ca_mtime     = inode->i_mtime.tv_sec;
-        mo.mo_attr.ca_blocks    = inode->i_blocks;
-        mo.mo_attr.ca_mode      = inode->i_mode;
-        mo.mo_attr.ca_pfid      = csb->csb_root_fid;
-        mo.mo_attr.ca_tfid      = ci->ci_fid;
-        mo.mo_attr.ca_nlink     = inode->i_nlink;
-        mo.mo_attr.ca_flags     = (M0_COB_UID | M0_COB_GID | M0_COB_ATIME |
-                                   M0_COB_CTIME | M0_COB_MTIME | M0_COB_MODE |
-                                   M0_COB_BLOCKS | M0_COB_SIZE | M0_COB_NLINK);
-        m0_buf_init(&mo.mo_attr.ca_name, (char *)dentry->d_name.name, dentry->d_name.len);
-
-        rc = m0t1fs_mds_cob_create(csb, &mo, &rep);
-        if (rc != 0)
-                goto out;
+	/** No hierarchy so far, all live in root */
+	M0_SET0(&mo);
+	mo.mo_attr.ca_uid    = inode->i_uid;
+	mo.mo_attr.ca_gid    = inode->i_gid;
+	mo.mo_attr.ca_atime  = inode->i_atime.tv_sec;
+	mo.mo_attr.ca_ctime  = inode->i_ctime.tv_sec;
+	mo.mo_attr.ca_mtime  = inode->i_mtime.tv_sec;
+	mo.mo_attr.ca_blocks = inode->i_blocks;
+	mo.mo_attr.ca_mode   = inode->i_mode;
+	mo.mo_attr.ca_pfid   = M0T1FS_I(dir)->ci_fid;
+	mo.mo_attr.ca_tfid   = ci->ci_fid;
+	mo.mo_attr.ca_nlink  = inode->i_nlink;
+	mo.mo_attr.ca_flags  = (M0_COB_UID | M0_COB_GID | M0_COB_ATIME |
+				M0_COB_CTIME | M0_COB_MTIME | M0_COB_MODE |
+				M0_COB_BLOCKS | M0_COB_SIZE | M0_COB_NLINK);
+	m0_buf_init(&mo.mo_attr.ca_name, (char *)dentry->d_name.name,
+		    dentry->d_name.len);
+
+	rc = m0t1fs_mds_cob_create(csb, &mo, &rep);
+	if (rc != 0)
+		goto out;
 
 	rc = m0t1fs_component_objects_op(ci, m0t1fs_ios_cob_create);
 	if (rc != 0)
@@ -243,6 +259,11 @@ out:
 	return rc;
 }
 
+static int m0t1fs_mkdir(struct inode *dir, struct dentry *dentry, int mode)
+{
+	return m0t1fs_create(dir, dentry, mode | S_IFDIR, NULL);
+}
+
 static struct dentry *m0t1fs_lookup(struct inode     *dir,
 				    struct dentry    *dentry,
 				    struct nameidata *nd)
@@ -250,7 +271,7 @@ static struct dentry *m0t1fs_lookup(struct inode     *dir,
 	struct m0t1fs_sb         *csb;
 	struct m0t1fs_inode      *ci;
 	struct inode             *inode = NULL;
-        struct m0_fop_lookup_rep *rep = NULL;
+	struct m0_fop_lookup_rep *rep = NULL;
 	struct m0t1fs_mdop        mo;
 	int rc;
 
@@ -263,26 +284,26 @@ static struct dentry *m0t1fs_lookup(struct inode     *dir,
 	if (dentry->d_name.len > csb->csb_namelen) {
 		M0_LEAVE("ERR_PTR: %p", ERR_PTR(-ENAMETOOLONG));
 		return ERR_PTR(-ENAMETOOLONG);
-        }
+	}
 
 	M0_LOG(M0_DEBUG, "Name: \"%s\"", dentry->d_name.name);
 
 	m0t1fs_fs_lock(csb);
 
-        M0_SET0(&mo);
-        mo.mo_attr.ca_pfid = csb->csb_root_fid;
-        m0_buf_init(&mo.mo_attr.ca_name, (char *)dentry->d_name.name,
-                    dentry->d_name.len);
+	M0_SET0(&mo);
+	mo.mo_attr.ca_pfid = M0T1FS_I(dir)->ci_fid;
+	m0_buf_init(&mo.mo_attr.ca_name, (char *)dentry->d_name.name,
+		    dentry->d_name.len);
 
 	rc = m0t1fs_mds_cob_lookup(csb, &mo, &rep);
 	if (rc == 0) {
-                mo.mo_attr.ca_tfid = rep->l_body.b_tfid;
-                inode = m0t1fs_iget(dir->i_sb, &mo.mo_attr.ca_tfid, &rep->l_body);
-	        if (IS_ERR(inode)) {
-		        M0_LEAVE("ERROR: %p", ERR_CAST(inode));
-	                m0t1fs_fs_unlock(csb);
-		        return ERR_CAST(inode);
-	        }
+		mo.mo_attr.ca_tfid = rep->l_body.b_tfid;
+		inode = m0t1fs_iget(dir->i_sb, &mo.mo_attr.ca_tfid, &rep->l_body);
+		if (IS_ERR(inode)) {
+			M0_LEAVE("ERROR: %p", ERR_CAST(inode));
+			m0t1fs_fs_unlock(csb);
+			return ERR_CAST(inode);
+		}
 	}
 
 	m0t1fs_fs_unlock(csb);
@@ -293,437 +314,452 @@ static struct dentry *m0t1fs_lookup(struct inode     *dir,
 
 struct m0_dirent *dirent_next(struct m0_dirent *ent)
 {
-        return  ent->d_reclen > 0 ? (void *)ent + ent->d_reclen : NULL;
+	return ent->d_reclen > 0 ? (void *)ent + ent->d_reclen : NULL;
 }
 
 struct m0_dirent *dirent_first(struct m0_fop_readdir_rep *rep)
 {
-        struct m0_dirent *ent = (struct m0_dirent *)rep->r_buf.b_addr;
-        return ent->d_namelen > 0 ? ent : NULL;
+	struct m0_dirent *ent = (struct m0_dirent *)rep->r_buf.b_addr;
+	return ent->d_namelen > 0 ? ent : NULL;
 }
 
 static int m0t1fs_opendir(struct inode *inode, struct file *file)
 {
-        struct m0t1fs_filedata *fd;
+	struct m0t1fs_filedata *fd;
 	M0_ENTRY();
 
-        M0_ALLOC_PTR(fd);
-        if (fd == NULL)
-                return -ENOMEM;
-        file->private_data = fd;
-
-        /** Setup readdir initial pos with "." and max possible namelen. */
-        fd->fd_dirpos = m0_alloc(M0T1FS_SB(inode->i_sb)->csb_namelen);
-        if (fd->fd_dirpos == NULL) {
-                m0_free(fd);
-                return -ENOMEM;
-        }
-        m0_bitstring_copy(fd->fd_dirpos, ".", 1);
-        fd->fd_direof = 0;
-        return 0;
+	M0_ALLOC_PTR(fd);
+	if (fd == NULL)
+		return -ENOMEM;
+	file->private_data = fd;
+
+	/** Setup readdir initial pos with "." and max possible namelen. */
+	fd->fd_dirpos = m0_alloc(M0T1FS_SB(inode->i_sb)->csb_namelen);
+	if (fd->fd_dirpos == NULL) {
+		m0_free(fd);
+		return -ENOMEM;
+	}
+	m0_bitstring_copy(fd->fd_dirpos, ".", 1);
+	fd->fd_direof = 0;
+	return 0;
 }
 
 static int m0t1fs_releasedir(struct inode *inode, struct file *file)
 {
-        struct m0t1fs_filedata *fd = file->private_data;
+	struct m0t1fs_filedata *fd = file->private_data;
 	M0_ENTRY();
 
-        m0_free(fd->fd_dirpos);
-        m0_free(file->private_data);
-        file->private_data = NULL;
-        return 0;
+	m0_free(fd->fd_dirpos);
+	m0_free(file->private_data);
+	file->private_data = NULL;
+	return 0;
 }
 
 static int m0t1fs_readdir(struct file *f,
-                          void        *buf,
-                          filldir_t    filldir)
+			  void        *buf,
+			  filldir_t    filldir)
 {
-        struct m0t1fs_inode             *ci;
-        struct m0t1fs_mdop               mo;
-        struct m0t1fs_sb                *csb;
-        struct m0_fop_readdir_rep       *rep;
-        struct dentry                   *dentry;
-        struct inode                    *dir;
-        struct m0_dirent                *ent;
-        struct m0t1fs_filedata          *fd;
-        int                              type;
-        ino_t                            ino;
-        int                              i;
-        int                              rc;
-        int                              over;
-
-        M0_ENTRY();
-
-        dentry = f->f_path.dentry;
-        dir    = dentry->d_inode;
-        ci     = M0T1FS_I(dir);
-        csb    = M0T1FS_SB(dir->i_sb);
-        i      = f->f_pos;
-
-        fd = f->private_data;
-        if (fd->fd_direof) {
-                rc = 0;
-                goto out;
-        }
-
-        M0_SET0(&mo);
-        /**
-           In case that readdir will be interrupted by enomem situation (filldir fails)
-           on big dir and finishes before eof is reached, it has chance to start from
-           there. This way f->f_pos and string readdir pos are in sync.
-         */
-        m0_buf_init(&mo.mo_attr.ca_name, m0_bitstring_buf_get(fd->fd_dirpos),
-                    m0_bitstring_len_get(fd->fd_dirpos));
-        mo.mo_attr.ca_tfid = ci->ci_fid;
-
-        m0t1fs_fs_lock(csb);
-
-        do {
-                M0_LOG(M0_DEBUG, "readdir from position \"%*s\"",
-                       (int)mo.mo_attr.ca_name.b_nob,
-                       (char *)mo.mo_attr.ca_name.b_addr);
-
-                rc = m0t1fs_mds_cob_readdir(csb, &mo, &rep);
-                if (rc < 0) {
-                        M0_LOG(M0_ERROR,
-                               "Failed to read dir from pos \"%*s\". Error %d",
-                               (int)mo.mo_attr.ca_name.b_nob,
-                               (char *)mo.mo_attr.ca_name.b_addr, rc);
-                        goto out;
-                }
-
-                for (ent = dirent_first(rep); ent != NULL; ent = dirent_next(ent)) {
-                        if (ent->d_namelen == 1 &&
-                            memcmp(ent->d_name, ".", 1) == 0) {
-                                ino = dir->i_ino;
-                                type = DT_DIR;
-                        } else if (ent->d_namelen == 2 &&
-                                   memcmp(ent->d_name, "..", 2) == 0) {
-                                ino = parent_ino(dentry);
-                                type = DT_DIR;
-                        } else {
-                                /**
-                                   TODO: Entry type is hardcoded to regular
-                                   files, should be fixed later.
-                                 */
-                                ino = ++i;
-                                type = DT_REG;
-                        }
-
-                        M0_LOG(M0_DEBUG, "filled off %lu ino %lu name \"%*s\"",
-                               (unsigned long)f->f_pos, (unsigned long)ino,
-                               ent->d_namelen, (char *)ent->d_name);
-
-                        over = filldir(buf, ent->d_name, ent->d_namelen,
-                                       f->f_pos, ino, type);
-                        if (over) {
-                                rc = 0;
-                                goto out;
-                        }
-                        f->f_pos++;
-                }
-                m0_bitstring_copy(fd->fd_dirpos, rep->r_end.s_buf, rep->r_end.s_len);
-                m0_buf_init(&mo.mo_attr.ca_name, m0_bitstring_buf_get(fd->fd_dirpos),
-                            m0_bitstring_len_get(fd->fd_dirpos));
-
-                M0_LOG(M0_DEBUG, "set position to \"%*s\" rc == %d",
-                       (int)mo.mo_attr.ca_name.b_nob,
-                       (char *)mo.mo_attr.ca_name.b_addr, rc);
-                /**
-                   Return codes for m0t1fs_mds_cob_readdir() are the following:
-                   - <0 - some error occured;
-                   - >0 - EOF signaled by mdservice, some number of entries available;
-                   -  0 - no error, some number of entries is sent by mdservice.
-                 */
-        } while (rc == 0);
-
-        /**
-           EOF detected, let's set return code to 0 to make vfs happy.
-         */
-        fd->fd_direof = 1;
-        rc = 0;
+	struct m0t1fs_inode             *ci;
+	struct m0t1fs_mdop               mo;
+	struct m0t1fs_sb                *csb;
+	struct m0_fop_readdir_rep       *rep;
+	struct dentry                   *dentry;
+	struct inode                    *dir;
+	struct m0_dirent                *ent;
+	struct m0t1fs_filedata          *fd;
+	int                              type;
+	ino_t                            ino;
+	int                              i;
+	int                              rc;
+	int                              over;
+
+	M0_ENTRY();
+
+	dentry = f->f_path.dentry;
+	dir    = dentry->d_inode;
+	ci     = M0T1FS_I(dir);
+	csb    = M0T1FS_SB(dir->i_sb);
+	i      = f->f_pos;
+
+	fd = f->private_data;
+	if (fd->fd_direof) {
+		rc = 0;
+		goto out;
+	}
+
+	M0_SET0(&mo);
+	/**
+	   In case that readdir will be interrupted by enomem situation (filldir fails)
+	   on big dir and finishes before eof is reached, it has chance to start from
+	   there. This way f->f_pos and string readdir pos are in sync.
+	 */
+	m0_buf_init(&mo.mo_attr.ca_name, m0_bitstring_buf_get(fd->fd_dirpos),
+		    m0_bitstring_len_get(fd->fd_dirpos));
+	mo.mo_attr.ca_tfid = ci->ci_fid;
+
+	m0t1fs_fs_lock(csb);
+
+	do {
+		M0_LOG(M0_DEBUG, "readdir from position \"%*s\"",
+		       (int)mo.mo_attr.ca_name.b_nob,
+		       (char *)mo.mo_attr.ca_name.b_addr);
+
+		rc = m0t1fs_mds_cob_readdir(csb, &mo, &rep);
+		if (rc < 0) {
+			M0_LOG(M0_ERROR,
+			       "Failed to read dir from pos \"%*s\". Error %d",
+			       (int)mo.mo_attr.ca_name.b_nob,
+			       (char *)mo.mo_attr.ca_name.b_addr, rc);
+			goto out;
+		}
+
+		for (ent = dirent_first(rep); ent != NULL; ent = dirent_next(ent)) {
+			if (ent->d_namelen == 1 &&
+			    memcmp(ent->d_name, ".", 1) == 0) {
+				ino = dir->i_ino;
+				type = DT_DIR;
+			} else if (ent->d_namelen == 2 &&
+				   memcmp(ent->d_name, "..", 2) == 0) {
+				ino = parent_ino(dentry);
+				type = DT_DIR;
+			} else {
+				/**
+				   TODO: Entry type is hardcoded to regular
+				   files, should be fixed later.
+				 */
+				ino = ++i;
+				type = DT_REG;
+			}
+
+			M0_LOG(M0_DEBUG, "filled off %lu ino %lu name \"%*s\"",
+			       (unsigned long)f->f_pos, (unsigned long)ino,
+			       ent->d_namelen, (char *)ent->d_name);
+
+			over = filldir(buf, ent->d_name, ent->d_namelen,
+				       f->f_pos, ino, type);
+			if (over) {
+				rc = 0;
+				goto out;
+			}
+			f->f_pos++;
+		}
+		m0_bitstring_copy(fd->fd_dirpos, rep->r_end.s_buf, rep->r_end.s_len);
+		m0_buf_init(&mo.mo_attr.ca_name, m0_bitstring_buf_get(fd->fd_dirpos),
+			    m0_bitstring_len_get(fd->fd_dirpos));
+
+		M0_LOG(M0_DEBUG, "set position to \"%*s\" rc == %d",
+		       (int)mo.mo_attr.ca_name.b_nob,
+		       (char *)mo.mo_attr.ca_name.b_addr, rc);
+		/**
+		   Return codes for m0t1fs_mds_cob_readdir() are the following:
+		   - <0 - some error occured;
+		   - >0 - EOF signaled by mdservice, some number of entries available;
+		   -  0 - no error, some number of entries is sent by mdservice.
+		 */
+	} while (rc == 0);
+
+	/**
+	   EOF detected, let's set return code to 0 to make vfs happy.
+	 */
+	fd->fd_direof = 1;
+	rc = 0;
 out:
-        m0t1fs_fs_unlock(csb);
-        M0_LEAVE("rc: %d", rc);
-        return rc;
+	m0t1fs_fs_unlock(csb);
+	M0_LEAVE("rc: %d", rc);
+	return rc;
 }
 
 static int m0t1fs_link(struct dentry *old, struct inode *dir,
-                       struct dentry *new)
+		       struct dentry *new)
 {
-        struct m0t1fs_sb                *csb;
-        struct m0_fop_link_rep          *link_rep;
-        struct m0t1fs_mdop               mo;
-        struct m0t1fs_inode             *ci;
-        struct inode                    *inode;
-        struct timespec                  now;
-        int                              rc;
-
-        inode = old->d_inode;
-        ci    = M0T1FS_I(inode);
-        csb   = M0T1FS_SB(inode->i_sb);
-
-        m0t1fs_fs_lock(csb);
-
-        M0_SET0(&mo);
-        now = CURRENT_TIME_SEC;
-        mo.mo_attr.ca_pfid = csb->csb_root_fid;
-        mo.mo_attr.ca_tfid  = ci->ci_fid;
-        mo.mo_attr.ca_nlink = inode->i_nlink + 1;
-        mo.mo_attr.ca_ctime = now.tv_sec;
-        mo.mo_attr.ca_flags = (M0_COB_CTIME | M0_COB_NLINK);
-        m0_buf_init(&mo.mo_attr.ca_name, (char *)new->d_name.name, new->d_name.len);
-
-        rc = m0t1fs_mds_cob_link(csb, &mo, &link_rep);
-        if (rc != 0) {
-                M0_LOG(M0_ERROR, "mdservive link fop failed: %d", rc);
-                goto out;
-        }
-
-        inc_nlink(inode);
-        inode->i_ctime = now;
-        mark_inode_dirty(inode);
-        atomic_inc(&inode->i_count);
-        d_instantiate(new, inode);
+	struct m0t1fs_sb                *csb;
+	struct m0_fop_link_rep          *link_rep;
+	struct m0t1fs_mdop               mo;
+	struct m0t1fs_inode             *ci;
+	struct inode                    *inode;
+	struct timespec                  now;
+	int                              rc;
+
+	inode = old->d_inode;
+	ci    = M0T1FS_I(inode);
+	csb   = M0T1FS_SB(inode->i_sb);
+
+	m0t1fs_fs_lock(csb);
+
+	M0_SET0(&mo);
+	now = CURRENT_TIME_SEC;
+	mo.mo_attr.ca_pfid = M0T1FS_I(dir)->ci_fid;
+	mo.mo_attr.ca_tfid  = ci->ci_fid;
+	mo.mo_attr.ca_nlink = inode->i_nlink + 1;
+	mo.mo_attr.ca_ctime = now.tv_sec;
+	mo.mo_attr.ca_flags = (M0_COB_CTIME | M0_COB_NLINK);
+	m0_buf_init(&mo.mo_attr.ca_name, (char *)new->d_name.name,
+		    new->d_name.len);
+
+	rc = m0t1fs_mds_cob_link(csb, &mo, &link_rep);
+	if (rc != 0) {
+		M0_LOG(M0_ERROR, "mdservive link fop failed: %d", rc);
+		goto out;
+	}
+
+	inode_inc_link_count(inode);
+	inode->i_ctime = now;
+	atomic_inc(&inode->i_count);
+	d_instantiate(new, inode);
 
 out:
-        m0t1fs_fs_unlock(csb);
-        M0_LEAVE("rc: %d", rc);
-        return rc;
+	m0t1fs_fs_unlock(csb);
+	M0_LEAVE("rc: %d", rc);
+	return rc;
 }
 
 static int m0t1fs_unlink(struct inode *dir, struct dentry *dentry)
 {
-        struct m0_fop_lookup_rep        *lookup_rep;
-        struct m0_fop_unlink_rep        *unlink_rep;
-        struct m0_fop_setattr_rep       *setattr_rep;
-        struct m0t1fs_sb                *csb;
-        struct inode                    *inode;
-        struct m0t1fs_inode             *ci;
-        struct m0t1fs_mdop               mo;
-        struct timespec                  now;
-        int                              rc;
-
-        M0_ENTRY();
-
-        M0_LOG(M0_INFO, "Name: \"%s\"", dentry->d_name.name);
-
-        inode = dentry->d_inode;
-        csb   = M0T1FS_SB(inode->i_sb);
-        ci    = M0T1FS_I(inode);
-
-        m0t1fs_fs_lock(csb);
-
-        M0_SET0(&mo);
-        now = CURRENT_TIME_SEC;
-        mo.mo_attr.ca_pfid = csb->csb_root_fid;
-        mo.mo_attr.ca_tfid = ci->ci_fid;
-        mo.mo_attr.ca_nlink = inode->i_nlink - 1;
-        mo.mo_attr.ca_ctime = now.tv_sec;
-        mo.mo_attr.ca_flags = (M0_COB_NLINK | M0_COB_CTIME);
-        m0_buf_init(&mo.mo_attr.ca_name,
-                    (char *)dentry->d_name.name, dentry->d_name.len);
-
-        rc = m0t1fs_mds_cob_lookup(csb, &mo, &lookup_rep);
-        if (rc != 0)
-                goto out;
-
-        rc = m0t1fs_mds_cob_unlink(csb, &mo, &unlink_rep);
-        if (rc != 0) {
-                M0_LOG(M0_ERROR, "mdservive unlink fop failed: %d", rc);
-                goto out;
-        }
-
-        if (mo.mo_attr.ca_nlink == 0) {
-                rc = m0t1fs_component_objects_op(ci, m0t1fs_ios_cob_delete);
-                if (rc != 0) {
-                        M0_LOG(M0_ERROR, "ioservice delete fop failed: %d", rc);
-                        goto out;
-                }
-        }
-
-        /** Update ctime and mtime on parent dir. */
-        M0_SET0(&mo);
-        mo.mo_attr.ca_tfid  = csb->csb_root_fid;
-        mo.mo_attr.ca_ctime = now.tv_sec;
-        mo.mo_attr.ca_mtime = now.tv_sec;
-        mo.mo_attr.ca_flags = (M0_COB_CTIME | M0_COB_MTIME);
-
-        rc = m0t1fs_mds_cob_setattr(csb, &mo, &setattr_rep);
-        if (rc != 0) {
-                M0_LOG(M0_ERROR, "Setattr on parent dir failed with %d", rc);
-                goto out;
-        }
-
-        inode->i_ctime = dir->i_ctime = dir->i_mtime = now;
-        inode_dec_link_count(inode);
+	struct m0_fop_lookup_rep        *lookup_rep;
+	struct m0_fop_unlink_rep        *unlink_rep;
+	struct m0_fop_setattr_rep       *setattr_rep;
+	struct m0t1fs_sb                *csb;
+	struct inode                    *inode;
+	struct m0t1fs_inode             *ci;
+	struct m0t1fs_mdop               mo;
+	struct timespec                  now;
+	int                              rc;
+
+	M0_ENTRY();
+
+	M0_LOG(M0_INFO, "Name: \"%s\"", dentry->d_name.name);
+
+	inode = dentry->d_inode;
+	csb   = M0T1FS_SB(inode->i_sb);
+	ci    = M0T1FS_I(inode);
+
+	m0t1fs_fs_lock(csb);
+
+	M0_SET0(&mo);
+	now = CURRENT_TIME_SEC;
+	mo.mo_attr.ca_pfid = M0T1FS_I(dir)->ci_fid;
+	mo.mo_attr.ca_tfid = ci->ci_fid;
+	mo.mo_attr.ca_nlink = inode->i_nlink - 1;
+	mo.mo_attr.ca_ctime = now.tv_sec;
+	mo.mo_attr.ca_flags = (M0_COB_NLINK | M0_COB_CTIME);
+	m0_buf_init(&mo.mo_attr.ca_name,
+		    (char *)dentry->d_name.name, dentry->d_name.len);
+
+	rc = m0t1fs_mds_cob_lookup(csb, &mo, &lookup_rep);
+	if (rc != 0)
+		goto out;
+
+	rc = m0t1fs_mds_cob_unlink(csb, &mo, &unlink_rep);
+	if (rc != 0) {
+		M0_LOG(M0_ERROR, "mdservive unlink fop failed: %d", rc);
+		goto out;
+	}
+
+	if (mo.mo_attr.ca_nlink == 0) {
+		rc = m0t1fs_component_objects_op(ci, m0t1fs_ios_cob_delete);
+		if (rc != 0) {
+			M0_LOG(M0_ERROR, "ioservice delete fop failed: %d", rc);
+			goto out;
+		}
+	}
+
+	/** Update ctime and mtime on parent dir. */
+	M0_SET0(&mo);
+	mo.mo_attr.ca_tfid  = M0T1FS_I(dir)->ci_fid;
+	mo.mo_attr.ca_ctime = now.tv_sec;
+	mo.mo_attr.ca_mtime = now.tv_sec;
+	mo.mo_attr.ca_flags = (M0_COB_CTIME | M0_COB_MTIME);
+
+	rc = m0t1fs_mds_cob_setattr(csb, &mo, &setattr_rep);
+	if (rc != 0) {
+		M0_LOG(M0_ERROR, "Setattr on parent dir failed with %d", rc);
+		goto out;
+	}
+
+	inode->i_ctime = dir->i_ctime = dir->i_mtime = now;
+	inode_dec_link_count(inode);
 out:
-        m0t1fs_fs_unlock(csb);
-        M0_LEAVE("rc: %d", rc);
-        return rc;
+	m0t1fs_fs_unlock(csb);
+	M0_LEAVE("rc: %d", rc);
+	return rc;
+}
+
+static int m0t1fs_rmdir(struct inode *dir, struct dentry *dentry)
+{
+	int rc;
+
+	M0_ENTRY();
+	rc = m0t1fs_unlink(dir, dentry);
+	if (!rc) {
+		inode_dec_link_count(dentry->d_inode);
+		drop_nlink(dir);
+	}
+	M0_LEAVE("rc: %d", rc);
+
+	return rc;
 }
 
 M0_INTERNAL int m0t1fs_getattr(struct vfsmount *mnt, struct dentry *dentry,
-                               struct kstat *stat)
+			       struct kstat *stat)
 {
-        struct m0_fop_getattr_rep       *getattr_rep;
-        struct m0t1fs_sb                *csb;
-        struct inode                    *inode;
-        struct m0t1fs_inode             *ci;
-        struct m0t1fs_mdop               mo;
-        int                              rc;
-
-        M0_ENTRY();
-
-        M0_LOG(M0_INFO, "Name: \"%s\"", dentry->d_name.name);
-
-        inode = dentry->d_inode;
-        csb   = M0T1FS_SB(inode->i_sb);
-        ci    = M0T1FS_I(inode);
-
-        m0t1fs_fs_lock(csb);
-
-        M0_SET0(&mo);
-        mo.mo_attr.ca_tfid  = ci->ci_fid;
-
-        /**
-           TODO: When we have dlm locking working, this will be changed to
-           revalidate inode with checking cached lock. If lock is cached
-           (not canceled), which means inode did not change, then we don't
-           have to do getattr and can just use @inode cached data.
-         */
-        rc = m0t1fs_mds_cob_getattr(csb, &mo, &getattr_rep);
-        if (rc != 0)
-                goto out;
-
-        /** Update inode fields with data from @getattr_rep. */
-        rc = m0t1fs_inode_update(inode, &getattr_rep->g_body);
-        if (rc != 0)
-                goto out;
-
-        /** Now its time to return inode stat data to user. */
-        stat->dev = inode->i_sb->s_dev;
-        stat->ino = inode->i_ino;
-        stat->mode = inode->i_mode;
-        stat->nlink = inode->i_nlink;
-        stat->uid = inode->i_uid;
-        stat->gid = inode->i_gid;
-        stat->rdev = inode->i_rdev;
-        stat->atime = inode->i_atime;
-        stat->mtime = inode->i_mtime;
-        stat->ctime = inode->i_ctime;
+	struct m0_fop_getattr_rep       *getattr_rep;
+	struct m0t1fs_sb                *csb;
+	struct inode                    *inode;
+	struct m0t1fs_inode             *ci;
+	struct m0t1fs_mdop               mo;
+	int                              rc;
+
+	M0_ENTRY();
+
+	M0_LOG(M0_INFO, "Name: \"%s\"", dentry->d_name.name);
+
+	inode = dentry->d_inode;
+	csb   = M0T1FS_SB(inode->i_sb);
+	ci    = M0T1FS_I(inode);
+
+	m0t1fs_fs_lock(csb);
+
+	M0_SET0(&mo);
+	mo.mo_attr.ca_tfid  = ci->ci_fid;
+
+	/**
+	   TODO: When we have dlm locking working, this will be changed to
+	   revalidate inode with checking cached lock. If lock is cached
+	   (not canceled), which means inode did not change, then we don't
+	   have to do getattr and can just use @inode cached data.
+	 */
+	rc = m0t1fs_mds_cob_getattr(csb, &mo, &getattr_rep);
+	if (rc != 0)
+		goto out;
+
+	/** Update inode fields with data from @getattr_rep. */
+	rc = m0t1fs_inode_update(inode, &getattr_rep->g_body);
+	if (rc != 0)
+		goto out;
+
+	/** Now its time to return inode stat data to user. */
+	stat->dev = inode->i_sb->s_dev;
+	stat->ino = inode->i_ino;
+	stat->mode = inode->i_mode;
+	stat->nlink = inode->i_nlink;
+	stat->uid = inode->i_uid;
+	stat->gid = inode->i_gid;
+	stat->rdev = inode->i_rdev;
+	stat->atime = inode->i_atime;
+	stat->mtime = inode->i_mtime;
+	stat->ctime = inode->i_ctime;
 #ifdef HAVE_INODE_BLKSIZE
-        stat->blksize = inode->i_blksize;
+	stat->blksize = inode->i_blksize;
 #else
-        stat->blksize = 1 << inode->i_blkbits;
+	stat->blksize = 1 << inode->i_blkbits;
 #endif
-        stat->size = i_size_read(inode);
-        stat->blocks = inode->i_blocks;
+	stat->size = i_size_read(inode);
+	stat->blocks = inode->i_blocks;
 out:
-        m0t1fs_fs_unlock(csb);
-        M0_LEAVE("rc: %d", rc);
-        return rc;
+	m0t1fs_fs_unlock(csb);
+	M0_LEAVE("rc: %d", rc);
+	return rc;
 }
 
 M0_INTERNAL int m0t1fs_size_update(struct inode *inode, uint64_t newsize)
 {
-        struct m0_fop_setattr_rep       *setattr_rep;
-        struct m0t1fs_sb                *csb;
-        struct m0t1fs_inode             *ci;
-        struct m0t1fs_mdop               mo;
-        int                              rc;
-
-        csb   = M0T1FS_SB(inode->i_sb);
-        ci    = M0T1FS_I(inode);
-
-        m0t1fs_fs_lock(csb);
-
-        M0_SET0(&mo);
-        mo.mo_attr.ca_tfid  = ci->ci_fid;
-        mo.mo_attr.ca_size = newsize;
-        mo.mo_attr.ca_flags |= M0_COB_SIZE;
-
-        rc = m0t1fs_mds_cob_setattr(csb, &mo, &setattr_rep);
-        if (rc != 0)
-                goto out;
-        inode->i_size = newsize;
+	struct m0_fop_setattr_rep       *setattr_rep;
+	struct m0t1fs_sb                *csb;
+	struct m0t1fs_inode             *ci;
+	struct m0t1fs_mdop               mo;
+	int                              rc;
+
+	csb   = M0T1FS_SB(inode->i_sb);
+	ci    = M0T1FS_I(inode);
+
+	m0t1fs_fs_lock(csb);
+
+	M0_SET0(&mo);
+	mo.mo_attr.ca_tfid  = ci->ci_fid;
+	mo.mo_attr.ca_size = newsize;
+	mo.mo_attr.ca_flags |= M0_COB_SIZE;
+
+	rc = m0t1fs_mds_cob_setattr(csb, &mo, &setattr_rep);
+	if (rc != 0)
+		goto out;
+	inode->i_size = newsize;
 out:
-        m0t1fs_fs_unlock(csb);
-        return rc;
+	m0t1fs_fs_unlock(csb);
+	return rc;
 }
 
 M0_INTERNAL int m0t1fs_setattr(struct dentry *dentry, struct iattr *attr)
 {
-        struct m0_fop_setattr_rep       *setattr_rep;
-        struct m0t1fs_sb                *csb;
-        struct inode                    *inode;
-        struct m0t1fs_inode             *ci;
-        struct m0t1fs_mdop               mo;
-        int                              rc;
-
-        M0_ENTRY();
-
-        M0_LOG(M0_INFO, "Name: \"%s\"", dentry->d_name.name);
-
-        inode = dentry->d_inode;
-        csb   = M0T1FS_SB(inode->i_sb);
-        ci    = M0T1FS_I(inode);
-
-        rc = inode_change_ok(inode, attr);
-        if (rc)
-                return rc;
-
-        m0t1fs_fs_lock(csb);
-
-        M0_SET0(&mo);
-        mo.mo_attr.ca_tfid  = ci->ci_fid;
-
-        if (attr->ia_valid & ATTR_CTIME) {
-                mo.mo_attr.ca_ctime = attr->ia_ctime.tv_sec;
-                mo.mo_attr.ca_flags |= M0_COB_CTIME;
-        }
-
-        if (attr->ia_valid & ATTR_MTIME) {
-                mo.mo_attr.ca_mtime = attr->ia_mtime.tv_sec;
-                mo.mo_attr.ca_flags |= M0_COB_MTIME;
-        }
-
-        if (attr->ia_valid & ATTR_ATIME) {
-                mo.mo_attr.ca_atime = attr->ia_atime.tv_sec;
-                mo.mo_attr.ca_flags |= M0_COB_ATIME;
-        }
-
-        if (attr->ia_valid & ATTR_SIZE) {
-                mo.mo_attr.ca_size = attr->ia_size;
-                mo.mo_attr.ca_flags |= M0_COB_SIZE;
-        }
-
-        if (attr->ia_valid & ATTR_MODE) {
-                mo.mo_attr.ca_mode = attr->ia_mode;
-                mo.mo_attr.ca_flags |= M0_COB_MODE;
-        }
-
-        if (attr->ia_valid & ATTR_UID) {
-                mo.mo_attr.ca_uid = attr->ia_uid;
-                mo.mo_attr.ca_flags |= M0_COB_UID;
-        }
-
-        if (attr->ia_valid & ATTR_GID) {
-                mo.mo_attr.ca_gid = attr->ia_gid;
-                mo.mo_attr.ca_flags |= M0_COB_GID;
-        }
-
-        rc = m0t1fs_mds_cob_setattr(csb, &mo, &setattr_rep);
-        if (rc != 0)
-                goto out;
-
-        rc = inode_setattr(inode, attr);
-        if (rc != 0)
-                goto out;
+	struct m0_fop_setattr_rep       *setattr_rep;
+	struct m0t1fs_sb                *csb;
+	struct inode                    *inode;
+	struct m0t1fs_inode             *ci;
+	struct m0t1fs_mdop               mo;
+	int                              rc;
+
+	M0_ENTRY();
+
+	M0_LOG(M0_INFO, "Name: \"%s\"", dentry->d_name.name);
+
+	inode = dentry->d_inode;
+	csb   = M0T1FS_SB(inode->i_sb);
+	ci    = M0T1FS_I(inode);
+
+	rc = inode_change_ok(inode, attr);
+	if (rc)
+		return rc;
+
+	m0t1fs_fs_lock(csb);
+
+	M0_SET0(&mo);
+	mo.mo_attr.ca_tfid  = ci->ci_fid;
+
+	if (attr->ia_valid & ATTR_CTIME) {
+		mo.mo_attr.ca_ctime = attr->ia_ctime.tv_sec;
+		mo.mo_attr.ca_flags |= M0_COB_CTIME;
+	}
+
+	if (attr->ia_valid & ATTR_MTIME) {
+		mo.mo_attr.ca_mtime = attr->ia_mtime.tv_sec;
+		mo.mo_attr.ca_flags |= M0_COB_MTIME;
+	}
+
+	if (attr->ia_valid & ATTR_ATIME) {
+		mo.mo_attr.ca_atime = attr->ia_atime.tv_sec;
+		mo.mo_attr.ca_flags |= M0_COB_ATIME;
+	}
+
+	if (attr->ia_valid & ATTR_SIZE) {
+		mo.mo_attr.ca_size = attr->ia_size;
+		mo.mo_attr.ca_flags |= M0_COB_SIZE;
+	}
+
+	if (attr->ia_valid & ATTR_MODE) {
+		mo.mo_attr.ca_mode = attr->ia_mode;
+		mo.mo_attr.ca_flags |= M0_COB_MODE;
+	}
+
+	if (attr->ia_valid & ATTR_UID) {
+		mo.mo_attr.ca_uid = attr->ia_uid;
+		mo.mo_attr.ca_flags |= M0_COB_UID;
+	}
+
+	if (attr->ia_valid & ATTR_GID) {
+		mo.mo_attr.ca_gid = attr->ia_gid;
+		mo.mo_attr.ca_flags |= M0_COB_GID;
+	}
+
+	rc = m0t1fs_mds_cob_setattr(csb, &mo, &setattr_rep);
+	if (rc != 0)
+		goto out;
+
+	rc = inode_setattr(inode, attr);
+	if (rc != 0)
+		goto out;
 out:
-        m0t1fs_fs_unlock(csb);
-        M0_LEAVE("rc: %d", rc);
-        return rc;
+	m0t1fs_fs_unlock(csb);
+	M0_LEAVE("rc: %d", rc);
+	return rc;
 }
 
 /**
@@ -752,21 +788,21 @@ M0_INTERNAL struct m0_fid m0t1fs_ios_cob_fid(const struct m0t1fs_inode *ci,
 }
 
 static uint32_t m0t1fs_ios_cob_idx(const struct m0t1fs_inode *ci,
-                                   const struct m0_fid *gfid,
-                                   const struct m0_fid *cfid)
+				   const struct m0_fid *gfid,
+				   const struct m0_fid *cfid)
 {
-        M0_PRE(ci->ci_layout_instance != NULL);
-        M0_PRE(gfid != NULL);
-        M0_PRE(cfid != NULL);
+	M0_PRE(ci->ci_layout_instance != NULL);
+	M0_PRE(gfid != NULL);
+	M0_PRE(cfid != NULL);
 
-        return m0_layout_enum_find(m0_layout_instance_to_enum(
-                                   ci->ci_layout_instance), gfid, cfid);
+	return m0_layout_enum_find(m0_layout_instance_to_enum(
+				   ci->ci_layout_instance), gfid, cfid);
 
 }
 
 static int m0t1fs_component_objects_op(struct m0t1fs_inode *ci,
 				       int (*func)(struct m0t1fs_sb *csb,
-					           const struct m0_fid *cfid,
+						   const struct m0_fid *cfid,
 						   const struct m0_fid *gfid,
 						   uint32_t cob_idx))
 {
@@ -810,278 +846,278 @@ out:
 }
 
 static int m0t1fs_mds_cob_fop_populate(const struct m0t1fs_mdop *mo,
-                                       struct m0_fop            *fop)
+				       struct m0_fop            *fop)
 {
-        struct m0_fop_create    *create;
-        struct m0_fop_unlink    *unlink;
-        struct m0_fop_link      *link;
-        struct m0_fop_lookup    *lookup;
-        struct m0_fop_getattr   *getattr;
-        struct m0_fop_statfs    *statfs;
-        struct m0_fop_setattr   *setattr;
-        struct m0_fop_readdir   *readdir;
-        struct m0_fop_cob       *req;
-        int                      rc = 0;
-
-        switch (m0_fop_opcode(fop)) {
-        case M0_MDSERVICE_CREATE_OPCODE:
-                create = m0_fop_data(fop);
-                req = &create->c_body;
-
-                req->b_pfid = mo->mo_attr.ca_pfid;
-                req->b_tfid = mo->mo_attr.ca_tfid;
-                body_mem2wire(req, &mo->mo_attr, mo->mo_attr.ca_flags);
-                rc = name_mem2wire(&create->c_name, &mo->mo_attr.ca_name);
-                break;
-        case M0_MDSERVICE_LINK_OPCODE:
-                link = m0_fop_data(fop);
-                req = &link->l_body;
-
-                req->b_pfid = mo->mo_attr.ca_pfid;
-                req->b_tfid = mo->mo_attr.ca_tfid;
-                body_mem2wire(req, &mo->mo_attr, mo->mo_attr.ca_flags);
-                rc = name_mem2wire(&link->l_name, &mo->mo_attr.ca_name);
-                break;
-        case M0_MDSERVICE_UNLINK_OPCODE:
-                unlink = m0_fop_data(fop);
-                req = &unlink->u_body;
-
-                req->b_pfid = mo->mo_attr.ca_pfid;
-                req->b_tfid = mo->mo_attr.ca_tfid;
-                body_mem2wire(req, &mo->mo_attr, mo->mo_attr.ca_flags);
-                rc = name_mem2wire(&unlink->u_name, &mo->mo_attr.ca_name);
-                break;
-        case M0_MDSERVICE_STATFS_OPCODE:
-                statfs = m0_fop_data(fop);
-                statfs->f_flags = 0;
-                break;
-        case M0_MDSERVICE_LOOKUP_OPCODE:
-                lookup = m0_fop_data(fop);
-                req = &lookup->l_body;
-
-                req->b_pfid = mo->mo_attr.ca_pfid;
-                rc = name_mem2wire(&lookup->l_name, &mo->mo_attr.ca_name);
-                break;
-        case M0_MDSERVICE_GETATTR_OPCODE:
-                getattr = m0_fop_data(fop);
-                req = &getattr->g_body;
-
-                req->b_tfid = mo->mo_attr.ca_tfid;
-                break;
-        case M0_MDSERVICE_SETATTR_OPCODE:
-                setattr = m0_fop_data(fop);
-                req = &setattr->s_body;
-
-                req->b_tfid = mo->mo_attr.ca_tfid;
-                body_mem2wire(req, &mo->mo_attr, mo->mo_attr.ca_flags);
-                break;
-        case M0_MDSERVICE_READDIR_OPCODE:
-                readdir = m0_fop_data(fop);
-                req = &readdir->r_body;
-
-                req->b_tfid = mo->mo_attr.ca_tfid;
-                rc = name_mem2wire(&readdir->r_pos, &mo->mo_attr.ca_name);
-                break;
-        default:
-                rc = -ENOSYS;
-                break;
-        }
-
-        return rc;
+	struct m0_fop_create    *create;
+	struct m0_fop_unlink    *unlink;
+	struct m0_fop_link      *link;
+	struct m0_fop_lookup    *lookup;
+	struct m0_fop_getattr   *getattr;
+	struct m0_fop_statfs    *statfs;
+	struct m0_fop_setattr   *setattr;
+	struct m0_fop_readdir   *readdir;
+	struct m0_fop_cob       *req;
+	int                      rc = 0;
+
+	switch (m0_fop_opcode(fop)) {
+	case M0_MDSERVICE_CREATE_OPCODE:
+		create = m0_fop_data(fop);
+		req = &create->c_body;
+
+		req->b_pfid = mo->mo_attr.ca_pfid;
+		req->b_tfid = mo->mo_attr.ca_tfid;
+		body_mem2wire(req, &mo->mo_attr, mo->mo_attr.ca_flags);
+		rc = name_mem2wire(&create->c_name, &mo->mo_attr.ca_name);
+		break;
+	case M0_MDSERVICE_LINK_OPCODE:
+		link = m0_fop_data(fop);
+		req = &link->l_body;
+
+		req->b_pfid = mo->mo_attr.ca_pfid;
+		req->b_tfid = mo->mo_attr.ca_tfid;
+		body_mem2wire(req, &mo->mo_attr, mo->mo_attr.ca_flags);
+		rc = name_mem2wire(&link->l_name, &mo->mo_attr.ca_name);
+		break;
+	case M0_MDSERVICE_UNLINK_OPCODE:
+		unlink = m0_fop_data(fop);
+		req = &unlink->u_body;
+
+		req->b_pfid = mo->mo_attr.ca_pfid;
+		req->b_tfid = mo->mo_attr.ca_tfid;
+		body_mem2wire(req, &mo->mo_attr, mo->mo_attr.ca_flags);
+		rc = name_mem2wire(&unlink->u_name, &mo->mo_attr.ca_name);
+		break;
+	case M0_MDSERVICE_STATFS_OPCODE:
+		statfs = m0_fop_data(fop);
+		statfs->f_flags = 0;
+		break;
+	case M0_MDSERVICE_LOOKUP_OPCODE:
+		lookup = m0_fop_data(fop);
+		req = &lookup->l_body;
+
+		req->b_pfid = mo->mo_attr.ca_pfid;
+		rc = name_mem2wire(&lookup->l_name, &mo->mo_attr.ca_name);
+		break;
+	case M0_MDSERVICE_GETATTR_OPCODE:
+		getattr = m0_fop_data(fop);
+		req = &getattr->g_body;
+
+		req->b_tfid = mo->mo_attr.ca_tfid;
+		break;
+	case M0_MDSERVICE_SETATTR_OPCODE:
+		setattr = m0_fop_data(fop);
+		req = &setattr->s_body;
+
+		req->b_tfid = mo->mo_attr.ca_tfid;
+		body_mem2wire(req, &mo->mo_attr, mo->mo_attr.ca_flags);
+		break;
+	case M0_MDSERVICE_READDIR_OPCODE:
+		readdir = m0_fop_data(fop);
+		req = &readdir->r_body;
+
+		req->b_tfid = mo->mo_attr.ca_tfid;
+		rc = name_mem2wire(&readdir->r_pos, &mo->mo_attr.ca_name);
+		break;
+	default:
+		rc = -ENOSYS;
+		break;
+	}
+
+	return rc;
 }
 
 static int m0t1fs_mds_cob_op(struct m0t1fs_sb            *csb,
-                             const struct m0t1fs_mdop    *mo,
-                             struct m0_fop_type          *ftype,
-                             void                       **rep)
+			     const struct m0t1fs_mdop    *mo,
+			     struct m0_fop_type          *ftype,
+			     void                       **rep)
 {
-        int                          rc;
-        struct m0_fop               *fop;
-        struct m0_rpc_session       *session;
-        struct m0_fop_create_rep    *create_rep;
-        struct m0_fop_unlink_rep    *unlink_rep;
-        struct m0_fop_rename_rep    *rename_rep;
-        struct m0_fop_link_rep      *link_rep;
-        struct m0_fop_setattr_rep   *setattr_rep;
-        struct m0_fop_getattr_rep   *getattr_rep;
-        struct m0_fop_statfs_rep    *statfs_rep;
-        struct m0_fop_lookup_rep    *lookup_rep;
-        struct m0_fop_open_rep      *open_rep;
-        struct m0_fop_close_rep     *close_rep;
-        struct m0_fop_readdir_rep   *readdir_rep;
-
-        M0_PRE(ftype != NULL);
-
-        M0_ENTRY();
-
-        /**
-           TODO: This needs to be fixed later.
-
-           Container 0 and its session are currently reserved for mdservice.
-           We hardcoding its using here temporary because of the following:
-           - we can't use @mo->mo_attr.ca_pfid because it is set to root
-             fid, which has container != 0 and we cannot change it as it
-             will conflict with cob io objects in case they share the same
-             db;
-           - we can't use @mo->mo_attr.ca_tfid it is not always set, some ops
-             do not require it;
-           - using @ci is not an option as well as it is not always used.
-             For example, it is not available for lookup.
-         */
-        session = m0t1fs_container_id_to_session(csb, 0);
-        M0_ASSERT(session != NULL);
-
-        fop = m0_fop_alloc(ftype, NULL);
-        if (fop == NULL) {
-                rc = -ENOMEM;
-                M0_LOG(M0_ERROR, "m0_fop_alloc() failed with %d", rc);
-                goto out;
-        }
-
-        rc = m0t1fs_mds_cob_fop_populate(mo, fop);
-        if (rc != 0) {
-                M0_LOG(M0_ERROR,
-                       "m0t1fs_mds_cob_fop_populate() failed with %d", rc);
-                goto out;
-        }
-
-        M0_LOG(M0_DEBUG, "Send md operation %u to session %lu",
-                m0_fop_opcode(fop), (unsigned long)session->s_session_id);
+	int                          rc;
+	struct m0_fop               *fop;
+	struct m0_rpc_session       *session;
+	struct m0_fop_create_rep    *create_rep;
+	struct m0_fop_unlink_rep    *unlink_rep;
+	struct m0_fop_rename_rep    *rename_rep;
+	struct m0_fop_link_rep      *link_rep;
+	struct m0_fop_setattr_rep   *setattr_rep;
+	struct m0_fop_getattr_rep   *getattr_rep;
+	struct m0_fop_statfs_rep    *statfs_rep;
+	struct m0_fop_lookup_rep    *lookup_rep;
+	struct m0_fop_open_rep      *open_rep;
+	struct m0_fop_close_rep     *close_rep;
+	struct m0_fop_readdir_rep   *readdir_rep;
+
+	M0_PRE(ftype != NULL);
+
+	M0_ENTRY();
+
+	/**
+	   TODO: This needs to be fixed later.
+
+	   Container 0 and its session are currently reserved for mdservice.
+	   We hardcoding its using here temporary because of the following:
+	   - we can't use @mo->mo_attr.ca_pfid because it is set to root
+	     fid, which has container != 0 and we cannot change it as it
+	     will conflict with cob io objects in case they share the same
+	     db;
+	   - we can't use @mo->mo_attr.ca_tfid it is not always set, some ops
+	     do not require it;
+	   - using @ci is not an option as well as it is not always used.
+	     For example, it is not available for lookup.
+	 */
+	session = m0t1fs_container_id_to_session(csb, 0);
+	M0_ASSERT(session != NULL);
+
+	fop = m0_fop_alloc(ftype, NULL);
+	if (fop == NULL) {
+		rc = -ENOMEM;
+		M0_LOG(M0_ERROR, "m0_fop_alloc() failed with %d", rc);
+		goto out;
+	}
+
+	rc = m0t1fs_mds_cob_fop_populate(mo, fop);
+	if (rc != 0) {
+		M0_LOG(M0_ERROR,
+		       "m0t1fs_mds_cob_fop_populate() failed with %d", rc);
+		goto out;
+	}
+
+	M0_LOG(M0_DEBUG, "Send md operation %u to session %lu",
+		m0_fop_opcode(fop), (unsigned long)session->s_session_id);
 
 	fop->f_item.ri_nr_sent_max = M0T1FS_RPC_TIMEOUT;
-        rc = m0_rpc_client_call(fop, session, NULL, 0 /* deadline */);
-        if (rc != 0) {
-                M0_LOG(M0_ERROR,
-                       "m0_rpc_client_call(%x) failed with %d", m0_fop_opcode(fop), rc);
-                goto out;
-        }
-
-        switch (m0_fop_opcode(fop)) {
-        case M0_MDSERVICE_CREATE_OPCODE:
-                create_rep = m0_fop_data(m0_rpc_item_to_fop(fop->f_item.ri_reply));
-                rc = create_rep->c_body.b_rc;
-                *rep = create_rep;
-                break;
-        case M0_MDSERVICE_STATFS_OPCODE:
-                statfs_rep = m0_fop_data(m0_rpc_item_to_fop(fop->f_item.ri_reply));
-                rc = statfs_rep->f_rc;
-                *rep = statfs_rep;
-                break;
-        case M0_MDSERVICE_LOOKUP_OPCODE:
-                lookup_rep = m0_fop_data(m0_rpc_item_to_fop(fop->f_item.ri_reply));
-                rc = lookup_rep->l_body.b_rc;
-                *rep = lookup_rep;
-                break;
-        case M0_MDSERVICE_LINK_OPCODE:
-                link_rep = m0_fop_data(m0_rpc_item_to_fop(fop->f_item.ri_reply));
-                rc = link_rep->l_body.b_rc;
-                *rep = link_rep;
-                break;
-        case M0_MDSERVICE_UNLINK_OPCODE:
-                unlink_rep = m0_fop_data(m0_rpc_item_to_fop(fop->f_item.ri_reply));
-                rc = unlink_rep->u_body.b_rc;
-                *rep = unlink_rep;
-                break;
-        case M0_MDSERVICE_RENAME_OPCODE:
-                rename_rep = m0_fop_data(m0_rpc_item_to_fop(fop->f_item.ri_reply));
-                rc = rename_rep->r_body.b_rc;
-                *rep = rename_rep;
-                break;
-        case M0_MDSERVICE_SETATTR_OPCODE:
-                setattr_rep = m0_fop_data(m0_rpc_item_to_fop(fop->f_item.ri_reply));
-                rc = setattr_rep->s_body.b_rc;
-                *rep = setattr_rep;
-                break;
-        case M0_MDSERVICE_GETATTR_OPCODE:
-                getattr_rep = m0_fop_data(m0_rpc_item_to_fop(fop->f_item.ri_reply));
-                rc = getattr_rep->g_body.b_rc;
-                *rep = getattr_rep;
-                break;
-        case M0_MDSERVICE_OPEN_OPCODE:
-                open_rep = m0_fop_data(m0_rpc_item_to_fop(fop->f_item.ri_reply));
-                rc = open_rep->o_body.b_rc;
-                *rep = open_rep;
-                break;
-        case M0_MDSERVICE_CLOSE_OPCODE:
-                close_rep = m0_fop_data(m0_rpc_item_to_fop(fop->f_item.ri_reply));
-                rc = close_rep->c_body.b_rc;
-                *rep = close_rep;
-                break;
-        case M0_MDSERVICE_READDIR_OPCODE:
-                readdir_rep = m0_fop_data(m0_rpc_item_to_fop(fop->f_item.ri_reply));
-                rc = readdir_rep->r_body.b_rc;
-                *rep = readdir_rep;
-                break;
-        default:
-                M0_LOG(M0_ERROR, "Unexpected fop opcode %x", m0_fop_opcode(fop));
-                rc = -ENOSYS;
-                goto out;
-        }
+	rc = m0_rpc_client_call(fop, session, NULL, 0 /* deadline */);
+	if (rc != 0) {
+		M0_LOG(M0_ERROR,
+		       "m0_rpc_client_call(%x) failed with %d", m0_fop_opcode(fop), rc);
+		goto out;
+	}
+
+	switch (m0_fop_opcode(fop)) {
+	case M0_MDSERVICE_CREATE_OPCODE:
+		create_rep = m0_fop_data(m0_rpc_item_to_fop(fop->f_item.ri_reply));
+		rc = create_rep->c_body.b_rc;
+		*rep = create_rep;
+		break;
+	case M0_MDSERVICE_STATFS_OPCODE:
+		statfs_rep = m0_fop_data(m0_rpc_item_to_fop(fop->f_item.ri_reply));
+		rc = statfs_rep->f_rc;
+		*rep = statfs_rep;
+		break;
+	case M0_MDSERVICE_LOOKUP_OPCODE:
+		lookup_rep = m0_fop_data(m0_rpc_item_to_fop(fop->f_item.ri_reply));
+		rc = lookup_rep->l_body.b_rc;
+		*rep = lookup_rep;
+		break;
+	case M0_MDSERVICE_LINK_OPCODE:
+		link_rep = m0_fop_data(m0_rpc_item_to_fop(fop->f_item.ri_reply));
+		rc = link_rep->l_body.b_rc;
+		*rep = link_rep;
+		break;
+	case M0_MDSERVICE_UNLINK_OPCODE:
+		unlink_rep = m0_fop_data(m0_rpc_item_to_fop(fop->f_item.ri_reply));
+		rc = unlink_rep->u_body.b_rc;
+		*rep = unlink_rep;
+		break;
+	case M0_MDSERVICE_RENAME_OPCODE:
+		rename_rep = m0_fop_data(m0_rpc_item_to_fop(fop->f_item.ri_reply));
+		rc = rename_rep->r_body.b_rc;
+		*rep = rename_rep;
+		break;
+	case M0_MDSERVICE_SETATTR_OPCODE:
+		setattr_rep = m0_fop_data(m0_rpc_item_to_fop(fop->f_item.ri_reply));
+		rc = setattr_rep->s_body.b_rc;
+		*rep = setattr_rep;
+		break;
+	case M0_MDSERVICE_GETATTR_OPCODE:
+		getattr_rep = m0_fop_data(m0_rpc_item_to_fop(fop->f_item.ri_reply));
+		rc = getattr_rep->g_body.b_rc;
+		*rep = getattr_rep;
+		break;
+	case M0_MDSERVICE_OPEN_OPCODE:
+		open_rep = m0_fop_data(m0_rpc_item_to_fop(fop->f_item.ri_reply));
+		rc = open_rep->o_body.b_rc;
+		*rep = open_rep;
+		break;
+	case M0_MDSERVICE_CLOSE_OPCODE:
+		close_rep = m0_fop_data(m0_rpc_item_to_fop(fop->f_item.ri_reply));
+		rc = close_rep->c_body.b_rc;
+		*rep = close_rep;
+		break;
+	case M0_MDSERVICE_READDIR_OPCODE:
+		readdir_rep = m0_fop_data(m0_rpc_item_to_fop(fop->f_item.ri_reply));
+		rc = readdir_rep->r_body.b_rc;
+		*rep = readdir_rep;
+		break;
+	default:
+		M0_LOG(M0_ERROR, "Unexpected fop opcode %x", m0_fop_opcode(fop));
+		rc = -ENOSYS;
+		goto out;
+	}
 
 out:
 	if (fop != NULL)
 		m0_fop_put(fop);
-        M0_LEAVE("%d", rc);
-        return rc;
+	M0_LEAVE("%d", rc);
+	return rc;
 }
 
 int m0t1fs_mds_statfs(struct m0t1fs_sb *csb, struct m0_fop_statfs_rep **rep)
 {
-        return m0t1fs_mds_cob_op(csb, NULL, &m0_fop_statfs_fopt, (void **)rep);
+	return m0t1fs_mds_cob_op(csb, NULL, &m0_fop_statfs_fopt, (void **)rep);
 }
 
 int m0t1fs_mds_cob_create(struct m0t1fs_sb          *csb,
-                          const struct m0t1fs_mdop  *mo,
-                          struct m0_fop_create_rep **rep)
+			  const struct m0t1fs_mdop  *mo,
+			  struct m0_fop_create_rep **rep)
 {
-        return m0t1fs_mds_cob_op(csb, mo, &m0_fop_create_fopt, (void **)rep);
+	return m0t1fs_mds_cob_op(csb, mo, &m0_fop_create_fopt, (void **)rep);
 }
 
 int m0t1fs_mds_cob_unlink(struct m0t1fs_sb          *csb,
-                          const struct m0t1fs_mdop  *mo,
-                          struct m0_fop_unlink_rep **rep)
+			  const struct m0t1fs_mdop  *mo,
+			  struct m0_fop_unlink_rep **rep)
 {
-        return m0t1fs_mds_cob_op(csb, mo, &m0_fop_unlink_fopt, (void **)rep);
+	return m0t1fs_mds_cob_op(csb, mo, &m0_fop_unlink_fopt, (void **)rep);
 }
 
 int m0t1fs_mds_cob_link(struct m0t1fs_sb          *csb,
-                        const struct m0t1fs_mdop  *mo,
-                        struct m0_fop_link_rep   **rep)
+			const struct m0t1fs_mdop  *mo,
+			struct m0_fop_link_rep   **rep)
 {
-        return m0t1fs_mds_cob_op(csb, mo, &m0_fop_link_fopt, (void **)rep);
+	return m0t1fs_mds_cob_op(csb, mo, &m0_fop_link_fopt, (void **)rep);
 }
 
 int m0t1fs_mds_cob_lookup(struct m0t1fs_sb          *csb,
-                          const struct m0t1fs_mdop  *mo,
-                          struct m0_fop_lookup_rep **rep)
+			  const struct m0t1fs_mdop  *mo,
+			  struct m0_fop_lookup_rep **rep)
 {
-        return m0t1fs_mds_cob_op(csb, mo, &m0_fop_lookup_fopt, (void **)rep);
+	return m0t1fs_mds_cob_op(csb, mo, &m0_fop_lookup_fopt, (void **)rep);
 }
 
 int m0t1fs_mds_cob_getattr(struct m0t1fs_sb           *csb,
-                           const struct m0t1fs_mdop   *mo,
-                           struct m0_fop_getattr_rep **rep)
+			   const struct m0t1fs_mdop   *mo,
+			   struct m0_fop_getattr_rep **rep)
 {
-        return m0t1fs_mds_cob_op(csb, mo, &m0_fop_getattr_fopt, (void **)rep);
+	return m0t1fs_mds_cob_op(csb, mo, &m0_fop_getattr_fopt, (void **)rep);
 }
 
 int m0t1fs_mds_cob_setattr(struct m0t1fs_sb           *csb,
-                           const struct m0t1fs_mdop   *mo,
-                           struct m0_fop_setattr_rep **rep)
+			   const struct m0t1fs_mdop   *mo,
+			   struct m0_fop_setattr_rep **rep)
 {
-        return m0t1fs_mds_cob_op(csb, mo, &m0_fop_setattr_fopt, (void **)rep);
+	return m0t1fs_mds_cob_op(csb, mo, &m0_fop_setattr_fopt, (void **)rep);
 }
 
 int m0t1fs_mds_cob_readdir(struct m0t1fs_sb           *csb,
-                           const struct m0t1fs_mdop   *mo,
-                           struct m0_fop_readdir_rep **rep)
+			   const struct m0t1fs_mdop   *mo,
+			   struct m0_fop_readdir_rep **rep)
 {
 	return m0t1fs_mds_cob_op(csb, mo, &m0_fop_readdir_fopt, (void **)rep);
 }
 
 static int m0t1fs_ios_cob_create(struct m0t1fs_sb    *csb,
-			         const struct m0_fid *cob_fid,
-			         const struct m0_fid *gob_fid,
+				 const struct m0_fid *cob_fid,
+				 const struct m0_fid *gob_fid,
 				 uint32_t cob_idx)
 {
 	return m0t1fs_ios_cob_op(csb, cob_fid, gob_fid, cob_idx,
@@ -1089,8 +1125,8 @@ static int m0t1fs_ios_cob_create(struct m0t1fs_sb    *csb,
 }
 
 static int m0t1fs_ios_cob_delete(struct m0t1fs_sb *csb,
-			         const struct m0_fid *cob_fid,
-			         const struct m0_fid *gob_fid,
+				 const struct m0_fid *cob_fid,
+				 const struct m0_fid *gob_fid,
 				 uint32_t cob_idx)
 {
 	return m0t1fs_ios_cob_op(csb, cob_fid, gob_fid, cob_idx,
@@ -1175,7 +1211,7 @@ static int m0t1fs_ios_cob_op(struct m0t1fs_sb    *csb,
 	} else
 		rc = reply->cor_rc;
 
-        M0_LOG(M0_DEBUG, "Finished ioservice op with %d", rc);
+	M0_LOG(M0_DEBUG, "Finished ioservice op with %d", rc);
 
 fop_put:
 	m0_fop_put(fop);
@@ -1209,8 +1245,8 @@ static int m0t1fs_ios_cob_fop_populate(struct m0t1fs_sb    *csb,
 	cli = (struct m0_pool_version_numbers*)&common->c_version;
 	*cli = curr;
 
-        common->c_gobfid = *gob_fid;
-        common->c_cobfid = *cob_fid;
+	common->c_gobfid = *gob_fid;
+	common->c_cobfid = *cob_fid;
 	common->c_cob_idx = cob_idx;
 
 	M0_LEAVE("%d", 0);
-- 
1.8.3.2

