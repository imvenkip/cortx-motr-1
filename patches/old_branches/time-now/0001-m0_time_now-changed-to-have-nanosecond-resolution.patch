From 1709fed18d38253d67e9a87dfa55b5c22f819780 Mon Sep 17 00:00:00 2001
From: Maxim Medved <Max_Medved@xyratex.com>
Date: Mon, 8 Apr 2013 17:39:57 +0300
Subject: [PATCH 1/6] m0_time_now(): changed to have nanosecond resolution

---
 doc/Doxyfile                |   2 +-
 lib/linux_kernel/ktime.c    |  31 +++++---
 lib/linux_kernel/time.h     |   2 -
 lib/linux_kernel/ut/main.c  |   4 +-
 lib/time.h                  |  12 +--
 lib/timer.c                 |  23 +++++-
 lib/user_space/semaphore.c  |   9 ++-
 lib/user_space/time.h       |  39 +++++++++-
 lib/user_space/utime.c      | 132 ++++++++++++++++++++++++++-----
 lib/ut/chan.c               |  11 ++-
 lib/ut/main.c               |   4 +-
 lib/ut/time.c               | 185 +++++++++++++++++++++++++++++++++++++++++++-
 lib/ut/timer.c              |   4 +-
 mero/init.c                 |   6 ++
 net/test/ut/client_server.c |  41 ++++++----
 rpc/formation2.c            |   2 +-
 utils/ub_main.c             |   2 +
 17 files changed, 431 insertions(+), 78 deletions(-)

diff --git a/doc/Doxyfile b/doc/Doxyfile
index d9e72cd..40a63a4 100644
--- a/doc/Doxyfile
+++ b/doc/Doxyfile
@@ -664,7 +664,7 @@ EXCLUDE_SYMLINKS       = YES
 # against the file with absolute path, so to exclude all test directories
 # for example use the pattern */test/*
 
-EXCLUDE_PATTERNS       = *.git/*
+EXCLUDE_PATTERNS       = *.git/* */extra-libs/*
 
 # The EXCLUDE_SYMBOLS tag can be used to specify one or more symbol names
 # (namespaces, classes, functions, etc.) that should be excluded from the
diff --git a/lib/linux_kernel/ktime.c b/lib/linux_kernel/ktime.c
index 9cf5120..ee9d727 100644
--- a/lib/linux_kernel/ktime.c
+++ b/lib/linux_kernel/ktime.c
@@ -19,9 +19,10 @@
  * Original creation date: 12/06/2010
  */
 
-#include "lib/time.h"
-#include "lib/assert.h"  /* M0_CASSERT */
-#include "lib/cdefs.h"   /* M0_EXPORTED */
+#include "lib/time.h"	/* m0_time_t */
+#include "lib/assert.h"	/* M0_ASSERT */
+#include "lib/cdefs.h"	/* M0_EXPORTED */
+
 #include <linux/module.h>
 #include <linux/time.h>
 #include <linux/jiffies.h>
@@ -37,27 +38,33 @@
 
 m0_time_t m0_time_now(void)
 {
-	struct timespec ts = current_kernel_time();
-	return m0_time(ts.tv_sec, ts.tv_nsec);
+	struct timespec ts;
+
+	getnstimeofday(&ts);
+	return M0_MKTIME(ts.tv_sec, ts.tv_nsec);
 }
 M0_EXPORTED(m0_time_now);
 
 /**
    Sleep for requested time
 */
-M0_INTERNAL int m0_nanosleep(const m0_time_t req, m0_time_t *rem)
+int m0_nanosleep(const m0_time_t req, m0_time_t *rem)
 {
 	struct timespec ts = {
 		.tv_sec  = m0_time_seconds(req),
 		.tv_nsec = m0_time_nanoseconds(req)
 	};
-	int rc = 0;
-	unsigned long tj = timespec_to_jiffies(&ts);
+	unsigned long	tj = timespec_to_jiffies(&ts);
+	/* this may use schedule_timeout_interruptible() to capture signals */
+	unsigned long	remtj = schedule_timeout_uninterruptible(tj);
+	struct timespec remts;
 
-	/* this may use TASK_INTERRUPTIBLE to capture signals */
-        set_current_state(TASK_UNINTERRUPTIBLE);
-        schedule_timeout(tj);
-	return rc;
+	M0_ASSERT(remtj >= 0);
+	if (rem != NULL) {
+		jiffies_to_timespec(remtj, &remts);
+		*rem = m0_time(remts.tv_sec, remts.tv_nsec);
+	}
+	return remtj == 0 ? 0 : -1;
 }
 M0_EXPORTED(m0_nanosleep);
 
diff --git a/lib/linux_kernel/time.h b/lib/linux_kernel/time.h
index ceebb2e..514dcd5 100644
--- a/lib/linux_kernel/time.h
+++ b/lib/linux_kernel/time.h
@@ -23,8 +23,6 @@
 #ifndef __MERO_LIB_LINUX_KERNEL_TIME_H__
 #define __MERO_LIB_LINUX_KERNEL_TIME_H__
 
-#include <linux/time.h>
-
 /* __MERO_LIB_LINUX_KERNEL_TIME_H__ */
 #endif
 
diff --git a/lib/linux_kernel/ut/main.c b/lib/linux_kernel/ut/main.c
index 6788023..cfd894c 100644
--- a/lib/linux_kernel/ut/main.c
+++ b/lib/linux_kernel/ut/main.c
@@ -38,7 +38,7 @@ M0_INTERNAL void test_queue(void);
 M0_INTERNAL void test_refs(void);
 M0_INTERNAL void test_rw(void);
 M0_INTERNAL void test_thread(void);
-M0_INTERNAL void test_time(void);
+M0_INTERNAL void m0_ut_time_test(void);
 M0_INTERNAL void test_trace(void);
 M0_INTERNAL void test_vec(void);
 M0_INTERNAL void test_zerovec(void);
@@ -69,7 +69,7 @@ const struct m0_test_suite m0_klibm0_ut = {
 		{ "refs",      test_refs          },
 		{ "rwlock",    test_rw            },
 		{ "thread",    test_thread        },
-		{ "time",      test_time          },
+		{ "time",      m0_ut_time_test	  },
 		{ "trace",     test_trace         },
 		{ "uuid",      m0_test_lib_uuid   },
 		{ "vec",       test_vec           },
diff --git a/lib/time.h b/lib/time.h
index 87244fa..922fd2f 100644
--- a/lib/time.h
+++ b/lib/time.h
@@ -33,12 +33,6 @@
    @{
  */
 
-#ifndef __KERNEL__
-#include "lib/user_space/time.h"
-#else
-#include "lib/linux_kernel/time.h"
-#endif
-
 typedef uint64_t m0_time_t;
 
 enum { M0_TIME_ONE_BILLION = 1000000000ULL };
@@ -46,6 +40,12 @@ enum { M0_TIME_ONE_BILLION = 1000000000ULL };
 /** The largest time that is never reached in system life. */
 extern const m0_time_t M0_TIME_NEVER;
 
+#ifndef __KERNEL__
+#include "lib/user_space/time.h"
+#else
+#include "lib/linux_kernel/time.h"
+#endif
+
 /** Create and return a m0_time_t from seconds and nanoseconds. */
 m0_time_t m0_time(uint64_t secs, long ns);
 
diff --git a/lib/timer.c b/lib/timer.c
index 4f386d6..fdd036f 100644
--- a/lib/timer.c
+++ b/lib/timer.c
@@ -67,6 +67,8 @@ enum timer_func {
 };
 
 static const m0_time_t zero_time = M0_MKTIME(0, 0);
+/** Clock source for M0_TIMER_HARD. @see timer_posix_set() */
+static int	       M0_CLOCK_SOURCE_TIMER = -1;
 
 /**
    Typed list of m0_timer_tid structures.
@@ -183,7 +185,7 @@ static int timer_posix_init(struct m0_timer *timer)
 	se.sigev_signo = TIMER_SIGNO;
 	se._sigev_un._tid = timer->t_tid;
 	se.sigev_value.sival_ptr = timer;
-	rc = timer_create(CLOCK_REALTIME, &se, &ptimer);
+	rc = timer_create(M0_CLOCK_SOURCE_TIMER, &se, &ptimer);
 	/* preserve timer->t_ptimer if timer_create() isn't succeeded */
 	if (rc == 0)
 		timer->t_ptimer = ptimer;
@@ -217,6 +219,9 @@ timer_posix_set(struct m0_timer *timer, m0_time_t expire, m0_time_t *old_expire)
 
 	M0_PRE(timer != NULL);
 
+	if (M0_CLOCK_SOURCE == M0_CLOCK_SOURCE_REALTIME_MONOTONIC)
+		expire -= m0_time_monotonic_offset;
+
 	ts.it_interval.tv_sec = 0;
 	ts.it_interval.tv_nsec = 0;
 	ts.it_value.tv_sec = m0_time_seconds(expire);
@@ -560,6 +565,22 @@ M0_INTERNAL bool m0_timer_is_started(const struct m0_timer *timer)
 M0_INTERNAL int m0_timers_init()
 {
 	timer_sigaction(TIMER_SIGNO, timer_sighandler);
+
+	switch (M0_CLOCK_SOURCE) {
+	case M0_CLOCK_SOURCE_GTOD:
+		M0_CLOCK_SOURCE_TIMER = CLOCK_REALTIME;
+		break;
+	case M0_CLOCK_SOURCE_REALTIME_MONOTONIC:
+		M0_CLOCK_SOURCE_TIMER = CLOCK_MONOTONIC;
+		break;
+	case M0_CLOCK_SOURCE_REALTIME:
+	case M0_CLOCK_SOURCE_MONOTONIC:
+	case M0_CLOCK_SOURCE_MONOTONIC_RAW:
+		M0_CLOCK_SOURCE_TIMER = M0_CLOCK_SOURCE;
+		break;
+	default:
+		M0_IMPOSSIBLE("Invalid clock source for timer");
+	}
 	return 0;
 }
 
diff --git a/lib/user_space/semaphore.c b/lib/user_space/semaphore.c
index d16c191..e2abb57 100644
--- a/lib/user_space/semaphore.c
+++ b/lib/user_space/semaphore.c
@@ -87,11 +87,12 @@ M0_INTERNAL unsigned m0_semaphore_value(struct m0_semaphore *semaphore)
 M0_INTERNAL bool m0_semaphore_timeddown(struct m0_semaphore *semaphore,
 					const m0_time_t abs_timeout)
 {
+	m0_time_t	abs_timeout_realtime = m0_time_to_realtime(abs_timeout);
 	struct timespec ts = {
-			.tv_sec  = m0_time_seconds(abs_timeout),
-			.tv_nsec = m0_time_nanoseconds(abs_timeout)
-		};
-	int rc;
+			.tv_sec  = m0_time_seconds(abs_timeout_realtime),
+			.tv_nsec = m0_time_nanoseconds(abs_timeout_realtime)
+	};
+	int		rc;
 
 	do
 		rc = sem_timedwait(&semaphore->s_sem, &ts);
diff --git a/lib/user_space/time.h b/lib/user_space/time.h
index 3afbb79..97e949d 100644
--- a/lib/user_space/time.h
+++ b/lib/user_space/time.h
@@ -15,6 +15,7 @@
  * http://www.xyratex.com/contact
  *
  * Original author: Nathan Rutman <Nathan_Rutman@xyratex.com>
+ *		    Maxim Medved <Max_Medved@xyratex.com>
  * Original creation date: 12/08/2010
  */
 
@@ -23,9 +24,45 @@
 #ifndef __MERO_LIB_USER_SPACE_TIME_H__
 #define __MERO_LIB_USER_SPACE_TIME_H__
 
-#include <sys/time.h>
 #include <time.h>
 
+/**
+ * Clock sources for m0_time_now(). @see m0_time_now()
+ * @note Be sure to change m0_semaphore and m0_timer implementations
+ * after changing CLOCK_SOURCES list.
+ * @see man 3p clock_gettime
+ * @see timer_posix_set(), m0_semaphore_timeddown(), m0_time_now(),
+ *	m0_time_to_realtime().
+ */
+enum CLOCK_SOURCES {
+	M0_CLOCK_SOURCE_REALTIME = CLOCK_REALTIME,
+	M0_CLOCK_SOURCE_MONOTONIC = CLOCK_MONOTONIC,
+	/** @note POSIX timers on Linux don't support this clock source */
+	M0_CLOCK_SOURCE_MONOTONIC_RAW = CLOCK_MONOTONIC_RAW,
+	/** gettimeofday(). All others clock sources use clock_gettime() */
+	M0_CLOCK_SOURCE_GTOD,
+	/** CLOCK_REALTIME + CLOCK_MONOTONIC combination.
+	 *  @see m0_utime_init() */
+	M0_CLOCK_SOURCE_REALTIME_MONOTONIC,
+};
+
+/** Clock source for m0_time_now() */
+extern const enum CLOCK_SOURCES M0_CLOCK_SOURCE;
+/** Offset for M0_CLOCK_SOURCE_REALTIME_MONOTONIC clock source.
+ *  @see m0_utime_init() */
+extern m0_time_t		m0_time_monotonic_offset;
+
+/**
+ * Useful for mutex/semaphore implementation. This function will translate
+ * time from value obtained from m0_time_now() to value that can be used
+ * with CLOCK_REALTIME-only functions such as sem_timedwait() and
+ * pthread_mutex_timedlock().
+ * @param time Time obtained from m0_time_now() and adjusted somehow if needed.
+ * @return Converted time value.
+ * @note In some cases this function will have 2 calls to clock_gettime().
+ */
+M0_INTERNAL m0_time_t m0_time_to_realtime(m0_time_t abs_time);
+
 /* __MERO_LIB_USER_SPACE_TIME_H__ */
 #endif
 
diff --git a/lib/user_space/utime.c b/lib/user_space/utime.c
index d211b9c..801d245 100644
--- a/lib/user_space/utime.c
+++ b/lib/user_space/utime.c
@@ -1,6 +1,6 @@
 /* -*- C -*- */
 /*
- * COPYRIGHT 2012 XYRATEX TECHNOLOGY LIMITED
+ * COPYRIGHT 2013 XYRATEX TECHNOLOGY LIMITED
  *
  * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
  * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
@@ -16,51 +16,141 @@
  *
  * Original author: Nathan Rutman <Nathan_Rutman@xyratex.com>,
  *                  Huang Hua <Hua_Huang@xyratex.com>
+ *		    Maxim Medved <Max_Medved@xyratex.com>
  * Original creation date: 01/27/2011
  */
 
-#include "lib/time.h"
-#include "lib/assert.h"  /* M0_CASSERT */
-#include "lib/cdefs.h"   /* M0_EXPORTED */
-#include <stddef.h>
+#include "lib/time.h"	/* m0_time_t */
 
-int nanosleep(const struct timespec *req, struct timespec *rem);
+#include "lib/assert.h" /* M0_ASSERT */
+#include "lib/cdefs.h"  /* M0_EXPORTED */
+#include "lib/misc.h"	/* M0_IN */
+#include "lib/errno.h"	/* ENOSYS */
+
+#include <sys/time.h>	/* gettimeofday */
+#include <time.h>	/* clock_gettime */
 
 /**
    @addtogroup time
 
-   Implementation of m0_time_t on top of userspace struct timespec
+   Implementation of m0_time_t.
+
+   Time functions can use different clock sources.
+   @see M0_CLOCK_SOURCE
 
    @{
 */
 
-m0_time_t m0_time_now(void)
+// const enum CLOCK_SOURCES M0_CLOCK_SOURCE = M0_CLOCK_SOURCE_REALTIME_MONOTONIC;
+const enum CLOCK_SOURCES M0_CLOCK_SOURCE = M0_CLOCK_SOURCE_MONOTONIC_RAW;
+m0_time_t		 m0_time_monotonic_offset;
+
+static m0_time_t clock_gettime_wrapper(clockid_t clock_id)
+{
+	struct timespec tp;
+	int		rc = clock_gettime(clock_id, &tp);
+
+	/** clock_gettime() can fail iff clock_id is invalid */
+	M0_ASSERT(rc == 0);
+	return M0_MKTIME(tp.tv_sec, tp.tv_nsec);
+}
+
+M0_INTERNAL int m0_utime_init(void)
+{
+	m0_time_t realtime;
+	m0_time_t monotonic;
+
+	if (M0_CLOCK_SOURCE == M0_CLOCK_SOURCE_REALTIME_MONOTONIC) {
+		monotonic = clock_gettime_wrapper(CLOCK_MONOTONIC);
+		realtime  = clock_gettime_wrapper(CLOCK_REALTIME);
+		m0_time_monotonic_offset = realtime - monotonic;
+		if (m0_time_monotonic_offset == 0)
+			m0_time_monotonic_offset = 1;
+	}
+	return 0;
+}
+
+M0_INTERNAL void m0_utime_fini(void)
 {
-        struct timeval tv;
+}
 
-        /* We could use clock_gettime(CLOCK_REALTIME, time) for nanoseconds,
-	 * but in this case we would have to link librt... */
-        gettimeofday(&tv, NULL);
+m0_time_t m0_time_now(void)
+{
+	struct timeval tv;
+	int	       rc;
+	m0_time_t      result;
 
-        return m0_time(tv.tv_sec, tv.tv_usec * 1000);
+	switch (M0_CLOCK_SOURCE) {
+	case M0_CLOCK_SOURCE_REALTIME_MONOTONIC:
+		M0_PRE(m0_time_monotonic_offset != 0);
+		result = clock_gettime_wrapper(CLOCK_MONOTONIC) +
+			 m0_time_monotonic_offset;
+		break;
+	case M0_CLOCK_SOURCE_GTOD:
+		rc = gettimeofday(&tv, NULL);
+		M0_ASSERT(rc == 0);
+		result = M0_MKTIME(tv.tv_sec, tv.tv_usec * 1000);
+		break;
+	case M0_CLOCK_SOURCE_REALTIME:
+	case M0_CLOCK_SOURCE_MONOTONIC:
+	case M0_CLOCK_SOURCE_MONOTONIC_RAW:
+		result = clock_gettime_wrapper(M0_CLOCK_SOURCE);
+		break;
+	default:
+		M0_IMPOSSIBLE("Unknown clock source");
+		result = M0_TIME_NEVER;
+	};
+	return result;
 }
 M0_EXPORTED(m0_time_now);
 
-/**
-   Sleep for requested time
-*/
+M0_INTERNAL m0_time_t m0_time_to_realtime(m0_time_t abs_time)
+{
+	m0_time_t source_time;
+	m0_time_t realtime;
+	m0_time_t monotonic;
+
+	if (abs_time != M0_TIME_NEVER) {
+		switch (M0_CLOCK_SOURCE) {
+		case M0_CLOCK_SOURCE_MONOTONIC:
+		case M0_CLOCK_SOURCE_MONOTONIC_RAW:
+			source_time = clock_gettime_wrapper(M0_CLOCK_SOURCE);
+			realtime    = clock_gettime_wrapper(CLOCK_REALTIME);
+			abs_time   += realtime - source_time;
+			break;
+		case M0_CLOCK_SOURCE_REALTIME_MONOTONIC:
+			monotonic = clock_gettime_wrapper(CLOCK_MONOTONIC);
+			realtime  = clock_gettime_wrapper(CLOCK_REALTIME);
+			/* get monotonic time */
+			abs_time -= m0_time_monotonic_offset;
+			/* add offset for realtime */
+			abs_time += realtime - monotonic;
+			/* It will mitigate time jumps between call
+			 * to m0_time_now() and call to this function. */
+			break;
+		case M0_CLOCK_SOURCE_GTOD:
+		case M0_CLOCK_SOURCE_REALTIME:
+			break;
+		default:
+			M0_IMPOSSIBLE("Unknown clock source");
+			abs_time = 0;
+		}
+	}
+	return abs_time;
+}
+
+/** Sleep for requested time */
 int m0_nanosleep(const m0_time_t req, m0_time_t *rem)
 {
-	struct timespec reqts = {
+	struct timespec	reqts = {
 		.tv_sec  = m0_time_seconds(req),
 		.tv_nsec = m0_time_nanoseconds(req)
 	};
-	struct timespec remts = { 0 };
-	int rc;
+	struct timespec remts;
+	int		rc = nanosleep(&reqts, &remts);
 
-	rc = nanosleep(&reqts, &remts);
 	if (rem != NULL)
-		*rem = m0_time(remts.tv_sec, remts.tv_nsec);
+		*rem = rc != 0 ? m0_time(remts.tv_sec, remts.tv_nsec) : 0;
 	return rc;
 }
 M0_EXPORTED(m0_nanosleep);
diff --git a/lib/ut/chan.c b/lib/ut/chan.c
index 57067ba..39e890b 100644
--- a/lib/ut/chan.c
+++ b/lib/ut/chan.c
@@ -96,6 +96,7 @@ void test_chan(void)
 	int             i;
 	int             j;
 	bool            got;
+	int		rc;
 
 	m0_mutex_init(&mutex);
 	m0_chan_init(&chan, &mutex);
@@ -159,10 +160,12 @@ void test_chan(void)
 	M0_UT_ASSERT(!got);
 
 	/* chan is signaled after 1/10 second. so the wait will return true */
-	m0_timer_init(&timer, M0_TIMER_HARD,
-		      m0_time_from_now(0, M0_TIME_ONE_BILLION/10),
-		      &signal_the_chan_in_timer, (unsigned long)&clink1);
-	m0_timer_start(&timer);
+	rc = m0_timer_init(&timer, M0_TIMER_HARD,
+			   m0_time_from_now(0, M0_TIME_ONE_BILLION/10),
+			   &signal_the_chan_in_timer, (unsigned long)&clink1);
+	M0_UT_ASSERT(rc == 0);
+	rc = m0_timer_start(&timer);
+	M0_UT_ASSERT(rc == 0);
 	got = m0_chan_timedwait(&clink1,
 				m0_time_from_now(0, M0_TIME_ONE_BILLION/5));
 	M0_UT_ASSERT(got);
diff --git a/lib/ut/main.c b/lib/ut/main.c
index d9be0f5..c0ff468 100644
--- a/lib/ut/main.c
+++ b/lib/ut/main.c
@@ -40,7 +40,7 @@ extern void test_queue(void);
 extern void test_refs(void);
 extern void test_rw(void);
 extern void test_thread(void);
-extern void test_time(void);
+extern void m0_ut_time_test(void);
 extern void test_timer(void);
 extern void test_tlist(void);
 extern void test_trace(void);
@@ -72,7 +72,7 @@ const struct m0_test_suite libm0_ut = {
 		{ "queue",     test_queue         },
 		{ "refs",      test_refs          },
 		{ "thread",    test_thread        },
-		{ "time",      test_time          },
+		{ "time",      m0_ut_time_test	  },
 		{ "timer",     test_timer         },
 		{ "tlist",     test_tlist         },
 		{ "trace",     test_trace         },
diff --git a/lib/ut/time.c b/lib/ut/time.c
index b515368..e597c12 100644
--- a/lib/ut/time.c
+++ b/lib/ut/time.c
@@ -16,14 +16,47 @@
  *
  * Original author: Nathan Rutman <Nathan_Rutman@xyratex.com>,
  *                  Huang Hua <Hua_Huang@xyratex.com>
+ *		    Maxim Medved <Max_Medved@xyratex.com>
  * Original creation date: 12/06/2010
  */
 
-#include "ut/ut.h"
-#include "lib/time.h"
-#include "lib/assert.h"
+#include "lib/time.h"		/* m0_time_t */
 
-void test_time(void)
+#include "lib/arith.h"		/* max_check */
+#include "lib/assert.h"		/* M0_PRE */
+#include "lib/atomic.h"		/* m0_atomic64 */
+#include "lib/semaphore.h"	/* m0_semaphore */
+#include "lib/thread.h"		/* m0_thread */
+#include "lib/trace.h"		/* M0_LOG */
+#include "lib/ub.h"		/* m0_ub_set */
+
+#include "ut/ut.h"		/* M0_UT_ASSERT */
+
+enum {
+	THREADS_NR_MAX = 32,
+	TIME_VALUES_NR = 0x10000,
+	/** 2ms accepted difference between m0_time_now() on different cores */
+	DIFF_ACCEPTED  = 2000000,
+};
+
+struct time_test {
+	m0_time_t tt_now;
+	int	  tt_thread_index;
+	int64_t	  tt_prev_index;
+};
+
+struct time_test_thread {
+	struct m0_thread    tth_thread;
+	struct m0_semaphore tth_start;
+};
+
+static struct time_test	       time_values[TIME_VALUES_NR];
+static struct time_test_thread time_threads[THREADS_NR_MAX];
+static struct m0_atomic64      time_index;
+static unsigned long	       err_nr;	/**< Number of out-of-sync errors */
+static m0_time_t	       err_max;	/**< Maximum out-of-sync error */
+
+static void time_test_simple(void)
 {
 	m0_time_t t1, t2, t3;
 	int rc;
@@ -73,6 +106,150 @@ void test_time(void)
 	M0_UT_ASSERT(t2 == M0_TIME_NEVER);
 }
 
+static void time_thread(int thread_index)
+{
+	struct time_test_thread *th = &time_threads[thread_index];
+	int64_t			 prev_index = -1;
+	int64_t			 index;
+
+	m0_semaphore_down(&th->tth_start);
+	while ((index = m0_atomic64_add_return(&time_index, 1)) <=
+	       TIME_VALUES_NR) {
+		m0_mb();
+		time_values[--index] = (struct time_test) {
+			.tt_now		 = m0_time_now(),
+			.tt_thread_index = thread_index,
+			.tt_prev_index	 = prev_index,
+		};
+		prev_index = index;
+		m0_mb();
+	}
+}
+
+static m0_time_t tv(int index)
+{
+	M0_ASSERT(index >= -1 && index < TIME_VALUES_NR);
+	return index == -1 ? 0 : time_values[index].tt_now;
+}
+
+static m0_time_t tv_prev(int index)
+{
+	M0_ASSERT(index >= 0 && index < TIME_VALUES_NR);
+	return tv(time_values[index].tt_prev_index);
+}
+
+/*
+ * [a], [b], [c] - sequential time measurements for some thread.
+ * prev[index] - previous measurement for thread that have measurement #'index'
+ * The following statements should be true if time is monotonic:
+ * - [a] <= [b]
+ * - [b] <= [c]
+ * - for each measurement [i] in range (b, c): prev[i] <= [c]
+ * - for each measurement [i] in range (b, c): [a] <= [i]
+ */
+static void time_test_check(int64_t a, int64_t b, int64_t c)
+{
+	int i;
+
+	M0_PRE(b != -1 && c != -1);
+	M0_UT_ASSERT(tv(a) <= tv(b) && tv(b) <= tv(c));
+	for (i = b + 1; i <= c - 1; ++i) {
+		/* check if m0_time_now() is out-of-sync and record mistiming */
+		err_max = max3(err_max, tv_prev(i) > tv(c) ?
+					tv_prev(i) - tv(c) : err_max,
+					tv(a) > tv(i) ?
+					tv(a) - tv(i) : err_max);
+		err_nr += tv_prev(i) > tv(c);
+		err_nr += tv(a) > tv(i);
+		M0_UT_ASSERT(tv_prev(i) <= tv(c) + DIFF_ACCEPTED);
+		M0_UT_ASSERT(tv(a) <= tv(i) + DIFF_ACCEPTED);
+	}
+}
+
+static void time_test_mt_nr(int threads_nr)
+{
+	static struct time_test_thread *th;
+	int				i;
+	int				rc;
+	int64_t				b;
+	int64_t				c;
+	bool				checked[THREADS_NR_MAX] = { };
+
+	m0_atomic64_set(&time_index, 0);
+	err_nr  = 0;
+	err_max = 0;
+	/* start time_thread()s */
+	for (i = 0; i < threads_nr; ++i) {
+		th = &time_threads[i];
+		rc = m0_semaphore_init(&th->tth_start, 0);
+		M0_UT_ASSERT(rc == 0);
+		rc = M0_THREAD_INIT(&th->tth_thread, int, NULL, &time_thread, i,
+				    "#%d_time_thread", i);
+		M0_UT_ASSERT(rc == 0);
+	}
+	/* barrier with all time_thread()s */
+	for (i = 0; i < threads_nr; ++i)
+		m0_semaphore_up(&time_threads[i].tth_start);
+	/* wait until all threads finished */
+	for (i = 0; i < threads_nr; ++i) {
+		th = &time_threads[i];
+		rc = m0_thread_join(&th->tth_thread);
+		M0_UT_ASSERT(rc == 0);
+		m0_thread_fini(&th->tth_thread);
+		m0_semaphore_fini(&th->tth_start);
+	}
+	M0_UT_ASSERT(m0_atomic64_get(&time_index) >= TIME_VALUES_NR);
+	/* check monotony of m0_time_now() results */
+	for (i = TIME_VALUES_NR - 1; i >= 0; --i) {
+		if (checked[time_values[i].tt_thread_index])
+			continue;
+		checked[time_values[i].tt_thread_index] = true;
+		b = i;
+		while (1) {
+			c = b;
+			b = time_values[c].tt_prev_index;
+			if (b == -1)
+				break;
+			time_test_check(time_values[b].tt_prev_index, b, c);
+		}
+	}
+	if (err_nr != 0) {
+		M0_LOG(M0_DEBUG, "time UT: threads = %d, samples = %d, "
+				 "number of out-of-sync errors = %lu, "
+				 "maximum out-of-sync error = %lu ns",
+		       threads_nr, TIME_VALUES_NR,
+		       err_nr, (unsigned long) err_max);
+	}
+}
+
+void m0_ut_time_test(void)
+{
+	int t;
+
+	time_test_simple();
+	for (t = 1; t <= THREADS_NR_MAX; ++t)
+		time_test_mt_nr(t);
+}
+
+enum { UB_TIME_ITER = 0x1000000 };
+
+static void ub_time_round(int unused)
+{
+	(void) m0_time_now();
+}
+
+struct m0_ub_set m0_time_ub = {
+	.us_name = "time-ub",
+	.us_init = NULL,
+	.us_fini = NULL,
+	.us_run  = {
+			{	.ub_name = "now",
+				.ub_iter = UB_TIME_ITER,
+				.ub_round = ub_time_round },
+			{	.ub_name = NULL		  }
+	}
+};
+
 /*
  *  Local variables:
  *  c-indentation-style: "K&R"
diff --git a/lib/ut/timer.c b/lib/ut/timer.c
index 8541811..b1577a2 100644
--- a/lib/ut/timer.c
+++ b/lib/ut/timer.c
@@ -158,9 +158,9 @@ static void test_timers(enum m0_timer_type timer_type, int nr_timers,
 	/* wait some time */
 	wait = make_time(wait_time_ms);
 	do {
-		(void)m0_nanosleep(wait, &rem);
+		rc = m0_nanosleep(wait, &rem);
 		wait = rem;
-	} while (wait != 0);
+	} while (rc != 0);
 	/* m0_timer_stop() */
 	for (i = 0; i < nr_timers; ++i) {
 		rc = m0_timer_stop(&timers[i]);
diff --git a/mero/init.c b/mero/init.c
index a7d42f7..6502e74 100644
--- a/mero/init.c
+++ b/mero/init.c
@@ -68,6 +68,9 @@
 #include "cm/cm.h"
 #include "mgmt/mgmt.h"
 
+M0_INTERNAL int m0_utime_init(void);
+M0_INTERNAL void m0_utime_fini(void);
+
 M0_INTERNAL int m0_memory_init(void);
 M0_INTERNAL void m0_memory_fini(void);
 
@@ -90,6 +93,9 @@ struct init_fini_call {
   subsystems, that are not yet ported to kernel mode.
  */
 struct init_fini_call subsystem[] = {
+#ifndef __KERNEL__
+	{ &m0_utime_init,	&m0_utime_fini,	      "time" },
+#endif
 	{ &m0_trace_init,       &m0_trace_fini,       "trace" },
 	{ &m0_fi_init,          &m0_fi_fini,          "finject" },
 	{ &m0_memory_init,      &m0_memory_fini,      "memory" },
diff --git a/net/test/ut/client_server.c b/net/test/ut/client_server.c
index 06f0738..732afed 100644
--- a/net/test/ut/client_server.c
+++ b/net/test/ut/client_server.c
@@ -39,8 +39,7 @@ enum {
 	NTCS_NODES_MAX		  = 128,
 	NTCS_NODE_ADDR_MAX	  = 0x100,
 	NTCS_TIMEOUT		  = 20,
-	/* 20min for debugging in gdb */
-	NTCS_TIMEOUT_GDB	  = 1200,
+	NTCS_TIMEOUT_GDB	  = 1200, /**< 20min for debugging in gdb */
 	NTCS_TMID_CONSOLE4CLIENTS = 2998,
 	NTCS_TMID_CONSOLE4SERVERS = 2999,
 	NTCS_TMID_NODES		  = 3000,
@@ -48,6 +47,7 @@ enum {
 	NTCS_TMID_DATA_CLIENTS    = NTCS_TMID_NODES + NTCS_NODES_MAX * 1,
 	NTCS_TMID_CMD_SERVERS	  = NTCS_TMID_NODES + NTCS_NODES_MAX * 2,
 	NTCS_TMID_DATA_SERVERS    = NTCS_TMID_NODES + NTCS_NODES_MAX * 3,
+	NTCS_ACCEPLABLE_MSG_LOSS  = 20,	/**< 20% */
 };
 
 static struct m0_net_test_node_cfg node_cfg[NTCS_NODES_MAX * 2];
@@ -134,6 +134,23 @@ static void msg_nr_print(const char *prefix,
 	     msg_nr->ntmn_total, msg_nr->ntmn_failed, msg_nr->ntmn_bad);
 }
 
+static bool msg_nr_in_range(size_t nr1, size_t nr2)
+{
+	size_t nr1_x100 = nr1 * 100;
+	return nr1_x100 >= nr2 * (100 - NTCS_ACCEPLABLE_MSG_LOSS) &&
+	       nr1_x100 <= nr2 * (100 + NTCS_ACCEPLABLE_MSG_LOSS);
+}
+
+static void nrchk(struct m0_net_test_msg_nr *nr1,
+		  struct m0_net_test_msg_nr *nr2)
+{
+	size_t total1 = nr1->ntmn_total;
+	size_t total2 = nr2->ntmn_total;
+
+	M0_UT_ASSERT(msg_nr_in_range(total1, total2));
+	M0_UT_ASSERT(msg_nr_in_range(total2, total1));
+}
+
 /*
  * Real situation - no explicit synchronization
  * between test console and test nodes.
@@ -268,6 +285,7 @@ static void net_test_client_server(const char *nid,
 	rc = m0_net_test_console_cmd(console, M0_NET_TEST_ROLE_SERVER,
 				     M0_NET_TEST_CMD_STATUS);
 	M0_UT_ASSERT(rc == servers_nr);
+	LOGD_VAR_NAME(ut_client_server) = true;
 	msg_nr_print("client msg sent",
 		     &console->ntcc_clients.ntcrc_sd->ntcsd_msg_nr_send);
 	msg_nr_print("client msg received",
@@ -299,25 +317,18 @@ static void net_test_client_server(const char *nid,
 	sd_servers = console->ntcc_servers.ntcrc_sd;
 	sd_clients = console->ntcc_clients.ntcrc_sd;
 	/* check stats */
-	/* @todo temporary disabled */
-#if 0
-	M0_UT_ASSERT(sd_servers->ntcsd_msg_nr_send.ntmn_total ==
-		     sd_clients->ntcsd_msg_nr_recv.ntmn_total);
-	M0_UT_ASSERT(sd_servers->ntcsd_msg_nr_recv.ntmn_total ==
-		     sd_clients->ntcsd_msg_nr_send.ntmn_total);
-	M0_UT_ASSERT(sd_servers->ntcsd_bulk_nr_send.ntmn_total ==
-		     sd_clients->ntcsd_bulk_nr_recv.ntmn_total);
-	M0_UT_ASSERT(sd_servers->ntcsd_bulk_nr_recv.ntmn_total ==
-		     sd_clients->ntcsd_bulk_nr_send.ntmn_total);
+	nrchk(&sd_servers->ntcsd_msg_nr_send, &sd_clients->ntcsd_msg_nr_recv);
+	nrchk(&sd_servers->ntcsd_msg_nr_recv, &sd_clients->ntcsd_msg_nr_send);
+	nrchk(&sd_servers->ntcsd_bulk_nr_send, &sd_clients->ntcsd_bulk_nr_recv);
+	nrchk(&sd_servers->ntcsd_bulk_nr_recv, &sd_clients->ntcsd_bulk_nr_send);
 	if (type == M0_NET_TEST_TYPE_BULK) {
 		/*
 		 * number of transfers are not measured on the test server
 		 * for ping test.
 		 */
-		M0_UT_ASSERT(sd_servers->ntcsd_transfers.ntmn_total ==
-			     sd_clients->ntcsd_transfers.ntmn_total);
+		nrchk(&sd_servers->ntcsd_transfers,
+		      &sd_clients->ntcsd_transfers);
 	}
-#endif
 	/* finalize console */
 	m0_net_test_slist_fini(&console_cfg->ntcc_servers);
 	m0_net_test_slist_fini(&console_cfg->ntcc_clients);
diff --git a/rpc/formation2.c b/rpc/formation2.c
index 62648b2..afbbf5b 100644
--- a/rpc/formation2.c
+++ b/rpc/formation2.c
@@ -443,7 +443,7 @@ static void item_move_to_urgent_queue(struct m0_rpc_frm *frm,
 	enum m0_rpc_frm_itemq_type  qtype;
 	struct m0_tl               *q;
 
-	M0_PRE(item != NULL && item->ri_deadline <= m0_time_now());
+	M0_PRE(item != NULL);
 
 	__itemq_remove(item);
 	qtype = frm_which_qtype(frm, item);
diff --git a/utils/ub_main.c b/utils/ub_main.c
index 2a884aa..3431729 100644
--- a/utils/ub_main.c
+++ b/utils/ub_main.c
@@ -40,6 +40,7 @@ extern struct m0_ub_set m0_memory_ub;
 extern struct m0_ub_set m0_parity_math_ub;
 extern struct m0_ub_set m0_rpc_ub;
 extern struct m0_ub_set m0_thread_ub;
+extern struct m0_ub_set m0_time_ub;
 extern struct m0_ub_set m0_tlist_ub;
 extern struct m0_ub_set m0_trace_ub;
 
@@ -97,6 +98,7 @@ static void ub_add(const struct ub_args *args)
 	 */
 	m0_ub_set_add(&m0_trace_ub);
 	m0_ub_set_add(&m0_tlist_ub);
+	m0_ub_set_add(&m0_time_ub);
 	m0_ub_set_add(&m0_thread_ub);
 	m0_ub_set_add(&m0_rpc_ub);
 	m0_ub_set_add(&m0_parity_math_ub);
-- 
1.8.3.2

