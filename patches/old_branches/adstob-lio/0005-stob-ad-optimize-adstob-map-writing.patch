From bcac2f278e215cf1588480afb40ab8038553f548 Mon Sep 17 00:00:00 2001
From: Andriy Tkachuk <andriy_tkachuk@xyratex.com>
Date: Mon, 21 Oct 2013 17:54:01 +0300
Subject: [PATCH 05/17] stob/ad: optimize adstob map writing

We used to write the map for each element of
si_stob indexvec data (usually 4K in size)
that led to huge amount of emap_paste() calls,
increasing BE transaction and memory consumption
for BE credits.

Now, we map only contiguous regions in
si_stob indexvec.

Note: m0_stob_write_credit() API was changed:
now, the m0_indexvec has to be passed instead of
plain m0_bcount_t nr. It is needed to calculate
the credit by the number of contiguous regions
in si_stob.
---
 addb/user_space/addb_stobsink.c |   2 +-
 ioservice/io_foms.c             |  36 +++++++++--
 reqh/ut/io_fop.c                |  11 +++-
 stob/ad.c                       | 131 +++++++++++++++++++++++++++-------------
 stob/stob.c                     |   7 +--
 stob/stob.h                     |   4 +-
 stob/ut/ad.c                    | 108 ++++++++++++++++-----------------
 7 files changed, 190 insertions(+), 109 deletions(-)

diff --git a/addb/user_space/addb_stobsink.c b/addb/user_space/addb_stobsink.c
index 77e55d8..feae31a 100644
--- a/addb/user_space/addb_stobsink.c
+++ b/addb/user_space/addb_stobsink.c
@@ -829,7 +829,7 @@ static void stobsink_persist(struct stobsink_poolbuf *pb,
 		m0_sm_group_lock(grp);
 		m0_dtx_init(&pb->spb_tx, dom->sd_bedom, grp);
 		dom->sd_ops->sdo_write_credit(dom,
-				pb->spb_io.si_user.ov_vec.v_nr,
+				&pb->spb_io.si_stob,
 				&pb->spb_tx.tx_betx_cred);
 		rc = dom->sd_ops->sdo_tx_make(dom, &pb->spb_tx);
 		if (rc != 0) {
diff --git a/ioservice/io_foms.c b/ioservice/io_foms.c
index 2ec9188..7c4f680 100644
--- a/ioservice/io_foms.c
+++ b/ioservice/io_foms.c
@@ -1723,12 +1723,16 @@ static int io_finish(struct m0_fom *fom)
 static void stob_write_credit(struct m0_fom *fom)
 {
 	int			 rc;
+	uint32_t		 bshift;
 	struct m0_io_fom_cob_rw	*fom_obj;
 	struct m0_fop_cob_rw	*rwfop;
 	struct m0_io_indexvec    wire_ivec;
 	struct m0_stob_domain	*fom_stdom;
-	m0_bcount_t		 count = 0;
+	struct m0_indexvec	 iv = {};
+	m0_bcount_t		*cnts;
+	m0_bindex_t		*offs;
 	int			 i;
+	int			 j;
 
 	M0_PRE(fom != NULL);
         M0_PRE(m0_is_io_fop(fom->fo_fop));
@@ -1743,12 +1747,36 @@ static void stob_write_credit(struct m0_fom *fom)
 	fom_stdom = m0_cs_stob_domain_find(m0_fom_reqh(fom),
 			&fom_obj->fcrw_stob->so_id);
 	M0_ASSERT(fom_stdom != NULL);
+	/*
+	   Since the upper layer IO block size could differ with IO block size
+	   of storage object, the block alignment and mapping is necessary.
+	 */
+	bshift = fom_obj->fcrw_stob->so_op->sop_block_shift(fom_obj->fcrw_stob);
+
 	for (i = 0; i < rwfop->crw_ivecs.cis_nr; i++) {
 		wire_ivec = rwfop->crw_ivecs.cis_ivecs[i];
-		count += wire_ivec.ci_nr;
+		iv.iv_vec.v_nr += wire_ivec.ci_nr;
+	}
+	M0_LOG(M0_DEBUG, "bshift=%d vnr=%d", (int)bshift, (int)iv.iv_vec.v_nr);
+	if (iv.iv_vec.v_nr == 0)
+		goto out;
+	M0_ALLOC_ARR(iv.iv_index, iv.iv_vec.v_nr);
+	M0_ASSERT(iv.iv_index != NULL); // XXX handle this error!
+	M0_ALLOC_ARR(iv.iv_vec.v_count, iv.iv_vec.v_nr);
+	M0_ASSERT(iv.iv_vec.v_count != NULL); // XXX handle this error!
+	offs = iv.iv_index;
+	cnts = iv.iv_vec.v_count;
+	for (i = 0; i < rwfop->crw_ivecs.cis_nr; i++) {
+		wire_ivec = rwfop->crw_ivecs.cis_ivecs[i];
+		for (j = 0; j < wire_ivec.ci_nr; j++) {
+			*(offs++) = wire_ivec.ci_iosegs[j].ci_index >> bshift;
+			*(cnts++) = wire_ivec.ci_iosegs[j].ci_count >> bshift;
+		}
 	}
-	M0_LOG(M0_DEBUG, "count=%d", (int)count);
-	m0_stob_write_credit(fom_stdom, count, m0_fom_tx_credit(fom));
+	m0_stob_write_credit(fom_stdom, &iv, m0_fom_tx_credit(fom));
+	m0_free(iv.iv_index);
+	m0_free(iv.iv_vec.v_count);
+out:
 	m0_stob_put(fom_obj->fcrw_stob);
 }
 
diff --git a/reqh/ut/io_fop.c b/reqh/ut/io_fop.c
index b9385f6..d542587 100644
--- a/reqh/ut/io_fop.c
+++ b/reqh/ut/io_fop.c
@@ -513,10 +513,19 @@ static void fom_stob_write_credit(struct m0_fom *fom)
 {
 	struct m0_stob_io_write *in_fop;
 	struct m0_stob          *stobj;
+	m0_bcount_t              count;
+	m0_bindex_t              index;
+	struct m0_indexvec       iv;
 
 	in_fop = m0_fop_data(fom->fo_fop);
 	stobj = stob_object_find(&in_fop->fiw_object, fom);
-	m0_stob_write_credit(stobj->so_domain, 1, m0_fom_tx_credit(fom));
+	index = 0;
+	count = in_fop->fiw_value.fi_count >>
+		stobj->so_op->sop_block_shift(stobj);
+	iv = (struct m0_indexvec) {
+		.iv_vec = (struct m0_vec) {.v_nr = 1, .v_count = &count},
+		.iv_index = &index};
+	m0_stob_write_credit(stobj->so_domain, &iv, m0_fom_tx_credit(fom));
 	m0_stob_put(stobj);
 }
 
diff --git a/stob/ad.c b/stob/ad.c
index 64556f2..7832ae0 100644
--- a/stob/ad.c
+++ b/stob/ad.c
@@ -24,13 +24,14 @@
 #include "be/extmap.h"
 #include "dtm/dtm.h"                /* m0_dtx */
 #include "fol/fol.h"
-#define M0_TRACE_SUBSYSTEM M0_TRACE_SUBSYS_STOB
+#define M0_TRACE_SUBSYSTEM M0_TRACE_SUBSYS_ADSTOB
 #include "lib/trace.h"
 #include "lib/thread.h"             /* LAMBDA */
 #include "lib/memory.h"
 #include "lib/arith.h"              /* min_type, min3 */
 #include "lib/misc.h"		    /* M0_SET0 */
 
+#include "balloc/balloc.h"
 #include "stob/stob.h"
 #include "stob/cache.h"
 #include "stob/ad.h"
@@ -864,7 +865,8 @@ static int ad_vec_alloc(struct m0_stob *obj,
    @note cursors and fragment sizes are measured in blocks.
  */
 static int ad_read_launch(struct m0_stob_io *io, struct ad_domain *adom,
-			  struct m0_vec_cursor *src, struct m0_vec_cursor *dst,
+			  struct m0_vec_cursor *src,
+			  struct m0_vec_cursor *dst,
 			  struct m0_be_emap_caret *car)
 {
 	struct m0_be_emap_cursor *it;
@@ -923,6 +925,11 @@ static int ad_read_launch(struct m0_stob_io *io, struct ad_domain *adom,
 		M0_ASSERT(!eomap);
 		M0_ASSERT(m0_ext_is_in(&seg->ee_ext, off));
 
+		M0_LOG(M0_DEBUG, "ext=[0x%llx, 0x%llx) val=0x%llx",
+			(unsigned long long)seg->ee_ext.e_start,
+			(unsigned long long)seg->ee_ext.e_end,
+			(unsigned long long)seg->ee_val);
+
 		frag_size = min3(m0_vec_cursor_step(src),
 				 m0_vec_cursor_step(dst),
 				 m0_be_emap_caret_step(car));
@@ -948,6 +955,9 @@ static int ad_read_launch(struct m0_stob_io *io, struct ad_domain *adom,
 		M0_ASSERT(!eomap);
 	} while (!eosrc);
 
+	M0_LOG(M0_DEBUG, "frags=%d frags_not_empty=%d",
+			(int)frags, (int)frags_not_empty);
+
 	ad_cursors_fini(it, src, dst, car);
 
 	result = ad_vec_alloc(io->si_obj, back, frags_not_empty);
@@ -1058,6 +1068,31 @@ static bool ad_wext_cursor_move(struct ad_wext_cursor *wc, m0_bcount_t count)
 	return wc->wc_wext == NULL;
 }
 
+static uint32_t ad_write_frags_count(struct m0_indexvec *iv)
+{
+	uint32_t               frags;
+	m0_bcount_t            frag_size;
+	m0_bcount_t            grp_size;
+	bool                   eov;
+	struct m0_ivec_cursor  it;
+
+	frags = 0;
+	m0_ivec_cursor_init(&it, iv);
+	grp_size = BALLOC_DEF_BLOCKS_PER_GROUP << BALLOC_DEF_BLOCK_SHIFT;
+
+	do {
+		frag_size = min_check(m0_ivec_cursor_cstep(&it), grp_size);
+		M0_ASSERT(frag_size > 0);
+		M0_ASSERT(frag_size <= (size_t)~0ULL);
+
+		eov = m0_ivec_cursor_move(&it, frag_size);
+
+		++frags;
+	} while (!eov);
+
+	return frags;
+}
+
 /**
    Calculates how many fragments this IO request contains.
 
@@ -1065,7 +1100,7 @@ static bool ad_wext_cursor_move(struct ad_wext_cursor *wc, m0_bcount_t count)
    for data, ignoring existing allocations in the overwritten extent of the
    file.
  */
-static uint32_t ad_write_count(struct m0_stob_io *io, struct m0_vec_cursor *src,
+static uint32_t ad_write_count(struct m0_vec_cursor *src,
 			       struct ad_wext_cursor *wc)
 {
 	uint32_t               frags;
@@ -1153,7 +1188,7 @@ static int seg_free(struct m0_stob_io *io, struct ad_domain *adom,
    storage object name-space.
  */
 static int ad_write_map_ext(struct m0_stob_io *io, struct ad_domain *adom,
-			    m0_bindex_t offset, struct m0_be_emap_cursor *orig,
+			    m0_bindex_t off, struct m0_be_emap_cursor *orig,
 			    const struct m0_ext *ext)
 {
 	int                    result;
@@ -1161,19 +1196,24 @@ static int ad_write_map_ext(struct m0_stob_io *io, struct ad_domain *adom,
 	struct m0_be_emap_cursor  it;
 	/* an extent in the logical name-space to be mapped to ext. */
 	struct m0_ext          todo = {
-		.e_start = offset,
-		.e_end   = offset + m0_ext_length(ext)
+		.e_start = off,
+		.e_end   = off + m0_ext_length(ext)
 	};
 
+	M0_ENTRY("ext=[0x%llx, 0x%llx) val=0x%llx",
+		(unsigned long long)todo.e_start,
+		(unsigned long long)todo.e_end,
+		(unsigned long long)ext->e_start);
+
 	m0_be_op_init(&it.ec_op);
-	m0_be_emap_lookup(orig->ec_map, &orig->ec_seg.ee_pre, offset, &it);
+	m0_be_emap_lookup(orig->ec_map, &orig->ec_seg.ee_pre, off, &it);
 	m0_be_op_wait(&it.ec_op);
 	M0_ASSERT(m0_be_op_state(&it.ec_op) == M0_BOS_SUCCESS);
 	result = it.ec_op.bo_u.u_emap.e_rc;
 	m0_be_op_fini(&it.ec_op);
 
 	if (result != 0)
-		return result;
+		M0_RETURN(result);
 	/*
 	 * Insert a new segment into extent map, overwriting parts of the map.
 	 *
@@ -1188,8 +1228,7 @@ static int ad_write_map_ext(struct m0_stob_io *io, struct ad_domain *adom,
 	 * of the corresponding physical extent.
 	 */
 	m0_be_op_init(&it.ec_op);
-	m0_be_emap_paste
-		(&it, &io->si_tx->tx_betx, &todo, ext->e_start,
+	m0_be_emap_paste(&it, &io->si_tx->tx_betx, &todo, ext->e_start,
 	 LAMBDA(void, (struct m0_be_emap_seg *seg) {
 			 /* handle extent deletion. */
 			 rc = rc ?: seg_free(io, adom, seg,
@@ -1228,7 +1267,7 @@ static int ad_write_map_ext(struct m0_stob_io *io, struct ad_domain *adom,
 	m0_be_op_fini(&it.ec_op);
 	m0_be_emap_close(&it);
 
-	return result ?: rc;
+	M0_RETURN(result ?: rc);
 }
 
 static int ad_fol_part_alloc(struct m0_fol_rec_part *part, uint32_t frags)
@@ -1265,12 +1304,13 @@ static int ad_fol_part_alloc(struct m0_fol_rec_part *part, uint32_t frags)
 
  */
 static int ad_write_map(struct m0_stob_io *io, struct ad_domain *adom,
-			struct m0_vec_cursor *dst,
+			struct m0_ivec_cursor *dst,
 			struct m0_be_emap_caret *map, struct ad_wext_cursor *wc,
 			uint32_t frags)
 {
 	int			result;
 	m0_bcount_t		frag_size;
+	m0_bindex_t		off;
 	bool			eodst;
 	bool			eoext;
 	struct m0_ext		todo;
@@ -1288,39 +1328,39 @@ static int ad_write_map(struct m0_stob_io *io, struct ad_domain *adom,
 	arp->arp_dom_id  = adom->ad_base.sd_dom_id;
 
 	do {
-		m0_bindex_t offset;
-
-		offset    = io->si_stob.iv_index[dst->vc_seg] + dst->vc_offset;
-		frag_size = min_check(m0_vec_cursor_step(dst),
+		off = m0_ivec_cursor_index(dst);
+		frag_size = min_check(m0_ivec_cursor_cstep(dst),
 				      ad_wext_cursor_step(wc));
 
 		todo.e_start = wc->wc_wext->we_ext.e_start + wc->wc_done;
 		todo.e_end   = todo.e_start + frag_size;
 
 		M0_ASSERT(i < frags);
-		arp->arp_seg.ps_old_data[i] = (struct m0_be_emap_seg ) {
+		arp->arp_seg.ps_old_data[i] = (struct m0_be_emap_seg) {
 			.ee_ext = {
-				.e_start = offset,
-				.e_end   = offset + m0_ext_length(&todo)
+				.e_start = off,
+				.e_end   = off + m0_ext_length(&todo)
 			},
 			.ee_val = todo.e_start,
 			.ee_pre = map->ct_it->ec_seg.ee_pre
 		};
 		++i;
 
-		result = ad_write_map_ext(io, adom, offset, map->ct_it, &todo);
+		result = ad_write_map_ext(io, adom, off, map->ct_it, &todo);
 
 		if (result != 0)
 			break;
 
-		eodst = m0_vec_cursor_move(dst, frag_size);
+		eodst = m0_ivec_cursor_move(dst, frag_size);
 		eoext = ad_wext_cursor_move(wc, frag_size);
 
 		M0_ASSERT(eodst == eoext);
 	} while (!eodst);
 
-	if (result == 0)
+	if (result == 0) {
+		arp->arp_seg.ps_segments = i;
 		m0_fol_rec_part_add(&io->si_tx->tx_fol_rec, part);
+	}
 
 	return result;
 }
@@ -1351,7 +1391,8 @@ static void ad_wext_fini(struct ad_write_ext *wext)
        (ad_write_map()).
  */
 static int ad_write_launch(struct m0_stob_io *io, struct ad_domain *adom,
-			   struct m0_vec_cursor *src, struct m0_vec_cursor *dst,
+			   struct m0_vec_cursor *src,
+			   struct m0_ivec_cursor *dst,
 			   struct m0_be_emap_caret *map)
 {
 	m0_bcount_t           todo;
@@ -1397,17 +1438,15 @@ static int ad_write_launch(struct m0_stob_io *io, struct ad_domain *adom,
 
 	if (result == 0) {
 		ad_wext_cursor_init(&wc, &head);
-		frags = ad_write_count(io, src, &wc);
+		frags = ad_write_count(src, &wc);
 		result = ad_vec_alloc(io->si_obj, back, frags);
 		if (result == 0) {
 			m0_vec_cursor_init(src, &io->si_user.ov_vec);
-			m0_vec_cursor_init(dst, &io->si_stob.iv_vec);
 			ad_wext_cursor_init(&wc, &head);
 
 			ad_write_back_fill(io, back, src, &wc);
 
-			m0_vec_cursor_init(src, &io->si_user.ov_vec);
-			m0_vec_cursor_init(dst, &io->si_stob.iv_vec);
+			m0_ivec_cursor_init(dst, &io->si_stob);
 			ad_wext_cursor_init(&wc, &head);
 
 			result = ad_write_map(io, adom, dst, map, &wc, frags);
@@ -1417,23 +1456,32 @@ static int ad_write_launch(struct m0_stob_io *io, struct ad_domain *adom,
 	return result;
 }
 
-static void ad_write_credit(struct ad_domain *dom, m0_bcount_t nr,
+static void ad_write_credit(struct ad_domain *dom, struct m0_indexvec *iv,
 			    struct m0_be_tx_credit *acc)
 {
-	M0_ENTRY("nr=%d cred=[%d:%d]", (int)nr,
+	int blocks = m0_vec_count(&iv->iv_vec) >> dom->ad_babshift;
+	int bfrags = blocks / BALLOC_DEF_BLOCKS_PER_GROUP + 1;
+	int frags;
+
+	M0_ENTRY("vnr=%d cred=[%d:%d]", (int)iv->iv_vec.v_nr,
 		(int)acc->tc_reg_nr, (int)acc->tc_reg_size);
+
 	if (dom->ad_ballroom->ab_ops->bo_alloc_credit != NULL)
-		dom->ad_ballroom->ab_ops->bo_alloc_credit(dom->ad_ballroom, nr,
-							  acc);
+		dom->ad_ballroom->ab_ops->bo_alloc_credit(dom->ad_ballroom,
+							  bfrags, acc);
 	M0_LOG(M0_DEBUG, "after bo_alloc: cred=[%d:%d]",
 		(int)acc->tc_reg_nr, (int)acc->tc_reg_size);
-	m0_be_emap_credit(&dom->ad_adata, M0_BEO_PASTE, nr, acc);
+
+	frags = ad_write_frags_count(iv);
+	M0_LOG(M0_DEBUG, "frags=%d", frags);
+	m0_be_emap_credit(&dom->ad_adata, M0_BEO_PASTE, frags, acc);
 	M0_LOG(M0_DEBUG, "after emap_cred: cred=[%d:%d]",
 		(int)acc->tc_reg_nr, (int)acc->tc_reg_size);
 
+	/* for each emap_paste() seg_free() could be called 3 times */
 	if (dom->ad_ballroom->ab_ops->bo_free_credit != NULL)
-		dom->ad_ballroom->ab_ops->bo_free_credit(dom->ad_ballroom, 3,
-							 acc);
+		dom->ad_ballroom->ab_ops->bo_free_credit(dom->ad_ballroom,
+							 3, acc);
 	M0_LEAVE("cred=[%d:%d]", (int)acc->tc_reg_nr, (int)acc->tc_reg_size);
 }
 
@@ -1441,7 +1489,7 @@ static void ad_write_credit(struct ad_domain *dom, m0_bcount_t nr,
    Implementation of m0_stob_domain_op::sdo_write_credit().
  */
 static void ad_domain_stob_write_credit(struct m0_stob_domain  *dom,
-					m0_bcount_t             nr,
+					struct m0_indexvec     *iv,
 					struct m0_be_tx_credit *accum)
 {
 	struct ad_domain     *adom    = domain2ad(dom);
@@ -1449,8 +1497,8 @@ static void ad_domain_stob_write_credit(struct m0_stob_domain  *dom,
 	M0_PRE(adom->ad_setup);
 	M0_PRE(dom->sd_type == &m0_ad_stob_type);
 
-	ad_write_credit(adom, nr, accum);
-	m0_stob_write_credit(adom->ad_bstore->so_domain, nr, accum);
+	ad_write_credit(adom, iv, accum);
+	m0_stob_write_credit(adom->ad_bstore->so_domain, iv, accum);
 }
 
 /**
@@ -1465,7 +1513,7 @@ static int ad_stob_io_launch(struct m0_stob_io *io)
 	struct ad_stob_io    *aio     = io->si_stob_private;
 	struct m0_be_emap_cursor it;
 	struct m0_vec_cursor  src;
-	struct m0_vec_cursor  dst;
+	struct m0_ivec_cursor dst;
 	struct m0_be_emap_caret  map;
 	struct m0_stob_io    *back    = &aio->ai_back;
 	int                   result;
@@ -1481,7 +1529,7 @@ static int ad_stob_io_launch(struct m0_stob_io *io)
 	/* only read-write at the moment */
 	M0_ASSERT(io->si_opcode == SIO_READ || io->si_opcode == SIO_WRITE);
 
-	result = ad_cursors_init(io, adom, &it, &src, &dst, &map);
+	result = ad_cursors_init(io, adom, &it, &src, &dst.ic_cur, &map);
 	if (result != 0)
 		return result;
 
@@ -1491,7 +1539,7 @@ static int ad_stob_io_launch(struct m0_stob_io *io)
 
 	switch (io->si_opcode) {
 	case SIO_READ:
-		result = ad_read_launch(io, adom, &src, &dst, &map);
+		result = ad_read_launch(io, adom, &src, &dst.ic_cur, &map);
 		break;
 	case SIO_WRITE:
 		result = ad_write_launch(io, adom, &src, &dst, &map);
@@ -1499,7 +1547,7 @@ static int ad_stob_io_launch(struct m0_stob_io *io)
 	default:
 		M0_IMPOSSIBLE("Invalid io type.");
 	}
-	ad_cursors_fini(&it, &src, &dst, &map);
+	ad_cursors_fini(&it, &src, &dst.ic_cur, &map);
 	if (result == 0) {
 		if (back->si_stob.iv_vec.v_nr > 0) {
 			/**
@@ -1603,6 +1651,7 @@ M0_INTERNAL void m0_ad_stobs_fini(void)
 
 /** @} end group stobad */
 
+#undef M0_TRACE_SUBSYSTEM
 /*
  *  Local variables:
  *  c-indentation-style: "K&R"
diff --git a/stob/stob.c b/stob/stob.c
index 91dcd43..380d5ac 100644
--- a/stob/stob.c
+++ b/stob/stob.c
@@ -105,11 +105,11 @@ m0_stob_domain_lookup(struct m0_stob_type *type, uint32_t domain_id)
 
 
 M0_INTERNAL void m0_stob_write_credit(struct m0_stob_domain  *dom,
-				      m0_bcount_t             nr,
+				      struct m0_indexvec     *ivec,
 				      struct m0_be_tx_credit *accum)
 {
 	if (dom->sd_ops->sdo_write_credit != NULL)
-		dom->sd_ops->sdo_write_credit(dom, nr, accum);
+		dom->sd_ops->sdo_write_credit(dom, ivec, accum);
 }
 
 M0_INTERNAL void m0_stob_domain_init(struct m0_stob_domain *dom,
@@ -303,9 +303,8 @@ M0_INTERNAL int m0_stob_io_launch(struct m0_stob_io *io, struct m0_stob *obj,
 		io->si_rc    = 0;
 		io->si_count = 0;
 		result = io->si_op->sio_launch(io);
-		if (result != 0) {
+		if (result != 0)
 			io->si_state = SIS_IDLE;
-		}
 	}
 	M0_POST(ergo(result != 0, io->si_state == SIS_IDLE));
 	return result;
diff --git a/stob/stob.h b/stob/stob.h
index 881fb9c..b5947fb 100644
--- a/stob/stob.h
+++ b/stob/stob.h
@@ -158,7 +158,7 @@ struct m0_stob_domain_op {
 	   Calculates the credit for write operation.
 	 */
 	void (*sdo_write_credit)(struct m0_stob_domain  *dom,
-				 m0_bcount_t             nr,
+				 struct m0_indexvec     *ivec,
 				 struct m0_be_tx_credit *accum);
 };
 
@@ -170,7 +170,7 @@ M0_INTERNAL void m0_stob_domain_init(struct m0_stob_domain *dom,
 M0_INTERNAL void m0_stob_domain_fini(struct m0_stob_domain *dom);
 
 M0_INTERNAL void m0_stob_write_credit(struct m0_stob_domain  *dom,
-				      m0_bcount_t             nr,
+				      struct m0_indexvec     *ivec,
 				      struct m0_be_tx_credit *accum);
 
 /**
diff --git a/stob/ut/ad.c b/stob/ut/ad.c
index e8dfaa5..b8d5a33 100644
--- a/stob/ut/ad.c
+++ b/stob/ut/ad.c
@@ -68,11 +68,8 @@ static const struct m0_stob_id id_fore = {
 	}
 };
 
-static const char db_name[] = "ut-ad";
-
 static struct m0_stob *obj_back;
 static struct m0_stob *obj_fore;
-static const char path[] = "./__s/o/0000000000000001.0000000000000002";
 static struct m0_stob_io io;
 static m0_bcount_t user_vec[NR];
 static char *user_buf[NR];
@@ -81,7 +78,7 @@ static char *user_bufs[NR];
 static char *read_bufs[NR];
 static m0_bindex_t stob_vec[NR];
 static struct m0_clink clink;
-static struct m0_dtx tx;
+static struct m0_dtx g_tx;
 struct m0_be_ut_backend	 ut_be;
 struct m0_be_ut_seg	 ut_seg;
 static struct m0_be_seg *db;
@@ -206,22 +203,22 @@ static int test_ad_init(void)
 	buf_size = max_check(MIN_BUF_SIZE
 			, (1 << block_shift) * MIN_BUF_SIZE_IN_BLOCKS);
 
-	m0_dtx_init(&tx, db->bs_domain, sm_grp);
-	m0_stob_create_credit(obj_fore, &tx.tx_betx_cred);
-	result = dom_fore->sd_ops->sdo_tx_make(dom_fore, &tx);
+	m0_dtx_init(&g_tx, db->bs_domain, sm_grp);
+	m0_stob_create_credit(obj_fore, &g_tx.tx_betx_cred);
+	result = dom_fore->sd_ops->sdo_tx_make(dom_fore, &g_tx);
 	M0_ASSERT(result == 0);
-	M0_ASSERT(m0_be_tx_state(&tx.tx_betx) == M0_BTS_ACTIVE);
+	M0_ASSERT(m0_be_tx_state(&g_tx.tx_betx) == M0_BTS_ACTIVE);
 
 	result = m0_stob_locate(obj_fore);
 	M0_ASSERT(result == 0 || result == -ENOENT);
 	if (result == -ENOENT) {
-		result = m0_stob_create(obj_fore, &tx);
+		result = m0_stob_create(obj_fore, &g_tx);
 		M0_ASSERT(result == 0);
 	}
 	M0_ASSERT(obj_fore->so_state == CSS_EXISTS);
-	result = m0_dtx_done_sync(&tx);
+	result = m0_dtx_done_sync(&g_tx);
 	M0_ASSERT(result == 0);
-	m0_dtx_fini(&tx);
+	m0_dtx_fini(&g_tx);
 
 	for (i = 0; i < ARRAY_SIZE(user_buf); ++i) {
 		user_buf[i] = m0_alloc_aligned(buf_size, block_shift);
@@ -265,10 +262,11 @@ static int test_ad_fini(void)
 	return 0;
 }
 
-static void test_write(int i)
+static void test_write(int nr, struct m0_dtx *tx)
 {
 	int			result;
 	struct m0_fol_rec_part *fol_rec_part;
+	bool                    is_local_tx = false;
 
 	/* @Note: This Fol record part object is not freed and shows as leak,
 	 * as it is passed as embbedded object in other places.
@@ -281,24 +279,41 @@ static void test_write(int i)
 	io.si_opcode = SIO_WRITE;
 	io.si_flags  = 0;
 	io.si_fol_rec_part = fol_rec_part;
-	io.si_user.ov_vec.v_nr = i;
+	io.si_user.ov_vec.v_nr = nr;
 	io.si_user.ov_vec.v_count = user_vec;
 	io.si_user.ov_buf = (void **)user_bufs;
 
-	io.si_stob.iv_vec.v_nr = i;
+	io.si_stob.iv_vec.v_nr = nr;
 	io.si_stob.iv_vec.v_count = user_vec;
 	io.si_stob.iv_index = stob_vec;
 
 	m0_clink_init(&clink, NULL);
 	m0_clink_add_lock(&io.si_wait, &clink);
 
-	result = m0_stob_io_launch(&io, obj_fore, &tx, NULL);
+	if (tx == NULL) {
+		tx = &g_tx;
+		m0_dtx_init(tx, db->bs_domain, sm_grp);
+		is_local_tx = true;
+	}
+	dom_fore->sd_ops->sdo_write_credit(dom_fore, &io.si_stob,
+						&tx->tx_betx_cred);
+	result = dom_fore->sd_ops->sdo_tx_make(dom_fore, tx);
 	M0_ASSERT(result == 0);
+	M0_ASSERT(m0_be_tx_state(&tx->tx_betx) == M0_BTS_ACTIVE);
+
+	result = m0_stob_io_launch(&io, obj_fore, tx, NULL);
+	M0_ASSERT(result == 0);
+
+	if (is_local_tx) {
+		result = m0_dtx_done_sync(tx);
+		M0_ASSERT(result == 0);
+		m0_dtx_fini(tx);
+	}
 
 	m0_chan_wait(&clink);
 
 	M0_ASSERT(io.si_rc == 0);
-	M0_ASSERT(io.si_count == (buf_size * i) >> block_shift);
+	M0_ASSERT(io.si_count == (buf_size * nr) >> block_shift);
 
 	m0_clink_del_lock(&clink);
 	m0_clink_fini(&clink);
@@ -325,7 +340,7 @@ static void test_read(int i)
 	m0_clink_init(&clink, NULL);
 	m0_clink_add_lock(&io.si_wait, &clink);
 
-	result = m0_stob_io_launch(&io, obj_fore, &tx, NULL);
+	result = m0_stob_io_launch(&io, obj_fore, &g_tx, NULL);
 	M0_ASSERT(result == 0);
 
 	m0_chan_wait(&clink);
@@ -341,27 +356,20 @@ static void test_read(int i)
 
 static void test_ad_rw_unordered()
 {
-	int result;
 	int i;
 
-	m0_dtx_init(&tx, db->bs_domain, sm_grp);
-	dom_fore->sd_ops->sdo_write_credit(dom_fore, NR, &tx.tx_betx_cred);
-	result = dom_fore->sd_ops->sdo_tx_make(dom_fore, &tx);
-	M0_ASSERT(result == 0);
-	M0_ASSERT(m0_be_tx_state(&tx.tx_betx) == M0_BTS_ACTIVE);
-
 	/* Unorderd write requests */
 	for (i = NR/2; i < NR; ++i) {
 		stob_vec[i-(NR/2)] = (buf_size * (i + 1)) >> block_shift;
 		memset(user_buf[i-(NR/2)], ('a' + i)|1, buf_size);
 	}
-	test_write(NR/2);
+	test_write(NR/2, NULL);
 
 	for (i = 0; i < NR/2; ++i) {
 		stob_vec[i] = (buf_size * (i + 1)) >> block_shift;
 		memset(user_buf[i], ('a' + i)|1, buf_size);
 	}
-	test_write(NR/2);
+	test_write(NR/2, NULL);
 
 	for (i = 0; i < NR; ++i) {
 		stob_vec[i] = (buf_size * (i + 1)) >> block_shift;
@@ -372,10 +380,6 @@ static void test_ad_rw_unordered()
 	test_read(NR);
 	for (i = 0; i < NR; ++i)
 		M0_ASSERT(memcmp(user_buf[i], read_buf[i], buf_size) == 0);
-
-	result = m0_dtx_done_sync(&tx);
-	M0_ASSERT(result == 0);
-	m0_dtx_fini(&tx);
 }
 
 /**
@@ -384,64 +388,56 @@ static void test_ad_rw_unordered()
 static void test_ad(void)
 {
 	int i;
-	int result;
-
-	m0_dtx_init(&tx, db->bs_domain, sm_grp);
-	dom_fore->sd_ops->sdo_write_credit(dom_fore, (NR * NR / 2),
-						&tx.tx_betx_cred);
-	result = dom_fore->sd_ops->sdo_tx_make(dom_fore, &tx);
-	M0_ASSERT(result == 0);
-	M0_ASSERT(m0_be_tx_state(&tx.tx_betx) == M0_BTS_ACTIVE);
 
-	for (i = 1; i < NR; ++i)
-		test_write(i);
+	for (i = 1; i <= NR; ++i)
+		test_write(i, NULL);
 
-	for (i = 1; i < NR; ++i) {
+	for (i = 1; i <= NR; ++i) {
 		int j;
 		test_read(i);
 		for (j = 0; j < i; ++j)
 			M0_ASSERT(memcmp(user_buf[j], read_buf[j], buf_size) == 0);
 	}
-	result = m0_dtx_done_sync(&tx);
-	M0_ASSERT(result == 0);
-	m0_dtx_fini(&tx);
 }
 
 static void test_ad_undo(void)
 {
 	int                     result;
 	struct m0_fol_rec_part *rpart;
+	struct m0_dtx           tx;
 
-	m0_dtx_init(&tx, db->bs_domain, sm_grp);
-	dom_fore->sd_ops->sdo_write_credit(dom_fore, 2, &tx.tx_betx_cred);
-	result = dom_fore->sd_ops->sdo_tx_make(dom_fore, &tx);
-	M0_UT_ASSERT(result == 0);
-	M0_ASSERT(m0_be_tx_state(&tx.tx_betx) == M0_BTS_ACTIVE);
+	m0_dtx_init(&g_tx, db->bs_domain, sm_grp);
 
 	memset(user_buf[0], 'a', buf_size);
-	test_write(1);
+	test_write(1, &g_tx);
+	result = m0_dtx_done_sync(&g_tx);
+	M0_ASSERT(result == 0);
 
 	test_read(1);
 
 	M0_ASSERT(memcmp(user_buf[0], read_bufs[0], buf_size) == 0);
 
-	rpart = m0_rec_part_tlist_head(&tx.tx_fol_rec.fr_parts);
+	rpart = m0_rec_part_tlist_head(&g_tx.tx_fol_rec.fr_parts);
 	M0_ASSERT(rpart != NULL);
 
 	/* Write new data in stob */
+	m0_dtx_init(&tx, db->bs_domain, sm_grp);
+	rpart->rp_ops->rpo_undo_credit(rpart, &tx.tx_betx_cred);
 	memset(user_buf[0], 'b', buf_size);
-	test_write(1);
+	test_write(1, &tx);
 
 	/* Do the undo operation. */
 	result = rpart->rp_ops->rpo_undo(rpart, &tx.tx_betx);
 	M0_UT_ASSERT(result == 0);
 
-	test_read(1);
-
 	result = m0_dtx_done_sync(&tx);
-	M0_ASSERT(m0_be_tx_state(&tx.tx_betx) == M0_BTS_DONE);
+	M0_ASSERT(result == 0);
 	m0_dtx_fini(&tx);
 
+	m0_dtx_fini(&g_tx);
+
+	test_read(1);
+
 	M0_ASSERT(memcmp(user_buf[0], read_bufs[0], buf_size) != 0);
 
 }
@@ -460,7 +456,7 @@ const struct m0_test_suite ad_ut = {
 
 static void ub_write(int i)
 {
-	test_write(NR - 1);
+	test_write(NR - 1, NULL);
 }
 
 static void ub_read(int i)
-- 
1.8.3.2

