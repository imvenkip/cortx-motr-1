From 03fa20afae127d503a58f8afc6c71c9cdca72885 Mon Sep 17 00:00:00 2001
From: Andriy Tkachuk <andriy_tkachuk@xyratex.com>
Date: Wed, 23 Oct 2013 17:38:48 +0300
Subject: [PATCH 06/17] ioservice/io_foms: allocate credit ivec at fom_create()

Generic fom M0_FOPH_TXN_OPEN phase, where we
calculate the credits, is not designed to return
the error. But we need to allocate the indexvec
of all IO segments to pass it to m0_stob_write_credit().

So now we allocate this array at m0_io_fom_cob_rw::fcrw_ivec
in m0_io_fom_cob_rw_create() and return error if
allocation failed.

Note: we still free that indexvec at the same
stob_write_credit() routine when we finished to
calculate the credit and the indexvec is no longer needed.

Suggested-by: Madhavrao Vemuri <madhav_vemuri@xyratex.com>
References: http://reviewboard.clusterstor.com/r/1552
---
 ioservice/io_foms.c         | 56 ++++++++++++++++++++++++---------------------
 ioservice/io_foms.h         |  7 ++++++
 ioservice/io_service_addb.h |  1 +
 3 files changed, 38 insertions(+), 26 deletions(-)

diff --git a/ioservice/io_foms.c b/ioservice/io_foms.c
index 7c4f680..1277922 100644
--- a/ioservice/io_foms.c
+++ b/ioservice/io_foms.c
@@ -1035,6 +1035,8 @@ static int m0_io_fom_cob_rw_create(struct m0_fop *fop, struct m0_fom **out,
 				   struct m0_reqh *reqh)
 {
 	int                      rc = 0;
+	int                      i;
+	uint32_t                 frags_nr = 0;
 	struct m0_fom           *fom;
 	struct m0_io_fom_cob_rw *fom_obj;
 	struct m0_fop_cob_rw    *rwfop;
@@ -1044,10 +1046,25 @@ static int m0_io_fom_cob_rw_create(struct m0_fop *fop, struct m0_fom **out,
 	M0_PRE(m0_is_io_fop(fop));
 	M0_PRE(out != NULL);
 
+	M0_ENTRY();
+
+	rwfop = io_rw_get(fop);
+
+	for (i = 0; i < rwfop->crw_ivecs.cis_nr; i++)
+		frags_nr += rwfop->crw_ivecs.cis_ivecs[i].ci_nr;
+	M0_LOG(M0_DEBUG, "frags_nr=%d", (int)frags_nr);
+
 	IOS_ALLOC_PTR(fom_obj, &m0_ios_addb_ctx, FOM_COB_RW_CREATE);
-	if (fom_obj == NULL) {
-		rc = -ENOMEM;
-		return rc;
+	if (fom_obj == NULL)
+		M0_RETURN(-ENOMEM);
+
+	if (m0_is_write_fop(fop) && frags_nr > 0) {
+		rc = m0_indexvec_alloc(&fom_obj->fcrw_ivec, frags_nr,
+			&m0_ios_addb_ctx, M0_IOS_ADDB_LOC_FOM_IVEC_ALLOC);
+		if (rc != 0) {
+			m0_free(fom_obj);
+			M0_RETURN(rc);
+		}
 	}
 
 	rep_fop = m0_is_read_fop(fop) ?
@@ -1055,8 +1072,7 @@ static int m0_io_fom_cob_rw_create(struct m0_fop *fop, struct m0_fom **out,
 		    m0_fop_alloc(&m0_fop_cob_writev_rep_fopt, NULL);
 	if (rep_fop == NULL) {
 		m0_free(fom_obj);
-		rc = -ENOMEM;
-		return rc;
+		M0_RETURN(-ENOMEM);
 	}
 
 	fom  = &fom_obj->fcrw_gen;
@@ -1069,8 +1085,6 @@ static int m0_io_fom_cob_rw_create(struct m0_fop *fop, struct m0_fom **out,
 	fom_obj->fcrw_fom_start_time = m0_time_now();
 	fom_obj->fcrw_stob = NULL;
 
-	rwfop = io_rw_get(fop);
-
 	fom_obj->fcrw_ndesc               = rwfop->crw_desc.id_nr;
 	fom_obj->fcrw_curr_desc_index     = 0;
 	fom_obj->fcrw_curr_ivec_index     = 0;
@@ -1086,7 +1100,7 @@ static int m0_io_fom_cob_rw_create(struct m0_fop *fop, struct m0_fom **out,
 	M0_LOG(M0_DEBUG, "FOM created : operation=%s, desc=%d.",
 	       m0_is_read_fop(fop) ? "READ" : "WRITE", rwfop->crw_desc.id_nr);
 
-        return rc;
+        M0_RETURN(rc);
 }
 
 /**
@@ -1728,7 +1742,6 @@ static void stob_write_credit(struct m0_fom *fom)
 	struct m0_fop_cob_rw	*rwfop;
 	struct m0_io_indexvec    wire_ivec;
 	struct m0_stob_domain	*fom_stdom;
-	struct m0_indexvec	 iv = {};
 	m0_bcount_t		*cnts;
 	m0_bindex_t		*offs;
 	int			 i;
@@ -1740,6 +1753,9 @@ static void stob_write_credit(struct m0_fom *fom)
 	fom_obj = container_of(fom, struct m0_io_fom_cob_rw, fcrw_gen);
 	M0_ASSERT(m0_io_fom_cob_rw_invariant(fom_obj));
 
+	if (fom_obj->fcrw_ivec.iv_vec.v_nr == 0)
+		return;
+
 	rwfop = io_rw_get(fom->fo_fop);
 
 	rc = stob_object_find(fom);
@@ -1753,19 +1769,8 @@ static void stob_write_credit(struct m0_fom *fom)
 	 */
 	bshift = fom_obj->fcrw_stob->so_op->sop_block_shift(fom_obj->fcrw_stob);
 
-	for (i = 0; i < rwfop->crw_ivecs.cis_nr; i++) {
-		wire_ivec = rwfop->crw_ivecs.cis_ivecs[i];
-		iv.iv_vec.v_nr += wire_ivec.ci_nr;
-	}
-	M0_LOG(M0_DEBUG, "bshift=%d vnr=%d", (int)bshift, (int)iv.iv_vec.v_nr);
-	if (iv.iv_vec.v_nr == 0)
-		goto out;
-	M0_ALLOC_ARR(iv.iv_index, iv.iv_vec.v_nr);
-	M0_ASSERT(iv.iv_index != NULL); // XXX handle this error!
-	M0_ALLOC_ARR(iv.iv_vec.v_count, iv.iv_vec.v_nr);
-	M0_ASSERT(iv.iv_vec.v_count != NULL); // XXX handle this error!
-	offs = iv.iv_index;
-	cnts = iv.iv_vec.v_count;
+	offs = fom_obj->fcrw_ivec.iv_index;
+	cnts = fom_obj->fcrw_ivec.iv_vec.v_count;
 	for (i = 0; i < rwfop->crw_ivecs.cis_nr; i++) {
 		wire_ivec = rwfop->crw_ivecs.cis_ivecs[i];
 		for (j = 0; j < wire_ivec.ci_nr; j++) {
@@ -1773,10 +1778,9 @@ static void stob_write_credit(struct m0_fom *fom)
 			*(cnts++) = wire_ivec.ci_iosegs[j].ci_count >> bshift;
 		}
 	}
-	m0_stob_write_credit(fom_stdom, &iv, m0_fom_tx_credit(fom));
-	m0_free(iv.iv_index);
-	m0_free(iv.iv_vec.v_count);
-out:
+	m0_stob_write_credit(fom_stdom, &fom_obj->fcrw_ivec,
+				m0_fom_tx_credit(fom));
+	m0_indexvec_free(&fom_obj->fcrw_ivec);
 	m0_stob_put(fom_obj->fcrw_stob);
 }
 
diff --git a/ioservice/io_foms.h b/ioservice/io_foms.h
index f43be5b..cc30e1a 100644
--- a/ioservice/io_foms.h
+++ b/ioservice/io_foms.h
@@ -183,6 +183,13 @@ struct m0_io_fom_cob_rw {
         m0_bcount_t                      fcrw_req_count;
         /** Number of bytes successfully transferred. */
         m0_bcount_t                      fcrw_count;
+
+	/**
+	 * Summary index vector representing the extent information
+	 * for the IO request. Used for BE-credit calculation.
+	 */
+	struct m0_indexvec               fcrw_ivec;
+
         /** Number of STOB I/O launched */
         int                              fcrw_num_stobio_launched;
         /** Pointer to buffer pool refered by FOM */
diff --git a/ioservice/io_service_addb.h b/ioservice/io_service_addb.h
index 06a8f6c..ee5c853 100644
--- a/ioservice/io_service_addb.h
+++ b/ioservice/io_service_addb.h
@@ -156,6 +156,7 @@ enum {
 	M0_IOS_ADDB_LOC_CREATE_BUF_POOL,
 	M0_IOS_ADDB_LOC_SERVICE_ALLOC,
 	M0_IOS_ADDB_LOC_FOM_COB_RW_CREATE,
+	M0_IOS_ADDB_LOC_FOM_IVEC_ALLOC,
 	M0_IOS_ADDB_LOC_ZERO_COPY_INITIATE_1,
 	M0_IOS_ADDB_LOC_ZERO_COPY_INITIATE_2,
 	M0_IOS_ADDB_LOC_ZERO_COPY_FINISH,
-- 
1.8.3.2

