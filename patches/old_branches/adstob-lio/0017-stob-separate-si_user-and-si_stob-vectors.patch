From f49c77747227f112c09646458859ae983fe3e79e Mon Sep 17 00:00:00 2001
From: Andriy Tkachuk <andriy_tkachuk@xyratex.com>
Date: Thu, 31 Oct 2013 11:29:08 +0200
Subject: [PATCH 17/17] stob: separate si_user and si_stob vectors

si_user and si_stob vectors should be allocated separately
if we want to pack them at linux_stob_io_launch().
---
 stob/ad.c        | 35 +++++++++++++++++++++--------------
 stob/ut/stobio.c | 13 ++++++++-----
 2 files changed, 29 insertions(+), 19 deletions(-)

diff --git a/stob/ad.c b/stob/ad.c
index 5d1bb2e..e359272 100644
--- a/stob/ad.c
+++ b/stob/ad.c
@@ -750,10 +750,8 @@ static void ad_stob_io_release(struct ad_stob_io *aio)
 {
 	struct m0_stob_io *back = &aio->ai_back;
 
-	M0_ASSERT(back->si_stob.iv_vec.v_count ==
-		  back->si_user.ov_vec.v_count);
-
 	m0_free(back->si_user.ov_vec.v_count);
+	m0_free(back->si_stob.iv_vec.v_count);
 	back->si_user.ov_vec.v_count = NULL;
 	back->si_stob.iv_vec.v_count = NULL;
 
@@ -819,29 +817,35 @@ static void ad_cursors_fini(struct m0_be_emap_cursor *it,
 static int ad_vec_alloc(struct m0_stob *obj,
 			struct m0_stob_io *back, uint32_t frags)
 {
-	m0_bcount_t *counts;
 	int          result;
 
+	M0_ENTRY("frags=%u", frags);
 	M0_ASSERT(back->si_user.ov_vec.v_count == NULL);
 
 	result = 0;
 	if (frags > 0) {
-		M0_ALLOC_ARR(counts, frags);
-		back->si_user.ov_vec.v_count = counts;
-		back->si_stob.iv_vec.v_count = counts;
+		M0_ALLOC_ARR(back->si_user.ov_vec.v_count, frags);
+		M0_ALLOC_ARR(back->si_stob.iv_vec.v_count, frags);
 		M0_ALLOC_ARR(back->si_user.ov_buf, frags);
 		M0_ALLOC_ARR(back->si_stob.iv_index, frags);
 
-		back->si_user.ov_vec.v_nr = frags;
-		back->si_stob.iv_vec.v_nr = frags;
-
-		if (counts == NULL || back->si_user.ov_buf == NULL ||
+		if (back->si_user.ov_vec.v_count == NULL ||
+		    back->si_stob.iv_vec.v_count == NULL ||
+		    back->si_user.ov_buf == NULL ||
 		    back->si_stob.iv_index == NULL) {
+			m0_free(back->si_user.ov_vec.v_count);
+			m0_free(back->si_stob.iv_vec.v_count);
+			m0_free(back->si_user.ov_buf);
+			m0_free(back->si_stob.iv_index);
 			M0_STOB_OOM(AD_VEC_ALLOC);
-			result = -ENOMEM;
+			M0_RETURN(-ENOMEM);
 		}
+
+		back->si_user.ov_vec.v_nr = frags;
+		back->si_stob.iv_vec.v_nr = frags;
 	}
-	return result;
+
+	M0_RETURN(result);
 }
 
 /**
@@ -1002,6 +1006,7 @@ static int ad_read_launch(struct m0_stob_io *io, struct ad_domain *adom,
 			back->si_user.ov_vec.v_count[idx] = frag_size;
 			back->si_user.ov_buf[idx] = buf;
 
+			back->si_stob.iv_vec.v_count[idx] = frag_size;
 			back->si_stob.iv_index[idx] = seg->ee_val +
 				(off - seg->ee_ext.e_start);
 			idx++;
@@ -1076,11 +1081,12 @@ static uint32_t ad_write_map_count(struct m0_indexvec *iv)
 	bool                   eov;
 	struct m0_ivec_cursor  it;
 
+	m0_indexvec_pack(iv);
+
 	frags = 0;
 	m0_ivec_cursor_init(&it, iv);
 	grp_size = BALLOC_DEF_BLOCKS_PER_GROUP << BALLOC_DEF_BLOCK_SHIFT;
 
-	m0_indexvec_pack(iv);
 	do {
 		frag_size = min_check(m0_ivec_cursor_step(&it), grp_size);
 		M0_ASSERT(frag_size > 0);
@@ -1150,6 +1156,7 @@ static void ad_write_back_fill(struct m0_stob_io *io, struct m0_stob_io *back,
 		back->si_user.ov_vec.v_count[idx] = frag_size;
 		back->si_user.ov_buf[idx] = buf;
 
+		back->si_stob.iv_vec.v_count[idx] = frag_size;
 		back->si_stob.iv_index[idx] =
 			wc->wc_wext->we_ext.e_start + wc->wc_done;
 
diff --git a/stob/ut/stobio.c b/stob/ut/stobio.c
index 9e08bc5..4a00fa1 100644
--- a/stob/ut/stobio.c
+++ b/stob/ut/stobio.c
@@ -79,7 +79,8 @@ struct stobio_test {
 
 	/* read/write vectors */
 	m0_bcount_t st_rdvec[RW_BUFF_NR];
-	m0_bcount_t st_wrvec[RW_BUFF_NR];
+	m0_bcount_t st_wuvec[RW_BUFF_NR];
+	m0_bcount_t st_wsvec[RW_BUFF_NR];
 };
 
 /* Test block device */
@@ -174,10 +175,10 @@ static void stobio_io_prepare(struct stobio_test *test,
 {
 	io->si_flags  = 0;
 	io->si_user.ov_vec.v_nr = RW_BUFF_NR;
-	io->si_user.ov_vec.v_count = test->st_wrvec;
+	io->si_user.ov_vec.v_count = test->st_wuvec;
 
 	io->si_stob.iv_vec.v_nr = RW_BUFF_NR;
-	io->si_stob.iv_vec.v_count = test->st_wrvec;
+	io->si_stob.iv_vec.v_count = test->st_wsvec;
 	io->si_stob.iv_index = test->st_rdvec;
 }
 
@@ -367,7 +368,8 @@ static void stobio_rwsegs_prepare(struct stobio_test *test, int starts_from)
 {
 	int i;
 	for (i = 0; i < RW_BUFF_NR; ++i) {
-		test->st_wrvec[i] = test->st_rw_buf_size_in_blocks;
+		test->st_wuvec[i] = test->st_rw_buf_size_in_blocks;
+		test->st_wsvec[i] = test->st_rw_buf_size_in_blocks;
 		test->st_rdvec[i] = test->st_rw_buf_size_in_blocks
 					* (2 * i + 1 + starts_from);
 		memset(test->st_wrbuf[i], ('a' + i) | 1, test->st_rw_buf_size);
@@ -378,7 +380,8 @@ static void stobio_rwsegs_overlapped_prepare(struct stobio_test *test, int start
 {
 	int i;
 	for (i = 0; i < RW_BUFF_NR; ++i) {
-		test->st_wrvec[i] = test->st_rw_buf_size_in_blocks;
+		test->st_wuvec[i] = test->st_rw_buf_size_in_blocks;
+		test->st_wsvec[i] = test->st_rw_buf_size_in_blocks;
 		test->st_rdvec[i] = test->st_rw_buf_size_in_blocks
 					* (i + 1 + starts_from);
 		memset(test->st_wrbuf[i], ('A' + i) | 1, test->st_rw_buf_size);
-- 
1.8.3.2

