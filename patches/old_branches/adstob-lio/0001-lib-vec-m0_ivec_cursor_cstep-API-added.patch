From 7fb5713998f64282e932ada1ba51178336906082 Mon Sep 17 00:00:00 2001
From: Andriy Tkachuk <andriy_tkachuk@xyratex.com>
Date: Mon, 21 Oct 2013 17:20:34 +0300
Subject: [PATCH 01/17] lib/vec: m0_ivec_cursor_cstep() API added

m0_ivec_cursor_cstep() counts the number of bytes
to the next _non-contiguous_ segment from the current
position of index vector cursor.
---
 lib/ut/vec.c | 42 +++++++++++++++++++++++++++++++++---------
 lib/vec.c    | 34 +++++++++++++++++++++++++++++++---
 lib/vec.h    | 16 ++++++++++++++++
 3 files changed, 80 insertions(+), 12 deletions(-)

diff --git a/lib/ut/vec.c b/lib/ut/vec.c
index 68fba5f..2eda41c 100644
--- a/lib/ut/vec.c
+++ b/lib/ut/vec.c
@@ -141,18 +141,22 @@ void test_vec(void)
 static void test_ivec_cursor(void)
 {
 	int		      nr;
-	m0_bindex_t	      segs[1];
+	m0_bindex_t	      segs[3];
 	m0_bindex_t	      index;
-	m0_bcount_t	      counts[1];
+	m0_bcount_t	      counts[3];
 	m0_bcount_t	      c;
 	struct m0_indexvec    ivec;
 	struct m0_ivec_cursor cur;
 
 	segs[0]   = 0;
-	counts[0] = 4096;
+	segs[1]   = 2;
+	segs[2]   = 8;
+	counts[0] = 2;
+	counts[1] = 2;
+	counts[2] = 4;
 
 	ivec.iv_index       = segs;
-	ivec.iv_vec.v_nr    = 1;
+	ivec.iv_vec.v_nr    = 3;
 	ivec.iv_vec.v_count = counts;
 
 	m0_ivec_cursor_init(&cur, &ivec);
@@ -160,11 +164,22 @@ static void test_ivec_cursor(void)
 	M0_UT_ASSERT(cur.ic_cur.vc_seg    == 0);
 	M0_UT_ASSERT(cur.ic_cur.vc_offset == 0);
 
-	M0_UT_ASSERT(m0_ivec_cursor_step(&cur)  == 4096);
+	M0_UT_ASSERT(m0_ivec_cursor_step(&cur)  == 2);
+	M0_UT_ASSERT(m0_ivec_cursor_cstep(&cur) == 4);
 	M0_UT_ASSERT(m0_ivec_cursor_index(&cur) == 0);
-	M0_UT_ASSERT(!m0_ivec_cursor_move(&cur, 2048));
-	M0_UT_ASSERT(m0_ivec_cursor_index(&cur) == 2048);
-	M0_UT_ASSERT(m0_ivec_cursor_move(&cur, 2048));
+	M0_UT_ASSERT(!m0_ivec_cursor_move(&cur, 1));
+	M0_UT_ASSERT(m0_ivec_cursor_index(&cur) == 1);
+	M0_UT_ASSERT(m0_ivec_cursor_step(&cur)  == 1);
+	M0_UT_ASSERT(m0_ivec_cursor_cstep(&cur) == 3);
+	M0_UT_ASSERT(!m0_ivec_cursor_move(&cur, 1));
+	M0_UT_ASSERT(m0_ivec_cursor_index(&cur) == 2);
+	M0_UT_ASSERT(m0_ivec_cursor_step(&cur)  == 2);
+	M0_UT_ASSERT(m0_ivec_cursor_cstep(&cur) == 2);
+	M0_UT_ASSERT(!m0_ivec_cursor_move(&cur, 2));
+	M0_UT_ASSERT(m0_ivec_cursor_index(&cur) == 8);
+	M0_UT_ASSERT(m0_ivec_cursor_step(&cur)  == 4);
+	M0_UT_ASSERT(m0_ivec_cursor_cstep(&cur) == 4);
+	M0_UT_ASSERT(m0_ivec_cursor_move(&cur, 4));
 
 	m0_ivec_cursor_init(&cur, &ivec);
 	c = 0;
@@ -174,7 +189,16 @@ static void test_ivec_cursor(void)
 		c = m0_ivec_cursor_step(&cur);
 		++nr;
 	}
-	M0_UT_ASSERT(nr == 1);
+	M0_UT_ASSERT(nr == 3);
+
+	m0_ivec_cursor_init(&cur, &ivec);
+	c = 0;
+	nr = 0;
+	while (!m0_ivec_cursor_move(&cur, c)) {
+		c = m0_ivec_cursor_cstep(&cur);
+		++nr;
+	}
+	M0_UT_ASSERT(nr == 2);
 }
 
 static void test_bufvec_cursor(void)
diff --git a/lib/vec.c b/lib/vec.c
index d9b84f0..6daf556 100644
--- a/lib/vec.c
+++ b/lib/vec.c
@@ -33,12 +33,11 @@
 
 M0_BASSERT(M0_SEG_SIZE == M0_0VEC_ALIGN);
 
-M0_INTERNAL m0_bcount_t m0_vec_count(const struct m0_vec *vec)
+static m0_bcount_t vec_count(const struct m0_vec *vec, uint32_t i)
 {
 	m0_bcount_t count;
-	uint32_t    i;
 
-	for (count = 0, i = 0; i < vec->v_nr; ++i) {
+	for (count = 0; i < vec->v_nr; ++i) {
 		/* overflow check */
 		M0_ASSERT(count + vec->v_count[i] >= count);
 		count += vec->v_count[i];
@@ -46,6 +45,11 @@ M0_INTERNAL m0_bcount_t m0_vec_count(const struct m0_vec *vec)
 	return count;
 }
 
+M0_INTERNAL m0_bcount_t m0_vec_count(const struct m0_vec *vec)
+{
+	return vec_count(vec, 0);
+}
+
 static bool m0_vec_cursor_invariant(const struct m0_vec_cursor *cur)
 {
 	return
@@ -108,6 +112,12 @@ M0_INTERNAL m0_bcount_t m0_vec_cursor_step(const struct m0_vec_cursor *cur)
 	return cur->vc_vec->v_count[cur->vc_seg] - cur->vc_offset;
 }
 
+M0_INTERNAL m0_bcount_t m0_vec_cursor_end(const struct m0_vec_cursor *cur)
+{
+	return m0_vec_cursor_step(cur) +
+	       vec_count(cur->vc_vec, cur->vc_seg + 1);
+}
+
 
 static int m0__bufvec_alloc(struct m0_bufvec *bufvec,
 	                    uint32_t          num_segs,
@@ -475,6 +485,24 @@ M0_INTERNAL m0_bcount_t m0_ivec_cursor_step(const struct m0_ivec_cursor *cur)
         return m0_vec_cursor_step(&cur->ic_cur);
 }
 
+M0_INTERNAL m0_bcount_t m0_ivec_cursor_cstep(const struct m0_ivec_cursor *cur)
+{
+        struct m0_indexvec	*ivec;
+	m0_bcount_t		 cstep	= m0_ivec_cursor_step(cur);
+	uint32_t		 seg;
+
+	ivec = container_of(cur->ic_cur.vc_vec, struct m0_indexvec, iv_vec);
+
+	for (seg = cur->ic_cur.vc_seg;
+	     seg < ivec->iv_vec.v_nr - 1 &&
+	       ivec->iv_index[seg] + ivec->iv_vec.v_count[seg] ==
+	       ivec->iv_index[seg + 1];
+	     seg++)
+		cstep += ivec->iv_vec.v_count[seg + 1];
+
+	return cstep;
+}
+
 M0_INTERNAL m0_bindex_t m0_ivec_cursor_index(struct m0_ivec_cursor *cur)
 {
         struct m0_indexvec *ivec;
diff --git a/lib/vec.h b/lib/vec.h
index a7feb9a..9730eff 100644
--- a/lib/vec.h
+++ b/lib/vec.h
@@ -122,6 +122,14 @@ M0_INTERNAL bool m0_vec_cursor_move(struct m0_vec_cursor *cur,
  */
 M0_INTERNAL m0_bcount_t m0_vec_cursor_step(const struct m0_vec_cursor *cur);
 
+/**
+   Return number of bytes that the cursor have to be moved to reach the
+   end of the vector position.
+
+   @pre cur->vc_seg < cur->vc_vec->v_nr
+ */
+M0_INTERNAL m0_bcount_t m0_vec_cursor_end(const struct m0_vec_cursor *cur);
+
 /** Vector of extents in a linear name-space */
 struct m0_indexvec {
 	/** Number of extents and their sizes. */
@@ -391,6 +399,14 @@ M0_INTERNAL bool m0_ivec_cursor_move_to(struct m0_ivec_cursor *cursor,
 M0_INTERNAL m0_bcount_t m0_ivec_cursor_step(const struct m0_ivec_cursor *cur);
 
 /**
+ * Returns the number of bytes needed to move cursor to next non-contiguous
+ * segment in given index vector.
+ * @param cur Index vector to be moved.
+ * @ret   Number of bytes needed to move the cursor to next segment.
+ */
+M0_INTERNAL m0_bcount_t m0_ivec_cursor_cstep(const struct m0_ivec_cursor *cur);
+
+/**
  * Returns index at current cursor position.
  * @param cur Given index vector cursor.
  * @ret   Index at current cursor position.
-- 
1.8.3.2

