From fd7a77767e5995c987d659a6b56ac9d969f03670 Mon Sep 17 00:00:00 2001
From: Andriy Tkachuk <andriy_tkachuk@xyratex.com>
Date: Mon, 28 Oct 2013 18:21:27 +0200
Subject: [PATCH 13/17] stob: IO chunks optimized at linux_stob_io_launch()

It was noticed that there are number of contiguous
chunks from si_user bufvec and si_stob indexvec
scheduled for the IO. By squashing these chunks into
larger ones we are scheduling on about 30% less
IO requests (according to log statistics observation
on writing 10Mb file) improving the performance.
---
 stob/linux_adieu.c | 38 +++++++++++++++++++-------------------
 1 file changed, 19 insertions(+), 19 deletions(-)

diff --git a/stob/linux_adieu.c b/stob/linux_adieu.c
index 1fcc2e7..66662dc 100644
--- a/stob/linux_adieu.c
+++ b/stob/linux_adieu.c
@@ -206,8 +206,8 @@ static int linux_stob_io_launch(struct m0_stob_io *io)
 	struct linux_stob    *lstob  = stob2linux(io->si_obj);
 	struct linux_domain  *ldom   = domain2linux(io->si_obj->so_domain);
 	struct linux_stob_io *lio    = io->si_stob_private;
-	struct m0_vec_cursor  src;
-	struct m0_vec_cursor  dst;
+	struct m0_bufvec_cursor src;
+	struct m0_ivec_cursor   dst;
 	uint32_t              frags;
 	m0_bcount_t           frag_size;
 	int                   result = 0;
@@ -221,22 +221,23 @@ static int linux_stob_io_launch(struct m0_stob_io *io)
 	M0_ASSERT((io->si_flags & SIF_PREFIX) == 0);
 	M0_PRE(m0_vec_count(&io->si_user.ov_vec) > 0);
 
-	m0_vec_cursor_init(&src, &io->si_user.ov_vec);
-	m0_vec_cursor_init(&dst, &io->si_stob.iv_vec);
+	m0_bufvec_cursor_init(&src, &io->si_user);
+	m0_ivec_cursor_init(&dst, &io->si_stob);
 
 	frags = 0;
 	do {
-		frag_size = min_check(m0_vec_cursor_step(&src),
-				      m0_vec_cursor_step(&dst));
+		frag_size = min_check(m0_bufvec_cursor_cstep(&src),
+				      m0_ivec_cursor_cstep(&dst));
 		M0_ASSERT(frag_size > 0);
 		frags++;
-		eosrc = m0_vec_cursor_move(&src, frag_size);
-		eodst = m0_vec_cursor_move(&dst, frag_size);
+		eosrc = m0_bufvec_cursor_move(&src, frag_size);
+		eodst = m0_ivec_cursor_move(&dst, frag_size);
 		M0_ASSERT(eosrc == eodst);
 	} while (!eosrc);
+	M0_LOG(M0_DEBUG, "frags=%u", frags);
 
-	m0_vec_cursor_init(&src, &io->si_user.ov_vec);
-	m0_vec_cursor_init(&dst, &io->si_stob.iv_vec);
+	m0_bufvec_cursor_init(&src, &io->si_user);
+	m0_ivec_cursor_init(&dst, &io->si_stob);
 
 	lio->si_nr   = frags;
 	lio->si_done = 0;
@@ -248,8 +249,8 @@ static int linux_stob_io_launch(struct m0_stob_io *io)
 			m0_bindex_t  off;
 			struct iocb *iocb;
 
-			frag_size = min_check(m0_vec_cursor_step(&src),
-					      m0_vec_cursor_step(&dst));
+			frag_size = min_check(m0_bufvec_cursor_cstep(&src),
+					      m0_ivec_cursor_cstep(&dst));
 			if (frag_size > (size_t)~0ULL) {
 				M0_STOB_FUNC_FAIL(LAD_STOB_IO_LAUNCH_1,
 						  -EOVERFLOW);
@@ -257,9 +258,8 @@ static int linux_stob_io_launch(struct m0_stob_io *io)
 				break;
 			}
 
-			buf = io->si_user.ov_buf[src.vc_seg] +
-				src.vc_offset;
-			off = io->si_stob.iv_index[dst.vc_seg] + dst.vc_offset;
+			buf = m0_bufvec_cursor_addr(&src);
+			off = m0_ivec_cursor_index(&dst);
 
 			iocb = &lio->si_qev[i].iq_iocb;
 			M0_SET0(iocb);
@@ -280,11 +280,11 @@ static int linux_stob_io_launch(struct m0_stob_io *io)
 			default:
 				M0_ASSERT(0);
 			}
-			M0_LOG(M0_DEBUG, "frag=%d op=%d sz=%d, off=%d",
-				i, io->si_opcode, (int)frag_size, (int)off);
+			M0_LOG(M0_DEBUG, "frag=%d op=%d buf=%p sz=%d, off=%d",
+			       i, io->si_opcode, buf, (int)frag_size, (int)off);
 
-			m0_vec_cursor_move(&src, frag_size);
-			m0_vec_cursor_move(&dst, frag_size);
+			m0_bufvec_cursor_move(&src, frag_size);
+			m0_ivec_cursor_move(&dst, frag_size);
 			lio->si_qev[i].iq_io = io;
 			m0_queue_link_init(&lio->si_qev[i].iq_linkage);
 		}
-- 
1.8.3.2

