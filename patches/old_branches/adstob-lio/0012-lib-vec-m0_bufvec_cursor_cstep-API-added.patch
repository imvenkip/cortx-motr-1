From 20b0db71d72f093670eb984738d13ae6444f7cb2 Mon Sep 17 00:00:00 2001
From: Andriy Tkachuk <andriy_tkachuk@xyratex.com>
Date: Mon, 28 Oct 2013 18:15:11 +0200
Subject: [PATCH 12/17] lib/vec: m0_bufvec_cursor_cstep() API added

m0_bufvec_cursor_cstep() counts the number of bytes
in contiguous bufvec chunks from the current position.
---
 lib/vec.c | 33 +++++++++++++++++++++++----------
 lib/vec.h | 13 +++++++++++++
 2 files changed, 36 insertions(+), 10 deletions(-)

diff --git a/lib/vec.c b/lib/vec.c
index 6ddd7ca..7f60613 100644
--- a/lib/vec.c
+++ b/lib/vec.c
@@ -389,26 +389,39 @@ M0_INTERNAL bool m0_bufvec_cursor_move(struct m0_bufvec_cursor *cur,
 }
 M0_EXPORTED(m0_bufvec_cursor_move);
 
-M0_INTERNAL m0_bcount_t m0_bufvec_cursor_step(const struct m0_bufvec_cursor
-					      *cur)
+M0_INTERNAL m0_bcount_t
+m0_bufvec_cursor_step(const struct m0_bufvec_cursor *cur)
 {
 	return m0_vec_cursor_step(&cur->bc_vc);
 }
 M0_EXPORTED(m0_bufvec_cursor_step);
 
-M0_INTERNAL void *bufvec_cursor_addr(struct m0_bufvec_cursor *cur)
+M0_INTERNAL m0_bcount_t
+m0_bufvec_cursor_cstep(const struct m0_bufvec_cursor *cur)
 {
-	struct m0_vec_cursor *vc = &cur->bc_vc;
-	struct m0_bufvec *bv = container_of(vc->vc_vec,struct m0_bufvec,ov_vec);
+        struct m0_bufvec	*bvec;
+	m0_bcount_t		 cstep	= m0_bufvec_cursor_step(cur);
+	uint32_t		 seg;
 
-	M0_PRE(!m0_bufvec_cursor_move(cur, 0));
-	return bv->ov_buf[vc->vc_seg] + vc->vc_offset;
+	bvec = container_of(cur->bc_vc.vc_vec, struct m0_bufvec, ov_vec);
+
+	for (seg = cur->bc_vc.vc_seg;
+	     seg < bvec->ov_vec.v_nr - 1 &&
+	       bvec->ov_buf[seg] + bvec->ov_vec.v_count[seg] ==
+	       bvec->ov_buf[seg + 1];
+	     seg++)
+		cstep += bvec->ov_vec.v_count[seg + 1];
+
+	return cstep;
 }
 
 M0_INTERNAL void *m0_bufvec_cursor_addr(struct m0_bufvec_cursor *cur)
 {
+	struct m0_vec_cursor *vc = &cur->bc_vc;
+	struct m0_bufvec *bv = container_of(vc->vc_vec,struct m0_bufvec,ov_vec);
+
 	M0_PRE(!m0_bufvec_cursor_move(cur, 0));
-	return bufvec_cursor_addr(cur);
+	return bv->ov_buf[vc->vc_seg] + vc->vc_offset;
 }
 M0_EXPORTED(m0_bufvec_cursor_addr);
 
@@ -443,8 +456,8 @@ M0_INTERNAL m0_bcount_t m0_bufvec_cursor_copy(struct m0_bufvec_cursor *dcur,
 		frag_size = min3(m0_bufvec_cursor_step(dcur),
 				 m0_bufvec_cursor_step(scur),
 				 num_bytes);
-		memmove(bufvec_cursor_addr(dcur),
-			bufvec_cursor_addr(scur),
+		memmove(m0_bufvec_cursor_addr(dcur),
+			m0_bufvec_cursor_addr(scur),
 			frag_size);
 		num_bytes -= frag_size;
 		bytes_copied += frag_size;
diff --git a/lib/vec.h b/lib/vec.h
index 032576f..b1c82c2 100644
--- a/lib/vec.h
+++ b/lib/vec.h
@@ -319,6 +319,19 @@ M0_INTERNAL m0_bcount_t m0_bufvec_cursor_step(const struct m0_bufvec_cursor
 					      *cur);
 
 /**
+   Return number of bytes that the cursor have to be moved to reach the next
+   non-contiguous segment in its vector (or to move into end of the vector
+   position, when the cursor is already at the last segment).
+
+   @pre !m0_bufvec_cursor_move(cur, 0)
+   @see m0_bufvec_cursor_step()
+   @param cur Pointer to the struct m0_bufvec_cursor.
+   @retval Count
+ */
+M0_INTERNAL m0_bcount_t m0_bufvec_cursor_cstep(const struct m0_bufvec_cursor
+					       *cur);
+
+/**
    Return the buffer address at the cursor's current position.
    @pre !m0_bufvec_cursor_move(cur, 0)
    @see m0_bufvec_cursor_copy()
-- 
1.8.3.2

