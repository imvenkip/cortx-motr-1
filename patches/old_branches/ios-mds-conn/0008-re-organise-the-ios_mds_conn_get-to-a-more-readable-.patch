From 4c1761aff73d30aace3cdb862e12c5f104ccd9dc Mon Sep 17 00:00:00 2001
From: Hua Huang <hua_huang@xyratex.com>
Date: Wed, 10 Apr 2013 16:54:11 +0800
Subject: [PATCH 08/10] re-organise the ios_mds_conn_get to a more readable
 way, according to vvv.

---
 ioservice/io_service.c | 60 +++++++++++++++++++++++++++++---------------------
 ioservice/io_service.h |  2 --
 2 files changed, 35 insertions(+), 27 deletions(-)

diff --git a/ioservice/io_service.c b/ioservice/io_service.c
index 6302b0e..5fec5ef 100644
--- a/ioservice/io_service.c
+++ b/ioservice/io_service.c
@@ -601,8 +601,8 @@ enum {
 	MAX_NR_RPC_IN_FLIGHT = 5,
 };
 
-M0_INTERNAL int m0_ios_mds_conn_init(struct m0_reqh *reqh,
-				     struct m0_ios_mds_conn *conn)
+static int m0_ios_mds_conn_init(struct m0_reqh *reqh,
+				struct m0_ios_mds_conn *conn)
 {
 	struct m0_mero        *mero;
 	struct m0_rpc_machine *rpc_machine;
@@ -641,35 +641,45 @@ M0_INTERNAL int m0_ios_mds_conn_init(struct m0_reqh *reqh,
 	M0_RETURN(rc);
 }
 
+/* Assumes that reqh->rh_rwlock is locked for writing. */
+static int ios_mds_conn_get_locked(struct m0_reqh *reqh,
+				   struct m0_ios_mds_conn **out,
+				   bool *new)
+{
+	M0_PRE(ios_mds_conn_key != 0);
+
+	*new = false;
+	*out = m0_reqh_lockers_get(reqh, ios_mds_conn_key);
+	if (*out != NULL)
+		return 0;
+
+	M0_ALLOC_PTR(*out);
+	if (*out == NULL)
+		return -ENOMEM;
+	*new = true;
+
+	m0_reqh_lockers_set(reqh, ios_mds_conn_key, *out);
+	return 0;
+}
+
 M0_INTERNAL int m0_ios_mds_conn_get(struct m0_reqh *reqh,
-				    struct m0_ios_mds_conn **out_conn)
+				    struct m0_ios_mds_conn **out)
 {
-	struct m0_ios_mds_conn *imc;
-	int                     rc = 0;
+	int  rc;
+	bool new;
+
+	M0_ENTRY("reqh %p", reqh);
 	M0_PRE(reqh != NULL);
-	M0_PRE(ios_mds_conn_key != 0);
 
-	M0_LOG(M0_DEBUG, "Get imc in reqh = %p", reqh);
 	m0_rwlock_write_lock(&reqh->rh_rwlock);
-	imc = m0_reqh_lockers_get(reqh, ios_mds_conn_key);
-	if (imc == NULL) {
-		M0_LOG(M0_DEBUG, "Alloc a new imc in reqh = %p", reqh);
-		M0_ALLOC_PTR(imc);
-		if (imc == NULL) {
-			rc = -ENOMEM;
-			m0_rwlock_write_unlock(&reqh->rh_rwlock);
-			return rc;
-		}
-		m0_reqh_lockers_set(reqh, ios_mds_conn_key, imc);
-		m0_rwlock_write_unlock(&reqh->rh_rwlock);
-		/* newly allocated. start connection after unlock. */
-		rc = m0_ios_mds_conn_init(reqh, imc);
-	} else {
-		/* found. unlock */
-		m0_rwlock_write_unlock(&reqh->rh_rwlock);
+	rc = ios_mds_conn_get_locked(reqh, out, &new);
+	m0_rwlock_write_unlock(&reqh->rh_rwlock);
+
+	if (new) {
+		M0_ASSERT(rc == 0);
+		rc = m0_ios_mds_conn_init(reqh, *out);
 	}
-	*out_conn = imc;
-	return rc;
+	M0_RETURN(rc);
 }
 
 M0_INTERNAL void m0_ios_mds_conn_fini(struct m0_reqh *reqh)
diff --git a/ioservice/io_service.h b/ioservice/io_service.h
index 0707210..b4e314b 100644
--- a/ioservice/io_service.h
+++ b/ioservice/io_service.h
@@ -127,8 +127,6 @@ struct m0_ios_mds_conn {
 	bool                  imc_connected;
 };
 
-M0_INTERNAL int m0_ios_mds_conn_init(struct m0_reqh *reqh,
-				     struct m0_ios_mds_conn *conn);
 M0_INTERNAL int m0_ios_mds_conn_get(struct m0_reqh *reqh,
 				    struct m0_ios_mds_conn **out_conn);
 
-- 
1.8.3.2

