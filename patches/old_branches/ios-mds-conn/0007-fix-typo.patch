From c1ef8134c00cb48d360ebddfd8c1ac325d4ab7f3 Mon Sep 17 00:00:00 2001
From: Hua Huang <hua_huang@xyratex.com>
Date: Wed, 10 Apr 2013 12:22:47 +0800
Subject: [PATCH 07/10] fix typo. free imc struct. remove warning message for
 optional -G. restore set state to DRAIN in m0_reqh_shutdown_wait(). add
 rso_fop_accept() for rpcservice. This allows any fop for rpcservice in any
 state.

---
 ioservice/io_service.c | 14 +++++++-------
 ioservice/io_service.h |  2 +-
 mero/setup.c           |  4 ----
 reqh/reqh.c            | 12 ++++++------
 rpc/rpc.c              | 12 +++++++++---
 5 files changed, 23 insertions(+), 21 deletions(-)

diff --git a/ioservice/io_service.c b/ioservice/io_service.c
index 4896a2b..6302b0e 100644
--- a/ioservice/io_service.c
+++ b/ioservice/io_service.c
@@ -631,10 +631,10 @@ M0_INTERNAL int m0_ios_mds_conn_init(struct m0_reqh *reqh,
 				   MAX_NR_RPC_IN_FLIGHT, NR_SLOTS_PER_SESSION,
 				   RPC_TIMEOUT);
 	if (rc == 0) {
-		conn->imc_connectted = true;
-		M0_LOG(M0_DEBUG, "Ios connectted to mds %s", srv_ep_addr);
+		conn->imc_connected = true;
+		M0_LOG(M0_DEBUG, "Ios connected to mds %s", srv_ep_addr);
 	} else {
-		conn->imc_connectted = false;
+		conn->imc_connected = false;
 		M0_LOG(M0_ERROR, "Ios could not connect to mds %s: rc = %d",
 				 srv_ep_addr, rc);
 	}
@@ -686,7 +686,7 @@ M0_INTERNAL void m0_ios_mds_conn_fini(struct m0_reqh *reqh)
 	m0_rwlock_write_unlock(&reqh->rh_rwlock);
 
 	M0_LOG(M0_DEBUG, "imc conn fini in reqh = %p, imc = %p", reqh, imc);
-	if (imc != NULL && imc->imc_connectted) {
+	if (imc != NULL && imc->imc_connected) {
 		M0_LOG(M0_DEBUG, "destroy session for %p", imc);
 		rc = m0_rpc_session_destroy(&imc->imc_session,
 					    m0_time_from_now(RPC_TIMEOUT, 0));
@@ -698,8 +698,8 @@ M0_INTERNAL void m0_ios_mds_conn_fini(struct m0_reqh *reqh)
 					 m0_time_from_now(RPC_TIMEOUT, 0));
 		if (rc != 0)
 			M0_LOG(M0_ERROR, "Failed to terminate connection %d", rc);
-		m0_free(imc);
 	}
+	m0_free(imc); /* free(NULL) is OK */
 }
 
 /**
@@ -724,7 +724,7 @@ M0_INTERNAL int m0_ios_mds_getattr(struct m0_reqh *reqh,
 	rc = m0_ios_mds_conn_get(reqh, &imc);
 	if (rc != 0)
 		return rc;
-	if (!imc->imc_connectted)
+	if (!imc->imc_connected)
 		return -ENODEV;
 
 	req = m0_fop_alloc(&m0_fop_getattr_fopt, NULL);
@@ -779,7 +779,7 @@ M0_INTERNAL int m0_ios_mds_layout_get(struct m0_reqh *reqh,
 	rc = m0_ios_mds_conn_get(reqh, &imc);
 	if (rc != 0)
 		return rc;
-	if (!imc->imc_connectted)
+	if (!imc->imc_connected)
 		return -ENODEV;
 
 	req = m0_fop_alloc(&m0_fop_layout_fopt, NULL);
diff --git a/ioservice/io_service.h b/ioservice/io_service.h
index 3e6a1f8..0707210 100644
--- a/ioservice/io_service.h
+++ b/ioservice/io_service.h
@@ -124,7 +124,7 @@ M0_INTERNAL void m0_ios_cdom_fini(struct m0_reqh *reqh);
 struct m0_ios_mds_conn {
 	struct m0_rpc_conn    imc_conn;
 	struct m0_rpc_session imc_session;
-	bool                  imc_connectted;
+	bool                  imc_connected;
 };
 
 M0_INTERNAL int m0_ios_mds_conn_init(struct m0_reqh *reqh,
diff --git a/mero/setup.c b/mero/setup.c
index 914a9f5..cd8bc9c 100644
--- a/mero/setup.c
+++ b/mero/setup.c
@@ -1727,10 +1727,6 @@ static int reqh_ctxs_are_valid(struct m0_mero *cctx)
 		}
 	} m0_tl_endfor;
 
-	if (cctx->cc_mds_epx.ex_endpoint == NULL)
-		M0_LOG(M0_WARN, "Missing mdservice endpoint.\n"
-				 "Use -G to provide a valid one");
-
 	if (cctx->cc_pool_width <= 0) {
 		M0_LOG(M0_ERROR, "Invalid pool width.\n"
 				 "Use -w to provide a valid integer");
diff --git a/reqh/reqh.c b/reqh/reqh.c
index d6be26e..f319ab7 100644
--- a/reqh/reqh.c
+++ b/reqh/reqh.c
@@ -388,6 +388,12 @@ M0_INTERNAL void m0_reqh_shutdown_wait(struct m0_reqh *reqh)
 	struct m0_reqh_service *rpcservice = NULL;
 
 	M0_PRE(reqh != NULL);
+	m0_rwlock_write_lock(&reqh->rh_rwlock);
+	M0_PRE(m0_reqh_invariant(reqh));
+	M0_PRE(m0_reqh_state_get(reqh) == M0_REQH_ST_NORMAL);
+	reqh_state_set(reqh, M0_REQH_ST_DRAIN);
+	m0_rwlock_write_unlock(&reqh->rh_rwlock);
+
 	m0_tl_for(m0_reqh_svc, &reqh->rh_services, service) {
 		M0_ASSERT(m0_reqh_service_invariant(service));
 		/* skip mdservice in first loop */
@@ -410,12 +416,6 @@ M0_INTERNAL void m0_reqh_shutdown_wait(struct m0_reqh *reqh)
 	if (rpcservice != NULL)
 		m0_reqh_service_prepare_to_stop(rpcservice);
 
-	m0_rwlock_write_lock(&reqh->rh_rwlock);
-	M0_PRE(m0_reqh_invariant(reqh));
-	M0_PRE(m0_reqh_state_get(reqh) == M0_REQH_ST_NORMAL);
-	reqh_state_set(reqh, M0_REQH_ST_DRAIN);
-	m0_rwlock_write_unlock(&reqh->rh_rwlock);
-
 	m0_reqh_fom_domain_idle_wait(reqh);
 }
 
diff --git a/rpc/rpc.c b/rpc/rpc.c
index 02b50e6..0eeb649 100644
--- a/rpc/rpc.c
+++ b/rpc/rpc.c
@@ -60,10 +60,16 @@ static void rpc_service_fini(struct m0_reqh_service *service)
 	m0_free(service);
 }
 
+static int rpc_service_fop_accept(struct m0_reqh_service *service,
+				  struct m0_fop *fop)
+{
+	return 0;
+}
 static const struct m0_reqh_service_ops rpc_ops = {
-	.rso_start = rpc_service_start,
-	.rso_stop = rpc_service_stop,
-	.rso_fini = rpc_service_fini
+	.rso_start      = rpc_service_start,
+	.rso_stop       = rpc_service_stop,
+	.rso_fini       = rpc_service_fini,
+	.rso_fop_accept = rpc_service_fop_accept
 };
 
 static int rpc_service_allocate(struct m0_reqh_service **service,
-- 
1.8.3.2

