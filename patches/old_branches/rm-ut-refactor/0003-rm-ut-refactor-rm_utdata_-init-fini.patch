From ce594b2a7ed62c008b9a8a47fc600ec62482ccb5 Mon Sep 17 00:00:00 2001
From: "Valery V. Vorotyntsev" <valery_vorotyntsev@xyratex.com>
Date: Thu, 16 May 2013 14:50:47 +0300
Subject: [PATCH 3/4] rm/ut: refactor rm_utdata_{init,fini}()

The "recursive" implementation of these functions hindered the
comprehension of the logic badly. New implementation can be read
from top to bottom, the code has no "jumps".  Now one can clearly
see, how to setup and tear down m0_rm structures.

Rename:
  rm_utdata_init() -> rm_ut_setup();
  rm_utdata_fini() -> rm_ut_teardown().

+ Fix a bug: rm_utdata_fini() used to call m0_rm_domain_init()
instead of m0_rm_domain_fini().
---
 rm/ut/lcredits.c    |   4 +-
 rm/ut/rcredits.c    |   8 +--
 rm/ut/rm_foms.c     |  12 ++---
 rm/ut/rm_fops.c     |  10 ++--
 rm/ut/rm_service.c  |   4 +-
 rm/ut/rmapi.c       |  16 +++---
 rm/ut/rmut.c        | 139 ++++++++++++++++++++--------------------------------
 rm/ut/rmut.h        |  26 +++++-----
 ut/ut_rpc_machine.c |   1 -
 9 files changed, 91 insertions(+), 129 deletions(-)

diff --git a/rm/ut/lcredits.c b/rm/ut/lcredits.c
index 2f0fb45..58f5fcf 100644
--- a/rm/ut/lcredits.c
+++ b/rm/ut/lcredits.c
@@ -49,7 +49,7 @@ const struct m0_rm_incoming_ops lcredits_incoming_ops = {
 
 static void local_credits_init(void)
 {
-	rm_utdata_init(&test_data, OBJ_OWNER);
+	rm_ut_setup(&test_data, RUM_DEFAULT);
 	rm_test_owner_capital_raise(&test_data.rd_owner, &test_data.rd_credit);
 	M0_SET0(&test_data.rd_in);
 	m0_chan_init(&lcredits_chan, &test_data.rd_rt.rt_lock);
@@ -58,7 +58,7 @@ static void local_credits_init(void)
 static void local_credits_fini(void)
 {
 	m0_chan_fini_lock(&lcredits_chan);
-	rm_utdata_fini(&test_data, OBJ_OWNER);
+	rm_ut_teardown(&test_data, RUM_DEFAULT);
 }
 
 static void cached_credits_test(enum m0_rm_incoming_flags flags)
diff --git a/rm/ut/rcredits.c b/rm/ut/rcredits.c
index 7eba814..43e0c76 100644
--- a/rm/ut/rcredits.c
+++ b/rm/ut/rcredits.c
@@ -171,7 +171,7 @@ static void server_start(enum rm_server srv_id)
 	enum rm_server	     cred_id = rm_ctx[srv_id].creditor_id;
 	enum rm_server	     debt_id = rm_ctx[srv_id].debtor_id;
 
-	rm_utdata_init(&rm_ctx[srv_id].rc_test_data, OBJ_OWNER);
+	rm_ut_setup(&rm_ctx[srv_id].rc_test_data, RUM_DEFAULT);
 	/*
 	 * If creditor id is valid, do creditor setup.
 	 * If there is no creditor, this server is original owner.
@@ -195,8 +195,8 @@ static void server_stop(enum rm_server srv_id)
 {
 	struct m0_rm_remote *creditor;
 	struct m0_rm_owner  *owner = &rm_ctx[srv_id].rc_test_data.rd_owner;
-	enum rm_server	     cred_id = rm_ctx[srv_id].creditor_id;
-	enum rm_server	     debt_id = rm_ctx[srv_id].debtor_id;
+	enum rm_server      cred_id = rm_ctx[srv_id].creditor_id;
+	enum rm_server      debt_id = rm_ctx[srv_id].debtor_id;
 
 	if (cred_id != SERVER_INVALID) {
 		creditor = owner->ro_creditor;
@@ -205,7 +205,7 @@ static void server_stop(enum rm_server srv_id)
 		m0_free(creditor);
 		owner->ro_creditor = NULL;
 	}
-	rm_utdata_fini(&rm_ctx[srv_id].rc_test_data, OBJ_OWNER);
+	rm_ut_teardown(&rm_ctx[srv_id].rc_test_data, RUM_DEFAULT);
 	if (cred_id != SERVER_INVALID)
 		rm_disconnect(&rm_ctx[srv_id], &rm_ctx[cred_id]);
 	if (debt_id != SERVER_INVALID)
diff --git a/rm/ut/rm_foms.c b/rm/ut/rm_foms.c
index 26a4a4c..735fddd 100644
--- a/rm/ut/rm_foms.c
+++ b/rm/ut/rm_foms.c
@@ -320,8 +320,7 @@ static void brw_fom_state_test(enum test_type test)
 	struct m0_fop *fop;
 	int	       rc;
 
-	/* Initialise hierarchy of RM objects */
-	rm_utdata_init(&test_data, OBJ_OWNER);
+	rm_ut_setup(&test_data, RUM_DEFAULT);
 
 	/* Add self-loan to the test owner object */
 	rm_test_owner_capital_raise(&test_data.rd_owner, &test_data.rd_credit);
@@ -354,7 +353,7 @@ static void brw_fom_state_test(enum test_type test)
 
 	fom_fini(fom, M0_RIT_BORROW);
 	brw_test_cleanup();
-	rm_utdata_fini(&test_data, OBJ_OWNER);
+	rm_ut_teardown(&test_data, RUM_DEFAULT);
 }
 
 /*
@@ -535,13 +534,10 @@ static void rvk_fom_state_test(enum test_type test)
 	struct m0_fop *fop;
 	int	       rc;
 
-	/* Initialise hierarchy of RM objects */
-	rm_utdata_init(&test_data, OBJ_OWNER);
-
+	rm_ut_setup(&test_data, RUM_DEFAULT);
 	rvk_data_setup(test);
 
 	fop = fop_alloc(M0_RIT_REVOKE);
-
 	fom_create(M0_RIT_REVOKE, false, fop, &fom);
 	M0_UT_ASSERT(fom != NULL);
 
@@ -564,7 +560,7 @@ static void rvk_fom_state_test(enum test_type test)
 	rvk_fom_state_validate(fom, rc, test);
 
 	fom_fini(fom, M0_RIT_REVOKE);
-	rm_utdata_fini(&test_data, OBJ_OWNER);
+	rm_ut_teardown(&test_data, RUM_DEFAULT);
 }
 
 /*
diff --git a/rm/ut/rm_fops.c b/rm/ut/rm_fops.c
index d5e2554..76ae698 100644
--- a/rm/ut/rm_fops.c
+++ b/rm/ut/rm_fops.c
@@ -524,8 +524,7 @@ static void revoke_reply_test(void)
  */
 static void borrow_fop_funcs_test(void)
 {
-	/* Initialise hierarchy of RM objects */
-	rm_utdata_init(&test_data, OBJ_OWNER);
+	rm_ut_setup(&test_data, RUM_DEFAULT);
 
 	/* 1. Test m0_rm_request_out() - sending BORROW FOP */
 	borrow_request_test();
@@ -533,13 +532,12 @@ static void borrow_fop_funcs_test(void)
 	/* 2. Test borrow_reply() - reply for BORROW FOP */
 	borrow_reply_test();
 
-	rm_utdata_fini(&test_data, OBJ_OWNER);
+	rm_ut_teardown(&test_data, RUM_DEFAULT);
 }
 
 static void revoke_fop_funcs_test(void)
 {
-	/* Initialise hierarchy of RM objects */
-	rm_utdata_init(&test_data, OBJ_OWNER);
+	rm_ut_setup(&test_data, RUM_DEFAULT);
 
 	/* 1. Test m0_rm_request_out() - sending REVOKE FOP */
 	revoke_request_test();
@@ -547,7 +545,7 @@ static void revoke_fop_funcs_test(void)
 	/* 2. Test revoke_reply() - reply for REVOKE FOP */
 	revoke_reply_test();
 
-	rm_utdata_fini(&test_data, OBJ_OWNER);
+	rm_ut_teardown(&test_data, RUM_DEFAULT);
 }
 
 void rm_fop_funcs_test(void)
diff --git a/rm/ut/rm_service.c b/rm/ut/rm_service.c
index 1ec55d1..d792d25 100644
--- a/rm/ut/rm_service.c
+++ b/rm/ut/rm_service.c
@@ -122,7 +122,7 @@ static void rm_client(const int tid)
 	M0_ALLOC_PTR(resource);
 	M0_UT_ASSERT(resource != NULL);
 
-	rm_utdata_init(&test_data, OBJ_OWNER);
+	rm_ut_setup(&test_data, RUM_DEFAULT);
 
 	resource->r_type = &test_data.rd_rt;
 	resource->r_ops  = &rings_ops;
@@ -152,7 +152,7 @@ static void rm_client(const int tid)
 	m0_chan_signal_lock(&rr_tests_chan);
 	/* Wait for server to stop */
 	m0_chan_wait(&tests_clink[SERVER_1]);
-	rm_utdata_fini(&test_data, OBJ_OWNER);
+	rm_ut_teardown(&test_data, RUM_DEFAULT);
 	m0_rm_remote_fini(creditor);
 	m0_free(resource);
 	m0_free(creditor);
diff --git a/rm/ut/rmapi.c b/rm/ut/rmapi.c
index 97ec31f..0a135cd 100644
--- a/rm/ut/rmapi.c
+++ b/rm/ut/rmapi.c
@@ -45,7 +45,7 @@ static void credits_api_test (void)
 {
 	int rc;
 
-	rm_utdata_init(&test_data, OBJ_OWNER);
+	rm_ut_setup(&test_data, RUM_DEFAULT);
 
 	/* 1. Test m0_rm_incoming_init() */
 	m0_rm_incoming_init(&test_data.rd_in, &test_data.rd_owner,
@@ -107,12 +107,12 @@ static void credits_api_test (void)
 	/* Test m0_rm_incoming_fini */
 	m0_rm_incoming_fini(&test_data.rd_in);
 
-	rm_utdata_fini(&test_data, OBJ_OWNER);
+	rm_ut_teardown(&test_data, RUM_DEFAULT);
 }
 
-static void owner_api_test (void)
+static void owner_api_test(void)
 {
-	rm_utdata_init(&test_data, OBJ_RES);
+	rm_ut_setup(&test_data, RUM_RESOURCE);
 
 	/*
 	 * 1. Test m0_rm_owner_init
@@ -140,12 +140,12 @@ static void owner_api_test (void)
 	M0_UT_ASSERT(test_data.rd_owner.ro_resource == NULL);
 	M0_UT_ASSERT(test_data.rd_res.rs_resource.r_ref == 0);
 
-	rm_utdata_fini(&test_data, OBJ_RES);
+	rm_ut_teardown(&test_data, RUM_RESOURCE);
 }
 
 static void res_api_test(void)
 {
-	rm_utdata_init(&test_data, OBJ_RES_TYPE);
+	rm_ut_setup(&test_data, RUM_RESOURCE_TYPE);
 
 	M0_SET0(&test_data.rd_res);
 	/* 1. Test m0_rm_resource_add */
@@ -167,12 +167,12 @@ static void res_api_test(void)
 	M0_UT_ASSERT(res_tlist_is_empty(&test_data.rd_rt.rt_resources));
 	m0_mutex_unlock(&test_data.rd_rt.rt_lock);
 
-	rm_utdata_fini(&test_data, OBJ_RES_TYPE);
+	rm_ut_teardown(&test_data, RUM_RESOURCE_TYPE);
 }
 
 static void rt_api_test(void)
 {
-	rm_utdata_init(&test_data, OBJ_RES_TYPE);
+	rm_ut_setup(&test_data, RUM_RESOURCE_TYPE);
 
 	M0_UT_ASSERT(test_data.rd_rt.rt_dom == &test_data.rd_dom);
 	M0_UT_ASSERT(test_data.rd_dom.rd_types[0] == &test_data.rd_rt);
diff --git a/rm/ut/rmut.c b/rm/ut/rmut.c
index f35269a..92d4df9 100644
--- a/rm/ut/rmut.c
+++ b/rm/ut/rmut.c
@@ -1,4 +1,3 @@
-/* -*- C -*- */
 /*
  * COPYRIGHT 2013 XYRATEX TECHNOLOGY LIMITED
  *
@@ -29,10 +28,7 @@
 
 extern const struct m0_tl_descr m0_remotes_tl;
 
-/*
- * Test variable(s)
- */
-M0_INTERNAL struct rm_ut_data	   test_data;
+M0_INTERNAL struct rm_ut_data test_data;
 
 extern void rm_api_test(void);
 extern void local_credits_test(void);
@@ -43,8 +39,6 @@ extern bool m0_rm_ur_tlist_is_empty(const struct m0_tl *list);
 extern void m0_remotes_tlist_del(struct m0_rm_remote *other);
 extern void rmsvc(void);
 
-struct rm_ut_data test_data;
-
 void rm_test_owner_capital_raise(struct m0_rm_owner *owner,
 				 struct m0_rm_credit *credit)
 {
@@ -55,100 +49,75 @@ void rm_test_owner_capital_raise(struct m0_rm_owner *owner,
 	M0_UT_ASSERT(!m0_rm_ur_tlist_is_empty(&owner->ro_owned[OWOS_CACHED]));
 }
 
-/*
- * Recursive call to initialise object hierarchy
- */
-void rm_utdata_init(struct rm_ut_data *data, enum obj_type type)
+void rm_ut_setup(struct rm_ut_data *data, enum rm_ut_mode mode)
 {
 	int rc;
 
-	M0_UT_ASSERT(data != NULL);
+	m0_rm_domain_init(&data->rd_dom);
 
-	switch (type) {
-		case OBJ_DOMAIN:
-			/* Initialise test_domain */
-			m0_rm_domain_init(&data->rd_dom);
-			break;
-		case OBJ_RES_TYPE:
-			rm_utdata_init(data, OBJ_DOMAIN);
-			/* Register test resource type */
-			rc = m0_rm_type_register(&data->rd_dom, &data->rd_rt);
-			M0_UT_ASSERT(rc == 0);
-			data->rd_rt.rt_ops = &rings_rtype_ops;
-			break;
-		case OBJ_RES:
-			rm_utdata_init(data, OBJ_RES_TYPE);
-			M0_SET0(&data->rd_res);
-			data->rd_res.rs_resource.r_ops = &rings_ops;
-			m0_rm_resource_add(&data->rd_rt,
-					   &data->rd_res.rs_resource);
-			break;
-		case OBJ_OWNER:
-			rm_utdata_init(data, OBJ_RES);
-			m0_rm_owner_init(&data->rd_owner,
-					 &data->rd_res.rs_resource, NULL);
-			break;
+	data->rd_rt.rt_ops = &rings_rtype_ops;
+	rc = m0_rm_type_register(&data->rd_dom, &data->rd_rt);
+	M0_UT_ASSERT(rc == 0);
+	if (mode == RUM_RESOURCE_TYPE)
+		return;
 
-		default:
-			M0_IMPOSSIBLE("Invalid value of obj_type");
-	}
+	M0_SET0(&data->rd_res);
+	data->rd_res.rs_resource.r_ops = &rings_ops;
+	m0_rm_resource_add(&data->rd_rt, &data->rd_res.rs_resource);
+	if (mode == RUM_RESOURCE)
+		return;
+
+	M0_ASSERT(mode == RUM_DEFAULT);
+	m0_rm_owner_init(&data->rd_owner, &data->rd_res.rs_resource, NULL);
 }
 
-/*
- * Recursive call to finalise object hierarchy
- */
-void rm_utdata_fini(struct rm_ut_data *data, enum obj_type type)
+void rm_ut_teardown(struct rm_ut_data *data, enum rm_ut_mode mode)
 {
-	struct m0_rm_remote *other;
+	struct m0_rm_remote *remote;
 	struct m0_rm_credit *credit;
 
-	M0_UT_ASSERT(data != NULL);
-
-	switch (type) {
-		case OBJ_DOMAIN:
-			/* Finalise test_domain */
-			m0_rm_domain_init(&data->rd_dom);
-			break;
-		case OBJ_RES_TYPE:
-			/* De-register test resource type */
-			m0_rm_type_deregister(&data->rd_rt);
-			rm_utdata_fini(data, OBJ_DOMAIN);
-			break;
-		case OBJ_RES:
-			m0_tl_for(m0_remotes,
-				  &data->rd_res.rs_resource.r_remote, other) {
-				m0_remotes_tlist_del(other);
-				m0_rm_remote_fini(other);
-				m0_free(other);
-			} m0_tl_endfor;
-			m0_rm_resource_del(&data->rd_res.rs_resource);
-			rm_utdata_fini(data, OBJ_RES_TYPE);
-			break;
-		case OBJ_OWNER:
-			m0_rm_owner_windup(&data->rd_owner);
-
-			data->rd_owner.ro_creditor = NULL;
-			m0_tl_for(m0_rm_ur, &data->rd_owner.ro_borrowed,
-				  credit) {
-				m0_rm_ur_tlist_del(credit);
-			} m0_tl_endfor;
-			m0_rm_owner_fini(&data->rd_owner);
-			rm_utdata_fini(data, OBJ_RES);
-			break;
-		default:
-			M0_IMPOSSIBLE("Invalid value of obj_type");
+	switch (mode) {
+	case RUM_DEFAULT:
+		m0_rm_owner_windup(&data->rd_owner);
+		data->rd_owner.ro_creditor = NULL;
+		m0_tl_for(m0_rm_ur, &data->rd_owner.ro_borrowed, credit) {
+			m0_rm_ur_tlist_del(credit);
+		} m0_tl_endfor;
+		m0_rm_owner_fini(&data->rd_owner);
+		/* fall through */
+	case RUM_RESOURCE:
+		/*
+		 * This is wrong that we need to put that much logic into a
+		 * UT destructor.
+		 *
+		 * XXX TODO: rm layer should provide a suitable interface.
+		 */
+		m0_tl_for(m0_remotes, &data->rd_res.rs_resource.r_remote,
+			  remote) {
+			m0_remotes_tlist_del(remote);
+			m0_rm_remote_fini(remote);
+			m0_free(remote);
+		} m0_tl_endfor;
+		m0_rm_resource_del(&data->rd_res.rs_resource);
+		/* fall through */
+	case RUM_RESOURCE_TYPE:
+		m0_rm_type_deregister(&data->rd_rt);
+		m0_rm_domain_fini(&data->rd_dom);
+		return;
+	default:
+		M0_IMPOSSIBLE("Invalid value of rm_ut_mode");
 	}
 }
 
 const struct m0_test_suite rm_ut = {
 	.ts_name = "rm-ut",
 	.ts_tests = {
-		{ "api", rm_api_test },
-		{ "lcredits", local_credits_test },
-		{ "fom-funcs", rm_fom_funcs_test },
-		{ "fop-funcs", rm_fop_funcs_test },
-		{ "rcredits", remote_credits_test },
-		{ "rmsvc", rmsvc },
+		{ "api",            rm_api_test },
+		{ "local-credits",  local_credits_test },
+		{ "fom-funcs",      rm_fom_funcs_test },
+		{ "fop-funcs",      rm_fop_funcs_test },
+		{ "remote-credits", remote_credits_test },
+		{ "rmsvc",          rmsvc },
 		{ NULL, NULL }
 	}
 };
diff --git a/rm/ut/rmut.h b/rm/ut/rmut.h
index 1a0285a..25b12f0 100644
--- a/rm/ut/rmut.h
+++ b/rm/ut/rmut.h
@@ -31,13 +31,6 @@
 #include "fop/fom_generic.h"
 #include "ut/ut_rpc_machine.h"
 
-enum obj_type {
-	OBJ_DOMAIN = 1,
-	OBJ_RES_TYPE,
-	OBJ_RES,
-	OBJ_OWNER
-};
-
 enum rm_server {
 	SERVER_1,
 	SERVER_2,
@@ -66,6 +59,15 @@ struct rm_ut_data {
 	struct m0_rm_credit        rd_credit;
 };
 
+enum rm_ut_mode {
+	RUM_DEFAULT,
+	RUM_RESOURCE_TYPE,
+	RUM_RESOURCE
+};
+
+void rm_ut_setup(struct rm_ut_data *data, enum rm_ut_mode mode);
+void rm_ut_teardown(struct rm_ut_data *data, enum rm_ut_mode mode);
+
 /*
  * RM server context. It lives inside a thread in this test.
  */
@@ -86,6 +88,9 @@ struct rm_context {
 	enum rm_server             debtor_id;
 };
 
+void rm_ctx_init(struct rm_context *rmctx);
+void rm_ctx_fini(struct rm_context *rmctx);
+
 /*
  * Test variable(s)
  */
@@ -95,15 +100,10 @@ M0_EXTERN const char        *serv_addr[];
 M0_EXTERN const int          cob_ids[];
 M0_EXTERN const char        *db_name[];
 
-void rm_utdata_init(struct rm_ut_data *data, enum obj_type type);
-void rm_utdata_fini(struct rm_ut_data *data, enum obj_type type);
 void rm_test_owner_capital_raise(struct m0_rm_owner *owner,
 				 struct m0_rm_credit *credit);
-void rm_ctx_init(struct rm_context *rmctx);
-void rm_ctx_fini(struct rm_context *rmctx);
 
-/* __MERO_RM_UT_RMUT_H__ */
-#endif
+#endif /* __MERO_RM_UT_RMUT_H__ */
 
 /*
  *  Local variables:
diff --git a/ut/ut_rpc_machine.c b/ut/ut_rpc_machine.c
index 7bec04f..0361087 100644
--- a/ut/ut_rpc_machine.c
+++ b/ut/ut_rpc_machine.c
@@ -165,7 +165,6 @@ M0_INTERNAL void m0_ut_rpc_mach_fini(struct m0_ut_rpc_mach_ctx *ctx)
 	m0_reqh_rpc_mach_tlink_del_fini(&ctx->rmc_rpc);
 	m0_rpc_machine_fini(&ctx->rmc_rpc);
 	m0_reqh_fini(&ctx->rmc_reqh);
-
 }
 
 #endif
-- 
1.8.3.2

