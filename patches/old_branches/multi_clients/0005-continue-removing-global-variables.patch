From 5c34cf69609d1639b5d89d576dd3bbb813a93e2e Mon Sep 17 00:00:00 2001
From: Hua Huang <hua_huang@xyratex.com>
Date: Tue, 25 Feb 2014 14:54:35 +0800
Subject: [PATCH 05/26] continue removing global variables.

---
 addb/addb_rec.c                             |  4 +++-
 layout/layout.c                             | 16 ++++++++--------
 m0t1fs/linux_kernel/m0t1fs.c                |  2 +-
 m0t1fs/linux_kernel/m0t1fs.h                |  2 +-
 m0t1fs/linux_kernel/st/m0t1fs_client_inc.sh |  3 +++
 m0t1fs/linux_kernel/st/m0t1fs_common_inc.sh |  4 ++--
 m0t1fs/linux_kernel/super.c                 | 11 +++++++++--
 net/tm.c                                    |  9 ++++++---
 8 files changed, 33 insertions(+), 18 deletions(-)

diff --git a/addb/addb_rec.c b/addb/addb_rec.c
index 10fdbea..9c9c656 100644
--- a/addb/addb_rec.c
+++ b/addb/addb_rec.c
@@ -68,7 +68,6 @@ static void addb_rec_post(struct m0_addb_mc *mc,
 			  uint64_t *fields,
 			  size_t fields_nr)
 {
-	struct m0_addb_monitor *mon;
 	struct m0_addb_rec     *rec;
 	size_t                  len;
 	size_t                  ctxid_seq_data_size;
@@ -158,8 +157,10 @@ static void addb_rec_post(struct m0_addb_mc *mc,
 	 * @todo: Find a way to remove this condition and instead assert
 	 * on not NULL.
 	 */
+#if 0
 	if (mc->am_reqh != NULL &&
 	    m0_addb_mon_ctx_invariant(&mc->am_reqh->rh_addb_monitoring_ctx)) {
+		struct m0_addb_monitor *mon;
 		/* Invoke all the monitor's filters */
 		m0_mutex_lock(&mc->am_reqh->rh_addb_monitoring_ctx.amc_mutex);
 		m0_tl_for(addb_mon,
@@ -169,6 +170,7 @@ static void addb_rec_post(struct m0_addb_mc *mc,
 		} m0_tl_endfor;
 		m0_mutex_unlock(&mc->am_reqh->rh_addb_monitoring_ctx.amc_mutex);
 	}
+#endif
 }
 
 #ifndef __KERNEL__
diff --git a/layout/layout.c b/layout/layout.c
index f2888ce..8901ceb 100644
--- a/layout/layout.c
+++ b/layout/layout.c
@@ -219,7 +219,7 @@ static void layout_type_get(struct m0_layout_domain *ldom,
 
 	m0_mutex_lock(&ldom->ld_lock);
 	M0_PRE(lt == ldom->ld_type[lt->lt_id]);
-	M0_CNT_INC(lt->lt_ref_count);
+//	M0_CNT_INC(lt->lt_ref_count);
 	m0_mutex_unlock(&ldom->ld_lock);
 }
 
@@ -232,7 +232,7 @@ static void layout_type_put(struct m0_layout_domain *ldom,
 
 	m0_mutex_lock(&ldom->ld_lock);
 	M0_PRE(lt == ldom->ld_type[lt->lt_id]);
-	M0_CNT_DEC(lt->lt_ref_count);
+//	M0_CNT_DEC(lt->lt_ref_count);
 	m0_mutex_unlock(&ldom->ld_lock);
 }
 
@@ -245,7 +245,7 @@ static void enum_type_get(struct m0_layout_domain *ldom,
 
 	m0_mutex_lock(&ldom->ld_lock);
 	M0_PRE(let == ldom->ld_enum[let->let_id]);
-	M0_CNT_INC(let->let_ref_count);
+//	M0_CNT_INC(let->let_ref_count);
 	m0_mutex_unlock(&ldom->ld_lock);
 }
 
@@ -258,7 +258,7 @@ static void enum_type_put(struct m0_layout_domain *ldom,
 
 	m0_mutex_lock(&ldom->ld_lock);
 	M0_PRE(let == ldom->ld_enum[let->let_id]);
-	M0_CNT_DEC(let->let_ref_count);
+//	M0_CNT_DEC(let->let_ref_count);
 	m0_mutex_unlock(&ldom->ld_lock);
 }
 
@@ -772,7 +772,7 @@ M0_INTERNAL int m0_layout_type_register(struct m0_layout_domain *dom,
 	M0_PRE(m0_layout__domain_invariant(dom));
 	M0_PRE(lt != NULL);
 	M0_PRE(IS_IN_ARRAY(lt->lt_id, dom->ld_type));
-	M0_PRE(lt->lt_ref_count == 0);
+//	M0_PRE(lt->lt_ref_count == 0);
 	M0_PRE(lt->lt_ops != NULL);
 
 	M0_ENTRY("Layout-type-id %lu, domain %p",
@@ -811,7 +811,7 @@ M0_INTERNAL void m0_layout_type_unregister(struct m0_layout_domain *dom,
 	M0_ENTRY("Layout-type-id %lu, domain %p",
 		 (unsigned long)lt->lt_id, dom);
 	m0_mutex_lock(&dom->ld_lock);
-	M0_PRE(lt->lt_ref_count == 0);
+//	M0_PRE(lt->lt_ref_count == 0);
 	lt->lt_ops->lto_unregister(dom, lt);
 	dom->ld_type[lt->lt_id] = NULL;
 	max_recsize_update(dom);
@@ -827,7 +827,7 @@ M0_INTERNAL int m0_layout_enum_type_register(struct m0_layout_domain *dom,
 	M0_PRE(m0_layout__domain_invariant(dom));
 	M0_PRE(let != NULL);
 	M0_PRE(IS_IN_ARRAY(let->let_id, dom->ld_enum));
-	M0_PRE(let->let_ref_count == 0);
+//	M0_PRE(let->let_ref_count == 0);
 	M0_PRE(let->let_ops != NULL);
 
 	M0_ENTRY("Enum_type_id %lu, domain %p",
@@ -865,7 +865,7 @@ M0_INTERNAL void m0_layout_enum_type_unregister(struct m0_layout_domain *dom,
 	M0_ENTRY("Enum_type_id %lu, domain %p",
 		 (unsigned long)let->let_id, dom);
 	m0_mutex_lock(&dom->ld_lock);
-	M0_PRE(let->let_ref_count == 0);
+//	M0_PRE(let->let_ref_count == 0);
 	let->let_ops->leto_unregister(dom, let);
 	dom->ld_enum[let->let_id] = NULL;
 	max_recsize_update(dom);
diff --git a/m0t1fs/linux_kernel/m0t1fs.c b/m0t1fs/linux_kernel/m0t1fs.c
index b3a1c0a..392373b 100644
--- a/m0t1fs/linux_kernel/m0t1fs.c
+++ b/m0t1fs/linux_kernel/m0t1fs.c
@@ -36,7 +36,7 @@ static char *node_uuid = "00000000-0000-0000-0000-000000000000"; /* nil UUID */
 module_param(node_uuid, charp, S_IRUGO);
 MODULE_PARM_DESC(node_uuid, "UUID of Mero node");
 
-char *local_addr = "0@lo:12345:45:6";
+char *local_addr = "0@lo:12345:45:";
 
 module_param(local_addr, charp, S_IRUGO);
 MODULE_PARM_DESC(local_addr, "End-point address of m0t1fs "
diff --git a/m0t1fs/linux_kernel/m0t1fs.h b/m0t1fs/linux_kernel/m0t1fs.h
index 9edd00b..8bbf181 100644
--- a/m0t1fs/linux_kernel/m0t1fs.h
+++ b/m0t1fs/linux_kernel/m0t1fs.h
@@ -436,7 +436,7 @@ extern struct m0t1fs_mon_addb_globals m0t1fs_mon_addb_globals;
 struct m0t1fs_globals {
 	struct m0_net_xprt                     *g_xprt;
 	/** local endpoint address module parameter */
-	const char                             *g_laddr;
+	char                                   *g_laddr;
 	char                                   *g_db_name;
 	struct m0_net_domain                    g_ndom;
 	struct m0_rpc_machine                   g_rpc_machine;
diff --git a/m0t1fs/linux_kernel/st/m0t1fs_client_inc.sh b/m0t1fs/linux_kernel/st/m0t1fs_client_inc.sh
index 841e4c4..bf939a3 100644
--- a/m0t1fs/linux_kernel/st/m0t1fs_client_inc.sh
+++ b/m0t1fs/linux_kernel/st/m0t1fs_client_inc.sh
@@ -355,6 +355,7 @@ file_creation_test()
 
 multi_client_test()
 {
+	set -x
 	local nr_clients=$1
 	local mount_dir_1=${MERO_M0T1FS_MOUNT_DIR}aa
 	local mount_dir_2=${MERO_M0T1FS_MOUNT_DIR}bb
@@ -467,9 +468,11 @@ m0t1fs_system_tests()
 		return 1
 	}
 	multi_client_test $NR_CLIENTS || {
+	set +x
                 echo "Failed: multi-client test failed."
 		return 1
 	}
+	set +x
 	return 0
 	io_combinations $POOL_WIDTH $NR_DATA $NR_PARITY || {
 		echo "Failed: IO failed.."
diff --git a/m0t1fs/linux_kernel/st/m0t1fs_common_inc.sh b/m0t1fs/linux_kernel/st/m0t1fs_common_inc.sh
index e529e7b..9f31406 100644
--- a/m0t1fs/linux_kernel/st/m0t1fs_common_inc.sh
+++ b/m0t1fs/linux_kernel/st/m0t1fs_common_inc.sh
@@ -21,7 +21,7 @@ MERO_MODULE=m0mero
 
 
 # kernel space tracing parameters
-MERO_MODULE_TRACE_MASK='m0t1fs'
+MERO_MODULE_TRACE_MASK='m0t1fs,rpc,net'
 MERO_TRACE_PRINT_CONTEXT=short
 MERO_TRACE_LEVEL=call+
 
@@ -83,7 +83,7 @@ load_kernel_module()
 	server_nid=${server_nid:-$lnet_nid}
 
 	# Client end point (m0mero module local_addr)
-	LADDR="$lnet_nid:12345:33:1"
+	LADDR="$lnet_nid:12345:33:"
 
 	mero_module_path=$MERO_CORE_ROOT/mero
 	mero_module=$MERO_MODULE
diff --git a/m0t1fs/linux_kernel/super.c b/m0t1fs/linux_kernel/super.c
index 1f86207..5aab127 100644
--- a/m0t1fs/linux_kernel/super.c
+++ b/m0t1fs/linux_kernel/super.c
@@ -986,11 +986,15 @@ static int m0t1fs_net_init(struct m0t1fs_sb *csb)
 	struct m0_net_xprt   *xprt;
 	struct m0_net_domain *ndom;
 	int		      rc;
+	char                 *laddr;
+	static int            i = 1;
 
 	M0_ENTRY();
+	laddr = m0_alloc(100);
 
 	csb->csb_m0t1fs_globals.g_xprt  = &m0_net_lnet_xprt;;
-	csb->csb_m0t1fs_globals.g_laddr = local_addr;
+	sprintf(laddr, "%s%d", local_addr, i++);
+	csb->csb_m0t1fs_globals.g_laddr = laddr;
 	xprt =  csb->csb_m0t1fs_globals.g_xprt;
 	ndom = &csb->csb_m0t1fs_globals.g_ndom;
 
@@ -1013,6 +1017,7 @@ static void m0t1fs_net_fini(struct m0t1fs_sb *csb)
 
 	m0_net_domain_fini(&csb->csb_m0t1fs_globals.g_ndom);
 	m0_net_xprt_fini(csb->csb_m0t1fs_globals.g_xprt);
+	m0_free(csb->csb_m0t1fs_globals.g_laddr);
 
 	M0_LEAVE();
 }
@@ -1054,12 +1059,14 @@ static int m0t1fs_rpc_init(struct m0t1fs_sb *csb)
 			  .rhia_svc          = (void*)1);
 	if (rc != 0)
 		goto dbenv_fini;
+	M0_LOG(M0_ERROR, "000000000000000");
 	rc = m0_rpc_machine_init(rpc_machine, ndom, laddr, reqh,
 				 buffer_pool, M0_BUFFER_ANY_COLOUR,
 				 max_rpc_msg_size, tm_recv_queue_min_len);
+	M0_LOG(M0_ERROR, "111111111111111: %d", rc);
 	if (rc != 0)
 		goto reqh_fini;
-
+	M0_LOG(M0_ERROR, "222222222222222");
 	m0_reqh_start(reqh);
 	tm = &rpc_machine->rm_tm;
 	M0_ASSERT(tm->ntm_recv_pool == buffer_pool);
diff --git a/net/tm.c b/net/tm.c
index 8a28454..71d64ae 100644
--- a/net/tm.c
+++ b/net/tm.c
@@ -223,6 +223,7 @@ M0_INTERNAL void m0_net_tm_fini(struct m0_net_transfer_mc *tm)
 {
 	struct m0_net_domain *dom = tm->ntm_dom;
 	int i;
+	M0_ENTRY();
 
 	/* wait for ongoing event processing to drain without holding lock:
 	   events modify state and end point refcounts
@@ -272,13 +273,14 @@ M0_INTERNAL void m0_net_tm_fini(struct m0_net_transfer_mc *tm)
 	m0_list_link_fini(&tm->ntm_dom_linkage);
 
 	m0_mutex_unlock(&dom->nd_mutex);
-	return;
+	M0_LEAVE();;
 }
 M0_EXPORTED(m0_net_tm_fini);
 
 M0_INTERNAL int m0_net_tm_start(struct m0_net_transfer_mc *tm, const char *addr)
 {
 	int rc;
+	M0_ENTRY();
 
 	M0_ASSERT(addr != NULL);
 	M0_PRE(tm != NULL);
@@ -303,7 +305,7 @@ M0_INTERNAL int m0_net_tm_start(struct m0_net_transfer_mc *tm, const char *addr)
 	M0_POST(m0_net__tm_invariant(tm));
 	m0_mutex_unlock(&tm->ntm_mutex);
 	M0_ASSERT(rc <= 0);
-	return rc;
+	M0_RETURN(rc);
 }
 M0_EXPORTED(m0_net_tm_start);
 
@@ -311,6 +313,7 @@ M0_INTERNAL int m0_net_tm_stop(struct m0_net_transfer_mc *tm, bool abort)
 {
 	int rc;
 	enum m0_net_tm_state oldstate;
+	M0_ENTRY();
 
 	m0_mutex_lock(&tm->ntm_mutex);
 	M0_PRE(m0_net__tm_invariant(tm));
@@ -330,7 +333,7 @@ M0_INTERNAL int m0_net_tm_stop(struct m0_net_transfer_mc *tm, bool abort)
 	M0_POST(m0_net__tm_invariant(tm));
 	m0_mutex_unlock(&tm->ntm_mutex);
 	M0_ASSERT(rc <= 0);
-	return rc;
+	M0_RETURN(rc);
 }
 M0_EXPORTED(m0_net_tm_stop);
 
-- 
1.8.3.2

