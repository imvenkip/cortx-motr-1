From 53b33855bc6617486e264b46f01f84dda25fe094 Mon Sep 17 00:00:00 2001
From: Hua Huang <hua_huang@xyratex.com>
Date: Wed, 5 Mar 2014 12:40:30 +0800
Subject: [PATCH 10/26] check if beseg is NULL, because on client, it is NULL
 in reqh. when iget_locked() returns, inode is already hashed.

---
 fop/fom_generic.c                           | 27 +++++++++++++++++++++++++++
 m0t1fs/linux_kernel/dir.c                   |  4 ----
 m0t1fs/linux_kernel/inode.c                 |  3 ++-
 m0t1fs/linux_kernel/st/m0t1fs_common_inc.sh |  2 +-
 4 files changed, 30 insertions(+), 6 deletions(-)

diff --git a/fop/fom_generic.c b/fop/fom_generic.c
index 7375fe6..40f4f63 100644
--- a/fop/fom_generic.c
+++ b/fop/fom_generic.c
@@ -232,6 +232,8 @@ static int fom_tx_init(struct m0_fom *fom)
 	struct m0_reqh *reqh;
 
 	reqh = m0_fom_reqh(fom);
+	if (reqh->rh_beseg == NULL)
+		return M0_FSO_AGAIN;
 
 	m0_dtx_init(&fom->fo_tx, reqh->rh_beseg->bs_domain,
 		    &fom->fo_loc->fl_group);
@@ -252,6 +254,9 @@ static int fom_tx_open(struct m0_fom *fom)
 	struct m0_reqh *reqh = m0_fom_reqh(fom);
 	struct m0_dtx  *dtx  = &fom->fo_tx;
 
+	if (reqh->rh_beseg == NULL)
+		return M0_FSO_AGAIN;
+
 	m0_fol_credit(reqh->rh_fol, M0_FO_REC_ADD, 1, m0_fom_tx_credit(fom));
 
 	if (!fom->fo_local) {
@@ -272,8 +277,12 @@ static int fom_tx_open(struct m0_fom *fom)
  */
 static int fom_tx_wait(struct m0_fom *fom)
 {
+	struct m0_reqh *reqh = m0_fom_reqh(fom);
 	struct m0_be_tx *tx = m0_fom_tx(fom);
 
+	if (reqh->rh_beseg == NULL)
+		return M0_FSO_AGAIN;
+
 	M0_ENTRY("fom=%p", fom);
 	M0_PRE(M0_IN(m0_be_tx_state(tx), (M0_BTS_OPENING,
 					  M0_BTS_ACTIVE, M0_BTS_FAILED)));
@@ -344,6 +353,11 @@ static int fom_success(struct m0_fom *fom)
  */
 static int fom_fol_rec_add(struct m0_fom *fom)
 {
+	struct m0_reqh  *reqh = m0_fom_reqh(fom);
+
+	if (reqh->rh_beseg == NULL)
+		return M0_FSO_AGAIN;
+
 	if (!fom->fo_local) {
 		int rc;
 
@@ -363,6 +377,10 @@ static int fom_tx_commit(struct m0_fom *fom)
 {
 	struct m0_dtx   *dtx = &fom->fo_tx;
 	struct m0_be_tx *tx  = m0_fom_tx(fom);
+	struct m0_reqh  *reqh = m0_fom_reqh(fom);
+
+	if (reqh->rh_beseg == NULL)
+		return M0_FSO_AGAIN;
 
 	M0_PRE(M0_IN(dtx->tx_state, (M0_DTX_INIT, M0_DTX_OPEN)));
 
@@ -383,6 +401,10 @@ static int fom_tx_commit(struct m0_fom *fom)
 static int fom_tx_commit_wait(struct m0_fom *fom)
 {
 	struct m0_be_tx *tx = m0_fom_tx(fom);
+	struct m0_reqh  *reqh = m0_fom_reqh(fom);
+
+	if (reqh->rh_beseg == NULL)
+		return M0_FSO_AGAIN;
 
 	if (m0_be_tx_state(tx) == M0_BTS_DONE) {
 		m0_dtx_fini(&fom->fo_tx);
@@ -421,6 +443,11 @@ static int fom_queue_reply(struct m0_fom *fom)
  */
 static int fom_queue_reply_wait(struct m0_fom *fom)
 {
+	struct m0_reqh  *reqh = m0_fom_reqh(fom);
+
+	if (reqh->rh_beseg == NULL)
+		return M0_FSO_AGAIN;
+
 	M0_PRE(M0_IN(fom->fo_tx.tx_state, (M0_DTX_INIT, M0_DTX_DONE)));
 
 	if (fom->fo_tx.tx_state == M0_DTX_INIT) {
diff --git a/m0t1fs/linux_kernel/dir.c b/m0t1fs/linux_kernel/dir.c
index c3aca0d..4f3c885 100644
--- a/m0t1fs/linux_kernel/dir.c
+++ b/m0t1fs/linux_kernel/dir.c
@@ -289,7 +289,6 @@ static int m0t1fs_create(struct inode     *dir,
 	       FID_P(m0t1fs_inode_fid(M0T1FS_I(dir))));
 
 	m0t1fs_fid_alloc(csb, &new_fid);
-	/* new_inode() will call m0t1fs_alloc_inode() using super_operations */
 	inode = iget_locked(sb, fid_hash(&new_fid));
 	if (inode == NULL)
 		M0_RETURN(-ENOMEM);
@@ -321,9 +320,6 @@ static int m0t1fs_create(struct inode     *dir,
 	if ((inode->i_state & I_NEW) != 0)
 		unlock_new_inode(inode);
 
-	insert_inode_hash(inode);
-	mark_inode_dirty(inode);
-
 	rc = m0t1fs_inode_layout_init(ci);
 	if (rc != 0)
 		goto out;
diff --git a/m0t1fs/linux_kernel/inode.c b/m0t1fs/linux_kernel/inode.c
index b8d417d..14a79b8 100644
--- a/m0t1fs/linux_kernel/inode.c
+++ b/m0t1fs/linux_kernel/inode.c
@@ -120,7 +120,6 @@ M0_INTERNAL void m0t1fs_file_lock_init(struct m0t1fs_inode    *ci,
 
 	M0_LOG(M0_INFO, FID_F, FID_P(fid));
 	rdom = m0t1fs_rmsvc_domain_get(&csb->csb_m0t1fs_globals.g_reqh);
-	M0_LOG(M0_ERROR, "rdom = %p", rdom);
 	M0_ASSERT(rdom != NULL);
 	/**
 	 * @todo Get di type from configuration.
@@ -144,6 +143,7 @@ M0_INTERNAL void m0t1fs_file_lock_init(struct m0t1fs_inode    *ci,
 M0_INTERNAL void m0t1fs_file_lock_fini(struct m0t1fs_inode *ci)
 {
 	int rc;
+	M0_ENTRY();
 
 	m0_rm_owner_windup(&ci->ci_fowner);
 	rc = m0_rm_owner_timedwait(&ci->ci_fowner, M0_BITS(ROS_FINAL),
@@ -152,6 +152,7 @@ M0_INTERNAL void m0t1fs_file_lock_fini(struct m0t1fs_inode *ci)
 	m0_file_owner_fini(&ci->ci_fowner);
 	m0_file_fini(&ci->ci_flock);
 	m0_rm_remote_fini(&ci->ci_creditor);
+	M0_LEAVE();
 }
 
 static void m0t1fs_inode_init(struct m0t1fs_inode *ci)
diff --git a/m0t1fs/linux_kernel/st/m0t1fs_common_inc.sh b/m0t1fs/linux_kernel/st/m0t1fs_common_inc.sh
index eb3da29..3826436 100644
--- a/m0t1fs/linux_kernel/st/m0t1fs_common_inc.sh
+++ b/m0t1fs/linux_kernel/st/m0t1fs_common_inc.sh
@@ -21,7 +21,7 @@ MERO_MODULE=m0mero
 
 
 # kernel space tracing parameters
-MERO_MODULE_TRACE_MASK='m0t1fs,rpc,net'
+MERO_MODULE_TRACE_MASK='m0t1fs'
 MERO_TRACE_PRINT_CONTEXT=short
 MERO_TRACE_LEVEL=call+
 
-- 
1.8.3.2

