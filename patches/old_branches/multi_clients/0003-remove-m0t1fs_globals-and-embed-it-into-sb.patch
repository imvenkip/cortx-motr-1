From ac6e047089cfb08c00b9ad8e0bc268fb5ca0f227 Mon Sep 17 00:00:00 2001
From: Hua Huang <hua_huang@xyratex.com>
Date: Wed, 19 Feb 2014 21:18:48 +0800
Subject: [PATCH 03/26] remove m0t1fs_globals, and embed it into sb. Just
 compiled, not tested.

---
 file/file.c                   |  32 ++--
 file/file.h                   |  15 +-
 ioservice/io_fops.c           |   4 +-
 ioservice/ut/bulkio_client.c  |  14 +-
 ioservice/ut/bulkio_common.c  |   7 +-
 ioservice/ut/bulkio_common.h  |   1 +
 layout/ut/layout.c            |  22 ---
 m0t1fs/linux_kernel/dir.c     |   9 +-
 m0t1fs/linux_kernel/file.c    |   5 +-
 m0t1fs/linux_kernel/inode.c   |  10 +-
 m0t1fs/linux_kernel/m0t1fs.c  | 339 +---------------------------------
 m0t1fs/linux_kernel/m0t1fs.h  |  22 ++-
 m0t1fs/linux_kernel/super.c   | 415 ++++++++++++++++++++++++++++++++++++------
 m0t1fs/linux_kernel/ut/file.c |  15 +-
 rm/rm_service.c               |   6 +-
 rm/rm_service.h               |  14 +-
 16 files changed, 460 insertions(+), 470 deletions(-)

diff --git a/file/file.c b/file/file.c
index 3f468af..16d777c 100644
--- a/file/file.c
+++ b/file/file.c
@@ -183,10 +183,6 @@ static int file_lock_cr_decode(struct m0_rm_credit     *self,
 static void file_lock_cr_free(struct m0_rm_credit *self);
 static void file_lock_cr_initial_capital(struct m0_rm_credit *self);
 
-static struct m0_rm_resource_type flock_rt = {
-	.rt_name = "File Lock Resource Type"
-};
-
 const struct m0_rm_resource_type_ops file_lock_type_ops = {
 	.rto_eq     = file_lock_equal,
 	.rto_len    = file_lock_len,
@@ -539,36 +535,42 @@ M0_INTERNAL void m0_file_unlock(struct m0_rm_incoming *req)
 }
 M0_EXPORTED(m0_file_unlock);
 
-M0_INTERNAL int m0_file_lock_type_register(struct m0_rm_domain *dom)
+M0_INTERNAL int m0_file_lock_type_register(struct m0_rm_domain *dom,
+					   struct m0_rm_resource_type *flock_rt)
 {
 	M0_ENTRY();
 
-	flock_rt.rt_id = M0_RM_FLOCK_RT;
-	flock_rt.rt_ops = &file_lock_type_ops;
-	M0_RETURN(m0_rm_type_register(dom, &flock_rt));
+	flock_rt->rt_id = M0_RM_FLOCK_RT;
+	flock_rt->rt_ops = &file_lock_type_ops;
+	M0_RETURN(m0_rm_type_register(dom, flock_rt));
 }
 M0_EXPORTED(m0_file_lock_type_register);
 
-M0_INTERNAL void m0_file_lock_type_deregister(void)
+M0_INTERNAL
+void m0_file_lock_type_deregister(struct m0_rm_resource_type *flock_rt)
 {
 	M0_ENTRY();
-	m0_rm_type_deregister(&flock_rt);
+	m0_rm_type_deregister(flock_rt);
 	M0_LEAVE();
 }
 M0_EXPORTED(m0_file_lock_type_deregister);
 
-M0_INTERNAL bool m0_file_lock_resource_is_added(const struct m0_fid *fid)
+M0_INTERNAL
+bool m0_file_lock_resource_is_added(const struct m0_fid *fid,
+				    struct m0_rm_resource_type *flock_rt)
 {
 	struct m0_file file;
 
 	M0_PRE(fid != NULL);
 
 	file.fi_fid = fid;
-	return m0_rm_resource_find(&flock_rt, &file.fi_res) == NULL ?
-		false : true;
+	return m0_rm_resource_find(flock_rt, &file.fi_res) == NULL ? false
+								   : true;
 }
 
-M0_INTERNAL struct m0_file *m0_resource_to_file(const struct m0_fid *fid)
+M0_INTERNAL
+struct m0_file *m0_resource_to_file(const struct m0_fid *fid,
+				    struct m0_rm_resource_type *flock_rt)
 {
 	struct m0_file	      *file = NULL;
 	struct m0_file	       lfile;
@@ -580,7 +582,7 @@ M0_INTERNAL struct m0_file *m0_resource_to_file(const struct m0_fid *fid)
 	M0_LOG(M0_DEBUG, FID_F, FID_P(fid));
 
 	lfile.fi_fid = fid;
-	res = m0_rm_resource_find(&flock_rt, &lfile.fi_res);
+	res = m0_rm_resource_find(flock_rt, &lfile.fi_res);
 	if (res != NULL)
 		file = container_of(res, struct m0_file, fi_res);
 
diff --git a/file/file.h b/file/file.h
index 380f553..cbd1edf 100644
--- a/file/file.h
+++ b/file/file.h
@@ -137,23 +137,30 @@ M0_INTERNAL void m0_file_unlock(struct m0_rm_incoming *req);
 /**
  * Registers the resource of type 'distributed mutex' with a resource domain.
  */
-M0_INTERNAL int m0_file_lock_type_register(struct m0_rm_domain *dom);
+M0_INTERNAL
+int m0_file_lock_type_register(struct m0_rm_domain *dom,
+			       struct m0_rm_resource_type *flock_rt);
 
 /**
  * De-registers the resource of type 'distributed mutex' from a resource domain.
  */
-M0_INTERNAL void m0_file_lock_type_deregister(void);
+M0_INTERNAL
+void m0_file_lock_type_deregister(struct m0_rm_resource_type *flock_rt);
 
 /**
  * Check whether a file lock resource with description given in @fid is
  * registered with file lock domain.
  */
-M0_INTERNAL bool m0_file_lock_resource_is_added(const struct m0_fid *fid);
+M0_INTERNAL
+bool m0_file_lock_resource_is_added(const struct m0_fid *fid,
+				    struct m0_rm_resource_type *flock_rt);
 
 /**
  * Returns m0_file from the given resource @fid.
  */
-M0_INTERNAL struct m0_file *m0_resource_to_file(const struct m0_fid *fid);
+M0_INTERNAL
+struct m0_file *m0_resource_to_file(const struct m0_fid *fid,
+				    struct m0_rm_resource_type *flock_rt);
 
 /** @} end of FileLock */
 
diff --git a/ioservice/io_fops.c b/ioservice/io_fops.c
index 504d8b5..97a2f66 100644
--- a/ioservice/io_fops.c
+++ b/ioservice/io_fops.c
@@ -1225,6 +1225,8 @@ static void io_fop_ivec_prepare(struct m0_fop *res_fop,
 
 static int io_fop_di_prepare(struct m0_fop *fop)
 {
+	return 0;
+/*
 	uint64_t		   size;
 	struct m0_fop_cob_rw	  *rw;
 	struct m0_io_indexvec_seq *io_info;
@@ -1236,7 +1238,6 @@ static int io_fop_di_prepare(struct m0_fop *fop)
 	m0_bcount_t		   bsize;
 
 	M0_PRE(fop != NULL);
-	return 0;
 
 	rbulk = m0_fop_to_rpcbulk(fop);
 	M0_ASSERT(rbulk != NULL);
@@ -1278,6 +1279,7 @@ cleanup:
 		--i;
 	}
 	return -ENOMEM;
+*/
 }
 
 static void io_fop_bulkbuf_move(struct m0_fop *src, struct m0_fop *dest)
diff --git a/ioservice/ut/bulkio_client.c b/ioservice/ut/bulkio_client.c
index 10fc933..1d307ee 100644
--- a/ioservice/ut/bulkio_client.c
+++ b/ioservice/ut/bulkio_client.c
@@ -151,20 +151,20 @@ static void bulkclient_test(void)
 	struct m0_rm_domain     *rm_dom;
 	struct m0_file           file;
 
+	struct m0_rm_resource_type flock_rt = {
+		.rt_name = "File Lock Resource Type"
+	};
+
 	M0_ALLOC_PTR(iofop);
 	M0_ASSERT(iofop != NULL);
 	M0_SET0(iofop);
 	M0_SET0(&nd);
 
-#ifndef __KERNEL__
 	M0_ALLOC_PTR(rm_dom);
 	M0_ASSERT(rm_dom != NULL);
 	m0_rm_domain_init(rm_dom);
-	rc = m0_file_lock_type_register(rm_dom);
+	rc = m0_file_lock_type_register(rm_dom, &flock_rt);
 	M0_ASSERT(rc == 0);
-#else
-	rm_dom = m0t1fs_rmsvc_domain_get();
-#endif
 
 	xprt = &m0_net_lnet_xprt;
 	rc = m0_net_domain_init(&nd, xprt, &m0_addb_proc_ctx);
@@ -411,11 +411,9 @@ static void bulkclient_test(void)
 	m0_free(iofop);
 	m0_net_domain_fini(&nd);
 	m0_file_fini(&file);
-#ifndef __KERNEL__
-	m0_file_lock_type_deregister();
+	m0_file_lock_type_deregister(&flock_rt);
 	m0_rm_domain_fini(rm_dom);
 	m0_free(rm_dom);
-#endif
 }
 
 const struct m0_test_suite bulkio_client_ut = {
diff --git a/ioservice/ut/bulkio_common.c b/ioservice/ut/bulkio_common.c
index 211df44..11d06f5 100644
--- a/ioservice/ut/bulkio_common.c
+++ b/ioservice/ut/bulkio_common.c
@@ -398,8 +398,11 @@ void bulkio_params_init(struct bulkio_params *bp)
 	bp->bp_rfops = NULL;
 	bp->bp_wfops = NULL;
 
+	bp->bp_flock_rt.rt_name = "File Lock Resource Type";
+
 	m0_rm_domain_init(&bp->bp_rdom);
-	rc = m0_file_lock_type_register(&bp->bp_rdom);
+	rc = m0_file_lock_type_register(&bp->bp_rdom, &bp->bp_flock_rt);
+
 	M0_ASSERT(rc == 0);
 
 }
@@ -431,7 +434,7 @@ void bulkio_params_fini(struct bulkio_params *bp)
 
 	m0_free(bp->bp_cdbname);
 	m0_free(bp->bp_slogfile);
-	m0_file_lock_type_deregister();
+	m0_file_lock_type_deregister(&bp->bp_flock_rt);
 	m0_rm_domain_fini(&bp->bp_rdom);
 }
 
diff --git a/ioservice/ut/bulkio_common.h b/ioservice/ut/bulkio_common.h
index a16f578..442b5b3 100644
--- a/ioservice/ut/bulkio_common.h
+++ b/ioservice/ut/bulkio_common.h
@@ -106,6 +106,7 @@ struct bulkio_params {
 	struct m0_net_xprt		 *bp_xprt;
 
 	struct m0_rm_domain		 bp_rdom;
+	struct m0_rm_resource_type       bp_flock_rt;
 	struct m0_file			 bp_file[IO_FIDS_NR];
 };
 
diff --git a/layout/ut/layout.c b/layout/ut/layout.c
index 9656c6a..75c7ebf 100644
--- a/layout/ut/layout.c
+++ b/layout/ut/layout.c
@@ -88,23 +88,6 @@ static int test_init(void)
 	rc = m0_layout_domain_init(&domain, &dbenv);
 	M0_ASSERT(rc == 0);
 
-#ifdef __KERNEL__
-	/*
-	 * A layout type can be registered with only one domain at a time.
-	 * As a part of the kernel UT, all the available layout types and enum
-	 * types have been registered with the domain
-	 * "m0t1fs_globals.g_layout_dom".
-	 * (This happpens during the module load operation, by performing
-	 * m0_layout_standard_types_register(&m0t1fs_globals.g_layout_dom)
-	 * through m0t1fs_init()). Hence, performing
-	 * m0_layout_standard_types_unregister(&m0t1fs_globals.g_layout_dom)
-	 * here to temporarily unregister all the available layout types and
-	 * enum types from the domain "m0t1fs_globals.g_layout_dom". Those will
-	 * be registered back in test_fini().
-	 */
-	m0_layout_standard_types_unregister(&m0t1fs_globals.g_layout_dom);
-#endif
-
 	/* Register all the standard layout types and enum types. */
 	rc = m0_layout_standard_types_register(&domain);
 	M0_ASSERT(rc == 0);
@@ -115,11 +98,6 @@ static int test_init(void)
 static int test_fini(void)
 {
 	m0_layout_standard_types_unregister(&domain);
-
-#ifdef __KERNEL__
-	m0_layout_standard_types_register(&m0t1fs_globals.g_layout_dom);
-#endif
-
 	m0_layout_domain_fini(&domain);
 	m0_dbenv_fini(&dbenv);
 
diff --git a/m0t1fs/linux_kernel/dir.c b/m0t1fs/linux_kernel/dir.c
index 9837e2f..c3aca0d 100644
--- a/m0t1fs/linux_kernel/dir.c
+++ b/m0t1fs/linux_kernel/dir.c
@@ -990,7 +990,8 @@ out:
 	return rc;
 }
 
-static int m0t1fs_mds_cob_fop_populate(const struct m0t1fs_mdop *mo,
+static int m0t1fs_mds_cob_fop_populate(struct m0t1fs_sb         *csb,
+				       const struct m0t1fs_mdop *mo,
 				       struct m0_fop            *fop)
 {
 	struct m0_fop_create    *create;
@@ -1086,7 +1087,7 @@ static int m0t1fs_mds_cob_fop_populate(const struct m0t1fs_mdop *mo,
 			 * for any type of layout.
 			 */
 			layout->l_buf.b_count = m0_layout_max_recsize(
-						&m0t1fs_globals.g_layout_dom);
+						&csb->csb_m0t1fs_globals.g_layout_dom);
 			layout->l_buf.b_addr = m0_alloc(layout->l_buf.b_count);
 			if (layout->l_buf.b_addr == NULL) {
 				rc = -ENOMEM;
@@ -1195,7 +1196,7 @@ static int m0t1fs_mds_cob_op(struct m0t1fs_sb            *csb,
 		goto out;
 	}
 
-	rc = m0t1fs_mds_cob_fop_populate(mo, fop);
+	rc = m0t1fs_mds_cob_fop_populate(csb, mo, fop);
 	if (rc != 0) {
 		M0_LOG(M0_ERROR,
 		       "m0t1fs_mds_cob_fop_populate() failed with %d", rc);
@@ -1301,7 +1302,7 @@ int m0t1fs_layout_op(struct m0t1fs_sb *csb, enum m0_layout_opcode op,
 	struct m0_fop_layout_rep *rep = NULL;
 	int                       rc;
 	struct m0_layout         *layout = NULL;
-	struct m0_layout_domain  *ldom = &m0t1fs_globals.g_layout_dom;
+	struct m0_layout_domain  *ldom = &csb->csb_m0t1fs_globals.g_layout_dom;
 
 	M0_ENTRY();
 
diff --git a/m0t1fs/linux_kernel/file.c b/m0t1fs/linux_kernel/file.c
index 60c722b..0c68934 100644
--- a/m0t1fs/linux_kernel/file.c
+++ b/m0t1fs/linux_kernel/file.c
@@ -4855,13 +4855,14 @@ static inline uint32_t io_seg_size(void)
 
 static uint32_t io_di_size(const struct io_request *req)
 {
-	struct m0_file *file;
 	return 0;
-
+/*
+	struct m0_file *file;
 	file = m0_resource_to_file(file_to_fid(req->ir_file));
 	if (file->fi_di_ops->do_out_shift(file) == 0)
 		return 0;
 	return file->fi_di_ops->do_out_shift(file) * M0_DI_ELEMENT_SIZE;
+*/
 }
 
 static int bulk_buffer_add(struct io_req_fop	   *irfop,
diff --git a/m0t1fs/linux_kernel/inode.c b/m0t1fs/linux_kernel/inode.c
index 7a27ff8..912ba43 100644
--- a/m0t1fs/linux_kernel/inode.c
+++ b/m0t1fs/linux_kernel/inode.c
@@ -98,11 +98,11 @@ M0_INTERNAL void m0t1fs_inode_cache_fini(void)
 	M0_LEAVE();
 }
 
-M0_INTERNAL struct m0_rm_domain *m0t1fs_rmsvc_domain_get(void)
+M0_INTERNAL struct m0_rm_domain *m0t1fs_rmsvc_domain_get(struct m0_reqh *reqh)
 {
 	return m0_rm_svc_domain_get(
 		m0_reqh_service_find(m0_reqh_service_type_find("rmservice"),
-				     &m0t1fs_globals.g_reqh));
+				     reqh));
 }
 
 static inline uint64_t m0t1fs_rm_container(const struct m0t1fs_sb *csb)
@@ -111,7 +111,7 @@ static inline uint64_t m0t1fs_rm_container(const struct m0t1fs_sb *csb)
 }
 
 M0_INTERNAL void m0t1fs_file_lock_init(struct m0t1fs_inode    *ci,
-				       const struct m0t1fs_sb *csb)
+				       struct m0t1fs_sb *csb)
 {
 	struct m0_rm_domain *rdom;
 	const struct m0_fid *fid = &ci->ci_fid;
@@ -120,7 +120,7 @@ M0_INTERNAL void m0t1fs_file_lock_init(struct m0t1fs_inode    *ci,
 	return;
 
 	M0_LOG(M0_INFO, FID_F, FID_P(fid));
-	rdom = m0t1fs_rmsvc_domain_get();
+	rdom = m0t1fs_rmsvc_domain_get(&csb->csb_m0t1fs_globals.g_reqh);
 	M0_LOG(M0_ERROR, "rdom = %p", rdom);
 	M0_ASSERT(rdom != NULL);
 	/**
@@ -424,7 +424,7 @@ static int m0t1fs_build_layout_instance(struct m0t1fs_sb           *csb,
 	M0_PRE(fid != NULL);
 	M0_PRE(linst != NULL);
 
-	layout = m0_layout_find(&m0t1fs_globals.g_layout_dom, layout_id);
+	layout = m0_layout_find(&csb->csb_m0t1fs_globals.g_layout_dom, layout_id);
 	if (layout == NULL) {
 		rc = m0t1fs_layout_op(csb, M0_LAYOUT_OP_LOOKUP,
 				      layout_id, &layout);
diff --git a/m0t1fs/linux_kernel/m0t1fs.c b/m0t1fs/linux_kernel/m0t1fs.c
index 75f0ea7..43f29c3 100644
--- a/m0t1fs/linux_kernel/m0t1fs.c
+++ b/m0t1fs/linux_kernel/m0t1fs.c
@@ -38,35 +38,20 @@ static char *node_uuid = "00000000-0000-0000-0000-000000000000"; /* nil UUID */
 module_param(node_uuid, charp, S_IRUGO);
 MODULE_PARM_DESC(node_uuid, "UUID of Mero node");
 
-static char *local_addr = "0@lo:12345:45:6";
+char *local_addr = "0@lo:12345:45:6";
 
 module_param(local_addr, charp, S_IRUGO);
 MODULE_PARM_DESC(local_addr, "End-point address of m0t1fs "
 		 "e.g. 172.18.50.40@o2ib1:12345:34:1");
 
-static uint32_t tm_recv_queue_min_len = M0_NET_TM_RECV_QUEUE_DEF_LEN;
+uint32_t tm_recv_queue_min_len = M0_NET_TM_RECV_QUEUE_DEF_LEN;
 module_param(tm_recv_queue_min_len , int, S_IRUGO);
 MODULE_PARM_DESC(tm_recv_queue_min_len, "TM receive queue minimum length");
 
-static uint32_t max_rpc_msg_size = M0_RPC_DEF_MAX_RPC_MSG_SIZE;
+uint32_t max_rpc_msg_size = M0_RPC_DEF_MAX_RPC_MSG_SIZE;
 module_param(max_rpc_msg_size, int, S_IRUGO);
 MODULE_PARM_DESC(max_rpc_msg_size, "Maximum RPC message size");
 
-static int  m0t1fs_net_init(void);
-static void m0t1fs_net_fini(void);
-
-static int  m0t1fs_rpc_init(void);
-static void m0t1fs_rpc_fini(void);
-
-static int  m0t1fs_addb_mon_total_io_size_init(void);
-static void m0t1fs_addb_mon_total_io_size_fini(void);
-
-static int  m0t1fs_layout_init(void);
-static void m0t1fs_layout_fini(void);
-
-static int m0t1fs_reqh_services_start(void);
-static void m0t1fs_reqh_services_stop(void);
-
 struct m0_addb_ctx m0t1fs_addb_ctx;
 
 static struct file_system_type m0t1fs_fs_type = {
@@ -79,11 +64,6 @@ static struct file_system_type m0t1fs_fs_type = {
 
 #define M0T1FS_DB_NAME "m0t1fs.db"
 
-struct m0t1fs_globals m0t1fs_globals = {
-	.g_xprt       = &m0_net_lnet_xprt,
-	.g_db_name    = M0T1FS_DB_NAME,
-};
-
 M0_INTERNAL const char *m0t1fs_param_node_uuid_get(void)
 {
 	return node_uuid;
@@ -119,8 +99,6 @@ M0_INTERNAL int m0t1fs_init(void)
 	M0_ADDB_MONITOR_STATS_TYPE_REGISTER(&m0_addb_rt_m0t1fs_mon_io_size,
 					    "io_size");
 
-	m0t1fs_globals.g_laddr = local_addr;
-
         rc = m0_fid_init();
         if (rc != 0)
                 goto out;
@@ -137,37 +115,13 @@ M0_INTERNAL int m0t1fs_init(void)
 	if (rc != 0)
 		goto mdservice_fini;
 
-	rc = m0t1fs_net_init();
-	if (rc != 0)
-		goto icache_fini;
-
-	rc = m0t1fs_rpc_init();
-	if (rc != 0)
-		goto net_fini;
-
-	rc = m0t1fs_addb_mon_total_io_size_init();
-	if (rc != 0)
-		goto rpc_fini;
-
-	rc = m0t1fs_layout_init();
-	if (rc != 0)
-		goto addb_mon_fini;
-
 	rc = register_filesystem(&m0t1fs_fs_type);
 	if (rc != 0)
-		goto layout_fini;
+		goto icache_fini;
 
 	M0_LEAVE("rc: 0");
 	return 0;
 
-layout_fini:
-	m0t1fs_layout_fini();
-addb_mon_fini:
-	m0t1fs_addb_mon_total_io_size_fini();
-rpc_fini:
-	m0t1fs_rpc_fini();
-net_fini:
-	m0t1fs_net_fini();
 icache_fini:
 	m0t1fs_inode_cache_fini();
 mdservice_fini:
@@ -190,9 +144,6 @@ M0_INTERNAL void m0t1fs_fini(void)
 
 	(void)unregister_filesystem(&m0t1fs_fs_type);
 
-	m0t1fs_layout_fini();
-	m0t1fs_rpc_fini();
-	m0t1fs_net_fini();
 	m0t1fs_inode_cache_fini();
 	m0_mdservice_fop_fini();
 	m0_ioservice_fop_fini();
@@ -202,284 +153,4 @@ M0_INTERNAL void m0t1fs_fini(void)
 
 	M0_LEAVE();
 }
-
-static int m0t1fs_net_init(void)
-{
-	struct m0_net_xprt   *xprt;
-	struct m0_net_domain *ndom;
-	int		      rc;
-
-	M0_ENTRY();
-
-	xprt =  m0t1fs_globals.g_xprt;
-	ndom = &m0t1fs_globals.g_ndom;
-
-	rc = m0_net_xprt_init(xprt);
-	if (rc != 0)
-		goto out;
-
-	/** @todo replace &m0_addb_proc_ctx */
-	rc = m0_net_domain_init(ndom, xprt, &m0_addb_proc_ctx);
-	if (rc != 0)
-		m0_net_xprt_fini(xprt);
-out:
-	M0_LEAVE("rc: %d", rc);
-	return rc;
-}
-
-static void m0t1fs_net_fini(void)
-{
-	M0_ENTRY();
-
-	m0_net_domain_fini(&m0t1fs_globals.g_ndom);
-	m0_net_xprt_fini(m0t1fs_globals.g_xprt);
-
-	M0_LEAVE();
-}
-
-static int m0t1fs_rpc_init(void)
-{
-	struct m0_dbenv           *dbenv       = &m0t1fs_globals.g_dbenv;
-	char                      *db_name     =  m0t1fs_globals.g_db_name;
-	struct m0_rpc_machine     *rpc_machine = &m0t1fs_globals.g_rpc_machine;
-	struct m0_reqh            *reqh        = &m0t1fs_globals.g_reqh;
-	struct m0_net_domain      *ndom        = &m0t1fs_globals.g_ndom;
-	const char                *laddr       =  m0t1fs_globals.g_laddr;
-	struct m0_net_buffer_pool *buffer_pool = &m0t1fs_globals.g_buffer_pool;
-	struct m0_fol             *fol         = &m0t1fs_globals.g_fol;
-	struct m0_net_transfer_mc *tm;
-	int                        rc;
-	uint32_t		   bufs_nr;
-	uint32_t		   tms_nr;
-
-	M0_ENTRY();
-
-	tms_nr	 = 1;
-	bufs_nr  = m0_rpc_bufs_nr(tm_recv_queue_min_len, tms_nr);
-
-	rc = m0_rpc_net_buffer_pool_setup(ndom, buffer_pool,
-					  bufs_nr, tms_nr);
-	if (rc != 0)
-		goto pool_fini;
-
-	rc = m0_dbenv_init(dbenv, db_name, 0);
-	if (rc != 0)
-		goto pool_fini;
-
-	rc = M0_REQH_INIT(reqh,
-			  .rhia_dtm          = (void*)1,
-			  .rhia_db           = NULL,
-			  .rhia_mdstore      = (void*)1,
-			  .rhia_fol          = fol,
-			  .rhia_svc          = (void*)1);
-	if (rc != 0)
-		goto dbenv_fini;
-	rc = m0_rpc_machine_init(rpc_machine, ndom, laddr, reqh,
-				 buffer_pool, M0_BUFFER_ANY_COLOUR,
-				 max_rpc_msg_size, tm_recv_queue_min_len);
-	if (rc != 0)
-		goto reqh_fini;
-
-	m0_reqh_start(reqh);
-	tm = &rpc_machine->rm_tm;
-	M0_ASSERT(tm->ntm_recv_pool == buffer_pool);
-
-	m0_reqh_rpc_mach_tlink_init_at_tail(rpc_machine,
-					    &reqh->rh_rpc_machines);
-
-	/* Start resource manager service */
-	rc = m0t1fs_reqh_services_start();
-	if (rc != 0)
-		goto reqh_fini;
-	M0_RETURN(0);
-
-reqh_fini:
-	m0_reqh_fini(reqh);
-dbenv_fini:
-	m0_dbenv_fini(dbenv);
-pool_fini:
-	m0_rpc_net_buffer_pool_cleanup(buffer_pool);
-	M0_LEAVE("rc: %d", rc);
-	M0_ASSERT(rc != 0);
-	return rc;
-}
-
-static void m0t1fs_mon_rw_io_watch(const struct m0_addb_monitor *mon,
-				   const struct m0_addb_rec     *rec,
-				   struct m0_reqh               *reqh)
-{
-	struct m0_addb_sum_rec                  *sum_rec;
-	struct m0t1fs_addb_mon_sum_data_io_size *sum_data =
-				&m0t1fs_globals.g_addb_mon_sum_data_rw_io_size;
-
-	if (m0_addb_rec_rid_make(M0_ADDB_BRT_DP, M0T1FS_ADDB_RECID_IO_FINISH)
-	    == rec->ar_rid) {
-		sum_rec = mon->am_ops->amo_sum_rec(mon, reqh);
-		M0_ASSERT(sum_rec != NULL);
-
-		m0_mutex_lock(&sum_rec->asr_mutex);
-		if (rec->ar_data.au64s_data[0] == IRT_READ) {
-			sum_data->sd_rio += rec->ar_data.au64s_data[1];
-			sum_rec->asr_dirty = true;
-		} else if (rec->ar_data.au64s_data[0] == IRT_WRITE) {
-			sum_data->sd_wio += rec->ar_data.au64s_data[1];
-			sum_rec->asr_dirty = true;
-		}
-		else
-			M0_IMPOSSIBLE("Invalid IO state");
-		m0_mutex_unlock(&sum_rec->asr_mutex);
-
-	}
-}
-
-static struct m0_addb_sum_rec *
-m0t1fs_mon_rw_io_sum_rec(const struct m0_addb_monitor *mon,
-		         struct m0_reqh               *reqh)
-{
-	struct m0_addb_sum_rec *sum_rec;
-
-	m0_rwlock_read_lock(&reqh->rh_rwlock);
-	sum_rec = m0_reqh_lockers_get(reqh,
-			m0t1fs_globals.g_addb_mon_rw_io_size_key);
-	m0_rwlock_read_unlock(&reqh->rh_rwlock);
-
-	return sum_rec;
-}
-
-const struct m0_addb_monitor_ops m0t1fs_addb_mon_rw_io_ops = {
-	.amo_watch   = m0t1fs_mon_rw_io_watch,
-	.amo_sum_rec = m0t1fs_mon_rw_io_sum_rec
-};
-
-static int m0t1fs_addb_mon_total_io_size_init(void)
-{
-	struct m0_addb_sum_rec *sum_rec;
-	struct m0_reqh         *reqh = &m0t1fs_globals.g_reqh;
-	uint32_t               *key = &m0t1fs_globals.g_addb_mon_rw_io_size_key;
-	uint64_t               *sum_data =
-		     (uint64_t *)&m0t1fs_globals.g_addb_mon_sum_data_rw_io_size;
-	uint32_t                sum_rec_nr =
-		     sizeof (m0t1fs_globals.g_addb_mon_sum_data_rw_io_size) /
-					     sizeof (uint64_t);
-	M0_ALLOC_PTR(sum_rec);
-	if (sum_rec == NULL)
-		M0_RETURN(-ENOMEM);
-
-	m0_addb_monitor_init(&m0t1fs_globals.g_addb_mon_rw_io_size,
-			     &m0t1fs_addb_mon_rw_io_ops);
-
-	m0_addb_monitor_sum_rec_init(sum_rec, &m0_addb_rt_m0t1fs_mon_io_size,
-				     sum_data, sum_rec_nr);
-
-	*key = m0_reqh_lockers_allot();
-
-	m0_rwlock_write_lock(&reqh->rh_rwlock);
-	m0_reqh_lockers_set(reqh, *key, sum_rec);
-	m0_rwlock_write_unlock(&reqh->rh_rwlock);
-
-	m0_addb_monitor_add(reqh, &m0t1fs_globals.g_addb_mon_rw_io_size);
-
-	return 0;
-}
-
-static void m0t1fs_addb_mon_total_io_size_fini(void)
-{
-	struct m0_addb_sum_rec *sum_rec;
-	struct m0_addb_monitor *mon = &m0t1fs_globals.g_addb_mon_rw_io_size;
-	struct m0_reqh         *reqh = &m0t1fs_globals.g_reqh;
-
-	sum_rec = mon->am_ops->amo_sum_rec(mon, &m0t1fs_globals.g_reqh);
-
-	m0_addb_monitor_del(reqh, mon);
-
-	m0_rwlock_write_lock(&reqh->rh_rwlock);
-	m0_reqh_lockers_clear(reqh, m0t1fs_globals.g_addb_mon_rw_io_size_key);
-	m0_rwlock_write_unlock(&reqh->rh_rwlock);
-	m0_addb_monitor_sum_rec_fini(sum_rec);
-	m0_free(sum_rec);
-	m0_addb_monitor_fini(mon);
-}
-
-static void m0t1fs_rpc_fini(void)
-{
-	M0_ENTRY();
-
-	m0t1fs_reqh_services_stop();
-	m0_reqh_rpc_mach_tlink_del_fini(&m0t1fs_globals.g_rpc_machine);
-	m0_rpc_machine_fini(&m0t1fs_globals.g_rpc_machine);
-	m0_reqh_fini(&m0t1fs_globals.g_reqh);
-	m0_dbenv_fini(&m0t1fs_globals.g_dbenv);
-	m0_rpc_net_buffer_pool_cleanup(&m0t1fs_globals.g_buffer_pool);
-
-	M0_LEAVE();
-}
-
-static int m0t1fs_layout_init(void)
-{
-	int rc;
-
-	M0_ENTRY();
-
-	rc = m0_layout_domain_init(&m0t1fs_globals.g_layout_dom,
-				   &m0t1fs_globals.g_dbenv);
-	if (rc == 0) {
-		rc = m0_layout_standard_types_register(
-						&m0t1fs_globals.g_layout_dom);
-		if (rc != 0)
-			m0_layout_domain_fini(&m0t1fs_globals.g_layout_dom);
-	}
-
-	M0_RETURN(rc);
-}
-
-static void m0t1fs_layout_fini(void)
-{
-	M0_ENTRY();
-
-	m0_layout_standard_types_unregister(&m0t1fs_globals.g_layout_dom);
-	m0_layout_domain_fini(&m0t1fs_globals.g_layout_dom);
-
-	M0_LEAVE();
-}
-
-static int m0t1fs_service_start(const char *sname)
-{
-	int                          rc;
-	struct m0_reqh              *reqh = &m0t1fs_globals.g_reqh;
-	struct m0_reqh_service_type *stype;
-	struct m0_reqh_service      *service;
-	struct m0_uint128            uuid;
-
-	stype = m0_reqh_service_type_find(sname);
-	if (stype == NULL)
-		M0_RETURN(-EINVAL);
-	rc = m0_reqh_service_allocate(&service, stype, NULL);
-	if (rc != 0)
-		M0_RETURN(rc);
-	m0_uuid_generate(&uuid);
-	m0_reqh_service_init(service, reqh, &uuid);
-	rc = m0_reqh_service_start(service);
-
-	M0_RETURN(rc);
-}
-
-static int m0t1fs_reqh_services_start(void)
-{
-	int rc;
-
-	rc = m0t1fs_service_start(M0_ADDB_SVC_NAME);
-	if (rc)
-		goto err;
-	rc = m0t1fs_service_start("rmservice");
-	if (rc)
-		goto err;
-	M0_RETURN(rc);
-err:
-	m0t1fs_reqh_services_stop();
-	M0_RETURN(rc);
-}
-
-static void m0t1fs_reqh_services_stop(void)
-{
-	m0_reqh_services_terminate(&m0t1fs_globals.g_reqh);
-}
+#undef M0_TRACE_SUBSYSTEM
diff --git a/m0t1fs/linux_kernel/m0t1fs.h b/m0t1fs/linux_kernel/m0t1fs.h
index 724c5ad..9edd00b 100644
--- a/m0t1fs/linux_kernel/m0t1fs.h
+++ b/m0t1fs/linux_kernel/m0t1fs.h
@@ -420,6 +420,17 @@ enum io_req_type {
         IRT_TYPE_NR,
 };
 
+extern char *local_addr;
+extern uint32_t tm_recv_queue_min_len;
+extern uint32_t max_rpc_msg_size;
+
+struct m0t1fs_mon_addb_globals {
+	struct m0_addb_monitor                  g_addb_mon_rw_io_size;
+	uint32_t                                g_addb_mon_rw_io_size_key;
+	struct m0t1fs_addb_mon_sum_data_io_size g_addb_mon_sum_data_rw_io_size;
+};
+extern struct m0t1fs_mon_addb_globals m0t1fs_mon_addb_globals;
+
 /** Anything that is global to m0t1fs module goes in this singleton structure.
     There is only one, global, instance of this type. */
 struct m0t1fs_globals {
@@ -434,13 +445,8 @@ struct m0t1fs_globals {
 	struct m0_fol                           g_fol;
 	struct m0_net_buffer_pool               g_buffer_pool;
 	struct m0_layout_domain                 g_layout_dom;
-	struct m0_addb_monitor                  g_addb_mon_rw_io_size;
-	uint32_t                                g_addb_mon_rw_io_size_key;
-	struct m0t1fs_addb_mon_sum_data_io_size g_addb_mon_sum_data_rw_io_size;
 };
 
-extern struct m0t1fs_globals m0t1fs_globals;
-
 /**
    For each <mounted_fs, target_service> pair, there is one instance of
    m0t1fs_service_context.
@@ -559,6 +565,8 @@ struct m0t1fs_sb {
 
 	/** Degraded mode Read[0] and write[1] I/O request statistics */
 	struct m0_addb_io_stats       csb_dgio_stats[2];
+
+	struct m0t1fs_globals         csb_m0t1fs_globals;
 };
 
 struct m0t1fs_filedata {
@@ -660,10 +668,10 @@ M0_INTERNAL int m0t1fs_inode_layout_init(struct m0t1fs_inode *ci);
 M0_INTERNAL struct m0_fid
 m0t1fs_ios_cob_fid(const struct m0t1fs_inode *ci, int index);
 
-M0_INTERNAL struct m0_rm_domain *m0t1fs_rmsvc_domain_get(void);
+M0_INTERNAL struct m0_rm_domain *m0t1fs_rmsvc_domain_get(struct m0_reqh *reqh);
 
 M0_INTERNAL void m0t1fs_file_lock_init(struct m0t1fs_inode    *ci,
-				       const struct m0t1fs_sb *csb);
+				       struct m0t1fs_sb *csb);
 
 M0_INTERNAL void m0t1fs_file_lock_fini(struct m0t1fs_inode *ci);
 
diff --git a/m0t1fs/linux_kernel/super.c b/m0t1fs/linux_kernel/super.c
index d6ad4e1..cee893e 100644
--- a/m0t1fs/linux_kernel/super.c
+++ b/m0t1fs/linux_kernel/super.c
@@ -36,19 +36,9 @@
 #include "conf/confc.h"    /* m0_confc */
 #include "rpc/rpclib.h"    /* m0_rcp_client_connect */
 #include "addb/addb.h"
+#include "lib/uuid.h"   /* m0_uuid_generate */
 #include "rpc/rpc_internal.h"
 
-static int m0t1fs_layout_build(const uint64_t         layout_id,
-			       const uint32_t         N,
-			       const uint32_t         K,
-			       const uint32_t         pool_width,
-			       const uint64_t         unit_size,
-			       struct m0_layout_enum *le,
-			       struct m0_layout     **layout);
-
-static int m0t1fs_cob_id_enum_build(const uint32_t pool_width,
-				    struct m0_layout_enum **lay_enum);
-
 extern struct io_mem_stats iommstats;
 
 M0_INTERNAL void io_bob_tlists_init(void);
@@ -503,7 +493,7 @@ static int connect_to_service(const char *addr, enum m0_conf_service_type type,
 
 	m0t1fs_service_context_init(ctx, csb, type);
 	rc = m0_rpc_client_connect(&ctx->sc_conn, &ctx->sc_session,
-				   &m0t1fs_globals.g_rpc_machine, addr,
+				   &csb->csb_m0t1fs_globals.g_rpc_machine, addr,
 				   M0T1FS_MAX_NR_RPC_IN_FLIGHT,
 				   M0T1FS_NR_SLOTS_PER_SESSION);
 	if (rc == 0) {
@@ -598,13 +588,14 @@ out:
 	M0_RETURN(rc);
 }
 
-static int configure_addb_rpc_sink(struct m0_addb_mc *addb_mc)
+static int configure_addb_rpc_sink(struct m0t1fs_sb *csb,
+				   struct m0_addb_mc *addb_mc)
 {
 
 	if (!m0_addb_mc_has_rpc_sink(addb_mc)) {
 		int rc = m0_addb_mc_configure_rpc_sink(addb_mc,
-						&m0t1fs_globals.g_rpc_machine,
-						&m0t1fs_globals.g_reqh,
+						&csb->csb_m0t1fs_globals.g_rpc_machine,
+						&csb->csb_m0t1fs_globals.g_reqh,
 						M0_ADDB_RPCSINK_TS_INIT_PAGES,
 						M0_ADDB_RPCSINK_TS_MAX_PAGES,
 						M0_ADDB_RPCSINK_TS_PAGE_SIZE);
@@ -730,7 +721,8 @@ static void m0t1fs_poolmach_destroy(struct m0_poolmach *mach)
 	m0_free(mach);
 }
 
-static int cl_map_build(struct m0t1fs_sb *csb, uint32_t nr_ios,
+static int cl_map_build(struct m0t1fs_sb       *csb,
+			uint32_t                nr_ios,
 			const struct fs_params *fs_params)
 {
 	struct m0t1fs_service_context        *ctx;
@@ -800,7 +792,8 @@ static int cl_map_build(struct m0t1fs_sb *csb, uint32_t nr_ios,
 /* ----------------------------------------------------------------
  * Layout
  * ---------------------------------------------------------------- */
-static int m0t1fs_layout_build(const uint64_t         layout_id,
+static int m0t1fs_layout_build(struct m0t1fs_sb      *csb,
+			       const uint64_t         layout_id,
 			       const uint32_t         N,
 			       const uint32_t         K,
 			       const uint32_t         pool_width,
@@ -825,7 +818,7 @@ static int m0t1fs_layout_build(const uint64_t         layout_id,
 	m0_uint128_init(&pl_attr.pa_seed, "upjumpandpumpim,");
 
 	*layout = NULL;
-	rc = m0_pdclust_build(&m0t1fs_globals.g_layout_dom,
+	rc = m0_pdclust_build(&csb->csb_m0t1fs_globals.g_layout_dom,
 			      layout_id, &pl_attr, le,
 			      &pdlayout);
 	if (rc == 0)
@@ -834,7 +827,8 @@ static int m0t1fs_layout_build(const uint64_t         layout_id,
 	M0_RETURN(rc);
 }
 
-static int m0t1fs_cob_id_enum_build(const uint32_t pool_width,
+static int m0t1fs_cob_id_enum_build(struct m0t1fs_sb *csb,
+				    const uint32_t pool_width,
 				    struct m0_layout_enum **lay_enum)
 {
 	struct m0_layout_linear_attr  lin_attr;
@@ -854,7 +848,7 @@ static int m0t1fs_cob_id_enum_build(const uint32_t pool_width,
 	};
 
 	*lay_enum = NULL;
-	rc = m0_linear_enum_build(&m0t1fs_globals.g_layout_dom,
+	rc = m0_linear_enum_build(&csb->csb_m0t1fs_globals.g_layout_dom,
 				  &lin_attr, &lle);
 	if (rc == 0)
 		*lay_enum = &lle->lle_base;
@@ -905,9 +899,9 @@ try_again:
 		break;
 	} while (1);
 
-	rc = m0t1fs_cob_id_enum_build(fs_params->fs_pool_width, &layout_enum);
+	rc = m0t1fs_cob_id_enum_build(csb, fs_params->fs_pool_width, &layout_enum);
 	if (rc == 0) {
-		rc = m0t1fs_layout_build(csb->csb_layout_id,
+		rc = m0t1fs_layout_build(csb, csb->csb_layout_id,
 					 fs_params->fs_nr_data_units,
 					 fs_params->fs_nr_parity_units,
 					 fs_params->fs_pool_width,
@@ -949,12 +943,286 @@ static void m0t1fs_sb_layout_fini(struct m0t1fs_sb *csb)
 	M0_LEAVE();
 }
 
+static int m0t1fs_service_start(const char *sname, struct m0_reqh *reqh)
+{
+	int                          rc;
+	struct m0_reqh_service_type *stype;
+	struct m0_reqh_service      *service;
+	struct m0_uint128            uuid;
+
+	stype = m0_reqh_service_type_find(sname);
+	if (stype == NULL)
+		M0_RETURN(-EINVAL);
+	rc = m0_reqh_service_allocate(&service, stype, NULL);
+	if (rc != 0)
+		M0_RETURN(rc);
+	m0_uuid_generate(&uuid);
+	m0_reqh_service_init(service, reqh, &uuid);
+	rc = m0_reqh_service_start(service);
+
+	M0_RETURN(rc);
+}
+
+static int m0t1fs_reqh_services_start(struct m0t1fs_sb *csb)
+{
+	struct m0_reqh *reqh = &csb->csb_m0t1fs_globals.g_reqh;
+	int rc;
+
+	rc = m0t1fs_service_start(M0_ADDB_SVC_NAME, reqh);
+	if (rc)
+		goto err;
+	rc = m0t1fs_service_start("rmservice", reqh);
+	if (rc)
+		goto err;
+	M0_RETURN(rc);
+err:
+	m0_reqh_services_terminate(reqh);
+	M0_RETURN(rc);
+}
+
+static int m0t1fs_net_init(struct m0t1fs_sb *csb)
+{
+	struct m0_net_xprt   *xprt;
+	struct m0_net_domain *ndom;
+	int		      rc;
+
+	M0_ENTRY();
+
+	csb->csb_m0t1fs_globals.g_laddr = local_addr;
+	xprt =  csb->csb_m0t1fs_globals.g_xprt;
+	ndom = &csb->csb_m0t1fs_globals.g_ndom;
+
+	rc = m0_net_xprt_init(xprt);
+	if (rc != 0)
+		goto out;
+
+	/** @todo replace &m0_addb_proc_ctx */
+	rc = m0_net_domain_init(ndom, xprt, &m0_addb_proc_ctx);
+	if (rc != 0)
+		m0_net_xprt_fini(xprt);
+out:
+	M0_LEAVE("rc: %d", rc);
+	return rc;
+}
+
+static void m0t1fs_net_fini(struct m0t1fs_sb *csb)
+{
+	M0_ENTRY();
+
+	m0_net_domain_fini(&csb->csb_m0t1fs_globals.g_ndom);
+	m0_net_xprt_fini(csb->csb_m0t1fs_globals.g_xprt);
+
+	M0_LEAVE();
+}
+
+static int m0t1fs_rpc_init(struct m0t1fs_sb *csb)
+{
+	struct m0_dbenv           *dbenv       = &csb->csb_m0t1fs_globals.g_dbenv;
+	char                      *db_name     =  csb->csb_m0t1fs_globals.g_db_name;
+	struct m0_rpc_machine     *rpc_machine = &csb->csb_m0t1fs_globals.g_rpc_machine;
+	struct m0_reqh            *reqh        = &csb->csb_m0t1fs_globals.g_reqh;
+	struct m0_net_domain      *ndom        = &csb->csb_m0t1fs_globals.g_ndom;
+	const char                *laddr       =  csb->csb_m0t1fs_globals.g_laddr;
+	struct m0_net_buffer_pool *buffer_pool = &csb->csb_m0t1fs_globals.g_buffer_pool;
+	struct m0_fol             *fol         = &csb->csb_m0t1fs_globals.g_fol;
+	struct m0_net_transfer_mc *tm;
+	int                        rc;
+	uint32_t		   bufs_nr;
+	uint32_t		   tms_nr;
+
+	M0_ENTRY();
+
+	tms_nr	 = 1;
+	bufs_nr  = m0_rpc_bufs_nr(tm_recv_queue_min_len, tms_nr);
+
+	rc = m0_rpc_net_buffer_pool_setup(ndom, buffer_pool,
+					  bufs_nr, tms_nr);
+	if (rc != 0)
+		goto pool_fini;
+
+	rc = m0_dbenv_init(dbenv, db_name, 0);
+	if (rc != 0)
+		goto pool_fini;
+
+	rc = M0_REQH_INIT(reqh,
+			  .rhia_dtm          = (void*)1,
+			  .rhia_db           = NULL,
+			  .rhia_mdstore      = (void*)1,
+			  .rhia_fol          = fol,
+			  .rhia_svc          = (void*)1);
+	if (rc != 0)
+		goto dbenv_fini;
+	rc = m0_rpc_machine_init(rpc_machine, ndom, laddr, reqh,
+				 buffer_pool, M0_BUFFER_ANY_COLOUR,
+				 max_rpc_msg_size, tm_recv_queue_min_len);
+	if (rc != 0)
+		goto reqh_fini;
+
+	m0_reqh_start(reqh);
+	tm = &rpc_machine->rm_tm;
+	M0_ASSERT(tm->ntm_recv_pool == buffer_pool);
+
+	m0_reqh_rpc_mach_tlink_init_at_tail(rpc_machine,
+					    &reqh->rh_rpc_machines);
+
+	M0_RETURN(0);
+
+reqh_fini:
+	m0_reqh_fini(reqh);
+dbenv_fini:
+	m0_dbenv_fini(dbenv);
+pool_fini:
+	m0_rpc_net_buffer_pool_cleanup(buffer_pool);
+	M0_LEAVE("rc: %d", rc);
+	M0_ASSERT(rc != 0);
+	return rc;
+}
+
+struct m0t1fs_mon_addb_globals m0t1fs_mon_addb_globals;
+
+static void m0t1fs_mon_rw_io_watch(const struct m0_addb_monitor *mon,
+				   const struct m0_addb_rec     *rec,
+				   struct m0_reqh               *reqh)
+{
+	struct m0_addb_sum_rec                  *sum_rec;
+	struct m0t1fs_addb_mon_sum_data_io_size *sum_data =
+				&m0t1fs_mon_addb_globals.g_addb_mon_sum_data_rw_io_size;
+
+	if (m0_addb_rec_rid_make(M0_ADDB_BRT_DP, M0T1FS_ADDB_RECID_IO_FINISH)
+	    == rec->ar_rid) {
+		sum_rec = mon->am_ops->amo_sum_rec(mon, reqh);
+		M0_ASSERT(sum_rec != NULL);
+
+		m0_mutex_lock(&sum_rec->asr_mutex);
+		if (rec->ar_data.au64s_data[0] == IRT_READ) {
+			sum_data->sd_rio += rec->ar_data.au64s_data[1];
+			sum_rec->asr_dirty = true;
+		} else if (rec->ar_data.au64s_data[0] == IRT_WRITE) {
+			sum_data->sd_wio += rec->ar_data.au64s_data[1];
+			sum_rec->asr_dirty = true;
+		}
+		else
+			M0_IMPOSSIBLE("Invalid IO state");
+		m0_mutex_unlock(&sum_rec->asr_mutex);
+
+	}
+}
+
+static struct m0_addb_sum_rec *
+m0t1fs_mon_rw_io_sum_rec(const struct m0_addb_monitor *mon,
+		         struct m0_reqh               *reqh)
+{
+	struct m0_addb_sum_rec *sum_rec;
+
+	m0_rwlock_read_lock(&reqh->rh_rwlock);
+	sum_rec = m0_reqh_lockers_get(reqh,
+			m0t1fs_mon_addb_globals.g_addb_mon_rw_io_size_key);
+	m0_rwlock_read_unlock(&reqh->rh_rwlock);
+
+	return sum_rec;
+}
+
+const struct m0_addb_monitor_ops m0t1fs_addb_mon_rw_io_ops = {
+	.amo_watch   = m0t1fs_mon_rw_io_watch,
+	.amo_sum_rec = m0t1fs_mon_rw_io_sum_rec
+};
+
+static int m0t1fs_addb_mon_total_io_size_init(struct m0t1fs_sb *csb)
+{
+	struct m0_addb_sum_rec *sum_rec;
+	struct m0_reqh         *reqh = &csb->csb_m0t1fs_globals.g_reqh;
+	uint32_t               *key = &m0t1fs_mon_addb_globals.g_addb_mon_rw_io_size_key;
+	uint64_t               *sum_data =
+		     (uint64_t *)&m0t1fs_mon_addb_globals.g_addb_mon_sum_data_rw_io_size;
+	uint32_t                sum_rec_nr =
+		     sizeof (m0t1fs_mon_addb_globals.g_addb_mon_sum_data_rw_io_size) /
+					     sizeof (uint64_t);
+	M0_ALLOC_PTR(sum_rec);
+	if (sum_rec == NULL)
+		M0_RETURN(-ENOMEM);
+
+	m0_addb_monitor_init(&m0t1fs_mon_addb_globals.g_addb_mon_rw_io_size,
+			     &m0t1fs_addb_mon_rw_io_ops);
+
+	m0_addb_monitor_sum_rec_init(sum_rec, &m0_addb_rt_m0t1fs_mon_io_size,
+				     sum_data, sum_rec_nr);
+
+	*key = m0_reqh_lockers_allot();
+
+	m0_rwlock_write_lock(&reqh->rh_rwlock);
+	m0_reqh_lockers_set(reqh, *key, sum_rec);
+	m0_rwlock_write_unlock(&reqh->rh_rwlock);
+
+	m0_addb_monitor_add(reqh, &m0t1fs_mon_addb_globals.g_addb_mon_rw_io_size);
+
+	return 0;
+}
+
+static void m0t1fs_addb_mon_total_io_size_fini(struct m0t1fs_sb *csb)
+{
+	struct m0_addb_sum_rec *sum_rec;
+	struct m0_addb_monitor *mon = &m0t1fs_mon_addb_globals.g_addb_mon_rw_io_size;
+	struct m0_reqh         *reqh = &csb->csb_m0t1fs_globals.g_reqh;
+
+	sum_rec = mon->am_ops->amo_sum_rec(mon, &csb->csb_m0t1fs_globals.g_reqh);
+
+	m0_addb_monitor_del(reqh, mon);
+
+	m0_rwlock_write_lock(&reqh->rh_rwlock);
+	m0_reqh_lockers_clear(reqh, m0t1fs_mon_addb_globals.g_addb_mon_rw_io_size_key);
+	m0_rwlock_write_unlock(&reqh->rh_rwlock);
+	m0_addb_monitor_sum_rec_fini(sum_rec);
+	m0_free(sum_rec);
+	m0_addb_monitor_fini(mon);
+}
+
+static void m0t1fs_rpc_fini(struct m0t1fs_sb *csb)
+{
+	M0_ENTRY();
+
+	m0_reqh_rpc_mach_tlink_del_fini(&csb->csb_m0t1fs_globals.g_rpc_machine);
+	m0_rpc_machine_fini(&csb->csb_m0t1fs_globals.g_rpc_machine);
+	m0_reqh_fini(&csb->csb_m0t1fs_globals.g_reqh);
+	m0_dbenv_fini(&csb->csb_m0t1fs_globals.g_dbenv);
+	m0_rpc_net_buffer_pool_cleanup(&csb->csb_m0t1fs_globals.g_buffer_pool);
+
+	M0_LEAVE();
+}
+
+static int m0t1fs_layout_init(struct m0t1fs_sb *csb)
+{
+	int rc;
+
+	M0_ENTRY();
+
+	rc = m0_layout_domain_init(&csb->csb_m0t1fs_globals.g_layout_dom,
+				   &csb->csb_m0t1fs_globals.g_dbenv);
+	if (rc == 0) {
+		rc = m0_layout_standard_types_register(
+						&csb->csb_m0t1fs_globals.g_layout_dom);
+		if (rc != 0)
+			m0_layout_domain_fini(&csb->csb_m0t1fs_globals.g_layout_dom);
+	}
+
+	M0_RETURN(rc);
+}
+
+static void m0t1fs_layout_fini(struct m0t1fs_sb *csb)
+{
+	M0_ENTRY();
+
+	m0_layout_standard_types_unregister(&csb->csb_m0t1fs_globals.g_layout_dom);
+	m0_layout_domain_fini(&csb->csb_m0t1fs_globals.g_layout_dom);
+
+	M0_LEAVE();
+}
+
+
 static int m0t1fs_setup(struct m0t1fs_sb *csb, const struct mount_opts *mops)
 {
 	struct m0t1fs_service_context *ctx;
 	struct m0_confc                confc;
 	struct m0_conf_obj            *fs;
-	struct m0_reqh                *reqh = &m0t1fs_globals.g_reqh;
 	const char                    *ep_addr;
 	uint32_t                       nr_ios = 0;
 	int                            rc;
@@ -964,40 +1232,60 @@ static int m0t1fs_setup(struct m0t1fs_sb *csb, const struct mount_opts *mops)
 	M0_ENTRY();
 	M0_PRE(csb->csb_astthread.t_state == TS_RUNNING);
 
-	csb->csb_next_key = mops->mo_fid_start;
+////
+	rc = m0t1fs_net_init(csb);
+	if (rc != 0)
+		goto err_return;
 
-	rc = m0_confc_init(&confc, &csb->csb_iogroup,
-			   &M0_BUF_INITS(mops->mo_profile),
-			   mops->mo_confd, &m0t1fs_globals.g_rpc_machine,
-			   mops->mo_local_conf);
+	rc = m0t1fs_rpc_init(csb);
 	if (rc != 0)
-		M0_RETURN(rc);
+		goto err_net_fini;
 
-	rc = m0_confc_open_sync(&fs, confc.cc_root, M0_BUF_INITS("filesystem"));
+	rc = m0t1fs_addb_mon_total_io_size_init(csb);
 	if (rc != 0)
-		goto end;
+		goto err_rpc_fini;
 
-	rc = fs_params_parse(&fs_params,
-			     M0_CONF_CAST(fs, m0_conf_filesystem)->cf_params) ?:
-		connect_to_services(csb, fs, &nr_ios);
+	rc = m0t1fs_layout_init(csb);
+	if (rc != 0)
+		goto err_addb_mon_fini;
+////
+	
+	csb->csb_next_key = mops->mo_fid_start;
 
-	m0_tl_for(svc_ctx, &csb->csb_service_contexts, ctx) {
-		if (ctx->sc_type == M0_CST_SS) {
-			stats_svc_is_provided = true;
-			break;
+	rc = m0_confc_init(&confc, &csb->csb_iogroup,
+			   &M0_BUF_INITS(mops->mo_profile),
+			   mops->mo_confd, &csb->csb_m0t1fs_globals.g_rpc_machine,
+			   mops->mo_local_conf);
+	if (rc == 0) {
+		int rc2 = 0;
+		rc = m0_confc_open_sync(&fs, confc.cc_root, M0_BUF_INITS("filesystem"));
+		if (rc == 0) {
+			rc2 = fs_params_parse(&fs_params,
+					     M0_CONF_CAST(fs, m0_conf_filesystem)->cf_params) ?:
+						connect_to_services(csb, fs, &nr_ios);
+
+			m0_tl_for(svc_ctx, &csb->csb_service_contexts, ctx) {
+				if (ctx->sc_type == M0_CST_SS) {
+					stats_svc_is_provided = true;
+					break;
+				}
+			} m0_tlist_endfor;
+			if (stats_svc_is_provided) {
+				ep_addr = ctx->sc_conn.c_rpcchan->rc_destep->nep_addr;
+				m0_addb_monitor_setup(&csb->csb_m0t1fs_globals.g_reqh, &ctx->sc_conn, ep_addr);
+				M0_LOG(M0_DEBUG, "Stats service connected");
+			} else
+				M0_LOG(M0_WARN, "Stats service not connected");
+			m0_confc_close(fs);
 		}
-	} m0_tlist_endfor;
-	if (stats_svc_is_provided) {
-		ep_addr = ctx->sc_conn.c_rpcchan->rc_destep->nep_addr;
-		m0_addb_monitor_setup(reqh, &ctx->sc_conn, ep_addr);
-		M0_LOG(M0_DEBUG, "Stats service connected");
-	} else
-		M0_LOG(M0_WARN, "Stats service not connected");
-	m0_confc_close(fs);
+		m0_confc_fini(&confc);
+		if (rc2 != 0)
+			goto err_disconnect;
+	}
 	if (rc != 0)
-		goto end;
+		goto err_layout_fini;
 
-	rc = configure_addb_rpc_sink(&m0_addb_gmc);
+	rc = configure_addb_rpc_sink(csb, &m0_addb_gmc);
 	if (rc != 0)
 		goto err_disconnect;
 
@@ -1015,11 +1303,18 @@ static int m0t1fs_setup(struct m0t1fs_sb *csb, const struct mount_opts *mops)
 	if (rc != 0)
 		goto err_poolmach_destroy;
 
+	/* Start resource manager service */
+	rc = m0t1fs_reqh_services_start(csb);
+	if (rc != 0)
+		goto err_poolmach_destroy;
+
 	rc = m0t1fs_sb_layout_init(csb, &fs_params);
-	if (rc == 0)
-		goto end;
+	if (rc != 0)
+		goto err_service_terminate;
+	M0_RETURN(0);
 
-	m0t1fs_sb_layout_fini(csb);
+err_service_terminate:
+	m0_reqh_services_terminate(&csb->csb_m0t1fs_globals.g_reqh);
 err_poolmach_destroy:
 	m0t1fs_poolmach_destroy(csb->csb_pool.po_mach);
 err_pool_fini:
@@ -1030,9 +1325,15 @@ addb_mc_unconf:
 	m0_addb_mc_init(&m0_addb_gmc);
 err_disconnect:
 	disconnect_from_services(csb);
-
-end:
-	m0_confc_fini(&confc);
+err_layout_fini:
+	m0t1fs_layout_fini(csb);
+err_addb_mon_fini:
+	m0t1fs_addb_mon_total_io_size_fini(csb);
+err_rpc_fini:
+	m0t1fs_rpc_fini(csb);
+err_net_fini:
+	m0t1fs_net_fini(csb);
+err_return:
 	M0_RETURN(rc);
 }
 
@@ -1045,6 +1346,12 @@ static void m0t1fs_teardown(struct m0t1fs_sb *csb)
 	m0_addb_mc_fini(&m0_addb_gmc);
 	m0_addb_mc_init(&m0_addb_gmc);
 	disconnect_from_services(csb);
+	m0_reqh_services_terminate(&csb->csb_m0t1fs_globals.g_reqh);
+	m0_reqh_fini(&csb->csb_m0t1fs_globals.g_reqh);
+	m0t1fs_layout_fini(csb);
+	m0t1fs_addb_mon_total_io_size_fini(csb);
+	m0t1fs_rpc_fini(csb);
+	m0t1fs_net_fini(csb);
 }
 
 static int m0t1fs_root_alloc(struct super_block *sb)
diff --git a/m0t1fs/linux_kernel/ut/file.c b/m0t1fs/linux_kernel/ut/file.c
index 8909526..8cb5187 100644
--- a/m0t1fs/linux_kernel/ut/file.c
+++ b/m0t1fs/linux_kernel/ut/file.c
@@ -84,6 +84,9 @@ static struct m0t1fs_service_context ctx;
 static struct m0_poolmach            poolmach;
 static struct m0_rm_remote           creditor;
 static struct m0t1fs_service_context msc;
+static struct m0_layout_domain       g_layout_dom;
+static struct m0_net_domain          g_ndom;
+static struct m0_rpc_machine         g_rpc_machine;
 
 M0_TL_DESCR_DECLARE(rpcbulk, M0_EXTERN);
 M0_TL_DECLARE(rpcbulk, M0_INTERNAL, struct m0_rpc_bulk_buf);
@@ -114,7 +117,7 @@ static int file_io_ut_init(void)
                 .lla_B  = ATTR_B_CONST,
         };
         llenum = NULL;
-        rc = m0_linear_enum_build(&m0t1fs_globals.g_layout_dom, &llattr,
+        rc = m0_linear_enum_build(&g_layout_dom, &llattr,
 			          &llenum);
         M0_ASSERT(rc == 0);
 
@@ -128,7 +131,7 @@ static int file_io_ut_init(void)
 
         };
         m0_uint128_init(&pdattr.pa_seed, "upjumpandpumpim,");
-        rc = m0_pdclust_build(&m0t1fs_globals.g_layout_dom, csb.csb_layout_id,
+        rc = m0_pdclust_build(&g_layout_dom, csb.csb_layout_id,
 			      &pdattr, &llenum->lle_base, &pdlay);
         M0_ASSERT(rc == 0);
         M0_ASSERT(pdlay != NULL);
@@ -712,8 +715,8 @@ static void target_ioreq_test(void)
 	size = IOVEC_NR * PAGE_CACHE_SIZE;
 	req.ir_sm.sm_state = IRS_READING;
 
-	ndom = &m0t1fs_globals.g_ndom;
-	conn.c_rpc_machine = &m0t1fs_globals.g_rpc_machine;
+	ndom = &g_ndom;
+	conn.c_rpc_machine = &g_rpc_machine;
 	session.s_conn = &conn;
 
 	aligned_buf = m0_alloc_aligned(M0_0VEC_ALIGN, M0_0VEC_SHIFT);
@@ -908,8 +911,8 @@ static void dgmode_readio_test(void)
 	M0_ALLOC_PTR(conn);
 	M0_UT_ASSERT(conn != NULL);
 	session->s_conn = conn;
-	conn->c_rpc_machine = &m0t1fs_globals.g_rpc_machine;
-	conn->c_rpc_machine->rm_tm.ntm_dom = &m0t1fs_globals.g_ndom;
+	conn->c_rpc_machine = &g_rpc_machine;
+	conn->c_rpc_machine->rm_tm.ntm_dom = &g_ndom;
 	ti->ti_session = session;
 
 	/* Creates IO fops from pages. */
diff --git a/rm/rm_service.c b/rm/rm_service.c
index a321ce8..254e975 100644
--- a/rm/rm_service.c
+++ b/rm/rm_service.c
@@ -182,8 +182,10 @@ static int rms_start(struct m0_reqh_service *service)
 
 	m0_rm_domain_init(&rms->rms_dom);
 
+	rms->rms_flock_rt.rt_name = "File Lock Resource Type";
+
 	/** Register various resource types */
-	m0_file_lock_type_register(&rms->rms_dom);
+	m0_file_lock_type_register(&rms->rms_dom, &rms->rms_flock_rt);
 
 	M0_RETURN(0);
 }
@@ -216,7 +218,7 @@ static void rms_stop(struct m0_reqh_service *service)
 		m0_free(owner);
 	} m0_tl_endfor;
 
-	m0_file_lock_type_deregister();
+	m0_file_lock_type_deregister(&rms->rms_flock_rt);
 	m0_rm_domain_fini(&rms->rms_dom);
 
 	M0_LEAVE();
diff --git a/rm/rm_service.h b/rm/rm_service.h
index e23306f..ca45c34 100644
--- a/rm/rm_service.h
+++ b/rm/rm_service.h
@@ -70,13 +70,19 @@
 
 struct m0_reqh_rm_service {
 	/** Request handler service representation */
-	struct m0_reqh_service rms_svc;
+	struct m0_reqh_service     rms_svc;
+
 	/** Resource manager domain */
-	struct m0_rm_domain    rms_dom;
+	struct m0_rm_domain        rms_dom;
+
+	/** Supported type: file lock */
+	struct m0_rm_resource_type rms_flock_rt;
+
 	/** Owners this service has created. */
-	struct m0_tl           rms_owners;
+	struct m0_tl               rms_owners;
+
 	/** rms_magic == M0_RM_SERVICE_MAGIC */
-	uint64_t               rms_magic;
+	uint64_t                   rms_magic;
 };
 
 M0_INTERNAL int m0_rms_register(void);
-- 
1.8.3.2

