From 0ed52d6bbe7bebe3b433754dde68c69de7b22432 Mon Sep 17 00:00:00 2001
From: Andriy Tkachuk <andriy_tkachuk@xyratex.com>
Date: Mon, 28 May 2012 17:29:30 +0300
Subject: [PATCH 2/2] rpc/session_fom: reply fop data embedded into fom

This is another part of the task "embed session fops into foms".

BTW, here is the description of the task (for convenience):

Date: Wed, 23 May 2012 20:02:42 +0400
From: Nikita Danilov <nikita_danilov@xyratex.com>
Subject: Re: embed session fops into foms task

the scope of the task is to

 * embed reply fops into foms, see session_gen_fom_create().
   You should use c2_fop_init() instead of c2_fop_alloc().
   This would avoid separate allocation of struct c2_fop;

 * avoid allocation of reply fop data: add a union of all
   possibly reply fop data to the session fom structure and
   pass address of this union as a "data" parameter to c2_fop_init().
   Use C2_CASSERT() to verify that reply fop data union is
   sufficiently large.
---
 fop/fop.c          |  3 ++-
 rpc/session_foms.c | 17 +++++++++++++++--
 rpc/session_foms.h |  7 +++++++
 3 files changed, 24 insertions(+), 3 deletions(-)

diff --git a/fop/fop.c b/fop/fop.c
index 9253437..df177e6 100644
--- a/fop/fop.c
+++ b/fop/fop.c
@@ -84,7 +84,8 @@ void c2_fop_fini(struct c2_fop *fop)
 
 	c2_rpc_item_fini(&fop->f_item);
 	c2_addb_ctx_fini(&fop->f_addb);
-	c2_free(fop->f_data.fd_data);
+	if (fop->f_data.fd_data != NULL)
+		c2_free(fop->f_data.fd_data);
 	c2_list_link_fini(&fop->f_link);
 }
 
diff --git a/rpc/session_foms.c b/rpc/session_foms.c
index 778146f..c5ab61c 100644
--- a/rpc/session_foms.c
+++ b/rpc/session_foms.c
@@ -54,13 +54,24 @@
 extern void item_exit_stats_set(struct c2_rpc_item   *item,
 				enum c2_rpc_item_path path);
 
+/**
+ * Custom rio_free call-back for reply fop
+ *
+ * Reply fop along with its data is embedded in the session fom, that's why
+ * we need this custom call-back:
+ *
+ *   - to avoid the freeing of these data here (call c2_fop_fini() only);
+ *
+ *   - to signal the fom (so it could be finalized).
+ */
 static void rep_fop_item_free(struct c2_rpc_item *item)
 {
 	struct c2_fop         *fop;
 	struct c2_session_fom *s_fom;
 
 	fop = c2_rpc_item_to_fop(item);
-	/* reply fop is embedded into session fom - so don't free it here */
+
+	fop->f_data.fd_data = NULL; /* c2_fop_fini() should not touch it */
 	c2_fop_fini(fop);
 
 	s_fom = container_of(fop, struct c2_session_fom, sf_rep_fop);
@@ -139,7 +150,9 @@ static int session_gen_fom_create(struct c2_fop *fop, struct c2_fom **out_fom)
 		goto out;
 	}
 
-	rc = c2_fop_init(reply_fop, reply_fopt, NULL);
+	C2_ASSERT(reply_fopt->ft_top->fft_layout->fm_sizeof <=
+	          sizeof(s_fom->sf_rep_fop_data_u));
+	rc = c2_fop_init(reply_fop, reply_fopt, &s_fom->sf_rep_fop_data_u);
 	if (rc != 0)
 		goto out;
 	reply_fop->f_item.ri_ops = &rep_fop_item_ops;
diff --git a/rpc/session_foms.h b/rpc/session_foms.h
index 0bc2976..54c6ee5 100644
--- a/rpc/session_foms.h
+++ b/rpc/session_foms.h
@@ -75,6 +75,13 @@ extern const struct c2_fom_ops c2_rpc_fom_session_establish_ops;
 struct c2_session_fom {
 	struct c2_fom	sf_fom;		/**< base fom */
 	struct c2_fop	sf_rep_fop;	/**< reply fop */
+	/** all possible reply fop data */
+	union {
+		struct c2_rpc_fop_conn_establish_rep    u_ce;
+		struct c2_rpc_fop_conn_terminate_rep    u_ct;
+		struct c2_rpc_fop_session_establish_rep u_se;
+		struct c2_rpc_fop_session_terminate_rep u_st;
+	} sf_rep_fop_data_u;
 	/** to make sure we destroy the fom after reply fop is finalized */
 	struct c2_chan  sf_chan;
 };
-- 
1.8.3.2

