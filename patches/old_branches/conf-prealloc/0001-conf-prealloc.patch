From 145d6790abba02f2e4344bdf2e986c5fd860b8ca Mon Sep 17 00:00:00 2001
From: Mandar Sawant <mandar_sawant@xyratex.com>
Date: Tue, 25 Mar 2014 19:36:07 +0530
Subject: [PATCH 1/5] conf-prealloc, - Calculate and pre-alocate BE segment
 memory and use it to allocate configuration   object through xcode. - Remove
 BE dependancy from xcode. - Save confx allocator information with
 configuration objects in conf btree to   help cleanup. - Add documentation.

---
 addb/user_space/addb_retrieval.c |   2 +-
 addb/ut/addb_ut_fom.c            |   4 +-
 addb/ut/addb_ut_stobsink.c       |   4 +-
 conf/db.c                        | 278 +++++++++++++++++++++++++++++++--------
 conf/preload.c                   |   2 +-
 file/file.c                      |   2 +-
 fol/fol.c                        |   4 +-
 fop/fop.c                        |   2 +-
 stats/stats_api.c                |   2 +-
 xcode/ut/xcode.c                 |   6 +-
 xcode/xcode.c                    | 123 +++++++++--------
 xcode/xcode.h                    |  18 ++-
 12 files changed, 313 insertions(+), 134 deletions(-)

diff --git a/addb/user_space/addb_retrieval.c b/addb/user_space/addb_retrieval.c
index e2c5a6d..aaa80de 100644
--- a/addb/user_space/addb_retrieval.c
+++ b/addb/user_space/addb_retrieval.c
@@ -579,7 +579,7 @@ static void addb_cursor_rec_free(struct m0_addb_cursor *cur)
 			.xo_ptr  = cur->ac_rec,
 		};
 
-		m0_xcode_free(&obj);
+		M0_XCODE_FREE(&obj, NULL, NULL);
 		cur->ac_rec = NULL;
 	}
 }
diff --git a/addb/ut/addb_ut_fom.c b/addb/ut/addb_ut_fom.c
index 10f4524..e875b07 100644
--- a/addb/ut/addb_ut_fom.c
+++ b/addb/ut/addb_ut_fom.c
@@ -205,8 +205,8 @@ static void addb_ut_fom_test(void)
 	m0_stob_put(ut_data.aufd_stob);
 	dom->sd_ops->sdo_fini(dom);
 	for (i = 0; i < UT_ADDB_FOM_REC_NR; ++i)
-		m0_xcode_free(&M0_XCODE_OBJ(m0_addb_rec_xc,
-					    ut_addb_rec_arr[i]));
+		M0_XCODE_FREE(&M0_XCODE_OBJ(m0_addb_rec_xc,
+					    ut_addb_rec_arr[i]), NULL, NULL);
 	addb_ct_tlist_del(&m0__addb_ut_ct0);
 	m0__addb_ut_ct0.act_magic = 0;
 	addb_rt_tlist_del(&m0__addb_ut_rt_dp1);
diff --git a/addb/ut/addb_ut_stobsink.c b/addb/ut/addb_ut_stobsink.c
index 589d3f1..2fe6232 100644
--- a/addb/ut/addb_ut_stobsink.c
+++ b/addb/ut/addb_ut_stobsink.c
@@ -455,7 +455,7 @@ static void addb_ut_stobsink_verify(struct stobsink *sink)
 			if (m0_addb_rec_is_ctx(r)) {
 				ctx_nr++;
 				obj.xo_ptr = r;
-				m0_xcode_free(&obj);
+				M0_XCODE_FREE(&obj, NULL, NULL);
 				continue;
 			}
 			M0_UT_ASSERT(r->ar_rid == dp_rid);
@@ -469,7 +469,7 @@ static void addb_ut_stobsink_verify(struct stobsink *sink)
 			}
 			count++;
 			obj.xo_ptr = r;
-			m0_xcode_free(&obj);
+			M0_XCODE_FREE(&obj, NULL, NULL);
 		}
 	}
 	M0_UT_ASSERT(ctx_nr == 1);
diff --git a/conf/db.c b/conf/db.c
index 61e8f63..a29d81e 100644
--- a/conf/db.c
+++ b/conf/db.c
@@ -95,6 +95,48 @@ static int confx_obj_measure(struct m0_confx_obj *xobj)
 	return M0_RC(m0_xcode_length(&ctx));
 }
 
+/* ------------------------------------------------------------------
+ * Database operations
+ * ------------------------------------------------------------------
+ */
+
+/**
+ * Contains BE segment memory allocation details. This preallocated
+ * BE segment memory is used to allocate configuration objects through
+ * xcode. This avoids blocking calls to BE allocator through xcode.
+ * The BE segment memory allocated to confx_allocator::a_chunk has to be
+ * released as a whole and cannot be released in pieces (i.e. allocated to
+ * configuration objects). Thus the confx_allocator is also added to the
+ * configuration btree along with the struct m0_confx_obj. This helps in
+ * releasing the memory as part of the db destruction.
+ */
+struct confx_allocator {
+	void                *a_chunk;
+	m0_bcount_t          a_total;
+	m0_bcount_t          a_used;
+};
+
+/**
+ * Maintains BE segment allocation details for configuration objects along with
+ * the configuration object to be allocated on the BE segment through xcode.
+ * Object of struct confx_obj_ctx is added to the configuration btree as a
+ * whole.
+ */
+struct confx_obj_ctx {
+	struct confx_allocator  oc_alloc;
+	struct m0_confx_obj    *oc_obj;
+};
+
+/**
+ * Maintains reference to configuration object allocator along with xcode ctx.
+ * struct confx_ctx::c_xcxtx is used to build configuration objects in BE
+ * segment memory which is accessed through struct confx_ctx::c_alloc.
+ */
+struct confx_ctx {
+	struct confx_allocator *c_alloc;
+	struct m0_xcode_ctx     c_xctx;
+};
+
 static m0_bcount_t confdb_ksize(const void *key)
 {
 	return sizeof(struct m0_fid);
@@ -102,7 +144,7 @@ static m0_bcount_t confdb_ksize(const void *key)
 
 static m0_bcount_t confdb_vsize(const void *val)
 {
-	return m0_confx_sizeof();
+	return m0_confx_sizeof() + sizeof(struct confx_allocator);
 }
 
 static const struct m0_be_btree_kv_ops confdb_ops = {
@@ -151,23 +193,46 @@ static void confdb_table_fini(struct m0_be_seg *seg)
 	M0_LEAVE();
 }
 
-/* ------------------------------------------------------------------
- * Database operations
- * ------------------------------------------------------------------ */
-static int confx_obj_dup(struct m0_confx_obj **dest, struct m0_confx_obj *src,
-			 struct m0_be_seg *seg, struct m0_be_tx *tx)
+static void *confdb_obj_alloc(struct m0_xcode_cursor *ctx, size_t nob)
+{
+	struct confx_ctx       *cctx;
+	struct confx_allocator *alloc;
+	char                   *addr;
+
+	cctx = container_of(container_of(ctx, struct m0_xcode_ctx, xcx_it),
+			    struct confx_ctx, c_xctx);
+	alloc = cctx->c_alloc;
+	M0_PRE(alloc->a_chunk != NULL);
+	M0_PRE(alloc->a_used + nob <= alloc->a_total);
+
+	addr = (char *)alloc->a_chunk + alloc->a_used;
+	alloc->a_used += nob;
+
+	return addr;
+}
+
+static int confx_obj_dup(struct confx_allocator *alloc,
+			 struct m0_confx_obj **dest,
+			 struct m0_confx_obj *src)
 {
 	struct m0_xcode_obj src_obj;
 	struct m0_xcode_obj dest_obj;
+	struct confx_ctx    cctx;
+	struct m0_xcode_ctx sctx;
 	int                 rc = 0;
 
 	confx_to_xcode_obj(src, &dest_obj, false);
 	confx_to_xcode_obj(src, &src_obj, true);
 	if (M0_FI_ENABLED("ut_confx_obj_dup_failure"))
 		rc = -EINVAL;
-	if (rc == 0)
-		rc = m0_xcode_be_dup(&dest_obj, &src_obj, seg, tx);
-	*dest = dest_obj.xo_ptr;
+	if (rc == 0) {
+		m0_xcode_ctx_init(&sctx, &src_obj);
+		m0_xcode_ctx_init(&cctx.c_xctx, &dest_obj);
+		cctx.c_alloc = alloc;
+		cctx.c_xctx.xcx_alloc = confdb_obj_alloc;
+		rc = m0_xcode_dup(&cctx.c_xctx, &sctx);
+	}
+	*dest = cctx.c_xctx.xcx_it.xcu_stack[0].s_obj.xo_ptr;
 	return rc;
 }
 
@@ -192,60 +257,73 @@ M0_INTERNAL int m0_confdb_create_credit(struct m0_be_seg *seg,
 		if (rc < 0)
 			break;
 		m0_be_btree_insert_credit(&btree, 1, sizeof(struct m0_fid),
-					  rc, accum);
+					  rc + sizeof(struct confx_allocator),
+					  accum);
 		rc = 0;
 	}
 
 	return M0_RC(rc);
 }
 
-M0_INTERNAL int m0_confdb_destroy_credit(struct m0_be_seg *seg,
-					 struct m0_be_tx_credit *accum)
+static int confdb_alloc(struct confx_allocator *alloc, struct m0_be_seg *seg,
+			struct m0_be_tx *tx, int size)
 {
-	struct m0_be_btree *btree;
-	int                 rc;
-
-	M0_ENTRY();
-	rc = m0_be_seg_dict_lookup(seg, btree_name, (void **)&btree);
-	if (rc == 0) {
-		m0_be_btree_destroy_credit(btree, 1, accum);
-		M0_BE_FREE_CREDIT_PTR(btree, seg, accum);
-	}
-	return M0_RC(rc);
+	M0_BE_OP_SYNC(__op,
+			m0_be_alloc(m0_be_seg_allocator(seg), tx, &__op,
+				&alloc->a_chunk, size));
+	M0_ASSERT(alloc->a_chunk != NULL);
+	if (alloc->a_chunk == NULL)
+		return -ENOMEM;
+	alloc->a_total = size;
+	alloc->a_used  = 0;
+
+	return 0;
 }
 
-M0_INTERNAL int m0_confdb_destroy(struct m0_be_seg *seg, struct m0_be_tx *tx)
+static m0_bcount_t conf_sizeof(const struct m0_confx *conf)
 {
-	struct m0_be_btree *btree;
-	int                 rc;
+	m0_bcount_t size = 0;
+	int         i;
+	int         rc;
 
-	M0_ENTRY();
-
-	/*
-	 * FIXME: Does not free the internal be objects allocated during
-	 *        confdb_create as part of xcode_dup operation.
-	 */
+	for (i = 0; i < conf->cx_nr; ++i) {
+		struct m0_confx_obj *obj;
 
-	rc = m0_be_seg_dict_lookup(seg, btree_name, (void **)&btree);
-	if (rc == 0) {
-		M0_BE_OP_SYNC(op, m0_be_btree_destroy(btree, tx, &op));
-		M0_BE_FREE_PTR_SYNC(btree, seg, tx);
-		rc = m0_be_seg_dict_delete(seg, tx, btree_name);
+		obj = M0_CONFX_AT(conf, i);
+		rc = confx_obj_measure(obj);
+		if (rc < 0) {
+			size = 0;
+			break;
+		}
+		size += m0_confx_sizeof() + rc;
 	}
-	return M0_RC(rc);
+
+	return size;
 }
 
-M0_INTERNAL void m0_confdb_fini(struct m0_be_seg *seg)
+static int confx_allocator_init(struct confx_allocator *alloc,
+				const struct m0_confx *conf,
+				struct m0_be_seg *seg, struct m0_be_tx *tx)
 {
-	confdb_table_fini(seg);
+	m0_bcount_t conf_size;
+	int         rc;
+
+	conf_size = conf_sizeof(conf);
+	if (conf_size == 0)
+		rc = -EINVAL;
+	if (rc == 0)
+		rc = confdb_alloc(alloc, seg, tx, conf_size);
+
+	return M0_RC(rc);
 }
 
 M0_INTERNAL int m0_confdb_create(struct m0_be_seg *seg, struct m0_be_tx *tx,
 				 const struct m0_confx *conf)
 {
-	struct m0_be_btree *btree;
-	int                 i;
-	int                 rc;
+	struct m0_be_btree     *btree;
+	struct confx_allocator  alloc;
+	int                     i;
+	int                     rc;
 
 	M0_ENTRY();
 	M0_PRE(conf->cx_nr > 0);
@@ -253,18 +331,27 @@ M0_INTERNAL int m0_confdb_create(struct m0_be_seg *seg, struct m0_be_tx *tx,
 	rc = confdb_table_init(seg, &btree, tx);
 	if (rc != 0)
 		return rc;
+	rc = confx_allocator_init(&alloc, conf, seg, tx);
 	for (i = 0; i < conf->cx_nr && rc == 0; ++i) {
-		struct m0_confx_obj *obj;
-		struct m0_buf        key;
-		struct m0_buf        val;
-
-		rc = confx_obj_dup(&obj, M0_CONFX_AT(conf, i), seg, tx);
+		struct confx_obj_ctx  obj_ctx;
+		struct m0_buf         key;
+		struct m0_buf         val;
+
+		/*
+		 * Save confx_allocator information along with the configuration
+		 * object in the btree.
+		 * Allocator information is replicated with all the configuration
+		 * objects in the btree.
+		 */
+		obj_ctx.oc_alloc = alloc;
+		rc = confx_obj_dup(&alloc, &obj_ctx.oc_obj, M0_CONFX_AT(conf, i));
 		if (rc != 0)
 			break;
-		M0_ASSERT(obj != NULL);
+		M0_ASSERT(obj_ctx.oc_obj != NULL);
 		/* discard const */
-		key = M0_FID_BUF((struct m0_fid *)m0_conf_objx_fid(obj));
-		val = M0_BUF_INIT(m0_confx_sizeof(), obj);
+		key = M0_FID_BUF((struct m0_fid *)m0_conf_objx_fid(obj_ctx.oc_obj));
+		val = M0_BUF_INIT(m0_confx_sizeof() +
+				  sizeof(struct confx_allocator), &obj_ctx);
 		rc = M0_BE_OP_SYNC_RET(op, m0_be_btree_insert(btree, tx,
 							      &op, &key, &val),
 				       bo_u.u_btree.t_rc);
@@ -276,6 +363,89 @@ M0_INTERNAL int m0_confdb_create(struct m0_be_seg *seg, struct m0_be_tx *tx,
 	return M0_RC(rc);
 }
 
+M0_INTERNAL int m0_confdb_destroy_credit(struct m0_be_seg *seg,
+					 struct m0_be_tx_credit *accum)
+{
+	struct m0_be_btree *btree;
+	int                 rc;
+
+	M0_ENTRY();
+	rc = m0_be_seg_dict_lookup(seg, btree_name, (void **)&btree);
+	if (rc == 0) {
+		m0_be_btree_destroy_credit(btree, 1, accum);
+		M0_BE_FREE_CREDIT_PTR(btree, seg, accum);
+	}
+	return M0_RC(rc);
+}
+
+static int __confdb_free(struct m0_be_btree *btree, struct m0_be_seg *seg,
+			 struct m0_be_tx *tx)
+{
+	struct m0_be_btree_cursor  bcur;
+	struct confx_allocator    *alloc = NULL;
+	struct confx_obj_ctx      *obj_ctx;
+	struct m0_buf              key;
+	struct m0_buf              val;
+	int                        rc;
+
+	m0_be_btree_cursor_init(&bcur, btree);
+	rc = m0_be_btree_cursor_first_sync(&bcur);
+	if (rc != 0) {
+		m0_be_btree_cursor_fini(&bcur);
+		return M0_RC(rc);
+	}
+	m0_be_btree_cursor_kv_get(&bcur, &key, &val);
+	/**
+	 * @todo check validity of key and record addresses and
+	 * sizes. Specifically, check that val.b_addr points to an
+	 * allocated region in a segment with appropriate size and
+	 * alignment. Such checks should be done generally by (not
+	 * existing) beobj interface.
+	 *
+	 * @todo also check that key (fid) matches m0_conf_objx_fid().
+	 */
+	obj_ctx = val.b_addr;
+	/*
+	 * Fetch the confx allocator information from the first configuration
+	 * object. Release pre-allocated BE segment memory from the allocator.
+	 */
+	alloc = &obj_ctx->oc_alloc;
+	m0_be_btree_cursor_fini(&bcur);
+	M0_BE_FREE_PTR_SYNC(alloc->a_chunk, seg, tx);
+
+	return M0_RC(rc);
+}
+
+M0_INTERNAL int m0_confdb_destroy(struct m0_be_seg *seg,
+				  struct m0_be_tx *tx)
+{
+	struct m0_be_btree        *btree;
+	int                        rc;
+
+	M0_ENTRY();
+
+	/*
+	 * FIXME: Does not free the internal be objects allocated during
+	 *        confdb_create as part of xcode_dup operation.
+	 */
+	rc = m0_be_seg_dict_lookup(seg, btree_name, (void **)&btree);
+	if (rc == 0)
+		rc = __confdb_free(btree, seg, tx);
+
+	if (rc == 0 || rc == -ENOENT) {
+		M0_BE_OP_SYNC(op, m0_be_btree_destroy(btree, tx, &op));
+		M0_BE_FREE_PTR_SYNC(btree, seg, tx);
+		rc = m0_be_seg_dict_delete(seg, tx, btree_name);
+	}
+
+	return M0_RC(rc);
+}
+
+M0_INTERNAL void m0_confdb_fini(struct m0_be_seg *seg)
+{
+	confdb_table_fini(seg);
+}
+
 static int confdb_objs_count(struct m0_be_btree *btree, size_t *result)
 {
 	struct m0_be_btree_cursor bcur;
@@ -328,8 +498,9 @@ static void confx_fill(struct m0_confx *dest, struct m0_be_btree *btree)
 	m0_be_btree_cursor_init(&bcur, btree);
 	for (i = 0, rc = m0_be_btree_cursor_first_sync(&bcur); rc == 0;
 	     rc = m0_be_btree_cursor_next_sync(&bcur), ++i) {
-		struct m0_buf key;
-		struct m0_buf val;
+		struct confx_obj_ctx *obj_ctx;
+		struct m0_buf         key;
+		struct m0_buf         val;
 
 		m0_be_btree_cursor_kv_get(&bcur, &key, &val);
 		M0_ASSERT(i < dest->cx_nr);
@@ -342,7 +513,8 @@ static void confx_fill(struct m0_confx *dest, struct m0_be_btree *btree)
 		 *
 		 * @todo also check that key (fid) matches m0_conf_objx_fid().
 		 */
-		memcpy(M0_CONFX_AT(dest, i), val.b_addr, val.b_nob);
+		obj_ctx = val.b_addr;
+		memcpy(M0_CONFX_AT(dest, i), obj_ctx->oc_obj, m0_confx_sizeof());
 	}
 	m0_be_btree_cursor_fini(&bcur);
 	/** @todo handle iteration errors. */
diff --git a/conf/preload.c b/conf/preload.c
index fe907d1..edc00fa 100644
--- a/conf/preload.c
+++ b/conf/preload.c
@@ -33,7 +33,7 @@ M0_INTERNAL void m0_confx_free(struct m0_confx *enc)
 {
 	M0_ENTRY();
 	if (enc != NULL)
-		m0_xcode_free(&M0_XCODE_OBJ(m0_confx_xc, enc));
+		M0_XCODE_FREE(&M0_XCODE_OBJ(m0_confx_xc, enc), NULL, NULL);
 	M0_LEAVE();
 }
 
diff --git a/file/file.c b/file/file.c
index 3b5620d..5b84517 100644
--- a/file/file.c
+++ b/file/file.c
@@ -333,7 +333,7 @@ static void file_lock_resource_free(struct m0_rm_resource *resource)
 	struct m0_file *fl;
 
 	fl = container_of(resource, struct m0_file, fi_res);
-	m0_xcode_free(&M0_XCODE_OBJ(m0_fid_xc, (void *)fl->fi_fid));
+	M0_XCODE_FREE(&M0_XCODE_OBJ(m0_fid_xc, (void *)fl->fi_fid), NULL, NULL);
 	m0_free(fl);
 }
 
diff --git a/fol/fol.c b/fol/fol.c
index e7df776..81205d6 100644
--- a/fol/fol.c
+++ b/fol/fol.c
@@ -403,14 +403,14 @@ M0_INTERNAL void m0_fol_rec_part_fini(struct m0_fol_rec_part *part)
 	m0_rec_part_tlink_fini(part);
 
 	if (part->rp_flag == M0_XCODE_DECODE) {
-		m0_xcode_free(&REC_PART_XCODE_OBJ(part));
+		M0_XCODE_FREE(&REC_PART_XCODE_OBJ(part), NULL, NULL);
 		m0_free(part);
 	} else {
 	    if (part->rp_ops->rpo_type == &m0_fop_fol_rec_part_type) {
 		m0_free(part->rp_data);
 		m0_free(part);
 	    } else
-		m0_xcode_free(&REC_PART_XCODE_OBJ(part));
+		M0_XCODE_FREE(&REC_PART_XCODE_OBJ(part), NULL, NULL);
 	}
 }
 
diff --git a/fop/fop.c b/fop/fop.c
index 7db7811..3b504d0 100644
--- a/fop/fop.c
+++ b/fop/fop.c
@@ -128,7 +128,7 @@ M0_INTERNAL void m0_fop_fini(struct m0_fop *fop)
 
 	m0_rpc_item_fini(&fop->f_item);
 	if (fop->f_data.fd_data != NULL)
-		m0_xcode_free(&M0_FOP_XCODE_OBJ(fop));
+		M0_XCODE_FREE(&M0_FOP_XCODE_OBJ(fop), NULL, NULL);
 	M0_LEAVE();
 }
 
diff --git a/stats/stats_api.c b/stats/stats_api.c
index 47da3e5..a1324ff 100644
--- a/stats/stats_api.c
+++ b/stats/stats_api.c
@@ -154,7 +154,7 @@ void m0_stats_free(struct m0_stats_recs *stats)
                 .xo_ptr  = stats,
 	};
 
-	m0_xcode_free(&obj);
+	M0_XCODE_FREE(&obj, NULL, NULL);
 }
 /*
  *  Local variables:
diff --git a/xcode/ut/xcode.c b/xcode/ut/xcode.c
index 698037c..e86a52a 100644
--- a/xcode/ut/xcode.c
+++ b/xcode/ut/xcode.c
@@ -451,7 +451,7 @@ static void xcode_decode_test(void)
 	M0_UT_ASSERT( TT->t_un.u.u_y   ==  T.t_un.u.u_y);
 	M0_UT_ASSERT(*TT->t_opaq.o_32  == *T.t_opaq.o_32);
 
-	m0_xcode_free(&decoded);
+	M0_XCODE_FREE(&decoded, NULL, NULL);
 }
 
 enum {
@@ -575,8 +575,8 @@ static void xcode_cmp_test(void)
 	M0_UT_ASSERT(cmp > 0);
 	t1->t_v.v_nr--;
 
-	m0_xcode_free(&obj0);
-	m0_xcode_free(&obj1);
+	M0_XCODE_FREE(&obj0, NULL, NULL);
+	M0_XCODE_FREE(&obj1, NULL, NULL);
 }
 
 #define OBJ(xt, ptr) (&(struct m0_xcode_obj){ .xo_type = (xt), .xo_ptr = (ptr) })
diff --git a/xcode/xcode.c b/xcode/xcode.c
index d0bf487..f3320c1 100644
--- a/xcode/xcode.c
+++ b/xcode/xcode.c
@@ -382,6 +382,23 @@ M0_INTERNAL void *m0_xcode_alloc(struct m0_xcode_cursor *it, size_t nob)
 	return m0_alloc(nob);
 }
 
+/*
+static void __xcode_free(struct m0_xcode_cursor *it)
+{
+	struct m0_xcode_cursor_frame *top = m0_xcode_cursor_top(it);
+	size_t                        nob = 0;
+	void                        **slot;
+
+	slot = allocp(it, &nob);
+	if (top->s_datum != 0) {
+		m0_free((void *) top->s_datum);
+		top->s_datum = 0;
+	}
+	if (nob != 0)
+		m0_free(*slot);
+}
+*/
+
 /**
  * Frees xcode object and its sub-objects.
  *
@@ -395,24 +412,27 @@ M0_INTERNAL void *m0_xcode_alloc(struct m0_xcode_cursor *it, size_t nob)
  * This is the only xcode function that has to deal with partially constructed
  * objects.
  */
-M0_INTERNAL void m0_xcode_free(struct m0_xcode_obj *obj)
+M0_INTERNAL void m0_xcode_free(struct m0_xcode_ctx *ctx)
 {
-	struct m0_xcode_cursor it;
+	struct m0_xcode_cursor *it;
 
-	m0_xcode_cursor_init(&it, obj);
-
-	while (m0_xcode_next(&it) > 0) {
-		struct m0_xcode_cursor_frame *top    = m0_xcode_cursor_top(&it);
+	//m0_xcode_cursor_init(&it, obj);
+	it = &ctx->xcx_it;
+	//if (ctx->xcx_free == NULL)
+	//	ctx->xcx_free = __xcode_free;
+	while (m0_xcode_next(it) > 0) {
+		struct m0_xcode_cursor_frame *top    = m0_xcode_cursor_top(it);
 		size_t                        nob    = 0;
 		struct m0_xcode_cursor_frame *prev   = top -1;
 		struct m0_xcode_obj          *par    = &prev->s_obj;
-		bool                          arrayp = at_array(&it, prev, par);
+		bool                          arrayp = at_array(it, prev, par);
 		void                        **slot;
 
 		if (top->s_flag == M0_XCODE_CURSOR_POST) {
-			slot = allocp(&it, &nob);
+			slot = allocp(it, &nob);
 			if (top->s_datum != 0) {
-				m0_free((void *) top->s_datum);
+				ctx->xcx_free == NULL ? m0_free((void *) top->s_datum) :
+							ctx->xcx_free(it);
 				top->s_datum = 0;
 			}
 			if (arrayp)
@@ -422,7 +442,9 @@ M0_INTERNAL void m0_xcode_free(struct m0_xcode_obj *obj)
 				 */
 				prev->s_datum = (uint64_t)*slot;
 			else if (nob != 0)
-				m0_free(*slot);
+				ctx->xcx_free == NULL ? m0_free(*slot) :
+							ctx->xcx_free(it);
+				//m0_free(*slot);
 		} else if (top->s_flag == M0_XCODE_CURSOR_PRE) {
 			/*
 			 * Deal with partially constructed objects.
@@ -433,68 +455,40 @@ M0_INTERNAL void m0_xcode_free(struct m0_xcode_obj *obj)
 					 * If array allocation failed, skip the
 					 * array entirely.
 					 */
-					--it.xcu_depth;
-				m0_xcode_skip(&it);
+					--it->xcu_depth;
+				m0_xcode_skip(it);
 			}
 		}
 	}
 }
 
-static ssize_t xcode_be_alloc(struct m0_be_seg *seg, struct m0_be_tx *tx,
-			      struct m0_xcode_cursor *it)
-{
-	struct m0_xcode_obj  *obj;
-	size_t                nob = 0;
-	void                **slot;
-
-	obj = &m0_xcode_cursor_top(it)->s_obj;
-
-	slot = allocp(it, &nob);
-	if (nob != 0 && *slot == NULL) {
-		M0_PRE(obj->xo_ptr == NULL);
-
-		M0_BE_ALLOC_ARR_SYNC(*slot, nob, seg, tx);
-		obj->xo_ptr = *slot;
-		if (obj->xo_ptr == NULL)
-			return -ENOMEM;
-	}
-	return 0;
-}
-
-static bool is_xcode_cursor_at(struct m0_xcode_cursor *it,
-			       enum m0_xcode_cursor_flag flag,
-			       enum m0_xcode_aggr aggr)
+M0_INTERNAL int m0_xcode_dup(struct m0_xcode_ctx *dest,
+			     struct m0_xcode_ctx *src)
 {
-	struct m0_xcode_cursor_frame *f = m0_xcode_cursor_top(it);
-
-	return (f->s_flag == flag &&
-		f->s_obj.xo_type->xct_aggr == aggr);
-}
+	struct m0_xcode_cursor  *dit;
+	struct m0_xcode_cursor  *sit;
+	int                      result;
 
-M0_INTERNAL int m0_xcode_be_dup(struct m0_xcode_obj *dest,
-				struct m0_xcode_obj *src, struct m0_be_seg *seg,
-				struct m0_be_tx *tx)
-{
-	struct m0_xcode_cursor  dit;
-	struct m0_xcode_cursor  sit;
-	int                     result;
+	//m0_xcode_cursor_init(&sit, src);
+	//m0_xcode_cursor_init(&dit, dest);
+	dit = &dest->xcx_it;
+	sit = &src->xcx_it;
 
-	M0_PRE(dest->xo_type == src->xo_type);
+	M0_ASSERT(m0_xcode_cursor_top(dit)->s_obj.xo_type ==
+		  m0_xcode_cursor_top(sit)->s_obj.xo_type);
 
-	m0_xcode_cursor_init(&sit, src);
-	m0_xcode_cursor_init(&dit, dest);
-	while ((result = m0_xcode_next(&sit)) > 0) {
+	while ((result = m0_xcode_next(sit)) > 0) {
 		struct m0_xcode_cursor_frame *sf;
 		struct m0_xcode_cursor_frame *df;
 		struct m0_xcode_obj          *sobj;
 		struct m0_xcode_obj          *dobj;
 		const struct m0_xcode_type   *xt;
 
-		result = m0_xcode_next(&dit);
+		result = m0_xcode_next(dit);
 		M0_ASSERT(result > 0);
 
-		sf = m0_xcode_cursor_top(&sit);
-		df = m0_xcode_cursor_top(&dit);
+		sf = m0_xcode_cursor_top(sit);
+		df = m0_xcode_cursor_top(dit);
 		M0_ASSERT(sf->s_flag == df->s_flag);
 		sobj = &sf->s_obj;
 		dobj = &df->s_obj;
@@ -504,7 +498,9 @@ M0_INTERNAL int m0_xcode_be_dup(struct m0_xcode_obj *dest,
 		if (sf->s_flag != M0_XCODE_CURSOR_PRE)
 			continue;
 
-		result = xcode_be_alloc(seg, tx, &dit);
+		result = m0_xcode_alloc_obj(dit, dest->xcx_alloc == NULL ?
+						 m0_xcode_alloc :
+						 dest->xcx_alloc);
 		if (result != 0)
 			return result;
 
@@ -514,13 +510,13 @@ M0_INTERNAL int m0_xcode_be_dup(struct m0_xcode_obj *dest,
 		}
 	}
 
-	if (result >= 0) {
-		result = 0;
-		*dest = m0_xcode_cursor_top(&dit)->s_obj;
-	}
+	//if (result >= 0) {
+	//	result = 0;
+	//	*dest = m0_xcode_cursor_top(dit)->s_obj;
+	//}
 
-	M0_POST(ergo(result == 0, m0_xcode_cmp(&dit.xcu_stack[0].s_obj,
-					       &sit.xcu_stack[0].s_obj) == 0));
+	M0_POST(ergo(result == 0, m0_xcode_cmp(&dit->xcu_stack[0].s_obj,
+					       &sit->xcu_stack[0].s_obj) == 0));
 	return result;
 }
 
@@ -554,7 +550,8 @@ M0_INTERNAL int m0_xcode_cmp(const struct m0_xcode_obj *o0,
 		xt = s0->xo_type;
 		M0_ASSERT(xt == s1->xo_type);
 
-		if (is_xcode_cursor_at(&it0, M0_XCODE_CURSOR_PRE, M0_XA_ATOM)) {
+		if (t0->s_flag == M0_XCODE_CURSOR_PRE &&
+		    xt->xct_aggr == M0_XA_ATOM) {
 			result = memcmp(s0->xo_ptr, s1->xo_ptr, xt->xct_sizeof);
 			if (result != 0)
 				return result;
diff --git a/xcode/xcode.h b/xcode/xcode.h
index bc98b14..6bd8d2a 100644
--- a/xcode/xcode.h
+++ b/xcode/xcode.h
@@ -534,6 +534,7 @@ struct m0_xcode_ctx {
 	   and all its non-inline sub-objects (arrays and opaque sub-objects).
 	 */
 	void                  *(*xcx_alloc)(struct m0_xcode_cursor *ctx, size_t);
+	void                   (*xcx_free)(struct m0_xcode_cursor *ctx);
 };
 
 /**
@@ -656,12 +657,21 @@ M0_INTERNAL int m0_xcode_read(struct m0_xcode_obj *obj, const char *str);
  */
 M0_INTERNAL int m0_xcode_print(const struct m0_xcode_obj *obj,
 			       char *str, int nr);
-M0_INTERNAL void m0_xcode_free(struct m0_xcode_obj *obj);
+
+#define M0_XCODE_FREE(obj, alloc, free)   \
+do {                                      \
+	struct m0_xcode_ctx __ctx;        \
+	m0_xcode_ctx_init(&__ctx, (obj)); \
+	__ctx.xcx_alloc = (alloc);        \
+	__ctx.xcx_free  = (free);         \
+	m0_xcode_free(&__ctx);            \
+} while (0)
+
+M0_INTERNAL void m0_xcode_free(struct m0_xcode_ctx *ctx);
 M0_INTERNAL int m0_xcode_cmp(const struct m0_xcode_obj *o0,
 			     const struct m0_xcode_obj *o1);
-M0_INTERNAL int m0_xcode_be_dup(struct m0_xcode_obj *dest,
-				struct m0_xcode_obj *src, struct m0_be_seg *seg,
-				struct m0_be_tx *tx);
+M0_INTERNAL int m0_xcode_dup(struct m0_xcode_ctx *dest,
+			     struct m0_xcode_ctx *src);
 
 /**
    Returns the address of a sub-object within an object.
-- 
1.8.3.2

