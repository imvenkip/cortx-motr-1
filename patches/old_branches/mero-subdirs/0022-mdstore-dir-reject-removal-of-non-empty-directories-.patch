From 9c53c8610ad05aef3ccfbd35ffe2c1b0d41112ca Mon Sep 17 00:00:00 2001
From: Alexander Gattin <alexander_gattin@xyratex.com>
Date: Sun, 10 Feb 2013 18:36:14 +0200
Subject: [PATCH 22/22] mdstore/dir: reject removal of non-empty directories
 with -ENOTEMPTY

* added m0_mdstore_dir_empty_check() helper for m0_mdstore_unlink()
* added more tracing to m0_mdstore_unlink()
* perform m0_mdstore_dir_empty_check() before unlinking directories
* changed code of m0_mdstore_readdir() to expect -ENOENT from
  m0_cob_iterator_get() and m0_cob_iterator_next() functions instead of 1
---
 mdstore/mdstore.c | 98 +++++++++++++++++++++++++++++++++++++++++++------------
 1 file changed, 78 insertions(+), 20 deletions(-)

diff --git a/mdstore/mdstore.c b/mdstore/mdstore.c
index 871c5a2..6544959 100644
--- a/mdstore/mdstore.c
+++ b/mdstore/mdstore.c
@@ -306,6 +306,54 @@ out:
 	return rc;
 }
 
+/**
+ * Checks that cob->co_fid directory is empty.
+ *
+ * @retval 0           Directory is empty.
+ * @retval -ENOTEMPTY  Directory isn not empty.
+ * @retval -ENOMEM     Memory allocation error.
+ */
+M0_INTERNAL int m0_mdstore_dir_empty_check(struct m0_mdstore *md,
+					   struct m0_cob     *cob,
+					   struct m0_db_tx   *tx)
+{
+	struct m0_cob_iterator  it;
+	struct m0_bitstring    *pos;
+	int                     rc;
+
+	M0_ENTRY();
+	pos = m0_bitstring_alloc(".", 1);
+	if (pos == NULL)
+		return -ENOMEM;
+	rc = m0_cob_iterator_init(cob, &it, pos, tx);
+	if (rc != 0) {
+		M0_LOG(M0_DEBUG, "iterator init: %d", rc);
+		goto out;
+	}
+	for (rc = m0_cob_iterator_get(&it);
+	     rc == 0 && m0_fid_eq(&it.ci_key->cnk_pfid, cob->co_fid);
+	     rc = m0_cob_iterator_next(&it)) {
+		M0_LOG(M0_DEBUG, "[%lx:%lx]/%.*s contains [%lx:%lx]/%.*s",
+		       cob->co_nskey->cnk_pfid.f_container,
+		       cob->co_nskey->cnk_pfid.f_key,
+		       m0_bitstring_len_get(&cob->co_nskey->cnk_name),
+		       (char *)m0_bitstring_buf_get(&cob->co_nskey->cnk_name),
+		       it.ci_key->cnk_pfid.f_container,
+		       it.ci_key->cnk_pfid.f_key,
+		       m0_bitstring_len_get(&it.ci_key->cnk_name),
+		       (char *)m0_bitstring_buf_get(&it.ci_key->cnk_name));
+		rc = -ENOTEMPTY;
+		break;
+	}
+	m0_cob_iterator_fini(&it);
+out:
+	m0_bitstring_free(pos);
+	if (rc == -ENOENT)
+		rc = 0;
+	M0_LEAVE("rc: %d", rc);
+	return rc;
+}
+
 M0_INTERNAL int m0_mdstore_unlink(struct m0_mdstore     *md,
 				  struct m0_fid         *pfid,
 				  struct m0_cob         *cob,
@@ -318,7 +366,15 @@ M0_INTERNAL int m0_mdstore_unlink(struct m0_mdstore     *md,
 	time_t                 now;
 	int                    rc;
 
-	M0_ENTRY();
+	M0_ENTRY("[%lx:%lx]/%.*s", pfid->f_container, pfid->f_key,
+		 (int)name->b_nob, (char *)name->b_addr);
+	M0_LOG(M0_DEBUG, "[%lx:%lx]/%.*s->[%lx:%lx],%d cob",
+	       cob->co_nskey->cnk_pfid.f_container,
+	       cob->co_nskey->cnk_pfid.f_key,
+	       m0_bitstring_len_get(&cob->co_nskey->cnk_name),
+	       (char *)m0_bitstring_buf_get(&cob->co_nskey->cnk_name),
+	       cob->co_nsrec.cnr_fid.f_container, 
+	       cob->co_nsrec.cnr_fid.f_key, cob->co_nsrec.cnr_linkno);
 	M0_ASSERT(pfid != NULL);
 	M0_ASSERT(cob != NULL);
 
@@ -406,19 +462,17 @@ M0_INTERNAL int m0_mdstore_unlink(struct m0_mdstore     *md,
 		m0_free(nskey);
 	} else {
 		/*
-		 * We ignore nlink for dirs and go for killing it.
-		 * This is because we don't update parent nlink in
-		 * case of killing subdirs. This results in a case
-		 * that dir will have nlink > 0 because correct
-		 * fop that will bring its nlink to zero will come
-		 * later.
+		 * TODO: we must take some sort of a lock
+		 * when doing check-before-modify update to directory.
 		 */
-		cob->co_nsrec.cnr_nlink = 0;
+		rc = m0_mdstore_dir_empty_check(md, cob, tx);
+		if (rc != 0)
+			goto out;
 		rc = m0_cob_delete(cob, tx);
-		if (rc == 0) {
-			/** Decrement cnr_nlink of parent directory. */
-			rc = m0_mdstore_dir_nlink_update(md, pfid, -1, tx);
-		}
+		if (rc != 0)
+			goto out;
+		/** Decrement cnr_nlink of parent directory. */
+		rc = m0_mdstore_dir_nlink_update(md, pfid, -1, tx);
 	}
 
 out:
@@ -676,17 +730,20 @@ M0_INTERNAL int m0_mdstore_readdir(struct m0_mdstore       *md,
 
 	rc = m0_cob_iterator_get(&it);
 	if (rc == 0) {
-		/*
-		 * Not exact position found and we are on least key
-		 * let's do one step forward.
-		 */
-		rc = m0_cob_iterator_next(&it);
-	} else if (rc > 0) {
 		if (!first) {
 			rc = m0_cob_iterator_next(&it);
 		} else {
 			rc = 0;
 		}
+	} else if (rc == -ENOENT) {
+		/*
+		 * Not exact position found and we are on least key
+		 * let's do one step forward.
+		 */
+		rc = m0_cob_iterator_next(&it);
+	} else {
+		M0_LOG(M0_DEBUG, "Iterator failed to get cursor with %d", rc);
+		goto out;
 	}
 
 	ent = rdpg->r_buf.b_addr;
@@ -708,7 +765,7 @@ M0_INTERNAL int m0_mdstore_readdir(struct m0_mdstore       *md,
 				       it.ci_key->cnk_pfid.f_key,
 				       cob->co_fid->f_container,
 				       cob->co_fid->f_key);
-				rc = 1;
+				rc = -ENOENT;
 				break;
 			}
 
@@ -745,7 +802,7 @@ M0_INTERNAL int m0_mdstore_readdir(struct m0_mdstore       *md,
 	}
 out_end:
 	m0_cob_iterator_fini(&it);
-	if (rc >= 0) {
+	if (rc == -ENOENT) {
 		if (last)
 			last->d_reclen = 0;
 		rdpg->r_end = m0_bitstring_alloc(m0_bitstring_buf_get(rdpg->r_pos),
@@ -754,6 +811,7 @@ out_end:
 		      "Setting last name to \"%.*s\"",
 		      (int)m0_bitstring_len_get(rdpg->r_pos),
 		      (char *)m0_bitstring_buf_get(rdpg->r_pos));
+		rc = ENOENT;
 	}
 out:
 	M0_LOG(M0_DEBUG, "Readdir finished with %d", rc);
-- 
1.8.3.2

