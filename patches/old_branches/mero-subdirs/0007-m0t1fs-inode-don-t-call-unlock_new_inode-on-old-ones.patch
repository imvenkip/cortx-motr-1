From 206cedad5262e8cd02d2a86384fb29418bc0cf64 Mon Sep 17 00:00:00 2001
From: Alexander Gattin <alexander_gattin@xyratex.com>
Date: Sat, 9 Feb 2013 23:12:05 +0200
Subject: [PATCH 07/22] m0t1fs/inode: don't call unlock_new_inode() on old ones

* properly retabulated m0t1fs/linux_kernel/inode.c file
* fixed m0t1fs_iget() to unlock only new inodes (with I_NEW
  flag) and ignore old ones
* changed copyright to 2013
---
 m0t1fs/linux_kernel/inode.c | 99 +++++++++++++++++++++++----------------------
 1 file changed, 50 insertions(+), 49 deletions(-)

diff --git a/m0t1fs/linux_kernel/inode.c b/m0t1fs/linux_kernel/inode.c
index cc5f52f..827f73c 100644
--- a/m0t1fs/linux_kernel/inode.c
+++ b/m0t1fs/linux_kernel/inode.c
@@ -1,5 +1,5 @@
 /*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
+ * COPYRIGHT 2013 XYRATEX TECHNOLOGY LIMITED
  *
  * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
  * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
@@ -61,7 +61,7 @@ static void init_once(void *foo)
 
 	M0_ENTRY();
 
-        m0_fid_set(&ci->ci_fid, 0, 0);
+	m0_fid_set(&ci->ci_fid, 0, 0);
 	inode_init_once(&ci->ci_inode);
 
 	M0_LEAVE();
@@ -162,24 +162,24 @@ M0_INTERNAL void m0t1fs_destroy_inode(struct inode *inode)
 }
 
 M0_INTERNAL struct inode *m0t1fs_root_iget(struct super_block *sb,
-                                           struct m0_fid *root_fid)
+					   struct m0_fid *root_fid)
 {
-        struct m0_fop_getattr_rep *rep = NULL;
+	struct m0_fop_getattr_rep *rep = NULL;
 	struct m0t1fs_mdop mo;
 	struct inode *inode;
 	int rc;
 
 	M0_ENTRY("sb: %p", sb);
 
-        M0_SET0(&mo);
-        mo.mo_attr.ca_tfid = *root_fid;
-        M0T1FS_SB(sb)->csb_root_fid = *root_fid;
-        M0T1FS_SB(sb)->csb_next_key = root_fid->f_key + 1;
+	M0_SET0(&mo);
+	mo.mo_attr.ca_tfid = *root_fid;
+	M0T1FS_SB(sb)->csb_root_fid = *root_fid;
+	M0T1FS_SB(sb)->csb_next_key = root_fid->f_key + 1;
 
 	rc = m0t1fs_mds_cob_getattr(M0T1FS_SB(sb), &mo, &rep);
 	if (rc != 0) {
-	        M0_LOG(M0_FATAL, "m0t1fs_mds_cob_getattr() failed with %d", rc);
-	        return ERR_PTR(rc);
+		M0_LOG(M0_FATAL, "m0t1fs_mds_cob_getattr() failed with %d", rc);
+		return ERR_PTR(rc);
 	}
 
 	inode = m0t1fs_iget(sb, root_fid, &rep->g_body);
@@ -238,39 +238,39 @@ static int m0t1fs_inode_set(struct inode *inode, void *opaque)
 }
 
 M0_INTERNAL int m0t1fs_inode_update(struct inode *inode,
-                                    struct m0_fop_cob *body)
+				    struct m0_fop_cob *body)
 {
 	int rc = 0;
 
 	M0_ENTRY();
 
-        if (body->b_valid & M0_COB_ATIME)
-	        inode->i_atime.tv_sec  = body->b_atime;
-        if (body->b_valid & M0_COB_MTIME)
-	        inode->i_mtime.tv_sec  = body->b_mtime;
-        if (body->b_valid & M0_COB_CTIME)
-	        inode->i_ctime.tv_sec  = body->b_ctime;
-        if (body->b_valid & M0_COB_UID)
-                inode->i_uid    = body->b_uid;
-        if (body->b_valid & M0_COB_GID)
-	        inode->i_gid    = body->b_gid;
-        if (body->b_valid & M0_COB_BLOCKS)
-	        inode->i_blocks = body->b_blocks;
-        if (body->b_valid & M0_COB_SIZE)
-	        inode->i_size = body->b_size;
-        if (body->b_valid & M0_COB_NLINK)
-	        inode->i_nlink = body->b_nlink;
-        if (body->b_valid & M0_COB_MODE)
-	        inode->i_mode = body->b_mode;
+	if (body->b_valid & M0_COB_ATIME)
+		inode->i_atime.tv_sec  = body->b_atime;
+	if (body->b_valid & M0_COB_MTIME)
+		inode->i_mtime.tv_sec  = body->b_mtime;
+	if (body->b_valid & M0_COB_CTIME)
+		inode->i_ctime.tv_sec  = body->b_ctime;
+	if (body->b_valid & M0_COB_UID)
+		inode->i_uid    = body->b_uid;
+	if (body->b_valid & M0_COB_GID)
+		inode->i_gid    = body->b_gid;
+	if (body->b_valid & M0_COB_BLOCKS)
+		inode->i_blocks = body->b_blocks;
+	if (body->b_valid & M0_COB_SIZE)
+		inode->i_size = body->b_size;
+	if (body->b_valid & M0_COB_NLINK)
+		inode->i_nlink = body->b_nlink;
+	if (body->b_valid & M0_COB_MODE)
+		inode->i_mode = body->b_mode;
 
 	M0_LEAVE("rc: %d", rc);
 	return rc;
 }
 
 static int m0t1fs_inode_read(struct inode *inode,
-                             struct m0_fop_cob *body)
+			     struct m0_fop_cob *body)
 {
-        struct m0t1fs_inode *ci = M0T1FS_I(inode);
+	struct m0t1fs_inode *ci = M0T1FS_I(inode);
 	int rc = 0;
 
 	M0_ENTRY();
@@ -282,7 +282,7 @@ static int m0t1fs_inode_read(struct inode *inode,
 
 	rc = m0t1fs_inode_update(inode, body);
 	if (rc != 0)
-	        goto out;
+		goto out;
 
 	if (S_ISREG(inode->i_mode)) {
 		inode->i_op   = &m0t1fs_reg_inode_operations;
@@ -293,10 +293,10 @@ static int m0t1fs_inode_read(struct inode *inode,
 	} else {
 		rc = -ENOSYS;
 	}
-        if (!m0t1fs_inode_is_root(inode)) {
-                ci->ci_layout_id = (M0T1FS_SB(inode->i_sb))->csb_layout_id;
-                rc = m0t1fs_inode_layout_init(ci);
-        }
+	if (!m0t1fs_inode_is_root(inode)) {
+		ci->ci_layout_id = (M0T1FS_SB(inode->i_sb))->csb_layout_id;
+		rc = m0t1fs_inode_layout_init(ci);
+	}
 out:
 	M0_LEAVE("rc: %d", rc);
 	return rc;
@@ -314,7 +314,7 @@ static unsigned long fid_hash(const struct m0_fid *fid)
 
 M0_INTERNAL struct inode *m0t1fs_iget(struct super_block *sb,
 				      const struct m0_fid *fid,
-                          	      struct m0_fop_cob *body)
+			  	      struct m0_fop_cob *body)
 {
 	struct inode *inode;
 	unsigned long hash;
@@ -331,22 +331,23 @@ M0_INTERNAL struct inode *m0t1fs_iget(struct super_block *sb,
 	 * set I_NEW flag in inode->i_state for newly allocated inode.
 	 */
 	inode = iget5_locked(sb, hash, m0t1fs_inode_test, m0t1fs_inode_set,
-                             (void *)fid);
-        if (IS_ERR(inode)) {
-	        M0_LEAVE("inode: %p", ERR_CAST(inode));
-	        return ERR_CAST(inode);
-        }
+			     (void *)fid);
+	if (IS_ERR(inode)) {
+		M0_LEAVE("inode: %p", ERR_CAST(inode));
+		return ERR_CAST(inode);
+	}
 	
-        if ((inode->i_state & I_NEW) != 0) {
-	        /* New inode, set its fields from @body */
-	        err = m0t1fs_inode_read(inode, body);
+	if (inode->i_state & I_NEW) {
+		/* New inode, set its fields from @body */
+		err = m0t1fs_inode_read(inode, body);
 	} else if (!(inode->i_state & (I_FREEING | I_CLEAR))) {
-	        /* Not a new inode, let's update its attributes from @body */
-	        err = m0t1fs_inode_update(inode, body);
+		/* Not a new inode, let's update its attributes from @body */
+		err = m0t1fs_inode_update(inode, body);
 	}
 	if (err != 0)
-	        goto out_err;
-	unlock_new_inode(inode);
+		goto out_err;
+	if (inode->i_state & I_NEW)
+		unlock_new_inode(inode);
 	M0_LEAVE("inode: %p", inode);
 	return inode;
 
-- 
1.8.3.2

