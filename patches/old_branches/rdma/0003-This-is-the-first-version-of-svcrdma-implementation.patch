From e581e6ef115c0bca343387ffbebb5ddb3b3ff1f7 Mon Sep 17 00:00:00 2001
From: "jinshan.xiong" <jinshan.xiong@clusterstor.com>
Date: Fri, 25 Jun 2010 10:46:35 -0600
Subject: [PATCH 03/34] This is the first version of svcrdma implementation.
 Here are some points to be addressed: 1. configuration protocol in rfc 5666;
 Right now, we just follow experienced    maximum message size from
 implementation of linux kernel rpc/rdma; 2. different memory registration:
 different hardware may have different memory    registration method
 supported, we need to fully use them; 3. userspace sunrpc uses a single
 thread implementation, this is not good and    cannot take advantage of
 parallelity of rdma. We need to address it, probably    use ganesha, or just
 do it ourself. Also, this affects credits assignment. 4. rdma xdr. At present
 I just use rpcgen to generate request, this is not good    because of too
 many memory allocation. Probably we need to revise it. 5. code cleanup and
 error handling

---
 net/usunrpc/rfc5666/rfc5666.h           |   93 +++
 net/usunrpc/rfc5666/rfc5666_xdr.c       |  244 ++++++++
 net/usunrpc/rfc5666/svc_rdma.c          | 1044 +++++++++++++++++++++++--------
 net/usunrpc/rfc5666/svc_rdma.h          |   11 +
 net/usunrpc/rfc5666/svc_rdma_internal.h |  136 ++++
 net/usunrpc/rfc5666/xdr_rdma.c          |   42 ++
 6 files changed, 1300 insertions(+), 270 deletions(-)
 create mode 100644 net/usunrpc/rfc5666/rfc5666.h
 create mode 100644 net/usunrpc/rfc5666/rfc5666_xdr.c
 create mode 100644 net/usunrpc/rfc5666/svc_rdma.h
 create mode 100644 net/usunrpc/rfc5666/svc_rdma_internal.h
 create mode 100644 net/usunrpc/rfc5666/xdr_rdma.c

diff --git a/net/usunrpc/rfc5666/rfc5666.h b/net/usunrpc/rfc5666/rfc5666.h
new file mode 100644
index 0000000..b1de59a
--- /dev/null
+++ b/net/usunrpc/rfc5666/rfc5666.h
@@ -0,0 +1,93 @@
+#include <rpc/rpc.h>
+
+struct rdma_segment {
+        uint32_t handle;
+        uint32_t length;
+        uint64_t offset;
+};
+
+struct rdma_read_chunk {
+        uint32_t position;
+        struct rdma_segment target;
+};
+
+struct rdma_read_list {
+        struct rdma_read_chunk entry;
+        struct rdma_read_list *next;
+};
+
+struct rdma_write_chunk {
+        uint32_t             nr_segs;
+        struct rdma_segment *segs;
+};
+
+struct rdma_write_list {
+        struct rdma_write_chunk entry;
+        struct rdma_write_list *next;
+};
+
+struct rdma_header_msg {
+        struct rdma_read_list *rdma_reads;
+        struct rdma_write_list *rdma_writes;
+        struct rdma_write_chunk *rdma_reply;
+};
+
+struct rdma_header_nomsg {
+        struct rdma_read_list *rdma_reads;
+        struct rdma_write_list *rdma_writes;
+        struct rdma_write_chunk *rdma_reply;
+};
+
+struct rdma_header_padded {
+        uint32_t rdma_align;
+        uint32_t rdma_thresh;
+        struct rdma_read_list *rdma_reads;
+        struct rdma_write_list *rdma_writes;
+        struct rdma_write_chunk *rdma_reply;
+};
+
+enum rdma_errcode {
+        RDMA_ERR_VERS = 1,
+        RDMA_ERR_CHUNK = 2,
+};
+
+struct rdma_error {
+        enum rdma_errcode errcode;
+        union {
+                struct rdma_vers_error rdma_vers;
+                uint32_t rdma_extra[8];
+        } u;
+};
+
+struct rdma_vers_error {
+        uint32_t rdma_vers_low;
+        uint32_t rdma_vers_high;
+};
+
+enum rdma_proc {
+        RDMA_MSG    = 0,
+        RDMA_NOMSG  = 1,
+        RDMA_MSGP   = 2,
+        RDMA_DONE   = 3,
+        RDMA_ERROR  = 4
+};
+
+struct rdma_body {
+        enum rdma_proc proc;
+        union {
+                struct rdma_header_msg    rdma_msg;
+                struct rdma_header_nomsg  rdma_nomsg;
+                struct rdma_header_padded rdma_msgp;
+                struct rdma_error         rdma_error;
+        } u;
+};
+
+struct svcrdma_msg {
+        uint32_t         rdma_xid;
+        uint32_t         rdma_vers;
+        uint32_t         rdma_credit;
+        struct rdma_body rdma_body;
+};
+
+/* the xdr functions */
+extern  bool_t xdr_svcrdma_msg (XDR *, struct svcrdma_msg *);
diff --git a/net/usunrpc/rfc5666/rfc5666_xdr.c b/net/usunrpc/rfc5666/rfc5666_xdr.c
new file mode 100644
index 0000000..a1a50ca
--- /dev/null
+++ b/net/usunrpc/rfc5666/rfc5666_xdr.c
@@ -0,0 +1,244 @@
+/*
+ * Please do not edit this file.
+ * It was generated using rpcgen.
+ */
+
+#include "rfc5666.h"
+
+static bool_t xdr_rdma_segment (XDR *xdrs, struct rdma_segment *objp)
+{
+        register int32_t *buf;
+
+         if (!xdr_uint32_t (xdrs, &objp->handle))
+                 return FALSE;
+         if (!xdr_uint32_t (xdrs, &objp->length))
+                 return FALSE;
+         if (!xdr_uint64_t (xdrs, &objp->offset))
+                 return FALSE;
+        return TRUE;
+}
+
+static bool_t xdr_rdma_read_chunk (XDR *xdrs, struct rdma_read_chunk *objp)
+{
+        register int32_t *buf;
+
+         if (!xdr_uint32_t (xdrs, &objp->position))
+                 return FALSE;
+         if (!xdr_rdma_segment (xdrs, &objp->target))
+                 return FALSE;
+        return TRUE;
+}
+
+static bool_t xdr_rdma_read_list (XDR *xdrs, struct rdma_read_list *objp)
+{
+        register int32_t *buf;
+
+         if (!xdr_rdma_read_chunk(xdrs, &objp->entry))
+                 return FALSE;
+         if (!xdr_pointer(xdrs,
+                          (char **)&objp->next,
+                          sizeof (struct rdma_read_list),
+                          (xdrproc_t) xdr_rdma_read_list))
+                 return FALSE;
+        return TRUE;
+}
+
+static bool_t xdr_rdma_write_chunk (XDR *xdrs, struct rdma_write_chunk *objp)
+{
+        register int32_t *buf;
+
+         if (!xdr_array(xdrs,
+                        (char **)&objp->nr_segs,
+                        (int *) &objp->segs,
+                        ~0,
+                        sizeof (struct rdma_segment),
+                        (xdrproc_t) xdr_rdma_segment))
+                 return FALSE;
+        return TRUE;
+}
+
+static bool_t xdr_rdma_write_list (XDR *xdrs, struct rdma_write_list *objp)
+{
+        register int32_t *buf;
+
+         if (!xdr_rdma_write_chunk (xdrs, &objp->entry))
+                 return FALSE;
+         if (!xdr_pointer(xdrs,
+                          (char **)&objp->next,
+                          sizeof (struct rdma_write_list),
+                          (xdrproc_t) xdr_rdma_write_list))
+                 return FALSE;
+        return TRUE;
+}
+
+static bool_t xdr_rdma_proc (XDR *xdrs, enum rdma_proc *objp)
+{
+        register int32_t *buf;
+
+         if (!xdr_enum (xdrs, (enum_t *) objp))
+                 return FALSE;
+        return TRUE;
+}
+
+static bool_t xdr_rdma_body (XDR *xdrs, struct rdma_body *objp)
+{
+        register int32_t *buf;
+
+         if (!xdr_rdma_proc (xdrs, &objp->proc))
+                 return FALSE;
+        switch (objp->proc) {
+        case RDMA_MSG:
+                 if (!xdr_rdma_header_msg (xdrs, &objp->u.rdma_msg))
+                         return FALSE;
+                break;
+        case RDMA_NOMSG:
+                 if (!xdr_rdma_header_nomsg (xdrs, &objp->u.rdma_nomsg))
+                         return FALSE;
+                break;
+        case RDMA_MSGP:
+                 if (!xdr_rdma_header_padded (xdrs, &objp->u.rdma_msgp))
+                         return FALSE;
+                break;
+        case RDMA_DONE:
+                break;
+        case RDMA_ERROR:
+                 if (!xdr_rdma_error (xdrs, &objp->u.rdma_error))
+                         return FALSE;
+                break;
+        default:
+                return FALSE;
+        }
+        return TRUE;
+}
+
+static bool_t xdr_rdma_header_msg (XDR *xdrs, struct rdma_header_msg *objp)
+{
+        register int32_t *buf;
+
+         if (!xdr_pointer (xdrs,
+                           (char **)&objp->rdma_reads,
+                           sizeof (struct rdma_read_list),
+                           (xdrproc_t) xdr_rdma_read_list))
+                 return FALSE;
+         if (!xdr_pointer (xdrs,
+                           (char **)&objp->rdma_writes,
+                           sizeof (struct rdma_write_list),
+                           (xdrproc_t) xdr_rdma_write_list))
+                 return FALSE;
+         if (!xdr_pointer (xdrs,
+                           (char **)&objp->rdma_reply,
+                           sizeof (struct rdma_write_chunk),
+                           (xdrproc_t) xdr_rdma_write_chunk))
+                 return FALSE;
+        return TRUE;
+}
+
+static bool_t xdr_rdma_header_nomsg (XDR *xdrs, struct rdma_header_nomsg *objp)
+{
+        register int32_t *buf;
+
+         if (!xdr_pointer (xdrs,
+                           (char **)&objp->rdma_reads,
+                           sizeof (struct rdma_read_list),
+                           (xdrproc_t) xdr_rdma_read_list))
+                 return FALSE;
+         if (!xdr_pointer (xdrs,
+                           (char **)&objp->rdma_writes,
+                           sizeof (struct rdma_write_list),
+                           (xdrproc_t) xdr_rdma_write_list))
+                 return FALSE;
+         if (!xdr_pointer (xdrs,
+                           (char **)&objp->rdma_reply,
+                           sizeof (struct rdma_write_chunk),
+                           (xdrproc_t) xdr_rdma_write_chunk))
+                 return FALSE;
+        return TRUE;
+}
+
+static bool_t xdr_rdma_header_padded (XDR *xdrs, struct rdma_header_padded *objp)
+{
+        register int32_t *buf;
+
+         if (!xdr_uint32_t (xdrs, &objp->rdma_align))
+                 return FALSE;
+         if (!xdr_uint32_t (xdrs, &objp->rdma_thresh))
+                 return FALSE;
+         if (!xdr_pointer (xdrs,
+                           (char **)&objp->rdma_reads,
+                           sizeof (struct rdma_read_list),
+                           (xdrproc_t) xdr_rdma_read_list))
+                 return FALSE;
+         if (!xdr_pointer (xdrs,
+                           (char **)&objp->rdma_writes,
+                           sizeof (struct rdma_write_list),
+                           (xdrproc_t) xdr_rdma_write_list))
+                 return FALSE;
+         if (!xdr_pointer (xdrs,
+                           (char **)&objp->rdma_reply,
+                           sizeof (struct rdma_write_chunk),
+                           (xdrproc_t) xdr_rdma_write_chunk))
+                 return FALSE;
+        return TRUE;
+}
+
+static bool_t xdr_rdma_errcode (XDR *xdrs, enum rdma_errcode *objp)
+{
+        register int32_t *buf;
+
+         if (!xdr_enum (xdrs, (enum_t *) objp))
+                 return FALSE;
+        return TRUE;
+}
+
+static bool_t xdr_rdma_error (XDR *xdrs, struct rdma_error *objp)
+{
+        register int32_t *buf;
+
+         if (!xdr_rdma_errcode (xdrs, &objp->errcode))
+                 return FALSE;
+        switch (objp->errcode) {
+        case ERR_VERS:
+                 if (!xdr_rdma_vers_error (xdrs, &objp->u.rdma_vers))
+                         return FALSE;
+                break;
+        case ERR_CHUNK:
+                break;
+        default:
+                 if (!xdr_vector (xdrs,
+                                  (char *)objp->u.rdma_extra,
+                                  8,
+                                  sizeof (uint32_t),
+                                  (xdrproc_t) xdr_uint32_t))
+                         return FALSE;
+                break;
+        }
+        return TRUE;
+}
+
+static bool_t xdr_rdma_vers_error (XDR *xdrs, struct rdma_vers_error *objp)
+{
+        register int32_t *buf;
+
+         if (!xdr_uint32_t (xdrs, &objp->rdma_vers_low))
+                 return FALSE;
+         if (!xdr_uint32_t (xdrs, &objp->rdma_vers_high))
+                 return FALSE;
+        return TRUE;
+}
+
+bool_t xdr_svcrdma_msg (XDR *xdrs, struct svcrdma_msg *objp)
+{
+        register int32_t *buf;
+
+         if (!xdr_uint32_t (xdrs, &objp->rdma_xid))
+                 return FALSE;
+         if (!xdr_uint32_t (xdrs, &objp->rdma_vers))
+                 return FALSE;
+         if (!xdr_uint32_t (xdrs, &objp->rdma_credit))
+                 return FALSE;
+         if (!xdr_rdma_body (xdrs, &objp->rdma_body))
+                 return FALSE;
+        return TRUE;
+}
+
+
diff --git a/net/usunrpc/rfc5666/svc_rdma.c b/net/usunrpc/rfc5666/svc_rdma.c
index f3dcfc3..c975465 100644
--- a/net/usunrpc/rfc5666/svc_rdma.c
+++ b/net/usunrpc/rfc5666/svc_rdma.c
@@ -14,106 +14,16 @@
 # include <libio/iolibio.h>
 #endif
 
-enum rdma_xprt_status {
-        RDMA_XPRT_INIT   = 0,
-        RDMA_XPRT_LISTEN,
-        RDMA_XPRT_CONNECTING,
-        RDMA_XPRT_ESTABLISHED,
-        RDMA_XPRT_DESTROYED
-};
-
-/*
- * svcrdma_export for listener
- */
-struct svcrndzv_xprt {
-        SVCXPRT                    svcxprt;
-        struct rdma_cm_id         *cmid;
-        struct rdma_event_channel *channel;
-        enum rdma_xprt_status      status;
-
-        /* rdma parameters are stored here. */
-        int trans;
-        int port;
-        int max_send_wr;
-        int max_recv_wr;
-        int max_send_sge;
-        int max_recv_sge;
-        int rc_retry_cnt;
-        int rc_rnr_retry_cnt;
-        int max_msg_size;
-        int page_size;
-        int rcv_wr_flags;
-        int snd_wr_flags;
-
-        /* exports have been accepted. */
-        struct c2_list             xprts;
-};
-
-struct rdma_reply {
-        struct rdma_reply *next;
-        struct svcrdma_xprt  *xprt;
-
-        /**
-         * Active replies belong to this export
-         */
-        struct c2_list_link  *link;
-
-        void              *buffer;
-        struct ibv_mr     *mr;
-        struct ibv_send_wr wr;
-        struct ibv_sge     sge;
-};
-
-struct rdma_request {
-        struct svcrdma_xprt  *xprt;
-        struct rdma_reply *reply;
-
-        /**
-         * Active repquests belong to this export.
-         * Sunrpc works sync right now, but we maintain requests assuming that
-         * multiple requests are handled simultaneously.
-         */
-        struct c2_list_link  *link;
 
-        void                 *buffer;
-        struct ibv_mr        *mr;
-        struct ibv_recv_wr    wr;
-        struct ibv_sge        sge;
-};
-
-/*
- *
- */
-struct svcrdma_xprt {
-        struct c2_list_link   link;
-        SVCXPRT               svcxprt;
-        struct svcrndzv_xprt *rndzv;
-        struct rdma_cm_id    *cmid;
-
-        /* queue pair information */
-        struct ibv_comp_channel *channel;
-        struct ibv_pd           *pd;
-        struct ibv_cq           *cq;
-        struct ibv_qp           *qp;
-
-        /* the rdma request is processing */
-        struct rdma_request  *curreq;
-        struct c2_list          *requests;
-        struct c2_list          *replis;
-
-        /* preallocated buffers used by this xprt. */
-        struct rdma_request  *rcv_bufs;
-        struct rdma_reply    *snd_bufs;
-
-        /* attribute of this xprt */
-        enum rdma_xprt_status    status;
-        XDR                      xdrs;
-};
+static int svcrdma_buffer_create(struct svcrdma_xprt *xprt);
+static void svcrdma_buffer_destroy(struct svcrdma_xprt *xprt);
+static int rdma_recv_completion(struct svcrdma_xprt *xprt,
+                                struct ibv_wc *wc,
+                                struct rpc_msg *rpcmsg);
+static void rdma_completion_one(struct rdma_context *ctxt);
 
+/* SVCXPRT callbacks */
 static void svcrdma_xprt_destroy (struct svcrdma_xprt *xprt);
-/*
- * Ops vector for TCP/IP based rpc service handle
- */
 static bool_t svcrdma_recv (SVCXPRT *, struct rpc_msg *);
 static enum xprt_stat svcrdma_stat (SVCXPRT *);
 static bool_t svcrdma_getargs (SVCXPRT *, xdrproc_t, caddr_t);
@@ -130,9 +40,7 @@ static const struct xp_ops svcrdma_op = {
         svcrdma_destroy
 };
 
-/*
- * Ops vector for TCP/IP rendezvous handler
- */
+/* SVCXPRT rendezvous callbacks */
 static bool_t rendezvous_request (SVCXPRT *, struct rpc_msg *);
 static enum xprt_stat rendezvous_stat (SVCXPRT *);
 static void rendezvous_abort (void) __attribute__ ((__noreturn__));
@@ -156,7 +64,7 @@ static const struct xp_ops svcrdma_rendezvous_op = {
 /**
  * svcrdma_create: Create an rdma export and make it listen on port @port
  */
-SVCXPRT *svcrdma_create (int port)
+SVCXPRT *svcrdma_create (int port, struct svcrdma_config *config)
 {
         SVCXPRT *svcxprt;
         struct svcrndzv_xprt *xp;
@@ -236,133 +144,6 @@ out:
         return NULL;
 }
 
-static void svcrdma_buffer_destroy(struct svcrdma_xprt *xprt)
-{
-        struct rdma_reply *reply;
-        int i;
-        int count;
-
-        count = xprt->rndzv->max_recv_wr;
-        if (xprt->rcv_bufs) {
-                for (i = 0; i < count; i++) {
-                        struct rdma_request *r = &xprt->rcv_bufs[i];
-
-                        if (r->buffer == NULL)
-                                break;
-                        free(r->buffer);
-
-                        if (r->mr == NULL)
-                                break;
-                        ibv_dereg_mr(r->mr);
-                }
-                mem_free(xprt->rcv_bufs);
-        }
-
-        reply = xprt->snd_bufs;
-        while (reply) {
-                struct rdma_reply *tmp = reply->next;
-
-                if (reply->buffer)
-                        free(reply->buffer);
-                if (reply->mr)
-                        ibv_dereg_mr(reply->mr);
-                mem_free(reply);
-                reply = tmp;
-        }
-}
-
-static int svcrdma_buffer_create(struct svcrdma_xprt *xprt)
-{
-        struct rdma_request *req;
-        int nr;
-        int count;
-        int bufsize;
-        int rc;
-
-        /* for receive buffers. */
-        count = xprt->rndzv->max_recv_wr;
-        req = mem_alloc(count * sizeof(*req));
-        if (req == NULL)
-                return -ENOMEM;
-
-        memset(req, 0, count * sizeof(*req));
-        xprt->rcv_bufs = req;
-
-        bufsize = xprt->rndzv->max_msg_size;
-        for (i = 0; i < count; i++) {
-                struct rdma_request *r = &req[i];
-                struct ibv_recv_wr     *badwr;
-
-                r->xprt = xprt;
-                if (posix_memalign(&r->buffer, xprt->rndzv->page_size, bufsize))
-                        goto out;
-
-                r->mr = ibv_reg_mr(xprt->pd, r->buffer, bufsize,
-                                   xprt->rndzv->rcv_wr_flags);
-                if (!r->mr) {
-                        free(r->buffer);
-                        r->buffer = NULL;
-                        goto out;
-                }
-
-                /* register receive buffer */
-                r->sge.addr   = r->buffer;
-                r->sge.length = bufsize;
-                r->sge.lkey   = r->mr->lkey;
-                r->wr.wr_id   = (uint64_t)r;
-                r->wr.sg_list = &r->sge;
-                r->wr.num_sge = 1;
-                rc = ibv_post_recv(xprt->qp, &r->wr, &badwr);
-                if (rc) {
-                        ibv_dereg_mr(r->mr);
-                        free(r->buffer);
-                        r->buffer = NULL;
-                        goto out;
-                }
-        }
-
-        /* for send buffers. */
-        count = xprt->rndzv->max_send_wr;
-        for (i = 0; i < count; i++) {
-                struct rdma_reply *reply;
-
-                reply = mem_alloc(sizeof(*reply));
-                if (!reply)
-                        goto out;
-                memset(reply, 0, sizeof(*reply));
-
-                posix_memalign(&reply->buffer, xprt->rndzv->page_size, bufsize);
-                if (!reply->buffer) {
-                        mem_free(reply);
-                        goto out;
-                }
-
-                reply->mr = ibv_reg_mr(xprt->pg, reply->buffer, bufsize,
-                                       xprt->rndzv->snd_wr_flags);
-                if (!reply->mr) {
-                        mem_free(reply);
-                        free(reply->buffer);
-                        goto out;
-                }
-
-                reply->xprt = xprt;
-                reply->sge.addr = reply->buffer;
-                reply->sge.length = bufsize;
-                reply->sge.lkey = reply->mr->lkey;
-                reply->wr.wr_id = (uint64_t)reply;
-                reply->wr.sg_list = &reply->sge;
-                reply->num_sge = 1;
-
-                reply->next = xprt->snd_bufs;
-                xprt->snd_bufs = reply;
-        }
-
-        return 0;
-
-out:
-        svcrdma_buffer_destroy(xprt);
-}
-
 /**
  * svcrdma_handle_connection: Handle a new connecting request from client.
  *
@@ -391,6 +172,8 @@ static int svcrdma_handle_connection(struct svcrndzv_xprt *xp,
 
         memset(xprt, 0, sizeof *xprt);
         c2_list_link_init(&xprt->link);
+        c2_list_init(&xprt->requests);
+        c2_list_init(&xprt->replies);
         xprt->rndzv = xp;
         xprt->cmid  = cmid;
 
@@ -438,8 +221,6 @@ static int svcrdma_handle_connection(struct svcrndzv_xprt *xp,
         svcxprt->xp_p1 = xprt;
         svcxprt->xp_ops = &svcrdma_op;
         svcxprt->xp_sock = xprt->channel->fd;
-        /* TODO: need to create xdr functions */
-        /* xdrrec_create(..) */
         xprt_register(svcxprt);
 
         /* add the xprt into linked list of listener */
@@ -453,7 +234,8 @@ out:
         return NULL; 
 }
 
-static inline struct svcrdma_xprt *xprt_find(struct svcrndzv_xprt *xp, struct rdma_cm_id *id)
+static inline struct svcrdma_xprt *xprt_find(struct svcrndzv_xprt *xp,
+                                             struct rdma_cm_id *id)
 {
         struct svcrdma_xprt *xprt;
 
@@ -524,7 +306,8 @@ static bool_t rendezvous_request (SVCXPRT *xprt, struct rpc_msg *errmsg)
         }
 
         if (rc)
-                svc_errx("Handle event %s return error %d\n", rdma_event_str(ev->event), rc);
+                svc_errx("Handle event %s return error %d\n",
+                         rdma_event_str(ev->event), rc);
 
         (void)rdma_ack_cm_event(ev);
         return FALSE;
@@ -550,23 +333,6 @@ static enum xprt_stat svcrdma_stat (SVCXPRT *xprt)
         return XPRT_IDLE;
 }
 
-static int svcrdma_handle_sendcomp(struct svcrdma_xprt *xprt,
-                                   struct rdma_reply *reply)
-{
-        return 0;
-}
-
-/**
- * Handle receive event from this transport.
- * An rpc is coming, the content of rpc message has already been in buffer.
- */
-static int svcrdma_handle_recvcomp(struct svcrdma_xprt *xprt,
-                                   struct rdma_request *req,
-                                   struct rpc_msg *msg)
-{
-        return 0;
-}
-
 /**
  * svcrdma_recv() will be called whenever a new request is pending on the
  * completion channel. This means a send wr has been finished, or recv wr
@@ -612,23 +378,24 @@ static bool_t svcrdma_recv (SVCXPRT *xprt, struct rpc_msg *msg)
                 svc_assert(rc == 1);
                 if (wc.status != IBV_WC_SUCCESS) {
                         svc_errx("get a wc with error(%s), op/id: %d/%lx",
-                                 ibv_wc_status_err(wc.staus), wc.opcode, wc.wr_id);
+                                 ibv_wc_status_err(wc.staus), wc.opcode,
+                                 wc.wr_id);
+
                         /* though there is something wrong, we still need to
                          * handle the completion event */
                         /* fall through */
                 }
                 switch(wc.opcode) {
-                case IBV_WC_SEND: {
-                        rc = svcrdma_handle_sendcomp(xp,
-                                        (struct rdma_reply *)wc.wr_id);
-                        break;
                 case IBV_WC_RECV:
-                        rc = svcrdma_handle_recvcomp(xp,
-                                        (struct rdma_request *)wc.wr_id, msg);
+                        rc = rdma_recv_completion(xp, &wc, msg);
                         break;
+                case IBV_WC_SEND:
                 case IBV_WC_RDMA_READ:
                 case IBV_WC_RDMA_WRITE:
-                        /* TODO: will handle later. */
+                        /* XXX: impossible to get this event from here because
+                         * RDMA event handling is sync. */
+                        svc_assert(0);
+                        rdma_completion_one(wc.wr_id);
                         break;
                 default:
                         svc_errx("unknown opcode(%d) of completion event %lx",
@@ -637,16 +404,18 @@ static bool_t svcrdma_recv (SVCXPRT *xprt, struct rpc_msg *msg)
                 }
         } /* while (1) */
 
-        return rc ? TRUE : FALSE;
+        return (rc == 0) ? TRUE : FALSE;
 }
 
-static bool_t svcrdma_getargs(SVCXPRT *xprt, xdrproc_t xdr_args, caddr_t args_ptr)
+static bool_t svcrdma_getargs(SVCXPRT *xprt, xdrproc_t xdr_args,
+                              caddr_t args_ptr)
 {
         struct svcrdma_xprt *xp = xprt->xp_p1;
         return ((*xdr_args) (&xp->xdrs, args_ptr));
 }
 
-static bool_t svcrdma_freeargs(SVCXPRT *xprt, xdrproc_t xdr_args, caddr_t args_ptr)
+static bool_t svcrdma_freeargs(SVCXPRT *xprt, xdrproc_t xdr_args,
+                               caddr_t args_ptr)
 {
         struct svcrdma_xprt *xp = xprt->xp_p1;
 
@@ -654,17 +423,87 @@ static bool_t svcrdma_freeargs(SVCXPRT *xprt, xdrproc_t xdr_args, caddr_t args_p
         return ((*xdr_args) (&xp->xdrs, args_ptr));
 }
 
-static bool_t svcrdma_reply(SVCXPRT *xprt, struct rpc_msg *msg)
+static bool_t svcrdma_reply(SVCXPRT *svcxprt, struct rpc_msg *msg)
 {
-  struct tcp_conn *cd = (struct tcp_conn *) (xprt->xp_p1);
-  XDR *xdrs = &(cd->xdrs);
-  bool_t stat;
-
-  xdrs->x_op = XDR_ENCODE;
-  msg->rm_xid = cd->x_id;
-  stat = INTUSE(xdr_replymsg) (xdrs, msg);
-  (void) INTUSE(xdrrec_endofrecord) (xdrs, TRUE);
-  return stat;
+        struct svcrdma_xprt *xprt = (struct svcrdma_xprt *)svcxprt->xp_p1;
+        int bufsize = xprt->rndzv->max_msg_size;
+        struct svcrdma_request *req;
+        struct svcrdma_reply *reply;
+        struct svcrdma_msg   *msg;
+        XDRS xdrs;
+        int rpc_buflen;
+        int rdma_buflen;
+        struct ibv_sge sge[2];
+        bool_t rc;
+
+        /* XXX: there is no way to get request in current implementation of
+         * sunrpc since it just pass SVCXPRT in */
+        req = xprt->curreq;
+        reply = req->reply;
+        reply->msg = req->msg;
+        msg = &reply->msg;
+
+        /* initiate the write list so that RDMA chunk write works. */
+        reply->writes = req->writes;
+        reply->writes_index = 0;
+
+        xdrmem_create(&xdrs, reply->rpc_buf, bufsize, XDR_ENCODE);
+        msg->rm_xid = reply->msg.rdma_xid;
+        if (!xdr_replymsg(&xdrs, msg)) {
+                /* this is probably because of not having enough buffer space */
+                return FALSE;
+        }
+        reply->rpc_buflen = XDR_GETPOS(&xdrs);
+
+        /* By rfc5666, the write chunks must have precise bytes it filled */
+        rdma_fixup_write_chunks(reply);
+
+        msg->rdma_vers = RDMA_VERS;
+        /* always 1 right now since we do not support async sunrpc request.
+         * Please notice that from rfc5666, if there is no outstanding request
+         * from a specific client, the credit must be at least 1 to prevent
+         * it from deadlocking. */
+        msg->rdma_credit = 1;
+
+        /* prepare to encode rdma chunks information */
+        {
+                /* assuming RDMA_MSG, will be fixed when actually composing
+                 * the message; it may be RDMA_NOMSG in case rpc message
+                 * is too long to send by RDMA send/recv */
+                struct rdma_header_msg *rdma_msg;
+
+                msg->rdma_body.rdma_proc = RDMA_MSG;
+                rdma_msg = msg->rdma_body.u.rdma_msg;
+                rdma_msg->rdma_reads = NULL;
+                rdma_msg->rdma_writes = req->writes;
+                rdma_msg->rdma_reply = NULL;
+        }
+        
+        xdrmem_create(&xdrs, reply->rdma_buf, bufsize, XDR_ENCODE);
+        if (!xdr_svcrdma_msg(&xdrs, msg)) {
+                /* impossible! the bufsize is not enough for even rdma
+                 * chunks - this is not my fault :-) */
+                svc_assert(0);
+        }
+        reply->rdma_buflen = XDR_GETPOS(&xdrs);
+
+        if (rdma_buflen + rpc_buflen > bufsize) {
+                /* we need to fill in reply chunk and redo encoding. */
+                /* TODO: fill in reply chunk */
+                svc_assert(0);
+        }
+
+        /* anyway, free request first */
+        svcrdma_repost_recv(req);
+
+        /* it looks all right, post reply buffer */
+        rc = rdma_send_reply(reply);
+        if (rc) {
+                /* if error, reply is not freed */
+                svcrdma_put_reply(reply);
+                return FALSE;
+        }
+        return TRUE;
 }
 
 static void svcrdma_xprt_destroy (struct svcrdma_xprt *xprt)
@@ -688,4 +527,669 @@ static void svcrdma_destroy(SVCXPRT *xprt)
         svcrdma_xprt_destroy(xprt->xp_p1);
 }
 
+/**
+ * buffer related routines.
+ */
+static void svcrdma_buffer_destroy(struct svcrdma_xprt *xprt)
+{
+        struct rdma_reply *reply;
+        int i;
+        int count;
+
+        count = xprt->rndzv->max_recv_wr;
+        if (xprt->rcv_bufs) {
+                for (i = 0; i < count; i++) {
+                        struct rdma_request *r = &xprt->rcv_bufs[i];
+
+                        if (r->buffer == NULL)
+                                break;
+                        free(r->buffer);
+
+                        if (r->mr == NULL)
+                                break;
+                        ibv_dereg_mr(r->mr);
+                }
+                mem_free(xprt->rcv_bufs);
+        }
+
+        reply = xprt->snd_bufs;
+        while (reply) {
+                struct rdma_reply *tmp = reply->next;
+
+                if (reply->buffer)
+                        free(reply->buffer);
+                if (reply->mr)
+                        ibv_dereg_mr(reply->mr);
+                mem_free(reply);
+                reply = tmp;
+        }
+}
+
+static int svcrdma_buffer_create(struct svcrdma_xprt *xprt)
+{
+        struct rdma_request *req;
+        int nr;
+        int count;
+        int bufsize;
+        int rc;
+
+        /* for receive buffers. */
+        count = xprt->rndzv->max_recv_wr;
+        req = mem_alloc(count * sizeof(*req));
+        if (req == NULL)
+                return -ENOMEM;
+
+        memset(req, 0, count * sizeof(*req));
+        xprt->rcv_bufs = req;
+
+        bufsize = xprt->rndzv->max_msg_size;
+        for (i = 0; i < count; i++) {
+                struct rdma_request *r = &req[i];
+                struct ibv_recv_wr     *badwr;
+
+                r->xprt = xprt;
+                if (posix_memalign(&r->buffer, xprt->rndzv->page_size, bufsize))
+                        goto out;
+
+                r->mr = ibv_reg_mr(xprt->pd, r->buffer, bufsize,
+                                   xprt->rndzv->rcv_wr_flags);
+                if (!r->mr) {
+                        free(r->buffer);
+                        r->buffer = NULL;
+                        goto out;
+                }
+
+                /* register receive buffer */
+                r->sge.addr   = r->buffer;
+                r->sge.length = bufsize;
+                r->sge.lkey   = r->mr->lkey;
+                r->wr.wr_id   = (uint64_t)r;
+                r->wr.sg_list = &r->sge;
+                r->wr.num_sge = 1;
+                rc = ibv_post_recv(xprt->qp, &r->wr, &badwr);
+                if (rc) {
+                        ibv_dereg_mr(r->mr);
+                        free(r->buffer);
+                        r->buffer = NULL;
+                        goto out;
+                }
+        }
+
+        /* for send buffers. */
+        count = xprt->rndzv->max_send_wr;
+        for (i = 0; i < count; i++) {
+                struct rdma_reply *reply;
+
+                reply = mem_alloc(sizeof(*reply));
+                if (!reply)
+                        goto out;
+                memset(reply, 0, sizeof(*reply));
+
+                posix_memalign(&reply->buffer, xprt->rndzv->page_size,
+                               bufsize * 2);
+                if (!reply->buffer) {
+                        mem_free(reply);
+                        goto out;
+                }
+
+                reply->rdma_buf = reply->buffer;
+                reply->rpc_buf = reply->buffer + bufsize;
+                reply->rdma_mr = ibv_reg_mr(xprt->pg, reply->rdma_buf, bufsize,
+                                            xprt->rndzv->snd_wr_flags);
+                if (!reply->rdma_mr) {
+                        mem_free(reply);
+                        free(reply->buffer);
+                        goto out;
+                }
+
+                reply->rpc_mr = ibv_reg_mr(xprt->pg, reply->rpc_buf, bufsize,
+                                           xprt->rndzv->snd_wr_flags);
+                if (reply->rpc_mr) {
+                        mem_free(reply);
+                        free(reply->buffer);
+                        ibv_dereg_mr(reply->rdma_mr);
+                        goto out;
+                }
+
+                reply->xprt = xprt;
+                reply->next = xprt->snd_bufs;
+                xprt->snd_bufs = reply;
+        }
+
+        return 0;
+
+out:
+        svcrdma_buffer_destroy(xprt);
+        return -EAGAIN;
+}
+
+static void svcrdma_repost_recv(struct rdma_request *req)
+{
+        struct ibv_recv_wr *badwr;
+        int rc;
+
+        req->reply = NULL;
+        xdrmem_create(&xdrs, NULL, 0, XDR_FREE);
+        xdr_svcrdma_msg(&xdrs, &req->msg);
+        rc = ibv_post_recv(xprt, &req->wr, &badwr);
+        if (rc)
+                svc_errx("repost recv buffer error");
+}
+
+/**
+ * Handle receive event from this transport.
+ * An rpc is coming, the content of rpc message has already been in buffer.
+ */
+static int rdma_recv_completion(struct svcrdma_xprt *xprt,
+                                struct ibv_wc *wc,
+                                struct rpc_msg *rpcmsg)
+{
+        struct rdma_request *req;
+        struct svcrdma_msg *msg;
+        struct ibv_recv_wr *badwr;
+        XDR                 xdrs;
+        int                 pos = 0;
+        int                 rc = 0;
+        int                 reqlen;
+
+        svc_assert(wc->opcode == IBV_WC_RECV);
+        req = (struct rdma_request *)wc->wr_id;
+
+        /* handle error message first */
+        if (wc->status != IBV_WC_SUCCESS) {
+                /* what can we do? Just reregister the buffer */
+                rc = ibv_post_recv(xprt->qp, &req->wr, &badwr);
+                if (rc)
+                        svc_errx("fatal error on registering the recv buffer");
+        }
+
+        
+        /* initiate the request by ibv_wc */
+        /* Right now, the sunrpc library is sync, this means only one request
+         * is pending at a time.
+         * After we have modified sunrpc library to support async requests,
+         * we can remove this check and use xprt->requests to track all pending
+         * requests.
+         */
+        memset(&req->msg, 0, sizeof req->msg);
+        reqlen = wc->byte_len;
+        svc_assert(xprt->curreq == NULL);
+        svc_assert(req->reply == NULL);
+        xprt->curreq = req;
+        c2_list_add(&xprt->requests, &xprt->link);
+        req->reply = svcrdma_get_reply(xprt);
+        if (req->reply == NULL) {
+                svc_errx("fatal error: no reply available, deadlock happens\n");
+                abort();
+        }
+
+        xdrmem_create(&xdrs, req->buffer, reqlen, XDR_DECODE);
+        if (xdr_svcrdma_msg(xdrs, &req->msg)) {
+                svc_errx("message corrupted, decode rfc5666 failed");
+                rc = RDMA_ERR_CHUNK;
+                goto out;
+        }
+        pos = XDR_GETPOS(&xdrs);
+        svc_assert(pos <= reqlen);
+
+        /* sanity check */
+        msg = &req->msg;
+        if (msg->rdma_vers != RDMA_VERS) {
+                svc_errx("version mismatched, %d/%d",
+                         msg->rdma_vers, RDMA_VERS);
+                rc = RDMA_ERR_VERS;
+                goto out;
+        }
+
+        /* handle chunks */
+        switch(msg->rdma_body.u.proc) {
+        case RDMA_MSG: {
+                struct rdma_header_msg *header_msg;
+
+                header_msg = &msg->rdma_body.u.rdma_msg;
+                req->reads = header_msg->rdma_reads;
+                req->writes = header_msg->rdma_writes;
+                req->reply = header_msg->rdma_reply;
+                if (req->reads) {
+                        struct rdma_read_list *list = req->reads;
+                        req->chunk_start = list->entry.position;
+                        req->chunk_len   = list->entry.target.length;
+                        while (list->next) {
+                                list = list->next;
+                                req->chunk_len += list->entry.target.length;
+                        }
+                }
+
+                /* setup rpc message base */
+                req->rpcbuf_len  = reqlen - pos;
+                req->rpcbuf_base = req->buffer + pos;
+                req->curpos  = 0;
+                break;
+        }
+        case RDMA_NOMSG: {
+                struct rdma_header_msg *header_nomsg;
+                struct rdma_read_list *rpcmsg;
+                int lenth;
+
+                header_nomsg = &msg->rdma_body.u.rdma_nomsg;
+                req->reads = header_nomsg->rdma_reads;
+                req->writes = header_nomsg->rdma_writes;
+                req->reply = header_nomsg->rdma_reply;
+
+                rpcmsg = req->reads;
+                svc_assert(rpcmsg->entry.position == 0);
+                length = rpcmsg->entry.target.length;
+                req->rpcbuf_len = length;
+                req->rpcbuf_base = mem_alloc(length);
+
+                rc = -ENOMEM;
+                if (req->rpcbuf_base) {
+                        rc = rdma_read_chunks(req, req->rpcbuf_base,
+                                              req->rpcbuf_len);
+                        if (rc < 0)
+                                mem_free(req->rpcbuf_base);
+                }
+                req->curpos  = 0;
+                break;
+        }
+        case RDMA_DONE:
+                /* reply chunk finished, not support */
+                svc_assert(0);
+                break;
+        case RDMA_MSGP:
+        case RDMA_ERROR:
+        default:
+                /* TODO: destroy the export */
+                break;
+        }
+        if (rc < 0)
+                goto out;
+
+        /* the header of RDMA chunks looks fine, just set the XDR stream */
+        xdrmem_create(&req->xdrs, req->rpcbuf_base, req->rpcbuf_len,
+                       XDR_DECODE);
+        req->xdrs.x_public = (void *)req;
+        return 0;
+
+out:
+        /* TODO: error handling needs reworking. */
+        if (rc > 0) { /* something wrong */
+#if 0
+                reply_msg->rdma_body.proc = RDMA_ERROR;
+                reply_msg->rdma_body.u.rdma_error.errcode = rc;
+#endif
+        }
+        /* TODO: free request message and compose an reply message */
+        return rc;
+}
+
+/* context to track rdma read and write */
+#define CTXT_MAX_MRS    256
+struct rdma_context {
+        struct c2_ref        ref;
+        void               (*completion)(struct rdma_context *, void *);
+        void                *ctx;
+        struct svcrdma_xprt *xprt;
+        int                  max_index;
+        int                  index;
+        struct ibv_mr       *mrs[CTXT_MAC_MRS];
+};
+
+static void rdma_completion(struct c2_ref *);
+static void rdma_context_init(struct rdma_context *ctxt,
+                              struct svcrdma_xprt *xprt,
+                              void (*comp)(struct rdma_context *, void *),
+                              void *ctx)
+{
+        memset(ctxt, 0, sizeof *ctxt);
+        c2_ref_init(&ctxt->ref, 0, rdma_completion);
+        ctxt->xprt       = xprt;
+        ctxt->completion = comp;
+        ctxt->ctx        = ctx;
+        ctxt->index      = 0;
+        ctxt->max_index  = CTXT_MAX_MRS;
+}
+
+static void rdma_completion_rw(struct rdma_context *ctxt, void *unused)
+{
+        int i;
+
+        /* complete or something wrong */
+        for (i = 0; i < ctxt->index; i++)
+                ibv_dereg_mr(ctxt->mrs[i]);
+        ctxt->index = 0;
+}
+
+static void rdma_completion(struct c2_ref *ref)
+{
+        struct rdma_context *ctxt = contain_of(ref, struct rdma_context, ref);
+        ctxt = ctxt;
+        if (ctxt->completion)
+                ctxt->completion(ctxt, ctx);
+        /* TODO: in multiple thread env, we then wake handling thread up. */
+}
+
+void rdma_completion_one(void *args)
+{
+        struct rdma_context *ctxt = args;
+        c2_ref_put(&ctxt->ref);
+}
+
+static int rdma_wait_for_completion(struct rdma_context *ctxt)
+{
+        struct svcrdma_xprt *xprt = ctxt->xprt;
+        struct ibv_cq *ecq;
+        void          *ectx;
+        struct ibv_wc  wc;
+        int            rc = 0;
+        int            ncount = ctxt->index;
+
+        if (ncount == 0)
+                return 0;
+
+        svc_assert(ncount <= ctxt->max_index);
+
+again:
+        if (ibv_get_cq_event(xprt->channel, &ecq, &ectx) != 0) {
+                svc_errx("get cq_event for xprt %p\n", xp);
+                return -errno;
+        }
+        svc_assert(ecq == xprt->cq && ectx == xrpt);
+        if (ibv_req_notify_events(xprt->cp, 0))
+                svc_errx("failed to set up notification");
+        ibv_ack_cq_events(xprt->cq, 1);
+        while (1) {
+                rc = ibv_poll_cq(xp->cq, 1, &wc);
+                if (rc == 0) {         /* no event pending any more */
+                        break;
+                } else if (rc < 0) /* error occurs */
+                        svc_errx("error occurs polling cq");
+                        break;
+                }
+
+                ncount--;
+                svc_assert(rc == 1);
+                if (wc.status != IBV_WC_SUCCESS) {
+                        svc_error("cq error %s\n", ibv_wc_status_str(rc));
+                        rc = -1;
+                        break;
+                }
+                svc_assert(wc->wr_id == (uint64_t)ctxt);
+                rdma_completion_one(ctxt);
+        }
+        if (rc == 0 && ncount)
+                goto again;
+        return rc;
+}
+
+static struct ibv_mr *do_rdma_post(struct rdma_context *ctxt,
+                                   struct rdma_segment *seg,
+                                   char *buffer, enum ibv_wr_opcode opc)
+{
+        struct ibv_sge sge = {
+                .addr   = buffer,
+                .length = seg->length
+        };
+        struct ibv_send_wr wr = {
+                .wr_id      = (uint64_t)ctxt,
+                .sg_list    = &sge,
+                .num_sge    = 1,
+                .opcode     = opc,
+                .send_flags = 0, /* IBV_SEND_SIGNALED; */
+                .wr = {
+                        .rdma = {
+                                .remote_addr = seg->offset,
+                                .rkey        = seg->handle
+                        }
+                }
+        };
+        struct ibv_send_wr *badwr;
+        struct ibv_mr *mr;
+        int flags;
+
+
+        svc_assert(opc == IBV_WR_RDMA_READ || opc == IBV_WR_RDMA_WRITE);
+        flags = IBV_ACCESS_REMOTE_WRITE|IBV_ACCESS_REMOGE_READ;
+        mr = ibv_reg_mr(ctxt->xprt->pd, buffer, seg->length, flags);
+        if (mr == NULL) {
+                svc_errx("register memory error, this may be due to not locking"
+                         " enough memory");
+                return NULL;
+        }
+
+        sge.lkey = mr->lkey;
+        rc = ibv_post_send(ctxt->xprt->qp, &wr, &badwr);
+        if (rc != IBV_WC_SUCCESS) {
+                svc_errx("post RDMA buffer error %s\n", ibv_wc_status_err(rc));
+                ibv_dereg_mr(mr);
+                return NULL;
+        }
+        return mr;
+}
+
+/**
+ * rdma_read_chunks: decode the XDR stream, we return the corresponding
+ * buffer address by the position of XDR stream - if the position happens to
+ * be in the RDMA chunks, RDMA transfer will be used to copy data into the
+ * buffer directly.
+ */
+int rdma_read_chunks(struct rdma_request *req, char *buffer, int buflen)
+{
+        struct rdma_context *ctxt;
+        struct rdma_read_list *next,
+        struct ibv_mr *mr;
+        struct rdma_segment *seg;
+        int len;
+        int nr_segs = 0;
+        int ncount = buflen;
+
+        ctxt = alloca(sizeof(*ctxt));
+        rdma_context_init(ctxt, req->xprt, rdma_completion_rw, (void *)req);
+        next = req->reads;
+        while (next && buflen) {
+                seg = &next->entry.target;
+                svc_assert(buflen >= seg->length);
+                mr = do_rdma_post(ctxt, seg, buffer, IBV_WR_RDMA_READ);
+                if (mr == NULL) {
+                        int retry = !!ctxt->index;
+
+                        rc = rdma_wait_for_completion(ctxt);
+                        if (rc) {
+                                svc_errx("wait for RDMA read failed");
+                                break;
+                        }
+                        svc_assert(c2_ref_get(&ctxt->ref) == 0);
+
+                        rc = -EAGAIN;
+                        if (retry)
+                                continue;
+                }
+                if (rc)
+                        break;
+
+                ctxt->mrs[ctxt->index] = mr;
+                c2_ref_get(&ctxt->ref);
+                ++ctxt->index;
+                if (ctxt->index == ctxt->max_index - 1) {
+                        rc = rdma_wait_for_completion(ctxt);
+                        if (rc) {
+                                svc_errx("wait for RDMA read failed");
+                                break;
+                        }
+                        svc_assert(c2_ref_get(&ctxt->ref) == 0);
+                }
+
+                buffer += seg->length;
+                buflen -= seg->length;
+                svc_assert(ncount >= 0);
+                next = next->next;
+        }
+        if (rc)
+                goto out;
+
+        svc_assert(buflen == 0);
+        if (ctxt->index)
+                rc = rdma_wait_for_completion(ctxt);
+        if (rc == 0)
+                req->reads = next;
+
+out:
+        return rc;
+}
+
+/**
+ * rdma_write_chunks: Write chunks to reply stream.
+ */
+int rdma_write_chunks(struct rdma_reply *rep, char *buffer, int buflen)
+{
+        struct rdma_context *ctxt;
+        struct rdma_write_list *next,
+        struct rdma_write_list *tmp;
+        struct rdma_write_chunk *chunk;
+        struct rdma_segment *seg;
+        struct ibv_mr *mr;
+
+        ctxt = alloca(sizeof(*ctxt));
+        rdma_context_init(ctxt, rep->xprt, rdma_completion_rw, (void*)rep);
+
+        next = reply->writes;
+        start_index = reply->writes_index;
+        while (next && buflen) {
+                int i;
+
+                chunk = &next->entry;
+                for (i = start_index; i < chunk->nr_segs && buflen; i++) {
+                        seg = &chunk->segs[i];
+                        if (buflen < seg->length) {
+                                buflen = 0;
+                                seg->length = buflen;
+                        }
+                        mr = do_rdma_post(ctxt, seg, buffer, IBV_WR_RDMA_WRITE);
+                        if (mr == NULL) {
+                                int retry = !!ctxt->index;
+
+                                rc = rdma_wait_for_completion(ctxt);
+                                if (rc) {
+                                        svc_errx("wait for RDMA read failed");
+                                        break;
+                                }
+                                svc_assert(c2_ref_get(&ctxt->ref) == 0);
+
+                                rc = -EAGAIN;
+                                if (!retry)
+                                        break;
+
+                                /* retry */
+                                --i;
+                                continue;
+                        }
+
+                        /* update rdma context */
+                        ctxt->mrs[ctxt->index] = mr;
+                        c2_ref_get(&ctxt->ref);
+                        ++ctxt->index;
+                        if (ctxt->index == ctxt->max_index - 1) {
+                                rc = rdma_wait_for_completion(ctxt);
+                                if (rc) {
+                                        svc_errx("wait for RDMA read failed");
+                                        break;
+                                }
+                        }
+
+                        buffer += seg->length;
+                        buflen -= seg->length;
+                        svc_assert(buflen >= 0);
+                }
+                if (rc)
+                        break;
+
+                if (!buflen) {
+                        if (i == chunk->nr_segs) {
+                                rep->writes_index = 0;
+                                next = next->next;
+                        } else {
+                                rep->writes_index = i;
+                        }
+                        break;
+                }
+
+                rep->writes_index = 0;
+                next = next->next;
+        }
+        if (rc)
+                goto out;
+
+        svc_assert(buflen == 0);
+        if (ctxt->index)
+                rc = rdma_wait_for_completion(ctxt);
+        if (rc == 0)
+                req->writes = next;
+
+out:
+        return rc;
+}
+
+void rdma_fixup_write_chunks(struct rdma_reply *reply)
+{
+        struct rdma_segment *seg;
+        struct rdma_write_list *list = reply->writes;
+        int index = reply->writes_index;
+        int i;
+
+        while (list) {
+                for (i = index; i < list->entry.nr_segs; i++) {
+                        seg = &list->entry.segs[i];
+                        seg->length = 0;
+                }
+                index = 0;
+                list = list->next;
+        }
+}
+
+static void rdma_reply_completion(struct rdma_context *ctxt, void *args)
+{
+        svcrdma_put_reply(reply);
+        ctxt->index = 0;
+}
+
+int rdma_send_reply(struct rdma_reply *reply)
+{
+        struct rdma_context *ctxt;
+        struct ibv_sge sge[2];
+        struct ibv_send_wr wr;
+        struct ibv_send_wr *badwr;
+        int nr_sges = 1;
+        int rc;
+
+        svc_assert(rdma_buflen != 0);
+        sge[0].addr   = reply->rdma_buf;
+        sge[0].length = reply->rdma_buflen;
+        sge[0].lkey   = reply->rdma_mr->lkey;
+
+        if (reply->rpc_buflen) {
+                sge[1].addr   = reply->rpc_buf;
+                sge[1].length = reply->rpc_buflen;
+                sge[1].lkey   = reply->rpc_mr->lkey;
+                nr_sges++;
+        }
+
+        ctxt = alloca(*ctxt);
+        rdma_context_init(ctxt, reply->xprt,
+                          rdma_reply_completion, (void*)reply);
+
+        wr.wr_id = (uint64_t)ctxt;
+        wr.sg_list = sge;
+        wr.num_sge = nr_sges;
+        wr.opcode = IBV_WR_SEND;
+        wr.send_flags = IBV_SEND_SIGNALED;
+        rc = ibv_post_send(reply->xprt, &wr, &badwr);
+        if (rc) {
+                svc_errx("post reply buffer error\n");
+                return rc;
+        }
+
+        rc = rdma_wait_for_completion(ctxt);
+        return rc;
+}
+
 
diff --git a/net/usunrpc/rfc5666/svc_rdma.h b/net/usunrpc/rfc5666/svc_rdma.h
new file mode 100644
index 0000000..25e86cc
--- /dev/null
+++ b/net/usunrpc/rfc5666/svc_rdma.h
@@ -0,0 +1,11 @@
+
+struct svcrdma_config {
+        int dummy;
+};
+
+struct c2_dbuf {
+        bool_t (*xdr)(XDRS *, char *buffer, int buflen);
+        int alignment;
+        int buflen;
+        char *buffer;
+};
diff --git a/net/usunrpc/rfc5666/svc_rdma_internal.h b/net/usunrpc/rfc5666/svc_rdma_internal.h
new file mode 100644
index 0000000..d569601
--- /dev/null
+++ b/net/usunrpc/rfc5666/svc_rdma_internal.h
@@ -0,0 +1,136 @@
+
+#include <stdio.h>
+#include <unistd.h>
+#include <string.h>
+#include <libintl.h>
+#include <rpc/rpc.h>
+#include <sys/socket.h>
+#include <sys/poll.h>
+#include <errno.h>
+#include <stdlib.h>
+
+#ifdef USE_IN_LIBIO
+# include <wchar.h>
+# include <libio/iolibio.h>
+#endif
+
+#define RDMA_VERS       1
+
+enum rdma_xprt_status {
+        RDMA_XPRT_INIT   = 0,
+        RDMA_XPRT_LISTEN,
+        RDMA_XPRT_CONNECTING,
+        RDMA_XPRT_ESTABLISHED,
+        RDMA_XPRT_DESTROYED
+};
+
+/*
+ * svcrdma_export for listener
+ */
+struct svcrndzv_xprt {
+        SVCXPRT                    svcxprt;
+        struct rdma_cm_id         *cmid;
+        struct rdma_event_channel *channel;
+        enum rdma_xprt_status      status;
+
+        /* exports have been accepted. */
+        struct c2_list             xprts;
+
+        /* rdma parameters are stored here. */
+        int trans;
+        int port;
+        int max_send_wr;
+        int max_recv_wr;
+        int max_send_sge;
+        int max_recv_sge;
+        int rc_retry_cnt;
+        int rc_rnr_retry_cnt;
+        int max_msg_size;
+        int page_size;
+        int rcv_wr_flags;
+        int snd_wr_flags;
+};
+
+/*
+ *
+ */
+struct svcrdma_xprt {
+        struct c2_list_link   link;
+        SVCXPRT               svcxprt;
+        struct svcrndzv_xprt *rndzv;
+        struct rdma_cm_id    *cmid;
+
+        /* queue pair information */
+        struct ibv_comp_channel *channel;
+        struct ibv_pd           *pd;
+        struct ibv_cq           *cq;
+        struct ibv_qp           *qp;
+
+        /* the rdma request is processing */
+        struct rdma_request     *curreq;
+        struct c2_list          *requests;
+        struct c2_list          *replis;
+
+        /* preallocated buffers used by this xprt. */
+        struct rdma_request  *rcv_bufs;
+        struct rdma_reply    *snd_bufs;
+
+        /* attribute of this xprt */
+        enum rdma_xprt_status    status;
+};
+
+struct rdma_reply {
+        struct rdma_reply *next;
+        struct svcrdma_xprt  *xprt;
+
+        /**
+         * Active replies belong to this export
+         */
+        struct c2_list_link  *link;
+        struct svcrdma_msg    msg;
+        XDRS                  xdrs;
+
+        struct rdma_write_list  *writes;
+        struct rdma_write_chunk *reply;
+        int                writes_index;
+
+        int                curpos; /* current position of XDR stream */
+
+        void              *buffer;
+        void              *rdma_buf;
+        void              *rpc_buf;
+        int                rdma_buflen;
+        int                rpc_buflen;
+        struct ibv_mr     *rdma_mr;
+        struct ibv_mr     *rpc_mr;
+        struct ibv_send_wr wr;
+};
+
+struct rdma_request {
+        struct svcrdma_xprt  *xprt;
+        struct rdma_reply    *reply;
+
+        /**
+         * Active repquests belong to this export.
+         * Sunrpc works sync right now, but we maintain requests assuming that
+         * multiple requests are handled simultaneously.
+         */
+        struct c2_list_link  *link;
+        struct svcrdma_msg    msg;
+        void                 *rpcbuf_base;
+        int                   rpcbuf_len;
+        int                   curpos;  /* current pos in XDR stream */
+        int                   chunk_start;
+        int                   chunk_len;
+        XDR                   xdrs;
+
+        struct rdma_read_list   *reads;
+        struct rdma_write_list  *writes;
+        struct rdma_write_chunk *reply;
+
+        void                 *buffer;
+        struct ibv_mr        *mr;
+        struct ibv_recv_wr    wr;
+        struct ibv_sge        sge;
+};
+
diff --git a/net/usunrpc/rfc5666/xdr_rdma.c b/net/usunrpc/rfc5666/xdr_rdma.c
new file mode 100644
index 0000000..e0fcbb2
--- /dev/null
+++ b/net/usunrpc/rfc5666/xdr_rdma.c
@@ -0,0 +1,42 @@
+/*
+ */
+bool_t xdr_dbuf(XDR *xdrs, struct c2_dbuf *dbuf)
+{
+        if (!xdr_u_int(xdrs, &dbuf->alignment))
+                return FALSE;
+        if (!xdr_u_int(xdrs, &dbuf->buflen))
+                return FALSE;
+
+        switch(xdrs->x_op) {
+        case XDR_DECODE:
+                if (posix_memalign(&dbuf->buffer, dbuf->alignment,
+                                   dbuf->buflen))
+                        return FALSE;
+        case XDR_ENCODE:
+                if (dbuf->xdr)
+                        return dbuf->xdr(xdrs, dbuf->buffer, dbuf->buflen);
+                return xdr_opaque(xdrs, dbuf->buffer, dbuf->buflen);
+        case XDR_FREE:
+                mem_free(dbuf->buffer);
+                return TRUE;
+        }
+        return FALSE;
+}
+
+bool_t xdr_rdma_chunks(XDRS *xdrs, char *buffer, int buflen)
+{
+        int rc;
+
+        svc_assert(xdrs->x_op == XDR_ENCODE || xdrs->x_op == XDR_DECODE);
+        if (xdrs->x_op == XDR_DECODE) {
+                struct rdma_request *req;
+                req = (struct rdma_request *)xdrs->x_public;
+                rc = rdma_read_chunks(req, buffer, buflen);
+        } else {
+                struct rdma_reply *reply;
+                reply = (struct rdma_reply *)xdrs->x_public;
+                rc = rdma_write_chunks(reply, buffer, buflen);
+        }
+
+        return rc == 0 ? TRUE : FALSE;
+}
-- 
1.8.3.2

