From 524fb98f17c2b9ba755b4c3a6f5f3e21978b93e6 Mon Sep 17 00:00:00 2001
From: jay <jay@delta.(none)>
Date: Fri, 30 Jul 2010 00:05:53 -0600
Subject: [PATCH 19/34] - debug/fix bugs

---
 c2t1fs/main.c                           |   8 ++
 net/ksunrpc/kxdr.c                      |   7 +-
 net/usunrpc/rfc5666/rfc5666.h           |   1 +
 net/usunrpc/rfc5666/rfc5666_xdr.c       |  69 +++++++++++----
 net/usunrpc/rfc5666/svc_rdma.c          | 146 +++++++++++++++++++++++---------
 net/usunrpc/rfc5666/svc_rdma.h          |   2 +-
 net/usunrpc/rfc5666/svc_rdma_internal.h |   5 +-
 net/usunrpc/server.c                    |   7 +-
 net/usunrpc/usunrpc.h                   |  18 +---
 9 files changed, 181 insertions(+), 82 deletions(-)

diff --git a/c2t1fs/main.c b/c2t1fs/main.c
index 21b3464..cc80d14 100644
--- a/c2t1fs/main.c
+++ b/c2t1fs/main.c
@@ -131,6 +131,12 @@ static int ksunrpc_read_write(struct c2_net_conn *conn,
 	struct c2_fop       *r;
 	struct c2_net_call  kcall;
 
+	if (off) {
+		printk(KERN_ERR "Do not support unaligned read/write, off=%d\n",
+			off);
+		return -EINVAL;
+	}
+
         if (rw == WRITE) {
 		struct c2_io_write     *arg;
                 struct c2_io_write_rep *ret;
@@ -153,6 +159,7 @@ static int ksunrpc_read_write(struct c2_net_conn *conn,
 		arg->siw_buf.cib_count = len;
 		arg->siw_buf.cib_pgoff = off;
 		arg->siw_buf.cib_pages = pages;
+		arg->siw_buf.cib_npages = npages;
 
                 DBG("writing data to server(%llu/%d/%d/%ld/%lld)\n",
                     objid, npages, off, len, pos);
@@ -185,6 +192,7 @@ static int ksunrpc_read_write(struct c2_net_conn *conn,
 		ret->sirr_buf.cib_count = len;
 		ret->sirr_buf.cib_pgoff = off;
 		ret->sirr_buf.cib_pages = pages;
+		ret->sirr_buf.cib_npages = npages;
 
                 DBG("reading data from server(%llu/%d/%d/%ld/%lld)\n",
                     objid, npages, off, len, pos);
diff --git a/net/ksunrpc/kxdr.c b/net/ksunrpc/kxdr.c
index cb2ab3d..e294753 100644
--- a/net/ksunrpc/kxdr.c
+++ b/net/ksunrpc/kxdr.c
@@ -274,7 +274,7 @@ static int kxdr_bulk_enc(struct kxdr_ctx *ctx, void *obj)
                 return result;
 
         xdr_write_pages(ctx->kc_xdr, dbuf->cib_pages, dbuf->cib_pgoff,
-                        dbuf->cib_npages);
+                        dbuf->cib_count);
         return 0;
 }
 
@@ -303,10 +303,9 @@ static int kxdr_bulk_rep(struct kxdr_ctx *ctx, void *obj)
 
         *ctx->kc_nob += sizeof(dbuf->cib_align) + sizeof(dbuf->cib_count);
         auth = ctx->kc_req->rq_task->tk_msg.rpc_cred->cr_auth;
-        offset = ((RPC_REPHDRSIZE + auth->au_rslack + 3) << 2) +
-                        *ctx->kc_nob;
+        offset = ((RPC_REPHDRSIZE + auth->au_rslack + 3) << 2) + *ctx->kc_nob;
         xdr_inline_pages(&ctx->kc_req->rq_rcv_buf, offset,
-                         dbuf->cib_pages, dbuf->cib_pgoff, dbuf->cib_npages);
+                         dbuf->cib_pages, dbuf->cib_pgoff, dbuf->cib_count);
         return 0;
 }
 
diff --git a/net/usunrpc/rfc5666/rfc5666.h b/net/usunrpc/rfc5666/rfc5666.h
index 382c934..ca84060 100644
--- a/net/usunrpc/rfc5666/rfc5666.h
+++ b/net/usunrpc/rfc5666/rfc5666.h
@@ -112,6 +112,7 @@ struct svcrdma_msg {
 
 /* the xdr functions */
 extern  bool_t xdr_svcrdma_msg (XDR *, struct svcrdma_msg *);
+extern  void   svcrdma_msg_dump(const char *, struct svcrdma_msg *);
 
 /** @} endgroup svcrdma */
 
diff --git a/net/usunrpc/rfc5666/rfc5666_xdr.c b/net/usunrpc/rfc5666/rfc5666_xdr.c
index 8980868..2b2f627 100644
--- a/net/usunrpc/rfc5666/rfc5666_xdr.c
+++ b/net/usunrpc/rfc5666/rfc5666_xdr.c
@@ -65,21 +65,21 @@ static bool_t xdr_rdma_proc (XDR *xdrs, enum rdma_proc *objp)
 
 static bool_t xdr_rdma_header_msg (XDR *xdrs, struct rdma_header_msg *objp)
 {
-         if (!xdr_pointer (xdrs,
-                           (char **)&objp->rdma_reads,
-                           sizeof (struct rdma_read_list),
-                           (xdrproc_t) xdr_rdma_read_list))
-                 return FALSE;
-         if (!xdr_pointer (xdrs,
-                           (char **)&objp->rdma_writes,
-                           sizeof (struct rdma_write_list),
-                           (xdrproc_t) xdr_rdma_write_list))
-                 return FALSE;
-         if (!xdr_pointer (xdrs,
-                           (char **)&objp->rdma_reply,
-                           sizeof (struct rdma_write_chunk),
-                           (xdrproc_t) xdr_rdma_write_chunk))
-                 return FALSE;
+        if (!xdr_pointer (xdrs,
+                          (char **)&objp->rdma_reads,
+                          sizeof (struct rdma_read_list),
+                          (xdrproc_t) xdr_rdma_read_list))
+                return FALSE;
+        if (!xdr_pointer (xdrs,
+                          (char **)&objp->rdma_writes,
+                          sizeof (struct rdma_write_list),
+                          (xdrproc_t) xdr_rdma_write_list))
+                return FALSE;
+        if (!xdr_pointer (xdrs,
+                          (char **)&objp->rdma_reply,
+                          sizeof (struct rdma_write_chunk),
+                          (xdrproc_t) xdr_rdma_write_chunk))
+                return FALSE;
         return TRUE;
 }
 
@@ -208,4 +208,43 @@ bool_t xdr_svcrdma_msg (XDR *xdrs, struct svcrdma_msg *objp)
         return TRUE;
 }
 
+static const char *proc_name[] = {
+        [RDMA_MSG]   = "msg",
+        [RDMA_NOMSG] = "no msg",
+        [RDMA_MSGP]  = "padded msg",
+        [RDMA_DONE]  = "done msg",
+        [RDMA_ERROR] = "error msg"
+};
+
+void svcrdma_msg_dump(const char *msg, struct svcrdma_msg *m)
+{
+        printf("-------------- dump rdma message:%s ----------\n", msg);
+        printf("xid %u|vers %d|credit %d|proc %s\n",
+                m->rdma_xid, m->rdma_vers, m->rdma_credit,
+                proc_name[m->rdma_body.rdma_proc]);
+        switch(m->rdma_body.rdma_proc) {
+        case RDMA_MSG: {
+                struct rdma_header_msg *hm = &m->rdma_body.u.rdma_msg;
+                printf("reads %p|writes %p|reply %p\n",
+                        hm->rdma_reads, hm->rdma_writes, hm->rdma_reply);
+                break;
+        }
+
+        case RDMA_NOMSG:
+        case RDMA_MSGP:
+        case RDMA_DONE:
+        case RDMA_ERROR:
+                break;
+        }
+        printf("-------------- dump end ----------\n");
+}
 
+/*
+ *  Local variables:
+ *  c-indentation-style: "K&R"
+ *  c-basic-offset: 8
+ *  tab-width: 8
+ *  fill-column: 80
+ *  scroll-step: 1
+ *  End:
+ */
diff --git a/net/usunrpc/rfc5666/svc_rdma.c b/net/usunrpc/rfc5666/svc_rdma.c
index 854a354..2828483 100644
--- a/net/usunrpc/rfc5666/svc_rdma.c
+++ b/net/usunrpc/rfc5666/svc_rdma.c
@@ -85,6 +85,7 @@ SVCXPRT *svcrdma_create (struct sockaddr_in *sa, struct svcrdma_config *cfg)
         SVCXPRT *svcxprt;
         struct svcrndzv_xprt *vxp;
         struct ibv_device_attr devattr;
+        int rc;
 
         C2_ALLOC_PTR(vxp);
         if (vxp == NULL) {
@@ -107,6 +108,18 @@ SVCXPRT *svcrdma_create (struct sockaddr_in *sa, struct svcrdma_config *cfg)
                 svcrdma_errx(errno, "rdma_create_id failed\n");
                 goto out;
         }
+        C2_ASSERT(vxp->vx_cmid->verbs == NULL);
+
+        if ((rc = rdma_bind_addr(vxp->vx_cmid, (struct sockaddr *)sa))) {
+                svcrdma_errx(errno, "bind address error rc = %d\n", rc);
+                goto out;
+        }
+
+        vxp->vx_status = RDMA_XPRT_LISTEN;
+        if (rdma_listen(vxp->vx_cmid, 0)) {
+                svcrdma_errx(errno, "listen error\n");
+                goto out;
+        }
 
         /* get attribute of before doing anything else */
         if (ibv_query_device(vxp->vx_cmid->verbs, &devattr)) {
@@ -134,17 +147,6 @@ SVCXPRT *svcrdma_create (struct sockaddr_in *sa, struct svcrdma_config *cfg)
                                IBV_ACCESS_REMOTE_READ |
                                IBV_ACCESS_REMOTE_WRITE;
 
-        if (rdma_bind_addr(vxp->vx_cmid, (struct sockaddr *)&sa)) {
-                svcrdma_errx(errno, "bind address error\n");
-                goto out;
-        }
-
-        vxp->vx_status = RDMA_XPRT_LISTEN;
-        if (rdma_listen(vxp->vx_cmid, 0)) {
-                svcrdma_errx(errno, "listen error\n");
-                goto out;
-        }
-
         /* Now initiate SVCXPRT stuffs. */
         svcxprt = &vxp->vx_svcxprt;
         svcxprt->xp_p1 = (caddr_t)vxp;
@@ -236,6 +238,7 @@ static int svcrdma_handle_connection(struct svcrndzv_xprt *vxp,
                 goto out;
         }
 
+        xprt->rx_qp = cmid->qp;
         if ((rc = svcrdma_buffer_create(xprt)))
                 goto out;
 
@@ -476,14 +479,19 @@ static bool_t svcrdma_getargs(SVCXPRT *svcxprt, xdrproc_t xdr_args,
 static bool_t svcrdma_freeargs(SVCXPRT *svcxprt, xdrproc_t xdr_args,
                                caddr_t args_ptr)
 {
+        XDR xdrs;
+#if 0
         struct svcrdma_xprt *xp = (struct svcrdma_xprt *)svcxprt->xp_p1;
         XDR *xdrs;
 
         C2_ASSERT(xp->rx_curreq != NULL);
         xdrs = &xp->rx_curreq->rq_xdrs;
+        xp->rx_curreq = NULL;
         C2_ASSERT(xdrs->x_public == (caddr_t)xp->rx_curreq);
         xdrs->x_op = XDR_FREE;
-        return ((*xdr_args) (xdrs, args_ptr));
+#endif
+        xdrs.x_op = XDR_FREE;
+        return ((*xdr_args) (&xdrs, args_ptr));
 }
 
 static bool_t svcrdma_reply(SVCXPRT *svcxprt, struct rpc_msg *rpcmsg)
@@ -514,6 +522,7 @@ static bool_t svcrdma_reply(SVCXPRT *svcxprt, struct rpc_msg *rpcmsg)
         /* it looks all right, post reply buffer */
         rc = rdma_reply_send(reply);
         if (rc) {
+                svcrdma_errx(rc, "send reply failed\n");
                 /* if error, reply is not freed */
                 rdma_reply_put(reply);
                 return FALSE;
@@ -658,8 +667,9 @@ static int svcrdma_buffer_create(struct svcrdma_xprt *xprt)
                 if (reply->rp_buffer == NULL)
                         goto out;
 
-                reply->rp_rdma_mr = ibv_reg_mr(xprt->rx_pd, reply->rp_buffer, bufsize,
-                                            xprt->rx_rndzv->vx_snd_wr_flags);
+                reply->rp_rdma_mr = ibv_reg_mr(xprt->rx_pd,
+                                               reply->rp_buffer, bufsize,
+                                               xprt->rx_rndzv->vx_snd_wr_flags);
                 if (!reply->rp_rdma_mr) {
                         rc = errno;
                         goto out;
@@ -672,6 +682,8 @@ static int svcrdma_buffer_create(struct svcrdma_xprt *xprt)
                         rc = errno;
                         goto out;
                 }
+                reply->rp_rdma_buf = reply->rp_buffer;
+                reply->rp_rpc_buf  = reply->rp_buffer + bufsize;
         }
 
         return 0;
@@ -720,17 +732,21 @@ static struct rdma_reply *rdma_reply_get(struct svcrdma_xprt *xprt)
 
 static void rdma_request_repost(struct rdma_request *req)
 {
+        struct svcrdma_xprt *xprt = req->rq_xprt;
         struct ibv_recv_wr *badwr;
         int rc;
 
-        c2_mutex_lock(&req->rq_xprt->rx_lock);
+        C2_ASSERT(xprt->rx_curreq == req);
+        xprt->rx_curreq = NULL;
+
+        c2_mutex_lock(&xprt->rx_lock);
         c2_list_del(&req->rq_link);
-        c2_mutex_unlock(&req->rq_xprt->rx_lock);
+        c2_mutex_unlock(&xprt->rx_lock);
 
         C2_ASSERT(req->rq_reply == NULL);
         xdrmem_create(&req->rq_xdrs, NULL, 0, XDR_FREE);
         xdr_svcrdma_msg(&req->rq_xdrs, &req->rq_msg);
-        rc = ibv_post_recv(req->rq_xprt->rx_qp, &req->rq_wr, &badwr);
+        rc = ibv_post_recv(xprt->rx_qp, &req->rq_wr, &badwr);
         if (rc)
                 svcrdma_errx(rc, "repost recv buffer error");
 }
@@ -805,19 +821,20 @@ static int rdma_recv_completion(struct svcrdma_xprt *xprt,
 
         msg = &req->rq_msg;
         xdrmem_create(&xdrs, req->rq_buffer, reqlen, XDR_DECODE);
-        if (xdr_svcrdma_msg(&xdrs, msg)) {
+        if (!xdr_svcrdma_msg(&xdrs, msg)) {
                 svcrdma_errx(0,
                              "message corrupted, decode rdma header failed");
-                reply->rp_xid = msg->rdma_xid; /* XXX: XID still wasn't decoded? */
+                 /* XXX: XID still wasn't decoded? */
+                reply->rp_xid = msg->rdma_xid;
                 errcode = RDMA_ERR_CHUNK;
                 goto out;
         }
+        svcrdma_msg_dump("request", msg);
         pos = XDR_GETPOS(&xdrs);
         C2_ASSERT(pos <= reqlen);
         reply->rp_xid = msg->rdma_xid;
 
         /* version check */
-        msg = &req->rq_msg;
         if (msg->rdma_vers != RDMA_VERS) {
                 svcrdma_errx(0, "version mismatched, %d/%d",
                              msg->rdma_vers, RDMA_VERS);
@@ -899,15 +916,24 @@ static int rdma_recv_completion(struct svcrdma_xprt *xprt,
         req->rq_writes = NULL;
         req->rq_reply  = reply;
 
+        dprintf("request rdma buflen = %d, rpclen = %d\n",
+                pos, req->rq_rpcbuf_len);
+
         /* the header of RDMA chunks looks fine, just set the XDR stream */
         xdrmem_create(&req->rq_xdrs, req->rq_rpcbuf_base, req->rq_rpcbuf_len,
                       XDR_DECODE);
         req->rq_xdrs.x_public = (void *)req;
+        if (!xdr_callmsg(&req->rq_xdrs, rpcmsg)) {
+                rc = EINVAL;
+                goto out;
+        }
+
         return 0;
 
 out:
         /* DRR: We'd like to repost request here. */
         /* rdma_request_repost(req); */
+        dprintf("error occurs %d\n", rc);
         if (errcode != RDMA_OK) { /* something wrong */
                 reply->rp_errcode = errcode;
                 rdma_reply_send(reply);
@@ -927,6 +953,7 @@ static void rdma_context_init(struct rdma_context *ctxt,
         c2_atomic64_set(&ctxt->refcnt, 0);
         ctxt->xprt       = xprt;
         ctxt->status     = IBV_WC_SUCCESS;
+        ctxt->async      = 0;
         ctxt->completion = comp;
         ctxt->ctx        = ctx;
         ctxt->index      = 0;
@@ -953,7 +980,7 @@ static void rdma_completion_one(struct rdma_context *ctxt,
                 svcrdma_errx(0, "ctxt(%p) cq error %s\n",
                              ctxt, ibv_wc_status_str(rc));
         }
-        if (c2_atomic64_dec_and_test(&ctxt->refcnt) == 0) {
+        if (c2_atomic64_dec_and_test(&ctxt->refcnt)) {
                 ctxt->completion(ctxt, ctxt->ctx);
                 /* TODO: need to wake up threads in multiple thread env */
         }
@@ -966,13 +993,13 @@ static int rdma_wait_for_completion(struct rdma_context *ctxt)
         void          *ectx;
         struct ibv_wc  wc;
         int            rc = 0;
-        int            ncount = ctxt->index;
+        int            ncount = c2_atomic64_get(&ctxt->refcnt);
+
+        dprintf("ctxt %p ncount = %d\n", ctxt, ncount);
 
         if (ncount == 0)
                 return 0;
 
-        C2_ASSERT(ncount <= ctxt->max_index);
-
 again:
         if ((rc = ibv_get_cq_event(xprt->rx_channel, &ecq, &ectx))) {
                 svcrdma_errx(rc, "get cq_event for xprt %p\n", xprt);
@@ -986,13 +1013,16 @@ again:
         while (1) {
                 rc = ibv_poll_cq(xprt->rx_cq, 1, &wc);
                 if (rc == 0) {         /* no event pending any more */
-                        break;
+			break;
                 } else if (rc < 0) {   /* error occurs */
                         rc = errno;
                         svcrdma_errx(rc, "error occurs polling cq");
                         break;
                 }
 
+                dprintf("get %d event from ctxt %p/%lx/%d\n",
+                        rc, ctxt, wc.wr_id, (int)c2_atomic64_get(&ctxt->refcnt));
+
                 ncount--;
                 C2_ASSERT(rc == 1);
                 C2_ASSERT(wc.wr_id == (uint64_t)ctxt);
@@ -1030,10 +1060,11 @@ static int do_rdma_post(struct rdma_context *ctxt, struct rdma_segment *seg,
         int rc;
 
         C2_ASSERT(opc == IBV_WR_RDMA_READ || opc == IBV_WR_RDMA_WRITE);
-        flags = IBV_ACCESS_REMOTE_WRITE|IBV_ACCESS_REMOTE_READ;
+	flags = IBV_ACCESS_LOCAL_WRITE | IBV_ACCESS_REMOTE_READ |
+                IBV_ACCESS_REMOTE_WRITE;
         mr = ibv_reg_mr(ctxt->xprt->rx_pd, buffer, seg->rs_length, flags);
         if (mr == NULL)
-                return ENOMEM;
+                return errno ?: ENOMEM;
 
         sge.lkey = mr->lkey;
         rc = ibv_post_send(ctxt->xprt->rx_qp, &wr, &badwr);
@@ -1068,14 +1099,19 @@ static int rdma_chunks_read(struct rdma_request *req, char *buffer, int buflen)
         while (rl && buflen) {
                 seg = &rl->rrl_entry.rrc_target;
                 C2_ASSERT(buflen >= seg->rs_length);
+		dprintf("pos %d, seg len %d handle %x, offset %lx\n",
+			rl->rrl_entry.rrc_position,
+			seg->rs_length, seg->rs_handle, seg->rs_offset);
                 rc = do_rdma_post(ctxt, seg, buffer, IBV_WR_RDMA_READ, &mr);
                 if (rc) {
                         int retry = !!ctxt->index;
                         int rc2;
+
+			svcrdma_errx(rc, "post recv buffer error\n");
                         
                         rc2 = rdma_wait_for_completion(ctxt);
                         if (rc2) {
-                                svcrdma_errx(0, "wait for RDMA read failed");
+                                svcrdma_errx(rc2, "wait for RDMA read failed");
                                 break;
                         }
                         C2_ASSERT(c2_atomic64_get(&ctxt->refcnt) == 0);
@@ -1102,19 +1138,29 @@ static int rdma_chunks_read(struct rdma_request *req, char *buffer, int buflen)
 
                 buffer += seg->rs_length;
                 buflen -= seg->rs_length;
-                C2_ASSERT(buflen >= 0);
+                if (buflen < 0)
+                        break;
+
                 rl = rl->rrl_next;
         }
-        if (rc)
-                goto out;
 
-        C2_ASSERT(buflen == 0);
-        if (ctxt->index)
-                rc = rdma_wait_for_completion(ctxt);
+	sleep(1);
+        if (ctxt->index) {
+                int rc2;
+                rc2 = rdma_wait_for_completion(ctxt);
+                if (rc == 0)
+                        rc = rc2;
+        }
+        if (buflen != 0 && rc == 0) {
+                rc = EINVAL;
+                svcrdma_errx(rc, "cannot consume all buffer, this means the size"
+                             " in rdma and the in protocol does not match!\n");
+        }
         if (rc == 0)
                 req->rq_reads = rl;
 
-out:
+	printf("buffer = %s, rc = %d, rl = %p\n", buffer, rc, rl);
+
         return rc;
 }
 
@@ -1298,6 +1344,7 @@ static int rdma_reply_encode(struct rdma_reply *reply)
 
 static void rdma_reply_completion(struct rdma_context *ctxt, void *args)
 {
+        dprintf("ctxt %p reply %p finished\n", ctxt, args);
         rdma_reply_put((struct rdma_reply *)args);
         ctxt->index = 0;
 }
@@ -1307,7 +1354,7 @@ static int rdma_reply_send(struct rdma_reply *reply)
         struct rdma_context  ctxt_static;
         struct rdma_context *ctxt = &ctxt_static;
         struct ibv_sge       sge[2];
-        struct ibv_send_wr   wr;
+        struct ibv_send_wr   wr = { 0 };
         struct ibv_send_wr  *badwr;
         int nr_sges = 1;
         int rc;
@@ -1316,6 +1363,10 @@ static int rdma_reply_send(struct rdma_reply *reply)
         if (rc)
                 return rc;
 
+        svcrdma_msg_dump("reply", &reply->rp_msg);
+        dprintf("reply rdma_buflen %d|rpc_buflen %d\n",
+                reply->rp_rdma_buflen, reply->rp_rpc_buflen);
+
         C2_ASSERT(reply->rp_rdma_buflen != 0);
         sge[0].addr   = (uint64_t)reply->rp_rdma_buf;
         sge[0].length = reply->rp_rdma_buflen;
@@ -1331,10 +1382,10 @@ static int rdma_reply_send(struct rdma_reply *reply)
         rdma_context_init(ctxt, reply->rp_xprt,
                           rdma_reply_completion, (void*)reply);
 
-        wr.wr_id = (uint64_t)ctxt;
-        wr.sg_list = sge;
-        wr.num_sge = nr_sges;
-        wr.opcode = IBV_WR_SEND;
+        wr.wr_id      = (uint64_t)ctxt;
+        wr.sg_list    = sge;
+        wr.num_sge    = nr_sges;
+        wr.opcode     = IBV_WR_SEND;
         wr.send_flags = IBV_SEND_SIGNALED;
         rc = ibv_post_send(reply->rp_xprt->rx_qp, &wr, &badwr);
         if (rc) {
@@ -1342,6 +1393,7 @@ static int rdma_reply_send(struct rdma_reply *reply)
                 return rc;
         }
 
+        c2_atomic64_inc(&ctxt->refcnt);
         rc = rdma_wait_for_completion(ctxt);
         return rc;
 }
@@ -1349,10 +1401,12 @@ static int rdma_reply_send(struct rdma_reply *reply)
 /**
   This is the callback function of xdr_dbuf().
  */
-bool_t xdr_rdma_chunks(XDR *xdrs, char *buffer, int buflen)
+bool_t xdr_rdma_chunks(XDR *xdrs, void *buffer, int buflen)
 {
         int rc;
 
+        dprintf("encode or decode rdma chunks, buflen = %d\n", buflen);
+
         C2_ASSERT(xdrs->x_op == XDR_ENCODE || xdrs->x_op == XDR_DECODE);
         if (xdrs->x_op == XDR_DECODE) {
                 struct rdma_request *req;
@@ -1366,3 +1420,13 @@ bool_t xdr_rdma_chunks(XDR *xdrs, char *buffer, int buflen)
 
         return rc == 0 ? TRUE : FALSE;
 }
+
+/*
+ *  Local variables:
+ *  c-indentation-style: "K&R"
+ *  c-basic-offset: 8
+ *  tab-width: 8
+ *  fill-column: 80
+ *  scroll-step: 1
+ *  End:
+ */
diff --git a/net/usunrpc/rfc5666/svc_rdma.h b/net/usunrpc/rfc5666/svc_rdma.h
index 249451d..dfb2b59 100644
--- a/net/usunrpc/rfc5666/svc_rdma.h
+++ b/net/usunrpc/rfc5666/svc_rdma.h
@@ -40,7 +40,7 @@ SVCXPRT *svcrdma_create(struct sockaddr_in *sa, struct svcrdma_config *cfg);
 /**
   the callback function of xdr_dbuf().
  */
-bool_t   xdr_rdma_chunks(XDR *xdrs, char *buffer, int buflen);
+bool_t   xdr_rdma_chunks(XDR *xdrs, void *buffer, int buflen);
 
 /** @} end group svcrdma */
 
diff --git a/net/usunrpc/rfc5666/svc_rdma_internal.h b/net/usunrpc/rfc5666/svc_rdma_internal.h
index b50c55d..d70a698 100644
--- a/net/usunrpc/rfc5666/svc_rdma_internal.h
+++ b/net/usunrpc/rfc5666/svc_rdma_internal.h
@@ -355,7 +355,6 @@ struct rdma_reply {
         void              *rp_rpc_buf;     /**< buffer to store rpc message */
         int                rp_rpc_buflen;  /**< rpc message buffer */
         struct ibv_mr     *rp_rpc_mr;      /**< memory region for rpc msg */
-        struct ibv_send_wr rp_wr;
         void              *rp_buffer;      /**< preallocated buffer, bufsize
                                                 is 2*max_msg_size */
 };
@@ -377,13 +376,15 @@ struct rdma_context {
         void                *ctx;
         struct svcrdma_xprt *xprt;
         enum ibv_wc_status   status;
+	int		     async;
         int                  max_index;
         int                  index;
         struct ibv_mr       *mrs[CTXT_MAX_MRS];
 };
 
 #include <err.h>
-#define svcrdma_errx(rc, fmt, args...)      errx(1, fmt, ##args)
+#define svcrdma_errx(rc, fmt, args...) errx(1, "error(%d):" fmt, rc, ##args)
+#define dprintf(fmt, args...) fprintf(stderr, "[%s:%d] " fmt, __FILE__, __LINE__, ##args)
 
 /** @} end group svcrdma */
 
diff --git a/net/usunrpc/server.c b/net/usunrpc/server.c
index 047aa19..3f54010 100644
--- a/net/usunrpc/server.c
+++ b/net/usunrpc/server.c
@@ -284,6 +284,8 @@ static void usunrpc_op(struct c2_service *service,
 	struct c2_fop          *arg;
 	int                     result;
 
+	printf("got fop %s\n", fopt->ft_name);
+
 	xs  = service->s_xport_private;
 	arg = c2_fop_alloc(fopt, NULL);
 	C2_ALLOC_PTR(wi);
@@ -381,7 +383,7 @@ static int usunrpc_start_svcrdma(struct c2_service *service,
                 .sin_family     = AF_INET,
                 .sin_port       = htons(xid->ssi_port),
                 .sin_addr       = {
-                        .s_addr = 0
+                        .s_addr = inet_addr("10.0.3.1")
                 }
         };
 
@@ -392,9 +394,10 @@ static int usunrpc_start_svcrdma(struct c2_service *service,
         if (xservice->s_transp == NULL)
                 return -errno;
 
+	c2_dbuf_xdrproc_set(xdr_rdma_chunks);
         return 0;
 #else
-        return -ENOSUPP;
+        return -EOPNOTSUPP;
 #endif
 }
 
diff --git a/net/usunrpc/usunrpc.h b/net/usunrpc/usunrpc.h
index 5c3c0e5..a33fb48 100644
--- a/net/usunrpc/usunrpc.h
+++ b/net/usunrpc/usunrpc.h
@@ -20,23 +20,7 @@ bool_t c2_fop_type_uxdr(const struct c2_fop_field_type *ftype,
 bool_t c2_fop_uxdrproc(XDR *xdrs, struct c2_fop *fop);
 int usunrpc_init(void);
 void usunrpc_fini(void);
-/**
-  xdr function for c2_dbuf.
-  We need this function to encode/decode data buffer in case they are to be
-  transferred via rdma read/write.
-
-  @param[in] xdrs - 
-  @param[in] dbuf - the c2_dbuf will be encoded or decoded
-  @param[in] xdr  - this is a callback function to encode/decode XDR stream;
-                    for rdma, this function must be xdr_rdma_chunks;
-                    otherwise NULL
-
-  @retval TRUE    - success
-  @retval FALSE   - something wrong
- */
-struct c2_dbuf;
-bool_t c2_xdr_dbuf (XDR *xdrs, struct c2_dbuf *dbuf,
-                    bool_t (*xdrproc)(XDR *, char *, int));
+void   c2_dbuf_xdrproc_set(bool_t (*)(XDR *, void *, int));
 
 /** @} end of group usunrpc */
 
-- 
1.8.3.2

