From 4bade381763fe48d16fb78ad53e131d9fd56187a Mon Sep 17 00:00:00 2001
From: "jinshan.xiong" <jinshan.xiong@clusterstor.com>
Date: Fri, 6 Aug 2010 13:50:51 -0600
Subject: [PATCH 29/34] - fix the problem mentioned by nikita

---
 c2t1fs/main.c                           |  7 +++--
 colibri/Makefile.am                     |  8 +++---
 configure.ac                            | 45 +++++++++++++--------------------
 fop/fop.c                               | 26 +++++++++++++------
 fop/fop2c.in                            |  6 +++++
 lib/refs.c                              |  8 ------
 lib/refs.h                              | 10 --------
 lib/thread.h                            |  8 ++++++
 lib/user_space/thread.c                 |  3 ---
 net/ksunrpc/ksunrpc.h                   |  6 +++--
 net/usunrpc/Makefile.am                 |  8 +-----
 net/usunrpc/rfc5666/svc_rdma.c          | 22 ++++++++--------
 net/usunrpc/rfc5666/svc_rdma_internal.h |  2 +-
 net/usunrpc/server.c                    | 13 +++-------
 net/usunrpc/usunrpc.h                   |  1 +
 net/usunrpc/usunrpc_internal.h          |  4 +--
 net/usunrpc/uxdr.c                      | 13 ++--------
 17 files changed, 80 insertions(+), 110 deletions(-)

diff --git a/c2t1fs/main.c b/c2t1fs/main.c
index cc80d14..45ba0fe 100644
--- a/c2t1fs/main.c
+++ b/c2t1fs/main.c
@@ -9,6 +9,7 @@
 #include <linux/uio.h>
 #include <linux/inet.h>
 #include <linux/in.h>
+#include <linux/pagemap.h>
 #include <linux/sunrpc/xprt.h>
 
 #include "lib/misc.h"  /* C2_SET0 */
@@ -155,7 +156,7 @@ static int ksunrpc_read_write(struct c2_net_conn *conn,
                 arg->siw_object.f_seq  = 10;
                 arg->siw_object.f_oid  = objid;
 		arg->siw_offset        = pos;
-		arg->siw_buf.cib_align = PAGE_SIZE;
+		arg->siw_buf.cib_align = PAGE_CACHE_SIZE;
 		arg->siw_buf.cib_count = len;
 		arg->siw_buf.cib_pgoff = off;
 		arg->siw_buf.cib_pages = pages;
@@ -188,7 +189,7 @@ static int ksunrpc_read_write(struct c2_net_conn *conn,
 		arg->sir_seg.f_offset = pos;
 		arg->sir_seg.f_count  = len;
 
-		ret->sirr_buf.cib_align = PAGE_SIZE;
+		ret->sirr_buf.cib_align = PAGE_CACHE_SIZE;
 		ret->sirr_buf.cib_count = len;
 		ret->sirr_buf.cib_pgoff = off;
 		ret->sirr_buf.cib_pages = pages;
@@ -527,11 +528,9 @@ static int c2t1fs_parse_options(struct super_block *sb, char *options)
                         if (strncmp(trans, "tcp", 3) == 0) {
                                 s1 += 3;
                                 csi->csi_srvid.ssi_trans = XPRT_TRANSPORT_TCP;
-#ifdef ENABLE_RDMA
                         } else if (strncmp(trans, "rdma", 4) == 0) {
                                 s1 += 4;
                                 csi->csi_srvid.ssi_trans = XPRT_TRANSPORT_RDMA;
-#endif
                         } else {
                                 printk(KERN_ERR "wrong transport type\n");
                                 return -EINVAL;
diff --git a/colibri/Makefile.am b/colibri/Makefile.am
index e4d87db..feeee15 100644
--- a/colibri/Makefile.am
+++ b/colibri/Makefile.am
@@ -19,6 +19,9 @@ libcolibri_la_LIBADD      = @AIO_LIBS@ @PTHREAD_LIBS@ @DB_LIBS@ @GALOIS_LIBS@ @C
                             $(top_builddir)/lib/libc2.la \
                             $(top_builddir)/net/libcolibri-net.la \
                             $(top_builddir)/net/usunrpc/libcolibri-net-usunrpc.la \
+                            $(top_builddir)/net/usunrpc/rfc5666/libcolibri-rdma.la \
+                            $(top_builddir)/fop/libcolibri-fop.la \
+                            $(top_builddir)/reqh/libcolibri-reqh.la \
                             $(top_builddir)/nrs/libcolibri-nrs.la \
                             $(top_builddir)/pool/libcolibri-pool.la \
                             $(top_builddir)/reqh/libcolibri-reqh.la \
@@ -29,10 +32,5 @@ libcolibri_la_LIBADD      = @AIO_LIBS@ @PTHREAD_LIBS@ @DB_LIBS@ @GALOIS_LIBS@ @C
 
 #                            $(top_builddir)/rpc/libcolibri-rpc.la
 
-# the following are from the rdma branch. Do we need the INCLUDES?
-if ENABLE_RDMA
-libcolibri_la_LIBADD += $(top_builddir)/net/usunrpc/rfc5666/libcolibri-rdma.la
-endif
-
 INCLUDES                  = -I. -I$(top_srcdir) -I$(top_srcdir)/include -I@DBSRC@ -I@DBSRC@/build_unix 
 
diff --git a/configure.ac b/configure.ac
index 665096d..8eda013 100755
--- a/configure.ac
+++ b/configure.ac
@@ -8,7 +8,6 @@ AH_TEMPLATE([PACKAGE], [Package name.])
 AH_TEMPLATE([VERSION], [Version of the package.])
 AH_TEMPLATE([ENABLE_DEBUG], [Enable debug info.])
 AH_TEMPLATE([ENABLE_GSSRPC], [Enable gssrpc.])
-AH_TEMPLATE([ENABLE_RDMA], [Enable rdma.])
 AH_TEMPLATE([HAVE_JOURNAL_ABORT], [Have journal_abort() function])
 AH_TEMPLATE([HAVE_FILE_READV], [Have fops->readv function])
 AH_TEMPLATE([HAVE_FILE_AIO_READ], [Have fops->aio_read function])
@@ -305,8 +304,6 @@ case $host_os in
                 ;;
 esac
 
-AM_CONDITIONAL([ENABLE_RDMA], [test x$enable_rdma = xyes])
-
 AC_MSG_CHECKING([for linux sources dir])
 AC_ARG_WITH([linux],
         [AC_HELP_STRING([--with-linux=path], [set path to linux sources])],
@@ -463,31 +460,23 @@ if test x$OS = xlinux; then
         LIBS=$OLD_LIBS
 fi
 
-AC_DEFUN([COLIBRI_LINUX_RDMA],
-[AC_MSG_CHECKING([if kernel supports sunrpc over rdma])
- COLIBRI_LINUX_TRY_COMPILE([
-        #include <linux/sunrpc/xprt.h>
-],[
-        int abc = XPRT_TRANSPORT_RDMA;
-],[
-        AC_MSG_RESULT([yes])
-],[
-        AC_MSG_ERROR([no kernel rdma, sorry!])
-])
-])
-
-if test x$enable_rdma = xyes; then
-        AC_CHECK_LIB([rdmacm], [rdma_create_id], [],
-                     [AC_MSG_ERROR([cannot find ramdcm lib])])
-        AC_CHECK_LIB([ibverbs], [ibv_open_device], [],
-                     [AC_MSG_ERROR([cannot find ibverbs])])
-        AC_CHECK_HEADERS([rdma/rdma_cma.h infiniband/verbs.h],
-                         [AC_DEFINE([ENABLE_RDMA])],
-                         [AC_MSG_ERROR([cannot find rdma header files])])
-
-        if test x$OS = xlinux; then
-                COLIBRI_LINUX_RDMA
-        fi
+AC_CHECK_LIB([rdmacm], [rdma_create_id], [],
+             [AC_MSG_ERROR([cannot find ramdcm lib])])
+AC_CHECK_LIB([ibverbs], [ibv_open_device], [],
+             [AC_MSG_ERROR([cannot find ibverbs])])
+AC_CHECK_HEADERS([rdma/rdma_cma.h infiniband/verbs.h], [],
+                 [AC_MSG_ERROR([cannot find rdma header files])])
+if test x$OS = xlinux; then
+         AC_MSG_CHECKING([if kernel supports sunrpc over rdma])
+         COLIBRI_LINUX_TRY_COMPILE([
+                #include <linux/sunrpc/xprt.h>
+         ],[
+                int abc = XPRT_TRANSPORT_RDMA;
+         ],[
+                AC_MSG_RESULT([yes])
+         ],[
+                AC_MSG_ERROR([no kernel rdma, sorry!])
+         ])
 fi
 
 OLD_LIBS=$LIBS
diff --git a/fop/fop.c b/fop/fop.c
index 8711fc7..0e6e265 100644
--- a/fop/fop.c
+++ b/fop/fop.c
@@ -1,13 +1,23 @@
 /* -*- C -*- */
 
-#include "lib/cdefs.h"  /* C2_EXPORTED */
-#include "lib/memory.h"
-#include "lib/misc.h"   /* C2_SET0 */
-#include "lib/list.h"
-#include "lib/mutex.h"
-#include "lib/vec.h"
 #include "fop/fop.h"
-#include "fop/fop_iterator.h"
+
+#ifdef __KERNEL__
+
+#include "lib/kdef.h"
+
+#define xdr_void      NULL
+#define xdr_char      NULL
+#define xdr_uint32_t  NULL
+#define xdr_uint64_t  NULL
+#define c2_xdr_io_buf NULL
+
+#else /* __KERNEL__ */
+#include "lib/memory.h"
+#include "net/usunrpc/usunrpc.h" /* for c2_xdr_io_buf */
+#endif /* __KERNEL__ */
+
+
 
 /**
    @addtogroup fop
@@ -235,7 +245,7 @@ struct c2_fop_field_type C2_FOP_TYPE_U64 = {
 C2_EXPORTED(C2_FOP_TYPE_U64);
 
 struct c2_fop_memlayout atom_bulk_memlayout = {
-	.fm_uxdr   = (xdrproc_t)NULL,
+	.fm_uxdr   = (xdrproc_t)c2_xdr_io_buf,
 	.fm_sizeof = 0
 };
 
diff --git a/fop/fop2c.in b/fop/fop2c.in
index 42d2a35..788d9a5 100755
--- a/fop/fop2c.in
+++ b/fop/fop2c.in
@@ -128,6 +128,12 @@ EOF
         NULL
 };
 
+/* Kludge code to make compiler find c2_xdr_io_buf symbol for fop.o */
+bool_t c2_xdr_io_buf(XDR *xdrs, void *obj)
+{
+        return TRUE;
+}
+
 void prefix(void)
 {
 	printf("/* -*- C -*- */\n");
diff --git a/lib/refs.c b/lib/refs.c
index 146dad8..9eb9fdf 100644
--- a/lib/refs.c
+++ b/lib/refs.c
@@ -20,11 +20,3 @@ void c2_ref_put(struct c2_ref *ref)
                 ref->release(ref);
         }
 }
-C2_EXPORTED(c2_ref_put);
-
-uint64_t c2_ref_read(struct c2_ref *ref)
-{
-	return c2_atomic64_get(&ref->ref_cnt);
-}
-C2_EXPORTED(c2_ref_read);
-
diff --git a/lib/refs.h b/lib/refs.h
index e824d46..d851de6 100644
--- a/lib/refs.h
+++ b/lib/refs.h
@@ -51,16 +51,6 @@ void c2_ref_get(struct c2_ref *ref);
 */
 void c2_ref_put(struct c2_ref *ref);
 
-/**
- return the current refcount of c2_ref.
-
- @param ref pointer to c2_ref object
-
- @return current refcount 
-*/
-uint64_t c2_ref_read(struct c2_ref *ref);
-
-
 #endif
 /*
  *  Local variables:
diff --git a/lib/thread.h b/lib/thread.h
index 90fecec..017cbe5 100644
--- a/lib/thread.h
+++ b/lib/thread.h
@@ -162,6 +162,14 @@ int  c2_thread_init(struct c2_thread *q, int (*init)(void *),
 void c2_thread_fini(struct c2_thread *q);
 
 /**
+ check if the thread @param q is running
+ */
+static inline int c2_thread_is_running(struct c2_thread *q)
+{
+        return (q->t_state == TS_RUNNING);
+}
+
+/**
    Waits until the thread exits.
 
    After this calls returns successfully it is guaranteed that no code would be
diff --git a/lib/user_space/thread.c b/lib/user_space/thread.c
index d207adf..6023fb2 100644
--- a/lib/user_space/thread.c
+++ b/lib/user_space/thread.c
@@ -84,9 +84,6 @@ int c2_thread_join(struct c2_thread *q)
 {
 	int result;
 
-        if (q->t_state == TS_PARKED)
-                return 0;
-
 	C2_PRE(q->t_state == TS_RUNNING);
 	C2_PRE(!pthread_equal(q->t_h.h_id, pthread_self()));
 	result = pthread_join(q->t_h.h_id, NULL);
diff --git a/net/ksunrpc/ksunrpc.h b/net/ksunrpc/ksunrpc.h
index 534f913..6aca9ef 100644
--- a/net/ksunrpc/ksunrpc.h
+++ b/net/ksunrpc/ksunrpc.h
@@ -8,6 +8,8 @@
 #ifdef __KERNEL__
 #include <linux/in.h>
 #include <linux/sunrpc/sched.h> /* for rpc_call_ops */
+#include <linux/sunrpc/clnt.h>
+#endif
 
 struct c2_fop;
 struct ksunrpc_service_id;
@@ -30,9 +32,9 @@ struct ksunrpc_dom {
 struct ksunrpc_service_id {
 	char                 *ssi_host;	    /**< server hostname */
 	struct sockaddr_in   *ssi_sockaddr; /**< server ip_addr  */
-	int 	              ssi_addrlen;  /**< server ip_addr  */
+	int 	              ssi_addrlen;  /**< addrlen, why need this? */
 	uint16_t              ssi_port;     /**< server tcp port */
-        int                   ssi_trans;    /**< server transport */
+        enum xprt_transports  ssi_trans;    /**< server transport */
 };
 
 struct c2_fop;
diff --git a/net/usunrpc/Makefile.am b/net/usunrpc/Makefile.am
index e546159..f00fb96 100644
--- a/net/usunrpc/Makefile.am
+++ b/net/usunrpc/Makefile.am
@@ -1,10 +1,4 @@
-usunrpcdir                         = $(includedir)/net/usunrpc
-usunrpc_HEADERS                    = usunrpc.h usunrpc_internal.h
-
-SUBDIRS                            = .
-if ENABLE_RDMA
-SUBDIRS                           += rfc5666
-endif
+SUBDIRS                            = . rfc5666
 
 noinst_LTLIBRARIES                 = libcolibri-net-usunrpc.la
 libcolibri_net_usunrpc_la_SOURCES  = client.c server.c domain.c usunrpc.h \
diff --git a/net/usunrpc/rfc5666/svc_rdma.c b/net/usunrpc/rfc5666/svc_rdma.c
index b0c51c1..bc375a1 100644
--- a/net/usunrpc/rfc5666/svc_rdma.c
+++ b/net/usunrpc/rfc5666/svc_rdma.c
@@ -1718,13 +1718,10 @@ static void svcrdma_thread_modify(struct svcrndzv_xprt *xp, int fd, int is_add)
 /* ------------------ rdma async thread functions end --------------------*/
 
 /* ----------------- rdma context functions --------------*/
-static void rdma_context_free(struct c2_ref *ref)
+static void rdma_context_free(struct rdma_context *ctxt)
 {
-        struct rdma_context *ctxt;
-
-        ctxt = container_of(ref, struct rdma_context, refcnt);
         C2_ASSERT(c2_atomic64_get(&ctxt->holders) == 0);
-        C2_ASSERT(c2_ref_read(&ctxt->refcnt) == 0);
+        C2_ASSERT(c2_atomic64_get(&ctxt->refcnt) == 0);
         c2_cond_fini(&ctxt->cond);
         c2_mutex_fini(&ctxt->lock);
         c2_free(ctxt);
@@ -1749,7 +1746,7 @@ rdma_context_alloc(struct svcrdma_xprt *xprt, int nchunks,
           after we have finished all our work. */
         c2_atomic64_set(&ctxt->holders, 1);
         /* all holders share one refcnt; another is for ourself. */
-        c2_ref_init(&ctxt->refcnt, 2, rdma_context_free);
+        c2_atomic64_set(&ctxt->refcnt, 2);
         c2_cond_init(&ctxt->cond);
         c2_mutex_init(&ctxt->lock);
         ctxt->xprt       = xprt;
@@ -1764,18 +1761,21 @@ rdma_context_alloc(struct svcrdma_xprt *xprt, int nchunks,
 
 static void rdma_context_get(struct rdma_context *ctxt)
 {
-        c2_ref_get(&ctxt->refcnt);
+        c2_atomic64_inc(&ctxt->refcnt);
 }
 
 static void rdma_context_put(struct rdma_context *ctxt)
 {
-        c2_ref_put(&ctxt->refcnt);
+        if (c2_atomic64_dec_and_test(&ctxt->refcnt)) {
+                C2_ASSERT(c2_atomic64_get(&ctxt->holders) == 0);
+                rdma_context_free(ctxt);
+        }
 }
 
 static void rdma_context_hold(struct rdma_context *ctxt)
 {
         C2_ASSERT(c2_atomic64_get(&ctxt->holders) > 0);
-        C2_ASSERT(c2_ref_read(&ctxt->refcnt) > 0);
+        C2_ASSERT(c2_atomic64_get(&ctxt->refcnt) > 0);
         c2_atomic64_inc(&ctxt->holders);
 }
 
@@ -1806,7 +1806,7 @@ static void rdma_complete_one(struct rdma_context *ctxt,
                               enum ibv_wc_status rc)
 {
         C2_ASSERT(c2_atomic64_get(&ctxt->holders) > 0);
-        C2_ASSERT(c2_ref_read(&ctxt->refcnt) > 0);
+        C2_ASSERT(c2_atomic64_get(&ctxt->refcnt) > 0);
 
         rdma_context_get(ctxt);
         if (rc != IBV_WC_SUCCESS) {
@@ -1825,7 +1825,7 @@ static void rdma_complete_one(struct rdma_context *ctxt,
 static int rdma_wait_for_completion(struct rdma_context *ctxt)
 {
         C2_ASSERT(c2_atomic64_get(&ctxt->holders) > 0);
-        C2_ASSERT(c2_ref_read(&ctxt->refcnt) > 1);
+        C2_ASSERT(c2_atomic64_get(&ctxt->refcnt) > 1);
         c2_mutex_lock(&ctxt->lock);
         if (rdma_context_drop(ctxt))
                 c2_cond_wait(&ctxt->cond, &ctxt->lock);
diff --git a/net/usunrpc/rfc5666/svc_rdma_internal.h b/net/usunrpc/rfc5666/svc_rdma_internal.h
index 06010ac..9af4b65 100644
--- a/net/usunrpc/rfc5666/svc_rdma_internal.h
+++ b/net/usunrpc/rfc5666/svc_rdma_internal.h
@@ -414,7 +414,7 @@ enum {
   in this way, it's easy to cleanup things after an rdma write/send finishes.
  */
 struct rdma_context {
-        struct c2_ref        refcnt;
+        struct c2_atomic64   refcnt;
         struct c2_atomic64   holders;
         struct c2_mutex      lock;
         struct c2_cond       cond;
diff --git a/net/usunrpc/server.c b/net/usunrpc/server.c
index 9a22ced..21a85c9 100644
--- a/net/usunrpc/server.c
+++ b/net/usunrpc/server.c
@@ -32,10 +32,7 @@
 
 #include "usunrpc.h"
 #include "usunrpc_internal.h"
-
-#ifdef ENABLE_RDMA
 #include "rfc5666/svc_rdma.h"
-#endif
 
 /**
    @addtogroup usunrpc User Level Sun RPC
@@ -370,7 +367,6 @@ out:
 static int usunrpc_start_svcrdma(struct c2_service *service,
                                  struct usunrpc_service_id *xid)
 {
-#ifdef ENABLE_RDMA
         struct usunrpc_service *xservice;
         struct svcrdma_config   cfg = {
                 .max_msg_size    = sysconf(_SC_PAGESIZE),
@@ -394,9 +390,6 @@ static int usunrpc_start_svcrdma(struct c2_service *service,
 
 	c2_dbuf_xdrproc_set(xdr_rdma_chunks);
         return 0;
-#else
-        return -EOPNOTSUPP;
-#endif
 }
 
 static int usunrpc_start_svcudp(struct c2_service *service,
@@ -538,7 +531,7 @@ static void usunrpc_service_stop(struct usunrpc_service *xs)
 	if (xs->s_workers != NULL) {
 		for (i = 0; i < xs->s_nr_workers; i++) {
 			thr = &xs->s_workers[i];
-			if (thr->t_func != NULL) {
+			if (c2_thread_is_running(thr)) {
 				c2_thread_join(thr);
 				c2_thread_fini(thr);
 			}
@@ -547,8 +540,8 @@ static void usunrpc_service_stop(struct usunrpc_service *xs)
 		xs->s_workers = NULL;
 	}
 
-	if (xs->s_scheduler_thread.t_func != NULL) {
-		/*
+	if (c2_thread_is_running(&xs->s_scheduler_thread)) {
+		/* 
 		 * Wait until scheduler sees the shutdown and exits. This might
 		 * wait for select(2) timeout. See
 		 * sunrpc_scheduler(). Alternatively, use a signal to kill
diff --git a/net/usunrpc/usunrpc.h b/net/usunrpc/usunrpc.h
index a33fb48..852ce54 100644
--- a/net/usunrpc/usunrpc.h
+++ b/net/usunrpc/usunrpc.h
@@ -20,6 +20,7 @@ bool_t c2_fop_type_uxdr(const struct c2_fop_field_type *ftype,
 bool_t c2_fop_uxdrproc(XDR *xdrs, struct c2_fop *fop);
 int usunrpc_init(void);
 void usunrpc_fini(void);
+bool_t c2_xdr_io_buf  (XDR *xdrs, void *obj);
 void   c2_dbuf_xdrproc_set(bool_t (*)(XDR *, void *, int));
 
 /** @} end of group usunrpc */
diff --git a/net/usunrpc/usunrpc_internal.h b/net/usunrpc/usunrpc_internal.h
index a4882a8..f902974 100644
--- a/net/usunrpc/usunrpc_internal.h
+++ b/net/usunrpc/usunrpc_internal.h
@@ -65,7 +65,7 @@ static inline bool udom_is_shutting(const struct c2_net_domain *dom)
 	return ((struct usunrpc_dom *)dom->nd_xprt_private)->sd_shutown;
 }
 
-enum {
+enum usunrpc_transport {
         USUNRPC_TRANS_TCP  = 0,
         USUNRPC_TRANS_UDP  = 1,
         USUNRPC_TRANS_RDMA = 2,
@@ -83,7 +83,7 @@ struct usunrpc_service_id {
 	uint16_t              ssi_port;     /**< server tcp port */
 	uint32_t              ssi_prog;     /**< server program number */
 	uint32_t              ssi_ver;      /**< server program version */
-        uint32_t              ssi_trans;    /**< trans type, TCP, RDMA etc */
+        enum usunrpc_transport ssi_trans;   /**< trans type, TCP, RDMA etc */
 };
 
 int  usunrpc_server_init(void);
diff --git a/net/usunrpc/uxdr.c b/net/usunrpc/uxdr.c
index 8e069ef..32bea77 100644
--- a/net/usunrpc/uxdr.c
+++ b/net/usunrpc/uxdr.c
@@ -47,8 +47,6 @@
 /*
  * User level xdr code.
  */
-static bool_t c2_xdr_io_buf(XDR *xdrs, void *obj);
-
 static const xdrproc_t atom_xdr[FPF_NR] = {
 	[FPF_VOID] = (xdrproc_t)&xdr_void,
 	[FPF_BYTE] = NULL,
@@ -60,15 +58,8 @@ static const xdrproc_t atom_xdr[FPF_NR] = {
 static xdrproc_t ftype_field_xdr(const struct c2_fop_field_type *ftype,
 				 int fieldno)
 {
-        struct c2_fop_field_type *chd;
-        xdrproc_t xdrproc;
-
 	C2_ASSERT(fieldno < ftype->fft_nr);
-        chd = ftype->fft_child[fieldno]->ff_type;
-        xdrproc = chd->fft_layout->fm_uxdr;
-        if (xdrproc == NULL && chd->fft_aggr == FFA_ATOM)
-                xdrproc = atom_xdr[chd->fft_u.u_atom.a_type];
-	return xdrproc;
+        return ftype->fft_child[fieldno]->ff_type->fft_layout->fm_uxdr;
 }
 
 static bool ftype_subxdr(const struct c2_fop_field_type *ftype,
@@ -174,7 +165,7 @@ void c2_dbuf_xdrproc_set(dbuf_xdrproc_t xdrproc)
         dbuf_xdrproc = xdrproc;
 }
 
-static bool_t c2_xdr_io_buf(XDR *xdrs, void *obj)
+bool_t c2_xdr_io_buf(XDR *xdrs, void *obj)
 {
         struct c2_io_buf *dbuf = obj;
         dbuf_xdrproc_t *xdrproc = dbuf_xdrproc;
-- 
1.8.3.2

