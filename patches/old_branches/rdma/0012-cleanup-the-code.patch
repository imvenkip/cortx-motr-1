From 49f7c10340c4a871653a1902bd688b2f917a77c3 Mon Sep 17 00:00:00 2001
From: "jinshan.xiong" <jinshan.xiong@clusterstor.com>
Date: Thu, 22 Jul 2010 16:33:49 -0600
Subject: [PATCH 12/34] - cleanup the code.

---
 lib/refs.c                              |   9 +-
 lib/refs.h                              |   4 +-
 net/usunrpc/rfc5666/rfc5666.h           |   3 +-
 net/usunrpc/rfc5666/svc_rdma.c          | 304 ++++++++++++++++++++------------
 net/usunrpc/rfc5666/svc_rdma.h          |   2 +-
 net/usunrpc/rfc5666/svc_rdma_internal.h |  11 +-
 net/usunrpc/rfc5666/xdr_rdma.c          |  19 --
 7 files changed, 207 insertions(+), 145 deletions(-)
 delete mode 100644 net/usunrpc/rfc5666/xdr_rdma.c

diff --git a/lib/refs.c b/lib/refs.c
index 8c169db..0451898 100644
--- a/lib/refs.c
+++ b/lib/refs.c
@@ -14,11 +14,14 @@ void c2_ref_get(struct c2_ref *ref)
 }
 C2_EXPORTED(c2_ref_get);
 
-void c2_ref_put(struct c2_ref *ref)
+int c2_ref_put(struct c2_ref *ref)
 {
-	if (c2_atomic64_dec_and_test(&ref->ref_cnt)) {
+        int ret = c2_atomic64_sub_return(&ref->ref_cnt, 1);
+
+        C2_ASSERT(ret >= 0);
+	if (ret == 0 && ref->release)
 		ref->release(ref);
-	}
+        return ret;
 }
 C2_EXPORTED(c2_ref_put);
 
diff --git a/lib/refs.h b/lib/refs.h
index 81e9ef1..b059f63 100644
--- a/lib/refs.h
+++ b/lib/refs.h
@@ -47,9 +47,9 @@ void c2_ref_get(struct c2_ref *ref);
 
  @param ref pointer to c2_ref object
 
- @return none
+ @return refcount after descreased
 */
-void c2_ref_put(struct c2_ref *ref);
+int c2_ref_put(struct c2_ref *ref);
 
 /**
  return the current refcount of c2_ref.
diff --git a/net/usunrpc/rfc5666/rfc5666.h b/net/usunrpc/rfc5666/rfc5666.h
index a005ea4..382c934 100644
--- a/net/usunrpc/rfc5666/rfc5666.h
+++ b/net/usunrpc/rfc5666/rfc5666.h
@@ -62,7 +62,8 @@ struct rdma_header_padded {
 };
 
 enum rdma_errcode {
-        RDMA_ERR_VERS = 1,
+        RDMA_OK        = 0,
+        RDMA_ERR_VERS  = 1,
         RDMA_ERR_CHUNK = 2,
 };
 
diff --git a/net/usunrpc/rfc5666/svc_rdma.c b/net/usunrpc/rfc5666/svc_rdma.c
index f844948..abbb5ec 100644
--- a/net/usunrpc/rfc5666/svc_rdma.c
+++ b/net/usunrpc/rfc5666/svc_rdma.c
@@ -13,11 +13,11 @@ static void svcrdma_buffer_destroy(struct svcrdma_xprt *xprt);
 static int rdma_recv_completion(struct svcrdma_xprt *xprt,
                                 struct ibv_wc *wc,
                                 struct rpc_msg *rpcmsg);
-static void rdma_completion_one(struct rdma_context *ctxt);
+static void rdma_completion_one(struct rdma_context *ctxt, enum ibv_wc_status);
 static void rdma_fixup_write_chunks(struct rdma_reply *reply);
-static void svcrdma_repost_recv(struct rdma_request *req);
+static void rdma_repost_req(struct rdma_request *req);
 static int rdma_send_reply(struct rdma_reply *reply);
-static void svcrdma_put_reply(struct rdma_reply *reply);
+static void rdma_put_reply(struct rdma_reply *reply);
 static struct rdma_reply *svcrdma_get_reply(struct svcrdma_xprt *xprt);
 static int rdma_read_chunks(struct rdma_request *req, char *buffer, int buflen);
 
@@ -45,13 +45,6 @@ static enum xprt_stat rendezvous_stat (SVCXPRT *);
 static void rendezvous_abort (void) __attribute__ ((__noreturn__));
 static void rendezvous_destroy(SVCXPRT *xprt);
 
-/* This function makes sure abort() relocation goes through PLT
-   and thus can be lazy bound.  */
-static void rendezvous_abort (void)
-{
-        abort ();
-};
-
 static const struct xp_ops svcrdma_rendezvous_op = {
         rendezvous_request,
         rendezvous_stat,
@@ -274,7 +267,7 @@ static bool_t rendezvous_request (SVCXPRT *xprt, struct rpc_msg *errmsg)
         if (rdma_get_cm_event(xp->channel, &ev)) {
                 svcrdma_errx("get_cm_event error\n");
                 /* what can I do? */
-                abort();
+                svcrdma_assert(0);
         }
 
         /* disconnect is special, handle it first. */
@@ -285,7 +278,6 @@ static bool_t rendezvous_request (SVCXPRT *xprt, struct rpc_msg *errmsg)
                 svcrdma_assert(xprt != NULL);
 
                 (void)rdma_ack_cm_event(ev);
-                c2_list_del(&xprt->link);
                 if (xprt->svcxprt.xp_p1 == (caddr_t)xprt)
                         xprt_unregister(&xprt->svcxprt);
                 svcrdma_xprt_destroy(xprt);
@@ -349,6 +341,13 @@ static enum xprt_stat svcrdma_stat (SVCXPRT *xprt)
         return XPRT_IDLE;
 }
 
+/* This function makes sure abort() relocation goes through PLT
+   and thus can be lazy bound.  */
+static void rendezvous_abort (void)
+{
+        svcrdma_assert(0);
+};
+
 /**
  * svcrdma_recv() will be called whenever a new request is pending on the
  * completion channel. This means a send wr has been finished, or recv wr
@@ -367,17 +366,10 @@ static bool_t svcrdma_recv (SVCXPRT *xprt, struct rpc_msg *msg)
                 return FALSE;
         }
 
-        if (ecq != xp->cq || ectx != xp) {
-                svcrdma_errx("wrong context has %p/%p, expect %p/%p",
-                             ecq, ectx, xp->cq, xp);
-                rc = 1;
-        }
-
+        svcrdma_assert(ecq == xp->cq && ectx == xp);
         if (ibv_req_notify_cq(xp->cq, 0))
                 svcrdma_errx("failed to set up notification");
         ibv_ack_cq_events(xp->cq, 1);
-        if (rc)
-                return FALSE;
 
         /* handle all events which are pending on this transport.
          * this may cause fairness and starvation problem since we have a
@@ -407,15 +399,19 @@ static bool_t svcrdma_recv (SVCXPRT *xprt, struct rpc_msg *msg)
                         break;
                 case IBV_WC_SEND:
                 case IBV_WC_RDMA_READ:
-                case IBV_WC_RDMA_WRITE:
+                case IBV_WC_RDMA_WRITE: {
+                        struct rdma_context *ctxt;
+
                         /* XXX: impossible to get this event from here because
                          * RDMA event handling is sync. */
                         svcrdma_assert(0);
-                        rdma_completion_one((struct rdma_context *)wc.wr_id);
+                        ctxt = (struct rdma_context *)wc.wr_id;
+                        rdma_completion_one(ctxt, wc.status);
                         break;
+                }
                 default:
-                        svcrdma_errx("unknown opcode(%d) of completion event %lx",
-                                 wc.opcode, wc.wr_id);
+                        svcrdma_errx("unknown opcode(%d) of cq event %lx",
+                                     wc.opcode, wc.wr_id);
                         break;
                 }
         } /* while (1) */
@@ -454,7 +450,6 @@ static bool_t svcrdma_reply(SVCXPRT *svcxprt, struct rpc_msg *rpcmsg)
         int bufsize = xprt->rndzv->max_msg_size;
         struct rdma_request *req;
         struct rdma_reply *reply;
-        struct svcrdma_msg   *msg;
         XDR xdrs;
         bool_t rc;
 
@@ -463,67 +458,24 @@ static bool_t svcrdma_reply(SVCXPRT *svcxprt, struct rpc_msg *rpcmsg)
         svcrdma_assert(xprt->curreq != NULL);
         req = xprt->curreq;
         reply = req->reply;
-        reply->msg = req->msg;
-        msg = &reply->msg;
+        req->reply = NULL;
 
-        /* initiate the write list so that RDMA chunk write works. */
-        reply->writes = req->writes;
-        reply->writes_index = 0;
+        /* anyway, free request first */
+        rdma_repost_req(req);
 
+        rpcmsg->rm_xid = reply->xid;
         xdrmem_create(&xdrs, reply->rpc_buf, bufsize, XDR_ENCODE);
-        msg->rdma_xid = reply->msg.rdma_xid;
         if (!xdr_replymsg(&xdrs, rpcmsg)) {
                 /* this is probably because of not having enough buffer space */
                 return FALSE;
         }
         reply->rpc_buflen = XDR_GETPOS(&xdrs);
 
-        /* By rfc5666, the write chunks must have precise bytes it filled */
-        rdma_fixup_write_chunks(reply);
-
-        msg->rdma_vers = RDMA_VERS;
-        /* always 1 right now since we do not support async sunrpc request.
-         * Please notice that from rfc5666, if there is no outstanding request
-         * from a specific client, the credit must be at least 1 to prevent
-         * it from deadlocking. */
-        msg->rdma_credit = 1;
-
-        /* prepare to encode rdma chunks information */
-        {
-                /* assuming RDMA_MSG, will be fixed when actually composing
-                 * the message; it may be RDMA_NOMSG in case rpc message
-                 * is too long to send by RDMA send/recv */
-                struct rdma_header_msg *rdma_msg;
-
-                msg->rdma_body.rdma_proc = RDMA_MSG;
-                rdma_msg = &msg->rdma_body.u.rdma_msg;
-                rdma_msg->rdma_reads = NULL;
-                rdma_msg->rdma_writes = req->writes;
-                rdma_msg->rdma_reply = NULL;
-        }
-        
-        xdrmem_create(&xdrs, reply->rdma_buf, bufsize, XDR_ENCODE);
-        if (!xdr_svcrdma_msg(&xdrs, msg)) {
-                /* impossible! the bufsize is not enough for even rdma
-                 * chunks - this is not my fault :-) */
-                svcrdma_assert(0);
-        }
-        reply->rdma_buflen = XDR_GETPOS(&xdrs);
-
-        if (reply->rdma_buflen + reply->rpc_buflen > bufsize) {
-                /* we need to fill in reply chunk and redo encoding. */
-                /* TODO: fill in reply chunk */
-                svcrdma_assert(0);
-        }
-
-        /* anyway, c2_free request first */
-        svcrdma_repost_recv(req);
-
         /* it looks all right, post reply buffer */
         rc = rdma_send_reply(reply);
         if (rc) {
                 /* if error, reply is not freed */
-                svcrdma_put_reply(reply);
+                rdma_put_reply(reply);
                 return FALSE;
         }
         return TRUE;
@@ -694,13 +646,18 @@ out:
         return rc;
 }
 
-static void svcrdma_put_reply(struct rdma_reply *reply)
+static void rdma_put_reply(struct rdma_reply *reply)
 {
         struct svcrdma_xprt *xprt = reply->xprt;
+        XDR xdrs;
+
+        xdrmem_create(&xdrs, NULL, 0, XDR_FREE);
+        (void)xdr_svcrdma_msg(&xdrs, &reply->msg);
 
         c2_mutex_lock(&xprt->bufs_mutex);
         reply->next = xprt->snd_bufs;
         xprt->snd_bufs = reply;
+        c2_list_del(&reply->link);
         c2_mutex_unlock(&xprt->bufs_mutex);
 }
 
@@ -712,17 +669,22 @@ static struct rdma_reply *svcrdma_get_reply(struct svcrdma_xprt *xprt)
         reply = xprt->snd_bufs;
         if (reply)
                 xprt->snd_bufs = reply->next;
+        c2_list_add(&xprt->replies, &reply->link);
         c2_mutex_unlock(&xprt->bufs_mutex);
 
         return reply;
 }
 
-static void svcrdma_repost_recv(struct rdma_request *req)
+static void rdma_repost_req(struct rdma_request *req)
 {
         struct ibv_recv_wr *badwr;
         int rc;
 
-        req->reply = NULL;
+        c2_mutex_lock(&req->xprt->bufs_mutex);
+        c2_list_del(&req->link);
+        c2_mutex_unlock(&req->xprt->bufs_mutex);
+
+        svcrdma_assert(req->reply == NULL);
         xdrmem_create(&req->xdrs, NULL, 0, XDR_FREE);
         xdr_svcrdma_msg(&req->xdrs, &req->msg);
         rc = ibv_post_recv(req->xprt->qp, &req->wr, &badwr);
@@ -733,12 +695,15 @@ static void svcrdma_repost_recv(struct rdma_request *req)
 /**
  * Handle receive event from this transport.
  * An rpc is coming, the content of rpc message has already been in buffer.
+ *
+ * return a non-zero # means error.
  */
 static int rdma_recv_completion(struct svcrdma_xprt *xprt,
                                 struct ibv_wc *wc,
                                 struct rpc_msg *rpcmsg)
 {
         struct rdma_request *req;
+        struct rdma_reply   *reply;
         struct svcrdma_msg *msg;
         struct ibv_recv_wr *badwr;
         XDR                 xdrs;
@@ -748,7 +713,7 @@ static int rdma_recv_completion(struct svcrdma_xprt *xprt,
 
         svcrdma_assert(wc->opcode == IBV_WC_RECV);
         req = (struct rdma_request *)wc->wr_id;
-        req->xprt = xprt;
+        svcrdma_assert(req->xprt == xprt);
 
         /* handle error message first */
         if (wc->status != IBV_WC_SUCCESS) {
@@ -756,6 +721,7 @@ static int rdma_recv_completion(struct svcrdma_xprt *xprt,
                 rc = ibv_post_recv(xprt->qp, &req->wr, &badwr);
                 if (rc)
                         svcrdma_errx("fatal error on registering recv buffer");
+                return rc;
         }
 
         
@@ -771,23 +737,33 @@ static int rdma_recv_completion(struct svcrdma_xprt *xprt,
         svcrdma_assert(xprt->curreq == NULL);
         svcrdma_assert(req->reply == NULL);
         xprt->curreq = req;
+        c2_mutex_lock(&xprt->bufs_mutex);
         c2_list_add(&xprt->requests, &xprt->link);
-        req->reply = svcrdma_get_reply(xprt);
-        if (req->reply == NULL) {
-                svcrdma_errx("fatal error: no reply buffer available\n");
-                abort();
-        }
+        c2_mutex_unlock(&xprt->bufs_mutex);
+
+        reply = svcrdma_get_reply(xprt);
+        svcrdma_assert(reply != NULL);
+        reply->xid         = 0;
+        reply->rdma_buflen = 0;
+        reply->rpc_buflen  = 0;
+        reply->errcode     = RDMA_OK;
+        reply->orig_writes = NULL;
+        reply->writes      = NULL;
+        reply->reply       = NULL;
 
+        msg = &req->msg;
         xdrmem_create(&xdrs, req->buffer, reqlen, XDR_DECODE);
-        if (xdr_svcrdma_msg(&xdrs, &req->msg)) {
-                svcrdma_errx("message corrupted, decode rfc5666 failed");
+        if (xdr_svcrdma_msg(&xdrs, msg)) {
+                svcrdma_errx("message corrupted, decode rdma header failed");
+                reply->xid = msg->rdma_xid; /* XXX: XID still wasn't decoded? */
                 rc = RDMA_ERR_CHUNK;
                 goto out;
         }
         pos = XDR_GETPOS(&xdrs);
         svcrdma_assert(pos <= reqlen);
+        reply->xid = msg->rdma_xid;
 
-        /* sanity check */
+        /* version check */
         msg = &req->msg;
         if (msg->rdma_vers != RDMA_VERS) {
                 svcrdma_errx("version mismatched, %d/%d",
@@ -834,11 +810,13 @@ static int rdma_recv_completion(struct svcrdma_xprt *xprt,
                 }
                 break;
         }
+        case RDMA_MSGP:
+                /* padded message, not support */
+                /* fall through */
         case RDMA_DONE:
                 /* reply chunk finished, not support */
                 svcrdma_assert(0);
                 break;
-        case RDMA_MSGP:
         case RDMA_ERROR:
         default:
                 /* TODO: destroy the export */
@@ -862,33 +840,39 @@ static int rdma_recv_completion(struct svcrdma_xprt *xprt,
                 }
         }
 
+        /* initiate reply message */
+        reply->orig_writes = reply->writes = req->writes;
+        reply->writes_index = 0;
+        req->writes = NULL;
+        req->reply  = reply;
+
         /* the header of RDMA chunks looks fine, just set the XDR stream */
         xdrmem_create(&req->xdrs, req->rpcbuf_base, req->rpcbuf_len,
-                       XDR_DECODE);
+                      XDR_DECODE);
         req->xdrs.x_public = (void *)req;
         return 0;
 
 out:
-        /* TODO: error handling needs reworking. */
+        /* anyway, free request first */
+        rdma_repost_req(req);
         if (rc > 0) { /* something wrong */
-#if 0
-                reply_msg->rdma_body.proc = RDMA_ERROR;
-                reply_msg->rdma_body.u.rdma_error.errcode = rc;
-#endif
+                reply->errcode = rc;
+                rdma_send_reply(reply);
+                rdma_put_reply(reply);
         }
-        /* TODO: free request message and compose an reply message */
         return rc;
 }
 
-static void rdma_completion(struct c2_ref *);
 static void rdma_context_init(struct rdma_context *ctxt,
                               struct svcrdma_xprt *xprt,
                               void (*comp)(struct rdma_context *, void *),
                               void *ctx)
 {
+        svcrdma_assert(comp != NULL);
         memset(ctxt, 0, sizeof *ctxt);
-        c2_ref_init(&ctxt->ref, 0, rdma_completion);
+        c2_ref_init(&ctxt->ref, 0, NULL);
         ctxt->xprt       = xprt;
+        ctxt->status     = IBV_WC_SUCCESS;
         ctxt->completion = comp;
         ctxt->ctx        = ctx;
         ctxt->index      = 0;
@@ -905,18 +889,20 @@ static void rdma_completion_rw(struct rdma_context *ctxt, void *unused)
         ctxt->index = 0;
 }
 
-static void rdma_completion(struct c2_ref *ref)
+static void rdma_completion_one(struct rdma_context *ctxt,
+                                enum ibv_wc_status rc)
 {
-        struct rdma_context *ctxt = container_of(ref, struct rdma_context, ref);
+        if (rc != IBV_WC_SUCCESS) {
+                if (ctxt->status == IBV_WC_SUCCESS)
+                        ctxt->status = rc;
 
-        if (ctxt->completion)
+                svcrdma_errx("ctxt(%p) cq error %s\n",
+                             ctxt, ibv_wc_status_str(rc));
+        }
+        if (c2_ref_put(&ctxt->ref) == 0) {
                 ctxt->completion(ctxt, ctxt->ctx);
-        /* TODO: in multiple thread env, we then wake handling thread up. */
-}
-
-void rdma_completion_one(struct rdma_context *ctxt)
-{
-        c2_ref_put(&ctxt->ref);
+                /* TODO: need to wake up threads in multiple thread env */
+        }
 }
 
 static int rdma_wait_for_completion(struct rdma_context *ctxt)
@@ -942,6 +928,7 @@ again:
         if (ibv_req_notify_cq(xprt->cq, 0))
                 svcrdma_errx("failed to set up notification");
         ibv_ack_cq_events(xprt->cq, 1);
+
         while (1) {
                 rc = ibv_poll_cq(xprt->cq, 1, &wc);
                 if (rc == 0) {         /* no event pending any more */
@@ -953,13 +940,8 @@ again:
 
                 ncount--;
                 svcrdma_assert(rc == 1);
-                if (wc.status != IBV_WC_SUCCESS) {
-                        svcrdma_errx("cq error %s\n", ibv_wc_status_str(rc));
-                        rc = -1;
-                        break;
-                }
                 svcrdma_assert(wc.wr_id == (uint64_t)ctxt);
-                rdma_completion_one(ctxt);
+                rdma_completion_one(ctxt, wc.status);
         }
         if (rc == 0 && ncount)
                 goto again;
@@ -968,7 +950,8 @@ again:
 
 static struct ibv_mr *do_rdma_post(struct rdma_context *ctxt,
                                    struct rdma_segment *seg,
-                                   char *buffer, enum ibv_wr_opcode opc)
+                                   char *buffer,
+                                   enum ibv_wr_opcode opc)
 {
         struct ibv_sge sge = {
                 .addr   = (uint64_t)buffer,
@@ -979,7 +962,7 @@ static struct ibv_mr *do_rdma_post(struct rdma_context *ctxt,
                 .sg_list    = &sge,
                 .num_sge    = 1,
                 .opcode     = opc,
-                .send_flags = 0, /* IBV_SEND_SIGNALED; */
+                .send_flags = IBV_SEND_SIGNALED,
                 .wr = {
                         .rdma = {
                                 .remote_addr = seg->rs_offset,
@@ -1029,6 +1012,7 @@ static int rdma_read_chunks(struct rdma_request *req, char *buffer, int buflen)
 
         ctxt = alloca(sizeof(*ctxt));
         rdma_context_init(ctxt, req->xprt, rdma_completion_rw, (void *)req);
+
         rl= req->reads;
         while (rl && buflen) {
                 seg = &rl->rrl_entry.rrc_target;
@@ -1191,21 +1175,90 @@ static void rdma_fixup_write_chunks(struct rdma_reply *reply)
         }
 }
 
+static int rdma_encode_reply(struct rdma_reply *reply)
+{
+        struct svcrdma_msg *msg = &reply->msg;
+        int bufsize;
+        XDR xdrs;
+
+        memset(msg, 0, sizeof(*msg));
+        msg->rdma_xid  = reply->xid;
+        msg->rdma_vers = RDMA_VERS;
+        /* always 1 right now since we do not support async sunrpc request.
+         * Please notice that from rfc5666, if there is no outstanding request
+         * from a specific client, the credit must be at least 1 to prevent
+         * it from deadlocking. */
+        msg->rdma_credit = 1;
+
+        if (reply->errcode != RDMA_OK) {
+                /* encode a RDMA_ERROR message. */
+                svcrdma_assert(reply->writes == NULL);
+                svcrdma_assert(reply->reply == NULL);
+                msg->rdma_body.rdma_proc = RDMA_ERROR;
+                msg->rdma_body.u.rdma_error.errcode = reply->errcode;
+                if (reply->errcode == RDMA_ERR_VERS) {
+                        struct rdma_vers_error *err;
+                        err = &msg->rdma_body.u.rdma_error.u.rdma_vers;
+                        err->rdma_vers_low = RDMA_VERS;
+                        err->rdma_vers_high = RDMA_VERS;
+                }
+        } else {
+                /* By rfc5666, the write chunks must have precise bytes it
+                   filled */
+                rdma_fixup_write_chunks(reply);
+
+                /* prepare to encode rdma chunks information */
+                {
+                        /* assuming RDMA_MSG, will be fixed when actually
+                           composing the message; it may be RDMA_NOMSG in case
+                           rpc message is too long to send by RDMA send/recv */
+                        struct rdma_header_msg *rdma_msg;
+
+                        msg->rdma_body.rdma_proc = RDMA_MSG;
+                        rdma_msg = &msg->rdma_body.u.rdma_msg;
+                        rdma_msg->rdma_reads = NULL;
+                        rdma_msg->rdma_writes = reply->orig_writes;
+                        rdma_msg->rdma_reply = NULL;
+                }
+        }
+
+        bufsize = reply->xprt->rndzv->max_msg_size;
+        xdrmem_create(&xdrs, reply->rdma_buf, bufsize, XDR_ENCODE);
+        if (!xdr_svcrdma_msg(&xdrs, msg)) {
+                /* impossible! the bufsize is not enough for even rdma
+                 * chunks - this is not my fault :-) */
+                svcrdma_assert(0);
+        }
+        reply->rdma_buflen = XDR_GETPOS(&xdrs);
+
+        if (reply->rdma_buflen + reply->rpc_buflen > bufsize) {
+                /* we need to fill in reply chunk and redo encoding. */
+                /* TODO: fill in reply chunk */
+                svcrdma_assert(0);
+        }
+
+        return 0;
+}
+
 static void rdma_reply_completion(struct rdma_context *ctxt, void *args)
 {
-        svcrdma_put_reply((struct rdma_reply *)args);
+        rdma_put_reply((struct rdma_reply *)args);
         ctxt->index = 0;
 }
 
 static int rdma_send_reply(struct rdma_reply *reply)
 {
         struct rdma_context *ctxt;
-        struct ibv_sge sge[2];
-        struct ibv_send_wr wr;
-        struct ibv_send_wr *badwr;
+        struct ibv_sge       sge[2];
+        struct ibv_send_wr   wr;
+        struct ibv_send_wr  *badwr;
         int nr_sges = 1;
         int rc;
 
+        rc = rdma_encode_reply(reply);
+        if (rc)
+                return rc;
+
         svcrdma_assert(reply->rdma_buflen != 0);
         sge[0].addr   = (uint64_t)reply->rdma_buf;
         sge[0].length = reply->rdma_buflen;
@@ -1237,4 +1290,23 @@ static int rdma_send_reply(struct rdma_reply *reply)
         return rc;
 }
 
+/**
+  This is the callback function of xdr_dbuf().
+ */
+bool_t xdr_rdma_chunks(XDR *xdrs, char *buffer, int buflen)
+{
+        int rc;
+
+        svcrdma_assert(xdrs->x_op == XDR_ENCODE || xdrs->x_op == XDR_DECODE);
+        if (xdrs->x_op == XDR_DECODE) {
+                struct rdma_request *req;
+                req = (struct rdma_request *)xdrs->x_public;
+                rc = rdma_read_chunks(req, buffer, buflen);
+        } else {
+                struct rdma_reply *reply;
+                reply = (struct rdma_reply *)xdrs->x_public;
+                rc = rdma_write_chunks(reply, buffer, buflen);
+        }
 
+        return rc == 0 ? TRUE : FALSE;
+}
diff --git a/net/usunrpc/rfc5666/svc_rdma.h b/net/usunrpc/rfc5666/svc_rdma.h
index 86ef2b3..2a43a6c 100644
--- a/net/usunrpc/rfc5666/svc_rdma.h
+++ b/net/usunrpc/rfc5666/svc_rdma.h
@@ -36,7 +36,7 @@ struct svcrdma_config {
  */
 SVCXPRT *svcrdma_create(struct sockaddr_in *sa, struct svcrdma_config *cfg);
 /**
-  a standard xdr function for c2_dbuf in rdma case.
+  the callback function of xdr_dbuf().
  */
 bool_t   xdr_rdma_chunks(XDR *xdrs, char *buffer, int buflen);
 
diff --git a/net/usunrpc/rfc5666/svc_rdma_internal.h b/net/usunrpc/rfc5666/svc_rdma_internal.h
index 7667762..ddff91e 100644
--- a/net/usunrpc/rfc5666/svc_rdma_internal.h
+++ b/net/usunrpc/rfc5666/svc_rdma_internal.h
@@ -121,7 +121,7 @@
  */
 
 /** RFC5666 has only version 1 supported. */
-#define RDMA_VERS       (htons(1))
+#define RDMA_VERS       1
 
 enum rdma_xprt_status {
         RDMA_XPRT_INIT   = 0, /**< init state */
@@ -197,6 +197,8 @@ struct svcrdma_xprt {
         SVCXPRT               svcxprt;
         struct svcrndzv_xprt *rndzv;
         struct rdma_cm_id    *cmid;
+        struct c2_mutex       bufs_mutex; /**< mutex to protect allocation
+                                                   and free of bufs */
 
         /**
            queue pair information.
@@ -216,8 +218,6 @@ struct svcrdma_xprt {
          */
         struct rdma_request      *rcv_bufs;
         struct rdma_reply        *snd_bufs;
-        struct c2_mutex           bufs_mutex; /**< mutex to protect allocation
-                                                   and free of bufs */
 
         /**
           the following information records the requests and replies this
@@ -257,10 +257,14 @@ struct rdma_reply {
 
         struct c2_list_link   link; /**< replies belonging to the same xprt. */
 
+        uint32_t              xid;  /* rpc/rdma xid, for ease to compose reply */
+        enum rdma_errcode     errcode;
+
         /**
           Information to encode the reply message
          */
         struct svcrdma_msg       msg;    /**< reply encode message */
+        struct rdma_write_list  *orig_writes;
         struct rdma_write_list  *writes; /**< write chunks, copied from rqst */
         struct rdma_write_chunk *reply;  /**< reply chunks */
         int                      writes_index;
@@ -351,6 +355,7 @@ struct rdma_context {
         void               (*completion)(struct rdma_context *, void *);
         void                *ctx;
         struct svcrdma_xprt *xprt;
+        enum ibv_wc_status   status;
         int                  max_index;
         int                  index;
         struct ibv_mr       *mrs[CTXT_MAX_MRS];
diff --git a/net/usunrpc/rfc5666/xdr_rdma.c b/net/usunrpc/rfc5666/xdr_rdma.c
deleted file mode 100644
index b88b87e..0000000
--- a/net/usunrpc/rfc5666/xdr_rdma.c
+++ /dev/null
@@ -1,19 +0,0 @@
-
-
-bool_t xdr_rdma_chunks(XDRS *xdrs, char *buffer, int buflen)
-{
-        int rc;
-
-        svc_assert(xdrs->x_op == XDR_ENCODE || xdrs->x_op == XDR_DECODE);
-        if (xdrs->x_op == XDR_DECODE) {
-                struct rdma_request *req;
-                req = (struct rdma_request *)xdrs->x_public;
-                rc = rdma_read_chunks(req, buffer, buflen);
-        } else {
-                struct rdma_reply *reply;
-                reply = (struct rdma_reply *)xdrs->x_public;
-                rc = rdma_write_chunks(reply, buffer, buflen);
-        }
-
-        return rc == 0 ? TRUE : FALSE;
-}
-- 
1.8.3.2

