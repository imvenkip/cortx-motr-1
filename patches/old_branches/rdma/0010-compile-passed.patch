From 4520422070061bf04224095a3aec21470a584aa0 Mon Sep 17 00:00:00 2001
From: "jinshan.xiong" <jinshan.xiong@clusterstor.com>
Date: Wed, 21 Jul 2010 17:49:44 -0600
Subject: [PATCH 10/34] - compile passed

---
 configure.ac                            |  16 +-
 lib/memory.c                            |  11 +
 lib/refs.c                              |   7 +
 lib/refs.h                              |  10 +
 lib/vec.h                               |  17 +
 net/usunrpc/Makefile.am                 |   6 +-
 net/usunrpc/rfc5666/Makefile.am         |   4 +
 net/usunrpc/rfc5666/rfc5666.h           |  36 +-
 net/usunrpc/rfc5666/rfc5666_xdr.c       | 130 +++----
 net/usunrpc/rfc5666/svc_rdma.c          | 647 ++++++++++++++------------------
 net/usunrpc/rfc5666/svc_rdma.h          |   2 +-
 net/usunrpc/rfc5666/svc_rdma_internal.h |  35 +-
 net/usunrpc/usunrpc.h                   |   5 +-
 net/usunrpc/uxdr.c                      |  21 +-
 14 files changed, 457 insertions(+), 490 deletions(-)
 create mode 100644 net/usunrpc/rfc5666/Makefile.am

diff --git a/configure.ac b/configure.ac
index 6fe731c..5db4c56 100755
--- a/configure.ac
+++ b/configure.ac
@@ -8,6 +8,7 @@ AH_TEMPLATE([PACKAGE], [Package name.])
 AH_TEMPLATE([VERSION], [Version of the package.])
 AH_TEMPLATE([ENABLE_DEBUG], [Enable debug info.])
 AH_TEMPLATE([ENABLE_GSSRPC], [Enable gssrpc.])
+AH_TEMPLATE([ENABLE_RDMA], [Enable rdma.])
 AH_TEMPLATE([HAVE_JOURNAL_ABORT], [Have journal_abort() function])
 AH_TEMPLATE([HAVE_FILE_READV], [Have fops->readv function])
 AH_TEMPLATE([HAVE_FILE_AIO_READ], [Have fops->aio_read function])
@@ -304,6 +305,8 @@ case $host_os in
                 ;;
 esac
 
+AM_CONDITIONAL([ENABLE_RDMA], [test x$enable_rdma = xyes])
+
 AC_MSG_CHECKING([for linux sources dir])
 AC_ARG_WITH([linux],
         [AC_HELP_STRING([--with-linux=path], [set path to linux sources])],
@@ -451,8 +454,6 @@ if test x$enable_gssrpc = xyes; then
         fi
 fi
 
-<<<<<<< HEAD:configure.ac
-=======
 if test x$OS = xlinux; then
         OLD_LIBS=$LIBS
         LIBS=""
@@ -463,11 +464,15 @@ if test x$OS = xlinux; then
 fi
 
 if test x$enable_rdma = xyes; then
-        AC_CHECK_HEADERS([rdma/rdma_cma.h infiniband/verbs.h], [AC_DEFINE([ENABLE_RDMA])],
-                         [AC_MSG_ERROR([rdma header files: rdma_cma.h or infiniband/verbs.h cannot be found!])])
+        AC_CHECK_LIB([rdmacm], [rdma_create_id], [],
+                     [AC_MSG_ERROR([cannot find ramdcm lib])])
+        AC_CHECK_LIB([ibverbs], [ibv_open_device], [],
+                     [AC_MSG_ERROR([cannot find ibverbs])])
+        AC_CHECK_HEADERS([rdma/rdma_cma.h infiniband/verbs.h],
+                         [AC_DEFINE([ENABLE_RDMA])],
+                         [AC_MSG_ERROR([cannot find rdma header files])])
 fi
 
->>>>>>> - move c2_buf and c2_dbuf to vec.h:configure.ac
 OLD_LIBS=$LIBS
 LIBS=""
 AC_SEARCH_LIBS([io_getevents], [c aio], [], [AC_MSG_ERROR([io_getevents cannot be found! Try install libaio-devel.])])
@@ -542,6 +547,7 @@ AC_CONFIG_FILES([
                  net/Makefile
                  net/ksunrpc/Makefile
                  net/usunrpc/Makefile
+                 net/usunrpc/rfc5666/Makefile
 		 net/ut/Makefile
 		 net/st/Makefile
                  nrs/Makefile
diff --git a/lib/memory.c b/lib/memory.c
index 5854e0e..98bb2b7 100644
--- a/lib/memory.c
+++ b/lib/memory.c
@@ -90,6 +90,17 @@ void *c2_alloc(size_t size)
 	return ret;
 }
 
+void *c2_alloc_align(size_t size, int align)
+{
+        void *ret;
+
+        if (posix_memalign(&ret, align, size))
+                return NULL;
+
+        memset(ret, 0, size);
+        return ret;
+}
+
 void c2_free(void *data)
 {
 	__free(data);
diff --git a/lib/refs.c b/lib/refs.c
index c12b753..8c169db 100644
--- a/lib/refs.c
+++ b/lib/refs.c
@@ -21,3 +21,10 @@ void c2_ref_put(struct c2_ref *ref)
 	}
 }
 C2_EXPORTED(c2_ref_put);
+
+int c2_ref_read(struct c2_ref *ref)
+{
+	return (int)c2_atomic64_get(&ref->ref_cnt);
+}
+C2_EXPORTED(c2_ref_read);
+
diff --git a/lib/refs.h b/lib/refs.h
index d851de6..81e9ef1 100644
--- a/lib/refs.h
+++ b/lib/refs.h
@@ -51,6 +51,16 @@ void c2_ref_get(struct c2_ref *ref);
 */
 void c2_ref_put(struct c2_ref *ref);
 
+/**
+ return the current refcount of c2_ref.
+
+ @param ref pointer to c2_ref object
+
+ @return current refcount 
+*/
+int c2_ref_read(struct c2_ref *ref);
+
+
 #endif
 /*
  *  Local variables:
diff --git a/lib/vec.h b/lib/vec.h
index a1ea803..d33c07c 100644
--- a/lib/vec.h
+++ b/lib/vec.h
@@ -136,6 +136,23 @@ int         c2_diovec_alloc   (struct c2_diovec *vec,
 void        c2_diovec_free    (struct c2_diovec *vec);
 int         c2_diovec_register(struct c2_diovec *vec, 
 			       struct c2_dio_engine *eng);
+
+/**
+  data buffer description in C2 service.
+
+  Whenever client wants to send a data buffer to server, the data buffer
+  must be encoded as a c2_dbuf. The most important field is @alignment which
+  indicates the alignment requirement of data.
+
+  TODO: In RDMA, the c2_dbuf has to be encoded/decoded by a customized function,
+  we have to work out a mechanism to conform to fop_type_XYZ structure.
+ */
+struct c2_dbuf {
+        uint32_t db_alignment; /**< alignment of data buffer */
+        uint32_t db_buflen;
+        void    *db_buffer;
+};
+
 /** @} end of vec group */
 
 /* __COLIBRI_LIB_VEC_H__ */
diff --git a/net/usunrpc/Makefile.am b/net/usunrpc/Makefile.am
index 59e05d4..e546159 100644
--- a/net/usunrpc/Makefile.am
+++ b/net/usunrpc/Makefile.am
@@ -1,6 +1,10 @@
 usunrpcdir                         = $(includedir)/net/usunrpc
 usunrpc_HEADERS                    = usunrpc.h usunrpc_internal.h
-SUBDIRS                            = . rfc5666
+
+SUBDIRS                            = .
+if ENABLE_RDMA
+SUBDIRS                           += rfc5666
+endif
 
 noinst_LTLIBRARIES                 = libcolibri-net-usunrpc.la
 libcolibri_net_usunrpc_la_SOURCES  = client.c server.c domain.c usunrpc.h \
diff --git a/net/usunrpc/rfc5666/Makefile.am b/net/usunrpc/rfc5666/Makefile.am
new file mode 100644
index 0000000..fbdaba9
--- /dev/null
+++ b/net/usunrpc/rfc5666/Makefile.am
@@ -0,0 +1,4 @@
+noinst_LTLIBRARIES                 = libcolibri-rdma.la
+libcolibri_rdma_la_SOURCES         = rfc5666.h rfc5666_xdr.c svc_rdma.h \
+                                     svc_rdma.c svc_rdma_internal.h
+INCLUDES                           = -I. -I$(top_srcdir) -I$(top_srcdir)/include
diff --git a/net/usunrpc/rfc5666/rfc5666.h b/net/usunrpc/rfc5666/rfc5666.h
index ad3f18b..a005ea4 100644
--- a/net/usunrpc/rfc5666/rfc5666.h
+++ b/net/usunrpc/rfc5666/rfc5666.h
@@ -3,7 +3,7 @@
 #define _RFC5666_H_
 
 #include <rpc/rpc.h>
-#include <libs/cdefs.h>
+#include "lib/cdefs.h"
 
 /**
   This file defines data structures needed by rdma. These data structures
@@ -16,29 +16,29 @@
   @{
  */
 struct rdma_segment {
-        uint32_t handle;
-        uint32_t length;
-        uint64_t offset;
+        uint32_t rs_handle;
+        uint32_t rs_length;
+        uint64_t rs_offset;
 };
 
 struct rdma_read_chunk {
-        uint32_t position;
-        struct rdma_segment target;
+        uint32_t            rrc_position;
+        struct rdma_segment rrc_target;
 };
 
 struct rdma_read_list {
-        struct rdma_read_chunk entry;
-        struct rdma_read_list *next;
+        struct rdma_read_chunk rrl_entry;
+        struct rdma_read_list *rrl_next;
 };
 
 struct rdma_write_chunk {
-        uint32_t             nr_segs;
-        struct rdma_segment *segs;
+        uint32_t             rwc_nr_segs;
+        struct rdma_segment *rwc_segs;
 };
 
 struct rdma_write_list {
-        struct rdma_write_chunk entry;
-        struct rdma_write_list *next;
+        struct rdma_write_chunk rwl_entry;
+        struct rdma_write_list *rwl_next;
 };
 
 struct rdma_header_msg {
@@ -66,6 +66,11 @@ enum rdma_errcode {
         RDMA_ERR_CHUNK = 2,
 };
 
+struct rdma_vers_error {
+        uint32_t rdma_vers_low;
+        uint32_t rdma_vers_high;
+};
+
 struct rdma_error {
         enum rdma_errcode errcode;
         union {
@@ -74,11 +79,6 @@ struct rdma_error {
         } u;
 };
 
-struct rdma_vers_error {
-        uint32_t rdma_vers_low;
-        uint32_t rdma_vers_high;
-};
-
 enum rdma_proc {
         RDMA_MSG    = 0,
         RDMA_NOMSG  = 1,
@@ -88,7 +88,7 @@ enum rdma_proc {
 };
 
 struct rdma_body {
-        enum rdma_proc proc;
+        enum rdma_proc rdma_proc;
         union {
                 struct rdma_header_msg    rdma_msg;
                 struct rdma_header_nomsg  rdma_nomsg;
diff --git a/net/usunrpc/rfc5666/rfc5666_xdr.c b/net/usunrpc/rfc5666/rfc5666_xdr.c
index 7066ab73..8980868 100644
--- a/net/usunrpc/rfc5666/rfc5666_xdr.c
+++ b/net/usunrpc/rfc5666/rfc5666_xdr.c
@@ -2,36 +2,30 @@
 
 static bool_t xdr_rdma_segment (XDR *xdrs, struct rdma_segment *objp)
 {
-        register int32_t *buf;
-
-         if (!xdr_uint32_t (xdrs, &objp->handle))
+         if (!xdr_uint32_t (xdrs, &objp->rs_handle))
                  return FALSE;
-         if (!xdr_uint32_t (xdrs, &objp->length))
+         if (!xdr_uint32_t (xdrs, &objp->rs_length))
                  return FALSE;
-         if (!xdr_uint64_t (xdrs, &objp->offset))
+         if (!xdr_uint64_t (xdrs, &objp->rs_offset))
                  return FALSE;
         return TRUE;
 }
 
 static bool_t xdr_rdma_read_chunk (XDR *xdrs, struct rdma_read_chunk *objp)
 {
-        register int32_t *buf;
-
-         if (!xdr_uint32_t (xdrs, &objp->position))
+         if (!xdr_uint32_t (xdrs, &objp->rrc_position))
                  return FALSE;
-         if (!xdr_rdma_segment (xdrs, &objp->target))
+         if (!xdr_rdma_segment (xdrs, &objp->rrc_target))
                  return FALSE;
         return TRUE;
 }
 
 static bool_t xdr_rdma_read_list (XDR *xdrs, struct rdma_read_list *objp)
 {
-        register int32_t *buf;
-
-         if (!xdr_rdma_read_chunk(xdrs, &objp->entry))
+         if (!xdr_rdma_read_chunk(xdrs, &objp->rrl_entry))
                  return FALSE;
          if (!xdr_pointer(xdrs,
-                          (char **)&objp->next,
+                          (char **)&objp->rrl_next,
                           sizeof (struct rdma_read_list),
                           (xdrproc_t) xdr_rdma_read_list))
                  return FALSE;
@@ -40,11 +34,9 @@ static bool_t xdr_rdma_read_list (XDR *xdrs, struct rdma_read_list *objp)
 
 static bool_t xdr_rdma_write_chunk (XDR *xdrs, struct rdma_write_chunk *objp)
 {
-        register int32_t *buf;
-
          if (!xdr_array(xdrs,
-                        (char **)&objp->nr_segs,
-                        (int *) &objp->segs,
+                        (char **) &objp->rwc_segs,
+                        (u_int *)&objp->rwc_nr_segs,
                         ~0,
                         sizeof (struct rdma_segment),
                         (xdrproc_t) xdr_rdma_segment))
@@ -54,62 +46,25 @@ static bool_t xdr_rdma_write_chunk (XDR *xdrs, struct rdma_write_chunk *objp)
 
 static bool_t xdr_rdma_write_list (XDR *xdrs, struct rdma_write_list *objp)
 {
-        register int32_t *buf;
-
-         if (!xdr_rdma_write_chunk (xdrs, &objp->entry))
-                 return FALSE;
-         if (!xdr_pointer(xdrs,
-                          (char **)&objp->next,
-                          sizeof (struct rdma_write_list),
-                          (xdrproc_t) xdr_rdma_write_list))
-                 return FALSE;
+        if (!xdr_rdma_write_chunk (xdrs, &objp->rwl_entry))
+                return FALSE;
+        if (!xdr_pointer(xdrs,
+                         (char **)&objp->rwl_next,
+                         sizeof (struct rdma_write_list),
+                         (xdrproc_t) xdr_rdma_write_list))
+                return FALSE;
         return TRUE;
 }
 
 static bool_t xdr_rdma_proc (XDR *xdrs, enum rdma_proc *objp)
 {
-        register int32_t *buf;
-
          if (!xdr_enum (xdrs, (enum_t *) objp))
                  return FALSE;
         return TRUE;
 }
 
-static bool_t xdr_rdma_body (XDR *xdrs, struct rdma_body *objp)
-{
-        register int32_t *buf;
-
-         if (!xdr_rdma_proc (xdrs, &objp->proc))
-                 return FALSE;
-        switch (objp->proc) {
-        case RDMA_MSG:
-                 if (!xdr_rdma_header_msg (xdrs, &objp->u.rdma_msg))
-                         return FALSE;
-                break;
-        case RDMA_NOMSG:
-                 if (!xdr_rdma_header_nomsg (xdrs, &objp->u.rdma_nomsg))
-                         return FALSE;
-                break;
-        case RDMA_MSGP:
-                 if (!xdr_rdma_header_padded (xdrs, &objp->u.rdma_msgp))
-                         return FALSE;
-                break;
-        case RDMA_DONE:
-                break;
-        case RDMA_ERROR:
-                 if (!xdr_rdma_error (xdrs, &objp->u.rdma_error))
-                         return FALSE;
-                break;
-        default:
-                return FALSE;
-        }
-        return TRUE;
-}
-
 static bool_t xdr_rdma_header_msg (XDR *xdrs, struct rdma_header_msg *objp)
 {
-        register int32_t *buf;
-
          if (!xdr_pointer (xdrs,
                            (char **)&objp->rdma_reads,
                            sizeof (struct rdma_read_list),
@@ -130,8 +85,6 @@ static bool_t xdr_rdma_header_msg (XDR *xdrs, struct rdma_header_msg *objp)
 
 static bool_t xdr_rdma_header_nomsg (XDR *xdrs, struct rdma_header_nomsg *objp)
 {
-        register int32_t *buf;
-
          if (!xdr_pointer (xdrs,
                            (char **)&objp->rdma_reads,
                            sizeof (struct rdma_read_list),
@@ -152,8 +105,6 @@ static bool_t xdr_rdma_header_nomsg (XDR *xdrs, struct rdma_header_nomsg *objp)
 
 static bool_t xdr_rdma_header_padded (XDR *xdrs, struct rdma_header_padded *objp)
 {
-        register int32_t *buf;
-
          if (!xdr_uint32_t (xdrs, &objp->rdma_align))
                  return FALSE;
          if (!xdr_uint32_t (xdrs, &objp->rdma_thresh))
@@ -178,25 +129,30 @@ static bool_t xdr_rdma_header_padded (XDR *xdrs, struct rdma_header_padded *objp
 
 static bool_t xdr_rdma_errcode (XDR *xdrs, enum rdma_errcode *objp)
 {
-        register int32_t *buf;
-
          if (!xdr_enum (xdrs, (enum_t *) objp))
                  return FALSE;
         return TRUE;
 }
 
-static bool_t xdr_rdma_error (XDR *xdrs, struct rdma_error *objp)
+static bool_t xdr_rdma_vers_error (XDR *xdrs, struct rdma_vers_error *objp)
 {
-        register int32_t *buf;
+         if (!xdr_uint32_t (xdrs, &objp->rdma_vers_low))
+                 return FALSE;
+         if (!xdr_uint32_t (xdrs, &objp->rdma_vers_high))
+                 return FALSE;
+        return TRUE;
+}
 
+static bool_t xdr_rdma_error (XDR *xdrs, struct rdma_error *objp)
+{
          if (!xdr_rdma_errcode (xdrs, &objp->errcode))
                  return FALSE;
         switch (objp->errcode) {
-        case ERR_VERS:
+        case RDMA_ERR_VERS:
                  if (!xdr_rdma_vers_error (xdrs, &objp->u.rdma_vers))
                          return FALSE;
                 break;
-        case ERR_CHUNK:
+        case RDMA_ERR_CHUNK:
                 break;
         default:
                  if (!xdr_vector (xdrs,
@@ -210,21 +166,37 @@ static bool_t xdr_rdma_error (XDR *xdrs, struct rdma_error *objp)
         return TRUE;
 }
 
-static bool_t xdr_rdma_vers_error (XDR *xdrs, struct rdma_vers_error *objp)
+static bool_t xdr_rdma_body (XDR *xdrs, struct rdma_body *objp)
 {
-        register int32_t *buf;
-
-         if (!xdr_uint32_t (xdrs, &objp->rdma_vers_low))
-                 return FALSE;
-         if (!xdr_uint32_t (xdrs, &objp->rdma_vers_high))
+         if (!xdr_rdma_proc (xdrs, &objp->rdma_proc))
                  return FALSE;
+        switch (objp->rdma_proc) {
+        case RDMA_MSG:
+                 if (!xdr_rdma_header_msg (xdrs, &objp->u.rdma_msg))
+                         return FALSE;
+                break;
+        case RDMA_NOMSG:
+                 if (!xdr_rdma_header_nomsg (xdrs, &objp->u.rdma_nomsg))
+                         return FALSE;
+                break;
+        case RDMA_MSGP:
+                 if (!xdr_rdma_header_padded (xdrs, &objp->u.rdma_msgp))
+                         return FALSE;
+                break;
+        case RDMA_DONE:
+                break;
+        case RDMA_ERROR:
+                 if (!xdr_rdma_error (xdrs, &objp->u.rdma_error))
+                         return FALSE;
+                break;
+        default:
+                return FALSE;
+        }
         return TRUE;
 }
 
 bool_t xdr_svcrdma_msg (XDR *xdrs, struct svcrdma_msg *objp)
 {
-        register int32_t *buf;
-
          if (!xdr_uint32_t (xdrs, &objp->rdma_xid))
                  return FALSE;
          if (!xdr_uint32_t (xdrs, &objp->rdma_vers))
diff --git a/net/usunrpc/rfc5666/svc_rdma.c b/net/usunrpc/rfc5666/svc_rdma.c
index 6b9aaba..057f6e8 100644
--- a/net/usunrpc/rfc5666/svc_rdma.c
+++ b/net/usunrpc/rfc5666/svc_rdma.c
@@ -2,16 +2,24 @@
 #include <rpc/rpc.h>
 #include <errno.h>
 #include <netinet/in.h>
+#include <unistd.h>
 
 #include "svc_rdma_internal.h"
 #include "svc_rdma.h"
 
+/* internal function forward declaration */
 static int svcrdma_buffer_create(struct svcrdma_xprt *xprt);
 static void svcrdma_buffer_destroy(struct svcrdma_xprt *xprt);
 static int rdma_recv_completion(struct svcrdma_xprt *xprt,
                                 struct ibv_wc *wc,
                                 struct rpc_msg *rpcmsg);
 static void rdma_completion_one(struct rdma_context *ctxt);
+static void rdma_fixup_write_chunks(struct rdma_reply *reply);
+static void svcrdma_repost_recv(struct rdma_request *req);
+static int rdma_send_reply(struct rdma_reply *reply);
+static void svcrdma_put_reply(struct rdma_reply *reply);
+static struct rdma_reply *svcrdma_get_reply(struct svcrdma_xprt *xprt);
+static int rdma_read_chunks(struct rdma_request *req, char *buffer, int buflen);
 
 /* SVCXPRT callbacks */
 static void svcrdma_xprt_destroy (struct svcrdma_xprt *xprt);
@@ -35,6 +43,7 @@ static const struct xp_ops svcrdma_op = {
 static bool_t rendezvous_request (SVCXPRT *, struct rpc_msg *);
 static enum xprt_stat rendezvous_stat (SVCXPRT *);
 static void rendezvous_abort (void) __attribute__ ((__noreturn__));
+static void rendezvous_destroy(SVCXPRT *xprt);
 
 /* This function makes sure abort() relocation goes through PLT
    and thus can be lazy bound.  */
@@ -61,9 +70,9 @@ SVCXPRT *svcrdma_create (struct sockaddr_in *sa, struct svcrdma_config *cfg)
         struct svcrndzv_xprt *xp;
         struct ibv_device_attr devattr;
 
-        xp = mem_alloc(sizeof(*xp));
+        C2_ALLOC_PTR(xp);
         if (xp == NULL) {
-                svc_errx("no memory\n");
+                svcrdma_errx("no memory\n");
                 return NULL;
         }
         memset(xp, 0, sizeof(*xp));
@@ -72,24 +81,24 @@ SVCXPRT *svcrdma_create (struct sockaddr_in *sa, struct svcrdma_config *cfg)
 
         xp->channel = rdma_create_event_channel();
         if (xp->channel == NULL) {
-                svc_errx("rdma_create_event channel failed\n");
+                svcrdma_errx("rdma_create_event channel failed\n");
                 goto out;
         }
 
-        if (rdma_create_id(xp->channel, &xp->cmid, 0, RDMA_RS_TCP)) {
-                svc_errx("rdma_create_id failed\n");
+        if (rdma_create_id(xp->channel, &xp->cmid, 0, RDMA_PS_TCP)) {
+                svcrdma_errx("rdma_create_id failed\n");
                 goto out;
         }
 
         /* get attribute of before doing anything else */
         if (ibv_query_device(xp->cmid->verbs, &devattr)) {
-                svc_errx("query device error\n");
+                svcrdma_errx("query device error\n");
                 goto out;
         }
 
         /* XXX: Only RC mode is supported right now */
         xp->trans = IBV_QPT_RC;
-        xp->port  = ntohs(sa->sa_port);
+        xp->port  = ntohs(sa->sin_port);
         xp->max_send_sge = 2;
         xp->max_recv_sge = 2;
         xp->rc_retry_cnt = 8;
@@ -110,21 +119,21 @@ SVCXPRT *svcrdma_create (struct sockaddr_in *sa, struct svcrdma_config *cfg)
                            IBV_ACCESS_REMOTE_WRITE;
 
         if (rdma_bind_addr(xp->cmid, (struct sockaddr *)&sa)) {
-                svc_errx("bind address error\n");
+                svcrdma_errx("bind address error\n");
                 goto out;
         }
 
         xp->status = RDMA_XPRT_LISTEN;
         if (rdma_listen(xp->cmid, 0)) {
-                svc_errx("listen error\n");
+                svcrdma_errx("listen error\n");
                 goto out;
         }
 
         /* Now initiate SVCXPRT stuffs. */
-        svcxprt = xp->svcxprt;
-        svcxprt->xp_p1 = xp;
+        svcxprt = &xp->svcxprt;
+        svcxprt->xp_p1 = (caddr_t)xp;
         svcxprt->xp_ops = &svcrdma_rendezvous_op;
-        svcxprt->xp_port = port;
+        svcxprt->xp_port = xp->port;
         svcxprt->xp_sock = xp->channel->fd;
 
         xprt_register(svcxprt);
@@ -135,139 +144,10 @@ out:
                 rdma_destroy_id(xp->cmid);
         if (xp->channel)
                 rdma_destroy_event_channel(xp->channel);
-        mem_free(xp);
+        c2_free(xp);
         return NULL;
 }
 
-static void svcrdma_buffer_destroy(struct svcrdma_xprt *xprt)
-{
-        struct rdma_reply *reply;
-        int i;
-        int count;
-
-        count = xprt->rndzv->max_recv_wr;
-        if (xprt->rcv_bufs) {
-                for (i = 0; i < count; i++) {
-                        struct rdma_request *r = &xprt->rcv_bufs[i];
-
-                        if (r->buffer == NULL)
-                                break;
-                        free(r->buffer);
-
-                        if (r->mr == NULL)
-                                break;
-                        ibv_dereg_mr(r->mr);
-                }
-                mem_free(xprt->rcv_bufs);
-        }
-
-        reply = xprt->snd_bufs;
-        while (reply) {
-                struct rdma_reply *tmp = reply->next;
-
-                if (reply->buffer)
-                        free(reply->buffer);
-                if (reply->mr)
-                        ibv_dereg_mr(reply->mr);
-                mem_free(reply);
-                reply = tmp;
-        }
-}
-
-static int svcrdma_buffer_create(struct svcrdma_xprt *xprt)
-{
-        struct rdma_request *req;
-        int nr;
-        int count;
-        int bufsize;
-        int rc;
-
-        /* for receive buffers. */
-        count = xprt->rndzv->max_recv_wr;
-        req = mem_alloc(count * sizeof(*req));
-        if (req == NULL)
-                return -ENOMEM;
-
-        memset(req, 0, count * sizeof(*req));
-        xprt->rcv_bufs = req;
-
-        bufsize = xprt->max_msg_size;
-        for (i = 0; i < count; i++) {
-                struct rdma_request *r = &req[i];
-                struct ibv_recv_wr     *badwr;
-
-                r->xprt = NULL;
-                if (posix_memalign(&r->buffer, xprt->rndzv->page_size, bufsize))
-                        goto out;
-
-                r->mr = ibv_reg_mr(xprt->pd, r->buffer, bufsize,
-                                   xprt->rndzv->rcv_wr_flags);
-                if (!r->mr) {
-                        free(r->buffer);
-                        r->buffer = NULL;
-                        goto out;
-                }
-
-                /* register receive buffer */
-                r->xprt       = xprt;
-                r->sge.addr   = r->buffer;
-                r->sge.length = bufsize;
-                r->sge.lkey   = r->mr->lkey;
-                r->wr.wr_id   = (uint64_t)r;
-                r->wr.sg_list = &r->sge;
-                r->wr.num_sge = 1;
-                rc = ibv_post_recv(xprt->qp, &r->wr, &badwr);
-                if (rc) {
-                        ibv_dereg_mr(r->mr);
-                        free(r->buffer);
-                        r->buffer = NULL;
-                        goto out;
-                }
-        }
-
-        /* for send buffers. */
-        count = xprt->rndzv->max_send_wr;
-        for (i = 0; i < count; i++) {
-                struct rdma_reply *reply;
-
-                reply = mem_alloc(sizeof(*reply));
-                if (!reply)
-                        goto out;
-                memset(reply, 0, sizeof(*reply));
-
-                posix_memalign(&reply->buffer, xprt->rndzv->page_size, bufsize * 2);
-                if (!reply->buffer) {
-                        mem_free(reply);
-                        goto out;
-                }
-
-                reply->rdma_mr = ibv_reg_mr(xprt->pd, reply->buffer, bufsize,
-                                            xprt->rndzv->snd_wr_flags);
-                if (!reply->mr) {
-                        mem_free(reply);
-                        free(reply->buffer);
-                        goto out;
-                }
-
-                reply->rpc_mr = ibv_reg_mr(xprt->pd, )
-
-                reply->xprt = xprt;
-                reply->sge.addr = reply->buffer;
-                reply->sge.length = bufsize;
-                reply->sge.lkey = reply->mr->lkey;
-                reply->wr.wr_id = (uint64_t)reply;
-                reply->wr.sg_list = &reply->sge;
-                reply->num_sge = 1;
-
-                reply->next = xprt->snd_bufs;
-                xprt->snd_bufs = reply;
-        }
-
-        return 0;
-
-out:
-        svcrdma_buffer_destroy(xprt);
-}
 
 /**
  * svcrdma_handle_connection: Handle a new connecting request from client.
@@ -291,7 +171,7 @@ static int svcrdma_handle_connection(struct svcrndzv_xprt *xp,
         struct ibv_qp_init_attr attr = { 0 };
         struct rdma_conn_param param = { 0 };
 
-        xprt = mem_alloc(sizeof(*xprt));
+        C2_ALLOC_PTR(xprt);
         if (xprt == NULL)
                 return -ENOMEM;
 
@@ -327,13 +207,13 @@ static int svcrdma_handle_connection(struct svcrndzv_xprt *xp,
         attr.cap.max_send_sge = xp->max_send_sge;
         attr.cap.max_recv_sge = xp->max_recv_sge;
         attr.qp_type = xp->trans;
-        if (rdma_create_qp(cmid, xp->pd, &attr) != 0)
+        if (rdma_create_qp(cmid, xprt->pd, &attr) != 0)
                 goto out;
 
         if (svcrdma_buffer_create(xprt) != 0)
                 goto out;
 
-        svc_assert(xp->trans == IBV_QPT_RC);
+        svcrdma_assert(xp->trans == IBV_QPT_RC);
         param.responder_resources = 1;
         param.initiator_depth = 1;
         param.rnr_retry_count = xp->rc_rnr_retry_cnt;
@@ -343,7 +223,7 @@ static int svcrdma_handle_connection(struct svcrndzv_xprt *xp,
 
         /* great, everything sounds ok, register an xprt to svc */
         svcxprt = &xprt->svcxprt;
-        svcxprt->xp_p1 = xprt;
+        svcxprt->xp_p1 = (caddr_t)xprt;
         svcxprt->xp_ops = &svcrdma_op;
         svcxprt->xp_sock = xprt->channel->fd;
         xprt_register(svcxprt);
@@ -356,7 +236,7 @@ static int svcrdma_handle_connection(struct svcrndzv_xprt *xp,
 
 out:
         svcrdma_xprt_destroy(xprt);
-        return NULL; 
+        return -errno; 
 }
 
 static inline struct svcrdma_xprt *xprt_find(struct svcrndzv_xprt *xp,
@@ -364,7 +244,7 @@ static inline struct svcrdma_xprt *xprt_find(struct svcrndzv_xprt *xp,
 {
         struct svcrdma_xprt *xprt;
 
-        c2_list_for_each_entry(xp->xprts, xprt, struct svcrdma_xprt, link) {
+        c2_list_for_each_entry(&xp->xprts, xprt, struct svcrdma_xprt, link) {
                 if (xprt->cmid == id)
                         return xprt;
         }
@@ -377,13 +257,13 @@ static inline struct svcrdma_xprt *xprt_find(struct svcrndzv_xprt *xp,
  **/
 static bool_t rendezvous_request (SVCXPRT *xprt, struct rpc_msg *errmsg)
 {
-        struct svcrndzv_xprt *xp = xprt->xp_p1;
+        struct svcrndzv_xprt *xp = (struct svcrndzv_xprt *)xprt->xp_p1;
         struct rdma_cm_event *ev;
         const char *msg;
         int rc = 0;
 
         if (rdma_get_cm_event(xp->channel, &ev)) {
-                svc_errx("get_cm_event error\n");
+                svcrdma_errx("get_cm_event error\n");
                 /* what can I do? */
                 abort();
         }
@@ -392,47 +272,47 @@ static bool_t rendezvous_request (SVCXPRT *xprt, struct rpc_msg *errmsg)
         if (ev->event == RDMA_CM_EVENT_DISCONNECTED) {
                 struct svcrdma_xprt *xprt = xprt_find(xp, ev->id);
 
-                svc_assert(ev->id != xp->cmid);
-                svc_assert(xprt != NULL);
+                svcrdma_assert(ev->id != xp->cmid);
+                svcrdma_assert(xprt != NULL);
 
                 (void)rdma_ack_cm_event(ev);
                 c2_list_del(&xprt->link);
-                if (xprt->svcxprt.xp_p1 == xprt)
+                if (xprt->svcxprt.xp_p1 == (caddr_t)xprt)
                         xprt_unregister(&xprt->svcxprt);
                 svcrdma_xprt_destroy(xprt);
                 return FALSE;
         }
 
+        msg = rdma_event_str(ev->event);
         switch(ev->event) {
         case RDMA_CM_EVENT_CONNECT_REQUEST:
-                svc_assert(ev->listen_id == xp->cmid);
-                svc_assert(xp->status == RDMA_XPRT_LISTEN);
+                svcrdma_assert(ev->listen_id == xp->cmid);
+                svcrdma_assert(xp->status == RDMA_XPRT_LISTEN);
                 rc = svcrdma_handle_connection(xp, ev);
                 break;
 
         case RDMA_CM_EVENT_ESTABLISHED: {
                 struct svcrdma_xprt *xprt = xprt_find(xp, ev->id);
 
-                svc_assert(ev->id != xp->cmid);
-                svc_assert(xprt != NULL);
-                svc_assert(xprt->status == RDMA_XPRT_CONNECTING);
-                xprt->status == RDMA_XPRT_ESTABLISHED;
+                svcrdma_assert(ev->id != xp->cmid);
+                svcrdma_assert(xprt != NULL);
+                svcrdma_assert(xprt->status == RDMA_XPRT_CONNECTING);
+                xprt->status = RDMA_XPRT_ESTABLISHED;
                 break;
         }
 
         case RDMA_CM_EVENT_DEVICE_REMOVAL:
         case RDMA_CM_EVENT_ADDR_CHANGE:
-                svc_warnx("get event %s, ignored\n", msg);
+                svcrdma_errx("get event %s, ignored\n", msg);
                 break;
 
         default:
-                svc_errx("Unknown event %s\n", rdma_event_str(ev->event));
+                svcrdma_errx("Unknown event %s\n", msg);
                 break;
         }
 
         if (rc)
-                svc_errx("Handle event %s return error %d\n",
-                         rdma_event_str(ev->event), rc);
+                svcrdma_errx("Handle event %s return error %d\n", msg, rc);
 
         (void)rdma_ack_cm_event(ev);
         return FALSE;
@@ -445,12 +325,12 @@ static enum xprt_stat rendezvous_stat (SVCXPRT *xprt)
 
 static void rendezvous_destroy(SVCXPRT *xprt)
 {
-        struct svcrndzv_xprt *xp = xprt->xp_p1;
+        struct svcrndzv_xprt *xp = (struct svcrndzv_xprt *)xprt->xp_p1;
 
         xprt_unregister(xprt);
         rdma_destroy_id(xp->cmid);
         rdma_destroy_event_channel(xp->channel);
-        mem_free(xp);
+        c2_free(xp);
 }
 
 static enum xprt_stat svcrdma_stat (SVCXPRT *xprt)
@@ -465,25 +345,25 @@ static enum xprt_stat svcrdma_stat (SVCXPRT *xprt)
  */
 static bool_t svcrdma_recv (SVCXPRT *xprt, struct rpc_msg *msg)
 {
-        struct svcrdma_xprt *xp = xprt->xp_p1;
+        struct svcrdma_xprt *xp = (struct svcrdma_xprt *)xprt->xp_p1;
         struct ibv_cq *ecq;
         void          *ectx;
         struct ibv_wc  wc;
         int            rc = 0;
 
         if (ibv_get_cq_event(xp->channel, &ecq, &ectx) != 0) {
-                svc_errx("get cq_event for xprt %p\n", xp);
+                svcrdma_errx("get cq_event for xprt %p\n", xp);
                 return FALSE;
         }
 
         if (ecq != xp->cq || ectx != xp) {
-                svc_errx("wrong context has %p/%p, expect %p/%p",
-                         ecq, ectx, xp->cq, xp)
+                svcrdma_errx("wrong context has %p/%p, expect %p/%p",
+                             ecq, ectx, xp->cq, xp);
                 rc = 1;
         }
 
-        if (ibv_req_notify_events(xp->cp, 0))
-                svc_errx("failed to set up notification");
+        if (ibv_req_notify_cq(xp->cq, 0))
+                svcrdma_errx("failed to set up notification");
         ibv_ack_cq_events(xp->cq, 1);
         if (rc)
                 return FALSE;
@@ -495,16 +375,16 @@ static bool_t svcrdma_recv (SVCXPRT *xprt, struct rpc_msg *msg)
                 rc = ibv_poll_cq(xp->cq, 1, &wc);
                 if (!rc) {         /* no event pending any more */
                         break;
-                } else if (rc < 0) /* error occurs */
-                        svc_errx("error occurs polling cq");
+                } else if (rc < 0) { /* error occurs */
+                        svcrdma_errx("error occurs polling cq");
                         break;
                 }
 
-                svc_assert(rc == 1);
+                svcrdma_assert(rc == 1);
                 if (wc.status != IBV_WC_SUCCESS) {
-                        svc_errx("get a wc with error(%s), op/id: %d/%lx",
-                                 ibv_wc_status_err(wc.staus), wc.opcode,
-                                 wc.wr_id);
+                        svcrdma_errx("get a wc with error(%s), op/id: %d/%lx",
+                                     ibv_wc_status_str(wc.status),
+                                     wc.opcode, wc.wr_id);
 
                         /* though there is something wrong, we still need to
                          * handle the completion event */
@@ -519,11 +399,11 @@ static bool_t svcrdma_recv (SVCXPRT *xprt, struct rpc_msg *msg)
                 case IBV_WC_RDMA_WRITE:
                         /* XXX: impossible to get this event from here because
                          * RDMA event handling is sync. */
-                        svc_assert(0);
-                        rdma_completion_one(wc.wr_id);
+                        svcrdma_assert(0);
+                        rdma_completion_one((struct rdma_context *)wc.wr_id);
                         break;
                 default:
-                        svc_errx("unknown opcode(%d) of completion event %lx",
+                        svcrdma_errx("unknown opcode(%d) of completion event %lx",
                                  wc.opcode, wc.wr_id);
                         break;
                 }
@@ -535,34 +415,41 @@ static bool_t svcrdma_recv (SVCXPRT *xprt, struct rpc_msg *msg)
 static bool_t svcrdma_getargs(SVCXPRT *xprt, xdrproc_t xdr_args,
                               caddr_t args_ptr)
 {
-        struct svcrdma_xprt *xp = xprt->xp_p1;
-        return ((*xdr_args) (&xp->xdrs, args_ptr));
+        struct svcrdma_xprt *xp = (struct svcrdma_xprt *)xprt->xp_p1;
+        XDR *xdrs;
+
+        svcrdma_assert(xp->curreq != NULL);
+        xdrs = &xp->curreq->xdrs;
+        svcrdma_assert(xdrs->x_public == (caddr_t)xp->curreq);
+        return ((*xdr_args) (&xp->curreq->xdrs, args_ptr));
 }
 
 static bool_t svcrdma_freeargs(SVCXPRT *xprt, xdrproc_t xdr_args,
                                caddr_t args_ptr)
 {
-        struct svcrdma_xprt *xp = xprt->xp_p1;
+        struct svcrdma_xprt *xp = (struct svcrdma_xprt *)xprt->xp_p1;
+        XDR *xdrs;
 
+        svcrdma_assert(xp->curreq != NULL);
+        xdrs = &xp->curreq->xdrs;
+        svcrdma_assert(xdrs->x_public == (caddr_t)xp->curreq);
         xdrs->x_op = XDR_FREE;
-        return ((*xdr_args) (&xp->xdrs, args_ptr));
+        return ((*xdr_args) (xdrs, args_ptr));
 }
 
-static bool_t svcrdma_reply(SVCXPRT *svcxprt, struct rpc_msg *msg)
+static bool_t svcrdma_reply(SVCXPRT *svcxprt, struct rpc_msg *rpcmsg)
 {
         struct svcrdma_xprt *xprt = (struct svcrdma_xprt *)svcxprt->xp_p1;
         int bufsize = xprt->rndzv->max_msg_size;
-        struct svcrdma_request *req;
-        struct svcrdma_reply *reply;
+        struct rdma_request *req;
+        struct rdma_reply *reply;
         struct svcrdma_msg   *msg;
-        XDRS xdrs;
-        int rpc_buflen;
-        int rdma_buflen;
-        struct ibv_sge sge[2];
+        XDR xdrs;
         bool_t rc;
 
         /* XXX: there is no way to get request in current implementation of
          * sunrpc since it just pass SVCXPRT in */
+        svcrdma_assert(xprt->curreq != NULL);
         req = xprt->curreq;
         reply = req->reply;
         reply->msg = req->msg;
@@ -573,8 +460,8 @@ static bool_t svcrdma_reply(SVCXPRT *svcxprt, struct rpc_msg *msg)
         reply->writes_index = 0;
 
         xdrmem_create(&xdrs, reply->rpc_buf, bufsize, XDR_ENCODE);
-        msg->rm_xid = reply->msg.rdma_xid;
-        if (!xdr_replymsg(&xdrs, msg)) {
+        msg->rdma_xid = reply->msg.rdma_xid;
+        if (!xdr_replymsg(&xdrs, rpcmsg)) {
                 /* this is probably because of not having enough buffer space */
                 return FALSE;
         }
@@ -598,7 +485,7 @@ static bool_t svcrdma_reply(SVCXPRT *svcxprt, struct rpc_msg *msg)
                 struct rdma_header_msg *rdma_msg;
 
                 msg->rdma_body.rdma_proc = RDMA_MSG;
-                rdma_msg = msg->rdma_body.u.rdma_msg;
+                rdma_msg = &msg->rdma_body.u.rdma_msg;
                 rdma_msg->rdma_reads = NULL;
                 rdma_msg->rdma_writes = req->writes;
                 rdma_msg->rdma_reply = NULL;
@@ -608,17 +495,17 @@ static bool_t svcrdma_reply(SVCXPRT *svcxprt, struct rpc_msg *msg)
         if (!xdr_svcrdma_msg(&xdrs, msg)) {
                 /* impossible! the bufsize is not enough for even rdma
                  * chunks - this is not my fault :-) */
-                svc_assert(0);
+                svcrdma_assert(0);
         }
         reply->rdma_buflen = XDR_GETPOS(&xdrs);
 
-        if (rdma_buflen + rpc_buflen > bufsize) {
+        if (reply->rdma_buflen + reply->rpc_buflen > bufsize) {
                 /* we need to fill in reply chunk and redo encoding. */
                 /* TODO: fill in reply chunk */
-                svc_assert(0);
+                svcrdma_assert(0);
         }
 
-        /* anyway, free request first */
+        /* anyway, c2_free request first */
         svcrdma_repost_recv(req);
 
         /* it looks all right, post reply buffer */
@@ -634,7 +521,7 @@ static bool_t svcrdma_reply(SVCXPRT *svcxprt, struct rpc_msg *msg)
 static void svcrdma_xprt_destroy (struct svcrdma_xprt *xprt)
 {
         if (xprt->cmid->qp)
-                rdma_destroy_qp(cmid);
+                rdma_destroy_qp(xprt->cmid);
         if (xprt->cq)
                 ibv_destroy_cq(xprt->cq);
         if (xprt->pd)
@@ -642,90 +529,94 @@ static void svcrdma_xprt_destroy (struct svcrdma_xprt *xprt)
         if (xprt->channel)
                 ibv_destroy_comp_channel(xprt->channel);
         rdma_destroy_id(xprt->cmid);
-        mem_free(xprt);
+        c2_free(xprt);
 }
 
 static void svcrdma_destroy(SVCXPRT *xprt)
 {
         xprt_unregister(xprt);
-        svcrdma_xprt_destroy(xprt->xp_p1);
+        svcrdma_xprt_destroy((struct svcrdma_xprt *)xprt->xp_p1);
 }
 
-/**
- * buffer related routines.
- */
-static void svcrdma_buffer_destroy(struct svcrndzv_xprt *xprt)
+static void svcrdma_buffer_destroy(struct svcrdma_xprt *xprt)
 {
         struct rdma_reply *reply;
         int i;
         int count;
 
-        count = xprt->max_recv_wr;
+        count = xprt->rndzv->max_recv_wr;
         if (xprt->rcv_bufs) {
                 for (i = 0; i < count; i++) {
                         struct rdma_request *r = &xprt->rcv_bufs[i];
 
                         if (r->buffer == NULL)
                                 break;
-                        free(r->buffer);
+                        c2_free(r->buffer);
 
                         if (r->mr == NULL)
                                 break;
                         ibv_dereg_mr(r->mr);
                 }
-                mem_free(xprt->rcv_bufs);
+                c2_free(xprt->rcv_bufs);
         }
 
         reply = xprt->snd_bufs;
         while (reply) {
                 struct rdma_reply *tmp = reply->next;
 
+                if (reply->rpc_mr)
+                        ibv_dereg_mr(reply->rpc_mr);
+                if (reply->rdma_mr)
+                        ibv_dereg_mr(reply->rdma_mr);
                 if (reply->buffer)
-                        free(reply->buffer);
-                if (reply->mr)
-                        ibv_dereg_mr(reply->mr);
-                mem_free(reply);
+                        c2_free(reply->buffer);
+                c2_free(reply);
                 reply = tmp;
         }
 }
 
-static int svcrdma_buffer_create(struct svcrndzv_xprt *xprt)
+static int svcrdma_buffer_create(struct svcrdma_xprt *xprt)
 {
         struct rdma_request *req;
-        int nr;
         int count;
         int bufsize;
         int rc;
+        int alignment;
+        int i;
 
         /* for receive buffers. */
         count = xprt->rndzv->max_recv_wr;
-        req = mem_alloc(count * sizeof(*req));
+        C2_ALLOC_ARR(req, count);
         if (req == NULL)
                 return -ENOMEM;
 
         memset(req, 0, count * sizeof(*req));
         xprt->rcv_bufs = req;
 
+        rc = -ENOMEM;
+        alignment = xprt->rndzv->page_size;
         bufsize = xprt->rndzv->max_msg_size;
         for (i = 0; i < count; i++) {
                 struct rdma_request *r = &req[i];
                 struct ibv_recv_wr     *badwr;
 
-                r->xprt = xprt;
-                if (posix_memalign(&r->buffer, xprt->rndzv->page_size, bufsize))
+                C2_ALLOC_ALIGN(r->buffer, bufsize, alignment);
+                if (r->buffer == NULL)
                         goto out;
 
                 r->mr = ibv_reg_mr(xprt->pd, r->buffer, bufsize,
                                    xprt->rndzv->rcv_wr_flags);
                 if (!r->mr) {
-                        free(r->buffer);
+                        c2_free(r->buffer);
                         r->buffer = NULL;
+                        rc = -errno;
                         goto out;
                 }
 
                 /* register receive buffer */
-                r->sge.addr   = r->buffer;
-                r->sge.length = bufsize;
+                r->xprt       = xprt;
+                r->sge.addr   = (uint64_t)r->buffer;
+                r->sge.length = (uint32_t)bufsize;
                 r->sge.lkey   = r->mr->lkey;
                 r->wr.wr_id   = (uint64_t)r;
                 r->wr.sg_list = &r->sge;
@@ -733,8 +624,9 @@ static int svcrdma_buffer_create(struct svcrndzv_xprt *xprt)
                 rc = ibv_post_recv(xprt->qp, &r->wr, &badwr);
                 if (rc) {
                         ibv_dereg_mr(r->mr);
-                        free(r->buffer);
+                        c2_free(r->buffer);
                         r->buffer = NULL;
+                        rc = -errno;
                         goto out;
                 }
         }
@@ -744,38 +636,38 @@ static int svcrdma_buffer_create(struct svcrndzv_xprt *xprt)
         for (i = 0; i < count; i++) {
                 struct rdma_reply *reply;
 
-                reply = mem_alloc(sizeof(*reply));
+                C2_ALLOC_PTR(reply);
                 if (!reply)
                         goto out;
-                memset(reply, 0, sizeof(*reply));
 
-                posix_memalign(&reply->buffer, xprt->rndzv->page_size,
-                               bufsize * 2);
-                if (!reply->buffer) {
-                        mem_free(reply);
+                C2_ALLOC_ALIGN(reply->buffer, bufsize * 2, alignment);
+                if (reply->buffer == NULL) {
+                        c2_free(reply);
                         goto out;
                 }
 
-                reply->rdma_buf = reply->buffer;
-                reply->rpc_buf = reply->buffer + bufsize;
                 reply->rdma_mr = ibv_reg_mr(xprt->pd, reply->buffer, bufsize,
-                                            xprt->snd_wr_flags);
+                                            xprt->rndzv->snd_wr_flags);
                 if (!reply->rdma_mr) {
-                        mem_free(reply);
-                        free(reply->buffer);
+                        c2_free(reply);
+                        c2_free(reply->buffer);
+                        rc = -errno;
                         goto out;
                 }
 
                 reply->rpc_mr = ibv_reg_mr(xprt->pd, reply->buffer + bufsize,
-                                           bufsize, xprt->snd_wr_flags);
-                if (reply->rpc_mr) {
-                        mem_free(reply);
-                        free(reply->buffer);
+                                           bufsize, xprt->rndzv->snd_wr_flags);
+                if (!reply->rpc_mr) {
                         ibv_dereg_mr(reply->rdma_mr);
+                        c2_free(reply);
+                        c2_free(reply->buffer);
+                        rc = -errno;
                         goto out;
                 }
 
-                reply->xprt = NULL;
+                reply->xprt = xprt;
+
+                /* add the reply buffer into xprt's reply list */
                 reply->next = xprt->snd_bufs;
                 xprt->snd_bufs = reply;
         }
@@ -784,7 +676,30 @@ static int svcrdma_buffer_create(struct svcrndzv_xprt *xprt)
 
 out:
         svcrdma_buffer_destroy(xprt);
-        return -EAGAIN;
+        return rc;
+}
+
+static void svcrdma_put_reply(struct rdma_reply *reply)
+{
+        struct svcrdma_xprt *xprt = reply->xprt;
+
+        c2_mutex_lock(&xprt->bufs_mutex);
+        reply->next = xprt->snd_bufs;
+        xprt->snd_bufs = reply;
+        c2_mutex_unlock(&xprt->bufs_mutex);
+}
+
+static struct rdma_reply *svcrdma_get_reply(struct svcrdma_xprt *xprt)
+{
+        struct rdma_reply *reply;
+
+        c2_mutex_lock(&xprt->bufs_mutex);
+        reply = xprt->snd_bufs;
+        if (reply)
+                xprt->snd_bufs = reply->next;
+        c2_mutex_unlock(&xprt->bufs_mutex);
+
+        return reply;
 }
 
 static void svcrdma_repost_recv(struct rdma_request *req)
@@ -793,11 +708,11 @@ static void svcrdma_repost_recv(struct rdma_request *req)
         int rc;
 
         req->reply = NULL;
-        xdrmem_create(&xdrs, NULL, 0, XDR_FREE);
-        xdr_svcrdma_msg(&xdrs, &req->msg);
-        rc = ibv_post_recv(xprt, &req->wr, &badwr);
+        xdrmem_create(&req->xdrs, NULL, 0, XDR_FREE);
+        xdr_svcrdma_msg(&req->xdrs, &req->msg);
+        rc = ibv_post_recv(req->xprt->qp, &req->wr, &badwr);
         if (rc)
-                svc_errx("repost recv buffer error");
+                svcrdma_errx("repost recv buffer error");
 }
 
 /**
@@ -816,7 +731,7 @@ static int rdma_recv_completion(struct svcrdma_xprt *xprt,
         int                 rc = 0;
         int                 reqlen;
 
-        svc_assert(wc->opcode == IBV_WC_RECV);
+        svcrdma_assert(wc->opcode == IBV_WC_RECV);
         req = (struct rdma_request *)wc->wr_id;
         req->xprt = xprt;
 
@@ -825,7 +740,7 @@ static int rdma_recv_completion(struct svcrdma_xprt *xprt,
                 /* what can we do? Just reregister the buffer */
                 rc = ibv_post_recv(xprt->qp, &req->wr, &badwr);
                 if (rc)
-                        svc_errx("fatal error on registering the recv buffer");
+                        svcrdma_errx("fatal error on registering recv buffer");
         }
 
         
@@ -838,88 +753,75 @@ static int rdma_recv_completion(struct svcrdma_xprt *xprt,
          */
         memset(&req->msg, 0, sizeof req->msg);
         reqlen = wc->byte_len;
-        svc_assert(xprt->curreq == NULL);
-        svc_assert(req->reply == NULL);
+        svcrdma_assert(xprt->curreq == NULL);
+        svcrdma_assert(req->reply == NULL);
         xprt->curreq = req;
         c2_list_add(&xprt->requests, &xprt->link);
         req->reply = svcrdma_get_reply(xprt);
         if (req->reply == NULL) {
-                svc_errx("fatal error: no reply available, deadlock happens\n");
+                svcrdma_errx("fatal error: no reply buffer available\n");
                 abort();
         }
 
         xdrmem_create(&xdrs, req->buffer, reqlen, XDR_DECODE);
-        if (xdr_svcrdma_msg(xdrs, &req->msg)) {
-                svc_errx("message corrupted, decode rfc5666 failed");
+        if (xdr_svcrdma_msg(&xdrs, &req->msg)) {
+                svcrdma_errx("message corrupted, decode rfc5666 failed");
                 rc = RDMA_ERR_CHUNK;
                 goto out;
         }
         pos = XDR_GETPOS(&xdrs);
-        svc_assert(pos <= reqlen);
+        svcrdma_assert(pos <= reqlen);
 
         /* sanity check */
         msg = &req->msg;
         if (msg->rdma_vers != RDMA_VERS) {
-                svc_errx("version mismatched, %d/%d",
+                svcrdma_errx("version mismatched, %d/%d",
                          msg->rdma_vers, RDMA_VERS);
                 rc = RDMA_ERR_VERS;
                 goto out;
         }
 
         /* handle chunks */
-        switch(msg->rdma_body.u.proc) {
+        switch(msg->rdma_body.rdma_proc) {
         case RDMA_MSG: {
                 struct rdma_header_msg *header_msg;
 
                 header_msg = &msg->rdma_body.u.rdma_msg;
                 req->reads = header_msg->rdma_reads;
                 req->writes = header_msg->rdma_writes;
-                req->reply = header_msg->rdma_reply;
-                if (req->reads) {
-                        struct rdma_read_list *list = req->reads;
-                        req->chunk_start = list->entry.position;
-                        req->chunk_len   = list->entry.target.length;
-                        while (list->next) {
-                                list = list->next;
-                                req->chunk_len += list->entry.target.length;
-                        }
-                }
 
                 /* setup rpc message base */
                 req->rpcbuf_len  = reqlen - pos;
                 req->rpcbuf_base = req->buffer + pos;
-                req->curpos  = 0;
                 break;
         }
         case RDMA_NOMSG: {
-                struct rdma_header_msg *header_nomsg;
-                struct rdma_read_list *rpcmsg;
-                int lenth;
+                struct rdma_header_nomsg *header_nomsg;
+                struct rdma_read_list *rl;
+                int length;
 
                 header_nomsg = &msg->rdma_body.u.rdma_nomsg;
                 req->reads = header_nomsg->rdma_reads;
                 req->writes = header_nomsg->rdma_writes;
-                req->reply = header_nomsg->rdma_reply;
 
-                rpcmsg = req->reads;
-                svc_assert(rpcmsg->entry.position == 0);
-                length = rpcmsg->entry.target.length;
+                rl = req->reads;
+                svcrdma_assert(rl->rrl_entry.rrc_position == 0);
+                length = rl->rrl_entry.rrc_target.rs_length;
                 req->rpcbuf_len = length;
-                req->rpcbuf_base = mem_alloc(length);
+                req->rpcbuf_base = c2_alloc(length);
 
                 rc = -ENOMEM;
                 if (req->rpcbuf_base) {
                         rc = rdma_read_chunks(req, req->rpcbuf_base,
                                               req->rpcbuf_len);
                         if (rc < 0)
-                                mem_free(req->rpcbuf_base);
+                                c2_free(req->rpcbuf_base);
                 }
-                req->curpos  = 0;
                 break;
         }
         case RDMA_DONE:
                 /* reply chunk finished, not support */
-                svc_assert(0);
+                svcrdma_assert(0);
                 break;
         case RDMA_MSGP:
         case RDMA_ERROR:
@@ -930,6 +832,21 @@ static int rdma_recv_completion(struct svcrdma_xprt *xprt,
         if (rc < 0)
                 goto out;
 
+        /* get total length of rdma chunks. */
+        if (req->reads) {
+                struct rdma_read_list *list = req->reads;
+                struct rdma_read_chunk *chunk = &list->rrl_entry;
+
+                svcrdma_assert(chunk->rrc_position != 0);
+                req->chunk_start = chunk->rrc_position;
+                req->chunk_len   = chunk->rrc_target.rs_length;
+                while (list->rrl_next) {
+                        list = list->rrl_next;
+                        chunk = &list->rrl_entry;
+                        req->chunk_len += chunk->rrc_target.rs_length;
+                }
+        }
+
         /* the header of RDMA chunks looks fine, just set the XDR stream */
         xdrmem_create(&req->xdrs, req->rpcbuf_base, req->rpcbuf_len,
                        XDR_DECODE);
@@ -948,18 +865,6 @@ out:
         return rc;
 }
 
-/* context to track rdma read and write */
-#define CTXT_MAX_MRS    256
-struct rdma_context {
-        struct c2_ref        ref;
-        void               (*completion)(struct rdma_context *, void *);
-        void                *ctx;
-        struct svcrdma_xprt *xprt;
-        int                  max_index;
-        int                  index;
-        struct ibv_mr       *mrs[CTXT_MAC_MRS];
-};
-
 static void rdma_completion(struct c2_ref *);
 static void rdma_context_init(struct rdma_context *ctxt,
                               struct svcrdma_xprt *xprt,
@@ -987,16 +892,15 @@ static void rdma_completion_rw(struct rdma_context *ctxt, void *unused)
 
 static void rdma_completion(struct c2_ref *ref)
 {
-        struct rdma_context *ctxt = contain_of(ref, struct rdma_context, ref);
-        ctxt = ctxt;
+        struct rdma_context *ctxt = container_of(ref, struct rdma_context, ref);
+
         if (ctxt->completion)
-                ctxt->completion(ctxt, ctx);
+                ctxt->completion(ctxt, ctxt->ctx);
         /* TODO: in multiple thread env, we then wake handling thread up. */
 }
 
-void rdma_completion_one(void *args)
+void rdma_completion_one(struct rdma_context *ctxt)
 {
-        struct rdma_context *ctxt = args;
         c2_ref_put(&ctxt->ref);
 }
 
@@ -1012,34 +916,34 @@ static int rdma_wait_for_completion(struct rdma_context *ctxt)
         if (ncount == 0)
                 return 0;
 
-        svc_assert(ncount <= ctxt->max_index);
+        svcrdma_assert(ncount <= ctxt->max_index);
 
 again:
         if (ibv_get_cq_event(xprt->channel, &ecq, &ectx) != 0) {
-                svc_errx("get cq_event for xprt %p\n", xp);
+                svcrdma_errx("get cq_event for xprt %p\n", xprt);
                 return -errno;
         }
-        svc_assert(ecq == xprt->cq && ectx == xrpt);
-        if (ibv_req_notify_events(xprt->cp, 0))
-                svc_errx("failed to set up notification");
+        svcrdma_assert(ecq == xprt->cq && ectx == xprt);
+        if (ibv_req_notify_cq(xprt->cq, 0))
+                svcrdma_errx("failed to set up notification");
         ibv_ack_cq_events(xprt->cq, 1);
         while (1) {
-                rc = ibv_poll_cq(xp->cq, 1, &wc);
+                rc = ibv_poll_cq(xprt->cq, 1, &wc);
                 if (rc == 0) {         /* no event pending any more */
                         break;
-                } else if (rc < 0) /* error occurs */
-                        svc_errx("error occurs polling cq");
+                } else if (rc < 0) {   /* error occurs */
+                        svcrdma_errx("error occurs polling cq");
                         break;
                 }
 
                 ncount--;
-                svc_assert(rc == 1);
+                svcrdma_assert(rc == 1);
                 if (wc.status != IBV_WC_SUCCESS) {
-                        svc_error("cq error %s\n", ibv_wc_status_str(rc));
+                        svcrdma_errx("cq error %s\n", ibv_wc_status_str(rc));
                         rc = -1;
                         break;
                 }
-                svc_assert(wc->wr_id == (uint64_t)ctxt);
+                svcrdma_assert(wc.wr_id == (uint64_t)ctxt);
                 rdma_completion_one(ctxt);
         }
         if (rc == 0 && ncount)
@@ -1052,8 +956,8 @@ static struct ibv_mr *do_rdma_post(struct rdma_context *ctxt,
                                    char *buffer, enum ibv_wr_opcode opc)
 {
         struct ibv_sge sge = {
-                .addr   = buffer,
-                .length = seg->length
+                .addr   = (uint64_t)buffer,
+                .length = seg->rs_length
         };
         struct ibv_send_wr wr = {
                 .wr_id      = (uint64_t)ctxt,
@@ -1063,29 +967,30 @@ static struct ibv_mr *do_rdma_post(struct rdma_context *ctxt,
                 .send_flags = 0, /* IBV_SEND_SIGNALED; */
                 .wr = {
                         .rdma = {
-                                .remote_addr = seg->offset,
-                                .rkey        = seg->handle
+                                .remote_addr = seg->rs_offset,
+                                .rkey        = seg->rs_handle
                         }
                 }
         };
         struct ibv_send_wr *badwr;
         struct ibv_mr *mr;
         int flags;
+        int rc;
 
-
-        svc_assert(opc == IBV_WR_RDMA_READ || opc == IBV_WR_RDMA_WRITE);
-        flags = IBV_ACCESS_REMOTE_WRITE|IBV_ACCESS_REMOGE_READ;
-        mr = ibv_reg_mr(ctxt->xprt->pd, buffer, seg->length, flags);
+        svcrdma_assert(opc == IBV_WR_RDMA_READ || opc == IBV_WR_RDMA_WRITE);
+        flags = IBV_ACCESS_REMOTE_WRITE|IBV_ACCESS_REMOTE_READ;
+        mr = ibv_reg_mr(ctxt->xprt->pd, buffer, seg->rs_length, flags);
         if (mr == NULL) {
-                svc_errx("register memory error, this may be due to not locking"
-                         " enough memory");
+                svcrdma_errx("register memory error, this may be due to not"
+                             " locking enough memory");
                 return NULL;
         }
 
         sge.lkey = mr->lkey;
         rc = ibv_post_send(ctxt->xprt->qp, &wr, &badwr);
         if (rc != IBV_WC_SUCCESS) {
-                svc_errx("post RDMA buffer error %s\n", ibv_wc_status_err(rc));
+                svcrdma_errx("post RDMA buffer error %s\n",
+                             ibv_wc_status_str(rc));
                 ibv_dereg_mr(mr);
                 return NULL;
         }
@@ -1098,32 +1003,31 @@ static struct ibv_mr *do_rdma_post(struct rdma_context *ctxt,
  * be in the RDMA chunks, RDMA transfer will be used to copy data into the
  * buffer directly.
  */
-int rdma_read_chunks(struct rdma_request *req, char *buffer, int buflen)
+static int rdma_read_chunks(struct rdma_request *req, char *buffer, int buflen)
 {
         struct rdma_context *ctxt;
-        struct rdma_read_list *next,
+        struct rdma_read_list *rl;
         struct ibv_mr *mr;
         struct rdma_segment *seg;
-        int len;
-        int nr_segs = 0;
         int ncount = buflen;
+        int rc = 0;
 
         ctxt = alloca(sizeof(*ctxt));
         rdma_context_init(ctxt, req->xprt, rdma_completion_rw, (void *)req);
-        next = req->reads;
-        while (next && buflen) {
-                seg = &next->entry.target;
-                svc_assert(buflen >= seg->length);
+        rl= req->reads;
+        while (rl && buflen) {
+                seg = &rl->rrl_entry.rrc_target;
+                svcrdma_assert(buflen >= seg->rs_length);
                 mr = do_rdma_post(ctxt, seg, buffer, IBV_WR_RDMA_READ);
                 if (mr == NULL) {
                         int retry = !!ctxt->index;
 
                         rc = rdma_wait_for_completion(ctxt);
                         if (rc) {
-                                svc_errx("wait for RDMA read failed");
+                                svcrdma_errx("wait for RDMA read failed");
                                 break;
                         }
-                        svc_assert(c2_ref_get(&ctxt->ref) == 0);
+                        svcrdma_assert(c2_ref_read(&ctxt->ref) == 0);
 
                         rc = -EAGAIN;
                         if (retry)
@@ -1138,25 +1042,25 @@ int rdma_read_chunks(struct rdma_request *req, char *buffer, int buflen)
                 if (ctxt->index == ctxt->max_index - 1) {
                         rc = rdma_wait_for_completion(ctxt);
                         if (rc) {
-                                svc_errx("wait for RDMA read failed");
+                                svcrdma_errx("wait for RDMA read failed");
                                 break;
                         }
-                        svc_assert(c2_ref_get(&ctxt->ref) == 0);
+                        svcrdma_assert(c2_ref_read(&ctxt->ref) == 0);
                 }
 
-                buffer += seg->length;
-                buflen -= seg->length;
-                svc_assert(ncount >= 0);
-                next = next->next;
+                buffer += seg->rs_length;
+                buflen -= seg->rs_length;
+                svcrdma_assert(ncount >= 0);
+                rl = rl->rrl_next;
         }
         if (rc)
                 goto out;
 
-        svc_assert(buflen == 0);
+        svcrdma_assert(buflen == 0);
         if (ctxt->index)
                 rc = rdma_wait_for_completion(ctxt);
         if (rc == 0)
-                req->reads = next;
+                req->reads = rl;
 
 out:
         return rc;
@@ -1165,29 +1069,30 @@ out:
 /**
  * rdma_write_chunks: Write chunks to reply stream.
  */
-int rdma_write_chunks(struct rdma_reply *rep, char *buffer, int buflen)
+int rdma_write_chunks(struct rdma_reply *reply, char *buffer, int buflen)
 {
         struct rdma_context *ctxt;
-        struct rdma_write_list *next,
-        struct rdma_write_list *tmp;
+        struct rdma_write_list *wl;
         struct rdma_write_chunk *chunk;
         struct rdma_segment *seg;
         struct ibv_mr *mr;
+        int start_index;
+        int rc = 0;
 
         ctxt = alloca(sizeof(*ctxt));
-        rdma_context_init(ctxt, rep->xprt, rdma_completion_rw, (void*)rep);
+        rdma_context_init(ctxt, reply->xprt, rdma_completion_rw, (void*)reply);
 
-        next = reply->writes;
+        wl = reply->writes;
         start_index = reply->writes_index;
-        while (next && buflen) {
+        while (wl && buflen) {
                 int i;
 
-                chunk = &next->entry;
-                for (i = start_index; i < chunk->nr_segs && buflen; i++) {
-                        seg = &chunk->segs[i];
-                        if (buflen < seg->length) {
+                chunk = &wl->rwl_entry;
+                for (i = start_index; i < chunk->rwc_nr_segs && buflen; i++) {
+                        seg = &chunk->rwc_segs[i];
+                        if (buflen < seg->rs_length) {
                                 buflen = 0;
-                                seg->length = buflen;
+                                seg->rs_length = buflen;
                         }
                         mr = do_rdma_post(ctxt, seg, buffer, IBV_WR_RDMA_WRITE);
                         if (mr == NULL) {
@@ -1195,10 +1100,10 @@ int rdma_write_chunks(struct rdma_reply *rep, char *buffer, int buflen)
 
                                 rc = rdma_wait_for_completion(ctxt);
                                 if (rc) {
-                                        svc_errx("wait for RDMA read failed");
+                                        svcrdma_errx("RDMA write failed");
                                         break;
                                 }
-                                svc_assert(c2_ref_get(&ctxt->ref) == 0);
+                                svcrdma_assert(c2_ref_read(&ctxt->ref) == 0);
 
                                 rc = -EAGAIN;
                                 if (!retry)
@@ -1216,68 +1121,68 @@ int rdma_write_chunks(struct rdma_reply *rep, char *buffer, int buflen)
                         if (ctxt->index == ctxt->max_index - 1) {
                                 rc = rdma_wait_for_completion(ctxt);
                                 if (rc) {
-                                        svc_errx("wait for RDMA read failed");
+                                        svcrdma_errx("RDMA write failed");
                                         break;
                                 }
                         }
 
-                        buffer += seg->length;
-                        buflen -= seg->length;
-                        svc_assert(buflen >= 0);
+                        buffer += seg->rs_length;
+                        buflen -= seg->rs_length;
+                        svcrdma_assert(buflen >= 0);
                 }
                 if (rc)
                         break;
 
                 if (!buflen) {
-                        if (i == chunk->nr_segs) {
-                                rep->writes_index = 0;
-                                next = next->next;
+                        if (i == chunk->rwc_nr_segs) {
+                                reply->writes_index = 0;
+                                wl = wl->rwl_next;
                         } else {
-                                rep->writes_index = i;
+                                reply->writes_index = i;
                         }
                         break;
                 }
 
-                rep->writes_index = 0;
-                next = next->next;
+                reply->writes_index = 0;
+                wl = wl->rwl_next;
         }
         if (rc)
                 goto out;
 
-        svc_assert(buflen == 0);
+        svcrdma_assert(buflen == 0);
         if (ctxt->index)
                 rc = rdma_wait_for_completion(ctxt);
         if (rc == 0)
-                req->writes = next;
+                reply->writes = wl;
 
 out:
         return rc;
 }
 
-void rdma_fixup_write_chunks(struct rdma_reply *reply)
+static void rdma_fixup_write_chunks(struct rdma_reply *reply)
 {
         struct rdma_segment *seg;
-        struct rdma_write_list *list = reply->writes;
+        struct rdma_write_list *wl = reply->writes;
         int index = reply->writes_index;
         int i;
 
-        while (list) {
-                for (i = index; i < list->entry.nr_segs; i++) {
-                        seg = &list->entry.segs[i];
-                        seg->length = 0;
+        while (wl) {
+                for (i = index; i < wl->rwl_entry.rwc_nr_segs; i++) {
+                        seg = &wl->rwl_entry.rwc_segs[i];
+                        seg->rs_length = 0;
                 }
                 index = 0;
-                list = list->next;
+                wl = wl->rwl_next;
         }
 }
 
 static void rdma_reply_completion(struct rdma_context *ctxt, void *args)
 {
-        svcrdma_put_reply(reply);
+        svcrdma_put_reply((struct rdma_reply *)args);
         ctxt->index = 0;
 }
 
-int rdma_send_reply(struct rdma_reply *reply)
+static int rdma_send_reply(struct rdma_reply *reply)
 {
         struct rdma_context *ctxt;
         struct ibv_sge sge[2];
@@ -1286,19 +1191,19 @@ int rdma_send_reply(struct rdma_reply *reply)
         int nr_sges = 1;
         int rc;
 
-        svc_assert(rdma_buflen != 0);
-        sge[0].addr   = reply->rdma_buf;
+        svcrdma_assert(reply->rdma_buflen != 0);
+        sge[0].addr   = (uint64_t)reply->rdma_buf;
         sge[0].length = reply->rdma_buflen;
         sge[0].lkey   = reply->rdma_mr->lkey;
 
         if (reply->rpc_buflen) {
-                sge[1].addr   = reply->rpc_buf;
+                sge[1].addr   = (uint64_t)reply->rpc_buf;
                 sge[1].length = reply->rpc_buflen;
                 sge[1].lkey   = reply->rpc_mr->lkey;
                 nr_sges++;
         }
 
-        ctxt = alloca(*ctxt);
+        ctxt = alloca(sizeof(*ctxt));
         rdma_context_init(ctxt, reply->xprt,
                           rdma_reply_completion, (void*)reply);
 
@@ -1307,9 +1212,9 @@ int rdma_send_reply(struct rdma_reply *reply)
         wr.num_sge = nr_sges;
         wr.opcode = IBV_WR_SEND;
         wr.send_flags = IBV_SEND_SIGNALED;
-        rc = ibv_post_send(reply->xprt, &wr, &badwr);
+        rc = ibv_post_send(reply->xprt->qp, &wr, &badwr);
         if (rc) {
-                svc_errx("post reply buffer error\n");
+                svcrdma_errx("post reply buffer error\n");
                 return rc;
         }
 
diff --git a/net/usunrpc/rfc5666/svc_rdma.h b/net/usunrpc/rfc5666/svc_rdma.h
index 382caee..86ef2b3 100644
--- a/net/usunrpc/rfc5666/svc_rdma.h
+++ b/net/usunrpc/rfc5666/svc_rdma.h
@@ -38,7 +38,7 @@ SVCXPRT *svcrdma_create(struct sockaddr_in *sa, struct svcrdma_config *cfg);
 /**
   a standard xdr function for c2_dbuf in rdma case.
  */
-bool_t   xdr_rdma_chunks(XDRS *xdrs, char *buffer, int buflen);
+bool_t   xdr_rdma_chunks(XDR *xdrs, char *buffer, int buflen);
 
 /** @} end group svcrdma */
 
diff --git a/net/usunrpc/rfc5666/svc_rdma_internal.h b/net/usunrpc/rfc5666/svc_rdma_internal.h
index 214809c..6b716f2 100644
--- a/net/usunrpc/rfc5666/svc_rdma_internal.h
+++ b/net/usunrpc/rfc5666/svc_rdma_internal.h
@@ -5,8 +5,12 @@
 #include <rpc/rpc.h>
 #include <errno.h>
 #include <rdma/rdma_cma.h>
+#include <infiniband/verbs.h>
 
-#include <libs/list.h>
+#include "lib/list.h"
+#include "lib/mutex.h"
+#include "lib/refs.h"
+#include "lib/memory.h"
 #include "rfc5666.h"
 
 /* internal data structures. */
@@ -117,7 +121,7 @@
  */
 
 /** RFC5666 has only version 1 supported. */
-#define RDMA_VERS       (xdr_one)
+#define RDMA_VERS       (htons(1))
 
 enum rdma_xprt_status {
         RDMA_XPRT_INIT   = 0, /**< init state */
@@ -259,7 +263,7 @@ struct rdma_reply {
         struct rdma_write_list  *writes; /**< write chunks, copied from rqst */
         struct rdma_write_chunk *reply;  /**< reply chunks */
         int                      writes_index;
-        XDRS                     xdrs;   /**< used for encoding message */
+        XDR                      xdrs;   /**< used for encoding message */
 
         /**
           Preallocated buffers for reply message.
@@ -269,8 +273,8 @@ struct rdma_reply {
           before rpc message is composed.
          */
         void              *rdma_buf;    /**< buffer to store rdma header */
-        int                rdma_buflen; /**< rdma header for the reply msg */
         void              *rpc_buf;     /**< buffer to store rpc message */
+        int                rdma_buflen; /**< rdma header for the reply msg */
         int                rpc_buflen;  /**< rpc message buffer */
         struct ibv_mr     *rdma_mr;     /**< memory region for rdma buffer */
         struct ibv_mr     *rpc_mr;      /**< memory region for rpc msg */
@@ -332,6 +336,29 @@ struct rdma_request {
         struct ibv_sge        sge;
 };
 
+/* context to track rdma read and write */
+#define CTXT_MAX_MRS    256
+
+/**
+  Data structure handles async completion event for rdma write/send.
+
+  For each ibv_send_wr, the wr_id is assigned to point to an rdma_context,
+  in this way, it's easy to cleanup things after an rdma write/send finishes.
+ */
+struct rdma_context {
+        struct c2_ref        ref;
+        void               (*completion)(struct rdma_context *, void *);
+        void                *ctx;
+        struct svcrdma_xprt *xprt;
+        int                  max_index;
+        int                  index;
+        struct ibv_mr       *mrs[CTXT_MAX_MRS];
+};
+
+#include <err.h>
+#define svcrdma_errx(fmt, args...)      errx(1, fmt, ##args)
+#define svcrdma_assert(expr)            C2_ASSERT(expr)
+
 /** @} end group svcrdma */
 
 #endif /* ifndef _SVC_RDMA_INTERNAL_H_ */
diff --git a/net/usunrpc/usunrpc.h b/net/usunrpc/usunrpc.h
index de64082..5c3c0e5 100644
--- a/net/usunrpc/usunrpc.h
+++ b/net/usunrpc/usunrpc.h
@@ -34,8 +34,9 @@ void usunrpc_fini(void);
   @retval TRUE    - success
   @retval FALSE   - something wrong
  */
-bool_t c2_xdr_dbuf (XDRS *xdrs, struct c2_dbuf *dbuf,
-                    bool_t (*xdr)(XDRS *, char *, int));
+struct c2_dbuf;
+bool_t c2_xdr_dbuf (XDR *xdrs, struct c2_dbuf *dbuf,
+                    bool_t (*xdrproc)(XDR *, char *, int));
 
 /** @} end of group usunrpc */
 
diff --git a/net/usunrpc/uxdr.c b/net/usunrpc/uxdr.c
index 24cc56c..3273dc8 100644
--- a/net/usunrpc/uxdr.c
+++ b/net/usunrpc/uxdr.c
@@ -5,6 +5,8 @@
 
 #include "lib/cdefs.h"
 #include "lib/assert.h"
+#include "lib/vec.h"
+#include "lib/memory.h"
 #include "fop/fop.h"
 
 #include "usunrpc.h"
@@ -152,24 +154,25 @@ bool_t c2_fop_uxdrproc(XDR *xdrs, struct c2_fop *fop)
 /*
  */
 bool_t xdr_dbuf(XDR *xdrs, struct c2_dbuf *dbuf,
-                bool_t (*xdr)(XDRS *, char *buffer, int buflen))
+                bool_t (*xdrproc)(XDR *, char *buffer, int buflen))
 {
-        if (!xdr_u_int(xdrs, &dbuf->alignment))
+        if (!xdr_u_int(xdrs, &dbuf->db_alignment))
                 return FALSE;
-        if (!xdr_u_int(xdrs, &dbuf->buflen))
+        if (!xdr_u_int(xdrs, &dbuf->db_buflen))
                 return FALSE;
 
         switch(xdrs->x_op) {
         case XDR_DECODE:
-                if (posix_memalign(&dbuf->buffer, dbuf->alignment,
-                                   dbuf->buflen))
+                dbuf->db_buffer = c2_alloc_align(dbuf->db_buflen,
+                                                 dbuf->db_alignment);
+                if (dbuf->db_buffer == NULL)
                         return FALSE;
         case XDR_ENCODE:
-                if (xdr)
-                        return xdr(xdrs, dbuf->buffer, dbuf->buflen);
-                return xdr_opaque(xdrs, dbuf->buffer, dbuf->buflen);
+                if (xdrproc)
+                        return xdrproc(xdrs, dbuf->db_buffer, dbuf->db_buflen);
+                return xdr_opaque(xdrs, dbuf->db_buffer, dbuf->db_buflen);
         case XDR_FREE:
-                mem_free(dbuf->buffer);
+                c2_free(dbuf->db_buffer);
                 return TRUE;
         }
         return FALSE;
-- 
1.8.3.2

