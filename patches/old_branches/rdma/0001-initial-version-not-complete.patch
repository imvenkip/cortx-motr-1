From ef27827cb086d8b531dfa2cc0c5f3619cf2af42f Mon Sep 17 00:00:00 2001
From: "jinshan.xiong" <jinshan.xiong@clusterstor.com>
Date: Fri, 25 Jun 2010 10:46:35 -0600
Subject: [PATCH 01/34] initial version - not complete

---
 net/usunrpc/rfc5666/svc_rdma.c | 434 +++++++++++++++++++++++++++++++++++++++++
 1 file changed, 434 insertions(+)
 create mode 100644 net/usunrpc/rfc5666/svc_rdma.c

diff --git a/net/usunrpc/rfc5666/svc_rdma.c b/net/usunrpc/rfc5666/svc_rdma.c
new file mode 100644
index 0000000..d4af8eb
--- /dev/null
+++ b/net/usunrpc/rfc5666/svc_rdma.c
@@ -0,0 +1,434 @@
+
+#include <stdio.h>
+#include <unistd.h>
+#include <string.h>
+#include <libintl.h>
+#include <rpc/rpc.h>
+#include <sys/socket.h>
+#include <sys/poll.h>
+#include <errno.h>
+#include <stdlib.h>
+
+#ifdef USE_IN_LIBIO
+# include <wchar.h>
+# include <libio/iolibio.h>
+#endif
+
+
+enum rdma_xprt_status {
+        RDMA_XPRT_INIT   = 0,
+        RDMA_XPRT_LISTEN,
+        RDMA_XPRT_CONNECTING,
+        RDMA_XPRT_ESTABLISHED,
+        RDMA_XPRT_DESTROYED
+};
+
+/*
+ * svcrdma_export for listener
+ */
+struct svcrndzv_xprt {
+        SVCXPRT                    svcxprt;
+        struct rdma_cm_id         *cmid;
+        struct rdma_event_channel *channel;
+        enum rdma_xprt_status      status;
+
+        /* rdma parameters are stored here. */
+        int trans;
+        int port;
+        int max_send_wr;
+        int max_recv_wr;
+        int max_send_sge;
+        int max_recv_sge;
+        int rc_retry_cnt;
+        int rc_rnr_retry_cnt;
+        int max_msg_size;
+
+        /* exports have been accepted. */
+        struct c2_list             xprts;
+};
+
+struct svcrdma_reply {
+        struct ibv_send_wr wr;
+        struct ibv_sge     sge;
+};
+
+struct svcrdma_request {
+        int                   reqlen;
+        struct svcrdma_xprt  *xprt;
+        struct svcrdma_reply *reply;
+
+        struct ibv_recv_wr    wr;
+        struct ibv_sge        sge;
+};
+
+/*
+ *
+ */
+struct svcrdma_xprt {
+        struct c2_list_link   link;
+        SVCXPRT               svcxprt;
+        struct svcrndzv_xprt *rndzv;
+        struct rdma_cm_id    *cmid;
+
+        /* queue pair information */
+        struct ibv_comp_channel *channel;
+        struct ibv_pd           *pd;
+        struct ibv_cq           *cq;
+        struct ibv_qp           *qp;
+
+        /* buffers used by this xprt. */
+        struct svcrdma_request  *rcv;
+        struct svcrdma_reply    *snd;
+
+        /* attribute of this xprt */
+        enum rdma_xprt_status    status;
+        XDR                      xdrs;
+};
+
+static void svcrdma_xprt_destroy (struct svcrdma_xprt *xprt);
+/*
+ * Ops vector for TCP/IP based rpc service handle
+ */
+static bool_t svcrdma_recv (SVCXPRT *, struct rpc_msg *);
+static enum xprt_stat svcrdma_stat (SVCXPRT *);
+static bool_t svcrdma_getargs (SVCXPRT *, xdrproc_t, caddr_t);
+static bool_t svcrdma_reply (SVCXPRT *, struct rpc_msg *);
+static bool_t svcrdma_freeargs (SVCXPRT *, xdrproc_t, caddr_t);
+static void svcrdma_destroy (SVCXPRT *);
+
+static const struct xp_ops svcrdma_op = {
+        svcrdma_recv,
+        svcrdma_stat,
+        svcrdma_getargs,
+        svcrdma_reply,
+        svcrdma_freeargs,
+        svcrdma_destroy
+};
+
+/*
+ * Ops vector for TCP/IP rendezvous handler
+ */
+static bool_t rendezvous_request (SVCXPRT *, struct rpc_msg *);
+static enum xprt_stat rendezvous_stat (SVCXPRT *);
+static void rendezvous_abort (void) __attribute__ ((__noreturn__));
+
+/* This function makes sure abort() relocation goes through PLT
+   and thus can be lazy bound.  */
+static void rendezvous_abort (void)
+{
+        abort ();
+};
+
+static const struct xp_ops svcrdma_rendezvous_op = {
+        rendezvous_request,
+        rendezvous_stat,
+        (bool_t (*) (SVCXPRT *, xdrproc_t, caddr_t)) rendezvous_abort,
+        (bool_t (*) (SVCXPRT *, struct rpc_msg *)) rendezvous_abort,
+        (bool_t (*) (SVCXPRT *, xdrproc_t, caddr_t)) rendezvous_abort,
+        rendezvous_destroy
+};
+
+SVCXPRT *svcrdma_create (int port)
+{
+        SVCXPRT *svcxprt;
+        struct svcrndzv_xprt *xp;
+        struct sockaddr_in saddr = {
+                .sin_family      = AF_INET,
+                .sin_addr.s_addr = htonl(INADDR_ANY),
+                .sin_port        = htons(port)
+        };
+
+        xp = mem_alloc(sizeof(*xp));
+        if (xp == NULL) {
+                svc_errx("no memory\n");
+                return NULL;
+        }
+        memset(xp, 0, sizeof(*xp));
+        xp->status = RDMA_XPRT_LISTEN;
+
+        xp->channel = rdma_create_event_channel();
+        if (xp->channel == NULL) {
+                svc_errx("rdma_create_event channel failed\n");
+                goto out;
+        }
+
+        /* XXX: Only RC mode is supported right now */
+        xp->trans = IBV_QPT_RC;
+        xp->port  = port;
+        xp->max_send_wr = 32;
+        xp->max_recv_wr = 32;
+        xp->max_send_sge = 1;
+        xp->max_recv_sge = 1;
+        xp->rc_retry_cnt = 8;
+        xp->rc_rnr_retry_cnt = 8;
+
+        /* suppose the maximum message size is 1 page. */
+        xp->max_msg_size = 4096;
+
+        if (rdma_create_id(xp->channel, &xp->cmid, 0, RDMA_RS_TCP)) {
+                svc_errx("rdma_create_id failed\n");
+                goto out;
+        }
+
+        if (rdma_bind_addr(xp->cmid, (struct sockaddr *)&saddr)) {
+                svc_errx("bind address error\n");
+                goto out;
+        }
+
+        xp->status = RDMA_XPRT_LISTEN;
+        if (rdma_listen(xp->cmid, 0)) {
+                svc_errx("listen error\n");
+                goto out;
+        }
+
+        /* Now initiate SVCXPRT stuffs. */
+        svcxprt = xp->svcxprt;
+        svcxprt->xp_p1 = xp;
+        svcxprt->xp_ops = &svcrdma_rendezvous_op;
+        svcxprt->xp_port = port;
+        svcxprt->xp_sock = xp->channel->fd;
+
+        xprt_register(svcxprt);
+        return svcxprt;
+
+out:
+        if (xp->cmid)
+                rdma_destroy_id(xp->cmid);
+        if (xp->channel)
+                rdma_destroy_event_channel(xp->channel);
+        mem_free(xp);
+        return NULL;
+}
+
+static int svcrdma_handle_connection(struct svcrndzv_xprt *xp,
+                                     struct rdma_cm_event *ev)
+{
+        SVCXPRT *svcxprt;
+        struct svcrdma_xprt *xprt;
+        struct rdma_cm_id *cmid = ev->id;
+        struct ibv_context *verbs = cmid->verbs;
+        struct ibv_qp_init_attr attr = { 0 };
+        struct rdma_conn_param param = { 0 };
+
+        xprt = mem_alloc(sizeof(*xprt));
+        if (xprt == NULL)
+                return -ENOMEM;
+
+        memset(xprt, 0, sizeof *xprt);
+        c2_list_link_init(&xprt->link);
+        xprt->rndzv = xp;
+        xprt->cmid  = cmid;
+
+        /* create queue pair */
+        xprt->channel = ibv_create_comp_channel(verbs);
+        if (xprt->channel == NULL)
+                goto out;
+
+        xprt->pd = ibv_alloc_pd(verbs);
+        if (xprt->pd == NULL)
+                goto out;
+
+        xprt->cq = ibv_create_cq(verbs, xp->max_send_wr + xp->max_recv_wr,
+                                 0, xprt->channel, 0);
+        if (xprt->cq == NULL)
+                goto out;
+
+        attr.send_cq = xprt->cq;
+        attr.recv_cq = xprt->cq;
+        attr.cap.max_send_wr = xp->max_send_wr;
+        attr.cap.max_recv_wr = xp->max_recv_wr;
+        attr.cap.max_send_sge = xp->max_send_sge;
+        attr.cap.max_recv_sge = xp->max_recv_sge;
+        attr.qp_type = xp->trans;
+        if (rdma_create_qp(cmid, xp->pd, &attr) != 0)
+                goto out;
+
+        if (svcrdma_buffer_init(xprt) != 0)
+                goto out;
+
+        svc_assert(xp->trans == IBV_QPT_RC);
+        param.responder_resources = 1;
+        param.initiator_depth = 1;
+        param.rnr_retry_count = xp->rc_rnr_retry_cnt;
+        param.retry_count = xp->rc_retry_cnt;
+        if (rdma_connect(cmid, &param) != 0)
+                goto out;
+
+        /* great, everything sounds ok, register an xprt to svc */
+        svcxprt = &xprt->svcxprt;
+        svcxprt->xp_p1 = xprt;
+        svcxprt->xp_ops = &svcrdma_op;
+        svcxprt->xp_sock = xprt->channel->fd;
+        /* TODO: need to create xdr functions */
+        /* xdrrec_create(..) */
+        xprt_register(svcxprt);
+
+        /* add the xprt into linked list of listener */
+        xprt->status = RDMA_XPRT_CONNECTING;
+        c2_list_add_tail(&xp->xprts, &xprt->link);
+
+        return 0;
+
+out:
+        svcrdma_xprt_destroy(xprt);
+        return NULL; 
+}
+
+static inline struct svcrdma_xprt *xprt_find(struct svcrndzv_xprt *xp, struct rdma_cm_id *id)
+{
+        struct svcrdma_xprt *xprt;
+
+        c2_list_for_each_entry(xp->xprts, xprt, struct svcrdma_xprt, link) {
+                if (xprt->cmid == ev->id)
+                        return xprt;
+        }
+        return NULL;
+}
+
+static bool_t rendezvous_request (SVCXPRT *xprt, struct rpc_msg *errmsg)
+{
+        struct svcrndzv_xprt *xp = xprt->xp_p1;
+        struct rdma_cm_event *ev;
+        const char *msg;
+        int rc = 0;
+
+        if (rdma_get_cm_event(xp->channel, &ev)) {
+                svc_errx("get_cm_event error\n");
+                /* what can I do? */
+                abort();
+        }
+
+        /* disconnect is special, handle it first. */
+        if (ev->event == RDMA_CM_EVENT_DISCONNECTED) {
+                struct svcrdma_xprt *xprt = xprt_find(xp, ev->id);
+
+                svc_assert(ev->id != xp->cmid);
+                svc_assert(xprt != NULL);
+
+                (void)rdma_ack_cm_event(ev);
+                c2_list_del(&xprt->link);
+                if (xprt->svcxprt.xp_p1 == xprt)
+                        xprt_unregister(&xprt->svcxprt);
+                svcrdma_xprt_destroy(xprt);
+                return FALSE;
+        }
+
+        switch(ev->event) {
+        case RDMA_CM_EVENT_CONNECT_REQUEST:
+                svc_assert(ev->listen_id == xp->cmid);
+                svc_assert(xp->status == RDMA_XPRT_LISTEN);
+                rc = svcrdma_handle_connection(xp, ev);
+                break;
+
+        case RDMA_CM_EVENT_ESTABLISHED: {
+                struct svcrdma_xprt *xprt = xprt_find(xp, ev->id);
+
+                svc_assert(ev->id != xp->cmid);
+                svc_assert(xprt != NULL);
+                svc_assert(xprt->status == RDMA_XPRT_CONNECTING);
+                xprt->status == RDMA_XPRT_ESTABLISHED;
+                break;
+        }
+
+        case RDMA_CM_EVENT_DEVICE_REMOVAL:
+        case RDMA_CM_EVENT_ADDR_CHANGE:
+                svc_warnx("get event %s, ignored\n", msg);
+                break;
+
+        default:
+                svc_errx("Unknown event %s\n", rdma_event_str(ev->event));
+                break;
+        }
+
+        if (rc)
+                svc_errx("Handle event %s return error %d\n", rdma_event_str(ev->event), rc);
+
+        (void)rdma_ack_cm_event(ev);
+        return FALSE;
+}
+
+static enum xprt_stat rendezvous_stat (SVCXPRT *xprt)
+{
+        return XPRT_IDLE;
+}
+
+static void rendezvous_destroy(SVCXPRT *xprt)
+{
+        struct svcrndzv_xprt *xp = xprt->xp_p1;
+
+        xprt_unregister(xprt);
+        rdma_destroy_id(xp->cmid);
+        rdma_destroy_event_channel(xp->channel);
+        mem_free(xp);
+}
+
+static enum xprt_stat svcrdma_stat (SVCXPRT *xprt)
+{
+        return XPRT_IDLE;
+}
+
+static bool_t svcrdma_recv (SVCXPRT *xprt, struct rpc_msg *msg)
+{
+  struct tcp_conn *cd = (struct tcp_conn *) (xprt->xp_p1);
+  XDR *xdrs = &(cd->xdrs);
+
+  xdrs->x_op = XDR_DECODE;
+  (void) INTUSE(xdrrec_skiprecord) (xdrs);
+  if (INTUSE(xdr_callmsg) (xdrs, msg))
+    {
+      cd->x_id = msg->rm_xid;
+      return TRUE;
+    }
+  cd->strm_stat = XPRT_DIED;	/* XXXX */
+  return FALSE;
+}
+
+static bool_t svcrdma_getargs(SVCXPRT *xprt, xdrproc_t xdr_args, caddr_t args_ptr)
+{
+        struct svcrdma_xprt *xp = xprt->xp_p1;
+        return ((*xdr_args) (&xp->xdrs, args_ptr));
+}
+
+static bool_t svcrdma_freeargs (SVCXPRT *xprt, xdrproc_t xdr_args, caddr_t args_ptr)
+{
+  XDR *xdrs = &(((struct svcrdma_xprt*) (xprt->xp_p1))->xdrs);
+
+  xdrs->x_op = XDR_FREE;
+  return ((*xdr_args) (xdrs, args_ptr));
+}
+
+static bool_t
+svcrdma_reply (SVCXPRT *xprt, struct rpc_msg *msg)
+{
+  struct tcp_conn *cd = (struct tcp_conn *) (xprt->xp_p1);
+  XDR *xdrs = &(cd->xdrs);
+  bool_t stat;
+
+  xdrs->x_op = XDR_ENCODE;
+  msg->rm_xid = cd->x_id;
+  stat = INTUSE(xdr_replymsg) (xdrs, msg);
+  (void) INTUSE(xdrrec_endofrecord) (xdrs, TRUE);
+  return stat;
+}
+
+static void svcrdma_xprt_destroy (struct svcrdma_xprt *xprt)
+{
+        if (xprt->cmid->qp)
+                rdma_destroy_qp(cmid);
+        if (xprt->cq)
+                ibv_destroy_cq(xprt->cq);
+        if (xprt->pd)
+                ibv_dealloc_pd(xprt->pd);
+        if (xprt->channel)
+                ibv_destroy_comp_channel(xprt->channel);
+        rdma_destroy_id(xprt->cmid);
+        mem_free(xprt);
+}
+
+static void svcrdma_destroy(SVCXPRT *xprt)
+{
+        xprt_unregister(xprt);
+        svcrdma_xprt_destroy(xprt->xp_p1);
+}
+
+
-- 
1.8.3.2

