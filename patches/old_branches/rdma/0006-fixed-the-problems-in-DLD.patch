From 21acbb2521d34a0a8101c396637b02cd37eb0f12 Mon Sep 17 00:00:00 2001
From: "jinshan.xiong" <jinshan.xiong@clusterstor.com>
Date: Thu, 15 Jul 2010 17:51:50 -0600
Subject: [PATCH 06/34] - fixed the problems in DLD - code revised

---
 net/usunrpc/rfc5666/rfc5666.h           |  17 ++++
 net/usunrpc/rfc5666/svc_rdma.c          | 174 ++++++++++++++++++++++++++++----
 net/usunrpc/rfc5666/svc_rdma_internal.h |  57 +++++++----
 3 files changed, 207 insertions(+), 41 deletions(-)

diff --git a/net/usunrpc/rfc5666/rfc5666.h b/net/usunrpc/rfc5666/rfc5666.h
index fcd4960..46cbe46 100644
--- a/net/usunrpc/rfc5666/rfc5666.h
+++ b/net/usunrpc/rfc5666/rfc5666.h
@@ -1,5 +1,18 @@
+
+#ifndef _RFC5666_H_
+#define _RFC5666_H_
+
 #include <rpc/rpc.h>
+#include <libs/cdefs.h>
+
+/**
+  This file defines data structures needed by rdma. These data structures
+  are generated by XDR descriptors.
+  XXX: Need to revise.
 
+  @addtogroup svcrdma
+  @{
+ */
 struct rdma_segment {
         uint32_t handle;
         uint32_t length;
@@ -96,3 +109,7 @@ struct svcrdma_msg {
 
 /* the xdr functions */
 extern  bool_t xdr_svcrdma_msg (XDR *, struct svcrdma_msg *);
+
+/** @} endgroup svcrdma */
+
+#endif /* ifndef _RFC5666_H_ */
diff --git a/net/usunrpc/rfc5666/svc_rdma.c b/net/usunrpc/rfc5666/svc_rdma.c
index f7fe64a..2f17ebd 100644
--- a/net/usunrpc/rfc5666/svc_rdma.c
+++ b/net/usunrpc/rfc5666/svc_rdma.c
@@ -1,16 +1,15 @@
 
-#include <stdio.h>
-#include <unistd.h>
-#include <string.h>
-#include <libintl.h>
 #include <rpc/rpc.h>
 #include <sys/socket.h>
 #include <sys/poll.h>
 #include <errno.h>
 #include <stdlib.h>
 
-static int svcrdma_buffer_create(struct svcrdma_xprt *xprt);
-static void svcrdma_buffer_destroy(struct svcrdma_xprt *xprt);
+#include "svc_rdma_internal.h"
+#include "svc_rdma.h"
+
+static int svcrdma_buffer_create(struct svcrndzv_xprt *xprt);
+static void svcrdma_buffer_destroy(struct svcrndzv_xprt *xprt);
 static int rdma_recv_completion(struct svcrdma_xprt *xprt,
                                 struct ibv_wc *wc,
                                 struct rpc_msg *rpcmsg);
@@ -67,6 +66,7 @@ SVCXPRT *svcrdma_create (struct sockaddr_in *sa, struct svcrdma_config *cfg)
                 .sin_addr.s_addr = htonl(INADDR_ANY),
                 .sin_port        = htons(port)
         };
+        struct ibv_device_attr devattr;
 
         xp = mem_alloc(sizeof(*xp));
         if (xp == NULL) {
@@ -85,10 +85,8 @@ SVCXPRT *svcrdma_create (struct sockaddr_in *sa, struct svcrdma_config *cfg)
         /* XXX: Only RC mode is supported right now */
         xp->trans = IBV_QPT_RC;
         xp->port  = port;
-        xp->max_send_wr = 1; /* Now that only sync sunrpc request is support */
-        xp->max_recv_wr = 1;
-        xp->max_send_sge = 1;
-        xp->max_recv_sge = 1;
+        xp->max_send_sge = 2;
+        xp->max_recv_sge = 2;
         xp->rc_retry_cnt = 8;
         xp->rc_rnr_retry_cnt = 8;
 
@@ -108,6 +106,15 @@ SVCXPRT *svcrdma_create (struct sockaddr_in *sa, struct svcrdma_config *cfg)
                 goto out;
         }
 
+        /* get attribute of before doing anything else */
+        if (ibv_query_device(xp->cmid->verbs, &devattr)) {
+                svc_errx("query device error\n");
+                goto out;
+        }
+        xp->max_send_wr = devattr.max_qp_wr;
+        xp->max_recv_wr = devattr.max_qp_wr;
+        xp->credits = devattr.max_qp_wr - 1;
+
         if (rdma_bind_addr(xp->cmid, (struct sockaddr *)&saddr)) {
                 svc_errx("bind address error\n");
                 goto out;
@@ -138,6 +145,135 @@ out:
         return NULL;
 }
 
+static void svcrdma_buffer_destroy(struct svcrndzv_xprt *xprt)
+{
+        struct rdma_reply *reply;
+        int i;
+        int count;
+
+        count = xprt->rndzv->max_recv_wr;
+        if (xprt->rcv_bufs) {
+                for (i = 0; i < count; i++) {
+                        struct rdma_request *r = &xprt->rcv_bufs[i];
+
+                        if (r->buffer == NULL)
+                                break;
+                        free(r->buffer);
+
+                        if (r->mr == NULL)
+                                break;
+                        ibv_dereg_mr(r->mr);
+                }
+                mem_free(xprt->rcv_bufs);
+        }
+
+        reply = xprt->snd_bufs;
+        while (reply) {
+                struct rdma_reply *tmp = reply->next;
+
+                if (reply->buffer)
+                        free(reply->buffer);
+                if (reply->mr)
+                        ibv_dereg_mr(reply->mr);
+                mem_free(reply);
+                reply = tmp;
+        }
+}
+
+static int svcrdma_buffer_create(struct svcrndzv_xprt *xprt)
+{
+        struct rdma_request *req;
+        int nr;
+        int count;
+        int bufsize;
+        int rc;
+
+        /* for receive buffers. */
+        count = xprt->max_recv_wr;
+        req = mem_alloc(count * sizeof(*req));
+        if (req == NULL)
+                return -ENOMEM;
+
+        memset(req, 0, count * sizeof(*req));
+        xprt->rcv_bufs = req;
+
+        bufsize = xprt->max_msg_size;
+        for (i = 0; i < count; i++) {
+                struct rdma_request *r = &req[i];
+                struct ibv_recv_wr     *badwr;
+
+                r->xprt = NULL;
+                if (posix_memalign(&r->buffer, xprt->rndzv->page_size, bufsize))
+                        goto out;
+
+                r->mr = ibv_reg_mr(xprt->pd, r->buffer, bufsize,
+                                   xprt->rndzv->rcv_wr_flags);
+                if (!r->mr) {
+                        free(r->buffer);
+                        r->buffer = NULL;
+                        goto out;
+                }
+
+                /* register receive buffer */
+                r->sge.addr   = r->buffer;
+                r->sge.length = bufsize;
+                r->sge.lkey   = r->mr->lkey;
+                r->wr.wr_id   = (uint64_t)r;
+                r->wr.sg_list = &r->sge;
+                r->wr.num_sge = 1;
+                rc = ibv_post_recv(xprt->qp, &r->wr, &badwr);
+                if (rc) {
+                        ibv_dereg_mr(r->mr);
+                        free(r->buffer);
+                        r->buffer = NULL;
+                        goto out;
+                }
+        }
+
+        /* for send buffers. */
+        count = xprt->max_send_wr;
+        for (i = 0; i < count; i++) {
+                struct rdma_reply *reply;
+
+                reply = mem_alloc(sizeof(*reply));
+                if (!reply)
+                        goto out;
+                memset(reply, 0, sizeof(*reply));
+
+                posix_memalign(&reply->buffer, xprt->rndzv->page_size, bufsize * 2);
+                if (!reply->buffer) {
+                        mem_free(reply);
+                        goto out;
+                }
+
+                reply->rdma_mr = ibv_reg_mr(xprt->pd, reply->buffer, bufsize,
+                                            xprt->snd_wr_flags);
+                if (!reply->mr) {
+                        mem_free(reply);
+                        free(reply->buffer);
+                        goto out;
+                }
+
+                reply->rpc_mr = ibv_reg_mr(xprt->pd, )
+
+                reply->xprt = NULL;
+                reply->sge.addr = reply->buffer;
+                reply->sge.length = bufsize;
+                reply->sge.lkey = reply->mr->lkey;
+                reply->wr.wr_id = (uint64_t)reply;
+                reply->wr.sg_list = &reply->sge;
+                reply->num_sge = 1;
+
+                reply->next = xprt->snd_bufs;
+                xprt->snd_bufs = reply;
+        }
+
+        return 0;
+
+out:
+        svcrdma_buffer_destroy(xprt);
+}
+
 /**
  * svcrdma_handle_connection: Handle a new connecting request from client.
  *
@@ -502,7 +638,6 @@ static bool_t svcrdma_reply(SVCXPRT *svcxprt, struct rpc_msg *msg)
 
 static void svcrdma_xprt_destroy (struct svcrdma_xprt *xprt)
 {
-        svcrdma_buffer_destroy(xprt);
         if (xprt->cmid->qp)
                 rdma_destroy_qp(cmid);
         if (xprt->cq)
@@ -524,13 +659,13 @@ static void svcrdma_destroy(SVCXPRT *xprt)
 /**
  * buffer related routines.
  */
-static void svcrdma_buffer_destroy(struct svcrdma_xprt *xprt)
+static void svcrdma_buffer_destroy(struct svcrndzv_xprt *xprt)
 {
         struct rdma_reply *reply;
         int i;
         int count;
 
-        count = xprt->rndzv->max_recv_wr;
+        count = xprt->max_recv_wr;
         if (xprt->rcv_bufs) {
                 for (i = 0; i < count; i++) {
                         struct rdma_request *r = &xprt->rcv_bufs[i];
@@ -559,7 +694,7 @@ static void svcrdma_buffer_destroy(struct svcrdma_xprt *xprt)
         }
 }
 
-static int svcrdma_buffer_create(struct svcrdma_xprt *xprt)
+static int svcrdma_buffer_create(struct svcrndzv_xprt *xprt)
 {
         struct rdma_request *req;
         int nr;
@@ -628,16 +763,16 @@ static int svcrdma_buffer_create(struct svcrdma_xprt *xprt)
 
                 reply->rdma_buf = reply->buffer;
                 reply->rpc_buf = reply->buffer + bufsize;
-                reply->rdma_mr = ibv_reg_mr(xprt->pg, reply->rdma_buf, bufsize,
-                                            xprt->rndzv->snd_wr_flags);
+                reply->rdma_mr = ibv_reg_mr(xprt->pd, reply->buffer, bufsize,
+                                            xprt->snd_wr_flags);
                 if (!reply->rdma_mr) {
                         mem_free(reply);
                         free(reply->buffer);
                         goto out;
                 }
 
-                reply->rpc_mr = ibv_reg_mr(xprt->pg, reply->rpc_buf, bufsize,
-                                           xprt->rndzv->snd_wr_flags);
+                reply->rpc_mr = ibv_reg_mr(xprt->pd, reply->buffer + bufsize,
+                                           bufsize, xprt->snd_wr_flags);
                 if (reply->rpc_mr) {
                         mem_free(reply);
                         free(reply->buffer);
@@ -645,7 +780,7 @@ static int svcrdma_buffer_create(struct svcrdma_xprt *xprt)
                         goto out;
                 }
 
-                reply->xprt = xprt;
+                reply->xprt = NULL;
                 reply->next = xprt->snd_bufs;
                 xprt->snd_bufs = reply;
         }
@@ -688,6 +823,7 @@ static int rdma_recv_completion(struct svcrdma_xprt *xprt,
 
         svc_assert(wc->opcode == IBV_WC_RECV);
         req = (struct rdma_request *)wc->wr_id;
+        req->xprt = xprt;
 
         /* handle error message first */
         if (wc->status != IBV_WC_SUCCESS) {
diff --git a/net/usunrpc/rfc5666/svc_rdma_internal.h b/net/usunrpc/rfc5666/svc_rdma_internal.h
index 93e8a7e..a1492e2 100644
--- a/net/usunrpc/rfc5666/svc_rdma_internal.h
+++ b/net/usunrpc/rfc5666/svc_rdma_internal.h
@@ -2,15 +2,12 @@
 #ifndef _SVC_RDMA_INTERNAL_H_
 #define _SVC_RDMA_INTERNAL_H_
 
-#include <stdio.h>
-#include <unistd.h>
-#include <string.h>
-#include <libintl.h>
 #include <rpc/rpc.h>
-#include <sys/socket.h>
-#include <sys/poll.h>
 #include <errno.h>
-#include <stdlib.h>
+#include <rdma/rdma_cma.h>
+
+#include <libs/list.h>
+#include "rfc5666.h"
 
 /* internal data structures. */
 
@@ -92,8 +89,14 @@
 
   In our implementation, svc server of course records how many clients are
   connected and reserves 1 credit for each client. We also track credits for
-  each client in connection export. Thus if there're no any outstanding for a
-  specific client, we'll set the credit to 1 - this is safe and reasonable.
+  each client in connection export. Thus if there're no any outstanding
+  requests for a specific client, we'll set the credit to 1 - this is safe and
+  reasonable.
+
+  <b>References</b>
+  [1] http://tools.ietf.org/html/rfc5666
+  [2] https://docs.google.com/a/horizontalscale.com/Doc?docid=0AXl3fai-z8jaZGdoamdmd2ZfMTFndjJyODJjdw&hl=en
+
  */
 
 /**
@@ -151,6 +154,9 @@ struct svcrndzv_xprt {
          */
         struct rdma_request      *rcv_bufs;
         struct rdma_reply        *snd_bufs;
+        struct c2_mutex           bufs_mutex; /**< mutex to protect allocation
+                                                   and free of bufs */
+
         /**
           Credits management.
           At initialisation time, the total avail credits is determined
@@ -220,12 +226,12 @@ struct svcrdma_xprt {
         /**
           requests which are being processed, prepared for future use
          */
-        struct c2_list          *requests;
+        struct c2_list           requests;
         /**
           Pending replies for this export.
           We need to track replies because of async attribute of RDMA
          */
-        struct c2_list          *replies;
+        struct c2_list           replies;
 
         /**
           credits management
@@ -244,7 +250,7 @@ struct rdma_reply {
         struct rdma_reply    *next; /**< global linked list */
         struct svcrdma_xprt  *xprt;
 
-        struct c2_list_link  *link; /**< replies belonging to the same xprt. */
+        struct c2_list_link   link; /**< replies belonging to the same xprt. */
 
         /**
           Information to encode the reply message
@@ -256,16 +262,21 @@ struct rdma_reply {
         XDRS                     xdrs;   /**< used for encoding message */
 
         /**
-          buffers for reply message. They are preallocated buffers.
+          Preallocated buffers for reply message.
+          Reply messages are a bit more complex than request, because for ease to
+          to implement, reply message is composed of independent two parts:
+          rdma header and rpc message. We do not know the exact rdma header length
+          before rpc message is composed.
          */
-        void              *buffer;
-        void              *rdma_buf;
-        void              *rpc_buf;
-        int                rdma_buflen;
-        int                rpc_buflen;
-        struct ibv_mr     *rdma_mr;
-        struct ibv_mr     *rpc_mr;
+        void              *rdma_buf;    /**< buffer to store rdma header */
+        int                rdma_buflen; /**< rdma header for the reply msg */
+        void              *rpc_buf;     /**< buffer to store rpc message */
+        int                rpc_buflen;  /**< rpc message buffer */
+        struct ibv_mr     *rdma_mr;     /**< memory region for rdma buffer */
+        struct ibv_mr     *rpc_mr;      /**< memory region for rpc msg */
         struct ibv_send_wr wr;
+        void              *buffer;      /**< preallocated buffer, bufsize
+                                             is 2*max_msg_size */
 };
 
 /**
@@ -280,7 +291,7 @@ struct rdma_request {
           Sunrpc works sync right now, but we maintain requests assuming that
           multiple requests are handled simultaneously.
          */
-        struct c2_list_link  *link;
+        struct c2_list_link   link;
 
         /**
           RDMA decoding information
@@ -311,7 +322,9 @@ struct rdma_request {
 
         /**
           For each request, the rpcbuf is preregistered and the length of the
-          buffer has already been negootiated.
+          buffer is well-known after having been negotiated.
+          The follow fileds are preallocated buffer and related information
+          to register buffer to rdma engine.
          */
         void                 *buffer;
         struct ibv_mr        *mr;
-- 
1.8.3.2

