From 0dd551775067286166f4523830c276fdd556be39 Mon Sep 17 00:00:00 2001
From: "jinshan.xiong" <jinshan.xiong@clusterstor.com>
Date: Fri, 23 Jul 2010 22:58:22 -0600
Subject: [PATCH 14/34] - Add rdma support to usunrpc

---
 colibri/Makefile.am                     |   6 ++
 lib/memory.c                            |   1 +
 net/usunrpc/client.c                    |  13 +++
 net/usunrpc/rfc5666/svc_rdma.c          |  86 ++++++++++----------
 net/usunrpc/rfc5666/svc_rdma_internal.h |   2 +-
 net/usunrpc/server.c                    | 137 +++++++++++++++++++++++---------
 net/usunrpc/usunrpc_internal.h          |   8 ++
 net/usunrpc/uxdr.c                      |  20 +++--
 stob/ut/server.c                        |  15 +++-
 9 files changed, 199 insertions(+), 89 deletions(-)

diff --git a/colibri/Makefile.am b/colibri/Makefile.am
index 9043658..e4d87db 100644
--- a/colibri/Makefile.am
+++ b/colibri/Makefile.am
@@ -29,4 +29,10 @@ libcolibri_la_LIBADD      = @AIO_LIBS@ @PTHREAD_LIBS@ @DB_LIBS@ @GALOIS_LIBS@ @C
 
 #                            $(top_builddir)/rpc/libcolibri-rpc.la
 
+# the following are from the rdma branch. Do we need the INCLUDES?
+if ENABLE_RDMA
+libcolibri_la_LIBADD += $(top_builddir)/net/usunrpc/rfc5666/libcolibri-rdma.la
+endif
+
+INCLUDES                  = -I. -I$(top_srcdir) -I$(top_srcdir)/include -I@DBSRC@ -I@DBSRC@/build_unix 
 
diff --git a/lib/memory.c b/lib/memory.c
index 98bb2b7..59e478e 100644
--- a/lib/memory.c
+++ b/lib/memory.c
@@ -94,6 +94,7 @@ void *c2_alloc_align(size_t size, int align)
 {
         void *ret;
 
+        C2_ASSERT((align ^ (align - 1)) == 0);
         if (posix_memalign(&ret, align, size))
                 return NULL;
 
diff --git a/net/usunrpc/client.c b/net/usunrpc/client.c
index a8c058c..f30f5f1 100644
--- a/net/usunrpc/client.c
+++ b/net/usunrpc/client.c
@@ -287,16 +287,29 @@ int usunrpc_service_id_init(struct c2_service_id *sid, va_list varargs)
 
 	C2_ALLOC_PTR(xsid);
 	if (xsid != NULL) {
+                char *trans;
+
 		sid->si_xport_private = xsid;
 		xsid->ssi_id = sid;
 
 		/* N.B. they have different order than kernelspace's ones */
 		xsid->ssi_host = va_arg(varargs, char *);
 		xsid->ssi_port = va_arg(varargs, int);
+                trans = va_arg(varargs, char *);
 		xsid->ssi_prog = C2_SESSION_PROGRAM;
 		xsid->ssi_ver  = C2_DEF_RPC_VER;
 		sid->si_ops = &usunrpc_service_id_ops;
 		result = 0;
+                if (strcmp("tcp", trans) == 0)
+                        xsid->ssi_trans = USUNRPC_TRANS_TCP;
+                else if (strcmp("udp", trans) == 0)
+                        xsid->ssi_trans = USUNRPC_TRANS_UDP;
+                else if (strcmp("rdma", trans) == 0)
+                        xsid->ssi_trans = USUNRPC_TRANS_RDMA;
+                else
+                        result = -EINVAL;
+                if (result)
+                        c2_free(xsid);
 	} else
 		result = -ENOMEM;
 	return result;
diff --git a/net/usunrpc/rfc5666/svc_rdma.c b/net/usunrpc/rfc5666/svc_rdma.c
index c78cadf..854a354 100644
--- a/net/usunrpc/rfc5666/svc_rdma.c
+++ b/net/usunrpc/rfc5666/svc_rdma.c
@@ -68,13 +68,13 @@ static enum xprt_stat rendezvous_stat (SVCXPRT *);
 static void rendezvous_abort (void) __attribute__ ((__noreturn__));
 static void rendezvous_destroy(SVCXPRT *);
 
-static const struct xp_ops svcrdma_rendezvous_op = {
+static const struct xp_ops svcrdma_rndzv_op = {
         .xp_recv     = rendezvous_request,
         .xp_stat     = rendezvous_stat,
-        .xp_getargs  = (bool_t (*)(SVCXPRT*, xdrproc_t, caddr_t)) rendezvous_abort,
-        .xp_reply    = (bool_t (*)(SVCXPRT*, struct rpc_msg *)) rendezvous_abort,
-        .xp_freeargs = (bool_t (*)(SVCXPRT*, xdrproc_t, caddr_t)) rendezvous_abort,
-        .xp_destroy = rendezvous_destroy
+        .xp_getargs  = (typeof(svcrdma_rndzv_op.xp_getargs)) rendezvous_abort,
+        .xp_reply    = (typeof(svcrdma_rndzv_op.xp_reply)) rendezvous_abort,
+        .xp_freeargs = (typeof(svcrdma_rndzv_op.xp_freeargs)) rendezvous_abort,
+        .xp_destroy  = rendezvous_destroy
 };
 
 /**
@@ -88,7 +88,8 @@ SVCXPRT *svcrdma_create (struct sockaddr_in *sa, struct svcrdma_config *cfg)
 
         C2_ALLOC_PTR(vxp);
         if (vxp == NULL) {
-                svcrdma_errx("no memory\n");
+                errno = ENOMEM;
+                svcrdma_errx(ENOMEM, "no memory\n");
                 return NULL;
         }
 
@@ -98,18 +99,18 @@ SVCXPRT *svcrdma_create (struct sockaddr_in *sa, struct svcrdma_config *cfg)
 
         vxp->vx_channel = rdma_create_event_channel();
         if (vxp->vx_channel == NULL) {
-                svcrdma_errx("rdma_create_event channel failed\n");
+                svcrdma_errx(errno, "rdma_create_event channel failed\n");
                 goto out;
         }
 
         if (rdma_create_id(vxp->vx_channel, &vxp->vx_cmid, 0, RDMA_PS_TCP)) {
-                svcrdma_errx("rdma_create_id failed\n");
+                svcrdma_errx(errno, "rdma_create_id failed\n");
                 goto out;
         }
 
         /* get attribute of before doing anything else */
         if (ibv_query_device(vxp->vx_cmid->verbs, &devattr)) {
-                svcrdma_errx("query device error\n");
+                svcrdma_errx(errno, "query device error\n");
                 goto out;
         }
 
@@ -123,11 +124,8 @@ SVCXPRT *svcrdma_create (struct sockaddr_in *sa, struct svcrdma_config *cfg)
         vxp->vx_max_send_wr = devattr.max_qp_wr;
         vxp->vx_max_recv_wr = devattr.max_qp_wr;
         vxp->vx_credits = devattr.max_qp_wr - 1;
-
-        /* suppose the maximum message size is 1 page. */
-        vxp->vx_page_size    = sysconf(_SC_PAGESIZE);
-        vxp->vx_mms = vxp->vx_page_size; /* XXX:negotiate with client */
-        /* vxp->vx_mms = cfg->max_msg_size; */
+        vxp->vx_page_size = sysconf(_SC_PAGESIZE);
+        vxp->vx_mms       = cfg->max_msg_size;
 
         vxp->vx_rcv_wr_flags = IBV_ACCESS_LOCAL_WRITE |
                                IBV_ACCESS_REMOTE_READ |
@@ -137,20 +135,20 @@ SVCXPRT *svcrdma_create (struct sockaddr_in *sa, struct svcrdma_config *cfg)
                                IBV_ACCESS_REMOTE_WRITE;
 
         if (rdma_bind_addr(vxp->vx_cmid, (struct sockaddr *)&sa)) {
-                svcrdma_errx("bind address error\n");
+                svcrdma_errx(errno, "bind address error\n");
                 goto out;
         }
 
         vxp->vx_status = RDMA_XPRT_LISTEN;
         if (rdma_listen(vxp->vx_cmid, 0)) {
-                svcrdma_errx("listen error\n");
+                svcrdma_errx(errno, "listen error\n");
                 goto out;
         }
 
         /* Now initiate SVCXPRT stuffs. */
         svcxprt = &vxp->vx_svcxprt;
         svcxprt->xp_p1 = (caddr_t)vxp;
-        svcxprt->xp_ops = &svcrdma_rendezvous_op;
+        svcxprt->xp_ops = &svcrdma_rndzv_op;
         svcxprt->xp_port = vxp->vx_port;
         svcxprt->xp_sock = vxp->vx_channel->fd;
 
@@ -302,7 +300,7 @@ static bool_t rendezvous_request(SVCXPRT *svcxprt, struct rpc_msg *errmsg)
         int rc = 0;
 
         if (rdma_get_cm_event(vxp->vx_channel, &ev)) {
-                svcrdma_errx("get_cm_event error\n");
+                svcrdma_errx(errno, "get_cm_event error\n");
                 /* what can I do? */
                 return FALSE;
         }
@@ -340,16 +338,16 @@ static bool_t rendezvous_request(SVCXPRT *svcxprt, struct rpc_msg *errmsg)
 
         case RDMA_CM_EVENT_DEVICE_REMOVAL:
         case RDMA_CM_EVENT_ADDR_CHANGE:
-                svcrdma_errx("get event %s, ignored\n", msg);
+                svcrdma_errx(EINVAL, "get event %s, ignored\n", msg);
                 break;
 
         default:
-                svcrdma_errx("Unknown event %s\n", msg);
+                svcrdma_errx(EINVAL, "Unknown event %s\n", msg);
                 break;
         }
 
         if (rc)
-                svcrdma_errx("Handle event %s return error %d\n", msg, rc);
+                svcrdma_errx(rc, "Handle event %s return error %d\n", msg, rc);
 
         (void)rdma_ack_cm_event(ev);
         return FALSE;
@@ -399,18 +397,19 @@ static bool_t svcrdma_recv(SVCXPRT *svcxprt, struct rpc_msg *msg)
         int            rc = 0;
 
         if (ibv_get_cq_event(xp->rx_channel, &ecq, &ectx) != 0) {
-                svcrdma_errx("get cq_event for xprt %p\n", xp);
+                svcrdma_errx(errno, "get cq_event for xprt %p\n", xp);
                 return FALSE;
         }
 
         C2_ASSERT(ecq == xp->rx_cq && ectx == xp);
         rc = ibv_req_notify_cq(xp->rx_cq, 0);
         if (rc)
-                svcrdma_errx("failed to set up notification(%d)\n", rc);
+                svcrdma_errx(rc, "failed to set up notification\n");
         ibv_ack_cq_events(xp->rx_cq, 1);
 
         if (xp->rx_status != RDMA_XPRT_ESTABLISHED) {
-                svcrdma_errx("Received a message but the export is not establised!\n");
+                svcrdma_errx(EINVAL, "Received a message but the export"
+                                     "is not establised!\n");
                 return FALSE;
         }
 
@@ -422,13 +421,13 @@ static bool_t svcrdma_recv(SVCXPRT *svcxprt, struct rpc_msg *msg)
                 if (!rc) {         /* no event pending any more */
                         break;
                 } else if (rc < 0) { /* error occurs */
-                        svcrdma_errx("error occurs polling cq");
+                        svcrdma_errx(errno, "error occurs polling cq");
                         break;
                 }
 
                 C2_ASSERT(rc == 1);
                 if (wc.status != IBV_WC_SUCCESS) {
-                        svcrdma_errx("get a wc with error(%s), op/id: %d/%lx",
+                        svcrdma_errx(EINVAL, "get a wc with error(%s), op/id: %d/%lx",
                                      ibv_wc_status_str(wc.status),
                                      wc.opcode, wc.wr_id);
 
@@ -453,7 +452,7 @@ static bool_t svcrdma_recv(SVCXPRT *svcxprt, struct rpc_msg *msg)
                         break;
                 }
                 default:
-                        svcrdma_errx("unknown opcode(%d) of cq event %lx",
+                        svcrdma_errx(EINVAL, "unknown opcode(%d) of cqe %lx",
                                      wc.opcode, wc.wr_id);
                         break;
                 }
@@ -733,7 +732,7 @@ static void rdma_request_repost(struct rdma_request *req)
         xdr_svcrdma_msg(&req->rq_xdrs, &req->rq_msg);
         rc = ibv_post_recv(req->rq_xprt->rx_qp, &req->rq_wr, &badwr);
         if (rc)
-                svcrdma_errx("repost recv buffer error");
+                svcrdma_errx(rc, "repost recv buffer error");
 }
 
 /**
@@ -765,7 +764,8 @@ static int rdma_recv_completion(struct svcrdma_xprt *xprt,
                 /* what can we do? Just reregister the buffer */
                 rc = ibv_post_recv(xprt->rx_qp, &req->rq_wr, &badwr);
                 if (rc)
-                        svcrdma_errx("fatal error on registering recv buffer");
+                        svcrdma_errx(rc,
+                                     "fatal error on registering recv buffer");
                 return rc;
         }
 
@@ -806,7 +806,8 @@ static int rdma_recv_completion(struct svcrdma_xprt *xprt,
         msg = &req->rq_msg;
         xdrmem_create(&xdrs, req->rq_buffer, reqlen, XDR_DECODE);
         if (xdr_svcrdma_msg(&xdrs, msg)) {
-                svcrdma_errx("message corrupted, decode rdma header failed");
+                svcrdma_errx(0,
+                             "message corrupted, decode rdma header failed");
                 reply->rp_xid = msg->rdma_xid; /* XXX: XID still wasn't decoded? */
                 errcode = RDMA_ERR_CHUNK;
                 goto out;
@@ -818,8 +819,8 @@ static int rdma_recv_completion(struct svcrdma_xprt *xprt,
         /* version check */
         msg = &req->rq_msg;
         if (msg->rdma_vers != RDMA_VERS) {
-                svcrdma_errx("version mismatched, %d/%d",
-                         msg->rdma_vers, RDMA_VERS);
+                svcrdma_errx(0, "version mismatched, %d/%d",
+                             msg->rdma_vers, RDMA_VERS);
                 errcode = RDMA_ERR_VERS;
                 goto out;
         }
@@ -949,7 +950,7 @@ static void rdma_completion_one(struct rdma_context *ctxt,
                 if (ctxt->status == IBV_WC_SUCCESS)
                         ctxt->status = rc;
 
-                svcrdma_errx("ctxt(%p) cq error %s\n",
+                svcrdma_errx(0, "ctxt(%p) cq error %s\n",
                              ctxt, ibv_wc_status_str(rc));
         }
         if (c2_atomic64_dec_and_test(&ctxt->refcnt) == 0) {
@@ -974,12 +975,12 @@ static int rdma_wait_for_completion(struct rdma_context *ctxt)
 
 again:
         if ((rc = ibv_get_cq_event(xprt->rx_channel, &ecq, &ectx))) {
-                svcrdma_errx("get cq_event for xprt %p\n", xprt);
+                svcrdma_errx(rc, "get cq_event for xprt %p\n", xprt);
                 return rc;
         }
         C2_ASSERT(ecq == xprt->rx_cq && ectx == xprt);
         if ((rc = ibv_req_notify_cq(xprt->rx_cq, 0)))
-                svcrdma_errx("failed to set up notification %d", rc);
+                svcrdma_errx(rc, "failed to set up notification");
         ibv_ack_cq_events(xprt->rx_cq, 1);
 
         while (1) {
@@ -988,7 +989,7 @@ again:
                         break;
                 } else if (rc < 0) {   /* error occurs */
                         rc = errno;
-                        svcrdma_errx("error occurs polling cq");
+                        svcrdma_errx(rc, "error occurs polling cq");
                         break;
                 }
 
@@ -1037,8 +1038,7 @@ static int do_rdma_post(struct rdma_context *ctxt, struct rdma_segment *seg,
         sge.lkey = mr->lkey;
         rc = ibv_post_send(ctxt->xprt->rx_qp, &wr, &badwr);
         if (rc != IBV_WC_SUCCESS) {
-                svcrdma_errx("post RDMA buffer error %s\n",
-                             ibv_wc_status_str(rc));
+                svcrdma_errx(rc, "post RDMA buffer error\n");
                 ibv_dereg_mr(mr);
                 return rc;
         }
@@ -1075,7 +1075,7 @@ static int rdma_chunks_read(struct rdma_request *req, char *buffer, int buflen)
                         
                         rc2 = rdma_wait_for_completion(ctxt);
                         if (rc2) {
-                                svcrdma_errx("wait for RDMA read failed");
+                                svcrdma_errx(0, "wait for RDMA read failed");
                                 break;
                         }
                         C2_ASSERT(c2_atomic64_get(&ctxt->refcnt) == 0);
@@ -1094,7 +1094,7 @@ static int rdma_chunks_read(struct rdma_request *req, char *buffer, int buflen)
                 if (ctxt->index == ctxt->max_index - 1) {
                         rc = rdma_wait_for_completion(ctxt);
                         if (rc) {
-                                svcrdma_errx("wait for RDMA read failed");
+                                svcrdma_errx(0, "wait for RDMA read failed");
                                 break;
                         }
                         C2_ASSERT(c2_atomic64_get(&ctxt->refcnt) == 0);
@@ -1154,7 +1154,7 @@ int rdma_chunks_write(struct rdma_reply *reply, char *buffer, int buflen)
 
                                 rc2 = rdma_wait_for_completion(ctxt);
                                 if (rc2) {
-                                        svcrdma_errx("RDMA write failed");
+                                        svcrdma_errx(0, "RDMA write failed");
                                         break;
                                 }
                                 C2_ASSERT(!c2_atomic64_get(&ctxt->refcnt));
@@ -1176,7 +1176,7 @@ int rdma_chunks_write(struct rdma_reply *reply, char *buffer, int buflen)
                         if (ctxt->index == ctxt->max_index - 1) {
                                 rc = rdma_wait_for_completion(ctxt);
                                 if (rc) {
-                                        svcrdma_errx("RDMA write failed");
+                                        svcrdma_errx(0, "RDMA write failed");
                                         break;
                                 }
                         }
@@ -1338,7 +1338,7 @@ static int rdma_reply_send(struct rdma_reply *reply)
         wr.send_flags = IBV_SEND_SIGNALED;
         rc = ibv_post_send(reply->rp_xprt->rx_qp, &wr, &badwr);
         if (rc) {
-                svcrdma_errx("post reply buffer error\n");
+                svcrdma_errx(rc, "post reply buffer error\n");
                 return rc;
         }
 
diff --git a/net/usunrpc/rfc5666/svc_rdma_internal.h b/net/usunrpc/rfc5666/svc_rdma_internal.h
index adc9a5b..b50c55d 100644
--- a/net/usunrpc/rfc5666/svc_rdma_internal.h
+++ b/net/usunrpc/rfc5666/svc_rdma_internal.h
@@ -383,7 +383,7 @@ struct rdma_context {
 };
 
 #include <err.h>
-#define svcrdma_errx(fmt, args...)      errx(1, fmt, ##args)
+#define svcrdma_errx(rc, fmt, args...)      errx(1, fmt, ##args)
 
 /** @} end group svcrdma */
 
diff --git a/net/usunrpc/server.c b/net/usunrpc/server.c
index dd17560..047aa19 100644
--- a/net/usunrpc/server.c
+++ b/net/usunrpc/server.c
@@ -33,6 +33,10 @@
 #include "usunrpc.h"
 #include "usunrpc_internal.h"
 
+#ifdef ENABLE_RDMA
+#include "rfc5666/svc_rdma.h"
+#endif
+
 /**
    @addtogroup usunrpc User Level Sun RPC
    @{
@@ -316,6 +320,98 @@ static void usunrpc_op(struct c2_service *service,
 	}
 }
 
+static int usunrpc_start_svctcp(struct c2_service *service,
+                                struct usunrpc_service_id *xid)
+{
+        struct usunrpc_service *xservice;
+	struct sockaddr_in      addr;
+	int                     i;
+	int                     rc;
+
+	xservice = service->s_xport_private;
+	C2_ASSERT(xservice->s_socket == -1);
+        xservice->s_socket = socket(AF_INET, SOCK_STREAM, 0);
+        if (xservice->s_socket == -1) {
+		ADDB_ADD(service, usunrpc_addb_socket, errno);
+		return -errno;
+	}
+
+	i = 1;
+	if (setsockopt(xservice->s_socket, SOL_SOCKET, SO_REUSEADDR,
+		       &i, sizeof(i)) < 0) {
+		ADDB_ADD(service, usunrpc_addb_reuseaddr, errno);
+		rc = -errno;
+                goto out;
+	}
+
+        memset(&addr, 0, sizeof addr);
+        addr.sin_port = htons(xid->ssi_port);
+        if (bind(xservice->s_socket, 
+		 (struct sockaddr *)&addr, sizeof addr) == -1) {
+		ADDB_ADD(service, usunrpc_addb_bind, errno);
+		rc = -errno;
+		goto out;
+	}
+
+        xservice->s_transp = svctcp_create(xservice->s_socket, 0, 0);
+        if (xservice->s_transp == NULL) {
+                rc = -errno ? : -ENOMEM;
+                ADDB_ADD(service, usunrpc_addb_svctcp_create, rc);
+                goto out;
+        }
+
+        return 0;
+                
+out:
+	close(xservice->s_socket);
+	return rc;
+}
+
+static int usunrpc_start_svcrdma(struct c2_service *service,
+                                 struct usunrpc_service_id *xid)
+{
+#ifdef ENABLE_RDMA
+        struct usunrpc_service *xservice;
+        struct svcrdma_config   cfg = {
+                .max_msg_size    = sysconf(_SC_PAGESIZE),
+                .retry_count     = 8,
+                .rnr_retry_count = 8
+        };
+        struct sockaddr_in sa = {
+                .sin_family     = AF_INET,
+                .sin_port       = htons(xid->ssi_port),
+                .sin_addr       = {
+                        .s_addr = 0
+                }
+        };
+
+        /* TODO: ask the configuration protocol on client for parameters. */
+
+        xservice = service->s_xport_private;
+        xservice->s_transp = svcrdma_create(&sa, &cfg);
+        if (xservice->s_transp == NULL)
+                return -errno;
+
+        return 0;
+#else
+        return -ENOSUPP;
+#endif
+}
+
+static int usunrpc_start_svcudp(struct c2_service *service,
+                                struct usunrpc_service_id *xid)
+{
+        C2_ASSERT(0);
+        return 0;
+}
+
+static int (*usunrpc_trans_policy[])(struct c2_service *,
+                                     struct usunrpc_service_id *) = {
+        [USUNRPC_TRANS_TCP]  = usunrpc_start_svctcp,
+        [USUNRPC_TRANS_UDP]  = usunrpc_start_svcudp,
+        [USUNRPC_TRANS_RDMA] = usunrpc_start_svcrdma
+};
+
 /**
    dispatch.
 
@@ -359,20 +455,16 @@ static int usunrpc_scheduler_init(struct c2_service *service)
 {
 	struct usunrpc_service    *xservice;
 	struct usunrpc_service_id *xid;
-	SVCXPRT                   *transp;
 	int                        result;
 
 	usunrpc_service_set(service);
 	xservice = service->s_xport_private;
 	xid = service->s_id->si_xport_private;
-
-	C2_ASSERT(xservice->s_socket >= 0);
-
-	result = -EINVAL;
-        transp = svctcp_create(xservice->s_socket, 0, 0);
-        if (transp != NULL) {
-		xservice->s_transp = transp;
-		if (svc_register(transp, xservice->s_progid,
+        C2_ASSERT(xid->ssi_trans < USUNRPC_TRANS_MAX);
+        result = (usunrpc_trans_policy[xid->ssi_trans])(service, xid);
+        if (result == 0) {
+		if (svc_register(xservice->s_transp,
+                                 xservice->s_progid, 
 				 xservice->s_version,
 				 usunrpc_dispatch, 0))
 			result = 0;
@@ -485,7 +577,6 @@ static void usunrpc_service_stop(struct usunrpc_service *xs)
 static int usunrpc_service_start(struct c2_service *service,
 				 struct usunrpc_service_id *xid, int nr_workers)
 {
-	struct sockaddr_in     addr;
 	int                    i;
 	int                    rc;
 	struct usunrpc_service *xservice;
@@ -495,32 +586,6 @@ static int usunrpc_service_start(struct c2_service *service,
 	xservice->s_progid  = xid->ssi_prog;
 	xservice->s_version = xid->ssi_ver;
 
-	C2_ASSERT(xservice->s_socket == -1);
-
-        xservice->s_socket = socket(AF_INET, SOCK_STREAM, 0);
-        if (xservice->s_socket == -1) {
-		ADDB_CALL(service, "socket", errno);
-		return -errno;
-	}
-
-	i = 1;
-	if (setsockopt(xservice->s_socket, SOL_SOCKET, SO_REUSEADDR,
-		       &i, sizeof(i)) < 0) {
-		ADDB_CALL(service, "reuseaddr", errno);
-		rc = -errno;
-		close(xservice->s_socket);
-		return rc;
-	}
-
-        C2_SET0(&addr);
-        addr.sin_port = htons(xid->ssi_port);
-        if (bind(xservice->s_socket,
-		 (struct sockaddr *)&addr, sizeof addr) == -1) {
-		ADDB_CALL(service, "bind", errno);
-		rc = -errno;
-		goto err;
-	}
-
         xservice->s_nr_workers = nr_workers;
 	C2_ALLOC_ARR(xservice->s_workers, nr_workers);
         if (xservice->s_workers == NULL) {
diff --git a/net/usunrpc/usunrpc_internal.h b/net/usunrpc/usunrpc_internal.h
index f2fa2e5..a4882a8 100644
--- a/net/usunrpc/usunrpc_internal.h
+++ b/net/usunrpc/usunrpc_internal.h
@@ -65,6 +65,13 @@ static inline bool udom_is_shutting(const struct c2_net_domain *dom)
 	return ((struct usunrpc_dom *)dom->nd_xprt_private)->sd_shutown;
 }
 
+enum {
+        USUNRPC_TRANS_TCP  = 0,
+        USUNRPC_TRANS_UDP  = 1,
+        USUNRPC_TRANS_RDMA = 2,
+        USUNRPC_TRANS_MAX
+};
+
 /**
    SUNRPC service identifier.
  */
@@ -76,6 +83,7 @@ struct usunrpc_service_id {
 	uint16_t              ssi_port;     /**< server tcp port */
 	uint32_t              ssi_prog;     /**< server program number */
 	uint32_t              ssi_ver;      /**< server program version */
+        uint32_t              ssi_trans;    /**< trans type, TCP, RDMA etc */
 };
 
 int  usunrpc_server_init(void);
diff --git a/net/usunrpc/uxdr.c b/net/usunrpc/uxdr.c
index 3273dc8..3d7d68e 100644
--- a/net/usunrpc/uxdr.c
+++ b/net/usunrpc/uxdr.c
@@ -151,11 +151,23 @@ bool_t c2_fop_uxdrproc(XDR *xdrs, struct c2_fop *fop)
 	return c2_fop_type_uxdr(fop->f_type->ft_top, xdrs, c2_fop_data(fop));
 }
 
+static bool_t (*dbuf_xdrproc)(XDR *xdrs, void *obj, int objlen) = NULL;
+void c2_dbuf_xdrproc_set(bool_t (*xdrproc)(XDR *, void *, int))
+{
+        dbuf_xdrproc = xdrproc;
+}
+
 /*
  */
-bool_t xdr_dbuf(XDR *xdrs, struct c2_dbuf *dbuf,
-                bool_t (*xdrproc)(XDR *, char *buffer, int buflen))
+bool_t xdr_dbuf(XDR *xdrs, void *obj)
 {
+        struct c2_dbuf *dbuf = obj;
+        bool_t (*xdrproc)(XDR *, void *, int);
+
+        xdrproc = dbuf_xdrproc;
+        if (xdrproc == NULL)
+                xdrproc = (typeof(xdrproc))xdr_opaque;
+
         if (!xdr_u_int(xdrs, &dbuf->db_alignment))
                 return FALSE;
         if (!xdr_u_int(xdrs, &dbuf->db_buflen))
@@ -168,9 +180,7 @@ bool_t xdr_dbuf(XDR *xdrs, struct c2_dbuf *dbuf,
                 if (dbuf->db_buffer == NULL)
                         return FALSE;
         case XDR_ENCODE:
-                if (xdrproc)
-                        return xdrproc(xdrs, dbuf->db_buffer, dbuf->db_buflen);
-                return xdr_opaque(xdrs, dbuf->db_buffer, dbuf->db_buflen);
+                return xdrproc(xdrs, dbuf->db_buffer, dbuf->db_buflen);
         case XDR_FREE:
                 c2_free(dbuf->db_buffer);
                 return TRUE;
diff --git a/stob/ut/server.c b/stob/ut/server.c
index 240eba6..50f7bae 100644
--- a/stob/ut/server.c
+++ b/stob/ut/server.c
@@ -384,7 +384,7 @@ int main(int argc, char **argv)
 	char        opath[64];
 	char        dpath[64];
 	int         port;
-        int         i = 0;
+        char       *trans = "tcp";
 
 	struct c2_stob_domain  *bdom;
 	struct c2_stob_id       backid;
@@ -412,15 +412,18 @@ int main(int argc, char **argv)
 			    C2_STRINGARG('d', "path to object store",
 				       LAMBDA(void, (const char *string) {
 					       path = string; })),
+			    C2_STRINGARG('X', "Transport type (tcp|udp|rdma)",
+				       LAMBDA(void, (const char *string) {
+					       trans = string; })),
 			    C2_FORMATARG('o', "back store object id", "%lu",
 					 &backid.si_bits.u_lo),
 			    C2_FORMATARG('p', "port to listen at", "%i", &port));
 	if (result != 0)
 		return result;
 
-	printf("path=%s, back store object=%llx.%llx, tcp port=%d\n",
+	printf("path=%s, back store object=%llx.%llx, tcp port=%d xprt=%s\n",
 		path, (unsigned long long)backid.si_bits.u_hi,
-		(unsigned long long)backid.si_bits.u_lo, port);
+		(unsigned long long)backid.si_bits.u_lo, port, trans);
 
 	result = c2_init();
 	C2_ASSERT(result == 0);
@@ -428,6 +431,10 @@ int main(int argc, char **argv)
 	result = io_fop_init();
 	C2_ASSERT(result == 0);
 
+	if (strcmp(trans, "tcp") ||
+	    strcmp(trans, "udp") ||
+	    strcmp(trans, "rdma"))
+		return -1;
 	C2_ASSERT(strlen(path) < ARRAY_SIZE(opath) - 8);
 
 	result = mkdir(path, 0700);
@@ -490,7 +497,7 @@ int main(int argc, char **argv)
 	result = c2_net_domain_init(&ndom, &c2_net_usunrpc_xprt);
 	C2_ASSERT(result == 0);
 
-	result = c2_service_id_init(&sid, &ndom, "127.0.0.1", port);
+	result = c2_service_id_init(&sid, &ndom, "127.0.0.1", port, trans);
 	C2_ASSERT(result == 0);
 
 	result = c2_service_start(&service, &sid);
-- 
1.8.3.2

