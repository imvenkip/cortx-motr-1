From b7a2e094bcdccbfa6590a9b2573ad687ed6dbbbd Mon Sep 17 00:00:00 2001
From: "jinshan.xiong" <jinshan.xiong@clusterstor.com>
Date: Wed, 21 Jul 2010 09:52:46 -0600
Subject: [PATCH 09/34] - move c2_buf and c2_dbuf to vec.h - Makefile

---
 configure.ac                            | 22 ++++++++++++
 net/usunrpc/Makefile.am                 |  1 +
 net/usunrpc/rfc5666/rfc5666.h           |  4 ++-
 net/usunrpc/rfc5666/svc_rdma.c          | 61 +++++++++++++++------------------
 net/usunrpc/rfc5666/svc_rdma_internal.h | 16 ++++-----
 net/usunrpc/rfc5666/xdr_rdma.c          | 24 -------------
 net/usunrpc/usunrpc.h                   | 17 +++++++++
 net/usunrpc/uxdr.c                      | 26 ++++++++++++++
 8 files changed, 105 insertions(+), 66 deletions(-)

diff --git a/configure.ac b/configure.ac
index 20305aa..6fe731c 100755
--- a/configure.ac
+++ b/configure.ac
@@ -289,6 +289,11 @@ AC_ARG_ENABLE([db-o_direct],
         [enable_db_o_direct=no]
 )
 
+AC_ARG_ENABLE([rdma],
+        [AC_HELP_STRING([--enable-rdma], [enable rdma support])], [],
+        [enable_rdma=no]
+)
+
 AC_MSG_CHECKING([for operating system])
 AC_MSG_RESULT([$host_os])
 case $host_os in
@@ -446,6 +451,23 @@ if test x$enable_gssrpc = xyes; then
         fi
 fi
 
+<<<<<<< HEAD:configure.ac
+=======
+if test x$OS = xlinux; then
+        OLD_LIBS=$LIBS
+        LIBS=""
+        AC_SEARCH_LIBS([io_getevents], [c aio], [], [AC_MSG_ERROR([io_getevents cannot be found!])])
+        AIO_LIBS=$LIBS
+        AC_SUBST([AIO_LIBS])
+        LIBS=$OLD_LIBS
+fi
+
+if test x$enable_rdma = xyes; then
+        AC_CHECK_HEADERS([rdma/rdma_cma.h infiniband/verbs.h], [AC_DEFINE([ENABLE_RDMA])],
+                         [AC_MSG_ERROR([rdma header files: rdma_cma.h or infiniband/verbs.h cannot be found!])])
+fi
+
+>>>>>>> - move c2_buf and c2_dbuf to vec.h:configure.ac
 OLD_LIBS=$LIBS
 LIBS=""
 AC_SEARCH_LIBS([io_getevents], [c aio], [], [AC_MSG_ERROR([io_getevents cannot be found! Try install libaio-devel.])])
diff --git a/net/usunrpc/Makefile.am b/net/usunrpc/Makefile.am
index afb2d66..59e05d4 100644
--- a/net/usunrpc/Makefile.am
+++ b/net/usunrpc/Makefile.am
@@ -1,5 +1,6 @@
 usunrpcdir                         = $(includedir)/net/usunrpc
 usunrpc_HEADERS                    = usunrpc.h usunrpc_internal.h
+SUBDIRS                            = . rfc5666
 
 noinst_LTLIBRARIES                 = libcolibri-net-usunrpc.la
 libcolibri_net_usunrpc_la_SOURCES  = client.c server.c domain.c usunrpc.h \
diff --git a/net/usunrpc/rfc5666/rfc5666.h b/net/usunrpc/rfc5666/rfc5666.h
index 46cbe46..ad3f18b 100644
--- a/net/usunrpc/rfc5666/rfc5666.h
+++ b/net/usunrpc/rfc5666/rfc5666.h
@@ -8,7 +8,9 @@
 /**
   This file defines data structures needed by rdma. These data structures
   are generated by XDR descriptors.
-  XXX: Need to revise.
+
+  XXX: Need to revise. There is so much memory allocation to decode an rdma
+       header.
 
   @addtogroup svcrdma
   @{
diff --git a/net/usunrpc/rfc5666/svc_rdma.c b/net/usunrpc/rfc5666/svc_rdma.c
index 2f17ebd..6b9aaba 100644
--- a/net/usunrpc/rfc5666/svc_rdma.c
+++ b/net/usunrpc/rfc5666/svc_rdma.c
@@ -1,15 +1,13 @@
 
 #include <rpc/rpc.h>
-#include <sys/socket.h>
-#include <sys/poll.h>
 #include <errno.h>
-#include <stdlib.h>
+#include <netinet/in.h>
 
 #include "svc_rdma_internal.h"
 #include "svc_rdma.h"
 
-static int svcrdma_buffer_create(struct svcrndzv_xprt *xprt);
-static void svcrdma_buffer_destroy(struct svcrndzv_xprt *xprt);
+static int svcrdma_buffer_create(struct svcrdma_xprt *xprt);
+static void svcrdma_buffer_destroy(struct svcrdma_xprt *xprt);
 static int rdma_recv_completion(struct svcrdma_xprt *xprt,
                                 struct ibv_wc *wc,
                                 struct rpc_msg *rpcmsg);
@@ -61,11 +59,6 @@ SVCXPRT *svcrdma_create (struct sockaddr_in *sa, struct svcrdma_config *cfg)
 {
         SVCXPRT *svcxprt;
         struct svcrndzv_xprt *xp;
-        struct sockaddr_in saddr = {
-                .sin_family      = AF_INET,
-                .sin_addr.s_addr = htonl(INADDR_ANY),
-                .sin_port        = htons(port)
-        };
         struct ibv_device_attr devattr;
 
         xp = mem_alloc(sizeof(*xp));
@@ -74,6 +67,7 @@ SVCXPRT *svcrdma_create (struct sockaddr_in *sa, struct svcrdma_config *cfg)
                 return NULL;
         }
         memset(xp, 0, sizeof(*xp));
+        c2_list_init(&xp->xprts);
         xp->status = RDMA_XPRT_LISTEN;
 
         xp->channel = rdma_create_event_channel();
@@ -82,17 +76,31 @@ SVCXPRT *svcrdma_create (struct sockaddr_in *sa, struct svcrdma_config *cfg)
                 goto out;
         }
 
+        if (rdma_create_id(xp->channel, &xp->cmid, 0, RDMA_RS_TCP)) {
+                svc_errx("rdma_create_id failed\n");
+                goto out;
+        }
+
+        /* get attribute of before doing anything else */
+        if (ibv_query_device(xp->cmid->verbs, &devattr)) {
+                svc_errx("query device error\n");
+                goto out;
+        }
+
         /* XXX: Only RC mode is supported right now */
         xp->trans = IBV_QPT_RC;
-        xp->port  = port;
+        xp->port  = ntohs(sa->sa_port);
         xp->max_send_sge = 2;
         xp->max_recv_sge = 2;
         xp->rc_retry_cnt = 8;
         xp->rc_rnr_retry_cnt = 8;
+        xp->max_send_wr = devattr.max_qp_wr;
+        xp->max_recv_wr = devattr.max_qp_wr;
+        xp->credits = devattr.max_qp_wr - 1;
 
         /* suppose the maximum message size is 1 page. */
         xp->page_size    = sysconf(_SC_PAGESIZE);
-        xp->max_msg_size = xp->page_size;
+        xp->max_msg_size = xp->page_size; /* XXX: will negotiate with client */
 
         xp->rcv_wr_flags = IBV_ACCESS_LOCAL_WRITE |
                            IBV_ACCESS_REMOTE_READ |
@@ -101,21 +109,7 @@ SVCXPRT *svcrdma_create (struct sockaddr_in *sa, struct svcrdma_config *cfg)
                            IBV_ACCESS_REMOTE_READ |
                            IBV_ACCESS_REMOTE_WRITE;
 
-        if (rdma_create_id(xp->channel, &xp->cmid, 0, RDMA_RS_TCP)) {
-                svc_errx("rdma_create_id failed\n");
-                goto out;
-        }
-
-        /* get attribute of before doing anything else */
-        if (ibv_query_device(xp->cmid->verbs, &devattr)) {
-                svc_errx("query device error\n");
-                goto out;
-        }
-        xp->max_send_wr = devattr.max_qp_wr;
-        xp->max_recv_wr = devattr.max_qp_wr;
-        xp->credits = devattr.max_qp_wr - 1;
-
-        if (rdma_bind_addr(xp->cmid, (struct sockaddr *)&saddr)) {
+        if (rdma_bind_addr(xp->cmid, (struct sockaddr *)&sa)) {
                 svc_errx("bind address error\n");
                 goto out;
         }
@@ -145,7 +139,7 @@ out:
         return NULL;
 }
 
-static void svcrdma_buffer_destroy(struct svcrndzv_xprt *xprt)
+static void svcrdma_buffer_destroy(struct svcrdma_xprt *xprt)
 {
         struct rdma_reply *reply;
         int i;
@@ -180,7 +174,7 @@ static void svcrdma_buffer_destroy(struct svcrndzv_xprt *xprt)
         }
 }
 
-static int svcrdma_buffer_create(struct svcrndzv_xprt *xprt)
+static int svcrdma_buffer_create(struct svcrdma_xprt *xprt)
 {
         struct rdma_request *req;
         int nr;
@@ -189,7 +183,7 @@ static int svcrdma_buffer_create(struct svcrndzv_xprt *xprt)
         int rc;
 
         /* for receive buffers. */
-        count = xprt->max_recv_wr;
+        count = xprt->rndzv->max_recv_wr;
         req = mem_alloc(count * sizeof(*req));
         if (req == NULL)
                 return -ENOMEM;
@@ -215,6 +209,7 @@ static int svcrdma_buffer_create(struct svcrndzv_xprt *xprt)
                 }
 
                 /* register receive buffer */
+                r->xprt       = xprt;
                 r->sge.addr   = r->buffer;
                 r->sge.length = bufsize;
                 r->sge.lkey   = r->mr->lkey;
@@ -231,7 +226,7 @@ static int svcrdma_buffer_create(struct svcrndzv_xprt *xprt)
         }
 
         /* for send buffers. */
-        count = xprt->max_send_wr;
+        count = xprt->rndzv->max_send_wr;
         for (i = 0; i < count; i++) {
                 struct rdma_reply *reply;
 
@@ -247,7 +242,7 @@ static int svcrdma_buffer_create(struct svcrndzv_xprt *xprt)
                 }
 
                 reply->rdma_mr = ibv_reg_mr(xprt->pd, reply->buffer, bufsize,
-                                            xprt->snd_wr_flags);
+                                            xprt->rndzv->snd_wr_flags);
                 if (!reply->mr) {
                         mem_free(reply);
                         free(reply->buffer);
@@ -256,7 +251,7 @@ static int svcrdma_buffer_create(struct svcrndzv_xprt *xprt)
 
                 reply->rpc_mr = ibv_reg_mr(xprt->pd, )
 
-                reply->xprt = NULL;
+                reply->xprt = xprt;
                 reply->sge.addr = reply->buffer;
                 reply->sge.length = bufsize;
                 reply->sge.lkey = reply->mr->lkey;
diff --git a/net/usunrpc/rfc5666/svc_rdma_internal.h b/net/usunrpc/rfc5666/svc_rdma_internal.h
index a1492e2..214809c 100644
--- a/net/usunrpc/rfc5666/svc_rdma_internal.h
+++ b/net/usunrpc/rfc5666/svc_rdma_internal.h
@@ -150,14 +150,6 @@ struct svcrndzv_xprt {
         struct c2_list             xprts;
 
         /**
-          Preallocated buffers used by this xprt.
-         */
-        struct rdma_request      *rcv_bufs;
-        struct rdma_reply        *snd_bufs;
-        struct c2_mutex           bufs_mutex; /**< mutex to protect allocation
-                                                   and free of bufs */
-
-        /**
           Credits management.
           At initialisation time, the total avail credits is determined
           by hardware. Then, for connecting clients, we have to reserve
@@ -215,6 +207,14 @@ struct svcrdma_xprt {
         struct ibv_qp           *qp;
 
         /**
+          Preallocated buffers used by this xprt.
+         */
+        struct rdma_request      *rcv_bufs;
+        struct rdma_reply        *snd_bufs;
+        struct c2_mutex           bufs_mutex; /**< mutex to protect allocation
+                                                   and free of bufs */
+
+        /**
           the following information records the requests and replies this
           export is handling. */
         /**
diff --git a/net/usunrpc/rfc5666/xdr_rdma.c b/net/usunrpc/rfc5666/xdr_rdma.c
index 2216c5c..b88b87e 100644
--- a/net/usunrpc/rfc5666/xdr_rdma.c
+++ b/net/usunrpc/rfc5666/xdr_rdma.c
@@ -1,28 +1,4 @@
-/*
- */
-bool_t xdr_dbuf(XDR *xdrs, struct c2_dbuf *dbuf,
-                bool_t (*xdr)(XDRS *, char *buffer, int buflen))
-{
-        if (!xdr_u_int(xdrs, &dbuf->alignment))
-                return FALSE;
-        if (!xdr_u_int(xdrs, &dbuf->buflen))
-                return FALSE;
 
-        switch(xdrs->x_op) {
-        case XDR_DECODE:
-                if (posix_memalign(&dbuf->buffer, dbuf->alignment,
-                                   dbuf->buflen))
-                        return FALSE;
-        case XDR_ENCODE:
-                if (xdr)
-                        return xdr(xdrs, dbuf->buffer, dbuf->buflen);
-                return xdr_opaque(xdrs, dbuf->buffer, dbuf->buflen);
-        case XDR_FREE:
-                mem_free(dbuf->buffer);
-                return TRUE;
-        }
-        return FALSE;
-}
 
 bool_t xdr_rdma_chunks(XDRS *xdrs, char *buffer, int buflen)
 {
diff --git a/net/usunrpc/usunrpc.h b/net/usunrpc/usunrpc.h
index 327d1a8..de64082 100644
--- a/net/usunrpc/usunrpc.h
+++ b/net/usunrpc/usunrpc.h
@@ -20,6 +20,23 @@ bool_t c2_fop_type_uxdr(const struct c2_fop_field_type *ftype,
 bool_t c2_fop_uxdrproc(XDR *xdrs, struct c2_fop *fop);
 int usunrpc_init(void);
 void usunrpc_fini(void);
+/**
+  xdr function for c2_dbuf.
+  We need this function to encode/decode data buffer in case they are to be
+  transferred via rdma read/write.
+
+  @param[in] xdrs - 
+  @param[in] dbuf - the c2_dbuf will be encoded or decoded
+  @param[in] xdr  - this is a callback function to encode/decode XDR stream;
+                    for rdma, this function must be xdr_rdma_chunks;
+                    otherwise NULL
+
+  @retval TRUE    - success
+  @retval FALSE   - something wrong
+ */
+bool_t c2_xdr_dbuf (XDRS *xdrs, struct c2_dbuf *dbuf,
+                    bool_t (*xdr)(XDRS *, char *, int));
+
 /** @} end of group usunrpc */
 
 /* __COLIBRI_NET_SUNRPC_SUNRPC_H__ */
diff --git a/net/usunrpc/uxdr.c b/net/usunrpc/uxdr.c
index 0f50320..24cc56c 100644
--- a/net/usunrpc/uxdr.c
+++ b/net/usunrpc/uxdr.c
@@ -149,6 +149,32 @@ bool_t c2_fop_uxdrproc(XDR *xdrs, struct c2_fop *fop)
 	return c2_fop_type_uxdr(fop->f_type->ft_top, xdrs, c2_fop_data(fop));
 }
 
+/*
+ */
+bool_t xdr_dbuf(XDR *xdrs, struct c2_dbuf *dbuf,
+                bool_t (*xdr)(XDRS *, char *buffer, int buflen))
+{
+        if (!xdr_u_int(xdrs, &dbuf->alignment))
+                return FALSE;
+        if (!xdr_u_int(xdrs, &dbuf->buflen))
+                return FALSE;
+
+        switch(xdrs->x_op) {
+        case XDR_DECODE:
+                if (posix_memalign(&dbuf->buffer, dbuf->alignment,
+                                   dbuf->buflen))
+                        return FALSE;
+        case XDR_ENCODE:
+                if (xdr)
+                        return xdr(xdrs, dbuf->buffer, dbuf->buflen);
+                return xdr_opaque(xdrs, dbuf->buffer, dbuf->buflen);
+        case XDR_FREE:
+                mem_free(dbuf->buffer);
+                return TRUE;
+        }
+        return FALSE;
+}
+
 /** @} end of group usunrpc */
 
 /*
-- 
1.8.3.2

