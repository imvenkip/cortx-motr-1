From 494e0fab06f03ab9e633997866830d3b777fc039 Mon Sep 17 00:00:00 2001
From: Hua Huang <hua_huang@xyratex.com>
Date: Wed, 27 Mar 2013 15:24:27 +0800
Subject: [PATCH 03/18] rename m0_sns_cm_file_info to m0_sns_cm_file_context.

---
 sns/cm/cm.c   |   8 +--
 sns/cm/iter.c | 224 +++++++++++++++++++++++++++++-----------------------------
 sns/cm/iter.h |  36 +++++-----
 3 files changed, 134 insertions(+), 134 deletions(-)

diff --git a/sns/cm/cm.c b/sns/cm/cm.c
index 47c8af1..9c089cd 100644
--- a/sns/cm/cm.c
+++ b/sns/cm/cm.c
@@ -573,15 +573,15 @@ M0_INTERNAL int m0_sns_cm_buf_attach(struct m0_sns_cm *scm, struct m0_cm_cp *cp)
 
 M0_INTERNAL uint64_t m0_sns_cm_data_seg_nr(struct m0_sns_cm *scm)
 {
-	struct m0_sns_cm_file_info *spl = &scm->sc_it.si_pl;
+	struct m0_sns_cm_file_context *sfc = &scm->sc_it.si_pl;
 
 	M0_PRE(scm != NULL);
 
-	return m0_pdclust_unit_size(spl->spl_pdlayout) %
+	return m0_pdclust_unit_size(sfc->sfc_pdlayout) %
 	       scm->sc_obp.nbp_seg_size ?
-	       m0_pdclust_unit_size(spl->spl_pdlayout) /
+	       m0_pdclust_unit_size(sfc->sfc_pdlayout) /
 	       scm->sc_obp.nbp_seg_size + 1 :
-	       m0_pdclust_unit_size(spl->spl_pdlayout) /
+	       m0_pdclust_unit_size(sfc->sfc_pdlayout) /
 	       scm->sc_obp.nbp_seg_size;
 }
 
diff --git a/sns/cm/iter.c b/sns/cm/iter.c
index 8cc1dde..1b236df 100644
--- a/sns/cm/iter.c
+++ b/sns/cm/iter.c
@@ -145,7 +145,7 @@ M0_INTERNAL struct m0_sns_cm *it2sns(struct m0_sns_cm_iter *it)
 
 M0_INTERNAL uint64_t m0_sns_cm_iter_failures_nr(const struct m0_sns_cm_iter *it)
 {
-	return it->si_pl.spl_group_nr_fail_units;
+	return it->si_pl.sfc_group_nr_fail_units;
 }
 
 static bool is_cob_failed(struct m0_sns_cm_iter *it,
@@ -166,11 +166,11 @@ static bool is_cob_failed(struct m0_sns_cm_iter *it,
  * Returns index of spare unit in the parity group, given the failure index
  * in the group.
  */
-static uint64_t __spare_unit_nr(const struct m0_sns_cm_file_info *spl,
+static uint64_t __spare_unit_nr(const struct m0_sns_cm_file_context *sfc,
 				uint64_t group, uint64_t fidx)
 {
-	return m0_pdclust_N(spl->spl_pdlayout) +
-	       m0_pdclust_K(spl->spl_pdlayout) + fidx;
+	return m0_pdclust_N(sfc->sfc_pdlayout) +
+	       m0_pdclust_K(sfc->sfc_pdlayout) + fidx;
 }
 
 static uint64_t __unit_start(struct m0_sns_cm_iter *it)
@@ -183,7 +183,7 @@ static uint64_t __unit_start(struct m0_sns_cm_iter *it)
 		return 0;
 	case SNS_REBALANCE:
 		/* Start from the first spare unit of the group. */
-		return __spare_unit_nr(&it->si_pl, it->si_pl.spl_sa.sa_group,
+		return __spare_unit_nr(&it->si_pl, it->si_pl.sfc_sa.sa_group,
 				       0);
 	default:
 		 M0_IMPOSSIBLE("op");
@@ -199,10 +199,10 @@ static uint64_t __unit_end(struct m0_sns_cm_iter *it)
 	switch (scm->sc_op) {
 	case SNS_REPAIR:
 		/* End at the last data/parity unit of the group. */
-		return it->si_pl.spl_dpupg;
+		return it->si_pl.sfc_dpupg;
 	case SNS_REBALANCE:
 		/* End at the last spare unit of the group. */
-		return it->si_pl.spl_upg;
+		return it->si_pl.sfc_upg;
 	default:
 		M0_IMPOSSIBLE("op");
 	}
@@ -228,18 +228,18 @@ static void iter_phase_set(struct m0_sns_cm_iter *it, int phase)
 
 static bool
 iter_layout_invariant(enum cm_data_iter_phase phase,
-                      const struct m0_sns_cm_file_info *spl)
+                      const struct m0_sns_cm_file_context *sfc)
 {
 	return ergo(M0_IN(phase, (ITPH_COB_NEXT, ITPH_GROUP_NEXT,
 				 ITPH_GROUP_NEXT_WAIT, ITPH_CP_SETUP)),
-		   spl->spl_pdlayout != NULL &&
-		   spl->spl_pi != NULL && spl->spl_upg != 0 &&
-		   spl->spl_dpupg != 0 && m0_fid_is_set(&spl->spl_gob_fid)) &&
-	       ergo(M0_IN(phase, (ITPH_CP_SETUP)), spl->spl_groups_nr != 0 &&
-		   m0_fid_is_set(&spl->spl_cob_fid) &&
-		   spl->spl_sa.sa_group <= spl->spl_groups_nr &&
-		   spl->spl_sa.sa_unit <= spl->spl_upg &&
-		   spl->spl_ta.ta_obj <= m0_pdclust_P(spl->spl_pdlayout));
+		   sfc->sfc_pdlayout != NULL &&
+		   sfc->sfc_pi != NULL && sfc->sfc_upg != 0 &&
+		   sfc->sfc_dpupg != 0 && m0_fid_is_set(&sfc->sfc_gob_fid)) &&
+	       ergo(M0_IN(phase, (ITPH_CP_SETUP)), sfc->sfc_groups_nr != 0 &&
+		   m0_fid_is_set(&sfc->sfc_cob_fid) &&
+		   sfc->sfc_sa.sa_group <= sfc->sfc_groups_nr &&
+		   sfc->sfc_sa.sa_unit <= sfc->sfc_upg &&
+		   sfc->sfc_ta.ta_obj <= m0_pdclust_P(sfc->sfc_pdlayout));
 }
 
 static bool iter_invariant(const struct m0_sns_cm_iter *it)
@@ -252,14 +252,14 @@ static bool iter_invariant(const struct m0_sns_cm_iter *it)
 
 /**
  * Fetches total size of a file corresponding to the given GOB fid
- * (m0_sns_cm::si_pl::spl_gob_fid). This is used to calculate
+ * (m0_sns_cm::si_pl::sfc_gob_fid). This is used to calculate
  * total number of parity groups per GOB.
  * @note Fetching file attributes may block.
  * @retval 0 on success, IT_WAIT for blocking operation
  */
 static ssize_t file_size(struct m0_sns_cm_iter *it)
 {
-	struct m0_fid      gfid = it->si_pl.spl_gob_fid;
+	struct m0_fid      gfid = it->si_pl.sfc_gob_fid;
 	struct m0_cob_attr attr = { {0} };
 	int                rc;
 
@@ -273,7 +273,7 @@ static ssize_t file_size(struct m0_sns_cm_iter *it)
 	if (rc == 0) {
 		M0_ASSERT(attr.ca_valid | M0_COB_LID);
 		M0_ASSERT(attr.ca_valid | M0_COB_SIZE);
-		it->si_pl.spl_fsize = attr.ca_size;
+		it->si_pl.sfc_fsize = attr.ca_size;
 	} else
 		M0_LOG(M0_ERROR, "getattr rc=%d size = %llu",
 				 rc, (unsigned long long)attr.ca_size);
@@ -282,7 +282,7 @@ static ssize_t file_size(struct m0_sns_cm_iter *it)
 }
 
 /**
- * Fetches file layout for it->si_pl.spl_gob_fid.
+ * Fetches file layout for it->si_pl.sfc_gob_fid.
  * @note This may block.
  * @retval 0 on success, IT_WAIT for blocking operation
  */
@@ -296,7 +296,7 @@ static int cm_layout_fetch(struct m0_sns_cm_iter *it)
 	int                       rc;
 
 	M0_PRE(it != NULL);
-	gfid = it->si_pl.spl_gob_fid;
+	gfid = it->si_pl.sfc_gob_fid;
 	ldom = it->si_ldom;
 
 	M0_LOG(M0_DEBUG, "getattr for %llu:%llu",
@@ -324,13 +324,13 @@ static int cm_layout_fetch(struct m0_sns_cm_iter *it)
 					 (unsigned long long)
 					 m0_pdclust_unit_size(pdl));
 
-			it->si_pl.spl_pdlayout = pdl;
+			it->si_pl.sfc_pdlayout = pdl;
 			/*
 			 * We need only the number of parity units equivalent
 			 * to the number of failures.
 			 */
-			it->si_pl.spl_dpupg = m0_pdclust_N(pdl) + m0_pdclust_K(pdl);
-			it->si_pl.spl_upg = m0_pdclust_N(pdl) + 2 * m0_pdclust_K(pdl);
+			it->si_pl.sfc_dpupg = m0_pdclust_N(pdl) + m0_pdclust_K(pdl);
+			it->si_pl.sfc_upg = m0_pdclust_N(pdl) + 2 * m0_pdclust_K(pdl);
 		}
 	}
 
@@ -395,7 +395,7 @@ M0_INTERNAL uint64_t nr_local_units(struct m0_sns_cm *scm,
 				    const struct m0_fid *fid, uint64_t group)
 {
 	struct m0_sns_cm_iter           *it  = &scm->sc_it;
-	struct m0_sns_cm_file_info      *spl = &it->si_pl;
+	struct m0_sns_cm_file_context   *sfc = &it->si_pl;
 	struct m0_pdclust_src_addr       sa;
 	struct m0_pdclust_tgt_addr       ta;
 	struct m0_fid                    cobfid;
@@ -406,14 +406,14 @@ M0_INTERNAL uint64_t nr_local_units(struct m0_sns_cm *scm,
 	int                              end   = __unit_end(it);
 
 	M0_PRE(iter_invariant(it));
-	M0_PRE(m0_fid_eq(fid, &spl->spl_gob_fid));
+	M0_PRE(m0_fid_eq(fid, &sfc->sfc_gob_fid));
 
 	sa.sa_group = group;
 	for (i = start; i < end; ++i) {
 		sa.sa_unit = i;
 		M0_SET0(&ta);
 		M0_SET0(&cobfid);
-		__unit_to_cobfid(spl->spl_pdlayout, spl->spl_pi, &sa, &ta, fid,
+		__unit_to_cobfid(sfc->sfc_pdlayout, sfc->sfc_pi, &sa, &ta, fid,
 				 &cobfid);
 		rc = cob_locate(it, &cobfid);
 		if (rc == 0 && is_cob_failed(it, &cobfid))
@@ -429,21 +429,21 @@ M0_INTERNAL uint64_t nr_local_units(struct m0_sns_cm *scm,
  * used to copy data from the spare unit to the new device by re-balance
  * operation.
  */
-static uint64_t __group_failed_unit_index(const struct m0_sns_cm_file_info
-					  *spl, uint64_t group, uint64_t fdata)
+static uint64_t __group_failed_unit_index(const struct m0_sns_cm_file_context
+					  *sfc, uint64_t group, uint64_t fdata)
 {
 	struct m0_pdclust_src_addr  sa;
 	struct m0_pdclust_tgt_addr  ta;
-	const struct m0_fid        *gobfid = &spl->spl_gob_fid;
+	const struct m0_fid        *gobfid = &sfc->sfc_gob_fid;
 	struct m0_fid               cobfid;
 	int                         i;
 
 	sa.sa_group = group;
-	for (i = 0; i < spl->spl_dpupg; ++i) {
+	for (i = 0; i < sfc->sfc_dpupg; ++i) {
 		sa.sa_unit = i;
 		M0_SET0(&ta);
 		M0_SET0(&cobfid);
-		__unit_to_cobfid(spl->spl_pdlayout, spl->spl_pi, &sa, &ta, gobfid,
+		__unit_to_cobfid(sfc->sfc_pdlayout, sfc->sfc_pi, &sa, &ta, gobfid,
 				 &cobfid);
 		if (cobfid.f_container == fdata)
 			return i;
@@ -452,15 +452,15 @@ static uint64_t __group_failed_unit_index(const struct m0_sns_cm_file_info
 	return ~0;
 }
 
-static uint64_t __target_unit_nr(const struct m0_sns_cm_file_info *spl,
+static uint64_t __target_unit_nr(const struct m0_sns_cm_file_context *sfc,
 				 uint64_t group, uint64_t fdata,
 				 enum m0_sns_cm_op op, uint64_t fidx)
 {
 	switch (op) {
 	case SNS_REPAIR:
-		return __spare_unit_nr(spl, group, fidx);
+		return __spare_unit_nr(sfc, group, fidx);
 	case SNS_REBALANCE:
-		return __group_failed_unit_index(spl, group, fdata);
+		return __group_failed_unit_index(sfc, group, fdata);
 	default:
 		 M0_IMPOSSIBLE("op");
 	}
@@ -471,7 +471,7 @@ static uint64_t __target_unit_nr(const struct m0_sns_cm_file_info *spl,
 M0_INTERNAL void m0_sns_cm_iter_tgt_unit_to_cob(struct m0_sns_cm_ag *sag)
 {
 	struct m0_sns_cm                *scm = cm2sns(sag->sag_base.cag_cm);
-	struct m0_sns_cm_file_info      *spl = &scm->sc_it.si_pl;
+	struct m0_sns_cm_file_context   *sfc = &scm->sc_it.si_pl;
 	struct m0_pdclust_src_addr       sa;
 	struct m0_pdclust_tgt_addr       ta;
 	struct m0_fid                    gobfid;
@@ -482,25 +482,25 @@ M0_INTERNAL void m0_sns_cm_iter_tgt_unit_to_cob(struct m0_sns_cm_ag *sag)
 		M0_SET0(&ta);
 		M0_SET0(&cobfid);
 		agid2fid(&sag->sag_base, &gobfid);
-		M0_ASSERT(m0_fid_eq(&gobfid, &spl->spl_gob_fid));
+		M0_ASSERT(m0_fid_eq(&gobfid, &sfc->sfc_gob_fid));
 		sa.sa_group = agid2group(&sag->sag_base);
-		sa.sa_unit  = __target_unit_nr(spl, sa.sa_group,
+		sa.sa_unit  = __target_unit_nr(sfc, sa.sa_group,
 					       scm->sc_it.si_fdata[fidx],
 					       scm->sc_op, fidx);
-		__unit_to_cobfid(spl->spl_pdlayout, spl->spl_pi, &sa, &ta, &gobfid,
+		__unit_to_cobfid(sfc->sfc_pdlayout, sfc->sfc_pi, &sa, &ta, &gobfid,
 				 &cobfid);
 		sag->sag_fc[fidx].fc_tgt_cobfid = cobfid;
 		sag->sag_fc[fidx].fc_tgt_cob_index = ta.ta_frame *
-					m0_pdclust_unit_size(spl->spl_pdlayout);
+					m0_pdclust_unit_size(sfc->sfc_pdlayout);
 	}
 }
 
 /**
- * Calculates COB fid for m0_sns_cm_file_info::spl_sa.
+ * Calculates COB fid for m0_sns_cm_file_context::sfc_sa.
  * Saves calculated struct m0_pdclust_tgt_addr in
- * m0_sns_cm_file_info::spl_ta.
+ * m0_sns_cm_file_context::sfc_ta.
  */
-static void unit_to_cobfid(struct m0_sns_cm_file_info *spl,
+static void unit_to_cobfid(struct m0_sns_cm_file_context *sfc,
 			   struct m0_fid *cob_fid_out)
 {
 	struct m0_pdclust_instance  *pi;
@@ -509,12 +509,12 @@ static void unit_to_cobfid(struct m0_sns_cm_file_info *spl,
 	struct m0_pdclust_tgt_addr  *ta;
 	struct m0_fid               *fid;
 
-	fid = &spl->spl_gob_fid;
-	pi = spl->spl_pi;
-	pl = spl->spl_pdlayout;
-	sa = &spl->spl_sa;
-	ta = &spl->spl_ta;
-	spl->spl_cob_is_spare_unit = unit_is_spare(pl, sa->sa_unit);
+	fid = &sfc->sfc_gob_fid;
+	pi = sfc->sfc_pi;
+	pl = sfc->sfc_pdlayout;
+	sa = &sfc->sfc_sa;
+	ta = &sfc->sfc_ta;
+	sfc->sfc_cob_is_spare_unit = unit_is_spare(pl, sa->sa_unit);
 	__unit_to_cobfid(pl, pi, sa, ta, fid, cob_fid_out);
 }
 
@@ -524,24 +524,24 @@ static void unit_to_cobfid(struct m0_sns_cm_file_info *spl,
  */
 static int layout_instance_build(struct m0_sns_cm_iter *it)
 {
-	struct m0_sns_cm_file_info      *spl;
+	struct m0_sns_cm_file_context   *sfc;
 	struct m0_pdclust_layout        *pl;
 	struct m0_layout_instance       *li;
 	struct m0_fid                   *fid;
 	int                              rc = -ENODATA;
 
-	spl = &it->si_pl;
-	fid = &spl->spl_gob_fid;
-	pl  = spl->spl_pdlayout;
+	sfc = &it->si_pl;
+	fid = &sfc->sfc_gob_fid;
+	pl  = sfc->sfc_pdlayout;
         /* Destroy previous pdclust instance */
-	if (spl->spl_pi != NULL)
-		m0_layout_instance_fini(&spl->spl_pi->pi_base);
+	if (sfc->sfc_pi != NULL)
+		m0_layout_instance_fini(&sfc->sfc_pi->pi_base);
 	if (pl != NULL) {
 		rc = m0_layout_instance_build(&pl->pl_base.sl_base, fid, &li);
 		if (rc == 0) {
-			spl->spl_pi = m0_layout_instance_to_pdi(li);
-			spl->spl_sa.sa_group = 0;
-			spl->spl_sa.sa_unit = 0;
+			sfc->sfc_pi = m0_layout_instance_to_pdi(li);
+			sfc->sfc_sa.sa_group = 0;
+			sfc->sfc_sa.sa_unit = 0;
 			iter_phase_set(it, ITPH_GROUP_NEXT);
 		}
 	}
@@ -588,15 +588,15 @@ static int iter_fid_next(struct m0_sns_cm_iter *it)
 		return -ENODATA;
 	if (rc == 0) {
 		/* Save next GOB fid in the iterator. */
-		it->si_pl.spl_gob_fid = fid_next;
+		it->si_pl.sfc_gob_fid = fid_next;
 		/* fini old layout instance and put old layout */
-		if (it->si_pl.spl_pi != NULL) {
-			m0_layout_instance_fini(&it->si_pl.spl_pi->pi_base);
-			it->si_pl.spl_pi = NULL;
+		if (it->si_pl.sfc_pi != NULL) {
+			m0_layout_instance_fini(&it->si_pl.sfc_pi->pi_base);
+			it->si_pl.sfc_pi = NULL;
 		}
-		if (it->si_pl.spl_pdlayout != NULL) {
-			m0_layout_put(m0_pdl_to_layout(it->si_pl.spl_pdlayout));
-			it->si_pl.spl_pdlayout = NULL;
+		if (it->si_pl.sfc_pdlayout != NULL) {
+			m0_layout_put(m0_pdl_to_layout(it->si_pl.sfc_pdlayout));
+			it->si_pl.sfc_pdlayout = NULL;
 		}
 
 		rc = cm_layout_fetch(it);
@@ -610,15 +610,15 @@ static int iter_fid_next(struct m0_sns_cm_iter *it)
 	return rc;
 }
 
-static uint64_t nr_groups(struct m0_sns_cm_file_info *spl)
+static uint64_t nr_groups(struct m0_sns_cm_file_context *sfc)
 {
 	uint64_t nr_data_bytes_per_group;
 
-	nr_data_bytes_per_group =  m0_pdclust_N(spl->spl_pdlayout) *
-				   m0_pdclust_unit_size(spl->spl_pdlayout);
-	return spl->spl_fsize % nr_data_bytes_per_group ?
-	       spl->spl_fsize / nr_data_bytes_per_group + 1 :
-	       spl->spl_fsize / nr_data_bytes_per_group;
+	nr_data_bytes_per_group =  m0_pdclust_N(sfc->sfc_pdlayout) *
+				   m0_pdclust_unit_size(sfc->sfc_pdlayout);
+	return sfc->sfc_fsize % nr_data_bytes_per_group ?
+	       sfc->sfc_fsize / nr_data_bytes_per_group + 1 :
+	       sfc->sfc_fsize / nr_data_bytes_per_group;
 }
 
 /**
@@ -631,7 +631,7 @@ static uint64_t nr_groups(struct m0_sns_cm_file_info *spl)
 static int __group_next(struct m0_sns_cm_iter *it)
 {
 	struct m0_sns_cm                *scm = it2sns(it);
-	struct m0_sns_cm_file_info      *spl;
+	struct m0_sns_cm_file_context   *sfc;
 	struct m0_pdclust_src_addr      *sa;
 	struct m0_fid                    cob_fid;
 	uint64_t                         groups_nr;
@@ -639,22 +639,22 @@ static int __group_next(struct m0_sns_cm_iter *it)
 	uint64_t                         unit;
 	int                              i;
 
-	spl = &it->si_pl;
-	spl->spl_groups_nr = groups_nr = nr_groups(spl);
-	sa = &spl->spl_sa;
+	sfc = &it->si_pl;
+	sfc->sfc_groups_nr = groups_nr = nr_groups(sfc);
+	sa = &sfc->sfc_sa;
 	for (group = sa->sa_group; group < groups_nr; ++group) {
-		spl->spl_group_nr_fail_units = 0;
-		for (unit = 0; unit < spl->spl_dpupg; ++unit) {
-			spl->spl_sa.sa_unit = unit;
-			spl->spl_sa.sa_group = group;
-			unit_to_cobfid(spl, &cob_fid);
+		sfc->sfc_group_nr_fail_units = 0;
+		for (unit = 0; unit < sfc->sfc_dpupg; ++unit) {
+			sfc->sfc_sa.sa_unit = unit;
+			sfc->sfc_sa.sa_group = group;
+			unit_to_cobfid(sfc, &cob_fid);
 			/* find number of failed units in this group. */
 			for (i = 0; i < scm->sc_failures_nr; ++i) {
 				if (cob_fid.f_container == it->si_fdata[i])
-					M0_CNT_INC(spl->spl_group_nr_fail_units);
+					M0_CNT_INC(sfc->sfc_group_nr_fail_units);
 			}
-			if (spl->spl_group_nr_fail_units > 0){
-				spl->spl_sa.sa_unit = __unit_start(it);
+			if (sfc->sfc_group_nr_fail_units > 0){
+				sfc->sfc_sa.sa_unit = __unit_start(it);
 				iter_phase_set(it, ITPH_COB_NEXT);
 				goto out;
 			}
@@ -711,13 +711,13 @@ static void agid_setup(const struct m0_fid *gob_fid, uint64_t group,
 static int iter_ag_setup(struct m0_sns_cm_iter *it)
 {
 	struct m0_sns_cm                *scm = it2sns(it);
-	struct m0_sns_cm_file_info      *spl = &it->si_pl;
+	struct m0_sns_cm_file_context   *sfc = &it->si_pl;
 	struct m0_cm_aggr_group         *ag;
 	struct m0_sns_cm_ag             *sag;
 	struct m0_cm_ag_id               agid;
 	int                              rc;
 
-	agid_setup(&spl->spl_gob_fid, spl->spl_sa.sa_group, &agid);
+	agid_setup(&sfc->sfc_gob_fid, sfc->sfc_sa.sa_group, &agid);
 	ag = m0_cm_aggr_group_locate(&scm->sc_base, &agid);
 	sag = ag2snsag(ag);
 	rc = m0_sns_cm_ag_setup(sag);
@@ -735,14 +735,14 @@ static int iter_cp_setup(struct m0_sns_cm_iter *it)
 	struct m0_sns_cm                *scm = it2sns(it);
 	struct m0_cm_ag_id               agid;
 	struct m0_cm_aggr_group         *ag;
-	struct m0_sns_cm_file_info      *spl;
+	struct m0_sns_cm_file_context   *sfc;
 	struct m0_sns_cm_cp             *scp;
 	uint64_t                         stob_offset;
 	enum m0_sns_cm_op                op = scm->sc_op;
 	int                              rc = 0;
 
-	spl = &it->si_pl;
-	agid_setup(&spl->spl_gob_fid, spl->spl_sa.sa_group, &agid);
+	sfc = &it->si_pl;
+	agid_setup(&sfc->sfc_gob_fid, sfc->sfc_sa.sa_group, &agid);
 	ag = m0_cm_aggr_group_locate(&scm->sc_base, &agid);
 	if (ag == NULL) {
 		rc = m0_cm_aggr_group_alloc(&scm->sc_base, &agid,
@@ -751,19 +751,19 @@ static int iter_cp_setup(struct m0_sns_cm_iter *it)
 			iter_phase_set(it, ITPH_AG_SETUP);
 		return rc;
 	}
-	if ((!spl->spl_cob_is_spare_unit && op == SNS_REPAIR) ||
-	    (spl->spl_cob_is_spare_unit && op == SNS_REBALANCE)) {
-		stob_offset = spl->spl_ta.ta_frame *
-			      m0_pdclust_unit_size(spl->spl_pdlayout);
+	if ((!sfc->sfc_cob_is_spare_unit && op == SNS_REPAIR) ||
+	    (sfc->sfc_cob_is_spare_unit && op == SNS_REBALANCE)) {
+		stob_offset = sfc->sfc_ta.ta_frame *
+			      m0_pdclust_unit_size(sfc->sfc_pdlayout);
 		scp = it->si_cp;
 		scp->sc_base.c_ag = ag;
-		ag->cag_cp_global_nr = spl->spl_dpupg;
+		ag->cag_cp_global_nr = sfc->sfc_dpupg;
 		/*
-		 * spl->spl_sa.sa_unit has gotten one index ahead. Hence actual
-		 * index of the copy packet is (spl->spl_sa.sa_unit - 1).
+		 * sfc->sfc_sa.sa_unit has gotten one index ahead. Hence actual
+		 * index of the copy packet is (sfc->sfc_sa.sa_unit - 1).
 		 */
-		rc = m0_sns_cm_cp_setup(scp, &spl->spl_cob_fid, stob_offset,
-					spl->spl_sa.sa_unit - 1);
+		rc = m0_sns_cm_cp_setup(scp, &sfc->sfc_cob_fid, stob_offset,
+					sfc->sfc_sa.sa_unit - 1);
 		if (rc < 0)
 			return rc;
 
@@ -787,20 +787,20 @@ static int iter_cp_setup(struct m0_sns_cm_iter *it)
  */
 static int iter_cob_next(struct m0_sns_cm_iter *it)
 {
-	struct m0_sns_cm_file_info      *spl;
+	struct m0_sns_cm_file_context   *sfc;
 	struct m0_fid                   *cob_fid;
 	struct m0_pdclust_src_addr      *sa;
 	uint32_t                         upg;
 	int                              rc = 0;
 
-	spl = &it->si_pl;
-	upg = spl->spl_upg;
-	sa = &spl->spl_sa;
+	sfc = &it->si_pl;
+	upg = sfc->sfc_upg;
+	sa = &sfc->sfc_sa;
 
-	cob_fid = &spl->spl_cob_fid;
+	cob_fid = &sfc->sfc_cob_fid;
 	do {
 		if (sa->sa_unit >= upg) {
-			++it->si_pl.spl_sa.sa_group;
+			++it->si_pl.sfc_sa.sa_group;
 			iter_phase_set(it, ITPH_GROUP_NEXT);
 			return 0;
 		}
@@ -810,7 +810,7 @@ static int iter_cob_next(struct m0_sns_cm_iter *it)
 		 * group. If this is the last unit in the parity group then
 		 * proceed to next parity group in the GOB.
 		 */
-		unit_to_cobfid(spl, cob_fid);
+		unit_to_cobfid(sfc, cob_fid);
 		rc = cob_locate(it, cob_fid);
 		++sa->sa_unit;
 	} while (rc == -ENOENT ||
@@ -969,18 +969,18 @@ static int layout_setup(struct m0_sns_cm_iter *it)
 
 static void layout_fini(struct m0_sns_cm_iter *it)
 {
-	struct m0_sns_cm_file_info *spl;
+	struct m0_sns_cm_file_context *sfc;
 
 	M0_PRE(iter_invariant(it));
 
-	spl = &it->si_pl;
-	if (spl->spl_pi != NULL) {
-		m0_layout_instance_fini(&spl->spl_pi->pi_base);
-		spl->spl_pi = NULL;
+	sfc = &it->si_pl;
+	if (sfc->sfc_pi != NULL) {
+		m0_layout_instance_fini(&sfc->sfc_pi->pi_base);
+		sfc->sfc_pi = NULL;
 	}
-	if (spl->spl_pdlayout != NULL) {
-		m0_layout_put(m0_pdl_to_layout(spl->spl_pdlayout));
-		spl->spl_pdlayout = NULL;
+	if (sfc->sfc_pdlayout != NULL) {
+		m0_layout_put(m0_pdl_to_layout(sfc->sfc_pdlayout));
+		sfc->sfc_pdlayout = NULL;
 	}
 	if (it->si_ldom_need_fini == 1) {
 		m0_layout_standard_types_unregister(it->si_ldom);
diff --git a/sns/cm/iter.h b/sns/cm/iter.h
index d7c0ab3..c15135e 100644
--- a/sns/cm/iter.h
+++ b/sns/cm/iter.h
@@ -37,55 +37,55 @@ struct m0_sns_cm;
 struct m0_sns_cm_ag;
 
 /**
- * PDclust Layout details for a GOB (file).
+ * File context in copy machine.
  * This maintains details like, the pdclust layout of the GOB, its corresponding
  * parity group, unit in the parity group which is being processed. Also few
  * more details regarding the current file size, number of units per group, etc.
  */
-struct m0_sns_cm_file_info {
+struct m0_sns_cm_file_context {
 	/** GOB being re-structured. */
-	struct m0_fid                 spl_gob_fid;
+	struct m0_fid                 sfc_gob_fid;
 
-	size_t                        spl_fsize;
+	size_t                        sfc_fsize;
 
 	/** GOB layout. */
-	struct m0_pdclust_layout     *spl_pdlayout;
+	struct m0_pdclust_layout     *sfc_pdlayout;
 
 	/** pdclust instance for a particular GOB. */
-	struct m0_pdclust_instance   *spl_pi;
+	struct m0_pdclust_instance   *sfc_pi;
 
 	/** Total number of units (i.e. N + 2K) in a parity group. */
-	uint32_t                      spl_upg;
+	uint32_t                      sfc_upg;
 
 	/** Total number of data and parity units in a parity group. */
-	uint32_t                      spl_dpupg;
+	uint32_t                      sfc_dpupg;
 
 	/** Total number of parity groups in file. */
-	uint64_t                      spl_groups_nr;
+	uint64_t                      sfc_groups_nr;
 
 	/**
 	 * Unit within a particular parity group corresponding to
 	 * m0_sns_cm_iter::si_gob_fid, of which the data is to be read or
 	 * written.
 	 */
-	struct m0_pdclust_src_addr    spl_sa;
+	struct m0_pdclust_src_addr    sfc_sa;
 
 	/**
 	 * COB index and frame number in the COB, corresponding to
-	 * m0_sns_cm_file_info::spl_sa.
+	 * m0_sns_cm_file_context::sfc_sa.
 	 */
-	struct m0_pdclust_tgt_addr    spl_ta;
+	struct m0_pdclust_tgt_addr    sfc_ta;
 
 	/**
 	 * Total number of failed units in an aggregation group represented by
-	 * m0_sns_cm_file_info::spl_sa.sa_group
+	 * m0_sns_cm_file_context::sfc_sa.sa_group
 	 */
-	uint64_t                      spl_group_nr_fail_units;
+	uint64_t                      sfc_group_nr_fail_units;
 
-	/** COB fid corresponding to m0_sns_cm_file_info::spl_ta. */
-	struct m0_fid                 spl_cob_fid;
+	/** COB fid corresponding to m0_sns_cm_file_context::sfc_ta. */
+	struct m0_fid                 sfc_cob_fid;
 
-	bool                          spl_cob_is_spare_unit;
+	bool                          sfc_cob_is_spare_unit;
 };
 
 /**
@@ -127,7 +127,7 @@ struct m0_sns_cm_iter {
 	int                              si_ldom_need_fini;
 
 	/** Layout details of a file. */
-	struct m0_sns_cm_file_info       si_pl;
+	struct m0_sns_cm_file_context    si_pl;
 
 	/**
 	 * Saved pre allocated copy packet, which needs to be configured.
-- 
1.8.3.2

