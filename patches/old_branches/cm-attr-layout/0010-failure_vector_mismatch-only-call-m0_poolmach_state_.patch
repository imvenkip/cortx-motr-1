From 13157ca4b1cbd5d07d62567080afe05650426f6f Mon Sep 17 00:00:00 2001
From: Hua Huang <hua_huang@xyratex.com>
Date: Thu, 4 Apr 2013 01:04:07 +0800
Subject: [PATCH 10/18] failure_vector_mismatch() only call
 m0_poolmach_state_transit() to update the status. failure_vector_mismatch()
 return -EAGAIN to caller. md5sum is used to verify file content.

---
 ioservice/cob_foms.c                        | 32 ++++++++++++++++++-----------
 ioservice/io_device.c                       |  3 ++-
 ioservice/io_foms.c                         | 15 +++++++-------
 m0t1fs/linux_kernel/file.c                  | 22 +++++++-------------
 m0t1fs/linux_kernel/st/m0t1fs_client_inc.sh |  6 +++---
 pool/pool.c                                 |  2 +-
 6 files changed, 40 insertions(+), 40 deletions(-)

diff --git a/ioservice/cob_foms.c b/ioservice/cob_foms.c
index 0738832..5afec26 100644
--- a/ioservice/cob_foms.c
+++ b/ioservice/cob_foms.c
@@ -210,7 +210,7 @@ static int cc_fom_tick(struct m0_fom *fom)
 	struct m0_fop_cob_op_reply     *reply;
 	struct m0_poolmach             *poolmach;
 	struct m0_reqh                 *reqh;
-	struct m0_pool_version_numbers *verp;
+	struct m0_pool_version_numbers *cliv;
 	struct m0_pool_version_numbers  curr;
 	struct m0_fop_cob_create       *fop;
 
@@ -227,14 +227,18 @@ static int cc_fom_tick(struct m0_fom *fom)
 	reqh = m0_fom_reqh(fom);
 	poolmach = m0_ios_poolmach_get(reqh);
 	m0_poolmach_current_version_get(poolmach, &curr);
-	verp = (struct m0_pool_version_numbers*)&fop->cc_common.c_version;
+	cliv = (struct m0_pool_version_numbers*)&fop->cc_common.c_version;
 
-//	m0_poolmach_version_dump(verp);
-//	m0_poolmach_version_dump(&curr);
+	/*
+	m0_poolmach_version_dump(cliv);
+	m0_poolmach_version_dump(&curr);
+	*/
 	/* Check the client version and server version before any processing */
-	if (!m0_poolmach_version_equal(verp, &curr)) {
+	if (!m0_poolmach_version_equal(cliv, &curr) &&
+		(cliv->pvn_version[PVE_READ] < curr.pvn_version[PVE_READ] &&
+		 cliv->pvn_version[PVE_WRITE] < curr.pvn_version[PVE_WRITE])) {
 		rc = M0_IOP_ERROR_FAILURE_VECTOR_VER_MISMATCH;
-		M0_LOG(M0_FATAL, "VERSION MISMATCH!");
+		M0_LOG(M0_DEBUG, "VERSION MISMATCH!");
 		
 		m0_poolmach_event_list_dump(poolmach);
 		m0_poolmach_device_state_dump(poolmach);
@@ -427,7 +431,7 @@ static int cd_fom_tick(struct m0_fom *fom)
 	struct m0_fop_cob_op_reply     *reply;
 	struct m0_poolmach             *poolmach;
 	struct m0_reqh                 *reqh;
-	struct m0_pool_version_numbers *verp;
+	struct m0_pool_version_numbers *cliv;
 	struct m0_pool_version_numbers  curr;
 	struct m0_fop_cob_delete       *fop;
 
@@ -444,14 +448,18 @@ static int cd_fom_tick(struct m0_fom *fom)
 	reqh = m0_fom_reqh(fom);
 	poolmach = m0_ios_poolmach_get(reqh);
 	m0_poolmach_current_version_get(poolmach, &curr);
-	verp = (struct m0_pool_version_numbers*)&fop->cd_common.c_version;
+	cliv = (struct m0_pool_version_numbers*)&fop->cd_common.c_version;
 
-//	m0_poolmach_version_dump(verp);
-//	m0_poolmach_version_dump(&curr);
+	/*
+	m0_poolmach_version_dump(cliv);
+	m0_poolmach_version_dump(&curr);
+	*/
 	/* Check the client version and server version before any processing */
-	if (!m0_poolmach_version_equal(verp, &curr)) {
+	if (!m0_poolmach_version_equal(cliv, &curr) &&
+		(cliv->pvn_version[PVE_READ] < curr.pvn_version[PVE_READ] &&
+		 cliv->pvn_version[PVE_WRITE] < curr.pvn_version[PVE_WRITE])) {
 		rc = M0_IOP_ERROR_FAILURE_VECTOR_VER_MISMATCH;
-		M0_LOG(M0_FATAL, "VERSION MISMATCH!");
+		M0_LOG(M0_DEBUG, "VERSION MISMATCH!");
 		
 		m0_poolmach_event_list_dump(poolmach);
 		m0_poolmach_device_state_dump(poolmach);
diff --git a/ioservice/io_device.c b/ioservice/io_device.c
index 3639428..01ca71a 100644
--- a/ioservice/io_device.c
+++ b/ioservice/io_device.c
@@ -294,8 +294,9 @@ M0_INTERNAL struct m0_poolmach *m0_ios_poolmach_get(struct m0_reqh *reqh)
 	M0_PRE(reqh != NULL);
 	M0_PRE(!m0_reqh_lockers_is_empty(reqh, poolmach_key));
 
+	m0_rwlock_read_lock(&reqh->rh_rwlock);
 	pm = m0_reqh_lockers_get(reqh, poolmach_key);
-	M0_LOG(M0_FATAL, "pool mach get for reqh=%p, key=%d, res=%p", reqh, poolmach_key, pm);
+	m0_rwlock_read_unlock(&reqh->rh_rwlock);
 	M0_POST(pm != NULL);
 	return pm;
 }
diff --git a/ioservice/io_foms.c b/ioservice/io_foms.c
index 05d5b22..fa36d1e 100644
--- a/ioservice/io_foms.c
+++ b/ioservice/io_foms.c
@@ -1589,9 +1589,6 @@ static int io_finish(struct m0_fom *fom)
 
         m0_stob_put(fom_obj->fcrw_stob);
 
-//        M0_ASSERT(ergo(rc == 0,
-//		       fom_obj->fcrw_req_count == fom_obj->fcrw_count));
-
 	rc = fom_obj->fcrw_rc ?: rc;
         if (rc != 0) {
 		m0_fom_phase_move(fom, rc, M0_FOPH_FAILURE);
@@ -1622,7 +1619,7 @@ static int m0_io_fom_cob_rw_tick(struct m0_fom *fom)
 							 M0_FOPH_FAILURE};
 	struct m0_poolmach                       *poolmach;
 	struct m0_reqh                           *reqh;
-	struct m0_pool_version_numbers           *verp;
+	struct m0_pool_version_numbers           *cliv;
 	struct m0_pool_version_numbers            curr;
 
 	M0_PRE(fom != NULL);
@@ -1639,16 +1636,18 @@ static int m0_io_fom_cob_rw_tick(struct m0_fom *fom)
 	poolmach = m0_ios_poolmach_get(reqh);
 	m0_poolmach_current_version_get(poolmach, &curr);
 	rwfop = io_rw_get(fom->fo_fop);
-	verp = (struct m0_pool_version_numbers*)(&rwfop->crw_version);
+	cliv = (struct m0_pool_version_numbers*)(&rwfop->crw_version);
 
 	/* Check the client version and server version before any processing */
-	if (!m0_poolmach_version_equal(verp, &curr)) {
+	if (!m0_poolmach_version_equal(cliv, &curr) &&
+		(cliv->pvn_version[PVE_READ] < curr.pvn_version[PVE_READ] &&
+		 cliv->pvn_version[PVE_WRITE] < curr.pvn_version[PVE_WRITE])) {
 		rc = M0_FSO_AGAIN;
 		m0_fom_phase_move(fom,
 				  M0_IOP_ERROR_FAILURE_VECTOR_VER_MISMATCH,
 				  M0_FOPH_FAILURE);
-		M0_LOG(M0_FATAL, "VERSION MISMATCH! poolmach = %p", poolmach);
-		m0_poolmach_version_dump(verp);
+		M0_LOG(M0_DEBUG, "VERSION MISMATCH! poolmach = %p", poolmach);
+		m0_poolmach_version_dump(cliv);
 		m0_poolmach_version_dump(&curr);
 		m0_poolmach_event_list_dump(poolmach);
 		m0_poolmach_device_state_dump(poolmach);
diff --git a/m0t1fs/linux_kernel/file.c b/m0t1fs/linux_kernel/file.c
index 46a5a35..cf84505 100644
--- a/m0t1fs/linux_kernel/file.c
+++ b/m0t1fs/linux_kernel/file.c
@@ -4089,10 +4089,9 @@ static void failure_vector_mismatch(struct io_req_fop *irfop)
 	struct m0_fop_cob_rw_reply     *rw_reply;
 	struct m0_fv_version           *reply_version;
 	struct m0_fv_updates           *reply_updates;
-	struct m0_fv_event             *event;
+	struct m0_pool_event           *event;
 	struct io_request              *req;
 	uint32_t                        i = 0;
-	uint32_t                        j = 0;
 
 	M0_PRE(irfop != NULL);
 
@@ -4107,30 +4106,22 @@ static void failure_vector_mismatch(struct io_req_fop *irfop)
 	reply_updates = &rw_reply->rwr_fv_updates;
 	srv = (struct m0_pool_version_numbers *)reply_version;
 	cli = &csb->csb_pool.po_mach->pm_state.pst_version;
-	M0_LOG(M0_FATAL, ">>>VERSION MISMATCH!");
+	M0_LOG(M0_DEBUG, ">>>VERSION MISMATCH!");
 	m0_poolmach_version_dump(cli);
 	m0_poolmach_version_dump(srv);
-	M0_LOG(M0_FATAL, "<<<VERSION MISMATCH!");
-	for (j = 0; j < reply_updates->fvu_count; ++j)
-		M0_LOG(M0_INFO, "reply_updates:%u:type = %u, index = %u,"
-		       "state = %u\n", j,
-		       reply_updates->fvu_events[j].fve_type,
-		       reply_updates->fvu_events[j].fve_index,
-		       reply_updates->fvu_events[j].fve_state);
 	/*
 	 * Retrieve the latest server version and
 	 * updates and apply to the client's copy.
 	 * When -EAGAIN is return, this system
 	 * call will be restarted.
 	 */
-	*cli = *srv;
-
 	while (i < reply_updates->fvu_count) {
-		event = &reply_updates->fvu_events[i];
-		m0_poolmach_state_transit(csb->csb_pool.po_mach,
-				(struct m0_pool_event*)event);
+		event = (struct m0_pool_event*)&reply_updates->fvu_events[i];
+		m0_poolmach_event_dump(event);
+		m0_poolmach_state_transit(csb->csb_pool.po_mach, event);
 		i++;
 	}
+	M0_LOG(M0_DEBUG, "<<<VERSION MISMATCH!");
 }
 
 static void io_bottom_half(struct m0_sm_group *grp, struct m0_sm_ast *ast)
@@ -4173,6 +4164,7 @@ static void io_bottom_half(struct m0_sm_group *grp, struct m0_sm_ast *ast)
 		M0_LOG(M0_INFO, "VERSION_MISMATCH received on fid %llu:%llu\n",
 		       tioreq->ti_fid.f_container, tioreq->ti_fid.f_key);
 		failure_vector_mismatch(irfop);
+		rc = -EAGAIN;
 		irfop->irf_reply_rc = rc;
 	}
 
diff --git a/m0t1fs/linux_kernel/st/m0t1fs_client_inc.sh b/m0t1fs/linux_kernel/st/m0t1fs_client_inc.sh
index 54b1bf4..082035c 100644
--- a/m0t1fs/linux_kernel/st/m0t1fs_client_inc.sh
+++ b/m0t1fs/linux_kernel/st/m0t1fs_client_inc.sh
@@ -481,9 +481,9 @@ sns_repair_test()
 		unmount_and_clean &>> $MERO_TEST_LOGFILE
 		return 1
 	}
-	md5sum $MERO_M0T1FS_MOUNT_DIR/file1_to_repair >  $MERO_M0T1FS_TEST_DIR/md5
-	md5sum $MERO_M0T1FS_MOUNT_DIR/file2_to_repair >> $MERO_M0T1FS_TEST_DIR/md5
-	md5sum $MERO_M0T1FS_MOUNT_DIR/file3_to_repair >> $MERO_M0T1FS_TEST_DIR/md5
+	md5sum $MERO_M0T1FS_MOUNT_DIR/file1_to_repair | tee  $MERO_M0T1FS_TEST_DIR/md5
+	md5sum $MERO_M0T1FS_MOUNT_DIR/file2_to_repair | tee -a $MERO_M0T1FS_TEST_DIR/md5
+	md5sum $MERO_M0T1FS_MOUNT_DIR/file3_to_repair | tee -a $MERO_M0T1FS_TEST_DIR/md5
 	trigger="$MERO_CORE_ROOT/sns/cm/st/m0repair -O 2 -U $unit_size -F $fail_device -n 3
 			-s 10240000 -s 10240000 -s 10240000 -N $NR_DATA -K $NR_PARITY -P $POOL_WIDTH
                          -S ${lnet_nid}:${EP[0]}
diff --git a/pool/pool.c b/pool/pool.c
index f8220fb..ae3a530 100644
--- a/pool/pool.c
+++ b/pool/pool.c
@@ -562,7 +562,7 @@ M0_INTERNAL void m0_poolmach_state_free(struct m0_poolmach *pm,
 static int lno = 0;
 
 /* Change this value to make it more verbose, e.g. to M0_ERROR */
-#define dump_level M0_FATAL
+#define dump_level M0_DEBUG
 
 M0_INTERNAL void m0_poolmach_version_dump(struct m0_pool_version_numbers *v)
 {
-- 
1.8.3.2

