From d0f98bdf515ebf77edd7b40365f93be23279c6e8 Mon Sep 17 00:00:00 2001
From: Hua Huang <hua_huang@xyratex.com>
Date: Mon, 25 Mar 2013 12:28:02 +0800
Subject: [PATCH 01/18] Allocate a layout domain in cm iterator if layout
 domain is not inited in this process address. Otherwise it points to that
 existing layout domain.

---
 sns/cm/iter.c | 55 ++++++++++++++++++++++++++++++++++++++++++-------------
 sns/cm/iter.h | 15 +++++++++++----
 2 files changed, 53 insertions(+), 17 deletions(-)

diff --git a/sns/cm/iter.c b/sns/cm/iter.c
index 2a3c9c5..01a7017 100644
--- a/sns/cm/iter.c
+++ b/sns/cm/iter.c
@@ -874,16 +874,35 @@ static int layout_setup(struct m0_sns_cm_iter *it)
 	struct m0_dbenv                 *dbenv;
 	uint64_t                         lid;
 	int                              rc;
+	struct m0_layout_domain         *ldom;
 
 	dbenv = it->si_dbenv;
-	rc = m0_layout_domain_init(&it->si_lay_dom, dbenv);
-	if (rc != 0)
-		return rc;
-	rc = m0_layout_standard_types_register(&it->si_lay_dom);
-	if (rc != 0) {
-		m0_layout_domain_fini(&it->si_lay_dom);
-		return rc;
+	if (m0_pdclust_layout_type.lt_domain == NULL) {
+		/* pdclust layout has not been registered. This means
+		 * layout domain and standard layouts have not been initialised
+		 * in other places. We need to allocate a new one */
+		M0_ALLOC_PTR(ldom);
+		if (ldom == NULL)
+			return -ENOMEM;
+
+		rc = m0_layout_domain_init(ldom, dbenv);
+		if (rc != 0) {
+			m0_free(ldom);
+			return rc;
+		}
+		rc = m0_layout_standard_types_register(ldom);
+		if (rc != 0) {
+			m0_layout_domain_fini(ldom);
+			m0_free(ldom);
+			return rc;
+		}
+		it->si_ldom_need_fini = 1;
+		it->si_ldom = ldom;
+	} else {
+		it->si_ldom = ldom = m0_pdclust_layout_type.lt_domain;
+		it->si_ldom_need_fini = 0;
 	}
+
 	spl = &it->si_pl;
 	if (spl->spl_N == 0 || spl->spl_K == 0 || spl->spl_P == 0) {
 		spl->spl_N = SNS_DEFAULT_NR_DATA_UNITS;
@@ -893,7 +912,7 @@ static int layout_setup(struct m0_sns_cm_iter *it)
 	lattr.lla_nr = spl->spl_P;
 	lattr.lla_A  = 1;
 	lattr.lla_B  = 1;
-	rc = m0_linear_enum_build(&it->si_lay_dom, &lattr, &spl->spl_le);
+	rc = m0_linear_enum_build(ldom, &lattr, &spl->spl_le);
 	if (rc == 0) {
 		lid                 = SNS_DEFAULT_LAYOUT_ID;
 		plattr.pa_N         = spl->spl_N;
@@ -903,11 +922,11 @@ static int layout_setup(struct m0_sns_cm_iter *it)
 			spl->spl_unit_size = m0_pagesize_get();
 		plattr.pa_unit_size = spl->spl_unit_size;
 		m0_uint128_init(&plattr.pa_seed, "upjumpandpumpim,");
-		rc = m0_pdclust_build(&it->si_lay_dom, lid, &plattr,
+		rc = m0_pdclust_build(ldom, lid, &plattr,
 				      &spl->spl_le->lle_base, &spl->spl_base);
 		if (rc != 0) {
 			m0_layout_enum_fini(&spl->spl_le->lle_base);
-			return rc;
+			goto out;
 		}
 
 		pl = spl->spl_base;
@@ -918,7 +937,14 @@ static int layout_setup(struct m0_sns_cm_iter *it)
 		spl->spl_dpupg = m0_pdclust_N(pl) + m0_pdclust_K(pl);
 		spl->spl_upg = m0_pdclust_N(pl) + 2 * m0_pdclust_K(pl);
 	}
-
+out:
+	if (rc != 0) {
+		if (it->si_ldom_need_fini == 1) {
+			m0_layout_standard_types_unregister(ldom);
+			m0_layout_domain_fini(ldom);
+			m0_free(ldom);
+		}
+	}
 	return rc;
 }
 
@@ -934,8 +960,11 @@ static void layout_fini(struct m0_sns_cm_iter *it)
 		spl->spl_pi = NULL;
 	}
 	m0_layout_put(m0_pdl_to_layout(spl->spl_base));
-	m0_layout_standard_types_unregister(&it->si_lay_dom);
-	m0_layout_domain_fini(&it->si_lay_dom);
+	if (it->si_ldom_need_fini == 1) {
+		m0_layout_standard_types_unregister(it->si_ldom);
+		m0_layout_domain_fini(it->si_ldom);
+		m0_free(it->si_ldom);
+	}
 }
 
 M0_INTERNAL int m0_sns_cm_iter_init(struct m0_sns_cm_iter *it)
diff --git a/sns/cm/iter.h b/sns/cm/iter.h
index c19ce48..e0309ad 100644
--- a/sns/cm/iter.h
+++ b/sns/cm/iter.h
@@ -126,11 +126,18 @@ struct m0_sns_cm_iter {
 
 	struct m0_cob_domain            *si_cob_dom;
 
-        /*
-         * XXX Temporary location for layout domain required to build pdclust
-         * layout.
+        /**
+         * layout domain. If layout domain is already initialised in other
+         * service, this will be a pointer to that domain. Otherwise a new
+         * layout domain will be allocated.
          */
-        struct m0_layout_domain          si_lay_dom;
+	struct m0_layout_domain         *si_ldom;
+	/**
+	 * layout domain need to fini or not.
+	 * If layout domain is shared with other service, then no need to
+	 * init and fini the above layout domain.
+	 */
+	int                              si_ldom_need_fini;
 
 	/** Layout details of a file. */
 	struct m0_sns_cm_pdclust_layout  si_pl;
-- 
1.8.3.2

