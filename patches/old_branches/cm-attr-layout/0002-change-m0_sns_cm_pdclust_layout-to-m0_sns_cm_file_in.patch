From 9852b2d944c613daa93d2cd086e576b9c9d339e4 Mon Sep 17 00:00:00 2001
From: Hua Huang <hua_huang@xyratex.com>
Date: Tue, 26 Mar 2013 12:32:00 +0800
Subject: [PATCH 02/18] change m0_sns_cm_pdclust_layout to m0_sns_cm_file_info.
 remove {spl_N,spl_K,spl_P,spl_unit_size} from m0_sns_cm_file_info: not
 needed. file_size(): get file size by m0_ios_mds_getattr().
 cm_layout_fetch(): get layout by m0_ios_mds_layout_get().

---
 ioservice/io_service.c  |   1 +
 sns/cm/cm.c             |   8 +-
 sns/cm/iter.c           | 214 ++++++++++++++++++++++++++----------------------
 sns/cm/iter.h           |  25 ++----
 sns/cm/st/trigger_fom.c |   4 -
 sns/cm/ut/cm.c          |   4 -
 6 files changed, 129 insertions(+), 127 deletions(-)

diff --git a/ioservice/io_service.c b/ioservice/io_service.c
index 83b070a..f6ee6cd 100644
--- a/ioservice/io_service.c
+++ b/ioservice/io_service.c
@@ -702,6 +702,7 @@ M0_INTERNAL void m0_ios_mds_rpc_ctx_fini(struct m0_reqh_service *service)
 	m0_rwlock_write_lock(&reqh->rh_rwlock);
 	rpc_client_ctx = m0_reqh_lockers_get(reqh, ios_mds_rpc_ctx_key);
 	m0_reqh_lockers_clear(reqh, ios_mds_rpc_ctx_key);
+	ios_mds_rpc_ctx_key = 0;
 	m0_rwlock_write_unlock(&reqh->rh_rwlock);
 
 	m0_rpc_client_stop(rpc_client_ctx);
diff --git a/sns/cm/cm.c b/sns/cm/cm.c
index 48e7cbf..47c8af1 100644
--- a/sns/cm/cm.c
+++ b/sns/cm/cm.c
@@ -573,15 +573,15 @@ M0_INTERNAL int m0_sns_cm_buf_attach(struct m0_sns_cm *scm, struct m0_cm_cp *cp)
 
 M0_INTERNAL uint64_t m0_sns_cm_data_seg_nr(struct m0_sns_cm *scm)
 {
-	struct m0_sns_cm_pdclust_layout *spl = &scm->sc_it.si_pl;
+	struct m0_sns_cm_file_info *spl = &scm->sc_it.si_pl;
 
 	M0_PRE(scm != NULL);
 
-	return m0_pdclust_unit_size(spl->spl_base) %
+	return m0_pdclust_unit_size(spl->spl_pdlayout) %
 	       scm->sc_obp.nbp_seg_size ?
-	       m0_pdclust_unit_size(spl->spl_base) /
+	       m0_pdclust_unit_size(spl->spl_pdlayout) /
 	       scm->sc_obp.nbp_seg_size + 1 :
-	       m0_pdclust_unit_size(spl->spl_base) /
+	       m0_pdclust_unit_size(spl->spl_pdlayout) /
 	       scm->sc_obp.nbp_seg_size;
 }
 
diff --git a/sns/cm/iter.c b/sns/cm/iter.c
index 01a7017..8cc1dde 100644
--- a/sns/cm/iter.c
+++ b/sns/cm/iter.c
@@ -166,10 +166,11 @@ static bool is_cob_failed(struct m0_sns_cm_iter *it,
  * Returns index of spare unit in the parity group, given the failure index
  * in the group.
  */
-static uint64_t __spare_unit_nr(const struct m0_sns_cm_pdclust_layout *spl,
+static uint64_t __spare_unit_nr(const struct m0_sns_cm_file_info *spl,
 				uint64_t group, uint64_t fidx)
 {
-	return spl->spl_N + spl->spl_K + fidx;
+	return m0_pdclust_N(spl->spl_pdlayout) +
+	       m0_pdclust_K(spl->spl_pdlayout) + fidx;
 }
 
 static uint64_t __unit_start(struct m0_sns_cm_iter *it)
@@ -227,20 +228,18 @@ static void iter_phase_set(struct m0_sns_cm_iter *it, int phase)
 
 static bool
 iter_layout_invariant(enum cm_data_iter_phase phase,
-                      const struct m0_sns_cm_pdclust_layout *spl)
+                      const struct m0_sns_cm_file_info *spl)
 {
 	return ergo(M0_IN(phase, (ITPH_COB_NEXT, ITPH_GROUP_NEXT,
 				 ITPH_GROUP_NEXT_WAIT, ITPH_CP_SETUP)),
-		   spl->spl_base != NULL && spl->spl_le != NULL &&
-		   spl->spl_pi != NULL && spl->spl_N != 0 && spl->spl_K != 0 &&
-		   spl->spl_P != 0 && spl->spl_upg != 0 &&
-		   spl->spl_P >= (spl->spl_N + 2 * spl->spl_K) &&
+		   spl->spl_pdlayout != NULL &&
+		   spl->spl_pi != NULL && spl->spl_upg != 0 &&
 		   spl->spl_dpupg != 0 && m0_fid_is_set(&spl->spl_gob_fid)) &&
 	       ergo(M0_IN(phase, (ITPH_CP_SETUP)), spl->spl_groups_nr != 0 &&
 		   m0_fid_is_set(&spl->spl_cob_fid) &&
 		   spl->spl_sa.sa_group <= spl->spl_groups_nr &&
 		   spl->spl_sa.sa_unit <= spl->spl_upg &&
-		   spl->spl_ta.ta_obj <= spl->spl_P);
+		   spl->spl_ta.ta_obj <= m0_pdclust_P(spl->spl_pdlayout));
 }
 
 static bool iter_invariant(const struct m0_sns_cm_iter *it)
@@ -255,29 +254,85 @@ static bool iter_invariant(const struct m0_sns_cm_iter *it)
  * Fetches total size of a file corresponding to the given GOB fid
  * (m0_sns_cm::si_pl::spl_gob_fid). This is used to calculate
  * total number of parity groups per GOB.
- * Returns 0 * @todo Currently the file size is hard coded, but eventually it would be
- * retrieved as part of file attributes.
  * @note Fetching file attributes may block.
  * @retval 0 on success, IT_WAIT for blocking operation
  */
 static ssize_t file_size(struct m0_sns_cm_iter *it)
 {
+	struct m0_fid      gfid = it->si_pl.spl_gob_fid;
+	struct m0_cob_attr attr = { {0} };
+	int                rc;
+
 	M0_PRE(it != NULL);
 
-	it->si_pl.spl_fsize = m0_trigger_file_size_get(&it->si_pl.spl_gob_fid);
+	M0_LOG(M0_DEBUG, "getattr for %llu:%llu",
+			 (unsigned long long)gfid.f_container,
+			 (unsigned long long)gfid.f_key);
+	rc = m0_ios_mds_getattr(it->si_cp->sc_base.c_fom.fo_service->rs_reqh,
+				&gfid, &attr);
+	if (rc == 0) {
+		M0_ASSERT(attr.ca_valid | M0_COB_LID);
+		M0_ASSERT(attr.ca_valid | M0_COB_SIZE);
+		it->si_pl.spl_fsize = attr.ca_size;
+	} else
+		M0_LOG(M0_ERROR, "getattr rc=%d size = %llu",
+				 rc, (unsigned long long)attr.ca_size);
 
 	return 0;
 }
 
 /**
- * Fetches file layout for scm->sc_it.si_pl.spl_gob_fid.
- * @todo To fetch file layout as part of file attributes.
+ * Fetches file layout for it->si_pl.spl_gob_fid.
  * @note This may block.
  * @retval 0 on success, IT_WAIT for blocking operation
  */
 static int cm_layout_fetch(struct m0_sns_cm_iter *it)
 {
+	struct m0_fid             gfid;
+	struct m0_cob_attr        attr = { {0} };
+	struct m0_layout_domain  *ldom;
+	struct m0_pdclust_layout *pdl = NULL;
+	struct m0_layout         *layout = NULL;
+	int                       rc;
+
 	M0_PRE(it != NULL);
+	gfid = it->si_pl.spl_gob_fid;
+	ldom = it->si_ldom;
+
+	M0_LOG(M0_DEBUG, "getattr for %llu:%llu",
+			 (unsigned long long)gfid.f_container,
+			 (unsigned long long)gfid.f_key);
+	rc = m0_ios_mds_getattr(it->si_cp->sc_base.c_fom.fo_service->rs_reqh,
+				&gfid, &attr);
+	M0_LOG(M0_DEBUG, "rc = %d lid = %lld", rc,
+			 (unsigned long long)attr.ca_lid);
+	if (rc == 0) {
+		struct m0_fom  *fom = &it->si_cp->sc_base.c_fom;
+		struct m0_reqh *reqh = fom->fo_service->rs_reqh;
+		M0_ASSERT(attr.ca_valid | M0_COB_LID);
+
+		M0_LOG(M0_FATAL, "getlayout");
+		rc = m0_ios_mds_layout_get(reqh, ldom, attr.ca_lid, &layout);
+		M0_LOG(M0_FATAL, "getlayout rc = %d", rc);
+		if (rc == 0) {
+			pdl = m0_layout_to_pdl(layout);
+			M0_LOG(M0_FATAL, "pdl N=%d,K=%d,P=%d,"
+					 "unit_size=%llu",
+					 m0_pdclust_N(pdl),
+					 m0_pdclust_K(pdl),
+					 m0_pdclust_P(pdl),
+					 (unsigned long long)
+					 m0_pdclust_unit_size(pdl));
+
+			it->si_pl.spl_pdlayout = pdl;
+			/*
+			 * We need only the number of parity units equivalent
+			 * to the number of failures.
+			 */
+			it->si_pl.spl_dpupg = m0_pdclust_N(pdl) + m0_pdclust_K(pdl);
+			it->si_pl.spl_upg = m0_pdclust_N(pdl) + 2 * m0_pdclust_K(pdl);
+		}
+	}
 
 	return 0;
 }
@@ -340,7 +395,7 @@ M0_INTERNAL uint64_t nr_local_units(struct m0_sns_cm *scm,
 				    const struct m0_fid *fid, uint64_t group)
 {
 	struct m0_sns_cm_iter           *it  = &scm->sc_it;
-	struct m0_sns_cm_pdclust_layout *spl = &it->si_pl;
+	struct m0_sns_cm_file_info      *spl = &it->si_pl;
 	struct m0_pdclust_src_addr       sa;
 	struct m0_pdclust_tgt_addr       ta;
 	struct m0_fid                    cobfid;
@@ -358,7 +413,7 @@ M0_INTERNAL uint64_t nr_local_units(struct m0_sns_cm *scm,
 		sa.sa_unit = i;
 		M0_SET0(&ta);
 		M0_SET0(&cobfid);
-		__unit_to_cobfid(spl->spl_base, spl->spl_pi, &sa, &ta, fid,
+		__unit_to_cobfid(spl->spl_pdlayout, spl->spl_pi, &sa, &ta, fid,
 				 &cobfid);
 		rc = cob_locate(it, &cobfid);
 		if (rc == 0 && is_cob_failed(it, &cobfid))
@@ -374,7 +429,7 @@ M0_INTERNAL uint64_t nr_local_units(struct m0_sns_cm *scm,
  * used to copy data from the spare unit to the new device by re-balance
  * operation.
  */
-static uint64_t __group_failed_unit_index(const struct m0_sns_cm_pdclust_layout
+static uint64_t __group_failed_unit_index(const struct m0_sns_cm_file_info
 					  *spl, uint64_t group, uint64_t fdata)
 {
 	struct m0_pdclust_src_addr  sa;
@@ -388,7 +443,7 @@ static uint64_t __group_failed_unit_index(const struct m0_sns_cm_pdclust_layout
 		sa.sa_unit = i;
 		M0_SET0(&ta);
 		M0_SET0(&cobfid);
-		__unit_to_cobfid(spl->spl_base, spl->spl_pi, &sa, &ta, gobfid,
+		__unit_to_cobfid(spl->spl_pdlayout, spl->spl_pi, &sa, &ta, gobfid,
 				 &cobfid);
 		if (cobfid.f_container == fdata)
 			return i;
@@ -397,7 +452,7 @@ static uint64_t __group_failed_unit_index(const struct m0_sns_cm_pdclust_layout
 	return ~0;
 }
 
-static uint64_t __target_unit_nr(const struct m0_sns_cm_pdclust_layout *spl,
+static uint64_t __target_unit_nr(const struct m0_sns_cm_file_info *spl,
 				 uint64_t group, uint64_t fdata,
 				 enum m0_sns_cm_op op, uint64_t fidx)
 {
@@ -416,7 +471,7 @@ static uint64_t __target_unit_nr(const struct m0_sns_cm_pdclust_layout *spl,
 M0_INTERNAL void m0_sns_cm_iter_tgt_unit_to_cob(struct m0_sns_cm_ag *sag)
 {
 	struct m0_sns_cm                *scm = cm2sns(sag->sag_base.cag_cm);
-	struct m0_sns_cm_pdclust_layout *spl = &scm->sc_it.si_pl;
+	struct m0_sns_cm_file_info      *spl = &scm->sc_it.si_pl;
 	struct m0_pdclust_src_addr       sa;
 	struct m0_pdclust_tgt_addr       ta;
 	struct m0_fid                    gobfid;
@@ -432,20 +487,20 @@ M0_INTERNAL void m0_sns_cm_iter_tgt_unit_to_cob(struct m0_sns_cm_ag *sag)
 		sa.sa_unit  = __target_unit_nr(spl, sa.sa_group,
 					       scm->sc_it.si_fdata[fidx],
 					       scm->sc_op, fidx);
-		__unit_to_cobfid(spl->spl_base, spl->spl_pi, &sa, &ta, &gobfid,
+		__unit_to_cobfid(spl->spl_pdlayout, spl->spl_pi, &sa, &ta, &gobfid,
 				 &cobfid);
 		sag->sag_fc[fidx].fc_tgt_cobfid = cobfid;
 		sag->sag_fc[fidx].fc_tgt_cob_index = ta.ta_frame *
-					m0_pdclust_unit_size(spl->spl_base);
+					m0_pdclust_unit_size(spl->spl_pdlayout);
 	}
 }
 
 /**
- * Calculates COB fid for m0_sns_cm_pdclust_layout::spl_sa.
+ * Calculates COB fid for m0_sns_cm_file_info::spl_sa.
  * Saves calculated struct m0_pdclust_tgt_addr in
- * m0_sns_cm_pdclust_layout::spl_ta.
+ * m0_sns_cm_file_info::spl_ta.
  */
-static void unit_to_cobfid(struct m0_sns_cm_pdclust_layout *spl,
+static void unit_to_cobfid(struct m0_sns_cm_file_info *spl,
 			   struct m0_fid *cob_fid_out)
 {
 	struct m0_pdclust_instance  *pi;
@@ -456,7 +511,7 @@ static void unit_to_cobfid(struct m0_sns_cm_pdclust_layout *spl,
 
 	fid = &spl->spl_gob_fid;
 	pi = spl->spl_pi;
-	pl = spl->spl_base;
+	pl = spl->spl_pdlayout;
 	sa = &spl->spl_sa;
 	ta = &spl->spl_ta;
 	spl->spl_cob_is_spare_unit = unit_is_spare(pl, sa->sa_unit);
@@ -467,34 +522,35 @@ static void unit_to_cobfid(struct m0_sns_cm_pdclust_layout *spl,
  * Builds layout instance for new GOB fid calculated in ITPH_FID_NEXT phase.
  * @see iter_fid_next()
  */
-static int fid_layout_build(struct m0_sns_cm_iter *it)
+static int layout_instance_build(struct m0_sns_cm_iter *it)
 {
-	struct m0_sns_cm_pdclust_layout *spl;
+	struct m0_sns_cm_file_info      *spl;
 	struct m0_pdclust_layout        *pl;
 	struct m0_layout_instance       *li;
 	struct m0_fid                   *fid;
-	int                              rc;
+	int                              rc = -ENODATA;
 
 	spl = &it->si_pl;
 	fid = &spl->spl_gob_fid;
-	pl  = spl->spl_base;
+	pl  = spl->spl_pdlayout;
         /* Destroy previous pdclust instance */
 	if (spl->spl_pi != NULL)
 		m0_layout_instance_fini(&spl->spl_pi->pi_base);
-	rc = m0_layout_instance_build(&pl->pl_base.sl_base, fid, &li);
-	if (rc == 0) {
-		spl->spl_pi = m0_layout_instance_to_pdi(li);
-		spl->spl_sa.sa_group = 0;
-		spl->spl_sa.sa_unit = 0;
-		iter_phase_set(it, ITPH_GROUP_NEXT);
+	if (pl != NULL) {
+		rc = m0_layout_instance_build(&pl->pl_base.sl_base, fid, &li);
+		if (rc == 0) {
+			spl->spl_pi = m0_layout_instance_to_pdi(li);
+			spl->spl_sa.sa_group = 0;
+			spl->spl_sa.sa_unit = 0;
+			iter_phase_set(it, ITPH_GROUP_NEXT);
+		}
 	}
-
 	return rc;
 }
 
 static int iter_fid_next_wait(struct m0_sns_cm_iter *it)
 {
-	return fid_layout_build(it);
+	return layout_instance_build(it);
 }
 
 /* Uses name space iterator. */
@@ -533,23 +589,33 @@ static int iter_fid_next(struct m0_sns_cm_iter *it)
 	if (rc == 0) {
 		/* Save next GOB fid in the iterator. */
 		it->si_pl.spl_gob_fid = fid_next;
+		/* fini old layout instance and put old layout */
+		if (it->si_pl.spl_pi != NULL) {
+			m0_layout_instance_fini(&it->si_pl.spl_pi->pi_base);
+			it->si_pl.spl_pi = NULL;
+		}
+		if (it->si_pl.spl_pdlayout != NULL) {
+			m0_layout_put(m0_pdl_to_layout(it->si_pl.spl_pdlayout));
+			it->si_pl.spl_pdlayout = NULL;
+		}
+
 		rc = cm_layout_fetch(it);
 		if (rc == IT_WAIT) {
 			iter_phase_set(it, ITPH_FID_NEXT_WAIT);
 			return rc;
 		}
-		rc = fid_layout_build(it);
+		rc = layout_instance_build(it);
 	}
 
 	return rc;
 }
 
-static uint64_t nr_groups(struct m0_sns_cm_pdclust_layout *spl)
+static uint64_t nr_groups(struct m0_sns_cm_file_info *spl)
 {
 	uint64_t nr_data_bytes_per_group;
 
-	nr_data_bytes_per_group =  m0_pdclust_N(spl->spl_base) *
-				   m0_pdclust_unit_size(spl->spl_base);
+	nr_data_bytes_per_group =  m0_pdclust_N(spl->spl_pdlayout) *
+				   m0_pdclust_unit_size(spl->spl_pdlayout);
 	return spl->spl_fsize % nr_data_bytes_per_group ?
 	       spl->spl_fsize / nr_data_bytes_per_group + 1 :
 	       spl->spl_fsize / nr_data_bytes_per_group;
@@ -565,7 +631,7 @@ static uint64_t nr_groups(struct m0_sns_cm_pdclust_layout *spl)
 static int __group_next(struct m0_sns_cm_iter *it)
 {
 	struct m0_sns_cm                *scm = it2sns(it);
-	struct m0_sns_cm_pdclust_layout *spl;
+	struct m0_sns_cm_file_info      *spl;
 	struct m0_pdclust_src_addr      *sa;
 	struct m0_fid                    cob_fid;
 	uint64_t                         groups_nr;
@@ -645,7 +711,7 @@ static void agid_setup(const struct m0_fid *gob_fid, uint64_t group,
 static int iter_ag_setup(struct m0_sns_cm_iter *it)
 {
 	struct m0_sns_cm                *scm = it2sns(it);
-	struct m0_sns_cm_pdclust_layout *spl = &it->si_pl;
+	struct m0_sns_cm_file_info      *spl = &it->si_pl;
 	struct m0_cm_aggr_group         *ag;
 	struct m0_sns_cm_ag             *sag;
 	struct m0_cm_ag_id               agid;
@@ -669,7 +735,7 @@ static int iter_cp_setup(struct m0_sns_cm_iter *it)
 	struct m0_sns_cm                *scm = it2sns(it);
 	struct m0_cm_ag_id               agid;
 	struct m0_cm_aggr_group         *ag;
-	struct m0_sns_cm_pdclust_layout *spl;
+	struct m0_sns_cm_file_info      *spl;
 	struct m0_sns_cm_cp             *scp;
 	uint64_t                         stob_offset;
 	enum m0_sns_cm_op                op = scm->sc_op;
@@ -688,7 +754,7 @@ static int iter_cp_setup(struct m0_sns_cm_iter *it)
 	if ((!spl->spl_cob_is_spare_unit && op == SNS_REPAIR) ||
 	    (spl->spl_cob_is_spare_unit && op == SNS_REBALANCE)) {
 		stob_offset = spl->spl_ta.ta_frame *
-			      m0_pdclust_unit_size(spl->spl_base);
+			      m0_pdclust_unit_size(spl->spl_pdlayout);
 		scp = it->si_cp;
 		scp->sc_base.c_ag = ag;
 		ag->cag_cp_global_nr = spl->spl_dpupg;
@@ -721,7 +787,7 @@ static int iter_cp_setup(struct m0_sns_cm_iter *it)
  */
 static int iter_cob_next(struct m0_sns_cm_iter *it)
 {
-	struct m0_sns_cm_pdclust_layout *spl;
+	struct m0_sns_cm_file_info      *spl;
 	struct m0_fid                   *cob_fid;
 	struct m0_pdclust_src_addr      *sa;
 	uint32_t                         upg;
@@ -867,12 +933,7 @@ static const struct m0_sm_conf cm_iter_sm_conf = {
 static int layout_setup(struct m0_sns_cm_iter *it)
 {
 
-	struct m0_sns_cm_pdclust_layout *spl;
-	struct m0_layout_linear_attr     lattr;
-	struct m0_pdclust_attr           plattr;
-	struct m0_pdclust_layout        *pl;
 	struct m0_dbenv                 *dbenv;
-	uint64_t                         lid;
 	int                              rc;
 	struct m0_layout_domain         *ldom;
 
@@ -903,54 +964,12 @@ static int layout_setup(struct m0_sns_cm_iter *it)
 		it->si_ldom_need_fini = 0;
 	}
 
-	spl = &it->si_pl;
-	if (spl->spl_N == 0 || spl->spl_K == 0 || spl->spl_P == 0) {
-		spl->spl_N = SNS_DEFAULT_NR_DATA_UNITS;
-		spl->spl_K = SNS_DEFAULT_NR_PARITY_UNITS;
-		spl->spl_P = SNS_DEFAULT_POOL_WIDTH;
-	}
-	lattr.lla_nr = spl->spl_P;
-	lattr.lla_A  = 1;
-	lattr.lla_B  = 1;
-	rc = m0_linear_enum_build(ldom, &lattr, &spl->spl_le);
-	if (rc == 0) {
-		lid                 = SNS_DEFAULT_LAYOUT_ID;
-		plattr.pa_N         = spl->spl_N;
-		plattr.pa_K         = spl->spl_K;
-		plattr.pa_P         = spl->spl_P;
-		if (spl->spl_unit_size == 0)
-			spl->spl_unit_size = m0_pagesize_get();
-		plattr.pa_unit_size = spl->spl_unit_size;
-		m0_uint128_init(&plattr.pa_seed, "upjumpandpumpim,");
-		rc = m0_pdclust_build(ldom, lid, &plattr,
-				      &spl->spl_le->lle_base, &spl->spl_base);
-		if (rc != 0) {
-			m0_layout_enum_fini(&spl->spl_le->lle_base);
-			goto out;
-		}
-
-		pl = spl->spl_base;
-		/*
-		 * We need only the number of parity units equivalent to the
-		 * number of failures.
-		 */
-		spl->spl_dpupg = m0_pdclust_N(pl) + m0_pdclust_K(pl);
-		spl->spl_upg = m0_pdclust_N(pl) + 2 * m0_pdclust_K(pl);
-	}
-out:
-	if (rc != 0) {
-		if (it->si_ldom_need_fini == 1) {
-			m0_layout_standard_types_unregister(ldom);
-			m0_layout_domain_fini(ldom);
-			m0_free(ldom);
-		}
-	}
-	return rc;
+	return 0;
 }
 
 static void layout_fini(struct m0_sns_cm_iter *it)
 {
-	struct m0_sns_cm_pdclust_layout *spl;
+	struct m0_sns_cm_file_info *spl;
 
 	M0_PRE(iter_invariant(it));
 
@@ -959,7 +978,10 @@ static void layout_fini(struct m0_sns_cm_iter *it)
 		m0_layout_instance_fini(&spl->spl_pi->pi_base);
 		spl->spl_pi = NULL;
 	}
-	m0_layout_put(m0_pdl_to_layout(spl->spl_base));
+	if (spl->spl_pdlayout != NULL) {
+		m0_layout_put(m0_pdl_to_layout(spl->spl_pdlayout));
+		spl->spl_pdlayout = NULL;
+	}
 	if (it->si_ldom_need_fini == 1) {
 		m0_layout_standard_types_unregister(it->si_ldom);
 		m0_layout_domain_fini(it->si_ldom);
diff --git a/sns/cm/iter.h b/sns/cm/iter.h
index e0309ad..d7c0ab3 100644
--- a/sns/cm/iter.h
+++ b/sns/cm/iter.h
@@ -42,16 +42,14 @@ struct m0_sns_cm_ag;
  * parity group, unit in the parity group which is being processed. Also few
  * more details regarding the current file size, number of units per group, etc.
  */
-struct m0_sns_cm_pdclust_layout {
+struct m0_sns_cm_file_info {
 	/** GOB being re-structured. */
 	struct m0_fid                 spl_gob_fid;
 
 	size_t                        spl_fsize;
 
 	/** GOB layout. */
-	struct m0_pdclust_layout     *spl_base;
-
-	struct m0_layout_linear_enum *spl_le;
+	struct m0_pdclust_layout     *spl_pdlayout;
 
 	/** pdclust instance for a particular GOB. */
 	struct m0_pdclust_instance   *spl_pi;
@@ -59,17 +57,6 @@ struct m0_sns_cm_pdclust_layout {
 	/** Total number of units (i.e. N + 2K) in a parity group. */
 	uint32_t                      spl_upg;
 
-	/** Number of data units in the parity group. */
-	uint32_t                      spl_N;
-
-	/** Number of parity units in the parity group. */
-	uint32_t                      spl_K;
-
-	/** Total pool width. */
-	uint32_t                      spl_P;
-
-	uint32_t                      spl_unit_size;
-
 	/** Total number of data and parity units in a parity group. */
 	uint32_t                      spl_dpupg;
 
@@ -85,17 +72,17 @@ struct m0_sns_cm_pdclust_layout {
 
 	/**
 	 * COB index and frame number in the COB, corresponding to
-	 * m0_sns_cm_pdclust_layout::spl_sa.
+	 * m0_sns_cm_file_info::spl_sa.
 	 */
 	struct m0_pdclust_tgt_addr    spl_ta;
 
 	/**
 	 * Total number of failed units in an aggregation group represented by
-	 * m0_sns_cm_pdclust_layout::spl_sa.sa_group
+	 * m0_sns_cm_file_info::spl_sa.sa_group
 	 */
 	uint64_t                      spl_group_nr_fail_units;
 
-	/** COB fid corresponding to m0_sns_cm_pdclust_layout::spl_ta. */
+	/** COB fid corresponding to m0_sns_cm_file_info::spl_ta. */
 	struct m0_fid                 spl_cob_fid;
 
 	bool                          spl_cob_is_spare_unit;
@@ -140,7 +127,7 @@ struct m0_sns_cm_iter {
 	int                              si_ldom_need_fini;
 
 	/** Layout details of a file. */
-	struct m0_sns_cm_pdclust_layout  si_pl;
+	struct m0_sns_cm_file_info       si_pl;
 
 	/**
 	 * Saved pre allocated copy packet, which needs to be configured.
diff --git a/sns/cm/st/trigger_fom.c b/sns/cm/st/trigger_fom.c
index 561ec1a..76bdb5a 100644
--- a/sns/cm/st/trigger_fom.c
+++ b/sns/cm/st/trigger_fom.c
@@ -229,10 +229,6 @@ static int trigger_fom_tick(struct m0_fom *fom)
 				scm->sc_it.si_fdata = &treq->fdata;
 				m0_trigger_file_sizes_save(treq->fsize.f_nr,
 							   treq->fsize.f_size);
-				scm->sc_it.si_pl.spl_N = treq->N;
-				scm->sc_it.si_pl.spl_K = treq->K;
-				scm->sc_it.si_pl.spl_P = treq->P;
-				scm->sc_it.si_pl.spl_unit_size = treq->unit_size;
 				scm->sc_op             = treq->op;
 				rc = m0_cm_start(cm);
 				M0_ASSERT(rc == 0);
diff --git a/sns/cm/ut/cm.c b/sns/cm/ut/cm.c
index 15c3974..3b5d9bd 100644
--- a/sns/cm/ut/cm.c
+++ b/sns/cm/ut/cm.c
@@ -123,10 +123,6 @@ static void iter_setup(uint32_t N, uint32_t K, uint32_t P, uint64_t unit_size)
 	M0_UT_ASSERT(bufs_nr != 0);
 	bufs_nr = cm_buffer_pool_provision(&scm->sc_obp, ITER_UT_BUF_NR);
 	M0_UT_ASSERT(bufs_nr != 0);
-        scm->sc_it.si_pl.spl_N = N;
-        scm->sc_it.si_pl.spl_K = K;
-        scm->sc_it.si_pl.spl_P = P;
-	scm->sc_it.si_pl.spl_unit_size = unit_size;
 	rc = m0_sns_cm_iter_init(&scm->sc_it);
 	M0_UT_ASSERT(rc == 0);
 }
-- 
1.8.3.2

