From 6580e13d013d8a0aadbf0df93f8cce14972c212c Mon Sep 17 00:00:00 2001
From: Hua Huang <hua_huang@xyratex.com>
Date: Fri, 5 Apr 2013 17:02:24 +0800
Subject: [PATCH 14/18] Introduce m0_poolmach_version_before() to compare
 version numbers. m0_ios_mds_layout_get() first tries to m0_layout_find().
 Fill file size in cm_layout_fetch(). file_size() does nothing currently. Skip
 M0_COB_ROOT_FID, M0_COB_SESSIONS_FID, M0_COB_SLASH_FID in iter_fid_next().
 Use float number to calculate time and throughput in trigger.

---
 ioservice/cob_foms.c   | 23 +++---------
 ioservice/io_device.c  |  9 +++--
 ioservice/io_foms.c    |  4 +-
 ioservice/io_service.c | 40 ++++----------------
 pool/pool.c            | 10 +++++
 pool/pool.h            |  8 ++++
 reqh/ut/reqh_service.c |  1 +
 sns/cm/cm.c            |  2 +-
 sns/cm/iter.c          | 99 +++++++++++++++++++++-----------------------------
 sns/cm/iter.h          |  2 +-
 sns/cm/st/repair_cli.c | 10 +++--
 11 files changed, 88 insertions(+), 120 deletions(-)

diff --git a/ioservice/cob_foms.c b/ioservice/cob_foms.c
index a9a74c4..a493488 100644
--- a/ioservice/cob_foms.c
+++ b/ioservice/cob_foms.c
@@ -229,18 +229,12 @@ static int cc_fom_tick(struct m0_fom *fom)
 	m0_poolmach_current_version_get(poolmach, &curr);
 	cliv = (struct m0_pool_version_numbers*)&fop->cc_common.c_version;
 
-	/*
-	m0_poolmach_version_dump(cliv);
-	m0_poolmach_version_dump(&curr);
-	*/
 	/* Check the client version and server version before any processing */
-	if (!m0_poolmach_version_equal(cliv, &curr) &&
-		(cliv->pvn_version[PVE_READ] < curr.pvn_version[PVE_READ] &&
-		 cliv->pvn_version[PVE_WRITE] < curr.pvn_version[PVE_WRITE])) {
-		/* poolmach failure vector needs to be synchronized in pool. */
-
+	if (m0_poolmach_version_before(cliv, &curr)) {
 		rc = M0_IOP_ERROR_FAILURE_VECTOR_VER_MISMATCH;
 		M0_LOG(M0_DEBUG, "VERSION MISMATCH!");
+		m0_poolmach_version_dump(cliv);
+		m0_poolmach_version_dump(&curr);
 		m0_poolmach_event_list_dump(poolmach);
 		m0_poolmach_device_state_dump(poolmach);
 		goto out;
@@ -451,17 +445,12 @@ static int cd_fom_tick(struct m0_fom *fom)
 	m0_poolmach_current_version_get(poolmach, &curr);
 	cliv = (struct m0_pool_version_numbers*)&fop->cd_common.c_version;
 
-	/*
-	m0_poolmach_version_dump(cliv);
-	m0_poolmach_version_dump(&curr);
-	*/
 	/* Check the client version and server version before any processing */
-	if (!m0_poolmach_version_equal(cliv, &curr) &&
-		(cliv->pvn_version[PVE_READ] < curr.pvn_version[PVE_READ] &&
-		 cliv->pvn_version[PVE_WRITE] < curr.pvn_version[PVE_WRITE])) {
+	if (m0_poolmach_version_before(cliv, &curr)) {
 		rc = M0_IOP_ERROR_FAILURE_VECTOR_VER_MISMATCH;
 		M0_LOG(M0_DEBUG, "VERSION MISMATCH!");
-
+		m0_poolmach_version_dump(cliv);
+		m0_poolmach_version_dump(&curr);
 		m0_poolmach_event_list_dump(poolmach);
 		m0_poolmach_device_state_dump(poolmach);
 		goto out;
diff --git a/ioservice/io_device.c b/ioservice/io_device.c
index 01ca71a..0fc467f 100644
--- a/ioservice/io_device.c
+++ b/ioservice/io_device.c
@@ -341,12 +341,13 @@ m0_ios_poolmach_version_updates_pack(struct m0_poolmach         *pm,
 	m0_poolmach_current_version_get(pm, &curr);
 	verp = (struct m0_pool_version_numbers*)version;
 	*verp = curr;
+	if (!m0_poolmach_version_before((struct m0_pool_version_numbers *)cli,
+					&curr))
+		return 0;
 
 	poolmach_events_tlist_init(&events_list);
-	rc = m0_poolmach_state_query(pm,
-				  (const struct m0_pool_version_numbers *)cli,
-				  (const struct m0_pool_version_numbers *)&curr,
-				   &events_list);
+	rc = m0_poolmach_state_query(pm, (struct m0_pool_version_numbers *)cli,
+				     &curr, &events_list);
 	if (rc != 0)
 		goto out;
 
diff --git a/ioservice/io_foms.c b/ioservice/io_foms.c
index fa36d1e..1cb11e2 100644
--- a/ioservice/io_foms.c
+++ b/ioservice/io_foms.c
@@ -1639,9 +1639,7 @@ static int m0_io_fom_cob_rw_tick(struct m0_fom *fom)
 	cliv = (struct m0_pool_version_numbers*)(&rwfop->crw_version);
 
 	/* Check the client version and server version before any processing */
-	if (!m0_poolmach_version_equal(cliv, &curr) &&
-		(cliv->pvn_version[PVE_READ] < curr.pvn_version[PVE_READ] &&
-		 cliv->pvn_version[PVE_WRITE] < curr.pvn_version[PVE_WRITE])) {
+	if (m0_poolmach_version_before(cliv, &curr)) {
 		rc = M0_FSO_AGAIN;
 		m0_fom_phase_move(fom,
 				  M0_IOP_ERROR_FAILURE_VECTOR_VER_MISMATCH,
diff --git a/ioservice/io_service.c b/ioservice/io_service.c
index ddfc93e..bb0d2a4 100644
--- a/ioservice/io_service.c
+++ b/ioservice/io_service.c
@@ -761,38 +761,6 @@ M0_INTERNAL int m0_ios_mds_getattr(struct m0_reqh *reqh,
  @param ldom the layout domain in which the layout will be created.
  @param lid  the layout id to query.
  @param l_out returned layout will be stored here.
-
- The sample code to use m0_ios_mds_getattr() and m0_ios_mds_layout_get() in
- services such as ioservice and copy machine is as following:
- @code
-        struct m0_fid      gfid = cc->fco_gfid;
-        struct m0_cob_attr attr = { {0} };
-	struct m0_layout_domain dom;
-	struct m0_layout_domain *ldom = &dom;
-	struct m0_pdclust_layout *pdl = NULL;
-	struct m0_layout *layout = NULL;
-
-	M0_LOG(M0_FATAL, "getattr");
-	rc = m0_ios_mds_getattr(fom->fo_service->rs_reqh, &gfid, &attr);
-	M0_LOG(M0_FATAL, "rc = %d lid = %lld", rc, (unsigned long long)attr.ca_lid);
-	M0_ASSERT(rc == 0);
-	M0_ASSERT(attr.ca_valid | M0_COB_LID);
-
-	M0_LOG(M0_FATAL, "getlayout new = %d", new);
-	rc = m0_ios_mds_layout_get(fom->fo_service->rs_reqh, ldom, attr.ca_lid, &layout);
-	M0_LOG(M0_FATAL, "getlayout rc = %d", rc);
-	if (rc == 0) {
-		pdl = m0_layout_to_pdl(layout);
-		M0_LOG(M0_FATAL, "pdl N=%d,K=%d,P=%d,unit_size=%llu",
-				 m0_pdclust_N(pdl),
-				 m0_pdclust_K(pdl),
-				 m0_pdclust_P(pdl),
-				 (unsigned long long)m0_pdclust_unit_size(pdl));
-
-		m0_layout_put(layout);
-	}
-
- @endcode
 */
 M0_INTERNAL int m0_ios_mds_layout_get(struct m0_reqh *reqh,
 				      struct m0_layout_domain *ldom,
@@ -804,9 +772,16 @@ M0_INTERNAL int m0_ios_mds_layout_get(struct m0_reqh *reqh,
 	struct m0_fop             *rep;
 	struct m0_fop_layout      *layout;
 	struct m0_fop_layout_rep  *layout_rep;
+	struct m0_layout          *l;
 	int                        rc;
 	M0_ENTRY();
 
+	l = m0_layout_find(ldom, lid);
+	if (l != NULL) {
+		*l_out = l;
+		return 0;
+	}
+
 	rpc_client_ctx = m0_ios_mds_rpc_ctx_get(reqh);
 	if (rpc_client_ctx == NULL)
 		return -ENODEV;
@@ -823,7 +798,6 @@ M0_INTERNAL int m0_ios_mds_layout_get(struct m0_reqh *reqh,
 	if (rc == 0) {
 		struct m0_bufvec               bv;
 		struct m0_bufvec_cursor        cur;
-		struct m0_layout              *l;
 		struct m0_layout_type         *lt;
 		M0_ASSERT(l_out != NULL);
 
diff --git a/pool/pool.c b/pool/pool.c
index ae3a530..17c9531 100644
--- a/pool/pool.c
+++ b/pool/pool.c
@@ -87,6 +87,16 @@ M0_INTERNAL bool m0_poolmach_version_equal(const struct m0_pool_version_numbers
 	return !memcmp(v1, v2, sizeof *v1);
 }
 
+M0_INTERNAL bool m0_poolmach_version_before(const struct m0_pool_version_numbers
+					    *v1,
+					    const struct m0_pool_version_numbers
+					    *v2)
+{
+	return
+		v1->pvn_version[PVE_READ]  < v2->pvn_version[PVE_READ] ||
+		v1->pvn_version[PVE_WRITE] < v2->pvn_version[PVE_WRITE];
+}
+
 M0_INTERNAL int m0_poolmach_init(struct m0_poolmach *pm,
 				 struct m0_dtm *dtm,
 				 uint32_t nr_nodes,
diff --git a/pool/pool.h b/pool/pool.h
index 3d8c06b..eb5fa2b 100644
--- a/pool/pool.h
+++ b/pool/pool.h
@@ -313,6 +313,14 @@ M0_INTERNAL bool m0_poolmach_version_equal(const struct m0_pool_version_numbers
 					   *v1,
 					   const struct m0_pool_version_numbers
 					   *v2);
+/**
+ * Pool Machine version numbers are incremented upon event.
+ * v1 before v2 means v2's version number is greater than v1's.
+ */
+M0_INTERNAL bool m0_poolmach_version_before(const struct m0_pool_version_numbers
+					    *v1,
+					    const struct m0_pool_version_numbers
+					    *v2);
 
 M0_INTERNAL int m0_poolmach_init(struct m0_poolmach *pm,
 				 struct m0_dtm *dtm,
diff --git a/reqh/ut/reqh_service.c b/reqh/ut/reqh_service.c
index 7c39954..2a60b46 100644
--- a/reqh/ut/reqh_service.c
+++ b/reqh/ut/reqh_service.c
@@ -141,6 +141,7 @@ static void test_service(void)
 	struct m0_reqh_service       *reqh_svc;
 	struct m0_fop                *fop;
 	static struct m0_dbenv        dbenv;
+
 	rc = m0_dbenv_init(&dbenv, "something", 0);
 	M0_UT_ASSERT(rc == 0);
 
diff --git a/sns/cm/cm.c b/sns/cm/cm.c
index 407fdc3..e589415 100644
--- a/sns/cm/cm.c
+++ b/sns/cm/cm.c
@@ -573,7 +573,7 @@ M0_INTERNAL int m0_sns_cm_buf_attach(struct m0_sns_cm *scm, struct m0_cm_cp *cp)
 
 M0_INTERNAL uint64_t m0_sns_cm_data_seg_nr(struct m0_sns_cm *scm)
 {
-	struct m0_sns_cm_file_context *sfc = &scm->sc_it.si_pl;
+	struct m0_sns_cm_file_context *sfc = &scm->sc_it.si_fc;
 
 	M0_PRE(scm != NULL);
 
diff --git a/sns/cm/iter.c b/sns/cm/iter.c
index 95eeb4e..5e37f03 100644
--- a/sns/cm/iter.c
+++ b/sns/cm/iter.c
@@ -145,7 +145,7 @@ M0_INTERNAL struct m0_sns_cm *it2sns(struct m0_sns_cm_iter *it)
 
 M0_INTERNAL uint64_t m0_sns_cm_iter_failures_nr(const struct m0_sns_cm_iter *it)
 {
-	return it->si_pl.sfc_group_nr_fail_units;
+	return it->si_fc.sfc_group_nr_fail_units;
 }
 
 static bool is_cob_failed(struct m0_sns_cm_iter *it,
@@ -183,7 +183,7 @@ static uint64_t __unit_start(struct m0_sns_cm_iter *it)
 		return 0;
 	case SNS_REBALANCE:
 		/* Start from the first spare unit of the group. */
-		return __spare_unit_nr(&it->si_pl, it->si_pl.sfc_sa.sa_group,
+		return __spare_unit_nr(&it->si_fc, it->si_fc.sfc_sa.sa_group,
 				       0);
 	default:
 		 M0_IMPOSSIBLE("op");
@@ -199,10 +199,10 @@ static uint64_t __unit_end(struct m0_sns_cm_iter *it)
 	switch (scm->sc_op) {
 	case SNS_REPAIR:
 		/* End at the last data/parity unit of the group. */
-		return it->si_pl.sfc_dpupg;
+		return it->si_fc.sfc_dpupg;
 	case SNS_REBALANCE:
 		/* End at the last spare unit of the group. */
-		return it->si_pl.sfc_upg;
+		return it->si_fc.sfc_upg;
 	default:
 		M0_IMPOSSIBLE("op");
 	}
@@ -247,46 +247,26 @@ static bool iter_invariant(const struct m0_sns_cm_iter *it)
 	enum cm_data_iter_phase phase = iter_phase(it);
 
 	return it != NULL && m0_sns_cm_iter_bob_check(it) &&
-	       it->si_cp != NULL && iter_layout_invariant(phase, &it->si_pl);
+	       it->si_cp != NULL && iter_layout_invariant(phase, &it->si_fc);
 }
 
 /**
  * Fetches total size of a file corresponding to the given GOB fid
- * (m0_sns_cm::si_pl::sfc_gob_fid). This is used to calculate
+ * (m0_sns_cm::si_fc::sfc_gob_fid). This is used to calculate
  * total number of parity groups per GOB.
  * @note Fetching file attributes may block.
  * @retval 0 on success, IT_WAIT for blocking operation
  */
 static ssize_t file_size(struct m0_sns_cm_iter *it)
 {
-	struct m0_fid      gfid = it->si_pl.sfc_gob_fid;
-	struct m0_cob_attr attr = { {0} };
-	int                rc;
-
-	M0_PRE(it != NULL);
-
-	M0_LOG(M0_DEBUG, "getattr for %llu:%llu",
-			 (unsigned long long)gfid.f_container,
-			 (unsigned long long)gfid.f_key);
-	rc = m0_ios_mds_getattr(it->si_cp->sc_base.c_fom.fo_service->rs_reqh,
-				&gfid, &attr);
-	if (rc == 0) {
-		M0_ASSERT(attr.ca_valid | M0_COB_LID);
-		M0_ASSERT(attr.ca_valid | M0_COB_SIZE);
-		it->si_pl.sfc_fsize = attr.ca_size;
-		M0_LOG(M0_DEBUG, "file size of %llu:%llu = %llu",
-				 (unsigned long long)gfid.f_container,
-				 (unsigned long long)gfid.f_key,
-				 (unsigned long long)attr.ca_size);
-	} else
-		M0_LOG(M0_ERROR, "getattr rc=%d size = %llu",
-				 rc, (unsigned long long)attr.ca_size);
-
+	/* File size is already filled in cm_layout_fetch().
+	 * If file size may change during repair, it needs to be updated.
+	 */
 	return 0;
 }
 
 /**
- * Fetches file layout for it->si_pl.sfc_gob_fid.
+ * Fetches file layout for it->si_fc.sfc_gob_fid.
  * @note This may block.
  * @retval 0 on success, IT_WAIT for blocking operation
  */
@@ -300,10 +280,10 @@ static int cm_layout_fetch(struct m0_sns_cm_iter *it)
 	int                       rc;
 
 	M0_PRE(it != NULL);
-	gfid = it->si_pl.sfc_gob_fid;
+	gfid = it->si_fc.sfc_gob_fid;
 	ldom = &it->si_cp->sc_base.c_fom.fo_service->rs_reqh->rh_ldom;
 
-	M0_LOG(M0_DEBUG, "getattr for %llu:%llu",
+	M0_LOG(M0_DEBUG, "get size and layout for %llu:%llu",
 			 (unsigned long long)gfid.f_container,
 			 (unsigned long long)gfid.f_key);
 	rc = m0_ios_mds_getattr(it->si_cp->sc_base.c_fom.fo_service->rs_reqh,
@@ -312,8 +292,13 @@ static int cm_layout_fetch(struct m0_sns_cm_iter *it)
 		struct m0_fom  *fom = &it->si_cp->sc_base.c_fom;
 		struct m0_reqh *reqh = fom->fo_service->rs_reqh;
 		M0_ASSERT(attr.ca_valid | M0_COB_LID);
+		M0_ASSERT(attr.ca_valid | M0_COB_SIZE);
 
-		M0_LOG(M0_DEBUG, "getlayout for %llu",
+		it->si_fc.sfc_fsize = attr.ca_size;
+		M0_LOG(M0_DEBUG, "FID = %llu:%llu, size = %llu, lid = %llu",
+				 (unsigned long long)gfid.f_container,
+				 (unsigned long long)gfid.f_key,
+				 (unsigned long long)attr.ca_size,
 				 (unsigned long long)attr.ca_lid);
 		rc = m0_ios_mds_layout_get(reqh, ldom, attr.ca_lid, &layout);
 		if (rc == 0) {
@@ -326,13 +311,13 @@ static int cm_layout_fetch(struct m0_sns_cm_iter *it)
 					 (unsigned long long)
 					 m0_pdclust_unit_size(pdl));
 
-			it->si_pl.sfc_pdlayout = pdl;
+			it->si_fc.sfc_pdlayout = pdl;
 			/*
 			 * We need only the number of parity units equivalent
 			 * to the number of failures.
 			 */
-			it->si_pl.sfc_dpupg = m0_pdclust_N(pdl) + m0_pdclust_K(pdl);
-			it->si_pl.sfc_upg = m0_pdclust_N(pdl) + 2 * m0_pdclust_K(pdl);
+			it->si_fc.sfc_dpupg = m0_pdclust_N(pdl) + m0_pdclust_K(pdl);
+			it->si_fc.sfc_upg = m0_pdclust_N(pdl) + 2 * m0_pdclust_K(pdl);
 		} else
 			M0_LOG(M0_DEBUG, "getlayout for %llu failed rc = %d",
 					 (unsigned long long)attr.ca_lid, rc);
@@ -402,7 +387,7 @@ M0_INTERNAL uint64_t nr_local_units(struct m0_sns_cm *scm,
 				    const struct m0_fid *fid, uint64_t group)
 {
 	struct m0_sns_cm_iter           *it  = &scm->sc_it;
-	struct m0_sns_cm_file_context   *sfc = &it->si_pl;
+	struct m0_sns_cm_file_context   *sfc = &it->si_fc;
 	struct m0_pdclust_src_addr       sa;
 	struct m0_pdclust_tgt_addr       ta;
 	struct m0_fid                    cobfid;
@@ -478,7 +463,7 @@ static uint64_t __target_unit_nr(const struct m0_sns_cm_file_context *sfc,
 M0_INTERNAL void m0_sns_cm_iter_tgt_unit_to_cob(struct m0_sns_cm_ag *sag)
 {
 	struct m0_sns_cm                *scm = cm2sns(sag->sag_base.cag_cm);
-	struct m0_sns_cm_file_context   *sfc = &scm->sc_it.si_pl;
+	struct m0_sns_cm_file_context   *sfc = &scm->sc_it.si_fc;
 	struct m0_pdclust_src_addr       sa;
 	struct m0_pdclust_tgt_addr       ta;
 	struct m0_fid                    gobfid;
@@ -538,7 +523,7 @@ static int layout_instance_build(struct m0_sns_cm_iter *it)
 	int                              rc = -ENODATA;
 	M0_PRE(it != NULL);
 
-	sfc = &it->si_pl;
+	sfc = &it->si_fc;
 	fid = &sfc->sfc_gob_fid;
 	pl  = sfc->sfc_pdlayout;
 	M0_ASSERT(pl != NULL);
@@ -589,25 +574,25 @@ static int iter_fid_next(struct m0_sns_cm_iter *it)
 	int           rc;
 
 	/* Get current GOB fid saved in the iterator. */
-	rc = __fid_next(it, &fid_next);
-	if (rc == 0 && m0_fid_eq(&fid_next, &M0_COB_ROOT_FID)) {
-		/* we reached the root fid. This is the end. */
-		rc = -ENOENT;
-	}
+	do {
+		rc = __fid_next(it, &fid_next);
+	} while (rc == 0 && (m0_fid_eq(&fid_next, &M0_COB_ROOT_FID)     ||
+			     m0_fid_eq(&fid_next, &M0_COB_SESSIONS_FID) ||
+			     m0_fid_eq(&fid_next, &M0_COB_SLASH_FID)));
 
 	if (rc == -ENOENT)
 		return -ENODATA;
 	if (rc == 0) {
 		/* Save next GOB fid in the iterator. */
-		it->si_pl.sfc_gob_fid = fid_next;
+		it->si_fc.sfc_gob_fid = fid_next;
 		/* fini old layout instance and put old layout */
-		if (it->si_pl.sfc_pi != NULL) {
-			m0_layout_instance_fini(&it->si_pl.sfc_pi->pi_base);
-			it->si_pl.sfc_pi = NULL;
+		if (it->si_fc.sfc_pi != NULL) {
+			m0_layout_instance_fini(&it->si_fc.sfc_pi->pi_base);
+			it->si_fc.sfc_pi = NULL;
 		}
-		if (it->si_pl.sfc_pdlayout != NULL) {
-			m0_layout_put(m0_pdl_to_layout(it->si_pl.sfc_pdlayout));
-			it->si_pl.sfc_pdlayout = NULL;
+		if (it->si_fc.sfc_pdlayout != NULL) {
+			m0_layout_put(m0_pdl_to_layout(it->si_fc.sfc_pdlayout));
+			it->si_fc.sfc_pdlayout = NULL;
 		}
 
 		rc = cm_layout_fetch(it);
@@ -655,7 +640,7 @@ static int __group_next(struct m0_sns_cm_iter *it)
 	uint64_t                         unit;
 	int                              i;
 
-	sfc = &it->si_pl;
+	sfc = &it->si_fc;
 	sfc->sfc_groups_nr = groups_nr = nr_groups(sfc);
 	sa = &sfc->sfc_sa;
 	for (group = sa->sa_group; group < groups_nr; ++group) {
@@ -727,7 +712,7 @@ static void agid_setup(const struct m0_fid *gob_fid, uint64_t group,
 static int iter_ag_setup(struct m0_sns_cm_iter *it)
 {
 	struct m0_sns_cm                *scm = it2sns(it);
-	struct m0_sns_cm_file_context   *sfc = &it->si_pl;
+	struct m0_sns_cm_file_context   *sfc = &it->si_fc;
 	struct m0_cm_aggr_group         *ag;
 	struct m0_sns_cm_ag             *sag;
 	struct m0_cm_ag_id               agid;
@@ -757,7 +742,7 @@ static int iter_cp_setup(struct m0_sns_cm_iter *it)
 	enum m0_sns_cm_op                op = scm->sc_op;
 	int                              rc = 0;
 
-	sfc = &it->si_pl;
+	sfc = &it->si_fc;
 	agid_setup(&sfc->sfc_gob_fid, sfc->sfc_sa.sa_group, &agid);
 	ag = m0_cm_aggr_group_locate(&scm->sc_base, &agid);
 	if (ag == NULL) {
@@ -809,14 +794,14 @@ static int iter_cob_next(struct m0_sns_cm_iter *it)
 	uint32_t                         upg;
 	int                              rc = 0;
 
-	sfc = &it->si_pl;
+	sfc = &it->si_fc;
 	upg = sfc->sfc_upg;
 	sa = &sfc->sfc_sa;
 
 	cob_fid = &sfc->sfc_cob_fid;
 	do {
 		if (sa->sa_unit >= upg) {
-			++it->si_pl.sfc_sa.sa_group;
+			++it->si_fc.sfc_sa.sa_group;
 			iter_phase_set(it, ITPH_GROUP_NEXT);
 			return 0;
 		}
@@ -957,7 +942,7 @@ static void layout_fini(struct m0_sns_cm_iter *it)
 
 	M0_PRE(iter_invariant(it));
 
-	sfc = &it->si_pl;
+	sfc = &it->si_fc;
 	if (sfc->sfc_pi != NULL) {
 		m0_layout_instance_fini(&sfc->sfc_pi->pi_base);
 		sfc->sfc_pi = NULL;
diff --git a/sns/cm/iter.h b/sns/cm/iter.h
index 58ebc25..bb9a240 100644
--- a/sns/cm/iter.h
+++ b/sns/cm/iter.h
@@ -114,7 +114,7 @@ struct m0_sns_cm_iter {
 	struct m0_cob_domain            *si_cob_dom;
 
 	/** Layout details of a file. */
-	struct m0_sns_cm_file_context    si_pl;
+	struct m0_sns_cm_file_context    si_fc;
 
 	/**
 	 * Saved pre allocated copy packet, which needs to be configured.
diff --git a/sns/cm/st/repair_cli.c b/sns/cm/st/repair_cli.c
index 1d3b61d..90581d8 100644
--- a/sns/cm/st/repair_cli.c
+++ b/sns/cm/st/repair_cli.c
@@ -103,7 +103,8 @@ int main(int argc, char *argv[])
 	uint32_t            unit_size;
 	uint64_t            fdata;
 	uint64_t            total_size = 0;
-	uint64_t            throughput;
+	double              total_time;
+	double              throughput;
 	uint64_t            fsize[MAX_FILES_NR];
 	uint64_t            N = 0;
 	uint64_t            K = 0;
@@ -171,9 +172,10 @@ int main(int argc, char *argv[])
 	printf("Time: %lu.%2.2lu sec,", (unsigned long)m0_time_seconds(delta),
 	       (unsigned long)m0_time_nanoseconds(delta) * 100 /
 	       M0_TIME_ONE_BILLION);
-	throughput = total_size / (unsigned long)m0_time_seconds(delta);
-	printf(" %lu.%2.2lu MB/s\n", throughput / (1024 *1024),
-	       (throughput % (1024 * 1024)) / (1024 * 100));
+	total_time = (double)m0_time_seconds(delta) +
+		     (double)m0_time_nanoseconds(delta) / M0_TIME_ONE_BILLION;
+	throughput = (double)total_size / total_time;
+	printf(" %2.2f MB/s\n", throughput / (1024 *1024));
 	m0_fop_put(fop);
 	client_fini();
 	m0_sns_repair_trigger_fop_fini();
-- 
1.8.3.2

