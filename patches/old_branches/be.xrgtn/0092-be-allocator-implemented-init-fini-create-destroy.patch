From ac653c962d44934d081098a7c4b12ad4ead77430 Mon Sep 17 00:00:00 2001
From: Maxim Medved <Max_Medved@xyratex.com>
Date: Tue, 4 Jun 2013 02:38:17 +0300
Subject: [PATCH 092/228] be allocator: implemented init/fini/create/destroy

be UT: single UT suite
be tx: fixed compilation error
---
 be/alloc.c         | 177 +++++++++++++++++++++++++++++++++++++++++++++++++++--
 be/alloc.h         |  21 +++++--
 be/seg.c           |   9 ++-
 be/seg.h           |   8 ++-
 be/tx.h            |  97 +++++++++++++++--------------
 be/ut/Makefile.sub |   2 +-
 be/ut/alloc.c      |  39 ++++++++++++
 be/ut/main.c       |  52 ++++++++++++++++
 be/ut/seg.c        |  16 +----
 mero/magic.h       |  14 +++++
 utils/ut_main.c    |   4 +-
 11 files changed, 364 insertions(+), 75 deletions(-)
 create mode 100644 be/ut/alloc.c
 create mode 100644 be/ut/main.c

diff --git a/be/alloc.c b/be/alloc.c
index 76c9383..36973c2 100644
--- a/be/alloc.c
+++ b/be/alloc.c
@@ -20,30 +20,192 @@
 
 #include "be/seg.h"
 
+#include "lib/types.h"  /* m0_bcount_t */
+#include "lib/memory.h"	/* m0_addr_is_aligned */
+#include "lib/errno.h"	/* ENOSPC */
+#include "mero/magic.h"	/* M0_BE_ALLOC_MAGIC0 */
+
+#include "be/list.h"	/* m0_be_list */
+
 /**
  * @addtogroup be
  *
  * @{
  */
 
+enum {
+	/** alignment for m0_be_allocator_header inside segment */
+	BE_ALLOC_HEADER_SHIFT = 3,
+	/** alignment for be_alloc_chunk */
+	BE_ALLOC_CHUNK_SHIFT  = 3,
+};
+
+struct be_alloc_chunk {
+	/**
+	 * M0_BE_ALLOC_MAGIC0
+	 * Used to find invalid memory access after allocated chunk.
+	 */
+	uint64_t	bac_magic0;
+	/** for m0_be_allocator_header.ba_chunks list */
+	struct m0_tlink bac_linkage;
+	/** magic for bac_linkage */
+	uint64_t	bac_magic;
+	/** for m0_be_allocator_header.ba_free list */
+	struct m0_tlink bac_linkage_free;
+	/** magic for bac_linkage_free */
+	uint64_t	bac_magic_free;
+	/** size of chunk */
+	m0_bcount_t	bac_size;
+	/** is chunk free? */
+	bool		bac_free;
+	/**
+	 * M0_BE_ALLOC_MAGIC1
+	 * Used to find invalid memory access before allocated chunk.
+	 */
+	/** M0_BE_ALLOC_MAGIC1 */
+	uint64_t	bac_magic1;
+	/** m0_be_alloc() will return address of bac_mem for allocated chunk */
+	char		bac_mem[0];
+};
+
+M0_TL_DESCR_DEFINE(chunks_all, "list of all chunks in m0_be_allocator",
+		   static, struct be_alloc_chunk, bac_linkage, bac_magic,
+		   M0_BE_ALLOC_ALL_LINK_MAGIC, M0_BE_ALLOC_ALL_MAGIC);
+M0_TL_DEFINE(chunks_all, static, struct be_alloc_chunk);
+
+M0_TL_DESCR_DEFINE(chunks_free, "list of free chunks in m0_be_allocator",
+		   static, struct be_alloc_chunk, bac_linkage_free, bac_magic_free,
+		   M0_BE_ALLOC_FREE_LINK_MAGIC, M0_BE_ALLOC_FREE_MAGIC);
+M0_TL_DEFINE(chunks_free, static, struct be_alloc_chunk);
+
+struct m0_be_allocator_header {
+	struct m0_be_list	      bah_chunks;	/**< all chunks */
+	struct m0_be_list	      bah_free;		/**< free chunks */
+	struct m0_be_allocator_stats  bah_stats;
+	struct be_alloc_chunk	      bah_main;		/**< main chunk */
+};
+
+static bool be_alloc_chunk_invariant(const struct be_alloc_chunk *c)
+{
+	return c->bac_magic0 == M0_BE_ALLOC_MAGIC0 &&
+	       c->bac_magic1 == M0_BE_ALLOC_MAGIC1;
+}
+
+static void be_alloc_chunk_init(struct be_alloc_chunk *c,
+				m0_bcount_t size, bool free)
+{
+	*c = (struct be_alloc_chunk) {
+		.bac_magic0 = M0_BE_ALLOC_MAGIC0,
+		.bac_size   = size,
+		.bac_free   = free,
+		.bac_magic1 = M0_BE_ALLOC_MAGIC1,
+	};
+	chunks_all_tlink_init(c);
+	chunks_free_tlink_init(c);
+	M0_POST(be_alloc_chunk_invariant(c));
+}
+
+static void be_alloc_chunk_fini(struct be_alloc_chunk *c)
+{
+	M0_PRE(be_alloc_chunk_invariant(c));
+	chunks_free_tlink_fini(c);
+	chunks_all_tlink_fini(c);
+}
+
 M0_INTERNAL int
 m0_be_allocator_init(struct m0_be_allocator *a, struct m0_be_seg *seg)
 {
-	return -1; /*XXX*/
+	M0_PRE(m0_be_seg__invariant(seg));
+
+	m0_mutex_init(&a->ba_lock);
+
+	a->ba_seg = seg;
+	a->ba_h = (struct m0_be_allocator_header *)
+		  ((char *) seg->bs_addr + seg->bs_reserved);
+	M0_ASSERT(m0_addr_is_aligned(a->ba_h, BE_ALLOC_HEADER_SHIFT));
+
+	return 0;
 }
 
 M0_INTERNAL void m0_be_allocator_fini(struct m0_be_allocator *a)
 {
+	m0_mutex_fini(&a->ba_lock);
+}
+
+M0_INTERNAL bool m0_be_allocator__invariant(struct m0_be_allocator *a)
+{
+	return true;
 }
 
 M0_INTERNAL int m0_be_allocator_create(struct m0_be_allocator *a)
 {
-	return -1; /*XXX*/
+	struct m0_be_allocator_header *h;
+	struct be_alloc_chunk	      *c;
+	m0_bcount_t		       overhead;
+	m0_bcount_t		       free_space;
+
+	M0_PRE(m0_be_allocator__invariant(a));
+
+	h = a->ba_h;
+	/** @todo GET_PTR h */
+	c = &h->bah_main;
+	overhead   = a->ba_seg->bs_reserved +
+		     sizeof(struct m0_be_allocator_header);
+	free_space = a->ba_seg->bs_size - overhead;
+
+	/* check if segment is large enough to allocate at least 1 byte */
+	if (a->ba_seg->bs_size <= overhead)
+		return -ENOSPC;
+
+	m0_mutex_lock(&a->ba_lock);
+
+	m0_be_list_init(&h->bah_chunks, a->ba_seg);
+	chunks_all_tlist_init(&h->bah_chunks.bl_list);
+	m0_be_list_init(&h->bah_free, a->ba_seg);
+	chunks_free_tlist_init(&h->bah_free.bl_list);
+
+	h->bah_stats = (struct m0_be_allocator_stats) {
+		.bas_free_space = free_space,
+	};
+
+	/* init main chunk */
+	c = &h->bah_main;
+	be_alloc_chunk_init(c, free_space, true);
+	chunks_all_tlist_add_tail(&h->bah_chunks.bl_list, c);
+	chunks_free_tlist_add_tail(&h->bah_free.bl_list, c);
+
+	m0_mutex_unlock(&a->ba_lock);
+
+	/** @todo PUT_PTR h */
+
+	M0_POST(m0_be_allocator__invariant(a));
+	return 0;
 }
 
 M0_INTERNAL int m0_be_allocator_destroy(struct m0_be_allocator *a)
 {
-	return -1; /*XXX*/
+	struct m0_be_allocator_header *h;
+	struct be_alloc_chunk	      *c;
+
+	M0_PRE(m0_be_allocator__invariant(a));
+
+	h = a->ba_h;
+	c = &h->bah_main;
+	/** @todo GET_PTR h */
+	m0_mutex_lock(&a->ba_lock);
+
+	chunks_free_tlist_del(c);
+	chunks_all_tlist_del(c);
+	be_alloc_chunk_fini(c);
+
+	chunks_free_tlist_fini(&h->bah_free.bl_list);
+	m0_be_list_fini(&h->bah_free);
+	chunks_all_tlist_fini(&h->bah_chunks.bl_list);
+	m0_be_list_fini(&h->bah_chunks);
+
+	m0_mutex_unlock(&a->ba_lock);
+	/** @todo PUT_PTR h */
+	return 0;
 }
 
 M0_INTERNAL void m0_be_allocator_credit(const struct m0_be_allocator *a,
@@ -65,9 +227,16 @@ m0_be_free(struct m0_be_allocator *a, struct m0_be_tx *tx, void *ptr)
 {
 }
 
-M0_INTERNAL void m0_be_alloc_stats(const struct m0_be_allocator *a,
+M0_INTERNAL void m0_be_alloc_stats(struct m0_be_allocator *a,
 				   struct m0_be_allocator_stats *out)
 {
+	M0_PRE(m0_be_allocator__invariant(a));
+
+	/** @todo GET_PTR a->ba_h */
+	m0_mutex_lock(&a->ba_lock);
+	*out = a->ba_h->bah_stats;
+	m0_mutex_unlock(&a->ba_lock);
+	/** @todo PUT_PTR a->ba_h */
 }
 
 /** @} end of be group */
diff --git a/be/alloc.h b/be/alloc.h
index fcb67d0..f155bd3 100644
--- a/be/alloc.h
+++ b/be/alloc.h
@@ -23,6 +23,9 @@
 #define __MERO_BE_ALLOC_H__
 
 #include "lib/types.h"  /* m0_bcount_t */
+#include "lib/mutex.h"	/* m0_mutex */
+
+#include "be/list.h"	/* m0_be_list */
 
 struct m0_be_seg;
 struct m0_be_tx;
@@ -34,14 +37,24 @@ struct m0_be_tx_credit;
  * @{
  */
 
+struct m0_be_allocator_stats {
+	m0_bcount_t bas_free_space;
+};
+
+struct m0_be_allocator_header;
+
 struct m0_be_allocator {
-	struct m0_be_seg *ba_seg;
+	struct m0_be_seg	      *ba_seg;
+	struct m0_mutex		       ba_lock;
+	/** Internal allocator data. It is stored inside the segment. */
+	struct m0_be_allocator_header *ba_h;
 };
 
 M0_INTERNAL int m0_be_allocator_init(struct m0_be_allocator *a,
 				     struct m0_be_seg *seg);
 
 M0_INTERNAL void m0_be_allocator_fini(struct m0_be_allocator *a);
+M0_INTERNAL bool m0_be_allocator__invariant(struct m0_be_allocator *a);
 
 M0_INTERNAL int m0_be_allocator_create(struct m0_be_allocator *a);
 M0_INTERNAL int m0_be_allocator_destroy(struct m0_be_allocator *a);
@@ -63,11 +76,7 @@ M0_INTERNAL void *m0_be_alloc(struct m0_be_allocator *a, struct m0_be_tx *tx,
 M0_INTERNAL void m0_be_free(struct m0_be_allocator *a,
 			    struct m0_be_tx *tx, void *ptr);
 
-struct m0_be_allocator_stats {
-	m0_bcount_t bas_free_space;
-};
-
-M0_INTERNAL void m0_be_alloc_stats(const struct m0_be_allocator *a,
+M0_INTERNAL void m0_be_alloc_stats(struct m0_be_allocator *a,
 				   struct m0_be_allocator_stats *out);
 
 /** @} end of be group */
diff --git a/be/seg.c b/be/seg.c
index b76f485..2738964 100644
--- a/be/seg.c
+++ b/be/seg.c
@@ -160,6 +160,11 @@ M0_INTERNAL void m0_be_seg_fini(struct m0_be_seg *seg)
 	M0_PRE(M0_IN(seg->bs_state, (M0_BSS_INIT, M0_BSS_CLOSED)));
 }
 
+M0_INTERNAL bool m0_be_seg__invariant(const struct m0_be_seg *seg)
+{
+	return seg->bs_reserved <= seg->bs_size;
+}
+
 bool m0_be__reg_invariant(const struct m0_be_reg *reg)
 {
 	return reg != NULL && reg->br_seg != NULL && reg->br_size > 0 &&
@@ -254,8 +259,10 @@ M0_INTERNAL int m0_be_seg_open(struct m0_be_seg *seg)
 	/* Read whole segment from storage. */
 	rc = stob_io_single_read(seg_addr0, seg_size, seg->bs_stob,
 				 0, st_block_shift);
-	if (rc == 0)
+	if (rc == 0) {
 		seg->bs_state = M0_BSS_OPENED;
+		seg->bs_reserved = sizeof *hdrbuf;
+	}
 	return rc;
 }
 
diff --git a/be/seg.h b/be/seg.h
index e32315e..8fa00ba 100644
--- a/be/seg.h
+++ b/be/seg.h
@@ -23,7 +23,7 @@
 #define __MERO_BE_SEG_H__
 
 #include "be/alloc.h"   /* m0_be_allocator */
-#include "stob/stob.h"  /* m0_stob, m0_stob_io */
+#include "stob/stob.h"  /* m0_stob */
 
 struct m0_be;
 struct m0_be_op;
@@ -51,6 +51,12 @@ struct m0_be_seg {
 	uint64_t               bs_id; /* see also m0_be::b_next_segid */
 	struct m0_stob        *bs_stob;
 	m0_bcount_t            bs_size;
+	/**
+	 * Size of space at the start of segment used by segment implementation.
+	 * Memory allocator should not use first bs_reserved bytes of segment
+	 * in any way.
+	 */
+	m0_bcount_t	       bs_reserved;
 	void                  *bs_addr;
 	struct m0_be_allocator bs_allocator;
 	struct m0_be          *bs_be;
diff --git a/be/tx.h b/be/tx.h
index 9777170..087b8eb 100644
--- a/be/tx.h
+++ b/be/tx.h
@@ -28,6 +28,9 @@
 #include "lib/types.h"
 #include "sm/sm.h"
 
+/** @todo XXX TODO added by max as a temporary fix of compilation error */
+typedef uint64_t m0_bindex_lsn;
+
 struct m0_stob;
 struct m0_be;
 
@@ -323,6 +326,53 @@ struct m0_be_log {
 };
 
 /**
+ * Credit represents resources that a transaction could consume:
+ *
+ *     - for each region captured by an active transaction, contents of captured
+ *       region must be stored somewhere (to be written to the log later). That
+ *       requires memory, which must be pre-allocated before transaction
+ *       captures anything to avoid dead-locks;
+ *
+ *     - similarly, for each captured region, a fixed size region descriptor
+ *       (m0_be_reg_d) should be stored. The memory for the descriptor must be
+ *       pre-allocated;
+ *
+ *     - finally, before transaction captures anything, transaction engine must
+ *       assure that there is enough free space in the log to write
+ *       transaction's updates. The space required is proportional to total
+ *       number of regions captured by the transaction and to total size of
+ *       these regions.
+ *
+ * Hence, the user should inform the engine about amount and size of regions
+ * that the transaction would modify. This is achieved by calling
+ * m0_be_tx_prep() (possibly multiple times), while the transaction is in
+ * PREPARE state. The calls to m0_be_tx_prep() must be conservative: it is fine
+ * to prepare for more updates than the transaction will actually make (the
+ * latter quantity is usually impossible to know beforehand anyway), but the
+ * transaction must never capture more than it prepared.
+ */
+struct m0_be_tx_credit {
+	/**
+	 * The number of regions needed for operation representation in the
+	 * transaction.
+	 */
+	m0_bcount_t tc_reg_nr;
+	/** Total size of memory needed for the same. */
+	m0_bcount_t tc_reg_size;
+};
+
+M0_INTERNAL void m0_be_tx_credit_init(struct m0_be_tx_credit *credit);
+
+/** c0 += c1 */
+M0_INTERNAL void m0_be_tx_credit_add(struct m0_be_tx_credit *c0,
+				     const struct m0_be_tx_credit *c1);
+
+/** c *= k */
+M0_INTERNAL void m0_be_tx_credit_mul(struct m0_be_tx_credit *c, m0_bcount_t k);
+
+typedef void (*m0_be_tx_cb_t)(const struct m0_be_tx *tx);
+
+/**
  * Transaction group is a collection of transactions, consecutive in closing
  * order, that are written to the log and recovered together.
  *
@@ -401,53 +451,6 @@ M0_INTERNAL void m0_be_tx_engine_init(struct m0_be_tx_engine *engine);
 M0_INTERNAL void m0_be_tx_engine_fini(struct m0_be_tx_engine *engine);
 
 /**
- * Credit represents resources that a transaction could consume:
- *
- *     - for each region captured by an active transaction, contents of captured
- *       region must be stored somewhere (to be written to the log later). That
- *       requires memory, which must be pre-allocated before transaction
- *       captures anything to avoid dead-locks;
- *
- *     - similarly, for each captured region, a fixed size region descriptor
- *       (m0_be_reg_d) should be stored. The memory for the descriptor must be
- *       pre-allocated;
- *
- *     - finally, before transaction captures anything, transaction engine must
- *       assure that there is enough free space in the log to write
- *       transaction's updates. The space required is proportional to total
- *       number of regions captured by the transaction and to total size of
- *       these regions.
- *
- * Hence, the user should inform the engine about amount and size of regions
- * that the transaction would modify. This is achieved by calling
- * m0_be_tx_prep() (possibly multiple times), while the transaction is in
- * PREPARE state. The calls to m0_be_tx_prep() must be conservative: it is fine
- * to prepare for more updates than the transaction will actually make (the
- * latter quantity is usually impossible to know beforehand anyway), but the
- * transaction must never capture more than it prepared.
- */
-struct m0_be_tx_credit {
-	/**
-	 * The number of regions needed for operation representation in the
-	 * transaction.
-	 */
-	m0_bcount_t tc_reg_nr;
-	/** Total size of memory needed for the same. */
-	m0_bcount_t tc_reg_size;
-};
-
-M0_INTERNAL void m0_be_tx_credit_init(struct m0_be_tx_credit *credit);
-
-/** c0 += c1 */
-M0_INTERNAL void m0_be_tx_credit_add(struct m0_be_tx_credit *c0,
-				     const struct m0_be_tx_credit *c1);
-
-/** c *= k */
-M0_INTERNAL void m0_be_tx_credit_mul(struct m0_be_tx_credit *c, m0_bcount_t k);
-
-typedef void (*m0_be_tx_cb_t)(const struct m0_be_tx *tx);
-
-/**
  * Transaction.
  */
 struct m0_be_tx {
diff --git a/be/ut/Makefile.sub b/be/ut/Makefile.sub
index accbf57..555969a 100644
--- a/be/ut/Makefile.sub
+++ b/be/ut/Makefile.sub
@@ -1 +1 @@
-ut_libmero_ut_la_SOURCES += be/ut/list.c be/ut/seg.c
+ut_libmero_ut_la_SOURCES += be/ut/alloc.c be/ut/list.c be/ut/main.c be/ut/seg.c
diff --git a/be/ut/alloc.c b/be/ut/alloc.c
new file mode 100644
index 0000000..1de5260
--- /dev/null
+++ b/be/ut/alloc.c
@@ -0,0 +1,39 @@
+/* -*- C -*- */
+/*
+ * COPYRIGHT 2013 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: Maxim Medved <Max_Medved@xyratex.com>
+ * Original creation date: 3-Jun-2013
+ */
+
+#include "ut/ut.h"
+#include "be/alloc.h"
+
+M0_INTERNAL void m0_be_ut_alloc_init_fini(void)
+{
+}
+
+/*
+ *  Local variables:
+ *  c-indentation-style: "K&R"
+ *  c-basic-offset: 8
+ *  tab-width: 8
+ *  fill-column: 80
+ *  scroll-step: 1
+ *  End:
+ */
+/*
+ * vim: tabstop=8 shiftwidth=8 noexpandtab textwidth=80 nowrap
+ */
diff --git a/be/ut/main.c b/be/ut/main.c
new file mode 100644
index 0000000..ba43a0a
--- /dev/null
+++ b/be/ut/main.c
@@ -0,0 +1,52 @@
+/* -*- C -*- */
+/*
+ * COPYRIGHT 2013 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: Maxim Medved <Max_Medved@xyratex.com>
+ * Original creation date: 3-Jun-2013
+ */
+
+#include "ut/ut.h"
+
+extern void m0_be_ut_seg_init_fini(void);
+extern void m0_be_ut_seg_create_destroy(void);
+extern void m0_be_ut_seg_open_close(void);
+
+extern void m0_be_ut_alloc_init_fini(void);
+
+const struct m0_test_suite m0_be_ut = {
+	.ts_name = "be-ut",
+	.ts_tests = {
+		{ "seg-init",   m0_be_ut_seg_init_fini		},
+		{ "seg-create", m0_be_ut_seg_create_destroy	},
+		{ "seg-open",   m0_be_ut_seg_open_close		},
+		{ "alloc-init", m0_be_ut_alloc_init_fini	},
+		{ NULL, NULL }
+	}
+};
+
+
+/*
+ *  Local variables:
+ *  c-indentation-style: "K&R"
+ *  c-basic-offset: 8
+ *  tab-width: 8
+ *  fill-column: 80
+ *  scroll-step: 1
+ *  End:
+ */
+/*
+ * vim: tabstop=8 shiftwidth=8 noexpandtab textwidth=80 nowrap
+ */
diff --git a/be/ut/seg.c b/be/ut/seg.c
index 94c003f..869af20 100644
--- a/be/ut/seg.c
+++ b/be/ut/seg.c
@@ -97,7 +97,7 @@ static void seg_fini_helper(struct m0_be_seg *seg, bool stob_put)
 	dom->sd_ops->sdo_fini(dom);
 }
 
-static void test_init_fini(void)
+M0_INTERNAL void m0_be_ut_seg_init_fini(void)
 {
 	struct m0_be_seg seg;
 
@@ -107,7 +107,7 @@ static void test_init_fini(void)
 	seg_storage_fini();
 }
 
-static void test_create_destroy(void)
+M0_INTERNAL void m0_be_ut_seg_create_destroy(void)
 {
 	struct m0_be_seg seg;
 	int              rc;
@@ -122,7 +122,7 @@ static void test_create_destroy(void)
 	seg_storage_fini();
 }
 
-static void test_open_close(void)
+M0_INTERNAL void m0_be_ut_seg_open_close(void)
 {
 	struct m0_be_seg seg;
 	int              rc;
@@ -139,13 +139,3 @@ static void test_open_close(void)
 	seg_fini_helper(&seg, false);
 	seg_storage_fini();
 }
-
-const struct m0_test_suite be_seg_ut = {
-	.ts_name = "be-seg-ut",
-	.ts_tests = {
-		{ "init",   test_init_fini },
-		{ "create", test_create_destroy },
-		{ "open",   test_open_close },
-		{ NULL, NULL }
-	}
-};
diff --git a/mero/magic.h b/mero/magic.h
index 6629b21..8d45d24 100644
--- a/mero/magic.h
+++ b/mero/magic.h
@@ -118,6 +118,20 @@ enum m0_magic_satchel {
 	/* m0_balloc_super_block::bsb_magic (blessed baloc) */
 	M0_BALLOC_SB_MAGIC = 0x33b1e55edba10c77,
 
+/* be */
+	/* XXX TODO generate it. be_alloc_chunk::bac_magic0 */
+	M0_BE_ALLOC_MAGIC0 = 0x330123456789AB77,
+	/* XXX TODO generate it. be_alloc_chunk::bac_magic1 */
+	M0_BE_ALLOC_MAGIC1 = 0x33BA987654321077,
+	/* XXX TODO generate it. m0_be_allocator_header::bah_chunks */
+	M0_BE_ALLOC_ALL_MAGIC = 0x3300112233445577,
+	/* XXX TODO generate it. be_alloc_chunk::bac_magic */
+	M0_BE_ALLOC_ALL_LINK_MAGIC = 0x3355443322110077,
+	/* XXX TODO generate it. m0_be_allocator_header::bah_free */
+	M0_BE_ALLOC_FREE_MAGIC = 0x3300001111222277,
+	/* XXX TODO generate it. be_alloc_chunk::bac_magic_free */
+	M0_BE_ALLOC_FREE_LINK_MAGIC = 0x3322221111000077,
+
 /* m0t1fs */
 	/* m0t1fs_sb::s_magic (cozie filesis) */
 	M0_T1FS_SUPER_MAGIC = 0x33c021ef11e51577,
diff --git a/utils/ut_main.c b/utils/ut_main.c
index 836c8ce..92e2cb1 100644
--- a/utils/ut_main.c
+++ b/utils/ut_main.c
@@ -39,7 +39,7 @@ extern const struct m0_test_suite addb_ut;
 extern const struct m0_test_suite adieu_ut;
 extern const struct m0_test_suite balloc_ut;
 extern const struct m0_test_suite be_list_ut;
-extern const struct m0_test_suite be_seg_ut;
+extern const struct m0_test_suite m0_be_ut;
 extern const struct m0_test_suite buffer_pool_ut;
 extern const struct m0_test_suite bulkio_client_ut;
 extern const struct m0_test_suite bulkio_server_ut;
@@ -106,7 +106,7 @@ void add_uts(void)
 	m0_ut_add(&adieu_ut);
 	m0_ut_add(&balloc_ut);
 	m0_ut_add(&be_list_ut);
-	m0_ut_add(&be_seg_ut);
+	m0_ut_add(&m0_be_ut);
 	m0_ut_add(&buffer_pool_ut);
 	m0_ut_add(&bulkio_client_ut);
 	m0_ut_add(&bulkio_server_ut);
-- 
1.8.3.2

