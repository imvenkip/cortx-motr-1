From a7f0e3200c4829c43b07ca5eafda80a9b8775151 Mon Sep 17 00:00:00 2001
From: Anatoliy Bilenko <anatoliy_bilenko@xyratex.com>
Date: Thu, 20 Jun 2013 19:11:59 +0300
Subject: [PATCH 187/228] tx_fom: Added FOM_IO_EMU definition to switch between
 real and emulated IO in tx fom.

---
 be/be.c     | 19 +++++++++++++++++++
 be/tx_fom.c | 23 ++++++++++++++++++++---
 2 files changed, 39 insertions(+), 3 deletions(-)

diff --git a/be/be.c b/be/be.c
index 7679e5c..9ab45ca 100644
--- a/be/be.c
+++ b/be/be.c
@@ -25,9 +25,11 @@
 #include "lib/misc.h" /* M0_BITS */
 #include "lib/memory.h"	/* m0_alloc */
 #include "be/btree.h"
+#include "fop/fom.h"
 #include "be/be.h"
 #include "sm/sm.h"
 
+
 /**
  * @addtogroup be
  *
@@ -118,6 +120,23 @@ M0_INTERNAL void m0_be_op_state_set(struct m0_be_op *op,
 	m0_sm_group_unlock(&op->bo_sm_grp);
 }
 
+M0_INTERNAL int m0_be_op_tick_ret(struct m0_be_op *op, struct m0_fom *fom,
+				  int next_state)
+{
+	m0_sm_group_lock(&op->bo_sm_grp);
+	if (M0_IN(op->bo_sm.sm_state, (M0_BOS_SUCCESS, M0_BOS_FAILURE))) {
+		m0_sm_group_unlock(&op->bo_sm_grp);
+		return M0_FSO_AGAIN;
+	}
+
+	m0_sm_group_lock(&op->bo_sm_grp);
+	m0_fom_wait_on(fom, &op->bo_sm.sm_chan, &fom->fo_cb);
+	m0_sm_group_unlock(&op->bo_sm_grp);
+
+	m0_fom_phase_set(fom, next_state);
+	return M0_FSO_WAIT;
+}
+
 #undef M0_TRACE_SUBSYSTEM
 /** @} end of be group */
 
diff --git a/be/tx_fom.c b/be/tx_fom.c
index 0f98705..55fa442 100644
--- a/be/tx_fom.c
+++ b/be/tx_fom.c
@@ -32,7 +32,8 @@
 #include "be/tx_service.h"
 #include "be/tx.h"
 
-#if 1 /* XXX */
+#define FOM_IO_EMU 0
+#if FOM_IO_EMU /* XXX */
 #include "lib/thread.h"
 static struct m0_thread g_thread;
 static struct m0_chan   g_chan;
@@ -80,6 +81,7 @@ enum tx_fom_states {
 struct tx_fom {
 	struct m0_fom           tf_gen;
 	struct m0_be_tx_engine *tf_engine;
+	struct m0_be_op         tf_op;
 };
 
 static struct m0_sm_state_descr tx_fom_states[] = {
@@ -151,7 +153,7 @@ static int tx_fom_tick(struct m0_fom *fom)
 		break;
 
 	case FS_SUBMITTED_TO_SEG:
-#if 1  /* XXX */
+#if FOM_IO_EMU  /* XXX */
 		m0_mutex_init(&g_mutex);
 		m0_chan_init(&g_chan, &g_mutex);
 
@@ -165,10 +167,23 @@ static int tx_fom_tick(struct m0_fom *fom)
 		return M0_FSO_WAIT;
 
 #else  /* XXX */
-		break;
+		{
+			struct tx_fom      *f = fom_to_txm(fom);
+			struct m0_be_reg_d *area = tx->t_reg_d_area;
+			struct m0_be_seg   *seg = area[0].rd_reg.br_seg;
+			struct m0_be_op    *op = &f->tf_op;
+
+			m0_be_seg_write_simple(seg, op, area,
+					       tx->t_captured.tc_reg_nr);
+			return m0_be_op_tick_ret(op, fom, FS_PLACED);
+		}
 #endif  /* XXX */
 
 	case FS_PLACED:
+#if FOM_IO_EMU  /* XXX */
+#else
+		M0_ASSERT(m0_be_op_state(&fom_to_txm(fom)->tf_op) == M0_BOS_SUCCESS);
+#endif
 		tx_state_set(tx, M0_BTS_PLACED);
 		m0_be_tx_free(tx);  /* free region buffers */
 		m0_fom_phase_set(fom, FS_STABLE);
@@ -236,6 +251,8 @@ tx_fom_create(struct m0_reqh *reqh, struct m0_be_tx_engine *engine)
 
 	engine->te_fom = fom;
 	txm->tf_engine = engine;
+	m0_be_op_init(&txm->tf_op);
+
 	return fom;
 }
 
-- 
1.8.3.2

