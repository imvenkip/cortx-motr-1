From b449d49a6b676bd9be0e3bfe981b0b9befd5a427 Mon Sep 17 00:00:00 2001
From: Alexander Gattin <alexander_gattin@xyratex.com>
Date: Fri, 21 Jun 2013 20:55:49 +0300
Subject: [PATCH 210/228] be/tx: use stobio chan directly without callbacks and
 stuff.

---
 be/be.h        |   9 ---
 be/seg.c       | 188 +++++++++++++++------------------------------------------
 be/seg.h       |  26 ++------
 be/tx.c        |  36 +++++++++--
 be/tx.h        |   3 +
 be/tx_fom.c    |  55 +++++++----------
 be/tx_regmap.c |   2 +
 be/ut/seg.c    |   4 --
 8 files changed, 111 insertions(+), 212 deletions(-)

diff --git a/be/be.h b/be/be.h
index 881929b..70e0766 100644
--- a/be/be.h
+++ b/be/be.h
@@ -57,7 +57,6 @@ enum m0_be_op_state {
 
 enum m0_be_op_type {
 	M0_BOP_REG,
-	M0_BOP_SEGIO,
 	M0_BOP_TREE,
 	M0_BOP_LIST,
 	M0_BOP_NR
@@ -73,14 +72,6 @@ struct m0_be_op {
 		/* Used by m0_be_reg_get(). */
 		struct m0_be_reg                   u_reg;
 
-		/* Used by m0_be_seg_read(), m0_be_seg_write(). */
-		struct {
-			/* STOB i/o structure with allocated si_stob.iv_index
-			 * array. */
-			struct m0_stob_io          si_stobio;
-			struct m0_clink            si_clink;
-		} u_segio;
-
 		/* Used by m0_be_list_get() and its callback. */
 		struct {
 			const struct m0_be_list   *l_list;
diff --git a/be/seg.c b/be/seg.c
index 2526d81..930d2c8 100644
--- a/be/seg.c
+++ b/be/seg.c
@@ -24,6 +24,8 @@
 #include "lib/misc.h"         /* M0_IN */
 #include "lib/memory.h"       /* m0_alloc_aligned */
 #include "lib/errno.h"        /* ENOMEM */
+#define M0_TRACE_SUBSYSTEM M0_TRACE_SUBSYS_BE
+#include "lib/trace.h"        /* M0_LOG */
 #include <sys/mman.h>         /* mmap */
 #include <search.h>           /* twalk */
 
@@ -294,156 +296,47 @@ static inline m0_bcount_t be_seg_blkno(const struct m0_be_seg *seg, void *addr)
 	return (addr - seg->bs_addr) >> seg->bs_bshift;
 }
 
-static void iovec_prepare(struct m0_be_seg *seg, struct m0_be_reg_d *area,
-			  m0_bindex_t nr, struct m0_indexvec *iv,
-			  struct m0_bufvec *bv)
+M0_INTERNAL int m0_be_launch_seg_write(struct m0_be_tx *tx)
 {
-	int i;
-
-	M0_PRE(seg->bs_bshift == 0);
-
-	M0_ALLOC_ARR(bv->ov_vec.v_count, nr);
-	M0_ALLOC_ARR(bv->ov_buf, nr);
-
-	M0_ALLOC_ARR(iv->iv_vec.v_count, nr);
-	M0_ALLOC_ARR(iv->iv_index, nr);
-
-	M0_ASSERT(bv->ov_vec.v_count != NULL && bv->ov_buf   != NULL);
-	M0_ASSERT(iv->iv_vec.v_count != NULL && iv->iv_index != NULL);
-
-	bv->ov_vec.v_nr = nr;
-	iv->iv_vec.v_nr = nr;
-
-	for (i = 0; i < nr; ++i) {
-		bv->ov_vec.v_count[i] = area[i].rd_reg.br_size;
-		bv->ov_buf[i]	      = area[i].rd_buf;
-
-		iv->iv_vec.v_count[i] = area[i].rd_reg.br_size;
-		iv->iv_index[i]       = be_seg_blkno(seg, area[i].rd_reg.br_addr);
-	}
-}
-
-static bool be_seg_stobio_cb(struct m0_clink *link)
-{
-	struct m0_be_op   *op = container_of(link, struct m0_be_op,
-					     bo_u.u_segio.si_clink);
-	struct m0_stob_io *io = &op->bo_u.u_segio.si_stobio;
-
-/* XXX: This probably should be deleted, but most likely in m0_be_op_fini() or
-   ->sd_in() of M0_BOS_SUCCESS | M0_BOS_FAILURE states...
- */
-/*        m0_clink_del_lock(link); */
-/*        m0_clink_fini(link); */
-/*        m0_stob_io_fini(io); */
-
-	op->bo_sm.sm_rc = io->si_rc;
-	m0_be_op_state_set(op, io->si_rc == 0 ? M0_BOS_SUCCESS : M0_BOS_FAILURE);
-
-	return io->si_rc == 0;
-}
-
-M0_INTERNAL void m0_be_seg_write_simple(struct m0_be_seg *seg,
-					struct m0_be_op *op,
-					struct m0_be_reg_d *area,
-					m0_bindex_t nr)
-{
-	struct m0_stob_io *io    = &op->bo_u.u_segio.si_stobio;
-	struct m0_clink   *clink = &op->bo_u.u_segio.si_clink;
-	int                rc;
-
-	/* Set up op, clink and io structs for SEGIO write. */
-	op->bo_utype = M0_BOP_SEGIO;
-	m0_clink_init(clink, &be_seg_stobio_cb);
-
-	m0_stob_io_init(io);
-	io->si_flags        = 0;
-	io->si_opcode       = SIO_WRITE;
-	io->si_fol_rec_part = (void *)1;
-
-	iovec_prepare(seg, area, nr, &io->si_stob, &io->si_user);
-
-	m0_clink_add_lock(&io->si_wait, clink);
-	m0_be_op_state_set(op, M0_BOS_ACTIVE);
-	rc = m0_stob_io_launch(io, seg->bs_stob, NULL, NULL);
-}
-
-M0_INTERNAL int
-m0_be_seg_write(struct m0_be_seg *seg, void *regd_tree, struct m0_be_op *op)
-{
-	struct m0_stob_io  *io;
-	struct m0_clink    *clink;
-	int                 rc;
-
-	M0_PRE(m0_be__seg_invariant(seg) && op != NULL);
-
-	/* Set up op, clink and io structs for SEGIO write. */
-	op->bo_utype        = M0_BOP_SEGIO;
-	clink               = &op->bo_u.u_segio.si_clink;
-	io                  = &op->bo_u.u_segio.si_stobio;
-	m0_clink_init(clink, &be_seg_stobio_cb);
-	m0_stob_io_init(io);
+	struct m0_stob_io         *io;
+	M0_UNUSED struct m0_clink *clink;
+	struct m0_be_seg          *seg;
+
+	M0_PRE(m0_be__tx_invariant(tx));
+
+	/* Set up tx's clink and io structs for SEGIO write. */
+	/*clink               = &tx->t_clink;*/
+	io                  = &tx->t_stobio;
+	/*m0_clink_init(clink, NULL);*/
+	/*
+	io->si_state        = SIS_IDLE;
+	m0_mutex_init(&io->si_mutex);
+	m0_chan_init(&io->si_wait, &io->si_mutex);
+	*/
 	io->si_flags        = 0;
 	io->si_opcode       = SIO_WRITE;
 	io->si_fol_rec_part = (void *)1;
 
-	/* Allocate and fill counts, buffers and indexes arrays. */
-	rc = m0_be_seg_bufvec_build(seg, regd_tree, &io->si_stob,
-				    &io->si_user);
-	if (rc != 0) {
-		op->bo_sm.sm_rc = rc;
-		m0_sm_state_set(&op->bo_sm, M0_BOS_FAILURE);
-		return rc;
-	}
+	/* Fill counts, buffers and indexes arrays. */
+	M0_LOG(M0_DEBUG, "tx%p", tx);
+	seg = m0_be_seg_bufvec_build(tx->t_root, &io->si_stob, &io->si_user);
+	M0_ASSERT(m0_be__seg_invariant(seg));
 
 	/* Add clink and start STOB i/o. */
-	m0_clink_add_lock(&io->si_wait, clink);
-	rc = m0_stob_io_launch(io, seg->bs_stob, NULL, NULL);
-	if (rc == 0)
-		m0_sm_state_set(&op->bo_sm, M0_BOS_ACTIVE);
-	return rc;
+	/*m0_clink_add_lock(&io->si_wait, clink);*/
+	return m0_stob_io_launch(io, seg->bs_stob, NULL, NULL);
 }
 
-M0_INTERNAL int m0_be_seg_bufvec_build(struct m0_be_seg *seg,
-				       void *regd_tree,
-				       struct m0_indexvec *iv,
-				       struct m0_bufvec *bv)
+M0_INTERNAL struct m0_be_seg * m0_be_seg_bufvec_build(void *regd_tree,
+						      struct m0_indexvec *iv,
+						      struct m0_bufvec *bv)
 {
-	m0_bcount_t reg_nr;
-	m0_bcount_t i;
+	struct m0_be_seg *seg;
+	m0_bcount_t       i;
 
-	M0_PRE(m0_be__seg_invariant(seg));
 	M0_PRE(iv != NULL && bv != NULL);
 
-	/* Count number of reg_d records in the tree. */
-	void reg_cnt(const void *p, const VISIT which, const int depth)
-	{
-		if (which == postorder || which == leaf)
-			reg_nr++;
-	}
-	reg_nr = 0;
-	twalk(regd_tree, &reg_cnt);
-
-	/* Allocate buf/index and count arrays in the provided
-	 * bufvec and indexvec stuctures. */
-	bv->ov_vec.v_nr    = reg_nr;
-	bv->ov_vec.v_count = M0_ALLOC_ARR(bv->ov_vec.v_count, reg_nr);
-	if (bv->ov_vec.v_count == NULL)
-		return -ENOMEM;
-	bv->ov_buf         = M0_ALLOC_ARR(bv->ov_buf, reg_nr);
-	if (bv->ov_buf == NULL) {
-		m0_free(bv->ov_vec.v_count);
-		return -ENOMEM;
-	}
-	iv->iv_index       = M0_ALLOC_ARR(iv->iv_index, reg_nr);
-	if (iv->iv_index == NULL) {
-		m0_free(bv->ov_buf);
-		m0_free(bv->ov_vec.v_count);
-		return -ENOMEM;
-	}
-	iv->iv_vec         = bv->ov_vec;
-
 	/* Fill count and buf/index arrays. */
-	i = 0;
 	void reg_fillvec(const void *p, const VISIT which, const int depth)
 	{
 		struct m0_be_regdtree_node *n =
@@ -453,6 +346,13 @@ M0_INTERNAL int m0_be_seg_bufvec_build(struct m0_be_seg *seg,
 			/* fill iv->iv_index[i], bv->ov_buf[i] and
 			 * iv->iv_vec.v_count[i]/bv->ov_vec.v_count[i]. */
 			m0_bcount_t b0;
+			if (seg == NULL) {
+				/* Take the 1st seg pointer as The Seg. */
+				seg = r->rd_reg.br_seg;
+			} else {
+				/* Assert that The Seg is The Only. */
+				M0_ASSERT(seg == r->rd_reg.br_seg);
+			}
 			M0_ASSERT(m0_addr_is_aligned(r->rd_buf,
 						     seg->bs_bshift));
 			b0 = be_seg_blkno(seg, r->rd_reg.br_addr);
@@ -462,13 +362,23 @@ M0_INTERNAL int m0_be_seg_bufvec_build(struct m0_be_seg *seg,
 			bv->ov_buf[i] = m0_stob_addr_pack(r->rd_buf,
 							  seg->bs_bshift);
 			iv->iv_index[i] = b0;
+			M0_LOG(M0_DEBUG, "reg #%i/%p: seg%p[%p,%p) => "
+			       "[%p,%p)", (int)i, r, seg, bv->ov_buf[i],
+			       bv->ov_buf[i] + bv->ov_vec.v_count[i],
+			       (void*)iv->iv_index[i],
+			       (void*)iv->iv_index[i] + iv->iv_vec.v_count[i]);
 		}
+		i++;
 	}
+	seg = NULL;
+	i = 0;
 	twalk(regd_tree, &reg_fillvec);
-	return 0;
+	iv->iv_vec.v_nr = i;
+	bv->ov_vec.v_nr = i;
+	M0_ASSERT(m0_be__seg_invariant(seg));
+	return seg;
 }
 
-
 M0_INTERNAL void m0_be_reg_get(struct m0_be_reg *reg, struct m0_be_op *op)
 {
 	m0_bcount_t n;
@@ -570,6 +480,8 @@ M0_INTERNAL bool m0_be_seg_contains(const struct m0_be_seg *seg, void *addr)
 
 /** @} end of be group */
 
+#undef M0_TRACE_SUBSYSTEM
+
 /*
  *  Local variables:
  *  c-indentation-style: "K&R"
diff --git a/be/seg.h b/be/seg.h
index c9fa911..ed694f7 100644
--- a/be/seg.h
+++ b/be/seg.h
@@ -98,14 +98,10 @@ M0_INTERNAL int m0_be_seg_dict_delete(struct m0_be_seg *seg, const char *name);
 
 M0_INTERNAL bool m0_be_seg_contains(const struct m0_be_seg *seg, void *addr);
 
-M0_INTERNAL int m0_be_seg_write(struct m0_be_seg *seg,
-				void *regd_tree,
-				struct m0_be_op *op);
-
-M0_INTERNAL int m0_be_seg_bufvec_build(struct m0_be_seg *seg,
-				       void *regd_tree,
-				       struct m0_indexvec *iv,
-				       struct m0_bufvec *bv);
+M0_INTERNAL int m0_be_launch_seg_write(struct m0_be_tx *tx);
+M0_INTERNAL struct m0_be_seg * m0_be_seg_bufvec_build(void *regd_tree,
+						      struct m0_indexvec *iv,
+						      struct m0_bufvec *bv);
 
 /*
  * `reg' parameter is not const, because stob IO will update
@@ -146,19 +142,5 @@ M0_INTERNAL int m0_be__reg_write(struct m0_be_seg *seg,
 				 struct m0_be_reg *regs,
 				 m0_bcount_t nr);
 
-/**
- * Simple segment write implementation which has to be removed ASAP.
- * It's introduced because we need straightforward possibility to
- * write data on the disk. This will unblock other tasks in BE. This
- * call will be replaced with m0_be_seg_write() in the nearest future.
- *
- * @param area - array of regions which has to be written on the disk.
- *               It has @nr elements.
- */
-M0_INTERNAL void m0_be_seg_write_simple(struct m0_be_seg *seg,
-					struct m0_be_op *op,
-					struct m0_be_reg_d *area,
-					m0_bindex_t nr);
-
 /** @} end of be group */
 #endif /* __MERO_BE_SEG_H__ */
diff --git a/be/tx.c b/be/tx.c
index e284eff..7d53ab0 100644
--- a/be/tx.c
+++ b/be/tx.c
@@ -181,6 +181,7 @@ M0_INTERNAL void m0_be_tx_init(struct m0_be_tx *tx, uint64_t tid,
 					      void *payload, void *datum))
 {
 	m0_sm_init(&tx->t_sm, &tx_sm_conf, M0_BTS_INIT, tx_grp);
+	m0_stob_io_init(&tx->t_stobio);
 	tx->t_root       = NULL;
 	tx->t_id         = tid;
 	tx->t_be         = be;
@@ -207,10 +208,12 @@ M0_INTERNAL void m0_be_tx_fini(struct m0_be_tx *tx)
 
 M0_INTERNAL void m0_be_tx_free(struct m0_be_tx *tx)
 {
+	struct m0_stob_io *io;
 	void noop(void *nodep) {}
 
 	M0_PRE(m0_be__tx_invariant(tx));
 	M0_PRE(tx_state(tx) >= M0_BTS_PLACED);
+	M0_ENTRY();
 
 	tdestroy(tx->t_root, noop);
 	tx->t_root = NULL;
@@ -220,6 +223,18 @@ M0_INTERNAL void m0_be_tx_free(struct m0_be_tx *tx)
 
 	m0_free(tx->t_reg_d_area);
 	tx->t_reg_d_area = NULL;
+
+	io = &tx->t_stobio;
+	m0_free(io->si_user.ov_vec.v_count);
+	io->si_user.ov_vec.v_count = NULL;  /* iv and ov share the same */
+        io->si_stob.iv_vec.v_count = NULL;  /* v_count array. */
+
+	m0_free(io->si_user.ov_buf);
+	io->si_user.ov_buf = NULL;
+
+	m0_free(io->si_stob.iv_index);
+	io->si_stob.iv_index = NULL;
+	M0_LEAVE();
 }
 
 M0_INTERNAL void
@@ -241,6 +256,8 @@ M0_INTERNAL void m0_be_tx_open(struct m0_be_tx *tx)
 {
 	struct m0_be_tx_engine *eng      = tx_engine(tx);
 	struct m0_be_tx_credit *prepared = &tx->t_prepared;
+	struct m0_bufvec       *bv;
+	struct m0_indexvec     *iv;
 	m0_bcount_t             log_size = tx_prepared_log_size(tx);
 
 	M0_PRE(m0_be__tx_invariant(tx));
@@ -250,7 +267,15 @@ M0_INTERNAL void m0_be_tx_open(struct m0_be_tx *tx)
 				  eng->te_log.lg_gr_size_max)) {
 		M0_ALLOC_ARR(tx->t_reg_d_area, prepared->tc_reg_nr);
 		M0_ALLOC_ARR(tx->t_reg_area, prepared->tc_reg_size);
-		if (tx->t_reg_d_area != NULL && tx->t_reg_area != NULL) {
+		iv = &tx->t_stobio.si_stob;
+		bv = &tx->t_stobio.si_user;
+		M0_ALLOC_ARR(bv->ov_vec.v_count, prepared->tc_reg_nr);
+		iv->iv_vec.v_count = bv->ov_vec.v_count;
+		M0_ALLOC_ARR(bv->ov_buf, prepared->tc_reg_nr);
+		M0_ALLOC_ARR(iv->iv_index, prepared->tc_reg_nr);
+		if (tx->t_reg_d_area != NULL && tx->t_reg_area != NULL &&
+		    bv->ov_vec.v_count != NULL && bv->ov_buf != NULL &&
+		    iv->iv_index != NULL) {
 			tx_engine_lock(eng);
 			if (tx_log_free_space(eng) >= log_size)
 				tx_open_tail(tx);
@@ -259,12 +284,11 @@ M0_INTERNAL void m0_be_tx_open(struct m0_be_tx *tx)
 			tx_engine_unlock(eng);
 		} else {
 			tx_fail(tx, -ENOMEM);
-			m0_free(tx->t_reg_d_area);
-			m0_free(tx->t_reg_area);
 		}
 	} else
 		tx_fail(tx, -EFBIG);
 
+	M0_LOG(M0_DEBUG, "tx%p", tx);
 	M0_POST(m0_be__tx_invariant(tx));
 }
 
@@ -285,8 +309,10 @@ m0_be_tx_capture(struct m0_be_tx *tx, const struct m0_be_reg *reg)
 	new->rd_buf = tx->t_reg_area + pos->tc_reg_size;
 	new->rd_reg = *reg;
 
-	M0_LOG(M0_DEBUG, "capture %p: [%p, %p)", new, new->rd_reg.br_addr,
-	       new->rd_reg.br_addr + new->rd_reg.br_size);
+	M0_LOG(M0_DEBUG, "tx%p capture %p: seg%p[%p, %p) -> [%p,%p)",
+	       tx, new, reg->br_seg, new->rd_reg.br_addr,
+	       new->rd_reg.br_addr + new->rd_reg.br_size,
+	       new->rd_buf, new->rd_buf + new->rd_reg.br_size);
 	credit_mod(&tx->t_captured, new, +1);
 	/*
 	 * A transaction keeps a tree of captured regions in tx->t_tree. Key
diff --git a/be/tx.h b/be/tx.h
index 79e5203..1712be3 100644
--- a/be/tx.h
+++ b/be/tx.h
@@ -404,6 +404,9 @@ struct m0_be_tx {
 	 * regions captured by the transaction.
 	 */
 	void                  *t_reg_area;
+	/* STOB i/o structure for seg and log i/o. */
+	struct m0_stob_io      t_stobio;
+	struct m0_clink        t_clink;
 	/**
 	 * The group the transaction is part of. This is non-NULL iff the
 	 * transaction is in GROUPED or later state.
diff --git a/be/tx_fom.c b/be/tx_fom.c
index 051fb25..b80adfe 100644
--- a/be/tx_fom.c
+++ b/be/tx_fom.c
@@ -82,8 +82,8 @@ enum tx_fom_states {
 
 struct tx_fom {
 	struct m0_fom           tf_gen;
+	struct m0_be_tx        *tf_tx;
 	struct m0_be_tx_engine *tf_engine;
-	struct m0_be_op         tf_op;
 };
 
 static struct m0_sm_state_descr tx_fom_states[] = {
@@ -129,9 +129,10 @@ static struct m0_sm_conf tx_fom_conf = {
 
 static int tx_fom_tick(struct m0_fom *fom)
 {
-	struct m0_be_tx *tx = m0_fom_phase(fom) > FS_STARTED ?
+	struct m0_be_tx  *tx = m0_fom_phase(fom) > FS_STARTED ?
 		gr_tlist_head(&fom_to_txm(fom)->tf_engine->te_group.tg_tx) :
 		NULL;
+	int               rc;
 
 	M0_LOG(M0_DEBUG, "phase = %d", m0_fom_phase(fom));
 
@@ -155,39 +156,25 @@ static int tx_fom_tick(struct m0_fom *fom)
 		break;
 
 	case FS_SUBMITTED_TO_SEG:
-#if XXX_MOCK_IO
-		m0_mutex_init(&g_mutex);
-		m0_chan_init(&g_chan, &g_mutex);
-
-		M0_THREAD_INIT(&g_thread, int, NULL, &g_handler, 0, "XXX");
-
-		m0_mutex_lock(&g_mutex);
-		m0_fom_wait_on(fom, &g_chan, &fom->fo_cb);
-		m0_mutex_unlock(&g_mutex);
-
-		m0_fom_phase_set(fom, FS_PLACED);
-		return M0_FSO_WAIT;
-#else
-		{
-			struct tx_fom      *f = fom_to_txm(fom);
-			struct m0_be_reg_d *area = tx->t_reg_d_area;
-			struct m0_be_seg   *seg = area[0].rd_reg.br_seg;
-			struct m0_be_op    *op = &f->tf_op;
-
-			m0_be_op_init(op);
-			m0_be_seg_write_simple(seg, op, area,
-					       tx->t_captured.tc_reg_nr);
-			return m0_be_op_tick_ret(op, fom, FS_PLACED);
+		/* chan_lock &tx->t_stobio.si_wait */
+		m0_mutex_lock(tx->t_stobio.si_wait.ch_guard);
+		m0_fom_wait_on(fom, &tx->t_stobio.si_wait, &fom->fo_cb);
+		M0_LOG(M0_DEBUG, "set up wait on chan %p",
+		       &tx->t_stobio.si_wait);
+		/* chan_unlock &tx->t_stobio.si_wait */
+		rc = m0_be_launch_seg_write(tx);
+		m0_mutex_unlock(tx->t_stobio.si_wait.ch_guard);
+		if (rc == 0) {
+			M0_LOG(M0_DEBUG, "launched tx%p i/o", tx);
+			m0_fom_phase_set(fom, FS_PLACED);
+		} else {
+			m0_fom_phase_set(fom, FS_FAILED);
 		}
-#endif
+		return M0_FSO_WAIT;
+
 	case FS_PLACED:
-#if !XXX_MOCK_IO
-		M0_ASSERT(m0_be_op_state(&fom_to_txm(fom)->tf_op) ==
-			  M0_BOS_SUCCESS);
-		m0_be_op_fini(&fom_to_txm(fom)->tf_op);
-#endif
 		tx_state_set(tx, M0_BTS_PLACED);
-		m0_be_tx_free(tx);  /* free region buffers */
+		m0_be_tx_free(tx);  /* free region and i/o buffers */
 		m0_fom_phase_set(fom, FS_STABLE);
 		return M0_FSO_AGAIN;
 
@@ -239,8 +226,8 @@ static const struct m0_fom_type_ops tx_fom_type_ops = {
 	.fto_create = NULL
 };
 
-static struct m0_fom *
-tx_fom_create(struct m0_reqh *reqh, struct m0_be_tx_engine *engine)
+static struct m0_fom * tx_fom_create(struct m0_reqh *reqh,
+				     struct m0_be_tx_engine *engine)
 {
 	struct tx_fom *txm;
 	struct m0_fom *fom;
diff --git a/be/tx_regmap.c b/be/tx_regmap.c
index ad45966..23cf27d 100644
--- a/be/tx_regmap.c
+++ b/be/tx_regmap.c
@@ -67,6 +67,8 @@ M0_INTERNAL size_t m0_be_regmap_size(struct m0_be_regmap *rm)
 	return 0;
 }
 
+/* XXX: tx_reg_cmp compares regions of different segnemts as if they are
+ * in the same segment. */
 M0_INTERNAL int tx_reg_cmp(const void *p0, const void *p1)
 {
 	const struct m0_be_reg_d *r0   = p0;
diff --git a/be/ut/seg.c b/be/ut/seg.c
index 194764d..d241b11 100644
--- a/be/ut/seg.c
+++ b/be/ut/seg.c
@@ -50,10 +50,6 @@ static void seg_write(struct m0_be_seg *seg)
 	for (i = 0; i < ARRAY_SIZE(area); ++i)
 		area[i].rd_reg.br_addr = seg->bs_addr + off + i*8;
 
-	m0_be_seg_write_simple(seg, &op, area, ARRAY_SIZE(area));
-	m0_be_op_wait(&op);
-	M0_UT_ASSERT(m0_be_op_state(&op) == M0_BOS_SUCCESS);
-
 	m0_be_op_fini(&op);
 }
 
-- 
1.8.3.2

