From 53fcf772c0acbecaa312aad77705ed4ccc84d90f Mon Sep 17 00:00:00 2001
From: Anatoliy Bilenko <anatoliy_bilenko@xyratex.com>
Date: Tue, 18 Jun 2013 15:18:46 +0300
Subject: [PATCH 165/228] tx: tx UT test updated, added asynchronous fom which
 process IO produced by tx

---
 be/tx.c       |  29 +++++++++++++++--
 be/tx.h       |  11 ++++++-
 be/tx_fom.c   | 103 ++++++++++++++++++++++++++++++++++++++++++++++++++--------
 be/tx_fom.h   |   5 ++-
 be/ut/btree.c |  12 +++----
 be/ut/tx.c    |  30 ++++++++++++-----
 6 files changed, 159 insertions(+), 31 deletions(-)

diff --git a/be/tx.c b/be/tx.c
index 8855899..d96b84e 100644
--- a/be/tx.c
+++ b/be/tx.c
@@ -23,6 +23,9 @@
  *
  * @{
  */
+#undef M0_TRACE_SUBSYSTEM
+#define M0_TRACE_SUBSYSTEM M0_TRACE_SUBSYS_BE
+#include "lib/trace.h"
 
 #include <search.h>            /* tsearch */
 
@@ -36,13 +39,14 @@
 #include "be/be.h"
 #include "be/tx.h"
 /* #include "be/tx_regmap.h"    /\* m0_be_regdtree_node *\/ */
+#include "fop/fom.h"
 
-M0_TL_DESCR_DEFINE(tx, "transactions", static, struct m0_be_tx,
+M0_TL_DESCR_DEFINE(tx, "transactions", M0_INTERNAL, struct m0_be_tx,
 		   t_linkage, t_magic,
 		   M0_TRACE_TX_MAGIC,
 		   M0_TRACE_TX_LIST_MAGIC);
 
-M0_TL_DEFINE(tx, static, struct m0_be_tx);
+M0_TL_DEFINE(tx, M0_INTERNAL, struct m0_be_tx);
 
 static bool tx_invariant(const struct m0_sm *mach);
 
@@ -206,6 +210,10 @@ m0_be_tx_prep(struct m0_be_tx *tx, const struct m0_be_tx_credit *credit)
 	M0_PRE(m0_be__tx_invariant(tx));
 	M0_PRE(tx_state(tx) == M0_BTS_INIT);
 	m0_be_tx_credit_add(&tx->t_prepared, credit);
+
+#if 1  /* added XXX */
+	tx->t_payload_size = tx->t_prepared.tc_reg_size;
+#endif
 	tx_state_set(tx, M0_BTS_PREPARE);
 	M0_POST(m0_be__tx_invariant(tx));
 }
@@ -352,6 +360,12 @@ M0_INTERNAL void m0_be_tx_close(struct m0_be_tx *tx)
 	tx_engine_got_space(eng);
 
 	M0_POST(m0_be__tx_engine_invariant(eng));
+
+	/* XXX */
+	M0_LOG(M0_DEBUG, "wakeup");
+	m0_fom_wakeup(eng->te_fom);
+	M0_LOG(M0_DEBUG, "awaken");
+
 	tx_engine_unlock(eng);
 }
 
@@ -510,6 +524,17 @@ static bool tx_invariant(const struct m0_sm *sm)
 	return m0_be__tx_invariant(sm2tx(sm));
 }
 
+M0_INTERNAL int m0_be_tx_timedwait(struct m0_be_tx *tx, int state,
+				   m0_time_t timeout)
+{
+        m0_sm_group_lock(tx->t_sm.sm_grp);
+        m0_sm_timedwait(&tx->t_sm, state, timeout);
+        m0_sm_group_unlock(tx->t_sm.sm_grp);
+
+        return tx->t_sm.sm_rc;
+}
+
+#undef M0_TRACE_SUBSYSTEM
 /** @} struct of be group */
 
 /*
diff --git a/be/tx.h b/be/tx.h
index a4d6d54..2beba2e 100644
--- a/be/tx.h
+++ b/be/tx.h
@@ -319,6 +319,11 @@ struct m0_be_tx_engine {
 	 * space is released.
 	 */
 	m0_bcount_t           te_reserved;
+
+	/**
+	 * Pointer to fom-worker serving transaction groups
+	 */
+	struct m0_fom        *te_fom;
 };
 
 M0_INTERNAL bool
@@ -492,7 +497,8 @@ M0_INTERNAL void m0_be_tx_capture(struct m0_be_tx *tx,
 
 M0_INTERNAL void m0_be_tx_close(struct m0_be_tx *tx);
 
-M0_INTERNAL int m0_be_tx_timedwait(struct m0_be_tx *tx, m0_time_t timeout);
+M0_INTERNAL int m0_be_tx_timedwait(struct m0_be_tx *tx, int state,
+				   m0_time_t timeout);
 
 /** Forces the transaction to storage. */
 M0_INTERNAL void m0_be_tx_force(struct m0_be_tx *tx);
@@ -504,6 +510,9 @@ M0_INTERNAL void m0_be_tx_stable(struct m0_be_tx *tx);
 
 M0_INTERNAL void tx_state_set(struct m0_be_tx *tx, enum m0_be_tx_state state);
 
+M0_TL_DESCR_DECLARE(tx, M0_EXTERN);
+M0_TL_DECLARE(tx, M0_INTERNAL, struct m0_be_tx);
+
 /** @} end of be group */
 #endif /* __MERO_BE_TX_H__ */
 
diff --git a/be/tx_fom.c b/be/tx_fom.c
index d2b6f22..808f3e1 100644
--- a/be/tx_fom.c
+++ b/be/tx_fom.c
@@ -21,13 +21,15 @@
 #undef M0_TRACE_SUBSYSTEM
 #define M0_TRACE_SUBSYSTEM M0_TRACE_SUBSYS_BE
 #include "lib/trace.h"
-#include "lib/cdefs.h" /* M0_UNUSED */
+#include "lib/cdefs.h"
 #include "lib/errno.h"
 #include "lib/memory.h"
+#include "lib/misc.h"
 #include "fop/fom.h"
 #include "reqh/reqh.h"
 #include "fop/fom_generic.h"
 #include "be/tx_service.h"
+#include "be/tx.h"
 
 /**
  * @addtogroup be
@@ -35,34 +37,104 @@
  */
 
 enum tx_fom_states {
-	FS_GROUPPED = M0_FOPH_NR + 1,
+	FS_STARTED,
+	FS_STABLE,
+
+	FS_GROUPED,
 	FS_SUBMITTED,
 	FS_PAYLOAD_LOGGED,
 	FS_COMMIT_GROUP_LOGGED,
 	FS_LOG_HEAD_UPDATED,
 	FS_LOGGED,
 	FS_PLACED,
-	FS_STABLE,
 	FS_FAILED,
 };
 
+static struct m0_sm_state_descr descr[] = {
+#define _STATE(name, flags, allowed)			\
+	[name] = {					\
+		.sd_flags   = (flags),			\
+		.sd_name    = #name,			\
+		.sd_allowed = allowed		\
+	}
+
+	_STATE(FS_STARTED        , M0_SDF_INITIAL, M0_BITS(FS_GROUPED)),
+	_STATE(FS_GROUPED        , 0,	 M0_BITS(FS_SUBMITTED)),
+	_STATE(FS_SUBMITTED       , 0,	 M0_BITS(FS_PAYLOAD_LOGGED)),
+	_STATE(FS_PAYLOAD_LOGGED    , 0, M0_BITS(FS_COMMIT_GROUP_LOGGED)),
+	_STATE(FS_COMMIT_GROUP_LOGGED  , 0, M0_BITS(FS_LOG_HEAD_UPDATED)),
+	_STATE(FS_LOG_HEAD_UPDATED   , 0, M0_BITS(FS_LOGGED)),
+	_STATE(FS_LOGGED        , 0, M0_BITS(FS_PLACED)),
+	_STATE(FS_PLACED        , 0, M0_BITS(FS_STABLE)),
+	_STATE(FS_FAILED        , M0_SDF_TERMINAL, 0),
+	_STATE(FS_STABLE        , M0_SDF_TERMINAL, 0)
+
+#undef _STATE
+};
+
+static struct m0_sm_conf conf = {
+	.scf_name = "tx_fom states",
+	.scf_nr_states = ARRAY_SIZE(descr),
+	.scf_state = descr
+};
+
 struct tx_fom {
 	/** Generic m0_fom object. */
 	struct m0_fom            tf_gen;
 
 	/** other stuff */
+	struct m0_be_tx_engine  *tf_eng;
 };
 
 static int tx_fom_tick(struct m0_fom *fom)
 {
-	M0_UNUSED struct tx_fom *m = container_of(fom, struct tx_fom, tf_gen);
-	M0_ENTRY();
+	struct tx_fom   *m  = container_of(fom, struct tx_fom, tf_gen);
+	struct m0_be_tx *tx = NULL;
 
-	if (m0_fom_phase(fom) < M0_FOPH_NR)
-		return m0_fom_tick_generic(fom);
+	M0_ENTRY();
 
-	m0_fom_phase_set(fom, M0_FOM_PHASE_FINISH);
-	M0_RETURN(M0_FSO_WAIT);
+	/* if (m0_fom_phase(fom) < M0_FOPH_NR) */
+	/* 	return m0_fom_tick_generic(fom); */
+
+	M0_LOG(M0_DEBUG, "phase = %d", m0_fom_phase(fom));
+
+	if (m0_fom_phase(fom) > FS_STARTED)
+		tx = gr_tlist_head(&m->tf_eng->te_group.tg_tx);
+
+	switch (m0_fom_phase(fom)) {
+	case FS_STARTED:
+		m0_fom_phase_set(fom, FS_GROUPED);
+		M0_RETURN(M0_FSO_WAIT);
+	case FS_GROUPED:
+		/* tx_state_set(tx, M0_BTS_GROUPED); */
+		break;
+	case FS_SUBMITTED:
+		break;
+	case FS_PAYLOAD_LOGGED:
+		break;
+	case FS_COMMIT_GROUP_LOGGED:
+		break;
+	case FS_LOG_HEAD_UPDATED:
+		tx_state_set(tx, M0_BTS_SUBMITTED);
+		break;
+	case FS_LOGGED:
+		tx_state_set(tx, M0_BTS_LOGGED);
+		break;
+	case FS_PLACED:
+		tx_state_set(tx, M0_BTS_PLACED);
+		m0_fom_phase_set(fom, FS_STABLE);
+		M0_RETURN(M0_FSO_WAIT);
+	case FS_STABLE:
+		tx_state_set(tx, M0_BTS_STABLE);
+		/* m0_fom_phase_set(fom, M0_FOM_PHASE_FINISH); */
+		M0_RETURN(M0_FSO_WAIT);
+	case FS_FAILED:
+	default:
+		M0_IMPOSSIBLE("Just for now it's not possible..."); /* XXX */
+	}
+
+	m0_fom_phase_set(fom, m0_fom_phase(fom) + 1);
+	M0_RETURN(M0_FSO_AGAIN);
 }
 
 static void tx_fom_fini(struct m0_fom *fom)
@@ -100,7 +172,8 @@ static const struct m0_fom_type_ops tx_fom_type_ops = {
 	.fto_create = NULL
 };
 
-static int tx_fom_create(struct m0_fom **out, struct m0_reqh *reqh)
+static int tx_fom_create(struct m0_fom **out, struct m0_reqh *reqh,
+			 struct m0_be_tx_engine *eng)
 {
 	struct tx_fom *m;
 
@@ -113,10 +186,14 @@ static int tx_fom_create(struct m0_fom **out, struct m0_reqh *reqh)
 		    NULL, NULL, reqh, &m0_txs_stype);
 
 	/* init tx_fom fields */
+	m->tf_eng = eng;
+	eng->te_fom = &m->tf_gen;
+
 	return 0;
 }
 
-M0_INTERNAL int m0_tx_processing_start(struct m0_reqh *reqh)
+M0_INTERNAL int m0_tx_processing_start(struct m0_reqh *reqh,
+				       struct m0_be_tx_engine *eng)
 {
 	struct m0_fom *fom;
 	int            rc;
@@ -124,9 +201,9 @@ M0_INTERNAL int m0_tx_processing_start(struct m0_reqh *reqh)
         M0_PRE(m0_reqh_state_get(reqh) == M0_REQH_ST_NORMAL);
 
 	m0_fom_type_init(&tx_fom_type, &tx_fom_type_ops,
-			 &m0_txs_stype, &m0_generic_conf);
+			 &m0_txs_stype, &conf);
 
-	rc = tx_fom_create(&fom, reqh);
+	rc = tx_fom_create(&fom, reqh, eng);
 	if (rc != 0)
 		M0_RETURN(rc);
 
diff --git a/be/tx_fom.h b/be/tx_fom.h
index 7b57cda..1e66542 100644
--- a/be/tx_fom.h
+++ b/be/tx_fom.h
@@ -23,11 +23,14 @@
 #ifndef __MERO_BE_TX_FOM_H__
 #define __MERO_BE_TX_FOM_H__
 
+struct m0_be_tx_engine;
+
 /**
  * @defgroup be
  * @{
  */
-M0_INTERNAL int m0_tx_processing_start(struct m0_reqh *reqh);
+M0_INTERNAL int m0_tx_processing_start(struct m0_reqh *reqh,
+				       struct m0_be_tx_engine *eng);
 M0_INTERNAL void m0_tx_processing_stop(void);
 
 /** @} end of be group */
diff --git a/be/ut/btree.c b/be/ut/btree.c
index d640cb6..95bd7b4 100644
--- a/be/ut/btree.c
+++ b/be/ut/btree.c
@@ -106,7 +106,7 @@ void test_create(void)
 	M0_UT_ASSERT(M0_IN(m0_be_op_state(&op), (M0_BOS_SUCCESS,
 						 M0_BOS_FAILURE)));
 	m0_be_tx_close(&tx);
-	M0_UT_ASSERT(m0_be_tx_timedwait(&tx, M0_TIME_NEVER) == 0);
+	M0_UT_ASSERT(m0_be_tx_timedwait(&tx, M0_BTS_STABLE, M0_TIME_NEVER) == 0);
 }
 
 void test_destroy(void)
@@ -124,7 +124,7 @@ void test_destroy(void)
 	M0_UT_ASSERT(M0_IN(m0_be_op_state(&op), (M0_BOS_SUCCESS,
 						 M0_BOS_FAILURE)));
 	m0_be_tx_close(&tx);
-	M0_UT_ASSERT(m0_be_tx_timedwait(&tx, M0_TIME_NEVER) == 0);
+	M0_UT_ASSERT(m0_be_tx_timedwait(&tx, M0_BTS_STABLE, M0_TIME_NEVER) == 0);
 
 	be_op_fini(&op);
 	be_fini(&be);
@@ -187,7 +187,7 @@ void test_insert(void)
 	}
 
 	m0_be_tx_close(&tx);
-	M0_UT_ASSERT(m0_be_tx_timedwait(&tx, M0_TIME_NEVER) == 0);
+	M0_UT_ASSERT(m0_be_tx_timedwait(&tx, M0_BTS_STABLE, M0_TIME_NEVER) == 0);
 }
 
 void test_update(void)
@@ -233,7 +233,7 @@ void test_update(void)
 	}
 
 	m0_be_tx_close(&tx);
-	M0_UT_ASSERT(m0_be_tx_timedwait(&tx, M0_TIME_NEVER) == 0);
+	M0_UT_ASSERT(m0_be_tx_timedwait(&tx, M0_BTS_STABLE, M0_TIME_NEVER) == 0);
 }
 
 void test_delete(void)
@@ -260,7 +260,7 @@ void test_delete(void)
 	}
 
 	m0_be_tx_close(&tx);
-	M0_UT_ASSERT(m0_be_tx_timedwait(&tx, M0_TIME_NEVER) == 0);
+	M0_UT_ASSERT(m0_be_tx_timedwait(&tx, M0_BTS_STABLE, M0_TIME_NEVER) == 0);
 }
 
 void test_lookup(void)
@@ -286,7 +286,7 @@ void test_lookup(void)
 	M0_UT_ASSERT(val.b_addr != NULL);
 
 	m0_be_tx_close(&tx);
-	M0_UT_ASSERT(m0_be_tx_timedwait(&tx, M0_TIME_NEVER) == 0);
+	M0_UT_ASSERT(m0_be_tx_timedwait(&tx, M0_BTS_STABLE, M0_TIME_NEVER) == 0);
 }
 
 const struct m0_test_suite be_list_ut = {
diff --git a/be/ut/tx.c b/be/ut/tx.c
index 9f35053..6aa84a7 100644
--- a/be/ut/tx.c
+++ b/be/ut/tx.c
@@ -17,6 +17,9 @@
  * Original creation date: 12-Jun-2013
  */
 
+#undef M0_TRACE_SUBSYSTEM
+#define M0_TRACE_SUBSYSTEM M0_TRACE_SUBSYS_BE
+#include "lib/trace.h"
 #include "ut/ut.h"
 #include "be/be.h"
 #include "be/tx.h"
@@ -82,12 +85,7 @@ static void be_fini(struct m0_be *be)
 	m0_be_tx_engine_fini(&be->b_tx);
 }
 
-int m0_be_tx_timedwait(struct m0_be_tx *tx, m0_time_t timeout)
-{ /*XXX: fixes comilation errors*/
-	return -1;
-}
-
-M0_UNUSED static void test_tx(void)
+static void test_tx(void)
 {
 	struct m0_be_op         op;
 	struct m0_be_tx         tx;
@@ -95,7 +93,9 @@ M0_UNUSED static void test_tx(void)
 	struct m0_be_seg       *seg   = &be_ut_btree_seg;
 	struct m0_be_allocator *alloc = &seg->bs_allocator;
 	struct m0_uint128      *p;
+	int 			rc;
 
+	M0_ENTRY();
 	/*
 	 * Init BE, BE IO, credits
 	 */
@@ -109,11 +109,15 @@ M0_UNUSED static void test_tx(void)
 	m0_be_tx_init(&tx, tid++, &be, &grp, persistent, discarded, NULL);
 	m0_be_allocator_credit(alloc, M0_BAO_ALLOC, sizeof *p, 0, &cred);
 	m0_be_tx_prep(&tx, &cred);
+	M0_LOG(M0_DEBUG, "prepared");
 
 	/*
 	 * Open tx, allocate, dirty and capture region
 	 */
 	m0_be_tx_open(&tx);
+	rc = m0_be_tx_timedwait(&tx, M0_BITS(M0_BTS_ACTIVE), M0_TIME_NEVER);
+	M0_UT_ASSERT(rc == 0);
+	M0_LOG(M0_DEBUG, "opened");
 
 	p = m0_be_alloc(&seg->bs_allocator, &tx, &op, sizeof *p, 0);
 	M0_UT_ASSERT(M0_IN(m0_be_op_state(&op), (M0_BOS_SUCCESS, M0_BOS_FAILURE)));
@@ -122,20 +126,27 @@ M0_UNUSED static void test_tx(void)
 	p->u_hi = 0xDEADD00D8BADF00D;
 	p->u_lo = 0x5CA1AB1E7E1ECA57;
 	M0_BE_TX_CAPTURE_PTR(seg, &tx, p);
+	M0_LOG(M0_DEBUG, "captured");
 
 	/*
 	 * Make things persistent
 	 */
 	m0_be_tx_close(&tx);
-	M0_UT_ASSERT(m0_be_tx_timedwait(&tx, M0_TIME_NEVER) == 0);
+	rc = m0_be_tx_timedwait(&tx, M0_BITS(M0_BTS_PLACED), M0_TIME_NEVER);
+	M0_UT_ASSERT(rc == 0);
+	M0_LOG(M0_DEBUG, "closed");
 
 	/*
 	 * Cleanup
 	 */
 	m0_be_op_fini(&op);
 	be_fini(&be);
+
+	M0_LEAVE();
 }
 
+#include <unistd.h>
+
 static void test_txs(void)
 {
 #define NAME(ext) "be-tx-ut" ext
@@ -166,9 +177,11 @@ static void test_txs(void)
 	reqh = m0_mero_to_rmach(&txs.rsx_mero_ctx)->rm_reqh;
 	M0_UT_ASSERT(reqh != NULL);
 
-	rc = m0_tx_processing_start(reqh);
+	rc = m0_tx_processing_start(reqh, &be.b_tx);
 	M0_UT_ASSERT(rc == 0);
 
+	sleep(2);
+
 	test_tx();
 
 	m0_tx_processing_stop();
@@ -185,3 +198,4 @@ const struct m0_test_suite be_tx_ut = {
 		{ NULL, NULL }
 	}
 };
+#undef M0_TRACE_SUBSYSTEM
-- 
1.8.3.2

