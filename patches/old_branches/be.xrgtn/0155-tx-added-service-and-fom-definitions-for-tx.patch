From 6f9a40268e99125d65fbe0ed8bd833f33e4d2874 Mon Sep 17 00:00:00 2001
From: Anatoliy Bilenko <anatoliy_bilenko@xyratex.com>
Date: Mon, 17 Jun 2013 09:04:17 +0300
Subject: [PATCH 155/228] tx: added service and fom definitions for tx.

---
 be/Makefile.sub |  20 +++++---
 be/tx_fom.c     | 135 ++++++++++++++++++++++++++++++++++++++++++++++++++
 be/tx_fom.h     |  49 ++++++++++++++++++
 be/tx_service.c | 151 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 be/tx_service.h |  58 ++++++++++++++++++++++
 be/ut/tx.c      |  54 +++++++++++++++++---
 mero/init.c     |   2 +
 utils/ut_main.c |   2 +
 8 files changed, 457 insertions(+), 14 deletions(-)
 create mode 100644 be/tx_fom.c
 create mode 100644 be/tx_fom.h
 create mode 100644 be/tx_service.c
 create mode 100644 be/tx_service.h

diff --git a/be/Makefile.sub b/be/Makefile.sub
index b2a1dee..9d8b782 100644
--- a/be/Makefile.sub
+++ b/be/Makefile.sub
@@ -1,12 +1,18 @@
 # XXX TODO FIXME extmap compiling disabled by max because of compilation errors
-nobase_mero_include_HEADERS += be/alloc.h be/list.h be/seg.h
+nobase_mero_include_HEADERS += be/alloc.h	\
+			       be/list.h	\
+			       be/seg.h 	\
+			       be/tx_service.h  \
+			       be/tx_fom.h
 # be/extmap.h \
 # be/extmap_internal.h
 
-mero_libmero_la_SOURCES += be/alloc.c   \
-                           be/list.c    \
-                           be/seg.c     \
-                           be/be.c      \
-                           be/btree.c   \
-                           be/tx.c      \
+mero_libmero_la_SOURCES += be/alloc.c   	\
+                           be/list.c    	\
+                           be/seg.c     	\
+                           be/be.c      	\
+                           be/btree.c   	\
+                           be/tx.c      	\
+                           be/tx_service.c	\
+			   be/tx_fom.c		\
                            #be/extmap.c
diff --git a/be/tx_fom.c b/be/tx_fom.c
new file mode 100644
index 0000000..3aef1f1
--- /dev/null
+++ b/be/tx_fom.c
@@ -0,0 +1,135 @@
+/* -*- C -*- */
+/*
+ * COPYRIGHT 2013 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: Anatoliy Bilenko <anatoliy_bilenko@xyratex.com>
+ * Original creation date: 17-Jun-2013
+ */
+
+#undef M0_TRACE_SUBSYSTEM
+#define M0_TRACE_SUBSYSTEM M0_TRACE_SUBSYS_BE
+#include "lib/trace.h"
+#include "lib/cdefs.h" /* M0_UNUSED */
+#include "lib/errno.h"
+#include "lib/memory.h"
+#include "fop/fom.h"
+#include "fop/fom_generic.h"
+#include "be/tx_service.h"
+
+/**
+ * @addtogroup be
+ * @{
+ */
+
+struct tx_fom {
+	/** Generic m0_fom object. */
+	struct m0_fom            tf_gen;
+
+	/** other stuff */
+};
+
+static int tx_fom_tick(struct m0_fom *fom)
+{
+	M0_UNUSED struct tx_fom *m = container_of(fom, struct tx_fom, tf_gen);
+
+	if (m0_fom_phase(fom) < M0_FOPH_NR)
+		return m0_fom_tick_generic(fom);
+
+	return M0_FSO_AGAIN;
+}
+
+static void tx_fom_fini(struct m0_fom *fom)
+{
+	struct tx_fom *m = container_of(fom, struct tx_fom, tf_gen);
+
+	m0_free(m);
+}
+
+static size_t tx_fom_home_locality(const struct m0_fom *fom)
+{
+	static size_t locality = 0; /* XXX: has locality be fixed? */
+
+	M0_PRE(fom != NULL);
+	return locality;
+}
+
+static void tx_fom_addb_init(struct m0_fom *fom, struct m0_addb_mc *mc)
+{
+	fom->fo_addb_ctx.ac_magic = M0_ADDB_CTX_MAGIC;
+}
+
+static const struct m0_fom_ops tx_fom_ops = {
+	.fo_fini          = tx_fom_fini,
+	.fo_tick          = tx_fom_tick,
+	.fo_home_locality = tx_fom_home_locality,
+	.fo_addb_init     = tx_fom_addb_init
+};
+
+static struct m0_fom_type tx_fom_type;
+
+static const struct m0_fom_type_ops tx_fom_type_ops = {
+	.fto_create = NULL
+};
+
+static int tx_fom_create(struct m0_fom **out, struct m0_reqh *reqh)
+{
+	struct tx_fom *m;
+
+	M0_ALLOC_PTR(m);
+	if (m == NULL)
+		return -ENOMEM;
+
+	*out = &m->tf_gen;
+	m0_fom_init(*out, &tx_fom_type, &tx_fom_ops,
+		    NULL, NULL, reqh, &m0_txs_stype);
+
+	/* init tx_fom fields */
+	return 0;
+}
+
+M0_INTERNAL int m0_tx_processing_start(struct m0_reqh *reqh)
+{
+	struct m0_fom *fom;
+	int            rc;
+
+	rc = tx_fom_create(&fom, reqh);
+	if (rc != 0)
+		return rc;
+
+	/* m0_rwlock_read_lock(&reqh->rh_rwlock); */
+        /* M0_PRE(m0_reqh_state_get(reqh) == M0_REQH_ST_NORMAL); */
+	/* m0_fom_queue(fom, reqh); */
+	/* m0_rwlock_read_unlock(&reqh->rh_rwlock); */
+	return -1;
+}
+
+M0_INTERNAL void m0_tx_processing_stop(/*XXX*/)
+{
+}
+
+#undef M0_TRACE_SUBSYSTEM
+/** @} end of be group */
+/*
+ *  Local variables:
+ *  c-indentation-style: "K&R"
+ *  c-basic-offset: 8
+ *  tab-width: 8
+ *  fill-column: 80
+ *  scroll-step: 1
+ *  End:
+ */
+/*
+ * vim: tabstop=8 shiftwidth=8 noexpandtab textwidth=80 nowrap
+ */
diff --git a/be/tx_fom.h b/be/tx_fom.h
new file mode 100644
index 0000000..adc42d3
--- /dev/null
+++ b/be/tx_fom.h
@@ -0,0 +1,49 @@
+/* -*- C -*- */
+/*
+ * COPYRIGHT 2013 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: Anatoliy Bilenko <anatoliy_bilenko@xyratex.com>
+ * Original creation date: 17-Jun-2013
+ */
+
+#pragma once
+
+#ifndef __MERO_BE_TX_FOM_H__
+#define __MERO_BE_TX_FOM_H__
+
+/**
+ * @defgroup be
+ * @{
+ */
+M0_INTERNAL int m0_tx_processing_start(struct m0_reqh *reqh);
+M0_INTERNAL void m0_tx_processing_stop(/*XXX*/);
+
+/** @} end of be group */
+
+#endif /* __MERO_BE_TX_FOM_H__ */
+
+
+/*
+ *  Local variables:
+ *  c-indentation-style: "K&R"
+ *  c-basic-offset: 8
+ *  tab-width: 8
+ *  fill-column: 80
+ *  scroll-step: 1
+ *  End:
+ */
+/*
+ * vim: tabstop=8 shiftwidth=8 noexpandtab textwidth=80 nowrap
+ */
diff --git a/be/tx_service.c b/be/tx_service.c
new file mode 100644
index 0000000..7b7496b
--- /dev/null
+++ b/be/tx_service.c
@@ -0,0 +1,151 @@
+/* -*- C -*- */
+/*
+ * COPYRIGHT 2013 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: Anatoliy Bilenko <anatoliy_bilenko@xyratex.com>
+ * Original creation date: 17-Jun-2013
+ */
+
+#undef M0_TRACE_SUBSYSTEM
+#define M0_TRACE_SUBSYSTEM M0_TRACE_SUBSYS_BE
+#define M0_ADDB_CT_CREATE_DEFINITION
+#include "lib/trace.h"
+#include "lib/errno.h"
+#include "addb/addb.h"
+#include "lib/memory.h"
+#include "be/tx_service.h"
+
+/**
+ * @addtogroup be
+ * @{
+ */
+
+/* ------------------------------------------------------------------
+ * ADDB helpers
+ * ------------------------------------------------------------------ */
+enum {
+	M0_ADDB_CTXID_TX_SERVICE = 1700
+};
+
+M0_ADDB_CT(m0_addb_ct_tx_service, M0_ADDB_CTXID_TX_SERVICE, "hi", "low");
+
+static void _addb_init(void)
+{
+	/* static struct m0_addb_ctx tx_service_mod_ctx; */
+	m0_addb_ctx_type_register(&m0_addb_ct_tx_service);
+	/* M0_ADDB_CTX_INIT(&m0_addb_gmc, &tx_service_mod_ctx, */
+	/* 		 &m0_addb_ct_tx_service, */
+	/* 		 &m0_addb_proc_ctx); */
+}
+
+static void _addb_fini(void)
+{
+        /* m0_addb_ctx_fini(&tx_service_mod_ctx); */
+}
+
+/* ------------------------------------------------------------------
+ * TX service
+ * ------------------------------------------------------------------ */
+
+static int txs_allocate(struct m0_reqh_service **out,
+			struct m0_reqh_service_type *stype,
+			struct m0_reqh_context *rctx);
+
+static const struct m0_reqh_service_type_ops txs_stype_ops = {
+	.rsto_service_allocate = txs_allocate
+};
+
+M0_REQH_SERVICE_TYPE_DEFINE(m0_txs_stype, &txs_stype_ops, "tx-service",
+                            &m0_addb_ct_tx_service);
+
+M0_INTERNAL int m0_txs_register(void)
+{
+	return m0_reqh_service_type_register(&m0_txs_stype);
+}
+
+M0_INTERNAL void m0_txs_unregister(void)
+{
+	m0_reqh_service_type_unregister(&m0_txs_stype);
+}
+
+static int  txs_start(struct m0_reqh_service *service);
+static void txs_stop(struct m0_reqh_service *service);
+static void txs_fini(struct m0_reqh_service *service);
+
+static const struct m0_reqh_service_ops txs_ops = {
+	.rso_start = txs_start,
+	.rso_stop  = txs_stop,
+	.rso_fini  = txs_fini
+};
+
+/** Allocates and initialises transaction service. */
+static int txs_allocate(struct m0_reqh_service **service,
+			  struct m0_reqh_service_type *stype,
+			  struct m0_reqh_context *rctx)
+{
+	struct m0_tx_service *s;
+
+	M0_ENTRY();
+	M0_PRE(stype == &m0_txs_stype);
+
+	M0_ALLOC_PTR(s);
+	if (s == NULL)
+		M0_RETURN(-ENOMEM);
+
+	*service = &s->ts_reqh;
+	(*service)->rs_ops = &txs_ops;
+	_addb_init();
+
+	M0_RETURN(0);
+}
+
+/** Finalises and deallocates transaction service. */
+static void txs_fini(struct m0_reqh_service *service)
+{
+	struct m0_tx_service *s = container_of(service, struct m0_tx_service,
+					       ts_reqh);
+
+	M0_ENTRY();
+	_addb_fini();
+	m0_free(s);
+	M0_LEAVE();
+}
+
+static int txs_start(struct m0_reqh_service *service)
+{
+	M0_ENTRY();
+	M0_RETURN(0);
+}
+
+static void txs_stop(struct m0_reqh_service *service)
+{
+	M0_ENTRY();
+	M0_LEAVE();
+}
+#undef M0_ADDB_CT_CREATE_DEFINITION
+#undef M0_TRACE_SUBSYSTEM
+/** @} end of be group */
+/*
+ *  Local variables:
+ *  c-indentation-style: "K&R"
+ *  c-basic-offset: 8
+ *  tab-width: 8
+ *  fill-column: 80
+ *  scroll-step: 1
+ *  End:
+ */
+/*
+ * vim: tabstop=8 shiftwidth=8 noexpandtab textwidth=80 nowrap
+ */
diff --git a/be/tx_service.h b/be/tx_service.h
new file mode 100644
index 0000000..9aabbdc
--- /dev/null
+++ b/be/tx_service.h
@@ -0,0 +1,58 @@
+/* -*- C -*- */
+/*
+ * COPYRIGHT 2013 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: Anatoliy Bilenko <anatoliy_bilenko@xyratex.com>
+ * Original creation date: 17-Jun-2013
+ */
+#pragma once
+#ifndef __MERO_BE_TX_SERVICE_H__
+#define __MERO_BE_TX_SERVICE_H__
+
+#include "reqh/reqh_service.h"
+
+/**
+ * @defgroup be
+ * @{
+ */
+
+extern struct m0_reqh_service_type m0_txs_stype;
+
+/** Transaction service */
+struct m0_tx_service {
+	/** Generic service. */
+	struct m0_reqh_service ts_reqh;
+};
+
+M0_INTERNAL int m0_txs_register(void);
+M0_INTERNAL void m0_txs_unregister(void);
+
+
+/** @} end of be group */
+
+#endif /* __MERO_BE_TX_SERVICE_H__ */
+
+/*
+ *  Local variables:
+ *  c-indentation-style: "K&R"
+ *  c-basic-offset: 8
+ *  tab-width: 8
+ *  fill-column: 80
+ *  scroll-step: 1
+ *  End:
+ */
+/*
+ * vim: tabstop=8 shiftwidth=8 noexpandtab textwidth=80 nowrap
+ */
diff --git a/be/ut/tx.c b/be/ut/tx.c
index ad62ea0..ef969bf 100644
--- a/be/ut/tx.c
+++ b/be/ut/tx.c
@@ -23,6 +23,7 @@
 #include "be/seg.h"
 #include "be/alloc.h"
 #include "lib/misc.h"
+#include "rpc/rpclib.h"
 #include "be/ut/helper.h"
 
 static struct m0_be_ut_seg_helper be_ut_btree_seg_helper;
@@ -31,16 +32,16 @@ static struct m0_be_seg		  be_ut_btree_seg;
 static struct m0_be		  be;
 static uint64_t			  tid = 1ULL;
 
-static void seg_create(void)
+M0_UNUSED static void seg_create(void)
 {
 	m0_be_ut_seg_create_open(&be_ut_btree_seg_helper, &be_ut_btree_seg);
 	m0_sm_group_init(&grp);
 }
 
-static void seg_destroy(void)
+M0_UNUSED static void seg_destroy(void)
 {
-	m0_be_ut_seg_close_destroy(&be_ut_btree_seg_helper, &be_ut_btree_seg);
 	m0_sm_group_fini(&grp);
+	m0_be_ut_seg_close_destroy(&be_ut_btree_seg_helper, &be_ut_btree_seg);
 }
 
 static void persistent(const struct m0_be_tx *tx)
@@ -66,7 +67,12 @@ static void be_fini(struct m0_be *be)
 {/* XXX */
 }
 
-void test_tx(void)
+int m0_be_tx_timedwait(struct m0_be_tx *tx, m0_time_t timeout)
+{ /*XXX: fixes comilation errors*/
+	return -1;
+}
+
+M0_UNUSED static void test_tx(void)
 {
 	struct m0_be_op         op;
 	struct m0_be_tx         tx;
@@ -115,14 +121,48 @@ void test_tx(void)
 	be_fini(&be);
 }
 
+static void test_txs(void)
+{
+#define NAME(ext) "be-tx-ut" ext
+#define SERVER_ENDPOINT "lnet:0@lo:12345:34:1"
+	int                      rc;
+	char                    *argv[] = {
+		NAME(""), "-r", "-p", "-T", "AD", "-D", NAME(".db"),
+		"-S", NAME(".stob"), "-A", NAME("-addb.stob"), "-w", "10",
+		"-e", SERVER_ENDPOINT, "-s", "tx-service",
+	};
+	static struct m0_net_xprt *g_xprt = &m0_net_lnet_xprt;
+	struct m0_rpc_server_ctx txs = {
+		.rsx_xprts            = &g_xprt,
+		.rsx_xprts_nr         = 1,
+		.rsx_argv             = argv,
+		.rsx_argc             = ARRAY_SIZE(argv),
+		.rsx_service_types    = NULL,
+		.rsx_service_types_nr = 0,
+		.rsx_log_file_name    = NAME(".log")
+	};
+	struct m0_reqh          *reqh;
+#undef SERVER_ENDPOINT
+#undef NAME
+
+	rc = m0_rpc_server_start(&txs);
+	M0_UT_ASSERT(rc == 0);
+
+	reqh = m0_mero_to_rmach(&txs.rsx_mero_ctx)->rm_reqh;
+	M0_UT_ASSERT(reqh != NULL);
+
+	m0_rpc_server_stop(&txs);
+}
+
 const struct m0_test_suite be_tx_ut = {
 	.ts_name = "be-tx-ut",
 	.ts_tests = {
-		{ "tx: segment create", seg_create },
+		/* { "tx: segment create", seg_create }, */
 
-		{ "tx: run", test_tx  },
+		/* { "tx: run", test_tx  }, */
+		{ "txs: run", test_txs },
 
-		{ "tx: segment destroy", seg_destroy },
+		/* { "tx: segment destroy", seg_destroy }, */
 		{ NULL, NULL }
 	}
 };
diff --git a/mero/init.c b/mero/init.c
index 2518f23..5da6c6c 100644
--- a/mero/init.c
+++ b/mero/init.c
@@ -54,6 +54,7 @@
 #  include "mero/linux_kernel/dummy_init_fini.h"
 #  include "net/test/initfini.h"	/* m0_net_test_init */
 #else
+#  include "be/tx_service.h"    /* m0_txs_register */
 #  include "conf/confd.h"       /* m0_confd_register */
 #  include "conf/addb.h"        /* m0_conf_addb_init */
 #  include "mdstore/mdstore.h"  /* m0_mdstore_mod_init */
@@ -143,6 +144,7 @@ struct init_fini_call subsystem[] = {
 #ifdef __KERNEL__
 	{ &m0t1fs_init,         &m0t1fs_fini,         "m0t1fs" },
 #else
+	{ &m0_txs_register,     &m0_txs_unregister,   "tx-service" },
 	{ &m0_confd_register,   &m0_confd_unregister, "confd" },
 	{ &m0_ios_register,     &m0_ios_unregister,   "ioservice" },
 	{ &m0_mds_register,     &m0_mds_unregister,   "mdservice"},
diff --git a/utils/ut_main.c b/utils/ut_main.c
index fdcc6f3..ae469a0 100644
--- a/utils/ut_main.c
+++ b/utils/ut_main.c
@@ -41,6 +41,7 @@ extern const struct m0_test_suite balloc_ut;
 extern const struct m0_test_suite be_list_ut;
 extern const struct m0_test_suite m0_be_ut;
 extern const struct m0_test_suite be_emap_ut;
+extern const struct m0_test_suite be_tx_ut;
 extern const struct m0_test_suite buffer_pool_ut;
 extern const struct m0_test_suite bulkio_client_ut;
 extern const struct m0_test_suite bulkio_server_ut;
@@ -112,6 +113,7 @@ void add_uts(void)
 	/*
 	m0_ut_add(&be_emap_ut);
 	*/
+	m0_ut_add(&be_tx_ut);
 	m0_ut_add(&buffer_pool_ut);
 	m0_ut_add(&bulkio_client_ut);
 	m0_ut_add(&bulkio_server_ut);
-- 
1.8.3.2

