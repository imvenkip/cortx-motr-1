From 122574ef7c25fb330f1d4449087433bafb6292fa Mon Sep 17 00:00:00 2001
From: Anatoliy Bilenko <anatoliy_bilenko@xyratex.com>
Date: Tue, 4 Jun 2013 14:59:12 +0300
Subject: [PATCH 095/228] be: added btree cursor implementation, added btree
 test placeholder.

---
 be/be.h            |   1 +
 be/btree.c         | 125 +++++++++++++++++++++++++++++++++++++++++++++--------
 be/btree.h         |  19 ++++----
 be/ut/Makefile.sub |   6 ++-
 be/ut/btree.c      |  76 ++++++++++++++++++++++++++++++++
 5 files changed, 199 insertions(+), 28 deletions(-)
 create mode 100644 be/ut/btree.c

diff --git a/be/be.h b/be/be.h
index acf154b..61d67f5 100644
--- a/be/be.h
+++ b/be/be.h
@@ -84,6 +84,7 @@ struct m0_be_op {
 			unsigned int               t_op;
 			const struct m0_buf       *t_in;
 			struct m0_buf             *t_out;
+			struct m0_buf             *t_out2;
 			struct m0_be_btree_anchor *t_anchor;
 		} u_btree;
 	} bo_u;
diff --git a/be/btree.c b/be/btree.c
index 4adf1de..121fc0e 100644
--- a/be/btree.c
+++ b/be/btree.c
@@ -1515,22 +1515,69 @@ M0_INTERNAL void m0_be_btree_cursor_fini(struct m0_be_btree_cursor *cursor)
 M0_INTERNAL void m0_be_btree_cursor_get(struct m0_be_btree_cursor *cur,
 					const struct m0_buf *key)
 {
-	struct node_pos last = get_btree_node(cur->bc_tree, key->b_addr);
+	struct node_pos    last;
+	struct bt_key_val  *kv;
+	struct m0_be_op    *op = &cur->bc_op;
+	struct m0_be_btree *tree = cur->bc_tree;
+
+	M0_PRE(m0_be_op_state(op) == M0_BOS_INIT);
+
+	op->bo_u.u_btree.t_anchor = NULL;
+	op->bo_u.u_btree.t_tree   = cur->bc_tree;
+	op->bo_u.u_btree.t_out    = NULL;
+	op->bo_u.u_btree.t_in     = NULL;
+	op->bo_u.u_btree.t_op     = M0_BBO_CURSOR_GET;
+	op->bo_u.u_btree.t_tx     = NULL;
+	op->bo_utype              = M0_BOP_TREE;
+
+	m0_sm_state_set(&op->bo_sm, M0_BOS_ACTIVE);
+	m0_rwlock_read_lock(&tree->bb_lock);
+
+	/* cursor move */
+	last = get_btree_node(cur->bc_tree, key->b_addr);
 	cur->bc_last_node = last.node;
 	cur->bc_last_pos = last.index;
 
-	if (cur->bc_last_node == NULL) {
-		/* return -ENOENT; */
-	}
+	if (cur->bc_last_node == NULL)
+		goto out;
 
 	cur->bc_pos = cur->bc_last_pos;
 	cur->bc_node = cur->bc_last_node;
-	/* *kv = cur->bc_node->bc_key_vals[cur->bc_pos]; return */
+
+	kv = cur->bc_node->key_vals[cur->bc_pos];
+	/* cursor end move */
+
+	op->bo_u.u_btree.t_out->b_addr = kv->val;
+	op->bo_u.u_btree.t_out->b_nob = cur->bc_tree->bb_ops->ko_dsize(kv->val);
+	op->bo_u.u_btree.t_out2->b_addr = kv->key;
+	op->bo_u.u_btree.t_out2->b_nob = cur->bc_tree->bb_ops->ko_ksize(kv->key);
+
+out:
+	m0_rwlock_read_unlock(&tree->bb_lock);
+	m0_sm_state_set(&op->bo_sm, M0_BOS_SUCCESS);
 }
 
-/* int btree_cur_next(struct btree_cursor *cur, struct bt_key_val **kv) */
 M0_INTERNAL void m0_be_btree_cursor_next(struct m0_be_btree_cursor *cur)
 {
+	struct bt_key_val  *kv;
+	struct m0_be_op    *op   = &cur->bc_op;
+	struct m0_be_btree *tree = cur->bc_tree;
+
+	M0_PRE(m0_be_op_state(op) == M0_BOS_INIT);
+
+	op->bo_u.u_btree.t_anchor = NULL;
+	op->bo_u.u_btree.t_tree   = cur->bc_tree;
+	op->bo_u.u_btree.t_out    = NULL;
+	op->bo_u.u_btree.t_in     = NULL;
+	op->bo_u.u_btree.t_op     = M0_BBO_CURSOR_NEXT;
+	op->bo_u.u_btree.t_tx     = NULL;
+	op->bo_utype              = M0_BOP_TREE;
+
+	m0_sm_state_set(&op->bo_sm, M0_BOS_ACTIVE);
+	m0_rwlock_read_lock(&tree->bb_lock);
+
+
+	/* cursor move */
 	++cur->bc_pos;
 
 	if (cur->bc_pos >= cur->bc_node->nr_active) {
@@ -1539,15 +1586,40 @@ M0_INTERNAL void m0_be_btree_cursor_next(struct m0_be_btree_cursor *cur)
 	}
 
 	if (cur->bc_pos == cur->bc_last_pos &&
-	    cur->bc_node == cur->bc_last_node) {
-		/* return -ENOENT; */
-	}
-
-	/* *kv = cur->bc_node->bc_key_vals[cur->bc_pos]; return */
+	    cur->bc_node == cur->bc_last_node)
+		goto out;
+	/* cursor end move */
+
+	kv = cur->bc_node->key_vals[cur->bc_pos];
+	op->bo_u.u_btree.t_out->b_addr = kv->val;
+	op->bo_u.u_btree.t_out->b_nob = cur->bc_tree->bb_ops->ko_dsize(kv->val);
+	op->bo_u.u_btree.t_out2->b_addr = kv->key;
+	op->bo_u.u_btree.t_out2->b_nob = cur->bc_tree->bb_ops->ko_ksize(kv->key);
+
+out:
+	m0_rwlock_read_unlock(&tree->bb_lock);
+	m0_sm_state_set(&op->bo_sm, M0_BOS_SUCCESS);
 }
 
 M0_INTERNAL void m0_be_btree_cursor_prev(struct m0_be_btree_cursor *cur)
 {
+	struct bt_key_val  *kv;
+	struct m0_be_op    *op   = &cur->bc_op;
+	struct m0_be_btree *tree = cur->bc_tree;
+
+	M0_PRE(m0_be_op_state(op) == M0_BOS_INIT);
+
+	op->bo_u.u_btree.t_anchor = NULL;
+	op->bo_u.u_btree.t_tree   = cur->bc_tree;
+	op->bo_u.u_btree.t_out    = NULL;
+	op->bo_u.u_btree.t_in     = NULL;
+	op->bo_u.u_btree.t_op     = M0_BBO_CURSOR_NEXT;
+	op->bo_u.u_btree.t_tx     = NULL;
+	op->bo_utype              = M0_BOP_TREE;
+
+	m0_sm_state_set(&op->bo_sm, M0_BOS_ACTIVE);
+	m0_rwlock_read_lock(&tree->bb_lock);
+
 	if (cur->bc_pos == 0) {
 		cur->bc_node = cur->bc_node->prev;
 		cur->bc_pos = cur->bc_node->nr_active - 1;
@@ -1555,18 +1627,33 @@ M0_INTERNAL void m0_be_btree_cursor_prev(struct m0_be_btree_cursor *cur)
 		--cur->bc_pos;
 
 	if (cur->bc_pos == cur->bc_last_pos &&
-	    cur->bc_node == cur->bc_last_node) {
-		/* return -ENOENT; */
-	}
+	    cur->bc_node == cur->bc_last_node)
+		goto out;
+
+	kv = cur->bc_node->key_vals[cur->bc_pos];
+	op->bo_u.u_btree.t_out->b_addr = kv->val;
+	op->bo_u.u_btree.t_out->b_nob = cur->bc_tree->bb_ops->ko_dsize(kv->val);
+	op->bo_u.u_btree.t_out2->b_addr = kv->key;
+	op->bo_u.u_btree.t_out2->b_nob = cur->bc_tree->bb_ops->ko_ksize(kv->key);
+out:
+	m0_rwlock_read_unlock(&tree->bb_lock);
+	m0_sm_state_set(&op->bo_sm, M0_BOS_SUCCESS);
+}
+
 
-	/* *kv = cur->bc_node->key_vals[cur->bc_pos]; return */
+M0_INTERNAL void m0_be_btree_cursor_put(struct m0_be_btree_cursor *cursor)
+{
 }
 
+M0_INTERNAL void m0_be_btree_cursor_kv_get(struct m0_be_btree_cursor *cur,
+					   struct m0_buf *key,
+					   struct m0_buf *val)
+{
+	M0_PRE(m0_be_op_state(&cur->bc_op) == M0_BOS_SUCCESS);
 
-/* M0_INTERNAL void m0_be_btree_cursor_put(struct m0_be_btree_cursor *cursor); */
-/* M0_INTERNAL void m0_be_btree_cursor_kv_get(struct m0_be_btree_cursor *cursor, */
-/* 					   struct m0_buf *key, */
-/* 					   struct m0_buf *value); */
+	val = cur->bc_op.bo_u.u_btree.t_out;
+	key = cur->bc_op.bo_u.u_btree.t_out2;
+}
 
 #undef M0_TRACE_SUBSYSTEM
 /** @} end of be group */
diff --git a/be/btree.h b/be/btree.h
index d7e7617..52f771c 100644
--- a/be/btree.h
+++ b/be/btree.h
@@ -57,14 +57,17 @@ struct m0_be_btree {
  * Possible persistent operations over the tree for which credit can be taken
  */
 enum m0_be_btree_op {
-	M0_BBO_CREATE,	/**< credit taken for m0_be_btree_create() */
-	M0_BBO_DESTROY, /**< credit taken for m0_be_btree_destroy() */
-	M0_BBO_INSERT,  /**< credit taken for m0_be_btree_{inplace_|}insert() */
-	M0_BBO_DELETE,  /**< credit taken for m0_be_btree_{inplace_|}delete() */
-	M0_BBO_UPDATE,  /**< credit taken for m0_be_btree_{inplace_|}update() */
-	M0_BBO_LOOKUP,
-	M0_BBO_MAXKEY,
-	M0_BBO_MINKEY,
+	M0_BBO_CREATE,	/**< IO made for m0_be_btree_create() */
+	M0_BBO_DESTROY, /**< IO made for m0_be_btree_destroy() */
+	M0_BBO_INSERT,  /**< IO made for m0_be_btree_{inplace_|}insert() */
+	M0_BBO_DELETE,  /**< IO made for m0_be_btree_{inplace_|}delete() */
+	M0_BBO_UPDATE,  /**< IO made for m0_be_btree_{inplace_|}update() */
+	M0_BBO_LOOKUP,  /**< IO made for m0_be_btree_lookup() */
+	M0_BBO_MAXKEY,  /**< IO made for m0_be_btree_maxkey() */
+	M0_BBO_MINKEY,  /**< IO made for m0_be_btree_minkey() */
+	M0_BBO_CURSOR_GET, /**< IO made for m0_be_btree_cursor_get() */
+	M0_BBO_CURSOR_NEXT, /**< IO made for m0_be_btree_cursor_get() */
+	M0_BBO_CURSOR_PREV, /**< IO made for m0_be_btree_cursor_get() */
 };
 
 /**
diff --git a/be/ut/Makefile.sub b/be/ut/Makefile.sub
index 555969a..6d61644 100644
--- a/be/ut/Makefile.sub
+++ b/be/ut/Makefile.sub
@@ -1 +1,5 @@
-ut_libmero_ut_la_SOURCES += be/ut/alloc.c be/ut/list.c be/ut/main.c be/ut/seg.c
+ut_libmero_ut_la_SOURCES += be/ut/alloc.c  \
+                            be/ut/list.c   \
+                            be/ut/main.c   \
+                            be/ut/seg.c    \
+                            be/ut/btree.c
diff --git a/be/ut/btree.c b/be/ut/btree.c
new file mode 100644
index 0000000..5646f9a
--- /dev/null
+++ b/be/ut/btree.c
@@ -0,0 +1,76 @@
+/*
+ * COPYRIGHT 2013 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: Anatoliy Bilenko <Anatoliy_Bilenko@xyratex.com>
+ * Original creation date: 04-Jun-2013
+ */
+
+#include "ut/ut.h"
+#include "be/btree.h"
+
+int test_init(void)
+{
+	return 0;
+}
+
+int test_fini(void)
+{
+	return 0;
+}
+
+void test_create(void)
+{
+}
+
+void test_insert(void)
+{
+}
+
+void test_update(void)
+{
+}
+
+void test_delete(void)
+{
+}
+
+void test_lookup(void)
+{
+}
+
+void test_iterate(void)
+{
+}
+
+void test_destroy(void)
+{
+}
+
+
+const struct m0_test_suite be_list_ut = {
+	.ts_name = "be-btree-ut",
+	.ts_init = test_init,
+	.ts_fini = test_fini,
+	.ts_tests = {
+		{ "create",  test_create  },
+		{ "insert",  test_insert  },
+		{ "update",  test_update  },
+		{ "delete",  test_delete  },
+		{ "lookup",  test_lookup  },
+		{ "iterate", test_iterate },
+		{ "destroy", test_destroy },
+		{ NULL, NULL }
+	}
+};
-- 
1.8.3.2

