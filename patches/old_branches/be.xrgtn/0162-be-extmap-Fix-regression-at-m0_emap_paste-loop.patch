From 170802981cc26c5baba882fe7210d30f7dc05918 Mon Sep 17 00:00:00 2001
From: Andriy Tkachuk <andriy_tkachuk@xyratex.com>
Date: Tue, 18 Jun 2013 00:25:58 +0300
Subject: [PATCH 162/228] be: extmap: Fix regression at m0_emap_paste() loop

Iterator movement was lost somehow.
---
 be/extmap.c | 80 ++++++++++++++++++++++++++++++++-----------------------------
 be/extmap.h |  2 +-
 2 files changed, 43 insertions(+), 39 deletions(-)

diff --git a/be/extmap.c b/be/extmap.c
index 37ac1c4..66aee9f 100644
--- a/be/extmap.c
+++ b/be/extmap.c
@@ -144,13 +144,12 @@ M0_INTERNAL bool m0_be_emap_ext_is_first(const struct m0_ext *ext)
 	return ext->e_start == 0;
 }
 
-static void emap_it_pack(struct m0_be_emap_cursor *it,
+static int emap_it_pack(struct m0_be_emap_cursor *it,
 	void (*btree_func)(struct m0_be_btree *btree, struct m0_be_tx *tx,
                                     struct m0_be_op *op,
                                     const struct m0_buf *key,
                                     const struct m0_buf *val),
-			struct m0_be_tx *tx,
-			struct m0_be_op *op)
+			struct m0_be_tx *tx)
 {
 	const struct m0_be_emap_seg *ext = &it->ec_seg;
 	struct m0_be_emap_key       *key = &it->ec_key;
@@ -161,9 +160,10 @@ static void emap_it_pack(struct m0_be_emap_cursor *it,
 	rec->er_start  = ext->ee_ext.e_start;
 	rec->er_value  = ext->ee_val;
 
-	btree_func(&it->ec_map->em_mapping, tx, op, &it->ec_keybuf,
-						    &it->ec_recbuf);
-	M0_ASSERT(m0_be_op_state(op) == M0_BOS_SUCCESS);
+	btree_func(&it->ec_map->em_mapping, tx, &it->ec_op, &it->ec_keybuf,
+							    &it->ec_recbuf);
+	M0_ASSERT(m0_be_op_state(&it->ec_op) == M0_BOS_SUCCESS);
+	return it->ec_op.bo_sm.sm_rc;
 }
 
 static bool emap_it_prefix_ok(const struct m0_be_emap_cursor *it)
@@ -250,16 +250,12 @@ enum move_dir {
 
 static int be_emap_move(struct m0_be_emap_cursor *it, enum move_dir dir)
 {
-	m0_sm_state_set(&it->ec_op.bo_sm, M0_BOS_ACTIVE);
-
 	if (dir == NEXT)
 		m0_be_btree_cursor_next(&it->ec_cursor);
 	else
 		m0_be_btree_cursor_prev(&it->ec_cursor);
 	emap_it_open(it);
 
-	m0_sm_state_set(&it->ec_op.bo_sm, it->ec_op.bo_sm.sm_rc == 0 ?
-					M0_BOS_SUCCESS : M0_BOS_FAILURE);
 	return it->ec_op.bo_sm.sm_rc;
 }
 
@@ -351,7 +347,10 @@ M0_INTERNAL void m0_be_emap_next(struct m0_be_emap_cursor *it)
 	M0_PRE(!m0_be_emap_ext_is_last(&it->ec_seg.ee_ext));
 	M0_INVARIANT_EX(be_emap_invariant(it));
 
+	m0_sm_state_set(&it->ec_op.bo_sm, M0_BOS_ACTIVE);
 	be_emap_next(it);
+	m0_sm_state_set(&it->ec_op.bo_sm, it->ec_op.bo_sm.sm_rc == 0 ?
+					M0_BOS_SUCCESS : M0_BOS_FAILURE);
 }
 
 M0_INTERNAL void m0_be_emap_prev(struct m0_be_emap_cursor *it)
@@ -359,28 +358,35 @@ M0_INTERNAL void m0_be_emap_prev(struct m0_be_emap_cursor *it)
 	M0_PRE(!m0_be_emap_ext_is_first(&it->ec_seg.ee_ext));
 	M0_INVARIANT_EX(be_emap_invariant(it));
 
+	m0_sm_state_set(&it->ec_op.bo_sm, M0_BOS_ACTIVE);
 	be_emap_prev(it);
+	m0_sm_state_set(&it->ec_op.bo_sm, it->ec_op.bo_sm.sm_rc == 0 ?
+					M0_BOS_SUCCESS : M0_BOS_FAILURE);
 }
 
-M0_INTERNAL void m0_be_emap_extent_update(struct m0_be_emap_cursor *it,
-					  struct m0_be_tx          *tx,
-				    const struct m0_be_emap_seg    *es)
+static int emap_extent_update(struct m0_be_emap_cursor *it,
+			      struct m0_be_tx          *tx,
+			const struct m0_be_emap_seg    *es)
 {
-	struct m0_be_op bt_op;
-
 	M0_PRE(it != NULL);
 	M0_PRE(es != NULL);
 	M0_PRE(m0_uint128_eq(&it->ec_seg.ee_pre, &es->ee_pre));
 	M0_PRE(it->ec_seg.ee_ext.e_end == es->ee_ext.e_end);
 
-	m0_sm_state_set(&it->ec_op.bo_sm, M0_BOS_ACTIVE);
-
 	it->ec_seg.ee_ext.e_start = es->ee_ext.e_start;
 	it->ec_seg.ee_val = es->ee_val;
-	emap_it_pack(it, m0_be_btree_update, tx, &bt_op);
+	emap_it_pack(it, m0_be_btree_update, tx);
+	return it->ec_op.bo_sm.sm_rc;
+}
 
-	it->ec_op.bo_sm.sm_rc = bt_op.bo_sm.sm_rc;
-	m0_sm_state_set(&it->ec_op.bo_sm, M0_BOS_SUCCESS);
+M0_INTERNAL void m0_be_emap_extent_update(struct m0_be_emap_cursor *it,
+					  struct m0_be_tx          *tx,
+				    const struct m0_be_emap_seg    *es)
+{
+	m0_sm_state_set(&it->ec_op.bo_sm, M0_BOS_ACTIVE);
+	emap_extent_update(it, tx, es);
+	m0_sm_state_set(&it->ec_op.bo_sm, it->ec_op.bo_sm.sm_rc == 0 ?
+					M0_BOS_SUCCESS : M0_BOS_FAILURE);
 }
 
 M0_INTERNAL void m0_be_emap_merge(struct m0_be_emap_cursor *it,
@@ -402,8 +408,7 @@ M0_INTERNAL void m0_be_emap_merge(struct m0_be_emap_cursor *it,
 
 	if (m0_ext_length(&it->ec_seg.ee_ext) < delta) {
 		it->ec_seg.ee_ext.e_end -= delta;
-		emap_it_pack(it, m0_be_btree_insert, tx, &bt_op);
-		if (bt_op.bo_sm.sm_rc != 0)
+		if (emap_it_pack(it, m0_be_btree_insert, tx) != 0)
 			goto fail;
 	}
 
@@ -415,9 +420,7 @@ M0_INTERNAL void m0_be_emap_merge(struct m0_be_emap_cursor *it,
 		goto fail;
 
 	it->ec_seg.ee_ext.e_start -= delta;
-	m0_be_emap_extent_update(it, tx, &it->ec_seg);
-	M0_ASSERT(m0_be_op_state(&it->ec_op) == M0_BOS_SUCCESS);
-	if (it->ec_op.bo_sm.sm_rc != 0)
+	if (emap_extent_update(it, tx, &it->ec_seg) != 0)
 		goto fail;
 
 	M0_ASSERT_EX(be_emap_invariant(it));
@@ -469,8 +472,7 @@ static void be_emap_split(struct m0_be_emap_cursor *it,
 		it->ec_seg.ee_ext.e_start = scan;
 		it->ec_seg.ee_ext.e_end   = scan + count;
 		it->ec_seg.ee_val         = vec->iv_index[i];
-		emap_it_pack(it, m0_be_btree_insert, tx, &bt_op);
-		if (bt_op.bo_sm.sm_rc != 0)
+		if (emap_it_pack(it, m0_be_btree_insert, tx) != 0)
 			goto fail;
 		scan += count;
 	}
@@ -504,15 +506,15 @@ M0_INTERNAL void m0_be_emap_split(struct m0_be_emap_cursor *it,
 
 M0_INTERNAL void m0_be_emap_paste(struct m0_be_emap_cursor *it,
 				  struct m0_be_tx          *tx,
-			    const struct m0_ext            *ext0,
+				  struct m0_ext            *ext,
 				  uint64_t                  val,
 	void (*del)(struct m0_be_emap_seg*),
 	void (*cut_left)(struct m0_be_emap_seg*, struct m0_ext*, uint64_t),
 	void (*cut_right)(struct m0_be_emap_seg*, struct m0_ext*, uint64_t))
 {
-	struct m0_be_emap_seg    *seg      = &it->ec_seg;
+	struct m0_be_emap_seg *seg      = &it->ec_seg;
 	struct m0_ext         *chunk    = &seg->ee_ext;
-	struct m0_ext          ext      = *ext0;
+	const struct m0_ext    ext0     = *ext;
 	struct m0_ext          clip;
 	m0_bcount_t            length[3];
 	m0_bindex_t            bstart[3] = { 0 };
@@ -526,7 +528,7 @@ M0_INTERNAL void m0_be_emap_paste(struct m0_be_emap_cursor *it,
 		.iv_index = bstart
 	};
 
-	M0_PRE(m0_ext_is_in(chunk, ext.e_start));
+	M0_PRE(m0_ext_is_in(chunk, ext->e_start));
 	M0_INVARIANT_EX(be_emap_invariant(it));
 
 	/*
@@ -545,13 +547,13 @@ M0_INTERNAL void m0_be_emap_paste(struct m0_be_emap_cursor *it,
 	 * time).
 	 */
 
-	for (;;) {
-		m0_ext_intersection(&ext, chunk, &clip);
+	while (!m0_ext_is_empty(ext)) {
+		m0_ext_intersection(ext, chunk, &clip);
 		consumed = m0_ext_length(&clip);
 		M0_ASSERT(consumed > 0);
 
 		length[0] = clip.e_start - chunk->e_start;
-		length[1] = clip.e_end == ext.e_end ? m0_ext_length(ext0) : 0;
+		length[1] = clip.e_end == ext->e_end ? m0_ext_length(&ext0) : 0;
 		length[2] = chunk->e_end - clip.e_end;
 
 		bstart[1] = val;
@@ -569,16 +571,18 @@ M0_INTERNAL void m0_be_emap_paste(struct m0_be_emap_cursor *it,
 			del(seg);
 
 		be_emap_split(it, tx, &vec, length[0] > 0 ? chunk->e_start :
-							     ext0->e_start);
+							      ext0.e_start);
 		if (it->ec_op.bo_sm.sm_rc != 0)
 			break;
 
-		ext.e_start += consumed;
-		M0_ASSERT(ext.e_start <= ext.e_end);
-		if (m0_ext_is_empty(&ext))
+		ext->e_start += consumed;
+		M0_ASSERT(ext->e_start <= ext->e_end);
+		if (m0_ext_is_empty(ext))
 			break;
 
 		M0_ASSERT(!m0_be_emap_ext_is_last(&seg->ee_ext));
+		if (be_emap_next(it) != 0)
+			break;
 	}
 
 	M0_ASSERT_EX(ergo(it->ec_op.bo_sm.sm_rc == 0, be_emap_invariant(it)));
diff --git a/be/extmap.h b/be/extmap.h
index b69f1ad..8deda8f 100644
--- a/be/extmap.h
+++ b/be/extmap.h
@@ -293,7 +293,7 @@ M0_INTERNAL void m0_be_emap_split(struct m0_be_emap_cursor *it,
  */
 M0_INTERNAL void m0_be_emap_paste(struct m0_be_emap_cursor *it,
 				  struct m0_be_tx          *tx,
-			    const struct m0_ext            *ext0,
+				  struct m0_ext            *ext,
 				  uint64_t                  val,
 	void (*del)(struct m0_be_emap_seg*),
 	void (*cut_left)(struct m0_be_emap_seg*, struct m0_ext*, uint64_t),
-- 
1.8.3.2

