From 220eb9f7c192defe2653e50a8e0aedb601802eb4 Mon Sep 17 00:00:00 2001
From: Andriy Tkachuk <andriy_tkachuk@xyratex.com>
Date: Fri, 7 Jun 2013 17:32:33 +0300
Subject: [PATCH 128/228] be: extmap copied to be/, original restored at db/

All Mero code compiles now.
---
 be/Makefile.sub      |   7 +-
 be/extmap.c          | 738 +++++++++++++++++++++++++++++++++++++++++++++++++++
 be/extmap.h          | 370 ++++++++++++++++++++++++++
 be/extmap_internal.h | 126 +++++++++
 db/extmap.c          | 616 ++++++++++++++++++------------------------
 db/extmap.h          | 166 +++++-------
 db/extmap_internal.h |  51 ++--
 7 files changed, 1582 insertions(+), 492 deletions(-)
 create mode 100644 be/extmap.c
 create mode 100644 be/extmap.h
 create mode 100644 be/extmap_internal.h

diff --git a/be/Makefile.sub b/be/Makefile.sub
index 389db64..d4d8c26 100644
--- a/be/Makefile.sub
+++ b/be/Makefile.sub
@@ -1,3 +1,6 @@
-nobase_mero_include_HEADERS += be/alloc.h be/list.h be/seg.h
+nobase_mero_include_HEADERS += be/alloc.h be/list.h be/seg.h \
+                                  be/extmap.h \
+                                  be/extmap_internal.h
 
-mero_libmero_la_SOURCES += be/alloc.c be/list.c be/seg.c be/be.c be/btree.c
+mero_libmero_la_SOURCES += be/alloc.c be/list.c be/seg.c be/be.c be/btree.c \
+                                  be/extmap.c
diff --git a/be/extmap.c b/be/extmap.c
new file mode 100644
index 0000000..5a68f05
--- /dev/null
+++ b/be/extmap.c
@@ -0,0 +1,738 @@
+/*
+ * COPYRIGHT 2013 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: Nikita Danilov <nikita_danilov@xyratex.com>
+ * Original creation date: 08/13/2010
+ */
+
+#include <stdio.h>     /* asprintf */
+#include <stdlib.h>
+#include <string.h>
+
+#include "lib/vec.h"
+#include "lib/errno.h"
+#include "lib/arith.h"   /* M0_3WAY */
+#include "be/extmap.h"
+#include "be/extmap_xc.h"
+
+/**
+   @addtogroup extmap
+
+   <b>Extent map implementation details.</b>
+
+   @see extmap_internal.h
+
+   Few notes:
+
+   @li m0_be_emap_cursor::ec_seg is "external" representation of iteration
+   state. m0_be_emap_cursor::ec_key and m0_be_emap_cursor::ec_rec are "internal";
+
+   @li after internal state has changed it is "opened" by emap_it_open() which
+   updates external stats to match changes;
+
+   @li similarly when external state has changed, it is "packed" into internal
+   one by emap_it_pack().
+
+   @li m0_be_emap_cursor::ec_pair is descriptor of buffers for data-base
+   operations. Buffers are aliased to m0_be_emap_cursor::ec_key and
+   m0_be_emap_cursor::ec_rec by emap_it_init().
+
+   @li be_emap_invariant() checks implementation invariant: an extent map is an
+   collection of segments with non-empty extents forming the partition of the
+   name-space and ordered by their starting offsets. This creates a separate
+   cursor within the same transaction as the cursor it is called against.
+
+   @li A segment ([A, B), V) is stored as a record (A, V) with a key (prefix,
+   B). Note, that the _high_ extent end is used as a key. This way,
+   m0_be_btree_cursor_get() can be used to position a cursor on a segment
+   containing a
+   given offset. Also note, that there is some redundancy in the persistent
+   state: two consecutive segments ([A, B), V) and ([B, C), U) are stored as
+   records (A, V) and (B, U) with keys (prefix, B) and (prefix, C)
+   respectively. B is stored twice. Generally, starting offset of a segment
+   extent can always be deduced from the key of previous segment (and for the
+   first segment it's 0), so some slight economy of storage could be achieved at
+   the expense of increased complexity and occasional extra storage traffic.
+
+   @note be_emap_invariant() is potentially expensive. Consider turning it off
+   conditionally.
+
+   @{
+ */
+
+/*
+static void key_print(const struct m0_be_emap_key *k)
+{
+	printf("%08lx.%08lx:%08lx", k->ek_prefix.u_hi, k->ek_prefix.u_lo,
+	       k->ek_offset);
+}
+*/
+
+static int be_emap_cmp(const void *key0, const void *key1)
+{
+	const struct m0_be_emap_key *a0 = key0;
+	const struct m0_be_emap_key *a1 = key1;
+
+	return m0_uint128_cmp(&a0->ek_prefix, &a1->ek_prefix) ?:
+		M0_3WAY(a0->ek_offset, a1->ek_offset);
+}
+
+static unsigned be_emap_ksize(const void* k)
+{
+	return sizeof(struct m0_be_emap_key);
+}
+
+static unsigned be_emap_dsize(const void* d)
+{
+	return sizeof(struct m0_be_emap_rec);
+}
+
+static const struct m0_be_btree_kv_ops be_emap_ops = {
+        .ko_ksize =   be_emap_ksize,
+        .ko_dsize =   be_emap_dsize,
+        .ko_compare = be_emap_cmp
+};
+
+M0_INTERNAL int m0_be_emap_init(struct m0_be_emap *map, struct m0_be_seg *db,
+			     const char *mapname)
+{
+	int rc;
+	struct m0_be_bnode *root;
+
+	rc = m0_be_seg_dict_lookup(db, mapname, (void**)&root);
+	if (rc != 0) {
+		return rc;
+	}
+
+	map->em_key_buf.b_addr = &map->em_key;
+	map->em_val_buf.b_addr = &map->em_rec;
+	map->em_key_buf.b_nob = sizeof map->em_key;
+	map->em_val_buf.b_nob = sizeof map->em_rec;
+
+	m0_be_btree_init(&map->em_mapping, db, &be_emap_ops, root);
+	return 0;
+}
+
+M0_INTERNAL void m0_be_emap_fini(struct m0_be_emap *map)
+{
+	m0_be_btree_fini(&map->em_mapping);
+}
+
+M0_INTERNAL struct m0_be_emap_seg *m0_be_emap_seg_get(struct m0_be_emap_cursor *it)
+{
+	return &it->ec_seg;
+}
+
+M0_INTERNAL bool m0_be_emap_ext_is_last(const struct m0_ext *ext)
+{
+	return ext->e_end == M0_BCOUNT_MAX;
+}
+
+M0_INTERNAL bool m0_be_emap_ext_is_first(const struct m0_ext *ext)
+{
+	return ext->e_start == 0;
+}
+
+static void emap_it_pack(struct m0_be_emap_cursor *it)
+{
+	const struct m0_be_emap_seg *ext = &it->ec_seg;
+	struct m0_be_emap_key       *key = &it->ec_key;
+	struct m0_be_emap_rec       *rec = &it->ec_rec;
+
+	key->ek_prefix = ext->ee_pre;
+	key->ek_offset = ext->ee_ext.e_end;
+	rec->er_start  = ext->ee_ext.e_start;
+	rec->er_value  = ext->ee_val;
+}
+
+static void emap_it_open(struct m0_be_emap_cursor *it)
+{
+	const struct m0_be_emap_key *key = &it->ec_key;
+	const struct m0_be_emap_rec *rec = &it->ec_rec;
+	struct m0_be_emap_seg       *ext = &it->ec_seg;
+
+	m0_be_btree_cursor_kv_get(&it->ec_cursor, &it->ec_keybuf,
+						  &it->ec_recbuf);
+	ext->ee_pre         = key->ek_prefix;
+	ext->ee_ext.e_start = rec->er_start;
+	ext->ee_ext.e_end   = key->ek_offset;
+	ext->ee_val         = rec->er_value;
+}
+
+static bool emap_it_prefix_ok(const struct m0_be_emap_cursor *it)
+{
+	return m0_uint128_eq(&it->ec_seg.ee_pre, &it->ec_prefix);
+}
+
+static void emap_it_init(struct m0_be_emap *map, struct m0_be_tx *tx,
+		   const struct m0_uint128 *prefix, m0_bindex_t offset,
+		   struct m0_be_emap_cursor *it)
+{
+	it->ec_keybuf.b_addr = &it->ec_key;
+	it->ec_recbuf.b_addr = &it->ec_rec;
+	it->ec_keybuf.b_nob  = sizeof it->ec_key;
+	it->ec_recbuf.b_nob  = sizeof it->ec_rec;
+	it->ec_key.ek_prefix = it->ec_prefix = *prefix;
+	it->ec_key.ek_offset = offset + 1;
+	it->ec_map           = map;
+	m0_be_btree_cursor_init(&it->ec_cursor, &map->em_mapping);
+}
+
+static void be_emap_close(struct m0_be_emap_cursor *it)
+{
+	m0_be_btree_cursor_fini(&it->ec_cursor);
+}
+
+M0_INTERNAL struct m0_be_op *m0_be_emap_be_op_get(struct m0_be_emap_cursor *it)
+{
+	return &it->ec_cursor.bc_op;
+}
+
+static void be_emap_lookup(struct m0_be_emap *map, struct m0_be_tx *tx,
+		       const struct m0_uint128 *prefix, m0_bindex_t offset,
+		       struct m0_be_emap_cursor *it)
+{
+	int result;
+
+	emap_it_init(map, tx, prefix, offset, it);
+	m0_be_btree_cursor_get(&it->ec_cursor, &it->ec_keybuf, true);
+	result = m0_be_emap_be_op_get(it)->bo_sm.sm_rc;
+	if (result != 0) {
+		be_emap_close(it);
+		return;
+	}
+	emap_it_open(it);
+	if (!emap_it_prefix_ok(it))
+		result = m0_be_emap_be_op_get(it)->bo_sm.sm_rc = -ESRCH;
+
+	M0_POST(ergo(result == 0, m0_ext_is_in(&it->ec_seg.ee_ext, offset)));
+}
+
+static void be_emap_next(struct m0_be_emap_cursor *it)
+{
+	m0_be_btree_cursor_next(&it->ec_cursor);
+	emap_it_open(it);
+	if (!emap_it_prefix_ok(it))
+		m0_be_emap_be_op_get(it)->bo_sm.sm_rc = -ESRCH;
+}
+
+static void be_emap_prev(struct m0_be_emap_cursor *it)
+{
+	m0_be_btree_cursor_prev(&it->ec_cursor);
+	emap_it_open(it);
+	if (!emap_it_prefix_ok(it))
+		m0_be_emap_be_op_get(it)->bo_sm.sm_rc = -ESRCH;
+}
+
+#if 0
+static bool be_emap_invariant_check(struct m0_be_emap_cursor *it)
+{
+	int                   result;
+	m0_bindex_t           reached;
+	m0_bcount_t           total;
+
+	reached = 0;
+	total   = 0;
+	if (!m0_be_emap_ext_is_first(&it->ec_seg.ee_ext))
+		return false;
+	while (1) {
+		if (it->ec_seg.ee_ext.e_start != reached)
+			return false;
+		if (it->ec_seg.ee_ext.e_end <= reached)
+			return false;
+		reached = it->ec_seg.ee_ext.e_end;
+		total += m0_ext_length(&it->ec_seg.ee_ext);
+		if (m0_be_emap_ext_is_last(&it->ec_seg.ee_ext))
+			break;
+		result = be_emap_next(it);
+		if (result != 0)
+			return true;
+	}
+	if (total != M0_BCOUNT_MAX)
+		return false;
+	if (reached != M0_BINDEX_MAX + 1)
+		return false;
+	return true;
+}
+
+static bool be_emap_invariant(struct m0_be_emap_cursor *it)
+{
+	struct m0_be_emap_cursor scan;
+	int                   result;
+	bool                  check;
+
+	result = be_emap_lookup(it->ec_map, it->ec_cursor.c_tx,
+			     &it->ec_key.ek_prefix, 0, &scan);
+	if (result == 0) {
+		check = be_emap_invariant_check(&scan);
+		be_emap_close(&scan);
+	} else
+		check = true;
+	return check;
+}
+
+#else
+
+static bool be_emap_invariant(struct m0_be_emap_cursor *it)
+{
+	return true;
+}
+#endif
+
+M0_INTERNAL void m0_be_emap_lookup(struct m0_be_emap        *map,
+				struct m0_be_tx       *tx,
+			  const struct m0_uint128     *prefix,
+				m0_bindex_t            offset,
+				struct m0_be_emap_cursor *it)
+{
+	M0_PRE(offset <= M0_BINDEX_MAX);
+
+	be_emap_lookup(map, tx, prefix, offset, it);
+	M0_ASSERT_EX(be_emap_invariant(it));
+}
+
+M0_INTERNAL void m0_be_emap_close(struct m0_be_emap_cursor *it)
+{
+	M0_INVARIANT_EX(be_emap_invariant(it));
+	be_emap_close(it);
+}
+
+M0_INTERNAL void m0_be_emap_next(struct m0_be_emap_cursor *it)
+{
+	M0_PRE(!m0_be_emap_ext_is_last(&it->ec_seg.ee_ext));
+	M0_INVARIANT_EX(be_emap_invariant(it));
+
+	be_emap_next(it);
+}
+
+M0_INTERNAL void m0_be_emap_prev(struct m0_be_emap_cursor *it)
+{
+	M0_PRE(!m0_be_emap_ext_is_first(&it->ec_seg.ee_ext));
+	M0_INVARIANT_EX(be_emap_invariant(it));
+
+	be_emap_prev(it);
+}
+
+M0_INTERNAL void m0_be_emap_extent_update(struct m0_be_emap_cursor *it,
+				       struct m0_be_tx       *tx,
+				       struct m0_be_op       *op,
+				 const struct m0_be_emap_seg    *es)
+{
+	struct m0_be_op bt_op;
+
+	M0_PRE(it != NULL);
+	M0_PRE(es != NULL);
+	M0_PRE(m0_uint128_eq(&it->ec_seg.ee_pre, &es->ee_pre));
+	M0_PRE(it->ec_seg.ee_ext.e_end == es->ee_ext.e_end);
+
+	m0_sm_state_set(&op->bo_sm, M0_BOS_ACTIVE);
+
+	it->ec_seg.ee_ext.e_start = es->ee_ext.e_start;
+	it->ec_seg.ee_val = es->ee_val;
+	emap_it_pack(it);
+	m0_be_btree_update(&it->ec_map->em_mapping, tx, &bt_op, &it->ec_keybuf,
+								&it->ec_recbuf);
+	M0_ASSERT(m0_be_op_state(&bt_op) == M0_BOS_SUCCESS);
+
+	op->bo_sm.sm_rc = bt_op.bo_sm.sm_rc;
+	m0_sm_state_set(&op->bo_sm, M0_BOS_SUCCESS);
+}
+
+M0_INTERNAL void m0_be_emap_merge(struct m0_be_emap_cursor *it,
+			       struct m0_be_tx       *tx,
+			       struct m0_be_op       *op,
+			       m0_bindex_t            delta)
+{
+	struct m0_be_op  bt_op;
+	struct m0_be_op *bt_it_op = m0_be_emap_be_op_get(it);
+
+	M0_PRE(!m0_be_emap_ext_is_last(&it->ec_seg.ee_ext));
+	M0_PRE(delta <= m0_ext_length(&it->ec_seg.ee_ext));
+	M0_INVARIANT_EX(be_emap_invariant(it));
+
+	m0_sm_state_set(&op->bo_sm, M0_BOS_ACTIVE);
+
+	m0_be_btree_delete(&it->ec_map->em_mapping, tx, &bt_op, &it->ec_keybuf);
+	M0_ASSERT(m0_be_op_state(&bt_op) == M0_BOS_SUCCESS);
+	if (bt_op.bo_sm.sm_rc != 0)
+		goto fail;
+
+	if (m0_ext_length(&it->ec_seg.ee_ext) < delta) {
+		it->ec_seg.ee_ext.e_end -= delta;
+		emap_it_pack(it);
+		m0_be_btree_insert(&it->ec_map->em_mapping, tx, &bt_op,
+							&it->ec_keybuf,
+							&it->ec_recbuf);
+		M0_ASSERT(m0_be_op_state(&bt_op) == M0_BOS_SUCCESS);
+		if (bt_op.bo_sm.sm_rc != 0)
+			goto fail;
+	}
+
+	/* Re-initialize cursor. */
+	m0_be_btree_cursor_get(&it->ec_cursor, &it->ec_keybuf, true);
+	M0_ASSERT(m0_be_op_state(bt_it_op) == M0_BOS_SUCCESS);
+	if (bt_it_op->bo_sm.sm_rc != 0)
+		goto fail;
+	emap_it_open(it);
+	if (!emap_it_prefix_ok(it)) {
+		op->bo_sm.sm_rc = -ESRCH;
+		goto fail;
+	}
+
+	be_emap_next(it);
+	M0_ASSERT(m0_be_op_state(bt_it_op) == M0_BOS_SUCCESS);
+	if (bt_it_op->bo_sm.sm_rc != 0)
+		goto fail;
+
+	it->ec_seg.ee_ext.e_start -= delta;
+	m0_be_emap_extent_update(it, tx, &bt_op, &it->ec_seg);
+	M0_ASSERT(m0_be_op_state(&bt_op) == M0_BOS_SUCCESS);
+	if (bt_op.bo_sm.sm_rc != 0)
+		goto fail;
+
+	M0_ASSERT_EX(be_emap_invariant(it));
+
+	m0_sm_state_set(&op->bo_sm, M0_BOS_SUCCESS);
+	return;
+
+fail:
+	m0_sm_state_set(&op->bo_sm, M0_BOS_FAILURE);
+	if (op->bo_sm.sm_rc == 0)
+		op->bo_sm.sm_rc = bt_op.bo_sm.sm_rc ?:
+				  bt_it_op->bo_sm.sm_rc;
+}
+
+static void be_emap_split(struct m0_be_emap_cursor *it,
+		       struct m0_be_tx       *tx,
+		       struct m0_be_op       *op,
+		       struct m0_indexvec    *vec, m0_bindex_t scan)
+{
+	uint32_t      i;
+	m0_bcount_t   count;
+	struct m0_be_emap_key save_key;
+	struct m0_buf      save_key_buf = {
+		.b_addr = &save_key,
+		.b_nob  = sizeof save_key
+	};
+	struct m0_be_op  bt_op;
+	struct m0_be_op *bt_it_op = m0_be_emap_be_op_get(it);
+
+	m0_sm_state_set(&op->bo_sm, M0_BOS_ACTIVE);
+
+	m0_be_btree_delete(&it->ec_map->em_mapping, tx, &bt_op, &it->ec_keybuf);
+	M0_ASSERT(m0_be_op_state(&bt_op) == M0_BOS_SUCCESS);
+	if (bt_op.bo_sm.sm_rc != 0)
+		goto fail;
+	/*
+	 * Now, by the same key just deleted cursor is moved
+	 * to the next segment.
+	 */
+	m0_be_btree_cursor_get(&it->ec_cursor, &it->ec_keybuf, true);
+	M0_ASSERT(m0_be_op_state(bt_it_op) == M0_BOS_SUCCESS);
+	if (bt_it_op->bo_sm.sm_rc != 0)
+		goto fail;
+	emap_it_open(it);
+	if (!emap_it_prefix_ok(it)) {
+		op->bo_sm.sm_rc = -ESRCH;
+		goto fail;
+	}
+
+	/* btree_insert below will invalidate the cursor. */
+	if (vec->iv_vec.v_nr > 0)
+		save_key = it->ec_key;
+
+	for (i = 0; i < vec->iv_vec.v_nr; ++i) {
+		count = vec->iv_vec.v_count[i];
+		if (count == 0)
+			continue;
+		it->ec_seg.ee_ext.e_start = scan;
+		it->ec_seg.ee_ext.e_end   = scan + count;
+		it->ec_seg.ee_val         = vec->iv_index[i];
+		emap_it_pack(it);
+		m0_be_btree_insert(&it->ec_map->em_mapping, tx, &bt_op,
+							&it->ec_keybuf,
+							&it->ec_recbuf);
+		M0_ASSERT(m0_be_op_state(&bt_op) == M0_BOS_SUCCESS);
+		if (bt_op.bo_sm.sm_rc != 0)
+			goto fail;
+		scan += count;
+	}
+
+	if (vec->iv_vec.v_nr > 0) {
+		/* Re-initialize cursor */
+		m0_be_btree_cursor_get(&it->ec_cursor, &save_key_buf, true);
+		M0_ASSERT(m0_be_op_state(bt_it_op) == M0_BOS_SUCCESS);
+		if (bt_it_op->bo_sm.sm_rc != 0)
+			goto fail;
+		emap_it_open(it);
+	}
+
+	m0_sm_state_set(&op->bo_sm, M0_BOS_SUCCESS);
+	return;
+
+fail:
+	m0_sm_state_set(&op->bo_sm, M0_BOS_FAILURE);
+	if (op->bo_sm.sm_rc == 0)
+		op->bo_sm.sm_rc = bt_op.bo_sm.sm_rc ?:
+				  bt_it_op->bo_sm.sm_rc;
+}
+
+M0_INTERNAL void m0_be_emap_split(struct m0_be_emap_cursor *it,
+			       struct m0_be_tx       *tx,
+			       struct m0_be_op       *op,
+			       struct m0_indexvec    *vec)
+{
+	M0_PRE(m0_vec_count(&vec->iv_vec) == m0_ext_length(&it->ec_seg.ee_ext));
+	M0_INVARIANT_EX(be_emap_invariant(it));
+
+	be_emap_split(it, tx, op, vec, it->ec_seg.ee_ext.e_start);
+	M0_ASSERT_EX(be_emap_invariant(it));
+}
+
+M0_INTERNAL void m0_be_emap_paste(struct m0_be_emap_cursor *it,
+			       struct m0_be_tx       *tx,
+			       struct m0_be_op       *op,
+			 const struct m0_ext         *ext0,
+			       uint64_t               val,
+	void (*del)(struct m0_be_emap_seg*),
+	void (*cut_left)(struct m0_be_emap_seg*, struct m0_ext*, uint64_t),
+	void (*cut_right)(struct m0_be_emap_seg*, struct m0_ext*, uint64_t))
+{
+	struct m0_be_emap_seg    *seg      = &it->ec_seg;
+	struct m0_ext         *chunk    = &seg->ee_ext;
+	struct m0_ext          ext      = *ext0;
+	struct m0_ext          clip;
+	m0_bcount_t            length[3];
+	m0_bindex_t            bstart[3] = { 0 };
+	m0_bcount_t            consumed;
+	uint64_t               val_orig;
+	struct m0_indexvec     vec = {
+		.iv_vec = {
+			.v_nr    = ARRAY_SIZE(length),
+			.v_count = length
+		},
+		.iv_index = bstart
+	};
+
+	M0_PRE(m0_ext_is_in(chunk, ext.e_start));
+	M0_INVARIANT_EX(be_emap_invariant(it));
+
+	/*
+	 * Iterate over existing segments overlapping with the new one,
+	 * calculating for each, what parts have to be deleted and what remains.
+	 *
+	 * In the worst case, an existing segment can split into three
+	 * parts. Generally, some of these parts can be empty.
+	 *
+	 * Cutting and deleting segments is handled uniformly by
+	 * be_emap_split(), thanks to the latter skipping empty segments.
+	 *
+	 * Note that the _whole_ new segment is inserted on the last iteration
+	 * of the loop below (see length[1] assignment), thus violating the map
+	 * invariant until the loop exits (the map is "porous" during that
+	 * time).
+	 */
+
+	for (;;) {
+		m0_ext_intersection(&ext, chunk, &clip);
+		consumed = m0_ext_length(&clip);
+		M0_ASSERT(consumed > 0);
+
+		length[0] = clip.e_start - chunk->e_start;
+		length[1] = clip.e_end == ext.e_end ? m0_ext_length(ext0) : 0;
+		length[2] = chunk->e_end - clip.e_end;
+
+		bstart[1] = val;
+		val_orig  = seg->ee_val;
+
+		if (length[0] > 0) {
+			cut_left(seg, &clip, val_orig);
+			bstart[0] = seg->ee_val;
+		}
+		if (length[2] > 0) {
+			cut_right(seg, &clip, val_orig);
+			bstart[2] = seg->ee_val;
+		}
+		if (length[0] == 0 && length[2] == 0)
+			del(seg);
+
+		be_emap_split(it, tx, op, &vec, length[0] > 0 ? chunk->e_start :
+							     ext0->e_start);
+		if (op->bo_sm.sm_rc != 0)
+			break;
+
+		ext.e_start += consumed;
+		M0_ASSERT(ext.e_start <= ext.e_end);
+		if (m0_ext_is_empty(&ext))
+			break;
+
+		M0_ASSERT(!m0_be_emap_ext_is_last(&seg->ee_ext));
+	}
+
+	M0_ASSERT_EX(ergo(op->bo_sm.sm_rc == 0, be_emap_invariant(it)));
+
+	/*
+	 * A tale of two keys.
+	 *
+	 * Primordial version of this function inserted the whole new extent (as
+	 * specified by @ext) at the first iteration of the loop. From time to
+	 * time the (clip.e_start == ext->e_start) assertion got violated for no
+	 * apparent reason. Eventually, after a lot of tracing (by Anatoliy),
+	 * the following sequence was tracked down:
+	 *
+	 * - on entry to m0_be_emap_paste():
+	 *
+	 *   map: *[0, 512) [512, 1024) [1024, 2048) [2048, ...)
+	 *   ext:   [0, 1024)
+	 *
+	 *   (where current cursor position is starred).
+	 *
+	 * - at the end of the first iteration, instead of expected
+	 *
+	 *   map: [0, 1024) *[512, 1024) [1024, 2048) [2048, ...)
+	 *
+	 *   the map was
+	 *
+	 *   map: [0, 1024) *[1024, 2048) [2048, ...)
+	 *
+	 * - that is, the call to be_emap_split():
+	 *
+	 *   - deleted [0, 512) (as expected),
+	 *   - inserted [0, 1024) (as expected),
+	 *   - deleted [512, 1024) ?!
+	 *
+	 * The later is seemingly impossible, because the call deletes exactly
+	 * one segment. The surprising explanation is that segment ([L, H), V)
+	 * is stored as a record (L, V) with H as a key (this is documented at
+	 * the top of this file) and the [0, 1024) segment has the same key as
+	 * already existing [512, 1024) one, with the former forever masking the
+	 * latter.
+	 *
+	 * The solution is to insert the new extent as the last step, but the
+	 * more important moral of this melancholy story is
+	 *
+	 *         Thou shalt wit thine abstraction levels.
+	 *
+	 * In the present case, be_emap_split() operates on the level of
+	 * records and keys which turns out to be subtly different from the
+	 * level of segments and maps.
+	 */
+}
+
+M0_INTERNAL void m0_be_emap_obj_insert(struct m0_be_emap    *map,
+				    struct m0_be_tx   *tx,
+				    struct m0_be_op   *op,
+			      const struct m0_uint128 *prefix,
+				    uint64_t           val)
+{
+	struct m0_be_op bt_op;
+
+	m0_sm_state_set(&op->bo_sm, M0_BOS_ACTIVE);
+
+	map->em_key.ek_prefix = *prefix;
+	map->em_key.ek_offset = M0_BCOUNT_MAX;
+	map->em_rec.er_start = 0;
+	map->em_rec.er_value = val;
+
+	m0_be_btree_insert(&map->em_mapping, tx, &bt_op, &map->em_key_buf,
+						     &map->em_val_buf);
+	M0_ASSERT(m0_be_op_state(&bt_op) == M0_BOS_SUCCESS);
+
+	op->bo_sm.sm_rc = bt_op.bo_sm.sm_rc;
+	m0_sm_state_set(&op->bo_sm, M0_BOS_SUCCESS);
+}
+
+M0_INTERNAL void m0_be_emap_obj_delete(struct m0_be_emap    *map,
+				    struct m0_be_tx   *tx,
+				    struct m0_be_op   *op,
+			      const struct m0_uint128 *prefix)
+{
+	struct m0_be_op bt_op;
+
+	m0_sm_state_set(&op->bo_sm, M0_BOS_ACTIVE);
+
+	map->em_key.ek_prefix = *prefix;
+	map->em_key.ek_offset = 1;
+	m0_be_btree_delete(&map->em_mapping, tx, op, &map->em_key_buf);
+	M0_ASSERT(m0_be_op_state(&bt_op) == M0_BOS_SUCCESS);
+
+	op->bo_sm.sm_rc = bt_op.bo_sm.sm_rc;
+	m0_sm_state_set(&op->bo_sm, M0_BOS_SUCCESS);
+}
+
+static bool m0_be_emap_caret_invariant(const struct m0_be_emap_caret *car)
+{
+	return
+		m0_ext_is_in(&car->ct_it->ec_seg.ee_ext, car->ct_index) ||
+		(m0_be_emap_ext_is_last(&car->ct_it->ec_seg.ee_ext) &&
+		 car->ct_index == M0_BINDEX_MAX + 1);
+}
+
+M0_INTERNAL void m0_be_emap_caret_init(struct m0_be_emap_caret  *car,
+				    struct m0_be_emap_cursor *it,
+				    m0_bindex_t            index)
+{
+	M0_PRE(index <= M0_BINDEX_MAX);
+	M0_PRE(m0_ext_is_in(&it->ec_seg.ee_ext, index));
+	car->ct_it    = it;
+	car->ct_index = index;
+	M0_ASSERT(m0_be_emap_caret_invariant(car));
+}
+
+M0_INTERNAL void m0_be_emap_caret_fini(struct m0_be_emap_caret *car)
+{
+	M0_ASSERT(m0_be_emap_caret_invariant(car));
+}
+
+M0_INTERNAL m0_bcount_t m0_be_emap_caret_step(const struct m0_be_emap_caret *car)
+{
+	M0_ASSERT(m0_be_emap_caret_invariant(car));
+	return car->ct_it->ec_seg.ee_ext.e_end - car->ct_index;
+}
+
+M0_INTERNAL int m0_be_emap_caret_move(struct m0_be_emap_caret *car, m0_bcount_t count)
+{
+	struct m0_be_op *bt_it_op = m0_be_emap_be_op_get(car->ct_it);
+
+	M0_ASSERT(m0_be_emap_caret_invariant(car));
+	while (count > 0 && car->ct_index < M0_BINDEX_MAX + 1) {
+		m0_bcount_t step;
+
+		step = m0_be_emap_caret_step(car);
+		if (count >= step) {
+			m0_be_emap_next(car->ct_it);
+			M0_ASSERT(m0_be_op_state(bt_it_op) == M0_BOS_SUCCESS);
+			if (bt_it_op->bo_sm.sm_rc < 0)
+				return bt_it_op->bo_sm.sm_rc;
+		} else
+			step = count;
+		car->ct_index += step;
+		count -= step;
+	}
+	M0_ASSERT(m0_be_emap_caret_invariant(car));
+	return car->ct_index == M0_BINDEX_MAX + 1;
+}
+
+/** @} end group extmap */
+
+/*
+ *  Local variables:
+ *  c-indentation-style: "K&R"
+ *  c-basic-offset: 8
+ *  tab-width: 8
+ *  fill-column: 80
+ *  scroll-step: 1
+ *  End:
+ */
diff --git a/be/extmap.h b/be/extmap.h
new file mode 100644
index 0000000..de0b084
--- /dev/null
+++ b/be/extmap.h
@@ -0,0 +1,370 @@
+/* -*- C -*- */
+/*
+ * COPYRIGHT 2013 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: Nikita Danilov <nikita_danilov@xyratex.com>
+ * Original creation date: 08/13/2010
+ */
+
+#pragma once
+
+#ifndef __MERO_BE_EXTMAP_H__
+#define __MERO_BE_EXTMAP_H__
+
+/**
+   @defgroup extmap Extent map abstraction
+
+   Extent map is a persistent transactional collection of extents in an abstract
+   numerical name-space with a numerical value associated to each extent.
+
+   The name-space is a set of all 64-bit unsigned numbers from 0 to
+   M0_BINDEX_MAX. An extent of the name-space consisting of numbers from A
+   (inclusive) to B (exclusive) is denoted [A, B).
+
+   A segment is an extent together with a 64-bit value associated with it,
+   denoted as ([A, B), V).
+
+   An extent map is a collection of segments whose extents are non-empty and
+   form a partition of the name-space.
+
+   That is, an extent map is something like
+
+   @f[
+           ([0, e_0), v_0), ([e_0, e_1), v_1), \ldots,
+	   ([e_n, M0\_BINDEX\_MAX + 1), v_n)
+   @f]
+
+   Note that extents cover the whole name-space from 0 to M0_BINDEX_MAX without
+   holes.
+
+   Possible applications of extent map include:
+
+     - allocation data for a data object. In this case an extent in the
+       name-space is interpreted as an extent in the logical offset space of
+       data object. A value associated with the extent is a starting block of a
+       physical extent allocated to the logical extent. In addition to allocated
+       extents, a map might contain "holes" and "not-allocated" extents, tagged
+       with special otherwise impossible values;
+
+     - various resource identifier distribution maps: file identifiers,
+       container identifiers, layout identifiers, recording state of resource
+       name-spaces: allocated to a certain node, free, etc.
+
+   Extent map interface is based on a notion of map cursor (m0_be_emap_cursor): an
+   object recording a position within a map (i.e., a segment reached by the
+   iteration).
+
+   A cursor can be positioned at the segment including a given point in the
+   name-space (m0_be_emap_lookup()) and moved through the segments (m0_be_emap_next()
+   and m0_be_emap_prev()).
+
+   An extent map can be modified by the following functions:
+
+     - m0_be_emap_split(): split a segment into a collection of segments with given
+       lengths and values, provided that their total length is the same as the
+       length of the original segment;
+
+     - m0_be_emap_merge(): merge part of a segment into the next segment. The
+       current segment is shrunk (or deleted if it would become empty) and the
+       next segment is expanded downward;
+
+     - m0_be_emap_paste() handles more complicated cases.
+
+   It's easy to see that these operations preserve extent map invariant that
+   extents are non-empty and form the name-space partition.
+
+   @note The asymmetry between split and merge interfaces (i.e., the fact that a
+   segment can be split into multiple segments at once, but only two segments
+   can be merged) is because a user usually wants to inspect a segment before
+   merging it with another one. For example, data object truncate goes through
+   the allocation data segments downward until the target offset of
+   reached. Each segment is analyzed, data-blocks are freed is necessary and the
+   segment is merged with the next one.
+
+   @note Currently the length and ordering of prefix and value is fixed by the
+   implementation. Should the need arise, prefixes and values of arbitrary size
+   and ordering could be easily implemented at the expense of dynamic memory
+   allocation during cursor initialization. Prefix comparison function could be
+   supplied as m0_be_emap constructor parameter.
+
+   @{
+ */
+
+#include "lib/ext.h"       /* m0_ext */
+#include "lib/types.h"     /* struct m0_uint128 */
+#include "be/tx.h"
+#include "be/btree.h"
+
+/* import */
+struct m0_be_emap;
+struct m0_be_seg;
+struct m0_be_tx;
+struct m0_indexvec;
+
+/* export */
+struct m0_be_emap_seg;
+struct m0_be_emap_cursor;
+
+/**
+    Create maps collection.
+
+    @param db - data-base environment used for persistency and transactional
+    support.
+
+    @retval -ENOENT mapname is not found in the segment dictionary.
+ */
+M0_INTERNAL int m0_be_emap_init(struct m0_be_emap   *map,
+			     struct m0_be_seg *db,
+		       const char             *mapname);
+
+/** Release the resources associated with the collection. */
+M0_INTERNAL void m0_be_emap_fini(struct m0_be_emap *map);
+
+/**
+   Insert a new map with the given prefix into the collection.
+
+   Initially new map consists of a single extent:
+
+   @f[
+	   ([0, M0\_BINDEX\_MAX + 1), val)
+   @f]
+ */
+M0_INTERNAL void m0_be_emap_obj_insert(struct m0_be_emap    *map,
+				    struct m0_be_tx   *tx,
+				    struct m0_be_op   *op,
+			      const struct m0_uint128 *prefix,
+				    uint64_t           val);
+
+/**
+   Remove a map with the given prefix from the collection.
+
+   @pre the map must be in initial state: consists of a single extent, covering
+   the whole name-space.
+ */
+M0_INTERNAL void m0_be_emap_obj_delete(struct m0_be_emap    *map,
+				    struct m0_be_tx   *tx,
+				    struct m0_be_op   *op,
+			      const struct m0_uint128 *prefix);
+
+/** Extent map segment. */
+struct m0_be_emap_seg {
+	/** Map prefix, identifying the map in its collection. */
+	struct m0_uint128 ee_pre;
+	/** Name-space extent. */
+	struct m0_ext     ee_ext;
+	/** Value associated with the extent. */
+	uint64_t          ee_val;
+};
+
+/** True iff the extent is the last one in a map. */
+M0_INTERNAL bool m0_be_emap_ext_is_last(const struct m0_ext *ext);
+
+/** True iff the extent is the first one in a map. */
+M0_INTERNAL bool m0_be_emap_ext_is_first(const struct m0_ext *ext);
+
+/** Returns an extent at the current cursor position. */
+M0_INTERNAL struct m0_be_emap_seg *m0_be_emap_seg_get(struct m0_be_emap_cursor *it);
+
+/** Returns the back-end operation of emap cursor */
+M0_INTERNAL struct m0_be_op *m0_be_emap_be_op_get(struct m0_be_emap_cursor *it);
+
+/**
+   Initialises extent map cursor to point to the segment containing given
+   offset in a map with a given prefix in a given collection.
+
+   All operations done through this cursor are executed in the context of given
+   transaction.
+
+   Asynchronous operation, get status via m0_be_emap_be_op_get(it)->bo_sm.sm_rc.
+
+   @pre offset <= M0_BINDEX_MAX
+
+   @retval -ESRCH no matching segment is found. The cursor is non-functional,
+   but m0_be_emap_seg_get() contains information about the first segment of the
+   next map (in prefix lexicographical order);
+
+   @retval -ENOENT no matching segment is found and there is no map following
+   requested one.
+ */
+M0_INTERNAL void m0_be_emap_lookup(struct m0_be_emap        *map,
+				struct m0_be_tx       *tx,
+			  const struct m0_uint128     *prefix,
+				m0_bindex_t            offset,
+				struct m0_be_emap_cursor *it);
+
+/**
+   Move cursor to the next segment in its map.
+
+   Asynchronous operation, get status via m0_be_emap_be_op_get(it)->bo_sm.sm_rc.
+
+   @pre !m0_be_emap_ext_is_last(m0_be_emap_seg_get(it))
+ */
+M0_INTERNAL void m0_be_emap_next(struct m0_be_emap_cursor *it);
+
+/**
+   Move cursor to the previous segment in its map.
+
+   Asynchronous operation, get status via m0_be_emap_be_op_get(it)->bo_sm.sm_rc.
+
+   @pre !m0_be_emap_ext_is_first(m0_be_emap_seg_get(it))
+ */
+M0_INTERNAL void m0_be_emap_prev(struct m0_be_emap_cursor *it);
+
+/**
+   Merge a part of the segment the cursor is currently positioned at with the
+   next segment in the map.
+
+   Current segment's extent is shrunk by delta. If this would make it empty, the
+   current segment is deleted. The next segment is expanded by delta downwards.
+
+   Asynchronous operation, get status via m0_be_emap_be_op_get(it)->bo_sm.sm_rc.
+
+   @pre !m0_be_emap_ext_is_last(m0_be_emap_seg_get(it))
+   @pre delta <= m0_ext_length(m0_be_emap_seg_get(it));
+ */
+M0_INTERNAL void m0_be_emap_merge(struct m0_be_emap_cursor *it,
+			       struct m0_be_tx       *tx,
+			       struct m0_be_op       *op,
+			       m0_bindex_t            delta);
+
+/**
+   Split the segment the cursor is current positioned at into a collection of
+   segments given by the vector.
+
+   Iterator is moved to the next segment after original one automatically.
+
+   @param vec - a vector describing the collection of
+   segments. vec->ov_vec.v_count[] array contains lengths of the extents and
+   vec->ov_index[] array contains values associated with the corresponding
+   extents.
+
+   Empty segments from vec are skipped.  On successful completion, the cursor is
+   positioned on the last created segment.
+
+   Asynchronous operation, get status via m0_be_emap_be_op_get(it)->bo_sm.sm_rc.
+
+   @pre m0_vec_count(&vec->ov_vec) == m0_ext_length(m0_be_emap_seg_get(it))
+ */
+M0_INTERNAL void m0_be_emap_split(struct m0_be_emap_cursor *it,
+			       struct m0_be_tx       *tx,
+			       struct m0_be_op       *op,
+			       struct m0_indexvec    *vec);
+
+/**
+   Paste segment (ext, val) into the map, deleting or truncating overlapping
+   segments as necessary.
+
+   Asynchronous operation, get status via m0_be_emap_be_op_get(it)->bo_sm.sm_rc.
+
+   @param del - this call-back is called when an existing segment is completely
+   covered by a new one and has to be deleted. The segment to be deleted is
+   supplied as the call-back argument;
+
+   @param cut_left - this call-back is called when an existing segment has to be
+   cut to give place to a new one and some non-empty left part of the existing
+   segment remains in the map. m0_ext call-back argument is the extent being cut
+   from the existing segment. The last argument is the value associated with the
+   existing segment. The call-back must set seg->ee_val to the new value
+   associated with the remaining left part of the segment;
+
+   @param cut_right - similar to cut_left, this call-back is called when some
+   non-empty right part of an existing segment survives the paste operation.
+
+   @note It is possible that both left and right cut call-backs are called
+   against the same segment (in the case where new segment fits completely into
+   existing one).
+
+   @note Map invariant is temporarily violated during paste operation. No calls
+   against the map should be made from the call-backs or, more generally, from
+   the same transaction, while paste is running.
+
+   @note Call-backs are called in the order of cursor iteration, but this is not
+   a part of official function contract.
+ */
+M0_INTERNAL void m0_be_emap_paste(struct m0_be_emap_cursor *it,
+			       struct m0_be_tx       *tx,
+			       struct m0_be_op       *op,
+			 const struct m0_ext         *ext0,
+			       uint64_t               val,
+	void (*del)(struct m0_be_emap_seg*),
+	void (*cut_left)(struct m0_be_emap_seg*, struct m0_ext*, uint64_t),
+	void (*cut_right)(struct m0_be_emap_seg*, struct m0_ext*, uint64_t));
+
+/**
+   Updates the segment at the current cursor with the given
+   segment having same prefix.
+
+   @pre m0_uint128_eq(&it->ec_seg.ee_pre, &es->ee_pre) == true
+ */
+M0_INTERNAL void m0_be_emap_extent_update(struct m0_be_emap_cursor *it,
+				       struct m0_be_tx       *tx,
+				       struct m0_be_op       *op,
+				 const struct m0_be_emap_seg    *es);
+
+/**
+   Release the resources associated with the cursor.
+ */
+M0_INTERNAL void m0_be_emap_close(struct m0_be_emap_cursor *it);
+
+#include "be/extmap_internal.h"
+
+/**
+    Extent map caret.
+
+    A caret is an iterator with finer granularity than a cursor. A caret is a
+    cursor plus an offset within the segment the cursor is currently over.
+
+    Caret interface is intentionally similar to m0_vec_cursor interface, which
+    see for further references.
+
+    Caret implementation is simplified by segment non-emptiness (as guaranteed
+    by extent map invariant).
+ */
+struct m0_be_emap_caret {
+	struct m0_be_emap_cursor *ct_it;
+	m0_bindex_t            ct_index;
+};
+
+M0_INTERNAL void m0_be_emap_caret_init(struct m0_be_emap_caret  *car,
+				    struct m0_be_emap_cursor *it,
+				    m0_bindex_t            index);
+
+M0_INTERNAL void m0_be_emap_caret_fini(struct m0_be_emap_caret *car);
+
+/**
+   Move the caret.
+
+   Asynchronous operation, get status via m0_be_emap_be_op_get(it)->bo_sm.sm_rc.
+ */
+M0_INTERNAL int m0_be_emap_caret_move(struct m0_be_emap_caret *car,
+				   m0_bcount_t           count);
+
+/** Returns how far is the end of extent. */
+M0_INTERNAL m0_bcount_t m0_be_emap_caret_step(const struct m0_be_emap_caret *car);
+
+/** @} end group extmap */
+
+/* __MERO_BE_EXTMAP_H__ */
+#endif
+
+/*
+ *  Local variables:
+ *  c-indentation-style: "K&R"
+ *  c-basic-offset: 8
+ *  tab-width: 8
+ *  fill-column: 80
+ *  scroll-step: 1
+ *  End:
+ */
diff --git a/be/extmap_internal.h b/be/extmap_internal.h
new file mode 100644
index 0000000..40efb03
--- /dev/null
+++ b/be/extmap_internal.h
@@ -0,0 +1,126 @@
+/* -*- C -*- */
+/*
+ * COPYRIGHT 2013 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: Nikita Danilov <nikita_danilov@xyratex.com>
+ * Original creation date: 08/13/2010
+ */
+
+#pragma once
+
+#ifndef __MERO_BE_EXTMAP_INTERNAL_H__
+#define __MERO_BE_EXTMAP_INTERNAL_H__
+
+/**
+   @addtogroup extmap
+
+   <b>Extent map implementation.</b>
+
+   Extent map collection (m0_be_emap) is a table. 128-bit prefix is used to store
+   multiple extent maps in the same table.
+
+   @{
+ */
+
+#include "lib/types.h"     /* struct m0_uint128 */
+#include "be/btree.h"
+
+/**
+   A key used to identify a particular segment in the map collection.
+ */
+struct m0_be_emap_key {
+	/**
+	    Prefix of the map the segment is part of.
+	 */
+	struct m0_uint128 ek_prefix;
+
+	/**
+	    Last offset of the segment's extent. That is, the key of a segment
+	    ([A, B), V) has B as an offset.
+
+	    This not entirely intuitive decision is forced by the available
+	    range search interfaces of m0_db_cursor: m0_db_cursor_get()
+	    positions the cursor on the least key not less than the key sought
+	    for.
+	 */
+	m0_bindex_t       ek_offset;
+};
+
+/**
+   A record stored in the table for each segment in the map collection.
+
+   @note Note that there is a certain amount of redundancy: for any but the
+   first segment in the map, its starting offset is equal to the last offset of
+   the previous segment and for the first segment, the starting offset is
+   0. Consequently, m0_be_emap_rec::er_start field can be eliminated reducing
+   storage foot-print at the expense of increase in code complexity and
+   possibility of occasional extra IO.
+ */
+struct m0_be_emap_rec {
+	/**
+	   Starting offset of the segment's extent.
+	 */
+	m0_bindex_t   er_start;
+	/**
+	   Value associated with the segment.
+	 */
+	uint64_t      er_value;
+};
+
+/**
+   m0_be_emap stores a collection of related extent maps. Individual maps within a
+   collection are identified by a prefix.
+
+   @see m0_be_emap_obj_insert()
+ */
+struct m0_be_emap {
+	struct m0_be_btree   em_mapping;
+	struct m0_buf        em_key_buf;
+	struct m0_buf        em_val_buf;
+	struct m0_be_emap_key   em_key;
+	struct m0_be_emap_rec   em_rec;
+};
+
+/**
+   Cursor iterating through the extent map.
+ */
+struct m0_be_emap_cursor {
+	/** Map this cursor is iterating through. */
+	struct m0_be_emap           *ec_map;
+	/** Segment currently reached. */
+	struct m0_be_emap_seg        ec_seg;
+	/** Data-base cursor. */
+	struct m0_be_btree_cursor ec_cursor;
+	struct m0_be_emap_key        ec_key;
+	struct m0_be_emap_rec        ec_rec;
+	struct m0_buf             ec_keybuf;
+	struct m0_buf             ec_recbuf;
+	struct m0_uint128         ec_prefix;
+};
+
+/** @} end group extmap */
+
+/* __MERO_BE_EXTMAP_INTERNAL_H__ */
+#endif
+
+/*
+ *  Local variables:
+ *  c-indentation-style: "K&R"
+ *  c-basic-offset: 8
+ *  tab-width: 8
+ *  fill-column: 80
+ *  scroll-step: 1
+ *  End:
+ */
diff --git a/db/extmap.c b/db/extmap.c
index 5f16734..a7565ea 100644
--- a/db/extmap.c
+++ b/db/extmap.c
@@ -1,5 +1,5 @@
 /*
- * COPYRIGHT 2013 XYRATEX TECHNOLOGY LIMITED
+ * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
  *
  * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
  * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
@@ -55,9 +55,8 @@
    cursor within the same transaction as the cursor it is called against.
 
    @li A segment ([A, B), V) is stored as a record (A, V) with a key (prefix,
-   B). Note, that the _high_ extent end is used as a key. This way,
-   m0_be_btree_cursor_get() can be used to position a cursor on a segment
-   containing a
+   B). Note, that the _high_ extent end is used as a key. This way, standard
+   m0_db_cursor_get() can be used to position a cursor on a segment containing a
    given offset. Also note, that there is some redundancy in the persistent
    state: two consecutive segments ([A, B), V) and ([B, C), U) are stored as
    records (A, V) and (B, U) with keys (prefix, B) and (prefix, C)
@@ -80,64 +79,74 @@ static void key_print(const struct m0_emap_key *k)
 }
 */
 
-static int emap_cmp(const void *key0, const void *key1)
+static int emap_cmp(struct m0_table *table,
+		    const void *key0, const void *key1)
 {
 	const struct m0_emap_key *a0 = key0;
 	const struct m0_emap_key *a1 = key1;
 
+/*	static const char compare[] = "<=>";
+
+	key_print(a0);
+	printf(" %c ", compare[(m0_uint128_cmp(&a0->ek_prefix,
+						 &a1->ek_prefix) ?:
+				  M0_3WAY(a0->ek_offset,
+					  a1->ek_offset)) + 1]);
+	key_print(a1);
+	printf("\n"); */
 	return m0_uint128_cmp(&a0->ek_prefix, &a1->ek_prefix) ?:
 		M0_3WAY(a0->ek_offset, a1->ek_offset);
 }
 
-static unsigned emap_ksize(const void* k)
+static const struct m0_table_ops emap_ops = {
+	.to = {
+		[TO_KEY] = {
+			.max_size = sizeof(struct m0_emap_key)
+		},
+		[TO_REC] = {
+			.max_size = sizeof(struct m0_emap_rec)
+		},
+	},
+	.key_cmp = emap_cmp
+};
+
+M0_INTERNAL int m0_emap_init(struct m0_emap *emap, struct m0_dbenv *db,
+			     const char *mapname)
 {
-	return sizeof(struct m0_emap_key);
+	return m0_table_init(&emap->em_mapping, db, mapname, 0, &emap_ops);
 }
 
-static unsigned emap_dsize(const void* d)
+M0_INTERNAL void m0_emap_fini(struct m0_emap *emap)
 {
-	return sizeof(struct m0_emap_rec);
+	m0_table_fini(&emap->em_mapping);
 }
 
-static const struct m0_be_btree_kv_ops emap_ops = {
-        .ko_ksize =   emap_ksize,
-        .ko_dsize =   emap_dsize,
-        .ko_compare = emap_cmp
-};
-
-M0_INTERNAL int m0_emap_init(struct m0_emap *map, struct m0_be_seg *db,
-			     const char *mapname)
+static void emap_pack(const struct m0_emap_seg *ext,
+		      struct m0_emap_key *key, struct m0_emap_rec *rec)
 {
-	int rc;
-	struct m0_be_bnode *root;
-
-	rc = m0_be_seg_dict_lookup(db, mapname, (void**)&root);
-	if (rc != 0) {
-		return rc;
-	}
-
-	map->em_key_buf.b_addr = &map->em_key;
-	map->em_val_buf.b_addr = &map->em_rec;
-	map->em_key_buf.b_nob = sizeof map->em_key;
-	map->em_val_buf.b_nob = sizeof map->em_rec;
-
-	m0_be_btree_init(&map->em_mapping, db, &emap_ops, root);
-	return 0;
+	key->ek_prefix = ext->ee_pre;
+	key->ek_offset = ext->ee_ext.e_end;
+	rec->er_start  = ext->ee_ext.e_start;
+	rec->er_value  = ext->ee_val;
 }
 
-M0_INTERNAL void m0_emap_fini(struct m0_emap *map)
+static void emap_open(const struct m0_emap_key *key,
+		      const struct m0_emap_rec *rec, struct m0_emap_seg *ext)
 {
-	m0_be_btree_fini(&map->em_mapping);
+	ext->ee_pre         = key->ek_prefix;
+	ext->ee_ext.e_start = rec->er_start;
+	ext->ee_ext.e_end   = key->ek_offset;
+	ext->ee_val         = rec->er_value;
 }
 
-M0_INTERNAL struct m0_emap_seg *m0_emap_seg_get(struct m0_emap_cursor *it)
+M0_INTERNAL struct m0_emap_seg *m0_emap_seg_get(struct m0_emap_cursor *iterator)
 {
-	return &it->ec_seg;
+	return &iterator->ec_seg;
 }
 
 M0_INTERNAL bool m0_emap_ext_is_last(const struct m0_ext *ext)
 {
-	return ext->e_end == M0_BCOUNT_MAX;
+	return ext->e_end == M0_BINDEX_MAX + 1;
 }
 
 M0_INTERNAL bool m0_emap_ext_is_first(const struct m0_ext *ext)
@@ -147,28 +156,12 @@ M0_INTERNAL bool m0_emap_ext_is_first(const struct m0_ext *ext)
 
 static void it_pack(struct m0_emap_cursor *it)
 {
-	const struct m0_emap_seg *ext = &it->ec_seg;
-	struct m0_emap_key       *key = &it->ec_key;
-	struct m0_emap_rec       *rec = &it->ec_rec;
-
-	key->ek_prefix = ext->ee_pre;
-	key->ek_offset = ext->ee_ext.e_end;
-	rec->er_start  = ext->ee_ext.e_start;
-	rec->er_value  = ext->ee_val;
+	emap_pack(&it->ec_seg, &it->ec_key, &it->ec_rec);
 }
 
 static void it_open(struct m0_emap_cursor *it)
 {
-	const struct m0_emap_key *key = &it->ec_key;
-	const struct m0_emap_rec *rec = &it->ec_rec;
-	struct m0_emap_seg       *ext = &it->ec_seg;
-
-	m0_be_btree_cursor_kv_get(&it->ec_cursor, &it->ec_keybuf,
-						  &it->ec_recbuf);
-	ext->ee_pre         = key->ek_prefix;
-	ext->ee_ext.e_start = rec->er_start;
-	ext->ee_ext.e_end   = key->ek_offset;
-	ext->ee_val         = rec->er_value;
+	emap_open(&it->ec_key, &it->ec_rec, &it->ec_seg);
 }
 
 static bool it_prefix_ok(const struct m0_emap_cursor *it)
@@ -176,67 +169,69 @@ static bool it_prefix_ok(const struct m0_emap_cursor *it)
 	return m0_uint128_eq(&it->ec_seg.ee_pre, &it->ec_prefix);
 }
 
-static void it_init(struct m0_emap *map, struct m0_be_tx *tx,
+#define IT_DO_OPEN(it, func)					\
+({								\
+	int __result;						\
+	struct m0_emap_cursor *__it = (it);			\
+								\
+	__result = (*(func))(&__it->ec_cursor, &__it->ec_pair);	\
+	if (__result == 0) {					\
+		it_open(__it);					\
+		if (!it_prefix_ok(__it))			\
+			__result = -ESRCH;			\
+	}							\
+	__result;						\
+})
+
+#define IT_DO_PACK(it, func)				\
+({							\
+	struct m0_emap_cursor *__it = (it);		\
+							\
+	it_pack(__it);					\
+	(*(func))(&__it->ec_cursor, &__it->ec_pair);	\
+})
+
+static int it_init(struct m0_emap *emap, struct m0_db_tx *tx,
 		   const struct m0_uint128 *prefix, m0_bindex_t offset,
-		   struct m0_emap_cursor *it)
+		   struct m0_emap_cursor *it, uint32_t flags)
 {
-	it->ec_keybuf.b_addr = &it->ec_key;
-	it->ec_recbuf.b_addr = &it->ec_rec;
-	it->ec_keybuf.b_nob  = sizeof it->ec_key;
-	it->ec_recbuf.b_nob  = sizeof it->ec_rec;
+	m0_db_pair_setup(&it->ec_pair, &emap->em_mapping,
+			 &it->ec_key, sizeof it->ec_key,
+			 &it->ec_rec, sizeof it->ec_rec);
 	it->ec_key.ek_prefix = it->ec_prefix = *prefix;
 	it->ec_key.ek_offset = offset + 1;
-	it->ec_map           = map;
-	m0_be_btree_cursor_init(&it->ec_cursor, &map->em_mapping);
+	it->ec_map           = emap;
+	return m0_db_cursor_init(&it->ec_cursor, &emap->em_mapping, tx, flags);
 }
 
 static void emap_close(struct m0_emap_cursor *it)
 {
-	m0_be_btree_cursor_fini(&it->ec_cursor);
+	m0_db_cursor_fini(&it->ec_cursor);
+	m0_db_pair_fini(&it->ec_pair);
 }
 
-M0_INTERNAL struct m0_be_op *m0_emap_be_op_get(struct m0_emap_cursor *it)
-{
-	return &it->ec_cursor.bc_op;
-}
-
-static void emap_lookup(struct m0_emap *map, struct m0_be_tx *tx,
+static int emap_lookup(struct m0_emap *emap, struct m0_db_tx *tx,
 		       const struct m0_uint128 *prefix, m0_bindex_t offset,
 		       struct m0_emap_cursor *it)
 {
 	int result;
 
-	it_init(map, tx, prefix, offset, it);
-	m0_be_btree_cursor_get(&it->ec_cursor, &it->ec_keybuf, true);
-	result = m0_emap_be_op_get(it)->bo_sm.sm_rc;
-	if (result != 0) {
-		emap_close(it);
-		return;
+	result = it_init(emap, tx, prefix, offset, it, 0);
+	if (result == 0) {
+		result = IT_DO_OPEN(it, &m0_db_cursor_get);
+		if (result != 0)
+			emap_close(it);
 	}
-	it_open(it);
-	if (!it_prefix_ok(it))
-		result = m0_emap_be_op_get(it)->bo_sm.sm_rc = -ESRCH;
-
 	M0_POST(ergo(result == 0, m0_ext_is_in(&it->ec_seg.ee_ext, offset)));
+	return result;
 }
 
-static void emap_next(struct m0_emap_cursor *it)
-{
-	m0_be_btree_cursor_next(&it->ec_cursor);
-	it_open(it);
-	if (!it_prefix_ok(it))
-		m0_emap_be_op_get(it)->bo_sm.sm_rc = -ESRCH;
-}
-
-static void emap_prev(struct m0_emap_cursor *it)
+static int emap_next(struct m0_emap_cursor *it)
 {
-	m0_be_btree_cursor_prev(&it->ec_cursor);
-	it_open(it);
-	if (!it_prefix_ok(it))
-		m0_emap_be_op_get(it)->bo_sm.sm_rc = -ESRCH;
+	return IT_DO_OPEN(it, &m0_db_cursor_next);
 }
 
-#if 0
+#ifdef ENABLE_DEBUG
 static bool emap_invariant_check(struct m0_emap_cursor *it)
 {
 	int                   result;
@@ -283,7 +278,7 @@ static bool emap_invariant(struct m0_emap_cursor *it)
 	return check;
 }
 
-#else
+#else /* !ENABLE_DEBUG */
 
 static bool emap_invariant(struct m0_emap_cursor *it)
 {
@@ -291,242 +286,92 @@ static bool emap_invariant(struct m0_emap_cursor *it)
 }
 #endif
 
-M0_INTERNAL void m0_emap_lookup(struct m0_emap        *map,
-				struct m0_be_tx       *tx,
-			  const struct m0_uint128     *prefix,
-				m0_bindex_t            offset,
-				struct m0_emap_cursor *it)
+int m0_emap_lookup(struct m0_emap *emap, struct m0_db_tx *tx,
+		   const struct m0_uint128 *prefix, m0_bindex_t offset,
+		   struct m0_emap_cursor *it)
 {
-	M0_PRE(offset <= M0_BINDEX_MAX);
+	int result;
 
-	emap_lookup(map, tx, prefix, offset, it);
-	M0_ASSERT_EX(emap_invariant(it));
-}
+	M0_PRE(offset <= M0_BINDEX_MAX);
 
-M0_INTERNAL void m0_emap_close(struct m0_emap_cursor *it)
-{
-	M0_INVARIANT_EX(emap_invariant(it));
-	emap_close(it);
+	result = emap_lookup(emap, tx, prefix, offset, it);
+	M0_ASSERT_EX(ergo(result == 0, emap_invariant(it)));
+	return result;
 }
 
-M0_INTERNAL void m0_emap_next(struct m0_emap_cursor *it)
+M0_INTERNAL int m0_emap_next(struct m0_emap_cursor *it)
 {
 	M0_PRE(!m0_emap_ext_is_last(&it->ec_seg.ee_ext));
 	M0_INVARIANT_EX(emap_invariant(it));
 
-	emap_next(it);
+	return emap_next(it);
 }
 
-M0_INTERNAL void m0_emap_prev(struct m0_emap_cursor *it)
+M0_INTERNAL int m0_emap_prev(struct m0_emap_cursor *it)
 {
 	M0_PRE(!m0_emap_ext_is_first(&it->ec_seg.ee_ext));
 	M0_INVARIANT_EX(emap_invariant(it));
 
-	emap_prev(it);
-}
-
-M0_INTERNAL void m0_emap_extent_update(struct m0_emap_cursor *it,
-				       struct m0_be_tx       *tx,
-				       struct m0_be_op       *op,
-				 const struct m0_emap_seg    *es)
-{
-	struct m0_be_op bt_op;
-
-	M0_PRE(it != NULL);
-	M0_PRE(es != NULL);
-	M0_PRE(m0_uint128_eq(&it->ec_seg.ee_pre, &es->ee_pre));
-	M0_PRE(it->ec_seg.ee_ext.e_end == es->ee_ext.e_end);
-
-	m0_sm_state_set(&op->bo_sm, M0_BOS_ACTIVE);
-
-	it->ec_seg.ee_ext.e_start = es->ee_ext.e_start;
-	it->ec_seg.ee_val = es->ee_val;
-	it_pack(it);
-	m0_be_btree_update(&it->ec_map->em_mapping, tx, &bt_op, &it->ec_keybuf,
-								&it->ec_recbuf);
-	M0_ASSERT(m0_be_op_state(&bt_op) == M0_BOS_SUCCESS);
-
-	op->bo_sm.sm_rc = bt_op.bo_sm.sm_rc;
-	m0_sm_state_set(&op->bo_sm, M0_BOS_SUCCESS);
+	return IT_DO_OPEN(it, &m0_db_cursor_prev);
 }
 
-M0_INTERNAL void m0_emap_merge(struct m0_emap_cursor *it,
-			       struct m0_be_tx       *tx,
-			       struct m0_be_op       *op,
-			       m0_bindex_t            delta)
+M0_INTERNAL void m0_emap_close(struct m0_emap_cursor *it)
 {
-	struct m0_be_op  bt_op;
-	struct m0_be_op *bt_it_op = m0_emap_be_op_get(it);
-
-	M0_PRE(!m0_emap_ext_is_last(&it->ec_seg.ee_ext));
-	M0_PRE(delta <= m0_ext_length(&it->ec_seg.ee_ext));
 	M0_INVARIANT_EX(emap_invariant(it));
-
-	m0_sm_state_set(&op->bo_sm, M0_BOS_ACTIVE);
-
-	m0_be_btree_delete(&it->ec_map->em_mapping, tx, &bt_op, &it->ec_keybuf);
-	M0_ASSERT(m0_be_op_state(&bt_op) == M0_BOS_SUCCESS);
-	if (bt_op.bo_sm.sm_rc != 0)
-		goto fail;
-
-	if (m0_ext_length(&it->ec_seg.ee_ext) < delta) {
-		it->ec_seg.ee_ext.e_end -= delta;
-		it_pack(it);
-		m0_be_btree_insert(&it->ec_map->em_mapping, tx, &bt_op,
-							&it->ec_keybuf,
-							&it->ec_recbuf);
-		M0_ASSERT(m0_be_op_state(&bt_op) == M0_BOS_SUCCESS);
-		if (bt_op.bo_sm.sm_rc != 0)
-			goto fail;
-	}
-
-	/* Re-initialize cursor. */
-	m0_be_btree_cursor_get(&it->ec_cursor, &it->ec_keybuf, true);
-	M0_ASSERT(m0_be_op_state(bt_it_op) == M0_BOS_SUCCESS);
-	if (bt_it_op->bo_sm.sm_rc != 0)
-		goto fail;
-	it_open(it);
-	if (!it_prefix_ok(it)) {
-		op->bo_sm.sm_rc = -ESRCH;
-		goto fail;
-	}
-
-	emap_next(it);
-	M0_ASSERT(m0_be_op_state(bt_it_op) == M0_BOS_SUCCESS);
-	if (bt_it_op->bo_sm.sm_rc != 0)
-		goto fail;
-
-	it->ec_seg.ee_ext.e_start -= delta;
-	m0_emap_extent_update(it, tx, &bt_op, &it->ec_seg);
-	M0_ASSERT(m0_be_op_state(&bt_op) == M0_BOS_SUCCESS);
-	if (bt_op.bo_sm.sm_rc != 0)
-		goto fail;
-
-	M0_ASSERT_EX(emap_invariant(it));
-
-	m0_sm_state_set(&op->bo_sm, M0_BOS_SUCCESS);
-	return;
-
-fail:
-	m0_sm_state_set(&op->bo_sm, M0_BOS_FAILURE);
-	if (op->bo_sm.sm_rc == 0)
-		op->bo_sm.sm_rc = bt_op.bo_sm.sm_rc ?:
-				  bt_it_op->bo_sm.sm_rc;
+	emap_close(it);
 }
 
-static void emap_split(struct m0_emap_cursor *it,
-		       struct m0_be_tx       *tx,
-		       struct m0_be_op       *op,
-		       struct m0_indexvec    *vec, m0_bindex_t scan)
+M0_INTERNAL int emap_split_internal(struct m0_emap_cursor *it,
+				    struct m0_indexvec *vec, m0_bindex_t scan)
 {
-	uint32_t      i;
-	m0_bcount_t   count;
-	struct m0_emap_key save_key;
-	struct m0_buf      save_key_buf = {
-		.b_addr = &save_key,
-		.b_nob  = sizeof save_key
-	};
-	struct m0_be_op  bt_op;
-	struct m0_be_op *bt_it_op = m0_emap_be_op_get(it);
-
-	m0_sm_state_set(&op->bo_sm, M0_BOS_ACTIVE);
-
-	m0_be_btree_delete(&it->ec_map->em_mapping, tx, &bt_op, &it->ec_keybuf);
-	M0_ASSERT(m0_be_op_state(&bt_op) == M0_BOS_SUCCESS);
-	if (bt_op.bo_sm.sm_rc != 0)
-		goto fail;
-	/*
-	 * Now, by the same key just deleted cursor is moved
-	 * to the next segment.
-	 */
-	m0_be_btree_cursor_get(&it->ec_cursor, &it->ec_keybuf, true);
-	M0_ASSERT(m0_be_op_state(bt_it_op) == M0_BOS_SUCCESS);
-	if (bt_it_op->bo_sm.sm_rc != 0)
-		goto fail;
-	it_open(it);
-	if (!it_prefix_ok(it)) {
-		op->bo_sm.sm_rc = -ESRCH;
-		goto fail;
-	}
-
-	/* btree_insert below will invalidate the cursor. */
-	if (vec->iv_vec.v_nr > 0)
-		save_key = it->ec_key;
-
-	for (i = 0; i < vec->iv_vec.v_nr; ++i) {
-		count = vec->iv_vec.v_count[i];
-		if (count == 0)
-			continue;
-		it->ec_seg.ee_ext.e_start = scan;
-		it->ec_seg.ee_ext.e_end   = scan + count;
-		it->ec_seg.ee_val         = vec->iv_index[i];
-		it_pack(it);
-		m0_be_btree_insert(&it->ec_map->em_mapping, tx, &bt_op,
-							&it->ec_keybuf,
-							&it->ec_recbuf);
-		M0_ASSERT(m0_be_op_state(&bt_op) == M0_BOS_SUCCESS);
-		if (bt_op.bo_sm.sm_rc != 0)
-			goto fail;
-		scan += count;
-	}
+	uint32_t    i;
+	int         result;
+	m0_bcount_t count;
 
-	if (vec->iv_vec.v_nr > 0) {
-		/* Re-initialize cursor */
-		m0_be_btree_cursor_get(&it->ec_cursor, &save_key_buf, true);
-		M0_ASSERT(m0_be_op_state(bt_it_op) == M0_BOS_SUCCESS);
-		if (bt_it_op->bo_sm.sm_rc != 0)
-			goto fail;
-		it_open(it);
+	result = m0_db_cursor_del(&it->ec_cursor);
+	if (result == 0) {
+		for (result = 0, i = 0; i < vec->iv_vec.v_nr; ++i) {
+			count = vec->iv_vec.v_count[i];
+			if (count != 0) {
+				it->ec_seg.ee_ext.e_start = scan;
+				it->ec_seg.ee_ext.e_end   = scan = scan + count;
+				it->ec_seg.ee_val         = vec->iv_index[i];
+				result = IT_DO_PACK(it, m0_db_cursor_add);
+				if (result != 0)
+					break;
+			}
+		}
 	}
-
-	m0_sm_state_set(&op->bo_sm, M0_BOS_SUCCESS);
-	return;
-
-fail:
-	m0_sm_state_set(&op->bo_sm, M0_BOS_FAILURE);
-	if (op->bo_sm.sm_rc == 0)
-		op->bo_sm.sm_rc = bt_op.bo_sm.sm_rc ?:
-				  bt_it_op->bo_sm.sm_rc;
+	return result;
 }
 
-M0_INTERNAL void m0_emap_split(struct m0_emap_cursor *it,
-			       struct m0_be_tx       *tx,
-			       struct m0_be_op       *op,
-			       struct m0_indexvec    *vec)
+M0_INTERNAL int m0_emap_split(struct m0_emap_cursor *it,
+			      struct m0_indexvec *vec)
 {
+	int result;
+
 	M0_PRE(m0_vec_count(&vec->iv_vec) == m0_ext_length(&it->ec_seg.ee_ext));
 	M0_INVARIANT_EX(emap_invariant(it));
 
-	emap_split(it, tx, op, vec, it->ec_seg.ee_ext.e_start);
-	M0_ASSERT_EX(emap_invariant(it));
+	result = emap_split_internal(it, vec, it->ec_seg.ee_ext.e_start);
+	M0_ASSERT_EX(ergo(result == 0, emap_invariant(it)));
+	return result;
 }
 
-M0_INTERNAL void m0_emap_paste(struct m0_emap_cursor *it,
-			       struct m0_be_tx       *tx,
-			       struct m0_be_op       *op,
-			 const struct m0_ext         *ext0,
-			       uint64_t               val,
-	void (*del)(struct m0_emap_seg*),
-	void (*cut_left)(struct m0_emap_seg*, struct m0_ext*, uint64_t),
-	void (*cut_right)(struct m0_emap_seg*, struct m0_ext*, uint64_t))
+int m0_emap_paste(struct m0_emap_cursor *it, struct m0_ext *ext, uint64_t val,
+		  void (*del)(struct m0_emap_seg *),
+		  void (*cut_left)(struct m0_emap_seg *, struct m0_ext *,
+				   uint64_t),
+		  void (*cut_right)(struct m0_emap_seg *, struct m0_ext *,
+				    uint64_t))
 {
+	int                    result   = 0;
+	uint64_t               val_orig;
 	struct m0_emap_seg    *seg      = &it->ec_seg;
 	struct m0_ext         *chunk    = &seg->ee_ext;
-	struct m0_ext          ext      = *ext0;
-	struct m0_ext          clip;
-	m0_bcount_t            length[3];
-	m0_bindex_t            bstart[3] = { 0 };
-	m0_bcount_t            consumed;
-	uint64_t               val_orig;
-	struct m0_indexvec     vec = {
-		.iv_vec = {
-			.v_nr    = ARRAY_SIZE(length),
-			.v_count = length
-		},
-		.iv_index = bstart
-	};
+	const struct m0_ext    ext0     = *ext;
 
-	M0_PRE(m0_ext_is_in(chunk, ext.e_start));
+	M0_PRE(m0_ext_is_in(chunk, ext->e_start));
 	M0_INVARIANT_EX(emap_invariant(it));
 
 	/*
@@ -537,7 +382,7 @@ M0_INTERNAL void m0_emap_paste(struct m0_emap_cursor *it,
 	 * parts. Generally, some of these parts can be empty.
 	 *
 	 * Cutting and deleting segments is handled uniformly by
-	 * emap_split(), thanks to the latter skipping empty segments.
+	 * emap_split_internal(), thanks to the latter skipping empty segments.
 	 *
 	 * Note that the _whole_ new segment is inserted on the last iteration
 	 * of the loop below (see length[1] assignment), thus violating the map
@@ -545,18 +390,30 @@ M0_INTERNAL void m0_emap_paste(struct m0_emap_cursor *it,
 	 * time).
 	 */
 
-	for (;;) {
-		m0_ext_intersection(&ext, chunk, &clip);
+	while (!m0_ext_is_empty(ext)) {
+		m0_bcount_t        length[3];
+		m0_bindex_t        bstart[3] = { 0 };
+		m0_bcount_t        consumed;
+		struct m0_ext      clip;
+		struct m0_indexvec vec = {
+			.iv_vec = {
+				.v_nr    = 3,
+				.v_count = length
+			},
+			.iv_index = bstart
+		};
+
+		m0_ext_intersection(ext, chunk, &clip);
+		M0_ASSERT(clip.e_start == ext->e_start);
 		consumed = m0_ext_length(&clip);
 		M0_ASSERT(consumed > 0);
 
 		length[0] = clip.e_start - chunk->e_start;
-		length[1] = clip.e_end == ext.e_end ? m0_ext_length(ext0) : 0;
+		length[1] = clip.e_end == ext->e_end ? m0_ext_length(&ext0) : 0;
 		length[2] = chunk->e_end - clip.e_end;
 
 		bstart[1] = val;
 		val_orig  = seg->ee_val;
-
 		if (length[0] > 0) {
 			cut_left(seg, &clip, val_orig);
 			bstart[0] = seg->ee_val;
@@ -568,20 +425,23 @@ M0_INTERNAL void m0_emap_paste(struct m0_emap_cursor *it,
 		if (length[0] == 0 && length[2] == 0)
 			del(seg);
 
-		emap_split(it, tx, op, &vec, length[0] > 0 ? chunk->e_start :
-							     ext0->e_start);
-		if (op->bo_sm.sm_rc != 0)
+		result = emap_split_internal(it, &vec, length[0] > 0 ?
+					     chunk->e_start : ext0.e_start);
+		if (result != 0)
 			break;
 
-		ext.e_start += consumed;
-		M0_ASSERT(ext.e_start <= ext.e_end);
-		if (m0_ext_is_empty(&ext))
-			break;
+		ext->e_start += consumed;
+		M0_ASSERT(ext->e_start <= ext->e_end);
 
-		M0_ASSERT(!m0_emap_ext_is_last(&seg->ee_ext));
+		if (!m0_ext_is_empty(ext)) {
+			M0_ASSERT(!m0_emap_ext_is_last(&seg->ee_ext));
+			result = emap_next(it);
+			if (result != 0)
+				break;
+		}
 	}
-
-	M0_ASSERT_EX(ergo(op->bo_sm.sm_rc == 0, emap_invariant(it)));
+	M0_ASSERT_EX(ergo(result == 0, emap_invariant(it)));
+	return result;
 
 	/*
 	 * A tale of two keys.
@@ -594,20 +454,20 @@ M0_INTERNAL void m0_emap_paste(struct m0_emap_cursor *it,
 	 *
 	 * - on entry to m0_emap_paste():
 	 *
-	 *   map: *[0, 512) [512, 1024) [1024, 2048) [2048, ...)
+	 *   emap: *[0, 512) [512, 1024) [1024, 2048) [2048, ...)
 	 *   ext:   [0, 1024)
 	 *
 	 *   (where current cursor position is starred).
 	 *
 	 * - at the end of the first iteration, instead of expected
 	 *
-	 *   map: [0, 1024) *[512, 1024) [1024, 2048) [2048, ...)
+	 *   emap: [0, 1024) *[512, 1024) [1024, 2048) [2048, ...)
 	 *
 	 *   the map was
 	 *
-	 *   map: [0, 1024) *[1024, 2048) [2048, ...)
+	 *   emap: [0, 1024) *[1024, 2048) [2048, ...)
 	 *
-	 * - that is, the call to emap_split():
+	 * - that is, the call to emap_split_internal():
 	 *
 	 *   - deleted [0, 512) (as expected),
 	 *   - inserted [0, 1024) (as expected),
@@ -625,51 +485,96 @@ M0_INTERNAL void m0_emap_paste(struct m0_emap_cursor *it,
 	 *
 	 *         Thou shalt wit thine abstraction levels.
 	 *
-	 * In the present case, emap_split() operates on the level of
+	 * In the present case, emap_split_internal() operates on the level of
 	 * records and keys which turns out to be subtly different from the
 	 * level of segments and maps.
 	 */
 }
 
-M0_INTERNAL void m0_emap_obj_insert(struct m0_emap    *map,
-				    struct m0_be_tx   *tx,
-				    struct m0_be_op   *op,
-			      const struct m0_uint128 *prefix,
-				    uint64_t           val)
+M0_INTERNAL int m0_emap_merge(struct m0_emap_cursor *it, m0_bindex_t delta)
 {
-	struct m0_be_op bt_op;
+	int result;
 
-	m0_sm_state_set(&op->bo_sm, M0_BOS_ACTIVE);
+	M0_PRE(!m0_emap_ext_is_last(&it->ec_seg.ee_ext));
+	M0_PRE(delta <= m0_ext_length(&it->ec_seg.ee_ext));
+	M0_INVARIANT_EX(emap_invariant(it));
 
-	map->em_key.ek_prefix = *prefix;
-	map->em_key.ek_offset = M0_BCOUNT_MAX;
-	map->em_rec.er_start = 0;
-	map->em_rec.er_value = val;
+	if (it->ec_seg.ee_ext.e_end == delta) {
+		result = m0_db_cursor_del(&it->ec_cursor);
+	} else {
+		it->ec_seg.ee_ext.e_end -= delta;
+		result = IT_DO_PACK(it, &m0_db_cursor_set);
+	}
+	if (result == 0) {
+		result = emap_next(it);
+		if (result == 0) {
+			it->ec_seg.ee_ext.e_start -= delta;
+			result = IT_DO_PACK(it, &m0_db_cursor_set);
+		}
+	}
+	M0_ASSERT_EX(ergo(result == 0, emap_invariant(it)));
+	return result;
+}
+
+M0_INTERNAL int m0_emap_extent_update(struct m0_emap_cursor *it,
+				      struct m0_emap_seg *es)
+{
+	int result;
+
+	M0_PRE(it != NULL);
+	M0_PRE(es != NULL);
+	M0_PRE(m0_uint128_eq(&it->ec_seg.ee_pre, &es->ee_pre));
+	M0_INVARIANT_EX(emap_invariant(it));
 
-	m0_be_btree_insert(&map->em_mapping, tx, &bt_op, &map->em_key_buf,
-						     &map->em_val_buf);
-	M0_ASSERT(m0_be_op_state(&bt_op) == M0_BOS_SUCCESS);
+	it->ec_seg = (struct m0_emap_seg) {
+		.ee_ext = {
+			.e_start = es->ee_ext.e_start,
+			.e_end   = es->ee_ext.e_end
+		},
+		.ee_val = es->ee_val
+	};
 
-	op->bo_sm.sm_rc = bt_op.bo_sm.sm_rc;
-	m0_sm_state_set(&op->bo_sm, M0_BOS_SUCCESS);
+	result = IT_DO_PACK(it, m0_db_cursor_set);
+	M0_ASSERT_EX(ergo(result == 0, emap_invariant(it)));
+	return result;
 }
 
-M0_INTERNAL void m0_emap_obj_delete(struct m0_emap    *map,
-				    struct m0_be_tx   *tx,
-				    struct m0_be_op   *op,
-			      const struct m0_uint128 *prefix)
+M0_INTERNAL int m0_emap_obj_insert(struct m0_emap *emap, struct m0_db_tx *tx,
+				   const struct m0_uint128 *prefix,
+				   uint64_t val)
 {
-	struct m0_be_op bt_op;
+	struct m0_emap_cursor it;
+	int                   result;
 
-	m0_sm_state_set(&op->bo_sm, M0_BOS_ACTIVE);
+	result = it_init(emap, tx, prefix, 0, &it, M0_DB_CURSOR_RMW);
+	if (result == 0) {
+		it.ec_seg.ee_pre         = *prefix;
+		it.ec_seg.ee_ext.e_start = 0;
+		it.ec_seg.ee_ext.e_end   = M0_BINDEX_MAX + 1;
+		it.ec_seg.ee_val         = val;
+		it_pack(&it);
+		result = m0_table_insert(tx, &it.ec_pair);
+		M0_ASSERT_EX(ergo(result == 0, emap_invariant(&it)));
+		m0_emap_close(&it);
+	}
+	return result;
+}
 
-	map->em_key.ek_prefix = *prefix;
-	map->em_key.ek_offset = 1;
-	m0_be_btree_delete(&map->em_mapping, tx, op, &map->em_key_buf);
-	M0_ASSERT(m0_be_op_state(&bt_op) == M0_BOS_SUCCESS);
+M0_INTERNAL int m0_emap_obj_delete(struct m0_emap *emap, struct m0_db_tx *tx,
+				   const struct m0_uint128 *prefix)
+{
+	struct m0_emap_cursor it;
+	int                   result;
 
-	op->bo_sm.sm_rc = bt_op.bo_sm.sm_rc;
-	m0_sm_state_set(&op->bo_sm, M0_BOS_SUCCESS);
+	result = m0_emap_lookup(emap, tx, prefix, 0, &it);
+	if (result == 0) {
+		M0_ASSERT(m0_emap_ext_is_first(&it.ec_seg.ee_ext) &&
+			  m0_emap_ext_is_last(&it.ec_seg.ee_ext));
+		M0_INVARIANT_EX(emap_invariant(&it));
+		result = m0_db_cursor_del(&it.ec_cursor);
+		m0_emap_close(&it);
+	}
+	return result;
 }
 
 static bool m0_emap_caret_invariant(const struct m0_emap_caret *car)
@@ -680,9 +585,9 @@ static bool m0_emap_caret_invariant(const struct m0_emap_caret *car)
 		 car->ct_index == M0_BINDEX_MAX + 1);
 }
 
-M0_INTERNAL void m0_emap_caret_init(struct m0_emap_caret  *car,
+M0_INTERNAL void m0_emap_caret_init(struct m0_emap_caret *car,
 				    struct m0_emap_cursor *it,
-				    m0_bindex_t            index)
+				    m0_bindex_t index)
 {
 	M0_PRE(index <= M0_BINDEX_MAX);
 	M0_PRE(m0_ext_is_in(&it->ec_seg.ee_ext, index));
@@ -696,15 +601,9 @@ M0_INTERNAL void m0_emap_caret_fini(struct m0_emap_caret *car)
 	M0_ASSERT(m0_emap_caret_invariant(car));
 }
 
-M0_INTERNAL m0_bcount_t m0_emap_caret_step(const struct m0_emap_caret *car)
-{
-	M0_ASSERT(m0_emap_caret_invariant(car));
-	return car->ct_it->ec_seg.ee_ext.e_end - car->ct_index;
-}
-
 M0_INTERNAL int m0_emap_caret_move(struct m0_emap_caret *car, m0_bcount_t count)
 {
-	struct m0_be_op *bt_it_op = m0_emap_be_op_get(car->ct_it);
+	int result;
 
 	M0_ASSERT(m0_emap_caret_invariant(car));
 	while (count > 0 && car->ct_index < M0_BINDEX_MAX + 1) {
@@ -712,10 +611,9 @@ M0_INTERNAL int m0_emap_caret_move(struct m0_emap_caret *car, m0_bcount_t count)
 
 		step = m0_emap_caret_step(car);
 		if (count >= step) {
-			m0_emap_next(car->ct_it);
-			M0_ASSERT(m0_be_op_state(bt_it_op) == M0_BOS_SUCCESS);
-			if (bt_it_op->bo_sm.sm_rc < 0)
-				return bt_it_op->bo_sm.sm_rc;
+			result = m0_emap_next(car->ct_it);
+			if (result < 0)
+				return result;
 		} else
 			step = count;
 		car->ct_index += step;
@@ -725,6 +623,12 @@ M0_INTERNAL int m0_emap_caret_move(struct m0_emap_caret *car, m0_bcount_t count)
 	return car->ct_index == M0_BINDEX_MAX + 1;
 }
 
+M0_INTERNAL m0_bcount_t m0_emap_caret_step(const struct m0_emap_caret *car)
+{
+	M0_ASSERT(m0_emap_caret_invariant(car));
+	return car->ct_it->ec_seg.ee_ext.e_end - car->ct_index;
+}
+
 /** @} end group extmap */
 
 /*
diff --git a/db/extmap.h b/db/extmap.h
index 43c7808..ae13064 100644
--- a/db/extmap.h
+++ b/db/extmap.h
@@ -1,6 +1,6 @@
 /* -*- C -*- */
 /*
- * COPYRIGHT 2013 XYRATEX TECHNOLOGY LIMITED
+ * COPYRIGHT 2012 XYRATEX TECHNOLOGY LIMITED
  *
  * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
  * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
@@ -104,15 +104,14 @@
 
 #include "lib/ext.h"       /* m0_ext */
 #include "lib/types.h"     /* struct m0_uint128 */
-#include "be/tx.h"
-#include "be/btree.h"
+#include "db/db.h"
 #include "lib/ext_xc.h"
 #include "lib/types_xc.h"
 
 /* import */
 struct m0_emap;
-struct m0_be_seg;
-struct m0_be_tx;
+struct m0_dbenv;
+struct m0_db_tx;
 struct m0_indexvec;
 
 /* export */
@@ -124,15 +123,12 @@ struct m0_emap_cursor;
 
     @param db - data-base environment used for persistency and transactional
     support.
-
-    @retval -ENOENT mapname is not found in the segment dictionary.
  */
-M0_INTERNAL int m0_emap_init(struct m0_emap   *map,
-			     struct m0_be_seg *db,
-		       const char             *mapname);
+M0_INTERNAL int m0_emap_init(struct m0_emap *emap,
+			     struct m0_dbenv *db, const char *mapname);
 
 /** Release the resources associated with the collection. */
-M0_INTERNAL void m0_emap_fini(struct m0_emap *map);
+M0_INTERNAL void m0_emap_fini(struct m0_emap *emap);
 
 /**
    Insert a new map with the given prefix into the collection.
@@ -143,11 +139,9 @@ M0_INTERNAL void m0_emap_fini(struct m0_emap *map);
 	   ([0, M0\_BINDEX\_MAX + 1), val)
    @f]
  */
-M0_INTERNAL void m0_emap_obj_insert(struct m0_emap    *map,
-				    struct m0_be_tx   *tx,
-				    struct m0_be_op   *op,
-			      const struct m0_uint128 *prefix,
-				    uint64_t           val);
+M0_INTERNAL int m0_emap_obj_insert(struct m0_emap *emap, struct m0_db_tx *tx,
+				   const struct m0_uint128 *prefix,
+				   uint64_t val);
 
 /**
    Remove a map with the given prefix from the collection.
@@ -155,10 +149,8 @@ M0_INTERNAL void m0_emap_obj_insert(struct m0_emap    *map,
    @pre the map must be in initial state: consists of a single extent, covering
    the whole name-space.
  */
-M0_INTERNAL void m0_emap_obj_delete(struct m0_emap    *map,
-				    struct m0_be_tx   *tx,
-				    struct m0_be_op   *op,
-			      const struct m0_uint128 *prefix);
+M0_INTERNAL int m0_emap_obj_delete(struct m0_emap *emap, struct m0_db_tx *tx,
+				   const struct m0_uint128 *prefix);
 
 /** Extent map segment. */
 struct m0_emap_seg {
@@ -177,76 +169,47 @@ M0_INTERNAL bool m0_emap_ext_is_last(const struct m0_ext *ext);
 M0_INTERNAL bool m0_emap_ext_is_first(const struct m0_ext *ext);
 
 /** Returns an extent at the current cursor position. */
-M0_INTERNAL struct m0_emap_seg *m0_emap_seg_get(struct m0_emap_cursor *it);
-
-/** Returns the back-end operation of emap cursor */
-M0_INTERNAL struct m0_be_op *m0_emap_be_op_get(struct m0_emap_cursor *it);
+M0_INTERNAL struct m0_emap_seg *m0_emap_seg_get(struct m0_emap_cursor
+						*iterator);
 
 /**
-   Initialises extent map cursor to point to the segment containing given
-   offset in a map with a given prefix in a given collection.
+    Initialises extent map cursor to point to the segment containing given
+    offset in a map with a given prefix in a given collection.
 
-   All operations done through this cursor are executed in the context of given
-   transaction.
+    All operations done through this cursor are executed in the context of given
+    transaction.
 
-   Asynchronous operation, get status via m0_emap_be_op_get(it)->bo_sm.sm_rc.
+    @pre offset <= M0_BINDEX_MAX
 
-   @pre offset <= M0_BINDEX_MAX
+    @retval -ESRCH no matching segment is found. The cursor is non-functional,
+    but m0_emap_seg_get() contains information about the first segment of the
+    next map (in prefix lexicographical order);
 
-   @retval -ESRCH no matching segment is found. The cursor is non-functional,
-   but m0_emap_seg_get() contains information about the first segment of the
-   next map (in prefix lexicographical order);
-
-   @retval -ENOENT no matching segment is found and there is no map following
-   requested one.
+    @retval -ENOENT no matching segment is found and there is no map following
+    requested one.
  */
-M0_INTERNAL void m0_emap_lookup(struct m0_emap        *map,
-				struct m0_be_tx       *tx,
-			  const struct m0_uint128     *prefix,
-				m0_bindex_t            offset,
-				struct m0_emap_cursor *it);
+M0_INTERNAL int m0_emap_lookup(struct m0_emap *emap, struct m0_db_tx *tx,
+			       const struct m0_uint128 *prefix,
+			       m0_bindex_t offset, struct m0_emap_cursor *it);
 
 /**
    Move cursor to the next segment in its map.
 
-   Asynchronous operation, get status via m0_emap_be_op_get(it)->bo_sm.sm_rc.
-
-   @pre !m0_emap_ext_is_last(m0_emap_seg_get(it))
+   @pre !m0_emap_ext_is_last(m0_emap_seg_get(iterator))
  */
-M0_INTERNAL void m0_emap_next(struct m0_emap_cursor *it);
+M0_INTERNAL int m0_emap_next(struct m0_emap_cursor *iterator);
 
 /**
    Move cursor to the previous segment in its map.
 
-   Asynchronous operation, get status via m0_emap_be_op_get(it)->bo_sm.sm_rc.
-
-   @pre !m0_emap_ext_is_first(m0_emap_seg_get(it))
- */
-M0_INTERNAL void m0_emap_prev(struct m0_emap_cursor *it);
-
-/**
-   Merge a part of the segment the cursor is currently positioned at with the
-   next segment in the map.
-
-   Current segment's extent is shrunk by delta. If this would make it empty, the
-   current segment is deleted. The next segment is expanded by delta downwards.
-
-   Asynchronous operation, get status via m0_emap_be_op_get(it)->bo_sm.sm_rc.
-
-   @pre !m0_emap_ext_is_last(m0_emap_seg_get(it))
-   @pre delta <= m0_ext_length(m0_emap_seg_get(it));
+   @pre !m0_emap_ext_is_first(m0_emap_seg_get(iterator))
  */
-M0_INTERNAL void m0_emap_merge(struct m0_emap_cursor *it,
-			       struct m0_be_tx       *tx,
-			       struct m0_be_op       *op,
-			       m0_bindex_t            delta);
+M0_INTERNAL int m0_emap_prev(struct m0_emap_cursor *iterator);
 
 /**
    Split the segment the cursor is current positioned at into a collection of
    segments given by the vector.
 
-   Iterator is moved to the next segment after original one automatically.
-
    @param vec - a vector describing the collection of
    segments. vec->ov_vec.v_count[] array contains lengths of the extents and
    vec->ov_index[] array contains values associated with the corresponding
@@ -255,21 +218,15 @@ M0_INTERNAL void m0_emap_merge(struct m0_emap_cursor *it,
    Empty segments from vec are skipped.  On successful completion, the cursor is
    positioned on the last created segment.
 
-   Asynchronous operation, get status via m0_emap_be_op_get(it)->bo_sm.sm_rc.
-
-   @pre m0_vec_count(&vec->ov_vec) == m0_ext_length(m0_emap_seg_get(it))
+   @pre m0_vec_count(&vec->ov_vec) == m0_ext_length(m0_emap_seg_get(iterator))
  */
-M0_INTERNAL void m0_emap_split(struct m0_emap_cursor *it,
-			       struct m0_be_tx       *tx,
-			       struct m0_be_op       *op,
-			       struct m0_indexvec    *vec);
+M0_INTERNAL int m0_emap_split(struct m0_emap_cursor *iterator,
+			      struct m0_indexvec *vec);
 
 /**
    Paste segment (ext, val) into the map, deleting or truncating overlapping
    segments as necessary.
 
-   Asynchronous operation, get status via m0_emap_be_op_get(it)->bo_sm.sm_rc.
-
    @param del - this call-back is called when an existing segment is completely
    covered by a new one and has to be deleted. The segment to be deleted is
    supplied as the call-back argument;
@@ -279,10 +236,10 @@ M0_INTERNAL void m0_emap_split(struct m0_emap_cursor *it,
    segment remains in the map. m0_ext call-back argument is the extent being cut
    from the existing segment. The last argument is the value associated with the
    existing segment. The call-back must set seg->ee_val to the new value
-   associated with the remaining left part of the segment;
+   associated with the remaining left part of the call-back;
 
    @param cut_right - similar to cut_left, this call-back is called when some
-   non-empty right part of an existing segment survives the paste operation.
+   non-empty part of an existing segment survives the paste operation.
 
    @note It is possible that both left and right cut call-backs are called
    against the same segment (in the case where new segment fits completely into
@@ -295,30 +252,39 @@ M0_INTERNAL void m0_emap_split(struct m0_emap_cursor *it,
    @note Call-backs are called in the order of cursor iteration, but this is not
    a part of official function contract.
  */
-M0_INTERNAL void m0_emap_paste(struct m0_emap_cursor *it,
-			       struct m0_be_tx       *tx,
-			       struct m0_be_op       *op,
-			 const struct m0_ext         *ext0,
-			       uint64_t               val,
-	void (*del)(struct m0_emap_seg*),
-	void (*cut_left)(struct m0_emap_seg*, struct m0_ext*, uint64_t),
-	void (*cut_right)(struct m0_emap_seg*, struct m0_ext*, uint64_t));
+int m0_emap_paste(struct m0_emap_cursor *it, struct m0_ext *ext, uint64_t val,
+		  void (*del)(struct m0_emap_seg *),
+		  void (*cut_left)(struct m0_emap_seg *, struct m0_ext *,
+				   uint64_t),
+		  void (*cut_right)(struct m0_emap_seg *, struct m0_ext *,
+				    uint64_t));
+
+/**
+   Merge a part of the segment the cursor is currently positioned at with the
+   next segment in the map.
+
+   Current segment's extent is shrunk by delta. If this would make it empty, the
+   current segment is deleted. The next segment is expanded by delta downwards.
+
+   @pre !m0_emap_ext_is_last(m0_emap_seg_get(iterator))
+   @pre delta <= m0_ext_length(m0_emap_seg_get(iterator));
+ */
+M0_INTERNAL int m0_emap_merge(struct m0_emap_cursor *iterator,
+			      m0_bindex_t delta);
 
 /**
-   Updates the segment at the current cursor with the given
+   Updates the segment the cursor is currently postioned at with the given
    segment having same prefix.
 
    @pre m0_uint128_eq(&it->ec_seg.ee_pre, &es->ee_pre) == true
  */
-M0_INTERNAL void m0_emap_extent_update(struct m0_emap_cursor *it,
-				       struct m0_be_tx       *tx,
-				       struct m0_be_op       *op,
-				 const struct m0_emap_seg    *es);
+M0_INTERNAL int m0_emap_extent_update(struct m0_emap_cursor *it,
+				      struct m0_emap_seg *es);
 
 /**
    Release the resources associated with the cursor.
  */
-M0_INTERNAL void m0_emap_close(struct m0_emap_cursor *it);
+M0_INTERNAL void m0_emap_close(struct m0_emap_cursor *iterator);
 
 #include "db/extmap_internal.h"
 
@@ -339,21 +305,13 @@ struct m0_emap_caret {
 	m0_bindex_t            ct_index;
 };
 
-M0_INTERNAL void m0_emap_caret_init(struct m0_emap_caret  *car,
+M0_INTERNAL void m0_emap_caret_init(struct m0_emap_caret *car,
 				    struct m0_emap_cursor *it,
-				    m0_bindex_t            index);
-
+				    m0_bindex_t index);
 M0_INTERNAL void m0_emap_caret_fini(struct m0_emap_caret *car);
-
-/**
-   Move the caret.
-
-   Asynchronous operation, get status via m0_emap_be_op_get(it)->bo_sm.sm_rc.
- */
 M0_INTERNAL int m0_emap_caret_move(struct m0_emap_caret *car,
-				   m0_bcount_t           count);
+				   m0_bcount_t count);
 
-/** Returns how far is the end of extent. */
 M0_INTERNAL m0_bcount_t m0_emap_caret_step(const struct m0_emap_caret *car);
 
 /** @} end group extmap */
diff --git a/db/extmap_internal.h b/db/extmap_internal.h
index ae9fc86..9a6683e 100644
--- a/db/extmap_internal.h
+++ b/db/extmap_internal.h
@@ -1,6 +1,6 @@
 /* -*- C -*- */
 /*
- * COPYRIGHT 2013 XYRATEX TECHNOLOGY LIMITED
+ * COPYRIGHT 2012 XYRATEX TECHNOLOGY LIMITED
  *
  * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
  * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
@@ -35,19 +35,25 @@
  */
 
 #include "lib/types.h"     /* struct m0_uint128 */
-#include "be/btree.h"
+#include "db/db.h"
+
+/**
+   m0_emap stores a collection of related extent maps. Individual maps within a
+   collection are identified by a prefix.
+
+   @see m0_emap_obj_insert()
+ */
+struct m0_emap {
+	struct m0_table   em_mapping;
+};
 
 /**
    A key used to identify a particular segment in the map collection.
  */
 struct m0_emap_key {
-	/**
-	    Prefix of the map the segment is part of.
-	 */
+	/** Prefix of the map the segment is part of. */
 	struct m0_uint128 ek_prefix;
-
-	/**
-	    Last offset of the segment's extent. That is, the key of a segment
+	/** Last offset of the segment's extent. That is, the key of a segment
 	    ([A, B), V) has B as an offset.
 
 	    This not entirely intuitive decision is forced by the available
@@ -80,34 +86,19 @@ struct m0_emap_rec {
 };
 
 /**
-   m0_emap stores a collection of related extent maps. Individual maps within a
-   collection are identified by a prefix.
-
-   @see m0_emap_obj_insert()
- */
-struct m0_emap {
-	struct m0_be_btree   em_mapping;
-	struct m0_buf        em_key_buf;
-	struct m0_buf        em_val_buf;
-	struct m0_emap_key   em_key;
-	struct m0_emap_rec   em_rec;
-};
-
-/**
    Cursor iterating through the extent map.
  */
 struct m0_emap_cursor {
 	/** Map this cursor is iterating through. */
-	struct m0_emap           *ec_map;
+	struct m0_emap     *ec_map;
 	/** Segment currently reached. */
-	struct m0_emap_seg        ec_seg;
+	struct m0_emap_seg  ec_seg;
 	/** Data-base cursor. */
-	struct m0_be_btree_cursor ec_cursor;
-	struct m0_emap_key        ec_key;
-	struct m0_emap_rec        ec_rec;
-	struct m0_buf             ec_keybuf;
-	struct m0_buf             ec_recbuf;
-	struct m0_uint128         ec_prefix;
+	struct m0_db_cursor ec_cursor;
+	struct m0_db_pair   ec_pair;
+	struct m0_emap_key  ec_key;
+	struct m0_emap_rec  ec_rec;
+	struct m0_uint128   ec_prefix;
 };
 
 /** @} end group extmap */
-- 
1.8.3.2

