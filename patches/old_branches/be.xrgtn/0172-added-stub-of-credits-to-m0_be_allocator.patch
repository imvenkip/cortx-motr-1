From a0d374fb5278c0e02987942e9601afa4ad34c570 Mon Sep 17 00:00:00 2001
From: Maxim Medved <Max_Medved@xyratex.com>
Date: Wed, 19 Jun 2013 05:10:12 +0300
Subject: [PATCH 172/228] added stub of credits to m0_be_allocator

---
 be/alloc.c          | 86 ++++++++++++++++++++++++++++++++++++-----------------
 be/alloc.h          |  3 +-
 be/alloc_internal.h |  2 +-
 be/list.c           |  3 +-
 be/seg.h            |  6 ++++
 be/tx_credit.c      | 10 +++++++
 be/tx_credit.h      | 20 +++++++++++++
 7 files changed, 100 insertions(+), 30 deletions(-)

diff --git a/be/alloc.c b/be/alloc.c
index 2cae782..9adc98d 100644
--- a/be/alloc.c
+++ b/be/alloc.c
@@ -31,6 +31,7 @@
 #include "be/seg_internal.h"	/* m0_be_seg_hdr */
 #include "be/tx.h"		/* m0_be_tx_credit */
 #include "be/be.h"		/* m0_be_op */
+#include "be/tx_credit.h"	/* m0_be_tx_credit_add */
 
 /**
  * @addtogroup be
@@ -454,16 +455,39 @@ M0_INTERNAL int m0_be_allocator_destroy(struct m0_be_allocator *a)
 	return 0;
 }
 
-M0_INTERNAL void m0_be_allocator_credit(const struct m0_be_allocator *a,
+M0_INTERNAL void m0_be_allocator_credit(struct m0_be_allocator *a,
 					enum m0_be_allocator_op optype,
 					m0_bcount_t size,
 					unsigned shift,
 					struct m0_be_tx_credit *accum)
 {
-	enum { DUMMY_CRED = 10 };
+	struct m0_be_tx_credit chunk_credit;
+	struct m0_be_tx_credit mem_credit;
+	struct m0_be_tx_credit header_credit;
 
-	accum->tc_reg_nr   = 1    * DUMMY_CRED;
-	accum->tc_reg_size = size * DUMMY_CRED;
+	M0_PRE(m0_be_allocator__invariant(a));
+
+	chunk_credit  = M0_BE_TX_CREDIT_TYPE(struct be_alloc_chunk);
+	header_credit = M0_BE_TX_CREDIT_TYPE(struct m0_be_allocator_header);
+	mem_credit    = M0_BE_TX_CREDIT(1, size * 2);
+
+	/** @todo TODO XXX add list credits instead of entire header */
+	switch (optype) {
+		case M0_BAO_ALLOC:
+			/* see be_alloc_chunk_split() */
+			/* prev, chunk0, new, chunk1, next */
+			m0_be_tx_credit_mac(accum, &chunk_credit, 5);
+			m0_be_tx_credit_add(accum, &mem_credit);
+			m0_be_tx_credit_add(accum, &header_credit);
+			break;
+		case M0_BAO_FREE:
+			/* prev of prev, prev, current, next, next of next */
+			m0_be_tx_credit_mac(accum, &chunk_credit, 5);
+			m0_be_tx_credit_add(accum, &header_credit);
+			break;
+		default:
+			M0_IMPOSSIBLE("Invalid allocator operation type");
+	}
 }
 
 M0_INTERNAL void *m0_be_alloc(struct m0_be_allocator *a,
@@ -474,6 +498,10 @@ M0_INTERNAL void *m0_be_alloc(struct m0_be_allocator *a,
 	struct be_alloc_chunk *c = NULL;
 
 	M0_PRE(m0_be_allocator__invariant(a));
+
+	/* XXX */
+	m0_be_op_state_set(op, M0_BOS_ACTIVE);
+
 	m0_mutex_lock(&a->ba_lock);
 	/* algorithm starts here */
 	m0_tl_for(chunks_free, &a->ba_h->bah_free.bl_list, iter) {
@@ -485,7 +513,6 @@ M0_INTERNAL void *m0_be_alloc(struct m0_be_allocator *a,
 	m0_mutex_unlock(&a->ba_lock);
 
 	/* XXX */
-	m0_be_op_state_set(op, M0_BOS_ACTIVE);
 	m0_be_op_state_set(op, M0_BOS_SUCCESS);
 
 	M0_POST(m0_be_allocator__invariant(a));
@@ -503,33 +530,38 @@ M0_INTERNAL void m0_be_free(struct m0_be_allocator *a,
 	struct be_alloc_chunk *next;
 	bool		       chunks_were_merged;
 
-	if (ptr == NULL)
-		goto done;
-
 	M0_PRE(m0_be_allocator__invariant(a));
-	m0_mutex_lock(&a->ba_lock);
+	M0_PRE(ptr == NULL || (char *) ptr >= (char *) a->ba_h->bah_addr);
+	M0_PRE(ptr == NULL ||
+	       (char *) ptr < ((char *) a->ba_h->bah_addr) + a->ba_h->bah_size);
+
+	/* XXX */
+	m0_be_op_state_set(op, M0_BOS_ACTIVE);
+
 	if (ptr != NULL) {
-		c = be_alloc_chunk_addr(ptr);
-		M0_PRE(be_alloc_chunk_invariant(a, c));
-		M0_PRE(!c->bac_free);
-		/* algorithm starts here */
-		be_alloc_chunk_mark_free(a, c);
-		prev = be_alloc_chunk_prev(a, c);
-		next = be_alloc_chunk_next(a, c);
-		chunks_were_merged = be_alloc_chunk_trymerge(a, prev, c);
-		if (chunks_were_merged)
-			c = prev;
-		be_alloc_chunk_trymerge(a, c, next);
-		/* and ends here */
-		M0_POST(c->bac_free);
-		M0_POST(c->bac_size > 0);
-		M0_POST(be_alloc_chunk_invariant(a, c));
+		m0_mutex_lock(&a->ba_lock);
+		if (ptr != NULL) {
+			c = be_alloc_chunk_addr(ptr);
+			M0_PRE(be_alloc_chunk_invariant(a, c));
+			M0_PRE(!c->bac_free);
+			/* algorithm starts here */
+			be_alloc_chunk_mark_free(a, c);
+			prev = be_alloc_chunk_prev(a, c);
+			next = be_alloc_chunk_next(a, c);
+			chunks_were_merged = be_alloc_chunk_trymerge(a, prev,
+								     c);
+			if (chunks_were_merged)
+				c = prev;
+			be_alloc_chunk_trymerge(a, c, next);
+			/* and ends here */
+			M0_POST(c->bac_free);
+			M0_POST(c->bac_size > 0);
+			M0_POST(be_alloc_chunk_invariant(a, c));
+		}
+		m0_mutex_unlock(&a->ba_lock);
 	}
-	m0_mutex_unlock(&a->ba_lock);
 
-done:
 	/* XXX */
-	m0_be_op_state_set(op, M0_BOS_ACTIVE);
 	m0_be_op_state_set(op, M0_BOS_SUCCESS);
 
 	M0_POST(m0_be_allocator__invariant(a));
diff --git a/be/alloc.h b/be/alloc.h
index 5dc5b0a..55847e6 100644
--- a/be/alloc.h
+++ b/be/alloc.h
@@ -64,7 +64,8 @@ enum m0_be_allocator_op {
 	M0_BAO_FREE
 };
 
-M0_INTERNAL void m0_be_allocator_credit(const struct m0_be_allocator *a,
+/** add to accum credits for optype */
+M0_INTERNAL void m0_be_allocator_credit(struct m0_be_allocator *a,
 					enum m0_be_allocator_op optype,
 					m0_bcount_t size,
 					unsigned shift,
diff --git a/be/alloc_internal.h b/be/alloc_internal.h
index 35dde07..171659a 100644
--- a/be/alloc_internal.h
+++ b/be/alloc_internal.h
@@ -65,7 +65,7 @@ struct be_alloc_chunk {
 struct m0_be_allocator_header {
 	struct m0_be_list	      bah_chunks;	/**< all chunks */
 	struct m0_be_list	      bah_free;		/**< free chunks */
-	struct m0_be_allocator_stats  bah_stats;
+	struct m0_be_allocator_stats  bah_stats;	/**< XXX not used now */
 	m0_bcount_t		      bah_size;		/**< memory size */
 	void			     *bah_addr;		/**< memory address */
 };
diff --git a/be/list.c b/be/list.c
index b522a37..bc506c2 100644
--- a/be/list.c
+++ b/be/list.c
@@ -78,7 +78,8 @@ M0_INTERNAL void m0_be_list_get(const struct m0_be_list *list,
 		   op->bo_sm.sm_grp);
 
 	m0_tlist_for(list->bl_descr, &list->bl_list, lnode) {
-		if (--nelems == 0) break;
+		if (--nelems == 0)
+			break;
 		op->bo_u.u_list.l_lnode     = lnode;
 		op->bo_u.u_list.l_nelems    = nelems + 1;
 		lreg_op.bo_u.u_reg.br_addr  = lnode;
diff --git a/be/seg.h b/be/seg.h
index 2a1095b..db9cedb 100644
--- a/be/seg.h
+++ b/be/seg.h
@@ -116,6 +116,12 @@ M0_INTERNAL int m0_be_seg_bufvec_build(struct m0_be_seg *seg,
  */
 M0_INTERNAL void m0_be_reg_get(struct m0_be_reg *reg, struct m0_be_op *op);
 
+#define M0_BE_PTR_GET(seg, op, ptr) \
+	m0_be_reg_get(M0_BE_REG((seg), (sizeof *ptr), (ptr)), (op))
+
+#define M0_BE_ARR_GET(seg, op, arr, nr) \
+	m0_be_reg_get(M0_BE_REG((seg), (sizeof arr[0]) * (nr), (arr)), (op))
+
 /**
  * XXX DOCUMENTME
  *
diff --git a/be/tx_credit.c b/be/tx_credit.c
index 40cfe70..2e837c4 100644
--- a/be/tx_credit.c
+++ b/be/tx_credit.c
@@ -45,6 +45,16 @@ M0_INTERNAL void m0_be_tx_credit_mul(struct m0_be_tx_credit *c, m0_bcount_t k)
 	c->tc_reg_size *= k;
 }
 
+M0_INTERNAL void m0_be_tx_credit_mac(struct m0_be_tx_credit *c,
+				     const struct m0_be_tx_credit *c1,
+				     m0_bcount_t k)
+{
+	struct m0_be_tx_credit c1_k = *c1;
+
+	m0_be_tx_credit_mul(&c1_k, k);
+	m0_be_tx_credit_add(c, &c1_k);
+}
+
 M0_INTERNAL bool
 credit_le(const struct m0_be_tx_credit *c0, const struct m0_be_tx_credit *c1)
 {
diff --git a/be/tx_credit.h b/be/tx_credit.h
index 235310b..a1024c8 100644
--- a/be/tx_credit.h
+++ b/be/tx_credit.h
@@ -75,11 +75,31 @@ M0_INTERNAL void m0_be_tx_credit_add(struct m0_be_tx_credit *c0,
 /** c *= k */
 M0_INTERNAL void m0_be_tx_credit_mul(struct m0_be_tx_credit *c, m0_bcount_t k);
 
+/**
+ * c += c1 * k
+ * Multiply-accumulate operation.
+ */
+M0_INTERNAL void m0_be_tx_credit_mac(struct m0_be_tx_credit *c,
+				     const struct m0_be_tx_credit *c1,
+				     m0_bcount_t k);
+
 M0_INTERNAL bool credit_le(const struct m0_be_tx_credit *c0,
 			   const struct m0_be_tx_credit *c1);
 M0_INTERNAL void credit_mod(struct m0_be_tx_credit *cr,
 			    const struct m0_be_reg_d *reg, int sgn);
 
+#define M0_BE_TX_CREDIT_TYPE(type)		\
+	((struct m0_be_tx_credit) {		\
+		.tc_reg_nr = 1,			\
+		.tc_reg_size = sizeof (type)	\
+	})
+
+#define M0_BE_TX_CREDIT(reg_nr, reg_size)	\
+	((struct m0_be_tx_credit) {		\
+		.tc_reg_nr = (reg_nr),		\
+		.tc_reg_size = (reg_size)	\
+	})
+
 /** @} end of be group */
 #endif /* __MERO_BE_TX_CREDIT_H__ */
 
-- 
1.8.3.2

