From 22984ba9d0b972ce29138afd1d31dd595318a70c Mon Sep 17 00:00:00 2001
From: Anatoliy Bilenko <anatoliy_bilenko@xyratex.com>
Date: Thu, 20 Jun 2013 18:47:11 +0300
Subject: [PATCH 186/228] seg: added m0_be_seg_write_simple() implementation.

---
 be/seg.c | 72 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++--------
 be/seg.h | 12 ++++++-----
 2 files changed, 70 insertions(+), 14 deletions(-)

diff --git a/be/seg.c b/be/seg.c
index 1cd91eb..35551cb 100644
--- a/be/seg.c
+++ b/be/seg.c
@@ -28,7 +28,7 @@
 #include "stob/stob.h"
 
 #include "be/seg_internal.h"
-/* #include "be/tx_regmap.h"  /\* m0_be_regdtree_node *\/ */
+#include "be/tx_regmap.h"
 
 #include <search.h>          /* twalk */
 #include <sys/mman.h>        /* mmap */
@@ -42,6 +42,7 @@
 #define BE_SEG_DEFAULT_ADDR   ((void *)0x400000000000)
 #define BE_SEG_HEADER_OFFSET  (0ULL)
 
+
 static int stob_io_single_write(void *buf, m0_bcount_t bufsize,
 				struct m0_stob *stob,
 				m0_bindex_t offs, uint32_t bshift)
@@ -361,24 +362,77 @@ static inline m0_bcount_t be_seg_blkno(const struct m0_be_seg *seg, void *addr)
 	return (addr - seg->bs_addr) >> seg->bs_bshift;
 }
 
+static void iovec_prepare(struct m0_be_seg *seg,
+			  struct m0_be_reg_d *area, m0_bindex_t nr,
+			  struct m0_indexvec *iv, struct m0_bufvec *bv)
+{
+	int i;
+
+	M0_PRE(seg->bs_bshift == 0);
+
+	M0_ALLOC_ARR(bv->ov_vec.v_count, nr);
+	M0_ALLOC_ARR(bv->ov_buf, nr);
+
+	M0_ALLOC_ARR(iv->iv_vec.v_count, nr);
+	M0_ALLOC_ARR(iv->iv_index, nr);
+
+	M0_ASSERT(bv->ov_vec.v_count != NULL && bv->ov_buf   != NULL);
+	M0_ASSERT(iv->iv_vec.v_count != NULL && iv->iv_index != NULL);
+
+	bv->ov_vec.v_nr = nr;
+	iv->iv_vec.v_nr = nr;
+
+	for (i = 0; i < nr; ++i) {
+		bv->ov_vec.v_count[i] = area[i].rd_reg.br_size;
+		bv->ov_buf[i]	      = area[i].rd_buf;
+
+		iv->iv_vec.v_count[i] = area[i].rd_reg.br_size;
+		iv->iv_index[i]       = be_seg_blkno(seg, area[i].rd_buf);
+	}
+}
+
 static bool be_seg_stobio_cb(struct m0_clink *link)
 {
 	struct m0_be_op   *op = container_of(link, struct m0_be_op,
 					     bo_u.u_segio.si_clink);
 	struct m0_stob_io *io = &op->bo_u.u_segio.si_stobio;
-	int                rc;
 
-	rc = io->si_rc;
 	m0_clink_del_lock(link);
 	m0_clink_fini(link);
 	m0_stob_io_fini(io);
+
+	op->bo_sm.sm_rc = io->si_rc;
+	m0_be_op_state_set(op, io->si_rc == 0 ? M0_BOS_ACTIVE : M0_BOS_FAILURE);
+
+	return io->si_rc == 0;
+}
+
+M0_INTERNAL void m0_be_seg_write_simple(struct m0_be_seg *seg,
+					struct m0_be_op *op,
+					struct m0_be_reg_d *area,
+					m0_bindex_t nr)
+{
+	struct m0_stob_io *io    = &op->bo_u.u_segio.si_stobio;
+	struct m0_clink   *clink = &op->bo_u.u_segio.si_clink;
+	int                rc;
+
+	M0_PRE(m0_be__seg_invariant(seg) && op != NULL);
+
+	/* Set up op, clink and io structs for SEGIO write. */
+	op->bo_utype        = M0_BOP_SEGIO;
+	m0_clink_init(clink, &be_seg_stobio_cb);
+
+	m0_stob_io_init(io);
+	io->si_flags        = 0;
+	io->si_opcode       = SIO_WRITE;
+	io->si_fol_rec_part = (void *)1;
+
+	iovec_prepare(seg, area, nr, &io->si_stob, &io->si_user);
+
+	m0_clink_add_lock(&io->si_wait, clink);
+	rc = m0_stob_io_launch(io, seg->bs_stob, NULL, NULL);
 	op->bo_sm.sm_rc = rc;
-	if (rc == 0) {
-		m0_sm_state_set(&op->bo_sm, M0_BOS_SUCCESS);
-	} else {
-		m0_sm_state_set(&op->bo_sm, M0_BOS_FAILURE);
-	}
-	return rc;
+	m0_be_op_state_set(op, rc == 0 ? M0_BOS_ACTIVE : M0_BOS_FAILURE);
 }
 
 M0_INTERNAL int m0_be_seg_write(struct m0_be_seg *seg,
diff --git a/be/seg.h b/be/seg.h
index ee863c1..42c9f72 100644
--- a/be/seg.h
+++ b/be/seg.h
@@ -27,6 +27,7 @@
 
 struct m0_be;
 struct m0_be_op;
+struct m0_be_reg_d;
 
 /**
  * @defgroup be
@@ -155,12 +156,13 @@ M0_INTERNAL int m0_be__reg_write(struct m0_be_seg *seg,
  * write data on the disk. This will unblock other tasks in BE. This
  * call will be replaced with m0_be_seg_write() in the nearest future.
  *
- * @param area - array of regions which has to be written on the disk of nr size
+ * @param area - array of regions which has to be written on the disk.
+ *               It has @nr elements.
  */
-M0_INTERNAL int m0_be_seg_write_simple(struct m0_be_seg *seg,
-				       struct m0_be_op *op,
-				       struct m0_be_reg_d *area,
-				       m0_bindex_t nr);
+M0_INTERNAL void m0_be_seg_write_simple(struct m0_be_seg *seg,
+					struct m0_be_op *op,
+					struct m0_be_reg_d *area,
+					m0_bindex_t nr);
 
 /** @} end of be group */
 #endif /* __MERO_BE_SEG_H__ */
-- 
1.8.3.2

