From c549b557e732a069ea3eac98f0c8caaa1aba2e0e Mon Sep 17 00:00:00 2001
From: Alexander Gattin <alexander_gattin@xyratex.com>
Date: Thu, 13 Jun 2013 16:47:20 +0300
Subject: [PATCH 152/228] be/seg: implement m0_be_seg_read().

---
 be/seg.c | 55 +++++++++++++++++++++++++++++++++++++++++++++++++++++++
 be/seg.h | 13 +++++++++++++
 2 files changed, 68 insertions(+)

diff --git a/be/seg.c b/be/seg.c
index da4d4b3..918da1f 100644
--- a/be/seg.c
+++ b/be/seg.c
@@ -213,6 +213,61 @@ static int stob_io_single_read(void *buf, m0_bcount_t bufsize,
 	return rc;
 }
 
+M0_INTERNAL int m0_be_seg_read(struct m0_be_seg *seg,
+			       struct m0_be_op  *op,
+			       struct m0_bufvec *bv)
+{
+	struct m0_stob_io  *io;
+	struct m0_clink    *clink;
+	struct m0_indexvec *iv;
+	void               *seg_addr0_packed;
+	m0_bcount_t         i;
+
+	M0_PRE(m0_be__seg_invariant(seg) && op != NULL);
+
+	/* Set up op, clink and io structs for SEGIO reading. */
+	op->bo_utype   = M0_BOP_SEGIO;
+	clink          = &op->bo_u.u_segio.si_clink;
+	io             = &op->bo_u.u_segio.si_stobio;
+	m0_clink_init(clink, NULL);
+	m0_stob_io_init(io);
+	io->si_flags   = 0;
+	io->si_opcode  = SIO_READ;
+	io->si_user    = *bv;
+	iv             = &io->si_stob;
+	iv->iv_vec     = bv->ov_vec;
+	/* XXX: iv_index needs to be allocated, but in case of -ENOMEM
+	 * it's probably possible to do i/o one buf at a time. */
+	iv->iv_index   = m0_alloc((sizeof *(iv->iv_index)) * iv->iv_vec.v_nr);
+	if (iv->iv_index == NULL) {
+		op->bo_sm.sm_rc = -ENOMEM;
+		m0_sm_state_set(&op->bo_sm, M0_BOS_FAILURE);
+		return op->bo_sm.sm_rc;
+	}
+	/* Calculate iv indexes from addresses relative to seg->bs_addr. */
+	seg_addr0_packed = m0_stob_addr_pack(seg->bs_addr, seg->bs_bshift);
+	for (i = 0; i < iv->iv_vec.v_nr; i++)
+		iv->iv_index[i] = bv->ov_buf[i] - seg_addr0_packed;
+	/* Add clink and start STOB i/o. */
+	m0_clink_add_lock(&io->si_wait, clink);
+	op->bo_sm.sm_rc = m0_stob_io_launch(io, seg->bs_stob, NULL, NULL);
+	m0_sm_state_set(&op->bo_sm, M0_BOS_ACTIVE);
+	/* XXX: STOB i/o is completed synchronously here. */
+	if (op->bo_sm.sm_rc == 0) {
+		m0_chan_wait(clink);
+		op->bo_sm.sm_rc = io->si_rc;
+	}
+	m0_clink_del_lock(clink);
+	m0_clink_fini(clink);
+	m0_stob_io_fini(io);
+	if (op->bo_sm.sm_rc == 0) {
+		m0_sm_state_set(&op->bo_sm, M0_BOS_SUCCESS);
+	} else {
+		m0_sm_state_set(&op->bo_sm, M0_BOS_FAILURE);
+	}
+	return op->bo_sm.sm_rc;
+}
+
 M0_INTERNAL int m0_be_seg_open(struct m0_be_seg *seg)
 {
 	int                   rc;
diff --git a/be/seg.h b/be/seg.h
index 14e96d4..c824c3c 100644
--- a/be/seg.h
+++ b/be/seg.h
@@ -97,6 +97,19 @@ M0_INTERNAL int m0_be_seg_dict_delete(struct m0_be_seg *seg, const char *name);
 
 M0_INTERNAL bool m0_be_seg_contains(const struct m0_be_seg *seg, void *addr);
 
+M0_INTERNAL int m0_be_seg_read(struct m0_be_seg *seg,
+			       struct m0_be_op *op,
+			       struct m0_bufvec *bv);
+
+M0_INTERNAL int m0_be_seg_write(struct m0_be_seg *seg,
+				struct m0_be_op *op,
+				struct m0_bufvec *bv);
+
+M0_INTERNAL int m0_be_seg_bufvec_build(struct m0_be_seg *seg,
+				       struct m0_be_op *op,
+				       struct m0_indexvec *iv,
+				       struct m0_bufvec *bv);
+
 /*
  * `reg' parameter is not const, because stob IO will update
  * m0_be_reg::br_addr when a region is loaded/stored.
-- 
1.8.3.2

