From da8984cbdf5f29f40194af22224db0d7c5c2c323 Mon Sep 17 00:00:00 2001
From: Alexander Gattin <alexander_gattin@xyratex.com>
Date: Tue, 18 Jun 2013 12:16:19 +0300
Subject: [PATCH 163/228] be/seg: implement m0_be_seg_write().

---
 be/be.h  |  2 +-
 be/seg.c | 53 +++++++++++++++++++++++++++++++++++++++++++++++++++++
 be/seg.h |  2 +-
 3 files changed, 55 insertions(+), 2 deletions(-)

diff --git a/be/be.h b/be/be.h
index d9cc7f4..1950a9f 100644
--- a/be/be.h
+++ b/be/be.h
@@ -75,7 +75,7 @@ struct m0_be_op {
 		/* Used by m0_be_reg_get(). */
 		struct m0_be_reg                   u_reg;
 
-		/* Used by m0_be_seg_read(). */
+		/* Used by m0_be_seg_read(), m0_be_seg_write(). */
 		struct {
 			/* STOB i/o structure with allocated si_stob.iv_index
 			 * array. */
diff --git a/be/seg.c b/be/seg.c
index b0a26d0..f23afe8 100644
--- a/be/seg.c
+++ b/be/seg.c
@@ -356,6 +356,59 @@ static inline m0_bcount_t be_seg_blkno(const struct m0_be_seg *seg, void *addr)
 	return (addr - seg->bs_addr) >> seg->bs_bshift;
 }
 
+M0_INTERNAL int m0_be_seg_write(struct m0_be_seg *seg,
+				void *regd_tree,
+				struct m0_be_op *op)
+{
+	struct m0_stob_io  *io;
+	struct m0_clink    *clink;
+	int                 rc;
+
+	M0_PRE(m0_be__seg_invariant(seg) && op != NULL);
+
+	/* Set up op, clink and io structs for SEGIO write. */
+	op->bo_utype       = M0_BOP_SEGIO;
+	clink              = &op->bo_u.u_segio.si_clink;
+	io                 = &op->bo_u.u_segio.si_stobio;
+	m0_clink_init(clink, NULL);
+	m0_stob_io_init(io);
+	io->si_flags       = 0;
+	io->si_opcode      = SIO_WRITE;
+	io.si_fol_rec_part = (void *)1;
+
+	/* Allocate and fill counts, buffers and indexes arrays. */
+	rc = m0_be_seg_bufvec_build(seg, regd_tree, &io->si_stob,
+				    &io->si_user);
+	if (rc != 0) {
+		op->bo_sm.sm_rc = rc;
+		m0_sm_state_set(&op->bo_sm, M0_BOS_FAILURE);
+		return rc;
+	}
+
+	/* Add clink and start STOB i/o. */
+	m0_clink_add_lock(&io->si_wait, clink);
+	rc = m0_stob_io_launch(io, seg->bs_stob, NULL, NULL);
+	if (rc != 0)
+		goto fin;
+	else
+		m0_sm_state_set(&op->bo_sm, M0_BOS_ACTIVE);
+
+	/* XXX: Complete STOB i/o synchronously. */
+	m0_chan_wait(clink);
+	rc = io->si_rc;
+fin:
+	m0_clink_del_lock(clink);
+	m0_clink_fini(clink);
+	m0_stob_io_fini(io);
+	op->bo_sm.sm_rc = rc;
+	if (rc == 0) {
+		m0_sm_state_set(&op->bo_sm, M0_BOS_SUCCESS);
+	} else {
+		m0_sm_state_set(&op->bo_sm, M0_BOS_FAILURE);
+	}
+	return rc;
+}
+
 M0_INTERNAL int m0_be_seg_bufvec_build(struct m0_be_seg *seg,
 				       void *regd_tree,
 				       struct m0_indexvec *iv,
diff --git a/be/seg.h b/be/seg.h
index 6ec9525..b6405d7 100644
--- a/be/seg.h
+++ b/be/seg.h
@@ -102,7 +102,7 @@ M0_INTERNAL int m0_be_seg_read(struct m0_be_seg *seg,
 			       struct m0_bufvec *bv);
 
 M0_INTERNAL int m0_be_seg_write(struct m0_be_seg *seg,
-				struct m0_be_op *op,
+				void *regd_tree,
 				struct m0_bufvec *bv);
 
 M0_INTERNAL int m0_be_seg_bufvec_build(struct m0_be_seg *seg,
-- 
1.8.3.2

