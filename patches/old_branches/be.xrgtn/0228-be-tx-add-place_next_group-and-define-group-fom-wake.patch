From 307fd070f82bd916368fd3f0a0f8c749cb3dd81b Mon Sep 17 00:00:00 2001
From: Alexander Gattin <alexander_gattin@xyratex.com>
Date: Tue, 2 Jul 2013 10:58:54 +0300
Subject: [PATCH 228/228] be/tx: add place_next_group() and define group fom
 wake semantics.

* add place_next_group() to wake first LOGGED group in queue when
  it's safe to start seg i/o (previous seg i/o has been completed)
* define and comment tx group wake actions
* modify tg_fom_tick() accordingly
* everybody goodbye
---
 be/tx_group.c | 53 ++++++++++++++++++++++++++++++++++++-----------------
 1 file changed, 36 insertions(+), 17 deletions(-)

diff --git a/be/tx_group.c b/be/tx_group.c
index 2a8695a..950cf8b 100644
--- a/be/tx_group.c
+++ b/be/tx_group.c
@@ -214,7 +214,17 @@ static void log_next_group(struct m0_be_tx_engine *eng)
 	if (! tg_tlist_is_empty(&eng->te_tgs[M0_BGS_CLOSED]) &&
 	    tg_tlist_is_empty(&eng->te_tgs[M0_BGS_LOG])) {
 		gr = tg_tlist_head(&eng->te_tgs[M0_BGS_CLOSED]);
-		tg_state_set(gr, M0_BGS_LOG);
+		m0_fom_wakeup(&gr->tg_fom);
+	}
+}
+
+/* Must be called with fom lock held. */
+static void place_next_group(struct m0_be_tx_engine *eng)
+{
+	struct m0_be_tx_group *gr;
+	if (! tg_tlist_is_empty(&eng->te_tgs[M0_BGS_LOGGED]) &&
+	    tg_tlist_is_empty(&eng->te_tgs[M0_BGS_PLACE])) {
+		gr = tg_tlist_head(&eng->te_tgs[M0_BGS_LOGGED]);
 		m0_fom_wakeup(&gr->tg_fom);
 	}
 }
@@ -235,11 +245,14 @@ static int tg_fom_tick(struct m0_fom *fom)
 		return M0_FSO_WAIT;
 
 	case M0_BGS_ACTIVE:
+		M0_PRE(m0_forall(i, ARRAY_SIZE(gr->tg_txs),
+				 (i == M0_BTS_CLOSED ||
+				  tg_tlist_is_empty(&gr->tg_txs[i]))));
 		/* Group is woken up in ACTIVE state iff tg_close_timeout
 		 * has expired. */
 		tg_state_set(gr, M0_BGS_CLOSED);
 		log_next_group(gr->tg_eng);
-		return M0_FSO_WAIT;
+		return M0_FSO_WAIT; /* wait for log_next_group */
 
 	case M0_BGS_CLOSED:
 		/* All group's transactions must be in CLOSED state,
@@ -256,42 +269,48 @@ static int tg_fom_tick(struct m0_fom *fom)
 		m0_tl_for(tg, &gr->tg_txs[M0_BTS_CLOSED], tx) {
 			tx_state_set(tx, M0_BTS_LOG);
 		} m0_tl_endfor;
-		return M0_FSO_WAIT;
+		return M0_FSO_WAIT; /* wait for log i/o completion */
 
 	case M0_BGS_LOG:
+		M0_PRE(m0_forall(i, ARRAY_SIZE(gr->tg_txs),
+				 (i == M0_BTS_LOG ||
+				  tg_tlist_is_empty(&gr->tg_txs[i]))));
 		/* Log i/o has been completed, go further. */
 		tg_state_set(gr, M0_BGS_LOGGED);
 		m0_tl_for(tg, &gr->tg_txs[M0_BTS_CLOSED], tx) {
 			tx_state_set(tx, M0_BTS_LOGGED);
 		} m0_tl_endfor;
 		log_next_group(eng);
-		return M0_FSO_AGAIN;
+		place_next_group(eng);
+		return M0_FSO_WAIT; /* wait for place_next_group */
 
 	case M0_BGS_LOGGED:
+		/* Group fom is awoken in LOGGED state by place_next_group. */
+		M0_PRE(m0_forall(i, ARRAY_SIZE(gr->tg_txs),
+				 (i == M0_BTS_LOGGED ||
+				  tg_tlist_is_empty(&gr->tg_txs[i]))));
 		tg_state_set(gr, M0_BGS_PLACE);
+		tx = gr_tlist_head(&gr->tg_txs[M0_BTS_LOGGED]);
+		tx_state_set(tx, M0_BTS_PLACE);
+		return M0_FSO_WAIT; /* wait for fom_wake from tx fom */
+
 	case M0_BGS_PLACE:
-		/* All group's transactions must be in LOGGED, PLACE or
-		 * PLACED state ATM, with no more than 1 tx in PLACE. */
+		/* Group fom is awoken when one its tx completes seg i/o. */
 		M0_PRE(m0_forall(i, ARRAY_SIZE(gr->tg_txs),
-				 (i == M0_BTS_LOGGED || i == M0_BTS_PLACE ||
-				  i == M0_BTS_PLACED ||
-				  tg_tlist_is_empty(&gr->tg_txs[i]))) &&
-		       M0_IN(tg_tlist_length(&gr->tg_txs[M0_BTS_PLACE]),
-			     (0, 1))
-		       );
+				 ((M0_BTS_LOGGED <= i && i <= M0_BTS_PLACED) ||
+				  tg_tlist_is_empty(&gr->tg_txs[i]))));
 
 		if (gr_tlist_is_empty(&gr->tg_txs[M0_BGS_LOGGED])) {
 			/* All transactions made it to PLACED. */
 			tg_state_set(gr, M0_BGS_PLACED);
+			place_next_group(eng);
 		} else {
-			/* Start seg i/o for the next LOGGED
-			 * transaction by switching it to PLACE. */
+			/* Start seg i/o for the next LOGGED transaction by
+			 * switching it to PLACE state. */
 			tx = gr_tlist_head(&gr->tg_txs[M0_BTS_LOGGED]);
-			m0_fom_wait_on(fom, &tx->t_fom.fo_sm_phase.sm_chan,
-				       &fom->fo_cb);
 			tx_state_set(tx, M0_BTS_PLACE);
 		}
-		return M0_FSO_WAIT;
+		return M0_FSO_WAIT; /* wait for next group's tx i/o */
 
 	case M0_BGS_PLACED:
 	case M0_BGS_FAILED:
-- 
1.8.3.2

