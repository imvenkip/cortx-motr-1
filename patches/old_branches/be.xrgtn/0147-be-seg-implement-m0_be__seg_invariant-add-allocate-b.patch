From a14f436e0cdeb3cf6a9eab6328de6a720e0bacaa Mon Sep 17 00:00:00 2001
From: Alexander Gattin <alexander_gattin@xyratex.com>
Date: Wed, 12 Jun 2013 13:50:06 +0300
Subject: [PATCH 147/228] be/seg: implement m0_be__seg_invariant(),
 add/allocate bs_pgmap.

* rename m0_be_seg__invariant() to m0_be__seg_invariant() and
  implement it similarly to m0_be__reg_invariant()
* check that region falls inside the segment in m0_be__seg_invariant()
* add bs_pgmap and bs_pgnr fields to struct m0_be_seg
* allocate sufficient bs_pgmap to descibe all segment's pages during
  m0_be_seg_open()
* initialize bs_id, bs_addr, bs_size etc in m0_be_seg_init()
---
 be/alloc.c |  2 +-
 be/seg.c   | 36 +++++++++++++++++++++++++++++-------
 be/seg.h   |  7 ++++++-
 3 files changed, 36 insertions(+), 9 deletions(-)

diff --git a/be/alloc.c b/be/alloc.c
index 7b90bbc..2492c9d 100644
--- a/be/alloc.c
+++ b/be/alloc.c
@@ -345,7 +345,7 @@ static bool be_alloc_chunk_trymerge(struct m0_be_allocator *al,
 M0_INTERNAL int m0_be_allocator_init(struct m0_be_allocator *a,
 				     struct m0_be_seg *seg)
 {
-	M0_PRE(m0_be_seg__invariant(seg));
+	M0_PRE(m0_be__seg_invariant(seg));
 
 	m0_mutex_init(&a->ba_lock);
 
diff --git a/be/seg.c b/be/seg.c
index 0d1b947..e2d83c6 100644
--- a/be/seg.c
+++ b/be/seg.c
@@ -18,6 +18,7 @@
  * Original creation date: 29-May-2013
  */
 
+#include "be/be.h"
 #include "be/seg.h"
 
 #include "lib/assert.h"
@@ -144,9 +145,14 @@ M0_INTERNAL int m0_be_seg_destroy(struct m0_be_seg *seg)
 M0_INTERNAL void
 m0_be_seg_init(struct m0_be_seg *seg, struct m0_stob *stob, struct m0_be *be)
 {
-	seg->bs_be = be;
-	seg->bs_stob = stob;
-	seg->bs_state = M0_BSS_INIT;
+	seg->bs_id           = be->b_next_segid++;
+	seg->bs_addr         = NULL;
+	seg->bs_size         = 0;
+	seg->bs_be           = be;
+	seg->bs_stob         = stob;
+	seg->bs_state        = M0_BSS_INIT;
+	seg->bs_pgmap        = NULL;
+	seg->bs_pgnr         = 0;
 }
 
 M0_INTERNAL void m0_be_seg_fini(struct m0_be_seg *seg)
@@ -154,15 +160,18 @@ M0_INTERNAL void m0_be_seg_fini(struct m0_be_seg *seg)
 	M0_PRE(M0_IN(seg->bs_state, (M0_BSS_INIT, M0_BSS_CLOSED)));
 }
 
-M0_INTERNAL bool m0_be_seg__invariant(const struct m0_be_seg *seg)
+M0_INTERNAL bool m0_be__seg_invariant(const struct m0_be_seg *seg)
 {
-	return true;
+	return seg != NULL && seg->bs_addr != NULL && seg->bs_size > 0
+		&& seg->bs_pgmap != NULL && seg->bs_pgnr > 0;
 }
 
 bool m0_be__reg_invariant(const struct m0_be_reg *reg)
 {
 	return reg != NULL && reg->br_seg != NULL && reg->br_size > 0 &&
-		reg->br_addr != NULL;
+		reg->br_addr != NULL && m0_be__seg_invariant(reg->br_seg) &&
+		reg->br_addr >= reg->br_seg->bs_addr && reg->br_addr +
+		reg->br_size <= reg->br_seg->bs_addr + reg->br_seg->bs_size;
 }
 
 static int stob_io_single_read(void *buf, m0_bcount_t bufsize,
@@ -218,6 +227,7 @@ M0_INTERNAL int m0_be_seg_open(struct m0_be_seg *seg)
 	m0_bcount_t	      hdrblocks;   /* number of sectors */
 	void		     *seg_addr0;
 	m0_bcount_t	      seg_size;
+	m0_bcount_t	      i;
 	void		     *p;
 
 	/* Allocate buffer for segment header. */
@@ -241,6 +251,15 @@ M0_INTERNAL int m0_be_seg_open(struct m0_be_seg *seg)
 	if (rc != 0)
 		return rc;
 
+	/* Allocate page map. */
+	seg->bs_pgnr = (seg_size + st_block_size - 1) / st_block_size;
+	seg->bs_pgmap = m0_alloc_aligned(sizeof(m0_bcount_t) * seg->bs_pgnr,
+					 64);
+	if (seg->bs_pgmap == NULL)
+		return -ENOMEM;
+	for (i = 0; i < seg->bs_pgnr; i++)
+		seg->bs_pgmap[i] = 0; /* not present yet */
+
 	/* mmap an area at bh_addr of bh_size. */
 	p = mmap(seg_addr0, seg_size, PROT_READ|PROT_WRITE,
 		 MAP_FIXED|MAP_ANONYMOUS|MAP_PRIVATE, -1, 0);
@@ -251,8 +270,11 @@ M0_INTERNAL int m0_be_seg_open(struct m0_be_seg *seg)
 	/* Read whole segment from storage. */
 	rc = stob_io_single_read(seg_addr0, seg_size, seg->bs_stob,
 				 0, st_block_shift);
-	if (rc == 0)
+	if (rc == 0) {
 		seg->bs_state = M0_BSS_OPENED;
+		for (i = 0; i < seg->bs_pgnr; i++)
+			seg->bs_pgmap[i] |= M0_BE_SEG_PG_PRESENT;
+	}
 	return rc;
 }
 
diff --git a/be/seg.h b/be/seg.h
index f346591..aac5a44 100644
--- a/be/seg.h
+++ b/be/seg.h
@@ -40,6 +40,9 @@ enum m0_be_seg_states {
 	M0_BSS_CLOSED,
 };
 
+#define M0_BE_SEG_PG_PRESENT      0x8000000000000000ULL
+#define M0_BE_SEG_PIN_CNT_MASK    (~M0_BE_SEG_PG_PRESENT)
+
 struct m0_be_seg {
 	uint64_t               bs_id; /* see also m0_be::b_next_segid */
 	struct m0_stob        *bs_stob;
@@ -48,9 +51,11 @@ struct m0_be_seg {
 	struct m0_be_allocator bs_allocator;
 	struct m0_be          *bs_be;
 	int                    bs_state;
+	m0_bcount_t           *bs_pgmap;
+	m0_bcount_t            bs_pgnr;
 };
 
-M0_INTERNAL bool m0_be_seg__invariant(const struct m0_be_seg *seg);
+M0_INTERNAL bool m0_be__seg_invariant(const struct m0_be_seg *seg);
 
 M0_INTERNAL void m0_be_seg_init(struct m0_be_seg *seg,
 				struct m0_stob *stob,
-- 
1.8.3.2

