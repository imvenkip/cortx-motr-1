From c0ec6f34d9fbc2a8fb1af3f3f3fc040e0af486c3 Mon Sep 17 00:00:00 2001
From: "Valery V. Vorotyntsev" <valery_vorotyntsev@xyratex.com>
Date: Fri, 21 Jun 2013 16:43:40 +0300
Subject: [PATCH 207/228] be: insert Nikita's documentation into
 tx_group_close()

---
 be/tx_group.c | 65 +++++++++++++++++++++++++++++++++++++++++++++++++++++++----
 be/tx_log.c   | 31 ++++++++++++++++++++++++++--
 2 files changed, 90 insertions(+), 6 deletions(-)

diff --git a/be/tx_group.c b/be/tx_group.c
index d4d81cb..960df72 100644
--- a/be/tx_group.c
+++ b/be/tx_group.c
@@ -36,13 +36,14 @@ M0_TL_DEFINE(gr, M0_INTERNAL, struct m0_be_tx);
 
 M0_INTERNAL void tx_group_init(struct m0_be_tx_group *gr)
 {
-	/* M0_SET0(gr); */
-
+#if 0 /* Nikita's code. */
+	M0_SET0(gr);
+#else /*XXX*/
 	gr->tg_lsn = 0ULL;
 	gr->tg_opened = true;
 	m0_be_tx_credit_init(&gr->tg_used);
 	gr_tlist_init(&gr->tg_tx);
-
+#endif
 }
 
 M0_INTERNAL void tx_group_fini(struct m0_be_tx_group *gr)
@@ -60,10 +61,66 @@ M0_INTERNAL void tx_group_add(struct m0_be_tx_engine *eng,
 	/* gr->tg_used.     XXX: what's here? */
 }
 
+/**
+ * Closes a transaction group.
+ *
+ * A group is closed when it either grows too large or too old.
+ */
 M0_INTERNAL void
 tx_group_close(struct m0_be_tx_engine *eng, struct m0_be_tx_group *gr)
 {
-	gr->tg_opened = false;
+	/*
+	 * A group is stored as a contiguous extent of the logical log with the
+	 * following structre:
+	 *
+	 *         HEADER TX_HEADER* TX_BODY* COMMIT_BLOCK
+	 *
+	 * HEADER is struct tx_group_header in memory.
+	 *
+	 * COMMIT_BLOCK is struct tx_group_commit_block, duplicating HEADER
+	 * fields (except magic).
+	 *
+	 * TX_HEADER is struct tx_group_entry in memory.
+	 *
+	 * When a group is closed, it builds its in-memory representation by
+	 * filling group header and building an in-memory representation of
+	 * transaction headers.
+	 *
+	 * This representation is build in pre-allocated (during tx engine
+	 * initialisation) arrays of some maximal size. This size determines
+	 * maximal group size (m0_be_log::lg_gr_size_max, maybe this should be
+	 * changed into m0_be_tx_credit to account both for total size of
+	 * transactions and the number of regions in them).
+	 *
+	 * tx_reg_header-s are built by scanning m0_be_tx::t_reg_d_area-s of
+	 * group's transactions (skipping unused regions descriptors).
+	 *
+	 * Once tx_group_header and the array of tx_group_entry is built, it is
+	 * encoded, by means of xcode, in a single sufficiently large and
+	 * properly aligned buffer pre-allocated at transaction engine startup.
+	 *
+	 * Note that tx_reg_header::rh_lsn is the lsn of the corresponding
+	 * region contents in TX_BODY.
+	 *
+	 * Then, the group is written to the log: a bufvec for stobio is formed
+	 * to contain HEADER, TX_HEADER*, regions data from
+	 * m0_be_tx::t_reg_area-s. This bufvec is pre-allocated too.
+	 *
+	 * This IO is launched. States of group's trasaction are changed to
+	 * SUBMITTED.  When it completes, another IO for COMMIT_BLOCK is
+	 * launched. When this IO completes, transaction states are changed to
+	 * LOGGED, m0_be_tx::t_persistent() is invoked.
+	 *
+	 * Then, in-place IO is submitted to segments, directly from
+	 * m0_be_tx::t_reg_area-s, again using pre-allocated bufvec-s. In the
+	 * simplest case, each transaction is submitted as a single IO,
+	 * alternatively some grouping can be done. When in-place IO for a
+	 * transaction completes, the transaction state changes to PLACED.
+	 *
+	 * When all group's transactions reach PLACED state, the group is
+	 * finalised.
+	 */
+	gr->tg_opened = false; /* XXX FIXME */
 }
 
 /** @} end of be group */
diff --git a/be/tx_log.c b/be/tx_log.c
index 95fd8e4..a6aa6be 100644
--- a/be/tx_log.c
+++ b/be/tx_log.c
@@ -28,10 +28,37 @@
  */
 
 struct tx_group_header {
-};
+	uint64_t gh_lsn;
+	uint64_t gh_size;
+	uint64_t gh_tx_nr;
+	uint64_t gh_magic;
+} M0_XCA_RECORD;
+
+struct tx_group_commit_block {
+	uint64_t gc_lsn;
+	uint64_t gc_size;
+	uint64_t gc_tx_nr;
+	uint64_t gc_magic;
+} M0_XCA_RECORD;
+
+struct tx_reg_header {
+	uint64_t rh_seg_id;
+	uint64_t rh_offset;
+	uint64_t rh_size;
+	uint64_t rh_lsn;
+} M0_XCA_RECORD;
+
+struct tx_reg_sequence {
+	uint64_t              rs_nr;
+	struct tx_reg_header *rs_reg;
+} M0_XCA_SEQUENCE;
 
 struct tx_group_entry {
-};
+	uint64_t               ge_tid;
+	uint64_t               ge_lsn;
+	struct m0_buf          ge_payload;
+	struct tx_reg_sequence ge_reg;
+} M0_XCA_RECORD;
 
 struct tx_header {
 };
-- 
1.8.3.2

