From 8ad27c3b7764a82ed3275da46a9c5c44fea16757 Mon Sep 17 00:00:00 2001
From: Maxim Medved <Max_Medved@xyratex.com>
Date: Tue, 20 Aug 2013 15:12:02 +0300
Subject: [PATCH 08/34] be/seg: multiple segments can be created

---
 be/seg.c       | 27 +++++++++++++--------------
 be/seg.h       |  8 +++++++-
 be/ut/helper.c | 31 +++++++++++++++++++++++++++++--
 3 files changed, 49 insertions(+), 17 deletions(-)

diff --git a/be/seg.c b/be/seg.c
index 322756b..490d070 100644
--- a/be/seg.c
+++ b/be/seg.c
@@ -38,9 +38,6 @@
  * @{
  */
 
-#define BE_SEG_DEFAULT_ADDR   ((void *)0x400000000000)
-#define BE_SEG_HEADER_OFFSET  (0ULL)
-
 static int
 seg_header_create(struct m0_be_seg *seg, void *addr, m0_bcount_t size)
 {
@@ -60,13 +57,16 @@ seg_header_create(struct m0_be_seg *seg, void *addr, m0_bcount_t size)
 	seg->bs_addr = addr;
 	seg->bs_size = size;
 
-	hdr_reg = M0_BE_REG(seg, sizeof *hdrbuf, addr + BE_SEG_HEADER_OFFSET);
+	hdr_reg = M0_BE_REG(seg, sizeof *hdrbuf,
+			    addr + M0_BE_SEG_HEADER_OFFSET);
 	rc = m0_be_seg__write(&hdr_reg, hdrbuf);
 	m0_free(hdrbuf);
 	return rc;
 }
 
-M0_INTERNAL int m0_be_seg_create(struct m0_be_seg *seg, m0_bcount_t size)
+M0_INTERNAL int m0_be_seg_create(struct m0_be_seg *seg,
+				 m0_bcount_t size,
+				 void *addr)
 {
 	M0_PRE(seg->bs_state == M0_BSS_INIT);
 	M0_PRE(seg->bs_stob->so_domain != NULL);
@@ -75,7 +75,7 @@ M0_INTERNAL int m0_be_seg_create(struct m0_be_seg *seg, m0_bcount_t size)
 	return m0_stob_find(seg->bs_stob->so_domain,
 			    &seg->bs_stob->so_id, &seg->bs_stob) ?:
 		m0_stob_create(seg->bs_stob, NULL) ?:
-		seg_header_create(seg, BE_SEG_DEFAULT_ADDR, size);
+		seg_header_create(seg, addr, size);
 }
 
 M0_INTERNAL int m0_be_seg_destroy(struct m0_be_seg *seg)
@@ -94,8 +94,8 @@ M0_INTERNAL void m0_be_seg_init(struct m0_be_seg *seg,
 				struct m0_be_domain *dom)
 {
 	*seg = (struct m0_be_seg) {
-		/* XXX add BE_SEG_HEADER_OFFSET */
-		.bs_reserved = sizeof(struct m0_be_seg_hdr),
+		.bs_reserved = M0_BE_SEG_HEADER_OFFSET +
+			       sizeof(struct m0_be_seg_hdr),
 		.bs_domain   = dom,
 		.bs_stob     = stob,
 		.bs_state    = M0_BSS_INIT,
@@ -143,11 +143,10 @@ M0_INTERNAL int m0_be_seg_open(struct m0_be_seg *seg)
 		return -ENOMEM;
 
 	/* Read segment header from storage. */
-	seg->bs_addr = BE_SEG_DEFAULT_ADDR;
-	/* XXX */
-	seg->bs_size = 1ULL << 48;
+	seg->bs_addr = (void *) hdrbuf - M0_BE_SEG_HEADER_OFFSET;
+	seg->bs_size = sizeof *hdrbuf + M0_BE_SEG_HEADER_OFFSET;
 	hdr_reg = M0_BE_REG(seg, sizeof *hdrbuf,
-			    (char *)BE_SEG_DEFAULT_ADDR + BE_SEG_HEADER_OFFSET);
+			    seg->bs_addr + M0_BE_SEG_HEADER_OFFSET);
 	rc = m0_be_seg__read(&hdr_reg, hdrbuf);
 	if (rc == 0) {
 		seg_addr0 = hdrbuf->bh_addr;
@@ -176,13 +175,13 @@ M0_INTERNAL int m0_be_seg_open(struct m0_be_seg *seg)
 	M0_ASSERT(p == seg_addr0);
 
 	/* Read whole segment from storage. */
+	seg->bs_size = seg_size;
+	seg->bs_addr = seg_addr0;
 	rc = m0_be_seg__read(&M0_BE_REG(seg, seg_size, seg_addr0), seg_addr0);
 	if (rc == 0) {
 		seg->bs_state = M0_BSS_OPENED;
 		for (i = 0; i < seg->bs_pgnr; i++)
 			seg->bs_pgmap[i] |= M0_BE_SEG_PG_PRESENT;
-		seg->bs_size = seg_size;
-		seg->bs_addr = seg_addr0;
 	}
 	return rc;
 }
diff --git a/be/seg.h b/be/seg.h
index fcac7ee..d713a4c 100644
--- a/be/seg.h
+++ b/be/seg.h
@@ -42,6 +42,10 @@ enum m0_be_seg_states {
 	M0_BSS_CLOSED,
 };
 
+enum {
+	M0_BE_SEG_HEADER_OFFSET = 0ULL,
+};
+
 #define M0_BE_SEG_PG_PRESENT       0x8000000000000000ULL
 #define M0_BE_SEG_PG_PIN_CNT_MASK  (~M0_BE_SEG_PG_PRESENT)
 
@@ -74,7 +78,9 @@ M0_INTERNAL int m0_be_seg_open(struct m0_be_seg *seg);
 M0_INTERNAL void m0_be_seg_close(struct m0_be_seg *seg);
 
 /** Creates the segment of specified size on the storage. */
-M0_INTERNAL int m0_be_seg_create(struct m0_be_seg *seg, m0_bcount_t size);
+M0_INTERNAL int m0_be_seg_create(struct m0_be_seg *seg,
+				 m0_bcount_t size,
+				 void *addr);
 M0_INTERNAL int m0_be_seg_destroy(struct m0_be_seg *seg);
 
 M0_INTERNAL bool m0_be_seg_contains(const struct m0_be_seg *seg, void *addr);
diff --git a/be/ut/helper.c b/be/ut/helper.c
index f4a0869..9b25bdc 100644
--- a/be/ut/helper.c
+++ b/be/ut/helper.c
@@ -39,6 +39,30 @@
 
 struct m0_sm_group ut__txs_sm_group;
 
+enum {
+	BE_UT_SEG_START_ADDR = 0x400000000000ULL,
+	BE_UT_SEG_START_ID   = 42ULL,
+};
+
+static struct m0_atomic64 be_ut_seg_addr;
+static struct m0_atomic64 be_ut_seg_id;
+
+static void *be_ut_seg_allocate_addr(m0_bcount_t size)
+{
+	/* initialize start addr if it wasn't already initialized */
+	m0_atomic64_cas((int64_t *) &be_ut_seg_addr,
+			0, BE_UT_SEG_START_ADDR);
+	size = m0_align(size, m0_pagesize_get());
+	return (void *) (m0_atomic64_add_return(&be_ut_seg_addr, size) - size);
+}
+
+static uint64_t be_ut_seg_allocate_id(void)
+{
+	m0_atomic64_cas((int64_t *) &be_ut_seg_id,
+			0, BE_UT_SEG_START_ID);
+	return m0_atomic64_add_return(&be_ut_seg_id, 1) - 1;
+}
+
 void m0_be_ut_backend_init(struct m0_be_ut_backend *ut_be)
 {
 #define NAME(ext) "be-ut" ext
@@ -107,7 +131,9 @@ static void be_ut_seg_init(struct m0_be_ut_seg *ut_seg,
 			   m0_bcount_t size,
 			   bool stob_create)
 {
-	struct m0_stob_id stob_id = { .si_bits = M0_UINT128(0, 42) };
+	struct m0_stob_id stob_id = {
+		.si_bits = M0_UINT128(0, be_ut_seg_allocate_id())
+	};
 	int               rc;
 
 	rc = system("rm -rf " BE_UT_H_STORAGE_DIR);
@@ -130,7 +156,8 @@ static void be_ut_seg_init(struct m0_be_ut_seg *ut_seg,
 	}
 
 	m0_be_seg_init(&ut_seg->bus_seg, ut_seg->bus_stob, &ut_be->but_dom);
-	rc = m0_be_seg_create(&ut_seg->bus_seg, size);
+	rc = m0_be_seg_create(&ut_seg->bus_seg, size,
+			      be_ut_seg_allocate_addr(size));
 	M0_ASSERT(rc == 0);
 	rc = m0_be_seg_open(&ut_seg->bus_seg);
 	M0_ASSERT(rc == 0);
-- 
1.8.3.2

