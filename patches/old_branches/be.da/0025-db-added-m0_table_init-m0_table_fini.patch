From 21ba1b93e14a7c83d0dc551fa7b532ea256dd6fb Mon Sep 17 00:00:00 2001
From: Anatoliy Bilenko <anatoliy_bilenko@xyratex.com>
Date: Wed, 21 Aug 2013 16:45:46 +0300
Subject: [PATCH 25/34] db: added m0_table_init()/m0_table_fini()

---
 db/db.c | 57 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++-
 1 file changed, 56 insertions(+), 1 deletion(-)

diff --git a/db/db.c b/db/db.c
index 70e9efb..9c2c474 100644
--- a/db/db.c
+++ b/db/db.c
@@ -49,6 +49,7 @@
 #include "ut/ast_thread.h"/* XXX: m0_ut_ast_thread_start */
 
 #include "stob/linux.h"		/* m0_linux_stob_domain_locate */
+#include "be/tx.h"
 
 /**
    @addtogroup db
@@ -151,11 +152,65 @@ M0_INTERNAL int m0_table_init(struct m0_table *table, struct m0_dbenv *env,
 			      const char *name, uint64_t flags,
 			      const struct m0_table_ops *ops)
 {
-	return -1;
+	M0_BE_TX_CREDIT(cred);
+	struct m0_be_op        op;
+	struct m0_be_tx       *tx;
+	struct m0_sm_group    *grp = NULL; /* XXX */
+	struct m0_be_seg      *seg = env->d_i.d_seg;
+	struct m0_be_btree     dummy = { .bb_seg = seg };
+	void *p;
+	int   rc;
+
+	rc = m0_be_seg_dict_lookup(seg, name, &p);
+	if (rc == 0) {
+		table->t_i.i_tree = (struct m0_be_btree*)p;
+		return 0;
+	}
+
+	M0_ALLOC_PTR(tx);
+	if (tx == NULL)
+		return -ENOMEM;
+
+	m0_be_btree_create_credit(&dummy, 1, &cred);
+	m0_be_allocator_credit(&seg->bs_allocator, M0_BAO_ALLOC,
+			       sizeof(struct m0_be_btree), 0, &cred);
+
+	m0_be_tx_init(tx, 0, env->d_i.d_dom, grp, NULL, NULL, NULL, NULL);
+	m0_be_tx_prep(tx, &cred);
+	m0_be_tx_open(tx);
+	rc = m0_be_tx_timedwait(tx, M0_BITS(M0_BTS_ACTIVE, M0_BTS_FAILED),
+				M0_TIME_NEVER);
+	if (rc != 0 || m0_be_tx_state(tx) != M0_BTS_ACTIVE) {
+		m0_be_tx_fini(tx);
+		m0_free(tx);
+		return -EFBIG;
+	}
+
+	m0_be_op_init(&op);
+	table->t_i.i_tree = m0_be_alloc(&seg->bs_allocator, tx, &op,
+				       sizeof(struct m0_be_btree), 0);
+	m0_be_op_wait(&op);
+	M0_ASSERT(m0_be_op_state(&op) == M0_BOS_SUCCESS);
+	m0_be_op_fini(&op);
+
+	m0_be_op_init(&op);
+	m0_be_btree_init(table->t_i.i_tree, seg, ops->ops);
+	m0_be_btree_create(table->t_i.i_tree, tx, &op);
+	m0_be_op_wait(&op);
+	M0_ASSERT(m0_be_op_state(&op) == M0_BOS_SUCCESS);
+	m0_be_op_fini(&op);
+
+	m0_be_tx_close(tx);
+	rc = m0_be_tx_timedwait(tx, M0_BITS(M0_BTS_DONE), M0_TIME_NEVER) ?:
+		m0_be_seg_dict_insert(seg, grp, name, table->t_i.i_tree);
+	m0_be_tx_fini(tx);
+	m0_free(tx);
+	return rc;
 }
 
 M0_INTERNAL void m0_table_fini(struct m0_table *table)
 {
+	m0_be_btree_fini(table->t_i.i_tree);
 }
 
 M0_INTERNAL void m0_db_buf_impl_init(struct m0_db_buf *buf)
-- 
1.8.3.2

