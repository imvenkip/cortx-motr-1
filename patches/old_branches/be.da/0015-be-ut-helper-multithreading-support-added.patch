From fe9a638c265f889e08ae563cefdd4ba3b9b357f1 Mon Sep 17 00:00:00 2001
From: Maxim Medved <Max_Medved@xyratex.com>
Date: Wed, 21 Aug 2013 03:41:21 +0300
Subject: [PATCH 15/34] be/ut/helper: multithreading support added

there is no ut__txs_sm_group in be/ut/helper anymore;
ut__txs_sm_group moved to be/ast_thread.c;
m0_be_ut_backend now manages groups and ast threads for transactions;
be_ut_reqh_{get,put}() added for reqh init (ref counter semantic);
m0_be_ut_backend_thread_exit() should be called in all threads except
        main thread after m0_be_ut_tx_init(), see be-ut:tx-concurrent
	for example;
be-ut:tx-concurrent implemented.
---
 be/ut/dict.c    |  11 +-
 be/ut/helper.c  | 355 +++++++++++++++++++++++++++++++++++++++++++-------------
 be/ut/helper.h  |  37 ++++--
 be/ut/main.c    |  26 ++---
 be/ut/tx.c      |  23 ++--
 ut/ast_thread.c |   4 +
 6 files changed, 331 insertions(+), 125 deletions(-)

diff --git a/be/ut/dict.c b/be/ut/dict.c
index 8c8e8fa..bdd7750 100644
--- a/be/ut/dict.c
+++ b/be/ut/dict.c
@@ -24,12 +24,11 @@
 #include "be/ut/helper.h"	/* m0_be_ut_backend */
 #include "ut/ut.h"
 
-extern struct m0_sm_group      ut__txs_sm_group;
-
 void m0_be_ut_dict(void)
 {
 	struct m0_be_ut_backend ut_be;
 	struct m0_be_ut_seg     ut_seg;
+	struct m0_sm_group     *grp;
 	struct m0_be_seg       *seg = &ut_seg.bus_seg;
 	void                   *p;
 	int                     i;
@@ -51,11 +50,12 @@ void m0_be_ut_dict(void)
 	m0_be_ut_seg_init(&ut_seg, &ut_be, 1 << 20);
 	m0_be_ut_seg_allocator_init(&ut_seg, &ut_be);
 
-	rc = m0_be_seg_dict_create(seg, &ut__txs_sm_group);
+	grp = m0_be_ut_backend_sm_group_lookup(&ut_be);
+	rc = m0_be_seg_dict_create(seg, grp);
 	M0_UT_ASSERT(rc == 0);
 
 	for (i = 0; i < ARRAY_SIZE(dict); ++i) {
-		rc = m0_be_seg_dict_insert(seg, &ut__txs_sm_group, dict[i].name,
+		rc = m0_be_seg_dict_insert(seg, grp, dict[i].name,
 					   dict[i].value);
 		M0_UT_ASSERT(rc == 0);
 	}
@@ -66,8 +66,7 @@ void m0_be_ut_dict(void)
 	}
 
 	for (i = 0; i < ARRAY_SIZE(dict); i+=2) {
-		rc = m0_be_seg_dict_delete(seg, &ut__txs_sm_group,
-					   dict[i].name);
+		rc = m0_be_seg_dict_delete(seg, grp, dict[i].name);
 		M0_UT_ASSERT(rc == 0);
 	}
 
diff --git a/be/ut/helper.c b/be/ut/helper.c
index 966a6f9..adc601f 100644
--- a/be/ut/helper.c
+++ b/be/ut/helper.c
@@ -21,103 +21,231 @@
 #define M0_TRACE_SUBSYSTEM M0_TRACE_SUBSYS_UT
 #include "lib/trace.h"
 
+#include "be/ut/helper.h"	/* m0_be_ut_backend */
+
 #include "lib/memory.h"		/* m0_alloc */
 #include "lib/misc.h"		/* M0_BITS */
 #include "lib/arith.h"		/* M0_CNT_INC */
-
-#include "be/ut/helper.h"	/* m0_be_ut_backend */
+#include "lib/errno.h"		/* ENOMEM */
 
 #include "stob/stob.h"		/* m0_stob_id */
 #include "stob/linux.h"		/* m0_linux_stob_domain_locate */
 #include "dtm/dtm.h"		/* m0_dtx_init */
 #include "rpc/rpclib.h"		/* m0_rpc_server_start */
+#include "net/net.h"		/* m0_net_xprt */
 
 #include <stdlib.h>		/* system */
+
 #include <sys/stat.h>		/* mkdir */
 #include <sys/types.h>		/* mkdir */
-
-#include <stdlib.h>		/* atexit */
 #include <pthread.h>		/* pthread_once */
+#include <unistd.h>		/* syscall */
+#include <sys/syscall.h>	/* syscall */
 
 #define BE_UT_H_STORAGE_DIR "./__seg_ut_stob"
 
-struct m0_sm_group ut__txs_sm_group;
-
 enum {
 	BE_UT_SEG_START_ADDR = 0x400000000000ULL,
 	BE_UT_SEG_START_ID   = 42ULL,
 };
 
-static pthread_once_t	      be_ut_seg_once_control = PTHREAD_ONCE_INIT;
-static struct m0_mutex	      be_ut_seg_lock;
-static struct m0_stob_domain *be_ut_seg_stob_dom;
-static void		     *be_ut_seg_addr;
-static uint64_t		      be_ut_seg_id;
-static int		      be_ut_seg_storage_ref_cnt;
+struct be_ut_helper_struct {
+	struct m0_net_xprt      *buh_net_xprt;
+	struct m0_rpc_server_ctx buh_rpc_sctx;
+	int			 buh_reqh_ref_cnt;
+	pthread_once_t		 buh_once_control;
+	struct m0_mutex		 buh_lock;
+	struct m0_stob_domain	*buh_stob_dom;
+	void			*buh_addr;
+	uint64_t		 buh_id;
+	int			 buh_storage_ref_cnt;
+};
+
+struct be_ut_helper_struct be_ut_helper = {
+	/* because there is no m0_mutex static initializer */
+	.buh_once_control = PTHREAD_ONCE_INIT,
+};
+
 
-static void *be_ut_seg_allocate_addr(m0_bcount_t size)
+static void *be_ut_seg_allocate_addr(struct be_ut_helper_struct *h,
+				     m0_bcount_t size)
 {
 	void *addr;
 
 	size = m0_align(size, m0_pagesize_get());
 
-	m0_mutex_lock(&be_ut_seg_lock);
-	addr		= be_ut_seg_addr;
-	be_ut_seg_addr += size;
-	m0_mutex_unlock(&be_ut_seg_lock);
+	m0_mutex_lock(&h->buh_lock);
+	addr	     = h->buh_addr;
+	h->buh_addr += size;
+	m0_mutex_unlock(&h->buh_lock);
 
 	return addr;
 }
 
-static uint64_t be_ut_seg_allocate_id(void)
+static uint64_t be_ut_seg_allocate_id(struct be_ut_helper_struct *h)
 {
 	uint64_t id;
 
-	m0_mutex_lock(&be_ut_seg_lock);
-	id = be_ut_seg_id++;
-	m0_mutex_unlock(&be_ut_seg_lock);
+	m0_mutex_lock(&h->buh_lock);
+	id = h->buh_id++;
+	m0_mutex_unlock(&h->buh_lock);
 
 	return id;
 }
 
-static inline void be_ut_seg_fini_once(void)
+static inline void be_ut_helper_fini(void)
 {
-	M0_PRE(be_ut_seg_stob_dom == NULL);
-	M0_PRE(be_ut_seg_storage_ref_cnt == 0);
-	m0_mutex_fini(&be_ut_seg_lock);
+	struct be_ut_helper_struct *h = &be_ut_helper;
+
+	M0_PRE(h->buh_stob_dom == NULL);
+	M0_PRE(h->buh_storage_ref_cnt == 0);
+	m0_mutex_fini(&h->buh_lock);
 }
 
 /* XXX call this function from m0_init()? */
-static void be_ut_seg_init_once(void)
+static void be_ut_helper_init(void)
 {
-	be_ut_seg_addr = (void *) BE_UT_SEG_START_ADDR;
-	be_ut_seg_id   = BE_UT_SEG_START_ID;
-	m0_mutex_init(&be_ut_seg_lock);
-	be_ut_seg_storage_ref_cnt = 0;
-	be_ut_seg_stob_dom = NULL;
-	atexit(&be_ut_seg_fini_once);	/* XXX REFACTORME */
+	struct be_ut_helper_struct *h = &be_ut_helper;
+
+	h->buh_reqh_ref_cnt    = 0,
+	h->buh_storage_ref_cnt = 0,
+	h->buh_stob_dom	       = NULL,
+	h->buh_addr	       = (void *) BE_UT_SEG_START_ADDR,
+	h->buh_id	       = BE_UT_SEG_START_ID,
+	m0_mutex_init(&h->buh_lock);
+	atexit(&be_ut_helper_fini);	/* XXX REFACTORME */
 }
 
-void m0_be_ut_backend_init(struct m0_be_ut_backend *ut_be)
+static void be_ut_helper_init_once(void)
 {
+	int rc;
+
+	rc = pthread_once(&be_ut_helper.buh_once_control, &be_ut_helper_init);
+	M0_ASSERT(rc == 0);
+}
+
+static struct m0_reqh *be_ut_reqh_get(void)
+{
+	struct be_ut_helper_struct *h = &be_ut_helper;
+	struct m0_reqh		   *reqh;
+	int			    rc;
 #define NAME(ext) "be-ut" ext
-	static char    *argv[] = {
+	static char		   *argv[] = {
 		NAME(""), "-r", "-p", "-T", "AD", "-D", NAME(".db"),
 		"-S", NAME(".stob"), "-A", NAME("_addb.stob"), "-w", "10",
 		"-e", "lnet:0@lo:12345:34:1", "-s", "be-tx-service"
 	};
-	struct m0_reqh *reqh;
-	int             rc;
 
-	*ut_be = (struct m0_be_ut_backend) {
-		.but_net_xprt = &m0_net_lnet_xprt,
-		.but_rpc_sctx = {
-			.rsx_xprts         = &ut_be->but_net_xprt,
+	be_ut_helper_init_once();
+
+	m0_mutex_lock(&h->buh_lock);
+	if (h->buh_reqh_ref_cnt == 0) {
+		h->buh_net_xprt = &m0_net_lnet_xprt;
+		h->buh_rpc_sctx = (struct m0_rpc_server_ctx) {
+			.rsx_xprts         = &h->buh_net_xprt,
 			.rsx_xprts_nr      = 1,
 			.rsx_argv          = argv,
 			.rsx_argc          = ARRAY_SIZE(argv),
-			.rsx_log_file_name = NAME(".log")
-		},
+			.rsx_log_file_name = NAME(".log"),
+		};
+#undef NAME
+		rc = m0_net_xprt_init(h->buh_net_xprt);
+		M0_ASSERT(rc == 0);
+		rc = m0_rpc_server_start(&h->buh_rpc_sctx);
+		M0_ASSERT(rc == 0);
+	}
+	M0_CNT_INC(h->buh_reqh_ref_cnt);
+	reqh = m0_mero_to_rmach(&h->buh_rpc_sctx.rsx_mero_ctx)->rm_reqh;
+	M0_ASSERT(reqh != NULL);
+	m0_mutex_unlock(&h->buh_lock);
+
+	return reqh;
+}
+
+static void be_ut_reqh_put(struct m0_reqh *reqh)
+{
+	struct be_ut_helper_struct *h = &be_ut_helper;
+	struct m0_reqh		   *reqh2;
+
+	m0_mutex_lock(&h->buh_lock);
+	reqh2 = m0_mero_to_rmach(&h->buh_rpc_sctx.rsx_mero_ctx)->rm_reqh;
+	M0_ASSERT(reqh == reqh2);
+	M0_CNT_DEC(h->buh_reqh_ref_cnt);
+	if (h->buh_reqh_ref_cnt == 0) {
+		m0_rpc_server_stop(&h->buh_rpc_sctx);
+		m0_net_xprt_fini(h->buh_net_xprt);
+	}
+	m0_mutex_unlock(&h->buh_lock);
+}
+
+static pid_t gettid()
+{
+	return syscall(SYS_gettid);
+}
+
+static void be_ut_sm_group_thread_func(struct m0_be_ut_sm_group_thread *sgt)
+{
+	struct m0_sm_group *grp = &sgt->sgt_grp;
+
+	while (!m0_semaphore_trydown(&sgt->sgt_stop_sem)) {
+		m0_chan_wait(&grp->s_clink);
+		m0_sm_group_lock(grp);
+		m0_sm_asts_run(grp);
+		m0_sm_group_unlock(grp);
+	}
+}
+
+static int m0_be_ut_sm_group_thread_init(struct m0_be_ut_sm_group_thread **sgtp)
+{
+	struct m0_be_ut_sm_group_thread *sgt;
+	int				 rc;
+
+	M0_ALLOC_PTR(*sgtp);
+	sgt = *sgtp;
+	if (sgt != NULL) {
+		sgt->sgt_tid = gettid();
+		m0_sm_group_init(&sgt->sgt_grp);
+		m0_semaphore_init(&sgt->sgt_stop_sem, 0);
+		rc = M0_THREAD_INIT(&sgt->sgt_thread,
+				    struct m0_be_ut_sm_group_thread *,
+				    NULL, &be_ut_sm_group_thread_func, sgt,
+				    "%pbe_sm_group_thread", sgt);
+		if (rc == 0) {
+			m0_sm_group_lock(&sgt->sgt_grp);
+		} else {
+			m0_semaphore_fini(&sgt->sgt_stop_sem);
+			m0_sm_group_fini(&sgt->sgt_grp);
+			m0_free(sgt);
+		}
+	} else {
+		rc = -ENOMEM;
+	}
+	return rc;
+}
+
+static void m0_be_ut_sm_group_thread_fini(struct m0_be_ut_sm_group_thread *sgt)
+{
+	int rc;
+
+	m0_semaphore_up(&sgt->sgt_stop_sem);
+
+	m0_clink_signal(&sgt->sgt_grp.s_clink);
+	m0_sm_group_unlock(&sgt->sgt_grp);
+
+	rc = m0_thread_join(&sgt->sgt_thread);
+	M0_ASSERT(rc == 0);
+	m0_thread_fini(&sgt->sgt_thread);
+
+	m0_semaphore_fini(&sgt->sgt_stop_sem);
+	m0_sm_group_fini(&sgt->sgt_grp);
+	m0_free(sgt);
+}
+
+void m0_be_ut_backend_init(struct m0_be_ut_backend *ut_be)
+{
+	int rc;
+
+	*ut_be = (struct m0_be_ut_backend) {
 		.but_dom_cfg = {
 			.bc_engine = {
 				.bec_group_nr = 1,
@@ -126,39 +254,102 @@ void m0_be_ut_backend_init(struct m0_be_ut_backend *ut_be)
 					1 << 20, 1 << 26),
 				.bec_group_size_max = M0_BE_TX_CREDIT_INIT(
 					1 << 21, 1 << 27),
-				.bec_group_tx_max = 20
+				.bec_group_tx_max = 20,
+				.bec_group_fom_reqh = be_ut_reqh_get(),
 			},
 		},
 	};
-#undef NAME
-
-	rc = m0_net_xprt_init(ut_be->but_net_xprt);
-	M0_ASSERT(rc == 0);
-	rc = m0_rpc_server_start(&ut_be->but_rpc_sctx);
-	M0_ASSERT(rc == 0);
-
-	reqh = m0_mero_to_rmach(&ut_be->but_rpc_sctx.rsx_mero_ctx)->rm_reqh;
-	M0_ASSERT(reqh != NULL);
-	ut_be->but_dom_cfg.bc_engine.bec_group_fom_reqh = reqh;
 
+	m0_mutex_init(&ut_be->but_sgt_lock);
 	rc = m0_be_domain_init(&ut_be->but_dom, &ut_be->but_dom_cfg);
 	M0_ASSERT(rc == 0);
 
-	m0_sm_group_lock(&ut__txs_sm_group); /* XXX fix it using fom-simple */
+	if (rc != 0)
+		m0_mutex_fini(&ut_be->but_sgt_lock);
 }
 
 void m0_be_ut_backend_fini(struct m0_be_ut_backend *ut_be)
 {
-	m0_sm_group_unlock(&ut__txs_sm_group);	/* XXX FIXME */
+	m0_forall(i, ut_be->but_sgt_size,
+		  m0_be_ut_sm_group_thread_fini(ut_be->but_sgt[i]), true);
 	m0_be_domain_fini(&ut_be->but_dom);
-	m0_rpc_server_stop(&ut_be->but_rpc_sctx);
-	m0_net_xprt_fini(ut_be->but_net_xprt);
+	m0_mutex_fini(&ut_be->but_sgt_lock);
+	be_ut_reqh_put(ut_be->but_dom_cfg.bc_engine.bec_group_fom_reqh);
+}
+
+static void be_ut_sm_group_thread_add(struct m0_be_ut_backend *ut_be,
+				      struct m0_be_ut_sm_group_thread *sgt)
+{
+	struct m0_be_ut_sm_group_thread **sgt_arr;
+	size_t				  size = ut_be->but_sgt_size;
+
+	M0_ALLOC_ARR(sgt_arr, size + 1);
+	M0_ASSERT(sgt_arr != NULL);
+
+	m0_forall(i, size, sgt_arr[i] = ut_be->but_sgt[i], true);
+	sgt_arr[size] = sgt;
+
+	m0_free(ut_be->but_sgt);
+	ut_be->but_sgt = sgt_arr;
+	++ut_be->but_sgt_size;
+}
+
+static size_t be_ut_backend_sm_group_find(struct m0_be_ut_backend *ut_be)
+{
+	size_t i;
+	pid_t  tid = gettid();
+
+	for (i = 0; i < ut_be->but_sgt_size; ++i) {
+		if (ut_be->but_sgt[i]->sgt_tid == tid)
+			break;
+	}
+	return i;
+}
+
+struct m0_sm_group *
+m0_be_ut_backend_sm_group_lookup(struct m0_be_ut_backend *ut_be)
+{
+	struct m0_be_ut_sm_group_thread	*sgt;
+	struct m0_sm_group		*grp = NULL;
+	pid_t				 tid = gettid();
+	int				 rc;
+
+	m0_mutex_lock(&ut_be->but_sgt_lock);
+	m0_forall(i, ut_be->but_sgt_size, sgt = ut_be->but_sgt[i],
+		  grp = sgt->sgt_tid == tid ? &sgt->sgt_grp : NULL,
+		  grp == NULL);
+	if (grp == NULL) {
+		rc = m0_be_ut_sm_group_thread_init(&sgt);
+		M0_ASSERT(rc == 0);
+		be_ut_sm_group_thread_add(ut_be, sgt);
+		grp = &sgt->sgt_grp;
+	}
+	m0_mutex_unlock(&ut_be->but_sgt_lock);
+	M0_POST(grp != NULL);
+	return grp;
+}
+
+void m0_be_ut_backend_thread_exit(struct m0_be_ut_backend *ut_be)
+{
+	size_t index;
+	size_t i;
+
+	m0_mutex_lock(&ut_be->but_sgt_lock);
+	index = be_ut_backend_sm_group_find(ut_be);
+	if (index != ut_be->but_sgt_size) {
+		m0_be_ut_sm_group_thread_fini(ut_be->but_sgt[index]);
+		for (i = index + 1; i < ut_be->but_sgt_size; ++i)
+			ut_be->but_sgt[i - 1] = ut_be->but_sgt[i];
+		--ut_be->but_sgt_size;
+	}
+	m0_mutex_unlock(&ut_be->but_sgt_lock);
 }
 
 void m0_be_ut_tx_init(struct m0_be_tx *tx, struct m0_be_ut_backend *ut_be)
 {
-	m0_be_tx_init(tx, 0, &ut_be->but_dom, &ut__txs_sm_group, NULL, NULL,
-		      NULL, NULL);
+	m0_be_tx_init(tx, 0, &ut_be->but_dom,
+		      m0_be_ut_backend_sm_group_lookup(ut_be),
+		      NULL, NULL, NULL, NULL);
 }
 
 static void be_ut_seg_init(struct m0_be_ut_seg *ut_seg,
@@ -166,18 +357,17 @@ static void be_ut_seg_init(struct m0_be_ut_seg *ut_seg,
 			   m0_bcount_t size,
 			   bool stob_create)
 {
-	struct m0_stob_id stob_id = {
-		.si_bits = M0_UINT128(0, be_ut_seg_allocate_id())
-	};
-	int               rc;
+	struct be_ut_helper_struct *h = &be_ut_helper;
+	struct m0_stob_id	    stob_id;
+	int			    rc;
 
-	/* init be_ut_seg_lock */
-	rc = pthread_once(&be_ut_seg_once_control, &be_ut_seg_init_once);
-	M0_ASSERT(rc == 0);
+	be_ut_helper_init_once();
 
-	m0_mutex_lock(&be_ut_seg_lock);
+	stob_id.si_bits = M0_UINT128(0, be_ut_seg_allocate_id(h));
 
-	if (be_ut_seg_storage_ref_cnt == 0) {
+	m0_mutex_lock(&h->buh_lock);
+
+	if (h->buh_storage_ref_cnt == 0) {
 		rc = system("rm -rf " BE_UT_H_STORAGE_DIR);
 		M0_ASSERT(rc == 0);
 		rc = mkdir(BE_UT_H_STORAGE_DIR, 0700);
@@ -185,28 +375,28 @@ static void be_ut_seg_init(struct m0_be_ut_seg *ut_seg,
 		rc = mkdir(BE_UT_H_STORAGE_DIR "/o", 0700);
 		M0_ASSERT(rc == 0);
 
-		M0_PRE(be_ut_seg_stob_dom == NULL);
+		M0_PRE(h->buh_stob_dom == NULL);
 		rc = m0_linux_stob_domain_locate(BE_UT_H_STORAGE_DIR,
-						 &be_ut_seg_stob_dom);
+						 &h->buh_stob_dom);
 		M0_ASSERT(rc == 0);
 	}
-	M0_CNT_INC(be_ut_seg_storage_ref_cnt);
+	M0_CNT_INC(h->buh_storage_ref_cnt);
 
 	m0_dtx_init(&ut_seg->bus_dtx);
 	if (stob_create) {
-		rc = m0_stob_create_helper(be_ut_seg_stob_dom, &ut_seg->bus_dtx,
+		rc = m0_stob_create_helper(h->buh_stob_dom, &ut_seg->bus_dtx,
 					   &stob_id, &ut_seg->bus_stob);
 		M0_ASSERT(rc == 0);
 	} else {
-		m0_stob_init(&ut_seg->bus_stob_, &stob_id, be_ut_seg_stob_dom);
+		m0_stob_init(&ut_seg->bus_stob_, &stob_id, h->buh_stob_dom);
 		ut_seg->bus_stob = &ut_seg->bus_stob_;
 	}
 
-	m0_mutex_unlock(&be_ut_seg_lock);
+	m0_mutex_unlock(&h->buh_lock);
 
 	m0_be_seg_init(&ut_seg->bus_seg, ut_seg->bus_stob, &ut_be->but_dom);
 	rc = m0_be_seg_create(&ut_seg->bus_seg, size,
-			      be_ut_seg_allocate_addr(size));
+			      be_ut_seg_allocate_addr(h, size));
 	M0_ASSERT(rc == 0);
 	rc = m0_be_seg_open(&ut_seg->bus_seg);
 	M0_ASSERT(rc == 0);
@@ -214,28 +404,29 @@ static void be_ut_seg_init(struct m0_be_ut_seg *ut_seg,
 
 static void be_ut_seg_fini(struct m0_be_ut_seg *ut_seg, bool stob_destroy)
 {
-	int rc;
+	struct be_ut_helper_struct *h = &be_ut_helper;
+	int			    rc;
 
 	m0_be_seg_close(&ut_seg->bus_seg);
 	rc = m0_be_seg_destroy(&ut_seg->bus_seg);
 	M0_ASSERT(rc == 0);
 	m0_be_seg_fini(&ut_seg->bus_seg);
 
-	m0_mutex_lock(&be_ut_seg_lock);
+	m0_mutex_lock(&h->buh_lock);
 	if (stob_destroy)
 		m0_stob_put(ut_seg->bus_stob);
 	m0_dtx_fini(&ut_seg->bus_dtx);
 
-	M0_CNT_DEC(be_ut_seg_storage_ref_cnt);
-	if (be_ut_seg_storage_ref_cnt == 0) {
-		be_ut_seg_stob_dom->sd_ops->sdo_fini(be_ut_seg_stob_dom);
-		be_ut_seg_stob_dom = NULL;
+	M0_CNT_DEC(h->buh_storage_ref_cnt);
+	if (h->buh_storage_ref_cnt == 0) {
+		h->buh_stob_dom->sd_ops->sdo_fini(h->buh_stob_dom);
+		h->buh_stob_dom = NULL;
 		if (stob_destroy) {
 			rc = system("rm -rf " BE_UT_H_STORAGE_DIR);
 			M0_ASSERT(rc == 0);
 		}
 	}
-	m0_mutex_unlock(&be_ut_seg_lock);
+	m0_mutex_unlock(&h->buh_lock);
 }
 
 void m0_be_ut_seg_init(struct m0_be_ut_seg *ut_seg,
diff --git a/be/ut/helper.h b/be/ut/helper.h
index 66a5c84..44e229c 100644
--- a/be/ut/helper.h
+++ b/be/ut/helper.h
@@ -22,23 +22,40 @@
 #ifndef __MERO_BE_UT_HELPER_H__
 #define __MERO_BE_UT_HELPER_H__
 
-#include "lib/types.h"   /* bool */
-#include "be/be.h"       /* m0_be */
-#include "be/domain.h"   /* m0_be_domain */
-#include "dtm/dtm.h"     /* m0_dtx */
-#include "net/net.h"     /* m0_net_xprt */
-#include "rpc/rpclib.h"  /* m0_rpc_server_ctx */
+#include "lib/types.h"		/* bool */
+
+#include "sm/sm.h"		/* m0_sm */
+#include "stob/stob.h"		/* m0_stob */
+
+#include "be/be.h"		/* m0_be */
+#include "be/domain.h"		/* m0_be_domain */
+#include "be/seg.h"		/* m0_be_seg */
+
+#include <sys/types.h>		/* pid_t */
+
+struct m0_be_ut_sm_group_thread {
+	struct m0_thread    sgt_thread;
+	pid_t		    sgt_tid;
+	struct m0_semaphore sgt_stop_sem;
+	struct m0_sm_group  sgt_grp;
+};
 
 struct m0_be_ut_backend {
-	struct m0_net_xprt      *but_net_xprt;
-	struct m0_rpc_server_ctx but_rpc_sctx;
-	struct m0_be_domain      but_dom;
-	struct m0_be_domain_cfg  but_dom_cfg;
+	struct m0_be_domain		  but_dom;
+	struct m0_be_domain_cfg		  but_dom_cfg;
+	struct m0_be_ut_sm_group_thread **but_sgt;
+	size_t				  but_sgt_size;
+	struct m0_mutex			  but_sgt_lock;
 };
 
 void m0_be_ut_backend_init(struct m0_be_ut_backend *ut_be);
 void m0_be_ut_backend_fini(struct m0_be_ut_backend *ut_be);
 
+struct m0_sm_group *
+m0_be_ut_backend_sm_group_lookup(struct m0_be_ut_backend *ut_be);
+
+void m0_be_ut_backend_thread_exit(struct m0_be_ut_backend *ut_be);
+
 /* will work with single thread only */
 void m0_be_ut_tx_init(struct m0_be_tx *tx, struct m0_be_ut_backend *ut_be);
 
diff --git a/be/ut/main.c b/be/ut/main.c
index 4605c60..ba61935 100644
--- a/be/ut/main.c
+++ b/be/ut/main.c
@@ -21,6 +21,11 @@
 #include "ut/ut.h"
 #include "ut/ast_thread.h"
 
+/*
+ * TODO
+ * - XXX s/rand_r/m0_rnd/g
+ */
+
 extern void m0_be_ut_reg_d_tree(void);
 extern void m0_be_ut_regmap_simple(void);
 extern void m0_be_ut_regmap_random(void);
@@ -63,25 +68,10 @@ extern void m0_be_ut_btree_simple(void);
 extern void m0_be_ut_emap(void);
 extern void m0_be_ut_dict(void);
 
-extern struct m0_sm_group ut__txs_sm_group;
-
-static int be_ut_init(void)
-{
-	m0_sm_group_init(&ut__txs_sm_group);
-	return m0_ut_ast_thread_start(&ut__txs_sm_group);
-}
-
-static int be_ut_fini(void)
-{
-	m0_ut_ast_thread_stop();
-	m0_sm_group_fini(&ut__txs_sm_group);
-	return 0;
-}
-
 const struct m0_test_suite be_ut = {
 	.ts_name = "be-ut",
-	.ts_init = be_ut_init,
-	.ts_fini = be_ut_fini,
+	.ts_init = NULL,
+	.ts_fini = NULL,
 	.ts_tests = {
 		{ "reg_d_tree",          m0_be_ut_reg_d_tree           },
 		{ "regmap-simple",       m0_be_ut_regmap_simple        },
@@ -106,7 +96,7 @@ const struct m0_test_suite be_ut = {
 		{ "tx-several",          m0_be_ut_tx_several           },
 		{ "tx-persistence",      m0_be_ut_tx_persistence       },
 		{ "tx-fast",             m0_be_ut_tx_fast              },
-		{ "tx-concurrent (XXX WIP)", m0_be_ut_tx_concurrent    },
+		{ "tx-concurrent",	 m0_be_ut_tx_concurrent	       },
 		{ "alloc-init",          m0_be_ut_alloc_init_fini      },
 		{ "alloc-create",        m0_be_ut_alloc_create_destroy },
 		{ "alloc-multiple",      m0_be_ut_alloc_multiple       },
diff --git a/be/ut/tx.c b/be/ut/tx.c
index d365808..885089e 100644
--- a/be/ut/tx.c
+++ b/be/ut/tx.c
@@ -439,36 +439,41 @@ void m0_be_ut_tx_fast(void)
 }
 
 enum {
-	BE_UT_TX_C_SEG_SIZE      = 0x10000,
 	BE_UT_TX_C_THREAD_NR     = 0x10,
-	BE_UT_TX_C_TX_PER_THREAD = 0x100,
+	BE_UT_TX_C_TX_PER_THREAD = 0x40,
 };
 
 struct be_ut_tx_thread_state {
 	struct m0_thread	 tts_thread;
 	struct m0_be_ut_backend *tts_ut_be;
-	struct m0_be_seg	*tts_seg;
 };
 
 static void be_ut_tx_thread(struct be_ut_tx_thread_state *state)
 {
-// XXX:
+	struct m0_be_tx tx;
+	int		i;
+
+	for (i = 0; i < BE_UT_TX_C_TX_PER_THREAD; ++i) {
+		M0_SET0(&tx);
+		m0_be_ut_tx_init(&tx, state->tts_ut_be);
+		m0_be_tx_open_sync(&tx);
+		m0_be_tx_close_sync(&tx);
+		m0_be_tx_fini(&tx);
+	}
+	m0_be_ut_backend_thread_exit(state->tts_ut_be);
 }
 
 void m0_be_ut_tx_concurrent(void)
 {
 	static struct be_ut_tx_thread_state threads[BE_UT_TX_C_THREAD_NR];
 	struct m0_be_ut_backend             ut_be;
-	struct m0_be_ut_seg                 ut_seg;
 	int                                 i;
 	int                                 rc;
 
 	m0_be_ut_backend_init(&ut_be);
-	m0_be_ut_seg_init(&ut_seg, &ut_be, BE_UT_TX_C_SEG_SIZE);
 
 	for (i = 0; i < ARRAY_SIZE(threads); ++i) {
 		threads[i].tts_ut_be = &ut_be;
-		threads[i].tts_seg = &ut_seg.bus_seg;
 		rc = M0_THREAD_INIT(&threads[i].tts_thread,
 				    struct be_ut_tx_thread_state *, NULL,
 				    &be_ut_tx_thread, &threads[i],
@@ -476,11 +481,11 @@ void m0_be_ut_tx_concurrent(void)
 		M0_UT_ASSERT(rc == 0);
 	}
 	for (i = 0; i < ARRAY_SIZE(threads); ++i) {
-		m0_thread_join(&threads[i].tts_thread);
+		rc = m0_thread_join(&threads[i].tts_thread);
+		M0_UT_ASSERT(rc == 0);
 		m0_thread_fini(&threads[i].tts_thread);
 	}
 
-	m0_be_ut_seg_fini(&ut_seg);
 	m0_be_ut_backend_fini(&ut_be);
 }
 
diff --git a/ut/ast_thread.c b/ut/ast_thread.c
index c06b838..77b23a9 100644
--- a/ut/ast_thread.c
+++ b/ut/ast_thread.c
@@ -30,6 +30,8 @@
  * @{
  */
 
+struct m0_sm_group ut__txs_sm_group;
+
 static struct {
 	bool                run;
 	struct m0_sm_group *grp;
@@ -50,6 +52,7 @@ static void ast_thread(struct m0_sm_group *grp)
 
 M0_INTERNAL int m0_ut_ast_thread_start(struct m0_sm_group *grp)
 {
+	m0_sm_group_init(grp);
 	g_ast.grp = grp;
 	g_ast.run = true;
 	return M0_THREAD_INIT(&g_ast.thread, struct m0_sm_group *, NULL,
@@ -61,6 +64,7 @@ M0_INTERNAL void m0_ut_ast_thread_stop(void)
 	g_ast.run = false;
 	m0_clink_signal(&g_ast.grp->s_clink);
 	m0_thread_join(&g_ast.thread);
+	m0_sm_group_fini(g_ast.grp);
 }
 
 /** @} end of XXX group */
-- 
1.8.3.2

