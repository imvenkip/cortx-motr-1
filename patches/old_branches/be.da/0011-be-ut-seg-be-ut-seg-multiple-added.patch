From a672bd894a06718ff7cc00b7d3dfe0fdd9941a1d Mon Sep 17 00:00:00 2001
From: Maxim Medved <Max_Medved@xyratex.com>
Date: Tue, 20 Aug 2013 20:18:35 +0300
Subject: [PATCH 11/34] be/ut/seg: be-ut:seg-multiple added

---
 be/ut/main.c |  2 ++
 be/ut/seg.c  | 42 ++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 44 insertions(+)

diff --git a/be/ut/main.c b/be/ut/main.c
index df40b95..4605c60 100644
--- a/be/ut/main.c
+++ b/be/ut/main.c
@@ -36,6 +36,7 @@ extern void m0_be_ut_log(void);
 extern void m0_be_ut_seg_create_destroy(void);
 extern void m0_be_ut_seg_open_close(void);
 extern void m0_be_ut_seg_io(void);
+extern void m0_be_ut_seg_multiple(void);
 
 extern void m0_be_ut_group_ondisk(void);
 
@@ -94,6 +95,7 @@ const struct m0_test_suite be_ut = {
 		{ "log (XXX NOOP)",      m0_be_ut_log                  },
 		{ "seg-open",            m0_be_ut_seg_open_close       },
 		{ "seg-io",              m0_be_ut_seg_io               },
+		{ "seg-multiple",        m0_be_ut_seg_multiple         },
 		{ "group_ondisk",        m0_be_ut_group_ondisk         },
 		{ "domain",              m0_be_ut_domain               },
 		{ "tx-states",		 m0_be_ut_tx_states	       },
diff --git a/be/ut/seg.c b/be/ut/seg.c
index 6ef1e6d..fded7e7 100644
--- a/be/ut/seg.c
+++ b/be/ut/seg.c
@@ -20,6 +20,10 @@
 
 #include "be/seg.h"		/* m0_be_seg */
 
+#include "lib/thread.h"		/* M0_THREAD_INIT */
+#include "lib/semaphore.h"	/* m0_semaphore */
+#include "lib/misc.h"		/* m0_forall */
+
 #include "ut/ut.h"		/* M0_UT_ASSERT */
 #include "be/ut/helper.h"	/* m0_be_ut_seg_helper */
 
@@ -108,3 +112,41 @@ M0_INTERNAL void m0_be_ut_seg_io(void)
 	}
 	m0_be_ut_seg_fini(&ut_seg);
 }
+
+enum {
+	BE_UT_SEG_THREAD_NR	= 0x10,
+	BE_UT_SEG_PER_THREAD	= 0x10,
+	BE_UT_SEG_MULTIPLE_SIZE = 0x10000,
+};
+
+static void be_ut_seg_thread_func(struct m0_semaphore *barrier)
+{
+	struct m0_be_ut_seg ut_seg;
+	int		    i;
+
+	m0_semaphore_down(barrier);
+	for (i = 0; i < BE_UT_SEG_PER_THREAD; ++i) {
+		m0_be_ut_seg_init(&ut_seg, NULL, BE_UT_SEG_MULTIPLE_SIZE);
+		m0_be_ut_seg_fini(&ut_seg);
+	}
+}
+
+void m0_be_ut_seg_multiple(void)
+{
+	static struct m0_thread threads[BE_UT_SEG_THREAD_NR];
+	struct m0_semaphore	barrier;
+	bool			rc_bool;
+
+	m0_semaphore_init(&barrier, 0);
+	rc_bool = m0_forall(i, ARRAY_SIZE(threads),
+			    M0_THREAD_INIT(&threads[i], struct m0_semaphore *,
+					   NULL, &be_ut_seg_thread_func,
+					   &barrier, "#%dbe-seg-ut", i) == 0);
+	M0_UT_ASSERT(rc_bool);
+	m0_forall(i, ARRAY_SIZE(threads), m0_semaphore_up(&barrier), true);
+	rc_bool = m0_forall(i, ARRAY_SIZE(threads),
+			    m0_thread_join(&threads[i]) == 0);
+	M0_UT_ASSERT(rc_bool);
+	m0_forall(i, ARRAY_SIZE(threads), m0_thread_fini(&threads[i]), true);
+	m0_semaphore_fini(&barrier);
+}
-- 
1.8.3.2

