From 2ea591e7f8661341c09c1c44b5f87db63cce3428 Mon Sep 17 00:00:00 2001
From: Maxim Medved <Max_Medved@xyratex.com>
Date: Tue, 20 Aug 2013 20:16:55 +0300
Subject: [PATCH 09/34] be/ut/helper: m0_be_ut_seg_{init,fini}() are now
 thread-safe

---
 be/ut/helper.c | 101 ++++++++++++++++++++++++++++++++++++++++++++-------------
 be/ut/helper.h |   1 -
 2 files changed, 79 insertions(+), 23 deletions(-)

diff --git a/be/ut/helper.c b/be/ut/helper.c
index 9b25bdc..966a6f9 100644
--- a/be/ut/helper.c
+++ b/be/ut/helper.c
@@ -23,6 +23,7 @@
 
 #include "lib/memory.h"		/* m0_alloc */
 #include "lib/misc.h"		/* M0_BITS */
+#include "lib/arith.h"		/* M0_CNT_INC */
 
 #include "be/ut/helper.h"	/* m0_be_ut_backend */
 
@@ -35,6 +36,9 @@
 #include <sys/stat.h>		/* mkdir */
 #include <sys/types.h>		/* mkdir */
 
+#include <stdlib.h>		/* atexit */
+#include <pthread.h>		/* pthread_once */
+
 #define BE_UT_H_STORAGE_DIR "./__seg_ut_stob"
 
 struct m0_sm_group ut__txs_sm_group;
@@ -44,23 +48,54 @@ enum {
 	BE_UT_SEG_START_ID   = 42ULL,
 };
 
-static struct m0_atomic64 be_ut_seg_addr;
-static struct m0_atomic64 be_ut_seg_id;
+static pthread_once_t	      be_ut_seg_once_control = PTHREAD_ONCE_INIT;
+static struct m0_mutex	      be_ut_seg_lock;
+static struct m0_stob_domain *be_ut_seg_stob_dom;
+static void		     *be_ut_seg_addr;
+static uint64_t		      be_ut_seg_id;
+static int		      be_ut_seg_storage_ref_cnt;
 
 static void *be_ut_seg_allocate_addr(m0_bcount_t size)
 {
-	/* initialize start addr if it wasn't already initialized */
-	m0_atomic64_cas((int64_t *) &be_ut_seg_addr,
-			0, BE_UT_SEG_START_ADDR);
+	void *addr;
+
 	size = m0_align(size, m0_pagesize_get());
-	return (void *) (m0_atomic64_add_return(&be_ut_seg_addr, size) - size);
+
+	m0_mutex_lock(&be_ut_seg_lock);
+	addr		= be_ut_seg_addr;
+	be_ut_seg_addr += size;
+	m0_mutex_unlock(&be_ut_seg_lock);
+
+	return addr;
 }
 
 static uint64_t be_ut_seg_allocate_id(void)
 {
-	m0_atomic64_cas((int64_t *) &be_ut_seg_id,
-			0, BE_UT_SEG_START_ID);
-	return m0_atomic64_add_return(&be_ut_seg_id, 1) - 1;
+	uint64_t id;
+
+	m0_mutex_lock(&be_ut_seg_lock);
+	id = be_ut_seg_id++;
+	m0_mutex_unlock(&be_ut_seg_lock);
+
+	return id;
+}
+
+static inline void be_ut_seg_fini_once(void)
+{
+	M0_PRE(be_ut_seg_stob_dom == NULL);
+	M0_PRE(be_ut_seg_storage_ref_cnt == 0);
+	m0_mutex_fini(&be_ut_seg_lock);
+}
+
+/* XXX call this function from m0_init()? */
+static void be_ut_seg_init_once(void)
+{
+	be_ut_seg_addr = (void *) BE_UT_SEG_START_ADDR;
+	be_ut_seg_id   = BE_UT_SEG_START_ID;
+	m0_mutex_init(&be_ut_seg_lock);
+	be_ut_seg_storage_ref_cnt = 0;
+	be_ut_seg_stob_dom = NULL;
+	atexit(&be_ut_seg_fini_once);	/* XXX REFACTORME */
 }
 
 void m0_be_ut_backend_init(struct m0_be_ut_backend *ut_be)
@@ -136,25 +171,39 @@ static void be_ut_seg_init(struct m0_be_ut_seg *ut_seg,
 	};
 	int               rc;
 
-	rc = system("rm -rf " BE_UT_H_STORAGE_DIR);
-	M0_ASSERT(rc == 0);
-	rc = mkdir(BE_UT_H_STORAGE_DIR, 0700);
-	M0_ASSERT(rc == 0);
-	rc = mkdir(BE_UT_H_STORAGE_DIR "/o", 0700);
+	/* init be_ut_seg_lock */
+	rc = pthread_once(&be_ut_seg_once_control, &be_ut_seg_init_once);
 	M0_ASSERT(rc == 0);
 
-	rc = m0_linux_stob_domain_locate(BE_UT_H_STORAGE_DIR, &ut_seg->bus_dom);
-	M0_ASSERT(rc == 0);
+	m0_mutex_lock(&be_ut_seg_lock);
+
+	if (be_ut_seg_storage_ref_cnt == 0) {
+		rc = system("rm -rf " BE_UT_H_STORAGE_DIR);
+		M0_ASSERT(rc == 0);
+		rc = mkdir(BE_UT_H_STORAGE_DIR, 0700);
+		M0_ASSERT(rc == 0);
+		rc = mkdir(BE_UT_H_STORAGE_DIR "/o", 0700);
+		M0_ASSERT(rc == 0);
+
+		M0_PRE(be_ut_seg_stob_dom == NULL);
+		rc = m0_linux_stob_domain_locate(BE_UT_H_STORAGE_DIR,
+						 &be_ut_seg_stob_dom);
+		M0_ASSERT(rc == 0);
+	}
+	M0_CNT_INC(be_ut_seg_storage_ref_cnt);
+
 	m0_dtx_init(&ut_seg->bus_dtx);
 	if (stob_create) {
-		rc = m0_stob_create_helper(ut_seg->bus_dom, &ut_seg->bus_dtx,
+		rc = m0_stob_create_helper(be_ut_seg_stob_dom, &ut_seg->bus_dtx,
 					   &stob_id, &ut_seg->bus_stob);
 		M0_ASSERT(rc == 0);
 	} else {
-		m0_stob_init(&ut_seg->bus_stob_, &stob_id, ut_seg->bus_dom);
+		m0_stob_init(&ut_seg->bus_stob_, &stob_id, be_ut_seg_stob_dom);
 		ut_seg->bus_stob = &ut_seg->bus_stob_;
 	}
 
+	m0_mutex_unlock(&be_ut_seg_lock);
+
 	m0_be_seg_init(&ut_seg->bus_seg, ut_seg->bus_stob, &ut_be->but_dom);
 	rc = m0_be_seg_create(&ut_seg->bus_seg, size,
 			      be_ut_seg_allocate_addr(size));
@@ -171,14 +220,22 @@ static void be_ut_seg_fini(struct m0_be_ut_seg *ut_seg, bool stob_destroy)
 	rc = m0_be_seg_destroy(&ut_seg->bus_seg);
 	M0_ASSERT(rc == 0);
 	m0_be_seg_fini(&ut_seg->bus_seg);
+
+	m0_mutex_lock(&be_ut_seg_lock);
 	if (stob_destroy)
 		m0_stob_put(ut_seg->bus_stob);
 	m0_dtx_fini(&ut_seg->bus_dtx);
-	ut_seg->bus_dom->sd_ops->sdo_fini(ut_seg->bus_dom);
-	if (stob_destroy) {
-		rc = system("rm -rf " BE_UT_H_STORAGE_DIR);
-		M0_ASSERT(rc == 0);
+
+	M0_CNT_DEC(be_ut_seg_storage_ref_cnt);
+	if (be_ut_seg_storage_ref_cnt == 0) {
+		be_ut_seg_stob_dom->sd_ops->sdo_fini(be_ut_seg_stob_dom);
+		be_ut_seg_stob_dom = NULL;
+		if (stob_destroy) {
+			rc = system("rm -rf " BE_UT_H_STORAGE_DIR);
+			M0_ASSERT(rc == 0);
+		}
 	}
+	m0_mutex_unlock(&be_ut_seg_lock);
 }
 
 void m0_be_ut_seg_init(struct m0_be_ut_seg *ut_seg,
diff --git a/be/ut/helper.h b/be/ut/helper.h
index adc039d..66a5c84 100644
--- a/be/ut/helper.h
+++ b/be/ut/helper.h
@@ -43,7 +43,6 @@ void m0_be_ut_backend_fini(struct m0_be_ut_backend *ut_be);
 void m0_be_ut_tx_init(struct m0_be_tx *tx, struct m0_be_ut_backend *ut_be);
 
 struct m0_be_ut_seg {
-	struct m0_stob_domain	*bus_dom;
 	struct m0_dtx            bus_dtx;
 	/**
 	 * Stob to test. It can point to m0_be_ut_seg.bus_stob_ if
-- 
1.8.3.2

