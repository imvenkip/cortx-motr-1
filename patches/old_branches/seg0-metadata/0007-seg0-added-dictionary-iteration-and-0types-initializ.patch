From c826c74fe6cf592feb8f75bd6b8bb5411a20f184 Mon Sep 17 00:00:00 2001
From: Anatoliy Bilenko <anatoliy_bilenko@xyratex.com>
Date: Thu, 13 Feb 2014 16:36:09 +0200
Subject: [PATCH 7/9] seg0: added dictionary iteration and 0types
 initialization procedures.

	* todos (for me)
	** TODO locking inside 0type interfaces
	** TODO change 0type interface according to Nikitas' message
	** TODO M0_BE_0TYPE_MAGIC
	** TODO M0_BE_SEG_MAGIC
	** TODO remove zt->b0_dom
	** TODO XXX in seg0.c
---
 be/domain.c | 71 +++++++++++++++++++++++++++++++++++++++++++++++++++++--------
 be/domain.h |  4 +++-
 be/seg0.c   |  4 ++--
 3 files changed, 67 insertions(+), 12 deletions(-)

diff --git a/be/domain.c b/be/domain.c
index ef5aeac..b4b0958 100644
--- a/be/domain.c
+++ b/be/domain.c
@@ -38,24 +38,66 @@ M0_TL_DEFINE(seg, M0_INTERNAL, struct m0_be_seg);
  *
  * @{
  */
+static void m0_be_domain__0types_fini(struct m0_be_domain *dom);
+static int m0_be_domain__0types_init(struct m0_be_domain *dom);
+
+static int segobj_opt_begin(const struct m0_be_seg    *dict,
+			    const struct m0_be_0type  *objtype,
+			    const struct m0_buf       *opt,
+			    char                     **suffix)
+{
+	return -1;
+}
+
+static int segobj_opt_next(const struct m0_be_seg    *dict,
+			   const struct m0_be_0type  *objtype,
+			   const struct m0_buf       *opt,
+			   char                     **suffix)
+{
+	return -1;
+}
+
+static int _0types_visit(struct m0_be_domain *dom, bool init)
+{
+	int		    rc;
+	int                 left;
+	struct m0_buf       opt;
+	struct m0_be_seg   *dict;
+	struct m0_be_0type *objtype;
+	char               *suffix;
+
+	dict = m0_be_domain_seg0_get(dom);
+
+        m0_tl_for(zt, &dom->bd_0type_list, objtype) {
+		for (left = segobj_opt_begin(dict, objtype, &opt, &suffix);
+		     left > 0 && rc != 0;
+		     left = segobj_opt_next(dict, objtype, &opt, &suffix)) {
+			rc = init ? objtype->b0_init(dom, suffix, &opt) :
+				(objtype->b0_fini(dom, suffix, &opt), 0);
+		}
+	} m0_tl_endfor;
+
+	return rc;
+}
 
 static int m0_be_domain__0types_init(struct m0_be_domain *dom)
 {
-	/* struct m0_buf      *opt; */
-	/* struct m0_be_0type *objtype; */
+	int		    rc;
 
-	/* m0_tlist_for(&be_0type_list, &dom->bd_0types, objtype) { */
-	/* 	for (opt = segobj_opt_begin(dict, objtype); */
-	/* 	     opt != NULL && rc != 0; */
-	/* 	     opt = segobj_opt_next(dict, opt, objtype)) */
-	/* 		rc = be_obj_up(dom, opt); */
-	/* } m0_tlist_endfor; */
+	M0_PRE(m0_be_domain_is_locked(dom));
 
-	return 0;
+	rc = _0types_visit(dom, true);
+	if (rc != 0)
+		m0_be_domain__0types_fini(dom);
+
+	return rc;
 }
 
 static void m0_be_domain__0types_fini(struct m0_be_domain *dom)
 {
+	M0_PRE(m0_be_domain_is_locked(dom));
+
+	(void) _0types_visit(dom, false);
 }
 
 M0_INTERNAL int m0_be_domain_init(struct m0_be_domain *dom,
@@ -98,6 +140,17 @@ M0_INTERNAL struct m0_be_engine *m0_be_domain_engine(struct m0_be_domain *dom)
 	return &dom->bd_engine;
 }
 
+M0_INTERNAL
+struct m0_be_seg *m0_be_domain_seg0_get(const struct m0_be_domain *dom)
+{
+	return seg_tlist_head(&dom->bd_seg_list);
+}
+
+M0_INTERNAL bool m0_be_domain_is_locked(const struct m0_be_domain *dom)
+{
+	return m0_mutex_is_locked(&dom->bd_engine.eng_lock);
+}
+
 /** @} end of be group */
 
 /*
diff --git a/be/domain.h b/be/domain.h
index 625ab31..fde15cc 100644
--- a/be/domain.h
+++ b/be/domain.h
@@ -50,7 +50,9 @@ M0_INTERNAL int m0_be_domain_init(struct m0_be_domain *dom,
 M0_INTERNAL void m0_be_domain_fini(struct m0_be_domain *dom);
 
 M0_INTERNAL struct m0_be_engine *m0_be_domain_engine(struct m0_be_domain *dom);
-
+M0_INTERNAL
+struct m0_be_seg *m0_be_domain_seg0_get(const struct m0_be_domain *dom);
+M0_INTERNAL bool m0_be_domain_is_locked(const struct m0_be_domain *dom);
 /** @} end of be group */
 #endif /* __MERO_BE_DOMAIN_H__ */
 
diff --git a/be/seg0.c b/be/seg0.c
index 0d2a90c..a49a3b0 100644
--- a/be/seg0.c
+++ b/be/seg0.c
@@ -37,12 +37,12 @@ static bool be_0type_invarinat(const struct m0_be_0type *zt, bool registered)
 
 static bool dom_is_locked(const struct m0_be_domain *dom)
 {
-	return m0_mutex_is_locked(&dom->bd_engine.eng_lock);
+	return m0_be_domain_is_locked(dom);
 }
 
 static struct m0_be_seg *seg0_get(const struct m0_be_domain *dom)
 {
-	return seg_tlist_head(&dom->bd_seg_list);
+	return m0_be_domain_seg0_get(dom);
 }
 
 static void keyname_format(const struct m0_be_0type *zt,
-- 
1.8.3.2

