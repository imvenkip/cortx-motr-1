From e3a02f0604231ea7ddb5853b0e507f0f5604ec30 Mon Sep 17 00:00:00 2001
From: Anatoliy Bilenko <anatoliy_bilenko@xyratex.com>
Date: Tue, 25 Feb 2014 19:28:26 +0200
Subject: [PATCH 8/9] seg_dict: added m0_be_seg_dict_{start,next}() iteration
 interface.

---
 be/seg_dict.c    | 44 ++++++++++++++++++++++++++++++++++++++++++++
 be/seg_dict.h    |  8 ++++++++
 be/ut/seg_dict.c | 27 +++++++++++++++++++++++++++
 3 files changed, 79 insertions(+)

diff --git a/be/seg_dict.c b/be/seg_dict.c
index 3de815e..3fedb28 100644
--- a/be/seg_dict.c
+++ b/be/seg_dict.c
@@ -154,6 +154,50 @@ M0_INTERNAL int m0_be_seg_dict_lookup(struct m0_be_seg *seg,
 				    bo_u.u_btree.t_rc));
 }
 
+M0_INTERNAL int _seg_dict_iterate(struct m0_be_seg *seg,
+				  const char *start_key,
+				  const char **this_key,
+				  void **this_rec,
+				  bool next)
+{
+	struct m0_be_btree_cursor  cursor;
+	struct m0_be_btree        *tree = dict_get(seg);
+	struct m0_buf		   start = M0_BUF_INITS((char*)start_key);
+	struct m0_buf		   key;
+	struct m0_buf              val;
+	int                        rc;
+
+	m0_be_btree_cursor_init(&cursor, tree);
+
+	rc = m0_be_btree_cursor_get_sync(&cursor, &start, true) ?:
+		(!next ? 0 : m0_be_btree_cursor_next_sync(&cursor));
+	if (rc == 0) {
+		m0_be_btree_cursor_kv_get(&cursor, &key, &val);
+		*this_key = (const char*)key.b_addr;
+		*this_rec = (void *) *(uint64_t *)val.b_addr; /* XXX */
+		rc = strstr(*this_key, "M0_BE:") ? 0 : -ENOENT;
+	}
+
+	m0_be_btree_cursor_fini(&cursor);
+
+	return rc;
+}
+
+M0_INTERNAL int m0_be_seg_dict_start(struct m0_be_seg *seg,
+				     const char **this_key,
+				     void **this_rec)
+{
+	return _seg_dict_iterate(seg, "M0_BE:", this_key, this_rec, false);
+}
+
+M0_INTERNAL int m0_be_seg_dict_next(struct m0_be_seg *seg,
+				    const char *start_key,
+				    const char **this_key,
+				    void **this_rec)
+{
+	return _seg_dict_iterate(seg, start_key, this_key, this_rec, true);
+}
+
 M0_INTERNAL int m0_be_seg_dict_insert(struct m0_be_seg *seg,
 				      struct m0_be_tx  *tx,
 				      const char       *name,
diff --git a/be/seg_dict.h b/be/seg_dict.h
index 502c68b..fd0df53 100644
--- a/be/seg_dict.h
+++ b/be/seg_dict.h
@@ -37,6 +37,14 @@ struct m0_be_tx_credit;
 M0_INTERNAL void m0_be_seg_dict_init(struct m0_be_seg *seg);
 M0_INTERNAL int m0_be_seg_dict_lookup(struct m0_be_seg *seg,
 				      const char *name,	void **out);
+M0_INTERNAL int m0_be_seg_dict_start(struct m0_be_seg *seg,
+				     const char **this_key,
+				     void **this_rec);
+M0_INTERNAL int m0_be_seg_dict_next(struct m0_be_seg *seg,
+				    const char *start_key,
+				    const char **this_key,
+				    void **this_rec);
+
 
 /* tx based dictionary interface */
 M0_INTERNAL int m0_be_seg_dict_insert(struct m0_be_seg *seg,
diff --git a/be/ut/seg_dict.c b/be/ut/seg_dict.c
index 741a5f9..1dcf2c1 100644
--- a/be/ut/seg_dict.c
+++ b/be/ut/seg_dict.c
@@ -102,6 +102,7 @@ void m0_be_ut_seg_dict(void)
 	struct m0_sm_group     *grp;
 	struct m0_be_seg       *seg = &ut_seg.bus_seg;
 	struct m0_be_tx         tx;
+	const char             *next_key;
 	void                   *p;
 	int                     i;
 	int                     rc;
@@ -116,6 +117,11 @@ void m0_be_ut_seg_dict(void)
 		{ "d00d", (void*)0xd00d },
 		{ "8bad", (void*)0x8bad },
 		{ "f00d", (void*)0xf00d },
+
+		{ "M0_BE:opt1", (void*)0xf00d0001 },
+		{ "M0_BE:opt2", (void*)0xf00d0002 },
+		{ "M0_BE:opt3", (void*)0xf00d0003 },
+		{ "M0_BE:opt4", (void*)0xf00d0004 },
 	};
 
 	m0_be_ut_backend_init(&ut_be);
@@ -145,6 +151,27 @@ void m0_be_ut_seg_dict(void)
 		M0_UT_ASSERT(rc == 0 && dict[i].value == p);
 	}
 
+
+	rc = m0_be_seg_dict_start(seg, &next_key, &p);
+	M0_UT_ASSERT(rc == 0 && p == (void*)0xf00d0001 &&
+		     strcmp(next_key, "M0_BE:opt1") == 0);
+
+	rc = m0_be_seg_dict_next(seg, next_key, &next_key, &p);
+	M0_UT_ASSERT(rc == 0 && p == (void*)0xf00d0002 &&
+		     strcmp(next_key, "M0_BE:opt2") == 0);
+
+	rc = m0_be_seg_dict_next(seg, next_key, &next_key, &p);
+	M0_UT_ASSERT(rc == 0 && p == (void*)0xf00d0003 &&
+		     strcmp(next_key, "M0_BE:opt3") == 0);
+
+	rc = m0_be_seg_dict_next(seg, next_key, &next_key, &p);
+	M0_UT_ASSERT(rc == 0 && p == (void*)0xf00d0004 &&
+		     strcmp(next_key, "M0_BE:opt4") == 0);
+
+	rc = m0_be_seg_dict_next(seg, next_key, &next_key, &p);
+	M0_UT_ASSERT(rc != 0);
+
+
 	for (i = 0; i < ARRAY_SIZE(dict); i+=2) {
 		rc = m0_be_seg_dict_delete(seg, &tx, dict[i].name);
 		M0_UT_ASSERT(rc == 0);
-- 
1.8.3.2

