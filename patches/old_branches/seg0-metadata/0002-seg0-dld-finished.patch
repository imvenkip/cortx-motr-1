From a53a7fc54643b330123cd6093a2ffa42d6d9eaea Mon Sep 17 00:00:00 2001
From: Anatoliy Bilenko <anatoliy_bilenko@xyratex.com>
Date: Wed, 29 Jan 2014 15:14:01 +0200
Subject: [PATCH 2/9] seg0: dld finished.

---
 be/seg.h | 188 ++++++++++++++++++++++++++++++++++++++++++++++++++++-----------
 1 file changed, 157 insertions(+), 31 deletions(-)

diff --git a/be/seg.h b/be/seg.h
index 7a4b995..73e0b10 100644
--- a/be/seg.h
+++ b/be/seg.h
@@ -161,8 +161,107 @@ M0_INTERNAL int m0_be_seg__write(struct m0_be_reg *reg, void *src);
 M0_INTERNAL int m0_be_reg__read(struct m0_be_reg *reg);
 M0_INTERNAL int m0_be_reg__write(struct m0_be_reg *reg);
 
+
+/**
+ * BE object types which can be brought up by m0_be_objects_up() and
+ * brought down by m0_be_objects_down().
+ */
+enum m0_be_segobj_type {
+	M0_BST_SEG,
+	M0_BST_AD,
+	M0_BST_COB,
+	M0_BST_MD,
+	M0_BST_BALLOC,
+	M0_BST_NR,
+};
+
+enum {
+	M0_BE_SEGOBJ_OPT_NAME_MAX   = 128,
+	M0_BE_SEGOBJ_OPT_VALUE_MAX  = 2048,
+};
+
+/**
+ * Options which are read and used while concrete BE-object
+ * initialization process.
+ *
+ * @note options format is choosen to be string based because it'll be
+ * much easier to implement the utility which preares seg0 with such format.
+ */
+struct m0_be_segobj_opt {
+	/**
+	 * Name of the option, format: "type : name".
+	 * type is of:
+	 * 'i' for int types
+	 * 'u' for usigned types
+	 * 'p' for pointers
+	 * 's' for strings
+	 * examples: "s:abrakadabra", "p:mds", "i:abs-zero", "u:absolute-answer"
+	 * @note: types are used for redundancy and error checking.
+	 */
+	char so_opt_name[M0_BE_SEGOBJ_OPT_NAME_MAX];
+
+	/**
+	 * Values of the option are read with sscanf(3) so they have
+	 * to be prepared respectively.
+	 * example corresponding to @so_opt_name doc:
+	 * "magic", "0xcafebabe8badf00d", "-273", "42"
+	 */
+	char so_opt_value[M0_BE_SEGOBJ_OPT_VALUE_MAX];
+};
+
 /**
- * Dependencies.
+ * Description of BE-object to bring up while initial seg0 load procedure.
+ * @note this structure is stored as a value for keys in seg0 dictionary.
+ */
+struct m0_be_segobj_desc {
+	enum m0_be_segobj_type   sd_type;
+	unsinged                 sd_opts_nr;
+	struct m0_be_segobj_opt  sd_opts[];
+};
+
+/**
+ * Loads seg0, then according to the metadata stored in seg0 dictionary, loads
+ * and brings other BE-objects up by calling corresponding functions.
+ *
+ * @param dom       domain to which seg0 and corresponding BE-objects are
+ *		    being bound.
+ * @param stob_dir  path to dir where seg0 stob lives.
+ * @param stob_id   seg0 stob id.
+ *
+ */
+M0_INTERNAL int m0_be_objects_up(struct m0_be_domain *dom,
+				 const char *stob_dir,
+				 const struct m0_stob_id *stob_id);
+
+/**
+ * Complementary to m0_be_objects_up().
+ */
+M0_INTERNAL void m0_be_objects_down(struct m0_be_domain *dom);
+
+/**
+ * <hr> <!------------------------------------------------------------>
+ * @section seg0-metadata Meta-segment (seg0), format and systematic BE storage startup.
+ * <b>Overview.</b>
+ *
+ * Seg0 stores an information to bring all BE subsystems up. It may include
+ * different hierarchies of objects which have to be brought up and initialized
+ * systematically. So the goal of metadata is to store an information which is
+ * used to specify and order and some options for BE subsystem initialization
+ * and startup.
+ *
+ * It's supposed that BE objects like segment or different structures stored
+ * inside it, like COB, have no mutual dependencies, so the initialization order
+ * and metadata may have trivial format.
+ *
+ * It's assumed that different BE objects of the same type can be brought up
+ * independently. This assumption makes initialization routines straightforward.
+ *
+ * Concrete BE object initialization depends on a tier of BE-objects which have
+ * to be started before it. Type of this object (in enum m0_be_segobj_type) has
+ * to be placed after types from which initialization of this object depends on.
+ *
+ * The hierarchiy below may have the following types ordering:
+ * enum { SEG, COB, MDS, AD, BALLOC, NR }
  * @dot
  *  digraph conf_fetch_phase {
  *      node [fontsize=9];
@@ -194,45 +293,72 @@ M0_INTERNAL int m0_be_reg__write(struct m0_be_reg *reg);
  *  }
  * @enddot
  *
- * Startup.
+ * <b> Metadata format </b>
+ * Related metadata is stored inside seg0 dictionary and retrieved from it by
+ * iteration of all records in dictionary with predefined prefix in its
+ * keys (@todo dictionary has to be updated a little bit to do this).
+ * Format of the key is the following: "{ prefix } { separator } { beobj name }"
+ * Example: "M0_BE:COB1"
+ *
+ * The value of such dictionary record contains object type which is being
+ * broguht up and options which is used to configure this BE-object.
+ *
+ * As it was noted, options in m0_be_segobj_desc are strings for convenience.
+ *
+ * <b>BE-object startup pseudocode (top-level).</b>
  *
  * @code
+ * struct m0_be_domain      *dom = ...;
+ *
  * struct m0_be_segobj_desc *desc;
  * enum m0_be_segobj_type    objtype;
  *
  * for (objtype = 0; objtype < M0_BST_NR; ++objtype) {
- * 	for (desc = segobj_desc_begin(dict, objtype);
- * 	     desc != NULL; desc = segobj_desc_next(dict, objtype))
- * 		be_obj_up(desc);
+ *      for (desc = segobj_desc_begin(dict, objtype);
+ *           desc != NULL && rc != 0;
+ *           desc = segobj_desc_next(dict, desc, objtype))
+ * 		rc = be_obj_up(dom, desc);
  * }
  * @endcode
+ *
+ * <b>Iterator-like interface used while startup.</b>
+ * @code
+ * const struct m0_be_segobj_desc *segobj_desc_begin(
+ * 	const struct m0_be_seg *dict,
+ * 	enum m0_be_segobj_type objtype);
+ *
+ * const struct m0_be_segobj_desc *segobj_desc_next(
+ * 	const struct m0_be_seg *dict,
+ * 	const struct m0_be_segobj_desc *desc,
+ * 	enum m0_be_segobj_type objtype);
+ * @endcode
+ *
+ * <b>Pseudocode bringing BE-object up.</b>
+ * @code
+ * int be_obj_up(struct m0_be_domain *dom, const struct m0_be_segobj_desc *desc)
+ * {
+ * 	enum m0_be_segobj_type    type = desc->sd_type;
+ * 	struct m0_be_segobj_opt  *opts = &desc->sd_opts;
+ * 	unsigned                  nr   = &desc->sd_opts_nr;
+ *
+ *      // seg_up(),  ad_up(), cob_up(),  md_up(), bal_up() are used to bring up
+ *      // different be object hierarchies.
+ *
+ * 	switch (type) {
+ * 	case M0_BST_SEG    : return seg_up(dom, &opts, nr);
+ * 	case M0_BST_AD     : return  ad_up(dom, &opts, nr);
+ * 	case M0_BST_COB    : return cob_up(dom, &opts, nr);
+ * 	case M0_BST_MD     : return  md_up(dom, &opts, nr);
+ * 	case M0_BST_BALLOC : return bal_up(dom, &opts, nr);
+ * 	default:
+ * 		M0_IMPOSSIBLE("invalid object type");
+ * 	}
+ * 	return -EINVAL;
+ * }
+ * @endcode
+ *
+ * <hr> <!------------------------------------------------------------>
  */
 
-enum m0_be_segobj_type {
-	M0_BST_SEG,
-	M0_BST_AD,
-	M0_BST_COB,
-	M0_BST_MD,
-	M0_BST_BALLOC,
-	M0_BST_NR,
-};
-
-struct m0_be_segobj_opts {
-	union {
-		struct { /* segment options */
-		} seg;
-		struct { /* mds options */
-		} mds;
-		struct { /* ad options */
-		} ad;
-	} so_u;
-};
-
-struct m0_be_segobj_desc {
-	enum m0_be_segobj_type   sd_type;
-	struct m0_be_segobj_opts sd_opts;
-};
-
-
 /** @} end of be group */
 #endif /* __MERO_BE_SEG_H__ */
-- 
1.8.3.2

