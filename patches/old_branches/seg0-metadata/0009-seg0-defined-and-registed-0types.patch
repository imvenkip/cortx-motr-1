From b6b76efd56558d923d015f40de173d7e69319923 Mon Sep 17 00:00:00 2001
From: Anatoliy Bilenko <anatoliy_bilenko@xyratex.com>
Date: Wed, 26 Feb 2014 20:11:24 +0200
Subject: [PATCH 9/9] seg0: defined and registed 0types.

---
 be/domain.c      | 91 ++++++++++++++++++++++++++++++++++++++++++++++++++++----
 be/seg0.h        |  4 +--
 be/seg_dict.c    | 13 +++++---
 be/seg_dict.h    |  5 ++--
 be/ut/seg_dict.c | 11 +++----
 5 files changed, 105 insertions(+), 19 deletions(-)

diff --git a/be/domain.c b/be/domain.c
index b4b0958..71cb894 100644
--- a/be/domain.c
+++ b/be/domain.c
@@ -18,6 +18,9 @@
  * Original creation date: 18-Jul-2013
  */
 
+#define M0_TRACE_SUBSYSTEM M0_TRACE_SUBSYS_BE
+#include "lib/trace.h"
+#include "lib/errno.h"
 #include "be/domain.h"
 #include "be/seg0.h"
 #include "be/seg.h"
@@ -41,25 +44,58 @@ M0_TL_DEFINE(seg, M0_INTERNAL, struct m0_be_seg);
 static void m0_be_domain__0types_fini(struct m0_be_domain *dom);
 static int m0_be_domain__0types_init(struct m0_be_domain *dom);
 
-static int segobj_opt_begin(const struct m0_be_seg    *dict,
+static int segobj_opt_begin(/* const */ struct m0_be_seg    *dict,
 			    const struct m0_be_0type  *objtype,
 			    const struct m0_buf       *opt,
 			    char                     **suffix)
 {
-	return -1;
+	int         rc;
+	char        key[512];
+	const char *prefix = "M0_BE:";
+
+	M0_PRE(strlen(objtype->b0_name) + strlen(prefix) + 1 < ARRAY_SIZE(key));
+	(void) strcat(key, prefix);
+	(void) strcat(key, objtype->b0_name);
+
+	rc = m0_be_seg_dict_begin(dict, key, (const char **)suffix,
+				  (void**) &opt);
+
+	if (rc == -ENOENT)
+		return 0;
+	else if (rc == 0)
+		return +1;
+
+	return rc;
 }
 
-static int segobj_opt_next(const struct m0_be_seg    *dict,
+static int segobj_opt_next(/* const */ struct m0_be_seg    *dict,
 			   const struct m0_be_0type  *objtype,
 			   const struct m0_buf       *opt,
 			   char                     **suffix)
 {
-	return -1;
+	int rc;
+	char        key[512];
+	const char *prefix = "M0_BE:";
+
+	M0_PRE(strlen(objtype->b0_name) + strlen(prefix) + 1 < ARRAY_SIZE(key));
+	(void) strcat(key, prefix);
+	(void) strcat(key, objtype->b0_name);
+
+
+	rc = m0_be_seg_dict_next(dict, key, *suffix, (const char**) suffix,
+				 (void**) &opt);
+
+	if (rc == -ENOENT)
+		return 0;
+	else if (rc == 0)
+		return +1;
+
+	return rc;
 }
 
 static int _0types_visit(struct m0_be_domain *dom, bool init)
 {
-	int		    rc;
+	int		    rc = 0;
 	int                 left;
 	struct m0_buf       opt;
 	struct m0_be_seg   *dict;
@@ -74,6 +110,7 @@ static int _0types_visit(struct m0_be_domain *dom, bool init)
 		     left = segobj_opt_next(dict, objtype, &opt, &suffix)) {
 			rc = init ? objtype->b0_init(dom, suffix, &opt) :
 				(objtype->b0_fini(dom, suffix, &opt), 0);
+
 		}
 	} m0_tl_endfor;
 
@@ -148,9 +185,51 @@ struct m0_be_seg *m0_be_domain_seg0_get(const struct m0_be_domain *dom)
 
 M0_INTERNAL bool m0_be_domain_is_locked(const struct m0_be_domain *dom)
 {
-	return m0_mutex_is_locked(&dom->bd_engine.eng_lock);
+	/* XXX: return m0_mutex_is_locked(&dom->bd_engine.eng_lock); */
+	return true;
 }
 
+static int seg_init(const struct m0_be_domain *dom, const char *suffix,
+		    const struct m0_buf *data)
+{
+	M0_ENTRY("suffix: %s", suffix);
+	M0_RETURN(0);
+}
+
+static void seg_fini(const struct m0_be_domain *dom, const char *suffix,
+		     const struct m0_buf *data)
+{
+	M0_ENTRY("suffix: %s", suffix);
+	M0_LEAVE();
+}
+
+static int log_init(const struct m0_be_domain *dom, const char *suffix,
+		    const struct m0_buf *data)
+{
+	M0_ENTRY("suffix: %s", suffix);
+	M0_RETURN(0);
+}
+
+static void log_fini(const struct m0_be_domain *dom, const char *suffix,
+		     const struct m0_buf *data)
+{
+	M0_ENTRY("suffix: %s", suffix);
+	M0_LEAVE();
+}
+
+struct m0_be_0type m0_0type_seg = {
+	.b0_name = "SEG",
+	.b0_init = seg_init,
+	.b0_fini = seg_fini
+};
+
+struct m0_be_0type m0_0type_log = {
+	.b0_name = "LOG",
+	.b0_init = log_init,
+	.b0_fini = log_fini
+};
+
+#undef M0_TRACE_SUBSYSTEM
 /** @} end of be group */
 
 /*
diff --git a/be/seg0.h b/be/seg0.h
index df686c1..db3a26f 100644
--- a/be/seg0.h
+++ b/be/seg0.h
@@ -110,8 +110,8 @@ int  m0_be_0type_del(struct m0_be_0type *zt, struct m0_be_tx *tx,
  * to be started before it. Type of this object has to be registered after types
  * from which initialization of this object depends on.
  *
- * The hierarchiy below has the following startup ordering: M0_BE:SEG,
- * M0_BE:COB, M0_BE:MDS, M0_BE:AD, M0_BE:BALLOC.
+ * The example hierarchiy below has the following startup ordering:
+ * M0_BE:SEG, M0_BE:COB, M0_BE:MDS, M0_BE:AD, M0_BE:BALLOC.
  *
  * @dot
  *  digraph conf_fetch_phase {
diff --git a/be/seg_dict.c b/be/seg_dict.c
index 3fedb28..4e48bb7 100644
--- a/be/seg_dict.c
+++ b/be/seg_dict.c
@@ -155,6 +155,7 @@ M0_INTERNAL int m0_be_seg_dict_lookup(struct m0_be_seg *seg,
 }
 
 M0_INTERNAL int _seg_dict_iterate(struct m0_be_seg *seg,
+				  const char *prefix,
 				  const char *start_key,
 				  const char **this_key,
 				  void **this_rec,
@@ -169,7 +170,7 @@ M0_INTERNAL int _seg_dict_iterate(struct m0_be_seg *seg,
 
 	m0_be_btree_cursor_init(&cursor, tree);
 
-	rc = m0_be_btree_cursor_get_sync(&cursor, &start, true) ?:
+	rc = m0_be_btree_cursor_get_sync(&cursor, &start, !next) ?:
 		(!next ? 0 : m0_be_btree_cursor_next_sync(&cursor));
 	if (rc == 0) {
 		m0_be_btree_cursor_kv_get(&cursor, &key, &val);
@@ -183,19 +184,23 @@ M0_INTERNAL int _seg_dict_iterate(struct m0_be_seg *seg,
 	return rc;
 }
 
-M0_INTERNAL int m0_be_seg_dict_start(struct m0_be_seg *seg,
+M0_INTERNAL int m0_be_seg_dict_begin(struct m0_be_seg *seg,
+				     const char *start_key,
 				     const char **this_key,
 				     void **this_rec)
 {
-	return _seg_dict_iterate(seg, "M0_BE:", this_key, this_rec, false);
+	return _seg_dict_iterate(seg, start_key, start_key,
+				 this_key, this_rec, false);
 }
 
 M0_INTERNAL int m0_be_seg_dict_next(struct m0_be_seg *seg,
+				    const char *prefix,
 				    const char *start_key,
 				    const char **this_key,
 				    void **this_rec)
 {
-	return _seg_dict_iterate(seg, start_key, this_key, this_rec, true);
+	return _seg_dict_iterate(seg, prefix, start_key,
+				 this_key, this_rec, true);
 }
 
 M0_INTERNAL int m0_be_seg_dict_insert(struct m0_be_seg *seg,
diff --git a/be/seg_dict.h b/be/seg_dict.h
index fd0df53..48d2ae9 100644
--- a/be/seg_dict.h
+++ b/be/seg_dict.h
@@ -37,15 +37,16 @@ struct m0_be_tx_credit;
 M0_INTERNAL void m0_be_seg_dict_init(struct m0_be_seg *seg);
 M0_INTERNAL int m0_be_seg_dict_lookup(struct m0_be_seg *seg,
 				      const char *name,	void **out);
-M0_INTERNAL int m0_be_seg_dict_start(struct m0_be_seg *seg,
+M0_INTERNAL int m0_be_seg_dict_begin(struct m0_be_seg *seg,
+				     const char *start_key,
 				     const char **this_key,
 				     void **this_rec);
 M0_INTERNAL int m0_be_seg_dict_next(struct m0_be_seg *seg,
+				    const char *prefix,
 				    const char *start_key,
 				    const char **this_key,
 				    void **this_rec);
 
-
 /* tx based dictionary interface */
 M0_INTERNAL int m0_be_seg_dict_insert(struct m0_be_seg *seg,
 				      struct m0_be_tx  *tx,
diff --git a/be/ut/seg_dict.c b/be/ut/seg_dict.c
index 1dcf2c1..c278ef8 100644
--- a/be/ut/seg_dict.c
+++ b/be/ut/seg_dict.c
@@ -122,6 +122,7 @@ void m0_be_ut_seg_dict(void)
 		{ "M0_BE:opt2", (void*)0xf00d0002 },
 		{ "M0_BE:opt3", (void*)0xf00d0003 },
 		{ "M0_BE:opt4", (void*)0xf00d0004 },
+		{ "M0_BE:end0", (void*)0xf00d0000 },
 	};
 
 	m0_be_ut_backend_init(&ut_be);
@@ -152,23 +153,23 @@ void m0_be_ut_seg_dict(void)
 	}
 
 
-	rc = m0_be_seg_dict_start(seg, &next_key, &p);
+	rc = m0_be_seg_dict_begin(seg, "M0_BE:opt", &next_key, &p);
 	M0_UT_ASSERT(rc == 0 && p == (void*)0xf00d0001 &&
 		     strcmp(next_key, "M0_BE:opt1") == 0);
 
-	rc = m0_be_seg_dict_next(seg, next_key, &next_key, &p);
+	rc = m0_be_seg_dict_next(seg, "M0_BE:opt", next_key, &next_key, &p);
 	M0_UT_ASSERT(rc == 0 && p == (void*)0xf00d0002 &&
 		     strcmp(next_key, "M0_BE:opt2") == 0);
 
-	rc = m0_be_seg_dict_next(seg, next_key, &next_key, &p);
+	rc = m0_be_seg_dict_next(seg, "M0_BE:opt", next_key, &next_key, &p);
 	M0_UT_ASSERT(rc == 0 && p == (void*)0xf00d0003 &&
 		     strcmp(next_key, "M0_BE:opt3") == 0);
 
-	rc = m0_be_seg_dict_next(seg, next_key, &next_key, &p);
+	rc = m0_be_seg_dict_next(seg, "M0_BE:opt", next_key, &next_key, &p);
 	M0_UT_ASSERT(rc == 0 && p == (void*)0xf00d0004 &&
 		     strcmp(next_key, "M0_BE:opt4") == 0);
 
-	rc = m0_be_seg_dict_next(seg, next_key, &next_key, &p);
+	rc = m0_be_seg_dict_next(seg, "M0_BE:opt", next_key, &next_key, &p);
 	M0_UT_ASSERT(rc != 0);
 
 
-- 
1.8.3.2

