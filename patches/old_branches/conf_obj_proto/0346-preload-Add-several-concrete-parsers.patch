From efabe0db98ce6f5833da5a47257b982475d7d558 Mon Sep 17 00:00:00 2001
From: Anatoliy Bilenko <anatoliy_bilenko@xyratex.com>
Date: Thu, 30 Aug 2012 21:19:41 +0300
Subject: [PATCH 346/370] preload: Add several concrete parsers.

---
 conf/preload.c   | 132 ++++++++++++++++++++++++++++++++++++++++++-------------
 conf/ut/prepar.c |   1 -
 2 files changed, 102 insertions(+), 31 deletions(-)

diff --git a/conf/preload.c b/conf/preload.c
index 194e8f8..e874ee9 100644
--- a/conf/preload.c
+++ b/conf/preload.c
@@ -27,6 +27,7 @@
 #include "lib/errno.h"
 #include "lib/misc.h"
 #include <ctype.h>		/* isspace */
+#include <stdlib.h>		/* strto{ull,ll,ul,l} @todo: move to misc.h */
 
 #define HUNK_DBG
 #ifdef HUNK_DBG
@@ -227,51 +228,118 @@ static int entry_parse(struct hunk *unit, const struct hunk *buffer)
  * Confx object parsers
  * ------------------------------------------------------------------ */
 
+enum { C2_CO_INVALID_TYPE = C2_CO_NR };
+
 static int parse_profile(const struct hunk *key, const struct hunk *val,
 			 struct confx_object *out)
 {
-	return -1;
+	printf(">>>>>>%s\n", __FUNCTION__);
+	hunk_pr("sub", key);
+	hunk_pr("sub", val);
+
+	if (hunk_str_eq(key, "id"))
+		c2_buf_init(&out->o_id, (void *)val->begin, hunk_len(val));
+
+	else if (hunk_str_eq(key, "filesystem"))
+		c2_buf_init(&out->o_conf.u.u_profile.xp_filesystem,
+			    (void *)val->begin, hunk_len(val));
+
+	else
+		return -EINVAL;
+
+	return 0;
 }
 
 static int parse_filesystem(const struct hunk *key, const struct hunk *val,
 			    struct confx_object *out)
 {
-	return -1;
+	printf(">>>>>>%s\n", __FUNCTION__);
+	hunk_pr("sub", key);
+	hunk_pr("sub", val);
+
+	return 0;
 }
 
 static int parse_service(const struct hunk *key, const struct hunk *val,
 			 struct confx_object *out)
 {
-	return -1;
+	printf(">>>>>>%s\n", __FUNCTION__);
+	hunk_pr("sub", key);
+	hunk_pr("sub", val);
+
+	return 0;
 }
 
 static int parse_node(const struct hunk *key, const struct hunk *val,
 		      struct confx_object *out)
 {
-	return -1;
+	printf(">>>>>>%s\n", __FUNCTION__);
+	hunk_pr("sub", key);
+	hunk_pr("sub", val);
+
+	return 0;
 }
 
 static int parse_nic(const struct hunk *key, const struct hunk *val,
 		     struct confx_object *out)
 {
-	return -1;
+	printf(">>>>>>%s\n", __FUNCTION__);
+	hunk_pr("sub", key);
+	hunk_pr("sub", val);
+
+	return 0;
 }
 
 static int parse_sdev(const struct hunk *key, const struct hunk *val,
 		      struct confx_object *out)
 {
-	return -1;
+	printf(">>>>>>%s\n", __FUNCTION__);
+	hunk_pr("sub", key);
+	hunk_pr("sub", val);
+
+	return 0;
 }
 
 static int parse_partition(const struct hunk *key, const struct hunk *val,
 			   struct confx_object *out)
 {
-	return -1;
+	printf(">>>>>>%s\n", __FUNCTION__);
+	hunk_pr("sub", key);
+	hunk_pr("sub", val);
+
+	if (hunk_str_eq(key, "id"))
+		out->o_id = (const struct c2_buf)
+			C2_BUF_INIT(hunk_len(val), (void *)val->begin);
+
+	else if (hunk_str_eq(key, "start"))
+		out->o_conf.u.u_partition.xa_start =
+			strtoull(val->begin, NULL, 0);
+
+	else if (hunk_str_eq(key, "size"))
+		out->o_conf.u.u_partition.xa_size =
+			strtoull(val->begin, NULL, 0);
+
+	else if (hunk_str_eq(key, "index"))
+		out->o_conf.u.u_partition.xa_index =
+			strtoul(val->begin, NULL, 0);
+
+	else if (hunk_str_eq(key, "pa_type"))
+		out->o_conf.u.u_partition.xa_type =
+			strtoul(val->begin, NULL, 0);
+
+	else if (hunk_str_eq(key, "filename"))
+		out->o_conf.u.u_partition.xa_file = (const struct c2_buf)
+			C2_BUF_INIT(hunk_len(val), (void *)val->begin);
+
+	else
+		return -EINVAL;
+
+	return 0;
 }
 
 
 /* ------------------------------------------------------------------
- * Bindings: generic parser is bind to concrete
+ * Bindings: generic parser is bound to concrete
  * ------------------------------------------------------------------ */
 
 static int parse_unused(const struct hunk *key, const struct hunk *val,
@@ -296,12 +364,12 @@ static const struct xstr_rec {
 	[C2_CO_PARTITION]  = { "partition"  , parse_partition  }
 };
 
-static size_t str_to_x(const char *conf_string)
+static size_t str_to_x(const struct hunk *key)
 {
 	size_t i;
 
 	for (i = 0; i < ARRAY_SIZE(xstr); ++i)
-		if (strcmp(xstr[i].r_name, conf_string) == 0)
+		if (hunk_str_eq(key, xstr[i].r_name))
 			return i;
 
 	C2_IMPOSSIBLE("Wrong configuration string type given!");
@@ -334,14 +402,22 @@ static int x_parser_call(const char *conf_string, struct confx_object *out)
 	if (rc != 0)
 		return rc;
 
-	hunk_pr("\t\t\tsub", &key);
-	hunk_pr("\t\t\tsub", &val);
+	//hunk_pr("\t\t\tsub", &key);
+	//hunk_pr("\t\t\tsub", &val);
 
-	if (0)
-		if (hunk_str_eq(&key, "type"))
-			xstr[str_to_x(conf_string)].r_parse(&key, &val, out);
+	if (hunk_str_eq(&key, "type")) {
+		C2_ASSERT(out->o_conf.u_type == C2_CO_INVALID_TYPE);
 
-	return 0;
+		rc = unit_advance(&val, '\"', '\"');
+		if (rc != 0)
+			return rc;
+
+		out->o_conf.u_type = str_to_x(&val);
+		return 0;
+	}
+
+	C2_ASSERT(out->o_conf.u_type != C2_CO_INVALID_TYPE);
+	return xstr[out->o_conf.u_type].r_parse(&key, &val, out);
 }
 
 
@@ -352,42 +428,38 @@ static int x_parser_call(const char *conf_string, struct confx_object *out)
 int c2_conf_parse(const char *src, struct confx_object *dest, size_t n)
 {
 	int rc;
-	int entries = 0;
 	size_t conf_index = 0;
 	struct hunk str = { .begin = src, .end = &src[strlen(src) - 1] };
 	struct hunk blk = { NULL, NULL };
 
 	for (; block_parse(&blk, &str) == 0; ) {
 		struct hunk rec = { NULL, NULL };
-		hunk_pr("block", &blk);
+
 		for (; record_parse(&rec, &blk) == 0; ) {
 			struct hunk ent = { NULL, NULL };
-			hunk_pr("\trecord", &rec);
+			dest[conf_index].o_conf.u_type = C2_CO_INVALID_TYPE;
+
 			for (; entry_parse(&ent, &rec) == 0; ) {
-				/* @todo: copying can be avoided */
+				/* @todo: avoid copying and C-strings */
 				char parse_buf[256];
 				int  len = ent.end - ent.begin + 1;
-
-				hunk_pr("\t\tentry", &ent);
-
 				if (len >= ARRAY_SIZE(parse_buf))
 					return -ENOMEM;
 
 				memcpy(parse_buf, ent.begin, len);
 				parse_buf[len]= '\0';
 
-				if (conf_index >= n)
-					return -ENOMEM;
-
 				rc = x_parser_call(parse_buf,
-						   &dest[conf_index++]);
+						   &dest[conf_index]);
 				if (rc != 0)
 					return rc;
-
-				++entries;
 			}
+
+			++conf_index;
+			if (conf_index >= n)
+				return -ENOMEM;
 		}
 	}
 
-	return entries;
+	return conf_index;
 }
diff --git a/conf/ut/prepar.c b/conf/ut/prepar.c
index acb1dd7..39a7cf8 100644
--- a/conf/ut/prepar.c
+++ b/conf/ut/prepar.c
@@ -4,7 +4,6 @@
 #include "lib/errno.h"
 #include "lib/misc.h"
 #include <stdio.h>
-#include <string.h>
 
 int main(void)
 {
-- 
1.8.3.2

