From 31490d86f8100efe8a233eececb1798e7e3a8f51 Mon Sep 17 00:00:00 2001
From: Anatoliy Bilenko <anatoliy_bilenko@xyratex.com>
Date: Fri, 31 Aug 2012 19:34:01 +0300
Subject: [PATCH 351/370] preload: Add arr_buff-type parsers and fillers.

---
 conf/preload.c   | 106 +++++++++++++++++++++++++++++++++++++++----------------
 conf/ut/prepar.c |  88 ++++++++++++++++++++++++++++++++-------------
 2 files changed, 139 insertions(+), 55 deletions(-)

diff --git a/conf/preload.c b/conf/preload.c
index 1921f38..fb288b3 100644
--- a/conf/preload.c
+++ b/conf/preload.c
@@ -24,6 +24,7 @@
 #include "conf/obj.h"
 
 #include "lib/assert.h"
+#include "lib/memory.h"
 #include "lib/errno.h"
 #include "lib/misc.h"
 #include <ctype.h>		/* isspace */
@@ -216,6 +217,18 @@ static int sequence_parse(struct hunk *unit, const struct hunk *buffer, char ss)
 	return unit_parse(unit, ss);
 }
 
+/* @todo: Very unoptimal sequence length calculation */
+static int sequence_len(const struct hunk *unit, char ss)
+{
+	int length = 0;
+	struct hunk contents = HUNK_EMPTY;
+
+	while (sequence_parse(&contents, unit, ss) == 0)
+		length++;
+
+	return length;
+}
+
 static int block_parse(struct hunk *unit, const struct hunk *buffer)
 {
 	return sequence_parse(unit, buffer, ',');
@@ -244,25 +257,6 @@ static int entry_parse(struct hunk *unit, const struct hunk *buffer)
 
 enum { C2_CO_INVALID_TYPE = C2_CO_NR };
 
-static int profile_parse(const struct hunk *key, const struct hunk *val,
-			 struct confx_object *out)
-{
-	hunk_pr(__FUNCTION__, key);
-	hunk_pr(__FUNCTION__, val);
-
-	if (hunk_str_eq(key, "id"))
-		c2_buf_init(&out->o_id, (void *)val->begin, hunk_len(val));
-
-	else if (hunk_str_eq(key, "filesystem"))
-		c2_buf_init(&out->o_conf.u.u_profile.xp_filesystem,
-			    (void *)val->begin, hunk_len(val));
-
-	else
-		return -EINVAL;
-
-	return 0;
-}
-
 static int rootfid_parse(struct fid *fid, const struct hunk *val)
 {
 	int rc;
@@ -288,6 +282,61 @@ static int rootfid_parse(struct fid *fid, const struct hunk *val)
 	return rc == -ENOENT ? 0 : -EINVAL;
 }
 
+static int arrbuf_parse(struct arr_buf *buf, const struct hunk *val)
+{
+	int i;
+	int rc;
+	struct hunk aval = HUNK_CP(val);
+	struct hunk qent = HUNK_EMPTY; /* quoted entry */
+	struct hunk uent = HUNK_EMPTY; /* unquoted entry */
+
+	/* parse: ~["addr1","addr2","addr3"]~ */
+
+	rc = unit_advance(&aval, '[', ']');
+	if (rc != 0)
+		return rc;
+
+	buf->ab_count = sequence_len(&aval, ',');
+	C2_ALLOC_ARR(buf->ab_elems, buf->ab_count);
+	if (buf->ab_elems == NULL)
+		return -ENOMEM;
+
+	for (i = 0; i < buf->ab_count; ++i) {
+		rc = sequence_parse(&qent, &aval, ',');
+		if (rc != 0)
+			return rc;
+
+		hunk_cp(&uent, &qent);
+		rc = unit_quoted_unquote(&uent);
+		if (rc != 0)
+			return rc;
+
+		c2_buf_init(&buf->ab_elems[i], (void *)uent.begin,
+			    hunk_len(&uent));
+	}
+
+	return 0;
+}
+
+static int profile_parse(const struct hunk *key, const struct hunk *val,
+			 struct confx_object *out)
+{
+	hunk_pr(__FUNCTION__, key);
+	hunk_pr(__FUNCTION__, val);
+
+	if (hunk_str_eq(key, "id"))
+		c2_buf_init(&out->o_id, (void *)val->begin, hunk_len(val));
+
+	else if (hunk_str_eq(key, "filesystem"))
+		c2_buf_init(&out->o_conf.u.u_profile.xp_filesystem,
+			    (void *)val->begin, hunk_len(val));
+
+	else
+		return -EINVAL;
+
+	return 0;
+}
+
 static int filesystem_parse(const struct hunk *key, const struct hunk *val,
 			    struct confx_object *out)
 {
@@ -301,13 +350,12 @@ static int filesystem_parse(const struct hunk *key, const struct hunk *val,
 		return rootfid_parse(&out->o_conf.u.u_filesystem.xf_rootfid,
 				     val);
 
-	/* @todo: ask vvv for input! */
 	else if (hunk_str_eq(key, "params"))
-		out->o_conf.u.u_sdev.xd_partitions.ab_count = 0;
+		return arrbuf_parse(&out->o_conf.u.u_filesystem.xf_params, val);
 
-	/* @todo: ask vvv for input! */
 	else if (hunk_str_eq(key, "services"))
-		out->o_conf.u.u_sdev.xd_partitions.ab_count = 0;
+		return arrbuf_parse(&out->o_conf.u.u_filesystem.xf_services,
+				    val);
 
 	else
 		return -EINVAL;
@@ -328,9 +376,8 @@ static int service_parse(const struct hunk *key, const struct hunk *val,
 		out->o_conf.u.u_service.xs_type =
 			strtoul(val->begin, NULL, 0);
 
-	/* @todo: ask vvv for input! */
 	else if (hunk_str_eq(key, "endpoints"))
-		out->o_conf.u.u_service.xs_endpoints.ab_count = 0;
+		return arrbuf_parse(&out->o_conf.u.u_service.xs_endpoints, val);
 
 	else if (hunk_str_eq(key, "node"))
 		c2_buf_init(&out->o_conf.u.u_service.xs_node,
@@ -372,13 +419,11 @@ static int node_parse(const struct hunk *key, const struct hunk *val,
 		out->o_conf.u.u_node.xn_pool_id =
 			strtoull(val->begin, NULL, 0);
 
-	/* @todo: ask vvv for input! */
 	else if (hunk_str_eq(key, "nics"))
-		out->o_conf.u.u_node.xn_nics.ab_count = 0;
+		return arrbuf_parse(&out->o_conf.u.u_node.xn_nics, val);
 
-	/* @todo: ask vvv for input! */
 	else if (hunk_str_eq(key, "sdevs"))
-		out->o_conf.u.u_node.xn_sdevs.ab_count = 0;
+		return arrbuf_parse(&out->o_conf.u.u_node.xn_sdevs, val);
 
 	else
 		return -EINVAL;
@@ -454,9 +499,8 @@ static int sdev_parse(const struct hunk *key, const struct hunk *val,
 		c2_buf_init(&out->o_conf.u.u_sdev.xd_filename,
 			    (void *)val->begin, hunk_len(val));
 
-	/* @todo: ask vvv for input! */
 	else if (hunk_str_eq(key, "partitions"))
-		out->o_conf.u.u_sdev.xd_partitions.ab_count = 0;
+		return arrbuf_parse(&out->o_conf.u.u_sdev.xd_partitions, val);
 
 	else
 		return -EINVAL;
diff --git a/conf/ut/prepar.c b/conf/ut/prepar.c
index b997854..5d7a47f 100644
--- a/conf/ut/prepar.c
+++ b/conf/ut/prepar.c
@@ -30,14 +30,27 @@ static void filesystem_check(const struct confx_object *conf)
 	/* parse_filesystem: ~services~ ~["mds", "io"]~ */
 
 	const struct c2_buf id = C2_BUF_INITS("c2t1fs");
+	const struct confx_filesystem *xfs = &conf->o_conf.u.u_filesystem;
 
 	C2_ASSERT(c2_buf_eq(&conf->o_id, &id));
 
 	C2_ASSERT(conf->o_conf.u_type == C2_CO_FILESYSTEM);
-	C2_ASSERT(conf->o_conf.u.u_filesystem.xf_rootfid.f_container == 11);
-	C2_ASSERT(conf->o_conf.u.u_filesystem.xf_rootfid.f_key == 22);
-	C2_ASSERT(conf->o_conf.u.u_sdev.xd_partitions.ab_count == 0);
-	C2_ASSERT(conf->o_conf.u.u_sdev.xd_partitions.ab_count == 0);
+	C2_ASSERT(xfs->xf_rootfid.f_container == 11);
+	C2_ASSERT(xfs->xf_rootfid.f_key == 22);
+
+	C2_ASSERT(xfs->xf_params.ab_count == 3);
+	C2_ASSERT(c2_buf_eq(&xfs->xf_params.ab_elems[0],
+			    &(const struct c2_buf) C2_BUF_INITS("50")));
+	C2_ASSERT(c2_buf_eq(&xfs->xf_params.ab_elems[1],
+			    &(const struct c2_buf) C2_BUF_INITS("60")));
+	C2_ASSERT(c2_buf_eq(&xfs->xf_params.ab_elems[2],
+			    &(const struct c2_buf) C2_BUF_INITS("70")));
+
+	C2_ASSERT(xfs->xf_services.ab_count == 2);
+	C2_ASSERT(c2_buf_eq(&xfs->xf_services.ab_elems[0],
+			    &(const struct c2_buf) C2_BUF_INITS("mds")));
+	C2_ASSERT(c2_buf_eq(&xfs->xf_services.ab_elems[1],
+			    &(const struct c2_buf) C2_BUF_INITS("io")));
 }
 
 static void service_check1(const struct confx_object *conf)
@@ -49,13 +62,18 @@ static void service_check1(const struct confx_object *conf)
 
 	const struct c2_buf id = C2_BUF_INITS("mds");
 	const struct c2_buf node = C2_BUF_INITS("N");
+	const struct confx_service *xsrv = &conf->o_conf.u.u_service;
 
 	C2_ASSERT(c2_buf_eq(&conf->o_id, &id));
 
 	C2_ASSERT(conf->o_conf.u_type == C2_CO_SERVICE);
-	C2_ASSERT(conf->o_conf.u.u_service.xs_type == 1);
-	C2_ASSERT(conf->o_conf.u.u_service.xs_endpoints.ab_count == 0);
-	C2_ASSERT(c2_buf_eq(&conf->o_conf.u.u_service.xs_node, &node));
+	C2_ASSERT(xsrv->xs_type == 1);
+
+	C2_ASSERT(xsrv->xs_endpoints.ab_count == 1);
+	C2_ASSERT(c2_buf_eq(&xsrv->xs_endpoints.ab_elems[0],
+			    &(const struct c2_buf) C2_BUF_INITS("addr0")));
+
+	C2_ASSERT(c2_buf_eq(&xsrv->xs_node, &node));
 }
 
 static void service_check2(const struct confx_object *conf)
@@ -67,13 +85,22 @@ static void service_check2(const struct confx_object *conf)
 
 	const struct c2_buf id = C2_BUF_INITS("io");
 	const struct c2_buf node = C2_BUF_INITS("N");
+	const struct confx_service *xsrv = &conf->o_conf.u.u_service;
 
 	C2_ASSERT(c2_buf_eq(&conf->o_id, &id));
 
 	C2_ASSERT(conf->o_conf.u_type == C2_CO_SERVICE);
-	C2_ASSERT(conf->o_conf.u.u_service.xs_type == 2);
-	C2_ASSERT(conf->o_conf.u.u_service.xs_endpoints.ab_count == 0);
-	C2_ASSERT(c2_buf_eq(&conf->o_conf.u.u_service.xs_node, &node));
+	C2_ASSERT(xsrv->xs_type == 2);
+
+	C2_ASSERT(xsrv->xs_endpoints.ab_count == 3);
+	C2_ASSERT(c2_buf_eq(&xsrv->xs_endpoints.ab_elems[0],
+			    &(const struct c2_buf) C2_BUF_INITS("addr1")));
+	C2_ASSERT(c2_buf_eq(&xsrv->xs_endpoints.ab_elems[1],
+			    &(const struct c2_buf) C2_BUF_INITS("addr2")));
+	C2_ASSERT(c2_buf_eq(&xsrv->xs_endpoints.ab_elems[2],
+			    &(const struct c2_buf) C2_BUF_INITS("addr3")));
+
+	C2_ASSERT(c2_buf_eq(&xsrv->xs_node, &node));
 }
 
 static void node_check(const struct confx_object *conf)
@@ -88,17 +115,25 @@ static void node_check(const struct confx_object *conf)
 	/* parse_node: ~sdevs~ ~["sdev0"]~ */
 
 	const struct c2_buf id = C2_BUF_INITS("N");
+	const struct confx_node *xnode = &conf->o_conf.u.u_node;
 
 	C2_ASSERT(c2_buf_eq(&conf->o_id, &id));
 
 	C2_ASSERT(conf->o_conf.u_type == C2_CO_NODE);
-	C2_ASSERT(conf->o_conf.u.u_node.xn_memsize == 8000);
-	C2_ASSERT(conf->o_conf.u.u_node.xn_nr_cpu == 2);
-	C2_ASSERT(conf->o_conf.u.u_node.xn_last_state == 3);
-	C2_ASSERT(conf->o_conf.u.u_node.xn_flags == 2);
-	C2_ASSERT(conf->o_conf.u.u_node.xn_pool_id == 0);
-	C2_ASSERT(conf->o_conf.u.u_node.xn_nics.ab_count == 0);
-	C2_ASSERT(conf->o_conf.u.u_node.xn_sdevs.ab_count == 0);
+	C2_ASSERT(xnode->xn_memsize == 8000);
+	C2_ASSERT(xnode->xn_nr_cpu == 2);
+	C2_ASSERT(xnode->xn_last_state == 3);
+	C2_ASSERT(xnode->xn_flags == 2);
+	C2_ASSERT(xnode->xn_pool_id == 0);
+
+	C2_ASSERT(xnode->xn_nics.ab_count == 1);
+	C2_ASSERT(c2_buf_eq(&xnode->xn_nics.ab_elems[0],
+			    &(const struct c2_buf) C2_BUF_INITS("nic0")));
+
+	C2_ASSERT(xnode->xn_sdevs.ab_count == 1);
+	C2_ASSERT(c2_buf_eq(&xnode->xn_sdevs.ab_elems[0],
+			    &(const struct c2_buf) C2_BUF_INITS("sdev0")));
+
 }
 
 static void nic_check(const struct confx_object *conf)
@@ -138,17 +173,22 @@ static void sdev_check(const struct confx_object *conf)
 
 	const struct c2_buf id = C2_BUF_INITS("sdev0");
 	const struct c2_buf fn = C2_BUF_INITS("/dev/sdev0");
+	const struct confx_sdev *xsd = &conf->o_conf.u.u_sdev;
 
 	C2_ASSERT(c2_buf_eq(&conf->o_id, &id));
 
 	C2_ASSERT(conf->o_conf.u_type == C2_CO_SDEV);
-	C2_ASSERT(conf->o_conf.u.u_sdev.xd_iface == 4);
-	C2_ASSERT(conf->o_conf.u.u_sdev.xd_media == 1);
-	C2_ASSERT(conf->o_conf.u.u_sdev.xd_size == 596000000000);
-	C2_ASSERT(conf->o_conf.u.u_sdev.xd_last_state == 3);
-	C2_ASSERT(conf->o_conf.u.u_sdev.xd_flags == 4);
-	C2_ASSERT(c2_buf_eq(&conf->o_conf.u.u_sdev.xd_filename, &fn));
-	C2_ASSERT(conf->o_conf.u.u_sdev.xd_partitions.ab_count == 0);
+	C2_ASSERT(xsd->xd_iface == 4);
+	C2_ASSERT(xsd->xd_media == 1);
+	C2_ASSERT(xsd->xd_size == 596000000000);
+	C2_ASSERT(xsd->xd_last_state == 3);
+	C2_ASSERT(xsd->xd_flags == 4);
+	C2_ASSERT(c2_buf_eq(&xsd->xd_filename, &fn));
+
+	C2_ASSERT(xsd->xd_partitions.ab_count == 1);
+	C2_ASSERT(c2_buf_eq(&xsd->xd_partitions.ab_elems[0],
+			    &(const struct c2_buf) C2_BUF_INITS("part0")));
+
 }
 
 static void partition_check(const struct confx_object *conf)
-- 
1.8.3.2

