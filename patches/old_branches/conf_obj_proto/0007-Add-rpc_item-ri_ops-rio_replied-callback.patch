From 744f7f8ad0d136e11d2833448c6e43b297b91976 Mon Sep 17 00:00:00 2001
From: "Valery V. Vorotyntsev" <valery_vorotyntsev@xyratex.com>
Date: Thu, 16 Feb 2012 19:07:21 +0200
Subject: [PATCH 007/370] Add rpc_item->ri_ops->rio_replied() callback.

+ confc.c (on_replied): ->rio_replied callback
+ confc.c (on_unpinned): don't forget to return true (true makes event
  "consumed")
---
 conf/conf.c     |  4 +--
 conf/conf.h     |  9 +++++-
 conf/confc.c    | 93 +++++++++++++++++++++++++++++++++++++++++----------------
 conf/confop.ff  |  7 ++++-
 conf/ut/conf.c  |  6 ++--
 conf/ut/confc.c |  2 +-
 conf/ut/path.c  |  2 +-
 7 files changed, 89 insertions(+), 34 deletions(-)

diff --git a/conf/conf.c b/conf/conf.c
index abc9658..897aba7 100644
--- a/conf/conf.c
+++ b/conf/conf.c
@@ -38,7 +38,7 @@ C2_TL_DESCR_DEFINE(c2_conf_filesystem_services,
 bool c2_conf_bytes_eq(const struct c2_conf_bytes *s1,
 		      const struct c2_conf_bytes *s2)
 {
-	return s1->cb_len == s2->cb_len
-		&& memcmp(s1->cb_data, s2->cb_data, s1->cb_len) == 0;
+	return s1->cb_size == s2->cb_size
+		&& memcmp(s1->cb_data, s2->cb_data, s1->cb_size) == 0;
 }
 C2_EXPORTED(c2_conf_bytes_eq);
diff --git a/conf/conf.h b/conf/conf.h
index 2576534..8ba32e9 100644
--- a/conf/conf.h
+++ b/conf/conf.h
@@ -28,6 +28,13 @@
 #include "lib/tlist.h" /* c2_tl */
 #include "lib/types.h"
 
+/**
+ * XXX Be sure to explain what this module (`conf' directory) is about.
+ * Such explanation --- a substitution for README file --- must be
+ * present in module's "main" file (this one or confc.h; use
+ * cross-references to make it more accessible).
+ */
+
 /** Type of configuration object. */
 enum c2_conf_objtype {
 	C2_CO_PROFILE,
@@ -49,7 +56,7 @@ enum c2_conf_status {
 
 /** Sequence of bytes. */
 struct c2_conf_bytes {
-	size_t   cb_len;
+	size_t   cb_size;
 	uint8_t *cb_data;
 };
 
diff --git a/conf/confc.c b/conf/confc.c
index baa3357..b0e2944 100644
--- a/conf/confc.c
+++ b/conf/confc.c
@@ -35,29 +35,53 @@ static struct c2_conf_cache confc_cache; /*< Confc's configuration cache. */
 enum confc_state { S_INITIAL, S_CHECK, S_WAIT_REPLY, S_WAIT_STATUS,
 		   S_GROW_CACHE, S_FAILURE, S_TERMINAL, S_NR };
 
-static void state_set(struct c2_sm_group *grp __attribute__((unused)),
-		      struct c2_sm_ast *ast)
+static void _state_set(struct c2_sm_group *grp __attribute__((unused)),
+		       struct c2_sm_ast *ast)
 {
 	struct c2_confc_fetchctx *ctx =
 		container_of(ast, struct c2_conf_fetchctx, fc__ast);
 	c2_sm_state_set(&ctx->fc__mach, (enum confc_state)ast->sa_datum);
 }
 
+static void _fail(struct c2_sm_group *grp __attribute__((unused)),
+		  struct c2_sm_ast *ast)
+{
+	struct c2_confc_fetchctx *ctx =
+		container_of(ast, struct c2_conf_fetchctx, fc__ast);
+	c2_sm_fail(&ctx->fc__mach, S_FAILURE, (int32_t)ast->sa_datum);
+}
+
+/** Posts an AST that will advance the state machine to given state. */
+static void ast_state_set(struct c2_sm_ast *ast, enum confc_state state)
+{
+	ast->sa_cb    = _state_set;
+	ast->sa_datum = state;
+	c2_sm_ast_post(confc_cache.cc_sm_group, ast);
+}
+
+/** Posts an AST that will move the state machine to S_FAILURE state. */
+static void ast_fail(struct c2_sm_ast *ast, int32_t rc)
+{
+	ast->sa_cb    = _fail;
+	ast->sa_datum = rc;
+	c2_sm_ast_post(confc_cache.cc_sm_group, ast);
+}
+
 /** Actions to perform on "object unpinned" event. */
-static bool unpinned_cb(struct c2_clink *link)
+static bool on_unpinned(struct c2_clink *link)
 {
 	struct c2_confc_fetchctx *ctx =
 		container_of(link, struct c2_confc_fetchctx, fc__clink);
 
-	ctx->fc__ast.sa_cb    = state_set;
-	ctx->fc__ast.sa_datum = S_CHECK;
-	c2_sm_ast_post(confc_cache.cc_sm_group, &ctx->fc__ast);
+	c2_clink_del(link);
+	ast_state_set(&ctx->fc__ast, S_CHECK);
+	return true;
 }
 
 void c2_confc_fetchctx_init(struct c2_confc_fetchctx *ctx)
 {
 	c2_chan_init(&ctx->fc_complete);
-	c2_clink_init(&ctx->fc__clink, unpinned_cb);
+	c2_clink_init(&ctx->fc__clink, on_unpinned);
 }
 C2_EXPORTED(c2_confc_fetchctx_init);
 
@@ -146,9 +170,9 @@ path_status(struct c2_confc_fetchctx *ctx, enum c2_conf_status *status)
 	if (*status == C2_CS_READY) {
 		C2_CNT_INC(obj->co_nrefs);
 		if (target_is_directory) {
-			XXX; /* fetchctx->fc_result = dir_allocate() */
+			XXX; /* ctx->fc_result = dir_allocate() */
 		} else {
-			fetchctx->fc_result = obj;
+			ctx->fc_result = obj;
 		}
 	} else if (*status == C2_CS_MISSING) {
 		if (!target_is_directory) {
@@ -180,17 +204,21 @@ end:
 	return ret;
 }
 
+static inline struct c2_confc_fetchctx * fetchctx(struct c2_sm *mach)
+{
+	C2_PRE(mach != NULL);
+	return container_of(mach, struct c2_confc_fetchctx, fc__mach);
+}
+
 /** Actions to perform on entering CHECK state. */
 static void check_st_in(struct c2_sm *mach)
 {
 	enum c2_conf_status status;
 	int rc;
-	struct c2_confc_fetchctx *ctx =
-		container_of(mach, struct c2_confc_fetchctx, fc__mach);
 
 	C2_PRE(c2_mutex_is_locked(&confc_cache.cc_sm_group->s_lock));
 
-	rc = path_status(ctx, &status);
+	rc = path_status(fetchctx(mach), &status);
 	if (rc != 0)
 		c2_sm_fail(mach, S_FAILURE, rc);
 	else if (status == C2_CS_MISSING)
@@ -205,27 +233,41 @@ static void check_st_in(struct c2_sm *mach)
 	C2_POST(c2_mutex_is_locked(&confc_cache.cc_sm_group->s_lock));
 }
 
+/** Actions to perform on RPC response arrival or an RPC error. */
+static void on_replied(struct c2_rpc_item *item)
+{
+	struct c2_fop *fop = container_of(item, struct c2_fop, f_item);
+	struct c2_confc_fetchctx *ctx =
+		container_of(fop, struct c2_confc_fetchctx, fc__fop);
+
+	if (item->ri_error == 0)
+		ast_state_set(&ctx->fc__ast, S_GROW_CACHE);
+	else
+		ast_fail(&ctx->fc__ast, item->ri_error);
+}
+
 /** Actions to perform on entering WAIT_REPLY state. */
 static void wait_reply_st_in(struct c2_sm *mach)
 {
 	int rc;
-	struct c2_confc_fetchctx *ctx =
-		container_of(mach, struct c2_confc_fetchctx, fc__mach);
-	const struct c2_confop_fetch *fop_data = ctx->fc__fop.f_data.fd_data;
-	/* XXX This fd_data field must be set somehow. */
+	struct c2_confc_fetchctx *ctx = fetchctx(mach);
+	const struct c2_confop_fetch *fop_data = c2_fop_data(&ctx->fc__fop);
+	/* XXX fop data must be set beforehand (see test_fop_encdec()
+	 * in xcode/ut/xcode_fop_test.c). */
 
-	C2_PRE(fop_data != NULL && fop_data->ff_origin.o_objkey.fb_len > 0
+	C2_PRE(fop_data != NULL && fop_data->ff_origin.o_objkey.fb_size > 0
 	       && fop_data->ff_origin.o_objkey.fb_data != NULL);
 
+	/* XXX c2_rpc_item need to be initialized properly. */
+	C2_ASSERT(ctx->fc__fop.f_item.ri_ops != NULL &&
+		  ctx->fc__fop.f_item.ri_ops->rio_replied == on_replied);
 	rc = c2_rpc_post(&ctx->fc__fop.f_item);
 	C2_ASSERT(rc == 0); /* c2_rpc_post() always returns 0, but hey */
 }
 
 static void complete(struct c2_sm *mach)
 {
-	struct c2_confc_fetchctx *ctx =
-		container_of(mach, struct c2_confc_fetchctx, fc__mach);
-	c2_chan_broadcast(&ctx->fc_complete);
+	c2_chan_broadcast(&fetchctx(mach)->fc_complete);
 }
 
 static bool failure_st_invariant(const struct c2_sm *mach)
@@ -239,7 +281,7 @@ static bool terminal_st_invariant(const struct c2_sm *mach)
 {
 	const struct c2_confc_fetchctx *ctx =
 		container_of(mach, const struct c2_confc_fetchctx, fc__mach);
-	return ctx->fc_result != NULL && ctx->fc__mach.sm_rc == 0;
+	return mach->sm_rc == 0 && ctx->fc_result != NULL;
 }
 
 static const struct c2_sm_state_descr confc_states[S_NR] = {
@@ -311,16 +353,17 @@ static struct c2_sm_conf confc_states_conf = {
 int c2_confc_open(const struct c2_conf_path *path,
 		  struct c2_confc_fetchctx *ctx)
 {
-	C2_PRE(XXX_is_just_initiated(ctx));
 	C2_PRE(c2_conf_path_invariant(path));
+	C2_PRE(XXX_is_just_initiated(ctx));
 
 	if (c2_conf_path_is_dir(path))
 		return -EISDIR;
 
+	/* XXX Consider copying of the path. Thus the caller would not
+	 * need to keep its path object alive. */
 	ctx->fc__path = path;
-	ctx->fc__ast.sa_cb    = state_set;
-	ctx->fc__ast.sa_datum = S_CHECK;
-	c2_sm_ast_post(confc_cache.cc_sm_group, &ctx->fc__ast);
+
+	ast_state_set(&ctx->fc__ast, S_CHECK);
 	return 0;
 }
 C2_EXPORTED(c2_confc_open);
diff --git a/conf/confop.ff b/conf/confop.ff
index 5b90f07..a49de7c 100644
--- a/conf/confop.ff
+++ b/conf/confop.ff
@@ -28,7 +28,7 @@ require "cfg/cfg"; /* C2_CFG_NAME_LEN, C2_CFG_PARAM_LEN,
  * XXX Can this structure be used instead of c2_conf_bytes?
  */
 sequence {
-	u32 fb_len;
+	u32 fb_size;
 	u8  fb_data
 } c2_confop_bytes;
 
@@ -143,6 +143,7 @@ record {
 	c2_confop_fixstr fp_filename
 } c2_confop_partition;
 
+/* Encoding of a configuration object. */
 record {
 	c2_confop_bytes fo_key;
 	union {
@@ -157,8 +158,12 @@ record {
 	} fo_val
 } c2_confop_obj;
 
+/* Confd's reponse to c2_confop_fetch. */
 record {
+	/* Result of configuration retrieval (-Exxx = failure, 0 = success). */
 	u32 ffr_rc;
+
+	/* A sequence of encoded configuration objects. */
 	sequence {
 		u32           d_nr;
 		c2_confop_obj d_objs
diff --git a/conf/ut/conf.c b/conf/ut/conf.c
index 60b22de..08fd9c5 100644
--- a/conf/ut/conf.c
+++ b/conf/ut/conf.c
@@ -27,12 +27,12 @@
 static void test_bytes(void)
 {
 	char s[] = "hello";
-	struct c2_conf_bytes a = { .cb_len = strlen(s), .cb_data = s };
-	struct c2_conf_bytes b = { .cb_len = strlen(s), .cb_data = "hello" };
+	struct c2_conf_bytes a = { .cb_size = strlen(s), .cb_data = s };
+	struct c2_conf_bytes b = { .cb_size = strlen(s), .cb_data = "hello" };
 
 	C2_UT_ASSERT(a.cb_data != b.cb_data);
 	C2_UT_ASSERT(c2_conf_bytes_eq(a, b));
-	++b.cb_len;
+	++b.cb_size;
 	C2_UT_ASSERT(!c2_conf_bytes_eq(a, b));
 }
 
diff --git a/conf/ut/confc.c b/conf/ut/confc.c
index 8dafaef..af322ba 100644
--- a/conf/ut/confc.c
+++ b/conf/ut/confc.c
@@ -82,8 +82,8 @@ static void test_init_fini(void)
 	C2_UT_ASSERT(obj->co_type   == C2_CO_PROFILE);
 	{
 		const struct c2_conf_bytes prof_bytes = {
+			.cb_size = strlen(prof)
 			.cb_data = prof,
-			.cb_len  = strlen(prof)
 		};
 		C2_UT_ASSERT(c2_conf_bytes_eq(obj->co_key, &prof_bytes));
 		C2_UT_ASSERT(/* allocated */ obj->co_key.cb_data != prof);
diff --git a/conf/ut/path.c b/conf/ut/path.c
index b3c68e4..1180e55 100644
--- a/conf/ut/path.c
+++ b/conf/ut/path.c
@@ -35,7 +35,7 @@ static void test_path_is_dir(void)
 	struct c2_conf_obj  prof = { .co_type = C2_CO_PROFILE };
 	struct c2_conf_obj  fs   = { .co_type = C2_CO_FILESYSTEM };
 	struct c2_conf_obj  node = { .co_type = C2_CO_NODE };
-#define DUMMY_KEY  { .cb_len = 0, .cb_data = NULL }
+#define DUMMY_KEY  { .cb_size = 0, .cb_data = NULL }
 	struct c2_conf_pathcomp comps[]    = {
 		/*0*/ C2_CONF_PATHCOMP_R(C2_CO_FILESYSTEM),
 		/*1*/ C2_CONF_PATHCOMP_R(C2_CO_SERVICE),
-- 
1.8.3.2

