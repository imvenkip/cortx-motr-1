From 8239b2fa800a453edead3803419835cf94c2842d Mon Sep 17 00:00:00 2001
From: "Valery V. Vorotyntsev" <valery_vorotyntsev@xyratex.com>
Date: Wed, 4 Apr 2012 18:08:14 +0300
Subject: [PATCH 123/370] describe state machine creation

+ Move state diagram to the top of `State Specification' section.
+ Make a list inside @note.
+ Fix a typo.

Reviewed-on: https://reviewboard.clusterstor.com/r/714/
Reported-by: Carl Braganza <carl_braganza@xyratex.com>
References:  LogD-1.3 #970
---
 conf/confc.c | 103 ++++++++++++++++++++++++++++++++++-------------------------
 1 file changed, 59 insertions(+), 44 deletions(-)

diff --git a/conf/confc.c b/conf/confc.c
index 9140bc3..1f56694 100644
--- a/conf/confc.c
+++ b/conf/confc.c
@@ -154,6 +154,12 @@
  *
  * - @ref confc-dld-lspec-comps
  * - @ref confc-dld-lspec-state
+ *   - @ref confc-dld-lspec-state-initial
+ *   - @ref confc-dld-lspec-state-check
+ *   - @ref confc-dld-lspec-state-wait-reply
+ *   - @ref confc-dld-lspec-state-wait-status
+ *   - @ref confc-dld-lspec-state-grow-cache
+ *   - @ref confc-dld-lspec-state-term
  * - @ref confc-dld-lspec-walk
  * - @ref confc-dld-lspec-grow
  * - @ref confc-dld-lspec-thread
@@ -186,18 +192,54 @@
  * <!------------------------------------------------------------------>
  * @subsection confc-dld-lspec-state State Specification
  *
+ * A confc state machine is embedded into c2_confc_ctx structure as
+ * its @ref c2_confc_ctx::fc_mach "fc_mach" member.
+ * c2_confc_ctx_init() initialises state machine and sets its state to
+ * S_INITIAL.
+ *
+ * @dot
+ * digraph confd_states {
+ *     node [fontsize=9];
+ *     edge [fontsize=9];
+ *     S_INITIAL  [style=filled, fillcolor=lightgrey];
+ *     S_TERMINAL [style=filled, fillcolor=lightgrey,
+ *                 label="{ completion_announce() }\nS_TERMINAL"];
+ *     S_FAILURE  [style=filled, fillcolor=lightgrey,
+ *                 label="{ completion_announce() }\nS_FAILURE"];
+ *
+ *     S_CHECK [label="{ check_st_in() }\nS_CHECK"];
+ *     S_WAIT_REPLY [label="{ wait_reply_st_in() }\nS_WAIT_REPLY"];
+ *     S_GROW_CACHE [label="{ grow_cache_st_in() }\nS_GROW_CACHE"];
+ *
+ *     S_INITIAL -> S_CHECK;
+ *     S_CHECK -> S_TERMINAL [label="all \"needed\" obj-s\nare cached"];
+ *     S_CHECK -> S_FAILURE [label="error"];
+ *     S_CHECK -> S_WAIT_REPLY [label=
+ *   "at least one\nof the \"needed\" obj-s\nis C2_CS_MISSING\n{ set status(es) to C2_CS_LOADING;\nsend request }"];
+ *     S_WAIT_REPLY -> S_FAILURE [label="timeout\nor\nrc != 0"];
+ *     S_WAIT_REPLY -> S_GROW_CACHE [label="response received,\nrc == 0"];
+ *     S_GROW_CACHE -> S_FAILURE [label="error"];
+ *     S_GROW_CACHE -> S_CHECK [label="done"];
+ *     S_CHECK -> S_WAIT_STATUS [label=
+ *   "no C2_CS_MISSING obj-s, but\nat least one is C2_CS_LOADING\n{ c2_clink_add(&obj->co_chan) }"];
+ *     S_WAIT_STATUS -> S_CHECK [label="\"status updated\" event"];
+ * }
+ * @enddot
+ *
+ * @subsubsection confc-dld-lspec-state-initial S_INITIAL
+ *
  * c2_confc_open() and c2_confc_diropen() check validity of `path'
  * argument, copy it to c2_confc_ctx::fc_path, and post an AST to
  * c2_confc::cc_group.
  *
  * @note  c2_sm_ast_post() signals group's clink. Current design of
- *        confc assumes that some external thread will respond to this
- *        event by calling c2_sm_asts_run().
+ *        confc assumes that some thread will respond to this event by
+ *        calling c2_sm_asts_run().
  *
  * When the AST, posted by c2_confc_open(), is run, it moves a state
  * machine (c2_confc_ctx::fc_mach) to S_CHECK state.
  *
- * - S_CHECK
+ * @subsubsection confc-dld-lspec-state-check S_CHECK
  *
  * When S_CHECK state is entered, check_st_in() callback is invoked.
  * It calls path_walk() and, depending on the value returned by this
@@ -217,12 +259,12 @@
  * The algorithm of path_walk() is described below (see @ref
  * confc-dld-lspec-walk).
  *
- * - S_WAIT_REPLY
+ * @subsubsection confc-dld-lspec-state-wait-reply S_WAIT_REPLY
  *
  * When a state machine is about to enter S_WAIT_REPLY state,
  * wait_reply_st_in() callback is executed. This callback sends
  * configuration request (c2_confc_ctx::fc_req) to the confd, using
- * c2_rpc_post().  (Not now; see @ref confc-offline.)
+ * c2_rpc_post().
  *
  * A state machine remains in S_WAIT_REPLY state until a reply from
  * confd arrives. This event triggers on_replied() callback.  If
@@ -232,7 +274,7 @@
  * counter (c2_rpc_item_get()) and posts an AST, scheduling transition
  * to S_GROW_CACHE state.
  *
- * - S_WAIT_STATUS
+ * @subsubsection confc-dld-lspec-state-wait-status S_WAIT_STATUS
  *
  * A state machine in S_WAIT_STATUS state remains idle until any of
  * the channels (c2_conf_obj::co_chan) that clinks of c2_confc_ctx are
@@ -242,59 +284,32 @@
  * state machine to S_CHECK state.
  *
  * @note  Object's channel (c2_conf_obj::co_chan) is signaled
- *        (c2_chan_broadcast())  1) when object_enrich() completes
- *        loading of configuration data into this object and changes
- *        status of this object to C2_CS_READY (loading succeeded) or
- *        C2_CS_MISSING (loading failed);  2) when the object is closed
- *        and its number of references becomes zero.  Of these cases
- *        only the first one is applicable to S_WAIT_STATUS state.
+ *        (c2_chan_broadcast()) when
+ *        -#
+ *          object_enrich() completes loading of configuration data
+ *          into this object and changes its status to C2_CS_READY
+ *          (loading succeeded) or C2_CS_MISSING (loading failed);
+ *        -#
+ *           the object is closed and its number of references becomes
+ *           zero.  This case is not applicable to S_WAIT_STATUS state.
  *
- * - S_GROW_CACHE
+ * @subsubsection confc-dld-lspec-state-grow-cache S_GROW_CACHE
  *
  * When a state machine is entering S_GROW_CACHE state,
  * grow_cache_st_in() callback is invoked.  If the error code
  * contained in confd's response (c2_conf_fetch_resp::fr_rc) is zero,
  * the callback calls cache_grow() function (see @ref
  * confc-dld-lspec-grow below).  The callback "releases" rpc item by
- * calling c2_rpc_item_but().  If ->fr_rc == 0 and cache_grow()
+ * calling c2_rpc_item_put().  If ->fr_rc == 0 and cache_grow()
  * succeeds, grow_cache_st_in() moves the state machine to S_CHECK
  * state, otherwise --- to S_FAILURE state.
  *
- * - S_TERMINAL, S_FAILURE
+ * @subsubsection confc-dld-lspec-state-term S_TERMINAL, S_FAILURE
  *
  * When a state machine enters S_TERMINAL or S_FAILURE state, it
  * invokes completion_announce() callback.  This function broadcasts
  * c2_confc_ctx::fc_complete channel.
  *
- * @dot
- * digraph confd_states {
- *     node [fontsize=9];
- *     edge [fontsize=9];
- *     S_INITIAL  [style=filled, fillcolor=lightgrey];
- *     S_TERMINAL [style=filled, fillcolor=lightgrey,
- *                 label="{ completion_announce() }\nS_TERMINAL"];
- *     S_FAILURE  [style=filled, fillcolor=lightgrey,
- *                 label="{ completion_announce() }\nS_FAILURE"];
- *
- *     S_CHECK [label="{ check_st_in() }\nS_CHECK"];
- *     S_WAIT_REPLY [label="{ wait_reply_st_in() }\nS_WAIT_REPLY"];
- *     S_GROW_CACHE [label="{ grow_cache_st_in() }\nS_GROW_CACHE"];
- *
- *     S_INITIAL -> S_CHECK;
- *     S_CHECK -> S_TERMINAL [label="all \"needed\" obj-s\nare cached"];
- *     S_CHECK -> S_FAILURE [label="error"];
- *     S_CHECK -> S_WAIT_REPLY [label=
- *   "at least one\nof the \"needed\" obj-s\nis C2_CS_MISSING\n{ set status(es) to C2_CS_LOADING;\nsend request }"];
- *     S_WAIT_REPLY -> S_FAILURE [label="timeout\nor\nrc != 0"];
- *     S_WAIT_REPLY -> S_GROW_CACHE [label="response received,\nrc == 0"];
- *     S_GROW_CACHE -> S_FAILURE [label="error"];
- *     S_GROW_CACHE -> S_CHECK [label="done"];
- *     S_CHECK -> S_WAIT_STATUS [label=
- *   "no C2_CS_MISSING obj-s, but\nat least one is C2_CS_LOADING\n{ c2_clink_add(&obj->co_chan) }"];
- *     S_WAIT_STATUS -> S_CHECK [label="\"status updated\" event"];
- * }
- * @enddot
- *
  * <!------------------------------------------------------------------>
  * @subsection confc-dld-lspec-walk Walking the DAG
  *
-- 
1.8.3.2

