From 1e678b49cf25d0d96bc8d4a1c1fbef326f7f71c1 Mon Sep 17 00:00:00 2001
From: "Valery V. Vorotyntsev" <valery_vorotyntsev@xyratex.com>
Date: Mon, 5 Mar 2012 01:24:31 +0200
Subject: [PATCH 039/370] c2_conf_cache: add cc_registry, delete cc_root

---
 conf/cache.h    |  25 ++++----------
 conf/confc.c    | 101 +++++++++++++++++++++++++-------------------------------
 conf/ut/confc.c |  12 +++----
 3 files changed, 57 insertions(+), 81 deletions(-)

diff --git a/conf/cache.h b/conf/cache.h
index bf3fba2..380d93f 100644
--- a/conf/cache.h
+++ b/conf/cache.h
@@ -20,38 +20,25 @@
 #ifndef __COLIBRI_CONF_CACHE_H__
 #define __COLIBRI_CONF_CACHE_H__
 
+#include "conf/map.h"  /* c2_conf_map */
 #include "lib/mutex.h" /* c2_mutex */
 
 struct c2_sm_group;
-struct c2_conf_obj;
 
 /** Configuration cache. */
 struct c2_conf_cache {
+	/** Registry of cached configuration objects. */
+	c2_conf_map         cc_registry;
 	/** Serializes confc state machines. */
-	struct c2_sm_group *cc_sm_group;
+	struct c2_sm_group *cc_group;
 	/**
 	 * Protects this structure and the overall configuration cache
 	 * (the DAG of configuration objects) from concurrent writes.
 	 */
 	struct c2_mutex     cc_lock;
-	/** Key-to-address mapping. */
-	XXX_db cc_map;
-	/**
-	 * Root configuration object.
-	 *
-	 * NULL for uninitialized confc.
-	 *
-	 * NULL for confd (single root is not applicable to confd,
-	 * which may have several profile objects in its cache).
-	 */
-	struct c2_conf_obj *cc_root;
 };
 
-/*
- * Those are confc and confd implementations, not configuration
- * consumers, who create configuration objects.
- */
-void c2_conf_obj_init(struct c2_conf_obj *obj);
-void c2_conf_obj_fini(struct c2_conf_obj *obj);
+void c2_conf_cache_init(struct c2_conf_cache *cache);
+void c2_conf_cache_fini(struct c2_conf_cache *cache);
 
 #endif /* __COLIBRI_CONF_CACHE_H__ */
diff --git a/conf/confc.c b/conf/confc.c
index 3dd96f3..505982e 100644
--- a/conf/confc.c
+++ b/conf/confc.c
@@ -151,16 +151,12 @@
  * (c2_conf_profile).  Cached configuration objects are allocated
  * dynamically.  Configuration cache is destroyed by c2_confc_fini().
  *
- * Besides the DAG of configuration objects, confc maintains a
- * key-to-address @b mapping --- an in-memory database that maps keys
- * of objects to memory addresses of these objects.  When new
- * configuration data arrives from the confd, confc consults this
- * mapping prior to adding new objects to the cache.
- *
- * Both configuration cache and key-to-address mapping are represented
- * by c2_conf_cache structure, defined in "conf/cache.h".  This
- * structure is used by confc and confd implementations; configuration
- * consumers does not need it.
+ * Besides the DAG of configuration objects, confc keeps a @b registry
+ * of cached objects --- an in-memory database that maps object
+ * identities (identity of an object is its key and type) to memory
+ * addresses of these objects.  When new configuration data arrives
+ * from the confd, confc consults the registry prior to adding new
+ * objects to the cache.
  *
  * @subsection confc-dld-lspec-state State Specification
  *
@@ -190,9 +186,10 @@
  * XXX
  */
 
-static struct c2_conf_cache confc_cache;
-
-static bool ctx_invariant(struct c2_confc_ctx *ctx);
+static struct {
+	struct c2_conf_cache    cache;
+	struct c2_conf_profile *root;
+} g_confc; /* `g_' for global variable */
 
 void c2_confc_ctx_init(struct c2_confc_ctx *ctx)
 {
@@ -213,20 +210,20 @@ C2_EXPORTED(c2_confc_ctx_fini);
 static enum c2_conf_status
 list_status(const struct c2_tl_descr *descr, const struct c2_tl *list)
 {
-	XXX;
 	/*
 	 * - If all of the objects are LOADING => return LOADING.
 	 * - If MISSING objects are found => change their statuses to
 	 *   LOADING and return MISSING.
 	 * - Otherwise (all objects are READY) return READY.
 	 */
+	XXX;
 }
 
 static inline struct c2_mutex * group_lock(void) {
-	return &confc_cache.cc_sm_group->s_lock;
+	return &g_confc.cache.cc_group->s_lock;
 }
 static inline struct c2_mutex * cache_lock(void) {
-	return &confc_cache.cc_lock;
+	return &g_confc.cache.cc_lock;
 }
 
 static inline struct c2_confc_ctx * to_ctx(struct c2_sm *mach)
@@ -247,9 +244,7 @@ static int
 path_walk(struct c2_confc_ctx *ctx, enum c2_conf_status *status)
 {
 	/*
-	 * XXX[remove this comment after DLDINSP]
-	 *
-	 * Refer to confc state diagram in the HLD.
+	 * [Refer to confc state diagram in the HLD.]
 	 *
 	 * path_walk() follows ctx->fc_path and checks the statuses
 	 * of met objects.  Upon success, the function sets *status to:
@@ -268,7 +263,8 @@ path_walk(struct c2_confc_ctx *ctx, enum c2_conf_status *status)
 	 *                  path_walk() registers ctx->fc_clink with
 	 *                  the channel(s) of loading object(s).
 	 */
-	struct c2_conf_obj *obj = ctx->fc_path.p_origin ?: confc_cache->cc_root;
+	struct c2_conf_obj *obj =
+		ctx->fc_path.p_origin ?: &g_confc.root->cp_obj;
 	struct c2_conf_pathcomp *comp = ctx->fc_path.p_comps;
 	size_t len = ctx->fc_path.p_len; /* number of components to go */
 	bool target_is_directory = false;
@@ -299,7 +295,7 @@ path_walk(struct c2_confc_ctx *ctx, enum c2_conf_status *status)
 			++comp;
 			C2_ASSERT(comp->pc_iskey);
 
-			/* XXX use the key-to-address mapping instead
+			/* XXX use the objid-to-address mapping instead
 			 * of list_find() */
 			child = list_find(XXX_dir, comp->pc_u.key);
 
@@ -350,11 +346,12 @@ end:
 
 static bool confc_is_initiated(void)
 {
-	C2_PRE(equi(confc_cache.cc_root, confc_cache.cc_sm_group));
-	return confc_cache.cc_root != NULL;
+	C2_PRE(equi(g_confc.root, g_confc.cache.cc_group));
+	return g_confc.root != NULL;
 }
 
-int c2_confc_init(const char *profile, const char *confd_addr /*XXX*/,
+int c2_confc_init(const char *profile,
+		  const char *confd_addr, /* XXX unused */
 		  struct c2_sm_group *sm_group)
 {
 	/*
@@ -364,15 +361,15 @@ int c2_confc_init(const char *profile, const char *confd_addr /*XXX*/,
 	 * C2_PRE(profile != NULL && *profile != 0);
 	 * C2_PRE(sm_group != NULL);
 	 *
-	 * confc_cache.cc_sm_group = sm_group;
-	 * c2_mutex_init(&confc_cache.cc_lock);
+	 * g_confc.cache.cc_group = sm_group;
+	 * c2_mutex_init(cache_lock());
 	 *
-	 * map_init(&confc_cache.cc_map);
+	 * c2_conf_map_init(&g_confc.cc_registry);
 	 *
 	 * root = allocate c2_conf_profile object;
 	 * copy `profile' to root->cp_obj.co_key;
-	 * map_add(&root->cp_obj);
-	 * confc_cache.cc_root = root;
+	 * c2_conf_map_add(&g_confc.cache.cc_registry, &root->cp_obj);
+	 * g_confc.root = root;
 	 *
 	 * C2_POST(confc_is_initiated());
 	 */
@@ -389,18 +386,18 @@ void c2_confc_fini(void)
 	 * c2_mutex_lock(group_lock());
 	 * c2_mutex_lock(cache_lock());
 	 *
-	 * for (obj in confc_cache.cc_map) {
+	 * for (obj in g_confc.cache.cc_registry) {
 	 * 	C2_ASSERT(obj->co_nrefs == 0
 	 * 		&& obj->co_status != C2_CS_LOADING);
 	 * 	c2_free(obj);
 	 * }
-	 * map_fini(&confc_cache.cc_map);
-	 * confc_cache.cc_root = NULL;
+	 * c2_confc_map_fini(&g_confc.cache.cc_registry);
+	 * g_confc.root = NULL;
 	 *
 	 * c2_mutex_unlock(cache_lock());
 	 * c2_mutex_fini(cache_lock());
 	 * c2_mutex_unlock(group_lock());
-	 * confc_cache.cc_sm_group = NULL;
+	 * g_confc.cache.cc_group = NULL;
 	 *
 	 * C2_POST(!confc_is_initiated());
 	 */
@@ -477,7 +474,7 @@ struct c2_confc_dir {
 	/** List descriptor. */
 	const struct c2_tl_descr *d_descr;
 };
-
+
 /* ------------------------------------------------------------------
  * Request-related functions.
  * ------------------------------------------------------------------ */
@@ -506,7 +503,7 @@ request_fill(struct c2_conf_fetch *req, const struct c2_conf_obj *path_org,
 
 	C2_POST(request_is_valid(req));
 }
-
+
 /* ------------------------------------------------------------------
  * State transitions.
  * ------------------------------------------------------------------ */
@@ -535,7 +532,7 @@ static void ast_state_set(struct c2_sm_ast *ast, enum confc_state state)
 {
 	ast->sa_cb    = _state_set;
 	ast->sa_datum = state;
-	c2_sm_ast_post(confc_cache.cc_sm_group, ast);
+	c2_sm_ast_post(g_confc.cache.cc_group, ast);
 }
 
 /** Posts an AST that will move the state machine to S_FAILURE state. */
@@ -543,7 +540,7 @@ static void ast_fail(struct c2_sm_ast *ast, int32_t rc)
 {
 	ast->sa_cb    = _fail;
 	ast->sa_datum = rc;
-	c2_sm_ast_post(confc_cache.cc_sm_group, ast);
+	c2_sm_ast_post(g_confc.cache.cc_group, ast);
 }
 
 /** Actions to perform on entering CHECK state. */
@@ -599,7 +596,9 @@ static void grow_cache_st_in(struct c2_sm *mach)
 	 * for (fetched in resp->ffr_data) {
 	 *     C2_ASSERT(fetched->fo_key is not empty &&
 	 *               fetched->fo_val.v_type < C2_CO_NR);
-	 *     cached = map_lookup(fetched->fo_key, fetched->fo_val.v_type);
+	 *     cached = c2_conf_map_lookup(&g_confc.cache.cc_registry,
+	 *                                 &fetched->fo_key,
+	 *                                 fetched->fo_val.v_type);
 	 *     if (cached == NULL)
 	 *         rc = cache_add(fetched);
 	 *     else
@@ -732,10 +731,11 @@ static struct c2_sm_conf confc_states_conf = {
 	.scf_nr_states = S_NR,
 	.scf_state     = confc_states
 };
-
+
 /* ------------------------------------------------------------------
  * Confc cache management.
  * ------------------------------------------------------------------ */
+
 static int
 object_enrich(struct c2_conf_obj *dest, const struct c2_confx_obj *src)
 {
@@ -761,7 +761,7 @@ object_enrich(struct c2_conf_obj *dest, const struct c2_confx_obj *src)
 	 */
 	XXX;
 }
-
+
 /* ------------------------------------------------------------------
  * misc
  * ------------------------------------------------------------------ */
@@ -775,30 +775,19 @@ static bool ctx_invariant(struct c2_confc_ctx *ctx)
 		item->ri_ops->rio_replied == on_replied &&
 		c2_fop_data(ctx->fc_fop) == &ctx->fc_req;
 }
-
+
 /* ------------------------------------------------------------------
  * XXX Symbols to define.
  * ------------------------------------------------------------------ */
-map_init();
-map_fini();
-
-/**
- * Adds new entry to the "key-to-address" mapping.
- *
- * @pre  The mapping does not contain given object.
- */
-static int map_add(struct XXX_map *registry, const struct c2_conf_obj *obj);
-
-static struct c2_conf_obj * map_lookup(const struct c2_conf_buf *key,
-				       uint8_t type);
 
 /**
  * Allocates new configuration object and sets its fields from on-wire data.
  *
- * @param registry  Key-to-address mapping.
+ * @param registry  Objid-to-address mapping.
  * @param src       Configuration object as received from confd.
  */
-static int cache_add(struct XXX_map *registry, const struct c2_confx_obj *src)
+static int
+cache_add(struct c2_conf_map *registry, const struct c2_confx_obj *src)
 {
 	/*
 	 * struct c2_conf_obj *obj;
@@ -813,7 +802,7 @@ static int cache_add(struct XXX_map *registry, const struct c2_confx_obj *src)
 	 * 	return -ENOMEM;
 	 *
 	 * rc = ops->oo_enrich(obj, src);
-	 * rc = ?: map_add(registry, obj);
+	 * rc = ?: c2_conf_map_add(registry, obj);
 	 *
 	 * if (rc != 0)
 	 * 	c2_free(obj);
diff --git a/conf/ut/confc.c b/conf/ut/confc.c
index f14c6ee..32aa827 100644
--- a/conf/ut/confc.c
+++ b/conf/ut/confc.c
@@ -71,11 +71,11 @@ static void test_init_fini(void)
 	rc = c2_confc_init(prof, "XXX_endpoint", &group);
 	C2_UT_ASSERT(rc == 0);
 	C2_UT_ASSERT(confc_is_initialized());
-	C2_UT_ASSERT(confc_cache.cc_sm_group == &group);
-	C2_UT_ASSERT(!c2_mutex_is_locked(&confc_cache.cc_lock));
-	C2_UT_ASSERT(confc_cache.cc_root != NULL);
+	C2_UT_ASSERT(g_confc.cache.cc_group == &group);
+	C2_UT_ASSERT(!c2_mutex_is_locked(&g_confc.cache.cc_lock));
+	C2_UT_ASSERT(g_confc.root != NULL);
 
-	root = confc_cache.cc_root;
+	root = &g_confc.root->cp_obj;
 	C2_UT_ASSERT(root->co_type == C2_CO_PROFILE);
 	C2_UT_ASSERT(root->co_status == C2_CS_MISSING);
 	C2_UT_ASSERT(c2_conf_buf_eq(root->co_key, &prof_buf));
@@ -111,7 +111,7 @@ static void test_ctx(void)
 
 static void test_path_status(void)
 {
-	c2_mutex_lock(&confc_cache.cc_sm_group->s_lock);
+	c2_mutex_lock(&g_confc.cache.cc_group->s_lock);
 	/* XXX
 	 * Call path_status(ctx, &status) with different paths
 	 * (ctx->fc_path) and ensure that:
@@ -127,7 +127,7 @@ static void test_path_status(void)
 	 * - elsif ...XXX
 	 */
 	C2_UT_FAIL("XXX not implemented");
-	c2_mutex_unlock(&confc_cache.cc_sm_group->s_lock);
+	c2_mutex_unlock(&g_confc.cache.cc_group->s_lock);
 }
 
 static void test_open(void)
-- 
1.8.3.2

