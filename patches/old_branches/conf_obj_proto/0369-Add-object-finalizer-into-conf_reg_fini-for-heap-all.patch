From 029a8580c927d562219c8cc00ce30a8647fce3be Mon Sep 17 00:00:00 2001
From: Anatoliy Bilenko <anatoliy_bilenko@xyratex.com>
Date: Sun, 16 Sep 2012 21:41:49 +0300
Subject: [PATCH 369/370] Add object finalizer into conf_reg_fini() for
 heap-allocated objects;

    - general cleanup.
---
 conf/reg2.c    |  12 ++++-
 conf/reg2.h    |   3 +-
 conf/ut/knot.c | 157 +++++++++++++++++++++++++++------------------------------
 3 files changed, 86 insertions(+), 86 deletions(-)

diff --git a/conf/reg2.c b/conf/reg2.c
index 13e0b30..0287cc9 100644
--- a/conf/reg2.c
+++ b/conf/reg2.c
@@ -6,8 +6,18 @@ void c2_reg_init(struct c2_reg *reg, c2_reg_equal_t eq)
 	reg->r_equal = eq;
 }
 
-void c2_reg_fini(struct c2_reg *reg)
+void c2_reg_fini(struct c2_reg *reg,
+		 void (*destruct)(struct c2_list_link *l))
 {
+	if (destruct != NULL) {
+		struct c2_list_link *link;
+
+		while ((link = c2_list_first(&reg->r_elems)) != NULL) {
+			c2_reg_del(reg, link);
+			destruct(link);
+		}
+	}
+
 	c2_list_fini(&reg->r_elems);
 }
 
diff --git a/conf/reg2.h b/conf/reg2.h
index e213167..511e59c 100644
--- a/conf/reg2.h
+++ b/conf/reg2.h
@@ -14,7 +14,8 @@ struct c2_reg {
 };
 
 void c2_reg_init(struct c2_reg *reg, c2_reg_equal_t eq);
-void c2_reg_fini(struct c2_reg *reg);
+void c2_reg_fini(struct c2_reg *reg,
+		 void (*destruct)(struct c2_list_link *link));
 
 void c2_reg_add(struct c2_reg *reg, struct c2_list_link *link);
 void c2_reg_del(struct c2_reg *reg, struct c2_list_link *link);
diff --git a/conf/ut/knot.c b/conf/ut/knot.c
index c319c22..10cfb50 100644
--- a/conf/ut/knot.c
+++ b/conf/ut/knot.c
@@ -3,6 +3,7 @@
 #include "conf/onwire.h"
 #include "conf/preload.h"
 #include "lib/thread.h" /* LAMBDA */
+#include "lib/memory.h"
 #include "lib/errno.h"
 #include "lib/arith.h"
 #include <stdio.h>
@@ -310,7 +311,7 @@ static void reg_test(void)
 		reg_obj_fini(&o[i]);
 	}
 
-	c2_reg_fini(&reg);
+	c2_reg_fini(&reg, NULL);
 }
 
 
@@ -482,35 +483,20 @@ static bool conf_obj_has_fkeys(struct conf_obj *obj)
 
 static void conf_obj_init(struct conf_obj *obj, struct confx_object *xobj)
 {
-	struct c2_knot_whoami who;
-	switch(xobj->o_conf.u_type) {
-	case C2_CO_PROFILE   :
-		who = (struct c2_knot_whoami) { conf_obj_id, co_profile_fk };
-		break;
-	case C2_CO_FILESYSTEM:
-		who = (struct c2_knot_whoami) { conf_obj_id, co_filesystem_fk };
-		break;
-	case C2_CO_SERVICE   :
-		who = (struct c2_knot_whoami) { conf_obj_id, co_service_fk };
-		break;
-	case C2_CO_NODE      :
-		who = (struct c2_knot_whoami) { conf_obj_id, co_node_fk };
-		break;
-	case C2_CO_NIC       :
-		who = (struct c2_knot_whoami) { conf_obj_id, co_nic_fk };
-		break;
-	case C2_CO_SDEV      :
-		who = (struct c2_knot_whoami) { conf_obj_id, co_sdev_fk };
-		break;
-	case C2_CO_PARTITION :
-		who = (struct c2_knot_whoami) { conf_obj_id, co_partition_fk };
-		break;
-	case C2_CO_DIR       :
-	default:
-		who = (struct c2_knot_whoami) { NULL, NULL };
+	struct c2_knot_whoami who[C2_CO_NR] = {
+		[C2_CO_PROFILE   ] = { conf_obj_id, co_profile_fk    },
+		[C2_CO_FILESYSTEM] = { conf_obj_id, co_filesystem_fk },
+		[C2_CO_SERVICE	 ] = { conf_obj_id, co_service_fk    },
+		[C2_CO_NODE	 ] = { conf_obj_id, co_node_fk       },
+		[C2_CO_NIC	 ] = { conf_obj_id, co_nic_fk        },
+		[C2_CO_SDEV	 ] = { conf_obj_id, co_sdev_fk       },
+		[C2_CO_PARTITION ] = { conf_obj_id, co_partition_fk  },
+		[C2_CO_DIR	 ] = { NULL	  , NULL             },
 	};
 
-	c2_knot_init(&obj->co_knot, who);
+	C2_ASSERT(xobj->o_conf.u_type < C2_CO_NR);
+
+	c2_knot_init(&obj->co_knot, who[xobj->o_conf.u_type]);
 	c2_list_link_init(&obj->co_link);
 	obj->co_data = *xobj;
 }
@@ -526,11 +512,6 @@ static void conf_reg_add(struct c2_reg *reg, struct conf_obj *o)
 	c2_reg_add(reg, &o->co_link);
 }
 
-static void conf_reg_del(struct c2_reg *reg, struct conf_obj *o)
-{
-	c2_reg_del(reg, &o->co_link);
-}
-
 static struct conf_obj *conf_reg_lookup(const struct c2_reg *reg,
 					const struct c2_buf *value)
 {
@@ -578,73 +559,87 @@ static int confx_read(struct confx_object *conf, size_t conf_count)
 	return n;
 }
 
+static void conf_obj_visit(const struct c2_list_link *l)
+{
+	int i;
+	struct c2_knot_uuid pid;
+	struct c2_knot_uuid cid;
+	char pb[256] = { 0 }; /* @todo: horrible! */
+	struct conf_obj *o = c2_list_entry(l, struct conf_obj, co_link);
+
+	for (i = 0; o->co_knot.k_who.kw_fk(&o->co_knot, &cid, i) == 0; ++i) {
+		char cb[256] = { 0 }; /* @todo: horrible! */
+
+		o->co_knot.k_who.kw_id(&o->co_knot, &pid);
+		memcpy(pb, pid.ku_id.b_addr, min64u(255ULL, pid.ku_id.b_nob));
+		memcpy(cb, cid.ku_id.b_addr, min64u(255ULL, cid.ku_id.b_nob));
+
+		printf("\"%s\" -> \"%s\"\n", pb, cb);
+	}
+}
+
+static void conf_obj_digraph_create(const struct c2_reg* reg)
+{
+	printf("digraph obj {\n");
+	c2_reg_iterate(reg, conf_obj_visit);
+	printf("}\n");
+}
+
 /**
  * @pre obj is not in DAG
  */
-static int dag_link(struct c2_reg *reg, struct conf_obj *obj)
+static int dag_link(struct c2_reg *reg, struct confx_object *objx)
 {
 	int i;
 	int rc;
-	struct c2_knot_whoami  who = obj->co_knot.k_who;
+	struct c2_knot_whoami  who;
 	struct c2_knot_uuid    uuid;
 	struct conf_obj       *child;
+	struct conf_obj	      *parent;
 
-	/* !!! ----------------------------------- !!! */
 	/* @todo: &uuid.ku_type should be passed also! */
-	/* !!! ----------------------------------- !!! */
+	/* @todo: confx update is not supported yet    */
+	C2_ASSERT(conf_reg_lookup(reg, &objx->o_id) == NULL);
+
+	C2_ALLOC_PTR(parent);
+	if (parent == NULL)
+		return -ENOMEM;
 
-	if (conf_obj_has_fkeys(obj)) {
-		for (i = 0; who.kw_fk(&obj->co_knot, &uuid, i) == 0; ++i) {
+	conf_obj_init(parent, objx);
+	who = parent->co_knot.k_who;
+
+	if (conf_obj_has_fkeys(parent)) {
+		for (i = 0; who.kw_fk(&parent->co_knot, &uuid, i) == 0; ++i) {
 			child = conf_reg_lookup(reg, &uuid.ku_id);
 			if (child == NULL)
 				return -ENOENT;
 
-			rc = c2_knot_link(KCAST(obj), KCAST(child));
+			rc = c2_knot_link(KCAST(parent), KCAST(child));
 			if (rc != 0) {
-				/* @todo: delete knots on error! */
+				/* @todo: frees childs? check it! */
+				conf_obj_fini(parent);
+				c2_free(parent);
 				return rc;
 			}
 		}
 	}
 
-	conf_reg_add(reg, obj);
+	conf_reg_add(reg, parent);
 
 	return 0;
 }
 
-static void conf_obj_visit(const struct c2_list_link *l)
+static void dag_reg_dtor(struct c2_list_link *l)
 {
-	int i;
-	struct c2_knot_uuid pid;
-	struct c2_knot_uuid cid;
-	char pb[256] = { 0 }; /* @todo: horrible! */
 	struct conf_obj *o = c2_list_entry(l, struct conf_obj, co_link);
-
-	for (i = 0; o->co_knot.k_who.kw_fk(&o->co_knot, &cid, i) == 0; ++i) {
-		char cb[256] = { 0 }; /* @todo: horrible! */
-
-		o->co_knot.k_who.kw_id(&o->co_knot, &pid);
-		memcpy(pb, pid.ku_id.b_addr, min64u(255ULL, pid.ku_id.b_nob));
-		memcpy(cb, cid.ku_id.b_addr, min64u(255ULL, cid.ku_id.b_nob));
-
-		printf("\"%s\" -> \"%s\"\n", pb, cb);
-	}
-}
-
-static void conf_obj_digraph_create(const struct c2_reg* reg,
-				    const struct conf_obj *obj)
-{
-	printf("digraph obj {\n");
-	c2_reg_iterate(reg, conf_obj_visit);
-	printf("}\n");
+	conf_obj_fini(o);
+	c2_free(o);
 }
 
 static void dag_test(void)
 {
 	static struct confx_object confx[100];
-	struct conf_obj conf[100];
 	struct c2_reg reg;
-
 	int conf_count;
 	int rc;
 	int i;
@@ -657,19 +652,13 @@ static void dag_test(void)
 	c2_reg_init(&reg, conf_obj_eq);
 
 	for (i = conf_count - 1; i >= 0; --i) {
-		conf_obj_init(&conf[i], &confx[i]);
-		rc = dag_link(&reg, &conf[i]);
+		rc = dag_link(&reg, &confx[i]);
 		C2_ASSERT(rc == 0);
 	}
 
-	conf_obj_digraph_create(&reg, &conf[0]);
-
-	for (i = 0; i < conf_count; ++i) {
-		conf_reg_del(&reg, &conf[i]);
-		conf_obj_fini(&conf[i]);
-	}
+	conf_obj_digraph_create(&reg);
 
-	c2_reg_fini(&reg);
+	c2_reg_fini(&reg, dag_reg_dtor);
 	c2_confx_fini(confx, conf_count);
 }
 
@@ -679,14 +668,14 @@ static void dag_test(void)
    ---------------------------------------------------------------------- */
 /* @TODO:  Alternative DAG linker TODO:
  *
- * 1)  add object finalizer into conf_reg_fini() for heap-allocated objects;
- * 2)  add link-rules to follow them while adding type1 into type2;
- * 2') add new obj type registration procedure (affects (2));
- * 3)  add usage of 'c2_knot_whoami::ku_type' for type distinguishing.
- * 4)  general cleanup; separate different components cleanly (e.g. c2_reg)!
- * 5)  write tests on each subsystem;
- * 6)  optimize when ready, remove extra abstraction layers, try to
- *     remove allocation in knot-list.
+ * 1) [X] add object finalizer into conf_reg_fini() for heap-allocated objects;
+ * 2) [ ] add link-rules to follow them while adding type1 into type2;
+ * 2')[ ] add new obj type registration procedure (affects (2));
+ * 3) [ ] add usage of 'c2_knot_whoami::ku_type' for type distinguishing.
+ * 4) [ ] general cleanup; separate different components cleanly (e.g. c2_reg)!
+ * 5) [ ] write tests on each subsystem;
+ * 6) [ ] optimize when ready, remove extra abstraction layers, try to
+ *       remove allocation in knot-list.
  */
 
 
-- 
1.8.3.2

