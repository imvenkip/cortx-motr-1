From d4e4d733cd8c894db14bf819efdb54dc50d52320 Mon Sep 17 00:00:00 2001
From: "Valery V. Vorotyntsev" <valery_vorotyntsev@xyratex.com>
Date: Mon, 13 Feb 2012 17:39:06 +0200
Subject: [PATCH 005/370] some more unit tests for c2_conf_path

+ ut/path.c: unit-test c2_conf_path_is_dir()
+ ut/confc.c: start describing path_status() tests
---
 conf/confc.c    | 55 ++++++++++++++++++++++++++++---------------------------
 conf/confc.h    |  3 ++-
 conf/path.h     |  8 ++++++--
 conf/ut/confc.c | 41 +++++++++++++++++++++++++++++++----------
 conf/ut/path.c  | 50 +++++++++++++++++++++++++++++++++++++++++++++++++-
 5 files changed, 116 insertions(+), 41 deletions(-)

diff --git a/conf/confc.c b/conf/confc.c
index 4b4d869..aba4870 100644
--- a/conf/confc.c
+++ b/conf/confc.c
@@ -79,7 +79,9 @@ list_status(const struct c2_tl_descr *descr, const struct c2_tl *list)
 }
 
 /**
- * @pre  c2_conf_path_invariant(ctx->fc__path)
+ * @pre   cache's sm_group is locked
+ * @pre   c2_conf_path_invariant(ctx->fc__path)
+ * @post  cache's sm_group is locked
  *
  * @retval -ENOENT  ctx->fc__path contains a key and the corresponding
  *                  object does not exist.
@@ -90,14 +92,17 @@ path_status(struct c2_confc_fetchctx *ctx, enum c2_conf_status *status)
 	struct c2_conf_obj *obj = ctx->fc__path->p_origin ?:
 		confc_cache->cc_root;
 	struct c2_conf_pathcomp *comp = ctx->fc__path->p_comps;
-	size_t nr = ctx->fc__path->p_nr_comps; /* nr of remaining components */
+	size_t len = ctx->fc__path->p_len; /* number of components to go */
 	bool target_is_directory = false;
+	int ret = 0;
 
+	C2_PRE(c2_mutex_is_locked(&confc_cache.cc_sm_group->s_lock));
 	C2_PRE(c2_conf_path_invariant(ctx->fc__path));
+
 	c2_mutex_lock(&confc_cache.cc_lock);
 	*status = obj->co_status;
 
-	for (; *status == C2_CS_READY && nr > 0; --nr, ++comp) {
+	for (; *status == C2_CS_READY && len > 0; --len, ++comp) {
 		const struct c2_conf_relation *rel;
 		struct c2_conf_obj *child;
 		C2_ASSERT(!comp->pc_iskey);
@@ -107,16 +112,18 @@ path_status(struct c2_confc_fetchctx *ctx, enum c2_conf_status *status)
 		target_is_directory = rel->r_dir != NULL;
 
 		if (target_is_directory) {
-			if (nr == 1) { /* the last component */
+			if (len == 1) { /* the last component */
 				*status = list_status(XXX_descr, XXX_list);
 				break;
 			}
 
-			--nr;
+			--len;
 			++comp;
 			C2_ASSERT(comp->pc_iskey);
-			/* XXX list_find() */
+
+			/* XXX use the hash table instead of list_find() */
 			child = list_find(XXX_dir, comp->pc_u.key);
+
 			target_is_directory = false;
 		} else {
 			/* child = *(struct c2_conf_obj **)((void *)obj */
@@ -126,8 +133,8 @@ path_status(struct c2_confc_fetchctx *ctx, enum c2_conf_status *status)
 
 		if (child == NULL) {
 			C2_ASSERT(comp->pc_iskey);
-			c2_mutex_unlock(&confc_cache.cc_lock);
-			return -ENOENT; /* no such key */
+			ret = -ENOENT; /* no such key */
+			goto end;
 		}
 
 		obj = child;
@@ -152,7 +159,7 @@ path_status(struct c2_confc_fetchctx *ctx, enum c2_conf_status *status)
 			 * Encode the following into ctx->fc__fop:
 			 *   .ff_origin.o_objtype = obj->co_objtype;
 			 *   .ff_origin.o_objkey <- obj->co_objkey;
-			 *   .ff_comps.c_nr       = nr;
+			 *   .ff_comps.c_nr       = len;
 			 *   .ff_comps.c_data    <- comp.
 			 */
 		}
@@ -165,9 +172,10 @@ path_status(struct c2_confc_fetchctx *ctx, enum c2_conf_status *status)
 	} else {
 		C2_IMPOSSIBLE("invalid object status");
 	}
-
+end:
 	c2_mutex_unlock(&confc_cache.cc_lock);
-	return 0;
+	C2_POST(c2_mutex_is_locked(&confc_cache.cc_sm_group->s_lock));
+	return ret;
 }
 
 /** Actions to perform on entering CHECK state. */
@@ -198,24 +206,17 @@ static void check_st_in(struct c2_sm *mach)
 /** Actions to perform on entering WAIT_REPLY state. */
 static void wait_reply_st_in(struct c2_sm *mach)
 {
+	int rc;
 	struct c2_confc_fetchctx *ctx =
 		container_of(mach, struct c2_confc_fetchctx, fc_mach);
+	const struct c2_confop_fetch *fop_data = ctx->fc__fop.f_data.fd_data;
+	/* XXX This fd_data field must be set somehow. */
 
-	C2_ASSERT(ctx->fc__fop.ff_origin.o_objkey.fb_len > 0 &&
-		  ctx->fc__fop.ff_origin.o_objkey.fb_data != NULL);
+	C2_PRE(fop_data != NULL && fop_data->ff_origin.o_objkey.fb_len > 0
+	       && fop_data->ff_origin.o_objkey.fb_data != NULL);
 
-	/* XXX
-	 * Where do I get c2_rpc_item from?  There is one embedded
-	 * into c2_fop (c2_fop::f_item), but ctx->fc__fop is not a
-	 * c2_fop...
-	 *
-	 * Another question: should xcode data structure
-	 * (c2_confop_fetch) be accessible through c2_fop::f_data?
-	 *
-	 * I need somebody to consult me on RPC subject.
-	 *  --vvv, 2012-02-10
-	 */
-	c2_rpc_post(&XXX_rpc_item);
+	rc = c2_rpc_post(&ctx->fc__fop.f_item);
+	C2_ASSERT(rc == 0); /* c2_rpc_post() always returns 0, but hey */
 }
 
 static bool failure_st_invariant(const struct c2_sm *mach)
@@ -349,14 +350,14 @@ C2_EXPORTED(c2_confc_close);
 /** Collection of configuration objects. */
 struct c2_confc_dir {
 	/** Parent object this collection belongs to. */
-	struct c2_conf_obj *d_parent;
+	struct c2_conf_obj       *d_parent;
 
 	/**
 	 * Currently opened (and pinned) element of this collection.
 	 *
 	 * The value is updated by c2_confc_dirnext().
 	 */
-	struct c2_conf_obj *d_current;
+	struct c2_conf_obj       *d_current;
 
 	/** List descriptor. */
 	const struct c2_tl_descr *d_descr;
diff --git a/conf/confc.h b/conf/confc.h
index 0105db5..04a2b2d 100644
--- a/conf/confc.h
+++ b/conf/confc.h
@@ -58,7 +58,7 @@ struct c2_confc_fetchctx {
 	 * collection of objects). */
 	const struct c2_conf_path *fc__path;
 
-	struct c2_confop_fetch     fc__fop;
+	struct c2_fop              fc__fop;
 	struct c2_sm_ast           fc__ast;
 
 	/**
@@ -75,6 +75,7 @@ void c2_confc_fetchctx_fini(struct c2_confc_fetchctx *ctx);
 /** Returns the error status for the asynchronous configuration request. */
 static inline int32_t c2_confc_error(const struct c2_confc_fetchctx *ctx)
 {
+	C2_PRE(ctx->fc_mach.sm_rc <= 0);
 	return -ctx->fc_mach.sm_rc;
 }
 
diff --git a/conf/path.h b/conf/path.h
index 88f6254..b19bdd0 100644
--- a/conf/path.h
+++ b/conf/path.h
@@ -32,7 +32,7 @@ struct c2_conf_pathcomp {
 
 struct c2_conf_path {
 	struct c2_conf_obj      *p_origin;
-	size_t                   p_nr_comps;
+	size_t                   p_len;
 	struct c2_conf_pathcomp *p_comps;
 };
 
@@ -46,7 +46,11 @@ struct c2_conf_path {
  */
 bool c2_conf_path_invariant(const struct c2_conf_path *path);
 
-/** Returns true iff the path ends with a one-to-many downlink. */
+/**
+ * Returns true iff the path ends with a one-to-many downlink.
+ *
+ * @pre  c2_conf_path_invariant(path)
+ */
 bool c2_conf_path_is_dir(const struct c2_conf_path *path);
 
 #endif /* __COLIBRI_CONF_PATH_H__ */
diff --git a/conf/ut/confc.c b/conf/ut/confc.c
index ed5f217..0b0c77c 100644
--- a/conf/ut/confc.c
+++ b/conf/ut/confc.c
@@ -22,11 +22,12 @@
 #  include <config.h>
 #endif
 #include "conf/confc.c"
-#include <string.h>     /* strlen */
+#include <string.h>     /* strlen, memcmp */
 
 static struct c2_sm_group g_grp;
 static struct c2_thread   g_ath;
 static bool               g_more = true;
+static const char         g_profile[] = "test-profile";
 
 static void ast_thread(int n __attribute__((unused)))
 {
@@ -42,7 +43,7 @@ static int init(void)
 	int rc;
 	c2_sm_group_init(&g_grp);
 	rc = C2_THREAD_INIT(&g_ath, int, NULL, ast_thread, 0, "ast_thread");
-	rc = rc ?: c2_confc_init("test-profile", "XXX_endpoint", &g_grp);
+	rc = rc ?: c2_confc_init(g_profile, "XXX_endpoint", &g_grp);
 	return rc;
 }
 
@@ -109,15 +110,33 @@ static void test_fetchctx(void)
 	 * container_of()->fc_mach */
 	C2_UT_ASSERT(ctx.fc__ast.sa_mach == NULL);
 
-	C2_UT_ASSERT(ctx->fc__fop.ff_origin.o_objkey.fb_len  == 0);
-	C2_UT_ASSERT(ctx->fc__fop.ff_origin.o_objkey.fb_data == NULL);
-	C2_UT_ASSERT(ctx->fc__fop.ff_comps.c_nr   == 0);
-	C2_UT_ASSERT(ctx->fc__fop.ff_comps.c_data == NULL);
+	C2_UT_ASSERT(ctx->fc__fop.f_data.fd_data == NULL);
+}
+
+static void test_path_status(void)
+{
+	c2_mutex_lock(&confc_cache.cc_sm_group->s_lock);
+	/* XXX
+	 * Call path_status(ctx, &status) with different paths
+	 * (ctx->fc__path) and ensure that:
+	 * - if all of the needed objects are cached:
+	 *   - if c2_conf_path_is_directory(ctx->fc__path):
+	 *      - ctx->fc_result points to a c2_confc_dir with
+	 *        ->d_parent of proper identity (type and key), null
+	 *        ->d_current, and proper ->d_descr;
+	 *   - else:
+	 *      - ctx->fc_result points to a concrete (not generic)
+	 *        configuration object with proper identity and
+	 *        configuration values.
+	 * - elsif ...XXX
+	 */
+	C2_UT_FAIL("XXX not implemented");
+	c2_mutex_unlock(&confc_cache.cc_sm_group->s_lock);
 }
 
 static void test_open(void)
 {
-	/*
+	/* XXX
 	 * - Initiate a c2_confc_fetchctx object --- ctx.
 	 *
 	 * - `path1' ends with a one-to-many downlink.
@@ -130,6 +149,7 @@ static void test_open(void)
 	 *   - Assert g_grp.s_forkq != NULL. (NB a race condition)
 	 *   - Assert ctx->fc__path is equal to path2.
 	 */
+	C2_UT_FAIL("XXX not implemented");
 }
 
 const struct c2_test_suite confc_ut = {
@@ -137,9 +157,10 @@ const struct c2_test_suite confc_ut = {
 	.ts_init  = init,
 	.fs_fini  = fini,
 	.ts_tests = {
-		{ "init/fini", test_init_fini },
-		{ "fetchctx",  test_fetchctx },
-		{ "open",      test_open },
+		{ "init/fini",   test_init_fini },
+		{ "fetchctx",    test_fetchctx },
+		{ "path_status", test_path_status },
+		{ "open",        test_open },
 		{ NULL, NULL }
 	}
 };
diff --git a/conf/ut/path.c b/conf/ut/path.c
index a89b4b0..1ef53ca 100644
--- a/conf/ut/path.c
+++ b/conf/ut/path.c
@@ -28,10 +28,58 @@ static void test_path_invariant(void)
 	C2_UT_FAIL("XXX not implemented");
 }
 
+static void test_path_is_dir(void)
+{
+	size_t i;
+	struct c2_conf_path path;
+	struct c2_conf_obj  prof = { .co_type = C2_CO_PROFILE };
+	struct c2_conf_obj  fs   = { .co_type = C2_CO_FILESYSTEM };
+	struct c2_conf_obj  node = { .co_type = C2_CO_NODE };
+#define DUMMY_KEY  { .cb_len = 0, .cb_data = NULL }
+	struct c2_conf_pathcomp comps[]    = {
+		/*0*/ { .pc_iskey = false, .pc_u.relation = C2_CO_FILESYSTEM },
+		/*1*/ { .pc_iskey = false, .pc_u.relation = C2_CO_SERVICE },
+		/*2*/ { .pc_iskey = true,  .pc_u.key = DUMMY_KEY },
+		/*3*/ { .pc_iskey = false, .pc_u.relation = C2_CO_NODE },
+		/*4*/ { .pc_iskey = false, .pc_u.relation = C2_CO_SDEV },
+		/*5*/ { .pc_iskey = true,  .pc_u.key = DUMMY_KEY },
+		/*6*/ { .pc_iskey = false, .pc_u.relation = C2_CO_PARTITION },
+		/*7*/ { .pc_iskey = true,  .pc_u.key = DUMMY_KEY }
+	};
+#undef DUMMY_KEY
+	const struct {
+		struct c2_conf_obj *path_origin;
+		size_t              comps_offset;
+		size_t              path_len;
+		bool                expected;
+	} tests[] = {
+		{ &prof, 0, 0, false }, /* [] */
+		{ NULL,  0, 0, false }, /* [] */
+		{ NULL,  0, 1, false }, /* [FILESYSTEM] */
+		{ &fs,   1, 1, true },  /* [SERVICE] */
+		{ &fs,   1, 2, false }, /* [SERVICE, "svc_0"] */
+		{ NULL,  0, 2, true },  /* [FILESYSTEM, SERVICE] */
+		{ &prof, 0, 3, false }, /* [FILESYSTEM, SERVICE, "svc_0"] */
+		{ &fs,   1, 3, false }, /* [SERVICE, "svc_0", NODE] */
+		{ &node, 4, 3, true },  /* [SDEV, "sd_1", PARTITION] */
+		{ &node, 4, 4, false }, /* [SDEV, "sd_1", PARTITION, "part"] */
+	};
+
+	for (i = 0; i < ARRAY_SIZE(tests); ++i) {
+		C2_ASSERT(tests[i].comps_offset + tests[i].path_len
+			  <= ARRAY_SIZE(comps));
+		path.p_origin = tests[i].path_origin;
+		path.p_len    = tests[i].path_len;
+		path.p_comps  = comps + tests[i].comps_offset;
+		C2_UT_ASSERT(c2_conf_path_is_dir(path) == tests[i].expected);
+	}
+}
+
 const struct c2_test_suite conf_path = {
 	.ts_name  = "conf-path",
 	.ts_tests = {
-		{ "path-invariant", test_path_invariant },
+		{ "path_invariant", test_path_invariant },
+		{ "path_is_dir",    test_path_is_dir },
 		{ NULL, NULL }
 	}
 };
-- 
1.8.3.2

