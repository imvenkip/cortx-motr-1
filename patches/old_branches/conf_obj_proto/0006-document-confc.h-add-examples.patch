From d649ca136b7c2e948e3919b9b7b983f66d643df8 Mon Sep 17 00:00:00 2001
From: "Valery V. Vorotyntsev" <valery_vorotyntsev@xyratex.com>
Date: Tue, 14 Feb 2012 23:46:31 +0200
Subject: [PATCH 006/370] document confc.h, add examples

+ path.h: C2_CONF_PATHCOMP_R, C2_CONF_PATHCOMP_K helper macros.
+ c2_confc_fetchctx::fc_complete: new member, a channel for
  "fetching done" events.
---
 conf/confc.c    |  29 ++++++---
 conf/confc.h    | 192 ++++++++++++++++++++++++++++++++++++++++++++++++++++----
 conf/path.h     |   3 +
 conf/ut/confc.c |  20 +++---
 conf/ut/path.c  |  16 ++---
 5 files changed, 219 insertions(+), 41 deletions(-)

diff --git a/conf/confc.c b/conf/confc.c
index aba4870..baa3357 100644
--- a/conf/confc.c
+++ b/conf/confc.c
@@ -40,7 +40,7 @@ static void state_set(struct c2_sm_group *grp __attribute__((unused)),
 {
 	struct c2_confc_fetchctx *ctx =
 		container_of(ast, struct c2_conf_fetchctx, fc__ast);
-	c2_sm_state_set(&ctx->fc_mach, (enum confc_state)ast->sa_datum);
+	c2_sm_state_set(&ctx->fc__mach, (enum confc_state)ast->sa_datum);
 }
 
 /** Actions to perform on "object unpinned" event. */
@@ -56,6 +56,7 @@ static bool unpinned_cb(struct c2_clink *link)
 
 void c2_confc_fetchctx_init(struct c2_confc_fetchctx *ctx)
 {
+	c2_chan_init(&ctx->fc_complete);
 	c2_clink_init(&ctx->fc__clink, unpinned_cb);
 }
 C2_EXPORTED(c2_confc_fetchctx_init);
@@ -63,6 +64,7 @@ C2_EXPORTED(c2_confc_fetchctx_init);
 void c2_confc_fetchctx_fini(struct c2_confc_fetchctx *ctx)
 {
 	c2_clink_fini(&ctx->fc__clink);
+	c2_chan_fini(&ctx->fc_complete);
 }
 C2_EXPORTED(c2_confc_fetchctx_fini);
 
@@ -184,7 +186,7 @@ static void check_st_in(struct c2_sm *mach)
 	enum c2_conf_status status;
 	int rc;
 	struct c2_confc_fetchctx *ctx =
-		container_of(mach, struct c2_confc_fetchctx, fc_mach);
+		container_of(mach, struct c2_confc_fetchctx, fc__mach);
 
 	C2_PRE(c2_mutex_is_locked(&confc_cache.cc_sm_group->s_lock));
 
@@ -208,7 +210,7 @@ static void wait_reply_st_in(struct c2_sm *mach)
 {
 	int rc;
 	struct c2_confc_fetchctx *ctx =
-		container_of(mach, struct c2_confc_fetchctx, fc_mach);
+		container_of(mach, struct c2_confc_fetchctx, fc__mach);
 	const struct c2_confop_fetch *fop_data = ctx->fc__fop.f_data.fd_data;
 	/* XXX This fd_data field must be set somehow. */
 
@@ -219,18 +221,25 @@ static void wait_reply_st_in(struct c2_sm *mach)
 	C2_ASSERT(rc == 0); /* c2_rpc_post() always returns 0, but hey */
 }
 
+static void complete(struct c2_sm *mach)
+{
+	struct c2_confc_fetchctx *ctx =
+		container_of(mach, struct c2_confc_fetchctx, fc__mach);
+	c2_chan_broadcast(&ctx->fc_complete);
+}
+
 static bool failure_st_invariant(const struct c2_sm *mach)
 {
 	const struct c2_confc_fetchctx *ctx =
-		container_of(mach, const struct c2_confc_fetchctx, fc_mach);
-	return ctx->fc_result == NULL && ctx->fc_mach.sm_rc < 0;
+		container_of(mach, const struct c2_confc_fetchctx, fc__mach);
+	return ctx->fc_result == NULL && ctx->fc__mach.sm_rc < 0;
 }
 
 static bool terminal_st_invariant(const struct c2_sm *mach)
 {
 	const struct c2_confc_fetchctx *ctx =
-		container_of(mach, const struct c2_confc_fetchctx, fc_mach);
-	return ctx->fc_result != NULL && ctx->fc_mach.sm_rc == 0;
+		container_of(mach, const struct c2_confc_fetchctx, fc__mach);
+	return ctx->fc_result != NULL && ctx->fc__mach.sm_rc == 0;
 }
 
 static const struct c2_sm_state_descr confc_states[S_NR] = {
@@ -278,7 +287,7 @@ static const struct c2_sm_state_descr confc_states[S_NR] = {
 	[S_FAILURE] = {
 		.sd_flags     = C2_SDF_FAILURE,
 		.sd_name      = "FAILURE",
-		.sd_in        = NULL,
+		.sd_in        = complete,
 		.sd_ex        = NULL,
 		.sd_invariant = failure_st_invariant,
 		.sd_allowed   = 0
@@ -286,7 +295,7 @@ static const struct c2_sm_state_descr confc_states[S_NR] = {
 	[S_TERMINAL] = {
 		.sd_flags     = C2_SDF_TERMINAL,
 		.sd_name      = "TERMINAL",
-		.sd_in        = NULL,
+		.sd_in        = complete,
 		.sd_ex        = NULL,
 		.sd_invariant = terminal_st_invariant,
 		.sd_allowed   = 0
@@ -325,7 +334,7 @@ void * c2_confc_open_sync(const struct c2_conf_path *path)
 	c2_confc_fetchctx_init(&ctx);
 	rc = c2_confc_open(path, &ctx);
 	if (rc == 0) {
-		rc = c2_sm_timedwait(&ctx.fc_mach, S_TERMINAL | S_FAILURE,
+		rc = c2_sm_timedwait(&ctx.fc__mach, S_TERMINAL | S_FAILURE,
 				     C2_TIME_NEVER);
 		C2_ASSERT(rc == 0);
 		ret = ctx.fc_result;
diff --git a/conf/confc.h b/conf/confc.h
index 04a2b2d..a457c98 100644
--- a/conf/confc.h
+++ b/conf/confc.h
@@ -23,6 +23,129 @@
 #include "sm/sm.h"    /* c2_sm, c2_sm_ast */
 #include "lib/chan.h" /* c2_clink */
 
+/**
+ * @page conf-confc  confc: configuration client
+ *
+ * Configuration client library (confc) provides user-space and kernel
+ * interfaces for accessing Colibri configuration information.
+ *
+ * Confc obtains configuration data from network-accessible
+ * configuration server (confd) and caches this data in memory.
+ *
+ * @section conf-confc-setup Initialization and termination
+ *
+ * Prior to accessing configuration, the application (aka
+ * configuration consumer) should initialize configuration client by
+ * calling c2_confc_init(). The application should also take care to
+ * terminate initialized confc with c2_confc_fini() call.
+ *
+ * A confc instance is associated with a state machine group
+ * (c2_sm_group). A user managing this group is responsible for making
+ * sure c2_sm_asts_run() is called when the group's channel is
+ * signalled. "AST" section of @ref sm has more details on this topic.
+ *
+ * @code
+ * #include "conf/confc.h"
+ *
+ * struct c2_sm_group *group = ...;
+ *
+ * startup(...) {
+ * 	rc = c2_confc_init("profile-name", "confd-endpoint", group);
+ * 	...
+ * }
+ *
+ * ... Access configuration objects using confc interfaces. ...
+ *
+ * shutdown(...) {
+ * 	c2_confc_fini();
+ * }
+ * @endcode
+ *
+ * @section conf-confc-opening Accessing configuration objects
+ *
+ * The application gets access to configuration data by "opening"
+ * configuration objects. c2_confc_open() is used to obtain a pointer
+ * to configuration object. c2_confc_diropen() is used to obtain a
+ * pointer to a collection of configuration objects, aka @em directory.
+ * Both functions have synchronous counterparts ---
+ * c2_confc_open_sync() and c2_confc_diropen_sync().
+ *
+ * The application uses c2_confc_dirnext() to iterate over the objects
+ * of a directory.
+ *
+ * Opened configuration objects and directories should be closed
+ * eventually. c2_confc_close() and c2_confc_dirclose() are used for
+ * this purpose.
+ *
+ * A configuration object is said to be @em pinned if its reference
+ * counter is nonzero, otherwise it is @em unpinned. Pinned objects
+ * are guaranteed not to be deleted by confc.
+ *
+ * c2_confc_*open*() and c2_confc_dirnext() functions pin the objects
+ * before providing them to configuration consumer. c2_confc_*close()
+ * "remove one pin" from a configuration object.
+ *
+ * @note The application should not follow relations of a
+ *       configuration object. Relations may point to unpinned objects
+ *       and it is bad idea to read configuration from an object that
+ *       may be deleted at any moment.
+ *
+ * Some examples follow.
+ *
+ * @code
+ * #include "conf/confc.h"
+ *
+ * struct c2_conf_filesystem; // defined in "conf/conf.h"
+ *
+ * static struct c2_conf_filesystem * filesystem_open_a(int32_t *errno)
+ * {
+ * 	struct c2_confc_fetchctx   ctx;
+ * 	struct c2_clink            clink;
+ * 	struct c2_conf_filesystem *ret = NULL;
+ * 	struct c2_conf_pathcomp    comps[] =
+ * 		{ C2_CONF_PATHCOMP_R(C2_CO_FILESYSTEM) };
+ * 	struct c2_conf_path        path = {
+ * 		.p_origin = NULL,
+ * 		.p_len    = ARRAY_SIZE(comps),
+ * 		.p_comps  = comps
+ * 	};
+ *
+ * 	c2_confc_fetchctx_init(&ctx);
+ * 	c2_clink_init(&clink, NULL)
+ * 	c2_clink_add(&ctx.fc_complete, &clink);
+ *
+ * 	rc = c2_confc_open_sync(&path, &ctx);
+ * 	if (rc != 0) {
+ * 		if (errno != NULL)
+ * 			*errno = -rc;
+ * 		goto end;
+ * 	}
+ *
+ * 	c2_chan_wait(&clink);
+ * 	ret = ctx.fc_result;
+ * 	if (ret == NULL && errno != NULL)
+ * 		*errno = c2_confc_error(ctx);
+ * end:
+ * 	c2_clink_del(&clink);
+ * 	c2_clink_fini(&clink);
+ * 	c2_confc_fetchctx_fini(&ctx);
+ * 	return ret;
+ * }
+ *
+ * static struct c2_conf_filesystem * filesystem_open_s(void)
+ * {
+ * 	struct c2_conf_pathcomp comps[] =
+ * 		{ C2_CONF_PATHCOMP_R(C2_CO_FILESYSTEM) };
+ * 	struct c2_conf_path path = {
+ * 		.p_origin = NULL,
+ * 		.p_len    = ARRAY_SIZE(comps),
+ * 		.p_comps  = comps
+ * 	};
+ * 	return c2_confc_open_sync(&path);
+ * }
+ * @endcode
+ */
+
 struct c2_conf_path;
 struct c2_confc_dir;
 
@@ -30,9 +153,11 @@ struct c2_confc_dir;
  * Initiates configuration client.
  *
  * @param profile     Name of profile used by this confc.
- * @param confd_addr  Configuration server end point address.
- * @param sm_group    State machine group that will be associated with
+ * @param confd_addr  Configuration server's end point address.
+ * @param sm_group    State machine group to be associated with confc
  *                    configuration cache.
+ *
+ * @pre  sm_group != NULL
  */
 int c2_confc_init(const char *profile, const char *confd_addr,
 		  struct c2_sm_group *sm_group);
@@ -45,21 +170,44 @@ int c2_confc_init(const char *profile, const char *confd_addr,
  */
 void c2_confc_fini(void);
 
+/** Configuration retrieval context. */
 struct c2_confc_fetchctx {
-	struct c2_sm fc_mach;
-	void        *fc_result;
+	/** This channel is signaled when the retrieval operation completes. */
+	struct c2_chan fc_complete;
+
+	/**
+	 * Pointer to the requested configuration object or directory.
+	 *
+	 * To be casted to
+	 * - <tt>struct X *</tt>, where X is a _concrete_ configuration
+	 *   object type (c2_conf_profile, c2_conf_filesystem, etc.),
+	 *   if the field is filled by c2_confc_open() call;
+	 * - <tt>struct c2_confc_dir *</tt> when filled by
+	 *   c2_confc_diropen().
+	 *
+	 * The value is NULL until fc_complete channel is signaled.
+	 * It is also NULL if configuration retrieval failed (see
+	 * c2_confc_error()).
+	 */
+	void          *fc_result;
 
 	/* -------------------------------------------------------------
-	 * The remaining fields (fc__*) are not supposed to be
-	 * accessed by configuration consumers.
+	 * The remaining fields (fc__*) are used by confc implementation.
+	 * They are not supposed to be accessed by configuration consumers.
 	 */
 
-	/* Path to the requested object or directory (directory is a
-	 * collection of objects). */
+	/** A confc state machine. */
+	struct c2_sm               fc__mach;
+
+	struct c2_sm_ast           fc__ast;
+
+	/**
+	 * Path to the requested object or directory (directory is a
+	 * collection of objects).
+	 */
 	const struct c2_conf_path *fc__path;
 
 	struct c2_fop              fc__fop;
-	struct c2_sm_ast           fc__ast;
 
 	/**
 	 * Record of interest in "object unpinned" events.
@@ -75,13 +223,13 @@ void c2_confc_fetchctx_fini(struct c2_confc_fetchctx *ctx);
 /** Returns the error status for the asynchronous configuration request. */
 static inline int32_t c2_confc_error(const struct c2_confc_fetchctx *ctx)
 {
-	C2_PRE(ctx->fc_mach.sm_rc <= 0);
-	return -ctx->fc_mach.sm_rc;
+	C2_PRE(ctx->fc__mach.sm_rc <= 0);
+	return -ctx->fc__mach.sm_rc;
 }
 
 /*
  * A caller must guarantee existence and immutability of `path' until
- * ctx->fc_mach terminates or fails.
+ * ctx->fc__mach terminates or fails.
  *
  * @pre  c2_conf_path_invariant(path)
  * @pre  ctx is initiated: its state machine is in INITIAL state,
@@ -98,11 +246,29 @@ int c2_confc_open(const struct c2_conf_path *path,
  */
 void * c2_confc_open_sync(const struct c2_conf_path *path);
 
+/* XXX[future]
+ * If statistics shows that synchronous variant is used more often, we
+ * may want to rename the functions: use c2_confc_open_async() for
+ * non-blocking function and c2_confc_open() for synchronous one.
+ */
+
+/**
+ * Closes configuration object opened with c2_confc_open() or
+ * c2_confc_open_sync().
+ *
+ * @param obj  The value returned by c2_confc_open_sync() or, in case
+ *             of c2_confc_open(), the value taken from
+ *             c2_confc_fetchctx::fc_result.
+ *
+ * @note  c2_confc_close(NULL) is a noop.
+ *
+ * @pre  ergo(obj != NULL, ((struct c2_conf_obj *)obj)->co_nrefs > 0)
+ */
 void c2_confc_close(void *obj);
 
 /*
  * A caller must guarantee existence and immutability of `path' until
- * ctx->fc_mach terminates or fails.
+ * ctx->fc__mach terminates or fails.
  *
  * @pre  `path' is not empty and its last component is a relation (not a key)
  */
diff --git a/conf/path.h b/conf/path.h
index b19bdd0..7457aba 100644
--- a/conf/path.h
+++ b/conf/path.h
@@ -30,6 +30,9 @@ struct c2_conf_pathcomp {
 	} pc_u;
 };
 
+#define C2_CONF_PATHCOMP_R(r)  { .pc_iskey = false, .pc_u.relation = (r) }
+#define C2_CONF_PATHCOMP_K(k)  { .pc_iskey = true, .pc_u.key = k }
+
 struct c2_conf_path {
 	struct c2_conf_obj      *p_origin;
 	size_t                   p_len;
diff --git a/conf/ut/confc.c b/conf/ut/confc.c
index 0b0c77c..8dafaef 100644
--- a/conf/ut/confc.c
+++ b/conf/ut/confc.c
@@ -95,19 +95,19 @@ static void test_fetchctx(void)
 	struct c2_confc_fetchctx ctx;
 
 	c2_confc_fetchctx_init(&ctx);
-	C2_UT_ASSERT(ctx.fc_mach.sm_grp   == &g_grp);
-	C2_UT_ASSERT(ctx.fc_mach.sm_state == S_INITIAL);
 
-	C2_UT_ASSERT(c2_confc_error(&ctx) == 0);
-	C2_UT_ASSERT(ctx.fc_result == NULL);
-	C2_UT_ASSERT(ctx.fc__path  == NULL);
-
-	C2_UT_ASSERT(ctx.fc__ast.sa_cb    == NULL);
-	C2_UT_ASSERT(ctx.fc__ast.sa_datum == NULL);
-	C2_UT_ASSERT(ctx.fc__ast.sa_next  == NULL);
+	C2_UT_ASSERT(ctx.fc_result         == NULL);
+	C2_UT_ASSERT(ctx.fc__mach.sm_grp   == &g_grp);
+	C2_UT_ASSERT(ctx.fc__mach.sm_state == S_INITIAL);
+	C2_UT_ASSERT(c2_confc_error(&ctx)  == 0);
+	C2_UT_ASSERT(ctx.fc__path          == NULL);
+	C2_UT_ASSERT(ctx.fc__ast.sa_cb     == NULL);
+	C2_UT_ASSERT(ctx.fc__ast.sa_datum  == NULL);
+	C2_UT_ASSERT(ctx.fc__ast.sa_next   == NULL);
+	/* XXX ctx.fc_complete is not tested. Should it be? */
 
 	/* c2_sm_ast::sa_mach is not used; c2_sm is accessed via
-	 * container_of()->fc_mach */
+	 * container_of()->fc__mach */
 	C2_UT_ASSERT(ctx.fc__ast.sa_mach == NULL);
 
 	C2_UT_ASSERT(ctx->fc__fop.f_data.fd_data == NULL);
diff --git a/conf/ut/path.c b/conf/ut/path.c
index 1ef53ca..b3c68e4 100644
--- a/conf/ut/path.c
+++ b/conf/ut/path.c
@@ -37,14 +37,14 @@ static void test_path_is_dir(void)
 	struct c2_conf_obj  node = { .co_type = C2_CO_NODE };
 #define DUMMY_KEY  { .cb_len = 0, .cb_data = NULL }
 	struct c2_conf_pathcomp comps[]    = {
-		/*0*/ { .pc_iskey = false, .pc_u.relation = C2_CO_FILESYSTEM },
-		/*1*/ { .pc_iskey = false, .pc_u.relation = C2_CO_SERVICE },
-		/*2*/ { .pc_iskey = true,  .pc_u.key = DUMMY_KEY },
-		/*3*/ { .pc_iskey = false, .pc_u.relation = C2_CO_NODE },
-		/*4*/ { .pc_iskey = false, .pc_u.relation = C2_CO_SDEV },
-		/*5*/ { .pc_iskey = true,  .pc_u.key = DUMMY_KEY },
-		/*6*/ { .pc_iskey = false, .pc_u.relation = C2_CO_PARTITION },
-		/*7*/ { .pc_iskey = true,  .pc_u.key = DUMMY_KEY }
+		/*0*/ C2_CONF_PATHCOMP_R(C2_CO_FILESYSTEM),
+		/*1*/ C2_CONF_PATHCOMP_R(C2_CO_SERVICE),
+		/*2*/ C2_CONF_PATHCOMP_K(DUMMY_KEY),
+		/*3*/ C2_CONF_PATHCOMP_R(C2_CO_NODE),
+		/*4*/ C2_CONF_PATHCOMP_R(C2_CO_SDEV),
+		/*5*/ C2_CONF_PATHCOMP_K(DUMMY_KEY),
+		/*6*/ C2_CONF_PATHCOMP_R(C2_CO_PARTITION),
+		/*7*/ C2_CONF_PATHCOMP_K(DUMMY_KEY)
 	};
 #undef DUMMY_KEY
 	const struct {
-- 
1.8.3.2

