From f81e5627ae147747eebe0d5859420a39302a2fd3 Mon Sep 17 00:00:00 2001
From: "Valery V. Vorotyntsev" <valery_vorotyntsev@xyratex.com>
Date: Wed, 15 Aug 2012 15:09:24 +0300
Subject: [PATCH 316/370] conf/obj_ops.c: implement *_invariant() functions

Replace generic_obj_invariant() with generic_obj_check_as():
the latter allows to specify expected value of ->co_type.
---
 conf/obj_ops.c | 222 ++++++++++++++++++++++++++++++++++++++++++++++-----------
 1 file changed, 179 insertions(+), 43 deletions(-)

diff --git a/conf/obj_ops.c b/conf/obj_ops.c
index 3b5eaa3..460770c 100644
--- a/conf/obj_ops.c
+++ b/conf/obj_ops.c
@@ -50,19 +50,13 @@ enum {
 	CONF_PARTITION_MAGIC  = 0x33bacca15a100f77
 };
 
-static bool dir_invariant(const void *bob);
-static bool profile_invariant(const void *bob);
-static bool filesystem_invariant(const void *bob);
-static bool service_invariant(const void *bob);
-static bool node_invariant(const void *bob);
-static bool nic_invariant(const void *bob);
-static bool sdev_invariant(const void *bob);
-static bool partition_invariant(const void *bob);
-
+static bool obj_is_stub(const struct c2_conf_obj *obj)
 static bool buf_is_valid(const struct c2_conf_buf *buf);
 static const struct c2_tl_descr *list_of(enum c2_conf_objtype *t);
 
 #define _BOB_DEFINE(abbrev, magix)                                           \
+static bool abbrev ## _invariant(const void *bob);                           \
+                                                                             \
 const struct c2_bob_type c2_conf_ ## abbrev ## _bob = {                      \
 	.bt_name = "c2_conf_" #abbrev,                                       \
 	.bt_magix_offset =                                                   \
@@ -119,65 +113,202 @@ static const struct obj_type *obj_type(enum c2_conf_objtype type)
 	return &_obj_types[type];
 }
 
-static bool generic_obj_invariant(const struct c2_conf_obj *obj)
+static bool
+generic_obj_check_as(const struct c2_conf_obj *obj, enum c2_conf_objtype type)
 {
-	const struct obj_type *ot = obj_type(obj->co_type);
+	const struct obj_type *ot = obj_type(type);
 
-	return obj->co_magix == ot->ot_bob->bt_magix &&
+	return obj->co_type == type && obj->co_magix == ot->ot_bob->bt_magix &&
 		buf_is_valid(&obj->co_id) &&
 		C2_IN(obj->co_status,
 		      (C2_CS_MISSING, C2_CS_LOADING, C2_CS_READY)) &&
 		obj->co_ops == &ot->ot_ops;
 }
 
-/**
- * c2_bob_check()s concrete (ambient) object given pointer to generic
- * (embedded) object.
- */
-static bool concrete_obj_invariant(const struct c2_conf_obj *obj)
+bool c2_conf_obj_invariant(const struct c2_conf_obj *obj)
 {
 	const struct obj_type *ot = obj_type(obj->co_type);
 
-	return c2_bob_check(ot->ot_bob, (const char *)obj - ot->ot_obj_offset);
-}
-
-bool c2_conf_obj_invariant(const struct c2_conf_obj *obj)
-{
-	return generic_obj_invariant(obj) && concrete_obj_invariant(obj);
+	return generic_obj_check_as(obj, obj->co_type) &&
+		c2_bob_check(ot->ot_bob, (const char *)obj - ot->ot_obj_offset);
 }
+
+/* ------------------------------------------------------------------
+ * Concrete invariants
+ * ------------------------------------------------------------------ */
 
 static bool dir_invariant(const void *bob)
 {
 	struct c2_conf_obj       *child;
 	const struct c2_conf_dir *self = bob;
-	const struct c2_conf_obj *parent = self->cd_obj.co_parent;
-	const struct c2_tl_descr *td = self->cd_obj.co_status == C2_CS_READY ?
-		list_of(self->cd_item_type) : NULL;
-
-	return parent != NULL && generic_obj_invariant(parent) &&
-		parent->co_status == C2_CS_READY &&
-		ergo(self->cd_obj.co_status == C2_CS_READY, td != NULL &&
+	const struct c2_conf_obj *self_obj = &self->cd_obj;
+	const struct c2_conf_obj *parent = self_obj->co_parent;
+	const struct c2_tl_descr *td = obj_is_stub(self_obj) ? NULL :
+		list_of(self->cd_item_type);
+
+	C2_PRE(self_obj->co_type == C2_CONF_DIR);
+
+	return /* Parent is valid configuration object. */
+		parent != NULL &&
+		generic_obj_check_as(parent, parent->co_type) &&
+		/* List's magic is unset iff `self' is a stub.*/
+		obj_is_stub(self_obj) == (self->cd_items.t_magic == 0) &&
+		/* Children are valid objects of proper type and point
+		 * to `self' via ->co_parent field. */
+		ergo(!obj_is_stub(self_obj), td != NULL &&
 		     c2_tlist_forall(td, child, &self->cd_items,
-				     child->co_type == self->cd_item_type));
+				     generic_obj_check_as(child,
+							  self->cd_item_type) &&
+				     child->co_parent == self_obj));
 }
 
+static bool child_is_ok(const struct c2_conf_obj *obj,
+			const struct c2_conf_obj *child,
+			enum c2_con_objtype child_type)
+{
+	return /* Child is NULL iff `obj' is a stub. */
+		obj_is_stub(obj) == (child == NULL) &&
+		/* Child is valid object of given type, and `obj' is
+		 * its parent. */
+		ergo(!obj_is_stub(obj),
+		     generic_obj_check_as(child, child_type) &&
+		     child->co_parent == obj);
+}
+
+#define ACCESS(ptr, member)                   \
+({                                            \
+	typeof(ptr) __ptr = (ptr);            \
+	__ptr == NULL ? NULL : __ptr->member; \
+})
+
 static bool profile_invariant(const void *bob)
 {
 	const struct c2_conf_profile *self = bob;
-	const struct c2_conf_obj     *child = prof->cp_filesystem == NULL ?
-		NULL : &prof->cp_filesystem->cf_obj;
+	const struct c2_conf_obj     *self_obj = &self->cp_obj;
+
+	C2_PRE(self_obj->co_type == C2_CONF_PROFILE);
 
-	return self->cp_obj.co_parent == NULL /* topmost object */ &&
-		(child != NULL) == (self->cp_obj.co_status == C2_CS_READY) &&
-		ergo(child != NULL, generic_obj_invariant(child) &&
-		     child->co_parent == &self->cp_obj);
+	return /* c2_conf_profile is the topmost object in the DAG. */
+		self_obj->co_parent == NULL &&
+		child_is_ok(self_obj, ACCESS(self->cp_filesystem, cf_obj),
+			    C2_CONF_FILESYSTEM) &&
+		/* Other checks. */
+		ergo(self_obj->co_confc != NULL,
+		     self_obj->co_confc->cc_root == self_obj);
 }
 
-/* XXX
- *
- * {filesystem..partition}_invariant()
- */
-XXX;
+static bool filesystem_invariant(const void *bob)
+{
+	const struct c2_conf_filesystem *self = bob;
+	const struct c2_conf_obj        *self_obj = &self->cf_obj;
+	struct c2_conf_obj              *parent = self_obj->co_parent;
+
+	C2_PRE(self_obj->co_type == C2_CONF_FILESYSTEM);
+
+	return /* Parent is valid c2_conf_profile pointing to `self' via
+		* c2_conf_profile::cp_filesystem field. */
+		generic_obj_check_as(parent, C2_CONF_PROFILE) &&
+		C2_CONF_CAST(parent,
+			     c2_conf_profile)->cp_filesystem == self_obj &&
+		child_is_ok(self_obj, ACCESS(self->cf_services, cd_obj),
+			    C2_CONF_DIR) &&
+		/* Other checks. */
+		obj_is_stub(self_obj) == (self->cf_params == NULL);
+}
+
+static bool service_invariant(const void *bob)
+{
+	const struct c2_conf_service *self = bob;
+	const struct c2_conf_obj     *self_obj = &self->cs_obj;
+	struct c2_conf_obj           *parent = self_obj->co_parent;
+
+	C2_PRE(self_obj->co_type == C2_CONF_SERVICE);
+
+	return /* Parent is valid c2_conf_dir with proper
+		* ->cd_item_type. */
+		generic_obj_check_as(parent, C2_CONF_DIR) &&
+		C2_CONF_CAST(parent,
+			     c2_conf_dir)->cd_item_type == C2_CONF_SERVICE &&
+		child_is_ok(self_obj, ACCESS(self->cs_node, cn_obj),
+			    C2_CONF_NODE) &&
+		/* Other checks. */
+		ergo(!obj_is_stub(self_obj),
+		     C2_IN(self->cs_type, (C2_CFG_SERVICE_METADATA,
+					   C2_CFG_SERVICE_IO,
+					   C2_CFG_SERVICE_MGMT,
+					   C2_CFG_SERVICE_DLM))) &&
+		obj_is_stub(self_obj) == (self->cs_endpoints == NULL);
+}
+
+static bool node_invariant(const void *bob)
+{
+	const struct c2_conf_node *self = bob;
+	const struct c2_conf_obj  *self_obj = &self->cn_obj;
+
+	C2_PRE(self_obj->co_type == C2_CONF_NODE);
+
+	return /* The notion of parent is not applicable to a node,
+		* since a node may host (be child of) several
+		* services. */
+		self_obj->co_parent == NULL &&
+		child_is_ok(self_obj, ACCESS(self->cn_nics, cd_obj),
+			    C2_CONF_DIR) &&
+		child_is_ok(self_obj, ACCESS(self->cn_sdevs, cd_obj),
+			    C2_CONF_DIR);
+}
+
+static bool nic_invariant(const void *bob)
+{
+	const struct c2_conf_nic *self = bob;
+	const struct c2_conf_obj *self_obj = &self->ni_obj;
+	struct c2_conf_obj       *parent = self_obj->co_parent;
+
+	C2_PRE(self_obj->co_type == C2_CONF_NIC);
+
+	return /* Parent is valid c2_conf_dir with proper
+		* ->cd_item_type. */
+		generic_obj_check_as(parent, C2_CONF_DIR) &&
+		C2_CONF_CAST(parent,
+			     c2_conf_dir)->cd_item_type == C2_CONF_NIC &&
+		/* Other checks. */
+		obj_is_stub(self_obj) == (self->ni_filename == NULL);
+}
+
+static bool sdev_invariant(const void *bob)
+{
+	const struct c2_conf_sdev *self = bob;
+	const struct c2_conf_obj  *self_obj = &self->sd_obj;
+	struct c2_conf_obj        *parent = self_obj->co_parent;
+
+	C2_PRE(self_obj->co_type == C2_CONF_SDEV);
+
+	return /* Parent is valid c2_conf_dir with proper
+		* ->cd_item_type. */
+		generic_obj_check_as(parent, C2_CONF_DIR) &&
+		C2_CONF_CAST(parent,
+			     c2_conf_dir)->cd_item_type == C2_CONF_SDEV &&
+		child_is_ok(self_obj, ACCESS(self->sd_partitions, cd_obj),
+			    C2_CONF_DIR) &&
+		/* Other checks. */
+		obj_is_stub(self_obj) == (self->sd_filename == NULL);
+}
+
+static bool partition_invariant(const void *bob)
+{
+	const struct c2_conf_partition *self = bob;
+	const struct c2_conf_obj       *self_obj = &self->pa_obj;
+	struct c2_conf_obj             *parent = self_obj->co_parent;
+
+	C2_PRE(self_obj->co_type == C2_CONF_PARTITION);
+
+	return /* Parent is valid c2_conf_dir with proper
+		* ->cd_item_type. */
+		generic_obj_check_as(parent, C2_CONF_DIR) &&
+		C2_CONF_CAST(parent,
+			     c2_conf_dir)->cd_item_type == C2_CONF_PARTITION &&
+		/* Other checks. */
+		obj_is_stub(self_obj) == (self->pa_filename == NULL);
+}
 
 /* ------------------------------------------------------------------
  * c2_conf_{new,match,fill}()
@@ -205,7 +336,7 @@ static int generic_obj_init(struct c2_conf_obj *obj, enum c2_conf_objtype type,
 	/* TODO Assert that obj->co_linkage is zeroed. */
 	C2_ASSERT(obj->co_confc == NULL);
 
-	C2_POST(generic_obj_invariant(obj));
+	C2_POST(generic_obj_check_as(obj, type));
 	return 0;
 }
 
@@ -507,6 +638,11 @@ static bool readdir_post(int retval, const struct c2_conf_obj *dir,
 		 entry == NULL);
 }
 
+static bool obj_is_stub(const struct c2_conf_obj *obj)
+{
+	return obj->co_status != C2_CS_READY;
+}
+
 static bool buf_is_valid(const struct c2_conf_buf *buf)
 {
 	return buf->cb_size > 0 && buf->cb_data != NULL;
-- 
1.8.3.2

