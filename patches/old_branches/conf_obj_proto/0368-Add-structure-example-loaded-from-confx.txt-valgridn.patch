From 987fa9dd26c1452ca076580acaaaebe97c2efd36 Mon Sep 17 00:00:00 2001
From: Anatoliy Bilenko <anatoliy_bilenko@xyratex.com>
Date: Sun, 16 Sep 2012 13:08:13 +0300
Subject: [PATCH 368/370] Add structure example loaded from confx.txt;
 valgridned: not leaks!

---
 conf/Makefile.am    |   2 +-
 conf/knot.c         |  38 +--
 conf/knot.h         |  17 +-
 conf/link.c         |  66 -----
 conf/link.h         |  55 ----
 conf/reg2.c         |  49 ++++
 conf/reg2.h         |  28 +++
 conf/ut/Makefile.am |  12 +-
 conf/ut/knot.c      | 703 ++++++++++++++++++++++++++++++++++++++++++++++++++++
 conf/ut/linktest.c  | 109 --------
 conf/ut/oddlist.c   | 138 -----------
 11 files changed, 817 insertions(+), 400 deletions(-)
 delete mode 100644 conf/link.c
 delete mode 100644 conf/link.h
 create mode 100644 conf/reg2.c
 create mode 100644 conf/reg2.h
 create mode 100644 conf/ut/knot.c
 delete mode 100644 conf/ut/linktest.c
 delete mode 100644 conf/ut/oddlist.c

diff --git a/conf/Makefile.am b/conf/Makefile.am
index b8a9311..0931511 100644
--- a/conf/Makefile.am
+++ b/conf/Makefile.am
@@ -7,7 +7,7 @@ _OBJS_SRC = objs/common.h objs/common.c objs/dir.c objs/profile.c   \
 noinst_LTLIBRARIES = libcolibri-conf.la
 libcolibri_conf_la_SOURCES = obj.h obj.c reg.h reg.c obj_ops.h obj_ops.c \
                              onwire.h preload.h preload.c $(_OBJS_SRC) \
-                             link.h link.c knot.c knot.h
+                             knot.c knot.h reg2.c reg2.h
 
 INCLUDES = -iquote . -iquote $(top_srcdir) -iquote $(top_srcdir)/include \
            -iquote /usr/include
diff --git a/conf/knot.c b/conf/knot.c
index ae477f7..3a63fa8 100644
--- a/conf/knot.c
+++ b/conf/knot.c
@@ -17,9 +17,21 @@ void c2_knot_list_init(struct c2_knot_list *list)
 	c2_list_init(&list->ol_list);
 }
 
-void c2_knot_list_fini(struct c2_knot_list *list)
+void c2_knot_list_fini(struct c2_knot_list *li)
 {
-	c2_list_fini(&list->ol_list);
+	struct c2_knot_list_item *item;
+	struct c2_list_link      *pos;
+	struct c2_list           *list = &li->ol_list;
+
+	/* clear list */
+	while ((pos = c2_list_first(list)) != NULL) {
+		item = c2_list_entry(pos, struct c2_knot_list_item, oli_link);
+		c2_list_del(&item->oli_link);
+		c2_list_link_fini(&item->oli_link);
+		c2_free(item);
+	}
+
+	c2_list_fini(list);
 }
 
 int  c2_knot_list_add(struct c2_knot_list *list, struct c2_knot *data)
@@ -44,6 +56,9 @@ void c2_knot_list_del(struct c2_knot_list *li, struct c2_knot *data)
 	struct c2_list_link     *pos;
 	struct c2_list          *list = &li->ol_list;
 
+	/* @todo: the following is better:
+	   while ((pos = c2_list_first(list)) != NULL) { delete ... }
+	*/
 	c2_list_for_each(list, pos) {
 		item = c2_list_entry(pos, struct c2_knot_list_item, oli_link);
 		if (item->oli_data == data) {
@@ -86,21 +101,12 @@ struct c2_knot *c2_knot_list_entry(struct c2_knot_list *li, size_t n)
 
 int  c2_knot_link  (struct c2_knot *this, struct c2_knot *what)
 {
-	int rc;
-
-	rc = c2_knot_list_add(&this->k_children, what);
-	if (rc != 0)
-		return rc;
-
-	what->k_parent = this;
-
-	return 0;
+	return c2_knot_list_add(&this->k_children, what);
 }
 
 void c2_knot_unlink(struct c2_knot *this, struct c2_knot *what)
 {
 	c2_knot_list_del(&this->k_children, what);
-	what->k_parent = NULL;
 }
 
 struct c2_knot *c2_knot_child(struct c2_knot *this, size_t child)
@@ -108,14 +114,10 @@ struct c2_knot *c2_knot_child(struct c2_knot *this, size_t child)
 	return c2_knot_list_entry(&this->k_children, child);
 }
 
-struct c2_knot *c2_knot_parent(struct c2_knot *this)
-{
-	return this->k_parent;
-}
-
-void c2_knot_init(struct c2_knot *this)
+void c2_knot_init(struct c2_knot *this, struct c2_knot_whoami who)
 {
 	c2_knot_list_init(&this->k_children);
+	this->k_who = who;
 }
 
 void c2_knot_fini(struct c2_knot *this)
diff --git a/conf/knot.h b/conf/knot.h
index 84399ff..429b70e 100644
--- a/conf/knot.h
+++ b/conf/knot.h
@@ -3,6 +3,7 @@
 #define __COLIBRI_KNOT_H__
 
 #include "lib/list.h"
+#include "lib/buf.h"
 
 struct c2_knot_list {
 	struct c2_list ol_list;
@@ -11,25 +12,31 @@ struct c2_knot_list {
 /* ----------------------------------------------------------------------
 			      knot interfaces:
    ---------------------------------------------------------------------- */
+struct c2_knot;
+
+struct c2_knot_uuid {
+	struct c2_buf ku_id;
+	struct c2_buf ku_type;
+};
+
 struct c2_knot_whoami {
-	const char *name;
-	int	    id;
+	void (*kw_id)(struct c2_knot *knot, struct c2_knot_uuid *out);
+	int  (*kw_fk)(struct c2_knot *knot, struct c2_knot_uuid *out,
+		      c2_bcount_t seq_num);
 };
 
 struct c2_knot {
-	struct c2_knot       *k_parent;
 	struct c2_knot_list   k_children;
 	struct c2_knot_whoami k_who;
 };
 
-void c2_knot_init(struct c2_knot *this);
+void c2_knot_init(struct c2_knot *this, struct c2_knot_whoami who);
 void c2_knot_fini(struct c2_knot *this);
 
 int  c2_knot_link  (struct c2_knot *this, struct c2_knot *what);
 void c2_knot_unlink(struct c2_knot *this, struct c2_knot *what);
 
 struct c2_knot *c2_knot_child(struct c2_knot *this, size_t child);
-struct c2_knot *c2_knot_parent(struct c2_knot *this);
 
 /* ----------------------------------------------------------------------
 			    knot_list interfaces:
diff --git a/conf/link.c b/conf/link.c
deleted file mode 100644
index ada3a35..0000000
--- a/conf/link.c
+++ /dev/null
@@ -1,66 +0,0 @@
-#include "conf/link.h"
-#include <stdio.h>
-#include <string.h>
-
-void c2_conf_rel_init(struct c2_conf_rel *link)
-{
-	c2_list_link_init(&link->cr_link);
-	c2_list_init(&link->cr_child);
-	link->cr_parent = NULL;
-}
-
-void c2_conf_rel_fini(struct c2_conf_rel *link)
-{
-	link->cr_parent = NULL;
-	c2_list_fini(&link->cr_child);
-	c2_list_link_fini(&link->cr_link);
-}
-
-void c2_conf_rel_add(struct c2_conf_rel *to, struct c2_conf_rel *what)
-{
-	c2_list_add(&to->cr_child, &what->cr_link);
-	what->cr_parent = to;
-}
-
-void c2_conf_rel_del(struct c2_conf_rel *from, struct c2_conf_rel *what)
-{
-	C2_PRE(c2_list_contains(&from->cr_child, &what->cr_link));
-
-	c2_list_del(&what->cr_link);
-	what->cr_parent = NULL;
-}
-
-struct c2_conf_rel *rel_lookup(struct c2_conf_rel *from,
-				      const c2_conf_rel_identity *what)
-{
-	struct c2_list_link *pos;
-	struct c2_conf_rel  *ent;
-
-	c2_list_for_each(&from->cr_child, pos) {
-		ent = c2_list_entry(pos, struct c2_conf_rel, cr_link);
-		if (strcmp(ent->cr_who.cw_id, what) == 0)
-			return ent;
-	}
-
-	return 0;
-}
-
-struct c2_conf_rel *c2_conf_rel_walk(struct c2_conf_rel *from,
-				     const c2_conf_rel_identity **through)
-{
-	struct c2_conf_rel *current = from;
-	struct c2_conf_rel *next = NULL;
-
-	for (; through[0] != NULL && through[1] != NULL; through++) {
-		next = rel_lookup(current, through[1]);
-		if (next == NULL)
-			return NULL;
-
-		printf("%s -> %s\n", current->cr_who.cw_id,
-		       next->cr_who.cw_id);
-		current = next;
-	}
-
-	return current;
-}
-
diff --git a/conf/link.h b/conf/link.h
deleted file mode 100644
index f3c5965..0000000
--- a/conf/link.h
+++ /dev/null
@@ -1,55 +0,0 @@
-#pragma once
-#ifndef __COLIBRI_CONF_LINK_H__
-#define __COLIBRI_CONF_LINK_H__
-
-#include "lib/list.h"
-
-typedef const char  c2_conf_rel_identity;
-typedef int         c2_conf_rel_ambtype;
-
-struct c2_conf_whoami {
-	c2_conf_rel_identity *cw_id;
-	c2_conf_rel_ambtype   cw_type;
-};
-
-struct c2_conf_rel {
-	/* links related stuff */
-	struct c2_list_link  cr_link; /* link into c2_conf_rel::cl_child */
-	struct c2_list	     cr_child;
-	struct c2_conf_rel  *cr_parent;
-
-	/* data related stuff */
-	struct c2_conf_whoami cr_who;
-};
-
-void c2_conf_rel_init(struct c2_conf_rel *link);
-void c2_conf_rel_fini(struct c2_conf_rel *link);
-
-void c2_conf_rel_add(struct c2_conf_rel *to,   struct c2_conf_rel *what);
-void c2_conf_rel_del(struct c2_conf_rel *from, struct c2_conf_rel *what);
-
-struct c2_conf_rel *c2_conf_rel_walk(struct c2_conf_rel *from,
-				     const c2_conf_rel_identity **through);
-
-/*
-  struct c2_conf_rel compound = ...;
-  struct c2_conf_rel_iter it = c2_conf_rel_begin(&compound);
-  for (; it != c2_conf_rel_end(it); it = c2_conf_rel_next(it)) {
-	struct c2_conf_rel *iterated_value = it->ri_current;
-  }
-*/
-
-struct c2_conf_rel_iter {
-	struct c2_conf_rel *ri_compound;
-	struct c2_conf_rel *ri_current;
-};
-
-/* @pre  is_conf_rel_compound(compound) */
-/* @post is_conf_rel_iter_valid(ret) */
-struct c2_conf_rel_iter c2_conf_rel_begin(struct c2_conf_rel *compound);
-struct c2_conf_rel_iter c2_conf_rel_end(struct c2_conf_rel_iter iter);
-struct c2_conf_rel_iter c2_conf_rel_next(struct c2_conf_rel_iter iter);
-
-
-#endif  /* __COLIBRI_CONF_REL_H__ */
-
diff --git a/conf/reg2.c b/conf/reg2.c
new file mode 100644
index 0000000..13e0b30
--- /dev/null
+++ b/conf/reg2.c
@@ -0,0 +1,49 @@
+#include "conf/reg2.h"
+
+void c2_reg_init(struct c2_reg *reg, c2_reg_equal_t eq)
+{
+	c2_list_init(&reg->r_elems);
+	reg->r_equal = eq;
+}
+
+void c2_reg_fini(struct c2_reg *reg)
+{
+	c2_list_fini(&reg->r_elems);
+}
+
+void c2_reg_add(struct c2_reg *reg, struct c2_list_link *link)
+{
+	c2_list_add(&reg->r_elems, link);
+}
+
+void c2_reg_del(struct c2_reg *reg, struct c2_list_link *link)
+{
+	C2_PRE(c2_list_contains(&reg->r_elems, link));
+
+	c2_list_del(link);
+}
+
+struct c2_list_link *c2_reg_lookup(const struct c2_reg *reg,
+				   const struct c2_buf *value)
+{
+	struct c2_list_link  *pos;
+	const struct c2_list *list = &reg->r_elems;
+
+	c2_list_for_each(list, pos) {
+		if (reg->r_equal(pos, value))
+			return pos;
+	}
+
+	return NULL;
+}
+
+void c2_reg_iterate(const struct c2_reg *reg,
+		    void (*visit)(const struct c2_list_link *link))
+{
+	struct c2_list_link  *pos;
+	const struct c2_list *list = &reg->r_elems;
+
+	c2_list_for_each(list, pos) {
+		visit(pos);
+	}
+}
diff --git a/conf/reg2.h b/conf/reg2.h
new file mode 100644
index 0000000..e213167
--- /dev/null
+++ b/conf/reg2.h
@@ -0,0 +1,28 @@
+#pragma once
+#ifndef __COLIBRI_CONF_REG2_H__
+#define __COLIBRI_CONF_REG2_H__
+
+#include "lib/list.h"
+#include "lib/buf.h"
+
+typedef bool (*c2_reg_equal_t)(const struct c2_list_link *current,
+			       const struct c2_buf *value);
+
+struct c2_reg {
+	struct c2_list r_elems;
+	c2_reg_equal_t r_equal;
+};
+
+void c2_reg_init(struct c2_reg *reg, c2_reg_equal_t eq);
+void c2_reg_fini(struct c2_reg *reg);
+
+void c2_reg_add(struct c2_reg *reg, struct c2_list_link *link);
+void c2_reg_del(struct c2_reg *reg, struct c2_list_link *link);
+
+struct c2_list_link *c2_reg_lookup(const struct c2_reg *reg,
+				   const struct c2_buf *value);
+
+void c2_reg_iterate(const struct c2_reg *reg,
+		    void (*visit)(const struct c2_list_link *link));
+
+#endif /* __COLIBRI_CONF_REG2_H__ */
diff --git a/conf/ut/Makefile.am b/conf/ut/Makefile.am
index cfc6e07..c82f060 100644
--- a/conf/ut/Makefile.am
+++ b/conf/ut/Makefile.am
@@ -10,11 +10,7 @@ noinst_PROGRAMS = prepar
 prepar_SOURCES  = prepar.c
 prepar_LDADD    = $(top_builddir)/colibri/libcolibri.la
 
-# Preload parser (temporary target)
-noinst_PROGRAMS  = linktest
-linktest_SOURCES = linktest.c
-linktest_LDADD   = $(top_builddir)/colibri/libcolibri.la
-
-noinst_PROGRAMS  = oddlist
-oddlist_SOURCES = oddlist.c
-oddlist_LDADD   = $(top_builddir)/colibri/libcolibri.la
+# Prototype of new relations model
+noinst_PROGRAMS  = knot
+knot_SOURCES     = knot.c
+knot_LDADD       = $(top_builddir)/colibri/libcolibri.la
diff --git a/conf/ut/knot.c b/conf/ut/knot.c
new file mode 100644
index 0000000..c319c22
--- /dev/null
+++ b/conf/ut/knot.c
@@ -0,0 +1,703 @@
+#include "conf/knot.h"
+#include "conf/reg2.h"
+#include "conf/onwire.h"
+#include "conf/preload.h"
+#include "lib/thread.h" /* LAMBDA */
+#include "lib/errno.h"
+#include "lib/arith.h"
+#include <stdio.h>
+#include <string.h>
+
+
+/* ----------------------------------------------------------------------
+			      knot list test:
+   ---------------------------------------------------------------------- */
+void knot_test(void)
+{
+#if 0
+#define printf(a, ...)
+	struct c2_knot_list list;
+	struct c2_knot data[] = { { .k_who = {"",10} },
+				  { .k_who = {"",21} },
+				  { .k_who = {"",32} },
+				  { .k_who = {"",43} },
+				  { .k_who = {"",54} }};
+	int i;
+
+	c2_knot_list_init(&list);
+
+	for (i = 0; i < ARRAY_SIZE(data); ++i)
+		c2_knot_list_add(&list, &data[i]);
+
+
+	printf("len: %lu\n", c2_knot_list_length(&list));
+
+	for (i = 0; i < ARRAY_SIZE(data); ++i)
+		printf("[%d]: %d\n", i, c2_knot_list_entry(&list, i)->k_who.id);
+
+	printf("NULL: %p\n", c2_knot_list_entry(&list, 100));
+
+	for (i = 0; i < ARRAY_SIZE(data); ++i)
+		c2_knot_list_del(&list, &data[i]);
+
+
+	c2_knot_list_fini(&list);
+#undef printf
+#endif
+}
+
+
+/* ----------------------------------------------------------------------
+		      knot structure dumb iterator:
+   ---------------------------------------------------------------------- */
+static void knot_rec_dfs_iterate(struct c2_knot *root,
+			  void (*visit)(struct c2_knot *child,
+					struct c2_knot *parent))
+{
+	size_t i;
+	struct c2_knot *child;
+
+	for (i = 0; (child = c2_knot_child(root, i)) != NULL; i++) {
+		visit(child, root);
+		knot_rec_dfs_iterate(child, visit);
+	}
+}
+
+static void knot_visit(struct c2_knot *child, struct c2_knot *parent)
+{
+	struct c2_knot_uuid pid;
+	struct c2_knot_uuid cid;
+
+	parent->k_who.kw_id(parent, &pid);
+	child->k_who.kw_id(child, &cid);
+
+	printf("\t%s -> %s\n", (char*)pid.ku_id.b_addr,(char*)cid.ku_id.b_addr);
+}
+
+static void hw_digraph_create(struct c2_knot *root)
+{
+	printf("digraph stu {\n");
+	knot_rec_dfs_iterate(root, knot_visit);
+	printf("}\n");
+}
+#if 0
+static void obj_knot_visit(struct c2_knot *child, struct c2_knot *parent)
+{
+	struct c2_knot_uuid pid;
+	struct c2_knot_uuid cid;
+	char pb[256] = { 0 }; /* @todo: horrible! */
+	char cb[256] = { 0 }; /* @todo: horrible! */
+
+	parent->k_who.kw_id(parent, &pid);
+	child->k_who.kw_id(child, &cid);
+
+	memcpy(pb, pid.ku_id.b_addr, min64u(255ULL, pid.ku_id.b_nob));
+	memcpy(cb, cid.ku_id.b_addr, min64u(255ULL, cid.ku_id.b_nob));
+
+	printf("\t\"%s\" -> \"%s\"\n", pb, cb);
+}
+
+static void obj_digraph_create(struct c2_knot *root)
+{
+	printf("digraph obj {\n");
+	knot_rec_dfs_iterate(root, obj_knot_visit);
+	printf("}\n");
+}
+#endif
+
+
+/* ----------------------------------------------------------------------
+         knot structure data types, id and foregin key converters:
+   ---------------------------------------------------------------------- */
+enum hw_type {
+	BIOS, MEM, CPU, CACHE, REG, MB
+};
+
+struct hw_part {
+	struct c2_knot  knot;
+	const char     *name;
+	enum hw_type    type;
+};
+
+static void hw_id(struct c2_knot *knot, struct c2_knot_uuid *out)
+{
+	struct hw_part *part = (struct hw_part *)knot;
+	C2_CASSERT((void*)part == (void*)&part->knot);
+
+	c2_buf_init(&out->ku_id, (void*)part->name, strlen(part->name));
+	c2_buf_init(&out->ku_type, &part->type, sizeof(part->type));
+}
+
+static int  hw_fk(struct c2_knot *knot, struct c2_knot_uuid *out,
+		  c2_bcount_t seq_num)
+{
+	return 0;
+}
+
+static void hw_part_init(struct hw_part *part, const char *name,
+			 enum hw_type type)
+{
+	part->name = name;
+	part->type = type;
+
+	c2_knot_init(&part->knot, (struct c2_knot_whoami){ hw_id, hw_fk });
+}
+
+static void hw_part_fini(struct hw_part *part)
+{
+	c2_knot_fini(&part->knot);
+}
+
+#define KCAST(t) (struct c2_knot*)(t)
+
+/* ----------------------------------------------------------------------
+		      knot structure test:
+   ---------------------------------------------------------------------- */
+void knot_struct_test()
+{
+
+/*
+ *                      mb0
+ *                       |
+ *                 +-----+--------------+----------------------+
+ *                 |     |              |                      |
+ *               bios0  mem0          cpu0--------+-----------cpu1
+ *                                      |         |            |
+ *                                    +-+-+       |          +-+-+
+ *                                    |   |       |          |   |
+ *                                  reg0 reg1     |        reg2 reg3
+ *                                             +--+--+
+ *                                             |     |
+ *                                         cache0  cache1
+ */
+
+	struct hw_part r20;
+	struct hw_part r21;
+	struct hw_part r22;
+	struct hw_part r23;
+	struct hw_part r24;
+	struct hw_part r25;
+
+	struct hw_part r13;
+	struct hw_part r12;
+	struct hw_part r11;
+	struct hw_part r10;
+
+	struct hw_part r00;
+
+	int rc;
+
+	hw_part_init(&r20, "cache0", CACHE);
+	hw_part_init(&r21, "cache1", CACHE);
+	hw_part_init(&r22, "reg0"  , REG  );
+	hw_part_init(&r23, "reg1"  , REG  );
+	hw_part_init(&r24, "reg2"  , REG  );
+	hw_part_init(&r25, "reg3"  , REG  );
+
+	hw_part_init(&r13, "bios0" , BIOS );
+	hw_part_init(&r12, "mem0"  , MEM  );
+	hw_part_init(&r11, "cpu1"  , CPU  );
+	hw_part_init(&r10, "cpu0"  , CPU  );
+
+	hw_part_init(&r00, "mb0"   , MB   );
+
+
+	rc = c2_knot_link(KCAST(&r00), KCAST(&r10)); C2_ASSERT(rc == 0);
+	rc = c2_knot_link(KCAST(&r00), KCAST(&r11)); C2_ASSERT(rc == 0);
+	rc = c2_knot_link(KCAST(&r00), KCAST(&r12)); C2_ASSERT(rc == 0);
+	rc = c2_knot_link(KCAST(&r00), KCAST(&r13)); C2_ASSERT(rc == 0);
+
+	rc = c2_knot_link(KCAST(&r10), KCAST(&r20)); C2_ASSERT(rc == 0);
+	rc = c2_knot_link(KCAST(&r10), KCAST(&r21)); C2_ASSERT(rc == 0);
+	rc = c2_knot_link(KCAST(&r10), KCAST(&r22)); C2_ASSERT(rc == 0);
+	rc = c2_knot_link(KCAST(&r10), KCAST(&r23)); C2_ASSERT(rc == 0);
+
+	rc = c2_knot_link(KCAST(&r11), KCAST(&r20)); C2_ASSERT(rc == 0);
+	rc = c2_knot_link(KCAST(&r11), KCAST(&r21)); C2_ASSERT(rc == 0);
+	rc = c2_knot_link(KCAST(&r11), KCAST(&r24)); C2_ASSERT(rc == 0);
+	rc = c2_knot_link(KCAST(&r11), KCAST(&r25)); C2_ASSERT(rc == 0);
+
+
+	hw_digraph_create(KCAST(&r00));
+
+
+	c2_knot_unlink(KCAST(&r11), KCAST(&r20));
+	c2_knot_unlink(KCAST(&r11), KCAST(&r21));
+	c2_knot_unlink(KCAST(&r11), KCAST(&r24));
+	c2_knot_unlink(KCAST(&r11), KCAST(&r25));
+
+	c2_knot_unlink(KCAST(&r10), KCAST(&r20));
+	c2_knot_unlink(KCAST(&r10), KCAST(&r21));
+	c2_knot_unlink(KCAST(&r10), KCAST(&r22));
+	c2_knot_unlink(KCAST(&r10), KCAST(&r23));
+
+	c2_knot_unlink(KCAST(&r00), KCAST(&r10));
+	c2_knot_unlink(KCAST(&r00), KCAST(&r11));
+	c2_knot_unlink(KCAST(&r00), KCAST(&r12));
+	c2_knot_unlink(KCAST(&r00), KCAST(&r13));
+
+
+	hw_part_fini(&r20);
+	hw_part_fini(&r21);
+	hw_part_fini(&r22);
+	hw_part_fini(&r23);
+	hw_part_fini(&r24);
+	hw_part_fini(&r25);
+	hw_part_fini(&r13);
+	hw_part_fini(&r12);
+	hw_part_fini(&r11);
+	hw_part_fini(&r10);
+	hw_part_fini(&r00);
+}
+
+/* ----------------------------------------------------------------------
+				reg2 test:
+   ---------------------------------------------------------------------- */
+struct reg_obj {
+	struct c2_list_link o_link;
+	int		    o_data;
+};
+
+static void reg_obj_init(struct reg_obj *o, int i)
+{
+	c2_list_link_init(&o->o_link);
+	o->o_data = i;
+}
+
+static void reg_obj_fini(struct reg_obj *o)
+{
+	c2_list_link_fini(&o->o_link);
+}
+
+static  bool reg_eq(const struct c2_list_link *current,
+		    const struct c2_buf *value)
+{
+	struct reg_obj *curr = c2_list_entry(current, struct reg_obj, o_link);
+	struct c2_buf   cbuf = C2_BUF_INIT(sizeof(curr->o_data),
+					   (void*)(&curr->o_data));
+
+	return c2_buf_eq(value, &cbuf);
+}
+
+static void reg_test(void)
+{
+	int i;
+
+	struct c2_reg reg;
+	struct reg_obj o[5];
+
+	struct c2_list_link *link;
+	struct c2_buf value;
+	struct reg_obj *looked;
+
+
+	c2_reg_init(&reg, reg_eq);
+
+	for (i = 0; i < ARRAY_SIZE(o); ++i) {
+		reg_obj_init(&o[i], i);
+		c2_reg_add(&reg, &o[i].o_link);
+	}
+
+	i = 3;
+	c2_buf_init(&value, &i, sizeof(i));
+	link = c2_reg_lookup(&reg, &value);
+	C2_ASSERT(link != NULL);
+	looked = c2_list_entry(link, struct reg_obj, o_link);
+	C2_ASSERT(looked->o_data == i);
+
+	for (i = 0; i < ARRAY_SIZE(o); ++i) {
+		c2_reg_del(&reg, &o[i].o_link);
+		reg_obj_fini(&o[i]);
+	}
+
+	c2_reg_fini(&reg);
+}
+
+
+/* ----------------------------------------------------------------------
+				conf object and conf reg:
+   ---------------------------------------------------------------------- */
+
+/** !!!A copy!!! */
+enum c2_conf_objtype {
+	C2_CO_DIR,        /* 0 */
+	C2_CO_PROFILE,    /* 1 */
+	C2_CO_FILESYSTEM, /* 2 */
+	C2_CO_SERVICE,    /* 3 */
+	C2_CO_NODE,       /* 4 */
+	C2_CO_NIC,        /* 5 */
+	C2_CO_SDEV,       /* 6 */
+	C2_CO_PARTITION,  /* 7 */
+	C2_CO_NR
+};
+
+struct conf_obj {
+	struct c2_knot	    co_knot; /* should be on the first place!!! */
+	struct c2_list_link co_link; /* link into registry */
+	struct confx_object co_data;
+};
+
+static void conf_obj_id(struct c2_knot *knot, struct c2_knot_uuid *out)
+{
+	struct conf_obj *obj = (struct conf_obj *)knot;
+	C2_CASSERT((void*)obj == (void*)&obj->co_knot);
+
+	out->ku_id = obj->co_data.o_id;
+
+	/* @todo init: out->ku_type */
+}
+
+/* ---------------------------------------------------------------------- */
+
+static int co_profile_fk(struct c2_knot *knot, struct c2_knot_uuid *out,
+			 c2_bcount_t seq_num)
+{
+	struct conf_obj *obj = (struct conf_obj *)knot;
+	C2_CASSERT((void*)obj == (void*)&obj->co_knot);
+
+	if (out == NULL)
+		return 1;
+
+	if (seq_num == 0) {
+		out->ku_id = obj->co_data.o_conf.u.u_profile.xp_filesystem;
+		return 0;
+	}
+
+	/* @todo init: out->ku_type */
+	return -ENOENT;
+}
+
+static int co_filesystem_fk(struct c2_knot *knot, struct c2_knot_uuid *out,
+			    c2_bcount_t seq_num)
+{
+	struct conf_obj *obj = (struct conf_obj *)knot;
+	uint32_t count = obj->co_data.o_conf.u.u_filesystem.xf_services.ab_count;
+	C2_CASSERT((void*)obj == (void*)&obj->co_knot);
+
+	if (out == NULL)
+		return count;
+
+	if (seq_num < count) {
+		out->ku_id =
+		obj->co_data.o_conf.u.u_filesystem.xf_services.ab_elems[seq_num];
+		return 0;
+	}
+
+	/* @todo init: out->ku_type */
+	return -ENOENT;
+}
+static int co_service_fk(struct c2_knot *knot, struct c2_knot_uuid *out,
+			 c2_bcount_t seq_num)
+{
+	struct conf_obj *obj = (struct conf_obj *)knot;
+	C2_CASSERT((void*)obj == (void*)&obj->co_knot);
+
+	if (out == NULL)
+		return 1;
+
+	if (seq_num == 0) {
+		out->ku_id = obj->co_data.o_conf.u.u_service.xs_node;
+		return 0;
+	}
+
+	/* @todo init: out->ku_type */
+	return -ENOENT;
+}
+static int co_node_fk(struct c2_knot *knot, struct c2_knot_uuid *out,
+			 c2_bcount_t seq_num)
+{
+	struct conf_obj *obj = (struct conf_obj *)knot;
+	uint32_t nic_count =
+		obj->co_data.o_conf.u.u_node.xn_nics.ab_count;
+	uint32_t sdev_count =
+		obj->co_data.o_conf.u.u_node.xn_sdevs.ab_count;
+
+	C2_CASSERT((void*)obj == (void*)&obj->co_knot);
+
+	if (out == NULL)
+		return nic_count + sdev_count;
+
+	if (seq_num < nic_count) {
+		out->ku_id = obj->co_data.o_conf.u.u_node.xn_nics.ab_elems[seq_num];
+		return 0;
+	} else if (nic_count <= seq_num && seq_num < (sdev_count + nic_count)) {
+		out->ku_id = obj->co_data.o_conf.u.u_node.xn_sdevs.ab_elems[seq_num - nic_count];
+		return 0;
+	}
+
+	/* @todo init: out->ku_type */
+	return -ENOENT;
+}
+static int co_nic_fk(struct c2_knot *knot, struct c2_knot_uuid *out,
+			 c2_bcount_t seq_num)
+{
+	struct conf_obj *obj = (struct conf_obj *)knot;
+	C2_CASSERT((void*)obj == (void*)&obj->co_knot);
+
+	if (out == NULL)
+		return 0;
+
+	/* @todo init: out->ku_type */
+	return -ENOENT;
+}
+static int co_sdev_fk(struct c2_knot *knot, struct c2_knot_uuid *out,
+			 c2_bcount_t seq_num)
+{
+	struct conf_obj *obj = (struct conf_obj *)knot;
+	uint32_t count = obj->co_data.o_conf.u.u_sdev.xd_partitions.ab_count;
+	C2_CASSERT((void*)obj == (void*)&obj->co_knot);
+
+	if (out == NULL)
+		return count;
+
+	if (seq_num < count) {
+		out->ku_id =
+		obj->co_data.o_conf.u.u_sdev.xd_partitions.ab_elems[seq_num];
+		return 0;
+	}
+
+	/* @todo init: out->ku_type */
+	return -ENOENT;
+}
+static int co_partition_fk(struct c2_knot *knot, struct c2_knot_uuid *out,
+			   c2_bcount_t seq_num)
+{
+	struct conf_obj *obj = (struct conf_obj *)knot;
+	C2_CASSERT((void*)obj == (void*)&obj->co_knot);
+
+	if (out == NULL)
+		return 0;
+
+	/* @todo init: out->ku_type */
+	return -ENOENT;
+}
+
+
+/* ---------------------------------------------------------------------- */
+
+static bool conf_obj_has_fkeys(struct conf_obj *obj)
+{
+	return obj->co_knot.k_who.kw_fk(&obj->co_knot, NULL, 0) > 0;
+}
+
+static void conf_obj_init(struct conf_obj *obj, struct confx_object *xobj)
+{
+	struct c2_knot_whoami who;
+	switch(xobj->o_conf.u_type) {
+	case C2_CO_PROFILE   :
+		who = (struct c2_knot_whoami) { conf_obj_id, co_profile_fk };
+		break;
+	case C2_CO_FILESYSTEM:
+		who = (struct c2_knot_whoami) { conf_obj_id, co_filesystem_fk };
+		break;
+	case C2_CO_SERVICE   :
+		who = (struct c2_knot_whoami) { conf_obj_id, co_service_fk };
+		break;
+	case C2_CO_NODE      :
+		who = (struct c2_knot_whoami) { conf_obj_id, co_node_fk };
+		break;
+	case C2_CO_NIC       :
+		who = (struct c2_knot_whoami) { conf_obj_id, co_nic_fk };
+		break;
+	case C2_CO_SDEV      :
+		who = (struct c2_knot_whoami) { conf_obj_id, co_sdev_fk };
+		break;
+	case C2_CO_PARTITION :
+		who = (struct c2_knot_whoami) { conf_obj_id, co_partition_fk };
+		break;
+	case C2_CO_DIR       :
+	default:
+		who = (struct c2_knot_whoami) { NULL, NULL };
+	};
+
+	c2_knot_init(&obj->co_knot, who);
+	c2_list_link_init(&obj->co_link);
+	obj->co_data = *xobj;
+}
+
+static void conf_obj_fini(struct conf_obj *obj)
+{
+	c2_knot_fini(&obj->co_knot);
+	c2_list_link_fini(&obj->co_link);
+}
+
+static void conf_reg_add(struct c2_reg *reg, struct conf_obj *o)
+{
+	c2_reg_add(reg, &o->co_link);
+}
+
+static void conf_reg_del(struct c2_reg *reg, struct conf_obj *o)
+{
+	c2_reg_del(reg, &o->co_link);
+}
+
+static struct conf_obj *conf_reg_lookup(const struct c2_reg *reg,
+					const struct c2_buf *value)
+{
+	struct c2_list_link *l;
+	struct conf_obj     *o;
+
+	l = c2_reg_lookup(reg, value);
+	if (l == NULL)
+		return NULL;
+
+	o = c2_list_entry(l, struct conf_obj, co_link);
+	return o;
+}
+
+static  bool conf_obj_eq(const struct c2_list_link *current,
+			 const struct c2_buf *value)
+{
+	struct conf_obj *co = c2_list_entry(current, struct conf_obj, co_link);
+
+	 /* @todo   : id comparison should contain the following: */
+	 /* c2_buf  : co->co_data.o_id                            */
+         /* unit32_t: co->co_data.o_conf.u_type                   */
+
+	return c2_buf_eq(&co->co_data.o_id, value);
+}
+
+
+/* ----------------------------------------------------------------------
+                            object DAG:
+   ---------------------------------------------------------------------- */
+
+static int confx_read(struct confx_object *conf, size_t conf_count)
+{
+	enum { KB = 1 << 10 };
+	static char buf[32*KB] = {0}; /* be careful here! */
+	int  n;
+
+	n = fread(buf, 1, sizeof buf, stdin);
+	if (n <= 0)
+		return -1;
+	buf[n] = '\0';
+
+	n = c2_conf_parse(buf, conf, conf_count);
+	C2_ASSERT(n == 8);
+	return n;
+}
+
+/**
+ * @pre obj is not in DAG
+ */
+static int dag_link(struct c2_reg *reg, struct conf_obj *obj)
+{
+	int i;
+	int rc;
+	struct c2_knot_whoami  who = obj->co_knot.k_who;
+	struct c2_knot_uuid    uuid;
+	struct conf_obj       *child;
+
+	/* !!! ----------------------------------- !!! */
+	/* @todo: &uuid.ku_type should be passed also! */
+	/* !!! ----------------------------------- !!! */
+
+	if (conf_obj_has_fkeys(obj)) {
+		for (i = 0; who.kw_fk(&obj->co_knot, &uuid, i) == 0; ++i) {
+			child = conf_reg_lookup(reg, &uuid.ku_id);
+			if (child == NULL)
+				return -ENOENT;
+
+			rc = c2_knot_link(KCAST(obj), KCAST(child));
+			if (rc != 0) {
+				/* @todo: delete knots on error! */
+				return rc;
+			}
+		}
+	}
+
+	conf_reg_add(reg, obj);
+
+	return 0;
+}
+
+static void conf_obj_visit(const struct c2_list_link *l)
+{
+	int i;
+	struct c2_knot_uuid pid;
+	struct c2_knot_uuid cid;
+	char pb[256] = { 0 }; /* @todo: horrible! */
+	struct conf_obj *o = c2_list_entry(l, struct conf_obj, co_link);
+
+	for (i = 0; o->co_knot.k_who.kw_fk(&o->co_knot, &cid, i) == 0; ++i) {
+		char cb[256] = { 0 }; /* @todo: horrible! */
+
+		o->co_knot.k_who.kw_id(&o->co_knot, &pid);
+		memcpy(pb, pid.ku_id.b_addr, min64u(255ULL, pid.ku_id.b_nob));
+		memcpy(cb, cid.ku_id.b_addr, min64u(255ULL, cid.ku_id.b_nob));
+
+		printf("\"%s\" -> \"%s\"\n", pb, cb);
+	}
+}
+
+static void conf_obj_digraph_create(const struct c2_reg* reg,
+				    const struct conf_obj *obj)
+{
+	printf("digraph obj {\n");
+	c2_reg_iterate(reg, conf_obj_visit);
+	printf("}\n");
+}
+
+static void dag_test(void)
+{
+	static struct confx_object confx[100];
+	struct conf_obj conf[100];
+	struct c2_reg reg;
+
+	int conf_count;
+	int rc;
+	int i;
+
+	/* read confxs */
+	conf_count = confx_read(confx, ARRAY_SIZE(confx));
+	C2_ASSERT(conf_count == 8);
+
+	/* test dag and linker */
+	c2_reg_init(&reg, conf_obj_eq);
+
+	for (i = conf_count - 1; i >= 0; --i) {
+		conf_obj_init(&conf[i], &confx[i]);
+		rc = dag_link(&reg, &conf[i]);
+		C2_ASSERT(rc == 0);
+	}
+
+	conf_obj_digraph_create(&reg, &conf[0]);
+
+	for (i = 0; i < conf_count; ++i) {
+		conf_reg_del(&reg, &conf[i]);
+		conf_obj_fini(&conf[i]);
+	}
+
+	c2_reg_fini(&reg);
+	c2_confx_fini(confx, conf_count);
+}
+
+
+/* ----------------------------------------------------------------------
+				dumb runner:
+   ---------------------------------------------------------------------- */
+/* @TODO:  Alternative DAG linker TODO:
+ *
+ * 1)  add object finalizer into conf_reg_fini() for heap-allocated objects;
+ * 2)  add link-rules to follow them while adding type1 into type2;
+ * 2') add new obj type registration procedure (affects (2));
+ * 3)  add usage of 'c2_knot_whoami::ku_type' for type distinguishing.
+ * 4)  general cleanup; separate different components cleanly (e.g. c2_reg)!
+ * 5)  write tests on each subsystem;
+ * 6)  optimize when ready, remove extra abstraction layers, try to
+ *     remove allocation in knot-list.
+ */
+
+
+int main(void)
+{
+	if (0) {
+		knot_test();
+		knot_struct_test();
+		reg_test();
+	}
+	dag_test();
+
+	return 0;
+}
diff --git a/conf/ut/linktest.c b/conf/ut/linktest.c
deleted file mode 100644
index 747a98d..0000000
--- a/conf/ut/linktest.c
+++ /dev/null
@@ -1,109 +0,0 @@
-#include "conf/link.h"
-#include <stdio.h>
-
-enum types {
-	BIOS,
-	MEM,
-	CPU,
-	CACHE,
-	REG,
-	MB
-};
-
-/*
-	mb0
-	 |
-   +-----+------+-------+
-   |	 |	|       |
- bios0	mem0   mem1    cpu0
-			|
-	   +------+-----+--- +----+----+
- 	   |	  |     |    |	  |    |
-         cache0 cache1 reg0 reg1 reg2 reg3
- */
-
-int main(void)
-{
-
-	struct c2_conf_rel r20 = { .cr_who = { "cache0", CACHE } };
-	struct c2_conf_rel r21 = { .cr_who = { "cache1", CACHE } };
-	struct c2_conf_rel r22 = { .cr_who = { "reg0"  , REG   } };
-	struct c2_conf_rel r23 = { .cr_who = { "reg1"  , REG   } };
-	struct c2_conf_rel r24 = { .cr_who = { "reg2"  , REG   } };
-	struct c2_conf_rel r25 = { .cr_who = { "reg3"  , REG   } };
-
-	struct c2_conf_rel r13 = { .cr_who = { "bios0" , BIOS  } };
-	struct c2_conf_rel r12 = { .cr_who = { "mem0"  , MEM   } };
-	struct c2_conf_rel r11 = { .cr_who = { "mem1"  , MEM   } };
-	struct c2_conf_rel r10 = { .cr_who = { "cpu0"  , CPU   } };
-
-	struct c2_conf_rel r00 = { .cr_who = { "mb0"   , MB    } };
-
-	c2_conf_rel_init(&r20);
-	c2_conf_rel_init(&r21);
-	c2_conf_rel_init(&r22);
-	c2_conf_rel_init(&r23);
-	c2_conf_rel_init(&r24);
-	c2_conf_rel_init(&r25);
-	c2_conf_rel_init(&r13);
-	c2_conf_rel_init(&r12);
-	c2_conf_rel_init(&r11);
-	c2_conf_rel_init(&r10);
-	c2_conf_rel_init(&r00);
-
-
-	c2_conf_rel_add(&r00, &r10);
-	c2_conf_rel_add(&r00, &r11);
-	c2_conf_rel_add(&r00, &r12);
-	c2_conf_rel_add(&r00, &r13);
-
-	c2_conf_rel_add(&r10, &r20);
-	c2_conf_rel_add(&r10, &r21);
-	c2_conf_rel_add(&r10, &r22);
-	c2_conf_rel_add(&r10, &r23);
-	c2_conf_rel_add(&r10, &r24);
-	c2_conf_rel_add(&r10, &r25);
-
-
-	printf("test1:\n");
-	{
-		const char *path[] = { "mb0", "cpu0", "reg0", NULL };
-		struct c2_conf_rel *rel = c2_conf_rel_walk(&r00, path);
-		C2_ASSERT(rel != NULL);
-	}
-	printf("test2:\n");
-	{
-		const char *path[] = { "mb0", "cpu0", "regX", NULL };
-		struct c2_conf_rel *rel = c2_conf_rel_walk(&r00, path);
-		C2_ASSERT(rel == NULL);
-	}
-
-
-	c2_conf_rel_del(&r00, &r10);
-	c2_conf_rel_del(&r00, &r11);
-	c2_conf_rel_del(&r00, &r12);
-	c2_conf_rel_del(&r00, &r13);
-
-	c2_conf_rel_del(&r10, &r20);
-	c2_conf_rel_del(&r10, &r21);
-	c2_conf_rel_del(&r10, &r22);
-	c2_conf_rel_del(&r10, &r23);
-	c2_conf_rel_del(&r10, &r24);
-	c2_conf_rel_del(&r10, &r25);
-
-
-	c2_conf_rel_fini(&r20);
-	c2_conf_rel_fini(&r21);
-	c2_conf_rel_fini(&r22);
-	c2_conf_rel_fini(&r23);
-	c2_conf_rel_fini(&r24);
-	c2_conf_rel_fini(&r25);
-	c2_conf_rel_fini(&r13);
-	c2_conf_rel_fini(&r12);
-	c2_conf_rel_fini(&r11);
-	c2_conf_rel_fini(&r10);
-	c2_conf_rel_fini(&r00);
-
-
-	return 0;
-}
diff --git a/conf/ut/oddlist.c b/conf/ut/oddlist.c
deleted file mode 100644
index fd12728..0000000
--- a/conf/ut/oddlist.c
+++ /dev/null
@@ -1,138 +0,0 @@
-#include "conf/knot.h"
-#include <stdio.h>
-
-
-void knot_test(void)
-{
-	struct c2_knot_list list;
-	struct c2_knot data[] = { { .k_who = {"",10} },
-				  { .k_who = {"",21} },
-				  { .k_who = {"",32} },
-				  { .k_who = {"",43} },
-				  { .k_who = {"",54} }};
-	int i;
-
-	c2_knot_list_init(&list);
-
-	for (i = 0; i < ARRAY_SIZE(data); ++i)
-		c2_knot_list_add(&list, &data[i]);
-
-
-	printf("len: %lu\n", c2_knot_list_length(&list));
-
-	for (i = 0; i < ARRAY_SIZE(data); ++i)
-		printf("[%d]: %d\n", i, c2_knot_list_entry(&list, i)->k_who.id);
-
-	printf("NULL: %p\n", c2_knot_list_entry(&list, 100));
-
-	for (i = 0; i < ARRAY_SIZE(data); ++i)
-		c2_knot_list_del(&list, &data[i]);
-
-
-	c2_knot_list_fini(&list);
-}
-
-enum types {
-	BIOS,
-	MEM,
-	CPU,
-	CACHE,
-	REG,
-	MB
-};
-
-void knot_struct_test()
-{
-/*
-        mb0
-         |
-   +-----+------+-------+----------------------+
-   |     |      |       |                      |
- bios0  mem0   mem1    cpu0-------+-----------cpu1
-                        |         |            |
-                      +-+-+       |          +-+-+
-                      |   |       |          |   |
-                    reg0 reg1     |        reg0 reg1
-                               +--+--+
-                               |     |
-                           cache0  cache1
- */
-
-	struct c2_knot r20 = { .k_who = { "cache0", CACHE } };
-	struct c2_knot r21 = { .k_who = { "cache1", CACHE } };
-	struct c2_knot r22 = { .k_who = { "reg0"  , REG   } };
-	struct c2_knot r23 = { .k_who = { "reg1"  , REG   } };
-	struct c2_knot r24 = { .k_who = { "reg2"  , REG   } };
-	struct c2_knot r25 = { .k_who = { "reg3"  , REG   } };
-
-	struct c2_knot r13 = { .k_who = { "bios0" , BIOS  } };
-	struct c2_knot r12 = { .k_who = { "mem0"  , MEM   } };
-	struct c2_knot r11 = { .k_who = { "mem1"  , MEM   } };
-	struct c2_knot r10 = { .k_who = { "cpu0"  , CPU   } };
-
-	struct c2_knot r00 = { .k_who = { "mb0"   , MB    } };
-
-	int rc;
-
-	c2_knot_init(&r20);
-	c2_knot_init(&r21);
-	c2_knot_init(&r22);
-	c2_knot_init(&r23);
-	c2_knot_init(&r24);
-	c2_knot_init(&r25);
-	c2_knot_init(&r13);
-	c2_knot_init(&r12);
-	c2_knot_init(&r11);
-	c2_knot_init(&r10);
-	c2_knot_init(&r00);
-
-
-	rc = c2_knot_link(&r00, &r10);  C2_ASSERT(rc == 0);
-	rc = c2_knot_link(&r00, &r11);  C2_ASSERT(rc == 0);
-	rc = c2_knot_link(&r00, &r12);  C2_ASSERT(rc == 0);
-	rc = c2_knot_link(&r00, &r13);  C2_ASSERT(rc == 0);
-
-	rc = c2_knot_link(&r10, &r20);  C2_ASSERT(rc == 0);
-	rc = c2_knot_link(&r10, &r21);  C2_ASSERT(rc == 0);
-	rc = c2_knot_link(&r10, &r22);  C2_ASSERT(rc == 0);
-	rc = c2_knot_link(&r10, &r23);  C2_ASSERT(rc == 0);
-	rc = c2_knot_link(&r10, &r24);  C2_ASSERT(rc == 0);
-	rc = c2_knot_link(&r10, &r25);  C2_ASSERT(rc == 0);
-
-
-
-	c2_knot_unlink(&r10, &r20);
-	c2_knot_unlink(&r10, &r21);
-	c2_knot_unlink(&r10, &r22);
-	c2_knot_unlink(&r10, &r23);
-	c2_knot_unlink(&r10, &r24);
-	c2_knot_unlink(&r10, &r25);
-
-	c2_knot_unlink(&r00, &r10);
-	c2_knot_unlink(&r00, &r11);
-	c2_knot_unlink(&r00, &r12);
-	c2_knot_unlink(&r00, &r13);
-
-
-	c2_knot_fini(&r20);
-	c2_knot_fini(&r21);
-	c2_knot_fini(&r22);
-	c2_knot_fini(&r23);
-	c2_knot_fini(&r24);
-	c2_knot_fini(&r25);
-	c2_knot_fini(&r13);
-	c2_knot_fini(&r12);
-	c2_knot_fini(&r11);
-	c2_knot_fini(&r10);
-	c2_knot_fini(&r00);
-
-}
-
-
-int main(void)
-{
-	knot_test();
-	knot_struct_test();
-
-	return 0;
-}
-- 
1.8.3.2

