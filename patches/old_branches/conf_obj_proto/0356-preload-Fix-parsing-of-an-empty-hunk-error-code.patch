From dccefd00473f995c7f376cc828976fb02e65757a Mon Sep 17 00:00:00 2001
From: Anatoliy Bilenko <anatoliy_bilenko@xyratex.com>
Date: Sun, 2 Sep 2012 23:17:51 +0300
Subject: [PATCH 356/370] preload: Fix parsing of an empty hunk error code.

---
 conf/preload.c | 93 +++++++++++++++++++++++++++++++---------------------------
 1 file changed, 50 insertions(+), 43 deletions(-)

diff --git a/conf/preload.c b/conf/preload.c
index d64950b..b943b64 100644
--- a/conf/preload.c
+++ b/conf/preload.c
@@ -37,7 +37,7 @@
 
 
 /* ------------------------------------------------------------------
- * Preload parser
+ * Simple character stack, used by preload parser library
  * ------------------------------------------------------------------ */
 
 struct stack {
@@ -73,23 +73,24 @@ static int stack_push(struct stack *stack, char c)
 
 static char stack_top(const struct stack *stack)
 {
-	C2_PRE(stack->end > 0);
+	C2_PRE(stack->end > 0 && stack->end <= stack->size);
 
 	return stack->stack[stack->end - 1];
 }
 
-/*
+
+/* -----------------------------------------------------------------------------
   Preload parser minilibrary is used to parse sequences of characters, separated
-  by ',', ':',... providing non-destructive input data capability. It introduces
-  three abstractions:
+  by ',', ':',... w.r.t. other separators like braces, quotes, etc. It provides
+  non-destructive input data capability and introduces the following
+  abstractions:
 
-        - Hunk is like an area of interest in given sequence of characters. It
+        # Hunk is like an area of interest in given sequence of characters. It
           has begin and end to specify the bounds of it. Library provides some
           minimalistic functions to operate hunks, like validating, copying,
-          comparing the contents the hunk points to, with a C-string, getting
-          its length.
+          comparing with built-in types, getting length.
 
-        - Unit is something that parser treats as an atomic and does not parse
+	# Unit is something that parser treats to be atomic and does not parse
           into. From the beginning it was called an `atom'. Units are in some
           sense 'context dependent' hunks. For example, the following can be a
           unit:
@@ -102,19 +103,19 @@ static char stack_top(const struct stack *stack)
           Library may perform simple manipulations over units, like trimming
           whitespaces, unquote quoted units. The most interesting part is
           parsing unit in the beginning of a `stream' and moving to the next
-          separated unit in the stream (unit_parse, unit_next). It's also
+          separated unit in the stream (unit_parse(), unit_next()). It's also
           possible to look into an 'atomic'-hunk and to find out that it's not.
-          Advancing into unit_10, 'may find something in undividable'
-          (unit_advance).
+          For example, advancing into unit_10, 'may find something in
+          undividable' (unit_advance()).
 
-        - Sequence iterator is a wrapper over unit_parse() and unit_next() which
-          provides an iterator-like iterface. Currently, unit, state of stream
+        # Sequence iterator is a wrapper over unit_parse() and unit_next() which
+          provides an iterator-like iterface. Unit, state of the input stream
           (buffer) and the type of used separator is a context of the iterator.
 
   Usage:
           struct hunk stream = HUNK_INITS("[parsed, seq], [of, bytes]");
-          struct hunk unit = HUNK_EMPTY;
-          size_t ui;
+          struct hunk unit = HUNK_INITIAL;
+          size_t ui; // unit index
           int    rc;
 
           for (; (rc = seq_iterate(&unit, &stream, ',')) == 0; ui++) {
@@ -124,36 +125,38 @@ static char stack_top(const struct stack *stack)
           }
 
           C2_ASSERT(rc == -ENOENT);
- */
+ ---------------------------------------------------------------------------- */
 
+
 struct hunk {
 	const char *begin;
 	const char *end;
 };
 
 #define HUNK_CP(p)    { .begin = p->begin, .end = p->end }
-#define HUNK_EMPTY    { NULL, NULL }
+#define HUNK_INITIAL  { NULL, NULL }
 #define HUNK_INITS(s) { .begin = s, .end = &s[strlen(s) - 1] }
 
-static bool hunk_is_empty(const struct hunk *p)
+static bool hunk_is_initial(const struct hunk *p)
 {
 	return p->begin == NULL && p->end == NULL;
 }
 
 static bool hunk_invariant(const struct hunk *p)
 {
-	C2_PRE(!hunk_is_empty(p));
+	C2_PRE(!hunk_is_initial(p));
 	return p->end >= p->begin;
 }
 
 static void hunk_pr(const char *prefix, const struct hunk *p) {
 #ifdef HUNK_DBG
-	char buf[4096];
+	char  buf[4096];
+	const char *c;
 
-	C2_PRE(!hunk_is_empty(p));
+	C2_PRE(hunk_invariant(p));
 
-	/* @todo: for (p = hunk->begin; p <= hunk->end; ++p)
-	   C2_PRE(isprint(*p)); */
+	for (c = p->begin; c <= p->end; ++c)
+		C2_PRE(isprint(*c));
 
 	memset(buf, 0, 4096);
 	memcpy(buf, p->begin, p->end - p->begin + 1);
@@ -175,11 +178,7 @@ static size_t hunk_len(const struct hunk *hunk)
 
 static bool hunk_str_eq(const struct hunk *hunk, const char *string)
 {
-	const char *p;
-	int	    len;
-
-	for (p = hunk->begin; p <= hunk->end; ++p)
-		C2_PRE(isprint(*p));
+	int len;
 
 	len = strlen(string);
 	if (len != hunk_len(hunk))
@@ -189,6 +188,10 @@ static bool hunk_str_eq(const struct hunk *hunk, const char *string)
 }
 
 
+/* ------------------------------------------------------------------
+ * Units of preload parser
+ * ------------------------------------------------------------------ */
+
 static int unit_trim(struct hunk *p)
 {
 	C2_PRE(hunk_invariant(p));
@@ -277,7 +280,7 @@ static int unit_parse(struct hunk *unit, char ss)
 
 		if (*p == ss) {
 			if (p == unit->begin)   /* unit starts from ',': e.g. */
-				return -EINVAL; /* ',42', treated as an error */
+				return -EINVAL; /* ",42"; treated as an error */
 
 			unit->end = --p;
 			break;
@@ -310,8 +313,12 @@ static int unit_next(struct hunk *unit, const struct hunk *buffer, char ss)
 }
 
 
+/* ------------------------------------------------------------------
+ * Sequences of preload parser
+ * ------------------------------------------------------------------ */
+
 /**
- *  @param ss sequence separator, like ',' or ':'
+ *  @param ss sequence separator: ',' or ':'
  */
 static int seq_iterate(struct hunk *unit, const struct hunk *buffer, char ss)
 {
@@ -319,7 +326,7 @@ static int seq_iterate(struct hunk *unit, const struct hunk *buffer, char ss)
 
 	C2_PRE(C2_IN(ss, (',', ':')));
 
-	if (hunk_is_empty(unit))
+	if (hunk_is_initial(unit))
 		hunk_cp(unit, buffer);
 	else {
 		rc = unit_next(unit, buffer, ss);
@@ -334,7 +341,7 @@ static int seq_iterate(struct hunk *unit, const struct hunk *buffer, char ss)
 static int seq_length(const struct hunk *unit, char ss)
 {
 	int length = 0;
-	struct hunk contents = HUNK_EMPTY;
+	struct hunk contents = HUNK_INITIAL;
 
 	while (seq_iterate(&contents, unit, ss) == 0)
 		length++;
@@ -384,7 +391,7 @@ static int rootfid_parse(struct fid *fid, const struct hunk *val)
 {
 	int rc;
 	struct hunk aval = HUNK_CP(val);
-	struct hunk rfid = HUNK_EMPTY;
+	struct hunk rfid = HUNK_INITIAL;
 
 	C2_PRE(hunk_invariant(val));
 
@@ -413,8 +420,8 @@ static int arrbuf_parse(struct arr_buf *buf, const struct hunk *val)
 	int i;
 	int rc;
 	struct hunk aval = HUNK_CP(val);
-	struct hunk qent = HUNK_EMPTY; /* quoted entry */
-	struct hunk uent = HUNK_EMPTY; /* unquoted entry */
+	struct hunk qent = HUNK_INITIAL; /* quoted entry */
+	struct hunk uent = HUNK_INITIAL; /* unquoted entry */
 
 	C2_PRE(hunk_invariant(val));
 
@@ -679,7 +686,7 @@ static int partition_parse(const struct hunk *key, const struct hunk *val,
 
 
 /* ------------------------------------------------------------------
- * Bindings: generic parser is bound to concrete
+ * Bindings: here generic parser is being bound to concrete
  * ------------------------------------------------------------------ */
 
 static int unused_parse(const struct hunk *key, const struct hunk *val,
@@ -719,9 +726,9 @@ static size_t str_to_x(const struct hunk *key)
 static int x_parser_call(const struct hunk *str, struct confx_object *out)
 {
 	int rc;
-	struct hunk ent = HUNK_EMPTY;
-	struct hunk key = HUNK_EMPTY;
-	struct hunk val = HUNK_EMPTY;
+	struct hunk ent = HUNK_INITIAL;
+	struct hunk key = HUNK_INITIAL;
+	struct hunk val = HUNK_INITIAL;
 
 	rc = seq_iterate(&ent, str, ':');
 	if (rc != 0)
@@ -770,13 +777,13 @@ int c2_conf_parse(const char *src, struct confx_object *dest, size_t n)
 	int rc;
 	size_t conf_index = 0;
 	struct hunk str = HUNK_INITS(src);
-	struct hunk blk = HUNK_EMPTY;
+	struct hunk blk = HUNK_INITIAL;
 
 	while ((rc = block_parse(&blk, &str)) == 0) {
-		struct hunk rec = HUNK_EMPTY;
+		struct hunk rec = HUNK_INITIAL;
 
 		while ((rc = record_parse(&rec, &blk)) == 0) {
-			struct hunk ent = HUNK_EMPTY;
+			struct hunk ent = HUNK_INITIAL;
 
 			dest[conf_index].o_conf.u_type = C2_CO_INVALID_TYPE;
 
-- 
1.8.3.2

