From 1d09233b0169d21ff9e821ccd7799b625d4a6b62 Mon Sep 17 00:00:00 2001
From: "Valery V. Vorotyntsev" <valery_vorotyntsev@xyratex.com>
Date: Sat, 18 Feb 2012 01:14:48 +0200
Subject: [PATCH 009/370] s/fc__/fc_/

These double underscores for "private" members do not look good.
---
 conf/confc.c    | 75 ++++++++++++++++++++++++++++-----------------------------
 conf/confc.h    | 22 ++++++++---------
 conf/ut/confc.c | 28 ++++++++++-----------
 3 files changed, 62 insertions(+), 63 deletions(-)

diff --git a/conf/confc.c b/conf/confc.c
index 1d52f0c..66ea12c 100644
--- a/conf/confc.c
+++ b/conf/confc.c
@@ -39,16 +39,16 @@ static void _state_set(struct c2_sm_group *grp __attribute__((unused)),
 		       struct c2_sm_ast *ast)
 {
 	struct c2_confc_fetchctx *ctx =
-		container_of(ast, struct c2_conf_fetchctx, fc__ast);
-	c2_sm_state_set(&ctx->fc__mach, (enum confc_state)ast->sa_datum);
+		container_of(ast, struct c2_conf_fetchctx, fc_ast);
+	c2_sm_state_set(&ctx->fc_mach, (enum confc_state)ast->sa_datum);
 }
 
 static void _fail(struct c2_sm_group *grp __attribute__((unused)),
 		  struct c2_sm_ast *ast)
 {
 	struct c2_confc_fetchctx *ctx =
-		container_of(ast, struct c2_conf_fetchctx, fc__ast);
-	c2_sm_fail(&ctx->fc__mach, S_FAILURE, (int32_t)ast->sa_datum);
+		container_of(ast, struct c2_conf_fetchctx, fc_ast);
+	c2_sm_fail(&ctx->fc_mach, S_FAILURE, (int32_t)ast->sa_datum);
 }
 
 /** Posts an AST that will advance the state machine to given state. */
@@ -71,23 +71,23 @@ static void ast_fail(struct c2_sm_ast *ast, int32_t rc)
 static bool on_unpinned(struct c2_clink *link)
 {
 	struct c2_confc_fetchctx *ctx =
-		container_of(link, struct c2_confc_fetchctx, fc__clink);
+		container_of(link, struct c2_confc_fetchctx, fc_clink);
 
 	c2_clink_del(link);
-	ast_state_set(&ctx->fc__ast, S_CHECK);
+	ast_state_set(&ctx->fc_ast, S_CHECK);
 	return true;
 }
 
 void c2_confc_fetchctx_init(struct c2_confc_fetchctx *ctx)
 {
 	c2_chan_init(&ctx->fc_complete);
-	c2_clink_init(&ctx->fc__clink, on_unpinned);
+	c2_clink_init(&ctx->fc_clink, on_unpinned);
 }
 C2_EXPORTED(c2_confc_fetchctx_init);
 
 void c2_confc_fetchctx_fini(struct c2_confc_fetchctx *ctx)
 {
-	c2_clink_fini(&ctx->fc__clink);
+	c2_clink_fini(&ctx->fc_clink);
 	c2_chan_fini(&ctx->fc_complete);
 }
 C2_EXPORTED(c2_confc_fetchctx_fini);
@@ -106,24 +106,23 @@ list_status(const struct c2_tl_descr *descr, const struct c2_tl *list)
 
 /**
  * @pre   cache's sm_group is locked
- * @pre   c2_conf_path_invariant(&ctx->fc__path)
+ * @pre   c2_conf_path_invariant(&ctx->fc_path)
  * @post  cache's sm_group is locked
  *
- * @retval -ENOENT  ctx->fc__path contains a key and the corresponding
+ * @retval -ENOENT  ctx->fc_path contains a key and the corresponding
  *                  object does not exist.
  */
 static int
 path_status(struct c2_confc_fetchctx *ctx, enum c2_conf_status *status)
 {
-	struct c2_conf_obj *obj = ctx->fc__path.p_origin ?:
-		confc_cache->cc_root;
-	struct c2_conf_pathcomp *comp = ctx->fc__path.p_comps;
-	size_t len = ctx->fc__path.p_len; /* number of components to go */
+	struct c2_conf_obj *obj = ctx->fc_path.p_origin ?: confc_cache->cc_root;
+	struct c2_conf_pathcomp *comp = ctx->fc_path.p_comps;
+	size_t len = ctx->fc_path.p_len; /* number of components to go */
 	bool target_is_directory = false;
 	int ret = 0;
 
 	C2_PRE(c2_mutex_is_locked(&confc_cache.cc_sm_group->s_lock));
-	C2_PRE(c2_conf_path_invariant(&ctx->fc__path));
+	C2_PRE(c2_conf_path_invariant(&ctx->fc_path));
 
 	c2_mutex_lock(&confc_cache.cc_lock);
 	*status = obj->co_status;
@@ -182,7 +181,7 @@ path_status(struct c2_confc_fetchctx *ctx, enum c2_conf_status *status)
 
 		XXX {
 			/*
-			 * Encode the following into ctx->fc__fop:
+			 * Encode the following into ctx->fc_fop:
 			 *   .ff_origin.o_objtype = obj->co_objtype;
 			 *   .ff_origin.o_objkey <- obj->co_objkey;
 			 *   .ff_comps.c_nr       = len;
@@ -193,7 +192,7 @@ path_status(struct c2_confc_fetchctx *ctx, enum c2_conf_status *status)
 		if (target_is_directory) {
 			XXX; /* scan directory, adding clinks */
 		} else {
-			c2_clink_add(&obj->co_chan, &ctx->fc__clink);
+			c2_clink_add(&obj->co_chan, &ctx->fc_clink);
 		}
 	} else {
 		C2_IMPOSSIBLE("invalid object status");
@@ -207,7 +206,7 @@ end:
 static inline struct c2_confc_fetchctx * fetchctx(struct c2_sm *mach)
 {
 	C2_PRE(mach != NULL);
-	return container_of(mach, struct c2_confc_fetchctx, fc__mach);
+	return container_of(mach, struct c2_confc_fetchctx, fc_mach);
 }
 
 /** Actions to perform on entering CHECK state. */
@@ -238,12 +237,12 @@ static void on_replied(struct c2_rpc_item *item)
 {
 	struct c2_fop *fop = container_of(item, struct c2_fop, f_item);
 	struct c2_confc_fetchctx *ctx =
-		container_of(fop, struct c2_confc_fetchctx, fc__fop);
+		container_of(fop, struct c2_confc_fetchctx, fc_fop);
 
 	if (item->ri_error == 0)
-		ast_state_set(&ctx->fc__ast, S_GROW_CACHE);
+		ast_state_set(&ctx->fc_ast, S_GROW_CACHE);
 	else
-		ast_fail(&ctx->fc__ast, item->ri_error);
+		ast_fail(&ctx->fc_ast, item->ri_error);
 }
 
 /** Actions to perform on entering WAIT_REPLY state. */
@@ -251,7 +250,7 @@ static void wait_reply_st_in(struct c2_sm *mach)
 {
 	int rc;
 	struct c2_confc_fetchctx *ctx = fetchctx(mach);
-	const struct c2_confop_fetch *fop_data = c2_fop_data(&ctx->fc__fop);
+	const struct c2_confop_fetch *fop_data = c2_fop_data(&ctx->fc_fop);
 	/* XXX fop data must be set beforehand (see test_fop_encdec()
 	 * in xcode/ut/xcode_fop_test.c). */
 
@@ -259,9 +258,9 @@ static void wait_reply_st_in(struct c2_sm *mach)
 	       && fop_data->ff_origin.o_objkey.fb_data != NULL);
 
 	/* XXX c2_rpc_item need to be initialized properly. */
-	C2_ASSERT(ctx->fc__fop.f_item.ri_ops != NULL &&
-		  ctx->fc__fop.f_item.ri_ops->rio_replied == on_replied);
-	rc = c2_rpc_post(&ctx->fc__fop.f_item);
+	C2_ASSERT(ctx->fc_fop.f_item.ri_ops != NULL &&
+		  ctx->fc_fop.f_item.ri_ops->rio_replied == on_replied);
+	rc = c2_rpc_post(&ctx->fc_fop.f_item);
 	C2_ASSERT(rc == 0); /* c2_rpc_post() always returns 0, but hey */
 }
 
@@ -270,7 +269,7 @@ static void grow_cache_st_in(struct c2_sm *mach)
 {
 	struct c2_fop            *fop;
 	struct c2_confc_fetchctx *ctx  = fetchctx(mach);
-	struct c2_rpc_item       *item = &ctx->fc__fop.f_item;
+	struct c2_rpc_item       *item = &ctx->fc_fop.f_item;
 
 	C2_PRE(item->ri_error == 0 && item->ri_reply != NULL);
 	fop = container_of(item, struct c2_fop, f_item);
@@ -287,14 +286,14 @@ static void complete(struct c2_sm *mach)
 static bool failure_st_invariant(const struct c2_sm *mach)
 {
 	const struct c2_confc_fetchctx *ctx =
-		container_of(mach, const struct c2_confc_fetchctx, fc__mach);
-	return ctx->fc_result == NULL && ctx->fc__mach.sm_rc < 0;
+		container_of(mach, const struct c2_confc_fetchctx, fc_mach);
+	return ctx->fc_result == NULL && ctx->fc_mach.sm_rc < 0;
 }
 
 static bool terminal_st_invariant(const struct c2_sm *mach)
 {
 	const struct c2_confc_fetchctx *ctx =
-		container_of(mach, const struct c2_confc_fetchctx, fc__mach);
+		container_of(mach, const struct c2_confc_fetchctx, fc_mach);
 	return mach->sm_rc == 0 && ctx->fc_result != NULL;
 }
 
@@ -369,19 +368,19 @@ int c2_confc_open(struct c2_confc_fetchctx *ctx,
 		  const struct c2_conf_pathcomp *path,
 		  size_t path_len)
 {
-	C2_PRE(ctx->fc__path.p_comps == NULL);
+	C2_PRE(ctx->fc_path.p_comps == NULL);
 
-	ctx->fc__path.p_origin = path_origin;
-	ctx->fc__path.p_len    = path_len;
-	ctx->fc__path.p_comps  = c2_conf_pathcomp_dup(path, path_len);
-	if (ctx->fc__path.p_comps == NULL)
+	ctx->fc_path.p_origin = path_origin;
+	ctx->fc_path.p_len    = path_len;
+	ctx->fc_path.p_comps  = c2_conf_pathcomp_dup(path, path_len);
+	if (ctx->fc_path.p_comps == NULL)
 		return -ENOMEM;
-	C2_ASSERT(c2_conf_path_invariant(&ctx->fc__path));
+	C2_ASSERT(c2_conf_path_invariant(&ctx->fc_path));
 
-	if (c2_conf_path_is_dir(&ctx->fc__path))
+	if (c2_conf_path_is_dir(&ctx->fc_path))
 		return -EISDIR;
 
-	ast_state_set(&ctx->fc__ast, S_CHECK);
+	ast_state_set(&ctx->fc_ast, S_CHECK);
 	return 0;
 }
 C2_EXPORTED(c2_confc_open);
@@ -395,7 +394,7 @@ void * c2_confc_open_sync(const struct c2_conf_path *path)
 	c2_confc_fetchctx_init(&ctx);
 	rc = c2_confc_open(path, &ctx);
 	if (rc == 0) {
-		rc = c2_sm_timedwait(&ctx.fc__mach, S_TERMINAL | S_FAILURE,
+		rc = c2_sm_timedwait(&ctx.fc_mach, S_TERMINAL | S_FAILURE,
 				     C2_TIME_NEVER);
 		C2_ASSERT(rc == 0);
 		ret = ctx.fc_result;
diff --git a/conf/confc.h b/conf/confc.h
index ee489bb..eaa0d83 100644
--- a/conf/confc.h
+++ b/conf/confc.h
@@ -163,7 +163,7 @@ void c2_confc_fini(void);
 /** Configuration retrieval context. */
 struct c2_confc_fetchctx {
 	/** This channel is signaled when the retrieval operation completes. */
-	struct c2_chan fc_complete;
+	struct c2_chan      fc_complete;
 
 	/**
 	 * Pointer to the requested configuration object or directory.
@@ -179,32 +179,32 @@ struct c2_confc_fetchctx {
 	 * It is also NULL if configuration retrieval failed (see
 	 * c2_confc_error()).
 	 */
-	void          *fc_result;
+	void               *fc_result;
 
 	/* -------------------------------------------------------------
-	 * The remaining fields (fc__*) are used by confc implementation.
-	 * They are not supposed to be accessed by configuration consumers.
+	 * The remaining fields are used by confc implementation and
+	 * are not supposed to be accessed by configuration consumers.
 	 */
 
 	/** A confc state machine. */
-	struct c2_sm               fc__mach;
+	struct c2_sm        fc_mach;
 
-	struct c2_sm_ast           fc__ast;
+	struct c2_sm_ast    fc_ast;
 
 	/**
 	 * Path to the requested object or directory (directory is a
 	 * collection of objects).
 	 */
-	struct c2_conf_path        fc__path;
+	struct c2_conf_path fc_path;
 
-	struct c2_fop              fc__fop;
+	struct c2_fop       fc_fop;
 
 	/**
 	 * Record of interest in "object unpinned" events.
 	 *
 	 * This clink gets added to c2_conf_obj::co_chan channel.
 	 */
-	struct c2_clink            fc__clink;
+	struct c2_clink     fc_clink;
 };
 
 void c2_confc_fetchctx_init(struct c2_confc_fetchctx *ctx);
@@ -213,8 +213,8 @@ void c2_confc_fetchctx_fini(struct c2_confc_fetchctx *ctx);
 /** Returns the error status for the asynchronous configuration request. */
 static inline int32_t c2_confc_error(const struct c2_confc_fetchctx *ctx)
 {
-	C2_PRE(ctx->fc__mach.sm_rc <= 0);
-	return -ctx->fc__mach.sm_rc;
+	C2_PRE(ctx->fc_mach.sm_rc <= 0);
+	return -ctx->fc_mach.sm_rc;
 }
 
 /**
diff --git a/conf/ut/confc.c b/conf/ut/confc.c
index 22fe766..bac8ebf 100644
--- a/conf/ut/confc.c
+++ b/conf/ut/confc.c
@@ -95,24 +95,24 @@ static void test_fetchctx(void)
 	c2_confc_fetchctx_init(&ctx);
 
 	C2_UT_ASSERT(ctx.fc_result         == NULL);
-	C2_UT_ASSERT(ctx.fc__mach.sm_grp   == &g_grp);
-	C2_UT_ASSERT(ctx.fc__mach.sm_state == S_INITIAL);
+	C2_UT_ASSERT(ctx.fc_mach.sm_grp   == &g_grp);
+	C2_UT_ASSERT(ctx.fc_mach.sm_state == S_INITIAL);
 	C2_UT_ASSERT(c2_confc_error(&ctx)  == 0);
 
-	C2_UT_ASSERT(ctx.fc__path.p_origin == NULL);
-	C2_UT_ASSERT(ctx.fc__path.p_len    == 0);
-	C2_UT_ASSERT(ctx.fc__path.p_comps  == NULL);
+	C2_UT_ASSERT(ctx.fc_path.p_origin == NULL);
+	C2_UT_ASSERT(ctx.fc_path.p_len    == 0);
+	C2_UT_ASSERT(ctx.fc_path.p_comps  == NULL);
 
-	C2_UT_ASSERT(ctx.fc__ast.sa_cb     == NULL);
-	C2_UT_ASSERT(ctx.fc__ast.sa_datum  == NULL);
-	C2_UT_ASSERT(ctx.fc__ast.sa_next   == NULL);
+	C2_UT_ASSERT(ctx.fc_ast.sa_cb     == NULL);
+	C2_UT_ASSERT(ctx.fc_ast.sa_datum  == NULL);
+	C2_UT_ASSERT(ctx.fc_ast.sa_next   == NULL);
 	/* XXX ctx.fc_complete is not tested. Should it be? */
 
 	/* c2_sm_ast::sa_mach is not used; c2_sm is accessed via
-	 * container_of()->fc__mach */
-	C2_UT_ASSERT(ctx.fc__ast.sa_mach == NULL);
+	 * container_of()->fc_mach */
+	C2_UT_ASSERT(ctx.fc_ast.sa_mach == NULL);
 
-	C2_UT_ASSERT(ctx->fc__fop.f_data.fd_data == NULL);
+	C2_UT_ASSERT(ctx->fc_fop.f_data.fd_data == NULL);
 }
 
 static void test_path_status(void)
@@ -120,9 +120,9 @@ static void test_path_status(void)
 	c2_mutex_lock(&confc_cache.cc_sm_group->s_lock);
 	/* XXX
 	 * Call path_status(ctx, &status) with different paths
-	 * (ctx->fc__path) and ensure that:
+	 * (ctx->fc_path) and ensure that:
 	 * - if all of the needed objects are cached:
-	 *   - if c2_conf_path_is_directory(&ctx->fc__path):
+	 *   - if c2_conf_path_is_directory(&ctx->fc_path):
 	 *      - ctx->fc_result points to a c2_confc_dir with
 	 *        ->d_parent of proper identity (type and key), null
 	 *        ->d_current, and proper ->d_descr;
@@ -149,7 +149,7 @@ static void test_open(void)
 	 * - `path2' ends with a one-to-one downlink.
 	 *   - Assert c2_confc_open(path2, ctx) returns 0.
 	 *   - Assert g_grp.s_forkq != NULL. (NB a race condition)
-	 *   - Assert ctx->fc__path is equal to path2.
+	 *   - Assert ctx->fc_path is equal to path2.
 	 */
 	C2_UT_FAIL("XXX not implemented");
 }
-- 
1.8.3.2

