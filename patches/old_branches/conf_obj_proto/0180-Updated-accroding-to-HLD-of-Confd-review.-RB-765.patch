From 4a9a4e66316a131f4cc91c90d105c4d766f4a2a4 Mon Sep 17 00:00:00 2001
From: Anatoliy Bilenko <anatoliy_bilenko@xyratex.com>
Date: Tue, 15 May 2012 18:25:56 +0300
Subject: [PATCH 180/370] Updated accroding to HLD of Confd review. RB-765.

---
 conf/confd.c | 186 +++++++++++++++++++++++------------------------------------
 conf/confd.h |  60 +++++++++----------
 2 files changed, 102 insertions(+), 144 deletions(-)

diff --git a/conf/confd.c b/conf/confd.c
index 2e1a4d9..969b89b 100644
--- a/conf/confd.c
+++ b/conf/confd.c
@@ -113,69 +113,18 @@
  * @code
  * conf_cache_preload (...)
  * {
- *   struct c2_dbenv db;
- *   struct c2_table t_prof, t_serv, t_fs, t_nic, t_part, t_dev, t_node;
- *   struct c2_db_cursor c_prof, c_serv, c_fs, c_nic, c_part, c_dev, c_node;
- *   struct c2_db_pair p_prof, p_serv, p_fs, p_nic, p_part, p_dev, p_node;
- *   int result;
- *
- *   result = c2_dbenv_init(db, "configuration.db", 0);
- *   C2_UT_ASSERT(result == 0);
- *
- *   result = c2_db_tx_init(tx, db, 0);
- *   C2_UT_ASSERT(result == 0);
- *
- *   result =
- *     c2_table_init(t_prof, db, "profiles", 0, &test_table_ops) ?:
- *     c2_table_init(t_serv, db, "services", 0, &test_table_ops) ?:
- *     c2_table_init(t_fs, db, "file_systems", 0, &test_table_ops) ?:
- *     c2_table_init(t_nic, db, "nics", 0, &test_table_ops) ?:
- *     c2_table_init(t_part, db, "storage_device_partitions", 0, &test_table_ops) ?:
- *     c2_table_init(t_dev, db, "storage_devices", 0, &test_table_ops) ?:
- *     c2_table_init(t_node, db, "nodes", 0, &test_table_ops);
- *
- *   C2_ASSERT(result == 0);
- *
- *   result =
- *   c2_db_cursor_init(&c_prof, &t_prof, &tx, 0) ?:
- *   c2_db_cursor_init(&c_serv, &t_serv, &tx, 0) ?:
- *   c2_db_cursor_init(&c_fs, &t_fs, &tx, 0) ?:
- *   c2_db_cursor_init(&c_nic, &t_nic, &tx, 0) ?:
- *   c2_db_cursor_init(&c_part, &t_part, &tx, 0) ?:
- *   c2_db_cursor_init(&c_dev, &t_dev, &tx, 0) ?:
- *   c2_db_cursor_init(&c_node, &t_node, &tx, 0);
- *
- *   C2_ASSERT(result == 0);
- *
- *  /* load values from "profiles" table * /
- *  while(c2_db_cursor_next(&c_prof, &p_prof) != -ENOENT) {
- *     ... allocate and fill struct c2_conf_profile from p_prof
- *  }
- *  /* load values from "file_systems" table * /
- *  while(c2_db_cursor_next(&c_fs, &p_fs) != -ENOENT) {
- *     ... allocate and fill struct c2_conf_filesystem from p_fs
- *     ... create DAG struct c2_conf_relation to profile conf-objects ...
- *  }
- *  /* load values from "services" table * /
- *  while(c2_db_cursor_next(&c_serv, &p_serv) != -ENOENT) {
- *     ... allocate and fill struct c2_conf_service from p_fs
- *     ... create DAG struct c2_conf_relation to file system conf-objects ...
- *  }
- *  /* load values from "nodes" table * /
- *  while(c2_db_cursor_next(&c_node, &p_node) != -ENOENT) {
- *     ... allocate and fill struct c2_conf_node from p_node
- *     ... create DAG struct c2_conf_relation to services conf-objects ...
- *  }
- *  /* load values from "nics" table * /
- *  while(c2_db_cursor_next(&c_nics, &p_nic) != -ENOENT) {
- *     ... allocate and fill struct c2_conf_nic from p_nic
- *     ... create DAG struct c2_conf_relation to node conf-objects ...
- *  }
- *  /* load values from "storage_devices" table * /
- *  while(c2_db_cursor_next(&c_dev, &p_dev) != -ENOENT) {
- *     ... allocate and fill struct c2_conf_sdev from p_dev
- *     ... create DAG struct c2_conf_relation to node conf-objects ...
- *  }
+ *    for each record in the "profiles" table do
+ *      ... allocate and fill struct c2_conf_profile from p_prof
+ *    endfor
+ *
+ *    for table in "file_systems", "services",
+ *              "nodes", "nics", "storage_devices",
+ *	        in the order specified, do
+ *       for each record in the table, do
+ *         ... allocate and fill struct c2_conf_obj ...
+ *         ... create DAG struct c2_conf_relation to appropriate conf object ...
+ *       endfor
+ *    end for
  * }
  * @endcode
  *
@@ -197,25 +146,30 @@
  * @endcode
  *
  * Request handler triggers user-defined functions to create FOMs for
- * processed FOPs. User has to define FOM-initialization functions
- * for each FOP treated as a request. To do so, the following
- * structures and functions have to be defined:
+ * processed FOPs. Service has to register FOM-initialization functions
+ * for each FOP treated as a request:
+ *   - c2_conf_fetch;
+ *   - c2_conf_update;
+ *   - c2_conf_stat.
+ *
+ * To do so, the appropriate structures and functions have to be
+ * defined. For example the following used by c2_conf_fetch FOP:
  *
  * @code
- * static const struct c2_fom_type_ops c2_XYZ_type_ops = {
- *	.fto_create = XYZ_fop_fom_create
+ * static const struct c2_fom_type_ops fom_fetch_type_ops = {
+ *       .fto_create = fetch_fop_fom_create
  * };
  *
- * struct c2_fom_type c2_fom_ping_mopt = {
- *       .ft_ops = &c2_fom_fop_type_ops
+ * struct c2_fom_type c2_fom_fetch_mopt = {
+ *       .ft_ops = &fom_fetch_type_ops
  * };
  *
- * int XYZ_fop_fom_create(struct c2_fop *fop, struct c2_fom **m)
- *   {
+ * static int fetch_fop_fom_create(struct c2_fop *fop, struct c2_fom **m)
+ * {
  *    1) allocate fom;
- *    2) c2_fom_init(fom, &c2_fom_ping_mopt, &c2_fom_ping_ops, fop, NULL);
+ *    2) c2_fom_init(fom, &c2_fom_ping_mopt, &fom_fetch_type_ops, fop, NULL);
  *    3) *m = fom;
- *  }
+ * }
  * @endcode
  *
  * The implementation of c2_fom_fetch_state() needs the following
@@ -245,22 +199,24 @@
  * The number of state machine instances correspond to the number of
  * FOPs being processed in confd.
  *
- *  c2_conf_fetch FOM state transition diagram:
+ * c2_conf_fetch FOM state transition diagram:
+ * @dot
  *  digraph confd_serialize_states {
- * 	node [fontsize=9];
- * 	edge [fontsize=9];
- * 	STATUS_INITIAL [style=filled, fillcolor=lightgrey];
- * 	STATUS_SERIALIZE;
- * 	STATUS_WAIT;
- * 	STATUS_TERMINATE [style=filled, fillcolor=lightgrey];
- * 	STATUS_FAILURE [style=filled, fillcolor=lightgrey];
- *
- * 	STATUS_INITIAL -> STATUS_SERIALIZE [label="c2_conf_fetch-FOP is arrived \n, next_state() == STATUS_SERIALIZE"];
- * 	STATUS_SERIALIZE -> STATUS_WAIT [label="tryrdlock(c2_confd::c_accr::ca_rwlock) != 0 || \n c2_confd::c_accr::ca_writers > 0, \n next_state() == STATUS_WAIT"];
- * 	STATUS_SERIALIZE -> STATUS_TERMINATE [label="serialization is done"];
- * 	STATUS_SERIALIZE -> STATUS_FAILURE [label="failed to lookup object \n in cache or (next_state() < 0)"];
- *  	STATUS_WAIT -> STATUS_SERIALIZE [label="tryrdlock(c2_confd::c_accr::ca_rwlock) == 0 && \n c2_confd::c_accr::ca_writers == 0, \n next_state()==STATUS_SERIALIZE"];
+ *      node [fontsize=9];
+ *      edge [fontsize=9];
+ *      STATUS_INITIAL [style=filled, fillcolor=lightgrey];
+ *      STATUS_SERIALIZE;
+ *      STATUS_WAIT;
+ *      STATUS_TERMINATE [style=filled, fillcolor=lightgrey];
+ *      STATUS_FAILURE [style=filled, fillcolor=lightgrey];
+ *
+ *      STATUS_INITIAL -> STATUS_SERIALIZE [label="c2_conf_fetch-FOP is arrived \n, next_state() == STATUS_SERIALIZE"];
+ *      STATUS_SERIALIZE -> STATUS_WAIT [label="tryrdlock(c2_confd::c_cache::ca_rwlock) != 0 || \n c2_confd::c_cache::ca_writers > 0, \n next_state() == STATUS_WAIT"];
+ *      STATUS_SERIALIZE -> STATUS_TERMINATE [label="serialization is done"];
+ *      STATUS_SERIALIZE -> STATUS_FAILURE [label="failed to lookup object \n in cache or (next_state() < 0)"];
+ *      STATUS_WAIT -> STATUS_SERIALIZE [label="tryrdlock(c2_confd::c_cache::ca_rwlock) == 0 && \n c2_confd::c_cache::ca_writers == 0, \n next_state()==STATUS_SERIALIZE"];
  *  }
+ * @enddot
  *
  * - C2_CONFD_STATUS_INITIAL:
  *   In this state, statistics values are being updated in c2_confd::c_stat.
@@ -269,17 +225,17 @@
  *
  * - C2_CONFD_STATUS_SERIALIZE:
  *   Current design assumes that data is pre-loaded into configuration
- *   cache. In current state, c2_confd::c_accr::ca_rwlock lock is
- *   being obtained as a read lock. c2_confd::c_accr::ca_writers
+ *   cache. In current state, c2_confd::c_cache::ca_rwlock lock is
+ *   being obtained as a read lock. c2_confd::c_cache::ca_writers
  *   corresponds to the number of update requests pending in the
  *   system and if this variable is greater than zero or it's
- *   impossible to obtain read lock on c2_confd::c_accr::ca_rwlock,
+ *   impossible to obtain read lock on c2_confd::c_cache::ca_rwlock,
  *   c2_conf_fetch FOM is being transited into C2_CONFD_STATUS_WAIT
  *   with next_state() call.
  *
  *   Otherwise c2_conf_fetch_resp FOP is being prepared for sending by
- *   locking c2_confd::c_accr::ca_rwlock, looking up requested path
- *   in configuration cache and unlocking c2_confd::c_accr::ca_rwlock.
+ *   locking c2_confd::c_cache::ca_rwlock, looking up requested path
+ *   in configuration cache and unlocking c2_confd::c_cache::ca_rwlock.
  *   After that, c2_conf_fetch_resp FOP is sent with c2_rpc_reply_post().
  *   next_state() transits FOM into C2_CONFD_STATUS_TERMINATE.
  *
@@ -290,9 +246,9 @@
  *   FOM state handler should return FSO_WAIT.
  *
  * - C2_CONFD_STATUS_WAIT:
- *   In this state, c2_confd::c_accr::ca_rwlock is trying to be
+ *   In this state, c2_confd::c_cache::ca_rwlock is trying to be
  *   obtained as a read lock. If it's obtained and there's no pending
- *   update requests in the system (c2_confd::c_accr::ca_writers == 0) than
+ *   update requests in the system (c2_confd::c_cache::ca_writers == 0) than
  *   next_state() transits FOM back into C2_CONFD_STATUS_SERIALIZE. In this case
  *   FOM state handler should return FSO_WAIT to perform the transition.
  *   Otherwise FOM is being remained in current state, by returning FSO_AGAIN.
@@ -309,21 +265,23 @@
  *   FOM state handler should return FSO_WAIT.
  *
  *  c2_conf_update FOM state transition diagram:
+ * @dot
  *  digraph confd_udpate_states {
- * 	node [fontsize=9];
- * 	edge [fontsize=9];
- * 	STATUS_INITIAL [style=filled, fillcolor=lightgrey];
- * 	STATUS_UPDATE;
- * 	STATUS_WAIT;
- * 	STATUS_TERMINATE [style=filled, fillcolor=lightgrey];
- * 	STATUS_FAILURE [style=filled, fillcolor=lightgrey];
- *
- * 	STATUS_INITIAL -> STATUS_UPDATE [label="c2_conf_update-FOP is arrived \n, next_state() == STATUS_UPDATE"];
- * 	STATUS_UPDATE -> STATUS_WAIT [label="trywrlock(c2_confd::c_accr::ca_rwlock) != 0, \n next_state() == STATUS_WAIT, \n c2_atomic64_inc(c2_confd::c_accr::ca_writers)"];
- * 	STATUS_UPDATE -> STATUS_TERMINATE [label="update is done"];
- * 	STATUS_UPDATE -> STATUS_FAILURE [label="failed to update object \n in cache or (next_state() < 0)"];
- *  	STATUS_WAIT -> STATUS_UPDATE [label="trywrlock(c2_confd::c_accr::ca_rwlock) == 0, \n next_state()==STATUS_UPDATE, \n c2_atomic64_dec(c2_confd::c_accr::ca_writers)"];
+ *      node [fontsize=9];
+ *      edge [fontsize=9];
+ *      STATUS_INITIAL [style=filled, fillcolor=lightgrey];
+ *      STATUS_UPDATE;
+ *      STATUS_WAIT;
+ *      STATUS_TERMINATE [style=filled, fillcolor=lightgrey];
+ *      STATUS_FAILURE [style=filled, fillcolor=lightgrey];
+ *
+ *      STATUS_INITIAL -> STATUS_UPDATE [label="c2_conf_update-FOP is arrived \n, next_state() == STATUS_UPDATE"];
+ *      STATUS_UPDATE -> STATUS_WAIT [label="trywrlock(c2_confd::c_cache::ca_rwlock) != 0, \n next_state() == STATUS_WAIT, \n c2_atomic64_inc(c2_confd::c_cache::ca_writers)"];
+ *      STATUS_UPDATE -> STATUS_TERMINATE [label="update is done"];
+ *      STATUS_UPDATE -> STATUS_FAILURE [label="failed to update object \n in cache or (next_state() < 0)"];
+ *      STATUS_WAIT -> STATUS_UPDATE [label="trywrlock(c2_confd::c_cache::ca_rwlock) == 0, \n next_state()==STATUS_UPDATE, \n c2_atomic64_dec(c2_confd::c_cache::ca_writers)"];
  *  }
+ * @enddot
  *
  * - C2_CONFD_STATUS_INITIAL:
  *   In this state, statistics values are being updated in c2_confd::c_stat.
@@ -332,13 +290,13 @@
  *
  * - C2_CONFD_STATUS_UPDATE:
 
- *   In current state, c2_confd::c_accr::ca_rwlock lock is being
+ *   In current state, c2_confd::c_cache::ca_rwlock lock is being
  *   obtained as a write lock. If it's already locked, pending update
- *   requests count c2_confd::c_accr::ca_writers should be
+ *   requests count c2_confd::c_cache::ca_writers should be
  *   incremented. In this case, next_state() is called and FOM is
  *   transited into C2_CONFD_STATUS_WAIT state.
  *
- *   Otherwise configuration c2_confd::c_accr::ca_rwlock is being
+ *   Otherwise configuration c2_confd::c_cache::ca_rwlock is being
  *   locked as a write lock, cache is being updated with new
  *   configuration values from c2_conf_update FOP and ca_rwlock is
  *   being unlocked.  After that, c2_conf_update_resp FOP is sent with
@@ -348,7 +306,7 @@
  *
  * - C2_CONFD_STATUS_WAIT:
  *   c2_confd_update FOM remains in current state until
- *   c2_confd::c_accr::ca_rwlock is obtained for writing.
+ *   c2_confd::c_cache::ca_rwlock is obtained for writing.
  *   FOM state handler should return FSO_WAIT if lock is obtained and
  *   FSO_AGAIN otherwise.
  *
@@ -387,7 +345,7 @@
  * synchronized. Assuming that access to db and cache, while adding
  * configuration values to cache, is done at the same time and
  * workload of confd is predominantly read-only, so simplistic
- * synchronization is enough (c2_confd::c_accr::ca_lock).
+ * synchronization is enough (c2_confd::c_cache::ca_lock).
  *
  * <hr> <!------------------------------------------------------------->
  * @subsection confd-lspec-numa NUMA Optimizations
@@ -626,7 +584,7 @@ static int next_state(struct c2_confd *confd, enum c2_confd_status st)
 
 /**
  * Loads confd::c_root of the DAG of configuration objects
- * from configuration db, or confd::c_accr::ca_map cache if mapping exists.
+ * from configuration db, or confd::c_cache::ca_map cache if mapping exists.
  *
  * @param confd	configuration service instance.
  */
diff --git a/conf/confd.h b/conf/confd.h
index 4042108..25e211e 100644
--- a/conf/confd.h
+++ b/conf/confd.h
@@ -33,7 +33,7 @@
  * @page confd-fspec Configuration Service (confd)
  *
  * Configuration service library (confd) is designed to work as a part
- * of user-space configuration service based on request handler logic
+ * of user-space configuration service, animated by request handler
  * and provides a "FOP-based" interface for accessing Colibri
  * configuration information stored in configuration db. Confd is run
  * within the context of a request handler launched by the
@@ -52,15 +52,16 @@
  *
  * <hr> <!------------------------------------------------------------>
  * @section confd-fspec-data Data Structures
- * - c2_reqh_confd_service --- represents configuration service instace
+ * - c2_reqh_confd_service --- represents configuration service instance
  *   registered in request handler.
  *
  * - c2_confd --- represents configuration service data, stores
- *   structures to perform caching, accessing to configuration db,
- *   request handling.
+ *   structures to perform caching, accesses to configuration db
+ *   and handles configuration data requests.
+ *
+ * - c2_confd_cache -- represents an efficient, high concurrency,
+ *   in-memory cache over the underlying database.
  *
- * - c2_confd_conf_accessor --- represents data structures related to
- *   efficient configuration data access.
  *   Members:
  *   - @c ca_db is a database environment to access configuration db.
  *   - @c ca_cache is a registry of cached configuration objects.
@@ -70,13 +71,25 @@
  * retrieved from the configuration db. Defining FOPs for
  * configuration requests and replies requires the use of the RPC
  * layer as a transport. Services have to register c2_fop_types for
- * each FOP they support. The following types have to be defined:
- * - c2_fop_type_format - defines format registed in *.ff used in confd
- * - c2_fom_type - defines FOM operation vector provided by user to
- *   hadle operations such as initialization and state transitions of
- *   FOM.
- * - c2_fop_type_ops - defines FOP operation vector.
- * - c2_rpc_item_type - defines RPC item type for given fop.
+ * each FOP they support.
+ * The following FOPs are defined for confd (onwire.ff):
+ * - c2_conf_fetch --- configuration request;
+ * - c2_conf_fetch_resp --- Confd's response to c2_conf_fetch;
+ * - c2_conf_update --- Update request;
+ * - c2_conf_update_resp --- Confd's response to c2_conf_update;
+ * - c2_conf_stat --- Statistics request;
+ * - c2_conf_stat_resp --- Confd's response to c2_conf_stat.
+ *
+ * For each FOP, FOP format, FOP operation vector, FOP types, RPC item
+ * types have to be defined. The following structures have to be
+ * defined for c2_conf_fetch FOP:
+ * - struct c2_fop_type_format c2_conf_fetch_tfmt --- defines format
+ *   registed in *.ff used in confd;
+ * - struct c2_fop_type c2_conf_fetch_fopt --- defines FOP type;
+ * - struct c2_fop_type_ops c2_conf_fetch_ops --- defines FOP
+ *   operation vector;
+ * - struct c2_rpc_item_type c2_rpc_item_type_fetch --- defines RPC
+ *   item type for given fop.
  *
  * FOPs used in configuration service are defined in @ref confd_fop_dfspec .
  *
@@ -89,22 +102,9 @@
  * <!------------------------------------------------------------------>
  * @subsection confd-fspec-sub-setup Initialization and termination
  *
- * Before confd is started, @ref colibri_setup calls c2_cs_setup_env()
- * function to initialize corresponding request handler, network
- * transport, stob file for request handler context and to specifiy an
- * endpoint to which clients connect.
- *
- * To parametrize colibri_setup the following options are provided:
- *  - Prefered network transport structure and the name of RPC server
- *    used by confd;
- *  - Request handler context;
- *  - Type of reqh storage;
- *  - Database file used by reqh;
- *  - STOB file for reqh context;
- *  - Network layer endpoint to which clients connect.
- *
  * To parametrize confd, user should provide the following arguments:
  *  - path to configuration db, where configuration values are stored.
+ *  - name of configuration service instance.
  *
  * Confd is initiated and put into operation by request handler logic,
  * after colibri is started. Confd service should be registered in
@@ -169,14 +169,14 @@
  */
 
 /** Configuration data accessor. */
-struct c2_confd_conf_accessor {
+struct c2_confd_cache {
 	/** Database path */
 	const char	       *ca_dbpath;
 	/** Database environment */
 	struct c2_dbenv		ca_db;
 	/** Registry of cached configuration objects */
 	struct c2_conf_map	ca_cache;
-	/** Keeps track of c2_confd_conf_accessor usage */
+	/** Keeps track of c2_confd_cache usage */
 	struct c2_ref		ca_ref;
 	/** Tracks number of threads which are going to update ca_cache */
 	struct c2_atomic64      ca_writers;
@@ -211,7 +211,7 @@ struct c2_confd_stat {
 /** Configuration service data. */
 struct c2_confd {
 	struct c2_addb_ctx		c_addb;
-	struct c2_confd_conf_accessor  *c_accr;
+	struct c2_confd_cache	       *c_cache;
 	struct c2_confd_stat		c_stat;
 };
 
-- 
1.8.3.2

