From baf4aae5f8fc698ad95139acddb6b673a5653948 Mon Sep 17 00:00:00 2001
From: "Valery V. Vorotyntsev" <valery_vorotyntsev@xyratex.com>
Date: Tue, 28 Aug 2012 15:53:49 +0300
Subject: [PATCH 332/370] conf: use c2_buf instead of c2_conf_buf

+ Delete conf/buf.[hc] files --- they are not needed any more.
---
 conf/buf.c      | 43 ----------------------------
 conf/buf.h      | 47 -------------------------------
 conf/conf_fop.c |  1 -
 conf/confc.c    | 14 ++++------
 conf/confc.h    | 87 ++++++++++++++++++++++++++++-----------------------------
 conf/obj.c      | 11 --------
 conf/obj.h      |  5 ++--
 conf/obj_ops.c  | 85 +++++++++++++++++++++++++++----------------------------
 conf/obj_ops.h  |  7 ++---
 conf/onwire.h   | 64 ++++++++++++++++++------------------------
 conf/preload.h  |  6 ++--
 11 files changed, 124 insertions(+), 246 deletions(-)
 delete mode 100644 conf/buf.c
 delete mode 100644 conf/buf.h

diff --git a/conf/buf.c b/conf/buf.c
deleted file mode 100644
index ec91cf7..0000000
--- a/conf/buf.c
+++ /dev/null
@@ -1,43 +0,0 @@
-/* -*- c -*- */
-/*
- * COPYRIGHT 2012 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Valery V. Vorotyntsev <valery_vorotyntsev@xyratex.com>
- * Original creation date: 08-Mar-2012
- */
-
-#ifdef HAVE_CONFIG_H
-#  include "config.h"
-#endif
-#include "conf/buf.h"
-#include "lib/memory.h"  /* c2_alloc */
-
-bool c2_conf_buf_eq(const struct c2_conf_buf *x, const struct c2_conf_buf *y)
-{
-	return x->cb_size == y->cb_size &&
-		memcmp(x->cb_data, y->cb_data, x->cb_size) == 0;
-}
-
-int c2_conf_buf_copy(struct c2_conf_buf *dest, const struct c2_conf_buf *src)
-{
-	C2_PRE(dest->cb_size == 0 && dest->cb_data == NULL);
-	C2_ALLOC_ARR(dest->cb_data, src->cb_size);
-	if (dest->cb_data == NULL)
-		return -ENOMEM;
-	dest->cb_size = src->cb_size;
-	memcpy(dest->cb_data, src->cb_data, src->cb_size);
-	C2_POST(c2_conf_buf_eq(dest, src));
-	return 0;
-}
diff --git a/conf/buf.h b/conf/buf.h
deleted file mode 100644
index 6141737..0000000
--- a/conf/buf.h
+++ /dev/null
@@ -1,47 +0,0 @@
-/* -*- c -*- */
-/*
- * COPYRIGHT 2012 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Valery V. Vorotyntsev <valery_vorotyntsev@xyratex.com>
- * Original creation date: 08-Mar-2012
- */
-#ifndef __COLIBRI_CONF_BUF_H__
-#define __COLIBRI_CONF_BUF_H__
-
-#include "conf/onwire.h" /* c2_conf_buf */
-#include "lib/misc.h"    /* strlen */
-
-/*
- * Initialisers for struct c2_conf_buf.
- *
- * c2_conf_buf is defined in onwire.ff, but C2_CONF_BUF_INIT() cannot
- * be defined there --- fop/fop2c would skip such a definition.
- */
-#define C2_CONF_BUF_INIT(size, data) { .cb_size = (size), .cb_data = (data) }
-#define C2_CONF_BUF_INITS(str)       C2_CONF_BUF_INIT(strlen(str), (str))
-#define C2_CONF_BUF_INIT0            C2_CONF_BUF_INIT(0, NULL)
-
-/** Returns true iff two buffers are equal. */
-bool c2_conf_buf_eq(const struct c2_conf_buf *x, const struct c2_conf_buf *y);
-
-/**
- * Copies a buffer.
- *
- * @pre   dest->cb_size == 0 && dest->cb_data == NULL
- * @post  ergo(result == 0, c2_conf_buf_eq(dest, src))
- */
-int c2_conf_buf_copy(struct c2_conf_buf *dest, const struct c2_conf_buf *src);
-
-#endif /* __COLIBRI_CONF_BUF_H__ */
diff --git a/conf/conf_fop.c b/conf/conf_fop.c
index 04853f5..bb2c508 100644
--- a/conf/conf_fop.c
+++ b/conf/conf_fop.c
@@ -81,7 +81,6 @@ C2_FOP_TYPE_DECLARE(c2_conf_update_resp, "update fop reply", &c2_conf_update_res
 		    C2_RPC_UPDATE_REPLY_OPCODE, C2_RPC_ITEM_TYPE_REPLY);
 
 static struct c2_fop_type_format *fmts[] = {
-	&c2_conf_buf_tfmt,
 	&arr_u64_tfmt,
 	&arr_buf_tfmt,
 	&arr_pathcomp_tfmt,
diff --git a/conf/confc.c b/conf/confc.c
index 766e862..62d22f2 100644
--- a/conf/confc.c
+++ b/conf/confc.c
@@ -279,8 +279,7 @@ static int cache_preload(struct c2_confc *confc, const char *conf_str);
 static bool confc_invariant(const struct c2_confc *confc);
 
 int c2_confc_init(struct c2_confc *confc, const char *conf_source,
-		  const struct c2_conf_buf *profile,
-		  struct c2_sm_group *sm_group)
+		  const struct c2_buf *profile, struct c2_sm_group *sm_group)
 {
 	/*
 	 * int rc;
@@ -449,7 +448,7 @@ struct c2_conf_obj *c2_confc_ctx_result(struct c2_confc_ctx *ctx)
 static void ast_state_set(struct c2_sm_ast *ast, enum confc_ctx_state state);
 
 int c2_confc__open(struct c2_confc_ctx *ctx, struct c2_conf_obj *origin,
-		   const struct c2_conf_buf path[])
+		   const struct c2_buf path[])
 {
 	C2_PRE(ctx_invariant(ctx));
 	C2_PRE(ergo(origin != NULL, origin->co_confc == ctx->fc_confc));
@@ -474,7 +473,7 @@ static bool sm_filter(struct c2_clink *link)
 }
 
 int c2_confc__open_sync(struct c2_conf_obj **result, struct c2_conf_obj *origin,
-			const struct c2_conf_buf path[])
+			const struct c2_buf path[])
 {
 	struct sm_waiter w;
 	int              rc;
@@ -1027,8 +1026,7 @@ cache_grow(struct c2_conf_reg *reg, const struct c2_conf_fetch_resp *resp)
 	 * confc_lock(confc);
 	 *
 	 * for (onwire in resp->fr_data) {
-	 *     if (onwire->o_id.cb_size == 0 ||
-	 *         onwire->o_id.cb_data == NULL) {
+	 *     if (onwire->o_id.b_nob == 0 || onwire->o_id.b_addr == NULL) {
 	 *         C2_ADDB_ADD(report bogus data);
 	 *         ret = -Exxx;
 	 *         break;
@@ -1084,8 +1082,8 @@ static void confd_disconnect(struct c2_rpc_client_ctx *rpc)
 static bool request_is_valid(const struct c2_conf_fetch *req)
 {
 	return  req->f_origin.oi_type < C2_CO_NR &&
-		req->f_origin.oi_id.cb_size > 0 &&
-		req->f_origin.oi_id.cb_data != NULL &&
+		req->f_origin.oi_id.b_nob > 0 &&
+		req->f_origin.oi_id.b_addr != NULL &&
 		equi(req->f_path.ab_count == 0, req->f_path.ab_elems == NULL);
 }
 
diff --git a/conf/confc.h b/conf/confc.h
index 2c17152..70e6fcd 100644
--- a/conf/confc.h
+++ b/conf/confc.h
@@ -20,12 +20,11 @@
 #ifndef __COLIBRI_CONF_CONFC_H__
 #define __COLIBRI_CONF_CONFC_H__
 
-#include "conf/onwire.h" /* c2_conf_buf, c2_conf_fetch */
-#include "conf/reg.h"    /* c2_conf_reg */
-#include "conf/buf.h"    /* C2_CONF_BUF_INIT0 */
-#include "sm/sm.h"       /* c2_sm, c2_sm_ast */
-#include "lib/mutex.h"   /* c2_mutex */
-#include "fop/fop.h"     /* c2_fop */
+#include "conf/reg.h"  /* c2_conf_reg */
+#include "lib/buf.h"   /* c2_buf, C2_BUF_INIT0 */
+#include "sm/sm.h"     /* c2_sm, c2_sm_ast */
+#include "lib/mutex.h" /* c2_mutex */
+#include "fop/fop.h"   /* c2_fop */
 
 struct c2_conf_obj;
 
@@ -110,7 +109,7 @@ struct c2_conf_obj;
  *
  * startup(const char *profile, ...)
  * {
- *         const struct c2_conf_buf prof = C2_CONF_BUF_INITS(profile);
+ *         const struct c2_buf prof = C2_BUF_INITS(profile);
  *
  *         rc = c2_confc_init(&confc, "confd-endpoint", &prof, group);
  *         ...
@@ -186,7 +185,7 @@ struct c2_conf_obj;
  *
  *         sm_waiter_init(&w, g_confc);
  *
- *         rc = c2_confc_open(&w.w_ctx, NULL, C2_CONF_BUF_INITS("filesystem"));
+ *         rc = c2_confc_open(&w.w_ctx, NULL, C2_BUF_INITS("filesystem"));
  *         if (rc == 0) {
  *                 while (!c2_confc_ctx_is_completed(&w.w_ctx))
  *                         c2_chan_wait(&w.w_clink);
@@ -205,7 +204,7 @@ struct c2_conf_obj;
  * static int filesystem_open2(struct c2_conf_filesystem **fs)
  * {
  *         return c2_confc_open_sync(fs, g_confc->cc_root,
- *                                   C2_CONF_BUF_INITS("filesystem"));
+ *                                   C2_BUF_INITS("filesystem"));
  * }
  *
  * // Filters out intermediate state transitions of c2_confc_ctx::fc_mach.
@@ -248,8 +247,8 @@ struct c2_conf_obj;
  *         int                 rc;
  *
  *         rc = c2_confc_open_sync(&dir, g_confc->cc_root,
- *                                 C2_CONF_BUF_INITS("filesystem"),
- *                                 C2_CONF_BUF_INITS("services"));
+ *                                 C2_BUF_INITS("filesystem"),
+ *                                 C2_BUF_INITS("services"));
  *         if (rc != 0)
  *                 return rc;
  *
@@ -282,30 +281,29 @@ struct c2_conf_obj;
  *
  * // Accesses configuration data of devices that are being used by
  * // specific service on specific node.
- * static int specific_devices_process(const struct c2_conf_buf *svc_id,
- *                                     const struct c2_conf_buf *node_id)
+ * static int specific_devices_process(const struct c2_buf *svc_id,
+ *                                     const struct c2_buf *node_id)
  * {
  *         struct c2_conf_obj *dir;
  *         struct c2_conf_obj *svc;
  *         int                 rc;
  *
  *         rc = c2_confc_open_sync(&dir, g_confc->cc_root,
- *                                 C2_CONF_BUF_INITS("filesystem"),
- *                                 C2_CONF_BUF_INITS("services"));
+ *                                 C2_BUF_INITS("filesystem"),
+ *                                 C2_BUF_INITS("services"));
  *         if (rc != 0)
  *                 return rc;
  *
  *         for (svc = NULL; (rc = c2_confc_readdir_sync(dir, &svc)) > 0; ) {
  *                 struct c2_conf_obj *node;
  *
- *                 if (!c2_conf_buf_eq(svc->co_id, svc_id))
+ *                 if (!c2_buf_eq(svc->co_id, svc_id))
  *                         // This is not the service we are looking for.
  *                         continue;
  *
- *                 rc = c2_confc_open_sync(&node, svc,
- *                                         C2_CONF_BUF_INITS("node"));
+ *                 rc = c2_confc_open_sync(&node, svc, C2_BUF_INITS("node"));
  *                 if (rc == 0) {
- *                         if (c2_conf_buf_eq(node->co_id, node_id))
+ *                         if (c2_buf_eq(node->co_id, node_id))
  *                                 rc = node_devices_process(node);
  *                         c2_confc_close(node);
  *                 }
@@ -333,7 +331,7 @@ struct c2_conf_obj;
  *         struct c2_conf_obj *entry;
  *         int                 rc;
  *
- *         rc = c2_confc_open_sync(&dir, node, C2_CONF_BUF_INITS("nics"));
+ *         rc = c2_confc_open_sync(&dir, node, C2_BUF_INITS("nics"));
  *         if (rc != 0)
  *                 return rc;
  *
@@ -354,7 +352,7 @@ struct c2_conf_obj;
  *         struct c2_conf_obj *entry;
  *         int                 rc;
  *
- *         rc = c2_confc_open_sync(&dir, node, C2_CONF_BUF_INITS("sdevs"));
+ *         rc = c2_confc_open_sync(&dir, node, C2_BUF_INITS("sdevs"));
  *         if (rc != 0)
  *                 return rc;
  *
@@ -524,7 +522,7 @@ struct c2_confc {
  *                     configuration cache.
  */
 int c2_confc_init(struct c2_confc *confc, const char *conf_source,
-		  const struct c2_conf_buf *profile,
+		  const struct c2_buf *profile,
 		  struct c2_sm_group *sm_group);
 
 /**
@@ -543,14 +541,14 @@ void c2_confc_fini(struct c2_confc *confc);
 /** Configuration retrieval context. */
 struct c2_confc_ctx {
 	/** The confc instance this context belongs to. */
-	struct c2_confc          *fc_confc;
+	struct c2_confc     *fc_confc;
 	/** Context state machine. */
-	struct c2_sm              fc_mach;
+	struct c2_sm         fc_mach;
 	/**
 	 * Asynchronous system trap, used by the implementation to
 	 * schedule a transition of ->fc_mach state machine.
 	 */
-	struct c2_sm_ast          fc_ast;
+	struct c2_sm_ast     fc_ast;
 	/**
 	 * Origin of the requested path.
 	 *
@@ -559,32 +557,32 @@ struct c2_confc_ctx {
 	 * measures to pin this object for the duration of path
 	 * traversal.  See the note in @ref confc-fspec-sub-use.
 	 */
-	struct c2_conf_obj       *fc_origin;
+	struct c2_conf_obj  *fc_origin;
 	/**
 	 * Path to the object requested by the application.
 	 *
 	 * It is responsibility of application's programmer to ensure
 	 * validity of the path until configuration request completes.
 	 */
-	const struct c2_conf_buf *fc_path;
+	const struct c2_buf *fc_path;
 	/** Configuration fetch request being sent to confd. */
-	struct c2_conf_fetch      fc_req;
+	struct c2_conf_fetch fc_req;
 	/** Request fop. */
-	struct c2_fop             fc_fop;
+	struct c2_fop        fc_fop;
 	/**
 	 * Record of interest in `object loading completed' or
 	 * `object unpinned' events.
 	 */
-	struct c2_clink           fc_clink;
+	struct c2_clink      fc_clink;
 	/**
 	 * Pointer to the requested configuration object.
 	 *
 	 * The application should use c2_confc_ctx_result() instead of
 	 * accessing this field directly.
 	 */
-	struct c2_conf_obj       *fc_result;
+	struct c2_conf_obj  *fc_result;
 	/** Magic number. */
-	uint64_t                  fc_magix;
+	uint64_t             fc_magix;
 };
 
 /**
@@ -644,8 +642,8 @@ struct c2_conf_obj *c2_confc_ctx_result(struct c2_confc_ctx *ctx);
  * @param ctx     Fetch context.
  * @param origin  Path origin (NULL = root configuration object).
  * @param ...     Path to the requested object. The variable arguments
- *                are c2_conf_buf initialisers (C2_CONF_BUF_INIT(),
- *                C2_CONF_BUF_INITS()); use C2_CONF_BUF_INIT0 for empty path.
+ *                are c2_buf initialisers (C2_BUF_INIT(), C2_BUF_INITS());
+ *                use C2_BUF_INIT0 for empty path.
  *
  * @note  The application must keep the data, pointed to by path
  *        arguments, intact, until configuration retrieval operation
@@ -654,11 +652,11 @@ struct c2_conf_obj *c2_confc_ctx_result(struct c2_confc_ctx *ctx);
  * @pre  ergo(origin != NULL, origin->co_confc == ctx->fc_confc)
  * @pre  ctx->fc_origin == NULL && ctx->fc_path == NULL
  */
-#define c2_confc_open(ctx, origin, ...)				       \
-	c2_confc__open((ctx), (origin), (const struct c2_conf_buf []){ \
-			__VA_ARGS__, C2_CONF_BUF_INIT0 })
+#define c2_confc_open(ctx, origin, ...)                           \
+	c2_confc__open((ctx), (origin), (const struct c2_buf []){ \
+			__VA_ARGS__, C2_BUF_INIT0 })
 int c2_confc__open(struct c2_confc_ctx *ctx, struct c2_conf_obj *origin,
-		   const struct c2_conf_buf path[]);
+		   const struct c2_buf path[]);
 
 /**
  * Opens configuration object synchronously.
@@ -673,18 +671,17 @@ int c2_confc__open(struct c2_confc_ctx *ctx, struct c2_conf_obj *origin,
  * struct c2_conf_filesystem *fs;
  * int rc;
  *
- * rc = c2_confc_open_sync(&fs, confc->cc_root,
- *                         C2_CONF_BUF_INITS("filesystem"));
+ * rc = c2_confc_open_sync(&fs, confc->cc_root, C2_BUF_INITS("filesystem"));
  * @endcode
  *
  * @see c2_confc_open() for a description of the parameters.
  */
-#define c2_confc_open_sync(result, origin, ...)             \
-	c2_confc__open_sync((result), (origin),             \
-			    (const struct c2_conf_buf []) { \
-				    __VA_ARGS__, C2_CONF_BUF_INIT0 })
+#define c2_confc_open_sync(result, origin, ...)        \
+	c2_confc__open_sync((result), (origin),        \
+			    (const struct c2_buf []) { \
+				    __VA_ARGS__, C2_BUF_INIT0 })
 int c2_confc__open_sync(struct c2_conf_obj **result, struct c2_conf_obj *origin,
-			const struct c2_conf_buf path[]);
+			const struct c2_buf path[]);
 
 /**
  * Closes configuration object opened with c2_confc_open() or
diff --git a/conf/obj.c b/conf/obj.c
index 6d72c0f..f733eef 100644
--- a/conf/obj.c
+++ b/conf/obj.c
@@ -262,8 +262,6 @@
  *
  *     @test c2_conf_parse() will be tested.
  *
- *     @test c2_conf_buf operations will be tested.
- *
  * @subsection conf-ut-confc confc Test Suite
  *
  *     Test suite's init routine will create an "ast" thread (search
@@ -391,15 +389,6 @@
  *
  * (@todo Delete this section from the DLD when the feature is landed
  * into master.)
- *
- * - c2_conf_buf should be replaced with c2_buf.
- *   This task includes:
- *   - reordering fields of c2_buf: ->b_nob, _then_ ->b_addr;
- *   - adding lib/buf.ff;
- *   - C2_BASSERT()ing in lib/misc.c that the structures, generated
- *     from lib/buf.ff, are equivalent to struct c2_buf: i.e., field
- *     sizes and field offsets are equal, so are sizes and alignments
- *     of the whole structures.
  */
 
 /**
diff --git a/conf/obj.h b/conf/obj.h
index f3015aa..c783bc3 100644
--- a/conf/obj.h
+++ b/conf/obj.h
@@ -20,11 +20,10 @@
 #ifndef __COLIBRI_CONF_OBJ_H__
 #define __COLIBRI_CONF_OBJ_H__
 
-#include "conf/onwire.h" /* c2_conf_buf */
-
 /* XXX @todo Move definitions from cfg/cfg.h to conf/schema.ff */
 #include "cfg/cfg.h"   /* c2_cfg_service_type */
 
+#include "lib/buf.h"   /* c2_buf */
 #include "lib/chan.h"  /* c2_chan */
 #include "fid/fid.h"   /* c2_fid */
 #include "lib/tlist.h" /* c2_tl, c2_tlink */
@@ -163,7 +162,7 @@ struct c2_conf_obj {
 	 * Object identifier.
 	 * This value is unique among the object of given ->co_type.
 	 */
-	struct c2_conf_buf            co_id;
+	struct c2_buf                 co_id;
 	enum c2_conf_status           co_status;
 	const struct c2_conf_obj_ops *co_ops;
 	/**
diff --git a/conf/obj_ops.c b/conf/obj_ops.c
index 4148c1e..c9e83e7 100644
--- a/conf/obj_ops.c
+++ b/conf/obj_ops.c
@@ -22,7 +22,6 @@
 #  include "config.h"
 #endif
 #include "conf/obj_ops.h"
-#include "conf/buf.h"     /* c2_conf_buf_copy, c2_conf_buf_eq */
 #include "conf/confc.h"   /* c2_confc */
 #include "lib/cdefs.h"    /* ergo, C2_MAGIX_OFFSET, IS_IN_ARRAY */
 #include "lib/arith.h"    /* C2_CNT_INC, C2_CNT_DEC */
@@ -44,7 +43,7 @@
  * ------------------------------------------------------------------ */
 
 static bool generic_obj_invariant(const void *bob);
-static bool buf_is_valid(const struct c2_conf_buf *buf);
+static bool buf_is_valid(const struct c2_buf *buf);
 
 enum {
 	CONF_GENERIC_MAGIC    = 0x33ca11ab1ed0d077,
@@ -74,7 +73,7 @@ C2_TL_DEFINE(generic_objs, static, struct c2_conf_obj);
 #define _BOB_TYPE_DEFINE(abbrev, magic)                            \
 static bool abbrev ## _invariant(const void *bob);                 \
 static int abbrev ## _lookup(struct c2_conf_obj *parent,           \
-			     const struct c2_conf_buf *name,       \
+			     const struct c2_buf *name,            \
 			     struct c2_conf_obj **out);            \
 static int abbrev ## _fill(struct c2_conf_obj *dest,               \
 			   const struct confx_object *src,         \
@@ -354,7 +353,7 @@ static bool partition_invariant(const void *bob)
  * ------------------------------------------------------------------ */
 
 struct c2_conf_obj *
-c2_conf_obj_new(enum c2_conf_objtype type, const struct c2_conf_buf *id)
+c2_conf_obj_new(enum c2_conf_objtype type, const struct c2_buf *id)
 {
 	void                  *amb; /* concrete object being allocated */
 	struct c2_conf_obj    *obj; /* embedded c2_conf_obj */
@@ -366,7 +365,7 @@ c2_conf_obj_new(enum c2_conf_objtype type, const struct c2_conf_buf *id)
 		return NULL;
 	obj = amb + ot->ot_obj_offset;
 
-	rc = c2_conf_buf_copy(&obj->co_id, id);
+	rc = c2_buf_copy(&obj->co_id, id);
 	if (rc != 0) {
 		c2_free(amb);
 		return NULL;
@@ -388,7 +387,7 @@ c2_conf_obj_new(enum c2_conf_objtype type, const struct c2_conf_buf *id)
 
 /** Finds object in the registry or creates (and registers) a stub for it. */
 static int obj_find(struct c2_conf_reg *reg, enum c2_conf_objtype type,
-		    const struct c2_conf_buf *id, struct c2_conf_obj **out)
+		    const struct c2_buf *id, struct c2_conf_obj **out)
 {
 	int rc;
 
@@ -425,9 +424,9 @@ static int obj_find(struct c2_conf_reg *reg, enum c2_conf_objtype type,
  *
  * XXX @todo UT transactional property of dir_new().
  */
-static int dir_new(const struct c2_conf_buf *dir_id,
-		   enum c2_conf_objtype child_type, struct arr_buf *src,
-		   struct c2_conf_reg *reg, struct c2_conf_dir **out)
+static int dir_new(const struct c2_buf *dir_id, enum c2_conf_objtype child_type,
+		   struct arr_buf *src, struct c2_conf_reg *reg,
+		   struct c2_conf_dir **out)
 {
 	struct c2_conf_obj *dir;
 	struct c2_conf_obj *child;
@@ -492,7 +491,7 @@ bool c2_conf_obj_match(const struct c2_conf_obj *cached,
 	C2_PRE(confx_object_is_valid(onwire));
 
 	if (cached->co_type != onwire->o_conf.u_type ||
-	    !c2_conf_buf_eq(cached->co_id, onwire->o_id))
+	    !c2_buf_eq(cached->co_id, onwire->o_id))
 		return false;
 
 	if (cached->co_status != C2_CS_READY)
@@ -509,7 +508,7 @@ static bool profile_match(const struct c2_conf_obj *cached,
 							    &onwire->o_id);
 	const struct c2_conf_filesystem *child = obj->cp_filesystem;
 
-	return c2_conf_buf_eq(&child->cf_obj.co_id, &objx->xp_filesystem);
+	return c2_buf_eq(&child->cf_obj.co_id, &objx->xp_filesystem);
 }
 
 static bool filesystem_match(const struct c2_conf_obj *cached,
@@ -519,17 +518,17 @@ static bool filesystem_match(const struct c2_conf_obj *cached,
 	const struct c2_conf_filesystem *obj = C2_CONF_CAST(cached,
 							    &onwire->o_id);
 	const struct c2_conf_service    *child = obj->cf_services;
-	const struct c2_conf_buf        *buf;
+	const struct c2_buf             *buf;
 	int                              i;
 
 	for (i = 0; obj->cf_params[i] != NULL; ++i) {
 		C2_ASSERT(i < objx->xf_params.ab_count);
 		buf = &objx->xf_params.ab_elements[i];
-		if (memcmp(obj->cf_params[i], buf->cb_data, buf->cb_size) != 0)
+		if (memcmp(obj->cf_params[i], buf->b_addr, buf->b_nob) != 0)
 			return false;
 	}
 
-	return c2_conf_buf_eq(&child->cd_obj.co_id, &objx->xp_services) &&
+	return c2_buf_eq(&child->cd_obj.co_id, &objx->xp_services) &&
 		objx->xf_rootfid.f_container == obj->cf_rootfid.f_container &&
 		objx->xf_rootfid.f_size == obj->cf_rootfid.f_size;
 }
@@ -540,18 +539,17 @@ static bool service_match(const struct c2_conf_obj *cached,
 	const struct confx_service   *objx = &onwire->o_conf.u.u_service;
 	const struct c2_conf_service *obj = C2_CONF_CAST(cached, &onwire->o_id);
 	const struct c2_conf_node    *child = obj->cs_node;
-	const struct c2_conf_buf     *buf;
+	const struct c2_buf          *buf;
 	int                           i;
 
 	for (i = 0; obj->cs_endpoints[i] != NULL; ++i) {
 		C2_ASSERT(i < objx->xs_endpoints.ab_count);
 		buf = &objx->xf_endpoints.ab_elements[i];
-		if (memcmp(obj->cs_endpoints[i],
-			   buf->cb_data, buf->cb_size) != 0)
+		if (memcmp(obj->cs_endpoints[i], buf->b_addr, buf->b_nob) != 0)
 			return false;
 	}
 
-	return c2_conf_buf_eq(&child->cn_obj.co_id, &objx->xs_node) &&
+	return c2_buf_eq(&child->cn_obj.co_id, &objx->xs_node) &&
 		obj->cs_type == objx->xs_type;
 }
 
@@ -596,7 +594,7 @@ static bool sdev_match(const struct c2_conf_obj *cached,
 	C2_IMPOSSIBLE("To be implemented!");
 	return
 		/* XXX TODO: compare dir elements */
-		/* c2_conf_buf_eq(&child->pa_obj.co_id, &objx->xd_partitions) && */
+		/* c2_buf_eq(&child->pa_obj.co_id, &objx->xd_partitions) && */
 		obj->sd_iface == objx->xd_iface &&
 		obj->sd_media == objx->xd_media &&
 		obj->sd_size == objx->xd_size &&
@@ -614,8 +612,8 @@ static bool partition_match(const struct c2_conf_obj *cached,
 		obj->pa_size == objx->xa_size   &&
 		obj->pa_index == objx->xa_index &&
 		obj->pa_type == objx->xa_type   &&
-		memcmp(obj->pa_filename, objx->xa_file.cb_data,
-		       objx->xa_file.cb_size) == 0;
+		memcmp(obj->pa_filename, objx->xa_file.b_addr,
+		       objx->xa_file.b_nob) == 0;
 }
 
 /* ------------------------------------------------------------------
@@ -663,7 +661,7 @@ int c2_conf_obj_fill(struct c2_conf_obj *dest, const struct confx_object *src,
 	C2_PRE(confc_is_nil_or_locked(obj));
 	C2_PRE(obj_is_stub(dest) && dest->co_nrefs == 0);
 	C2_PRE(dest->co_type == src->o_conf.u_type);
-	C2_PRE(c2_conf_buf_eq(&dest->co_id, &src->o_id));
+	C2_PRE(c2_buf_eq(&dest->co_id, &src->o_id));
 	C2_PRE(confx_object_is_valid(src));
 
 	rc = ot->ot_ops.coo_fill(dest, src, reg);
@@ -740,8 +738,8 @@ static int node_fill(struct c2_conf_obj *__dest,
 {
 	int                      rc;
 	struct c2_conf_node     *dest;
-	struct c2_conf_buf       nic_id = C2_CONF_BUF_INIT0;
-	struct c2_conf_buf       sdev_id = C2_CONF_BUF_INIT0;
+	struct c2_buf            nic_id = C2_BUF_INIT0;
+	struct c2_buf            sdev_id = C2_BUF_INIT0;
 	const struct confx_node *src = &__src->o_conf.u.u_node;
 
 	dest = C2_CONF_CAST(__dest, c2_conf_node); /* XXX */
@@ -752,18 +750,18 @@ static int node_fill(struct c2_conf_obj *__dest,
 	dest->cn_flags      = xn_flags;
 	dest->cn_pool_id    = xn_pool_id;
 
-	rc = c2_conf_buf_copy(&nic_id, &__src->o_id);
+	rc = c2_buf_copy(&nic_id, &__src->o_id);
 	if (rc != 0)
 		return rc;
 
-	rc = c2_conf_buf_copy(&sdev_id, &__src->o_id);
+	rc = c2_buf_copy(&sdev_id, &__src->o_id);
 	if (rc != 0)
 		return rc;
 
 	/* making ids of directories different */
-	C2_ASSERT(nic_id.cb_size > 1 && sdev_id.cb_size > 1);
-	nic_id.cb_data[0] = 'N';
-	sdev_id.cb_data[0] = 'S';
+	C2_ASSERT(nic_id.b_nob > 1 && sdev_id.b_nob > 1);
+	nic_id.b_addr[0] = 'N';
+	sdev_id.b_addr[0] = 'S';
 
 	return dir_new(&nic_id, C2_CO_NIC, &src->xn_nics, reg,
 		       &dest->cn_nics) ?:
@@ -819,8 +817,8 @@ fail:
  * ->coo_lookup()
  * ------------------------------------------------------------------ */
 
-static int dir_lookup(struct c2_conf_obj *parent,
-		      const struct c2_conf_buf *name, struct c2_conf_obj **out)
+static int dir_lookup(struct c2_conf_obj *parent, const struct c2_buf *name,
+		      struct c2_conf_obj **out)
 {
 	struct c2_conf_obj *child;
 	struct c2_conf_dir *dir = C2_CONF_CAST(parent, c2_conf_dir);
@@ -829,7 +827,7 @@ static int dir_lookup(struct c2_conf_obj *parent,
 
 	/*
 	 * for_each(child in dir->cd_items) {
-	 *     if (c2_conf_buf_eq(child->co_id, name)) {
+	 *     if (c2_buf_eq(child->co_id, name)) {
 	 *         *out = child;
 	 *         return 0;
 	 *     }
@@ -841,7 +839,7 @@ static int dir_lookup(struct c2_conf_obj *parent,
 }
 
 static int
-profile_lookup(struct c2_conf_obj *parent, const struct c2_conf_buf *name,
+profile_lookup(struct c2_conf_obj *parent, const struct c2_buf *name,
 	       struct c2_conf_obj **out)
 {
 	struct c2_conf_obj     *child;
@@ -849,8 +847,7 @@ profile_lookup(struct c2_conf_obj *parent, const struct c2_conf_buf *name,
 
 	C2_PRE(parent->co_status == C2_CS_READY);
 
-	if (!c2_conf_buf_eq(name, &(const struct c2_conf_buf)
-			    C2_CONF_BUF_INITS("filesystem")))
+	if (!c2_buf_eq(name, &(const struct c2_buf)C2_BUF_INITS("filesystem")))
 		return -ENOENT;
 
 	child = &prof->cp_filesystem->cf_obj;
@@ -976,16 +973,16 @@ static bool obj_is_stub(const struct c2_conf_obj *obj)
 	return obj->co_status != C2_CS_READY;
 }
 
-static bool buf_is_valid(const struct c2_conf_buf *buf)
+static bool buf_is_valid(const struct c2_buf *buf)
 {
-	return buf->cb_size > 0 && buf->cb_data != NULL;
+	return buf->b_nob > 0 && buf->b_addr != NULL;
 }
 
 /*
  * Note, that buf_strdup() expects valid (buf_is_valid()) buffer.
  * Take care when working with buffers received over network.
  */
-static char *buf_strdup(const struct c2_conf_buf *buf)
+static char *buf_strdup(const struct c2_buf *buf)
 {
 	size_t len;
 	char  *s;
@@ -994,13 +991,13 @@ static char *buf_strdup(const struct c2_conf_buf *buf)
 
 	/* Measure the size of payload. Buffer's bytes beyond '\0'
 	 * will never be used. */
-	len = strlen(buf->cb_data);
-	if (len > buf->cb_size)
-		len = buf->cb_size;
+	len = strlen(buf->b_addr);
+	if (len > buf->b_nob)
+		len = buf->b_nob;
 
 	C2_ALLOC_ARR(s, len + 1);
 	if (s != NULL) {
-		memcpy(s, buf->cb_data, len);
+		memcpy(s, buf->b_addr, len);
 		s[len] = 0;
 	}
 	return s;
@@ -1010,8 +1007,8 @@ static char *buf_strdup(const struct c2_conf_buf *buf)
 static bool confx_object_is_valid(const struct confx_object *src)
 {
 	/* XXX
-	 * - All of c2_conf_buf-s contained in `src' are buf_is_valid();
-	 * - all of arr_buf-s are populated with valid c2_conf_buf-s;
+	 * - All of c2_buf-s contained in `src' are buf_is_valid();
+	 * - all of arr_buf-s are populated with valid c2_buf-s;
 	 * - etc.
 	 */
 	(void) src; /* XXX */
diff --git a/conf/obj_ops.h b/conf/obj_ops.h
index 465d631..4be3f27 100644
--- a/conf/obj_ops.h
+++ b/conf/obj_ops.h
@@ -83,8 +83,7 @@ struct c2_conf_obj_ops {
 	 *
 	 * @pre  parent->co_status == C2_CS_READY
 	 */
-	int (*coo_lookup)(struct c2_conf_obj *parent,
-			  const struct c2_conf_buf *name,
+	int (*coo_lookup)(struct c2_conf_obj *parent, const struct c2_buf *name,
 			  struct c2_conf_obj **out);
 
 	/**
@@ -178,7 +177,7 @@ void c2_conf_obj_put(struct c2_conf_obj *obj);
  * configuration objects.
  */
 struct c2_conf_obj *c2_conf_obj_new(enum c2_conf_objtype type,
-				    const struct c2_conf_buf *id);
+				    const struct c2_buf *id);
 
 /**
  * Returns false iff cached configuration object and on-wire object
@@ -198,7 +197,7 @@ bool c2_conf_obj_match(const struct c2_conf_obj *cached,
  * @pre   dest->co_status != C2_CS_READY
  * @pre   dest->co_nrefs == 0
  * @pre   dest->co_type == src->o_conf.u_type
- * @pre   c2_conf_buf_eq(&dest->co_id, &src->o_id)
+ * @pre   c2_buf_eq(&dest->co_id, &src->o_id)
  *
  * @post  dest->co_status == C2_CS_READY
  * @post  c2_conf_obj_invariant(dest)
diff --git a/conf/onwire.h b/conf/onwire.h
index 346dd6e..5dc8309 100644
--- a/conf/onwire.h
+++ b/conf/onwire.h
@@ -25,31 +25,21 @@
 #include "xcode/xcode.h"
 
 /* export */
-struct c2_conf_buf;
 struct c2_conf_fetch;
 struct c2_conf_fetch_resp;
 struct c2_conf_update;
 struct c2_conf_update_resp;
 
-/**
- * Sequence of bytes.
- * See also C2_CONF_BUF_INIT(), c2_conf_buf_eq().
- */
-struct c2_conf_buf {
-	uint32_t cb_size;
-	char    *cb_data;
-} C2_XCA_SEQUENCE;
-
 /** XXX @todo Use c2_buf instead of arr_buf. */
 struct arr_buf {
-	uint32_t            ab_count;
-	struct c2_conf_buf *ab_elems;
+	uint32_t       ab_count;
+	struct c2_buf *ab_elems;
 } C2_XCA_SEQUENCE;
 
 /** XXX @todo s/objid/objiden/ ? */
 struct objid {
-	uint32_t           oi_type; /* see c2_conf_objtype for values */
-	struct c2_conf_buf oi_id;
+	uint32_t      oi_type; /* see c2_conf_objtype for values */
+	struct c2_buf oi_id;
 } C2_XCA_RECORD;
 
 struct fid {
@@ -62,7 +52,7 @@ struct fid {
  * ------------------------------------------------------------------ */
 struct confx_profile {
 	/* Name of profile's filesystem. */
-	struct c2_conf_buf xp_filesystem;
+	struct c2_buf xp_filesystem;
 } C2_XCA_RECORD;
 
 struct confx_filesystem {
@@ -76,11 +66,11 @@ struct confx_filesystem {
 
 struct confx_service {
 	/* Service type.  See c2_cfg_service_type. */
-	uint32_t           xs_type;
+	uint32_t       xs_type;
 	/* End-points from which this service is reachable. */
-	struct arr_buf     xs_endpoints;
+	struct arr_buf xs_endpoints;
 	/* Hosting node. */
-	struct c2_conf_buf xs_node;
+	struct c2_buf  xs_node;
 } C2_XCA_RECORD;
 
 struct confx_node {
@@ -102,45 +92,45 @@ struct confx_node {
 
 struct confx_nic {
 	/* Type of network interface.  See c2_cfg_nic_type. */
-	uint32_t           xi_iface;
+	uint32_t      xi_iface;
 	/* Maximum transmission unit. */
-	uint32_t           xi_mtu;
+	uint32_t      xi_mtu;
 	/* Speed in Mb/sec. */
-	uint64_t           xi_speed;
+	uint64_t      xi_speed;
 	/* Filename in host OS. */
-	struct c2_conf_buf xi_filename;
+	struct c2_buf xi_filename;
 	/* Last known state.  See c2_cfg_state_bit. */
-	uint64_t           xi_last_state;
+	uint64_t      xi_last_state;
 } C2_XCA_RECORD;
 
 struct confx_sdev {
 	/* Interface type.  See c2_cfg_storage_device_interface_type. */
-	uint32_t           xd_iface;
+	uint32_t       xd_iface;
 	/* Media type.  See c2_cfg_storage_device_media_type. */
-	uint32_t           xd_media;
+	uint32_t       xd_media;
 	/* Size in bytes. */
-	uint64_t           xd_size;
+	uint64_t       xd_size;
 	/* Last known state.  See c2_cfg_state_bit. */
-	uint64_t           xd_last_state;
+	uint64_t       xd_last_state;
 	/* Property flags.  See c2_cfg_flag_bit. */
-	uint64_t           xd_flags;
+	uint64_t       xd_flags;
 	/* Filename in host OS. */
-	struct c2_conf_buf xd_filename;
+	struct c2_buf  xd_filename;
 	/* Partitions of this storage device. */
-	struct arr_buf     xd_partitions;
+	struct arr_buf xd_partitions;
 } C2_XCA_RECORD;
 
 struct confx_partition {
 	/* Start offset in bytes. */
-	uint64_t           xa_start;
+	uint64_t      xa_start;
 	/* Size in bytes. */
-	uint64_t           xa_size;
+	uint64_t      xa_size;
 	/* Partition index. */
-	uint32_t           xa_index;
+	uint32_t      xa_index;
 	/* Partition type.  See c2_cfg_storage_device_partition_type. */
-	uint32_t           xa_type;
+	uint32_t      xa_type;
 	/* Filename in host OS. */
-	struct c2_conf_buf xa_file;
+	struct c2_buf xa_file;
 } C2_XCA_RECORD;
 
 struct confx_u {
@@ -163,8 +153,8 @@ struct confx_u {
 
 /** Configuration object descriptor. */
 struct confx_object {
-	struct c2_conf_buf o_id;   /*< Object identifier. */
-	struct confx_u     o_conf; /*< Configuration data. */
+	struct c2_buf  o_id;   /*< Object identifier. */
+	struct confx_u o_conf; /*< Configuration data. */
 } C2_XCA_RECORD;
 
 struct enconf {
diff --git a/conf/preload.h b/conf/preload.h
index fe4f04c..49dfc51 100644
--- a/conf/preload.h
+++ b/conf/preload.h
@@ -74,16 +74,16 @@ struct confx_object;
  *
  * @code
  * struct confx_object a = {
- *     .o_id = C2_CONF_BUF_INITS("test"),
+ *     .o_id = C2_BUF_INITS("test"),
  *     .o_conf = {
  *         .u_type = C2_CO_PROFILE,
  *         .u.u_profile = {
- *             .xp_filesystem = C2_CONF_BUF_INITS("c2t1fs")
+ *             .xp_filesystem = C2_BUF_INITS("c2t1fs")
  *         }
  *     }
  * };
  * struct confx_object b = {
- *     .o_id = C2_CONF_BUF_INITS("c2t1fs"),
+ *     .o_id = C2_BUF_INITS("c2t1fs"),
  *     .o_conf = {
  *         .u_type = C2_CO_FILESYSTEM,
  *         .u.u_filesystem = {
-- 
1.8.3.2

