From c142e47a1b3628ef7e5533bdc49bf00898c1ea41 Mon Sep 17 00:00:00 2001
From: Anatoliy Bilenko <anatoliy_bilenko@xyratex.com>
Date: Mon, 3 Sep 2012 13:16:27 +0300
Subject: [PATCH 357/370] lib: add c2_strtou{32,64}() wrappers over
 strtoul{,l}()

	- preload: updated according to changes in lib.
---
 conf/preload.c           | 68 ++++++++++++++++++++++++++++++------------------
 lib/Makefile.am          |  2 ++
 lib/linux_kernel/kmisc.c | 44 +++++++++++++++++++++++++++++++
 lib/misc.h               |  6 +++++
 lib/user_space/umisc.c   | 42 ++++++++++++++++++++++++++++++
 5 files changed, 137 insertions(+), 25 deletions(-)
 create mode 100644 lib/linux_kernel/kmisc.c
 create mode 100644 lib/user_space/umisc.c

diff --git a/conf/preload.c b/conf/preload.c
index b943b64..e7ecb3e 100644
--- a/conf/preload.c
+++ b/conf/preload.c
@@ -28,9 +28,8 @@
 #include "lib/errno.h"
 #include "lib/misc.h"
 #include <ctype.h>		/* isspace */
-#include <stdlib.h>		/* strto{ull,ll,ul,l} @todo: move to misc.h */
 
-#define HUNK_DBG
+/* #define HUNK_DBG */
 #ifdef HUNK_DBG
 #include <stdio.h>
 #endif
@@ -318,7 +317,18 @@ static int unit_next(struct hunk *unit, const struct hunk *buffer, char ss)
  * ------------------------------------------------------------------ */
 
 /**
- *  @param ss sequence separator: ',' or ':'
+ * Iterates elements of a given sequence of characters.
+ *
+ * @param unit[inout]	parsed element of a sequence
+ * @param buffer[in]    sequence of characters, represented by a hunk
+ * @param ss[in]	sequence separator
+ *
+ * @return       0 when unit was successfully parsed,
+ *	   -ENOENT when the end of sequence reached,
+ *              <0 if any other error.
+ *
+ * @pre hunk_invariant(unit)
+ * @pre C2_IN(ss, (',', ':'))
  */
 static int seq_iterate(struct hunk *unit, const struct hunk *buffer, char ss)
 {
@@ -337,7 +347,15 @@ static int seq_iterate(struct hunk *unit, const struct hunk *buffer, char ss)
 	return unit_parse(unit, ss);
 }
 
-/* @todo: Very unoptimal sequence length calculation */
+/**
+ * Calculates the number of elements in a given sequence of characters.
+ *
+ * @param unit[in] sequence of characters, represented by a hunk
+ * @param ss[in]   sequence separator
+ *
+ * @pre hunk_invariant(unit)
+ * @pre C2_IN(ss, (',', ':'))
+ */
 static int seq_length(const struct hunk *unit, char ss)
 {
 	int length = 0;
@@ -402,12 +420,12 @@ static int rootfid_parse(struct fid *fid, const struct hunk *val)
 	rc = seq_iterate(&rfid, &aval, ',');
 	if (rc != 0)
 		return rc;
-	fid->f_container = strtoull(rfid.begin, NULL, 0);
+	fid->f_container = c2_strtou64(rfid.begin, NULL, 0);
 
 	rc = seq_iterate(&rfid, &aval, ',');
 	if (rc != 0)
 		return rc;
-	fid->f_key = strtoull(rfid.begin, NULL, 0);
+	fid->f_key = c2_strtou64(rfid.begin, NULL, 0);
 
 	rc = seq_iterate(&rfid, &aval, ',');
 
@@ -510,7 +528,7 @@ static int service_parse(const struct hunk *key, const struct hunk *val,
 
 	else if (hunk_str_eq(key, "svc_type"))
 		out->o_conf.u.u_service.xs_type =
-			strtoul(val->begin, NULL, 0);
+			c2_strtou32(val->begin, NULL, 0);
 
 	else if (hunk_str_eq(key, "endpoints"))
 		return arrbuf_parse(&out->o_conf.u.u_service.xs_endpoints, val);
@@ -538,23 +556,23 @@ static int node_parse(const struct hunk *key, const struct hunk *val,
 
 	else if (hunk_str_eq(key, "memsize"))
 		out->o_conf.u.u_node.xn_memsize =
-			strtoul(val->begin, NULL, 0);
+			c2_strtou32(val->begin, NULL, 0);
 
 	else if (hunk_str_eq(key, "nr_cpu"))
 		out->o_conf.u.u_node.xn_nr_cpu =
-			strtoul(val->begin, NULL, 0);
+			c2_strtou32(val->begin, NULL, 0);
 
 	else if (hunk_str_eq(key, "last_state"))
 		out->o_conf.u.u_node.xn_last_state =
-			strtoull(val->begin, NULL, 0);
+			c2_strtou64(val->begin, NULL, 0);
 
 	else if (hunk_str_eq(key, "flags"))
 		out->o_conf.u.u_node.xn_flags =
-			strtoull(val->begin, NULL, 0);
+			c2_strtou64(val->begin, NULL, 0);
 
 	else if (hunk_str_eq(key, "pool_id"))
 		out->o_conf.u.u_node.xn_pool_id =
-			strtoull(val->begin, NULL, 0);
+			c2_strtou64(val->begin, NULL, 0);
 
 	else if (hunk_str_eq(key, "nics"))
 		return arrbuf_parse(&out->o_conf.u.u_node.xn_nics, val);
@@ -580,15 +598,15 @@ static int nic_parse(const struct hunk *key, const struct hunk *val,
 
 	else if (hunk_str_eq(key, "iface_type"))
 		out->o_conf.u.u_nic.xi_iface =
-			strtoul(val->begin, NULL, 0);
+			c2_strtou32(val->begin, NULL, 0);
 
 	else if (hunk_str_eq(key, "mtu"))
 		out->o_conf.u.u_nic.xi_mtu =
-			strtoul(val->begin, NULL, 0);
+			c2_strtou32(val->begin, NULL, 0);
 
 	else if (hunk_str_eq(key, "speed"))
 		out->o_conf.u.u_nic.xi_speed =
-			strtoull(val->begin, NULL, 0);
+			c2_strtou64(val->begin, NULL, 0);
 
 	else if (hunk_str_eq(key, "filename"))
 		c2_buf_init(&out->o_conf.u.u_nic.xi_filename,
@@ -596,7 +614,7 @@ static int nic_parse(const struct hunk *key, const struct hunk *val,
 
 	else if (hunk_str_eq(key, "last_state"))
 		out->o_conf.u.u_nic.xi_last_state =
-			strtoull(val->begin, NULL, 0);
+			c2_strtou64(val->begin, NULL, 0);
 
 	else
 		return -EINVAL;
@@ -616,23 +634,23 @@ static int sdev_parse(const struct hunk *key, const struct hunk *val,
 
 	else if (hunk_str_eq(key, "iface"))
 		out->o_conf.u.u_sdev.xd_iface =
-			strtoul(val->begin, NULL, 0);
+			c2_strtou32(val->begin, NULL, 0);
 
 	else if (hunk_str_eq(key, "media"))
 		out->o_conf.u.u_sdev.xd_media =
-			strtoul(val->begin, NULL, 0);
+			c2_strtou32(val->begin, NULL, 0);
 
 	else if (hunk_str_eq(key, "size"))
 		out->o_conf.u.u_sdev.xd_size =
-			strtoul(val->begin, NULL, 0);
+			c2_strtou64(val->begin, NULL, 0);
 
 	else if (hunk_str_eq(key, "last_state"))
 		out->o_conf.u.u_sdev.xd_last_state =
-			strtoul(val->begin, NULL, 0);
+			c2_strtou64(val->begin, NULL, 0);
 
 	else if (hunk_str_eq(key, "flags"))
 		out->o_conf.u.u_sdev.xd_flags =
-			strtoul(val->begin, NULL, 0);
+			c2_strtou64(val->begin, NULL, 0);
 
 	else if (hunk_str_eq(key, "filename"))
 		c2_buf_init(&out->o_conf.u.u_sdev.xd_filename,
@@ -660,19 +678,19 @@ static int partition_parse(const struct hunk *key, const struct hunk *val,
 
 	else if (hunk_str_eq(key, "start"))
 		out->o_conf.u.u_partition.xa_start =
-			strtoull(val->begin, NULL, 0);
+			c2_strtou64(val->begin, NULL, 0);
 
 	else if (hunk_str_eq(key, "size"))
 		out->o_conf.u.u_partition.xa_size =
-			strtoull(val->begin, NULL, 0);
+			c2_strtou64(val->begin, NULL, 0);
 
 	else if (hunk_str_eq(key, "index"))
 		out->o_conf.u.u_partition.xa_index =
-			strtoul(val->begin, NULL, 0);
+			c2_strtou32(val->begin, NULL, 0);
 
 	else if (hunk_str_eq(key, "pa_type"))
 		out->o_conf.u.u_partition.xa_type =
-			strtoul(val->begin, NULL, 0);
+			c2_strtou32(val->begin, NULL, 0);
 
 	else if (hunk_str_eq(key, "filename"))
 		out->o_conf.u.u_partition.xa_file = (const struct c2_buf)
diff --git a/lib/Makefile.am b/lib/Makefile.am
index 49edae6..96acbff 100644
--- a/lib/Makefile.am
+++ b/lib/Makefile.am
@@ -98,6 +98,7 @@ libc2_la_SOURCES     = \
                        user_space/cdefs.h \
                        user_space/finject_init.c \
                        user_space/memory.c \
+                       user_space/umisc.c \
                        user_space/mutex.h \
                        user_space/processor.c \
                        user_space/rwlock.c \
@@ -127,6 +128,7 @@ EXTRA_DIST             = \
                          linux_kernel/cdefs.h \
                          linux_kernel/finject_init.c \
                          linux_kernel/kcookie.c \
+                         linux_kernel/kmisc.c \
                          linux_kernel/kthread.c \
                          linux_kernel/ktrace.c \
                          linux_kernel/ktime.c \
diff --git a/lib/linux_kernel/kmisc.c b/lib/linux_kernel/kmisc.c
new file mode 100644
index 0000000..84180f5
--- /dev/null
+++ b/lib/linux_kernel/kmisc.c
@@ -0,0 +1,44 @@
+/* -*- C -*- */
+/*
+ * COPYRIGHT 2012 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: Anatoliy Bilenko <Anatoliy_Bilenko@xyratex.com>
+ * Original creation date: 03/09/2012
+ */
+
+#include "lib/misc.h"
+#include <linux/cpu.h> /* simple_strtoull, simple_strtoul */
+
+uint64_t c2_strtou64(const char *str, char **endptr, int base)
+{
+	return simple_strtoull(str, endptr, base);
+}
+C2_EXPORTED(c2_strtou64);
+
+uint32_t c2_strtou32(const char *str, char **endptr, int base)
+{
+	return simple_strtoul(str, endptr, base);
+}
+C2_EXPORTED(c2_strtou32);
+
+/*
+ *  Local variables:
+ *  c-indentation-style: "K&R"
+ *  c-basic-offset: 8
+ *  tab-width: 8
+ *  fill-column: 80
+ *  scroll-step: 1
+ *  End:
+ */
diff --git a/lib/misc.h b/lib/misc.h
index 29b240f..1a95397 100644
--- a/lib/misc.h
+++ b/lib/misc.h
@@ -116,6 +116,12 @@ uint64_t c2_round_down(uint64_t val, uint64_t size);
 
 const char *c2_bool_to_str(bool b);
 
+/* strtoull for user- and kernel-space */
+uint64_t c2_strtou64(const char *str, char **endptr, int base);
+
+/* strtoul for user- and kernel-space */
+uint32_t c2_strtou32(const char *str, char **endptr, int base);
+
 /* __COLIBRI_LIB_MISC_H__ */
 #endif
 
diff --git a/lib/user_space/umisc.c b/lib/user_space/umisc.c
new file mode 100644
index 0000000..ca1b0c9
--- /dev/null
+++ b/lib/user_space/umisc.c
@@ -0,0 +1,42 @@
+/* -*- C -*- */
+/*
+ * COPYRIGHT 2012 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: Anatoliy Bilenko <Anatoliy_Bilenko@xyratex.com>
+ * Original creation date: 03/09/2012
+ */
+
+#include "lib/misc.h"
+#include <stdlib.h>		/* strtoull, strtoul */
+
+uint64_t c2_strtou64(const char *str, char **endptr, int base)
+{
+	return strtoull(str, endptr, base);
+}
+
+uint32_t c2_strtou32(const char *str, char **endptr, int base)
+{
+	return strtoul(str, endptr, base);
+}
+
+/*
+ *  Local variables:
+ *  c-indentation-style: "K&R"
+ *  c-basic-offset: 8
+ *  tab-width: 8
+ *  fill-column: 80
+ *  scroll-step: 1
+ *  End:
+ */
-- 
1.8.3.2

