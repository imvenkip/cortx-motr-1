From 91d0e9f24303af274eddd8acecae0141b2d083ee Mon Sep 17 00:00:00 2001
From: "Valery V. Vorotyntsev" <valery_vorotyntsev@xyratex.com>
Date: Mon, 19 Mar 2012 22:29:39 +0200
Subject: [PATCH 080/370] use struct c2_confc instead of global variable

* Get rid of `c2_conf_cache' structure, delete conf/cache.h.
* "Global variable" approach is wrong. There can be multiple
  instances of Colibri running in the same address space.
  Introduce `c2_confc' structure and pass it as a parameter
  to c2_confc_*() functions.

References:  LogD-1.3 # 833
Reported-by: Nikita Danilov <nikita_danilov@xyratex.com>
Reviewed-on: http://reviewboard.clusterstor.com/r/714/
---
 conf/cache.h |  60 -------------
 conf/confc.c | 285 ++++++++++++++++++++++++++++++-----------------------------
 conf/confc.h |  94 ++++++++++++--------
 3 files changed, 204 insertions(+), 235 deletions(-)
 delete mode 100644 conf/cache.h

diff --git a/conf/cache.h b/conf/cache.h
deleted file mode 100644
index 0afe838..0000000
--- a/conf/cache.h
+++ /dev/null
@@ -1,60 +0,0 @@
-/* -*- c -*- */
-/*
- * COPYRIGHT 2012 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Valery V. Vorotyntsev <valery_vorotyntsev@xyratex.com>
- * Original creation date: 11-Feb-2012
- */
-#ifndef __COLIBRI_CONF_CACHE_H__
-#define __COLIBRI_CONF_CACHE_H__
-
-#include "conf/map.h"  /* c2_conf_map */
-#include "lib/mutex.h" /* c2_mutex */
-#include "lib/cdefs.h" /* container_of */
-
-/**
- * @defgroup conf_cache  Configuration Cache
- *
- * @see @ref confc-dld
- *
- * @{
- */
-
-struct c2_sm_group;
-
-/** Configuration cache. */
-struct c2_conf_cache {
-	/** Registry of cached configuration objects. */
-	c2_conf_map         cc_registry;
-	/** Serializes confc state machines. */
-	struct c2_sm_group *cc_group;
-	/**
-	 * Protects this structure and the overall configuration cache
-	 * (the DAG of configuration objects) from concurrent writes.
-	 */
-	struct c2_mutex     cc_lock;
-};
-
-int c2_conf_cache_init(struct c2_conf_cache *cache);
-void c2_conf_cache_fini(struct c2_conf_cache *cache);
-
-static inline struct c2_conf_cache *
-c2_conf_map_to_cache(struct c2_conf_map *map)
-{
-	return container_of(map, struct c2_conf_cache, cc_registry);
-}
-
-/** @} conf_cache */
-#endif /* __COLIBRI_CONF_CACHE_H__ */
diff --git a/conf/confc.c b/conf/confc.c
index 70eba34..d87ecfb 100644
--- a/conf/confc.c
+++ b/conf/confc.c
@@ -316,16 +316,12 @@
  * @{
  */
 
-static struct {
-	struct c2_conf_cache cache;
-	struct c2_conf_obj  *root;
-} g_confc; /* `g_' for global variable */
-
-void c2_confc_ctx_init(struct c2_confc_ctx *ctx)
+void c2_confc_ctx_init(struct c2_confc_ctx *ctx, struct c2_confc *client)
 {
-	C2_PRE(confc_is_initialised());
+	C2_PRE(confc_is_initialised(confc));
+	ctx->fc_client = confc;
 	c2_sm_init(&ctx->fc_mach, &confc_states_conf, S_INITIAL,
-		   g_confc.cache.cc_group, XXX /* *c2_addb_ctx */);
+		   confc->cc_group, XXX /* *c2_addb_ctx */);
 	c2_chan_init(&ctx->fc_complete);
 	c2_clink_init(&ctx->fc_clink, on_unpinned);
 	C2_POST(ctx_invariant(ctx));
@@ -337,6 +333,7 @@ void c2_confc_ctx_fini(struct c2_confc_ctx *ctx)
 	c2_clink_fini(&ctx->fc_clink);
 	c2_chan_fini(&ctx->fc_complete);
 	c2_sm_fini(&ctx->fc_mach);
+	ctx->fc_client = NULL;
 }
 
 static enum c2_conf_status
@@ -351,25 +348,29 @@ list_status(const struct c2_tl_descr *descr, const struct c2_tl *list)
 	XXX;
 }
 
-static inline struct c2_mutex * group_lock(void)
+static inline struct c2_mutex * group_lock(struct c2_confc_ctx *ctx)
 {
-	return &g_confc.cache.cc_group->s_lock;
+	return &ctx->fc_client->cc_group->s_lock;
 }
 
-static inline struct c2_mutex * cache_lock(void)
+static inline struct c2_mutex * cache_lock(struct c2_confc_ctx *ctx)
 {
-	return &g_confc.cache.cc_lock;
+	return &ctx->fc_client->cc_lock;
 }
 
-static inline struct c2_conf_map * cache_registry(void)
+static inline struct c2_confc_ctx * mach_to_ctx(struct c2_sm *mach)
 {
-	return &g_confc.cache.cc_registry;
+	return container_of(mach, struct c2_confc_ctx, fc_mach);
 }
 
-static inline struct c2_confc_ctx * to_ctx(struct c2_sm *mach)
+static inline struct c2_confc_ctx * ast_to_ctx(struct c2_sm_ast *ast)
 {
-	C2_PRE(mach != NULL);
-	return container_of(mach, struct c2_confc_ctx, fc_mach);
+	return container_of(ast, struct c2_confc_ctx, fc_ast);
+}
+
+static inline struct c2_confc * registry_to_client(struct c2_conf_map *cache)
+{
+	return container_of(cache, struct c2_confc, cc_registry);
 }
 
 /**
@@ -399,16 +400,17 @@ static inline struct c2_confc_ctx * to_ctx(struct c2_sm *mach)
  */
 static int path_walk(struct c2_confc_ctx *ctx)
 {
-	struct c2_conf_obj *obj = ctx->fc_path.p_origin ?: g_confc.root;
+	struct c2_conf_obj *obj = ctx->fc_path.p_origin
+		?: ctx->fc_client->cc_root;
 	struct c2_conf_pathcomp *comp = ctx->fc_path.p_comps;
 	size_t len = ctx->fc_path.p_len; /* number of components to go */
 	bool target_is_directory = false;
 	int ret;
 
-	C2_PRE(c2_mutex_is_locked(group_lock()));
+	C2_PRE(c2_mutex_is_locked(group_lock(ctx)));
 	C2_PRE(c2_conf_path_is_valid(&ctx->fc_path, NULL));
 
-	c2_mutex_lock(cache_lock());
+	c2_mutex_lock(cache_lock(ctx));
 	ret = obj->co_status;
 
 	for (; ret == C2_CS_READY && len > 0; --len, ++comp) {
@@ -480,17 +482,19 @@ static int path_walk(struct c2_confc_ctx *ctx)
 		C2_IMPOSSIBLE("invalid object status");
 	}
 end:
-	c2_mutex_unlock(cache_lock());
-	C2_POST(c2_mutex_is_locked(group_lock()));
+	c2_mutex_unlock(cache_lock(ctx));
+	C2_POST(c2_mutex_is_locked(group_lock(ctx)));
 	return ret;
 }
 
 /**
- * Adds new objects contained in confd's response to the configuration cache.
+ * Adds new objects, contained in confd's response, to the
+ * configuration cache.
  *
  * @pre  resp->fr_rc == 0
  */
-static int cache_grow(const struct c2_conf_fetch_resp *resp)
+static int cache_grow(struct c2_conf_map *cache,
+		      const struct c2_conf_fetch_resp *resp)
 {
 	/*
 	 * struct confx_object *fetched;
@@ -506,12 +510,12 @@ static int cache_grow(const struct c2_conf_fetch_resp *resp)
 	 *         return -Exxx;
 	 *     }
 	 *
-	 *     cached = c2_conf_map_lookup(cache_registry(), &fetched->o_key,
+	 *     cached = c2_conf_map_lookup(cache, &fetched->o_key,
 	 *                                 fetched->o_val.ov_type);
 	 *     if (cached == NULL)
-	 *         rc = cache_add(fetched);
+	 *         rc = cache_add(cache, fetched);
 	 *     else
-	 *         rc = object_enrich(cached, fetched);
+	 *         rc = object_enrich(cached, fetched, cache);
 	 *
 	 *     if (rc != 0)
 	 *         break;
@@ -522,10 +526,10 @@ static int cache_grow(const struct c2_conf_fetch_resp *resp)
 	XXX;
 }
 
-static bool confc_is_initialised(void)
+static bool confc_is_initialised(const struct c2_confc *client)
 {
-	C2_PRE(equi(g_confc.root, g_confc.cache.cc_group));
-	return g_confc.root != NULL;
+	C2_PRE(equi(client->cc_root, client->cc_group));
+	return client->cc_root != NULL;
 }
 
 static int cache_preload(const char *conf_str)
@@ -547,56 +551,62 @@ static int cache_preload(const char *conf_str)
 	XXX;
 }
 
-int c2_confc_init(const char *profile, const char *confd_addr,
-		  struct c2_sm_group *sm_group)
+int c2_confc_init(struct c2_confc *client, const char *confd_addr,
+		  const char *profile, struct c2_sm_group *sm_group)
 {
 	/*
-	 * int                 rc;
+	 * int rc;
 	 * struct c2_conf_obj *root;
 	 *
-	 * C2_PRE(!confc_is_initialised());
-	 * C2_PRE(profile != NULL && *profile != 0);
+	 * C2_PRE(!confc_is_initialised(client));
 	 * C2_PRE(confd_addr != NULL && *confd_addr != 0);
+	 * C2_PRE(profile != NULL && *profile != 0);
 	 * C2_PRE(sm_group != NULL);
 	 *
-	 * g_confc.cache.cc_group = sm_group;
-	 * c2_mutex_init(cache_lock());
+	 * c2_mutex_lock(&sm_group->s_lock);
+	 * c2_mutex_init(&client->cc_lock);
+	 * c2_mutex_lock(&client->cc_lock);
 	 *
-	 * c2_conf_map_init(cache_registry());
+	 * client->cc_group = sm_group;
+	 *
+	 * c2_conf_map_init(&client->cc_registry);
 	 * root = c2_conf_obj_new(C2_CO_PROFILE, &(const struct c2_conf_buf)
 	 *                        C2_CONF_BUF_INIT(strlen(profile), profile));
-	 * c2_conf_map_add(cache_registry(), root);
-	 * g_confc.root = root;
+	 * c2_conf_map_add(&client->cc_registry, root);
+	 * client->cc_root = root;
 	 *
 	 * cache_preload(confd_addr);
 	 *
-	 * C2_POST(equi(rc == 0, confc_is_initiated()));
+	 * C2_POST(equi(rc == 0, confc_is_initialised(client)));
+	 * c2_mutex_unlock(&client->cc_lock);
+	 * c2_mutex_unlock(&sm_group->s_lock);
+	 * return rc;
 	 */
 	XXX;
 }
 
-void c2_confc_fini(void)
+void c2_confc_fini(struct c2_confc *client)
 {
 	/*
-	 * C2_PRE(confc_is_initialised());
+	 * C2_PRE(confc_is_initialised(client));
 	 *
-	 * c2_mutex_lock(group_lock());
-	 * c2_mutex_lock(cache_lock());
+	 * c2_mutex_lock(&client->cc_group->s_lock);
+	 * c2_mutex_lock(&client->cc_lock);
 	 *
-	 * for (obj in cache_registry()) {
+	 * for (obj in client->cc_registry) {
 	 *     C2_ASSERT(obj->co_nrefs == 0 &&
 	 *               obj->co_status != C2_CS_LOADING);
 	 *     c2_free(obj);
 	 * }
-	 * c2_confc_map_fini(cache_registry());
-	 * g_confc.root = NULL;
+	 * c2_confc_map_fini(&client->cc_registry);
+	 * client->cc_root = NULL;
 	 *
-	 * c2_mutex_unlock(cache_lock());
-	 * c2_mutex_fini(cache_lock());
-	 * c2_mutex_unlock(group_lock());
-	 * g_confc.cache.cc_group = NULL;
+	 * c2_mutex_unlock(&client->cc_lock);
+	 * c2_mutex_fini(&client->cc_lock);
+	 * c2_mutex_unlock(&client->cc_group->s_lock);
+	 * client->cc_group = NULL;
 	 *
-	 * C2_POST(!confc_is_initialised());
+	 * C2_POST(!confc_is_initialised(client));
 	 */
 	XXX;
 }
@@ -606,17 +616,17 @@ int c2_confc_open(struct c2_confc_ctx *ctx, struct c2_conf_obj *path_origin,
 {
 	bool isdir;
 
-	C2_PRE(confc_is_initialised());
+	C2_PRE(confc_is_initialised(ctx->fc_client));
 	C2_PRE(ctx->fc_path.p_origin == NULL && ctx->fc_path.p_len == 0 &&
 	       ctx->fc_path.p_comps == NULL);
 
-	ctx->fc_path.p_origin = path_origin;
-	ctx->fc_path.p_len    = path_len;
-	ctx->fc_path.p_comps  = C2_ALLOC_ARR(path, path_len);
+	ctx->fc_path.p_comps = C2_ALLOC_ARR(path, path_len);
 	if (ctx->fc_path.p_comps == NULL)
 		return -ENOMEM;
-	C2_ASSERT(c2_conf_path_is_valid(&ctx->fc_path, &isdir));
+	ctx->fc_path.p_len = path_len;
+	ctx->fc_path.p_origin = path_origin;
 
+	C2_ASSERT(c2_conf_path_is_valid(&ctx->fc_path, &isdir));
 	if (isdir)
 		return -EISDIR;
 
@@ -624,50 +634,49 @@ int c2_confc_open(struct c2_confc_ctx *ctx, struct c2_conf_obj *path_origin,
 	return 0;
 }
 
-void * c2_confc_open_sync(struct c2_conf_obj *path_origin,
+void * c2_confc_open_sync(struct c2_confc *client,
+			  struct c2_conf_obj *path_origin,
 			  const struct c2_conf_pathcomp *path, size_t path_len)
 {
 	struct c2_confc_ctx ctx;
-	int rc;
-	void *ret = NULL;
+	int                 rc;
+	void               *result = NULL;
 
-	C2_PRE(confc_is_initialised());
+	C2_PRE(confc_is_initialised(client));
 
-	c2_confc_ctx_init(&ctx);
+	c2_confc_ctx_init(&ctx, client);
 	rc = c2_confc_open(&ctx, path_origin, path, path_len);
 	if (rc == 0) {
 		rc = c2_sm_timedwait(&ctx.fc_mach, S_TERMINAL | S_FAILURE,
 				     C2_TIME_NEVER);
 		C2_ASSERT(rc == 0);
-		ret = ctx.fc_result;
+		result = ctx.fc_result;
 	}
 	c2_confc_ctx_fini(&ctx);
-	return ret;
+	return result;
 }
 
-void c2_confc_close(void *obj)
+void c2_confc_close(void *obj, struct c2_confc *client)
 {
 	struct c2_conf_obj *x = obj;
 
-	c2_mutex_lock(cache_lock());
+	c2_mutex_lock(&client->cc_lock);
 	C2_CNT_DEC(x->co_nrefs);
 	if (x->co_nrefs == 0)
 		c2_chan_broadcast(&x->co_chan);
-	c2_mutex_unlock(cache_lock());
+	c2_mutex_unlock(&client->cc_lock);
 }
 
 /** Collection of configuration objects. */
 struct c2_confc_dir {
 	/** Parent object this collection belongs to. */
 	struct c2_conf_obj       *d_parent;
-
 	/**
 	 * Currently opened (and pinned) element of this collection.
 	 *
 	 * The value is updated by c2_confc_dirnext().
 	 */
 	struct c2_conf_obj       *d_current;
-
 	/** List descriptor. */
 	const struct c2_tl_descr *d_descr;
 };
@@ -689,14 +698,15 @@ static void
 request_fill(struct c2_conf_fetch *req, const struct c2_conf_obj *path_org,
 	     struct c2_conf_pathcomp *path, size_t path_len)
 {
-	C2_PRE(c2_mutex_is_locked(group_lock()));
-	C2_PRE(c2_mutex_is_locked(cache_lock()));
+	struct c2_confc_ctx *ctx =
+		container_of(req, struct c2_confc_ctx, fc_req);
+	C2_PRE(c2_mutex_is_locked(group_lock(ctx)));
+	C2_PRE(c2_mutex_is_locked(cache_lock(ctx)));
 
-	req->ff_origin.o_objtype = path_org->co_type;
-	memcpy(&req->ff_origin.o_objkey, &path_org->co_key,
-	       sizeof req->ff_origin.o_objkey);
-	req->ff_comps.c_nr = path_len;
-	req->ff_comps.c_data = path;
+	req->f_origin.o_objtype = path_org->co_type;
+	req->f_origin.oi_objkey = path_org->co_key;
+	req->f_comps.ap_count = path_len;
+	req->f_comps.ap_elems = path;
 
 	C2_POST(request_is_valid(req));
 }
@@ -711,43 +721,42 @@ enum confc_state { S_INITIAL, S_CHECK, S_WAIT_REPLY, S_WAIT_STATUS,
 static void _state_set(struct c2_sm_group *grp __attribute__((unused)),
 		       struct c2_sm_ast *ast)
 {
-	struct c2_confc_ctx *ctx =
-		container_of(ast, struct c2_confc_ctx, fc_ast);
-	c2_sm_state_set(&ctx->fc_mach, (enum confc_state)ast->sa_datum);
+	c2_sm_state_set(&ast_to_ctx(ast)->fc_mach,
+			(enum confc_state)ast->sa_datum);
 }
 
 static void _fail(struct c2_sm_group *grp __attribute__((unused)),
 		  struct c2_sm_ast *ast)
 {
-	struct c2_confc_ctx *ctx =
-		container_of(ast, struct c2_confc_ctx, fc_ast);
-	c2_sm_fail(&ctx->fc_mach, S_FAILURE, (int32_t)ast->sa_datum);
+	c2_sm_fail(&ast_to_ctx(ast)->fc_mach, S_FAILURE,
+		   (int32_t)ast->sa_datum);
 }
 
 /** Posts an AST that will advance the state machine to given state. */
 static void ast_state_set(struct c2_sm_ast *ast, enum confc_state state)
 {
-	ast->sa_cb    = _state_set;
+	ast->sa_cb = _state_set;
 	ast->sa_datum = state;
-	c2_sm_ast_post(g_confc.cache.cc_group, ast);
+	c2_sm_ast_post(ast_to_ctx(ast)->fc_client->cc_group, ast);
 }
 
 /** Posts an AST that will move the state machine to S_FAILURE state. */
 static void ast_fail(struct c2_sm_ast *ast, int32_t rc)
 {
-	ast->sa_cb    = _fail;
+	ast->sa_cb = _fail;
 	ast->sa_datum = rc;
-	c2_sm_ast_post(g_confc.cache.cc_group, ast);
+	c2_sm_ast_post(ast_to_ctx(ast)->fc_client->cc_group, ast);
 }
 
 /** Actions to perform on entering CHECK state. */
 static void check_st_in(struct c2_sm *mach)
 {
 	int rc;
+	struct c2_confc_ctx *ctx = mach_to_ctx(mach);
 
-	C2_PRE(c2_mutex_is_locked(group_lock()));
+	C2_PRE(c2_mutex_is_locked(group_lock(ctx)));
 
-	rc = path_walk(to_ctx(mach));
+	rc = path_walk(ctx);
 	if (rc < 0)
 		c2_sm_fail(mach, S_FAILURE, rc);
 	else if (rc == C2_CS_MISSING)
@@ -759,14 +768,14 @@ static void check_st_in(struct c2_sm *mach)
 	else
 		C2_IMPOSSIBLE("path_walk: invalid result");
 
-	C2_POST(c2_mutex_is_locked(group_lock()));
+	C2_POST(c2_mutex_is_locked(group_lock(ctx)));
 }
 
 /** Actions to perform on entering WAIT_REPLY state. */
 static void wait_reply_st_in(struct c2_sm *mach)
 {
 	int rc;
-	struct c2_confc_ctx *ctx = to_ctx(mach);
+	struct c2_confc_ctx *ctx = mach_to_ctx(mach);
 
 	C2_PRE(ctx_invariant(ctx));
 	rc = c2_rpc_post(&ctx->fc_fop.f_item);
@@ -777,9 +786,10 @@ static void wait_reply_st_in(struct c2_sm *mach)
 static void grow_cache_st_in(struct c2_sm *mach)
 {
 	/*
+	 * int                        rc;
 	 * struct c2_conf_fetch_resp *resp;
-	 * int rc;
-	 * struct c2_rpc_item *item = c2_fop_to_rpc_item(&to_ctx(mach)->fc_fop);
+	 * struct c2_confc_ctx       *ctx  = mach_to_ctx(mach);
+	 * struct c2_rpc_item        *item = c2_fop_to_rpc_item(&ctx->fc_fop);
 	 *
 	 * C2_PRE(item->ri_error == 0 && item->ri_reply != NULL);
 	 *
@@ -787,7 +797,7 @@ static void grow_cache_st_in(struct c2_sm *mach)
 	 * C2_ASSERT(`resp' bob_check()s);
 	 *
 	 * rc = resp->fr_rc;
-	 * rc = rc ?: cache_grow(resp);
+	 * rc = rc ?: cache_grow(&ctx->fc_client->cc_registry, resp);
 	 *
 	 * // Let rpc layer free the memory allocated for response.
 	 * c2_rpc_item_put(item->ri_reply);
@@ -802,7 +812,7 @@ static void grow_cache_st_in(struct c2_sm *mach)
 
 static void completion_announce(struct c2_sm *mach)
 {
-	c2_chan_broadcast(&to_ctx(mach)->fc_complete);
+	c2_chan_broadcast(&mach_to_ctx(mach)->fc_complete);
 }
 
 static bool failure_st_invariant(const struct c2_sm *mach)
@@ -841,7 +851,6 @@ static bool on_unpinned(struct c2_clink *link)
 {
 	struct c2_confc_ctx *ctx =
 		container_of(link, struct c2_confc_ctx, fc_clink);
-
 	c2_clink_del(link);
 	ast_state_set(&ctx->fc_ast, S_CHECK);
 	return true;
@@ -914,30 +923,60 @@ static struct c2_sm_conf confc_states_conf = {
 };
 
 /* ------------------------------------------------------------------
- * Confc cache management.
+ * Configuration cache management.
  * ------------------------------------------------------------------ */
 
-static int
-object_enrich(struct c2_conf_obj *dest, const struct confx_object *src)
+/**
+ * Allocates new configuration object and sets its fields from the
+ * on-wire data.
+ *
+ * @param cache  Registry of cached configuration objects.
+ * @param src    Configuration object as received from confd.
+ */
+static int cache_add(struct c2_conf_map *cache, const struct confx_object *src)
+{
+	/*
+	 * struct c2_conf_obj *obj;
+	 * int rc;
+	 *
+	 * obj = c2_conf_obj_new(src->o_val.ov_type, &src->o_key);
+	 * if (obj == NULL)
+	 *     return -ENOMEM;
+	 *
+	 * rc = c2_conf_obj_fill(obj, src, cache);
+	 * rc = ?: c2_conf_map_add(cache, obj);
+	 *
+	 * if (rc != 0)
+	 *     c2_free(obj);
+	 * return rc;
+	 */
+	XXX;
+}
+
+static int object_enrich(struct c2_conf_obj *dest,
+			 const struct confx_object *src,
+			 struct c2_conf_map *cache)
 {
 	/*
-	 * int ret = 0;
-	 * C2_PRE(c2_mutex_is_locked(group_lock()));
-	 * c2_mutex_lock(cache_lock());
+	 * int ret;
+	 * struct c2_confc *cli = registry_to_client(cache);
+	 *
+	 * C2_PRE(c2_mutex_is_locked(&cli->cc_group->s_lock));
+	 * c2_mutex_lock(&cli->cc_lock);
 	 * C2_PRE(dest->co_type == src->fo_val.v_type);
 	 *
 	 * if (c2_conf_obj_mismatch(dest, src)) {
 	 *     c2_addb(report inconsistency);
 	 *     ret = -EMISMATCH; // XXX Can we use non-standard errno?
 	 * } else if (dest->co_status != C2_CS_READY) {
-	 *     ret = c2_conf_obj_fill(dest, src, cache_registry());
+	 *     ret = c2_conf_obj_fill(dest, src, cache);
 	 * }
 	 *
-	 * obj->co_status = rc == 0 ? C2_CS_READY : C2_CS_MISSING;
+	 * obj->co_status = ret == 0 ? C2_CS_READY : C2_CS_MISSING;
 	 * c2_chan_broadcast(&dest->co_chan);
 	 *
-	 * c2_mutex_unlock(cache_lock());
-	 * C2_POST(c2_mutex_is_locked(group_lock()));
+	 * c2_mutex_unlock(&cli->cc_lock);
+	 * C2_POST(c2_mutex_is_locked(&cli->cc_group->s_lock));
 	 * return ret;
 	 */
 	XXX;
@@ -957,38 +996,4 @@ static bool ctx_invariant(struct c2_confc_ctx *ctx)
 		c2_fop_data(ctx->fc_fop) == &ctx->fc_req;
 }
 
-/* ------------------------------------------------------------------
- * XXX Symbols to define.
- * ------------------------------------------------------------------ */
-
-/**
- * Allocates new configuration object and sets its fields from the
- * on-wire data.
- *
- * @param src  Configuration object as received from confd.
- */
-static int
-cache_add(const struct confx_object *src)
-{
-	/*
-	 * struct c2_conf_obj *obj;
-	 * int                 rc;
-	 *
-	 * C2_ASSERT(IS_IN_ARRAY(src->fo_val.v_type, object_ops));
-	 * ops = object_ops + src->fo_val.v_type;
-	 *
-	 * obj = c2_conf_obj_new(src->o_val.ov_type, src->o_key);
-	 * if (obj == NULL)
-	 *     return -ENOMEM;
-	 *
-	 * rc = c2_conf_obj_fill(obj, src, cache_registry());
-	 * rc = ?: c2_conf_map_add(cache_registry(), obj);
-	 *
-	 * if (rc != 0)
-	 *     c2_free(obj);
-	 * return rc;
-	 */
-	XXX;
-}
-
 /** @} confc_dlspec */
diff --git a/conf/confc.h b/conf/confc.h
index 02d0872..7c21f27 100644
--- a/conf/confc.h
+++ b/conf/confc.h
@@ -101,16 +101,17 @@
  * #include "conf/confc.h"
  *
  * struct c2_sm_group *group = ...;
+ * struct c2_confc confc;
  *
  * startup(...) {
- * 	rc = c2_confc_init("profile-name", "confd-endpoint", group);
+ * 	rc = c2_confc_init(&confc, "profile-name", "confd-endpoint", group);
  * 	...
  * }
  *
  * ... Access configuration objects using confc interfaces. ...
  *
  * shutdown(...) {
- * 	c2_confc_fini();
+ * 	c2_confc_fini(confc);
  * }
  * @endcode
  *
@@ -149,6 +150,8 @@
  *
  * struct c2_conf_filesystem; // defined in "conf/obj.h"
  *
+ * struct c2_confc *confc = ...;
+ *
  * static struct c2_conf_filesystem * filesystem_open_a(int32_t *errno)
  * {
  *     struct c2_confc_ctx        ctx;
@@ -158,7 +161,7 @@
  *     struct c2_conf_filesystem *ret = NULL;
  *     int                        rc;
  *
- *     c2_confc_ctx_init(&ctx);
+ *     c2_confc_ctx_init(&ctx, confc);
  *     c2_clink_init(&clink, NULL)
  *     c2_clink_add(&ctx.fc_complete, &clink);
  *
@@ -182,7 +185,7 @@
  * {
  *     struct c2_conf_pathcomp path[] =
  *         { C2_CONF_PATHCOMP_R(C2_CO_FILESYSTEM) };
- *     return c2_confc_open_sync(NULL, path, ARRAY_SIZE(path));
+ *     return c2_confc_open_sync(confc, NULL, path, ARRAY_SIZE(path));
  * }
  * @endcode
  *
@@ -192,6 +195,8 @@
  * #include "conf/confc.h"
  * #include "conf/obj.h" // c2_conf_service
  *
+ * struct c2_confc *confc = ...;
+ *
  * static int service_by_type(enum c2_cfg_service_type tos)
  * {
  *     struct c2_confc_dir    *d;
@@ -201,7 +206,7 @@
  *         C2_CONF_PATHCOMP_R(C2_CO_SERVICE)
  *     };
  *
- *     d = c2_confc_diropen_sync(NULL, path, ARRAY_SIZE(path));
+ *     d = c2_confc_diropen_sync(confc, NULL, path, ARRAY_SIZE(path));
  *     if (d == NULL)
  *         return -1;
  *
@@ -211,7 +216,7 @@
  *         }
  *     }
  *
- *     c2_confc_dirclose(d);
+ *     c2_confc_dirclose(d, confc);
  *     return 0;
  * }
  * @endcode
@@ -222,6 +227,8 @@
  * #include "conf/confc.h"
  * #include "conf/obj.h" // c2_conf_service, c2_conf_node
  *
+ * struct c2_confc *confc = ...;
+ *
  * static int node_devices(enum c2_cfg_service_type svc_type,
  *                         const struct c2_conf_buf *node_key)
  * {
@@ -238,7 +245,7 @@
  *     int ret = -1;
  *
  *     // /fs/services
- *     services = c2_confc_diropen_sync(NULL, path, ARRAY_SIZE(path));
+ *     services = c2_confc_diropen_sync(confc, NULL, path, ARRAY_SIZE(path));
  *     if (services == NULL)
  *         return -1;
  *
@@ -247,43 +254,43 @@
  *             continue;
  *
  *         path[0].pc_u.relation = C2_CO_NODE;
- *         node = c2_confc_open_sync(svc, path, 1); // svc/node
+ *         node = c2_confc_open_sync(confc, svc, path, 1); // svc/node
  *         if (node == NULL)
  *             goto end;
  *
  *         if (!c2_conf_buf_eq(node->cn_obj.co_key, node_key)) {
- *             c2_confc_close(node);
+ *             c2_confc_close(node, confc);
  *             continue;
  *         }
  *
  *         path[0].pc_u.relation = C2_CO_NIC;
- *         d = c2_confc_diropen_sync(node, path, 1); // node/nics
+ *         d = c2_confc_diropen_sync(confc, node, path, 1); // node/nics
  *         if (d == NULL) {
- *             c2_confc_close(node);
+ *             c2_confc_close(node, confc);
  *             goto end;
  *         }
  *         while ((nic = c2_confc_dirnext(d)) != NULL) {
  *             // ... Use `nic' ...
  *         }
- *         c2_confc_dirclose(d);
+ *         c2_confc_dirclose(d, confc);
  *
  *         path[0].pc_u.relation = C2_CO_SDEV;
- *         d = c2_confc_diropen_sync(node, path, 1); // node/sdevs
+ *         d = c2_confc_diropen_sync(confc, node, path, 1); // node/sdevs
  *         if (d == NULL) {
- *             c2_confc_close(node);
+ *             c2_confc_close(node, confc);
  *             goto end;
  *         }
  *         while ((sdev = c2_confc_dirnext(d)) != NULL) {
  *             // ... Use `sdev' ...
  *         }
- *         c2_confc_dirclose(d);
+ *         c2_confc_dirclose(d, confc);
  *
- *         c2_confc_close(node);
+ *         c2_confc_close(node, confc);
  *     }
  *
  *     ret = 0;
  * end:
- *     c2_confc_dirclose(services);
+ *     c2_confc_dirclose(services, confc);
  *     return ret;
  * }
  * @endcode
@@ -301,12 +308,25 @@
 
 struct c2_confc_dir;
 
+/** Configuration client. */
+struct c2_confc {
+	/** Registry of cached configuration objects. */
+	struct c2_conf_map  cc_registry;  /* XXX Rename to cc_cache? */
+	/** Root of the DAG of configuration objects. */
+	struct c2_conf_obj *cc_root;
+	/** Serializes confc state machines. */
+	struct c2_sm_group *cc_group;
+	/** Protects this structure and the DAG from concurrent writes. */
+	struct c2_mutex     cc_lock;
+};
+
 /**
- * Initiates configuration client.
+ * Initialises configuration client.
  *
- * @param profile     Name of profile used by this confc.
+ * @param client      A confc instance to be initialised.
  * @param confd_addr  See the note below. @todo Configuration server's
  *                    end point address.
+ * @param profile     Name of profile used by this confc.
  * @param sm_group    State machine group to be associated with confc
  *                    configuration cache.
  *
@@ -318,11 +338,11 @@ struct c2_confc_dir;
  * @pre   sm_group != NULL
  * @post  equi(retval == 0, confc cache is initiated)
  */
-int c2_confc_init(const char *profile, const char *confd_addr,
-		  struct c2_sm_group *sm_group);
+int c2_confc_init(struct c2_confc *client, const char *confd_addr,
+		  const char *profile, struct c2_sm_group *sm_group);
 
 /**
- * Terminates configuration client. Destroys configuration cache,
+ * Finalises configuration client. Destroys configuration cache,
  * freeing allocated memory.
  *
  * @note Users of confc API must be careful not to call
@@ -336,7 +356,7 @@ int c2_confc_init(const char *profile, const char *confd_addr,
  * @pre   There are no opened (pinned) configuration objects.
  * @post  confc cache is not initiated
  */
-void c2_confc_fini(void);
+void c2_confc_fini(struct c2_confc *client);
 
 /** Configuration retrieval context. */
 struct c2_confc_ctx {
@@ -358,6 +378,8 @@ struct c2_confc_ctx {
 	 */
 	void                *fc_result;
 /* private: internal use only */
+	/** The confc instance this context belongs to. */
+	struct c2_confc     *fc_client;
 	/** A confc state machine. */
 	struct c2_sm         fc_mach;
 	/** Asynchronous system trap. */
@@ -376,7 +398,7 @@ struct c2_confc_ctx {
 	struct c2_clink      fc_clink;
 };
 
-void c2_confc_ctx_init(struct c2_confc_ctx *ctx);
+void c2_confc_ctx_init(struct c2_confc_ctx *ctx, struct c2_confc *client);
 void c2_confc_ctx_fini(struct c2_confc_ctx *ctx);
 
 /** Returns the error status for the asynchronous configuration request. */
@@ -405,7 +427,8 @@ int c2_confc_open(struct c2_confc_ctx *ctx, struct c2_conf_obj *path_origin,
  *
  * @see c2_confc_open()
  */
-void * c2_confc_open_sync(struct c2_conf_obj *path_origin,
+void * c2_confc_open_sync(struct c2_confc *client,
+			  struct c2_conf_obj *path_origin,
 			  const struct c2_conf_pathcomp *path,
 			  size_t path_len);
 
@@ -419,15 +442,16 @@ void * c2_confc_open_sync(struct c2_conf_obj *path_origin,
  * Closes configuration object opened with c2_confc_open() or
  * c2_confc_open_sync().
  *
- * @param obj  The value returned by c2_confc_open_sync() or, in case
- *             of c2_confc_open(), the value taken from
- *             c2_confc_ctx::fc_result.
+ * @param obj     The value returned by c2_confc_open_sync() or, in case
+ *                of c2_confc_open(), the value taken from
+ *                c2_confc_ctx::fc_result.
+ * @param client  The instance of confc this object was opened with.
  *
- * @note  c2_confc_close(NULL) is a noop.
+ * @note  c2_confc_close(NULL,...) is a noop.
  *
  * @pre  ergo(obj != NULL, ((struct c2_conf_obj *)obj)->co_nrefs > 0)
  */
-void c2_confc_close(void *obj);
+void c2_confc_close(void *obj, struct c2_confc *client);
 
 /**
  * Requests an asynchronous opening of a collection of configuration objects.
@@ -450,9 +474,9 @@ int c2_confc_diropen(struct c2_confc_ctx *ctx, struct c2_conf_obj *path_origin,
  *
  * @see c2_confc_diropen()
  */
-struct c2_confc_dir * c2_confc_diropen_sync(struct c2_conf_obj *path_origin,
-					    const struct c2_conf_pathcomp *path,
-					    size_t path_len);
+struct c2_confc_dir *
+c2_confc_diropen_sync(struct c2_confc *client, struct c2_conf_obj *path_origin,
+		      const struct c2_conf_pathcomp *path, size_t path_len);
 
 /**
  * Returns a pointer to the next configuration object of given
@@ -477,9 +501,9 @@ const void * c2_confc_dirnext(struct c2_confc_dir *dir);
  * Closes directory opened with c2_confc_diropen() or
  * c2_confc_diropen_sync().
  *
- * @note  c2_confc_dirclose(NULL) is a noop.
+ * @note  c2_confc_dirclose(NULL,...) is a noop.
  */
-void c2_confc_dirclose(struct c2_confc_dir *dir);
+void c2_confc_dirclose(struct c2_confc_dir *dir, struct c2_confc *client);
 
 /** @} confc_dfspec */
 #endif /* __COLIBRI_CONF_CONFC_H__ */
-- 
1.8.3.2

