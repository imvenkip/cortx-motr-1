From 3bcb348b65b5d3c6a9882a55a1d146a4c8d7ed2e Mon Sep 17 00:00:00 2001
From: "Valery V. Vorotyntsev" <valery_vorotyntsev@xyratex.com>
Date: Thu, 30 Aug 2012 16:44:51 +0300
Subject: [PATCH 341/370] conf: enable conf-reg-ut

+ Add boolean parameter to c2_conf_reg_fini().
---
 conf/confc.c   |  2 +-
 conf/obj_ops.c | 23 +++++++-------
 conf/obj_ops.h | 24 ++++++++++-----
 conf/reg.c     | 20 +++++-------
 conf/reg.h     | 27 ++++++-----------
 conf/ut/obj.c  |  2 +-
 conf/ut/reg.c  | 96 +++++++++++++++++++++++++++++++++++-----------------------
 7 files changed, 105 insertions(+), 89 deletions(-)

diff --git a/conf/confc.c b/conf/confc.c
index 62d22f2..6a8e257 100644
--- a/conf/confc.c
+++ b/conf/confc.c
@@ -320,7 +320,7 @@ void c2_confc_fini(struct c2_confc *confc)
 	 * if (confc->cc_rpc.rcx_remote_addr != NULL)
 	 *     confd_disconnect(&confc->cc_rpc);
 	 *
-	 * c2_confc_reg_fini(&confc->cc_registry);
+	 * c2_conf_reg_fini(&confc->cc_registry, true);
 	 * confc->cc_root = NULL;
 	 *
 	 * confc->cc_group = NULL;
diff --git a/conf/obj_ops.c b/conf/obj_ops.c
index 869e3fd..bfd2728 100644
--- a/conf/obj_ops.c
+++ b/conf/obj_ops.c
@@ -23,6 +23,7 @@
 #endif
 #include "conf/obj_ops.h"
 #include "conf/reg.h"     /* c2_conf_reg_lookup */
+#include "conf/onwire.h"  /* arr_buf */
 /* #include "conf/confc.h"   /\* c2_confc *\/ */
 #include "lib/cdefs.h"    /* ergo, C2_MAGIX_OFFSET, IS_IN_ARRAY */
 #include "lib/arith.h"    /* C2_CNT_INC, C2_CNT_DEC */
@@ -451,20 +452,15 @@ static int dir_new(const struct c2_buf *dir_id, enum c2_conf_objtype child_type,
 
 	if (rc == 0) {
 		c2_conf_reg_add(reg, dir);
-	} else { /* Restore consistency. */
+	} else {
+		/* Restore consistency. */
 		c2_tlist_for(&generic_objs_tl, &(*out)->cd_items, child) {
-			/* Unregister (and finalise) directory element. */
-			c2_conf_reg_delete(reg, child);
-#if 0 /*XXX*/
-			/* XXX This should be done by c2_conf_reg_delete(). */
-			child->co_ops->coo_fini(child);
-			c2_free((void *)child - ot->ot_obj_offset);
-#endif /*XXX*/
+			c2_conf_reg_del(reg, child);
+			c2_conf_obj_delete(child);
 
 		} c2_tlist_endfor;
-
-		/* Finalise the directory itself. */
-		c2_conf_reg_delete(reg, dir);
+		c2_conf_reg_del(reg, dir);
+		c2_conf_obj_delete(dir);
 	}
 
 	return rc;
@@ -476,8 +472,13 @@ static int dir_new(const struct c2_buf *dir_id, enum c2_conf_objtype child_type,
 
 void c2_conf_obj_delete(struct c2_conf_obj *obj)
 {
+	/* XXX C2_PRE(c2_conf_obj_invariant(obj)); */
+	C2_PRE(obj->co_nrefs == 0 && obj->co_status != C2_CS_LOADING);
+
 	obj->co_ops->coo_fini(obj);
 	/* XXX Finalise generic object. */
+
+	c2_free((void *)obj - obj_type(obj->co_type)->ot_obj_offset);
 }
 
 /* ------------------------------------------------------------------
diff --git a/conf/obj_ops.h b/conf/obj_ops.h
index 1fcfbe5..9948073 100644
--- a/conf/obj_ops.h
+++ b/conf/obj_ops.h
@@ -21,8 +21,7 @@
 #ifndef __COLIBRI_CONF_OBJOPS_H__
 #define __COLIBRI_CONF_OBJOPS_H__
 
-#include "conf/obj.h"
-#include "conf/onwire.h"
+#include "conf/obj.h" /* c2_conf_objtype */
 
 /**
  * @page conf-fspec-objops Configuration Object Operations
@@ -37,12 +36,15 @@
  *
  * @section conf-fspec-objops-sub Subroutines
  *
- * - c2_conf_obj_new() allocates and initialises new configuration object.
+ * - c2_conf_obj_new() allocates and initialises configuration object.
+ * - c2_conf_obj_delete() finalises and frees configuration object.
+ *
  * - c2_conf_obj_match() compares cached configuration object with its
  *   on-wire representation.
  * - c2_conf_obj_fill() enriches a stub with configuration data.
  *
  * - c2_conf_obj_invariant() checks validity of a configuration object.
+ *
  * - c2_conf_obj_get() increases and c2_conf_obj_put() decreases
  *   object's number of references.
  *
@@ -64,6 +66,7 @@ C2_TL_DECLARE(c2_conf_reg, , struct c2_conf_obj);
 
 /* import */
 struct c2_conf_reg;
+struct confx_object;
 
 /** Magic value for a generic configuration object (c2_conf_obj). */
 enum { C2_CONF_OBJ_MAGIC = 0x335e1f1e55ce1177 /* selfless cell */ };
@@ -127,11 +130,12 @@ struct c2_conf_obj_ops {
 			  const struct confx_object *onwire);
 
 	/**
-	 * Destructor of configuration object.
+	 * Finalises the concrete fields of given configuration objects.
+	 *
+	 * ->coo_fini() neither finalises generic fields (those of
+	 * c2_conf_obj), nor c2_free()s the configuration object.
 	 *
-	 * The intended usage of ->coo_fini() is to free the allocated
-	 * concrete object (i.e., the ambient object that `obj' is
-	 * embedded in).
+	 * @see c2_conf_obj_delete()
 	 */
 	void (*coo_fini)(struct c2_conf_obj *obj);
 };
@@ -176,7 +180,11 @@ void c2_conf_obj_put(struct c2_conf_obj *obj);
 struct c2_conf_obj *c2_conf_obj_new(enum c2_conf_objtype type,
 				    const struct c2_buf *id);
 
-/** XXX */
+/**
+ * Finalises and frees concrete configuration object.
+ *
+ * @pre  obj->co_nrefs == 0 && obj->co_status != C2_CS_LOADING
+ */
 void c2_conf_obj_delete(struct c2_conf_obj *obj);
 
 /**
diff --git a/conf/reg.c b/conf/reg.c
index d529a64..b54ec7c 100644
--- a/conf/reg.c
+++ b/conf/reg.c
@@ -22,7 +22,7 @@
 #  include "config.h"
 #endif
 #include "conf/reg.h"
-#include "conf/obj_ops.h" /* C2_CONF_OBJ_MAGIC */
+#include "conf/obj_ops.h" /* C2_CONF_OBJ_MAGIC, c2_conf_obj_delete */
 #include "lib/memory.h"   /* C2_ALLOC_PTR */
 #include "lib/errno.h"    /* ENOMEM */
 
@@ -69,26 +69,20 @@ struct c2_conf_obj *c2_conf_reg_lookup(const struct c2_conf_reg *reg,
 	return obj;
 }
 
-static void del(struct c2_conf_obj *obj)
-{
-	C2_PRE(obj->co_nrefs == 0 && obj->co_status != C2_CS_LOADING);
-
-	c2_conf_reg_tlist_del(obj);
-	obj->co_ops->coo_fini(obj);
-}
-
-void c2_conf_reg_delete(const struct c2_conf_reg *reg, struct c2_conf_obj *obj)
+void c2_conf_reg_del(const struct c2_conf_reg *reg, struct c2_conf_obj *obj)
 {
 	C2_PRE(c2_conf_reg_tlist_contains(&reg->r_objs, obj));
-	del(obj);
+	c2_conf_reg_tlist_del(obj);
 }
 
-void c2_conf_reg_fini(struct c2_conf_reg *reg)
+void c2_conf_reg_fini(struct c2_conf_reg *reg, bool delete)
 {
 	struct c2_conf_obj *obj;
 
 	c2_tlist_for(&c2_conf_reg_tl, &reg->r_objs, obj) {
-		del(obj);
+		c2_conf_reg_tlist_del(obj);
+		if (delete)
+			c2_conf_obj_delete(obj);
 	} c2_tlist_endfor;
 
 	c2_conf_reg_tlist_fini(&reg->r_objs);
diff --git a/conf/reg.h b/conf/reg.h
index 19fd314..3ea081f 100644
--- a/conf/reg.h
+++ b/conf/reg.h
@@ -45,14 +45,12 @@
  * @section conf-fspec-reg-sub Subroutines
  *
  * - c2_conf_reg_init() initialises a registry.
- * - c2_conf_reg_fini() finalises a registry, freeing all of the
- *   registered configuration objects.
+ * - c2_conf_reg_fini() finalises a registry.
  *
- * - c2_conf_reg_add() registers new configuration object.
+ * - c2_conf_reg_add() registers configuration object.
  * - c2_conf_reg_lookup() returns the address of registered
  *   configuration object given its identity.
- * - c2_conf_reg_delete() unregisters configuration object and calls
- *   its destructor.
+ * - c2_conf_reg_del() unregisters configuration object.
  *
  * @section conf-fspec-reg-thread Concurrency control
  *
@@ -88,29 +86,24 @@ void c2_conf_reg_init(struct c2_conf_reg *reg);
 /**
  * Finalises a registry.
  *
- * c2_conf_reg_fini() calls c2_conf_obj_ops::coo_fini() on every
- * registered configuration object.
- *
- * @pre  c2_tl_forall(c2_conf_reg, obj, &reg->r_objs,
- *                    obj->co_nrefs == 0 && obj->co_status != C2_CS_LOADING)
+ * If `delete' parameter is true, the function c2_conf_obj_delete()s
+ * every registered configuration object.
  */
-void c2_conf_reg_fini(struct c2_conf_reg *reg);
+void c2_conf_reg_fini(struct c2_conf_reg *reg, bool delete);
 
 /**
- * Registers new configuration object.
+ * Registers configuration object.
  *
  * @pre  !c2_conf_reg_tlink_is_in(obj)
  */
 void c2_conf_reg_add(struct c2_conf_reg *reg, struct c2_conf_obj *obj);
 
 /**
- * Un-registers configuration object and calls its destructor
- * (c2_conf_obj_ops::coo_fini()).
+ * Un-registers configuration object.
  *
- * @pre  obj is registered
- * @pre  obj->co_nrefs == 0 && obj->co_status != C2_CS_LOADING
+ * @pre  c2_conf_reg_tlist_contains(&reg->r_objs, obj)
  */
-void c2_conf_reg_delete(const struct c2_conf_reg *reg, struct c2_conf_obj *obj);
+void c2_conf_reg_del(const struct c2_conf_reg *reg, struct c2_conf_obj *obj);
 
 /**
  * Searches for a configuration object given its identity (type & id).
diff --git a/conf/ut/obj.c b/conf/ut/obj.c
index 1a8bfa5..f67f150 100644
--- a/conf/ut/obj.c
+++ b/conf/ut/obj.c
@@ -48,7 +48,7 @@ static void test_new(void)
 	/* XXX TODO: check concrete fields */
 
 	c2_conf_obj_delete(obj);
-	c2_conf_reg_fini(&reg);
+	c2_conf_reg_fini(&reg, true);
 }
 
 const struct c2_test_suite conf_obj_ut = {
diff --git a/conf/ut/reg.c b/conf/ut/reg.c
index 024a652..6011ec0 100644
--- a/conf/ut/reg.c
+++ b/conf/ut/reg.c
@@ -21,71 +21,91 @@
 #ifdef HAVE_CONFIG_H
 #  include "config.h"
 #endif
-/* #include "conf/reg.c" */
+#include "conf/reg.h"
+#include "conf/obj_ops.h" /* c2_conf_obj_ops */
+#include "lib/memory.h"   /* C2_ALLOC_PTR */
+#include "lib/buf.h"      /* c2_buf, C2_BUF_INITS */
 #include "lib/ut.h"
 
-#if 0 /*XXX*/
 static size_t g_nr_finalised = 0;
 
-static void obj_fini(struct c2_conf_obj *obj __attribute__((unused)))
+static void obj_fini(struct c2_conf_obj *obj)
 {
+	c2_buf_free(&obj->co_id);
+	c2_conf_reg_tlink_fini(obj);
 	++g_nr_finalised;
 }
 
+const struct c2_conf_obj_ops g_ops = { .coo_fini = obj_fini };
+
+static struct c2_conf_obj *
+obj_new(enum c2_conf_objtype type, const struct c2_buf *id)
+{
+	struct c2_conf_obj *obj;
+	int                 rc;
+
+	C2_ALLOC_PTR(obj);
+	if (obj == NULL)
+		return NULL;
+
+	obj->co_type = type;
+	obj->co_ops = &g_ops;
+	c2_conf_reg_tlink_init(obj);
+
+	rc = c2_buf_copy(&obj->co_id, id);
+	if (rc != 0) {
+		c2_free(obj);
+		return NULL;
+	}
+
+	return obj;
+}
+
 static void test_reg(void)
 {
-	struct c2_conf_reg           reg;
-	struct c2_conf_obj          *obj;
-	size_t                       i;
-	const struct c2_conf_obj_ops ops = { .coo_fini = obj_fini };
-	struct c2_conf_obj           samples[] = {
-		{
-			.co_type = C2_CO_NODE,
-			.co_id   = C2_CONF_BUF_INITS("node"),
-			.co_ops  = &ops
-		},
-		{
-			.co_type = C2_CO_DIR,
-			.co_id   = C2_CONF_BUF_INITS("dir"),
-			.co_ops  = &ops
-		},
-		{
-			.co_type = C2_CO_NIC,
-			.co_id   = C2_CONF_BUF_INIT(4, "ni\0c"),
-			.co_ops  = &ops
-		}
+	struct c2_conf_reg  reg;
+	struct c2_conf_obj *obj;
+	size_t              i;
+	struct {
+		enum c2_conf_objtype type;
+		struct c2_buf        id;
+	} samples[] = {
+		{ C2_CO_NODE, C2_BUF_INITS("node") },
+		{ C2_CO_DIR,  C2_BUF_INITS("dir") },
+		{ C2_CO_NIC,  C2_BUF_INIT(4, "ni\0c") }
 	};
 
 	c2_conf_reg_init(&reg);
 
-	for (i = 0; i < sizeof samples; ++i) {
-		obj = c2_conf_reg_lookup(&reg, samples[i].co_type,
-					 &samples[i].co_id);
-		C2_UT_ASSERT(obj == NULL);
+	for (i = 0; i < ARRAY_SIZE(samples); ++i) {
+		C2_UT_ASSERT(c2_conf_reg_lookup(&reg, samples[i].type,
+						&samples[i].id) == NULL);
+
+		obj = obj_new(samples[i].type, &samples[i].id);
+		C2_UT_ASSERT(obj != NULL);
+		c2_conf_reg_add(&reg, obj);
 
-		c2_conf_reg_add(&reg, &samples[i]);
-		obj = c2_conf_reg_lookup(&reg, samples[i].co_type,
-					 &samples[i].co_id);
-		C2_UT_ASSERT(obj == &samples[i]);
+		C2_UT_ASSERT(c2_conf_reg_lookup(&reg, samples[i].type,
+						&samples[i].id) == obj);
 	}
 
+	c2_conf_reg_del(&reg, obj);
+	C2_UT_ASSERT(c2_conf_reg_lookup(&reg, obj->co_type, &obj->co_id) ==
+		     NULL);
 	C2_UT_ASSERT(g_nr_finalised == 0);
-	c2_conf_reg_delete(&reg, obj);
+	c2_conf_obj_delete(obj);
 	C2_UT_ASSERT(g_nr_finalised == 1);
-	obj = c2_conf_reg_lookup(&reg, obj->co_type, obj->co_id);
-	C2_UT_ASSERT(obj == NULL);
 
-	c2_conf_reg_fini(&reg);
-	C2_UT_ASSERT(g_nr_finalised == sizeof samples);
+	c2_conf_reg_fini(&reg, true);
+	C2_UT_ASSERT(g_nr_finalised == ARRAY_SIZE(samples));
 }
-#endif /*XXX*/
 
 const struct c2_test_suite conf_reg_ut = {
 	.ts_name  = "conf-reg-ut",
 	.ts_init  = NULL,
 	.ts_fini  = NULL,
 	.ts_tests = {
-		/* { "conf-reg", test_reg }, */
+		{ "conf-reg", test_reg },
 		{ NULL, NULL }
 	}
 };
-- 
1.8.3.2

