From 64d61a31cff18f02b272cd795be0db8538033201 Mon Sep 17 00:00:00 2001
From: "Valery V. Vorotyntsev" <valery_vorotyntsev@xyratex.com>
Date: Mon, 6 Feb 2012 00:16:20 +0200
Subject: [PATCH 001/370] initial (backup) commit of `conf' directory

---
 conf/conf.c     |  35 ++++++++++
 conf/conf.h     | 181 ++++++++++++++++++++++++++++++++++++++++++++++++++
 conf/confc.c    | 202 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 conf/confc.h    | 101 ++++++++++++++++++++++++++++
 conf/confop.ff  | 159 ++++++++++++++++++++++++++++++++++++++++++++
 conf/path.h     |  48 ++++++++++++++
 conf/relation.c |  99 +++++++++++++++++++++++++++
 conf/relation.h |  60 +++++++++++++++++
 conf/ut/conf.c  |  31 +++++++++
 9 files changed, 916 insertions(+)
 create mode 100644 conf/conf.c
 create mode 100644 conf/conf.h
 create mode 100644 conf/confc.c
 create mode 100644 conf/confc.h
 create mode 100644 conf/confop.ff
 create mode 100644 conf/path.h
 create mode 100644 conf/relation.c
 create mode 100644 conf/relation.h
 create mode 100644 conf/ut/conf.c

diff --git a/conf/conf.c b/conf/conf.c
new file mode 100644
index 0000000..c74f490
--- /dev/null
+++ b/conf/conf.c
@@ -0,0 +1,35 @@
+/* -*- c -*- */
+/*
+ * COPYRIGHT 2012 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: Valery V. Vorotyntsev <valery_vorotyntsev@xyratex.com>
+ * Original creation date: 03-Feb-2012
+ */
+
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+#include "conf/conf.h"
+
+enum {
+	CONF_FSSVC_HEAD_MAGIC   = 0x66732f7376632020, /* "fs/svc  " */
+	CONF_NDSVC_HEAD_MAGIC   = 0x6e6f64652f737663, /* "node/svc" */
+	CONF_SERVICE_LINK_MAGIC = 0x7365727669636520  /* "service " */
+};
+
+C2_TL_DESCR_DEFINE(c2_conf_filesystem_services,
+		   "c2_conf_filesystem::cf_services", ,
+		   struct c2_conf_service, cs_filesystem_linkage, cs_magic,
+		   CONF_SERVICE_LINK_MAGIC, CONF_FSSVC_HEAD_MAGIC);
diff --git a/conf/conf.h b/conf/conf.h
new file mode 100644
index 0000000..4935578
--- /dev/null
+++ b/conf/conf.h
@@ -0,0 +1,181 @@
+/* -*- c -*- */
+/*
+ * COPYRIGHT 2012 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: Valery V. Vorotyntsev <valery_vorotyntsev@xyratex.com>
+ * Original creation date: 30-Jan-2012
+ */
+#ifndef __COLIBRI_CONF_CONF_H__
+#define __COLIBRI_CONF_CONF_H__
+
+/* XXX @todo Move definitions from cfg/cfg.h to conf/schema.h */
+#include "cfg/cfg.h"
+
+#include "lib/chan.h"  /* c2_chan */
+#include "fid/fid.h"   /* c2_fid */
+#include "lib/tlist.h" /* c2_tl */
+#include "lib/types.h"
+
+/** Type of configuration object. */
+enum c2_conf_objtype {
+	C2_CO_PROFILE,
+	C2_CO_FILESYSTEM,
+	C2_CO_SERVICE,
+	C2_CO_NODE,
+	C2_CO_NIC,
+	C2_CO_SDEV,
+	C2_CO_PARTITION,
+	C2_CO_NR
+};
+
+/** Checks the value of c2_conf_objtype. */
+static inline bool c2_conf_objtype_invariant(enum c2_conf_objtype x)
+{
+	return C2_CO_PROFILE <= x && x < C2_CO_NR;
+}
+
+/** Sequence of bytes. */
+struct c2_conf_bytes {
+	size_t   cb_len;
+	uint8_t *cb_data;
+};
+
+/** Status of configuration object. */
+enum c2_conf_status {
+	C2_CS_MISSING, /*< Configuration is absent; no retrieval in progress. */
+	C2_CS_LOADING, /*< Retrieval of configuration is in progress. */
+	C2_CS_READY    /*< Configuration is available. */
+};
+
+/** Abstract configuration object. */
+struct c2_conf_obj {
+	enum c2_conf_objtype co_type;
+	struct c2_conf_bytes co_key;
+	enum c2_conf_status  co_status;
+
+	/**
+	 * Reference counter.
+	 *
+	 * The object is "pinned" if this value is non-zero.
+	 */
+	uint64_t co_nrefs;
+
+	/**
+	 * Channel on which "status updated" and "object unpinned"
+	 * events are announced.
+	 */
+	struct c2_chan co_chan;
+};
+
+struct c2_conf_filesystem;
+
+struct c2_conf_profile {
+	struct c2_conf_obj         cp_obj;
+	struct c2_conf_filesystem *cp_filesystem;
+};
+
+/** Configuration cache. */
+struct c2_conf_cache {
+	/** Root configuration object. */
+	struct c2_conf_profile cc_root;
+
+	/** Serializes confc state machines. */
+	struct c2_sm_group    *cc_sm_group;
+
+	/**
+	 * Protects this structure and the DAG of configuration
+	 * objects from concurrent writes.
+	 */
+	struct c2_mutex        cc_lock;
+};
+
+struct c2_conf_filesystem {
+	struct c2_conf_obj cf_obj;
+	struct c2_fid      cf_rootfid;
+	uint64_t           cf_params[C2_CFG_PARAM_LEN];
+
+	/**
+	 * Services running in this filesystem.
+	 *
+	 * List of c2_conf_service objects, linked through
+	 * cs_filesystem_linkage member.
+	 */
+	struct c2_tl       cf_services;
+};
+
+struct c2_conf_node;
+
+struct c2_conf_service {
+	struct c2_conf_obj         cs_obj;
+	struct c2_conf_filesystem *cs_filesystem;
+	enum c2_cfg_service_type   cs_type;
+	char cs_endpoints[C2_CFG_SERVICE_MAX_END_POINTS][C2_CFG_NAME_LEN];
+	struct c2_conf_node       *cs_node;
+
+	/** Linkage to c2_conf_filesystem::cf_services. */
+	struct c2_tlink            cs_filesystem_linkage;
+
+	/** Magic for a list of services. */
+	uint64_t cs_magic;
+};
+
+/** Descriptor for a tlist of filesystem's services. */
+C2_TL_DESCR_DECLARE(c2_conf_filesystem_services, extern);
+
+struct c2_conf_node {
+	struct c2_conf_obj cn_obj;
+	struct c2_tl       cn_services;
+	uint32_t           cn_memsize;
+	uint32_t           cn_nr_processors;
+	uint64_t           cn_last_state;
+	uint64_t           cn_flags;
+	uint64_t           cn_pool_id;
+	struct c2_tl       cn_nics;
+	struct c2_tl       cn_sdevs;
+};
+
+struct c2_conf_nic {
+	struct c2_conf_obj   ni_obj;
+	struct c2_conf_node *ni_node;
+	uint32_t             ni_iface_type;
+	uint32_t             ni_mtu;
+	uint64_t             ni_speed;
+	char                 ni_filename[C2_CFG_NAME_LEN];
+	uint64_t             ni_last_state;
+};
+
+struct c2_conf_sdev {
+	struct c2_conf_obj   sd_obj;
+	struct c2_conf_node *sd_node;
+	uint32_t             sd_type;
+	uint32_t             sd_media;
+	uint64_t             sd_size;
+	uint64_t             sd_last_state;
+	uint64_t             sd_flags;
+	char                 sd_filename[C2_CFG_NAME_LEN];
+	struct c2_tl         sd_partitions;
+};
+
+struct c2_conf_partition {
+	struct c2_conf_obj   pa_obj;
+	struct c2_conf_sdev *pa_sdev;
+	uint64_t             pa_start;
+	uint64_t             pa_size;
+	uint32_t             pa_index;
+	uint32_t             pa_type;
+	char                 pa_filename[C2_CFG_NAME_LEN];
+};
+
+#endif /* __COLIBRI_CONF_CONF_H__ */
diff --git a/conf/confc.c b/conf/confc.c
new file mode 100644
index 0000000..9f630ea
--- /dev/null
+++ b/conf/confc.c
@@ -0,0 +1,202 @@
+/* -*- c -*- */
+/*
+ * COPYRIGHT 2012 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: Valery V. Vorotyntsev <valery_vorotyntsev@xyratex.com>
+ * Original creation date: 30-Jan-2012
+ */
+
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+#include "conf/confc.h"
+
+static struct c2_conf_cache cache; /*< Confc's configuration cache. */
+
+enum { S_INITIAL, S_CHECK, S_WAIT_REPLY, S_WAIT_STATUS, S_GROW_CACHE,
+       S_FAILURE, S_TERMINAL, S_NR };
+
+/**
+ * @pre   c2_conf_path_invariant(path)
+ * @post  ergo(retval == 0, *result is valid status)
+ *
+ * @retval -ENOENT  `path' contains nonexistent key.
+ */
+int cache_path_check(struct c2_conf_cache *cache,
+		     const struct c2_conf_path *path,
+		     enum c2_conf_status *result)
+{
+	struct c2_conf_obj *parent = path->p_origin ?: &cache->cc_root.cp_obj;
+	struct c2_conf_pathcomp *comp = path->p_comps;
+	size_t nr = path->p_nr_comps; /* remaining number of components */
+	bool target_is_directory = false;
+
+	C2_ASSERT(c2_conf_path_invariant(path));
+	*result = parent->co_status;
+
+	for (; nr > 0; --nr, ++comp) {
+		const struct c2_conf_relation *rel;
+		struct c2_conf_obj *child;
+		C2_ASSERT(!comp->pc_iskey);
+
+		rel = c2_conf_downlink(obj->co_type, comp->pc_u.relation);
+		C2_ASSERT(rel != NULL);
+		target_is_directory = rel->r_dir != NULL;
+
+		if (target_is_directory) {
+			if (nr == 1) { /* the last path component */
+				/* XXX directory_scan():
+				 * - if all of the objects are LOADING ---
+				 *   return LOADING;
+				 * - if MISSING objects are found ---
+				 *   change their statuses to LOADING
+				 *   and return MISSING;
+				 * - otherwise all objects are READY ---
+				 *   return READY.
+				 */
+				*result = directory_scan(XXX);
+				break;
+			}
+
+			--nr;
+			++comp;
+			C2_ASSERT(comp->pc_iskey);
+
+			child = XXX_find(XXX_dir, comp->pc_u.key);
+			if (child == NULL) /* no such key */
+				return -ENOENT;
+
+		} else {
+			obj = *(struct c2_conf_obj **)((void *)obj + rel->r_offset);
+			C2_ASSERT(obj->co_type == rel->r_type);
+			XXX; /* check obj->co_status */
+			XXX;
+		}
+	}
+
+	/* C2_ASSERT(parent->co_status == C2_CS_READY); */
+	/* /\* XXX */
+	/*  * ++parent->co_nrefs; */
+	/*  * fetchctx->fc_result = parent */
+	/*  *\/ */
+	/* *result = C2_CS_READY; */
+
+	if (*result == C2_CS_READY) {
+		++parent->co_nrefs;
+		if (target_is_directory) {
+			/* XXX fetchctx->fc_result = dir_allocate() */
+		} else {
+			/* XXX fetchctx->fc_result = parent */
+		}
+	} else if (*result == C2_CS_MISSING) {
+		if (!target_is_directory) {
+			C2_ASSERT(parent->co_status == C2_CS_MISSING);
+			parent->co_status = C2_CS_LOADING;
+		}
+
+		/* XXX
+		 * fop->path = { .p_origin   = parent,
+		 *               .p_nr_comps = nr,
+		 *               .p_comps    = comp }
+		 */
+	} else if (*result == C2_CS_LOADING) {
+		if (target_is_directory) {
+			/* XXX scan directory, adding clinks */
+		} else {
+			/* XXX clink_add(&parent->co_chan) */
+		}
+	} else {
+		C2_IMPOSSIBLE("XXX");
+	}
+
+	return 0;
+}
+
+/**
+ * Confc states.
+ *
+ * - INITIAL
+ *   - CHECK
+ *
+ * - CHECK
+ *   in:
+ *   - Lock the configuration cache (c2_conf_cache::cc_lock).
+ *   - [[Traverse the cache as instructed by the path]]
+ *     (c2_confc_fetchctx::fc__path) and check the statuses of
+ *     configuration objects located on this path.
+ ***********************************************************************
+ * Results of traversal: all objects are C2_CS_READY
+ *                     | some objects are C2_CS_MISSING (the function
+ *                       sets their statuses to C2_CS_LOADING)
+ *                     | unready objects are C2_CS_LOADING
+ *                     | path is invalid
+ ***********************************************************************
+ *   - If all of the objects are C2_CS_READY then:
+ *     - increment reference counter (c2_conf_obj::co_nrefs) of the
+ *       requested object or the parent of the requested collection;
+ *     - set result pointer (c2_confc_fetchctx::fc_result);
+ *     - move to TERMINAL state.
+ *   - Otherwise:
+ *   ex: Unlock the configuration cache.
+ *   allowed:
+ *   - TERMINAL
+ *   - WAIT_REPLY
+ *   - WAIT_STATUS
+ *
+ */
+const struct c2_sm_state_descr confc_states[S_NR] = {
+	[S_INITIAL] = {
+		.sd_flags     = C2_SDF_INITIAL,
+		.sd_name      = "INITIAL",
+		.sd_in        = NULL,
+		.sd_ex        = NULL,
+		.sd_invariant = NULL,
+		.sd_allowed   = (1 << S_CHECK),
+	},
+};
+
+struct c2_sm_conf confc_states_conf = {
+	.scf_name      = "confc states",
+	.scf_nr_states = S_NR,
+	.scf_state     = confc_states
+};
+
+int c2_confc_open(const struct c2_conf_path *path,
+		  struct c2_confc_fetchctx *ctx)
+{
+/*
+ * - Check the precondition.
+ * - Set the path (fc__path).
+ * - c2_sm_group_lock(cache.cc_sm_group);
+ * - c2_sm_state_set(&ctx->fc_mach, S_CHECK);
+ */
+}
+C2_EXPORTED(c2_confc_open);
+
+/** Collection of configuration objects. */
+struct c2_confc_dir {
+	/** Parent object this collection belongs to. */
+	struct c2_conf_obj *d_parent;
+
+	/**
+	 * Currently opened (and pinned) element of this collection.
+	 *
+	 * The value is updated by c2_confc_dirnext().
+	 */
+	struct c2_conf_obj *d_current;
+
+	/** List descriptor. */
+	const struct c2_tl_descr *d_descr;
+};
diff --git a/conf/confc.h b/conf/confc.h
new file mode 100644
index 0000000..3505277
--- /dev/null
+++ b/conf/confc.h
@@ -0,0 +1,101 @@
+/* -*- c -*- */
+/*
+ * COPYRIGHT 2012 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: Valery V. Vorotyntsev <valery_vorotyntsev@xyratex.com>
+ * Original creation date: 30-Jan-2012
+ */
+#ifndef __COLIBRI_CONF_CONFC_H__
+#define __COLIBRI_CONF_CONFC_H__
+
+#include "sm/sm.h" /* c2_sm, c2_sm_ast */
+
+/**
+ * Initiates configuration client.
+ *
+ * @param profile     Name of profile used by this confc.
+ * @param confd_addr  Configuration server end point address.
+ * @param sm_group    State machine group that will be associated with
+ *                    configuration cache.
+ */
+int c2_confc_init(const char *profile, const char *confd_addr,
+		  struct c2_sm_group *sm_group);
+
+/**
+ * Terminates configuration client. Destroys configuration cache,
+ * freeing allocated memory.
+ *
+ * @pre  There are no opened (pinned) configuration objects.
+ */
+void c2_confc_fini(void);
+
+struct c2_conf_path;
+
+struct c2_confc_fetchctx {
+	struct c2_sm fc_mach;
+	void        *fc_result;
+	int          fc_errno;
+
+	/* The remaining fields (fc__*) are not supposed to be
+	 * accessed by configuration consumers. */
+
+	/* Path to the requested object or directory (collection of objects). */
+	const struct c2_conf_path *fc__path;
+
+	struct c2_confop_fetch     fc__fop;
+	struct c2_sm_ast           fc__ast;
+};
+
+/*
+ * A caller must guarantee existence and immutability of `path' until
+ * ctx->fc_mach terminates or fails.
+ *
+ * @pre  ctx is initiated: its state machine is in INITIAL state,
+ *       results are unset, and the path is NULL.
+ */
+int c2_confc_open(const struct c2_conf_path *path,
+		  struct c2_confc_fetchctx *ctx);
+
+/*
+ * Synchronous variant of c2_confc_open(). Returns a pointer to the
+ * requested configuration object or NULL in case of error.
+ */
+void * c2_confc_open_sync(const struct c2_conf_path *path);
+
+void c2_confc_close(void *obj);
+
+/*
+ * A caller must guarantee existence and immutability of `path' until
+ * ctx->fc_mach terminates or fails.
+ *
+ * @pre  `path' is not empty and its last component is a relation (not a key)
+ */
+int c2_confc_diropen(const struct c2_conf_path *path,
+		     struct c2_confc_fetchctx *ctx);
+
+struct c2_confc_dir;
+
+/*
+ * Synchronous variant of c2_confc_diropen(). Returns a pointer to the
+ * requested collection (directory) of configuration objects or NULL
+ * in case of error.
+ */
+struct c2_confc_dir * c2_confc_diropen_sync(const struct c2_conf_path *path);
+
+void * c2_confc_dirnext(struct c2_confc_dir *dir);
+
+void c2_confc_dirclose(struct c2_confc_dir *dir);
+
+#endif /* __COLIBRI_CONF_CONFC_H__ */
diff --git a/conf/confop.ff b/conf/confop.ff
new file mode 100644
index 0000000..22841dd
--- /dev/null
+++ b/conf/confop.ff
@@ -0,0 +1,159 @@
+/* -*- c -*- */
+/*
+ * COPYRIGHT 2012 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: Valery V. Vorotyntsev <valery_vorotyntsev@xyratex.com>
+ * Original creation date: 30-Jan-2012
+ */
+
+/* XXX @todo Move definitions from cfg/cfg.h to conf/schema.h */
+require "cfg/cfg"; /* C2_CFG_NAME_LEN, C2_CFG_PARAM_LEN,
+		    * C2_CFG_SERVICE_MAX_END_POINTS */
+
+/* Sequence of bytes. */
+sequence {
+	u32 fb_len;
+	u8  fb_data
+} c2_confop_bytes;
+
+/* Array of C2_CFG_NAME_LEN bytes. cfg/cfg.h puts names in such arrays. */
+sequence {
+	void n_none :C2_CFG_NAME_LEN;
+	u8   n_data
+} c2_confop_fixstr;
+
+/* Configuration request FOP. */
+record {
+	/*
+	 * Type of the requested configuration object.
+	 * See c2_conf_objtype for values.
+	 */
+	u32             ff_objtype;
+
+	/* Key of the requested object. */
+	c2_confop_bytes ff_objkey;
+
+	/* Depth of retrieval. */
+	u32             ff_depth
+} c2_confop_fetch;
+
+/* Configuration of a profile. */
+record {
+	c2_confop_fixstr fp_filesystem /* Name of profile's filesystem. */
+} c2_confop_profile;
+
+/* Configuration of a filesystem. */
+record {
+	record {
+		u64 f_container;
+		u64 f_key
+	} ff_rootfid; /* Root fid. */
+	sequence {
+		void p_none :C2_CFG_PARAM_LEN;
+		u64  p_data
+	} ff_params   /* Filesystem parameters. */
+} c2_confop_filesystem;
+
+/* Configuration of a service. */
+record {
+	/* Parent filesystem. */
+	c2_confop_bytes fs_filesystem;
+
+	/* Service type. See c2_cfg_service_type for values. */
+	u32             fs_type;
+
+	/* End-points from which this service is reachable. */
+	sequence {
+		void             e_none :C2_CFG_SERVICE_MAX_END_POINTS;
+		c2_confop_fixstr e_data
+	} fs_endpoints;
+
+	/* Hosting node. */
+	c2_confop_bytes fs_node
+} c2_confop_service;
+
+record {
+	sequence {
+		u32             s_nr;
+		c2_confop_bytes s_data
+	} fn_services;
+	u32 fn_memsize;
+	u32 fn_nr_processors;
+	u64 fn_last_state;
+	u64 fn_flags;
+	u64 fn_pool_id;
+	sequence {
+		u32             n_nr;
+		c2_confop_bytes n_data
+	} fn_nics;
+	sequence {
+		u32             d_nr;
+		c2_confop_bytes d_data
+	} fn_sdevs
+} c2_confop_node;
+
+record {
+	c2_confop_bytes  fn_node;
+	u32              fn_iface_type;
+	u32              fn_mtu;
+	u64              fn_speed;
+	c2_confop_fixstr fn_filename;
+	u64              fn_last_state
+} c2_confop_nic;
+
+record {
+	c2_confop_bytes  fd_node;
+	u32              fd_type;
+	u32              fd_media;
+	u64              fd_size;
+	u64              fd_last_state;
+	u64              fd_flags;
+	c2_confop_fixstr fd_filename;
+	sequence {
+		u32             p_nr;
+		c2_confop_bytes p_data
+	} fd_partitions
+} c2_confop_sdev;
+
+record {
+	c2_confop_bytes  fp_sdev;
+	u64              fp_start;
+	u64              fp_size;
+	u32              fp_index;
+	u32              fp_type;
+	c2_confop_fixstr fp_filename
+} c2_confop_partition;
+
+record {
+	c2_confop_bytes fo_objkey;
+	union {
+		u8                   v_objtype;
+		c2_confop_profile    v_profile;
+		c2_confop_filesystem v_filesystem;
+		c2_confop_service    v_service;
+		c2_confop_node       v_node;
+		c2_confop_nic        v_nic;
+		c2_confop_sdev       v_sdev;
+		c2_confop_partition  v_partition
+	} fo_val
+} c2_confop_obj;
+
+record {
+	u32 ffr_rc;
+	sequence {
+		u32           d_nr;
+		c2_confop_obj d_objs
+	} ffr_data
+} c2_confop_fetch_resp
diff --git a/conf/path.h b/conf/path.h
new file mode 100644
index 0000000..633115c
--- /dev/null
+++ b/conf/path.h
@@ -0,0 +1,48 @@
+/* -*- c -*- */
+/*
+ * COPYRIGHT 2012 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: Valery V. Vorotyntsev <valery_vorotyntsev@xyratex.com>
+ * Original creation date: 30-Jan-2012
+ */
+#ifndef __COLIBRI_CONF_PATH_H__
+#define __COLIBRI_CONF_PATH_H__
+
+#include "conf/conf.h"
+
+struct c2_conf_pathcomp {
+	union {
+		enum c2_conf_objtype relation;
+		struct c2_conf_bytes key;
+	} pc_u;
+	bool pc_iskey;
+};
+
+struct c2_conf_path {
+	struct c2_conf_obj      *p_origin;
+	size_t                   p_nr_comps;
+	struct c2_conf_pathcomp *p_comps;
+};
+
+/**
+ * Returns true iff the path is empty or has the following properties:
+ * - the first component is a relation;
+ * - a directory is followed by a key or is the last component;
+ * - a key is preceded by a directory (hence a key cannot follow an object);
+ * - the path consists of downlinks (for those c2_conf_downlink() != NULL).
+ */
+bool c2_conf_path_invariant(const struct c2_conf_path *path);
+
+#endif /* __COLIBRI_CONF_PATH_H__ */
diff --git a/conf/relation.c b/conf/relation.c
new file mode 100644
index 0000000..ff01212
--- /dev/null
+++ b/conf/relation.c
@@ -0,0 +1,99 @@
+/* -*- c -*- */
+/*
+ * COPYRIGHT 2012 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: Valery V. Vorotyntsev <valery_vorotyntsev@xyratex.com>
+ * Original creation date: 05-Feb-2012
+ */
+
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+#include "conf/relation.h"
+
+const struct c2_conf_relation rels_profile[] = {
+	{
+		.r_type   = C2_CO_FILESYSTEM,
+		.r_offset = offsetof(struct c2_conf_profile, cp_filesystem),
+		.r_dir    = NULL
+	}
+};
+const struct c2_conf_relation rels_filesystem[] = {
+	{
+		.r_type   = C2_CO_SERVICE,
+		.r_offset = offsetof(struct c2_conf_filesystem, cf_services),
+		.r_dir    = c2_conf_filesystem_services_tl
+	}
+};
+const struct c2_conf_relation rels_service[] = {
+	{
+		.r_type   = C2_CO_NODE,
+		.r_offset = offsetof(struct c2_conf_service, cs_node),
+		.r_dir    = NULL
+	}
+};
+const struct c2_conf_relation rels_node[] = {
+	{
+		.r_type   = C2_CO_NIC,
+		.r_offset = offsetof(struct c2_conf_node, cn_nics),
+		.r_dir    = c2_conf_node_nics_tl
+	},
+	{
+		.r_type   = C2_CO_SDEV,
+		.r_offset = offsetof(struct c2_conf_node, cn_sdevs),
+		.r_dir    = c2_conf_node_sdevs_tl
+	}
+};
+const struct c2_conf_relation rels_sdev[] = {
+	{
+		.r_type   = C2_CO_PARTITION,
+		.r_offset = offsetof(struct c2_conf_sdev, sd_partitions),
+		.r_dir    = c2_conf_sdev_partitions_tl
+	}
+};
+
+const struct rels {
+	const struct c2_conf_relation *data;
+	size_t                         nr;
+} downlinks[C2_CO_NR] = {
+	[C2_CO_PROFILE]    = { .data = rels_profile,
+			       .nr   = ARRAY_SIZE(rels_profile) },
+	[C2_CO_FILESYSTEM] = { .data = rels_filesystem,
+			       .nr   = ARRAY_SIZE(rels_filesystem) },
+	[C2_CO_SERVICE]    = { .data = rels_service,
+			       .nr   = ARRAY_SIZE(rels_service) },
+	[C2_CO_NODE]       = { .data = rels_node,
+			       .nr   = ARRAY_SIZE(rels_node) },
+	[C2_CO_NIC]        = { .data = NULL, .ar_nr = 0 },
+	[C2_CO_SDEV]       = { .data = rels_sdev,
+			       .nr   = ARRAY_SIZE(rels_sdev) },
+	[C2_CO_PARTITION]  = { .data = NULL, .ar_nr = 0 }
+};
+
+const struct c2_conf_relation *
+c2_conf_downlink(enum c2_conf_objtype src, enum c2_conf_objtype tgt)
+{
+	size_t i;
+	const struct rels rs = downlinks[src];
+
+	C2_PRE(c2_conf_objtype_invariant(src));
+	C2_PRE(c2_conf_objtype_invariant(tgt));
+
+	for (i = 0; i < rs.nr; ++i) {
+		if (rs.data[i]->r_type == tgt)
+			return rs.data[i];
+	}
+	return NULL;
+}
diff --git a/conf/relation.h b/conf/relation.h
new file mode 100644
index 0000000..e62fa9d
--- /dev/null
+++ b/conf/relation.h
@@ -0,0 +1,60 @@
+/* -*- c -*- */
+/*
+ * COPYRIGHT 2012 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: Valery V. Vorotyntsev <valery_vorotyntsev@xyratex.com>
+ * Original creation date: 05-Feb-2012
+ */
+#ifndef __COLIBRI_CONF_RELATION_H__
+#define __COLIBRI_CONF_RELATION_H__
+
+#include "conf/conf.h" /* c2_conf_objtype */
+
+/** Relation --- a pointer from one configuration object to another
+ * object or a list of objects. */
+struct c2_conf_relation {
+	/**
+	 * Type of relation's target.
+	 *
+	 * Target can be either single configuration object or a list
+	 * of objects.
+	 */
+	enum c2_conf_objtype      r_type;
+
+	/** Offset of the relation field in an ambient structure. */
+	int                       r_offset;
+
+	/**
+	 * tlist descriptor of the target directory (which is a list
+	 * of objects); NULL if the relation points to a configuration
+	 * object.
+	 */
+	const struct c2_tl_descr *r_dir;
+};
+
+/**
+ * Returns description of a downlink, given types of source and target
+ * objects. Returns NULL if there is no such downlink.
+ *
+ * @param src  Type of object the downlink originates from.
+ * @param tgt  Type of downlink's target object(s).
+ *
+ * @pre  c2_conf_objtype_invariant(src)
+ * @pre  c2_conf_objtype_invariant(tgt)
+ */
+const struct c2_conf_relation * c2_conf_downlink(enum c2_conf_objtype src,
+						 enum c2_conf_objtype tgt);
+
+#endif /* __COLIBRI_CONF_RELATION_H__ */
diff --git a/conf/ut/conf.c b/conf/ut/conf.c
new file mode 100644
index 0000000..7166255
--- /dev/null
+++ b/conf/ut/conf.c
@@ -0,0 +1,31 @@
+/* -*- c -*- */
+/*
+ * COPYRIGHT 2012 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: Valery V. Vorotyntsev <valery_vorotyntsev@xyratex.com>
+ * Original creation date: 04-Feb-2012
+ */
+
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+#include "conf/conf.c" /* note the inclusion of _definitions_ */
+
+/** Checks the invariant of `allowed_relations'. */
+static void relations(void)
+{
+	/* For each element of `allowed_relations' ensure that its
+	 * ->data array has no duplicates of relation::r_type. */
+}
-- 
1.8.3.2

