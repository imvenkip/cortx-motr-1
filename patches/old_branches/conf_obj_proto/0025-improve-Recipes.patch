From 90ad7851657d1db8c8160a8107af32c1c9a4fb0a Mon Sep 17 00:00:00 2001
From: "Valery V. Vorotyntsev" <valery_vorotyntsev@xyratex.com>
Date: Tue, 28 Feb 2012 19:31:34 +0200
Subject: [PATCH 025/370] improve Recipes

TODO: Add example for c2_confc_diropen().

+ Add pinned/unpinned to definitions.
+ Improve documentation of c2_confc_dirnext().
+ Rename path_status() to path_follow().
---
 conf/confc.c | 21 ++++++++++-------
 conf/confc.h | 73 +++++++++++++++++++++++++++++-------------------------------
 2 files changed, 48 insertions(+), 46 deletions(-)

diff --git a/conf/confc.c b/conf/confc.c
index 2505aed..71c6674 100644
--- a/conf/confc.c
+++ b/conf/confc.c
@@ -76,7 +76,7 @@
  *
  * New terms:
  *
- * - <b>Directory</b>: a list of configuration objects. This term is
+ * - @b Directory: a list of configuration objects. This term is
  *   usually used in context of path.  Alternative name --- collection
  *   of configuration objects.
  *
@@ -85,6 +85,10 @@
  *   of the path (if any) are ready (C2_CS_READY) and target is either
  *   an object that is ready or a directory of ready objects.
  *
+ * - A configuration object is said to be @b pinned if its reference
+ *   counter is nonzero, otherwise it is @b unpinned.  Confc never
+ *   invalidates pinned objects.
+ *
  * <hr> <!------------------------------------------------------------->
  * @section confc-dld-req Requirements
  *
@@ -121,8 +125,9 @@
  * <hr> <!------------------------------------------------------------->
  * @section confc-dld-highlights Design Highlights
  *
- * XXX
- *
+ * - Configuration consumers should not use relations of a
+ *   configuration object to access its neighbors: relations may point
+ *   to unpinned objects that can be invalidated by confc.
  */
 
 static struct c2_conf_cache confc_cache;
@@ -183,28 +188,28 @@ request_fill(struct c2_confop_fetch *req, const struct c2_conf_obj *path_org,
  *                  object does not exist.
  */
 static int
-path_status(struct c2_confc_ctx *ctx, enum c2_conf_status *status)
+path_follow(struct c2_confc_ctx *ctx, enum c2_conf_status *status)
 {
 	/*
 	 * XXX[remove this comment after DLDINSP]
 	 *
 	 * Refer to confc state diagram in the HLD.
 	 *
-	 * path_status() follows ctx->fc_path and checks the statuses
+	 * path_follow() follows ctx->fc_path and checks the statuses
 	 * of met objects.  Upon success, the function sets *status to:
 	 *
 	 * - C2_CS_READY:   path target is reachable
 	 *
 	 * - C2_CS_MISSING: At least one of the intermediate objects
 	 *                  or the target itself is C2_CS_MISSING.
-	 *                  path_status() changes statuses of such
+	 *                  path_follow() changes statuses of such
 	 *                  objects to C2_CS_LOADING and fills
 	 *                  ctx->fc_req.
 	 *
 	 * - C2_CS_LOADING: Neither path target nor missing objects
 	 *                  can be reached because of C2_CS_LOADING
 	 *                  object(s) blocking the path.
-	 *                  path_status() registers ctx->fc_clink with
+	 *                  path_follow() registers ctx->fc_clink with
 	 *                  the channel(s) of loading object(s).
 	 */
 	struct c2_conf_obj *obj = ctx->fc_path.p_origin ?: confc_cache->cc_root;
@@ -495,7 +500,7 @@ static void check_st_in(struct c2_sm *mach)
 
 	C2_PRE(c2_mutex_is_locked(group_lock()));
 
-	rc = path_status(to_ctx(mach), &status);
+	rc = path_follow(to_ctx(mach), &status);
 	if (rc != 0)
 		c2_sm_fail(mach, S_FAILURE, rc);
 	else if (status == C2_CS_MISSING)
diff --git a/conf/confc.h b/conf/confc.h
index f060fcf..694ff8c 100644
--- a/conf/confc.h
+++ b/conf/confc.h
@@ -81,19 +81,18 @@
  * <hr> <!------------------------------------------------------------->
  * @section confc-dld-fspec-recipes  Recipes
  *
- * XXX
- *
  * @subsection confc-dld-fspec-recipes-setup Initialization and termination
  *
  * Prior to accessing configuration, the application (aka
  * configuration consumer) should initialize configuration client by
- * calling c2_confc_init(). The application should also take care to
- * terminate initialized confc with c2_confc_fini() call.
+ * calling c2_confc_init().
  *
  * A confc instance is associated with a state machine group
  * (c2_sm_group). A user managing this group is responsible for making
  * sure c2_sm_asts_run() is called when the group's channel is
- * signalled. "AST" section of @ref sm has more details on this topic.
+ * signalled; "AST" section of @ref sm has more details on this topic.
+ *
+ * Initiated confc must be eventually terminated with c2_confc_fini().
  *
  * @code
  * #include "conf/confc.h"
@@ -114,34 +113,30 @@
  *
  * @subsection confc-dld-fspec-recipes-open Accessing configuration objects
  *
- * The application gets access to configuration data by "opening"
- * configuration objects. c2_confc_open() is used to obtain a pointer
- * to configuration object. c2_confc_diropen() is used to obtain a
- * pointer to a collection of configuration objects, aka @em directory.
- * Both functions have synchronous counterparts ---
- * c2_confc_open_sync() and c2_confc_diropen_sync().
- *
- * The application uses c2_confc_dirnext() to iterate over the objects
- * of a directory.
+ * The application gets access to configuration data by opening
+ * configuration objects.
  *
- * Opened configuration objects and directories should be closed
- * eventually. c2_confc_close() and c2_confc_dirclose() are used for
- * this purpose.
+ * c2_confc_open() or c2_confc_open_sync() open individual
+ * configuration objects; c2_confc_diropen() or
+ * c2_confc_diropen_sync() open directories.  Objects of a directory
+ * are iterated over with c2_confc_dirnext().
  *
- * A configuration object is said to be @em pinned if its reference
- * counter is nonzero, otherwise it is @em unpinned. Pinned objects
- * are guaranteed not to be deleted by confc.
+ * c2_confc_open() and c2_confc_diropen() are asynchronous calls.  The
+ * application should initialize a context object
+ * (c2_confc_ctx_init()) and register a clink with
+ * c2_confc_ctx::fc_complete channel prior to calling any of these
+ * functions.  When the clink is signaled, c2_confc_ctx::fc_result
+ * will point to the requested object/directory or be NULL in case of
+ * error.  c2_confc_error() returns the error code.
  *
- * c2_confc_*open*() and c2_confc_dirnext() functions pin the objects
- * before providing them to configuration consumer. c2_confc_*close()
- * "remove one pin" from a configuration object.
+ * A caller of c2_confc_open_sync() or c2_confc_diropen_sync() will be
+ * blocked while confc is processing the request.
  *
- * @note The application should not follow relations of a
- *       configuration object. Relations may point to unpinned objects
- *       and it is bad idea to read configuration from an object that
- *       may be deleted at any moment.
+ * All opened configuration objects and directories must be closed
+ * before c2_confc_fini() is called.  c2_confc_close() and
+ * c2_confc_dirclose() are used for this purpose.
  *
- * Some examples follow.
+ * Examples:
  *
  * @code
  * #include "conf/confc.h"
@@ -152,26 +147,25 @@
  * {
  * 	struct c2_confc_ctx        ctx;
  * 	struct c2_clink            clink;
- * 	struct c2_conf_filesystem *ret = NULL;
  * 	struct c2_conf_pathcomp    path[] =
  * 		{ C2_CONF_PATHCOMP_R(C2_CO_FILESYSTEM) };
+ * 	struct c2_conf_filesystem *ret = NULL;
+ * 	int                        rc;
  *
  * 	c2_confc_ctx_init(&ctx);
  * 	c2_clink_init(&clink, NULL)
  * 	c2_clink_add(&ctx.fc_complete, &clink);
  *
  * 	rc = c2_confc_open(&ctx, NULL, path, ARRAY_SIZE(path));
- * 	if (rc != 0) {
- * 		if (errno != NULL)
- * 			*errno = -rc;
- * 		goto end;
+ * 	if (rc == 0) {
+ * 		c2_chan_wait(&clink);
+ * 		ret = ctx.fc_result;
+ * 		if (ret == NULL && errno != NULL)
+ * 			*errno = c2_confc_error(ctx);
+ * 	} else if (errno != NULL) {
+ * 		*errno = -rc;
  * 	}
  *
- * 	c2_chan_wait(&clink);
- * 	ret = ctx.fc_result;
- * 	if (ret == NULL && errno != NULL)
- * 		*errno = c2_confc_error(ctx);
- * end:
  * 	c2_clink_del(&clink);
  * 	c2_clink_fini(&clink);
  * 	c2_confc_ctx_fini(&ctx);
@@ -345,6 +339,9 @@ struct c2_confc_dir * c2_confc_diropen_sync(struct c2_conf_obj *path_origin,
  * Returns a pointer to the next configuration object of given
  * collection.  Returns NULL if at the end of collection.
  *
+ * Closes the object returned by previous c2_confc_dirnext() call with
+ * the same argument.
+ *
  * c2_confc_dirnext() is used to navigate collections of configuration
  * objects:
  *
-- 
1.8.3.2

