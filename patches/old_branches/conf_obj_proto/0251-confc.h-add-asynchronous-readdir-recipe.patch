From 24f87d001c8937b00b657bf1e463b6623cccd9db Mon Sep 17 00:00:00 2001
From: "Valery V. Vorotyntsev" <valery_vorotyntsev@xyratex.com>
Date: Tue, 17 Jul 2012 14:22:42 +0300
Subject: [PATCH 251/370] confc.h: add "asynchronous readdir" recipe

+ Use `//' comments in @code..@endcode blocks, because doxygen
  does not render `///' comments.
+ Precede global variables (used in the recipes) with `g_'.
+ Define sm_waiter_{init,fini,wait}() functions to improve
  recipes' signal-to-noise ratio.

LogD #463
RB: r/865/diff/2-4/?file=23424#file23424line590
---
 conf/confc.h | 121 ++++++++++++++++++++++++++++++++++++++++++++++++-----------
 1 file changed, 99 insertions(+), 22 deletions(-)

diff --git a/conf/confc.h b/conf/confc.h
index 08464d1..641c1eb 100644
--- a/conf/confc.h
+++ b/conf/confc.h
@@ -49,6 +49,7 @@ struct c2_mutex;
  *   - @ref confc-fspec-recipe1
  *   - @ref confc-fspec-recipe2
  *   - @ref confc-fspec-recipe3
+ *   - @ref confc-fspec-recipe4
  * - @ref confc_dfspec "Detailed Functional Specification"
  *
  * <hr> <!------------------------------------------------------------>
@@ -159,42 +160,34 @@ struct c2_mutex;
  * @code
  * #include "conf/confc.h"
  *
- * struct c2_confc *confc = ...;
+ * struct c2_confc *g_confc = ...;
  *
+ * // A sample c2_confc_ctx wrapper.
  * struct sm_waiter {
  *         struct c2_confc_ctx w_ctx;
  *         struct c2_clink     w_clink;
  * };
  *
- * /// Filters out intermediate states of c2_confc_ctx::fc_mach.
- * static bool sm_filter(struct c2_clink *link)
- * {
- *         int32_t e = c2_confc_ctx_error(&container_of(link, struct sm_waiter,
- *                                                      w_clink)->w_ctx);
- *         return e == EINPROGRESS;
- * }
+ * static void sm_waiter_init(struct sm_waiter *w, struct c2_confc *confc);
+ * static void sm_waiter_fini(struct sm_waiter *w);
+ * static int sm_waiter_wait(struct sm_waiter *w);
  *
  * static int filesystem_open_async(struct c2_conf_filesystem **fs)
  * {
  *         struct sm_waiter w;
  *         int              rc;
  *
- *         c2_confc_ctx_init(&w.w_ctx, confc);
- *         c2_clink_init(&w.w_clink, sm_filter);
- *         c2_clink_add(&w.w_ctx.fc_mach.sm_chan, &w.w_clink);
+ *         sm_waiter_init(&w, g_confc);
  *
  *         rc = c2_confc_open(&w.w_ctx, NULL, "filesystem");
  *         if (rc == 0) {
- *                 while ((rc = c2_confc_ctx_error(&w.w_ctx)) == EINPROGRESS)
- *                         c2_chan_wait(&w.w_clink);
+ *                 rc = sm_waiter_wait(&w);
  *                 if (rc == 0)
  *                         *fs = C2_CONF_CAST(c2_confc_ctx_result(&w.w_ctx),
  *                                            c2_conf_filesystem);
  *         }
  *
- *         c2_clink_del(&w.w_clink);
- *         c2_clink_fini(&w.w_clink);
- *         c2_confc_ctx_fini(&w.w_ctx);
+ *         sm_wrapper_fini(&w);
  *         return rc;
  * }
  *
@@ -202,6 +195,28 @@ struct c2_mutex;
  * {
  *         return c2_confc_open_sync(fs, confc->cc_root, "filesystem");
  * }
+ *
+ * // Filters out intermediate state of c2_confc_ctx::fc_mach.
+ * static bool sm_waiter_filter(struct c2_clink *link)
+ * {
+ *         int32_t e = c2_confc_ctx_error(&container_of(link, struct sm_waiter,
+ *                                                      w_clink)->w_ctx);
+ *         return e == EINPROGRESS;
+ * }
+ *
+ * static void sm_waiter_init(struct sm_waiter *w, struct c2_confc *confc)
+ * {
+ * 	c2_confc_ctx_init(&w->w_ctx, confc);
+ * 	c2_clink_init(&w->w_clink, sm_waiter_filter);
+ * 	c2_clink_add(&w->w_ctx.fc_mach.sm_chan, &w->w_clink);
+ * }
+ *
+ * static void sm_waiter_fini(struct sm_waiter *w)
+ * {
+ * 	c2_clink_del(&w->w_clink);
+ * 	c2_clink_fini(&w->w_clink);
+ * 	c2_confc_ctx_fini(&w->w_ctx);
+ * }
  * @endcode
  *
  * <!---------------------------------------------------------------->
@@ -210,7 +225,7 @@ struct c2_mutex;
  * @code
  * #include "conf/confc.h"
  *
- * struct c2_confc *confc = ...;
+ * struct c2_confc *g_confc = ...;
  *
  * static int specific_service_process(enum c2_cfg_service_type tos)
  * {
@@ -219,7 +234,7 @@ struct c2_mutex;
  *         struct c2_conf_dircur cur;
  *         int rc;
  *
- *         rc = c2_confc_open_sync(&dir_obj, confc->cc_root,
+ *         rc = c2_confc_open_sync(&dir_obj, g_confc->cc_root,
  *                                 "filesystem/services");
  *         if (rc != 0)
  *                 return rc;
@@ -250,12 +265,12 @@ struct c2_mutex;
  * @code
  * #include "conf/confc.h"
  *
- * struct c2_confc *confc = ...;
+ * struct c2_confc *g_confc = ...;
  *
  * static int node_devices_process(struct c2_conf_obj *node);
  *
- * /// Accesses configuration data of devices used by specific service on
- * /// specific node.
+ * // Accesses configuration data of devices used by specific service
+ * // on specific node.
  * static int specific_devices_process(const char *svc_id, const char *node_id)
  * {
  *         struct c2_conf_obj   *dir_obj;
@@ -263,7 +278,7 @@ struct c2_mutex;
  *         struct c2_conf_obj   *svc_obj;
  *         int rc;
  *
- *         rc = c2_confc_open_sync(&dir_obj, confc->cc_root,
+ *         rc = c2_confc_open_sync(&dir_obj, g_confc->cc_root,
  *                                 "filesystem/services");
  *         if (rc != 0)
  *                 return rc;
@@ -350,6 +365,68 @@ struct c2_mutex;
  * }
  * @endcode
  *
+ * <!---------------------------------------------------------------->
+ * @subsection confc-fspec-recipe4 Iterate directory object asynchronously
+ *
+ * @code
+ * #include "conf/confc.h"
+ * #include "lib/arith.h" // C2_CNT_INC
+ *
+ * struct c2_confc *g_confc = ...;
+ *
+ * struct sm_waiter {
+ * 	struct c2_confc_ctx w_ctx;
+ * 	struct c2_clink     w_clink;
+ * };
+ *
+ * // sm_waiter_*() functions are defined in one of the recipes above.
+ * static void sm_waiter_init(struct sm_waiter *w, struct c2_confc *confc);
+ * static void sm_waiter_fini(struct sm_waiter *w);
+ * static int sm_waiter_wait(struct sm_waiter *w);
+ *
+ * // Counts the number of entries in a given directory.
+ * static ssize_t dir_len(struct c2_conf_dir *dir)
+ * {
+ * 	struct c2_conf_dircur     cur;
+ * 	struct sm_waiter          w;
+ * 	const struct c2_conf_obj *entry;
+ * 	int                       rc;
+ * 	ssize_t                   count = 0;
+ *
+ * 	c2_conf_dircur_init(&cur, dir);
+ * 	sm_waiter_init(&w, g_confc);
+ *
+ * 	while (1) {
+ * 		rc = c2_confc_readdir(&w.w_ctx, &cur);
+ * 		if (rc == 2 || rc < 0) { // end of directory or an error
+ * 			break;
+ * 		} else if (rc == 1) {    // an entry is available immediately
+ * 			C2_CNT_INC(count);
+ * 			continue;
+ * 		} else {                 // asynchronous case
+ * 			C2_ASSERT(rc == 0);
+ * 			rc = sm_waiter_wait(&w);
+ * 			if (rc != 0)
+ * 				break; // error
+ *
+ * 			entry = c2_confc_ctx_result(&w.w_ctx);
+ * 			if (entry == NULL)
+ * 				break; // end of directory
+ * 			else
+ * 				C2_CNT_INC(count);
+ *
+ * 			// Re-initialise c2_confc_ctx.
+ * 			sm_waiter_fini(&w);
+ * 			sm_waiter_init(&w);
+ * 		}
+ * 	}
+ *
+ * 	sm_waiter_fini(&w);
+ * 	c2_conf_dircur_fini(&cur);
+ * 	return rc ?: count;
+ * }
+ * @endcode
+ *
  * @see @ref confc_dfspec "Detailed Functional Specification"
  */
 
-- 
1.8.3.2

