From 790d96aad65e2d998c28e79cb52f32ea8fd1318b Mon Sep 17 00:00:00 2001
From: Anatoliy Bilenko <anatoliy_bilenko@xyratex.com>
Date: Thu, 30 Aug 2012 17:20:06 +0300
Subject: [PATCH 342/370] preload: Add bindings to concrete obj_type parsers.

---
 conf/preload.c   | 210 +++++++++++++++++++++++++++++++++++++++++++++++++++----
 conf/preload.h   |   2 +-
 conf/ut/prepar.c |   8 ++-
 3 files changed, 204 insertions(+), 16 deletions(-)

diff --git a/conf/preload.c b/conf/preload.c
index f1638db..194e8f8 100644
--- a/conf/preload.c
+++ b/conf/preload.c
@@ -21,6 +21,8 @@
 
 #include "conf/preload.h"
 #include "conf/onwire.h"
+#include "conf/obj.h"
+
 #include "lib/assert.h"
 #include "lib/errno.h"
 #include "lib/misc.h"
@@ -48,6 +50,12 @@ static bool hunk_is_empty(const struct hunk *p)
 	return p->begin == NULL && p->end == NULL;
 }
 
+static bool hunk_is_valid(const struct hunk *p)
+{
+	C2_PRE(!hunk_is_empty(p));
+	return p->end >= p->begin;
+}
+
 static void hunk_pr(const char *prefix, const struct hunk *p) {
 #ifdef HUNK_DBG
 	char buf[4096];
@@ -64,6 +72,29 @@ static void hunk_cp(struct hunk *dest, const struct hunk *source) {
 	dest->end   = source->end;
 }
 
+static size_t hunk_len(const struct hunk *hunk)
+{
+	C2_PRE(!hunk_is_empty(hunk));
+	C2_PRE(hunk_is_valid(hunk));
+
+	return hunk->end - hunk->begin + 1;
+}
+
+static bool hunk_str_eq(const struct hunk *hunk, const char *string)
+{
+	const char *p;
+	int	    len;
+
+	for (p = hunk->begin; p <= hunk->end; ++p)
+		C2_PRE(isprint(*p));
+
+	len = strlen(string);
+	if (len != hunk_len(hunk))
+		return false;
+
+	return memcmp(hunk->begin, string, len) == 0;
+}
+
 static int hunk_trim(struct hunk *p)
 {
 	C2_PRE(!hunk_is_empty(p));
@@ -80,7 +111,7 @@ static int hunk_trim(struct hunk *p)
 			return -ENOENT;
 	}
 
-	return (p->end > p->begin) ? 0 : -EINVAL;
+	return hunk_is_valid(p) ? 0 : -EINVAL;
 }
 
 static int unit_advance(struct hunk *unit, char open, char close)
@@ -93,10 +124,11 @@ static int unit_advance(struct hunk *unit, char open, char close)
 	unit->begin++;
 	unit->end--;
 
+	/* @todo: hunk_is_valid() */
 	return (unit->begin >= unit->end) ? -ENOENT : 0;
 }
 
-static int unit_parse(struct hunk *unit)
+static int unit_parse(struct hunk *unit, char ss)
 {
 	int  rc;
 	const char *p;
@@ -119,8 +151,8 @@ static int unit_parse(struct hunk *unit)
 		if (*p == '{') curly++; /* push *p into stack */
 		if (*p == '}') curly--; /* pop *c from stack, check *c == '{' */
 
-		if (!curly && !brace && (*p == ',' || p == unit->end)) {
-			unit->end = (*p == ',') ? --p : p;
+		if (!curly && !brace && (*p == ss || p == unit->end)) {
+			unit->end = (*p == ss) ? --p : p;
 			return hunk_trim(unit);
 		}
 	}
@@ -128,43 +160,50 @@ static int unit_parse(struct hunk *unit)
 	return -ENOENT;
 }
 
-static int unit_next(struct hunk *unit, const struct hunk *buffer)
+static int unit_next(struct hunk *unit, const struct hunk *buffer, char ss)
 {
 	int  rc;
 
+	C2_PRE(!hunk_is_empty(buffer));
 	unit->begin = unit->end;
 	unit->end = buffer->end;
 
-	if (++unit->begin >= unit->end)
+	++unit->begin;
+	if (!hunk_is_valid(unit))
 		return -ENOENT;
 
 	if ((rc = hunk_trim(unit)) != 0)
 		return rc;
 
-	if (*unit->begin++ != ',')
+	if (*unit->begin++ != ss)
 		return -EINVAL;
 
 	return 0;
 }
 
-static int sequence_parse(struct hunk *unit, const struct hunk *buffer)
+/**
+ *  @param ss	sequence separator, like ',' or ':'
+ */
+static int sequence_parse(struct hunk *unit, const struct hunk *buffer, char ss)
 {
 	int  rc;
 
+	C2_PRE(C2_IN(ss, (',', ':')));
+
 	if (hunk_is_empty(unit))
 		hunk_cp(unit, buffer);
 	else {
-		rc = unit_next(unit, buffer);
+		rc = unit_next(unit, buffer, ss);
 		if (rc != 0)
 			return rc;
 	}
 
-	return unit_parse(unit);
+	return unit_parse(unit, ss);
 }
 
 static int block_parse(struct hunk *unit, const struct hunk *buffer)
 {
-	return sequence_parse(unit, buffer);
+	return sequence_parse(unit, buffer, ',');
 }
 
 static int record_parse(struct hunk *unit, const struct hunk *buffer)
@@ -172,7 +211,7 @@ static int record_parse(struct hunk *unit, const struct hunk *buffer)
 	struct hunk contents = HUNK_CP(buffer);
 
 	return unit_advance(&contents, '[', ']') ?:
-		sequence_parse(unit, &contents);
+		sequence_parse(unit, &contents, ',');
 }
 
 static int entry_parse(struct hunk *unit, const struct hunk *buffer)
@@ -180,17 +219,141 @@ static int entry_parse(struct hunk *unit, const struct hunk *buffer)
 	struct hunk contents = HUNK_CP(buffer);
 
 	return unit_advance(&contents, '{', '}') ?:
-		sequence_parse(unit, &contents);
+		sequence_parse(unit, &contents, ',');
 }
 
 
 /* ------------------------------------------------------------------
- * Confx objects allocation
+ * Confx object parsers
+ * ------------------------------------------------------------------ */
+
+static int parse_profile(const struct hunk *key, const struct hunk *val,
+			 struct confx_object *out)
+{
+	return -1;
+}
+
+static int parse_filesystem(const struct hunk *key, const struct hunk *val,
+			    struct confx_object *out)
+{
+	return -1;
+}
+
+static int parse_service(const struct hunk *key, const struct hunk *val,
+			 struct confx_object *out)
+{
+	return -1;
+}
+
+static int parse_node(const struct hunk *key, const struct hunk *val,
+		      struct confx_object *out)
+{
+	return -1;
+}
+
+static int parse_nic(const struct hunk *key, const struct hunk *val,
+		     struct confx_object *out)
+{
+	return -1;
+}
+
+static int parse_sdev(const struct hunk *key, const struct hunk *val,
+		      struct confx_object *out)
+{
+	return -1;
+}
+
+static int parse_partition(const struct hunk *key, const struct hunk *val,
+			   struct confx_object *out)
+{
+	return -1;
+}
+
+
+/* ------------------------------------------------------------------
+ * Bindings: generic parser is bind to concrete
+ * ------------------------------------------------------------------ */
+
+static int parse_unused(const struct hunk *key, const struct hunk *val,
+			struct confx_object *out)
+{
+	C2_IMPOSSIBLE("Wrong parser handler called");
+	return -1;
+}
+
+static const struct xstr_rec {
+	const char *r_name;
+	int (*r_parse)(const struct hunk *key, const struct hunk *val,
+		       struct confx_object *out);
+} xstr[C2_CO_NR] = {
+	[C2_CO_DIR]	   = { "unused"     , parse_unused     },
+	[C2_CO_PROFILE]	   = { "profile"    , parse_profile    },
+	[C2_CO_FILESYSTEM] = { "filesystem" , parse_filesystem },
+	[C2_CO_SERVICE]	   = { "service"    , parse_service    },
+	[C2_CO_NODE]	   = { "node"	    , parse_node       },
+	[C2_CO_NIC]	   = { "nic"	    , parse_nic        },
+	[C2_CO_SDEV]	   = { "sdev"	    , parse_sdev       },
+	[C2_CO_PARTITION]  = { "partition"  , parse_partition  }
+};
+
+static size_t str_to_x(const char *conf_string)
+{
+	size_t i;
+
+	for (i = 0; i < ARRAY_SIZE(xstr); ++i)
+		if (strcmp(xstr[i].r_name, conf_string) == 0)
+			return i;
+
+	C2_IMPOSSIBLE("Wrong configuration string type given!");
+}
+
+static int x_parser_call(const char *conf_string, struct confx_object *out)
+{
+	int rc;
+	struct hunk str = { .begin = conf_string,
+			    .end = &conf_string[strlen(conf_string) - 1] };
+	struct hunk ent = { NULL, NULL };
+	struct hunk key = { NULL, NULL };
+	struct hunk val = { NULL, NULL };
+
+	rc = sequence_parse(&ent, &str, ':');
+	if (rc != 0)
+		return rc;
+	hunk_cp(&key, &ent);
+
+	rc = sequence_parse(&ent, &str, ':');
+	if (rc != 0)
+		return rc;
+	hunk_cp(&val, &ent);
+
+	rc = sequence_parse(&ent, &str, ':');
+	if (rc != -ENOENT)
+		return -EINVAL;
+
+	rc = unit_advance(&key, '\"', '\"');
+	if (rc != 0)
+		return rc;
+
+	hunk_pr("\t\t\tsub", &key);
+	hunk_pr("\t\t\tsub", &val);
+
+	if (0)
+		if (hunk_str_eq(&key, "type"))
+			xstr[str_to_x(conf_string)].r_parse(&key, &val, out);
+
+	return 0;
+}
+
+
+/* ------------------------------------------------------------------
+ * Toplevel parser
  * ------------------------------------------------------------------ */
 
 int c2_conf_parse(const char *src, struct confx_object *dest, size_t n)
 {
+	int rc;
 	int entries = 0;
+	size_t conf_index = 0;
 	struct hunk str = { .begin = src, .end = &src[strlen(src) - 1] };
 	struct hunk blk = { NULL, NULL };
 
@@ -201,7 +364,26 @@ int c2_conf_parse(const char *src, struct confx_object *dest, size_t n)
 			struct hunk ent = { NULL, NULL };
 			hunk_pr("\trecord", &rec);
 			for (; entry_parse(&ent, &rec) == 0; ) {
+				/* @todo: copying can be avoided */
+				char parse_buf[256];
+				int  len = ent.end - ent.begin + 1;
+
 				hunk_pr("\t\tentry", &ent);
+
+				if (len >= ARRAY_SIZE(parse_buf))
+					return -ENOMEM;
+
+				memcpy(parse_buf, ent.begin, len);
+				parse_buf[len]= '\0';
+
+				if (conf_index >= n)
+					return -ENOMEM;
+
+				rc = x_parser_call(parse_buf,
+						   &dest[conf_index++]);
+				if (rc != 0)
+					return rc;
+
 				++entries;
 			}
 		}
diff --git a/conf/preload.h b/conf/preload.h
index 05ba6a3..dff12e2 100644
--- a/conf/preload.h
+++ b/conf/preload.h
@@ -21,7 +21,7 @@
 #ifndef __COLIBRI_CONF_PRELOAD_H__
 #define __COLIBRI_CONF_PRELOAD_H__
 
-#include "lib/types.h"
+#include "lib/types.h" /* size_t */
 
 struct confx_object;
 
diff --git a/conf/ut/prepar.c b/conf/ut/prepar.c
index 9f2084f..f107788 100644
--- a/conf/ut/prepar.c
+++ b/conf/ut/prepar.c
@@ -1,6 +1,11 @@
 #include <stdio.h>
 #include <string.h>
+
 #include "conf/preload.h"
+#include "conf/onwire.h"
+#include "lib/assert.h"
+#include "lib/errno.h"
+#include "lib/misc.h"
 
 enum {
 	KB = (1 << 10)
@@ -12,6 +17,7 @@ int main(void)
 {
 	int c;
 	int i = 0;
+	struct confx_object conf[100];
 
 	memset(buf, 0, 32*KB);
 
@@ -23,7 +29,7 @@ int main(void)
 
 	buf[i] = '\0';
 
-	i = c2_conf_parse(buf, NULL, 0);
+	i = c2_conf_parse(buf, conf, ARRAY_SIZE(conf));
 	printf("entries: %d\n", i);
 
 	return 0;
-- 
1.8.3.2

