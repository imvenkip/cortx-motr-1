From 2352696af622f08d9571323bf91756361e2f65ea Mon Sep 17 00:00:00 2001
From: "Valery V. Vorotyntsev" <valery_vorotyntsev@xyratex.com>
Date: Wed, 22 Aug 2012 15:30:48 +0300
Subject: [PATCH 324/370] conf: implement {profile..node}_fill()

- Add c2_conf_obj_ops::coo_fill().
- Implement c2_conf_obj_fill().
- Implement {profile..node}_fill().
---
 conf/obj.h     |   2 +-
 conf/obj_ops.c | 266 +++++++++++++++++++++++++++++++++++++++++++++++++++------
 conf/obj_ops.h |  22 ++++-
 conf/onwire.h  |   3 +-
 4 files changed, 266 insertions(+), 27 deletions(-)

diff --git a/conf/obj.h b/conf/obj.h
index a997350..fe45bba 100644
--- a/conf/obj.h
+++ b/conf/obj.h
@@ -264,7 +264,7 @@ struct c2_conf_service {
 	 * Service end points.
 	 * NULL terminated array of C strings.
 	 */
-	const char              *cs_endpoints;
+	const char             **cs_endpoints;
 };
 
 struct c2_conf_node {
diff --git a/conf/obj_ops.c b/conf/obj_ops.c
index 3308df4..eb93962 100644
--- a/conf/obj_ops.c
+++ b/conf/obj_ops.c
@@ -29,7 +29,7 @@
 #include "lib/misc.h"     /* C2_IN */
 #include "lib/memory.h"   /* c2_alloc */
 #include "lib/tlist.h"
-#include "lib/errno.h"    /* ENOENT */
+#include "lib/errno.h"    /* ENOENT, ENOMEM */
 
 /**
  * @defgroup conf_dlspec_objops Configuration Object Operations
@@ -77,7 +77,10 @@ static bool abbrev ## _invariant(const void *bob);                 \
 static int abbrev ## _lookup(struct c2_conf_obj *parent,           \
 			     const struct c2_conf_buf *name,       \
 			     struct c2_conf_obj **out);            \
-                                                                   \
+static int abbrev ## _fill(struct c2_conf_obj *dest,		   \
+			   const struct confx_object *src,	   \
+			   struct c2_conf_reg *reg);		   \
+								   \
 const struct c2_bob_type c2_conf_ ## abbrev ## _bob = {            \
 	.bt_name = "c2_conf_" #abbrev,                             \
 	.bt_magix_offset =                                         \
@@ -118,7 +121,10 @@ static const struct obj_type {
 		.ot_obj_offset = offsetof(struct c2_conf_ ## abbrev,          \
 					  c2_conf_ ## abbrev ## _cast_field), \
 		.ot_bob        = &c2_conf_ ## abbrev ## _bob,                 \
-		.ot_ops        = { .coo_lookup  = abbrev ## _lookup }         \
+		.ot_ops        = {					      \
+			.coo_lookup = abbrev ## _lookup,                      \
+			.coo_fill   = abbrev ##	_fill			      \
+		}							      \
 	}
 
 	[C2_CO_DIR]        = _OBJ_TYPE_INIT(dir),
@@ -165,7 +171,8 @@ static bool generic_obj_invariant(const void *bob)
 	return buf_is_valid(&obj->co_id) &&
 		C2_IN(obj->co_status,
 		      (C2_CS_MISSING, C2_CS_LOADING, C2_CS_READY)) &&
-		obj->co_ops == &obj_type(type)->ot_ops;
+		obj->co_ops == &obj_type(type)->ot_ops &&
+		ergo(obj_is_stub(obj), obj->co_nrefs == 0);
 }
 
 static bool dir_invariant(const void *bob)
@@ -368,9 +375,10 @@ c2_conf_obj_new(enum c2_conf_objtype type, const struct c2_conf_buf *id)
 	obj->co_ops = &ot->ot_ops;
 	c2_chan_init(&obj->co_chan);
 
+	/* We cannot check c2_conf_obj_invariant() here: concrete
+	 * fields can't be validated, because connections to other
+	 * objects of the DAG have not been established yet. */
 	C2_POST(c2_conf_obj_bob_check(obj));
-	/* Concrete fields cannot be validated, because connections to
-	 * other objects of the DAG have not been established yet. */
 	return obj;
 }
 
@@ -410,23 +418,232 @@ bool c2_conf_obj_match(const struct c2_conf_obj *cached,
 	return obj_ops[cached->co_type].oo_equal(a, b);
 }
 
+static int obj_find(struct c2_conf_reg *reg, enum c2_conf_objtype type,
+		    const struct c2_conf_buf *id, struct c2_conf_obj **out)
+{
+	int rc;
+
+	*out = c2_conf_reg_lookup(reg, type, id);
+	if (*out == NULL) {
+		/* Create a stub. */
+		*out = c2_conf_obj_new(type, id);
+		if (*out == NULL)
+			return -ENOMEM;
+
+		/* Register the stub. */
+		rc = c2_conf_reg_add(reg, *out);
+		if (rc != 0) {
+			(*out)->co_ops->coo_fini(*out);
+			return rc;
+		}
+	}
+	return 0;
+}
+
+static int dir_new(const struct c2_conf_buf *parent_id,
+		   enum c2_conf_objtype child_type,
+		   struct arr_buf *src, struct c2_conf_reg *reg,
+		   struct c2_conf_dir **out)
+{
+	struct c2_conf_obj *child;
+	uint32_t            i;
+	int		    rc;
+
+	C2_ASSERT(*out == NULL);
+	*out = c2_conf_obj_new(C2_CO_DIR, parent_id);
+	if (*out == NULL)
+		return -ENOMEM;
+
+	for (i = 0; i < src->ab_count; ++i) {
+		rc = obj_find(reg, child_type, &src->ab_elems[i], &child);
+		if (rc != 0)
+			break;
+
+		/* Link directory and its element together. */
+		child->co_parent = &(*out)->cd_obj;
+		generic_objs_tlist_add(&(*out)->cd_items, child);
+	}
+
+	if (rc != 0) {
+		/* Restore consistency. */
+		struct void           *amb;
+		struct c2_conf_obj    *dir;
+		uint32_t               j;
+		const struct obj_type *ot = obj_type(child_type);
+
+		for (j = 0; j < i; ++j) {
+			child = c2_conf_reg_lookup(reg, child_type,
+						   &src->ab_elems[j]);
+			C2_ASSERT(child != NULL);
+
+			c2_conf_reg_delete(reg, child_type, &src->ab_elems[j]);
+
+			amb = (void *)child - ot->ot_obj_offset;
+			child->co_ops->coo_fini(child);
+			c2_free(amb);
+		}
+
+		dir = &(*out)->cd_obj;
+		dir->co_ops->coo_fini(dir);
+		c2_free(*out);
+	}
+
+	return rc;
+}
+
+static int endpoint_fill(const struct arr_buf *buf, char ***endpoint)
+{
+	uint32_t  i;
+	uint32_t  j;
+	char     *str;
+	uint32_t  size;
+	char     *data;
+
+	C2_ALLOC_PTR(**endpoint, ab_count);
+	if (**endpoint == NULL)
+		return -ENOMEM;
+
+	for (i = 0; i < buf->ab_count; ++i) {
+		size = buf->ab_elems[i]->cb_size;
+		data = buf->ab_elems[i]->cb_data;
+
+		C2_ALLOC_PTR(str, size + 1);
+		if (str == NULL)
+			break;
+
+		memcpy(str, data, size);
+		str[size] = '\0';
+		endpoint[i] = str;
+	}
+
+	if (str != NULL)
+		return 0;
+
+	/* cleanup */
+	for (j = 0; j < i; ++j) {
+		c2_free(endpoint[j]);
+	}
+
+	c2_free(**endpoint);
+
+	return -ENOMEM;
+}
+
+static int profile_fill(struct c2_conf_obj *__dest,
+			const struct confx_object *__src,
+			struct c2_conf_reg *reg)
+{
+	struct c2_conf_profile     *dest;
+	struct c2_conf_obj         *fs;
+	int                         rc;
+	const struct confx_profile *src = &__src->o_conf.u.u_profile;
+
+	/* XXX C2_CONF_CAST() may be not applicable here: ->bt_check()
+	 * may fail, because __dest's linkage hasn't been set yet.  */
+	dest = C2_CONF_CAST(__dest, c2_conf_profile);
+
+	rc = obj_find(reg, C2_CO_FILESYSTEM, &src->xp_filesystem, &fs);
+	if (rc != 0)
+		return rc;
+	dest->cp_filesystem = C2_CONF_CAST(fs, c2_conf_filesystem);
+
+	return 0;
+}
+
+static int filesystem_fill(struct c2_conf_obj *__dest,
+			   const struct confx_object *__src,
+			   struct c2_conf_reg *reg)
+{
+	struct c2_conf_filesystem     *dest;
+	const struct confx_filesystem *src = &__src->o_conf.u.u_filesystem;
+
+	dest = C2_CONF_CAST(__dest, c2_conf_filesystem); /* XXX */
+
+	dest->cf_rootfid = src->xf_rootfid;
+	dest->cf_params = XXX;
+
+	return dir_new(&__src->o_id, C2_CO_SERVICE, &src->xf_services, reg,
+		       &dest->cf_services);
+}
+
+static int service_fill(struct c2_conf_obj *__dest,
+			const struct confx_object *__src,
+			struct c2_conf_reg *reg)
+{
+	struct c2_conf_service     *dest;
+	struct c2_conf_obj         *node;
+	int                         rc;
+	const struct confx_service *src = &__src->o_conf.u.u_service;
+
+	dest = C2_CONF_CAST(__dest, c2_conf_service); /* XXX */
+
+	rc = obj_find(reg, C2_CO_NODE, &src->xs_node, &node);
+	if (rc != 0)
+		return rc;
+	dest->cs_node = C2_CONF_CAST(node, c2_conf_node);
+	dest->cs_type = src->xs_type;
+
+	retrun endpoint_fill(&src->xs_endpoints, &dest->cs_endpoints);
+}
+
+static int node_fill(struct c2_conf_obj *__dest,
+		     const struct confx_object *__src,
+		     struct c2_conf_reg *reg)
+{
+	int			 rc;
+	struct c2_conf_buf	 nic_id;
+	struct c2_conf_buf	 sdev_id;
+	struct c2_conf_node     *dest;
+	const struct confx_node *src = &__src->o_conf.u.u_node;
+
+	dest = C2_CONF_CAST(__dest, c2_conf_node); /* XXX */
+
+	dest->cn_memsize    = xn_memsize;
+	dest->cn_nr_cpu	    = xn_nr_cpu;
+	dest->cn_last_state = xn_last_state;
+	dest->cn_flags	    = xn_flags;
+	dest->cn_pool_id    = xn_pool_id;
+
+	rc = c2_conf_buf_copy(&nic_id, &__src->o_id);
+	if (rc != 0)
+		return rc;
+
+	rc = c2_conf_buf_copy(&sdev_id, &__src->o_id);
+	if (rc != 0)
+		return rc;
+
+	/* making ids of directories different */
+	C2_ASSERT(nic_id.cb_size > 1 && sdev_id.cb_size > 1);
+	nic_id.cb_data[0] = 'N';
+	sdev_id.cb_data[0] = 'S';
+
+	return dir_new(&nic_id, C2_CO_NIC, &src->xn_nics, reg,
+		       &dest->cn_nics) ?:
+		dir_new(&sdev_id, C2_CO_SDEV, &src->xn_sdevs, reg,
+			&dest->cn_sdevs);
+}
+
+
 int c2_conf_obj_fill(struct c2_conf_obj *dest, const struct confx_object *src,
 		     struct c2_conf_reg *reg)
 {
-	/*
-	 * C2_PRE(...);
-	 *
-	 * Set fields of `dest', copying data from `src'.
-	 *
-	 * For "foreign key" fields (aka relations):
-	 *   - if target object does not exist in the cache, create a
-	 *     stub for it;
-	 *   - set relation fields of dest and target.
-	 *
-	 * dest->co_status = C2_CS_READY;
-	 * C2_POST(...);
-	 */
-	XXX;
+	const struct obj_type *ot = obj_type(obj->co_type);
+
+	C2_PRE(c2_conf_obj_invariant(dest));
+	C2_PRE(confc_is_nil_or_locked(obj));
+	C2_PRE(obj_is_stub(dest) && dest->co_nrefs == 0);
+	C2_PRE(dest->co_type == src->o_conf.u_type);
+	C2_PRE(c2_conf_buf_eq(&dest->co_id, &src->o_id));
+
+	rc = ot->ot_ops.coo_fill(dest, src, reg);
+	if (rc != 0)
+		return rc;
+
+	dest->co_status = C2_CS_READY;
+	c2_conf_obj_invariant(obj);
+	C2_POST(confc_is_nil_or_locked(obj));
+
+	return 0;
 }
 
 /* ------------------------------------------------------------------
@@ -538,16 +755,17 @@ static int dir_readdir(struct c2_conf_obj *dir, struct c2_conf_obj **pptr)
  * c2_conf_obj_{get,put}()
  * ------------------------------------------------------------------ */
 
-static bool confc_is_locked(const struct c2_confc *confc)
+static bool confc_is_nil_or_locked(const struct c2_conf_obj *obj)
 {
-	return c2_mutex_is_locked(&confc->cc_lock);
+	return obj->co_confc == NULL ||
+		c2_mutex_is_locked(&obj->co_confc->cc_lock);
 }
 
 void c2_conf_obj_get(struct c2_conf_obj *obj)
 {
 	C2_PRE(c2_conf_obj_invariant(obj));
 	C2_PRE(obj->co_status == C2_CS_READY);
-	C2_PRE(ergo(obj->co_confc != NULL, confc_is_locked(obj->co_confc)));
+	C2_PRE(confc_is_nil_or_locked(obj));
 
 	C2_CNT_INC(obj->co_nrefs);
 }
@@ -556,7 +774,7 @@ void c2_conf_obj_put(struct c2_conf_obj *obj)
 {
 	C2_PRE(c2_conf_obj_invariant(obj));
 	C2_PRE(obj->co_status == C2_CS_READY);
-	C2_PRE(ergo(obj->co_confc != NULL, confc_is_locked(obj->co_confc)));
+	C2_PRE(confc_is_nil_or_locked(obj));
 
 	C2_CNT_DEC(obj->co_nrefs);
 	if (obj->co_nrefs == 0)
diff --git a/conf/obj_ops.h b/conf/obj_ops.h
index 1485647..9422bc4 100644
--- a/conf/obj_ops.h
+++ b/conf/obj_ops.h
@@ -78,6 +78,7 @@ struct c2_conf_obj_ops {
 	int (*coo_lookup)(struct c2_conf_obj *parent,
 			  const struct c2_conf_buf *name,
 			  struct c2_conf_obj **out);
+
 	/**
 	 * Gets next directory entry.
 	 *
@@ -98,6 +99,20 @@ struct c2_conf_obj_ops {
 	 * object in case of C2_CONF_DIRNEXT.
 	 */
 	int (*coo_readdir)(struct c2_conf_obj *dir, struct c2_conf_obj **pptr);
+
+	/**
+	 * Populates a concrete object with configuration data taken
+	 * from confx_object.
+	 *
+	 * Creates stubs of object's neighbours, if necessary.
+	 *
+	 * Note, that ->coo_fill() *does not* set dest->co_status to
+	 * C2_CS_READY.
+	 */
+	int (*coo_fill)(struct c2_conf_obj *dest,
+			const struct confx_object *src,
+			struct c2_conf_reg *reg);
+
 	/**
 	 * Destructor of configuration object.
 	 *
@@ -140,7 +155,12 @@ void c2_conf_obj_put(struct c2_conf_obj *obj);
 /**
  * Allocates and initialises configuration object of given type.
  *
- * Copies `id' into ->co_id of the resulting object.
+ * `id' is copied into ->co_id of the resulting object.
+ *
+ * Note, that c2_conf_obj_new() does not add resulting object into the
+ * configuration cache: the resulting object is neither registered,
+ * nor integrated into the @ref conf-lspec-comps "DAG" of
+ * configuration objects.
  */
 struct c2_conf_obj *c2_conf_obj_new(enum c2_conf_objtype type,
 				    const struct c2_conf_buf *id);
diff --git a/conf/onwire.h b/conf/onwire.h
index 11dcb27..346dd6e 100644
--- a/conf/onwire.h
+++ b/conf/onwire.h
@@ -40,12 +40,13 @@ struct c2_conf_buf {
 	char    *cb_data;
 } C2_XCA_SEQUENCE;
 
+/** XXX @todo Use c2_buf instead of arr_buf. */
 struct arr_buf {
 	uint32_t            ab_count;
 	struct c2_conf_buf *ab_elems;
 } C2_XCA_SEQUENCE;
 
-/** XXX @todo: s/objid/objiden/ ? */
+/** XXX @todo s/objid/objiden/ ? */
 struct objid {
 	uint32_t           oi_type; /* see c2_conf_objtype for values */
 	struct c2_conf_buf oi_id;
-- 
1.8.3.2

