From 8a6e8b9ce72602635edada9ef8feeb2b710ab547 Mon Sep 17 00:00:00 2001
From: Anatoliy Bilenko <anatoliy_bilenko@xyratex.com>
Date: Sat, 1 Sep 2012 10:44:46 +0300
Subject: [PATCH 352/370] preload: Add confx[] destruction facilities. Add
 parser documentation.

---
 conf/preload.c   | 162 ++++++++++++++++++++++++++++++++++++++++++++-----------
 conf/preload.h   |   2 +
 conf/ut/prepar.c |   5 +-
 3 files changed, 137 insertions(+), 32 deletions(-)

diff --git a/conf/preload.c b/conf/preload.c
index fb288b3..35c8719 100644
--- a/conf/preload.c
+++ b/conf/preload.c
@@ -30,7 +30,7 @@
 #include <ctype.h>		/* isspace */
 #include <stdlib.h>		/* strto{ull,ll,ul,l} @todo: move to misc.h */
 
-#define HUNK_DBG
+/* #define HUNK_DBG */
 #ifdef HUNK_DBG
 #include <stdio.h>
 #endif
@@ -40,6 +40,54 @@
  * Preload parser
  * ------------------------------------------------------------------ */
 
+/*
+  Preload parser minilibrary is used to parse sequences of characters, separated
+  by ',', ':',... providing non-destructive input data capability. It introduces
+  three abstractions:
+
+        - Hunk is like an area of interest in given sequence of characters. It
+          has begin and end to specify the bounds of it. Library provides some
+          minimalistic functions to operate hunks, like validating, copying,
+          comparing the contents the hunk points to, with a C-string, getting
+          its length.
+
+        - Unit is something that parser treats as an atomic and does not parse
+          into. From the beginning it was called an `atom'. Units are in some
+          sense 'context dependent' hunks. For example, the following can be a
+          unit:
+
+           [ { "type":"profile", ... , "id":"test-2" },...,{    ...    } ], ...
+           | | |<---unit_00-->|        |<-unit_0n->| |     |           | |
+           | |<----------------unit_10-------------->|     |<-unit_1n->| |
+           |<------------------------unit_30---------------------------->|
+
+          Library may perform simple manipulations over units, like trimming
+          whitespaces, unquote quoted units. The most interesting part is
+          parsing unit in the beginning of a `stream' and moving to the next
+          separated unit in the stream (unit_parse, unit_next). It's also
+          possible to look into an 'atomic'-hunk and to find out that it's not.
+          Advancing into unit_10, 'may find something in undividable'
+          (unit_advance).
+
+        - Sequence iterator is a wrapper over unit_parse() and unit_next() which
+          provides an iterator-like iterface. Currently, unit, state of stream
+          (buffer) and the type of used separator is a context of the iterator.
+
+  Usage:
+          struct hunk stream = HUNK_INITS("[parsed, seq], [of, bytes]");
+          struct hunk unit = HUNK_EMPTY;
+          size_t ui;
+          int    rc;
+
+          for (; (rc = seq_iterate(&unit, &stream, ',')) == 0; ui++) {
+                C2_ASSERT(hunk_str_eq(&stream, "[parsed, seq], [of, bytes]"));
+                C2_ASSERT(ergo(ui == 0, hunk_str_eq(&unit, "[parsed, seq]")));
+                C2_ASSERT(ergo(ui == 1, hunk_str_eq(&unit, "[of, bytes]")));
+          }
+
+          C2_ASSERT(rc == -ENOENT);
+ */
+
 struct hunk {
 	const char *begin;
 	const char *end;
@@ -54,7 +102,7 @@ static bool hunk_is_empty(const struct hunk *p)
 	return p->begin == NULL && p->end == NULL;
 }
 
-static bool hunk_is_valid(const struct hunk *p)
+static bool hunk_invariant(const struct hunk *p)
 {
 	C2_PRE(!hunk_is_empty(p));
 	return p->end >= p->begin;
@@ -82,8 +130,7 @@ static void hunk_cp(struct hunk *dest, const struct hunk *source) {
 
 static size_t hunk_len(const struct hunk *hunk)
 {
-	C2_PRE(!hunk_is_empty(hunk));
-	C2_PRE(hunk_is_valid(hunk));
+	C2_PRE(hunk_invariant(hunk));
 
 	return hunk->end - hunk->begin + 1;
 }
@@ -103,9 +150,10 @@ static bool hunk_str_eq(const struct hunk *hunk, const char *string)
 	return memcmp(hunk->begin, string, len) == 0;
 }
 
-static int hunk_trim(struct hunk *p)
+
+static int unit_trim(struct hunk *p)
 {
-	C2_PRE(!hunk_is_empty(p));
+	C2_PRE(hunk_invariant(p));
 
 	while (isspace(*p->begin)) {
 		p->begin++;
@@ -119,12 +167,12 @@ static int hunk_trim(struct hunk *p)
 			return -ENOENT;
 	}
 
-	return hunk_is_valid(p) ? 0 : -EINVAL;
+	return hunk_invariant(p) ? 0 : -EINVAL;
 }
 
 static int unit_advance(struct hunk *unit, char open, char close)
 {
-	C2_PRE(!hunk_is_empty(unit));
+	C2_PRE(hunk_invariant(unit));
 
 	if (!(*unit->begin == open && *unit->end == close))
 		return -EINVAL;
@@ -132,7 +180,7 @@ static int unit_advance(struct hunk *unit, char open, char close)
 	unit->begin++;
 	unit->end--;
 
-	return hunk_is_valid(unit) ? 0 : -ENOENT;
+	return hunk_invariant(unit) ? 0 : -ENOENT;
 }
 
 static int unit_quoted_unquote(struct hunk *unit)
@@ -152,7 +200,7 @@ static int unit_parse(struct hunk *unit, char ss)
 	int  curly  = 0;
 	bool quoted = false;
 
-	if ((rc = hunk_trim(unit)) != 0)
+	if ((rc = unit_trim(unit)) != 0)
 		return rc;
 
 	for (p = unit->begin; p <= unit->end; ++p) {
@@ -169,7 +217,7 @@ static int unit_parse(struct hunk *unit, char ss)
 
 		if (!curly && !brace && (*p == ss || p == unit->end)) {
 			unit->end = (*p == ss) ? --p : p;
-			return hunk_trim(unit);
+			return unit_trim(unit);
 		}
 	}
 
@@ -180,27 +228,30 @@ static int unit_next(struct hunk *unit, const struct hunk *buffer, char ss)
 {
 	int  rc;
 
-	C2_PRE(!hunk_is_empty(buffer));
+	C2_PRE(hunk_invariant(unit));
+
 	unit->begin = unit->end;
 	unit->end = buffer->end;
 
 	++unit->begin;
-	if (!hunk_is_valid(unit))
+	if (!hunk_invariant(unit))
 		return -ENOENT;
 
-	if ((rc = hunk_trim(unit)) != 0)
+	if ((rc = unit_trim(unit)) != 0)
 		return rc;
 
 	if (*unit->begin++ != ss)
 		return -EINVAL;
 
+	C2_POST(hunk_invariant(unit));
 	return 0;
 }
 
+
 /**
- *  @param ss	sequence separator, like ',' or ':'
+ *  @param ss sequence separator, like ',' or ':'
  */
-static int sequence_parse(struct hunk *unit, const struct hunk *buffer, char ss)
+static int seq_iterate(struct hunk *unit, const struct hunk *buffer, char ss)
 {
 	int  rc;
 
@@ -218,20 +269,25 @@ static int sequence_parse(struct hunk *unit, const struct hunk *buffer, char ss)
 }
 
 /* @todo: Very unoptimal sequence length calculation */
-static int sequence_len(const struct hunk *unit, char ss)
+static int seq_length(const struct hunk *unit, char ss)
 {
 	int length = 0;
 	struct hunk contents = HUNK_EMPTY;
 
-	while (sequence_parse(&contents, unit, ss) == 0)
+	while (seq_iterate(&contents, unit, ss) == 0)
 		length++;
 
 	return length;
 }
 
+
+/* ------------------------------------------------------------------
+ * Preload parser helpers
+ * ------------------------------------------------------------------ */
+
 static int block_parse(struct hunk *unit, const struct hunk *buffer)
 {
-	return sequence_parse(unit, buffer, ',');
+	return seq_iterate(unit, buffer, ',');
 }
 
 static int record_parse(struct hunk *unit, const struct hunk *buffer)
@@ -239,7 +295,7 @@ static int record_parse(struct hunk *unit, const struct hunk *buffer)
 	struct hunk contents = HUNK_CP(buffer);
 
 	return unit_advance(&contents, '[', ']') ?:
-		sequence_parse(unit, &contents, ',');
+		seq_iterate(unit, &contents, ',');
 }
 
 static int entry_parse(struct hunk *unit, const struct hunk *buffer)
@@ -247,7 +303,7 @@ static int entry_parse(struct hunk *unit, const struct hunk *buffer)
 	struct hunk contents = HUNK_CP(buffer);
 
 	return unit_advance(&contents, '{', '}') ?:
-		sequence_parse(unit, &contents, ',');
+		seq_iterate(unit, &contents, ',');
 }
 
 
@@ -257,52 +313,60 @@ static int entry_parse(struct hunk *unit, const struct hunk *buffer)
 
 enum { C2_CO_INVALID_TYPE = C2_CO_NR };
 
+static bool kv_invariant(const struct hunk *key, const struct hunk *val)
+{
+	return hunk_invariant(key) && hunk_invariant(val);
+}
+
 static int rootfid_parse(struct fid *fid, const struct hunk *val)
 {
 	int rc;
 	struct hunk aval = HUNK_CP(val);
 	struct hunk rfid = HUNK_EMPTY;
 
+	C2_PRE(hunk_invariant(val));
+
 	rc = unit_advance(&aval, '[', ']');
 	if (rc != 0)
 		return rc;
 
-	rc = sequence_parse(&rfid, &aval, ',');
+	rc = seq_iterate(&rfid, &aval, ',');
 	if (rc != 0)
 		return rc;
 	fid->f_container = strtoull(rfid.begin, NULL, 0);
 
-	rc = sequence_parse(&rfid, &aval, ',');
+	rc = seq_iterate(&rfid, &aval, ',');
 	if (rc != 0)
 		return rc;
 	fid->f_key = strtoull(rfid.begin, NULL, 0);
 
-	rc = sequence_parse(&rfid, &aval, ',');
+	rc = seq_iterate(&rfid, &aval, ',');
 
 	return rc == -ENOENT ? 0 : -EINVAL;
 }
 
 static int arrbuf_parse(struct arr_buf *buf, const struct hunk *val)
 {
+	/* parse: ~["addr1","addr2","addr3"]~ */
 	int i;
 	int rc;
 	struct hunk aval = HUNK_CP(val);
 	struct hunk qent = HUNK_EMPTY; /* quoted entry */
 	struct hunk uent = HUNK_EMPTY; /* unquoted entry */
 
-	/* parse: ~["addr1","addr2","addr3"]~ */
+	C2_PRE(hunk_invariant(val));
 
 	rc = unit_advance(&aval, '[', ']');
 	if (rc != 0)
 		return rc;
 
-	buf->ab_count = sequence_len(&aval, ',');
+	buf->ab_count = seq_length(&aval, ',');
 	C2_ALLOC_ARR(buf->ab_elems, buf->ab_count);
 	if (buf->ab_elems == NULL)
 		return -ENOMEM;
 
 	for (i = 0; i < buf->ab_count; ++i) {
-		rc = sequence_parse(&qent, &aval, ',');
+		rc = seq_iterate(&qent, &aval, ',');
 		if (rc != 0)
 			return rc;
 
@@ -321,6 +385,7 @@ static int arrbuf_parse(struct arr_buf *buf, const struct hunk *val)
 static int profile_parse(const struct hunk *key, const struct hunk *val,
 			 struct confx_object *out)
 {
+	C2_PRE(kv_invariant(key, val));
 	hunk_pr(__FUNCTION__, key);
 	hunk_pr(__FUNCTION__, val);
 
@@ -340,6 +405,7 @@ static int profile_parse(const struct hunk *key, const struct hunk *val,
 static int filesystem_parse(const struct hunk *key, const struct hunk *val,
 			    struct confx_object *out)
 {
+	C2_PRE(kv_invariant(key, val));
 	hunk_pr(__FUNCTION__, key);
 	hunk_pr(__FUNCTION__, val);
 
@@ -366,6 +432,7 @@ static int filesystem_parse(const struct hunk *key, const struct hunk *val,
 static int service_parse(const struct hunk *key, const struct hunk *val,
 			 struct confx_object *out)
 {
+	C2_PRE(kv_invariant(key, val));
 	hunk_pr(__FUNCTION__, key);
 	hunk_pr(__FUNCTION__, val);
 
@@ -393,6 +460,7 @@ static int service_parse(const struct hunk *key, const struct hunk *val,
 static int node_parse(const struct hunk *key, const struct hunk *val,
 		      struct confx_object *out)
 {
+	C2_PRE(kv_invariant(key, val));
 	hunk_pr(__FUNCTION__, key);
 	hunk_pr(__FUNCTION__, val);
 
@@ -434,6 +502,7 @@ static int node_parse(const struct hunk *key, const struct hunk *val,
 static int nic_parse(const struct hunk *key, const struct hunk *val,
 		     struct confx_object *out)
 {
+	C2_PRE(kv_invariant(key, val));
 	hunk_pr(__FUNCTION__, key);
 	hunk_pr(__FUNCTION__, val);
 
@@ -469,6 +538,7 @@ static int nic_parse(const struct hunk *key, const struct hunk *val,
 static int sdev_parse(const struct hunk *key, const struct hunk *val,
 		      struct confx_object *out)
 {
+	C2_PRE(kv_invariant(key, val));
 	hunk_pr(__FUNCTION__, key);
 	hunk_pr(__FUNCTION__, val);
 
@@ -511,6 +581,7 @@ static int sdev_parse(const struct hunk *key, const struct hunk *val,
 static int partition_parse(const struct hunk *key, const struct hunk *val,
 			   struct confx_object *out)
 {
+	C2_PRE(kv_invariant(key, val));
 	hunk_pr(__FUNCTION__, key);
 	hunk_pr(__FUNCTION__, val);
 
@@ -589,17 +660,17 @@ static int x_parser_call(const struct hunk *str, struct confx_object *out)
 	struct hunk key = HUNK_EMPTY;
 	struct hunk val = HUNK_EMPTY;
 
-	rc = sequence_parse(&ent, str, ':');
+	rc = seq_iterate(&ent, str, ':');
 	if (rc != 0)
 		return rc;
 	hunk_cp(&key, &ent);
 
-	rc = sequence_parse(&ent, str, ':');
+	rc = seq_iterate(&ent, str, ':');
 	if (rc != 0)
 		return rc;
 	hunk_cp(&val, &ent);
 
-	rc = sequence_parse(&ent, str, ':');
+	rc = seq_iterate(&ent, str, ':');
 	if (rc != -ENOENT)
 		return -EINVAL;
 
@@ -640,6 +711,7 @@ int c2_conf_parse(const char *src, struct confx_object *dest, size_t n)
 
 		for (; record_parse(&rec, &blk) == 0; ) {
 			struct hunk ent = HUNK_EMPTY;
+
 			dest[conf_index].o_conf.u_type = C2_CO_INVALID_TYPE;
 
 			for (; entry_parse(&ent, &rec) == 0; ) {
@@ -656,3 +728,33 @@ int c2_conf_parse(const char *src, struct confx_object *dest, size_t n)
 
 	return conf_index;
 }
+
+void c2_confx_fini(struct confx_object *dest, size_t n)
+{
+	int i;
+	struct confx_object     *conf;
+	struct confx_filesystem *xfs;
+	struct confx_service    *xsrv;
+	struct confx_node       *xnode;
+	struct confx_sdev       *xsd;
+
+	for (i = 0; i < n; ++i) {
+		conf = &dest[i];
+
+		if (conf->o_conf.u_type == C2_CO_FILESYSTEM) {
+			xfs = &conf->o_conf.u.u_filesystem;
+			c2_free(xfs->xf_params.ab_elems);
+			c2_free(xfs->xf_services.ab_elems);
+		} else if (conf->o_conf.u_type == C2_CO_SERVICE) {
+			xsrv = &conf->o_conf.u.u_service;
+			c2_free(xsrv->xs_endpoints.ab_elems);
+		} else if (conf->o_conf.u_type == C2_CO_NODE) {
+			xnode = &conf->o_conf.u.u_node;
+			c2_free(xnode->xn_nics.ab_elems);
+			c2_free(xnode->xn_sdevs.ab_elems);
+		} else if (conf->o_conf.u_type == C2_CO_SDEV) {
+			xsd = &conf->o_conf.u.u_sdev;
+			c2_free(xsd->xd_partitions.ab_elems);
+		}
+	}
+}
diff --git a/conf/preload.h b/conf/preload.h
index dff12e2..b61c7ad 100644
--- a/conf/preload.h
+++ b/conf/preload.h
@@ -148,5 +148,7 @@ struct confx_object;
  */
 int c2_conf_parse(const char *src, struct confx_object *dest, size_t n);
 
+void c2_confx_fini(struct confx_object *dest, size_t n);
+
 /** @} conf_dfspec_preload */
 #endif /* __COLIBRI_CONF_PRELOAD_H__ */
diff --git a/conf/ut/prepar.c b/conf/ut/prepar.c
index 5d7a47f..0acb537 100644
--- a/conf/ut/prepar.c
+++ b/conf/ut/prepar.c
@@ -208,7 +208,7 @@ static void partition_check(const struct confx_object *conf)
 	C2_ASSERT(conf->o_conf.u_type == C2_CO_PARTITION);
 	C2_ASSERT(conf->o_conf.u.u_partition.xa_start == 0);
 	C2_ASSERT(conf->o_conf.u.u_partition.xa_size == 596000000000);
-	C2_ASSERT(conf->o_conf.u.u_partition.xa_index ==0);
+	C2_ASSERT(conf->o_conf.u.u_partition.xa_index == 0);
 	C2_ASSERT(conf->o_conf.u.u_partition.xa_type == 7);
 	C2_ASSERT(c2_buf_eq(&conf->o_conf.u.u_partition.xa_file, &fn));
 }
@@ -229,7 +229,6 @@ int main(void)
 	printf("entries: %d\n", n);
 
 	C2_ASSERT(n == 8);
-
 	profile_check(&conf[0]);
 	filesystem_check(&conf[1]);
 	service_check1(&conf[2]);
@@ -239,5 +238,7 @@ int main(void)
 	sdev_check(&conf[6]);
 	partition_check(&conf[7]);
 
+	c2_confx_fini(conf, n);
+
 	return 0;
 }
-- 
1.8.3.2

