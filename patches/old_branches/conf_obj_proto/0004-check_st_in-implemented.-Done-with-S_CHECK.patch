From 79c6040e5cae6354aa2267493106818c3c0d6167 Mon Sep 17 00:00:00 2001
From: "Valery V. Vorotyntsev" <valery_vorotyntsev@xyratex.com>
Date: Sat, 11 Feb 2012 01:28:33 +0200
Subject: [PATCH 004/370] check_st_in() implemented. Done with S_CHECK.

+ c2_confc_fetchctx::fc__clink: new field.
+ c2_confc_fetchctx::fc_errno replaced with c2_confc_error().
+ cache.h: Move struct c2_conf_cache to a separate file as it is only
  used by confc and confd implementations.
+ c2_conf_cache::cc_root is now a pointer to generic configuration object
  (c2_conf_obj), not profile object.
+ Improve documentation of c2_conf_cache::cc_lock. It *is* used after all.
+ c2_confc_close() and c2_confc_open_sync() implemented.
---
 conf/cache.h    |  59 +++++++++++++++
 conf/conf.c     |   1 +
 conf/conf.h     |  37 ++--------
 conf/confc.c    | 222 ++++++++++++++++++++++++++++++++++++++------------------
 conf/confc.h    |  33 +++++++--
 conf/confop.ff  |   6 +-
 conf/path.h     |   2 +-
 conf/relation.c |   5 +-
 conf/relation.h |   9 +--
 conf/ut/confc.c |   9 ++-
 10 files changed, 262 insertions(+), 121 deletions(-)
 create mode 100644 conf/cache.h

diff --git a/conf/cache.h b/conf/cache.h
new file mode 100644
index 0000000..11e560d
--- /dev/null
+++ b/conf/cache.h
@@ -0,0 +1,59 @@
+/* -*- c -*- */
+/*
+ * COPYRIGHT 2012 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: Valery V. Vorotyntsev <valery_vorotyntsev@xyratex.com>
+ * Original creation date: 11-Feb-2012
+ */
+#ifndef __COLIBRI_CONF_CACHE_H__
+#define __COLIBRI_CONF_CACHE_H__
+
+#ifndef __C2_CONF_IMPL
+#  error "conf/cache.h is not supposed to be #include-d."
+#endif
+
+#include "lib/mutex.h" /* c2_mutex */
+
+struct c2_sm_group;
+struct c2_conf_obj;
+
+/** Configuration cache. */
+struct c2_conf_cache {
+	/** Serializes confc state machines. */
+	struct c2_sm_group *cc_sm_group;
+
+	/**
+	 * Protects this structure and the overall configuration cache
+	 * (the DAG of configuration objects) from concurrent writes.
+	 */
+	struct c2_mutex     cc_lock;
+
+	/**
+	 * Root configuration object.
+	 *
+	 * NULL for uninitialized confc.
+	 * NULL for confd --- confd doesn't have a single root object.
+	 */
+	struct c2_conf_obj *cc_root;
+};
+
+/*
+ * Those are confc and confd implementations, not configuration
+ * consumers, who create configuration objects.
+ */
+void c2_conf_obj_init(struct c2_conf_obj *obj);
+void c2_conf_obj_fini(struct c2_conf_obj *obj);
+
+#endif /* __COLIBRI_CONF_CACHE_H__ */
diff --git a/conf/conf.c b/conf/conf.c
index 2fee72f..abc9658 100644
--- a/conf/conf.c
+++ b/conf/conf.c
@@ -41,3 +41,4 @@ bool c2_conf_bytes_eq(const struct c2_conf_bytes *s1,
 	return s1->cb_len == s2->cb_len
 		&& memcmp(s1->cb_data, s2->cb_data, s1->cb_len) == 0;
 }
+C2_EXPORTED(c2_conf_bytes_eq);
diff --git a/conf/conf.h b/conf/conf.h
index 4bbca04..2576534 100644
--- a/conf/conf.h
+++ b/conf/conf.h
@@ -40,11 +40,12 @@ enum c2_conf_objtype {
 	C2_CO_NR
 };
 
-/** Checks the value of c2_conf_objtype. */
-static inline bool c2_conf_objtype_invariant(enum c2_conf_objtype x)
-{
-	return C2_CO_PROFILE <= x && x < C2_CO_NR;
-}
+/** Status of configuration object. */
+enum c2_conf_status {
+	C2_CS_MISSING, /*< Configuration is absent; no retrieval in progress. */
+	C2_CS_LOADING, /*< Retrieval of configuration is in progress. */
+	C2_CS_READY    /*< Configuration is available. */
+};
 
 /** Sequence of bytes. */
 struct c2_conf_bytes {
@@ -56,13 +57,6 @@ struct c2_conf_bytes {
 bool c2_conf_bytes_eq(const struct c2_conf_bytes *s1,
 		      const struct c2_conf_bytes *s2);
 
-/** Status of configuration object. */
-enum c2_conf_status {
-	C2_CS_MISSING, /*< Configuration is absent; no retrieval in progress. */
-	C2_CS_LOADING, /*< Retrieval of configuration is in progress. */
-	C2_CS_READY    /*< Configuration is available. */
-};
-
 /** Abstract configuration object. */
 struct c2_conf_obj {
 	enum c2_conf_objtype co_type;
@@ -90,25 +84,6 @@ struct c2_conf_profile {
 	struct c2_conf_filesystem *cp_filesystem;
 };
 
-/** Configuration cache. */
-struct c2_conf_cache {
-	/** Serializes confc state machines. */
-	struct c2_sm_group     *cc_sm_group;
-
-	/**
-	 * Protects this structure and the DAG of configuration
-	 * objects from concurrent writes.
-	 */
-	struct c2_mutex         cc_lock; /* XXX Is it needed? */
-
-	/**
-	 * Root configuration object of a confc cache.
-	 *
-	 * NULL for uninitialized confc. Always NULL for confd.
-	 */
-	struct c2_conf_profile *cc_root;
-};
-
 struct c2_conf_filesystem {
 	struct c2_conf_obj cf_obj;
 	struct c2_fid      cf_rootfid;
diff --git a/conf/confc.c b/conf/confc.c
index 38eb64c..4b4d869 100644
--- a/conf/confc.c
+++ b/conf/confc.c
@@ -22,13 +22,50 @@
 #  include <config.h>
 #endif
 #include "conf/confc.h"
+
+#define __C2_CONF_IMPL
+#include "conf/cache.h" /* c2_conf_cache */
+
 #include "lib/cdefs.h"  /* container_of */
+#include "lib/arith.h"  /* C2_CNT_INC, C2_CNT_DEC */
+#include "lib/time.h"   /* C2_TIME_NEVER */
 
 static struct c2_conf_cache confc_cache; /*< Confc's configuration cache. */
 
 enum confc_state { S_INITIAL, S_CHECK, S_WAIT_REPLY, S_WAIT_STATUS,
 		   S_GROW_CACHE, S_FAILURE, S_TERMINAL, S_NR };
 
+static void state_set(struct c2_sm_group *grp __attribute__((unused)),
+		      struct c2_sm_ast *ast)
+{
+	struct c2_confc_fetchctx *ctx =
+		container_of(ast, struct c2_conf_fetchctx, fc__ast);
+	c2_sm_state_set(&ctx->fc_mach, (enum confc_state)ast->sa_datum);
+}
+
+/** Actions to perform on "object unpinned" event. */
+static bool unpinned_cb(struct c2_clink *link)
+{
+	struct c2_confc_fetchctx *ctx =
+		container_of(link, struct c2_confc_fetchctx, fc__clink);
+
+	ctx->fc__ast.sa_cb    = state_set;
+	ctx->fc__ast.sa_datum = S_CHECK;
+	c2_sm_ast_post(confc_cache.cc_sm_group, &ctx->fc__ast);
+}
+
+void c2_confc_fetchctx_init(struct c2_confc_fetchctx *ctx)
+{
+	c2_clink_init(&ctx->fc__clink, unpinned_cb);
+}
+C2_EXPORTED(c2_confc_fetchctx_init);
+
+void c2_confc_fetchctx_fini(struct c2_confc_fetchctx *ctx)
+{
+	c2_clink_fini(&ctx->fc__clink);
+}
+C2_EXPORTED(c2_confc_fetchctx_fini);
+
 static enum c2_conf_status
 list_status(const struct c2_tl_descr *descr, const struct c2_tl *list)
 {
@@ -50,13 +87,14 @@ list_status(const struct c2_tl_descr *descr, const struct c2_tl *list)
 static int
 path_status(struct c2_confc_fetchctx *ctx, enum c2_conf_status *status)
 {
-	struct c2_conf_obj *obj =
-		ctx->fc__path->p_origin ?: &confc_cache->cc_root->cp_obj;
+	struct c2_conf_obj *obj = ctx->fc__path->p_origin ?:
+		confc_cache->cc_root;
 	struct c2_conf_pathcomp *comp = ctx->fc__path->p_comps;
-	size_t nr = ctx->fc__path->p_nr_comps; /* remaining nr of components */
+	size_t nr = ctx->fc__path->p_nr_comps; /* nr of remaining components */
 	bool target_is_directory = false;
 
-	C2_ASSERT(c2_conf_path_invariant(ctx->fc__path));
+	C2_PRE(c2_conf_path_invariant(ctx->fc__path));
+	c2_mutex_lock(&confc_cache.cc_lock);
 	*status = obj->co_status;
 
 	for (; *status == C2_CS_READY && nr > 0; --nr, ++comp) {
@@ -69,7 +107,7 @@ path_status(struct c2_confc_fetchctx *ctx, enum c2_conf_status *status)
 		target_is_directory = rel->r_dir != NULL;
 
 		if (target_is_directory) {
-			if (nr == 1) { /* the last path component */
+			if (nr == 1) { /* the last component */
 				*status = list_status(XXX_descr, XXX_list);
 				break;
 			}
@@ -88,6 +126,7 @@ path_status(struct c2_confc_fetchctx *ctx, enum c2_conf_status *status)
 
 		if (child == NULL) {
 			C2_ASSERT(comp->pc_iskey);
+			c2_mutex_unlock(&confc_cache.cc_lock);
 			return -ENOENT; /* no such key */
 		}
 
@@ -96,7 +135,7 @@ path_status(struct c2_confc_fetchctx *ctx, enum c2_conf_status *status)
 	}
 
 	if (*status == C2_CS_READY) {
-		++obj->co_nrefs;
+		C2_CNT_INC(obj->co_nrefs);
 		if (target_is_directory) {
 			XXX; /* fetchctx->fc_result = dir_allocate() */
 		} else {
@@ -121,88 +160,78 @@ path_status(struct c2_confc_fetchctx *ctx, enum c2_conf_status *status)
 		if (target_is_directory) {
 			XXX; /* scan directory, adding clinks */
 		} else {
-			XXX; /* clink_add(&obj->co_chan) */
+			c2_clink_add(&obj->co_chan, &ctx->fc__clink);
 		}
 	} else {
 		C2_IMPOSSIBLE("invalid object status");
 	}
 
+	c2_mutex_unlock(&confc_cache.cc_lock);
 	return 0;
 }
 
 /** Actions to perform on entering CHECK state. */
 static void check_st_in(struct c2_sm *mach)
 {
-	int rc;
 	enum c2_conf_status status;
+	int rc;
 	struct c2_confc_fetchctx *ctx =
 		container_of(mach, struct c2_confc_fetchctx, fc_mach);
 
 	C2_PRE(c2_mutex_is_locked(&confc_cache.cc_sm_group->s_lock));
 
 	rc = path_status(ctx, &status);
-	if (rc != 0) {
-		C2_ASSERT(rc < 0);
-		ctx->fc_errno = rc;
+	if (rc != 0)
 		c2_sm_fail(mach, S_FAILURE, rc);
-		goto end;
-	}
-
-	if (status == C2_CS_MISSING) {
-		XXX;
-	} else if (status == C2_CS_LOADING) {
-		XXX;
-	} else if (status == C2_CS_READY) {
-		C2_ASSERT(ctx->fc_result != NULL && mach->sm_rc == 0
-			  && ctx->fc_errno == 0);
+	else if (status == C2_CS_MISSING)
+		c2_sm_state_set(mach, S_WAIT_REPLY);
+	else if (status == C2_CS_LOADING)
+		c2_sm_state_set(mach, S_WAIT_STATUS);
+	else if (status == C2_CS_READY)
 		c2_sm_state_set(mach, S_TERMINAL);
-	} else {
+	else
 		C2_IMPOSSIBLE("status is not valid");
-	}
-end:
+
 	C2_POST(c2_mutex_is_locked(&confc_cache.cc_sm_group->s_lock));
 }
 
+/** Actions to perform on entering WAIT_REPLY state. */
+static void wait_reply_st_in(struct c2_sm *mach)
+{
+	struct c2_confc_fetchctx *ctx =
+		container_of(mach, struct c2_confc_fetchctx, fc_mach);
+
+	C2_ASSERT(ctx->fc__fop.ff_origin.o_objkey.fb_len > 0 &&
+		  ctx->fc__fop.ff_origin.o_objkey.fb_data != NULL);
+
+	/* XXX
+	 * Where do I get c2_rpc_item from?  There is one embedded
+	 * into c2_fop (c2_fop::f_item), but ctx->fc__fop is not a
+	 * c2_fop...
+	 *
+	 * Another question: should xcode data structure
+	 * (c2_confop_fetch) be accessible through c2_fop::f_data?
+	 *
+	 * I need somebody to consult me on RPC subject.
+	 *  --vvv, 2012-02-10
+	 */
+	c2_rpc_post(&XXX_rpc_item);
+}
+
 static bool failure_st_invariant(const struct c2_sm *mach)
 {
 	const struct c2_confc_fetchctx *ctx =
 		container_of(mach, const struct c2_confc_fetchctx, fc_mach);
-	return ctx->fc_result == NULL && ctx->fc_mach.sm_rc < 0
-		&& ctx->fc_errno == -ctx->fc_mach.sm_rc;
+	return ctx->fc_result == NULL && ctx->fc_mach.sm_rc < 0;
+}
+
+static bool terminal_st_invariant(const struct c2_sm *mach)
+{
+	const struct c2_confc_fetchctx *ctx =
+		container_of(mach, const struct c2_confc_fetchctx, fc_mach);
+	return ctx->fc_result != NULL && ctx->fc_mach.sm_rc == 0;
 }
 
-/**
- * Confc states.
- *
- * - INITIAL
- *   - CHECK
- *
- * - CHECK
- *   in:
- *   - Lock the configuration cache (c2_conf_cache::cc_lock).
- *   - [[Traverse the cache as instructed by the path]]
- *     (c2_confc_fetchctx::fc__path) and check the statuses of
- *     configuration objects located on this path.
- ***********************************************************************
- * Results of traversal: all objects are C2_CS_READY
- *                     | some objects are C2_CS_MISSING (the function
- *                       sets their statuses to C2_CS_LOADING)
- *                     | unready objects are C2_CS_LOADING
- *                     | path is invalid
- ***********************************************************************
- *   - If all of the objects are C2_CS_READY then:
- *     - increment reference counter (c2_conf_obj::co_nrefs) of the
- *       requested object or the parent of the requested collection;
- *     - set result pointer (c2_confc_fetchctx::fc_result);
- *     - move to TERMINAL state.
- *   - Otherwise:
- *   ex: Unlock the configuration cache.
- *   allowed:
- *   - TERMINAL
- *   - WAIT_REPLY
- *   - WAIT_STATUS
- *
- */
 static const struct c2_sm_state_descr confc_states[S_NR] = {
 	[S_INITIAL] = {
 		.sd_flags     = C2_SDF_INITIAL,
@@ -210,7 +239,7 @@ static const struct c2_sm_state_descr confc_states[S_NR] = {
 		.sd_in        = NULL,
 		.sd_ex        = NULL,
 		.sd_invariant = NULL,
-		.sd_allowed   = (1 << S_CHECK)
+		.sd_allowed   = 1 << S_CHECK
 	},
 	[S_CHECK] = {
 		.sd_flags     = 0,
@@ -218,8 +247,32 @@ static const struct c2_sm_state_descr confc_states[S_NR] = {
 		.sd_in        = check_st_in,
 		.sd_ex        = NULL,
 		.sd_invariant = NULL,
-		.sd_allowed   = (1 << S_WAIT_REPLY) | (1 << S_WAIT_STATUS)
-		| (1 << S_TERMINAL) | (1 << S_FAILURE)
+		.sd_allowed   = 1 << S_WAIT_REPLY | 1 << S_WAIT_STATUS
+		| 1 << S_TERMINAL | 1 << S_FAILURE
+	},
+	[S_WAIT_REPLY] = {
+		.sd_flags     = 0,
+		.sd_name      = "WAIT_REPLY",
+		.sd_in        = wait_reply_st_in,
+		.sd_ex        = NULL,
+		.sd_invariant = NULL,
+		.sd_allowed   = 1 << S_GROW_CACHE | 1 << S_FAILURE
+	},
+	[S_WAIT_STATUS] = {
+		.sd_flags     = 0,
+		.sd_name      = "WAIT_STATUS",
+		.sd_in        = NULL
+		.sd_ex        = NULL,
+		.sd_invariant = NULL,
+		.sd_allowed   = 1 << S_CHECK
+	},
+	[S_GROW_CACHE] = {
+		.sd_flags     = 0,
+		.sd_name      = "GROW_CACHE",
+		.sd_in        = NULL
+		.sd_ex        = NULL,
+		.sd_invariant = NULL,
+		.sd_allowed   = 1 << S_CHECK | 1 << S_FAILURE
 	},
 	[S_FAILURE] = {
 		.sd_flags     = C2_SDF_FAILURE,
@@ -228,6 +281,14 @@ static const struct c2_sm_state_descr confc_states[S_NR] = {
 		.sd_ex        = NULL,
 		.sd_invariant = failure_st_invariant,
 		.sd_allowed   = 0
+	},
+	[S_TERMINAL] = {
+		.sd_flags     = C2_SDF_TERMINAL,
+		.sd_name      = "TERMINAL",
+		.sd_in        = NULL,
+		.sd_ex        = NULL,
+		.sd_invariant = terminal_st_invariant,
+		.sd_allowed   = 0
 	}
 };
 
@@ -237,14 +298,6 @@ static struct c2_sm_conf confc_states_conf = {
 	.scf_state     = confc_states
 };
 
-static void state_set(struct c2_sm_group *grp __attribute__((unused)),
-		      struct c2_sm_ast *ast)
-{
-	struct c2_confc_fetchctx *ctx =
-		container_of(ast, struct c2_conf_fetchctx, fc__ast);
-	c2_sm_state_set(&ctx->fc_mach, (enum confc_state)ast->sa_datum);
-}
-
 int c2_confc_open(const struct c2_conf_path *path,
 		  struct c2_confc_fetchctx *ctx)
 {
@@ -262,6 +315,37 @@ int c2_confc_open(const struct c2_conf_path *path,
 }
 C2_EXPORTED(c2_confc_open);
 
+void * c2_confc_open_sync(const struct c2_conf_path *path)
+{
+	struct c2_confc_fetchctx ctx;
+	int rc;
+	void *ret = NULL;
+
+	c2_confc_fetchctx_init(&ctx);
+	rc = c2_confc_open(path, &ctx);
+	if (rc == 0) {
+		rc = c2_sm_timedwait(&ctx.fc_mach, S_TERMINAL | S_FAILURE,
+				     C2_TIME_NEVER);
+		C2_ASSERT(rc == 0);
+		ret = ctx.fc_result;
+	}
+	c2_confc_fetchctx_fini(&ctx);
+	return ret;
+}
+C2_EXPORTED(c2_confc_open_sync);
+
+void c2_confc_close(void *obj)
+{
+	struct c2_conf_obj *x = obj;
+
+	c2_mutex_lock(&confc_cache.cc_lock);
+	C2_CNT_DEC(x->co_nrefs);
+	if (x->co_nrefs == 0)
+		c2_chan_broadcast(&x->co_chan);
+	c2_mutex_unlock(&confc_cache.cc_lock);
+}
+C2_EXPORTED(c2_confc_close);
+
 /** Collection of configuration objects. */
 struct c2_confc_dir {
 	/** Parent object this collection belongs to. */
diff --git a/conf/confc.h b/conf/confc.h
index 9c1a11c..0105db5 100644
--- a/conf/confc.h
+++ b/conf/confc.h
@@ -20,7 +20,8 @@
 #ifndef __COLIBRI_CONF_CONFC_H__
 #define __COLIBRI_CONF_CONFC_H__
 
-#include "sm/sm.h" /* c2_sm, c2_sm_ast */
+#include "sm/sm.h"    /* c2_sm, c2_sm_ast */
+#include "lib/chan.h" /* c2_clink */
 
 struct c2_conf_path;
 struct c2_confc_dir;
@@ -47,25 +48,43 @@ void c2_confc_fini(void);
 struct c2_confc_fetchctx {
 	struct c2_sm fc_mach;
 	void        *fc_result;
-	int          fc_errno; /* XXX Can we just use -fc_mach.sm_rc? */
 
-	/* The remaining fields (fc__*) are not supposed to be
-	 * accessed by configuration consumers. */
+	/* -------------------------------------------------------------
+	 * The remaining fields (fc__*) are not supposed to be
+	 * accessed by configuration consumers.
+	 */
 
-	/* Path to the requested object or directory (collection of objects). */
+	/* Path to the requested object or directory (directory is a
+	 * collection of objects). */
 	const struct c2_conf_path *fc__path;
 
 	struct c2_confop_fetch     fc__fop;
 	struct c2_sm_ast           fc__ast;
+
+	/**
+	 * Record of interest in "object unpinned" events.
+	 *
+	 * This clink gets added to c2_conf_obj::co_chan channel.
+	 */
+	struct c2_clink            fc__clink;
 };
 
+void c2_confc_fetchctx_init(struct c2_confc_fetchctx *ctx);
+void c2_confc_fetchctx_fini(struct c2_confc_fetchctx *ctx);
+
+/** Returns the error status for the asynchronous configuration request. */
+static inline int32_t c2_confc_error(const struct c2_confc_fetchctx *ctx)
+{
+	return -ctx->fc_mach.sm_rc;
+}
+
 /*
  * A caller must guarantee existence and immutability of `path' until
  * ctx->fc_mach terminates or fails.
  *
- * @pre  ctx is initiated: its state machine is in INITIAL state,
- *       fc_result == NULL, fc_errno == 0, fc__path == NULL.
  * @pre  c2_conf_path_invariant(path)
+ * @pre  ctx is initiated: its state machine is in INITIAL state,
+ *       fc_result == NULL, fc__path == NULL.
  *
  * @retval -EISDIR  Path leads to a directory.
  */
diff --git a/conf/confop.ff b/conf/confop.ff
index 18843e6..5b90f07 100644
--- a/conf/confop.ff
+++ b/conf/confop.ff
@@ -44,16 +44,16 @@ union {
 	c2_confop_bytes pc_key      :1
 } c2_confop_pathcomp;
 
-/* Configuration fetch request. */
+/* Configuration request. */
 record {
 	record {
 		u32             o_objtype; /* see c2_conf_objtype for values */
 		c2_confop_bytes o_objkey
-	} ff_origin; /* configuration object the path originates from */
+	} ff_origin; /* Configuration object the path originates from. */
 	sequence {
 		u32                c_nr;
 		c2_confop_pathcomp c_data
-	} ff_comps  /* path components */
+	} ff_comps   /* Path components. */
 } c2_confop_fetch;
 
 /* Configuration of a profile. */
diff --git a/conf/path.h b/conf/path.h
index ad94e86..88f6254 100644
--- a/conf/path.h
+++ b/conf/path.h
@@ -46,7 +46,7 @@ struct c2_conf_path {
  */
 bool c2_conf_path_invariant(const struct c2_conf_path *path);
 
-/** Returns true iff `path' ends with a one-to-many downlink. */
+/** Returns true iff the path ends with a one-to-many downlink. */
 bool c2_conf_path_is_dir(const struct c2_conf_path *path);
 
 #endif /* __COLIBRI_CONF_PATH_H__ */
diff --git a/conf/relation.c b/conf/relation.c
index 7660499..07d4eb8 100644
--- a/conf/relation.c
+++ b/conf/relation.c
@@ -88,8 +88,8 @@ c2_conf_downlink(enum c2_conf_objtype src, enum c2_conf_objtype tgt)
 	size_t i;
 	const struct rels rs = downlinks[src];
 
-	C2_PRE(c2_conf_objtype_invariant(src));
-	C2_PRE(c2_conf_objtype_invariant(tgt));
+	C2_PRE(C2_CO_PROFILE <= src && src < C2_CO_NR);
+	C2_PRE(C2_CO_PROFILE <= tgt && tgt < C2_CO_NR);
 
 	for (i = 0; i < rs.nr; ++i) {
 		if (rs.data[i]->r_type == tgt)
@@ -97,3 +97,4 @@ c2_conf_downlink(enum c2_conf_objtype src, enum c2_conf_objtype tgt)
 	}
 	return NULL;
 }
+C2_EXPORTED(c2_conf_downlink);
diff --git a/conf/relation.h b/conf/relation.h
index e62fa9d..422db85 100644
--- a/conf/relation.h
+++ b/conf/relation.h
@@ -22,8 +22,10 @@
 
 #include "conf/conf.h" /* c2_conf_objtype */
 
-/** Relation --- a pointer from one configuration object to another
- * object or a list of objects. */
+/**
+ * Relation --- a pointer from one configuration object to another
+ * object or a list of objects.
+ */
 struct c2_conf_relation {
 	/**
 	 * Type of relation's target.
@@ -50,9 +52,6 @@ struct c2_conf_relation {
  *
  * @param src  Type of object the downlink originates from.
  * @param tgt  Type of downlink's target object(s).
- *
- * @pre  c2_conf_objtype_invariant(src)
- * @pre  c2_conf_objtype_invariant(tgt)
  */
 const struct c2_conf_relation * c2_conf_downlink(enum c2_conf_objtype src,
 						 enum c2_conf_objtype tgt);
diff --git a/conf/ut/confc.c b/conf/ut/confc.c
index f9b94fd..ed5f217 100644
--- a/conf/ut/confc.c
+++ b/conf/ut/confc.c
@@ -76,7 +76,7 @@ static void test_init_fini(void)
 	C2_UT_ASSERT(!c2_mutex_is_locked(&confc_cache.cc_lock));
 	C2_UT_ASSERT(confc_cache.cc_root != NULL);
 
-	obj = &confc_cache.cc_root->cp_obj;
+	obj = confc_cache.cc_root;
 	C2_UT_ASSERT(obj->co_status == C2_CS_MISSING);
 	C2_UT_ASSERT(obj->co_type   == C2_CO_PROFILE);
 	{
@@ -97,8 +97,8 @@ static void test_fetchctx(void)
 	C2_UT_ASSERT(ctx.fc_mach.sm_grp   == &g_grp);
 	C2_UT_ASSERT(ctx.fc_mach.sm_state == S_INITIAL);
 
+	C2_UT_ASSERT(c2_confc_error(&ctx) == 0);
 	C2_UT_ASSERT(ctx.fc_result == NULL);
-	C2_UT_ASSERT(ctx.fc_errno  == 0);
 	C2_UT_ASSERT(ctx.fc__path  == NULL);
 
 	C2_UT_ASSERT(ctx.fc__ast.sa_cb    == NULL);
@@ -109,7 +109,10 @@ static void test_fetchctx(void)
 	 * container_of()->fc_mach */
 	C2_UT_ASSERT(ctx.fc__ast.sa_mach == NULL);
 
-	/* XXX ctx.fc__fop is not checked. */
+	C2_UT_ASSERT(ctx->fc__fop.ff_origin.o_objkey.fb_len  == 0);
+	C2_UT_ASSERT(ctx->fc__fop.ff_origin.o_objkey.fb_data == NULL);
+	C2_UT_ASSERT(ctx->fc__fop.ff_comps.c_nr   == 0);
+	C2_UT_ASSERT(ctx->fc__fop.ff_comps.c_data == NULL);
 }
 
 static void test_open(void)
-- 
1.8.3.2

