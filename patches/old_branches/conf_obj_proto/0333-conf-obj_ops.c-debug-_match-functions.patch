From abf90a01bd1aec452327f18537d9ec708e7eaccf Mon Sep 17 00:00:00 2001
From: "Valery V. Vorotyntsev" <valery_vorotyntsev@xyratex.com>
Date: Tue, 28 Aug 2012 17:28:07 +0300
Subject: [PATCH 333/370] conf/obj_ops.c: debug *_match() functions

+ buf_streq(), arrays_eq(): New functions.
---
 conf/obj_ops.c | 212 +++++++++++++++++++++++++++++----------------------------
 conf/onwire.h  |   1 +
 2 files changed, 109 insertions(+), 104 deletions(-)

diff --git a/conf/obj_ops.c b/conf/obj_ops.c
index c9e83e7..25bdb6c 100644
--- a/conf/obj_ops.c
+++ b/conf/obj_ops.c
@@ -25,7 +25,7 @@
 #include "conf/confc.h"   /* c2_confc */
 #include "lib/cdefs.h"    /* ergo, C2_MAGIX_OFFSET, IS_IN_ARRAY */
 #include "lib/arith.h"    /* C2_CNT_INC, C2_CNT_DEC */
-#include "lib/misc.h"     /* C2_IN, memcpy, strlen */
+#include "lib/misc.h"     /* C2_IN, memcpy, memcmp, strlen */
 #include "lib/memory.h"   /* c2_alloc, C2_ALLOC_ARR */
 #include "lib/tlist.h"
 #include "lib/errno.h"    /* ENOENT, ENOMEM, EINVAL */
@@ -483,6 +483,8 @@ static int dir_new(const struct c2_buf *dir_id, enum c2_conf_objtype child_type,
  * ------------------------------------------------------------------ */
 
 static bool confx_object_is_valid(const struct confx_object *src);
+static bool buf_streq(const struct c2_buf *buf, const char *str);
+static bool arrays_eq(const char **cached, const struct arr_buf *onwire);
 
 bool c2_conf_obj_match(const struct c2_conf_obj *cached,
 		       const struct confx_object *onwire)
@@ -504,9 +506,8 @@ static bool profile_match(const struct c2_conf_obj *cached,
 			  const struct confx_object *onwire)
 {
 	const struct confx_profile      *objx = &onwire->o_conf.u.u_profile;
-	const struct c2_conf_profile    *obj = C2_CONF_CAST(cached,
-							    &onwire->o_id);
-	const struct c2_conf_filesystem *child = obj->cp_filesystem;
+	const struct c2_conf_filesystem *child =
+		C2_CONF_CAST(cached, c2_conf_profile)->cp_filesystem;
 
 	return c2_buf_eq(&child->cf_obj.co_id, &objx->xp_filesystem);
 }
@@ -516,21 +517,11 @@ static bool filesystem_match(const struct c2_conf_obj *cached,
 {
 	const struct confx_filesystem   *objx = &onwire->o_conf.u.u_filesystem;
 	const struct c2_conf_filesystem *obj = C2_CONF_CAST(cached,
-							    &onwire->o_id);
-	const struct c2_conf_service    *child = obj->cf_services;
-	const struct c2_buf             *buf;
-	int                              i;
-
-	for (i = 0; obj->cf_params[i] != NULL; ++i) {
-		C2_ASSERT(i < objx->xf_params.ab_count);
-		buf = &objx->xf_params.ab_elements[i];
-		if (memcmp(obj->cf_params[i], buf->b_addr, buf->b_nob) != 0)
-			return false;
-	}
-
-	return c2_buf_eq(&child->cd_obj.co_id, &objx->xp_services) &&
-		objx->xf_rootfid.f_container == obj->cf_rootfid.f_container &&
-		objx->xf_rootfid.f_size == obj->cf_rootfid.f_size;
+							    c2_conf_filesystem);
+	C2_IMPOSSIBLE("XXX TODO: compare dir elements");
+	return arrays_eq(obj->cf_params, &objx->xf_params) &&
+		obj->cf_rootfid.f_container == objx->xf_rootfid.f_container &&
+		obj->cf_rootfid.f_key == objx->xf_rootfid.f_key;
 }
 
 static bool service_match(const struct c2_conf_obj *cached,
@@ -539,35 +530,24 @@ static bool service_match(const struct c2_conf_obj *cached,
 	const struct confx_service   *objx = &onwire->o_conf.u.u_service;
 	const struct c2_conf_service *obj = C2_CONF_CAST(cached, &onwire->o_id);
 	const struct c2_conf_node    *child = obj->cs_node;
-	const struct c2_buf          *buf;
-	int                           i;
-
-	for (i = 0; obj->cs_endpoints[i] != NULL; ++i) {
-		C2_ASSERT(i < objx->xs_endpoints.ab_count);
-		buf = &objx->xf_endpoints.ab_elements[i];
-		if (memcmp(obj->cs_endpoints[i], buf->b_addr, buf->b_nob) != 0)
-			return false;
-	}
 
-	return c2_buf_eq(&child->cn_obj.co_id, &objx->xs_node) &&
-		obj->cs_type == objx->xs_type;
+	return obj->cs_type == objx->xs_type &&
+		arrays_eq(obj->cs_endpoints, &objx->xs_endpoints) &&
+		c2_buf_eq(&child->cn_obj.co_id, &objx->xs_node);
 }
 
 static bool node_match(const struct c2_conf_obj *cached,
 		       const struct confx_object *onwire)
 {
 	const struct confx_node   *objx = &onwire->o_conf.u.u_node;
-	const struct c2_conf_node *obj = C2_CONF_CAST(cached, &onwire->o_id);
-	const struct c2_conf_nic  *child_nic  = obj->cn_nics;
-	const struct c2_conf_sdev *child_sdev = obj->cn_sdevs;
+	const struct c2_conf_node *obj = C2_CONF_CAST(cached, c2_conf_node);
 
-	C2_IMPOSSIBLE("To be implemented!");
-	return /* XXX TODO: compare dir elements */
-		objx->xn_memsize    == obj->cn_memsize    &&
-		objx->xn_nr_cpu	    == obj->cn_nr_cpu     &&
-		objx->xn_last_state == obj->cn_last_state &&
-		objx->xn_flags	    == obj->cn_flags      &&
-		objx->xn_pool_id    == obj->cn_pool_id;
+	C2_IMPOSSIBLE("XXX TODO: compare dir elements");
+	return  obj->cn_memsize    == objx->xn_memsize    &&
+		obj->cn_nr_cpu     == objx->xn_nr_cpu     &&
+		obj->cn_last_state == objx->xn_last_state &&
+		obj->cn_flags      == objx->xn_flags      &&
+		obj->cn_pool_id    == objx->xn_pool_id;
 
 }
 
@@ -575,31 +555,28 @@ static bool nic_match(const struct c2_conf_obj *cached,
 		      const struct confx_object *onwire)
 {
 	const struct confx_nic   *objx = &onwire->o_conf.u.u_nic;
-	const struct c2_conf_nic *obj = C2_CONF_CAST(cached, &onwire->o_id);
+	const struct c2_conf_nic *obj = C2_CONF_CAST(cached, c2_conf_nic);
 
-	return objx->xi_iface == obj->ni_iface &&
-		objx->xi_mtu == obj->ni_mtu &&
-		objx->xi_speed == obj->ni_speed &&
-		objx->xi_last_state == obj->ni_last_state;
+	return  obj->ni_iface      == objx->xi_iface      &&
+		obj->ni_mtu        == objx->xi_mtu        &&
+		obj->ni_speed      == objx->xi_speed      &&
+		obj->ni_last_state == objx->xi_last_state &&
+		buf_streq(&objx->xi_filename, obj->ni_filename);
 }
 
 static bool sdev_match(const struct c2_conf_obj *cached,
 		       const struct confx_object *onwire)
 {
-	const struct confx_sdev        *objx = &onwire->o_conf.u.u_sdev;
-	const struct c2_conf_sdev      *obj = C2_CONF_CAST(cached,
-							   &onwire->o_id);
-	const struct c2_conf_partition *child = obj->ni_partitions;
-
-	C2_IMPOSSIBLE("To be implemented!");
-	return
-		/* XXX TODO: compare dir elements */
-		/* c2_buf_eq(&child->pa_obj.co_id, &objx->xd_partitions) && */
-		obj->sd_iface == objx->xd_iface &&
-		obj->sd_media == objx->xd_media &&
-		obj->sd_size == objx->xd_size &&
+	const struct confx_sdev   *objx = &onwire->o_conf.u.u_sdev;
+	const struct c2_conf_sdev *obj = C2_CONF_CAST(cached, c2_conf_sdev);
+
+	C2_IMPOSSIBLE("XXX TODO: compare dir elements");
+	return  obj->sd_iface      == objx->xd_iface      &&
+		obj->sd_media      == objx->xd_media      &&
+		obj->sd_size       == objx->xd_size       &&
 		obj->sd_last_state == objx->xd_last_state &&
-		obj->sd_flags == objx->xd_flags;
+		obj->sd_flags      == objx->xd_flags      &&
+		buf_streq(&objx->xd_filename, obj->sd_filename);
 }
 
 static bool partition_match(const struct c2_conf_obj *cached,
@@ -607,13 +584,26 @@ static bool partition_match(const struct c2_conf_obj *cached,
 {
 	const struct confx_partition   *objx = &onwire->o_conf.u.u_partition;
 	const struct c2_conf_partition *obj = C2_CONF_CAST(cached,
-							   &onwire->o_id);
-	return obj->pa_start == objx->xa_start  &&
-		obj->pa_size == objx->xa_size   &&
+							   c2_conf_partition);
+	return  obj->pa_start == objx->xa_start &&
+		obj->pa_size  == objx->xa_size  &&
 		obj->pa_index == objx->xa_index &&
-		obj->pa_type == objx->xa_type   &&
-		memcmp(obj->pa_filename, objx->xa_file.b_addr,
-		       objx->xa_file.b_nob) == 0;
+		obj->pa_type  == objx->xa_type  &&
+		buf_streq(&objx->xa_file, obj->pa_filename);
+}
+
+static bool arrays_eq(const char **cached, const struct arr_buf *onwire)
+{
+	uint32_t i;
+
+	C2_PRE(onwire->ab_count != 0);
+
+	for (i = 0; cached[i] != NULL; ++i) {
+		if (i >= onwire->ab_count || !buf_streq(&onwire->ab_elems[i],
+							cached[i]))
+			return false;
+	}
+	return i == onwire->ab_count;
 }
 
 /* ------------------------------------------------------------------
@@ -750,18 +740,20 @@ static int node_fill(struct c2_conf_obj *__dest,
 	dest->cn_flags      = xn_flags;
 	dest->cn_pool_id    = xn_pool_id;
 
-	rc = c2_buf_copy(&nic_id, &__src->o_id);
-	if (rc != 0)
-		return rc;
+	/* Mangle directories' identifiers to make them unique. */
+	{
+		C2_ASSERT(__src->o_id.b_nob > 1);
 
-	rc = c2_buf_copy(&sdev_id, &__src->o_id);
-	if (rc != 0)
-		return rc;
+		rc = c2_buf_copy(&nic_id, &__src->o_id);
+		if (rc != 0)
+			return rc;
+		nic_id.b_addr[0] = 'N';
 
-	/* making ids of directories different */
-	C2_ASSERT(nic_id.b_nob > 1 && sdev_id.b_nob > 1);
-	nic_id.b_addr[0] = 'N';
-	sdev_id.b_addr[0] = 'S';
+		rc = c2_buf_copy(&sdev_id, &__src->o_id);
+		if (rc != 0)
+			return rc;
+		sdev_id.b_addr[0] = 'S';
+	}
 
 	return dir_new(&nic_id, C2_CO_NIC, &src->xn_nics, reg,
 		       &dest->cn_nics) ?:
@@ -918,6 +910,48 @@ static int dir_readdir(struct c2_conf_obj *dir, struct c2_conf_obj **pptr)
  */
 
 /* ------------------------------------------------------------------
+ * Auxiliary c2_buf operations
+ * ------------------------------------------------------------------ */
+
+static bool buf_is_valid(const struct c2_buf *buf)
+{
+	return buf->b_nob > 0 && buf->b_addr != NULL;
+}
+
+/*
+ * Note, that buf_strdup() expects valid (buf_is_valid()) buffer.
+ * Take care when working with buffers received over network.
+ */
+static char *buf_strdup(const struct c2_buf *buf)
+{
+	size_t len;
+	char  *s;
+
+	C2_PRE(buf_is_valid(buf));
+
+	/* Measure the size of payload. Buffer's bytes beyond '\0'
+	 * will never be used. */
+	len = strlen(buf->b_addr);
+	if (len > buf->b_nob)
+		len = buf->b_nob;
+
+	C2_ALLOC_ARR(s, len + 1);
+	if (s != NULL) {
+		memcpy(s, buf->b_addr, len);
+		s[len] = 0;
+	}
+	return s;
+}
+
+static bool buf_streq(const struct c2_buf *buf, const char *str)
+{
+	C2_PRE(buf_is_valid(buf) && str != NULL);
+
+	return memcmp(str, buf->b_addr, buf->b_nob) == 0 &&
+		strlen(str) == buf->b_nob;
+}
+
+/* ------------------------------------------------------------------
  * misc.
  * ------------------------------------------------------------------ */
 
@@ -973,36 +1007,6 @@ static bool obj_is_stub(const struct c2_conf_obj *obj)
 	return obj->co_status != C2_CS_READY;
 }
 
-static bool buf_is_valid(const struct c2_buf *buf)
-{
-	return buf->b_nob > 0 && buf->b_addr != NULL;
-}
-
-/*
- * Note, that buf_strdup() expects valid (buf_is_valid()) buffer.
- * Take care when working with buffers received over network.
- */
-static char *buf_strdup(const struct c2_buf *buf)
-{
-	size_t len;
-	char  *s;
-
-	C2_PRE(buf_is_valid(buf));
-
-	/* Measure the size of payload. Buffer's bytes beyond '\0'
-	 * will never be used. */
-	len = strlen(buf->b_addr);
-	if (len > buf->b_nob)
-		len = buf->b_nob;
-
-	C2_ALLOC_ARR(s, len + 1);
-	if (s != NULL) {
-		memcpy(s, buf->b_addr, len);
-		s[len] = 0;
-	}
-	return s;
-}
-
 /** Performs sanity checking of given onwire object. */
 static bool confx_object_is_valid(const struct confx_object *src)
 {
diff --git a/conf/onwire.h b/conf/onwire.h
index 5dc8309..378bdbb 100644
--- a/conf/onwire.h
+++ b/conf/onwire.h
@@ -42,6 +42,7 @@ struct objid {
 	struct c2_buf oi_id;
 } C2_XCA_RECORD;
 
+/** XXX @todo Use c2_fid? */
 struct fid {
 	uint64_t f_container;
 	uint64_t f_key;
-- 
1.8.3.2

