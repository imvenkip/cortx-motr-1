From 98d5c78ef1c99c6221dffba4bbb8d9d19564017b Mon Sep 17 00:00:00 2001
From: "Valery V. Vorotyntsev" <valery_vorotyntsev@xyratex.com>
Date: Fri, 6 Jul 2012 14:17:56 +0300
Subject: [PATCH 229/370] conf/obj_ops.c: describe lookup/readdir
 implementations

+ conf/obj.c: Add the intention to replace c2_conf_buf with C string.
---
 conf/confc.h   |  2 +-
 conf/obj.c     |  5 +++-
 conf/obj.h     |  2 +-
 conf/obj_ops.c | 84 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 4 files changed, 90 insertions(+), 3 deletions(-)

diff --git a/conf/confc.h b/conf/confc.h
index e62ef40..e918e59 100644
--- a/conf/confc.h
+++ b/conf/confc.h
@@ -211,7 +211,7 @@ struct c2_mutex;
  *     if (rc != 0)
  *         return rc;
  *
- *     // This is an idiom: initialize c2_conf_dircur and close
+ *     // This is the idiom: initialize c2_conf_dircur and close
  *     // directory object.  c2_conf_dircur will keep the object pinned.
  *     c2_conf_dircur_init(&cur, C2_CONF_CAST(obj, c2_conf_dir));
  *     c2_confc_close(obj);
diff --git a/conf/obj.c b/conf/obj.c
index 5e7d81a..f4c868d 100644
--- a/conf/obj.c
+++ b/conf/obj.c
@@ -361,7 +361,10 @@
  * (@todo Delete this section from the DLD when the feature is landed
  * into master.)
  *
- * XXX
+ * - Object identifiers can be expressed perfectly well with C strings,
+ *   so I'm going to use `const char *' for c2_conf_obj::co_id and get
+ *   rid of c2_conf_buf.  The only place where c2_conf_buf (Pascal string)
+ *   might remain is conf/onwire.ff.
  */
 
 /**
diff --git a/conf/obj.h b/conf/obj.h
index cc9059c..e5fd46f 100644
--- a/conf/obj.h
+++ b/conf/obj.h
@@ -395,7 +395,7 @@ struct c2_conf_obj_ops {
 	 * Returns the next directory entry.
 	 *
 	 * @retval 1    *result now points to the next directory entry.
-	 * @retval 0    End of the directory is reached.
+	 * @retval 0    End of directory is reached.
 	 * @retval < 0  Error.
 	 *
 	 * @pre  cur->dc_dir->cd_obj.co_status == C2_CS_READY
diff --git a/conf/obj_ops.c b/conf/obj_ops.c
index f3834bb..bada2f3 100644
--- a/conf/obj_ops.c
+++ b/conf/obj_ops.c
@@ -116,5 +116,89 @@ int c2_conf_obj_fill(struct c2_conf_obj *dest, const struct confx_object *src,
 	 */
 	XXX;
 }
+
+/* ------------------------------------------------------------------
+ * Implementations of ->coo_{lookup,readdir}() for concrete object types
+ * ------------------------------------------------------------------ */
+
+/* XXX
+ *
+ * Note, that signatures of *_lookup()s below differ from the
+ * signature of c2_conf_obj_ops::coo_lookup: `name' argument in the
+ * latter is `const struct c2_conf_buf *', not `const char *'.
+ *
+ * I am going to use `const char *' for c2_conf_obj::co_id.
+ * See @ref conf-impl-plan.
+ */
+
+static int dir_lookup(struct c2_conf_obj *parent, const char *name,
+		      struct c2_conf_obj **out)
+{
+	struct c2_conf_obj     *child;
+	struct c2_conf_profile *dir = C2_CONF_CAST(parent, c2_conf_dir);
+
+	C2_PRE(parent->co_status == C2_CS_READY);
+
+	/*
+	 * for_each(child in dir->cd_items) {
+	 *     if (streq(child->co_id, name)) {
+	 *         *out = child;
+	 *         return 0;
+	 *     }
+	 * }
+	 *
+	 * return -ENOENT;
+	 */
+	XXX;
+}
+
+static int dir_readdir(struct c2_conf_obj **result, struct c2_conf_dircur *cur)
+{
+	/*
+	 * Decrement cur->dc_pin->co_nrefs; cur->dc_pin = NULL.
+	 * Call c2_tlist_next().
+	 * If retval of c2_tlist_next() is NULL, return 0 (end of directory).
+	 * Otherwise, cur->dc_pin = retval; increment cur->dc_pin->co_nrefs.
+	 * *result = cur->dc_pin.
+	 * Return 1.
+	 */
+	XXX;
+}
+
+static int profile_lookup(struct c2_conf_obj *parent, const char *name,
+			  struct c2_conf_obj **out)
+{
+	struct c2_conf_obj     *child;
+	struct c2_conf_profile *prof = C2_CONF_CAST(parent, c2_conf_profile);
+
+	C2_PRE(parent->co_status == C2_CS_READY);
+
+	if (!streq(name, "filesystem"))
+		return -ENOENT;
+
+	child = &prof->cp_filesystem->cf_obj;
+	C2_ASSERT(child->co_parent == parent);
+	*out = child;
+	return 0;
+}
+
+/* XXX
+ *
+ * The remaining *_lookup()s are mostly similar to
+ * profile_lookup(). The differences are:
+ * - a list of expected names (e.g., node_lookup() will expect
+ *   ["nics", "sdevs"]);
+ * - offset of child pointer in the ambient (concrete) parent.
+ *
+ * Thus much of contents of *_lookup()s will go into a helper
+ * function, taking a NULL terminated array of "known children" as a
+ * parameter.
+ */
+
+/* XXX
+ *
+ * There are no {profile..partition}_readdir().  ->coo_readdir of any
+ * object except of c2_conf_dir is NULL.
+ */
 
 /** @} conf_dlspec_objops */
-- 
1.8.3.2

