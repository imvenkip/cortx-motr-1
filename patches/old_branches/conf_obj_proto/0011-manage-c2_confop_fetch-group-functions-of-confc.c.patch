From 18893de9d468a4e8730b80d6590e44d9b1c0d30a Mon Sep 17 00:00:00 2001
From: "Valery V. Vorotyntsev" <valery_vorotyntsev@xyratex.com>
Date: Wed, 22 Feb 2012 15:23:38 +0200
Subject: [PATCH 011/370] manage c2_confop_fetch; group functions of confc.c

The commit is huge, sorry.  I'll try to produce more digestible
commits in the future.

+ move the definition of c2_conf_buf to confop.ff
+ get rid of confop_raw.ff
+ request_fill(), request_is_valid(), request_encode(): new functions
  that manage c2_confop_fetch
+ confc.c: group the functions by topic
---
 conf/confc.c       | 447 +++++++++++++++++++++++++++++++++--------------------
 conf/confc.h       |  28 ++--
 conf/confop.ff     |  55 ++++---
 conf/confop_raw.ff |  28 ----
 conf/obj.h         |  14 +-
 conf/ut/confc.c    |   2 +-
 6 files changed, 334 insertions(+), 240 deletions(-)
 delete mode 100644 conf/confop_raw.ff

diff --git a/conf/confc.c b/conf/confc.c
index 9dae245..9c5f36e 100644
--- a/conf/confc.c
+++ b/conf/confc.c
@@ -24,69 +24,29 @@
 #include "conf/confc.h"
 
 #define __C2_CONF_IMPL
-#include "conf/cache.h" /* c2_conf_cache */
+#include "conf/cache.h"  /* c2_conf_cache */
 
-#include "lib/cdefs.h"  /* container_of */
-#include "lib/arith.h"  /* C2_CNT_INC, C2_CNT_DEC */
-#include "lib/time.h"   /* C2_TIME_NEVER */
+#include "xcode/xcode.h"
+#include "lib/cdefs.h"   /* C2_EXPORTED, container_of, C2_HAS_TYPE */
+#include "lib/arith.h"   /* C2_CNT_INC, C2_CNT_DEC */
+#include "lib/time.h"    /* C2_TIME_NEVER */
+#include "lib/misc.h"    /* memcpy */
 
-static struct c2_conf_cache confc_cache; /*< Confc's configuration cache. */
+static struct c2_conf_cache confc_cache;
 
-enum confc_state { S_INITIAL, S_CHECK, S_WAIT_REPLY, S_WAIT_STATUS,
-		   S_GROW_CACHE, S_FAILURE, S_TERMINAL, S_NR };
-
-static void _state_set(struct c2_sm_group *grp __attribute__((unused)),
-		       struct c2_sm_ast *ast)
-{
-	struct c2_confc_fetchctx *ctx =
-		container_of(ast, struct c2_conf_fetchctx, fc_ast);
-	c2_sm_state_set(&ctx->fc_mach, (enum confc_state)ast->sa_datum);
-}
-
-static void _fail(struct c2_sm_group *grp __attribute__((unused)),
-		  struct c2_sm_ast *ast)
-{
-	struct c2_confc_fetchctx *ctx =
-		container_of(ast, struct c2_conf_fetchctx, fc_ast);
-	c2_sm_fail(&ctx->fc_mach, S_FAILURE, (int32_t)ast->sa_datum);
-}
-
-/** Posts an AST that will advance the state machine to given state. */
-static void ast_state_set(struct c2_sm_ast *ast, enum confc_state state)
-{
-	ast->sa_cb    = _state_set;
-	ast->sa_datum = state;
-	c2_sm_ast_post(confc_cache.cc_sm_group, ast);
-}
-
-/** Posts an AST that will move the state machine to S_FAILURE state. */
-static void ast_fail(struct c2_sm_ast *ast, int32_t rc)
-{
-	ast->sa_cb    = _fail;
-	ast->sa_datum = rc;
-	c2_sm_ast_post(confc_cache.cc_sm_group, ast);
-}
-
-/** Actions to perform on "object unpinned" event. */
-static bool on_unpinned(struct c2_clink *link)
-{
-	struct c2_confc_fetchctx *ctx =
-		container_of(link, struct c2_confc_fetchctx, fc_clink);
-
-	c2_clink_del(link);
-	ast_state_set(&ctx->fc_ast, S_CHECK);
-	return true;
-}
+static bool ctx_invariant(struct c2_confc_fetchctx *ctx);
 
 void c2_confc_fetchctx_init(struct c2_confc_fetchctx *ctx)
 {
 	c2_chan_init(&ctx->fc_complete);
 	c2_clink_init(&ctx->fc_clink, on_unpinned);
+	C2_POST(ctx_invariant(ctx));
 }
 C2_EXPORTED(c2_confc_fetchctx_init);
 
 void c2_confc_fetchctx_fini(struct c2_confc_fetchctx *ctx)
 {
+	C2_PRE(ctx_invariant(ctx));
 	c2_clink_fini(&ctx->fc_clink);
 	c2_chan_fini(&ctx->fc_complete);
 }
@@ -104,6 +64,23 @@ list_status(const struct c2_tl_descr *descr, const struct c2_tl *list)
 	 */
 }
 
+static inline struct c2_mutex * group_lock(void) {
+	return &confc_cache.cc_sm_group->s_lock;
+}
+static inline struct c2_mutex * cache_lock(void) {
+	return &confc_cache.cc_lock;
+}
+
+static inline struct c2_confc_fetchctx * to_ctx(struct c2_sm *mach)
+{
+	C2_PRE(mach != NULL);
+	return container_of(mach, struct c2_confc_fetchctx, fc_mach);
+}
+
+static void
+request_fill(struct c2_confop_fetch *req, const struct c2_conf_obj *path_org,
+	     struct c2_conf_pathcomp *path, size_t path_len);
+
 /**
  * @pre   cache's sm_group is locked
  * @pre   c2_conf_path_invariant(&ctx->fc_path)
@@ -121,10 +98,10 @@ path_status(struct c2_confc_fetchctx *ctx, enum c2_conf_status *status)
 	bool target_is_directory = false;
 	int ret = 0;
 
-	C2_PRE(c2_mutex_is_locked(&confc_cache.cc_sm_group->s_lock));
+	C2_PRE(c2_mutex_is_locked(group_lock()));
 	C2_PRE(c2_conf_path_invariant(&ctx->fc_path));
 
-	c2_mutex_lock(&confc_cache.cc_lock);
+	c2_mutex_lock(cache_lock());
 	*status = obj->co_status;
 
 	for (; *status == C2_CS_READY && len > 0; --len, ++comp) {
@@ -178,16 +155,7 @@ path_status(struct c2_confc_fetchctx *ctx, enum c2_conf_status *status)
 			C2_ASSERT(obj->co_status == C2_CS_MISSING);
 			obj->co_status = C2_CS_LOADING;
 		}
-
-		XXX {
-			/*
-			 * Encode the following into ctx->fc_fop:
-			 *   .ff_origin.o_objtype = obj->co_objtype;
-			 *   .ff_origin.o_objkey <- obj->co_objkey;
-			 *   .ff_comps.c_nr       = len;
-			 *   .ff_comps.c_data    <- comp.
-			 */
-		}
+		request_fill(&ctx->fc_req, obj, comp, len);
 	} else if (*status == C2_CS_LOADING) {
 		if (target_is_directory) {
 			XXX; /* scan directory, adding clinks */
@@ -198,15 +166,204 @@ path_status(struct c2_confc_fetchctx *ctx, enum c2_conf_status *status)
 		C2_IMPOSSIBLE("invalid object status");
 	}
 end:
-	c2_mutex_unlock(&confc_cache.cc_lock);
-	C2_POST(c2_mutex_is_locked(&confc_cache.cc_sm_group->s_lock));
+	c2_mutex_unlock(cache_lock());
+	C2_POST(c2_mutex_is_locked(group_lock()));
 	return ret;
 }
 
-static inline struct c2_confc_fetchctx * fetchctx(struct c2_sm *mach)
+int c2_confc_open(struct c2_confc_fetchctx *ctx,
+		  struct c2_conf_obj *path_origin,
+		  const struct c2_conf_pathcomp *path,
+		  size_t path_len)
 {
-	C2_PRE(mach != NULL);
-	return container_of(mach, struct c2_confc_fetchctx, fc_mach);
+	C2_PRE(ctx->fc_path.p_comps == NULL);
+
+	ctx->fc_path.p_origin = path_origin;
+	ctx->fc_path.p_len    = path_len;
+	ctx->fc_path.p_comps  = c2_conf_pathcomp_dup(path, path_len);
+	if (ctx->fc_path.p_comps == NULL)
+		return -ENOMEM;
+	C2_ASSERT(c2_conf_path_invariant(&ctx->fc_path));
+
+	if (c2_conf_path_is_dir(&ctx->fc_path))
+		return -EISDIR;
+
+	ast_state_set(&ctx->fc_ast, S_CHECK);
+	return 0;
+}
+C2_EXPORTED(c2_confc_open);
+
+void * c2_confc_open_sync(const struct c2_conf_path *path)
+{
+	struct c2_confc_fetchctx ctx;
+	int rc;
+	void *ret = NULL;
+
+	c2_confc_fetchctx_init(&ctx);
+	rc = c2_confc_open(path, &ctx);
+	if (rc == 0) {
+		rc = c2_sm_timedwait(&ctx.fc_mach, S_TERMINAL | S_FAILURE,
+				     C2_TIME_NEVER);
+		C2_ASSERT(rc == 0);
+		ret = ctx.fc_result;
+	}
+	c2_confc_fetchctx_fini(&ctx);
+	return ret;
+}
+C2_EXPORTED(c2_confc_open_sync);
+
+void c2_confc_close(void *obj)
+{
+	struct c2_conf_obj *x = obj;
+
+	c2_mutex_lock(cache_lock());
+	C2_CNT_DEC(x->co_nrefs);
+	if (x->co_nrefs == 0)
+		c2_chan_broadcast(&x->co_chan);
+	c2_mutex_unlock(cache_lock());
+}
+C2_EXPORTED(c2_confc_close);
+
+/** Collection of configuration objects. */
+struct c2_confc_dir {
+	/** Parent object this collection belongs to. */
+	struct c2_conf_obj       *d_parent;
+
+	/**
+	 * Currently opened (and pinned) element of this collection.
+	 *
+	 * The value is updated by c2_confc_dirnext().
+	 */
+	struct c2_conf_obj       *d_current;
+
+	/** List descriptor. */
+	const struct c2_tl_descr *d_descr;
+};
+
+/* ------------------------------------------------------------------
+ * Request-related functions.
+ * ------------------------------------------------------------------ */
+
+static bool request_is_valid(const struct c2_confop_fetch *req)
+{
+	return  req->ff_origin.o_objtype < C2_CO_NR &&
+		ret->ff_origin.o_objkey.cb_size > 0 &&
+		ret->ff_origin.o_objkey.cb_data != NULL &&
+		equi(ret->ff_comps.c_nr == 0, ret->ff_comps.c_data != NULL);
+}
+
+/** Asserts validity of the configuration request and returns its address. */
+static struct c2_confop_fetch * to_request(struct c2_rpc_item *item)
+{
+	struct c2_fop          *fop = c2_rpc_item_to_fop(item);
+	struct c2_confop_fetch *req = c2_fop_data(fop);
+
+	C2_PRE(item->ri_type == &request_item_type);
+
+	/* XXX c2_confop_fetch_bob_check() needs C2_BOB_DEFINE() and
+	 * magic field in c2_confop_fetch, but it's worth it. */
+	C2_ASSERT(req != NULL && c2_confop_fetch_bob_check(req));
+
+	C2_ASSERT(request_is_valid(req));
+	return req;
+}
+
+/**
+ * Encodes configuration request into a network buffer provided by the
+ * rpc layer.
+ *
+ * This function is assigned to ->rito_encode() callback of the
+ * "request" rpc item.
+ */
+static int
+request_encode(struct c2_rpc_item_type *item_type __attribute__((unused)),
+	       struct c2_rpc_item *item, struct c2_bufvec_cursor *cur)
+{
+	struct c2_xcode_ctx       xtx;
+	const struct c2_xcode_obj xobj = {
+		.xo_type = c2_confop_fetch_xc,
+		.xo_ptr  = to_request(item) /* verifies request */
+	};
+
+	c2_xcode_ctx_init(&xtx, &xobj);
+	C2_ASSERT(C2_HAS_TYPE(&xtx.xcx_buf, cur));
+	memcpy(&xtx.xcx_buf, cur, sizeof cur);
+	return c2_xcode_encode(&xtx);
+}
+
+static const struct c2_rpc_item_type_ops request_item_type_ops = {
+	.rito_encode    = request_encode,
+
+	/* c2_rpc_encode() asserts that this member is not NULL */
+	.rito_item_size = XXX /* XXX[question] Should it be
+			       * c2_fop_item_type_default_onwire_size()
+			       * or a function returning
+			       * c2_xcode_length() of
+			       * c2_confop_fetch? */
+};
+
+/** Used for configuration requests. */
+static struct c2_rpc_item_type request_item_type = {
+	.rit_opcode = XXX,
+	.rit_ops    = &request_item_type_ops,
+	.rit_flags  = C2_RPC_ITEM_TYPE_REQUEST,
+	.rit_magic  = XXX
+};
+
+/** Fills c2_confop_fetch structure. */
+static void
+request_fill(struct c2_confop_fetch *req, const struct c2_conf_obj *path_org,
+	     struct c2_conf_pathcomp *path, size_t path_len)
+{
+	C2_PRE(c2_mutex_is_locked(group_lock()));
+	C2_PRE(c2_mutex_is_locked(cache_lock()));
+
+	req->ff_origin.o_objtype = path_org->co_type;
+	memcpy(&req->ff_origin.o_objkey, &path_org->co_key,
+	       sizeof req->ff_origin.o_objkey);
+	req->ff_comps.c_nr = path_len;
+	req->ff_comps.c_data = path;
+
+	C2_POST(request_is_valid(req));
+}
+
+/* ------------------------------------------------------------------
+ * State transitions.
+ * ------------------------------------------------------------------ */
+
+enum confc_state { S_INITIAL, S_CHECK, S_WAIT_REPLY, S_WAIT_STATUS,
+		   S_GROW_CACHE, S_FAILURE, S_TERMINAL, S_NR };
+
+static void _state_set(struct c2_sm_group *grp __attribute__((unused)),
+		       struct c2_sm_ast *ast)
+{
+	struct c2_confc_fetchctx *ctx =
+		container_of(ast, struct c2_conf_fetchctx, fc_ast);
+	c2_sm_state_set(&ctx->fc_mach, (enum confc_state)ast->sa_datum);
+}
+
+static void _fail(struct c2_sm_group *grp __attribute__((unused)),
+		  struct c2_sm_ast *ast)
+{
+	struct c2_confc_fetchctx *ctx =
+		container_of(ast, struct c2_conf_fetchctx, fc_ast);
+	c2_sm_fail(&ctx->fc_mach, S_FAILURE, (int32_t)ast->sa_datum);
+}
+
+/** Posts an AST that will advance the state machine to given state. */
+static void ast_state_set(struct c2_sm_ast *ast, enum confc_state state)
+{
+	ast->sa_cb    = _state_set;
+	ast->sa_datum = state;
+	c2_sm_ast_post(confc_cache.cc_sm_group, ast);
+}
+
+/** Posts an AST that will move the state machine to S_FAILURE state. */
+static void ast_fail(struct c2_sm_ast *ast, int32_t rc)
+{
+	ast->sa_cb    = _fail;
+	ast->sa_datum = rc;
+	c2_sm_ast_post(confc_cache.cc_sm_group, ast);
 }
 
 /** Actions to perform on entering CHECK state. */
@@ -215,9 +372,9 @@ static void check_st_in(struct c2_sm *mach)
 	enum c2_conf_status status;
 	int rc;
 
-	C2_PRE(c2_mutex_is_locked(&confc_cache.cc_sm_group->s_lock));
+	C2_PRE(c2_mutex_is_locked(group_lock()));
 
-	rc = path_status(fetchctx(mach), &status);
+	rc = path_status(to_ctx(mach), &status);
 	if (rc != 0)
 		c2_sm_fail(mach, S_FAILURE, rc);
 	else if (status == C2_CS_MISSING)
@@ -229,52 +386,31 @@ static void check_st_in(struct c2_sm *mach)
 	else
 		C2_IMPOSSIBLE("status is not valid");
 
-	C2_POST(c2_mutex_is_locked(&confc_cache.cc_sm_group->s_lock));
-}
-
-/** Actions to perform on RPC response arrival or an RPC error. */
-static void on_replied(struct c2_rpc_item *item)
-{
-	struct c2_fop *fop = container_of(item, struct c2_fop, f_item);
-	struct c2_confc_fetchctx *ctx =
-		container_of(fop, struct c2_confc_fetchctx, fc_fop);
-
-	if (item->ri_error == 0)
-		ast_state_set(&ctx->fc_ast, S_GROW_CACHE);
-	else
-		ast_fail(&ctx->fc_ast, item->ri_error);
+	C2_POST(c2_mutex_is_locked(group_lock()));
 }
 
 /** Actions to perform on entering WAIT_REPLY state. */
 static void wait_reply_st_in(struct c2_sm *mach)
 {
 	int rc;
-	struct c2_confc_fetchctx *ctx = fetchctx(mach);
-	const struct c2_confop_fetch *fop_data = c2_fop_data(&ctx->fc_fop);
-	/* XXX fop data must be set beforehand (see test_fop_encdec()
-	 * in xcode/ut/xcode_fop_test.c). */
-
-	C2_PRE(fop_data != NULL && fop_data->ff_origin.o_objkey.fb_size > 0
-	       && fop_data->ff_origin.o_objkey.fb_data != NULL);
+	struct c2_confc_fetchctx *ctx = to_ctx(mach);
 
-	/* XXX c2_rpc_item need to be initialized properly. */
-	C2_ASSERT(ctx->fc_fop.f_item.ri_ops != NULL &&
-		  ctx->fc_fop.f_item.ri_ops->rio_replied == on_replied);
+	C2_PRE(ctx_invariant(ctx));
 	rc = c2_rpc_post(&ctx->fc_fop.f_item);
 	C2_ASSERT(rc == 0); /* c2_rpc_post() always returns 0, but hey */
 }
 
-static void *
-xcx_alloc(struct c2_xcode_ctx *ctx __attribute__((unused)), size_t n)
-{
-	return c2_alloc(n);
-}
+/* static void * */
+/* xcx_alloc(struct c2_xcode_ctx *ctx __attribute__((unused)), size_t n) */
+/* { */
+/* 	return c2_alloc(n); */
+/* } */
 
 /** Actions to perform on entering GROW_CACHE state. */
 static void grow_cache_st_in(struct c2_sm *mach)
 {
 	struct c2_fop      *fop;
-	struct c2_rpc_item *item = &fetchctx(mach)->fc_fop.f_item;
+	struct c2_rpc_item *item = &to_ctx(mach)->fc_fop.f_item;
 
 	C2_PRE(item->ri_error == 0 && item->ri_reply != NULL);
 	fop = c2_rpc_item_to_fop(item->ri_reply);
@@ -287,7 +423,7 @@ static void grow_cache_st_in(struct c2_sm *mach)
 			.xo_ptr  = NULL
 		};
 		/* XXX This buffer must contain serialized configuration. */
-		char             ebuf[100];
+		char             ebuf[100]; /*XXX*/
 		c2_bcount_t      count = ARRAY_SIZE(ebuf);
 		void            *vec   = ebuf;
 		struct c2_bufvec bvec  = C2_BUFVEC_INIT_BUF(&vec, &count);
@@ -307,9 +443,9 @@ static void grow_cache_st_in(struct c2_sm *mach)
 	}
 }
 
-static void complete(struct c2_sm *mach)
+static void completion_announce(struct c2_sm *mach)
 {
-	c2_chan_broadcast(&fetchctx(mach)->fc_complete);
+	c2_chan_broadcast(&to_ctx(mach)->fc_complete);
 }
 
 static bool failure_st_invariant(const struct c2_sm *mach)
@@ -326,6 +462,32 @@ static bool terminal_st_invariant(const struct c2_sm *mach)
 	return mach->sm_rc == 0 && ctx->fc_result != NULL;
 }
 
+/** Handles RPC "replied" event: response arrival or an error. */
+static void on_replied(struct c2_rpc_item *item)
+{
+	struct c2_confc_fetchctx *ctx;
+
+	C2_PRE(item->ri_type == &request_item_type);
+	ctx = container_of(c2_rpc_item_to_fop(item), struct c2_confc_fetchctx,
+			   fc_fop);
+
+	if (item->ri_error == 0)
+		ast_state_set(&ctx->fc_ast, S_GROW_CACHE);
+	else
+		ast_fail(&ctx->fc_ast, item->ri_error);
+}
+
+/** Handles "object unpinned" event. */
+static bool on_unpinned(struct c2_clink *link)
+{
+	struct c2_confc_fetchctx *ctx =
+		container_of(link, struct c2_confc_fetchctx, fc_clink);
+
+	c2_clink_del(link);
+	ast_state_set(&ctx->fc_ast, S_CHECK);
+	return true;
+}
+
 static const struct c2_sm_state_descr confc_states[S_NR] = {
 	[S_INITIAL] = {
 		.sd_flags     = C2_SDF_INITIAL,
@@ -371,7 +533,7 @@ static const struct c2_sm_state_descr confc_states[S_NR] = {
 	[S_FAILURE] = {
 		.sd_flags     = C2_SDF_FAILURE,
 		.sd_name      = "FAILURE",
-		.sd_in        = complete,
+		.sd_in        = completion_announce,
 		.sd_ex        = NULL,
 		.sd_invariant = failure_st_invariant,
 		.sd_allowed   = 0
@@ -379,7 +541,7 @@ static const struct c2_sm_state_descr confc_states[S_NR] = {
 	[S_TERMINAL] = {
 		.sd_flags     = C2_SDF_TERMINAL,
 		.sd_name      = "TERMINAL",
-		.sd_in        = complete,
+		.sd_in        = completion_announce,
 		.sd_ex        = NULL,
 		.sd_invariant = terminal_st_invariant,
 		.sd_allowed   = 0
@@ -391,72 +553,17 @@ static struct c2_sm_conf confc_states_conf = {
 	.scf_nr_states = S_NR,
 	.scf_state     = confc_states
 };
+
+/* ------------------------------------------------------------------
+ * misc
+ * ------------------------------------------------------------------ */
 
-int c2_confc_open(struct c2_confc_fetchctx *ctx,
-		  struct c2_conf_obj *path_origin,
-		  const struct c2_conf_pathcomp *path,
-		  size_t path_len)
+static bool ctx_invariant(struct c2_confc_fetchctx *ctx)
 {
-	C2_PRE(ctx->fc_path.p_comps == NULL);
-
-	ctx->fc_path.p_origin = path_origin;
-	ctx->fc_path.p_len    = path_len;
-	ctx->fc_path.p_comps  = c2_conf_pathcomp_dup(path, path_len);
-	if (ctx->fc_path.p_comps == NULL)
-		return -ENOMEM;
-	C2_ASSERT(c2_conf_path_invariant(&ctx->fc_path));
-
-	if (c2_conf_path_is_dir(&ctx->fc_path))
-		return -EISDIR;
-
-	ast_state_set(&ctx->fc_ast, S_CHECK);
-	return 0;
+	const struct c2_rpc_item *item = &ctx->fc_fop.f_item;
+	return XXX /* more checks */ &&
+		item->ri_type == &request_item_type &&
+		item->ri_ops != NULL &&
+		item->ri_ops->rio_replied == on_replied &&
+		c2_fop_data(ctx->fc_fop) == &ctx->fc_req;
 }
-C2_EXPORTED(c2_confc_open);
-
-void * c2_confc_open_sync(const struct c2_conf_path *path)
-{
-	struct c2_confc_fetchctx ctx;
-	int rc;
-	void *ret = NULL;
-
-	c2_confc_fetchctx_init(&ctx);
-	rc = c2_confc_open(path, &ctx);
-	if (rc == 0) {
-		rc = c2_sm_timedwait(&ctx.fc_mach, S_TERMINAL | S_FAILURE,
-				     C2_TIME_NEVER);
-		C2_ASSERT(rc == 0);
-		ret = ctx.fc_result;
-	}
-	c2_confc_fetchctx_fini(&ctx);
-	return ret;
-}
-C2_EXPORTED(c2_confc_open_sync);
-
-void c2_confc_close(void *obj)
-{
-	struct c2_conf_obj *x = obj;
-
-	c2_mutex_lock(&confc_cache.cc_lock);
-	C2_CNT_DEC(x->co_nrefs);
-	if (x->co_nrefs == 0)
-		c2_chan_broadcast(&x->co_chan);
-	c2_mutex_unlock(&confc_cache.cc_lock);
-}
-C2_EXPORTED(c2_confc_close);
-
-/** Collection of configuration objects. */
-struct c2_confc_dir {
-	/** Parent object this collection belongs to. */
-	struct c2_conf_obj       *d_parent;
-
-	/**
-	 * Currently opened (and pinned) element of this collection.
-	 *
-	 * The value is updated by c2_confc_dirnext().
-	 */
-	struct c2_conf_obj       *d_current;
-
-	/** List descriptor. */
-	const struct c2_tl_descr *d_descr;
-};
diff --git a/conf/confc.h b/conf/confc.h
index be3f364..9530ded 100644
--- a/conf/confc.h
+++ b/conf/confc.h
@@ -21,8 +21,9 @@
 #define __COLIBRI_CONF_CONFC_H__
 
 #include "conf/path.h"
-#include "sm/sm.h"    /* c2_sm, c2_sm_ast */
-#include "lib/chan.h" /* c2_clink */
+#include "conf/confop.h" /* c2_confop_fetch */
+#include "sm/sm.h"       /* c2_sm, c2_sm_ast */
+#include "lib/chan.h"    /* c2_clink */
 
 /**
  * @page conf-confc  confc: configuration client
@@ -163,7 +164,7 @@ void c2_confc_fini(void);
 /** Configuration retrieval context. */
 struct c2_confc_fetchctx {
 	/** This channel is signaled when the retrieval operation completes. */
-	struct c2_chan      fc_complete;
+	struct c2_chan         fc_complete;
 
 	/**
 	 * Pointer to the requested configuration object or directory.
@@ -179,7 +180,7 @@ struct c2_confc_fetchctx {
 	 * It is also NULL if configuration retrieval failed (see
 	 * c2_confc_error()).
 	 */
-	void               *fc_result;
+	void                  *fc_result;
 
 	/* -------------------------------------------------------------
 	 * The remaining fields are used by confc implementation and
@@ -187,24 +188,25 @@ struct c2_confc_fetchctx {
 	 */
 
 	/** A confc state machine. */
-	struct c2_sm        fc_mach;
+	struct c2_sm           fc_mach;
 
-	struct c2_sm_ast    fc_ast;
+	struct c2_sm_ast       fc_ast;
 
-	/**
-	 * Path to the requested object or directory (directory is a
-	 * collection of objects).
-	 */
-	struct c2_conf_path fc_path;
+	/** Path to the requested object/directory. */
+	struct c2_conf_path    fc_path;
 
 	/**
 	 * Record of interest in "object unpinned" events.
 	 *
 	 * This clink gets added to c2_conf_obj::co_chan channel.
 	 */
-	struct c2_clink     fc_clink;
+	struct c2_clink        fc_clink;
+
+	/** Configuration request. */
+	struct c2_confop_fetch fc_req;
 
-	struct c2_fop       fc_fop;
+	/** Request fop. */
+	struct c2_fop          fc_fop;
 };
 
 void c2_confc_fetchctx_init(struct c2_confc_fetchctx *ctx);
diff --git a/conf/confop.ff b/conf/confop.ff
index 8b5a382..a0ffed6 100644
--- a/conf/confop.ff
+++ b/conf/confop.ff
@@ -18,28 +18,37 @@
  * Original creation date: 30-Jan-2012
  */
 
-/* XXX @todo Move definitions from cfg/cfg.h to conf/schema.h */
+/* XXX TODO Move definitions from cfg/cfg.h to conf/db.ff */
 require "cfg/cfg"; /* C2_CFG_NAME_LEN, C2_CFG_PARAM_LEN,
 		    * C2_CFG_SERVICE_MAX_END_POINTS */
-require "conf/confop_raw_u"; /* c2_confop_buf */
 
-/* Array of C2_CFG_NAME_LEN bytes. cfg/cfg.h puts names in such arrays. */
+/*
+ * Sequence of bytes.
+ *
+ * See also C2_CONF_BUF_INIT() and c2_conf_buf_eq().
+ */
+sequence {
+	u32 cb_size;
+	u8  cb_data
+} c2_conf_buf;
+
+/* Array of C2_CFG_NAME_LEN bytes. (cfg/cfg.h puts names in such arrays.) */
 sequence {
 	void fs_none :C2_CFG_NAME_LEN;
 	u8   fs_data
 } c2_confop_fixstr;
 
 union {
-	u8            pc_iskey;
-	u32           pc_relation :0;
-	c2_confop_buf pc_key      :1
+	u8          pc_iskey;
+	u32         pc_relation :0;
+	c2_conf_buf pc_key      :1
 } c2_confop_pathcomp;
 
 /* Configuration request. */
 record {
 	record {
-		u32           o_objtype; /* see c2_conf_objtype for values */
-		c2_confop_buf o_objkey
+		u32         o_objtype; /* see c2_conf_objtype for values */
+		c2_conf_buf o_objkey
 	} ff_origin; /* Configuration object the path originates from. */
 	sequence {
 		u32                c_nr;
@@ -67,10 +76,10 @@ record {
 /* Configuration of a service. */
 record {
 	/* Parent filesystem. */
-	c2_confop_buf fs_filesystem;
+	c2_conf_buf fs_filesystem;
 
 	/* Service type. See c2_cfg_service_type for values. */
-	u32           fs_type;
+	u32         fs_type;
 
 	/* End-points from which this service is reachable. */
 	sequence {
@@ -79,13 +88,13 @@ record {
 	} fs_endpoints;
 
 	/* Hosting node. */
-	c2_confop_buf fs_node
+	c2_conf_buf fs_node
 } c2_confop_service;
 
 record {
 	sequence {
-		u32           s_nr;
-		c2_confop_buf s_data
+		u32         s_nr;
+		c2_conf_buf s_data
 	} fn_services;
 	u32 fn_memsize;
 	u32 fn_nr_processors;
@@ -93,17 +102,17 @@ record {
 	u64 fn_flags;
 	u64 fn_pool_id;
 	sequence {
-		u32           n_nr;
-		c2_confop_buf n_data
+		u32         n_nr;
+		c2_conf_buf n_data
 	} fn_nics;
 	sequence {
-		u32           d_nr;
-		c2_confop_buf d_data
+		u32         d_nr;
+		c2_conf_buf d_data
 	} fn_sdevs
 } c2_confop_node;
 
 record {
-	c2_confop_buf    fn_node;
+	c2_conf_buf      fn_node;
 	u32              fn_iface_type;
 	u32              fn_mtu;
 	u64              fn_speed;
@@ -112,7 +121,7 @@ record {
 } c2_confop_nic;
 
 record {
-	c2_confop_buf    fd_node;
+	c2_conf_buf      fd_node;
 	u32              fd_type;
 	u32              fd_media;
 	u64              fd_size;
@@ -120,13 +129,13 @@ record {
 	u64              fd_flags;
 	c2_confop_fixstr fd_filename;
 	sequence {
-		u32           p_nr;
-		c2_confop_buf p_data
+		u32         p_nr;
+		c2_conf_buf p_data
 	} fd_partitions
 } c2_confop_sdev;
 
 record {
-	c2_confop_buf    fp_sdev;
+	c2_conf_buf      fp_sdev;
 	u64              fp_start;
 	u64              fp_size;
 	u32              fp_index;
@@ -136,7 +145,7 @@ record {
 
 /* Encoding of a configuration object. */
 record {
-	c2_confop_buf fo_key;
+	c2_conf_buf fo_key;
 	union {
 		u8                   v_type;
 		c2_confop_profile    v_profile;
diff --git a/conf/confop_raw.ff b/conf/confop_raw.ff
deleted file mode 100644
index 747bceb..0000000
--- a/conf/confop_raw.ff
+++ /dev/null
@@ -1,28 +0,0 @@
-/* -*- c -*- */
-/*
- * COPYRIGHT 2012 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Valery V. Vorotyntsev <valery_vorotyntsev@xyratex.com>
- * Original creation date: 15-Feb-2012
- */
-
-/*
- * Sequence of bytes.
- *
- * XXX Can this structure be used instead of `c2_conf_buf'?
- */
-DEF(c2_confop_buf, SEQUENCE,
-    _(fb_size, U32),
-    _(fb_data, BYTE));
diff --git a/conf/obj.h b/conf/obj.h
index 4ae1318..0ffc89a 100644
--- a/conf/obj.h
+++ b/conf/obj.h
@@ -20,6 +20,8 @@
 #ifndef __COLIBRI_CONF_OBJ_H__
 #define __COLIBRI_CONF_OBJ_H__
 
+#include "conf/confop.h" /* c2_conf_buf */
+
 /* XXX @todo Move definitions from cfg/cfg.h to conf/schema.h */
 #include "cfg/cfg.h"
 
@@ -54,11 +56,13 @@ enum c2_conf_status {
 	C2_CS_READY    /*< Configuration is available. */
 };
 
-/** Sequence of bytes. */
-struct c2_conf_buf {
-	size_t   cb_size;
-	uint8_t *cb_data;
-};
+/**
+ * C2_CONF_BUF_INIT: initializer for struct c2_conf_buf.
+ *
+ * The structure itself is defined in confop.ff.  Yes, this is ugly, but
+ * - the structure has to be xcoded, so it has to be defined in .ff file;
+ * - a macro cannot be defined in .ff file --- xcode/ff2c will reject it.
+ */
 #define C2_CONF_BUF_INIT(size, data) { .cb_size = (size), .cb_data = (data) }
 
 /** Returns true iff two buffers are equal. */
diff --git a/conf/ut/confc.c b/conf/ut/confc.c
index bac8ebf..5519ec2 100644
--- a/conf/ut/confc.c
+++ b/conf/ut/confc.c
@@ -112,7 +112,7 @@ static void test_fetchctx(void)
 	 * container_of()->fc_mach */
 	C2_UT_ASSERT(ctx.fc_ast.sa_mach == NULL);
 
-	C2_UT_ASSERT(ctx->fc_fop.f_data.fd_data == NULL);
+	C2_UT_ASSERT(c2_fop_data(&ctx->fc_fop) == &ctx->fc_req);
 }
 
 static void test_path_status(void)
-- 
1.8.3.2

