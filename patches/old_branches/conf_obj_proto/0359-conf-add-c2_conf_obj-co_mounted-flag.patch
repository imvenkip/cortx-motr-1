From 0846f56f1b22d64466ceabac1d8e2c94cc179d13 Mon Sep 17 00:00:00 2001
From: "Valery V. Vorotyntsev" <valery_vorotyntsev@xyratex.com>
Date: Wed, 5 Sep 2012 20:40:50 +0300
Subject: [PATCH 359/370] conf: add c2_conf_obj::co_mounted flag

- Change concrete invariants to analyse c2_conf_obj::co_mounted and work
  in any context.

- Revise concrete invariants. Exclude parent_check() function.

- conf/ut/reg.c (test_reg): Enable all samples.

- Rename c2_conf_obj_new() to c2_conf_obj_create(). `new' is not a verb.
---
 conf/confc.c           | 10 +++----
 conf/obj.h             | 22 +++++++++++++++
 conf/obj_ops.c         | 41 ++++++++++++---------------
 conf/obj_ops.h         | 18 +++++++-----
 conf/objs/common.c     | 75 ++++++++++++++++++++++++++++++++++----------------
 conf/objs/common.h     | 31 ++++++++-------------
 conf/objs/dir.c        | 69 ++++++++++++++++++++++++++++++++++++++++------
 conf/objs/filesystem.c | 19 +++++++------
 conf/objs/nic.c        | 14 ++++------
 conf/objs/node.c       | 17 ++++++++----
 conf/objs/partition.c  | 14 ++++------
 conf/objs/profile.c    | 20 ++++++++------
 conf/objs/sdev.c       | 18 ++++++------
 conf/objs/service.c    | 27 ++++++++----------
 conf/onwire.h          |  1 -
 conf/ut/obj.c          |  9 ------
 conf/ut/reg.c          |  2 --
 17 files changed, 244 insertions(+), 163 deletions(-)

diff --git a/conf/confc.c b/conf/confc.c
index 6a8e257..99c52c5 100644
--- a/conf/confc.c
+++ b/conf/confc.c
@@ -213,12 +213,12 @@
  *      cache with cache_add().
  *
  * cache_add() performs the following operations:
- *   -# c2_conf_obj_new() --- allocates configuration object and
+ *   -# c2_conf_obj_create() --- allocates configuration object and
  *      initialises its fields;
  *   -# c2_conf_obj_fill() --- fills new object with configuration data
  *      contained in on-wire object descriptor (confx_object);
- *   -# c2_conf_reg_add() --- adds new entry to the cached objects
- *      registry.
+ *   -# c2_conf_reg_add() --- adds configuration object to the
+ *      registry of cached objects.
  *
  * object_enrich() compares cached object with the descriptor received
  * from the confd.  If a discrepancy is found (!c2_conf_obj_match()),
@@ -289,7 +289,7 @@ int c2_confc_init(struct c2_confc *confc, const char *conf_source,
 	 * C2_PRE(conf_source != NULL && *conf_source != 0);
 	 * C2_PRE(XXX_sanity_check(profile));
 	 *
-	 * root = c2_conf_obj_new(C2_CO_PROFILE, profile);
+	 * root = c2_conf_obj_create(C2_CO_PROFILE, profile);
 	 * if (root == NULL)
 	 *     return -ENOMEM;
 	 * root->co_confc = confc;
@@ -963,7 +963,7 @@ static int cache_add(struct c2_conf_reg *reg, const struct confx_object *onwire)
 	 *
 	 * C2_PRE(confc_is_locked(confc));
 	 *
-	 * obj = c2_conf_obj_new(onwire->o_conf.u_type, &onwire->o_id);
+	 * obj = c2_conf_obj_create(onwire->o_conf.u_type, &onwire->o_id);
 	 * if (obj == NULL)
 	 *     return -ENOMEM;
 	 * obj->co_confc = confc;
diff --git a/conf/obj.h b/conf/obj.h
index 555a6a8..f833e0b 100644
--- a/conf/obj.h
+++ b/conf/obj.h
@@ -159,13 +159,17 @@ enum c2_conf_status {
 struct c2_conf_obj {
 	/** Type of the ambient (concrete) configuration object. */
 	enum c2_conf_objtype          co_type;
+
 	/**
 	 * Object identifier.
 	 * This value is unique among the object of given ->co_type.
 	 */
 	struct c2_buf                 co_id;
+
 	enum c2_conf_status           co_status;
+
 	const struct c2_conf_obj_ops *co_ops;
+
 	/**
 	 * Pointer to the parent object.
 	 *
@@ -173,6 +177,7 @@ struct c2_conf_obj {
          * (e.g., c2_conf_node).
 	 */
 	struct c2_conf_obj           *co_parent;
+
 	/**
 	 * Reference counter.
 	 * The object is "pinned" if this value is non-zero.
@@ -180,20 +185,25 @@ struct c2_conf_obj {
 	 * @see c2_conf_obj_get(), c2_conf_obj_put()
 	 */
 	uint64_t                      co_nrefs;
+
 	/**
 	 * Channel on which "configuration loading completed" and
 	 * "object unpinned" events are announced.
 	 */
 	struct c2_chan                co_chan;
+
 	/** Linkage to c2_conf_reg::r_objs. */
 	struct c2_tlink               co_reg_link;
+
 	/** Linkage to c2_conf_dir::cd_items. */
 	struct c2_tlink               co_dir_link;
+
 	/**
 	 * Private data of confc implementation.
 	 * NULL at confd side.
 	 */
 	struct c2_confc              *co_confc;
+
 	/**
 	 * Generic magic.
 	 *
@@ -203,6 +213,7 @@ struct c2_conf_obj {
 	 * This magic value is used for list operations.
 	 */
 	uint64_t                      co_gen_magic;
+
 	/**
 	 * Concrete magic.
 	 *
@@ -213,6 +224,17 @@ struct c2_conf_obj {
 	 * (see C2_CONF_CAST()).
 	 */
 	uint64_t                      co_con_magic;
+
+	/**
+	 * Whether the object has been inserted into the DAG.
+	 *
+	 * ->co_mounted is true iff all of object's relations -- both
+	 * generic (->co_parent) and concrete (e.g.,
+	 * c2_conf_service::cs_node) -- are established.
+	 *
+	 * @see @ref conf-lspec-comps
+	 */
+	bool                          co_mounted;
 };
 
 /* ------------------------------------------------------------------
diff --git a/conf/obj_ops.c b/conf/obj_ops.c
index 1a74ab6..a45f534 100644
--- a/conf/obj_ops.c
+++ b/conf/obj_ops.c
@@ -65,11 +65,12 @@ static bool _generic_obj_invariant(const void *bob)
 {
 	const struct c2_conf_obj *obj = bob;
 
-	return buf_is_valid(&obj->co_id) &&
+	return buf_is_valid(&obj->co_id) && obj->co_ops != NULL &&
 		C2_IN(obj->co_status,
 		      (C2_CS_MISSING, C2_CS_LOADING, C2_CS_READY)) &&
-		obj->co_ops != NULL &&
-		ergo(obj_is_stub(obj), obj->co_nrefs == 0);
+		(obj->co_status == C2_CS_READY ? obj->co_mounted :
+		 obj->co_nrefs == 0) &&
+		ergo(!obj->co_mounted, obj->co_status == C2_CS_MISSING);
 }
 
 struct c2_conf_obj *c2_conf__dir_create(void);
@@ -119,13 +120,9 @@ c2_conf_obj_create(enum c2_conf_objtype type, const struct c2_buf *id)
 	c2_conf_obj_bob_init(obj);
 	C2_ASSERT(obj->co_gen_magic == C2_CONF_OBJ_MAGIC);
 	C2_ASSERT(obj->co_con_magic != 0);
+	C2_ASSERT(!obj->co_mounted);
 
-	/*
-	 * We cannot check c2_conf_obj_invariant() here: validation of
-	 * concrete fields may fail, because connections to other
-	 * objects of the DAG have not been established yet.
-	 */
-	C2_POST(c2_conf_obj_bob_check(obj));
+	C2_POST(c2_conf_obj_invariant(obj));
 	return obj;
 }
 
@@ -145,7 +142,7 @@ void c2_conf_obj_delete(struct c2_conf_obj *obj)
 	obj->co_ops->coo_delete(obj);
 }
 
-static bool confc_is_nil_or_locked(const struct c2_conf_obj *obj)
+static bool confc_is_unset_or_locked(const struct c2_conf_obj *obj)
 {
 #if 0 /* XXX */
 	return obj->co_confc == NULL ||
@@ -159,7 +156,7 @@ void c2_conf_obj_get(struct c2_conf_obj *obj)
 {
 	C2_PRE(c2_conf_obj_invariant(obj));
 	C2_PRE(obj->co_status == C2_CS_READY);
-	C2_PRE(confc_is_nil_or_locked(obj));
+	C2_PRE(confc_is_unset_or_locked(obj));
 
 	C2_CNT_INC(obj->co_nrefs);
 }
@@ -168,7 +165,7 @@ void c2_conf_obj_put(struct c2_conf_obj *obj)
 {
 	C2_PRE(c2_conf_obj_invariant(obj));
 	C2_PRE(obj->co_status == C2_CS_READY);
-	C2_PRE(confc_is_nil_or_locked(obj));
+	C2_PRE(confc_is_unset_or_locked(obj));
 
 	C2_CNT_DEC(obj->co_nrefs);
 	if (obj->co_nrefs == 0)
@@ -183,7 +180,7 @@ int c2_conf_obj_fill(struct c2_conf_obj *dest, const struct confx_object *src,
 	int rc;
 
 	C2_PRE(c2_conf_obj_invariant(dest));
-	C2_PRE(confc_is_nil_or_locked(dest));
+	C2_PRE(confc_is_unset_or_locked(dest));
 	C2_PRE(obj_is_stub(dest) && dest->co_nrefs == 0);
 	C2_PRE(dest->co_type == src->o_conf.u_type);
 	C2_PRE(c2_buf_eq(&dest->co_id, &src->o_id));
@@ -192,7 +189,8 @@ int c2_conf_obj_fill(struct c2_conf_obj *dest, const struct confx_object *src,
 	rc = dest->co_ops->coo_fill(dest, src, reg);
 
 	C2_POST(dest->co_status == (rc == 0 ? C2_CS_READY : C2_CS_MISSING));
-	C2_POST(confc_is_nil_or_locked(dest));
+	C2_POST(ergo(rc == 0, dest->co_mounted));
+	C2_POST(confc_is_unset_or_locked(dest));
 	C2_POST(c2_conf_obj_invariant(dest));
 	return rc;
 }
@@ -200,18 +198,13 @@ int c2_conf_obj_fill(struct c2_conf_obj *dest, const struct confx_object *src,
 bool c2_conf_obj_match(const struct c2_conf_obj *cached,
 		       const struct confx_object *onwire)
 {
-	C2_PRE(c2_conf_obj_invariant(cached));
+	C2_PRE(cached->co_mounted && c2_conf_obj_invariant(cached));
 	C2_PRE(confx_object_is_valid(onwire));
 
-	if (cached->co_type != onwire->o_conf.u_type ||
-	    !c2_buf_eq(&cached->co_id, &onwire->o_id))
-		return false;
-
-	return cached->co_status == C2_CS_READY ?
-		/* compare concrete fields */
-		cached->co_ops->coo_match(cached, onwire) :
-		/* a stub with matching identity */
-		true;
+	return cached->co_type == onwire->o_conf.u_type &&
+		c2_buf_eq(&cached->co_id, &onwire->o_id) &&
+		(obj_is_stub(cached) ||
+		 cached->co_ops->coo_match(cached, onwire));
 }
 
 /** Performs sanity checking of given onwire object. */
diff --git a/conf/obj_ops.h b/conf/obj_ops.h
index f7ba022..477ecad 100644
--- a/conf/obj_ops.h
+++ b/conf/obj_ops.h
@@ -103,6 +103,7 @@ struct c2_conf_obj_ops {
 	 *
 	 * @pre   dest->co_nrefs == 0 && dest->co_status != C2_CS_READY
 	 * @post  dest->co_status == (retval == 0 ? C2_CS_READY : C2_CS_MISSING)
+	 * @post  ergo(retval == 0, dest->co_mounted)
 	 */
 	int (*coo_fill)(struct c2_conf_obj *dest,
 			const struct confx_object *src,
@@ -167,6 +168,9 @@ struct c2_conf_obj_ops {
  *
  * Note, that c2_conf_obj_create() does not add the resulting object
  * into configuration cache.
+ *
+ * @post  ergo(retval != NULL,
+ *             !retval->co_mounted && retval->co_status == C2_CS_MISSING)
  */
 struct c2_conf_obj *c2_conf_obj_create(enum c2_conf_objtype type,
 				       const struct c2_buf *id);
@@ -206,19 +210,18 @@ void c2_conf_obj_put(struct c2_conf_obj *obj);
  * @param src   On-wire object, providing the configuration data.
  * @param reg   Registry of cached configuration objects.
  *
- * Note, that the caller is responsible for ensuring that valid
- * confx_object is passed via `src' parameter.
+ * Note, that the caller is responsible for passing valid confx_object
+ * via `src' parameter.
  *
  * @pre   `src' is valid
  * @pre   c2_mutex_is_locked(&dest->co_confc->cc_lock)
- * @pre   dest->co_status != C2_CS_READY
- * @pre   dest->co_nrefs == 0
+ * @pre   dest->co_nrefs == 0 && dest->co_status != C2_CS_READY
  * @pre   dest->co_type == src->o_conf.u_type
  * @pre   c2_buf_eq(&dest->co_id, &src->o_id)
  *
- * @post  dest->co_status == C2_CS_READY
  * @post  c2_conf_obj_invariant(dest)
  * @post  c2_mutex_is_locked(&dest->co_confc->cc_lock)
+ * @post  ergo(retval == 0, dest->co_status == C2_CS_READY && dest->co_mounted)
  */
 int c2_conf_obj_fill(struct c2_conf_obj *dest, const struct confx_object *src,
 		     struct c2_conf_reg *reg);
@@ -227,9 +230,10 @@ int c2_conf_obj_fill(struct c2_conf_obj *dest, const struct confx_object *src,
  * Returns false iff cached configuration object and on-wire object
  * have conflicting data.
  *
- * Note, that the caller is responsible for ensuring that valid
- * confx_object is passed via `onwire' parameter.
+ * Note, that the caller is responsible for passing valid confx_object
+ * via `onwire' parameter.
  *
+ * @pre  cached->co_mounted
  * @pre  `onwire' is valid
  */
 bool c2_conf_obj_match(const struct c2_conf_obj *cached,
diff --git a/conf/objs/common.c b/conf/objs/common.c
index 13a7f15..265ae4b 100644
--- a/conf/objs/common.c
+++ b/conf/objs/common.c
@@ -22,22 +22,19 @@
 #  include "config.h"
 #endif
 #include "conf/objs/common.h"
-#include "conf/reg.h" /* c2_conf_reg_lookup, c2_conf_reg_add, c2_conf_reg_del */
+#include "conf/reg.h"
 
-int obj_find(struct c2_conf_reg *reg, enum c2_conf_objtype type,
-	     const struct c2_buf *id, struct c2_conf_obj **out)
+bool buf_is_valid(const struct c2_buf *buf)
 {
-	*out = c2_conf_reg_lookup(reg, type, id);
-	if (*out == NULL) {
-		/* Create a stub. */
-		*out = c2_conf_obj_create(type, id);
-		if (*out == NULL)
-			return -ENOMEM;
+	return buf->b_nob > 0 && buf->b_addr != NULL;
+}
 
-		/* Register the stub. */
-		c2_conf_reg_add(reg, *out);
-	}
-	return 0;
+bool buf_streq(const struct c2_buf *buf, const char *str)
+{
+	C2_PRE(buf_is_valid(buf) && str != NULL);
+
+	return memcmp(str, buf->b_addr, buf->b_nob) == 0 &&
+		strlen(str) == buf->b_nob;
 }
 
 char *buf_strdup(const struct c2_buf *buf)
@@ -61,23 +58,53 @@ char *buf_strdup(const struct c2_buf *buf)
 	return s;
 }
 
-bool buf_streq(const struct c2_buf *buf, const char *str)
+bool obj_is_stub(const struct c2_conf_obj *obj)
 {
-	C2_PRE(buf_is_valid(buf) && str != NULL);
+	return obj->co_status != C2_CS_READY;
+}
 
-	return memcmp(str, buf->b_addr, buf->b_nob) == 0 &&
-		strlen(str) == buf->b_nob;
+static bool mounted_as(const struct c2_conf_obj *obj, enum c2_conf_objtype type)
+{
+	return obj->co_mounted && obj->co_type == type;
+}
+
+bool
+parent_check(const struct c2_conf_obj *obj, enum c2_conf_objtype parent_type)
+{
+	const struct c2_conf_obj *parent = obj->co_parent;
+
+	C2_PRE(obj->co_mounted && obj->co_type != parent_type);
+
+	return mounted_as(parent, parent_type) &&
+		parent->co_status == C2_CS_READY &&
+		ergo(parent_type == C2_CO_DIR,
+		     C2_CONF_CAST(parent, c2_conf_dir)->cd_item_type ==
+		     obj->co_type);
 }
 
-bool child_is_ok(const struct c2_conf_obj *obj, const struct c2_conf_obj *child,
+bool child_check(const struct c2_conf_obj *obj, const struct c2_conf_obj *child,
 		 enum c2_conf_objtype child_type)
 {
-	return /* Child is NULL iff `obj' is a stub. */
-		obj_is_stub(obj) == (child == NULL) &&
-		/* Child is valid object of given type, and `obj' is
-		 * its parent. */
-		ergo(!obj_is_stub(obj), obj_check_as(child, child_type) &&
-		     child->co_parent == obj);
+	C2_PRE(obj->co_mounted);
+
+	return obj_is_stub(obj) ? child == NULL :
+		mounted_as(child, child_type) && child->co_parent == obj;
+}
+
+int obj_find(struct c2_conf_reg *reg, enum c2_conf_objtype type,
+	     const struct c2_buf *id, struct c2_conf_obj **out)
+{
+	*out = c2_conf_reg_lookup(reg, type, id);
+	if (*out == NULL) {
+		/* Create a stub. */
+		*out = c2_conf_obj_create(type, id);
+		if (*out == NULL)
+			return -ENOMEM;
+
+		/* Register the stub. */
+		c2_conf_reg_add(reg, *out);
+	}
+	return 0;
 }
 
 int dir_new(const struct c2_buf *dir_id, enum c2_conf_objtype child_type,
diff --git a/conf/objs/common.h b/conf/objs/common.h
index 66d37dd..41738fa 100644
--- a/conf/objs/common.h
+++ b/conf/objs/common.h
@@ -60,25 +60,9 @@ static void type ## _bob_fini(struct type *bob) \
 						\
 struct __ ## type ## _semicolon_catcher
 
-static inline bool obj_is_stub(const struct c2_conf_obj *obj)
-{
-	return obj->co_status != C2_CS_READY;
-}
+bool buf_is_valid(const struct c2_buf *buf);
 
-static inline bool
-obj_check_as(const struct c2_conf_obj *obj, enum c2_conf_objtype type)
-{
-	return obj->co_type == type && c2_conf_obj_invariant(obj);
-}
-
-/** Finds object in the registry or creates (and registers) a stub for it. */
-int obj_find(struct c2_conf_reg *reg, enum c2_conf_objtype type,
-	     const struct c2_buf *id, struct c2_conf_obj **out);
-
-static inline bool buf_is_valid(const struct c2_buf *buf)
-{
-	return buf->b_nob > 0 && buf->b_addr != NULL;
-}
+bool buf_streq(const struct c2_buf *buf, const char *str);
 
 /**
  * Duplicates a string pointed to by buf->b_addr.  Length of the
@@ -91,11 +75,18 @@ static inline bool buf_is_valid(const struct c2_buf *buf)
  */
 char *buf_strdup(const struct c2_buf *buf);
 
-bool buf_streq(const struct c2_buf *buf, const char *str);
+bool obj_is_stub(const struct c2_conf_obj *obj);
+
+bool
+parent_check(const struct c2_conf_obj *obj, enum c2_conf_objtype parent_type);
 
-bool child_is_ok(const struct c2_conf_obj *obj, const struct c2_conf_obj *child,
+bool child_check(const struct c2_conf_obj *obj, const struct c2_conf_obj *child,
 		 enum c2_conf_objtype child_type);
 
+/** Finds object in the registry or creates (and registers) a stub for it. */
+int obj_find(struct c2_conf_reg *reg, enum c2_conf_objtype type,
+	     const struct c2_buf *id, struct c2_conf_obj **out);
+
 /**
  * Creates new c2_conf_directory and populates it with stubs.
  *
diff --git a/conf/objs/dir.c b/conf/objs/dir.c
index 62c38c5..c923899 100644
--- a/conf/objs/dir.c
+++ b/conf/objs/dir.c
@@ -37,14 +37,20 @@ static bool dir_invariant(const void *bob)
 
 	C2_PRE(self_obj->co_type == C2_CO_DIR);
 
-	return /* Parent is valid configuration object. */
-		obj_check_as(parent, parent->co_type) &&
-		/* Children are valid objects of proper type and point
-		 * to `self' via ->co_parent field. */
-		ergo(!obj_is_stub(self_obj),
-		     c2_tl_forall(c2_conf_dir, child, &self->cd_items,
-			obj_check_as(child, self->cd_item_type) &&
-			((struct c2_conf_obj *)child)->co_parent == self_obj));
+	return ergo(self_obj->co_status == C2_CS_READY,
+		    C2_IN(self->cd_item_type, (C2_CO_SERVICE, C2_CO_NIC,
+					       C2_CO_SDEV, C2_CO_PARTITION))) &&
+		(self_obj->co_mounted ?
+		 /* check relations */
+		 parent->co_mounted && parent->co_status == C2_CS_READY &&
+		 C2_IN(parent->co_type,
+		       (C2_CO_FILESYSTEM, C2_CO_NODE, C2_CO_SDEV)) &&
+		 ergo(self_obj->co_status == C2_CS_READY,
+		      c2_tl_forall(c2_conf_dir, child, &self->cd_items,
+				   child_check(self_obj, child,
+					       self->cd_item_type))) :
+		 /* ensure the absence of relations */
+		 parent == NULL && c2_conf_dir_tlist_is_empty(&self->cd_items));
 }
 
 static int dir_fill(struct c2_conf_obj *__dest __attribute__((unused)),
@@ -62,6 +68,53 @@ static bool dir_match(const struct c2_conf_obj *cached __attribute__((unused)),
 	return false;
 }
 
+/* static bool */
+/* belongs(const struct c2_conf_obj *entry, const struct c2_conf_obj *dir) */
+/* { */
+/* 	const struct c2_conf_dir *d = bob_of(dir, const struct c2_conf_dir, */
+/* 					     c2_conf_dir_cast_field, */
+/* 					     &c2_conf_dir_bob); */
+/* 	return d->cd_item_type == entry->co_type && entry->co_parent == dir; */
+/* } */
+
+/* /\** */
+/*  * Precondition for c2_conf_obj_ops::coo_readdir(). */
+/*  * */
+/*  * @param dir     The 1st argument of ->coo_readdir(). */
+/*  * @param entry   The 2nd argument of ->coo_readdir(), dereferenced */
+/*  *                before the function is called (*pptr). */
+/*  * */
+/*  * @see c2_conf_obj_ops::coo_readdir() */
+/*  *\/ */
+/* static bool */
+/* readdir_pre(const struct c2_conf_obj *dir, const struct c2_conf_obj *entry) */
+/* { */
+/* 	return obj_invariant(dir) && obj_invariant(entry) && */
+/* 		dir->co_type == C2_CO_DIR && dir->co_nrefs > 0 && */
+/* 		ergo(entry != NULL, belongs(entry, dir) && entry->co_nrefs > 0); */
+/* } */
+
+/* /\** */
+/*  * Postcondition for c2_conf_obj_ops::coo_readdir(). */
+/*  * */
+/*  * @param retval  The value returned by ->coo_readdir(). */
+/*  * @param dir     The 1st argument of ->coo_readdir(). */
+/*  * @param entry   The 2nd argument of ->coo_readdir(), dereferenced */
+/*  *                after the function is called (*pptr). */
+/*  * */
+/*  * @see c2_conf_obj_ops::coo_readdir() */
+/*  *\/ */
+/* static bool readdir_post(int retval, const struct c2_conf_obj *dir, */
+/* 			 const struct c2_conf_obj *entry) */
+/* { */
+/* 	return obj_invariant(dir) && obj_invariant(entry) && */
+/* 		C2_IN(retval, */
+/* 		     (C2_CONF_DIREND, C2_CONF_DIRNEXT, C2_CONF_DIRMISS)) && */
+/* 		(retval == C2_CONF_DIRNEXT ? */
+/* 		 (entry != NULL && belongs(entry, dir) && entry->co_nrefs > 0) : */
+/* 		 entry == NULL); */
+/* } */
+
 static int dir_readdir(struct c2_conf_obj *dir, struct c2_conf_obj **pptr)
 {
 	/*
diff --git a/conf/objs/filesystem.c b/conf/objs/filesystem.c
index 1b2e55d..135efe6 100644
--- a/conf/objs/filesystem.c
+++ b/conf/objs/filesystem.c
@@ -29,18 +29,19 @@ static bool filesystem_invariant(const void *bob)
 {
 	const struct c2_conf_filesystem *self = bob;
 	const struct c2_conf_obj        *self_obj = &self->cf_obj;
-	struct c2_conf_obj              *parent = self_obj->co_parent;
 
 	C2_PRE(self_obj->co_type == C2_CO_FILESYSTEM);
 
-	return /* Parent is valid c2_conf_profile pointing to `self' via
-		* c2_conf_profile::cp_filesystem field. */
-		obj_check_as(parent, C2_CO_PROFILE) &&
-		C2_CONF_CAST(parent, c2_conf_profile)->cp_filesystem == self &&
-		child_is_ok(self_obj, MEMBER_PTR(self->cf_services, cd_obj),
-			    C2_CO_DIR) &&
-		/* Other checks. */
-		obj_is_stub(self_obj) == (self->cf_params == NULL);
+	return ergo(obj_is_stub(self_obj), self->cf_params == NULL) &&
+		(self_obj->co_mounted ?
+		 /* check relations */
+		 parent_check(self_obj, C2_CO_PROFILE) &&
+		 C2_CONF_CAST(self_obj->co_parent,
+			      c2_conf_profile)->cp_filesystem == self &&
+		 child_check(self_obj, MEMBER_PTR(self->cf_services, cd_obj),
+			     C2_CO_DIR) :
+		 /* ensure the absence of relations */
+		 self_obj->co_parent == NULL && self->cf_services == NULL);
 }
 
 static int filesystem_fill(struct c2_conf_obj *__dest,
diff --git a/conf/objs/nic.c b/conf/objs/nic.c
index 682d5dc..cc72055 100644
--- a/conf/objs/nic.c
+++ b/conf/objs/nic.c
@@ -29,17 +29,15 @@ static bool nic_invariant(const void *bob)
 {
 	const struct c2_conf_nic *self = bob;
 	const struct c2_conf_obj *self_obj = &self->ni_obj;
-	struct c2_conf_obj       *parent = self_obj->co_parent;
 
 	C2_PRE(self_obj->co_type == C2_CO_NIC);
 
-	return /* Parent is valid c2_conf_dir with proper
-		* ->cd_item_type. */
-		obj_check_as(parent, C2_CO_DIR) &&
-		C2_CONF_CAST(parent,
-			     c2_conf_dir)->cd_item_type == C2_CO_NIC &&
-		/* Other checks. */
-		obj_is_stub(self_obj) == (self->ni_filename == NULL);
+	return obj_is_stub(self_obj) == (self->ni_filename == NULL) &&
+		(self_obj->co_mounted ?
+		 /* check relations */
+		 parent_check(self_obj, C2_CO_DIR) :
+		 /* ensure the absence of relations */
+		 self_obj->co_parent == NULL);
 }
 
 static int nic_fill(struct c2_conf_obj *__dest,
diff --git a/conf/objs/node.c b/conf/objs/node.c
index b20bb38..38d3c5d 100644
--- a/conf/objs/node.c
+++ b/conf/objs/node.c
@@ -33,13 +33,20 @@ static bool node_invariant(const void *bob)
 	C2_PRE(self_obj->co_type == C2_CO_NODE);
 
 	return /* The notion of parent is not applicable to a node,
-		* since a node may host (be child of) several
+		* since a node may host (be a child of) several
 		* services. */
 		self_obj->co_parent == NULL &&
-		child_is_ok(self_obj, MEMBER_PTR(self->cn_nics, cd_obj),
-			    C2_CO_DIR) &&
-		child_is_ok(self_obj, MEMBER_PTR(self->cn_sdevs, cd_obj),
-			    C2_CO_DIR);
+		(self_obj->co_mounted ?
+		 /* check relations */
+		 parent_check(self_obj, C2_CO_SERVICE) &&
+		 C2_CONF_CAST(self_obj->co_parent,
+			      c2_conf_service)->cs_node == self &&
+		 child_check(self_obj, MEMBER_PTR(self->cn_nics, cd_obj),
+			     C2_CO_DIR) &&
+		 child_check(self_obj, MEMBER_PTR(self->cn_sdevs, cd_obj),
+			     C2_CO_DIR) :
+		 /* ensure the absence of relations */
+		 self->cn_nics == NULL && self->cn_sdevs == NULL);
 }
 
 static int node_fill(struct c2_conf_obj *__dest,
diff --git a/conf/objs/partition.c b/conf/objs/partition.c
index 17cdebb..971369e 100644
--- a/conf/objs/partition.c
+++ b/conf/objs/partition.c
@@ -29,17 +29,15 @@ static bool partition_invariant(const void *bob)
 {
 	const struct c2_conf_partition *self = bob;
 	const struct c2_conf_obj       *self_obj = &self->pa_obj;
-	struct c2_conf_obj             *parent = self_obj->co_parent;
 
 	C2_PRE(self_obj->co_type == C2_CO_PARTITION);
 
-	return /* Parent is valid c2_conf_dir with proper
-		* ->cd_item_type. */
-		obj_check_as(parent, C2_CO_DIR) &&
-		C2_CONF_CAST(parent,
-			     c2_conf_dir)->cd_item_type == C2_CO_PARTITION &&
-		/* Other checks. */
-		obj_is_stub(self_obj) == (self->pa_filename == NULL);
+	return obj_is_stub(self_obj) == (self->pa_filename == NULL) &&
+		(self_obj->co_mounted ?
+		 /* check relations */
+		 parent_check(self_obj, C2_CO_DIR) :
+		 /* ensure the absence of relations */
+		 self_obj->co_parent == NULL);
 }
 
 static int partition_fill(struct c2_conf_obj *__dest,
diff --git a/conf/objs/profile.c b/conf/objs/profile.c
index 4c2d565..61a4824 100644
--- a/conf/objs/profile.c
+++ b/conf/objs/profile.c
@@ -32,17 +32,21 @@ static bool profile_invariant(const void *bob)
 
 	C2_PRE(self_obj->co_type == C2_CO_PROFILE);
 
-	return /* c2_conf_profile is the topmost object in the DAG. */
-		self_obj->co_parent == NULL &&
-		child_is_ok(self_obj, MEMBER_PTR(self->cp_filesystem, cf_obj),
-			    C2_CO_FILESYSTEM) &&
-#if 0 /* XXX */
-		/* Other checks. */
+	return
+#if 0 /*XXX*/
 		ergo(self_obj->co_confc != NULL,
-		     self_obj->co_confc->cc_root == self_obj);
+		     self_obj->co_confc->cc_root == self_obj) &&
 #else
-		true;
+		true &&
 #endif
+		/* c2_conf_profile is the topmost object in the DAG */
+		self_obj->co_parent == NULL &&
+		(self_obj->co_mounted ?
+		 /* check relations */
+		 child_check(self_obj, MEMBER_PTR(self->cp_filesystem, cf_obj),
+			     C2_CO_FILESYSTEM) :
+		 /* ensure the absence of relations */
+		 self->cp_filesystem == NULL);
 }
 
 static int profile_fill(struct c2_conf_obj *__dest,
diff --git a/conf/objs/sdev.c b/conf/objs/sdev.c
index 2d3d8c0..73d2396 100644
--- a/conf/objs/sdev.c
+++ b/conf/objs/sdev.c
@@ -29,19 +29,17 @@ static bool sdev_invariant(const void *bob)
 {
 	const struct c2_conf_sdev *self = bob;
 	const struct c2_conf_obj  *self_obj = &self->sd_obj;
-	struct c2_conf_obj        *parent = self_obj->co_parent;
 
 	C2_PRE(self_obj->co_type == C2_CO_SDEV);
 
-	return /* Parent is valid c2_conf_dir with proper
-		* ->cd_item_type. */
-		obj_check_as(parent, C2_CO_DIR) &&
-		C2_CONF_CAST(parent,
-			     c2_conf_dir)->cd_item_type == C2_CO_SDEV &&
-		child_is_ok(self_obj, MEMBER_PTR(self->sd_partitions, cd_obj),
-			    C2_CO_DIR) &&
-		/* Other checks. */
-		obj_is_stub(self_obj) == (self->sd_filename == NULL);
+	return obj_is_stub(self_obj) == (self->sd_filename == NULL) &&
+		(self_obj->co_mounted ?
+		 /* check relations */
+		 parent_check(self_obj, C2_CO_DIR) &&
+		 child_check(self_obj, MEMBER_PTR(self->sd_partitions, cd_obj),
+			     C2_CO_DIR) :
+		 /* ensure the absence of relations */
+		 self_obj->co_parent == NULL && self->sd_partitions == NULL);
 }
 
 static int sdev_fill(struct c2_conf_obj *__dest,
diff --git a/conf/objs/service.c b/conf/objs/service.c
index 3c59ced..3c190b8 100644
--- a/conf/objs/service.c
+++ b/conf/objs/service.c
@@ -29,24 +29,21 @@ static bool service_invariant(const void *bob)
 {
 	const struct c2_conf_service *self = bob;
 	const struct c2_conf_obj     *self_obj = &self->cs_obj;
-	struct c2_conf_obj           *parent = self_obj->co_parent;
 
 	C2_PRE(self_obj->co_type == C2_CO_SERVICE);
 
-	return /* Parent is valid c2_conf_dir with proper
-		* ->cd_item_type. */
-		obj_check_as(parent, C2_CO_DIR) &&
-		C2_CONF_CAST(parent,
-			     c2_conf_dir)->cd_item_type == C2_CO_SERVICE &&
-		child_is_ok(self_obj, MEMBER_PTR(self->cs_node, cn_obj),
-			    C2_CO_NODE) &&
-		/* Other checks. */
-		ergo(!obj_is_stub(self_obj),
-		     C2_IN(self->cs_type, (C2_CFG_SERVICE_METADATA,
-					   C2_CFG_SERVICE_IO,
-					   C2_CFG_SERVICE_MGMT,
-					   C2_CFG_SERVICE_DLM))) &&
-		obj_is_stub(self_obj) == (self->cs_endpoints == NULL);
+	return (obj_is_stub(self_obj) ? self->cs_endpoints == NULL :
+		C2_IN(self->cs_type, (C2_CFG_SERVICE_METADATA,
+				      C2_CFG_SERVICE_IO,
+				      C2_CFG_SERVICE_MGMT,
+				      C2_CFG_SERVICE_DLM))) &&
+		(self_obj->co_mounted ?
+		 /* check relations */
+		 parent_check(self_obj, C2_CO_DIR) &&
+		 child_check(self_obj, MEMBER_PTR(self->cs_node, cn_obj),
+			     C2_CO_NODE) :
+		 /* ensure the absence of relations */
+		 self_obj->co_parent == NULL && self->cs_node == NULL);
 }
 
 static int endpoints_populate(const char ***dest, const struct arr_buf *src)
diff --git a/conf/onwire.h b/conf/onwire.h
index 23bf106..82af5eb 100644
--- a/conf/onwire.h
+++ b/conf/onwire.h
@@ -30,7 +30,6 @@ struct c2_conf_fetch_resp;
 struct c2_conf_update;
 struct c2_conf_update_resp;
 
-/** XXX @todo Use c2_buf instead of arr_buf. */
 struct arr_buf {
 	uint32_t       ab_count;
 	struct c2_buf *ab_elems;
diff --git a/conf/ut/obj.c b/conf/ut/obj.c
index 25060ac..8cbcd06 100644
--- a/conf/ut/obj.c
+++ b/conf/ut/obj.c
@@ -22,8 +22,6 @@
 #  include "config.h"
 #endif
 #include "conf/obj_ops.h"
-#include "conf/reg.h"
-#include "lib/buf.h"
 #include "lib/ut.h"
 
 void test_obj(void)
@@ -36,13 +34,6 @@ void test_obj(void)
 					 C2_BUF_INITS("test"));
 		C2_UT_ASSERT(obj != NULL);
 
-		/* XXX TODO: check generic fields */
-
-		/* rc = c2_conf_obj_fill(obj, objx, &reg); */
-		/* C2_UT_ASSERT(rc == 0); */
-
-		/* XXX TODO: check concrete fields */
-
 		c2_conf_obj_delete(obj);
 	}
 }
diff --git a/conf/ut/reg.c b/conf/ut/reg.c
index e3f857a..71fb401 100644
--- a/conf/ut/reg.c
+++ b/conf/ut/reg.c
@@ -37,10 +37,8 @@ void test_reg(void)
 		struct c2_buf        id;
 	} samples[] = {
 		{ C2_CO_PROFILE,    C2_BUF_INIT(7, "pr\0file") },
-#if 0 /* XXX filesystem_invariant() fails, since objects are not connected */
 		{ C2_CO_FILESYSTEM, C2_BUF_INITS("filesystem") },
 		{ C2_CO_DIR,        C2_BUF_INITS("dir") }
-#endif
 	};
 
 	c2_conf_reg_init(&reg);
-- 
1.8.3.2

