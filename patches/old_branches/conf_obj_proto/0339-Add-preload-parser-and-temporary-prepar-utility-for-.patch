From 9b79fbede405b9625c17c7ce5c0c929df8253606 Mon Sep 17 00:00:00 2001
From: Anatoliy Bilenko <anatoliy_bilenko@xyratex.com>
Date: Thu, 30 Aug 2012 13:18:47 +0300
Subject: [PATCH 339/370] Add preload parser and temporary `prepar'-utility for
 debugging.

    - run `./prepar < confx.txt' for output.
---
 conf/Makefile.am    |   3 +-
 conf/preload.c      | 211 ++++++++++++++++++++++++++++++++++++++++++++++++++++
 conf/preload.h      |   4 +-
 conf/ut/Makefile.am |   5 ++
 conf/ut/confx.txt   |  19 +++++
 conf/ut/prepar.c    |  30 ++++++++
 6 files changed, 270 insertions(+), 2 deletions(-)
 create mode 100644 conf/preload.c
 create mode 100644 conf/ut/confx.txt
 create mode 100644 conf/ut/prepar.c

diff --git a/conf/Makefile.am b/conf/Makefile.am
index 2baa13e..1b8942e 100644
--- a/conf/Makefile.am
+++ b/conf/Makefile.am
@@ -1,7 +1,8 @@
 include $(top_srcdir)/Makefile.xc
 
 noinst_LTLIBRARIES = libcolibri-conf.la
-libcolibri_conf_la_SOURCES = obj.h obj.c reg.h reg.c onwire.h obj_ops.h obj_ops.c
+libcolibri_conf_la_SOURCES = obj.h obj.c reg.h reg.c obj_ops.h obj_ops.c \
+                             onwire.h preload.h preload.c
 
 INCLUDES	= -iquote . -iquote $(top_srcdir) -iquote \
 		$(top_srcdir)/include -iquote /usr/include
diff --git a/conf/preload.c b/conf/preload.c
new file mode 100644
index 0000000..f1638db
--- /dev/null
+++ b/conf/preload.c
@@ -0,0 +1,211 @@
+/* -*- c -*- */
+/*
+ * COPYRIGHT 2012 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: Valery V. Vorotyntsev <valery_vorotyntsev@xyratex.com>
+ *                  Anatoliy Bilenko <Anatoliy_Bilenko@xyratex.com>
+ * Original creation date: 29-Aug-2012
+ */
+
+#include "conf/preload.h"
+#include "conf/onwire.h"
+#include "lib/assert.h"
+#include "lib/errno.h"
+#include "lib/misc.h"
+#include <ctype.h>		/* isspace */
+
+#define HUNK_DBG
+#ifdef HUNK_DBG
+#include <stdio.h>
+#endif
+
+
+/* ------------------------------------------------------------------
+ * Preload parser
+ * ------------------------------------------------------------------ */
+
+struct hunk {
+	const char *begin;
+	const char *end;
+};
+
+#define HUNK_CP(p) { .begin = p->begin, .end = p->end }
+
+static bool hunk_is_empty(const struct hunk *p)
+{
+	return p->begin == NULL && p->end == NULL;
+}
+
+static void hunk_pr(const char *prefix, const struct hunk *p) {
+#ifdef HUNK_DBG
+	char buf[4096];
+
+	C2_PRE(!hunk_is_empty(p));
+	memset(buf, 0, 4096);
+	memcpy(buf, p->begin, p->end - p->begin + 1);
+	printf("%s: ~%s~\n---\n", prefix, buf);
+#endif
+}
+
+static void hunk_cp(struct hunk *dest, const struct hunk *source) {
+	dest->begin = source->begin;
+	dest->end   = source->end;
+}
+
+static int hunk_trim(struct hunk *p)
+{
+	C2_PRE(!hunk_is_empty(p));
+
+	while (isspace(*p->begin)) {
+		p->begin++;
+		if (p->begin == p->end)
+			return -ENOENT;
+	}
+
+	while (isspace(*p->end)) {
+		p->end--;
+		if (p->begin == p->end)
+			return -ENOENT;
+	}
+
+	return (p->end > p->begin) ? 0 : -EINVAL;
+}
+
+static int unit_advance(struct hunk *unit, char open, char close)
+{
+	C2_PRE(!hunk_is_empty(unit));
+
+	if (!(*unit->begin == open && *unit->end == close))
+		return -ENOENT;
+
+	unit->begin++;
+	unit->end--;
+
+	return (unit->begin >= unit->end) ? -ENOENT : 0;
+}
+
+static int unit_parse(struct hunk *unit)
+{
+	int  rc;
+	const char *p;
+	int  brace  = 0;
+	int  curly  = 0;
+	bool quoted = false;
+
+	if ((rc = hunk_trim(unit)) != 0)
+		return rc;
+
+	for (p = unit->begin; p <= unit->end; ++p) {
+		if (*p == '\"')
+			quoted = !quoted;
+
+		if (quoted)
+			continue;
+					/* @TODO: */
+		if (*p == '[') brace++; /* push *p into stack */
+		if (*p == ']') brace--; /* pop *c from stack, check *c == '[' */
+		if (*p == '{') curly++; /* push *p into stack */
+		if (*p == '}') curly--; /* pop *c from stack, check *c == '{' */
+
+		if (!curly && !brace && (*p == ',' || p == unit->end)) {
+			unit->end = (*p == ',') ? --p : p;
+			return hunk_trim(unit);
+		}
+	}
+
+	return -ENOENT;
+}
+
+static int unit_next(struct hunk *unit, const struct hunk *buffer)
+{
+	int  rc;
+
+	unit->begin = unit->end;
+	unit->end = buffer->end;
+
+	if (++unit->begin >= unit->end)
+		return -ENOENT;
+
+	if ((rc = hunk_trim(unit)) != 0)
+		return rc;
+
+	if (*unit->begin++ != ',')
+		return -EINVAL;
+
+	return 0;
+}
+
+static int sequence_parse(struct hunk *unit, const struct hunk *buffer)
+{
+	int  rc;
+
+	if (hunk_is_empty(unit))
+		hunk_cp(unit, buffer);
+	else {
+		rc = unit_next(unit, buffer);
+		if (rc != 0)
+			return rc;
+	}
+
+	return unit_parse(unit);
+}
+
+static int block_parse(struct hunk *unit, const struct hunk *buffer)
+{
+	return sequence_parse(unit, buffer);
+}
+
+static int record_parse(struct hunk *unit, const struct hunk *buffer)
+{
+	struct hunk contents = HUNK_CP(buffer);
+
+	return unit_advance(&contents, '[', ']') ?:
+		sequence_parse(unit, &contents);
+}
+
+static int entry_parse(struct hunk *unit, const struct hunk *buffer)
+{
+	struct hunk contents = HUNK_CP(buffer);
+
+	return unit_advance(&contents, '{', '}') ?:
+		sequence_parse(unit, &contents);
+}
+
+
+/* ------------------------------------------------------------------
+ * Confx objects allocation
+ * ------------------------------------------------------------------ */
+
+int c2_conf_parse(const char *src, struct confx_object *dest, size_t n)
+{
+	int entries = 0;
+	struct hunk str = { .begin = src, .end = &src[strlen(src) - 1] };
+	struct hunk blk = { NULL, NULL };
+
+	for (; block_parse(&blk, &str) == 0; ) {
+		struct hunk rec = { NULL, NULL };
+		hunk_pr("block", &blk);
+		for (; record_parse(&rec, &blk) == 0; ) {
+			struct hunk ent = { NULL, NULL };
+			hunk_pr("\trecord", &rec);
+			for (; entry_parse(&ent, &rec) == 0; ) {
+				hunk_pr("\t\tentry", &ent);
+				++entries;
+			}
+		}
+	}
+
+	return entries;
+}
diff --git a/conf/preload.h b/conf/preload.h
index f863427..05ba6a3 100644
--- a/conf/preload.h
+++ b/conf/preload.h
@@ -21,6 +21,8 @@
 #ifndef __COLIBRI_CONF_PRELOAD_H__
 #define __COLIBRI_CONF_PRELOAD_H__
 
+#include "lib/types.h"
+
 struct confx_object;
 
 /**
@@ -144,7 +146,7 @@ struct confx_object;
  * @pre   src does not start with "local-conf:"
  * @post  retval <= n
  */
-static int c2_conf_parse(const char *src, struct confx_object dest[], size_t n);
+int c2_conf_parse(const char *src, struct confx_object *dest, size_t n);
 
 /** @} conf_dfspec_preload */
 #endif /* __COLIBRI_CONF_PRELOAD_H__ */
diff --git a/conf/ut/Makefile.am b/conf/ut/Makefile.am
index 0dd64a6..dbbaca0 100644
--- a/conf/ut/Makefile.am
+++ b/conf/ut/Makefile.am
@@ -1,3 +1,8 @@
 noinst_LTLIBRARIES    = libconf-ut.la
 libconf_ut_la_SOURCES = obj.c reg.c
 libconf_ut_la_LIBADD  = $(top_builddir)/colibri/libcolibri.la
+
+# Preload parser (temporary target)
+noinst_PROGRAMS = prepar
+prepar_SOURCES  = prepar.c
+prepar_LDADD    = $(top_builddir)/colibri/libcolibri.la
diff --git a/conf/ut/confx.txt b/conf/ut/confx.txt
new file mode 100644
index 0000000..9d118ff
--- /dev/null
+++ b/conf/ut/confx.txt
@@ -0,0 +1,19 @@
+
+[ { "type":"profile", "id":"test-2", "filesystem":"c2t1fs" }
+, { "type":"filesystem", "id":"c2t1fs", "rootfid":[11, 22], "params":[50,60,70],
+    "services":["mds", "io"] }
+, { "type":"service", "id":"mds", "filesystem":"c2t1fs", "svc_type":1,
+    "endpoints":["addr0"], "node":"N" }
+, { "type":"service", "id":"io", "filesystem":"c2t1fs", "svc_type":2,
+    "endpoints":["addr1","addr2","addr3"], "node":"N" }
+, { "type":"node", "id":"N", "services":["mds", "io"], "memsize":8000,
+    "nr_cpu":2, "last_state":3, "flags":2, "pool_id":0, "nics":["nic0"],
+    "sdevs":["sdev0"] }
+, { "type":"nic", "id":"nic0", "iface_type":5, "mtu":8192, "speed":10000,
+    "filename":"ib0", "last_state":3 }
+, { "type":"sdev", "id":"sdev0", "iface":4, "media":1, "size":596000000000,
+    "last_state":3, "flags":4, "partitions":["part0"] }
+, { "type":"partition", "id":"part0", "start":0, "size":596000000000, "index":0,
+    "pa_type":7, "filename":"sda1" } ]
+
+
diff --git a/conf/ut/prepar.c b/conf/ut/prepar.c
new file mode 100644
index 0000000..9f2084f
--- /dev/null
+++ b/conf/ut/prepar.c
@@ -0,0 +1,30 @@
+#include <stdio.h>
+#include <string.h>
+#include "conf/preload.h"
+
+enum {
+	KB = (1 << 10)
+};
+
+static char buf[32*KB];
+
+int main(void)
+{
+	int c;
+	int i = 0;
+
+	memset(buf, 0, 32*KB);
+
+	while ((c = getchar()) != EOF) {
+		buf[i++] = c;
+		if (i >= 32*KB)
+			return -1;
+	}
+
+	buf[i] = '\0';
+
+	i = c2_conf_parse(buf, NULL, 0);
+	printf("entries: %d\n", i);
+
+	return 0;
+}
-- 
1.8.3.2

