From 7bac344efeb15ea21a29ad90f4e4e8bdb9ff0a09 Mon Sep 17 00:00:00 2001
From: Hua Huang <hua_huang@xyratex.com>
Date: Fri, 7 Dec 2012 11:10:47 +0800
Subject: [PATCH 1/6] client misc fixes, mainly comments and style.

---
 m0t1fs/linux_kernel/dir.c                   |  15 ++-
 m0t1fs/linux_kernel/file.c                  | 138 ++++++++++++++++------------
 m0t1fs/linux_kernel/file_internal.h         |  10 +-
 m0t1fs/linux_kernel/m0t1fs.h                |   6 +-
 m0t1fs/linux_kernel/st/m0t1fs_common_inc.sh |   5 +
 m0t1fs/linux_kernel/super.c                 |   5 +-
 6 files changed, 106 insertions(+), 73 deletions(-)

diff --git a/m0t1fs/linux_kernel/dir.c b/m0t1fs/linux_kernel/dir.c
index c6705ed..76bc1a2 100644
--- a/m0t1fs/linux_kernel/dir.c
+++ b/m0t1fs/linux_kernel/dir.c
@@ -171,6 +171,7 @@ static int m0t1fs_create(struct inode     *dir,
 	int                       rc;
 
 	M0_ENTRY();
+	M0_LOG(M0_INFO, "Creating \"%s\"", dentry->d_name.name);
 
 	/* Flat file system. create allowed only on root directory */
 	M0_ASSERT(m0t1fs_inode_is_root(dir));
@@ -304,6 +305,7 @@ struct m0_dirent *dirent_first(struct m0_fop_readdir_rep *rep)
 static int m0t1fs_opendir(struct inode *inode, struct file *file)
 {
         struct m0t1fs_filedata *fd;
+	M0_ENTRY();
 
         M0_ALLOC_PTR(fd);
         if (fd == NULL)
@@ -321,8 +323,11 @@ static int m0t1fs_opendir(struct inode *inode, struct file *file)
         return 0;
 }
 
-static int m0t1fs_releasedir(struct inode *inode, struct file *file) {
+static int m0t1fs_releasedir(struct inode *inode, struct file *file)
+{
         struct m0t1fs_filedata *fd = file->private_data;
+	M0_ENTRY();
+
         m0_free(fd->fd_dirpos);
         m0_free(file->private_data);
         file->private_data = NULL;
@@ -471,7 +476,7 @@ static int m0t1fs_link(struct dentry *old, struct inode *dir,
 
         rc = m0t1fs_mds_cob_link(csb, &mo, &link_rep);
         if (rc != 0) {
-                M0_LOG(M0_ERROR, "mdservive link fop failed: %d\n", rc);
+                M0_LOG(M0_ERROR, "mdservive link fop failed: %d", rc);
                 goto out;
         }
 
@@ -525,7 +530,7 @@ static int m0t1fs_unlink(struct inode *dir, struct dentry *dentry)
 
         rc = m0t1fs_mds_cob_unlink(csb, &mo, &unlink_rep);
         if (rc != 0) {
-                M0_LOG(M0_ERROR, "mdservive unlink fop failed: %d\n", rc);
+                M0_LOG(M0_ERROR, "mdservive unlink fop failed: %d", rc);
                 goto out;
         }
 
@@ -938,7 +943,7 @@ static int m0t1fs_mds_cob_op(struct m0t1fs_sb            *csb,
                 goto out;
         }
 
-        M0_LOG(M0_DEBUG, "Send md operation %x to session %lu\n",
+        M0_LOG(M0_DEBUG, "Send md operation %u to session %lu",
                 m0_fop_opcode(fop), (unsigned long)session->s_session_id);
 
         rc = m0_rpc_client_call(fop, session, NULL,
@@ -1129,7 +1134,7 @@ static int m0t1fs_ios_cob_op(struct m0t1fs_sb    *csb,
 	if (rc != 0)
 		goto fop_put;
 
-	M0_LOG(M0_DEBUG, "Send %s [%lu:%lu] to session %lu\n",
+	M0_LOG(M0_DEBUG, "Send %s [%lu:%lu] to session %lu",
 		cobcreate ? "cob_create" : "cob_delete",
 		(unsigned long)cob_fid->f_container,
 		(unsigned long)cob_fid->f_key,
diff --git a/m0t1fs/linux_kernel/file.c b/m0t1fs/linux_kernel/file.c
index bcd29d8..5183e4e 100644
--- a/m0t1fs/linux_kernel/file.c
+++ b/m0t1fs/linux_kernel/file.c
@@ -591,10 +591,10 @@ static void nw_xfer_req_complete(struct nw_xfer_request *xfer,
 				 bool			 rmw);
 static int  nw_xfer_req_dispatch(struct nw_xfer_request *xfer);
 
-static int  nw_xfer_tioreq_map	(struct nw_xfer_request	     *xfer,
-				 struct m0_pdclust_src_addr  *src,
-				 struct m0_pdclust_tgt_addr  *tgt,
-				 struct target_ioreq	    **out);
+static int  nw_xfer_tioreq_map	(struct nw_xfer_request	          *xfer,
+				 const struct m0_pdclust_src_addr *src,
+				 struct m0_pdclust_tgt_addr       *tgt,
+				 struct target_ioreq	         **out);
 
 static int  nw_xfer_tioreq_get	(struct nw_xfer_request *xfer,
 				 struct m0_fid		*fid,
@@ -892,7 +892,8 @@ static void nw_xfer_request_init(struct nw_xfer_request *xfer)
 
 	nw_xfer_request_bob_init(xfer);
 	xfer->nxr_rc	= 0;
-	xfer->nxr_bytes = xfer->nxr_iofop_nr = 0;
+	xfer->nxr_bytes = 0;
+	xfer->nxr_iofop_nr = 0;
 	xfer->nxr_state = NXS_INITIALIZED;
 	xfer->nxr_ops	= &xfer_ops;
 	tioreqs_tlist_init(&xfer->nxr_tioreqs);
@@ -986,8 +987,8 @@ static int user_data_copy(struct pargrp_iomap *map,
 					end - start);
 			pagefault_enable();
 
-			M0_LOG(M0_INFO, "%llu bytes copied from user-space\
-			       from offset %llu", bytes, start);
+			M0_LOG(M0_INFO, "%llu bytes copied from user-space "
+					"from offset %llu", bytes, start);
 
 			map->pi_ioreq->ir_copied_nr += bytes;
 
@@ -1003,8 +1004,8 @@ static int user_data_copy(struct pargrp_iomap *map,
 
 		map->pi_ioreq->ir_copied_nr += end - start - bytes;
 
-		M0_LOG(M0_INFO, "%llu bytes copied to user-space from offset\
-		       %llu", end - start - bytes, start);
+		M0_LOG(M0_INFO, "%llu bytes copied to user-space from offset "
+				"%llu", end - start - bytes, start);
 
 		if (bytes != 0)
 			M0_RETERR(-EFAULT, "Failed to copy_to_user");
@@ -1137,7 +1138,7 @@ static int ioreq_user_data_copy(struct io_request   *req,
 	struct m0_ivec_cursor	  srccur;
 	struct m0_pdclust_layout *play;
 
-	M0_ENTRY("io_request : %p, %s filter = %d", req,
+	M0_ENTRY("io_request : %p, %s user-space. filter = 0x%x", req,
 		 dir == CD_COPY_FROM_USER ? (char *)"from" : (char *)"to",
 		 filter);
 	M0_PRE(io_request_invariant(req));
@@ -1362,6 +1363,7 @@ static int pargrp_iomap_databuf_alloc(struct pargrp_iomap *map,
 	M0_PRE(map != NULL);
 	M0_PRE(map->pi_databufs[row][col] == NULL);
 
+	M0_ENTRY("row %u col %u", row, col);
 	map->pi_databufs[row][col] = data_buf_alloc_init(0);
 
 	return map->pi_databufs[row][col] == NULL ?  -ENOMEM : 0;
@@ -1428,6 +1430,9 @@ static int pargrp_iomap_seg_process(struct pargrp_iomap *map,
 			 * delimited the index vector to EOF boundary.
 			 */
 			dbuf->db_flags |= PA_READ;
+
+		M0_LOG(M0_DEBUG, "start %llu count %llu row %u col %u flag %x",
+				start, count, row, col, dbuf->db_flags);
 	}
 
 	M0_RETURN(0);
@@ -1598,8 +1603,7 @@ static int pargrp_iomap_readrest(struct pargrp_iomap *map)
 
 	M0_ENTRY("map %p", map);
 	M0_PRE(pargrp_iomap_invariant(map));
-
-	map->pi_rtype = PIR_READREST;
+	M0_PRE(map->pi_rtype == PIR_READREST);
 
 	play	 = pdlayout_get(map->pi_ioreq);
 	ivec	 = &map->pi_ivec;
@@ -1745,10 +1749,8 @@ static int pargrp_iomap_populate(struct pargrp_iomap	  *map,
 	uint64_t		  seg;
 	uint64_t		  size = 0;
 	uint64_t		  grpsize;
-	//uint32_t                  rseg;
 	m0_bcount_t		  count = 0;
 	m0_bindex_t               endpos = 0;
-	//m0_bindex_t               reqindex;
 	m0_bcount_t               segcount = 0;
 	/* Number of pages _completely_ spanned by incoming io vector. */
 	uint64_t		  nr = 0;
@@ -1769,7 +1771,6 @@ static int pargrp_iomap_populate(struct pargrp_iomap	  *map,
 	grpsize	 = data_size(play);
 	grpstart = grpsize * map->pi_grpid;
 	grpend	 = grpstart + grpsize;
-	endpos   = m0_ivec_cursor_index(cursor);
 
 	for (seg = cursor->ic_cur.vc_seg; seg < SEG_NR(ivec) &&
 	     INDEX(ivec, seg) < grpend; ++seg) {
@@ -1809,8 +1810,8 @@ static int pargrp_iomap_populate(struct pargrp_iomap	  *map,
 		/* For read IO request, IO should not go beyond EOF. */
 		if (map->pi_ioreq->ir_type == IRT_READ &&
 		    seg_endpos(&map->pi_ivec, seg) > size)
-			COUNT(&map->pi_ivec, seg) = size - INDEX(&map->pi_ivec,
-								 seg);
+			COUNT(&map->pi_ivec, seg) = size -
+						INDEX(&map->pi_ivec, seg);
 
 		/*
 		 * If current segment is _partially_ spanned by previous
@@ -1827,9 +1828,7 @@ static int pargrp_iomap_populate(struct pargrp_iomap	  *map,
 			COUNT(&map->pi_ivec, seg) -= (newindex -
 					INDEX(&map->pi_ivec, seg));
 
-			INDEX(&map->pi_ivec, seg)  = m0_round_up(
-					INDEX(&map->pi_ivec, seg) + 1,
-					PAGE_CACHE_SIZE);
+			INDEX(&map->pi_ivec, seg)  = newindex;
 		}
 
 		++map->pi_ivec.iv_vec.v_nr;
@@ -1845,6 +1844,10 @@ static int pargrp_iomap_populate(struct pargrp_iomap	  *map,
 			round_up(endpos, PAGE_CACHE_SIZE) -
 			INDEX(&map->pi_ivec, seg);
 
+		M0_LOG(M0_DEBUG, "seg %llu index %llu count %llu", seg,
+				INDEX(&map->pi_ivec, seg),
+				COUNT(&map->pi_ivec, seg));
+
 		count = endpos - m0_ivec_cursor_index(cursor);
 		++seg;
 	}
@@ -1878,6 +1881,7 @@ static int pargrp_iomap_populate(struct pargrp_iomap	  *map,
 			     parity_units_page_nr(play);
 
 		if (rr_page_nr < ro_page_nr) {
+			map->pi_rtype = PIR_READREST;
 			rc = map->pi_ops->pi_readrest(map);
 			if (rc != 0)
 				M0_RETERR(rc, "readrest failed");
@@ -1927,6 +1931,12 @@ static int ioreq_iomaps_prepare(struct io_request *req)
 		grpend	 = group_id(seg_endpos(&req->ir_ivec, seg) - 1,
 				    data_size(play));
 		for (grp = grpstart; grp <= grpend; ++grp) {
+			/*
+			 * grparray is a temporary array to record found groups.
+			 * Scan this array for [grpstart, grpend].
+			 * If not found, record it in this array and
+			 * increase ir_iomap_nr.
+			 */
 			for (id = 0; id < req->ir_iomap_nr; ++id)
 				if (grparray[id] == grp)
 					break;
@@ -2047,8 +2057,8 @@ static int nw_xfer_io_prepare(struct nw_xfer_request *xfer)
 	for (map = 0; map < req->ir_iomap_nr; ++map) {
 
 		count        = 0;
-		pgstart	     = data_size(play) * req->ir_iomaps[map]->
-			       pi_grpid;
+		pgstart	     = data_size(play) *
+					req->ir_iomaps[map]->pi_grpid;
 		pgend	     = pgstart + data_size(play);
 		src.sa_group = req->ir_iomaps[map]->pi_grpid;
 
@@ -2097,8 +2107,6 @@ static int nw_xfer_io_prepare(struct nw_xfer_request *xfer)
 			 * number of spare units equal number of parity units.
 			 * In case of spare units, no IO is done.
 			 */
-			m0_bindex_t par_offset = 0;
-
 			for (unit = 0; unit < 2 * layout_k(play); ++unit) {
 
 				src.sa_unit = layout_n(play) + unit;
@@ -2115,7 +2123,6 @@ static int nw_xfer_io_prepare(struct nw_xfer_request *xfer)
 							layout_unit_size(play),
 							src.sa_unit,
 							req->ir_iomaps[map]);
-				par_offset += layout_unit_size(play);
 			}
 		}
 	}
@@ -2126,6 +2133,7 @@ err:
 		tioreqs_tlist_del(ti);
 		target_ioreq_fini(ti);
 		m0_free(ti);
+		++iommstats.d_target_ioreq_nr;
 		ti = NULL;
 	} m0_tl_endfor;
 
@@ -2299,7 +2307,7 @@ fail:
 
 static int io_request_init(struct io_request  *req,
 			   struct file	      *file,
-			   struct iovec	      *iov,
+			   const struct iovec *iov,
 			   struct m0_indexvec *ivec,
 			   enum io_req_type    rw)
 {
@@ -2362,13 +2370,13 @@ static void io_request_fini(struct io_request *req)
 
 	m0_tl_for (tioreqs, &req->ir_nwxfer.nxr_tioreqs, ti) {
 		   tioreqs_tlist_del(ti);
-		   /*
-		    * All io_req_fop structures in list target_ioreq::ti_iofops
-		    * are already finalized in nw_xfer_req_complete().
-		    */
-		   target_ioreq_fini(ti);
-		   m0_free(ti);
-		   ++iommstats.d_target_ioreq_nr;
+		/*
+		 * All io_req_fop structures in list target_ioreq::ti_iofops
+		 * are already finalized in nw_xfer_req_complete().
+		 */
+		target_ioreq_fini(ti);
+		m0_free(ti);
+		++iommstats.d_target_ioreq_nr;
 	} m0_tl_endfor;
 
 	nw_xfer_request_fini(&req->ir_nwxfer);
@@ -2393,10 +2401,10 @@ static void data_buf_fini(struct data_buf *buf)
 	buf->db_flags = PA_NONE;
 }
 
-static int nw_xfer_tioreq_map(struct nw_xfer_request	  *xfer,
-			      struct m0_pdclust_src_addr  *src,
-			      struct m0_pdclust_tgt_addr  *tgt,
-			      struct target_ioreq	 **out)
+static int nw_xfer_tioreq_map(struct nw_xfer_request	       *xfer,
+			      const struct m0_pdclust_src_addr *src,
+			      struct m0_pdclust_tgt_addr       *tgt,
+			      struct target_ioreq	      **out)
 {
 	int			  rc;
 	struct m0_fid		  tfid;
@@ -2417,6 +2425,11 @@ static int nw_xfer_tioreq_map(struct nw_xfer_request	  *xfer,
 	tfid	= target_fid(req, tgt);
 	session = target_session(req, tfid);
 
+	M0_LOG(M0_DEBUG, "[%llu:%llu] -> [%llu:%llu] @ tfid [%llu:%llu]",
+			 src->sa_group, src->sa_unit,
+			 tgt->ta_frame, tgt->ta_obj,
+			 tfid.f_container, tfid.f_key);
+
 	rc = nw_xfer_tioreq_get(xfer, &tfid, session,
 				layout_unit_size(play) * req->ir_iomap_nr,
 				out);
@@ -2431,8 +2444,8 @@ static int target_ioreq_init(struct target_ioreq    *ti,
 {
 	int rc;
 
-	M0_ENTRY("target_ioreq %p, nw_xfer_request %p, fid %p",
-		 ti, xfer, cobfid);
+	M0_ENTRY("target_ioreq %p, nw_xfer_request %p, fid [%llu:%llu]",
+		 ti, xfer, cobfid->f_container, cobfid->f_key);
 	M0_PRE(ti      != NULL);
 	M0_PRE(xfer    != NULL);
 	M0_PRE(cobfid  != NULL);
@@ -2451,18 +2464,12 @@ static int target_ioreq_init(struct target_ioreq    *ti,
 	tioreqs_tlink_init(ti);
 	target_ioreq_bob_init(ti);
 
-	ti->ti_bufvec.ov_vec.v_nr = page_nr(size);
-
 	rc = m0_indexvec_alloc(&ti->ti_ivec, page_nr(size),
 			       &m0t1fs_addb, &io_addb_loc);
 	if (rc != 0)
-		goto fail;
-	/*
-	 * This value is incremented when new segments are added to the
-	 * index vector.
-	 */
-	ti->ti_ivec.iv_vec.v_nr = 0;
+		goto out;
 
+	ti->ti_bufvec.ov_vec.v_nr = page_nr(size);
 	M0_ALLOC_ARR_ADDB(ti->ti_bufvec.ov_vec.v_count,
 			  ti->ti_bufvec.ov_vec.v_nr, &m0t1fs_addb,
 			  &io_addb_loc);
@@ -2479,13 +2486,19 @@ static int target_ioreq_init(struct target_ioreq    *ti,
 	if (ti->ti_pageattrs == NULL)
 		goto fail;
 
+	/*
+	 * This value is incremented when new segments are added to the
+	 * index vector in target_ioreq_seg_add().
+	 */
+	ti->ti_ivec.iv_vec.v_nr = 0;
+
 	M0_POST(target_ioreq_invariant(ti));
 	M0_RETURN(0);
 fail:
 	m0_indexvec_free(&ti->ti_ivec);
 	m0_free(ti->ti_bufvec.ov_vec.v_count);
 	m0_free(ti->ti_bufvec.ov_buf);
-
+out:
 	M0_RETERR(-ENOMEM, "Failed to allocate memory in target_ioreq_init");
 }
 
@@ -2543,11 +2556,12 @@ static int nw_xfer_tioreq_get(struct nw_xfer_request *xfer,
 	int		     rc = 0;
 	struct target_ioreq *ti;
 
-	M0_ENTRY("nw_xfer_request %p, fid %p", xfer, fid);
 	M0_PRE(nw_xfer_request_invariant(xfer));
 	M0_PRE(fid     != NULL);
 	M0_PRE(session != NULL);
 	M0_PRE(out     != NULL);
+	M0_ENTRY("nw_xfer_request %p, fid [%llu:%llu]",
+			xfer, fid->f_container, fid->f_key);
 
 	ti = target_ioreq_locate(xfer, fid);
 	if (ti == NULL) {
@@ -2556,16 +2570,16 @@ static int nw_xfer_tioreq_get(struct nw_xfer_request *xfer,
 			M0_RETERR(-ENOMEM, "Failed to allocate memory"
 				  "for target_ioreq");
 
-		++iommstats.a_target_ioreq_nr;
 		rc = target_ioreq_init(ti, xfer, fid, session, size);
 		if (rc == 0) {
 			tioreqs_tlist_add(&xfer->nxr_tioreqs, ti);
-			M0_LOG(M0_INFO, "New target_ioreq added for fid\
-					%llu:%llu", fid->f_container,
+			M0_LOG(M0_INFO, "New target_ioreq added for fid "
+					"%llu:%llu", fid->f_container,
 					fid->f_key);
 		}
 		else
 			m0_free(ti);
+		++iommstats.a_target_ioreq_nr;
 	}
 	*out = ti;
 	M0_RETURN(rc);
@@ -2643,8 +2657,8 @@ static void target_ioreq_seg_add(struct target_ioreq *ti,
 	struct m0_pdclust_layout  *play;
 	enum m0_pdclust_unit_type  unit_type;
 
-	M0_ENTRY("target_ioreq %p, gob_offset %llu, count %llu",
-		 ti, gob_offset, count);
+	M0_ENTRY("tio req %p, gob_offset %llu, count %llu frame %llu unit %llu",
+		 ti, gob_offset, count, frame, unit);
 	M0_PRE(target_ioreq_invariant(ti));
 	M0_PRE(map != NULL);
 
@@ -2687,8 +2701,8 @@ static void target_ioreq_seg_add(struct target_ioreq *ti,
 		ti->ti_bufvec.ov_buf[seg]  = buf->db_buf.b_addr;
 		ti->ti_pageattrs[seg] |= buf->db_flags;
 
-		M0_LOG(M0_INFO, "Seg id %d [%llu, %llu] added to target_ioreq"
-		       "with fid %llu:%llu with flags %d", seg,
+		M0_LOG(M0_INFO, "Seg id %d [%llu, %llu] added to target_ioreq "
+		       "with fid %llu:%llu with flags 0x%x", seg,
 		       INDEX(&ti->ti_ivec, seg), COUNT(&ti->ti_ivec, seg),
 		       ti->ti_fid.f_container, ti->ti_fid.f_key,
 		       ti->ti_pageattrs[seg]);
@@ -2795,7 +2809,7 @@ M0_INTERNAL ssize_t m0t1fs_aio(struct kiocb *kcb,
 		M0_RETERR(-ENOMEM, "Failed to allocate memory for io_request");
 	++iommstats.a_ioreq_nr;
 
-	rc = io_request_init(req, kcb->ki_filp, (struct iovec *)iov, ivec, rw);
+	rc = io_request_init(req, kcb->ki_filp, iov, ivec, rw);
 	if (rc != 0) {
 		count = 0;
 		goto last;
@@ -2882,7 +2896,7 @@ static ssize_t file_aio_write(struct kiocb	 *kcb,
 	size_t		    saved_count;
 	struct m0_indexvec *ivec;
 
-	M0_ENTRY("struct iovec %p position %llu", iov, pos);
+	M0_ENTRY("struct iovec %p position %llu seg_nr %lu", iov, pos, seg_nr);
 	M0_PRE(kcb != NULL);
 	M0_PRE(iov != NULL);
 	M0_PRE(seg_nr > 0);
@@ -2914,7 +2928,8 @@ static ssize_t file_aio_write(struct kiocb	 *kcb,
 		return 0;
 	}
 
-	M0_LOG(M0_INFO, "Write vec-count = %llu", m0_vec_count(&ivec->iv_vec));
+	M0_LOG(M0_INFO, "Write vec-count = %llu seg_nr %lu",
+			m0_vec_count(&ivec->iv_vec), seg_nr);
 	count = m0t1fs_aio(kcb, iov, ivec, IRT_WRITE);
 
 	/* Updates file position. */
@@ -3070,6 +3085,8 @@ static void io_rpc_item_cb(struct m0_rpc_item *item)
 	ioreq  = bob_of(reqfop->irf_tioreq->ti_nwxfer, struct io_request,
 			ir_nwxfer, &ioreq_bobtype);
 
+	M0_LOG(M0_INFO, "io_req_fop %p, target_ioreq %p io_request %p",
+			reqfop, reqfop->irf_tioreq, ioreq);
 	m0_sm_ast_post(ioreq->ir_sm.sm_grp, &reqfop->irf_ast);
 	M0_LEAVE();
 }
@@ -3173,6 +3190,7 @@ static int nw_xfer_req_dispatch(struct nw_xfer_request *xfer)
 	struct io_req_fop   *irfop;
 	struct io_request   *req;
 	struct target_ioreq *ti;
+	M0_ENTRY();
 
 	M0_PRE(xfer != NULL);
 	req = bob_of(xfer, struct io_request, ir_nwxfer, &ioreq_bobtype);
@@ -3326,7 +3344,7 @@ static int target_ioreq_iofops_prepare(struct target_ioreq *ti,
 	struct m0_pool_version_numbers  curr;
 	struct m0_pool_version_numbers *cli;
 
-	M0_ENTRY("target_ioreq %p", ti);
+	M0_ENTRY("prepare io fops for target ioreq %p filter 0x%x", ti, filter);
 	M0_PRE(target_ioreq_invariant(ti));
 	M0_PRE(M0_IN(filter, (PA_DATA, PA_PARITY)));
 
diff --git a/m0t1fs/linux_kernel/file_internal.h b/m0t1fs/linux_kernel/file_internal.h
index e467de4..3b00bdc 100644
--- a/m0t1fs/linux_kernel/file_internal.h
+++ b/m0t1fs/linux_kernel/file_internal.h
@@ -734,10 +734,10 @@ struct nw_xfer_ops {
 	 * @param out  Out parameter containing target_ioreq object.
 	 * @pre   nw_xfer_request_invariant(xfer).
          */
-        int  (*nxo_tioreq_map) (struct nw_xfer_request      *xfer,
-                                struct m0_pdclust_src_addr  *src,
-                                struct m0_pdclust_tgt_addr  *tgt,
-                                struct target_ioreq        **out);
+        int  (*nxo_tioreq_map) (struct nw_xfer_request           *xfer,
+                                const struct m0_pdclust_src_addr *src,
+                                struct m0_pdclust_tgt_addr       *tgt,
+                                struct target_ioreq             **out);
 };
 
 /**
@@ -886,7 +886,7 @@ struct io_request {
          * It is used as is since using a new structure would require
          * conversion.
          */
-        struct iovec                *ir_iovec;
+        const struct iovec          *ir_iovec;
 
         /** Async state machine to handle state transitions and callbacks. */
         struct m0_sm                 ir_sm;
diff --git a/m0t1fs/linux_kernel/m0t1fs.h b/m0t1fs/linux_kernel/m0t1fs.h
index 5610f4e..d07f14b 100644
--- a/m0t1fs/linux_kernel/m0t1fs.h
+++ b/m0t1fs/linux_kernel/m0t1fs.h
@@ -673,7 +673,11 @@ M0_INTERNAL int m0t1fs_inode_layout_init(struct m0t1fs_inode *ci);
 
 M0_INTERNAL struct m0_fid m0t1fs_ios_cob_fid(const struct m0t1fs_inode *ci,
 					     int index);
-
+/**
+ * I/O mem stats.
+ * Prefix "a_" stands for "allocate".
+ * Prefix "d_" stands for "de-allocate".
+ */
 struct io_mem_stats {
 	uint64_t a_ioreq_nr;
 	uint64_t d_ioreq_nr;
diff --git a/m0t1fs/linux_kernel/st/m0t1fs_common_inc.sh b/m0t1fs/linux_kernel/st/m0t1fs_common_inc.sh
index 450096f..3d1a6d8 100644
--- a/m0t1fs/linux_kernel/st/m0t1fs_common_inc.sh
+++ b/m0t1fs/linux_kernel/st/m0t1fs_common_inc.sh
@@ -19,9 +19,14 @@ MERO_M0T1FS_TEST_DIR=/tmp/test_m0t1fs_$$
 #MERO_M0T1FS_TEST_DIR=/tmp/test_m0t1fs
 MERO_MODULE=m0mero
 
+
+# kernel space tracing parameters
 MERO_MODULE_TRACE_MASK='!all'
 MERO_TRACE_PRINT_CONTEXT=short
 MERO_TRACE_LEVEL=call+
+
+
+#user-space tracing parameters
 export M0_TRACE_IMMEDIATE_MASK='!all' # put your subsystem here
 #export M0_TRACE_LEVEL=debug+
 export M0_TRACE_PRINT_CONTEXT=short
diff --git a/m0t1fs/linux_kernel/super.c b/m0t1fs/linux_kernel/super.c
index 6ff48ac..3fc1b61 100644
--- a/m0t1fs/linux_kernel/super.c
+++ b/m0t1fs/linux_kernel/super.c
@@ -172,6 +172,7 @@ static int m0t1fs_statfs(struct dentry *dentry, struct kstatfs *buf)
 	struct super_block *sb = dentry->d_sb;
 	struct m0t1fs_sb   *csb = M0T1FS_SB(sb);
 	int                 rc;
+	M0_ENTRY();
 
 	m0t1fs_fs_lock(csb);
 	rc = m0t1fs_mds_statfs(csb, &rep);
@@ -187,7 +188,7 @@ static int m0t1fs_statfs(struct dentry *dentry, struct kstatfs *buf)
 	buf->f_ffree = rep->f_ffree;
 	buf->f_namelen = rep->f_namelen;
 	m0t1fs_fs_unlock(csb);
-	return 0;
+	M0_RETURN(0);
 }
 
 static int fs_params_parse(struct m0t1fs_mnt_opts *dest, const char **src);
@@ -1187,7 +1188,7 @@ m0t1fs_container_id_to_session(const struct m0t1fs_sb *csb,
 	ctx = csb->csb_cl_map.clm_map[container_id];
 	M0_ASSERT(ctx != NULL);
 
-	M0_LEAVE("session: %p", &ctx->sc_session);
+	M0_LEAVE("id %llu -> session: %p", container_id, &ctx->sc_session);
 	return &ctx->sc_session;
 }
 
-- 
1.8.3.2

