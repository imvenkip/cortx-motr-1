From f79228df40ef5578408fdb821bcf8313bc76551e Mon Sep 17 00:00:00 2001
From: Nachiket Sahasrabuddhe <nachiket_sahasrabuddhe@xyratex.com>
Date: Mon, 7 Oct 2013 13:09:13 +0530
Subject: [PATCH 34/50] bigmemalloc.mf

-Removed leaves_beneath added within path_element.
-Introduced it as a separate element.
---
 lib/varr.c         | 84 +++++++++++++++++++-----------------------------------
 lib/varr.h         | 33 +++++++++------------
 lib/varr_private.h | 37 ++++++++++++++++++++++--
 3 files changed, 78 insertions(+), 76 deletions(-)

diff --git a/lib/varr.c b/lib/varr.c
index ac69cf0..dbad89a 100644
--- a/lib/varr.c
+++ b/lib/varr.c
@@ -60,7 +60,7 @@ M0_INTERNAL uint32_t children_of_level(const struct m0_varr *arr,
 				       uint32_t level);
 /* Updates the total number of leaf nodes touched upon by the cursor
  * iterator. */
-M0_INTERNAL void completed_leaves_cnt_update(struct m0_varr_cursor *cursor,
+M0_INTERNAL void completed_leaves_update(struct m0_varr_cursor *cursor,
 					     uint32_t inc);
 /* Fetches address of an object with index 'index' within the array. Returns
  * 'true' when address is present in the cache. Returns 'false' otherwise. */
@@ -258,33 +258,18 @@ M0_INTERNAL int m0_varr_cursor_init(struct m0_varr_cursor *cursor,
 	pe->vp_idx	      = 0;
 	pe->vp_buf	      = (void *)arr->va_tree;
 	pe->vp_width	      = 1;
-	/* Max. number of leaves at level 'depth'. */
-	pe->vp_leaves_beneath =
-		safe_bitshift((uint32_t)1, arr->va_bufptr_nr_shift *
-			      (depth - 1) + VA_TNODE_NR, <<);
 
 	while (cursor->vc_depth < depth) {
 		buf = pe->vp_buf;
 		if (buf != NULL) {
 			++pe;
 			++cursor->vc_depth;
-			pe->vp_buf = (void *)(*buf);
-			pe->vp_idx = 0;
-			pe->vp_width = children_of_level(arr,
-							 cursor->vc_depth);
-			/* No. of leaf 'objects' beneath the current node
-			 * assuming a complete tree of depth 'depth'.
-			 * For depth == arr->va_depth, these 'objects' are user
-			 * objects, otherwise these objects are
-			 * buffer-pointers.
-			 * When cursor->vc_depth == depth, then a node has
-			 * a tree of depth zero beneath and hence has total
-			 * leaf 'objects' radix^0. */
-			pe->vp_leaves_beneath = cursor->vc_depth == depth ? 1 :
-				safe_bitshift((uint32_t)1,
-					      arr->va_bufptr_nr_shift *
-					      (depth - cursor->vc_depth - 1),
-					      <<);
+			pe->vp_buf   = (void *)(*buf);
+			pe->vp_idx   = 0;
+			pe->vp_width = safe_bitshift((uint32_t)1,
+						     log_radix(arr,
+							       cursor->vc_depth),
+						     <<)
 		}
 		else
 			return -EINVAL;
@@ -292,23 +277,17 @@ M0_INTERNAL int m0_varr_cursor_init(struct m0_varr_cursor *cursor,
 	return 0;
 }
 
-M0_INTERNAL uint32_t children_of_level(const struct m0_varr *arr,
-				       uint32_t level)
+M0_INTERNAL uint8_t log_radix(const struct m0_varr *arr, uint32_t level)
 {
-	uint32_t bit_shift;
-
 	M0_PRE(arr != NULL);
 	M0_PRE(level <= arr->va_depth);
 
 	if (level <= 1)
-		return level == 1 ? VA_TNODE_NR : 1;
-	else {
-		bit_shift = level == arr->va_depth ?
+		return level == 1 ? VA_TNODE_NR_SHIFT : 0;
+	else
+		return level == arr->va_depth ?
 			arr->va_buf_shift - arr->va_obj_shift :
 			arr->va_buf_shift - arr->va_bufptr_nr_shift;
-
-		return safe_bitshift((uint32_t)1, bit_shift, <<);
-	}
 }
 
 M0_INTERNAL void* m0_varr_cursor_get(const struct m0_varr_cursor *cursor)
@@ -337,32 +316,29 @@ M0_INTERNAL int m0_varr_cursor_move(struct m0_varr_cursor *cursor,
 
 	switch (cursor->vc_trav) {
 	case ITERATE:
-		leaves_beneath_shift = 1;
+		leaves_beneath_shift = 0;
 		while (d > 0 &&
-		       !within_tree_width(cursor->arr,
+		       !within_tree_width(cursor->arr, pe->vp_idx +
 					  safe_bitshift(inc,
 						        leaves_beneath_shift,
-							>>))
-		       pe->vp_leaves_beneath *
-		       (pe->vp_width - pe->vp_idx - 1) < inc ||
-		       cursor->vc_done >= cursor->arr->va_nr) {
-			leaves_beneath_shift = children_of_level(cursor->arr, d);
+							>>))) {
+			leaves_beneath_shift += log_radix(cursor->arr, d);
+			/*TODO*/
+			if (d == cursor->vc_depth)
+				completed_leaves_update(cursor, inc);
 			--d;
 			--pe;
-			if (d == cursor->vc_depth)
-				completed_leaves_cnt_update(cursor, inc);
 		}
 		if (d > 0) {
 			while (d <= cursor->vc_depth && inc > 0) {
-				while (inc >= pe->vp_leaves_beneath) {
-					++pe->vp_idx;
-					++pe->vp_buf;
-					inc -= pe->vp_leaves_beneath;
-					if (d == cursor->vc_depth)
-						completed_leaves_cnt_update(cursor,
-									    inc);
-				}
-				if (d != cursor->vc_depth) {
+				inc = safe_bitshift(inc, leaves_beneath_shift,
+						    >>);
+				pe->vp_idx += inc;
+				pe->vp_buf += inc;
+				if (d == cursor->vc_depth)
+					completed_leaves_update(cursor,
+								inc);
+				else {
 					++d;
 					buf = (unsigned long *)pe->vp_buf;
 					pe->vp_buf = (void *)(*buf);
@@ -375,13 +351,12 @@ M0_INTERNAL int m0_varr_cursor_move(struct m0_varr_cursor *cursor,
 		} else
 			goto end;
 		break;
-
 	case PRE_ORDER:
 		for (;d > 0 && !within_tree_width(cursor, d,
 						  pe->vp_idx + 1);
 		     --pe, --d) {
 			if (d == cursor->vc_arr->va_depth - 1)
-				completed_leaves_cnt_update(cursor, 1);
+				completed_leaves_update(cursor, 1);
 		}
 
 		if (d > 0) {
@@ -398,14 +373,13 @@ M0_INTERNAL int m0_varr_cursor_move(struct m0_varr_cursor *cursor,
 				++pe->vp_buf;
 				cursor->vc_depth = d;
 				if (d == cursor->vc_arr->va_depth - 1)
-					completed_leaves_cnt_update(cursor,
+					completed_leaves_update(cursor,
 								    1);
 			}
 			goto next;
 		} else
 			goto end;
 		break;
-
 	case POST_ORDER:
 		if (d == cursor->vc_arr->va_depth)
 			++cursor->vc_done;
@@ -438,7 +412,7 @@ M0_INTERNAL bool within_tree_width(const struct m0_varr_cursor *cursor,
 		cursor->vc_done < cursor->vc_arr->va_nr;
 }
 
-M0_INTERNAL void completed_leaves_cnt_update(struct m0_varr_cursor *cursor,
+M0_INTERNAL void completed_leaves_update(struct m0_varr_cursor *cursor,
 					     uint32_t inc)
 {
 	M0_PRE(cursor != NULL);
diff --git a/lib/varr.h b/lib/varr.h
index 1efa317..14001f1 100644
--- a/lib/varr.h
+++ b/lib/varr.h
@@ -75,33 +75,33 @@
  *
  * @endcode
  */
-
 struct m0_varr;
 
 enum {
 	/* Number of nodes which originate from root of radix tree. */
-	VA_TNODE_NR = 64,
+	VA_TNODE_NR	  = 64,
 
 	/* Size of pointer to a tree node. */
-	VA_TNODEPTR_SIZE = sizeof(void *),
+	VA_TNODEPTR_SIZE  = sizeof(void *),
 
 	VA_TNODE_NR_SHIFT = 6,
+	VA_DEPTH_MAX	  = 16,
 };
 
 struct m0_varr {
 	/** Number of elements in array. */
-	uint64_t          va_nr;
+	uint64_t              va_nr;
 
 	/** Log of object-size to the base two. */
-	uint8_t           va_obj_shift;
+	uint8_t               va_obj_shift;
 
 	/** Size of buffer which is used to store objects from array. */
-	size_t		  va_bufsize;
+	size_t		      va_bufsize;
 	/** Log of va_bufsize to the base 2. */
-	uint8_t           va_buf_shift;
+	uint8_t               va_buf_shift;
 
 	/** Level depth of tree proportional to number of objects stored. */
-	uint32_t          va_depth;
+	uint32_t              va_depth;
 
 	/**
 	 * Number of pointer to buffer that can be accommodated in one
@@ -112,8 +112,8 @@ struct m0_varr {
 	 * significant and _exactly same_ compute operations which can be
 	 * easily avoided by maintaining it as a member.
 	 */
-	uint64_t	   va_bufptr_nr;
-	uint8_t            va_bufptr_nr_shift;
+	uint64_t	      va_bufptr_nr;
+	uint8_t               va_bufptr_nr_shift;
 
 	/**
 	 * Array of radix tree nodes, each of which represents an abstraction
@@ -123,20 +123,15 @@ struct m0_varr {
 	 * Such arrangement provisions constant height radix tree which eases
 	 * up the lookups.
 	 */
-	void              *va_tree[VA_TNODE_NR];
-
-	/**
-	 * maintains backlink to parents in a tree traversal.
-	 */
-	struct varr_stack *va_stack;
-
+	void                 *va_tree[VA_TNODE_NR];
+	
 	/**
 	 * Holds address of buffer holding recently accessed object.
 	 */
-	struct varr_cache *va_cache;
+	struct m0_varr_cache *va_cache;
 
 	/** Magic field to cross check sanity of structure. */
-	uint64_t           va_magic;
+	uint64_t              va_magic;
 };
 
 /**
diff --git a/lib/varr_private.h b/lib/varr_private.h
index 58eadf1..dbb0429 100644
--- a/lib/varr_private.h
+++ b/lib/varr_private.h
@@ -23,9 +23,42 @@
 #ifndef __MERO_LIB_VIRTUAL_ARRAY_PRIVATE_H__
 #define __MERO_LIB_VIRTUAL_ARRAY_PRIVATE_H__
 
+enum m0_varr_cursor_trav {
+	ITERATE,
+	PRE_ORDER,
+	POST_ORDER,
+};
+
+struct m0_varr_path_element {
+	uint32_t  vp_idx;
+	uint32_t  vp_width;
+	void	 *vp_buf;
+};
+
+struct m0_varr_cursor {
+	struct m0_varr		    *vc_arr;
+	uint32_t		     vc_depth;
+	uint64_t		     vc_done;
+	struct m0_varr_path_element  vc_path[VA_DEPTH_MAX];
+	enum m0_varr_cursor_trav     vc_trav;
+};
+
+/* Cache that holds pointer to recently accessed buffer along with range of
+ * objects that reside in it.
+ */
+struct m0_varr_cache {
+	unsigned long *vc_buff;
+	uint64_t       vc_first_index;
+	uint64_t       vc_last_index;
+};
+
 M0_EXTERN void *m0_varr_buf_alloc(size_t bufsize);
 M0_EXTERN void  m0_varr_buf_free(void *buf, size_t bufsize);
 M0_EXTERN bool  m0_varr_size_is_valid(const struct m0_varr *arr);
-
-struct varr_cache;
+M0_INTERNAL int m0_varr_cursor_init(struct m0_varr_cursor *cursor,
+				    const struct m0_varr *arr, uint32_t depth,
+				    enum m0_varr_cursor_trav traversal);
+M0_INTERNAL void* m0_varr_cursor_get(const struct m0_varr_cursor *cursor);
+M0_INTERNAL int m0_varr_cursor_next(struct m0_varr_cursor *cursor);
+M0_INTERNAL int m0_varr_cursor_move(struct m0_varr_cursor *cursor, uint32_t inc);
 #endif /* __MERO_LIB_VIRTUAL_ARRAY_PRIVATE_H__ */
-- 
1.8.3.2

