From fc7b7c8f362fab092dbc5743cf5706fcea69a394 Mon Sep 17 00:00:00 2001
From: Nachiket Sahasrabuddhe <nachiket_sahasrabuddhe@xyratex.com>
Date: Tue, 29 Oct 2013 13:56:08 +0530
Subject: [PATCH 44/50] bigmemalloc.mf -Basic UT runs with this code, though UT
 is not part of this commit. -Modifications include: a. m0_varr_iter()        
                 b. cache_update()

---
 lib/varr.c | 27 +++++++++++++++++----------
 lib/varr.h |  6 ++++--
 2 files changed, 21 insertions(+), 12 deletions(-)

diff --git a/lib/varr.c b/lib/varr.c
index f199786..c4c611e 100644
--- a/lib/varr.c
+++ b/lib/varr.c
@@ -308,9 +308,15 @@ M0_INTERNAL uint32_t children_of_level(const struct m0_varr *arr,
 
 M0_INTERNAL void* m0_varr_cursor_get(struct m0_varr_cursor *cursor)
 {
+	M0_PRE(cursor != NULL);
 	return cursor->vc_path[cursor->vc_depth].vp_buf;
 }
 
+M0_INTERNAL void m0_varr_cursor_set(struct m0_varr_cursor *cursor, void *addr)
+{
+	M0_PRE(cursor != NULL);
+	cursor->vc_path[cursor->vc_depth].vp_buf = addr;
+}
 M0_INTERNAL int m0_varr_cursor_next(struct m0_varr_cursor *cursor)
 {
 	return m0_varr_cursor_move(cursor, 1);
@@ -401,7 +407,8 @@ M0_INTERNAL int m0_varr_cursor_move(struct m0_varr_cursor *cursor,
 		if (d == cursor->vc_arr->va_depth - 1)
 			completed_leaves_update(cursor, d, 1);
 		if (within_tree_width(cursor, d, pe->vp_idx + 1) &&
-		    buff_incr(cursor->vc_arr, d, pe->vp_buf, 1) != NULL) {
+		    *(void **)buff_incr(cursor->vc_arr, d, pe->vp_buf, 1)
+		    != NULL) {
 			++pe->vp_idx;
 			pe->vp_buf = buff_incr(cursor->vc_arr, d, pe->vp_buf,
 					       1);
@@ -523,7 +530,7 @@ M0_INTERNAL uint64_t max_buff_nr_till_lev_n_pn(const struct m0_varr *arr,
 M0_INTERNAL void *buff_incr(const struct m0_varr *arr, uint32_t depth,
 			    void *buff, uint32_t incr)
 {
-	size_t   inc_unit;
+	size_t inc_unit;
 
 	M0_PRE(arr != NULL && buff != NULL);
 
@@ -539,17 +546,17 @@ M0_INTERNAL void varr_buffers_dealloc(struct m0_varr *arr)
 {
 	struct m0_varr_cursor cursor;
 	int		      rc;
-	unsigned long	      holder;
+	void		     *holder;
 
 	rc = m0_varr_cursor_init(&cursor, arr, DEALLOC);
 	M0_ASSERT(rc == 0);
 	do {
-		holder = *(unsigned long *)m0_varr_cursor_get(&cursor);
+		holder = *(void **)m0_varr_cursor_get(&cursor);
 		/* This condition will fail when varr_buffers_alloc() has got
 		 * terminated intermittently. */
-		if ((void *)holder != NULL)
-			m0_varr_buf_free((void *)holder,
-					 arr->va_bufsize);
+		if ((void *)holder != NULL) {
+			m0_varr_buf_free(holder, arr->va_bufsize);
+		}
 	} while (m0_varr_cursor_next(&cursor));
 }
 
@@ -584,7 +591,7 @@ M0_INTERNAL void *m0_varr_ele_get(struct m0_varr *arr, uint64_t index)
 	if (cache_fetch(arr, index, &holder))
 		goto end;
 	holder = (void *)arr->va_tree;
-	for (level = 1; level <= arr->va_depth - 1; ++level) {
+	for (level = 1; level < arr->va_depth; ++level) {
 
 		holder =  buff_incr(arr, level, holder,
 				    index_within_level((const struct m0_varr *)
@@ -618,7 +625,7 @@ M0_INTERNAL void cache_update(struct m0_varr *arr, void *holder,
 	uint64_t index_in_level;
 
 	M0_PRE(arr != NULL);
-	M0_PRE(index <= arr->va_nr - 1);
+	M0_PRE(index < arr->va_nr);
 
 	index_in_level = index_within_level((const struct m0_varr *)arr,
 					    index, arr->va_depth);
@@ -628,7 +635,7 @@ M0_INTERNAL void cache_update(struct m0_varr *arr, void *holder,
 					      safe_bitshift((uint64_t)1,
 							    arr->va_buf_shift -
 							    arr->va_obj_shift,
-							    <<),
+							    <<) - 1,
 					      arr->va_nr - 1);
 }
 
diff --git a/lib/varr.h b/lib/varr.h
index 54bcafd..c889869 100644
--- a/lib/varr.h
+++ b/lib/varr.h
@@ -206,6 +206,7 @@ M0_INTERNAL int m0_varr_cursor_init(struct m0_varr_cursor *cursor,
  * Returns a pointer corresponding to the current location of a cursor.
  */
 M0_INTERNAL void* m0_varr_cursor_get(struct m0_varr_cursor *cursor);
+M0_INTERNAL void m0_varr_cursor_set(struct m0_varr_cursor *cursor, void *addr);
 M0_INTERNAL int m0_varr_cursor_next(struct m0_varr_cursor *cursor);
 M0_INTERNAL int m0_varr_cursor_move(struct m0_varr_cursor *cursor, uint32_t inc);
 
@@ -227,8 +228,9 @@ M0_INTERNAL int m0_varr_cursor_move(struct m0_varr_cursor *cursor, uint32_t inc)
 	 rc = m0_varr_cursor_init(&cursor, __arr, ITERATE);		\
 	 M0_ASSERT(rc == 0);						\
 	 m0_varr_cursor_move(&cursor, idx);				\
-	 for (obj = m0_varr_cursor_get(&cursor);idx < end;		\
-	      idx += __inc, m0_varr_cursor_move(&cursor, __inc)) {	\
+	 for (obj = m0_varr_cursor_get(&cursor); idx < __end;		\
+	      idx += __inc, m0_varr_cursor_move(&cursor, __inc),        \
+	      obj = m0_varr_cursor_get(&cursor)) {			\
 
 #define m0_varr_end_iter } } )
 
-- 
1.8.3.2

