From 3b4da19cf0c2af40824ba404e868d864ff815285 Mon Sep 17 00:00:00 2001
From: Nachiket Sahasrabuddhe <nachiket_sahasrabuddhe@xyratex.com>
Date: Tue, 27 Aug 2013 13:53:17 +0530
Subject: [PATCH 17/50] bigmemalloc.mf

1. Same code for alloc and dealloc has been used. The key corner case
   of freeing last element from buffer is still pending.
---
 lib/varr.c | 99 +++++++++-----------------------------------------------------
 1 file changed, 14 insertions(+), 85 deletions(-)

diff --git a/lib/varr.c b/lib/varr.c
index de61d17..de4ffde 100644
--- a/lib/varr.c
+++ b/lib/varr.c
@@ -282,88 +282,8 @@ static int buffers_helper(struct m0_varr     *arr,
 	return i == nr ? 0 : -ENOMEM;
 }
 
-/*
- * While deallocating buffers, the leaf node buffers are deallocated first
- * since during indexing these pages account for initial members of
- * virtual array.
- * The approach is centered towards maintaining a LIFO stack per iteration 
- * which will store parent of a given level while traversing from top down.
- * The whole approach is taken in order to implement tree traversal in an
- * iterative manner rather than using recursive functions.
- * This approach is a bit similar to inorder traversal of a tree but
- * not exactly the same.
- */
-static void varr_buffers_dealloc(struct m0_varr *arr,
-				 uint64_t        buff_nr)
-{
-	int            rc;
-	int            node;
-	uint32_t       level;
-	uint64_t       nr;
-	uint64_t       done;
-	uint64_t       buff_nr_pn;
-	unsigned long *holder;
-
-	M0_PRE(arr     != NULL);
-	M0_PRE(buff_nr  > 0);
-
-	for (done = 0, node = 0; node < VA_TNODE_NR && done < buff_nr;
-	     ++node) {
-		holder = arr->va_tree[node];
-		buff_nr_pn = min64u(max_buff_nr_till_lev_n_pn(arr, 1),
-				    buff_nr - done);
-		while (done < buff_nr_pn) {
-			for (level = 1; level <= arr->va_depth &&
-			     done < buff_nr_pn; ++level) {
-
-				nr = min64u(level != arr->va_depth ? 1 :
-					    arr->va_bufptr_nr,
-					    buff_nr_pn - done);
-				if (level != arr->va_depth) {
-					arr->va_stack[level - 1].ls_index  =
-						index_in_level_n_pn(arr, done,
-								    level);
-					holder += arr->va_stack[level - 1].
-						  ls_index;
-					arr->va_stack[level - 1].ls_parent =
-						holder;
-					holder = (unsigned long *)*holder;
-				}
-			}
-
-			/* Deallocates the leaf node buffer(s). */
-			rc = buffers_helper(arr, holder, nr, BA_DEALLOC);
-			M0_ASSERT(rc == 0);
-			done += nr;
-
-			/* If the stack was built, start popping the stack. */
-			for (level = arr->va_depth - 1;
-			     level >= 1 && arr->va_stack != NULL; --level) {
-
-				/*
-				 * Deallocates the holder buffer if all
-				 * buffers beneath this buffer in this trail
-				 * are already deallocated.
-				 */
-				if (min64u(buff_nr_pn,
-				    max_buff_nr_till_lev_n_pn(arr, level) *
-				    (arr->va_stack[level - 1].ls_index + 1)) ==
-				    done % max_buff_nr_till_lev_n_pn(arr, 1)) {
-					rc = buffers_helper(arr, arr->
-							    va_stack[level - 1].
-							    ls_parent, 1,
-							    BA_DEALLOC);
-					M0_ASSERT(rc == 0);
-				}
-				arr->va_stack[level - 1].ls_parent = NULL;
-				arr->va_stack[level - 1].ls_index  = 0;
-			}
-		}
-	}
-}
-
 /* Allocates buffers for given virtual array from level 0 to varr::va_depth. */
-static int varr_buffers_alloc(struct m0_varr    *arr,
+static int varr_buffers_manage(struct m0_varr    *arr,
 		uint64_t           buff_nr,
 		enum buffer_action op)
 {
@@ -382,7 +302,8 @@ static int varr_buffers_alloc(struct m0_varr    *arr,
 	 * of some meta-buffer.
 	 */
 	unsigned long *holder;
-	unsigned long ptr_inc;
+	unsigned long  ptr_inc;
+	unsigned long  last_ptr_inc;
 
 	M0_PRE(arr     != NULL);
 	M0_PRE(buff_nr  > 0);
@@ -414,7 +335,7 @@ static int varr_buffers_alloc(struct m0_varr    *arr,
 		while (done_pt < buff_nr_pn) {
 			holder = arr->va_tree[node];
 			for (level = 1; level <= arr->va_depth &&
-					done_pt < buff_nr_pn; ++level) {
+			     done_pt < buff_nr_pn; ++level) {
 
 				/*
 				 * For all levels except the last one,
@@ -443,9 +364,15 @@ static int varr_buffers_alloc(struct m0_varr    *arr,
 								op);
 					break;
 				case BA_DEALLOC:
-					if (ptr_inc > 0 && (uint64_t *)*(holder + ptr_inc -1)!= NULL )
+					if (ptr_inc > 0 && (uint64_t *)*(holder + ptr_inc -1)!= NULL ) {
+						if (level != arr->va_depth) {
+							last_child = (unsigned long *)*(holder + ptr_inc - 1);
+							last_child += last_ptr_inc;
+							rc = buffers_helper(arr, last_child, last_nr, op);
+						}
 						rc = buffers_helper(arr, holder + ptr_inc - 1, nr,
-								op);
+								    op);
+					}
 					holder += ptr_inc;
 					break;
 				}
@@ -457,6 +384,8 @@ static int varr_buffers_alloc(struct m0_varr    *arr,
 			/* We respect your privacy! */
 			if (level != arr->va_depth)
 				holder = (unsigned long *)*holder;
+			if (last_level > level)
+				last_ptr_inc = ptr_inc;
 		}
 
 		if (op == BA_DEALLOC) {
-- 
1.8.3.2

