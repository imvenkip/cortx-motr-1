From 852f4ac10a973c17ae6f3e42663e8e0a28b4bb43 Mon Sep 17 00:00:00 2001
From: Nachiket Sahasrabuddhe <nachiket_sahasrabuddhe@xyratex.com>
Date: Thu, 10 Oct 2013 17:26:37 +0530
Subject: [PATCH 37/50] bigmemalloc.mf

-m0_varr_cursor_move() updated for the case of ITERATE.
-Few issues in PRE-ORDER and POST-ORDER need to be resolved.
---
 lib/varr.c | 66 ++++++++++++++++++++++++++++++++++----------------------------
 1 file changed, 36 insertions(+), 30 deletions(-)

diff --git a/lib/varr.c b/lib/varr.c
index 990b055..49c6d60 100644
--- a/lib/varr.c
+++ b/lib/varr.c
@@ -89,9 +89,9 @@ M0_INTERNAL uint64_t last_nbits_set(uint8_t n);
 /* Increments buffer based upon its level in a tree */
 M0_INTERNAL void * buff_incr(struct m0_varr *arr, uint32_t depth,
 			     void *buff, uint32_t incr);
-M0_INTERNAL uint32_t next_id_update(const struct m0_varr_cursor *cursor,
-				    uint32_t d, uint32_t inc,
-				    uint32_t next_idx);
+M0_INTERNAL uint32_t next_id_update(uint32_t inc,
+				    uint32_t leaves_beneath_shift,
+				    uint32_t next_idx)
 /* Shifts a given number to left/right by taking into account sizeof(number) */
 #define safe_bitshift(num, shift, operator)				     \
 	({								     \
@@ -321,7 +321,6 @@ M0_INTERNAL int m0_varr_cursor_move(struct m0_varr_cursor *cursor,
 
 	pe = &cursor->vc_path[d];
 	next_idx = pe->vp_idx + inc;
-	idx_new  &= (pe->vp_width - 1);
 	switch (cursor->vc_trav) {
 	case ITERATE:
 		leaves_beneath_shift = 0;
@@ -344,22 +343,24 @@ M0_INTERNAL int m0_varr_cursor_move(struct m0_varr_cursor *cursor,
 		}
 
 		if (d > 0) {
-			do {
+			while (d <= cursor->vc_depth) {
 				inc     = safe_bitshift(next_idx,
 							leaves_beneath_shift,
 							>>);
 				pe->vp_buf = buff_incr(cursor->arr, d,
 						       pe->vp_buf, inc);
 				pe->vp_idx += inc;
-				next_idx = next_id_update(cursor, next_idx,
-							  inc, d);
-				if (d == cursor->vc_depth)
+				next_idx = next_id_update(inc,
+							  leaves_beneath_shift,
+							  next_idx);
+				if (d == cursor->vc_depth && inc > 0)
 					completed_leaves_update(cursor, d, inc);
 				else {
-					if (inc > 0)
+					/* To avoid unnecessary multiplication
+					 * zero. */
+					if (inc > 1)
 						completed_leaves_update(cursor,
-									d,
-									inc -
+									d, inc -
 									1);
 					buf = (unsigned long *)pe->vp_buf;
 					++pe;
@@ -369,7 +370,7 @@ M0_INTERNAL int m0_varr_cursor_move(struct m0_varr_cursor *cursor,
 						log_radix(cursor->arr, d);
 				}
 				++d;
-			} while (d < cursor->vc_done);
+			}
 			goto next;
 		} else
 			goto end;
@@ -384,6 +385,7 @@ M0_INTERNAL int m0_varr_cursor_move(struct m0_varr_cursor *cursor,
 		}
 
 		if (d > 0) {
+			/* Decide whether to descend or move horizontally. */
 			if (d == cursor->vc_depth &&
 			    d < cursor->vc_arr->va_depth - 1) {
 				buf = (unsigned long *)pe->vp_buf;
@@ -405,20 +407,21 @@ M0_INTERNAL int m0_varr_cursor_move(struct m0_varr_cursor *cursor,
 		break;
 
 	case POST_ORDER:
-		if (d == cursor->vc_arr->va_depth)
-			++cursor->vc_done;
-		if (within_tree_width(cursor, d,
-				      pe->vp_idx + 1)) {
-			++pe->vp_idx;
-			++pe->vp_buf;
-		} else {
-			--pe;
-			--d;
-			cursor->vc_depth = d;
+		for (;d > 0 && !within_tree_width(cursor, d,
+						  pe->vp_idx + 1);
+		     --pe, --d) {
+			if (d == cursor->vc_arr->va_depth - 1)
+				completed_leaves_update(cursor, d, 1);
 		}
-		if (d > 0)
+		if (d > 0) {
+			if (d == cursor->vc_depth &&
+			    within_tree_width(cursor, d, pe->vp_idx + 1)) {
+				++pe->idx;
+				pe->vp_buf = buf_incr(pe->vp_buf, 1);
+			} else
+				cursor->vc_depth = d;
 			goto next;
-		else
+		} else
 			goto end;
 		break;
 	}
@@ -440,8 +443,11 @@ M0_INTERNAL void completed_leaves_update(struct m0_varr_cursor *cursor,
 					 uint32_t depth, uint32_t inc)
 {
 	M0_PRE(cursor != NULL);
-	cursor->vc_done += inc * max_buff_nr_till_lev_n_pn(cursor->vc_arr,
-							   depth);
+	if (depth == cursor->arr->va_depth)
+		cursor->vc_done += inc;
+	else
+		cursor->vc_done += inc * varr_obj_nr_in_buff(cursor->vc_arr) *
+			max_buff_nr_till_lev_n_pn(cursor->vc_arr, depth);
 }
 
 /*
@@ -477,12 +483,12 @@ M0_INTERNAL void *buff_incr(struct m0_varr *arr, uint32_t depth,
 	return buff;
 }
 
-M0_INTERNAL uint32_t next_id_update(const struct m0_varr_cursor *cursor,
-				    uint32_t d, uint32_t inc,
+M0_INTERNAL uint32_t next_id_update(uint32_t inc,
+				    uint32_t leaves_beneath_shift,
 				    uint32_t next_idx)
 {
-	return next_idx - (inc * varr_obj_nr_in_buff(cursor->vc_arr) *
-			max_buff_nr_till_lev_n_pn(cursor->vc_arr, d));
+	return next_idx - inc * safe_bitshift((uint32_t)1, leaves_beneath_shift,
+					      <<);
 }
 
 M0_INTERNAL void varr_buffers_dealloc(struct m0_varr *arr, uint64_t buf_nr)
-- 
1.8.3.2

