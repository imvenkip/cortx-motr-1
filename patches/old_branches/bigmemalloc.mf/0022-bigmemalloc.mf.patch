From 13ec50c4e7660842391030cc42e32281ef1f4513 Mon Sep 17 00:00:00 2001
From: Nachiket Sahasrabuddhe <nachiket_sahasrabuddhe@xyratex.com>
Date: Sat, 7 Sep 2013 15:29:15 +0530
Subject: [PATCH 22/50] bigmemalloc.mf

---
 lib/linux_kernel/varr.c | 19 +++++++++----------
 lib/varr.c              | 42 +++++++++++++++++++++++++-----------------
 2 files changed, 34 insertions(+), 27 deletions(-)

diff --git a/lib/linux_kernel/varr.c b/lib/linux_kernel/varr.c
index 6205836..fda883f 100644
--- a/lib/linux_kernel/varr.c
+++ b/lib/linux_kernel/varr.c
@@ -25,27 +25,26 @@
 
 M0_EXTERN void *m0_varr_buf_alloc(int bufsize)
 {
-	if (bufsize == PAGE_CACHE_SIZE)
-		return (void *)get_zeroed_page(GFP_KERNEL);
-	else
-		return m0_alloc(bufsize);
+	M0_PRE(bufsize == PAGE_CACHE_SIZE);
+
+	return (void *)get_zeroed_page(GFP_KERNEL);
 }
 
-M0_EXTERN void m0_varr_buf_free(void *buf, int bufsize)
+M0_EXTERN void m0_varr_buf_free(void *buf)
 {
 	M0_PRE(buf != NULL);
 
-	if (bufsize == PAGE_CACHE_SIZE)
-		free_page((unsigned long)buf);
-	else
-		m0_free(buf);
+	free_page((unsigned long)buf);
 }
 
 M0_EXTERN bool m0_varr_size_is_valid(const struct m0_varr *arr)
 {
 	M0_PRE(arr != NULL);
 
-	return arr->va_obj_shift  <=  arr->va_buf_shift
+	return
+		arr->va_sizeof  <  arr->va_bufsize &&
+		arr->va_bufsize == PAGE_CACHE_SIZE &&
+		arr->va_bufsize %  arr->va_sizeof == 0;
 }
 
 /*
diff --git a/lib/varr.c b/lib/varr.c
index 1729853..372a6ed 100644
--- a/lib/varr.c
+++ b/lib/varr.c
@@ -49,13 +49,13 @@ M0_INTERNAL void m0_varr_fini(struct m0_varr *arr);
 M0_INTERNAL uint64_t cont_nr_for_objs(unsigned long nr,
 				      unsigned long obj_nr_in_1_cont);
 /* Shifts a given number to left/right by taking into account sizeof (number) */
-#define safe_bitshift(num, type, shift)					     \
+#define safe_bitshift(num, type, shifti, operator)			     \
 ({									     \
-	int   __shift = (shift);					     \
-	type  __num   = (num);						     \
-	(__shift >= 0 ? (__shift < 8 * sizeof __num ?			     \
-			 __num << __shift : 0 ) :			     \
-	 (0 - __shift) < 8 * sizeof __num ? __num >> (0 - __shift) : 0)	     \
+	uint8_t __shift = (shift);					     \
+	type    __num   = (num);					     \
+	M0_BASSERT(operator == "<<" || operator == ">>");		     \
+	M0_ASSERT(__shift < 8 * sizeof __num);				     \
+	operator == "<<" ? __num << __shift : __num >> __shift;		     \
  })
 /*
  * A LIFO stack which maintains the backlink to parent node as well as
@@ -136,7 +136,7 @@ M0_INTERNAL uint8_t nearest_power_of_two(size_t size)
 	uint8_t aligned_shift = 0;
 
 	while (size > aligned_size) {
-		safe_bitshift(aligned_size, size_t, 1);
+		safe_bitshift(aligned_size, size_t, 1, "<<");
 		++aligned_shift;
 	}
 	return aligned_shift;
@@ -150,7 +150,8 @@ M0_INTERNAL bool is_power_of_two(size_t size)
 /* Returns a 64-bit integer whose last n bits are set, rest are zero */
 M0_INTERNAL uint64_t last_nbits_set(uint8_t n)
 {
-	return n < 64 ? ~safe_bitshift(~(uint64_t)0, uint64_t, n) :
+	M0_PRE(n <= 64);
+	return n < 64 ? ~safe_bitshift(~(uint64_t)0, uint64_t, n, "<<") :
 		~(uint64_t)0;
 }
 
@@ -158,7 +159,7 @@ M0_INTERNAL unsigned long varr_obj_nr_in_buff(const struct m0_varr *arr)
 {
 	M0_PRE(arr != NULL);
 	return	safe_bitshift((unsigned long)1, unsigned long,
-			      (int)(arr->va_buf_shift - arr->va_obj_shift));
+			      (arr->va_buf_shift - arr->va_obj_shift), "<<");
 }
 
 M0_INTERNAL uint64_t cont_nr_for_objs(unsigned long nr,
@@ -217,8 +218,8 @@ M0_INTERNAL int m0_varr_init(struct m0_varr *arr,
 	arr->va_buf_shift       = nearest_power_of_two(bufsize);
 	arr->va_bufptr_nr_shift = arr->va_buf_shift -
 		neares_power_of_two(VA_TNODEPTR_SIZE);
-	arr->va_bufptr_nr       = safely_shift((uint64_t) 1,
-						arr->va_bufptr_nr_shift);
+	arr->va_bufptr_nr       = safe_bitshift((uint64_t) 1, uint64_t,
+						arr->va_bufptr_nr_shift, "<<");
 
 	/*
 	 * Since two successive buffs are not guaranteed to be contiguous,
@@ -286,14 +287,17 @@ M0_INTERNAL unsigned long *m0_varr_buffer(const struct m0_varr *arr,
 	obj_mask  = last_nbits_set(arr->va_obj_shift);
 	buff_mask = last_nbits_set(arr->va_buff_shift);
 	index_local = index;
-	index_local >>= arr->va_obj_shift + (arr->va_depth - 1) *
-		arr->va_buf_shift;
+	index_local = safe_bitshift(index_local, uint64_t,
+				    arr->va_obj_shift + (arr->va_depth - 1) *
+				    arr->va_buf_shift, ">>");
 	holder = arr->va_tree[index_local];
 	index_local = index;
 	for (level = 1; level <= arr->va_depth - 1; ++level,
 	     index_local = index) {
-		index_local >>= arr->va_obj_shif + (arr->va_depth - level) *
-			arr->va_buf_shift;
+		index_local = safe_bitshift(index_local, uint64_t,
+					    arr->va_obj_shif +
+					    (arr->va_depth - level) *
+					    arr->va_buf_shift, ">>");
 		index_local &= buff_mask;
 		holder += index;
 		/* Dereferences the buffer pointer at given offset. */
@@ -501,7 +505,9 @@ static uint64_t max_buff_nr_till_lev_n_pn(const struct m0_varr *arr,
 
 	/*return m0_pow(arr->va_bufsize / VA_TNODEPTR_SIZE,
 		      arr->va_depth - level);*/
-	return 1<<(arr->va_bufptr_nr_shift * (arr->va_depth - level));
+	return safe_bitshift((uint64_t)1, uint64_t, (arr->va_bufptr_nr_shift *
+						     (arr->va_depth - level)),
+			     "<<");
 }
 
 /*
@@ -536,7 +542,9 @@ M0_INTERNAL uint32_t level_find(const struct m0_varr *arr,
 	M0_PRE(pg   > 0);
 
 	for (level = 0; !found; ++level)
-		if (pg <= 1<<(arr->va_bufptr_nr_shift * level + VA_NODE_SHIFT))
+		if (pg <= safe_bitshift((uint32_t)1, uint32_t,
+					arr->va_bufptr_nr_shift*level +
+					VA_NODE_SHIFT),"<<")
 			found = true;
 	return level + 1;
 }
-- 
1.8.3.2

