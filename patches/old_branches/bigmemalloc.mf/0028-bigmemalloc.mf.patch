From aaa649bc70f62694c1779c983309ab833a10f6b2 Mon Sep 17 00:00:00 2001
From: Nachiket Sahasrabuddhe <nachiket_sahasrabuddhe@xyratex.com>
Date: Thu, 19 Sep 2013 15:06:11 +0530
Subject: [PATCH 28/50] bigmemalloc.mf

-minor modifications in progress
---
 lib/varr.c | 88 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 88 insertions(+)

diff --git a/lib/varr.c b/lib/varr.c
index 6c86204..88b6c6b 100644
--- a/lib/varr.c
+++ b/lib/varr.c
@@ -60,6 +60,93 @@ M0_INTERNAL void varr_buffers_dealloc(struct m0_varr *arr,
 	 !strcmp(operator, "<<") ? __num << __shift : __num >> __shift;	     \
 	 })
 
+enum m0_varr_cursor_trav {
+	DEPTH_FIRST,
+	BREADTH_FIRST,
+};
+
+struct m0_varr_path_element {
+	uint32_t  vp_index;
+	void	 *vp_buf;
+};
+
+struct m0_varr_cursor {
+	struct m0_varr		    *vc_arr;
+	uint32_t		     vc_depth;
+	struct m0_varr_path_element  vc_path[M0_VARR_DEPTH_MAX];
+	enum m0_varr_cursor_trav     vc_trav;
+};
+
+M0_INTERNAL int m0_varr_cursor_init(struct m0_varr_cursor *cursor,
+				    const struct m0_varr *arr, uint32_t depth,
+				    enum m0_varr_cursor_trav traversal)
+{
+	struct m0_varr_path_element *pe;
+	uint32_t		     depth;
+	unsigned long		    *buf;
+
+	M0_PRE(cursor != NULL);
+	M0_PRE(arr != NULL);
+	M0_PRE(depth < arr->va_depth);
+
+	pe		 = &cursor->vc_path[0];
+	cursor->vc_arr   = arr;
+	cursor->vc_depth = depth;
+	cursor->vc_trav  = traversal;
+	pe->vp_index	 = 0;
+	pe->vp_buf	 = arr->va_tree;
+
+	if (traversal == BREADTH_FIRST) {
+		while (d < depth) {
+			buf = pe->vp_buf;
+			++pe;
+			pe->vp_index = 0;
+			if (buf != NULL)
+				pe->vp_buf = (unsigned long *)*buf;
+			else
+				return -ENOMEM;
+			++d;
+		}
+	}
+	return 0;
+}
+
+M0_INTERNAL int m0_varr_cursor_next(struct m0_varr_cursor *cursor)
+{
+
+	struct m0_varr_path_element *pe = cursor->vc_path[cursor->vc_depth - 1];
+	uint32_t		     d  = cursor->vc_depth;
+
+	M0_PRE(cursor != NULL);
+
+	switch (cursor->vc_trav) {
+	case BREADTH_FIRST:
+		for (;d > 1 && !within_tree_width(cursor->vc_arr,
+						  pe->vp_index + 1);
+		     --pe, --d)
+			;
+		++pe->vp_index;
+		++pe->vp_buf;
+		while (d < cursor->vc_depth) {
+			buf = pe->vp_buf;
+			++pe;
+			if (buf == NULL)
+				return -ENOMEM;
+			pe->buf = (unsigned long*)*buf;
+			pe->idx = 0;
+			++d;
+		}
+		return 0;
+		break;
+	case DEPTH_FIRST:
+		if (cursor->vc_depth < arr->va_depth) {
+			
+		}
+
+		break;
+	}
+
+}
 /* A record in a stack holding address, and index associated with that address
  * within a buffer */
 struct varr_stack_rec {
@@ -272,6 +359,7 @@ M0_INTERNAL bool varr_invariant(const struct m0_varr *arr)
 		arr->va_buf_shift >= arr->va_obj_shift;
 }
 
+
 M0_INTERNAL int m0_varr_init(struct m0_varr *arr, uint64_t nr, size_t size,
 			     size_t bufsize)
 {
-- 
1.8.3.2

