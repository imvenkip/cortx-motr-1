From 283a595f9b805178a74a76b798abdf4399fd9596 Mon Sep 17 00:00:00 2001
From: Nachiket Sahasrabuddhe <nachiket_sahasrabuddhe@xyratex.com>
Date: Wed, 21 Aug 2013 20:13:01 +0530
Subject: [PATCH 16/50] bigmemalloc.mf

-varr_buffers_alloc() has been modified to work for both alloc
 and dealloc case.
-one more round of CR needs to be done for this patch.
---
 lib/varr.c | 93 ++++++++++++++++++++++++++++++++++----------------------------
 1 file changed, 51 insertions(+), 42 deletions(-)

diff --git a/lib/varr.c b/lib/varr.c
index 42dc81f..de61d17 100644
--- a/lib/varr.c
+++ b/lib/varr.c
@@ -363,8 +363,9 @@ static void varr_buffers_dealloc(struct m0_varr *arr,
 }
 
 /* Allocates buffers for given virtual array from level 0 to varr::va_depth. */
-static int varr_buffers_alloc(struct m0_varr *arr,
-			      uint64_t        buff_nr)
+static int varr_buffers_alloc(struct m0_varr    *arr,
+		uint64_t           buff_nr,
+		enum buffer_action op)
 {
 	int            rc;
 	int            node;
@@ -381,6 +382,7 @@ static int varr_buffers_alloc(struct m0_varr *arr,
 	 * of some meta-buffer.
 	 */
 	unsigned long *holder;
+	unsigned long ptr_inc;
 
 	M0_PRE(arr     != NULL);
 	M0_PRE(buff_nr  > 0);
@@ -398,19 +400,21 @@ static int varr_buffers_alloc(struct m0_varr *arr,
 	 * a pointer on each level, except for the last level.
 	 */
 	for (done = 0, node = 0, done_pt = 0; node < VA_TNODE_NR && done < buff_nr;
-	     ++node, done_pt = 0) {
-		if (arr->va_tree[node] == NULL) {
-			rc = buffers_helper(arr, arr->va_tree[node],
-					    1, BA_ALLOC);
-			if (rc != 0)
-				goto end;
+			++node, done_pt = 0) {
+		if (op == BA_ALLOC) {
+			if (arr->va_tree[node] == NULL) {
+				rc = buffers_helper(arr, arr->va_tree[node],
+						1, op);
+				if (rc != 0)
+					goto end;
+			}
 		}
 		buff_nr_pn = min64u(max_buff_nr_till_lev_n_pn(arr, 1),
-				    buff_nr - done);
+				buff_nr - done);
 		while (done_pt < buff_nr_pn) {
 			holder = arr->va_tree[node];
 			for (level = 1; level <= arr->va_depth &&
-			     done_pt < buff_nr_pn; ++level) {
+					done_pt < buff_nr_pn; ++level) {
 
 				/*
 				 * For all levels except the last one,
@@ -420,48 +424,53 @@ static int varr_buffers_alloc(struct m0_varr *arr,
 				 * multiple buffers.
 				 */
 				nr = min64u(level != arr->va_depth ? 1 :
-					    arr->va_bufptr_nr,
-					    buff_nr_pn - done_pt);
+						arr->va_bufptr_nr,
+						buff_nr_pn - done_pt);
 
 				/*
 				 * For last level, the holding address is
 				 * fixed and need not be computed.
 				 */
-					holder += index_in_level_n_pn(arr,
-							done_pt, level - 1);
-
-				/*
-				 * The loop travels same trail multiple times
-				 * until all buffers which fall in this trail
-				 * are allocated.
-				 * Meta-buffers in this trail could be already
-				 * allocated and no allocation is needed on
-				 * that level.
-				 */
-				if ((unsigned long *)*holder == NULL) {
-					rc = buffers_helper(arr, holder, nr,
-							    BA_ALLOC);
-					if (rc != 0)
-						goto end;
-					/*
-					 * Input buff_nr number is number of
-					 * _data_ buffers.
-					 */
-					if (level == arr->va_depth)
-						done_pt += nr;
+				ptr_inc = index_in_level_n_pn(arr,
+						done_pt, level);
+
+
+				switch (op) {
+				case BA_ALLOC:
+					holder += ptr_inc;
+					if ((uint64_t *)*holder == NULL)
+						rc = buffers_helper(arr, holder, nr,
+								op);
+					break;
+				case BA_DEALLOC:
+					if (ptr_inc > 0 && (uint64_t *)*(holder + ptr_inc -1)!= NULL )
+						rc = buffers_helper(arr, holder + ptr_inc - 1, nr,
+								op);
+					holder += ptr_inc;
+					break;
 				}
-				M0_ASSERT((unsigned long *)*holder != NULL);
-
-				/* We respect your privacy! */
-				if (level != arr->va_depth)
-					holder = (unsigned long *)*holder;
+				if (rc != 0)
+					goto end;
 			}
+			if (level == arr->va_depth)
+				done_pt += nr;
+			/* We respect your privacy! */
+			if (level != arr->va_depth)
+				holder = (unsigned long *)*holder;
+		}
+
+		if (op == BA_DEALLOC) {
+			rc = buffers_helper(arr, arr->va_tree[node],
+					1, op);
+			if (rc != 0)
+				goto end;
 		}
-		done += buff_nr_pn;
 	}
+	done += buff_nr_pn;
+}
 end:
-	M0_POST(ergo(rc == 0, done == buff_nr));
-	return rc;
+M0_POST(ergo(rc == 0, done == buff_nr));
+return rc;
 }
 
 /*
-- 
1.8.3.2

