From 3195a6bc91b80b135940addda828327ad901f48b Mon Sep 17 00:00:00 2001
From: Nachiket Sahasrabuddhe <nachiket_sahasrabuddhe@xyratex.com>
Date: Sat, 12 Oct 2013 22:53:07 +0530
Subject: [PATCH 40/50] bigmemalloc.mf

-Modified m0_varr_cursor_move() for the case of ITERATE.
-Code for ITERATE is now simplified. But it now supports
 iterations only over leaf-nodes and not other levels.
---
 lib/varr.c         | 206 +++++++++++++++++++++++++----------------------------
 lib/varr.h         |  26 +++++--
 lib/varr_private.h |   6 --
 3 files changed, 119 insertions(+), 119 deletions(-)

diff --git a/lib/varr.c b/lib/varr.c
index b3bb612..566306a 100644
--- a/lib/varr.c
+++ b/lib/varr.c
@@ -55,6 +55,13 @@ M0_INTERNAL void varr_buffers_dealloc(struct m0_varr *arr);
 M0_INTERNAL uint32_t depth_find(const struct m0_varr *arr, uint64_t buff_nr);
 /* Returns log to the base two for the radix associated with a level. */
 M0_INTERNAL uint8_t log_radix(const struct m0_varr *arr, uint32_t level);
+/* Returns the yongest  common ancestor of two children within a tree */
+M0_INTERNAL uint32_t common_ancestor(const struct m0_varr *arr,
+				     uint64_t target_idx, uint64_t src_idx);
+/* Returns index within a buffer at given depth for a given target_index within
+ * an array. */
+M0_INTERNAL uint32_t index_within_level(const struct m0_varr *arr,
+					uint64_t target_idx, uint32_t depth);
 /* Returns total number of children for a node at given level in a tree. */
 M0_INTERNAL uint32_t children_of_level(const struct m0_varr *arr,
 				       uint32_t level);
@@ -89,9 +96,6 @@ M0_INTERNAL uint64_t last_nbits_set(uint8_t n);
 /* Increments buffer based upon its level in a tree */
 M0_INTERNAL void * buff_incr(const struct m0_varr *arr, uint32_t depth,
 			     void *buff, uint32_t incr);
-M0_INTERNAL uint32_t target_id_update(uint32_t inc,
-				      uint32_t leaves_beneath_shift,
-				      uint32_t target_idx);
 /* Shifts a given number to left/right by taking into account sizeof(number) */
 #define safe_bitshift(num, shift, operator)				     \
 	({								     \
@@ -105,7 +109,8 @@ M0_INTERNAL uint32_t target_id_update(uint32_t inc,
 M0_INTERNAL int m0_varr_init(struct m0_varr *arr, uint64_t nr, size_t size,
 			     size_t bufsize)
 {
-	int rc = 0;
+	int	 rc = 0;
+	uint64_t buff_nr;
 
 	M0_PRE(arr != NULL);
 	M0_PRE(nr > 0);
@@ -133,12 +138,10 @@ M0_INTERNAL int m0_varr_init(struct m0_varr *arr, uint64_t nr, size_t size,
 	 * bufsize and can fault the program.
 	 */
 	M0_ASSERT(m0_varr_size_is_valid(arr));
-
 	m0_varr_bob_init(arr);
-
-	arr->va_buff_nr = total_leaf_buffers(nr, varr_obj_nr_in_buff(arr),
-			arr->va_buf_shift - arr->va_obj_shift);
-	arr->va_depth   = depth_find(arr, arr->va_buff_nr);
+	buff_nr = total_leaf_buffers(nr, varr_obj_nr_in_buff(arr),
+				     arr->va_buf_shift - arr->va_obj_shift);
+	arr->va_depth   = depth_find(arr, buff_nr);
 	M0_ALLOC_PTR(arr->va_cache);
 	if (arr->va_cache == NULL)
 		rc = -ENOMEM;
@@ -231,7 +234,7 @@ M0_INTERNAL int varr_buffers_alloc(struct m0_varr *arr)
 	int		      rc;
 	unsigned long	      holder;
 
-	rc = m0_varr_cursor_init(&cursor, arr, 1, ALLOC);
+	rc = m0_varr_cursor_init(&cursor, arr, ALLOC);
 	if (rc != 0)
 		goto end;
 	do {
@@ -249,15 +252,15 @@ end:
 }
 
 M0_INTERNAL int m0_varr_cursor_init(struct m0_varr_cursor *cursor,
-				    const struct m0_varr *arr, uint32_t depth,
+				    const struct m0_varr *arr,
 				    enum m0_varr_cursor_trav traversal)
 {
 	struct m0_varr_path_element *pe;
 	unsigned long		    *buf;
+	uint32_t		     depth;
 
 	M0_PRE(cursor != NULL);
 	M0_PRE(arr != NULL);
-	M0_PRE(depth > 0 && depth <= arr->va_depth);
 
 	cursor->vc_arr	 = (struct m0_varr *)arr;
 	cursor->vc_trav	 = traversal;
@@ -268,6 +271,8 @@ M0_INTERNAL int m0_varr_cursor_init(struct m0_varr_cursor *cursor,
 	pe->vp_buf	 = (void *)arr->va_tree;
 	pe->vp_width	 = 1;
 
+	depth = traversal == ITERATE ? arr->va_depth : traversal == ALLOC ? 1 :
+						        arr->va_depth - 1;
 	while (cursor->vc_depth < depth) {
 		buf = pe->vp_buf;
 		if (buf != NULL) {
@@ -300,7 +305,8 @@ M0_INTERNAL uint8_t log_radix(const struct m0_varr *arr, uint32_t level)
 
 M0_INTERNAL void* m0_varr_cursor_get(const struct m0_varr_cursor *cursor)
 {
-	return cursor->vc_path[cursor->vc_depth].vp_buf;
+	return cursor->vc_done >= cursor->vc_arr->va_nr ? NULL :
+		cursor->vc_path[cursor->vc_depth].vp_buf;
 }
 
 M0_INTERNAL int m0_varr_cursor_next(struct m0_varr_cursor *cursor)
@@ -314,76 +320,45 @@ M0_INTERNAL int m0_varr_cursor_move(struct m0_varr_cursor *cursor,
 	unsigned long		    *buf;
 	struct m0_varr_path_element *pe;
 	uint32_t		     d = cursor->vc_depth;
-	uint32_t		     leaves_beneath_shift;
-	uint32_t		     target_idx;
+	uint64_t		     target_idx;
+	uint32_t		     common_anct;
+	uint32_t		     index_in_level;
 
 	M0_PRE(cursor != NULL);
-	M0_PRE(d < M0_VA_DEPTH_MAX);
+	M0_PRE(d <= cursor->vc_arr->va_depth);
 	M0_PRE(ergo(cursor->vc_trav != ITERATE, inc == 1));
 
 	pe = &cursor->vc_path[d];
-	target_idx = pe->vp_idx + inc;
 	switch (cursor->vc_trav) {
 	case ITERATE:
-		leaves_beneath_shift = 0;
-		/* Keep ascending till step required for target index is within
-		 * the reach of buffer at given level. */
-		while (d > 0 &&
-		       !within_tree_width((const struct m0_varr_cursor *)
-					  cursor->vc_arr, cursor->vc_depth,
-					  pe->vp_idx + inc)) {
-			leaves_beneath_shift += log_radix(cursor->vc_arr, d);
-			if (d == cursor->vc_depth)
-				completed_leaves_update(cursor, d,
-							pe->vp_width -
-							pe->vp_idx);
-			else
-				completed_leaves_update(cursor, d,
-							pe->vp_width -
-							pe->vp_idx - 1);
-			inc = safe_bitshift(target_idx, leaves_beneath_shift,
-					    >>);
-			--d;
+		target_idx = cursor->vc_done + inc;
+		if (target_idx >= cursor->vc_arr->va_nr)
+			goto end;
+		common_anct = common_ancestor(cursor->vc_arr, target_idx,
+					      cursor->vc_done);
+		while (d > common_anct) {
+			pe->vp_idx = index_within_level(cursor->vc_arr,
+							target_idx, d);
 			--pe;
+			--d;
 		}
-
-		if (d > 0) {
-			while (d <= cursor->vc_depth) {
-				inc = safe_bitshift(target_idx,
-						    leaves_beneath_shift, >>);
-				pe->vp_buf = buff_incr(cursor->vc_arr, d,
-						       pe->vp_buf, inc);
-				pe->vp_idx += inc;
-				target_idx =
-					target_id_update(inc,
-							 leaves_beneath_shift,
-							 target_idx);
-				if (d == cursor->vc_depth && inc > 0)
-					completed_leaves_update(cursor, d,
-								inc);
-				else {
-					/* To avoid unnecessary multiplication
-					 * with zero. */
-					if (inc > 1)
-						completed_leaves_update(cursor,
-									d,
-									inc -
-									1);
-					buf = (unsigned long *)pe->vp_buf;
-					++pe;
-					pe->vp_buf = (void *)(*buf);
-					pe->vp_idx = 0;
-					leaves_beneath_shift -=
-						log_radix(cursor->vc_arr, d);
-				}
-				++d;
-			}
-			goto next;
-		} else
-			goto end;
-		break;
+		index_in_level = index_within_level(cursor->vc_arr,
+						    target_idx, d);
+		pe->vp_buf = buff_incr(cursor->vc_arr, d, pe->vp_buf,
+				       index_in_level - pe->vp_idx);
+		pe->vp_idx = index_in_level;
+		while (d <= cursor->vc_depth) {
+			buf = (unsigned long *)pe->vp_buf;
+			pe->vp_buf = (void *)(*buf);
+			pe->vp_buf = buff_incr(cursor->vc_arr, d, pe->vp_buf,
+					       pe->vp_idx);
+			++d;
+		}
+		cursor->vc_done = target_idx;
+		goto next;
+	break;
 	case ALLOC:
-		/* Increments of cursor->vc_done are in the quantums of objects
+		/* Increments of cursor->vc_done are in the quantum of objects
 		 * in a single leaf buffer. Hence strict equality constraint is
 		 * avoided below. */
 		if (cursor->vc_done > cursor->vc_arr->va_buff_nr)
@@ -453,7 +428,6 @@ M0_INTERNAL int m0_varr_cursor_move(struct m0_varr_cursor *cursor,
 			goto next;
 		else
 			goto end;
-
 		break;
 	}
 next:
@@ -462,6 +436,50 @@ end:
 	return 0;
 }
 
+M0_INTERNAL uint32_t common_ancestor(const struct m0_varr *arr,
+				     uint64_t target_idx, uint64_t src_idx)
+{
+	uint64_t diff;
+	uint32_t level = arr->va_depth;
+
+	M0_PRE(arr != NULL);
+
+	diff = target_idx ^ src_idx;
+	if (diff == 0)
+		return 0;
+	if (diff <= varr_obj_nr_in_buff(arr))
+		return arr->va_depth;
+	diff >>= arr->va_buf_shift - arr->va_obj_shift;
+	while (diff > 0 && level > 0) {
+		diff >>= arr->va_bufptr_nr_shift;
+		--level;
+	}
+	return level;
+}
+
+M0_INTERNAL uint32_t index_within_level(const struct m0_varr *arr,
+					uint64_t target_idx, uint32_t depth)
+{
+	uint64_t  shift;
+
+	M0_PRE(arr != NULL);
+	M0_PRE(depth <= arr->va_depth);
+
+	shift = depth == arr->va_depth ? 0 :
+		arr->va_buf_shift - arr->va_obj_shift +
+		(arr->va_depth - depth - 1) * arr->va_bufptr_nr_shift;
+	target_idx  = safe_bitshift(target_idx, shift, >>);
+	target_idx &= last_nbits_set(shift);
+	return target_idx;
+}
+
+M0_INTERNAL uint64_t last_nbits_set(uint8_t n)
+{
+	M0_PRE(n <= 64);
+	return n < 64 ? ~safe_bitshift(~(uint64_t)0, n, <<) :
+		~(uint64_t)0;
+}
+
 M0_INTERNAL bool within_tree_width(const struct m0_varr_cursor *cursor,
 				   uint32_t depth, uint32_t index)
 {
@@ -521,21 +539,13 @@ M0_INTERNAL void *buff_incr(const struct m0_varr *arr, uint32_t depth,
 	return buff;
 }
 
-M0_INTERNAL uint32_t target_id_update(uint32_t inc,
-				      uint32_t leaves_beneath_shift,
-				      uint32_t target_idx)
-{
-	return target_idx - inc * safe_bitshift((uint32_t)1,
-					        leaves_beneath_shift, <<);
-}
-
 M0_INTERNAL void varr_buffers_dealloc(struct m0_varr *arr)
 {
 	struct m0_varr_cursor cursor;
 	int		      rc;
 	unsigned long	      holder;
 
-	rc = m0_varr_cursor_init(&cursor, arr, arr->va_depth - 1, DEALLOC);
+	rc = m0_varr_cursor_init(&cursor, arr, DEALLOC);
 	M0_ASSERT(rc == 0);
 
 	do {
@@ -570,33 +580,22 @@ M0_INTERNAL bool varr_invariant(const struct m0_varr *arr)
 M0_INTERNAL void *m0_varr_ele_get(struct m0_varr *arr, uint64_t index)
 {
 	uint32_t       level;
-	uint64_t       obj_mask;
-	uint64_t       buff_mask;
 	unsigned long *holder;
-	uint64_t       index_local;
 
 	M0_PRE(arr != NULL);
 	M0_PRE(index < arr->va_nr);
 
 	if (cache_fetch(arr, index, &holder))
 		goto end;
-	obj_mask    = last_nbits_set(arr->va_obj_shift);
-	buff_mask   = last_nbits_set(arr->va_buf_shift);
-	index_local = safe_bitshift(index, arr->va_obj_shift +
-				    (arr->va_depth - 1) * arr->va_buf_shift,
-				    >>);
-	holder = arr->va_tree[index_local];
-	for (level = 1; level <= arr->va_depth - 1; ++level) {
-		index_local = safe_bitshift(index, arr->va_obj_shift +
-					    (arr->va_depth - 1 - level) *
-					    arr->va_buf_shift, >>);
-		index_local &= buff_mask;
-		holder += index;
+	holder = (unsigned long *)arr->va_tree;
+	for (level = 0; level <= arr->va_depth - 1; ++level) {
+		holder += index_within_level((const struct m0_varr *) arr,
+					     index, level);
 		/* Dereferences the buffer pointer at given offset. */
 		holder = (unsigned long *)*holder;
 		M0_ASSERT(holder != NULL);
 	}
-	cache_update(arr, holder, index & (~obj_mask));
+	cache_update(arr, holder, index);
 	M0_POST_EX(varr_invariant(arr));
 end:
 	/* Adds to holder the index of required object within a buffer */
@@ -615,18 +614,11 @@ M0_INTERNAL bool cache_fetch(const struct m0_varr *arr, uint64_t index,
 		 arr->va_cache->vc_first_index);
 }
 
-M0_INTERNAL uint64_t last_nbits_set(uint8_t n)
-{
-	M0_PRE(n <= 64);
-	return n < 64 ? ~safe_bitshift(~(uint64_t)0, n, <<) :
-		~(uint64_t)0;
-}
-
 M0_INTERNAL void cache_update(struct m0_varr *arr, unsigned long *holder,
 			      uint64_t start_index)
 {
 	M0_PRE(arr != NULL);
-	M0_PRE(start_index < arr->va_nr - 1);
+	M0_PRE(start_index <= arr->va_nr - 1);
 
 	arr->va_cache->vc_buff = holder;
 	arr->va_cache->vc_first_index = start_index;
diff --git a/lib/varr.h b/lib/varr.h
index 1541f35..d0dad9e 100644
--- a/lib/varr.h
+++ b/lib/varr.h
@@ -104,6 +104,7 @@ enum m0_varr_cursor_trav {
 };
 
 struct m0_varr_path_element {
+	uint64_t  vp_arr_idx;
 	uint32_t  vp_idx;
 	uint32_t  vp_width;
 	void	 *vp_buf;
@@ -168,9 +169,9 @@ struct m0_varr {
 
 /**
  * Initialises a virtual array.
- * @param nr   Length of array.
- * @param size Size of object to be stored in array.
- * @param bufsize Size of each buffer which stores the objects.
+ * @param nr[in]      Length of array.
+ * @param size[in]    Size of object to be stored in array.
+ * @param bufsize[in] Size of each buffer which stores the objects.
  * @pre   arr != NULL && nr > 0.
  * @post  varr_invariant(arr).
  */
@@ -192,8 +193,22 @@ M0_INTERNAL void m0_varr_fini(struct m0_varr *arr);
  * @post varr_invariant(arr).
  */
 M0_INTERNAL void *m0_varr_ele_get(struct m0_varr *arr, uint64_t index);
-
+/**
+ * Returns the size of an array.
+ */
 M0_INTERNAL uint64_t m0_varr_size(const struct m0_varr *arr);
+/** Initializes the cursor to suitable location based upon the operation of
+ * traversal. */
+M0_INTERNAL int m0_varr_cursor_init(struct m0_varr_cursor *cursor,
+				    const struct m0_varr *arr,
+				    enum m0_varr_cursor_trav traversal);
+/**
+ * Returns a pointer corresponding to the current location of a cursor.
+ */
+M0_INTERNAL void* m0_varr_cursor_get(const struct m0_varr_cursor *cursor);
+M0_INTERNAL int m0_varr_cursor_next(struct m0_varr_cursor *cursor);
+M0_INTERNAL int m0_varr_cursor_move(struct m0_varr_cursor *cursor, uint32_t inc);
+
 /* Iterates over an arbitrary arithmetic progression of indices over
  * the range [start, end) */
 #define m0_varr_iter(arr, type, idx, obj, start, end, inc)		\
@@ -209,8 +224,7 @@ M0_INTERNAL uint64_t m0_varr_size(const struct m0_varr *arr);
 	 M0_PRE(idx < __arr->va_nr && __end <= __arr->va_nr);		\
 	 M0_PRE(sizeof *obj == 1 << __arr->va_obj_shift);		\
 									\
-	 rc = m0_varr_cursor_init(&cursor, __arr,			\
-				  __arr->va_depth, ITERATE)		\
+	 rc = m0_varr_cursor_init(&cursor, __arr, ITERATE);		\
 	 M0_ASSERT(rc == 0);						\
 	 m0_varr_cursor_move(&cursor, idx);				\
 	 for (obj = m0_varr_cursor_get(&cursor);idx < end;		\
diff --git a/lib/varr_private.h b/lib/varr_private.h
index 16b27f5..6a04cbe 100644
--- a/lib/varr_private.h
+++ b/lib/varr_private.h
@@ -26,10 +26,4 @@
 M0_EXTERN void *m0_varr_buf_alloc(size_t bufsize);
 M0_EXTERN void  m0_varr_buf_free(void *buf, size_t bufsize);
 M0_EXTERN bool  m0_varr_size_is_valid(const struct m0_varr *arr);
-M0_INTERNAL int m0_varr_cursor_init(struct m0_varr_cursor *cursor,
-				    const struct m0_varr *arr, uint32_t depth,
-				    enum m0_varr_cursor_trav traversal);
-M0_INTERNAL void* m0_varr_cursor_get(const struct m0_varr_cursor *cursor);
-M0_INTERNAL int m0_varr_cursor_next(struct m0_varr_cursor *cursor);
-M0_INTERNAL int m0_varr_cursor_move(struct m0_varr_cursor *cursor, uint32_t inc);
 #endif /* __MERO_LIB_VIRTUAL_ARRAY_PRIVATE_H__ */
-- 
1.8.3.2

