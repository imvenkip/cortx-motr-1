From 21ae505129636386691f7644304d29a5a39dbaf8 Mon Sep 17 00:00:00 2001
From: Nachiket Sahasrabuddhe <nachiket_sahasrabuddhe@xyratex.com>
Date: Fri, 27 Sep 2013 17:59:25 +0530
Subject: [PATCH 31/50] bigmemalloc.mf

-m0_varr_cursor_move() modified.
-this now supports cursor movement by aribitrary increment for the mode
 ITERATE.
---
 lib/varr.c | 67 ++++++++++++++++++++++++++++++++++++++------------------------
 1 file changed, 41 insertions(+), 26 deletions(-)

diff --git a/lib/varr.c b/lib/varr.c
index e6cba3b..b3a8a39 100644
--- a/lib/varr.c
+++ b/lib/varr.c
@@ -115,7 +115,7 @@ M0_INTERNAL int m0_varr_cursor_init(struct m0_varr_cursor *cursor,
 
 	M0_PRE(cursor != NULL);
 	M0_PRE(arr != NULL);
-	M0_PRE(depth < arr->va_depth);
+	M0_PRE(depth > 0 && depth <= arr->va_depth);
 
 	cursor->vc_arr   = arr;
 	cursor->vc_trav  = traversal;
@@ -125,6 +125,10 @@ M0_INTERNAL int m0_varr_cursor_init(struct m0_varr_cursor *cursor,
 	pe->vp_idx	 = 0;
 	pe->vp_buf	 = (void *)arr->va_tree;
 	pe->vp_width	 = 1;
+	++pe;
+	pe->vp_idx	 = 0;
+	pe->vp_buf	 = arr->va_tree[0];
+	pe->vp_width	 = VA_TNODE_NR_MAX;
 
 	while (cursor->vc_depth < depth) {
 		buf = pe->vp_buf;
@@ -133,6 +137,9 @@ M0_INTERNAL int m0_varr_cursor_init(struct m0_varr_cursor *cursor,
 			pe->vp_idx = 0;
 			pe->vp_width = children_of_level(arr,
 							 cursor->vc_depth);
+			pe->vp_leaves_beneath =
+				leaves_beneath_count(arr, cursor->vc_depth,
+						     depth)
 			/*TODO*/
 			pe->vp_buf = (void *)(*buf);
 		}
@@ -144,6 +151,11 @@ M0_INTERNAL int m0_varr_cursor_init(struct m0_varr_cursor *cursor,
 	/* Pre-calculate children of each level. */
 	while (d <= arr->va_depth) {
 		pe->vp_width = children_of_level(arr, d);
+		pe->vp_leaves_beneath =
+			safe_bitshift((uint32_t)1, arr->va_bufsize_shift -
+				      arr->va_obj_shift, "<<") *
+				leaves_beneath_count(arr, cursor->vc_depth,
+						     depth);
 		++d;
 	}
 	return 0;
@@ -154,17 +166,20 @@ M0_INTERNAL void* m0_varr_cursor_get(const struct m0_varr_cursor *cursor)
 	return cursor->vc_path[cursor->vc_depth].vp_buf;
 }
 
-M0_INTERNAL bool m0_varr_cursor_move(struct m0_varr_cursor *cursor,
-				     uint32_t inc)
+M0_INTERNAL int m0_varr_cursor_next(struct m0_varr_cursor *cursor)
 {
-	uint32_t i;
+	return m0_varr_cursor_move(cursor, 1);
+}
 
-	for (i = 0; i < inc && m0_varr_cursor_next(&cursor); ++i)
-		;
-	return i == inc;
+M0_INTERNAL void completed_leaves_cnt_update(struct m0_varr_cursor *cursor,
+					     uint32_t inc)
+{
+	cursor->vc_done += inc * max_buff_nr_till_lev_n_pn(cursor->vc_arr,
+							   cursor->vc_depth);
 }
 
-M0_INTERNAL int m0_varr_cursor_next(struct m0_varr_cursor *cursor)
+M0_INTERNAL int m0_varr_cursor_move(struct m0_varr_cursor *cursor,
+				    uint32_t inc)
 {
 
 	struct m0_varr_path_element *pe
@@ -172,28 +187,27 @@ M0_INTERNAL int m0_varr_cursor_next(struct m0_varr_cursor *cursor)
 
 	M0_PRE(cursor != NULL);
 	M0_PRE(d < M0_VARR_DEPTH_MAX);
+	M0_PRE(ergo(cursor->vc_tarv != ITERATE, inc == 1));
 
 	pe = cursor->vc_path[d];
 
 	switch (cursor->vc_trav) {
 	case ITERATE:
-		for (;d > 0 && !within_tree_width(cursor, d,
-						  pe->vp_index + 1);
-		     --pe, --d)
-			;
+		while (d > 0 &&
+		       pe->vp_leaves_beneath * (pe->vp_width - pe->vp_idx) <
+		       inc) {
+			--d;
+			--pe;
+		}
 		if (d > 0) {
-			++pe->vp_index;
-			++pe->vp_buf;
-			if (d == cursor->vc_depth)
-				cursor->vc_done +=
-				 max_buff_nr_till_lev_n_pn(cursor->vc_arr,
-							   cursor->vc_depth);
-			while (d < cursor->vc_depth) {
-				buf = pe->vp_buf;
-				++pe;
-				++d;
-				pe->vp_buf = (unsigned long*)*buf;
-				pe->vp_idx = 0;
+			while (inc > 0) {
+				while (inc > pe->vp_leaves_beneath) {
+					++pe->idx;
+					++pe->buf;
+					inc -= pe->vp_leaves_beneath;
+				}
+				pe->buf = (unsigned long *)*pe->buf;
+				pe->idx = 0;
 			}
 			return 1;
 		} else
@@ -204,7 +218,7 @@ M0_INTERNAL int m0_varr_cursor_next(struct m0_varr_cursor *cursor)
 						  pe->vp_idx + 1)
 		     --pe, --d) {
 			if (d == cursor->vc_arr->va_depth - 1)
-				++cursor->vc_done;
+				completed_leaves_cnt_update(cursor, 1);
 		}
 
 		if (d > 0) {
@@ -221,7 +235,8 @@ M0_INTERNAL int m0_varr_cursor_next(struct m0_varr_cursor *cursor)
 				++pe->vp_buf;
 				cursor->vc_depth = d;
 				if (d == cursor->vc_arr->va_depth - 1)
-					++cursor->vc_done;
+					completed_leaves_cnt_update(cursor,
+								    1);
 			}
 			return 1;
 		} else
-- 
1.8.3.2

