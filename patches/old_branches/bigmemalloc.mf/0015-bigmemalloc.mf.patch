From 8e2ef1151ccef699f8277e95fc3fab4fb1637053 Mon Sep 17 00:00:00 2001
From: Nachiket Sahasrabuddhe <nachiket_sahasrabuddhe@xyratex.com>
Date: Wed, 21 Aug 2013 13:35:04 +0530
Subject: [PATCH 15/50] bigmemalloc.mf

varr_buffers_alloc() from lib.varr.c is modified.
---
 lib/varr.c | 22 +++++++++++-----------
 1 file changed, 11 insertions(+), 11 deletions(-)

diff --git a/lib/varr.c b/lib/varr.c
index 6455a7b..42dc81f 100644
--- a/lib/varr.c
+++ b/lib/varr.c
@@ -313,7 +313,6 @@ static void varr_buffers_dealloc(struct m0_varr *arr,
 		buff_nr_pn = min64u(max_buff_nr_till_lev_n_pn(arr, 1),
 				    buff_nr - done);
 		while (done < buff_nr_pn) {
-
 			for (level = 1; level <= arr->va_depth &&
 			     done < buff_nr_pn; ++level) {
 
@@ -373,6 +372,8 @@ static int varr_buffers_alloc(struct m0_varr *arr,
 	uint64_t       nr;
 	/* Number of buffer allocated at any given moment. */
 	uint64_t       done;
+	/* Number of buffers allocated per tree at given moment */
+	uint64_t       done_pt;
 	/* Number of buffers per tree node. */
 	uint64_t       buff_nr_pn;
 	/*
@@ -396,21 +397,20 @@ static int varr_buffers_alloc(struct m0_varr *arr,
 	 * While traversing the tree, a trail is followed by dereferencing
 	 * a pointer on each level, except for the last level.
 	 */
-	for (done = 0, node = 0; node < VA_TNODE_NR && done < buff_nr;
-	     ++node) {
+	for (done = 0, node = 0, done_pt = 0; node < VA_TNODE_NR && done < buff_nr;
+	     ++node, done_pt = 0) {
 		if (arr->va_tree[node] == NULL) {
 			rc = buffers_helper(arr, arr->va_tree[node],
 					    1, BA_ALLOC);
 			if (rc != 0)
 				goto end;
 		}
-		holder = arr->va_tree[node];
 		buff_nr_pn = min64u(max_buff_nr_till_lev_n_pn(arr, 1),
 				    buff_nr - done);
-		while (done < buff_nr_pn) {
-
+		while (done_pt < buff_nr_pn) {
+			holder = arr->va_tree[node];
 			for (level = 1; level <= arr->va_depth &&
-			     done < buff_nr_pn; ++level) {
+			     done_pt < buff_nr_pn; ++level) {
 
 				/*
 				 * For all levels except the last one,
@@ -421,15 +421,14 @@ static int varr_buffers_alloc(struct m0_varr *arr,
 				 */
 				nr = min64u(level != arr->va_depth ? 1 :
 					    arr->va_bufptr_nr,
-					    buff_nr_pn - done);
+					    buff_nr_pn - done_pt);
 
 				/*
 				 * For last level, the holding address is
 				 * fixed and need not be computed.
 				 */
-				if (level != arr->va_depth)
 					holder += index_in_level_n_pn(arr,
-							done, level);
+							done_pt, level - 1);
 
 				/*
 				 * The loop travels same trail multiple times
@@ -449,7 +448,7 @@ static int varr_buffers_alloc(struct m0_varr *arr,
 					 * _data_ buffers.
 					 */
 					if (level == arr->va_depth)
-						done += nr;
+						done_pt += nr;
 				}
 				M0_ASSERT((unsigned long *)*holder != NULL);
 
@@ -458,6 +457,7 @@ static int varr_buffers_alloc(struct m0_varr *arr,
 					holder = (unsigned long *)*holder;
 			}
 		}
+		done += buff_nr_pn;
 	}
 end:
 	M0_POST(ergo(rc == 0, done == buff_nr));
-- 
1.8.3.2

