From 8e9ba24691fdec6db714bbcb7fa854c589717205 Mon Sep 17 00:00:00 2001
From: Nachiket Sahasrabuddhe <nachiket_sahasrabuddhe@xyratex.com>
Date: Wed, 30 Oct 2013 13:44:15 +0530
Subject: [PATCH 47/50] bigmemalloc.mf

-lib/varr.c is under re-org. Code does NOT compile.
---
 lib/varr.c | 205 ++++++++++++++++++++++++++++++++++---------------------------
 1 file changed, 116 insertions(+), 89 deletions(-)

diff --git a/lib/varr.c b/lib/varr.c
index 73b9eb9..245d926 100644
--- a/lib/varr.c
+++ b/lib/varr.c
@@ -94,8 +94,9 @@ M0_INTERNAL uint8_t nearest_power_of_two(size_t size);
 /* Returns a 64-bit number whose last 'n' bits are set, and rest are zero. */
 M0_INTERNAL uint64_t last_nbits_set(uint8_t n);
 /* Increments buffer based upon its level in a tree */
-M0_INTERNAL void * buff_incr(const struct m0_varr *arr, uint32_t depth,
-			     void *buff, uint32_t incr);
+M0_INTERNAL void *buff_move(const struct m0_varr *arr, uint32_t depth,
+			    void *buff, uint32_t step,
+			    enum m0_varr_cursor_dir dir)
 /* Shifts a given number to left/right by taking into account sizeof(number) */
 #define safe_bitshift(num, shift, operator)				     \
 	({								     \
@@ -244,7 +245,7 @@ M0_INTERNAL int varr_buffers_alloc(struct m0_varr *arr)
 			goto end;
 		}
 		*(void **)m0_varr_cursor_get(&cursor) = holder;
-	} while (m0_varr_cursor_next(&cursor));
+	} while (m0_varr_cursor_preorder_iter(&cursor));
 end:
 	return rc;
 }
@@ -317,7 +318,7 @@ M0_INTERNAL int m0_varr_cursor_next(struct m0_varr_cursor *cursor)
 }
 
 M0_INTERNAL int m0_varr_cursor_move(struct m0_varr_cursor *cursor,
-				    uint32_t inc)
+				    uint64_t step, enum m0_varr_cursor_dir dir)
 {
 	void			    *buf;
 	struct m0_varr_path_element *pe;
@@ -325,106 +326,128 @@ M0_INTERNAL int m0_varr_cursor_move(struct m0_varr_cursor *cursor,
 	uint64_t		     target_idx;
 	uint32_t		     common_anct;
 	uint32_t		     index_in_level;
+	uint32_t		     step_in_level;
 
 	M0_PRE(cursor != NULL);
 	M0_PRE(ergo(cursor->vc_trav == ITERATE,
-		    d == cursor->vc_arr->va_depth));
+				d == cursor->vc_arr->va_depth));
 	M0_PRE(ergo(cursor->vc_trav != ITERATE, inc == 1 &&
-		    d < cursor->vc_arr->va_depth));
+				d < cursor->vc_arr->va_depth));
 
 	pe = &cursor->vc_path[d];
-	switch (cursor->vc_trav) {
-	case ITERATE:
-		target_idx = cursor->vc_done + inc;
+	if (dir == FWD) {
+		target_idx = cursor->vc_done + step;
 		if (target_idx >= cursor->vc_arr->va_nr)
 			goto end;
-		else if (target_idx == cursor->vc_done)
-			goto next;
-		common_anct = common_ancestor(cursor->vc_arr, target_idx,
-					      cursor->vc_done);
-		while (d > common_anct) {
-			pe->vp_idx = index_within_level(cursor->vc_arr,
-							target_idx, d);
+	} else {
+		if (step > cursor->vc_done)
+			goto end;
+		target_idx = cursor->vc_done - step;
+	}
+	if (target_idx == cursor->vc_done)
+		goto next;
+	common_anct = common_ancestor(cursor->vc_arr, target_idx,
+				      cursor->vc_done);
+	while (d > common_anct) {
+		pe->vp_idx = index_within_level(cursor->vc_arr,
+						target_idx, d);
+		--pe;
+		--d;
+	}
+	index_in_level = index_within_level(cursor->vc_arr,
+					    target_idx, d);
+	step_in_level = index_in_level > pe->vp_idx ? index_in_level -
+		pe->vp_idx : pe->vp_idx - index_in_level;
+	pe->vp_buf = buff_move(cursor->vc_arr, d, pe->vp_buf,
+			       step_in_level, dir);
+	pe->vp_idx = index_in_level;
+	while (common_anct != cursor->vc_depth &&
+	       d < cursor->vc_depth) {
+		buf = pe->vp_buf;
+		++pe;
+		++d;
+		pe->vp_buf = *(void **)buf;
+		pe->vp_buf = buff_move(cursor->vc_arr, d, pe->vp_buf,
+				       pe->vp_idx, FWD);
+	}
+	cursor->vc_done = target_idx;
+	return 1;
+end:
+	return 0;
+
+}
+
+M0_INTERNAL int m0_varr_cursor_preorder_nxt(struct m0_varr_cursor *cursor)
+{
+	void			    *buf;
+	struct m0_varr_path_element *pe;
+	uint32_t		     d = cursor->vc_depth;
+
+	/* Increments of cursor->vc_done are in the quantum of objects
+	 * in a single leaf buffer. Hence strict equality constraint is
+	 * avoided below. */
+	if (cursor->vc_done >= cursor->vc_arr->va_nr)
+		goto end;
+	if (d < cursor->vc_arr->va_depth - 1) {
+		buf = pe->vp_buf;
+		++pe;
+		++d;
+		pe->vp_buf = *(void **)buf;
+		pe->vp_idx = 0;
+		pe->vp_width = children_of_level(cursor->vc_arr, d);
+	} else {
+		completed_leaves_update(cursor, d, 1);
+		while (!within_tree_width(cursor, d, pe->vp_idx + 1) &&
+		       d > 0) {
 			--pe;
 			--d;
 		}
-		index_in_level = index_within_level(cursor->vc_arr,
-						    target_idx, d);
-		pe->vp_buf = buff_incr(cursor->vc_arr, d, pe->vp_buf,
-				       index_in_level - pe->vp_idx);
-		pe->vp_idx = index_in_level;
-		while (common_anct != cursor->vc_depth &&
-		       d < cursor->vc_depth) {
-			buf = pe->vp_buf;
-			++pe;
-			++d;
-			pe->vp_buf = *(void **)buf;
-			pe->vp_buf = buff_incr(cursor->vc_arr, d, pe->vp_buf,
-					       pe->vp_idx);
-		}
-		cursor->vc_done = target_idx;
+		++pe->vp_idx;
+		pe->vp_buf = buff_move(cursor->vc_arr, d, pe->vp_buf, 1, FWD);
+	}
+	cursor->vc_depth = d;
+	if (cursor->vc_depth != 0)
 		goto next;
-	break;
-	case ALLOC:
-		/* Increments of cursor->vc_done are in the quantum of objects
-		 * in a single leaf buffer. Hence strict equality constraint is
-		 * avoided below. */
-		if (cursor->vc_done >= cursor->vc_arr->va_nr)
-			goto end;
-		if (d < cursor->vc_arr->va_depth - 1) {
+	else
+		goto end;
+next:
+	return 1;
+end:
+	return 0;
+}
+
+M0_INTERNAL int m0_varr_cursor_postorder_nxt(struct m0_varr_cursor *cursor)
+{
+	void			    *buf;
+	struct m0_varr_path_element *pe;
+	uint32_t		     d = cursor->vc_depth;
+
+	if (d == 0)
+		goto end;
+	if (d == cursor->vc_arr->va_depth - 1)
+		completed_leaves_update(cursor, d, 1);
+	if (within_tree_width(cursor, d, pe->vp_idx + 1) &&
+	    *(void **)buff_move(cursor->vc_arr, d, pe->vp_buf, 1, FWD)
+	    != NULL) {
+		++pe->vp_idx;
+		pe->vp_buf = buff_move(cursor->vc_arr, d, pe->vp_buf, 1, FWD);
+		while (d < cursor->vc_arr->va_depth - 1 &&
+		       *(void **)pe->vp_buf != NULL) {
 			buf = pe->vp_buf;
 			++pe;
 			++d;
 			pe->vp_buf = *(void **)buf;
 			pe->vp_idx = 0;
-			pe->vp_width = children_of_level(cursor->vc_arr, d);
-		} else {
-			completed_leaves_update(cursor, d, 1);
-			while (!within_tree_width(cursor, d, pe->vp_idx + 1) &&
-				d > 0) {
-				--pe;
-				--d;
-			}
-			++pe->vp_idx;
-			pe->vp_buf = buff_incr(cursor->vc_arr, d, pe->vp_buf,
-					       1);
-		}
-		cursor->vc_depth = d;
-		if (cursor->vc_depth != 0)
-			goto next;
-		else
-			goto end;
-		break;
-	case DEALLOC:
-		if (d == 0)
-			goto end;
-		if (d == cursor->vc_arr->va_depth - 1)
-			completed_leaves_update(cursor, d, 1);
-		if (within_tree_width(cursor, d, pe->vp_idx + 1) &&
-		    *(void **)buff_incr(cursor->vc_arr, d, pe->vp_buf, 1)
-		    != NULL) {
-			++pe->vp_idx;
-			pe->vp_buf = buff_incr(cursor->vc_arr, d, pe->vp_buf,
-					       1);
-			while (d < cursor->vc_arr->va_depth - 1 &&
-			       *(void **)pe->vp_buf != NULL) {
-				buf = pe->vp_buf;
-				++pe;
-				++d;
-				pe->vp_buf = *(void **)buf;
-				pe->vp_idx = 0;
-			}
-		} else {
-			--pe;
-			--d;
 		}
-		cursor->vc_depth = d;
-		if (cursor->vc_depth != 0)
-			goto next;
-		else
-			goto end;
-		break;
+	} else {
+		--pe;
+		--d;
 	}
+	cursor->vc_depth = d;
+	if (cursor->vc_depth != 0)
+		goto next;
+	else
+		goto end;
 next:
 	return 1;
 end:
@@ -521,8 +544,9 @@ M0_INTERNAL uint64_t max_buff_nr_till_lev_n_pn(const struct m0_varr *arr,
 					    (arr->va_depth - level - 1)), <<);
 }
 
-M0_INTERNAL void *buff_incr(const struct m0_varr *arr, uint32_t depth,
-			    void *buff, uint32_t incr)
+M0_INTERNAL void *buff_move(const struct m0_varr *arr, uint32_t depth,
+			    void *buff, uint32_t step,
+			    enum m0_varr_cursor_dir dir)
 {
 	size_t inc_unit;
 
@@ -532,7 +556,10 @@ M0_INTERNAL void *buff_incr(const struct m0_varr *arr, uint32_t depth,
 		inc_unit = arr->va_obj_size;
 	else
 		inc_unit = M0_VA_TNODEPTR_SIZE;
-	buff += incr*inc_unit;
+	if (dir == FWD)
+		buff += incr*inc_unit;
+	else
+		buff -= incr*inc_unit;
 	return buff;
 }
 
@@ -551,7 +578,7 @@ M0_INTERNAL void varr_buffers_dealloc(struct m0_varr *arr)
 		if ((void *)holder != NULL) {
 			m0_varr_buf_free(holder, arr->va_bufsize);
 		}
-	} while (m0_varr_cursor_next(&cursor));
+	} while (m0_varr_cursor_postorder_iter(&cursor));
 }
 
 M0_INTERNAL void m0_varr_fini(struct m0_varr *arr)
-- 
1.8.3.2

