From 9bf578108e867e8f6e9250c95422dc12a3883d0a Mon Sep 17 00:00:00 2001
From: "Valery V. Vorotyntsev" <valery_vorotyntsev@xyratex.com>
Date: Fri, 16 Aug 2013 09:50:31 +0530
Subject: [PATCH 1/7] fol: convert to BE

Replace contents of fol/ directory with converted files, copying them
from be.db branch. Note that commit history is lost, unfortunately.
---
 fol/fol.c         | 781 +++++++++++++++++++++++++++++++++++++-----------------
 fol/fol.h         | 190 ++++++++-----
 fol/fol_private.h |   3 +-
 fol/lsn.h         |   4 +-
 fol/ut/fol.c      | 351 ++++++++++++++++++------
 mero/magic.h      |   6 +-
 6 files changed, 942 insertions(+), 393 deletions(-)

diff --git a/fol/fol.c b/fol/fol.c
index 329cae6..03a783b 100644
--- a/fol/fol.c
+++ b/fol/fol.c
@@ -15,23 +15,16 @@
  * http://www.xyratex.com/contact
  *
  * Original author: Nikita Danilov <nikita_danilov@xyratex.com>
- * Original creation date: 09/09/2010
+ * Original creation date: 09-Sep-2010
  */
 
-#include "lib/adt.h"           /* m0_buf */
-#include "lib/arith.h"         /* M0_3WAY */
-#include "lib/memory.h"
-#include "lib/errno.h"
-#include "lib/misc.h"          /* M0_SET0 */
-#include "lib/cdefs.h"         /* M0_EXPORTED */
-#include "lib/vec.h"
-#include "mero/magic.h"
-#include "rpc/rpc_opcodes.h"
 #include "fol/fol.h"
-#include "fol/fol_xc.h"
-#include "xcode/xcode.h"
-#include "fop/fop.h"
 #include "fol/fol_private.h"
+#include "fol/fol_xc.h"       /* m0_xc_fol_init */
+#include "lib/errno.h"        /* ENOENT, EFBIG, ENOMEM */
+#include "lib/misc.h"         /* M0_SET0 */
+#include "lib/memory.h"
+#include "fop/fop.h"          /* m0_fop_fol_rec_part_type */
 
 /**
    @addtogroup fol
@@ -67,27 +60,44 @@ M0_TL_DESCR_DEFINE(m0_rec_part, "fol record part", M0_INTERNAL,
 		   M0_FOL_REC_PART_LINK_MAGIC, M0_FOL_REC_PART_HEAD_MAGIC);
 M0_TL_DEFINE(m0_rec_part, M0_INTERNAL, struct m0_fol_rec_part);
 
-static size_t fol_record_pack_size(struct m0_fol_rec *rec);
-static int fol_record_pack(struct m0_fol_rec *rec, struct m0_buf *buf);
-static int fol_record_encode(struct m0_fol_rec *rec, struct m0_buf *out);
-static int fol_record_decode(struct m0_fol_rec *rec);
-static int fol_rec_desc_encdec(struct m0_fol_rec_desc *desc,
-			       struct m0_bufvec_cursor *cur,
-			       enum m0_xcode_what what);
-
 #define REC_SIBLING_XCODE_OBJ(ptr) M0_XCODE_OBJ(m0_fol_update_ref_xc, ptr)
 #define REC_OBJ_REF_XCODE_OBJ(ptr) M0_XCODE_OBJ(m0_fol_obj_ref_xc, ptr)
 
 #define REC_PART_HEADER_XCODE_OBJ(ptr) \
-M0_XCODE_OBJ(m0_fol_rec_part_header_xc, ptr)
+	M0_XCODE_OBJ(m0_fol_rec_part_header_xc, ptr)
 
 #define REC_PART_XCODE_OBJ(r) (struct m0_xcode_obj) { \
-	.xo_type = part->rp_ops != NULL ?	      \
+	.xo_type = part->rp_ops != NULL ?             \
 		   part->rp_ops->rpo_type->rpt_xt :   \
 		   m0_fop_fol_rec_part_type.rpt_xt,   \
-	.xo_ptr  = r->rp_data,		              \
+	.xo_ptr  = r->rp_data                         \
 }
 
+enum {
+	FOL_KEY_SIZE = sizeof(m0_lsn_t),
+#if !XXX_USE_DB5
+	/*
+	 * The maximum possible length of fol record.
+	 *
+	 * We need to obtain sufficient BE credit before adding new record
+	 * to the fol. Fol records are of variable length and the actual
+	 * length is hard, if possible, to calculate at the moment of
+	 * m0_fol_credit() call. We use the empirical value of maximum
+	 * possible record length instead.
+	 *
+	 * XXX REVISEME: If the value is not sufficient, increase it.
+	 * Alternative (proper?) solution is to calculate the size of fol
+	 * record as a function of rpc opcode.
+	 */
+	FOL_REC_MAXSIZE = 512
+#endif
+};
+
+/* ------------------------------------------------------------------
+ * LSN
+ * ------------------------------------------------------------------ */
+
+static m0_bcount_t fol_rec_header_pack_size(struct m0_fol_rec_header *h);
 
 M0_INTERNAL bool m0_lsn_is_valid(m0_lsn_t lsn)
 {
@@ -104,12 +114,28 @@ M0_INTERNAL int m0_lsn_cmp(m0_lsn_t lsn0, m0_lsn_t lsn1)
 
 M0_INTERNAL m0_lsn_t lsn_inc(m0_lsn_t lsn)
 {
-	++lsn;
-	M0_ASSERT(lsn != 0);
+	M0_CNT_INC(lsn);
+
+	M0_POST(m0_lsn_is_valid(lsn));
+	return lsn;
+}
+
+M0_INTERNAL m0_lsn_t m0_fol_lsn_allocate(struct m0_fol *fol)
+{
+	m0_lsn_t lsn;
+	/*
+	 * Obtain next fol lsn under the lock. Alternatively, m0_fol::f_lsn
+	 * could be made into a m0_atomic64 instance.
+	 */
+	m0_mutex_lock(&fol->f_lock);
+	lsn = fol->f_lsn;
+	fol->f_lsn = lsn_inc(fol->f_lsn);
+	m0_mutex_unlock(&fol->f_lock);
 	M0_POST(m0_lsn_is_valid(lsn));
 	return lsn;
 }
 
+#if XXX_USE_DB5
 static int lsn_cmp(struct m0_table *table, const void *key0, const void *key1)
 {
 	const m0_lsn_t *lsn0 = key0;
@@ -121,7 +147,7 @@ static int lsn_cmp(struct m0_table *table, const void *key0, const void *key1)
 static const struct m0_table_ops fol_ops = {
 	.to = {
 		[TO_KEY] = {
-			.max_size = sizeof(m0_lsn_t)
+			.max_size = FOL_KEY_SIZE
 		},
 		[TO_REC] = {
 			.max_size = ~0
@@ -129,68 +155,54 @@ static const struct m0_table_ops fol_ops = {
 	},
 	.key_cmp = lsn_cmp
 };
-
-/**
-   Initializes fields in @rec.
-
-   Note, that key buffer in the cursor is initialized to point to
-   rec->fr_desc.rd_lsn. As a result, the cursor's key follows lsn changes
-   automagically.
-
-   @see m0_fol_rec_fini()
- */
-static int rec_init(struct m0_fol_rec *rec, struct m0_db_tx *tx)
+#else
+static m0_bcount_t fol_ksize(const void *_)
 {
-	struct m0_db_pair *pair;
-
-	M0_PRE(rec->fr_fol != NULL);
-
-	m0_fol_rec_init(rec);
-	pair = &rec->fr_pair;
-	m0_db_pair_setup(pair, &rec->fr_fol->f_table, &rec->fr_desc.rd_lsn,
-			 sizeof rec->fr_desc.rd_lsn, NULL, 0);
-	return m0_db_cursor_init(&rec->fr_ptr, &rec->fr_fol->f_table, tx, 0);
+	return FOL_KEY_SIZE;
 }
 
-M0_INTERNAL void m0_fol_rec_init(struct m0_fol_rec *rec)
+static m0_bcount_t fol_vsize(const void *data)
 {
-	M0_PRE(rec != NULL);
-
-	m0_rec_part_tlist_init(&rec->fr_fol_rec_parts);
-}
+	struct m0_fol_rec_header hdr;
+	m0_bcount_t              len = fol_rec_header_pack_size(&hdr);
+	struct m0_bufvec         bvec = M0_BUFVEC_INIT_BUF((void **)&data,
+							   &len);
+	struct m0_bufvec_cursor  cur;
+	int                      rc;
 
-/**
-   Finalizes @rec.
-
-   @see rec_init()
- */
-M0_INTERNAL void m0_fol_lookup_rec_fini(struct m0_fol_rec *rec)
-{
-	M0_PRE(rec != NULL);
-
-	m0_fol_rec_fini(rec);
-	m0_db_cursor_fini(&rec->fr_ptr);
-	m0_db_pair_fini(&rec->fr_pair);
+	m0_bufvec_cursor_init(&cur, &bvec);
+	rc = m0_xcode_encdec(&M0_REC_HEADER_XCODE_OBJ(&hdr), &cur,
+			     M0_XCODE_DECODE);
+	/* XXX There is no way to return an error code from
+	 * m0_be_btree_kv_ops::ko_vsize(). */
+	M0_ASSERT(rc == 0 && hdr.rh_magic == M0_FOL_REC_MAGIC);
+
+	M0_POST(hdr.rh_data_len <= FOL_REC_MAXSIZE);
+	return hdr.rh_data_len;
 }
 
-M0_INTERNAL void m0_fol_rec_fini(struct m0_fol_rec *rec)
+static int lsn_cmp(const void *key0, const void *key1)
 {
-	struct m0_fol_rec_part *part;
+	const m0_lsn_t *lsn0 = key0;
+	const m0_lsn_t *lsn1 = key1;
 
-	m0_tl_for(m0_rec_part, &rec->fr_fol_rec_parts, part) {
-		m0_fol_rec_part_fini(part);
-	} m0_tl_endfor;
-	m0_rec_part_tlist_fini(&rec->fr_fol_rec_parts);
+	return m0_lsn_cmp(*lsn0, *lsn1);
 }
 
-M0_INTERNAL void m0_fol_rec_part_add(struct m0_fol_rec *rec,
-				     struct m0_fol_rec_part *part)
-{
-	M0_PRE(rec != NULL && part != NULL);
+static const struct m0_be_btree_kv_ops fol_kv_ops = {
+	.ko_ksize   = fol_ksize,
+	.ko_vsize   = fol_vsize,
+	.ko_compare = lsn_cmp
+};
+#endif
+
+/* ------------------------------------------------------------------
+ * m0_fol operations
+ * ------------------------------------------------------------------ */
 
-	m0_rec_part_tlist_add_tail(&rec->fr_fol_rec_parts, part);
-}
+static int fol_setup(struct m0_fol *fol, struct m0_be_tx *tx);
 
+#if XXX_USE_DB5
 M0_INTERNAL int m0_fol_init(struct m0_fol *fol, struct m0_dbenv *env)
 {
 	int result;
@@ -232,54 +244,222 @@ M0_INTERNAL int m0_fol_init(struct m0_fol *fol, struct m0_dbenv *env)
 	M0_POST(ergo(result == 0, m0_lsn_is_valid(fol->f_lsn)));
 	return result;
 }
+#else
+M0_INTERNAL int m0_fol_init(struct m0_fol *fol, struct m0_be_seg *seg,
+			    struct m0_be_tx *tx, struct m0_be_op *op)
+{
+	struct m0_be_btree *tree = &fol->f_store;
+	int                 rc;
+
+	M0_PRE(m0_be_tx_state(tx) == M0_BTS_ACTIVE);
+
+	m0_be_op_state_set(op, M0_BOS_ACTIVE);
+
+	m0_mutex_init(&fol->f_lock);
+	m0_be_btree_init(tree, seg, &fol_kv_ops);
+
+	if (tree->bb_root == NULL)
+		M0_BE_OP_SYNC(local_op,
+			      m0_be_btree_create(tree, tx, &local_op));
+
+	rc = fol_setup(fol, tx);
+	if (rc != 0) {
+		M0_BE_OP_SYNC(local_op,
+			      m0_be_btree_destroy(tree, tx, &local_op));
+		m0_fol_fini(fol);
+	}
+	m0_be_op_state_set(op, M0_BOS_SUCCESS);
+	return rc;
+}
+#endif
 
 M0_INTERNAL void m0_fol_fini(struct m0_fol *fol)
 {
+#if XXX_USE_DB5
 	m0_table_fini(&fol->f_table);
+#else
+	m0_be_btree_fini(&fol->f_store);
+	m0_mutex_fini(&fol->f_lock);
+#endif
 }
 
-M0_INTERNAL m0_lsn_t m0_fol_lsn_allocate(struct m0_fol *fol)
+M0_INTERNAL int m0_fol_force(struct m0_fol *fol, m0_lsn_t upto)
 {
-	m0_lsn_t lsn;
+#if XXX_USE_DB5
+	return m0_dbenv_sync(fol->f_table.t_env);
+#else
+	M0_IMPOSSIBLE("XXX Not implemented");
+	return -1;
+#endif
+}
 
-	/*
-	 * Obtain next fol lsn under the lock. Alternatively, m0_fol::f_lsn
-	 * could be made into a m0_atomic64 instance.
-	 */
-	m0_mutex_lock(&fol->f_lock);
-	lsn = fol->f_lsn;
-	fol->f_lsn = lsn_inc(fol->f_lsn);
-	m0_mutex_unlock(&fol->f_lock);
-	M0_POST(m0_lsn_is_valid(lsn));
-	return lsn;
+#if !XXX_USE_DB5
+M0_INTERNAL void m0_fol_credit(const struct m0_fol *fol, enum m0_fol_op optype,
+			       m0_bcount_t nr, struct m0_be_tx_credit *accum)
+{
+	const struct m0_be_btree *tree = &fol->f_store;
+
+	M0_PRE(nr > 0);
+
+	switch (optype) {
+	case M0_FO_INIT:
+		/* Several m0_fol_init()s seem pointless. */
+		M0_ASSERT(nr == 1);
+		m0_be_btree_create_credit(tree, nr, accum);
+		m0_be_btree_insert_credit(tree, nr, FOL_KEY_SIZE,
+					  FOL_REC_MAXSIZE, accum);
+		/* This const-removing typecast is inelegant but it lets `fol'
+		 * parameter be const, while doing no no harm. */
+		m0_be_btree_destroy_credit((struct m0_be_btree *)tree, nr,
+					   accum);
+		break;
+	case M0_FO_REC_ADD:
+		m0_be_btree_insert_credit(tree, nr, FOL_KEY_SIZE,
+					  FOL_REC_MAXSIZE, accum);
+		break;
+	default:
+		M0_IMPOSSIBLE("Invalid optype");
+	}
 }
 
-M0_INTERNAL int m0_fol_add_buf(struct m0_fol *fol, struct m0_db_tx *tx,
-			       struct m0_fol_rec_desc *drec, struct m0_buf *buf)
+/** Inserts first record into the fol. */
+static int fol_zero(struct m0_fol *fol, struct m0_be_tx *tx)
 {
-	struct m0_db_pair pair;
+	struct m0_fol_rec rec;
+	int               rc;
 
-	M0_PRE(m0_lsn_is_valid(drec->rd_lsn));
+	M0_PRE(m0_be_btree_is_empty(&fol->f_store));
 
-	m0_db_pair_setup(&pair, &fol->f_table,
-			 &drec->rd_lsn, sizeof drec->rd_lsn,
-			 buf->b_addr, buf->b_nob);
-	return m0_table_insert(tx, &pair);
+	M0_CASSERT(M0_LSN_ANCHOR > M0_LSN_RESERVED_NR);
+
+	m0_fol_rec_init(&rec);
+	rec.fr_desc = (struct m0_fol_rec_desc){
+		.rd_header = { .rh_refcount = 1 },
+		.rd_lsn    = M0_LSN_ANCHOR
+	};
+	M0_BE_OP_SYNC(op, rc = m0_fol_rec_add(fol, &rec, tx, &op));
+	if (rc == 0)
+		fol->f_lsn = M0_LSN_ANCHOR + 1;
+
+	m0_fol_rec_fini(&rec);
+	return rc;
 }
 
-M0_INTERNAL int m0_fol_force(struct m0_fol *fol, m0_lsn_t upto)
+/** Increments m0_fol::f_lsn. */
+static int fol_inc(struct m0_fol *fol, struct m0_fol_rec *rec)
 {
-	return m0_dbenv_sync(fol->f_table.t_env);
+	int rc;
+
+	rc = m0_be_btree_cursor_last_sync(&rec->fr_ptr);
+	if (rc == 0) {
+		m0_be_btree_cursor_kv_get(&rec->fr_ptr, &rec->fr_key,
+					  &rec->fr_val);
+		fol->f_lsn = lsn_inc(rec->fr_desc.rd_lsn);
+	}
+	return rc;
+}
+
+static int fol_setup(struct m0_fol *fol, struct m0_be_tx *tx)
+{
+	struct m0_fol_rec rec;
+	int               rc;
+
+	M0_PRE(fol->f_store.bb_root != NULL);
+
+	rc = m0_fol_rec_lookup(fol, M0_LSN_ANCHOR, &rec);
+	if (rc == -ENOENT)
+		rc = fol_zero(fol, tx);
+	else if (rc == 0)
+		rc = fol_inc(fol, &rec);
+	else
+		return rc;
+
+	m0_fol_lookup_rec_fini(&rec);
+	return rc;
+}
+#endif
+
+/* ------------------------------------------------------------------
+ * FOL records and their parts
+ * ------------------------------------------------------------------ */
+
+/**
+ * Initializes fields in @rec.
+ *
+ * Note, that key buffer in the cursor is initialized to point to
+ * rec->fr_desc.rd_lsn. As a result, the cursor's key follows lsn changes
+ * automagically.
+ *
+ * @see m0_fol_rec_fini()
+ */
+#if XXX_USE_DB5
+static int rec_init(struct m0_fol_rec *rec, struct m0_db_tx *tx)
+{
+	struct m0_db_pair *pair;
+	M0_PRE(rec->fr_fol != NULL);
+
+	m0_fol_rec_init(rec);
+	pair = &rec->fr_pair;
+	m0_db_pair_setup(pair, &rec->fr_fol->f_table, &rec->fr_desc.rd_lsn,
+			 FOL_KEY_SIZE, NULL, 0);
+	return m0_db_cursor_init(&rec->fr_ptr, &rec->fr_fol->f_table, tx, 0);
+}
+#else
+static void rec_init(struct m0_fol_rec *rec, struct m0_fol *fol)
+{
+	M0_PRE(rec->fr_fol != NULL);
+
+	m0_fol_rec_init(rec);
+	rec->fr_fol = fol;
+	m0_buf_init(&rec->fr_key, &rec->fr_desc.rd_lsn, FOL_KEY_SIZE);
+	M0_SET0(&rec->fr_val);
+	m0_be_btree_cursor_init(&rec->fr_ptr, &rec->fr_fol->f_store);
+}
+#endif
+
+/**
+ * Finalizes @rec.
+ *
+ * @see rec_init()
+ */
+M0_INTERNAL void m0_fol_lookup_rec_fini(struct m0_fol_rec *rec)
+{
+#if XXX_USE_DB5
+	m0_db_cursor_fini(&rec->fr_ptr);
+	m0_db_pair_fini(&rec->fr_pair);
+#else
+	m0_be_btree_cursor_put(&rec->fr_ptr);
+	m0_be_btree_cursor_fini(&rec->fr_ptr);
+#endif
+	m0_fol_rec_fini(rec);
+}
+
+M0_INTERNAL void m0_fol_rec_init(struct m0_fol_rec *rec)
+{
+	m0_rec_part_tlist_init(&rec->fr_parts);
+}
+
+M0_INTERNAL void m0_fol_rec_fini(struct m0_fol_rec *rec)
+{
+	struct m0_fol_rec_part *part;
+
+	m0_tl_for(m0_rec_part, &rec->fr_parts, part) {
+		m0_fol_rec_part_fini(part);
+	} m0_tl_endfor;
+	m0_rec_part_tlist_fini(&rec->fr_parts);
 }
 
 M0_INTERNAL bool m0_fol_rec_invariant(const struct m0_fol_rec_desc *drec)
 {
+	const struct m0_fol_rec_header *h = &drec->rd_header;
 	uint32_t i;
 	uint32_t j;
 
 	if (!m0_lsn_is_valid(drec->rd_lsn))
 		return false;
-	for (i = 0; i < drec->rd_header.rh_obj_nr; ++i) {
+	if (h->rh_magic != M0_FOL_REC_MAGIC)
+		return false;
+	for (i = 0; i < h->rh_obj_nr; ++i) {
 		struct m0_fol_obj_ref *ref;
 
 		ref = &drec->rd_ref[i];
@@ -295,12 +475,13 @@ M0_INTERNAL bool m0_fol_rec_invariant(const struct m0_fol_rec_desc *drec)
 				return false;
 		}
 	}
+/* XXX DELETEME: Do we care about the disabled section?  --vvv */
 #if 0
 	if (!m0_epoch_is_valid(&drec->rd_epoch))
 		return false;
-	if (!m0_update_is_valid(&drec->rd_header.rh_self))
+	if (!m0_update_is_valid(&h->rh_self))
 		return false;
-	for (i = 0; i < drec->rd_header.rh_sibling_nr; ++i) {
+	for (i = 0; i < h->rh_sibling_nr; ++i) {
 		struct m0_fol_update_ref *upd;
 
 		upd = &drec->rd_sibling[i];
@@ -318,6 +499,43 @@ M0_INTERNAL bool m0_fol_rec_invariant(const struct m0_fol_rec_desc *drec)
 	return true;
 }
 
+M0_INTERNAL void m0_fol_rec_part_init(struct m0_fol_rec_part *part, void *data,
+				      const struct m0_fol_rec_part_type *type)
+{
+	M0_PRE(part != NULL);
+	M0_PRE(type != NULL && type->rpt_ops != NULL);
+
+	part->rp_data = data;
+	type->rpt_ops->rpto_rec_part_init(part);
+	m0_rec_part_tlink_init(part);
+}
+
+M0_INTERNAL void m0_fol_rec_part_fini(struct m0_fol_rec_part *part)
+{
+	M0_PRE(part != NULL);
+	M0_PRE(part->rp_ops != NULL);
+	M0_PRE(part->rp_data != NULL);
+
+	if (m0_rec_part_tlink_is_in(part))
+		m0_rec_part_tlist_del(part);
+	m0_rec_part_tlink_fini(part);
+
+	if (part->rp_flag == M0_XCODE_DECODE) {
+		m0_xcode_free(&REC_PART_XCODE_OBJ(part));
+		m0_free(part);
+	} else {
+	    if (part->rp_ops->rpo_type == &m0_fop_fol_rec_part_type) {
+		m0_free(part->rp_data);
+		m0_free(part);
+	    } else
+		m0_xcode_free(&REC_PART_XCODE_OBJ(part));
+	}
+}
+
+/* ------------------------------------------------------------------
+ * Record part types
+ * ------------------------------------------------------------------ */
+
 enum {
 	FOL_REC_PART_TYPE_MAX = 128,
 	PART_TYPE_START_INDEX = 1
@@ -385,107 +603,82 @@ fol_rec_part_type_lookup(uint32_t index)
 	M0_PRE(IS_IN_ARRAY(index, rptypes));
 	return rptypes[index];
 }
+
+/* ------------------------------------------------------------------
+ * Record encoding/decoding
+ * ------------------------------------------------------------------ */
 
-M0_INTERNAL void
-m0_fol_rec_part_init(struct m0_fol_rec_part *part, void *data,
-		     const struct m0_fol_rec_part_type *type)
+static m0_bcount_t fol_rec_header_pack_size(struct m0_fol_rec_header *h)
 {
-	M0_PRE(part != NULL);
-	M0_PRE(type != NULL && type->rpt_ops != NULL);
+	struct m0_xcode_ctx ctx;
+	int len = m0_xcode_data_size(&ctx, &M0_REC_HEADER_XCODE_OBJ(h));
 
-	part->rp_data = data;
-	type->rpt_ops->rpto_rec_part_init(part);
-	m0_rec_part_tlink_init(part);
+	M0_POST(len > 0);
+	return len;
 }
 
-M0_INTERNAL void m0_fol_rec_part_fini(struct m0_fol_rec_part *part)
+static size_t fol_record_pack_size(struct m0_fol_rec *rec)
 {
-	M0_PRE(part != NULL);
-	M0_PRE(part->rp_ops != NULL);
-	M0_PRE(part->rp_data != NULL);
-
-	if (m0_rec_part_tlink_is_in(part))
-		m0_rec_part_tlist_del(part);
-	m0_rec_part_tlink_fini(part);
+	struct m0_fol_rec_desc       *desc = &rec->fr_desc;
+	struct m0_fol_rec_header     *h = &desc->rd_header;
+	const struct m0_fol_rec_part *part;
+	struct m0_fol_rec_part_header rph;
+	struct m0_xcode_ctx           ctx;
+	m0_bcount_t                   len;
+
+	len = fol_rec_header_pack_size(h) +
+	      h->rh_obj_nr *
+		m0_xcode_data_size(&ctx, &REC_OBJ_REF_XCODE_OBJ(desc->rd_ref)) +
+	      h->rh_sibling_nr *
+		m0_xcode_data_size(&ctx,
+				   &REC_SIBLING_XCODE_OBJ(desc->rd_sibling)) +
+	      h->rh_parts_nr *
+		m0_xcode_data_size(&ctx, &REC_PART_HEADER_XCODE_OBJ(&rph));
+
+	m0_tl_for(m0_rec_part, &rec->fr_parts, part) {
+		len += m0_xcode_data_size(&ctx, &REC_PART_XCODE_OBJ(part));
+	} m0_tl_endfor;
 
-	if (part->rp_flag == M0_XCODE_DECODE) {
-		m0_xcode_free(&REC_PART_XCODE_OBJ(part));
-		m0_free(part);
-	} else {
-	    if (part->rp_ops->rpo_type == &m0_fop_fol_rec_part_type) {
-		m0_free(part->rp_data);
-		m0_free(part);
-	    } else
-		m0_xcode_free(&REC_PART_XCODE_OBJ(part));
-	}
+	len = m0_align(len, 8);
+#if !XXX_USE_DB5
+	M0_POST(len <= FOL_REC_MAXSIZE);
+#endif
+	return len;
 }
 
-M0_INTERNAL int m0_fol_rec_add(struct m0_fol *fol, struct m0_db_tx *tx,
-			       struct m0_fol_rec *rec)
+static int fol_rec_desc_encdec(struct m0_fol_rec_desc *desc,
+			       struct m0_bufvec_cursor *cur,
+			       enum m0_xcode_what what)
 {
-	int                     result;
-	struct m0_buf           buf;
-	struct m0_fol_rec_desc *desc;
-
-	M0_PRE(rec != NULL);
-	M0_PRE(fol != NULL);
-	M0_PRE(tx != NULL);
-
-	desc = &rec->fr_desc;
-	result = fol_record_encode(rec, &buf) ?:
-		 m0_fol_add_buf(fol, tx, desc, &buf);
-	if (result == 0)
-		m0_free(buf.b_addr);
-	return result;
-}
+	struct m0_fol_rec_header *h = &desc->rd_header;
+	uint32_t		  i;
+	int			  rc;
 
-static int fol_record_encode(struct m0_fol_rec *rec, struct m0_buf *out)
-{
-	void                   *buf;
-	size_t                  size;
-	int                     result;
-	struct m0_fol_rec_desc *desc = &rec->fr_desc;
+	M0_PRE(ergo(what == M0_XCODE_ENCODE, h->rh_magic == M0_FOL_REC_MAGIC));
 
-	desc->rd_header.rh_parts_nr =
-		m0_rec_part_tlist_length(&rec->fr_fol_rec_parts);
+	rc = m0_xcode_encdec(&M0_REC_HEADER_XCODE_OBJ(h), cur, what);
+	if (rc != 0)
+		return rc;
 
-	size = fol_record_pack_size(rec);
-	M0_ASSERT(M0_IS_8ALIGNED(size));
+	if (what == M0_XCODE_DECODE && h->rh_refcount == 0)
+		return -ENOENT;
 
-	desc->rd_header.rh_data_len = size;
+	for (i = 0; i < h->rh_obj_nr; ++i) {
+		struct m0_fol_obj_ref *r = &desc->rd_ref[i];
+		rc = m0_xcode_encdec(&REC_OBJ_REF_XCODE_OBJ(r), cur, what);
+		if (rc != 0)
+			return rc;
+	}
 
-	buf = m0_alloc(size);
-	if (buf != NULL) {
-		out->b_addr = buf;
-		out->b_nob  = size;
-		result = fol_record_pack(rec, out);
-	} else
-		result = -ENOMEM;
-	return result;
-}
+	for (i = 0; i < h->rh_sibling_nr; ++i) {
+		struct m0_fol_update_ref *r = &desc->rd_sibling[i];
+		rc = m0_xcode_encdec(&REC_SIBLING_XCODE_OBJ(r), cur, what);
+		if (rc != 0)
+			return rc;
+	}
 
-static size_t fol_record_pack_size(struct m0_fol_rec *rec)
-{
-	struct m0_fol_rec_desc       *desc = &rec->fr_desc;
-	struct m0_fol_rec_part       *part;
-	m0_bcount_t		      len;
-	struct m0_xcode_ctx	      ctx;
-	struct m0_fol_rec_part_header rp;
-
-	len = m0_xcode_data_size(&ctx,
-				 &M0_REC_HEADER_XCODE_OBJ(&desc->rd_header)) +
-	      desc->rd_header.rh_obj_nr *
-	      m0_xcode_data_size(&ctx, &REC_OBJ_REF_XCODE_OBJ(desc->rd_ref)) +
-	      desc->rd_header.rh_sibling_nr *
-	      m0_xcode_data_size(&ctx,
-				 &REC_SIBLING_XCODE_OBJ(desc->rd_sibling)) +
-	      desc->rd_header.rh_parts_nr *
-	      m0_xcode_data_size(&ctx, &REC_PART_HEADER_XCODE_OBJ(&rp));
-
-	m0_tl_for(m0_rec_part, &rec->fr_fol_rec_parts, part) {
-		len += m0_xcode_data_size(&ctx, &REC_PART_XCODE_OBJ(part));
-	} m0_tl_endfor;
-	return m0_align(len, 8);
+	M0_POST(ergo(what == M0_XCODE_DECODE, h->rh_magic == M0_FOL_REC_MAGIC));
+	return 0;
 }
 
 static int fol_record_pack(struct m0_fol_rec *rec, struct m0_buf *buf)
@@ -502,7 +695,7 @@ static int fol_record_pack(struct m0_fol_rec *rec, struct m0_buf *buf)
 	if (rc != 0)
 		return rc;
 
-	m0_tl_for(m0_rec_part, &rec->fr_fol_rec_parts, part) {
+	m0_tl_for(m0_rec_part, &rec->fr_parts, part) {
 		struct m0_fol_rec_part_header rph;
 		uint32_t		      index;
 
@@ -512,7 +705,7 @@ static int fol_record_pack(struct m0_fol_rec *rec, struct m0_buf *buf)
 
 		rph = (struct m0_fol_rec_part_header) {
 			.rph_index = index,
-			.rph_magic = M0_FOL_REC_PART_MAGIC,
+			.rph_magic = M0_FOL_REC_PART_MAGIC
 		};
 
 		rc = m0_xcode_encdec(&REC_PART_HEADER_XCODE_OBJ(&rph),
@@ -526,66 +719,43 @@ static int fol_record_pack(struct m0_fol_rec *rec, struct m0_buf *buf)
 	return rc;
 }
 
-static int fol_rec_desc_encdec(struct m0_fol_rec_desc *desc,
-			       struct m0_bufvec_cursor *cur,
-			       enum m0_xcode_what what)
+static int fol_record_encode(struct m0_fol_rec *rec, struct m0_buf *out)
 {
-	struct m0_fol_rec_header *h = &desc->rd_header;
-	int			  rc;
-	uint32_t		  i;
+	struct m0_fol_rec_header *h = &rec->fr_desc.rd_header;
+	size_t                    size;
+	void                     *buf;
 
-	rc = m0_xcode_encdec(&M0_REC_HEADER_XCODE_OBJ(h), cur, what);
-	if (rc != 0)
-		return rc;
+	h->rh_magic = M0_FOL_REC_MAGIC;
+	h->rh_parts_nr = m0_rec_part_tlist_length(&rec->fr_parts);
 
-	if (what == M0_XCODE_DECODE && h->rh_refcount == 0)
-		return -ENOENT;
+	size = fol_record_pack_size(rec);
+	M0_ASSERT(M0_IS_8ALIGNED(size));
 
-	for (i = 0, rc = 0; rc == 0 && i < h->rh_obj_nr; ++i) {
-		struct m0_fol_obj_ref *obj_ref = &desc->rd_ref[i];
-		rc = m0_xcode_encdec(&REC_OBJ_REF_XCODE_OBJ(obj_ref),
-				     cur, what);
-	}
-	if (rc != 0)
-		return rc;
+	h->rh_data_len = size;
 
-	for (i = 0, rc = 0; rc == 0 && i < h->rh_sibling_nr; ++i) {
-		struct m0_fol_update_ref *ur = &desc->rd_sibling[i];
-		rc = m0_xcode_encdec(&REC_SIBLING_XCODE_OBJ(ur), cur, what);
-	}
-	return rc;
-}
-
-M0_INTERNAL int m0_fol_rec_lookup(struct m0_fol *fol, struct m0_db_tx *tx,
-				  m0_lsn_t lsn, struct m0_fol_rec *out)
-{
-	int result;
+	buf = m0_alloc(size);
+	if (buf == NULL)
+		return -ENOMEM;
 
-	out->fr_fol = fol;
-	result = rec_init(out, tx);
-	if (result == 0) {
-		out->fr_desc.rd_lsn = lsn;
-		result = m0_db_cursor_get(&out->fr_ptr, &out->fr_pair) ?:
-			 fol_record_decode(out);
-		if (result != 0)
-			m0_fol_lookup_rec_fini(out);
-	}
-	M0_POST(ergo(result == 0, out->fr_desc.rd_lsn == lsn));
-	M0_POST(ergo(result == 0, out->fr_desc.rd_header.rh_refcount > 0));
-	M0_POST(ergo(result == 0, m0_fol_rec_invariant(&out->fr_desc)));
-	return result;
+	m0_buf_init(out, buf, size);
+	return fol_record_pack(rec, out);
 }
 
 static int fol_record_decode(struct m0_fol_rec *rec)
 {
+	struct m0_fol_rec_desc *desc = &rec->fr_desc;
+#if XXX_USE_DB5
 	struct m0_buf	       *rec_buf = &rec->fr_pair.dp_rec.db_buf;
 	void		       *buf = &rec_buf->b_addr;
-	m0_bcount_t	        len = rec_buf->b_nob;
+	m0_bcount_t		len = rec_buf->b_nob;
 	struct m0_bufvec	bvec = M0_BUFVEC_INIT_BUF(buf, &len);
+#else
+	struct m0_bufvec        bvec = M0_BUFVEC_INIT_BUF(&rec->fr_val.b_addr,
+							  &rec->fr_val.b_nob);
+#endif
 	struct m0_bufvec_cursor cur;
-	uint32_t		i;
-	struct m0_fol_rec_desc *desc = &rec->fr_desc;
-	int			rc;
+	uint32_t                i;
+	int                     rc;
 
 	m0_bufvec_cursor_init(&cur, &bvec);
 
@@ -594,12 +764,12 @@ static int fol_record_decode(struct m0_fol_rec *rec)
 		return rc;
 
 	for (i = 0; rc == 0 && i < desc->rd_header.rh_parts_nr; ++i) {
-		struct m0_fol_rec_part	          *part;
+		struct m0_fol_rec_part            *part;
 		const struct m0_fol_rec_part_type *part_type;
 		struct m0_fol_rec_part_header      ph;
 
-		rc = m0_xcode_encdec(&REC_PART_HEADER_XCODE_OBJ(&ph),
-				     &cur, M0_XCODE_DECODE);
+		rc = m0_xcode_encdec(&REC_PART_HEADER_XCODE_OBJ(&ph), &cur,
+				     M0_XCODE_DECODE);
 		if (rc == 0) {
 			void *rp_data;
 
@@ -618,14 +788,147 @@ static int fol_record_decode(struct m0_fol_rec *rec)
 			part->rp_flag = M0_XCODE_DECODE;
 
 			m0_fol_rec_part_init(part, rp_data, part_type);
-			rc = m0_xcode_encdec(&REC_PART_XCODE_OBJ(part),
-					     &cur, M0_XCODE_DECODE);
+			rc = m0_xcode_encdec(&REC_PART_XCODE_OBJ(part), &cur,
+					     M0_XCODE_DECODE);
 			if (rc == 0)
 				m0_fol_rec_part_add(rec, part);
 		}
 	}
 	return rc;
 }
+
+/* ------------------------------------------------------------------
+ * Adding and searching records
+ * ------------------------------------------------------------------ */
+
+#if XXX_USE_DB5
+M0_INTERNAL int m0_fol_rec_add(struct m0_fol *fol,
+			       struct m0_db_tx *tx,
+			       struct m0_fol_rec *rec)
+{
+	struct m0_buf buf;
+	int           rc;
+
+	rc = fol_record_encode(rec, &buf);
+	if (rc == 0) {
+		rc = m0_fol_add_buf(fol, tx, &rec->fr_desc, &buf));
+		m0_buf_free(&buf);
+	}
+	return rc;
+}
+#else
+M0_INTERNAL int m0_fol_rec_add(struct m0_fol *fol,
+			       struct m0_fol_rec *rec,
+			       struct m0_be_tx *tx,
+			       struct m0_be_op *op)
+{
+	struct m0_buf buf;
+	int           rc;
+
+	m0_be_op_state_set(op, M0_BOS_ACTIVE);
+
+	rc = fol_record_encode(rec, &buf);
+	if (rc == 0) {
+		M0_BE_OP_SYNC(local_op,
+			      rc = m0_fol_add_buf(fol, &rec->fr_desc, &buf, tx,
+						  &local_op));
+		m0_buf_free(&buf);
+	}
+
+	m0_be_op_state_set(op, M0_BOS_SUCCESS);
+	return rc;
+}
+#endif
+
+M0_INTERNAL void m0_fol_rec_part_add(struct m0_fol_rec *rec,
+				     struct m0_fol_rec_part *part)
+{
+	M0_PRE(rec != NULL && part != NULL);
+
+	m0_rec_part_tlist_add_tail(&rec->fr_parts, part);
+}
+
+#if XXX_USE_DB5
+M0_INTERNAL int m0_fol_add_buf(struct m0_fol *fol, struct m0_db_tx *tx,
+			       struct m0_fol_rec_desc *drec, struct m0_buf *buf)
+{
+	struct m0_db_pair pair;
+
+	M0_PRE(m0_lsn_is_valid(drec->rd_lsn));
+
+	m0_db_pair_setup(&pair, &fol->f_table, &drec->rd_lsn, FOL_KEY_SIZE,
+			 buf->b_addr, buf->b_nob);
+	return m0_table_insert(tx, &pair);
+}
+#else
+M0_INTERNAL int m0_fol_add_buf(struct m0_fol *fol, struct m0_fol_rec_desc *drec,
+			       struct m0_buf *buf,
+			       struct m0_be_tx *tx, struct m0_be_op *op)
+{
+	int rc;
+
+	M0_PRE(m0_lsn_is_valid(drec->rd_lsn));
+
+	m0_be_op_state_set(op, M0_BOS_ACTIVE);
+	rc = M0_BE_OP_SYNC_RET(
+		local_op,
+		m0_be_btree_insert(&fol->f_store, tx, &local_op,
+				   &M0_BUF_INIT(FOL_KEY_SIZE, &drec->rd_lsn),
+				   buf),
+		bo_u.u_btree.t_rc);
+	m0_be_op_state_set(op, M0_BOS_SUCCESS);
+	return rc;
+}
+#endif
+
+#if XXX_USE_DB5
+M0_INTERNAL int m0_fol_rec_lookup(struct m0_fol *fol, struct m0_db_tx *tx,
+				  m0_lsn_t lsn, struct m0_fol_rec *out)
+{
+	int result;
+
+	out->fr_fol = fol;
+	result = rec_init(out, tx);
+	if (result == 0) {
+		out->fr_desc.rd_lsn = lsn;
+		result = m0_db_cursor_get(&out->fr_ptr, &out->fr_pair) ?:
+			 fol_record_decode(out);
+		if (result != 0)
+			m0_fol_lookup_rec_fini(out);
+	}
+	M0_POST(ergo(result == 0, out->fr_desc.rd_lsn == lsn));
+	M0_POST(ergo(result == 0, out->fr_desc.rd_header.rh_refcount > 0));
+	M0_POST(ergo(result == 0, m0_fol_rec_invariant(&out->fr_desc)));
+	return result;
+}
+#else
+M0_INTERNAL int
+m0_fol_rec_lookup(struct m0_fol *fol, m0_lsn_t lsn, struct m0_fol_rec *out)
+{
+	struct m0_fol_rec_desc    *d   = &out->fr_desc;
+	struct m0_be_btree_cursor *cur = &out->fr_ptr;
+	int                        rc;
+
+	rec_init(out, fol);
+
+	d->rd_lsn = lsn;
+	rc = m0_be_btree_cursor_get_sync(cur, &out->fr_key, true);
+	if (rc != 0)
+		goto out;
+	m0_be_btree_cursor_kv_get(cur, &out->fr_key, &out->fr_val);
+
+	rc = fol_record_decode(out);
+	if (rc != 0)
+		goto out;
+
+	M0_POST(d->rd_header.rh_refcount > 0);
+	M0_POST(m0_fol_rec_invariant(d));
+out:
+	if (rc != 0)
+		m0_fol_lookup_rec_fini(out);
+	return rc;
+}
+#endif
 
 /** @} end of fol group */
 
diff --git a/fol/fol.h b/fol/fol.h
index eb41d0f..917f185 100644
--- a/fol/fol.h
+++ b/fol/fol.h
@@ -27,9 +27,10 @@
    @defgroup fol File operations log
 
    File operations log (fol) is a per-node collection of records, describing
-   updates to file system state carried out on the node. See HLD (url below) for
-   the description of requirements, usage patterns and constraints on fol, as
-   well as important terminology (update, operation, etc.).
+   updates to file system state carried out on the node. See HLD for the
+   description of requirements, usage patterns and constraints on fol,
+   as well as important terminology (update, operation, etc.):
+   https://docs.google.com/a/xyratex.com/document/d/1_5UGU0n7CATMiuG6V9eK3cMshiYFotPVnIy478MMnvM/comment .
 
    A fol is represented by an instance of struct m0_fol. A fol record has two
    data-types associated with it:
@@ -40,13 +41,13 @@
    location in the fol.
 
    A fol record contains the list of fol record parts, belonging to fol record
-   part types, added during updates. These fol record parts provides flexibility
+   part types, added during updates. These fol record parts provide flexibility
    for modules to participate in a transaction without global knowledge.
 
    @see m0_fol_rec_part : FOL record part.
    @see m0_fol_rec_part_type : FOL record part type.
 
-   m0_fol_rec_part_ops contains operations for undo and redo of
+   m0_fol_rec_part_ops structure contains operations for undo and redo of
    FOL record parts.
 
    @see m0_fol_rec_part_init() : Initializes m0_fol_rec_part with
@@ -56,18 +57,17 @@
    @see m0_fol_rec_part_type_register() : Registers FOL record part type.
    @see m0_fol_rec_part_type_deregister() : Deregisters FOL record part type.
 
-   FOL record parts list is kept in m0_fol_rec::fr_fol_rec_parts which is
-   initialized in m0_fol_rec_init()
+   FOL record parts list is kept in m0_fol_rec::fr_parts which is
+   initialized in m0_fol_rec_init().
 
    m0_fol_rec_add() is used to compose FOL record from FOL record descriptor
    and parts.
    fol_record_encode() encodes the FOL record parts in the list
-   m0_fol_rec:fr_fol_rec_parts in a buffer, which then will be added into the db
+   m0_fol_rec:fr_parts in a buffer, which then will be added into the db
    using m0_fol_add_buf().
 
    @see m0_fol_rec_add()
    @see m0_fol_rec_lookup()
-   @see https://docs.google.com/a/horizontalscale.com/Doc?docid=0Aa9lcGbR4emcZGhxY2hqdmdfNjQ2ZHZocWJ4OWo
 
    m0_fol_rec_part_type_init() and m0_fol_rec_part_type_fini() are added
    to initialize and finalize FOL part types.
@@ -77,9 +77,9 @@
    After successful execution of updates on server side, in FOM generic phase
    using m0_fom_fol_rec_add() FOL record parts in the list are combined in a
    FOL record and is made persistent. Before this phase all FOL record parts
-   needs to be added in the list after completing their updates.
+   need to be added in the list after completing their updates.
 
-   After retrieving FOL record from data base, FOL record parts are decoded
+   After retrieving FOL record from the storage, FOL record parts are decoded
    based on part type using index and are used in undo or redo operations.
    <hr>
    @section IOFOLDLD-conformance Conformance
@@ -87,30 +87,34 @@
    @{
  */
 
+#define XXX_USE_DB5 0
+
 /* export */
 struct m0_fol;
 struct m0_fol_rec_desc;
 struct m0_fol_rec;
 
 /* import */
-#include "lib/adt.h"      /* m0_buf */
-#include "lib/types.h"    /* uint64_t */
-#include "lib/arith.h"    /* M0_IS_8ALIGNED */
+#include "lib/types.h"      /* uint64_t */
+#include "lib/arith.h"      /* M0_IS_8ALIGNED */
 #include "lib/mutex.h"
-#include "lib/vec.h"
 #include "fid/fid.h"
-#include "dtm/dtm_update.h" /* m0_update_id, m0_update_state */
-#include "dtm/verno.h"    /* m0_verno */
-#include "db/db.h"        /* m0_table, m0_db_cursor */
-#include "fol/lsn.h"      /* m0_lsn_t */
-
+#include "dtm/dtm_update.h" /* m0_update_id, m0_epoch_id */
+#include "dtm/verno.h"      /* m0_verno */
+#if XXX_USE_DB5
+#  include "db/db.h"        /* m0_table, m0_db_cursor */
+#else
+#  include "be/btree.h"
+#endif
+#include "fol/lsn.h"        /* m0_lsn_t */
 #include "fid/fid_xc.h"
 #include "dtm/verno_xc.h"
 #include "dtm/dtm_update_xc.h"
 
+#if XXX_USE_DB5
 struct m0_dbenv;
 struct m0_db_tx;
-struct m0_epoch_id;
+#endif
 
 /**
    In-memory representation of a fol.
@@ -125,13 +129,18 @@ struct m0_epoch_id;
    functions against the same fol (except for m0_fol_init() and m0_fol_fini()).
  */
 struct m0_fol {
+#if XXX_USE_DB5
 	/** Table where fol records are stored. */
-	struct m0_table f_table;
+	struct m0_table    f_table;
+#else
+	/** KV storage of fol records. */
+	struct m0_be_btree f_store;
+#endif
 	/** Next lsn to use in the fol. */
-	m0_lsn_t        f_lsn;
+	m0_lsn_t           f_lsn;
 	/** Lock, serializing fol access. */
-	struct m0_mutex f_lock;
-	struct m0_reqh *f_reqh;
+	struct m0_mutex    f_lock;
+	struct m0_reqh    *f_reqh;
 };
 
 /**
@@ -140,9 +149,29 @@ struct m0_fol {
 
    @post ergo(result == 0, m0_lsn_is_valid(fol->f_lsn))
  */
+#if XXX_USE_DB5
 M0_INTERNAL int m0_fol_init(struct m0_fol *fol, struct m0_dbenv *env);
+#else
+M0_INTERNAL int m0_fol_init(struct m0_fol *fol, struct m0_be_seg *seg,
+			    struct m0_be_tx *tx, struct m0_be_op *op);
+#endif
 M0_INTERNAL void m0_fol_fini(struct m0_fol *fol);
 
+#if !XXX_USE_DB5
+/** Fol operations that modify back-end segment. */
+enum m0_fol_op {
+	M0_FO_INIT,    /**< m0_fol_init() */
+	M0_FO_REC_ADD  /**< m0_fol_rec_add() */
+};
+
+/**
+ * Calculates the credit needed to perform `nr' fol operations of type
+ * `optype' and adds this credit to `accum'.
+ */
+M0_INTERNAL void m0_fol_credit(const struct m0_fol *fol, enum m0_fol_op optype,
+			       m0_bcount_t nr, struct m0_be_tx_credit *accum);
+#endif
+
 /**
    Adds a record to the fol, in the transaction context.
 
@@ -155,24 +184,41 @@ M0_INTERNAL void m0_fol_fini(struct m0_fol *fol);
    @pre m0_lsn_is_valid(drec->rd_lsn);
    @see m0_fol_add_buf()
  */
-M0_INTERNAL int m0_fol_rec_add(struct m0_fol *fol, struct m0_db_tx *tx,
+#if XXX_USE_DB5
+M0_INTERNAL int m0_fol_rec_add(struct m0_fol *fol,
+			       struct m0_db_tx *tx,
 			       struct m0_fol_rec *rec);
-
-/**
-   Reserves and returns lsn.
-
-   @post m0_lsn_is_valid(result);
- */
-M0_INTERNAL m0_lsn_t m0_fol_lsn_allocate(struct m0_fol *fol);
+#else
+M0_INTERNAL int m0_fol_rec_add(struct m0_fol *fol,
+			       struct m0_fol_rec *rec,
+			       struct m0_be_tx *tx,
+			       struct m0_be_op *op);
+#endif
 
 /**
    Similar to m0_fol_rec_add(), but with a record already packed into a buffer.
 
    @pre m0_lsn_is_valid(drec->rd_lsn);
  */
-M0_INTERNAL int m0_fol_add_buf(struct m0_fol *fol, struct m0_db_tx *tx,
+#if XXX_USE_DB5
+M0_INTERNAL int m0_fol_add_buf(struct m0_fol *fol,
+			       struct m0_db_tx *tx,
 			       struct m0_fol_rec_desc *drec,
 			       struct m0_buf *buf);
+#else
+M0_INTERNAL int m0_fol_add_buf(struct m0_fol *fol,
+			       struct m0_fol_rec_desc *drec,
+			       struct m0_buf *buf,
+			       struct m0_be_tx *tx,
+			       struct m0_be_op *op);
+#endif
+
+/**
+   Reserves and returns lsn.
+
+   @post m0_lsn_is_valid(result);
+ */
+M0_INTERNAL m0_lsn_t m0_fol_lsn_allocate(struct m0_fol *fol);
 
 /**
    Forces the log.
@@ -221,9 +267,9 @@ struct m0_fol_obj_ref {
    @todo More detailed description is to be supplied as part of DTM design.
  */
 struct m0_fol_update_ref {
-	/* taken from enum m0_update_state  */
-	uint32_t             ur_state;
-	struct m0_update_id  ur_id;
+	/* taken from enum m0_update_state */
+	uint32_t            ur_state;
+	struct m0_update_id ur_id;
 } M0_XCA_RECORD;
 
 /**
@@ -232,22 +278,27 @@ struct m0_fol_update_ref {
    @see m0_fol_rec_desc
  */
 struct m0_fol_rec_header {
-	/** number of outstanding references to the record */
+	/** Number of outstanding references to the record. */
 	uint64_t            rh_refcount;
-	/** number of objects modified by this update */
+	/** Number of objects modified by this update. */
 	uint32_t            rh_obj_nr;
-	/** number of sibling updates in the same operation */
+	/** Number of sibling updates in the same operation. */
 	uint32_t            rh_sibling_nr;
-	/** number of record parts added to the record */
+	/** Number of record parts added to the record. */
 	uint32_t            rh_parts_nr;
-	/** length of the remaining operation type specific data in bytes */
+	/**
+	 * Length of the remaining operation type specific data in bytes.
+	 *
+	 * @note XXX Currently this is the length of encoded record.
+	 */
 	uint32_t            rh_data_len;
 	/**
-	    Identifier of this update.
-
-	    @note that the update might be for a different node.
+	 * Identifier of this update.
+	 *
+	 * @note The update might be for a different node.
 	 */
 	struct m0_update_id rh_self;
+	uint64_t            rh_magic;
 } M0_XCA_RECORD;
 
 M0_BASSERT(M0_IS_8ALIGNED(sizeof(struct m0_fol_rec_header)));
@@ -270,15 +321,15 @@ M0_BASSERT(M0_IS_8ALIGNED(sizeof(struct m0_fol_update_ref)));
    it is done with inspecting the record.
  */
 struct m0_fol_rec_desc {
-	/** record log sequence number */
-	m0_lsn_t                      rd_lsn;
-	struct m0_fol_rec_header      rd_header;
-	/** references to the objects modified by this update. */
-	struct m0_fol_obj_ref        *rd_ref;
-	/** a DTM epoch this update is a part of. */
-	struct m0_epoch_id           *rd_epoch;
-	/** identifiers of sibling updates. */
-	struct m0_fol_update_ref     *rd_sibling;
+	/** Record log sequence number. */
+	m0_lsn_t                  rd_lsn;
+	struct m0_fol_rec_header  rd_header;
+	/** References to the objects modified by this update. */
+	struct m0_fol_obj_ref    *rd_ref;
+	/** A DTM epoch this update is a part of. */
+	struct m0_epoch_id       *rd_epoch;
+	/** Identifiers of sibling updates. */
+	struct m0_fol_update_ref *rd_sibling;
 };
 
 /**
@@ -310,17 +361,23 @@ struct m0_fol_rec_desc {
    fields (reference counter and sibling updates state).
  */
 struct m0_fol_rec {
-	struct m0_fol               *fr_fol;
-	struct m0_fol_rec_desc       fr_desc;
+	struct m0_fol            *fr_fol;
+	struct m0_fol_rec_desc    fr_desc;
 	/**
 	   A list of all FOL record parts in a record.
 	   Record parts are linked through m0_fol_rec_part:rp_link to this list.
 	 */
-	struct m0_tl		     fr_fol_rec_parts;
+	struct m0_tl              fr_parts;
 	/** cursor in the underlying data-base, pointing to the record location
 	    in the fol. */
-	struct m0_db_cursor          fr_ptr;
-	struct m0_db_pair            fr_pair;
+#if XXX_USE_DB5
+	struct m0_db_cursor       fr_ptr;
+	struct m0_db_pair         fr_pair;
+#else
+	struct m0_be_btree_cursor fr_ptr;
+	struct m0_buf             fr_key;
+	struct m0_buf             fr_val;
+#endif
 };
 
 /** Initializes fol record parts list. */
@@ -338,7 +395,10 @@ M0_INTERNAL void m0_fol_rec_fini(struct m0_fol_rec *rec);
    @post ergo(result == 0, out->fr_d.rd_refcount > 0)
    @post ergo(result == 0, m0_fol_rec_invariant(&out->fr_d))
  */
-M0_INTERNAL int m0_fol_rec_lookup(struct m0_fol *fol, struct m0_db_tx *tx,
+M0_INTERNAL int m0_fol_rec_lookup(struct m0_fol *fol,
+#if XXX_USE_DB5
+				  struct m0_db_tx *tx,
+#endif
 				  m0_lsn_t lsn, struct m0_fol_rec *out);
 
 /**
@@ -429,8 +489,13 @@ struct m0_fol_rec_part_type_ops {
  */
 struct m0_fol_rec_part_ops {
 	const struct m0_fol_rec_part_type *rpo_type;
+#if XXX_USE_DB5
 	int (*rpo_undo)(struct m0_fol_rec_part *part, struct m0_db_tx *tx);
 	int (*rpo_redo)(struct m0_fol_rec_part *part, struct m0_db_tx *tx);
+#else
+	int (*rpo_undo)(struct m0_fol_rec_part *part, struct m0_be_tx *tx);
+	int (*rpo_redo)(struct m0_fol_rec_part *part, struct m0_be_tx *tx);
+#endif
 };
 
 struct m0_fol_rec_part_header {
@@ -490,10 +555,9 @@ static const struct m0_fol_rec_part_type_ops part ## _type_ops = { \
 #define M0_FOL_REC_PART_TYPE_INIT(part, name)		        \
 part ## _type = M0_FOL_REC_PART_TYPE_XC_OPS(name, part ## _xc,  \
 				            &part ## _type_ops)
-/** @} end of fol group */
 
-/* __MERO_FOL_FOL_H__ */
-#endif
+/** @} end of fol group */
+#endif /* __MERO_FOL_FOL_H__ */
 
 /*
  *  Local variables:
diff --git a/fol/fol_private.h b/fol/fol_private.h
index 356f3bb..3ed805d 100644
--- a/fol/fol_private.h
+++ b/fol/fol_private.h
@@ -25,8 +25,7 @@
 
 #define M0_REC_HEADER_XCODE_OBJ(ptr) M0_XCODE_OBJ(m0_fol_rec_header_xc, ptr)
 
-/* __MERO_FOL_FOL_PRIVATE_H__ */
-#endif
+#endif /* __MERO_FOL_FOL_PRIVATE_H__ */
 
 /*
  *  Local variables:
diff --git a/fol/lsn.h b/fol/lsn.h
index 2c46f8e..5bbc24c 100644
--- a/fol/lsn.h
+++ b/fol/lsn.h
@@ -69,12 +69,12 @@ enum {
 
 /** True iff the argument might be an lsn of an existing fol record. */
 M0_INTERNAL bool m0_lsn_is_valid(m0_lsn_t lsn);
+
 /** 3-way comparison (-1, 0, +1) of lsns, compatible with record
     dependencies. */
 M0_INTERNAL int m0_lsn_cmp(m0_lsn_t lsn0, m0_lsn_t lsn1);
 
-/* __MERO_FOL_LSN_H__ */
-#endif
+#endif /* __MERO_FOL_LSN_H__ */
 
 /*
  *  Local variables:
diff --git a/fol/ut/fol.c b/fol/ut/fol.c
index 82381ee..7bef5ca 100644
--- a/fol/ut/fol.c
+++ b/fol/ut/fol.c
@@ -15,75 +15,158 @@
  * http://www.xyratex.com/contact
  *
  * Original author: Nikita Danilov <nikita_danilov@xyratex.com>
- * Original creation date: 09/16/2010
+ * Original creation date: 16-Sep-2010
  */
 
-
-#include "ut/ut.h"
-#include "lib/ub.h"
-#include "lib/memory.h"
-#include "lib/misc.h"              /* M0_SET0 */
 #include "fol/fol.h"
-#include "rpc/rpc_opcodes.h"
-#include "fid/fid_xc.h"
 #include "fol/fol_private.h"
 #include "fol/fol_xc.h"
+#if !XXX_USE_DB5
+#  include "ut/be.h"
+#  include "ut/ast_thread.h"
+/* XXX FIXME: Do not use ut/ directory of other subsystem. */
+#  include "be/ut/helper.h"   /* m0_be_ut_backend */
+#endif
 
-static const char db_name[] = "ut-fol";
+#include "fid/fid_xc.h"
+#include "rpc/rpc_opcodes.h"
+#include "lib/memory.h"
+#include "lib/misc.h"         /* M0_SET0 */
 
-static int db_reset(void)
-{
-        return m0_ut_db_reset(db_name);
-}
+#include "ut/ut.h"
+#include "lib/ub.h"
 
-static struct m0_dbenv           db;
+#if XXX_USE_DB5
+static const char db_name[] = "ut-fol";
+
+static struct m0_fol_rec_header *h;
+static struct m0_fol_rec_desc   *d;
 static struct m0_fol             fol;
-static struct m0_db_tx           tx;
 static struct m0_fol_rec         r;
-static struct m0_fol_rec_desc   *d;
-static struct m0_fol_rec_header *h;
 static struct m0_buf             buf;
-
-static int result;
-
-static int verify_part_data(struct m0_fol_rec_part *part, struct m0_db_tx *tx);
+static struct m0_dbenv           db;
+static struct m0_db_tx           tx;
+#else
+static struct m0_fol            *g_fol;
+static struct m0_fol_rec_header *g_hdr;
+static struct m0_fol_rec_desc   *g_desc;
+static struct m0_fol_rec         g_rec;
+static struct m0_be_ut_backend   g_ut_be;
+static struct m0_be_ut_seg       g_ut_seg;
+static struct m0_be_tx           g_tx;
+#endif
+
+#if XXX_USE_DB5
+static int db_reset(void)
+{
+	return m0_ut_db_reset(db_name);
+}
+#endif
+
+static int verify_part_data(struct m0_fol_rec_part *part,
+#if XXX_USE_DB5
+			    struct m0_db_tx *tx
+#else
+			    struct m0_be_tx *tx
+#endif
+	);
 M0_FOL_REC_PART_TYPE_DECLARE(ut_part, static, verify_part_data, NULL);
 
 static void test_init(void)
 {
-	result = m0_dbenv_init(&db, db_name, 0);
-	M0_ASSERT(result == 0);
+#if XXX_USE_DB5
+	rc = m0_dbenv_init(&db, db_name, 0);
+	M0_ASSERT(rc == 0);
 
-	result = m0_fol_init(&fol, &db);
-	M0_ASSERT(result == 0);
+	rc = m0_fol_init(&fol, &db);
+	M0_ASSERT(rc == 0);
 
-	result = m0_db_tx_init(&tx, &db, 0);
-	M0_ASSERT(result == 0);
+	rc = m0_db_tx_init(&tx, &db, 0);
+	M0_ASSERT(rc == 0);
 
 	m0_fol_rec_init(&r);
 
 	d = &r.fr_desc;
 	h = &d->rd_header;
+#else
+	M0_BE_TX_CREDIT(cred);
+	int rc;
+
+	m0_ut_backend_init(&g_ut_be, &g_ut_seg);
+
+	g_fol = m0_ut_be_alloc(sizeof *g_fol, &g_ut_seg.bus_seg, &g_ut_be);
+	M0_UT_ASSERT(g_fol != NULL);
+
+	m0_fol_credit(g_fol, M0_FO_INIT, 1, &cred);
+	/*
+	 * There are 3 m0_fol_rec_add() calls --- in functions test_add(),
+	 * test_lookup(), and test_fol_rec_part_encdec().
+	 */
+	m0_fol_credit(g_fol, M0_FO_REC_ADD, 3, &cred);
+	m0_ut_be_tx_begin(&g_tx, &g_ut_be, &cred);
+
+	M0_BE_OP_SYNC(op,
+		      rc = m0_fol_init(g_fol, &g_ut_seg.bus_seg, &g_tx, &op));
+	M0_UT_ASSERT(rc == 0);
+
+	m0_fol_rec_init(&g_rec);
+	g_desc = &g_rec.fr_desc;
+	g_hdr = &g_desc->rd_header;
+#endif
 }
 
 static void test_fini(void)
 {
+#if XXX_USE_DB5
 	m0_fol_rec_fini(&r);
 
-	result = m0_db_tx_commit(&tx);
-	M0_ASSERT(result == 0);
+	rc = m0_db_tx_commit(&tx);
+	M0_ASSERT(rc == 0);
 
 	m0_fol_fini(&fol);
 	m0_dbenv_fini(&db);
-	m0_free(buf.b_addr);
+	m0_buf_free(&buf);
+#else
+	m0_fol_rec_fini(&g_rec);
+
+	m0_ut_be_tx_end(&g_tx);
+	/*
+	 * The call fails with the following error message:
+	 *
+	 * | Suite: fol-ut
+	 * |   Test: fol-init ...passed  0.221908 sec
+	 * |   Test: fol-rec-part-type-reg ...passed  0.9 sec
+	 * |   Test: fol-add ...passed  0.599 sec
+	 * |   Test: fol-lookup ...passed  0.842 sec
+	 * |   Test: fol-rec-part-test ...passed  0.2984 sec
+	 * |   Test: fol-rec-part-type-unreg ...passed  0.6 sec
+	 * |   Test: fol-fini ...mero:  FATAL : [lib/assert.c:42:m0_panic] panic: m0_vec_count(&io->si_user.ov_vec) > 0 linux_stob_io_launch() (stob/linux_adieu.c:222)
+	 * | Mero panic: m0_vec_count(&io->si_user.ov_vec) > 0 at linux_stob_io_launch() stob/linux_adieu.c:222 (errno: 0) (last failed: none)
+	 *
+	 * The backtrace:
+	 *
+	 * fom_exec
+	 *  \_ tx_group_fom_tick
+	 *      \_ m0_be_tx_group__place
+	 *          \_ m0_be_io_launch
+	 *              \_ m0_stob_io_launch
+	 *                  \_ linux_stob_io_launch
+	 *                      \_ M0_PRE(m0_vec_count(&io->si_user.ov_vec) > 0)	 */
+	m0_fol_fini(g_fol);
+
+	m0_ut_be_free(g_fol, sizeof *g_fol, &g_ut_seg.bus_seg, &g_ut_be);
+	m0_ut_backend_fini(&g_ut_be, &g_ut_seg);
+#endif
 }
 
 static void test_rec_part_type_reg(void)
 {
+	int rc;
+
 	ut_part_type = M0_FOL_REC_PART_TYPE_XC_OPS("UT record part", m0_fid_xc,
 						   &ut_part_type_ops);
-	result =  m0_fol_rec_part_type_register(&ut_part_type);
-	M0_ASSERT(result == 0);
+	rc = m0_fol_rec_part_type_register(&ut_part_type);
+	M0_ASSERT(rc == 0);
 	M0_ASSERT(ut_part_type.rpt_index > 0);
 }
 
@@ -97,40 +180,78 @@ static void test_rec_part_type_unreg(void)
 
 static void test_add(void)
 {
+#if XXX_USE_DB5
 	M0_SET0(h);
-
 	h->rh_refcount = 1;
 
 	d->rd_lsn = m0_fol_lsn_allocate(&fol);
-	result = m0_fol_rec_add(&fol, &tx, &r);
-	M0_ASSERT(result == 0);
+	rc = m0_fol_rec_add(&fol, &tx, &r);
+	M0_ASSERT(rc == 0);
+#else
+	int rc;
+
+	M0_SET0(g_hdr);
+	g_hdr->rh_refcount = 1;
+
+	g_desc->rd_lsn = m0_fol_lsn_allocate(g_fol);
+	M0_BE_OP_SYNC(op, rc = m0_fol_rec_add(g_fol, &g_rec, &g_tx, &op));
+	M0_ASSERT(rc == 0);
+#endif
 }
 
 extern m0_lsn_t lsn_inc(m0_lsn_t lsn);
 
 static void test_lookup(void)
 {
+#if XXX_USE_DB5
 	struct m0_fol_rec dup;
 
 	d->rd_lsn = m0_fol_lsn_allocate(&fol);
-	result = m0_fol_rec_add(&fol, &tx, &r);
-	M0_ASSERT(result == 0);
+	rc = m0_fol_rec_add(&fol, &tx, &r);
+	M0_ASSERT(rc == 0);
 
-	result = m0_fol_rec_lookup(&fol, &tx, d->rd_lsn, &dup);
-	M0_ASSERT(result == 0);
+	rc = m0_fol_rec_lookup(&fol, &tx, d->rd_lsn, &dup);
+	M0_ASSERT(rc == 0);
 
 	M0_ASSERT(dup.fr_desc.rd_lsn == d->rd_lsn);
 	M0_ASSERT(m0_xcode_cmp(&M0_REC_HEADER_XCODE_OBJ(&d->rd_header),
 			       &M0_REC_HEADER_XCODE_OBJ(&dup.fr_desc.rd_header))
-	          == 0);
+		  == 0);
 
 	m0_fol_lookup_rec_fini(&dup);
 
-	result = m0_fol_rec_lookup(&fol, &tx, lsn_inc(d->rd_lsn), &dup);
-	M0_ASSERT(result == -ENOENT);
+	rc = m0_fol_rec_lookup(&fol, &tx, lsn_inc(d->rd_lsn), &dup);
+	M0_ASSERT(rc == -ENOENT);
+#else
+	struct m0_fol_rec dup;
+	int               rc;
+
+	g_desc->rd_lsn = m0_fol_lsn_allocate(g_fol);
+	M0_BE_OP_SYNC(op, rc = m0_fol_rec_add(g_fol, &g_rec, &g_tx, &op));
+	M0_ASSERT(rc == 0);
+
+	rc = m0_fol_rec_lookup(g_fol, g_desc->rd_lsn, &dup);
+	M0_ASSERT(rc == 0);
+
+	M0_ASSERT(dup.fr_desc.rd_lsn == g_desc->rd_lsn);
+	M0_ASSERT(m0_xcode_cmp(&M0_REC_HEADER_XCODE_OBJ(&g_desc->rd_header),
+			       &M0_REC_HEADER_XCODE_OBJ(&dup.fr_desc.rd_header))
+		  == 0);
+
+	m0_fol_lookup_rec_fini(&dup);
+
+	rc = m0_fol_rec_lookup(g_fol, lsn_inc(g_desc->rd_lsn), &dup);
+	M0_ASSERT(rc == -ENOENT);
+#endif
 }
 
-static int verify_part_data(struct m0_fol_rec_part *part, struct m0_db_tx *tx)
+static int verify_part_data(struct m0_fol_rec_part *part,
+#if XXX_USE_DB5
+			    struct m0_db_tx *_
+#else
+			    struct m0_be_tx *_
+#endif
+	)
 {
 	struct m0_fid *dec_rec;
 
@@ -142,72 +263,122 @@ static int verify_part_data(struct m0_fol_rec_part *part, struct m0_db_tx *tx)
 
 static void test_fol_rec_part_encdec(void)
 {
-	struct m0_fid	       *rec;
+	struct m0_fid          *rec;
 	struct m0_fol_rec       dec_rec;
 	struct m0_fol_rec_part  ut_rec_part;
-	m0_lsn_t		lsn;
+	m0_lsn_t                lsn;
 	struct m0_fol_rec_part *dec_part;
+#if !XXX_USE_DB5
+	int                     rc;
 
+	m0_fol_rec_init(&g_rec);
+#else
 	m0_fol_rec_init(&r);
+#endif
+
 	M0_ALLOC_PTR(rec);
 	M0_UT_ASSERT(rec != NULL);
-
-	rec->f_container = 22;
-	rec->f_key	 = 33;
+	*rec = (struct m0_fid){ .f_container = 22, .f_key = 33 };
 
 	m0_fol_rec_part_init(&ut_rec_part, rec, &ut_part_type);
-
+#if XXX_USE_DB5
 	m0_fol_rec_part_add(&r, &ut_rec_part);
 
 	h->rh_refcount = 1;
 	lsn = d->rd_lsn = m0_fol_lsn_allocate(&fol);
 
-	result = m0_fol_rec_add(&fol, &tx, &r);
-	M0_ASSERT(result == 0);
+	rc = m0_fol_rec_add(&fol, &tx, &r);
+	M0_ASSERT(rc == 0);
 
-	result = m0_db_tx_commit(&tx);
-	M0_ASSERT(result == 0);
+	rc = m0_db_tx_commit(&tx);
+	M0_ASSERT(rc == 0);
 	m0_fol_rec_fini(&r);
 
-	result = m0_db_tx_init(&tx, &db, 0);
-	M0_ASSERT(result == 0);
+	rc = m0_db_tx_init(&tx, &db, 0);
+	M0_ASSERT(rc == 0);
 
-	result = m0_fol_rec_lookup(&fol, &tx, lsn, &dec_rec);
-	M0_ASSERT(result == 0);
+	rc = m0_fol_rec_lookup(&fol, &tx, lsn, &dec_rec);
+	M0_ASSERT(rc == 0);
 
-	m0_tl_for(m0_rec_part, &dec_rec.fr_fol_rec_parts, dec_part) {
+	m0_tl_for(m0_rec_part, &dec_rec.fr_parts, dec_part) {
+		/* Call verify_part_data() for each part. */
 		dec_part->rp_ops->rpo_undo(dec_part, &tx);
 	} m0_tl_endfor;
+#else
+	m0_fol_rec_part_add(&g_rec, &ut_rec_part);
+
+	g_hdr->rh_refcount = 1;
+	lsn = g_desc->rd_lsn = m0_fol_lsn_allocate(g_fol);
+
+	M0_BE_OP_SYNC(op, rc = m0_fol_rec_add(g_fol, &g_rec, &g_tx, &op));
+	M0_ASSERT(rc == 0);
+
+	m0_fol_rec_fini(&g_rec);
+
+	m0_ut_be_tx_end(&g_tx);
+	m0_ut_be_tx_begin(&g_tx, &g_ut_be, &M0_BE_TX_CREDIT_OBJ(0, 0));
+
+	rc = m0_fol_rec_lookup(g_fol, lsn, &dec_rec);
+	M0_ASSERT(rc == 0);
 
+	m0_tl_for(m0_rec_part, &dec_rec.fr_parts, dec_part) {
+		/* Call verify_part_data() for each part. */
+		dec_part->rp_ops->rpo_undo(dec_part, &g_tx);
+	} m0_tl_endfor;
+#endif
 	m0_fol_lookup_rec_fini(&dec_rec);
 }
+
+#if !XXX_USE_DB5
+extern struct m0_sm_group ut__txs_sm_group;
+
+static int _init(void)
+{
+	m0_sm_group_init(&ut__txs_sm_group);
+	return m0_ut_ast_thread_start(&ut__txs_sm_group);
+}
+
+static int _fini(void)
+{
+	m0_ut_ast_thread_stop();
+	m0_sm_group_fini(&ut__txs_sm_group);
+	return 0;
+}
+#endif /* XXX_USE_DB5 */
 
 const struct m0_test_suite fol_ut = {
 	.ts_name = "fol-ut",
+#if XXX_USE_DB5
 	.ts_init = db_reset,
-	/* .ts_fini = db_reset, */
+#else
+	.ts_init = _init,
+	.ts_fini = _fini,
+#endif
 	.ts_tests = {
-		{ "fol-init", test_init },
-		{ "fol-rec-part-type-reg", test_rec_part_type_reg },
-		{ "fol-add", test_add },
-		{ "fol-lookup", test_lookup },
-		{ "fol-rec-part-test", test_fol_rec_part_encdec},
+		/*
+		 * Note, that there are dependencies between these tests.
+		 * Do not reorder them willy-nilly.
+		 */
+		{ "fol-init",                test_init                },
+		{ "fol-rec-part-type-reg",   test_rec_part_type_reg   },
+		{ "fol-add",                 test_add                 },
+		{ "fol-lookup",              test_lookup              },
+		{ "fol-rec-part-test",       test_fol_rec_part_encdec },
 		{ "fol-rec-part-type-unreg", test_rec_part_type_unreg },
-		{ "fol-fini", test_fini },
+		{ "fol-fini",                test_fini                },
 		{ NULL, NULL }
 	}
 };
-
-/*
+
+/* ------------------------------------------------------------------
  * UB
- */
+ * ------------------------------------------------------------------ */
 
-enum {
-	UB_ITER = 100000
-};
+enum { UB_ITER = 100000 };
 
 static int ub_init(const char *opts M0_UNUSED)
 {
+#if XXX_USE_DB5
 	db_reset();
 	test_init();
 	test_rec_part_type_reg();
@@ -215,6 +386,11 @@ static int ub_init(const char *opts M0_UNUSED)
 	M0_SET0(h);
 
 	h->rh_refcount = 1;
+#else
+	test_init();
+	test_rec_part_type_reg();
+	*g_hdr = (struct m0_fol_rec_header){ .rh_refcount = 1 };
+#endif
 	return 0;
 }
 
@@ -222,27 +398,30 @@ static void ub_fini(void)
 {
 	test_rec_part_type_unreg();
 	test_fini();
+#if XXX_USE_DB5
 	db_reset();
+#endif
 }
 
+#if XXX_USE_DB5
 static m0_lsn_t last;
 
 static void checkpoint()
 {
-	result = m0_db_tx_commit(&tx);
-	M0_ASSERT(result == 0);
+	rc = m0_db_tx_commit(&tx);
+	M0_ASSERT(rc == 0);
 
-	result = m0_db_tx_init(&tx, &db, 0);
-	M0_ASSERT(result == 0);
+	rc = m0_db_tx_init(&tx, &db, 0);
+	M0_ASSERT(rc == 0);
 }
 
 static void ub_insert(int i)
 {
 	d->rd_lsn = m0_fol_lsn_allocate(&fol);
-	result = m0_fol_rec_add(&fol, &tx, &r);
-	M0_ASSERT(result == 0);
+	rc = m0_fol_rec_add(&fol, &tx, &r);
+	M0_ASSERT(rc == 0);
 	last = d->rd_lsn;
-	if (i%1000 == 0)
+	if (i % 1000 == 0)
 		checkpoint();
 }
 
@@ -253,27 +432,29 @@ static void ub_lookup(int i)
 
 	lsn = last - i;
 
-	result = m0_fol_rec_lookup(&fol, &tx, lsn, &rec);
-	M0_ASSERT(result == 0);
+	rc = m0_fol_rec_lookup(&fol, &tx, lsn, &rec);
+	M0_ASSERT(rc == 0);
 	m0_fol_lookup_rec_fini(&rec);
-	if (i%1000 == 0)
+	if (i % 1000 == 0)
 		checkpoint();
 }
 
 static void ub_insert_buf(int i)
 {
 	d->rd_lsn = m0_fol_lsn_allocate(&fol);
-	result = m0_fol_add_buf(&fol, &tx, d, &buf);
-	M0_ASSERT(result == 0);
-	if (i%1000 == 0)
+	rc = m0_fol_add_buf(&fol, &tx, d, &buf);
+	M0_ASSERT(rc == 0);
+	if (i % 1000 == 0)
 		checkpoint();
 }
+#endif
 
 struct m0_ub_set m0_fol_ub = {
 	.us_name = "fol-ub",
 	.us_init = ub_init,
 	.us_fini = ub_fini,
 	.us_run  = {
+#if XXX_USE_DB5
 		{ .ub_name = "insert",
 		  .ub_iter = UB_ITER,
 		  .ub_round = ub_insert },
@@ -285,7 +466,7 @@ struct m0_ub_set m0_fol_ub = {
 		{ .ub_name = "insert-buf",
 		  .ub_iter = UB_ITER,
 		  .ub_round = ub_insert_buf },
-
+#endif
 		{ .ub_name = NULL }
 	}
 };
diff --git a/mero/magic.h b/mero/magic.h
index 6e30c7c..c16e79c 100644
--- a/mero/magic.h
+++ b/mero/magic.h
@@ -374,12 +374,14 @@ enum m0_magic_satchel {
 	M0_FOM_LL_MAGIC = 0x330b1e55edb05577,
 
 /* FOL */
+	/* m0_fol_rec_header::rh_magic (facade decile) */
+	M0_FOL_REC_MAGIC = 0x33facadedec11e77,
+	/* m0_fol_rec_part_header:rph_magic (baseball aced) */
+	M0_FOL_REC_PART_MAGIC = 0x33ba5eba11aced77,
 	/* m0_fol_rec_part:rp_link (ceaseless deb) */
 	M0_FOL_REC_PART_LINK_MAGIC = 0x33cea5e1e55deb77,
 	/* m0_fol_rec_part:rp_magic (bloodied bozo) */
 	M0_FOL_REC_PART_HEAD_MAGIC = 0x33b100d1edb02077,
-	/* m0_fol_rec_part_header:rph_magic (baseball aced) */
-	M0_FOL_REC_PART_MAGIC = 0x33ba5eba11aced77,
 
 /* HA */
 	/* m0_ha_epoch_monitor::ham_magic (bead Adelaide) */
-- 
1.8.3.2

