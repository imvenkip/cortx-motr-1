From ece08f89cc3a9110678f1fae565fddc4bc11e843 Mon Sep 17 00:00:00 2001
From: Nachiket Sahasrabuddhe <nachiket_sahasrabuddhe@xyratex.com>
Date: Thu, 22 Aug 2013 15:39:11 +0530
Subject: [PATCH 4/4] multi_node_parity_math

Code reviewed at:
http://reviewboard.clusterstor.com/r/1495/
Reviewer: Anup Barve
This code will land into master only when appropriate changes are made
in SNS code.
---
 sns/parity_math.h | 93 ++++++++++++++++++++++++++++++-------------------------
 1 file changed, 50 insertions(+), 43 deletions(-)

diff --git a/sns/parity_math.h b/sns/parity_math.h
index 8b4ece6..703d572 100644
--- a/sns/parity_math.h
+++ b/sns/parity_math.h
@@ -293,19 +293,25 @@ M0_INTERNAL void m0_parity_math_buffer_xor(struct m0_buf *dest,
  *  a lost block, then SNS client marks recovery of that lost block as
  *  complete.
  *
- *  This algorithm works in three phases. In the first phase each node updates
- *  in-memory copies for lost-blocks using alive blocks local to the node.
- *  If the set of lost blocks consists of both data as well as parity blocks,
- *  then in the second phase, contribution of the partially recovered data
- *  blocks towards lost parity blocks gets computed. SNS client achieves this
- *  by calling m0_sns_ir_local_xform().
- *  At this stage, if we add in-memory copies of a lost block residing over all
- *  the nodes, then we get a recovered block. In order to achieve this, each
- *  node sends an in-memory copy of a lost block, to a node at which the spare
- *  for that block resides. Node at the receiving end then passes incoming
- *  blocks to m0_sns_ir_recover(). This completes the third phase. Nodes that
- *  do not have any spare block, do not go through the third phase. Next
- *  section illustrates entire recovery process using an example.
+ *  This algorithm works in three phases listed below:
+ *  -# Phase1: transform alive blocks present locally on each node.
+ *  -# Phase2: transform partially recovered data-blocks (from phase1 above)
+ *             for failed parity-blocks.
+ *  -# Phase3: add partially recovered blocks from last two phases at
+ *             nodes where respective spare resides.
+ *  In the first phase each node updates in-memory buffers for lost-blocks
+ *  using in-memory buffers for alive blocks, local to the node. If the set of
+ *  lost blocks consists of both data as well as parity blocks, then in the
+ *  second phase, contribution of the partially recovered data blocks towards
+ *  lost parity blocks gets computed. SNS client achieves this by calling
+ *  m0_sns_ir_local_xform(). At this stage, if we add in-memory buffers of a
+ *  lost block residing over all the nodes, then we would get a recovered
+ *  block. In order to achieve this, each node sends an in-memory buffer of a
+ *  lost block, to a node at which the spare for that block resides. Node at
+ *  the receiving end then passes incoming blocks to m0_sns_ir_recover().
+ *  This completes the third phase. Nodes that do not have any spare block,
+ *  do not have any computations in the last phase. Next section illustrates
+ *  entire recovery process using an example.
  *
  *  @section incremental_recovery-use-case Use-case
  *  Consider a case of six data blocks, two parity blocks, and two spare
@@ -318,8 +324,8 @@ M0_INTERNAL void m0_parity_math_buffer_xor(struct m0_buf *dest,
 			 ________________________
 			*			 *
 			*  d0, p0, s0     --> N0 *
-			*  d1, p1         --> N1 *
-			*  d2, d3, d5     --> N2 *
+			*  d2, p1         --> N1 *
+			*  d1, d3, d5     --> N2 *
 			*  d4, s1         --> N3 *
 			*________________________*
     @endverbatim
@@ -328,34 +334,36 @@ M0_INTERNAL void m0_parity_math_buffer_xor(struct m0_buf *dest,
  * at s0 and that of p1 gets restored at s1. Assume that d2 and p1 obey
  * following equations:
  * @code
- * d2 = (w0.d0 + w5.p0) + (w1.d1) + (w2.d3 + w4.d5)         + (w3.d4)
- * p1 = (v0.d0)         + (v1.d1) + (v3.d3 + v5.d5 + v2.d2) + (v4.d4)
+ * d2 = (w0.d0 + w5.p0)           + (w1.d1 + w2.d3 + w4.d5) + (w3.d4)
+ * p1 = (v0.d0)         + (v2.d2) + (v1.d1 + v3.d3 + v5.d5) + (v4.d4)
  * @endcode
  * In the equations above, vi and wi are constants, for each i. Note
  * that we have clubbed those terms which can be evaluated at a same node.
  * As discussed earlier, recovery of failed blocks is carried out in three
  * phases. Following table illustrates all three phases in the context of our
- * example. In the following table, we represent a local copy of a lost block
- * di, on node Nj as di_Nj.
+ * example. In the following table, we represent an in-memory buffer of a lost
+ * block di, on node Nj as di_Nj.
  * @verbatim
 	Configuration:
 	 N = 6, K = 2
 	 Lost blocks: d2 and p1
           _____________________________________________________________________
-         |Phase 1              |Phase 2          |Phase 3                       |
-   ______|_____________________|_________________|______________________________|
-   |  N0 |d2_N0 = w0.d0 + w5.p0|p1_N0 += v2.d2_N0|d2_N0 += d2_N1 + d2_N2 + d2_N3|
-   |     |p1_N0 = v0.d0        |                 |send p1_N0 to N3              |
-   |_____|_____________________|_________________|______________________________|
-   |  N1 |d2_N1 = w1.d1        |p1_N1 += v2.d2_N1|send d2_N1 to N0              |
-   |     |p1_N1 = v1.d1        |                 |send p1_N1 to N3              |
-   |_____|_____________________|_________________|______________________________|
-   |  N2 |d2_N2 = w2.d3 + w4.d5|p1_N2 += v2.d2_N2|send d2_N2 to N0              |
-   |     |p1_N2 = v3.d3 + v5.d5|                 |send p1_N2 to N3              |
-   |_____|_____________________|_________________|_____________________________ |
-   |  N3 |d2_N3 = w3.d4        |p1_N3 += v2.d2_N3|send d2_N3 to N0              |
-   |     |p1_N3 = v4.d4        |                 |p1_N3 += p1_N0 + p1_N1 + p1_N2|
-   |_____|_____________________|_________________|______________________________|
+         |Phase 1                      |Phase 2          |Phase 3		|
+   ______|_____________________________|_________________|______________________|
+   |  N0 |d2_N0 = w0.d0 + w5.p0        |p1_N0 += v2.d2_N0|send p1_N0 to N3      |
+   |     |p1_N0 = v0.d0                |                 |d2_N0 += d2_N2 + d2_N3|
+   |     |                             |                 |s0 = d2_N0            |
+   |_____|_____________________________|_________________|______________________|
+   |  N1 |			       |		 |		        |
+   |     |			       |                 |		        |
+   |_____|_____________________________|_________________|______________________|
+   |  N2 |d2_N2 = w1.d1 + w2.d3 + w4.d5|p1_N2 += v2.d2_N2|send d2_N2 to N0      |
+   |     |p1_N2 = v1.d1 + v3.d3 + v5.d5|                 |send p1_N2 to N3      |
+   |_____|_____________________________|_________________|______________________|
+   |  N3 |d2_N3 = w3.d4                |p1_N3 += v2.d2_N3|send d2_N3 to N0      |
+   |     |p1_N3 = v4.d4                |                 |p1_N3 += p1_N0 + p1_N2|
+   |     |                             |                 |s1 = p1_N3            |
+   |_____|_____________________________|_________________|______________________|
  * @endverbatim
  * We will now see how incremental-recovery APIs enable execution of various
  * phases described above.
@@ -417,23 +425,23 @@ M0_INTERNAL void m0_parity_math_buffer_xor(struct m0_buf *dest,
  * parity blocks, the only operation m0_sns_ir_local_xform() performs is
  * changing the phase associated with recovery routine from M0_SI_BARE to
  * M0_SI_XFORM.
- * In the last phase, a node sends a copy of a lost block to a node where
- * respective spare unit resides. Receiving node passes incoming blocks to
- * recovery routine.
+ * In the last phase, a node sends an in-memory buffer for a lost block to a
+ * node where respective spare unit resides. Receiving node passes incoming
+ * buffers to recovery routine.
  *
  * @code
- * //Phase 3
+ * //Phase 3 at N0
  * send_block_to_spare(p1_N0, N3);
  *
- * for (i = 1; i < 4; ++i) {
+ * for (i = 2; i < 4; ++i) {
  *	m0_sns_ir_recover(&ir, d2_Ni, bitmap_d2_Ni, index_of(d0));
  * }
  * @endcode
  *
- * With every block that SNS client submits to m0_sns_ir_recover(), a bitmap
+ * With every buffer that SNS client submits to m0_sns_ir_recover(), a bitmap
  * is submitted. Based upon indices of bits set in the bitmap, recovery module
  * figures out the members from a parity group that have contributed to the
- * incoming block. Hence, when a local block d0 gets submitted at node N0, a
+ * incoming buffer. Hence, when a local block d0 gets submitted at node N0, a
  * bitmap accompanying has only that bit set which represents d0. On the
  * other hand, during third phase, a bitmap that accompanies d2_Ni has those
  * bits set which represent blocks local to node Ni.
@@ -499,9 +507,8 @@ M0_INTERNAL void m0_sns_ir_recover(struct m0_sns_ir *ir,
 /**
  * When failures include both data and parity blocks, this function uses
  * local copy of recovered (partially or fully) data-block for recovering
- * failed parity block. On any node, this function can be triggered only once,
- * typically when blocks local to a node are exhausted. Subsequent triggers
- * will result into a no-operaiton.
+ * failed parity block. On any node, this function can be triggered only once
+ * per parity group. Subsequent triggers will result into a no-operaiton.
  * @param ir holds information relevant for recovery
  */
 M0_INTERNAL void m0_sns_ir_local_xform(struct m0_sns_ir *ir);
-- 
1.8.3.2

