From e4a0c2aeca07263285736740c9d03316f4074c41 Mon Sep 17 00:00:00 2001
From: Amit Jambure <Amit_Jambure@xyratex.com>
Date: Wed, 15 May 2013 11:42:34 +0530
Subject: [PATCH 2/2] rpc: Some more doxygen documentation updates.

---
 rpc/conn_internal.h       |  7 ++++---
 rpc/formation2_internal.h | 10 +++-------
 rpc/item.h                | 35 ++++++++++++++++-------------------
 rpc/session_internal.h    |  2 +-
 rpc/slot_internal.h       |  3 ---
 5 files changed, 24 insertions(+), 33 deletions(-)

diff --git a/rpc/conn_internal.h b/rpc/conn_internal.h
index 94373ad..a9a68fa 100644
--- a/rpc/conn_internal.h
+++ b/rpc/conn_internal.h
@@ -123,10 +123,11 @@ M0_INTERNAL int m0_rpc_rcv_conn_establish(struct m0_rpc_conn *conn);
 /**
    Terminates receiver end of rpc connection.
 
-   @pre conn_state(conn) == M0_RPC_CONN_ACTIVE && conn->c_nr_sessions == 0
+   Terminates alive sessions if any.
+
+   @pre conn_state(conn) == M0_RPC_CONN_ACTIVE
    @post ergo(result == 0, conn_state(conn) == M0_RPC_CONN_TERMINATING)
-   @post ergo(result != 0 && result != -EBUSY,
-		conn_state(conn) == M0_RPC_CONN_FAILED)
+   @post ergo(result != 0, conn_state(conn) == M0_RPC_CONN_FAILED)
  */
 M0_INTERNAL int m0_rpc_rcv_conn_terminate(struct m0_rpc_conn *conn);
 
diff --git a/rpc/formation2_internal.h b/rpc/formation2_internal.h
index 1530116..45b9c36 100644
--- a/rpc/formation2_internal.h
+++ b/rpc/formation2_internal.h
@@ -67,11 +67,8 @@
    - RPC Packet is also referred as "RPC" in some other parts of code and docs
    - A "one-way" item is also referred as "unsolicited" item.
 
-   @todo XXX item merging support
-   @todo XXX stats collection
    @todo XXX Support for "RPC Group"
    @todo XXX RPC item cancellation
-   @todo XXX RPC item deadline timer based on generic state machine framework
    @todo XXX Better RPC level flow control than the one provided by
              m0_rpc_frm_constraints::fc_max_nr_packets_enqed
  */
@@ -173,14 +170,12 @@ enum m0_rpc_frm_itemq_type {
    There is one instance of m0_rpc_frm for each destination end-point.
 
    Events in which the formation state machine is interested are:
-
    - RPC item is posted for sending
    - RPC packet has been sent or packet sending is failed
    - deadline timer of WAITING item is expired
    - Ready slot is available
 
    Events that formation machine triggers for rest of RPC are:
-
    - Packet is ready for sending
    - Request to bind an item to a slot
 
@@ -200,7 +195,8 @@ enum m0_rpc_frm_itemq_type {
 
    <B>Concurrency and Existence: </B> @n
 
-   Access to m0_rpc_frm instance is synchronised by m0_rpc_machine::rm_mutex.
+   Access to m0_rpc_frm instance is synchronised by
+   m0_rpc_machine::rm_sm_grp::s_lock.
 
    m0_rpc_frm is not reference counted. It is responsibility of user to
    free m0_rpc_frm. Ensuring that m0_rpc_frm is in IDLE state, before
@@ -215,7 +211,7 @@ struct m0_rpc_frm {
 	   Note: Because of very simple nature of formation state machine,
 	   currently we are not using generic sm framework. If need arises
 	   in future, we should implement formation state machine using
-	   generic sm framework.
+	   m0_sm framework.
 	 */
 	enum frm_state                 f_state;
 
diff --git a/rpc/item.h b/rpc/item.h
index 63b44f7..d9bf354 100644
--- a/rpc/item.h
+++ b/rpc/item.h
@@ -118,8 +118,7 @@ enum m0_rpc_item_stage {
 	RPC_ITEM_STAGE_PAST_COMMITTED = 1,
 	/** the reply was received, but persistence confirmation wasn't */
 	RPC_ITEM_STAGE_PAST_VOLATILE,
-	/** the item was sent (i.e., placed into an rpc) and no reply is
-	    received */
+	/** the item is sent but no reply is received */
 	RPC_ITEM_STAGE_IN_PROGRESS,
 	/** Operation is timedout. Uncertain whether receiver has processed
 	    the request or not. */
@@ -139,17 +138,13 @@ enum {
    slot_ref object establishes association between m0_rpc_item and
    m0_rpc_slot. Upto MAX_SLOT_REF number of m0_rpc_slot_ref objects are
    embeded with m0_rpc_item.
-   At the time item is associated with a slot, values of few slot fields are
-   copied into slot_ref.
  */
 struct m0_rpc_slot_ref {
 	/** sr_slot and sr_item identify two ends of association */
 	struct m0_rpc_slot           *sr_slot;
-
 	struct m0_rpc_item           *sr_item;
-
+	/** Part of onwire RPC item header */
 	struct m0_rpc_onwire_slot_ref sr_ow;
-
 	/** Anchor to put item on m0_rpc_slot::sl_item_list
 	    List descriptor: slot_item
 	 */
@@ -212,12 +207,20 @@ struct m0_rpc_item {
 	 */
 	struct m0_sm                     ri_sm;
 	enum m0_rpc_item_stage		 ri_stage;
+	/** Number of times the item was sent */
 	uint32_t                         ri_nr_sent;
+	/** Reply received when request is still in SENDING state is kept
+	    "pending" until the request item moves to SENT state.
+	 */
 	struct m0_rpc_item              *ri_pending_reply;
 	struct m0_rpc_slot_ref		 ri_slot_refs[MAX_SLOT_REF];
-	/** Anchor to put item on m0_rpc_session::s_unbound_items list */
+	/** @deprecated Anchor to put item on
+	    m0_rpc_session::s_unbound_items list
+	 */
 	struct m0_list_link		 ri_unbound_link;
-	/** Item size in bytes. header + payload. */
+	/** Item size in bytes. header + payload.
+	    Set during first call to m0_rpc_item_size() on this item.
+	 */
 	size_t                           ri_size;
 	/** Pointer to the type object for this item */
 	const struct m0_rpc_item_type	*ri_type;
@@ -235,7 +238,7 @@ struct m0_rpc_item {
 	/** Link in RPC packet. m0_rpc_packet::rp_items
 	    List descriptor: packet_item.
 	    XXX An item cannot be in itemq and in packet at the same time.
-	    Hence iff needed ri_iq_link and ri_plink can be replaced with
+	    Hence, iff needed, ri_iq_link and ri_plink can be replaced with
 	    just one tlink.
 	 */
 	struct m0_tlink                  ri_plink;
@@ -266,7 +269,7 @@ struct m0_rpc_item_ops {
 
 	   If item->ri_error != 0, then item->ri_reply may or may not be NULL.
 
-	   For each request, sender receives one of following two types
+	   For a request, sender can receive one of following two types
 	   of replies:
 	   - generic-reply (m0_fop_generic_reply):
 	     This type of reply is received when operation fails in generic
@@ -350,7 +353,8 @@ struct m0_rpc_item_type_ops {
 	m0_bcount_t (*rito_payload_size)(const struct m0_rpc_item *item);
 
 	/**
-	  Return true iff item1 and item2 are equal.
+	   Return true iff item1 and item2 are equal.
+	   @todo XXX Implement rito_eq for fops
 	 */
 	bool (*rito_eq)(const struct m0_rpc_item *i1,
 			const struct m0_rpc_item *i2);
@@ -434,13 +438,6 @@ struct m0_rpc_item_type {
 	uint64_t			   rit_magic;
 };
 
-#define M0_RPC_ITEM_TYPE_DEF(itype, opcode, flags, ops)  \
-struct m0_rpc_item_type (itype) = {                      \
-	.rit_opcode = (opcode),                          \
-	.rit_flags = (flags),                            \
-	.rit_ops = (ops)                                 \
-};
-
 /**
   Registers a new rpc item type by adding an entry to the rpc item types list.
   Asserts when an entry for that opcode already exists in the item types
diff --git a/rpc/session_internal.h b/rpc/session_internal.h
index b3d957d..d1703b8 100644
--- a/rpc/session_internal.h
+++ b/rpc/session_internal.h
@@ -105,7 +105,7 @@ M0_INTERNAL int m0_rpc_session_cob_create(struct m0_cob *conn_cob,
 
    @pre session->s_state == M0_RPC_SESSION_INITIALISED &&
 	session->s_conn != NULL
-   @post ergo(result == 0, session->s_state == M0_RPC_SESSION_ALIVE)
+   @post ergo(result == 0, session->s_state == M0_RPC_SESSION_IDLE)
    @post ergo(result != 0, session->s_state == M0_RPC_SESSION_FAILED)
  */
 M0_INTERNAL int m0_rpc_rcv_session_establish(struct m0_rpc_session *session);
diff --git a/rpc/slot_internal.h b/rpc/slot_internal.h
index 6d9ff5c..3df69f1 100644
--- a/rpc/slot_internal.h
+++ b/rpc/slot_internal.h
@@ -249,9 +249,6 @@ M0_INTERNAL void m0_rpc_slot_persistence(struct m0_rpc_slot *slot,
 M0_INTERNAL void m0_rpc_slot_reset(struct m0_rpc_slot *slot,
 				   struct m0_verno last_seen);
 
-/**
-   Finalises slot
- */
 M0_INTERNAL void m0_rpc_slot_fini(struct m0_rpc_slot *slot);
 
 M0_INTERNAL bool m0_rpc_slot_invariant(const struct m0_rpc_slot *slot);
-- 
1.8.3.2

