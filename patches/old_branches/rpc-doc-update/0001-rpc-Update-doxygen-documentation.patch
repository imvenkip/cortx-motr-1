From fb604b19abae693ed3d6c93875011e372e2d88f6 Mon Sep 17 00:00:00 2001
From: Amit Jambure <Amit_Jambure@xyratex.com>
Date: Mon, 13 May 2013 11:41:16 +0530
Subject: [PATCH 1/2] rpc: Update doxygen documentation.

---
 rpc/conn.c          |  5 +++--
 rpc/conn.h          | 53 +++++++++++++++++++++----------------------
 rpc/session.h       | 65 +++++++++++++++++++++--------------------------------
 rpc/slot_internal.h | 21 +++++------------
 4 files changed, 59 insertions(+), 85 deletions(-)

diff --git a/rpc/conn.c b/rpc/conn.c
index 2dcc00d..e8d739a 100644
--- a/rpc/conn.c
+++ b/rpc/conn.c
@@ -473,8 +473,9 @@ static void session_zero_detach(struct m0_rpc_conn *conn)
 	M0_LEAVE();
 }
 
-M0_INTERNAL int m0_rpc_conn_timedwait(struct m0_rpc_conn *conn, uint64_t states,
-				      const m0_time_t timeout)
+M0_INTERNAL int m0_rpc_conn_timedwait(struct m0_rpc_conn *conn,
+				      uint64_t            states,
+				      const m0_time_t     timeout)
 {
 	int rc;
 
diff --git a/rpc/conn.h b/rpc/conn.h
index 9652ed1..eb88488 100644
--- a/rpc/conn.h
+++ b/rpc/conn.h
@@ -52,14 +52,14 @@ enum m0_rpc_conn_state {
 	M0_RPC_CONN_INITIALISED,
 
 	/**
-	   When sender is waiting for receiver reply to get its sender ID it is
-	   in CONNECTING state.
+	   Connection establish request is sent to receiver but its reply is
+	   not yet received.
 	 */
 	M0_RPC_CONN_CONNECTING,
 
 	/**
-	   When initialization is successfull connection enters in ACTIVE state.
-	   It stays in this state for until termination.
+	   Receiver replied with a successful connection establish reply.
+	   Connection is established and ready to be used.
 	 */
 	M0_RPC_CONN_ACTIVE,
 
@@ -91,7 +91,7 @@ enum m0_rpc_conn_state {
 };
 
 /**
-   RPC Connection flags
+   RPC Connection flags @see m0_rpc_conn::c_flags
  */
 enum m0_rpc_conn_flags {
 	RCF_SENDER_END = 1 << 0,
@@ -128,7 +128,6 @@ enum m0_rpc_conn_flags {
    "hand-made" and there is no need to communicate to receiver in order to
    create this session. Receiver assumes that there always exists a session 0
    for each rpc connection.
-   Session 0 always have exactly 1 slot within it.
    Receiver creates session 0 while creating the rpc connection itself.
    Session 0 is required to send special fops like
    - conn_establish or conn_terminate FOP
@@ -176,16 +175,8 @@ enum m0_rpc_conn_flags {
   - Receiver side m0_rpc_conn object will be instantiated in response to
     rpc connection establish request and is deallocated while terminating the
     rpc connection.
-  - User is not expected to take lock on m0_rpc_conn object. Session module
-    will internally synchronise access to m0_rpc_conn.
-  - m0_rpc_conn::c_mutex protects all but c_link fields of m0_rpc_conn.
-  - Locking order:
-    - slot->sl_mutex
-    - session->s_mutex
-    - conn->c_mutex
-    - rpc_machine->rm_session_mutex, rpc_machine->rm_ready_slots_mutex (As of
-      now, there is no case where these two mutex are held together. If such
-      need arises then ordering of these two mutex should be decided.)
+  - Access to m0_rpc_conn is synchronized with
+    conn->c_rpc_machine->rm_sm_grp.s_lock.
 
   <B> Typical sequence of API execution </B>
   Note: error checking is omitted.
@@ -251,7 +242,7 @@ enum m0_rpc_conn_flags {
   all the state transitions of conn internally.
  */
 struct m0_rpc_conn {
-	/** Sender ID unique on receiver */
+	/** Sender ID, unique on receiver */
 	uint64_t                  c_sender_id;
 
 	/** Globally unique ID of rpc connection */
@@ -288,9 +279,7 @@ struct m0_rpc_conn {
 
 	struct m0_rpc_service    *c_service;
 
-	/** A m0_rpc_chan structure that will point to the transfer
-	    machine used by this m0_rpc_conn.
-	 */
+	/** Identifies destination of this connection. */
 	struct m0_rpc_chan       *c_rpcchan;
 
 	/** cob representing the connection */
@@ -333,8 +322,9 @@ M0_INTERNAL int m0_rpc_conn_init(struct m0_rpc_conn *conn,
 
 /**
     Sends handshake CONN_ESTABLISH fop to the remote end.
-    When reply to CONN_ESTABLISH is received,
-    m0_rpc_conn_establish_reply_received() is called.
+
+    Use m0_rpc_conn_timedwait() to wait until conn moves to
+    ESTABLISHED or FAILED state.
 
     @pre conn_state(conn) == M0_RPC_CONN_INITIALISED
     @post ergo(result != 0, conn_state(conn) == M0_RPC_CONN_FAILED)
@@ -372,8 +362,9 @@ M0_INTERNAL int m0_rpc_conn_create(struct m0_rpc_conn *conn,
    Sends "conn_terminate" FOP to receiver.
    m0_rpc_conn_terminate() is a no-op if @conn is already in TERMINATING
    state.
-   m0_rpc_conn_terminate_reply_received() is called when reply to
-   CONN_TERMINATE is received.
+
+   Use m0_rpc_conn_timedwait() to wait until conn is moved to TERMINATED
+   or FAILED state.
 
    @pre (conn_state(conn) == M0_RPC_CONN_ACTIVE && conn->c_nr_sessions == 0 &&
 	 conn->c_service == NULL) ||
@@ -416,8 +407,9 @@ M0_INTERNAL void m0_rpc_conn_fini(struct m0_rpc_conn *conn);
 int m0_rpc_conn_destroy(struct m0_rpc_conn *conn, m0_time_t abs_timeout);
 
 /**
-    Waits until @conn reaches in any one of states specified by @state_flags.
-    @param state_flags can specify multiple states by ORing
+    Waits until @conn reaches in any one of states specified by @states.
+
+    @param state_flags can specify multiple states by using M0_BITS().
 
     @param abs_timeout should not sleep past abs_timeout waiting for conn
 		to reach in desired state.
@@ -427,10 +419,17 @@ int m0_rpc_conn_destroy(struct m0_rpc_conn *conn, m0_time_t abs_timeout);
                 state.
  */
 M0_INTERNAL int m0_rpc_conn_timedwait(struct m0_rpc_conn *conn,
-				      uint64_t state_flags,
+				      uint64_t states,
 				      const m0_time_t abs_timeout);
 
+/**
+   Just for debugging purpose. Useful in gdb.
+
+   dir = 1, to print incoming conn list
+   dir = 0, to print outgoing conn list
+ */
 M0_INTERNAL int m0_rpc_machine_conn_list_dump(struct m0_rpc_machine *machine,
 					      int dir);
+
 /** @}  End of rpc_session group */
 #endif /* __MERO_RPC_CONN_H__ */
diff --git a/rpc/session.h b/rpc/session.h
index ccc8dfb..fa59ee5 100644
--- a/rpc/session.h
+++ b/rpc/session.h
@@ -58,7 +58,7 @@ Out of these, m0_rpc_conn and m0_rpc_session are visible to user.
 m0_rpc_slot and m0_rpc_slot_ref are internal to rpc layer and not visible to
 users outside rpc layer.
 
-Session module uses following types of objects defined by rpc-core:
+Session module uses following types of objects:
 - rpc machine @see m0_rpc_machine
 - rpc item @see m0_rpc_item.
 
@@ -85,10 +85,9 @@ definitions are used on both sender and receiver side)
 <B> Bound and Unbound rpc items: </B>
 
 Rpc layer can send an rpc item on network only if it is associated with some
-slot within the session. User of rpc layer can indirectly specify the slot (via
-"update stream") on which the item needs to be sent. Or the user can just
-specify session and leave the task of choosing any available slot to
-rpc layer.
+slot within the session. User can specify the slot on which the item needs to
+be sent. Or the user can just specify session and leave the task of choosing
+any available slot to rpc layer.
 
 With respect to session and slots, an rpc item is said to be "bound" if
 the item is associated with slot. An item is called as "unbound"/"freestanding"
@@ -227,9 +226,7 @@ back to sender.
  addition to uuid, that is not guaranteed to be globally unique)
 
     @todo
-	- stats
 	- Generate ADDB data points for important session events
-	- UUID generation
 	- store replies in FOL
 	- Support more than one items in flight for a slot
 	- Optimization: Cache misordered items at receiver, rather than
@@ -237,16 +234,12 @@ back to sender.
 	- How to get unique stob_id for session and slot cobs?
 	- slot table resize needs to be implemented.
 	- Design protocol to dynamically adjust number of slots.
-	- Session level timeout
-	- session can be terminated only if all items are pruned from all
-		slot->sl_item_list
-
  */
 
 #include "lib/list.h"
 #include "lib/tlist.h"
 #include "lib/time.h"
-#include "sm/sm.h" /* m0_sm */
+#include "sm/sm.h"                /* m0_sm */
 #include "rpc/rpc_onwire.h"
 
 /* Imports */
@@ -268,7 +261,7 @@ enum m0_rpc_session_state {
 	M0_RPC_SESSION_INITIALISED,
 	/**
 	   When sender sends a SESSION_ESTABLISH FOP to reciever it
-	   is in CREATING state
+	   is in ESTABLISHING state
 	 */
 	M0_RPC_SESSION_ESTABLISHING,
 	/**
@@ -277,7 +270,7 @@ enum m0_rpc_session_state {
 			for each item I in S->item_list
 				// I has got reply
 				I->state is in {PAST_COMMITTED, PAST_VOLATILE}
-		- session->unbound_items list is empty
+		- formation queue has no item associated with this session
 	   A session can be terminated only if it is IDLE.
 	 */
 	M0_RPC_SESSION_IDLE,
@@ -286,7 +279,7 @@ enum m0_rpc_session_state {
 		- Any of slots has item to be sent (FUTURE items)
 		- Any of slots has item for which reply is not received
 			(IN_PROGRESS items)
-		- unbound_items list is not empty
+		- Formation queue has item associated with this session
 	 */
 	M0_RPC_SESSION_BUSY,
 	/**
@@ -332,22 +325,13 @@ enum m0_rpc_session_state {
    Users of rpc-layer are never expected to take lock on session. Rpc layer
    will internally synchronise access to m0_rpc_session.
 
-   m0_rpc_session::s_mutex protects all fields except s_link. s_link is
-   protected by session->s_conn->c_mutex.
+   All access to session are synchronized using
+   session->s_conn->c_rpc_machine->rm_sm_grp.s_lock.
 
-   There is no need to take session->s_mutex while posting item on the session.`
    When session is in one of INITIALISED, TERMINATED, FINALISED and
    FAILED state, user is expected to serialise access to the session object.
-   (It is assumed that session in one of {INITIALISED, TERMINATED, FAILED,
-    FINALISED} state, very likely does not have concurrent users).
-
-   Locking order:
-    - slot->sl_mutex
-    - session->s_mutex
-    - conn->c_mutex
-    - rpc_machine->rm_session_mutex, rpc_machine->rm_ready_slots_mutex (As of
-      now, there is no case where these two mutex are held together. If such
-      need arises then ordering of these two mutex should be decided.)
+   (It is assumed that session, in one of {INITIALISED, TERMINATED, FAILED,
+    FINALISED} states, does not have concurrent users).
 
    @verbatim
                                       |
@@ -425,7 +409,7 @@ enum m0_rpc_session_state {
 			      // will be called when reply to this item is
 			      // received. DO NOT FREE THIS ITEM.
 
-   m0_rpc_post(item);
+   rc = m0_rpc_post(item);
 
    // TERMINATING SESSION
    // Wait until all the items that were posted on this session, are sent and
@@ -493,6 +477,7 @@ struct m0_rpc_session {
 
 	/** list of items that can be sent through any available slot.
 	    items are placed using m0_rpc_item::ri_unbound_link
+	    @deprecated XXX
 	 */
 	struct m0_list            s_unbound_items;
 
@@ -548,9 +533,8 @@ M0_INTERNAL int m0_rpc_session_init(struct m0_rpc_session *session,
 
 /**
     Sends a SESSION_ESTABLISH fop across pre-defined session-0 in
-    session->s_conn.
-    m0_rpc_session_establish_reply_received() is called when reply to
-    SESSION_ESTABLISH fop is received.
+    session->s_conn. Use m0_rpc_session_timedwait() to wait
+    until session reaches IDLE or FAILED state.
 
     @pre session_state(session) == M0_RPC_SESSION_INITIALISED
     @pre conn_state(session->s_conn) == M0_RPC_CONN_ACTIVE
@@ -589,8 +573,8 @@ M0_INTERNAL int m0_rpc_session_create(struct m0_rpc_session *session,
 /**
    Sends terminate session fop to receiver.
    Acts as no-op if session is already in TERMINATING state.
-   m0_rpc_session_terminate_reply_received() is called when reply to
-   CONN_TERMINATE fop is received.
+   Does not wait for reply. Use m0_rpc_session_timedwait() to wait
+   until session reaches TERMINATED or FAILED state.
 
    @pre M0_IN(session_state(session), (M0_RPC_SESSION_IDLE,
 				       M0_RPC_SESSION_TERMINATING))
@@ -610,6 +594,7 @@ M0_INTERNAL int m0_rpc_session_terminate(struct m0_rpc_session *session,
  *                    FAILED state.
  *
  * @pre M0_IN(session_state(session), (M0_RPC_SESSION_IDLE,
+ *				       M0_RPC_SESSION_BUSY,
  *				       M0_RPC_SESSION_TERMINATING))
  * @post M0_IN(session_state(session), (M0_RPC_SESSION_TERMINATED,
  *					M0_RPC_SESSION_FAILED))
@@ -620,16 +605,16 @@ M0_INTERNAL int m0_rpc_session_terminate_sync(struct m0_rpc_session *session,
 /**
     Waits until @session object reaches in one of states given by @state_flags.
 
-    @param state_flags can specify multiple states by ORing
+    @param states can specify multiple states by using M0_BITS()
     @param abs_timeout thread does not sleep past abs_timeout waiting for conn
 		to reach in desired state.
     @return 0 if session reaches in one of the state(s) specified by
 		@state_flags
-            -ETIMEDOUT if time out has occured before session reaches in desired
-                state.
+            -ETIMEDOUT if time out has occured before session reaches in
+                desired state.
  */
 M0_INTERNAL int m0_rpc_session_timedwait(struct m0_rpc_session *session,
-					 uint64_t state_flags,
+					 uint64_t states,
 					 const m0_time_t abs_timeout);
 
 /**
@@ -642,8 +627,8 @@ M0_INTERNAL int m0_rpc_session_timedwait(struct m0_rpc_session *session,
 M0_INTERNAL void m0_rpc_session_fini(struct m0_rpc_session *session);
 
 /**
- * A combination of m0_rpc_session_terminate_sync() and m0_rpc_session_fini() in
- * a single routine - terminate the session, wait until it switched to
+ * A combination of m0_rpc_session_terminate_sync() and m0_rpc_session_fini()
+ * in a single routine - terminate the session, wait until it switched to
  * terminated state and finalize session object.
  */
 int m0_rpc_session_destroy(struct m0_rpc_session *session,
diff --git a/rpc/slot_internal.h b/rpc/slot_internal.h
index 628e4d8..6d9ff5c 100644
--- a/rpc/slot_internal.h
+++ b/rpc/slot_internal.h
@@ -60,6 +60,7 @@ struct m0_rpc_slot_ops {
 	/** Slot has no items to send and hence is idle. Formation
 	    can use such slot to send unbound items. */
 	void (*so_slot_idle)(struct m0_rpc_slot *slot);
+	/** Slot has some item in IN_PROGRESS or FUTURE stage */
 	void (*so_slot_busy)(struct m0_rpc_slot *slot);
 };
 
@@ -72,12 +73,12 @@ struct m0_rpc_slot_ops {
 
   One can think of a slot as a pipe. On sender side, application/formation is
   placing items at one end of this pipe. The item appears on the other end
-  of pipe. And formation takes the item, packs in some RPC, and sends it.
+  of pipe. And formation takes the item, packs in some packet, and sends it.
 
   On receiver side, when an item is received it is placed in one end of the
   pipe. When the item appears on other end of pipe it is sent for execution.
 
-  With a slot a list of items, ordered by verno is associated. An item on
+  With a slot, a list of items, ordered by verno is associated. An item on
   the list is in one of the following states:
 
   - past committed: the reply for the item was received and the receiver
@@ -94,10 +95,6 @@ struct m0_rpc_slot_ops {
 
   - future: the item wasn't sent.
 
-  An item can be linked into multiple slots (similar to m0_fol_obj_ref).
-  For each slot the item has a separate verno and separate linkage into
-  the slot's item list. Item state is common for all slots;
-
   An item has a MUTABO flag, which is set when the item is an update
   (i.e., changes the file system state). When the item is an update then
   (for each slot the item is in) its verno is greater than the verno of
@@ -145,16 +142,8 @@ struct m0_rpc_slot_ops {
   <B> Liveness and concurreny </B>
   Slots are allocated at the time of session initialisation and freed at the
   time of session finalisation.
-  m0_rpc_slot::sl_mutex protects all fields of slot except sl_link.
-  sl_link is protected by m0_rpc_machine::rm_ready_slots_mutex.
-
-  Locking order:
-    - slot->sl_mutex
-    - session->s_mutex
-    - conn->c_mutex
-    - rpc_machine->rm_session_mutex, rpc_machine->rm_ready_slots_mutex (As of
-      now, there is no case where these two mutex are held together. If such
-      need arises then ordering of these two mutex should be decided.)
+  Access to slot is synchronized by
+    slot->sl_session->s_conn->c_rpc_machine->rm_sm_grp.s_lock
  */
 struct m0_rpc_slot {
 	/** Session to which this slot belongs */
-- 
1.8.3.2

