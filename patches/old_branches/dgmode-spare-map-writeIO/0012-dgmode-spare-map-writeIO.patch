From 7a52e7e4400779fee08c12fd5b66b01167227878 Mon Sep 17 00:00:00 2001
From: Nachiket Sahasrabuddhe <nachiket_sahasrabuddhe@xyratex.com>
Date: Mon, 17 Feb 2014 14:09:09 +0530
Subject: [PATCH 12/14] dgmode-spare-map-writeIO

1. Removed a white space and a commented line from the code.
---
 m0t1fs/linux_kernel/file.c                     | 50 ++++----------------
 m0t1fs/linux_kernel/st/m0t1fs_sns_repair_mf.sh | 64 +-------------------------
 2 files changed, 10 insertions(+), 104 deletions(-)

diff --git a/m0t1fs/linux_kernel/file.c b/m0t1fs/linux_kernel/file.c
index a93efb5..85fb6b4 100644
--- a/m0t1fs/linux_kernel/file.c
+++ b/m0t1fs/linux_kernel/file.c
@@ -1995,8 +1995,6 @@ static int pargrp_iomap_populate(struct pargrp_iomap	  *map,
 	grpsize	 = data_size(play);
 	grpstart = grpsize * map->pi_grpid;
 	grpend	 = grpstart + grpsize;
-	/*XXX:How do we gurantee that none of the prevous segments overlap with
-	 * parity-group of interest ? */
 	for (seg = cursor->ic_cur.vc_seg; seg < SEG_NR(ivec) &&
 	     INDEX(ivec, seg) < grpend; ++seg) {
 		currindex = seg == cursor->ic_cur.vc_seg ?
@@ -2013,8 +2011,6 @@ static int pargrp_iomap_populate(struct pargrp_iomap	  *map,
 
 	size = map->pi_ioreq->ir_file->f_dentry->d_inode->i_size;
 
-	/*XXX: How do we gurantee that m0_ivec_cursor_index(cursor) >= grpstart
-	 * ?*/
 	for (seg = 0; !m0_ivec_cursor_move(cursor, count) &&
 	     m0_ivec_cursor_index(cursor) < grpend;) {
 		/*
@@ -2044,7 +2040,6 @@ static int pargrp_iomap_populate(struct pargrp_iomap	  *map,
 				COUNT(&map->pi_ivec, seg) = size -
 					INDEX(&map->pi_ivec, seg);
 			else
-			/*XXX:What if INDEX(&map->pi_ivec, seg) < size ?*/
 				COUNT(&map->pi_ivec, seg) = 0;
 			if (COUNT(&map->pi_ivec, seg) == 0) {
 				count = m0_ivec_cursor_step(cursor);
@@ -2063,9 +2058,6 @@ static int pargrp_iomap_populate(struct pargrp_iomap	  *map,
 
 			newindex = m0_round_up(INDEX(&map->pi_ivec, seg) + 1,
 					       PAGE_CACHE_SIZE);
-			/*XXX: How do we gurantee that end of the segment
-			 * lies in new page ? If it does not shall we not skip
-			 * the page ?*/
 			COUNT(&map->pi_ivec, seg) -= (newindex -
 					INDEX(&map->pi_ivec, seg));
 
@@ -2108,7 +2100,7 @@ static int pargrp_iomap_populate(struct pargrp_iomap	  *map,
 		 * Can use number of data_buf structures instead of using
 		 * indexvec_page_nr().
 		 */
-		ro_page_nr = /* Number of pages to be read. 
+		ro_page_nr = /* Number of pages to be read.
 			      XXX: 'nr' can not be directly eliminated. If
 			      page contents are within_eof, then even if
 			      they are fully modified, older contents need
@@ -2128,12 +2120,13 @@ static int pargrp_iomap_populate(struct pargrp_iomap	  *map,
 			     parity_units_page_nr(play);
 
 		if (rr_page_nr < ro_page_nr) {
+			M0_LOG(M0_INFO,"Read-rest approach selected");
 			map->pi_rtype = PIR_READREST;
 			rc = map->pi_ops->pi_readrest(map);
 			if (rc != 0)
 				M0_RETERR(rc, "readrest failed");
 		} else {
-			M0_LOG(M0_FATAL,"Read-old approach selected");
+			M0_LOG(M0_INFO,"Read-old approach selected");
 			map->pi_rtype = PIR_READOLD;
 			rc = map->pi_ops->pi_readold_auxbuf_alloc(map);
 		}
@@ -2287,7 +2280,6 @@ static int pargrp_iomap_dgmode_process(struct pargrp_iomap *map,
 	M0_PRE(tio   != NULL);
 	M0_PRE(index != NULL);
 	M0_PRE(count >  0);
-	//M0_PRE(ioreq_sm_state(map->pi_ioreq) == IRS_DEGRADED_READING);
 
 	/*
 	 * Finds out the id of target object to which failed IO fop
@@ -2493,8 +2485,6 @@ static int pargrp_iomap_dgmode_postprocess(struct pargrp_iomap *map)
 		for (row = 0; row < data_row_nr(play); ++row) {
 
 			data_page_offset_get(map, row, col, &start);
-			/*XXX: Does it mean that inode->i_size is always a 
-			 * multiple of PAGE_CACHE_SIZE ? */
 			within_eof = start + PAGE_CACHE_SIZE < inode->i_size ||
 			             (inode->i_size > 0 &&
 				      page_id(start + PAGE_CACHE_SIZE - 1) ==
@@ -2687,7 +2677,6 @@ static int pargrp_iomap_dgmode_recover(struct pargrp_iomap *map)
 		for (col = 0; col < data_col_nr(play) + parity_col_nr(play); ++col)
 			if (*(fail + col) == 1)
 				++failed_nr;
-		M0_LOG(M0_FATAL,"Failed units in group %d are %d", (int)map->pi_grpid, failed_nr);
 		m0_parity_math_recover(parity_math(map->pi_ioreq), data,
 				       parity, &failed);
 		failed_nr = 0;
@@ -3104,8 +3093,6 @@ static int device_check(struct io_request *req)
 		if (rc != 0)
 			M0_RETERR(rc, "Failed to retrieve target device state");
 		ti->ti_state = state;
-
-	//	M0_LOG(M0_FATAL,"Request to device %d found", (int)(ti->ti_fid.f_container));
 		if (M0_IN(state, (M0_PNDS_FAILED, M0_PNDS_OFFLINE,
 			          M0_PNDS_SNS_REPAIRING)))
 			st_cnt++;
@@ -3135,7 +3122,6 @@ static int ioreq_dgmode_write(struct io_request *req, bool rmw)
 	M0_PRE_EX(io_request_invariant(req));
 
 	rc = device_check(req);
-	M0_LOG(M0_FATAL, "value for nw_rc = %d", req->ir_nwxfer.nxr_rc);
 	if (req->ir_nwxfer.nxr_rc == 0)
 		M0_RETURN(req->ir_nwxfer.nxr_rc);
 	else if (rc < 0)
@@ -3173,7 +3159,6 @@ static int ioreq_dgmode_write(struct io_request *req, bool rmw)
 	 * IO request will be reshuffled by redirecting pages meant for
 	 * failed device(s) to its corresponding spare unit(s).
 	 */
-	M0_LOG(M0_INFO, "1. req->ir_rc = %d, nwxfer rc = %d",
 	       req->ir_rc, req->ir_nwxfer.nxr_rc);
 
 	/*
@@ -3184,7 +3169,6 @@ static int ioreq_dgmode_write(struct io_request *req, bool rmw)
 	 */
 	req->ir_nwxfer.nxr_ops->nxo_complete(&req->ir_nwxfer, rmw);
 	if (M0_IN(req->ir_sns_state, (SRS_UNINITIALIZED, SRS_REPAIR_NOTDONE))) {
-		M0_LOG(M0_FATAL,"DEGRADED MODE WRITE");
 		/*
 		 * Resets count of data bytes and parity bytes along with
 		 * return status.
@@ -3225,9 +3209,6 @@ static int ioreq_dgmode_write(struct io_request *req, bool rmw)
 			       1000); /* uS */
 	m0_addb_counter_update(&stats->ais_sizes_cntr,
 			       (uint64_t) req->ir_nwxfer.nxr_bytes);
-
-	if (req->ir_nwxfer.nxr_rc != 0)
-		M0_LOG(M0_FATAL,"Error in DEGRADED MODE WRITE");
 	M0_RETURN(req->ir_nwxfer.nxr_rc);
 }
 
@@ -3278,7 +3259,6 @@ static int ioreq_dgmode_read(struct io_request *req, bool rmw)
 		 */
 
 		m0_tl_for (iofops, &ti->ti_iofops, irfop) {
-			M0_LOG(M0_INFO,"Processing fops to failed device "FID_F"\n", FID_P(&ti->ti_fid));
 			rc = irfop->irf_ops->irfo_dgmode_read(irfop);
 			if (rc != 0)
 				break;
@@ -3331,7 +3311,6 @@ static int ioreq_dgmode_read(struct io_request *req, bool rmw)
 	if (req->ir_nwxfer.nxr_rc != 0)
 		req->ir_nwxfer.nxr_rc = 0;
 	req->ir_rc = req->ir_nwxfer.nxr_rc;
-	M0_LOG(M0_FATAL, "IN DEGRADED MODE");
 
 	rc = req->ir_nwxfer.nxr_ops->nxo_distribute(&req->ir_nwxfer);
 	if (rc != 0)
@@ -3431,7 +3410,6 @@ static int ioreq_iosm_handle(struct io_request *req)
 		enum io_req_state state;
 
 		rmw = false;
-		M0_LOG(M0_FATAL,"Pure write case");
 		state = req->ir_type == IRT_READ ? IRS_READING :
 						   IRS_WRITING;
 		if (state == IRS_WRITING) {
@@ -3483,7 +3461,6 @@ static int ioreq_iosm_handle(struct io_request *req)
 			 */
 			rc = req->ir_ops->iro_dgmode_write(req, rmw);
 			if (rc != 0) {
-				M0_LOG(M0_FATAL,"ERROR in DGMODE WRITE");
 				goto fail_locked;
 			}
 		}
@@ -3492,7 +3469,6 @@ static int ioreq_iosm_handle(struct io_request *req)
 		m0_bcount_t read_pages = 0;
 
 		rmw = true;
-		M0_LOG(M0_INFO, "Read-modify-write case");
 		m0_htable_for(tioreqht, ti, &req->ir_nwxfer.nxr_tioreqs_hash) {
 			for (seg = 0; seg < ti->ti_bufvec.ov_vec.v_nr; ++seg)
 				if (ti->ti_pageattrs[seg] & PA_READ)
@@ -3576,7 +3552,6 @@ static int ioreq_iosm_handle(struct io_request *req)
 		/* Returns immediately if all devices are in healthy state. */
 		rc = req->ir_ops->iro_dgmode_write(req, rmw);
 		if (rc != 0) {
-			M0_LOG(M0_FATAL, "1 ERROR in DGMODE WRITE");
 			goto fail_locked;
 		}
 	}
@@ -4052,7 +4027,6 @@ static int nw_xfer_tioreq_get(struct nw_xfer_request *xfer,
 	if (ti->ti_dgvec == NULL && M0_IN(ioreq_sm_state(req),
 	    (IRS_DEGRADED_READING, IRS_DEGRADED_WRITING))) {
 		rc = dgmode_rwvec_alloc_init(ti);
-		M0_LOG(M0_FATAL, "dg-vec allocated for device %d", (int)ti->ti_fid.f_container);
 	}
 
 	*out = ti;
@@ -4161,7 +4135,6 @@ static void target_ioreq_seg_add(struct target_ioreq              *ti,
 	if (ioreq_sm_state(req) == IRS_DEGRADED_READING ||
 	    (ioreq_sm_state(req) == IRS_DEGRADED_WRITING &&
 	     req->ir_sns_state   == SRS_REPAIR_DONE)) {
-		M0_LOG(M0_FATAL,"(seg-add)state of device %d is %d",(int)ti->ti_fid.f_container, (int)ti->ti_state);
 		M0_ASSERT(ti->ti_dgvec != NULL);
 		ivec  = &ti->ti_dgvec->dr_ivec;
 		bvec  = &ti->ti_dgvec->dr_bufvec;
@@ -4774,7 +4747,7 @@ static void io_bottom_half(struct m0_sm_group *grp, struct m0_sm_ast *ast)
 	reply_item = req_item->ri_reply;
 	rc = req_item->ri_error ?: m0_rpc_item_generic_reply_rc(reply_item);
 	if (rc != 0) {
-		M0_LOG(M0_FATAL, "reply error: rc=%d", rc);
+		M0_LOG(M0_ERROR, "reply error: rc=%d", rc);
 		goto ref_dec;
 	}
 	M0_ASSERT(reply_item != NULL &&
@@ -4787,7 +4760,7 @@ static void io_bottom_half(struct m0_sm_group *grp, struct m0_sm_ast *ast)
 	rw_reply  = io_rw_rep_get(reply_fop);
 	rc        = rw_reply->rwr_rc;
 	req->ir_sns_state = rw_reply->rwr_repair_done;
-	M0_LOG(M0_FATAL, "reply received = %d, sns state = %d", rc,
+	M0_LOG(M0_INFO, "reply received = %d, sns state = %d", rc,
 			 req->ir_sns_state);
 
 	if (rc == M0_IOP_ERROR_FAILURE_VECTOR_VER_MISMATCH) {
@@ -4803,12 +4776,12 @@ static void io_bottom_half(struct m0_sm_group *grp, struct m0_sm_ast *ast)
 
 	if (tioreq->ti_nwxfer->nxr_rc == 0) {
 		tioreq->ti_nwxfer->nxr_rc = rc;
-		M0_LOG(M0_FATAL, "nwxfer rc = %d", tioreq->ti_nwxfer->nxr_rc);
+		M0_LOG(M0_INFO, "nwxfer rc = %d", tioreq->ti_nwxfer->nxr_rc);
 	}
 
 	if (irfop->irf_pattr == PA_DATA) {
 		tioreq->ti_databytes += irfop->irf_iofop.if_rbulk.rb_bytes;
-		M0_LOG(M0_FATAL, "Returned no of bytes = %llu",
+		M0_LOG(M0_INFO, "Returned no of bytes = %llu",
 		       irfop->irf_iofop.if_rbulk.rb_bytes);
 	} else
 		tioreq->ti_parbytes  += irfop->irf_iofop.if_rbulk.rb_bytes;
@@ -4855,7 +4828,7 @@ static int nw_xfer_req_dispatch(struct nw_xfer_request *xfer)
 
 	m0_htable_for(tioreqht, ti, &xfer->nxr_tioreqs_hash) {
 		if (ti->ti_state != M0_PNDS_ONLINE) {
-			M0_LOG(M0_FATAL, "Skipped iofops prepare for "FID_F,
+			M0_LOG(M0_INFO, "Skipped iofops prepare for "FID_F,
 			       FID_P(&ti->ti_fid));
 			continue;
 		}
@@ -4870,12 +4843,9 @@ static int nw_xfer_req_dispatch(struct nw_xfer_request *xfer)
 	} m0_htable_endfor;
 
 	m0_htable_for(tioreqht, ti, &xfer->nxr_tioreqs_hash) {
-
-		M0_LOG(M0_INFO, "Will be submitting fops for device "FID_F,
-		       FID_P(&ti->ti_fid));
 		/* Skips the target device if it is not online. */
 		if (ti->ti_state != M0_PNDS_ONLINE) {
-			M0_LOG(M0_FATAL, "Skipped device "FID_F,
+			M0_LOG(M0_INFO, "Skipped device "FID_F,
 			       FID_P(&ti->ti_fid));
 			continue;
 		}
@@ -5160,9 +5130,7 @@ static int target_ioreq_iofops_prepare(struct target_ioreq *ti,
 		bvec  = &ti->ti_bufvec;
 		pattr = ti->ti_pageattrs;
 	} else {
-		M0_LOG(M0_FATAL,"state of device %d is %d",(int)ti->ti_fid.f_container, (int)ti->ti_state);
 		if (ti->ti_dgvec == NULL) {
-			M0_LOG(M0_FATAL, "Caught the device:%d", (int)ti->ti_fid.f_container);
 			M0_RETURN(0);
 		}
 		ivec  = &ti->ti_dgvec->dr_ivec;
diff --git a/m0t1fs/linux_kernel/st/m0t1fs_sns_repair_mf.sh b/m0t1fs/linux_kernel/st/m0t1fs_sns_repair_mf.sh
index eaf6951..98e3e55 100755
--- a/m0t1fs/linux_kernel/st/m0t1fs_sns_repair_mf.sh
+++ b/m0t1fs/linux_kernel/st/m0t1fs_sns_repair_mf.sh
@@ -6,70 +6,8 @@
 . `dirname $0`/m0t1fs_common_inc.sh
 . `dirname $0`/m0t1fs_client_inc.sh
 . `dirname $0`/m0t1fs_server_inc.sh
+. `dirname $0`/m0t1fs_sns_common_inc.sh
 
-pool_mach_set_failure()
-{
-	DEVICES=""
-	STATE=""
-	for i in "$@"
-	do
-		DEVICES="$DEVICES -I $i"
-		STATE="$STATE -s 1"
-	done
-	poolmach="$MERO_CORE_ROOT/pool/m0poolmach -O Set -T device -N $# \
-		 $DEVICES $STATE -C ${lnet_nid}:${SNS_CLI_EP} $IOSEP"
-	echo $poolmach
-	if ! $poolmach ; then
-		echo "m0poolmach failed"
-		unmount_and_clean &>> $MERO_TEST_LOGFILE
-		return 1
-	fi
-
-	return 0
-}
-
-pool_mach_query()
-{
-	DEVICES=""
-	for i in "$@"
-	do
-		DEVICES="$DEVICES -I $i"
-	done
-	poolmach="$MERO_CORE_ROOT/pool/m0poolmach -O Query -T device -N $# \
-		 $DEVICES -C ${lnet_nid}:${SNS_CLI_EP} $IOSEP"
-	echo $poolmach
-	if ! $poolmach ; then
-		echo "m0poolmach failed"
-		unmount_and_clean &>> $MERO_TEST_LOGFILE
-		return 1
-	fi
-
-	return 0
-}
-
-sns_repair()
-{
-	repair_trigger="$MERO_CORE_ROOT/sns/cm/st/m0repair -O 2 -C ${lnet_nid}:${SNS_CLI_EP} $IOSEP"
-	echo $repair_trigger
-	if ! $repair_trigger ; then
-		echo "SNS Repair failed"
-		return 1
-	fi
-
-	return 0
-}
-
-sns_rebalance()
-{
-        rebalance_trigger="$MERO_CORE_ROOT/sns/cm/st/m0repair -O 4 -C ${lnet_nid}:${SNS_CLI_EP} $IOSEP"
-        echo $rebalance_trigger
-        if ! $rebalance_trigger ; then
-                echo "SNS Re-balance failed"
-                return 1
-        fi
-
-	return 0
-}
 
 sns_repair_test()
 {
-- 
1.8.3.2

