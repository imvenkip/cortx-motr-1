From 3ed9b3969d339827389643603db5a161f68205e7 Mon Sep 17 00:00:00 2001
From: Nachiket Sahasrabuddhe <nachiket_sahasrabuddhe@xyratex.com>
Date: Thu, 9 Jan 2014 15:23:46 +0530
Subject: [PATCH 03/14] dgmode-spare-map -Added a patch for cascaded failure in
 pargrp_iomap_dgmode_process.

---
 m0t1fs/linux_kernel/file.c | 108 ++++++++++++++++++++++++++++++++++++++-------
 1 file changed, 92 insertions(+), 16 deletions(-)

diff --git a/m0t1fs/linux_kernel/file.c b/m0t1fs/linux_kernel/file.c
index f6403f8..37f369b 100644
--- a/m0t1fs/linux_kernel/file.c
+++ b/m0t1fs/linux_kernel/file.c
@@ -650,6 +650,10 @@ M0_INTERNAL void io_bob_tlists_init(void)
 	M0_ASSERT(iofop_bobtype.bt_magix == M0_T1FS_IOFOP_MAGIC);
 }
 
+static int state_of_unit(struct m0_pdclust_src_addr *src,
+			 struct io_request *req,
+			 enum m0_pool_nd_state *state);
+
 static void io_rpc_item_cb (struct m0_rpc_item *item);
 static void io_req_fop_release(struct m0_ref *ref);
 
@@ -2223,19 +2227,24 @@ static int pargrp_iomap_dgmode_process(struct pargrp_iomap *map,
 		                       m0_bindex_t         *index,
 			               uint32_t             count)
 {
-	int                        rc = 0;
-	uint32_t                   seg;
-	uint32_t                   row;
-	uint32_t                   col;
-	uint32_t                   tgt_id;
-	m0_bindex_t                goff;
-	struct m0_layout_enum     *le;
-	struct m0_pdclust_layout  *play;
-	struct m0_pdclust_src_addr src;
-	struct m0_pdclust_tgt_addr tgt;
-	enum m0_pdclust_unit_type  unit_type;
-	struct m0t1fs_sb	  *msb;
-	const struct m0_fid	  *gfid;
+	int                         rc = 0;
+	uint32_t                    seg;
+	uint32_t                    row;
+	uint32_t                    col;
+	uint32_t                    tgt_id;
+	m0_bindex_t                 goff;
+	struct m0_layout_enum      *le;
+	struct m0_pdclust_layout   *play;
+	struct m0_pdclust_instance *play_instance;
+	struct m0_pdclust_src_addr  src;
+	struct m0_pdclust_src_addr  spare;
+	struct m0_pdclust_tgt_addr  tgt;
+	enum m0_pdclust_unit_type   unit_type;
+	enum m0_pool_nd_state	    dev_state;
+	struct m0t1fs_sb	   *msb;
+	const struct m0_fid	   *gfid;
+	uint32_t		    spare_slot;
+	uint32_t		    spare_slot_prev;
 
 	M0_PRE_EX(pargrp_iomap_invariant(map));
 	M0_ENTRY("grpid = %llu, count = %u\n", map->pi_grpid, count);
@@ -2243,6 +2252,7 @@ static int pargrp_iomap_dgmode_process(struct pargrp_iomap *map,
 	M0_PRE(index != NULL);
 	M0_PRE(count >  0);
 	M0_PRE(ioreq_sm_state(map->pi_ioreq) == IRS_DEGRADED_READING);
+	M0_PRE(M0_IN(dev_state,(M0_PNDS_FAILED, M0_PNDS_SNS_REPAIRED)));
 
 	/*
 	 * Finds out the id of target object to which failed IO fop
@@ -2253,10 +2263,12 @@ static int pargrp_iomap_dgmode_process(struct pargrp_iomap *map,
 	tgt_id = m0_layout_enum_find(le, file_to_fid(map->pi_ioreq->ir_file),
 			             &tio->ti_fid);
 	play   = pdlayout_get(map->pi_ioreq);
+	play_instance = pdlayout_instance(layout_instance(map->pi_ioreq));
 	map->pi_state = PI_DEGRADED;
 	msb = file_to_sb(map->pi_ioreq->ir_file);
 	gfid = file_to_fid(map->pi_ioreq->ir_file);
-
+	rc = m0_poolmach_device_state(msb->csb_pool.po_mach,
+				      tio->ti_fid.f_container, &dev_state);
 	for (seg = 0; seg < count; ++seg) {
 
 		tgt.ta_frame = index[seg] / layout_unit_size(play);
@@ -2272,6 +2284,26 @@ static int pargrp_iomap_dgmode_process(struct pargrp_iomap *map,
 		M0_ASSERT(src.sa_group == map->pi_grpid);
 		M0_ASSERT(src.sa_unit  <  layout_n(play) + layout_k(play));
 		unit_type = m0_pdclust_unit_classify(play, src.sa_unit);
+		if (dev_state == M0_PNDS_SNS_REPAIRED) {
+			if (unit_type == M0_PUT_SPARE)
+				continue;
+			rc = m0_sns_repair_spare_map(msb->csb_pool.po_mach,
+						     gfid, play, play_instance,
+						     src.sa_group, src.sa_unit,
+						     &spare_slot,
+						     &spare_slot_prev);
+			if (rc != 0) {
+				M0_ADDB_FUNC_FAIL(&m0_addb_gmc,
+						  M0T1FS_ADDB_LOC_TIOREQ_MAP_QSPSLOT,
+						  rc, &m0t1fs_addb_ctx);
+				M0_RETURN(rc);
+			}
+			spare.sa_group = src.sa_group;
+			spare.sa_unit = spare_slot_prev;
+			rc = state_of_unit(&spare, map->pi_ioreq, &dev_state);
+			if (dev_state == M0_PNDS_SNS_REPAIRED)
+				continue;
+		}
 		if (unit_type == M0_PUT_SPARE) {
 			rc = m0_sns_repair_data_map(msb->csb_pool.po_mach,
 						    gfid, play, src.sa_group,
@@ -2344,6 +2376,32 @@ par_fail:
 	M0_RETERR(rc, "dgmode_process failed");
 }
 
+int state_of_unit(struct m0_pdclust_src_addr *src,
+		  struct io_request *req, enum m0_pool_nd_state *state)
+{
+	struct m0_pdclust_layout   *play;
+	struct m0_pdclust_instance *play_instance;
+	struct m0_pdclust_tgt_addr  tgt;
+	struct m0_fid		    tfid;
+	int			    rc;
+	struct m0t1fs_sb	   *msb;
+
+	msb = file_to_sb(req->ir_file);
+	play   = pdlayout_get(req);
+	play_instance = pdlayout_instance(layout_instance(req));
+	m0_pdclust_instance_map(play_instance, src, &tgt);
+	tfid = target_fid(req, &tgt);
+	rc = m0_poolmach_device_state(msb->csb_pool.po_mach, tfid.f_container,
+				      state);
+	if (rc != 0) {
+		M0_ADDB_FUNC_FAIL(&m0_addb_gmc,
+				M0T1FS_ADDB_LOC_TIOREQ_MAP_QDEVST,
+				rc, &m0t1fs_addb_ctx);
+		M0_RETURN(rc);
+	}
+	return 0;
+}
+
 static int pargrp_iomap_dgmode_postprocess(struct pargrp_iomap *map)
 {
 	int                       rc = 0;
@@ -3113,8 +3171,9 @@ static int ioreq_dgmode_write(struct io_request *req, bool rmw)
 
 static int ioreq_dgmode_read(struct io_request *req, bool rmw)
 {
-	int                      rc            = 0;
-	int                      failed_dev_nr = 0;
+	int                      rc              = 0;
+	int                      failed_dev_nr   = 0;
+	int                      repaired_dev_nr = 0;
 	uint64_t                 id;
 	struct m0t1fs_sb        *csb;
 	struct io_req_fop       *irfop;
@@ -3169,6 +3228,23 @@ static int ioreq_dgmode_read(struct io_request *req, bool rmw)
 		} m0_tl_endfor;
 	} m0_htable_endfor;
 
+	if (repaired_dev_nr != 0 && failed_dev_nr != 0) {
+		m0_htable_for(tioreqht, ti, &req->ir_nwxfer.nxr_tioreqs_hash) {
+			rc = m0_poolmach_device_state(csb->csb_pool.po_mach,
+					ti->ti_fid.f_container, &state);
+			if (rc != 0)
+				M0_RETERR(rc, "Failed to retrieve device state");
+			if (state != M0_PNDS_SNS_REPAIRED)
+				continue;
+			m0_tl_for (iofops, &ti->ti_iofops, irfop) {
+				rc = irfop->irf_ops->irfo_dgmode_read(irfop);
+				if (rc != 0)
+					break;
+			} m0_tl_endfor;
+
+		} m0_htable_endfor;
+	}
+
 	if (rc != 0)
 		M0_RETERR(rc, "dgmode failed");
 
-- 
1.8.3.2

