From 0aa9058847b3220efae4695fae32aa643fceabe0 Mon Sep 17 00:00:00 2001
From: Nachiket Sahasrabuddhe <nachiket_sahasrabuddhe@xyratex.com>
Date: Mon, 10 Feb 2014 19:49:15 +0530
Subject: [PATCH 08/14] dgmode-spare-map-writeIO

-Code reorganisation is over.
-Necessary to prepare a script for testing.
---
 m0t1fs/linux_kernel/file.c          | 80 ++++++++++++-------------------------
 m0t1fs/linux_kernel/file_internal.h |  7 +---
 2 files changed, 27 insertions(+), 60 deletions(-)

diff --git a/m0t1fs/linux_kernel/file.c b/m0t1fs/linux_kernel/file.c
index ec71f73..28d6259 100644
--- a/m0t1fs/linux_kernel/file.c
+++ b/m0t1fs/linux_kernel/file.c
@@ -387,12 +387,12 @@ static inline m0_bcount_t seg_endpos(const struct m0_indexvec *ivec, uint32_t i)
 	return ivec->iv_index[i] + ivec->iv_vec.v_count[i];
 }
 
-static inline struct inode *file_to_inode(struct file *file)
+static inline struct inode *file_to_inode(const struct file *file)
 {
 	return file->f_dentry->d_inode;
 }
 
-static inline struct m0t1fs_inode *file_to_m0inode(struct file *file)
+static inline struct m0t1fs_inode *file_to_m0inode(const struct file *file)
 {
 	return M0T1FS_I(file_to_inode(file));
 }
@@ -417,7 +417,8 @@ static inline uint64_t page_nr(m0_bcount_t size)
 	return size >> PAGE_CACHE_SHIFT;
 }
 
-static inline struct m0_layout_instance *layout_instance(struct io_request *req)
+static inline struct m0_layout_instance *layout_instance(const struct io_request
+							 *req)
 {
 	return file_to_m0inode(req->ir_file)->ci_layout_instance;
 }
@@ -428,7 +429,8 @@ static inline struct m0_pdclust_instance *pdlayout_instance(struct
 	return m0_layout_instance_to_pdi(li);
 }
 
-static inline struct m0_pdclust_layout *pdlayout_get(struct io_request *req)
+static inline struct m0_pdclust_layout *pdlayout_get(const struct io_request
+						     *req)
 {
 	return m0_layout_to_pdl(layout_instance(req)->li_l);
 }
@@ -532,7 +534,7 @@ static inline m0_bindex_t gfile_offset(m0_bindex_t                 toff,
 	return goff;
 }
 
-static inline struct m0_fid target_fid(struct io_request	  *req,
+static inline struct m0_fid target_fid(const struct io_request	  *req,
 				       struct m0_pdclust_tgt_addr *tgt)
 {
 	return m0t1fs_ios_cob_fid(file_to_m0inode(req->ir_file), tgt->ta_obj);
@@ -650,14 +652,14 @@ M0_INTERNAL void io_bob_tlists_init(void)
 	M0_ASSERT(iofop_bobtype.bt_magix == M0_T1FS_IOFOP_MAGIC);
 }
 
-static void refresh_device_state(struct nw_xfer_request *xfer, bool rmw);
+static void device_state_reset(struct nw_xfer_request *xfer, bool rmw);
 static int io_spare_map(const struct pargrp_iomap *map,
 			const struct m0_pdclust_src_addr *src,
 			uint32_t *spare_slot, uint32_t *spare_slot_prev,
 			enum m0_pool_nd_state *eff_state);
 
-static int state_of_unit(struct m0_pdclust_src_addr *src,
-			 struct io_request *req,
+static int state_of_unit(const struct m0_pdclust_src_addr *src,
+			 const struct io_request *req,
 			 enum m0_pool_nd_state *state);
 
 static void io_rpc_item_cb (struct m0_rpc_item *item);
@@ -2212,9 +2214,7 @@ static int page_update(struct pargrp_iomap *map, uint32_t row, uint32_t col,
 {
 	struct m0_pdclust_layout  *play;
 	struct m0_pdclust_src_addr src;
-	struct m0_pdclust_tgt_addr tgt;
 	struct m0t1fs_sb          *csb;
-	struct m0_fid		   tfid;
 	enum m0_pool_nd_state      state;
 	uint32_t		   spare_slot;
 	uint32_t		   spare_prev;
@@ -2232,13 +2232,8 @@ static int page_update(struct pargrp_iomap *map, uint32_t row, uint32_t col,
 		src.sa_unit = col;
 	else
 		src.sa_unit = col + layout_n(play);
-	m0_pdclust_instance_map(pdlayout_instance(
-				layout_instance(map->pi_ioreq)),
-				&src, &tgt);
-	tfid = target_fid(map->pi_ioreq, &tgt);
-	/*XXX: Has effective-failure been considered ? */
-	rc = m0_poolmach_device_state(csb->csb_pool.po_mach,
-				      tfid.f_container, &state);
+
+	rc = state_of_unit(&src, map->pi_ioreq, &state);
 	if (rc == 0) {
 		if (M0_IN(state, (M0_PNDS_FAILED, M0_PNDS_OFFLINE,
 				  M0_PNDS_SNS_REPAIRING))) {
@@ -2253,7 +2248,7 @@ static int page_update(struct pargrp_iomap *map, uint32_t row, uint32_t col,
 				          &state);
 			if (rc == 0 &&
 			    M0_IN(state, (M0_PNDS_FAILED, M0_PNDS_OFFLINE,
-					      M0_PNDS_SNS_REPAIRING))) {
+					  M0_PNDS_SNS_REPAIRING))) {
 				if (page_type == PA_DATA)
 					map->pi_databufs[row][col]->db_flags |=
 						PA_READ_FAILED;
@@ -2328,7 +2323,6 @@ static int pargrp_iomap_dgmode_process(struct pargrp_iomap *map,
 			rc = 0;
 			goto end;
 		}
-		++map->pi_ioreq->ir_failed_nr;
 	}
 	map->pi_state = PI_DEGRADED;
 	++map->pi_ioreq->ir_dgmap_nr;
@@ -2436,8 +2430,8 @@ static int io_spare_map(const struct pargrp_iomap *map,
 	return 0;
 }
 
-int state_of_unit(struct m0_pdclust_src_addr *src,
-		  struct io_request *req, enum m0_pool_nd_state *state)
+int state_of_unit(const struct m0_pdclust_src_addr *src,
+		  const struct io_request *req, enum m0_pool_nd_state *state)
 {
 	struct m0_pdclust_layout   *play;
 	struct m0_pdclust_instance *play_instance;
@@ -2547,7 +2541,6 @@ static int pargrp_iomap_dgmode_postprocess(struct pargrp_iomap *map)
 			 * failure (PA_READ_FAILED flag set) are read in
 			 * degraded mode.
 			 */
-//			if (M0_IN(map->pi_rtype, (PIR_READOLD, PIR_NONE)) &&
 			if (within_eof) {
 				dbuf->db_flags |= PA_DGMODE_READ;
 				M0_LOG(M0_DEBUG, "[%u][%u], flag = %d\n",
@@ -2595,7 +2588,7 @@ static int pargrp_iomap_dgmode_postprocess(struct pargrp_iomap *map)
 			/* Skips the page if it is marked as PA_READ_FAILED. */
 			if (dbuf->db_flags & PA_READ_FAILED)
 				continue;
-//			if (M0_IN(map->pi_rtype, (PIR_READREST, PIR_NONE)))
+			if (M0_IN(map->pi_rtype, (PIR_READREST, PIR_NONE)))
 				dbuf->db_flags |= PA_DGMODE_READ;
 		}
 	}
@@ -3179,8 +3172,6 @@ static int ioreq_dgmode_write(struct io_request *req, bool rmw)
 	 * IO request will be reshuffled by redirecting pages meant for
 	 * failed device(s) to its corresponding spare unit(s).
 	 */
-//	M0_ASSERT(M0_IN(req->ir_sns_state, (SRS_REPAIR_NOTDONE,
-//					    SRS_REPAIR_DONE)));
 	M0_LOG(M0_INFO, "1. req->ir_rc = %d, nwxfer rc = %d",
 	       req->ir_rc, req->ir_nwxfer.nxr_rc);
 
@@ -3192,7 +3183,6 @@ static int ioreq_dgmode_write(struct io_request *req, bool rmw)
 	 */
 	req->ir_nwxfer.nxr_ops->nxo_complete(&req->ir_nwxfer, rmw);
 	if (M0_IN(req->ir_sns_state, (SRS_UNINITIALIZED, SRS_REPAIR_NOTDONE))) {
-	//if (req->ir_sns_state == SRS_REPAIR_NOTDONE) {
 		M0_LOG(M0_FATAL,"DEGRADED MODE WRITE");
 		/*
 		 * Resets count of data bytes and parity bytes along with
@@ -3243,7 +3233,6 @@ static int ioreq_dgmode_write(struct io_request *req, bool rmw)
 static int ioreq_dgmode_read(struct io_request *req, bool rmw)
 {
 	int                      rc            = 0;
-	int                      repaired_dev_nr = 0;
 	uint64_t                 id;
 	struct m0t1fs_sb        *csb;
 	struct io_req_fop       *irfop;
@@ -3276,10 +3265,8 @@ static int ioreq_dgmode_read(struct io_request *req, bool rmw)
 			M0_RETERR(rc, "Failed to retrieve device state");
 		M0_LOG(M0_INFO, "device state for "FID_F" is %d",
 		       FID_P(&ti->ti_fid), state);
-		if (ti->ti_state == M0_PNDS_SNS_REPAIRED)
-			++repaired_dev_nr;
 		if (!M0_IN(state, (M0_PNDS_FAILED, M0_PNDS_OFFLINE,
-			   M0_PNDS_SNS_REPAIRING)))
+			   M0_PNDS_SNS_REPAIRING, M0_PNDS_SNS_REPAIRED)))
 			continue;
 		/*
 		 * Finds out parity groups for which read IO failed and marks
@@ -3288,7 +3275,6 @@ static int ioreq_dgmode_read(struct io_request *req, bool rmw)
 		 * failed, rest of the parity group also needs to be read
 		 * (subject to file size) in order to re-generate lost data.
 		 */
-		++req->ir_failed_nr;
 
 		m0_tl_for (iofops, &ti->ti_iofops, irfop) {
 			M0_LOG(M0_INFO,"Processing fops to failed device "FID_F"\n", FID_P(&ti->ti_fid));
@@ -3297,30 +3283,13 @@ static int ioreq_dgmode_read(struct io_request *req, bool rmw)
 				break;
 		} m0_tl_endfor;
 	} m0_htable_endfor;
-	if (repaired_dev_nr > 0) {
-		M0_LOG(M0_FATAL, "Repaired devices = %d", (int)repaired_dev_nr);
-		m0_htable_for(tioreqht, ti, &req->ir_nwxfer.nxr_tioreqs_hash) {
-			rc = m0_poolmach_device_state(csb->csb_pool.po_mach,
-					ti->ti_fid.f_container, &state);
-			if (rc != 0)
-				M0_RETERR(rc, "Failed to retrieve device state");
-			if (state != M0_PNDS_SNS_REPAIRED)
-				continue;
-			m0_tl_for (iofops, &ti->ti_iofops, irfop) {
-				rc = irfop->irf_ops->irfo_dgmode_read(irfop);
-				if (rc != 0)
-					break;
-			} m0_tl_endfor;
 
-		} m0_htable_endfor;
-	}
 	if (rc != 0)
 		M0_RETERR(rc, "dgmode failed");
 
 	/*
-	 * Starts processing the pages again if one or more devices
-	 * are in one of the states
-	 * { M0_PNDS_FAILED, M0_PNDS_OFFLINE, M0_PNDS_SNS_REPAIRING }
+	 * Starts processing the pages again if any of the parity groups is
+	 * in the state PI_DEGRADED.
 	 */
 	if (req->ir_dgmap_nr > 0) {
 		for (id = 0; id < req->ir_iomap_nr; ++id) {
@@ -3589,7 +3558,7 @@ static int ioreq_iosm_handle(struct io_request *req)
 							     rmw);
 			if (req->ir_rc != 0)
 				goto fail_locked;
-			refresh_device_state(&req->ir_nwxfer, rmw);
+			device_state_reset(&req->ir_nwxfer, rmw);
 		}
 		ioreq_sm_state_set(req, IRS_WRITING);
 		rc = req->ir_ops->iro_parity_recalc(req);
@@ -3879,7 +3848,7 @@ static int nw_xfer_tioreq_map(struct nw_xfer_request           *xfer,
 					  rc, &m0t1fs_addb_ctx);
 			M0_RETURN(rc);
 		}
-		/* Check if there is effective-failure. */
+		/* Check if there is an effective-failure. */
 		if (spare_slot_prev != src->sa_unit) {
 			spare.sa_unit = spare_slot_prev;
 			m0_pdclust_instance_map(play_instance, &spare, tgt);
@@ -4189,8 +4158,9 @@ static void target_ioreq_seg_add(struct target_ioreq              *ti,
 	       tgt->ta_frame, tgt->ta_obj,
 	       unit_type == M0_PUT_DATA ? 'D' : 'P');
 
-	if (M0_IN(ioreq_sm_state(req),
-	    (IRS_DEGRADED_READING, IRS_DEGRADED_WRITING))) {
+	if (ioreq_sm_state(req) == IRS_DEGRADED_READING ||
+	    (ioreq_sm_state(req) == IRS_DEGRADED_WRITING &&
+	     req->ir_sns_state   == SRS_REPAIR_DONE)) {
 		M0_LOG(M0_FATAL,"(seg-add)state of device %d is %d",(int)ti->ti_fid.f_container, (int)ti->ti_state);
 		M0_ASSERT(ti->ti_dgvec != NULL);
 		ivec  = &ti->ti_dgvec->dr_ivec;
@@ -4935,7 +4905,7 @@ out:
 	M0_RETURN(rc);
 }
 
-static void refresh_device_state(struct nw_xfer_request *xfer, bool rmw)
+static void device_state_reset(struct nw_xfer_request *xfer, bool rmw)
 {
 	struct io_request   *req;
 	struct target_ioreq *ti;
diff --git a/m0t1fs/linux_kernel/file_internal.h b/m0t1fs/linux_kernel/file_internal.h
index da72d59..25a45b8 100644
--- a/m0t1fs/linux_kernel/file_internal.h
+++ b/m0t1fs/linux_kernel/file_internal.h
@@ -1394,11 +1394,8 @@ struct io_request {
 	enum sns_repair_state        ir_sns_state;
 
 	/**
-	 * Total number of failed devices associated with the IO request.
-	 */
-	uint32_t		     ir_failed_nr;
-	/**
-	 * Total number of parity-maps that are in degraded mode.
+	 * Total number of parity-maps associated with this request that are in
+	 * degraded mode.
 	 */
 	uint32_t		     ir_dgmap_nr;
 };
-- 
1.8.3.2

