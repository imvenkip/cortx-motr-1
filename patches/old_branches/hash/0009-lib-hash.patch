From f4524e5623f1f11c7663141f1f33b382f55bb913 Mon Sep 17 00:00:00 2001
From: "anand.vidwansa" <anand_vidwansa@xyratex.com>
Date: Thu, 25 Jul 2013 23:25:30 -0700
Subject: [PATCH 09/10] lib:hash - Changed names of some APIs. - Removed
 key_type from hash initialization routine. - Fixed incorrect documentation. -
 Moved build time asserts to check type of hash function, key equal routine.

---
 lib/hash.c                    |  2 +-
 lib/hash.h                    | 45 +++++++++++++++++++++----------------------
 lib/ut/hash.c                 | 12 ++++++------
 m0t1fs/linux_kernel/file.c    |  3 +--
 m0t1fs/linux_kernel/ut/file.c |  2 +-
 5 files changed, 31 insertions(+), 33 deletions(-)

diff --git a/lib/hash.c b/lib/hash.c
index df64df3..943e455 100644
--- a/lib/hash.c
+++ b/lib/hash.c
@@ -201,7 +201,7 @@ M0_INTERNAL bool m0_htable_is_empty(const struct m0_htable *htable)
 	return nr == htable->h_bucket_nr;
 }
 
-M0_INTERNAL uint64_t m0_htable_length(const struct m0_htable *htable)
+M0_INTERNAL uint64_t m0_htable_size(const struct m0_htable *htable)
 {
 	uint64_t nr;
 	uint64_t len = 0;
diff --git a/lib/hash.h b/lib/hash.h
index 019530d..3cc558d 100644
--- a/lib/hash.h
+++ b/lib/hash.h
@@ -29,7 +29,7 @@
 /**
  * @defgroup hash Hash table.
  *
- * Hash table module provides a simple hash implementation built over
+ * Hash table module provides a simple hash implementation built on
  * top of typed lists. @see tlist.
  *
  * Often, lookup for objects stored in simple tlists proves to be expensive
@@ -102,8 +102,8 @@
  * - Now define hash descriptor like this.
  *
  *   M0_HT_DESCR_DEFINE(foohash, "Hash of foo structures", static, struct foo,
- *                      f_link, f_magic, FOO_MAGIC, BAR_MAGIC, uint64_t,
- *                      f_hash_key, hash_func, hash_key_eq);
+ *                      f_link, f_magic, FOO_MAGIC, BAR_MAGIC, f_hash_key,
+ *                      hash_func, hash_key_eq);
  *
  *   This will take care of defining tlist descriptor internally.
  *
@@ -163,10 +163,9 @@ struct m0_htable {
 	uint64_t                  h_bucket_nr;
 
 	/**
-	 * Array of hash buckets. Hash buckets are supposed to be
-	 * indexed in increasing order of hash key.
-	 * Ergo, the very first bucket will have bucket id 0, the next one
-	 * will have bucket id 1 and so on.
+	 * Array of hash buckets.
+	 * Hash buckets are supposed to be indexed in increasing order of
+	 * bucket id retrieved using hash function.
 	 */
 	struct m0_hbucket        *h_buckets;
 
@@ -176,7 +175,8 @@ struct m0_htable {
 
 /**
  * Hash table descriptor. An instance of this type must be defined per
- * struct m0_htable.
+ * hash table type. Multiple instances of m0_htable can share a single
+ * descriptor.
  * It keeps track of tlist descriptor, offset to key field and hash function.
  */
 struct m0_ht_descr {
@@ -269,35 +269,34 @@ M0_INTERNAL void *m0_htable_lookup(const struct m0_htable *htable,
 M0_INTERNAL bool m0_htable_is_empty(const struct m0_htable *htable);
 
 /** Returns number of objects stored within m0_htable. */
-M0_INTERNAL uint64_t m0_htable_length(const struct m0_htable *htable);
+M0_INTERNAL uint64_t m0_htable_size(const struct m0_htable *htable);
 
 /** Defines a hashtable descriptor. */
-#define M0_HT_DESCR(name, amb_type, key_type, key_field,		\
-		    hash_func, key_eq)					\
+#define M0_HT_DESCR(name, amb_type, key_field, hash_func, key_eq)	\
 {									\
 	.hd_tldescr    = &name ## _tl,					\
 	.hd_key_eq     = key_eq,					\
 	.hd_hash_func  = hash_func,					\
 	.hd_key_offset = offsetof(amb_type, key_field),			\
-};									\
-									\
-M0_BASSERT(M0_HAS_TYPE(M0_FIELD_VALUE(amb_type, key_field),		\
-		       key_type));					\
+};
 
 /** Defines a hashtable descriptor with given scope. */
 #define M0_HT_DESCR_DEFINE(name, htname, scope, amb_type, amb_link_field,\
 			   amb_magic_field, amb_magic, head_magic,	\
-			   key_type, key_field, hash_func, key_eq)	\
+			   key_field, hash_func, key_eq)		\
+									\
+M0_BASSERT(sizeof(hash_func(NULL, &M0_FIELD_VALUE(amb_type, key_field))) > 0);\
+M0_BASSERT(sizeof(key_eq(&M0_FIELD_VALUE(amb_type, key_field),		\
+			 &M0_FIELD_VALUE(amb_type, key_field))) > 0);	\
 									\
 M0_TL_DESCR_DEFINE(name, htname, scope, amb_type, amb_link_field.hl_link,	\
 		   amb_magic_field, amb_magic, head_magic);		\
 									\
 scope const struct m0_ht_descr name ## _ht = M0_HT_DESCR(name,		\
 							 amb_type,	\
-							 key_type,	\
 							 key_field,	\
-							 hash_func,	\
-							 key_eq)
+	(uint64_t (*)(const struct m0_htable *, const void *))hash_func,\
+	(bool (*)(const void *, const void *))key_eq)
 
 /** Declares a hashtable descriptr with given scope. */
 #define M0_HT_DESCR_DECLARE(name, scope)				\
@@ -317,7 +316,7 @@ scope amb_type *name ## _htable_lookup(const struct m0_htable *htable,	\
 				       key_type               *key);	\
 scope void name ## _htable_fini(struct m0_htable *htable);		\
 scope bool name ## _htable_is_empty(const struct m0_htable *htable);	\
-scope uint64_t m0_htable_length(const struct m0_htable *htable);
+scope uint64_t name ## _htable_size(const struct m0_htable *htable);
 
 /**
  * Defines all functions of hash table which accepts ambient type
@@ -361,9 +360,9 @@ scope __AUN bool name ## _htable_is_empty(const struct m0_htable *htable)\
 	return m0_htable_is_empty(htable);				\
 }									\
 									\
-scope __AUN uint64_t name ## _htable_length(const struct m0_htable *htable)\
+scope __AUN uint64_t name ## _htable_size(const struct m0_htable *htable)\
 {									\
-	return m0_htable_length(htable);				\
+	return m0_htable_size(htable);					\
 }									\
 
 /**
@@ -397,7 +396,7 @@ scope __AUN uint64_t name ## _htable_length(const struct m0_htable *htable)\
 /**
  * An open ended version of loop over all objects in all hash buckets
  * in a m0_htable.
- * This loop has to be closed using m0_htable_endfor() macro.
+ * This loop has to be closed using m0_htable_endfor macro.
  */
 #define m0_htable_for(name, var, htable)				    \
 ({									    \
diff --git a/lib/ut/hash.c b/lib/ut/hash.c
index 5f5c4f1..3990e72 100644
--- a/lib/ut/hash.c
+++ b/lib/ut/hash.c
@@ -70,7 +70,7 @@ static bool key_eq(const void *key1, const void *key2)
 
 M0_HT_DESCR_DEFINE(foohash, "Hash of fops", static, struct foo,
 		   f_hlink, f_magic, FOO_MAGIC, BAR_MAGIC,
-		   uint64_t, f_hkey, hash_func, key_eq);
+		   f_hkey, hash_func, key_eq);
 
 M0_HT_DEFINE(foohash, static, struct foo, uint64_t);
 
@@ -98,7 +98,7 @@ void test_hashtable(void)
 	M0_UT_ASSERT(thebar.b_hash.h_buckets != NULL);
 
 	foohash_htable_add(&thebar.b_hash, &foos[0]);
-	M0_UT_ASSERT(foohash_htable_length(&thebar.b_hash) == 1);
+	M0_UT_ASSERT(foohash_htable_size(&thebar.b_hash) == 1);
 	M0_UT_ASSERT(!foohash_htable_is_empty(&thebar.b_hash));
 	key = 0;
 	M0_UT_ASSERT(foohash_htable_lookup(&thebar.b_hash, &key) == &foos[0]);
@@ -110,7 +110,7 @@ void test_hashtable(void)
 
 	foohash_htable_del(&thebar.b_hash, &foos[0]);
 	M0_UT_ASSERT(foohash_htable_is_empty(&thebar.b_hash));
-	M0_UT_ASSERT(foohash_htable_length(&thebar.b_hash) == 0);
+	M0_UT_ASSERT(foohash_htable_size(&thebar.b_hash) == 0);
 	M0_UT_ASSERT(foohash_htable_lookup(&thebar.b_hash, &foos[0].f_hkey) ==
 		     NULL);
 
@@ -118,7 +118,7 @@ void test_hashtable(void)
 		foohash_htable_add(&thebar.b_hash, &foos[i]);
 		M0_UT_ASSERT(m0_tlink_is_in(&foohash_tl, &foos[i]));
 	}
-	M0_UT_ASSERT(foohash_htable_length(&thebar.b_hash) == FOO_NR);
+	M0_UT_ASSERT(foohash_htable_size(&thebar.b_hash) == FOO_NR);
 
 	for (i = 0; i < BUCKET_NR; ++i) {
 		hb = &thebar.b_hash.h_buckets[i];
@@ -138,13 +138,13 @@ void test_hashtable(void)
 
 	for (i = 0; i < FOO_NR; ++i) {
 		foohash_htable_del(&thebar.b_hash, &foos[i]);
-		M0_UT_ASSERT(foohash_htable_length(&thebar.b_hash) ==
+		M0_UT_ASSERT(foohash_htable_size(&thebar.b_hash) ==
 			     FOO_NR - (i + 1));
 		M0_UT_ASSERT(foohash_htable_lookup(&thebar.b_hash,
 					&foos[i].f_hkey) == NULL);
 		M0_UT_ASSERT(!m0_tlink_is_in(&foohash_tl, &foos[i]));
 	}
-	M0_UT_ASSERT(foohash_htable_length(&thebar.b_hash) == 0);
+	M0_UT_ASSERT(foohash_htable_size(&thebar.b_hash) == 0);
 	M0_UT_ASSERT(foohash_htable_is_empty(&thebar.b_hash));
 
 	foohash_htable_fini(&thebar.b_hash);
diff --git a/m0t1fs/linux_kernel/file.c b/m0t1fs/linux_kernel/file.c
index 98ce971..51c8bf7f 100644
--- a/m0t1fs/linux_kernel/file.c
+++ b/m0t1fs/linux_kernel/file.c
@@ -498,8 +498,7 @@ static bool tioreq_key_eq(const void *key1, const void *key2)
 M0_HT_DESCR_DEFINE(tioreqht, "Hash of target_ioreq objects", static,
 		   struct target_ioreq, ti_link, ti_magic,
 		   M0_T1FS_TIOREQ_MAGIC, M0_T1FS_TLIST_HEAD_MAGIC,
-		   uint64_t, ti_fid.f_container, tioreqs_hash_func,
-		   tioreq_key_eq);
+		   ti_fid.f_container, tioreqs_hash_func, tioreq_key_eq);
 
 M0_HT_DEFINE(tioreqht, static, struct target_ioreq, uint64_t);
 
diff --git a/m0t1fs/linux_kernel/ut/file.c b/m0t1fs/linux_kernel/ut/file.c
index 439433f..2cdc72a 100644
--- a/m0t1fs/linux_kernel/ut/file.c
+++ b/m0t1fs/linux_kernel/ut/file.c
@@ -648,7 +648,7 @@ static void nw_xfer_ops_test(void)
 	/* Test for nw_xfer_io_distribute. */
 	rc = nw_xfer_io_distribute(&req.ir_nwxfer);
 	M0_UT_ASSERT(rc == 0);
-	M0_UT_ASSERT(tioreqht_htable_length(&req.ir_nwxfer.nxr_tioreqs_hash) ==
+	M0_UT_ASSERT(tioreqht_htable_size(&req.ir_nwxfer.nxr_tioreqs_hash) ==
 			LAY_P);
 	m0_htable_for(tioreqht, ti, &req.ir_nwxfer.nxr_tioreqs_hash) {
 		M0_UT_ASSERT(ti->ti_nwxfer == &req.ir_nwxfer);
-- 
1.8.3.2

