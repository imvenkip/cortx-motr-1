From b5bf93040ae6ca3e908f0eade89309e8d3fa5b6d Mon Sep 17 00:00:00 2001
From: "anand.vidwansa" <anand_vidwansa@xyratex.com>
Date: Tue, 18 Jun 2013 03:49:46 -0700
Subject: [PATCH 04/10] lib:hash - Added support for generic keys (void *). -
 Moved tlist definitions inside hash table definitions. - Updated hash ut and
 IO code to align with new interfaces. - Updated documentation to align with
 new interfaces.

---
 lib/Kbuild.sub                      |   4 +-
 lib/Makefile.sub                    |   3 +-
 lib/hash.c                          | 295 +++++++++++-----------
 lib/hash.h                          | 479 ++++++++++++++++++++++++++----------
 lib/linux_kernel/ut/main.c          |   2 +
 lib/ut/Kbuild.sub                   |   1 +
 lib/ut/hash.c                       | 140 ++++++-----
 lib/ut/main.c                       |   4 +-
 m0t1fs/linux_kernel/file.c          | 115 +++++----
 m0t1fs/linux_kernel/file_internal.h |   2 +-
 m0t1fs/linux_kernel/ut/file.c       |  21 +-
 mero/magic.h                        |   6 +-
 12 files changed, 674 insertions(+), 398 deletions(-)

diff --git a/lib/Kbuild.sub b/lib/Kbuild.sub
index 1a2b533..8bad7bf 100644
--- a/lib/Kbuild.sub
+++ b/lib/Kbuild.sub
@@ -13,6 +13,7 @@ m0mero_objects += lib/assert.o \
                   lib/ext.o \
                   lib/ext_xc.o \
                   lib/finject.o \
+		  lib/hash.o \
                   lib/getopts.o \
                   lib/list.o \
                   lib/locality.o \
@@ -30,8 +31,7 @@ m0mero_objects += lib/assert.o \
                   lib/uuid.o \
                   lib/vec.o \
                   lib/vec.o \
-                  lib/vec_xc.o \
-		  lib/hash.o
+                  lib/vec_xc.o
 
 m0mero_objects += lib/linux_kernel/finject_init.o \
                   lib/linux_kernel/kassert.o \
diff --git a/lib/Makefile.sub b/lib/Makefile.sub
index 03a13a1..4a71b07 100644
--- a/lib/Makefile.sub
+++ b/lib/Makefile.sub
@@ -17,6 +17,7 @@ nobase_mero_include_HEADERS += lib/arith.h \
 			       lib/ext_xc.h \
                                lib/finject.h \
                                lib/getopts.h \
+			       lib/hash.h \
                                lib/list.h \
                                lib/locality.h \
                                lib/lockers.h \
@@ -71,6 +72,7 @@ mero_libmero_la_SOURCES += lib/assert.c \
                            lib/finject.c \
                            lib/finject_internal.h \
                            lib/getopts.c \
+			   lib/hash.c \
                            lib/list.c \
 			   lib/locality.c \
                            lib/lockers.c \
@@ -91,7 +93,6 @@ mero_libmero_la_SOURCES += lib/assert.c \
                            lib/uuid.c \
                            lib/vec.c \
                            lib/vec_xc.c \
-			   lib/hash.c \
                            lib/user_space/finject_init.c \
                            lib/user_space/memory.c \
                            lib/user_space/processor.c \
diff --git a/lib/hash.c b/lib/hash.c
index 83d8de2..1198e7f 100644
--- a/lib/hash.c
+++ b/lib/hash.c
@@ -14,7 +14,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Anand Vidwana <anand_vidwansa@xyratex.com>
+ * Original author: Anand Vidwansa <anand_vidwansa@xyratex.com>
  * Original creation date: 05/21/2013
  */
 
@@ -24,221 +24,236 @@
  */
 
 #include "lib/bob.h"	/* m0_bob_type */
-#include "lib/hash.h"   /* m0_hashlist */
+#include "lib/hash.h"   /* m0_htable */
 #include "lib/errno.h"  /* Include appropriate errno.h header. */
 #include "lib/arith.h"	/* min64u() */
 #include "lib/memory.h" /* M0_ALLOC_ARR() */
+#include "lib/misc.h"	/* m0_forall() */
 
-static const struct m0_bob_type hashlist_bobtype;
-M0_BOB_DEFINE(static, &hashlist_bobtype, m0_hashlist);
+static const struct m0_bob_type htable_bobtype;
+M0_BOB_DEFINE(static, &htable_bobtype, m0_htable);
 
-static const struct m0_bob_type hashlist_bobtype = {
-	.bt_name         = "hashlist",
-	.bt_magix_offset = offsetof(struct m0_hashlist, hl_magic),
+static const struct m0_bob_type htable_bobtype = {
+	.bt_name         = "hashtable",
+	.bt_magix_offset = offsetof(struct m0_htable, h_magic),
 	.bt_magix        = M0_LIB_HASHLIST_MAGIC,
 	.bt_check        = NULL,
 };
 
-static bool hashlist_invariant(const struct m0_hashlist *hlist);
+static bool htable_invariant(const struct m0_ht_descr *d,
+			     const struct m0_htable   *htable);
 
-M0_INTERNAL int m0_hashbucket_alloc_init(struct m0_hashlist *hlist,
-				         uint64_t            bucket_id)
+M0_INTERNAL void m0_hbucket_init(const struct m0_ht_descr *d,
+				 struct m0_hbucket        *bucket)
 {
-	M0_PRE(hlist != NULL);
-	M0_PRE(hlist->hl_buckets != NULL);
-	M0_PRE(hlist->hl_buckets[bucket_id] == NULL);
-
-	M0_ALLOC_PTR(hlist->hl_buckets[bucket_id]);
-	if (hlist->hl_buckets[bucket_id] == NULL)
-		return -ENOMEM;
+	M0_PRE(bucket != NULL);
+	M0_PRE(d != NULL);
+	M0_PRE(d->hd_tldescr != NULL);
 
-	hlist->hl_buckets[bucket_id]->hb_bucket_id = bucket_id;
-	m0_tlist_init(hlist->hl_tldescr,
-		      &hlist->hl_buckets[bucket_id]->hb_objects);
-	hlist->hl_buckets[bucket_id]->hb_hlist = hlist;
-	return 0;
+	m0_tlist_init(d->hd_tldescr, &bucket->hb_objects);
 }
 
-M0_INTERNAL void m0_hashbucket_dealloc_fini(struct m0_hashbucket *bucket)
+M0_INTERNAL void m0_hbucket_fini(const struct m0_ht_descr *d,
+				 struct m0_hbucket        *bucket)
 {
 	M0_PRE(bucket != NULL);
-	M0_PRE(bucket->hb_hlist != NULL);
+	M0_PRE(d != NULL);
+	M0_PRE(d->hd_tldescr != NULL);
+
+	m0_tlist_fini(d->hd_tldescr, &bucket->hb_objects);
+}
+
+M0_INTERNAL void *m0_htable_key(const struct m0_ht_descr *d,
+				void                     *amb)
+{
+	return d->hd_key(d, amb);
+}
 
-	bucket->hb_hlist->hl_buckets[bucket->hb_bucket_id] = NULL;
-	m0_tlist_fini(bucket->hb_hlist->hl_tldescr, &bucket->hb_objects);
-	bucket->hb_hlist = NULL;
-	m0_free(bucket);
+M0_INTERNAL bool m0_htable_key_eq(const struct m0_ht_descr *d,
+				  void                     *key1,
+				  void                     *key2)
+{
+	return d->hd_key_eq(key1, key2);
 }
 
-static uint64_t hashlist_key_get(const struct m0_hashlist *hlist,
-				 const void               *obj)
+static inline uint64_t key_get(const struct m0_ht_descr *d,
+			       void                     *amb)
 {
-	return *(uint64_t *)(obj + hlist->hl_key_offset);
+	uint64_t key = 0;
+
+	switch (d->hd_key_type) {
+	case M0_HT_KEY_U8 :
+		key = *(uint8_t *)m0_htable_key(d, amb);
+		break;
+	case M0_HT_KEY_U16:
+		key = *(uint16_t *)m0_htable_key(d, amb);
+		break;
+	case M0_HT_KEY_U32:
+		key = *(uint32_t *)m0_htable_key(d, amb);
+		break;
+	case M0_HT_KEY_U64:
+		key = *(uint64_t *)m0_htable_key(d, amb);
+		break;
+	default:
+		M0_IMPOSSIBLE("Invalid key type");
+	}
+	return key;
 }
 
-static bool hashlist_invariant(const struct m0_hashlist *hlist)
+static bool hbucket_invariant(const struct m0_ht_descr *d,
+			      const struct m0_hbucket  *bucket,
+			      const struct m0_htable   *htable)
 {
+	uint64_t  index;
+	void     *amb;
+	uint64_t  key;
+
+	index = bucket - htable->h_buckets;
+
 	return
-		m0_hashlist_bob_check(hlist) &&
-		hlist->hl_bucket_nr >  0 &&
-		hlist->hl_hash_func != NULL &&
-		hlist->hl_buckets   != NULL &&
-		hlist->hl_tldescr   != NULL;
+		bucket != NULL &&
+		d != NULL &&
+		d->hd_tldescr != NULL &&
+		m0_hbucket_forall_ol (d->hd_tldescr, amb, bucket,
+			 ((void)(key = key_get(d, amb)), true) &&
+			 (index == d->hd_hash_func(htable, &key)));
 }
 
-M0_INTERNAL int m0_hashlist_init(struct m0_hashlist       *hlist,
-				 uint64_t (*hfunc)
-				 (const struct m0_hashlist *hlist,
-				  uint64_t                  key),
-				 uint64_t                  bucket_nr,
-				 size_t                    key_offset,
-				 const struct m0_tl_descr *descr)
+static bool htable_invariant(const struct m0_ht_descr *d,
+			     const struct m0_htable   *htable)
 {
-	M0_PRE(hlist != NULL);
-	M0_PRE(hfunc != NULL);
+	return
+		m0_htable_bob_check(htable) &&
+		htable->h_bucket_nr >  0 &&
+		htable->h_buckets   != NULL &&
+		m0_forall(i, htable->h_bucket_nr, hbucket_invariant(d,
+			  &htable->h_buckets[i], htable));
+}
+
+M0_INTERNAL int m0_htable_init(const struct m0_ht_descr *d,
+			       struct m0_htable         *htable,
+			       uint64_t                  bucket_nr)
+{
+	uint64_t nr;
+
+	M0_PRE(htable != NULL);
+	M0_PRE(d != NULL);
 	M0_PRE(bucket_nr > 0);
-	M0_PRE(descr != NULL);
-
-	m0_hashlist_bob_init(hlist);
-
-	/*
-	 * Number of buckets is determined based on minimum of
-	 * - number of objects to be stored.
-	 * - max number of buckets that can fit into M0_0VEC_ALIGN (4K)
-	 *   segment.
-	 * This helps in keeping buckets localized in one page while operating
-	 * in linux kernel.
-	 */
-	hlist->hl_key_offset = key_offset;
-	hlist->hl_hash_func  = hfunc;
-	hlist->hl_tldescr    = descr;
-	hlist->hl_bucket_nr  = min64u(bucket_nr, M0_0VEC_ALIGN /
-				      sizeof(struct m0_hashbucket *));
-	M0_ALLOC_ARR(hlist->hl_buckets, hlist->hl_bucket_nr);
-	if (hlist->hl_buckets == NULL)
+
+	m0_htable_bob_init(htable);
+
+	htable->h_bucket_nr  = bucket_nr;
+	M0_ALLOC_ARR(htable->h_buckets, htable->h_bucket_nr);
+	if (htable->h_buckets == NULL)
 		return -ENOMEM;
 
-	M0_POST(hashlist_invariant(hlist));
+	for (nr = 0; nr < htable->h_bucket_nr; ++nr)
+		m0_hbucket_init(d, &htable->h_buckets[nr]);
+	M0_POST_EX(htable_invariant(d, htable));
 	return 0;
 }
 
-M0_INTERNAL int m0_hashlist_add(struct m0_hashlist *hlist, void *obj)
+M0_INTERNAL void m0_htable_add(const struct m0_ht_descr *d,
+			       struct m0_htable         *htable,
+			       void                     *amb)
 {
-	int      rc;
+	uint64_t key;
 	uint64_t bucket_id;
 
-	M0_PRE(hashlist_invariant(hlist));
-	M0_PRE(obj != NULL);
+	M0_PRE_EX(htable_invariant(d, htable));
+	M0_PRE(amb != NULL);
 
-	bucket_id = hlist->hl_hash_func(hlist, hashlist_key_get(hlist, obj));
+	key = key_get(d, amb);
+	bucket_id = d->hd_hash_func(htable, &key);
 
-	/*
-	 * Allocates and initializes the bucket if it is not
-	 * initialized already.
-	 */
-	if (hlist->hl_buckets[bucket_id] == NULL) {
-		rc = m0_hashbucket_alloc_init(hlist, bucket_id);
-		if (rc != 0)
-			return rc;
-	}
-	m0_tlist_add(hlist->hl_tldescr,
-		     &hlist->hl_buckets[bucket_id]->hb_objects, obj);
-	M0_POST(hashlist_invariant(hlist));
-	M0_POST(m0_tlink_is_in(hlist->hl_tldescr, obj));
-
-	return 0;
+	m0_tlist_add(d->hd_tldescr,
+		     &htable->h_buckets[bucket_id].hb_objects, amb);
+	M0_POST_EX(htable_invariant(d, htable));
+	M0_POST(m0_tlink_is_in(d->hd_tldescr, amb));
 }
 
-M0_INTERNAL void m0_hashlist_del(struct m0_hashlist *hlist, void *obj)
+M0_INTERNAL void m0_htable_del(const struct m0_ht_descr *d,
+			       struct m0_htable         *htable,
+			       void                     *amb)
 {
+	uint64_t key;
 	uint64_t bucket_id;
 
-	M0_PRE(hashlist_invariant(hlist));
-	M0_PRE(obj != NULL);
+	M0_PRE_EX(htable_invariant(d, htable));
+	M0_PRE(amb != NULL);
 
-	bucket_id = hlist->hl_hash_func(hlist, hashlist_key_get(hlist, obj));
+	key = key_get(d, amb);
+	bucket_id = d->hd_hash_func(htable, &key);
 
-	if (hlist->hl_buckets[bucket_id] == NULL)
-		return;
-	m0_tlist_del(hlist->hl_tldescr, obj);
+	m0_tlist_del(d->hd_tldescr, amb);
 
-	/* Finalizes and deallocates the bucket if it is empty. */
-	if (m0_tlist_is_empty(hlist->hl_tldescr,
-			      &hlist->hl_buckets[bucket_id]->hb_objects))
-		m0_hashbucket_dealloc_fini(hlist->hl_buckets[bucket_id]);
-
-	M0_POST(hashlist_invariant(hlist));
-	M0_POST(!m0_tlink_is_in(hlist->hl_tldescr, obj));
+	M0_POST_EX(htable_invariant(d, htable));
+	M0_POST(!m0_tlink_is_in(d->hd_tldescr, amb));
 }
 
-M0_INTERNAL void *m0_hashlist_lookup(const struct m0_hashlist *hlist,
-				     uint64_t                  key)
+M0_INTERNAL void *m0_htable_lookup(const struct m0_ht_descr *d,
+				   const struct m0_htable   *htable,
+				   void                     *key)
 {
-	void                 *scan;
-	uint64_t              bucket_id;
-	struct m0_hashbucket *bucket;
+	void     *scan;
+	uint64_t  k;
+	uint64_t  bucket_id;
 
-	M0_PRE(hashlist_invariant(hlist));
+	M0_PRE_EX(htable_invariant(d, htable));
 
-	bucket_id = hlist->hl_hash_func(hlist, key);
-	bucket    = hlist->hl_buckets[bucket_id];
-	if (bucket == NULL)
-		return NULL;
+	bucket_id = d->hd_hash_func(htable, key);
 
-	m0_tlist_for (hlist->hl_tldescr, &bucket->hb_objects, scan) {
-		if (hashlist_key_get(hlist, scan) == key)
+	m0_tlist_for (d->hd_tldescr, &htable->h_buckets[bucket_id].hb_objects,
+		      scan) {
+		k = key_get(d, scan);
+		if (m0_htable_key_eq(d, &k, key))
 			break;
 	} m0_tlist_endfor;
 
 	return scan;
 }
 
-M0_INTERNAL void m0_hashlist_fini(struct m0_hashlist *hlist)
+M0_INTERNAL void m0_htable_fini(const struct m0_ht_descr *d,
+				struct m0_htable         *htable)
 {
-	uint64_t              nr;
-	struct m0_hashbucket *bucket;
+	uint64_t nr;
 
-	M0_PRE(hashlist_invariant(hlist));
+	M0_PRE_EX(htable_invariant(d, htable));
 
-	for (nr = 0; nr < hlist->hl_bucket_nr; ++nr) {
-		bucket = hlist->hl_buckets[nr];
-		if (bucket != NULL)
-			m0_hashbucket_dealloc_fini(bucket);
-	}
-	m0_free(hlist->hl_buckets);
-	m0_hashlist_bob_fini(hlist);
-	hlist->hl_buckets   = NULL;
-	hlist->hl_bucket_nr = 0;
-	hlist->hl_tldescr   = NULL;
-	hlist->hl_hash_func = NULL;
+	for (nr = 0; nr < htable->h_bucket_nr; ++nr)
+		m0_hbucket_fini(d, &htable->h_buckets[nr]);
+	m0_free(htable->h_buckets);
+	m0_htable_bob_fini(htable);
+	htable->h_buckets   = NULL;
+	htable->h_bucket_nr = 0;
 }
 
-M0_INTERNAL bool m0_hashlist_is_empty(const struct m0_hashlist *hlist)
+M0_INTERNAL bool m0_htable_is_empty(const struct m0_ht_descr *d,
+				    const struct m0_htable   *htable)
 {
 	uint64_t nr;
 
-	M0_PRE(hashlist_invariant(hlist));
+	M0_PRE_EX(htable_invariant(d, htable));
 
-	for (nr = 0; nr < hlist->hl_bucket_nr; ++nr) {
-		if (hlist->hl_buckets[nr] != NULL &&
-		    !m0_tlist_is_empty(hlist->hl_tldescr,
-			    &hlist->hl_buckets[nr]->hb_objects))
+	for (nr = 0; nr < htable->h_bucket_nr; ++nr) {
+		if (!m0_tlist_is_empty(d->hd_tldescr,
+				&htable->h_buckets[nr].hb_objects))
 			break;
 	}
-	return nr == hlist->hl_bucket_nr;
+	return nr == htable->h_bucket_nr;
 }
 
-M0_INTERNAL uint64_t m0_hashlist_length(const struct m0_hashlist *hlist)
+M0_INTERNAL uint64_t m0_htable_length(const struct m0_ht_descr *d,
+				      const struct m0_htable   *htable)
 {
 	uint64_t nr;
 	uint64_t len = 0;
 
-	M0_PRE(hashlist_invariant(hlist));
+	M0_PRE_EX(htable_invariant(d, htable));
 
-	for (nr = 0; nr < hlist->hl_bucket_nr; ++nr) {
-		if (hlist->hl_buckets[nr] != NULL)
-			len += m0_tlist_length(hlist->hl_tldescr,
-					&hlist->hl_buckets[nr]->hb_objects);
+	for (nr = 0; nr < htable->h_bucket_nr; ++nr) {
+		len += m0_tlist_length(d->hd_tldescr,
+				&htable->h_buckets[nr].hb_objects);
 	}
 	return len;
 }
diff --git a/lib/hash.h b/lib/hash.h
index f6b08f6..f83d7c5 100644
--- a/lib/hash.h
+++ b/lib/hash.h
@@ -14,7 +14,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Anand Vidwana <anand_vidwansa@xyratex.com>
+ * Original author: Anand Vidwansa <anand_vidwansa@xyratex.com>
  * Original creation date: 05/21/2013
  */
 
@@ -27,29 +27,43 @@
 #include "lib/tlist.h"
 
 /**
- * @defgroup hash Hashed lists.
+ * @defgroup hash Hash table.
  *
- * Hashed list module provides a simple hash implementation built over
+ * Hash table module provides a simple hash implementation built over
  * top of typed lists. @see tlist.
  *
  * Often, lookup for objects stored in simple tlists prove to be expensive
  * owing to lack of any efficient arrangement of objects in tlist.
- * Hash list provides a simple way to distribute objects in hash using a
+ * Hash table provides a simple way to distribute objects in hash using a
  * key-value mechanism, which enhances lookup time of objects.
  *
- * Hash list contains array of hash buckets which contain bucket id
- * and a tlist of objects.
+ * Hash table contains array of hash buckets which contain a simple tlist
+ * of ambient objects.
  * Every object is supposed to provide a key, based on which its location
- * in hash list is decided. The caller is supposed to provide a hash function
+ * in hash table is decided. The caller is supposed to provide a hash function
  * which is used to calculate bucket id in which object will lie.
  *
- * Similar to tlists, hash list is a simple algorithmic module. It does not
+ * Hash keys and ambient objects are generic (kept as void *) in hash code
+ * so as to support any type of keys and objects.
+ * However, since hash code tries to retrieve hash key in generic functions
+ * like m0_htable_add(), m0_htable_lookup() &c, there is a restriction on
+ * types of keys that can be used with hash table.
+ *
+ * A known set of key types are supported by hash table. And the code expects
+ * key type to be from this set. @see m0_ht_key_type.
+ * Since type of key can be variable, key retrieval and key equal functions
+ * are supposed to be provided by user. @see m0_ht_descr.
+ *
+ * Users are encouraged to use the type-safe interfaces defined over hash
+ * table using macros like M0_HT_DEFINE().
+ *
+ * Similar to tlists, hash table is a simple algorithmic module. It does not
  * deal with liveness or concurrency and other such issues. Caller is supposed
  * to control liveness and use proper synchronization primitives to handle
  * concurrency.
  *
  * A good hash function can ensure good distribution of objects
- * throughout the hash list, thus owing to efficient operation of hash.
+ * throughout the hash table, thus owing to efficient operation of hash.
  *
  * Consider a scenario with struct bar containing multiple objects of
  * struct foo.
@@ -58,8 +72,8 @@
  *
  * struct bar {
  *         ...
- *         // Hash list used to store multiple foo-s.
- *         struct m0_hashlist b_foohash;
+ *         // Hash table used to store multiple foo-s.
+ *         struct m0_htable b_foohash;
  *         ...
  * };
  *
@@ -67,7 +81,7 @@
  *         // Magic to validate sanity of object.
  *         uint64_t        f_magic;
  *
- *         // Key used to find out appropriate bucket.
+ *         // A uint64_t Key used to find out appropriate bucket.
  *         uint64_t        f_hash_key;
  *
  *         ...
@@ -75,98 +89,107 @@
  *         struct m0_tlink f_link;
  * };
  *
- * - Now, define the tlist descriptor.
+ * - Define a hash function which will take care of distributing objects
+ *   throughtout the hash buckets and the key retrieval and key equal
+ *   functions.
  *
- *   M0_TL_DESCR_DEFINE(foohash, "Hash of foo-s", static, struct foo,
- *                      f_link, f_magic, magix, M0_LIB_HASHBUCKET_MAGIC);
+ *   uint64_t hash_func(const struct m0_htable *htable, void *key)
+ *   {
+ *           uint64_t *k = (uint64_t *)key;
+ *           return (*k) % bucket_nr;
+ *   }
  *
- * - Define a hash function which will take care of distributing objects
- *   throughtout the hash buckets.
+ *   void *hash_key_get(const struct m0_ht_descr *d, void *amb))
+ *   {
+ *           struct foo *f = (struct foo *)amb;
+ *           return &(f->f_hash_key);
+ *   }
  *
- *   uint64_t hash_func(uint64_t key)
+ *   void *hash_key_eq(void *key1, void *key2)
  *   {
- *           return key % bucket_nr;
+ *           uint64_t *k1 = (uint64_t *)key1;
+ *           uint64_t *k2 = (uint64_t *)key2;
+ *           return (*k1) == (*k2);
  *   }
  *
- * - Now initialize the m0_hashlist like
+ * - Now define hash descriptor like this.
+ *
+ *   M0_HT_DESCR_DEFINE(foohash, "Hash of foo structures", static, struct foo,
+ *                      f_link, FOO_MAGIC, BAR_MAGIC, uint64_t, f_hkey,
+ *                      hash_func, hash_key_get, hash_key_eq);
+ *
+ *   This will take care of defining tlist descriptor internally.
+ *
+ *   Similarly,
+ *
+ *   M0_HT_DEFINE(foohash, static, struct foo, uint64_t);
+ *
+ *   this will take care of defining tlist APIs internally.
+ *
+ * - Now initialize the m0_htable like
  *
- *   m0_hashlist_init(&bar->b_foohash, hash_func, bucket_nr,
- *                    offsetof(struct foo, f_key, &foohash_tl);
+ *   m0_htable_init(&bar->b_foohash, hash_func, bucket_nr,
+ *                     offsetof(struct foo, f_key, &foohash_tl);
  *
  * Now, foo objects can be added/removed to/from bar::b_foohash using
- * APIs like m0_hashlist_add() and m0_hashlist_del().
+ * APIs like m0_htable_add() and m0_htable_del().
  *
- * Also, lookup through hash can be done using API like m0_hashlist_lookup().
+ * Also, lookup through hash can be done using API like m0_htable_lookup().
  *
  * @endcode
  *
- * Macros like m0_hashbucket_forall() and m0_hashlist_forall() can be used
- * to evaluate a certain expression for all objects in hashbucket/hashlist.
+ * Macros like m0_hbucket_forall() and m0_htable_forall() can be used
+ * to evaluate a certain expression for all objects in hashbucket/hashtable.
  *
- * m0_hashlist_for() and m0_hashlist_endfor() can be used to have a loop
- * over all objects in hashlist.
+ * m0_htable_for() and m0_htable_endfor() can be used to have a loop
+ * over all objects in hashtable.
  *
  * @{
  */
 
+struct m0_htable;
+struct m0_hbucket;
+struct m0_ht_descr;
+
 /**
  * Represents a simple hash bucket.
  */
-struct m0_hashbucket {
-	/**
-	 * Bucket id. It is calculated by supplying key (provided by user)
-	 * to m0_hashlist::hl_hash_func().
-	 * Typically for struct m0_hashlist, m0_fid::f_key is used as hash key.
-	 * During initialization, this key is set to an invalid value.
-	 * As and when elements are added to hash, this key is updated.
-	 */
-	uint64_t            hb_bucket_id;
-
+struct m0_hbucket {
 	/**
-	 * List of target_ioreq objects which share
-	 * target_ioreq::ti_fid::f_key.
+	 * List of objects which lie in same hash bucket.
 	 * A single m0_tl_descr object would be used by all
-	 * m0_hashbucket::hb_objects lists in a single m0_hash object.
+	 * m0_hbucket::hb_objects lists in a single m0_hash object.
 	 */
 	struct m0_tl        hb_objects;
-
-	/** Backlink to parent m0_hashlist structure. */
-	struct m0_hashlist *hb_hlist;
 };
 
 /**
- * Allocates and initializes m0_hashbucket structure.
- * @pre   hlist != NULL && hlist->hl_buckets != NULL &&
- *        hlist->hl_buckets[bucket_id] == NULL.
- * @post  hlist->hl_buckets[bucket_id] != NULL.
+ * Allocates and initializes m0_hbucket structure.
+ * @pre hbucket != NULL && d != NULL.
  */
-M0_INTERNAL int hashbucket_alloc_init(struct m0_hashlist *hlist,
-				      uint64_t            bucket_id);
+M0_INTERNAL void m0_hbucket_init(const struct m0_ht_descr *d,
+				 struct m0_hbucket        *hbucket);
 
 /**
- * Finalizes and deallocates a m0_hashbucket structure.
+ * Finalizes and deallocates a m0_hbucket structure.
  * @pre bucket != NULL.
  */
-M0_INTERNAL void hashbucket_dealloc_fini(struct m0_hashbucket *bucket);
-
-struct m0_hashlist;
+M0_INTERNAL void m0_hbucket_fini(const struct m0_ht_descr *d,
+				 struct m0_hbucket        *bucket);
 
 /**
  * A simple hash data structure which helps to avoid the linear search
  * of whole list of objects.
  * However considering that linux kernel can not guarantee more than one
  * contiguous pages during memory allocation, the upper threshold of
- * number of buckets is limited by page_size / sizeof(m0_hashbucket *).
+ * number of buckets is limited by page_size / sizeof(m0_hbucket *).
  */
-struct m0_hashlist {
+struct m0_htable {
 	/** Magic value. Holds M0_LIB_HASHLIST_MAGIC.  */
-	uint64_t                   hl_magic;
+	uint64_t                  h_magic;
 
 	/** Number of hash buckets used. */
-	uint64_t                   hl_bucket_nr;
-
-	/** Offset of key field in ambient structure. */
-	size_t                     hl_key_offset;
+	uint64_t                  h_bucket_nr;
 
 	/**
 	 * Array of hash buckets. Hash buckets are supposed to be
@@ -174,129 +197,327 @@ struct m0_hashlist {
 	 * Ergo, the very first bucket will have bucket id 0, the next one
 	 * will have bucket id 1 and so on.
 	 */
-	struct m0_hashbucket     **hl_buckets;
+	struct m0_hbucket        *h_buckets;
+};
+
+/**
+ * Possible permissible types for keys used in hash tables.
+ * Such a table has to be used since type of key has to be found
+ * out in generic code (m0_htable_add, m0_htable_del, m0_htable_lookup).
+ * Since key is supposed to be void *, the actual type of key can be
+ * found out only by using typeof() macro, where name of key_field
+ * is needed, along with ambient type.
+ * But all ambient objects and keys are used as void * in generic code,
+ * hence typeof() macro can not yield results.
+ */
+enum m0_ht_key_type {
+	M0_HT_KEY_U8  = 1,
+	M0_HT_KEY_U16 = 2,
+	M0_HT_KEY_U32 = 4,
+	M0_HT_KEY_U64 = 8,
+	M0_HT_KEY_NR,
+};
+
+/**
+ * Hash table descriptor. An instance of this type must be defined per
+ * struct m0_htable.
+ * It keeps track of tlist descriptor, offset to key field and hash function.
+ */
+struct m0_ht_descr {
+	/** Human readable name. */
+	const char               *hd_name;
 
-	/** tlist descriptor used for m0_hashbucket::hb_objects tlist. */
-	const struct m0_tl_descr  *hl_tldescr;
+	/** tlist descriptor used for m0_hbucket::hb_objects tlist. */
+	const struct m0_tl_descr *hd_tldescr;
 
 	/** Hash function. Has to be provided by user. */
-	uint64_t (*hl_hash_func)  (const struct m0_hashlist *hlist,
-			           uint64_t               key);
+	uint64_t (*hd_hash_func) (const struct m0_htable *htable,
+			          void                   *key);
+
+	void *(*hd_key)          (const struct m0_ht_descr *d,
+				  void                     *amb);
+	/**
+	 * Key comparison routine. Since hash component supports
+	 * custom made keys, the comparison routine has to be
+	 * provided by user.
+	 */
+	bool (*hd_key_eq)        (void *key1, void *key2);
+
+	/** Type of key in ambient structure. */
+	enum m0_ht_key_type      hd_key_type;
 };
 
+M0_INTERNAL void *m0_htable_key(const struct m0_ht_descr *d,
+				void                     *amb);
+
+M0_INTERNAL bool m0_htable_key_eq(const struct m0_ht_descr *d,
+				  void                     *key1,
+				  void                     *key2);
+
 /**
- * Initializes a hashlist.
- * @param bucket_nr Number of buckets that will be housed in this m0_hashlist.
+ * Initializes a hashtable.
+ * @param bucket_nr Number of buckets that will be housed in this m0_htable.
  *        Max number of buckets has upper threshold of 512 buckets.
  * @param key_offset Offset of key field in ambient object.
  *        This key is used in operations like add, del, lookup &c.
  * @param hfunc Hash function used to calculate bucket id.
- * @param descr tlist descriptor used for tlist in hash buckets.
- * @pre   hlist != NULL &&
- *        hfunc != NULL &&
+ * @param d tlist descriptor used for tlist in hash buckets.
+ * @pre   htable != NULL &&
+ *        hfunc  != NULL &&
  *        bucket_nr > 0    &&
- *        descr != NULL.
- * @post hlist->hl_magic == M0_LIB_HASHLIST_MAGIC &&
- *       hlist->hl_bucket_nr > 0 &&
- *       hlist->hl_hash_func == hfunc &&
- *       hlist->hl_tldescr == descr.
+ *        d != NULL.
+ * @post htable->h_magic == M0_LIB_HASHLIST_MAGIC &&
+ *       htable->h_bucket_nr > 0 &&
+ *       htable->h_hash_func == hfunc &&
+ *       htable->h_tldescr == d.
  */
-M0_INTERNAL int m0_hashlist_init(struct m0_hashlist *hlist,
-				 uint64_t (*hfunc)
-				 (const struct m0_hashlist *hlist,
-				  uint64_t                  key),
-				 uint64_t                   bucket_nr,
-				 size_t                     key_offset,
-				 const struct m0_tl_descr  *descr);
+M0_INTERNAL int m0_htable_init(const struct m0_ht_descr *d,
+			       struct m0_htable         *htable,
+			       uint64_t                  bucket_nr);
 
 /**
- * Finalizes a struct m0_hashlist.
- * @pre  hlist != NULL &&
- *       hlist->hl_magic == M0_LIB_HASHLIST_MAGIC &&
- *       hlist->hl_buckets != NULL.
- * @post hlist->buckets == NULL &&
- *       hlist->bucket_nr == 0.
+ * Finalizes a struct m0_htable.
+ * @pre  htable != NULL &&
+ *       htable->h_magic == M0_LIB_HASHLIST_MAGIC &&
+ *       htable->h_buckets != NULL.
+ * @post htable->buckets == NULL &&
+ *       htable->bucket_nr == 0.
  */
-M0_INTERNAL void m0_hashlist_fini(struct m0_hashlist *hlist);
+M0_INTERNAL void m0_htable_fini(const struct m0_ht_descr *d,
+				struct m0_htable         *htable);
 
 /**
- * Adds an object to hash list.
+ * Adds an object to hash table.
  * The key must be set in object at specified location in order to
  * identify the bucket.
- * @pre  hlist != NULL &&
- *       obj   != NULL &&
- *       hlist->hl_buckets != NULL.
+ * @pre  htable != NULL &&
+ *       amb    != NULL &&
+ *       htable->h_buckets != NULL.
  */
-M0_INTERNAL int m0_hashlist_add(struct m0_hashlist *hlist, void *obj);
+M0_INTERNAL void m0_htable_add(const struct m0_ht_descr *d,
+			       struct m0_htable         *htable,
+			       void                     *amb);
 
 /**
- * Removes an object from hash list.
+ * Removes an object from hash table.
  * The key must be set in object at specified location in order to
  * identify the bucket.
- * @pre hlist != NULL &&
- *      obj   != NULL &&
- *      hlist->hl_buckets != NULL.
+ * @pre htable != NULL &&
+ *      amb    != NULL &&
+ *      htable->h_buckets != NULL.
  */
-M0_INTERNAL void m0_hashlist_del(struct m0_hashlist *hlist, void *obj);
+M0_INTERNAL void m0_htable_del(const struct m0_ht_descr *d,
+			       struct m0_htable         *htable,
+			       void                     *amb);
 
 /**
- * Looks up if given object is present in hash list based on input key.
+ * Looks up if given object is present in hash table based on input key.
  * Returns ambient object on successful lookup, returns NULL otherwise.
- * @pre hlist != NULL &&
- *      hlist->hl_buckets != NULL.
+ * @pre htable != NULL &&
+ *      htable->h_buckets != NULL.
  */
-M0_INTERNAL void *m0_hashlist_lookup(const struct m0_hashlist *hlist,
-				     uint64_t		       key);
+M0_INTERNAL void *m0_htable_lookup(const struct m0_ht_descr *d,
+				   const struct m0_htable   *htable,
+				   void                     *key);
+
+/** Returns if m0_htable contains any objects. */
+M0_INTERNAL bool m0_htable_is_empty(const struct m0_ht_descr *d,
+				    const struct m0_htable   *htable);
 
-/** Returns if m0_hashlist contains any objects. */
-M0_INTERNAL bool m0_hashlist_is_empty(const struct m0_hashlist *hlist);
+/** Returns number of objects stored within m0_htable. */
+M0_INTERNAL uint64_t m0_htable_length(const struct m0_ht_descr *d,
+				      const struct m0_htable   *htable);
 
-/** Returns number of objects stored within m0_hashlist. */
-M0_INTERNAL uint64_t m0_hashlist_length(const struct m0_hashlist *hlist);
+#define KEY_TYPE_IS_VALID(key)	\
+	M0_HAS_TYPE((key), uint8_t)  || \
+	M0_HAS_TYPE((key), uint16_t) ||	\
+	M0_HAS_TYPE((key), uint32_t) ||	\
+	M0_HAS_TYPE((key), uint64_t)
+
+/** Defines a hashtable descriptor. */
+#define M0_HT_DESCR(name, ambient_type, key_type, key_field,		\
+		    hash_func, key_get, key_eq, tldescr)		\
+{									\
+	.hd_name       = name,						\
+	.hd_key        = key_get,					\
+	.hd_key_eq     = key_eq,					\
+	.hd_tldescr    = tldescr,					\
+	.hd_hash_func  = hash_func,					\
+	.hd_key_type   = (enum m0_ht_key_type)sizeof(key_type)		\
+};									\
+									\
+M0_BASSERT(M0_HAS_TYPE(M0_FIELD_VALUE(ambient_type, key_field),		\
+		       key_type));					\
+M0_BASSERT(KEY_TYPE_IS_VALID(M0_FIELD_VALUE(ambient_type, key_field)));	\
+M0_BASSERT((sizeof(uint64_t) == M0_HT_KEY_U64) &&			\
+	   (sizeof(uint32_t) == M0_HT_KEY_U32) &&			\
+	   (sizeof(uint16_t) == M0_HT_KEY_U16) &&			\
+	   (sizeof(uint8_t)  == M0_HT_KEY_U8));
+
+/** Defines a hashtable descriptor with given scope. */
+#define M0_HT_DESCR_DEFINE(name, htname, scope, amb_type,		\
+			   amb_link_field, amb_magic_field,		\
+			   amb_magic, head_magic, key_type,		\
+			   key_field, hash_func, key_get, key_eq)	\
+M0_TL_DESCR_DEFINE(name, htname, scope, amb_type, amb_link_field,	\
+		   amb_magic_field, amb_magic, head_magic);		\
+									\
+scope const struct m0_ht_descr name ## _ht = M0_HT_DESCR(htname,	\
+							 amb_type,	\
+							 key_type,	\
+							 key_field,	\
+							 hash_func,	\
+							 key_get,	\
+							 key_eq,	\
+							 &name ## _tl)
+
+/** Declares a hashtable descriptr with given scope. */
+#define M0_HT_DESCR_DECLARE(name, scope)				\
+scope const struct m0_ht_descr name ## _ht
 
 /**
- * Iterates over the members of a m0_hashbucket and performs given operation
+ * Declares all functions of hash table which accepts ambient type
+ * and key type as input.
+ */
+#define M0_HT_DECLARE(name, scope, amb_type, key_type)			\
+									\
+scope int name ## _htable_init(struct m0_htable *htable,		\
+			       uint64_t bucket_nr);			\
+scope void *name ## _htable_key(const struct m0_htable *htable,		\
+				const void             *amb);		\
+scope bool name ## _htable_key_eq(key_type key1, key_type key2);	\
+scope void name ## _htable_add (struct m0_htable *htable, amb_type *amb);\
+scope void name ## _htable_del(struct m0_htable *htable, amb_type *amb);\
+scope void * name ## _htable_lookup(const struct m0_htable *htable,	\
+				    key_type               *key);	\
+scope void name ## _htable_fini(struct m0_htable *htable);		\
+scope bool name ## _htable_is_empty(const struct m0_htable *htable);	\
+scope uint64_t m0_htable_length(const struct m0_htable *htable);
+
+/**
+ * Defines all functions of hash table which accepts ambient type
+ * and key type as input.
+ */
+#define M0_HT_DEFINE(name, scope, amb_type, key_type)			\
+									\
+M0_TL_DEFINE(name, scope, amb_type);					\
+									\
+scope __AUN int name ## _htable_init(struct m0_htable *htable,		\
+				     uint64_t          bucket_nr)	\
+{									\
+	return m0_htable_init(&name ## _ht, htable, bucket_nr);		\
+}									\
+									\
+scope __AUN void *name ## _htable_key(key_type               *key,	\
+			              void                   *amb)	\
+{									\
+	return m0_htable_key(&name ## _ht, amb);			\
+}									\
+									\
+scope __AUN bool name ## _htable_key_eq(key_type key1, key_type key2)	\
+{									\
+	return m0_htable_key_eq(&name ## _ht, &key1, &key2);		\
+}									\
+									\
+scope __AUN void name ## _htable_add(struct m0_htable *htable,		\
+				    amb_type         *amb)		\
+{									\
+	m0_htable_add(&name ## _ht, htable, amb);			\
+}									\
+									\
+scope __AUN void name ## _htable_del(struct m0_htable *htable,		\
+			             amb_type         *amb)		\
+{									\
+	m0_htable_del(&name ## _ht, htable, amb);			\
+}									\
+									\
+scope __AUN void *name ## _htable_lookup(const struct m0_htable *htable,\
+					 key_type               *key)	\
+{									\
+	return m0_htable_lookup(&name ## _ht, htable, key);		\
+}									\
+									\
+scope __AUN void name ## _htable_fini(struct m0_htable *htable)		\
+{									\
+	m0_htable_fini(&name ## _ht, htable);				\
+}									\
+									\
+scope __AUN bool name ## _htable_is_empty(const struct m0_htable *htable)\
+{									\
+	return m0_htable_is_empty(&name ## _ht, htable);		\
+}									\
+									\
+scope __AUN uint64_t name ## _htable_length(const struct m0_htable *htable)\
+{									\
+	return m0_htable_length(&name ## _ht, htable);			\
+}									\
+
+/**
+ * Iterates over the members of a m0_hbucket and performs given operation
  * for all of them.
  */
-#define m0_hashbucket_forall(name, var, bucket, ...)			    \
+#define m0_hbucket_forall(name, var, bucket, ...)			    \
 ({									    \
-	m0_tl_forall(name, var, &bucket->hb_objects, ({ __VA_ARGS__ ; }));  \
+	typeof (bucket) __bucket = (bucket);				    \
+									    \
+	m0_tl_forall(name, var, &__bucket->hb_objects, ({ __VA_ARGS__ ; }));\
 })
 
 /**
- * Iterates over all hashbuckets and invokes m0_hashbucket_forall() for all
+ * Iterates over all hashbuckets and invokes m0_hbucket_forall() for all
  * buckets.
  */
-#define m0_hashlist_forall(name, var, hlist, ...)			    \
+#define m0_htable_forall(name, var, htable, ...)			    \
 ({									    \
 	uint64_t cnt;							    \
-	typeof (hlist) hl = (hlist);					    \
+	typeof (htable) ht = (htable);					    \
 									    \
-	for (cnt = 0; cnt < hl->hl_bucket_nr; ++cnt)	{		    \
-		if (hl->hl_buckets[cnt] != NULL &&			    \
-		    (!(m0_hashbucket_forall(name, var, hl->hl_buckets[cnt], \
-					 ({ __VA_ARGS__ ; })))))	    \
+	for (cnt = 0; cnt < ht->h_bucket_nr; ++cnt)	{		    \
+		if (!(m0_hbucket_forall(name, var, &ht->h_buckets[cnt],     \
+					 ({ __VA_ARGS__ ; }))))	            \
 			break;						    \
 	}								    \
-	cnt == hl->hl_bucket_nr;					    \
+	cnt == ht->h_bucket_nr;					            \
 })
 
 /**
  * An open ended version of loop over all objects in all hash buckets
- * in a m0_hashlist.
- * This loop has to be closed using hashlist_endfor() macro.
+ * in a m0_htable.
+ * This loop has to be closed using m0_htable_endfor() macro.
  */
-#define m0_hashlist_for(name, var, hlist)				    \
+#define m0_htable_for(name, var, htable)				    \
 ({									    \
 	uint64_t __cnt;							    \
-	typeof (hlist) hl = (hlist);					    \
+	typeof (htable) ht = (htable);					    \
 									    \
-	for (__cnt = 0; __cnt < hl->hl_bucket_nr; ++__cnt) {		    \
-		if (hl->hl_buckets[__cnt] != NULL) {			    \
-			m0_tl_for(name, &hl->hl_buckets[__cnt]->hb_objects, \
-				  var)
+	for (__cnt = 0; __cnt < ht->h_bucket_nr; ++__cnt) {		    \
+		m0_tl_for(name, &ht->h_buckets[__cnt].hb_objects, var)
+
+#define m0_htable_endfor m0_tl_endfor; }; })
+
+/**
+ * Open ended version of loop over all ambient objects in a given
+ * hash bucket.
+ * The loop has to be closed using m0_hbucket_endfor;
+ */
+#define m0_hbucket_for(descr, var, bucket)				    \
+({									    \
+	m0_tlist_for (descr, &bucket->hb_objects, var)
+
+#define m0_hbucket_endfor m0_tlist_endfor; })
 
-#define m0_hashlist_endfor m0_tl_endfor; } }; })
+/**
+ * A loop which uses open ended version of hash bucket.
+ * This can be used for invariant checking.
+ */
+#define m0_hbucket_forall_ol(descr, var, bucket, ...)			    \
+({									    \
+	m0_hbucket_for (descr, var, bucket) {				    \
+		if (!({ __VA_ARGS__; }))				    \
+			break;						    \
+	} m0_hbucket_endfor;						    \
+	var == NULL;							    \
+})
 
 /** @} end of hash */
 
diff --git a/lib/linux_kernel/ut/main.c b/lib/linux_kernel/ut/main.c
index fa1b3a1..9619ba5 100644
--- a/lib/linux_kernel/ut/main.c
+++ b/lib/linux_kernel/ut/main.c
@@ -47,6 +47,7 @@ M0_INTERNAL void test_memory(void);
 M0_INTERNAL void test_bob(void);
 M0_INTERNAL void m0_ut_lib_buf_test(void);
 M0_INTERNAL void m0_test_lib_uuid(void);
+M0_INTERNAL void test_hashtable(void);
 
 const struct m0_test_suite m0_klibm0_ut = {
 	.ts_name = "klibm0-ut",
@@ -77,6 +78,7 @@ const struct m0_test_suite m0_klibm0_ut = {
 		{ "uuid",          m0_test_lib_uuid   },
 		{ "vec",           test_vec           },
 		{ "zerovec",       test_zerovec       },
+		{ "hash",          test_hashtable     },
 		{ NULL,            NULL               }
 	}
 };
diff --git a/lib/ut/Kbuild.sub b/lib/ut/Kbuild.sub
index f0f0649..bd91c2a 100644
--- a/lib/ut/Kbuild.sub
+++ b/lib/ut/Kbuild.sub
@@ -4,6 +4,7 @@ m0ut_objects += lib/ut/bitmap.o \
                 lib/ut/chan.o \
                 lib/ut/cookie.o \
                 lib/ut/finject.o \
+                lib/ut/hash.o \
                 lib/ut/list.o \
                 lib/ut/locality.o \
                 lib/ut/lockers.o \
diff --git a/lib/ut/hash.c b/lib/ut/hash.c
index e3fead7..636c883 100644
--- a/lib/ut/hash.c
+++ b/lib/ut/hash.c
@@ -14,20 +14,25 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Anand Vidwana <anand_vidwansa@xyratex.com>
+ * Original author: Anand Vidwansa <anand_vidwansa@xyratex.com>
  * Original creation date: 05/28/2013
  */
 
 #include "lib/bob.h"	/* m0_bob_type */
-#include "lib/hash.h"   /* m0_hashlist */
+#include "lib/hash.h"   /* m0_htable */
 #include "lib/errno.h"  /* Include appropriate errno.h header. */
 #include "ut/ut.h"	/* M0_UT_ASSERT() */
 
+/*
+ * Once upon a time, there was a hash in a bar, which consists of
+ * number of foos!
+ * And all foos shared their keys in order to enroll into the hash.
+ */
 struct bar {
 	/* Holds BAR_MAGIC. */
 	uint64_t           b_magic;
 	int                b_rc;
-	struct m0_hashlist b_hash;
+	struct m0_htable b_hash;
 };
 
 struct foo {
@@ -45,24 +50,44 @@ enum {
 	FOO_MAGIC = 0x911ea3a7096a96e5ULL,
 };
 
-static uint64_t hash_func(const struct m0_hashlist *hlist, uint64_t key)
+static struct foo foos[FOO_NR];
+static struct bar thebar;
+
+static uint64_t hash_func(const struct m0_htable *htable, void *k)
 {
-	return key % hlist->hl_bucket_nr;
+	uint64_t *key  = (uint64_t *)k;
+
+	return (*key) % htable->h_bucket_nr;
 }
 
-M0_TL_DESCR_DEFINE(foohash, "Hash of foos", static, struct foo,
-		   f_link, f_magic, FOO_MAGIC, BAR_MAGIC);
-M0_TL_DEFINE(foohash, static, struct foo);
+static void *hash_key_get(const struct m0_ht_descr *d, void *obj)
+{
+	struct foo *amb = (struct foo *)obj;
 
-static struct foo foos[FOO_NR];
-static struct bar thebar;
+	return &(amb->f_hkey);
+}
 
-void test_hash(void)
+static bool key_eq(void *key1, void *key2)
 {
-	int                   i;
-	int                   rc;
-	struct foo           *f;
-	struct m0_hashbucket *hb;
+	uint64_t *k1 = (uint64_t *)key1;
+	uint64_t *k2 = (uint64_t *)key2;
+
+	return (*k1) == (*k2);
+}
+
+M0_HT_DESCR_DEFINE(foohash, "Hash of fops", static, struct foo, f_link,
+		   f_magic, FOO_MAGIC, BAR_MAGIC,
+		   uint64_t, f_hkey, hash_func, hash_key_get, key_eq);
+
+M0_HT_DEFINE(foohash, static, struct foo, uint64_t);
+
+void test_hashtable(void)
+{
+	int                i;
+	int                rc;
+	uint64_t           key;
+	struct foo        *f;
+	struct m0_hbucket *hb;
 
 	for (i = 0; i < FOO_NR; ++i) {
 		foos[i].f_magic = FOO_MAGIC;
@@ -73,75 +98,66 @@ void test_hash(void)
 
 	thebar.b_magic = BAR_MAGIC;
 	thebar.b_rc    = 0;
-	rc = m0_hashlist_init(&thebar.b_hash, hash_func, BUCKET_NR,
-			      offsetof(struct foo, f_hkey), &foohash_tl);
-	M0_UT_ASSERT(rc == 0);
-	M0_UT_ASSERT(thebar.b_hash.hl_magic == M0_LIB_HASHLIST_MAGIC);
-	M0_UT_ASSERT(thebar.b_hash.hl_bucket_nr == BUCKET_NR);
-	M0_UT_ASSERT(thebar.b_hash.hl_buckets != NULL);
-	M0_UT_ASSERT(thebar.b_hash.hl_hash_func == hash_func);
-
-	rc = m0_hashlist_add(&thebar.b_hash, &foos[0]);
+	rc = foohash_htable_init(&thebar.b_hash, BUCKET_NR);
 	M0_UT_ASSERT(rc == 0);
-	M0_UT_ASSERT(m0_hashlist_length(&thebar.b_hash) == 1);
-	M0_UT_ASSERT(!m0_hashlist_is_empty(&thebar.b_hash));
-	M0_UT_ASSERT(m0_hashlist_lookup(&thebar.b_hash, 0) == &foos[0]);
-	M0_UT_ASSERT(m0_hashlist_lookup(&thebar.b_hash, 1) == NULL);
+	M0_UT_ASSERT(thebar.b_hash.h_magic == M0_LIB_HASHLIST_MAGIC);
+	M0_UT_ASSERT(thebar.b_hash.h_bucket_nr == BUCKET_NR);
+	M0_UT_ASSERT(thebar.b_hash.h_buckets != NULL);
+
+	foohash_htable_add(&thebar.b_hash, &foos[0]);
+	M0_UT_ASSERT(foohash_htable_length(&thebar.b_hash) == 1);
+	M0_UT_ASSERT(!foohash_htable_is_empty(&thebar.b_hash));
+	key = 0;
+	M0_UT_ASSERT(foohash_htable_lookup(&thebar.b_hash, &key) == &foos[0]);
+	key = 1;
+	M0_UT_ASSERT(foohash_htable_lookup(&thebar.b_hash, &key) == NULL);
 
-	M0_UT_ASSERT(thebar.b_hash.hl_buckets[0] != NULL);
-	M0_UT_ASSERT(thebar.b_hash.hl_buckets[0]->hb_bucket_id == 0);
 	M0_UT_ASSERT(!m0_tlist_is_empty(&foohash_tl, &thebar.b_hash.
-				        hl_buckets[0]->hb_objects));
-	M0_UT_ASSERT(thebar.b_hash.hl_buckets[0]->hb_hlist == &thebar.b_hash);
+				        h_buckets[0].hb_objects));
 
-	m0_hashlist_del(&thebar.b_hash, &foos[0]);
-	M0_UT_ASSERT(m0_hashlist_is_empty(&thebar.b_hash));
-	M0_UT_ASSERT(m0_hashlist_length(&thebar.b_hash) == 0);
-	M0_UT_ASSERT(m0_hashlist_lookup(&thebar.b_hash, foos[0].f_hkey) == NULL);
-	M0_UT_ASSERT(thebar.b_hash.hl_buckets[0] == NULL);
+	foohash_htable_del(&thebar.b_hash, &foos[0]);
+	M0_UT_ASSERT(foohash_htable_is_empty(&thebar.b_hash));
+	M0_UT_ASSERT(foohash_htable_length(&thebar.b_hash) == 0);
+	M0_UT_ASSERT(foohash_htable_lookup(&thebar.b_hash, &foos[0].f_hkey) ==
+		     NULL);
 
 	for (i = 0; i < FOO_NR; ++i) {
-		rc = m0_hashlist_add(&thebar.b_hash, &foos[i]);
-		M0_UT_ASSERT(rc == 0);
+		foohash_htable_add(&thebar.b_hash, &foos[i]);
 		M0_UT_ASSERT(m0_tlink_is_in(&foohash_tl, &foos[i]));
 	}
-	M0_UT_ASSERT(m0_hashlist_length(&thebar.b_hash) == FOO_NR);
+	M0_UT_ASSERT(foohash_htable_length(&thebar.b_hash) == FOO_NR);
 
 	for (i = 0; i < BUCKET_NR; ++i) {
-		hb = thebar.b_hash.hl_buckets[i];
-		M0_UT_ASSERT(hb != NULL);
-		M0_UT_ASSERT(hb->hb_bucket_id == i);
+		hb = &thebar.b_hash.h_buckets[i];
 		M0_UT_ASSERT(!m0_tlist_is_empty(&foohash_tl, &hb->hb_objects));
-		M0_UT_ASSERT(m0_hashbucket_forall(foohash, f, hb,
-			     f->f_hkey % BUCKET_NR == hb->hb_bucket_id));
+		M0_UT_ASSERT(m0_hbucket_forall(foohash, f, hb,
+			     f->f_hkey % BUCKET_NR == i));
 	}
-	M0_UT_ASSERT(m0_hashlist_forall(foohash, f, &thebar.b_hash,
+	M0_UT_ASSERT(m0_htable_forall(foohash, f, &thebar.b_hash,
 		     f->f_subject == 0));
 
-	m0_hashlist_for(foohash, f, &thebar.b_hash) {
+	m0_htable_for(foohash, f, &thebar.b_hash) {
 		f->f_subject = 1;
-	} m0_hashlist_endfor;
+	} m0_htable_endfor;
 
-	M0_UT_ASSERT(m0_hashlist_forall(foohash, f, &thebar.b_hash,
+	M0_UT_ASSERT(m0_htable_forall(foohash, f, &thebar.b_hash,
 		     f->f_subject == 1));
 
 	for (i = 0; i < FOO_NR; ++i) {
-		m0_hashlist_del(&thebar.b_hash, &foos[i]);
-		M0_UT_ASSERT(m0_hashlist_length(&thebar.b_hash) ==
+		foohash_htable_del(&thebar.b_hash, &foos[i]);
+		M0_UT_ASSERT(foohash_htable_length(&thebar.b_hash) ==
 			     FOO_NR - (i + 1));
-		M0_UT_ASSERT(m0_hashlist_lookup(&thebar.b_hash,
-					foos[i].f_hkey) == NULL);
+		M0_UT_ASSERT(foohash_htable_lookup(&thebar.b_hash,
+					&foos[i].f_hkey) == NULL);
 		M0_UT_ASSERT(!m0_tlink_is_in(&foohash_tl, &foos[i]));
 	}
-	M0_UT_ASSERT(m0_hashlist_length(&thebar.b_hash) == 0);
-	M0_UT_ASSERT(m0_hashlist_is_empty(&thebar.b_hash));
-
-	m0_hashlist_fini(&thebar.b_hash);
-	M0_UT_ASSERT(thebar.b_hash.hl_buckets   == NULL);
-	M0_UT_ASSERT(thebar.b_hash.hl_bucket_nr == 0);
-	M0_UT_ASSERT(thebar.b_hash.hl_magic     == 0);
-	M0_UT_ASSERT(thebar.b_hash.hl_tldescr   == NULL);
-	M0_UT_ASSERT(thebar.b_hash.hl_hash_func == NULL);
+	M0_UT_ASSERT(foohash_htable_length(&thebar.b_hash) == 0);
+	M0_UT_ASSERT(foohash_htable_is_empty(&thebar.b_hash));
+
+	foohash_htable_fini(&thebar.b_hash);
+	M0_UT_ASSERT(thebar.b_hash.h_buckets   == NULL);
+	M0_UT_ASSERT(thebar.b_hash.h_bucket_nr == 0);
+	M0_UT_ASSERT(thebar.b_hash.h_magic     == 0);
 }
 
 /*
diff --git a/lib/ut/main.c b/lib/ut/main.c
index a3caff7..e5defa9 100644
--- a/lib/ut/main.c
+++ b/lib/ut/main.c
@@ -48,7 +48,7 @@ extern void test_trace(void);
 extern void test_vec(void);
 extern void test_zerovec(void);
 extern void test_locality(void);
-extern void test_hash(void);
+extern void test_hashtable(void);
 
 const struct m0_test_suite libm0_ut = {
 	.ts_name = "libm0-ut",
@@ -84,7 +84,7 @@ const struct m0_test_suite libm0_ut = {
 		{ "uuid",             m0_test_lib_uuid   },
 		{ "vec",              test_vec           },
 		{ "zerovec",          test_zerovec       },
-		{ "hash",	      test_hash          },
+		{ "hash",	      test_hashtable     },
 		{ NULL,               NULL               }
 	}
 };
diff --git a/m0t1fs/linux_kernel/file.c b/m0t1fs/linux_kernel/file.c
index 79cf2c5..7ff34b6 100644
--- a/m0t1fs/linux_kernel/file.c
+++ b/m0t1fs/linux_kernel/file.c
@@ -480,11 +480,36 @@ static inline uint64_t target_offset(uint64_t		       frame,
 	       (gob_offset % layout_unit_size(play));
 }
 
-M0_TL_DESCR_DEFINE(tioreq_hash, "Hash of target_ioreq objects", static,
-		   struct target_ioreq, ti_link, ti_magic, M0_T1FS_TIOREQ_MAGIC,
-		   M0_LIB_HASHBUCKET_MAGIC);
+static uint64_t tioreqs_hash_func(const struct m0_htable *htable, void *k)
+{
+	uint64_t *key = (uint64_t *)k;
+
+	return (*key) % htable->h_bucket_nr;
+}
+
+static void *tioreq_key_get(const struct m0_ht_descr *d,
+			    void                     *amb)
+{
+	struct target_ioreq *ti = (struct target_ioreq *)amb;
 
-M0_TL_DEFINE(tioreq_hash, static, struct target_ioreq);
+	return (uint64_t *)(&ti->ti_fid.f_container);
+}
+
+static bool tioreq_key_eq(void *key1, void *key2)
+{
+	uint64_t *k1 = (uint64_t *)key1;
+	uint64_t *k2 = (uint64_t *)key2;
+
+	return (*k1) == (*k2);
+}
+
+M0_HT_DESCR_DEFINE(tioreqht, "Hash of target_ioreq objects", static,
+		   struct target_ioreq, ti_link, ti_magic,
+		   M0_T1FS_TIOREQ_MAGIC, M0_T1FS_TLIST_HEAD_MAGIC,
+		   uint64_t, ti_fid.f_container, tioreqs_hash_func,
+		   tioreq_key_get, tioreq_key_eq);
+
+M0_HT_DEFINE(tioreqht, static, struct target_ioreq, uint64_t);
 
 /* Finds out pargrp_iomap::pi_grpid from target index. */
 static inline uint64_t pargrp_id_find(m0_bindex_t index,
@@ -900,10 +925,12 @@ static bool io_request_invariant(const struct io_request *req)
 	       m0_fid_is_valid(file_to_fid(req->ir_file)) &&
 
 	       ergo(ioreq_sm_state(req) == IRS_READING,
-		    !m0_hashlist_is_empty(&req->ir_nwxfer.nxr_tioreqs_hash)) &&
+		    !tioreqht_htable_is_empty(&req->ir_nwxfer.
+			    nxr_tioreqs_hash)) &&
 
 	       ergo(ioreq_sm_state(req) == IRS_WRITING,
-		    !m0_hashlist_is_empty(&req->ir_nwxfer.nxr_tioreqs_hash)) &&
+		    !tioreqht_htable_is_empty(&req->ir_nwxfer.
+			    nxr_tioreqs_hash)) &&
 
 	       ergo(ioreq_sm_state(req) == IRS_WRITE_COMPLETE,
 		    req->ir_nwxfer.nxr_iofop_nr == 0) &&
@@ -931,13 +958,13 @@ static bool nw_xfer_request_invariant(const struct nw_xfer_request *xfer)
 		    (xfer->nxr_iofop_nr == 0)) &&
 
 	       ergo(xfer->nxr_state == NXS_INFLIGHT,
-		    !m0_hashlist_is_empty(&xfer->nxr_tioreqs_hash)) &&
+		    !tioreqht_htable_is_empty(&xfer->nxr_tioreqs_hash)) &&
 
 	       ergo(xfer->nxr_state == NXS_COMPLETE,
 		    xfer->nxr_iofop_nr == 0) &&
 
-	       m0_hashlist_forall(tioreq_hash, tioreq, &xfer->nxr_tioreqs_hash,
-			          target_ioreq_invariant(tioreq));
+	       m0_htable_forall(tioreqht, tioreq, &xfer->nxr_tioreqs_hash,
+			       target_ioreq_invariant(tioreq));
 }
 
 static bool data_buf_invariant(const struct data_buf *db)
@@ -1020,11 +1047,6 @@ static bool pargrp_iomap_invariant_nr(const struct io_request *req)
 			 pargrp_iomap_invariant(req->ir_iomaps[i]));
 }
 
-static uint64_t tioreqs_hash_func(const struct m0_hashlist *hlist, uint64_t key)
-{
-	return key % hlist->hl_bucket_nr;
-}
-
 static void nw_xfer_request_init(struct nw_xfer_request *xfer)
 {
 	struct io_request        *req;
@@ -1042,11 +1064,8 @@ static void nw_xfer_request_init(struct nw_xfer_request *xfer)
 	xfer->nxr_ops	= &xfer_ops;
 
 	play = pdlayout_get(req);
-	xfer->nxr_rc = m0_hashlist_init(&xfer->nxr_tioreqs_hash,
-			tioreqs_hash_func, layout_n(play) + 2 * layout_k(play),
-			offsetof(struct target_ioreq, ti_fid) +
-			offsetof(struct m0_fid, f_container),
-			&tioreq_hash_tl);
+	xfer->nxr_rc = tioreqht_htable_init(&xfer->nxr_tioreqs_hash,
+				layout_n(play) + 2 * layout_k(play));
 
 	M0_POST_EX(nw_xfer_request_invariant(xfer));
 	M0_LEAVE();
@@ -1060,7 +1079,7 @@ static void nw_xfer_request_fini(struct nw_xfer_request *xfer)
 
 	xfer->nxr_ops = NULL;
 	nw_xfer_request_bob_fini(xfer);
-	m0_hashlist_fini(&xfer->nxr_tioreqs_hash);
+	tioreqht_htable_fini(&xfer->nxr_tioreqs_hash);
 	M0_LEAVE();
 }
 
@@ -2860,13 +2879,13 @@ static int nw_xfer_io_distribute(struct nw_xfer_request *xfer)
 
 	M0_RETURN(0);
 err:
-	m0_hashlist_for(tioreq_hash, ti, &xfer->nxr_tioreqs_hash) {
-		m0_hashlist_del(&xfer->nxr_tioreqs_hash, ti);
+	m0_htable_for(tioreqht, ti, &xfer->nxr_tioreqs_hash) {
+		tioreqht_htable_del(&xfer->nxr_tioreqs_hash, ti);
 		target_ioreq_fini(ti);
 		m0_free(ti);
 		++iommstats.d_target_ioreq_nr;
 		ti = NULL;
-	} m0_hashlist_endfor;
+	} m0_htable_endfor;
 
 	M0_RETERR(rc, "io_prepare failed");
 }
@@ -2927,7 +2946,7 @@ static int device_check(struct io_request *req)
 					   IRS_WRITE_COMPLETE)));
 	csb = file_to_sb(req->ir_file);
 
-	m0_hashlist_for (tioreq_hash, ti, &req->ir_nwxfer.nxr_tioreqs_hash) {
+	m0_htable_for (tioreqht, ti, &req->ir_nwxfer.nxr_tioreqs_hash) {
 		rc = m0_poolmach_device_state(csb->csb_pool.po_mach,
 				              ti->ti_fid.f_container, &state);
 		if (rc != 0)
@@ -2937,7 +2956,7 @@ static int device_check(struct io_request *req)
 		if (M0_IN(state, (M0_PNDS_FAILED, M0_PNDS_OFFLINE,
 			          M0_PNDS_SNS_REPAIRING)))
 			st_cnt++;
-	} m0_hashlist_endfor;
+	} m0_htable_endfor;
 
 	/*
 	 * Since m0t1fs IO only supports XOR at the moment, max number of
@@ -3021,12 +3040,11 @@ static int ioreq_dgmode_write(struct io_request *req, bool rmw)
 		 * Fops meant for failed devices are dropped in
 		 * nw_xfer_req_dispatch().
 		 */
-		m0_hashlist_for(tioreq_hash, ti,
-			     &req->ir_nwxfer.nxr_tioreqs_hash) {
+		m0_htable_for(tioreqht, ti, &req->ir_nwxfer.nxr_tioreqs_hash) {
 			ti->ti_databytes = 0;
 			ti->ti_parbytes  = 0;
 			ti->ti_rc        = 0;
-		} m0_hashlist_endfor;
+		} m0_htable_endfor;
 
 	} else {
 		/*
@@ -3118,7 +3136,7 @@ static int ioreq_dgmode_read(struct io_request *req, bool rmw)
 			if (rc != 0)
 				break;
 		} m0_tl_endfor;
-	} m0_hashlist_endfor;
+	} m0_htable_endfor;
 
 	if (rc != 0)
 		M0_RETERR(rc, "dgmode failed");
@@ -3146,19 +3164,19 @@ static int ioreq_dgmode_read(struct io_request *req, bool rmw)
 		 * Ergo, page counts in index and buffer vectors are reset.
 		 */
 
-		m0_hashlist_for(tioreq_hash, ti,
+		m0_htable_for(tioreqht, ti,
 			     &req->ir_nwxfer.nxr_tioreqs_hash) {
 			ti->ti_ivec.iv_vec.v_nr = 0;
-		} m0_hashlist_endfor;
+		} m0_htable_endfor;
 	}
 
 	req->ir_nwxfer.nxr_ops->nxo_complete(&req->ir_nwxfer, rmw);
 
-	m0_hashlist_for(tioreq_hash, ti, &req->ir_nwxfer.nxr_tioreqs_hash) {
+	m0_htable_for(tioreqht, ti, &req->ir_nwxfer.nxr_tioreqs_hash) {
 		ti->ti_databytes = 0;
 		ti->ti_parbytes  = 0;
 		ti->ti_rc        = 0;
-	} m0_hashlist_endfor;
+	} m0_htable_endfor;
 
 	/* Resets the status code before starting degraded mode read IO. */
 	if (req->ir_nwxfer.nxr_rc != 0)
@@ -3320,12 +3338,11 @@ static int ioreq_iosm_handle(struct io_request *req)
 		m0_bcount_t read_pages = 0;
 
 		rmw = true;
-		m0_hashlist_for(tioreq_hash, ti,
-			     &req->ir_nwxfer.nxr_tioreqs_hash) {
+		m0_htable_for(tioreqht, ti, &req->ir_nwxfer.nxr_tioreqs_hash) {
 			for (seg = 0; seg < ti->ti_bufvec.ov_vec.v_nr; ++seg)
 				if (ti->ti_pageattrs[seg] & PA_READ)
 					++read_pages;
-		} m0_hashlist_endfor;
+		} m0_htable_endfor;
 
 		/* Read IO is issued only if byte count > 0. */
 		if (read_pages > 0) {
@@ -3501,8 +3518,8 @@ static void io_request_fini(struct io_request *req)
 	req->ir_ops    = NULL;
 	m0_indexvec_free(&req->ir_ivec);
 
-	m0_hashlist_for(tioreq_hash, ti, &req->ir_nwxfer.nxr_tioreqs_hash) {
-		m0_hashlist_del(&req->ir_nwxfer.nxr_tioreqs_hash, ti);
+	m0_htable_for(tioreqht, ti, &req->ir_nwxfer.nxr_tioreqs_hash) {
+		tioreqht_htable_del(&req->ir_nwxfer.nxr_tioreqs_hash, ti);
 		/*
 		 * All io_req_fop structures in list target_ioreq::ti_iofops
 		 * are already finalized in nw_xfer_req_complete().
@@ -3510,7 +3527,7 @@ static void io_request_fini(struct io_request *req)
 		target_ioreq_fini(ti);
 		m0_free(ti);
 		++iommstats.d_target_ioreq_nr;
-	} m0_hashlist_endfor;
+	} m0_htable_endfor;
 
 	nw_xfer_request_fini(&req->ir_nwxfer);
 	M0_LEAVE();
@@ -3716,7 +3733,7 @@ static int target_ioreq_init(struct target_ioreq    *ti,
 	ti->ti_databytes = 0;
 
 	iofops_tlist_init(&ti->ti_iofops);
-	tioreq_hash_tlink_init(ti);
+	tioreqht_tlink_init(ti);
 	target_ioreq_bob_init(ti);
 
 	rc = m0_indexvec_alloc(&ti->ti_ivec, page_nr(size),
@@ -3769,7 +3786,7 @@ static void target_ioreq_fini(struct target_ioreq *ti)
 	M0_PRE_EX(target_ioreq_invariant(ti));
 
 	target_ioreq_bob_fini(ti);
-	tioreq_hash_tlink_fini(ti);
+	tioreqht_tlink_fini(ti);
 	iofops_tlist_fini(&ti->ti_iofops);
 	ti->ti_ops     = NULL;
 	ti->ti_session = NULL;
@@ -3801,7 +3818,7 @@ static struct target_ioreq *target_ioreq_locate(struct nw_xfer_request *xfer,
 	M0_PRE_EX(nw_xfer_request_invariant(xfer));
 	M0_PRE(fid != NULL);
 
-	ti = m0_hashlist_lookup(&xfer->nxr_tioreqs_hash, fid->f_container);
+	ti = tioreqht_htable_lookup(&xfer->nxr_tioreqs_hash, &fid->f_container);
 	M0_ASSERT(ergo(ti != NULL, m0_fid_cmp(fid, &ti->ti_fid) == 0));
 
 	M0_LEAVE();
@@ -3836,7 +3853,7 @@ static int nw_xfer_tioreq_get(struct nw_xfer_request *xfer,
 
 		rc = target_ioreq_init(ti, xfer, fid, session, size);
 		if (rc == 0) {
-			m0_hashlist_add(&xfer->nxr_tioreqs_hash, ti);
+			tioreqht_htable_add(&xfer->nxr_tioreqs_hash, ti);
 			M0_LOG(M0_INFO, "New target_ioreq added for fid "
 					"%llu:%llu", fid->f_container,
 					fid->f_key);
@@ -4647,7 +4664,7 @@ static int nw_xfer_req_dispatch(struct nw_xfer_request *xfer)
 	                 &csb->csb_addb_ctx);
 	m0t1fs_fs_unlock(csb);
 
-	m0_hashlist_for(tioreq_hash, ti, &xfer->nxr_tioreqs_hash) {
+	m0_htable_for(tioreqht, ti, &xfer->nxr_tioreqs_hash) {
 		if (ti->ti_state != M0_PNDS_ONLINE) {
 			M0_LOG(M0_INFO, "Skipped iofops prepare for fid"
 			       "%llu:%llu", ti->ti_fid.f_container,
@@ -4662,9 +4679,9 @@ static int nw_xfer_req_dispatch(struct nw_xfer_request *xfer)
 		rc = ti->ti_ops->tio_iofops_prepare(ti, PA_PARITY);
 		if (rc != 0)
 			M0_RETERR(rc, "parity fop failed");
-	} m0_hashlist_endfor;
+	} m0_htable_endfor;
 
-	m0_hashlist_for(tioreq_hash, ti, &xfer->nxr_tioreqs_hash) {
+	m0_htable_for(tioreqht, ti, &xfer->nxr_tioreqs_hash) {
 
 		/* Skips the target device if it is not online. */
 		if (ti->ti_state != M0_PNDS_ONLINE) {
@@ -4684,7 +4701,7 @@ static int nw_xfer_req_dispatch(struct nw_xfer_request *xfer)
 						csb_pending_io_nr);
 		} m0_tl_endfor;
 
-	} m0_hashlist_endfor;
+	} m0_htable_endfor;
 
 out:
 	xfer->nxr_state = NXS_INFLIGHT;
@@ -4703,7 +4720,7 @@ static void nw_xfer_req_complete(struct nw_xfer_request *xfer, bool rmw)
 	xfer->nxr_state = NXS_COMPLETE;
 	req = bob_of(xfer, struct io_request, ir_nwxfer, &ioreq_bobtype);
 
-	m0_hashlist_for(tioreq_hash, ti, &xfer->nxr_tioreqs_hash) {
+	m0_htable_for(tioreqht, ti, &xfer->nxr_tioreqs_hash) {
 		struct io_req_fop *irfop;
 
 		/* Maintains only the first error encountered. */
@@ -4728,7 +4745,7 @@ static void nw_xfer_req_complete(struct nw_xfer_request *xfer, bool rmw)
 			     ti->ti_fid.f_container, ti->ti_fid.f_key,
 			     ti->ti_databytes + ti->ti_parbytes,
 			     m0_time_sub(m0_time_now(), ti->ti_start_time));
-	} m0_hashlist_endfor;
+	} m0_htable_endfor;
 
 	M0_LOG(M0_INFO, "Number of bytes %s = %llu",
 	       ioreq_sm_state(req) == IRS_READ_COMPLETE ? "read" : "written",
diff --git a/m0t1fs/linux_kernel/file_internal.h b/m0t1fs/linux_kernel/file_internal.h
index c727d4e..7396e4b 100644
--- a/m0t1fs/linux_kernel/file_internal.h
+++ b/m0t1fs/linux_kernel/file_internal.h
@@ -1198,7 +1198,7 @@ struct nw_xfer_request {
 	 * of target_ioreq objects based on a key
 	 * (target_ioreq::ti_fid::f_container)
 	 */
-	struct m0_hashlist        nxr_tioreqs_hash;
+	struct m0_htable        nxr_tioreqs_hash;
 
         /**
          * Number of IO fops issued by all target_ioreq structures
diff --git a/m0t1fs/linux_kernel/ut/file.c b/m0t1fs/linux_kernel/ut/file.c
index b16c90b..439433f 100644
--- a/m0t1fs/linux_kernel/ut/file.c
+++ b/m0t1fs/linux_kernel/ut/file.c
@@ -348,7 +348,7 @@ static void ds_test(void)
 	ioreq_sm_state_set(&req, IRS_REQ_COMPLETE);
 	req.ir_nwxfer.nxr_state = NXS_COMPLETE;
 	req.ir_nwxfer.nxr_bytes = 1;
-	M0_UT_ASSERT(m0_hashlist_is_empty(&req.ir_nwxfer.nxr_tioreqs_hash));
+	M0_UT_ASSERT(tioreqht_htable_is_empty(&req.ir_nwxfer.nxr_tioreqs_hash));
 	io_request_fini(&req);
 	M0_UT_ASSERT(req.ir_file   == NULL);
 	M0_UT_ASSERT(req.ir_iovec  == NULL);
@@ -637,7 +637,8 @@ static void nw_xfer_ops_test(void)
 	/* Test for nw_xfer_tioreq_map. */
 	rc = nw_xfer_tioreq_map(&req.ir_nwxfer, &src, &tgt, &ti);
 	M0_UT_ASSERT(rc == 0);
-	M0_UT_ASSERT(!m0_hashlist_is_empty(&req.ir_nwxfer.nxr_tioreqs_hash));
+	M0_UT_ASSERT(!tioreqht_htable_is_empty(&req.ir_nwxfer.
+				nxr_tioreqs_hash));
 	M0_UT_ASSERT(ti->ti_ivec.iv_index != NULL);
 	M0_UT_ASSERT(ti->ti_ivec.iv_vec.v_count != NULL);
 	M0_UT_ASSERT(ti->ti_bufvec.ov_vec.v_count != NULL);
@@ -647,9 +648,9 @@ static void nw_xfer_ops_test(void)
 	/* Test for nw_xfer_io_distribute. */
 	rc = nw_xfer_io_distribute(&req.ir_nwxfer);
 	M0_UT_ASSERT(rc == 0);
-	M0_UT_ASSERT(m0_hashlist_length(&req.ir_nwxfer.nxr_tioreqs_hash) ==
+	M0_UT_ASSERT(tioreqht_htable_length(&req.ir_nwxfer.nxr_tioreqs_hash) ==
 			LAY_P);
-	m0_hashlist_for(tioreq_hash, ti, &req.ir_nwxfer.nxr_tioreqs_hash) {
+	m0_htable_for(tioreqht, ti, &req.ir_nwxfer.nxr_tioreqs_hash) {
 		M0_UT_ASSERT(ti->ti_nwxfer == &req.ir_nwxfer);
 		M0_UT_ASSERT(ti->ti_ops != NULL);
 
@@ -659,11 +660,11 @@ static void nw_xfer_ops_test(void)
 			M0_UT_ASSERT(ti->ti_ivec.iv_vec.v_count[cnt] ==
 				     PAGE_CACHE_SIZE);
 		}
-	} m0_hashlist_endfor;
+	} m0_htable_endfor;
 
-	m0_hashlist_for(tioreq_hash, ti1, &req.ir_nwxfer.nxr_tioreqs_hash) {
-		m0_hashlist_del(&req.ir_nwxfer.nxr_tioreqs_hash, ti1);
-	} m0_hashlist_endfor;
+	m0_htable_for(tioreqht, ti1, &req.ir_nwxfer.nxr_tioreqs_hash) {
+		tioreqht_htable_del(&req.ir_nwxfer.nxr_tioreqs_hash, ti1);
+	} m0_htable_endfor;
 
 	ioreq_iomaps_destroy(&req);
 	req.ir_sm.sm_state      = IRS_REQ_COMPLETE;
@@ -851,6 +852,7 @@ static void dgmode_readio_test(void)
 	uint32_t                    row;
 	uint32_t                    col;
 	uint64_t                    pgcur = 0;
+	uint64_t                    key;
 	struct iovec                iovec_arr[DGMODE_IOVEC_NR];
 	struct m0_fop              *reply;
 	struct io_request          *req;
@@ -899,7 +901,8 @@ static void dgmode_readio_test(void)
 
 	ioreq_sm_state_set(req, IRS_LOCK_ACQUIRED);
 	ioreq_sm_state_set(req, IRS_READING);
-	ti = m0_hashlist_lookup(&req->ir_nwxfer.nxr_tioreqs_hash, 1);
+	key = 1;
+	ti = tioreqht_htable_lookup(&req->ir_nwxfer.nxr_tioreqs_hash, &key);
 
 	/*
 	 * Fake data structure members so that UT passes through
diff --git a/mero/magic.h b/mero/magic.h
index bdc763e..030f4d8 100644
--- a/mero/magic.h
+++ b/mero/magic.h
@@ -187,6 +187,9 @@ enum m0_magic_satchel {
 	/* m0t1fs_services_tl::td_head_magic (seize sicilia) */
 	M0_T1FS_SERVICE_HEAD_MAGIC =0x335e12e51c111a77,
 
+	/* hashbucket::hb_tioreqs::td_head_magic = desirability */
+	M0_T1FS_TLIST_HEAD_MAGIC = 0x33de512ab1111777,
+
 /* Configuration */
 	/* m0_conf_cache::ca_registry::t_magic (fabled feodal) */
 	M0_CONF_CACHE_MAGIC = 0x33fab1edfe0da177,
@@ -741,9 +744,6 @@ enum m0_magic_satchel {
 	/* hashlist::hl_magic = invincibilis */
 	M0_LIB_HASHLIST_MAGIC = 0x3319519c1b111577,
 
-	/* hashbucket::hb_tioreqs::td_head_magic = desirability */
-	M0_LIB_HASHBUCKET_MAGIC = 0x33de512ab1111777,
-
 };
 
 #endif /* __MERO_MERO_MAGIC_H__ */
-- 
1.8.3.2

