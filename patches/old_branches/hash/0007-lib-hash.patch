From dade500e11aaaa349cbb424b3768f9e5767c7870 Mon Sep 17 00:00:00 2001
From: "anand.vidwansa" <anand_vidwansa@xyratex.com>
Date: Wed, 17 Jul 2013 23:48:46 -0700
Subject: [PATCH 07/10] lib:hash - Added support for generic key type. -
 Updated documentation. - Aligned UT with new interfaces. - Removed deprecated
 code.

---
 lib/hash.c                          | 156 +++++++++----------------
 lib/hash.h                          | 224 +++++++++++-------------------------
 lib/ut/hash.c                       |  25 ++--
 m0t1fs/linux_kernel/file.c          |  24 ++--
 m0t1fs/linux_kernel/file_internal.h |   4 +-
 5 files changed, 145 insertions(+), 288 deletions(-)

diff --git a/lib/hash.c b/lib/hash.c
index 1198e7f..39419aa 100644
--- a/lib/hash.c
+++ b/lib/hash.c
@@ -40,94 +40,57 @@ static const struct m0_bob_type htable_bobtype = {
 	.bt_check        = NULL,
 };
 
-static bool htable_invariant(const struct m0_ht_descr *d,
-			     const struct m0_htable   *htable);
+static bool htable_invariant(const struct m0_htable *htable);
 
-M0_INTERNAL void m0_hbucket_init(const struct m0_ht_descr *d,
-				 struct m0_hbucket        *bucket)
+static void hbucket_init(const struct m0_ht_descr *d,
+			 struct m0_hbucket        *bucket)
 {
 	M0_PRE(bucket != NULL);
 	M0_PRE(d != NULL);
-	M0_PRE(d->hd_tldescr != NULL);
 
 	m0_tlist_init(d->hd_tldescr, &bucket->hb_objects);
 }
 
-M0_INTERNAL void m0_hbucket_fini(const struct m0_ht_descr *d,
-				 struct m0_hbucket        *bucket)
+static void hbucket_fini(const struct m0_ht_descr *d,
+			 struct m0_hbucket        *bucket)
 {
 	M0_PRE(bucket != NULL);
 	M0_PRE(d != NULL);
-	M0_PRE(d->hd_tldescr != NULL);
 
 	m0_tlist_fini(d->hd_tldescr, &bucket->hb_objects);
 }
 
-M0_INTERNAL void *m0_htable_key(const struct m0_ht_descr *d,
-				void                     *amb)
+static void *obj_key(const struct m0_ht_descr *hd, void *obj)
 {
-	return d->hd_key(d, amb);
+	return obj + hd->hd_key_offset;
 }
 
-M0_INTERNAL bool m0_htable_key_eq(const struct m0_ht_descr *d,
-				  void                     *key1,
-				  void                     *key2)
-{
-	return d->hd_key_eq(key1, key2);
-}
-
-static inline uint64_t key_get(const struct m0_ht_descr *d,
-			       void                     *amb)
-{
-	uint64_t key = 0;
-
-	switch (d->hd_key_type) {
-	case M0_HT_KEY_U8 :
-		key = *(uint8_t *)m0_htable_key(d, amb);
-		break;
-	case M0_HT_KEY_U16:
-		key = *(uint16_t *)m0_htable_key(d, amb);
-		break;
-	case M0_HT_KEY_U32:
-		key = *(uint32_t *)m0_htable_key(d, amb);
-		break;
-	case M0_HT_KEY_U64:
-		key = *(uint64_t *)m0_htable_key(d, amb);
-		break;
-	default:
-		M0_IMPOSSIBLE("Invalid key type");
-	}
-	return key;
-}
-
-static bool hbucket_invariant(const struct m0_ht_descr *d,
+static bool hbucket_invariant(const struct m0_ht_descr *desc,
 			      const struct m0_hbucket  *bucket,
 			      const struct m0_htable   *htable)
 {
 	uint64_t  index;
 	void     *amb;
-	uint64_t  key;
 
 	index = bucket - htable->h_buckets;
 
 	return
 		bucket != NULL &&
-		d != NULL &&
-		d->hd_tldescr != NULL &&
-		m0_hbucket_forall_ol (d->hd_tldescr, amb, bucket,
-			 ((void)(key = key_get(d, amb)), true) &&
-			 (index == d->hd_hash_func(htable, &key)));
+		desc != NULL &&
+		m0_hbucket_forall_ol(desc->hd_tldescr, amb, bucket,
+			 	     index == desc->hd_hash_func(htable,
+				     obj_key(desc, amb)));
 }
 
-static bool htable_invariant(const struct m0_ht_descr *d,
-			     const struct m0_htable   *htable)
+static bool htable_invariant(const struct m0_htable *htable)
 {
 	return
 		m0_htable_bob_check(htable) &&
 		htable->h_bucket_nr >  0 &&
 		htable->h_buckets   != NULL &&
-		m0_forall(i, htable->h_bucket_nr, hbucket_invariant(d,
-			  &htable->h_buckets[i], htable));
+		m0_forall(i, htable->h_bucket_nr,
+			  hbucket_invariant(htable->h_descr,
+				  &htable->h_buckets[i], htable));
 }
 
 M0_INTERNAL int m0_htable_init(const struct m0_ht_descr *d,
@@ -142,119 +105,112 @@ M0_INTERNAL int m0_htable_init(const struct m0_ht_descr *d,
 
 	m0_htable_bob_init(htable);
 
-	htable->h_bucket_nr  = bucket_nr;
+	htable->h_descr     = d;
+	htable->h_bucket_nr = bucket_nr;
 	M0_ALLOC_ARR(htable->h_buckets, htable->h_bucket_nr);
 	if (htable->h_buckets == NULL)
 		return -ENOMEM;
 
 	for (nr = 0; nr < htable->h_bucket_nr; ++nr)
-		m0_hbucket_init(d, &htable->h_buckets[nr]);
-	M0_POST_EX(htable_invariant(d, htable));
+		hbucket_init(d, &htable->h_buckets[nr]);
+	M0_POST_EX(htable_invariant(htable));
 	return 0;
 }
 
-M0_INTERNAL void m0_htable_add(const struct m0_ht_descr *d,
-			       struct m0_htable         *htable,
-			       void                     *amb)
+M0_INTERNAL void m0_htable_add(struct m0_htable *htable,
+			       void             *amb)
 {
-	uint64_t key;
 	uint64_t bucket_id;
 
-	M0_PRE_EX(htable_invariant(d, htable));
+	M0_PRE_EX(htable_invariant(htable));
 	M0_PRE(amb != NULL);
+	M0_PRE(!m0_tlink_is_in(htable->h_descr->hd_tldescr, amb));
 
-	key = key_get(d, amb);
-	bucket_id = d->hd_hash_func(htable, &key);
+	bucket_id = htable->h_descr->hd_hash_func(htable,
+			obj_key(htable->h_descr, amb));
 
-	m0_tlist_add(d->hd_tldescr,
+	m0_tlist_add(htable->h_descr->hd_tldescr,
 		     &htable->h_buckets[bucket_id].hb_objects, amb);
-	M0_POST_EX(htable_invariant(d, htable));
-	M0_POST(m0_tlink_is_in(d->hd_tldescr, amb));
+	M0_POST_EX(htable_invariant(htable));
+	M0_POST(m0_tlink_is_in(htable->h_descr->hd_tldescr, amb));
 }
 
-M0_INTERNAL void m0_htable_del(const struct m0_ht_descr *d,
-			       struct m0_htable         *htable,
-			       void                     *amb)
+M0_INTERNAL void m0_htable_del(struct m0_htable *htable,
+			       void             *amb)
 {
-	uint64_t key;
 	uint64_t bucket_id;
 
-	M0_PRE_EX(htable_invariant(d, htable));
+	M0_PRE_EX(htable_invariant(htable));
 	M0_PRE(amb != NULL);
 
-	key = key_get(d, amb);
-	bucket_id = d->hd_hash_func(htable, &key);
+	bucket_id = htable->h_descr->hd_hash_func(htable,
+			obj_key(htable->h_descr, amb));
 
-	m0_tlist_del(d->hd_tldescr, amb);
+	m0_tlist_del(htable->h_descr->hd_tldescr, amb);
 
-	M0_POST_EX(htable_invariant(d, htable));
-	M0_POST(!m0_tlink_is_in(d->hd_tldescr, amb));
+	M0_POST_EX(htable_invariant(htable));
+	M0_POST(!m0_tlink_is_in(htable->h_descr->hd_tldescr, amb));
 }
 
-M0_INTERNAL void *m0_htable_lookup(const struct m0_ht_descr *d,
-				   const struct m0_htable   *htable,
-				   void                     *key)
+M0_INTERNAL void *m0_htable_lookup(const struct m0_htable *htable,
+				   const void             *key)
 {
 	void     *scan;
-	uint64_t  k;
 	uint64_t  bucket_id;
 
-	M0_PRE_EX(htable_invariant(d, htable));
+	M0_PRE_EX(htable_invariant(htable));
 
-	bucket_id = d->hd_hash_func(htable, key);
+	bucket_id = htable->h_descr->hd_hash_func(htable, key);
 
-	m0_tlist_for (d->hd_tldescr, &htable->h_buckets[bucket_id].hb_objects,
-		      scan) {
-		k = key_get(d, scan);
-		if (m0_htable_key_eq(d, &k, key))
+	m0_tlist_for(htable->h_descr->hd_tldescr,
+		     &htable->h_buckets[bucket_id].hb_objects, scan) {
+		if (htable->h_descr->hd_key_eq(obj_key(htable->h_descr, scan),
+					       key))
 			break;
 	} m0_tlist_endfor;
 
 	return scan;
 }
 
-M0_INTERNAL void m0_htable_fini(const struct m0_ht_descr *d,
-				struct m0_htable         *htable)
+M0_INTERNAL void m0_htable_fini(struct m0_htable *htable)
 {
 	uint64_t nr;
 
-	M0_PRE_EX(htable_invariant(d, htable));
+	M0_PRE_EX(htable_invariant(htable));
 
 	for (nr = 0; nr < htable->h_bucket_nr; ++nr)
-		m0_hbucket_fini(d, &htable->h_buckets[nr]);
+		hbucket_fini(htable->h_descr, &htable->h_buckets[nr]);
 	m0_free(htable->h_buckets);
 	m0_htable_bob_fini(htable);
 	htable->h_buckets   = NULL;
 	htable->h_bucket_nr = 0;
+	htable->h_descr     = NULL;
 }
 
-M0_INTERNAL bool m0_htable_is_empty(const struct m0_ht_descr *d,
-				    const struct m0_htable   *htable)
+M0_INTERNAL bool m0_htable_is_empty(const struct m0_htable *htable)
 {
 	uint64_t nr;
 
-	M0_PRE_EX(htable_invariant(d, htable));
+	M0_PRE_EX(htable_invariant(htable));
 
 	for (nr = 0; nr < htable->h_bucket_nr; ++nr) {
-		if (!m0_tlist_is_empty(d->hd_tldescr,
+		if (!m0_tlist_is_empty(htable->h_descr->hd_tldescr,
 				&htable->h_buckets[nr].hb_objects))
 			break;
 	}
 	return nr == htable->h_bucket_nr;
 }
 
-M0_INTERNAL uint64_t m0_htable_length(const struct m0_ht_descr *d,
-				      const struct m0_htable   *htable)
+M0_INTERNAL uint64_t m0_htable_length(const struct m0_htable *htable)
 {
 	uint64_t nr;
 	uint64_t len = 0;
 
-	M0_PRE_EX(htable_invariant(d, htable));
+	M0_PRE_EX(htable_invariant(htable));
 
-	for (nr = 0; nr < htable->h_bucket_nr; ++nr) {
-		len += m0_tlist_length(d->hd_tldescr,
+	for (nr = 0; nr < htable->h_bucket_nr; ++nr)
+		len += m0_tlist_length(htable->h_descr->hd_tldescr,
 				&htable->h_buckets[nr].hb_objects);
-	}
 	return len;
 }
 
diff --git a/lib/hash.h b/lib/hash.h
index 835ca40..019530d 100644
--- a/lib/hash.h
+++ b/lib/hash.h
@@ -45,22 +45,14 @@
  *
  * Hash keys and ambient objects are generic (kept as void *) in hash code
  * so as to support any type of keys and objects.
- * However, since hash code tries to retrieve hash key in generic functions
- * like m0_htable_add(), m0_htable_lookup() &c, there is a restriction on
- * types of keys that can be used with hash table.
- *
- * A known set of key types are supported by hash table. And the code expects
- * key type to be from this set. @see m0_ht_key_type.
- * Since type of key can be variable, key retrieval and key equal functions
- * are supposed to be provided by user. @see m0_ht_descr.
  *
  * Users are encouraged to use the type-safe interfaces defined over hash
  * table using macros like M0_HT_DEFINE().
  *
  * Similar to tlists, hash table is a simple algorithmic module. It does not
- * deal with liveness or concurrency and other such issues. Caller is supposed
- * to control liveness and use proper synchronization primitives to handle
- * concurrency.
+ * deal with liveness or concurrency and other such issues.
+ * Caller is supposed to control liveness and use proper synchronization
+ * primitives to handle concurrency.
  *
  * A good hash function can ensure good distribution of objects
  * throughout the hash table, thus owing to efficient operation of hash.
@@ -85,39 +77,33 @@
  *         uint64_t        f_hash_key;
  *
  *         ...
- *         // linkage to keep foo structures as part of some list
- *         // hash table.
- *         struct m0_tlink f_link;
+ *         // hash linkage to keep foo structures as part of some list
+ *         // in hash table.
+ *         struct m0_hlink f_link;
  * };
  *
  * - Define a hash function which will take care of distributing objects
  *   throughtout the hash buckets and the key retrieval and key equal
  *   functions.
  *
- *   uint64_t hash_func(const struct m0_htable *htable, void *key)
+ *   uint64_t hash_func(const struct m0_htable *htable, const void *key)
  *   {
- *           uint64_t *k = key;
+ *           const uint64_t *k = key;
  *           return *k % htable->h_bucket_nr;
  *   }
  *
- *   void *hash_key_get(const struct m0_ht_descr *d, void *amb))
+ *   void *hash_key_eq(const void *key1, const void *key2)
  *   {
- *           struct foo *f = amb;
- *           return &(f->f_hash_key);
- *   }
- *
- *   void *hash_key_eq(void *key1, void *key2)
- *   {
- *           uint64_t *k1 = key1;
- *           uint64_t *k2 = key2;
+ *           const uint64_t *k1 = key1;
+ *           const uint64_t *k2 = key2;
  *           return *k1 == *k2;
  *   }
  *
  * - Now define hash descriptor like this.
  *
  *   M0_HT_DESCR_DEFINE(foohash, "Hash of foo structures", static, struct foo,
- *                      f_link, FOO_MAGIC, BAR_MAGIC, uint64_t, f_hash_key,
- *                      hash_func, hash_key_get, hash_key_eq);
+ *                      f_link, f_magic, FOO_MAGIC, BAR_MAGIC, uint64_t,
+ *                      f_hash_key, hash_func, hash_key_eq);
  *
  *   This will take care of defining tlist descriptor internally.
  *
@@ -162,24 +148,10 @@ struct m0_hbucket {
 	 * A single m0_tl_descr object would be used by all
 	 * m0_hbucket::hb_objects lists in a single m0_hash object.
 	 */
-	struct m0_tl        hb_objects;
+	struct m0_tl hb_objects;
 };
 
 /**
- * Allocates and initializes m0_hbucket structure.
- * @pre hbucket != NULL && d != NULL.
- */
-M0_INTERNAL void m0_hbucket_init(const struct m0_ht_descr *d,
-				 struct m0_hbucket        *hbucket);
-
-/**
- * Finalizes and deallocates a m0_hbucket structure.
- * @pre bucket != NULL.
- */
-M0_INTERNAL void m0_hbucket_fini(const struct m0_ht_descr *d,
-				 struct m0_hbucket        *bucket);
-
-/**
  * A simple hash data structure which helps to avoid the linear search
  * of whole list of objects.
  */
@@ -197,24 +169,9 @@ struct m0_htable {
 	 * will have bucket id 1 and so on.
 	 */
 	struct m0_hbucket        *h_buckets;
-};
 
-/**
- * Possible permissible types for keys used in hash tables.
- * Such a table has to be used since type of key has to be found
- * out in generic code (m0_htable_add, m0_htable_del, m0_htable_lookup).
- * Since key is supposed to be void *, the actual type of key can be
- * found out only by using typeof() macro, where name of key_field
- * is needed, along with ambient type.
- * But all ambient objects and keys are used as void * in generic code,
- * hence typeof() macro can not yield results.
- */
-enum m0_ht_key_type {
-	M0_HT_KEY_U8  = 1,
-	M0_HT_KEY_U16 = 2,
-	M0_HT_KEY_U32 = 4,
-	M0_HT_KEY_U64 = 8,
-	M0_HT_KEY_NR,
+	/** Associated hash table descriptor. */
+	const struct m0_ht_descr *h_descr;
 };
 
 /**
@@ -223,40 +180,36 @@ enum m0_ht_key_type {
  * It keeps track of tlist descriptor, offset to key field and hash function.
  */
 struct m0_ht_descr {
-	/** Human readable name. */
-	const char               *hd_name;
-
 	/** tlist descriptor used for m0_hbucket::hb_objects tlist. */
 	const struct m0_tl_descr *hd_tldescr;
 
+	/** Offset to key field in ambient object. */
+	size_t                    hd_key_offset;
+
 	/** Hash function. Has to be provided by user. */
 	uint64_t (*hd_hash_func) (const struct m0_htable *htable,
-			          void                   *key);
+			          const void             *key);
 
-	void *(*hd_key)          (const struct m0_ht_descr *d,
-				  void                     *amb);
 	/**
 	 * Key comparison routine. Since hash component supports
 	 * custom made keys, the comparison routine has to be
 	 * provided by user.
 	 */
-	bool (*hd_key_eq)        (void *key1, void *key2);
-
-	/** Type of key in ambient structure. */
-	enum m0_ht_key_type      hd_key_type;
+	bool (*hd_key_eq)        (const void *key1, const void *key2);
 };
 
-M0_INTERNAL void *m0_htable_key(const struct m0_ht_descr *d,
-				void                     *amb);
-
-M0_INTERNAL bool m0_htable_key_eq(const struct m0_ht_descr *d,
-				  void                     *key1,
-				  void                     *key2);
+/**
+ * Wrapper over m0_tlink to align with m0_htable.
+ * Every ambient object which is supposed to be a member of hash table,
+ * is supposed to have a m0_hlink member.
+ */
+struct m0_hlink {
+	struct m0_tlink hl_link;
+};
 
 /**
  * Initializes a hashtable.
  * @param bucket_nr Number of buckets that will be housed in this m0_htable.
- * @param hfunc Hash function used to calculate bucket id.
  * @param d tlist descriptor used for tlist in hash buckets.
  * @pre   htable != NULL &&
  *        bucket_nr > 0    &&
@@ -273,39 +226,33 @@ M0_INTERNAL int m0_htable_init(const struct m0_ht_descr *d,
  * Finalizes a struct m0_htable.
  * @pre  htable != NULL &&
  *       htable->h_magic == M0_LIB_HASHLIST_MAGIC &&
- *       htable->h_buckets != NULL &&
- *       d != NULL..
+ *       htable->h_buckets != NULL.
  * @post htable->buckets == NULL &&
  *       htable->bucket_nr == 0.
  */
-M0_INTERNAL void m0_htable_fini(const struct m0_ht_descr *d,
-				struct m0_htable         *htable);
+M0_INTERNAL void m0_htable_fini(struct m0_htable *htable);
 
 /**
  * Adds an object to hash table.
  * The key must be set in object at specified location in order to
  * identify the bucket.
- * @pre  d != NULL &&
- *       htable != NULL &&
- *       amb    != NULL &&
- *       htable->h_buckets != NULL.
+ * @pre htable != NULL &&
+ *      amb    != NULL &&
+ *      htable->h_buckets != NULL.
  */
-M0_INTERNAL void m0_htable_add(const struct m0_ht_descr *d,
-			       struct m0_htable         *htable,
-			       void                     *amb);
+M0_INTERNAL void m0_htable_add(struct m0_htable *htable,
+			       void             *amb);
 
 /**
  * Removes an object from hash table.
  * The key must be set in object at specified location in order to
  * identify the bucket.
- * @pre d != NULL &&
- *      htable != NULL &&
+ * @pre htable != NULL &&
  *      amb    != NULL &&
  *      htable->h_buckets != NULL.
  */
-M0_INTERNAL void m0_htable_del(const struct m0_ht_descr *d,
-			       struct m0_htable         *htable,
-			       void                     *amb);
+M0_INTERNAL void m0_htable_del(struct m0_htable *htable,
+			       void             *amb);
 
 /**
  * Looks up if given object is present in hash table based on input key.
@@ -315,60 +262,42 @@ M0_INTERNAL void m0_htable_del(const struct m0_ht_descr *d,
  *      htable != NULL &&
  *      htable->h_buckets != NULL.
  */
-M0_INTERNAL void *m0_htable_lookup(const struct m0_ht_descr *d,
-				   const struct m0_htable   *htable,
-				   void                     *key);
+M0_INTERNAL void *m0_htable_lookup(const struct m0_htable *htable,
+				   const void             *key);
 
 /** Returns if m0_htable contains any objects. */
-M0_INTERNAL bool m0_htable_is_empty(const struct m0_ht_descr *d,
-				    const struct m0_htable   *htable);
+M0_INTERNAL bool m0_htable_is_empty(const struct m0_htable *htable);
 
 /** Returns number of objects stored within m0_htable. */
-M0_INTERNAL uint64_t m0_htable_length(const struct m0_ht_descr *d,
-				      const struct m0_htable   *htable);
-
-#define KEY_TYPE_IS_VALID(key)	\
-	M0_HAS_TYPE((key), uint8_t)  || \
-	M0_HAS_TYPE((key), uint16_t) ||	\
-	M0_HAS_TYPE((key), uint32_t) ||	\
-	M0_HAS_TYPE((key), uint64_t)
+M0_INTERNAL uint64_t m0_htable_length(const struct m0_htable *htable);
 
 /** Defines a hashtable descriptor. */
-#define M0_HT_DESCR(name, ambient_type, key_type, key_field,		\
-		    hash_func, key_get, key_eq, tldescr)		\
+#define M0_HT_DESCR(name, amb_type, key_type, key_field,		\
+		    hash_func, key_eq)					\
 {									\
-	.hd_name       = name,						\
-	.hd_key        = key_get,					\
+	.hd_tldescr    = &name ## _tl,					\
 	.hd_key_eq     = key_eq,					\
-	.hd_tldescr    = tldescr,					\
 	.hd_hash_func  = hash_func,					\
-	.hd_key_type   = (enum m0_ht_key_type)sizeof(key_type)		\
+	.hd_key_offset = offsetof(amb_type, key_field),			\
 };									\
 									\
-M0_BASSERT(M0_HAS_TYPE(M0_FIELD_VALUE(ambient_type, key_field),		\
+M0_BASSERT(M0_HAS_TYPE(M0_FIELD_VALUE(amb_type, key_field),		\
 		       key_type));					\
-M0_BASSERT(KEY_TYPE_IS_VALID(M0_FIELD_VALUE(ambient_type, key_field)));	\
-M0_BASSERT((sizeof(uint64_t) == M0_HT_KEY_U64) &&			\
-	   (sizeof(uint32_t) == M0_HT_KEY_U32) &&			\
-	   (sizeof(uint16_t) == M0_HT_KEY_U16) &&			\
-	   (sizeof(uint8_t)  == M0_HT_KEY_U8));
 
 /** Defines a hashtable descriptor with given scope. */
-#define M0_HT_DESCR_DEFINE(name, htname, scope, amb_type,		\
-			   amb_link_field, amb_magic_field,		\
-			   amb_magic, head_magic, key_type,		\
-			   key_field, hash_func, key_get, key_eq)	\
-M0_TL_DESCR_DEFINE(name, htname, scope, amb_type, amb_link_field,	\
+#define M0_HT_DESCR_DEFINE(name, htname, scope, amb_type, amb_link_field,\
+			   amb_magic_field, amb_magic, head_magic,	\
+			   key_type, key_field, hash_func, key_eq)	\
+									\
+M0_TL_DESCR_DEFINE(name, htname, scope, amb_type, amb_link_field.hl_link,	\
 		   amb_magic_field, amb_magic, head_magic);		\
 									\
-scope const struct m0_ht_descr name ## _ht = M0_HT_DESCR(htname,	\
+scope const struct m0_ht_descr name ## _ht = M0_HT_DESCR(name,		\
 							 amb_type,	\
 							 key_type,	\
 							 key_field,	\
 							 hash_func,	\
-							 key_get,	\
-							 key_eq,	\
-							 &name ## _tl)
+							 key_eq)
 
 /** Declares a hashtable descriptr with given scope. */
 #define M0_HT_DESCR_DECLARE(name, scope)				\
@@ -381,14 +310,11 @@ scope const struct m0_ht_descr name ## _ht
 #define M0_HT_DECLARE(name, scope, amb_type, key_type)			\
 									\
 scope int name ## _htable_init(struct m0_htable *htable,		\
-			       uint64_t bucket_nr);			\
-scope void *name ## _htable_key(const struct m0_htable *htable,		\
-				const void             *amb);		\
-scope bool name ## _htable_key_eq(key_type key1, key_type key2);	\
-scope void name ## _htable_add (struct m0_htable *htable, amb_type *amb);\
+			       uint64_t          bucket_nr);		\
+scope void name ## _htable_add(struct m0_htable *htable, amb_type *amb);\
 scope void name ## _htable_del(struct m0_htable *htable, amb_type *amb);\
-scope void * name ## _htable_lookup(const struct m0_htable *htable,	\
-				    key_type               *key);	\
+scope amb_type *name ## _htable_lookup(const struct m0_htable *htable,	\
+				       key_type               *key);	\
 scope void name ## _htable_fini(struct m0_htable *htable);		\
 scope bool name ## _htable_is_empty(const struct m0_htable *htable);	\
 scope uint64_t m0_htable_length(const struct m0_htable *htable);
@@ -407,48 +333,37 @@ scope __AUN int name ## _htable_init(struct m0_htable *htable,		\
 	return m0_htable_init(&name ## _ht, htable, bucket_nr);		\
 }									\
 									\
-scope __AUN void *name ## _htable_key(key_type               *key,	\
-			              void                   *amb)	\
-{									\
-	return m0_htable_key(&name ## _ht, amb);			\
-}									\
-									\
-scope __AUN bool name ## _htable_key_eq(key_type key1, key_type key2)	\
-{									\
-	return m0_htable_key_eq(&name ## _ht, &key1, &key2);		\
-}									\
-									\
 scope __AUN void name ## _htable_add(struct m0_htable *htable,		\
-				    amb_type         *amb)		\
+				     amb_type         *amb)		\
 {									\
-	m0_htable_add(&name ## _ht, htable, amb);			\
+	m0_htable_add(htable, amb);					\
 }									\
 									\
 scope __AUN void name ## _htable_del(struct m0_htable *htable,		\
 			             amb_type         *amb)		\
 {									\
-	m0_htable_del(&name ## _ht, htable, amb);			\
+	m0_htable_del(htable, amb);					\
 }									\
 									\
-scope __AUN void *name ## _htable_lookup(const struct m0_htable *htable,\
-					 key_type               *key)	\
+scope __AUN amb_type *name ## _htable_lookup(const struct m0_htable *htable,\
+					     key_type               *key)\
 {									\
-	return m0_htable_lookup(&name ## _ht, htable, key);		\
+	return m0_htable_lookup(htable, key);				\
 }									\
 									\
 scope __AUN void name ## _htable_fini(struct m0_htable *htable)		\
 {									\
-	m0_htable_fini(&name ## _ht, htable);				\
+	m0_htable_fini(htable);						\
 }									\
 									\
 scope __AUN bool name ## _htable_is_empty(const struct m0_htable *htable)\
 {									\
-	return m0_htable_is_empty(&name ## _ht, htable);		\
+	return m0_htable_is_empty(htable);				\
 }									\
 									\
 scope __AUN uint64_t name ## _htable_length(const struct m0_htable *htable)\
 {									\
-	return m0_htable_length(&name ## _ht, htable);			\
+	return m0_htable_length(htable);				\
 }									\
 
 /**
@@ -511,7 +426,8 @@ scope __AUN uint64_t name ## _htable_length(const struct m0_htable *htable)\
  */
 #define m0_hbucket_forall_ol(descr, var, bucket, ...)			    \
 ({									    \
-	m0_hbucket_for (descr, var, bucket) {				    \
+	typeof(descr) d = descr;					    \
+	m0_hbucket_for (d, var, bucket) {				    \
 		if (!({ __VA_ARGS__; }))				    \
 			break;						    \
 	} m0_hbucket_endfor;						    \
diff --git a/lib/ut/hash.c b/lib/ut/hash.c
index 81144e6..5f5c4f1 100644
--- a/lib/ut/hash.c
+++ b/lib/ut/hash.c
@@ -40,7 +40,7 @@ struct foo {
 	uint64_t        f_magic;
 	uint64_t        f_hkey;
 	int             f_subject;
-	struct m0_tlink f_link;
+	struct m0_hlink f_hlink;
 };
 
 enum {
@@ -53,31 +53,24 @@ enum {
 static struct foo foos[FOO_NR];
 static struct bar thebar;
 
-static uint64_t hash_func(const struct m0_htable *htable, void *k)
+static uint64_t hash_func(const struct m0_htable *htable, const void *k)
 {
-	uint64_t *key  = k;
+	const uint64_t *key  = k;
 
 	return *key % htable->h_bucket_nr;
 }
 
-static void *hash_key_get(const struct m0_ht_descr *d, void *obj)
+static bool key_eq(const void *key1, const void *key2)
 {
-	struct foo *amb = obj;
-
-	return &(amb->f_hkey);
-}
-
-static bool key_eq(void *key1, void *key2)
-{
-	uint64_t *k1 = key1;
-	uint64_t *k2 = key2;
+	const uint64_t *k1 = key1;
+	const uint64_t *k2 = key2;
 
 	return *k1 == *k2;
 }
 
-M0_HT_DESCR_DEFINE(foohash, "Hash of fops", static, struct foo, f_link,
-		   f_magic, FOO_MAGIC, BAR_MAGIC,
-		   uint64_t, f_hkey, hash_func, hash_key_get, key_eq);
+M0_HT_DESCR_DEFINE(foohash, "Hash of fops", static, struct foo,
+		   f_hlink, f_magic, FOO_MAGIC, BAR_MAGIC,
+		   uint64_t, f_hkey, hash_func, key_eq);
 
 M0_HT_DEFINE(foohash, static, struct foo, uint64_t);
 
diff --git a/m0t1fs/linux_kernel/file.c b/m0t1fs/linux_kernel/file.c
index 7ff34b6..98ce971 100644
--- a/m0t1fs/linux_kernel/file.c
+++ b/m0t1fs/linux_kernel/file.c
@@ -480,34 +480,26 @@ static inline uint64_t target_offset(uint64_t		       frame,
 	       (gob_offset % layout_unit_size(play));
 }
 
-static uint64_t tioreqs_hash_func(const struct m0_htable *htable, void *k)
+static uint64_t tioreqs_hash_func(const struct m0_htable *htable, const void *k)
 {
-	uint64_t *key = (uint64_t *)k;
+	const uint64_t *key = (uint64_t *)k;
 
-	return (*key) % htable->h_bucket_nr;
+	return *key % htable->h_bucket_nr;
 }
 
-static void *tioreq_key_get(const struct m0_ht_descr *d,
-			    void                     *amb)
+static bool tioreq_key_eq(const void *key1, const void *key2)
 {
-	struct target_ioreq *ti = (struct target_ioreq *)amb;
+	const uint64_t *k1 = (uint64_t *)key1;
+	const uint64_t *k2 = (uint64_t *)key2;
 
-	return (uint64_t *)(&ti->ti_fid.f_container);
-}
-
-static bool tioreq_key_eq(void *key1, void *key2)
-{
-	uint64_t *k1 = (uint64_t *)key1;
-	uint64_t *k2 = (uint64_t *)key2;
-
-	return (*k1) == (*k2);
+	return *k1 == *k2;
 }
 
 M0_HT_DESCR_DEFINE(tioreqht, "Hash of target_ioreq objects", static,
 		   struct target_ioreq, ti_link, ti_magic,
 		   M0_T1FS_TIOREQ_MAGIC, M0_T1FS_TLIST_HEAD_MAGIC,
 		   uint64_t, ti_fid.f_container, tioreqs_hash_func,
-		   tioreq_key_get, tioreq_key_eq);
+		   tioreq_key_eq);
 
 M0_HT_DEFINE(tioreqht, static, struct target_ioreq, uint64_t);
 
diff --git a/m0t1fs/linux_kernel/file_internal.h b/m0t1fs/linux_kernel/file_internal.h
index 7396e4b..26ce0a0 100644
--- a/m0t1fs/linux_kernel/file_internal.h
+++ b/m0t1fs/linux_kernel/file_internal.h
@@ -1715,8 +1715,8 @@ struct target_ioreq {
         /** Resulting IO fops are sent on this rpc session. */
         struct m0_rpc_session         *ti_session;
 
-        /** Linkage to link in to nw_xfer_request::nxr_tioreqs list. */
-        struct m0_tlink                ti_link;
+        /** Linkage to link in to nw_xfer_request::nxr_tioreqs_hash table. */
+        struct m0_hlink                ti_link;
 
         /**
          * Index vector containing IO segments with cob offsets and
-- 
1.8.3.2

