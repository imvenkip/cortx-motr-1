From 98114b4be6a82e92db301515ef20a3f06da19c93 Mon Sep 17 00:00:00 2001
From: Anatoliy Bilenko <anatoliy_bilenko@xyratex.com>
Date: Sun, 30 Mar 2014 18:41:37 +0300
Subject: [PATCH 04/11] seg0: simple seg0 reload test added.

---
 be/engine.c        | 45 +-------------------------
 be/engine.h        |  3 +-
 be/ut/Makefile.sub |  2 ++
 be/ut/helper.c     | 53 ++++++++++++++++++++++++++----
 be/ut/helper.h     |  7 ++++
 be/ut/main.c       |  4 +++
 be/ut/seg0.c       | 94 ++++++++++++++++++++++++++++++++++++++++++++++++++++++
 be/ut/seg_dict.c   | 18 +++++------
 8 files changed, 166 insertions(+), 60 deletions(-)
 create mode 100644 be/ut/seg0.c

diff --git a/be/engine.c b/be/engine.c
index 58fbcff..1e85401 100644
--- a/be/engine.c
+++ b/be/engine.c
@@ -47,8 +47,6 @@ M0_TL_DESCR_DEFINE(egr, "m0_be_engine::eng_groups[]", static,
 		   M0_BE_TX_MAGIC /* XXX */, M0_BE_TX_ENGINE_MAGIC /* XXX */);
 M0_TL_DEFINE(egr, static, struct m0_be_tx_group);
 
-static void be_engine_got_log_space_cb(struct m0_be_log *log);
-
 M0_INTERNAL int
 m0_be_engine_init(struct m0_be_engine *en, struct m0_be_engine_cfg *en_cfg)
 {
@@ -425,7 +423,7 @@ M0_INTERNAL void m0_be_engine_stop(struct m0_be_engine *en)
 	M0_LEAVE();
 }
 
-static void be_engine_got_log_space_cb(struct m0_be_log *log)
+M0_INTERNAL void m0_be_engine_got_log_space_cb(struct m0_be_log *log)
 {
 	struct m0_be_engine *en =
 		container_of(log, struct m0_be_engine, eng_log);
@@ -439,47 +437,6 @@ static void be_engine_got_log_space_cb(struct m0_be_log *log)
 	be_engine_unlock(en);
 }
 
-/* ------------------------------------------------------------------
- * 0types definitions
- * ------------------------------------------------------------------ */
-
-static int ut_log0_init(const struct m0_be_domain *dom, const char *suffix,
-			const struct m0_buf *data)
-{
-	const struct m0_be_engine_cfg *en_cfg = &dom->bd_cfg.bc_engine;
-	struct m0_be_engine *en = (struct m0_be_engine*) &dom->bd_engine;
-
-	M0_ENTRY();
-
-	M0_ASSERT_INFO(en_cfg->bec_log_size >=
-		       en_cfg->bec_group_size_max.tc_reg_size,
-		       "Log size shouldn't be less than maximum group size: "
-		       "log_size = %lu, group_size_max = %lu",
-		       en_cfg->bec_log_size,
-		       en_cfg->bec_group_size_max.tc_reg_size);
-	M0_ASSERT_INFO(!en_cfg->bec_log_replay, "Recovery is not implemented");
-
-	m0_be_log_init(&en->eng_log, en_cfg->bec_log_stob,
-		       be_engine_got_log_space_cb);
-	return M0_RC(m0_be_log_create(&en->eng_log, en_cfg->bec_log_size));
-}
-
-static void ut_log0_fini(const struct m0_be_domain *dom, const char *suffix,
-			 const struct m0_buf *data)
-{
-	struct m0_be_engine *en = (struct m0_be_engine*) &dom->bd_engine;
-
-	M0_ENTRY();
-	m0_be_log_fini(&en->eng_log);
-	M0_LEAVE();
-}
-
-struct m0_be_0type m0_be_ut_log0 = {
-	.b0_name = "M0_BE_MKFS:LOG",
-	.b0_init = ut_log0_init,
-	.b0_fini = ut_log0_fini
-};
-
 /** @} end of be group */
 #undef M0_TRACE_SUBSYSTEM
 
diff --git a/be/engine.h b/be/engine.h
index 5ab2837..ad2ccad 100644
--- a/be/engine.h
+++ b/be/engine.h
@@ -109,7 +109,8 @@ M0_INTERNAL void m0_be_engine__tx_group_open(struct m0_be_engine *en,
 M0_INTERNAL void m0_be_engine__tx_group_close(struct m0_be_engine *en,
 					      struct m0_be_tx_group *gr);
 
-extern struct m0_be_0type m0_be_ut_log0;
+M0_INTERNAL void m0_be_engine_got_log_space_cb(struct m0_be_log *log);
+
 
 /** @} end of be group */
 #endif /* __MERO_BE_ENGINE_H__ */
diff --git a/be/ut/Makefile.sub b/be/ut/Makefile.sub
index 9838294..d40fb8a 100644
--- a/be/ut/Makefile.sub
+++ b/be/ut/Makefile.sub
@@ -10,7 +10,9 @@ ut_libmero_ut_la_SOURCES += be/ut/alloc.c           \
                             be/ut/log_store.c       \
                             be/ut/main.c            \
                             be/ut/seg.c             \
+                            be/ut/seg0.c            \
                             be/ut/seg_dict.c        \
+                            be/ut/fake_mkfs.c       \
                             be/ut/tx.c              \
                             be/ut/tx_group_ondisk.c \
                             be/ut/tx_regmap.c
diff --git a/be/ut/helper.c b/be/ut/helper.c
index b62bce3..18d884d 100644
--- a/be/ut/helper.c
+++ b/be/ut/helper.c
@@ -769,8 +769,44 @@ M0_INTERNAL void m0_ut_be_fom_domain_idle_wait(struct m0_reqh *reqh)
 	m0_clink_fini(&clink);
 }
 
-static int seg0_init(const struct m0_be_domain *d, const char *suffix,
-		     const struct m0_buf *data)
+/* ------------------------------------------------------------------
+ * XXX: 0types definitions, used for fake-mkfs.
+ * have to be redeclared in mkfs utility.
+ * ------------------------------------------------------------------ */
+
+static int ut_log0_init(const struct m0_be_domain *dom, const char *suffix,
+			const struct m0_buf *data)
+{
+	const struct m0_be_engine_cfg *en_cfg = &dom->bd_cfg.bc_engine;
+	struct m0_be_engine *en = (struct m0_be_engine*) &dom->bd_engine;
+
+	M0_ENTRY();
+
+	M0_ASSERT_INFO(en_cfg->bec_log_size >=
+		       en_cfg->bec_group_size_max.tc_reg_size,
+		       "Log size shouldn't be less than maximum group size: "
+		       "log_size = %lu, group_size_max = %lu",
+		       en_cfg->bec_log_size,
+		       en_cfg->bec_group_size_max.tc_reg_size);
+	M0_ASSERT_INFO(!en_cfg->bec_log_replay, "Recovery is not implemented");
+
+	m0_be_log_init(&en->eng_log, en_cfg->bec_log_stob,
+		       m0_be_engine_got_log_space_cb);
+	return M0_RC(m0_be_log_create(&en->eng_log, en_cfg->bec_log_size));
+}
+
+static void ut_log0_fini(const struct m0_be_domain *dom, const char *suffix,
+			 const struct m0_buf *data)
+{
+	struct m0_be_engine *en = (struct m0_be_engine*) &dom->bd_engine;
+
+	M0_ENTRY();
+	m0_be_log_fini(&en->eng_log);
+	M0_LEAVE();
+}
+
+static int ut_seg0_init(const struct m0_be_domain *d, const char *suffix,
+			const struct m0_buf *data)
 {
 	struct be_ut_helper_struct *h = &be_ut_helper;
 	struct m0_be_seg           *seg;
@@ -793,8 +829,8 @@ static int seg0_init(const struct m0_be_domain *d, const char *suffix,
 	return rc;
 }
 
-static void seg0_fini(const struct m0_be_domain *d, const char *suffix,
-		      const struct m0_buf *data)
+static void ut_seg0_fini(const struct m0_be_domain *d, const char *suffix,
+			 const struct m0_buf *data)
 {
 	struct m0_be_domain *dom = (struct m0_be_domain *) d;
 	struct m0_be_seg    *seg  = m0_be_domain_seg0_get(dom);
@@ -813,10 +849,15 @@ static void seg0_fini(const struct m0_be_domain *d, const char *suffix,
 
 struct m0_be_0type m0_be_ut_seg0 = {
 	.b0_name = "M0_BE_MKFS:SEG0",
-	.b0_init = seg0_init,
-	.b0_fini = seg0_fini
+	.b0_init = ut_seg0_init,
+	.b0_fini = ut_seg0_fini
 };
 
+struct m0_be_0type m0_be_ut_log0 = {
+	.b0_name = "M0_BE_MKFS:LOG",
+	.b0_init = ut_log0_init,
+	.b0_fini = ut_log0_fini
+};
 
 #undef M0_TRACE_SUBSYSTEM
 
diff --git a/be/ut/helper.h b/be/ut/helper.h
index fecb48c..9aef7dd 100644
--- a/be/ut/helper.h
+++ b/be/ut/helper.h
@@ -180,6 +180,13 @@ M0_INTERNAL int m0_be_ut__seg_dict_destroy(struct m0_be_seg   *seg,
 M0_INTERNAL void m0_ut_be_fom_domain_idle_wait(struct m0_reqh *reqh);
 
 extern struct m0_be_0type m0_be_ut_seg0;
+extern struct m0_be_0type m0_be_ut_log0;
+
+struct m0_be_0type_log_opts {
+	struct m0_stob_id lo_stob_id;
+	size_t            lo_size;
+};
+
 
 #endif /* __MERO_BE_UT_HELPER_H__ */
 
diff --git a/be/ut/main.c b/be/ut/main.c
index 7775f3d..723e9f2 100644
--- a/be/ut/main.c
+++ b/be/ut/main.c
@@ -68,6 +68,8 @@ extern void m0_be_ut_list_api(void);
 extern void m0_be_ut_btree_simple(void);
 extern void m0_be_ut_emap(void);
 extern void m0_be_ut_seg_dict(void);
+extern void m0_be_ut_fake_mkfs(void);
+extern void m0_be_ut_seg0_test(void);
 
 
 const struct m0_test_suite be_ut = {
@@ -110,6 +112,8 @@ const struct m0_test_suite be_ut = {
 		{ "list",                m0_be_ut_list_api             },
 		{ "btree",               m0_be_ut_btree_simple         },
 		{ "seg_dict",            m0_be_ut_seg_dict             },
+		{ "fake_mkfs",           m0_be_ut_fake_mkfs            },
+		{ "seg0",                m0_be_ut_seg0_test            },
 		{ "emap",                m0_be_ut_emap                 },
 		{ NULL, NULL }
 	}
diff --git a/be/ut/seg0.c b/be/ut/seg0.c
new file mode 100644
index 0000000..566968b
--- /dev/null
+++ b/be/ut/seg0.c
@@ -0,0 +1,94 @@
+/*
+ * COPYRIGHT 2013 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: Anatoliy Bilenko <Anatoliy_Bilenko@xyratex.com>
+ * Original creation date: 28-Mar-2014
+ */
+
+#define M0_TRACE_SUBSYSTEM M0_TRACE_SUBSYS_UT
+#include "lib/trace.h"
+#include "lib/types.h"		/* m0_uint128_eq */
+#include "lib/misc.h"		/* M0_BITS */
+#include "lib/memory.h"         /* M0_ALLOC_PTR, m0_free */
+#include "be/ut/helper.h"	/* m0_be_ut_backend */
+#include "be/seg.h"
+#include "be/seg0.h"
+#include "stob/stob.h"
+#include "stob/linux.h"
+#include "ut/ut.h"
+
+#include <unistd.h>
+#include <stdlib.h>
+
+void fake_mkfs(void)
+{
+	char *ut_dir;
+	int   rc;
+
+	ut_dir = get_current_dir_name();
+
+	rc = chdir("..");
+	M0_UT_ASSERT(rc == 0);
+
+	rc = system("./utils/.libs/lt-ut -t be-ut:fake_mkfs -k"
+		    " > /dev/null 2>&1");
+	M0_UT_ASSERT(rc == 0);
+
+	rc = chdir(ut_dir);
+	M0_UT_ASSERT(rc == 0);
+
+	free(ut_dir);
+}
+
+void m0_be_ut_seg0_test(void)
+{
+	struct m0_stob   *seg0_stob;
+	struct m0_be_seg  seg;
+	struct m0_stob_domain *dom;
+	struct m0_stob_id stob_id;
+	struct m0_be_allocator alloc;
+	void *p;
+	int rc;
+
+	fake_mkfs();
+
+	stob_id.si_bits = M0_UINT128(0, 43);
+
+	rc = m0_linux_stob_domain_locate("./__seg_ut_stob", &dom);
+	M0_ASSERT(rc == 0);
+	rc = m0_stob_create_helper(dom, NULL, &stob_id, &seg0_stob);
+	M0_ASSERT(rc == 0);
+
+	m0_be_seg_init(&seg, seg0_stob, NULL);
+	rc = m0_be_seg_open(&seg);
+	M0_ASSERT(rc == 0);
+
+	rc = m0_be_allocator_init(&alloc, &seg);
+	M0_ASSERT(rc == 0);
+
+	m0_be_seg_dict_init(&seg);
+
+	rc = m0_be_seg_dict_lookup(&seg, "M0_BE:LOG", &p);
+	M0_ASSERT(p != NULL && rc == 0);
+
+	rc = m0_be_seg_dict_lookup(&seg, "M0_BE:SEG0", &p);
+	M0_ASSERT(p == NULL && rc == 0);
+
+	// m0_be_ut_stob_put(seg0_stob, false);
+	m0_stob_put(seg0_stob);
+	dom->sd_ops->sdo_fini(dom);
+}
+
+#undef M0_TRACE_SUBSYSTEM
diff --git a/be/ut/seg_dict.c b/be/ut/seg_dict.c
index e633ca0..f5312d4 100644
--- a/be/ut/seg_dict.c
+++ b/be/ut/seg_dict.c
@@ -97,15 +97,15 @@ M0_INTERNAL int m0_be_ut__seg_dict_destroy(struct m0_be_seg   *seg,
 void m0_be_ut_seg_dict(void)
 {
 	struct m0_be_ut_backend ut_be;
-	M0_UNUSED struct m0_be_tx_credit  credit = {};
-	M0_UNUSED struct m0_sm_group     *grp;
-	M0_UNUSED struct m0_be_seg       *seg;
-	M0_UNUSED struct m0_be_tx         tx;
-	M0_UNUSED const char             *next_key;
-	M0_UNUSED void                   *p;
-	M0_UNUSED int                     i;
-	M0_UNUSED int                     rc;
-	M0_UNUSED struct {
+	struct m0_be_tx_credit  credit = {};
+	struct m0_sm_group     *grp;
+	struct m0_be_seg       *seg;
+	struct m0_be_tx         tx;
+	const char             *next_key;
+	void                   *p;
+	int                     i;
+	int                     rc;
+	struct {
 		const char *name;
 		void       **value;
 	} dict[] = {
-- 
1.8.3.2

