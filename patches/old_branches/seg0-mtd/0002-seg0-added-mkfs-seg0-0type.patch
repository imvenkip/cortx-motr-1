From 7d4b66717205cf6e65fda76ea067339f79c0b394 Mon Sep 17 00:00:00 2001
From: Anatoliy Bilenko <anatoliy_bilenko@xyratex.com>
Date: Thu, 27 Mar 2014 20:40:14 +0200
Subject: [PATCH 02/11] seg0: added mkfs:seg0 0type.

---
 be/engine.c      | 17 ------------
 be/engine.h      |  1 -
 be/seg0.c        |  2 +-
 be/ut/helper.c   | 81 +++++++++++++++++++++++++++++++++++++++++++++++---------
 be/ut/helper.h   |  2 ++
 be/ut/seg_dict.c | 22 ++++++++-------
 6 files changed, 83 insertions(+), 42 deletions(-)

diff --git a/be/engine.c b/be/engine.c
index dd7bfe0..58fbcff 100644
--- a/be/engine.c
+++ b/be/engine.c
@@ -480,23 +480,6 @@ struct m0_be_0type m0_be_ut_log0 = {
 	.b0_fini = ut_log0_fini
 };
 
-static int seg0_init(const struct m0_be_domain *dom, const char *suffix,
-		     const struct m0_buf *data)
-{
-	return -1;
-}
-
-static void seg0_fini(const struct m0_be_domain *dom, const char *suffix,
-		      const struct m0_buf *data)
-{
-}
-
-struct m0_be_0type m0_be_ut_seg0 = {
-	.b0_name = "M0_BE_MKFS:SEG0",
-	.b0_init = seg0_init,
-	.b0_fini = seg0_fini
-};
-
 /** @} end of be group */
 #undef M0_TRACE_SUBSYSTEM
 
diff --git a/be/engine.h b/be/engine.h
index a1afdf8..5ab2837 100644
--- a/be/engine.h
+++ b/be/engine.h
@@ -110,7 +110,6 @@ M0_INTERNAL void m0_be_engine__tx_group_close(struct m0_be_engine *en,
 					      struct m0_be_tx_group *gr);
 
 extern struct m0_be_0type m0_be_ut_log0;
-extern struct m0_be_0type m0_be_ut_seg0;
 
 /** @} end of be group */
 #endif /* __MERO_BE_ENGINE_H__ */
diff --git a/be/seg0.c b/be/seg0.c
index 8cb4ec0..6f472ac 100644
--- a/be/seg0.c
+++ b/be/seg0.c
@@ -63,7 +63,7 @@ void m0_be_0type_register(struct m0_be_domain *dom, struct m0_be_0type *zt)
 	M0_PRE(be_0type_invarinat(zt, false));
 	M0_PRE(dom_is_locked(dom));
 
-	zt_tlink_init_at(zt, &dom->bd_0type_list);
+	zt_tlink_init_at_tail(zt, &dom->bd_0type_list);
 	zt->b0_dom = dom;
 }
 
diff --git a/be/ut/helper.c b/be/ut/helper.c
index 9a78451..c1b5d59 100644
--- a/be/ut/helper.c
+++ b/be/ut/helper.c
@@ -245,6 +245,7 @@ void m0_be_ut_backend_cfg_default(struct m0_be_domain_cfg *cfg)
 			.bec_group_close_timeout = M0_TIME_ONE_MSEC,
 			.bec_group_fom_reqh = reqh,
 		},
+		.bc_seg0_size = 1ULL << 20,
 	};
 }
 
@@ -295,7 +296,7 @@ void m0_be_ut_backend_mkfs_init(struct m0_be_ut_backend *ut_be)
 {
 	(void)m0_be_domain_init(&ut_be->but_dom);
 	m0_be_0type_register(&ut_be->but_dom, &m0_be_ut_log0);
-	//m0_be_0type_register(&ut_be->but_dom, &m0_be_ut_seg0);
+	m0_be_0type_register(&ut_be->but_dom, &m0_be_ut_seg0);
 	m0_be_ut_backend_init_cfg(ut_be, NULL);
 }
 
@@ -421,6 +422,20 @@ void m0_be_ut_tx_init(struct m0_be_tx *tx, struct m0_be_ut_backend *ut_be)
 	be_ut_tx_unlock_if(grp, ut_be);
 }
 
+static int storage_prepare(const char *storage_dir, const char *obj_dir,
+			   struct m0_stob_domain **dom)
+{
+	M0_PRE(*dom == NULL);
+
+	return
+#if 0
+		system("rm -rf " storage_dir) ?:
+#endif
+		mkdir(storage_dir, 0700) ?:
+		mkdir(obj_dir, 0700)     ?:
+		m0_linux_stob_domain_locate(storage_dir, dom);
+}
+
 struct m0_stob *m0_be_ut_stob_get_by_id(uint64_t id, bool stob_create)
 {
 	struct be_ut_helper_struct *h = &be_ut_helper;
@@ -434,18 +449,9 @@ struct m0_stob *m0_be_ut_stob_get_by_id(uint64_t id, bool stob_create)
 
 	m0_mutex_lock(&h->buh_seg_lock);
 	if (h->buh_storage_ref_cnt == 0) {
-#if 0
-		rc = system("rm -rf " BE_UT_H_STORAGE_DIR);
-		M0_ASSERT(rc == 0);
-#endif
-		rc = mkdir(BE_UT_H_STORAGE_DIR, 0700);
-		// M0_ASSERT(rc == 0);
-		rc = mkdir(BE_UT_H_STORAGE_DIR "/o", 0700);
-		// M0_ASSERT(rc == 0);
-
-		M0_PRE(h->buh_stob_dom == NULL);
-		rc = m0_linux_stob_domain_locate(BE_UT_H_STORAGE_DIR,
-						 &h->buh_stob_dom);
+		rc = storage_prepare(BE_UT_H_STORAGE_DIR,
+				     BE_UT_H_STORAGE_DIR "/o",
+				     &h->buh_stob_dom);
 		M0_ASSERT(rc == 0);
 	}
 	M0_CNT_INC(h->buh_storage_ref_cnt);
@@ -736,6 +742,55 @@ M0_INTERNAL void m0_ut_be_fom_domain_idle_wait(struct m0_reqh *reqh)
 	m0_clink_fini(&clink);
 }
 
+static int seg0_init(const struct m0_be_domain *d, const char *suffix,
+		     const struct m0_buf *data)
+{
+	struct be_ut_helper_struct *h = &be_ut_helper;
+	struct m0_be_seg           *seg;
+	struct m0_be_domain        *dom = (struct m0_be_domain *) d;
+	uint64_t                    size = dom->bd_cfg.bc_seg0_size;
+	int			    rc;
+
+	M0_ALLOC_PTR(seg);
+	M0_ASSERT(seg != NULL);
+
+	m0_be_seg_init(seg, m0_be_ut_stob_get(true), dom);
+	rc = m0_be_seg_create(seg, size, be_ut_seg_allocate_addr(h, size));
+	M0_ASSERT(rc == 0);
+	rc = m0_be_seg_open(seg);
+	M0_ASSERT(rc == 0);
+
+	M0_ASSERT(seg_tlist_is_empty(&dom->bd_seg_list));
+	seg_tlist_add(&dom->bd_seg_list, seg);
+
+	return rc;
+}
+
+static void seg0_fini(const struct m0_be_domain *d, const char *suffix,
+		      const struct m0_buf *data)
+{
+	struct m0_be_domain *dom = (struct m0_be_domain *) d;
+	struct m0_be_seg    *seg  = m0_be_domain_seg0_get(dom);
+	struct m0_stob      *stob = seg->bs_stob;
+	int		     rc;
+
+	m0_be_seg_close(seg);
+	rc = m0_be_seg_destroy(seg);
+	M0_ASSERT(rc == 0);
+	seg_tlist_del(seg);
+	m0_be_seg_fini(seg);
+	m0_free(seg);
+
+	m0_be_ut_stob_put(stob, true);
+}
+
+struct m0_be_0type m0_be_ut_seg0 = {
+	.b0_name = "M0_BE_MKFS:SEG0",
+	.b0_init = seg0_init,
+	.b0_fini = seg0_fini
+};
+
+
 #undef M0_TRACE_SUBSYSTEM
 
 /*
diff --git a/be/ut/helper.h b/be/ut/helper.h
index 3570770..0639fd6 100644
--- a/be/ut/helper.h
+++ b/be/ut/helper.h
@@ -173,6 +173,8 @@ M0_INTERNAL int m0_be_ut__seg_dict_destroy(struct m0_be_seg   *seg,
  */
 M0_INTERNAL void m0_ut_be_fom_domain_idle_wait(struct m0_reqh *reqh);
 
+extern struct m0_be_0type m0_be_ut_seg0;
+
 #endif /* __MERO_BE_UT_HELPER_H__ */
 
 /*
diff --git a/be/ut/seg_dict.c b/be/ut/seg_dict.c
index 4cc67ab..027fc52 100644
--- a/be/ut/seg_dict.c
+++ b/be/ut/seg_dict.c
@@ -97,16 +97,16 @@ M0_INTERNAL int m0_be_ut__seg_dict_destroy(struct m0_be_seg   *seg,
 void m0_be_ut_seg_dict(void)
 {
 	struct m0_be_ut_backend ut_be;
-	struct m0_be_tx_credit  credit = {};
-	struct m0_be_ut_seg     ut_seg;
-	struct m0_sm_group     *grp;
-	struct m0_be_seg       *seg = &ut_seg.bus_seg;
-	struct m0_be_tx         tx;
-	const char             *next_key;
-	void                   *p;
-	int                     i;
-	int                     rc;
-	struct {
+	M0_UNUSED struct m0_be_tx_credit  credit = {};
+	M0_UNUSED struct m0_be_ut_seg     ut_seg;
+	M0_UNUSED struct m0_sm_group     *grp;
+	M0_UNUSED struct m0_be_seg       *seg = &ut_seg.bus_seg;
+	M0_UNUSED struct m0_be_tx         tx;
+	M0_UNUSED const char             *next_key;
+	M0_UNUSED void                   *p;
+	M0_UNUSED int                     i;
+	M0_UNUSED int                     rc;
+	M0_UNUSED struct {
 		const char *name;
 		void       **value;
 	} dict[] = {
@@ -127,6 +127,7 @@ void m0_be_ut_seg_dict(void)
 
 	M0_SET0(&ut_be);
 	m0_be_ut_backend_mkfs_init(&ut_be);
+#if 0
 	m0_be_ut_seg_init(&ut_seg, &ut_be, 1 << 20);
 	m0_be_ut_seg_allocator_init(&ut_seg, &ut_be);
 	m0_be_ut_tx_init(&tx, &ut_be);
@@ -201,6 +202,7 @@ void m0_be_ut_seg_dict(void)
 	rc = m0_be_ut__seg_dict_destroy(seg, grp);
 	M0_UT_ASSERT(rc == 0);
 	m0_be_ut_seg_fini(&ut_seg);
+#endif
 	m0_be_ut_backend_fini(&ut_be);
 }
 
-- 
1.8.3.2

