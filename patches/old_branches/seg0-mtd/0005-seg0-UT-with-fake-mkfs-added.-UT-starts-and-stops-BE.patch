From 94dadbcd4e0239d542637b2da4d7522066f303c3 Mon Sep 17 00:00:00 2001
From: Anatoliy Bilenko <anatoliy_bilenko@xyratex.com>
Date: Mon, 31 Mar 2014 01:22:07 +0300
Subject: [PATCH 05/11] seg0: UT with fake-mkfs added. UT starts and stops BE
 domain.

---
 be/domain.c       | 114 ++++++++++++++++++++++++++++++++++--------------------
 be/domain.h       |   1 +
 be/ut/fake_mkfs.c |  87 +++++++++++++++++++++++++++++++++++++++++
 be/ut/helper.c    |  60 ++++++++++++++++++++++++++++
 be/ut/helper.h    |   2 +
 be/ut/seg0.c      |  52 +++++++++++++++----------
 6 files changed, 255 insertions(+), 61 deletions(-)
 create mode 100644 be/ut/fake_mkfs.c

diff --git a/be/domain.c b/be/domain.c
index 7d2803a..b762775 100644
--- a/be/domain.c
+++ b/be/domain.c
@@ -21,6 +21,7 @@
 #define M0_TRACE_SUBSYSTEM M0_TRACE_SUBSYS_BE
 #include "lib/trace.h"
 #include "lib/errno.h"
+#include "lib/memory.h"
 #include "be/domain.h"
 #include "be/seg0.h"
 #include "be/seg.h"
@@ -44,57 +45,52 @@ M0_TL_DEFINE(seg, M0_INTERNAL, struct m0_be_seg);
 static void m0_be_domain__0types_fini(struct m0_be_domain *dom);
 static int m0_be_domain__0types_init(struct m0_be_domain *dom);
 
-static int segobj_opt_begin(/* const */ struct m0_be_seg    *dict,
-			    const struct m0_be_0type  *objtype,
-			    const struct m0_buf       *opt,
-			    char                     **suffix)
+static int segobj_opt_begin(struct m0_be_seg         *dict,
+			    const struct m0_be_0type *objtype,
+			    struct m0_buf            *opt,
+			    char                    **suffix)
 {
-	int         rc;
-	char        key[512];
-	const char *prefix = "M0_BE:";
+	struct m0_buf *buf;
+	int	       rc;
 
 	if (strstr(objtype->b0_name, "M0_BE_MKFS:") == objtype->b0_name)
 		return +1;
 
-	M0_PRE(strlen(objtype->b0_name) + strlen(prefix) + 1 < ARRAY_SIZE(key));
-	(void) strcat(key, prefix);
-	(void) strcat(key, objtype->b0_name);
-
-	rc = m0_be_seg_dict_begin(dict, key, (const char **)suffix,
-				  (void**) &opt);
+	rc = m0_be_seg_dict_begin(dict, objtype->b0_name,
+				  (const char **)suffix, (void**) &buf);
 
 	if (rc == -ENOENT)
 		return 0;
-	else if (rc == 0)
+	else if (rc == 0) {
+		if (buf != NULL)
+			*opt = *buf;
 		return +1;
+	}
 
 	return rc;
 }
 
-static int segobj_opt_next(/* const */ struct m0_be_seg    *dict,
-			   const struct m0_be_0type  *objtype,
-			   const struct m0_buf       *opt,
-			   char                     **suffix)
+static int segobj_opt_next(struct m0_be_seg         *dict,
+			   const struct m0_be_0type *objtype,
+			   struct m0_buf            *opt,
+			   char                    **suffix)
 {
-	int rc;
-	char        key[512];
-	const char *prefix = "M0_BE:";
+	struct m0_buf *buf;
+	int            rc;
 
 	if (strstr(objtype->b0_name, "M0_BE_MKFS:") == objtype->b0_name)
 		return 0;
 
-	M0_PRE(strlen(objtype->b0_name) + strlen(prefix) + 1 < ARRAY_SIZE(key));
-	(void) strcat(key, prefix);
-	(void) strcat(key, objtype->b0_name);
-
-
-	rc = m0_be_seg_dict_next(dict, key, *suffix, (const char**) suffix,
-				 (void**) &opt);
+	rc = m0_be_seg_dict_next(dict, objtype->b0_name, *suffix,
+				 (const char**) suffix, (void**) &buf);
 
 	if (rc == -ENOENT)
 		return 0;
-	else if (rc == 0)
+	else if (rc == 0) {
+		if (buf != NULL)
+			*opt = *buf;
 		return +1;
+	}
 
 	return rc;
 }
@@ -108,6 +104,8 @@ static int _0types_visit(struct m0_be_domain *dom, bool init)
 	struct m0_be_0type *objtype;
 	char               *suffix;
 
+	//M0_PRE(zt_tlist_head(&dom->bd_0type_list)->b0_name == "M0_BE:SEG0")
+
 	dict = m0_be_domain_seg0_get(dom);
 
         m0_tl_for(zt, &dom->bd_0type_list, objtype) {
@@ -123,12 +121,56 @@ static int _0types_visit(struct m0_be_domain *dom, bool init)
 	return rc;
 }
 
+static int m0_be_domain__seg0_init(struct m0_be_domain *dom)
+{
+	struct m0_be_seg *seg;
+	int		  rc;
+
+	M0_PRE(dom->bd_seg0_stob != NULL);
+
+	M0_ALLOC_PTR(seg);
+	if (seg == NULL)
+		return -ENOMEM;
+
+	m0_be_seg_init(seg, dom->bd_seg0_stob, dom);
+	rc = m0_be_seg_open(seg);
+	if (rc != 0) {
+		m0_free(seg);
+		return rc;
+	}
+
+	m0_be_seg_dict_init(seg);
+	seg_tlist_add(&dom->bd_seg_list, seg);
+
+	return rc;
+}
+
+static void m0_be_domain__seg0_fini(struct m0_be_domain *dom)
+{
+	struct m0_be_seg *seg;
+
+	M0_PRE(dom->bd_seg0_stob != NULL);
+
+	seg = m0_be_domain_seg0_get(dom);
+	seg_tlist_del(seg);
+	/* there's no need to fini seg dict here */
+	m0_be_seg_close(seg);
+	m0_be_seg_fini(seg);
+	m0_free(seg);
+}
+
 static int m0_be_domain__0types_init(struct m0_be_domain *dom)
 {
 	int		    rc;
 
 	M0_PRE(m0_be_domain_is_locked(dom));
 
+	if (dom->bd_seg0_stob != NULL) { /* means mkfs */
+		rc = m0_be_domain__seg0_init(dom);
+		if (rc != 0)
+			return rc;
+	}
+
 	rc = _0types_visit(dom, true);
 	if (rc != 0)
 		m0_be_domain__0types_fini(dom);
@@ -141,19 +183,9 @@ static void m0_be_domain__0types_fini(struct m0_be_domain *dom)
 	M0_PRE(m0_be_domain_is_locked(dom));
 
 	(void) _0types_visit(dom, false);
-}
-
-M0_UNUSED static struct m0_be_0type *m0_be_domain__0type_lookup(struct m0_be_domain *dom,
-						      const char *name)
-{
-	struct m0_be_0type *type;
-
-	m0_tl_for(zt, &dom->bd_0type_list, type) {
-		if (strcmp(type->b0_name, name) == 0)
-			return type;
-	} m0_tl_endfor;
 
-	return NULL;
+	if (dom->bd_seg0_stob != NULL)
+		m0_be_domain__seg0_fini(dom);
 }
 
 M0_INTERNAL int m0_be_domain_init(struct m0_be_domain *dom)
diff --git a/be/domain.h b/be/domain.h
index ae17580..7262954 100644
--- a/be/domain.h
+++ b/be/domain.h
@@ -43,6 +43,7 @@ struct m0_be_domain {
 	struct m0_tl            bd_0type_list;
 	/** List of segments in this domain. First segment in which is seg0. */
 	struct m0_tl            bd_seg_list;
+	struct m0_stob         *bd_seg0_stob;
 };
 
 M0_INTERNAL int m0_be_domain_start(struct m0_be_domain *dom,
diff --git a/be/ut/fake_mkfs.c b/be/ut/fake_mkfs.c
new file mode 100644
index 0000000..a19f7ff
--- /dev/null
+++ b/be/ut/fake_mkfs.c
@@ -0,0 +1,87 @@
+/*
+ * COPYRIGHT 2013 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: Anatoliy Bilenko <Anatoliy_Bilenko@xyratex.com>
+ * Original creation date: 28-Mar-2014
+ */
+
+#define M0_TRACE_SUBSYSTEM M0_TRACE_SUBSYS_UT
+#include "lib/trace.h"
+#include "lib/types.h"		/* m0_uint128_eq */
+#include "lib/misc.h"		/* M0_BITS */
+#include "lib/memory.h"         /* M0_ALLOC_PTR, m0_free */
+#include "be/ut/helper.h"	/* m0_be_ut_backend */
+#include "ut/ut.h"
+
+#define M0_BE_LOG_NAME  "M0_BE:LOG"
+#define M0_BE_SEG0_NAME "M0_BE:SEG0"
+
+void m0_be_ut_fake_mkfs(void)
+{
+	struct m0_be_0type_log_opts *log_opts;
+	struct m0_buf               *log_opts_buf;
+	struct m0_be_ut_backend      ut_be;
+	struct m0_be_tx_credit       credit = {};
+	struct m0_sm_group          *grp;
+	struct m0_be_seg            *seg;
+	struct m0_be_tx              tx;
+	int                          rc;
+
+	M0_SET0(&ut_be);
+	m0_be_ut_backend_mkfs_init(&ut_be);
+	seg = m0_be_domain_seg0_get(&ut_be.but_dom);
+	m0_be_ut__seg_allocator_init(seg, &ut_be);
+	m0_be_ut_tx_init(&tx, &ut_be);
+
+	grp = m0_be_ut_backend_sm_group_lookup(&ut_be);
+	rc = m0_be_ut__seg_dict_create(seg, grp);
+	M0_UT_ASSERT(rc == 0);
+
+	/* 1) log */
+	m0_be_seg_dict_insert_credit(seg, M0_BE_LOG_NAME, &credit);
+	M0_BE_ALLOC_CREDIT_PTR(log_opts_buf, seg, &credit);
+	M0_BE_ALLOC_CREDIT_PTR(log_opts, seg, &credit);
+	/* 2) seg0 */
+	m0_be_seg_dict_insert_credit(seg, M0_BE_SEG0_NAME, &credit);
+	/* end */
+
+	m0_be_tx_prep(&tx, &credit);
+	m0_be_tx_open_sync(&tx);
+
+	/* 1) log */
+	M0_BE_ALLOC_PTR_SYNC(log_opts_buf, seg, &tx);
+	M0_BE_ALLOC_PTR_SYNC(log_opts, seg, &tx);
+	log_opts->lo_size            = 1 << 27;
+	log_opts->lo_stob_id.si_bits = M0_UINT128(0, 42);
+	m0_buf_init(log_opts_buf, log_opts, sizeof log_opts);
+	M0_BE_TX_CAPTURE_PTR(seg, &tx, log_opts);
+	M0_BE_TX_CAPTURE_PTR(seg, &tx, log_opts_buf);
+
+	rc = m0_be_seg_dict_insert(seg, &tx, M0_BE_LOG_NAME, log_opts_buf);
+	M0_UT_ASSERT(rc == 0);
+
+	/* 2) seg0 */
+	/* There's no seg0 options yet so passing NULL-pointer here */
+	rc = m0_be_seg_dict_insert(seg, &tx, M0_BE_SEG0_NAME, NULL);
+	M0_UT_ASSERT(rc == 0);
+
+	/* end */
+
+	m0_be_tx_close_sync(&tx);
+	m0_be_tx_fini(&tx);
+	m0_be_ut_backend_fini(&ut_be);
+}
+
+#undef M0_TRACE_SUBSYSTEM
diff --git a/be/ut/helper.c b/be/ut/helper.c
index 18d884d..057f523 100644
--- a/be/ut/helper.c
+++ b/be/ut/helper.c
@@ -859,6 +859,66 @@ struct m0_be_0type m0_be_ut_log0 = {
 	.b0_fini = ut_log0_fini
 };
 
+static int seg0_init(const struct m0_be_domain *d, const char *suffix,
+		     const struct m0_buf *data)
+{
+	M0_ENTRY();
+	M0_LEAVE();
+	return 0;
+}
+
+static void seg0_fini(const struct m0_be_domain *d, const char *suffix,
+		      const struct m0_buf *data)
+{
+	M0_ENTRY();
+	M0_LEAVE();
+}
+
+static int log0_init(const struct m0_be_domain *dom, const char *suffix,
+		     const struct m0_buf *data)
+{
+	struct m0_be_engine *en = (struct m0_be_engine*) &dom->bd_engine;
+	struct m0_be_0type_log_opts *opts =
+		(struct m0_be_0type_log_opts *) data->b_addr;
+	struct m0_stob *log_stob;
+
+	int rc;
+
+	M0_ENTRY();
+	M0_ALLOC_PTR(log_stob);
+	M0_ASSERT(log_stob != NULL);
+
+	rc = m0_stob_create_helper(dom->bd_seg0_stob->so_domain,
+				   NULL, &opts->lo_stob_id, &log_stob);
+	M0_ASSERT(rc == 0);
+
+	m0_be_log_init(&en->eng_log, log_stob, m0_be_engine_got_log_space_cb);
+	return M0_RC(m0_be_log_create(&en->eng_log, opts->lo_size));
+}
+
+static void log0_fini(const struct m0_be_domain *dom, const char *suffix,
+			 const struct m0_buf *data)
+{
+	struct m0_be_engine *en = (struct m0_be_engine*) &dom->bd_engine;
+
+	M0_ENTRY();
+	m0_be_log_fini(&en->eng_log);
+	m0_stob_put(en->eng_log.lg_store.ls_stob);
+	M0_LEAVE();
+}
+
+struct m0_be_0type m0_be_log0 = {
+	.b0_name = "M0_BE:LOG",
+	.b0_init = log0_init,
+	.b0_fini = log0_fini
+};
+
+struct m0_be_0type m0_be_seg0 = {
+	.b0_name = "M0_BE:SEG0",
+	.b0_init = seg0_init,
+	.b0_fini = seg0_fini
+};
+
 #undef M0_TRACE_SUBSYSTEM
 
 /*
diff --git a/be/ut/helper.h b/be/ut/helper.h
index 9aef7dd..c6a317f 100644
--- a/be/ut/helper.h
+++ b/be/ut/helper.h
@@ -181,6 +181,8 @@ M0_INTERNAL void m0_ut_be_fom_domain_idle_wait(struct m0_reqh *reqh);
 
 extern struct m0_be_0type m0_be_ut_seg0;
 extern struct m0_be_0type m0_be_ut_log0;
+extern struct m0_be_0type m0_be_log0;
+extern struct m0_be_0type m0_be_seg0;
 
 struct m0_be_0type_log_opts {
 	struct m0_stob_id lo_stob_id;
diff --git a/be/ut/seg0.c b/be/ut/seg0.c
index 566968b..6910ddf 100644
--- a/be/ut/seg0.c
+++ b/be/ut/seg0.c
@@ -52,14 +52,39 @@ void fake_mkfs(void)
 	free(ut_dir);
 }
 
+/*
+ * // level n
+ * m0_be_domain_init(&dom);
+ * m0_be_0type_register(&dom, foo);
+ * m0_be_0type_register(&dom, bar);
+ *
+ * // level m (m > n)
+ * dom.seg0_stob = stob;
+ * m0_be_domain_start(&dom);
+ */
+static void be_domain_init(struct m0_be_domain *dom, struct m0_stob *seg0_stob)
+{
+	int rc;
+	struct m0_be_domain_cfg cfg;
+
+	m0_be_domain_init(dom);
+	m0_be_0type_register(dom, &m0_be_seg0);
+	m0_be_0type_register(dom, &m0_be_log0);
+
+	m0_be_ut_backend_cfg_default(&cfg);
+	cfg.bc_engine.bec_group_fom_reqh = m0_be_ut_reqh_get();
+
+	dom->bd_seg0_stob = seg0_stob;
+	rc = m0_be_domain_start(dom, &cfg);
+	M0_UT_ASSERT(rc == 0);
+}
+
 void m0_be_ut_seg0_test(void)
 {
-	struct m0_stob   *seg0_stob;
-	struct m0_be_seg  seg;
+	struct m0_stob        *seg0_stob;
+	struct m0_stob_id      stob_id;
+	struct m0_be_domain    bedom;
 	struct m0_stob_domain *dom;
-	struct m0_stob_id stob_id;
-	struct m0_be_allocator alloc;
-	void *p;
 	int rc;
 
 	fake_mkfs();
@@ -71,22 +96,9 @@ void m0_be_ut_seg0_test(void)
 	rc = m0_stob_create_helper(dom, NULL, &stob_id, &seg0_stob);
 	M0_ASSERT(rc == 0);
 
-	m0_be_seg_init(&seg, seg0_stob, NULL);
-	rc = m0_be_seg_open(&seg);
-	M0_ASSERT(rc == 0);
-
-	rc = m0_be_allocator_init(&alloc, &seg);
-	M0_ASSERT(rc == 0);
-
-	m0_be_seg_dict_init(&seg);
-
-	rc = m0_be_seg_dict_lookup(&seg, "M0_BE:LOG", &p);
-	M0_ASSERT(p != NULL && rc == 0);
-
-	rc = m0_be_seg_dict_lookup(&seg, "M0_BE:SEG0", &p);
-	M0_ASSERT(p == NULL && rc == 0);
+	be_domain_init(&bedom, seg0_stob);
+	m0_be_domain_fini(&bedom);
 
-	// m0_be_ut_stob_put(seg0_stob, false);
 	m0_stob_put(seg0_stob);
 	dom->sd_ops->sdo_fini(dom);
 }
-- 
1.8.3.2

