From 02e02f092c77e3d4e0e836462bd54d0db43c4c30 Mon Sep 17 00:00:00 2001
From: Mandar Sawant <mandar_sawant@xyratex.com>
Date: Wed, 12 Mar 2014 15:35:14 +0530
Subject: [PATCH 7/8] be.conv.confx, - Address inspection comments. - Move BE
 sepecific code to conf/db.[ch]

---
 conf/Kbuild.sub   |   1 +
 conf/Makefile.sub |   1 +
 conf/confd_fom.c  |   4 +-
 conf/db.c         | 577 +++++++++---------------------------------------------
 conf/db.h         |  42 +---
 conf/preload.c    | 140 ++-----------
 6 files changed, 118 insertions(+), 647 deletions(-)

diff --git a/conf/Kbuild.sub b/conf/Kbuild.sub
index d12c05d..d2adc73 100644
--- a/conf/Kbuild.sub
+++ b/conf/Kbuild.sub
@@ -6,6 +6,7 @@ m0mero_objects += \
                   conf/obj_ops.o \
                   conf/onwire_xc.o \
                   conf/preload.o \
+                  conf/db.o \
                   conf/objs/common.o \
                   conf/objs/dir.o \
                   conf/objs/profile.o \
diff --git a/conf/Makefile.sub b/conf/Makefile.sub
index 758020d..6d8818b 100644
--- a/conf/Makefile.sub
+++ b/conf/Makefile.sub
@@ -18,6 +18,7 @@ mero_libmero_la_SOURCES += \
                            conf/confc.c \
                            conf/confd.c \
                            conf/confd_fom.c \
+                           conf/db.c \
                            conf/fop.c \
                            conf/obj.c \
                            conf/obj_ops.c \
diff --git a/conf/confd_fom.c b/conf/confd_fom.c
index e478c48..adc9244 100644
--- a/conf/confd_fom.c
+++ b/conf/confd_fom.c
@@ -51,7 +51,7 @@ static void conf_addb_init(struct m0_fom *fom, struct m0_addb_mc *mc)
 static int conf_fetch_tick(struct m0_fom *fom);
 static int conf_update_tick(struct m0_fom *fom);
 static int confx_populate(struct m0_confx *dest, const struct objid *origin,
-			  const struct arr_buf *path,
+			  const struct arr_fid *path,
 			  struct m0_conf_cache *cache);
 
 static size_t confd_fom_locality(const struct m0_fom *fom)
@@ -239,7 +239,7 @@ static int confd_path_walk(struct m0_conf_obj *cur, const struct arr_fid *path,
 }
 
 static int confx_populate(struct m0_confx *dest, const struct objid *origin,
-			  const struct arr_buf *path,
+			  const struct arr_fid *path,
 			  struct m0_conf_cache *cache)
 {
 	struct m0_conf_obj *org;
diff --git a/conf/db.c b/conf/db.c
index 957ce02..8ea7eee 100644
--- a/conf/db.c
+++ b/conf/db.c
@@ -23,9 +23,8 @@
 #include "lib/finject.h"
 
 #include "conf/db.h"
-#include "conf/onwire.h"     /* m0_confx_obj, m0_confx */
+#include "conf/onwire.h"
 #include "conf/onwire_xc.h"
-#include "conf/obj.h"        /* m0_conf_objtype */
 #include "xcode/xcode.h"
 #include "db/db.h"
 #include "be/btree.h"
@@ -34,517 +33,133 @@
 #include "lib/memory.h"      /* m0_alloc, m0_free */
 #include "lib/errno.h"       /* EINVAL */
 #include "lib/misc.h"        /* M0_SET0 */
+#include "lib/locality.h"
 
-static enum m0_conf_objtype xobj_type(const struct m0_confx_obj *xobj)
-{
-	uint32_t t = xobj->o_conf.u_type;
-
-	M0_CASSERT(M0_CO_DIR == 0);
-	M0_POST(t < M0_CO_NR && t != M0_CO_DIR);
-	return t;
-}
-
-static int confx_to_xcode_obj(struct m0_confx_obj *xobj,
-			      struct m0_xcode_obj *out, bool decode)
-{
-	M0_PRE(xobj != NULL && out != NULL);
-
-	switch(xobj_type(xobj)) {
-#define _CASE(type, abbrev)                                                         \
-	case type:                                                                  \
-		*out =  M0_XCODE_OBJ(m0_confx_ ## abbrev ## _xc,                    \
-				     decode ? NULL : &xobj->o_conf.u.u_ ## abbrev); \
-		break
-
-	_CASE(M0_CO_PROFILE,    profile);
-	_CASE(M0_CO_FILESYSTEM, filesystem);
-	_CASE(M0_CO_SERVICE,    service);
-	_CASE(M0_CO_NODE,       node);
-	_CASE(M0_CO_NIC,        nic);
-	_CASE(M0_CO_SDEV,       sdev);
-	_CASE(M0_CO_PARTITION,  partition);
-#undef _CASE
-	case M0_CO_DIR:
-	default:
-		M0_RETERR(-EINVAL, "Invalid object type: %u", xobj_type(xobj));
-	}
-
-	M0_RETURN(0);
-}
-
-/* Note: m0_xcode_ctx_init() doesn't allow `xobj' to be const. Sigh. */
-static int
-xcode_ctx_init(struct m0_xcode_ctx *ctx, struct m0_confx_obj *xobj, bool decode)
-{
-	struct m0_xcode_obj obj;
-
-	M0_ENTRY();
-
-	confx_to_xcode_obj(xobj, &obj, decode);
-	m0_xcode_ctx_init(ctx, &obj);
-	if (decode)
-		ctx->xcx_alloc = _conf_xcode_alloc;
-
-	M0_RETURN(0);
-}
-
-static int confx_obj_measure(struct m0_confx_obj *xobj, m0_bcount_t *result)
-{
-	struct m0_xcode_ctx ctx;
-	int                 rc;
-
-	M0_ENTRY();
-
-	rc = xcode_ctx_init(&ctx, xobj, false);
-	if (rc != 0)
-		M0_RETURN(rc);
-
-	rc = m0_xcode_length(&ctx);
-	if (rc < 0)
-		M0_RETURN(rc);
-	M0_ASSERT(rc != 0); /* XXX How can we be so sure? */
-
-	*result = rc;
-	M0_RETURN(0);
-}
-
-/* ------------------------------------------------------------------
- * confdb_key, confdb_obj
- * ------------------------------------------------------------------ */
-
-enum {
-	CONFDB_SRV_EP_MAX = 16,
-	CONFDB_FS_MAX     = 16,
-	CONFDB_NICS_MAX   = 16,
-	CONFDB_SDEVS_MAX  = 16,
-	CONFDB_PART_MAX   = 16,
-	CONFDB_NAME_LEN   = 256,
-
-	/* XXX FIXME: very inaccurate estimations */
-	CONFDB_REC_MAX    = sizeof(struct m0_confx_obj) + CONFDB_NAME_LEN * (
-		CONFDB_SRV_EP_MAX + CONFDB_FS_MAX + CONFDB_NICS_MAX +
-		CONFDB_SDEVS_MAX + CONFDB_PART_MAX)
-};
-
-<<<<<<< HEAD
-struct confdb_key {
-	struct m0_fid cdk_id;
-};
-
-static int
-confdb_key_cmp(const void *key0, const void *key1)
-{
-	return m0_fid_cmp(key0, key1);
-}
-
-static m0_bcount_t confdb_ksize(const void *key)
-{
-	return sizeof(struct confdb_key);
-}
-
-static m0_bcount_t confdb_vsize(const void *val)
-{
-	return sizeof(struct m0_confx_u);
-}
-
-static const struct m0_be_btree_kv_ops confdb_ops = {
-	.ko_ksize   = confdb_ksize,
-	.ko_vsize   = confdb_vsize,
-	.ko_compare = confdb_key_cmp
-};
-
-/**
- * Database representation of a configuration object.
- *
- * confdb_obj can be stored in a database.
+/*
+ * Contains BE segment memory allocation details corresponding to the
+ * configuration object struct confx_ctx::cc_confx.
  */
-struct confdb_obj {
-	struct m0_fid do_key; /*< Object identifier. */
-	struct m0_buf do_rec; /*< Object fields. */
+struct confx_ctx {
+        void                *cc_ptr;
+        m0_bcount_t          cc_total;
+        m0_bcount_t          cc_used;
+        struct m0_xcode_ctx  cc_xctx;
+        struct m0_confx      cc_confx;
 };
 
-static void confx_to_dbkey(struct m0_confx_obj *src, struct confdb_key *key)
+static void *confdb_obj_alloc(struct m0_xcode_cursor *ctx, size_t nob)
 {
-	key->cdk_id = src->o_id;
-}
+        struct confx_ctx *cctx;
+        char             *addr;
 
-/**
- * Encodes m0_confx_obj into the corresponding database representation.
- *
- * If the call succeeds, the user is responsible for freeing allocated memory:
- * @code
- *         m0_buf_free(&dest->do_rec);
- * @endcode
- *
- * @note  xcode API doesn't let `src' to be const.
- */
-static void confx_to_db(struct m0_confx_obj *src, struct confdb_key *key,
-			struct confdb_obj *dest)
-{
-	M0_ENTRY();
+        cctx = container_of(container_of(ctx, struct m0_xcode_ctx, xcx_it),
+                            struct confx_ctx, cc_xctx);
 
-	dest->do_key = key->cdk_id;
-	m0_buf_init(&dest->do_rec, &src->o_conf, sizeof(struct m0_confx_u));
-}
+        M0_PRE(cctx->cc_ptr != NULL);
+        M0_PRE(cctx->cc_used + nob <= cctx->cc_total);
 
-/**
- * Decodes m0_confx_obj from its database representation.
- *
- * @note  XXX User is responsible for freeing `dest' array with
- *        m0_confx_free().
- */
-static void confx_from_db(struct m0_confx_obj *dest, enum m0_conf_objtype type,
-			  struct confdb_obj *src)
-{
-	M0_ENTRY();
-	M0_PRE(M0_CO_DIR < type && type < M0_CO_NR);
+        addr = (char *)cctx->cc_ptr + cctx->cc_used;
+        cctx->cc_used += nob;
 
-	dest->o_id = src->do_key;
-	dest->o_conf = *(struct m0_confx_u *)src->do_rec.b_addr;
+        return addr;
 }
-
-/* ------------------------------------------------------------------
- * Tables
- * ------------------------------------------------------------------ */
-/* XXX Consider using "The X macro":
- * http://www.drdobbs.com/cpp/the-x-macro/228700289 */
-
-static const char *table_names[] = {
-	[M0_CO_DIR]        = NULL,
-	[M0_CO_PROFILE]    = "profile",
-	[M0_CO_FILESYSTEM] = "filesystem",
-	[M0_CO_SERVICE]    = "service",
-	[M0_CO_NODE]       = "node",
-	[M0_CO_NIC]        = "nic",
-	[M0_CO_SDEV]       = "sdev",
-	[M0_CO_PARTITION]  = "partition"
-};
-M0_BASSERT(ARRAY_SIZE(table_names) == M0_CO_NR);
 
-static void confdb_tables_fini(struct m0_be_seg *seg)
+M0_INTERNAL int m0_confdb_free(struct m0_confx *enc, struct m0_be_seg *seg,
+			       struct m0_be_tx *tx)
 {
-	struct m0_be_btree *btree;
-	int                 i;
-	int                 rc;
+	struct confx_ctx       *cctx;
+	struct m0_be_tx_credit  cred = {};
+	struct m0_sm_group     *grp = m0_locality0_get()->lo_grp;
+	int                     rc;
 
-	M0_ENTRY();
-
-	for (i = 0; i < ARRAY_SIZE(table_names); ++i) {
-		if (table_names[i] == NULL)
-			continue;
-		rc = m0_be_seg_dict_lookup(seg, table_names[i],
-					   (void **)&btree);
-		if (rc == 0)
-			m0_be_btree_fini(btree);
+	cctx = container_of(enc, struct confx_ctx, cc_confx);
+	m0_be_allocator_credit(m0_be_seg_allocator(seg), M0_BAO_FREE,
+			       cctx->cc_total, 0, &cred);
+	m0_sm_group_lock(grp);
+	m0_be_tx_init(tx, 0, seg->bs_domain, grp, NULL, NULL, NULL, NULL);
+	m0_be_tx_prep(tx, &cred);
+	rc = m0_be_tx_open_sync(tx);
+	if (rc == 0) {
+		M0_BE_FREE_PTR_SYNC(cctx->cc_ptr, seg, tx);
+		m0_be_tx_close_sync(tx);
+		m0_free(cctx);
 	}
+	m0_be_tx_fini(tx);
+	m0_sm_group_unlock(grp);
 
-	M0_LEAVE();
+	M0_RETURN(rc);
 }
 
-static int
-confdb_tables_init(struct m0_be_seg *seg, struct m0_be_btree *btrees[],
-		   struct m0_be_tx *tx)
+static int confdb_alloc(struct confx_ctx *cctx, struct m0_be_seg *seg,
+			struct m0_be_tx *tx, int size)
 {
-	int                 i;
-	int                 rc = 0;
+	struct m0_be_tx_credit  cred = {};
+	struct m0_sm_group     *grp = m0_locality0_get()->lo_grp;
+	int                     rc;
 
-	M0_ENTRY();
-
-	for (i = 0; i < M0_CO_NR; ++i) {
-		if (table_names[i] == NULL)
-			continue;
-		M0_BE_ALLOC_PTR_SYNC(btrees[i], seg, tx);
-		m0_be_btree_init(btrees[i], seg, &confdb_ops);
-		M0_BE_OP_SYNC(op, m0_be_btree_create(btrees[i], tx, &op));
-		rc = m0_be_seg_dict_insert(seg, tx, table_names[i], btrees[i]);
-		if (rc != 0)
-			break;
-	}
-
-	if (M0_FI_ENABLED("ut_confdb_create_failure"))
-		rc = -EINVAL;
+	m0_be_allocator_credit(m0_be_seg_allocator(seg), M0_BAO_ALLOC,
+			       size, 0, &cred);
+	m0_sm_group_lock(grp);
+	m0_be_tx_init(tx, 0, seg->bs_domain, grp, NULL, NULL, NULL, NULL);
+	m0_be_tx_prep(tx, &cred);
+	rc = m0_be_tx_open_sync(tx);
 	if (rc != 0) {
-		confdb_tables_fini(seg);
-		m0_confdb_destroy(seg, tx);
+		m0_be_tx_fini(tx);
+		M0_RETURN(rc);
 	}
-
-	M0_RETURN(rc);
-}
-
-/* ------------------------------------------------------------------
- * Database operations
- * ------------------------------------------------------------------ */
-static int confx_obj_dup(struct m0_confx_obj *dest, struct m0_confx_obj *src,
-			 struct m0_be_seg *seg, struct m0_be_tx *tx)
-{
-	struct m0_xcode_obj    src_obj;
-	struct m0_xcode_obj    dest_obj;
-	int                    rc;
-
-	dest->o_id = src->o_id;
-	dest->o_conf.u_type = src->o_conf.u_type;
-	rc = confx_to_xcode_obj(dest, &dest_obj, false) ?:
-		confx_to_xcode_obj(src, &src_obj, false);
-	if (M0_FI_ENABLED("ut_confx_obj_dup_failure"))
-		rc = -EINVAL;
-	if (rc == 0)
-		rc = m0_xcode_be_dup(&dest_obj, &src_obj, seg, tx);
+	M0_BE_OP_SYNC(__op,
+			m0_be_alloc(m0_be_seg_allocator(seg), tx, &__op,
+				    &cctx->cc_ptr, size));
+	M0_ASSERT(cctx->cc_ptr != NULL);
+	m0_be_tx_close_sync(tx);
+	m0_be_tx_fini(tx);
+	m0_sm_group_unlock(grp);
+	if (cctx->cc_ptr == NULL)
+		return -ENOMEM;
+	cctx->cc_total = size;
+	cctx->cc_used  = 0;
 
 	return rc;
 }
 
-M0_INTERNAL int m0_confdb_create_credit(struct m0_be_seg *seg,
-					const struct m0_confx *conf,
-					struct m0_be_tx_credit *accum)
+M0_INTERNAL int m0_confx_to_db(struct m0_confx *conf, struct m0_be_seg *seg,
+			       struct m0_be_tx *tx, struct m0_confx **out)
 {
-	struct m0_be_btree   btree = { .bb_seg = seg };
-	m0_bcount_t          len;
-	m0_bcount_t          ksize;
-	struct m0_confx_obj *obj;
-	int                  rc;
-	int                  i;
-
-	m0_be_btree_create_credit(&btree, ARRAY_SIZE(table_names), accum);
-	for (i = 0; i < ARRAY_SIZE(table_names); ++i) {
-		if (table_names[i] == NULL)
-			continue;
-		M0_BE_ALLOC_CREDIT_PTR(&btree, seg, accum);
-		m0_be_seg_dict_insert_credit(seg, table_names[i], accum);
-	}
-
-	for (i = 0; i < conf->cx_nr; ++i) {
-		obj = &conf->cx_objs[i];
-		M0_ASSERT(IS_IN_ARRAY(xobj_type(obj), table_names));
-		rc = confx_obj_measure(obj, &len);
-		if (rc != 0)
-			M0_RETURN(rc);
-		len += sizeof(obj->o_conf.u_type);
-		ksize = sizeof(struct confdb_key);
-		m0_be_btree_insert_credit(&btree, 1, ksize, len, accum);
-	}
-
-	M0_LOG(M0_FATAL, "total credits: %lu", (unsigned long)accum->tc_reg_size);
-	M0_RETURN(0);
-}
-
-M0_INTERNAL int m0_confdb_destroy_credit(struct m0_be_seg *seg,
-					 struct m0_be_tx_credit *accum)
-{
-	struct m0_be_btree *btree;
-	int                 i;
-	int                 rc = 0;
-
-	for (i = 0; i < ARRAY_SIZE(table_names); ++i) {
-		if (table_names[i] == NULL)
-			continue;
-		rc = m0_be_seg_dict_lookup(seg, table_names[i],
-					   (void **)&btree);
-		if (rc != 0)
-			M0_RETURN(rc);
-		m0_be_btree_destroy_credit(btree, 1, accum);
-		M0_BE_FREE_CREDIT_PTR(btree, seg, accum);
-	}
-
-	M0_RETURN(rc);
-}
-
-M0_INTERNAL int m0_confdb_destroy(struct m0_be_seg *seg, struct m0_be_tx *tx)
-{
-	struct m0_be_btree     *btree;
-	int                     i;
+        struct confx_ctx       *cctx = NULL;
+	struct m0_xcode_ctx    *dctx;
+        struct m0_xcode_ctx     ctx;
 	int                     rc = 0;
+	int                     result;
 
-	/*
-	 * FIXME: Does not free the internal be objects allocated during
-	 *        confdb_create as part of xcode_dup operation.
-	 */
-
-	for (i = 0; i < ARRAY_SIZE(table_names); ++i) {
-		if (table_names[i] == NULL)
-			continue;
-		rc = m0_be_seg_dict_lookup(seg, table_names[i],
-					   (void **)&btree);
-		if (rc != 0)
-			M0_RETURN(rc);
-		M0_BE_OP_SYNC(op, m0_be_btree_destroy(btree, tx, &op));
-		M0_BE_FREE_PTR_SYNC(btree, seg, tx);
-		rc = m0_be_seg_dict_delete(seg, tx, table_names[i]);
-		if (rc != 0)
+	M0_ALLOC_PTR(cctx);
+	if (cctx == NULL)
+		M0_RETURN(rc);
+	M0_SET0(&ctx);
+	m0_xcode_ctx_init(&ctx, &M0_XCODE_OBJ(m0_confx_xc, conf));
+	result = m0_xcode_length(&ctx);
+	if (result < 0) {
+		m0_free(cctx);
+		M0_RETURN(result);
+	} else {
+		result += sizeof(struct m0_confx_obj) * conf->cx_nr;
+		rc = confdb_alloc(cctx, seg, tx, result);
+		if (rc != 0) {
+			m0_free(cctx);
 			M0_RETURN(rc);
-	}
-
-	M0_RETURN(rc);
-}
-
-M0_INTERNAL void m0_confdb_fini(struct m0_be_seg *seg)
-{
-	confdb_tables_fini(seg);
-}
-
-M0_INTERNAL int m0_confdb_create(struct m0_be_seg *seg, struct m0_be_tx *tx,
-				 const struct m0_confx *conf)
-{
-	struct m0_be_btree  *btrees[ARRAY_SIZE(table_names)];
-	struct m0_be_btree  *btree;
-	struct m0_confx_obj *confx_objs;
-	struct confdb_key    db_key;
-	struct confdb_obj    db_obj;
-	m0_bcount_t          nr_objs;
-	int                  i;
-	int                  rc;
-
-	M0_ENTRY();
-	M0_PRE(conf->cx_nr > 0);
-
-	rc = confdb_tables_init(seg, btrees, tx);
-	if (rc != 0)
-		return rc;
-	M0_ALLOC_ARR(confx_objs, conf->cx_nr);
-	for (i = 0; i < conf->cx_nr && rc == 0; ++i) {
-		M0_ASSERT(IS_IN_ARRAY(xobj_type(&conf->cx_objs[i]),
-				      table_names));
-		rc = confx_obj_dup(&confx_objs[i], &conf->cx_objs[i], seg, tx);
-		if (rc != 0)
-			break;
-		M0_SET0(&db_obj);
-		confx_to_dbkey(&confx_objs[i], &db_key);
-		confx_to_db(&confx_objs[i], &db_key, &db_obj);
-		btree = btrees[xobj_type(&conf->cx_objs[i])];
-		M0_BE_OP_SYNC(op, m0_be_btree_insert(btree, tx, &op,
-						 &M0_FID_BUF(&db_obj.do_key),
-						 &db_obj.do_rec));
-	}
-	if (rc == 0) {
-		rc = confdb_objs_count(btrees, &nr_objs);
-		M0_ASSERT(rc == 0);
-	}
-	if (rc !=0) {
-		confdb_tables_fini(seg);
-		m0_confdb_destroy(seg, tx);
-	}
-	m0_free(confx_objs);
-	M0_RETURN(rc);
-}
-
-/* XXX FIXME: Other functions receive both `tables' and the number of tables.
- * confdb_objs_count() shouldn't be different. */
-static int
-confdb_objs_count(struct m0_be_btree *btrees[], size_t *result)
-{
-	struct m0_be_btree_cursor  bcur;
-	int                        t;
-	int                        rc;
-
-	M0_ENTRY();
-
-	/* Too large to be allocated on stack. */
-	*result = 0;
-	for (t = M0_CO_PROFILE; t < M0_CO_NR; ++t) {
-		m0_be_btree_cursor_init(&bcur, btrees[t]);
-		for (rc = m0_be_btree_cursor_first_sync(&bcur); rc == 0;
-		     rc = m0_be_btree_cursor_next_sync(&bcur)) {
-			++*result;
-		}
-		m0_be_btree_cursor_fini(&bcur);
-		/* Make sure we are at the end of the table. */
-		M0_ASSERT(rc == -ENOENT);
-		rc = 0;
-	}
-
-	M0_RETURN(rc);
-}
-
-static struct m0_confx *confx_alloc(size_t nr_objs)
-{
-	struct m0_confx *ret;
-
-	M0_PRE(nr_objs > 0);
-
-	M0_ALLOC_PTR(ret);
-	if (ret == NULL)
-		return NULL;
-
-	M0_ALLOC_ARR(ret->cx_objs, nr_objs);
-	if (ret->cx_objs == NULL) {
-		m0_free(ret);
-		return NULL;
-	}
-
-	ret->cx_nr = nr_objs;
-	return ret;
-}
-
-static void
-=======
-static int
->>>>>>> be.conv.confx,
-confx_fill(struct m0_confx *dest, struct m0_be_btree *btrees[])
-{
-	struct m0_be_btree_cursor bcur;
-	size_t                    ti;    /* index in tables[] */
-	size_t                    i = 0; /* index in dest->cx_objs[] */
-
-	M0_ENTRY();
-	M0_PRE(dest->cx_nr > 0);
-
-	for (ti = M0_CO_PROFILE; ti <= M0_CO_PARTITION; ++ti) {
-		int rc;
-		struct m0_buf keybuf;
-
-		m0_be_btree_cursor_init(&bcur, btrees[ti]);
-		for (rc = m0_be_btree_cursor_first_sync(&bcur); rc == 0;
-		     rc = m0_be_btree_cursor_next_sync(&bcur), ++i) {
-			struct confdb_obj dbobj;
-			m0_be_btree_cursor_kv_get(&bcur, &keybuf,
-						  &dbobj.do_rec);
-			M0_ASSERT(i < dest->cx_nr);
-			/**
-			 * @todo check validity of key and record addresses and
-			 * sizes. Specifically, check that keybuf.b_addr points
-			 * to an allocated region in a segment with appropriate
-			 * size and alignment. Such checks should be done
-			 * generally by (not existing) beobj interface.
-			 */
-			dbobj.do_key = *(struct m0_fid *)keybuf.b_addr;
-			confx_from_db(&dest->cx_objs[i], ti, &dbobj);
 		}
-		m0_be_btree_cursor_fini(&bcur);
-		M0_ASSERT(rc == -ENOENT); /* end of the table */
-	}
-}
-
-M0_INTERNAL int m0_confdb_read(struct m0_be_seg *seg, struct m0_confx **out)
-{
-	struct m0_be_btree *btrees[ARRAY_SIZE(table_names)];
-	int                 i;
-	int                 rc;
-	size_t              nr_objs = 0;
-
-	M0_ENTRY();
-
-	for (i = 0; i < ARRAY_SIZE(table_names); ++i) {
-		if (table_names[i] == NULL)
-			continue;
-		rc = m0_be_seg_dict_lookup(seg, table_names[i],
-					   (void **)&btrees[i]);
-		if (rc != 0)
-			return rc;
-	}
-	rc = confdb_objs_count(btrees, &nr_objs);
-	if (rc != 0)
-		goto out;
-	if (nr_objs == 0) {
-		rc = -ENODATA;
-		goto out;
-	}
-	*out = confx_alloc(nr_objs);
-	if (*out == NULL) {
-		rc = -ENOMEM;
-		goto out;
+		dctx = &cctx->cc_xctx;
+		M0_SET0(dctx);
+		M0_SET0(&ctx);
+		m0_xcode_ctx_init(dctx, &M0_XCODE_OBJ(m0_confx_xc,
+				  &cctx->cc_confx));
+		dctx->xcx_alloc = confdb_obj_alloc;
+		m0_xcode_ctx_init(&ctx, &M0_XCODE_OBJ(m0_confx_xc,
+						      *out));
+		rc = m0_xcode_dup(dctx, &ctx);
+		if (rc == 0)
+			*out = &cctx->cc_confx;
 	}
 
-	confx_fill(*out, btrees);
-out:
 	M0_RETURN(rc);
 }
 
diff --git a/conf/db.h b/conf/db.h
index abb23a1..246e838 100644
--- a/conf/db.h
+++ b/conf/db.h
@@ -21,48 +21,14 @@
 #ifndef __MERO_CONF_DB_H__
 #define __MERO_CONF_DB_H__
 
-#include "be/tx_credit.h"
 #include "be/seg.h"
 
 
 struct m0_confx;
-struct m0_confx_obj;
 
-/**
- * Calculates BE credits required by configuration database tables and @conf.
- */
-M0_INTERNAL int m0_confdb_create_credit(struct m0_be_seg *seg,
-					const struct m0_confx *conf,
-					struct m0_be_tx_credit *accum);
-
-/**
- * Creates configuration database, populating it with provided
- * configuration data.
- *
- * @pre  conf->cx_nr > 0
- */
-M0_INTERNAL int m0_confdb_create(struct m0_be_seg *seg, struct m0_be_tx *tx,
-                                 const struct m0_confx *conf);
-
-/**
- * Finalises in-memory configuration database.
- */
-M0_INTERNAL void m0_confdb_fini(struct m0_be_seg *seg);
-/**
- * Calculates BE credits in-order to destroy configuration database from
- * persistent store.
- */
-M0_INTERNAL int m0_confdb_destroy_credit(struct m0_be_seg *seg,
-					 struct m0_be_tx_credit *accum);
-M0_INTERNAL int m0_confdb_destroy(struct m0_be_seg *seg, struct m0_be_tx *tx);
-
-/**
- * Creates m0_confx and populates it with data read from a
- * configuration database.
- *
- * If the call succeeds, the user is responsible for freeing allocated
- * memory with m0_confx_free(*out).
- */
-M0_INTERNAL int m0_confdb_read(struct m0_be_seg *seg, struct m0_confx **out);
+M0_INTERNAL int m0_confx_to_db(struct m0_confx *conf, struct m0_be_seg *seg,
+			       struct m0_be_tx *tx, struct m0_confx **out);
+M0_INTERNAL int m0_confdb_free(struct m0_confx *enc, struct m0_be_seg *seg,
+			       struct m0_be_tx *tx);
 
 #endif /* __MERO_CONF_DB_H__ */
diff --git a/conf/preload.c b/conf/preload.c
index 4a0b3a6..ae3caa1 100644
--- a/conf/preload.c
+++ b/conf/preload.c
@@ -22,6 +22,7 @@
 #define M0_TRACE_SUBSYSTEM M0_TRACE_SUBSYS_CONF
 #include "lib/trace.h"
 
+#include "conf/db.h"
 #include "conf/preload.h"
 #include "conf/onwire.h"     /* m0_confx */
 #include "conf/onwire_xc.h"  /* m0_confx_xc */
@@ -39,104 +40,29 @@
  * Contains BE segment memory allocation details corresponding to the
  * configuration object struct confx_ctx::cc_confx.
  */
-struct confx_ctx {
-	void                *cc_ptr;
-	m0_bcount_t          cc_total;
-	m0_bcount_t          cc_used;
-	struct m0_xcode_ctx  cc_xctx;
-	struct m0_confx      cc_confx;
-};
-
-static void *__confx_alloc(struct m0_xcode_cursor *ctx, size_t nob)
-{
-	struct confx_ctx *cctx;
-	char             *addr;
-
-	cctx = container_of(container_of(ctx, struct m0_xcode_ctx, xcx_it),
-			    struct confx_ctx, cc_xctx);
-
-	M0_PRE(cctx->cc_ptr != NULL);
-	M0_PRE(cctx->cc_used + nob <= cctx->cc_total);
-
-	addr = (char *)cctx->cc_ptr + cctx->cc_used;
-	cctx->cc_used += nob;
-
-	return addr;
-}
-
 M0_INTERNAL int m0_confx_free(struct m0_confx *enc, struct m0_be_seg *seg,
 			      struct m0_be_tx *tx)
 {
-	struct confx_ctx       *cctx;
-	struct m0_be_tx_credit  cred = {};
-	struct m0_sm_group     *grp = m0_locality0_get()->lo_grp;
-	int                     rc = 0;
+	int rc = 0;
 
 	M0_ENTRY();
 
 	if (enc != NULL) {
-		if (seg == NULL) {
+		if (seg != NULL)
+			rc = m0_confdb_free(enc, seg, tx);
+		else
 			m0_xcode_free(&M0_XCODE_OBJ(m0_confx_xc, enc));
-		} else {
-			cctx = container_of(enc, struct confx_ctx, cc_confx);
-			m0_be_allocator_credit(m0_be_seg_allocator(seg), M0_BAO_FREE,
-					       cctx->cc_total, 0, &cred);
-			m0_sm_group_lock(grp);
-			m0_be_tx_init(tx, 0, seg->bs_domain, grp, NULL, NULL, NULL, NULL);
-			m0_be_tx_prep(tx, &cred);
-			rc = m0_be_tx_open_sync(tx);
-			if (rc == 0) {
-				M0_BE_FREE_PTR_SYNC(cctx->cc_ptr, seg, tx);
-				m0_be_tx_close_sync(tx);
-			}
-			m0_be_tx_fini(tx);
-			m0_sm_group_unlock(grp);
-			m0_free(cctx);
-		}
 	}
 
 	M0_RETURN(rc);
 }
 
-static int confstr_be_mem_alloc(struct confx_ctx *cctx, struct m0_be_seg *seg,
-				struct m0_be_tx *tx, int size)
-{
-	struct m0_be_tx_credit  cred = {};
-	struct m0_sm_group     *grp = m0_locality0_get()->lo_grp;
-	int                     rc;
-
-	m0_be_allocator_credit(m0_be_seg_allocator(seg), M0_BAO_ALLOC,
-			       size, 0, &cred);
-	m0_sm_group_lock(grp);
-	m0_be_tx_init(tx, 0, seg->bs_domain, grp, NULL, NULL, NULL, NULL);
-	m0_be_tx_prep(tx, &cred);
-	rc = m0_be_tx_open_sync(tx);
-	if (rc != 0) {
-		m0_be_tx_fini(tx);
-		M0_RETURN(rc);
-	}
-	M0_BE_OP_SYNC(__op,
-		      m0_be_alloc(m0_be_seg_allocator(seg), tx, &__op,
-				  &cctx->cc_ptr, size));
-	M0_ASSERT(cctx->cc_ptr != NULL);
-	m0_be_tx_close_sync(tx);
-	m0_be_tx_fini(tx);
-	m0_sm_group_unlock(grp);
-	if (cctx->cc_ptr == NULL)
-		return -ENOMEM;
-	cctx->cc_total = size;
-	cctx->cc_used  = 0;
-
-	return rc;
-}
-
 M0_INTERNAL int m0_confstr_parse(const char *s, struct m0_be_seg *seg,
 				 struct m0_be_tx *tx, struct m0_confx **out)
 {
-	struct confx_ctx       *cctx = NULL;
-	struct m0_xcode_ctx     ctx;
-	int                     rc;
-	int                     result;
+	struct m0_confx     *conf;
+	struct m0_xcode_ctx  ctx;
+	int                  rc;
 
 	M0_ENTRY();
 
@@ -152,53 +78,15 @@ M0_INTERNAL int m0_confstr_parse(const char *s, struct m0_be_seg *seg,
 		M0_RETURN(rc);
 	}
 	if (rc == 0 && seg != NULL) {
-		struct m0_xcode_ctx *dctx;
-
-		M0_ALLOC_PTR(cctx);
-		if (cctx == NULL) {
-			rc = -ENOMEM;
-			goto cleanup;
-		}
-		M0_SET0(&ctx);
-		m0_xcode_ctx_init(&ctx, &M0_XCODE_OBJ(m0_confx_xc, *out));
-		result = m0_xcode_length(&ctx);
-		if (result < 0) {
-			m0_free(cctx);
-			rc = result;
-			goto cleanup;
-		} else {
-			result += sizeof(struct m0_confx_obj) * (*out)->cx_nr;
-			rc = confstr_be_mem_alloc(cctx, seg, tx, result);
-			if (rc != 0) {
-				m0_free(cctx);
-				goto cleanup;
-			}
-			dctx = &cctx->cc_xctx;
-			M0_SET0(dctx);
-			M0_SET0(&ctx);
-			m0_xcode_ctx_init(dctx, &M0_XCODE_OBJ(m0_confx_xc,
-					  &cctx->cc_confx));
-			dctx->xcx_alloc = __confx_alloc;
-			m0_xcode_ctx_init(&ctx, &M0_XCODE_OBJ(m0_confx_xc,
-							      *out));
-			rc = m0_xcode_dup(dctx, &ctx);
-			if (rc == 0) {
-				rc = m0_confx_free(*out, NULL, NULL);
-				if (rc == 0)
-					*out = &cctx->cc_confx;
-			}
-		}
-	}
-
-cleanup:
-	if (rc != 0) {
-		rc = m0_confx_free(*out, NULL, NULL);
+		conf = *out;
+		rc = m0_confx_to_db(conf, seg, tx, out);
+		if (rc != 0)
+			*out = NULL;
+		rc = m0_confx_free(conf, NULL, NULL);
 		if (rc != 0)
 			M0_LOG(M0_NOTICE,
-			       "Cannot free configuration object, rc :\n%s %d",
+			       "Cannot free configuration object, \n%s rc: %d",
 			       s, rc);
-		else
-			*out = NULL;
 	}
 
 	M0_RETURN(rc);
-- 
1.8.3.2

