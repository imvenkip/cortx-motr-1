From f377735f422ea0075fbacc7c973d23190971ba0f Mon Sep 17 00:00:00 2001
From: Mandar Sawant <mandar_sawant@xyratex.com>
Date: Fri, 21 Feb 2014 17:43:37 +0530
Subject: [PATCH 1/8] be.conv.confx,

- Modify m0_confx_str_parse() to build configuration object directly
  into BE segment memory through configuration string directly.
- Support both building configuration objects into BE segment memory as well
  as in main memory through xcode.
---
 conf/confc.c      |   4 +-
 conf/confd.c      |  10 +--
 conf/confd_fom.c  |   5 +-
 conf/db.c         |   1 +
 conf/preload.c    | 210 +++++++++++++++++++++++++++++++++++++++++++++++++++---
 conf/preload.h    |   6 +-
 conf/ut/cache.c   |   6 +-
 conf/ut/db.c      |  30 ++++++--
 conf/ut/fuzz.c    |   6 +-
 console/console.c |   4 +-
 xcode/string.c    |  18 ++---
 xcode/ut/xcode.c  |  81 +++++++++++++++------
 xcode/xcode.h     |   2 +-
 13 files changed, 321 insertions(+), 62 deletions(-)

diff --git a/conf/confc.c b/conf/confc.c
index 343d3b4..c904fd0 100644
--- a/conf/confc.c
+++ b/conf/confc.c
@@ -1245,11 +1245,11 @@ static int confc_cache_preload(struct m0_confc *confc, const char *local_conf)
 	M0_ENTRY();
 	M0_PRE(confc_is_locked(confc));
 
-	rc = m0_confstr_parse(local_conf, &enc);
+	rc = m0_confstr_parse(local_conf, NULL, &enc);
 	if (rc == 0) {
 		for (i = 0; i < enc->cx_nr && rc == 0; ++i)
 			rc = cached_obj_update(confc, &enc->cx_objs[i]);
-		m0_confx_free(enc);
+		m0_confx_free(enc, NULL);
 	}
 	M0_RETURN(rc);
 }
diff --git a/conf/confd.c b/conf/confd.c
index 7116b3d..93feff3 100644
--- a/conf/confd.c
+++ b/conf/confd.c
@@ -505,7 +505,8 @@ static int file_read(const char *path, char *dest, size_t sz)
 	M0_RETURN(rc);
 }
 
-static int confd_cache_preload(struct m0_conf_cache *cache, const char *dbpath)
+static int confd_cache_preload(struct m0_conf_cache *cache,
+			       struct m0_be_seg *seg, const char *dbpath)
 {
 	static char      buf[4096];
 	struct m0_confx *enc;
@@ -515,7 +516,8 @@ static int confd_cache_preload(struct m0_conf_cache *cache, const char *dbpath)
 	M0_ENTRY();
 	M0_PRE(m0_mutex_is_locked(cache->ca_lock));
 
-	rc = file_read(dbpath, buf, sizeof buf) ?: m0_confstr_parse(buf, &enc);
+	rc = file_read(dbpath, buf, sizeof buf) ?: m0_confstr_parse(buf, seg,
+								    &enc);
 	if (rc != 0)
 		M0_RETURN(rc);
 
@@ -528,7 +530,7 @@ static int confd_cache_preload(struct m0_conf_cache *cache, const char *dbpath)
 			m0_conf_obj_fill(obj, xobj, cache);
 	}
 
-	m0_confx_free(enc);
+	m0_confx_free(enc, seg);
 	M0_RETURN(rc);
 }
 
@@ -556,7 +558,7 @@ static int confd_allocate(struct m0_reqh_service **service,
 	m0_conf_cache_init(&confd->d_cache, &confd->d_lock);
 
 	m0_mutex_lock(&confd->d_lock);
-	rc = confd_cache_preload(&confd->d_cache, rctx->rc_confdb);
+	rc = confd_cache_preload(&confd->d_cache, rctx->rc_beseg, rctx->rc_confdb);
 	m0_mutex_unlock(&confd->d_lock);
 
 	if (rc == 0) {
diff --git a/conf/confd_fom.c b/conf/confd_fom.c
index 816d9e1..c033bc9 100644
--- a/conf/confd_fom.c
+++ b/conf/confd_fom.c
@@ -28,6 +28,7 @@
 #include "conf/preload.h"     /* m0_confx_free */
 #include "rpc/rpc_opcodes.h"  /* M0_CONF_FETCH_OPCODE */
 #include "fop/fom_generic.h"  /* M0_FOPH_NR */
+#include "reqh/reqh.h"
 #include "lib/memory.h"       /* m0_free */
 #include "lib/misc.h"         /* M0_SET0 */
 #include "lib/errno.h"        /* ENOMEM, EOPNOTSUPP */
@@ -130,7 +131,7 @@ static int conf_fetch_tick(struct m0_fom *fom)
 	confd = bob_of(fom->fo_service, struct m0_confd, d_reqh, &m0_confd_bob);
 	m0_mutex_lock(&confd->d_lock);
 	rc = confx_populate(&r->fr_data, &q->f_origin, &q->f_path,
-			    &confd->d_cache);
+			    &confd->d_cache, confd->d_reqh.rs_reqh->rh_beseg);
 	m0_mutex_unlock(&confd->d_lock);
 	if (rc != 0)
 		M0_ASSERT(r->fr_data.cx_nr == 0 && r->fr_data.cx_objs == NULL);
@@ -269,7 +270,7 @@ static int confx_populate(struct m0_confx *dest, const struct objid *origin,
 	if (rc == 0)
 		M0_ASSERT(nr == 0);
 	else
-		m0_confx_free(dest);
+		m0_confx_free(dest, seg);
 	M0_RETURN(rc);
 }
 
diff --git a/conf/db.c b/conf/db.c
index 8a8de9c..745a95c 100644
--- a/conf/db.c
+++ b/conf/db.c
@@ -335,6 +335,7 @@ M0_INTERNAL int m0_confdb_create_credit(struct m0_be_seg *seg,
 		m0_be_btree_insert_credit(&btree, 1, ksize, len, accum);
 	}
 
+	M0_LOG(M0_FATAL, "total credits: %lu", (unsigned long)accum->tc_reg_size);
 	M0_RETURN(0);
 }
 
diff --git a/conf/preload.c b/conf/preload.c
index ad996f4..e80c1d1 100644
--- a/conf/preload.c
+++ b/conf/preload.c
@@ -25,35 +25,225 @@
 #include "conf/preload.h"
 #include "conf/onwire.h"     /* m0_confx */
 #include "conf/onwire_xc.h"  /* m0_confx_xc */
+#include "conf/obj.h"
 #include "xcode/xcode.h"
 #include "lib/memory.h"      /* M0_ALLOC_PTR */
 #include "lib/errno.h"       /* ENOMEM */
+#include "lib/locality.h"
+#include "be/tx.h"
+#include "be/tx_credit.h"
+#include "be/alloc.h"
+#include "be/op.h"
+#ifndef __KERNEL__
+#include <stdio.h>
+#endif
 
-M0_INTERNAL void m0_confx_free(struct m0_confx *enc)
+struct confx_ctx {
+	void                *cc_ptr;
+	m0_bcount_t          cc_total;
+	m0_bcount_t          cc_used;
+	struct m0_xcode_ctx  cc_xctx;
+	struct m0_confx      cc_confx;
+};
+
+static void *__confx_ctx_alloc(struct confx_ctx *cctx, size_t nob)
 {
+	char *addr;
+
+	M0_PRE(cctx->cc_ptr != NULL);
+	M0_PRE(cctx->cc_used + nob <= cctx->cc_total);
+
+	addr = (char *)cctx->cc_ptr + cctx->cc_used;
+	cctx->cc_used += nob;
+
+	return addr;
+}
+
+static void *__confx_alloc(struct m0_xcode_cursor *ctx, size_t nob)
+{
+	struct confx_ctx *cctx;
+
+	cctx = container_of(container_of(ctx, struct m0_xcode_ctx, xcx_it),
+			    struct confx_ctx, cc_xctx);
+
+	return __confx_ctx_alloc(cctx, nob);
+}
+
+M0_INTERNAL void m0_confx_free(struct m0_confx *enc, struct m0_be_seg *seg)
+{
+	struct confx_ctx *cctx;
+	struct m0_be_tx_credit  cred = {};
+	struct m0_be_tx         tx;
+	struct m0_sm_group     *grp = m0_locality0_get()->lo_grp;
+	int                     rc;
+
 	M0_ENTRY();
-	if (enc != NULL)
-		m0_xcode_free(&M0_XCODE_OBJ(m0_confx_xc, enc));
+
+	if (enc != NULL) {
+		if (seg == NULL)
+			m0_xcode_free(&M0_XCODE_OBJ(m0_confx_xc, enc));
+		else {
+			cctx = container_of(enc, struct confx_ctx, cc_confx);
+			m0_be_allocator_credit(m0_be_seg_allocator(seg), M0_BAO_FREE,
+					       cctx->cc_total, 0, &cred);
+			m0_sm_group_lock(grp);
+			m0_be_tx_init(&tx, 0, seg->bs_domain, grp, NULL, NULL, NULL, NULL);
+			m0_be_tx_prep(&tx, &cred);
+			rc = m0_be_tx_open_sync(&tx);
+			if (rc != 0) {
+				M0_LOG(M0_FATAL, "rc: %d", rc);
+				M0_ASSERT(rc == 0);
+			}
+			M0_BE_OP_SYNC(op, m0_be_free(m0_be_seg_allocator(seg), &tx, &op,
+						     cctx->cc_ptr));
+			m0_be_tx_close_sync(&tx);
+			m0_sm_group_unlock(grp);
+		}
+	}
+
 	M0_LEAVE();
 }
 
-M0_INTERNAL int m0_confstr_parse(const char *s, struct m0_confx **out)
+static size_t confstr_to_obj_size(const char *s)
 {
-	int rc;
+	char buf[1024] = {0};
+	int slen = 0;
+	uint32_t type;
+	uint32_t nr_confx_obj;
+	size_t obj_size = 0;
+	uint32_t conf_objtype_size[M0_CO_NR] = {
+			[M0_CO_PROFILE] = sizeof(struct m0_confx_profile),
+			[M0_CO_FILESYSTEM] = sizeof(struct m0_confx_filesystem),
+			[M0_CO_SERVICE] = sizeof (struct m0_confx_service),
+			[M0_CO_NODE] = sizeof (struct m0_confx_node),
+			[M0_CO_NIC] = sizeof(struct m0_confx_nic),
+			[M0_CO_SDEV] = sizeof(struct m0_confx_sdev),
+			[M0_CO_PARTITION] = sizeof(struct m0_confx_partition)
+	};
+
+	/* calculate size for total number of struct m0_confx_obj */
+	if (*s != '\0' && *s == '[') {
+		s++;
+		sscanf(s, "%u\n", &nr_confx_obj);
+		obj_size += sizeof(struct m0_confx_obj) * nr_confx_obj;
+	}
+
+	while (*s != '\0') {
+		type = 0;
+		conf_objtype_size[0] = 0;
+		if (*s == '{') {
+			s++;
+#ifndef __KERNEL__
+			sscanf(s, "%u\n", &type);
+			printf("%u %u\n", type, conf_objtype_size[type]);
+#endif
+			obj_size += conf_objtype_size[type];
+		}
+		if (*s == '[')
+			obj_size += sizeof(m0_bcount_t);
+		if (*s == '"') {
+			++s;
+			memset(buf, 0, 1024);
+			slen = 0;
+#ifndef __KERNEL__
+			while (*s != '"') {
+				sscanf(s, "%c", &buf[slen]);
+				++slen;
+				++s;
+			}
+			printf("%d %s\n", slen, buf);
+#endif
+			obj_size += slen;
+		}
+			//M0_LOG(M0_FATAL, "%s", (char *)&s[i]);
+		s++;
+		//memset(buf, 0, 1024);
+		//str += result;
+	}
+
+	//if (obj_size != 0)
+	//	obj_size += sizeof(struct m0_confx);
+	return obj_size;
+}
+
+static int confstr_ctx_init(struct confx_ctx *cctx, const char *s,
+			    struct m0_be_seg *seg)
+{
+	struct m0_be_tx_credit  cred = {};
+	struct m0_be_tx         tx;
+	struct m0_sm_group     *grp = m0_locality0_get()->lo_grp;
+	size_t                  obj_size = 0;
+	int                     rc;
+
+	obj_size = confstr_to_obj_size(s);
+	if (obj_size == 0)
+		return -EINVAL;
+	M0_LOG(M0_FATAL, "obj_size: %lu", obj_size);
+	m0_be_allocator_credit(m0_be_seg_allocator(seg), M0_BAO_ALLOC,
+			       obj_size, 0, &cred);
+	m0_sm_group_lock(grp);
+	m0_be_tx_init(&tx, 0, seg->bs_domain, grp, NULL, NULL, NULL, NULL);
+	m0_be_tx_prep(&tx, &cred);
+	rc = m0_be_tx_open_sync(&tx);
+	if (rc != 0) {
+		M0_LOG(M0_FATAL, "rc: %d", rc);
+		M0_ASSERT(rc == 0);
+		M0_RETURN(rc);
+	}
+	M0_BE_OP_SYNC(op, m0_be_alloc(m0_be_seg_allocator(seg), &tx, &op,
+		      &cctx->cc_ptr, obj_size));
+	M0_ASSERT(cctx->cc_ptr != NULL);
+	m0_be_tx_close_sync(&tx);
+	m0_sm_group_unlock(grp);
+	if (cctx->cc_ptr == NULL)
+		return -ENOMEM;
+	cctx->cc_total = obj_size;
+	cctx->cc_used  = 0;
+
+	return 0;
+}
+
+M0_INTERNAL int m0_confstr_parse(const char *s, struct m0_be_seg *seg,
+				 struct m0_confx **out)
+{
+	struct confx_ctx       *cctx = NULL;
+	struct m0_xcode_ctx     ctx;
+	struct m0_xcode_ctx    *xctx;
+	int                     rc;
 
 	M0_ENTRY();
 
-	M0_ALLOC_PTR(*out);
+	M0_SET0(&ctx);
+	if (seg != NULL) {
+		M0_ALLOC_PTR(cctx);
+		if (cctx == NULL)
+			M0_RETURN(-ENOMEM);
+		rc = confstr_ctx_init(cctx, s, seg);
+		if (rc != 0) {
+			m0_free(cctx);
+			M0_RETURN(rc);
+		}
+		xctx = &cctx->cc_xctx;
+		*out = &cctx->cc_confx;//__confx_ctx_alloc(cctx, sizeof(struct m0_confx));
+		M0_LOG(M0_FATAL, "confx: %p cctx->cc_ptr: %p", *out, cctx->cc_ptr);
+	} else {
+		xctx = &ctx;
+		M0_ALLOC_PTR(*out);
+	}
 	if (*out == NULL)
-		M0_RETURN(-ENOMEM);
-
-	rc = m0_xcode_read(&M0_XCODE_OBJ(m0_confx_xc, *out), s);
+		return -ENOMEM;
+	m0_xcode_ctx_init(xctx, &M0_XCODE_OBJ(m0_confx_xc, *out));
+	xctx->xcx_alloc = cctx == NULL ? m0_xcode_alloc : __confx_alloc;
+	rc = m0_xcode_read(xctx, s);
 	if (rc != 0) {
 		M0_ASSERT(rc < 0);
 		M0_LOG(M0_NOTICE, "Cannot parse configuration string:\n%s", s);
-		m0_confx_free(*out);
+		m0_confx_free(*out, seg);
 		*out = NULL;
 	}
+	if (rc == 0)
+		M0_LOG(M0_FATAL, "total: %lu used: %lu", (unsigned long)cctx->cc_total,
+			(unsigned long)cctx->cc_used);
 	M0_RETURN(rc);
 }
 
diff --git a/conf/preload.h b/conf/preload.h
index 64fb8b4..155d228 100644
--- a/conf/preload.h
+++ b/conf/preload.h
@@ -22,6 +22,7 @@
 #define __MERO_CONF_PRELOAD_H__
 
 struct m0_confx;
+struct m0_be_seg;
 
 /**
  * @page conf-fspec-preload Pre-Loading of Configuration Cache
@@ -138,10 +139,11 @@ struct m0_confx;
  *         m0_confx_free(*out);
  * @endcode
  */
-M0_INTERNAL int m0_confstr_parse(const char *s, struct m0_confx **out);
+M0_INTERNAL int m0_confstr_parse(const char *s, struct m0_be_seg *seg,
+				 struct m0_confx **out);
 
 /** Frees the memory, dynamically allocated by m0_confstr_parse(). */
-M0_INTERNAL void m0_confx_free(struct m0_confx *enc);
+M0_INTERNAL void m0_confx_free(struct m0_confx *enc, struct m0_be_seg *seg);
 
 /** @} conf_dfspec_preload */
 #endif /* __MERO_CONF_PRELOAD_H__ */
diff --git a/conf/ut/cache.c b/conf/ut/cache.c
index bedf4c4..584e4e2 100644
--- a/conf/ut/cache.c
+++ b/conf/ut/cache.c
@@ -130,12 +130,12 @@ void test_obj_fill(void)
 	int                 rc;
 	char                buf[1024] = {0};
 
-	m0_confx_free(NULL); /* to make sure this can be done */
+	m0_confx_free(NULL, NULL); /* to make sure this can be done */
 
 	rc = m0_ut_file_read(M0_CONF_UT_PATH("conf_xc.txt"), buf, sizeof buf);
 	M0_UT_ASSERT(rc == 0);
 
-	rc = m0_confstr_parse(buf, &enc);
+	rc = m0_confstr_parse(buf, NULL, &enc);
 	M0_UT_ASSERT(rc == 0);
         M0_UT_ASSERT(enc->cx_nr == 8); /* "conf_xc.txt" describes 8 objects */
 
@@ -150,7 +150,7 @@ void test_obj_fill(void)
 	}
 	m0_mutex_unlock(&g_lock);
 
-	m0_confx_free(enc);
+	m0_confx_free(enc, NULL);
 }
 
 /* ------------------------------------------------------------------ */
diff --git a/conf/ut/db.c b/conf/ut/db.c
index 222ddab..799df5b 100644
--- a/conf/ut/db.c
+++ b/conf/ut/db.c
@@ -244,6 +244,24 @@ static void conf_ut_be_tx_fini(struct m0_be_tx *tx)
         m0_be_tx_close_sync(tx);
         m0_be_tx_fini(tx);
 }
+void test_confstr_parse(void)
+{
+	struct m0_confx        *enc;
+	int                     rc;
+	char                    buf[1024] = {0};
+
+	cleanup();
+
+	conf_ut_db_init();
+
+	rc = m0_ut_file_read(M0_CONF_UT_PATH("conf_xc.txt"), buf, sizeof buf);
+	M0_UT_ASSERT(rc == 0);
+	rc = m0_confstr_parse(buf, seg, &enc);
+	M0_UT_ASSERT(rc == 0);
+	M0_UT_ASSERT(enc->cx_nr == 8);
+	m0_confx_free(enc, seg);
+	m0_confdb_fini(seg);
+}
 
 void test_confdb(void)
 {
@@ -270,20 +288,20 @@ void test_confdb(void)
 
 	cleanup();
 
+	conf_ut_db_init();
+
 	rc = m0_ut_file_read(M0_CONF_UT_PATH("conf_xc.txt"), buf, sizeof buf);
 	M0_UT_ASSERT(rc == 0);
 
-	rc = m0_confstr_parse("[0]", &enc);
+	rc = m0_confstr_parse("[0]", seg, &enc);
 	M0_UT_ASSERT(rc == 0);
 	M0_UT_ASSERT(enc->cx_nr == 0);
-	m0_confx_free(enc);
+	m0_confx_free(enc, seg);
 
-	rc = m0_confstr_parse(buf, &enc);
+	rc = m0_confstr_parse(buf, seg, &enc);
 	M0_UT_ASSERT(rc == 0);
 	M0_UT_ASSERT(enc->cx_nr == 8);
 
-	conf_ut_db_init();
-
 	rc = m0_confdb_create_credit(seg, enc, &accum);
 	M0_UT_ASSERT(rc == 0);
 	rc = conf_ut_be_tx_create(&tx, &ut_be, &accum);
@@ -308,7 +326,7 @@ void test_confdb(void)
 	M0_UT_ASSERT(enc->cx_nr == ARRAY_SIZE(tests));
 	for (i = 0; i < ARRAY_SIZE(tests); ++i)
 		tests[i].check(&dec->cx_objs[i]);
-	m0_confx_free(enc);
+	m0_confx_free(enc, seg);
 	m0_confdb_fini(seg);
 	M0_SET0(&accum);
 	rc = m0_confdb_destroy_credit(seg, &accum);
diff --git a/conf/ut/fuzz.c b/conf/ut/fuzz.c
index 0d090ce..e6820c9 100644
--- a/conf/ut/fuzz.c
+++ b/conf/ut/fuzz.c
@@ -27,6 +27,7 @@
 #include "ut/ut.h"
 
 extern void test_confdb(void);
+extern void test_confstr_parse(void);
 
 /** Statistics accumulator for m0_confstr_parse() call. */
 struct fuzz_acc {
@@ -159,9 +160,9 @@ _fuzz_test(const char *conf_str, char what, char by, bool eq, size_t nr_subs,
 			if (sample == NULL)
 				continue;
 
-			rc = m0_confstr_parse(sample, &enc);
+			rc = m0_confstr_parse(sample, NULL, &enc);
 			if (unlikely(rc == 0)) {
-				m0_confx_free(enc);
+				m0_confx_free(enc, NULL);
 				++acc->nr_successes;
 			}
 			++acc->nr_total;
@@ -230,6 +231,7 @@ const struct m0_test_suite confstr_ut = {
 	.ts_init  = NULL,
 	.ts_fini  = NULL,
 	.ts_tests = {
+		{"str",   test_confstr_parse},
 		{ "db",   test_confdb       },
 		{ "fuzz", test_confstr_fuzz },
 		{ NULL, NULL }
diff --git a/console/console.c b/console/console.c
index 890d5af..9d3fc9a 100644
--- a/console/console.c
+++ b/console/console.c
@@ -76,6 +76,7 @@ static int fop_send_and_print(struct m0_rpc_client_ctx *cctx, uint32_t opcode,
 	struct m0_rpc_item *item;
 	struct m0_fop	   *fop;
 	struct m0_fop	   *rfop;
+	struct m0_xcode_ctx ctx;
 	int		    rc;
 
 	ftype = m0_fop_type_find(opcode);
@@ -88,7 +89,8 @@ static int fop_send_and_print(struct m0_rpc_client_ctx *cctx, uint32_t opcode,
 		return -EINVAL;
 
 	if (fop_input != NULL) {
-		rc = m0_xcode_read(&M0_FOP_XCODE_OBJ(fop), fop_input);
+		m0_xcode_ctx_init(&ctx, &M0_FOP_XCODE_OBJ(fop));
+		rc = m0_xcode_read(&ctx, fop_input);
 		if (rc != 0)
 			return rc;
 	} else {
diff --git a/xcode/string.c b/xcode/string.c
index e93d6dd..8ff882a 100644
--- a/xcode/string.c
+++ b/xcode/string.c
@@ -98,10 +98,10 @@ static int char_check(const char **str, char ch)
 	return result;
 }
 
-M0_INTERNAL int m0_xcode_read(struct m0_xcode_obj *obj, const char *str)
+M0_INTERNAL int m0_xcode_read(struct m0_xcode_ctx *ctx, const char *str)
 {
-	struct m0_xcode_cursor it;
-	int                    result;
+	struct m0_xcode_cursor *it = &ctx->xcx_it;
+	int                     result;
 
 	static const char structure[M0_XA_NR][M0_XCODE_CURSOR_NR] = {
 		               /* NONE  PRE   IN POST */
@@ -132,10 +132,10 @@ M0_INTERNAL int m0_xcode_read(struct m0_xcode_obj *obj, const char *str)
 	M0_CASSERT(sizeof(uint64_t) == sizeof(unsigned long));
 	M0_CASSERT(sizeof(uint32_t) == sizeof(unsigned));
 
-	m0_xcode_cursor_init(&it, obj);
+	//m0_xcode_cursor_init(&it, obj);
 
-	while ((result = m0_xcode_next(&it)) > 0) {
-		struct m0_xcode_cursor_frame *top  = m0_xcode_cursor_top(&it);
+	while ((result = m0_xcode_next(it)) > 0) {
+		struct m0_xcode_cursor_frame *top  = m0_xcode_cursor_top(it);
 		struct m0_xcode_obj          *cur  = &top->s_obj;
 		enum m0_xcode_cursor_flag     flag = top->s_flag;
 		const struct m0_xcode_type   *xt   = cur->xo_type;
@@ -143,10 +143,10 @@ M0_INTERNAL int m0_xcode_read(struct m0_xcode_obj *obj, const char *str)
 
 		str = space_skip(str);
 		if (flag == M0_XCODE_CURSOR_PRE) {
-			result = m0_xcode_alloc_obj(&it, m0_xcode_alloc);
+			result = m0_xcode_alloc_obj(it, ctx->xcx_alloc);
 			if (result != 0)
 				return result;
-			if (it.xcu_depth > 0) {
+			if (it->xcu_depth > 0) {
 				int                           order;
 				enum m0_xcode_aggr            par;
 				struct m0_xcode_cursor_frame *pre = top - 1;
@@ -165,7 +165,7 @@ M0_INTERNAL int m0_xcode_read(struct m0_xcode_obj *obj, const char *str)
 				if (result < 0)
 					return result;
 				str += result + 1;
-				m0_xcode_skip(&it);
+				m0_xcode_skip(it);
 				continue;
 			}
 		}
diff --git a/xcode/ut/xcode.c b/xcode/ut/xcode.c
index 4ff1a8b..bcdcd6c 100644
--- a/xcode/ut/xcode.c
+++ b/xcode/ut/xcode.c
@@ -587,78 +587,109 @@ static void xcode_read_test(void)
 	struct un  U;
 	struct v   V;
 	struct top T;
+	struct m0_xcode_ctx ctx;
 
 	M0_SET0(&F);
-	result = m0_xcode_read(OBJ(&xut_foo.xt, &F), "(10, 0xff)");
+	M0_SET0(&ctx);
+	m0_xcode_ctx_init(&ctx, OBJ(&xut_foo.xt, &F));
+	result = m0_xcode_read(&ctx, "(10, 0xff)");
 	M0_UT_ASSERT(result == 0);
 	M0_UT_ASSERT(F.f_x == 10);
 	M0_UT_ASSERT(F.f_y == 0xff);
 
 	M0_SET0(&F);
-	result = m0_xcode_read(OBJ(&xut_foo.xt, &F), " ( 10 , 0xff ) ");
+	M0_SET0(&ctx);
+	m0_xcode_ctx_init(&ctx, OBJ(&xut_foo.xt, &F));
+	result = m0_xcode_read(&ctx, " ( 10 , 0xff ) ");
 	M0_UT_ASSERT(result == 0);
 	M0_UT_ASSERT(F.f_x == 10);
 	M0_UT_ASSERT(F.f_y == 0xff);
 
 	M0_SET0(&F);
-	result = m0_xcode_read(OBJ(&xut_foo.xt, &F), "(10,010)");
+	M0_SET0(&ctx);
+	m0_xcode_ctx_init(&ctx, OBJ(&xut_foo.xt, &F));
+	result = m0_xcode_read(&ctx, "(10,010)");
 	M0_UT_ASSERT(result == 0);
 	M0_UT_ASSERT(F.f_x == 10);
 	M0_UT_ASSERT(F.f_y == 8);
 
 	M0_SET0(&F);
-	result = m0_xcode_read(OBJ(&xut_foo.xt, &F), " ( 10 , 0xff ) rest");
+	M0_SET0(&ctx);
+	m0_xcode_ctx_init(&ctx, OBJ(&xut_foo.xt, &F));
+	result = m0_xcode_read(&ctx, " ( 10 , 0xff ) rest");
 	M0_UT_ASSERT(result == -EINVAL);
 
 	M0_SET0(&F);
-	result = m0_xcode_read(OBJ(&xut_foo.xt, &F), "(10,)");
+	M0_SET0(&ctx);
+	m0_xcode_ctx_init(&ctx, OBJ(&xut_foo.xt, &F));
+	result = m0_xcode_read(&ctx, "(10,)");
 	M0_UT_ASSERT(result == -EPROTO);
 
 	M0_SET0(&F);
-	result = m0_xcode_read(OBJ(&xut_foo.xt, &F), "(10 12)");
+	M0_SET0(&ctx);
+	m0_xcode_ctx_init(&ctx, OBJ(&xut_foo.xt, &F));
+	result = m0_xcode_read(&ctx, "(10 12)");
 	M0_UT_ASSERT(result == -EPROTO);
 
 	M0_SET0(&F);
-	result = m0_xcode_read(OBJ(&xut_foo.xt, &F), "()");
+	M0_SET0(&ctx);
+	m0_xcode_ctx_init(&ctx, OBJ(&xut_foo.xt, &F));
+	result = m0_xcode_read(&ctx, "()");
 	M0_UT_ASSERT(result == -EPROTO);
 
 	M0_SET0(&F);
-	result = m0_xcode_read(OBJ(&xut_foo.xt, &F), "");
+	M0_SET0(&ctx);
+	m0_xcode_ctx_init(&ctx, OBJ(&xut_foo.xt, &F));
+	result = m0_xcode_read(&ctx, "");
 	M0_UT_ASSERT(result == -EPROTO);
 
 	M0_SET0(&U);
-	result = m0_xcode_read(OBJ(&xut_un.xt, &U), "{1| 42}");
+	M0_SET0(&ctx);
+	m0_xcode_ctx_init(&ctx, OBJ(&xut_un.xt, &U));
+	result = m0_xcode_read(&ctx, "{1| 42}");
 	M0_UT_ASSERT(result == 0);
 	M0_UT_ASSERT(U.u_tag == 1);
 	M0_UT_ASSERT(U.u.u_x == 42);
 
 	M0_SET0(&U);
-	result = m0_xcode_read(OBJ(&xut_un.xt, &U), "{4| 8}");
+	M0_SET0(&ctx);
+	m0_xcode_ctx_init(&ctx, OBJ(&xut_un.xt, &U));
+	result = m0_xcode_read(&ctx, "{4| 8}");
 	M0_UT_ASSERT(result == 0);
 	M0_UT_ASSERT(U.u_tag == 4);
 	M0_UT_ASSERT(U.u.u_y == 8);
 
 	M0_SET0(&U);
-	result = m0_xcode_read(OBJ(&xut_un.xt, &U), "{3| 0}");
+	M0_SET0(&ctx);
+	m0_xcode_ctx_init(&ctx, OBJ(&xut_un.xt, &U));
+	result = m0_xcode_read(&ctx, "{3| 0}");
 	M0_UT_ASSERT(result == -EPROTO);
 
 	M0_SET0(&U);
-	result = m0_xcode_read(OBJ(&xut_un.xt, &U), "{3}");
+	M0_SET0(&ctx);
+	m0_xcode_ctx_init(&ctx, OBJ(&xut_un.xt, &U));
+	result = m0_xcode_read(&ctx, "{3}");
 	M0_UT_ASSERT(result == 0);
 	M0_UT_ASSERT(U.u_tag == 3);
 
 	M0_SET0(&V);
-	result = m0_xcode_read(OBJ(&xut_v.xt, &V), "[0]");
+	M0_SET0(&ctx);
+	m0_xcode_ctx_init(&ctx, OBJ(&xut_v.xt, &V));
+	result = m0_xcode_read(&ctx, "[0]");
 	M0_UT_ASSERT(result == 0);
 	M0_UT_ASSERT(V.v_nr == 0);
 
 	M0_SET0(&V);
-	result = m0_xcode_read(OBJ(&xut_v.xt, &V), "[1: 42]");
+	M0_SET0(&ctx);
+	m0_xcode_ctx_init(&ctx, OBJ(&xut_v.xt, &V));
+	result = m0_xcode_read(&ctx, "[1: 42]");
 	M0_UT_ASSERT(result == 0);
 	M0_UT_ASSERT(V.v_nr == 1);
 	M0_UT_ASSERT(V.v_data[0] == 42);
 
-	result = m0_xcode_read(OBJ(&xut_v.xt, &V), "[3: 42, 43, 44]");
+	M0_SET0(&ctx);
+	m0_xcode_ctx_init(&ctx, OBJ(&xut_v.xt, &V));
+	result = m0_xcode_read(&ctx, "[3: 42, 43, 44]");
 	M0_UT_ASSERT(result == 0);
 	M0_UT_ASSERT(V.v_nr == 3);
 	M0_UT_ASSERT(V.v_data[0] == 42);
@@ -666,28 +697,38 @@ static void xcode_read_test(void)
 	M0_UT_ASSERT(V.v_data[2] == 44);
 
 	M0_SET0(&V);
-	result = m0_xcode_read(OBJ(&xut_v.xt, &V), "\"a\"");
+	M0_SET0(&ctx);
+	m0_xcode_ctx_init(&ctx, OBJ(&xut_v.xt, &V));
+	result = m0_xcode_read(&ctx, "\"a\"");
 	M0_UT_ASSERT(result == 0);
 	M0_UT_ASSERT(V.v_nr == 1);
 	M0_UT_ASSERT(strncmp(V.v_data, "a", 1) == 0);
 
 	M0_SET0(&V);
-	result = m0_xcode_read(OBJ(&xut_v.xt, &V), "\"abcdef\"");
+	M0_SET0(&ctx);
+	m0_xcode_ctx_init(&ctx, OBJ(&xut_v.xt, &V));
+	result = m0_xcode_read(&ctx, "\"abcdef\"");
 	M0_UT_ASSERT(result == 0);
 	M0_UT_ASSERT(V.v_nr == 6);
 	M0_UT_ASSERT(strncmp(V.v_data, "abcdef", 6) == 0);
 
 	M0_SET0(&V);
-	result = m0_xcode_read(OBJ(&xut_v.xt, &V), "\"\"");
+	M0_SET0(&ctx);
+	m0_xcode_ctx_init(&ctx, OBJ(&xut_v.xt, &V));
+	result = m0_xcode_read(&ctx, "\"\"");
 	M0_UT_ASSERT(result == 0);
 	M0_UT_ASSERT(V.v_nr == 0);
 
 	M0_SET0(&V);
-	result = m0_xcode_read(OBJ(&xut_v.xt, &V), "\"");
+	M0_SET0(&ctx);
+	m0_xcode_ctx_init(&ctx, OBJ(&xut_v.xt, &V));
+	result = m0_xcode_read(&ctx, "\"");
 	M0_UT_ASSERT(result == -EPROTO);
 
 	M0_SET0(&T);
-	result = m0_xcode_read(OBJ(&xut_top.xt, &T), ""
+	M0_SET0(&ctx);
+	m0_xcode_ctx_init(&ctx, OBJ(&xut_top.xt, &T));
+	result = m0_xcode_read(&ctx, ""
 "((1, 2),"
 " 8,"
 " [4: 1, 2, 3, 4],"
diff --git a/xcode/xcode.h b/xcode/xcode.h
index 931439f..7cb2c64 100644
--- a/xcode/xcode.h
+++ b/xcode/xcode.h
@@ -636,7 +636,7 @@ m0_xcode_alloc_obj(struct m0_xcode_cursor *it,
  * Error or not, the caller should free the (partially) constructed object with
  * m0_xcode_free().
  */
-M0_INTERNAL int m0_xcode_read(struct m0_xcode_obj *obj, const char *str);
+M0_INTERNAL int m0_xcode_read(struct m0_xcode_ctx *ctx, const char *str);
 M0_INTERNAL void m0_xcode_free(struct m0_xcode_obj *obj);
 M0_INTERNAL int m0_xcode_cmp(const struct m0_xcode_obj *o0,
 			     const struct m0_xcode_obj *o1);
-- 
1.8.3.2

