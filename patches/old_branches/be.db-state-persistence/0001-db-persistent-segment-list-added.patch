From 900b664a3083b2397e2c6cac11efeb3790da0098 Mon Sep 17 00:00:00 2001
From: Maxim Medved <max_medved@xyratex.com>
Date: Wed, 4 Dec 2013 20:56:02 +0200
Subject: [PATCH 1/2] db: persistent segment list added

---
 be/ut/helper.c | 123 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 be/ut/helper.h |  10 +++++
 be/ut/main.c   |   3 ++
 db/db.c        |  60 ++++++++++++++++++++++++++++
 4 files changed, 196 insertions(+)

diff --git a/be/ut/helper.c b/be/ut/helper.c
index a7c6e91..2ed28f3 100644
--- a/be/ut/helper.c
+++ b/be/ut/helper.c
@@ -49,6 +49,8 @@ enum {
 	BE_UT_SEG_START_ID   = 42ULL,
 };
 
+static const char *be_ut_seg_state = "be_ut_seg_state.txt";
+
 struct m0_be_ut_sm_group_thread {
 	struct m0_thread    sgt_thread;
 	pid_t		    sgt_tid;
@@ -76,6 +78,26 @@ struct be_ut_helper_struct be_ut_helper = {
 };
 
 
+static void be_ut_seg_state_save(struct be_ut_helper_struct *h)
+{
+	m0_be_ut_state_save(be_ut_seg_state,
+			    LAMBDA(bool, (FILE *f, int *state) {
+				   fprintf(f, "%p %"PRIu64"\n",
+					   h->buh_addr, h->buh_id);
+				   return false;
+				   }));
+}
+
+static void be_ut_seg_state_tryload(struct be_ut_helper_struct *h)
+{
+	m0_be_ut_state_tryload(be_ut_seg_state,
+			       LAMBDA(bool, (FILE *f, int *state) {
+				      fscanf(f, "%p %"SCNu64"\n",
+					     &h->buh_addr, &h->buh_id);
+				      return false;
+				      }));
+}
+
 static void *be_ut_seg_allocate_addr(struct be_ut_helper_struct *h,
 				     m0_bcount_t size)
 {
@@ -86,8 +108,10 @@ static void *be_ut_seg_allocate_addr(struct be_ut_helper_struct *h,
 	m0_mutex_lock(&h->buh_seg_lock);
 	addr	     = h->buh_addr;
 	h->buh_addr += size;
+	be_ut_seg_state_save(h);
 	m0_mutex_unlock(&h->buh_seg_lock);
 
+
 	return addr;
 }
 
@@ -97,6 +121,7 @@ static uint64_t be_ut_seg_allocate_id(struct be_ut_helper_struct *h)
 
 	m0_mutex_lock(&h->buh_seg_lock);
 	id = h->buh_id++;
+	be_ut_seg_state_save(h);
 	m0_mutex_unlock(&h->buh_seg_lock);
 
 	return id;
@@ -124,6 +149,7 @@ static void be_ut_helper_init(void)
 	h->buh_id	       = BE_UT_SEG_START_ID,
 	m0_mutex_init(&h->buh_seg_lock);
 	m0_mutex_init(&h->buh_reqh_lock);
+	be_ut_seg_state_tryload(h);
 	atexit(&be_ut_helper_fini);	/* XXX REFACTORME */
 }
 
@@ -724,6 +750,103 @@ M0_INTERNAL void m0_be_ut_txc_fini(struct m0_be_ut_txc *tc)
 	m0_buf_free(&tc->butc_seg_copy);
 }
 
+M0_INTERNAL void m0_be_ut_state_save(const char *filename,
+				     bool (*func)(FILE *f, int *state))
+{
+	FILE *f;
+	int   rc;
+	char  tmpfilename[0x100];
+	int   state;
+
+	rc = snprintf(tmpfilename, ARRAY_SIZE(tmpfilename), "%s.TMP", filename);
+	M0_ASSERT_INFO(rc < ARRAY_SIZE(tmpfilename), "rc = %d", rc);
+
+	f = fopen(tmpfilename, "w");
+	M0_ASSERT_INFO(f != NULL, "can't open file %s: errno = %d",
+		       tmpfilename, errno);
+
+	state = 0;
+	while (func(f, &state))
+		;
+
+	rc = fclose(f);
+	M0_ASSERT_INFO(rc == 0, "can't close file %s: errno = %d",
+		       tmpfilename, errno);
+
+	/*
+	 * Don't write directly to the seg_map_file to prevent file corruption
+	 * if process is killed between fopen() and fclose() in this function.
+	 * mv will replace the file atomically (see rename(2) for reference).
+	 */
+	rc = rename(tmpfilename, filename);
+	M0_ASSERT_INFO(rc == 0, "rename(%s, %s) failed: rc = %d",
+		       tmpfilename, filename, rc);
+}
+
+M0_INTERNAL void m0_be_ut_state_tryload(const char *filename,
+					bool (*func)(FILE *f, int *state))
+{
+	FILE *f;
+	int   rc;
+	int   state;
+
+	f = fopen(filename, "r");
+	if (f != NULL) {
+		state = 0;
+		while (func(f, &state))
+			;
+
+		rc = fclose(f);
+		M0_ASSERT_INFO(rc == 0, "can't close file %s: errno = %d",
+			       filename, errno);
+	} else {
+		M0_LOG(M0_NOTICE, "can't open file %s: errno = %d",
+		       filename, errno);
+	}
+}
+
+enum {
+	BE_UT_HELPER_STATE_NR = 0x100,
+};
+
+static const char *be_ut_helper_state_filename = "be-ut.helper-state.txt";
+
+M0_INTERNAL void m0_be_ut_helper_state(void)
+{
+	uint64_t a[BE_UT_HELPER_STATE_NR];
+	uint64_t b[BE_UT_HELPER_STATE_NR];
+	uint64_t zero_arr[BE_UT_HELPER_STATE_NR];
+	uint64_t seed = 0;
+	int	 i;
+	int	 rc;
+
+	for (i = 0; i < ARRAY_SIZE(a); ++i)
+		a[i] = m0_rnd(1UL << 32, &seed);
+	M0_SET_ARR0(b);
+	M0_SET_ARR0(zero_arr);
+
+	for (i = 0; i < 2; ++i) {
+		m0_be_ut_state_tryload(be_ut_helper_state_filename,
+				       LAMBDA(bool, (FILE *f, int *state) {
+					      return fscanf(f, "%"SCNu64"\n",
+							 &b[(*state)++]) != EOF;
+					      }));
+		rc = memcmp(b, zero_arr, sizeof b);
+		M0_ASSERT_INFO(equi(rc == 0, i == 0), "rc = %d, i = %d", rc, i);
+		rc = memcmp(b, a, sizeof b);
+		M0_ASSERT_INFO(equi(rc == 0, i != 0), "rc = %d, i = %d", rc, i);
+
+		m0_be_ut_state_save(be_ut_helper_state_filename,
+				    LAMBDA(bool, (FILE *f, int *state) {
+					   if (i == 1)
+						return false;
+					   fprintf(f, "%"PRIu64"\n",
+						   a[(*state)++]);
+					   return *state < ARRAY_SIZE(a);
+					   }));
+	}
+}
+
 #undef M0_TRACE_SUBSYSTEM
 
 /*
diff --git a/be/ut/helper.h b/be/ut/helper.h
index 3dc1959..eb0b1b5 100644
--- a/be/ut/helper.h
+++ b/be/ut/helper.h
@@ -22,6 +22,10 @@
 #ifndef __MERO_BE_UT_HELPER_H__
 #define __MERO_BE_UT_HELPER_H__
 
+#ifndef __KERNEL__
+#include <stdio.h>		/* FILE */
+#endif
+
 #include "lib/types.h"		/* bool */
 #include "lib/buf.h"		/* m0_buf */
 #include "sm/sm.h"		/* m0_sm */
@@ -165,6 +169,12 @@ M0_INTERNAL int m0_be_ut__seg_dict_create(struct m0_be_seg   *seg,
 M0_INTERNAL int m0_be_ut__seg_dict_destroy(struct m0_be_seg   *seg,
 					   struct m0_sm_group *grp);
 
+#ifndef __KERNEL__
+M0_INTERNAL void m0_be_ut_state_save(const char *filename,
+				     bool (*func)(FILE *f, int *state));
+M0_INTERNAL void m0_be_ut_state_tryload(const char *filename,
+					bool (*func)(FILE *f, int *state));
+#endif
 
 #endif /* __MERO_BE_UT_HELPER_H__ */
 
diff --git a/be/ut/main.c b/be/ut/main.c
index b44a67c..fac395c 100644
--- a/be/ut/main.c
+++ b/be/ut/main.c
@@ -69,6 +69,8 @@ extern void m0_be_ut_btree_simple(void);
 extern void m0_be_ut_emap(void);
 extern void m0_be_ut_seg_dict(void);
 
+extern void m0_be_ut_helper_state(void);
+
 
 const struct m0_test_suite be_ut = {
 	.ts_name = "be-ut",
@@ -109,6 +111,7 @@ const struct m0_test_suite be_ut = {
 		{ "btree",               m0_be_ut_btree_simple         },
 		{ "seg_dict",            m0_be_ut_seg_dict             },
 		{ "emap",                m0_be_ut_emap                 },
+		{ "helper-state",	 m0_be_ut_helper_state         },
 		{ NULL, NULL }
 	}
 };
diff --git a/db/db.c b/db/db.c
index 9023413..6fd62e5 100644
--- a/db/db.c
+++ b/db/db.c
@@ -75,6 +75,8 @@ enum {
 	SEG_SIZE	 = 1UL << 26,
 };
 
+static const char *seg_map_file	    = "./seg_map.txt";
+
 struct seg_map_item {
 	char		    *smi_name;
 	uint64_t	     smi_stob_id;
@@ -140,6 +142,56 @@ static struct seg_map_item *seg_map_lookup_ut_seg(struct m0_be_ut_seg *ut_seg)
 	return smi;
 }
 
+static bool seg_map_save_item(FILE *f, int *state)
+{
+	struct seg_map_item *smi;
+	int		     rc;
+
+	if (seg_map_size == 0)
+		return false;
+	smi = &seg_map[(*state)++];
+	if (!smi->smi_reset) {
+		rc = fprintf(f, "%s %"PRIu64" %p\n",
+			     smi->smi_name, smi->smi_stob_id,
+			     smi->smi_seg_addr);
+		M0_ASSERT_INFO(rc > 0, "rc = %d", rc);
+	}
+
+	return *state < seg_map_size;
+}
+
+static void seg_map_save(void)
+{
+	seg_map_lock();
+	m0_be_ut_state_save(seg_map_file, &seg_map_save_item);
+	seg_map_unlock();
+}
+
+static bool seg_map_tryload_item(FILE *f, int *state)
+{
+	uint64_t  stob_id;
+	char	  name[0x100];	/* XXX possible problem here */
+	void	 *seg_addr;
+	int	  rc;
+
+	rc = fscanf(f, "%s %"SCNu64" %p\n", name, &stob_id, &seg_addr);
+	if (rc != EOF) {
+		M0_ASSERT_INFO(rc == 3, "invalid format: rc = %d", rc);
+		seg_map_add(name, stob_id, seg_addr, NULL);
+	}
+	return rc != EOF;
+}
+
+static void seg_map_tryload(void)
+{
+	M0_ASSERT_INFO(seg_map_size == 0,
+		       "This function should be called before the first "
+		       "m0_dbenv_init() call. seg_map_size = %d", seg_map_size);
+	seg_map_lock();
+	m0_be_ut_state_tryload(seg_map_file, &seg_map_tryload_item);
+	seg_map_unlock();
+}
+
 static void dbenv_seg_init(struct m0_be_ut_seg *ut_seg,
 			   struct m0_be_ut_backend *ut_be,
 			   const char *name)
@@ -178,6 +230,8 @@ static void dbenv_seg_init(struct m0_be_ut_seg *ut_seg,
 	smi = seg_map_lookup(name);
 	smi->smi_reset = false;
 	smi->smi_ut_seg = ut_seg;
+
+	seg_map_save();
 }
 
 static void dbenv_seg_fini(struct m0_be_ut_seg *ut_seg)
@@ -186,6 +240,8 @@ static void dbenv_seg_fini(struct m0_be_ut_seg *ut_seg)
 	struct m0_stob	    *stob = ut_seg->bus_seg.bs_stob;
 	// int		     rc;
 
+	seg_map_save();
+
 	M0_ASSERT(smi != NULL);
 	smi->smi_ut_seg = NULL;
 
@@ -206,6 +262,8 @@ static void dbenv_seg_reset(const char *name)
 	if (smi != NULL) {
 		M0_ASSERT(smi->smi_ut_seg == NULL);
 		smi->smi_reset = true;
+
+		seg_map_save();
 	}
 }
 
@@ -797,6 +855,7 @@ M0_INTERNAL int m0_db_init(void)
 			 &m0_addb_ct_db_mod, &m0_addb_proc_ctx);
 	m0_xc_extmap_init();
 	m0_mutex_init(&seg_map_lock_);
+	seg_map_tryload();
 	return 0;
 }
 
@@ -804,6 +863,7 @@ M0_INTERNAL void m0_db_fini(void)
 {
 	int i;
 
+	seg_map_save();
 	for (i = 0; i < seg_map_size; ++i)
 		m0_free(seg_map[i].smi_name);
 	m0_mutex_fini(&seg_map_lock_);
-- 
1.8.3.2

