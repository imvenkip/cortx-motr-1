From fbe51e176b2de1385e9941ef6d6d73d9bb9e994f Mon Sep 17 00:00:00 2001
From: Maxim Medved <max_medved@xyratex.com>
Date: Wed, 20 Nov 2013 01:40:49 +0200
Subject: [PATCH 17/26] be/allocator: capture chunk size and not entire chunk

---
 be/alloc.c | 44 +++++++++++++-------------------------------
 1 file changed, 13 insertions(+), 31 deletions(-)

diff --git a/be/alloc.c b/be/alloc.c
index 6c22abf..ab9bfd6 100644
--- a/be/alloc.c
+++ b/be/alloc.c
@@ -210,29 +210,11 @@ static void be_alloc_free_flag_capture(struct m0_be_allocator *a,
 	M0_BE_TX_CAPTURE_PTR(a->ba_seg, tx, &c->bac_free);
 }
 
-/*
 static void be_alloc_size_capture(struct m0_be_allocator *a,
 				  struct m0_be_tx *tx,
 				  struct be_alloc_chunk *c)
 {
-	if (c != NULL)
-		M0_BE_TX_CAPTURE_PTR(a->ba_seg, tx, &c->bac_size);
-}
-*/
-
-static void chunks_all_tlist_capture_around(struct m0_be_allocator *a,
-					    struct m0_be_tx *tx,
-					    struct be_alloc_chunk *c)
-{
-	struct be_alloc_chunk *cprev;
-	struct be_alloc_chunk *cnext;
-
-	cprev = chunks_all_tlist_prev(&a->ba_h->bah_chunks.bl_list, c);
-	cnext = chunks_all_tlist_next(&a->ba_h->bah_chunks.bl_list, c);
-	be_alloc_chunk_capture(a, tx, c);
-	be_alloc_chunk_capture(a, tx, cprev);
-	be_alloc_chunk_capture(a, tx, cnext);
-	be_alloc_head_capture(a, tx);
+	M0_BE_TX_CAPTURE_PTR(a->ba_seg, tx, &c->bac_size);
 }
 
 static bool be_alloc_is_mem_in_allocator(struct m0_be_allocator *a,
@@ -475,9 +457,10 @@ be_alloc_chunk_split(struct m0_be_allocator *a,
 
 	if (chunk0_size <= chunk_size) {
 		/* no space for chunk0 */
-		if (prev != NULL)
+		if (prev != NULL) {
 			prev->bac_size += chunk0_size;
-		else
+			be_alloc_size_capture(a, tx, prev);
+		} else
 			; /* space before the first chunk is temporary lost */
 	} else {
 		prev_free = be_alloc_chunk_add_after(a, tx, prev, prev_free,
@@ -494,15 +477,11 @@ be_alloc_chunk_split(struct m0_be_allocator *a,
 	if (chunk1_size <= chunk_size) {
 		/* no space for chunk1 */
 		new->bac_size += chunk1_size;
+		be_alloc_size_capture(a, tx, new);
 	} else {
 		be_alloc_chunk_add_after(a, tx, new, prev_free,
 					 0, chunk1_size, true);
 	}
-	/*
-	 * XXX capture all chunks around the new in case if nearest chunks
-	 * size was changed.
-	 */
-	chunks_all_tlist_capture_around(a, tx, new);
 
 	M0_POST(!new->bac_free);
 	M0_POST(new->bac_size >= size);
@@ -557,7 +536,7 @@ static bool be_alloc_chunk_trymerge(struct m0_be_allocator *a,
 		y_size_total = sizeof(*y) + y->bac_size;
 		be_alloc_chunk_del_fini(a, tx, y);
 		x->bac_size += y_size_total;
-		be_alloc_chunk_capture(a, tx, x);
+		be_alloc_size_capture(a, tx, x);
 		chunks_were_merged = true;
 	}
 	M0_POST(ergo(x != NULL, be_alloc_chunk_invariant(a, x)));
@@ -693,6 +672,7 @@ M0_INTERNAL void m0_be_allocator_credit(struct m0_be_allocator *a,
 	struct m0_be_tx_credit chunk_del_fini_credit = {};
 	struct m0_be_tx_credit chunk_trymerge_credit = {};
 	struct m0_be_tx_credit cred_mark_free = {};
+	struct m0_be_tx_credit cred_split = {};
 	struct m0_be_tx_credit mem_zero_credit = {};
 	struct m0_be_tx_credit chunk_credit;
 	struct m0_be_tx_credit header_credit;
@@ -733,7 +713,11 @@ M0_INTERNAL void m0_be_allocator_credit(struct m0_be_allocator *a,
 	chunk_del_fini_credit = tmp;
 
 	m0_be_tx_credit_add(&chunk_trymerge_credit, &chunk_del_fini_credit);
-	m0_be_tx_credit_add(&chunk_trymerge_credit, &chunk_credit);
+	m0_be_tx_credit_add(&chunk_trymerge_credit, &cred_chunk_size);
+
+	m0_be_tx_credit_add(&cred_split, &chunk_del_fini_credit);
+	m0_be_tx_credit_mac(&cred_split, &cred_chunk_size, 2);
+	m0_be_tx_credit_mac(&cred_split, &chunk_add_after_credit, 3);
 
 	m0_be_list_credit(free, M0_BLO_INSERT, 1, &cred_mark_free);
 	m0_be_tx_credit_add(&cred_mark_free, &cred_free_flag);
@@ -750,9 +734,7 @@ M0_INTERNAL void m0_be_allocator_credit(struct m0_be_allocator *a,
 			m0_be_tx_credit_mac(accum, &cred_list_destroy, 2);
 			break;
 		case M0_BAO_ALLOC_ALIGNED:
-			m0_be_tx_credit_add(accum, &chunk_del_fini_credit);
-			m0_be_tx_credit_mac(accum, &chunk_add_after_credit, 3);
-			m0_be_tx_credit_add(accum, &capture_around_credit);
+			m0_be_tx_credit_add(accum, &cred_split);
 			m0_be_tx_credit_add(accum, &mem_zero_credit);
 			break;
 		case M0_BAO_ALLOC:
-- 
1.8.3.2

