From 00a7a52b189dcaf2e45a38db933baf8550a78924 Mon Sep 17 00:00:00 2001
From: Yuriy Umanets <yuriy_umanets@xyratex.com>
Date: Fri, 25 Feb 2011 04:02:10 -0700
Subject: [PATCH 014/158] - reworked c2_cob_link(). It now has simplified
 interface: stat data cob, name key and tx. Use it from c2_cob_create() which
 hot some parts of origin link, mostly allocating cob which how it should have
 been from the very beginning; - corresponding fixes in c2_md_store_link(); -
 stab for sanity checks in c2_md_store_rename().

---
 cob/cob.c         | 177 +++++++++++++++++++++++++-----------------------------
 cob/cob.h         |  19 +++---
 mdstore/mdstore.c |  47 +++++++++++----
 3 files changed, 127 insertions(+), 116 deletions(-)

diff --git a/cob/cob.c b/cob/cob.c
index 9afe638..6f634b4 100644
--- a/cob/cob.c
+++ b/cob/cob.c
@@ -468,148 +468,115 @@ C2_ADDB_EV_DEFINE(cob_delete,  "md_delete",  0x6, C2_ADDB_FLAG);
 C2_ADDB_EV_DEFINE(cob_rename,  "md_rename",  0x7, C2_ADDB_FLAG);
 C2_ADDB_EV_DEFINE(cob_setattr, "md_setattr", 0x8, C2_ADDB_FLAG);
 
+/** 
+   For assertions only.
+*/
+static bool c2_cob_is_valid(struct c2_cob *cob)
+{
+        return c2_stob_id_is_set(&cob->co_stobid);
+}
 
 /**
-   Add a new cob name to the namespace. This takes a reference on 
-   the cob in-memory struct.
+   Create name, update object index and nlink in "zero" name
+   statdata.
    
+   cob   - stat data (zero name) cob;
+   nskey - new name to add to the file;
+   tx    - transaction handle.
+
    @todo: Update {a|c|m}time in pfid and tfid
 */
-int c2_cob_link(struct c2_cob_domain *dom,
+int c2_cob_link(struct c2_cob        *cob,
                 struct c2_cob_nskey  *nskey,
-                struct c2_cob_nsrec  *nsrec,
-                uint64_t              need,
-                struct c2_cob       **out,
                 struct c2_db_tx      *tx)
 {
-        struct c2_cob      *cob;
-        struct c2_cob      *cob0;
         struct c2_cob_oikey oikey;
         struct c2_db_pair   pair;
+        struct c2_cob_nsrec nsrec;
         int                 nlink;
 	int                 rc;
 
+        C2_PRE(cob != NULL);
         C2_PRE(nskey != NULL);
-        C2_PRE(nsrec != NULL);
-	C2_PRE(c2_stob_id_is_set(&nsrec->cnr_stobid));
         C2_PRE(c2_stob_id_is_set(&nskey->cnk_pfid));
+        C2_PRE(c2_cob_is_valid(cob));
 
-        rc = cob_alloc(dom, &cob);
-        if (rc) {
-                C2_ADDB_ADD(&dom->cd_addb, &cob_addb_loc, cob_enomem, rc);
-                return rc;
-        }
-
-        cob->co_nskey = nskey;
+        /*
+         * This is nsrec or new created namespace name. Let's copy
+         * stat data rec to it and adjust it later.
+         */
+        nsrec = cob->co_nsrec;
 
-        /* Take over nskey memory management from caller. */
-        if (need & CA_NSKEY_FREE)
-                cob->co_valid |= CA_NSKEY | CA_NSKEY_FREE;
+        /*
+         * Linkno is number of links in statdata - 1
+         */
+        nsrec.cnr_linkno = cob->co_nsrec.cnr_nlink;
 
         /* 
-         * Check if this create case (no "zero" statdaat cob exists) 
+         * Bump ->cnr_nlink and use _old_ value for the key in object
+         * index later.
          */
-        if (nsrec->cnr_nlink > 0) {
-                /*
-                 * Let's find zero statdata, we will need it. 
-                 */
-                rc = c2_cob_locate(dom, &nsrec->cnr_stobid, &cob0, tx);
-                if (rc) {
-                        C2_ADDB_ADD(&dom->cd_addb, &cob_addb_loc, cob_enoent, rc);
-                        goto out_free;
-                }
+        nlink = cob->co_nsrec.cnr_nlink++;
 
-                /*
-                 * This is one more name for an existing file, its linkno
-                 * is the same as number of links before bumping it. 
-                 */
-                nsrec->cnr_linkno = cob0->co_nsrec.cnr_nlink;
-
-                /* 
-                 * Bump ->cnr_nlink and use _old_ value for the key in object
-                 * index later.
-                 */
-                nlink = cob0->co_nsrec.cnr_nlink++;
-                
+        /* 
+         * Check if this create case (no "zero" statdata cob exists) 
+         */
+        if (nsrec.cnr_linkno > 0) {
                 /* 
-                 * Now let's update cob0 stat data on storage with new nlink
+                 * Now let's update stat data on storage with new nlink
                  * value.
                  */
-                c2_db_pair_setup(&pair, &cob0->co_dom->cd_namespace,
-			         cob0->co_nskey, c2_cob_nskey_size(cob0->co_nskey),
-			         &cob0->co_nsrec, sizeof cob0->co_nsrec);
+                c2_db_pair_setup(&pair, &cob->co_dom->cd_namespace,
+			         cob->co_nskey, c2_cob_nskey_size(cob->co_nskey),
+			         &cob->co_nsrec, sizeof cob->co_nsrec);
                 rc = c2_table_update(tx, &pair);
 	        c2_db_pair_release(&pair);
 	        c2_db_pair_fini(&pair);
-                c2_cob_put(cob0);
 	        if (rc)
 	                goto out_free;
-	} else {
-	        /* 
-	         * Zero nlink for zero statdata key and +1 nlink for 
-	         * statdata itself.
-	         */
-	        nlink = nsrec->cnr_nlink++;
-
-                /*
-                 * This is first name, its linkno == 0. 
-                 */
-                nsrec->cnr_linkno = 0;
 	}
 
-        /*
-         * We use child stobid for a key. 
-         */
-        oikey.cok_stobid = nsrec->cnr_stobid;
-        
-        /*
-         * Use new nlink value for the key in object index. 
-         */
+        oikey.cok_stobid = cob->co_nsrec.cnr_stobid;
         oikey.cok_linkno = nlink;
 
         /*
-         * Add to object index table. Table insert should fail if
-         * already exists. 
+         * Add new name to object index table. Table insert should fail
+         * if name already exists. 
          */
-        c2_db_pair_setup(&pair, &dom->cd_object_index,
-			 &oikey, sizeof oikey, cob->co_nskey, 
-			 c2_cob_nskey_size(cob->co_nskey));
+        c2_db_pair_setup(&pair, &cob->co_dom->cd_object_index,
+			 &oikey, sizeof oikey, nskey, 
+			 c2_cob_nskey_size(nskey));
 
         rc = c2_table_insert(tx, &pair);
         c2_db_pair_release(&pair);
 	c2_db_pair_fini(&pair);
 	if (rc) {
-                C2_ADDB_ADD(&dom->cd_addb, &cob_addb_loc, cob_eexist, rc);
+                C2_ADDB_ADD(&cob->co_dom->cd_addb, &cob_addb_loc, 
+                            cob_eexist, rc);
                 goto out_free;
         }
 
-        /* Cache the nsrec. */
-        cob->co_nsrec = *nsrec;
-        cob->co_valid |= CA_NSREC;
-
         /*
          * Add to namespace table. Content of ->co_nsrec is not important
          * with only exception for stobid and linkno. Meaningful statdata
          * is stored in "zero" namespace entry.
          */
-        c2_db_pair_setup(&pair, &dom->cd_namespace,
-			 cob->co_nskey, c2_cob_nskey_size(cob->co_nskey),
-			 &cob->co_nsrec, sizeof cob->co_nsrec);
+        c2_db_pair_setup(&pair, &cob->co_dom->cd_namespace,
+			 nskey, c2_cob_nskey_size(nskey),
+			 &nsrec, sizeof nsrec);
 
         rc = c2_table_insert(tx, &pair);
         c2_db_pair_release(&pair);
 	c2_db_pair_fini(&pair);
 	if (rc) {
-                C2_ADDB_ADD(&dom->cd_addb, &cob_addb_loc, cob_eexist, rc);
+                C2_ADDB_ADD(&cob->co_dom->cd_addb, &cob_addb_loc, 
+                            cob_eexist, rc);
                 goto out_free;
         }
-                
-        *out = cob;
 	return 0;
 
 out_free:
-        c2_cob_put(cob);
-        C2_ADDB_ADD(&dom->cd_addb, &cob_addb_loc, cob_link, rc == 0);
+        C2_ADDB_ADD(&cob->co_dom->cd_addb, &cob_addb_loc, cob_link, rc == 0);
         return rc;
 }
 
@@ -634,16 +601,41 @@ int c2_cob_create(struct c2_cob_domain *dom,
 	int                 rc;
 
         C2_PRE(fabrec != NULL);
-        
+        C2_PRE(nskey != NULL);
+        C2_PRE(nsrec != NULL);
+	C2_PRE(c2_stob_id_is_set(&nsrec->cnr_stobid));
+        C2_PRE(c2_stob_id_is_set(&nskey->cnk_pfid));
+
+        rc = cob_alloc(dom, &cob);
+        if (rc) {
+                C2_ADDB_ADD(&dom->cd_addb, &cob_addb_loc, cob_enomem, rc);
+                return rc;
+        }
+
+        cob->co_nskey = nskey;
+        cob->co_valid |= CA_NSKEY;
+
+        /* 
+         * Take over nskey memory management from caller. 
+         */
+        if (need & CA_NSKEY_FREE)
+                cob->co_valid |= CA_NSKEY_FREE;
+
         /*
          * No first statdata exists, nlink should be 0! 
          */
         C2_PRE(nsrec->cnr_nlink == 0);
 
+        /* 
+         * Now let's update stat data _before_ calling link. 
+         */
+        cob->co_nsrec = *nsrec;
+        cob->co_valid |= CA_NSREC;
+
         /*
          * Let's create name, statdata and object index.
          */
-        rc = c2_cob_link(dom, nskey, nsrec, need, &cob, tx);
+        rc = c2_cob_link(cob, nskey, tx);
         if (rc)
                 return rc;
 
@@ -653,7 +645,9 @@ int c2_cob_create(struct c2_cob_domain *dom,
         cob->co_fabrec = *fabrec;
         cob->co_valid |= CA_FABREC;
 
-        /* Add to filattr-basic table. */
+        /* 
+         * Add to filattr-basic table. 
+         */
         c2_db_pair_setup(&pair, &dom->cd_fileattr_basic,
 			 &cob->co_stobid, sizeof cob->co_stobid,
 			 &cob->co_fabrec, sizeof cob->co_fabrec);
@@ -673,14 +667,6 @@ out_free:
         return rc;
 }
 
-/** 
-   For assertions only.
-*/
-static bool c2_cob_is_valid(struct c2_cob *cob)
-{
-        return c2_stob_id_is_set(&cob->co_stobid);
-}
-
 /**
    Unlink last link, kill statdata, file attrs, etc.
  */
@@ -955,6 +941,7 @@ int c2_cob_rename(struct c2_cob        *cob,
         c2_db_cursor_fini(&cursor);
         if (rc)
                 goto out;
+        
 
         /* Update object index */
         oikey.cok_stobid = cob->co_stobid;
diff --git a/cob/cob.h b/cob/cob.h
index f950a17..6aa5991 100644
--- a/cob/cob.h
+++ b/cob/cob.h
@@ -257,22 +257,25 @@ int c2_cob_create(struct c2_cob_domain *dom,
                   struct c2_db_tx      *tx);
 
 /**
-   Create name, object index and update nlink in "zero" statdata. Outcome
-   is the same as for c2_cob_create().
+   Create name, update object index and nlink in "zero" name
+   statdata.
+   
+   cob   - stat data (zero name) cob;
+   nskey - new name to add to the file;
+   tx    - transaction handle.
+
+   @todo: Update {a|c|m}time in pfid and tfid
 */
-int c2_cob_link(struct c2_cob_domain *dom,
+int c2_cob_link(struct c2_cob        *cob,
                 struct c2_cob_nskey  *nskey,
-                struct c2_cob_nsrec  *nsrec,
-                uint64_t              need,
-                struct c2_cob       **out,
                 struct c2_db_tx      *tx);
                 
 /**
    Delete name, update nlink and kill statdata if last nlink.
    
    cob   - stat data (zero name) cob;
-   nskey - name to kill (may be the name of statdata)
-   tx    - transcation handle
+   nskey - name to kill (may be the name of statdata);
+   tx    - transcation handle.
 */
 int c2_cob_unlink(struct c2_cob       *cob, 
                   struct c2_cob_nskey *nskey,
diff --git a/mdstore/mdstore.c b/mdstore/mdstore.c
index 92d8848..4d98891 100644
--- a/mdstore/mdstore.c
+++ b/mdstore/mdstore.c
@@ -143,9 +143,9 @@ int c2_md_store_link(struct c2_md_store *md, struct c2_fop *fop,
 {
         struct c2_fop_link    *link = c2_fop_data(fop);
         struct c2_fop_body    *body = &link->l_body;
+        struct c2_stob_id      stobid;
         struct c2_cob         *cob;
         struct c2_cob_nskey   *key;
-        struct c2_cob_nsrec    nsrec;
         int                    rc;
         
         rc = c2_md_store_check_perm(md, fop, ctx);
@@ -153,18 +153,18 @@ int c2_md_store_link(struct c2_md_store *md, struct c2_fop *fop,
                 return rc;
 
         /*
-         * Let's zero out statdata. We don't need it, moreover,
-         * ->nlink should be 0 for links, this is how unlink
-         * can understand if it tries to kill link or statdata
-         * itself. In latter case it needs to be move statdata
-         * to en existing name of the file.
-        */
-        C2_SET0(&nsrec);
+         * Let's find stat data cob first.
+         */
+        fid2stobid(&stobid, &body->b_tfid);
+        rc = c2_cob_locate(&md->md_cob, &stobid, &cob, ctx->ft_tx);
+        if (rc)
+                return rc;
+
+        /*
+         * Link @key to a file described with @cob
+         */        
         make_nskey(&key, &body->b_pfid, &link->l_name);
-        fid2stobid(&nsrec.cnr_stobid, &body->b_tfid);
-        
-        rc = c2_cob_link(&md->md_cob, key, &nsrec, 0, &cob, 
-                         ctx->ft_tx);
+        rc = c2_cob_link(cob, key, ctx->ft_tx);
         c2_cob_put(cob);
         c2_free(key);
         return rc;
@@ -245,6 +245,16 @@ int c2_md_store_close(struct c2_md_store *md, struct c2_fop *fop,
         return rc;
 }
 
+static int c2_md_store_check_sanity(struct c2_md_store *md, 
+                                    struct c2_fop_rename *rename,
+                                    struct c2_fop_ctx *ctx)
+{
+        /*
+         * @todo: is_subdir() like checks should be here.
+         */
+        return 0;
+}
+
 int c2_md_store_rename(struct c2_md_store *md, struct c2_fop *fop,
                        struct c2_fop_ctx *ctx)
 {
@@ -256,11 +266,22 @@ int c2_md_store_rename(struct c2_md_store *md, struct c2_fop *fop,
         struct c2_stob_id     stobid;
         struct c2_cob        *cob;
         int                   rc;
-        
+
+        /*
+         * Check permissions for this operation.
+         */        
         rc = c2_md_store_check_perm(md, fop, ctx);
         if (rc)
                 return rc;
 
+        /*
+         * Perform rename sanity checks (source should not be ancestor
+         * of target dir, etc).
+         */
+        rc = c2_md_store_check_sanity(md, rename, ctx);
+        if (rc)
+                return rc;
+
         fid2stobid(&stobid, &sbody->b_tfid);
         make_nskey(&srckey, &sbody->b_pfid, &rename->r_sname);
         make_nskey(&tgtkey, &tbody->b_pfid, &rename->r_tname);
-- 
1.8.3.2

