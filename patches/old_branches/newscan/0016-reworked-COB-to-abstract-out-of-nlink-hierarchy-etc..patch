From 229dfdfbf06bd9f048770020cdbc08259c4d5987 Mon Sep 17 00:00:00 2001
From: Yuriy Umanets <yuriy_umanets@xyratex.com>
Date: Tue, 1 Mar 2011 05:44:47 -0700
Subject: [PATCH 016/158] - reworked COB to abstract out of nlink, hierarchy,
 etc., knowledge; - reworked mdstore to handle all the things last nlink, etc;
 - added _rep fops to md.ff; - added readdir and getattr fop to md.ff; - added
 [acm]time fields to c2_fop_body to make it suitable for readdir and attr
 fops; - fixes with comments, fixed unlink implementaton.

---
 cob/cob.c         | 412 ++++++++++++++++++++----------------------------------
 cob/cob.h         |  71 +++++-----
 cob/ut/cob.c      |  15 +-
 mdstore/md.ff     |  44 +++++-
 mdstore/mdstore.c | 168 ++++++++++++++++------
 5 files changed, 364 insertions(+), 346 deletions(-)

diff --git a/cob/cob.c b/cob/cob.c
index 6f634b4..fbe15f3 100644
--- a/cob/cob.c
+++ b/cob/cob.c
@@ -270,15 +270,20 @@ static int cob_ns_lookup(struct c2_cob *cob, struct c2_db_tx *tx)
  */
 static int cob_oi_lookup(struct c2_cob *cob, struct c2_db_tx *tx)
 {
-        struct c2_cob_oikey oikey;
-        int rc;
+        struct c2_db_cursor cursor;
+        int                 rc;
 
-        /* Don't need to lookup anything if nskey is already here. */
         if (cob->co_valid & CA_NSKEY)
                 return 0;
 
-        oikey.cok_stobid = cob->co_stobid;
-        oikey.cok_linkno = 0;
+        /*
+         * We use cursor here because in some situations we need
+         * find most suitable position instead of exact location.
+         */
+        rc = c2_db_cursor_init(&cursor, 
+                               &cob->co_dom->cd_object_index, tx);
+        if (rc)
+                return rc;
 
         /* 
          * Find the name from the object index table. Note the key buffer
@@ -286,13 +291,11 @@ static int cob_oi_lookup(struct c2_cob *cob, struct c2_db_tx *tx)
          * until c2_db_pair_fini. 
          */
         c2_db_pair_setup(&cob->co_oipair, &cob->co_dom->cd_object_index,
-			 &oikey, sizeof oikey, NULL, 0);
-        rc = c2_table_lookup(tx, &cob->co_oipair);
+			 &cob->co_oikey, sizeof cob->co_oikey, NULL, 0);
+
+        c2_db_cursor_get(&cursor, &cob->co_oipair);
         c2_db_pair_release(&cob->co_oipair);
-        if (rc) {
-                c2_db_pair_fini(&cob->co_oipair);
-                return rc;
-        }
+        c2_db_cursor_fini(&cursor);
 
         cob->co_nskey =
                 (struct c2_cob_nskey *)cob->co_oipair.dp_rec.db_buf.b_addr;
@@ -388,14 +391,16 @@ int c2_cob_lookup(struct c2_cob_domain *dom, struct c2_cob_nskey *nskey,
                 return rc;
         }
 
-        /* Otherwise we can't assume NSKEY will stick around */
+        /* 
+         * Otherwise we can't assume NSKEY will stick around. 
+         */
         if (need & CA_NSKEY_FREE)
-                cob->co_valid |= CA_NSKEY | CA_NSKEY_FREE;
+                cob->co_valid |= CA_NSKEY_FREE;
 
         /*
          * Get the fabrec here too if needed.  co_valid will be set
          * correctly inside the call so we can ignore the return code. 
-        */
+         */
         if (need & CA_FABREC)
                 cob_fab_lookup(cob, tx);
 
@@ -410,7 +415,8 @@ int c2_cob_lookup(struct c2_cob_domain *dom, struct c2_cob_nskey *nskey,
    @see cob_cache_nscheck
  */
 static int cob_cache_oicheck(struct c2_cob_domain *dom,
-                             const struct c2_stob_id *id, struct c2_cob **out)
+                             struct c2_cob_oikey *oikey, 
+                             struct c2_cob **out)
 {
         /* 
          * @todo: implement a cache for cobs and check if the cob with this
@@ -420,23 +426,23 @@ static int cob_cache_oicheck(struct c2_cob_domain *dom,
 }
 
 /**
-   Locate by stob id
+   Locate by object index key
 
    Check if cached first; otherwise create a new cob and populate it with
    the contents of the oi record; i.e. the filename.
 
    This lookup adds a reference to the cob.
  */
-int c2_cob_locate(struct c2_cob_domain *dom, const struct c2_stob_id *id,
+int c2_cob_locate(struct c2_cob_domain *dom, struct c2_cob_oikey *oikey,
                   struct c2_cob **out, struct c2_db_tx *tx)
 {
         struct c2_cob *cob;
         int rc;
 
-        C2_PRE(c2_stob_id_is_set(id));
+        C2_PRE(c2_stob_id_is_set(&oikey->cok_stobid));
 
-        rc = cob_cache_oicheck(dom, id, out);
-        if (rc == 0) /* cached, took ref */
+        rc = cob_cache_oicheck(dom, oikey, out);
+        if (rc == 0)
                 return 0;
 
         /* Get cob memory. */
@@ -444,7 +450,7 @@ int c2_cob_locate(struct c2_cob_domain *dom, const struct c2_stob_id *id,
         if (rc)
                 return rc;
 
-        cob->co_stobid = *id;
+        cob->co_oikey = *oikey;
         rc = cob_oi_lookup(cob, tx);
         if (rc) {
                 c2_cob_put(cob);
@@ -477,110 +483,6 @@ static bool c2_cob_is_valid(struct c2_cob *cob)
 }
 
 /**
-   Create name, update object index and nlink in "zero" name
-   statdata.
-   
-   cob   - stat data (zero name) cob;
-   nskey - new name to add to the file;
-   tx    - transaction handle.
-
-   @todo: Update {a|c|m}time in pfid and tfid
-*/
-int c2_cob_link(struct c2_cob        *cob,
-                struct c2_cob_nskey  *nskey,
-                struct c2_db_tx      *tx)
-{
-        struct c2_cob_oikey oikey;
-        struct c2_db_pair   pair;
-        struct c2_cob_nsrec nsrec;
-        int                 nlink;
-	int                 rc;
-
-        C2_PRE(cob != NULL);
-        C2_PRE(nskey != NULL);
-        C2_PRE(c2_stob_id_is_set(&nskey->cnk_pfid));
-        C2_PRE(c2_cob_is_valid(cob));
-
-        /*
-         * This is nsrec or new created namespace name. Let's copy
-         * stat data rec to it and adjust it later.
-         */
-        nsrec = cob->co_nsrec;
-
-        /*
-         * Linkno is number of links in statdata - 1
-         */
-        nsrec.cnr_linkno = cob->co_nsrec.cnr_nlink;
-
-        /* 
-         * Bump ->cnr_nlink and use _old_ value for the key in object
-         * index later.
-         */
-        nlink = cob->co_nsrec.cnr_nlink++;
-
-        /* 
-         * Check if this create case (no "zero" statdata cob exists) 
-         */
-        if (nsrec.cnr_linkno > 0) {
-                /* 
-                 * Now let's update stat data on storage with new nlink
-                 * value.
-                 */
-                c2_db_pair_setup(&pair, &cob->co_dom->cd_namespace,
-			         cob->co_nskey, c2_cob_nskey_size(cob->co_nskey),
-			         &cob->co_nsrec, sizeof cob->co_nsrec);
-                rc = c2_table_update(tx, &pair);
-	        c2_db_pair_release(&pair);
-	        c2_db_pair_fini(&pair);
-	        if (rc)
-	                goto out_free;
-	}
-
-        oikey.cok_stobid = cob->co_nsrec.cnr_stobid;
-        oikey.cok_linkno = nlink;
-
-        /*
-         * Add new name to object index table. Table insert should fail
-         * if name already exists. 
-         */
-        c2_db_pair_setup(&pair, &cob->co_dom->cd_object_index,
-			 &oikey, sizeof oikey, nskey, 
-			 c2_cob_nskey_size(nskey));
-
-        rc = c2_table_insert(tx, &pair);
-        c2_db_pair_release(&pair);
-	c2_db_pair_fini(&pair);
-	if (rc) {
-                C2_ADDB_ADD(&cob->co_dom->cd_addb, &cob_addb_loc, 
-                            cob_eexist, rc);
-                goto out_free;
-        }
-
-        /*
-         * Add to namespace table. Content of ->co_nsrec is not important
-         * with only exception for stobid and linkno. Meaningful statdata
-         * is stored in "zero" namespace entry.
-         */
-        c2_db_pair_setup(&pair, &cob->co_dom->cd_namespace,
-			 nskey, c2_cob_nskey_size(nskey),
-			 &nsrec, sizeof nsrec);
-
-        rc = c2_table_insert(tx, &pair);
-        c2_db_pair_release(&pair);
-	c2_db_pair_fini(&pair);
-	if (rc) {
-                C2_ADDB_ADD(&cob->co_dom->cd_addb, &cob_addb_loc, 
-                            cob_eexist, rc);
-                goto out_free;
-        }
-	return 0;
-
-out_free:
-        C2_ADDB_ADD(&cob->co_dom->cd_addb, &cob_addb_loc, cob_link, rc == 0);
-        return rc;
-}
-
-/**
    Add a new cob to the namespace.
 
    This doesn't create a new stob; just creates metadata table entries
@@ -621,11 +523,6 @@ int c2_cob_create(struct c2_cob_domain *dom,
         if (need & CA_NSKEY_FREE)
                 cob->co_valid |= CA_NSKEY_FREE;
 
-        /*
-         * No first statdata exists, nlink should be 0! 
-         */
-        C2_PRE(nsrec->cnr_nlink == 0);
-
         /* 
          * Now let's update stat data _before_ calling link. 
          */
@@ -635,7 +532,7 @@ int c2_cob_create(struct c2_cob_domain *dom,
         /*
          * Let's create name, statdata and object index.
          */
-        rc = c2_cob_link(cob, nskey, tx);
+        rc = c2_cob_add_name(cob, nskey, tx);
         if (rc)
                 return rc;
 
@@ -646,7 +543,7 @@ int c2_cob_create(struct c2_cob_domain *dom,
         cob->co_valid |= CA_FABREC;
 
         /* 
-         * Add to filattr-basic table. 
+         * Add to fileattr-basic table. 
          */
         c2_db_pair_setup(&pair, &dom->cd_fileattr_basic,
 			 &cob->co_stobid, sizeof cob->co_stobid,
@@ -668,7 +565,7 @@ out_free:
 }
 
 /**
-   Unlink last link, kill statdata, file attrs, etc.
+   Kill name+statdata, object index entry, file attrs, etc.
  */
 int c2_cob_delete(struct c2_cob *cob, struct c2_db_tx *tx)
 {
@@ -676,15 +573,8 @@ int c2_cob_delete(struct c2_cob *cob, struct c2_db_tx *tx)
         struct c2_db_pair   pair;
         int                  rc;
 
-        /*
-         * We need the name key. 
-         */
-        rc = cob_oi_lookup(cob, tx);
-        if (rc) {
-                C2_ADDB_ADD(&cob->co_dom->cd_addb, &cob_addb_loc, cob_enoent, rc);
-                goto out;
-        }
-        C2_POST(cob->co_valid & CA_NSKEY);
+        C2_PRE(c2_cob_is_valid(cob));
+        C2_PRE(cob->co_valid & CA_NSKEY);
 
         /* 
          * Remove from the object index table. 
@@ -732,155 +622,157 @@ out:
 }
 
 /**
-   Delete name, update nlink and kill statdata if last nlink.
+   Update cob's nsrec. May be used for stat data updates.
    
+   cob - stat data cob, result of c2_cob_locate;
+   tx - transaction handle.
+*/
+int c2_cob_update(struct c2_cob *cob, struct c2_db_tx *tx)
+{
+        struct c2_db_pair   pair;
+        int                 rc;
+        
+        C2_PRE(c2_cob_is_valid(cob));
+        c2_db_pair_setup(&pair, &cob->co_dom->cd_namespace,
+                         cob->co_nskey, c2_cob_nskey_size(cob->co_nskey),
+                         &cob->co_nsrec, sizeof cob->co_nsrec);
+        rc = c2_table_update(tx, &pair);
+        if (rc == 0)
+                cob->co_valid |= CA_NSREC;
+        else
+                cob->co_valid &= ~CA_NSREC;
+        c2_db_pair_release(&pair);
+        c2_db_pair_fini(&pair);
+        return rc;
+}
+
+/**
+   Add name to namespace and object index.
+      
    cob   - stat data (zero name) cob;
-   nskey - name to kill (may be the name of statdata)
-   tx    - transcation handle
+   nskey - new name to add to the file;
+   tx    - transaction handle.
 */
-int c2_cob_unlink(struct c2_cob        *cob, 
-                  struct c2_cob_nskey  *nskey,
-                  struct c2_db_tx      *tx)
+int c2_cob_add_name(struct c2_cob        *cob,
+                    struct c2_cob_nskey  *nskey,
+                    struct c2_db_tx      *tx)
 {
-        struct c2_db_cursor cursor;
-        struct c2_cob_nsrec nsrec;
-        struct c2_cob_nskey nkey;
         struct c2_cob_oikey oikey;
         struct c2_db_pair   pair;
-        int                 nlink;
-        int                 rc;
+        struct c2_cob_nsrec nsrec;
+	int                 rc;
 
+        C2_PRE(cob != NULL);
+        C2_PRE(nskey != NULL);
+        C2_PRE(c2_stob_id_is_set(&nskey->cnk_pfid));
         C2_PRE(c2_cob_is_valid(cob));
 
         /*
-         * We need the name key. 
+         * This is nsrec or new created namespace name. Let's copy
+         * stat data rec to it and adjust it later.
          */
-        rc = cob_oi_lookup(cob, tx);
-        if (rc) {
-                C2_ADDB_ADD(&cob->co_dom->cd_addb, &cob_addb_loc, cob_enoent, rc);
-                goto out;
-        }
-        C2_POST(cob->co_valid & CA_NSKEY);
+        nsrec = cob->co_nsrec;
 
         /*
-         * Passed cob is zero name holding statdata one. Let's check 
-         * its nlink.
+         * Linkno for new name is number of links in statdata - 1
          */
-        C2_PRE(cob->co_nsrec.cnr_nlink > 0);
-        nlink = cob->co_nsrec.cnr_nlink--;
+        nsrec.cnr_linkno = cob->co_nsrec.cnr_nlink;
+        oikey.cok_stobid = cob->co_nsrec.cnr_stobid;
 
         /* 
-         * Last nlink, let's all everything. 
+         * Use _old_ nlink value for the key in object index.
          */
-        if (nlink == 0) {
-                rc = c2_cob_delete(cob, tx);
-                goto out;
-        }
-                
+        oikey.cok_linkno = cob->co_nsrec.cnr_nlink;
+
         /*
-         * Lookup name that will be killed in namespace to check if 
-         * this is statdata one or not. 
+         * Add new name to object index table. Table insert should fail
+         * if name already exists. 
          */
-        c2_db_pair_setup(&pair, &cob->co_dom->cd_namespace,
-	                 nskey, c2_cob_nskey_size(nskey),
-		         &nsrec, sizeof nsrec);
-        rc = c2_table_lookup(tx, &pair);
+        c2_db_pair_setup(&pair, &cob->co_dom->cd_object_index,
+			 &oikey, sizeof oikey, nskey, 
+			 c2_cob_nskey_size(nskey));
+
+        rc = c2_table_insert(tx, &pair);
         c2_db_pair_release(&pair);
-        c2_db_pair_fini(&pair);
-        if (rc) {
-                C2_ADDB_ADD(&cob->co_dom->cd_addb, &cob_addb_loc, cob_enoent, rc);
-                goto out;
+	c2_db_pair_fini(&pair);
+	if (rc) {
+                C2_ADDB_ADD(&cob->co_dom->cd_addb, &cob_addb_loc, 
+                            cob_eexist, rc);
+                goto out_free;
         }
-        
+
         /*
-         * Statdata name should always have linkno == 0. Other names
-         * have linkno > 0.
+         * Add to namespace table. Content of ->co_nsrec is not important
+         * with only exception for stobid and linkno. Meaningful statdata
+         * is stored in "zero" namespace entry.
          */
-        if (nsrec.cnr_linkno == 0) {
-                /*
-                 * This is first enrty, let's move statdata to next 
-                 * existing name. Let's find a name. 
-                 */
-                rc = c2_db_cursor_init(&cursor, 
-                                       &cob->co_dom->cd_object_index, tx);
-                if (rc)
-                        goto out;
+        c2_db_pair_setup(&pair, &cob->co_dom->cd_namespace,
+			 nskey, c2_cob_nskey_size(nskey),
+			 &nsrec, sizeof nsrec);
 
-                oikey.cok_stobid = cob->co_stobid;
-                        
-                /*
-                 * We want to move statdata to next name, this is 
-                 * something with linkno > 0. Let's put 1 and cursor
-                 * will find closest one.
-                 */
-                oikey.cok_linkno = 1;
+        rc = c2_table_insert(tx, &pair);
+        c2_db_pair_release(&pair);
+	c2_db_pair_fini(&pair);
+	if (rc) {
+                C2_ADDB_ADD(&cob->co_dom->cd_addb, &cob_addb_loc, 
+                            cob_eexist, rc);
+                goto out_free;
+        }
+	return 0;
 
-                c2_db_pair_setup(&pair, &cob->co_dom->cd_object_index,
-	                         &oikey, sizeof oikey, &nkey, sizeof nkey);
+out_free:
+        C2_ADDB_ADD(&cob->co_dom->cd_addb, &cob_addb_loc, cob_link, rc == 0);
+        return rc;
+}
 
-                c2_db_cursor_get(&cursor, &pair);
-                c2_db_cursor_fini(&cursor);
+/**
+   Delete name from namespace and object index.
+   
+   cob   - stat data (zero name) cob;
+   nskey - name to kill (may be the name of statdata);
+   tx    - transcation handle.
+*/
+int c2_cob_del_name(struct c2_cob        *cob, 
+                    struct c2_cob_nskey  *nskey,
+                    struct c2_db_tx      *tx)
+{
+        struct c2_cob_oikey oikey;
+        struct c2_db_pair   pair;
+        int                 rc;
 
-                /*
-                 * Now let's move statdata itself using found namespace
-                 * key and nsrec from cob. Note that nlink-- is realdy
-                 * done above.
-                 */
-                c2_db_pair_setup(&pair, &cob->co_dom->cd_namespace,
-		                 &nkey, sizeof nkey, &cob->co_nsrec, 
-		                 sizeof cob->co_nsrec);
-                rc = c2_table_update(tx, &pair);
-                c2_db_pair_release(&pair);
-                c2_db_pair_fini(&pair);
-                if (rc)
-                        goto out;
+        C2_PRE(c2_cob_is_valid(cob));
+        C2_PRE(cob->co_valid & CA_NSKEY);
 
-                /*
-                 * Time to kill the name whatever it was.
-                 */
-                c2_db_pair_setup(&pair, &cob->co_dom->cd_namespace,
-	                         nskey, c2_cob_nskey_size(nskey),
-		                 NULL, 0);
-                rc = c2_table_delete(tx, &pair);
-                c2_db_pair_release(&pair);
-                c2_db_pair_fini(&pair);
-                if (rc)
-                        goto out;
+        /*
+         * Kill name from namespace.
+         */
+        c2_db_pair_setup(&pair, &cob->co_dom->cd_namespace,
+                         nskey, c2_cob_nskey_size(nskey),
+		         NULL, 0);
+        rc = c2_table_delete(tx, &pair);
+        c2_db_pair_release(&pair);
+        c2_db_pair_fini(&pair);
+        if (rc)
+                goto out;
+
+        /*
+         * Let's also kill object index entry.
+         */
+        oikey.cok_stobid = cob->co_stobid;
+        oikey.cok_linkno = cob->co_nsrec.cnr_nlink;
+
+        c2_db_pair_setup(&pair, &cob->co_dom->cd_object_index,
+                         &oikey, sizeof oikey, NULL, 0);
+        rc = c2_table_delete(tx, &pair);
+        c2_db_pair_release(&pair);
+        c2_db_pair_fini(&pair);
 
-                /*
-                 * Let's also kill object index entry. Note that we use
-                 * nsrec.linkno from nsrec found by name key. This allows
-                 * to kill object index entry without a loop.
-                */
-                oikey.cok_stobid = cob->co_stobid;
-                oikey.cok_linkno = nsrec.cnr_linkno;
-
-                c2_db_pair_setup(&pair, &cob->co_dom->cd_object_index,
-	                         &oikey, sizeof oikey, NULL, 0);
-                rc = c2_table_delete(tx, &pair);
-                c2_db_pair_release(&pair);
-                c2_db_pair_fini(&pair);
-        } else {
-                /*
-                 * Let's update statdata on storage to make sure that
-                 * nlink-- is there.
-                 */
-                c2_db_pair_setup(&pair, &cob->co_dom->cd_namespace,
-	                         cob->co_nskey, c2_cob_nskey_size(cob->co_nskey),
-	                         &cob->co_nsrec, sizeof cob->co_nsrec);
-                rc = c2_table_update(tx, &pair);
-                c2_db_pair_release(&pair);
-                c2_db_pair_fini(&pair);
-                cob->co_valid |= CA_NSREC;
-        }
-                
 out:
         /*
          * If the op failed, assume we're not going to do anything else about
          * it, so log and drop in all cases. 
          */
         C2_ADDB_ADD(&cob->co_dom->cd_addb, &cob_addb_loc, cob_delete, rc == 0);
-        c2_cob_put(cob);
         return rc;
 }
 
@@ -892,10 +784,10 @@ out:
    tgtkey - target name;
    tx     - transcation handle
 */
-int c2_cob_rename(struct c2_cob        *cob, 
-                  struct c2_cob_nskey  *srckey,
-                  struct c2_cob_nskey  *tgtkey,
-                  struct c2_db_tx      *tx)
+int c2_cob_update_name(struct c2_cob        *cob, 
+                       struct c2_cob_nskey  *srckey,
+                       struct c2_cob_nskey  *tgtkey,
+                       struct c2_db_tx      *tx)
 {
         struct c2_cob_nsrec nsrec;
         struct c2_db_pair   pair;
diff --git a/cob/cob.h b/cob/cob.h
index 993e0f8..f6f12d7 100644
--- a/cob/cob.h
+++ b/cob/cob.h
@@ -191,6 +191,7 @@ struct c2_cob {
         uint64_t               co_valid;   /**< @see enum ca_valid */
         struct c2_verno        co_version; /**< current object version */
         struct c2_cob_nskey   *co_nskey;   /**< pfid, filename */
+        struct c2_cob_oikey    co_oikey;   /**< tfid, linkno */
         struct c2_cob_nsrec    co_nsrec;   /**< fid, stat data */
         struct c2_cob_fabrec   co_fabrec;  /**< fileattr_basic data */
         struct c2_db_pair      co_oipair;
@@ -227,7 +228,7 @@ int c2_cob_lookup(struct c2_cob_domain *dom,
                   struct c2_db_tx      *tx);
 
 /**
-   Locate by stob id
+   Locate by object index key.
 
    Check if cached first; otherwise create a new cob and populate it with
    the contents of the oi record; i.e. the filename.
@@ -237,7 +238,7 @@ int c2_cob_lookup(struct c2_cob_domain *dom,
     @see c2_cob_lookup
  */
 int c2_cob_locate(struct c2_cob_domain    *dom, 
-                  const struct c2_stob_id *id,
+                  struct c2_cob_oikey     *oikey,
                   struct c2_cob          **out, 
                   struct c2_db_tx         *tx);
 
@@ -256,36 +257,50 @@ int c2_cob_create(struct c2_cob_domain *dom,
                   struct c2_db_tx      *tx);
 
 /**
-   Create name, update object index and nlink in "zero" name
-   statdata.
+   Delete name with statdata, entry in object index and file
+   attributes.
+*/
+int c2_cob_delete(struct c2_cob *cob, 
+                  struct c2_db_tx *tx);
+
+/**
+   Update cob's nsrec. May be used for stat data updates.
    
+   cob - stat data cob, result of c2_cob_locate;
+   tx - transaction handle.
+*/
+int c2_cob_update(struct c2_cob *cob, 
+                  struct c2_db_tx *tx);
+
+/**
+   Update file attributes of passed cob with @nsrec fields.
+*/
+int c2_cob_setattr(struct c2_cob        *cob,
+                   struct c2_cob_nsrec  *nsrec,
+                   struct c2_cob_fabrec *fabrec,
+                   struct c2_db_tx      *tx);
+                  
+/**
+   Add name to namespace and object index.
+      
    cob   - stat data (zero name) cob;
    nskey - new name to add to the file;
    tx    - transaction handle.
-
-   @todo: Update {a|c|m}time in pfid and tfid
 */
-int c2_cob_link(struct c2_cob        *cob,
-                struct c2_cob_nskey  *nskey,
-                struct c2_db_tx      *tx);
+int c2_cob_add_name(struct c2_cob        *cob,
+                    struct c2_cob_nskey  *nskey,
+                    struct c2_db_tx      *tx);
                 
 /**
-   Delete name, update nlink and kill statdata if last nlink.
+   Delete name from namespace and object index.
    
    cob   - stat data (zero name) cob;
    nskey - name to kill (may be the name of statdata);
    tx    - transcation handle.
 */
-int c2_cob_unlink(struct c2_cob       *cob, 
-                  struct c2_cob_nskey *nskey,
-                  struct c2_db_tx     *tx);
-
-/**
-   Delete name with statdata, entry in object index and file
-   attributes.
-*/
-int c2_cob_delete(struct c2_cob *cob, 
-                  struct c2_db_tx *tx);
+int c2_cob_del_name(struct c2_cob        *cob, 
+                    struct c2_cob_nskey  *nskey,
+                    struct c2_db_tx      *tx);
 
 /**
    Rename oldkey with passed newkey.
@@ -295,20 +310,12 @@ int c2_cob_delete(struct c2_cob *cob,
    tgtkey - target name;
    tx     - transcation handle
 */
-int c2_cob_rename(struct c2_cob        *cob, 
-                  struct c2_cob_nskey  *srckey,
-                  struct c2_cob_nskey  *tgtkey,
-                  struct c2_db_tx      *tx);
+int c2_cob_update_name(struct c2_cob        *cob, 
+                       struct c2_cob_nskey  *srckey,
+                       struct c2_cob_nskey  *tgtkey,
+                       struct c2_db_tx      *tx);
 
 /**
-   Update file attributes of passed cob with @nsrec fields.
-*/
-int c2_cob_setattr(struct c2_cob        *cob,
-                   struct c2_cob_nsrec  *nsrec,
-                   struct c2_cob_fabrec *fabrec,
-                   struct c2_db_tx      *tx);
-                  
-/**
    Acquires an additional reference on the object.
 
    @see c2_cob_put()
diff --git a/cob/ut/cob.c b/cob/ut/cob.c
index ebeea3f..ad4a975 100644
--- a/cob/ut/cob.c
+++ b/cob/ut/cob.c
@@ -116,13 +116,17 @@ static int test_locate_internal(void)
 {
         struct c2_db_tx      tx;
         struct c2_stob_id    sid;
+        struct c2_cob_oikey  oikey;
 
         /* stob fid */
         sid.si_bits.u_hi = 0xabc;
         sid.si_bits.u_lo = 0xdef;
+        
+        oikey.cok_stobid = sid;
+        oikey.cok_linkno = 0;
 
         c2_db_tx_init(&tx, dom.cd_dbenv, 0);
-        rc = c2_cob_locate(&dom, &sid, &cob, &tx);
+        rc = c2_cob_locate(&dom, &oikey, &cob, &tx);
         c2_db_tx_commit(&tx);
 
         return rc;
@@ -147,10 +151,9 @@ static void test_locate(void)
         c2_cob_put(cob);
 }
 
-static void test_unlink(void)
+static void test_delete(void)
 {
         struct c2_db_tx      tx;
-        struct c2_cob_nskey *key;
 
         /* gets ref */
         rc = test_locate_internal();
@@ -158,11 +161,9 @@ static void test_unlink(void)
 
         c2_db_tx_init(&tx, dom.cd_dbenv, 0);
         /* drops ref */
-        make_nskey(&key, 0x123, 0x456, "hello world");
-        rc = c2_cob_unlink(cob, key, &tx);
+        rc = c2_cob_delete(cob, &tx);
         c2_db_tx_commit(&tx);
 	C2_UT_ASSERT(rc == 0);
-        c2_free(key);
 
         /* should fail now */
         rc = test_locate_internal();
@@ -178,7 +179,7 @@ const struct c2_test_suite cob_ut = {
                 { "cob-create", test_create },
                 { "cob-lookup", test_lookup },
                 { "cob-locate", test_locate },
-                { "cob-unlink", test_unlink },
+                { "cob-delete", test_delete },
 		{ "cob-fini", test_fini },
 		{ NULL, NULL }
 	}
diff --git a/mdstore/md.ff b/mdstore/md.ff
index 4715779..1a09e96 100644
--- a/mdstore/md.ff
+++ b/mdstore/md.ff
@@ -27,6 +27,9 @@ DEF(c2_fop_body, RECORD,
     _(b_gid, U32),
     _(b_sid, U32),
     _(b_nid, U64),
+    _(b_atime, U32),
+    _(b_mtime, U32),
+    _(b_ctime, U32),
     _(b_pfid, c2_fop_fid),
     _(b_tfid, c2_fop_fid));
 
@@ -34,29 +37,66 @@ DEF(c2_fop_create, RECORD,
     _(c_body, c2_fop_body),
     _(c_name, c2_fop_name));
 
+DEF(c2_fop_create_rep, RECORD,
+    _(c_body, c2_fop_body));
+
 DEF(c2_fop_link, RECORD,
     _(l_body, c2_fop_body),
     _(l_name, c2_fop_name));
 
+DEF(c2_fop_link_rep, RECORD,
+    _(l_body, c2_fop_body));
+
 DEF(c2_fop_unlink, RECORD,
     _(u_body, c2_fop_body),
     _(u_name, c2_fop_name));
 
+DEF(c2_fop_unlink_rep, RECORD,
+    _(u_body, c2_fop_body));
+
 DEF(c2_fop_rename, RECORD,
     _(r_sbody, c2_fop_body),
     _(r_tbody, c2_fop_body),
     _(r_sname, c2_fop_name),
     _(r_tname, c2_fop_name));
 
+DEF(c2_fop_rename_rep, RECORD,
+    _(r_body, c2_fop_body));
+
 DEF(c2_fop_open, RECORD,
     _(o_body, c2_fop_body));
 
+DEF(c2_fop_open_rep, RECORD,
+    _(o_body, c2_fop_body));
+
 DEF(c2_fop_close, RECORD,
     _(c_body, c2_fop_body));
 
+DEF(c2_fop_close_rep, RECORD,
+    _(c_body, c2_fop_body));
+
 DEF(c2_fop_setattr, RECORD,
-    _(s_body, c2_fop_body),
-    _(s_time, U32));
+    _(s_body, c2_fop_body));
+
+DEF(c2_fop_setattr_rep, RECORD,
+    _(s_body, c2_fop_body));
+
+DEF(c2_fop_getattr, RECORD,
+    _(g_body, c2_fop_body));
+
+DEF(c2_fop_getattr_rep, RECORD,
+    _(g_body, c2_fop_body));
+
+DEF(c2_fop_readdir, RECORD,
+    _(r_body, c2_fop_body));
+
+DEF(c2_fop_dirent, RECORD,
+    _(d_body, c2_fop_body),
+    _(d_name, c2_fop_name));
+
+DEF(c2_fop_readdir_rep, RECORD,
+    _(r_count, U32),
+    _(r_entry, c2_fop_dirent));
 
 /** @} end of fop group */
 
diff --git a/mdstore/mdstore.c b/mdstore/mdstore.c
index 32045e3..e827848 100644
--- a/mdstore/mdstore.c
+++ b/mdstore/mdstore.c
@@ -153,9 +153,9 @@ int c2_md_store_link(struct c2_md_store *md, struct c2_fop *fop,
 {
         struct c2_fop_link    *link = c2_fop_data(fop);
         struct c2_fop_body    *body = &link->l_body;
-        struct c2_stob_id      stobid;
+        struct c2_cob_oikey    oikey;
         struct c2_cob         *cob;
-        struct c2_cob_nskey   *key;
+        struct c2_cob_nskey   *nskey;
         int                    rc;
         
         rc = c2_md_store_check_perm(md, fop, ctx);
@@ -165,18 +165,28 @@ int c2_md_store_link(struct c2_md_store *md, struct c2_fop *fop,
         /*
          * Let's find stat data cob first.
          */
-        fid2stobid(&stobid, &body->b_tfid);
-        rc = c2_cob_locate(&md->md_cob, &stobid, &cob, ctx->ft_tx);
+        fid2stobid(&oikey.cok_stobid, &body->b_tfid);
+        oikey.cok_linkno = 0;
+
+        rc = c2_cob_locate(&md->md_cob, &oikey, &cob, ctx->ft_tx);
         if (rc)
                 return rc;
 
         /*
-         * Link @key to a file described with @cob
+         * Link @nskey to a file described with @cob
          */        
-        make_nskey(&key, &body->b_pfid, &link->l_name);
-        rc = c2_cob_link(cob, key, ctx->ft_tx);
+        make_nskey(&nskey, &body->b_pfid, &link->l_name);
+        rc = c2_cob_add_name(cob, nskey, ctx->ft_tx);
+        if (rc)
+                goto out;
+        /*
+         * Update nlink in statdata and save it to storage. 
+         */
+        cob->co_nsrec.cnr_nlink++;
+        rc = c2_cob_update(cob, ctx->ft_tx);
+out:
         c2_cob_put(cob);
-        c2_free(key);
+        c2_free(nskey);
         return rc;
 }
 
@@ -185,23 +195,81 @@ int c2_md_store_unlink(struct c2_md_store *md, struct c2_fop *fop,
 {
         struct c2_fop_unlink  *unlink = c2_fop_data(fop);
         struct c2_fop_body    *body = &unlink->u_body;
-        struct c2_stob_id      stobid;
-        struct c2_cob_nskey   *key;
+        struct c2_cob_nskey   *nskey;
+        struct c2_cob_oikey    oikey;
         struct c2_cob         *cob;
+        struct c2_cob_nsrec    nsrec;
         int                    rc;
     
         rc = c2_md_store_check_perm(md, fop, ctx);
         if (rc)
                 return rc;
         
-        make_nskey(&key, &body->b_pfid, &unlink->u_name);
-        fid2stobid(&stobid, &body->b_tfid);
-        rc = c2_cob_locate(&md->md_cob, &stobid, &cob, ctx->ft_tx);
+        make_nskey(&nskey, &body->b_pfid, &unlink->u_name);
+
+        fid2stobid(&oikey.cok_stobid, &body->b_tfid);
+        oikey.cok_linkno = 0;
+
+        /*
+         * Lookup for stat data cob.
+         */
+        rc = c2_cob_locate(&md->md_cob, &oikey, &cob, ctx->ft_tx);
         if (rc)
                 return rc;
 
-        rc = c2_cob_unlink(cob, key, ctx->ft_tx);
-        c2_free(key);
+        /*
+         * Copy "working copy" of stat data.
+         */
+        nsrec = cob->co_nsrec;
+        C2_PRE(nsrec.cnr_nlink > 0);
+        nsrec.cnr_nlink--;
+        
+        /* 
+         * Last nlink, let's delete everything left. 
+         */
+        if (nsrec.cnr_nlink == 0) {
+                rc = c2_cob_delete(cob, ctx->ft_tx);
+                goto out;
+        }
+        
+        /*
+         * Check if we're trying to kill stata data entry. We need to
+         * move stat data to next name if so.
+         */
+        if (c2_cob_nskey_size(nskey) == c2_cob_nskey_size(cob->co_nskey) &&
+            !memcmp(cob->co_nskey, nskey, c2_cob_nskey_size(nskey))) {
+                /*
+                 * Let's re-use cob variable to make this function
+                 * even shorter.
+                 */
+                c2_cob_put(cob);
+
+                /*
+                 * Find next name (new stat data) in object index. Note
+                 * that ->cok_stoid is already set above.
+                 */
+                oikey.cok_linkno++;
+                
+                rc = c2_cob_locate(&md->md_cob, &oikey, &cob, ctx->ft_tx);
+                if (rc)
+                        goto out;
+        }
+
+        /*
+         * Update stat data on store. 
+         */
+        cob->co_nsrec = nsrec;
+        rc = c2_cob_update(cob, ctx->ft_tx);
+        if (rc)
+                goto out;
+
+        /*
+         * Kill name whatever it was.
+         */
+        rc = c2_cob_del_name(cob, nskey, ctx->ft_tx);
+out:
+        c2_cob_put(cob);
+        c2_free(nskey);
         return rc;
 }
 
@@ -210,7 +278,7 @@ int c2_md_store_open(struct c2_md_store *md, struct c2_fop *fop,
 {
         struct c2_fop_open   *open = c2_fop_data(fop);
         struct c2_fop_body   *body = &open->o_body;
-        struct c2_stob_id     stobid;
+        struct c2_cob_oikey   oikey;
         struct c2_cob        *cob;
         int                   rc;
         
@@ -218,10 +286,17 @@ int c2_md_store_open(struct c2_md_store *md, struct c2_fop *fop,
         if (rc)
                 return rc;
         
-        fid2stobid(&stobid, &body->b_tfid);
-        rc = c2_cob_locate(&md->md_cob, &stobid, &cob, ctx->ft_tx);
-        if (rc)
+        fid2stobid(&oikey.cok_stobid, &body->b_tfid);
+        oikey.cok_linkno = 0;
+
+        rc = c2_cob_locate(&md->md_cob, &oikey, &cob, ctx->ft_tx);
+        if (rc == -ENOENT) {
+                /*
+                 * @todo: create file is open mode says so.
+                 */
+        } else if (rc) {
                 return rc;
+        }
         
         c2_cob_put(cob);
         return rc;
@@ -232,7 +307,7 @@ int c2_md_store_close(struct c2_md_store *md, struct c2_fop *fop,
 {
         struct c2_fop_close  *close = c2_fop_data(fop);
         struct c2_fop_body   *body = &close->c_body;
-        struct c2_stob_id     stobid;
+        struct c2_cob_oikey   oikey;
         struct c2_cob        *cob;
         int                   rc;
         
@@ -240,8 +315,10 @@ int c2_md_store_close(struct c2_md_store *md, struct c2_fop *fop,
         if (rc)
                 return rc;
         
-        fid2stobid(&stobid, &body->b_tfid);
-        rc = c2_cob_locate(&md->md_cob, &stobid, &cob, ctx->ft_tx);
+        fid2stobid(&oikey.cok_stobid, &body->b_tfid);
+        oikey.cok_linkno = 0;
+
+        rc = c2_cob_locate(&md->md_cob, &oikey, &cob, ctx->ft_tx);
         if (rc)
                 return rc;
     
@@ -255,23 +332,17 @@ int c2_md_store_close(struct c2_md_store *md, struct c2_fop *fop,
         return rc;
 }
 
-static int c2_md_store_check_sanity(struct c2_md_store *md, 
-                                    struct c2_fop_rename *rename,
-                                    struct c2_fop_ctx *ctx)
+static int c2_md_store_rename_sanity(struct c2_md_store *md, 
+                                     struct c2_fop_rename *rename,
+                                     struct c2_fop_ctx *ctx)
 {
-        struct c2_stob_id   tgtid;
-        struct c2_stob_id   srcid;
-        struct c2_cob      *tgt;
-        int                 rc = 0;
+        struct c2_cob_oikey  oikey;
+        struct c2_stob_id    tgtid;
+        struct c2_stob_id    srcid;
+        struct c2_cob       *tgt;
+        int                  rc = 0;
 
-        /*
-         * Get src id for comparisons.
-         */
         fid2stobid(&srcid, &rename->r_sbody.b_tfid);
-
-        /*
-         * Let's lookup for target starting point.
-         */
         fid2stobid(&tgtid, &rename->r_tbody.b_tfid);
         
         /*
@@ -286,7 +357,10 @@ static int c2_md_store_check_sanity(struct c2_md_store *md,
                 /*
                  * Let's lookup for a target cob.
                  */
-                rc = c2_cob_locate(&md->md_cob, &tgtid, &tgt, ctx->ft_tx);
+                oikey.cok_stobid = tgtid;
+                oikey.cok_linkno = 0;
+
+                rc = c2_cob_locate(&md->md_cob, &oikey, &tgt, ctx->ft_tx);
                 if (rc)
                         return rc;
                 /*
@@ -313,7 +387,7 @@ int c2_md_store_rename(struct c2_md_store *md, struct c2_fop *fop,
         struct c2_fop_body   *tbody = &rename->r_tbody;
         struct c2_cob_nskey  *srckey;
         struct c2_cob_nskey  *tgtkey;
-        struct c2_stob_id     stobid;
+        struct c2_cob_oikey   oikey;
         struct c2_cob        *cob;
         int                   rc;
 
@@ -328,19 +402,21 @@ int c2_md_store_rename(struct c2_md_store *md, struct c2_fop *fop,
          * Perform rename sanity checks (source should not be ancestor
          * of target dir, etc).
          */
-        rc = c2_md_store_check_sanity(md, rename, ctx);
+        rc = c2_md_store_rename_sanity(md, rename, ctx);
         if (rc)
                 return rc;
 
-        fid2stobid(&stobid, &sbody->b_tfid);
+        fid2stobid(&oikey.cok_stobid, &sbody->b_tfid);
+        oikey.cok_linkno = 0;
+
         make_nskey(&srckey, &sbody->b_pfid, &rename->r_sname);
         make_nskey(&tgtkey, &tbody->b_pfid, &rename->r_tname);
 
-        rc = c2_cob_locate(&md->md_cob, &stobid, &cob, ctx->ft_tx);
+        rc = c2_cob_locate(&md->md_cob, &oikey, &cob, ctx->ft_tx);
         if (rc)
                 return rc;
                 
-        rc = c2_cob_rename(cob, srckey, tgtkey, ctx->ft_tx);
+        rc = c2_cob_update_name(cob, srckey, tgtkey, ctx->ft_tx);
         c2_cob_put(cob);
         c2_free(srckey);
         c2_free(tgtkey);
@@ -355,7 +431,7 @@ int c2_md_store_setattr(struct c2_md_store *md, struct c2_fop *fop,
         struct c2_fop_body    *body = &setattr->s_body;
         struct c2_cob_nsrec    nsrec;
         struct c2_cob_fabrec   fabrec;
-        struct c2_stob_id      stobid;
+        struct c2_cob_oikey    oikey;
         struct c2_cob         *cob;
         int                    rc;
         
@@ -363,8 +439,10 @@ int c2_md_store_setattr(struct c2_md_store *md, struct c2_fop *fop,
         if (rc)
                 return rc;
 
-        fid2stobid(&stobid, &body->b_tfid);
-        rc = c2_cob_locate(&md->md_cob, &stobid, &cob, ctx->ft_tx);
+        fid2stobid(&oikey.cok_stobid, &body->b_tfid);
+        oikey.cok_linkno = 0;
+
+        rc = c2_cob_locate(&md->md_cob, &oikey, &cob, ctx->ft_tx);
         if (rc)
                 return rc;
 
-- 
1.8.3.2

