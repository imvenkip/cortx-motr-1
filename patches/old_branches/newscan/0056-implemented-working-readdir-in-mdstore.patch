From dab09d3cbc3272ab2f6712a9f6572d3ca11f0e23 Mon Sep 17 00:00:00 2001
From: Yuriy Umanets <yuriy_umanets@xyratex.com>
Date: Tue, 12 Apr 2011 09:34:26 -0600
Subject: [PATCH 056/158] - implemented working readdir in mdstore; - added
 cob_iterator API for readdir needs; - bunch of fixes about missed
 db_pair_{release|fini} in error handling in cob; - cleanups about error paths
 and fini code in cob; - more error handling in cob about getting attributes;
 - fixes in c2_md_store_lookup() and its path down to cob; - extract omg attrs
 if said so, no double fab_attrs should be extracted in cob; - operation
 permission checks for readdi in foms; - preallocate 4096 readdir entries in
 fom for readdir; - changes about root allocation. It is now created by mkfs
 and looked up in init time using C2_MD_ROOT_FID and "ROOT" name

---
 cob/cob.c            | 179 ++++++++++++++++++++++++++++++++++++++-------------
 cob/cob.h            |  14 ++--
 mdservice/md_foms.c  |  23 ++++++-
 mdservice/md_fops.ff |   1 +
 mdstore/mdstore.c    |  48 +++++++++-----
 mdstore/mdstore.h    |   2 +-
 utils/mkfs.colibri.c |  22 ++++---
 7 files changed, 212 insertions(+), 77 deletions(-)

diff --git a/cob/cob.c b/cob/cob.c
index 3a056df..f071537 100644
--- a/cob/cob.c
+++ b/cob/cob.c
@@ -2,6 +2,8 @@
 #  include <config.h>
 #endif
 
+#include <limits.h>
+
 #include "lib/misc.h"   /* C2_SET0 */
 #include "lib/cdefs.h"
 #include "lib/arith.h"   /* C2_3WAY */
@@ -75,6 +77,34 @@ int c2_cob_nskey_size(const struct c2_cob_nskey *cnk)
                 c2_bitstring_len_get(&cnk->cnk_name));
 }
 
+/**
+   Make nskey for iterator. Allocate space for max possible name
+   but put real string len into the struct.
+*/
+void c2_cob_make_nskey_max(struct c2_cob_nskey **keyh, 
+                           struct c2_fid *pfid,
+                           const char *name, 
+                           int namelen)
+{
+        struct c2_cob_nskey *key;
+
+        key = c2_alloc(sizeof(*key) + NAME_MAX);
+        key->cnk_pfid = *pfid;
+        memcpy(c2_bitstring_buf_get(&key->cnk_name), name, namelen);
+        c2_bitstring_len_set(&key->cnk_name, namelen);
+        *keyh = key;
+}
+
+/**
+   Key size for iterator in which case we don't know exact length of key
+   and want to allocate it for worst case scenario, that is, for max 
+   possible name len.
+ */
+static int c2_cob_nskey_size_max(const struct c2_cob_nskey *cnk)
+{
+        return (sizeof(*cnk) + NAME_MAX);
+}
+
 /** 
    Namespace table definition
 */
@@ -209,9 +239,9 @@ int c2_cob_domain_init(struct c2_cob_domain *dom, struct c2_dbenv *env,
                            cob_dom_id_make(table, &dom->cd_id, "fo"),
                            0, &cob_omg_ops);
 	if (rc != 0) {
+                c2_table_fini(&dom->cd_fileattr_basic);
                 c2_table_fini(&dom->cd_object_index);
                 c2_table_fini(&dom->cd_namespace);
-                c2_table_fini(&dom->cd_fileattr_basic);
 		return rc;
         }
 
@@ -222,10 +252,10 @@ int c2_cob_domain_init(struct c2_cob_domain *dom, struct c2_dbenv *env,
 
 void c2_cob_domain_fini(struct c2_cob_domain *dom)
 {
-        c2_table_fini(&dom->cd_namespace);
-        c2_table_fini(&dom->cd_object_index);
-        c2_table_fini(&dom->cd_fileattr_basic);
         c2_table_fini(&dom->cd_fileattr_omg);
+        c2_table_fini(&dom->cd_fileattr_basic);
+        c2_table_fini(&dom->cd_object_index);
+        c2_table_fini(&dom->cd_namespace);
 	c2_rwlock_fini(&dom->cd_guard);
 	c2_addb_ctx_fini(&dom->cd_addb);
 }
@@ -311,7 +341,6 @@ static int cob_ns_lookup(struct c2_cob *cob, struct c2_db_tx *tx)
 			 cob->co_nskey, c2_cob_nskey_size(cob->co_nskey),
 			 &cob->co_nsrec, sizeof cob->co_nsrec);
         rc = c2_table_lookup(tx, &pair);
-
         c2_db_pair_release(&pair);
         c2_db_pair_fini(&pair);
 
@@ -352,13 +381,19 @@ static int cob_oi_lookup(struct c2_cob *cob, struct c2_db_tx *tx)
                  */
                 rc = c2_db_cursor_init(&cursor, 
                                        &cob->co_dom->cd_object_index, tx);
-                if (rc)
+                if (rc) {
+                        c2_db_pair_release(&cob->co_oipair);
+                        c2_db_pair_fini(&cob->co_oipair);
                         return rc;
+                }
 
-                c2_db_cursor_get(&cursor, &cob->co_oipair);
+                rc = c2_db_cursor_get(&cursor, &cob->co_oipair);
                 c2_db_pair_release(&cob->co_oipair);
-	        c2_db_pair_fini(&cob->co_oipair);
-                c2_db_cursor_fini(&cursor);
+                if (rc) {
+                        c2_db_pair_fini(&cob->co_oipair);
+                        c2_db_cursor_fini(&cursor);
+                        return rc;
+                }
         } else {
                 /*
                  * Let's use lookup that can return meaningful error code
@@ -366,8 +401,10 @@ static int cob_oi_lookup(struct c2_cob *cob, struct c2_db_tx *tx)
                  */
                 rc = c2_table_lookup(tx, &cob->co_oipair);
                 c2_db_pair_release(&cob->co_oipair);
-                if (rc)
+                if (rc) {
+                        c2_db_pair_fini(&cob->co_oipair);
                         return rc;
+                }
         }
 
         cob->co_nskey =
@@ -476,14 +513,24 @@ int c2_cob_lookup(struct c2_cob_domain *dom, struct c2_cob_nskey *nskey,
          * Get the fabrec here too if needed.  co_valid will be set
          * correctly inside the call so we can ignore the return code. 
          */
-        if (need & CA_FABREC)
-                cob_fab_lookup(cob, tx);
+        if (need & CA_FABREC) {
+                rc = cob_fab_lookup(cob, tx);
+                if (rc) {
+                        c2_cob_put(cob);
+                        return rc;
+                }
+        }
 
         /*
          * Get omg attributes as well if we need it.
          */
-        if (need & CA_OMGREC)
-                cob_fab_lookup(cob, tx);
+        if (need & CA_OMGREC) {
+                rc = cob_omg_lookup(cob, tx);
+                if (rc) {
+                        c2_cob_put(cob);
+                        return rc;
+                }
+        }
 
         *out = cob;
 	return rc;
@@ -517,68 +564,95 @@ int c2_cob_locate(struct c2_cob_domain *dom, struct c2_cob_oikey *oikey,
                 return rc;
         }
 
-        cob_ns_lookup(cob, tx);
-        cob_fab_lookup(cob, tx);
-        cob_omg_lookup(cob, tx);
+        rc = cob_ns_lookup(cob, tx);
+        if (rc) {
+                c2_cob_put(cob);
+                return rc;
+        }
+        rc = cob_fab_lookup(cob, tx);
+        if (rc) {
+                c2_cob_put(cob);
+                return rc;
+        }
+        rc = cob_omg_lookup(cob, tx);
+        if (rc) {
+                c2_cob_put(cob);
+                return rc;
+        }
 
         *out = cob;
 	return rc;
 }
 
 int c2_cob_iterator_init(struct c2_cob *cob, const char *name, 
-                         int namelen, struct c2_db_tx *tx)
+                         int namelen, int hint, struct c2_db_tx *tx)
 {
         int rc;
 
         /*
          * Prepare entry key using passed started pos.
-         */        
-        c2_cob_make_nskey(&cob->co_itkey, &cob->co_fid, name, namelen);
+         */
+        c2_cob_make_nskey_max(&cob->co_itkey, &cob->co_fid, name, namelen);
 
         /*
-         * Init iterator cursor.
+         * Init iterator cursor with max possible key size.
          */
         c2_db_pair_setup(&cob->co_itpair, &cob->co_dom->cd_namespace,
-			 &cob->co_itkey, c2_cob_nskey_size(cob->co_itkey), 
+			 cob->co_itkey, c2_cob_nskey_size_max(cob->co_itkey), 
 			 &cob->co_itrec, sizeof cob->co_itrec);
 
         rc = c2_db_cursor_init(&cob->co_itcursor, 
                                &cob->co_dom->cd_namespace, tx);
         if (rc) {
+                c2_db_pair_release(&cob->co_itpair);
+                c2_db_pair_fini(&cob->co_itpair);
                 c2_free(cob->co_itkey);
                 return rc;
         }
+        cob->co_ithint = hint;
         cob->co_itinit = 1;
-
         return rc;
 }
 
-int c2_cob_iterator_next(struct c2_cob *cob, struct c2_cob_nskey **key, 
-                         struct c2_cob_nsrec **rec)
+int c2_cob_iterator_next(struct c2_cob *cob)
 {
-        int   rc;
+        int rc;
 
         if (cob->co_itinit) {
                 rc = c2_db_cursor_get(&cob->co_itcursor, &cob->co_itpair);
+                if (cob->co_ithint == IH_PREV) {
+                        if (rc == 0)
+                                rc = c2_db_cursor_prev(&cob->co_itcursor, 
+                                                       &cob->co_itpair);
+                } else if (cob->co_ithint == IH_NEXT) {
+                        if (rc == 0)
+                                rc = c2_db_cursor_next(&cob->co_itcursor, 
+                                                       &cob->co_itpair);
+                } else {
+                        /*
+                         * We may want to read from most suitable position,
+                         * no need to have exact match.
+                         */
+                        if (rc == -ENOENT)
+                                rc = 0;
+                }
                 cob->co_itinit = 0;
         } else {
                 rc = c2_db_cursor_next(&cob->co_itcursor, &cob->co_itpair);
         }
 
-        if (rc == 0) {
-                *key = cob->co_itkey;
-                *rec = &cob->co_itrec;
-        }
+        if (!c2_fid_eq(&cob->co_itkey->cnk_pfid, &cob->co_fid))
+                return -ENOENT;
 
         return rc;
 }
 
 void c2_cob_iterator_fini(struct c2_cob *cob)
 {
-        c2_free(cob->co_itkey);
         c2_db_pair_release(&cob->co_itpair);
 	c2_db_pair_fini(&cob->co_itpair);
         c2_db_cursor_fini(&cob->co_itcursor);
+        c2_free(cob->co_itkey);
 }
 
 /** 
@@ -621,29 +695,39 @@ int c2_cob_create(struct c2_cob        *cob,
 
         /*
          * Allocate omgid using last allocated number + 1.
-         * Find terminator record and do prev() out of it.
+         * Find terminator record and do prev() out of it
+         * to find last allocated.
          */
         omgkey.cok_omgid = ~0ULL;
         
-        c2_db_pair_setup(&pair, &cob->co_dom->cd_fileattr_omg,
-			 &omgkey, sizeof omgkey,
-			 &cob->co_omgrec, sizeof cob->co_omgrec);
-
         rc = c2_db_cursor_init(&cursor, 
                                &cob->co_dom->cd_fileattr_omg, tx);
         if (rc)
                 return rc;
 
-        c2_db_cursor_get(&cursor, &pair);
-        c2_db_cursor_prev(&cursor, &pair);
+        c2_db_pair_setup(&pair, &cob->co_dom->cd_fileattr_omg,
+			 &omgkey, sizeof omgkey,
+			 &cob->co_omgrec, sizeof cob->co_omgrec);
+
+        rc = c2_db_cursor_get(&cursor, &pair);
+        if (rc == 0)
+                rc = c2_db_cursor_prev(&cursor, &pair);
         c2_db_pair_release(&pair);
 	c2_db_pair_fini(&pair);
         c2_db_cursor_fini(&cursor);
 
-        /*
-         * Bump last allocated omgid.
-         */
-        nsrec->cnr_omgid = ++omgkey.cok_omgid;
+        if (rc == 0) {
+                /*
+                 * Bump last allocated omgid.
+                 */
+                nsrec->cnr_omgid = ++omgkey.cok_omgid;
+        } else {
+                /*
+                 * No terminator record found, this
+                 * must be root creating.
+                 */
+                nsrec->cnr_omgid = 0;
+        }
 
         cob->co_nskey = nskey;
         cob->co_valid |= CA_NSKEY;
@@ -1007,6 +1091,8 @@ int c2_cob_update_name(struct c2_cob        *cob,
 	                 tgtkey, c2_cob_nskey_size(tgtkey),
 		         &nsrec, sizeof nsrec);
         rc = c2_db_cursor_get(&cursor, &pair);
+        c2_db_pair_release(&pair);
+        c2_db_pair_fini(&pair);
         if (rc == 0) {
                 c2_db_cursor_fini(&cursor);
                 rc = -EEXIST;
@@ -1021,7 +1107,9 @@ int c2_cob_update_name(struct c2_cob        *cob,
 		         &nsrec, sizeof nsrec);
 
         rc = c2_db_cursor_get(&cursor, &pair);
-        if (rc) {
+        c2_db_pair_release(&pair);
+        c2_db_pair_fini(&pair);
+        if (rc != 0) {
                 c2_db_cursor_fini(&cursor);
                 rc = -ENOENT;
                 C2_ADDB_ADD(&cob->co_dom->cd_addb, &cob_addb_loc, 
@@ -1034,10 +1122,11 @@ int c2_cob_update_name(struct c2_cob        *cob,
 	                 tgtkey, c2_cob_nskey_size(tgtkey),
 		         &nsrec, sizeof nsrec);
         rc = c2_db_cursor_set(&cursor, &pair);
+        c2_db_pair_release(&pair);
+        c2_db_pair_fini(&pair);
         c2_db_cursor_fini(&cursor);
         if (rc)
-                goto out;
-        
+                goto out;        
 
         /* Update object index */
         oikey.cok_fid = cob->co_fid;
diff --git a/cob/cob.h b/cob/cob.h
index 38960fa..057742f 100644
--- a/cob/cob.h
+++ b/cob/cob.h
@@ -240,7 +240,8 @@ struct c2_cob {
         struct c2_cob_nskey   *co_itkey;    /**< current iterator pos */
         struct c2_cob_nsrec    co_itrec;    /**< current iterator rec */
         struct c2_db_pair      co_itpair;   /**< used for iterator cursor */
-	int                    co_itinit;   /**< iterator just initialized */
+        int                    co_ithint;   /**< iterator hint */
+        int                    co_itinit;
 	struct c2_addb_ctx     co_addb;     /**< cob private addb ctx. */
 };
 
@@ -259,6 +260,12 @@ enum c2_cob_ca_valid {
         CA_LAYOUT     = (1 << 6),  /**< layout in cob is up-to-date */
 };
 
+enum c2_cob_iterator_hint {
+        IH_PREV      = (1 << 0),   /**< position on prev record from key */
+        IH_XTLY      = (1 << 1),   /**< position exactly on passed key */
+        IH_NEXT      = (1 << 2)    /**< position on next record from key */
+};
+
 /**
    Lookup a filename in the namespace table
 
@@ -361,14 +368,13 @@ int c2_cob_update_name(struct c2_cob        *cob,
 int c2_cob_iterator_init(struct c2_cob *cob, 
                          const char *name, 
                          int namelen, 
+                         int hint,
                          struct c2_db_tx *tx);
 
 /**
    Position to next name in a dir cob.
 */
-int c2_cob_iterator_next(struct c2_cob *cob, 
-                         struct c2_cob_nskey **key, 
-                         struct c2_cob_nsrec **rec);
+int c2_cob_iterator_next(struct c2_cob *cob);
 
 /**
    Finish cob iterator.
diff --git a/mdservice/md_foms.c b/mdservice/md_foms.c
index 25971ca..dd39682 100644
--- a/mdservice/md_foms.c
+++ b/mdservice/md_foms.c
@@ -2,6 +2,8 @@
 #  include <config.h>
 #endif
 
+#include <sys/stat.h>    /* S_ISDIR */
+
 #include "lib/misc.h"   /* C2_SET0 */
 #include "lib/cdefs.h"
 #include "lib/arith.h"   /* C2_3WAY */
@@ -536,6 +538,19 @@ out:
 
 static int c2_md_readdir_fom_perm(struct c2_fom *fom)
 {
+        struct c2_fom_md              *fom_obj;
+        struct c2_fop_readdir         *req;
+        struct c2_fop                 *fop;
+
+        fom_obj = container_of(fom, struct c2_fom_md, fm_fom);
+
+        fop = fom_obj->fm_fop;
+        C2_ASSERT(fop != NULL);
+        req = c2_fop_data(fop);
+
+        if (!S_ISDIR(req->r_body.b_mode))
+                return -EINVAL;
+
         return 0;
 }
 
@@ -590,7 +605,9 @@ static int c2_md_readdir_fom_state(struct c2_fom *fom)
         /*
          * Preallocate some number of entries for readdir.
          */
-        rep->r_vector.v_dirent = c2_alloc(C2_MD_READDIR_ENTRIES_ALLOC);
+        rep->r_vector.v_dirent = 
+            c2_alloc(C2_MD_READDIR_ENTRIES_ALLOC * 
+                     sizeof(*rep->r_vector.v_dirent));
         if (rep->r_vector.v_dirent == NULL) {
                 c2_cob_put(cob);
                 rc = -ENOMEM;
@@ -600,12 +617,12 @@ static int c2_md_readdir_fom_state(struct c2_fom *fom)
         
         for (i = 0; i < rep->r_vector.v_count; i++) {
                 ent = &rep->r_vector.v_dirent[i];
-                ent->d_name.n_name = c2_alloc(PATH_MAX);
+                ent->d_name.n_name = c2_alloc(NAME_MAX);
                 if (ent->d_name.n_name == NULL) {
                         rc = -ENOMEM;
                         break;
                 }
-                ent->d_name.n_count = PATH_MAX;
+                ent->d_name.n_count = NAME_MAX;
         }
         
         if (rc) {
diff --git a/mdservice/md_fops.ff b/mdservice/md_fops.ff
index 59c5d61..604a655 100644
--- a/mdservice/md_fops.ff
+++ b/mdservice/md_fops.ff
@@ -93,6 +93,7 @@ DEF(c2_fop_getattr_rep, RECORD,
 
 DEF(c2_fop_readdir, RECORD,
     _(r_body, c2_fop_cob),
+    _(r_hint, U32),
     _(r_pos, c2_fop_name));
 
 DEF(c2_fop_readdir_dirent, RECORD,
diff --git a/mdstore/mdstore.c b/mdstore/mdstore.c
index 094d1f8..e74ffef 100644
--- a/mdstore/mdstore.c
+++ b/mdstore/mdstore.c
@@ -41,7 +41,6 @@ int c2_md_store_init(struct c2_md_store *md,
                      struct c2_dbenv *db, 
                      int init_root)
 {
-        struct c2_cob_nskey   *nskey;
         struct c2_db_tx        tx;
         int                    rc;
 
@@ -59,10 +58,8 @@ int c2_md_store_init(struct c2_md_store *md,
         }
         if (init_root) {
                 c2_db_tx_init(&tx, db, 0);
-                
-                c2_cob_make_nskey(&nskey, &C2_MD_ROOT_FID, "ROOT", 4);
-                rc = c2_cob_lookup(&md->md_dom, nskey, CA_NSKEY_FREE, 
-                                   &md->md_root, &tx);
+                rc = c2_md_store_lookup(md, NULL, "ROOT", 4, 
+                                        &md->md_root, &tx);
                 if (rc) {
                         c2_db_tx_abort(&tx);
                 } else {
@@ -95,7 +92,7 @@ int c2_md_store_create_attr(struct c2_md_store *md,
                             struct c2_cob_omgrec *omgrec,
                             struct c2_db_tx *tx)
 {
-        int    rc;
+        int rc;
         
         rc = c2_cob_create(cob, nskey, nsrec, fabrec, omgrec, 0, tx);
         if (rc)
@@ -110,10 +107,9 @@ int c2_md_store_create_attr(struct c2_md_store *md,
                 if (rc)
                         return rc;
 
-                if (!c2_fid_eq(&cob->co_fid, &C2_MD_ROOT_FID)) {
+                if (!c2_fid_eq(&pcob->co_fid, &cob->co_fid)) {
                         /*
-                         * Add direntry ".." to empty dir. To do so we 
-                         * need parent cob first.
+                         * Add direntry ".." to empty dir.
                          */
                         rc = c2_md_store_add_name(pcob, &cob->co_fid, "..", 2, tx);
                         if (rc)
@@ -664,17 +660,20 @@ int c2_md_store_readdir(struct c2_md_store *md,
         C2_ASSERT(cob != NULL);        
 
         rc = c2_cob_iterator_init(cob, req->r_pos.n_name, 
-                                  req->r_pos.n_count, 
+                                  req->r_pos.n_count,
+                                  req->r_hint, 
                                   &ctx->fc_tx->tx_dbtx);
         if (rc)
                 goto out;
 
         vec = &rep->r_vector;
         for (count = 0; count < vec->v_count; count++) {
-                rc = c2_cob_iterator_next(cob, &nskey, &nsrec);
+                nskey = cob->co_itkey;
+                nsrec = &cob->co_itrec;
+                rc = c2_cob_iterator_next(cob);
                 if (rc)
                         break;
-                ent = &vec->v_dirent[vec->v_count++];
+                ent = &vec->v_dirent[count];
                 memcpy(ent->d_name.n_name, 
                        c2_bitstring_buf_get(&nskey->cnk_name),
                        nskey->cnk_name.b_len);
@@ -683,6 +682,18 @@ int c2_md_store_readdir(struct c2_md_store *md,
         
         vec->v_count = count;
         c2_cob_iterator_fini(cob);
+        
+        /*
+         * We have to return:
+         *  =1 - if directory end is not reached, just read requested
+         *       number of entries;
+         *  =0 - if directory end is reached;
+         *  <0 - for errors.
+         */
+        if (rc == 0)
+                rc = 1;
+        else if (rc == -ENOENT)
+                rc = 0;
 out:
         C2_ADDB_ADD(&md->md_addb, &mdstore_addb_loc, 
                     c2_addb_func_fail, "md_readdir", rc);
@@ -722,14 +733,19 @@ int c2_md_store_lookup(struct c2_md_store *md,
                        struct c2_cob *pcob,
                        const char *name, 
                        int namelen, 
-                       struct c2_cob *cob, 
+                       struct c2_cob **cob, 
                        struct c2_db_tx *tx)
 {
         struct c2_cob_nskey *nskey;
+        int                  flags;
         int                  rc;
-        
-        c2_cob_make_nskey(&nskey, &pcob->co_fid, name, namelen);
-        rc = c2_cob_lookup(&md->md_dom, nskey, CA_NSKEY_FREE, &cob, tx);
+
+        if (pcob == NULL)        
+                c2_cob_make_nskey(&nskey, &C2_MD_ROOT_FID, name, namelen);
+        else
+                c2_cob_make_nskey(&nskey, &pcob->co_fid, name, namelen);
+        flags = (CA_NSKEY_FREE | CA_FABREC | CA_OMGREC);
+        rc = c2_cob_lookup(&md->md_dom, nskey, flags, cob, tx);
 
         return rc;
 }
diff --git a/mdstore/mdstore.h b/mdstore/mdstore.h
index c004568..599b29c 100644
--- a/mdstore/mdstore.h
+++ b/mdstore/mdstore.h
@@ -208,7 +208,7 @@ int c2_md_store_lookup(struct c2_md_store *md,
                        struct c2_cob *pcob,
                        const char *name, 
                        int namelen, 
-                       struct c2_cob *cob, 
+                       struct c2_cob **cob, 
                        struct c2_db_tx *tx);
 /**
    Allocate new cob on mdstore @md.
diff --git a/utils/mkfs.colibri.c b/utils/mkfs.colibri.c
index cbb209d..896dc4f 100644
--- a/utils/mkfs.colibri.c
+++ b/utils/mkfs.colibri.c
@@ -136,7 +136,9 @@ int main(int argc, char *argv[])
         nsrec.u.cnr_size = 4096;
         nsrec.cnr_blksize = 4096;
         nsrec.cnr_blocks = 16;
-        nsrec.cnr_atime = nsrec.cnr_mtime = nsrec.cnr_ctime = time(&now);
+
+        time(&now);
+        nsrec.cnr_atime = nsrec.cnr_mtime = nsrec.cnr_ctime = now;
 
         C2_SET0(&fabrec);
 
@@ -150,15 +152,20 @@ int main(int argc, char *argv[])
                           S_IRGRP | S_IXGRP |           /* r-x for group */
                           S_IROTH | S_IXOTH;            /* r-x for others */
 
+        c2_db_tx_init(&tx, &db, 0);
+        
+        /*
+         * Create root cob.
+         */
         rc = c2_md_store_alloc(&md, &C2_MD_ROOT_FID, &cob);
         if (rc)
-                goto out_free_md;
+                goto out;
 
-        c2_db_tx_init(&tx, &db, 0);
+        rc = c2_md_store_create_attr(&md, cob, cob, nskey, 
+                                     &nsrec, &fabrec, &omgrec, 
+                                     &tx);
+        c2_cob_put(cob);
         
-        rc = c2_md_store_create_attr(&md, cob, cob, nskey, &nsrec, 
-                                     &fabrec, &omgrec, &tx);
-
         /*
          * Create terminator omgid record with id == ~0.
          */
@@ -180,13 +187,12 @@ int main(int argc, char *argv[])
         rc = c2_table_insert(&tx, &pair);
         c2_db_pair_release(&pair);
 	c2_db_pair_fini(&pair);
-
+out:
         if (rc)
                 c2_db_tx_abort(&tx);
         else
                 c2_db_tx_commit(&tx);
         c2_free(nskey);
-out_free_md:
         c2_md_store_fini(&md);
 out_free_db:
         c2_dbenv_fini(&db);
-- 
1.8.3.2

