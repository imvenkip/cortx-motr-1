From 71595abe6a5983b11dd49775318207647a3436cd Mon Sep 17 00:00:00 2001
From: Nikita Danilov <nikita_danilov@xyratex.com>
Date: Mon, 3 Sep 2012 02:35:16 +0400
Subject: [PATCH 1/3] db: new db interface implementation "trivial db" (tdb).

tdb is a new memory-only implementation of db/db.h.

It uses sorted linked lists to implement "tables". No persistency. Transaction
abort is not supported. Locking is up to user.

Unit tests pass except for:

    - cfm, cob: cobfid uses assumptions about db implementation;

    - layout: layout_update() fails for some reason;

    - yaml2db: assumes persistency.

All tests using balloc (balloc, ios-bufferpool, colibri_setup, rpclib) take ages
to complete.
---
 addb/addb_console.c                    |   2 +-
 addb/ut/addb.c                         |   5 +-
 balloc/balloc.c                        |  19 +-
 balloc/ut/balloc.c                     |   6 +-
 balloc/ut/dump_free_extent.c           |   7 +-
 balloc/ut/dump_group_desc.c            |   6 +-
 balloc/ut/dump_super_block.c           |   7 +-
 balloc/ut/format.c                     |   6 +-
 balloc/ut/free.c                       |   7 +-
 balloc/ut/mperf.c                      |   7 +-
 balloc/ut/perf.c                       |   6 +-
 build_kernel_modules/Makefile.in       |   4 +-
 build_kernel_modules/dummy_init_fini.c |  11 -
 cfg/cfg.c                              |   8 -
 cob/cob.c                              |  26 +-
 colibri/colibri_setup.c                |   3 +-
 colibri/colibri_setup.h                |   3 +-
 colibri/cs_main.c                      |   2 +-
 configure.ac                           |  11 +
 console/console_mesg.c                 |   1 +
 console/ut/console.c                   |   2 +
 db/Makefile.am                         |  12 +-
 db/db.c                                | 857 ---------------------------------
 db/db.h                                |  36 +-
 db/db5/db.h                            | 107 ++++
 db/db5/db5.c                           | 857 +++++++++++++++++++++++++++++++++
 db/db_common.c                         |  12 +
 db/db_common.h                         |   4 +
 db/db_impl.h                           | 107 ----
 db/extmap.c                            |  10 -
 db/linux_kernel/db.c                   | 588 ----------------------
 db/linux_kernel/db_impl.h              |  85 ----
 db/tdb/db.h                            |  79 +++
 db/tdb/tdb.c                           | 668 +++++++++++++++++++++++++
 db/ut/db.c                             |  24 +-
 db/ut/elist.c                          |   2 +-
 db/ut/emap.c                           |  10 -
 desim/chs.c                            |   2 +-
 desim/client.c                         |   3 +-
 desim/cnt.c                            |   2 +-
 desim/elevator.c                       |   3 +-
 desim/net.c                            |   3 +-
 desim/sim.c                            |   2 +-
 desim/ut/chs_test.c                    |   2 +-
 desim/ut/net_test.c                    |   3 +-
 fol/fol.c                              |   8 -
 fop/fom.h                              |   4 +-
 ioservice/cob_foms.c                   |   7 +-
 ioservice/cobfid_map.c                 |  91 +---
 ioservice/cobfid_map.h                 |  10 +-
 ioservice/ut/cob_foms.c                |   2 +-
 ioservice/ut/cobfid_map.c              | 100 ++--
 layout/layout.c                        |   8 -
 layout/list_enum.c                     |   8 -
 layout/ut/ldemo.c                      |   4 +-
 lib/assert.c                           |   2 +-
 lib/finject.c                          |   7 +-
 lib/getopts.c                          |   3 +-
 lib/thread.c                           |   2 +-
 lib/ub.c                               |   2 +-
 lib/user_space/finject_init.c          |   2 +-
 lib/user_space/processor.c             |   3 +-
 lib/user_space/utrace.c                |   2 +-
 lib/ut.c                               |   2 +-
 lib/ut.h                               |   2 +-
 lib/ut/processor.c                     |   3 +-
 net/bulk_emulation/mem_xprt_ep.c       |   4 +-
 net/bulk_emulation/st/main.c           |   3 +-
 net/bulk_emulation/st/ping.h           |   3 +-
 net/lnet/lnet_core.c                   |   3 +-
 net/lnet/st/main.c                     |   3 +-
 net/lnet/st/ping.h                     |   3 +-
 net/lnet/ut/lut_main.c                 |   2 +-
 net/ut/utils.c                         |   4 +-
 reqh/reqh_service.c                    |   1 +
 reqh/ut/reqh_fom_ut.c                  |   2 +-
 rpc/conn.c                             |   1 +
 rpc/it/rpc_ping.c                      |  10 +-
 rpc/rpclib.c                           |   7 +-
 rpc/rpclib.h                           |   5 +-
 rpc/session.c                          |   1 +
 rpc/slot.c                             |   1 +
 sns/ut/parity_math_mt_ub.c             |   3 +-
 stob/ad.c                              |   6 +-
 stob/linux.c                           |   3 +-
 stob/ut/ad.c                           |   1 -
 stob/ut/adieu.c                        |   2 +-
 stob/ut/stobio.c                       |   1 -
 xcode/ut/ff2c.c                        |   2 +-
 xcode/ut/xcode.c                       |   5 +-
 yaml2db/st/main.c                      |   1 +
 yaml2db/yaml2db.c                      |   2 +-
 92 files changed, 1985 insertions(+), 1993 deletions(-)
 delete mode 100644 db/db.c
 create mode 100644 db/db5/db.h
 create mode 100644 db/db5/db5.c
 delete mode 100644 db/db_impl.h
 delete mode 100644 db/linux_kernel/db.c
 delete mode 100644 db/linux_kernel/db_impl.h
 create mode 100644 db/tdb/db.h
 create mode 100644 db/tdb/tdb.c

diff --git a/addb/addb_console.c b/addb/addb_console.c
index 5659766..76627e8 100644
--- a/addb/addb_console.c
+++ b/addb/addb_console.c
@@ -22,7 +22,7 @@
 #  include "config.h"
 #endif
 
-#include <stdio.h> /* printf */
+#include "lib/string.h" /* printf */
 
 #include "addb/addb.h"
 
diff --git a/addb/ut/addb.c b/addb/ut/addb.c
index ca0b39f..6260b9e 100644
--- a/addb/ut/addb.c
+++ b/addb/ut/addb.c
@@ -18,12 +18,11 @@
  * Original creation date: 01/27/2012
  */
 
-#include <stdio.h>
-#include <string.h>
 #include <unistd.h>
 
-#include "addb/addb.h"
+#include "lib/string.h"
 #include "lib/ut.h"
+#include "addb/addb.h"
 
 struct c2_addb_ctx addb_ut_ctx;
 
diff --git a/balloc/balloc.c b/balloc/balloc.c
index e263a32..1b0a94c 100644
--- a/balloc/balloc.c
+++ b/balloc/balloc.c
@@ -25,18 +25,19 @@
 #define C2_TRACE_SUBSYSTEM C2_TRACE_SUBSYS_BALLOC
 #include "lib/trace.h"        /* C2_LOG and C2_ENTRY */
 
-#include <stdio.h>        /* sprintf */
 #include <stdlib.h>
 #include <memory.h>
 #include <sys/stat.h>
 #include <sys/time.h>
 
-#include "dtm/dtm.h"	  /* c2_dtx */
+#include "lib/string.h"   /* sprintf */
 #include "lib/misc.h"	  /* C2_SET0 */
 #include "lib/errno.h"
 #include "lib/arith.h"	  /* min_check, c2_is_po2 */
 #include "lib/memory.h"
-#include "balloc.h"
+
+#include "dtm/dtm.h"	  /* c2_dtx */
+#include "balloc/balloc.h"
 
 /**
    C2 Data Block Allocator.
@@ -233,26 +234,14 @@ static int balloc_blockno_compare(struct c2_table *t,
 }
 
 static const struct c2_table_ops c2_super_block_ops = {
-	.to = {
-		[TO_KEY] = { .max_size = sizeof (uint64_t) },
-		[TO_REC] = { .max_size = sizeof (struct c2_balloc_super_block) }
-	},
 	.key_cmp = NULL
 };
 
 static const struct c2_table_ops c2_group_extent_ops = {
-	.to = {
-		[TO_KEY] = { .max_size = sizeof (c2_bindex_t) },
-		[TO_REC] = { .max_size = sizeof (c2_bindex_t) }
-	},
 	.key_cmp = balloc_blockno_compare,
 };
 
 static const struct c2_table_ops c2_group_desc_ops = {
-	.to = {
-		[TO_KEY] = { .max_size = sizeof (c2_bindex_t) },
-		[TO_REC] = { .max_size = sizeof (struct c2_balloc_group_desc) }
-	},
 	.key_cmp = NULL
 };
 
diff --git a/balloc/ut/balloc.c b/balloc/ut/balloc.c
index 5938ced..aebf7ff 100644
--- a/balloc/ut/balloc.c
+++ b/balloc/ut/balloc.c
@@ -18,21 +18,21 @@
  * Original creation date: 09/02/2010
  */
 
-#include <stdio.h>        /* fprintf */
 #include <stdlib.h>       /* srand, rand */
 #include <errno.h>
 #include <sys/time.h>
 #include <err.h>
 
-#include "dtm/dtm.h"      /* c2_dtx */
+#include "lib/string.h"   /* fprintf */
 #include "lib/arith.h"    /* C2_3WAY, c2_uint128 */
 #include "lib/misc.h"     /* C2_SET0 */
 #include "lib/assert.h"
 #include "lib/memory.h"
 #include "lib/thread.h"
 #include "lib/getopts.h"
-#include "db/db.h"
 #include "lib/ut.h"
+#include "db/db.h"
+#include "dtm/dtm.h"      /* c2_dtx */
 #include "balloc/balloc.h"
 
 #define BALLOC_DBNAME "./__balloc_db"
diff --git a/balloc/ut/dump_free_extent.c b/balloc/ut/dump_free_extent.c
index a0b28fb..810147e 100644
--- a/balloc/ut/dump_free_extent.c
+++ b/balloc/ut/dump_free_extent.c
@@ -17,21 +17,22 @@
  * Original author: Huang Hua <hua_huang@xyratex.com>
  * Original creation date: 09/02/2010
  */
-#include <stdio.h>        /* fprintf */
+
 #include <stdlib.h>       /* srand, rand */
 #include <errno.h>
 #include <sys/time.h>
 #include <err.h>
 
-#include "dtm/dtm.h"      /* c2_dtx */
+#include "lib/string.h"   /* fprintf */
 #include "lib/arith.h"    /* C2_3WAY, c2_uint128 */
 #include "lib/misc.h"     /* C2_SET0 */
 #include "lib/assert.h"
 #include "lib/memory.h"
 #include "lib/thread.h"
 #include "lib/getopts.h"
-#include "db/db.h"
 #include "lib/ut.h"
+#include "db/db.h"
+#include "dtm/dtm.h"      /* c2_dtx */
 #include "balloc/balloc.h"
 
 int main(int argc, char **argv)
diff --git a/balloc/ut/dump_group_desc.c b/balloc/ut/dump_group_desc.c
index b6d4186..52ded21 100644
--- a/balloc/ut/dump_group_desc.c
+++ b/balloc/ut/dump_group_desc.c
@@ -18,21 +18,21 @@
  * Original creation date: 09/02/2010
  */
 
-#include <stdio.h>        /* fprintf */
 #include <stdlib.h>       /* srand, rand */
 #include <errno.h>
 #include <sys/time.h>
 #include <err.h>
 
-#include "dtm/dtm.h"      /* c2_dtx */
+#include "lib/string.h"   /* fprintf */
 #include "lib/arith.h"    /* C2_3WAY, c2_uint128 */
 #include "lib/misc.h"     /* C2_SET0 */
 #include "lib/assert.h"
 #include "lib/memory.h"
 #include "lib/thread.h"
 #include "lib/getopts.h"
-#include "db/db.h"
 #include "lib/ut.h"
+#include "db/db.h"
+#include "dtm/dtm.h"      /* c2_dtx */
 #include "balloc/balloc.h"
 
 int main(int argc, char **argv)
diff --git a/balloc/ut/dump_super_block.c b/balloc/ut/dump_super_block.c
index 7297067..542a824 100644
--- a/balloc/ut/dump_super_block.c
+++ b/balloc/ut/dump_super_block.c
@@ -17,21 +17,22 @@
  * Original author: Huang Hua <hua_huang@xyratex.com>
  * Original creation date: 09/02/2010
  */
-#include <stdio.h>        /* fprintf */
+
 #include <stdlib.h>       /* srand, rand */
 #include <errno.h>
 #include <sys/time.h>
 #include <err.h>
 
-#include "dtm/dtm.h"      /* c2_dtx */
+#include "lib/string.h"   /* fprintf */
 #include "lib/arith.h"    /* C2_3WAY, c2_uint128 */
 #include "lib/misc.h"     /* C2_SET0 */
 #include "lib/assert.h"
 #include "lib/memory.h"
 #include "lib/thread.h"
 #include "lib/getopts.h"
-#include "db/db.h"
 #include "lib/ut.h"
+#include "db/db.h"
+#include "dtm/dtm.h"      /* c2_dtx */
 #include "balloc/balloc.h"
 
 int main(int argc, char **argv)
diff --git a/balloc/ut/format.c b/balloc/ut/format.c
index b2e895c..6f5a1bd 100644
--- a/balloc/ut/format.c
+++ b/balloc/ut/format.c
@@ -18,21 +18,21 @@
  * Original creation date: 09/02/2010
  */
 
-#include <stdio.h>        /* fprintf */
 #include <stdlib.h>       /* srand, rand */
 #include <errno.h>
 #include <sys/time.h>
 #include <err.h>
 
-#include "dtm/dtm.h"      /* c2_dtx */
+#include "lib/string.h"   /* fprintf */
 #include "lib/arith.h"    /* C2_3WAY, c2_uint128 */
 #include "lib/misc.h"     /* C2_SET0 */
 #include "lib/assert.h"
 #include "lib/memory.h"
 #include "lib/thread.h"
 #include "lib/getopts.h"
-#include "db/db.h"
 #include "lib/ut.h"
+#include "db/db.h"
+#include "dtm/dtm.h"      /* c2_dtx */
 #include "balloc/balloc.h"
 
 int main(int argc, char **argv)
diff --git a/balloc/ut/free.c b/balloc/ut/free.c
index 680c905..da3aebd 100644
--- a/balloc/ut/free.c
+++ b/balloc/ut/free.c
@@ -17,21 +17,22 @@
  * Original author: Huang Hua <hua_huang@xyratex.com>
  * Original creation date: 09/02/2010
  */
-#include <stdio.h>        /* fprintf */
+
 #include <stdlib.h>       /* srand, rand */
 #include <errno.h>
 #include <sys/time.h>
 #include <err.h>
 
-#include "dtm/dtm.h"      /* c2_dtx */
+#include "lib/string.h"   /* fprintf */
 #include "lib/arith.h"    /* C2_3WAY, c2_uint128 */
 #include "lib/misc.h"     /* C2_SET0 */
 #include "lib/assert.h"
 #include "lib/memory.h"
 #include "lib/thread.h"
 #include "lib/getopts.h"
-#include "db/db.h"
 #include "lib/ut.h"
+#include "db/db.h"
+#include "dtm/dtm.h"      /* c2_dtx */
 #include "balloc/balloc.h"
 
 int main(int argc, char **argv)
diff --git a/balloc/ut/mperf.c b/balloc/ut/mperf.c
index a10fda3..524618a 100644
--- a/balloc/ut/mperf.c
+++ b/balloc/ut/mperf.c
@@ -18,21 +18,22 @@
  * Original creation date: 09/02/2010
  */
 
-#include <stdio.h>        /* fprintf */
 #include <stdlib.h>       /* srand, rand */
+#include <unistd.h>       /* usleep */
 #include <errno.h>
 #include <sys/time.h>
 #include <err.h>
 
-#include "dtm/dtm.h"      /* c2_dtx */
+#include "lib/string.h"   /* fprintf */
 #include "lib/arith.h"    /* C2_3WAY, c2_uint128 */
 #include "lib/misc.h"     /* C2_SET0 */
 #include "lib/assert.h"
 #include "lib/memory.h"
 #include "lib/thread.h"
 #include "lib/getopts.h"
-#include "db/db.h"
 #include "lib/ut.h"
+#include "db/db.h"
+#include "dtm/dtm.h"      /* c2_dtx */
 #include "balloc/balloc.h"
 
 const int MAX = 1000 * 1000;
diff --git a/balloc/ut/perf.c b/balloc/ut/perf.c
index a8b9ec6..b171029 100644
--- a/balloc/ut/perf.c
+++ b/balloc/ut/perf.c
@@ -18,21 +18,21 @@
  * Original creation date: 09/02/2010
  */
 
-#include <stdio.h>        /* fprintf */
 #include <stdlib.h>       /* srand, rand */
 #include <errno.h>
 #include <sys/time.h>
 #include <err.h>
 
-#include "dtm/dtm.h"      /* c2_dtx */
+#include "lib/string.h"   /* fprintf */
 #include "lib/arith.h"    /* C2_3WAY, c2_uint128 */
 #include "lib/misc.h"     /* C2_SET0 */
 #include "lib/assert.h"
 #include "lib/memory.h"
 #include "lib/thread.h"
 #include "lib/getopts.h"
-#include "db/db.h"
 #include "lib/ut.h"
+#include "db/db.h"
+#include "dtm/dtm.h"      /* c2_dtx */
 #include "balloc/balloc.h"
 
 const int MAX = 1000 * 1000;
diff --git a/build_kernel_modules/Makefile.in b/build_kernel_modules/Makefile.in
index d3a30d4..579021e 100644
--- a/build_kernel_modules/Makefile.in
+++ b/build_kernel_modules/Makefile.in
@@ -31,7 +31,7 @@ dirs  = addb                                                                  \
         cob                                                                   \
         colibri                                                               \
         db                                                                    \
-        db/linux_kernel                                                       \
+        db/tdb                                                                \
         dtm                                                                   \
         fid                                                                   \
         fol                                                                   \
@@ -83,7 +83,7 @@ colibri_SOURCES                 := init.c
 
 db_SOURCES                      := db_common.c
 
-db_linux_kernel_SOURCES         := db.c
+db_tdb_SOURCES                  := tdb.c
 
 dtm_SOURCES                     := verno.c dtm.c
 
diff --git a/build_kernel_modules/dummy_init_fini.c b/build_kernel_modules/dummy_init_fini.c
index 739fda1..73af383 100644
--- a/build_kernel_modules/dummy_init_fini.c
+++ b/build_kernel_modules/dummy_init_fini.c
@@ -53,17 +53,6 @@ void c2_threads_fini(void)
 
 }
 
-int c2_db_init(void)
-{
-	DUMMY_IMPLEMENTATION;
-	return 0;
-}
-
-void c2_db_fini(void)
-{
-
-}
-
 int c2_linux_stobs_init(void)
 {
 	DUMMY_IMPLEMENTATION;
diff --git a/cfg/cfg.c b/cfg/cfg.c
index 3493cd7..d186943 100644
--- a/cfg/cfg.c
+++ b/cfg/cfg.c
@@ -44,14 +44,6 @@ static int dev_key_cmp(struct c2_table *table, const void *key0,
 
 /* Table ops for disk table */
 const struct c2_table_ops c2_cfg_storage_device_table_ops = {
-        .to = {
-                [TO_KEY] = {
-			.max_size = sizeof(struct c2_cfg_storage_device__key)
-		},
-                [TO_REC] = {
-			.max_size = sizeof(struct c2_cfg_storage_device__val)
-		}
-        },
         .key_cmp = dev_key_cmp
 };
 
diff --git a/cob/cob.c b/cob/cob.c
index bbf2cc1..7b843da 100644
--- a/cob/cob.c
+++ b/cob/cob.c
@@ -31,7 +31,7 @@
 #include "lib/assert.h"
 #include "lib/memory.h"
 #include "lib/bitstring.h"
-
+#include "lib/string.h"       /* sprintf */
 #include "cob/cob.h"
 
 /**
@@ -66,14 +66,6 @@ static int ns_cmp(struct c2_table *table, const void *key0, const void *key1)
 }
 
 static const struct c2_table_ops cob_ns_ops = {
-	.to = {
-		[TO_KEY] = {
-			.max_size = ~0
-		},
-		[TO_REC] = {
-			.max_size = sizeof(struct c2_cob_nsrec)
-		}
-	},
 	.key_cmp = ns_cmp
 };
 
@@ -98,14 +90,6 @@ static int oi_cmp(struct c2_table *table, const void *key0, const void *key1)
 }
 
 static const struct c2_table_ops cob_oi_ops = {
-	.to = {
-		[TO_KEY] = {
-			.max_size = sizeof(struct c2_cob_oikey)
-		},
-		[TO_REC] = {
-			.max_size = ~0
-		}
-	},
 	.key_cmp = oi_cmp
 };
 
@@ -120,14 +104,6 @@ static int fb_cmp(struct c2_table *table, const void *key0, const void *key1)
 	return c2_stob_id_cmp(id0, id1);
 }
 static const struct c2_table_ops cob_fab_ops = {
-	.to = {
-		[TO_KEY] = {
-			.max_size = sizeof(struct c2_stob_id)
-		},
-		[TO_REC] = {
-                        .max_size = sizeof(struct c2_cob_fabrec)
-		}
-	},
 	.key_cmp = fb_cmp
 };
 
diff --git a/colibri/colibri_setup.c b/colibri/colibri_setup.c
index 137dd35..c07ece5 100644
--- a/colibri/colibri_setup.c
+++ b/colibri/colibri_setup.c
@@ -22,11 +22,10 @@
 #include "config.h"
 #endif
 
-#include <stdio.h>     /* fprintf */
 #include <sys/stat.h>  /* mkdir */
 #include <sys/types.h> /* mkdir */
-#include <string.h>    /* strtok_r, strcmp */
 
+#include "lib/string.h" /* fprintf, strtok_r, strcmp */
 #include "lib/errno.h"
 #include "lib/assert.h"
 #include "lib/memory.h"
diff --git a/colibri/colibri_setup.h b/colibri/colibri_setup.h
index c840ed9..7c68fa7 100644
--- a/colibri/colibri_setup.h
+++ b/colibri/colibri_setup.h
@@ -23,8 +23,7 @@
 #ifndef __COLIBRI_COLIBRI_COLIBRI_SETUP_H__
 #define __COLIBRI_COLIBRI_COLIBRI_SETUP_H__
 
-#include <stdio.h> /* FILE */
-
+#include "lib/string.h" /* FILE */
 #include "lib/tlist.h"
 #include "reqh/reqh_service.h"
 #include "stob/stob.h"
diff --git a/colibri/cs_main.c b/colibri/cs_main.c
index 92b06c0..6e7a5b8 100644
--- a/colibri/cs_main.c
+++ b/colibri/cs_main.c
@@ -22,10 +22,10 @@
 #include "config.h"
 #endif
 
-#include <stdio.h>     /* fprintf */
 #include <unistd.h>    /* pause */
 #include <signal.h>    /* sigaction */
 
+#include "lib/string.h" /* fprintf */
 #include "lib/errno.h"
 #include "lib/memory.h"
 #include "lib/misc.h"  /* C2_SET0 */
diff --git a/configure.ac b/configure.ac
index 7a8ce04..5aaf20a 100644
--- a/configure.ac
+++ b/configure.ac
@@ -9,6 +9,7 @@ AH_TEMPLATE([VERSION], [Version of the package.])
 AH_TEMPLATE([ENABLE_SYNC_ATOMIC], [Enable gcc built-in automic functions])
 AH_TEMPLATE([ENABLE_DEBUG], [Enable debug info.])
 AH_TEMPLATE([ENABLE_FAULT_INJECTION], [Enable fault injection.])
+AH_TEMPLATE([ENABLE_DB5], [Enable db5.])
 AH_TEMPLATE([HAVE_JOURNAL_ABORT], [Have journal_abort() function])
 AH_TEMPLATE([HAVE_FILE_READV], [Have fops->readv function])
 AH_TEMPLATE([HAVE_FILE_AIO_READ], [Have fops->aio_read function])
@@ -282,6 +283,11 @@ AC_ARG_ENABLE([mcheck],
         [enable_mcheck=no]
 )
 
+AC_ARG_ENABLE([db5],
+        [AC_HELP_STRING([--enable-db5], [enable db5 support])], [],
+        [enable_db5=no]
+)
+
 AC_ARG_ENABLE([rpm],
         [AC_HELP_STRING([--enable-rpm], [enable rpm build mode])], [],
         [enable_rpm=no]
@@ -591,6 +597,11 @@ if test x$enable_finject = xyes; then
         AC_DEFINE([ENABLE_FAULT_INJECTION])
 fi
 
+if test x$enable_db5 = xyes; then
+        AC_DEFINE([ENABLE_DB5])
+fi
+AM_CONDITIONAL([DB5], [test x$enable_db5 = xyes])
+
 if test x$enable_mcheck = xyes; then
 	LDFLAGS="$LDFLAGS -lmcheck"
 fi
diff --git a/console/console_mesg.c b/console/console_mesg.c
index 064791d..72cbce1 100644
--- a/console/console_mesg.c
+++ b/console/console_mesg.c
@@ -21,6 +21,7 @@
 #  include "config.h"
 #endif
 
+#include "lib/string.h"     /* fprintf, stdout, stderr */
 #include "lib/errno.h" /* ENOTSUP */
 
 #include "console/console_fop.h"
diff --git a/console/ut/console.c b/console/ut/console.c
index 22232ad..24dae50 100644
--- a/console/ut/console.c
+++ b/console/ut/console.c
@@ -27,6 +27,8 @@
 #endif
 
 #include <sysexits.h>
+#include <unistd.h>               /* truncate */
+#include <sys/types.h>            /* truncate */
 
 #include "lib/types.h"            /* uint64_t */
 #include "lib/ut.h"
diff --git a/db/Makefile.am b/db/Makefile.am
index 89dbb64..b001541 100644
--- a/db/Makefile.am
+++ b/db/Makefile.am
@@ -1,9 +1,15 @@
 dbdir                    = $(includedir)/colibri/db
-db_HEADERS               = db.h extmap.h extmap_internal.h db_impl.h db_common.h
+db_HEADERS               = db.h extmap.h extmap_internal.h db_common.h\
+                           db5/db.h tdb/db.h
 
 noinst_LTLIBRARIES       = libcolibri-db.la
-libcolibri_db_la_SOURCES = db.c db.h extmap.c extmap.h extmap_internal.h \
-                           db_impl.h db_common.c db_common.h
+libcolibri_db_la_SOURCES = db.h extmap.c extmap.h extmap_internal.h \
+                           db_common.c db_common.h
+if DB5 
+libcolibri_db_la_SOURCES += db5/db5.c
+else
+libcolibri_db_la_SOURCES += tdb/tdb.c
+endif
 
 INCLUDES                 = -iquote . -iquote $(top_srcdir) -iquote $(top_srcdir)/include
 
diff --git a/db/db.c b/db/db.c
deleted file mode 100644
index 8648afb..0000000
--- a/db/db.c
+++ /dev/null
@@ -1,857 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Nikita Danilov <nikita_danilov@xyratex.com>
- * Original creation date: 08/13/2010
- */
-
-#include <stdarg.h>
-#include <stdlib.h>    /* free */
-#include <sys/stat.h>  /* mkdir */
-#include <stdio.h>     /* asprintf, fopen, fclose */
-
-#include "lib/adt.h"   /* c2_buf */
-#include "lib/misc.h"  /* C2_SET0 */
-#include "lib/errno.h"
-#include "lib/assert.h"
-#include "lib/memory.h"
-
-#include "db/db.h"
-#include "db/db_common.h"
-
-/**
-   @addtogroup db
-
-   <b>db5 based implementation.</b>
-
-   Should be mostly self-evident.
-
-   An implementation emits ADDB events all db5 errors.
-
-   The natural way to implement transaction waiter would be to use a "commit
-   call-back" that gets called whenever a transaction or a group of transactions
-   becomes persistent. Alas, db5 provides no such call-back. Instead, when a
-   transaction is closed, the last LSN used by the data-base environment is
-   obtained (get_lsn()). A special per-environment thread (dbenv_thread()),
-   started by c2_dbenv_init() once a second learns (by calling
-   DBENV->log_stat()) what is the last persistent LSN and signals waiters for
-   all transactions with LSNs less than or equal to the last persistent LSN.
-
-   This solution leaves much to be desired: (i) it smells of a hack, (ii)
-   get_lsn() is perhaps too expensive to be called on each transaction
-   completion, (iii) it relies on undocumented internal structure of LSN, see
-   dbenv_thread() for details.
-
-   Alternatively, commit call-back can be added to db5.
-
-   @see http://www.oracle.com/technology/documentation/berkeley-db/db/api_reference/C/index.html
-
-   @{
- */
-
-static int key_compare(DB *db, const DBT *dbt1, const DBT *dbt2);
-static int get_lsn(struct c2_dbenv *env, DB_LSN *lsn);
-static void dbenv_thread(struct c2_dbenv *env);
-
-C2_TL_DESCR_DEFINE(enw, "env waiters", static, struct c2_db_tx_waiter,
-		   tw_env, tw_magix,
-		   C2_DB_TX_WAITER_MAGIX,
-		   0xda2edc0cc1d10515 /* dazed coccidiosis */);
-C2_TL_DEFINE(enw, static, struct c2_db_tx_waiter);
-
-
-/**
-   Convert db5 specific error code into generic errno.
-
-   This function is idempotent: dberr_conv(dberr_conv(x)) == dberr_conv(x) for
-   all x.
-
-   @see http://www.oracle.com/technology/documentation/berkeley-db/db/programmer_reference/program_errorret.html
- */
-static int dberr_conv(int db_error)
-{
-	/*
-	 * This translation is incomplete. Add more cases if you see spurious
-	 * EINVAL's. See <db.h> (DB5 header) for error constants.
-	 */
-	switch (db_error) {
-	case DB_NOTFOUND:
-		return -ENOENT;
-	case DB_LOCK_DEADLOCK:
-		return -EDEADLK;
-	case DB_KEYEXIST:
-		return -EEXIST;
-	case DB_KEYEMPTY:
-		return -ENOENT;
-	case DB_LOCK_NOTGRANTED:
-		return -ENOLCK;
-	case DB_BUFFER_SMALL:
-		return -ENOBUFS;
-	default:
-		/* As per <db.h>:
-		 *
-		 *         We don't want our error returns to conflict with
-		 *         other packages where possible, so pick a base error
-		 *         value that's hopefully not common.  We document that
-		 *         we own the error name space from -30,800 to -30,999.
-		 */
-		if (-30999 <= db_error && db_error <= -30800)
-			return -EINVAL;
-		else if (db_error > 0)
-			/* errno */
-			return -db_error;
-		else
-			return db_error;
-	}
-}
-
-/**
-   A helper to DBENV_CALL(), TABLE_CALL(), TX_CALL() and CURSOR_CALL(): converts
-   db5 error code into errno and emits an ADDB event in a given context, if
-   necessary.
- */
-static int db_call_tail(struct c2_addb_ctx *ctx, int rc, const char *name,
-			int *tolerate)
-{
-	if (rc != 0) {
-		rc = dberr_conv(rc);
-		for (; *tolerate != 0 && *tolerate != rc; tolerate++)
-			;
-		if (*tolerate == 0)
-			C2_ADDB_ADD(ctx, &db_loc, c2_addb_func_fail, name, rc);
-	}
-	return rc;
-}
-
-/**
-   Calls dbenv method (open, set_*, get_*, tx_*, etc.), converts the result to
-   errno and emits addb event if necessary.
- */
-#define DBENV_CALL(dbenv, method, ...)					\
-({									\
-	int rc;								\
-									\
-	rc = (dbenv)->d_i.d_env->method((dbenv)->d_i.d_env , ## __VA_ARGS__); \
-	db_call_tail(&(dbenv)->d_addb, rc, #method, dbenv_tol_ ## method); \
-})
-
-/**
-   Calls table method (open, get, put, etc.), converts the result to errno and
-   emits addb event if necessary.
-
-   @note c2_table_lookup() calls ->get() directly.
- */
-#define TABLE_CALL(table, method, ...)					\
-({									\
-	int rc;								\
-									\
-	rc = (table)->t_i.t_db->method((table)->t_i.t_db , ## __VA_ARGS__); \
-	db_call_tail(&(table)->t_addb, rc, #method, table_tol_ ## method); \
-})
-
-/**
-   Calls transaction method (commit, abort, etc.), converts the result to errno
-   and emits addb event if necessary.
- */
-#define TX_CALL(tx, method, ...)					\
-({									\
-	int rc;								\
-									\
-	rc = (tx)->dt_i.dt_txn->method((tx)->dt_i.dt_txn , ## __VA_ARGS__); \
-	db_call_tail(&(tx)->dt_addb, rc, #method, tx_tol_ ## method);	\
-})
-
-/**
-   Calls cursor method (get, set, close, etc.), converts the result to errno
-   and emits addb event in the context of cursor table, if necessary.
- */
-#define CURSOR_CALL(cur, method, ...)					\
-({									\
-	int rc;								\
-									\
-	rc = (cur)->c_i.c_dbc->method((cur)->c_i.c_dbc , ## __VA_ARGS__); \
-	db_call_tail(&(cur)->c_table->t_addb, rc, "dbc::" #method,	\
-		cursor_tol_ ## method);					\
-})
-
-/**
-   Helper function: opens a file with a name constructed from printf(3)-like
-   format and arguments.
- */
-static __attribute__((format(printf, 3, 4))) int
-openvar(FILE **file, const char *mode, const char *fmt, ...)
-{
-	char   *name;
-	int     nob;
-	va_list args;
-	int     result;
-
-	va_start(args, fmt);
-	nob = vasprintf(&name, fmt, args);
-	if (nob >= 0) {
-		*file = fopen(name, mode);
-		free(name);
-		result = file != NULL ? 0 : -errno;
-	} else {
-		*file = NULL;
-		result = -ENOMEM;
-	}
-	va_end(args);
-	return result;
-}
-
-static int dbenv_tol_set_verbose[] = { 0 };
-static int dbenv_tol_set_flags[] = { 0 };
-static int dbenv_tol_open[] = { 0 };
-static int dbenv_tol_close[] = { 0 };
-static int dbenv_tol_txn_begin[] = { 0 };
-static int dbenv_tol_set_lk_detect[] = { 0 };
-static int dbenv_tol_memp_sync[] = { 0 };
-static int dbenv_tol_log_flush[] = { 0 };
-static int dbenv_tol_log_cursor[] = { 0 };
-static int dbenv_tol_log_stat[] = { 0 };
-static int dbenv_tol_memp_trickle[] = { 0 };
-static int dbenv_tol_set_alloc[] = { 0 };
-static int dbenv_tol_txn_checkpoint[] = { 0 };
-
-static void *never(void *ptr, size_t size)
-{
-	C2_IMPOSSIBLE("realloc called.");
-}
-
-/**
-   Major part of c2_dbenv_init().
- */
-static int dbenv_setup(struct c2_dbenv *env, const char *name, uint64_t flags)
-{
-	int                   result;
-	DB_ENV               *de;
-	struct c2_dbenv_impl *di;
-
-	C2_SET0(env);
-
-	di = &env->d_i;
-
-	c2_dbenv_common_init(env);
-	c2_mutex_init(&di->d_lock);
-	enw_tlist_init(&di->d_waiters);
-	c2_cond_init(&di->d_shutdown_cond);
-	/*
-	 * XXX translate flags from c2 to db5.
-	 */
-	if (flags == 0)
-		flags = DB_CREATE|DB_THREAD|DB_INIT_LOG|DB_INIT_MPOOL|
-			DB_INIT_TXN|DB_INIT_LOCK|DB_RECOVER;
-
-	if (flags & DB_CREATE)
-		/* try to create home directory, don't bother to check the
-		   result, ->open() below would fail anyway. */
-		mkdir(name, 0700);
-
-	/*
-	 * Redirect db environment message stream and error streams to
-	 * appropriately named files. Alternatively, DB_ENV->set_msgcall() and
-	 * DB_ENV->set_errcall() can be used to intercept individual messages
-	 * (at the data-base environment level, corresponding
-	 * DB->set_{msg,err}call() calls can be used for table-level granularity
-	 * interception) and to emit ADDB events for them.
-	 */
-
-	result = openvar(&di->d_errlog, "a", "%s.errlog", name);
-	if (result != 0)
-		return result;
-
-	result = openvar(&di->d_msglog, "a", "%s.msglog", name);
-	if (result != 0)
-		return result;
-
-	result = db_env_create(&di->d_env, 0);
-	if (result == 0) {
-		de = di->d_env;
-		de->app_private = env;
-		de->set_msgfile(de, di->d_msglog);
-		de->set_errfile(de, di->d_errlog);
-		de->set_errpfx(de, "c2");
-		result = DBENV_CALL(env, set_verbose, DB_VERB_DEADLOCK, 1);
-		C2_ASSERT(result == 0);
-		result = DBENV_CALL(env, set_verbose, DB_VERB_WAITSFOR, 1);
-		C2_ASSERT(result == 0);
-		result = DBENV_CALL(env, set_verbose, DB_VERB_RECOVERY, 1);
-		C2_ASSERT(result == 0);
-		result = DBENV_CALL(env, set_flags, DB_TXN_NOSYNC, 1);
-		C2_ASSERT(result == 0);
-		result = DBENV_CALL(env, set_lk_detect, DB_LOCK_DEFAULT);
-		C2_ASSERT(result == 0);
-		result = DBENV_CALL(env, set_alloc, c2_alloc, never, c2_free);
-		C2_ASSERT(result == 0);
-
-		/*
-		 * XXX todo
-		 *
-		 * db5 has a plethora of data-base flags and options that could
-		 * be setup here. One goal of db/db.h interface is to insulate
-		 * its user from all these complexities. Sensible defaults must
-		 * be selected.
-		 *
-		 * DBENV_CALL(env, set_thread_count, ...);
-		 * DBENV_CALL(env, set_cachesize, ...);
-		 * DBENV_CALL(env, set_bsize, ...);
-		 * DBENV_CALL(env, set_app_dispatch, c2_fol_dispatch);
-		 *
-		 * start ->memp_trickle() thread.
-		 */
-		if (result == 0) {
-			result = DBENV_CALL(env, open, name, flags, 0700);
-			if (result == 0) {
-				result = C2_THREAD_INIT(&di->d_thread,
-							struct c2_dbenv *, NULL,
-							&dbenv_thread, env,
-							"dbenv_thread");
-				if (result == 0)
-					DBENV_CALL(env, log_cursor,
-						   &di->d_logc, 0);
-			}
-		}
-	} else
-		di->d_env = NULL;
-	return dberr_conv(result);
-}
-
-int c2_dbenv_init(struct c2_dbenv *env, const char *name, uint64_t flags)
-{
-	int result;
-
-	result = dbenv_setup(env, name, flags);
-	if (result != 0)
-		c2_dbenv_fini(env);
-	return result;
-}
-
-void c2_dbenv_fini(struct c2_dbenv *env)
-{
-	struct c2_dbenv_impl *di;
-
-	di = &env->d_i;
-	if (di->d_env != NULL) {
-		DBENV_CALL(env, memp_sync, NULL);
-		DBENV_CALL(env, log_flush, NULL);
-	}
-	if (di->d_thread.t_state == TS_RUNNING) {
-		c2_mutex_lock(&di->d_lock);
-		di->d_shutdown = true;
-		c2_cond_signal(&di->d_shutdown_cond, &di->d_lock);
-		c2_mutex_unlock(&di->d_lock);
-		c2_thread_join(&di->d_thread);
-		c2_thread_fini(&di->d_thread);
-	}
-	if (di->d_logc != NULL) {
-		di->d_logc->close(di->d_logc, 0);
-		di->d_logc = NULL;
-	}
-	if (di->d_env != NULL) {
-		DBENV_CALL(env, close, 0);
-		di->d_env = NULL;
-	}
-	if (di->d_msglog != NULL) {
-		fclose(di->d_msglog);
-		di->d_msglog = NULL;
-	}
-	if (di->d_errlog != NULL) {
-		fclose(di->d_errlog);
-		di->d_errlog = NULL;
-	}
-	c2_cond_fini(&di->d_shutdown_cond);
-	enw_tlist_fini(&di->d_waiters);
-	c2_mutex_fini(&di->d_lock);
-	c2_dbenv_common_fini(env);
-}
-
-int c2_dbenv_sync(struct c2_dbenv *env)
-{
-	return DBENV_CALL(env, txn_checkpoint, 0, 0, 0);
-}
-
-static int table_tol_set_lorder[] = { 0 };
-static int table_tol_open[] = { 0 };
-static int table_tol_close[] = { 0 };
-static int table_tol_set_bt_compare[] = { 0 };
-static int table_tol_put[] = { 0 };
-static int table_tol_get[] = { -ENOENT, 0 };
-static int table_tol_del[] = { 0 };
-static int table_tol_cursor[] = { 0 };
-static int table_tol_sync[] = { 0 };
-
-int c2_table_init(struct c2_table *table, struct c2_dbenv *env,
-		  const char *name, uint64_t flags,
-		  const struct c2_table_ops *ops)
-{
-	int result;
-	DB *db;
-
-	c2_table_common_init(table, env, ops);
-	if (flags == 0)
-		flags = DB_AUTO_COMMIT|DB_CREATE|DB_THREAD|DB_TXN_NOSYNC|
-			/*
-			 * Both a data-base and a transaction
-			 * must use "read uncommitted" to avoid
-			 * dead-locks.
-			 */
-			0/*DB_READ_UNCOMMITTED*/;
-
-	result = db_create(&table->t_i.t_db, env->d_i.d_env, 0);
-	if (result == 0) {
-		db = table->t_i.t_db;
-		db->app_private = table;
-		/* Our lord is little-endian. */
-		result = TABLE_CALL(table, set_lorder, 1234);
-		if (result == 0) {
-			if (ops->key_cmp != NULL)
-				result = TABLE_CALL(table, set_bt_compare,
-						    &key_compare);
-		}
-		if (result == 0)
-			result = TABLE_CALL(table, open, NULL, name,
-					    NULL, DB_BTREE, flags, 0700);
-	} else
-		table->t_i.t_db = NULL;
-	result = dberr_conv(result);
-	if (result != 0)
-		c2_table_fini(table);
-	return result;
-}
-
-void c2_table_fini(struct c2_table *table)
-{
-	if (table->t_i.t_db != NULL) {
-		TABLE_CALL(table, sync, 0);
-		TABLE_CALL(table, close, 0);
-		table->t_i.t_db = NULL;
-	}
-	c2_table_common_fini(table);
-}
-
-void c2_db_buf_impl_init(struct c2_db_buf *buf)
-{
-	DBT *dbt;
-
-	dbt = &buf->db_i.db_dbt;
-	dbt->data = buf->db_buf.b_addr;
-	dbt->ulen = dbt->size = buf->db_buf.b_nob;
-
-	switch (buf->db_type) {
-	case DBT_ALLOC:
-		dbt->flags = DB_DBT_MALLOC;
-		break;
-	case DBT_COPYOUT:
-		dbt->flags = DB_DBT_USERMEM;
-		break;
-	default:
-		C2_IMPOSSIBLE("Wrong buffer type.");
-	}
-}
-
-void c2_db_buf_impl_fini(struct c2_db_buf *buf)
-{
-}
-
-bool c2_db_buf_impl_invariant(const struct c2_db_buf *buf)
-{
-	return
-                buf->db_i.db_dbt.data == buf->db_buf.b_addr &&
-                (buf->db_type == DBT_ALLOC) ?
-                buf->db_i.db_dbt.size == buf->db_buf.b_nob :
-                buf->db_i.db_dbt.ulen == buf->db_buf.b_nob;
-}
-
-int c2_db_tx_init(struct c2_db_tx *tx, struct c2_dbenv *env, uint64_t flags)
-{
-	int result;
-	DB_TXN *txn;
-
-	c2_db_common_tx_init(tx, env);
-	if (flags == 0)
-		flags = 0/*DB_READ_UNCOMMITTED*/|DB_TXN_NOSYNC;
-
-	result = DBENV_CALL(env, txn_begin, NULL, &tx->dt_i.dt_txn, flags);
-	if (result == 0) {
-		txn = tx->dt_i.dt_txn;
-		/*
-		 * Hack alert: DB_TXN has no application private field similar
-		 * to {DBENV,DB}->app_private. Hijack xml_private.
-		 */
-		txn->xml_internal = tx;
-	} else
-		tx->dt_i.dt_txn = NULL;
-	result = dberr_conv(result);
-	return result;
-}
-
-static void waiter_fini(struct c2_db_tx_waiter *w)
-{
-	enw_tlink_del_fini(w);
-	w->tw_done(w);
-}
-
-static int tx_fini_pre(struct c2_db_tx *tx, bool commit)
-{
-	struct c2_db_tx_waiter *w;
-	struct c2_dbenv        *env;
-	int                     result;
-	DB_LSN                  lsn;
-
-	env = tx->dt_env;
-	if (commit && !txw_tlist_is_empty(&tx->dt_waiters)) {
-		result = get_lsn(env, &lsn);
-		if (result != 0)
-			return result;
-	}
-	c2_tl_for(txw, &tx->dt_waiters, w) {
-		txw_tlist_del(w);
-		if (!commit) {
-			w->tw_abort(w);
-			c2_mutex_lock(&env->d_i.d_lock);
-			waiter_fini(w);
-			c2_mutex_unlock(&env->d_i.d_lock);
-		} else {
-			w->tw_commit(w);
-			w->tw_i.tw_lsn = lsn;
-		}
-	} c2_tl_endfor;
-	return 0;
-}
-
-void tx_fini(struct c2_db_tx *tx)
-{
-	c2_db_common_tx_fini(tx);
-}
-
-static int tx_tol_commit[] = { 0 };
-static int tx_tol_abort[] = { 0 };
-
-int c2_db_tx_commit(struct c2_db_tx *tx)
-{
-	int result;
-
-	result = tx_fini_pre(tx, true);
-	if (result == 0)
-		result = TX_CALL(tx, commit, DB_TXN_NOSYNC);
-	tx_fini(tx);
-	return result;
-}
-
-int c2_db_tx_abort(struct c2_db_tx *tx)
-{
-	int result;
-
-	tx_fini_pre(tx, false);
-	result = TX_CALL(tx, abort);
-	tx_fini(tx);
-	return result;
-}
-
-void c2_db_tx_waiter_add(struct c2_db_tx *tx, struct c2_db_tx_waiter *w)
-{
-	struct c2_dbenv *env;
-
-	env = tx->dt_env;
-
-	c2_mutex_lock(&env->d_i.d_lock);
-	enw_tlink_init_at(w, &env->d_i.d_waiters);
-	c2_mutex_unlock(&env->d_i.d_lock);
-
-	txw_tlink_init_at(w, &tx->dt_waiters);
-}
-
-static DBT *pair_key(struct c2_db_pair *pair)
-{
-	return &pair->dp_key.db_i.db_dbt;
-}
-
-static DBT *pair_rec(struct c2_db_pair *pair)
-{
-	return &pair->dp_rec.db_i.db_dbt;
-}
-
-static void pair_prep(struct c2_db_pair *pair)
-{
-	DBT *key;
-	DBT *rec;
-
-	key = pair_key(pair);
-	rec = pair_rec(pair);
-
-	C2_PRE(c2_db_pair_invariant(pair));
-
-	if (pair->dp_key.db_type == DBT_ALLOC) {
-		c2_free(key->data);
-		key->data = NULL;
-	}
-	if (pair->dp_rec.db_type == DBT_ALLOC) {
-		c2_free(rec->data);
-		rec->data = NULL;
-	}
-}
-
-static void db_buf_done(struct c2_db_buf *buf)
-{
-	if (buf->db_type == DBT_ALLOC) {
-		buf->db_buf.b_addr = buf->db_i.db_dbt.data;
-		buf->db_buf.b_nob  = buf->db_i.db_dbt.size;
-	}
-}
-
-static void pair_done(struct c2_db_pair *pair)
-{
-	db_buf_done(&pair->dp_key);
-	db_buf_done(&pair->dp_rec);
-	C2_POST(c2_db_pair_invariant(pair));
-}
-
-#define WITH_PAIR(pair, action)			\
-({						\
-	struct c2_db_pair *__pair = (pair);	\
-	int                __result;		\
-						\
-	pair_prep(__pair);			\
-	__result = (action);			\
-	pair_done(__pair);			\
-	__result;				\
-});
-
-int c2_table_update(struct c2_db_tx *tx, struct c2_db_pair *pair)
-{
-	return WITH_PAIR(pair, TABLE_CALL(pair->dp_table, put, tx->dt_i.dt_txn,
-					  pair_key(pair), pair_rec(pair), 0));
-}
-
-int c2_table_insert(struct c2_db_tx *tx, struct c2_db_pair *pair)
-{
-	return WITH_PAIR(pair, TABLE_CALL(pair->dp_table, put, tx->dt_i.dt_txn,
-					  pair_key(pair), pair_rec(pair),
-					  DB_NOOVERWRITE));
-}
-
-int c2_table_lookup(struct c2_db_tx *tx, struct c2_db_pair *pair)
-{
-	/*
-	 * Possible optimization: if pair's DBT flags are 0, ->get() would
-	 *                        return with DBT->data pointing directly to the
-	 *                        in-db data. Returned pointer is valid until
-	 *                        _any_ call against the same DB handle is made
-	 *                        by any thread.
-	 *
-	 *                        This gives a 0-copy lookup: embed a mutex in
-	 *                        c2_table, lock it in c2_table_lookup() and
-	 *                        release in c2_db_rec_fini().
-	 *
-	 *                        DBT_INPLACE buffer type is reserved for this
-	 *                        purpose.
-	 */
-	return WITH_PAIR(pair, TABLE_CALL(pair->dp_table, get, tx->dt_i.dt_txn,
-					  pair_key(pair), pair_rec(pair),
-					  DB_RMW));
-}
-
-int c2_table_delete(struct c2_db_tx *tx, struct c2_db_pair *pair)
-{
-	return WITH_PAIR(pair, TABLE_CALL(pair->dp_table, del, tx->dt_i.dt_txn,
-					  pair_key(pair), 0));
-}
-
-int c2_db_cursor_init(struct c2_db_cursor *cursor, struct c2_table *table,
-		      struct c2_db_tx *tx, uint32_t flags)
-{
-	cursor->c_flags = 0;
-        if (flags & C2_DB_CURSOR_READ_COMMITTED)
-                cursor->c_flags |= DB_READ_COMMITTED;
-        else if (flags & C2_DB_CURSOR_READ_UNCOMMITTED)
-                cursor->c_flags |= DB_READ_UNCOMMITTED;
-        else if (flags & C2_DB_CURSOR_RMW)
-                cursor->c_flags |= DB_RMW;
-
-	cursor->c_table = table;
-	cursor->c_tx    = tx;
-	return TABLE_CALL(table, cursor, tx->dt_i.dt_txn,
-			  &cursor->c_i.c_dbc, 0);
-}
-
-static int cursor_tol_close[] = { 0 };
-static int cursor_tol_get[] = { -ENOENT, 0 };
-static int cursor_tol_put[] = { 0 };
-static int cursor_tol_del[] = { 0 };
-
-void c2_db_cursor_fini(struct c2_db_cursor *cursor)
-{
-	CURSOR_CALL(cursor, close);
-}
-
-static int cursor_get(struct c2_db_cursor *cursor, struct c2_db_pair *pair,
-		      uint32_t flags)
-{
-	return WITH_PAIR(pair, CURSOR_CALL(cursor, get, pair_key(pair),
-					   pair_rec(pair),
-                                           cursor->c_flags | flags));
-}
-
-int c2_db_cursor_get(struct c2_db_cursor *cursor, struct c2_db_pair *pair)
-{
-	return cursor_get(cursor, pair, DB_SET_RANGE);
-}
-
-int c2_db_cursor_next(struct c2_db_cursor *cursor, struct c2_db_pair *pair)
-{
-	return cursor_get(cursor, pair, DB_NEXT);
-}
-
-int c2_db_cursor_prev(struct c2_db_cursor *cursor, struct c2_db_pair *pair)
-{
-	return cursor_get(cursor, pair, DB_PREV);
-}
-
-int c2_db_cursor_first(struct c2_db_cursor *cursor, struct c2_db_pair *pair)
-{
-	return cursor_get(cursor, pair, DB_FIRST);
-}
-
-int c2_db_cursor_last(struct c2_db_cursor *cursor, struct c2_db_pair *pair)
-{
-	return cursor_get(cursor, pair, DB_LAST);
-}
-
-int c2_db_cursor_set(struct c2_db_cursor *cursor, struct c2_db_pair *pair)
-{
-	return WITH_PAIR(pair, CURSOR_CALL(cursor, put, pair_key(pair),
-					   pair_rec(pair), DB_CURRENT));
-}
-
-int c2_db_cursor_add(struct c2_db_cursor *cursor, struct c2_db_pair *pair)
-{
-	return WITH_PAIR(pair, CURSOR_CALL(cursor, put, pair_key(pair),
-					   pair_rec(pair), DB_KEYFIRST));
-}
-
-int c2_db_cursor_del(struct c2_db_cursor *cursor)
-{
-	return CURSOR_CALL(cursor, del, 0);
-}
-
-int c2_db_init(void)
-{
-	return 0;
-}
-
-void c2_db_fini(void)
-{
-}
-
-static int key_compare(DB *db, const DBT *dbt0, const DBT *dbt1)
-{
-	struct c2_table *table;
-
-	table = db->app_private;
-	C2_ASSERT(table->t_i.t_db == db);
-	C2_ASSERT(table->t_ops->key_cmp != NULL);
-	return table->t_ops->key_cmp(table, dbt0->data, dbt1->data);
-}
-
-/**
-   Returns the last LSN used by the data-base environment.
- */
-static int get_lsn(struct c2_dbenv *env, DB_LSN *lsn)
-{
-	int         rc;
-	DBT         nonce;
-	/* dummy buffer to copy last log record to. */
-	static char dummy[20000];
-
-	nonce.data  = dummy;
-	nonce.flags = DB_DBT_USERMEM;
-	nonce.ulen  = sizeof dummy;
-
-	rc = env->d_i.d_logc->get(env->d_i.d_logc, lsn, &nonce, DB_LAST);
-	return db_call_tail(&env->d_addb, rc, "logc::get", NULL);
-}
-
-/**
-   Per data-base environment thread.
-
-   This thread loops until the environment shutdown starts, doing the following:
-
-   @li de-stage some dirty pages, to guarantee some amount of free memory in the
-   pool and to make write-back smoother;
-
-   @li determine what is the last persistent LSN and signal transacaction
-   waiters accordingly;
-
-   @li sleep for some time.
- */
-static void dbenv_thread(struct c2_dbenv *env)
-{
-	bool                  last;
-	DB_LSN                next;
-	DB_LOG_STAT          *st;
-	struct c2_dbenv_impl *di;
-
-	di = &env->d_i;
-
-	C2_SET0(&next);
-	last = false;
-	do {
-		int                     rc;
-		int                     nr_pages;
-		struct c2_db_tx_waiter *w;
-		c2_time_t               deadline;
-		c2_time_t               delay;
-
-		DBENV_CALL(env, memp_trickle, 10, &nr_pages);
-		rc = DBENV_CALL(env, log_stat, &st, 0);
-		c2_mutex_lock(&di->d_lock);
-		last = di->d_shutdown;
-		if (rc == 0) {
-			/*
-			 * Reconstruct LSN from DB_LOG_STAT fields. This has
-			 * been reverse engineered from the db5 sources.
-			 */
-			next.file   = st->st_disk_file;
-			next.offset = st->st_disk_offset;
-			c2_free(st);
-			c2_tl_for(enw, &di->d_waiters, w) {
-				if (log_compare(&w->tw_i.tw_lsn, &next) <= 0) {
-					w->tw_persistent(w);
-					waiter_fini(w);
-				}
-			} c2_tl_endfor;
-		}
-		deadline = c2_time_now();
-		c2_time_set(&delay, 1, 0);
-		deadline = c2_time_add(deadline, delay);
-		c2_cond_timedwait(&di->d_shutdown_cond, &di->d_lock, deadline);
-		c2_mutex_unlock(&di->d_lock);
-	} while (!last);
-	C2_ASSERT(enw_tlist_is_empty(&env->d_i.d_waiters));
-}
-
-/** @} end of db group */
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
diff --git a/db/db.h b/db/db.h
index 73db961..c859780 100644
--- a/db/db.h
+++ b/db/db.h
@@ -31,12 +31,11 @@
    @defgroup db Data-base interfaces.
 
    This file defines interfaces for access to a simple indexing mechanism,
-   similar to data-base tables with primary index. Currently this interface is
+   similar to data-base tables with primary index. Originally this interface was
    implemented on top of Oracle db5 (nee Sleepycat's Berkeley DB) and details of
-   this implementation leak into data-structures. In the future, additional
-   implementations will be added, specifically a simple memory-only
-   implementation for Linux kernel, and the separation between generic and
-   implementation-specific state will be exacted.
+   this implementation leak into data-structures. An additional memory-only
+   implementation ("trivial db", tdb) exists, usable both in user space and
+   Linux kernel.
 
    Main data-types introduced here are:
 
@@ -65,10 +64,10 @@ struct c2_db_rec;
 struct c2_db_tx;
 struct c2_buf;
 
-#ifdef __KERNEL__
-#include "db/linux_kernel/db_impl.h"
+#if defined(ENABLE_DB5) && !defined(__KERNEL__)
+# include "db/db5/db.h"
 #else
-#include "db/db_impl.h"
+# include "db/tdb/db.h"
 #endif
 
 /** Data-base environment.
@@ -227,27 +226,6 @@ enum {
    @see c2_table
  */
 struct c2_table_ops {
-	struct {
-		/**
-		    Maximal size of key or record (as determined by the index in
-		    c2_table_ops::to).
-		 */
-		uint32_t max_size;
-		/**
-		   Convert in-memory key or record representation to in-db one.
-
-		   @note not currently used.
-		 */
-		void   (*pack)(struct c2_table *table, uint32_t *size,
-			       const void *src, void **dst);
-		/**
-		   Convert in-db key or record representation to in-memory one.
-
-		   @note not currently used.
-		 */
-		void   (*open)(struct c2_table *table, uint32_t size,
-			       const void *src, void **dst);
-	} to[TO_NR];
 	/**
 	   Key comparison function.
 
diff --git a/db/db5/db.h b/db/db5/db.h
new file mode 100644
index 0000000..adabade
--- /dev/null
+++ b/db/db5/db.h
@@ -0,0 +1,107 @@
+/* -*- C -*- */
+/*
+ * COPYRIGHT 2012 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: Nikita Danilov <nikita_danilov@xyratex.com>
+ * Original creation date: 08/13/2010
+ */
+
+#pragma once
+
+#ifndef __COLIBRI_DB_DB_IMPL_H__
+#define __COLIBRI_DB_DB_IMPL_H__
+
+#include <db.h>
+
+#include "lib/types.h"
+#include "lib/thread.h"
+#include "lib/tlist.h"
+#include "lib/mutex.h"
+#include "lib/cond.h"
+
+/**
+   @addtogroup db Data-base interfaces.
+
+   @{
+ */
+
+/**
+   db5-specific part of generic c2_dbenv.
+
+   Most fields are only updated when the environment is set up. Others (as noted
+   below) are protected by c2_dbenv_impl::d_lock.
+ */
+struct c2_dbenv_impl {
+	/** db5 private handle */
+	DB_ENV            *d_env;
+	/** File stream where error messages for this dbenv are sent to. */
+	FILE              *d_errlog;
+	/** File stream where informational messages for this dbenv are sent
+	    to. */
+	FILE              *d_msglog;
+	/** Log cursor used to determine the current LSN. */
+	DB_LOGC           *d_logc;
+	/** Lock protecting waiters list. */
+	struct c2_mutex    d_lock;
+	/** A list of waiters (c2_db_tx_waiter). Protected by
+	    c2_dbenv_impl::d_lock.  */
+	struct c2_tl       d_waiters;
+	/** Thread for asynchronous environment related work. */
+	struct c2_thread   d_thread;
+	/** True iff the environment is being shut down. Protected by
+	    c2_dbenv_impl::d_lock.*/
+	bool               d_shutdown;
+	/** Condition variable signalled on shutdown. Signalled under
+	    c2_dbenv_impl::d_lock.*/
+	struct c2_cond     d_shutdown_cond;
+};
+
+struct c2_table_impl {
+	/** db5 private table handle. */
+	DB                        *t_db;
+};
+
+struct c2_db_buf_impl {
+	DBT db_dbt;
+};
+
+struct c2_db_tx_impl {
+	/** A db5 private transaction handle. */
+	DB_TXN            *dt_txn;
+};
+
+struct c2_db_tx_waiter_impl {
+	/** An lsn from the transaction this wait is for. */
+	DB_LSN              tw_lsn;
+};
+
+struct c2_db_cursor_impl {
+	DBC             *c_dbc;
+};
+
+/** @} end of db group */
+
+/* __COLIBRI_DB_REC_H__ */
+#endif
+
+/*
+ *  Local variables:
+ *  c-indentation-style: "K&R"
+ *  c-basic-offset: 8
+ *  tab-width: 8
+ *  fill-column: 80
+ *  scroll-step: 1
+ *  End:
+ */
diff --git a/db/db5/db5.c b/db/db5/db5.c
new file mode 100644
index 0000000..0c86231
--- /dev/null
+++ b/db/db5/db5.c
@@ -0,0 +1,857 @@
+/* -*- C -*- */
+/*
+ * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: Nikita Danilov <nikita_danilov@xyratex.com>
+ * Original creation date: 08/13/2010
+ */
+
+#include <stdarg.h>
+#include <stdlib.h>    /* free */
+#include <sys/stat.h>  /* mkdir */
+
+#include "lib/string.h" /* vasprintf, fopen, fclose */
+#include "lib/adt.h"    /* c2_buf */
+#include "lib/misc.h"   /* C2_SET0 */
+#include "lib/errno.h"
+#include "lib/assert.h"
+#include "lib/memory.h"
+
+#include "db/db.h"
+#include "db/db_common.h"
+
+/**
+   @addtogroup db
+
+   <b>db5 based implementation.</b>
+
+   Should be mostly self-evident.
+
+   An implementation emits ADDB events all db5 errors.
+
+   The natural way to implement transaction waiter would be to use a "commit
+   call-back" that gets called whenever a transaction or a group of transactions
+   becomes persistent. Alas, db5 provides no such call-back. Instead, when a
+   transaction is closed, the last LSN used by the data-base environment is
+   obtained (get_lsn()). A special per-environment thread (dbenv_thread()),
+   started by c2_dbenv_init() once a second learns (by calling
+   DBENV->log_stat()) what is the last persistent LSN and signals waiters for
+   all transactions with LSNs less than or equal to the last persistent LSN.
+
+   This solution leaves much to be desired: (i) it smells of a hack, (ii)
+   get_lsn() is perhaps too expensive to be called on each transaction
+   completion, (iii) it relies on undocumented internal structure of LSN, see
+   dbenv_thread() for details.
+
+   Alternatively, commit call-back can be added to db5.
+
+   @see http://www.oracle.com/technology/documentation/berkeley-db/db/api_reference/C/index.html
+
+   @{
+ */
+
+static int key_compare(DB *db, const DBT *dbt1, const DBT *dbt2);
+static int get_lsn(struct c2_dbenv *env, DB_LSN *lsn);
+static void dbenv_thread(struct c2_dbenv *env);
+
+C2_TL_DESCR_DEFINE(enw, "env waiters", static, struct c2_db_tx_waiter,
+		   tw_env, tw_magix,
+		   C2_DB_TX_WAITER_MAGIX,
+		   0xda2edc0cc1d10515 /* dazed coccidiosis */);
+C2_TL_DEFINE(enw, static, struct c2_db_tx_waiter);
+
+
+/**
+   Convert db5 specific error code into generic errno.
+
+   This function is idempotent: dberr_conv(dberr_conv(x)) == dberr_conv(x) for
+   all x.
+
+   @see http://www.oracle.com/technology/documentation/berkeley-db/db/programmer_reference/program_errorret.html
+ */
+static int dberr_conv(int db_error)
+{
+	/*
+	 * This translation is incomplete. Add more cases if you see spurious
+	 * EINVAL's. See <db.h> (DB5 header) for error constants.
+	 */
+	switch (db_error) {
+	case DB_NOTFOUND:
+		return -ENOENT;
+	case DB_LOCK_DEADLOCK:
+		return -EDEADLK;
+	case DB_KEYEXIST:
+		return -EEXIST;
+	case DB_KEYEMPTY:
+		return -ENOENT;
+	case DB_LOCK_NOTGRANTED:
+		return -ENOLCK;
+	case DB_BUFFER_SMALL:
+		return -ENOBUFS;
+	default:
+		/* As per <db.h>:
+		 *
+		 *         We don't want our error returns to conflict with
+		 *         other packages where possible, so pick a base error
+		 *         value that's hopefully not common.  We document that
+		 *         we own the error name space from -30,800 to -30,999.
+		 */
+		if (-30999 <= db_error && db_error <= -30800)
+			return -EINVAL;
+		else if (db_error > 0)
+			/* errno */
+			return -db_error;
+		else
+			return db_error;
+	}
+}
+
+/**
+   A helper to DBENV_CALL(), TABLE_CALL(), TX_CALL() and CURSOR_CALL(): converts
+   db5 error code into errno and emits an ADDB event in a given context, if
+   necessary.
+ */
+static int db_call_tail(struct c2_addb_ctx *ctx, int rc, const char *name,
+			int *tolerate)
+{
+	if (rc != 0) {
+		rc = dberr_conv(rc);
+		for (; *tolerate != 0 && *tolerate != rc; tolerate++)
+			;
+		if (*tolerate == 0)
+			C2_ADDB_ADD(ctx, &db_loc, c2_addb_func_fail, name, rc);
+	}
+	return rc;
+}
+
+/**
+   Calls dbenv method (open, set_*, get_*, tx_*, etc.), converts the result to
+   errno and emits addb event if necessary.
+ */
+#define DBENV_CALL(dbenv, method, ...)					\
+({									\
+	int rc;								\
+									\
+	rc = (dbenv)->d_i.d_env->method((dbenv)->d_i.d_env , ## __VA_ARGS__); \
+	db_call_tail(&(dbenv)->d_addb, rc, #method, dbenv_tol_ ## method); \
+})
+
+/**
+   Calls table method (open, get, put, etc.), converts the result to errno and
+   emits addb event if necessary.
+
+   @note c2_table_lookup() calls ->get() directly.
+ */
+#define TABLE_CALL(table, method, ...)					\
+({									\
+	int rc;								\
+									\
+	rc = (table)->t_i.t_db->method((table)->t_i.t_db , ## __VA_ARGS__); \
+	db_call_tail(&(table)->t_addb, rc, #method, table_tol_ ## method); \
+})
+
+/**
+   Calls transaction method (commit, abort, etc.), converts the result to errno
+   and emits addb event if necessary.
+ */
+#define TX_CALL(tx, method, ...)					\
+({									\
+	int rc;								\
+									\
+	rc = (tx)->dt_i.dt_txn->method((tx)->dt_i.dt_txn , ## __VA_ARGS__); \
+	db_call_tail(&(tx)->dt_addb, rc, #method, tx_tol_ ## method);	\
+})
+
+/**
+   Calls cursor method (get, set, close, etc.), converts the result to errno
+   and emits addb event in the context of cursor table, if necessary.
+ */
+#define CURSOR_CALL(cur, method, ...)					\
+({									\
+	int rc;								\
+									\
+	rc = (cur)->c_i.c_dbc->method((cur)->c_i.c_dbc , ## __VA_ARGS__); \
+	db_call_tail(&(cur)->c_table->t_addb, rc, "dbc::" #method,	\
+		cursor_tol_ ## method);					\
+})
+
+/**
+   Helper function: opens a file with a name constructed from printf(3)-like
+   format and arguments.
+ */
+static __attribute__((format(printf, 3, 4))) int
+openvar(FILE **file, const char *mode, const char *fmt, ...)
+{
+	char   *name;
+	int     nob;
+	va_list args;
+	int     result;
+
+	va_start(args, fmt);
+	nob = vasprintf(&name, fmt, args);
+	if (nob >= 0) {
+		*file = fopen(name, mode);
+		free(name);
+		result = file != NULL ? 0 : -errno;
+	} else {
+		*file = NULL;
+		result = -ENOMEM;
+	}
+	va_end(args);
+	return result;
+}
+
+static int dbenv_tol_set_verbose[] = { 0 };
+static int dbenv_tol_set_flags[] = { 0 };
+static int dbenv_tol_open[] = { 0 };
+static int dbenv_tol_close[] = { 0 };
+static int dbenv_tol_txn_begin[] = { 0 };
+static int dbenv_tol_set_lk_detect[] = { 0 };
+static int dbenv_tol_memp_sync[] = { 0 };
+static int dbenv_tol_log_flush[] = { 0 };
+static int dbenv_tol_log_cursor[] = { 0 };
+static int dbenv_tol_log_stat[] = { 0 };
+static int dbenv_tol_memp_trickle[] = { 0 };
+static int dbenv_tol_set_alloc[] = { 0 };
+static int dbenv_tol_txn_checkpoint[] = { 0 };
+
+static void *never(void *ptr, size_t size)
+{
+	C2_IMPOSSIBLE("realloc called.");
+}
+
+/**
+   Major part of c2_dbenv_init().
+ */
+static int dbenv_setup(struct c2_dbenv *env, const char *name, uint64_t flags)
+{
+	int                   result;
+	DB_ENV               *de;
+	struct c2_dbenv_impl *di;
+
+	C2_SET0(env);
+
+	di = &env->d_i;
+
+	c2_dbenv_common_init(env);
+	c2_mutex_init(&di->d_lock);
+	enw_tlist_init(&di->d_waiters);
+	c2_cond_init(&di->d_shutdown_cond);
+	/*
+	 * XXX translate flags from c2 to db5.
+	 */
+	if (flags == 0)
+		flags = DB_CREATE|DB_THREAD|DB_INIT_LOG|DB_INIT_MPOOL|
+			DB_INIT_TXN|DB_INIT_LOCK|DB_RECOVER;
+
+	if (flags & DB_CREATE)
+		/* try to create home directory, don't bother to check the
+		   result, ->open() below would fail anyway. */
+		mkdir(name, 0700);
+
+	/*
+	 * Redirect db environment message stream and error streams to
+	 * appropriately named files. Alternatively, DB_ENV->set_msgcall() and
+	 * DB_ENV->set_errcall() can be used to intercept individual messages
+	 * (at the data-base environment level, corresponding
+	 * DB->set_{msg,err}call() calls can be used for table-level granularity
+	 * interception) and to emit ADDB events for them.
+	 */
+
+	result = openvar(&di->d_errlog, "a", "%s.errlog", name);
+	if (result != 0)
+		return result;
+
+	result = openvar(&di->d_msglog, "a", "%s.msglog", name);
+	if (result != 0)
+		return result;
+
+	result = db_env_create(&di->d_env, 0);
+	if (result == 0) {
+		de = di->d_env;
+		de->app_private = env;
+		de->set_msgfile(de, di->d_msglog);
+		de->set_errfile(de, di->d_errlog);
+		de->set_errpfx(de, "c2");
+		result = DBENV_CALL(env, set_verbose, DB_VERB_DEADLOCK, 1);
+		C2_ASSERT(result == 0);
+		result = DBENV_CALL(env, set_verbose, DB_VERB_WAITSFOR, 1);
+		C2_ASSERT(result == 0);
+		result = DBENV_CALL(env, set_verbose, DB_VERB_RECOVERY, 1);
+		C2_ASSERT(result == 0);
+		result = DBENV_CALL(env, set_flags, DB_TXN_NOSYNC, 1);
+		C2_ASSERT(result == 0);
+		result = DBENV_CALL(env, set_lk_detect, DB_LOCK_DEFAULT);
+		C2_ASSERT(result == 0);
+		result = DBENV_CALL(env, set_alloc, c2_alloc, never, c2_free);
+		C2_ASSERT(result == 0);
+
+		/*
+		 * XXX todo
+		 *
+		 * db5 has a plethora of data-base flags and options that could
+		 * be setup here. One goal of db/db.h interface is to insulate
+		 * its user from all these complexities. Sensible defaults must
+		 * be selected.
+		 *
+		 * DBENV_CALL(env, set_thread_count, ...);
+		 * DBENV_CALL(env, set_cachesize, ...);
+		 * DBENV_CALL(env, set_bsize, ...);
+		 * DBENV_CALL(env, set_app_dispatch, c2_fol_dispatch);
+		 *
+		 * start ->memp_trickle() thread.
+		 */
+		if (result == 0) {
+			result = DBENV_CALL(env, open, name, flags, 0700);
+			if (result == 0) {
+				result = C2_THREAD_INIT(&di->d_thread,
+							struct c2_dbenv *, NULL,
+							&dbenv_thread, env,
+							"dbenv_thread");
+				if (result == 0)
+					DBENV_CALL(env, log_cursor,
+						   &di->d_logc, 0);
+			}
+		}
+	} else
+		di->d_env = NULL;
+	return dberr_conv(result);
+}
+
+int c2_dbenv_init(struct c2_dbenv *env, const char *name, uint64_t flags)
+{
+	int result;
+
+	result = dbenv_setup(env, name, flags);
+	if (result != 0)
+		c2_dbenv_fini(env);
+	return result;
+}
+
+void c2_dbenv_fini(struct c2_dbenv *env)
+{
+	struct c2_dbenv_impl *di;
+
+	di = &env->d_i;
+	if (di->d_env != NULL) {
+		DBENV_CALL(env, memp_sync, NULL);
+		DBENV_CALL(env, log_flush, NULL);
+	}
+	if (di->d_thread.t_state == TS_RUNNING) {
+		c2_mutex_lock(&di->d_lock);
+		di->d_shutdown = true;
+		c2_cond_signal(&di->d_shutdown_cond, &di->d_lock);
+		c2_mutex_unlock(&di->d_lock);
+		c2_thread_join(&di->d_thread);
+		c2_thread_fini(&di->d_thread);
+	}
+	if (di->d_logc != NULL) {
+		di->d_logc->close(di->d_logc, 0);
+		di->d_logc = NULL;
+	}
+	if (di->d_env != NULL) {
+		DBENV_CALL(env, close, 0);
+		di->d_env = NULL;
+	}
+	if (di->d_msglog != NULL) {
+		fclose(di->d_msglog);
+		di->d_msglog = NULL;
+	}
+	if (di->d_errlog != NULL) {
+		fclose(di->d_errlog);
+		di->d_errlog = NULL;
+	}
+	c2_cond_fini(&di->d_shutdown_cond);
+	enw_tlist_fini(&di->d_waiters);
+	c2_mutex_fini(&di->d_lock);
+	c2_dbenv_common_fini(env);
+}
+
+int c2_dbenv_sync(struct c2_dbenv *env)
+{
+	return DBENV_CALL(env, txn_checkpoint, 0, 0, 0);
+}
+
+static int table_tol_set_lorder[] = { 0 };
+static int table_tol_open[] = { 0 };
+static int table_tol_close[] = { 0 };
+static int table_tol_set_bt_compare[] = { 0 };
+static int table_tol_put[] = { 0 };
+static int table_tol_get[] = { -ENOENT, 0 };
+static int table_tol_del[] = { 0 };
+static int table_tol_cursor[] = { 0 };
+static int table_tol_sync[] = { 0 };
+
+int c2_table_init(struct c2_table *table, struct c2_dbenv *env,
+		  const char *name, uint64_t flags,
+		  const struct c2_table_ops *ops)
+{
+	int result;
+	DB *db;
+
+	c2_table_common_init(table, env, ops);
+	if (flags == 0)
+		flags = DB_AUTO_COMMIT|DB_CREATE|DB_THREAD|DB_TXN_NOSYNC|
+			/*
+			 * Both a data-base and a transaction
+			 * must use "read uncommitted" to avoid
+			 * dead-locks.
+			 */
+			0/*DB_READ_UNCOMMITTED*/;
+
+	result = db_create(&table->t_i.t_db, env->d_i.d_env, 0);
+	if (result == 0) {
+		db = table->t_i.t_db;
+		db->app_private = table;
+		/* Our lord is little-endian. */
+		result = TABLE_CALL(table, set_lorder, 1234);
+		if (result == 0) {
+			if (ops->key_cmp != NULL)
+				result = TABLE_CALL(table, set_bt_compare,
+						    &key_compare);
+		}
+		if (result == 0)
+			result = TABLE_CALL(table, open, NULL, name,
+					    NULL, DB_BTREE, flags, 0700);
+	} else
+		table->t_i.t_db = NULL;
+	result = dberr_conv(result);
+	if (result != 0)
+		c2_table_fini(table);
+	return result;
+}
+
+void c2_table_fini(struct c2_table *table)
+{
+	if (table->t_i.t_db != NULL) {
+		TABLE_CALL(table, sync, 0);
+		TABLE_CALL(table, close, 0);
+		table->t_i.t_db = NULL;
+	}
+	c2_table_common_fini(table);
+}
+
+void c2_db_buf_impl_init(struct c2_db_buf *buf)
+{
+	DBT *dbt;
+
+	dbt = &buf->db_i.db_dbt;
+	dbt->data = buf->db_buf.b_addr;
+	dbt->ulen = dbt->size = buf->db_buf.b_nob;
+
+	switch (buf->db_type) {
+	case DBT_ALLOC:
+		dbt->flags = DB_DBT_MALLOC;
+		break;
+	case DBT_COPYOUT:
+		dbt->flags = DB_DBT_USERMEM;
+		break;
+	default:
+		C2_IMPOSSIBLE("Wrong buffer type.");
+	}
+}
+
+void c2_db_buf_impl_fini(struct c2_db_buf *buf)
+{
+}
+
+bool c2_db_buf_impl_invariant(const struct c2_db_buf *buf)
+{
+	return
+                buf->db_i.db_dbt.data == buf->db_buf.b_addr &&
+                (buf->db_type == DBT_ALLOC) ?
+                buf->db_i.db_dbt.size == buf->db_buf.b_nob :
+                buf->db_i.db_dbt.ulen == buf->db_buf.b_nob;
+}
+
+int c2_db_tx_init(struct c2_db_tx *tx, struct c2_dbenv *env, uint64_t flags)
+{
+	int result;
+	DB_TXN *txn;
+
+	c2_db_common_tx_init(tx, env);
+	if (flags == 0)
+		flags = 0/*DB_READ_UNCOMMITTED*/|DB_TXN_NOSYNC;
+
+	result = DBENV_CALL(env, txn_begin, NULL, &tx->dt_i.dt_txn, flags);
+	if (result == 0) {
+		txn = tx->dt_i.dt_txn;
+		/*
+		 * Hack alert: DB_TXN has no application private field similar
+		 * to {DBENV,DB}->app_private. Hijack xml_private.
+		 */
+		txn->xml_internal = tx;
+	} else
+		tx->dt_i.dt_txn = NULL;
+	result = dberr_conv(result);
+	return result;
+}
+
+static void waiter_fini(struct c2_db_tx_waiter *w)
+{
+	enw_tlink_del_fini(w);
+	w->tw_done(w);
+}
+
+static int tx_fini_pre(struct c2_db_tx *tx, bool commit)
+{
+	struct c2_db_tx_waiter *w;
+	struct c2_dbenv        *env;
+	int                     result;
+	DB_LSN                  lsn;
+
+	env = tx->dt_env;
+	if (commit && !txw_tlist_is_empty(&tx->dt_waiters)) {
+		result = get_lsn(env, &lsn);
+		if (result != 0)
+			return result;
+	}
+	c2_tl_for(txw, &tx->dt_waiters, w) {
+		txw_tlist_del(w);
+		if (!commit) {
+			w->tw_abort(w);
+			c2_mutex_lock(&env->d_i.d_lock);
+			waiter_fini(w);
+			c2_mutex_unlock(&env->d_i.d_lock);
+		} else {
+			w->tw_commit(w);
+			w->tw_i.tw_lsn = lsn;
+		}
+	} c2_tl_endfor;
+	return 0;
+}
+
+void tx_fini(struct c2_db_tx *tx)
+{
+	c2_db_common_tx_fini(tx);
+}
+
+static int tx_tol_commit[] = { 0 };
+static int tx_tol_abort[] = { 0 };
+
+int c2_db_tx_commit(struct c2_db_tx *tx)
+{
+	int result;
+
+	result = tx_fini_pre(tx, true);
+	if (result == 0)
+		result = TX_CALL(tx, commit, DB_TXN_NOSYNC);
+	tx_fini(tx);
+	return result;
+}
+
+int c2_db_tx_abort(struct c2_db_tx *tx)
+{
+	int result;
+
+	tx_fini_pre(tx, false);
+	result = TX_CALL(tx, abort);
+	tx_fini(tx);
+	return result;
+}
+
+void c2_db_tx_waiter_add(struct c2_db_tx *tx, struct c2_db_tx_waiter *w)
+{
+	struct c2_dbenv *env;
+
+	env = tx->dt_env;
+
+	c2_mutex_lock(&env->d_i.d_lock);
+	enw_tlink_init_at(w, &env->d_i.d_waiters);
+	c2_mutex_unlock(&env->d_i.d_lock);
+
+	txw_tlink_init_at(w, &tx->dt_waiters);
+}
+
+static DBT *pair_key(struct c2_db_pair *pair)
+{
+	return &pair->dp_key.db_i.db_dbt;
+}
+
+static DBT *pair_rec(struct c2_db_pair *pair)
+{
+	return &pair->dp_rec.db_i.db_dbt;
+}
+
+static void pair_prep(struct c2_db_pair *pair)
+{
+	DBT *key;
+	DBT *rec;
+
+	key = pair_key(pair);
+	rec = pair_rec(pair);
+
+	C2_PRE(c2_db_pair_invariant(pair));
+
+	if (pair->dp_key.db_type == DBT_ALLOC) {
+		c2_free(key->data);
+		key->data = NULL;
+	}
+	if (pair->dp_rec.db_type == DBT_ALLOC) {
+		c2_free(rec->data);
+		rec->data = NULL;
+	}
+}
+
+static void db_buf_done(struct c2_db_buf *buf)
+{
+	if (buf->db_type == DBT_ALLOC) {
+		buf->db_buf.b_addr = buf->db_i.db_dbt.data;
+		buf->db_buf.b_nob  = buf->db_i.db_dbt.size;
+	}
+}
+
+static void pair_done(struct c2_db_pair *pair)
+{
+	db_buf_done(&pair->dp_key);
+	db_buf_done(&pair->dp_rec);
+	C2_POST(c2_db_pair_invariant(pair));
+}
+
+#define WITH_PAIR(pair, action)			\
+({						\
+	struct c2_db_pair *__pair = (pair);	\
+	int                __result;		\
+						\
+	pair_prep(__pair);			\
+	__result = (action);			\
+	pair_done(__pair);			\
+	__result;				\
+});
+
+int c2_table_update(struct c2_db_tx *tx, struct c2_db_pair *pair)
+{
+	return WITH_PAIR(pair, TABLE_CALL(pair->dp_table, put, tx->dt_i.dt_txn,
+					  pair_key(pair), pair_rec(pair), 0));
+}
+
+int c2_table_insert(struct c2_db_tx *tx, struct c2_db_pair *pair)
+{
+	return WITH_PAIR(pair, TABLE_CALL(pair->dp_table, put, tx->dt_i.dt_txn,
+					  pair_key(pair), pair_rec(pair),
+					  DB_NOOVERWRITE));
+}
+
+int c2_table_lookup(struct c2_db_tx *tx, struct c2_db_pair *pair)
+{
+	/*
+	 * Possible optimization: if pair's DBT flags are 0, ->get() would
+	 *                        return with DBT->data pointing directly to the
+	 *                        in-db data. Returned pointer is valid until
+	 *                        _any_ call against the same DB handle is made
+	 *                        by any thread.
+	 *
+	 *                        This gives a 0-copy lookup: embed a mutex in
+	 *                        c2_table, lock it in c2_table_lookup() and
+	 *                        release in c2_db_rec_fini().
+	 *
+	 *                        DBT_INPLACE buffer type is reserved for this
+	 *                        purpose.
+	 */
+	return WITH_PAIR(pair, TABLE_CALL(pair->dp_table, get, tx->dt_i.dt_txn,
+					  pair_key(pair), pair_rec(pair),
+					  DB_RMW));
+}
+
+int c2_table_delete(struct c2_db_tx *tx, struct c2_db_pair *pair)
+{
+	return WITH_PAIR(pair, TABLE_CALL(pair->dp_table, del, tx->dt_i.dt_txn,
+					  pair_key(pair), 0));
+}
+
+int c2_db_cursor_init(struct c2_db_cursor *cursor, struct c2_table *table,
+		      struct c2_db_tx *tx, uint32_t flags)
+{
+	c2_db_common_cursor_init(cursor, table, tx);
+	cursor->c_flags = 0;
+        if (flags & C2_DB_CURSOR_READ_COMMITTED)
+                cursor->c_flags |= DB_READ_COMMITTED;
+        else if (flags & C2_DB_CURSOR_READ_UNCOMMITTED)
+                cursor->c_flags |= DB_READ_UNCOMMITTED;
+        else if (flags & C2_DB_CURSOR_RMW)
+                cursor->c_flags |= DB_RMW;
+
+	return TABLE_CALL(table, cursor, tx->dt_i.dt_txn,
+			  &cursor->c_i.c_dbc, 0);
+}
+
+static int cursor_tol_close[] = { 0 };
+static int cursor_tol_get[] = { -ENOENT, 0 };
+static int cursor_tol_put[] = { 0 };
+static int cursor_tol_del[] = { 0 };
+
+void c2_db_cursor_fini(struct c2_db_cursor *cursor)
+{
+	c2_db_common_cursor_fini(cursor);
+	CURSOR_CALL(cursor, close);
+}
+
+static int cursor_get(struct c2_db_cursor *cursor, struct c2_db_pair *pair,
+		      uint32_t flags)
+{
+	return WITH_PAIR(pair, CURSOR_CALL(cursor, get, pair_key(pair),
+					   pair_rec(pair),
+                                           cursor->c_flags | flags));
+}
+
+int c2_db_cursor_get(struct c2_db_cursor *cursor, struct c2_db_pair *pair)
+{
+	return cursor_get(cursor, pair, DB_SET_RANGE);
+}
+
+int c2_db_cursor_next(struct c2_db_cursor *cursor, struct c2_db_pair *pair)
+{
+	return cursor_get(cursor, pair, DB_NEXT);
+}
+
+int c2_db_cursor_prev(struct c2_db_cursor *cursor, struct c2_db_pair *pair)
+{
+	return cursor_get(cursor, pair, DB_PREV);
+}
+
+int c2_db_cursor_first(struct c2_db_cursor *cursor, struct c2_db_pair *pair)
+{
+	return cursor_get(cursor, pair, DB_FIRST);
+}
+
+int c2_db_cursor_last(struct c2_db_cursor *cursor, struct c2_db_pair *pair)
+{
+	return cursor_get(cursor, pair, DB_LAST);
+}
+
+int c2_db_cursor_set(struct c2_db_cursor *cursor, struct c2_db_pair *pair)
+{
+	return WITH_PAIR(pair, CURSOR_CALL(cursor, put, pair_key(pair),
+					   pair_rec(pair), DB_CURRENT));
+}
+
+int c2_db_cursor_add(struct c2_db_cursor *cursor, struct c2_db_pair *pair)
+{
+	return WITH_PAIR(pair, CURSOR_CALL(cursor, put, pair_key(pair),
+					   pair_rec(pair), DB_KEYFIRST));
+}
+
+int c2_db_cursor_del(struct c2_db_cursor *cursor)
+{
+	return CURSOR_CALL(cursor, del, 0);
+}
+
+int c2_db_init(void)
+{
+	return 0;
+}
+
+void c2_db_fini(void)
+{
+}
+
+static int key_compare(DB *db, const DBT *dbt0, const DBT *dbt1)
+{
+	struct c2_table *table;
+
+	table = db->app_private;
+	C2_ASSERT(table->t_i.t_db == db);
+	C2_ASSERT(table->t_ops->key_cmp != NULL);
+	return table->t_ops->key_cmp(table, dbt0->data, dbt1->data);
+}
+
+/**
+   Returns the last LSN used by the data-base environment.
+ */
+static int get_lsn(struct c2_dbenv *env, DB_LSN *lsn)
+{
+	int         rc;
+	DBT         nonce;
+	/* dummy buffer to copy last log record to. */
+	static char dummy[20000];
+
+	nonce.data  = dummy;
+	nonce.flags = DB_DBT_USERMEM;
+	nonce.ulen  = sizeof dummy;
+
+	rc = env->d_i.d_logc->get(env->d_i.d_logc, lsn, &nonce, DB_LAST);
+	return db_call_tail(&env->d_addb, rc, "logc::get", NULL);
+}
+
+/**
+   Per data-base environment thread.
+
+   This thread loops until the environment shutdown starts, doing the following:
+
+   @li de-stage some dirty pages, to guarantee some amount of free memory in the
+   pool and to make write-back smoother;
+
+   @li determine what is the last persistent LSN and signal transacaction
+   waiters accordingly;
+
+   @li sleep for some time.
+ */
+static void dbenv_thread(struct c2_dbenv *env)
+{
+	bool                  last;
+	DB_LSN                next;
+	DB_LOG_STAT          *st;
+	struct c2_dbenv_impl *di;
+
+	di = &env->d_i;
+
+	C2_SET0(&next);
+	last = false;
+	do {
+		int                     rc;
+		int                     nr_pages;
+		struct c2_db_tx_waiter *w;
+		c2_time_t               deadline;
+		c2_time_t               delay;
+
+		DBENV_CALL(env, memp_trickle, 10, &nr_pages);
+		rc = DBENV_CALL(env, log_stat, &st, 0);
+		c2_mutex_lock(&di->d_lock);
+		last = di->d_shutdown;
+		if (rc == 0) {
+			/*
+			 * Reconstruct LSN from DB_LOG_STAT fields. This has
+			 * been reverse engineered from the db5 sources.
+			 */
+			next.file   = st->st_disk_file;
+			next.offset = st->st_disk_offset;
+			c2_free(st);
+			c2_tl_for(enw, &di->d_waiters, w) {
+				if (log_compare(&w->tw_i.tw_lsn, &next) <= 0) {
+					w->tw_persistent(w);
+					waiter_fini(w);
+				}
+			} c2_tl_endfor;
+		}
+		deadline = c2_time_now();
+		c2_time_set(&delay, 1, 0);
+		deadline = c2_time_add(deadline, delay);
+		c2_cond_timedwait(&di->d_shutdown_cond, &di->d_lock, deadline);
+		c2_mutex_unlock(&di->d_lock);
+	} while (!last);
+	C2_ASSERT(enw_tlist_is_empty(&env->d_i.d_waiters));
+}
+
+/** @} end of db group */
+
+/*
+ *  Local variables:
+ *  c-indentation-style: "K&R"
+ *  c-basic-offset: 8
+ *  tab-width: 8
+ *  fill-column: 80
+ *  scroll-step: 1
+ *  End:
+ */
diff --git a/db/db_common.c b/db/db_common.c
index 3dda701..50efad7 100644
--- a/db/db_common.c
+++ b/db/db_common.c
@@ -179,6 +179,18 @@ void c2_db_common_tx_fini(struct c2_db_tx *tx)
 	txw_tlist_fini(&tx->dt_waiters);
 }
 
+void c2_db_common_cursor_init(struct c2_db_cursor *cur, struct c2_table *table,
+			      struct c2_db_tx *tx)
+{
+	C2_SET0(cur);
+	cur->c_table = table;
+	cur->c_tx    = tx;
+}
+
+void c2_db_common_cursor_fini(struct c2_db_cursor *cur)
+{
+}
+
 /** @} end of db group */
 
 /*
diff --git a/db/db_common.h b/db/db_common.h
index b6ee9c9..585351b 100644
--- a/db/db_common.h
+++ b/db/db_common.h
@@ -50,6 +50,10 @@ void c2_db_pair_release  (struct c2_db_pair *pair);
 void c2_db_common_tx_init(struct c2_db_tx *tx, struct c2_dbenv *env);
 void c2_db_common_tx_fini(struct c2_db_tx *tx);
 
+void c2_db_common_cursor_init(struct c2_db_cursor *cur, struct c2_table *table,
+			      struct c2_db_tx *tx);
+void c2_db_common_cursor_fini(struct c2_db_cursor *cur);
+
 extern const struct c2_addb_loc      db_loc;
 extern const struct c2_addb_ctx_type db_env_ctx_type;
 extern const struct c2_addb_ctx_type db_table_ctx_type;
diff --git a/db/db_impl.h b/db/db_impl.h
deleted file mode 100644
index adabade..0000000
--- a/db/db_impl.h
+++ /dev/null
@@ -1,107 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2012 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Nikita Danilov <nikita_danilov@xyratex.com>
- * Original creation date: 08/13/2010
- */
-
-#pragma once
-
-#ifndef __COLIBRI_DB_DB_IMPL_H__
-#define __COLIBRI_DB_DB_IMPL_H__
-
-#include <db.h>
-
-#include "lib/types.h"
-#include "lib/thread.h"
-#include "lib/tlist.h"
-#include "lib/mutex.h"
-#include "lib/cond.h"
-
-/**
-   @addtogroup db Data-base interfaces.
-
-   @{
- */
-
-/**
-   db5-specific part of generic c2_dbenv.
-
-   Most fields are only updated when the environment is set up. Others (as noted
-   below) are protected by c2_dbenv_impl::d_lock.
- */
-struct c2_dbenv_impl {
-	/** db5 private handle */
-	DB_ENV            *d_env;
-	/** File stream where error messages for this dbenv are sent to. */
-	FILE              *d_errlog;
-	/** File stream where informational messages for this dbenv are sent
-	    to. */
-	FILE              *d_msglog;
-	/** Log cursor used to determine the current LSN. */
-	DB_LOGC           *d_logc;
-	/** Lock protecting waiters list. */
-	struct c2_mutex    d_lock;
-	/** A list of waiters (c2_db_tx_waiter). Protected by
-	    c2_dbenv_impl::d_lock.  */
-	struct c2_tl       d_waiters;
-	/** Thread for asynchronous environment related work. */
-	struct c2_thread   d_thread;
-	/** True iff the environment is being shut down. Protected by
-	    c2_dbenv_impl::d_lock.*/
-	bool               d_shutdown;
-	/** Condition variable signalled on shutdown. Signalled under
-	    c2_dbenv_impl::d_lock.*/
-	struct c2_cond     d_shutdown_cond;
-};
-
-struct c2_table_impl {
-	/** db5 private table handle. */
-	DB                        *t_db;
-};
-
-struct c2_db_buf_impl {
-	DBT db_dbt;
-};
-
-struct c2_db_tx_impl {
-	/** A db5 private transaction handle. */
-	DB_TXN            *dt_txn;
-};
-
-struct c2_db_tx_waiter_impl {
-	/** An lsn from the transaction this wait is for. */
-	DB_LSN              tw_lsn;
-};
-
-struct c2_db_cursor_impl {
-	DBC             *c_dbc;
-};
-
-/** @} end of db group */
-
-/* __COLIBRI_DB_REC_H__ */
-#endif
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
diff --git a/db/extmap.c b/db/extmap.c
index 2162aa2..4c5e4f3 100644
--- a/db/extmap.c
+++ b/db/extmap.c
@@ -21,9 +21,7 @@
 #  include "config.h"
 #endif
 
-#include <stdio.h>     /* asprintf */
 #include <stdlib.h>
-#include <string.h>
 
 #include "lib/vec.h"
 #include "lib/errno.h"
@@ -102,14 +100,6 @@ static int emap_cmp(struct c2_table *table,
 }
 
 static const struct c2_table_ops emap_ops = {
-	.to = {
-		[TO_KEY] = {
-			.max_size = sizeof(struct c2_emap_key)
-		},
-		[TO_REC] = {
-			.max_size = sizeof(struct c2_emap_rec)
-		},
-	},
 	.key_cmp = emap_cmp
 };
 
diff --git a/db/linux_kernel/db.c b/db/linux_kernel/db.c
deleted file mode 100644
index 87c73f8..0000000
--- a/db/linux_kernel/db.c
+++ /dev/null
@@ -1,588 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Nikita Danilov <nikita_danilov@xyratex.com>
- * Original creation date: 09/23/2010
- */
-
-#include "lib/adt.h"   /* c2_buf */
-#include "lib/misc.h"  /* C2_SET0 */
-#include "lib/cdefs.h" /* C2_EXPORTED */
-#include "lib/arith.h" /* C2_3WAY() */
-#include "lib/errno.h"
-#include "lib/assert.h"
-#include "lib/memory.h"
-
-#include "db/db.h"
-#include "db/db_common.h"
-
-/**
-   @addtogroup db
-
-   <b>Linux kernel implementation.</b>
-
-   @{
- */
-
-C2_TL_DESCR_DEFINE(pair, "(key, rec) pairs",
-		   static, struct c2_db_kpair, dk_linkage, dk_magix,
-		   0x50c1a112ede1ffe1 /* socialized eiffel */,
-		   0x0551f1edca5cade5 /* ossified cascades */);
-C2_TL_DEFINE(pair, static, struct c2_db_kpair);
-
-static bool ktable_invariant_locked(struct c2_table *t,
-				    struct c2_table_impl *ti);
-static bool ktable_invariant(struct c2_table *t);
-
-int c2_dbenv_init(struct c2_dbenv *env, const char *name, uint64_t flags)
-{
-	c2_dbenv_common_init(env);
-	return 0;
-}
-C2_EXPORTED(c2_dbenv_init);
-
-void c2_dbenv_fini(struct c2_dbenv *env)
-{
-	c2_dbenv_common_fini(env);
-}
-C2_EXPORTED(c2_dbenv_fini);
-
-int c2_dbenv_sync(struct c2_dbenv *env)
-{
-	return 0;
-}
-
-int c2_table_init(struct c2_table *table, struct c2_dbenv *env,
-		  const char *name, uint64_t flags,
-		  const struct c2_table_ops *ops)
-{
-	c2_table_common_init(table, env, ops);
-	pair_tlist_init(&table->t_i.tk_pair);
-	c2_mutex_init(&table->t_i.tk_lock);
-	return 0;
-}
-
-void c2_table_fini(struct c2_table *table)
-{
-	struct c2_db_kpair *kpair;
-
-	C2_ASSERT(ktable_invariant(table));
-
-	c2_tl_for(pair, &table->t_i.tk_pair, kpair) {
-		pair_tlink_del_fini(kpair);
-		c2_free(kpair);
-	} c2_tl_endfor;
-	pair_tlist_fini(&table->t_i.tk_pair);
-	c2_mutex_fini(&table->t_i.tk_lock);
-	c2_table_common_fini(table);
-}
-
-int c2_db_tx_init(struct c2_db_tx *tx, struct c2_dbenv *env, uint64_t flags)
-{
-	c2_db_common_tx_init(tx, env);
-	txw_tlist_init(&tx->dt_waiters);
-	return 0;
-}
-
-int c2_db_tx_commit(struct c2_db_tx *tx)
-{
-	struct c2_db_tx_waiter *w;
-	struct c2_dbenv        *env;
-
-	env = tx->dt_env;
-	c2_tl_for(txw, &tx->dt_waiters, w) {
-		txw_tlist_del(w);
-		w->tw_commit(w);
-		w->tw_done(w);
-	} c2_tl_endfor;
-	c2_db_common_tx_fini(tx);
-	return 0;
-}
-
-int c2_db_tx_abort(struct c2_db_tx *tx)
-{
-	C2_IMPOSSIBLE("Aborting transaction in kernel space.");
-}
-
-void c2_db_tx_waiter_add(struct c2_db_tx *tx, struct c2_db_tx_waiter *w)
-{
-	txw_tlist_add(&tx->dt_waiters, w);
-}
-
-static int key_cmp(struct c2_table *t,
-		   const struct c2_buf *k0, const struct c2_buf *k1)
-{
-	if (t->t_ops->key_cmp != NULL)
-		return t->t_ops->key_cmp(t, k0->b_addr, k1->b_addr);
-	else
-		return C2_3WAY(memcmp(k0->b_addr, k1->b_addr,
-				      min_check(k0->b_nob, k1->b_nob)), 0);
-}
-
-static struct c2_db_kpair *ktable_lookup(struct c2_db_pair *pair, int *out)
-{
-	struct c2_db_kpair   *scan;
-	struct c2_table      *t;
-	struct c2_table_impl *ti;
-
-	t  = pair->dp_table;
-	ti = &t->t_i;
-	/*
-	 * Note that this should return only 0 or -ENOENT. The code below
-	 * depends on this.
-	 */
-	C2_PRE(c2_mutex_is_locked(&ti->tk_lock));
-
-	*out = -ENOENT;
-	c2_tl_for(pair, &ti->tk_pair, scan) {
-		switch (key_cmp(t, &scan->dk_key, &pair->dp_key.db_buf)) {
-		case -1:
-			continue;
-		case 0:
-			*out = 0;
-			/* fall through */
-		default:
-			break;
-		}
-	} c2_tl_endfor;
-	return scan;
-}
-
-static struct c2_db_kpair *kpair_alloc(struct c2_db_pair *pair)
-{
-	struct c2_db_kpair *kpair;
-	struct c2_buf      *key;
-	struct c2_buf      *rec;
-
-	key = &pair->dp_key.db_buf;
-	rec = &pair->dp_rec.db_buf;
-
-	C2_CASSERT((sizeof *kpair & 07) == 0);
-	C2_PRE((key->b_nob & 07) == 0);
-	C2_PRE((rec->b_nob & 07) == 0);
-
-	kpair = c2_alloc(sizeof *kpair + key->b_nob + rec->b_nob);
-	if (kpair != NULL) {
-		kpair->dk_key.b_nob = key->b_nob;
-		kpair->dk_rec.b_nob = rec->b_nob;
-		kpair->dk_key.b_addr = kpair + 1;
-		kpair->dk_rec.b_addr = kpair->dk_key.b_addr + key->b_nob;
-		memcpy(kpair->dk_key.b_addr, key->b_addr, key->b_nob);
-		memcpy(kpair->dk_rec.b_addr, rec->b_addr, rec->b_nob);
-	}
-	return kpair;
-}
-
-static int kbuf_copyout(struct c2_buf *kbuf, struct c2_db_buf *dbbuf)
-{
-	struct c2_buf *ubuf;
-
-	ubuf = &dbbuf->db_buf;
-	if (dbbuf->db_type == DBT_ALLOC) {
-		C2_ASSERT(ubuf->b_addr == NULL);
-		ubuf->b_addr = c2_alloc(kbuf->b_nob);
-		if (ubuf->b_addr == NULL)
-			return -ENOMEM;
-		ubuf->b_nob = kbuf->b_nob;
-	}
-	C2_ASSERT(ubuf->b_addr != NULL);
-	if (ubuf->b_nob < kbuf->b_nob)
-		return -ENOBUFS;
-	memcpy(ubuf->b_addr, kbuf->b_addr, kbuf->b_nob);
-	return 0;
-}
-
-static int kpair_copyout(struct c2_db_kpair *kpair, struct c2_db_pair *pair)
-{
-	int result;
-
-	/*
-	 * XXX this might return an error after modifying the pair.
-	 */
-
-	result = kbuf_copyout(&kpair->dk_key, &pair->dp_key);
-	if (result == 0)
-		result = kbuf_copyout(&kpair->dk_rec, &pair->dp_rec);
-	return result;
-}
-
-static void pair_lock(struct c2_db_pair *pair)
-{
-	c2_mutex_lock(&pair->dp_table->t_i.tk_lock);
-}
-
-static void pair_unlock(struct c2_db_pair *pair)
-{
-	c2_mutex_unlock(&pair->dp_table->t_i.tk_lock);
-}
-
-static struct c2_tl *pair_list(struct c2_db_pair *pair)
-{
-	return &pair->dp_table->t_i.tk_pair;
-}
-
-int c2_table_update(struct c2_db_tx *tx, struct c2_db_pair *pair)
-{
-	struct c2_db_kpair *replacement;
-	struct c2_db_kpair *kpair;
-	int                 result;
-
-	C2_ASSERT(ktable_invariant(pair->dp_table));
-
-	replacement = kpair_alloc(pair);
-	if (replacement != NULL) {
-		pair_lock(pair);
-		kpair = ktable_lookup(pair, &result);
-		if (result == 0) {
-			pair_tlist_add_after(kpair, replacement);
-			pair_tlink_del_fini(kpair);
-			c2_free(kpair);
-		} else
-			c2_free(replacement);
-		pair_unlock(pair);
-	} else
-		result = -ENOMEM;
-
-	C2_ASSERT(ktable_invariant(pair->dp_table));
-	return result;
-}
-
-int table_insert(struct c2_db_pair *pair, struct c2_db_kpair **kpair_out)
-{
-	struct c2_db_kpair *newkp;
-	struct c2_db_kpair *kpair;
-	int                 result;
-
-	C2_ASSERT(ktable_invariant(pair->dp_table));
-
-	newkp = kpair_alloc(pair);
-	if (newkp != NULL) {
-		int out;
-
-		pair_lock(pair);
-		kpair = ktable_lookup(pair, &out);
-		if (out == -ENOENT) {
-			pair_tlist_add_before(kpair, newkp);
-			*kpair_out = newkp;
-			result = 0;
-		} else {
-			c2_free(newkp);
-			result = -EEXIST;
-		}
-		pair_unlock(pair);
-	} else
-		result = -ENOMEM;
-	C2_ASSERT(ktable_invariant(pair->dp_table));
-	return result;
-}
-
-int c2_table_insert(struct c2_db_tx *tx, struct c2_db_pair *pair)
-{
-	struct c2_db_kpair *dummy;
-
-	return table_insert(pair, &dummy);
-}
-
-int c2_table_lookup(struct c2_db_tx *tx, struct c2_db_pair *pair)
-{
-	int                 result;
-	struct c2_db_kpair *kpair;
-
-	C2_ASSERT(ktable_invariant(pair->dp_table));
-
-	pair_lock(pair);
-	kpair = ktable_lookup(pair, &result);
-	if (result == 0)
-		kpair_copyout(kpair, pair);
-	pair_unlock(pair);
-	return result;
-}
-
-int c2_table_delete(struct c2_db_tx *tx, struct c2_db_pair *pair)
-{
-	int                 result;
-	struct c2_db_kpair *kpair;
-
-	C2_ASSERT(ktable_invariant(pair->dp_table));
-
-	pair_lock(pair);
-	kpair = ktable_lookup(pair, &result);
-	if (result == 0) {
-		pair_tlink_del_fini(kpair);
-		c2_free(kpair);
-	}
-	pair_unlock(pair);
-
-	C2_ASSERT(ktable_invariant(pair->dp_table));
-
-	return result;
-}
-
-int c2_db_cursor_init(struct c2_db_cursor *cursor, struct c2_table *table,
-		      struct c2_db_tx *tx, uint32_t flags)
-{
-	C2_SET0(cursor);
-	return 0;
-}
-
-void c2_db_cursor_fini(struct c2_db_cursor *cursor)
-{
-}
-
-int c2_db_cursor_get(struct c2_db_cursor *cursor, struct c2_db_pair *pair)
-{
-	int result;
-
-	C2_PRE(cursor->c_table == pair->dp_table);
-	C2_ASSERT(ktable_invariant(pair->dp_table));
-
-	c2_mutex_lock(&cursor->c_table->t_i.tk_lock);
-	cursor->c_i.ck_current = ktable_lookup(pair, &result);
-	if (result == 0)
-		kpair_copyout(cursor->c_i.ck_current, pair);
-	c2_mutex_unlock(&cursor->c_table->t_i.tk_lock);
-	return result;
-}
-
-int c2_db_cursor_next(struct c2_db_cursor *cursor, struct c2_db_pair *pair)
-{
-	struct c2_db_cursor_impl *ci;
-	int                       result;
-	struct c2_db_kpair       *next;
-
-	C2_PRE(cursor->c_table == pair->dp_table);
-	C2_ASSERT(ktable_invariant(pair->dp_table));
-
-	ci = &cursor->c_i;
-
-	if (ci->ck_current == NULL)
-		result = -EINVAL;
-	else {
-		pair_lock(pair);
-		next = pair_tlist_next(pair_list(pair), ci->ck_current);
-		if (next == NULL)
-			result = -ENOENT;
-		else {
-			ci->ck_current = next;
-			result = kpair_copyout(ci->ck_current, pair);
-		}
-		pair_unlock(pair);
-	}
-	return result;
-}
-
-int c2_db_cursor_prev(struct c2_db_cursor *cursor, struct c2_db_pair *pair)
-{
-	struct c2_db_cursor_impl *ci;
-	int                       result;
-	struct c2_db_kpair       *prev;
-
-	C2_PRE(cursor->c_table == pair->dp_table);
-	C2_ASSERT(ktable_invariant(pair->dp_table));
-
-	ci = &cursor->c_i;
-
-	if (ci->ck_current == NULL)
-		result = -EINVAL;
-	else {
-		pair_lock(pair);
-		prev = pair_tlist_prev(pair_list(pair), ci->ck_current);
-		if (prev == NULL)
-			result = -ENOENT;
-		else {
-			ci->ck_current = prev;
-			result = kpair_copyout(ci->ck_current, pair);
-		}
-		pair_unlock(pair);
-	}
-	return result;
-}
-
-int c2_db_cursor_first(struct c2_db_cursor *cursor, struct c2_db_pair *pair)
-{
-	struct c2_db_cursor_impl *ci;
-	struct c2_tl             *pl;
-	int                       result;
-	struct c2_db_kpair       *first;
-
-	C2_PRE(cursor->c_table == pair->dp_table);
-	C2_ASSERT(ktable_invariant(pair->dp_table));
-
-	ci = &cursor->c_i;
-	pl = pair_list(pair);
-
-	pair_lock(pair);
-	first = pair_tlist_head(pl);
-	if (first == NULL)
-		result = -ENOENT;
-	else {
-		ci->ck_current = first;
-		kpair_copyout(ci->ck_current, pair);
-		result = 0;
-	}
-	pair_unlock(pair);
-	return result;
-}
-
-int c2_db_cursor_last(struct c2_db_cursor *cursor, struct c2_db_pair *pair)
-{
-	struct c2_db_cursor_impl *ci;
-	struct c2_tl             *pl;
-	int                       result;
-	struct c2_db_kpair       *last;
-
-	C2_PRE(cursor->c_table == pair->dp_table);
-	C2_ASSERT(ktable_invariant(pair->dp_table));
-
-	ci = &cursor->c_i;
-	pl = pair_list(pair);
-
-	pair_lock(pair);
-	last = pair_tlist_tail(pl);
-	if (last == NULL)
-		result = -ENOENT;
-	else {
-		ci->ck_current = last;
-		kpair_copyout(ci->ck_current, pair);
-		result = 0;
-	}
-	pair_unlock(pair);
-	return result;
-}
-
-int c2_db_cursor_set(struct c2_db_cursor *cursor, struct c2_db_pair *pair)
-{
-	struct c2_db_cursor_impl *ci;
-	struct c2_db_kpair       *newkp;
-	struct c2_db_kpair       *cur;
-	struct c2_db_pair         replacement;
-	int                       result;
-
-	C2_PRE(cursor->c_table == pair->dp_table);
-	C2_ASSERT(ktable_invariant(pair->dp_table));
-
-	ci = &cursor->c_i;
-
-	cur = ci->ck_current;
-	if (cur == NULL)
-		return -EINVAL;
-
-	/* XXX accessing kpair without table mutex. */
-	c2_db_pair_setup(&replacement, pair->dp_table,
-			 cur->dk_key.b_addr, cur->dk_key.b_nob,
-			 pair->dp_rec.db_buf.b_addr, pair->dp_rec.db_buf.b_nob);
-
-	newkp = kpair_alloc(&replacement);
-	if (newkp != NULL) {
-		pair_lock(pair);
-		pair_tlist_add_after(cur, newkp);
-		pair_tlink_del_fini(cur);
-		c2_free(cur);
-		ci->ck_current = newkp;
-		pair_unlock(pair);
-		result = 0;
-	} else
-		result = -ENOMEM;
-
-	C2_ASSERT(ktable_invariant(pair->dp_table));
-
-	return result;
-}
-
-int c2_db_cursor_add(struct c2_db_cursor *cursor, struct c2_db_pair *pair)
-{
-	C2_PRE(cursor->c_table == pair->dp_table);
-
-	return table_insert(pair, &cursor->c_i.ck_current);
-}
-
-int c2_db_cursor_del(struct c2_db_cursor *cursor)
-{
-	struct c2_db_cursor_impl *ci;
-	struct c2_table_impl     *ti;
-	int                       result;
-
-	C2_ASSERT(ktable_invariant(cursor->c_table));
-
-	ci = &cursor->c_i;
-	ti = &cursor->c_table->t_i;
-
-	if (ci->ck_current != NULL) {
-		c2_mutex_lock(&ti->tk_lock);
-		pair_tlink_del_fini(ci->ck_current);
-		c2_free(ci->ck_current);
-		ci->ck_current = NULL;
-		c2_mutex_unlock(&ti->tk_lock);
-		result = 0;
-	} else
-		result = -EINVAL;
-	C2_ASSERT(ktable_invariant(cursor->c_table));
-	return result;
-}
-
-void c2_db_buf_impl_init(struct c2_db_buf *buf)
-{
-}
-
-void c2_db_buf_impl_fini(struct c2_db_buf *buf)
-{
-}
-
-bool c2_db_buf_impl_invariant(const struct c2_db_buf *buf)
-{
-	return true;
-}
-
-static bool ktable_invariant_locked(struct c2_table *t,
-				    struct c2_table_impl *ti)
-{
-	struct c2_tl *tkp = &t->t_i.tk_pair;
-
-	return
-		c2_tlist_invariant(&pair_tl, tkp) &&
-		c2_tl_forall(pair, scan, tkp,
-			     scan->dk_key.b_addr == scan + 1 &&
-			     scan->dk_rec.b_addr ==
-			     scan->dk_key.b_addr + scan->dk_key.b_nob &&
-			     ergo(pair_tlist_prev(tkp, scan) != NULL,
-				  key_cmp(t, &pair_tlist_prev(tkp, scan)->dk_key,
-					  &scan->dk_key) == -1));
-}
-
-static bool ktable_invariant(struct c2_table *t)
-{
-	bool                  result;
-	struct c2_table_impl *ti;
-
-	ti = &t->t_i;
-
-	c2_mutex_lock(&ti->tk_lock);
-	result = ktable_invariant_locked(t, ti);
-	c2_mutex_unlock(&ti->tk_lock);
-	return result;
-}
-
-/** @} end of db group */
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
diff --git a/db/linux_kernel/db_impl.h b/db/linux_kernel/db_impl.h
deleted file mode 100644
index f1b5023..0000000
--- a/db/linux_kernel/db_impl.h
+++ /dev/null
@@ -1,85 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2012 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Nikita Danilov <nikita_danilov@xyratex.com>
- * Original creation date: 09/23/2010
- */
-
-#pragma once
-
-#ifndef __COLIBRI_DB_LINUX_KERNEL_DB_IMPL_H__
-#define __COLIBRI_DB_LINUX_KERNEL_DB_IMPL_H__
-
-#include "lib/tlist.h"
-#include "lib/mutex.h"
-
-/**
-   @addtogroup db Data-base interfaces.
-
-   <b>Linux kernel implementation.</b>
-
-   @{
- */
-
-struct c2_dbenv_impl {
-};
-
-struct c2_table_impl {
-	/**
-	   Kernel "table" is simply a list of pairs in memory.
-	 */
-	struct c2_tl    tk_pair;
-	struct c2_mutex tk_lock;
-};
-
-struct c2_db_buf_impl {
-};
-
-struct c2_db_tx_impl {
-};
-
-struct c2_db_tx_waiter_impl {
-};
-
-/**
-   (key, record) pair in a kernel memory.
- */
-struct c2_db_kpair {
-	uint64_t        dk_magix;
-	struct c2_tlink dk_linkage;
-	struct c2_buf   dk_key;
-	struct c2_buf   dk_rec;
-	/* followed by dk_key.a_nob + dk_rec.a_nob bytes */
-};
-
-struct c2_db_cursor_impl {
-	struct c2_db_kpair *ck_current;
-};
-
-/** @} end of db group */
-
-/* __COLIBRI_DB_LINUX_KERNEL_DB_IMPL_H__ */
-#endif
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
diff --git a/db/tdb/db.h b/db/tdb/db.h
new file mode 100644
index 0000000..08d17cb
--- /dev/null
+++ b/db/tdb/db.h
@@ -0,0 +1,79 @@
+/* -*- C -*- */
+/*
+ * COPYRIGHT 2012 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: Nikita Danilov <nikita_danilov@xyratex.com>
+ * Original creation date: 09/23/2010
+ */
+
+#pragma once
+
+#ifndef __COLIBRI_DB_LINUX_KERNEL_DB_IMPL_H__
+#define __COLIBRI_DB_LINUX_KERNEL_DB_IMPL_H__
+
+#include "lib/tlist.h"
+#include "lib/mutex.h"
+
+/**
+   @addtogroup db Data-base interfaces.
+
+   <b>Linux kernel implementation.</b>
+
+   @{
+ */
+
+/* defined in db/tdb/tdb.c */
+struct kpair;
+
+struct c2_dbenv_impl {
+};
+
+struct c2_table_impl {
+	/**
+	   Kernel "table" is simply a list of pairs in memory.
+	 */
+	struct c2_tl    tk_pair;
+	struct c2_mutex tk_lock;
+};
+
+struct c2_db_buf_impl {
+};
+
+struct c2_db_tx_impl {
+	struct c2_tl ti_plank;
+};
+
+struct c2_db_tx_waiter_impl {
+};
+
+
+struct c2_db_cursor_impl {
+	struct kpair *ck_current;
+};
+
+/** @} end of db group */
+
+/* __COLIBRI_DB_LINUX_KERNEL_DB_IMPL_H__ */
+#endif
+
+/*
+ *  Local variables:
+ *  c-indentation-style: "K&R"
+ *  c-basic-offset: 8
+ *  tab-width: 8
+ *  fill-column: 80
+ *  scroll-step: 1
+ *  End:
+ */
diff --git a/db/tdb/tdb.c b/db/tdb/tdb.c
new file mode 100644
index 0000000..a4d50d2
--- /dev/null
+++ b/db/tdb/tdb.c
@@ -0,0 +1,668 @@
+/* -*- C -*- */
+/*
+ * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: Nikita Danilov <nikita_danilov@xyratex.com>
+ * Original creation date: 09/23/2010
+ */
+
+#include "lib/adt.h"   /* c2_buf */
+#include "lib/misc.h"  /* C2_SET0 */
+#include "lib/cdefs.h" /* C2_EXPORTED */
+#include "lib/arith.h" /* C2_3WAY() */
+#include "lib/errno.h"
+#include "lib/assert.h"
+#include "lib/memory.h"
+
+#include "db/db.h"
+#include "db/db_common.h"
+
+/**
+   @addtogroup db
+
+   <b>Linux kernel implementation.</b>
+
+   @{
+ */
+
+/**
+   (key, record) pair in a kernel memory.
+ */
+struct kpair {
+	uint64_t         dk_magix;
+	struct c2_table *dk_table;
+	struct c2_tlink  dk_deathrow;
+	struct c2_tlink  dk_linkage;
+	struct c2_buf    dk_key;
+	struct c2_buf    dk_rec;
+	/* followed by dk_key.a_nob + dk_rec.a_nob bytes */
+};
+
+enum {
+	KPAIR_MAGIX = 0x50c1a112ede1ffe1 /* socialized eiffel */
+};
+
+C2_TL_DESCR_DEFINE(pair, "(key, rec) pairs",
+		   static, struct kpair, dk_linkage, dk_magix,
+		   KPAIR_MAGIX, 0x0551f1edca5cade5 /* ossified cascades */);
+C2_TL_DEFINE(pair, static, struct kpair);
+
+C2_TL_DESCR_DEFINE(plank, "moribund pairs",
+		   static, struct kpair, dk_deathrow, dk_magix,
+		   KPAIR_MAGIX, 0x33B00B0CCACC1077 /* boo Boccaccio */);
+C2_TL_DEFINE(plank, static, struct kpair);
+
+static bool ktable_invariant_locked(struct c2_table *t,
+				    struct c2_table_impl *ti);
+static bool ktable_invariant(struct c2_table *t);
+
+int c2_dbenv_init(struct c2_dbenv *env, const char *name, uint64_t flags)
+{
+	c2_dbenv_common_init(env);
+	return 0;
+}
+C2_EXPORTED(c2_dbenv_init);
+
+void c2_dbenv_fini(struct c2_dbenv *env)
+{
+	c2_dbenv_common_fini(env);
+}
+C2_EXPORTED(c2_dbenv_fini);
+
+int c2_dbenv_sync(struct c2_dbenv *env)
+{
+	return 0;
+}
+
+int c2_table_init(struct c2_table *table, struct c2_dbenv *env,
+		  const char *name, uint64_t flags,
+		  const struct c2_table_ops *ops)
+{
+	c2_table_common_init(table, env, ops);
+	pair_tlist_init(&table->t_i.tk_pair);
+	c2_mutex_init(&table->t_i.tk_lock);
+	return 0;
+}
+
+void c2_table_fini(struct c2_table *table)
+{
+	struct kpair *kpair;
+
+	C2_ASSERT(ktable_invariant(table));
+
+	c2_tl_for(pair, &table->t_i.tk_pair, kpair) {
+		C2_ASSERT(!plank_tlink_is_in(kpair));
+		pair_tlink_del_fini(kpair);
+		c2_free(kpair);
+	} c2_tl_endfor;
+	pair_tlist_fini(&table->t_i.tk_pair);
+	c2_mutex_fini(&table->t_i.tk_lock);
+	c2_table_common_fini(table);
+}
+
+int c2_db_tx_init(struct c2_db_tx *tx, struct c2_dbenv *env, uint64_t flags)
+{
+	c2_db_common_tx_init(tx, env);
+	txw_tlist_init(&tx->dt_waiters);
+	plank_tlist_init(&tx->dt_i.ti_plank);
+	return 0;
+}
+
+static void kpairs_kill(struct c2_db_tx *tx)
+{
+	struct kpair *scan;
+
+	c2_tl_for(plank, &tx->dt_i.ti_plank, scan) {
+		c2_mutex_lock(&scan->dk_table->t_i.tk_lock);
+		pair_tlink_del_fini(scan);
+		c2_mutex_unlock(&scan->dk_table->t_i.tk_lock);
+		plank_tlink_del_fini(scan);
+		c2_free(scan);
+	} c2_tl_endfor;
+	plank_tlist_fini(&tx->dt_i.ti_plank);
+}
+
+static void kpair_plank(struct c2_db_tx *tx, struct kpair *kpair)
+{
+	C2_PRE(!plank_tlink_is_in(kpair));
+	plank_tlist_add(&tx->dt_i.ti_plank, kpair);
+}
+
+int c2_db_tx_commit(struct c2_db_tx *tx)
+{
+	struct c2_db_tx_waiter *w;
+	struct c2_dbenv        *env;
+
+	kpairs_kill(tx);
+	env = tx->dt_env;
+	c2_tl_for(txw, &tx->dt_waiters, w) {
+		txw_tlist_del(w);
+		w->tw_commit(w);
+		w->tw_done(w);
+	} c2_tl_endfor;
+	c2_db_common_tx_fini(tx);
+	return 0;
+}
+
+int c2_db_tx_abort(struct c2_db_tx *tx)
+{
+	kpairs_kill(tx);
+	C2_IMPOSSIBLE("Aborting transaction in tdb.");
+}
+
+void c2_db_tx_waiter_add(struct c2_db_tx *tx, struct c2_db_tx_waiter *w)
+{
+	txw_tlist_add(&tx->dt_waiters, w);
+}
+
+static int key_cmp(struct c2_table *t,
+		   const struct c2_buf *k0, const struct c2_buf *k1)
+{
+	if (t->t_ops->key_cmp != NULL)
+		return t->t_ops->key_cmp(t, k0->b_addr, k1->b_addr);
+	else
+		return C2_3WAY(memcmp(k0->b_addr, k1->b_addr,
+				      min_check(k0->b_nob, k1->b_nob)), 0);
+}
+
+static struct kpair *ktable_lookup(struct c2_db_pair *pair, int *out)
+{
+	struct kpair         *scan;
+	struct c2_table      *t;
+	struct c2_table_impl *ti;
+
+	/*
+	 * Note that this function should return only 0 or -ENOENT in "out". The
+	 * code below depends on this.
+	 */
+
+	t  = pair->dp_table;
+	ti = &t->t_i;
+	C2_PRE(c2_mutex_is_locked(&ti->tk_lock));
+
+	*out = -ENOENT;
+	c2_tl_for(pair, &ti->tk_pair, scan) {
+		if (plank_tlink_is_in(scan))
+			continue;
+		switch (key_cmp(t, &scan->dk_key, &pair->dp_key.db_buf)) {
+		case -1:
+			continue;
+		case 0:
+			*out = 0;
+			/* fall through */
+		}
+		break;
+	} c2_tl_endfor;
+	return scan;
+}
+
+static struct kpair *kpair_alloc(struct c2_db_pair *pair)
+{
+	struct kpair  *kpair;
+	struct c2_buf *key;
+	struct c2_buf *rec;
+
+	key = &pair->dp_key.db_buf;
+	rec = &pair->dp_rec.db_buf;
+
+	kpair = c2_alloc(sizeof *kpair + key->b_nob + rec->b_nob);
+	if (kpair != NULL) {
+		kpair->dk_table = pair->dp_table;
+		kpair->dk_key.b_nob = key->b_nob;
+		kpair->dk_rec.b_nob = rec->b_nob;
+		kpair->dk_key.b_addr = kpair + 1;
+		kpair->dk_rec.b_addr = kpair->dk_key.b_addr + key->b_nob;
+		memcpy(kpair->dk_key.b_addr, key->b_addr, key->b_nob);
+		memcpy(kpair->dk_rec.b_addr, rec->b_addr, rec->b_nob);
+		pair_tlink_init(kpair);
+		plank_tlink_init(kpair);
+	}
+	return kpair;
+}
+
+static int kbuf_copyout(struct c2_buf *kbuf, struct c2_db_buf *dbbuf)
+{
+	struct c2_buf *ubuf;
+
+	ubuf = &dbbuf->db_buf;
+	if (dbbuf->db_type == DBT_ALLOC) {
+		C2_ASSERT(ubuf->b_addr == NULL);
+		ubuf->b_addr = c2_alloc(kbuf->b_nob);
+		if (ubuf->b_addr == NULL)
+			return -ENOMEM;
+		ubuf->b_nob = kbuf->b_nob;
+	}
+	C2_ASSERT(ubuf->b_addr != NULL);
+	if (ubuf->b_nob < kbuf->b_nob)
+		return -ENOBUFS;
+	memcpy(ubuf->b_addr, kbuf->b_addr, kbuf->b_nob);
+	return 0;
+}
+
+static int kpair_copyout(struct kpair *kpair, struct c2_db_pair *pair)
+{
+	int result;
+
+	/*
+	 * XXX this might return an error after modifying the pair.
+	 */
+
+	result = kbuf_copyout(&kpair->dk_key, &pair->dp_key);
+	if (result == 0)
+		result = kbuf_copyout(&kpair->dk_rec, &pair->dp_rec);
+	return result;
+}
+
+static void pair_lock(struct c2_db_pair *pair)
+{
+	c2_mutex_lock(&pair->dp_table->t_i.tk_lock);
+}
+
+static void pair_unlock(struct c2_db_pair *pair)
+{
+	c2_mutex_unlock(&pair->dp_table->t_i.tk_lock);
+}
+
+static struct c2_tl *pair_list(struct c2_db_pair *pair)
+{
+	return &pair->dp_table->t_i.tk_pair;
+}
+
+int c2_table_update(struct c2_db_tx *tx, struct c2_db_pair *pair)
+{
+	struct kpair *replacement;
+	struct kpair *kpair;
+	int                 result;
+
+	C2_ASSERT(ktable_invariant(pair->dp_table));
+
+	replacement = kpair_alloc(pair);
+	if (replacement != NULL) {
+		pair_lock(pair);
+		kpair = ktable_lookup(pair, &result);
+		if (result == 0) {
+			pair_tlist_add_after(kpair, replacement);
+			kpair_plank(tx, kpair);
+		} else
+			c2_free(replacement);
+		pair_unlock(pair);
+	} else
+		result = -ENOMEM;
+
+	C2_ASSERT(ktable_invariant(pair->dp_table));
+	return result;
+}
+
+int table_insert(struct c2_db_pair *pair, struct kpair **kpair_out)
+{
+	struct kpair *newkp;
+	struct kpair *kpair;
+	int                 result;
+
+	C2_ASSERT(ktable_invariant(pair->dp_table));
+
+	newkp = kpair_alloc(pair);
+	if (newkp != NULL) {
+		int out;
+
+		pair_lock(pair);
+		kpair = ktable_lookup(pair, &out);
+		if (out == -ENOENT) {
+			if (kpair != NULL)
+				pair_tlist_add_before(kpair, newkp);
+			else
+				pair_tlist_add_tail(pair_list(pair), newkp);
+			*kpair_out = newkp;
+			result = 0;
+		} else {
+			c2_free(newkp);
+			result = -EEXIST;
+		}
+		pair_unlock(pair);
+	} else
+		result = -ENOMEM;
+	C2_ASSERT(ktable_invariant(pair->dp_table));
+	return result;
+}
+
+int c2_table_insert(struct c2_db_tx *tx, struct c2_db_pair *pair)
+{
+	struct kpair *dummy;
+
+	return table_insert(pair, &dummy);
+}
+
+int c2_table_lookup(struct c2_db_tx *tx, struct c2_db_pair *pair)
+{
+	int                 result;
+	struct kpair *kpair;
+
+	C2_ASSERT(ktable_invariant(pair->dp_table));
+
+	pair_lock(pair);
+	kpair = ktable_lookup(pair, &result);
+	if (result == 0)
+		kpair_copyout(kpair, pair);
+	pair_unlock(pair);
+	return result;
+}
+
+int c2_table_delete(struct c2_db_tx *tx, struct c2_db_pair *pair)
+{
+	int           result;
+	struct kpair *kpair;
+
+	C2_ASSERT(ktable_invariant(pair->dp_table));
+
+	pair_lock(pair);
+	kpair = ktable_lookup(pair, &result);
+	if (result == 0)
+		kpair_plank(tx, kpair);
+	pair_unlock(pair);
+
+	C2_ASSERT(ktable_invariant(pair->dp_table));
+
+	return result;
+}
+
+int c2_db_cursor_init(struct c2_db_cursor *cursor, struct c2_table *table,
+		      struct c2_db_tx *tx, uint32_t flags)
+{
+	c2_db_common_cursor_init(cursor, table, tx);
+	return 0;
+}
+
+void c2_db_cursor_fini(struct c2_db_cursor *cursor)
+{
+	c2_db_common_cursor_fini(cursor);
+}
+
+static struct kpair *kpair_fix_next(struct c2_table *t, struct kpair *cur)
+{
+	while (cur != NULL && plank_tlink_is_in(cur))
+		cur = pair_tlist_next(&t->t_i.tk_pair, cur);
+	return cur;
+}
+
+static struct kpair *kpair_fix_prev(struct c2_table *t, struct kpair *cur)
+{
+	while (cur != NULL && plank_tlink_is_in(cur))
+		cur = pair_tlist_prev(&t->t_i.tk_pair, cur);
+	return cur;
+}
+
+int c2_db_cursor_get(struct c2_db_cursor *cursor, struct c2_db_pair *pair)
+{
+	int result;
+
+	C2_PRE(cursor->c_table == pair->dp_table);
+	C2_ASSERT(ktable_invariant(pair->dp_table));
+
+	c2_mutex_lock(&cursor->c_table->t_i.tk_lock);
+	cursor->c_i.ck_current = ktable_lookup(pair, &result);
+	/*
+	 * ktable_lookup() sets result to 0 when exact match was
+	 * found. Otherwise result is -ENOENT and it returns "insertion point"
+	 * or NULL, when the key looked for is larger than all keys in the
+	 * table. Return error (-ENOENT) in the latter case and 0 otherwise.
+	 */
+	if (cursor->c_i.ck_current != NULL) {
+		kpair_copyout(cursor->c_i.ck_current, pair);
+		result = 0;
+	}
+	c2_mutex_unlock(&cursor->c_table->t_i.tk_lock);
+	return result;
+}
+
+int c2_db_cursor_next(struct c2_db_cursor *cursor, struct c2_db_pair *pair)
+{
+	struct c2_db_cursor_impl *ci;
+	int                       result;
+	struct kpair             *next;
+
+	C2_PRE(cursor->c_table == pair->dp_table);
+	C2_ASSERT(ktable_invariant(pair->dp_table));
+
+	ci = &cursor->c_i;
+
+	if (ci->ck_current == NULL)
+		result = -EINVAL;
+	else {
+		pair_lock(pair);
+		next = kpair_fix_next(cursor->c_table,
+				      pair_tlist_next(pair_list(pair),
+						      ci->ck_current));
+		if (next == NULL)
+			result = -ENOENT;
+		else {
+			ci->ck_current = next;
+			result = kpair_copyout(ci->ck_current, pair);
+		}
+		pair_unlock(pair);
+	}
+	return result;
+}
+
+int c2_db_cursor_prev(struct c2_db_cursor *cursor, struct c2_db_pair *pair)
+{
+	struct c2_db_cursor_impl *ci;
+	int                       result;
+	struct kpair             *prev;
+
+	C2_PRE(cursor->c_table == pair->dp_table);
+	C2_ASSERT(ktable_invariant(pair->dp_table));
+
+	ci = &cursor->c_i;
+
+	if (ci->ck_current == NULL)
+		result = -EINVAL;
+	else {
+		pair_lock(pair);
+		prev = kpair_fix_prev(cursor->c_table,
+				      pair_tlist_prev(pair_list(pair),
+						      ci->ck_current));
+		if (prev == NULL)
+			result = -ENOENT;
+		else {
+			ci->ck_current = prev;
+			result = kpair_copyout(ci->ck_current, pair);
+		}
+		pair_unlock(pair);
+	}
+	return result;
+}
+
+int c2_db_cursor_first(struct c2_db_cursor *cursor, struct c2_db_pair *pair)
+{
+	struct c2_db_cursor_impl *ci;
+	struct c2_tl             *pl;
+	int                       result;
+	struct kpair             *first;
+
+	C2_PRE(cursor->c_table == pair->dp_table);
+	C2_ASSERT(ktable_invariant(pair->dp_table));
+
+	ci = &cursor->c_i;
+	pl = pair_list(pair);
+
+	pair_lock(pair);
+	first = kpair_fix_next(cursor->c_table, pair_tlist_head(pl));
+	if (first == NULL)
+		result = -ENOENT;
+	else {
+		ci->ck_current = first;
+		kpair_copyout(ci->ck_current, pair);
+		result = 0;
+	}
+	pair_unlock(pair);
+	return result;
+}
+
+int c2_db_cursor_last(struct c2_db_cursor *cursor, struct c2_db_pair *pair)
+{
+	struct c2_db_cursor_impl *ci;
+	struct c2_tl             *pl;
+	int                       result;
+	struct kpair             *last;
+
+	C2_PRE(cursor->c_table == pair->dp_table);
+	C2_ASSERT(ktable_invariant(pair->dp_table));
+
+	ci = &cursor->c_i;
+	pl = pair_list(pair);
+
+	pair_lock(pair);
+	last = kpair_fix_prev(cursor->c_table, pair_tlist_tail(pl));
+	if (last == NULL)
+		result = -ENOENT;
+	else {
+		ci->ck_current = last;
+		kpair_copyout(ci->ck_current, pair);
+		result = 0;
+	}
+	pair_unlock(pair);
+	return result;
+}
+
+int c2_db_cursor_set(struct c2_db_cursor *cursor, struct c2_db_pair *pair)
+{
+	struct c2_db_cursor_impl *ci;
+	struct kpair             *newkp;
+	struct kpair             *cur;
+	struct c2_db_pair         replacement;
+	int                       result;
+
+	C2_PRE(cursor->c_table == pair->dp_table);
+	C2_ASSERT(ktable_invariant(pair->dp_table));
+
+	ci = &cursor->c_i;
+
+	cur = ci->ck_current;
+	if (cur == NULL)
+		return -EINVAL;
+
+	/* XXX accessing kpair without table mutex. */
+	c2_db_pair_setup(&replacement, pair->dp_table,
+			 cur->dk_key.b_addr, cur->dk_key.b_nob,
+			 pair->dp_rec.db_buf.b_addr, pair->dp_rec.db_buf.b_nob);
+
+	newkp = kpair_alloc(&replacement);
+	if (newkp != NULL) {
+		pair_lock(pair);
+		pair_tlist_add_after(cur, newkp);
+		kpair_plank(cursor->c_tx, cur);
+		ci->ck_current = newkp;
+		pair_unlock(pair);
+		result = 0;
+	} else
+		result = -ENOMEM;
+
+	C2_ASSERT(ktable_invariant(pair->dp_table));
+
+	return result;
+}
+
+int c2_db_cursor_add(struct c2_db_cursor *cursor, struct c2_db_pair *pair)
+{
+	C2_PRE(cursor->c_table == pair->dp_table);
+
+	return table_insert(pair, &cursor->c_i.ck_current);
+}
+
+int c2_db_cursor_del(struct c2_db_cursor *cursor)
+{
+	struct c2_db_cursor_impl *ci;
+	struct c2_table_impl     *ti;
+	int                       result;
+
+	C2_ASSERT(ktable_invariant(cursor->c_table));
+
+	ci = &cursor->c_i;
+	ti = &cursor->c_table->t_i;
+
+	if (ci->ck_current != NULL) {
+		c2_mutex_lock(&ti->tk_lock);
+		kpair_plank(cursor->c_tx, ci->ck_current);
+		c2_mutex_unlock(&ti->tk_lock);
+		result = 0;
+	} else
+		result = -EINVAL;
+	C2_ASSERT(ktable_invariant(cursor->c_table));
+	return result;
+}
+
+void c2_db_buf_impl_init(struct c2_db_buf *buf)
+{
+}
+
+void c2_db_buf_impl_fini(struct c2_db_buf *buf)
+{
+}
+
+bool c2_db_buf_impl_invariant(const struct c2_db_buf *buf)
+{
+	return true;
+}
+
+static bool ktable_invariant_locked(struct c2_table *t,
+				    struct c2_table_impl *ti)
+{
+	struct c2_tl *tkp = &t->t_i.tk_pair;
+
+	return true;
+	return
+		c2_tlist_invariant(&pair_tl, tkp) &&
+		c2_tl_forall(pair, scan, tkp,
+			     scan->dk_key.b_addr == scan + 1 &&
+			     scan->dk_rec.b_addr ==
+			     scan->dk_key.b_addr + scan->dk_key.b_nob &&
+			     ergo(pair_tlist_prev(tkp, scan) != NULL,
+				  key_cmp(t, &pair_tlist_prev(tkp, scan)->dk_key,
+					  &scan->dk_key) == -1));
+}
+
+static bool ktable_invariant(struct c2_table *t)
+{
+	bool                  result;
+	struct c2_table_impl *ti;
+
+	ti = &t->t_i;
+
+	c2_mutex_lock(&ti->tk_lock);
+	result = ktable_invariant_locked(t, ti);
+	c2_mutex_unlock(&ti->tk_lock);
+	return result;
+}
+
+int c2_db_init(void)
+{
+	return 0;
+}
+
+void c2_db_fini(void)
+{
+}
+
+/** @} end of db group */
+
+/*
+ *  Local variables:
+ *  c-indentation-style: "K&R"
+ *  c-basic-offset: 8
+ *  tab-width: 8
+ *  fill-column: 80
+ *  scroll-step: 1
+ *  End:
+ */
diff --git a/db/ut/db.c b/db/ut/db.c
index a9c4759..ddd7a1a 100644
--- a/db/ut/db.c
+++ b/db/ut/db.c
@@ -47,10 +47,6 @@ static int test_key_cmp(struct c2_table *table,
 }
 
 static const struct c2_table_ops test_table_ops = {
-	.to = {
-		[TO_KEY] = { .max_size = 8 },
-		[TO_REC] = { .max_size = 8 }
-	},
 	.key_cmp = test_key_cmp
 };
 
@@ -160,6 +156,7 @@ static void test_insert(void)
 	c2_db_pair_fini(&cons);
         dbut_fini(&db, &table, &tx, &c2_db_tx_commit);
 
+#if defined(ENABLE_DB5)
 	/* and look up again */
 
         dbut_init(db_name, test_table, &db, &table, &tx);
@@ -172,6 +169,7 @@ static void test_insert(void)
 
 	c2_db_pair_fini(&cons1);
         dbut_fini(&db, &table, &tx, &c2_db_tx_commit);
+#endif
 }
 
 static void test_delete(void)
@@ -216,6 +214,7 @@ static void test_delete(void)
         dbut_fini(&db, &table, &tx, &c2_db_tx_commit);
 }
 
+#if defined(ENABLE_DB5)
 static void test_abort(void)
 {
 	struct c2_dbenv   db;
@@ -319,6 +318,7 @@ static void test_waiter(void)
         dbut_fini(&db, &table, &tx, &c2_db_tx_commit);
 	C2_UT_ASSERT(wflag == 3);
 }
+#endif
 
 const struct c2_test_suite db_ut = {
 	.ts_name = "libdb-ut",
@@ -330,12 +330,15 @@ const struct c2_test_suite db_ut = {
 		{ "lookup", test_lookup },
 		{ "insert", test_insert },
 		{ "delete", test_delete },
+#if defined(ENABLE_DB5)
 		{ "abort", test_abort },
 		{ "waiter", test_waiter },
+#endif
 		{ NULL, NULL }
 	}
 };
 
+#if defined(ENABLE_DB5)
 /*
  * Test Suite db-cursor-ut.
  */
@@ -509,6 +512,19 @@ const struct c2_test_suite db_cursor_ut = {
 	}
 };
 
+#else /* !defined(ENABLE_DB5) */
+
+const struct c2_test_suite db_cursor_ut = {
+	.ts_name = "db-cursor-ut",
+	.ts_init = NULL,
+	.ts_fini = NULL,
+	.ts_tests = {
+		{ NULL, NULL }
+	}
+};
+
+#endif
+
 /*
  * UB
  */
diff --git a/db/ut/elist.c b/db/ut/elist.c
index fb7314e..202bcb9 100644
--- a/db/ut/elist.c
+++ b/db/ut/elist.c
@@ -18,11 +18,11 @@
  * Original creation date: 08/13/2010
  */
 
-#include <stdio.h>        /* fprintf */
 #include <errno.h>
 #include <err.h>
 #include <sysexits.h>
 
+#include "lib/string.h"   /* fprintf */
 #include "lib/arith.h"    /* C2_3WAY, c2_uint128 */
 #include "lib/misc.h"     /* C2_SET0 */
 #include "lib/assert.h"
diff --git a/db/ut/emap.c b/db/ut/emap.c
index 3ef470d..346ae4e 100644
--- a/db/ut/emap.c
+++ b/db/ut/emap.c
@@ -18,8 +18,6 @@
  * Original creation date: 08/13/2010
  */
 
-#include <stdio.h>        /* printf */
-
 #include "lib/arith.h"    /* C2_3WAY, c2_uint128 */
 #include "lib/vec.h"
 #include "lib/types.h"
@@ -152,15 +150,7 @@ static void test_print(void)
 	result = c2_emap_lookup(&emap, &tx, &prefix, 0, &it);
 	C2_UT_ASSERT(result == 0);
 
-#if 0
-	printf("%010lx:%010lx:\n", prefix.u_hi, prefix.u_lo);
-#endif
 	for (i = 0; ; ++i) {
-#if 0
-		printf("\t%5.5i %16lx .. %16lx: %16lx %10lx\n", i,
-		       seg->ee_ext.e_start, seg->ee_ext.e_end,
-		       c2_ext_length(&seg->ee_ext), seg->ee_val);
-#endif
 		if (c2_emap_ext_is_last(&seg->ee_ext))
 			break;
 		result = c2_emap_next(&it);
diff --git a/desim/chs.c b/desim/chs.c
index 8db0292..9539483 100644
--- a/desim/chs.c
+++ b/desim/chs.c
@@ -26,10 +26,10 @@
 #endif
 
 #include <string.h>
-#include <stdio.h>
 #include <stdlib.h>
 #include <math.h> /* sqrt(3) */
 
+#include "lib/string.h"
 #include "lib/assert.h"
 #include "desim/sim.h"
 #include "desim/chs.h"
diff --git a/desim/client.c b/desim/client.c
index 8f46d45..737ce60 100644
--- a/desim/client.c
+++ b/desim/client.c
@@ -22,8 +22,7 @@
 #  include "config.h"
 #endif
 
-#include <stdio.h>
-
+#include "lib/string.h"
 #include "lib/assert.h"
 #include "desim/sim.h"
 #include "desim/net.h"
diff --git a/desim/cnt.c b/desim/cnt.c
index c728d94..74e773d 100644
--- a/desim/cnt.c
+++ b/desim/cnt.c
@@ -25,10 +25,10 @@
 
 #include <string.h>
 #include <stdlib.h>
-#include <stdio.h>
 #include <err.h>
 #include <math.h>
 
+#include "lib/string.h"
 #include "desim/sim.h"
 #include "desim/cnt.h"
 
diff --git a/desim/elevator.c b/desim/elevator.c
index bdf111e..a9358c2 100644
--- a/desim/elevator.c
+++ b/desim/elevator.c
@@ -23,10 +23,9 @@
 #  include "config.h"
 #endif
 
-#include <string.h>
-#include <stdio.h>
 #include <stdlib.h>
 
+#include "lib/string.h"
 #include "lib/assert.h"
 #include "desim/elevator.h"
 
diff --git a/desim/net.c b/desim/net.c
index d80392a..6b0af93 100644
--- a/desim/net.c
+++ b/desim/net.c
@@ -23,8 +23,7 @@
 #  include "config.h"
 #endif
 
-#include <stdio.h>
-
+#include "lib/string.h"
 #include "lib/assert.h"
 #include "desim/sim.h"
 #include "desim/net.h"
diff --git a/desim/sim.c b/desim/sim.c
index d4bbce7..94a06ef 100644
--- a/desim/sim.c
+++ b/desim/sim.c
@@ -25,13 +25,13 @@
 #endif
 
 #include <stdlib.h>
-#include <stdio.h>
 #include <string.h>
 #include <err.h>
 #include <sysexits.h>
 
 #include <execinfo.h>
 
+#include "lib/string.h"
 #include "lib/assert.h"
 #include "desim/sim.h"
 
diff --git a/desim/ut/chs_test.c b/desim/ut/chs_test.c
index 967a8b0..58629e9 100644
--- a/desim/ut/chs_test.c
+++ b/desim/ut/chs_test.c
@@ -23,9 +23,9 @@
 #  include "config.h"
 #endif
 
-#include <stdio.h>
 #include <math.h> /* sqrt */
 
+#include "lib/string.h"
 #include "colibri/init.h"
 
 #include "desim/sim.h"
diff --git a/desim/ut/net_test.c b/desim/ut/net_test.c
index 821419a..63dd801 100644
--- a/desim/ut/net_test.c
+++ b/desim/ut/net_test.c
@@ -23,9 +23,10 @@
 #  include "config.h"
 #endif
 
-#include <stdio.h>
 #include <math.h> /* sqrt */
 
+#include "lib/string.h"
+
 #include "colibri/init.h"
 
 #include "desim/sim.h"
diff --git a/fol/fol.c b/fol/fol.c
index dff5e11..29f1e30 100644
--- a/fol/fol.c
+++ b/fol/fol.c
@@ -83,14 +83,6 @@ static int lsn_cmp(struct c2_table *table, const void *key0, const void *key1)
 }
 
 static const struct c2_table_ops fol_ops = {
-	.to = {
-		[TO_KEY] = {
-			.max_size = sizeof(c2_lsn_t)
-		},
-		[TO_REC] = {
-			.max_size = ~0
-		}
-	},
 	.key_cmp = lsn_cmp
 };
 
diff --git a/fop/fom.h b/fop/fom.h
index ce53bea..abed0d1 100644
--- a/fop/fom.h
+++ b/fop/fom.h
@@ -458,9 +458,9 @@ struct c2_fom {
 	unsigned		  fo_transitions_saved;
 
 	/** State machine for generic and specfic FOM phases. */
-	struct c2_sm		 fo_sm_phase;
+	struct c2_sm		  fo_sm_phase;
 	/** State machine for FOM states. */
-	struct c2_sm		 fo_sm_state;
+	struct c2_sm		  fo_sm_state;
 	/** Result of fom execution, -errno on failure */
 	int32_t			  fo_rc;
 	/** Thread executing current phase transition. */
diff --git a/ioservice/cob_foms.c b/ioservice/cob_foms.c
index 32b7211..8a85538 100644
--- a/ioservice/cob_foms.c
+++ b/ioservice/cob_foms.c
@@ -346,7 +346,8 @@ static int cc_cobfid_map_add(struct c2_fom *fom, struct c2_fom_cob_op *cc)
 	cob_fid.u_lo = cc->fco_cfid.f_key;
 
 	c2_mutex_lock(&cfm->cfm_mutex);
-	rc = c2_cobfid_map_add(cfm, cob_fid.u_hi, cc->fco_gfid, cob_fid);
+	rc = c2_cobfid_map_add(cfm, cob_fid.u_hi, cc->fco_gfid, cob_fid,
+			       &fom->fo_tx);
 	c2_mutex_unlock(&cfm->cfm_mutex);
 	if (rc != 0)
 		C2_ADDB_ADD(&fom->fo_fop->f_addb, &cc_fom_addb_loc,
@@ -500,13 +501,13 @@ static int cd_cobfid_map_delete(struct c2_fom *fom, struct c2_fom_cob_op *cd)
 	cob_fid.u_lo = cd->fco_cfid.f_key;
 
 	c2_mutex_lock(&cfm->cfm_mutex);
-	rc = c2_cobfid_map_del(cfm, cob_fid.u_hi, cd->fco_gfid);
+	rc = c2_cobfid_map_del(cfm, cob_fid.u_hi, cd->fco_gfid, &fom->fo_tx);
 	c2_mutex_unlock(&cfm->cfm_mutex);
 
 	if (rc != 0)
 		C2_ADDB_ADD(&fom->fo_fop->f_addb, &cd_fom_addb_loc,
 			    cd_fom_func_fail,
-			    "c2_cobfid_map_setup_delrec() failed.", rc);
+			    "c2_cobfid_map_del() failed.", rc);
 	else
 		C2_ADDB_ADD(&fom->fo_fop->f_addb, &cc_fom_addb_loc,
 			    c2_addb_trace,
diff --git a/ioservice/cobfid_map.c b/ioservice/cobfid_map.c
index 8d0f44c..59baead 100644
--- a/ioservice/cobfid_map.c
+++ b/ioservice/cobfid_map.c
@@ -85,14 +85,6 @@ static int cfm_key_cmp(struct c2_table *table, const void *key0,
 }
 
 static const struct c2_table_ops cfm_table_ops = {
-	.to = {
-		[TO_KEY] = {
-			.max_size = sizeof(struct cobfid_map_key)
-		},
-		[TO_REC] = {
-			.max_size = sizeof(struct c2_uint128)
-		}
-	},
 	.key_cmp = cfm_key_cmp
 };
 
@@ -175,89 +167,64 @@ void c2_cobfid_map_fini(struct c2_cobfid_map *cfm)
 }
 
 int c2_cobfid_map_add(struct c2_cobfid_map *cfm, const uint64_t container_id,
-		      const struct c2_fid file_fid, struct c2_uint128 cob_fid)
+		      const struct c2_fid file_fid, struct c2_uint128 cob_fid,
+		      struct c2_dtx *dtx)
 {
 	int			 rc;
-	bool			 table_update_failed = false;
 	struct c2_db_pair	 db_pair;
 	struct cobfid_map_key	 key;
-	struct c2_db_tx		 tx;
+	struct c2_db_tx		*tx = &dtx->tx_dbtx;
 
 	C2_PRE(cobfid_map_invariant(cfm));
 
 	key.cfk_ci = container_id;
 	key.cfk_fid = file_fid;
 
-	rc = c2_db_tx_init(&tx, cfm->cfm_dbenv, 0);
-	if (rc != 0) {
-		C2_ADDB_ADD(cfm->cfm_addb, &cfm_addb_loc, cfm_func_fail,
-			    "c2_db_tx_init", rc);
-		return rc;
-	}
-
 	c2_db_pair_setup(&db_pair, &cfm->cfm_table, &key,
 			 sizeof(struct cobfid_map_key),
 			 &cob_fid, sizeof(struct c2_uint128));
 
-	rc = c2_table_update(&tx, &db_pair);
-	if (rc != 0) {
-		table_update_failed = true;
+	rc = c2_table_insert(tx, &db_pair);
+	if (rc != 0)
 		C2_ADDB_ADD(cfm->cfm_addb, &cfm_addb_loc, cfm_func_fail,
-			    "c2_table_update", rc);
-	}
+			    "c2_table_insert", rc);
 
 	c2_db_pair_release(&db_pair);
 	c2_db_pair_fini(&db_pair);
-	if (!table_update_failed) {
+	if (rc == 0)
 		cfm->cfm_last_mod = c2_time_now();
-		c2_db_tx_commit(&tx);
-	} else
-		c2_db_tx_abort(&tx);
 
 	C2_POST(cobfid_map_invariant(cfm));
-
 	return rc;
 }
 
 int c2_cobfid_map_del(struct c2_cobfid_map *cfm, const uint64_t container_id,
-		      const struct c2_fid file_fid)
+		      const struct c2_fid file_fid, struct c2_dtx *dtx)
 {
 	int			 rc;
 	struct c2_db_pair	 db_pair;
 	struct cobfid_map_key	 key;
-	bool			 table_op_failed = false;
-	struct c2_db_tx		 tx;
+	struct c2_db_tx		*tx = &dtx->tx_dbtx;
 
 	C2_PRE(cobfid_map_invariant(cfm));
 
-	rc = c2_db_tx_init(&tx, cfm->cfm_dbenv, 0);
-	if (rc != 0) {
-		C2_ADDB_ADD(cfm->cfm_addb, &cfm_addb_loc, cfm_func_fail,
-			    "c2_db_tx_init", rc);
-		return rc;
-	}
-
 	key.cfk_ci = container_id;
 	key.cfk_fid = file_fid;
 
 	c2_db_pair_setup(&db_pair, &cfm->cfm_table, &key,
 			 sizeof(struct cobfid_map_key), NULL, 0);
 
-	rc = c2_table_delete(&tx, &db_pair);
+	rc = c2_table_delete(tx, &db_pair);
 	if (rc != 0) {
 		C2_ADDB_ADD(cfm->cfm_addb, &cfm_addb_loc, cfm_func_fail,
 			    "c2_table_delete", rc);
-		table_op_failed = true;
 	}
 
 	c2_db_pair_release(&db_pair);
 	c2_db_pair_fini(&db_pair);
 
-	if (!table_op_failed) {
+	if (rc == 0)
 		cfm->cfm_last_mod = c2_time_now();
-		c2_db_tx_commit(&tx);
-	} else
-		c2_db_tx_abort(&tx);
 
 	C2_POST(cobfid_map_invariant(cfm));
 
@@ -358,7 +325,7 @@ static int cobfid_map_iter_init(struct c2_cobfid_map *cfm,
 
 int c2_cobfid_map_iter_next(struct  c2_cobfid_map_iter *iter,
 			    uint64_t *container_id_p, struct c2_fid *file_fid_p,
-			    struct c2_uint128 *cob_fid_p)
+			    struct c2_uint128 *cob_fid_p, struct c2_dtx *dtx)
 {
 	int			  rc;
 	struct cobfid_map_record *recs;
@@ -379,7 +346,7 @@ int c2_cobfid_map_iter_next(struct  c2_cobfid_map_iter *iter,
 		iter->cfmi_rec_idx = 0;
 		/* buffer empty: fetch records into the buffer
 		   and then set cfmi_rec_idx to 0 */
-		rc = iter->cfmi_ops->cfmio_fetch(iter);
+		rc = iter->cfmi_ops->cfmio_fetch(iter, dtx);
 		if (rc != 0){
 			C2_ASSERT(iter->cfmi_error != 0);
 			C2_ADDB_ADD(iter->cfmi_cfm->cfm_addb, &cfm_addb_loc,
@@ -391,7 +358,7 @@ int c2_cobfid_map_iter_next(struct  c2_cobfid_map_iter *iter,
 		/* iterator stale: reload the buffer and reset buffer index */
 		iter->cfmi_rec_idx = 0;
 		iter->cfmi_reload = true;
-		rc = iter->cfmi_ops->cfmio_reload(iter);
+		rc = iter->cfmi_ops->cfmio_reload(iter, dtx);
 		if (rc != 0){
 			C2_ASSERT(iter->cfmi_error != 0);
 			C2_ADDB_ADD(iter->cfmi_cfm->cfm_addb, &cfm_addb_loc,
@@ -433,7 +400,7 @@ int c2_cobfid_map_iter_next(struct  c2_cobfid_map_iter *iter,
  *****************************************************************************
  */
 
-static int enum_fetch(struct c2_cobfid_map_iter *iter)
+static int enum_fetch(struct c2_cobfid_map_iter *iter, struct c2_dtx *dtx)
 {
 	int				 rc;
 	int				 i;
@@ -445,7 +412,7 @@ static int enum_fetch(struct c2_cobfid_map_iter *iter)
 	struct c2_uint128		 cob_fid;
 	struct cobfid_map_record	*recs;
 	struct c2_db_cursor		 db_cursor;
-	struct c2_db_tx			 tx;
+	struct c2_db_tx			*tx = &dtx->tx_dbtx;
 
 	C2_PRE(cobfid_map_iter_invariant(iter));
 
@@ -453,18 +420,10 @@ static int enum_fetch(struct c2_cobfid_map_iter *iter)
 
 	cfm = iter->cfmi_cfm;
 
-	rc = c2_db_tx_init(&tx, cfm->cfm_dbenv, 0);
-	if (rc != 0) {
-		C2_ADDB_ADD(cfm->cfm_addb, &cfm_addb_loc, cfm_func_fail,
-			    "c2_db_tx_init", rc);
-		return rc;
-	}
-
-	rc = c2_db_cursor_init(&db_cursor, &cfm->cfm_table, &tx, 0);
+	rc = c2_db_cursor_init(&db_cursor, &cfm->cfm_table, tx, 0);
 	if (rc != 0) {
 		C2_ADDB_ADD(cfm->cfm_addb, &cfm_addb_loc, cfm_func_fail,
 			    "c2_db_cursor_init", rc);
-		c2_db_tx_abort(&tx);
 		return rc;
 	}
 
@@ -551,10 +510,8 @@ cleanup:
 	if (rc == 0) {
 		iter->cfmi_next_ci = key.cfk_ci;
 		iter->cfmi_next_fid = key.cfk_fid;
-		c2_db_tx_commit(&tx);
 	} else {
 		iter->cfmi_error = rc;
-		c2_db_tx_abort(&tx);
 	}
 
 	return rc;
@@ -580,14 +537,14 @@ static bool enum_is_at_end(struct c2_cobfid_map_iter *iter,
 	return false;
 }
 
-static int enum_reload(struct c2_cobfid_map_iter *iter)
+static int enum_reload(struct c2_cobfid_map_iter *iter, struct c2_dtx *dtx)
 {
 	C2_PRE(cobfid_map_iter_invariant(iter));
 
 	iter->cfmi_next_ci = iter->cfmi_last_ci;
 	iter->cfmi_next_fid = iter->cfmi_last_fid;
 
-	return iter->cfmi_ops->cfmio_fetch(iter);
+	return iter->cfmi_ops->cfmio_fetch(iter, dtx);
 }
 
 static const struct c2_cobfid_map_iter_ops enum_ops = {
@@ -625,9 +582,10 @@ int c2_cobfid_map_enum(struct c2_cobfid_map *cfm,
    fid in the last record read, so that the next fetch will continue
    beyond the current batch.  The value of cfmi_next_ci is not modified.
  */
-static int enum_container_fetch(struct c2_cobfid_map_iter *iter)
+static int enum_container_fetch(struct c2_cobfid_map_iter *iter,
+				struct c2_dtx *dtx)
 {
-	return enum_fetch(iter);
+	return enum_fetch(iter, dtx);
 }
 
 /**
@@ -662,9 +620,10 @@ static bool enum_container_is_at_end(struct c2_cobfid_map_iter *iter,
 /**
    Reload from the position prior to the last record read.
  */
-static int enum_container_reload(struct c2_cobfid_map_iter *iter)
+static int enum_container_reload(struct c2_cobfid_map_iter *iter,
+				 struct c2_dtx *dtx)
 {
-	return enum_reload(iter);
+	return enum_reload(iter, dtx);
 }
 
 static const struct c2_cobfid_map_iter_ops enum_container_ops = {
diff --git a/ioservice/cobfid_map.h b/ioservice/cobfid_map.h
index 1153d51..a4ccc38 100644
--- a/ioservice/cobfid_map.h
+++ b/ioservice/cobfid_map.h
@@ -147,7 +147,7 @@ struct c2_cobfid_map_iter_ops {
 	   Loads the next batch of records into the iterator and updates the
 	   iterator state to correctly position for the next call.
 	 */
-	int (*cfmio_fetch)(struct c2_cobfid_map_iter *);
+	int (*cfmio_fetch)(struct c2_cobfid_map_iter *, struct c2_dtx *);
 	/**
 	   Determines if the record in the specified position will
 	   exhaust the iterator.
@@ -160,7 +160,7 @@ struct c2_cobfid_map_iter_ops {
 	   delete a record, as indicated by comparing cfm_last_mod with
 	   cfmi_last_load.
 	*/
-	int (*cfmio_reload)(struct c2_cobfid_map_iter *);
+	int (*cfmio_reload)(struct c2_cobfid_map_iter *, struct c2_dtx *);
 };
 
 /**
@@ -211,7 +211,7 @@ void c2_cobfid_map_iter_fini(struct  c2_cobfid_map_iter *iter);
 int c2_cobfid_map_add(struct c2_cobfid_map *cfm,
 		      const uint64_t container_id,
 		      const struct c2_fid file_fid,
-		      struct c2_uint128 cob_fid);
+		      struct c2_uint128 cob_fid, struct c2_dtx *dtx);
 
 /**
    Delete the association of the tuple (container_id, file_fid) with a cob_fid.
@@ -223,7 +223,7 @@ int c2_cobfid_map_add(struct c2_cobfid_map *cfm,
  */
 int c2_cobfid_map_del(struct c2_cobfid_map *cfm,
 		      const uint64_t container_id,
-		      const struct c2_fid file_fid);
+		      const struct c2_fid file_fid, struct c2_dtx *dtx);
 
 /**
    Initializes an iterator to enumerate the associations within a container
@@ -278,7 +278,7 @@ int c2_cobfid_map_enum(struct c2_cobfid_map *cfm,
 int c2_cobfid_map_iter_next(struct  c2_cobfid_map_iter *iter,
 			    uint64_t *container_id_p,
 			    struct c2_fid *file_fid_p,
-			    struct c2_uint128 *cob_fid_p);
+			    struct c2_uint128 *cob_fid_p, struct c2_dtx *dtx);
 
 /**
  * Finds the struct c2_cobfid_map instance in the request handler using
diff --git a/ioservice/ut/cob_foms.c b/ioservice/ut/cob_foms.c
index 1f9f9d6..af33fca 100644
--- a/ioservice/ut/cob_foms.c
+++ b/ioservice/ut/cob_foms.c
@@ -620,7 +620,7 @@ static void cobfid_map_verify(struct c2_fom *fom, const bool map_exists)
 	C2_UT_ASSERT(rc == 0);
 
 	rc = c2_cobfid_map_iter_next(&cfm_iter, &cid_out,
-				     &fid_out, &cob_fid_out);
+				     &fid_out, &cob_fid_out, &fom->fo_tx);
 	c2_cobfid_map_iter_fini(&cfm_iter);
 	C2_UT_ASSERT(ergo(map_exists, rc == 0));
 	C2_UT_ASSERT(ergo(!map_exists, rc != 0));
diff --git a/ioservice/ut/cobfid_map.c b/ioservice/ut/cobfid_map.c
index f3a7597..60df6ab 100644
--- a/ioservice/ut/cobfid_map.c
+++ b/ioservice/ut/cobfid_map.c
@@ -24,8 +24,10 @@
 
 #include "ioservice/cobfid_map.h"
 #include "lib/ut.h"
+#include "lib/thread.h"
 #include "lib/memory.h"
 #include "lib/arith.h"
+#include "dtm/dtm.h"                  /* c2_dtx */
 
 /* Number of records to be enumerated */
 enum {
@@ -78,6 +80,7 @@ static void enumerate_generic(const int rec_total, const char *map_path,
 	struct c2_addb_ctx	 cfm_addb_ctx;
 	struct c2_cobfid_map	 cfm_map;
 	struct c2_cobfid_map_iter cfm_iter;
+	struct c2_dtx             dtx;
 
 	/* Reset any existing database */
 	rc = c2_ut_db_reset(map_path);
@@ -87,6 +90,9 @@ static void enumerate_generic(const int rec_total, const char *map_path,
         rc = c2_dbenv_init(&cfm_dbenv, map_path, 0);
 	C2_UT_ASSERT(rc == 0);
 
+	rc = c2_db_tx_init(&dtx.tx_dbtx, &cfm_dbenv, 0);
+	C2_UT_ASSERT(rc == 0);
+
 	c2_addb_ctx_init(&cfm_addb_ctx, &cfm_ut_addb_ctx_type,
 			 &c2_addb_global_ctx);
 	/* Initialize the map */
@@ -143,10 +149,10 @@ static void enumerate_generic(const int rec_total, const char *map_path,
 		if (etype == ENUM_MAP) {
 			cid_in[i] = j;
 			rc = c2_cobfid_map_add(&cfm_map, cid_in[i],
-					       fid_in[i], cob_fid_in[i]);
+					       fid_in[i], cob_fid_in[i], &dtx);
 		} else
 			rc = c2_cobfid_map_add(&cfm_map, container_id_in,
-					       fid_in[i], cob_fid_in[i]);
+					       fid_in[i], cob_fid_in[i], &dtx);
 
 		C2_UT_ASSERT(rc == 0);
 		j--;
@@ -155,6 +161,9 @@ static void enumerate_generic(const int rec_total, const char *map_path,
 	/* Finalise the DB environment, transaction and cobfid_map,
 	   and reinitialize to check database persistence */
 	if (check_persistence) {
+		rc = c2_db_tx_commit(&dtx.tx_dbtx);
+		C2_UT_ASSERT(rc == 0);
+
 		c2_cobfid_map_fini(&cfm_map);
 		c2_dbenv_fini(&cfm_dbenv);
 
@@ -162,6 +171,9 @@ static void enumerate_generic(const int rec_total, const char *map_path,
 		rc = c2_dbenv_init(&cfm_dbenv, map_path, 0);
 		C2_UT_ASSERT(rc == 0);
 
+		rc = c2_db_tx_init(&dtx.tx_dbtx, &cfm_dbenv, 0);
+		C2_UT_ASSERT(rc == 0);
+
 		/* Initialize the map */
 		rc = c2_cobfid_map_init(&cfm_map, &cfm_dbenv, &cfm_addb_ctx,
 					"cfm_map_table");
@@ -176,9 +188,9 @@ static void enumerate_generic(const int rec_total, const char *map_path,
 						  &cfm_iter);
 		C2_UT_ASSERT(rc == 0);
 		while ((rc = c2_cobfid_map_iter_next(&cfm_iter,
-						&container_id_out,
-						&fid_out[rec_nr],
-						&cob_fid_out[rec_nr])) == 0) {
+					&container_id_out,
+					&fid_out[rec_nr],
+					&cob_fid_out[rec_nr], &dtx)) == 0) {
 			rec_nr++;
 		}
 		C2_UT_ASSERT(cfm_iter.cfmi_error == -ENOENT);
@@ -187,9 +199,9 @@ static void enumerate_generic(const int rec_total, const char *map_path,
 		rc = c2_cobfid_map_enum(&cfm_map, &cfm_iter);
 		C2_UT_ASSERT(rc == 0);
 		while ((rc = c2_cobfid_map_iter_next(&cfm_iter,
-						&cid_out[rec_nr],
-						&fid_out[rec_nr],
-						&cob_fid_out[rec_nr])) == 0) {
+					&cid_out[rec_nr],
+					&fid_out[rec_nr],
+				        &cob_fid_out[rec_nr], &dtx)) == 0) {
 			rec_nr++;
 		}
 		C2_UT_ASSERT(cfm_iter.cfmi_error == -ENOENT);
@@ -226,6 +238,9 @@ static void enumerate_generic(const int rec_total, const char *map_path,
 		c2_free(cid_out);
 	}
 
+	rc = c2_db_tx_commit(&dtx.tx_dbtx);
+	C2_UT_ASSERT(rc == 0);
+
 	c2_cobfid_map_fini(&cfm_map);
 	c2_dbenv_fini(&cfm_dbenv);
 
@@ -292,6 +307,7 @@ static void test_iter_sensitivity(void)
 	struct c2_addb_ctx	 cfm_addb_ctx;
 	struct c2_cobfid_map	 cfm_map;
 	struct c2_cobfid_map_iter cfm_iter;
+	struct c2_dtx             dtx;
 
 	/* Reset any existing database */
 	rc = c2_ut_db_reset(iter_test_map);
@@ -301,6 +317,9 @@ static void test_iter_sensitivity(void)
         rc = c2_dbenv_init(&cfm_dbenv, iter_test_map, 0);
 	C2_UT_ASSERT(rc == 0);
 
+	rc = c2_db_tx_init(&dtx.tx_dbtx, &cfm_dbenv, 0);
+	C2_UT_ASSERT(rc == 0);
+
 	/* Initialize the map */
 	rc = c2_cobfid_map_init(&cfm_map, &cfm_dbenv, &cfm_addb_ctx,
 				"cfm_map_table");
@@ -314,21 +333,24 @@ static void test_iter_sensitivity(void)
 	cob_fid_in.u_lo = 31;
 
 	/* Add31 - add key with fid.f_key = 31 */
-	rc = c2_cobfid_map_add(&cfm_map, container_id_in, fid_in, cob_fid_in);
+	rc = c2_cobfid_map_add(&cfm_map, container_id_in, fid_in,
+			       cob_fid_in, &dtx);
 	C2_UT_ASSERT(rc == 0);
 
 	fid_in.f_key = 52;
 	cob_fid_in.u_lo = 52;
 
 	/* Add52 - add key with fid.f_key = 52 */
-	rc = c2_cobfid_map_add(&cfm_map, container_id_in, fid_in, cob_fid_in);
+	rc = c2_cobfid_map_add(&cfm_map, container_id_in, fid_in,
+			       cob_fid_in, &dtx);
 	C2_UT_ASSERT(rc == 0);
 
 	fid_in.f_key = 73;
 	cob_fid_in.u_lo = 73;
 
 	/* Add73 - add key with fid.f_key = 73 */
-	rc = c2_cobfid_map_add(&cfm_map, container_id_in, fid_in, cob_fid_in);
+	rc = c2_cobfid_map_add(&cfm_map, container_id_in, fid_in,
+			       cob_fid_in, &dtx);
 	C2_UT_ASSERT(rc == 0);
 
 	/* Open the iterator */
@@ -337,7 +359,7 @@ static void test_iter_sensitivity(void)
 
 	/* Get31 */
 	rc = c2_cobfid_map_iter_next(&cfm_iter, &container_id_out, &fid_out,
-				     &cob_fid_out);
+				     &cob_fid_out, &dtx);
 	C2_UT_ASSERT(rc == 0);
 	C2_UT_ASSERT(fid_out.f_key == 31);
 	C2_UT_ASSERT(cob_fid_out.u_lo == 31);
@@ -346,12 +368,13 @@ static void test_iter_sensitivity(void)
 	cob_fid_in.u_lo = 94;
 
 	/* Add94 - add key with fid.f_key = 94 */
-	rc = c2_cobfid_map_add(&cfm_map, container_id_in, fid_in, cob_fid_in);
+	rc = c2_cobfid_map_add(&cfm_map, container_id_in, fid_in, cob_fid_in,
+			       &dtx);
 	C2_UT_ASSERT(rc == 0);
 
 	/* Get52 */
 	rc = c2_cobfid_map_iter_next(&cfm_iter, &container_id_out, &fid_out,
-				     &cob_fid_out);
+				     &cob_fid_out, &dtx);
 	C2_UT_ASSERT(rc == 0);
 	C2_UT_ASSERT(fid_out.f_key == 52);
 	C2_UT_ASSERT(cob_fid_out.u_lo == 52);
@@ -360,12 +383,13 @@ static void test_iter_sensitivity(void)
 	cob_fid_in.u_lo = 20;
 
 	/* Add20 - add key with fid.f_key = 20 */
-	rc = c2_cobfid_map_add(&cfm_map, container_id_in, fid_in, cob_fid_in);
+	rc = c2_cobfid_map_add(&cfm_map, container_id_in, fid_in, cob_fid_in,
+			       &dtx);
 	C2_UT_ASSERT(rc == 0);
 
 	/* Get73 */
 	rc = c2_cobfid_map_iter_next(&cfm_iter, &container_id_out, &fid_out,
-				     &cob_fid_out);
+				     &cob_fid_out, &dtx);
 	C2_UT_ASSERT(rc == 0);
 	C2_UT_ASSERT(fid_out.f_key == 73);
 	C2_UT_ASSERT(cob_fid_out.u_lo == 73);
@@ -374,19 +398,20 @@ static void test_iter_sensitivity(void)
 	cob_fid_in.u_lo = 87;
 
 	/* Add87 - add key with fid.f_key = 87 */
-	rc = c2_cobfid_map_add(&cfm_map, container_id_in, fid_in, cob_fid_in);
+	rc = c2_cobfid_map_add(&cfm_map, container_id_in, fid_in, cob_fid_in,
+			       &dtx);
 	C2_UT_ASSERT(rc == 0);
 
 	/* Get87 */
 	rc = c2_cobfid_map_iter_next(&cfm_iter, &container_id_out, &fid_out,
-				     &cob_fid_out);
+				     &cob_fid_out, &dtx);
 	C2_UT_ASSERT(rc == 0);
 	C2_UT_ASSERT(fid_out.f_key == 87);
 	C2_UT_ASSERT(cob_fid_out.u_lo == 87);
 
 	/* Get94 */
 	rc = c2_cobfid_map_iter_next(&cfm_iter, &container_id_out, &fid_out,
-				     &cob_fid_out);
+				     &cob_fid_out, &dtx);
 	C2_UT_ASSERT(rc == 0);
 	C2_UT_ASSERT(fid_out.f_key == 94);
 	C2_UT_ASSERT(cob_fid_out.u_lo == 94);
@@ -400,55 +425,58 @@ static void test_iter_sensitivity(void)
 
 	/* Get20 */
 	rc = c2_cobfid_map_iter_next(&cfm_iter, &container_id_out, &fid_out,
-				     &cob_fid_out);
+				     &cob_fid_out, &dtx);
 	C2_UT_ASSERT(rc == 0);
 	C2_UT_ASSERT(fid_out.f_key == 20);
 	C2_UT_ASSERT(cob_fid_out.u_lo == 20);
 
 	/* Get31 */
 	rc = c2_cobfid_map_iter_next(&cfm_iter, &container_id_out, &fid_out,
-				     &cob_fid_out);
+				     &cob_fid_out, &dtx);
 	C2_UT_ASSERT(rc == 0);
 	C2_UT_ASSERT(fid_out.f_key == 31);
 	C2_UT_ASSERT(cob_fid_out.u_lo == 31);
 
 	/* Get52 */
 	rc = c2_cobfid_map_iter_next(&cfm_iter, &container_id_out, &fid_out,
-				     &cob_fid_out);
+				     &cob_fid_out, &dtx);
 	C2_UT_ASSERT(rc == 0);
 	C2_UT_ASSERT(fid_out.f_key == 52);
 	C2_UT_ASSERT(cob_fid_out.u_lo == 52);
 
 	/* Get73 */
 	rc = c2_cobfid_map_iter_next(&cfm_iter, &container_id_out, &fid_out,
-				     &cob_fid_out);
+				     &cob_fid_out, &dtx);
 	C2_UT_ASSERT(rc == 0);
 	C2_UT_ASSERT(fid_out.f_key == 73);
 	C2_UT_ASSERT(cob_fid_out.u_lo == 73);
 
 	/* Get87 */
 	rc = c2_cobfid_map_iter_next(&cfm_iter, &container_id_out, &fid_out,
-				     &cob_fid_out);
+				     &cob_fid_out, &dtx);
 	C2_UT_ASSERT(rc == 0);
 	C2_UT_ASSERT(fid_out.f_key == 87);
 	C2_UT_ASSERT(cob_fid_out.u_lo == 87);
 
 	/* Get94 */
 	rc = c2_cobfid_map_iter_next(&cfm_iter, &container_id_out, &fid_out,
-				     &cob_fid_out);
+				     &cob_fid_out, &dtx);
 	C2_UT_ASSERT(rc == 0);
 	C2_UT_ASSERT(fid_out.f_key == 94);
 	C2_UT_ASSERT(cob_fid_out.u_lo == 94);
 
 	/* Iterator Empty */
 	rc = c2_cobfid_map_iter_next(&cfm_iter, &container_id_out, &fid_out,
-				     &cob_fid_out);
+				     &cob_fid_out, &dtx);
 	C2_UT_ASSERT(rc == -ENOENT);
 	C2_UT_ASSERT(cfm_iter.cfmi_error == -ENOENT);
 
 	/* Close iterator */
 	c2_cobfid_map_iter_fini(&cfm_iter);
 
+	c2_db_tx_commit(&dtx.tx_dbtx);
+	C2_UT_ASSERT(rc == 0);
+
 	c2_cobfid_map_fini(&cfm_map);
 	c2_dbenv_fini(&cfm_dbenv);
 
@@ -488,6 +516,10 @@ static void cfm_op(const int tid)
         uint64_t                 container_id_in;
         uint64_t                 container_id_out;
         struct c2_cobfid_map_iter cfm_iter;
+	struct c2_dtx             dtx;
+
+	rc = c2_db_tx_init(&dtx.tx_dbtx, &cfm_global_dbenv, 0);
+	C2_UT_ASSERT(rc == 0);
 
 	/* Use multiple fetches for iterator */
 	rec_total = MULTIPLE_BUF_REC_NR;
@@ -524,7 +556,7 @@ static void cfm_op(const int tid)
 		c2_mutex_lock(&cfm_global_mutex);
 
 		rc = c2_cobfid_map_add(&cfm_global_map, container_id_in,
-				       fid_in[tid][i], cob_fid_in[tid][i]);
+				       fid_in[tid][i], cob_fid_in[tid][i], &dtx);
                 C2_UT_ASSERT(rc == 0);
 
 		c2_mutex_unlock(&cfm_global_mutex);
@@ -543,7 +575,8 @@ static void cfm_op(const int tid)
 
 	while ((rc = c2_cobfid_map_iter_next(&cfm_iter, &container_id_out,
 					     &fid_out[tid][rec_nr],
-					     &cob_fid_out[tid][rec_nr])) == 0) {
+					     &cob_fid_out[tid][rec_nr],
+					     &dtx)) == 0) {
 		rec_nr++;
 	}
 
@@ -567,6 +600,9 @@ static void cfm_op(const int tid)
 	   Output arrays are not freed as they are required for validation */
         c2_free(fid_in[tid]);
         c2_free(cob_fid_in[tid]);
+
+	rc = c2_db_tx_commit(&dtx.tx_dbtx);
+	C2_UT_ASSERT(rc == 0);
 }
 
 /* Test concurrent operation across multiple threads for a cobfid_map */
@@ -582,6 +618,7 @@ static void test_cfm_concurrency(void)
 	uint64_t		  cid;
 	struct c2_uint128         cob_fid;
 	struct c2_fid             fid;
+	struct c2_dtx             dtx;
 
 	/* Reset any existing database */
 	rc = c2_ut_db_reset(concurrency_test_map);
@@ -591,6 +628,9 @@ static void test_cfm_concurrency(void)
         rc = c2_dbenv_init(&cfm_global_dbenv, concurrency_test_map, 0);
         C2_UT_ASSERT(rc == 0);
 
+	rc = c2_db_tx_init(&dtx.tx_dbtx, &cfm_global_dbenv, 0);
+        C2_UT_ASSERT(rc == 0);
+
 	c2_addb_ctx_init(&cfm_global_addb_ctx, &cfm_ut_addb_ctx_type,
 			 &c2_addb_global_ctx);
 
@@ -636,7 +676,7 @@ static void test_cfm_concurrency(void)
 	tid_rec_nr = 0;
 
 	while ((rc = c2_cobfid_map_iter_next(&cfm_iter, &cid, &fid,
-					     &cob_fid)) == 0) {
+					     &cob_fid, &dtx)) == 0) {
 		/* Check the ordering of enumeration. The data from all the
 		   threads has to be in correct order. */
                 C2_UT_ASSERT(c2_fid_eq(&fid_out[tid][tid_rec_nr], &fid));
@@ -669,6 +709,8 @@ static void test_cfm_concurrency(void)
         C2_UT_ASSERT(rec_nr == CFM_THREAD_NR * MULTIPLE_BUF_REC_NR);
 
 	/* Cleanup */
+	c2_db_tx_commit(&dtx.tx_dbtx);
+	C2_UT_ASSERT(rc == 0);
 	c2_cobfid_map_fini(&cfm_global_map);
 	c2_dbenv_fini(&cfm_global_dbenv);
 
diff --git a/layout/layout.c b/layout/layout.c
index 5c3a75e..4e1db56 100644
--- a/layout/layout.c
+++ b/layout/layout.c
@@ -525,14 +525,6 @@ static int l_key_cmp(struct c2_table *table,
 
 /** table_ops for the layouts table. */
 static const struct c2_table_ops layouts_table_ops = {
-	.to = {
-		[TO_KEY] = {
-			.max_size = sizeof(struct c2_uint128)
-		},
-		[TO_REC] = {
-			.max_size = ~0
-		}
-	},
 	.key_cmp = l_key_cmp
 };
 
diff --git a/layout/list_enum.c b/layout/list_enum.c
index 7db5af0..72ade5e 100644
--- a/layout/list_enum.c
+++ b/layout/list_enum.c
@@ -101,14 +101,6 @@ static int lcl_key_cmp(struct c2_table *table,
 
 /** table_ops for cob_lists table. */
 static const struct c2_table_ops cob_lists_table_ops = {
-	.to = {
-		[TO_KEY] = {
-			.max_size = sizeof(struct cob_lists_key)
-		},
-		[TO_REC] = {
-			.max_size = sizeof(struct cob_lists_rec)
-		}
-	},
 	.key_cmp = lcl_key_cmp
 };
 
diff --git a/layout/ut/ldemo.c b/layout/ut/ldemo.c
index 2b4400d..40f4f19 100644
--- a/layout/ut/ldemo.c
+++ b/layout/ut/ldemo.c
@@ -18,10 +18,10 @@
  * Original creation date: 07/15/2010
  */
 
-#include <stdio.h>  /* printf */
-#include <stdlib.h> /* atoi */
 #include <math.h>   /* sqrt */
+#include <stdlib.h> /* atoi */
 
+#include "lib/string.h"  /* printf */
 #include "lib/misc.h"   /* C2_SET0 */
 #include "lib/memory.h"
 #include "lib/assert.h"
diff --git a/lib/assert.c b/lib/assert.c
index 3b9b9e9..ab40a65 100644
--- a/lib/assert.c
+++ b/lib/assert.c
@@ -22,13 +22,13 @@
 #  include "config.h"
 #endif
 
-#include <stdio.h>  /* fprintf, fflush */
 #include <stdlib.h> /* abort */
 
 #ifdef HAVE_BACKTRACE
 #  include <execinfo.h>
 #endif
 
+#include "lib/string.h"  /* fprintf, fflush */
 #include "lib/trace.h"
 #include "lib/errno.h"
 #include "lib/assert.h"
diff --git a/lib/finject.c b/lib/finject.c
index acc3742..dea4668 100644
--- a/lib/finject.c
+++ b/lib/finject.c
@@ -25,12 +25,7 @@
 
 #ifdef ENABLE_FAULT_INJECTION
 
-#ifdef __KERNEL__
-#include <linux/kernel.h>  /* snprintf */
-#else
-#include <stdio.h>         /* snprintf */
-#endif
-
+#include "lib/string.h"    /* snprintf */
 #include "lib/errno.h"     /* ENOMEM */
 #include "lib/memory.h"    /* C2_ALLOC_ARR */
 #include "lib/mutex.h"     /* c2_mutex */
diff --git a/lib/getopts.c b/lib/getopts.c
index c9b35a3..0adbcbc 100644
--- a/lib/getopts.c
+++ b/lib/getopts.c
@@ -20,9 +20,10 @@
 
 #define _POSIX_C_SOURCE 2 /* for getopt */
 #include <unistd.h>     /* getopt */
-#include <stdio.h>      /* fprintf, sscanf */
 #include <stdlib.h>     /* strtoull */
 
+#include "lib/string.h" /* fprintf, sscanf */
+
 /* getopt(3) interface */
 extern char *optarg;
 extern int   optind;
diff --git a/lib/thread.c b/lib/thread.c
index 3eefa17..e9d0429 100644
--- a/lib/thread.c
+++ b/lib/thread.c
@@ -21,9 +21,9 @@
 
 #ifndef __KERNEL__
 #include <stdarg.h>
-#include <stdio.h>	/* vsnprintf */
 #endif
 
+#include "lib/string.h"	/* vsnprintf */
 #include "lib/misc.h"   /* C2_SET0 */
 #include "lib/thread.h"
 
diff --git a/lib/ub.c b/lib/ub.c
index 648a96e..652286d 100644
--- a/lib/ub.c
+++ b/lib/ub.c
@@ -19,10 +19,10 @@
  */
 
 #define _ISOC99_SOURCE /* INFINITY */
-#include <stdio.h>     /* printf */
 #include <sys/time.h>  /* gettimeofday */
 #include <math.h>      /* sqrt */
 
+#include "lib/string.h" /* printf */
 #include "lib/misc.h"   /* C2_SET0 */
 #include "lib/assert.h"
 #include "lib/arith.h"
diff --git a/lib/user_space/finject_init.c b/lib/user_space/finject_init.c
index 0f89144..b830495 100644
--- a/lib/user_space/finject_init.c
+++ b/lib/user_space/finject_init.c
@@ -23,13 +23,13 @@
 #include "config.h"
 #endif
 
-#include <stdio.h>         /* printf */
 
 #ifdef ENABLE_FAULT_INJECTION
 
 #include <stdlib.h>        /* random */
 #include <unistd.h>        /* getpid */
 
+#include "lib/string.h"    /* printf */
 #include "lib/mutex.h"     /* c2_mutex */
 #include "lib/time.h"      /* c2_time_now */
 #include "lib/finject.h"
diff --git a/lib/user_space/processor.c b/lib/user_space/processor.c
index 1de5428..e6c37b8 100644
--- a/lib/user_space/processor.c
+++ b/lib/user_space/processor.c
@@ -22,9 +22,7 @@
 #  include "config.h"
 #endif
 
-#include <stdio.h>
 #include <stdlib.h>
-#include <string.h>
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <dirent.h>
@@ -32,6 +30,7 @@
 #include <linux/limits.h>
 #include <sched.h> /* sched_getcpu() */
 
+#include "lib/string.h"
 #include "lib/errno.h"
 #include "lib/memory.h"
 #include "lib/processor.h"
diff --git a/lib/user_space/utrace.c b/lib/user_space/utrace.c
index 392eb6c..22af85e 100644
--- a/lib/user_space/utrace.c
+++ b/lib/user_space/utrace.c
@@ -22,12 +22,12 @@
 #include <errno.h>
 #include <err.h>
 #include <sysexits.h>
-#include <stdio.h>
 #include <stdlib.h>   /* getenv, strtoul */
 #include <unistd.h>   /* getpagesize */
 #include <fcntl.h>    /* open, O_RDWR|O_CREAT|O_TRUNC */
 #include <sys/mman.h> /* mmap */
 
+#include "lib/string.h"
 #include "lib/arith.h"
 #include "lib/memory.h"
 #include "lib/trace.h"
diff --git a/lib/ut.c b/lib/ut.c
index bac5121..0907656 100644
--- a/lib/ut.c
+++ b/lib/ut.c
@@ -24,9 +24,9 @@
 #include <CUnit/TestRun.h>
 
 #include <stdlib.h>                /* system */
-#include <stdio.h>                 /* asprintf */
 #include <unistd.h>                /* dup, dup2 */
 
+#include "lib/string.h"            /* asprintf */
 #include "lib/assert.h"            /* C2_ASSERT */
 #include "lib/thread.h"            /* LAMBDA */
 #include "lib/memory.h"            /* c2_allocated */
diff --git a/lib/ut.h b/lib/ut.h
index 5f025ee..aa0f183 100644
--- a/lib/ut.h
+++ b/lib/ut.h
@@ -24,12 +24,12 @@
 
 #ifndef __KERNEL__
 # include <stdbool.h>     /* bool */
-# include <stdio.h>       /* FILE, fpos_t */
 # include <CUnit/Basic.h>
 #else
 # include "lib/types.h"
 #endif
 
+#include "lib/string.h"      /* FILE, fpos_t */
 #include "lib/list.h" /* c2_list_link, c2_list */
 
 /**
diff --git a/lib/ut/processor.c b/lib/ut/processor.c
index 5a19421..22e6bbb 100644
--- a/lib/ut/processor.c
+++ b/lib/ut/processor.c
@@ -17,12 +17,13 @@
  * Original creation date: 03/17/2011
  */
 
-#include <stdio.h>
 #include <stdlib.h>
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <unistd.h>
 #include <linux/limits.h>
+
+#include "lib/string.h"
 #include "lib/ut.h"
 #include "lib/ub.h"
 #include "lib/assert.h"
diff --git a/net/bulk_emulation/mem_xprt_ep.c b/net/bulk_emulation/mem_xprt_ep.c
index f5ecc2c..114b1bb 100644
--- a/net/bulk_emulation/mem_xprt_ep.c
+++ b/net/bulk_emulation/mem_xprt_ep.c
@@ -21,9 +21,7 @@
 
 /* This file is included into mem_xprt_xo.c */
 
-#ifndef __KERNEL__
-#include <stdio.h> /* sprintf */
-#endif
+#include "lib/string.h" /* sprintf */
 
 /**
    @addtogroup bulkmem
diff --git a/net/bulk_emulation/st/main.c b/net/bulk_emulation/st/main.c
index b64ce87..cdb5808 100644
--- a/net/bulk_emulation/st/main.c
+++ b/net/bulk_emulation/st/main.c
@@ -23,8 +23,6 @@
 #endif
 
 #include <stdlib.h>
-#include <stdio.h>
-#include <string.h>
 
 #include <sys/socket.h>
 #ifdef HAVE_NETINET_IN_H
@@ -34,6 +32,7 @@
 #include <netdb.h>
 
 #include "colibri/init.h"
+#include "lib/string.h"
 #include "lib/assert.h"
 #include "lib/errno.h"
 #include "lib/getopts.h"
diff --git a/net/bulk_emulation/st/ping.h b/net/bulk_emulation/st/ping.h
index ea3d800..5951503 100644
--- a/net/bulk_emulation/st/ping.h
+++ b/net/bulk_emulation/st/ping.h
@@ -70,12 +70,13 @@ enum {
 	PART3_SERVER_ID = 141421,
 };
 
+#include "lib/string.h"
+
 #define PRId64 "lld" /* from <inttypes.h> */
 /* Debug printf macro */
 #ifdef __KERNEL__
 #define PING_ERR(fmt, ...) printk(KERN_ERR fmt , ## __VA_ARGS__)
 #else
-#include <stdio.h>
 #define PING_ERR(fmt, ...) fprintf(stderr, fmt , ## __VA_ARGS__)
 #endif
 
diff --git a/net/lnet/lnet_core.c b/net/lnet/lnet_core.c
index d975006..f050c1b 100644
--- a/net/lnet/lnet_core.c
+++ b/net/lnet/lnet_core.c
@@ -20,10 +20,11 @@
  */
 
 #ifndef __KERNEL__
-#include <stdio.h>   /* snprintf */
 #include <stdlib.h>  /* strtoull */
 #endif /* __KERNEL__ */
 
+#include "lib/string.h"   /* snprintf */
+
 /**
    @addtogroup LNetCore
    @{
diff --git a/net/lnet/st/main.c b/net/lnet/st/main.c
index 14a48db..1d1d589 100644
--- a/net/lnet/st/main.c
+++ b/net/lnet/st/main.c
@@ -24,10 +24,9 @@
 #endif
 
 #include <stdlib.h>
-#include <stdio.h>
-#include <string.h>
 
 #include "colibri/init.h"
+#include "lib/string.h"
 #include "lib/assert.h"
 #include "lib/errno.h"
 #include "lib/getopts.h"
diff --git a/net/lnet/st/ping.h b/net/lnet/st/ping.h
index 04030d4..c48cf2d 100644
--- a/net/lnet/st/ping.h
+++ b/net/lnet/st/ping.h
@@ -140,11 +140,12 @@ enum {
 	SEC_PER_MIN = 60,
 };
 
+#include "lib/string.h"
+
 /* Debug printf macro */
 #ifdef __KERNEL__
 #define PING_ERR(fmt, ...) printk(KERN_ERR fmt , ## __VA_ARGS__)
 #else
-#include <stdio.h>
 #define PING_ERR(fmt, ...) fprintf(stderr, fmt , ## __VA_ARGS__)
 #endif
 
diff --git a/net/lnet/ut/lut_main.c b/net/lnet/ut/lut_main.c
index bba9c62..c501eae 100644
--- a/net/lnet/ut/lut_main.c
+++ b/net/lnet/ut/lut_main.c
@@ -21,11 +21,11 @@
 #include <sys/ioctl.h>
 #include <sys/stat.h>
 #include <fcntl.h>
-#include <stdio.h>
 #include <stdlib.h> /* exit */
 #include <unistd.h> /* getuid, close, read, write, lseek */
 
 #include "colibri/init.h"
+#include "lib/string.h"
 #include "lib/arith.h" /* c2_is_po2 */
 #include "lib/assert.h"
 #include "lib/errno.h"
diff --git a/net/ut/utils.c b/net/ut/utils.c
index a0af1c2..777e6e8 100644
--- a/net/ut/utils.c
+++ b/net/ut/utils.c
@@ -17,11 +17,11 @@
  * Original creation date: 05/07/2010
  */
 
-#include <stdio.h>
-#include <string.h>
 #include <CUnit/Basic.h>
 #include <net/net.h>
 
+#include "lib/string.h"
+
 /* The suite initialization function.
  * Returns zero on success, non-zero otherwise.
  */
diff --git a/reqh/reqh_service.c b/reqh/reqh_service.c
index f0f8ecb..c3b9c25 100644
--- a/reqh/reqh_service.c
+++ b/reqh/reqh_service.c
@@ -22,6 +22,7 @@
 #include "config.h"
 #endif
 
+#include "lib/string.h"     /* snprintf */
 #include "lib/rwlock.h"
 #include "lib/errno.h"
 #include "lib/memory.h"
diff --git a/reqh/ut/reqh_fom_ut.c b/reqh/ut/reqh_fom_ut.c
index 3f7712d..e84ec1b 100644
--- a/reqh/ut/reqh_fom_ut.c
+++ b/reqh/ut/reqh_fom_ut.c
@@ -21,12 +21,12 @@
 #include "config.h"
 #endif
 
-#include <stdio.h>
 #include <stdlib.h>
 #include <sys/stat.h>	/* mkdir */
 #include <sys/types.h>	/* mkdir */
 #include <err.h>
 
+#include "lib/string.h"
 #include "lib/ut.h"
 
 #include "net/net.h"
diff --git a/rpc/conn.c b/rpc/conn.c
index 8050c53..d72490b 100644
--- a/rpc/conn.c
+++ b/rpc/conn.c
@@ -23,6 +23,7 @@
 #include "config.h"
 #endif
 
+#include "lib/string.h"     /* sprintf, printf */
 #include "lib/errno.h"
 #include "lib/memory.h"
 #include "lib/misc.h"
diff --git a/rpc/it/rpc_ping.c b/rpc/it/rpc_ping.c
index ab42f5a..8fcc656 100644
--- a/rpc/it/rpc_ping.c
+++ b/rpc/it/rpc_ping.c
@@ -24,6 +24,7 @@
 #endif
 
 #include "colibri/init.h"
+#include "lib/string.h"
 #include "lib/assert.h"
 #include "lib/errno.h"
 #include "lib/getopts.h"
@@ -43,13 +44,10 @@
 #include "rpc/it/ping_fop_ff.h"
 
 #ifdef __KERNEL__
-#include <linux/kernel.h>
-#include "rpc/it/linux_kernel/rpc_ping.h"
-#define printf printk
+# include "rpc/it/linux_kernel/rpc_ping.h"
+# define printf printk
 #else
-#include <stdlib.h>
-#include <stdio.h>
-#include <string.h>
+# include <stdlib.h>
 #endif
 
 #ifndef __KERNEL__
diff --git a/rpc/rpclib.c b/rpc/rpclib.c
index aa2449a..8110d96 100644
--- a/rpc/rpclib.c
+++ b/rpc/rpclib.c
@@ -23,11 +23,8 @@
 #include "config.h"
 #endif
 
-#ifndef __KERNEL__
-#include <errno.h> /* errno */
-#include <stdio.h> /* fopen(), fclose() */
-#endif
-
+#include "lib/errno.h"   /* errno */
+#include "lib/string.h"
 #include "lib/cdefs.h"
 #include "lib/types.h"
 #include "lib/memory.h"
diff --git a/rpc/rpclib.h b/rpc/rpclib.h
index fe5f7e6..05c3154 100644
--- a/rpc/rpclib.h
+++ b/rpc/rpclib.h
@@ -23,10 +23,7 @@
 #ifndef __COLIBRI_RPC_RPCLIB_H__
 #define __COLIBRI_RPC_RPCLIB_H__
 
-#ifndef __KERNEL__
-#include <stdio.h> /* FILE */
-#endif
-
+#include "lib/string.h"
 #include "rpc/item.h"    /* struct c2_rpc_machine, c2_rpc_item */
 #include "rpc/rpc2.h"
 #include "rpc/session.h" /* struct c2_rpc_conn, c2_rpc_session */
diff --git a/rpc/session.c b/rpc/session.c
index 22e9959..72fe611 100644
--- a/rpc/session.c
+++ b/rpc/session.c
@@ -23,6 +23,7 @@
 #include "config.h"
 #endif
 
+#include "lib/string.h"     /* sprintf */
 #include "lib/errno.h"
 #include "lib/memory.h"
 #include "lib/misc.h"
diff --git a/rpc/slot.c b/rpc/slot.c
index 9cb1c4b..2eca627 100644
--- a/rpc/slot.c
+++ b/rpc/slot.c
@@ -22,6 +22,7 @@
 #include "config.h"
 #endif
 
+#include "lib/string.h"     /* sprintf */
 #include "lib/errno.h"
 #include "lib/memory.h"
 #include "lib/misc.h"
diff --git a/sns/ut/parity_math_mt_ub.c b/sns/ut/parity_math_mt_ub.c
index b6b7e6f..ebd94b7 100644
--- a/sns/ut/parity_math_mt_ub.c
+++ b/sns/ut/parity_math_mt_ub.c
@@ -17,11 +17,10 @@
  * Original creation date: 10/19/2010
  */
 
-#include <stdio.h>
 #include <stdlib.h>
-#include <string.h>
 #include <time.h>
 
+#include "lib/string.h"
 #include "lib/types.h"
 #include "lib/adt.h"
 #include "lib/assert.h"
diff --git a/stob/ad.c b/stob/ad.c
index ed36611..c0b0d1c 100644
--- a/stob/ad.c
+++ b/stob/ad.c
@@ -1,3 +1,4 @@
+/* -*- C -*- */
 /*
  * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
  *
@@ -21,11 +22,10 @@
 #  include "config.h"
 #endif
 
-#include <errno.h>
-#include <string.h>                 /* memset */
-
 #include "db/extmap.h"
 #include "dtm/dtm.h"                /* c2_dtx */
+#include "lib/errno.h"
+#include "lib/string.h"             /* memset, sprintf */
 #include "lib/thread.h"             /* LAMBDA */
 #include "lib/memory.h"
 #include "lib/arith.h"              /* min_type, min3 */
diff --git a/stob/linux.c b/stob/linux.c
index 7c4067c..2411a36 100644
--- a/stob/linux.c
+++ b/stob/linux.c
@@ -21,14 +21,13 @@
 #  include "config.h"
 #endif
 
-#include <stdio.h>
 #include <unistd.h>                    /* close */
 #include <stdlib.h>
-#include <string.h>
 #include <sys/stat.h>
 #include <sys/types.h>
 #include <fcntl.h>
 
+#include "lib/string.h"
 #include "lib/errno.h"
 #include "lib/memory.h"
 #include "lib/assert.h"
diff --git a/stob/ut/ad.c b/stob/ut/ad.c
index 78fdc84..3c9dd44 100644
--- a/stob/ut/ad.c
+++ b/stob/ut/ad.c
@@ -22,7 +22,6 @@
 #endif
 
 #include <stdlib.h>    /* system */
-#include <stdio.h>     /* fopen, fgetc, ... */
 #include <unistd.h>    /* unlink */
 #include <sys/stat.h>  /* mkdir */
 #include <sys/types.h> /* mkdir */
diff --git a/stob/ut/adieu.c b/stob/ut/adieu.c
index d95b9b8..f1ad42e 100644
--- a/stob/ut/adieu.c
+++ b/stob/ut/adieu.c
@@ -22,11 +22,11 @@
 #endif
 
 #include <stdlib.h>    /* system */
-#include <stdio.h>     /* fopen, fgetc, ... */
 #include <unistd.h>    /* unlink */
 #include <sys/stat.h>  /* mkdir */
 #include <sys/types.h> /* mkdir */
 
+#include "lib/string.h" /* fopen, fgetc, ... */
 #include "lib/misc.h"   /* C2_SET0 */
 #include "lib/memory.h" /* c2_alloc_align */
 #include "lib/errno.h"
diff --git a/stob/ut/stobio.c b/stob/ut/stobio.c
index 6f0270b..d54061e 100644
--- a/stob/ut/stobio.c
+++ b/stob/ut/stobio.c
@@ -18,7 +18,6 @@
  */
 
 #include <stdlib.h>    /* system */
-#include <stdio.h>     /* fopen, fgetc, ... */
 #include <sys/stat.h>  /* mkdir */
 #include <sys/types.h> /* mkdir */
 #include <linux/limits.h>
diff --git a/xcode/ut/ff2c.c b/xcode/ut/ff2c.c
index 0f6dc6a..2d4b36c 100644
--- a/xcode/ut/ff2c.c
+++ b/xcode/ut/ff2c.c
@@ -18,7 +18,7 @@
  * Original creation date: 30-Dec-2011
  */
 
-#include <stdio.h>                          /* printf, stdout */
+#include "lib/string.h"                     /* printf, stdout */
 
 #include "lib/misc.h"                       /* C2_SET0 */
 #include "lib/ut.h"
diff --git a/xcode/ut/xcode.c b/xcode/ut/xcode.c
index 282b5ce..d65ab24 100644
--- a/xcode/ut/xcode.c
+++ b/xcode/ut/xcode.c
@@ -18,10 +18,7 @@
  * Original creation date: 28-Dec-2011
  */
 
-#ifndef __KERNEL__
-#include <stdio.h>                          /* printf */
-#endif
-
+#include "lib/string.h"                     /* printf */
 #include "lib/memory.h"
 #include "lib/vec.h"                        /* c2_bufvec */
 #include "lib/misc.h"                       /* C2_SET0 */
diff --git a/yaml2db/st/main.c b/yaml2db/st/main.c
index 882be1e..186b6e2 100644
--- a/yaml2db/st/main.c
+++ b/yaml2db/st/main.c
@@ -23,6 +23,7 @@
 #endif
 
 #include "colibri/init.h"
+#include "lib/thread.h"
 #include "lib/errno.h"
 #include "lib/getopts.h"
 #include "lib/misc.h"
diff --git a/yaml2db/yaml2db.c b/yaml2db/yaml2db.c
index 4842879..1e4c991 100644
--- a/yaml2db/yaml2db.c
+++ b/yaml2db/yaml2db.c
@@ -425,7 +425,7 @@ int c2_yaml2db_conf_load(struct c2_yaml2db_ctx *yctx,
 			 const char *conf_param)
 {
         int                      rc;
-	/* gcc extension */
+	/* C99 variable length array */
 	bool			 valid_key_status[ysec->ys_num_keys];
 	bool			 mandatory_keys_present;
 	size_t			 section_index;
-- 
1.8.3.2

