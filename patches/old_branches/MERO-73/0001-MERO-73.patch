From 4d63e2425241818d6263738fb6dc22a2fb6a773c Mon Sep 17 00:00:00 2001
From: Mandar Sawant <mandar_sawant@xyratex.com>
Date: Fri, 14 Mar 2014 12:02:42 +0530
Subject: [PATCH 1/2] MERO-73, - Fix cacaded sns repair issue, reset struct
 m0_cm_sw_update::swu_is_complete on every   sns repair start operation. -
 Handle sns repair restart case for existing sliding window values. - Separate
 m0_be_tx_fini() from m0_cm_prepare_done() to handle the case where PREPARE  
 phase is skipped in case of existing sliding window.

---
 cm/cm.c                                        | 10 ++++--
 cm/sw.c                                        |  5 +--
 cm/sw.h                                        |  1 +
 cm/sw_update_fom.c                             | 11 +++---
 fop/fom.c                                      |  3 +-
 m0t1fs/linux_kernel/st/m0t1fs_sns_repair_mf.sh | 49 ++++++++++++++++++--------
 sns/cm/trigger_fom.c                           | 46 +++++++++++++++---------
 7 files changed, 83 insertions(+), 42 deletions(-)

diff --git a/cm/cm.c b/cm/cm.c
index b0a2c33..166bd4c 100644
--- a/cm/cm.c
+++ b/cm/cm.c
@@ -470,7 +470,7 @@ static struct m0_sm_state_descr cm_state_descr[M0_CMS_NR] = {
 		.sd_flags	= 0,
 		.sd_name	= "cm_idle",
 		.sd_allowed	= M0_BITS(M0_CMS_FAIL, M0_CMS_PREPARE,
-					  M0_CMS_FINI)
+					  M0_CMS_READY, M0_CMS_FINI)
 	},
 	[M0_CMS_PREPARE] = {
 		.sd_flags	= 0,
@@ -762,13 +762,17 @@ M0_INTERNAL int m0_cm_prepare_sw_store_commit(struct m0_cm *cm)
 	return rc;
 }
 
+M0_INTERNAL void m0_cm_prepare_sw_store_fini(struct m0_cm *cm)
+{
+	m0_cm_sw_store_fini(cm);
+}
+
 M0_INTERNAL int m0_cm_prepare_done(struct m0_cm *cm)
 {
 	int             rc;
 	struct m0_cm_sw sw;
 
 	m0_cm_lock(cm);
-	m0_cm_sw_store_fini(cm);
 	rc = m0_cm_sw_store_load(cm, &sw);
 	if (rc == 0)
 		cm->cm_last_saved_sw_hi = sw.sw_lo;
@@ -794,7 +798,7 @@ M0_INTERNAL int m0_cm_ready(struct m0_cm *cm)
 	M0_PRE(cm->cm_type != NULL);
 
 	m0_cm_lock(cm);
-	M0_PRE(m0_cm_state_get(cm) == M0_CMS_PREPARE);
+	M0_PRE(M0_IN(m0_cm_state_get(cm), (M0_CMS_IDLE, M0_CMS_PREPARE)));
 	M0_PRE(m0_cm_invariant(cm));
 
 	cm->cm_ready_fops_recvd = 0;
diff --git a/cm/sw.c b/cm/sw.c
index 0f8a2ab..19a4c5b 100644
--- a/cm/sw.c
+++ b/cm/sw.c
@@ -138,18 +138,19 @@ M0_INTERNAL int m0_cm_sw_store_init(struct m0_cm *cm, struct m0_sm_group *grp)
 	char                   cm_sw_name[80];
 	int                    rc;
 
+	M0_SET0(tx);
 	sprintf(cm_sw_name, "cm_sw_%llu", (unsigned long long)cm->cm_id);
 	rc = m0_be_seg_dict_lookup(seg, cm_sw_name, (void**)&sw);
 	if (rc == 0)
 		return rc;
 
-	M0_SET0(tx);
 	m0_be_tx_init(tx, 0, seg->bs_domain, grp, NULL, NULL, NULL, NULL);
 	M0_BE_ALLOC_CREDIT_PTR(sw, seg, &cred);
 	m0_be_seg_dict_insert_credit(seg, cm_sw_name, &cred);
 	m0_be_tx_prep(tx, &cred);
 	m0_be_tx_open(tx);
-	return 0;
+	M0_ASSERT(tx->t_sm.sm_rc == 0);
+	return rc;
 }
 
 M0_INTERNAL int m0_cm_sw_store_commit(struct m0_cm *cm)
diff --git a/cm/sw.h b/cm/sw.h
index 4e72d75..fe14eb3 100644
--- a/cm/sw.h
+++ b/cm/sw.h
@@ -89,6 +89,7 @@ M0_INTERNAL int m0_cm_sw_remote_update(struct m0_cm *cm);
  * @param grp This group is used for sliding window BE transactions.
  */
 M0_INTERNAL int m0_cm_sw_store_init(struct m0_cm *cm, struct m0_sm_group *grp);
+M0_INTERNAL void m0_cm_sw_store_fini(struct m0_cm *cm);
 
 /**
  * Prepares sliding window persistent store for this copy machine.
diff --git a/cm/sw_update_fom.c b/cm/sw_update_fom.c
index 9584dd8..d5694fa 100644
--- a/cm/sw_update_fom.c
+++ b/cm/sw_update_fom.c
@@ -232,13 +232,15 @@ static int swu_complete(struct m0_cm_sw_update *swu)
 					     &tx->tx_betx_cred);
         }
 
-        if (m0_be_tx_state(&tx->tx_betx) == M0_BTS_PREPARE) {
+        if (m0_be_tx_state(&tx->tx_betx) == M0_BTS_PREPARE)
                 m0_dtx_open(tx);
-                return M0_FSO_AGAIN;
-        } else if (m0_be_tx_state(&tx->tx_betx) == M0_BTS_OPENING) {
+	if (m0_be_tx_state(&tx->tx_betx) == M0_BTS_FAILED)
+		M0_RETURN(tx->tx_betx.t_sm.sm_rc);
+        if (m0_be_tx_state(&tx->tx_betx) == M0_BTS_OPENING) {
                 m0_fom_wait_on(fom, &tx->tx_betx.t_sm.sm_chan, &fom->fo_cb);
                 return M0_FSO_WAIT;
-        }
+        } else
+		m0_dtx_opened(tx);
 
 	M0_BE_FREE_PTR_SYNC(sw, seg, &tx->tx_betx);
 	m0_be_seg_dict_delete(seg, &tx->tx_betx, cm_sw_name);
@@ -305,6 +307,7 @@ M0_INTERNAL void m0_cm_sw_update_start(struct m0_cm *cm)
 {
 	struct m0_fom *fom = &cm->cm_sw_update.swu_fom;
 
+	cm->cm_sw_update.swu_is_complete = false;
 	m0_fom_init(fom, &cm_sw_update_fom_type, &cm_sw_update_fom_ops, NULL,
 		    NULL, cm->cm_service.rs_reqh, cm->cm_service.rs_type);
 	m0_fom_queue(fom, cm->cm_service.rs_reqh);
diff --git a/fop/fom.c b/fop/fom.c
index 3bf6a27..449b8be 100644
--- a/fop/fom.c
+++ b/fop/fom.c
@@ -1123,8 +1123,9 @@ void m0_fom_fini(struct m0_fom *fom)
 				M0_FOM_ADDB_CTX_VEC(fom));
 		m0_sm_stats_post(&fom->fo_sm_state, &reqh->rh_addb_mc,
 				M0_FOM_ADDB_CTX_VEC(fom));
-		m0_addb_sm_counter_fini(&fom->fo_sm_state_stats);
 	}
+	if (fom->fo_sm_state_stats.asc_data != NULL)
+		m0_addb_sm_counter_fini(&fom->fo_sm_state_stats);
 	if (fom->fo_sm_phase_stats.asc_data != NULL) {
 		m0_free(fom->fo_sm_phase_stats.asc_data);
 		m0_addb_sm_counter_fini(&fom->fo_sm_phase_stats);
diff --git a/m0t1fs/linux_kernel/st/m0t1fs_sns_repair_mf.sh b/m0t1fs/linux_kernel/st/m0t1fs_sns_repair_mf.sh
index 98e3e55..a99011e 100755
--- a/m0t1fs/linux_kernel/st/m0t1fs_sns_repair_mf.sh
+++ b/m0t1fs/linux_kernel/st/m0t1fs_sns_repair_mf.sh
@@ -18,7 +18,7 @@ sns_repair_test()
 	local N=3
 	local K=3
 	local P=9
-	local stride=20
+	local stride=32
 	local unit_size=$((stride * 1024))
 
 	echo "Starting SNS repair testing ..."
@@ -34,26 +34,27 @@ sns_repair_test()
 		return 1
 	}
 
-	dd if=/dev/urandom bs=$unit_size count=50 \
-	   of=$MERO_M0T1FS_MOUNT_DIR/file2_to_repair >> $MERO_TEST_LOGFILE || {
-		echo "Failed: dd failed.."
-		unmount_and_clean &>> $MERO_TEST_LOGFILE
-		return 1
-	}
 
-	dd if=/dev/urandom bs=$unit_size count=50 \
-	   of=$MERO_M0T1FS_MOUNT_DIR/file3_to_repair >> $MERO_TEST_LOGFILE || {
-		echo "Failed: dd failed.."
-		unmount_and_clean &>> $MERO_TEST_LOGFILE
-		return 1
-	}
+#	dd if=/dev/urandom bs=$unit_size count=50 \
+#	   of=$MERO_M0T1FS_MOUNT_DIR/file2_to_repair >> $MERO_TEST_LOGFILE || {
+#		echo "Failed: dd failed.."
+#		unmount_and_clean &>> $MERO_TEST_LOGFILE
+#		return 1
+#	}
+#
+#	dd if=/dev/urandom bs=$unit_size count=50 \
+#	   of=$MERO_M0T1FS_MOUNT_DIR/file3_to_repair >> $MERO_TEST_LOGFILE || {
+#		echo "Failed: dd failed.."
+#		unmount_and_clean &>> $MERO_TEST_LOGFILE
+#		return 1
+#	}
 
 	for ((i=1; i < ${#EP[*]}; i++)) ; do
 		IOSEP="$IOSEP -S ${lnet_nid}:${EP[$i]}"
 	done
 
 ####### Set Failure device
-	pool_mach_set_failure $fail_device1 $fail_device2
+	pool_mach_set_failure $fail_device1
 	if [ $? -ne "0" ]
 	then
 		return $?
@@ -66,12 +67,30 @@ sns_repair_test()
 	fi
 ####### Query device state
 
-	pool_mach_query $fail_device1 $fail_device2
+	pool_mach_query $fail_device1
+	if [ $? -ne "0" ]
+	then
+		return $?
+	fi
+
+	pool_mach_set_failure $fail_device2
 	if [ $? -ne "0" ]
 	then
 		return $?
 	fi
 
+	sns_repair
+	if [ $? -ne "0" ]
+	then
+		return $?
+	fi
+####### Query device state
+
+	pool_mach_query $fail_device2
+	if [ $? -ne "0" ]
+	then
+		return $?
+	fi
 	pool_mach_set_failure $fail_device3
 	if [ $? -ne "0" ]
 	then
diff --git a/sns/cm/trigger_fom.c b/sns/cm/trigger_fom.c
index 4a69c23..c3298cb 100644
--- a/sns/cm/trigger_fom.c
+++ b/sns/cm/trigger_fom.c
@@ -82,7 +82,7 @@ enum trigger_phases {
 static struct m0_sm_state_descr trigger_phases[] = {
 	[TPH_PREPARE_INIT] = {
 		.sd_name      = "Initialise local sw store",
-		.sd_allowed   = M0_BITS(TPH_PREPARE_WAIT, TPH_FINI)
+		.sd_allowed   = M0_BITS(TPH_PREPARE_WAIT, TPH_READY, TPH_FINI)
 	},
 	[TPH_PREPARE_WAIT] = {
 		.sd_name      = "Wait till sw store is initialised",
@@ -221,9 +221,12 @@ static int trigger_fom_tick(struct m0_fom *fom)
 				if (rc != 0)
 					goto fail;
 				rc = m0_cm_prepare_sw_store_init(cm, grp);
-				if (rc != 0)
+				if (rc != 0 && rc != -ENOENT)
 					goto fail;
-				m0_fom_phase_set(fom, TPH_PREPARE_WAIT);
+				if (rc == -ENOENT)
+					m0_fom_phase_set(fom, TPH_PREPARE_WAIT);
+				else
+					m0_fom_phase_set(fom, TPH_PREPARE_DONE);
 				rc = M0_FSO_AGAIN;
 				M0_LOG(M0_DEBUG, "got trigger: prepare init");
 				break;
@@ -233,37 +236,46 @@ static int trigger_fom_tick(struct m0_fom *fom)
 					rc = tx->t_sm.sm_rc;
 					goto fail;
 				}
-				else if (m0_be_tx_state(tx) == M0_BTS_OPENING) {
+				if (m0_be_tx_state(tx) == M0_BTS_OPENING) {
 					m0_fom_wait_on(fom, &tx->t_sm.sm_chan,
 							&fom->fo_cb);
 					rc = M0_FSO_WAIT;
 					break;
-				} else {
+				}
+				if (m0_be_tx_state(tx) == M0_BTS_ACTIVE){
 					rc = m0_cm_prepare_sw_store_commit(cm);
 					if (rc != 0)
 						goto fail;
+					m0_fom_phase_set(fom, TPH_PREPARE_DONE);
+					rc = M0_FSO_AGAIN;
 				}
-				m0_fom_phase_set(fom, TPH_PREPARE_DONE);
-				rc = M0_FSO_AGAIN;
 				M0_LOG(M0_DEBUG, "trigger: prepare init wait");
 				break;
 			case TPH_PREPARE_DONE:
+				enum me_be_tx_state state = m0_be_tx_state(tx);
 				tx = &cm->cm_sw_update.swu_tx;
-				if (m0_be_tx_state(tx) == M0_BTS_DONE) {
-					rc = m0_cm_prepare_done(cm);
-					if (rc != 0)
+				if (M0_IN(state, (M0_BTS_FAILED, M0_BTS_DONE))) {
+					rc = tx->t_sm.sm_rc;
+					m0_cm_prepare_sw_store_fini(cm);
+					if (state == M0_BTS_FAILED)
 						goto fail;
-					m0_mutex_lock(&cm->cm_wait_mutex);
-					m0_fom_wait_on(fom, &cm->cm_ready_wait,
-							&fom->fo_cb);
-					m0_mutex_unlock(&cm->cm_wait_mutex);
-					m0_fom_phase_set(fom, TPH_READY);
+				}
+				if (m0_be_tx_state(tx) != M0_BTS_PREPARE &&
+				    m0_be_tx_state(tx) != M0_BTS_DONE) {
+					m0_fom_wait_on(fom, &tx->t_sm.sm_chan,
+						       &fom->fo_cb);
 					rc = M0_FSO_WAIT;
 					break;
 				}
 
-				m0_fom_wait_on(fom, &tx->t_sm.sm_chan,
-					       &fom->fo_cb);
+				rc = m0_cm_prepare_done(cm);
+				if (rc != 0)
+					goto fail;
+				m0_mutex_lock(&cm->cm_wait_mutex);
+				m0_fom_wait_on(fom, &cm->cm_ready_wait,
+						&fom->fo_cb);
+				m0_mutex_unlock(&cm->cm_wait_mutex);
+				m0_fom_phase_set(fom, TPH_READY);
 
 				rc = M0_FSO_WAIT;
 				M0_LOG(M0_DEBUG, "trigger: prepare done");
-- 
1.8.3.2

