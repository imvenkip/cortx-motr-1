From 7f745429e6ad604c133ce73f4a445e004e80884f Mon Sep 17 00:00:00 2001
From: Zishan Shaikh <zishan_shaikh@xyratex.com>
Date: Mon, 11 Feb 2013 04:08:54 -0800
Subject: [PATCH 049/121] ks_insert, delete: tx cannot be NULL change

---
 be/domain.c   |  15 +++---
 be/kv_store.c | 168 +++++++++++++---------------------------------------------
 be/kv_store.h |   4 +-
 3 files changed, 47 insertions(+), 140 deletions(-)

diff --git a/be/domain.c b/be/domain.c
index 5967b50..378fe51 100644
--- a/be/domain.c
+++ b/be/domain.c
@@ -148,6 +148,7 @@ M0_INTERNAL void m0_be_domain_seg_restore(struct m0_be_domain *dom,
 {
         struct  m0_stob_domain   *stob_dom;
         struct  m0_stob_id        stob_id = {{0, 1}}; /* Hardcoded for now. */
+        struct m0_be_seg         *seg_rec;
         int                       result;
         bool                      stob_directio = true;
 
@@ -156,19 +157,20 @@ M0_INTERNAL void m0_be_domain_seg_restore(struct m0_be_domain *dom,
 
         M0_PRE(m0_be_seg_state(&dom->bd_data) == M0_BESEG_ACTIVE);
 
-        seg = m0_be_domain_get_seg(dom, name);
+        seg_rec = m0_be_domain_get_seg(dom, name);
 
-        if (seg && m0_be_seg_state(seg) == M0_BESEG_CLOSED) {
-                m0_be_seg_open(seg);
+        if (seg_rec && m0_be_seg_state(seg_rec) == M0_BESEG_CLOSED) {
+                m0_be_seg_open(seg_rec);
+                seg = seg_rec;
         }
 
-        if (!seg) {
+        if (!seg_rec) {
                 /* Hardcoded for now. */
                 seg->bs_impl.segment_id = 1;
 
                 m0_be_seg_init(seg, dom, &dom->bd_impl.sm_group, 0);
 
-                //m0_stob_type_init(&m0_linux_stob_type);
+                m0_stob_type_init(&m0_linux_stob_type);
                 result = m0_stob_domain_locate(&m0_linux_stob_type, "./__be",
                                                &stob_dom);
                 M0_ASSERT(result == 0);
@@ -225,7 +227,7 @@ M0_INTERNAL bool m0_be_domain_invariant(const struct m0_be_domain *dom)
         sm_group = m0_be_domain_sm_group(sdom);
 
         return  dom != NULL &&
-                dom->bd_magic == M0_BE_DOMAIN_MAGIC &&
+		dom->bd_magic == M0_BE_DOMAIN_MAGIC &&
                 !m0_mutex_is_locked(&sm_group->s_lock);
 }
 
@@ -243,6 +245,7 @@ M0_INTERNAL struct m0_be_seg *m0_be_domain_get_seg(struct m0_be_domain *dom,
         return seg_it;
 }
 
+
 #undef M0_TRACE_SUBSYSTEM
 /** @} end group be_domain */
 
diff --git a/be/kv_store.c b/be/kv_store.c
index 1e2df73..d829e15 100644
--- a/be/kv_store.c
+++ b/be/kv_store.c
@@ -62,7 +62,6 @@ static void __ks_get_current(struct m0_tl_descr   *d,
 static void __ks_prev_next_add_cred(struct m0_be_kv_store     *handle,
                                     struct m0_be_tx           *tx,
                                     void                      *current,
-                                    int                        in_tx_state,
                                     int                        operation);
 
 M0_INTERNAL void m0_be_ks_create_handle(struct m0_be_domain        *dom,
@@ -270,7 +269,7 @@ M0_EXPORTED(m0_be_ks_find);
 
 M0_INTERNAL int m0_be_ks_delete(struct m0_be_kv_store  *handle,
                                 void                   *obj,
-                                struct m0_be_tx        *del_tx)
+                                struct m0_be_tx        *tx)
 {
         void                    *scan;
         void                    *target = NULL;
@@ -282,9 +281,7 @@ M0_INTERNAL int m0_be_ks_delete(struct m0_be_kv_store  *handle,
         struct m0_tl_descr      *ks_list_descr;
         struct m0_be_domain     *ks_dom;
         struct m0_sm_group      *sm_group;
-        struct m0_be_tx         *tx             = del_tx;
-        int                      del_tx_state   = BE_KV_IN_TX_NOT_NULL;
-        int                      target_found;
+        bool                     target_found;
 
         M0_ENTRY();
 
@@ -294,25 +291,16 @@ M0_INTERNAL int m0_be_ks_delete(struct m0_be_kv_store  *handle,
         ks_dom         = handle->handle_heap.ks_dom;
         sm_group       = m0_be_domain_sm_group(ks_dom);
 
-        /* If tx is not provided create and start a new one */
-        if (del_tx == NULL) {
-                del_tx_state = BE_KV_IN_TX_NULL;
-                M0_ALLOC_PTR(tx);
-                M0_ASSERT(tx != NULL);
-
-                m0_be_tx_init(tx, ks_dom, 0);
-        }
-
         /* Find the target node to be deleted */
         m0_tlist_for(ks_list_descr, ks_tlist, scan) {
                 if (handle->handle_heap.ks_key_cmp(scan, obj) == 0) {
                         target = scan;
-                        target_found = BE_KV_SUCCESS;
+                        target_found = true;
                         break;
                 }
         } m0_tlist_endfor;
 
-        if (target_found == BE_KV_SUCCESS) {
+        if (target_found == true) {
                 /* Capture t_head */
                 temp_link   = head->ll_next;
                 t_head_link = temp_link->ll_prev;
@@ -321,55 +309,30 @@ M0_INTERNAL int m0_be_ks_delete(struct m0_be_kv_store  *handle,
                 m0_be_ks_prep_link_reg(ks_dom, t_head_link, tx, &t_head_reg);
                 M0_ASSERT(t_head_reg != NULL);
 
-                if (del_tx == NULL) {
-                        m0_be_tx_add_cred(tx, t_head_reg);
-                } else {
-                        m0_be_reg_capture(t_head_reg);
-                        m0_free(t_head_reg);
-                }
+                m0_be_reg_capture(t_head_reg);
+                m0_free(t_head_reg);
 
                 /*
                  * Add the current, previous and next pointers about to
                  * be modified to the credit or captures them depending
                  * upon the transaction received
                  */
-                __ks_prev_next_add_cred(handle, tx, target, del_tx_state,
-                                        BE_KV_DELETE);
-
-                if (del_tx == NULL) {
-                        m0_be_tx_prep(tx);
-                        m0_be_tx_start(tx);
-                }
+                __ks_prev_next_add_cred(handle, tx, target, BE_KV_DELETE);
 
                 /* Now delete */
                 m0_tlink_del_fini(ks_list_descr, target);
-
-                if (del_tx == NULL) {
-                        m0_be_tx_done(tx);
-                        m0_be_wait(sm_group, &tx->bt_sm,
-                                   M0_BITS(M0_BETX_DONE, M0_BETX_FAILED));
-                        m0_be_tx_fini(tx);
-                        m0_free(tx);
-                        m0_free(t_head_reg);
-                }
-                goto exit_success;
+                M0_LEAVE();
+                return BE_KV_SUCCESS;
+        } else {
+                M0_LEAVE();
+                return BE_KV_FAILURE;
         }
-
-        goto exit_failure;
-
-exit_success:
-        M0_LEAVE();
-        return BE_KV_SUCCESS;
-exit_failure:
-        M0_LEAVE();
-        return BE_KV_FAILURE;
 }
 M0_EXPORTED(m0_be_ks_delete);
 
 M0_INTERNAL int __ks_tlist_add_at_tail(struct m0_be_kv_store     *handle,
                                        void                      *new,
-                                       struct m0_be_tx           *tx,
-                                       int                        in_tx_state)
+                                       struct m0_be_tx           *tx)
 {
         struct m0_be_reg        *tail_obj_reg;
         struct m0_list_link     *tail_obj_link;
@@ -394,14 +357,9 @@ M0_INTERNAL int __ks_tlist_add_at_tail(struct m0_be_kv_store     *handle,
         m0_be_ks_prep_link_reg(ks_dom, tail_obj_link, tx, &tail_obj_reg);
         M0_ASSERT(tail_obj_reg != NULL);
 
-        if (in_tx_state == BE_KV_IN_TX_NULL) {
-                m0_be_tx_add_cred(tx, tail_obj_reg);
-                m0_be_tx_prep(tx);
-                m0_be_tx_start(tx);
-        } else {
-                m0_be_reg_capture(tail_obj_reg);
-                m0_free(tail_obj_reg);
-        }
+        /* Capture this region */
+        m0_be_reg_capture(tail_obj_reg);
+        m0_free(tail_obj_reg);
 
         /* Finally, add at tail in tlist */
         m0_tlist_add_tail(ks_list_descr, ks_tlist, new);
@@ -412,7 +370,7 @@ M0_INTERNAL int __ks_tlist_add_at_tail(struct m0_be_kv_store     *handle,
 
 M0_INTERNAL int m0_be_ks_insert(struct m0_be_kv_store      *handle,
                                 struct m0_be_reference     *obj_ref,
-                                struct m0_be_tx            *ins_tx)
+                                struct m0_be_tx            *tx)
 {
         struct m0_be_reg        *obj_link_reg;
         struct m0_be_domain     *dom;
@@ -421,12 +379,10 @@ M0_INTERNAL int m0_be_ks_insert(struct m0_be_kv_store      *handle,
         struct m0_tl            *ks_tlist;
         struct m0_tl_descr      *ks_list_descr;
         struct m0_list_link     *head;
-        struct m0_be_tx         *tx = ins_tx;
         struct m0_sm_group      *sm_group;
-        void                    *new;
         void                    *scan;
+        void                    *new;
         int                      ret_val       = BE_KV_INVALID_REQ;
-        int                      in_tx_state   = BE_KV_IN_TX_NOT_NULL;
 
         M0_ENTRY("obj_ref: %p", obj_ref);
 
@@ -452,14 +408,6 @@ M0_INTERNAL int m0_be_ks_insert(struct m0_be_kv_store      *handle,
                 }
         } m0_tlist_endfor;
 
-        /* If tx is not provided, create and start a new one */
-        if (ins_tx == NULL) {
-                in_tx_state = BE_KV_IN_TX_NULL;
-                M0_ALLOC_PTR(tx);
-                M0_ASSERT(tx != NULL);
-                m0_be_tx_init(tx, dom, 0);
-        }
-
         /* Tlink init for this object */
         m0_tlink_init(ks_list_descr, new);
 
@@ -471,12 +419,8 @@ M0_INTERNAL int m0_be_ks_insert(struct m0_be_kv_store      *handle,
         M0_ASSERT(obj_link_reg != NULL);
 
         /** Capture this region. */
-        if (ins_tx == NULL)
-                m0_be_tx_add_cred(tx, obj_link_reg);
-        else {
-                m0_be_reg_capture(obj_link_reg);
-                m0_free(obj_link_reg);
-        }
+        m0_be_reg_capture(obj_link_reg);
+        m0_free(obj_link_reg);
 
         head = (void *)&ks_tlist->t_head;
 
@@ -487,20 +431,15 @@ M0_INTERNAL int m0_be_ks_insert(struct m0_be_kv_store      *handle,
         m0_be_ks_prep_link_reg(dom, head, tx, &t_head_reg);
         M0_ASSERT(t_head_reg != NULL);
 
+        /* Capture t_head */
+        m0_be_reg_capture(t_head_reg);
+        m0_free(t_head_reg);
+
         /* Check if tlist is empty */
         if ((head->ll_next == (void *)head) &&
             (head->ll_prev == (void *)head)) {
-                /* Capture t_head region */
-                if (ins_tx == NULL) {
-                        m0_be_tx_add_cred(tx, t_head_reg);
-                        m0_be_tx_prep(tx);
-                        m0_be_tx_start(tx);
-                } else {
-                        m0_be_reg_capture(t_head_reg);
-                        m0_free(t_head_reg);
-                }
 
-                /* Add to tlist now */
+               /* Add to tlist now */
                 m0_tlist_add(ks_list_descr, ks_tlist, new);
                 ret_val = BE_KV_SUCCESS;
         } else {
@@ -515,16 +454,7 @@ M0_INTERNAL int m0_be_ks_insert(struct m0_be_kv_store      *handle,
                                  * about to be modified to the credit
                                  */
                                 __ks_prev_next_add_cred(handle, tx, scan,
-                                                        in_tx_state,
                                                         BE_KV_INSERT);
-                                if (ins_tx == NULL) {
-                                        m0_be_tx_add_cred(tx, t_head_reg);
-                                        m0_be_tx_prep(tx);
-                                        m0_be_tx_start(tx);
-                                } else {
-                                        m0_be_reg_capture(t_head_reg);
-                                        m0_free(t_head_reg);
-                                }
 
                                 /* Now add the object to the tlist */
                                 m0_tlist_add_before(ks_list_descr, scan, new);
@@ -535,29 +465,10 @@ M0_INTERNAL int m0_be_ks_insert(struct m0_be_kv_store      *handle,
 
                 /* If key is largest in the list, add at tail */
                 if (ret_val == BE_KV_INVALID_REQ) {
-
-                        if (ins_tx == NULL) {
-                                m0_be_tx_add_cred(tx, t_head_reg);
-                        } else {
-                                m0_be_reg_capture(t_head_reg);
-                                m0_free(t_head_reg);
-                        }
-
-                        ret_val = __ks_tlist_add_at_tail(handle, new, tx,
-                                                         in_tx_state);
+                        ret_val = __ks_tlist_add_at_tail(handle, new, tx);
                 }
         }
 
-        if (ins_tx == NULL) {
-                m0_be_tx_done(tx);
-                m0_be_wait(sm_group, &tx->bt_sm,
-                           M0_BITS(M0_BETX_DONE, M0_BETX_FAILED));
-                m0_be_tx_fini(tx);
-                m0_free(tx);
-                m0_free(t_head_reg);
-                m0_free(obj_link_reg);
-        }
-
 exit_insert:
         M0_LEAVE("ret_val: %d", ret_val);
         return ret_val;
@@ -643,10 +554,10 @@ static void __ks_get_current(struct m0_tl_descr   *d,
 
         M0_LEAVE();
 }
+
 static void __ks_prev_next_add_cred(struct m0_be_kv_store *handle,
                                     struct m0_be_tx       *tx,
                                     void                  *current,
-                                    int                    in_tx_state,
                                     int                    operation)
 {
         struct m0_be_reg         *prev_reg;
@@ -688,25 +599,18 @@ static void __ks_prev_next_add_cred(struct m0_be_kv_store *handle,
         }
 
         /* Capture the regions */
-        if (in_tx_state == BE_KV_IN_TX_NULL) {
-                m0_be_tx_add_cred(tx, prev_reg);
-                m0_be_tx_add_cred(tx, curr_reg);
-                if (operation == BE_KV_DELETE)
-                        m0_be_tx_add_cred(tx, next_reg);
-        } else {
-                m0_be_reg_capture(prev_reg);
-                m0_free(prev_reg);
+        m0_be_reg_capture(prev_reg);
+        m0_free(prev_reg);
 
-                if (operation == BE_KV_DELETE) {
-                        m0_be_reg_capture(next_reg);
-                        m0_free(next_reg);
-                }
+        if (operation == BE_KV_DELETE) {
+                m0_be_reg_capture(next_reg);
+                m0_free(next_reg);
+        }
 
-                m0_be_reg_capture(curr_reg);
-                m0_free(curr_reg);
-       }
+        m0_be_reg_capture(curr_reg);
+        m0_free(curr_reg);
 
-       M0_LEAVE();
+        M0_LEAVE();
 }
 
 #undef M0_TRACE_SUBSYSTEM
diff --git a/be/kv_store.h b/be/kv_store.h
index 0b9a29f..cfed3ec 100644
--- a/be/kv_store.h
+++ b/be/kv_store.h
@@ -211,7 +211,7 @@ M0_INTERNAL bool m0_be_ks_init(struct m0_be_kv_store **handle,
                                       object will be stored.
   @param obj_ref               :      the reference allocated to the actual
                                       object.
-  @param tx                    :      transaction handle. Can be NULL.
+  @param tx                    :      transaction handle.
   @retval BE_KV_FAILURE        :      upon failure to insert key.
   @retval BE_KV_SUCCESS        :      upon successful insert.
   @retval BE_KV_DUPLICATE      :      upon trying to insert duplicate key.
@@ -239,7 +239,7 @@ M0_INTERNAL void  *m0_be_ks_find(struct m0_be_kv_store *handle,
   @param handle         :       handle containing the tlist in which the @obj is
                                 stored.
   @param obj            :       the object to be deleted.
-  @param tx             :       transaction handle. Can be NULL.
+  @param tx             :       transaction handle.
   @retval BE_KV_FAILURE :       in case of failures.
   @retval BE_KV_SUCCESS :       in case of success.
  */
-- 
1.8.3.2

