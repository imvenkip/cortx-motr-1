From 1e15643935c3a3fa051149811714bc2492c2ff53 Mon Sep 17 00:00:00 2001
From: Zishan Shaikh <zishan_shaikh@xyratex.com>
Date: Thu, 2 May 2013 00:24:45 -0700
Subject: [PATCH 082/121] Changing ks_update to accept tx already in start
 state

---
 be/kv_store.c    | 24 ++++++------------------
 be/kv_store.h    | 12 +++++++++++-
 be/ut/kv_store.c | 16 +++++++++++-----
 cob/cob.c        | 26 +++++++++++++++++++++++---
 4 files changed, 51 insertions(+), 27 deletions(-)

diff --git a/be/kv_store.c b/be/kv_store.c
index 6369d08..caf27b0 100644
--- a/be/kv_store.c
+++ b/be/kv_store.c
@@ -339,6 +339,7 @@ exit_delete:
 M0_EXPORTED(m0_be_ks_delete);
 
 M0_INTERNAL int32_t m0_be_ks_update(struct m0_be_kv_store     *handle,
+                                    struct m0_be_tx           *tx,
                                     struct m0_be_kv_store_cb  *bkc_ks_cbinfo,
                                     void                      *in_obj,
                                     uint64_t                   sizeof_obj,
@@ -351,7 +352,6 @@ M0_INTERNAL int32_t m0_be_ks_update(struct m0_be_kv_store     *handle,
         struct m0_be_buf         buf;
         struct m0_be_reg        *reg;
         struct m0_be_seg        *seg;
-        struct m0_be_tx         *tx;
         void                    *current;
         void                    *scan;
         void                    *ksc_cbdata;
@@ -359,6 +359,7 @@ M0_INTERNAL int32_t m0_be_ks_update(struct m0_be_kv_store     *handle,
         bool                     ret_dom;
         kv_key_cmp_t             cmp_fp;
 
+        M0_PRE(m0_be_tx_state(tx) == M0_BETX_OPEN);
         M0_ASSERT(in_obj != NULL);
         M0_ENTRY("handle: %p obj:%p", handle, in_obj);
 
@@ -381,13 +382,6 @@ M0_INTERNAL int32_t m0_be_ks_update(struct m0_be_kv_store     *handle,
          * capture it and update it with incoming object
          */
         if (scan != NULL) {
-                M0_ALLOC_PTR(tx);
-                M0_ASSERT(tx != NULL);
-
-                M0_ALLOC_PTR(reg);
-                M0_ASSERT(reg != NULL);
-
-                m0_be_tx_init(tx, dom, 0);
 
                 /* Lookup for the kv_store segment. If not found, create one */
                 ret_dom = m0_be_domain_lookup(dom, BE_KV_SEG_NAME, &seg);
@@ -395,14 +389,14 @@ M0_INTERNAL int32_t m0_be_ks_update(struct m0_be_kv_store     *handle,
                 M0_ASSERT(seg != NULL);
 
                 /* Prepare a region to capture the object */
+                M0_ALLOC_PTR(reg);
+                M0_ASSERT(reg != NULL);
                 buf.b_nob  = sizeof_obj;
                 buf.b_addr = current;
                 m0_be_reg_init(reg, tx, seg, &buf);
 
-                /* Add this region to tx credit list and start the tx */
-                m0_be_tx_add_cred(tx, reg);
-                m0_be_tx_prep(tx);
-                m0_be_tx_start(tx);
+                /* Capture this region. */
+                m0_be_reg_capture(reg);
 
                 /* Update the current object */
                 if (obj_update != NULL) {
@@ -414,12 +408,6 @@ M0_INTERNAL int32_t m0_be_ks_update(struct m0_be_kv_store     *handle,
                 /* Just to assure the key was not corrupted */
                 M0_ASSERT(cmp_fp(current, in_obj) == 0);
 
-                m0_be_tx_done(tx, NULL);
-                m0_be_wait(sm_group, &tx->bt_sm,
-                           M0_BITS(M0_BETX_DONE, M0_BETX_FAILED));
-
-                m0_be_tx_fini(tx);
-                m0_free(tx);
                 m0_free(reg);
 
                 ret_val = 0;
diff --git a/be/kv_store.h b/be/kv_store.h
index c1d82a7..90c4942 100644
--- a/be/kv_store.h
+++ b/be/kv_store.h
@@ -184,14 +184,21 @@
 
        @code:
        struct m0_be_kv_store_cb *cb_info;
+       struct m0_be_tx          *tx;
        kv_obj_copy_t             obj_update;
 
        cb_info->ksc_cbdata  = cb_data;
        cb_info->ksc_cb      = update_callback;
        obj_copy             = user_obj_update_routine;
 
-       rc = m0_be_ks_update(handle, cb_info, object_to_update,
+       m0_be_tx_init(tx);
+       m0_be_tx_start(tx);
+
+       rc = m0_be_ks_update(handle, tx, cb_info, object_to_update,
                             sizeof *object_to_update, obj_update);
+       m0_be_tx_done(tx, NULL);
+       m0_be_wait(sm_group, &tx->bt_sm, M0_BITS(M0_BETX_DONE, M0_BETX_FAILED));
+       m0_be_tx_fini(tx);
        @endcode
 
 
@@ -473,6 +480,8 @@ M0_INTERNAL int32_t m0_be_ks_delete(struct m0_be_kv_store     *handle,
 
   @param handle         :       handle containing the tlist in which the @obj is
                                 stored.
+  @param tx             :       be transaction in which the update will
+                                be carried out.
   @param cb_info        :       the callback information that will be used
                                 to call the callback function after  completion
                                 of updation.
@@ -484,6 +493,7 @@ M0_INTERNAL int32_t m0_be_ks_delete(struct m0_be_kv_store     *handle,
   @retval BE_KV_SUCCESS :       in case of success.
  */
 M0_INTERNAL int32_t m0_be_ks_update(struct m0_be_kv_store     *handle,
+                                    struct m0_be_tx           *tx,
                                     struct m0_be_kv_store_cb  *cb_info,
                                     void                      *obj,
                                     uint64_t                   sizeof_obj,
diff --git a/be/ut/kv_store.c b/be/ut/kv_store.c
index 29631bc..30431c3 100644
--- a/be/ut/kv_store.c
+++ b/be/ut/kv_store.c
@@ -607,18 +607,24 @@ void test_recover_and_delete()
 
 void test_kv_store_update()
 {
-        long int    i;
-        int         rc;
+        struct m0_be_tx *tx;
+        long   int       i;
+        int              rc;
 
         for (i = 0; i < UT_UB_ITER; i++) {
+                M0_ALLOC_PTR(tx);
+                m0_be_tx_init(tx, kv_dom, 0);
+                m0_be_tx_start(tx);
                 /* Put some new value in the object and keep key intact. */
                 ret_obj1[i]->obj_val = i + 1000;
                 ret_obj2[i]->obj_val = i + 2000;
-                rc = m0_be_ks_update(handle1, NULL, ret_obj1[i],
+                rc = m0_be_ks_update(handle1, tx, NULL, ret_obj1[i],
                                      sizeof *ret_obj1[i], function_update);
-                rc = m0_be_ks_update(handle2, NULL, ret_obj2[i],
+                rc = m0_be_ks_update(handle2, tx, NULL, ret_obj2[i],
                                      sizeof *ret_obj2[i], function_update);
-
+                m0_be_tx_done(tx, NULL);
+                m0_be_wait(sm_group, &tx->bt_sm, M0_BITS(M0_BETX_DONE,
+                                                         M0_BETX_FAILED));
                 M0_UT_ASSERT(rc == 0);
         }
 
diff --git a/cob/cob.c b/cob/cob.c
index 07ae1f6..f922f79 100644
--- a/cob/cob.c
+++ b/cob/cob.c
@@ -1400,10 +1400,15 @@ M0_INTERNAL int m0_cob_update(struct m0_cob *cob,
 #ifndef __KERNEL__
         struct m0_be_kv_store  *handle;
         struct m0_be_ks_pair   *kv_pair;
+        struct m0_be_tx        *be_tx;
+        struct m0_be_domain    *kv_dom;
+        struct m0_sm_group     *sm_group;
 
         if (nsrec != NULL) {
-                handle = cob->co_dom->cd_kvnamespace;
+                handle   = cob->co_dom->cd_kvnamespace;
                 M0_ASSERT(handle != NULL);
+                kv_dom   = handle->ks_handle_heap.ksh_dom;
+                sm_group = m0_be_domain_sm_group(kv_dom);
 
                 /*
                  * Create a pair, with the new updated input @nsrec,
@@ -1416,8 +1421,23 @@ M0_INTERNAL int m0_cob_update(struct m0_cob *cob,
                 M0_ASSERT(rc == 0);
                 M0_ASSERT(kv_pair  != NULL);
 
-                rc = m0_be_ks_update(handle, NULL, kv_pair, sizeof *kv_pair,
-                                     m0_be_kv_cob_pair_copy);
+                M0_ALLOC_PTR(be_tx);
+                M0_ASSERT(be_tx != NULL);
+                m0_be_tx_init(be_tx, kv_dom, 0);
+                m0_be_tx_start(be_tx);
+
+                rc = m0_be_ks_update(handle, be_tx, NULL, kv_pair,
+                                     sizeof *kv_pair, m0_be_kv_cob_pair_copy);
+
+                /*
+                 * For now, no cob_info has been provided, so sending NULL to
+                 * m0_be_tx_done.
+                 */
+                m0_be_tx_done(be_tx, NULL);
+                m0_be_wait(sm_group, &be_tx->bt_sm, M0_BITS(M0_BETX_DONE,
+                                                            M0_BETX_FAILED));
+                m0_be_tx_fini(be_tx);
+                m0_free(be_tx);
 
                 if (rc != 0)
                         goto out;
-- 
1.8.3.2

