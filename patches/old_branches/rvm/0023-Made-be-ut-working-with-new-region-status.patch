From f281cade0c64e91518d7a2c12f1b7561b2fe52b4 Mon Sep 17 00:00:00 2001
From: Sachin Patil <sachin_patil@xyratex.com>
Date: Mon, 31 Dec 2012 01:26:39 -0800
Subject: [PATCH 023/121] Made be/ut working with new region status

---
 be/be_seg.c |  4 ----
 be/be_tx.c  | 11 ++++++-----
 be/ut/be.c  | 13 ++++++++-----
 3 files changed, 14 insertions(+), 14 deletions(-)

diff --git a/be/be_seg.c b/be/be_seg.c
index 1f277d5..954ca28 100644
--- a/be/be_seg.c
+++ b/be/be_seg.c
@@ -584,8 +584,6 @@ M0_INTERNAL void m0_be_seg_create_cb(struct m0_sm_group *sm_group,
         /* @todo - end transaction */
         /* Assuption : create implicitely opens the segment */
 
-        printf("\ndata_file_path : %s\n", seg->bs_impl.path_name);
-
         result = rds_load_heap(seg->bs_impl.path_name,
                                RVM_LENGTH_TO_OFFSET(dev_length),
                                &static_addr,
@@ -653,8 +651,6 @@ M0_INTERNAL void m0_be_seg_open_cb(struct m0_sm_group *sm_group,
         int  err;
         char *static_addr = NULL;
 
-        printf("\ndata_file_path : %s\n", seg->bs_impl.path_name);
-
         result = rds_load_heap(seg->bs_impl.path_name,
                                RVM_LENGTH_TO_OFFSET(dev_length),
                                &static_addr,
diff --git a/be/be_tx.c b/be/be_tx.c
index 144dfe4..ec132bb 100644
--- a/be/be_tx.c
+++ b/be/be_tx.c
@@ -505,8 +505,6 @@ M0_INTERNAL void m0_be_tx_set_capture_status(void * data)
         bool failed_res = false;
         bool capturing_res = false;
 
-        printf("\nIn Function : %s", __FUNCTION__);
-
         /* Iterate credit list to check the capture status for each region. */
         m0_tlist_for(&m0_be_reg_tl, &(tx->bt_impl.bc_tl), reg_it) {
                 /* check if region capture is in prorgess */
@@ -523,12 +521,15 @@ M0_INTERNAL void m0_be_tx_set_capture_status(void * data)
         } m0_tlist_endfor;
 
         if(!capturing_res) {
+                /**
+                 * This function will be called from callback function, so 
+                 * sm_group lock is not required while setting tx state.
+                 */
                 if(failed_res) {
-                        M0_TX_SM_STATE_SET(tx, M0_BETX_FAILED);
+                        m0_sm_state_set(&(tx->bt_sm), M0_BETX_FAILED);
                 }
                 else {
-                        printf("\nMarking status M0_BETX_PREPARED\n");
-                        M0_TX_SM_STATE_SET(tx, M0_BETX_PREPARED);
+                        m0_sm_state_set(&(tx->bt_sm), M0_BETX_PREPARED);
                 }
         }
 
diff --git a/be/ut/be.c b/be/ut/be.c
index 77097c9..109815e 100644
--- a/be/ut/be.c
+++ b/be/ut/be.c
@@ -71,7 +71,7 @@ int main()
         printf("\nSegment is created\n");
 
         /**
-         * TODO :Implement UT to test segment open 
+         * @todo :Implement UT to test segment open 
          */
 
         printf("\nWaiting for segment to be active\n");
@@ -87,6 +87,7 @@ int main()
 
         printf("\nSegment is opened\n");
 
+        printf("\ndata_file_path : %s\n", seg->bs_impl.path_name);
 
         /* Transaction list initialization */
         m0_be_tx_init(&tx, &dom, 0);
@@ -101,30 +102,32 @@ int main()
 
         m0_be_buf_init(&buf, NULL, 1024, 0, 0, 0);
         m0_be_reg_init(&reg, NULL, seg, &buf);
-        printf("sachin reg : %p reg_state[%d]\n", reg, reg->br_sm.sm_state);
+        printf("reg : %p reg_state[%d]\n", reg, reg->br_sm.sm_state);
         m0_be_alloc(reg);
 
-        printf("\nWaiting for M0_BEREG_ALLOCATED\n");
+        printf("\nReg is allocating\n");
         m0_sm_group_lock(reg->br_impl.sm_group);
         m0_sm_timedwait(&(reg->br_sm),
                         (1 << M0_BEREG_ALLOCATED) | (1 << M0_BEREG_FAILED),
                          M0_TIME_NEVER);
 
         m0_sm_group_unlock(reg->br_impl.sm_group);
+        printf("\nReg is allocated\n");
 
         m0_be_tx_add_cred(&tx, reg);
 
         printf("reg : %p reg_state[%d]\n", reg, reg->br_sm.sm_state);
         m0_be_tx_prep(&tx);
 
+        printf("\nTx is Preparing\n");
         m0_sm_group_lock(tx.bt_impl.sm_group);
-        printf("\nWaiting for transaction to be in prepared state \n");
         m0_sm_timedwait(&tx.bt_sm,
                         (1 << M0_BETX_PREPARED) | (1 << M0_BETX_FAILED),
                         M0_TIME_NEVER);
         m0_sm_group_unlock(tx.bt_impl.sm_group);
-        printf("\nTx is Opening\n");
+        printf("\nTx is Prepared\n");
 
+        printf("\nTx is Opening\n");
         m0_be_tx_start(&tx);
         m0_sm_group_lock(tx.bt_impl.sm_group);
         m0_sm_timedwait(&tx.bt_sm,
-- 
1.8.3.2

