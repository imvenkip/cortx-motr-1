From c9979ae53c768b7512b8656c9244c7bf9100f3c3 Mon Sep 17 00:00:00 2001
From: Zishan Shaikh <zishan_shaikh@xyratex.com>
Date: Fri, 15 Mar 2013 06:34:46 -0700
Subject: [PATCH 065/121] Fixed a few typos and style defects in KV-store

---
 be/helper.h         | 10 ++++-----
 be/kv_store.c       | 43 ++++++++++++++++++---------------------
 be/kv_store.h       |  2 +-
 be/ut/kv_store.c    | 13 +++++++-----
 be/ut/kv_store_ub.c | 58 ++++++++++++++++++++++++++++++++++++++++++++---------
 5 files changed, 82 insertions(+), 44 deletions(-)

diff --git a/be/helper.h b/be/helper.h
index 4b33e4f..78c3b1c 100644
--- a/be/helper.h
+++ b/be/helper.h
@@ -39,13 +39,13 @@
 /**
   Return values and control operations used by kv_store.
  */
-enum {
+enum m0_be_kv_status {
         /** Return Values. */
         BE_KV_SUCCESS        = 0,
-        BE_KV_FAILURE        = 111,
-        BE_KV_DUPLICATE      = 222,
-        BE_KV_OUT_OF_DOMAIN  = 333,
-        BE_KV_INVALID_REQ    = 444,
+        BE_KV_FAILURE        = -111,
+        BE_KV_DUPLICATE      = -222,
+        BE_KV_OUT_OF_DOMAIN  = -333,
+        BE_KV_INVALID_REQ    = -444,
 
         /** Control operations in specific functions. */
         BE_KV_INSERT         = 555,
diff --git a/be/kv_store.c b/be/kv_store.c
index e377cdd..79042c4 100644
--- a/be/kv_store.c
+++ b/be/kv_store.c
@@ -139,16 +139,12 @@ M0_INTERNAL void m0_be_ks_init(struct m0_be_kv_store     *handle,
         struct m0_tl_descr         *descr;
         struct m0_be_domain        *dom;
         struct m0_be_kv_store_cb   *bko_cbinfo;
-        kv_key_cmp_t                cmp_fp;
-        kv_key_match_t              match_fp;
 
         M0_ENTRY("handle: %p mode: %s", handle, mode);
         M0_PRE(m0_be_ks_get_handle_state(handle) == M0_BEKS_CREATED);
 
         descr    = handle->ks_handle_heap.ksh_list_descr;
         dom      = handle->ks_handle_heap.ksh_dom;
-        cmp_fp   = handle->ks_handle_heap.ksh_key_cmp;
-        match_fp = handle->ks_handle_heap.ksh_key_match;
         sm_group = m0_be_domain_sm_group(dom);
 
         M0_ALLOC_PTR(bk_opdata);
@@ -225,7 +221,7 @@ M0_INTERNAL void m0_be_ks_fini(struct m0_be_kv_store     *handle,
         if (cb_info != NULL) {
                 ksc_cbdata = cb_info->ksc_cbdata;
                 M0_ASSERT(ksc_cbdata != NULL);
-                cb_info->ksc_cb(ksc_cbdata);
+                cb_info->ksc_cb(ksc_cbdata, NULL, BE_KV_SUCCESS);
         }
 
         m0_free(handle);
@@ -260,10 +256,10 @@ M0_INTERNAL void *m0_be_ks_find(struct m0_be_kv_store     *handle,
 
 exit_find:
         /* Call the callback function provided by the user. */
-        if (cb_info != NULL) {
+        if (cb_info != NULL && target != NULL) {
                 ksc_cbdata = cb_info->ksc_cbdata;
                 M0_ASSERT(ksc_cbdata != NULL);
-                cb_info->ksc_cb(ksc_cbdata);
+                cb_info->ksc_cb(ksc_cbdata, target, BE_KV_SUCCESS);
         }
 
         M0_LEAVE("target: %p", target);
@@ -287,7 +283,7 @@ M0_INTERNAL int32_t m0_be_ks_delete(struct m0_be_kv_store     *handle,
         struct m0_tl_descr      *ks_list_descr;
         struct m0_be_domain     *ks_dom;
         struct m0_sm_group      *sm_group;
-        int32_t                  ret_val;
+        enum m0_be_kv_status     ret_val;
         bool                     target_found;
 
         M0_ENTRY();
@@ -335,10 +331,10 @@ M0_INTERNAL int32_t m0_be_ks_delete(struct m0_be_kv_store     *handle,
         }
 
         /* Call the callback function provided by the user. */
-        if (cb_info != NULL) {
+        if (cb_info != NULL && ret_val == BE_KV_SUCCESS) {
                 ksc_cbdata = cb_info->ksc_cbdata;
                 M0_ASSERT(ksc_cbdata != NULL);
-                cb_info->ksc_cb(ksc_cbdata);
+                cb_info->ksc_cb(ksc_cbdata, NULL, ret_val);
         }
 
         M0_LEAVE();
@@ -397,7 +393,8 @@ M0_INTERNAL int32_t m0_be_ks_insert(struct m0_be_kv_store     *handle,
         void                    *scan;
         void                    *new;
         void                    *ksc_cbdata;
-        int32_t                  ret_val       = BE_KV_INVALID_REQ;
+        enum m0_be_kv_status     ret_val       = BE_KV_INVALID_REQ;
+        kv_key_cmp_t             cmp_fp;
 
         M0_ENTRY("handle: %p obj:%p", handle, obj_ref->be_virtual_address);
         M0_ASSERT(tx != NULL);
@@ -415,19 +412,11 @@ M0_INTERNAL int32_t m0_be_ks_insert(struct m0_be_kv_store     *handle,
         ks_tlist      = &handle->ks_handle_rvm->ksr_tlist;
         sm_group      = m0_be_domain_sm_group(dom);
         head          = (void *)&ks_tlist->t_head;
+        cmp_fp        = handle->ks_handle_heap.ksh_key_cmp;
 
         /* Collect the object to be inserted. */
         new           = obj_ref->be_virtual_address;
 
-        /* Check for duplicate insertion */
-        m0_tlist_for(ks_list_descr, ks_tlist, scan) {
-                if (handle->ks_handle_heap.ksh_key_cmp(new, scan) == 0) {
-                        ret_val = BE_KV_DUPLICATE;
-                        M0_LOG(M0_ERROR, "kv_insert: duplicate insertion!");
-                        goto exit_insert;
-                }
-        } m0_tlist_endfor;
-
         /* Capture the linkages of head and @new object */
         __ks_insert_capture_head_new(handle, new, tx);
 
@@ -444,7 +433,7 @@ M0_INTERNAL int32_t m0_be_ks_insert(struct m0_be_kv_store     *handle,
                  */
                 m0_tlist_for(ks_list_descr, ks_tlist, scan)
                 {
-                        if (handle->ks_handle_heap.ksh_key_cmp(new, scan) < 0) {
+                        if (cmp_fp(new, scan) < 0) {
                                 /*
                                  * Add the current, previous and next pointers
                                  * about to be modified to the credit
@@ -456,6 +445,12 @@ M0_INTERNAL int32_t m0_be_ks_insert(struct m0_be_kv_store     *handle,
                                 m0_tlist_add_before(ks_list_descr, scan, new);
                                 ret_val = BE_KV_SUCCESS;
                                 break;
+                        } else if (cmp_fp(new, scan) == 0) {
+                                /* Check for duplicate insertion */
+                                ret_val = BE_KV_DUPLICATE;
+                                M0_LOG(M0_ERROR,
+                                       "kv_insert: duplicate insertion!");
+                                goto exit_insert;
                         }
                 } m0_tlist_endfor;
 
@@ -467,10 +462,10 @@ M0_INTERNAL int32_t m0_be_ks_insert(struct m0_be_kv_store     *handle,
 
 exit_insert:
         /* Call the callback function provided by the user. */
-        if (cb_info != NULL) {
+        if (cb_info != NULL && ret_val  == BE_KV_SUCCESS) {
                 ksc_cbdata = cb_info->ksc_cbdata;
                 M0_ASSERT(ksc_cbdata != NULL);
-                cb_info->ksc_cb(ksc_cbdata);
+                cb_info->ksc_cb(ksc_cbdata, NULL, ret_val);
         }
 
         M0_LEAVE("ret_val: %d", ret_val);
@@ -801,7 +796,7 @@ M0_INTERNAL void m0_be_ksi_init_done(void *cb_data)
         if (cb_info != NULL) {
                 ksc_cbdata = cb_info->ksc_cbdata;
                 M0_ASSERT(ksc_cbdata != NULL);
-                cb_info->ksc_cb(ksc_cbdata);
+                cb_info->ksc_cb(ksc_cbdata, NULL, BE_KV_SUCCESS);
                 /* Was allocated in m0_be_ks_init */
                 m0_free(cb_info);
         }
diff --git a/be/kv_store.h b/be/kv_store.h
index 4730a31..c58816f 100644
--- a/be/kv_store.h
+++ b/be/kv_store.h
@@ -229,7 +229,7 @@ struct m0_be_kv_store_cb {
         /** Call back data to be used. */
         void            *ksc_cbdata;
         /** The call back function. */
-        void           (*ksc_cb)(void *cb_data);
+        void           (*ksc_cb)(void *cb_data, void *result, int rc);
 };
 
 
diff --git a/be/ut/kv_store.c b/be/ut/kv_store.c
index aed89f5..4300486 100644
--- a/be/ut/kv_store.c
+++ b/be/ut/kv_store.c
@@ -69,32 +69,35 @@ char                        kv_cmd[1024];
 int                         kv_val;
 
 /** Callback function to be called after operation completion. */
-void init_operation_callback(void *operation_name)
+void init_operation_callback(void *operation_name, void *result, int rc)
 {
         m0_free(operation_name);
 }
 
 /** Callback function to be called after operation completion. */
-void fini_operation_callback(void *operation_name)
+void fini_operation_callback(void *operation_name, void *result, int rc)
 {
         m0_free(operation_name);
 }
 
 /** Callback function to be called after operation completion. */
-void insert_operation_callback(void *operation_name)
+void insert_operation_callback(void *operation_name, void *result, int rc)
 {
+        M0_ASSERT(rc == BE_KV_SUCCESS);
         m0_free(operation_name);
 }
 
 /** Callback function to be called after operation completion. */
-void find_operation_callback(void *operation_name)
+void find_operation_callback(void *operation_name, void *result, int rc)
 {
+        M0_ASSERT(rc == BE_KV_SUCCESS);
         m0_free(operation_name);
 }
 
 /** Callback function to be called after operation completion. */
-void delete_operation_callback(void *operation_name)
+void delete_operation_callback(void *operation_name, void *result, int rc)
 {
+        M0_ASSERT(rc == BE_KV_SUCCESS);
         m0_free(operation_name);
 }
 
diff --git a/be/ut/kv_store_ub.c b/be/ut/kv_store_ub.c
index 8e5cc8d..5d26a18 100644
--- a/be/ut/kv_store_ub.c
+++ b/be/ut/kv_store_ub.c
@@ -69,6 +69,42 @@ long int                    find_index = 0;
 long int                    del_index = 0;
 long int                    val;
 
+/** Callback function to be called after operation completion. */
+void init_operation_callback(void *operation_name, void *result, int rc)
+{
+        m0_free(operation_name);
+}
+
+/** Callback function to be called after operation completion. */
+void fini_operation_callback(void *operation_name, void *result, int rc)
+{
+        m0_free(operation_name);
+}
+
+/** Callback function to be called after operation completion. */
+void insert_operation_callback(void *operation_name, void *result, int rc)
+{
+        M0_ASSERT(rc == BE_KV_SUCCESS);
+        m0_free(operation_name);
+}
+
+/** Callback function to be called after operation completion. */
+void find_operation_callback(void *operation_name, void *result, int rc)
+{
+        M0_ASSERT(rc == BE_KV_SUCCESS);
+        ret_obj[find_index]  = (struct m0_kv_store_obj *)result;
+        M0_ASSERT(ret_obj[find_index] != NULL);
+        find_index++;
+        m0_free(operation_name);
+}
+
+/** Callback function to be called after operation completion. */
+void delete_operation_callback(void *operation_name, void *result, int rc)
+{
+        M0_ASSERT(rc == BE_KV_SUCCESS);
+        m0_free(operation_name);
+}
+
 /** Key compare routine. */
 int function_comp(void *key1, void *key2)
 {
@@ -132,9 +168,20 @@ exit:
         m0_free(tx);
 }
 
-static void *__find(long int *key)
+static void ub_kv_find()
 {
-        return m0_be_ks_find(handle, NULL, key);
+        struct m0_be_kv_store_cb        *cb_info;
+        char                            *operation_name;
+        M0_ALLOC_PTR(cb_info);
+
+        operation_name = (char *)malloc(10);
+        strcpy(operation_name, "KS_FIND");
+
+        cb_info->ksc_cbdata     = (void *)operation_name;
+        cb_info->ksc_cb         = find_operation_callback;
+
+        m0_be_ks_find(handle, cb_info, &find_index);
+        m0_free(cb_info);
 }
 
 static int __delete(struct m0_kv_store_obj *target)
@@ -188,13 +235,6 @@ static int __delete(struct m0_kv_store_obj *target)
         return ret_val;
 }
 
-static void ub_kv_find()
-{
-        ret_obj[find_index]  = (struct m0_kv_store_obj *)__find(&find_index);
-        M0_ASSERT(ret_obj[find_index] != NULL);
-        find_index++;
-}
-
 void ub_kv_delete()
 {
         int32_t status;
-- 
1.8.3.2

