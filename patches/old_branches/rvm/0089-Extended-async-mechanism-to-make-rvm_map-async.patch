From 7bd69f1e9340f66673c522c9462fd68f6f68f373 Mon Sep 17 00:00:00 2001
From: Sachin Patil <sachin_patil@xyratex.com>
Date: Tue, 14 May 2013 00:10:48 -0700
Subject: [PATCH 089/121] Extended async mechanism to make rvm_map async. This
 Removes m0_chan_wait() from the launch_stob_io().

---
 be/seg.c            |  36 +-----
 be/ut/be.c          |   2 +-
 rvm/rvm.h           |  11 +-
 rvm/rvm_createseg.c |   3 +-
 rvm/rvm_io.c        | 240 +++++++++++++++++++++++++++++++++++-
 rvm/rvm_loadseg.c   |  47 +++----
 rvm/rvm_map.c       | 349 ++++++++++++++++++++++++++++++++++------------------
 rvm/rvm_private.h   |  33 ++++-
 8 files changed, 535 insertions(+), 186 deletions(-)

diff --git a/be/seg.c b/be/seg.c
index 63e93e9..0281689 100644
--- a/be/seg.c
+++ b/be/seg.c
@@ -309,38 +309,6 @@ M0_INTERNAL void m0_be_seg_fail(struct m0_be_seg *seg)
         M0_LEAVE();
 }
 
-
-
-#if 0
-static int be_rvm_rds_zap_heap(struct m0_be_seg *seg)
-{
-        char                     *start_addr        = (char *)0xbebd000;
-        long                      rds_static_len    = 0;
-        long                      nlist             = RVM_NLIST;
-        long                      chunk_size        = RVM_CHUNK_SIZE;
-        unsigned long             dev_length        = RVM_SEGMENT_SIZE;
-        unsigned long             heap_length       = RVM_HEAP_SIZE;
-        int                       result;
-        int                       err;
-
-        /* @todo - need to handle rvm errors in callback. */
-        /* Create heap structure. */
-        rds_static_len    = RVM_ROUND_LENGTH_DOWN_TO_PAGE_SIZE(4096);
-
-        result = rds_zap_heap(seg->bs_impl.path_name,
-                              RVM_LENGTH_TO_OFFSET(dev_length),
-                              start_addr,
-                              rds_static_len,
-                              heap_length,
-                              nlist,
-                              chunk_size,
-                              &err,
-                              &seg->bs_rvm);
-
-        return result;
-}
-#endif
-
 /**
  * The function calls rvm api's to create and open segment.
  *
@@ -498,7 +466,7 @@ exit:
 
 M0_INTERNAL void m0_be_seg_open_rds_load_heap_cb(struct m0_be_cbinfo *cbinfo,
                                                  int                  status,
-                                                 m0_be_msg_type_t     msg)
+                                                 m0_be_msg_type_t     msg_type)
 {
         struct m0_be_seg_cbdata  *bs_cbdata;
         struct m0_be_seg         *seg;
@@ -522,7 +490,7 @@ exit:
                                           seg_state);
 
         if(cbinfo->bc_pcbinfo != NULL && cbinfo->bc_pcbinfo->bc_cb != NULL)
-                m0_be_handler_post(cbinfo->bc_pcbinfo, status, msg);
+                m0_be_handler_post(cbinfo->bc_pcbinfo, status, msg_type);
 
         m0_free(bs_cbdata);
         M0_LEAVE("Segment = %p  Opened state = %d", seg, seg_state);
diff --git a/be/ut/be.c b/be/ut/be.c
index 5fc7098..80e49de 100644
--- a/be/ut/be.c
+++ b/be/ut/be.c
@@ -266,7 +266,7 @@ static int ts_be_init(void)   /* ts_ for "test suite" */
         bt_cbdata->counter                         =  10;
         bt_cbdata->completed                       =  false;
         M0_ALLOC_PTR(bt_cbdata->be_usr_ast);
-        bt_cbdata->be_usr_ast->bua_sm_group         = &usr_sm_group;
+        bt_cbdata->be_usr_ast->bua_sm_group        = &usr_sm_group;
 
         M0_ALLOC_PTR(seg);
         M0_ASSERT(seg != NULL);
diff --git a/rvm/rvm.h b/rvm/rvm.h
index 2cc21d7..20d2bd8 100644
--- a/rvm/rvm.h
+++ b/rvm/rvm.h
@@ -40,6 +40,7 @@ Coda are listed in the file CREDITS.
 /* get timestamp structures and system constants */
 #include <sys/time.h>
 #include <sys/param.h>
+//#include "be/be.h"
 
 /* define bool, TRUE, and FALSE */
 
@@ -51,6 +52,9 @@ Coda are listed in the file CREDITS.
 #define FALSE 0
 #endif
 
+/* forward declaration */
+struct m0_be_cbinfo;
+
 /* RVM's use of false, true and bool causes trouble with versions of gcc
    above 2.6 or so; because of this, the names of RVM's definitions
    have been changed to rvm_{false,true,bool_t}. (Originally changed
@@ -428,9 +432,10 @@ extern void *rds_heap_addr(rvm_seg_hdr_t *seg_hdr);
 
 /* map recoverable storage */
 extern rvm_return_t rvm_map(
-    rvm_seg_hdr_t           *seg_hdr,
-    rvm_region_t         *region,       /* pointer to region descriptor */
-    rvm_options_t        *options       /* optional ptr to option descriptor */
+    rvm_seg_hdr_t           	*seg_hdr,
+    rvm_region_t         	*region,       /* pointer to region descriptor */
+    rvm_options_t        	*options,      /* optional ptr to option descriptor */
+    struct m0_be_cbinfo	 	*cbinfo 	/* cbinfo from upper layer. */
     );
 
 /* unmap recoverable storage */
diff --git a/rvm/rvm_createseg.c b/rvm/rvm_createseg.c
index 7d00fe9..7c2ec8f 100644
--- a/rvm/rvm_createseg.c
+++ b/rvm/rvm_createseg.c
@@ -212,7 +212,7 @@ rvm_return_t rvm_create_segment(char *dev_name,
 	rcsc_cbinfo->bc_cb 	 = rcs_rvm_map_cb;
 	rcsc_cbinfo->bc_pcbinfo  = cbinfo;
 
-	status = rvm_map(seg_hdr, region, options);
+	status = rvm_map(seg_hdr, region, options, rcsc_cbinfo);
 	if (status != RVM_SUCCESS) {
 		rvm_free_region(region);
 	}
@@ -222,7 +222,6 @@ exit:
 		m0_be_handler_post(cbinfo->bc_pcbinfo, status, msg_type);
 		m0_free(rcs_cbdata);
 	}
-	rcs_rvm_map_cb(rcsc_cbinfo, status, msg_type);
 
 	return status;
 }
diff --git a/rvm/rvm_io.c b/rvm/rvm_io.c
index d39149a..633108d 100644
--- a/rvm/rvm_io.c
+++ b/rvm/rvm_io.c
@@ -35,6 +35,7 @@ Coda are listed in the file CREDITS.
 #include "rvm/rvm_private.h"
 #include "stob/stob.h"
 #include "lib/memory.h"
+#include "be/handler.h"
 
 #ifndef UIO_MAXIOV
 #define UIO_MAXIOV 16
@@ -259,6 +260,108 @@ long close_dev(dev)
     return retval;
     }
 
+static bool stob_io_complete_cb(struct m0_clink *clink)
+{
+	lsi_cbdata_t		*lsi_cbdata;
+	struct m0_be_cbinfo	*cbinfo;
+	int 			 status   = 0;
+	m0_be_msg_type_t 	 msg_type = M0_BE_SUCCESS;
+
+	lsi_cbdata = container_of(clink, lsi_cbdata_t, lsic_clink);
+	cbinfo 	   = &lsi_cbdata->lsic_cbinfo;
+
+	if (cbinfo != NULL && cbinfo->bc_cb != NULL) {
+		m0_be_handler_post(cbinfo, status, msg_type);
+	}
+
+	return true;
+}
+
+
+void launch_stob_io_cb(struct m0_be_cbinfo *cbinfo, int status,
+		       m0_be_msg_type_t msg_type)
+{
+	lsi_cbdata_t		*lsi_cbdata;
+	struct m0_stob_io	*io;
+	struct m0_clink		*clink;
+
+	lsi_cbdata = container_of(cbinfo, lsi_cbdata_t, lsic_cbinfo);
+
+	io 	= &lsi_cbdata->lsic_io;
+	clink 	= &lsi_cbdata->lsic_clink;
+
+	m0_clink_del(clink);
+	m0_clink_fini(clink);
+	m0_stob_io_fini(io);
+
+	if (cbinfo->bc_pcbinfo != NULL && cbinfo->bc_pcbinfo->bc_cb != NULL) {
+		m0_be_handler_post(cbinfo->bc_pcbinfo, status, msg_type);
+	}
+
+	m0_free(lsi_cbdata);
+}
+
+uint32_t launch_stob_io_new(enum m0_stob_io_opcode opcode,
+			uint32_t 	  	  io_nr,
+			m0_bcount_t 	 	 *io_count,
+			m0_bindex_t 	 	 *io_offset,
+			void 			**io_addr,
+			struct m0_stob 	 	 *stob,
+			struct m0_be_cbinfo 	 *cbinfo)
+{
+	struct m0_stob_io       *io;
+	struct m0_clink         *clink;
+	uint32_t                 rc;
+	int 			 status   = 0;
+	m0_be_msg_type_t 	 msg_type = M0_BE_SUCCESS;
+	struct m0_be_cbinfo 	*lsic_cbinfo;
+
+	lsi_cbdata_t		*lsi_cbdata;
+
+	M0_ALLOC_PTR(lsi_cbdata);
+	M0_ASSERT(lsi_cbdata != NULL);
+
+	lsic_cbinfo = &lsi_cbdata->lsic_cbinfo;
+	lsic_cbinfo->bc_cb 	 = launch_stob_io_cb;
+	lsic_cbinfo->bc_pcbinfo  = cbinfo;
+	lsic_cbinfo->bc_hq 	 = cbinfo->bc_hq;
+	lsic_cbinfo->bc_sm_group = cbinfo->bc_sm_group;
+
+	io 	= &lsi_cbdata->lsic_io;
+	clink 	= &lsi_cbdata->lsic_clink;
+
+	m0_stob_io_init(io);
+
+	io->si_opcode              = opcode;
+	io->si_user.ov_vec.v_nr    = io_nr;
+	io->si_user.ov_vec.v_count = io_count;
+	io->si_user.ov_buf         = io_addr;
+
+	io->si_stob.iv_vec.v_nr    = io_nr;
+	io->si_stob.iv_vec.v_count = io_count;
+	io->si_stob.iv_index       = io_offset;
+
+	io->si_flags               = 0;
+
+
+	m0_clink_init(clink, &stob_io_complete_cb);
+	m0_clink_add(&io->si_wait, clink);
+	rc = m0_stob_io_launch(io, stob, NULL, NULL);
+
+	if (rc != 0) {
+		status 	 = -1;
+		msg_type = M0_BE_INTERNAL;
+
+		if (cbinfo->bc_pcbinfo != NULL &&
+		    cbinfo->bc_pcbinfo->bc_cb != NULL) {
+			m0_be_handler_post(cbinfo->bc_pcbinfo, status, msg_type);
+		}
+		m0_free(lsi_cbdata);
+	}
+
+	return 0;
+}
+
 uint32_t launch_stob_io(opcode, io_nr, io_count, io_offset, io_addr, stob)
     enum m0_stob_io_opcode  opcode;
     uint32_t                io_nr;
@@ -355,6 +458,138 @@ uint64_t launch_read_io(stob, offset, dest, length)
     return retval;
 }
 
+void read_stob_cb(struct m0_be_cbinfo *cbinfo, int status,
+		  m0_be_msg_type_t msg_type)
+{
+	device_t 		*dev;
+	read_stob_cbdata_t 	*rs_cbdata;
+
+	rs_cbdata = container_of(cbinfo, read_stob_cbdata_t, rsc_cbinfo);
+        M0_ASSERT(rs_cbdata != NULL);
+
+	if (status != 0)
+		goto exit;
+
+	dev = rs_cbdata->rsc_dev;
+	dev->last_position = RVM_ADD_LENGTH_TO_OFFSET(dev->last_position,
+						      rs_cbdata->rsc_nbytes);
+exit:
+	if (cbinfo->bc_pcbinfo != NULL && cbinfo->bc_pcbinfo->bc_cb != NULL) {
+		m0_be_handler_post(cbinfo->bc_pcbinfo, status, msg_type);
+	}
+
+	m0_free(rs_cbdata->rsc_io_offset);
+	m0_free(rs_cbdata->rsc_io_count);
+	m0_free(rs_cbdata->rsc_io_addr);
+
+	m0_free(rs_cbdata);
+}
+
+/* read bytes from device or file */
+long read_stob_new(device_t *dev, rvm_offset_t *rvm_offset, char *dest,
+	       rvm_length_t length, struct m0_be_cbinfo *cbinfo)
+{
+	read_stob_cbdata_t     *rs_cbdata;
+	struct m0_be_cbinfo    *rsc_cbinfo;
+	void                  **io_addr;
+	m0_bindex_t            *io_offset;
+	m0_bcount_t            *io_count;
+	uint32_t                io_bshift;
+	uint32_t                io_nr;
+	uint64_t                io_read_len;
+	int                     i = 0;
+
+	rvm_length_t    	offset 	  = 0;
+	rvm_offset_t    	last_position;
+	rvm_length_t    	retval;
+	int 			status;
+	m0_be_msg_type_t	msg_type = M0_BE_SUCCESS;
+
+	assert(dev->stob != NULL);
+	assert(length != 0);
+	assert((dev->raw_io) ? (SECTOR_INDEX(length) == 0) : 1);
+	assert((dev == &default_log->dev) ?
+	       (!LOCK_FREE(default_log->dev_lock)) : 1);
+
+	if ((retval = chk_seek(dev, rvm_offset)) < 0) {
+		status 	 = -1;
+		msg_type = retval;
+		goto exit;
+	}
+
+	last_position = RVM_ADD_LENGTH_TO_OFFSET(dev->last_position, length);
+
+	assert(RVM_OFFSET_EQL_ZERO(*rvm_offset) ? 1 :
+	       RVM_OFFSET_LEQ(last_position,dev->num_bytes));
+
+	/* do read in larg-ish blocks to avoid kernel buffer availability
+ 	 * problems also zero region if /dev/null being read */
+
+	io_bshift = dev->stob->so_op->sop_block_shift(dev->stob);
+	io_nr 	  = (length + rvm_max_read_len - 1) / rvm_max_read_len;
+
+	M0_ALLOC_PTR(rs_cbdata);
+	M0_ASSERT(rs_cbdata != NULL);
+
+	M0_ALLOC_ARR(io_addr, io_nr);
+	M0_ASSERT(io_addr != NULL);
+
+	M0_ALLOC_ARR(io_count, io_nr);
+	M0_ASSERT(io_count != NULL);
+
+	M0_ALLOC_ARR(io_offset, io_nr);
+	M0_ASSERT(io_offset != NULL);
+
+	offset = rvm_offset->low;
+	rs_cbdata->rsc_nbytes = length;
+
+	while (length > 0) {
+		if (length <= rvm_max_read_len)
+			io_read_len = length;
+		else
+			io_read_len = rvm_max_read_len;
+
+		io_addr[i]      = m0_stob_addr_pack(dest, io_bshift);
+		io_count[i]     = io_read_len >> io_bshift;
+		io_offset[i]    = offset >> io_bshift;
+
+		length      	-= io_read_len;
+		offset      	+= io_read_len;
+		dest        	+= io_read_len;
+		i           	+= 1;
+	}
+
+	rs_cbdata->rsc_io_addr 	 = io_addr;
+	rs_cbdata->rsc_io_count  = io_count;
+	rs_cbdata->rsc_io_offset = io_offset;
+	rs_cbdata->rsc_dev 	 = dev;
+	rsc_cbinfo = &rs_cbdata->rsc_cbinfo;
+
+	rsc_cbinfo->bc_hq 	= cbinfo->bc_hq;
+	rsc_cbinfo->bc_sm_group = cbinfo->bc_sm_group;
+	rsc_cbinfo->bc_cb 	= read_stob_cb;
+	rsc_cbinfo->bc_pcbinfo 	= cbinfo;
+
+	status = launch_stob_io_new(SIO_READ, io_nr, io_count, io_offset,
+				    io_addr, dev->stob, rsc_cbinfo);
+
+	if (status < 0) {
+		msg_type = M0_BE_INTERNAL;
+		m0_free(io_addr);
+		m0_free(io_count);
+		m0_free(io_offset);
+
+		m0_free(rs_cbdata);
+	}
+exit:
+	if (status != 0 && cbinfo->bc_pcbinfo != NULL &&
+	    cbinfo->bc_pcbinfo->bc_cb != NULL) {
+		m0_be_handler_post(cbinfo->bc_pcbinfo, status, msg_type);
+	}
+
+	return 0;
+}
+
 /* read bytes from device or file */
 long read_stob(dev,offset,dest,length)
     device_t        *dev;               /* device descriptor */
@@ -381,7 +616,7 @@ long read_stob(dev,offset,dest,length)
            : RVM_OFFSET_LEQ(last_position,dev->num_bytes));
 
     /* do read in larg-ish blocks to avoid kernel buffer availability problems
- *      * also zero region if /dev/null being read */
+ *  *      * also zero region if /dev/null being read */
 
     nbytes = launch_read_io(dev->stob, offset->low, dest, length);
 
@@ -417,8 +652,7 @@ long read_dev(dev,offset,dest,length)
             /* seek if necessary */
             errno = 0;
             if ((retval = chk_seek(dev,offset)) < 0)
-                return retval;
-            last_position = RVM_ADD_LENGTH_TO_OFFSET(dev->last_position,
+                return retval; last_position = RVM_ADD_LENGTH_TO_OFFSET(dev->last_position,
                                                      length);
             assert(RVM_OFFSET_EQL_ZERO(*offset) ? 1
                    : RVM_OFFSET_LEQ(last_position,dev->num_bytes));
diff --git a/rvm/rvm_loadseg.c b/rvm/rvm_loadseg.c
index 56d6a68..40b9d99 100644
--- a/rvm/rvm_loadseg.c
+++ b/rvm/rvm_loadseg.c
@@ -46,7 +46,7 @@ void rls_loop_rvm_map_cb(cbinfo, status, msg)
         rls_cbdata_t            *rls_cbdata;
         rvm_seg_hdr_t           *seg_hdr;
         rvm_region_t            *hdr_region;
-        int                      err;
+        int                      err = 0;
 
         if (status != 0)
                 goto exit;
@@ -113,18 +113,6 @@ void rls_rvm_map_cb(cbinfo, status, msg)
         options    = rls_cbdata->rlsc_options;
         regions    = rls_cbdata->rlsc_regions_defs;
 
-        M0_ALLOC_PTR(rvm_map_cbinfo);
-        if (rvm_map_cbinfo == NULL) {
-                status = -1;
-                msg    = -ENOMEM;
-                goto exit;
-        }
-
-        rvm_map_cbinfo->bc_sm_group = cbinfo->bc_sm_group;
-        rvm_map_cbinfo->bc_hq       = cbinfo->bc_hq;
-        rvm_map_cbinfo->bc_cb       = NULL;
-        rvm_map_cbinfo->bc_pcbinfo  = NULL;
-
         hdrp = (rvm_segment_hdr_t *)(hdr_region->vmaddr);
 
         /* Make sure struct_id is correct */
@@ -157,6 +145,24 @@ void rls_rvm_map_cb(cbinfo, status, msg)
 
         for (i = 0; i < hdrp->nregions; i++)
                 if ((unsigned long)(hdrp->regions[i].vmaddr) >= 0) {
+		if (i != hdrp->nregions-1) {
+			M0_ALLOC_PTR(rvm_map_cbinfo);
+			if (rvm_map_cbinfo == NULL) {
+				status = -1;
+				msg    = -ENOMEM;
+				goto exit;
+			}
+			rvm_map_cbinfo->bc_sm_group = cbinfo->bc_sm_group;
+			rvm_map_cbinfo->bc_hq       = cbinfo->bc_hq;
+			rvm_map_cbinfo->bc_cb       = NULL;
+			rvm_map_cbinfo->bc_pcbinfo  = NULL;
+
+		}
+		else {
+			rvm_map_cbinfo = cbinfo;
+			rvm_map_cbinfo->bc_cb = rls_loop_rvm_map_cb;
+		}
+
                         (*regions)[i].offset = hdrp->regions[i].offset;
                         (*regions)[i].length = hdrp->regions[i].length;
                         (*regions)[i].vmaddr = hdrp->regions[i].vmaddr;
@@ -183,13 +189,8 @@ void rls_rvm_map_cb(cbinfo, status, msg)
                                         goto exit;
                                 }
 
-                        if (i == hdrp->nregions-1) {
-                                rvm_map_cbinfo->bc_cb     = rls_loop_rvm_map_cb;
-                                rvm_map_cbinfo->bc_pcbinfo = cbinfo;
-                        }
-
                         /* Pass rvm_map_cbinfo as param to rvm_map. */
-                        err = rvm_map(seg_hdr, region, options);
+                        err = rvm_map(seg_hdr, region, options, rvm_map_cbinfo);
                         if (err != RVM_SUCCESS) {
                                 status = -1;
                                 msg    = (m0_be_msg_type_t)err;
@@ -197,7 +198,10 @@ void rls_rvm_map_cb(cbinfo, status, msg)
                         }
                 }
 exit:
-        rls_loop_rvm_map_cb(cbinfo, status, msg);
+        if (status != 0 && cbinfo->bc_pcbinfo != NULL &&
+            cbinfo->bc_pcbinfo->bc_cb != NULL) {
+                m0_be_handler_post(cbinfo->bc_pcbinfo, status, msg);
+        }
 }
 
 
@@ -271,7 +275,7 @@ rvm_load_segment(char *DevName, rvm_offset_t DevLength, rvm_options_t *options,
          * else, as vmaddr is NULL, the segment will be pre-allocated and
          * registered by rvm_map->establish_range->round_region->page_alloc -JH
          */
-        err = rvm_map(seg_hdr, hdr_region, options);
+        err = rvm_map(seg_hdr, hdr_region, options, rlsc_cbinfo);
         if (err != RVM_SUCCESS) {
                 status = -1;
                 msg    = err;
@@ -286,6 +290,5 @@ exit:
                 m0_free(rls_cbdata);
         }
 
-        rls_rvm_map_cb(rlsc_cbinfo, status, msg);
         return status;
 }
diff --git a/rvm/rvm_map.c b/rvm/rvm_map.c
index 6316923..c65e886 100644
--- a/rvm/rvm_map.c
+++ b/rvm/rvm_map.c
@@ -44,6 +44,9 @@ Coda are listed in the file CREDITS.
 #include <errno.h>
 #include "rvm/rvm_private.h"
 
+#include "lib/memory.h"
+#include "be/handler.h"
+
 #ifdef __CYGWIN32__
 #include <windows.h>
 #endif
@@ -202,14 +205,12 @@ rvm_bool_t rvm_register_page(rvm_seg_hdr_t *seg_hdr, char *vmaddr, rvm_length_t
 	/* case one: the start of the new region falls within
 	   a previously allocated region */
 	if( (bookmark->start <= vmaddr) && (vmaddr <= bookmark->end) ) {
-	    printf("Case one.\n");
 	    return(rvm_false);
 	}
 
 	/* case two: the end of the new region falls within
 	   a previously allocated region */
 	if ( (bookmark->start <= end)   && (end    <= bookmark->end) ) {
-	    printf("Case two.\n");
 	    return(rvm_false);
 	}
 
@@ -217,7 +218,6 @@ rvm_bool_t rvm_register_page(rvm_seg_hdr_t *seg_hdr, char *vmaddr, rvm_length_t
 	   (n.b.: the case where the new region is contained within a
 	          currently allocated region is handled by case one) */
 	if ( (vmaddr <= bookmark->start) && (bookmark->end <= end) ) {
-	    printf("Case three.\n");
 	    return(rvm_false);
 	}
 
@@ -944,55 +944,71 @@ err_exit:;
     }
 
 /* make data from segment available from mapped region */
-static rvm_return_t map_data(rvm_options,region)
-    rvm_options_t   *rvm_options;
-    region_t        *region;
-    {
-    seg_t           *seg = region->seg;
-    rvm_return_t    retval = RVM_SUCCESS;
-#if defined(__NetBSD__) || defined(__FreeBSD__)
-    char            *addr;
-#endif
-    /* check for pager mapping */
-    if (rvm_options != NULL)
-        if (rvm_options->pager != NULL)
-            {
-            /* external pager interface not implemented yet */
-            return RVM_EPAGER;
-            }
+static rvm_return_t map_data(rvm_options_t 	 *rvm_options,
+			     region_t 	 	 *region,
+			     struct m0_be_cbinfo *cbinfo)
+{
+	seg_t           	*seg 	 = region->seg;
+	int 		 	status   = RVM_SUCCESS;
+	m0_be_msg_type_t 	msg_type = M0_BE_SUCCESS;
+
+	#if defined(__NetBSD__) || defined(__FreeBSD__)
+	char            *addr;
+	#endif
+	/* check for pager mapping */
+	if (rvm_options != NULL)
+		if (rvm_options->pager != NULL) {
+			/* external pager interface not implemented yet */
+			status = -1;
+			msg_type = RVM_EPAGER;
+			goto exit;
+		}
 
-#if defined(__NetBSD__) || defined(__FreeBSD__)
-		/* NetBSD has a kernel bug that will panic if we
-		   try to read from a raw device and copy it to address
-		   on or above 0x10400000.  This is known to be a problem
-		   with vm_fault() of NetBSD kernel that panics when it
-		   finds that the pte (page directory table entry) does
-		   not exist in page dir table (instead of trying to
-		   create it). Before that is fixed, we work around it
-		   by manually touching one byte of address space of
-		   every pte's that we'll need.  This will get the pte
-		   created and we'll be fine.  This is proposed by rvb.
-		     -- clement */
-		if (seg->dev.raw_io) {
-		    for (addr=region->vmaddr;
-			 addr < ( (region->vmaddr)+(region->length) );
-			 addr+=0x400000) { /* each pte is for 0x400000 of vm */
+	#if defined(__NetBSD__) || defined(__FreeBSD__)
+	/* NetBSD has a kernel bug that will panic if we
+	try to read from a raw device and copy it to address
+	on or above 0x10400000.  This is known to be a problem
+	with vm_fault() of NetBSD kernel that panics when it
+	finds that the pte (page directory table entry) does
+	not exist in page dir table (instead of trying to
+	create it). Before that is fixed, we work around it
+	by manually touching one byte of address space of
+	every pte's that we'll need.  This will get the pte
+	created and we'll be fine.  This is proposed by rvb.
+	-- clement */
+	if (seg->dev.raw_io) {
+		for (addr=region->vmaddr;
+		     addr < ( (region->vmaddr) + (region->length) );
+		     addr+=0x400000) {
+		     /* each pte is for 0x400000 of vm */
 			*addr = 0; /* this will force kernel to create
-				   the pte*/
-		    }
+			the pte*/
+		}
+	}
+	#endif /* __BSD44__ */
+	/* read data directly from segment */
+	if (!region->no_copy)
+		{
+			status = read_stob_new(&seg->dev,
+				      	   &region->offset,
+					   region->vmaddr,
+					   region->length,
+					   cbinfo);
+			if (status < 0) {
+				msg_type = RVM_EIO;
+				status 	 = -1;
+				goto exit;
+			}
 		}
-#endif /* __BSD44__ */
-    /* read data directly from segment */
-    if (!region->no_copy)
-        CRITICAL(seg->dev_lock,
-            {
-            if (read_stob(&seg->dev,&region->offset,
-                         region->vmaddr,region->length) < 0)
-                retval = RVM_EIO;
-            });
 
-    return retval;
-    }
+	return RVM_SUCCESS;
+exit:
+	if (status != 0 && cbinfo->bc_pcbinfo != NULL &&
+	    cbinfo->bc_pcbinfo->bc_cb != NULL) {
+                m0_be_handler_post(cbinfo->bc_pcbinfo, status, msg_type);
+        }
+	return status;
+}
 
 /* error exit cleanup */
 static void clean_up(seg_hdr,region,mem_region)
@@ -1027,87 +1043,180 @@ static void clean_up(seg_hdr,region,mem_region)
         }
 }
 
-/* rvm_map */
-rvm_return_t rvm_map(rvm_seg_hdr_t *seg_hdr, rvm_region_t *rvm_region, rvm_options_t *rvm_options)
+void rvm_map_cb(struct m0_be_cbinfo *cbinfo,
+		int status,
+		m0_be_msg_type_t msg_type)
 {
-    seg_t               *seg;              /* segment descriptor */
-    region_t            *region = NULL;    /* new region descriptor */
-    mem_region_t        *mem_region= NULL; /* new region's tree node */
-    rvm_return_t        retval;
-    rvm_region_t        save_rvm_region;
-    int fd;				   /* For private mappings */
-    void *addr;
-
-    /* preliminary checks & saves */
-    if (bad_init()) return RVM_EINIT;
-    if ((retval=bad_region(rvm_region)) != RVM_SUCCESS)
-        return retval;
-    if (rvm_options != NULL)
-        if ((retval=do_rvm_options(rvm_options)) != RVM_SUCCESS)
-            return retval;
-    if (default_log == NULL) return RVM_ELOG;
-    (void)BCOPY((char *)rvm_region,(char *)&save_rvm_region,
-               sizeof(rvm_region_t));
-
-    /* find or build segment */
-    seg = seg_lookup(rvm_region->data_dev,&retval);
-    if (retval != RVM_SUCCESS) goto err_exit;
-    if (seg == NULL)
-        {                               /* must build a new segment */
-        if ((seg=build_seg(rvm_region,default_log,&retval))
-            == NULL) goto err_exit;
-            seg->dev.stob = seg_hdr->seg_stob;
+	rvm_region_t	*rvm_region;
+	rm_cbdata_t 	*rm_cbdata;
+
+	rm_cbdata = container_of(cbinfo, rm_cbdata_t, rmc_cbinfo);
+        M0_ASSERT(rm_cbdata != NULL);
+
+        rvm_region = rm_cbdata->rmc_rvm_region;
+
+	if (status != 0)
+		rvm_region->length = 0;
+
+	if (cbinfo->bc_pcbinfo != NULL && cbinfo->bc_pcbinfo->bc_cb != NULL) {
+                m0_be_handler_post(cbinfo->bc_pcbinfo, status, msg_type);
         }
-    else
-        /* test if segment closed by earlier (failing) rvm_terminate */
-        if (seg->dev.handle == 0) return RVM_EIO;
+	m0_free(rm_cbdata);
+}
 
-    /* check for vm overlap with existing mappings & build descriptors */
-    if ((retval = establish_range(seg_hdr, rvm_region,&region,&mem_region,seg))
-                != RVM_SUCCESS)
-        goto err_exit;
+/* rvm_map */
+rvm_return_t rvm_map(rvm_seg_hdr_t 		*seg_hdr,
+		     rvm_region_t  		*rvm_region,
+		     rvm_options_t 		*rvm_options,
+		     struct m0_be_cbinfo	*cbinfo)
+{
+	seg_t       		*seg;              /* segment descriptor */
+	region_t   		*region = NULL;    /* new region descriptor */
+	mem_region_t		*mem_region= NULL; /* new region's tree node */
+	void			*addr;
+	rm_cbdata_t		*rm_cbdata;
+	struct m0_be_cbinfo 	*rmc_cbinfo;
+	rvm_region_t   	 	save_rvm_region;
+	int		 	fd;		   /* For private mappings */
+	rvm_return_t  	 	retval;
+	int 		 	status 		= 0;
+	m0_be_msg_type_t 	msg_type 	= M0_BE_SUCCESS;
+	int 		 	region_saved 	= 0;
+
+	/* preliminary checks & saves */
+	if (bad_init()) {
+		status = -1;
+		msg_type =  RVM_EINIT;
+		goto err_exit;
+	}
+	if ((retval = bad_region(rvm_region)) != RVM_SUCCESS) {
+		status = -1;
+		msg_type = retval;
+	}
+	if (rvm_options != NULL)
+		if ((retval = do_rvm_options(rvm_options)) != RVM_SUCCESS) {
+			status = -1;
+			msg_type = retval;
+			goto err_exit;
+		}
+	if (default_log == NULL) {
+		status 	 = -1;
+		msg_type = RVM_ELOG;
+		goto err_exit;
+	}
+	(void)BCOPY((char *)rvm_region,(char *)&save_rvm_region,
+		    sizeof(rvm_region_t));
+
+	/* This is used to cleanup above saved region */
+	region_saved = 1;
+
+	/* find or build segment */
+	seg = seg_lookup(rvm_region->data_dev,&retval);
+	if (retval != RVM_SUCCESS) {
+		status 	 = -1;
+		msg_type = retval;
+		goto err_exit;
+	}
+	if (seg == NULL) {
+		/* must build a new segment */
+		if ((seg=build_seg(rvm_region,default_log,&retval)) == NULL) {
+			status = -1;
+			msg_type = M0_BE_INTERNAL;
+			goto err_exit;
+		}
+		seg->dev.stob = seg_hdr->seg_stob;
+	}
+	else {
+	/* test if segment closed by earlier (failing) rvm_terminate */
+		if (seg->dev.handle == 0) {
+			status 	 = -1;
+			msg_type = RVM_EIO;
+			goto err_exit;
+		}
+	}
 
-    /* check for overlap with existing mappings in segment, check
-       for truncation dependencies, and enter region in map_list */
-    if ((retval=chk_dependencies(seg,region)) != RVM_SUCCESS)
-        goto err_exit;
+	/* check for vm overlap with existing mappings & build descriptors */
+	retval = establish_range(seg_hdr, rvm_region,&region, &mem_region,seg);
+	if (retval != RVM_SUCCESS) {
+		status 	 = -1;
+		msg_type = retval;
+		goto err_exit;
+	}
 
-    /* Do the private map or get the data from the segment */
-    if (rvm_map_private) {
-	fd = open(rvm_region->data_dev, O_RDONLY | O_BINARY);
-	if ( fd < 0 ) {
-	    retval = RVM_EIO;
-	    goto err_exit;
+	/* check for overlap with existing mappings in segment, check
+	for truncation dependencies, and enter region in map_list */
+	if ((retval = chk_dependencies(seg, region)) != RVM_SUCCESS) {
+		status 	 = -1;
+		msg_type = retval;
+		goto err_exit;
 	}
-	addr = mmap(rvm_region->vmaddr, rvm_region->length,
-		    PROT_READ | PROT_WRITE, MAP_FIXED | MAP_PRIVATE,
-		    fd, region->offset.low);
-	if (!rvm_region->vmaddr)
-	    rvm_region->vmaddr = addr;
-
-	if (addr != rvm_region->vmaddr) {
-	    retval = RVM_ENOT_MAPPED;
-	    goto err_exit;
+
+	/* complete region tree node */
+	mem_region->region = region;
+
+	/* Do the private map or get the data from the segment */
+	if (rvm_map_private) {
+		fd = open(rvm_region->data_dev, O_RDONLY | O_BINARY);
+		if ( fd < 0 ) {
+			status   = -1;
+			msg_type = RVM_EIO;
+			goto err_exit;
+		}
+		addr = mmap(rvm_region->vmaddr,
+			    rvm_region->length,
+			    PROT_READ | PROT_WRITE,
+			    MAP_FIXED | MAP_PRIVATE,
+			    fd,
+			    region->offset.low);
+		if (!rvm_region->vmaddr)
+			rvm_region->vmaddr = addr;
+
+		if (addr != rvm_region->vmaddr) {
+			status = -1;
+			msg_type = RVM_ENOT_MAPPED;
+			goto err_exit;
+		}
+		if (close(fd)) {
+			status 	 = -1;
+			msg_type = RVM_EIO;
+			goto err_exit;
+		}
 	}
-	if (close(fd)) {
-	    retval = RVM_EIO;
-	    goto err_exit;
+	else {
+		/* get the data from the segment */
+		M0_ALLOC_PTR(rm_cbdata);
+		M0_ASSERT(rm_cbdata != NULL);
+
+		rmc_cbinfo = &rm_cbdata->rmc_cbinfo;
+
+		rmc_cbinfo->bc_cb 	= rvm_map_cb;
+		rmc_cbinfo->bc_pcbinfo 	= cbinfo;
+		rmc_cbinfo->bc_hq 	= cbinfo->bc_hq;
+		rmc_cbinfo->bc_sm_group = cbinfo->bc_sm_group;
+
+		rm_cbdata->rmc_rvm_region = rvm_region;
+
+		retval = map_data(rvm_options, region, rmc_cbinfo);
+
+		if (retval != RVM_SUCCESS) {
+			status = -1;
+			msg_type = retval;
+			goto err_exit;
+		}
 	}
-    } else {
-        /* get the data from the segment */
-        if ((retval = map_data(rvm_options,region)) != RVM_SUCCESS) {
-            rvm_region->length = 0;
-	    goto err_exit;
+
+	return RVM_SUCCESS;
+err_exit:
+	if (region_saved) {
+		clean_up(region, mem_region);
+		(void)BCOPY((char *)&save_rvm_region, (char *)rvm_region,
+			    sizeof(rvm_region_t));
 	}
-    }
 
-    /* complete region tree node and exit*/
-    mem_region->region = region;
-    return RVM_SUCCESS;
+	if (rvm_map_private || (status != 0 && cbinfo->bc_pcbinfo != NULL &&
+				cbinfo->bc_pcbinfo->bc_cb != NULL)) {
+                m0_be_handler_post(cbinfo->bc_pcbinfo, status, msg_type);
+        }
 
-  err_exit:
-    clean_up(region,mem_region);
-    (void)BCOPY((char *)&save_rvm_region,(char *)rvm_region,
-               sizeof(rvm_region_t));
-    return retval;
+	return status;
 }
diff --git a/rvm/rvm_private.h b/rvm/rvm_private.h
index 79ce989..41ec385 100644
--- a/rvm/rvm_private.h
+++ b/rvm/rvm_private.h
@@ -39,6 +39,7 @@ Coda are listed in the file CREDITS.
 #include <assert.h>
 #include "rvm/rvm.h"
 #include "rvm/rvm_statistics.h"
+#include "be/be.h"
 
 #include <fcntl.h>
 #include <stdint.h>
@@ -1108,6 +1109,29 @@ typedef struct
     }
 int_tid_t;
 
+/* rvm_map_cbdata */
+typedef	struct rm_cbdata {
+	struct m0_be_cbinfo	 rmc_cbinfo;
+	rvm_region_t 		*rmc_rvm_region;
+}rm_cbdata_t;
+
+/* read_stob_cbdata */
+typedef	struct read_stob_cbdata {
+	struct m0_be_cbinfo	  rsc_cbinfo;
+	device_t		 *rsc_dev;
+	void                  	**rsc_io_addr;
+	m0_bindex_t            	*rsc_io_offset;
+	m0_bcount_t            	*rsc_io_count;
+	uint64_t		 rsc_nbytes;
+}read_stob_cbdata_t;
+
+/* read_stob_cbdata */
+typedef	struct launch_stob_io_cbdata {
+	struct m0_be_cbinfo	 lsic_cbinfo;
+	struct m0_clink		 lsic_clink;
+	struct m0_stob_io     	 lsic_io;
+}lsi_cbdata_t;
+
 /* definitions for tid flags field (also used in trans_hdr flags field */
 #define RESTORE_FLAG        (2*RVM_COALESCE_TRANS)
 #define FLUSH_FLAG          (2*RESTORE_FLAG)
@@ -1485,7 +1509,7 @@ long mem_partial_include(tree_node_t *tnode1, tree_node_t *tnode2);
 long mem_total_include(tree_node_t *tnode1, tree_node_t *tnode2);
 region_t *find_whole_range(rvm_seg_hdr_t *seg_hdr, char *dest, rvm_length_t length, rw_lock_mode_t mode);
 region_t *find_partial_range(rvm_seg_hdr_t *seg_hdr, char *dest, rvm_length_t length, long *code);
-rvm_return_t rvm_map(rvm_seg_hdr_t *seg_hdr, rvm_region_t *rvm_region, rvm_options_t *rvm_options);
+rvm_return_t rvm_map(rvm_seg_hdr_t *seg_hdr, rvm_region_t *rvm_region, rvm_options_t *rvm_options, struct m0_be_cbinfo *cbinfo);
 
 
 /* segment dictionary functions */
@@ -1518,6 +1542,13 @@ long close_dev();                       /* [rvm_io.c] */
 /*  device_t        *dev; */
 
 extern
+long read_stob_new();                        /* [rvm_io.c] */
+/*  device_t        *dev;
+    rvm_offset_t    *offset;
+    char            *dest;
+    rvm_length_t    length;
+*/
+extern
 long read_stob();                        /* [rvm_io.c] */
 /*  device_t        *dev;
     rvm_offset_t    *offset;
-- 
1.8.3.2

