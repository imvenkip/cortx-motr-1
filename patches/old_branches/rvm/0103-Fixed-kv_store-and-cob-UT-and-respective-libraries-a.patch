From f4e0494dd76ecc2679d0c8100454b688f46edc92 Mon Sep 17 00:00:00 2001
From: Zishan Shaikh <zishan_shaikh@xyratex.com>
Date: Tue, 28 May 2013 04:01:02 -0700
Subject: [PATCH 103/121] Fixed kv_store and cob UT and respective libraries as
 well to fit into current async mechanism. KV store, BE, COB UT and kvstore UB
 are working fine.

---
 be/be_rvm.c        |   6 +-
 be/domain.c        |  16 +++-
 be/helper.c        |  29 +++---
 be/helper.h        |   4 +-
 be/kv_store.c      | 195 +++++++++++++++++++----------------------
 be/kv_store.h      |  33 +++----
 be/ut/kv_store.c   | 253 ++++++++++++++++++++++++++---------------------------
 cob/cob.c          | 131 +++++++++++++++++----------
 cob/ut/cob.c       |  49 ++++++++++-
 rvm/rvm.h          |   5 ++
 rvm/rvm_init.c     |   4 +-
 rvm/rvm_logflush.c |   3 +-
 rvm/rvm_private.h  |   3 -
 13 files changed, 397 insertions(+), 334 deletions(-)

diff --git a/be/be_rvm.c b/be/be_rvm.c
index 6686daf..06c2d33 100644
--- a/be/be_rvm.c
+++ b/be/be_rvm.c
@@ -84,9 +84,9 @@ int m0_be_rvm_init(struct m0_be_domain *dom,
         if(retval != RVM_SUCCESS)
                 status = -1;
 
-        if (status != 0 && cbinfo->bc_pcbinfo != NULL &&
-            cbinfo->bc_pcbinfo->bc_cb != NULL) {
-                m0_be_handler_post(cbinfo->bc_pcbinfo, status, msg_type);
+        if (status != 0 && cbinfo != NULL &&
+            cbinfo->bc_cb != NULL) {
+                m0_be_handler_post(cbinfo, status, msg_type);
                 m0_free(rvm_cbdata);
         }
         return 0;
diff --git a/be/domain.c b/be/domain.c
index 3096df3..f41c57c 100644
--- a/be/domain.c
+++ b/be/domain.c
@@ -76,6 +76,7 @@ M0_INTERNAL void m0_be_domain_init(struct m0_be_domain *dom,
         int                        result;
         struct m0_be_handler_data *bh_data;
         int                        status = 0;
+	bool			   rvm_init_done = false;
         m0_be_msg_type_t           msg_type = M0_BE_SUCCESS;
 
         M0_ENTRY("domain: %p", dom);
@@ -110,12 +111,19 @@ M0_INTERNAL void m0_be_domain_init(struct m0_be_domain *dom,
         m0_be_tx_tlist_init(&dom->bd_tx);
 
         printf("\nfunction : %s\n", __FUNCTION__);
-        status = m0_be_rvm_init(dom, cbinfo);
+
+	/* Do no init RVM if already initialised. */
+	if (bad_init())
+        	status = m0_be_rvm_init(dom, cbinfo);
+	else
+		rvm_init_done = true;
+
+	status = 0;
 
 exit:
-        if (status != 0 && cbinfo->bc_pcbinfo != NULL &&
-            cbinfo->bc_pcbinfo->bc_cb != NULL) {
-                m0_be_handler_post(cbinfo->bc_pcbinfo, status, msg_type);
+        if ((status != 0 || rvm_init_done) && cbinfo != NULL &&
+            cbinfo->bc_cb != NULL) {
+                m0_be_handler_post(cbinfo, status, msg_type);
         }
 
         M0_POST(m0_be_domain_invariant(dom));
diff --git a/be/helper.c b/be/helper.c
index 1b3642e..05cc4ec 100644
--- a/be/helper.c
+++ b/be/helper.c
@@ -181,23 +181,20 @@ M0_EXPORTED(m0_kv_malloc_helper);
 M0_INTERNAL void *m0_kv_find_helper(struct m0_be_kv_store *handle,
                                     void                  *key,
                                     void                  *cbdata,
-                                    void                 (*find_cb)(void *data,
-                                                                    void *res,
-                                                                    int   rc))
+				    struct m0_be_cbinfo   *cbinfo)
+/*void                 (*find_cb)(void *data,*/
+/*void *res,*/
+/*int   rc))*/
 {
-        struct m0_be_kv_store_cb        *cb_info = NULL;
-        void                            *result;
+        void                    *result;
 
-        if (cbdata != NULL && find_cb != NULL) {
-                M0_ALLOC_PTR(cb_info);
-                cb_info->ksc_cbdata     = cbdata;
-                cb_info->ksc_cb         = find_cb;
-        }
-
-        result = m0_be_ks_find(handle, cb_info, key);
-        if (cb_info != NULL)
-                m0_free(cb_info);
+	/*if (cbdata != NULL && find_cb != NULL) {*/
+	/*M0_ALLOC_PTR(cb_info);*/
+	/*cb_info->ksc_cbdata     = cbdata;*/
+	/*cb_info->ksc_cb         = find_cb;*/
+	/*}*/
 
+        result = m0_be_ks_find(handle, cbinfo, key);
         return result;
 }
 M0_EXPORTED(m0_kv_find_helper);
@@ -284,9 +281,9 @@ M0_EXPORTED(m0_be_sm_lock_state_change_helper);
 
 M0_INTERNAL void m0_be_cbinfo_copy_helper(struct m0_be_cbinfo *icbinfo,
                                           struct m0_be_cbinfo *ocbinfo,
-                                          m0_be_callback cb)
+                                          m0_be_callback       cb)
 {
-    ocbinfo->bc_pcbinfo   = icbinfo;
+    ocbinfo->bc_pcbinfo  = icbinfo;
     ocbinfo->bc_cb       = cb;
     ocbinfo->bc_sm_group = icbinfo->bc_sm_group;
     ocbinfo->bc_hq       = icbinfo->bc_hq;
diff --git a/be/helper.h b/be/helper.h
index 897f96d..4a4437c 100644
--- a/be/helper.h
+++ b/be/helper.h
@@ -77,9 +77,7 @@ M0_INTERNAL void *m0_kv_malloc_helper(struct m0_be_domain     *cob_be_domain,
 M0_INTERNAL void *m0_kv_find_helper(struct m0_be_kv_store *handle,
                                     void                  *key,
                                     void                  *cbdata,
-                                    void                 (*find_cb)(void *data,
-                                                                    void *res,
-                                                                    int   rc));
+				    struct m0_be_cbinfo   *cbinfo);
 
 M0_INTERNAL int32_t m0_kv_delete_helper(struct m0_be_kv_store *handle,
                                         struct m0_be_tx       *tx,
diff --git a/be/kv_store.c b/be/kv_store.c
index caf27b0..4a589c6 100644
--- a/be/kv_store.c
+++ b/be/kv_store.c
@@ -134,15 +134,15 @@ M0_INTERNAL void m0_be_ks_create(struct m0_tl_descr      *descr,
 M0_EXPORTED(m0_be_ks_create);
 
 M0_INTERNAL void m0_be_ks_init(struct m0_be_kv_store     *handle,
-                               struct m0_be_kv_store_cb  *cb_info,
+                               struct m0_be_cbinfo	 *cbinfo,
                                enum   m0_be_ks_init_mode  mode)
 {
         struct m0_sm_group         *sm_group;
         struct m0_be_seg           *rvm_handle_seg = NULL;
         struct m0_be_ks_cbdata     *bk_cbdata;
+        struct m0_be_cbinfo	   *bkc_cbinfo;
         struct m0_tl_descr         *descr;
         struct m0_be_domain        *dom;
-        struct m0_be_kv_store_cb   *bkc_ks_cbinfo;
         bool                        ret_dom;
 
         M0_ENTRY("handle: %p mode: %d", handle, mode);
@@ -162,55 +162,45 @@ M0_INTERNAL void m0_be_ks_init(struct m0_be_kv_store     *handle,
         M0_ASSERT(ret_dom);
         M0_PRE(m0_be_seg_state(rvm_handle_seg) == M0_BESEG_ACTIVE);
 
-        M0_ALLOC_PTR(bk_cbdata);
-        M0_ASSERT(bk_cbdata != NULL);
-
         /* Mark key store initialisation as in progress */
         m0_be_sm_lock_state_change_helper(&handle->ks_handle_heap.ksh_sm,
                                           sm_group, M0_BEKS_INPROGRESS);
-        /*
-         * If user has provided a callback function to be called after
-         * completion of ks_init, then maintain it in our own call back data
-         */
-        if (cb_info != NULL) {
-                M0_ALLOC_PTR(bkc_ks_cbinfo);
-                M0_ASSERT(bkc_ks_cbinfo != NULL);
 
-                bkc_ks_cbinfo->ksc_cb     = cb_info->ksc_cb;
-                bkc_ks_cbinfo->ksc_cbdata = cb_info->ksc_cbdata;
-                bk_cbdata->bkc_ks_cbinfo  = bkc_ks_cbinfo;
-        }
-        else {
-                /* Assures bkc_ks_cbinfo won't contain garbage info */
-                bk_cbdata->bkc_ks_cbinfo = NULL;
-        }
+	/* Prepare call back data */
+	M0_ALLOC_PTR(bk_cbdata);
+	M0_ASSERT(bk_cbdata != NULL);
 
-        /* Prepare call back data */
         bk_cbdata->bkc_handle   = handle;
         bk_cbdata->bkc_ksi_mode = mode;
         bk_cbdata->bkc_seg      = rvm_handle_seg;
 
-        __ks_handle_create_helper(bk_cbdata);
+	bkc_cbinfo 		= &bk_cbdata->bkc_cbinfo;
+	m0_be_cbinfo_copy_helper(cbinfo, bkc_cbinfo, NULL);
+
+	/*bkc_ks_cbinfo->ksc_cb     = cb_info->ksc_cb;*/
+	/*bkc_ks_cbinfo->ksc_cbdata = cb_info->ksc_cbdata;*/
+	/*bk_cbdata->bkc_ks_cbinfo  = bkc_ks_cbinfo;*/
+
+	__ks_handle_create_helper(bk_cbdata);
         M0_LEAVE("handle: %p", handle);
 }
 M0_EXPORTED(m0_be_ks_init);
 
 M0_INTERNAL void m0_be_ks_fini(struct m0_be_kv_store     *handle,
-                               struct m0_be_kv_store_cb  *bkc_ks_cbinfo)
+                               struct m0_be_cbinfo	 *cbinfo)
 {
-        void                *ksc_cbdata;
         int32_t              ret_val;
 
         M0_ENTRY();
         M0_PRE(m0_be_ks_get_handle_state(handle) == M0_BEKS_DONE);
         ret_val = 0;
 
-        /* Call the callback function provided by the user. */
-        if (bkc_ks_cbinfo != NULL) {
-                ksc_cbdata = bkc_ks_cbinfo->ksc_cbdata;
-                M0_ASSERT(ksc_cbdata != NULL);
-                bkc_ks_cbinfo->ksc_cb(ksc_cbdata, NULL, ret_val);
-        }
+	/**//* Call the callback function provided by the user. */
+	/*if (bkc_ks_cbinfo != NULL) {*/
+	/*ksc_cbdata = bkc_ks_cbinfo->ksc_cbdata;*/
+	/*M0_ASSERT(ksc_cbdata != NULL);*/
+	/*bkc_ks_cbinfo->ksc_cb(ksc_cbdata, NULL, ret_val);*/
+	/*}*/
 
         m0_free(handle);
         M0_LEAVE();
@@ -218,12 +208,11 @@ M0_INTERNAL void m0_be_ks_fini(struct m0_be_kv_store     *handle,
 M0_EXPORTED(m0_be_ks_fini);
 
 M0_INTERNAL void *m0_be_ks_find(struct m0_be_kv_store     *handle,
-                                struct m0_be_kv_store_cb  *bkc_ks_cbinfo,
+                                struct m0_be_cbinfo	  *cbinfo,
                                 void                      *key)
 {
         void                    *scan;
         void                    *target;
-        void                    *ksc_cbdata;
         struct m0_tl            *ks_tlist;
         struct m0_tl_descr      *ks_list_descr;
         int32_t                  rc;
@@ -250,11 +239,11 @@ M0_INTERNAL void *m0_be_ks_find(struct m0_be_kv_store     *handle,
 
 exit_find:
         /* Call the callback function provided by the user. */
-        if (bkc_ks_cbinfo != NULL) {
-                ksc_cbdata = bkc_ks_cbinfo->ksc_cbdata;
-                M0_ASSERT(ksc_cbdata != NULL);
-                bkc_ks_cbinfo->ksc_cb(ksc_cbdata, target, rc);
-        }
+	/*if (bkc_ks_cbinfo != NULL) {*/
+	/*ksc_cbdata = bkc_ks_cbinfo->ksc_cbdata;*/
+	/*M0_ASSERT(ksc_cbdata != NULL);*/
+	/*bkc_ks_cbinfo->ksc_cb(ksc_cbdata, target, rc);*/
+	/*}*/
 
         M0_LEAVE("target: %p", target);
         return target;
@@ -262,13 +251,12 @@ exit_find:
 M0_EXPORTED(m0_be_ks_find);
 
 M0_INTERNAL int32_t m0_be_ks_delete(struct m0_be_kv_store     *handle,
-                                    struct m0_be_kv_store_cb  *bkc_ks_cbinfo,
+                                    struct m0_be_cbinfo	      *cbinfo,
                                     void                      *obj,
                                     struct m0_be_tx           *tx)
 {
         void                    *scan;
         void                    *target = NULL;
-        void                    *ksc_cbdata;
         struct m0_be_reg        *t_head_reg;
         struct m0_list_link     *temp_link;
         struct m0_list_link     *t_head_link;
@@ -326,12 +314,12 @@ M0_INTERNAL int32_t m0_be_ks_delete(struct m0_be_kv_store     *handle,
         ret_val = -ENOENT;
 
 exit_delete:
-        /* Call the callback function provided by the user. */
-        if (bkc_ks_cbinfo != NULL) {
-                ksc_cbdata = bkc_ks_cbinfo->ksc_cbdata;
-                M0_ASSERT(ksc_cbdata != NULL);
-                bkc_ks_cbinfo->ksc_cb(ksc_cbdata, NULL, ret_val);
-        }
+	/* Call the callback function provided by the user. */
+	/*if (bkc_ks_cbinfo != NULL) {*/
+	/*ksc_cbdata = bkc_ks_cbinfo->ksc_cbdata;*/
+	/*M0_ASSERT(ksc_cbdata != NULL);*/
+	/*bkc_ks_cbinfo->ksc_cb(ksc_cbdata, NULL, ret_val);*/
+	/*}*/
 
         M0_LEAVE();
         return ret_val;
@@ -340,7 +328,7 @@ M0_EXPORTED(m0_be_ks_delete);
 
 M0_INTERNAL int32_t m0_be_ks_update(struct m0_be_kv_store     *handle,
                                     struct m0_be_tx           *tx,
-                                    struct m0_be_kv_store_cb  *bkc_ks_cbinfo,
+                                    struct m0_be_cbinfo	      *cbinfo,
                                     void                      *in_obj,
                                     uint64_t                   sizeof_obj,
                                     kv_obj_update_t            obj_update)
@@ -354,7 +342,6 @@ M0_INTERNAL int32_t m0_be_ks_update(struct m0_be_kv_store     *handle,
         struct m0_be_seg        *seg;
         void                    *current;
         void                    *scan;
-        void                    *ksc_cbdata;
         int32_t                  ret_val;
         bool                     ret_dom;
         kv_key_cmp_t             cmp_fp;
@@ -418,12 +405,11 @@ M0_INTERNAL int32_t m0_be_ks_update(struct m0_be_kv_store     *handle,
 
 exit_update:
         /* Call the callback function provided by the user. */
-        if (bkc_ks_cbinfo != NULL) {
-                ksc_cbdata = bkc_ks_cbinfo->ksc_cbdata;
-                M0_ASSERT(ksc_cbdata != NULL);
-                bkc_ks_cbinfo->ksc_cb(ksc_cbdata, NULL, ret_val);
-        }
-
+	/*if (bkc_ks_cbinfo != NULL) {*/
+	/*ksc_cbdata = bkc_ks_cbinfo->ksc_cbdata;*/
+	/*M0_ASSERT(ksc_cbdata != NULL);*/
+	/*bkc_ks_cbinfo->ksc_cb(ksc_cbdata, NULL, ret_val);*/
+	/*}*/
         return ret_val;
 }
 M0_EXPORTED(m0_be_ks_update);
@@ -467,7 +453,7 @@ M0_INTERNAL int32_t __ks_tlist_add_at_tail(struct m0_be_kv_store     *handle,
 }
 
 M0_INTERNAL int32_t m0_be_ks_insert(struct m0_be_kv_store     *handle,
-                                    struct m0_be_kv_store_cb  *bkc_ks_cbinfo,
+                                    struct m0_be_cbinfo	      *cbinfo,
                                     struct m0_be_reference    *obj_ref,
                                     struct m0_be_tx           *tx)
 {
@@ -478,7 +464,6 @@ M0_INTERNAL int32_t m0_be_ks_insert(struct m0_be_kv_store     *handle,
         struct m0_sm_group      *sm_group;
         void                    *scan;
         void                    *new;
-        void                    *ksc_cbdata;
         int32_t                  ret_val;
         kv_key_cmp_t             cmp_fp;
 
@@ -547,11 +532,11 @@ M0_INTERNAL int32_t m0_be_ks_insert(struct m0_be_kv_store     *handle,
         }
 exit_insert:
         /* Call the callback function provided by the user. */
-        if (bkc_ks_cbinfo != NULL) {
-                ksc_cbdata = bkc_ks_cbinfo->ksc_cbdata;
-                M0_ASSERT(ksc_cbdata != NULL);
-                bkc_ks_cbinfo->ksc_cb(ksc_cbdata, NULL, ret_val);
-        }
+	/*if (bkc_ks_cbinfo != NULL) {*/
+	/*ksc_cbdata = bkc_ks_cbinfo->ksc_cbdata;*/
+	/*M0_ASSERT(ksc_cbdata != NULL);*/
+	/*bkc_ks_cbinfo->ksc_cb(ksc_cbdata, NULL, ret_val);*/
+	/*}*/
 
         M0_LEAVE("ret_val: %d", ret_val);
         return ret_val;
@@ -782,11 +767,8 @@ static void __ks_prev_next_add_cred(struct m0_be_kv_store *handle,
 
 static void __ks_handle_create_helper(struct m0_be_ks_cbdata *bk_cbdata)
 {
-        struct m0_be_domain     *dom;
         struct m0_be_kv_store   *handle;
-        struct m0_tl_descr      *descr;
         struct m0_be_seg        *seg;
-        struct m0_sm_group      *sm_group;
         bool                     ret_val;
         enum m0_be_ks_init_mode  mode;
 
@@ -795,15 +777,10 @@ static void __ks_handle_create_helper(struct m0_be_ks_cbdata *bk_cbdata)
         handle = bk_cbdata->bkc_handle;
         seg    = bk_cbdata->bkc_seg;
         mode   = bk_cbdata->bkc_ksi_mode;
-        dom    = handle->ks_handle_heap.ksh_dom;
-        descr  = handle->ks_handle_heap.ksh_list_descr;
 
         M0_ASSERT(handle != NULL);
-        M0_ASSERT(dom    != NULL);
-        M0_ASSERT(seg    != NULL);
-        M0_ASSERT(descr  != NULL);
+        M0_ASSERT(seg  	 != NULL);
 
-        sm_group = m0_be_domain_sm_group(dom);
         ret_val  = m0_be_ks_deref_handle(handle, seg);
 
         /* Create handle */
@@ -827,7 +804,9 @@ M0_INTERNAL void m0_be_ksi_hs_cb(struct m0_be_cbinfo *cbinfo, int status,
         struct m0_be_ks_cbdata      *bk_cbdata;
         struct m0_be_domain         *dom;
         struct m0_sm_group          *sm_group;
-        struct m0_be_cbinfo         *bkc_cbinfo;
+
+	if (status != 0)
+		goto exit;
 
         M0_ENTRY();
 
@@ -841,20 +820,23 @@ M0_INTERNAL void m0_be_ksi_hs_cb(struct m0_be_cbinfo *cbinfo, int status,
         M0_ASSERT(descr       != NULL);
         M0_ASSERT(rvm_handle  != NULL);
 
-        /* freeing callback data sent to hs_update from __ks_create_handle. */
-        m0_free(bk_cbdata->bkc_hscbdata);
 
         sm_group = m0_be_domain_sm_group(dom);
         m0_tlist_init(descr, &rvm_handle->ksr_tlist);
 
-        bkc_cbinfo                      = &bk_cbdata->bkc_cbinfo;
-        bkc_cbinfo->bc_cb               = m0_be_ksi_tx_cb;
-        bkc_cbinfo->bc_pcbinfo          = NULL;
-        bkc_cbinfo->bc_sm_group         = sm_group;
-        bkc_cbinfo->bc_hq               = &dom->bd_hq;
-
+	/*bkc_cbinfo                      = &bk_cbdata->bkc_cbinfo;*/
+        cbinfo->bc_cb = m0_be_ksi_tx_cb;
+	/*bkc_cbinfo->bc_pcbinfo          = NULL;*/
+	/*bkc_cbinfo->bc_sm_group         = sm_group;*/
+	/*bkc_cbinfo->bc_hq               = &dom->bd_hq;*/
+        m0_be_tx_done(tx, cbinfo);
+exit:
+	if (status != 0 && cbinfo->bc_pcbinfo != NULL &&
+	    cbinfo->bc_pcbinfo->bc_cb != NULL) {
+	    	m0_be_handler_post(cbinfo->bc_pcbinfo, status, msg_type);
+		m0_free(bk_cbdata);
+	}
 
-        m0_be_tx_done(tx, bkc_cbinfo);
         M0_LEAVE();
 }
 
@@ -867,6 +849,9 @@ M0_INTERNAL void m0_be_ksi_tx_cb(struct m0_be_cbinfo *cbinfo, int status,
 
         M0_ENTRY();
 
+	if (status != 0)
+		goto exit;
+
         bk_cbdata  = container_of(cbinfo, struct m0_be_ks_cbdata, bkc_cbinfo);
 
         tx  = bk_cbdata->bkc_tx;
@@ -882,29 +867,31 @@ M0_INTERNAL void m0_be_ksi_tx_cb(struct m0_be_cbinfo *cbinfo, int status,
 
         /* Complete the kv-store initialisation process */
         m0_be_ksi_init_done(bk_cbdata);
+exit:
+	if (status != 0 && cbinfo->bc_pcbinfo != NULL &&
+	    cbinfo->bc_pcbinfo->bc_cb != NULL) {
+	    	m0_be_handler_post(cbinfo->bc_pcbinfo, status, msg_type);
+		m0_free(bk_cbdata);
+	}
 
         M0_LEAVE();
 }
 
+/* Last call in the ks_init chain. */
 M0_INTERNAL void m0_be_ksi_init_done(struct m0_be_ks_cbdata *bk_cbdata)
 {
         struct m0_be_kv_store      *handle;
-        struct m0_be_kv_store_cb   *bkc_ks_cbinfo;
         struct m0_be_domain        *dom;
         struct m0_sm_group         *sm_group;
-        void                       *ksc_cbdata;
+	struct m0_be_cbinfo	   *cbinfo;
         int32_t                     ret_val;
 
         M0_ENTRY();
         M0_ASSERT(bk_cbdata != NULL);
 
-        handle = bk_cbdata->bkc_handle;
-        dom    = handle->ks_handle_heap.ksh_dom;
-
-        if (bk_cbdata->bkc_ks_cbinfo != NULL)
-                bkc_ks_cbinfo = bk_cbdata->bkc_ks_cbinfo;
-        else
-                bkc_ks_cbinfo = NULL;
+        handle =  bk_cbdata->bkc_handle;
+	cbinfo = &bk_cbdata->bkc_cbinfo;
+        dom    =  handle->ks_handle_heap.ksh_dom;
 
         M0_ASSERT(handle != NULL);
         M0_ASSERT(dom    != NULL);
@@ -915,15 +902,22 @@ M0_INTERNAL void m0_be_ksi_init_done(struct m0_be_ks_cbdata *bk_cbdata)
                                           sm_group, M0_BEKS_DONE);
         ret_val = 0;
 
-        /* If provided, call the callback function assigned by the user */
-        if (bkc_ks_cbinfo != NULL) {
-                ksc_cbdata = bkc_ks_cbinfo->ksc_cbdata;
-                M0_ASSERT(ksc_cbdata != NULL);
-                bkc_ks_cbinfo->ksc_cb(ksc_cbdata, NULL, ret_val);
-                /* Was allocated in m0_be_ks_init */
-                m0_free(bkc_ks_cbinfo);
-        }
+	/* Call the user provided call back. */
+	if (cbinfo->bc_pcbinfo != NULL && cbinfo->bc_pcbinfo->bc_cb != NULL) {
+		m0_be_handler_post(cbinfo->bc_pcbinfo, ret_val, M0_BE_SUCCESS);
+	}
 
+	/**//* If provided, call the callback function assigned by the user */
+	/*if (bkc_ks_cbinfo != NULL) {*/
+	/*ksc_cbdata = bkc_ks_cbinfo->ksc_cbdata;*/
+	/*M0_ASSERT(ksc_cbdata != NULL);*/
+	/*bkc_ks_cbinfo->ksc_cb(ksc_cbdata, NULL, ret_val);*/
+	/**//* Was allocated in m0_be_ks_init */
+	/*m0_free(bkc_ks_cbinfo);*/
+	/*}*/
+
+        /* freeing callback data sent to hs_update from __ks_create_handle. */
+        m0_free(bk_cbdata->bkc_hscbdata);
         m0_free(bk_cbdata);
         M0_LEAVE();
 }
@@ -981,9 +975,6 @@ M0_INTERNAL void __ks_create_handle(struct m0_be_ks_cbdata *bk_cbdata)
         M0_ASSERT(rvm_handle != NULL);
         M0_ASSERT(rvm_handle_ref != NULL);
 
-        /*
-         * Store this handle information at index 0 in handle_store
-         */
         M0_ALLOC_PTR(bh_cbdata);
         M0_ASSERT(bh_cbdata != NULL);
 
@@ -1004,12 +995,8 @@ M0_INTERNAL void __ks_create_handle(struct m0_be_ks_cbdata *bk_cbdata)
 
         bk_cbdata->bkc_hscbdata         = bh_cbdata;
 
-        bkc_cbinfo                      = &bk_cbdata->bkc_cbinfo;
+	bkc_cbinfo                      = &bk_cbdata->bkc_cbinfo;
         bkc_cbinfo->bc_cb               = m0_be_ksi_hs_cb;
-        bkc_cbinfo->bc_pcbinfo          = NULL;
-        bkc_cbinfo->bc_sm_group         = sm_group;
-        bkc_cbinfo->bc_hq               = &dom->bd_hq;
-
 
         m0_be_hs_update(bh_cbdata, bkc_cbinfo);
         M0_LEAVE();
diff --git a/be/kv_store.h b/be/kv_store.h
index 90c4942..9cc8602 100644
--- a/be/kv_store.h
+++ b/be/kv_store.h
@@ -269,17 +269,6 @@ struct m0_be_kv_store {
 };
 
 /**
-  Structure that stores the callback function and the call back data that would
-  used after completion of kv-store operations.
- */
-struct m0_be_kv_store_cb {
-        /** Call back data to be used. */
-        void            *ksc_cbdata;
-        /** The call back function. */
-        void           (*ksc_cb)(void *cb_data, void *result, int rc);
-};
-
-/**
   The actual key_value pair, has to be allocated on RVM.
   @todo: both ksp_key and ksp_value are just holding virtual addresses for now.
  */
@@ -310,6 +299,10 @@ enum m0_be_ks_init_mode {
   from callback to another.
  */
 struct m0_be_ks_cbdata {
+        /** Holds callback info supplied to lower layer from kv-store layer. */
+        struct m0_be_cbinfo        bkc_cbinfo;
+        /** Kv-store init mode. */
+        enum m0_be_ks_init_mode    bkc_ksi_mode;
         /** Key value store state machine. */
         struct m0_sm               bkc_sm;
         /** Actual kv-store handle. */
@@ -320,14 +313,8 @@ struct m0_be_ks_cbdata {
         struct m0_be_reg          *bkc_reg;
         /** Transaction pointer under which handle is created. */
         struct m0_be_tx           *bkc_tx;
-        /** Callback information to be used after operation completion. */
-        struct m0_be_kv_store_cb  *bkc_ks_cbinfo;
-        /** Kv-store init mode. */
-        enum m0_be_ks_init_mode    bkc_ksi_mode;
         /** pointer to cbdata sent to hs_update. */
         struct m0_be_hs_cbdata    *bkc_hscbdata;
-        /** Holds callback info supplied to lower layer from kv-store layer. */
-        struct m0_be_cbinfo        bkc_cbinfo;
 };
 
 /**
@@ -401,7 +388,7 @@ M0_INTERNAL void m0_be_ks_create(struct m0_tl_descr      *descr,
                                allowed modes: M0_BE_KS_CREATE, M0_BE_KS_RECOVER.
  */
 M0_INTERNAL void m0_be_ks_init(struct m0_be_kv_store     *handle,
-                               struct m0_be_kv_store_cb  *cb_info,
+                               struct m0_be_cbinfo	 *cb_info,
                                enum   m0_be_ks_init_mode  init_mode);
 
 /**
@@ -413,7 +400,7 @@ M0_INTERNAL void m0_be_ks_init(struct m0_be_kv_store     *handle,
 
  */
 M0_INTERNAL void m0_be_ks_fini(struct m0_be_kv_store     *handle,
-                               struct m0_be_kv_store_cb  *cb_info);
+                               struct m0_be_cbinfo	 *cb_info);
 /**
   Insert a key value pair in the kv_store contained in @handle.
 
@@ -432,7 +419,7 @@ M0_INTERNAL void m0_be_ks_fini(struct m0_be_kv_store     *handle,
                                       magic and the domain magic in handle.
  */
 M0_INTERNAL int32_t  m0_be_ks_insert(struct m0_be_kv_store     *handle,
-                                     struct m0_be_kv_store_cb  *cb_info,
+                                     struct m0_be_cbinfo       *cb_info,
                                      struct m0_be_reference    *obj_ref,
                                      struct m0_be_tx           *tx);
 
@@ -448,7 +435,7 @@ M0_INTERNAL int32_t  m0_be_ks_insert(struct m0_be_kv_store     *handle,
   @return              :       object holding the @key or NULL if fails.
  */
 M0_INTERNAL void  *m0_be_ks_find(struct m0_be_kv_store     *handle,
-                                 struct m0_be_kv_store_cb  *cb_info,
+			     	 struct m0_be_cbinfo       *cb_info,
                                  void                      *key);
 
 /**
@@ -465,7 +452,7 @@ M0_INTERNAL void  *m0_be_ks_find(struct m0_be_kv_store     *handle,
   @retval BE_KV_SUCCESS :       in case of success.
  */
 M0_INTERNAL int32_t m0_be_ks_delete(struct m0_be_kv_store     *handle,
-                                    struct m0_be_kv_store_cb  *cb_info,
+			     	    struct m0_be_cbinfo       *cb_info,
                                     void                      *obj,
                                     struct m0_be_tx           *tx);
 
@@ -494,7 +481,7 @@ M0_INTERNAL int32_t m0_be_ks_delete(struct m0_be_kv_store     *handle,
  */
 M0_INTERNAL int32_t m0_be_ks_update(struct m0_be_kv_store     *handle,
                                     struct m0_be_tx           *tx,
-                                    struct m0_be_kv_store_cb  *cb_info,
+                                    struct m0_be_cbinfo	      *cb_info,
                                     void                      *obj,
                                     uint64_t                   sizeof_obj,
                                     kv_obj_update_t            obj_update);
diff --git a/be/ut/kv_store.c b/be/ut/kv_store.c
index d570e4d..0a05d25 100644
--- a/be/ut/kv_store.c
+++ b/be/ut/kv_store.c
@@ -94,7 +94,6 @@ struct m0_kv_store_obj     *ret_obj1[UT_UB_ITER]  = {NULL};
 struct m0_kv_store_obj     *ret_obj2[UT_UB_ITER]  = {NULL};
 struct m0_be_kv_store      *handle1               =  NULL;
 struct m0_be_kv_store      *handle2               =  NULL;
-struct m0_be_kv_store_cb   *cb_info;
 struct m0_be_ts_cbdata     *bt_cbdata;
 struct m0_sm_group         *sm_group;
 static const char          *stob_dir  = "/tmp/__be/o";
@@ -122,43 +121,43 @@ void increment_count_ast_cb(struct m0_sm_group *sm_group, struct m0_sm_ast *ast)
         count++;
 }
 
-/** Callback function to be called after operation completion. */
-void init_operation_callback(void *operation_name, void *result, int rc)
-{
-        struct m0_be_usr_astinfo *astinfo;
-        m0_free(operation_name);
-
-        M0_ALLOC_PTR(astinfo);
-        astinfo->bua_ast.sa_cb = increment_count_ast_cb;
-        be_usr_ast_post_helper(astinfo);
-}
-
-/** Callback function to be called after operation completion. */
-void fini_operation_callback(void *operation_name, void *result, int rc)
-{
-        m0_free(operation_name);
-}
-
-/** Callback function to be called after operation completion. */
-void insert_operation_callback(void *operation_name, void *result, int rc)
-{
-        M0_ASSERT(rc == 0);
-        m0_free(operation_name);
-}
-
-/** Callback function to be called after operation completion. */
-void find_operation_callback(void *operation_name, void *result, int rc)
-{
-        M0_ASSERT(rc == 0);
-        m0_free(operation_name);
-}
-
-/** Callback function to be called after operation completion. */
-void delete_operation_callback(void *operation_name, void *result, int rc)
-{
-        M0_ASSERT(rc == 0);
-        m0_free(operation_name);
-}
+/**//** Callback function to be called after operation completion. */
+/*void init_operation_callback(void *operation_name, void *result, int rc)*/
+/*{*/
+/*struct m0_be_usr_astinfo *astinfo;*/
+/*m0_free(operation_name);*/
+
+/*M0_ALLOC_PTR(astinfo);*/
+/*astinfo->bua_ast.sa_cb = increment_count_ast_cb;*/
+/*be_usr_ast_post_helper(astinfo);*/
+/*}*/
+
+/**//** Callback function to be called after operation completion. */
+/*void fini_operation_callback(void *operation_name, void *result, int rc)*/
+/*{*/
+/*m0_free(operation_name);*/
+/*}*/
+
+/**//** Callback function to be called after operation completion. */
+/*void insert_operation_callback(void *operation_name, void *result, int rc)*/
+/*{*/
+/*M0_ASSERT(rc == 0);*/
+/*m0_free(operation_name);*/
+/*}*/
+
+/**//** Callback function to be called after operation completion. */
+/*void find_operation_callback(void *operation_name, void *result, int rc)*/
+/*{*/
+/*M0_ASSERT(rc == 0);*/
+/*m0_free(operation_name);*/
+/*}*/
+
+/**//** Callback function to be called after operation completion. */
+/*void delete_operation_callback(void *operation_name, void *result, int rc)*/
+/*{*/
+/*M0_ASSERT(rc == 0);*/
+/*m0_free(operation_name);*/
+/*}*/
 
 /** Key compare routine. */
 int function_comp(void *in_obj1, void *in_obj2)
@@ -266,50 +265,57 @@ static int log_stob_create(void)
         return 0;
 }
 
+void be_kv_ts_cb(struct m0_be_cbinfo *cbinfo, int status,
+                 m0_be_msg_type_t msg_type)
+{
+        struct m0_be_ts_cbdata *cbdata;
+        M0_ASSERT(cbinfo != NULL);
+        cbdata = container_of(cbinfo, struct m0_be_ts_cbdata, cbinfo);
+
+        if (cbdata->be_usr_ast != NULL) {
+                cbdata->be_usr_ast->bua_status    = status;
+                cbdata->be_usr_ast->bua_msg       = msg_type;
+
+                be_usr_ast_post_helper(cbdata->be_usr_ast);
+        }
+}
+
 static void __init_kv_store1(struct m0_sm_group *sm_group,
                              struct m0_sm_ast   *ast)
 {
         struct m0_be_usr_astinfo   *astinfo;
+	struct m0_be_cbinfo	   *cbinfo;
         enum   m0_be_ks_init_mode  init_mode;
 
-        astinfo   = container_of(ast, struct m0_be_usr_astinfo, bua_ast);
+	printf("\n!@@@@@ in init_kv_store 1!!@@@@@\n");
+
+	cbinfo = &bt_cbdata->cbinfo;
+	cbinfo->bc_cb = be_kv_ts_cb;
+
+        astinfo    = container_of(ast, struct m0_be_usr_astinfo, bua_ast);
+	ast->sa_cb = increment_count_ast_cb;
         init_mode = astinfo->bua_ks_init_mode;
 
         /* Initialise the kv-store i.e. create on RVM */
-        m0_be_ks_init(handle1, cb_info, init_mode);
+        m0_be_ks_init(handle1, cbinfo, init_mode);
 }
 
 static void __init_kv_store2(enum m0_be_ks_init_mode init_mode)
 {
-        operation_name = (char *)malloc(10);
-        strcpy(operation_name, "KS_INIT");
-        cb_info->ksc_cb      = init_operation_callback;
-        cb_info->ksc_cbdata  = (void *)operation_name;
+	struct m0_be_cbinfo	*cbinfo;
 
-        m0_be_ks_init(handle2, cb_info, init_mode);
+	cbinfo = &bt_cbdata->cbinfo;
+	cbinfo->bc_cb = be_kv_ts_cb;
+
+        m0_be_ks_init(handle2, cbinfo, init_mode);
 
         M0_LOG(M0_INFO, "kv_store initialised!");
-        m0_free(cb_info);
 
         M0_ASSERT(handle1->ks_handle_rvm != NULL);
         M0_ASSERT(handle2->ks_handle_rvm != NULL);
 }
 
 
-void be_kv_ts_cb(struct m0_be_cbinfo *cbinfo, int status,
-                 m0_be_msg_type_t msg_type)
-{
-        struct m0_be_ts_cbdata *cbdata;
-        M0_ASSERT(cbinfo != NULL);
-        cbdata = container_of(cbinfo, struct m0_be_ts_cbdata, cbinfo);
-
-        if (cbdata->be_usr_ast != NULL) {
-                cbdata->be_usr_ast->bua_status    = status;
-                cbdata->be_usr_ast->bua_msg       = msg_type;
-
-                be_usr_ast_post_helper(cbdata->be_usr_ast);
-        }
-}
 
 static void __set_bt_cbdata()
 {
@@ -340,26 +346,27 @@ static void __initialise_handle1(enum m0_be_ks_init_mode init_mode)
 
         M0_ALLOC_PTR(bt_cbdata);
 
-        /* Initialise the kv store. */
-        m0_be_ks_init_domain(&kv_dom, NULL, log_stob);
+        M0_ALLOC_PTR(kv_dom);
         M0_ASSERT(kv_dom != NULL);
 
-        /* Create a kv-store handle */
-        m0_be_ks_create(&kv_list_descr1, kv_dom,
-                        cmp_routine, match_routine, 0, &handle1);
-        M0_ASSERT(handle1 != NULL);
+	m0_be_domain_create(kv_dom, NULL, log_stob);
 
-        sm_group = m0_be_domain_sm_group(kv_dom);
+	sm_group = m0_be_domain_sm_group(kv_dom);
+	M0_ASSERT(sm_group != NULL);
 
-        /* Set the callback information for ks_init*/
-        M0_ALLOC_PTR(cb_info);
-        M0_ASSERT(cb_info != NULL);
+	__set_bt_cbdata();
+        bt_cbdata->be_usr_ast->bua_ast.sa_cb = increment_count_ast_cb;
 
-        operation_name = (char *)malloc(10);
-        strcpy(operation_name, "KS_INIT");
+        m0_be_domain_init(kv_dom, &bt_cbdata->cbinfo);
+        /* Wait for domain_init completion. */
+        wait_and_lock_usr_sm_group();
+	printf("\n\n$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$DOM INIT\nnnnnnn");
 
-        cb_info->ksc_cb      = init_operation_callback;
-        cb_info->ksc_cbdata  = (void *)operation_name;
+	/* Create and init kvstore handle1. */
+        /* Create a kv-store handle */
+        m0_be_ks_create(&kv_list_descr1, kv_dom,
+                        cmp_routine, match_routine, 0, &handle1);
+        M0_ASSERT(handle1 != NULL);
 
         /* Create a new segment, and also the callback information needed */
         /* @todo: segment name is hardcoded for now */
@@ -370,7 +377,7 @@ static void __initialise_handle1(enum m0_be_ks_init_mode init_mode)
          * Set the callback information to be called after segment
          * creation/open completes.
          */
-        __set_bt_cbdata();
+	/*__set_bt_cbdata();*/
         bt_cbdata->be_usr_ast->bua_ks_init_mode = init_mode;
         bt_cbdata->be_usr_ast->bua_ast.sa_cb    = __init_kv_store1;
 
@@ -386,11 +393,14 @@ static void __initialise_handle1(enum m0_be_ks_init_mode init_mode)
         /* Wait for segment create completion. */
         wait_and_lock_usr_sm_group();
 
+	printf("\n\n######################segment created. ##########\n");
+
         /*
          * Wait for ks_init for handle1 to be completed,
          * called after seg_create_cb completion.
          */
         wait_and_lock_usr_sm_group();
+	printf("%%%%%%%%%%%%%%%%%%%%intitialised 1%%%%%%%%%%%%\n");
 }
 
 static int ts_kv_store_init()
@@ -434,31 +444,36 @@ static int ts_kv_store_init()
 
 void ts_kv_store_fini()
 {
-        /* Set the callback information */
-        M0_ALLOC_PTR(cb_info);
-        M0_ASSERT(cb_info != NULL);
+	/**//* Set the callback information */
+	/*M0_ALLOC_PTR(cb_info);*/
+	/*M0_ASSERT(cb_info != NULL);*/
 
-        operation_name = (char *)malloc(10);
-        strcpy(operation_name, "KS_FINI");
-        cb_info->ksc_cbdata     = (void *)operation_name;
-        cb_info->ksc_cb         = fini_operation_callback;
+	/*operation_name = (char *)malloc(10);*/
+	/*strcpy(operation_name, "KS_FINI");*/
+	/*cb_info->ksc_cbdata     = (void *)operation_name;*/
+	/*cb_info->ksc_cb         = fini_operation_callback;*/
+
+	__set_bt_cbdata();
+        bt_cbdata->be_usr_ast->bua_ast.sa_cb = increment_count_ast_cb;
 
-        m0_be_ks_fini(handle1, cb_info);
+        m0_be_ks_fini(handle1, NULL);
 
-        operation_name = (char *)malloc(10);
-        strcpy(operation_name, "KS_FINI");
-        cb_info->ksc_cbdata     = (void *)operation_name;
-        cb_info->ksc_cb         = fini_operation_callback;
+	/*operation_name = (char *)malloc(10);*/
+	/*strcpy(operation_name, "KS_FINI");*/
+	/*cb_info->ksc_cbdata     = (void *)operation_name;*/
+	/*cb_info->ksc_cb         = fini_operation_callback;*/
 
-        m0_be_ks_fini(handle2, cb_info);
+        m0_be_ks_fini(handle2, NULL);
 
-        m0_be_seg_done(kv_seg, NULL);
+        m0_be_seg_done(kv_seg, &bt_cbdata->cbinfo);
+	wait_and_lock_usr_sm_group();
 
         m0_be_domain_fini(kv_dom);
         m0_free(kv_dom);
         kv_dom  = NULL;
         handle1 = handle2 = NULL;
-        m0_free(cb_info);
+
+        m0_free(bt_cbdata->be_usr_ast);
         m0_free(bt_cbdata);
 }
 
@@ -509,18 +524,8 @@ static int insert(struct m0_be_kv_store   *handle,
         object->key     = key;
         object->obj_val = val;
 
-        /* Set the callback information */
-        M0_ALLOC_PTR(cb_info);
-        M0_ASSERT(cb_info != NULL);
-
-        operation_name = (char *)malloc(10);
-        strcpy(operation_name, "KS_INSERT");
-
-        cb_info->ksc_cbdata     = (void *)operation_name;
-        cb_info->ksc_cb         = insert_operation_callback;
-
         /* Insert this into the kv_store */
-        status = m0_be_ks_insert(handle, cb_info, obj_ref, tx);
+        status = m0_be_ks_insert(handle, NULL, obj_ref, tx);
         if (status != 0)
                 goto exit;
 
@@ -535,7 +540,6 @@ static int insert(struct m0_be_kv_store   *handle,
         m0_free(tx);
         m0_free(obj_reg);
         m0_free(obj_buf);
-        m0_free(cb_info);
         m0_free(bt_cbdata->be_usr_ast);
         *out_object = object;
 exit:
@@ -547,18 +551,7 @@ static struct m0_kv_store_obj *find(struct m0_be_kv_store *handle,
 {
         void                      *ret_val;
 
-        /* Set the callback information */
-        M0_ALLOC_PTR(cb_info);
-        M0_ASSERT(cb_info != NULL);
-
-        operation_name = (char *)malloc(10);
-        strcpy(operation_name, "KS_FIND");
-
-        cb_info->ksc_cbdata     = (void *)operation_name;
-        cb_info->ksc_cb         = find_operation_callback;
-
-        ret_val = m0_be_ks_find(handle, cb_info, key);
-        m0_free(cb_info);
+        ret_val = m0_be_ks_find(handle, NULL, key);
 
         return ret_val;
 }
@@ -593,18 +586,8 @@ static int delete(struct m0_be_kv_store *handle, struct m0_kv_store_obj *target)
         m0_be_tx_prep(tx);
         m0_be_tx_start(tx);
 
-        /* Set the callback information */
-        M0_ALLOC_PTR(cb_info);
-        M0_ASSERT(cb_info != NULL);
-
-        operation_name = (char *)malloc(10);
-        strcpy(operation_name, "KS_DELETE");
-
-        cb_info->ksc_cbdata     = (void *)operation_name;
-        cb_info->ksc_cb         = delete_operation_callback;
-
-        /* Delete this obj from kv store */
-        ret_val = m0_be_ks_delete(handle, cb_info, (void *)target, tx);
+	/* Delete this obj from kv store */
+        ret_val = m0_be_ks_delete(handle, NULL, (void *)target, tx);
         m0_be_free_helper(kv_dom, tx, target, sizeof *target);
 
         /* set cbinfo for tx_done. */
@@ -618,7 +601,6 @@ static int delete(struct m0_be_kv_store *handle, struct m0_kv_store_obj *target)
         m0_free(tx);
         m0_free(obj_reg);
         m0_free(obj_buf);
-        m0_free(cb_info);
         m0_free(bt_cbdata->be_usr_ast);
         /*m0_free(bt_cbdata);*/
         return ret_val;
@@ -630,7 +612,13 @@ void test_kv_store()
         long int i;
         int32_t  status;
 
-        M0_ASSERT(count == 2);
+	/*
+	 * Count was incremented by :
+	 * 1. m0_be_domain_init.
+	 * 2. __init_kv_store1
+	 * 3. __init_kv_store2
+	 */
+	M0_ASSERT(count == 3);
         count = 0;
 
         /*
@@ -734,6 +722,7 @@ void test_recover_and_delete()
                                  &handle2->ks_handle_rvm->ksr_tlist);
         M0_ASSERT(length == 0);
 
+	printf("\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! callinf fini in recovery!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
         ts_kv_store_fini();
 
         sprintf(kv_cmd, "rm -rf %s", stob_dir);
@@ -957,6 +946,11 @@ static void ub_fini()
         size_t  length;
         int     rc;
 
+	printf("\n\n^^^^^^^^^^^^^^^^^^^^^^^^in ub_fini^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n");
+	__set_bt_cbdata();
+        bt_cbdata->be_usr_ast->bua_ast.sa_cb = increment_count_ast_cb;
+
+
         /* To ensure that deletion was successful */
         length = m0_tlist_length(&kv_list_descr1,
                                  &handle1->ks_handle_rvm->ksr_tlist);
@@ -965,7 +959,8 @@ static void ub_fini()
         sm_group = m0_be_domain_sm_group(kv_dom);
 
         m0_be_ks_fini(handle1, NULL);
-        m0_be_seg_done(kv_seg, NULL);
+        m0_be_seg_done(kv_seg, &bt_cbdata->cbinfo);
+	wait_and_lock_usr_sm_group();
         m0_be_domain_fini(kv_dom);
         m0_stob_domain_fini(stob_dom);
 
diff --git a/cob/cob.c b/cob/cob.c
index 72f9b30..a610ddf 100644
--- a/cob/cob.c
+++ b/cob/cob.c
@@ -457,11 +457,42 @@ static char *cob_dom_id_make(char *buf, const struct m0_cob_domain_id *id,
 }
 
 #ifndef __KERNEL__
+
+void cob_ns_kv_store_init(struct m0_be_cbinfo *cbinfo, int status,
+                          m0_be_msg_type_t     msg)
+{
+        struct m0_cob_be_cbinfo  *cob_cbinfo;
+        struct m0_sm_ast         *ast;
+        struct m0_sm_group       *post_sm_group;
+
+        M0_ASSERT(cbinfo != NULL);
+        cob_cbinfo    = container_of(cbinfo, struct m0_cob_be_cbinfo,
+                                     cbc_cbinfo);
+
+        if (msg == M0_BE_SUCCESS) {
+                ast           = &cob_cbinfo->cbc_ast;
+                post_sm_group = cob_cbinfo->cbc_sm_group;
+
+                m0_sm_group_lock(cbinfo->bc_sm_group);
+                m0_sm_ast_post(post_sm_group, ast);
+                m0_sm_group_unlock(cbinfo->bc_sm_group);
+        }
+}
+
+static void __kv_operation_ast_cb(struct m0_sm_group *sm_group,
+                                       struct m0_sm_ast   *ast)
+{
+        M0_LOG(M0_INFO, "cob-nsrec kv-store init");
+}
+
 static void __kv_store_init_helper(struct m0_be_kv_store    **handle,
                                    struct m0_stob            *log_stob,
                                    int32_t                    handle_index,
                                    enum   m0_be_ks_init_mode  init_mode)
 {
+	struct m0_cob_be_cbinfo *cob_cbinfo;
+	struct m0_be_cbinfo	*be_cbinfo;
+	struct m0_sm_group	*sm_group;
         const  char             *stob_dir;
         const  char             *stob_file;
         char                     kv_cmd[1024];
@@ -484,19 +515,33 @@ static void __kv_store_init_helper(struct m0_be_kv_store    **handle,
         cmp_routine     = m0_cob_kv_ns_cmp;
         match_routine   = m0_cob_kv_ns_match;
 
-        m0_be_ks_init_domain(&cob_be_domain, NULL, log_stob);
-        M0_ASSERT(&cob_be_domain != NULL);
+        M0_ALLOC_PTR(cob_be_domain);
+        M0_ASSERT(cob_be_domain != NULL);
+
+	m0_be_domain_create(cob_be_domain, NULL, log_stob);
+	sm_group = m0_be_domain_sm_group(cob_be_domain);
+
+	M0_ALLOC_PTR(cob_cbinfo);
+	M0_ASSERT(cob_cbinfo != NULL);
+
+	be_cbinfo               = &cob_cbinfo->cbc_cbinfo;
+        be_cbinfo->bc_hq        = &cob_be_domain->bd_hq;
+        be_cbinfo->bc_cb        = cob_ns_kv_store_init;
+        be_cbinfo->bc_sm_group  = sm_group;
+        be_cbinfo->bc_pcbinfo   = NULL;
+
+	cob_cbinfo->cbc_sm_group     = &cob_sm_group;
+        cob_cbinfo->cbc_ast.sa_cb    = __kv_operation_ast_cb;
+        cob_cbinfo->cbc_ast.sa_datum = (void *)cob_be_domain;
+
+        m0_be_domain_init(cob_be_domain, be_cbinfo);
+	__cob_wait_and_lock_sm_group(&cob_sm_group);
 
         /* Create a kv-store handle */
         m0_be_ks_create(&cob_ns_list_descr, cob_be_domain,
                         cmp_routine, match_routine, handle_index, handle);
         M0_ASSERT(*handle != NULL);
-}
-
-static void __kv_init_operation_ast_cb(struct m0_sm_group *sm_group,
-                                       struct m0_sm_ast   *ast)
-{
-        M0_LOG(M0_INFO, "cob-nsrec kv-store init");
+	m0_free(cob_cbinfo);
 }
 
 void cob_nsrec_kv_init_operation_cb(void *cbdata, void *result, int rc)
@@ -523,50 +568,24 @@ void cob_nsrec_kv_init_operation_cb(void *cbdata, void *result, int rc)
 void __ast_init_kv_store(struct m0_sm_group *sm_group, struct m0_sm_ast *ast)
 {
         struct m0_be_kv_store     *handle;
-        struct m0_be_kv_store_cb  *kv_cbinfo;
         struct m0_cob_be_cbinfo   *cob_cbinfo;
+	struct m0_be_cbinfo	  *be_cbinfo;
         enum   m0_be_ks_init_mode  init_mode;
 
         cob_cbinfo = container_of(ast, struct m0_cob_be_cbinfo, cbc_ast);
         handle     = cob_cbinfo->cbc_ks_handle;
         M0_ASSERT(handle != NULL);
-        init_mode  = cob_cbinfo->cbc_ks_init_mode;
+        init_mode  =  cob_cbinfo->cbc_ks_init_mode;
+	be_cbinfo  = &cob_cbinfo->cbc_cbinfo;
 
         /*
          * Set ast call back to be called after ks_init operation operation
          * completes.
          */
-        cob_cbinfo->cbc_ast.sa_cb = __kv_init_operation_ast_cb;
-
-        M0_ALLOC_PTR(kv_cbinfo);
-        M0_ASSERT(kv_cbinfo != NULL);
-
-        kv_cbinfo->ksc_cb      = cob_nsrec_kv_init_operation_cb;
-        kv_cbinfo->ksc_cbdata  = (void *)cob_cbinfo;
+        cob_cbinfo->cbc_ast.sa_cb = __kv_operation_ast_cb;
 
         /* Initialise kv_store. */
-        m0_be_ks_init(handle, kv_cbinfo, init_mode);
-}
-
-void cob_ns_kv_store_init(struct m0_be_cbinfo *cbinfo, int status,
-                          m0_be_msg_type_t     msg)
-{
-        struct m0_cob_be_cbinfo  *cob_cbinfo;
-        struct m0_sm_ast         *ast;
-        struct m0_sm_group       *post_sm_group;
-
-        M0_ASSERT(cbinfo != NULL);
-        cob_cbinfo    = container_of(cbinfo, struct m0_cob_be_cbinfo,
-                                     cbc_cbinfo);
-
-        if (msg == M0_BE_SUCCESS) {
-                ast           = &cob_cbinfo->cbc_ast;
-                post_sm_group = cob_cbinfo->cbc_sm_group;
-
-                m0_sm_group_lock(cbinfo->bc_sm_group);
-                m0_sm_ast_post(post_sm_group, ast);
-                m0_sm_group_unlock(cbinfo->bc_sm_group);
-        }
+        m0_be_ks_init(handle, be_cbinfo, init_mode);
 }
 
 static void __cob_set_seg_cbinfo(struct m0_cob_be_cbinfo    *cob_cbinfo,
@@ -615,6 +634,7 @@ int m0_cob_domain_init_nsrec_recovery(struct m0_cob_domain          *dom,
 
         if (cob_be_domain == NULL) {
                 handle_index = dom->cd_kvnamespace_index_in_static_reg;
+                m0_sm_group_init(&cob_sm_group);
                 __kv_store_init_helper(&dom->cd_kvnamespace,
                                        dom->cd_kv_log_stob, handle_index,
                                        M0_BE_KS_RECOVER);
@@ -622,7 +642,6 @@ int m0_cob_domain_init_nsrec_recovery(struct m0_cob_domain          *dom,
                  * Set the callback info to be called after segment
                  * creation operation.
                  */
-                m0_sm_group_init(&cob_sm_group);
                 sm_group = m0_be_domain_sm_group(cob_be_domain);
                 M0_ALLOC_PTR(cob_cbinfo);
                 M0_ASSERT(cob_cbinfo != NULL);
@@ -640,6 +659,7 @@ int m0_cob_domain_init_nsrec_recovery(struct m0_cob_domain          *dom,
 
                 /* Wait for handle initialisation. */
                 __cob_wait_and_lock_sm_group(&cob_sm_group);
+		m0_free(cob_cbinfo);
         }
 
         return m0_cob_domain_init(dom, env, id);
@@ -675,6 +695,7 @@ int m0_cob_domain_init(struct m0_cob_domain *dom, struct m0_dbenv *env,
         handle_index = dom->cd_kvnamespace_index_in_static_reg;
 
         if (cob_be_domain == NULL) {
+                m0_sm_group_init(&cob_sm_group);
                 __kv_store_init_helper(&dom->cd_kvnamespace,
                                        dom->cd_kv_log_stob, handle_index,
                                        M0_BE_KS_CREATE);
@@ -683,8 +704,9 @@ int m0_cob_domain_init(struct m0_cob_domain *dom, struct m0_dbenv *env,
                  * Set the callback info to be called after segment
                  * creation operation.
                  */
-                m0_sm_group_init(&cob_sm_group);
+
                 sm_group = m0_be_domain_sm_group(cob_be_domain);
+
                 M0_ALLOC_PTR(cob_cbinfo);
                 M0_ASSERT(cob_cbinfo != NULL);
                 __cob_set_seg_cbinfo(cob_cbinfo, dom->cd_kvnamespace, sm_group,
@@ -745,21 +767,40 @@ int m0_cob_domain_init(struct m0_cob_domain *dom, struct m0_dbenv *env,
 void m0_cob_domain_fini(struct m0_cob_domain *dom)
 {
 #ifndef __KERNEL__
+	printf("\n**********************************COB DOMAIN FINI*************************\n");
         /* Fini kv_store for nsrec. Finis cob_be_domain as well*/
-        struct m0_be_seg *kv_seg;
-        bool              ret_dom;
+        struct m0_be_seg	*kv_seg;
+	struct m0_cob_be_cbinfo	*cob_cbinfo;
+	struct m0_be_cbinfo 	*be_cbinfo;
+	struct m0_sm_group	*sm_group;
+        bool			 ret_dom;
 
         m0_be_ks_fini(dom->cd_kvnamespace, NULL);
 
         ret_dom = m0_be_domain_lookup(cob_be_domain, BE_KV_SEG_NAME, &kv_seg);
         M0_ASSERT(ret_dom);
         M0_ASSERT(kv_seg != NULL);
-        m0_be_seg_done(kv_seg, NULL);
+
+	sm_group = m0_be_domain_sm_group(cob_be_domain);
+	M0_ALLOC_PTR(cob_cbinfo);
+	M0_ASSERT(cob_cbinfo != NULL);
+	be_cbinfo               = &cob_cbinfo->cbc_cbinfo;
+        be_cbinfo->bc_hq        = &cob_be_domain->bd_hq;
+        be_cbinfo->bc_cb        = cob_ns_kv_store_init;
+        be_cbinfo->bc_sm_group  = sm_group;
+        be_cbinfo->bc_pcbinfo   = NULL;
+
+	cob_cbinfo->cbc_sm_group     = &cob_sm_group;
+        cob_cbinfo->cbc_ast.sa_cb    = __kv_operation_ast_cb;
+        cob_cbinfo->cbc_ast.sa_datum = (void *)cob_be_domain;
+
+        m0_be_seg_done(kv_seg, be_cbinfo);
+	__cob_wait_and_lock_sm_group(&cob_sm_group);
 
         m0_be_domain_fini(cob_be_domain);
         m0_free(cob_be_domain);
         cob_be_domain = NULL;
-
+	m0_free(cob_cbinfo);
 #endif
 
         m0_table_fini(&dom->cd_fileattr_omg);
diff --git a/cob/ut/cob.c b/cob/ut/cob.c
index 52c27a3..729c2bd 100644
--- a/cob/ut/cob.c
+++ b/cob/ut/cob.c
@@ -50,6 +50,7 @@ int32_t                            handle_index;
 
 /* defined in cob/cob.c */
 extern struct m0_be_domain  *cob_be_domain;
+static struct m0_sm_group    cob_sm_group;
 
 static int log_stob_create(void)
 {
@@ -101,6 +102,36 @@ static int log_stob_create(void)
         return 0;
 }
 
+static void __cob_be_tx_done_ast_cb(struct m0_sm_group *sm_group,
+                                    struct m0_sm_ast   *ast)
+{
+        struct m0_be_tx *tx;
+
+        tx = (struct m0_be_tx *)ast->sa_datum;
+        m0_be_tx_fini(tx);
+        m0_free(tx);
+}
+
+/** Called by m0_be_tx_done_cb at the very end of tx done termination. */
+static void __cob_be_tx_done_cb(struct m0_be_cbinfo *cbinfo, int status,
+                                m0_be_msg_type_t     msg_type)
+{
+        struct m0_cob_be_cbinfo  *cob_cbinfo;
+        struct m0_sm_ast         *ast;
+        struct m0_sm_group       *post_sm_group;
+
+        cob_cbinfo = container_of(cbinfo, struct m0_cob_be_cbinfo, cbc_cbinfo);
+
+        ast           = &cob_cbinfo->cbc_ast;
+        post_sm_group = cob_cbinfo->cbc_sm_group;
+
+        m0_sm_group_lock(cbinfo->bc_sm_group);
+        m0_sm_ast_post(post_sm_group, ast);
+        m0_sm_group_unlock(cbinfo->bc_sm_group);
+        m0_free(cob_cbinfo);
+}
+
+
 static int stob_create()
 {
         sprintf(kv_cmd, "mkdir -p %s", stob_dir);
@@ -159,6 +190,7 @@ static void test_mkfs(void)
 
 static void test_init(void)
 {
+	m0_sm_group_init(&cob_sm_group);
         rc = m0_dbenv_init(&db, db_name, 0);
         /*test_init is called by ub_init which hates M0_UT_ASSERT*/
         M0_ASSERT(rc == 0);
@@ -214,6 +246,8 @@ static void test_create(void)
         struct m0_cob_nsrec       *nsrec;
         struct m0_cob_nsrec       *updated_nsrec;
         struct m0_sm_group        *sm_group;
+	struct m0_cob_be_cbinfo	  *cob_cbinfo;
+        struct m0_be_cbinfo 	  *be_cbinfo;
 
         M0_SET0(&omgrec);
 
@@ -268,7 +302,20 @@ static void test_create(void)
         updated_nsrec->cnr_nlink = 1;
 
         sm_group = m0_be_domain_sm_group(cob_be_domain);
-        m0_be_tx_done(be_tx, NULL);
+
+	M0_ALLOC_PTR(cob_cbinfo);
+
+        be_cbinfo               = &cob_cbinfo->cbc_cbinfo;
+        be_cbinfo->bc_hq        = &cob_be_domain->bd_hq;
+        be_cbinfo->bc_cb        =  __cob_be_tx_done_cb;
+        be_cbinfo->bc_sm_group  =  sm_group;
+        be_cbinfo->bc_pcbinfo   =  NULL;
+
+        cob_cbinfo->cbc_sm_group     = &cob_sm_group;
+        cob_cbinfo->cbc_ast.sa_cb    = __cob_be_tx_done_ast_cb;
+        cob_cbinfo->cbc_ast.sa_datum = (void *)be_tx;
+
+        m0_be_tx_done(be_tx, be_cbinfo);
         m0_be_wait(sm_group, &be_tx->bt_sm, M0_BITS(M0_BETX_DONE,
                                                     M0_BETX_FAILED));
         m0_be_tx_fini(be_tx);
diff --git a/rvm/rvm.h b/rvm/rvm.h
index 83d2ab3..1255dc2 100644
--- a/rvm/rvm.h
+++ b/rvm/rvm.h
@@ -413,6 +413,11 @@ typedef struct rvm_seg_hdr
 /*
         Main Function Declarations
 */
+
+/* initialization, query, and structure checkers */
+
+extern rvm_bool_t bad_init();                  /* [rvm_init.c] */
+
 /* RVM initialization: pass version and optional options
    descriptor */
 
diff --git a/rvm/rvm_init.c b/rvm/rvm_init.c
index 97af6ba..75c5805 100644
--- a/rvm/rvm_init.c
+++ b/rvm/rvm_init.c
@@ -187,8 +187,8 @@ rvm_return_t rvm_initialize(const char *rvm_version, rvm_options_t *rvm_options,
 
 exit:
         if ((status != 0 || !rvm_options->create_log_file) &&
-            cbinfo->bc_pcbinfo != NULL && cbinfo->bc_pcbinfo->bc_cb != NULL) {
-                m0_be_handler_post(cbinfo->bc_pcbinfo, status, msg_type);
+            cbinfo != NULL && cbinfo->bc_cb != NULL) {
+                m0_be_handler_post(cbinfo, status, msg_type);
                 m0_free(ri_cbdata);
         }
         return status;
diff --git a/rvm/rvm_logflush.c b/rvm/rvm_logflush.c
index 95fefae..eb8ed35 100644
--- a/rvm/rvm_logflush.c
+++ b/rvm/rvm_logflush.c
@@ -1162,7 +1162,8 @@ exit:
 	/* If special is NULL or some error occured post parent. */
 	if ((be_status != 0 || special == NULL) && cbinfo->bc_pcbinfo != NULL &&
 	    cbinfo->bc_pcbinfo->bc_cb != NULL) {
-		m0_be_handler_post(cbinfo->bc_pcbinfo, be_status, msg);
+		/*m0_be_handler_post(cbinfo->bc_pcbinfo, be_status, msg);*/
+		m0_be_handler_post(cbinfo, be_status, msg);
 		m0_free(lfs_cbdata);
 	}
 	return retval;
diff --git a/rvm/rvm_private.h b/rvm/rvm_private.h
index 69c2048..2e5f41d 100644
--- a/rvm/rvm_private.h
+++ b/rvm/rvm_private.h
@@ -1654,9 +1654,6 @@ tree_node_t *tree_predecessor();        /* [rvm_utils.c] */
 /*  tree_root_t     *tree;
     rvm_bool_t      direction;
 */
-/* initialization, query, and structure checkers */
-
-extern rvm_bool_t bad_init();                  /* [rvm_init.c] */
 
 /* [rvm_status.c] */
 rvm_return_t bad_options(rvm_options_t *rvm_options, rvm_bool_t chk_log_dev);
-- 
1.8.3.2

