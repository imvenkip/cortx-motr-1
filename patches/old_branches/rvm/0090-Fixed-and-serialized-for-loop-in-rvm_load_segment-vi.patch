From 5d1ec239640aa83915089a3b8e05e86d675de17c Mon Sep 17 00:00:00 2001
From: Zishan Shaikh <zishan_shaikh@xyratex.com>
Date: Tue, 14 May 2013 07:37:43 -0700
Subject: [PATCH 090/121] Fixed and serialized for loop in rvm_load_segment via
 async mechanism

---
 rvm/rvm_loadseg.c         | 144 ++++++++++++++++++++++++++++++++++------------
 rvm/rvm_segment_private.h |   3 +
 2 files changed, 109 insertions(+), 38 deletions(-)

diff --git a/rvm/rvm_loadseg.c b/rvm/rvm_loadseg.c
index 40b9d99..f37b6ad 100644
--- a/rvm/rvm_loadseg.c
+++ b/rvm/rvm_loadseg.c
@@ -88,6 +88,91 @@ exit:
         m0_free(rls_cbdata);
 }
 
+void __rls_rvm_map(cbinfo, status, msg)
+        struct m0_be_cbinfo *cbinfo;
+        int                  status;
+        m0_be_msg_type_t     msg;
+{
+        rls_cbdata_t            *rls_cbdata;
+        rvm_seg_hdr_t           *seg_hdr;
+        rvm_segment_hdr_t       *hdrp;
+        rvm_region_t            *region;
+        rvm_options_t           *options;
+        rvm_region_def_t       **regions;
+        unsigned long            cur_index;
+        unsigned long            iter;
+        int                      err;
+
+        if (status != 0)
+                goto exit;
+
+        rls_cbdata = container_of(cbinfo, rls_cbdata_t, rlsc_cbinfo);
+        iter       = rls_cbdata->rlsc_rvmmap_itr;
+        cur_index  = rls_cbdata->rlsc_rvmmap_curr_index;
+
+        /* All regions have been rvm_mapped. */
+        if (iter == 0) {
+                rls_loop_rvm_map_cb(cbinfo, status, msg);
+                return;
+        }
+
+        seg_hdr = rls_cbdata->rlsc_seg_hdr;
+        region  = rls_cbdata->rlsc_region;
+        options = rls_cbdata->rlsc_options;
+        regions = rls_cbdata->rlsc_regions_defs;
+        hdrp    = rls_cbdata->rlsc_hdrp;
+
+        if ((unsigned long)(hdrp->regions[cur_index].vmaddr) >= 0) {
+                (*regions)[cur_index].offset = hdrp->regions[cur_index].offset;
+                (*regions)[cur_index].length = hdrp->regions[cur_index].length;
+                (*regions)[cur_index].vmaddr = hdrp->regions[cur_index].vmaddr;
+
+                region->offset       = (*regions)[cur_index].offset;
+                region->length       = (*regions)[cur_index].length;
+                region->vmaddr       = (*regions)[cur_index].vmaddr;
+
+                /* HACK */ rds_rvmsize += region->length; /* HACK */
+
+                if (!rvm_map_private) {
+                        err = allocate_vm(seg_hdr, &(region->vmaddr),
+                                          region->length);
+                        if (err != RVM_SUCCESS) {
+                                status = -1;
+                                msg    = (m0_be_msg_type_t)err;
+                                goto exit;
+                        }
+                } else
+                        if (!rvm_register_page(seg_hdr, region->vmaddr,
+                                               region->length)) {
+                                status = -1;
+                                msg    = RVM_EINTERNAL;
+                                goto exit;
+                        }
+        }
+
+        iter                              -= 1;
+        cur_index                         += 1;
+        rls_cbdata->rlsc_rvmmap_curr_index = cur_index;
+        rls_cbdata->rlsc_rvmmap_itr        = iter;
+        cbinfo->bc_cb                      = __rls_rvm_map;
+
+        if (iter == 0) {
+                cbinfo->bc_cb = rls_loop_rvm_map_cb;
+        }
+
+        err = rvm_map(seg_hdr, region, options, cbinfo);
+        if (err != RVM_SUCCESS) {
+                status = -1;
+                msg    = (m0_be_msg_type_t)err;
+        }
+
+exit:
+        if (status != 0 && cbinfo->bc_pcbinfo != NULL &&
+            cbinfo->bc_pcbinfo->bc_cb != NULL) {
+                m0_be_handler_post(cbinfo->bc_pcbinfo, status, msg);
+        }
+}
+
 void rls_rvm_map_cb(cbinfo, status, msg)
         struct m0_be_cbinfo *cbinfo;
         int                  status;
@@ -100,9 +185,7 @@ void rls_rvm_map_cb(cbinfo, status, msg)
         rvm_region_t            *region;
         rvm_length_t            *nregions;
         rvm_options_t           *options;
-        struct m0_be_cbinfo     *rvm_map_cbinfo;
         rvm_region_def_t       **regions;
-        int                      i;
         int                      err;
 
         rls_cbdata = container_of(cbinfo, rls_cbdata_t, rlsc_cbinfo);
@@ -143,33 +226,15 @@ void rls_rvm_map_cb(cbinfo, status, msg)
 
         /* HACK */ rds_startaddr = hdrp->regions[0].vmaddr; /* HACK */
 
-        for (i = 0; i < hdrp->nregions; i++)
-                if ((unsigned long)(hdrp->regions[i].vmaddr) >= 0) {
-		if (i != hdrp->nregions-1) {
-			M0_ALLOC_PTR(rvm_map_cbinfo);
-			if (rvm_map_cbinfo == NULL) {
-				status = -1;
-				msg    = -ENOMEM;
-				goto exit;
-			}
-			rvm_map_cbinfo->bc_sm_group = cbinfo->bc_sm_group;
-			rvm_map_cbinfo->bc_hq       = cbinfo->bc_hq;
-			rvm_map_cbinfo->bc_cb       = NULL;
-			rvm_map_cbinfo->bc_pcbinfo  = NULL;
-
-		}
-		else {
-			rvm_map_cbinfo = cbinfo;
-			rvm_map_cbinfo->bc_cb = rls_loop_rvm_map_cb;
-		}
-
-                        (*regions)[i].offset = hdrp->regions[i].offset;
-                        (*regions)[i].length = hdrp->regions[i].length;
-                        (*regions)[i].vmaddr = hdrp->regions[i].vmaddr;
-
-                        region->offset       = (*regions)[i].offset;
-                        region->length       = (*regions)[i].length;
-                        region->vmaddr       = (*regions)[i].vmaddr;
+        if (hdrp->nregions > 0)
+                if ((unsigned long)(hdrp->regions[0].vmaddr) >= 0) {
+                        (*regions)[0].offset = hdrp->regions[0].offset;
+                        (*regions)[0].length = hdrp->regions[0].length;
+                        (*regions)[0].vmaddr = hdrp->regions[0].vmaddr;
+
+                        region->offset       = (*regions)[0].offset;
+                        region->length       = (*regions)[0].length;
+                        region->vmaddr       = (*regions)[0].vmaddr;
 
                         /* HACK */ rds_rvmsize += region->length; /* HACK */
 
@@ -188,15 +253,19 @@ void rls_rvm_map_cb(cbinfo, status, msg)
                                         msg    = RVM_EINTERNAL;
                                         goto exit;
                                 }
-
-                        /* Pass rvm_map_cbinfo as param to rvm_map. */
-                        err = rvm_map(seg_hdr, region, options, rvm_map_cbinfo);
-                        if (err != RVM_SUCCESS) {
-                                status = -1;
-                                msg    = (m0_be_msg_type_t)err;
-                                goto exit;
-                        }
                 }
+
+        /* One iteration has been completed. */
+        rls_cbdata->rlsc_hdrp              = hdrp;
+        rls_cbdata->rlsc_rvmmap_itr        = hdrp->nregions - 1;
+        rls_cbdata->rlsc_rvmmap_curr_index = 1;
+        cbinfo->bc_cb                      = __rls_rvm_map;
+
+        err = rvm_map(seg_hdr, region, options, cbinfo);
+        if (err != RVM_SUCCESS) {
+                status = -1;
+                msg    = (m0_be_msg_type_t)err;
+        }
 exit:
         if (status != 0 && cbinfo->bc_pcbinfo != NULL &&
             cbinfo->bc_pcbinfo->bc_cb != NULL) {
@@ -204,7 +273,6 @@ exit:
         }
 }
 
-
 /*
  * rvm_load_segment
  * - locates the place in the process's address where to load segments
diff --git a/rvm/rvm_segment_private.h b/rvm/rvm_segment_private.h
index bbd8794..ce19f5b 100644
--- a/rvm/rvm_segment_private.h
+++ b/rvm/rvm_segment_private.h
@@ -69,7 +69,10 @@ typedef struct rvm_create_segment_cbdata {
 
 typedef struct rvm_load_segment_cbdata {
         struct m0_be_cbinfo      rlsc_cbinfo;
+        rvm_length_t             rlsc_rvmmap_itr;
+        rvm_length_t             rlsc_rvmmap_curr_index;
         rvm_seg_hdr_t           *rlsc_seg_hdr;
+        rvm_segment_hdr_t       *rlsc_hdrp;
         rvm_region_t            *rlsc_hdr_region;
         rvm_region_t            *rlsc_region;
         rvm_length_t            *rlsc_nregions;
-- 
1.8.3.2

