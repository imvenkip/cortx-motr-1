From 5e3bff1e98ef54b6e9bc76109cde792a6fc60aeb Mon Sep 17 00:00:00 2001
From: Sachin Patil <sachin_patil@xyratex.com>
Date: Mon, 1 Apr 2013 08:18:30 -0700
Subject: [PATCH 074/121] Added stobio support for datafile write. The stobio
 mechanism is still waits on clink for the for io completion. Need to
 implement the callback mechanism for io completion.

Commented not required function instead of deleting them for incase
future use.
---
 rvm/rvm_io.c        |  83 ++++++++--------
 rvm/rvm_logrecovr.c | 274 +++++++++++++++++++++++++++++++++++++---------------
 rvm/rvm_private.h   |  12 +++
 3 files changed, 251 insertions(+), 118 deletions(-)

diff --git a/rvm/rvm_io.c b/rvm/rvm_io.c
index a6094ce..d4e7769 100644
--- a/rvm/rvm_io.c
+++ b/rvm/rvm_io.c
@@ -46,9 +46,6 @@ Coda are listed in the file CREDITS.
 #define FSYNC(fd) fsync(fd)
 #endif
 
-#define OP_READ     1 << 0
-#define OP_WRITE    1 << 1
-
 /* global variables */
 device_t            *rvm_errdev;        /* last device to have error */
 int                 rvm_ioerrno=0;      /* also save the errno for I/O error */
@@ -235,8 +232,48 @@ long close_dev(dev)
     return retval;
     }
 
-uint64_t launch_io(opcode, stob, offset, dest, length)
-    int                 opcode;
+uint32_t launch_stob_io(opcode, io_nr, io_count, io_offset, io_addr, stob)
+    enum m0_stob_io_opcode  opcode;
+    uint32_t                io_nr;
+    m0_bcount_t            *io_count;
+    m0_bindex_t            *io_offset;
+    void                  **io_addr;
+    struct m0_stob         *stob;
+{
+    struct m0_stob_io       io;
+    struct m0_clink         clink;
+    uint32_t                rc;
+
+    m0_stob_io_init(&io);
+
+    io.si_opcode              = opcode;
+
+    io.si_user.ov_vec.v_nr    = io_nr;
+    io.si_user.ov_vec.v_count = io_count;
+    io.si_user.ov_buf         = io_addr;
+
+    io.si_stob.iv_vec.v_nr    = io_nr;
+    io.si_stob.iv_vec.v_count = io_count;
+    io.si_stob.iv_index       = io_offset;
+
+    io.si_flags               = 0;
+
+
+    m0_clink_init(&clink, NULL);
+    m0_clink_add(&io.si_wait, &clink);
+    rc = m0_stob_io_launch(&io, stob, NULL, NULL);
+
+    if (rc == 0)
+        m0_chan_wait(&clink);
+
+    m0_clink_del(&clink);
+    m0_clink_fini(&clink);
+    m0_stob_io_fini(&io);
+
+    return rc;
+}
+
+uint64_t launch_read_io(stob, offset, dest, length)
     struct m0_stob     *stob;
     rvm_length_t        offset;
     char               *dest;
@@ -249,9 +286,6 @@ uint64_t launch_io(opcode, stob, offset, dest, length)
     uint32_t                io_nr;
     uint64_t                io_read_len;
 
-    struct m0_stob_io       io;
-    struct m0_clink         clink;
-    int                     rc;
     int                     i = 0;
     uint64_t                retval = 0;
 
@@ -267,7 +301,7 @@ uint64_t launch_io(opcode, stob, offset, dest, length)
     M0_ALLOC_ARR(io_offset, io_nr);
     M0_ASSERT(io_offset != NULL);
 
-    while(length > 0) {
+    while (length > 0) {
         if (length <= rvm_max_read_len)
             io_read_len = length;
         else
@@ -284,34 +318,7 @@ uint64_t launch_io(opcode, stob, offset, dest, length)
         i           += 1;
     }
 
-    m0_stob_io_init(&io);
-
-    if(opcode == OP_READ)
-        io.si_opcode = SIO_READ;
-
-    if(opcode == OP_WRITE)
-        io.si_opcode = SIO_WRITE;
-
-    io.si_user.ov_vec.v_nr    = io_nr;
-    io.si_user.ov_vec.v_count = io_count;
-    io.si_user.ov_buf         = io_addr;
-
-    io.si_stob.iv_vec.v_nr    = io_nr;
-    io.si_stob.iv_vec.v_count = io_count;
-    io.si_stob.iv_index       = io_offset;
-
-    io.si_flags               = 0;
-
-    m0_clink_init(&clink, NULL);
-    m0_clink_add(&io.si_wait, &clink);
-    rc = m0_stob_io_launch(&io, stob, NULL, NULL);
-
-    if (rc == 0)
-        m0_chan_wait(&clink);
-
-    m0_clink_del(&clink);
-    m0_clink_fini(&clink);
-    m0_stob_io_fini(&io);
+    launch_stob_io(SIO_READ, io_nr, io_count, io_offset, io_addr, stob);
 
     m0_free(io_offset);
     m0_free(io_count);
@@ -348,7 +355,7 @@ long read_stob(dev,offset,dest,length)
     /* do read in larg-ish blocks to avoid kernel buffer availability problems
  *      * also zero region if /dev/null being read */
 
-    nbytes = launch_io(OP_READ, dev->stob, offset->low, dest, length);
+    nbytes = launch_read_io(dev->stob, offset->low, dest, length);
 
     /* update position */
     dev->last_position = RVM_ADD_LENGTH_TO_OFFSET(dev->last_position, nbytes);
diff --git a/rvm/rvm_logrecovr.c b/rvm/rvm_logrecovr.c
index 1768874..cd782be 100644
--- a/rvm/rvm_logrecovr.c
+++ b/rvm/rvm_logrecovr.c
@@ -30,11 +30,16 @@ Coda are listed in the file CREDITS.
 #include <errno.h>
 #include "rvm/rvm_private.h"
 
+#include "stob/stob.h"
+#include "lib/memory.h"
+
 #ifdef RVM_LOG_TAIL_BUG
 #include <rvmtesting.h>
 extern unsigned long *ClobberAddress;
 #endif /* RVM_LOG_TAIL_BUG */
 
+#define MAX_WRITE_RECORDS 4096
+
 /* global variables */
 
 extern log_t        *default_log;       /* default log descriptor ptr */
@@ -2043,20 +2048,22 @@ X( log_seg_id: done)
 
     return RVM_SUCCESS;
     }
+
 /* pre-scan change tree to see how much to read to read into buffer */
+/*
 static dev_region_t *pre_scan(log,tree)
-    log_t           *log;               /* log descriptor */
-    tree_root_t     *tree;              /* current tree root */
+    log_t           *log;               / * log descriptor * /
+    tree_root_t     *tree;              / * current tree root * /
     {
-    log_buf_t       *log_buf = &log->log_buf; /* log buffer descriptor */
+    log_buf_t       *log_buf = &log->log_buf; / * log buffer descriptor * /
     dev_region_t    *last_node = NULL;
-    dev_region_t    *node;              /* current change tree node */
+    dev_region_t    *node;              / * current change tree node * /
     rvm_offset_t    temp;
 
-    /* find node with least offset */
+    / * find node with least offset * /
     node = (dev_region_t *)tree->root;
-    /* XXX - Can node ever be NULL?  If so, last_node can be random */
-    /* I currently believe it must be NON-null */
+    / * XXX - Can node ever be NULL?  If so, last_node can be random * /
+    / * I currently believe it must be NON-null * /
     assert(node != NULL);
     while (node != NULL)
         {
@@ -2066,22 +2073,22 @@ static dev_region_t *pre_scan(log,tree)
         }
     log_buf->offset = CHOP_OFFSET_TO_SECTOR_SIZE(last_node->offset);
 
-    /* scan for maximum offset node that will fit in buffer */
+    / * scan for maximum offset node that will fit in buffer * /
     node = (dev_region_t *)tree->root;
     while (node != NULL)
         {
         assert(node->links.node.struct_id == dev_region_id);
 
-        /* compute buffer extension for this node */
+        / * compute buffer extension for this node * /
         temp = RVM_SUB_OFFSETS(node->end_offset,log_buf->offset);
         temp = ROUND_OFFSET_TO_SECTOR_SIZE(temp);
 
-        /* see if will fit in log buffer */
+        / * see if will fit in log buffer * /
         if (RVM_OFFSET_GTR(temp,log_buf->buf_len))
-            node = (dev_region_t *)node->links.node.lss; /* try smaller */
+            node = (dev_region_t *)node->links.node.lss; / * try smaller * /
         else
             {
-            /* see if there's another that will also fit */
+            / * see if there's another that will also fit * /
             last_node = node;
             node = (dev_region_t *)node->links.node.gtr;
             }
@@ -2089,49 +2096,51 @@ static dev_region_t *pre_scan(log,tree)
 
     return last_node;
     }
+*/
 /* merge large node disk-resident new values with segment data */
+/*
 static rvm_return_t disk_merge(log,node,preload)
-    log_t           *log;               /* log descriptor */
-    dev_region_t    *node;              /* node to merge */
-    rvm_bool_t      preload;            /* end sector preload done if true */
+    log_t           *log;               / * log descriptor * /
+    dev_region_t    *node;              / * node to merge * /
+    rvm_bool_t      preload;            / * end sector preload done if true * /
     {
-    log_status_t    *status = &log->status; /* status descriptor */
-    log_buf_t       *log_buf = &log->log_buf; /* log buffer descriptor */
-    rvm_length_t    data_len=0;         /* actual nv data length read */
-    rvm_length_t    buf_ptr;            /* log buffer ptr */
-    rvm_length_t    aux_ptr;            /* aux buffer ptr
-                                           (compensates for sector alignment) */
-    rvm_length_t    tmp_ptr;            /* temporary buffer ptr */
-    long            rw_length;          /* actual i/o transfer length */
-    rvm_offset_t    end_offset;         /* end offset temporary */
-    rvm_return_t    retval;             /* return value */
-    rvm_bool_t      was_preloaded = preload; /* save preload state */
+    log_status_t    *status = &log->status; / * status descriptor * /
+    log_buf_t       *log_buf = &log->log_buf; / * log buffer descriptor * /
+    rvm_length_t    data_len=0;         / * actual nv data length read * /
+    rvm_length_t    buf_ptr;            / * log buffer ptr * /
+    rvm_length_t    aux_ptr;            / * aux buffer ptr
+                                           (compensates for sector alignment) * /
+    rvm_length_t    tmp_ptr;            / * temporary buffer ptr * /
+    long            rw_length;          / * actual i/o transfer length * /
+    rvm_offset_t    end_offset;         / * end offset temporary * /
+    rvm_return_t    retval;             / * return value * /
+    rvm_bool_t      was_preloaded = preload; / * save preload state * /
 
     assert(log->trunc_thread == cthread_self());
     assert((status->trunc_state & RVM_TRUNC_PHASES)
            == RVM_TRUNC_APPLY);
     assert(node->links.node.struct_id == dev_region_id);
 
-    /* set log buffer pointer and end offset */
+    / * set log buffer pointer and end offset * /
     end_offset = CHOP_OFFSET_TO_SECTOR_SIZE(node->end_offset);
     buf_ptr = RVM_OFFSET_TO_LENGTH(RVM_SUB_OFFSETS(node->offset,
                                                    log_buf->offset));
     node->log_offset = RVM_ADD_LENGTH_TO_OFFSET(node->log_offset,
                                                 BYTE_SKEW(buf_ptr));
     DO_FOREVER
-        {                               /* fill log buffer from aux buf */
+        {                               / * fill log buffer from aux buf * /
         while ((buf_ptr < log_buf->length)
                && (node->length != 0))
             {
-            /* see how much to get in this pass & load aux_buf */
+            / * see how much to get in this pass & load aux_buf * /
             if ((log_buf->length-buf_ptr) < node->length)
-                rw_length = log_buf->length-buf_ptr; /* fill log_buf */
+                rw_length = log_buf->length-buf_ptr; / * fill log_buf * /
             else
-                rw_length = node->length; /* get all remaining */
+                rw_length = node->length; / * get all remaining * /
             if ((retval=load_aux_buf(log,&node->log_offset,rw_length,
                                      &aux_ptr,&data_len,SYNCH,rvm_true))
                 != RVM_SUCCESS) return retval;
-            /* sanity checks and monitoring */
+            / * sanity checks and monitoring * /
             assert((aux_ptr+data_len) <= log_buf->aux_rlength);
             assert((buf_ptr+data_len) <= log_buf->length);
             assert(BYTE_SKEW(aux_ptr) == BYTE_SKEW(node->vmaddr));
@@ -2141,16 +2150,16 @@ static rvm_return_t disk_merge(log,node,preload)
                                &log_buf->aux_buf[aux_ptr],NULL,NULL,
                                "disk_merge: data read from log:");
 
-            /* preload of last modified segment sector */
+            / * preload of last modified segment sector * /
             if (RVM_OFFSET_GTR(RVM_ADD_LENGTH_TO_OFFSET(
                                node->offset,data_len),end_offset)
                 && (!preload))
                 {
-                /* must load last sector of mods from segment */
+                / * must load last sector of mods from segment * /
                 tmp_ptr = CHOP_TO_SECTOR_SIZE(buf_ptr+data_len);
                 if (!(log->in_recovery || rvm_utlsw || rvm_no_yield))
                     {
-                    cthread_yield();    /* allow reschedule */
+                    cthread_yield();    / * allow reschedule * /
                     assert(log->trunc_thread == cthread_self());
                     }
                 if ((rw_length=read_dev(log->cur_seg_dev,&end_offset,
@@ -2162,18 +2171,18 @@ static rvm_return_t disk_merge(log,node,preload)
                 assert(rw_length == SECTOR_SIZE);
                 preload = rvm_true;
 
-                /* monitor data from last sector */
+                / * monitor data from last sector * /
                 if (rvm_chk_len != 0)
                     monitor_vmaddr(node->vmaddr,data_len,
                                    &log_buf->buf[buf_ptr],NULL,NULL,
                                    "disk_merge: data read from segment:");
                 }
 
-            /* copy to segment (in log buffer) */
+            / * copy to segment (in log buffer) * /
             (void)BCOPY(&log_buf->aux_buf[aux_ptr],
                         &log_buf->buf[buf_ptr],data_len);
 
-            /* tally bytes merged & do monitoring */
+            / * tally bytes merged & do monitoring * /
             if (rvm_chk_len != 0)
                 {
                 monitor_vmaddr(node->vmaddr,data_len,
@@ -2187,7 +2196,7 @@ static rvm_return_t disk_merge(log,node,preload)
             node->offset =
                 RVM_ADD_LENGTH_TO_OFFSET(node->offset,data_len);
             buf_ptr += data_len;
-            /* if done, set final write length */
+            / * if done, set final write length * /
             if (node->length == 0)
                 {
                 assert(RVM_OFFSET_EQL(node->offset,
@@ -2201,7 +2210,7 @@ static rvm_return_t disk_merge(log,node,preload)
                 }
             }
 
-        /* write buffer to segment & monitor */
+        / * write buffer to segment & monitor * /
         assert(buf_ptr == log_buf->length);
         if ((rw_length=write_dev(log->cur_seg_dev,&log_buf->offset,
                                  log_buf->buf,log_buf->length,
@@ -2217,7 +2226,7 @@ static rvm_return_t disk_merge(log,node,preload)
                            "disk_merge: data written to segment:");
         if (!(log->in_recovery || rvm_utlsw || rvm_no_yield))
             {
-            cthread_yield();            /* allow reschedule */
+            cthread_yield();            / * allow reschedule * /
             assert(log->trunc_thread == cthread_self());
             assert((status->trunc_state & RVM_TRUNC_PHASES)
                    == RVM_TRUNC_APPLY);
@@ -2228,19 +2237,21 @@ static rvm_return_t disk_merge(log,node,preload)
         assert(OFFSET_TO_SECTOR_INDEX(log_buf->offset) == 0);
         }
     }
+*/
 /* merge node's new values with segment data in buffer */
+/*
 static rvm_return_t merge_node(log,node,preload)
-    log_t           *log;               /* log descriptor */
-    dev_region_t    *node;              /* current change tree node */
-    rvm_bool_t      preload;            /* end sector preload done if true */
+    log_t           *log;               / * log descriptor * /
+    dev_region_t    *node;              / * current change tree node * /
+    rvm_bool_t      preload;            / * end sector preload done if true * /
     {
-    log_buf_t       *log_buf = &log->log_buf; /* log buffer descriptor */
+    log_buf_t       *log_buf = &log->log_buf; / * log buffer descriptor * /
     rvm_length_t    temp;
-    rvm_return_t    retval;             /* return value */
+    rvm_return_t    retval;             / * return value * /
 
-    /* do monitoring and merge node data into segment */
+    / * do monitoring and merge node data into segment * /
     if (RVM_OFFSET_EQL_ZERO(node->log_offset))
-        {                               /* data in node */
+        {                               / * data in node * /
         if (rvm_chk_len != ZERO)
             monitor_vmaddr(node->vmaddr,node->length,
                            node->nv_ptr,NULL,NULL,
@@ -2251,53 +2262,153 @@ static rvm_return_t merge_node(log,node,preload)
         dest_aligned_bcopy(node->nv_ptr,&log_buf->buf[temp],
                            node->length);
         }
-    else                                /* data on disk -- use aux_buf */
+    else                                / * data on disk -- use aux_buf * /
         if ((retval=disk_merge(log,node,preload)) != RVM_SUCCESS)
             return retval;
 
-    /* free node and check for yield */
+    / * free node and check for yield * /
     (void) free_dev_region(node);
     if (num_nodes-- == 0)
         {
         num_nodes = NODES_PER_YIELD;
         if (!(log->in_recovery || rvm_utlsw || rvm_no_yield))
             {
-            cthread_yield();            /* allow reschedule */
+            cthread_yield();            / * allow reschedule * /
             assert(log->trunc_thread == cthread_self());
             }
         }
 
     return RVM_SUCCESS;
     }
+*/
 
-static rvm_return_t update_seg(log,seg_dict,seg_dev)
+static rvm_return_t  update_seg(log, seg_dict, seg_dev)
     log_t           *log;               /* log descriptor */
     seg_dict_t      *seg_dict;          /* segment dictionary entry */
     device_t        *seg_dev;           /* segment device descriptor */
 {
-    log_status_t    *status = &log->status; /* status descriptor */
-    log_buf_t       *log_buf = &log->log_buf; /* log buffer descriptor */
-    long            r_length;           /* length of data transfered */
-    rvm_bool_t      preload;            /* end sector preload done if true */
-    char            *addr=NULL;         /* monitoring address */
-    rvm_offset_t    temp;               /* offset temporary */
-    dev_region_t    *node;              /* current node */
-    dev_region_t    *last_node;         /* last node before buffer write */
-    rvm_return_t    retval = RVM_SUCCESS; /* return value */
-    long            nodes_done = 0;
+    log_status_t           *status;
+    dev_region_t           *node;
+    tree_root_t            *mod_tree;
+    struct m0_stob         *stob;
+    void                  **io_addr;
+    m0_bindex_t            *io_offset;
+    m0_bcount_t            *io_count;
+    uint32_t                io_bshift;
+    uint32_t                iter_count;
+    uint32_t                iter_remained;
+    uint32_t                i = 0;
+    uint32_t                nodes_done = 0;
+    uint32_t                retval;
+
+    mod_tree        = &seg_dict->mod_tree;
+    status          = &log->status;
+    stob            = seg_dev->stob;
+    rvm_num_nodes   = mod_tree->n_nodes;
+    iter_remained   = rvm_num_nodes;
 
     /* sanity checks and initializations */
     assert(&log->dev != seg_dev);
     assert(log->trunc_thread == cthread_self());
+    assert((status->trunc_state & RVM_TRUNC_PHASES) == RVM_TRUNC_APPLY);
+
+    if (!(log->in_recovery || rvm_utlsw)) {
+        mutex_lock(&seg_dict->seg->dev_lock);
+        assert(log->trunc_thread == cthread_self());
+        assert((status->trunc_state & RVM_TRUNC_PHASES) == RVM_TRUNC_APPLY);
+    }
+
+    iter_count = MAX_WRITE_RECORDS;
+    if (rvm_num_nodes < MAX_WRITE_RECORDS) {
+        iter_count = rvm_num_nodes;
+    }
+
+    M0_ALLOC_ARR(io_addr, iter_count);
+    M0_ASSERT(io_addr != NULL);
+
+    M0_ALLOC_ARR(io_count, iter_count);
+    M0_ASSERT(io_count != NULL);
+
+    M0_ALLOC_ARR(io_offset, iter_count);
+    M0_ASSERT(io_offset != NULL);
+
+    io_bshift = stob->so_op->sop_block_shift(stob);
+
+    for (node = (dev_region_t *)init_tree_generator(mod_tree,FORWARD,rvm_false);
+        (node) != NULL; node = (dev_region_t *)tree_successor(mod_tree)) {
+
+        io_addr[i]      = m0_stob_addr_pack(node->nv_ptr, io_bshift);
+        io_count[i]     = node->length >> io_bshift;
+        io_offset[i]    = node->offset.low >> io_bshift;
+        i++;
+        nodes_done++;
+        if (i == iter_count) {
+            retval = launch_stob_io(SIO_WRITE, iter_count, io_count, io_offset,
+                                    io_addr, stob);
+            if(retval != RVM_SUCCESS)
+                return retval;
+
+            iter_remained -= iter_count;
+            iter_count = MAX_WRITE_RECORDS;
+            if (iter_remained < MAX_WRITE_RECORDS) {
+                iter_count = iter_remained;
+            }
+            i = 0;
+        }
+    }
+
+    UNLINK_NODES_OF(seg_dict->mod_tree, dev_region_t, node)
+    {
+        assert(node->links.node.struct_id == dev_region_id);
+        (void)free_dev_region(node);
+    }
+
+    assert(nodes_done == rvm_num_nodes);
+    assert(seg_dict->mod_tree.n_nodes == 0);
+
+    m0_free(io_offset);
+    m0_free(io_count);
+    m0_free(io_addr);
+
+    /* end segment dev_lock crit sec */
+    if (!(log->in_recovery || rvm_utlsw)) {
+        mutex_unlock(&seg_dict->seg->dev_lock);
+        assert(log->trunc_thread == cthread_self());
+        assert((status->trunc_state & RVM_TRUNC_PHASES) == RVM_TRUNC_APPLY);
+    }
+
+    return retval;
+}
+
+/*
+static rvm_return_t update_seg(log,seg_dict,seg_dev)
+    log_t           *log;               / * log descriptor * /
+    seg_dict_t      *seg_dict;          / * segment dictionary entry * /
+    device_t        *seg_dev;           / * segment device descriptor * /
+{
+    log_status_t    *status = &log->status; / * status descriptor * /
+    log_buf_t       *log_buf = &log->log_buf; / * log buffer descriptor * /
+    long            r_length;           / * length of data transfered * /
+    rvm_bool_t      preload;            / * end sector preload done if true * /
+    char            *addr=NULL;         / * monitoring address * /
+    rvm_offset_t    temp;               / * offset temporary * /
+    dev_region_t    *node;              / * current node * /
+    dev_region_t    *last_node;         / * last node before buffer write * /
+    rvm_return_t    retval = RVM_SUCCESS; / * return value * /
+    long            nodes_done = 0;
+
+    / * sanity checks and initializations * /
+    assert(&log->dev != seg_dev);
+    assert(log->trunc_thread == cthread_self());
     assert((status->trunc_state & RVM_TRUNC_PHASES)
            == RVM_TRUNC_APPLY);
     rvm_num_nodes = seg_dict->mod_tree.n_nodes;
     rvm_max_depth = seg_dict->mod_tree.max_depth;
     clear_aux_buf(log);
 
-    /* process the change tree */
-    if (!(log->in_recovery || rvm_utlsw)) /* begin segment dev_lock crit sec
-                                             */
+    / * process the change tree * /
+    if (!(log->in_recovery || rvm_utlsw)) / * begin segment dev_lock crit sec
+                                             * /
         {
         mutex_lock(&seg_dict->seg->dev_lock);
         assert(log->trunc_thread == cthread_self());
@@ -2306,16 +2417,16 @@ static rvm_return_t update_seg(log,seg_dict,seg_dev)
         }
     while (seg_dict->mod_tree.root != NULL)
         {
-        /* pre-scan tree to determine how to fill buffer */
+        / * pre-scan tree to determine how to fill buffer * /
         last_node = pre_scan(log,&seg_dict->mod_tree);
 
-        /* initialize buffer with segment data */
+        / * initialize buffer with segment data * /
         temp = RVM_SUB_OFFSETS(last_node->end_offset,
                                log_buf->offset);
         temp = ROUND_OFFSET_TO_SECTOR_SIZE(temp);
         if (RVM_OFFSET_LEQ(temp,log_buf->buf_len))
             {
-            /* node(s) fit in log buffer */
+            / * node(s) fit in log buffer * /
             log_buf->r_length = RVM_OFFSET_TO_LENGTH(RVM_SUB_OFFSETS(
                                     last_node->end_offset,
                                     log_buf->offset));
@@ -2326,10 +2437,10 @@ static rvm_return_t update_seg(log,seg_dict,seg_dev)
             }
         else
             {
-            log_buf->r_length = SECTOR_SIZE; /* very large node!! */
+            log_buf->r_length = SECTOR_SIZE; / * very large node!! * /
             preload = rvm_false;
             }
-        /* allow reschedule & do the read */
+        / * allow reschedule & do the read * /
         if (!(log->in_recovery || rvm_utlsw || rvm_no_yield))
             {
             cthread_yield();
@@ -2348,14 +2459,14 @@ static rvm_return_t update_seg(log,seg_dict,seg_dev)
                == RVM_TRUNC_APPLY);
         assert(r_length == log_buf->r_length);
 
-        /* merge selected nodes into buffer */
+        / * merge selected nodes into buffer * /
         num_nodes = NODES_PER_YIELD;
         UNLINK_NODES_OF(seg_dict->mod_tree,dev_region_t,node)
             {
             assert(node->links.node.struct_id == dev_region_id);
             nodes_done++;
 
-            /* do monitoring */
+            / * do monitoring * /
             if (rvm_chk_len != 0)
                 {
                 temp = log_buf->offset;
@@ -2365,15 +2476,15 @@ static rvm_return_t update_seg(log,seg_dict,seg_dev)
                                "update_seg: data read from segment:");
                 }
 
-            /* merge data */
+            / * merge data * /
             if ((retval=merge_node(log,node,preload))
                 != RVM_SUCCESS) goto err_exit;
-            if (rvm_chk_sigint != NULL) /* test for interrupt */
+            if (rvm_chk_sigint != NULL) / * test for interrupt * /
                 if ((*rvm_chk_sigint)(NULL)) goto err_exit;
             if (node == last_node) break;
             }
 
-        /* update the segment on disk */
+        / * update the segment on disk * /
         if ((r_length=write_dev(seg_dev,&log_buf->offset,log_buf->buf,
                                 log_buf->r_length,rvm_true)) < 0)
             {
@@ -2384,7 +2495,7 @@ static rvm_return_t update_seg(log,seg_dict,seg_dev)
         assert((status->trunc_state & RVM_TRUNC_PHASES)
                == RVM_TRUNC_APPLY);
         assert(r_length == log_buf->r_length);
-        /* do monitoring */
+        / * do monitoring * /
         if (rvm_chk_len != 0)
             {
             if (!RVM_OFFSET_EQL(temp,log_buf->offset))
@@ -2396,12 +2507,12 @@ static rvm_return_t update_seg(log,seg_dict,seg_dev)
             }
         }
 
-    /* tree checks and cleanup after unlinking */
+    / * tree checks and cleanup after unlinking * /
     assert(nodes_done == rvm_num_nodes);
     assert(seg_dict->mod_tree.n_nodes == 0);
 
 err_exit:
-    if (!(log->in_recovery || rvm_utlsw)) /* end segment dev_lock crit sec */
+    if (!(log->in_recovery || rvm_utlsw)) / * end segment dev_lock crit sec * /
         {
         mutex_unlock(&seg_dict->seg->dev_lock);
         assert(log->trunc_thread == cthread_self());
@@ -2410,6 +2521,8 @@ err_exit:
         }
     return retval;
     }
+*/
+
 /* Recovery: phase 3 -- apply modifications to segments */
 rvm_return_t apply_mods(log)
     log_t           *log;               /* log descriptor */
@@ -2461,8 +2574,9 @@ rvm_return_t apply_mods(log)
         log->cur_seg_dev = seg_dev;
 
         /* read segment data and merge new values */
-        if ((retval=update_seg(log,seg_dict,seg_dev))
-            != RVM_SUCCESS) return retval;
+        if ((retval=update_seg(log,seg_dict,seg_dev)) != RVM_SUCCESS)
+                return retval;
+
         assert(log->trunc_thread == cthread_self());
         assert((status->trunc_state & RVM_TRUNC_PHASES)
                == RVM_TRUNC_APPLY);
diff --git a/rvm/rvm_private.h b/rvm/rvm_private.h
index 85e3d22..8bbbd69 100644
--- a/rvm/rvm_private.h
+++ b/rvm/rvm_private.h
@@ -41,6 +41,8 @@ Coda are listed in the file CREDITS.
 #include "rvm/rvm_statistics.h"
 
 #include <fcntl.h>
+#include <stdint.h>
+
 #ifndef O_BINARY
 #define O_BINARY 0
 #endif
@@ -1513,6 +1515,16 @@ long read_stob();                        /* [rvm_io.c] */
     char            *dest;
     rvm_length_t    length;
 */
+extern
+uint32_t launch_stob_io();               /* [rvm_io.c] */
+/*
+ enum m0_stob_io_opcode  opcode;
+ uint32_t                io_nr;
+ m0_bcount_t            *io_count;
+ m0_bindex_t            *io_offset;
+ void                  **io_addr;
+ struct m0_stob         *stob;
+*/
 
 extern
 long read_dev();                        /* [rvm_io.c] */
-- 
1.8.3.2

