From 88e0c141af3562a6238cb033f43641574cf5d3b4 Mon Sep 17 00:00:00 2001
From: Zishan Shaikh <zishan_shaikh@xyratex.com>
Date: Fri, 31 May 2013 09:54:17 -0700
Subject: [PATCH 111/121] Made RVM fully asynchronous. All UTs (be, kvstore,
 cob, kvstore-UB) except hs-ut working correctly.

---
 cob/cob.c           |   7 +--
 rvm/rvm_logrecovr.c | 175 ++++++++++++++++++++++++++++++++--------------------
 rvm/rvm_private.h   |   2 +-
 3 files changed, 111 insertions(+), 73 deletions(-)

diff --git a/cob/cob.c b/cob/cob.c
index a610ddf..f666f5f 100644
--- a/cob/cob.c
+++ b/cob/cob.c
@@ -94,7 +94,7 @@ static void __cob_be_tx_done_cb(struct m0_be_cbinfo *cbinfo, int status,
         m0_sm_group_lock(cbinfo->bc_sm_group);
         m0_sm_ast_post(post_sm_group, ast);
         m0_sm_group_unlock(cbinfo->bc_sm_group);
-        m0_free(cob_cbinfo);
+	m0_free(cob_cbinfo);
 }
 
 static void __cob_set_be_tx_done_cbinfo(struct m0_cob_be_cbinfo  *cob_cbinfo,
@@ -472,10 +472,7 @@ void cob_ns_kv_store_init(struct m0_be_cbinfo *cbinfo, int status,
         if (msg == M0_BE_SUCCESS) {
                 ast           = &cob_cbinfo->cbc_ast;
                 post_sm_group = cob_cbinfo->cbc_sm_group;
-
-                m0_sm_group_lock(cbinfo->bc_sm_group);
                 m0_sm_ast_post(post_sm_group, ast);
-                m0_sm_group_unlock(cbinfo->bc_sm_group);
         }
 }
 
@@ -562,7 +559,7 @@ void cob_nsrec_kv_init_operation_cb(void *cbdata, void *result, int rc)
         m0_sm_ast_post(post_sm_group, ast);
         m0_sm_group_unlock(be_cbinfo->bc_sm_group);
 
-        m0_free(cob_cbinfo);
+	m0_free(cob_cbinfo);
 }
 
 void __ast_init_kv_store(struct m0_sm_group *sm_group, struct m0_sm_ast *ast)
diff --git a/rvm/rvm_logrecovr.c b/rvm/rvm_logrecovr.c
index c84bf24..72cd8e3 100644
--- a/rvm/rvm_logrecovr.c
+++ b/rvm/rvm_logrecovr.c
@@ -1001,8 +1001,8 @@ void __validate_rec_reverse_cb(struct m0_be_cbinfo *cbinfo,
 		msg_type  = RVM_EINTERNAL;
 	}
 exit:
-        if (cbinfo != NULL && cbinfo->bc_cb != NULL) {
-                m0_be_handler_post(cbinfo, be_status, msg_type);
+        if (cbinfo->bc_pcbinfo != NULL && cbinfo->bc_pcbinfo->bc_cb != NULL) {
+                m0_be_handler_post(cbinfo->bc_pcbinfo, be_status, msg_type);
 		m0_free(lrc_cbdata);
         }
 
@@ -1018,9 +1018,10 @@ void validate_rec_reverse_cb(struct m0_be_cbinfo *cbinfo, int  be_status,
 	long             tmp_ptr;            /* temporary buffer ptr */
 	rvm_length_t     tmp_len;
 	rvm_offset_t     offset;             /* temp for offset calculations */
-	rvm_return_t     retval;
+	rvm_return_t     retval = RVM_SUCCESS;
     	lrc_cbdata_t    *lrc_cbdata;
 	rvm_bool_t 	 synch;
+	rvm_bool_t 	 is_vrc_complete = rvm_false;
 
 	printf("\nfunction %s\n", __FUNCTION__);
 	if(be_status != 0)
@@ -1037,25 +1038,26 @@ void validate_rec_reverse_cb(struct m0_be_cbinfo *cbinfo, int  be_status,
 	if (rec_end->rec_hdr.struct_id != rec_end_id)
 		goto no_record;             /* no next record */
 	lrc_cbdata->lrc_rec_end = rec_end;
+
 	/* see if record will fit in buffer */
 	if ((ROUND_TO_SECTOR_SIZE(rec_end->rec_hdr.rec_length +
 	      sizeof(rec_end_t)) + SECTOR_SIZE) <= log_buf->length) {
 		/* yes, get whole record in buffer */
-		if ((long)(log_buf->ptr - rec_end->rec_hdr.rec_length) < 0)
-		    {
-			    /* refill buffer (be sure end marker is included) */
-			    log_buf->ptr += sizeof(rec_end_t);
-			    lrc_cbdata->lrc_is_refill_buf = rvm_true;
-			    cbinfo->bc_cb = __validate_rec_reverse_cb;
-			    if ((retval=refill_buffer(log,REVERSE,synch))
-				!= RVM_SUCCESS) {
+		if ((long)(log_buf->ptr - rec_end->rec_hdr.rec_length) < 0) {
+			/* refill buffer (be sure end marker is included) */
+			log_buf->ptr += sizeof(rec_end_t);
+			lrc_cbdata->lrc_is_refill_buf = rvm_true;
+			cbinfo->bc_cb = __validate_rec_reverse_cb;
+
+			if ((retval = refill_buffer(log, REVERSE, synch,
+						    cbinfo))!= RVM_SUCCESS) {
 				be_status = -1;
 				msg_type  = retval;
-				goto exit;
-			    }
-			    log_buf->ptr -= sizeof(rec_end_t);
-			    rec_end = (rec_end_t *)&log_buf->buf[log_buf->ptr];
-		    }
+			}
+			goto exit;
+		} else
+			is_vrc_complete = rvm_true;
+
 		tmp_ptr = log_buf->ptr - rec_end->rec_hdr.rec_length;
 		rec_hdr = (rec_hdr_t *)&log_buf->buf[tmp_ptr];
 	}
@@ -1078,7 +1080,7 @@ void validate_rec_reverse_cb(struct m0_be_cbinfo *cbinfo, int  be_status,
 
 		retval = load_aux_buf(log, &offset, MAX_HDR_SIZE,
 				      &lrc_cbdata->lrc_tmp_ptr, &tmp_len,
-				      synch, rvm_false);
+				      synch, rvm_false, cbinfo);
 		if (retval != RVM_SUCCESS) {
 		     be_status = -1;
 		     msg_type  = retval;
@@ -1087,16 +1089,28 @@ void validate_rec_reverse_cb(struct m0_be_cbinfo *cbinfo, int  be_status,
 
 		if (lrc_cbdata->lrc_tmp_ptr == -1)
 		    goto no_record;             /* record header not available */
+
+		goto exit;
+	}
+
+	if (is_vrc_complete) {
+		if (!validate_hdr(log,rec_hdr,rec_end,REVERSE)) {
+			be_status = -1;
+			msg_type  = M0_BE_INTERNAL;
+		}
+		goto exit;
 	}
 
 no_record:
 	log_buf->ptr = -1;               /* no next record */
 exit:
-	if ((retval != RVM_SUCCESS || log_buf->ptr == -1) && cbinfo != NULL &&
-	      cbinfo->bc_cb != NULL) {
-                m0_be_handler_post(cbinfo, be_status, msg_type);
+	if ((be_status != 0 || log_buf->ptr == -1 || is_vrc_complete) &&
+	     cbinfo->bc_pcbinfo != NULL && cbinfo->bc_pcbinfo->bc_cb != NULL) {
+                m0_be_handler_post(cbinfo->bc_pcbinfo, be_status, msg_type);
+		m0_free(lrc_cbdata);
         }
 }
+
 /* validate current record in buffer in reverse scan */
 rvm_return_t validate_rec_reverse(log_t *log, rvm_bool_t synch,
 				   struct m0_be_cbinfo *cbinfo)
@@ -1104,14 +1118,15 @@ rvm_return_t validate_rec_reverse(log_t *log, rvm_bool_t synch,
 	log_buf_t       *log_buf = &log->log_buf; /* log buffer descriptor */
 	log_status_t    *status = &log->status; /* status area */
 	rvm_offset_t     offset;             /* temp for offset calculations */
-	rvm_return_t    retval;
 
     	lrc_cbdata_t        *lrc_cbdata;
 	struct m0_be_cbinfo *lrc_cbinfo;
 	int 		     be_status = 0;
 	m0_be_msg_type_t     msg_type = M0_BE_SUCCESS;
-	rvm_bool_t	     wrap_end = rvm_false;
+	rvm_return_t         retval = RVM_SUCCESS;
+	/*rvm_bool_t	     wrap_end = rvm_false;*/
 
+	printf("\nfunction %s\n", __FUNCTION__);
         M0_ALLOC_PTR(lrc_cbdata);
         if (lrc_cbdata == NULL) {
                 be_status = -1;
@@ -1123,7 +1138,7 @@ rvm_return_t validate_rec_reverse(log_t *log, rvm_bool_t synch,
         lrc_cbdata->lrc_synch = synch;
         lrc_cbinfo            = &lrc_cbdata->lrc_cbinfo;
 
-	m0_be_cbinfo_copy_helper(cbinfo, lrc_cbinfo, scan_wrap_reverse_cb);
+	m0_be_cbinfo_copy_helper(cbinfo, lrc_cbinfo, validate_rec_reverse_cb);
 
     /* get previous end marker into buffer */
     if ((long)(log_buf->ptr-sizeof(rec_end_t)) < 0)
@@ -1131,24 +1146,33 @@ rvm_return_t validate_rec_reverse(log_t *log, rvm_bool_t synch,
 	    offset = RVM_ADD_LENGTH_TO_OFFSET(log_buf->offset,
 					      log_buf->ptr);
 	    if (RVM_OFFSET_EQL(offset, status->log_start)) {
-		    retval=scan_wrap_reverse(log, synch, lrc_cbinfo);
-		    wrap_end = rvm_true;
+		    retval   = scan_wrap_reverse(log, synch, lrc_cbinfo);
+		    if (retval != RVM_SUCCESS) {
+		    	be_status = -1;
+			msg_type  = retval;
+		    }
+		    /*wrap_end = rvm_true;*/
 		    goto exit;              /* exit pointing to wrap marker */
             }
         else
             {
-		    retval=init_buffer(log, &offset, REVERSE, synch);
+		    retval = init_buffer(log, &offset, REVERSE, synch,
+		    		         lrc_cbinfo);
         	    if (retval != RVM_SUCCESS) {
 			be_status = -1;
 			msg_type  = retval;
 			goto exit;
 		    }
             }
-        }
+        } else {
+		validate_rec_reverse_cb(lrc_cbinfo, be_status, msg_type);
+	}
+
 exit:
-       if ((retval != RVM_SUCCESS || wrap_end == rvm_true) && cbinfo != NULL &&
-            cbinfo->bc_cb != NULL) {
+    /*if ((retval != RVM_SUCCESS || wrap_end == rvm_true) && cbinfo != NULL &&*/
+       if (be_status != 0 && cbinfo != NULL && cbinfo->bc_cb != NULL) {
                 m0_be_handler_post(cbinfo, be_status, msg_type);
+		m0_free(lrc_cbdata);
         }
         return retval;
 
@@ -1508,31 +1532,34 @@ rvm_return_t scan_reverse(log, synch, cbinfo)
 	int			 be_status = 0;
 	assert(log_buf->ptr != -1);         /* can't reposition from this! */
 
-	M0_ALLOC_PTR(lrc_cbdata);
-        if (lrc_cbdata == NULL) {
-                be_status = -1;
-                msg    = -ENOMEM;
-                goto exit;
-        }
-        /* Prepare cbinfo. */
-        lrc_cbdata->lrc_log   = log;
-        lrc_cbdata->lrc_synch = synch;
-        lrc_cbinfo          = &lrc_cbdata->lrc_cbinfo;
-	m0_be_cbinfo_copy_helper(cbinfo, lrc_cbinfo, NULL);
+	printf("\nfunction %s\n", __FUNCTION__);
 
 	/* test if scan starting from tail */
 	offset = RVM_ADD_LENGTH_TO_OFFSET(log_buf->offset,log_buf->ptr);
 
 	if (RVM_OFFSET_EQL(offset,status->prev_log_tail)
 	|| (rvm_utlsw && RVM_OFFSET_EQL(offset,status->log_tail))) {
-		lrc_cbinfo->bc_cb = scan_reverse_cb;
-		retval = validate_rec_reverse(log, synch, lrc_cbinfo);
+		/* This is an exit point. */
+		retval = validate_rec_reverse(log, synch, cbinfo);
 		if(retval != RVM_SUCCESS) {
 	                be_status = -1;
         	        msg    = -ENOMEM;
 		}
 		goto exit;
 	}
+
+	M0_ALLOC_PTR(lrc_cbdata);
+        if (lrc_cbdata == NULL) {
+                be_status = -1;
+                msg    = -ENOMEM;
+                goto exit;
+        }
+        /* Prepare cbinfo. */
+        lrc_cbdata->lrc_log   = log;
+        lrc_cbdata->lrc_synch = synch;
+        lrc_cbinfo          = &lrc_cbdata->lrc_cbinfo;
+	m0_be_cbinfo_copy_helper(cbinfo, lrc_cbinfo, NULL);
+
 	scan_reverse_cb(lrc_cbinfo, be_status, msg);
 
 exit:
@@ -2412,8 +2439,12 @@ void locate_tail_cb(loc_tail_cbdata_t *loc_tail_cbdata)
 #endif /* RVM_LOG_TAIL_BUG */
 
 	status->last_write = last_write;
-	if (RVM_OFFSET_EQL(status->log_head,status->log_tail))
-		clear_log_status(log);	/* log empty */
+	if (RVM_OFFSET_EQL(status->log_head,status->log_tail)) {
+                CRITICAL(log->dev_lock, /* begin dev_lock crit sec */
+		{
+			clear_log_status(log);	/* log empty */
+		});
+	}
 	else {	/* log not empty */
 		status->log_empty = rvm_false;
 
@@ -2851,7 +2882,11 @@ void loc_tail_init_buf_cb(struct m0_be_cbinfo *cbinfo, int be_status,
 		#ifdef RVM_LOG_TAIL_BUG
 		protect_page__Fi(ClobberAddress);
 		#endif /* RVM_LOG_TAIL_BUG */
-		clear_log_status(log);
+                CRITICAL(log->dev_lock, /* begin dev_lock crit sec */
+		{
+			clear_log_status(log);
+		});
+
 		goto status_valid;
 	}
 
@@ -3862,7 +3897,6 @@ void bt_chk_wrap_cb(struct m0_be_cbinfo *cbinfo, int be_status,
 {
 	log_t		      *log;
 	bt_cbdata_t           *bt_cbdata;
-	struct m0_be_cbinfo   *bt_cbinfo;
 	rvm_return_t	       retval;
 
 	if(be_status == -1)
@@ -3871,18 +3905,16 @@ void bt_chk_wrap_cb(struct m0_be_cbinfo *cbinfo, int be_status,
 	bt_cbdata   = container_of(cbinfo, bt_cbdata_t, bt_cbinfo);
 	log         = bt_cbdata->bt_log;
 
-	bt_cbinfo   = &bt_cbdata->bt_cbinfo;
-
-	bt_cbinfo->bc_pcbinfo   = cbinfo;
-	bt_cbinfo->bc_cb        = bt_do_trans_cb;
-	bt_cbinfo->bc_sm_group  = cbinfo->bc_sm_group;
-	bt_cbinfo->bc_hq        = cbinfo->bc_hq;
+	/*bt_cbinfo->bc_pcbinfo   = cbinfo;*/
+	cbinfo->bc_cb        = bt_do_trans_cb;
+	/*bt_cbinfo->bc_sm_group  = cbinfo->bc_sm_group;*/
+	/*bt_cbinfo->bc_hq        = cbinfo->bc_hq;*/
 
 	bt_cbdata->bt_force_wrap_chk = rvm_false;
 X( trans_hdr_id: do_trans)
 	if ((retval = do_trans(log,
 			       bt_cbdata->bt_skip_trans,
-			       bt_cbinfo)) != RVM_SUCCESS) {
+			       cbinfo)) != RVM_SUCCESS) {
 		msg_type = retval;
 		be_status = -1;
 	}
@@ -3904,24 +3936,26 @@ void bt_scan_reverse_cb(struct m0_be_cbinfo *cbinfo, int be_status,
 	rec_end_t      	      *rec_end;      /* last record scanned in buffer */
 	rvm_offset_t          *tail;         /* tail offset temp */
     	bt_cbdata_t           *bt_cbdata;
-	struct m0_be_cbinfo   *bt_cbinfo;
+	/*struct m0_be_cbinfo   *bt_cbinfo;*/
 
-	if(be_status == -1)
+	if(be_status != 0)
 		goto exit;
 
+	printf("\nfunction %s\n", __FUNCTION__);
+
 	bt_cbdata   = container_of(cbinfo, bt_cbdata_t, bt_cbinfo);
 	log         = bt_cbdata->bt_log;
 	tail	    = &bt_cbdata->bt_tail;
 
-	bt_cbinfo   = &bt_cbdata->bt_cbinfo;
+	/*bt_cbinfo   = &bt_cbdata->bt_cbinfo;*/
 	assert(log->trunc_thread == cthread_self());
 	log_buf	    = &log->log_buf;
 	status	    = &log->status;
 
-	bt_cbinfo->bc_pcbinfo   = cbinfo;
-	bt_cbinfo->bc_cb        = bt_chk_wrap_cb;
-	bt_cbinfo->bc_sm_group  = cbinfo->bc_sm_group;
-	bt_cbinfo->bc_hq        = cbinfo->bc_hq;
+	/*bt_cbinfo->bc_pcbinfo   = cbinfo;*/
+	cbinfo->bc_cb        = bt_chk_wrap_cb;
+	/*bt_cbinfo->bc_sm_group  = cbinfo->bc_sm_group;*/
+	/*bt_cbinfo->bc_hq        = cbinfo->bc_hq;*/
 
 X(done scan_reverse)
         assert(log->trunc_thread == cthread_self());
@@ -3949,12 +3983,14 @@ X(else)
 		switch (rec_end->rec_type)
                 {
 			case trans_hdr_id:        /* process transaction */
+printf("\n!@#$^!@*&^*(!@(*!&@(*!&@(*&!*(@&(!@&(* CALLING CHECK WRAP!@##$$^&^&^!@&*&*^\n");
 X( trans_hdr_id: chk_wrap)
 			        if ((retval = chk_wrap(
 				                  log,
 						  bt_cbdata->bt_force_wrap_chk,
   		                	 	  &bt_cbdata->bt_skip_trans,
-				                  bt_cbinfo)) != RVM_SUCCESS) {
+				                  cbinfo)) != RVM_SUCCESS) {
+					/*bt_cbinfo)) != RVM_SUCCESS) {*/
 				                 	be_status = -1;
 				                	msg_type = retval;
 				                	goto exit;
@@ -3977,8 +4013,11 @@ X( log_seg_id: done)
 				break;
 			default:  assert(rvm_false); /* trouble, log damage? */
                 }
+
 	       /* update local tail ptr */
-	       *tail = RVM_ADD_LENGTH_TO_OFFSET(log_buf->offset, log_buf->ptr);
+		*tail = RVM_ADD_LENGTH_TO_OFFSET(log_buf->offset, log_buf->ptr);
+		bt_pre_scan_reverse_cb(cbinfo, be_status, msg_type);
+		goto exit;
             }
 exit:
 	if (be_status != 0 && cbinfo->bc_pcbinfo != NULL &&
@@ -3997,7 +4036,7 @@ void bt_pre_scan_reverse_cb(struct m0_be_cbinfo *cbinfo, int be_status,
 	rvm_return_t           retval;             /* return value */
 	rvm_offset_t          *tail;               /* tail offset temp */
     	bt_cbdata_t           *bt_cbdata;
-	rvm_bool_t	       loop_break;
+	rvm_bool_t	       loop_break = rvm_false;
 
 	if(be_status == -1)
 		goto exit;
@@ -4024,7 +4063,8 @@ exit:
 	if ((be_status != 0 || loop_break) && cbinfo->bc_pcbinfo != NULL &&
 	    cbinfo->bc_pcbinfo->bc_cb != NULL) {
 		m0_be_handler_post(cbinfo->bc_pcbinfo, be_status, msg_type);
-		m0_free(bt_cbdata);
+		if (be_status != 0)
+			m0_free(bt_cbdata);
 	}
 }
 
@@ -4454,8 +4494,8 @@ exit:
                                 mutex_unlock(&seg_dict->seg->dev_lock);
                                 assert(log->trunc_thread == cthread_self());
 				trunc_state = status->trunc_state;
-                                assert((trunc_state & RVM_TRUNC_PHASES) ==
-                                       RVM_TRUNC_APPLY);
+				assert((trunc_state & RVM_TRUNC_PHASES) ==
+					RVM_TRUNC_APPLY);
                         }
                 }
                 /* Post parent. */
@@ -4557,6 +4597,7 @@ static rvm_return_t  update_seg(log, seg_dict, seg_dev, cbinfo)
                 nodes_done++;
                 if (i == iter_count) {
                         /* pass lrc_cbinfo to launch stobio. */
+
                         retval = launch_stob_io_new(SIO_WRITE, iter_count,
 						    io_count, io_offset,
 						    io_addr, stob,
@@ -5305,7 +5346,6 @@ void log_recover_cb(cbinfo, be_status, msg)
 
         new_1st_rec_num = lrc_cbdata->lrc_recnr;
 
-        /* should take lock or not>?? */
         CRITICAL(log->truncation_lock,      /* begin truncation lock crit sec */
         {
                 assert(log->trunc_thread == cthread_self());
@@ -5415,6 +5455,7 @@ void lr_build_tree_cb(cbinfo, be_status, msg)
 			msg	  = retval;
 			goto err_exit;
 		}
+		goto exit_log_recover;
 		X(apply_mods end)
 	});
 
diff --git a/rvm/rvm_private.h b/rvm/rvm_private.h
index b8fbb1e..45abfd5 100644
--- a/rvm/rvm_private.h
+++ b/rvm/rvm_private.h
@@ -1826,7 +1826,6 @@ typedef	struct launch_stob_io_cbdata {
 
 typedef struct log_recover_cbdata {
         struct m0_be_cbinfo      lrc_cbinfo;
-        log_t                   *lrc_log;
 
         /** Needed by log_recover_cb & apply_mods. */
         rvm_length_t             lrc_recnr;
@@ -1872,6 +1871,7 @@ typedef struct log_recover_cbdata {
 	trans_hdr_t		 lrc_trans_hdr;
 	rvm_bool_t      	 lrc_chk_val;
 
+        log_t                   *lrc_log;
 }lrc_cbdata_t;
 
 /* wait_for_space_cbdata. */
-- 
1.8.3.2

