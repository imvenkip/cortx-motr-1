From 8b8856c5ac0452b448547ea2518571bf97f308a7 Mon Sep 17 00:00:00 2001
From: Sachin Patil <sachin_patil@xyratex.com>
Date: Mon, 28 Jan 2013 20:51:10 -0800
Subject: [PATCH 038/121] Incorporated almost all the review comments for
 domain, segment, regions and transactions

---
 Makefile.am             |   4 +-
 be/Makefile.sub         |  11 +-
 be/be.h                 | 403 ++++++++++++++++-----------
 be/be_domain.c          | 314 ---------------------
 be/be_impl.h            |  28 +-
 be/be_init.c            |  51 ++++
 be/be_init.h            |  55 ++++
 be/be_magic.h           |  52 ----
 be/be_private.h         |  57 ++++
 be/be_reg.c             | 511 ----------------------------------
 be/be_reg.h             |  65 -----
 be/be_rvm.c             |   7 +-
 be/be_rvm.h             |  14 +-
 be/be_seg.c             | 717 ------------------------------------------------
 be/be_seg.h             |  68 -----
 be/be_tx.c              | 564 -------------------------------------
 be/be_tx.h              |  76 -----
 be/domain.c             | 252 +++++++++++++++++
 be/domain.h             |  54 ++++
 be/reg.c                | 468 +++++++++++++++++++++++++++++++
 be/reg.h                |  71 +++++
 be/seg.c                | 482 ++++++++++++++++++++++++++++++++
 be/seg.h                |  76 +++++
 be/tx.c                 | 516 ++++++++++++++++++++++++++++++++++
 be/tx.h                 |  72 +++++
 be/ut/Makefile          |   8 +-
 be/ut/Makefile.sub      |   2 +-
 be/ut/be.c              |  99 ++++---
 be/ut/be_handle_store.c | 129 ---------
 be/ut/handle_store.c    | 138 ++++++++++
 mero/init.c             |   3 +
 mero/magic.h            |  22 ++
 sm/sm.c                 |   8 +
 sm/sm.h                 |   9 +
 34 files changed, 2672 insertions(+), 2734 deletions(-)
 delete mode 100644 be/be_domain.c
 create mode 100644 be/be_init.c
 create mode 100644 be/be_init.h
 delete mode 100644 be/be_magic.h
 create mode 100644 be/be_private.h
 delete mode 100644 be/be_reg.c
 delete mode 100644 be/be_reg.h
 delete mode 100644 be/be_seg.c
 delete mode 100644 be/be_seg.h
 delete mode 100644 be/be_tx.c
 delete mode 100644 be/be_tx.h
 create mode 100644 be/domain.c
 create mode 100644 be/domain.h
 create mode 100644 be/reg.c
 create mode 100644 be/reg.h
 create mode 100644 be/seg.c
 create mode 100644 be/seg.h
 create mode 100644 be/tx.c
 create mode 100644 be/tx.h
 delete mode 100644 be/ut/be_handle_store.c
 create mode 100644 be/ut/handle_store.c

diff --git a/Makefile.am b/Makefile.am
index 5ef3e90..feb2da8 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -150,7 +150,7 @@ mero_libmero_la_SOURCES  =
 include $(top_srcdir)/addb/Makefile.sub
 include $(top_srcdir)/addb/addbff/Makefile.sub
 include $(top_srcdir)/be/Makefile.sub
-include $(top_srcdir)/be/lib/Makefile.sub
+#include $(top_srcdir)/be/lib/Makefile.sub
 include $(top_srcdir)/balloc/Makefile.sub
 include $(top_srcdir)/build_kernel_modules/Makefile.sub
 include $(top_srcdir)/m0t1fs/Makefile.sub
@@ -202,7 +202,7 @@ ut_libmero_ut_la_SOURCES  =
 
 include $(top_srcdir)/addb/ut/Makefile.sub
 include $(top_srcdir)/be/ut/Makefile.sub
-include $(top_srcdir)/be/lib/ut/Makefile.sub
+#include $(top_srcdir)/be/lib/ut/Makefile.sub
 include $(top_srcdir)/balloc/ut/Makefile.sub
 include $(top_srcdir)/capa/ut/Makefile.sub
 include $(top_srcdir)/cm/ut/Makefile.sub
diff --git a/be/Makefile.sub b/be/Makefile.sub
index 52793e7..f58bdd5 100644
--- a/be/Makefile.sub
+++ b/be/Makefile.sub
@@ -1,7 +1,8 @@
 nobase_mero_include_HEADERS +=  be/be.h
 
-mero_libmero_la_SOURCES	    +=	be/be_domain.c          \
-				be/be_seg.c             \
-				be/be_reg.c             \
-				be/be_rvm.c             \
-				be/be_tx.c
+mero_libmero_la_SOURCES	    +=	be/be_init.c 	\
+				be/domain.c    	\
+				be/seg.c       	\
+				be/reg.c       	\
+				be/be_rvm.c    	\
+				be/tx.c
diff --git a/be/be.h b/be/be.h
index 55720d9..444f03f 100644
--- a/be/be.h
+++ b/be/be.h
@@ -178,49 +178,33 @@ struct m0_be_seg;
 struct m0_be_tx;
 struct m0_be_credit;
 struct m0_be_reg;
+//struct m0_be_buf;
 
 /* import */
-#include <malloc.h>
-#include "be/lib/be_tlist.h"
-#include "be/lib/be_buf.h"
 #include "sm/sm.h"
-#include "lib/thread.h"
 #include "addb/addb.h"
-#include "lib/memory.h"
-#include "lib/misc.h"
-
 #include "stob/stob.h"
-#include "stob/linux.h"
-#include "stob/linux_internal.h"
-
-#include "be/rvm.h"
-#include "be/rds.h"
+#include "lib/misc.h"
 
 #include "be/be_impl.h"
-
-#include "be/be_seg.h"
-#include "be/be_tx.h"
-#include "be/be_reg.h"
-#include "be/be_rvm.h"
-#include "be/be_magic.h"
-
-struct m0_be_buf;
+#include "be/lib/be_buf.h"
 
 /**
  * Initialises the in-memory part of domain structure. This function does not
  * initiate any IO.
  *
- * @post dom->bd_data.bs_sm.sm_state == M0_BESEG_CLOSED
+ * @post m0_be_seg_state_get(dom->bd_data) == M0_BESEG_CLOSED
  */
-//void m0_be_domain_init  (struct m0_be_domain *dom, struct m0_stob *stob,
-//                                      struct m0_stob *log_stob);
 M0_INTERNAL void m0_be_domain_init(struct m0_be_domain *dom,
+                                   struct m0_stob *stob,
+                                   struct m0_stob *log_stob,
                                    uint64_t dom_magic);
 
 /**
  * Finalises the in-memory part of domain structure.
  *
- * @pre M0_IN(dom->bd_data.bs_sm.sm_state, (M0_BESEG_CLOSED, M0_BESEG_FAILED))
+ * @pre M0_IN(m0_be_seg_state_get(dom->bd_data), (M0_BESEG_CLOSED,
+ *                                                M0_BESEG_FAILED))
  */
 M0_INTERNAL void m0_be_domain_fini(struct m0_be_domain *dom);
 
@@ -229,51 +213,46 @@ M0_INTERNAL void m0_be_domain_fini(struct m0_be_domain *dom);
  *
  * Note that this operation is *not* transactional (there is no domain yet).
  *
- * @pre dom->bd_data.bs_sm.sm_state == M0_BESEG_CLOSED
- * @pre M0_IN(dom->bd_data.bs_sm.sm_state, (M0_BESEG_CLOSED, M0_BESEG_FAILED,
- *                                          M0_BESEG_ACTIVE, M0_BESEG_CREATING))
+ * @pre m0_be_seg_state_get(dom->bd_data) == M0_BESEG_CLOSED
+ * @pre M0_IN(m0_be_seg_state_get(dom->bd_data), (M0_BESEG_CLOSED, 
+ *                                                M0_BESEG_FAILED, 
+ *                                                M0_BESEG_ACTIVE, 
+ *                                                M0_BESEG_CREATING))
  */
-/* void m0_be_domain_create(struct m0_be_domain *dom, struct m0_stob *stob); */
-M0_INTERNAL void m0_be_domain_create(struct m0_be_domain **dom);
+M0_INTERNAL void m0_be_domain_create(struct m0_be_domain *dom,
+                                     struct m0_stob *stob);
 
 /**
  * Searches a domain for the existing segment with a given name.
  *
- * @pre dom->bd_data.bs_sm.sm_state == M0_BESEG_ACTIVE
- * @pre seg->bs_sm.sm_state == M0_BESEG_CLOSED
+ * @pre m0_be_seg_state_get(dom->bd_data) == M0_BESEG_ACTIVE
+ * @pre m0_be_seg_state_get(seg) == M0_BESEG_CLOSED
  * @pre seg->bs_dom == dom
- * @post M0_IN(seg->bs_sm.sm_state, (M0_BESEG_OPENING, M0_BESEG_ACTIVE,
- *                                   M0_BESEG_FAILED))
+ * @post M0_IN(m0_be_seg_state_get(seg), (M0_BESEG_OPENING, M0_BESEG_ACTIVE,
+ *                                        M0_BESEG_FAILED))
  */
-
-/* void m0_be_domain_lookup(struct m0_be_domain *dom, const char *name,
-                         struct m0_be_seg *out); */
-
-M0_INTERNAL void m0_be_domain_lookup(struct m0_be_domain *dom,
-                                     const uint64_t segment_id,
-                                     struct m0_be_seg **out);
-
+M0_INTERNAL int m0_be_domain_lookup(struct m0_be_domain *dom, const char *name,
+                                    struct m0_be_seg *out);
 
 /**
- *
+ * Loads/Restores named segment in memory on recovery of kv-store.
  * Searches a domain for the existing segment with a given name.
  * Note - This function does not create new segment, if segment not found.
  *        This will return BE_SEG_FAILED for non existing segment lookups.
  *
- * @pre dom->bd_data.bs_sm.sm_state == M0_BESEG_ACTIVE
+ * @pre m0_be_seg_state_get(dom->bd_data) == M0_BESEG_ACTIVE
  * @pre seg->bs_dom == dom
- * @post M0_IN(seg->bs_sm.sm_state, (M0_BESEG_OPENING, M0_BESEG_ACTIVE,
- *                                   M0_BESEG_FAILED))
+ * @post M0_IN(m0_be_seg_state_get(seg), (M0_BESEG_OPENING, M0_BESEG_ACTIVE,
+ *                                        M0_BESEG_FAILED))
  */
-
-M0_INTERNAL void m0_be_domain_lookup_recover(struct m0_be_domain *dom,
-                                             const uint64_t       segment_id,
-                                             struct m0_be_seg   **out);
+M0_INTERNAL void m0_be_domain_lookup_restore(struct m0_be_domain *dom,
+                                             const char *name,
+                                             struct m0_be_seg *out);
 
 /**
  * Initialises the segment structure in memory.
  *
- * @post seg->bs_sm.sm_state == M0_BESEG_CLOSED
+ * @post m0_be_seg_state_get(seg) == M0_BESEG_CLOSED
  */
 M0_INTERNAL void m0_be_seg_init(struct m0_be_seg *seg, struct m0_be_domain *dom,
                                 struct m0_sm_group *sm_group, uint64_t flags);
@@ -281,80 +260,79 @@ M0_INTERNAL void m0_be_seg_init(struct m0_be_seg *seg, struct m0_be_domain *dom,
 /**
  * Initialises segment opening.
  *
- * @pre M0_IN(seg->bs_sm.sm_state, (M0_BESEG_CLOSED, M0_BESEG_CREATING))
- * @pre seg->bs_dom->bd_data.bs_sm.sm_state == M0_BESEG_ACTIVE
- * @post M0_IN(seg->bs_sm.sm_state, (M0_BESEG_OPENING,
- *                                   M0_BESEG_ACTIVE, M0_BESEG_FAILED))
+ * @pre M0_IN(m0_be_seg_state_get(seg), (M0_BESEG_CLOSED, M0_BESEG_CREATING))
+ * @pre m0_be_seg_state_get(dom->bd_data) == M0_BESEG_ACTIVE
+ * @post M0_IN(m0_be_seg_state_get(seg), (M0_BESEG_OPENING,
+ *                                        M0_BESEG_ACTIVE, M0_BESEG_FAILED))
  */
 M0_INTERNAL void m0_be_seg_open(struct m0_be_seg *seg);
 
 /**
- * @pre M0_IN(seg->bs_sm.sm_state, (M0_BESEG_CLOSED, M0_BESEG_FAILED))
+ * @pre M0_IN(m0_be_seg_state_get(seg), (M0_BESEG_CLOSED, M0_BESEG_FAILED))
  */
 M0_INTERNAL void m0_be_seg_fini(struct m0_be_seg *seg);
 
 /**
  * Starts creation of a new segment in the domain.
  *
- * @pre seg->bs_dom->bd_data.bs_sm.sm_state == M0_BESEG_ACTIVE
- * @pre seg->bs_sm.sm_state == M0_BESEG_CLOSED
- *
- * @post M0_IN(seg->bs_sm.sm_state, (M0_BESEG_CREATING,
- *                                   M0_BESEG_ACTIVE, M0_BESEG_FAILED))
+ * @pre m0_be_seg_state_get(dom->bd_data) == M0_BESEG_ACTIVE
+ * @pre m0_be_seg_state_get(seg) == M0_BESEG_CLOSED
+ * @post M0_IN(m0_be_seg_state_get(seg), (M0_BESEG_CREATING,
+ *                                        M0_BESEG_ACTIVE, M0_BESEG_FAILED))
  */
 M0_INTERNAL void m0_be_seg_create(struct m0_be_seg *seg, struct m0_be_tx *tx,
-                                  struct m0_stob *stob);
-
+                                  const char *name, struct m0_stob *stob);
 /**
  * Starts segment consistency check.
  *
- * @pre seg->bs_sm.sm_state == M0_BESEG_CLOSED
- * @post M0_IN(seg->bs_sm.sm_state, (M0_BESEG_CLOSED,
- *                                   M0_BESEG_CHECKING, M0_BESEG_FAILED))
+ * @pre m0_be_seg_state_get(seg) == M0_BESEG_CLOSED
+ * @post M0_IN(m0_be_seg_state_get(seg), (M0_BESEG_CLOSED,
+ *                                        M0_BESEG_CHECKING, M0_BESEG_FAILED))
  */
-M0_INTERNAL void m0_be_seg_check (struct m0_be_seg *seg, struct m0_be_tx *tx);
+M0_INTERNAL void m0_be_seg_check(struct m0_be_seg *seg, struct m0_be_tx *tx);
 
 /**
  * Starts segment deletion.
  *
- * @pre seg->bs_sm.sm_state == M0_BESEG_CLOSED
- * @post M0_IN(seg->bs_sm.sm_state, (M0_BESEG_CLOSED,
- *                                   M0_BESEG_DELETING, M0_BESEG_FAILED))
+ * @pre m0_be_seg_state_get(seg) == M0_BESEG_CLOSED
+ * @post M0_IN(m0_be_seg_state_get(seg), (M0_BESEG_CLOSED,
+ *                                        M0_BESEG_DELETING, M0_BESEG_FAILED))
  */
 M0_INTERNAL void m0_be_seg_delete(struct m0_be_seg *seg, struct m0_be_tx *tx);
 
 /**
  * Starts segment closing.
  *
- * @pre seg->bs_sm.sm_state == M0_BESEG_ACTIVE
- * @post M0_IN(seg->bs_sm.sm_state, (M0_BESEG_CLOSED,
- *                                   M0_BESEG_CLOSING, M0_BESEG_FAILED))
+ * @pre m0_be_seg_state_get(seg) == M0_BESEG_ACTIVE
+ * @post M0_IN(m0_be_seg_state_get(seg), (M0_BESEG_CLOSED,
+ *                                        M0_BESEG_CLOSING, M0_BESEG_FAILED))
  */
 M0_INTERNAL void m0_be_seg_done(struct m0_be_seg *seg);
 
 /**
  * Marks the segment as failed.
  *
- * @post seg->bs_sm.sm_state == M0_BESEG_FAILED
+ * @post m0_be_seg_state_get(seg) == M0_BESEG_FAILED
  */
 M0_INTERNAL void m0_be_seg_fail(struct m0_be_seg *seg);
 
 /**
- * @post reg->br_sm.sm_state == M0_BEREG_INIT
+ * Initializes segment in memory
+ *
+ * @post m0_be_reg_state_get(reg) == M0_BEREG_INIT
  */
-M0_INTERNAL void m0_be_reg_init(struct m0_be_reg **rout, struct m0_be_tx *tx,
-                                struct m0_be_seg *seg,  struct m0_be_buf *buf);
-
+M0_INTERNAL void m0_be_reg_init(struct m0_be_reg *reg, struct m0_be_tx *tx,
+                                struct m0_be_seg *seg, struct m0_be_buf *buf);
 /**
- * @pre reg->br_sm.sm_state != M0_BEREG_INPROGRESS
+ * @pre m0_be_reg_state_get(reg) != M0_BEREG_INPROGRESS
  */
 M0_INTERNAL void m0_be_reg_fini(struct m0_be_reg *reg);
 
 /**
  * Initialises the transaction structure.
  *
- * @pre dom->bd_data.bs_sm.sm_state == M0_BESEG_ACTIVE
- * @post tx->bt_sm.sm_state == M0_BETX_PREPARING
+ * @pre m0_be_seg_state_get(dom->bd_data) == M0_BESEG_ACTIVE
+ * @post m0_be_tx_state_get(tx) == M0_BETX_PREPARING
  * @post tx->bt_dom == dom
  */
 M0_INTERNAL void m0_be_tx_init(struct m0_be_tx *tx,
@@ -364,42 +342,42 @@ M0_INTERNAL void m0_be_tx_init(struct m0_be_tx *tx,
 /**
  * Indicates that a transaction will use certain amount of resources.
  *
- * @pre tx->bt_sm.sm_state == M0_BETX_PREPARING
+ * @pre m0_be_tx_state_get(tx) == M0_BETX_PREPARING
  */
 M0_INTERNAL void m0_be_tx_prep(struct m0_be_tx *tx);
 
 /**
  * Starts a prepared transaction.
  *
- * @pre tx->bt_sm.sm_state == M0_BETX_PREPARING
- * @post M0_IN(tx->bt_sm.sm_state, (M0_BETX_PREPARED, M0_BETX_OPEN,
- *                                  M0_BETX_FAILED))
+ * @pre m0_be_tx_state_get(tx) == M0_BETX_PREPARING
+ * @post M0_IN(m0_be_tx_state_get(tx), (M0_BETX_PREPARED, M0_BETX_OPEN,
+ *                                      M0_BETX_FAILED))
  */
 M0_INTERNAL void m0_be_tx_start(struct m0_be_tx *tx);
 
 /**
  * Closes a transaction.
  *
- * @pre tx->bt_sm.sm_state == M0_BETX_OPEN
- * @post M0_IN(tx->bt_sm.sm_state, (M0_BETX_CLOSED, M0_BETX_COMMITTED,
- *                                  M0_BETX_DONE, M0_BETX_FAILED))
+ * @pre m0_be_tx_state_get(tx) == M0_BETX_OPEN
+ * @post M0_IN(m0_be_tx_state_get(tx), (M0_BETX_CLOSED, M0_BETX_COMMITTED,
+ *                                      M0_BETX_DONE, M0_BETX_FAILED))
  */
 M0_INTERNAL void m0_be_tx_done(struct m0_be_tx *tx);
 
 /**
  * Finalises transaction structure.
  *
- * @pre M0_IN(tx->bt_sm.sm_state, (M0_BETX_DONE, M0_BETX_FAILED))
+ * @pre M0_IN(m0_be_tx_state_get(tx), (M0_BETX_DONE, M0_BETX_FAILED))
  */
 M0_INTERNAL void m0_be_tx_fini(struct m0_be_tx *tx);
 
 /**
  * Captures a region in a transaction.
  *
- * @pre tx->bt_sm.sm_state == M0_BETX_OPEN
- * @pre reg->br_sm.sm_state == M0_BEREG_INIT
- * @post M0_IN(reg->br_sm.sm_state, (M0_BEREG_INPROGRESS, M0_BEREG_SUCCEED,
- *                                   M0_BEREG_FAILED))
+ * @pre m0_be_tx_state_get(tx) == M0_BETX_OPEN
+ * @pre m0_be_reg_state_get(reg) == M0_BEREG_INIT
+ * @post M0_IN(m0_be_reg_state_get(reg), (M0_BEREG_INPROGRESS, M0_BEREG_SUCCEED,
+ *                                        M0_BEREG_FAILED))
  */
 M0_INTERNAL void m0_be_reg_capture(struct m0_be_reg *reg);
 
@@ -407,21 +385,20 @@ M0_INTERNAL void m0_be_reg_capture(struct m0_be_reg *reg);
 /**
  * Allocates a region.
  *
- * @pre reg->br_sm.sm_state == M0_BEREG_INIT
+ * @pre m0_be_reg_state_get(reg) == M0_BEREG_INIT
  * @pre reg->br_buf.b_addr == NULL
- * @post M0_IN(reg->br_sm.sm_state, (M0_BEREG_INPROGRESS, M0_BEREG_SUCCEED,
- *                                   M0_BEREG_FAILED))
+ * @post M0_IN(m0_be_reg_state_get(reg), (M0_BEREG_INPROGRESS, M0_BEREG_SUCCEED,
+ *                                        M0_BEREG_FAILED))
  */
 M0_INTERNAL void m0_be_alloc(struct m0_be_reg *reg);
 
 /**
  * Frees a region.
- *
  * Freeing NULL is a no-op.
  *
- * @pre reg->br_sm.sm_state == M0_BEREG_INIT
- * @post M0_IN(reg->br_sm.sm_state, (M0_BEREG_INPROGRESS, M0_BEREG_SUCCEED,
- *                                   M0_BEREG_FAILED))
+ * @pre m0_be_reg_state_get(reg) == M0_BEREG_INIT
+ * @post M0_IN(m0_be_reg_state_get(reg), (M0_BEREG_INPROGRESS, M0_BEREG_SUCCEED,
+ *                                        M0_BEREG_FAILED))
  */
 M0_INTERNAL void m0_be_free(struct m0_be_reg *reg);
 
@@ -431,7 +408,7 @@ M0_INTERNAL void m0_be_free(struct m0_be_reg *reg);
  * This doesn't incur a state change in region state machine and doesn't report
  * failures.
  *
- * @pre reg->br_sm.sm_state == M0_BEREG_INIT
+ * @pre m0_be_reg_state_get(reg) == M0_BEREG_INIT
  * @pre reg->br_buf.b_addr != NULL
  */
 M0_INTERNAL void m0_be_prefetch(const struct m0_be_reg *reg);
@@ -439,20 +416,20 @@ M0_INTERNAL void m0_be_prefetch(const struct m0_be_reg *reg);
 /**
  * Pins the region in memory, fetching it in first, if necessary.
  *
- * @pre reg->br_sm.sm_state == M0_BEREG_INIT
+ * @pre m0_be_reg_state_get(reg) == M0_BEREG_INIT
  * @pre reg->br_buf.b_addr != NULL
- * @post M0_IN(reg->br_sm.sm_state, (M0_BEREG_INPROGRESS, M0_BEREG_SUCCEED,
- *                                   M0_BEREG_FAILED))
+ * @post M0_IN(m0_be_reg_state_get(reg), (M0_BEREG_INPROGRESS, M0_BEREG_SUCCEED,
+ *                                        M0_BEREG_FAILED))
  */
 M0_INTERNAL void m0_be_get(const struct m0_be_reg *reg);
 
 /**
  * Un-pins the region, pinned by m0_be_get().
  *
- * @pre reg->br_sm.sm_state == M0_BEREG_INIT
+ * @pre m0_be_reg_state_get(reg) == M0_BEREG_INIT
  * @pre reg->br_buf.b_addr != NULL
- * @post M0_IN(reg->br_sm.sm_state, (M0_BEREG_INPROGRESS, M0_BEREG_SUCCEED,
- *                                   M0_BEREG_FAILED))
+ * @post M0_IN(m0_be_reg_state_get(reg), (M0_BEREG_INPROGRESS, M0_BEREG_SUCCEED,
+ *                                        M0_BEREG_FAILED))
  */
 M0_INTERNAL void m0_be_put(const struct m0_be_reg *reg);
 
@@ -460,9 +437,8 @@ M0_INTERNAL void m0_be_put(const struct m0_be_reg *reg);
  * A page in a segment.
  */
 struct m0_be_page {
-        /* Virtual address of be_page */
+        /* Address of be_page. */
         void            *bp_addr;
-
         uint64_t         offset;
         uint64_t         length;
 };
@@ -472,37 +448,26 @@ struct m0_be_page {
  */
 struct m0_be_seg {
         /** State machine. @see enum m0_be_seg_state. */
-
         struct m0_sm          bs_sm;
-
-        /* callback object for sm */
+        /** Callback object for ast. */
         struct m0_sm_ast      bs_sm_ast;
-
         /** Underlying storage object. */
         struct m0_stob       *bs_stob;
         /** Domain this segment belongs to. */
         struct m0_be_domain  *bs_dom;
         /** Linkage in the list of domain stobs: m0_be_dom::bd_seg. */
         struct m0_tlink       bs_linkage;
-
-        /* tlink magic field */
+        /** Magic for segment structure. */
         uint64_t              bs_magic;
-
         /** Starting address in primary store. This field is valid in
             M0_BESEG_ACTIVE state. */
-        void                 *bs_heap_addr;
-
+        void                 *bs_addr;
+        /** Static region start address for the segment. */
         void                 *bs_static_addr;
-
-        /* be_page which stores mapped page info */
-        /* @todo - this stores single page, we need to maintain list
-         * of mapped pages.
-         */
+        /* Stores mapped page info. */
         struct m0_be_page     bs_page;
-
         /** Addb context for this segment. */
         struct m0_addb_ctx    bs_addb;
-
         /** Implementation private fields. */
         struct m0_be_seg_impl bs_impl;
 };
@@ -517,24 +482,29 @@ struct m0_be_domain {
         struct m0_tl             bd_seg;
         /** List of active transactions. */
         struct m0_tl             bd_tx;
-        /** Domain wide magic*/
+        /** Magic to identify domain wide pointers. */
         uint64_t                 bd_magic;
-        /** Implementation private fields. */
+        /** Implementation of private fields. */
         struct m0_be_domain_impl bd_impl;
 };
 
 /**
  * Region callback data from transaction layer.
+ *
+ * The m0_be_tx_pre_cb function is used to check, any of the previous capture is
+ * failed. The return value is used in to take decision whether to capture 
+ * current region or not in region layer.
+ *
+ * The m0_be_tx_post_cb function is used to set the transaction status to 
+ * M0_BETX_PREPARED if all the region's captured successfully.
+ *
  */
-
 struct m0_be_capture_cb {
-        void *datum;
-
-        /* pre-capture callback */
-        int (* m0_be_tx_pre_cb)(void *);
-
-        /* post-capture callback */
-        void (* m0_be_tx_post_cb)(void *);
+        void    *datum;
+        /** Pre-Capture callback function. */
+        int    (*m0_be_tx_pre_cb)(void *tx);
+        /** Post-Capture callback function. */
+        void   (*m0_be_tx_post_cb)(void *tx);
 };
 
 /**
@@ -543,16 +513,14 @@ struct m0_be_capture_cb {
 struct m0_be_tx {
         /** State machine. @see enum m0_be_tx_state. */
         struct m0_sm             bt_sm;
-        /* callback object for sm */
+        /** Callback object for ast. */
         struct m0_sm_ast         bt_sm_ast;
         /** Domain of this transaction. */
         struct m0_be_domain     *bt_dom;
         /** Linkage in the list of active transactions, m0_be_dom::bd_tx. */
         struct m0_tlink          bt_linkage;
-
-        /* tlink magic field */
+        /** Magic to identify tx structure. */
         uint64_t                 bt_magic;
-
         /** Implementation private fields. */
         struct m0_be_tx_impl     bt_impl;
 };
@@ -563,11 +531,11 @@ struct m0_be_tx {
 struct m0_be_reg {
         /** State machine. @see enum m0_be_reg_state. */
         struct m0_sm br_sm;
-        /* callback object for sm */
+        /** Callback object for ast. */
         struct m0_sm_ast br_sm_ast;
         /** Transaction this region is used in. */
         struct m0_be_tx *br_tx;
-        /** This should be filled along with br_tx */
+        /** This should be filled along with br_tx. */
         struct m0_be_capture_cb br_tx_cbdata;
         /** Segment for this region */
         struct m0_be_seg *br_seg;
@@ -575,14 +543,49 @@ struct m0_be_reg {
         struct m0_be_buf br_buf;
         /** Linkage in the list of credit list, m0_be_credit::bc_tl */
         struct m0_tlink br_linkage;
-
-        /* tlink magic field */
+        /** Magic to identify reg structure. */
         uint64_t br_magic;
-
-        /** Implementation private fields. */
-        struct m0_be_reg_impl br_impl;
 };
 
+
+/**
+   @verbatim
+                                      |
+                                      | m0_be_seg_init()
+                                      V
+          +----------------------INITIALISED
+          |                           |
+          |                           | m0_be_seg_create()
+          |                           |
+          |     timed-out             V
+          +-----------------------CREATING
+	  |   create_failed           | create successful
+	  V                           |
+	FAILED <------+               |  
+	  |           |               +
+	  |           |               |
+	  |           |failed         |
+	  |           |               V
+	  |           +-------------OPENING
+	  |           |               |
+	  | fini()    |               | m0_be_seg_open()
+	  |           |               V
+	  |           +-------------ACTIVE
+	  |                           |
+	  |                           |
+	  |                           |
+	  |                           | m0_be_seg_done
+	  |                           V
+	  |                       CLOSING
+	  |                           |
+	  |                           | m0_be_seg_fini()
+	  |                           V
+	  +----------------------> CLOSED
+
+   @endverbatim
+
+*/
+
 enum m0_be_seg_state {
         M0_BESEG_INIT,
         M0_BESEG_CREATING,
@@ -597,6 +600,49 @@ enum m0_be_seg_state {
 };
 
 
+/**
+   @verbatim
+                                      |
+                                      | m0_be_tx_init()
+                                      V
+          +----------------------INITIALIZING
+          |                           |
+          |                           | 
+          |                           |
+          |     timed-out             V
+          +-----------------------INITIALIZED
+	  |   init_failed             | init successful
+	  |                           |
+	  |                           | m0_be_tx_start()
+	  |                           V
+          +-------------------------PREPARING
+	  |                           |
+	  |                           |
+	  |                           |
+	FAILED <------+               |  
+	  |           |               + m0_be_tx_prep()
+	  |           |               |
+	  |           |failed         |
+	  |           |               V
+	  |           +-------------PREPARED
+	  |           |               |
+	  | fini()    |               | 
+	  |           |               V
+	  |           +-------------OPEN
+	  |                           |
+	  |                           |
+	  |                           |
+	  |                           | m0_be_tx_done()
+	  |                           V
+	  |                         DONE
+	  |                           |
+	  |                           | 
+	  |                           V
+	  +----------------------> CLOSED
+
+   @endverbatim
+
+*/
 enum m0_be_tx_state {
         M0_BETX_INITIALIZING,
         M0_BETX_INIT,
@@ -610,6 +656,52 @@ enum m0_be_tx_state {
         M0_BETX_FAILED
 };
 
+/**
+   @verbatim
+                                      |
+                                      | m0_be_reg_init()
+                                      V
+          +----------------------INITIALIZED
+          |                           |
+          |                           | 
+          |                           |
+          |     timed-out             V
+          +-----------------------ALLOCATING
+	  |   alloc_failed            | allocation successful
+	  |                           |
+	  |                           | m0_be_alloc()
+	  |                           V
+          +------------------------ALLOCATED
+	  |                           |
+	  |                           |
+	  |                           |
+	FAILED <------+               |  
+	  |           |               + m0_be_reg_capture()
+	  |           |               |
+	  |           |failed         |
+	  |           |               V
+	  |           +-------------CAPTURING
+	  |           |               |
+	  | fini()    |               | 
+	  |           |               V
+	  |           +-------------CAPTURED
+	  |                           |
+	  |                           |
+	  |                           |
+	  |                           | m0_be_free()
+	  |                           V
+	  |                         FREEING
+	  |                           |
+	  |                           | 
+	  |                         FREED  
+	  |                           |
+	  |                           |
+	  |                           |
+	  +------------------------> DONE
+
+   @endverbatim
+
+*/
 enum m0_be_reg_state {
         M0_BEREG_INIT,
         M0_BEREG_ALLOCATING,
@@ -627,26 +719,17 @@ enum m0_be_domain_flags {
         M0_BEFL_GLOBAL  = (1 << 1)
 };
 
+/**
+ * The named segment header will contain these fields.
+ * @note - These are not used currently.
+ */
 struct m0_be_named_seg_hdr {
+        /** Entry index for last segment. */
         uint64_t max_segment_index;
+        /** Total segments in the domain. */
         uint64_t total_segments;
 };
 
-/* m0_tlist definition for segment list - m0_be_seg_tlist */
-M0_TL_DESCR_DEFINE(m0_be_seg, "m0_be_seg", static, struct m0_be_seg, bs_linkage,
-                   bs_magic, 0xc2be5e9c2be5e9c2, 0x2c9e5eb2c9e5eb2c);
-M0_TL_DEFINE(m0_be_seg, static, struct m0_be_seg);
-
-/* m0_tlist definition for active transaction list - m0_be_tx_tlist */
-M0_TL_DESCR_DEFINE(m0_be_tx, "m0_be_tx", static, struct m0_be_tx, bt_linkage,
-                   bt_magic, 0xc2be7478c2be7478, 0x8747eb2c8747eb2c);
-M0_TL_DEFINE(m0_be_tx, static, struct m0_be_tx);
-
-/* m0_tlist definition for credit list - m0_be_crd_tlist */
-M0_TL_DESCR_DEFINE(m0_be_reg, "m0_be_reg", static, struct m0_be_reg, br_linkage,
-                   br_magic, 0xc2be3248c1be3248, 0x8423eb1c8423eb2c);
-M0_TL_DEFINE(m0_be_reg, static, struct m0_be_reg);
-
 /** @} end of be group */
 
 /* __MERO_BE_BE_H__ */
diff --git a/be/be_domain.c b/be/be_domain.c
deleted file mode 100644
index 29bb32d..0000000
--- a/be/be_domain.c
+++ /dev/null
@@ -1,314 +0,0 @@
-/*
- * COPYRIGHT 2012 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Sachin Patil <sachin_patil@xyratex.com>
- * Original creation date: 08 Nov 2012
- */
-
-#include "be/be.h"
-
-/**
-  @addtogroup be_domain
-
-  <b>Implementation of back-end domain on top of back-end segments </b>
-
-  A domain is a collection of named segments. A domain has a special segment
-  called named segment which is used as a directory of other segments. A user
-  can add or remove segments to or from the domain and the back-end updates the
-  domain data accordingly.
-
-  @{
-  */
-
-/**
- * Initialises creation of a domain.
- *
- * Note that this operation is *not* transactional (there is no domain yet).
- *
- */
-
-M0_INTERNAL void m0_be_domain_create(struct m0_be_domain **out)
-{
-        struct m0_be_domain *dom = NULL;
-
-        *out = NULL;
-
-        M0_ALLOC_PTR(dom);
-        if (dom != NULL) {
-                *out = dom;
-        }
-
-}
-
-
-/**
- * Initialises the in-memory part of domain structure. This function does not
- * initiate any IO.
- *
- * @post dom->bd_data.bs_sm.sm_state == M0_BESEG_CLOSED
- */
-M0_INTERNAL void m0_be_domain_init(struct m0_be_domain *dom, uint64_t dom_magic)
-{
-        /* Asserting on required pointers */
-        M0_ASSERT(dom != NULL);
-
-        /* Initialise domain structure with required values */
-        /* Initialize domain wide magic */
-        dom->bd_magic = dom_magic;
-        /*
-        dom->bd_data.bs_stob    = stob;
-        dom->bd_impl.log_stob   = log_stob;
-        */
-
-        m0_be_seg_init(&(dom->bd_data), dom, &(dom->bd_impl.sm_group), 0);
-
-        /**
-         * @todo - Need to decide if m0_be_seg_init should be called
-         * instead of M0_BESEG_CLOSED state assignment
-         **/
-        dom->bd_data.bs_sm.sm_state = M0_BESEG_CLOSED;
-
-        /* Segment list initialization */
-        m0_be_seg_tlist_init(&(dom->bd_seg));
-
-        /* Transaction list initialization */
-        m0_be_tx_tlist_init(&(dom->bd_tx));
-
-        /* Initialize segment state machine */
-        M0_ALLOC_PTR(dom->bd_impl.th);
-
-        M0_ASSERT(dom->bd_impl.th != NULL);
-
-        m0_bs_sm_init(dom);
-
-        /**
-         * initialize rvm
-         * @todo - this initialization is per backend domain for now
-         * need to do it only once while initializing mero instance.
-         */
-        m0_be_rvm_init();
-
-        M0_POST(dom->bd_data.bs_sm.sm_state == M0_BESEG_CLOSED);
-
-}
-
-/**
- * Searches a domain for the existing segment with a given name.
- * If not found, then create new segment.
- *
- * @pre dom->bd_data.bs_sm.sm_state == M0_BESEG_ACTIVE
- * @pre seg->bs_sm.sm_state == M0_BESEG_CLOSED
- * @pre seg->bs_dom == dom
- * @post M0_IN(seg->bs_sm.sm_state, (M0_BESEG_OPENING, M0_BESEG_ACTIVE,
- *                                   M0_BESEG_FAILED))
- */
-M0_INTERNAL void m0_be_domain_lookup(struct m0_be_domain *dom,
-                                     const uint64_t segment_id,
-                                     struct m0_be_seg **out)
-{
-        struct m0_be_seg *seg_it;
-
-        /* Asserting on required conditions */
-        M0_ASSERT(dom != NULL);
-        M0_ASSERT(segment_id > 0);
-
-        M0_PRE(dom->bd_data.bs_sm.sm_state == M0_BESEG_ACTIVE);
-        /**
-         * @todo - Need to understand other 2 pre conditions should be checked
-         * for which segment - Named or the segment which is looked up just now
-         */
-
-        /**
-         * Iterate through segment tlist and check for requested segment_id
-         * This assumes all the list is in memory.
-         */
-        m0_tlist_for(&m0_be_seg_tl, &(dom->bd_seg), seg_it) {
-                if (segment_id == seg_it->bs_impl.segment_id) {
-                        *out = seg_it;
-                        break;
-                }
-        } m0_tlist_endfor;
-
-        /* This fills/adds segment into in-memory segment list on demand */
-        if (*out == NULL) {
-                /* @todo - Check into named segment list whether segment is
-                 * created or not
-                 * out = NULL;
-                 * m0_be_seg_tlist_add(&(dom->bd_seg), *out);
-                 */
-        }
-
-        if ( (*out != NULL)                              &&
-             (M0_BESEG_CLOSED == (*out)->bs_sm.sm_state) ) {
-                m0_be_seg_open(*out);
-        }
-
-        if (*out == NULL) {
-                /* If segment not created already then allocate, init, create */
-                /* Allocate memory for the objects */
-                /* @todo - This allocation could be blocking, may need to move
-                 * to state machine
-                 */
-
-                /* todo@ error handling for object allocation */
-                M0_ALLOC_PTR(*out);
-
-                (*out)->bs_impl.segment_id = segment_id;
-
-                m0_be_seg_tlink_init(*out);
-
-                /* Last 2 arguments - sm_grp and flags */
-                m0_be_seg_init(*out, dom, &(dom->bd_impl.sm_group), 0);
-
-                m0_be_seg_create(*out, NULL, NULL);
-                /* Last 3 arguments - transaction_ptr,
-                 *                    auto_increment_segment_id, stob
-                 */
-
-                m0_be_seg_tlist_add(&(dom->bd_seg), *out);
-        }
-}
-
-/**
- * Finalises the in-memory part of domain structure.
- *
- * @pre M0_IN(dom->bd_data.bs_sm.sm_state, (M0_BESEG_CLOSED, M0_BESEG_FAILED))
- */
-M0_INTERNAL void m0_be_domain_fini(struct m0_be_domain *dom)
-{
-        struct m0_be_seg         *seg_it;
-        struct m0_be_tx          *tx_it;
-
-        /* Back-end Named segment should be in closed or init failed state */
-        M0_PRE( (dom->bd_data.bs_sm.sm_state == M0_BESEG_CLOSED) ||
-                (dom->bd_data.bs_sm.sm_state == M0_BESEG_FAILED) );
-
-
-        /* iterate through txn tlist and call capture/fini on each one */
-        m0_tlist_for(&m0_be_tx_tl, &(dom->bd_tx), tx_it) {
-                m0_be_tx_tlink_del_fini(tx_it);
-                //m0_be_tx_fini(tx_it);
-        } m0_tlist_endfor;
-
-        /* iterate through segment tlist and call fini on each one */
-        m0_tlist_for(&m0_be_seg_tl, &(dom->bd_seg), seg_it) {
-                m0_be_seg_tlink_del_fini(seg_it);
-                m0_be_seg_fini(seg_it);
-        } m0_tlist_endfor;
-
-        /* Finilize segment list */
-        m0_be_seg_tlist_fini(&(dom->bd_seg));
-
-        /* Finilize transaction list */
-        m0_be_tx_tlist_fini(&(dom->bd_tx));
-
-        /* Finalize log device stob */
-        m0_stob_fini(dom->bd_impl.log_stob);
-
-        /* Free allocated memory */
-        /* m0_free(dom); */
-}
-
-/**
- * Searches a domain for the existing segment with a given name.
- * Note - This function does not create new segment, if segment not found.
- *        This will return BE_SEG_FAILED for non existing segment lookups.
- *
- * @pre dom->bd_data.bs_sm.sm_state == M0_BESEG_ACTIVE
- * @pre seg->bs_dom == dom
- * @post M0_IN(seg->bs_sm.sm_state, (M0_BESEG_OPENING, M0_BESEG_ACTIVE,
- *                                   M0_BESEG_FAILED))
- */
-
-M0_INTERNAL void m0_be_domain_lookup_recover(struct m0_be_domain *dom,
-                                             const uint64_t       segment_id,
-                                             struct m0_be_seg   **out)
-{
-        struct  m0_be_seg        *seg_it;
-        struct  m0_stob_domain   *stob_dom;
-        struct  m0_stob_id        stob_id = {{0, segment_id}};
-        int                       result;
-        bool                      stob_directio = true;
-
-        /* Asserting on required conditions */
-        M0_ASSERT(dom != NULL);
-        M0_ASSERT(segment_id > 0);
-
-        M0_PRE(dom->bd_data.bs_sm.sm_state == M0_BESEG_ACTIVE);
-
-        /**
-         * Iterate through segment tlist and check for requested segment_id
-         * This assumes all the list is in memory.
-         */
-        m0_tlist_for(&m0_be_seg_tl, &(dom->bd_seg), seg_it) {
-                if (segment_id == seg_it->bs_impl.segment_id) {
-                        *out = seg_it;
-                        break;
-                }
-        } m0_tlist_endfor;
-
-        if ( (*out != NULL)                              &&
-             (M0_BESEG_CLOSED == (*out)->bs_sm.sm_state) ) {
-                m0_be_seg_open(*out);
-        }
-
-
-        if (*out == NULL) {
-                /* Now allocate, init and open the segment */
-
-                /* todo@ error handling for object allocation */
-                M0_ALLOC_PTR(*out);
-
-                (*out)->bs_impl.segment_id = segment_id;
-
-                /* Last 2 arguments - sm_grp and flags */
-                m0_be_seg_init(*out, dom, &(dom->bd_impl.sm_group), 0);
-
-                m0_stob_type_init(&m0_linux_stob_type);
-                result = m0_stob_domain_locate(&m0_linux_stob_type,
-                                               "./__be",
-                                               &stob_dom);
-                M0_ASSERT(result == 0);
-
-                result = m0_linux_stob_setup(stob_dom, stob_directio);
-                M0_ASSERT(result == 0);
-
-                result = m0_stob_find(stob_dom, &stob_id, &((*out)->bs_stob));
-                M0_ASSERT(result == 0);
-
-                result = m0_stob_create((*out)->bs_stob, NULL);
-
-                if (result < 0) {
-                        (*out)->bs_stob->so_state = CSS_UNKNOWN;
-                }
-
-                m0_be_seg_open(*out);
-
-                m0_be_seg_tlink_init(*out);
-                m0_be_seg_tlist_add(&(dom->bd_seg), *out);
-        }
-}
-
-/** @} end group be_domain */
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
diff --git a/be/be_impl.h b/be/be_impl.h
index 798df62..8e72794 100644
--- a/be/be_impl.h
+++ b/be/be_impl.h
@@ -25,12 +25,13 @@
 /**
   @defgroup be (Meta-data) back-end
   @{
-  */
+*/
 
-#include "be/be.h"
+#include "sm/sm.h"
+#include "stob/stob.h"
+#include "be/rvm.h"
 
-/* export */
-struct m0_stob;
+#define MAXNAMELEN      1024
 
 /**
  * Backend Domain private implementation.
@@ -39,7 +40,7 @@ struct m0_be_domain_impl {
         /** Stob which is used as log device for entire back-end domain. */
         struct m0_stob         *log_stob;
         struct m0_sm_group      sm_group;
-        struct m0_thread       *th;
+        struct m0_thread        th;
 };
 
 /**
@@ -47,12 +48,10 @@ struct m0_be_domain_impl {
  */
 struct m0_be_seg_impl {
         /** Segment Id which is used to indentify segment uniquely. */
-        uint64_t                 segment_id;
-
+        uint64_t                segment_id;
+        char                    segment_name[MAXNAMELEN];
         /* Segment stob file path or device path  */
-        char                     path_name[MAXPATHLEN];
-
-        struct m0_sm_group      *sm_group;
+        char                    path_name[MAXPATHLEN];
 };
 
 /**
@@ -63,15 +62,6 @@ struct m0_be_tx_impl {
 
         /* Credit list of (m0_be_reg) regions associated with transaction */
         struct m0_tl             bc_tl;
-
-        struct m0_sm_group      *sm_group;
-};
-
-/**
- * Backend regions private implementation.
- */
-struct m0_be_reg_impl {
-        struct m0_sm_group *sm_group;
 };
 
 /** @} end of be group */
diff --git a/be/be_init.c b/be/be_init.c
new file mode 100644
index 0000000..a3f2d70
--- /dev/null
+++ b/be/be_init.c
@@ -0,0 +1,51 @@
+/*
+ * COPYRIGHT 2013 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: Sachin Patil <sachin_patil@xyratex.com>
+ * Original creation date: 25 Jan 2013
+ */
+
+#include "be/be.h"
+#include "be/be_init.h"
+#include "be/be_rvm.h"
+
+/**
+  @addtogroup be
+  @{
+*/
+
+M0_INTERNAL int m0_be_init(void)
+{
+        m0_be_rvm_init();
+
+        return 0;
+}
+
+M0_INTERNAL void m0_be_fini(void)
+{
+
+}
+
+/** @} end group be */
+
+/*
+ *  Local variables:
+ *  c-indentation-style: "K&R"
+ *  c-basic-offset: 8
+ *  tab-width: 8
+ *  fill-column: 80
+ *  scroll-step: 1
+ *  End:
+ */
diff --git a/be/be_init.h b/be/be_init.h
new file mode 100644
index 0000000..086487a
--- /dev/null
+++ b/be/be_init.h
@@ -0,0 +1,55 @@
+/*
+ * COPYRIGHT 2013 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: Sachin Patil <sachin_patil@xyratex.com>
+ * Original creation date: 25 Jan 2013
+ */
+
+#pragma once
+
+#ifndef __MERO_BE_BE_INIT_H__
+#define __MERO_BE_BE_INIT_H__
+
+/**
+  @defgroup be (Meta-data) back-end
+  @{
+*/
+
+/**
+ * Backend initialization function.
+ * This function will be called while initializing mero instance(mero/init.c).
+ */
+M0_INTERNAL int m0_be_init(void);
+
+/**
+ * Backend initialization function.
+ * This function will be called while finalizing mero instance(mero/init.c).
+ */
+M0_INTERNAL void m0_be_fini(void);
+
+/** @} end of be group */
+
+/* __MERO_BE_BE_INIT_H__ */
+#endif
+
+/*
+ *  Local variables:
+ *  c-indentation-style: "K&R"
+ *  c-basic-offset: 8
+ *  tab-width: 8
+ *  fill-column: 80
+ *  scroll-step: 1
+ *  End:
+ */
diff --git a/be/be_magic.h b/be/be_magic.h
deleted file mode 100644
index 2fe0680..0000000
--- a/be/be_magic.h
+++ /dev/null
@@ -1,52 +0,0 @@
-/*
- * COPYRIGHT 2013 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Sachin Patil <sachin_patil@xyratex.com>
- * Original creation date: 07 Jan 2013
- */
-
-#pragma once
-
-#ifndef __MERO_BE_BE_MAGIC_H__
-#define __MERO_BE_BE_MAGIC_H__
-
-/**
-  @defgroup be_magic
-  @{
-  */
-
-/**
- * Backend Domain Magic declarations
- */
-
-enum m0_be_magic {
-        /* be_domain::be_dom_magic (cca11a5ca11ed) */
-        BE_DOMAIN_MAGIC = 0x33ca11a5ca11ed77
-};
-
-/** @} end of be_magic interface */
-
-/* __MERO_BE_BE_RVM_H__ */
-#endif
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
diff --git a/be/be_private.h b/be/be_private.h
new file mode 100644
index 0000000..6aaee05
--- /dev/null
+++ b/be/be_private.h
@@ -0,0 +1,57 @@
+/*
+ * COPYRIGHT 2013 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: Sachin Patil <sachin_patil@xyratex.com>
+ * Original creation date: 22 Jan 2013
+ */
+
+#pragma once
+
+#ifndef __MERO_BE_BE_PRIVATE_H__
+#define __MERO_BE_BE_PRIVATE_H__
+
+/**
+  @defgroup be
+  @{
+*/
+
+#include "mero/magic.h"
+
+M0_TL_DESCR_DEFINE(m0_be_seg, "m0_be_seg", static, struct m0_be_seg, bs_linkage,
+                   bs_magic, M0_BE_SEG_MAGIC, M0_BE_SEG_HDR_MAGIC);
+M0_TL_DEFINE(m0_be_seg, static inline, struct m0_be_seg);
+
+M0_TL_DESCR_DEFINE(m0_be_tx, "m0_be_tx", static, struct m0_be_tx, bt_linkage,
+                   bt_magic, M0_BE_TX_MAGIC, M0_BE_TX_HDR_MAGIC);
+M0_TL_DEFINE(m0_be_tx, static inline, struct m0_be_tx);
+
+M0_TL_DESCR_DEFINE(m0_be_reg, "m0_be_reg", static, struct m0_be_reg, br_linkage,
+                   br_magic, M0_BE_REG_MAGIC, M0_BE_REG_HDR_MAGIC);
+M0_TL_DEFINE(m0_be_reg, static inline, struct m0_be_reg);
+
+/** @} end of be */
+
+/* __MERO_BE_BE_PRIVATE_H__ */
+#endif
+
+/*
+ *  Local variables:
+ *  c-indentation-style: "K&R"
+ *  c-basic-offset: 8
+ *  tab-width: 8
+ *  fill-column: 80
+ *  scroll-step: 1
+ *  End:
+ */
diff --git a/be/be_reg.c b/be/be_reg.c
deleted file mode 100644
index 306c83b..0000000
--- a/be/be_reg.c
+++ /dev/null
@@ -1,511 +0,0 @@
-/*
- * COPYRIGHT 2012 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Sachin Patil <sachin_patil@xyratex.com>
- * Original creation date: 30 Nov 2012
- */
-
-#include "be/be.h"
-
-/**
-        Back-end
-
-  @addtogroup be
-  @{
-  */
-
-/* State machine variable declarations  */
-static const struct m0_sm_state_descr reg_states[] = {
-        [M0_BEREG_INIT] = {
-                .sd_flags     = M0_SDF_INITIAL,
-                .sd_name      = "BE REG INIT",
-                .sd_in        = NULL,
-                .sd_ex        = NULL,
-                .sd_invariant = NULL,
-                .sd_allowed   = (1 << M0_BEREG_ALLOCATING)      |
-                                (1 << M0_BEREG_FREEING)         |
-                                (1 << M0_BEREG_CAPTURING)       |
-                                (1 << M0_BEREG_FAILED)
-        },
-        [M0_BEREG_ALLOCATING] = {
-                .sd_flags     = 0,
-                .sd_name      = "BE REG ALLOCATING",
-                .sd_in        = NULL,
-                .sd_ex        = NULL,
-                .sd_invariant = NULL,
-                .sd_allowed   = (1 << M0_BEREG_ALLOCATED)       |
-                                (1 << M0_BEREG_FAILED)
-        },
-        [M0_BEREG_ALLOCATED] = {
-                .sd_flags     = 0,
-                .sd_name      = "BE REG ALLOCATED",
-                .sd_in        = NULL,
-                .sd_ex        = NULL,
-                .sd_invariant = NULL,
-                .sd_allowed   = (1 << M0_BEREG_CAPTURING)       |
-                                (1 << M0_BEREG_FREEING)         |
-                                (1 << M0_BEREG_FAILED)
-        },
-        [M0_BEREG_CAPTURING] = {
-                .sd_flags     = 0,
-                .sd_name      = "BE REG CAPTURING",
-                .sd_in        = NULL,
-                .sd_ex        = NULL,
-                .sd_invariant = NULL,
-                .sd_allowed   = (1 << M0_BEREG_CAPTURED)        |
-                                (1 << M0_BEREG_DONE)            |
-                                (1 << M0_BEREG_FAILED)
-        },
-        [M0_BEREG_CAPTURED] = {
-                .sd_flags     = 0,
-                .sd_name      = "BE REG CAPTURED",
-                .sd_in        = NULL,
-                .sd_ex        = NULL,
-                .sd_invariant = NULL,
-                .sd_allowed   = (1 << M0_BEREG_DONE)            |
-                                (1 << M0_BEREG_FAILED)
-        },
-        [M0_BEREG_DONE] = {
-                .sd_flags     = M0_SDF_FINAL,
-                .sd_name      = "BE REG DONE",
-                .sd_in        = NULL,
-                .sd_ex        = NULL,
-                .sd_invariant = NULL,
-                .sd_allowed   = (1 << M0_BEREG_FREEING)
-        },
-        [M0_BEREG_FREEING] = {
-                .sd_flags     = 0,
-                .sd_name      = "BE REG FREEING",
-                .sd_in        = NULL,
-                .sd_ex        = NULL,
-                .sd_invariant = NULL,
-                .sd_allowed   = (1 << M0_BEREG_FREED)           |
-                                (1 << M0_BEREG_FAILED)
-        },
-        [M0_BEREG_FREED] = {
-                .sd_flags     = M0_SDF_TERMINAL,
-                .sd_name      = "BE REG FREED",
-                .sd_in        = NULL,
-                .sd_ex        = NULL,
-                .sd_invariant = NULL,
-                .sd_allowed   = 0,
-        },
-        [M0_BEREG_FAILED] = {
-                .sd_flags     = M0_SDF_FAILURE,
-                .sd_name      = "BE REG FAILED",
-                .sd_in        = NULL,
-                .sd_ex        = NULL,
-                .sd_invariant = NULL,
-                .sd_allowed   = (1 << M0_BEREG_FREEING)         |
-                                (1 << M0_BEREG_FAILED)
-        },
-};
-
-static const struct m0_sm_conf reg_conf = {
-        .scf_name      = "REG States",
-        .scf_nr_states = ARRAY_SIZE(reg_states),
-        .scf_state     = reg_states
-};
-
-
-static void *static_reg_start_addr = NULL;
-
-/**
- * @post reg->br_sm.sm_state == M0_BEREG_INIT
- */
-M0_INTERNAL void m0_be_reg_init(struct m0_be_reg **reg_out, struct m0_be_tx *tx,
-                                struct m0_be_seg *seg,  struct m0_be_buf *buf)
-{
-        struct m0_be_reg *reg;
-
-        /* Asserting on required pointers */
-        M0_ASSERT(reg_out != NULL);
-        M0_ASSERT(seg != NULL);
-        M0_ASSERT(buf != NULL);
-
-        M0_ALLOC_PTR(reg);
-
-        if (reg == NULL) {
-                /* TODO@ : malloc failed */
-                goto exit_error;
-        }
-
-        /* Initialise region structure with required values */
-        reg->br_tx  = tx;
-        reg->br_tx_cbdata.datum = NULL;
-        reg->br_tx_cbdata.m0_be_tx_pre_cb = m0_be_tx_get_capture_status;
-        reg->br_tx_cbdata.m0_be_tx_post_cb = m0_be_tx_set_capture_status;
-
-        reg->br_seg = seg;
-
-        /* sm_group is taken from tx, but we can take it from seg also */
-        reg->br_impl.sm_group = seg->bs_impl.sm_group;
-
-        reg->br_buf.b_nob = buf->b_nob;
-        reg->br_buf.logical_address = buf->logical_address;
-
-        /* Lock sm group */
-        m0_sm_group_lock(reg->br_impl.sm_group);
-
-        /* Register the state machine of the tx into sm_group */
-        m0_sm_init(&(reg->br_sm), &reg_conf, M0_BEREG_INIT,
-                                        reg->br_impl.sm_group, NULL);
-
-        /* Unlock locked sm group */
-        m0_sm_group_unlock(reg->br_impl.sm_group);
-
-        *reg_out = reg;
-
-exit_error:
-        return;
-}
-
-/**
- * Allocates a region.
- * Updates m0_reference of region that can be used to persist pointers
- *
- * @pre reg->br_sm.sm_state == M0_BEREG_INIT
- * @pre reg->br_buf.b_addr == NULL
- * @post M0_IN(reg->br_sm.sm_state, (M0_BEREG_ALLOCATING, M0_BEREG_ALLOCATED,
- *                                   M0_BEREG_FAILED))
- */
-
-M0_INTERNAL void m0_be_alloc(struct m0_be_reg *reg)
-{
-        /* Asserting on required pointers */
-        M0_ASSERT(reg != NULL);
-
-        /* Locking sm group before setting sm_state */
-        m0_sm_group_lock(reg->br_impl.sm_group);
-
-        m0_sm_state_set(&(reg->br_sm), M0_BEREG_ALLOCATING);
-
-        /* Unlock locked sm group */
-        m0_sm_group_unlock(reg->br_impl.sm_group);
-
-        reg->br_sm_ast.sa_cb    = m0_be_alloc_cb;
-        reg->br_sm_ast.sa_datum = (void *)reg;
-
-        m0_be_reg_req_post(reg->br_impl.sm_group, &(reg->br_sm_ast));
-}
-
-/**
- * Frees a region.
- *
- * Freeing NULL is a no-op.
- *
- * @pre M0_IN(reg->br_sm.sm_state, (M0_BEREG_INIT, M0_BEREG_ALLOCATED,
- *                                  M0_BEREG_DONE, M0_BEREG_FAILED))
- * @post M0_IN(reg->br_sm.sm_state, (M0_BEREG_FREEING, M0_BEREG_FREED,
- *                                   M0_BEREG_FAILED))
- */
-M0_INTERNAL void m0_be_free(struct m0_be_reg *reg)
-{
-        /* Asserting on required pointers */
-        M0_ASSERT(reg != NULL);
-
-        /* @todo - Need to understand pre condition check */
-        /* Locking sm group before setting sm_state */
-        m0_sm_group_lock(reg->br_impl.sm_group);
-        m0_sm_state_set(&(reg->br_sm), M0_BEREG_FREEING);
-        /* Unlock locked sm group */
-        m0_sm_group_unlock(reg->br_impl.sm_group);
-
-        reg->br_sm_ast.sa_cb    = m0_be_free_cb;
-        reg->br_sm_ast.sa_datum = (void *)reg;
-
-        m0_be_reg_req_post(reg->br_impl.sm_group, &(reg->br_sm_ast));
-}
-
-/**
- * Pre-fetches a region.
- *
- * This doesn't incur a state change in region state machine and doesn't report
- * failures.
- *
- * @pre reg->br_sm.sm_state == M0_BEREG_INIT
- * @pre reg->br_buf.b_addr != NULL
- */
-M0_INTERNAL void m0_be_prefetch(const struct m0_be_reg *reg)
-{
-
-}
-
-
-/**
- * Un-pins the region, pinned by m0_be_get().
- *
- * @pre reg->br_sm.sm_state == M0_BEREG_INIT
- * @pre reg->br_buf.b_addr != NULL
- * @post M0_IN(reg->br_sm.sm_state, (M0_BEREG_INPROGRESS, M0_BEREG_SUCCEED,
- *                                   M0_BEREG_FAILED))
- */
-M0_INTERNAL void m0_be_put(const struct m0_be_reg *reg)
-{
-
-}
-
-/**
- * Captures a region in a transaction.
- *
- * @pre tx->bt_sm.sm_state == M0_BETX_OPEN
- * @pre M0_IN(reg->br_sm.sm_state, (M0_BEREG_INIT, M0_BEREG_ALLOCATED))
- * @post M0_IN(reg->br_sm.sm_state, (M0_BEREG_CAPTURING, M0_BEREG_CAPTURED,
- *                                   M0_BEREG_FAILED))
- */
-M0_INTERNAL void m0_be_reg_capture(struct m0_be_reg *reg)
-{
-        int grp_locked = 0;
-
-        /* Asserting on required pointers */
-        M0_ASSERT(reg != NULL);
-        M0_ASSERT(reg->br_tx != NULL);
-
-        //M0_PRE(reg->br_sm.sm_state == M0_BEREG_INIT);
-        M0_PRE(M0_IN(reg->br_sm.sm_state, (M0_BEREG_INIT, M0_BEREG_ALLOCATED)));
-
-        /* Locking sm group before setting sm_state if not locked */
-        if(!m0_mutex_is_locked(&(reg->br_impl.sm_group->s_lock))) {
-                grp_locked = 1;
-                m0_sm_group_lock(reg->br_impl.sm_group);
-        }
-
-        m0_sm_state_set(&(reg->br_sm), M0_BEREG_CAPTURING);
-
-        /* Unlock locked sm group if locked locally */
-        if(grp_locked)
-                m0_sm_group_unlock(reg->br_impl.sm_group);
-
-        reg->br_sm_ast.sa_cb    = m0_be_reg_capture_cb;
-        reg->br_sm_ast.sa_datum = (void *)reg;
-
-        m0_be_reg_req_post(reg->br_impl.sm_group, &(reg->br_sm_ast));
-
-}
-
-/**
- * @pre M0_IN(reg->br_sm.sm_state, (M0_BEREG_DONE, M0_BEREG_FAILED))
- */
-M0_INTERNAL void m0_be_reg_fini(struct m0_be_reg *reg)
-{
-
-        M0_PRE(M0_IN(reg->br_sm.sm_state, (M0_BEREG_DONE, M0_BEREG_FAILED)));
-
-        /* release memory allocated in m0_be_reg_init */
-        m0_free(reg);
-
-        /* todo@ Finalizing on state machine */
-}
-
-/**
- * The function posts reg request to state machine thread
- *
- */
-M0_INTERNAL void m0_be_reg_req_post(struct m0_sm_group *sm_group,
-                                 struct m0_sm_ast *sm_ast)
-{
-        m0_sm_ast_post(sm_group, sm_ast);
-}
-
-/**
- * Callback function for allocation of region
- *
- */
-
-M0_INTERNAL void m0_be_alloc_cb(struct m0_sm_group *sm_group,
-                                  struct m0_sm_ast *sm_ast)
-{
-        struct m0_be_reg *reg;
-        struct m0_uint128 *toffset;
-        rvm_tid_t *tid = NULL;
-        int             err;
-        uint64_t hi;
-        long int lo;
-
-        /* Asserting on required pointers */
-        M0_ASSERT(sm_group != NULL);
-        M0_ASSERT(sm_ast != NULL);
-
-        reg = (struct m0_be_reg *)sm_ast->sa_datum;
-
-        M0_ASSERT(reg != NULL);
-
-        if (reg->br_tx != NULL)
-                tid = reg->br_tx->bt_impl.tx_id;
-
-        reg->br_buf.b_addr = (void *)rds_malloc(reg->br_buf.b_nob,
-                                                tid, &err);
-
-
-        /* Assign domain magic to reg reference magic  to identify references
-         * within the domain.
-         */
-        reg->br_buf.logical_address.magic = reg->br_seg->bs_dom->bd_magic;
-
-        toffset = &(reg->br_buf.logical_address.segid_offset);
-
-        hi = reg->br_seg->bs_impl.segment_id;
-        lo = (reg->br_seg->bs_heap_addr - reg->br_buf.b_addr);
-
-
-       if (lo < 0)
-                 lo = -1 * lo;
-
-        toffset->u_hi = hi;
-        toffset->u_lo = lo;
-
-        m0_sm_state_set(&(reg->br_sm), M0_BEREG_ALLOCATED);
-
-        return;
-}
-
-/**
- * Callback function for freeing of region
- *
- */
-
-M0_INTERNAL void m0_be_free_cb(struct m0_sm_group *sm_group,
-                                  struct m0_sm_ast *sm_ast)
-{
-        int             err;
-        rvm_tid_t      *tid = NULL;
-        struct m0_be_reg *reg;
-
-        /* Asserting on required pointers */
-        M0_ASSERT(sm_group != NULL);
-        M0_ASSERT(sm_ast != NULL);
-
-        reg = (struct m0_be_reg *)sm_ast->sa_datum;
-
-        M0_ASSERT(reg != NULL);
-
-        if (reg->br_tx != NULL)
-                tid = reg->br_tx->bt_impl.tx_id;
-        /*
-         * Allocate memory from RDS Heap.
-         * Update br_buf to store virtual address.
-         */
-
-        rds_free((char *)reg->br_buf.b_addr, tid, &err);
-
-        if (err != SUCCESS)
-                goto error_exit;
-
-        reg->br_buf.b_addr                              = NULL;
-        reg->br_buf.logical_address.segid_offset.u_hi   = 0;
-        reg->br_buf.logical_address.segid_offset.u_lo   = 0;
-
-        m0_sm_state_set(&(reg->br_sm), M0_BEREG_FREED);
-
-error_exit:
-        m0_sm_state_set(&(reg->br_sm), M0_BEREG_FAILED);
-}
-
-
-/**
- * Callback function for capturing region
- *
- */
-M0_INTERNAL void m0_be_reg_capture_cb(struct m0_sm_group *sm_group,
-                                      struct m0_sm_ast *sm_ast)
-{
-        struct m0_be_reg *reg;
-        rvm_return_t ret;
-        int result;
-        enum m0_be_reg_state reg_st = M0_BEREG_FAILED;
-
-
-        /* Asserting on required pointers */
-        M0_ASSERT(sm_group != NULL);
-        M0_ASSERT(sm_ast != NULL);
-
-        reg = (struct m0_be_reg *)sm_ast->sa_datum;
-
-        M0_ASSERT(reg != NULL);
-
-        if(reg->br_tx_cbdata.datum) {
-                result = reg->br_tx_cbdata.m0_be_tx_pre_cb(
-                                        reg->br_tx_cbdata.datum);
-                /**
-                 * Do not perform rvm_set_range on current region if region
-                 * capture is failed for any previous region
-                 */
-                if( result == M0_BETX_PREP_FAILED) {
-                        reg_st = M0_BEREG_DONE;
-                        goto reg_done_exit;
-                }
-         }
-
-        ret = rvm_set_range(reg->br_tx->bt_impl.tx_id,
-                            reg->br_buf.b_addr,
-                            reg->br_buf.b_nob);
-
-        if(RVM_SUCCESS == ret)
-                reg_st = M0_BEREG_CAPTURED;
-
-
-reg_done_exit:
-        m0_sm_state_set(&(reg->br_sm), reg_st);
-
-        if(reg->br_tx_cbdata.datum) {
-                reg->br_tx_cbdata.m0_be_tx_post_cb(reg->br_tx_cbdata.datum);
-        }
-}
-
-/**
- * Handle store support APIs
- * Due to RVM limitation of single segment support,
- * the static region from segment is used as a handle store.
- */
-M0_INTERNAL void m0_be_static_reg_init(void *start_addr)
-{
-        static_reg_start_addr = start_addr;
-}
-
-M0_INTERNAL void m0_be_static_reg_capture_buf(uint64_t offset,
-                                              struct m0_be_buf *ubuf,
-                                              struct m0_be_seg *seg,
-                                              struct m0_be_tx *tx)
-{
-        struct m0_be_reg       *reg;
-        struct m0_be_buf        buf;
-
-        m0_be_buf_init(&buf, NULL, ubuf->b_nob, 0, 0, 0);
-
-        buf.b_addr = static_reg_start_addr + offset;
-
-        m0_be_reg_init(&reg, NULL, seg, &buf);
-
-        m0_be_tx_add_cred(tx, reg);
-
-        m0_be_tx_prep(tx);
-}
-
-M0_INTERNAL void *m0_be_static_reg_get_handle_addr(uint64_t offset)
-{
-        return (static_reg_start_addr + offset);
-}
-
-/** @} end group be */
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
diff --git a/be/be_reg.h b/be/be_reg.h
deleted file mode 100644
index 2457432..0000000
--- a/be/be_reg.h
+++ /dev/null
@@ -1,65 +0,0 @@
-/*
- * COPYRIGHT 2012 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Sachin Patil <sachin_patil@xyratex.com>
- * Original creation date: 27 Dec 2012
- */
-
-#pragma once
-
-#ifndef __MERO_BE_BE_REG_H__
-#define __MERO_BE_BE_REG_H__
-
-/**
-  @defgroup be (Meta-data) back-end
-  @{
-  */
-#include "be/be.h"
-
-M0_INTERNAL void m0_be_alloc_cb(struct m0_sm_group  *sm_group,
-                                struct m0_sm_ast *sm_ast);
-
-M0_INTERNAL void m0_be_free_cb(struct m0_sm_group *sm_group,
-                               struct m0_sm_ast *sm_ast);
-
-M0_INTERNAL void m0_be_reg_capture_cb(struct m0_sm_group *sm_group,
-                                      struct m0_sm_ast *sm_ast);
-
-M0_INTERNAL void m0_be_reg_req_post(struct m0_sm_group *sm_group,
-                                    struct m0_sm_ast *sm_ast);
-
-M0_INTERNAL void m0_be_static_reg_init();
-
-M0_INTERNAL void m0_be_static_reg_capture_buf(uint64_t offset,
-                                             struct m0_be_buf *buf,
-                                             struct m0_be_seg *seg,
-                                             struct m0_be_tx *tx);
-
-M0_INTERNAL void *m0_be_static_reg_get_handle_addr(uint64_t offset);
-
-/** @} end of be group */
-
-/* __MERO_BE_BE_REG_H__ */
-#endif
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
diff --git a/be/be_rvm.c b/be/be_rvm.c
index 12be84b..5a01362 100644
--- a/be/be_rvm.c
+++ b/be/be_rvm.c
@@ -19,10 +19,14 @@
 
 #include "be/be.h"
 
+
 /**
   @addtogroup be_rvm
   @{
   */
+const char *log_file="/tmp/log_file";
+
+extern void *RecoverableHeapStartAddress;
 
 
 /**
@@ -39,7 +43,7 @@ void m0_be_rvm_init()
         M0_ASSERT(options != NULL);
 
         options->flags |= RVM_ALL_OPTIMIZATIONS;
-        options->log_dev = LOG_FILE;
+        options->log_dev = (char *)log_file;
         options->create_log_file = rvm_true;
         options->create_log_size = RVM_MK_OFFSET(0,20971520);
         options->create_log_mode = 0600;
@@ -49,7 +53,6 @@ void m0_be_rvm_init()
         M0_ASSERT(retval == RVM_SUCCESS);
 
         rvm_free_options(options);
-
 };
 
 void *m0_be_rvm_get_heapaddr()
diff --git a/be/be_rvm.h b/be/be_rvm.h
index f010828..560d299 100644
--- a/be/be_rvm.h
+++ b/be/be_rvm.h
@@ -23,18 +23,20 @@
 #define __MERO_BE_BE_RVM_H__
 
 /**
-  @defgroup be_rvm interface
+  @defgroup be interface
   @{
   */
-#define LOG_FILE  "/tmp/log_file"
-
-extern void *RecoverableHeapStartAddress;
-
+/*
+ * Initializes RVM.
+ */
 void m0_be_rvm_init();
 
+/*
+ * Returns address of the heap start form the RVM segment.
+ */
 void *m0_be_rvm_get_heapaddr();
 
-/** @} end of be_rvm interface */
+/** @} end of be interface */
 
 /* __MERO_BE_BE_RVM_H__ */
 #endif
diff --git a/be/be_seg.c b/be/be_seg.c
deleted file mode 100644
index edebef5..0000000
--- a/be/be_seg.c
+++ /dev/null
@@ -1,717 +0,0 @@
-/*
- * COPYRIGHT 2012 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Sachin Patil <sachin_patil@xyratex.com>
- * Original creation date: 12 Nov 2012
- */
-
-#include "be/be.h"
-
-/**
-  @addtogroup be_seg
-
-  <b>Implementation of back-end segments </b>
-
-  A segment is a contiguous extent in primary store backed by persistent store.
-  Level 0 uses Mero storage objects (m0_stob) to access persistent store.
-  At the level 0, the segment is just an array of bytes, uninterpreted by
-  back-end. Level 0 allows user to load a segment in primary store partially
-  or completely. User can query and modify the segment data.
-  Updates to the segment are written back to the persistent store.
-
-  @{
-  */
-
-/* State machine states for backend segment */
-
-static const struct m0_sm_state_descr m0_be_seg_states[] = {
-        [M0_BESEG_INIT] = {
-                .sd_flags     = M0_SDF_INITIAL,
-                .sd_name      = "BE SEG INIT",
-                .sd_in        = NULL,
-                .sd_ex        = NULL,
-                .sd_invariant = NULL,
-                .sd_allowed   = (1 << M0_BESEG_CREATING) |
-                                (1 << M0_BESEG_OPENING)  |
-                                (1 << M0_BESEG_FAILED)
-        },
-
-        [M0_BESEG_CREATING] = {
-                .sd_flags     = 0,
-                .sd_name      = "BE SEG CREATING",
-                .sd_in        = NULL,
-                .sd_ex        = NULL,
-                .sd_invariant = NULL,
-                .sd_allowed   = (1 << M0_BESEG_ACTIVE)  |
-                                (1 << M0_BESEG_FAILED)
-        },
-        /**
-         * [M0_BESEG_CREATED] = {
-                .sd_flags     = 0,
-                .sd_name      = "BE SEG CREATED",
-                .sd_in        = NULL,
-                .sd_ex        = NULL,
-                .sd_invariant = NULL,
-                .sd_allowed   = (1 << M0_BESEG_OPENING)  |
-                                (1 << M0_BESEG_ACTIVE)   |
-                                (1 << M0_BESEG_FAILED)
-         * },
-         */
-
-        [M0_BESEG_OPENING] = {
-                .sd_flags     = 0,
-                .sd_name      = "BE SEG OPENING",
-                .sd_in        = NULL,
-                .sd_ex        = NULL,
-                .sd_invariant = NULL,
-                .sd_allowed   = (1 << M0_BESEG_ACTIVE)   |
-                                (1 << M0_BESEG_FAILED)
-        },
-
-        [M0_BESEG_ACTIVE] = {
-                .sd_flags     = 0,
-                .sd_name      = "BE SEG ACTIVE",
-                .sd_in        = NULL,
-                .sd_ex        = NULL,
-                .sd_invariant = NULL,
-                .sd_allowed   = (1 << M0_BESEG_CLOSING)  |
-                                (1 << M0_BESEG_CLOSED)   |
-                                (1 << M0_BESEG_FAILED)
-        },
-
-        [M0_BESEG_CLOSING] = {
-                .sd_flags     = 0,
-                .sd_name      = "BE SEG CLOSING",
-                .sd_in        = NULL,
-                .sd_ex        = NULL,
-                .sd_invariant = NULL,
-                .sd_allowed   = (1 << M0_BESEG_CLOSED)   |
-                                (1 << M0_BESEG_FAILED)
-        },
-
-        [M0_BESEG_CLOSED] = {
-                .sd_flags     = M0_SDF_FINAL,
-                .sd_name      = "BE SEG CLOSED",
-                .sd_in        = NULL,
-                .sd_ex        = NULL,
-                .sd_invariant = NULL,
-                .sd_allowed   = (1 << M0_BESEG_OPENING)  |
-                                (1 << M0_BESEG_ACTIVE)   |
-                                (1 << M0_BESEG_FAILED)
-        },
-
-        [M0_BESEG_CHECKING] = {
-                .sd_flags     = 0,
-                .sd_name      = "BE SEG CHECKING",
-                .sd_in        = NULL,
-                .sd_ex        = NULL,
-                .sd_invariant = NULL,
-                .sd_allowed   = (1 << M0_BESEG_CHECKING) |
-                                (1 << M0_BESEG_CLOSED)   |
-                                (1 << M0_BESEG_FAILED)
-        },
-
-        [M0_BESEG_DELETING] = {
-                .sd_flags     = 0,
-                .sd_name      = "BE SEG DELETING",
-                .sd_in        = NULL,
-                .sd_ex        = NULL,
-                .sd_invariant = NULL,
-                .sd_allowed   = (1 << M0_BESEG_DELETING) |
-                                (1 << M0_BESEG_CLOSED)   |
-                                (1 << M0_BESEG_FAILED)
-        },
-
-        [M0_BESEG_FAILED] = {
-                .sd_flags     = M0_SDF_FAILURE,
-                .sd_name      = "BE SEG FAILED",
-                .sd_in        = NULL,
-                .sd_ex        = NULL,
-                .sd_invariant = NULL,
-                .sd_allowed   = 0
-        }
-};
-
-static const struct m0_sm_conf seg_conf = {
-        .scf_name      = "BE SEG STATES",
-        .scf_nr_states = ARRAY_SIZE(m0_be_seg_states),
-        .scf_state     = m0_be_seg_states
-};
-
-/**
- * Starts creation of a new segment in the domain.
- *
- * @pre seg->bs_dom->bd_data.bs_sm.sm_state == M0_BESEG_ACTIVE
- * @pre seg->bs_sm.sm_state == M0_BESEG_CLOSED
- * @post M0_IN(seg->bs_sm.sm_state, (M0_BESEG_CREATING,
- *                                   M0_BESEG_ACTIVE, M0_BESEG_FAILED))
- */
-M0_INTERNAL void m0_be_seg_create(struct m0_be_seg *seg,
-                                  struct m0_be_tx *tx,
-                                  struct m0_stob *stob)
-{
-        M0_PRE(seg->bs_sm.sm_state == M0_BESEG_INIT);
-
-        /* Locking sm group before setting sm_state */
-        m0_sm_group_lock(seg->bs_impl.sm_group);
-
-        m0_sm_state_set(&(seg->bs_sm), M0_BESEG_CREATING);
-
-        /* unlock locked sm group */
-        m0_sm_group_unlock(seg->bs_impl.sm_group);
-
-        seg->bs_stob = stob;
-
-        seg->bs_sm_ast.sa_cb    = m0_be_seg_create_cb;
-        seg->bs_sm_ast.sa_datum = (void *)seg;
-
-        m0_seg_req_post(&(seg->bs_dom->bd_impl.sm_group), &(seg->bs_sm_ast));
-}
-
-/**
- * Initialises the segment structure in memory.
- *
- * @post seg->bs_sm.sm_state == M0_BESEG_CLOSED
- * @todo - Need to understand use of  arguments - m0_sm_group and flags
- */
-M0_INTERNAL void m0_be_seg_init(struct m0_be_seg *seg,
-                                struct m0_be_domain *dom,
-                                struct m0_sm_group *sm_group,
-                                uint64_t flags)
-{
-        /* Asserting on required pointers */
-        M0_ASSERT(seg != NULL);
-        M0_ASSERT(dom != NULL);
-
-        /* Initialise domain structure with required values */
-        seg->bs_dom = dom;
-        seg->bs_impl.sm_group = sm_group;
-
-        /**
-         * Need to make it null because it is referenced into rvm callback to
-         * decide operation status
-         */
-        seg->bs_page.bp_addr = NULL;
-
-        /* Locking sm_group is required before initializing sm */
-        m0_sm_group_lock(seg->bs_impl.sm_group);
-
-        /* Register the state machine of the segment into sm_group */
-        m0_sm_init(&seg->bs_sm, &seg_conf, M0_BESEG_INIT, sm_group,
-                        &seg->bs_addb);
-
-        /* unlock locked sm group */
-        m0_sm_group_unlock(seg->bs_impl.sm_group);
-
-        M0_POST(seg->bs_sm.sm_state == M0_BESEG_INIT);
-}
-
-/**
- * Initialises segment opening.
- *
- * @pre seg->bs_sm.sm_state == M0_BESEG_CLOSED
- * @pre seg->bs_dom->bd_data.bs_sm.sm_state == M0_BESEG_ACTIVE
- * @post M0_IN(seg->bs_sm.sm_state, (M0_BESEG_OPENING,
- *                                   M0_BESEG_ACTIVE, M0_BESEG_FAILED))
- */
-M0_INTERNAL void m0_be_seg_open(struct m0_be_seg *seg)
-{
-        /* Asserting on required pointers */
-        M0_ASSERT(seg != NULL);
-
-        M0_PRE( (seg->bs_sm.sm_state == M0_BESEG_INIT)    ||
-                (seg->bs_sm.sm_state == M0_BESEG_CLOSED) );
-
-        M0_PRE(seg->bs_dom->bd_data.bs_sm.sm_state == M0_BESEG_ACTIVE);
-
-        /* Locking sm group before setting sm_state */
-        m0_sm_group_lock(seg->bs_impl.sm_group);
-
-        m0_sm_state_set(&(seg->bs_sm), M0_BESEG_OPENING);
-
-        /* unlock locked sm group */
-        m0_sm_group_unlock(seg->bs_impl.sm_group);
-
-        /* Start mapping the segment */
-        /* @todo - Mapping entire segment for now */
-
-        seg->bs_sm_ast.sa_cb    = m0_be_seg_open_cb;
-        seg->bs_sm_ast.sa_datum = (void *)seg;
-
-        m0_seg_req_post(&(seg->bs_dom->bd_impl.sm_group), &(seg->bs_sm_ast));
-
-        /* M0_POST(M0_IN(seg->bs_sm.sm_state, (M0_BESEG_OPENING,
-                                    M0_BESEG_ACTIVE, M0_BESEG_FAILED))); */
-
-        M0_POST( (seg->bs_sm.sm_state == M0_BESEG_OPENING) ||
-                 (seg->bs_sm.sm_state == M0_BESEG_ACTIVE)  ||
-                 (seg->bs_sm.sm_state == M0_BESEG_FAILED)  );
-}
-
-/**
- * Starts segment closing.
- *
- * @pre seg->bs_sm.sm_state == M0_BESEG_ACTIVE
- * @post M0_IN(seg->bs_sm.sm_state, (M0_BESEG_CLOSED,
- *                                   M0_BESEG_CLOSING, M0_BESEG_FAILED))
- */
-M0_INTERNAL void m0_be_seg_done(struct m0_be_seg *seg)
-{
-        /* Asserting on required pointers */
-        M0_ASSERT(seg != NULL);
-
-        M0_PRE(seg->bs_sm.sm_state == M0_BESEG_ACTIVE);
-
-        /* Locking sm group before setting sm_state */
-        m0_sm_group_lock(seg->bs_impl.sm_group);
-
-        m0_sm_state_set(&(seg->bs_sm), M0_BESEG_CLOSED);
-
-        /* unlock locked sm group */
-        m0_sm_group_unlock(seg->bs_impl.sm_group);
-
-        /* @todo - Start unmapping the segment */
-
-        /* M0_POST(M0_IN(seg->bs_sm.sm_state,
-         * (M0_BESEG_CLOSED, M0_BESEG_CLOSING, M0_BESEG_FAILED))); */
-
-        M0_POST( (seg->bs_sm.sm_state == M0_BESEG_CLOSING) ||
-                 (seg->bs_sm.sm_state == M0_BESEG_CLOSED)  ||
-                 (seg->bs_sm.sm_state == M0_BESEG_FAILED)  );
-
-}
-
-/**
- * @pre M0_IN(seg->bs_sm.sm_state, (M0_BESEG_CLOSED, M0_BESEG_FAILED))
- */
-M0_INTERNAL void m0_be_seg_fini(struct m0_be_seg *seg)
-{
-        /* Asserting on required pointers */
-        M0_ASSERT(seg != NULL);
-
-        /* M0_PRE(M0_IN(seg->bs_sm.sm_state,
-         * (M0_BESEG_CLOSED, M0_BESEG_FAILED))); */
-        M0_PRE( (seg->bs_sm.sm_state == M0_BESEG_CLOSED) ||
-                (seg->bs_sm.sm_state == M0_BESEG_FAILED) );
-
-        /* Finalizing on state machine */
-        m0_sm_fini(&(seg->bs_sm));
-
-        /* Finalizing respective stob */
-        m0_stob_fini(seg->bs_stob);
-
-        /* Removing entry from in memory in segment list if present */
-        if (m0_be_seg_tlink_is_in(seg))
-                m0_be_seg_tlink_del_fini(seg);
-
-        /* free segment object memory */
-        m0_free(seg);
-}
-
-/**
- * Starts segment deletion.
- *
- * @pre seg->bs_sm.sm_state == M0_BESEG_CLOSED
- * @post M0_IN(seg->bs_sm.sm_state, (M0_BESEG_CLOSED,
- *                                   M0_BESEG_DELETING, M0_BESEG_FAILED))
- */
-M0_INTERNAL void m0_be_seg_delete(struct m0_be_seg *seg, struct m0_be_tx *tx)
-{
-        uint64_t segment_id;
-        struct m0_be_domain *dom;
-
-        /* Asserting on required pointers */
-        M0_ASSERT(seg != NULL);
-        M0_ASSERT(tx != NULL);
-
-        M0_PRE(seg->bs_sm.sm_state == M0_BESEG_CLOSED);
-
-        /* Locking sm group before setting sm_state */
-        m0_sm_group_lock(seg->bs_impl.sm_group);
-
-        m0_sm_state_set(&(seg->bs_sm), M0_BESEG_DELETING);
-
-        /* unlock locked sm group */
-        m0_sm_group_unlock(seg->bs_impl.sm_group);
-
-        /* Removing entry from in memory in segment list if present */
-        /* todo@ Need some kind of log here if condition is false */
-        if (m0_be_seg_tlink_is_in(seg))
-                m0_be_seg_tlink_del_fini(seg);
-
-        /**
-         * The following veriables are needed to remove entry from named
-         * segment
-         */
-        segment_id = seg->bs_impl.segment_id;
-        dom        = seg->bs_dom;
-
-        /* @todo - remove entry from named segment transactionally */
-
-        /* M0_POST(M0_IN(seg->bs_sm.sm_state,
-        * (M0_BESEG_CLOSED, M0_BESEG_DELETING, M0_BESEG_FAILED))); */
-
-        M0_POST( (seg->bs_sm.sm_state == M0_BESEG_CLOSED)   ||
-                 (seg->bs_sm.sm_state == M0_BESEG_DELETING) ||
-                 (seg->bs_sm.sm_state == M0_BESEG_FAILED)   );
-
-}
-
-/**
- * Starts segment consistency check.
- *
- * @pre seg->bs_sm.sm_state == M0_BESEG_CLOSED
- * @post M0_IN(seg->bs_sm.sm_state, (M0_BESEG_CLOSED,
- *                                   M0_BESEG_CHECKING, M0_BESEG_FAILED))
- */
-M0_INTERNAL void m0_be_seg_check(struct m0_be_seg *seg, struct m0_be_tx *tx)
-{
-        /* Asserting on required pointers */
-        M0_ASSERT(seg != NULL);
-        M0_ASSERT(tx != NULL);
-
-        /* @todo - not clear idea about what to do in this at the moment */
-
-        /* M0_POST(M0_IN(seg->bs_sm.sm_state, (M0_BESEG_CLOSED,
-                                       M0_BESEG_CHECKING, M0_BESEG_FAILED))); */
-
-        M0_POST( (seg->bs_sm.sm_state == M0_BESEG_CLOSED)   ||
-                 (seg->bs_sm.sm_state == M0_BESEG_CHECKING) ||
-                 (seg->bs_sm.sm_state == M0_BESEG_FAILED)   );
-
-}
-
-/**
- * Marks the segment as failed.
- *
- * @post seg->bs_sm.sm_state == M0_BESEG_FAILED
- */
-M0_INTERNAL void m0_be_seg_fail(struct m0_be_seg *seg)
-{
-        /* Asserting on required pointers */
-        M0_ASSERT(seg != NULL);
-
-        /* Locking sm group before setting sm_state */
-        m0_sm_group_lock(seg->bs_impl.sm_group);
-
-        m0_sm_state_set(&(seg->bs_sm), M0_BESEG_FAILED);
-
-        /* unlock locked sm group */
-        m0_sm_group_unlock(seg->bs_impl.sm_group);
-
-        M0_POST(seg->bs_sm.sm_state == M0_BESEG_FAILED);
-}
-
-
-/**
- * Helper functions for segments
- */
-
-/**
- * Initializes segment state machine data structures
- */
-M0_INTERNAL void m0_bs_sm_init(struct m0_be_domain  *dom)
-{
-        int result;
-
-        m0_sm_group_init(&(dom->bd_impl.sm_group));
-
-        result = M0_THREAD_INIT(dom->bd_impl.th,
-                                struct m0_sm_group *,
-                                NULL,
-                                &m0_bs_handler_thread,
-                                &(dom->bd_impl.sm_group),
-                                "Be Seg sm handler thread");
-
-}
-
-/**
- * Thread handler which listen's on channel for incomming requests
- */
-M0_INTERNAL void m0_bs_handler_thread(struct m0_sm_group *sm_group)
-{
-        while(1) {
-                /**
-                 * 1) Wait on  the channel
-                 * 2) Wake on new request -
-                 *      a) Lock the sm group
-                 *      b) Call as ast callback for the request
-                 *      c) Unlock sm group when done with the callback
-                 * 3) Go to step 1
-                 *
-                 * @note - So no need to lock sm_group in callback as it is
-                 *         locked before calling the callback.
-                 */
-                m0_chan_wait(&(sm_group->s_clink));
-                m0_sm_group_lock(sm_group);
-                m0_sm_asts_run(sm_group);
-                m0_sm_group_unlock(sm_group);
-
-                /* todo@ loop exit condition */
-        }
-}
-
-/**
- * The function posts segment request to state machine thread
- *
- */
-
-M0_INTERNAL void m0_seg_req_post(struct m0_sm_group *sm_group,
-                                 struct m0_sm_ast *sm_ast)
-{
-        m0_sm_ast_post(sm_group, sm_ast);
-}
-
-/**
- * The callback function which will be called by state machine
- * The function calls rvm API's to open the segment
- *
- */
-
-M0_INTERNAL void m0_be_seg_create_cb(struct m0_sm_group *sm_group,
-                                     struct m0_sm_ast *sm_ast)
-{
-        struct m0_be_seg *seg;
-
-        M0_ASSERT(sm_group != NULL);
-        M0_ASSERT(sm_ast != NULL);
-
-        seg = (struct m0_be_seg *)sm_ast->sa_datum;
-
-        /* Generate new segment id */
-
-        /**
-        struct m0_be_named_seg_hdr *named_seg_hdr;
-        named_seg_hdr = (struct m0_be_named_seg_hdr *)
-                        seg->bs_dom->bd_data.bs_addr;
-        M0_ASSERT(NULL != named_seg_hdr);
-        seg->bs_impl.segment_id = named_seg_hdr->max_segment_index + 1;
-        */
-
-        /* Create linux stob */
-        /* @todo - Please revisit this when have better understanding
-         * of linux stob
-         */
-        struct  m0_stob_domain   *stob_dom;
-        bool                      stob_directio = true;
-        struct  m0_stob_id        stob_id = {{0, seg->bs_impl.segment_id}};
-        int                       result;
-        struct linux_stob        *lstob;
-        struct linux_domain      *ldom;
-        int                       nbytes = 0;
-        int                       err;
-        unsigned long             dev_length        = SEGMENT_SIZE;
-        unsigned long             heap_length       = HEAP_SIZE;
-        char                     *start_Addr        = (char *)0xbebd000;
-        char                     *static_addr       = NULL;
-        long                      rds_static_len    = 0;
-        long                      nlist             = 16;
-        long                      chunk_size        = 64;
-        /* initialize stob type */
-        m0_stob_type_init(&m0_linux_stob_type);
-
-        /* @todo - stob path is hardcoded for now */
-        result = m0_stob_domain_locate(&m0_linux_stob_type,
-                                       "./__be",
-                                       &stob_dom);
-        M0_ASSERT(result == 0);
-
-        result = m0_linux_stob_setup(stob_dom, stob_directio);
-        M0_ASSERT(result == 0);
-
-        result = m0_stob_find(stob_dom, &stob_id, &(seg->bs_stob));
-        M0_ASSERT(result == 0);
-        M0_ASSERT(seg->bs_stob->so_state == CSS_UNKNOWN);
-        result = m0_stob_create(seg->bs_stob, NULL);
-
-        if (result < 0)
-                goto error;
-
-        lstob = stob2linux(seg->bs_stob);
-
-        M0_ASSERT(lstob != NULL);
-
-        /* Get fle-path for segment stob */
-        /* @note - can not use linux_stob_path as it is declared as static in
-         *  linux.[hc] */
-
-        ldom = domain2linux(seg->bs_stob->so_domain);
-        nbytes = snprintf(seg->bs_impl.path_name,
-                          ARRAY_SIZE(seg->bs_impl.path_name),
-                          "%s/o/%016lx.%016lx",
-                          ldom->sdl_path,
-                          seg->bs_stob->so_id.si_bits.u_hi,
-                          seg->bs_stob->so_id.si_bits.u_lo);
-
-        if (nbytes < 0)
-                goto error;
-
-        /* @todo - need to handle rvm errors in callback */
-        /* create heap structure */
-        /* result = rds_zap_heap(DevName, DevLength, startAddr, staticLength,
-         *                       heapLength, nlists, chunkSize, err); */
-
-        rds_static_len    = RVM_ROUND_LENGTH_DOWN_TO_PAGE_SIZE(4096);
-
-        result = rds_zap_heap(seg->bs_impl.path_name,
-                              RVM_LENGTH_TO_OFFSET(dev_length),
-                              start_Addr,
-                              rds_static_len,
-                              heap_length,
-                              nlist,
-                              chunk_size,
-                              &err);
-
-        if (result < 0)
-                goto error;
-
-        /* @todo - begin transaction */
-        /* update the named segment transactionally */
-        /* @todo - end transaction */
-        /* Assuption : create implicitely opens the segment */
-
-        result = rds_load_heap(seg->bs_impl.path_name,
-                               RVM_LENGTH_TO_OFFSET(dev_length),
-                               &static_addr,
-                               &err);
-
-        if (result < 0)
-                goto error;
-
-        printf("\nstatic_addr : %p\n", static_addr);
-
-        seg->bs_static_addr = (void *)(static_addr);
-
-        seg->bs_heap_addr = (void *)m0_be_rvm_get_heapaddr();
-
-        m0_sm_state_set((&seg->bs_sm), M0_BESEG_ACTIVE);
-
-        return;
-
-error:
-        m0_sm_state_set((&seg->bs_sm), M0_BESEG_FAILED);
-}
-
-/**
- * The callback function which will be called by state machine
- * The function calls rvm api's to open the segment
- *
- */
-
-M0_INTERNAL void m0_be_seg_open_cb(struct m0_sm_group *sm_group,
-                                   struct m0_sm_ast *sm_ast)
-{
-        int                      nbytes;
-        int                      result;
-
-        struct linux_stob       *lstob;
-        struct linux_domain     *ldom;
-        struct m0_be_seg        *seg;
-
-        /* Asserting on required pointers */
-        M0_ASSERT(sm_group != NULL);
-        M0_ASSERT(sm_ast != NULL);
-
-        seg = (struct m0_be_seg *)sm_ast->sa_datum;
-
-        if (seg->bs_stob->so_state == CSS_UNKNOWN)
-                goto error;
-
-        lstob = stob2linux(seg->bs_stob);
-
-        M0_ASSERT(lstob != NULL);
-
-        /* Get fle-path for segment stob */
-        /* @note - can not use linux_stob_path as its declared as static */
-        ldom = domain2linux(seg->bs_stob->so_domain);
-        nbytes = snprintf(seg->bs_impl.path_name,
-                          ARRAY_SIZE(seg->bs_impl.path_name),
-                          "%s/o/%016lx.%016lx",
-                          ldom->sdl_path,
-                          seg->bs_stob->so_id.si_bits.u_hi,
-                          seg->bs_stob->so_id.si_bits.u_lo);
-
-        if (nbytes < 0)
-                goto error;
-
-        /* @todo - need to handle rvm errors in callback */
-        /* load heap */
-        /* rds_load_heap(*DevName, DevLength, **staticAddr, *err); */
-
-        unsigned long dev_length = SEGMENT_SIZE;
-        int  err;
-        char *static_addr = NULL;
-
-        result = rds_load_heap(seg->bs_impl.path_name,
-                               RVM_LENGTH_TO_OFFSET(dev_length),
-                               &static_addr,
-                               &err);
-
-        if (result < 0)
-                goto error;
-
-        printf("\nstatic_addr : %p\n", static_addr);
-
-        seg->bs_static_addr = (void *)(static_addr);
-
-        seg->bs_heap_addr = (void *)m0_be_rvm_get_heapaddr();
-
-        m0_sm_state_set((&seg->bs_sm), M0_BESEG_ACTIVE);
-
-        return;
-
-error:
-        m0_sm_state_set((&seg->bs_sm), M0_BESEG_FAILED);
-
-        return;
-}
-
-/**
- * The callback function which will be called by rvm upon completion of req
- * The function updates segment state.
- *
- * @post M0_POST(seg->bs_sm.sm_state, M0_IN(M0_BESEG_ACTIVE, M0_BESEG_FAILED))
- *
- */
-
-/**
-void m0_bs_rvm_cb(void *data) {
-        M0_ASSERT(NULL != data);
-
-        struct m0_be_seg *seg = (struct m0_be_seg *)data;
-
-        if(NULL == seg->bs_page.bp_addr)
-                m0_sm_state_set(&(seg->bs_sm), M0_BESEG_FAILED);
-        else
-                m0_sm_state_set(&(seg->bs_sm), M0_BESEG_ACTIVE);
-
-         M0_POST( (seg->bs_sm.sm_state == M0_BESEG_ACTIVE) ||
-                  (seg->bs_sm.sm_state == M0_BESEG_FAILED) );
-
-        return;
-}
-**/
-
-/** @} end group be_seg */
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
diff --git a/be/be_seg.h b/be/be_seg.h
deleted file mode 100644
index 215f809..0000000
--- a/be/be_seg.h
+++ /dev/null
@@ -1,68 +0,0 @@
-/*
- * COPYRIGHT 2012 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Sachin Patil <sachin_patil@xyratex.com>
- * Original creation date: 26 Nov 2012
- */
-
-#pragma once
-
-#ifndef __MERO_BE_BE_SEG_H__
-#define __MERO_BE_BE_SEG_H__
-
-/**
-  @defgroup be (Meta-data) back-end
-  @{
-  */
-
-#include <stdio.h>
-
-#include "be/be.h"
-
-M0_INTERNAL void m0_bs_sm_init(struct m0_be_domain  *dom);
-M0_INTERNAL void m0_bs_handler_thread(struct m0_sm_group *sm_group);
-
-M0_INTERNAL void m0_seg_req_post(struct m0_sm_group *sm_grp,
-                                 struct m0_sm_ast *sm_ast);
-
-M0_INTERNAL void m0_be_seg_create_cb(struct m0_sm_group *sm_group,
-                                     struct m0_sm_ast *sm_ast);
-M0_INTERNAL void m0_be_seg_open_cb(struct m0_sm_group *sm_group,
-                                   struct m0_sm_ast *sm_ast);
-
-#define HEAP_SIZE       (100*1024*1024)
-
-#define PAGE_SIZE       (1024*4)
-
-#define SEGMENT_SIZE    (PAGE_SIZE + HEAP_SIZE + PAGE_SIZE)
-
-#define NLIST           (16)
-
-#define CHUNK_SIZE      (64)
-
-/** @} end of be group */
-
-/* __MERO_BE_BE_SEG_H__ */
-#endif
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
diff --git a/be/be_tx.c b/be/be_tx.c
deleted file mode 100644
index a8024f8..0000000
--- a/be/be_tx.c
+++ /dev/null
@@ -1,564 +0,0 @@
-/*
- * COPYRIGHT 2012 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Prashant Dhange <prashant_dhange@xyratex.com>
- * Original creation date: 03 Dec 2012
- */
-
-#include "be/be.h"
-#include <stdlib.h>
-/**
-  @addtogroup be_transaction
-
-  <b>Implementation of back-end transaction </b>
-
-  A transaction is a group of updates to the segments of a domain that is
-  guaranteed to be atomic in the face of failures. A user creates a
-  transaction associated with a domain and then starts updating the data
-  in domain's segments. The transaction is then closed. Back-end
-  guarantees that even if the process fails, the persistent segments
-  state (as visible through level 0 interface) will contain either all or
-  none updates executed as part of the transaction. Note that
-  transactions only provide atomicity w.r.t. failures. Other
-  "transactional" properties (consistency, isolation) are not guaranteed
-  by level 0. To achieve them, the user should use other mechanisms (such
-  as locking) if necessary. Neither does level 0 provide transaction
-  durability: it is *not* guaranteed that when transaction close call
-  returns the transaction updates are persistent. Instead of this, the
-  back-end notifies the user when updates become persistent (which might
-  be some time after the transaction is closed);
-
-  A transaction credit is a pre-declaration of a resource usage by a
-  transaction. A transaction starts in "prepare" phase, where resources
-  that will be used by the transaction are pre-declared (before they are
-  actually used). Most importantly, the amount of space the transaction
-  will consume in the log and in memory must be pre-delcared to avoid
-  dead-locks;
-
-  @{
-  */
-
-/* State machine variable declarations  */
-static const struct m0_sm_state_descr tx_states[] = {
-         [M0_BETX_INITIALIZING] = {
-                .sd_flags     = M0_SDF_INITIAL,
-                .sd_name      = "BE TX INIT",
-                .sd_in        = NULL,
-                .sd_ex        = NULL,
-                .sd_invariant = NULL,
-                .sd_allowed   = (1 << M0_BETX_INIT)        |
-                                (1 << M0_BETX_FAILED)
-        },
-        [M0_BETX_INIT] = {
-                .sd_flags     = 0,
-                .sd_name      = "BE TX INIT",
-                .sd_in        = NULL,
-                .sd_ex        = NULL,
-                .sd_invariant = NULL,
-                .sd_allowed   = (1 << M0_BETX_PREPARING)   |
-                                (1 << M0_BETX_OPEN)        |
-                                (1 << M0_BETX_FAILED)
-        },
-        [M0_BETX_PREPARING] = {
-                .sd_flags     = 0,
-                .sd_name      = "BE TX PREPARING",
-                .sd_in        = NULL,
-                .sd_ex        = NULL,
-                .sd_invariant = NULL,
-                .sd_allowed   = (1 << M0_BETX_PREPARED)    |
-                                (1 << M0_BETX_PREPARING)   |
-                                (1 << M0_BETX_OPEN)        |
-                                (1 << M0_BETX_FAILED)
-        },
-        [M0_BETX_PREPARED] = {
-                .sd_flags     = 0,
-                .sd_name      = "BE TX PREPARED",
-                .sd_in        = NULL,
-                .sd_ex        = NULL,
-                .sd_invariant = NULL,
-                .sd_allowed   = (1 << M0_BETX_PREPARED)    |
-                                (1 << M0_BETX_OPEN)        |
-                                (1 << M0_BETX_FAILED)
-        },
-        [M0_BETX_OPEN] = {
-                .sd_flags     = 0,
-                .sd_name      = "BE TX OPEN",
-                .sd_in        = NULL,
-                .sd_ex        = NULL,
-                .sd_invariant = NULL,
-                .sd_allowed   = (1 << M0_BETX_DONE)        |
-                                (1 << M0_BETX_COMMITTED)   |
-                                (1 << M0_BETX_FAILED)
-        },
-        [M0_BETX_DONE] = {
-                .sd_flags     = 0,
-                .sd_name      = "BE TX DONE",
-                .sd_in        = NULL,
-                .sd_ex        = NULL,
-                .sd_invariant = NULL,
-                .sd_allowed   = (1 << M0_BETX_CLOSED)      |
-                                (1 << M0_BETX_COMMITTED)   |
-                                (1 << M0_BETX_PREPARING)   |
-                                (1 << M0_BETX_FAILED)
-        },
-        [M0_BETX_CLOSED] = {
-                .sd_flags     = M0_SDF_TERMINAL,
-                .sd_name      = "BE TX CLOSED",
-                .sd_in        = NULL,
-                .sd_ex        = NULL,
-                .sd_invariant = NULL,
-                .sd_allowed   = 0
-        },
-        [M0_BETX_COMMITTED] = {
-                .sd_flags     = 0,
-                .sd_name      = "BE TX COMMITTED",
-                .sd_in        = NULL,
-                .sd_ex        = NULL,
-                .sd_invariant = NULL,
-                .sd_allowed   = (1 << M0_BETX_CLOSED)      |
-                                (1 << M0_BETX_FAILED)
-        },
-        [M0_BETX_FAILED] = {
-                .sd_flags     = M0_SDF_FAILURE,
-                .sd_name      = "BE TX FAILED",
-                .sd_in        = NULL,
-                .sd_ex        = NULL,
-                .sd_invariant = NULL,
-                .sd_allowed   = (1 << M0_BETX_FAILED)
-        },
-};
-
-static const struct m0_sm_conf tx_conf = {
-        .scf_name      = "Tx States",
-        .scf_nr_states = ARRAY_SIZE(tx_states),
-        .scf_state     = tx_states
-};
-
-/**
- * Initialises the transaction structure.
- *
- * @pre dom->bd_data.bs_sm.sm_state == M0_BESEG_ACTIVE
- * @post tx->bt_sm.sm_state == M0_BETX_PREPARING
- * @post tx->bt_dom == dom
- */
-M0_INTERNAL void m0_be_tx_init(struct m0_be_tx *tx,
-                               struct m0_be_domain *dom, uint64_t flags)
-{
-        /* Asserting on required pointers */
-        M0_ASSERT(tx != NULL);
-        M0_ASSERT(dom != NULL);
-        M0_ASSERT(&(dom->bd_impl.sm_group) != NULL);
-
-        /* Initialise domain structure with required values */
-        tx->bt_dom              = dom;
-        tx->bt_impl.sm_group    = &(dom->bd_impl.sm_group);
-
-        /* Initialize bt_impl->bc_tl list */
-        m0_be_reg_tlist_init(&(tx->bt_impl.bc_tl));
-
-        /*
-         * Locking sm_group is required before initializing sm
-         * TODO@ Need to confirm with Nikita, do we need to move the state
-         * transition logic to CALLBACKS. This Applies for state change
-         * accross the segments, regions, transactions
-         */
-        m0_sm_group_lock(tx->bt_impl.sm_group);
-
-        /* Register the state machine of the tx into sm_group */
-        m0_sm_init(&tx->bt_sm, &tx_conf, M0_BETX_INITIALIZING,
-                   tx->bt_impl.sm_group, NULL);
-
-        /* unlock locked sm group */
-        m0_sm_group_unlock(tx->bt_impl.sm_group);
-
-        tx->bt_sm_ast.sa_cb    = m0_be_tx_init_cb;
-        tx->bt_sm_ast.sa_datum = (void *)tx;
-
-        m0_tx_req_post(&(tx->bt_dom->bd_impl.sm_group), &(tx->bt_sm_ast));
-}
-
-/**
- * Indicates that a transaction will use certain amount of resources.
- *
- * @pre tx->bt_sm.sm_state == M0_BETX_INIT
- *
- */
-M0_INTERNAL void m0_be_tx_prep(struct m0_be_tx *tx)
-{
-        struct m0_be_reg *reg_it;
-
-        /* Asserting on required pointers */
-        M0_ASSERT(tx != NULL);
-
-        /* Is tx->bt_sm.sm_state in M0_BETX_INIT state */
-        M0_PRE(tx->bt_sm.sm_state == M0_BETX_INIT);
-
-        /* Iterate credit list of regions */
-        m0_tlist_for(&m0_be_reg_tl, &(tx->bt_impl.bc_tl), reg_it) {
-
-                /* check reg_it->br_sm.sm_state for region state */
-
-                if (reg_it->br_sm.sm_state != M0_BEREG_INIT &&
-                    reg_it->br_sm.sm_state != M0_BEREG_ALLOCATED) {
-
-                        M0_TX_SM_STATE_SET(tx, M0_BETX_FAILED);
-                        /* TODO@ add error log message */
-                        goto exit_error;
-                }
-
-        } m0_tlist_endfor;
-
-        M0_TX_SM_STATE_SET(tx, M0_BETX_PREPARING);
-
-        tx->bt_sm_ast.sa_cb    = m0_be_tx_prep_cb;
-        tx->bt_sm_ast.sa_datum = (void *)tx;
-
-        m0_tx_req_post(&(tx->bt_dom->bd_impl.sm_group), &(tx->bt_sm_ast));
-        goto exit;
-
-exit_error:
-        rvm_abort_transaction(tx->bt_impl.tx_id);
-        rvm_free_tid(tx->bt_impl.tx_id);
-exit:
-        return;
-}
-
-/**
- * Starts a prepared transaction.
- *
- * @pre tx->bt_sm.sm_state == M0_BETX_PREPARING
- * @post M0_IN(tx->bt_sm.sm_state, (M0_BETX_PREPARED, M0_BETX_OPEN,
- *                                      M0_BETX_FAILED) )
- */
-M0_INTERNAL void m0_be_tx_start(struct m0_be_tx *tx)
-{
-
-        M0_ASSERT(tx != NULL);
-
-        /*
-         * Added M0_IN support to call start when theres nothing in
-         * credit list i.e. without calling tx_prep
-         */
-        M0_IN(tx->bt_sm.sm_state, (M0_BETX_PREPARED, M0_BETX_PREPARING));
-
-        tx->bt_sm_ast.sa_cb    = m0_be_tx_start_cb;
-        tx->bt_sm_ast.sa_datum = (void *)tx;
-
-        m0_tx_req_post(&(tx->bt_dom->bd_impl.sm_group), &(tx->bt_sm_ast));
-}
-
-/**
- * Closes a transaction.
- *
- * @pre tx->bt_sm.sm_state == M0_BETX_OPEN
- * @post M0_IN(tx->bt_sm.sm_state, (M0_BETX_CLOSED, M0_BETX_COMMITTED,
- *                                  M0_BETX_DONE, M0_BETX_FAILED))
- */
-M0_INTERNAL void m0_be_tx_done(struct m0_be_tx *tx)
-{
-        /* Asserting on required pointers */
-        M0_ASSERT(tx != NULL);
-
-        M0_PRE(tx->bt_sm.sm_state == M0_BETX_OPEN);
-
-        tx->bt_sm_ast.sa_cb    = m0_be_tx_done_cb;
-        tx->bt_sm_ast.sa_datum = (void *)tx;
-
-        m0_tx_req_post(&(tx->bt_dom->bd_impl.sm_group), &(tx->bt_sm_ast));
-}
-
-/**
- * Finalises transaction structure.
- *
- * @pre M0_IN(tx->bt_sm.sm_state, (M0_BETX_DONE, M0_BETX_FAILED))
- */
-M0_INTERNAL void m0_be_tx_fini(struct m0_be_tx *tx)
-{
-        struct m0_be_reg *reg_it;
-
-        /* Asserting on required pointers */
-        M0_ASSERT(tx != NULL);
-
-        M0_PRE(M0_IN(tx->bt_sm.sm_state, (M0_BETX_DONE, M0_BETX_FAILED)));
-
-        rvm_free_tid(tx->bt_impl.tx_id);
-
-         /* Removing entries from reg list if present */
-         /* Iterate credit list of regions */
-         m0_tlist_for(&m0_be_reg_tl, &(tx->bt_impl.bc_tl), reg_it) {
-                if (m0_be_reg_tlink_is_in(reg_it)) {
-                         m0_be_reg_tlink_del_fini(reg_it);
-
-                         m0_be_reg_fini(reg_it);
-                }
-         } m0_tlist_endfor;
-
-        /* Finalise bt_impl->bc_tl list */
-        m0_be_reg_tlist_fini(&(tx->bt_impl.bc_tl));
-
-        M0_TX_SM_STATE_SET(tx, M0_BETX_CLOSED);
-
-        /* Remove entry from in memory active transaction list if present */
-        if (m0_be_tx_tlink_is_in(tx))
-                m0_be_tx_tlink_del_fini(tx);
-
-        /* Finalizing on state machine */
-        m0_sm_fini(&(tx->bt_sm));
-}
-
-/*
- *    m0_be_tx_init callback function
- */
-M0_INTERNAL void m0_be_tx_init_cb(struct m0_sm_group *sm_group,
-                                  struct m0_sm_ast *sm_ast)
-{
-        struct m0_be_tx         *tx;
-        rvm_return_t             ret;
-        rvm_tid_t               *tid;
-
-        /* Asserting on required pointers */
-        M0_ASSERT(sm_group != NULL);
-        M0_ASSERT(sm_ast != NULL);
-
-        tx = (struct m0_be_tx *) sm_ast->sa_datum;
-        M0_ASSERT(tx != NULL);
-
-        tid = rvm_malloc_tid();
-
-        if (tid == NULL) {
-                /* TODO@ add error log message */
-                goto exit_alloc;
-        }
-
-        tx->bt_impl.tx_id = tid;
-
-        ret = rvm_begin_transaction(tx->bt_impl.tx_id, restore);
-
-        if (RVM_SUCCESS != ret) {
-                /* TODO@ add error log message */
-                goto exit_begin_tx;
-        }
-        m0_sm_state_set(&(tx->bt_sm), M0_BETX_INIT);
-        goto exit;
-
-exit_begin_tx:
-        rvm_free_tid(tid);
-exit_alloc:
-        m0_sm_state_set(&(tx->bt_sm), M0_BETX_FAILED);
-exit:
-        return;
-}
-
-/*
- * m0_be_tx_prep callback function
- */
-M0_INTERNAL void m0_be_tx_prep_cb(struct m0_sm_group *sm_group,
-                                  struct m0_sm_ast *sm_ast)
-{
-        struct m0_be_tx         *tx;
-        struct m0_be_reg        *reg_it;
-
-        /* Asserting on required pointers */
-        M0_ASSERT(sm_group != NULL);
-        M0_ASSERT(sm_ast != NULL);
-
-        tx = (struct m0_be_tx *) sm_ast->sa_datum;
-
-        M0_ASSERT(tx != NULL);
-
-        /* Iterate credit list of regions */
-        m0_tlist_for(&m0_be_reg_tl, &(tx->bt_impl.bc_tl), reg_it) {
-                /* Assumption: reg_it->br_tx will be updated to tx */
-                reg_it->br_tx = tx;
-                reg_it->br_tx_cbdata.datum = (void *)tx;
-
-                /*
-                * Capture region function which changes
-                * the region state to InProgress
-                */
-                m0_be_reg_capture(reg_it);
-
-        } m0_tlist_endfor;
-
-        return;
-}
-
-/*
- *    m0_be_tx_start callback function
- */
-M0_INTERNAL void m0_be_tx_start_cb(struct m0_sm_group *sm_group,
-                                   struct m0_sm_ast *sm_ast)
-{
-        struct m0_be_tx         *tx;
-
-        /* Asserting on required pointers */
-        M0_ASSERT(sm_group != NULL);
-        M0_ASSERT(sm_ast != NULL);
-
-        tx = (struct m0_be_tx *) sm_ast->sa_datum;
-
-        /* Add this transaction to domain's active transaction list */
-        m0_be_tx_tlink_init(tx);
-
-        m0_be_tx_tlist_add(&tx->bt_dom->bd_tx, tx);
-
-        m0_sm_state_set(&(tx->bt_sm), M0_BETX_OPEN);
-}
-
-/*
- *    m0_be_tx_done callback function
- */
-M0_INTERNAL void m0_be_tx_done_cb(struct m0_sm_group *sm_group,
-                                  struct m0_sm_ast *sm_ast)
-{
-        struct m0_be_tx         *tx;
-        struct m0_be_reg        *reg_it;
-        rvm_return_t ret;
-
-        /* Asserting on required pointers */
-        M0_ASSERT(sm_group != NULL);
-        M0_ASSERT(sm_ast != NULL);
-
-        tx = (struct m0_be_tx *) sm_ast->sa_datum;
-
-        ret = rvm_end_transaction(tx->bt_impl.tx_id, flush);
-
-        if (RVM_SUCCESS != ret) {
-                /* TODO@ add error log message */
-                goto exit_end_tx;
-        }
-
-        /* Iterate credit list of regions */
-        m0_tlist_for(&m0_be_reg_tl, &(tx->bt_impl.bc_tl), reg_it) {
-                /* Mark all regions for completion */
-                /* TODO@ need to call function m0_sm_state_set() */
-                reg_it->br_sm.sm_state = M0_BEREG_DONE;
-
-        } m0_tlist_endfor;
-
-        m0_sm_state_set(&(tx->bt_sm), M0_BETX_DONE);
-        goto exit;
-
-exit_end_tx:
-        rvm_free_tid(tx->bt_impl.tx_id);
-        m0_sm_state_set(&(tx->bt_sm), M0_BETX_FAILED);
-exit:
-        return;
-}
-
-M0_INTERNAL void m0_be_tx_add_cred(struct m0_be_tx *tx,
-                                   struct m0_be_reg *reg)
-{
-        /* Asserting on required pointers */
-        M0_ASSERT(tx != NULL);
-        M0_ASSERT(reg != NULL);
-
-        /* Add reg to credit list, default would be add to tail */
-        m0_be_reg_tlink_init(reg);
-
-        m0_be_reg_tlist_add_tail(&(tx->bt_impl.bc_tl), reg);
-}
-
-/**
- * The function posts tx request to state machine thread
- *
- */
-M0_INTERNAL void m0_tx_req_post(struct m0_sm_group *sm_group,
-                                struct m0_sm_ast *sm_ast)
-{
-        m0_sm_ast_post(sm_group, sm_ast);
-}
-
-/**
- * The function iterates the region list to check if any region capture has
- * failed.
- * If any earlier capture is failed, then the current region won't be captured.
- */
-M0_INTERNAL int m0_be_tx_get_capture_status(void * data)
-{
-        struct m0_be_tx *tx = (struct m0_be_tx *)data;
-        struct m0_be_reg *reg_it;
-
-        int result = M0_BETX_PREP_INPROGRESS;
-
-        /* Iterate credit list to check the capture status for each region. */
-        m0_tlist_for(&m0_be_reg_tl, &(tx->bt_impl.bc_tl), reg_it) {
-                /* check reg_it->br_sm.sm_state for region state */
-
-                if (reg_it->br_sm.sm_state == M0_BEREG_FAILED) {
-                        result = M0_BETX_PREP_FAILED;
-                        break;
-                }
-
-        } m0_tlist_endfor;
-
-        return result;
-}
-
-/**
- * The function iterates all the region list to check if they are captured
- * successfully.
- * This is pre-requisite for transaction to be marked as PREPARED.
- */
-M0_INTERNAL void m0_be_tx_set_capture_status(void * data)
-{
-        struct m0_be_tx *tx = (struct m0_be_tx *)data;
-        struct m0_be_reg *reg_it;
-
-        bool failed_res = false;
-        bool capturing_res = false;
-
-        /* Iterate credit list to check the capture status for each region. */
-        m0_tlist_for(&m0_be_reg_tl, &(tx->bt_impl.bc_tl), reg_it) {
-                /* check if region capture is in prorgess */
-                if (reg_it->br_sm.sm_state == M0_BEREG_CAPTURING) {
-                        capturing_res = true;
-                        break;
-                }
-
-                /* check if region capture is failed */
-                if (reg_it->br_sm.sm_state == M0_BEREG_FAILED) {
-                        failed_res = true;
-                }
-
-        } m0_tlist_endfor;
-
-        if(!capturing_res) {
-                /**
-                 * This function will be called from callback function, so
-                 * sm_group lock is not required while setting tx state.
-                 */
-                if(failed_res) {
-                        m0_sm_state_set(&(tx->bt_sm), M0_BETX_FAILED);
-                }
-                else {
-                        m0_sm_state_set(&(tx->bt_sm), M0_BETX_PREPARED);
-                }
-        }
-
-        return;
-}
-
-/** @} end group be_trans */
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
diff --git a/be/be_tx.h b/be/be_tx.h
deleted file mode 100644
index 5a6c3ed..0000000
--- a/be/be_tx.h
+++ /dev/null
@@ -1,76 +0,0 @@
-/*
- * COPYRIGHT 2012 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Prashant Dhange <prashant_dhange@xyratex.com>
- * Original creation date: 10 Dec 2012
- */
-
-#pragma once
-
-#ifndef __MERO_BE_BE_TX_H__
-#define __MERO_BE_BE_TX_H__
-
-/**
-  @defgroup be (Meta-data) back-end
-  @{
-  */
-#include "be/be.h"
-
-#define M0_TX_SM_STATE_SET(tx, state)                                 \
-        m0_sm_group_lock((tx)->bt_impl.sm_group);                     \
-        m0_sm_state_set(&((tx)->bt_sm), state);                       \
-        m0_sm_group_unlock((tx)->bt_impl.sm_group);
-
-enum m0_be_tx_prep_state {
-        M0_BETX_PREP_INPROGRESS,
-        M0_BETX_PREP_SUCCEED,
-        M0_BETX_PREP_FAILED,
-};
-
-M0_INTERNAL void m0_be_tx_add_cred(struct m0_be_tx *tx,
-                                   struct m0_be_reg *reg);
-
-M0_INTERNAL void m0_be_tx_init_cb(struct m0_sm_group *sm_group,
-                                  struct m0_sm_ast *sm_ast);
-M0_INTERNAL void m0_be_tx_prep_cb(struct m0_sm_group *sm_group,
-                                  struct m0_sm_ast *sm_ast);
-M0_INTERNAL void m0_be_tx_start_cb(struct m0_sm_group *sm_group,
-                                   struct m0_sm_ast *sm_ast);
-M0_INTERNAL void m0_be_tx_done_cb(struct m0_sm_group *sm_group,
-                                  struct m0_sm_ast *sm_ast);
-M0_INTERNAL void m0_be_tx_fini_cb(struct m0_sm_group *sm_group,
-                                  struct m0_sm_ast *sm_ast);
-
-M0_INTERNAL void m0_tx_req_post(struct m0_sm_group *sm_group,
-                                struct m0_sm_ast *sm_ast);
-
-M0_INTERNAL int m0_be_tx_get_capture_status(void * data);
-
-M0_INTERNAL void m0_be_tx_set_capture_status(void * data);
-
-/** @} end of be group */
-
-/* __MERO_BE_BE_TX_H__ */
-#endif
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
diff --git a/be/domain.c b/be/domain.c
new file mode 100644
index 0000000..2ba47fa
--- /dev/null
+++ b/be/domain.c
@@ -0,0 +1,252 @@
+/*
+ * COPYRIGHT 2012 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: Sachin Patil <sachin_patil@xyratex.com>
+ * Original creation date: 08 Nov 2012
+ */
+
+#include <stdio.h>
+#include <string.h>
+
+#include "be/be.h"
+#include "be/domain.h"
+#include "be/seg.h"
+#include "be/be_private.h"
+#include "be/be_init.h"
+
+#include "stob/linux.h"
+
+/**
+  @addtogroup be_domain
+  @{
+*/
+
+M0_INTERNAL void m0_be_domain_create(struct m0_be_domain *dom,
+                                     struct m0_stob *stob)
+{
+
+}
+
+M0_INTERNAL void m0_be_domain_init(struct m0_be_domain *dom,
+                                   struct m0_stob *stob,
+                                   struct m0_stob *log_stob,
+                                   uint64_t dom_magic)
+{
+        int result;
+        m0_time_t t;
+
+        M0_ASSERT(dom != NULL);
+
+        dom->bd_data.bs_stob    = stob;
+        dom->bd_impl.log_stob   = log_stob;
+        dom->bd_magic           = dom_magic;
+
+        m0_sm_group_init(&dom->bd_impl.sm_group);
+
+        /** Do not worry this is not infinite loop. */
+        while(1) {
+                result = M0_THREAD_INIT(&dom->bd_impl.th, struct m0_sm_group *,
+                                        NULL, &m0_be_handler_thread,
+                                        &dom->bd_impl.sm_group,
+                                        "Backend handler thread");
+                if (result == 0) {
+                        /** Thread creation successfully. */
+                        break;
+                } else {
+                        /** Retrying to create thread. */
+                        m0_thread_fini(&dom->bd_impl.th);
+                        m0_nanosleep(m0_time_set(&t, 1, 0), NULL);
+                }
+        }
+        m0_be_seg_init(&dom->bd_data, dom, &dom->bd_impl.sm_group, 0);
+
+        /**
+         * @todo - Need to decide if m0_be_seg_init should be called
+         * instead of M0_BESEG_CLOSED state assignment
+         **/
+        m0_sm_group_lock(&dom->bd_impl.sm_group);
+        m0_sm_state_set(&dom->bd_data.bs_sm, M0_BESEG_CLOSED);
+        m0_sm_group_unlock(&dom->bd_impl.sm_group);
+
+        m0_be_seg_tlist_init(&dom->bd_seg);
+
+        m0_be_tx_tlist_init(&dom->bd_tx);
+
+        /**
+         * This is just temporary, when we integrate backend-domain with mero
+         * this needs to be removed.
+         */
+        m0_be_init();
+}
+
+M0_INTERNAL int m0_be_domain_lookup(struct m0_be_domain *dom, const char *name,
+                                     struct m0_be_seg *out)
+{
+        struct m0_be_seg *seg_it;
+        int found = -1;
+
+        M0_ASSERT(dom != NULL);
+
+        M0_PRE(m0_be_seg_state_get(&dom->bd_data) == M0_BESEG_ACTIVE);
+
+        m0_tlist_for(&m0_be_seg_tl, &dom->bd_seg, seg_it) {
+                if (strcmp(name, seg_it->bs_impl.segment_name) == 0) {
+                        memcpy(out, seg_it, sizeof(struct m0_be_seg));
+                        found = 0;
+                        break;
+                }
+        } m0_tlist_endfor;
+
+        /* This fills/adds segment into in-memory segment list on demand */
+        if (found != 0) {
+                /* @todo - if found in persistent memory of named segment, then
+                 * add into the in-memory active segment list
+                 * m0_be_seg_tlist_add(&dom->bd_seg, out);
+                 */
+        }
+
+        if ((found != 0) && (m0_be_seg_state_get(out) == M0_BESEG_CLOSED)) {
+                m0_be_seg_open(out);
+        }
+
+        return found;
+}
+
+M0_INTERNAL void m0_be_domain_fini(struct m0_be_domain *dom)
+{
+        struct m0_be_seg         *seg_it;
+        struct m0_be_tx          *tx_it;
+
+        M0_PRE(M0_IN(m0_be_seg_state_get(&dom->bd_data), (M0_BESEG_CLOSED,
+                                                         M0_BESEG_FAILED)));
+
+        m0_tlist_for (&m0_be_tx_tl, &dom->bd_tx, tx_it) {
+                m0_be_tx_tlink_del_fini(tx_it);
+        } m0_tlist_endfor;
+
+        m0_tlist_for (&m0_be_seg_tl, &dom->bd_seg, seg_it) {
+                m0_be_seg_tlink_del_fini(seg_it);
+                m0_be_seg_fini(seg_it);
+        } m0_tlist_endfor;
+
+        /* Finilize segment list */
+        m0_be_seg_tlist_fini(&dom->bd_seg);
+
+        /* Finilize transaction list */
+        m0_be_tx_tlist_fini(&dom->bd_tx);
+
+        /* Finalize log device stob */
+        m0_stob_fini(dom->bd_impl.log_stob);
+}
+
+M0_INTERNAL void m0_be_domain_restore(struct m0_be_domain *dom, 
+                                      const char          *name,
+                                      struct m0_be_seg    *out)
+{
+        struct  m0_be_seg        *seg_it;
+        struct  m0_stob_domain   *stob_dom;
+        struct  m0_stob_id        stob_id = {{0, 1}}; /** Hardcoded for now */
+        int                       result;
+        bool                      stob_directio = true;
+        int                       found = 0;
+
+        M0_ASSERT(dom != NULL);
+
+        M0_PRE(m0_be_seg_state_get(&dom->bd_data) == M0_BESEG_ACTIVE);
+
+        m0_tlist_for(&m0_be_seg_tl, &dom->bd_seg, seg_it) {
+                if (strcmp(name, seg_it->bs_impl.segment_name) == 0) {
+                        memcpy(out, seg_it, sizeof(struct m0_be_seg));
+                        found = 1;
+                        break;
+                }
+        } m0_tlist_endfor;
+
+        if (found && (m0_be_seg_state_get(out) == M0_BESEG_CLOSED)) {
+                m0_be_seg_open(out);
+        }
+
+        if (!found) {
+                out->bs_impl.segment_id = 1;
+
+                m0_be_seg_init(out, dom, &dom->bd_impl.sm_group, 0);
+
+                m0_stob_type_init(&m0_linux_stob_type);
+                result = m0_stob_domain_locate(&m0_linux_stob_type,
+                                               "./__be",
+                                               &stob_dom);
+                M0_ASSERT(result == 0);
+
+                result = m0_linux_stob_setup(stob_dom, stob_directio);
+                M0_ASSERT(result == 0);
+
+                result = m0_stob_find(stob_dom, &stob_id, &out->bs_stob);
+                M0_ASSERT(result == 0);
+
+                result = m0_stob_create(out->bs_stob, NULL);
+
+                if (result < 0) {
+                        out->bs_stob->so_state = CSS_UNKNOWN;
+                }
+
+                m0_be_seg_open(out);
+
+                m0_be_seg_tlink_init(out);
+                m0_be_seg_tlist_add(&dom->bd_seg, out);
+        }
+}
+
+
+M0_INTERNAL void m0_be_handler_thread(struct m0_sm_group *sm_group)
+{
+        while(1) {
+                /**
+                 * 1) Wait on  the channel.
+                 * 2) Wake on new request -
+                 *      a) Lock the sm group.
+                 *      b) Call as ast callback for the request.
+                 *      c) Unlock sm group when done with the callback.
+                 * 3) Go to step 1.
+                 *
+                 * @note - No need to lock sm_group in callback as it is locked
+                 * before calling the callback.
+                 */
+                m0_chan_wait(&sm_group->s_clink);
+                m0_sm_group_lock(sm_group);
+                m0_sm_asts_run(sm_group);
+                m0_sm_group_unlock(sm_group);
+        }
+}
+
+struct m0_sm_group *m0_be_domain_sm_group(struct m0_be_domain *dom) {
+        return &dom->bd_impl.sm_group;
+}
+
+bool m0_be_domain_invariant(const struct m0_be_domain *dom) {
+
+        return true;
+}
+
+/** @} end group be_domain */
+
+/*
+ *  Local variables:
+ *  c-indentation-style: "K&R"
+ *  c-basic-offset: 8
+ *  tab-width: 8
+ *  fill-column: 80
+ *  scroll-step: 1
+ *  End:
+ */
diff --git a/be/domain.h b/be/domain.h
new file mode 100644
index 0000000..43c2d95
--- /dev/null
+++ b/be/domain.h
@@ -0,0 +1,54 @@
+/*
+ * COPYRIGHT 2013 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: Sachin Patil <sachin_patil@xyratex.com>
+ * Original creation date: 25 Jan 2013
+ */
+
+#pragma once
+
+#ifndef __MERO_BE_DOMAIN_H__
+#define __MERO_BE_DOMAIN_H__
+
+/**
+  @defgroup be (Meta-data) back-end
+  @{
+*/
+
+#include "be/be.h"
+/**
+ * Handler thread for backend domain.
+ */
+M0_INTERNAL void m0_be_handler_thread(struct m0_sm_group *sm_group);
+
+/**
+ * This is just helper function to return sm_group pointer from the domain.
+ */
+struct m0_sm_group *m0_be_domain_sm_group(struct m0_be_domain *dom);
+
+/** @} end of be group */
+
+/* __MERO_BE_DOMAIN_H__ */
+#endif
+
+/*
+ *  Local variables:
+ *  c-indentation-style: "K&R"
+ *  c-basic-offset: 8
+ *  tab-width: 8
+ *  fill-column: 80
+ *  scroll-step: 1
+ *  End:
+ */
diff --git a/be/reg.c b/be/reg.c
new file mode 100644
index 0000000..1205852
--- /dev/null
+++ b/be/reg.c
@@ -0,0 +1,468 @@
+/*
+ * COPYRIGHT 2012 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: Sachin Patil <sachin_patil@xyratex.com>
+ * Original creation date: 30 Nov 2012
+ */
+
+#include "be/be.h"
+#include "be/domain.h"
+#include "be/reg.h"
+#include "be/tx.h"
+
+#include "be/rds.h"
+
+
+/**
+        Back-end
+
+  @addtogroup be
+  @{
+  */
+
+/* State machine variable declarations  */
+static const struct m0_sm_state_descr reg_states[] = {
+        [M0_BEREG_INIT] = {
+                .sd_flags     = M0_SDF_INITIAL,
+                .sd_name      = "Init",
+                .sd_allowed   = M0_BITS(M0_BEREG_ALLOCATING,
+                                        M0_BEREG_FREEING,
+                                        M0_BEREG_CAPTURING,
+                                        M0_BEREG_FAILED)
+        },
+        [M0_BEREG_ALLOCATING] = {
+                .sd_flags     = 0,
+                .sd_name      = "Allocating",
+                .sd_allowed   = M0_BITS(M0_BEREG_ALLOCATED,
+                                        M0_BEREG_FAILED)
+        },
+        [M0_BEREG_ALLOCATED] = {
+                .sd_flags     = 0,
+                .sd_name      = "Allocated",
+                .sd_allowed   = M0_BITS(M0_BEREG_CAPTURING,
+                                        M0_BEREG_FREEING,
+                                        M0_BEREG_FAILED)
+        },
+        [M0_BEREG_CAPTURING] = {
+                .sd_flags     = 0,
+                .sd_name      = "Capturing",
+                .sd_allowed   = M0_BITS(M0_BEREG_CAPTURED,
+                                        M0_BEREG_DONE,
+                                        M0_BEREG_FAILED)
+        },
+        [M0_BEREG_CAPTURED] = {
+                .sd_flags     = 0,
+                .sd_name      = "Captured",
+                .sd_allowed   = M0_BITS(M0_BEREG_DONE,
+                                        M0_BEREG_FAILED)
+        },
+        [M0_BEREG_DONE] = {
+                .sd_flags     = M0_SDF_FINAL,
+                .sd_name      = "Done",
+                .sd_allowed   = M0_BITS(M0_BEREG_FREEING)
+        },
+        [M0_BEREG_FREEING] = {
+                .sd_flags     = 0,
+                .sd_name      = "Freeing",
+                .sd_allowed   = M0_BITS(M0_BEREG_FREED,
+                                        M0_BEREG_FAILED)
+        },
+        [M0_BEREG_FREED] = {
+                .sd_flags     = M0_SDF_TERMINAL,
+                .sd_name      = "Freed",
+                .sd_allowed   = 0,
+        },
+        [M0_BEREG_FAILED] = {
+                .sd_flags     = M0_SDF_FAILURE,
+                .sd_name      = "Failed",
+                .sd_allowed   = M0_BITS(M0_BEREG_FREEING,
+                                        M0_BEREG_FAILED)
+        },
+};
+
+static const struct m0_sm_conf reg_conf = {
+        .scf_name      = "Region States",
+        .scf_nr_states = ARRAY_SIZE(reg_states),
+        .scf_state     = reg_states
+};
+
+
+static void *static_reg_start_addr = NULL;
+
+/**
+ * @post m0_be_reg_state_get(reg) == M0_BEREG_INIT
+ */
+M0_INTERNAL void m0_be_reg_init(struct m0_be_reg *reg, struct m0_be_tx *tx,
+                                struct m0_be_seg *seg,  struct m0_be_buf *buf)
+{
+        /* Asserting on required pointers */
+        M0_ASSERT(reg != NULL);
+        M0_ASSERT(seg != NULL);
+        M0_ASSERT(buf != NULL);
+
+        /* Initialise region structure with required values */
+        reg->br_tx  = tx;
+        reg->br_tx_cbdata.datum = NULL;
+        reg->br_tx_cbdata.m0_be_tx_pre_cb = m0_be_tx_get_capture_status;
+        reg->br_tx_cbdata.m0_be_tx_post_cb = m0_be_tx_set_capture_status;
+
+        reg->br_seg = seg;
+
+        reg->br_buf.b_nob = buf->b_nob;
+        reg->br_buf.logical_address = buf->logical_address;
+
+        /* Lock sm group */
+        m0_sm_group_lock(m0_be_domain_sm_group(reg->br_seg->bs_dom));
+
+        /* Register the state machine of the tx into sm_group */
+        m0_sm_init(&reg->br_sm, &reg_conf, M0_BEREG_INIT,
+                  m0_be_domain_sm_group(reg->br_seg->bs_dom), NULL);
+
+        /* Unlock locked sm group */
+        m0_sm_group_unlock(m0_be_domain_sm_group(reg->br_seg->bs_dom));
+}
+
+/**
+ * Allocates a region.
+ * Updates m0_reference of region that can be used to persist pointers
+ *
+ * @pre m0_be_reg_state_get(reg) == M0_BEREG_INIT
+ * @pre reg->br_buf.b_addr == NULL
+ * @post M0_IN(m0_be_reg_state_get(reg), (M0_BEREG_ALLOCATING, 
+ *                                        M0_BEREG_ALLOCATED,M0_BEREG_FAILED))
+ */
+
+M0_INTERNAL void m0_be_alloc(struct m0_be_reg *reg)
+{
+        /* Asserting on required pointers */
+        M0_ASSERT(reg != NULL);
+
+        /* Locking sm group before setting sm_state */
+        m0_sm_group_lock(m0_be_domain_sm_group(reg->br_seg->bs_dom));
+
+        m0_sm_state_set(&reg->br_sm, M0_BEREG_ALLOCATING);
+
+        /* Unlock locked sm group */
+        m0_sm_group_unlock(m0_be_domain_sm_group(reg->br_seg->bs_dom));
+
+        reg->br_sm_ast.sa_cb    = m0_be_alloc_cb;
+        reg->br_sm_ast.sa_datum = (void *)reg;
+
+        m0_be_reg_req_post(m0_be_domain_sm_group(reg->br_seg->bs_dom),
+                           &reg->br_sm_ast);
+}
+
+/**
+ * Frees a region.
+ *
+ * Freeing NULL is a no-op.
+ *
+ * @pre M0_IN(m0_be_reg_state_get(reg), (M0_BEREG_INIT, M0_BEREG_ALLOCATED,
+ *                                       M0_BEREG_DONE, M0_BEREG_FAILED))
+ * @post M0_IN(m0_be_reg_state_get(reg), (M0_BEREG_FREEING, M0_BEREG_FREED,
+ *                                        M0_BEREG_FAILED))
+ */
+M0_INTERNAL void m0_be_free(struct m0_be_reg *reg)
+{
+        /* Asserting on required pointers */
+        M0_ASSERT(reg != NULL);
+
+        /* @todo - Need to understand pre condition check */
+        /* Locking sm group before setting sm_state */
+        m0_sm_group_lock(m0_be_domain_sm_group(reg->br_seg->bs_dom));
+        m0_sm_state_set(&reg->br_sm, M0_BEREG_FREEING);
+        /* Unlock locked sm group */
+        m0_sm_group_unlock(m0_be_domain_sm_group(reg->br_seg->bs_dom));
+
+        reg->br_sm_ast.sa_cb    = m0_be_free_cb;
+        reg->br_sm_ast.sa_datum = (void *)reg;
+
+        m0_be_reg_req_post(m0_be_domain_sm_group(reg->br_seg->bs_dom),
+                           &reg->br_sm_ast);
+}
+
+/**
+ * Pre-fetches a region.
+ *
+ * This doesn't incur a state change in region state machine and doesn't report
+ * failures.
+ *
+ * @pre m0_be_reg_state_get(reg) == M0_BEREG_INIT
+ * @pre reg->br_buf.b_addr != NULL
+ */
+M0_INTERNAL void m0_be_prefetch(const struct m0_be_reg *reg)
+{
+
+}
+
+
+/**
+ * Un-pins the region, pinned by m0_be_get().
+ *
+ * @pre m0_be_reg_state_get(reg) == M0_BEREG_INIT
+ * @pre reg->br_buf.b_addr != NULL
+ * @post M0_IN(m0_be_reg_state_get(reg), (M0_BEREG_INPROGRESS, M0_BEREG_SUCCEED,
+ *                                        M0_BEREG_FAILED))
+ */
+M0_INTERNAL void m0_be_put(const struct m0_be_reg *reg)
+{
+
+}
+
+/**
+ * Captures a region in a transaction.
+ *
+ * @pre m0_be_tx_state_get(tx) == M0_BETX_OPEN
+ * @pre M0_IN(m0_be_reg_state_get(reg), (M0_BEREG_INIT, M0_BEREG_ALLOCATED))
+ * @post M0_IN(m0_be_reg_state_get(reg), (M0_BEREG_CAPTURING, M0_BEREG_CAPTURED,
+ *                                        M0_BEREG_FAILED))
+ */
+M0_INTERNAL void m0_be_reg_capture(struct m0_be_reg *reg)
+{
+        struct m0_sm_group *sm_group;
+        int                 grp_locked = 0;
+
+        /* Asserting on required pointers */
+        M0_ASSERT(reg != NULL);
+        M0_ASSERT(reg->br_tx != NULL);
+
+        M0_PRE(M0_IN(m0_be_reg_state_get(reg), (M0_BEREG_INIT,
+                                                M0_BEREG_ALLOCATED)));
+
+        sm_group = m0_be_domain_sm_group(reg->br_seg->bs_dom);
+
+        M0_ASSERT(sm_group != NULL);
+
+        /* Locking sm group before setting sm_state if not locked */
+        if(!m0_mutex_is_locked(&sm_group->s_lock)) {
+                grp_locked = 1;
+                m0_sm_group_lock(sm_group);
+        }
+
+        m0_sm_state_set(&reg->br_sm, M0_BEREG_CAPTURING);
+
+        /* Unlock locked sm group if locked locally */
+        if(grp_locked)
+                m0_sm_group_unlock(sm_group);
+
+        reg->br_sm_ast.sa_cb    = m0_be_reg_capture_cb;
+        reg->br_sm_ast.sa_datum = (void *)reg;
+
+        m0_be_reg_req_post(sm_group, &reg->br_sm_ast);
+
+}
+
+/**
+ * @pre M0_IN(m0_be_reg_state_get(reg), (M0_BEREG_DONE, M0_BEREG_FAILED))
+ */
+M0_INTERNAL void m0_be_reg_fini(struct m0_be_reg *reg)
+{
+
+        M0_PRE(M0_IN(m0_be_reg_state_get(reg), (M0_BEREG_DONE,
+                                                M0_BEREG_FAILED)));
+
+        /* todo@ Finalizing on state machine */
+}
+
+/**
+ * The function posts reg request to state machine thread
+ *
+ */
+M0_INTERNAL void m0_be_reg_req_post(struct m0_sm_group *sm_group,
+                                 struct m0_sm_ast *sm_ast)
+{
+        m0_sm_ast_post(sm_group, sm_ast);
+}
+
+/**
+ * Callback function for allocation of region
+ *
+ */
+
+M0_INTERNAL void m0_be_alloc_cb(struct m0_sm_group *sm_group,
+                                  struct m0_sm_ast *sm_ast)
+{
+        struct m0_be_reg *reg;
+        struct m0_uint128 *toffset;
+        rvm_tid_t *tid = NULL;
+        int             err;
+        uint64_t hi;
+        long int lo;
+
+        /* Asserting on required pointers */
+        M0_ASSERT(sm_group != NULL);
+        M0_ASSERT(sm_ast != NULL);
+
+        reg = (struct m0_be_reg *)sm_ast->sa_datum;
+
+        M0_ASSERT(reg != NULL);
+
+        if (reg->br_tx != NULL)
+                tid = reg->br_tx->bt_impl.tx_id;
+
+        reg->br_buf.b_addr = (void *)rds_malloc(reg->br_buf.b_nob,
+                                                tid, &err);
+
+
+        /* Assign domain magic to reg reference magic  to identify references
+         * within the domain.
+         */
+        reg->br_buf.logical_address.magic = reg->br_seg->bs_dom->bd_magic;
+
+        toffset = &reg->br_buf.logical_address.segid_offset;
+
+        hi = reg->br_seg->bs_impl.segment_id;
+        lo = (reg->br_seg->bs_addr - reg->br_buf.b_addr);
+
+
+       if (lo < 0)
+                 lo = -1 * lo;
+
+        toffset->u_hi = hi;
+        toffset->u_lo = lo;
+
+        m0_sm_state_set(&reg->br_sm, M0_BEREG_ALLOCATED);
+
+        return;
+}
+
+/**
+ * Callback function for freeing of region
+ *
+ */
+
+M0_INTERNAL void m0_be_free_cb(struct m0_sm_group *sm_group,
+                                  struct m0_sm_ast *sm_ast)
+{
+        int             err;
+        rvm_tid_t      *tid = NULL;
+        struct m0_be_reg *reg;
+
+        /* Asserting on required pointers */
+        M0_ASSERT(sm_group != NULL);
+        M0_ASSERT(sm_ast != NULL);
+
+        reg = (struct m0_be_reg *)sm_ast->sa_datum;
+
+        M0_ASSERT(reg != NULL);
+
+        if (reg->br_tx != NULL)
+                tid = reg->br_tx->bt_impl.tx_id;
+        /*
+         * Allocate memory from RDS Heap.
+         * Update br_buf to store virtual address.
+         */
+
+        rds_free((char *)reg->br_buf.b_addr, tid, &err);
+
+        if (err != SUCCESS)
+                goto error_exit;
+
+        reg->br_buf.b_addr                              = NULL;
+        reg->br_buf.logical_address.segid_offset.u_hi   = 0;
+        reg->br_buf.logical_address.segid_offset.u_lo   = 0;
+
+        m0_sm_state_set(&reg->br_sm, M0_BEREG_FREED);
+
+error_exit:
+        m0_sm_state_set(&reg->br_sm, M0_BEREG_FAILED);
+}
+
+
+/**
+ * Callback function for capturing region
+ *
+ */
+M0_INTERNAL void m0_be_reg_capture_cb(struct m0_sm_group *sm_group,
+                                      struct m0_sm_ast *sm_ast)
+{
+        struct m0_be_reg *reg;
+        rvm_return_t ret;
+        int result;
+        enum m0_be_reg_state reg_st = M0_BEREG_FAILED;
+
+
+        /* Asserting on required pointers */
+        M0_ASSERT(sm_group != NULL);
+        M0_ASSERT(sm_ast != NULL);
+
+        reg = (struct m0_be_reg *)sm_ast->sa_datum;
+
+        M0_ASSERT(reg != NULL);
+
+        if(reg->br_tx_cbdata.datum) {
+                result = reg->br_tx_cbdata.m0_be_tx_pre_cb(
+                                        reg->br_tx_cbdata.datum);
+                /**
+                 * Do not perform rvm_set_range on current region if region
+                 * capture is failed for any previous region
+                 */
+                if( result == M0_BETX_PREP_FAILED) {
+                        reg_st = M0_BEREG_DONE;
+                        goto reg_done_exit;
+                }
+         }
+
+        ret = rvm_set_range(reg->br_tx->bt_impl.tx_id,
+                            reg->br_buf.b_addr,
+                            reg->br_buf.b_nob);
+
+        if(RVM_SUCCESS == ret)
+                reg_st = M0_BEREG_CAPTURED;
+
+
+reg_done_exit:
+        m0_sm_state_set(&reg->br_sm, reg_st);
+
+        if(reg->br_tx_cbdata.datum) {
+                reg->br_tx_cbdata.m0_be_tx_post_cb(reg->br_tx_cbdata.datum);
+        }
+}
+
+M0_INTERNAL void m0_be_static_reg_init(void *start_addr)
+{
+        static_reg_start_addr = start_addr;
+}
+
+M0_INTERNAL void m0_be_static_reg_capture_buf(uint64_t offset,
+                                              struct m0_be_reg *reg,
+                                              struct m0_be_tx *tx)
+{
+        m0_be_tx_add_cred(tx, reg);
+
+        m0_be_tx_prep(tx);
+}
+
+M0_INTERNAL void *m0_be_static_reg_get_handle_addr(uint64_t offset)
+{
+        return (static_reg_start_addr + offset);
+}
+
+uint32_t m0_be_reg_state_get(const struct m0_be_reg *reg)
+{
+        return reg->br_sm.sm_state;
+}
+
+/** @} end group be */
+
+/*
+ *  Local variables:
+ *  c-indentation-style: "K&R"
+ *  c-basic-offset: 8
+ *  tab-width: 8
+ *  fill-column: 80
+ *  scroll-step: 1
+ *  End:
+ */
diff --git a/be/reg.h b/be/reg.h
new file mode 100644
index 0000000..6118904
--- /dev/null
+++ b/be/reg.h
@@ -0,0 +1,71 @@
+/*
+ * COPYRIGHT 2012 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: Sachin Patil <sachin_patil@xyratex.com>
+ * Original creation date: 27 Dec 2012
+ */
+
+#pragma once
+
+#ifndef __MERO_BE_BE_REG_H__
+#define __MERO_BE_BE_REG_H__
+
+/**
+  @defgroup be (Meta-data) back-end
+  @{
+  */
+#include "be/be.h"
+
+M0_INTERNAL void m0_be_alloc_cb(struct m0_sm_group  *sm_group,
+                                struct m0_sm_ast *sm_ast);
+
+M0_INTERNAL void m0_be_free_cb(struct m0_sm_group *sm_group,
+                               struct m0_sm_ast *sm_ast);
+
+M0_INTERNAL void m0_be_reg_capture_cb(struct m0_sm_group *sm_group,
+                                      struct m0_sm_ast *sm_ast);
+
+M0_INTERNAL void m0_be_reg_req_post(struct m0_sm_group *sm_group,
+                                    struct m0_sm_ast *sm_ast);
+
+/**
+ * Handle store support APIs
+ * Due to RVM limitation of single segment support,
+ * the static region from segment is used as a handle store.
+ */
+M0_INTERNAL void m0_be_static_reg_init();
+
+M0_INTERNAL void m0_be_static_reg_capture_buf(uint64_t offset,
+                                             struct m0_be_reg *reg,
+                                             struct m0_be_tx *tx);
+
+M0_INTERNAL void *m0_be_static_reg_get_handle_addr(uint64_t offset);
+
+uint32_t m0_be_reg_state_get(const struct m0_be_reg *reg);
+
+/** @} end of be group */
+
+/* __MERO_BE_BE_REG_H__ */
+#endif
+
+/*
+ *  Local variables:
+ *  c-indentation-style: "K&R"
+ *  c-basic-offset: 8
+ *  tab-width: 8
+ *  fill-column: 80
+ *  scroll-step: 1
+ *  End:
+ */
diff --git a/be/seg.c b/be/seg.c
new file mode 100644
index 0000000..ab1b594
--- /dev/null
+++ b/be/seg.c
@@ -0,0 +1,482 @@
+/*
+ * COPYRIGHT 2012 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: Sachin Patil <sachin_patil@xyratex.com>
+ * Original creation date: 12 Nov 2012
+ */
+
+#include "be/be.h"
+#include "be/be_private.h"
+#include "be/seg.h"
+#include "be/domain.h"
+#include "be/be_rvm.h"
+#include "be/rds.h"
+
+#include "stob/linux.h"
+#include "stob/linux_internal.h"
+
+/**
+  @addtogroup be_seg
+  @{
+*/
+
+/** State machine states for backend segment */
+
+static const struct m0_sm_state_descr m0_be_seg_states[] = {
+        [M0_BESEG_INIT] = {
+                .sd_flags     = M0_SDF_INITIAL,
+                .sd_name      = "Init",
+                .sd_allowed   = M0_BITS(M0_BESEG_CREATING, M0_BESEG_OPENING,
+                                        M0_BESEG_CLOSED, M0_BESEG_FAILED)
+        },
+
+        [M0_BESEG_CREATING] = {
+                .sd_flags     = 0,
+                .sd_name      = "Creating",
+                .sd_allowed   = M0_BITS(M0_BESEG_ACTIVE, M0_BESEG_FAILED)
+        },
+        /**
+         * [M0_BESEG_CREATED] = {
+                .sd_flags     = 0,
+                .sd_name      = "BE SEG CREATED",
+                .sd_allowed   = M0_BITS(M0_BESEG_OPENING, M0_BESEG_ACTIVE,
+                                        M0_BESEG_FAILED)
+         * },
+         */
+
+        [M0_BESEG_OPENING] = {
+                .sd_flags     = 0,
+                .sd_name      = "Opening",
+                .sd_allowed   = M0_BITS(M0_BESEG_ACTIVE, M0_BESEG_FAILED)
+        },
+
+        [M0_BESEG_ACTIVE] = {
+                .sd_flags     = 0,
+                .sd_name      = "Active",
+                .sd_allowed   = M0_BITS(M0_BESEG_CLOSING, M0_BESEG_CLOSED,
+                                        M0_BESEG_FAILED)
+        },
+
+        [M0_BESEG_CLOSING] = {
+                .sd_flags     = 0,
+                .sd_name      = "Closing",
+                .sd_allowed   = M0_BITS(M0_BESEG_CLOSED, M0_BESEG_FAILED)
+        },
+
+        [M0_BESEG_CLOSED] = {
+                .sd_flags     = M0_SDF_FINAL,
+                .sd_name      = "Closed",
+                .sd_allowed   = M0_BITS(M0_BESEG_OPENING, M0_BESEG_ACTIVE,
+                                        M0_BESEG_FAILED)
+        },
+
+        [M0_BESEG_CHECKING] = {
+                .sd_flags     = 0,
+                .sd_name      = "Checking",
+                .sd_allowed   = M0_BITS(M0_BESEG_CHECKING, M0_BESEG_CLOSED,
+                                        M0_BESEG_FAILED)
+        },
+
+        [M0_BESEG_DELETING] = {
+                .sd_flags     = 0,
+                .sd_name      = "Deleting",
+                .sd_allowed   = M0_BITS(M0_BESEG_DELETING, M0_BESEG_CLOSED,
+                                        M0_BESEG_FAILED)
+        },
+
+        [M0_BESEG_FAILED] = {
+                .sd_flags     = M0_SDF_FAILURE,
+                .sd_name      = "Failed",
+                .sd_allowed   = 0
+        }
+};
+
+static const struct m0_sm_conf seg_conf = {
+        .scf_name      = "Segment States",
+        .scf_nr_states = ARRAY_SIZE(m0_be_seg_states),
+        .scf_state     = m0_be_seg_states
+};
+
+M0_INTERNAL void m0_be_seg_create(struct m0_be_seg *seg, struct m0_be_tx *tx,
+                                  const char *name, struct m0_stob *stob)
+{
+        M0_PRE(seg->bs_sm.sm_state == M0_BESEG_INIT);
+
+        m0_sm_group_lock(m0_be_domain_sm_group(seg->bs_dom));
+
+        m0_sm_state_set(&seg->bs_sm, M0_BESEG_CREATING);
+
+        m0_sm_group_unlock(m0_be_domain_sm_group(seg->bs_dom));
+
+        seg->bs_stob = stob;
+        strcpy(seg->bs_impl.segment_name, name);
+
+        seg->bs_sm_ast.sa_cb    = m0_be_seg_create_cb;
+        seg->bs_sm_ast.sa_datum = (void *)seg;
+
+        m0_seg_req_post(m0_be_domain_sm_group(seg->bs_dom), &seg->bs_sm_ast);
+}
+
+M0_INTERNAL void m0_be_seg_init(struct m0_be_seg *seg,
+                                struct m0_be_domain *dom,
+                                struct m0_sm_group *sm_group,
+                                uint64_t flags)
+{
+        M0_ASSERT(seg != NULL);
+        M0_ASSERT(dom != NULL);
+
+        /* Initialise domain structure with required values */
+        seg->bs_dom = dom;
+
+        /* Hardcoded for time being. */
+        seg->bs_impl.segment_id = 1;
+
+        /**
+         * Need to make it null because it is referenced into rvm callback to
+         * decide operation status
+         */
+        seg->bs_page.bp_addr = NULL;
+
+        m0_sm_group_lock(sm_group);
+
+        /* Register the state machine of the segment into sm_group */
+        m0_sm_init(&seg->bs_sm, &seg_conf, M0_BESEG_INIT, sm_group,
+                        &seg->bs_addb);
+
+        m0_sm_group_unlock(sm_group);
+}
+
+M0_INTERNAL void m0_be_seg_open(struct m0_be_seg *seg)
+{
+        M0_ASSERT(seg != NULL);
+
+        M0_PRE(M0_IN(m0_be_seg_state_get(seg), (M0_BESEG_INIT,
+                                                M0_BESEG_CLOSED)));
+
+        M0_PRE(m0_be_seg_state_get(&seg->bs_dom->bd_data) == M0_BESEG_ACTIVE);
+
+        m0_sm_group_lock(m0_be_domain_sm_group(seg->bs_dom));
+
+        m0_sm_state_set(&seg->bs_sm, M0_BESEG_OPENING);
+
+        m0_sm_group_unlock(m0_be_domain_sm_group(seg->bs_dom));
+
+        seg->bs_sm_ast.sa_cb    = m0_be_seg_open_cb;
+        seg->bs_sm_ast.sa_datum = (void *)seg;
+
+        m0_seg_req_post(m0_be_domain_sm_group(seg->bs_dom), &seg->bs_sm_ast);
+}
+
+M0_INTERNAL void m0_be_seg_done(struct m0_be_seg *seg)
+{
+        M0_ASSERT(seg != NULL);
+
+        M0_PRE(m0_be_seg_state_get(seg) == M0_BESEG_ACTIVE);
+
+        m0_sm_group_lock(m0_be_domain_sm_group(seg->bs_dom));
+
+        m0_sm_state_set(&seg->bs_sm, M0_BESEG_CLOSED);
+
+        m0_sm_group_unlock(m0_be_domain_sm_group(seg->bs_dom));
+
+        /* @todo - Start unmapping the segment */
+}
+
+M0_INTERNAL void m0_be_seg_fini(struct m0_be_seg *seg)
+{
+        M0_ASSERT(seg != NULL);
+
+        M0_PRE(M0_IN(m0_be_seg_state_get(seg), (M0_BESEG_CLOSED,
+                                                M0_BESEG_FAILED)));
+
+        /* Finalizing on state machine */
+        m0_sm_fini(&seg->bs_sm);
+
+        /* Finalizing respective stob */
+        m0_stob_fini(seg->bs_stob);
+
+        /* Removing entry from in memory segment list if present */
+        if (m0_be_seg_tlink_is_in(seg))
+                m0_be_seg_tlink_del_fini(seg);
+}
+
+M0_INTERNAL void m0_be_seg_delete(struct m0_be_seg *seg, struct m0_be_tx *tx)
+{
+        uint64_t segment_id;
+        struct m0_be_domain *dom;
+
+        M0_ASSERT(seg != NULL);
+        M0_ASSERT(tx != NULL);
+
+        M0_PRE(seg->bs_sm.sm_state == M0_BESEG_CLOSED);
+
+        m0_sm_group_lock(m0_be_domain_sm_group(seg->bs_dom));
+
+        m0_sm_state_set(&seg->bs_sm, M0_BESEG_DELETING);
+
+        m0_sm_group_unlock(m0_be_domain_sm_group(seg->bs_dom));
+
+        /* Removing entry from in memory in segment list if present */
+        /* todo@ Need some kind of log here if condition is false */
+        if (m0_be_seg_tlink_is_in(seg))
+                m0_be_seg_tlink_del_fini(seg);
+
+        /**
+         * The following veriables are needed to remove entry from named
+         * segment
+         */
+        segment_id = seg->bs_impl.segment_id;
+        dom        = seg->bs_dom;
+
+        /* @todo - remove entry from named segment transactionally */
+}
+
+M0_INTERNAL void m0_be_seg_check(struct m0_be_seg *seg, struct m0_be_tx *tx)
+{
+        M0_ASSERT(seg != NULL);
+        M0_ASSERT(tx != NULL);
+
+        /* @todo - not clear idea about what to do in this at the moment */
+}
+
+M0_INTERNAL void m0_be_seg_fail(struct m0_be_seg *seg)
+{
+        M0_ASSERT(seg != NULL);
+
+        m0_sm_group_lock(m0_be_domain_sm_group(seg->bs_dom));
+
+        m0_sm_state_set(&seg->bs_sm, M0_BESEG_FAILED);
+
+        m0_sm_group_unlock(m0_be_domain_sm_group(seg->bs_dom));
+}
+
+M0_INTERNAL void m0_seg_req_post(struct m0_sm_group *sm_group,
+                                 struct m0_sm_ast *sm_ast)
+{
+        m0_sm_ast_post(sm_group, sm_ast);
+}
+
+/**
+ * The function calls rvm api's to create and open segment.
+ *
+ */
+M0_INTERNAL void m0_be_seg_create_cb(struct m0_sm_group *sm_group,
+                                     struct m0_sm_ast *sm_ast)
+{
+        struct m0_be_seg *seg;
+
+        M0_ASSERT(sm_group != NULL);
+        M0_ASSERT(sm_ast != NULL);
+
+        seg = (struct m0_be_seg *)sm_ast->sa_datum;
+
+        /* Generate new segment id */
+
+        /**
+        struct m0_be_named_seg_hdr *named_seg_hdr;
+        named_seg_hdr = (struct m0_be_named_seg_hdr *)
+                        seg->bs_dom->bd_data.bs_addr;
+        M0_ASSERT(NULL != named_seg_hdr);
+        seg->bs_impl.segment_id = named_seg_hdr->max_segment_index + 1;
+        */
+
+        /* Create linux stob */
+        /* @todo - Please revisit this when have better understanding
+         * of linux stob
+         */
+        struct  m0_stob_domain   *stob_dom;
+        bool                      stob_directio = true;
+        struct  m0_stob_id        stob_id = {{0, seg->bs_impl.segment_id}};
+        int                       result;
+        struct linux_stob        *lstob;
+        struct linux_domain      *ldom;
+        int                       nbytes = 0;
+        int                       err;
+        unsigned long             dev_length        = RVM_SEGMENT_SIZE;
+        unsigned long             heap_length       = RVM_HEAP_SIZE;
+        char                     *start_Addr        = (char *)0xbebd000;
+        char                     *static_addr       = NULL;
+        long                      rds_static_len    = 0;
+        long                      nlist             = RVM_NLIST;
+        long                      chunk_size        = RVM_CHUNK_SIZE;
+        /* initialize stob type */
+        m0_stob_type_init(&m0_linux_stob_type);
+
+        /* @todo - stob path is hardcoded for now */
+        result = m0_stob_domain_locate(&m0_linux_stob_type,
+                                       "./__be",
+                                       &stob_dom);
+        M0_ASSERT(result == 0);
+
+        result = m0_linux_stob_setup(stob_dom, stob_directio);
+        M0_ASSERT(result == 0);
+
+        result = m0_stob_find(stob_dom, &stob_id, &seg->bs_stob);
+        M0_ASSERT(result == 0);
+        M0_ASSERT(seg->bs_stob->so_state == CSS_UNKNOWN);
+        result = m0_stob_create(seg->bs_stob, NULL);
+
+        if (result < 0)
+                goto error;
+
+        lstob = stob2linux(seg->bs_stob);
+
+        M0_ASSERT(lstob != NULL);
+
+        /* Get fle-path for segment stob */
+        /* @note - can not use linux_stob_path as it is declared as static in
+         *  linux.[hc] */
+
+        ldom = domain2linux(seg->bs_stob->so_domain);
+        nbytes = snprintf(seg->bs_impl.path_name,
+                          ARRAY_SIZE(seg->bs_impl.path_name),
+                          "%s/o/%016lx.%016lx",
+                          ldom->sdl_path,
+                          seg->bs_stob->so_id.si_bits.u_hi,
+                          seg->bs_stob->so_id.si_bits.u_lo);
+
+        if (nbytes < 0)
+                goto error;
+
+        /* @todo - need to handle rvm errors in callback */
+        /* create heap structure */
+        /* result = rds_zap_heap(DevName, DevLength, startAddr, staticLength,
+         *                       heapLength, nlists, chunkSize, err); */
+
+        rds_static_len    = RVM_ROUND_LENGTH_DOWN_TO_PAGE_SIZE(4096);
+
+        result = rds_zap_heap(seg->bs_impl.path_name,
+                              RVM_LENGTH_TO_OFFSET(dev_length),
+                              start_Addr,
+                              rds_static_len,
+                              heap_length,
+                              nlist,
+                              chunk_size,
+                              &err);
+
+        if (result < 0)
+                goto error;
+
+        /* @todo - begin transaction */
+        /* update the named segment transactionally */
+        /* @todo - end transaction */
+        /* Assuption : create implicitely opens the segment */
+
+        result = rds_load_heap(seg->bs_impl.path_name,
+                               RVM_LENGTH_TO_OFFSET(dev_length),
+                               &static_addr,
+                               &err);
+
+        if (result < 0)
+                goto error;
+
+        seg->bs_static_addr = (void *)(static_addr);
+
+        seg->bs_addr = (void *)m0_be_rvm_get_heapaddr();
+
+        m0_sm_state_set((&seg->bs_sm), M0_BESEG_ACTIVE);
+
+        return;
+
+error:
+        m0_sm_state_set((&seg->bs_sm), M0_BESEG_FAILED);
+}
+
+/**
+ * The function calls rvm api's to open the segment.
+ *
+ */
+
+M0_INTERNAL void m0_be_seg_open_cb(struct m0_sm_group *sm_group,
+                                   struct m0_sm_ast *sm_ast)
+{
+        int                      nbytes;
+        int                      result;
+
+        struct linux_stob       *lstob;
+        struct linux_domain     *ldom;
+        struct m0_be_seg        *seg;
+
+        M0_ASSERT(sm_group != NULL);
+        M0_ASSERT(sm_ast != NULL);
+
+        seg = (struct m0_be_seg *)sm_ast->sa_datum;
+
+        if (seg->bs_stob->so_state == CSS_UNKNOWN)
+                goto error;
+
+        lstob = stob2linux(seg->bs_stob);
+
+        M0_ASSERT(lstob != NULL);
+
+        /* Get fle-path for segment stob */
+        /* @note - can not use linux_stob_path as its declared as static */
+        ldom = domain2linux(seg->bs_stob->so_domain);
+        nbytes = snprintf(seg->bs_impl.path_name,
+                          ARRAY_SIZE(seg->bs_impl.path_name),
+                          "%s/o/%016lx.%016lx",
+                          ldom->sdl_path,
+                          seg->bs_stob->so_id.si_bits.u_hi,
+                          seg->bs_stob->so_id.si_bits.u_lo);
+
+        if (nbytes < 0)
+                goto error;
+
+        /* @todo - need to handle rvm errors in callback */
+        /* load heap */
+        /* rds_load_heap(*DevName, DevLength, **staticAddr, *err); */
+
+        unsigned long dev_length = RVM_SEGMENT_SIZE;
+        int  err;
+        char *static_addr = NULL;
+
+        result = rds_load_heap(seg->bs_impl.path_name,
+                               RVM_LENGTH_TO_OFFSET(dev_length),
+                               &static_addr,
+                               &err);
+
+        if (result < 0)
+                goto error;
+
+        seg->bs_static_addr = (void *)(static_addr);
+
+        seg->bs_addr = (void *)m0_be_rvm_get_heapaddr();
+
+        m0_sm_state_set((&seg->bs_sm), M0_BESEG_ACTIVE);
+
+        return;
+
+error:
+        m0_sm_state_set((&seg->bs_sm), M0_BESEG_FAILED);
+
+        return;
+}
+
+uint32_t m0_be_seg_state_get(const struct m0_be_seg *seg)
+{
+        return seg->bs_sm.sm_state;
+}
+
+/** @} end group be_seg */
+
+/*
+ *  Local variables:
+ *  c-indentation-style: "K&R"
+ *  c-basic-offset: 8
+ *  tab-width: 8
+ *  fill-column: 80
+ *  scroll-step: 1
+ *  End:
+ */
diff --git a/be/seg.h b/be/seg.h
new file mode 100644
index 0000000..076df25
--- /dev/null
+++ b/be/seg.h
@@ -0,0 +1,76 @@
+/*
+ * COPYRIGHT 2012 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: Sachin Patil <sachin_patil@xyratex.com>
+ * Original creation date: 26 Nov 2012
+ */
+
+#pragma once
+
+#ifndef __MERO_BE_BE_SEG_H__
+#define __MERO_BE_BE_SEG_H__
+
+/**
+  @defgroup be (Meta-data) back-end
+  @{
+*/
+
+#include "be/be.h"
+
+M0_INTERNAL void m0_seg_req_post(struct m0_sm_group *sm_grp,
+                                 struct m0_sm_ast *sm_ast);
+
+/**
+ * Callback function to create segment.
+ */
+M0_INTERNAL void m0_be_seg_create_cb(struct m0_sm_group *sm_group,
+                                     struct m0_sm_ast *sm_ast);
+/**
+ * Callback function to open segment.
+ */
+M0_INTERNAL void m0_be_seg_open_cb(struct m0_sm_group *sm_group,
+                                   struct m0_sm_ast *sm_ast);
+
+/**
+ * This function returns state machine for the segment.
+ */
+M0_INTERNAL uint32_t m0_be_seg_state_get(const struct m0_be_seg *seg);
+
+/**
+ * These params will be used to call rvm API's from segment layer.
+ */
+enum BE_RVM_PARAMS {
+        RVM_HEAP_SIZE     = 100 * 1024 * 1024,
+        /** RVM_PAGE_SIZE was conflicting with RVM variable declarations. */
+        RVM_PG_SIZE       = 1024 * 4,
+        RVM_SEGMENT_SIZE  = RVM_PG_SIZE + RVM_HEAP_SIZE + RVM_PG_SIZE,
+        RVM_NLIST         = 16,
+        RVM_CHUNK_SIZE    = 64,
+};
+
+/** @} end of be group */
+
+/* __MERO_BE_BE_SEG_H__ */
+#endif
+
+/*
+ *  Local variables:
+ *  c-indentation-style: "K&R"
+ *  c-basic-offset: 8
+ *  tab-width: 8
+ *  fill-column: 80
+ *  scroll-step: 1
+ *  End:
+ */
diff --git a/be/tx.c b/be/tx.c
new file mode 100644
index 0000000..7e301bf
--- /dev/null
+++ b/be/tx.c
@@ -0,0 +1,516 @@
+/*
+ * COPYRIGHT 2012 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: Prashant Dhange <prashant_dhange@xyratex.com>
+ * Original creation date: 03 Dec 2012
+ */
+
+#include "be/be.h"
+#include "be/be_private.h"
+#include "be/tx.h"
+#include "be/reg.h"
+#include "be/domain.h"
+
+/* State machine variable declarations  */
+static const struct m0_sm_state_descr tx_states[] = {
+         [M0_BETX_INITIALIZING] = {
+                .sd_flags     = M0_SDF_INITIAL,
+                .sd_name      = "Initializing",
+                .sd_allowed   = M0_BITS(M0_BETX_INIT,
+                                        M0_BETX_FAILED)
+        },
+        [M0_BETX_INIT] = {
+                .sd_flags     = 0,
+                .sd_name      = "Initialize",
+                .sd_allowed   = M0_BITS(M0_BETX_PREPARING,
+                                        M0_BETX_OPEN,
+                                        M0_BETX_FAILED)
+        },
+        [M0_BETX_PREPARING] = {
+                .sd_flags     = 0,
+                .sd_name      = "Preparing",
+                .sd_allowed   = M0_BITS(M0_BETX_PREPARED,
+                                        M0_BETX_PREPARING,
+                                        M0_BETX_OPEN,
+                                        M0_BETX_FAILED)
+        },
+        [M0_BETX_PREPARED] = {
+                .sd_flags     = 0,
+                .sd_name      = "Prepared",
+                .sd_allowed   = M0_BITS(M0_BETX_PREPARED,
+                                        M0_BETX_OPEN,
+                                        M0_BETX_FAILED)
+        },
+        [M0_BETX_OPEN] = {
+                .sd_flags     = 0,
+                .sd_name      = "Open",
+                .sd_allowed   = M0_BITS(M0_BETX_DONE,
+                                        M0_BETX_COMMITTED,
+                                        M0_BETX_FAILED)
+        },
+        [M0_BETX_DONE] = {
+                .sd_flags     = 0,
+                .sd_name      = "Done",
+                .sd_allowed   = M0_BITS(M0_BETX_CLOSED,
+                                        M0_BETX_COMMITTED,
+                                        M0_BETX_PREPARING,
+                                        M0_BETX_FAILED)
+        },
+        [M0_BETX_CLOSED] = {
+                .sd_flags     = M0_SDF_TERMINAL,
+                .sd_name      = "Closed",
+                .sd_allowed   = 0
+        },
+        [M0_BETX_COMMITTED] = {
+                .sd_flags     = 0,
+                .sd_name      = "Committed",
+                .sd_allowed   = M0_BITS(M0_BETX_CLOSED,
+                                        M0_BETX_FAILED)
+        },
+        [M0_BETX_FAILED] = {
+                .sd_flags     = M0_SDF_FAILURE,
+                .sd_name      = "Failed",
+                .sd_allowed   = M0_BITS(M0_BETX_FAILED)
+        },
+};
+
+static const struct m0_sm_conf tx_conf = {
+        .scf_name      = "Tx States",
+        .scf_nr_states = ARRAY_SIZE(tx_states),
+        .scf_state     = tx_states
+};
+
+/**
+ * Initialises the transaction structure.
+ *
+ * @pre m0_be_seg_state_get(dom->bd_data) == M0_BESEG_ACTIVE
+ * @post m0_be_tx_state_get(tx) == M0_BETX_PREPARING
+ * @post tx->bt_dom == dom
+ */
+M0_INTERNAL void m0_be_tx_init(struct m0_be_tx *tx,
+                               struct m0_be_domain *dom, uint64_t flags)
+{
+        /* Asserting on required pointers */
+        M0_ASSERT(tx != NULL);
+        M0_ASSERT(dom != NULL);
+        M0_ASSERT(&dom->bd_impl.sm_group != NULL);
+
+        /* Initialise domain structure with required values */
+        tx->bt_dom = dom;
+
+        /* Initialize bt_impl->bc_tl list */
+        m0_be_reg_tlist_init(&tx->bt_impl.bc_tl);
+
+        /*
+         * Locking sm_group is required before initializing sm
+         * TODO@ Need to confirm with Nikita, do we need to move the state
+         * transition logic to CALLBACKS. This Applies for state change
+         * accross the segments, regions, transactions
+         */
+        m0_sm_group_lock(m0_be_domain_sm_group(tx->bt_dom));
+
+        /* Register the state machine of the tx into sm_group */
+        m0_sm_init(&tx->bt_sm, &tx_conf, M0_BETX_INITIALIZING,
+                   m0_be_domain_sm_group(tx->bt_dom), NULL);
+
+        /* unlock locked sm group */
+        m0_sm_group_unlock(m0_be_domain_sm_group(tx->bt_dom));
+
+        tx->bt_sm_ast.sa_cb    = m0_be_tx_init_cb;
+        tx->bt_sm_ast.sa_datum = (void *)tx;
+
+        m0_tx_req_post(m0_be_domain_sm_group(tx->bt_dom), &tx->bt_sm_ast);
+}
+
+/**
+ * Indicates that a transaction will use certain amount of resources.
+ *
+ * @pre m0_be_tx_state_get(tx) == M0_BETX_INIT
+ *
+ */
+M0_INTERNAL void m0_be_tx_prep(struct m0_be_tx *tx)
+{
+        struct m0_be_reg *reg_it;
+
+        /* Asserting on required pointers */
+        M0_ASSERT(tx != NULL);
+
+        /* Is m0_be_tx_state_get(tx) in M0_BETX_INIT state */
+        M0_PRE(m0_be_tx_state_get(tx) == M0_BETX_INIT);
+
+        /* Iterate credit list of regions */
+        m0_tlist_for(&m0_be_reg_tl, &tx->bt_impl.bc_tl, reg_it) {
+
+                /* check reg_it->br_sm.sm_state for region state */
+
+                if (!M0_IN(m0_be_reg_state_get(reg_it), (M0_BEREG_INIT, 
+                                                         M0_BEREG_ALLOCATED))) {
+
+                        m0_be_sm_state_change(m0_be_domain_sm_group(tx->bt_dom),
+                                              &tx->bt_sm, M0_BETX_FAILED);
+                        /* TODO@ add error log message */
+                        goto exit_error;
+                }
+
+        } m0_tlist_endfor;
+
+        m0_be_sm_state_change(m0_be_domain_sm_group(tx->bt_dom),
+                              &tx->bt_sm, M0_BETX_PREPARING);
+
+        tx->bt_sm_ast.sa_cb    = m0_be_tx_prep_cb;
+        tx->bt_sm_ast.sa_datum = (void *)tx;
+
+        m0_tx_req_post(m0_be_domain_sm_group(tx->bt_dom), &tx->bt_sm_ast);
+        goto exit;
+
+exit_error:
+        rvm_abort_transaction(tx->bt_impl.tx_id);
+        rvm_free_tid(tx->bt_impl.tx_id);
+exit:
+        return;
+}
+
+/**
+ * Starts a prepared transaction.
+ *
+ * @pre m0_be_tx_state_get(tx) == M0_BETX_PREPARING
+ * @post M0_IN(m0_be_tx_state_get(tx), (M0_BETX_PREPARED, M0_BETX_OPEN,
+ *                                      M0_BETX_FAILED))
+ */
+M0_INTERNAL void m0_be_tx_start(struct m0_be_tx *tx)
+{
+
+        M0_ASSERT(tx != NULL);
+
+        /*
+         * Added M0_IN support to call start when theres nothing in
+         * credit list i.e. without calling tx_prep
+         */
+        M0_IN(m0_be_tx_state_get(tx), (M0_BETX_PREPARED, M0_BETX_PREPARING));
+
+        tx->bt_sm_ast.sa_cb    = m0_be_tx_start_cb;
+        tx->bt_sm_ast.sa_datum = (void *)tx;
+
+        m0_tx_req_post(m0_be_domain_sm_group(tx->bt_dom), &tx->bt_sm_ast);
+}
+
+/**
+ * Closes a transaction.
+ *
+ * @pre m0_be_tx_state_get(tx) == M0_BETX_OPEN
+ * @post M0_IN(m0_be_tx_state_get(tx), (M0_BETX_CLOSED, M0_BETX_COMMITTED,
+ *                                      M0_BETX_DONE, M0_BETX_FAILED))
+ */
+M0_INTERNAL void m0_be_tx_done(struct m0_be_tx *tx)
+{
+        /* Asserting on required pointers */
+        M0_ASSERT(tx != NULL);
+
+        M0_PRE(m0_be_tx_state_get(tx) == M0_BETX_OPEN);
+
+        tx->bt_sm_ast.sa_cb    = m0_be_tx_done_cb;
+        tx->bt_sm_ast.sa_datum = (void *)tx;
+
+        m0_tx_req_post(m0_be_domain_sm_group(tx->bt_dom), &tx->bt_sm_ast);
+}
+
+/**
+ * Finalises transaction structure.
+ *
+ * @pre M0_IN(m0_be_tx_state_get(tx), (M0_BETX_DONE, M0_BETX_FAILED))
+ */
+M0_INTERNAL void m0_be_tx_fini(struct m0_be_tx *tx)
+{
+        struct m0_be_reg *reg_it;
+
+        /* Asserting on required pointers */
+        M0_ASSERT(tx != NULL);
+
+        M0_PRE(M0_IN(m0_be_tx_state_get(tx), (M0_BETX_DONE, M0_BETX_FAILED)));
+
+        rvm_free_tid(tx->bt_impl.tx_id);
+
+         /* Removing entries from reg list if present */
+         /* Iterate credit list of regions */
+         m0_tlist_for(&m0_be_reg_tl, &tx->bt_impl.bc_tl, reg_it) {
+                if (m0_be_reg_tlink_is_in(reg_it)) {
+                         m0_be_reg_tlink_del_fini(reg_it);
+
+                         m0_be_reg_fini(reg_it);
+                }
+         } m0_tlist_endfor;
+
+        /* Finalise bt_impl->bc_tl list */
+        m0_be_reg_tlist_fini(&tx->bt_impl.bc_tl);
+
+        m0_be_sm_state_change(m0_be_domain_sm_group(tx->bt_dom),
+                              &tx->bt_sm, M0_BETX_CLOSED);
+
+        /* Remove entry from in memory active transaction list if present */
+        if (m0_be_tx_tlink_is_in(tx))
+                m0_be_tx_tlink_del_fini(tx);
+
+        /* Finalizing on state machine */
+        m0_sm_fini(&tx->bt_sm);
+}
+
+/*
+ *    m0_be_tx_init callback function
+ */
+M0_INTERNAL void m0_be_tx_init_cb(struct m0_sm_group *sm_group,
+                                  struct m0_sm_ast *sm_ast)
+{
+        struct m0_be_tx         *tx;
+        rvm_return_t             ret;
+        rvm_tid_t               *tid;
+
+        /* Asserting on required pointers */
+        M0_ASSERT(sm_group != NULL);
+        M0_ASSERT(sm_ast != NULL);
+
+        tx = (struct m0_be_tx *) sm_ast->sa_datum;
+        M0_ASSERT(tx != NULL);
+
+        tid = rvm_malloc_tid();
+
+        if (tid == NULL) {
+                /* TODO@ add error log message */
+                goto exit_alloc;
+        }
+
+        tx->bt_impl.tx_id = tid;
+
+        ret = rvm_begin_transaction(tx->bt_impl.tx_id, restore);
+
+        if (RVM_SUCCESS != ret) {
+                /* TODO@ add error log message */
+                goto exit_begin_tx;
+        }
+        m0_sm_state_set(&tx->bt_sm, M0_BETX_INIT);
+        goto exit;
+
+exit_begin_tx:
+        rvm_free_tid(tid);
+exit_alloc:
+        m0_sm_state_set(&tx->bt_sm, M0_BETX_FAILED);
+exit:
+        return;
+}
+
+/*
+ * m0_be_tx_prep callback function
+ */
+M0_INTERNAL void m0_be_tx_prep_cb(struct m0_sm_group *sm_group,
+                                  struct m0_sm_ast *sm_ast)
+{
+        struct m0_be_tx         *tx;
+        struct m0_be_reg        *reg_it;
+
+        /* Asserting on required pointers */
+        M0_ASSERT(sm_group != NULL);
+        M0_ASSERT(sm_ast != NULL);
+
+        tx = (struct m0_be_tx *) sm_ast->sa_datum;
+
+        M0_ASSERT(tx != NULL);
+
+        /* Iterate credit list of regions */
+        m0_tlist_for(&m0_be_reg_tl, &tx->bt_impl.bc_tl, reg_it) {
+                /* Assumption: reg_it->br_tx will be updated to tx */
+                reg_it->br_tx = tx;
+                reg_it->br_tx_cbdata.datum = (void *)tx;
+
+                /*
+                * Capture region function which changes
+                * the region state to InProgress
+                */
+                m0_be_reg_capture(reg_it);
+
+        } m0_tlist_endfor;
+
+        return;
+}
+
+/*
+ *    m0_be_tx_start callback function
+ */
+M0_INTERNAL void m0_be_tx_start_cb(struct m0_sm_group *sm_group,
+                                   struct m0_sm_ast *sm_ast)
+{
+        struct m0_be_tx         *tx;
+
+        /* Asserting on required pointers */
+        M0_ASSERT(sm_group != NULL);
+        M0_ASSERT(sm_ast != NULL);
+
+        tx = (struct m0_be_tx *) sm_ast->sa_datum;
+
+        /* Add this transaction to domain's active transaction list */
+        m0_be_tx_tlink_init(tx);
+
+        m0_be_tx_tlist_add(&tx->bt_dom->bd_tx, tx);
+
+        m0_sm_state_set(&tx->bt_sm, M0_BETX_OPEN);
+}
+
+/*
+ *    m0_be_tx_done callback function
+ */
+M0_INTERNAL void m0_be_tx_done_cb(struct m0_sm_group *sm_group,
+                                  struct m0_sm_ast *sm_ast)
+{
+        struct m0_be_tx         *tx;
+        struct m0_be_reg        *reg_it;
+        rvm_return_t ret;
+
+        /* Asserting on required pointers */
+        M0_ASSERT(sm_group != NULL);
+        M0_ASSERT(sm_ast != NULL);
+
+        tx = (struct m0_be_tx *) sm_ast->sa_datum;
+
+        ret = rvm_end_transaction(tx->bt_impl.tx_id, flush);
+
+        if (RVM_SUCCESS != ret) {
+                /* TODO@ add error log message */
+                goto exit_end_tx;
+        }
+
+        /* Iterate credit list of regions */
+        m0_tlist_for(&m0_be_reg_tl, &tx->bt_impl.bc_tl, reg_it) {
+                /* Mark all regions for completion */
+                /* TODO@ need to call function m0_sm_state_set() */
+                m0_sm_state_set(&reg_it->br_sm, M0_BEREG_DONE);
+        } m0_tlist_endfor;
+
+        m0_sm_state_set(&tx->bt_sm, M0_BETX_DONE);
+        goto exit;
+
+exit_end_tx:
+        rvm_free_tid(tx->bt_impl.tx_id);
+        m0_sm_state_set(&tx->bt_sm, M0_BETX_FAILED);
+exit:
+        return;
+}
+
+M0_INTERNAL void m0_be_tx_add_cred(struct m0_be_tx *tx,
+                                   struct m0_be_reg *reg)
+{
+        /* Asserting on required pointers */
+        M0_ASSERT(tx != NULL);
+        M0_ASSERT(reg != NULL);
+
+        /* Add reg to credit list, default would be add to tail */
+        m0_be_reg_tlink_init(reg);
+
+        m0_be_reg_tlist_add_tail(&tx->bt_impl.bc_tl, reg);
+}
+
+/**
+ * The function posts tx request to state machine thread
+ *
+ */
+M0_INTERNAL void m0_tx_req_post(struct m0_sm_group *sm_group,
+                                struct m0_sm_ast *sm_ast)
+{
+        m0_sm_ast_post(sm_group, sm_ast);
+}
+
+/**
+ * The function iterates the region list to check if any region capture has
+ * failed.
+ * If any earlier capture is failed, then the current region won't be captured.
+ */
+M0_INTERNAL int m0_be_tx_get_capture_status(void * data)
+{
+        struct m0_be_tx *tx = (struct m0_be_tx *)data;
+        struct m0_be_reg *reg_it;
+
+        int result = M0_BETX_PREP_INPROGRESS;
+
+        /* Iterate credit list to check the capture status for each region. */
+        m0_tlist_for(&m0_be_reg_tl, &tx->bt_impl.bc_tl, reg_it) {
+                /* check reg_it->br_sm.sm_state for region state */
+
+                if (m0_be_reg_state_get(reg_it) == M0_BEREG_FAILED) {
+                        result = M0_BETX_PREP_FAILED;
+                        break;
+                }
+
+        } m0_tlist_endfor;
+
+        return result;
+}
+
+/**
+ * The function iterates all the region list to check if they are captured
+ * successfully.
+ * This is pre-requisite for transaction to be marked as PREPARED.
+ */
+M0_INTERNAL void m0_be_tx_set_capture_status(void * data)
+{
+        struct m0_be_tx *tx = (struct m0_be_tx *)data;
+        struct m0_be_reg *reg_it;
+
+        bool failed_res = false;
+        bool capturing_res = false;
+
+        /* Iterate credit list to check the capture status for each region. */
+        m0_tlist_for(&m0_be_reg_tl, &tx->bt_impl.bc_tl, reg_it) {
+                /* check if region capture is in prorgess */
+                if (m0_be_reg_state_get(reg_it) == M0_BEREG_CAPTURING) {
+                        capturing_res = true;
+                        break;
+                }
+
+                /* check if region capture is failed */
+                if (m0_be_reg_state_get(reg_it) == M0_BEREG_FAILED) {
+                        failed_res = true;
+                }
+
+        } m0_tlist_endfor;
+
+        if(!capturing_res) {
+                /**
+                 * This function will be called from callback function, so
+                 * sm_group lock is not required while setting tx state.
+                 */
+                if(failed_res) {
+                        m0_sm_state_set(&tx->bt_sm, M0_BETX_FAILED);
+                }
+                else {
+                        m0_sm_state_set(&tx->bt_sm, M0_BETX_PREPARED);
+                }
+        }
+
+        return;
+}
+
+uint32_t m0_be_tx_state_get(const struct m0_be_tx *tx)
+{
+        return tx->bt_sm.sm_state;
+}
+
+/** @} end group be_trans */
+
+/*
+ *  Local variables:
+ *  c-indentation-style: "K&R"
+ *  c-basic-offset: 8
+ *  tab-width: 8
+ *  fill-column: 80
+ *  scroll-step: 1
+ *  End:
+ */
diff --git a/be/tx.h b/be/tx.h
new file mode 100644
index 0000000..12ec28d
--- /dev/null
+++ b/be/tx.h
@@ -0,0 +1,72 @@
+/*
+ * COPYRIGHT 2012 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: Prashant Dhange <prashant_dhange@xyratex.com>
+ * Original creation date: 10 Dec 2012
+ */
+
+#pragma once
+
+#ifndef __MERO_BE_BE_TX_H__
+#define __MERO_BE_BE_TX_H__
+
+/**
+  @defgroup be (Meta-data) back-end
+  @{
+  */
+#include "be/be.h"
+
+enum m0_be_tx_prep_state {
+        M0_BETX_PREP_INPROGRESS,
+        M0_BETX_PREP_SUCCEED,
+        M0_BETX_PREP_FAILED,
+};
+
+M0_INTERNAL void m0_be_tx_add_cred(struct m0_be_tx *tx,
+                                   struct m0_be_reg *reg);
+
+M0_INTERNAL void m0_be_tx_init_cb(struct m0_sm_group *sm_group,
+                                  struct m0_sm_ast *sm_ast);
+M0_INTERNAL void m0_be_tx_prep_cb(struct m0_sm_group *sm_group,
+                                  struct m0_sm_ast *sm_ast);
+M0_INTERNAL void m0_be_tx_start_cb(struct m0_sm_group *sm_group,
+                                   struct m0_sm_ast *sm_ast);
+M0_INTERNAL void m0_be_tx_done_cb(struct m0_sm_group *sm_group,
+                                  struct m0_sm_ast *sm_ast);
+M0_INTERNAL void m0_be_tx_fini_cb(struct m0_sm_group *sm_group,
+                                  struct m0_sm_ast *sm_ast);
+
+M0_INTERNAL void m0_tx_req_post(struct m0_sm_group *sm_group,
+                                struct m0_sm_ast *sm_ast);
+
+M0_INTERNAL int m0_be_tx_get_capture_status(void * data);
+
+M0_INTERNAL void m0_be_tx_set_capture_status(void * data);
+
+uint32_t m0_be_tx_state_get(const struct m0_be_tx *tx);
+/** @} end of be group */
+
+/* __MERO_BE_BE_TX_H__ */
+#endif
+
+/*
+ *  Local variables:
+ *  c-indentation-style: "K&R"
+ *  c-basic-offset: 8
+ *  tab-width: 8
+ *  fill-column: 80
+ *  scroll-step: 1
+ *  End:
+ */
diff --git a/be/ut/Makefile b/be/ut/Makefile
index 600e5ed..1b45755 100644
--- a/be/ut/Makefile
+++ b/be/ut/Makefile
@@ -1,10 +1,10 @@
 .PHONY:all
 
 all:
-	gcc .libs/ut_libmero_ut_la-be.o  ../../mero/.libs/libmero.a  -o ./be_ut  -lpthread  -ldb  -lrt -laio -lrvm -lrds -lseg -L../../../rvm/rvm/.libs -L../../../rvm/rds/.libs -L../../../rvm/seg/.libs
-	gcc .libs/ut_libmero_ut_la-be_handle_store.o  ../../mero/.libs/libmero.a -o ./be_handle_store -lpthread -ldb -lrt -laio -lrvm -lrds -lseg -L../../../rvm/rvm/.libs -L../../../rvm/rds/.libs -L../../../rvm/seg/.libs
+	gcc .libs/ut_libmero_ut_la-be.o  ../../mero/.libs/libmero.a  -o ./be  -lpthread  -ldb  -lrt -laio -lrvm -lrds -lseg -L../../../rvm/rvm/.libs -L../../../rvm/rds/.libs -L../../../rvm/seg/.libs
+	#gcc .libs/ut_libmero_ut_la-handle_store.o  ../../mero/.libs/libmero.a -o ./handle_store -lpthread -ldb -lrt -laio -lrvm -lrds -lseg -L../../../rvm/rvm/.libs -L../../../rvm/rds/.libs -L../../../rvm/seg/.libs
 	rm -rf /tmp/log_file
 
 clean:
-	rm -rf ./be_ut
-	rm -rf ./be_handle_store
+	rm -rf ./be
+	rm -rf ./handle_store
diff --git a/be/ut/Makefile.sub b/be/ut/Makefile.sub
index 2c137b2..6c4175e 100644
--- a/be/ut/Makefile.sub
+++ b/be/ut/Makefile.sub
@@ -1,2 +1,2 @@
 ut_libmero_ut_la_SOURCES += be/ut/be.c \
-			    be/ut/be_handle_store.c
+			    be/ut/handle_store.c
diff --git a/be/ut/be.c b/be/ut/be.c
index e235cd8..0d1316c 100644
--- a/be/ut/be.c
+++ b/be/ut/be.c
@@ -31,126 +31,147 @@
 
 #include <stdio.h>
 #include <unistd.h>
+
 #include "be/be.h"
+#include "be/domain.h"
+#include "be/tx.h"
+
+#include "mero/magic.h"
+#include "sm/sm.h"
 
-struct m0_be_seg *seg;
+struct m0_be_seg seg;
 struct m0_be_domain dom;
+struct m0_be_reg reg;
+struct m0_be_tx tx;
 
 int main()
 {
         /** Be Domain Transaction */
-        struct m0_be_tx tx;
-        struct m0_be_reg *reg;
+        struct m0_sm_group *sm_group;
         struct m0_be_buf buf;
+        int result;
 
         /* Initializing domain */
         printf("\n\tBackend UT\n");
-        m0_be_domain_init(&dom, BE_DOMAIN_MAGIC);
+        m0_be_domain_init(&dom, NULL, NULL, M0_BE_DOMAIN_MAGIC);
         printf("\nDomain is initialized\n");
 
         /**
          * This is just done to work other part of the code.
          * We are not dealing with named segment for this moment.
          */
-        dom.bd_data.bs_sm.sm_state = M0_BESEG_ACTIVE;
+        sm_group = m0_be_domain_sm_group(&dom);
+
+        M0_ASSERT(sm_group != NULL);
+
+        m0_sm_group_lock(sm_group);
+        m0_sm_state_set(&dom.bd_data.bs_sm, M0_BESEG_ACTIVE);
+        m0_sm_group_unlock(sm_group);
 
-        m0_be_domain_lookup(&dom, 1, &seg);
+        result = m0_be_domain_lookup(&dom, "first", &seg);
+        printf("\nDomain Lookup Result : %d\n", result);
 
-        m0_sm_group_lock(seg->bs_impl.sm_group);
-        m0_sm_timedwait(&(seg->bs_sm),
+        if(result != 0) {
+                printf("\nCreating Segment\n");
+                m0_be_seg_init(&seg, &dom, sm_group, 0);
+                m0_be_seg_create(&seg, NULL,  "first", NULL);
+
+        }
+        m0_sm_group_lock(sm_group);
+        m0_sm_timedwait(&seg.bs_sm,
                         (1 << M0_BESEG_ACTIVE) | (1 << M0_BESEG_FAILED),
                         M0_TIME_NEVER);
-        m0_sm_group_unlock(seg->bs_impl.sm_group);
-
+        m0_sm_group_unlock(sm_group);
 
-        if (M0_BESEG_FAILED == seg->bs_sm.sm_state) {
+        if (M0_BESEG_FAILED == seg.bs_sm.sm_state) {
                 printf("\nFailed to create segment \n");
                 return -1;
         }
 
         printf("\nSegment is created and opened\n");
 
-        printf("\ndata_file_path : %s\n", seg->bs_impl.path_name);
+        printf("\ndata_file_path : %s\n", seg.bs_impl.path_name);
 
         /* Transaction list initialization */
         m0_be_tx_init(&tx, &dom, 0);
 
-        m0_sm_group_lock(tx.bt_impl.sm_group);
+        m0_sm_group_lock(sm_group);
         m0_sm_timedwait(&tx.bt_sm,
                         (1 << M0_BETX_INIT) | (1 << M0_BETX_FAILED),
                         M0_TIME_NEVER);
-        m0_sm_group_unlock(tx.bt_impl.sm_group);
+        m0_sm_group_unlock(sm_group);
         printf("\nTx is initiated\n");
 
 
-        m0_be_buf_init(&buf, NULL, 1024, 0, 0, 0);
-        m0_be_reg_init(&reg, NULL, seg, &buf);
-        printf("reg : %p reg_state[%d]\n", reg, reg->br_sm.sm_state);
-        m0_be_alloc(reg);
+        /*m0_be_buf_init(&buf, NULL, 1024, 0, 0, 0); */
+        buf.b_nob = 1024;
+        m0_be_reg_init(&reg, NULL, &seg, &buf);
+        printf("reg_state[%d]\n", reg.br_sm.sm_state);
+        m0_be_alloc(&reg);
 
         printf("\nReg is allocating\n");
-        m0_sm_group_lock(reg->br_impl.sm_group);
-        m0_sm_timedwait(&(reg->br_sm),
+        m0_sm_group_lock(sm_group);
+        m0_sm_timedwait(&reg.br_sm,
                         (1 << M0_BEREG_ALLOCATED) | (1 << M0_BEREG_FAILED),
                          M0_TIME_NEVER);
 
-        m0_sm_group_unlock(reg->br_impl.sm_group);
+        m0_sm_group_unlock(sm_group);
         printf("\nReg is allocated\n");
 
         printf("\nsegment_id : %ld segment_offset : %ld\n",
-                        reg->br_buf.logical_address.segid_offset.u_hi,
-                        reg->br_buf.logical_address.segid_offset.u_lo);
+                        reg.br_buf.logical_address.segid_offset.u_hi,
+                        reg.br_buf.logical_address.segid_offset.u_lo);
 
 
-        m0_be_tx_add_cred(&tx, reg);
+        m0_be_tx_add_cred(&tx, &reg);
 
-        printf("reg : %p reg_state[%d]\n", reg, reg->br_sm.sm_state);
+        printf("reg_state[%d]\n", reg.br_sm.sm_state);
         m0_be_tx_prep(&tx);
 
         printf("\nTx is Preparing\n");
-        m0_sm_group_lock(tx.bt_impl.sm_group);
+        m0_sm_group_lock(sm_group);
         m0_sm_timedwait(&tx.bt_sm,
                         (1 << M0_BETX_PREPARED) | (1 << M0_BETX_FAILED),
                         M0_TIME_NEVER);
-        m0_sm_group_unlock(tx.bt_impl.sm_group);
+        m0_sm_group_unlock(sm_group);
         printf("\nTx is Prepared\n");
 
         printf("\nTx is Opening\n");
         m0_be_tx_start(&tx);
-        m0_sm_group_lock(tx.bt_impl.sm_group);
+        m0_sm_group_lock(sm_group);
         m0_sm_timedwait(&tx.bt_sm,
                         (1 << M0_BETX_OPEN) | (1 << M0_BETX_FAILED),
                         M0_TIME_NEVER);
-        m0_sm_group_unlock(tx.bt_impl.sm_group);
+        m0_sm_group_unlock(sm_group);
         printf("\nTx Opened\n");
 
-        strcpy(reg->br_buf.logical_address.virtual_address, "VIRTUAL WORLD");
+        strcpy(reg.br_buf.logical_address.virtual_address, "VIRTUAL WORLD");
         printf("\ndata : [%s]\n",
-                        (char *)reg->br_buf.logical_address.virtual_address);
+                        (char *)reg.br_buf.logical_address.virtual_address);
 
         printf("\nsegment_id : %ld segment_offset : %ld\n",
-                        reg->br_buf.logical_address.segid_offset.u_hi,
-                        reg->br_buf.logical_address.segid_offset.u_lo);
+                        reg.br_buf.logical_address.segid_offset.u_hi,
+                        reg.br_buf.logical_address.segid_offset.u_lo);
 
         printf("\nvirtual_addr : %p\n",
-                        reg->br_buf.logical_address.virtual_address);
+                        reg.br_buf.logical_address.virtual_address);
 
-        strcpy(reg->br_buf.logical_address.virtual_address, "START --> END");
+        strcpy(reg.br_buf.logical_address.virtual_address, "START --> END");
         m0_be_tx_done(&tx);
-        m0_sm_group_lock(tx.bt_impl.sm_group);
+        m0_sm_group_lock(sm_group);
         m0_sm_timedwait(&tx.bt_sm,
                         (1 << M0_BETX_DONE) | (1 << M0_BETX_FAILED),
                         M0_TIME_NEVER);
-        m0_sm_group_unlock(tx.bt_impl.sm_group);
+        m0_sm_group_unlock(sm_group);
 
         printf("\ndata : [%s]\n",
-                        (char *)reg->br_buf.logical_address.virtual_address);
+                        (char *)reg.br_buf.logical_address.virtual_address);
 
         rvm_truncate();
 
         m0_be_tx_fini(&tx);
 
-        m0_be_seg_done(seg);
+        m0_be_seg_done(&seg);
         dom.bd_data.bs_sm.sm_state = M0_BESEG_CLOSED;
         m0_be_domain_fini(&dom);
 
diff --git a/be/ut/be_handle_store.c b/be/ut/be_handle_store.c
deleted file mode 100644
index dbf20bb..0000000
--- a/be/ut/be_handle_store.c
+++ /dev/null
@@ -1,129 +0,0 @@
-/*
- * COPYRIGHT 2012 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Prashant Dhange <prashant_dhange@xyratex.com>
- * Original creation date: 28 Dec 2012
- */
-
-/**
- *              Be Domain UT
- *
- * The UT does not create Named Segment and thus named segment related
- * function is not completed for time being
- */
-
-/**
-  @addtogroup be_ut
-  @{
-  */
-
-#include <stdio.h>
-#include <unistd.h>
-#include <stdlib.h>
-#include "be/be.h"
-#include "be/lib/be_handle_store.h"
-
-struct m0_be_seg *seg;
-struct m0_be_domain *dom;
-struct m0_stob ns_stob, stob;
-struct m0_stob log_stob;
-struct m0_be_tx tx;
-
-void __init()
-{
-        /* Initializing domain */
-        printf("\n\tBackend UT\n");
-        m0_be_domain_create(&dom);
-        m0_be_domain_init(dom, BE_DOMAIN_MAGIC);
-        printf("\nDomain is initialized\n");
-
-        /**
-         * This is just done to work other part of the code.
-         * We are not dealing with named segment for this moment.
-         */
-        dom->bd_data.bs_sm.sm_state = M0_BESEG_ACTIVE;
-
-        m0_be_domain_lookup(dom, 1, &seg);
-
-        m0_sm_group_lock(seg->bs_impl.sm_group);
-        m0_sm_timedwait(&(seg->bs_sm),
-                        (1 << M0_BESEG_ACTIVE) | (1 << M0_BESEG_FAILED),
-                        M0_TIME_NEVER);
-        m0_sm_group_unlock(seg->bs_impl.sm_group);
-
-
-        if (M0_BESEG_FAILED == seg->bs_sm.sm_state) {
-                printf("\nFailed to create segment \n");
-                return;
-        }
-        printf("\nSegment is opened\n");
-        printf("\nheap addr : %p\n", seg->bs_heap_addr);
-        printf("\nstatic addr : %p\n", seg->bs_static_addr);
-}
-
-void __fini()
-{
-        rvm_truncate();
-        rvm_flush();
-
-        m0_be_seg_done(seg);
-        dom->bd_data.bs_sm.sm_state = M0_BESEG_CLOSED;
-        m0_be_domain_fini(dom);
-
-        printf("\nExiting from Backend UT\n");
-
-        printf("\n");
-}
-
-int main(int argc, char *argv[])
-{
-        int i=0;
-        int run_mode = atoi(argv[1]);
-
-        __init();
-        m0_be_hs_init(seg);
-
-        if (!run_mode) {
-                for (i = 0; i < 10; i++) {
-                        struct m0_uint128 kvstore;
-                        kvstore.u_hi = 1 + i;
-                        kvstore.u_lo = 88779911231 + i;
-                        m0_be_hs_update(i, &kvstore);
-                }
-                for (i = 0; i < 10; i = i+2) {
-                        struct m0_uint128 *kvstore = m0_be_hs_get(i);
-                        printf("Address [%ld, %ld] \n", kvstore->u_hi, kvstore->u_lo);
-                }
-        } else {
-                for (i = 0; i < 10; i = i+2) {
-                        struct m0_uint128 *kvstore = m0_be_hs_get(i);
-                        printf("Address [%ld, %ld] \n", kvstore->u_hi, kvstore->u_lo);
-                }
-        }
-        __fini();
-        return 0;
-}
-
-/** @} end group be_ut */
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
diff --git a/be/ut/handle_store.c b/be/ut/handle_store.c
new file mode 100644
index 0000000..38a8e5d
--- /dev/null
+++ b/be/ut/handle_store.c
@@ -0,0 +1,138 @@
+/*
+ * COPYRIGHT 2012 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: Prashant Dhange <prashant_dhange@xyratex.com>
+ * Original creation date: 28 Dec 2012
+ */
+
+/**
+ *              Be Domain UT
+ *
+ * The UT does not create Named Segment and thus named segment related
+ * function is not completed for time being
+ */
+
+/**
+  @addtogroup be_ut
+  @{
+  */
+
+#include <stdio.h>
+#include <unistd.h>
+#include <stdlib.h>
+
+#include "be/be.h"
+#include "be/domain.h"
+#include "mero/magic.h"
+
+#include "be/lib/handle_store.h"
+
+struct m0_be_seg seg;
+struct m0_be_domain dom;
+struct m0_stob ns_stob, stob;
+struct m0_stob log_stob;
+struct m0_be_tx tx;
+
+void __init()
+{
+        struct m0_sm_group *sm_group;
+
+        /* Initializing domain */
+        printf("\n\tBackend UT\n");
+        m0_be_domain_init(&dom, NULL, NULL, M0_BE_DOMAIN_MAGIC);
+        printf("\nDomain is initialized\n");
+
+        sm_group = m0_be_domain_sm_group(&dom);
+
+        /**
+         * This is just done to work other part of the code.
+         * We are not dealing with named segment for this moment.
+         */
+        m0_sm_group_lock(sm_group);
+        m0_sm_state_set(&dom.bd_data.bs_sm, M0_BESEG_ACTIVE);
+        m0_sm_group_unlock(sm_group);
+
+        m0_be_domain_lookup(&dom, "first", &seg);
+
+        m0_sm_group_lock(sm_group);
+        m0_sm_timedwait(&(seg.bs_sm),
+                        (1 << M0_BESEG_ACTIVE) | (1 << M0_BESEG_FAILED),
+                        M0_TIME_NEVER);
+        m0_sm_group_unlock(sm_group);
+
+
+        if (M0_BESEG_FAILED == seg.bs_sm.sm_state) {
+                printf("\nFailed to create segment \n");
+                return;
+        }
+        printf("\nSegment is opened\n");
+        printf("\nheap addr : %p\n", seg.bs_addr);
+        printf("\nstatic addr : %p\n", seg.bs_static_addr);
+}
+
+void __fini()
+{
+        rvm_truncate();
+        rvm_flush();
+
+        m0_be_seg_done(&seg);
+        dom.bd_data.bs_sm.sm_state = M0_BESEG_CLOSED;
+        m0_be_domain_fini(&dom);
+
+        printf("\nExiting from Backend UT\n");
+
+        printf("\n");
+}
+
+int main(int argc, char *argv[])
+{
+        int i=0;
+        int run_mode = atoi(argv[1]);
+
+        __init();
+        m0_be_hs_init(&seg);
+
+        if (!run_mode) {
+                for (i = 0; i < 10; i++) {
+                        struct m0_uint128 kvstore;
+                        kvstore.u_hi = 1 + i;
+                        kvstore.u_lo = 88779911231 + i;
+                        m0_be_hs_update(i, &kvstore);
+                }
+                for (i = 0; i < 10; i = i+2) {
+                        struct m0_uint128 *kvstore = m0_be_hs_get(i);
+                        printf("Address [%ld, %ld] \n", kvstore->u_hi, kvstore->u_lo);
+                }
+        } else {
+                for (i = 0; i < 10; i = i+2) {
+                        struct m0_uint128 *kvstore = m0_be_hs_get(i);
+                        printf("Address [%ld, %ld] \n", kvstore->u_hi, kvstore->u_lo);
+                }
+        }
+        __fini();
+        return 0;
+}
+
+/** @} end group be_ut */
+
+/*
+ *  Local variables:
+ *  c-indentation-style: "K&R"
+ *  c-basic-offset: 8
+ *  tab-width: 8
+ *  fill-column: 80
+ *  scroll-step: 1
+ *  End:
+ */
diff --git a/mero/init.c b/mero/init.c
index 2ddd8de..0683005 100644
--- a/mero/init.c
+++ b/mero/init.c
@@ -63,6 +63,7 @@
 #include "mdservice/md_service.h"
 #include "sns/sns.h"
 #include "cm/cm.h"
+#include "be/be_init.h"
 
 M0_INTERNAL int m0_memory_init(void);
 M0_INTERNAL void m0_memory_fini(void);
@@ -128,6 +129,8 @@ struct init_fini_call subsystem[] = {
 	{ &m0_cm_module_init,   &m0_cm_module_fini,   "copy machine" },
 	{ &m0_sns_init,         &m0_sns_fini,         "sns" },
 #endif
+        /* RVM must be initialized before using backend domain. */
+	{ &m0_be_init,         &m0_be_fini,         "back-end domain" },
 };
 
 static void fini_nr(int i)
diff --git a/mero/magic.h b/mero/magic.h
index a848857..2ae0a8f 100644
--- a/mero/magic.h
+++ b/mero/magic.h
@@ -467,6 +467,28 @@ enum m0_magic_satchel {
 /* Trace */
 	/* m0_trace_rec_header::trh_magic (foldable doll) */
 	M0_TRACE_MAGIC = 0x33f01dab1ed01177,
+
+/* BE Domain */
+        /* m0_be_domain::be_dom_magic (callas called) */
+        M0_BE_DOMAIN_MAGIC = 0x33ca11a5ca11ed77,
+
+        /* m0_be_seg::td_head_magic (shoeless boss) */
+        M0_BE_SEG_HDR_MAGIC = 0x3355373045550977,
+
+        /* m0_be_seg::bs_magic (booze loloish) */
+        M0_BE_SEG_MAGIC = 0x3332009451070777,
+
+        /* m0_be_tx::td_head_magic (acidic adalia) */
+        M0_BE_TX_HDR_MAGIC = 0x33ac1d1cada11a77,
+
+        /* m0_be_tx::bt_magic (bozo adelaide) */
+        M0_BE_TX_MAGIC = 0x330209ade1a1de77,
+
+        /* m0_be_br::td_head_magic (losses obsess) */
+        M0_BE_REG_HDR_MAGIC = 0x3353550755359077,
+
+        /* m0_be_br::bs_magic (sissoo azolla) */
+        M0_BE_REG_MAGIC = 0x33005515a2011a77,
 };
 
 #endif /* __MERO_MERO_MAGIC_H__ */
diff --git a/sm/sm.c b/sm/sm.c
index 043da9b..5b0360f 100644
--- a/sm/sm.c
+++ b/sm/sm.c
@@ -396,6 +396,14 @@ M0_INTERNAL void m0_sm_conf_extend(const struct m0_sm_state_descr *base,
 	}
 }
 
+M0_INTERNAL void m0_be_sm_state_change(struct m0_sm_group *grp,
+                                       struct m0_sm *sm, uint32_t state)
+{
+        m0_sm_group_lock(grp);
+        m0_sm_state_set(sm, state);
+        m0_sm_group_unlock(grp);
+}
+
 /** @} end of sm group */
 
 /*
diff --git a/sm/sm.h b/sm/sm.h
index 18b425e..a6b6973 100644
--- a/sm/sm.h
+++ b/sm/sm.h
@@ -628,6 +628,15 @@ M0_INTERNAL void m0_sm_conf_extend(const struct m0_sm_state_descr *base,
 
 M0_INTERNAL bool m0_sm_invariant(const struct m0_sm *mach);
 
+
+/**
+ * State change with sm group locking 
+ * This function locks sm_group and changes state specified in function
+ * parameter, then unlocks the sm_group.
+ */
+M0_INTERNAL void m0_be_sm_state_change(struct m0_sm_group *grp,
+                                       struct m0_sm *sm, uint32_t state);
+
 /** @} end of sm group */
 
 /* __MERO_SM_SM_H__ */
-- 
1.8.3.2

