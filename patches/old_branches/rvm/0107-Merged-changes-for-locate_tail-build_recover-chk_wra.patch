From c75974ad24aac14c0694e5d61f2db5ee6c443866 Mon Sep 17 00:00:00 2001
From: Zishan Shaikh <zishan_shaikh@xyratex.com>
Date: Thu, 30 May 2013 09:20:47 -0700
Subject: [PATCH 107/121] Merged changes for locate_tail, build_recover,
 chk_wrap, range_chk_sum and others.

---
 rvm/rvm_logrecovr.c | 3298 ++++++++++++++++++++++++++++++++++-----------------
 rvm/rvm_private.h   |   33 +-
 2 files changed, 2272 insertions(+), 1059 deletions(-)

diff --git a/rvm/rvm_logrecovr.c b/rvm/rvm_logrecovr.c
index 54febc8..ad88d68 100644
--- a/rvm/rvm_logrecovr.c
+++ b/rvm/rvm_logrecovr.c
@@ -70,12 +70,20 @@ rvm_bool_t          rvm_shadow_buf;     /* use shadow buffer */
 #define ZERO 0
 #else
 #endif
+void scan_reverse_snr_loop_cb(struct m0_be_cbinfo *cbinfo, int  be_status,
+                           m0_be_msg_type_t msg_type);
+void scan_reverse_snr_cb(struct m0_be_cbinfo *cbinfo, int  be_status,
+                           m0_be_msg_type_t msg_type);
 
 /*static rvm_length_t     nv_local_max = NV_LOCAL_MAX;*/
 static struct timeval   trunc_start_time;
 static rvm_length_t     last_tree_build_time;
 static rvm_length_t     last_tree_apply_time;
 
+ /* Forward declaration needed for sts_range_chk_sum_cb. */
+void sts_nv_fwd_cb(struct m0_be_cbinfo *cbinfo, int be_status,
+		   m0_be_msg_type_t msg);
+
 #define NODES_PER_YIELD 1000000
 static rvm_length_t num_nodes = NODES_PER_YIELD;
 /* test if modification range will change monitored addresses */
@@ -181,136 +189,162 @@ void free_log_buf(log)
         log_buf->aux_length = 0;
         }
     }
+
+/* Callback for init_buffer. */
+void init_buffer_cb(cbinfo, status, msg)
+	struct m0_be_cbinfo *cbinfo;
+	int		     status;
+	m0_be_msg_type_t     msg;
+{
+	lrc_cbdata_t	*lrc_cbdata;
+	log_t		*log;
+	rvm_bool_t	 synch;
+
+	printf("\n function %s \n", __FUNCTION__);
+	if (status != 0)
+		goto exit;
+
+	lrc_cbdata = container_of(cbinfo, lrc_cbdata_t, lrc_cbinfo);
+	log	   = lrc_cbdata->lrc_log;
+	synch	   = lrc_cbdata->lrc_synch;
+
+	assert(log->trunc_thread == cthread_self());
+
+	if (synch)
+		mutex_unlock(&log->dev_lock);   /* end dev_lock crit sec */
+
+	assert(log->trunc_thread == cthread_self());
+exit:
+	/********************************************** UNCOMMENT ***************************************/
+	/*if (cbinfo->bc_pcbinfo != NULL && cbinfo->bc_pcbinfo->bc_cb != NULL)*/
+	/*m0_be_handler_post(cbinfo->bc_pcbinfo, status, msg);*/
+
+	m0_free(lrc_cbdata);
+}
+
 /* init log buffer with desired offset data from log */
-rvm_return_t init_buffer(log,offset,direction,synch)
-    log_t           *log;               /* log descriptor */
-    rvm_offset_t    *offset;            /* offset in log to load */
-    rvm_bool_t      direction;          /* true ==> forward */
-    rvm_bool_t      synch;              /* true ==> synchronization required */
-    {
-    log_buf_t       *log_buf = &log->log_buf; /* log buffer descriptor */
-    rvm_length_t    length;             /* length of buffer */
-    rvm_offset_t    read_len;           /* read length calculation temp */
-    rvm_return_t    retval = RVM_SUCCESS; /* return value */
+rvm_return_t init_buffer(log, offset, direction, synch, cbinfo)
+    log_t           	*log;          /* log descriptor */
+    rvm_offset_t    	*offset;       /* offset in log to load */
+    rvm_bool_t      	 direction;    /* true ==> forward */
+    rvm_bool_t      	 synch;        /* true ==> synchronization required */
+    struct m0_be_cbinfo *cbinfo;
+{
+	log_buf_t       	*log_buf   = &log->log_buf;
+	lrc_cbdata_t		*lrc_cbdata;
+	struct m0_be_cbinfo 	*lrc_cbinfo;
+	rvm_length_t     	 length;      /* length of buffer */
+	rvm_offset_t     	 read_len;    /* read length calculation temp */
+	rvm_return_t      	 retval    = RVM_SUCCESS;
+	int		 	 be_status = 0;
+	m0_be_msg_type_t  	 msg 	   = M0_BE_SUCCESS;
 
-    assert(RVM_OFFSET_GEQ(*offset,log->status.log_start));
-    assert(RVM_OFFSET_LEQ(*offset,log->dev.num_bytes));
-    assert(log->trunc_thread == cthread_self());
+	printf("\n function %s \n", __FUNCTION__);
 
-    /* calculate buffer read length and ptr */
-    log_buf->ptr = OFFSET_TO_SECTOR_INDEX(*offset);
-    if (direction == FORWARD)
-        {                               /* forward */
-        log_buf->offset = CHOP_OFFSET_TO_SECTOR_SIZE(*offset);
-        if (RVM_OFFSET_EQL(log_buf->offset,log->dev.num_bytes))
-            read_len = log->status.log_size;
-        else
-            read_len = RVM_SUB_OFFSETS(log->dev.num_bytes,
-                                       log_buf->offset);
-        }
-    else
-        {                               /* reverse */
-        log_buf->offset = ROUND_OFFSET_TO_SECTOR_SIZE(*offset);
-        if (RVM_OFFSET_EQL(log_buf->offset,log->status.log_start))
-            log_buf->offset = log->dev.num_bytes;
-        if (RVM_OFFSET_EQL(log_buf->offset,log->dev.num_bytes))
-            read_len = log->status.log_size;
-        else
-            read_len = RVM_SUB_OFFSETS(log_buf->offset,
-                                       log->status.log_start);
+	M0_ALLOC_PTR(lrc_cbdata);
+        if (lrc_cbdata == NULL) {
+                be_status = -1;
+                msg       = -ENOMEM;
+                goto exit;
         }
 
-    /* get actual length to read */
-    if (RVM_OFFSET_GTR(read_len,log_buf->buf_len))
-        length = log_buf->length;
-    else
-        length = RVM_OFFSET_TO_LENGTH(read_len);
-    /* set offset of read for reverse fill */
-    if (direction == REVERSE)
-        {
-        log_buf->offset = RVM_SUB_LENGTH_FROM_OFFSET(log_buf->offset,
-                                                     length);
-        if (log_buf->ptr == 0)
-            log_buf->ptr = length;
-        else
-            log_buf->ptr += (length-SECTOR_SIZE);
-        }
+	lrc_cbdata->lrc_log   =  log;
+	lrc_cbdata->lrc_synch =  synch;
+	lrc_cbinfo	      = &lrc_cbdata->lrc_cbinfo;
+	/************************ UNCOMMENT THIS. ***************************************************/
+	/*m0_be_cbinfo_copy_helper(cbinfo, lrc_cbinfo, init_buffer_cb);*/
 
-    /* lock device & allow swap if necessary */
-    if (synch)
-        {
-        if (!rvm_no_yield) cthread_yield();
-        assert(log->trunc_thread == cthread_self());
-        mutex_lock(&log->dev_lock); /* begin dev_lock crit sec */
-        assert(log->trunc_thread == cthread_self());
-        }
+	assert(RVM_OFFSET_GEQ(*offset, log->status.log_start));
+	assert(RVM_OFFSET_LEQ(*offset, log->dev.num_bytes));
+	assert(log->trunc_thread == cthread_self());
 
-    /* allow write to buffer */
-/* MACH_RVM_PROTECT
- *
- * protect(log_buf->buf, log_buf->length, FALSE,
- *         VM_PROT_WRITE | VM_PROT_READ);
- */
+	/* calculate buffer read length and ptr */
+	log_buf->ptr = OFFSET_TO_SECTOR_INDEX(*offset);
+	if (direction == FORWARD) {
+		log_buf->offset = CHOP_OFFSET_TO_SECTOR_SIZE(*offset);
 
-    /* read data from log device */
-    if ((log_buf->r_length=read_dev_old(&log->dev,&log_buf->offset,
-                                        log_buf->buf,length)) < 0)
-        {
-        retval = RVM_EIO;               /* i/o error */
-        log_buf->r_length = 0;          /* buffer invalid */
-        }
-    assert(log->trunc_thread == cthread_self());
+		if (RVM_OFFSET_EQL(log_buf->offset, log->dev.num_bytes))
+			read_len = log->status.log_size;
+		else
+			read_len = RVM_SUB_OFFSETS(log->dev.num_bytes,
+					     	   log_buf->offset);
+	} else {
+		log_buf->offset = ROUND_OFFSET_TO_SECTOR_SIZE(*offset);
 
-    /* write protect buffer & unlock */
-/* MACH_RVM_PROTECT
- *
- * protect(log_buf->buf, log_buf->length, FALSE, VM_PROT_READ);
- *
- * #ifdef SPECIAL_DEBUG
- * / * re-read into shadow buffer & compare * /
- * if (rvm_shadow_buf)
- * {
- *     ret = vm_protect(task_self_,(vm_address_t)(log_buf->shadow_buf),
- *                      (vm_size_t)(log_buf->length),FALSE,
- *                      VM_PROT_WRITE | VM_PROT_READ);
- *     assert(ret == KERN_SUCCESS);
- *     if ((r_length=read_dev(&log->dev,&log_buf->offset,
- *                            log_buf->shadow_buf,length)) < 0)
- *     {
- *         retval = RVM_EIO;               / * i/o error * /
- *         assert(rvm_false);
- *     }
- *     assert(r_length == length);
- *     assert(r_length == log_buf->r_length);
- *     ret = vm_protect(task_self_,(vm_address_t)(log_buf->shadow_buf),
- *                      (vm_size_t)(log_buf->length),FALSE,VM_PROT_READ);
- *     assert(ret == KERN_SUCCESS);
- *     assert(memcmp(log_buf->buf,log_buf->shadow_buf,length) == 0);
- * }
- * #endif SPECIAL_DEBUG
- */
+		if (RVM_OFFSET_EQL(log_buf->offset, log->status.log_start))
+			log_buf->offset = log->dev.num_bytes;
 
-    if (synch)
-        mutex_unlock(&log->dev_lock);   /* end dev_lock crit sec */
-    assert(log->trunc_thread == cthread_self());
+		if (RVM_OFFSET_EQL(log_buf->offset, log->dev.num_bytes))
+			read_len = log->status.log_size;
+		else
+			read_len = RVM_SUB_OFFSETS(log_buf->offset,
+					       	   log->status.log_start);
+	}
+
+	/* get actual length to read */
+	if (RVM_OFFSET_GTR(read_len, log_buf->buf_len))
+		length = log_buf->length;
+	else
+		length = RVM_OFFSET_TO_LENGTH(read_len);
+
+	/* set offset of read for reverse fill */
+	if (direction == REVERSE) {
+		log_buf->offset = RVM_SUB_LENGTH_FROM_OFFSET(log_buf->offset,
+							     length);
+		if (log_buf->ptr == 0)
+			log_buf->ptr = length;
+		else
+			log_buf->ptr += (length-SECTOR_SIZE);
+	}
+
+	/* lock device & allow swap if necessary */
+	if (synch) {
+		if (!rvm_no_yield)
+			cthread_yield();
+		assert(log->trunc_thread == cthread_self());
+		mutex_lock(&log->dev_lock); /* begin dev_lock crit sec */
+		assert(log->trunc_thread == cthread_self());
+	}
+
+	 /************************ REPLCAE WITH read_dev_new  and pass lrc_cbinfo**********/
+	/* read data from log device */
+	if ((log_buf->r_length = read_dev_old(&log->dev, &log_buf->offset,
+					      log_buf->buf, length)) < 0) {
+		retval 		  =  RVM_EIO;               /* i/o error */
+		log_buf->r_length =  0;          /* buffer invalid */
+		be_status 	  = -1;
+		msg	  	  =  retval;
+	}
+
+exit:
+	if (be_status != 0 && cbinfo != NULL && cbinfo->bc_cb != NULL) {
+		m0_be_handler_post(cbinfo, be_status, msg);
+		m0_free(lrc_cbdata);
+	}
+
+	/*************************** REMOVE THIS **********************************************/
+	init_buffer_cb(lrc_cbinfo, be_status, msg);
+	return retval;
+}
 
-    return retval;
-    }
 /* refill buffer in scan direction */
-static rvm_return_t refill_buffer(log,direction,synch)
-    log_t           *log;               /* log descriptor */
-    rvm_bool_t      direction;          /* true ==> forward */
-    rvm_bool_t      synch;              /* true ==> synchronization required */
-    {
-    log_buf_t       *log_buf = &log->log_buf; /* log buffer descriptor */
-    rvm_offset_t    offset;             /* new buffer offset temp */
+static rvm_return_t refill_buffer(log, direction, synch, cbinfo)
+    log_t           	*log;            /* log descriptor */
+    rvm_bool_t           direction;      /* true ==> forward */
+    rvm_bool_t      	 synch;          /* true ==> synchronization required */
+    struct m0_be_cbinfo *cbinfo;
+{
+	log_buf_t       *log_buf = &log->log_buf; /* log buffer descriptor */
+	rvm_offset_t     offset;             /* new buffer offset temp */
 
-    /* compute new offset for buffer fill */
-    offset = RVM_ADD_LENGTH_TO_OFFSET(log_buf->offset,log_buf->ptr);
+	printf("\n function %s \n", __FUNCTION__);
+	/* compute new offset for buffer fill */
+	offset = RVM_ADD_LENGTH_TO_OFFSET(log_buf->offset,log_buf->ptr);
+
+	/* fill the buffer */
+	return init_buffer(log, &offset, direction, synch, cbinfo);
+}
 
-    /* fill the buffer */
-    return init_buffer(log,&offset,direction,synch);
-    }
 /* compare buf & shadow buf from gdb */
 #ifdef SPECIAL_DEBUG
 int log_buf_cmp(disp)
@@ -406,114 +440,163 @@ int find_buf_word(wrd,disp)
 
     return find_word(wrd, (rvm_length_t *)log_buf->buf,disp,log_buf->r_length);
     }
-/* load log auxillary buffer */
-rvm_return_t load_aux_buf(log,log_offset,length,aux_ptr,
-                                 data_len,synch,pre_load)
-    log_t           *log;               /* log descriptor */
-    rvm_offset_t    *log_offset;        /* buffer read offset */
-    rvm_length_t    length;             /* data length wanted */
-    rvm_length_t    *aux_ptr;           /* ptr to aux. buf offset */
-    rvm_length_t    *data_len;          /* ptr to actual data length read */
-    rvm_bool_t      synch;              /* true ==> synchronization required */
-    rvm_bool_t      pre_load;           /* permit pre-loading of range */
-    {
-    log_buf_t       *log_buf = &log->log_buf; /* log buffer descriptor */
-    rvm_offset_t    high_offset;        /* end of read area */
-    rvm_length_t    read_len;           /* buffer read length */
-    rvm_return_t    retval = RVM_SUCCESS;
 
-    assert(log->trunc_thread == cthread_self());
+void load_aux_buf_cb(cbinfo, status, msg_type)
+        struct m0_be_cbinfo     *cbinfo;
+        int                      status;
+        m0_be_msg_type_t         msg_type;
+{
+	lrc_cbdata_t *lrc_cbdata;
 
-    /* check offset */
-    if (RVM_OFFSET_GTR(*log_offset,log->dev.num_bytes))
-        {
-        *aux_ptr = -1;                  /* out of bounds -- partial record */
-        return RVM_SUCCESS;
-        }
+	if (status != 0)
+		goto exit;
 
-    /* see if request is already in buffer */
-    high_offset = RVM_ADD_LENGTH_TO_OFFSET(log_buf->aux_offset,
-                                           log_buf->aux_rlength);
-    if ((RVM_OFFSET_GEQ(*log_offset,log_buf->aux_offset))
-        && (RVM_OFFSET_LSS(*log_offset,high_offset)))
-        {
-        /* yes, have at least some of the data so report how much */
-        *aux_ptr = RVM_OFFSET_TO_LENGTH(
-                     RVM_SUB_OFFSETS(*log_offset,log_buf->aux_offset));
-        read_len = RVM_OFFSET_TO_LENGTH(
-                       RVM_SUB_OFFSETS(high_offset,*log_offset));
-        if (read_len < length)
-            *data_len = read_len;
-        else
-            *data_len = length;
-        return RVM_SUCCESS;
-        }
+	printf("\n function %s \n", __FUNCTION__);
 
-    /* if less than sector requested, see if pre-load permitted */
-    if (pre_load && (length < SECTOR_SIZE))
-        read_len = log_buf->aux_length; /* yes, fill buffer */
-    else
-        read_len = length;              /* no, just do what requested */
-    /* determine length and offset for log read */
-    log_buf->aux_offset = CHOP_OFFSET_TO_SECTOR_SIZE(*log_offset);
-    high_offset = RVM_ADD_LENGTH_TO_OFFSET(*log_offset,read_len);
-    high_offset = ROUND_OFFSET_TO_SECTOR_SIZE(high_offset);
-    if (RVM_OFFSET_GTR(high_offset,log->dev.num_bytes))
-        high_offset = log->dev.num_bytes; /* don't read past end of log */
-
-    /* report actual length read and ptr into buffer */
-    read_len = RVM_OFFSET_TO_LENGTH(
-                RVM_SUB_OFFSETS(high_offset,log_buf->aux_offset));
-    *aux_ptr = OFFSET_TO_SECTOR_INDEX(*log_offset);
-    if (read_len > log_buf->aux_length)
-        {
-        if ((read_len >= length)
-            && (length <= (log_buf->aux_length-SECTOR_SIZE)))
-            *data_len = length;
-        else
-            *data_len = log_buf->aux_length - *aux_ptr;
-        read_len = log_buf->aux_length;
-        }
-    else
-        *data_len = length;
+	lrc_cbdata = container_of(cbinfo, lrc_cbdata_t, lrc_cbinfo);
+	assert(lrc_cbdata->lrc_log->trunc_thread == cthread_self());
 
-    /* lock device and allow swap if necessary */
-    if (synch)
-        {
-        if (!rvm_no_yield) cthread_yield(); /* allow swap now */
-        assert(log->trunc_thread == cthread_self());
-        mutex_lock(&log->dev_lock); /* begin dev_lock crit sec */
-        assert(log->trunc_thread == cthread_self());
+	if (lrc_cbdata->lrc_synch)
+        	mutex_unlock(&lrc_cbdata->lrc_log->dev_lock);
+
+	assert(lrc_cbdata->lrc_log->trunc_thread == cthread_self());
+
+exit:
+	if(cbinfo->bc_pcbinfo != NULL && cbinfo->bc_pcbinfo->bc_cb != NULL) {
+                m0_be_handler_post(cbinfo->bc_pcbinfo, status, msg_type);
         }
 
-    /* allow write to buffer */
-/* MACH_RVM_PROTECT
- *
- * protect(log_buf->aux_buf, log_buf->aux_length, FALSE,
- *         VM_PROT_WRITE | VM_PROT_READ);
- */
+	m0_free(lrc_cbdata);
+}
+/* load log auxillary buffer */
+rvm_return_t load_aux_buf(log, log_offset, length,aux_ptr,
+                          data_len, synch,pre_load, cbinfo)
+    log_t           	*log;              /* log descriptor */
+    rvm_offset_t    	*log_offset;       /* buffer read offset */
+    rvm_length_t    	 length;           /* data length wanted */
+    rvm_length_t    	*aux_ptr;          /* ptr to aux. buf offset */
+    rvm_length_t    	*data_len;         /* ptr to actual data length read */
+    rvm_bool_t      	 synch;         /* true ==> synchronization required */
+    rvm_bool_t      	 pre_load;          /* permit pre-loading of range */
+    struct m0_be_cbinfo *cbinfo;
+{
+	lrc_cbdata_t        *lrc_cbdata;
+	struct m0_be_cbinfo *lrc_cbinfo;
+	log_buf_t           *log_buf   = &log->log_buf;
+	rvm_offset_t	    *aux_offset;
+	rvm_offset_t         high_offset;        /* end of read area */
+	rvm_length_t         read_len;           /* buffer read length */
+	rvm_bool_t	     is_load_aux_done = rvm_false;
+	rvm_return_t         retval    	      = RVM_SUCCESS;
+	int		     be_status 	      = 0;
+	m0_be_msg_type_t     msg              = M0_BE_SUCCESS;
+
+	printf("\n function %s \n", __FUNCTION__);
 
-    /* read new value data from log */
-    if ((log_buf->aux_rlength=read_dev(&log->dev,&log_buf->aux_offset,
-                 log_buf->aux_buf,read_len)) < 0)
-        {
-        retval = RVM_EIO;
-        log_buf->aux_rlength = 0;
+	assert(log->trunc_thread == cthread_self());
+
+	/* check offset */
+	if (RVM_OFFSET_GTR(*log_offset, log->dev.num_bytes)) {
+		/* out of bounds -- partial record */
+		*aux_ptr  = -1;
+		be_status = -1;
+		msg	  = M0_BE_INTERNAL;
+		goto exit;
+	}
+
+	/* see if request is already in buffer */
+	high_offset = RVM_ADD_LENGTH_TO_OFFSET(log_buf->aux_offset,
+					       log_buf->aux_rlength);
+	if ((RVM_OFFSET_GEQ(*log_offset, log_buf->aux_offset))
+	    && (RVM_OFFSET_LSS(*log_offset, high_offset))) {
+		/* yes, have at least some of the data so report how much */
+		 aux_offset = &log_buf->aux_offset;
+		*aux_ptr = RVM_OFFSET_TO_LENGTH(RVM_SUB_OFFSETS(*log_offset,
+								*aux_offset));
+
+		read_len = RVM_OFFSET_TO_LENGTH(RVM_SUB_OFFSETS(high_offset,
+								*log_offset));
+		if (read_len < length)
+			*data_len = read_len;
+		else
+		   	*data_len = length;
+
+		is_load_aux_done = rvm_true;
+		goto exit;
+	}
+
+	/* if less than sector requested, see if pre-load permitted */
+	if (pre_load && (length < SECTOR_SIZE))
+		read_len = log_buf->aux_length; /* yes, fill buffer */
+	else
+		read_len = length;              /* no, just do what requested */
+
+	/* determine length and offset for log read */
+	log_buf->aux_offset = CHOP_OFFSET_TO_SECTOR_SIZE(*log_offset);
+	high_offset 	    = RVM_ADD_LENGTH_TO_OFFSET(*log_offset,read_len);
+	high_offset 	    = ROUND_OFFSET_TO_SECTOR_SIZE(high_offset);
+
+	if (RVM_OFFSET_GTR(high_offset, log->dev.num_bytes))
+		/* don't read past end of log */
+		high_offset = log->dev.num_bytes;
+
+	/* report actual length read and ptr into buffer */
+	read_len = RVM_OFFSET_TO_LENGTH(RVM_SUB_OFFSETS(high_offset,
+							log_buf->aux_offset));
+	*aux_ptr = OFFSET_TO_SECTOR_INDEX(*log_offset);
+
+	if (read_len > log_buf->aux_length) {
+		if ((read_len >= length) && (length <=
+					     (log_buf->aux_length-SECTOR_SIZE)))
+			*data_len = length;
+		else
+		    	*data_len = log_buf->aux_length - *aux_ptr;
+
+		read_len = log_buf->aux_length;
+	} else
+		*data_len = length;
+
+	/* lock device and allow swap if necessary */
+	if (synch) {
+		if (!rvm_no_yield)
+			cthread_yield(); /* allow swap now */
+		assert(log->trunc_thread == cthread_self());
+		mutex_lock(&log->dev_lock); /* begin dev_lock crit sec */
+		assert(log->trunc_thread == cthread_self());
+	}
+
+	M0_ALLOC_PTR(lrc_cbdata);
+        if (lrc_cbdata == NULL) {
+                be_status = -1;
+                msg       = -ENOMEM;
+                goto exit;
         }
-    assert(log->trunc_thread == cthread_self());
 
-    /* write protect buffer & unlock */
-/* MACH_RVM_PROTECT
- *
- * protect(log_buf->aux_buf, log_buf->aux_length, FALSE, VM_PROT_READ);
- */
+	lrc_cbdata->lrc_log   = log;
+	lrc_cbdata->lrc_synch = synch;
+	lrc_cbinfo            = &lrc_cbdata->lrc_cbinfo;
+	/************************** UNCOMMENT THISSSSSSSS **************************************/
+	/*m0_be_cbinfo_copy_helper(cbinfo, lrc_cbinfo, load_aux_buf_cb);*/
+
+	/* read new value data from log */
+	if ((log_buf->aux_rlength = read_dev(&log->dev ,&log_buf->aux_offset,
+					     log_buf->aux_buf, read_len)) < 0) {
+		retval = msg 	     = RVM_EIO;
+		log_buf->aux_rlength = 0;
+		be_status 	     = -1;
+	}
 
-    if (synch)
-        mutex_unlock(&log->dev_lock);   /* end dev_lock crit sec */
-    assert(log->trunc_thread == cthread_self());
+exit:
+	if ((retval != RVM_SUCCESS || is_load_aux_done) && cbinfo != NULL &&
+	    cbinfo->bc_cb != NULL) {
+		m0_be_handler_post(cbinfo, be_status, msg);
+		m0_free(lrc_cbdata);
+	}
 
-    return retval;
-    }
+	/************************** REMOVE THIS CALLLL ******************************************/
+	load_aux_buf_cb(lrc_cbinfo, be_status, msg);
+	return retval;
+}
 
 void clear_aux_buf(log)
     log_t           *log;               /* log descriptor */
@@ -523,9 +606,8 @@ void clear_aux_buf(log)
     RVM_ZERO_OFFSET(log_buf->aux_offset);
     log_buf->aux_rlength = 0;
     }
-
 /* record header type validation */
-rvm_bool_t chk_hdr_type(rec_hdr)
+rvm_bool_t chk_hdr_type(rec_hdr )
     rec_hdr_t       *rec_hdr;           /* generic record header */
     {
     switch (rec_hdr->struct_id)
@@ -550,21 +632,16 @@ rvm_bool_t chk_hdr_currency(log,rec_hdr)
 
     /* be sure record number makes sense */
     if ((status->first_rec_num != 0) &&
-        (rec_hdr->rec_num < status->first_rec_num)) {
-	printf("\nfunction : %s status->firsrt_rec_num != 0", __FUNCTION__);
+        (rec_hdr->rec_num < status->first_rec_num))
         return rvm_false;               /* obsolete record */
-    }
 
     /* be sure record written after previous truncation & before this one */
     if (TIME_LSS(rec_hdr->timestamp,status->prev_trunc)
-        || TIME_GTR(rec_hdr->timestamp,status->last_trunc)) {
-	printf("\nfunction : %s TIME_LESS || TIME_GTR", __FUNCTION__);
+        || TIME_GTR(rec_hdr->timestamp,status->last_trunc))
         return rvm_false;                   /* obsolete record */
-    }
-	printf("\nfunction : %s Returning true", __FUNCTION__);
 
     return rvm_true;
-}
+    }
 
 void reset_hdr_chks(log)
     log_t           *log;               /* log descriptor */
@@ -678,449 +755,426 @@ rvm_bool_t validate_hdr(log,rec_hdr,rec_end,direction)
 
     return rvm_true;
     }
-/* get next new value range by forward scan of transaction record
-   ptr points to next range header
-   exits with as much of range in buffer as will fit */
-rvm_return_t scan_nv_forward(log,synch)
-    log_t           *log;               /* log descriptor */
-    rvm_bool_t      synch;              /* true ==> synchronization required */
-    {
-    log_buf_t       *log_buf = &log->log_buf; /* log buffer descriptor */
-    rvm_offset_t    offset;             /* offset calculation temp */
-    rec_hdr_t       *rec_hdr;           /* temporary cast for record header */
-    rvm_return_t    retval;             /* return value */
 
-    /* see if new header is entirely within buffer */
-    if ((log_buf->ptr+sizeof(rec_hdr_t)) >= log_buf->r_length)
-        {
-        /* no, refill buffer */
-        offset = RVM_ADD_LENGTH_TO_OFFSET(log_buf->offset,
-                                          log_buf->ptr);
-        if ((retval=init_buffer(log,&offset,FORWARD,synch))
-            != RVM_SUCCESS) return retval;
-        }
+void scan_nv_forward_cb(cbinfo, status, msg)
+	struct m0_be_cbinfo	*cbinfo;
+	int			 status;
+	m0_be_msg_type_t	 msg;
+{
+	lrc_cbdata_t		*lrc_cbdata;
+	log_t			*log;
+	log_buf_t       	*log_buf;
+	rec_hdr_t       	*rec_hdr;      /* cast for next record hdr */
+	rvm_return_t     	 retval;
+	rvm_bool_t		 synch;
+	rvm_bool_t		 fwd_done = rvm_false;
 
-    /* check header */
-    rec_hdr = (rec_hdr_t *)&log_buf->buf[log_buf->ptr];
-    switch (rec_hdr->struct_id)
-        {
-      case nv_range_id:     break;
-      case rec_end_id:      return RVM_SUCCESS;
+	printf("\nfunction %s \n", __FUNCTION__);
 
-      default:              return RVM_SUCCESS; /* need better reporting */
-        }
+	if (status != 0)
+		goto exit;
 
-    /* get whole range in buffer */
-    if ((log_buf->ptr+rec_hdr->rec_length) > log_buf->r_length)
-        {
-        if ((retval=refill_buffer(log,FORWARD,synch))
-            != RVM_SUCCESS) return retval;
-        }
+	lrc_cbdata    =  container_of(cbinfo, lrc_cbdata_t, lrc_cbinfo);
+	log	      =  lrc_cbdata->lrc_log;
+	synch	      =  lrc_cbdata->lrc_synch;
+	log_buf       = &log->log_buf;
 
-    return RVM_SUCCESS;
-    }
-/* get previous new value range by reverse scan of transaction record
-   ptr points to previous range header; exits with range in buffer */
-rvm_return_t scan_nv_reverse(log,synch)
-    log_t          *log;                /* log descriptor */
-    rvm_bool_t      synch;              /* true ==> synchronization required */
-    {
-    log_buf_t       *log_buf = &log->log_buf; /* log buffer descriptor */
-    rec_hdr_t       *rec_hdr;           /* temporary cast for record header */
-    long            len=0;                /* back displacement to prev. hdr */
-    rvm_offset_t    offset;             /* offset calculation temp */
-    rvm_return_t    retval;             /* return value */
+	/* check header */
+	rec_hdr = (rec_hdr_t *)&log_buf->buf[log_buf->ptr];
+	switch (rec_hdr->struct_id) {
+		case nv_range_id:
+			break;
 
-    /* get new header position */
-    rec_hdr = (rec_hdr_t *)&log_buf->buf[log_buf->ptr];
-    switch (rec_hdr->struct_id)
-    {
-      case rec_end_id:
-        len = ((rec_end_t *)rec_hdr)->sub_rec_len;
-        break;
+		case rec_end_id:
+			fwd_done = rvm_true;
+			goto exit;
+			/*return RVM_SUCCESS;*/
 
-      case nv_range_id:
-        len = ((nv_range_t *)rec_hdr)->sub_rec_len;
-        break;
+		default:
+			fwd_done = rvm_true;
+			goto exit;
+			/*return RVM_SUCCESS; *//* need better reporting */
+	}
 
-      default:
-        assert(rvm_false);               /* trouble -- log damage? */
-    }
+	/* get whole range in buffer */
+	if ((log_buf->ptr+rec_hdr->rec_length) > log_buf->r_length) {
+		retval = refill_buffer(log, FORWARD, synch, cbinfo->bc_pcbinfo);
+		if (retval != RVM_SUCCESS) {
+			status = -1;
+			msg    =  retval;
+		}
+	}
+exit:
+	if ((status != 0 || fwd_done) && cbinfo->bc_pcbinfo!= NULL &&
+	    cbinfo->bc_pcbinfo->bc_cb != NULL) {
+	    	m0_be_handler_post(cbinfo->bc_pcbinfo, status, msg);
+	}
 
-    /* see if new header is entirely within buffer */
-    if ((log_buf->ptr-len) < 0)
-        {
-        /* no, refill buffer according to length of data */
-        if ((len-sizeof(nv_range_t)) <= NV_LOCAL_MAX)
-            {                           /* small, get data into buffer */
-            if ((retval=refill_buffer(log,REVERSE,synch))
-                != RVM_SUCCESS) return retval;
-            log_buf->ptr -= len;
-            }
-        else
-            {                           /* large, skip data for now */
-            offset = RVM_ADD_LENGTH_TO_OFFSET(log_buf->offset,
-                         (log_buf->ptr+sizeof(nv_range_t)));
-            offset = RVM_SUB_LENGTH_FROM_OFFSET(offset,len);
-            if ((retval=init_buffer(log,&offset,REVERSE,synch))
-                != RVM_SUCCESS) return retval;
-            log_buf->ptr -= sizeof(nv_range_t);
-            }
-        }
-    else log_buf->ptr -= len;
-    /* exit pointing to new header */
-    rec_hdr = (rec_hdr_t *)&log_buf->buf[log_buf->ptr];
-    if (rec_hdr->struct_id == trans_hdr_id)
-        return RVM_SUCCESS;
-    assert(rec_hdr->struct_id == nv_range_id);
+	/* Not needed anymore, as refill_buffer takes parent..*/
+	m0_free(lrc_cbdata);
+}
 
-    return RVM_SUCCESS;
-    }
-/* validate record in buffer in forward scan */
-rvm_return_t validate_rec_forward(log,synch)
-    log_t           *log;               /* log descriptor */
-    rvm_bool_t      synch;              /* true ==> synchronization required */
-    {
-    log_buf_t       *log_buf = &log->log_buf; /* log buffer descriptor */
-    rec_hdr_t       *rec_hdr;           /* temporary cast for next record hdr */
-    rec_end_t       *rec_end = NULL;    /* temporary cast for record end */
-    rvm_offset_t    end_offset;         /* temporary for caluculating end */
-    rvm_return_t    retval;
-    long            tmp_ptr;
-    rvm_length_t    tmp_len;
+/* get next new value range by forward scan of transaction record
+   ptr points to next range header
+   exits with as much of range in buffer as will fit */
+rvm_return_t scan_nv_forward(log, synch, cbinfo)
+    log_t           	*log;   /* log descriptor */
+    rvm_bool_t      	 synch; /* true ==> synchronization required */
+    struct m0_be_cbinfo *cbinfo;
+{
+	lrc_cbdata_t		*lrc_cbdata;
+	struct m0_be_cbinfo	*lrc_cbinfo;
+	log_buf_t       	*log_buf   = &log->log_buf;
+	rvm_offset_t     	 offset;
+	rvm_return_t     	 retval;
+	int			 be_status = 0;
+	m0_be_msg_type_t	 msg 	   = M0_BE_SUCCESS;
 
-    /* see if next header is entirely within buffer */
-    if ((log_buf->ptr + MAX_HDR_SIZE) > log_buf->r_length)
-        {
-        /* no, re-init buffer */
-        end_offset = RVM_ADD_LENGTH_TO_OFFSET(log_buf->offset,
-                                              log_buf->ptr);
-       if ((retval = init_buffer(log,&end_offset,FORWARD,synch))
-           != RVM_SUCCESS) return retval;
-        }
+	printf("\nfunction %s\n", __FUNCTION__);
 
-    /* check header type */
-    rec_hdr = (rec_hdr_t *)&log_buf->buf[log_buf->ptr];
-    if (rec_hdr->struct_id == log_wrap_id)
-        goto validate;                  /* skip rec_end stuff for wrap */
-    if (!chk_hdr(log,rec_hdr,NULL,FORWARD))
-        goto no_record;                 /* no next record */
-
-    /* see if record will fit in buffer */
-    if ((ROUND_TO_SECTOR_SIZE(rec_hdr->rec_length+sizeof(rec_end_t))
-         + SECTOR_SIZE)
-        <= log_buf->length)
-        {
-        /* yes, get whole record in buffer */
-        if ((log_buf->ptr+rec_hdr->rec_length+sizeof(rec_end_t))
-            > log_buf->length)
-            {
-            /* refill buffer */
-            if ((retval = refill_buffer(log, FORWARD, synch))
-                != RVM_SUCCESS)
-			return retval;
-            rec_hdr = (rec_hdr_t *)&log_buf->buf[log_buf->ptr];
-            }
-        tmp_ptr = log_buf->ptr + rec_hdr->rec_length;
-        rec_end = (rec_end_t *)&log_buf->buf[tmp_ptr];
-        }
-    else
-        {
-        /* no, won't fit -- read rec_end into aux buffer for validation */
-        end_offset = RVM_ADD_LENGTH_TO_OFFSET(log_buf->offset,
-                         log_buf->ptr+rec_hdr->rec_length);
-
-        /* check offset alignment to see if rec_hdr is trash */
-        tmp_ptr = RVM_OFFSET_TO_LENGTH(end_offset);
-        if (tmp_ptr != CHOP_TO_LENGTH(tmp_ptr))
-            goto no_record;             /* end marker alignment wrong */
-        retval = load_aux_buf(log, &end_offset, sizeof(rec_end_t),
-			      &tmp_ptr, &tmp_len, synch, rvm_false);
-        if (retval != RVM_SUCCESS) return retval;
-        if (tmp_ptr == -1)
-            goto no_record;             /* record end not available */
-        rec_end = (rec_end_t *)&log_buf->aux_buf[tmp_ptr];
+	M0_ALLOC_PTR(lrc_cbdata);
+        if (lrc_cbdata == NULL) {
+                be_status = -1;
+                msg       = -ENOMEM;
+                goto exit;
         }
 
-    /* validate whole record now that end is available */
-  validate:
-    if (validate_hdr(log,rec_hdr,rec_end,FORWARD))
-        return RVM_SUCCESS;
+	lrc_cbdata->lrc_log   =  log;
+	lrc_cbdata->lrc_synch =  synch;
+	lrc_cbinfo	      = &lrc_cbdata->lrc_cbinfo;
 
-  no_record:                            /* no next record */
-    log_buf->ptr = -1;
-    return RVM_SUCCESS;
-    }
-/* scan forward from present position at a record structure
-   returns updated offset indexed by ptr; -1 ==> no next rec. */
-rvm_return_t scan_forward(log,synch)
-    log_t           *log;               /* log descriptor */
-    rvm_bool_t      synch;              /* true ==> synchronization required */
-    {
-    log_buf_t       *log_buf = &log->log_buf; /* log buffer descriptor */
-    rec_hdr_t       *rec_hdr;           /* cast for next record hdr */
-    rvm_return_t    retval;
+	/* see if new header is entirely within buffer */
+	if ((log_buf->ptr + sizeof(rec_hdr_t)) >= log_buf->r_length) {
+		/* it's not, then refill buffer */
+		offset = RVM_ADD_LENGTH_TO_OFFSET(log_buf->offset,
+						  log_buf->ptr);
 
-    assert(log_buf->ptr != -1);         /* invalid position */
-    rec_hdr = (rec_hdr_t *)&log_buf->buf[log_buf->ptr];
-    switch (rec_hdr->struct_id)
-        {
-      case trans_hdr_id: case log_seg_id:
-        log_buf->ptr += (rec_hdr->rec_length+sizeof(rec_end_t));
-        break;
-      case rec_end_id:
-        log_buf->ptr += sizeof(rec_end_t);
-        break;
-      case nv_range_id:                 /* scan past remaining ranges */
-        DO_FOREVER
-            {
-            if ((retval=scan_nv_forward(log,synch)) != RVM_SUCCESS)
-                return retval;
-            rec_hdr = (rec_hdr_t *)&log_buf->buf[log_buf->ptr];
-            switch (rec_hdr->struct_id)
-                {
-              case nv_range_id:
-                log_buf->ptr += rec_hdr->rec_length;
-                break;
-              case rec_end_id:
-                log_buf->ptr += sizeof(rec_end_t);
-                goto trans_done;
-              default:                  /* validate_rec_forward will handle */
-                goto trans_done;
-                }
-            }
-trans_done:
-        break;
-      case log_wrap_id:
-        if ((retval=init_buffer(log,&log->status.log_start,
-                                FORWARD,synch))
-                != RVM_SUCCESS) return retval;
-        break;
-      default:
-        if (rvm_utlsw)
-            {
-            log_buf->ptr = -1;          /* utility can handle unknown records */
-            return RVM_SUCCESS;
-            }
-        assert(rvm_false);                  /* unknown record type */
-        }
+		m0_be_cbinfo_copy_helper(cbinfo, lrc_cbinfo,
+					 scan_nv_forward_cb);
+		retval = init_buffer(log, &offset, FORWARD,synch, lrc_cbinfo);
+		if (retval != RVM_SUCCESS) {
+			be_status = -1;
+			msg    =  retval;
+		}
 
-    /* validate next record */
-    return validate_rec_forward(log,synch);
-    }
-/* scan for wrap marker */
-rvm_return_t scan_wrap_reverse(log,synch)
-    rvm_bool_t      synch;              /* true ==> synchronization required */
-    log_t           *log;               /* log descriptor */
-    {
-    log_buf_t       *log_buf = &log->log_buf; /* log buffer descriptor */
-    rec_hdr_t       *rec_hdr;           /* temporary cast for record header */
-    log_wrap_t      *log_wrap;          /* temporary cast for wrap marker */
-    long            tmp_ptr;            /* temporary buffer ptr */
-    rvm_return_t    retval;
+		goto exit;
+	}
 
-    /* load last sectors of log */
-    if ((retval=init_buffer(log,&log->dev.num_bytes,
-                            REVERSE,synch))
-        != RVM_SUCCESS) return retval;
-
-    /* scan for wrap marker */
-    /* for the purpose of locating the wrap marker, we use the (duplicated)
-       struct_id2 which, while positions at the end of the record, guarantees
-       that we must interpret it first, otherwise, we may possibly
-       mis-interpret other field of the record to have a struct_id of
-       log_wrap_id ! */
-    for (tmp_ptr = (log_buf->ptr - sizeof(log_wrap_t));
-         tmp_ptr >= 0; tmp_ptr -= sizeof(rvm_length_t))
-        {
-        log_wrap = (log_wrap_t *)&log_buf->buf[tmp_ptr];
-        if (log_wrap->struct_id2 == log_wrap_id)
-            {
-		assert( (log_wrap->rec_hdr.struct_id==log_wrap_id) || rvm_utlsw );
-		/* XXXX fix this */
-#if 0
-		if (!((log_wrap->struct_id == log_wrap_id) || rvm_utlsw)) {
-		    printf("not true!\n");
-		    assert(0);
-		}
-#endif
-	    break;
-            }
-        }
+	scan_nv_forward_cb(lrc_cbinfo, be_status, msg);
+exit:
+	if (be_status != 0 && cbinfo != NULL && cbinfo->bc_cb != NULL) {
+	    	m0_be_handler_post(cbinfo, be_status, msg);
+		m0_free(lrc_cbdata);
+	}
+	return RVM_SUCCESS;
+}
 
-    /* validate header if tmp_ptr legit */
-    if ((tmp_ptr >= 0) && (tmp_ptr < log_buf->r_length))
-        {
+void scan_wrap_reverse_cb(struct m0_be_cbinfo *cbinfo, int  be_status,
+			   m0_be_msg_type_t msg_type)
+{
+	log_t		*log;
+	log_buf_t       *log_buf; /* log buffer descriptor */
+	rec_hdr_t       *rec_hdr;           /* temporary cast for record header */
+	log_wrap_t      *log_wrap;          /* temporary cast for wrap marker */
+	long            tmp_ptr;            /* temporary buffer ptr */
+	lrc_cbdata_t   *lrc_cbdata;
+
+	M0_ASSERT(cbinfo != NULL);
+	lrc_cbdata = container_of(cbinfo, lrc_cbdata_t, lrc_cbinfo);
+
+	log     = lrc_cbdata->lrc_log;
+	log_buf = &log->log_buf;
+
+	/* scan for wrap marker */
+	/* for the purpose of locating the wrap marker, we use the (duplicated)
+	struct_id2 which, while positions at the end of the record, guarantees
+	that we must interpret it first, otherwise, we may possibly
+	mis-interpret other field of the record to have a struct_id of
+	log_wrap_id ! */
+	for (tmp_ptr = (log_buf->ptr - sizeof(log_wrap_t));
+	 tmp_ptr >= 0; tmp_ptr -= sizeof(rvm_length_t))
+	{
+		log_wrap = (log_wrap_t *)&log_buf->buf[tmp_ptr];
+		if (log_wrap->struct_id2 == log_wrap_id)
+		    {
+			assert( (log_wrap->rec_hdr.struct_id==log_wrap_id) || rvm_utlsw );
+		    	break;
+		    }
+	}
+
+	/* validate header if tmp_ptr legit */
+	if ((tmp_ptr >= 0) && (tmp_ptr < log_buf->r_length))
+	{
 	    log_buf->ptr = tmp_ptr;
 	    rec_hdr = (rec_hdr_t *)&log_buf->buf[log_buf->ptr];
 	    if (!validate_hdr(log,rec_hdr,NULL,REVERSE))
 		log_buf->ptr = -1;
-        }
-    else
-        /* no wrap marker found */
-        if (rvm_utlsw)
-            log_buf->ptr = -1;          /* utility can deal with it */
-        else assert(rvm_false);
+	}
+	else
+	/* no wrap marker found */
+	if (rvm_utlsw)
+	    log_buf->ptr = -1;          /* utility can deal with it */
+	else assert(rvm_false);
 
-    return RVM_SUCCESS;
-    }
-/* validate current record in buffer in reverse scan */
-rvm_return_t validate_rec_reverse(log,synch)
-     rvm_bool_t      synch;              /* true ==> synchronization required */
-     log_t           *log;               /* log descriptor */
+        if (cbinfo != NULL && cbinfo->bc_cb != NULL) {
+                m0_be_handler_post(cbinfo, be_status, msg_type);
+        }
+}
+/* scan for wrap marker */
+rvm_return_t scan_wrap_reverse(log_t *log, rvm_bool_t synch,
+				struct m0_be_cbinfo *cbinfo)
 {
-    log_buf_t       *log_buf = &log->log_buf; /* log buffer descriptor */
-    log_status_t    *status = &log->status; /* status area */
-    rec_end_t       *rec_end = NULL;    /* temporary cast for record end */
-    rec_hdr_t       *rec_hdr;           /* temporary cast for record header */
-    long            tmp_ptr;            /* temporary buffer ptr */
-    rvm_length_t    tmp_len;
-    rvm_offset_t    offset;             /* temp for offset calculations */
-    rvm_return_t    retval;
+	rvm_return_t    retval = RVM_EINTERNAL;
 
-    /* get previous end marker into buffer */
-    if ((long)(log_buf->ptr-sizeof(rec_end_t)) < 0)
-        {
-	    offset = RVM_ADD_LENGTH_TO_OFFSET(log_buf->offset,
-					      log_buf->ptr);
-	    if (RVM_OFFSET_EQL(offset,status->log_start))
-		{
-            retval=scan_wrap_reverse(log,synch);
-            return retval;              /* exit pointing to wrap marker */
-            }
-        else
-            {
-            if ((retval=init_buffer(log,&offset,REVERSE,synch))
-                != RVM_SUCCESS) return retval;
-            }
+	lrc_cbdata_t        *lrc_cbdata;
+	struct m0_be_cbinfo *lrc_cbinfo;
+	int 		     be_status = 0;
+	m0_be_msg_type_t     msg_type = M0_BE_SUCCESS;
+
+        M0_ALLOC_PTR(lrc_cbdata);
+        if (lrc_cbdata == NULL) {
+                be_status = -1;
+                msg_type  = -ENOMEM;
+                goto exit;
         }
-    log_buf->ptr -= sizeof(rec_end_t);
-
-    /* check new end marker */
-    rec_end = (rec_end_t *)&log_buf->buf[log_buf->ptr];
-    if (rec_end->rec_hdr.struct_id != rec_end_id)
-        goto no_record;             /* no next record */
-    /* see if record will fit in buffer */
-    if ((ROUND_TO_SECTOR_SIZE(rec_end->rec_hdr.rec_length+sizeof(rec_end_t))
-        + SECTOR_SIZE) <= log_buf->length)
-        {
-        /* yes, get whole record in buffer */
-        if ((long)(log_buf->ptr - rec_end->rec_hdr.rec_length) < 0)
-            {
-            /* refill buffer (be sure end marker is included) */
-            log_buf->ptr += sizeof(rec_end_t);
-            if ((retval=refill_buffer(log,REVERSE,synch))
-                != RVM_SUCCESS) return retval;
-            log_buf->ptr -= sizeof(rec_end_t);
-            rec_end = (rec_end_t *)&log_buf->buf[log_buf->ptr];
-            }
-        tmp_ptr = log_buf->ptr - rec_end->rec_hdr.rec_length;
-        rec_hdr = (rec_hdr_t *)&log_buf->buf[tmp_ptr];
+
+        lrc_cbdata->lrc_log   = log;
+        lrc_cbdata->lrc_synch = synch;
+        lrc_cbinfo            = &lrc_cbdata->lrc_cbinfo;
+
+	m0_be_cbinfo_copy_helper(cbinfo, lrc_cbinfo, scan_wrap_reverse_cb);
+	/* load last sectors of log */
+        retval = init_buffer(log, &log->dev.num_bytes, REVERSE, synch, cbinfo);
+	if (retval != RVM_SUCCESS) {
+	     be_status = -1;
+	     msg_type  = retval;
+	     goto exit_err;
+	}
+exit_err:
+	m0_free(lrc_cbdata);
+
+exit:
+       if (retval != RVM_SUCCESS && cbinfo != NULL &&
+            cbinfo->bc_cb != NULL) {
+                m0_be_handler_post(cbinfo, be_status, msg_type);
         }
-    else
-        {
-        /* no, save rec_end for validation & get header in aux. buffer */
-        offset = RVM_SUB_LENGTH_FROM_OFFSET(log_buf->offset,
-                                            rec_end->rec_hdr.rec_length);
-        offset = RVM_ADD_LENGTH_TO_OFFSET(offset,log_buf->ptr);
-
-        /* check offset alignment to see if rec_end is trash */
-        tmp_ptr = RVM_OFFSET_TO_LENGTH(offset);
-        if (tmp_ptr != CHOP_TO_LENGTH(tmp_ptr))
-            goto no_record;             /* header alignment wrong */
-        retval = load_aux_buf(log, &offset, MAX_HDR_SIZE, &tmp_ptr, &tmp_len,
-                              synch, rvm_false);
-        if (retval != RVM_SUCCESS) return retval;
-        if (tmp_ptr == -1)
-            goto no_record;             /* record header not available */
-        rec_hdr = (rec_hdr_t *)&log_buf->aux_buf[tmp_ptr];
+	return retval;
+
+}
+
+void __validate_rec_reverse_cb(struct m0_be_cbinfo *cbinfo,
+				int  be_status,
+                                m0_be_msg_type_t msg_type)
+{
+	log_t		*log;
+	log_buf_t       *log_buf; /* log buffer descriptor */
+	lrc_cbdata_t    *lrc_cbdata;
+	rec_end_t       *rec_end = NULL;    /* temporary cast for record end */
+	long		 tmp_ptr;
+	rec_hdr_t       *rec_hdr;
+
+	if(be_status != 0)
+		goto exit;
+
+	M0_ASSERT(cbinfo != NULL);
+
+	lrc_cbdata = container_of(cbinfo, lrc_cbdata_t, lrc_cbinfo);
+	log        = lrc_cbdata->lrc_log;
+	log_buf	   = &log->log_buf;
+	if(lrc_cbdata->lrc_is_refill_buf) {
+	        log_buf->ptr -= sizeof(rec_end_t);
+                rec_end       = (rec_end_t *)&log_buf->buf[log_buf->ptr];
+                tmp_ptr       = log_buf->ptr - rec_end->rec_hdr.rec_length;
+                rec_hdr       = (rec_hdr_t *)&log_buf->buf[tmp_ptr];
+	} else {
+		rec_end = lrc_cbdata->lrc_rec_end;
+                rec_hdr = (rec_hdr_t *)&log_buf->aux_buf[lrc_cbdata->lrc_tmp_ptr];
         }
 
-    /* validate whole record now that header is available */
-    if (validate_hdr(log,rec_hdr,rec_end,REVERSE))
-        return RVM_SUCCESS;
+        /* validate whole record now that header is available */
+        if(!validate_hdr(log,rec_hdr,rec_end,REVERSE)) {
+		be_status = -1;
+		msg_type  = RVM_EINTERNAL;
+	}
+exit:
+        if (cbinfo != NULL && cbinfo->bc_cb != NULL) {
+                m0_be_handler_post(cbinfo, be_status, msg_type);
+		m0_free(lrc_cbdata);
+        }
 
-no_record:
-    log_buf->ptr = -1;               /* no next record */
-    return RVM_SUCCESS;
-    }
-/* scan backward from present position at a record structure
-   returns index of offset in ptr; -1 ==> no next rec. */
-rvm_return_t scan_reverse(log,synch)
-    log_t           *log;               /* log descriptor */
-    rvm_bool_t      synch;              /* true ==> synchronization required */
-    {
-    log_buf_t       *log_buf = &log->log_buf; /* log buffer descriptor */
-    log_status_t    *status = &log->status; /* status area */
-    rec_hdr_t       *rec_hdr;           /* temporary cast for record header */
-    rvm_offset_t    offset;             /* temp for offset calculations */
-    rvm_return_t    retval;
+}
+void validate_rec_reverse_cb(struct m0_be_cbinfo *cbinfo, int  be_status,
+			      m0_be_msg_type_t msg_type)
+{
+	log_t		*log;
+	log_buf_t       *log_buf; /* log buffer descriptor */
+	log_status_t    *status; /* status area */
+	rec_end_t       *rec_end = NULL;    /* temporary cast for record end */
+	rec_hdr_t       *rec_hdr;           /* temporary cast for record header */
+	long             tmp_ptr;            /* temporary buffer ptr */
+	rvm_length_t     tmp_len;
+	rvm_offset_t     offset;             /* temp for offset calculations */
+	rvm_return_t     retval;
+    	lrc_cbdata_t    *lrc_cbdata;
+	rvm_bool_t 	 synch;
+
+	if(be_status != 0)
+	    goto exit;
+
+	lrc_cbdata    = container_of(cbinfo, lrc_cbdata_t, lrc_cbinfo);
+	log 	      = lrc_cbdata->lrc_log;
+	log_buf       = &log->log_buf;
+	status        = &log->status;
+	log_buf->ptr -= sizeof(rec_end_t);
+	synch         = lrc_cbdata->lrc_synch;
+	/* check new end marker */
+	rec_end = (rec_end_t *)&log_buf->buf[log_buf->ptr];
+	if (rec_end->rec_hdr.struct_id != rec_end_id)
+		goto no_record;             /* no next record */
+	lrc_cbdata->lrc_rec_end = rec_end;
+	/* see if record will fit in buffer */
+	if ((ROUND_TO_SECTOR_SIZE(rec_end->rec_hdr.rec_length +
+	      sizeof(rec_end_t)) + SECTOR_SIZE) <= log_buf->length) {
+		/* yes, get whole record in buffer */
+		if ((long)(log_buf->ptr - rec_end->rec_hdr.rec_length) < 0)
+		    {
+			    /* refill buffer (be sure end marker is included) */
+			    log_buf->ptr += sizeof(rec_end_t);
+			    lrc_cbdata->lrc_is_refill_buf = rvm_true;
+			    cbinfo->bc_cb = __validate_rec_reverse_cb;
+			    if ((retval=refill_buffer(log,REVERSE,synch))
+				!= RVM_SUCCESS) {
+				be_status = -1;
+				msg_type  = retval;
+				goto exit;
+			    }
+			    log_buf->ptr -= sizeof(rec_end_t);
+			    rec_end = (rec_end_t *)&log_buf->buf[log_buf->ptr];
+		    }
+		tmp_ptr = log_buf->ptr - rec_end->rec_hdr.rec_length;
+		rec_hdr = (rec_hdr_t *)&log_buf->buf[tmp_ptr];
+	}
+	else
+	{
+		/* no, save rec_end for validation & get header in aux. buffer */
+		offset = RVM_SUB_LENGTH_FROM_OFFSET(log_buf->offset,
+						    rec_end->rec_hdr.rec_length);
+		offset = RVM_ADD_LENGTH_TO_OFFSET(offset,log_buf->ptr);
 
-    assert(log_buf->ptr != -1);         /* can't reposition from this! */
+		/* check offset alignment to see if rec_end is trash */
+		lrc_cbdata->lrc_tmp_ptr = RVM_OFFSET_TO_LENGTH(offset);
 
-    /* test if scan starting from tail */
-    offset = RVM_ADD_LENGTH_TO_OFFSET(log_buf->offset,log_buf->ptr);
-    if (RVM_OFFSET_EQL(offset, status->prev_log_tail)
-        || (rvm_utlsw && RVM_OFFSET_EQL(offset, status->log_tail)))
-        return validate_rec_reverse(log,synch);
+		if (lrc_cbdata->lrc_tmp_ptr !=
+		    CHOP_TO_LENGTH(lrc_cbdata->lrc_tmp_ptr))
+		    goto no_record;             /* header alignment wrong */
 
-    /* test if at start of log & must wrap around */
-    if ((RVM_OFFSET_EQL(log_buf->offset,status->log_start)) &&
-        (log_buf->ptr == 0))
-        {
-        if ((retval=scan_wrap_reverse(log,synch)) != RVM_SUCCESS)
-            return retval;
-        return RVM_SUCCESS;             /* exit pointing to wrap marker */
+		lrc_cbdata->lrc_is_refill_buf = rvm_false;
+		cbinfo->bc_cb                 = __validate_rec_reverse_cb;
+
+		retval = load_aux_buf(log, &offset, MAX_HDR_SIZE,
+				      &lrc_cbdata->lrc_tmp_ptr, &tmp_len,
+				      synch, rvm_false);
+		if (retval != RVM_SUCCESS) {
+		     be_status = -1;
+		     msg_type  = retval;
+		     goto exit;
+		}
+
+		if (lrc_cbdata->lrc_tmp_ptr == -1)
+		    goto no_record;             /* record header not available */
+	}
+
+no_record:
+	log_buf->ptr = -1;               /* no next record */
+exit:
+	if ((retval != RVM_SUCCESS || log_buf->ptr == -1) && cbinfo != NULL &&
+	      cbinfo->bc_cb != NULL) {
+                m0_be_handler_post(cbinfo, be_status, msg_type);
         }
+}
+/* validate current record in buffer in reverse scan */
+rvm_return_t validate_rec_reverse(log_t *log, rvm_bool_t synch,
+				   struct m0_be_cbinfo *cbinfo)
+{
+	log_buf_t       *log_buf = &log->log_buf; /* log buffer descriptor */
+	log_status_t    *status = &log->status; /* status area */
+	rvm_offset_t     offset;             /* temp for offset calculations */
+	rvm_return_t    retval;
 
-    /* move to previous record end marker */
-    rec_hdr = (rec_hdr_t *)&log_buf->buf[log_buf->ptr];
-    switch (rec_hdr->struct_id)
+    	lrc_cbdata_t        *lrc_cbdata;
+	struct m0_be_cbinfo *lrc_cbinfo;
+	int 		     be_status = 0;
+	m0_be_msg_type_t     msg_type = M0_BE_SUCCESS;
+	rvm_bool_t	     wrap_end = rvm_false;
+
+        M0_ALLOC_PTR(lrc_cbdata);
+        if (lrc_cbdata == NULL) {
+                be_status = -1;
+                msg_type  = -ENOMEM;
+                goto exit;
+        }
+
+        lrc_cbdata->lrc_log   = log;
+        lrc_cbdata->lrc_synch = synch;
+        lrc_cbinfo            = &lrc_cbdata->lrc_cbinfo;
+
+	m0_be_cbinfo_copy_helper(cbinfo, lrc_cbinfo, scan_wrap_reverse_cb);
+
+    /* get previous end marker into buffer */
+    if ((long)(log_buf->ptr-sizeof(rec_end_t)) < 0)
         {
-      case trans_hdr_id: case log_seg_id:
-      case log_wrap_id:
-        break;
-      case rec_end_id:
-        if (((rec_end_t *)rec_hdr)->rec_type != trans_hdr_id)
-            {                           /* record is always in buffer */
-            log_buf->ptr -= rec_hdr->rec_length;
-            break;
-            }
-      case nv_range_id:                 /* scan past remaining ranges */
-        DO_FOREVER
-            {
-            if ((retval=scan_nv_reverse(log,synch)) != RVM_SUCCESS)
-                return retval;
-            rec_hdr = (rec_hdr_t *)&log_buf->buf[log_buf->ptr];
-            if (rec_hdr->struct_id == trans_hdr_id)
-                break;
+	    offset = RVM_ADD_LENGTH_TO_OFFSET(log_buf->offset,
+					      log_buf->ptr);
+	    if (RVM_OFFSET_EQL(offset, status->log_start)) {
+		    retval=scan_wrap_reverse(log, synch, lrc_cbinfo);
+		    wrap_end = rvm_true;
+		    goto exit;              /* exit pointing to wrap marker */
             }
-        break;
-      default:
+        else
             {
-            if (rvm_utlsw)
-                {
-                log_buf->ptr = -1;      /* utl can recover */
-                return RVM_SUCCESS;
-                }
-            assert(rvm_false);          /* not at recognizable point in log */
+		    retval=init_buffer(log, &offset, REVERSE, synch);
+        	    if (retval != RVM_SUCCESS) {
+			be_status = -1;
+			msg_type  = retval;
+			goto exit;
+		    }
             }
         }
+exit:
+       if ((retval != RVM_SUCCESS || wrap_end == rvm_true) && cbinfo != NULL &&
+            cbinfo->bc_cb != NULL) {
+                m0_be_handler_post(cbinfo, be_status, msg_type);
+        }
+        return retval;
 
-    /* validate new record and set log_buf->ptr */
-    return validate_rec_reverse(log,synch);
-    }
-/* Recovery: phase 1 -- locate current log tail from last status block
-     location */
+}
 
-/* log_wrap status update for tail location */
-static void set_wrap_status(status,rec_hdr)
-    log_status_t    *status;            /* status descriptor */
-    rec_hdr_t       *rec_hdr;           /* current record scanned in buffer */
+void scan_reverse_vrr_cb(struct m0_be_cbinfo *cbinfo, int  be_status,
+                           m0_be_msg_type_t msg_type)
 {
-    status->wrap_time = rec_hdr->timestamp;
-    status->n_special++;
-    status->tot_wrap++;
+	log_t 	      *log;
+	rvm_bool_t     synch;
+	rvm_return_t   retval;
+	lrc_cbdata_t  *lrc_cbdata;
+
+	if(be_status != 0)
+		goto exit;
+	lrc_cbdata	= container_of(cbinfo, lrc_cbdata_t, lrc_cbinfo);
+	log		= lrc_cbdata->lrc_log;
+	synch		= lrc_cbdata->lrc_synch;
+
+	/* validate new record and set log_buf->ptr */
+	retval = validate_rec_reverse(log,synch,cbinfo->bc_pcbinfo);
+	if(retval != RVM_SUCCESS) {
+		be_status = -1;
+		msg_type  = retval;
+	}
+exit:
+        if (be_status != 0 && cbinfo->bc_pcbinfo != NULL &&
+	    cbinfo->bc_pcbinfo->bc_cb != NULL) {
+                m0_be_handler_post(cbinfo->bc_pcbinfo, be_status, msg_type);
+	}
+	m0_free(lrc_cbdata);
 }
 
 void rcs_done_loop(range_chk_sum_cbdata_t *rcs_cbdata)
@@ -1170,166 +1224,1119 @@ void rcs_refill_buffer_cb(struct m0_be_cbinfo *cbinfo, int be_status,
 	if (chk_length > nv_length)
 		chk_length = nv_length;
 
-	chk_sum_temp += chk_sum(&log_buf->buf[log_buf->ptr + align_skew],
-				chk_length);
-	nv_length       -= chk_length;
-	log_buf->ptr    += (chk_length + align_skew);
-	if (nv_length == 0) {
-		done = rvm_true;
-		goto done_looping;
+	chk_sum_temp += chk_sum(&log_buf->buf[log_buf->ptr + align_skew],
+				chk_length);
+	nv_length       -= chk_length;
+	log_buf->ptr    += (chk_length + align_skew);
+	if (nv_length == 0) {
+		done = rvm_true;
+		goto done_looping;
+	}
+
+	retval = refill_buffer(log, FORWARD, synch);
+
+	if (retval != RVM_SUCCESS) {
+		be_status = -1;
+		msg_type = retval;
+		goto exit;
+	}
+
+	rcs_cbdata->rcsc_nv_length 	= nv_length;
+	rcs_cbdata->rcsc_chk_sum_temp 	= chk_sum_temp;
+
+	goto exit;
+done_looping:
+	rcs_done_loop(rcs_cbdata);
+exit:
+	if (be_status != 0 && cbinfo != NULL && cbinfo->bc_cb != NULL) {
+                m0_be_handler_post(cbinfo, be_status, msg_type);
+                m0_free(rcs_cbdata);
+        }
+}
+
+/* range checksum computation & check */
+static rvm_return_t range_chk_sum(log, nv, chk_val, synch, cbinfo)
+log_t           	*log;               /* log descriptor */
+nv_range_t      	*nv;                /* range header */
+rvm_bool_t      	*chk_val;           /* result [out] */
+rvm_bool_t      	synch;              /* true ==> synchronization required */
+struct m0_be_cbinfo 	*cbinfo;
+{
+	range_chk_sum_cbdata_t *rcs_cbdata;
+	struct m0_be_cbinfo    *rcsc_cbinfo;
+
+	log_buf_t       	*log_buf = &log->log_buf; 	/* log buffer descriptor */
+	rvm_length_t    	 nv_chk_sum;        		/* nv's check sum */
+	rvm_length_t    	 chk_sum_temp = 0;   		/* check sum temp */
+	rvm_length_t    	 nv_length;          		/* actual length of data */
+	rvm_length_t    	 chk_length;         		/* length of check summed range */
+	rvm_length_t    	 align_skew;         		/* initial alignment skew */
+	rvm_return_t    	 retval;             		/* return value */
+	rvm_bool_t		 done = rvm_false;
+
+	int			 be_status = 0;
+	m0_be_msg_type_t 	 msg_type = M0_BE_SUCCESS;
+
+	M0_ALLOC_PTR(rcs_cbdata);
+	M0_ASSERT(rcs_cbdata != NULL);
+
+	rcsc_cbinfo = &rcs_cbdata->rcsc_cbinfo;
+	rcs_cbdata->rcsc_chk_val 	= chk_val;
+	rcs_cbdata->rcsc_log 	 	= log;
+	*rcs_cbdata->rcsc_chk_val 	= rvm_false;
+
+	nv_chk_sum 	= nv->chk_sum;
+	nv_length  	= nv->length;
+	align_skew 	= BYTE_SKEW(RVM_OFFSET_TO_LENGTH(nv->offset));
+	log_buf->ptr 	+= sizeof(nv_range_t);
+
+	chk_length = log_buf->r_length - log_buf->ptr - align_skew;
+	if (chk_length > nv_length)
+		chk_length = nv_length;
+
+	chk_sum_temp += chk_sum(&log_buf->buf[log_buf->ptr + align_skew],
+				chk_length);
+	nv_length 	-= chk_length;
+	log_buf->ptr 	+= (chk_length + align_skew);
+
+	if (nv_length == 0) {
+		done = rvm_true;
+		goto done_looping;
+	}
+
+        m0_be_cbinfo_copy_helper(cbinfo, rcsc_cbinfo, rcs_refill_buffer_cb);
+
+	retval = refill_buffer(log, FORWARD, synch);
+
+	if (retval != RVM_SUCCESS) {
+		msg_type  = retval;
+		be_status = -1;
+	}
+
+	rcs_cbdata->rcsc_nv_length 	= nv_length;
+	rcs_cbdata->rcsc_chk_sum_temp 	= chk_sum_temp;
+	rcs_cbdata->rcsc_nv_chk_sum 	= nv->chk_sum;
+
+	goto exit;
+done_looping:
+	rcs_done_loop(rcs_cbdata);
+exit:
+	if (be_status != 0 && cbinfo != NULL && cbinfo->bc_cb != NULL) {
+                m0_be_handler_post(cbinfo, be_status, msg_type);
+                m0_free(rcs_cbdata);
+        }
+	return retval;
+}
+
+
+void scan_reverse_snr_loop_cb(struct m0_be_cbinfo *cbinfo, int  be_status,
+                           m0_be_msg_type_t msg_type)
+{
+	log_t 		    *log;
+	log_buf_t           *log_buf;	 /* log buffer descriptor */
+	rvm_bool_t	     synch;
+	rec_hdr_t           *rec_hdr;           /* temporary cast for record header */
+	lrc_cbdata_t        *lrc_cbdata;
+	rvm_return_t	     retval;
+
+        if(be_status != 0)
+                goto exit;
+
+        lrc_cbdata	= container_of(cbinfo, lrc_cbdata_t, lrc_cbinfo);
+        log		= lrc_cbdata->lrc_log;
+        log_buf    	= &log->log_buf;
+	synch	   	= lrc_cbdata->lrc_synch;
+	rec_hdr		= lrc_cbdata->lrc_rec_hdr;
+
+	rec_hdr = (rec_hdr_t *)&log_buf->buf[log_buf->ptr];
+	if (rec_hdr->struct_id == trans_hdr_id) {
+		/* Loop Terminates */
+		scan_reverse_vrr_cb(cbinfo, be_status, msg_type);
+	}
+	else if ((retval=scan_nv_reverse(log,synch,cbinfo)) != RVM_SUCCESS) {
+		be_status = -1;
+		msg_type  = retval;
+	}
+exit:
+	if(be_status != 0 &&cbinfo->bc_pcbinfo != NULL &&
+	   cbinfo->bc_pcbinfo->bc_cb != NULL) {
+      		m0_be_handler_post(cbinfo->bc_pcbinfo, be_status, msg_type);
+		m0_free(lrc_cbdata);
+        }
+}
+
+void scan_reverse_cb(struct m0_be_cbinfo *cbinfo, int  be_status,
+                           m0_be_msg_type_t msg_type)
+{
+	log_t 		    *log;
+	log_buf_t           *log_buf;	 /* log buffer descriptor */
+	log_status_t        *status; 	 /* status area */
+	rvm_bool_t	     synch;
+	rvm_bool_t	     do_post_parent =rvm_false;
+	lrc_cbdata_t        *lrc_cbdata;
+	rvm_return_t	     retval;
+
+	if(be_status != 0)
+		goto exit;
+
+	lrc_cbdata = container_of(cbinfo, lrc_cbdata_t, lrc_cbinfo);
+
+	log	= lrc_cbdata->lrc_log;
+	synch 	= lrc_cbdata->lrc_synch;
+	log_buf = &log->log_buf;
+	status  = &log->status;
+	/* test if at start of log & must wrap around */
+	if ((RVM_OFFSET_EQL(log_buf->offset,status->log_start)) &&
+	(log_buf->ptr == 0))
+	{
+		retval=scan_wrap_reverse(log, synch, cbinfo->bc_pcbinfo);
+		goto exit_failure;
+	} else {
+		do_post_parent = rvm_true;
+		cbinfo->bc_cb =  scan_reverse_snr_cb;
+	}
+exit:
+        if ((be_status != 0 || do_post_parent) && cbinfo != NULL && cbinfo->bc_cb != NULL) {
+	        if (do_post_parent)
+			m0_be_handler_post(cbinfo, be_status, msg_type);
+	}
+		return;
+exit_failure:
+	m0_free(lrc_cbdata);
+}
+
+void scan_reverse_snr_cb(struct m0_be_cbinfo *cbinfo, int  be_status,
+                           m0_be_msg_type_t msg_type)
+{
+	log_t 		    *log;
+	log_buf_t           *log_buf;	 /* log buffer descriptor */
+	rvm_bool_t	     synch;
+	rec_hdr_t           *rec_hdr;           /* temporary cast for record header */
+	lrc_cbdata_t        *lrc_cbdata;
+	rvm_return_t	     retval = RVM_EINTERNAL;
+
+	if(be_status != 0)
+		goto exit;
+
+	lrc_cbdata = container_of(cbinfo, lrc_cbdata_t, lrc_cbinfo);
+	log	   = lrc_cbdata->lrc_log;
+	log_buf	   = &log->log_buf;
+	synch      = lrc_cbdata->lrc_synch;
+	/* move to previous record end marker */
+	rec_hdr = (rec_hdr_t *)&log_buf->buf[log_buf->ptr];
+	lrc_cbdata->lrc_rec_hdr = rec_hdr;
+	cbinfo->bc_cb = scan_reverse_vrr_cb;
+
+	switch (rec_hdr->struct_id)
+	{
+		case trans_hdr_id:
+		case log_seg_id:
+		case log_wrap_id:
+			break;
+		case rec_end_id:
+			if (((rec_end_t *)rec_hdr)->rec_type !=
+			       trans_hdr_id) {
+				 /* record is always in buffer */
+				log_buf->ptr -= rec_hdr->rec_length;
+				 break;
+			}
+		case nv_range_id:                 /* scan past remaining ranges */
+			cbinfo->bc_cb = scan_reverse_snr_loop_cb;
+		    	if ((retval=scan_nv_reverse(log,synch,cbinfo)) !=
+			      RVM_SUCCESS) {
+				be_status = -1;
+				msg_type  = retval;
+			}
+			goto exit;
+		default:
+			{
+			    if (rvm_utlsw)
+				{
+					log_buf->ptr = -1;      /* utl can recover */
+					goto exit;
+				}
+                            /* not at recognizable point in log */
+			    assert(rvm_false);
+			}
+	}
+
+	if(cbinfo != NULL && cbinfo->bc_cb != NULL)
+		m0_be_handler_post(cbinfo,be_status, msg_type);
+	return;
+exit:
+	if ((be_status != 0  || log_buf->ptr == -1) && cbinfo->bc_pcbinfo !=
+	      NULL && cbinfo->bc_pcbinfo->bc_cb != NULL) {
+                        m0_be_handler_post(cbinfo->bc_pcbinfo, be_status, msg_type);
+			m0_free(lrc_cbdata);
+        }
+
+}
+
+/* scan backward from present position at a record structure
+   returns index of offset in ptr; -1 ==> no next rec. */
+rvm_return_t scan_reverse(log, synch, cbinfo)
+	log_t 			*log;
+	rvm_bool_t 		 synch;
+	struct m0_be_cbinfo 	*cbinfo;
+{
+	log_buf_t       *log_buf = &log->log_buf; /* log buffer descriptor */
+	log_status_t    *status = &log->status; /* status area */
+	rvm_offset_t    offset;             /* temp for offset calculations */
+	rvm_return_t    retval = RVM_SUCCESS;
+
+	lrc_cbdata_t   		*lrc_cbdata;
+	struct m0_be_cbinfo	*lrc_cbinfo;
+	m0_be_msg_type_t	 msg       =  M0_BE_SUCCESS;
+	int			 be_status = 0;
+	assert(log_buf->ptr != -1);         /* can't reposition from this! */
+
+	M0_ALLOC_PTR(lrc_cbdata);
+        if (lrc_cbdata == NULL) {
+                be_status = -1;
+                msg    = -ENOMEM;
+                goto exit;
+        }
+        /* Prepare cbinfo. */
+        lrc_cbdata->lrc_log   = log;
+        lrc_cbdata->lrc_synch = synch;
+        lrc_cbinfo          = &lrc_cbdata->lrc_cbinfo;
+	m0_be_cbinfo_copy_helper(cbinfo, lrc_cbinfo, NULL);
+
+	/* test if scan starting from tail */
+	offset = RVM_ADD_LENGTH_TO_OFFSET(log_buf->offset,log_buf->ptr);
+
+	if (RVM_OFFSET_EQL(offset,status->prev_log_tail)
+	|| (rvm_utlsw && RVM_OFFSET_EQL(offset,status->log_tail))) {
+		lrc_cbinfo->bc_cb = scan_reverse_cb;
+		retval = validate_rec_reverse(log, synch, lrc_cbinfo);
+		if(retval != RVM_SUCCESS) {
+	                be_status = -1;
+        	        msg    = -ENOMEM;
+		}
+		goto exit;
+	}
+	scan_reverse_cb(lrc_cbinfo, be_status, msg);
+
+exit:
+	if (be_status != 0 && cbinfo->bc_pcbinfo != NULL &&
+            cbinfo->bc_pcbinfo->bc_cb != NULL) {
+                m0_be_handler_post(cbinfo->bc_pcbinfo, be_status, msg);
+                m0_free(lrc_cbdata);
+        }
+	return retval;
+
+}
+
+
+
+
+void scan_nv_reverse_cb(cbinfo, status, msg)
+	struct m0_be_cbinfo	*cbinfo;
+	int			 status;
+	m0_be_msg_type_t	 msg;
+{
+	lrc_cbdata_t	*lrc_cbdata;
+	log_t		*log;
+	log_buf_t	*log_buf;
+	rec_hdr_t	*rec_hdr;
+
+	lrc_cbdata = container_of(cbinfo, lrc_cbdata_t, lrc_cbinfo);
+	log	   = lrc_cbdata->lrc_log;
+	log_buf	   = &log->log_buf;
+
+	/* exit pointing to new header */
+	rec_hdr = (rec_hdr_t *)&log_buf->buf[log_buf->ptr];
+	if (rec_hdr->struct_id == trans_hdr_id) {
+		goto exit;
+	}
+
+	assert(rec_hdr->struct_id == nv_range_id);
+exit:
+	if (cbinfo->bc_pcbinfo != NULL && cbinfo->bc_pcbinfo->bc_cb != NULL) {
+	    	m0_be_handler_post(cbinfo->bc_pcbinfo, status, msg);
+	}
+	m0_free(lrc_cbdata);
+}
+
+/* get previous new value range by reverse scan of transaction record
+   ptr points to previous range header; exits with range in buffer */
+rvm_return_t scan_nv_reverse(log, synch, cbinfo)
+    log_t          	*log;           /* log descriptor */
+    rvm_bool_t      	 synch;         /* true ==> synchronization required */
+    struct m0_be_cbinfo *cbinfo;
+{
+	lrc_cbdata_t		*lrc_cbdata;
+	struct m0_be_cbinfo	*lrc_cbinfo;
+	log_buf_t       	*log_buf = &log->log_buf;
+	rec_hdr_t       	*rec_hdr;
+	long             	 len = 0;
+	rvm_offset_t     	 offset;
+	rvm_return_t        	 retval = RVM_SUCCESS;
+	int			 be_status = 0;
+	m0_be_msg_type_t	 msg = M0_BE_SUCCESS;
+
+	printf("\nfunction %s\n", __FUNCTION__);
+	M0_ALLOC_PTR(lrc_cbdata);
+        if (lrc_cbdata == NULL) {
+                be_status = -1;
+                msg       = -ENOMEM;
+                goto exit;
+        }
+
+	lrc_cbdata->lrc_log   =  log;
+	lrc_cbinfo	      = &lrc_cbdata->lrc_cbinfo;
+	/******************* UNCOMMENT THIS ***************************************/
+	/*m0_be_cbinfo_copy_helper(cbinfo, lrc_cbinfo, scan_nv_reverse_cb);*/
+
+	/* get new header position */
+	rec_hdr = (rec_hdr_t *)&log_buf->buf[log_buf->ptr];
+	switch (rec_hdr->struct_id) {
+		case rec_end_id:
+			len = ((rec_end_t *)rec_hdr)->sub_rec_len;
+			break;
+
+		case nv_range_id:
+			len = ((nv_range_t *)rec_hdr)->sub_rec_len;
+			break;
+
+		default:
+			assert(rvm_false);   /* trouble -- log damage? */
+	}
+
+	/* see if new header is entirely within buffer */
+	if ((log_buf->ptr - len) < 0) {
+		/* no, refill buffer according to length of data */
+		if ((len - sizeof(nv_range_t)) <= NV_LOCAL_MAX){
+			/* small, get data into buffer */
+			retval = refill_buffer(log, REVERSE, synch, lrc_cbinfo);
+			if (retval != RVM_SUCCESS) {
+				be_status = -1;
+				msg	  = retval;
+				goto exit;
+			}
+
+		    	log_buf->ptr -= len;
+			goto exit;
+		} else {
+			/* large, skip data for now */
+			offset = RVM_ADD_LENGTH_TO_OFFSET(log_buf->offset,
+				 			 (log_buf->ptr +
+							  sizeof(nv_range_t)));
+
+			offset = RVM_SUB_LENGTH_FROM_OFFSET(offset,len);
+				/****************************** pass lrc_cbinfo ********************////////////
+			retval = init_buffer(log, &offset, REVERSE, synch);
+			/*lrc_cbinfo);*/
+			if (retval != RVM_SUCCESS) {
+				be_status = -1;
+				msg	  = retval;
+				goto exit;
+			}
+			log_buf->ptr -= sizeof(nv_range_t);
+			/********* make it goto exit. *******************************************/
+			goto temporary_exit;
+		}
+	} else
+		log_buf->ptr -= len;
+temporary_exit:
+	scan_nv_reverse_cb(lrc_cbinfo, be_status, msg);
+
+exit:
+	if (be_status != 0 && cbinfo != NULL && cbinfo->bc_cb != NULL) {
+	    	m0_be_handler_post(cbinfo, be_status, msg);
+		m0_free(lrc_cbdata);
+	}
+
+	return retval;
+}
+
+void vrf_refill_buffer_cb(cbinfo, status, msg)
+	struct m0_be_cbinfo	*cbinfo;
+	int			 status;
+	m0_be_msg_type_t	 msg;
+{
+	lrc_cbdata_t		*lrc_cbdata;
+	log_t			*log;
+	log_buf_t       	*log_buf;
+	rec_hdr_t       	*rec_hdr;
+	rec_end_t       	*rec_end = NULL;
+	long            	 tmp_ptr;
+
+	printf("\nfunction %s\n", __FUNCTION__);
+	if (status != 0)
+		goto exit;
+
+	lrc_cbdata =   container_of(cbinfo, lrc_cbdata_t, lrc_cbinfo);
+	log	   =   lrc_cbdata->lrc_log;
+	log_buf	   =  &log->log_buf;
+
+	rec_hdr    =  (rec_hdr_t *)&log_buf->buf[log_buf->ptr];
+	tmp_ptr    =   log_buf->ptr + rec_hdr->rec_length;
+	rec_end    =  (rec_end_t *)&log_buf->buf[tmp_ptr];
+
+	if (!validate_hdr(log, rec_hdr, rec_end, FORWARD)) {
+		status = -1;
+		msg = M0_BE_INTERNAL;
+	}
+
+exit:
+	if (cbinfo->bc_pcbinfo != NULL && cbinfo->bc_pcbinfo->bc_cb != NULL) {
+	    	m0_be_handler_post(cbinfo->bc_pcbinfo, status, msg);
+	}
+	m0_free(lrc_cbdata);
+}
+
+void vrf_load_aux_buf_cb(cbinfo, status, msg)
+	struct m0_be_cbinfo	*cbinfo;
+	int			 status;
+	m0_be_msg_type_t	 msg;
+{
+	lrc_cbdata_t		*lrc_cbdata;
+	log_t			*log;
+	log_buf_t       	*log_buf;
+	rec_hdr_t       	*rec_hdr;
+	rec_end_t       	*rec_end = NULL;
+	long            	 tmp_ptr;
+
+	printf("\nfunction %s\n", __FUNCTION__);
+	if (status != 0)
+		goto exit;
+
+	lrc_cbdata =  container_of(cbinfo, lrc_cbdata_t, lrc_cbinfo);
+	log	   =  lrc_cbdata->lrc_log;
+	log_buf	   = &log->log_buf;
+	tmp_ptr	   =  lrc_cbdata->lrc_tmp_ptr;
+
+	/* check header type */
+	rec_hdr = (rec_hdr_t *)&log_buf->buf[log_buf->ptr];
+
+	rec_end = (rec_end_t *)&log_buf->aux_buf[tmp_ptr];
+	if (!validate_hdr(log, rec_hdr, rec_end, FORWARD)) {
+		status = -1;
+		msg    = M0_BE_INTERNAL;
+	}
+exit:
+	if (cbinfo->bc_pcbinfo != NULL && cbinfo->bc_pcbinfo->bc_cb != NULL) {
+	    	m0_be_handler_post(cbinfo->bc_pcbinfo, status, msg);
+	}
+	m0_free(lrc_cbdata);
+
+}
+
+void validate_rec_forward_cb(cbinfo, status, msg)
+	struct m0_be_cbinfo	*cbinfo;
+	int			 status;
+	m0_be_msg_type_t	 msg;
+{
+	lrc_cbdata_t		*lrc_cbdata;
+	log_t			*log;
+	log_buf_t       	*log_buf;
+	rec_hdr_t       	*rec_hdr;
+	rec_end_t       	*rec_end = NULL;
+	rvm_offset_t    	 end_offset;
+	rvm_return_t    	 retval;
+	long            	 tmp_ptr;
+	rvm_length_t    	 tmp_len;
+	rvm_bool_t		 synch;
+	rvm_bool_t		 val_rec_fwd_done = rvm_false;
+
+	printf("\nfunction %s\n", __FUNCTION__);
+
+	if (status != 0)
+		goto exit;
+
+	lrc_cbdata =  container_of(cbinfo, lrc_cbdata_t, lrc_cbinfo);
+	log	   =  lrc_cbdata->lrc_log;
+	synch	   =  lrc_cbdata->lrc_synch;
+	log_buf	   = &log->log_buf;
+
+	/* check header type */
+	rec_hdr = (rec_hdr_t *)&log_buf->buf[log_buf->ptr];
+
+	if (rec_hdr->struct_id == log_wrap_id) {
+		val_rec_fwd_done = rvm_true;
+		goto validate;         /* skip rec_end stuff for wrap */
+	}
+
+	if (!chk_hdr(log, rec_hdr, NULL, FORWARD)) {
+		val_rec_fwd_done = rvm_true;
+		goto no_record;                 /* no next record */
+	}
+
+	/* see if record will fit in buffer */
+	if ((ROUND_TO_SECTOR_SIZE(rec_hdr->rec_length + sizeof(rec_end_t)) +
+	     SECTOR_SIZE) <= log_buf->length) {
+
+		/* yes, get whole record in buffer */
+		if ((log_buf->ptr + rec_hdr->rec_length + sizeof(rec_end_t)) >
+		    log_buf->length) {
+
+			/* refill buffer */
+			cbinfo->bc_cb = vrf_refill_buffer_cb;
+			retval = refill_buffer(log, FORWARD, synch, cbinfo);
+			if (retval != RVM_SUCCESS) {
+				status = -1;
+				msg    = retval;
+			}
+			goto exit;
+		    }
+
+		 tmp_ptr = log_buf->ptr + rec_hdr->rec_length;
+		 lrc_cbdata->lrc_tmp_ptr = tmp_ptr;
+		 rec_end = (rec_end_t *)&log_buf->buf[tmp_ptr];
+	} else {
+		/*
+		 * no, won't fit -- read rec_end into aux buffer for validation
+		 */
+		end_offset = RVM_ADD_LENGTH_TO_OFFSET(log_buf->offset,
+				 		      (log_buf->ptr +
+						      rec_hdr->rec_length));
+
+		/* check offset alignment to see if rec_hdr is trash */
+		tmp_ptr = RVM_OFFSET_TO_LENGTH(end_offset);
+
+		if (tmp_ptr != CHOP_TO_LENGTH(tmp_ptr)) {
+			val_rec_fwd_done = rvm_true;
+			goto no_record;
+		}
+
+		cbinfo->bc_cb 		= vrf_load_aux_buf_cb;
+		lrc_cbdata->lrc_tmp_ptr = tmp_ptr;
+
+		retval = load_aux_buf(log, &end_offset, sizeof(rec_end_t),
+				      &tmp_ptr, &tmp_len, synch, rvm_false,
+				      cbinfo);
+
+		if (retval != RVM_SUCCESS) {
+			status = -1;
+			msg    = retval;
+		}
+
+		/*
+		 * Is needed here itself, as it is updated directly in the
+		 * non-blocking part of load_aux_buf.
+		 */
+		if (tmp_ptr == -1) {
+			val_rec_fwd_done = rvm_true;
+			goto no_record;   /* record end not available */
+		}
+
+		goto exit;
+	}
+
+	/* validate whole record now that end is available */
+validate:
+	if (!validate_hdr(log, rec_hdr, rec_end, FORWARD)) {
+		status = -1;
+		msg    = M0_BE_INTERNAL;
+		goto exit;
+	}
+
+no_record:
+	/* no next record */
+	log_buf->ptr = -1;
+
+exit:
+	if ((val_rec_fwd_done || status != 0) && cbinfo->bc_pcbinfo != NULL &&
+	    cbinfo->bc_pcbinfo->bc_cb != NULL) {
+	    	m0_be_handler_post(cbinfo->bc_pcbinfo, status, msg);
+		m0_free(lrc_cbdata);
+	}
+}
+
+
+
+/* validate record in buffer in forward scan */
+rvm_return_t validate_rec_forward(log, synch, cbinfo)
+    log_t           	*log;      /* log descriptor */
+    rvm_bool_t           synch;    /* true ==> synchronization required */
+    struct m0_be_cbinfo *cbinfo;
+{
+	lrc_cbdata_t		*lrc_cbdata;
+	struct m0_be_cbinfo 	*lrc_cbinfo;
+	log_buf_t       	*log_buf = &log->log_buf;
+	rvm_offset_t    	 end_offset;
+	rvm_return_t    	 retval;
+	int			 be_status = 0;
+	m0_be_msg_type_t	 msg 	   = M0_BE_SUCCESS;
+
+	printf("\nfunction %s\n", __FUNCTION__);
+
+	M0_ALLOC_PTR(lrc_cbdata);
+        if (lrc_cbdata == NULL) {
+                be_status = -1;
+                msg       = -ENOMEM;
+                goto exit;
+        }
+
+	lrc_cbdata->lrc_log   =  log;
+	lrc_cbdata->lrc_synch =  synch;
+	lrc_cbinfo	      = &lrc_cbdata->lrc_cbinfo;
+	m0_be_cbinfo_copy_helper(cbinfo, lrc_cbinfo, validate_rec_forward_cb);
+
+	/* see if next header is entirely within buffer */
+	if ((log_buf->ptr + MAX_HDR_SIZE) > log_buf->r_length) {
+		/* no, re-init buffer */
+		end_offset = RVM_ADD_LENGTH_TO_OFFSET(log_buf->offset,
+						      log_buf->ptr);
+
+		retval = init_buffer(log, &end_offset, FORWARD, synch,
+				     lrc_cbinfo);
+		if (retval != RVM_SUCCESS) {
+			be_status = -1;
+			msg 	  = retval;
+		}
+		goto exit;
+	}
+
+	validate_rec_forward_cb(lrc_cbinfo, be_status, msg);
+exit:
+	if (be_status != 0  && cbinfo != NULL &&
+	    cbinfo->bc_cb != NULL) {
+	    	m0_be_handler_post(cbinfo, be_status, msg);
+		m0_free(lrc_cbdata);
+	}
+
+	return retval;
+}
+
+void sf_scan_nv_forward_cb(cbinfo, status, msg)
+	struct m0_be_cbinfo	*cbinfo;
+	int			 status;
+	m0_be_msg_type_t	 msg;
+{
+	lrc_cbdata_t		*lrc_cbdata;
+	log_t			*log;
+	log_buf_t       	*log_buf;
+	rec_hdr_t       	*rec_hdr;      /* cast for next record hdr */
+	rvm_return_t     	 retval;
+	rvm_bool_t		 synch;
+	rvm_bool_t		 loop_continue = rvm_false;
+	long 		 	 ptr;
+
+	printf("\nfunction %s \n", __FUNCTION__);
+
+	if (status != 0)
+		goto exit;
+
+	lrc_cbdata    =  container_of(cbinfo, lrc_cbdata_t, lrc_cbinfo);
+	log	      =  lrc_cbdata->lrc_log;
+	synch	      =  lrc_cbdata->lrc_synch;
+	log_buf       = &log->log_buf;
+	ptr	      = log_buf->ptr;
+	rec_hdr	      = (rec_hdr_t *)&log_buf->buf[ptr];
+	cbinfo->bc_cb = sf_scan_nv_forward_cb;
+
+	switch (rec_hdr->struct_id) {
+		case nv_range_id:
+			ptr          += rec_hdr->rec_length;
+			log_buf->ptr  = ptr;
+			loop_continue = rvm_true;
+			break;
+
+		case rec_end_id:
+			/* breaks loop */
+			ptr += sizeof(rec_end_t);
+			log_buf->ptr = ptr;
+			loop_continue = rvm_false;
+			break;
+
+		default:
+			/* breaks loop */
+			loop_continue = rvm_false;
+			break;
+	}
+
+	/* If loop has ended, move on to validate_rec_forward. */
+	if (loop_continue) {
+		retval = scan_nv_forward(log, synch, cbinfo);
+		if (retval != RVM_SUCCESS) {
+			status = -1;
+			msg = retval;
+			goto exit;
+		}
+	} else {
+		retval = validate_rec_forward(log, synch, cbinfo->bc_pcbinfo);
+		if (retval != RVM_SUCCESS) {
+			status = -1;
+			msg = retval;
+			goto exit;
+		}
+		m0_free(lrc_cbdata);
+	}
+
+exit:
+	if (status != 0 && cbinfo->bc_pcbinfo != NULL &&
+	    cbinfo->bc_pcbinfo->bc_cb != NULL) {
+	    	m0_be_handler_post(cbinfo->bc_pcbinfo, status, msg);
+		m0_free(lrc_cbdata);
+	}
+}
+
+void sf_init_buffer_cb(cbinfo, status, msg)
+	struct m0_be_cbinfo	*cbinfo;
+	int			 status;
+	m0_be_msg_type_t	 msg;
+{
+	lrc_cbdata_t		*lrc_cbdata;
+	log_t			*log;
+	rvm_return_t     	 retval;
+	rvm_bool_t		 synch;
+
+	printf("\nfunction %s \n", __FUNCTION__);
+
+	if (status != 0)
+		goto exit;
+
+	lrc_cbdata    =  container_of(cbinfo, lrc_cbdata_t, lrc_cbinfo);
+	log	      =  lrc_cbdata->lrc_log;
+	synch	      =  lrc_cbdata->lrc_synch;
+
+	retval = validate_rec_forward(log, synch, cbinfo->bc_pcbinfo);
+
+	if (retval != RVM_SUCCESS) {
+		status = -1;
+		msg = retval;
+		goto exit;
+	}
+
+	m0_free(lrc_cbdata);
+exit:
+	if (status != 0 && cbinfo->bc_pcbinfo != NULL &&
+	    cbinfo->bc_pcbinfo->bc_cb != NULL) {
+	    	m0_be_handler_post(cbinfo->bc_pcbinfo, status, msg);
+		m0_free(lrc_cbdata);
+	}
+}
+
+
+/* scan forward from present position at a record structure
+   returns updated offset indexed by ptr; -1 ==> no next rec. */
+rvm_return_t scan_forward(log, synch, cbinfo)
+    log_t                 *log;        /* log descriptor */
+    rvm_bool_t             synch;      /* true ==> synchronization required */
+    struct m0_be_cbinfo	  *cbinfo;
+{
+	lrc_cbdata_t		*lrc_cbdata;
+	struct m0_be_cbinfo	*lrc_cbinfo;
+	log_buf_t       	*log_buf = &log->log_buf;
+	rec_hdr_t       	*rec_hdr;      /* cast for next record hdr */
+	rvm_return_t     	 retval;
+	rvm_bool_t		 is_scan_fwd_done = rvm_false;
+	rvm_bool_t		 call_validate 	  = rvm_false;
+	int			 be_status	  = 0;
+	m0_be_msg_type_t	 msg		  = M0_BE_SUCCESS;
+
+	printf("\nfunction %s \n", __FUNCTION__);
+
+	M0_ALLOC_PTR(lrc_cbdata);
+        if (lrc_cbdata == NULL) {
+                be_status = -1;
+                msg       = -ENOMEM;
+                goto exit;
+        }
+
+	lrc_cbdata->lrc_log   =  log;
+	lrc_cbdata->lrc_synch =  synch;
+	lrc_cbinfo	      = &lrc_cbdata->lrc_cbinfo;
+
+	assert(log_buf->ptr != -1);         /* invalid position */
+	rec_hdr = (rec_hdr_t *)&log_buf->buf[log_buf->ptr];
+
+	switch (rec_hdr->struct_id) {
+		case trans_hdr_id:
+
+		case log_seg_id:
+			log_buf->ptr += (rec_hdr->rec_length +
+					 sizeof(rec_end_t));
+			call_validate = rvm_true;
+			break;
+
+		case rec_end_id:
+			log_buf->ptr += sizeof(rec_end_t);
+			call_validate = rvm_true;
+			break;
+
+		case nv_range_id:        /* scan past remaining ranges */
+			/* loop begin { */
+			m0_be_cbinfo_copy_helper(cbinfo, lrc_cbinfo,
+						 sf_scan_nv_forward_cb);
+			retval = scan_nv_forward(log, synch, lrc_cbinfo);
+
+			if (retval != RVM_SUCCESS) {
+				be_status = -1;
+				msg	  = retval;
+			}
+			/* loop end } */
+			break;
+
+		case log_wrap_id:
+			m0_be_cbinfo_copy_helper(cbinfo, lrc_cbinfo,
+						 sf_init_buffer_cb);
+			retval = init_buffer(log, &log->status.log_start,
+					     FORWARD, synch, lrc_cbinfo);
+
+			if (retval != RVM_SUCCESS) {
+				be_status = -1;
+				msg	  = retval;
+			}
+			break;
+
+		default:
+			if (rvm_utlsw) {
+			    	log_buf->ptr 	 = -1;
+				is_scan_fwd_done = rvm_true;
+				call_validate	 = rvm_false;
+				/*return RVM_SUCCESS;*/
+			}
+			assert(rvm_false);      /* unknown record type */
+	}
+
+	if (call_validate) {
+		/* Validate next record */
+		retval = validate_rec_forward(log, synch, cbinfo->bc_pcbinfo);
+		if (retval != RVM_SUCCESS) {
+			be_status = -1;
+			msg	  = retval;
+		}
+		m0_free(lrc_cbdata);
+		goto exit_return;
+	}
+
+exit:
+	if ((be_status != 0 || is_scan_fwd_done) && cbinfo != NULL &&
+	    cbinfo->bc_cb != NULL) {
+	    	m0_be_handler_post(cbinfo, be_status, msg);
+		m0_free(lrc_cbdata);
+	}
+
+exit_return:
+	/*return validate_rec_forward(log, synch, cbinfo->bc_pcbinfo);*/
+	return retval;
+}
+
+/* Recovery: phase 1 -- locate current log tail from last status block
+     location */
+
+/* log_wrap status update for tail location */
+static void set_wrap_status(status,rec_hdr)
+    log_status_t    *status;            /* status descriptor */
+    rec_hdr_t       *rec_hdr;           /* current record scanned in buffer */
+    {
+    status->wrap_time = rec_hdr->timestamp;
+    status->n_special++;
+    status->tot_wrap++;
+    }
+
+/* Last call in the set trans status chain. */
+void set_trans_status_cb(cbinfo, be_status, msg)
+	struct m0_be_cbinfo	*cbinfo;
+	int			 be_status;
+	m0_be_msg_type_t	 msg;
+{
+	lrc_cbdata_t	*lrc_cbdata;
+	log_t		*log;
+	log_status_t	*status;
+	trans_hdr_t	*trans_hdr;
+
+	printf("\n function %s \n", __FUNCTION__);
+	if (be_status != 0)
+		goto exit;
+
+	lrc_cbdata =  container_of(cbinfo, lrc_cbdata_t, lrc_cbinfo);
+	log	   =  lrc_cbdata->lrc_log;
+	trans_hdr  = &lrc_cbdata->lrc_trans_hdr;
+	status     = &log->status;
+
+	/* be sure all ranges are present */
+	if (lrc_cbdata->lrc_num_ranges != trans_hdr->num_ranges) {
+		log->log_buf.ptr = -1;
+		goto exit;                /* incomplete */
+	}
+
+	/* transaction complete, update status */
+	status->last_uname = trans_hdr->uname;
+	if (trans_hdr->flags & FLUSH_FLAG)
+		status->n_flush_commit++;
+	else
+		status->n_no_flush_commit++;
+
+	if (((trans_hdr->flags & FIRST_ENTRY_FLAG) != 0) &&
+	    ((trans_hdr->flags & LAST_ENTRY_FLAG)  == 0))
+		status->n_split++;
+exit:
+	if(cbinfo->bc_pcbinfo != NULL &&  cbinfo->bc_pcbinfo->bc_cb != NULL) {
+		m0_be_handler_post(cbinfo->bc_pcbinfo, be_status, msg);
+	}
+	m0_free(lrc_cbdata);
+}
+
+void sts_range_chk_sum_cb(cbinfo, be_status, msg)
+	struct m0_be_cbinfo	*cbinfo;
+	int			 be_status;
+	m0_be_msg_type_t	 msg;
+{
+	lrc_cbdata_t	*lrc_cbdata;
+	log_t		*log;
+	rvm_bool_t       chk_val;
+	rvm_return_t	 retval;
+
+	printf("\n function %s \n", __FUNCTION__);
+	if (be_status != 0)
+		goto exit;
+
+	lrc_cbdata = container_of(cbinfo, lrc_cbdata_t, lrc_cbinfo);
+	log	   = lrc_cbdata->lrc_log;
+	chk_val	   = lrc_cbdata->lrc_chk_val;
+
+	if (chk_val != rvm_true) {
+		log->log_buf.ptr = -1;
+		goto exit; /* check sum failure */
 	}
 
-	retval = refill_buffer(log, FORWARD, synch);
+	lrc_cbdata->lrc_num_ranges++;
 
+	cbinfo->bc_cb = sts_nv_fwd_cb;
+	retval 	      = scan_nv_forward(log, NO_SYNCH, cbinfo);
 	if (retval != RVM_SUCCESS) {
 		be_status = -1;
-		msg_type = retval;
-		goto exit;
+		msg 	  =  retval;
 	}
 
-	rcs_cbdata->rcsc_nv_length = nv_length;
-	rcs_cbdata->rcsc_chk_sum_temp = chk_sum_temp;
-
-	goto exit;
-done_looping:
-	rcs_done_loop(rcs_cbdata);
 exit:
-	if (be_status != 0 && cbinfo != NULL && cbinfo->bc_cb != NULL) {
-                m0_be_handler_post(cbinfo, be_status, msg_type);
-                m0_free(rcs_cbdata);
-        }
+	if ((!chk_val || be_status != 0) && cbinfo->bc_pcbinfo != NULL &&
+	   cbinfo->bc_pcbinfo->bc_cb != NULL) {
+		m0_be_handler_post(cbinfo->bc_pcbinfo, be_status, msg);
+		m0_free(lrc_cbdata);
+	}
 }
 
-/* range checksum computation & check */
-static rvm_return_t range_chk_sum(log, nv, chk_val, synch, cbinfo)
-log_t           	*log;               /* log descriptor */
-nv_range_t      	*nv;                /* range header */
-rvm_bool_t      	*chk_val;           /* result [out] */
-rvm_bool_t      	synch;              /* true ==> synchronization required */
-struct m0_be_cbinfo 	*cbinfo;
+void sts_nv_fwd_cb(cbinfo, be_status, msg)
+	struct m0_be_cbinfo	*cbinfo;
+	int			 be_status;
+	m0_be_msg_type_t	 msg;
 {
-	range_chk_sum_cbdata_t *rcs_cbdata;
-	struct m0_be_cbinfo    *rcsc_cbinfo;
-
-	log_buf_t       	*log_buf = &log->log_buf; 	/* log buffer descriptor */
-	rvm_length_t    	 nv_chk_sum;        		/* nv's check sum */
-	rvm_length_t    	 chk_sum_temp = 0;   		/* check sum temp */
-	rvm_length_t    	 nv_length;          		/* actual length of data */
-	rvm_length_t    	 chk_length;         		/* length of check summed range */
-	rvm_length_t    	 align_skew;         		/* initial alignment skew */
-	rvm_return_t    	 retval;             		/* return value */
-	rvm_bool_t		 done = rvm_false;
-
-	int			 be_status = 0;
-	m0_be_msg_type_t 	 msg_type = M0_BE_SUCCESS;
-
-	M0_ALLOC_PTR(rcs_cbdata);
-	M0_ASSERT(rcs_cbdata != NULL);
-
-	rcsc_cbinfo = &rcs_cbdata->rcsc_cbinfo;
-	rcs_cbdata->rcsc_chk_val 	= chk_val;
-	rcs_cbdata->rcsc_log 	 	= log;
-	*rcs_cbdata->rcsc_chk_val 	= rvm_false;
-
-	nv_chk_sum 	= nv->chk_sum;
-	nv_length  	= nv->length;
-	align_skew 	= BYTE_SKEW(RVM_OFFSET_TO_LENGTH(nv->offset));
-	log_buf->ptr 	+= sizeof(nv_range_t);
+	lrc_cbdata_t		*lrc_cbdata;
+	log_t			*log;
+	log_buf_t       	*log_buf;
+	log_status_t    	*status;
+	nv_range_t      	*nv;                /* range header */
+	trans_hdr_t     	*trans_hdr;          /* copy of header */
+    	rec_hdr_t        	*rec_hdr;   /* current trans record in buffer */
+	rvm_bool_t      	*chk_val;
+	long            	 num_ranges     = 0;   /* range scan counter */
+	rvm_bool_t      	 loop_done      = rvm_false;
+	rvm_bool_t      	 is_bad_record  = rvm_false;
+	rvm_return_t    	 retval	        = RVM_SUCCESS;
+
+	printf("\n function %s\n", __FUNCTION__);
+	if (be_status != 0)
+		goto exit;
 
-	chk_length = log_buf->r_length - log_buf->ptr - align_skew;
-	if (chk_length > nv_length)
-		chk_length = nv_length;
+	lrc_cbdata =  container_of(cbinfo, lrc_cbdata_t, lrc_cbinfo);
+	log	   =  lrc_cbdata->lrc_log;
+	num_ranges =  lrc_cbdata->lrc_num_ranges;
+	chk_val    = &lrc_cbdata->lrc_chk_val;
+	trans_hdr  = &lrc_cbdata->lrc_trans_hdr;
+	log_buf	   = &log->log_buf;
+	status	   = &log->status;
 
-	chk_sum_temp += chk_sum(&log_buf->buf[log_buf->ptr + align_skew],
-				chk_length);
-	nv_length 	-= chk_length;
-	log_buf->ptr 	+= (chk_length + align_skew);
+	rec_hdr = (rec_hdr_t *)&(log_buf->buf[log_buf->ptr]);
 
-	if (nv_length == 0) {
-		done = rvm_true;
-		goto done_looping;
+	if (rec_hdr->struct_id == rec_end_id) {
+		loop_done = rvm_true;
+		goto break_loop;
 	}
 
-        m0_be_cbinfo_copy_helper(cbinfo, rcsc_cbinfo, rcs_refill_buffer_cb);
+	if (rec_hdr->struct_id != nv_range_id) {
+		is_bad_record = rvm_true;
+		goto bad_record;            /* invalid record */
+	}
 
-	retval = refill_buffer(log, FORWARD, synch);
+	nv = (nv_range_t *)rec_hdr;
+	if (trans_hdr->rec_hdr.rec_num != nv->rec_hdr.rec_num) {
+		is_bad_record = rvm_true;
+		goto bad_record;            /* wrong transaction */
+	}
 
+	cbinfo->bc_cb = sts_range_chk_sum_cb;
+	/* test range's data check sum */
+	retval = range_chk_sum(log, nv, chk_val, NO_SYNCH, cbinfo);
 	if (retval != RVM_SUCCESS) {
-		msg_type  = retval;
 		be_status = -1;
+		msg	  =  retval;
+		goto exit;
 	}
 
-	rcs_cbdata->rcsc_nv_length 	= nv_length;
-	rcs_cbdata->rcsc_chk_sum_temp 	= chk_sum_temp;
-	rcs_cbdata->rcsc_nv_chk_sum 	= nv->chk_sum;
+break_loop:
+	/* set_trans_status has been completed, finish the remainder task. */
+	if (loop_done) {
+		set_trans_status_cb(cbinfo, be_status, msg);
+		goto exit;
+	}
+
+bad_record:
+	log_buf->ptr = -1;
 
-	goto exit;
-done_looping:
-	rcs_done_loop(rcs_cbdata);
 exit:
-	if (be_status != 0 && cbinfo != NULL && cbinfo->bc_cb != NULL) {
-                m0_be_handler_post(cbinfo, be_status, msg_type);
-                m0_free(rcs_cbdata);
-        }
-	return retval;
+	if((be_status != 0 || is_bad_record) && cbinfo->bc_pcbinfo != NULL &&
+	   cbinfo->bc_pcbinfo->bc_cb != NULL) {
+		m0_be_handler_post(cbinfo->bc_pcbinfo, be_status, msg);
+		m0_free(lrc_cbdata);
+	}
 }
 
 /* transaction validation & status update for tail location */
-static rvm_return_t set_trans_status(log,rec_hdr)
-    log_t           *log;               /* log descriptor */
-    rec_hdr_t        *rec_hdr;           /* current trans record in buffer */
-    {
-    log_buf_t       *log_buf = &log->log_buf; /* log buffer descriptor */
-    log_status_t    *status = &log->status;   /* status descriptor */
-    trans_hdr_t     trans_hdr;          /* copy of header */
-    long            num_ranges = 0;     /* range scan counter */
-    nv_range_t      *nv;                /* range header */
-    rvm_bool_t      chk_val;            /* checksum test result */
-    rvm_return_t    retval;             /* return value */
+static rvm_return_t set_trans_status(log, rec_hdr, cbinfo)
+    log_t           	*log;               /* log descriptor */
+    rec_hdr_t        	*rec_hdr;           /* current trans record in buffer */
+    struct m0_be_cbinfo	*cbinfo;
+{
+	lrc_cbdata_t		*lrc_cbdata;
+	struct m0_be_cbinfo 	*lrc_cbinfo;
+	log_buf_t       	*log_buf = &log->log_buf;
+	trans_hdr_t     	 trans_hdr;          /* copy of header */
+	long            	 num_ranges = 0;     /* range scan counter */
+	int			 be_status  = 0;
+	m0_be_msg_type_t	 msg	    = M0_BE_SUCCESS;
+	rvm_return_t    	 retval	    = RVM_SUCCESS;
+
+	printf("\n function %s \n", __FUNCTION__);
+	M0_ALLOC_PTR(lrc_cbdata);
+        if (lrc_cbdata == NULL) {
+                be_status = -1;
+                msg       = -ENOMEM;
+                goto exit;
+        }
 
-    /* keep copy of header to get status if ranges are OK */
-    BCOPY((char *)rec_hdr,(char *)&trans_hdr,sizeof(trans_hdr_t));
 
-    /* scan and check sum all ranges */
-    log_buf->ptr += sizeof(trans_hdr_t);
-    DO_FOREVER
-        {
-        if ((retval=scan_nv_forward(log,NO_SYNCH)) != RVM_SUCCESS)
-            return retval;
-        rec_hdr = (rec_hdr_t *)&(log_buf->buf[log_buf->ptr]);
-        if (rec_hdr->struct_id == rec_end_id)
-            break;                      /* done */
-        if (rec_hdr->struct_id != nv_range_id)
-            goto bad_record;            /* invalid record */
-        nv = (nv_range_t *)rec_hdr;
-        if (trans_hdr.rec_hdr.rec_num != nv->rec_hdr.rec_num)
-            goto bad_record;            /* wrong transaction */
-
-        /* test range's data check sum */
-        if ((retval=range_chk_sum(log,nv,&chk_val,NO_SYNCH))
-            != RVM_SUCCESS) return retval;
-        if (chk_val != rvm_true) goto bad_record; /* check sum failure */
-
-        num_ranges++;
-        }
-    /* be sure all ranges are present */
-    if (num_ranges != trans_hdr.num_ranges)
-        goto bad_record;                /* incomplete */
-
-    /* transaction complete, update status */
-    status->last_uname = trans_hdr.uname;
-    if (trans_hdr.flags & FLUSH_FLAG)
-        status->n_flush_commit++;
-    else status->n_no_flush_commit++;
-    if (((trans_hdr.flags & FIRST_ENTRY_FLAG) != 0)
-        && ((trans_hdr.flags & LAST_ENTRY_FLAG) == 0))
-        status->n_split++;
-    return RVM_SUCCESS;
+	/* keep copy of header to get status if ranges are OK */
+	BCOPY((char *)rec_hdr, (char *)&trans_hdr, sizeof(trans_hdr_t));
 
-bad_record:
-    log_buf->ptr = -1;
-    return RVM_SUCCESS;
-    }
+	/* IMP: Also mainitain in lrc_cbdata. */
+	BCOPY((char *)rec_hdr, (char *)&lrc_cbdata->lrc_trans_hdr,
+	      sizeof(trans_hdr_t));
+
+	/* scan and check sum all ranges */
+	log_buf->ptr += sizeof(trans_hdr_t);
+
+	/* lrc_trans_hdr has been already updated. */
+	lrc_cbdata->lrc_log 		=  log;
+	lrc_cbdata->lrc_num_ranges	=  num_ranges;
+	lrc_cbinfo	    		= &lrc_cbdata->lrc_cbinfo;
+	m0_be_cbinfo_copy_helper(cbinfo, lrc_cbinfo, sts_nv_fwd_cb);
+
+	retval = scan_nv_forward(log, NO_SYNCH, lrc_cbinfo);
+	if (retval != RVM_SUCCESS) {
+		be_status = -1;
+		msg 	  =  retval;
+	}
+exit:
+	if (be_status != 0 && cbinfo != NULL && cbinfo->bc_cb != NULL) {
+		m0_be_handler_post(cbinfo, be_status, msg);
+	}
+	return retval;
+}
 
 void loc_tail_vrf_cb(struct m0_be_cbinfo *cbinfo, int be_status,
                      m0_be_msg_type_t msg_type);
@@ -1399,7 +2406,7 @@ void locate_tail_cb(loc_tail_cbdata_t *loc_tail_cbdata)
 	m0_free(loc_tail_cbdata);
 }
 
-void set_trans_status_cb(struct m0_be_cbinfo *cbinfo, int be_status,
+void loc_tail_set_trans_status_cb(struct m0_be_cbinfo *cbinfo, int be_status,
 			 m0_be_msg_type_t msg_type)
 {
 	loc_tail_cbdata_t 	*loc_tail_cbdata;
@@ -1505,7 +2512,7 @@ void loc_tail_vrf_cb(struct m0_be_cbinfo *cbinfo, int be_status,
 			tail = status->log_start;
 			break;
 		case trans_hdr_id:
-			cbinfo->bc_cb = set_trans_status_cb;
+			cbinfo->bc_cb = loc_tail_set_trans_status_cb;
 			retval = set_trans_status(log, rec_hdr);
 			if (retval != RVM_SUCCESS) {
 				be_status = -1;
@@ -1516,7 +2523,7 @@ void loc_tail_vrf_cb(struct m0_be_cbinfo *cbinfo, int be_status,
 			set_trans_called = rvm_true;
 			/** This needs to be removed when set_trans_status
 			 * becomes async. */
-			set_trans_status_cb(cbinfo, be_status, msg_type);
+			loc_tail_set_trans_status_cb(cbinfo, be_status, msg_type);
 			assert(log->trunc_thread == cthread_self());
 			assert((status->trunc_state & RVM_TRUNC_PHASES) == RVM_TRUNC_FIND_TAIL);
 			if (log_buf->ptr != -1)
@@ -1533,7 +2540,7 @@ void loc_tail_vrf_cb(struct m0_be_cbinfo *cbinfo, int be_status,
 	}
 
 	if(!set_trans_called) {
-		set_trans_status_cb(cbinfo, be_status, msg_type);
+		loc_tail_set_trans_status_cb(cbinfo, be_status, msg_type);
 	}
 
 	goto exit;
@@ -2207,7 +3214,6 @@ static rvm_return_t do_nv(log,nv)
     dev_region_t    *node;              /* change tree node for this nv */
     rvm_length_t    aligned_len;        /* allocation temp */
     rvm_offset_t    offset;             /* monitoring temp */
-    rvm_bool_t      chk_val;            /* checksum result */
     rvm_return_t    retval;             /* return value */
 
     assert(log->trunc_thread == cthread_self());
@@ -2271,77 +3277,164 @@ static rvm_return_t do_nv(log,nv)
         return retval;
 
     /* see if complete check sum test wanted */
-    if (rvm_chk_sum)
-        {
-        if ((retval=range_chk_sum(log,nv,&chk_val,SYNCH))
-            != RVM_SUCCESS) return retval;
-        assert(chk_val == rvm_true);        /* check sum failure */
-        if ((retval=scan_nv_reverse(log,SYNCH)) != RVM_SUCCESS)
-            return retval;
-        assert(log->trunc_thread == cthread_self());
-        assert((status->trunc_state & RVM_TRUNC_PHASES)
-           == RVM_TRUNC_BUILD_TREE);
-        }
+    /*if (rvm_chk_sum)*/
+    /*{*/
+    /*if ((retval=range_chk_sum(log,nv,&chk_val,SYNCH))*/
+    /*!= RVM_SUCCESS) return retval;*/
+    /*assert(chk_val == rvm_true);        *//* check sum failure */
+    /*if ((retval=scan_nv_reverse(log,SYNCH)) != RVM_SUCCESS)*/
+    /*return retval;*/
+    /*assert(log->trunc_thread == cthread_self());*/
+    /*assert((status->trunc_state & RVM_TRUNC_PHASES)*/
+    /*== RVM_TRUNC_BUILD_TREE);*/
+    /*}*/
 
     return RVM_SUCCESS;
     }
-/* scan modifications of transaction in reverse order & build tree */
-static rvm_return_t do_trans(log,skip_trans)
-    log_t           *log;               /* log descriptor */
-    rvm_bool_t      skip_trans;         /* scan, but ignore if true */
-    {
-    log_status_t    *status = &log->status; /* status descriptor */
-    log_buf_t       *log_buf = &log->log_buf; /* log buffer descriptor */
 
-    rec_hdr_t       *rec_hdr;           /* last record header scanned */
-    rec_end_t       *rec_end;           /* end marker for transaction */
-    trans_hdr_t     *trans_hdr;         /* transaction header ptr */
-    long            num_ranges = 0;     /* ranges processed */
-    long            prev_range = 0;     /* previous range number */
-    rvm_return_t    retval;             /* return value */
+void do_trans_cb(cbinfo, be_status, msg)
+	struct m0_be_cbinfo	*cbinfo;
+	int			 be_status;
+	m0_be_msg_type_t	 msg;
+{
+	lrc_cbdata_t		*lrc_cbdata;
+	log_t			*log;
+	log_status_t    	*status;
+	log_buf_t       	*log_buf;
+	rec_hdr_t       	*rec_hdr;
+	trans_hdr_t     	*trans_hdr;
+	rvm_bool_t	 	 skip_trans;
+	rvm_bool_t	 	 loop_done = rvm_false;
+	long            	 num_ranges;
+	long            	 prev_range = 0;
+	rvm_return_t    	 retval     = RVM_SUCCESS;
+
+	printf("\n function %s\n", __FUNCTION__);
+	if (be_status != 0)
+		goto exit;
 
-    assert(log->trunc_thread == cthread_self());
-    assert((status->trunc_state & RVM_TRUNC_PHASES)
-           == RVM_TRUNC_BUILD_TREE);
+	lrc_cbdata =  container_of(cbinfo, lrc_cbdata_t, lrc_cbinfo);
+	log	   =  lrc_cbdata->lrc_log;
+	skip_trans =  lrc_cbdata->lrc_skip_trans;
+	num_ranges =  lrc_cbdata->lrc_num_ranges;
+	prev_range =  lrc_cbdata->lrc_prev_range;
+	log_buf	   = &log->log_buf;
+	status	   = &log->status;
 
-    /* remember the transaction's timestamp and scan ranges */
-    rec_end = (rec_end_t *)&log_buf->buf[log_buf->ptr];
-    assert(rec_end->rec_hdr.struct_id == rec_end_id);
-    log_buf->timestamp = rec_end->rec_hdr.timestamp;
-    DO_FOREVER
-        {
-        if ((retval=scan_nv_reverse(log,SYNCH)) != RVM_SUCCESS)
-            return retval;
-        assert(log->trunc_thread == cthread_self());
-        assert((status->trunc_state & RVM_TRUNC_PHASES)
-           == RVM_TRUNC_BUILD_TREE);
-        rec_hdr = (rec_hdr_t *)&log_buf->buf[log_buf->ptr];
-
-        /* test for end */
-        if (rec_hdr->struct_id == trans_hdr_id)
-            break;                      /* done */
-
-        /* check order and process the range */
-        assert(rec_hdr->struct_id == nv_range_id);
-        if (prev_range != 0)
-            assert(((nv_range_t *)rec_hdr)->range_num == (prev_range-1));
-        if (!skip_trans)
-            if ((retval=do_nv(log,(nv_range_t *)rec_hdr))
-                != RVM_SUCCESS) return retval;
+	assert(log->trunc_thread == cthread_self());
+	assert((status->trunc_state & RVM_TRUNC_PHASES)	==
+		RVM_TRUNC_BUILD_TREE);
+	rec_hdr = (rec_hdr_t *)&log_buf->buf[log_buf->ptr];
+
+	/* test for end */
+	if (rec_hdr->struct_id == trans_hdr_id) {
+		loop_done = rvm_true;
+		goto exit;
+	}
+
+	/* check order and process the range */
+	assert(rec_hdr->struct_id == nv_range_id);
+	if (prev_range != 0)
+		assert(((nv_range_t *)rec_hdr)->range_num == (prev_range-1));
+	if (!skip_trans)
+		if ((retval = do_nv(log,(nv_range_t *)rec_hdr))!= RVM_SUCCESS) {
+			be_status = -1;
+			msg    	  = retval;
+			goto exit;
+		}
+
+	/* tally ranges processed */
+	num_ranges++;
+	prev_range = ((nv_range_t *)rec_hdr)->range_num;
+
+	lrc_cbdata->lrc_num_ranges = num_ranges;
+	lrc_cbdata->lrc_prev_range = prev_range;
+	cbinfo->bc_cb 		   = do_trans_cb;
+
+	retval = scan_nv_reverse(log, SYNCH, cbinfo);
+	if (retval != RVM_SUCCESS) {
+		be_status = -1;
+		msg	  = retval;
+		goto exit;
+	}
+
+exit:
+        if ((be_status != 0 || loop_done) &&
+             cbinfo->bc_pcbinfo != NULL && cbinfo->bc_pcbinfo->bc_cb != NULL) {
+	     	if (loop_done) {
+			/* sanity checks at the end... */
+			trans_hdr = (trans_hdr_t *)rec_hdr;
+			assert(trans_hdr->rec_hdr.struct_id == trans_hdr_id);
+			assert(TIME_EQL(trans_hdr->rec_hdr.timestamp,
+					log_buf->timestamp));
+			assert(trans_hdr->num_ranges == num_ranges);
+
+			if (num_ranges != 0)
+				assert(prev_range == 1);
+	     	}
 
-        /* tally ranges processed */
-        num_ranges++;
-        prev_range = ((nv_range_t *)rec_hdr)->range_num;
+                m0_be_handler_post(cbinfo->bc_pcbinfo, be_status, msg);
+                m0_free(lrc_cbdata);
         }
+}
+
+/* scan modifications of transaction in reverse order & build tree */
+static rvm_return_t do_trans(log, skip_trans, cbinfo)
+    log_t           	*log;               /* log descriptor */
+    rvm_bool_t      	 skip_trans;         /* scan, but ignore if true */
+    struct m0_be_cbinfo *cbinfo;
+{
+	lrc_cbdata_t		*lrc_cbdata;
+	struct m0_be_cbinfo	*lrc_cbinfo;
+	log_status_t    	*status = &log->status; /* status descriptor */
+	log_buf_t       	*log_buf = &log->log_buf;
+	rec_end_t       	*rec_end;    /* end marker for transaction */
+	long            	 num_ranges = 0;     /* ranges processed */
+	long            	 prev_range = 0;     /* previous range number */
+	int			 be_status  = 0;
+	m0_be_msg_type_t	 msg	    = M0_BE_SUCCESS;
+	rvm_return_t    	 retval     = RVM_SUCCESS;
+
+	printf("\n function %s\n", __FUNCTION__);
 
-    /* sanity checks at the end... */
-    trans_hdr = (trans_hdr_t *)rec_hdr;
-    assert(trans_hdr->rec_hdr.struct_id == trans_hdr_id);
-    assert(TIME_EQL(trans_hdr->rec_hdr.timestamp,log_buf->timestamp));
-    assert(trans_hdr->num_ranges == num_ranges);
-    if (num_ranges != 0) assert(prev_range == 1);
+	assert(log->trunc_thread == cthread_self());
+	assert((status->trunc_state & RVM_TRUNC_PHASES) ==
+	       RVM_TRUNC_BUILD_TREE);
 
-    return RVM_SUCCESS;
+	/* remember the transaction's timestamp and scan ranges */
+	rec_end = (rec_end_t *)&log_buf->buf[log_buf->ptr];
+	assert(rec_end->rec_hdr.struct_id == rec_end_id);
+	log_buf->timestamp = rec_end->rec_hdr.timestamp;
+
+	M0_ALLOC_PTR(lrc_cbdata);
+        if (lrc_cbdata == NULL) {
+                be_status = -1;
+                msg       = -ENOMEM;
+                goto exit;
+        }
+
+	lrc_cbdata->lrc_log 		=  log;
+	lrc_cbdata->lrc_skip_trans	=  skip_trans;
+	lrc_cbdata->lrc_num_ranges	=  num_ranges;
+	lrc_cbdata->lrc_prev_range	=  prev_range;
+	lrc_cbinfo			= &lrc_cbdata->lrc_cbinfo;
+	/********************************************************** UNCOMMENT *****************************/
+	/*m0_be_cbinfo_copy_helper(cbinfo, lrc_cbinfo, do_trans_cb);*/
+
+	retval = scan_nv_reverse(log, SYNCH, lrc_cbinfo);
+	if (retval != RVM_SUCCESS) {
+		be_status = -1;
+		msg	  =  retval;
+	}
+exit:
+	if (be_status != 0  && cbinfo != NULL &&  cbinfo->bc_cb != NULL) {
+	    	m0_be_handler_post(cbinfo, be_status, msg);
+		m0_free(lrc_cbdata);
+	}
+
+	/***************************************** REMOVE THIS *******************************************/
+	do_trans_cb(lrc_cbinfo, be_status, msg);
+	return retval;
 }
 
 M0_INTERNAL void cw_init_buffer_cb(struct m0_be_cbinfo *cbinfo,
@@ -2663,106 +3756,295 @@ exit:
 /* Recovery: phase 2 -- build modification trees, and
    construct dictionary of segment short names
 */
+
+void bt_pre_scan_reverse_cb(struct m0_be_cbinfo *cbinfo, int be_status,
+		             m0_be_msg_type_t msg_type);
 #define X(a)
-static rvm_return_t build_tree(log)
-    log_t           *log;               /* log descriptor */
-    {
-    	printf("\n function __%s__ \n", __FUNCTION__);
-    log_status_t    *status = &log->status; /* status descriptor */
-    log_buf_t       *log_buf = &log->log_buf; /* log buffer descriptor */
-    rvm_return_t    retval;             /* return value */
-    rvm_offset_t    tail;               /* tail offset temp */
-    rec_end_t       *rec_end;           /* last record scanned in buffer */
-    rvm_length_t    trans_cnt = 0;      /* transactions processed */
-    rvm_bool_t      force_wrap_chk = rvm_false; /* true if suspect bad wrap */
-    rvm_bool_t      skip_trans;         /* true if bad wrap trans to be skipped */
+void bt_do_trans_cb(struct m0_be_cbinfo *cbinfo, int be_status,
+                    m0_be_msg_type_t msg_type)
+{
+	log_t		      *log;
+	log_buf_t      	      *log_buf;
+	rvm_offset_t          *tail;
+	bt_cbdata_t           *bt_cbdata;
 
-    assert(log->trunc_thread == cthread_self());
-    assert(((status->trunc_state & RVM_TRUNC_PHASES) == RVM_TRUNC_FIND_TAIL)
-            || ((status->trunc_state & RVM_TRUNC_PHASES) == ZERO));
-    status->trunc_state = (status->trunc_state & (~RVM_TRUNC_FIND_TAIL))
-                           | RVM_TRUNC_BUILD_TREE;
+	if(be_status == -1)
+		goto exit;
+
+	bt_cbdata   = container_of(cbinfo, bt_cbdata_t, bt_cbinfo);
+	log         = bt_cbdata->bt_log;
+	tail	    = &bt_cbdata->bt_tail;
+	log_buf	    = &log->log_buf;
+
+	/* update local tail ptr */
+	*tail = RVM_ADD_LENGTH_TO_OFFSET(log_buf->offset, log_buf->ptr);
+	/* leave buffer unprotected for later phases */
+	/* MACH_RVM_PROTECT
+	 *
+	 * protect(log_buf->buf, log_buf->length, FALSE,
+	 * 	   VM_PROT_WRITE | VM_PROT_READ);
+	 */
+	bt_pre_scan_reverse_cb(cbinfo, be_status, msg_type);
+exit:
+	if (be_status != 0 && cbinfo->bc_pcbinfo != NULL &&
+	    cbinfo->bc_pcbinfo->bc_cb != NULL) {
+		m0_be_handler_post(cbinfo->bc_pcbinfo, be_status, msg_type);
+		m0_free(bt_cbdata);
+	}
+}
+void bt_chk_wrap_cb(struct m0_be_cbinfo *cbinfo, int be_status,
+                    m0_be_msg_type_t msg_type)
+{
+	log_t		      *log;
+	bt_cbdata_t           *bt_cbdata;
+	struct m0_be_cbinfo   *bt_cbinfo;
+	rvm_return_t	       retval;
+
+	if(be_status == -1)
+		goto exit;
+
+	bt_cbdata   = container_of(cbinfo, bt_cbdata_t, bt_cbinfo);
+	log         = bt_cbdata->bt_log;
+
+	bt_cbinfo   = &bt_cbdata->bt_cbinfo;
+
+	bt_cbinfo->bc_pcbinfo   = cbinfo;
+	bt_cbinfo->bc_cb        = bt_do_trans_cb;
+	bt_cbinfo->bc_sm_group  = cbinfo->bc_sm_group;
+	bt_cbinfo->bc_hq        = cbinfo->bc_hq;
+
+	bt_cbdata->bt_force_wrap_chk = rvm_false;
+X( trans_hdr_id: do_trans)
+	if ((retval = do_trans(log,
+			       bt_cbdata->bt_skip_trans,
+			       bt_cbinfo)) != RVM_SUCCESS) {
+		msg_type = retval;
+		be_status = -1;
+	}
+exit:
+	if (be_status != 0 && cbinfo->bc_pcbinfo != NULL &&
+	    cbinfo->bc_pcbinfo->bc_cb != NULL) {
+		m0_be_handler_post(cbinfo->bc_pcbinfo, be_status, msg_type);
+		m0_free(bt_cbdata);
+	}
+}
+
+void bt_scan_reverse_cb(struct m0_be_cbinfo *cbinfo, int be_status,
+                        m0_be_msg_type_t msg_type)
+{
+	log_t		      *log;
+	log_status_t          *status;       /* status descriptor */
+	log_buf_t      	      *log_buf;      /* log buffer descriptor */
+	rvm_return_t           retval;       /* return value */
+	rec_end_t      	      *rec_end;      /* last record scanned in buffer */
+	rvm_offset_t          *tail;         /* tail offset temp */
+    	bt_cbdata_t           *bt_cbdata;
+	struct m0_be_cbinfo   *bt_cbinfo;
+
+	if(be_status == -1)
+		goto exit;
+
+	bt_cbdata   = container_of(cbinfo, bt_cbdata_t, bt_cbinfo);
+	log         = bt_cbdata->bt_log;
+	tail	    = &bt_cbdata->bt_tail;
+
+	bt_cbinfo   = &bt_cbdata->bt_cbinfo;
+	assert(log->trunc_thread == cthread_self());
+	log_buf	    = &log->log_buf;
+	status	    = &log->status;
+
+	bt_cbinfo->bc_pcbinfo   = cbinfo;
+	bt_cbinfo->bc_cb        = bt_chk_wrap_cb;
+	bt_cbinfo->bc_sm_group  = cbinfo->bc_sm_group;
+	bt_cbinfo->bc_hq        = cbinfo->bc_hq;
 
-    /* reset sequence checks and init scan buffers */
-X(reset_hdr)
-    reset_hdr_chks(log);
-X(clear_aux)
-    clear_aux_buf(log);
-X(init_buf)
-    if (RVM_OFFSET_EQL(status->prev_log_tail, status->log_start))
-        retval = init_buffer(log,&status->log_start, FORWARD,SYNCH);
-    else
-        retval = init_buffer(log,&status->prev_log_tail, REVERSE,SYNCH);
-    assert(retval == RVM_SUCCESS);
-    assert(log->trunc_thread == cthread_self());
-X(done_init_buf)
-    /* scan in reverse from tail to find records for uncommitted changes */
-    num_nodes = NODES_PER_YIELD;
-    log_buf->split_ok = rvm_false;      /* split records not checked yet */
-    tail = status->prev_log_tail;       /* use previous epoch tail */
-    while (!RVM_OFFSET_EQL(tail,status->prev_log_head))
-        {
-X(start loop)
-        if ((retval=scan_reverse(log,SYNCH)) != RVM_SUCCESS)
-            return retval;
 X(done scan_reverse)
         assert(log->trunc_thread == cthread_self());
         assert((status->trunc_state & RVM_TRUNC_PHASES)
                == RVM_TRUNC_BUILD_TREE);
         if (rvm_chk_sigint != NULL)     /* test for interrupt */
-            if ((*rvm_chk_sigint)(NULL)) return RVM_SUCCESS;
+            if ((*rvm_chk_sigint)(NULL)) {
+	    	msg_type = RVM_SUCCESS;
+		goto exit;
+	    }
         assert((long)log_buf->ptr >= 0); /* log damage, invalid record */
 
         /* check type of end marker, do type-dependent processing */
         rec_end = (rec_end_t *)&log_buf->buf[log_buf->ptr];
         if (rec_end->rec_hdr.struct_id == log_wrap_id)
-            {
+	{
 X(log_wrap)
-            if (!log_buf->split_ok)
-                force_wrap_chk = rvm_true;
-            }
-        else
-            {
+		if (!log_buf->split_ok)
+			bt_cbdata->bt_force_wrap_chk = rvm_true;
+	}
+	else
+	{
 X(else)
-            assert(rec_end->rec_hdr.struct_id == rec_end_id);
-            switch (rec_end->rec_type)
+		assert(rec_end->rec_hdr.struct_id == rec_end_id);
+		switch (rec_end->rec_type)
                 {
-              case trans_hdr_id:        /* process transaction */
+			case trans_hdr_id:        /* process transaction */
 X( trans_hdr_id: chk_wrap)
-                if ((retval=chk_wrap(log,force_wrap_chk,&skip_trans))
-                    != RVM_SUCCESS) return retval;
-                force_wrap_chk = rvm_false;
-X( trans_hdr_id: do_trans)
-                if ((retval=do_trans(log,skip_trans)) != RVM_SUCCESS)
-                    return retval;
-X( trans_hdr_id: end)
-                trans_cnt++;
-                break;
-              case log_seg_id:          /* enter seg short id in dictionary */
+			        if ((retval = chk_wrap(
+				                  log,
+						  bt_cbdata->bt_force_wrap_chk,
+  		                	 	  &bt_cbdata->bt_skip_trans,
+				                  bt_cbinfo)) != RVM_SUCCESS) {
+				                 	be_status = -1;
+				                	msg_type = retval;
+				                	goto exit;
+
+				 }
+				goto exit;
+			case log_seg_id:          /* enter seg short
+						     id in dictionary */
 X( log_seg_id: def_seg_dict)
-                if ((retval=def_seg_dict(log,(rec_hdr_t *)
-                    RVM_SUB_LENGTH_FROM_ADDR(rec_end,
-                                        rec_end->rec_hdr.rec_length)))
-                    != RVM_SUCCESS) return retval;
+				if ((retval=def_seg_dict(log,(rec_hdr_t *)
+					    RVM_SUB_LENGTH_FROM_ADDR(rec_end,
+					    rec_end->rec_hdr.rec_length)))
+					    != RVM_SUCCESS) {
+					    be_status = -1;
+					    msg_type  = retval;
+					    goto exit;
+			        }
 X( log_seg_id: done)
-                log_buf->ptr -= rec_end->rec_hdr.rec_length;
-                break;
-              default:  assert(rvm_false); /* trouble, log damage? */
+				log_buf->ptr -= rec_end->rec_hdr.rec_length;
+				break;
+			default:  assert(rvm_false); /* trouble, log damage? */
                 }
+	       /* update local tail ptr */
+	       *tail = RVM_ADD_LENGTH_TO_OFFSET(log_buf->offset, log_buf->ptr);
             }
+exit:
+	if (be_status != 0 && cbinfo->bc_pcbinfo != NULL &&
+	    cbinfo->bc_pcbinfo->bc_cb != NULL) {
+		m0_be_handler_post(cbinfo->bc_pcbinfo, be_status, msg_type);
+		m0_free(bt_cbdata);
+	}
+}
+void bt_pre_scan_reverse_cb(struct m0_be_cbinfo *cbinfo, int be_status,
+		             m0_be_msg_type_t msg_type)
+{
+	log_t		      *log;
+	log_status_t          *status = NULL; /* status descriptor */
+	log_buf_t      	      *log_buf = NULL; /* log buffer
+							   descriptor */
+	rvm_return_t           retval;             /* return value */
+	rvm_offset_t          *tail;               /* tail offset temp */
+    	bt_cbdata_t           *bt_cbdata;
+	rvm_bool_t	       loop_break;
+
+	if(be_status == -1)
+		goto exit;
 
-        /* update local tail ptr */
-        tail = RVM_ADD_LENGTH_TO_OFFSET(log_buf->offset,log_buf->ptr);
-        }
+	bt_cbdata   = container_of(cbinfo, bt_cbdata_t, bt_cbinfo);
+	log         = bt_cbdata->bt_log;
+	tail 	    = &bt_cbdata->bt_tail;
 
-    /* leave buffer unprotected for later phases */
-/* MACH_RVM_PROTECT
- *
- * protect(log_buf->buf, log_buf->length, FALSE, VM_PROT_WRITE | VM_PROT_READ);
- */
+	assert(log->trunc_thread == cthread_self());
+	log_buf	    = &log->log_buf;
+	status	    = &log->status;
 
-    return RVM_SUCCESS;
-    }
+	if(RVM_OFFSET_EQL(*tail,status->prev_log_head)) {
+		loop_break = rvm_true;
+		goto exit;
+	}
+	cbinfo->bc_cb = bt_scan_reverse_cb;
+X(start loop)
+	if ((retval = scan_reverse(log, SYNCH, cbinfo)) != RVM_SUCCESS) {
+		msg_type  = retval;
+		be_status = -1;
+	}
+exit:
+	if ((be_status != 0 || loop_break) && cbinfo->bc_pcbinfo != NULL &&
+	    cbinfo->bc_pcbinfo->bc_cb != NULL) {
+		m0_be_handler_post(cbinfo->bc_pcbinfo, be_status, msg_type);
+		m0_free(bt_cbdata);
+	}
+}
+
+void bt_init_buffer_cb(struct m0_be_cbinfo *cbinfo, int be_status,
+		       m0_be_msg_type_t msg_type)
+{
+	log_t		      *log;
+	log_status_t          *status = NULL; /* status descriptor */
+	log_buf_t      	      *log_buf = NULL; /* log buffer descriptor */
+    	bt_cbdata_t           *bt_cbdata;
+
+	if(be_status == -1)
+		goto exit;
+
+	bt_cbdata   = container_of(cbinfo, bt_cbdata_t, bt_cbinfo);
+	log         = bt_cbdata->bt_log;
+
+	assert(log->trunc_thread == cthread_self());
+	log_buf	    = &log->log_buf;
+	status	    = &log->status;
+X(done_init_buf)
+	/* scan in reverse from tail to find records for uncommitted changes */
+	num_nodes = NODES_PER_YIELD;
+	log_buf->split_ok = rvm_false;      /* split records not checked yet */
+	bt_cbdata->bt_tail = status->prev_log_tail; /* use previous epoch tail*/
+	bt_pre_scan_reverse_cb(cbinfo, be_status, msg_type);
+exit:
+	if (be_status != 0 && cbinfo->bc_pcbinfo != NULL &&
+	    cbinfo->bc_pcbinfo->bc_cb != NULL) {
+		m0_be_handler_post(cbinfo->bc_pcbinfo, be_status, msg_type);
+		m0_free(bt_cbdata);
+	}
+}
+
+static rvm_return_t build_tree(log, cbinfo)
+	log_t           	 *log;               /* log descriptor */
+	struct m0_be_cbinfo  *cbinfo;
+{
+	log_status_t          *status = &log->status; /* status descriptor */
+	rvm_return_t           retval;             /* return value */
+	rvm_offset_t          *status_offset;
+	rvm_bool_t             direction;
+    	bt_cbdata_t           *bt_cbdata;
+	struct m0_be_cbinfo   *bt_cbinfo;
+	int		       be_status = 0;
+	m0_be_msg_type_t       msg_type = M0_BE_SUCCESS;
+
+	assert(log->trunc_thread == cthread_self());
+	assert(((status->trunc_state & RVM_TRUNC_PHASES) == RVM_TRUNC_FIND_TAIL)
+	        || ((status->trunc_state & RVM_TRUNC_PHASES) == ZERO));
+	status->trunc_state = (status->trunc_state & (~RVM_TRUNC_FIND_TAIL))
+	                       | RVM_TRUNC_BUILD_TREE;
+
+	M0_ALLOC_PTR(bt_cbdata);
+	M0_ASSERT(bt_cbdata != NULL);
+
+	bt_cbdata->bt_log                = log;
+
+	bt_cbinfo                        = &bt_cbdata->bt_cbinfo;
+	m0_be_cbinfo_copy_helper(cbinfo, bt_cbinfo, bt_init_buffer_cb);
+
+	/* reset sequence checks and init scan buffers */
+X(reset_hdr)
+	reset_hdr_chks(log);
+X(clear_aux)
+	clear_aux_buf(log);
+X(init_buf)
+	if (RVM_OFFSET_EQL(status->prev_log_tail, status->log_start)) {
+		status_offset = &status->log_start;
+		direction     = FORWARD;
+	}
+	else {
+		status_offset = &status->prev_log_tail;
+		direction     = REVERSE;
+	}
+    	printf("\n function __%s__ \n", __FUNCTION__);
+        retval = init_buffer(log, status_offset, direction, SYNCH, bt_cbinfo);
+
+	if (retval != RVM_SUCCESS && cbinfo->bc_pcbinfo != NULL &&
+	    cbinfo->bc_pcbinfo->bc_cb != NULL) {
+		m0_be_handler_post(cbinfo->bc_pcbinfo, be_status, msg_type);
+		m0_free(bt_cbdata);
+	}
+	return RVM_SUCCESS;
+}
 
 /* pre-scan change tree to see how much to read to read into buffer */
 /*
@@ -4177,50 +5459,82 @@ exit_log_recover:
 	}
 }
 
-void lr_locate_tail_cb(cbinfo, be_status, msg)
-	struct m0_be_cbinfo	*cbinfo;
-	int			 be_status;
-	m0_be_msg_type_t	 msg;
+/* recover committed state from log */
+rvm_return_t log_recover(log, count, is_daemon, flag, cbinfo)
+    log_t               *log;               /* log descriptor */
+    rvm_length_t        *count;             /* ptr to statistics counter */
+    rvm_bool_t           is_daemon;          /* true if called by daemon */
+    rvm_length_t         flag;               /* truncation type flag */
+    struct m0_be_cbinfo *cbinfo;
 {
-	lrc_cbdata_t        *lrc_cbdata;
-	log_t		    *log;
-        log_status_t        *status;
-        log_daemon_t        *daemon;
-
-	rvm_bool_t           is_daemon;
+        lrc_cbdata_t        *lrc_cbdata;
+        struct m0_be_cbinfo *lrc_cbinfo;
+        log_status_t        *status = &log->status; /* log status descriptor */
+        log_daemon_t        *daemon = &log->daemon; /* log daemon descriptor */
+        int                  kretval;
+        int                  be_status = 0;
+        m0_be_msg_type_t     msg       = M0_BE_SUCCESS;
+        rvm_bool_t           do_truncation = rvm_false;
         rvm_return_t         retval = RVM_SUCCESS;
+        rvm_length_t         new_1st_rec_num = 0;
 
-        rvm_bool_t           do_truncation;
-        rvm_length_t         new_1st_rec_num;
-	rvm_length_t        *count;             /* ptr to statistics counter */
-
-	printf("\nfunction : %s\n", __FUNCTION__);
+        printf("\nfunction : %s\n", __FUNCTION__);
 
-	if (be_status != 0)
+	M0_ALLOC_PTR(lrc_cbdata);
+	if (lrc_cbdata == NULL) {
+		be_status = -1;
+		retval    = msg = -ENOMEM;
 		goto exit_log_recover;
+	}
 
-	lrc_cbdata      = container_of(cbinfo, lrc_cbdata_t, lrc_cbinfo);
-	log	        = lrc_cbdata->lrc_log;
-	do_truncation   = lrc_cbdata->lrc_do_trunc;
-	is_daemon	= lrc_cbdata->lrc_is_daemon;
-	status	        = &log->status;
-	daemon	        = &log->daemon;
-	new_1st_rec_num = lrc_cbdata->lrc_recnr;
-	count		= lrc_cbdata->lrc_count;
+	/* Prepare lrc_cbdata. */
+	lrc_cbdata->lrc_log             = log;
+	lrc_cbdata->lrc_is_daemon       = is_daemon;
 
-	printf("\nfunction : %s before crit sec be_status : %d\n", __FUNCTION__,be_status);
+	/* Prepare cbinfo to be given to apply_mods. */
+	lrc_cbinfo             = &lrc_cbdata->lrc_cbinfo;
 
+        X(start)
         CRITICAL(log->truncation_lock,      /* begin truncation lock crit sec */
         {
+                /* capture truncation thread & flag for checking */
+                assert(log->trunc_thread == (cthread_t)NULL);
+                assert(status->trunc_state == ZERO);
+                log->trunc_thread = cthread_self();
+                status->trunc_state = flag;
+
+                X(dev_lock)
                 CRITICAL(log->dev_lock, /* begin dev_lock crit sec */
                         {
+                                /* process statistics */
+                                assert(log->trunc_thread == cthread_self());
+                                kretval= gettimeofday(&trunc_start_time,
+                                                  (struct timezone *)NULL);
+                                if (kretval != 0) {
+                                        retval = RVM_EIO;
+                                        goto err_exit1;
+                                }
+
+                                last_tree_build_time = 0;
+                                last_tree_apply_time = 0;
+
+                                X(in_recovery)
+                                /* phase 1: locate tail & start new epoch */
+                                if (log->in_recovery) {
+                                        if ((retval = locate_tail(log)) !=
+                                            RVM_SUCCESS)
+                                                goto err_exit1;
+                                        assert((status->trunc_state &
+                                                RVM_TRUNC_PHASES) ==
+                                                RVM_TRUNC_FIND_TAIL);
+                                }
+
                                 assert(log->trunc_thread == cthread_self());
 
                                 /* test for interrupt */
                                 if (rvm_chk_sigint != NULL)
                                         if ((*rvm_chk_sigint)(NULL))
                                                 goto err_exit1;
-				printf("\nfunction : %s after rvm_chk_sigint be_status : %d\n", __FUNCTION__,be_status);
 
                                 /* see if truncation actually needed */
                                 if (RVM_OFFSET_EQL(status->log_tail,
@@ -4236,9 +5550,12 @@ void lr_locate_tail_cb(cbinfo, be_status, msg)
 					lrc_cbdata->lrc_is_epoch_done = rvm_true;
 					lrc_cbdata->lrc_do_trunc      = do_truncation;
 
-					cbinfo->bc_cb = lr_epoch_cb;
+					m0_be_cbinfo_copy_helper(cbinfo,
+								 lrc_cbinfo,
+								 lr_epoch_cb);
 
-				   	retval = new_epoch(log, count, cbinfo);
+				   	retval = new_epoch(log, count,
+							   lrc_cbinfo);
                                         /* switch epochs */
 					msg = retval;
                                         if (retval != RVM_SUCCESS) {
@@ -4268,8 +5585,6 @@ void lr_locate_tail_cb(cbinfo, be_status, msg)
                                 }
                         }); /* end dev_lock crit sec */
 
-		printf("\nfunction : %s after rvm_chk_sigint be_status : %d\n", __FUNCTION__,be_status);
-
                 if (retval != RVM_SUCCESS) {
                         be_status = -1;
                         msg       = retval;
@@ -4285,11 +5600,9 @@ void lr_locate_tail_cb(cbinfo, be_status, msg)
 	lrc_cbdata->lrc_is_epoch_done	= rvm_false;
 	lrc_cbdata->lrc_do_trunc	= do_truncation;
 	/* Calling this function just to setup lrc_cbinfo with cbinfo. */
-	/*cbinfo->bc_cb = lrc_cbinfo;*/
-
-	/*m0_be_cbinfo_copy_helper(cbinfo, lrc_cbinfo, NULL);*/
+	m0_be_cbinfo_copy_helper(cbinfo, lrc_cbinfo, NULL);
 
-	lr_epoch_cb(cbinfo, be_status, msg);
+	lr_epoch_cb(lrc_cbinfo, be_status, msg);
 	goto exit_log_recover;
 
 
@@ -4327,139 +5640,8 @@ void lr_locate_tail_cb(cbinfo, be_status, msg)
 		                           be_status, msg);
 			m0_free(lrc_cbdata);
                 }
-}
-
-/* recover committed state from log */
-rvm_return_t log_recover(log, count, is_daemon, flag, cbinfo)
-    log_t               *log;               /* log descriptor */
-    rvm_length_t        *count;             /* ptr to statistics counter */
-    rvm_bool_t           is_daemon;          /* true if called by daemon */
-    rvm_length_t         flag;               /* truncation type flag */
-    struct m0_be_cbinfo *cbinfo;
-{
-        lrc_cbdata_t        *lrc_cbdata;
-        struct m0_be_cbinfo *lrc_cbinfo;
-        log_status_t        *status = &log->status; /* log status descriptor */
-        log_daemon_t        *daemon = &log->daemon; /* log daemon descriptor */
-        int                  kretval;
-        int                  be_status = 0;
-        m0_be_msg_type_t     msg       = M0_BE_SUCCESS;
-        rvm_return_t         retval = RVM_SUCCESS;
-
-        printf("\nfunction : %s\n", __FUNCTION__);
-
-	M0_ALLOC_PTR(lrc_cbdata);
-	if (lrc_cbdata == NULL) {
-		be_status = -1;
-		retval    = msg = -ENOMEM;
-		goto exit_log_recover;
-	}
-
-	/* Prepare lrc_cbdata. */
-	lrc_cbdata->lrc_log             = log;
-	lrc_cbdata->lrc_is_daemon       = is_daemon;
-	lrc_cbdata->lrc_count       	= count;
-
-	/* Prepare cbinfo to be given to apply_mods. */
-	lrc_cbinfo             = &lrc_cbdata->lrc_cbinfo;
-
-        X(start)
-        CRITICAL(log->truncation_lock,      /* begin truncation lock crit sec */
-        {
-                /* capture truncation thread & flag for checking */
-                assert(log->trunc_thread == (cthread_t)NULL);
-                assert(status->trunc_state == ZERO);
-                log->trunc_thread = cthread_self();
-                status->trunc_state = flag;
-
-                X(dev_lock)
-                CRITICAL(log->dev_lock, /* begin dev_lock crit sec */
-                        {
-                                /* process statistics */
-                                assert(log->trunc_thread == cthread_self());
-                                kretval= gettimeofday(&trunc_start_time,
-                                                  (struct timezone *)NULL);
-                                if (kretval != 0) {
-                                        retval = RVM_EIO;
-                                        goto err_exit1;
-                                }
-
-                                last_tree_build_time = 0;
-                                last_tree_apply_time = 0;
-
-                                X(in_recovery)
-                                /* phase 1: locate tail & start new epoch */
-				m0_be_cbinfo_copy_helper(cbinfo, lrc_cbinfo,
-							 lr_locate_tail_cb);
-                                if (log->in_recovery) {
-					retval = locate_tail(log, lrc_cbinfo);
-                                        if (retval != RVM_SUCCESS)
-                                        assert((status->trunc_state &
-                                                RVM_TRUNC_PHASES) ==
-                                                RVM_TRUNC_FIND_TAIL);
-                                }
-				else {
-					printf("\nfunction : %s !log->in_recovery", __FUNCTION__);
-					lr_locate_tail_cb(lrc_cbinfo, be_status,
-							  msg);
-
-				}
-X(err_exit1)
-	err_exit1:;
-                        }); /* end dev_lock crit sec */
-	}); /* end truncation_lock crit sec */
-
-	if (is_daemon) {
-		mutex_lock(&daemon->lock);
-		assert(log->daemon.thread == cthread_self());
-		assert(daemon->state == truncating);
-		assert((status->trunc_state & RVM_ASYNC_TRUNCATE) != 0);
-		condition_signal(&daemon->flush_flag);
-		mutex_unlock(&daemon->lock);
-	}
-
-	if (retval != RVM_SUCCESS) {
-		be_status = -1;
-		msg       = retval;
-		goto err_exit;
-	}
-
-	goto exit_log_recover;
-err_exit:
-        CRITICAL(log->truncation_lock,   /* begin truncation lock crit sec */
-	{
-                /* wake up any threads waiting on a truncation */
-                assert(log->trunc_thread == cthread_self());
-                CRITICAL(daemon->lock,        /* begin daemon->lock crit sec */
-                {
-                        assert(log->trunc_thread == cthread_self());
-                        if (is_daemon) {
-                        assert(log->daemon.thread == cthread_self());
-                        assert((status->trunc_state &
-                                        RVM_ASYNC_TRUNCATE) != 0);
-
-                        assert(daemon->state == truncating);
-                        if (retval != RVM_SUCCESS)
-                        daemon->state = error;
-                        }
-
-                        assert(log->trunc_thread == cthread_self());
-                }); /* end daemon->lock crit sec */
-
-                log->trunc_thread   = (cthread_t)NULL;
-                status->trunc_state = ZERO;
-
-        }); /* end truncation lock crit sec */
-
-exit_log_recover:
-	if (be_status != 0 && cbinfo != NULL && cbinfo->bc_cb != NULL) {
-		m0_be_handler_post(cbinfo->bc_pcbinfo, be_status, msg);
-		m0_free(lrc_cbdata);
-	}
-
         return retval;
 }
-
 #undef X
 
 void rt_flush_log_cb(struct m0_be_cbinfo *cbinfo, int status,
diff --git a/rvm/rvm_private.h b/rvm/rvm_private.h
index 8eac243..5450b7d 100644
--- a/rvm/rvm_private.h
+++ b/rvm/rvm_private.h
@@ -1767,6 +1767,15 @@ typedef struct rcl_cbdata {
 	rvm_bool_t		 rclc_is_alloc_devstatus;
 }rcl_cbdata_t;
 
+/* build_tree_cbdata */
+typedef struct bt_cbdata {
+        struct m0_be_cbinfo      bt_cbinfo;
+        log_t                   *bt_log;
+	rvm_bool_t		 bt_skip_trans;
+	rvm_bool_t		 bt_force_wrap_chk;
+	rvm_offset_t             bt_tail;
+}bt_cbdata_t;
+
 /* flush_log_cbdata */
 typedef struct fl_cbdata {
         struct m0_be_cbinfo      flc_cbinfo;
@@ -1836,7 +1845,29 @@ typedef struct log_recover_cbdata {
         m0_bindex_t             *lrc_io_offset;
         m0_bcount_t             *lrc_io_count;
         void                   **lrc_io_addr;
-	rvm_length_t		*lrc_count;
+
+	/** Needed by init_buffer & refill_buffer. */
+	rvm_bool_t		 lrc_synch;
+
+	/**
+	 * Needed by scan wrap_reverse and validate_rec_reverse,
+	 * validate_rec_forward, scan_reverse.
+	 */
+	rvm_bool_t		 lrc_is_refill_buf;
+	rec_end_t		*lrc_rec_end;
+	rec_hdr_t		*lrc_rec_hdr;
+	long			 lrc_tmp_ptr;
+
+
+	/** Needed by do_trans. */
+	rvm_bool_t		 lrc_skip_trans;
+	long			 lrc_num_ranges;
+	long			 lrc_prev_range;
+
+	/** Needed by set_trans_status. */
+	trans_hdr_t		 lrc_trans_hdr;
+	rvm_bool_t      	 lrc_chk_val;
+
 }lrc_cbdata_t;
 
 /* wait_for_space_cbdata. */
-- 
1.8.3.2

