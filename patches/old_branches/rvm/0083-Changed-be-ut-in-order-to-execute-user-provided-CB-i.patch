From 53cc6f739ed3ea92d2584290dfcd1fdedde8f26c Mon Sep 17 00:00:00 2001
From: Zishan Shaikh <zishan_shaikh@xyratex.com>
Date: Thu, 2 May 2013 03:36:05 -0700
Subject: [PATCH 083/121] Changed be-ut in order to execute user provided CB in
 user's thread.

---
 be/be.h    |   8 ++--
 be/ut/be.c | 141 +++++++++++++++++++++++++++++++++++++++++--------------------
 2 files changed, 99 insertions(+), 50 deletions(-)

diff --git a/be/be.h b/be/be.h
index 220d081..147196b 100644
--- a/be/be.h
+++ b/be/be.h
@@ -720,11 +720,11 @@ enum m0_be_msg_type {
  * Holds callback info from higher level to lower level.
  */
 struct m0_be_cbinfo {
-        m0_be_callback          bc_cb;
+        m0_be_callback           bc_cb;
         /** Parent cbinfo pointer. */
-        struct m0_be_cbinfo    *bc_pcbinfo;
-        struct m0_sm_group     *bc_sm_group;
-        struct m0_tl           *bc_hq;
+        struct m0_be_cbinfo     *bc_pcbinfo;
+        struct m0_sm_group      *bc_sm_group;
+        struct m0_tl            *bc_hq;
 };
 
 /** Handler object. */
diff --git a/be/ut/be.c b/be/ut/be.c
index 55f24ba..8d91c78 100644
--- a/be/ut/be.c
+++ b/be/ut/be.c
@@ -52,18 +52,41 @@
 #define BE_DEBUG        0
 
 static struct m0_be_seg         *seg;
-static struct m0_sm_group       *sm_group;
 static struct m0_be_domain      *dom;
+static struct m0_sm_group       *sm_group;
+static struct m0_sm_group        usr_sm_group;
+
 
 char be_cmd[512];
 #if RVM_CREATE
-static const char      *stob_dir  = "/tmp/__be/o";
-static const char      *stob_file = "0000000000000000.0000000000000001";
+static const char        *stob_dir  = "/tmp/__be/o";
+static const char        *stob_file = "0000000000000000.0000000000000001";
 #endif
-extern const char      *log_file;
-struct m0_stob         *log_stob;
-struct m0_stob_domain  *stob_dom;
-char                    path_name[MAXPATHLEN];
+extern const char        *log_file;
+struct m0_stob           *log_stob;
+struct m0_stob_domain    *stob_dom;
+struct m0_be_cbinfo       pcbinfo;
+char                      path_name[MAXPATHLEN];
+
+
+/*
+ * Holds ast callback info and user sm_goup, used to return control from handler
+ * thread to user.
+ */
+struct m0_be_usr_astinfo {
+        struct m0_sm_group  *bua_sm_group;
+        struct m0_sm_ast     bua_ast;
+        m0_be_msg_type_t     bua_msg;
+        int                  bua_status;
+};
+
+struct m0_be_ts_cbdata {
+        struct m0_be_cbinfo       cbinfo;
+        struct m0_be_usr_astinfo *be_usr_ast;
+        int                       counter;
+        /* current operation is completed or not */
+        bool                      completed;
+} *bt_cbdata;
 
 static int log_stob_create(void)
 {
@@ -118,11 +141,20 @@ static int log_stob_create(void)
         return 0;
 }
 
-struct m0_be_ts_cbdata {
-        struct m0_be_cbinfo cbinfo;
-        int                 counter;
-        bool                completed; /* current operation is completed or not */
-} *bt_cbdata;
+static void be_usr_ast_post_helper(struct m0_be_usr_astinfo *be_usr_ast)
+{
+        struct m0_sm_ast *usr_ast;
+        usr_ast      = &be_usr_ast->bua_ast;
+
+        m0_sm_group_lock(sm_group);
+        m0_sm_ast_post(&usr_sm_group, usr_ast);
+        m0_sm_group_unlock(sm_group);
+}
+
+void be_ts_ast_post_cb(struct m0_sm_group *sm_group, struct m0_sm_ast *ast)
+{
+        printf("be_tx_ast_post_cb id = %x\n", (unsigned int)pthread_self());
+}
 
 void be_ts_cb(struct m0_be_cbinfo *cbinfo, int status, m0_be_msg_type_t msg_type)
 {
@@ -137,10 +169,17 @@ void be_ts_cb(struct m0_be_cbinfo *cbinfo, int status, m0_be_msg_type_t msg_type
                 printf("\n%s - counter : %d completed : %d\n", __FUNCTION__,
                        cbdata->counter, (cbdata->completed) ? 1 : 0);
 
-        if(cbinfo->bc_pcbinfo != NULL && cbinfo->bc_pcbinfo->bc_cb != NULL)
-                m0_be_handler_post(cbinfo->bc_pcbinfo, status, msg_type);
+        if (cbdata->be_usr_ast != NULL) {
+                cbdata->be_usr_ast->bua_status    = status;
+                cbdata->be_usr_ast->bua_msg       = msg_type;
+                cbdata->be_usr_ast->bua_ast.sa_cb = be_ts_ast_post_cb;
+
+                printf("be_ts_cb id = %x\n", (unsigned int)pthread_self());
+                be_usr_ast_post_helper(cbdata->be_usr_ast);
+        }
 }
 
+
 static int ts_be_init(void)   /* ts_ for "test suite" */
 {
         int rc = 0;
@@ -172,6 +211,7 @@ static int ts_be_init(void)   /* ts_ for "test suite" */
         M0_LOG(M0_DEBUG, "Domain create");
         m0_be_domain_create(dom, NULL, log_stob);
         m0_be_domain_init(dom);
+        m0_sm_group_init(&usr_sm_group);
         sm_group = m0_be_domain_sm_group(dom);
         M0_ASSERT(sm_group != NULL);
 
@@ -181,23 +221,23 @@ static int ts_be_init(void)   /* ts_ for "test suite" */
                 M0_ALLOC_PTR(seg);
                 m0_be_seg_init(seg, dom, sm_group, 0);
 
-                bt_cbdata->cbinfo.bc_cb         = be_ts_cb;
-                bt_cbdata->cbinfo.bc_sm_group   = sm_group;
-                bt_cbdata->cbinfo.bc_hq         = &dom->bd_hq;
-                bt_cbdata->cbinfo.bc_pcbinfo    = NULL;
-                bt_cbdata->counter              = 0;
-                bt_cbdata->completed            = false;
+                bt_cbdata->cbinfo.bc_cb             =  be_ts_cb;
+                bt_cbdata->cbinfo.bc_sm_group       =  sm_group;
+                bt_cbdata->cbinfo.bc_hq             = &dom->bd_hq;
+                bt_cbdata->cbinfo.bc_pcbinfo        =  NULL;
+                bt_cbdata->counter                  =  0;
+                bt_cbdata->completed                =  false;
+                M0_ALLOC_PTR(bt_cbdata->be_usr_ast);
+                bt_cbdata->be_usr_ast->bua_sm_group = &usr_sm_group;
 
                 m0_be_seg_create(seg, NULL,  "first", NULL, &bt_cbdata->cbinfo);
+                m0_chan_wait(&usr_sm_group.s_clink);
+                m0_sm_group_lock(&usr_sm_group);
+                m0_sm_asts_run(&usr_sm_group);
+                m0_sm_group_unlock(&usr_sm_group);
         }
 
-        m0_sm_group_lock(sm_group);
-        m0_sm_timedwait(&seg->bs_sm,
-                        (1 << M0_BESEG_ACTIVE) | (1 << M0_BESEG_FAILED),
-                        M0_TIME_NEVER);
-        m0_sm_group_unlock(sm_group);
-
-        while(bt_cbdata->completed == false);
+        /* while(bt_cbdata->completed == false);*/
 
         if (m0_be_seg_state(seg) == M0_BESEG_FAILED) {
                 rc = -1;
@@ -217,22 +257,23 @@ static int ts_be_init(void)   /* ts_ for "test suite" */
         sm_group = m0_be_domain_sm_group(dom);
         M0_ASSERT(sm_group != NULL);
 
-        bt_cbdata->cbinfo.bc_cb         = be_ts_cb;
-        bt_cbdata->cbinfo.bc_sm_group   = sm_group;
-        bt_cbdata->cbinfo.bc_hq         = &dom->bd_hq;
-        bt_cbdata->cbinfo.bc_pcbinfo    = NULL;
-        bt_cbdata->counter              = 10;
-        bt_cbdata->completed            = false;
+        bt_cbdata->cbinfo.bc_cb                    =  be_ts_cb;
+        bt_cbdata->cbinfo.bc_sm_group              =  sm_group;
+        bt_cbdata->cbinfo.bc_hq                    = &dom->bd_hq;
+        bt_cbdata->cbinfo.bc_pcbinfo               =  NULL;
+        bt_cbdata->counter                         =  10;
+        bt_cbdata->completed                       =  false;
+        M0_ALLOC_PTR(bt_cbdata->be_usr_ast);
+        bt_cbdata->be_usr_ast->bua_sm_group         = &usr_sm_group;
 
         M0_ALLOC_PTR(seg);
         M0_ASSERT(seg != NULL);
         m0_be_domain_seg_restore(dom, "first", seg, &bt_cbdata->cbinfo);
 
-        m0_sm_group_lock(sm_group);
-        m0_sm_timedwait(&seg->bs_sm,
-                        (1 << M0_BESEG_ACTIVE) | (1 << M0_BESEG_FAILED),
-                        M0_TIME_NEVER);
-        m0_sm_group_unlock(sm_group);
+        m0_chan_wait(&usr_sm_group.s_clink);
+        m0_sm_group_lock(&usr_sm_group);
+        m0_sm_asts_run(&usr_sm_grp);
+        m0_sm_group_unlock(&usr_sm_group);
 
         while(bt_cbdata->completed == false);
 
@@ -240,6 +281,8 @@ static int ts_be_init(void)   /* ts_ for "test suite" */
                 rc = -1;
         }
 #endif
+
+        m0_free(bt_cbdata->be_usr_ast);
         return rc;
 }
 
@@ -286,20 +329,26 @@ static void test_be_transaction()
         strcpy(reg->br_buf.b_logical_address.be_virtual_address,
                "Be UT - VIRTUAL WORLD");
 
-        bt_cbdata->cbinfo.bc_cb         = be_ts_cb;
-        bt_cbdata->cbinfo.bc_sm_group   = sm_group;
-        bt_cbdata->cbinfo.bc_hq         = &dom->bd_hq;
-        bt_cbdata->cbinfo.bc_pcbinfo    = NULL;
-        bt_cbdata->counter              = 20;
-        bt_cbdata->completed            = false;
+        bt_cbdata->cbinfo.bc_cb              =  be_ts_cb;
+        bt_cbdata->cbinfo.bc_sm_group        =  sm_group;
+        bt_cbdata->cbinfo.bc_hq              = &dom->bd_hq;
+        bt_cbdata->cbinfo.bc_pcbinfo         =  NULL;
+        M0_ALLOC_PTR(bt_cbdata->be_usr_ast);
+        bt_cbdata->be_usr_ast->bua_sm_group   = &usr_sm_group;
+
+        bt_cbdata->counter                =  20;
+        bt_cbdata->completed              =  false;
 
         m0_be_tx_done(tx, &bt_cbdata->cbinfo);
 
-        while(bt_cbdata->completed == false);
+        m0_chan_wait(&usr_sm_group.s_clink);
+        m0_sm_group_lock(&usr_sm_group);
+        m0_sm_asts_run(&usr_sm_group);
+        m0_sm_group_unlock(&usr_sm_group);
+        m0_free(bt_cbdata->be_usr_ast);
 
         m0_be_tx_fini(tx);
 
-
         m0_free(buf);
         m0_free(reg);
         m0_free(tx);
-- 
1.8.3.2

