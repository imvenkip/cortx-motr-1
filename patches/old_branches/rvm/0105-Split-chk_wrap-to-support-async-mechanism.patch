From 1c1df9999a7b0e287a1cc37269dec2e118eec5bb Mon Sep 17 00:00:00 2001
From: Sachin Patil <sachin_patil@xyratex.com>
Date: Thu, 30 May 2013 00:51:54 -0700
Subject: [PATCH 105/121] Split chk_wrap to support async mechanism.

UT will not work unless chk_wrap receives cbinfo from the caller.
---
 rvm/rvm_logrecovr.c | 426 +++++++++++++++++++++++++++++++++++++---------------
 rvm/rvm_private.h   |  14 ++
 2 files changed, 317 insertions(+), 123 deletions(-)

diff --git a/rvm/rvm_logrecovr.c b/rvm/rvm_logrecovr.c
index b3b7978..337f706 100644
--- a/rvm/rvm_logrecovr.c
+++ b/rvm/rvm_logrecovr.c
@@ -2234,144 +2234,324 @@ static rvm_return_t do_trans(log,skip_trans)
     if (num_ranges != 0) assert(prev_range == 1);
 
     return RVM_SUCCESS;
-    }
-/* log wrap-around validation */
-static rvm_return_t chk_wrap(log,force_wrap_chk,skip_trans)
-    log_t           *log;               /* log descriptor */
-    rvm_bool_t      force_wrap_chk;     /* wrap check required if true */
-    rvm_bool_t      *skip_trans;        /* set true if bad split */
-    {
-    log_status_t    *status = &log->status; /* status descriptor */
-    log_buf_t       *log_buf = &log->log_buf; /* log buffer descriptor */
-    rvm_offset_t    offset;             /* offset temp */
-    rvm_offset_t    end_offset;         /* offset of last trans end marker */
-    rec_end_t       *rec_end;           /* last record scanned in buffer */
-    trans_hdr_t     last_trans_hdr;     /* last transaction record header */
-    trans_hdr_t     *trans_hdr;         /* header temporary */
-    log_wrap_t      *log_wrap;          /* wrap-around marker */
-    long            tmp_ptr;            /* buffer index temp */
-    long            data_len;           /* length temporary */
-    rvm_return_t    retval;             /* return value */
+}
 
-    *skip_trans = rvm_false;
-    rec_end = (rec_end_t *)&log_buf->buf[log_buf->ptr];
-    offset = RVM_ADD_LENGTH_TO_OFFSET(log_buf->offset,log_buf->ptr);
-    offset = RVM_SUB_LENGTH_FROM_OFFSET(offset,rec_end->rec_hdr.rec_length);
+M0_INTERNAL void cw_init_buffer_cb(struct m0_be_cbinfo *cbinfo,
+				   int 		 	be_status,
+				   m0_be_msg_type_t  	msg_type)
+{
+	log_t			*log;
+	chk_wrap_cbdata_t	*cw_cbdata;
+	log_status_t    	*status; 	/* status descriptor. */
+	log_buf_t       	*log_buf; 	/* log buffer descriptor. */
 
-    /* check if transaction header is at start of log data area */
-    if (!RVM_OFFSET_EQL(offset,status->log_start) && (!force_wrap_chk))
-        return RVM_SUCCESS;             /* no, nothing more needed */
+	cw_cbdata = container_of(cbinfo, chk_wrap_cbdata_t, cwc_cbinfo);
 
-    /* get header */
-    if (force_wrap_chk)
-        {
-        /* header can be anywhere */
-        if (RVM_OFFSET_LSS(offset,log_buf->offset))
-            {
-            retval = load_aux_buf(log,&offset,sizeof(trans_hdr_t),
-                                  &tmp_ptr,&data_len,SYNCH,rvm_false);
-            if (retval != RVM_SUCCESS) return retval;
-            assert(log->trunc_thread == cthread_self());
-            assert((status->trunc_state & RVM_TRUNC_PHASES)
-                   == RVM_TRUNC_BUILD_TREE);
-            assert(data_len >= sizeof(trans_hdr_t));
-            trans_hdr = (trans_hdr_t *)&log_buf->aux_buf[tmp_ptr];
-            }
-        else
-            trans_hdr = (trans_hdr_t *)&log_buf->buf[log_buf->ptr
-                                                -rec_end->rec_hdr.rec_length];
+	log	= cw_cbdata->cwc_log;
+	status	= &log->status;
+	log_buf	= &log->log_buf;
+
+	assert(log->trunc_thread == cthread_self());
+	assert((status->trunc_state & RVM_TRUNC_PHASES) == RVM_TRUNC_BUILD_TREE);
+	log_buf->ptr -= sizeof(rec_end_t);
+	log_buf->split_ok = rvm_true;
+
+	if (cbinfo->bc_pcbinfo != NULL && cbinfo->bc_pcbinfo->bc_cb != NULL) {
+                m0_be_handler_post(cbinfo->bc_pcbinfo, be_status, msg_type);
         }
-    else
-        /* header is at start of aux_buf or recovery buffer */
-        if (RVM_OFFSET_LSS(offset,log_buf->offset))
-            trans_hdr = (trans_hdr_t *)log_buf->aux_buf;
-        else
-            trans_hdr = (trans_hdr_t *)log_buf->buf;
+	m0_free(cw_cbdata);
+}
 
-    /* check for split transaction */
-    assert(trans_hdr->rec_hdr.struct_id == trans_hdr_id);
-    if (TRANS_HDR(FIRST_ENTRY_FLAG)
-        && TRANS_HDR(LAST_ENTRY_FLAG))
-        return RVM_SUCCESS;             /* not split, nothing more needed */
+M0_INTERNAL void cw_scan_reverse_cb1(struct m0_be_cbinfo *cbinfo,
+				    int 		  be_status,
+				    m0_be_msg_type_t  	  msg_type)
+{
+	log_t			*log;
+	chk_wrap_cbdata_t	*cw_cbdata;
 
-    /* split, see if must check further or skip record */
-    assert(TRANS_HDR(FIRST_ENTRY_FLAG) || TRANS_HDR(LAST_ENTRY_FLAG));
-    if (!TRANS_HDR(LAST_ENTRY_FLAG))
-        {
-        if (log_buf->split_ok)
-            {                           /* split previously checked */
-            log_buf->split_ok = rvm_false;
-            return RVM_SUCCESS;
-            }
-        if (force_wrap_chk)             /* if not last entry, trans not good */
-            {
-            *skip_trans = rvm_true;
-            return RVM_SUCCESS;
-            }
+	log_status_t    	*status; 		/* status descriptor */
+	log_buf_t       	*log_buf; 		/* log buffer descriptor */
+	rvm_offset_t    	 offset;             	/* offset temp */
+	rec_end_t       	*rec_end;           	/* last record scanned in buffer */
+	trans_hdr_t     	*last_trans_hdr;     	/* last transaction record header */
+	trans_hdr_t     	*trans_hdr;         	/* header temporary */
+	rvm_return_t    	 retval;             	/* return value */
+
+	cw_cbdata = container_of(cbinfo, chk_wrap_cbdata_t, cwc_cbinfo);
+
+	log	= cw_cbdata->cwc_log;
+	status	= &log->status;
+	log_buf	= &log->log_buf;
+
+	last_trans_hdr 	= &cw_cbdata->cwc_last_trans_hdr;
+
+	rec_end = (rec_end_t *)&log_buf->buf[log_buf->ptr];
+
+	assert(log->trunc_thread == cthread_self());
+	assert((status->trunc_state & RVM_TRUNC_PHASES) == RVM_TRUNC_BUILD_TREE);
+	assert((long)log_buf->ptr >= 0);
+	assert(rec_end->rec_hdr.struct_id == rec_end_id);
+
+	/* check if the header is the first record of last transaction */
+	offset 	= RVM_ADD_LENGTH_TO_OFFSET(log_buf->offset, log_buf->ptr);
+	offset 	= RVM_SUB_LENGTH_FROM_OFFSET(offset, rec_end->rec_hdr.rec_length);
+
+	if (RVM_OFFSET_LSS(offset, log_buf->offset)) {
+		/* header is in aux_buf */
+		cw_cbdata->cwc_tmp_ptr   = OFFSET_TO_SECTOR_INDEX(offset);
+		trans_hdr = (trans_hdr_t *)&log_buf->aux_buf[cw_cbdata->cwc_tmp_ptr];
+	}
+	else {
+		/* header is in recovery buffer */
+		cw_cbdata->cwc_tmp_ptr = RVM_OFFSET_TO_LENGTH(
+					 RVM_SUB_OFFSETS(offset,
+							 log_buf->offset));
+		assert(cw_cbdata->cwc_tmp_ptr >= 0);
+		trans_hdr = (trans_hdr_t *)&log_buf->buf[cw_cbdata->cwc_tmp_ptr];
+	}
+
+	/* sanity checks... */
+	assert(trans_hdr->rec_hdr.struct_id == trans_hdr_id);
+	assert(TRANS_HDR(FIRST_ENTRY_FLAG));
+	assert(TIME_EQL(trans_hdr->uname, last_trans_hdr->uname));
+	assert(trans_hdr->rec_hdr.rec_num == (last_trans_hdr->rec_hdr.rec_num - 2));
+
+	/* all is well, restore last transaction record */
+	log_buf->prev_rec_num = 0;
+	ZERO_TIME(log_buf->prev_timestamp);
+
+	cbinfo->bc_cb = cw_init_buffer_cb;
+
+	retval = init_buffer(log, &cw_cbdata->cwc_end_offset, REVERSE, SYNCH);
+
+	if (retval != RVM_SUCCESS) {
+		be_status = -1;
+		msg_type  = retval;
+	}
+
+	if (be_status != 0 && cbinfo->bc_pcbinfo != NULL &&
+	    cbinfo->bc_pcbinfo->bc_cb != NULL) {
+                m0_be_handler_post(cbinfo->bc_pcbinfo, be_status, msg_type);
+                m0_free(cw_cbdata);
         }
+}
 
-    /* must make local copy and scan for first record of transaction */
-    end_offset = RVM_ADD_LENGTH_TO_OFFSET(log_buf->offset,
-                                (log_buf->ptr+sizeof(rec_end_t)));
-    (void)BCOPY(trans_hdr,&last_trans_hdr,sizeof(trans_hdr_t));
-    if ((retval=scan_reverse(log,SYNCH)) != RVM_SUCCESS)
-        return retval;
-    assert(log->trunc_thread == cthread_self());
-    assert((status->trunc_state & RVM_TRUNC_PHASES)
-           == RVM_TRUNC_BUILD_TREE);
+M0_INTERNAL void cw_scan_reverse_cb(struct m0_be_cbinfo *cbinfo,
+				    int 		 be_status,
+				    m0_be_msg_type_t  	 msg_type)
+{
+	log_t			*log;
+	log_status_t    	*status; 			/* status descriptor */
+	log_buf_t       	*log_buf; 			/* log buffer descriptor */
+	trans_hdr_t     	*last_trans_hdr;     		/* last transaction record header */
+	log_wrap_t      	*log_wrap;          		/* wrap-around marker */
+	rvm_return_t    	 retval;             		/* return value */
 
-    /* wrap-around had better be next... */
-    assert((long)log_buf->ptr >= 0);
-    log_wrap = (log_wrap_t *)&log_buf->buf[log_buf->ptr];
-    assert(log_wrap->rec_hdr.struct_id == log_wrap_id);
-    assert(log_wrap->rec_hdr.rec_num == (last_trans_hdr.rec_hdr.rec_num-1));
+	chk_wrap_cbdata_t	*cw_cbdata;
 
-    /* now scan for first record of transaction */
-    if ((retval=scan_reverse(log,SYNCH)) != RVM_SUCCESS)
-        return retval;
-    assert(log->trunc_thread == cthread_self());
-    assert((status->trunc_state & RVM_TRUNC_PHASES)
-           == RVM_TRUNC_BUILD_TREE);
-    assert((long)log_buf->ptr >= 0);
-    rec_end = (rec_end_t *)&log_buf->buf[log_buf->ptr];
-    assert(rec_end->rec_hdr.struct_id == rec_end_id);
-    /* check if the header is the first record of last transaction */
-    offset = RVM_ADD_LENGTH_TO_OFFSET(log_buf->offset,log_buf->ptr);
-    offset = RVM_SUB_LENGTH_FROM_OFFSET(offset,rec_end->rec_hdr.rec_length);
-    if (RVM_OFFSET_LSS(offset,log_buf->offset))
-        {
-        /* header is in aux_buf */
-        tmp_ptr = OFFSET_TO_SECTOR_INDEX(offset);
-        trans_hdr = (trans_hdr_t *)&log_buf->aux_buf[tmp_ptr];
+	cw_cbdata = container_of(cbinfo, chk_wrap_cbdata_t, cwc_cbinfo);
+
+        log     = cw_cbdata->cwc_log;
+        status  = &log->status;
+        log_buf = &log->log_buf;
+
+	last_trans_hdr 	= &cw_cbdata->cwc_last_trans_hdr;
+
+	assert(log->trunc_thread == cthread_self());
+	assert((status->trunc_state & RVM_TRUNC_PHASES) == RVM_TRUNC_BUILD_TREE);
+
+	/* wrap-around had better be next... */
+	assert((long)log_buf->ptr >= 0);
+	log_wrap = (log_wrap_t *)&log_buf->buf[log_buf->ptr];
+	assert(log_wrap->rec_hdr.struct_id == log_wrap_id);
+	assert(log_wrap->rec_hdr.rec_num == (last_trans_hdr->rec_hdr.rec_num-1));
+
+	cbinfo->bc_cb = cw_scan_reverse_cb1;
+
+	/* now scan for first record of transaction */
+	if ((retval = scan_reverse(log, SYNCH)) != RVM_SUCCESS) {
+		be_status = -1;
+		msg_type  = retval;
+	}
+
+	if (be_status != 0 && cbinfo->bc_pcbinfo != NULL &&
+	    cbinfo->bc_pcbinfo->bc_cb != NULL) {
+                m0_be_handler_post(cbinfo->bc_pcbinfo, be_status, msg_type);
+                m0_free(cw_cbdata);
         }
-    else
-        {
-        /* header is in recovery buffer */
-        tmp_ptr = RVM_OFFSET_TO_LENGTH(RVM_SUB_OFFSETS(offset,
-                                           log_buf->offset));
-        assert(tmp_ptr >= 0);
-        trans_hdr = (trans_hdr_t *)&log_buf->buf[tmp_ptr];
+}
+
+M0_INTERNAL void cw_load_aux_buf_cb(struct m0_be_cbinfo *cbinfo,
+				    int 		 be_status,
+				    m0_be_msg_type_t  	 msg_type)
+{
+	log_t			*log;
+	log_status_t    	*status; 			/* status descriptor */
+	log_buf_t       	*log_buf; 			/* log buffer descriptor */
+	trans_hdr_t     	*last_trans_hdr;     		/* last transaction record header */
+	trans_hdr_t     	*trans_hdr;         		/* header temporary */
+	long            	 tmp_ptr;            		/* buffer index temp */
+	long            	*data_len;           		/* length temporary */
+	rvm_return_t    	 retval;             		/* return value */
+	rvm_bool_t      	 force_wrap_chk; 		/* wrap check required if true */
+	rvm_bool_t		*skip_trans;
+
+	chk_wrap_cbdata_t	*cw_cbdata;
+	rvm_bool_t		 post_parent = rvm_false;
+
+	cw_cbdata = container_of(cbinfo, chk_wrap_cbdata_t, cwc_cbinfo);
+
+        log     = cw_cbdata->cwc_log;
+        status  = &log->status;
+        log_buf = &log->log_buf;
+
+	data_len 	= &cw_cbdata->cwc_data_len;
+	force_wrap_chk 	= cw_cbdata->cwc_force_wrap_chk;
+	tmp_ptr		= cw_cbdata->cwc_tmp_ptr;
+
+	skip_trans 	= cw_cbdata->cwc_skip_trans;
+	last_trans_hdr 	= &cw_cbdata->cwc_last_trans_hdr;
+
+	if (cw_cbdata->cwc_lab_called) {
+		assert(log->trunc_thread == cthread_self());
+		assert((status->trunc_state & RVM_TRUNC_PHASES) == RVM_TRUNC_BUILD_TREE);
+		assert(*data_len >= sizeof(trans_hdr_t));
+		cw_cbdata->cwc_trans_hdr = (trans_hdr_t *)
+					   &log_buf->aux_buf[tmp_ptr];
+	}
+
+	trans_hdr = cw_cbdata->cwc_trans_hdr;	/* header temporary */
+
+	/* check for split transaction */
+	assert(trans_hdr->rec_hdr.struct_id == trans_hdr_id);
+	if (TRANS_HDR(FIRST_ENTRY_FLAG) && TRANS_HDR(LAST_ENTRY_FLAG)) {
+		be_status = 0;
+		msg_type  =  retval = RVM_SUCCESS;
+		post_parent = rvm_true;
+		goto exit; /* not split, nothing more needed */
+	}
+
+	/* split, see if must check further or skip record */
+	assert(TRANS_HDR(FIRST_ENTRY_FLAG) || TRANS_HDR(LAST_ENTRY_FLAG));
+	if (!TRANS_HDR(LAST_ENTRY_FLAG)) {
+		if (log_buf->split_ok) { /* split previously checked */
+			log_buf->split_ok = rvm_false;
+			be_status = 0;
+			msg_type = retval = RVM_SUCCESS;
+			post_parent = rvm_true;
+			goto exit;
+		}
+		if (force_wrap_chk) { /* if not last entry, trans not good */
+			*skip_trans = rvm_true;
+			be_status = 0;
+			msg_type = retval = RVM_SUCCESS;
+			post_parent = rvm_true;
+			goto exit;
+		}
+	}
+
+	/* must make local copy and scan for first record of transaction */
+	cw_cbdata->cwc_end_offset = RVM_ADD_LENGTH_TO_OFFSET(log_buf->offset,
+							     (log_buf->ptr +
+							      sizeof(rec_end_t)));
+
+	(void)BCOPY(trans_hdr, last_trans_hdr, sizeof(trans_hdr_t));
+
+	cbinfo->bc_cb = cw_scan_reverse_cb;
+
+	if ((retval = scan_reverse(log, SYNCH)) != RVM_SUCCESS) {
+		be_status = -1;
+		msg_type  = retval;
+	}
+exit:
+	if ((be_status != 0 || post_parent) && cbinfo->bc_pcbinfo != NULL &&
+	    cbinfo->bc_pcbinfo->bc_cb != NULL) {
+                m0_be_handler_post(cbinfo->bc_pcbinfo, be_status, msg_type);
+                m0_free(cw_cbdata);
         }
+}
 
-    /* sanity checks... */
-    assert(trans_hdr->rec_hdr.struct_id == trans_hdr_id);
-    assert(TRANS_HDR(FIRST_ENTRY_FLAG));
-    assert(TIME_EQL(trans_hdr->uname,last_trans_hdr.uname));
-    assert(trans_hdr->rec_hdr.rec_num == (last_trans_hdr.rec_hdr.rec_num-2));
+/* log wrap-around validation */
+static rvm_return_t chk_wrap(log, force_wrap_chk, skip_trans, cbinfo)
+	log_t           	*log;            		/* log descriptor */
+	rvm_bool_t      	 force_wrap_chk; 		/* wrap check required if true */
+	rvm_bool_t      	*skip_trans;     		/* set true if bad split */
+	struct m0_be_cbinfo 	*cbinfo;
+{
+	log_status_t    	*status = &log->status; 	/* status descriptor */
+	log_buf_t       	*log_buf = &log->log_buf; 	/* log buffer descriptor */
+	rvm_offset_t    	 offset;             		/* offset temp */
+	rec_end_t       	*rec_end;           		/* last record scanned in buffer */
+	long            	*data_len;           		/* length temporary */
+	rvm_return_t    	 retval;             		/* return value */
 
-    /* all is well, restore last transaction record */
-    log_buf->prev_rec_num = 0;
-    ZERO_TIME(log_buf->prev_timestamp);
-    if ((retval=init_buffer(log,&end_offset,REVERSE,SYNCH))
-        != RVM_SUCCESS) return retval;
-    assert(log->trunc_thread == cthread_self());
-    assert((status->trunc_state & RVM_TRUNC_PHASES)
-           == RVM_TRUNC_BUILD_TREE);
-    log_buf->ptr -= sizeof(rec_end_t);
-    log_buf->split_ok = rvm_true;
+	int			 be_status = 0;
+	m0_be_msg_type_t 	 msg_type  = M0_BE_SUCCESS;
+	chk_wrap_cbdata_t	*cw_cbdata;
+	struct m0_be_cbinfo	*cwc_cbinfo;
+	rvm_bool_t		 post_parent = rvm_false;
+
+	M0_ALLOC_PTR(cw_cbdata);
+	M0_ASSERT(cw_cbdata != NULL);
+
+	cwc_cbinfo = &cw_cbdata->cwc_cbinfo;
+	data_len = &cw_cbdata->cwc_data_len;
+
+	cw_cbdata->cwc_log 	      = log;
+	cw_cbdata->cwc_force_wrap_chk = force_wrap_chk;
+	cw_cbdata->cwc_skip_trans     = skip_trans;
+
+	*cw_cbdata->cwc_skip_trans     = rvm_false;
+
+	rec_end 	= (rec_end_t *)&log_buf->buf[log_buf->ptr];
+	offset 		= RVM_ADD_LENGTH_TO_OFFSET(log_buf->offset,log_buf->ptr);
+	offset 		= RVM_SUB_LENGTH_FROM_OFFSET(offset,rec_end->rec_hdr.rec_length);
+
+	m0_be_cbinfo_copy_helper(cbinfo, cwc_cbinfo, cw_load_aux_buf_cb);
+
+	/* check if transaction header is at start of log data area */
+	if (!RVM_OFFSET_EQL(offset,status->log_start) && (!force_wrap_chk)) {
+		be_status = 0;
+		msg_type  = retval = RVM_SUCCESS;
+		post_parent = rvm_true;
+		goto exit;
+	}
+
+	/* get header */
+	if (force_wrap_chk) {
+		/* header can be anywhere */
+		if (RVM_OFFSET_LSS(offset, log_buf->offset)) {
+			retval = load_aux_buf(log,&offset,sizeof(trans_hdr_t),
+					      &cw_cbdata->cwc_tmp_ptr, data_len,
+					      SYNCH, rvm_false);
+
+			if (retval != RVM_SUCCESS) {
+				be_status = -1;
+				msg_type = retval;
+				goto exit;
+			}
+			cw_cbdata->cwc_lab_called = rvm_true;
+		}
+		else {
+			cw_cbdata->cwc_trans_hdr = (trans_hdr_t *)&log_buf->buf[log_buf->ptr - rec_end->rec_hdr.rec_length];
+		}
+	}
+	else {
+	/* header is at start of aux_buf or recovery buffer */
+		if (RVM_OFFSET_LSS(offset,log_buf->offset))
+			cw_cbdata->cwc_trans_hdr = (trans_hdr_t *)log_buf->aux_buf;
+		else
+			cw_cbdata->cwc_trans_hdr = (trans_hdr_t *)log_buf->buf;
+	}
+exit:
+	if ((be_status != 0 || post_parent) && cbinfo != NULL && cbinfo->bc_cb != NULL) {
+		m0_be_handler_post(cbinfo, be_status, msg_type);
+                m0_free(cw_cbdata);
+        }
+
+	return retval;
+}
 
-    return RVM_SUCCESS;
-    }
 /* Recovery: phase 2 -- build modification trees, and
    construct dictionary of segment short names
 */
diff --git a/rvm/rvm_private.h b/rvm/rvm_private.h
index cc16b52..e70f02d 100644
--- a/rvm/rvm_private.h
+++ b/rvm/rvm_private.h
@@ -1891,6 +1891,20 @@ typedef struct loc_tail_cbdata {
 	struct timeval           ltc_save_last_trunc;
 } loc_tail_cbdata_t;
 
+typedef struct chk_wrap_cbdata {
+	struct m0_be_cbinfo	 cwc_cbinfo;
+	log_t			*cwc_log;
+	trans_hdr_t             *cwc_trans_hdr;
+	rvm_bool_t		*cwc_skip_trans;
+	trans_hdr_t		 cwc_last_trans_hdr;
+	/* load_aux_buf called. */
+	rvm_bool_t		 cwc_lab_called;
+	rvm_bool_t		 cwc_force_wrap_chk;
+	long			 cwc_data_len;
+	long			 cwc_tmp_ptr;
+	rvm_offset_t		 cwc_end_offset;
+} chk_wrap_cbdata_t;
+
 void rvm_initialize_cb(struct m0_be_cbinfo *cbinfo, int status,
                        m0_be_msg_type_t msg_type);
 
-- 
1.8.3.2

