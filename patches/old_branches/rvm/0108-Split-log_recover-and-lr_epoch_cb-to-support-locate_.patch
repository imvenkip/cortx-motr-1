From f5e13284ebec49221359417326a6f35fea2f73ae Mon Sep 17 00:00:00 2001
From: Zishan Shaikh <zishan_shaikh@xyratex.com>
Date: Fri, 31 May 2013 00:02:03 -0700
Subject: [PATCH 108/121] Split log_recover and lr_epoch_cb to support
 locate_tail and build_tree asynch mechanism.

---
 rvm/rvm_logrecovr.c | 636 +++++++++++++++++++++++++++++-----------------------
 rvm/rvm_private.h   |   2 +-
 2 files changed, 354 insertions(+), 284 deletions(-)

diff --git a/rvm/rvm_logrecovr.c b/rvm/rvm_logrecovr.c
index ad88d68..13a0bc5 100644
--- a/rvm/rvm_logrecovr.c
+++ b/rvm/rvm_logrecovr.c
@@ -215,9 +215,8 @@ void init_buffer_cb(cbinfo, status, msg)
 
 	assert(log->trunc_thread == cthread_self());
 exit:
-	/********************************************** UNCOMMENT ***************************************/
-	/*if (cbinfo->bc_pcbinfo != NULL && cbinfo->bc_pcbinfo->bc_cb != NULL)*/
-	/*m0_be_handler_post(cbinfo->bc_pcbinfo, status, msg);*/
+	if (cbinfo->bc_pcbinfo != NULL && cbinfo->bc_pcbinfo->bc_cb != NULL)
+		m0_be_handler_post(cbinfo->bc_pcbinfo, status, msg);
 
 	m0_free(lrc_cbdata);
 }
@@ -251,8 +250,7 @@ rvm_return_t init_buffer(log, offset, direction, synch, cbinfo)
 	lrc_cbdata->lrc_log   =  log;
 	lrc_cbdata->lrc_synch =  synch;
 	lrc_cbinfo	      = &lrc_cbdata->lrc_cbinfo;
-	/************************ UNCOMMENT THIS. ***************************************************/
-	/*m0_be_cbinfo_copy_helper(cbinfo, lrc_cbinfo, init_buffer_cb);*/
+	m0_be_cbinfo_copy_helper(cbinfo, lrc_cbinfo, init_buffer_cb);
 
 	assert(RVM_OFFSET_GEQ(*offset, log->status.log_start));
 	assert(RVM_OFFSET_LEQ(*offset, log->dev.num_bytes));
@@ -306,10 +304,10 @@ rvm_return_t init_buffer(log, offset, direction, synch, cbinfo)
 		assert(log->trunc_thread == cthread_self());
 	}
 
-	 /************************ REPLCAE WITH read_dev_new  and pass lrc_cbinfo**********/
 	/* read data from log device */
-	if ((log_buf->r_length = read_dev_old(&log->dev, &log_buf->offset,
-					      log_buf->buf, length)) < 0) {
+	log_buf->r_length = read_dev(&log->dev, &log_buf->offset, log_buf->buf,
+				     length, lrc_cbinfo);
+	if (log_buf->r_length < 0) {
 		retval 		  =  RVM_EIO;               /* i/o error */
 		log_buf->r_length =  0;          /* buffer invalid */
 		be_status 	  = -1;
@@ -322,8 +320,6 @@ exit:
 		m0_free(lrc_cbdata);
 	}
 
-	/*************************** REMOVE THIS **********************************************/
-	init_buffer_cb(lrc_cbinfo, be_status, msg);
 	return retval;
 }
 
@@ -5127,6 +5123,39 @@ exit:
 	return retval;
 }
 
+void wake_up_waiting_threads(log_t *log, rvm_bool_t is_daemon,
+			     log_daemon_t *daemon, rvm_return_t err_status)
+{
+        log_status_t    *status = &log->status;
+	printf("\n function %s\n", __FUNCTION__);
+
+	/* Wake up waiting threads if any. */
+        CRITICAL(log->truncation_lock,   /* begin truncation lock crit sec */
+	{
+                /* wake up any threads waiting on a truncation */
+                assert(log->trunc_thread == cthread_self());
+                CRITICAL(daemon->lock,        /* begin daemon->lock crit sec */
+                {
+                        assert(log->trunc_thread == cthread_self());
+                        if (is_daemon) {
+				assert(log->daemon.thread == cthread_self());
+				assert((status->trunc_state &
+					RVM_ASYNC_TRUNCATE) != 0);
+
+				assert(daemon->state == truncating);
+				if (err_status != RVM_SUCCESS)
+					daemon->state = error;
+                        }
+
+                        assert(log->trunc_thread == cthread_self());
+                }); /* end daemon->lock crit sec */
+
+                log->trunc_thread   = (cthread_t)NULL;
+                status->trunc_state = ZERO;
+        }); /* end truncation lock crit sec */
+}
+
+
 void status_update_cb(cbinfo, be_status, msg)
         struct m0_be_cbinfo  *cbinfo;
         int                   be_status;
@@ -5163,29 +5192,10 @@ void status_update_cb(cbinfo, be_status, msg)
                 assert(log->trunc_thread == cthread_self());
                 assert((status->trunc_state & RVM_TRUNC_PHASES) ==
                        RVM_TRUNC_UPDATE);
-
-                /* wake up any threads waiting on a truncation */
-                assert(log->trunc_thread == cthread_self());
-                CRITICAL(daemon->lock, /* begin daemon->lock crit sec */
-                {
-                        assert(log->trunc_thread == cthread_self());
-                        if (is_daemon) {
-                                assert(log->daemon.thread == cthread_self());
-                                assert((status->trunc_state &
-                                        RVM_ASYNC_TRUNCATE) != 0);
-
-                                assert(daemon->state == truncating);
-                                if (retval != RVM_SUCCESS)
-                                        daemon->state = error;
-                        }
-
-                        assert(log->trunc_thread == cthread_self());
-                }); /* end daemon->lock crit sec */
-
-                log->trunc_thread   = (cthread_t)NULL;
-                status->trunc_state = ZERO;
         });
 
+	wake_up_waiting_threads(log, is_daemon, daemon, retval);
+
 exit:
         if (cbinfo->bc_pcbinfo != NULL &&
             cbinfo->bc_pcbinfo->bc_cb != NULL) {
@@ -5277,7 +5287,7 @@ exit:
 }
 
 
-void lr_epoch_cb(cbinfo, be_status, msg)
+void lr_build_tree_cb(cbinfo, be_status, msg)
 	struct m0_be_cbinfo	*cbinfo;
 	int			 be_status;
 	m0_be_msg_type_t	 msg;
@@ -5289,6 +5299,80 @@ void lr_epoch_cb(cbinfo, be_status, msg)
         struct timeval       end_time;
         struct timeval       tmp_time;
         int                  kretval;
+	rvm_bool_t           is_daemon;
+        rvm_return_t         retval;
+
+	if (be_status != 0)
+		goto exit_log_recover;
+
+	lrc_cbdata      = container_of(cbinfo, lrc_cbdata_t, lrc_cbinfo);
+	log	        = lrc_cbdata->lrc_log;
+	is_daemon	= lrc_cbdata->lrc_is_daemon;
+	status	        = &log->status;
+	daemon	        = &log->daemon;
+
+        CRITICAL(log->truncation_lock,      /* begin truncation lock crit sec */
+	{
+		assert(log->trunc_thread == cthread_self());
+		assert((status->trunc_state & RVM_TRUNC_PHASES) ==
+		       RVM_TRUNC_BUILD_TREE);
+
+		kretval= gettimeofday(&end_time, (struct timezone *)NULL);
+		if (kretval != 0)
+			/* return RVM_EIO; */
+			assert(0);
+
+		end_time = sub_times(&end_time,&tmp_time);
+		last_tree_build_time = round_time(&end_time);
+
+		/* test for interrupt */
+		if (rvm_chk_sigint != NULL)
+			if ((*rvm_chk_sigint)(NULL))
+				goto err_exit;
+
+		/* apply tree and time */
+		kretval= gettimeofday(&tmp_time, (struct timezone *)NULL);
+		if (kretval != 0)
+			/* return RVM_EIO; */
+			assert(0);
+
+		/* status update is not done yet! */
+		lrc_cbdata->lrc_is_update_done = rvm_false;
+		X(apply_mods)
+		/* phase 3 */
+		cbinfo->bc_cb = log_recover_cb;
+		if ((retval = apply_mods(log, cbinfo)) != RVM_SUCCESS) {
+			be_status = -1;
+			msg	  = retval;
+			goto err_exit;
+		}
+		X(apply_mods end)
+	});
+
+err_exit:
+	assert(log->trunc_thread == cthread_self());
+	wake_up_waiting_threads(log, is_daemon, daemon, retval);
+
+exit_log_recover:
+	if (be_status != 0  && cbinfo->bc_pcbinfo != NULL &&
+	    cbinfo->bc_pcbinfo->bc_cb != NULL) {
+		m0_be_handler_post(cbinfo->bc_pcbinfo,
+				   be_status, msg);
+		m0_free(lrc_cbdata);
+	}
+}
+
+void lr_epoch_cb(cbinfo, be_status, msg)
+	struct m0_be_cbinfo	*cbinfo;
+	int			 be_status;
+	m0_be_msg_type_t	 msg;
+{
+	lrc_cbdata_t        *lrc_cbdata;
+	log_t		    *log;
+        log_status_t        *status;
+        log_daemon_t        *daemon;
+        struct timeval       tmp_time;
+        int                  kretval;
         rvm_bool_t           do_truncation;
 	rvm_bool_t           is_daemon;
         rvm_return_t         retval;
@@ -5306,155 +5390,212 @@ void lr_epoch_cb(cbinfo, be_status, msg)
 	new_1st_rec_num = lrc_cbdata->lrc_recnr;
 
         CRITICAL(log->truncation_lock,      /* begin truncation lock crit sec */
+	{
+		if(lrc_cbdata->lrc_is_epoch_done == rvm_true) {
+			CRITICAL(log->dev_lock,
+			{
+				/* has to be checked only if new_epoch */
+				assert(log->trunc_thread == cthread_self());
+			});
+		}
+
+		CRITICAL(log->dev_lock, /* begin dev_lock crit sec */
 		{
-			if(lrc_cbdata->lrc_is_epoch_done == rvm_true) {
-				CRITICAL(log->dev_lock,
-				{
-					/* has to be checked only if new_epoch */
-					assert(log->trunc_thread ==
-					       cthread_self());
-				});
+			/*
+			 * signal `initiate_truncation' that the first
+			 * part is done.
+			 */
+			if (is_daemon) {
+				mutex_lock(&daemon->lock);
+				assert(log->daemon.thread == cthread_self());
+				assert(daemon->state == truncating);
+				assert((status->trunc_state &
+				       RVM_ASYNC_TRUNCATE) != 0);
+				condition_signal(&daemon->flush_flag);
+				mutex_unlock(&daemon->lock);
 			}
+		});
 
-			CRITICAL(log->dev_lock, /* begin dev_lock crit sec */
-			{
-				/*
-				 * signal `initiate_truncation' that the first
-				 * part is done.
-				 */
-				if (is_daemon) {
-					mutex_lock(&daemon->lock);
-					assert(log->daemon.thread ==
-					       cthread_self());
-					assert(daemon->state == truncating);
-					assert((status->trunc_state &
-					       RVM_ASYNC_TRUNCATE) != 0);
-					condition_signal(&daemon->flush_flag);
-					mutex_unlock(&daemon->lock);
-				}
-			});
+		/* test for interrupt */
+		if (rvm_chk_sigint != NULL)
+			if ((*rvm_chk_sigint)(NULL)) {
+				be_status = -1;
+				goto err_exit;
+			}
 
-			/* test for interrupt */
-			if (rvm_chk_sigint != NULL)
-				if ((*rvm_chk_sigint)(NULL)) {
-					be_status = -1;
-					goto err_exit;
-				}
+		lrc_cbdata->lrc_recnr = new_1st_rec_num;
+
+		/* do log scan if truncation actually needed */
+		if (do_truncation) {
+			printf("\nin if in %s\n", __FUNCTION__);
+			X(do_trunc)
+			/* build tree and time */
+			kretval= gettimeofday(&tmp_time,
+					      (struct timezone *)NULL);
+			if (kretval != 0)
+				/* return RVM_EIO; */
+				assert(0);
+
+			cbinfo->bc_cb = lr_build_tree_cb;
+			X(build_tree)
+			/* phase 2 */
+			if ((retval = build_tree(log, cbinfo)) != RVM_SUCCESS) {
+				printf("\n CRITICAL, build_tree failed! \n");
+				be_status = -1;
+				msg	  =  retval;
+				goto err_exit;
+			}
+			X(build_tree done)
+			goto exit_log_recover;
 
-			lrc_cbdata->lrc_recnr = new_1st_rec_num;
-			cbinfo->bc_cb	      = log_recover_cb;
+		} else {
+			status->trunc_state = (status->trunc_state &
+					       (~RVM_TRUNC_PHASES)) |
+					      RVM_TRUNC_APPLY;
 
-			/*m0_be_cbinfo_copy_helper(cbinfo, lrc_cbinfo,*/
-			/*log_recover_cb);*/
+			lrc_cbdata->lrc_is_update_done = rvm_true;
+			cbinfo->bc_cb                  = status_update_cb;
 
-			/* do log scan if truncation actually needed */
-			if (do_truncation) {
-				printf("\nin if in %s\n", __FUNCTION__);
-				X(do_trunc)
-				/* build tree and time */
-				kretval= gettimeofday(&tmp_time,
-						      (struct timezone *)NULL);
-				if (kretval != 0)
-					/* return RVM_EIO; */
-					assert(0);
+			X(status_upd)
+			/* always update the status */
+			/* phase 4 */
+			printf("\n function __enter__: %s\n", __FUNCTION__);
+			retval = status_update(log, new_1st_rec_num, cbinfo);
 
-				X(build_tree)
-				/* phase 2 */
-				if ((retval=build_tree(log)) != RVM_SUCCESS)
-					/* return retval; */
-					assert(0);
+			if (retval != RVM_SUCCESS) {
+				be_status = -1;
+				msg       = retval;
+			}
+			printf("\n function __exit__: %s\n", __FUNCTION__);
+			goto exit_log_recover;
+		}
 
-				X(build_tree done)
+	});
+err_exit:
+	assert(log->trunc_thread == cthread_self());
+	wake_up_waiting_threads(log, is_daemon, daemon, retval);
 
-				assert(log->trunc_thread == cthread_self());
-				assert((status->trunc_state & RVM_TRUNC_PHASES)
-				       == RVM_TRUNC_BUILD_TREE);
-
-				kretval= gettimeofday(&end_time,
-						      (struct timezone *)NULL);
-
-				if (kretval != 0)
-					/* return RVM_EIO; */
-					assert(0);
-
-				end_time = sub_times(&end_time,&tmp_time);
-				last_tree_build_time = round_time(&end_time);
-
-				/* test for interrupt */
-				if (rvm_chk_sigint != NULL)
-					if ((*rvm_chk_sigint)(NULL))
-						goto err_exit;
-
-				/* apply tree and time */
-				kretval= gettimeofday(&tmp_time,
-						      (struct timezone *)NULL);
-				if (kretval != 0)
-					/* return RVM_EIO; */
-					assert(0);
-
-				/* status update is not done yet! */
-				lrc_cbdata->lrc_is_update_done = rvm_false;
-
-				X(apply_mods)
-				/* phase 3 */
-				if ((retval = apply_mods(log, cbinfo)) !=
-				    RVM_SUCCESS)
-					goto err_exit;
-				X(apply_mods end)
-
-				goto exit_log_recover;
-
-			} else {
-				status->trunc_state = (status->trunc_state &
-						       (~RVM_TRUNC_PHASES)) |
-						      RVM_TRUNC_APPLY;
-
-				lrc_cbdata->lrc_is_update_done = rvm_true;
-				cbinfo->bc_cb                  = status_update_cb;
-
-				X(status_upd)
-				/* always update the status */
-				/* phase 4 */
-				printf("\n function __enter__: %s\n", __FUNCTION__);
-				retval = status_update(log, new_1st_rec_num,
-						       cbinfo);
+exit_log_recover:
+	if (be_status != 0  && cbinfo->bc_pcbinfo != NULL &&
+	    cbinfo->bc_pcbinfo->bc_cb != NULL) {
+		m0_be_handler_post(cbinfo->bc_pcbinfo,
+				   be_status, msg);
+		m0_free(lrc_cbdata);
+	}
+}
+
+void lr_locate_tail_cb(cbinfo, be_status, msg)
+	struct m0_be_cbinfo	*cbinfo;
+	int			 be_status;
+	m0_be_msg_type_t	 msg;
+{
+	lrc_cbdata_t        *lrc_cbdata;
+	log_t		    *log;
+        log_status_t        *status;
+        log_daemon_t        *daemon;
+
+	rvm_bool_t           is_daemon;
+        rvm_return_t         retval = RVM_SUCCESS;
+
+        rvm_bool_t           do_truncation;
+        rvm_length_t         new_1st_rec_num;
+	rvm_length_t        *count;             /* ptr to statistics counter */
 
+	printf("\nfunction : %s\n", __FUNCTION__);
+
+	if (be_status != 0)
+		goto exit_log_recover;
+
+	lrc_cbdata      = container_of(cbinfo, lrc_cbdata_t, lrc_cbinfo);
+	log	        = lrc_cbdata->lrc_log;
+	do_truncation   = lrc_cbdata->lrc_do_trunc;
+	is_daemon	= lrc_cbdata->lrc_is_daemon;
+	status	        = &log->status;
+	daemon	        = &log->daemon;
+	new_1st_rec_num = lrc_cbdata->lrc_recnr;
+	count		= lrc_cbdata->lrc_count;
+
+	printf("\nfunction : %s before crit sec be_status : %d\n", __FUNCTION__,be_status);
+
+        CRITICAL(log->truncation_lock,      /* begin truncation lock crit sec */
+        {
+                CRITICAL(log->dev_lock, /* begin dev_lock crit sec */
+		{
+			assert(log->trunc_thread == cthread_self());
+
+			/* test for interrupt */
+			if (rvm_chk_sigint != NULL)
+				if ((*rvm_chk_sigint)(NULL))
+					goto err_exit1;
+
+			/* see if truncation actually needed */
+			if (RVM_OFFSET_EQL(status->log_tail,
+					   status->log_head))
+				status->log_empty = rvm_true;
+			else {
+				printf("\n in a complete new trace!!\n");
+				status->log_empty = rvm_false;
+				do_truncation 	  = rvm_true;
+				new_1st_rec_num   = status->next_rec_num;
+
+				lrc_cbdata->lrc_recnr         = new_1st_rec_num;
+				lrc_cbdata->lrc_is_epoch_done = rvm_true;
+				lrc_cbdata->lrc_do_trunc      = do_truncation;
+
+				cbinfo->bc_cb = lr_epoch_cb;
+				retval 	      = new_epoch(log, count, cbinfo);
+				/* switch epochs */
+				msg = retval;
 				if (retval != RVM_SUCCESS) {
-					printf("\n function = %s failed in main else\n", __FUNCTION__);
 					be_status = -1;
-					msg       = retval;
+					goto err_exit1;
+				} else {
+					be_status = 0;
+					goto exit_crit;
 				}
-				printf("\n function __exit__: %s\n", __FUNCTION__);
-				goto exit_log_recover;
 			}
 
-		err_exit:
-			assert(log->trunc_thread == cthread_self());
-			CRITICAL(daemon->lock,        /* begin daemon->lock crit sec */
-			{
-				assert(log->trunc_thread == cthread_self());
-				if (is_daemon) {
+			X(err_exit1)
+			err_exit1:;
+
+			/* signal `initiate_truncation' that the first
+			 * part is done.
+			 */
+			if (is_daemon) {
+				mutex_lock(&daemon->lock);
 				assert(log->daemon.thread == cthread_self());
+				assert(daemon->state == truncating);
 				assert((status->trunc_state &
-						RVM_ASYNC_TRUNCATE) != 0);
+				       RVM_ASYNC_TRUNCATE) != 0);
+				condition_signal(&daemon->flush_flag);
+				mutex_unlock(&daemon->lock);
+			}
+		}); /* end dev_lock crit sec */
 
-				assert(daemon->state == truncating);
-				if (retval != RVM_SUCCESS)
-				daemon->state = error;
-				}
+                if (retval != RVM_SUCCESS) {
+                        be_status = -1;
+                        msg       = retval;
+                        goto err_exit;
+                }
+	exit_crit:;
+	});
 
-				assert(log->trunc_thread == cthread_self());
-			}); /* end daemon->lock crit sec */
+	if (lrc_cbdata->lrc_is_epoch_done == rvm_true)
+		goto exit_log_recover;
 
-			log->trunc_thread   = (cthread_t)NULL;
-			status->trunc_state = ZERO;
+	lrc_cbdata->lrc_recnr 		= new_1st_rec_num;
+	lrc_cbdata->lrc_is_epoch_done	= rvm_false;
+	lrc_cbdata->lrc_do_trunc	= do_truncation;
+	lr_epoch_cb(cbinfo, be_status, msg);
+	goto exit_log_recover;
+
+err_exit:
+	wake_up_waiting_threads(log, is_daemon, daemon, retval);
 
-		});
 exit_log_recover:
 	if (be_status != 0  && cbinfo->bc_pcbinfo != NULL &&
 	    cbinfo->bc_pcbinfo->bc_cb != NULL) {
-		m0_be_handler_post(cbinfo->bc_pcbinfo,
-				   be_status, msg);
+		m0_be_handler_post(cbinfo->bc_pcbinfo, be_status, msg);
 		m0_free(lrc_cbdata);
 	}
 }
@@ -5474,9 +5615,7 @@ rvm_return_t log_recover(log, count, is_daemon, flag, cbinfo)
         int                  kretval;
         int                  be_status = 0;
         m0_be_msg_type_t     msg       = M0_BE_SUCCESS;
-        rvm_bool_t           do_truncation = rvm_false;
         rvm_return_t         retval = RVM_SUCCESS;
-        rvm_length_t         new_1st_rec_num = 0;
 
         printf("\nfunction : %s\n", __FUNCTION__);
 
@@ -5490,6 +5629,7 @@ rvm_return_t log_recover(log, count, is_daemon, flag, cbinfo)
 	/* Prepare lrc_cbdata. */
 	lrc_cbdata->lrc_log             = log;
 	lrc_cbdata->lrc_is_daemon       = is_daemon;
+	lrc_cbdata->lrc_count       	= count;
 
 	/* Prepare cbinfo to be given to apply_mods. */
 	lrc_cbinfo             = &lrc_cbdata->lrc_cbinfo;
@@ -5505,141 +5645,71 @@ rvm_return_t log_recover(log, count, is_daemon, flag, cbinfo)
 
                 X(dev_lock)
                 CRITICAL(log->dev_lock, /* begin dev_lock crit sec */
-                        {
-                                /* process statistics */
-                                assert(log->trunc_thread == cthread_self());
-                                kretval= gettimeofday(&trunc_start_time,
-                                                  (struct timezone *)NULL);
-                                if (kretval != 0) {
-                                        retval = RVM_EIO;
-                                        goto err_exit1;
-                                }
-
-                                last_tree_build_time = 0;
-                                last_tree_apply_time = 0;
-
-                                X(in_recovery)
-                                /* phase 1: locate tail & start new epoch */
-                                if (log->in_recovery) {
-                                        if ((retval = locate_tail(log)) !=
-                                            RVM_SUCCESS)
-                                                goto err_exit1;
-                                        assert((status->trunc_state &
-                                                RVM_TRUNC_PHASES) ==
-                                                RVM_TRUNC_FIND_TAIL);
-                                }
-
-                                assert(log->trunc_thread == cthread_self());
+		{
+			/* process statistics */
+			assert(log->trunc_thread == cthread_self());
+			kretval= gettimeofday(&trunc_start_time,
+					      (struct timezone *)NULL);
+			if (kretval != 0) {
+				retval = RVM_EIO;
+				goto err_exit1;
+			}
 
-                                /* test for interrupt */
-                                if (rvm_chk_sigint != NULL)
-                                        if ((*rvm_chk_sigint)(NULL))
-                                                goto err_exit1;
-
-                                /* see if truncation actually needed */
-                                if (RVM_OFFSET_EQL(status->log_tail,
-                                                   status->log_head))
-                                        status->log_empty = rvm_true;
-                                else {
-					printf("\n in a complete new trace!!\n");
-                                        status->log_empty = rvm_false;
-                                        do_truncation 	  = rvm_true;
-                                        new_1st_rec_num   = status->next_rec_num;
-
-					lrc_cbdata->lrc_recnr         = new_1st_rec_num;
-					lrc_cbdata->lrc_is_epoch_done = rvm_true;
-					lrc_cbdata->lrc_do_trunc      = do_truncation;
-
-					m0_be_cbinfo_copy_helper(cbinfo,
-								 lrc_cbinfo,
-								 lr_epoch_cb);
-
-				   	retval = new_epoch(log, count,
-							   lrc_cbinfo);
-                                        /* switch epochs */
-					msg = retval;
-                                        if (retval != RVM_SUCCESS) {
-						be_status = -1;
-                                         	goto err_exit1;
-					} else {
-						be_status = 0;
-						goto exit_crit;
-					}
-                                }
+			last_tree_build_time = 0;
+			last_tree_apply_time = 0;
 
-                                X(err_exit1)
-                                err_exit1:;
-
-                                /* signal `initiate_truncation' that the first
-				 * part is done.
-				 */
-                                if (is_daemon) {
-                                        mutex_lock(&daemon->lock);
-                                        assert(log->daemon.thread ==
-                                               cthread_self());
-                                        assert(daemon->state == truncating);
-                                        assert((status->trunc_state &
-                                               RVM_ASYNC_TRUNCATE) != 0);
-                                        condition_signal(&daemon->flush_flag);
-                                        mutex_unlock(&daemon->lock);
-                                }
-                        }); /* end dev_lock crit sec */
+			X(in_recovery)
+			/* phase 1: locate tail & start new epoch */
+			m0_be_cbinfo_copy_helper(cbinfo, lrc_cbinfo,
+						 lr_locate_tail_cb);
 
-                if (retval != RVM_SUCCESS) {
-                        be_status = -1;
-                        msg       = retval;
-                        goto err_exit;
-                }
-	exit_crit:;
-	});
+			if (log->in_recovery) {
+				retval = locate_tail(log, lrc_cbinfo);
+				if (retval != RVM_SUCCESS) {
+					be_status = -1;
+					msg	  = retval;
+					goto err_exit1;
+				}
+				assert((status->trunc_state &
+					RVM_TRUNC_PHASES) ==
+					RVM_TRUNC_FIND_TAIL);
+			}
+			else {
+				printf("\nfunction : %s !log->in_recovery", __FUNCTION__);
+				lr_locate_tail_cb(lrc_cbinfo, be_status, msg);
 
-	if (lrc_cbdata->lrc_is_epoch_done == rvm_true)
-		goto exit_log_recover;
+			}
+X(err_exit1)
+err_exit1:;
+		}); /* end dev_lock crit sec */
+	}); /* end truncation_lock crit sec */
+
+	if (is_daemon) {
+		mutex_lock(&daemon->lock);
+		assert(log->daemon.thread == cthread_self());
+		assert(daemon->state == truncating);
+		assert((status->trunc_state & RVM_ASYNC_TRUNCATE) != 0);
+		condition_signal(&daemon->flush_flag);
+		mutex_unlock(&daemon->lock);
+	}
 
-	lrc_cbdata->lrc_recnr 		= new_1st_rec_num;
-	lrc_cbdata->lrc_is_epoch_done	= rvm_false;
-	lrc_cbdata->lrc_do_trunc	= do_truncation;
-	/* Calling this function just to setup lrc_cbinfo with cbinfo. */
-	m0_be_cbinfo_copy_helper(cbinfo, lrc_cbinfo, NULL);
+	if (retval != RVM_SUCCESS) {
+		be_status = -1;
+		msg       = retval;
+		goto err_exit;
+	}
 
-	lr_epoch_cb(lrc_cbinfo, be_status, msg);
 	goto exit_log_recover;
 
+err_exit:
+	wake_up_waiting_threads(log, is_daemon, daemon, retval);
 
-	/*********** if else removed */
-
-        CRITICAL(log->truncation_lock,   /* begin truncation lock crit sec */
-	{
-                /* wake up any threads waiting on a truncation */
-        err_exit:
-                assert(log->trunc_thread == cthread_self());
-                CRITICAL(daemon->lock,        /* begin daemon->lock crit sec */
-                {
-                        assert(log->trunc_thread == cthread_self());
-                        if (is_daemon) {
-                        assert(log->daemon.thread == cthread_self());
-                        assert((status->trunc_state &
-                                        RVM_ASYNC_TRUNCATE) != 0);
-
-                        assert(daemon->state == truncating);
-                        if (retval != RVM_SUCCESS)
-                        daemon->state = error;
-                        }
-
-                        assert(log->trunc_thread == cthread_self());
-                }); /* end daemon->lock crit sec */
-
-                log->trunc_thread   = (cthread_t)NULL;
-                status->trunc_state = ZERO;
+exit_log_recover:
+	if (be_status != 0 && cbinfo != NULL && cbinfo->bc_cb != NULL) {
+		m0_be_handler_post(cbinfo->bc_pcbinfo, be_status, msg);
+		m0_free(lrc_cbdata);
+	}
 
-        }); /* end truncation lock crit sec */
-        exit_log_recover:
-                if (be_status != 0  && cbinfo->bc_pcbinfo != NULL &&
-                    cbinfo->bc_pcbinfo->bc_cb != NULL) {
-                        m0_be_handler_post(cbinfo->bc_pcbinfo,
-		                           be_status, msg);
-			m0_free(lrc_cbdata);
-                }
         return retval;
 }
 #undef X
diff --git a/rvm/rvm_private.h b/rvm/rvm_private.h
index 5450b7d..ee1574f 100644
--- a/rvm/rvm_private.h
+++ b/rvm/rvm_private.h
@@ -1836,6 +1836,7 @@ typedef struct log_recover_cbdata {
         rvm_bool_t           	 lrc_do_trunc;
         long                     lrc_seg_dict_len;
         long                     lrc_curr_vec_index;
+	rvm_length_t        	*lrc_count;
 
         /** Needed by __update_seg_cb. */
         uint32_t                 lrc_upd_seg_iter_remained;
@@ -1858,7 +1859,6 @@ typedef struct log_recover_cbdata {
 	rec_hdr_t		*lrc_rec_hdr;
 	long			 lrc_tmp_ptr;
 
-
 	/** Needed by do_trans. */
 	rvm_bool_t		 lrc_skip_trans;
 	long			 lrc_num_ranges;
-- 
1.8.3.2

