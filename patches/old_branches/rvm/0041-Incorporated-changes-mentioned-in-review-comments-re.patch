From 71a078083b9a2ce6a2bdd36e2c6f25304ebb15ac Mon Sep 17 00:00:00 2001
From: Prashant Dhange <prashant_dhange@xyratex.com>
Date: Wed, 30 Jan 2013 07:42:46 -0800
Subject: [PATCH 041/121] Incorporated changes mentioned in review comments,
 review request #1214 for be/

---
 Makefile.am              |   2 -
 be/Makefile.sub          |  25 +-
 be/be.h                  |  51 ++--
 be/be_buf.c              |  49 ++++
 be/be_buf.h              |  63 ++++
 be/be_impl.h             |  10 +-
 be/be_init.c             |   5 +-
 be/be_init.h             |   4 +-
 be/be_list.c             | 262 +++++++++++++++++
 be/be_list.h             | 246 ++++++++++++++++
 be/be_private.h          |   4 +-
 be/be_rvm.c              |   5 +-
 be/be_rvm.h              |   4 +-
 be/be_tlist.c            | 304 ++++++++++++++++++++
 be/be_tlist.h            | 430 +++++++++++++++++++++++++++
 be/be_types.h            |  55 ++++
 be/domain.c              |  40 +--
 be/domain.h              |   6 +-
 be/handle_store.c        | 120 ++++++++
 be/handle_store.h        |  53 ++++
 be/helper.c              | 207 +++++++++++++
 be/helper.h              | 131 +++++++++
 be/kv_store.c            | 734 +++++++++++++++++++++++++++++++++++++++++++++++
 be/kv_store.h            | 281 ++++++++++++++++++
 be/lib/Makefile.sub      |  14 -
 be/lib/be_buf.c          |  51 ----
 be/lib/be_buf.h          |  60 ----
 be/lib/be_handle_store.c | 112 --------
 be/lib/be_handle_store.h |  50 ----
 be/lib/be_helper.c       | 165 -----------
 be/lib/be_helper.h       |  98 -------
 be/lib/be_kv_store.c     | 679 -------------------------------------------
 be/lib/be_kv_store.h     | 185 ------------
 be/lib/be_list.c         | 275 ------------------
 be/lib/be_list.h         | 281 ------------------
 be/lib/be_tlist.c        | 303 -------------------
 be/lib/be_tlist.h        | 651 -----------------------------------------
 be/lib/be_types.h        |  55 ----
 be/lib/ut/Makefile       |  10 -
 be/lib/ut/Makefile.sub   |   2 -
 be/lib/ut/be_kv_store.c  | 294 -------------------
 be/lib/ut/be_tlist.c     | 267 -----------------
 be/reg.c                 |  54 ++--
 be/reg.h                 |  11 +-
 be/seg.c                 | 140 +++++----
 be/seg.h                 |  34 +--
 be/tx.c                  | 137 ++++-----
 be/tx.h                  |  10 +-
 be/ut/Makefile           |  10 -
 be/ut/Makefile.sub       |   6 +-
 be/ut/be.c               | 138 ++++-----
 be/ut/be_tlist.c         | 346 ++++++++++++++++++++++
 be/ut/handle_store.c     | 154 +++++-----
 be/ut/init-be.sh         |  15 -
 be/ut/kv_store.c         | 332 +++++++++++++++++++++
 utils/ut_main.c          |  14 +-
 56 files changed, 4049 insertions(+), 3995 deletions(-)
 create mode 100644 be/be_buf.c
 create mode 100644 be/be_buf.h
 create mode 100644 be/be_list.c
 create mode 100644 be/be_list.h
 create mode 100644 be/be_tlist.c
 create mode 100644 be/be_tlist.h
 create mode 100644 be/be_types.h
 create mode 100644 be/handle_store.c
 create mode 100644 be/handle_store.h
 create mode 100644 be/helper.c
 create mode 100644 be/helper.h
 create mode 100644 be/kv_store.c
 create mode 100644 be/kv_store.h
 delete mode 100644 be/lib/Makefile.sub
 delete mode 100644 be/lib/be_buf.c
 delete mode 100644 be/lib/be_buf.h
 delete mode 100644 be/lib/be_handle_store.c
 delete mode 100644 be/lib/be_handle_store.h
 delete mode 100644 be/lib/be_helper.c
 delete mode 100644 be/lib/be_helper.h
 delete mode 100644 be/lib/be_kv_store.c
 delete mode 100644 be/lib/be_kv_store.h
 delete mode 100644 be/lib/be_list.c
 delete mode 100644 be/lib/be_list.h
 delete mode 100644 be/lib/be_tlist.c
 delete mode 100644 be/lib/be_tlist.h
 delete mode 100644 be/lib/be_types.h
 delete mode 100644 be/lib/ut/Makefile
 delete mode 100644 be/lib/ut/Makefile.sub
 delete mode 100644 be/lib/ut/be_kv_store.c
 delete mode 100644 be/lib/ut/be_tlist.c
 delete mode 100644 be/ut/Makefile
 create mode 100644 be/ut/be_tlist.c
 delete mode 100755 be/ut/init-be.sh
 create mode 100644 be/ut/kv_store.c

diff --git a/Makefile.am b/Makefile.am
index feb2da8..d594458 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -150,7 +150,6 @@ mero_libmero_la_SOURCES  =
 include $(top_srcdir)/addb/Makefile.sub
 include $(top_srcdir)/addb/addbff/Makefile.sub
 include $(top_srcdir)/be/Makefile.sub
-#include $(top_srcdir)/be/lib/Makefile.sub
 include $(top_srcdir)/balloc/Makefile.sub
 include $(top_srcdir)/build_kernel_modules/Makefile.sub
 include $(top_srcdir)/m0t1fs/Makefile.sub
@@ -202,7 +201,6 @@ ut_libmero_ut_la_SOURCES  =
 
 include $(top_srcdir)/addb/ut/Makefile.sub
 include $(top_srcdir)/be/ut/Makefile.sub
-#include $(top_srcdir)/be/lib/ut/Makefile.sub
 include $(top_srcdir)/balloc/ut/Makefile.sub
 include $(top_srcdir)/capa/ut/Makefile.sub
 include $(top_srcdir)/cm/ut/Makefile.sub
diff --git a/be/Makefile.sub b/be/Makefile.sub
index f58bdd5..5c3677d 100644
--- a/be/Makefile.sub
+++ b/be/Makefile.sub
@@ -1,8 +1,21 @@
 nobase_mero_include_HEADERS +=  be/be.h
+				be/be_types.h		\
+				be/be_buf.h		\
+				be/be_list.h		\
+				be/be_tlist.h		\
+				be/helper.h		\
+				be/handle_store.h	\
+				be/kv_store.h
 
-mero_libmero_la_SOURCES	    +=	be/be_init.c 	\
-				be/domain.c    	\
-				be/seg.c       	\
-				be/reg.c       	\
-				be/be_rvm.c    	\
-				be/tx.c
+mero_libmero_la_SOURCES	    +=	be/be_init.c		\
+				be/domain.c		\
+				be/seg.c		\
+				be/reg.c		\
+				be/be_rvm.c		\
+				be/tx.c			\
+				be/be_buf.c		\
+				be/be_list.c		\
+				be/be_tlist.c		\
+				be/helper.c		\
+				be/handle_store.c	\
+				be/kv_store.c
diff --git a/be/be.h b/be/be.h
index 9d36185..7a0568b 100644
--- a/be/be.h
+++ b/be/be.h
@@ -178,7 +178,6 @@ struct m0_be_seg;
 struct m0_be_tx;
 struct m0_be_credit;
 struct m0_be_reg;
-//struct m0_be_buf;
 
 /* import */
 #include "sm/sm.h"
@@ -187,7 +186,7 @@ struct m0_be_reg;
 #include "lib/misc.h"
 
 #include "be/be_impl.h"
-#include "be/lib/be_buf.h"
+#include "be/be_buf.h"
 
 /**
  * Initialises the in-memory part of domain structure. This function does not
@@ -236,7 +235,6 @@ M0_INTERNAL int m0_be_domain_lookup(struct m0_be_domain *dom, const char *name,
 
 /**
  * Loads/Restores named segment in memory on recovery of kv-store.
- * Searches a domain for the existing segment with a given name.
  * Note - This function does not create new segment, if segment not found.
  *        This will return BE_SEG_FAILED for non existing segment lookups.
  *
@@ -245,7 +243,7 @@ M0_INTERNAL int m0_be_domain_lookup(struct m0_be_domain *dom, const char *name,
  * @post M0_IN(m0_be_seg_state_get(seg), (M0_BESEG_OPENING, M0_BESEG_ACTIVE,
  *                                        M0_BESEG_FAILED))
  */
-M0_INTERNAL void m0_be_domain_lookup_restore(struct m0_be_domain *dom,
+M0_INTERNAL void m0_be_domain_restore(struct m0_be_domain *dom,
                                              const char *name,
                                              struct m0_be_seg *out);
 
@@ -274,6 +272,8 @@ M0_INTERNAL void m0_be_seg_fini(struct m0_be_seg *seg);
 
 /**
  * Starts creation of a new segment in the domain.
+ * In case of duplicate @name, the state of @seg is set as failed and
+ * the function returns.
  *
  * @pre m0_be_seg_state_get(dom->bd_data) == M0_BESEG_ACTIVE
  * @pre m0_be_seg_state_get(seg) == M0_BESEG_CLOSED
@@ -553,7 +553,7 @@ struct m0_be_reg {
                                       |
                                       | m0_be_seg_init()
                                       V
-          +----------------------INITIALISED
+          +--------------------------INIT
           |                           |
           |                           | m0_be_seg_create()
           |                           |
@@ -574,18 +574,28 @@ struct m0_be_reg {
 	  |                           |
 	  |                           |
 	  |                           |
-	  |                           | m0_be_seg_done
+	  |                           | m0_be_seg_done()
 	  |                           V
 	  |                       CLOSING
 	  |                           |
-	  |                           | m0_be_seg_fini()
 	  |                           V
-	  +----------------------> CLOSED
+	  +----------------------> CLOSED<------------------+
+	  |                        ^  |                     |   
+	  |                        |  |                     |   
+	  |      +-----------------+  |                     |   
+	  |      |     ---------------+--------------       |   
+	  |      |     |              |             |       |   
+	  |      |     |              |             |       | m0_be_seg_delete()
+	  |      |     |              |             |       |
+	  |      +--CHECKING--------->|<---------DELETING---+           
+	  |     m0_be_seg_check()     |                      
+	  |                           |                      
+	  |                           |                      
+	  +---------------------------+                      
 
    @endverbatim
 
 */
-
 enum m0_be_seg_state {
         M0_BESEG_INIT,
         M0_BESEG_CREATING,
@@ -610,23 +620,23 @@ enum m0_be_seg_state {
           |                           | 
           |                           |
           |     timed-out             V
-          +-----------------------INITIALIZED
+          +-------------------------INIT
 	  |   init_failed             | init successful
 	  |                           |
-	  |                           | m0_be_tx_start()
+	  |                           | 
 	  |                           V
           +-------------------------PREPARING
 	  |                           |
 	  |                           |
 	  |                           |
 	FAILED <------+               |  
-	  |           |               + m0_be_tx_prep()
+	  |           |               | m0_be_tx_prep()
 	  |           |               |
 	  |           |failed         |
 	  |           |               V
 	  |           +-------------PREPARED
 	  |           |               |
-	  | fini()    |               | 
+	  | fini()    |               | m0_be_tx_start()
 	  |           |               V
 	  |           +-------------OPEN
 	  |                           |
@@ -634,14 +644,13 @@ enum m0_be_seg_state {
 	  |                           |
 	  |                           | m0_be_tx_done()
 	  |                           V
-	  |                         DONE
+	  |<-------------------------DONE
 	  |                           |
 	  |                           | 
 	  |                           V
-	  +----------------------> CLOSED
+	  +----------------------->CLOSED
 
    @endverbatim
-
 */
 enum m0_be_tx_state {
         M0_BETX_INITIALIZING,
@@ -661,7 +670,7 @@ enum m0_be_tx_state {
                                       |
                                       | m0_be_reg_init()
                                       V
-          +----------------------INITIALIZED
+          +-------------------------INIT
           |                           |
           |                           | 
           |                           |
@@ -676,7 +685,7 @@ enum m0_be_tx_state {
 	  |                           |
 	  |                           |
 	FAILED <------+               |  
-	  |           |               + m0_be_reg_capture()
+	  |           |               | m0_be_reg_capture()
 	  |           |               |
 	  |           |failed         |
 	  |           |               V
@@ -690,7 +699,7 @@ enum m0_be_tx_state {
 	  |                           |
 	  |                           | m0_be_free()
 	  |                           V
-	  |                         FREEING
+	  +-------------------------FREEING
 	  |                           |
 	  |                           | 
 	  |                         FREED  
@@ -700,7 +709,6 @@ enum m0_be_tx_state {
 	  +------------------------> DONE
 
    @endverbatim
-
 */
 enum m0_be_reg_state {
         M0_BEREG_INIT,
@@ -732,8 +740,7 @@ struct m0_be_named_seg_hdr {
 
 /** @} end of be group */
 
-/* __MERO_BE_BE_H__ */
-#endif
+#endif /* __MERO_BE_BE_H__ */
 
 /*
  *  Local variables:
diff --git a/be/be_buf.c b/be/be_buf.c
new file mode 100644
index 0000000..22f4c49
--- /dev/null
+++ b/be/be_buf.c
@@ -0,0 +1,49 @@
+/* -*- C -*- */
+/*
+ * COPYRIGHT 2012 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: Zishan Shaikh <zishan_shaikh@xyratex.com>
+ * Original creation date: 12/04/2012
+ */
+
+#include "be/be_buf.h"
+
+/**
+   @addtogroup be_buf Basic buffer type
+   @{
+*/
+
+M0_INTERNAL void m0_be_buf_init(struct m0_be_buf *buf, void *data, uint32_t nob,
+                                uint64_t segment_id, uint64_t segment_offset,
+                                void *virtual_addr)
+{
+        buf->b_addr = data;
+        buf->b_nob  = nob;
+        buf->b_logical_address.be_segid_offset.u_hi = segment_id;
+        buf->b_logical_address.be_segid_offset.u_lo = segment_offset;
+        buf->b_logical_address.be_virtual_address   = virtual_addr;
+}
+
+/** @} end of be_buf group */
+
+/*
+ *  Local variables:
+ *  c-indentation-style: "K&R"
+ *  c-basic-offset: 8
+ *  tab-width: 8
+ *  fill-column: 80
+ *  scroll-step: 1
+ *  End:
+ */
diff --git a/be/be_buf.h b/be/be_buf.h
new file mode 100644
index 0000000..7584254
--- /dev/null
+++ b/be/be_buf.h
@@ -0,0 +1,63 @@
+/* -*- C -*- */
+/*
+ * COPYRIGHT 2012 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: Zishan Shaikh <zishan_shaikh@xyratex.com>
+ * Original creation date : 12/04/2012
+ */
+#pragma once
+#ifndef __MERO_BE_BE_BUF_H__
+#define __MERO_BE_BE_BUF_H__
+
+#include "be/be_types.h"
+
+/**
+   @defgroup be_buf Basic buffer type
+   @{
+*/
+
+/**
+ * Backend domain type buffer.
+ */
+struct m0_be_buf {
+        m0_bcount_t                      b_nob;
+        union {
+                void                    *b_addr;
+                /* Holds the m0_reference for the object. */
+                struct m0_be_reference   b_logical_address;
+        };
+};
+
+/**
+ * Backend domain type buffer initialization.
+ */
+M0_INTERNAL void m0_be_buf_init(struct m0_be_buf *buf, void *data, uint32_t nob,
+                                uint64_t segment_id, uint64_t segment_offset,
+                                void *virtual_addr);
+
+/** @} end of be_buf group. */
+
+#endif /* __MERO_BE_BE_BUF_H__ */
+
+
+/*
+ *  Local variables:
+ *  c-indentation-style: "K&R"
+ *  c-basic-offset: 8
+ *  tab-width: 8
+ *  fill-column: 80
+ *  scroll-step: 1
+ *  End:
+ */
diff --git a/be/be_impl.h b/be/be_impl.h
index 8e72794..50bffbb 100644
--- a/be/be_impl.h
+++ b/be/be_impl.h
@@ -13,8 +13,8 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Sachin Patil <sachin_patil@xyratex.com>
- * Original creation date: 08 Nov 2012
+ * Original author              : Sachin Patil <sachin_patil@xyratex.com>
+ * Original creation date       : 11/08/2012
  */
 
 #pragma once
@@ -26,7 +26,6 @@
   @defgroup be (Meta-data) back-end
   @{
 */
-
 #include "sm/sm.h"
 #include "stob/stob.h"
 #include "be/rvm.h"
@@ -37,7 +36,7 @@
  * Backend Domain private implementation.
  */
 struct m0_be_domain_impl {
-        /** Stob which is used as log device for entire back-end domain. */
+        /* Stob which is used as log device for entire back-end domain. */
         struct m0_stob         *log_stob;
         struct m0_sm_group      sm_group;
         struct m0_thread        th;
@@ -47,7 +46,7 @@ struct m0_be_domain_impl {
  * Backend Segment private implementation.
  */
 struct m0_be_seg_impl {
-        /** Segment Id which is used to indentify segment uniquely. */
+        /* Segment Id which is used to indentify segment uniquely. */
         uint64_t                segment_id;
         char                    segment_name[MAXNAMELEN];
         /* Segment stob file path or device path  */
@@ -59,7 +58,6 @@ struct m0_be_seg_impl {
  */
 struct m0_be_tx_impl {
         rvm_tid_t               *tx_id;
-
         /* Credit list of (m0_be_reg) regions associated with transaction */
         struct m0_tl             bc_tl;
 };
diff --git a/be/be_init.c b/be/be_init.c
index a3f2d70..3ec9887 100644
--- a/be/be_init.c
+++ b/be/be_init.c
@@ -13,8 +13,8 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Sachin Patil <sachin_patil@xyratex.com>
- * Original creation date: 25 Jan 2013
+ * Original author              : Sachin Patil <sachin_patil@xyratex.com>
+ * Original creation date       : 01/25/2013
  */
 
 #include "be/be.h"
@@ -29,7 +29,6 @@
 M0_INTERNAL int m0_be_init(void)
 {
         m0_be_rvm_init();
-
         return 0;
 }
 
diff --git a/be/be_init.h b/be/be_init.h
index 086487a..bd6fea6 100644
--- a/be/be_init.h
+++ b/be/be_init.h
@@ -13,8 +13,8 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Sachin Patil <sachin_patil@xyratex.com>
- * Original creation date: 25 Jan 2013
+ * Original author              : Sachin Patil <sachin_patil@xyratex.com>
+ * Original creation date       : 01/25/2013
  */
 
 #pragma once
diff --git a/be/be_list.c b/be/be_list.c
new file mode 100644
index 0000000..513e4a5
--- /dev/null
+++ b/be/be_list.c
@@ -0,0 +1,262 @@
+/*
+ * COPYRIGHT 2012 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: Zishan Shaikh <zishan_shaikh@xyratex.com>
+ * Original creation date : 12/04/2012
+ */
+#include "lib/assert.h"
+#include "be/be_list.h"
+
+/** @addtogroup be_list
+ * @{
+ */
+
+M0_INTERNAL void m0_be_list_init(struct m0_be_list *head)
+{
+        head->l_head.n_virtual_address = (struct m0_be_list_link *)head;
+        head->l_tail.n_virtual_address = (struct m0_be_list_link *)head;
+}
+M0_EXPORTED(m0_be_list_init);
+
+M0_INTERNAL void m0_be_list_fini(struct m0_be_list *head)
+{
+        M0_ASSERT(m0_be_list_is_empty(head));
+}
+M0_EXPORTED(m0_be_list_fini);
+
+M0_INTERNAL bool m0_be_list_is_empty(const struct m0_be_list *head)
+{
+        return head->l_head.n_virtual_address == (void *)head;
+}
+M0_EXPORTED(m0_be_list_is_empty);
+
+M0_INTERNAL bool m0_be_list_link_invariant(const struct m0_be_list_link *link)
+{
+        struct m0_be_list_link *scan;
+        struct m0_be_list_link *next_temp;
+        struct m0_be_list_link *prev_temp;
+        uint64_t                prev_magic;
+        uint64_t                next_magic;
+        uint64_t                curr_magic;
+
+        if ((link->ll_next.n_virtual_address == link) !=
+            (link->ll_prev.n_virtual_address == link))
+                return false;
+
+        for (scan = link->ll_next.n_virtual_address;
+             scan != link;
+             scan = scan->ll_next.n_virtual_address) {
+
+                next_temp = scan->ll_next.n_virtual_address;
+                prev_temp = scan->ll_prev.n_virtual_address;
+
+                /** Make sure all belong in same domain. */
+                prev_magic = prev_temp->ll_next.n_logical_address.be_magic;
+                next_magic = next_temp->ll_next.n_logical_address.be_magic;
+                curr_magic = scan->ll_next.n_logical_address.be_magic;
+
+                M0_ASSERT(curr_magic == prev_magic);
+                M0_ASSERT(curr_magic == next_magic);
+
+                prev_magic = prev_temp->ll_prev.n_logical_address.be_magic;
+                next_magic = next_temp->ll_prev.n_logical_address.be_magic;
+                curr_magic  = scan->ll_prev.n_logical_address.be_magic;
+
+                M0_ASSERT(curr_magic == prev_magic);
+                M0_ASSERT(curr_magic == next_magic);
+
+                if (next_temp->ll_prev.n_virtual_address != scan ||
+                    prev_temp->ll_next.n_virtual_address != scan)
+                        return false;
+        }
+        return true;
+}
+
+M0_INTERNAL bool m0_be_list_invariant(const struct m0_be_list *head)
+{
+        return m0_be_list_link_invariant((void *)head);
+}
+
+M0_INTERNAL size_t m0_be_list_length(const struct m0_be_list *list)
+{
+        struct m0_be_list_link *scan;
+        size_t                 length;
+
+        M0_ASSERT(m0_be_list_invariant(list));
+        length = 0;
+
+        for (scan = list->l_head.n_virtual_address;
+             scan != (void *)list;
+             scan = scan->ll_next.n_virtual_address)
+                length++;
+
+        return length;
+}
+
+M0_INTERNAL bool m0_be_list_contains(const struct m0_be_list *list,
+                                     const struct m0_be_list_link *link)
+{
+        struct m0_be_list_link *scan;
+
+        M0_ASSERT(m0_be_list_invariant(list));
+
+        for (scan = list->l_head.n_virtual_address;
+             scan != (void *)list;
+             scan = scan->ll_next.n_virtual_address)
+                if (scan == link)
+                        return true;
+        return false;
+}
+
+static inline void __m0_be_list_add(struct m0_be_list_link *next,
+                                    struct m0_be_list_link *prev,
+                                    struct m0_be_list_link *new)
+{
+        M0_ASSERT(prev->ll_next.n_virtual_address == (void *)next &&
+                  next->ll_prev.n_virtual_address == (void *)prev);
+        M0_ASSERT(m0_be_list_link_invariant(next));
+
+        new->ll_next.n_virtual_address  = next;
+        new->ll_prev.n_virtual_address  = prev;
+
+        next->ll_prev.n_virtual_address = new;
+        prev->ll_next.n_virtual_address = new;
+
+        M0_ASSERT(m0_be_list_link_invariant(next));
+}
+
+M0_INTERNAL void m0_be_list_add(struct m0_be_list *head,
+                                struct m0_be_list_link *new)
+{
+        __m0_be_list_add(head->l_head.n_virtual_address, (void *)head, new);
+}
+M0_EXPORTED(m0_be_list_add);
+
+M0_INTERNAL void m0_be_list_add_tail(struct m0_be_list *head,
+                                     struct m0_be_list_link *new)
+{
+        __m0_be_list_add((void *)head, head->l_tail.n_virtual_address, new);
+}
+M0_EXPORTED(m0_be_list_add_tail);
+
+M0_INTERNAL void m0_be_list_add_after(struct m0_be_list_link *anchor,
+                                      struct m0_be_list_link *new)
+{
+        __m0_be_list_add(anchor->ll_next.n_virtual_address, anchor, new);
+}
+M0_EXPORTED(m0_be_list_add_after);
+
+M0_INTERNAL void m0_be_list_add_before(struct m0_be_list_link *anchor,
+                                       struct m0_be_list_link *new)
+{
+        __m0_be_list_add(anchor, anchor->ll_prev.n_virtual_address, new);
+}
+M0_EXPORTED(m0_be_list_add_before);
+
+static void __m0_be_list_del(struct m0_be_list_link *old)
+{
+        M0_ASSERT(m0_be_list_link_invariant(old));
+        struct m0_be_list_link *prev_temp;
+        struct m0_be_list_link *next_temp;
+
+        prev_temp = old->ll_prev.n_virtual_address;
+        next_temp = old->ll_next.n_virtual_address;
+
+        prev_temp->ll_next.n_virtual_address = next_temp;
+        next_temp->ll_prev.n_virtual_address = prev_temp;
+}
+
+M0_INTERNAL void m0_be_list_del(struct m0_be_list_link *old)
+{
+        __m0_be_list_del(old);
+        m0_be_list_link_init(old, NULL);
+}
+M0_EXPORTED(m0_be_list_del);
+
+M0_INTERNAL void m0_be_list_move(struct m0_be_list      *head,
+                                 struct m0_be_list_link *old)
+{
+        __m0_be_list_del(old);
+        m0_be_list_add(head, old);
+        M0_ASSERT(m0_be_list_invariant(head));
+}
+
+M0_INTERNAL void m0_be_list_move_tail(struct m0_be_list      *head,
+                                      struct m0_be_list_link *old)
+{
+        __m0_be_list_del(old);
+        m0_be_list_add_tail(head, old);
+        M0_ASSERT(m0_be_list_invariant(head));
+}
+
+M0_INTERNAL void m0_be_list_link_init(struct m0_be_list_link *link,
+                                      struct m0_be_reference  *ref)
+{
+        struct m0_uint128      *next_temp;
+        struct m0_uint128      *prev_temp;
+        uint64_t                seg_id;
+        uint64_t                offset;
+
+        link->ll_prev.n_virtual_address = (void *)link;
+        link->ll_next.n_virtual_address = (void *)link;
+
+        if (ref != NULL) {
+                seg_id    = ref->be_segid_offset.u_hi;
+                offset    = ref->be_segid_offset.u_lo;
+
+                next_temp = &link->ll_next.n_logical_address.be_segid_offset;
+                prev_temp = &link->ll_prev.n_logical_address.be_segid_offset;
+
+                next_temp->u_hi = seg_id;
+                next_temp->u_lo = offset;
+
+                prev_temp->u_hi = seg_id;
+                prev_temp->u_lo = offset;
+                
+                /** Assign domain magic in @ref */
+                link->ll_prev.n_logical_address.be_magic = ref->be_magic;
+                link->ll_next.n_logical_address.be_magic = ref->be_magic;
+        }
+}
+M0_EXPORTED(m0_be_list_link_init);
+
+
+M0_INTERNAL void m0_be_list_link_fini(struct m0_be_list_link *link)
+{
+        M0_ASSERT(!m0_be_list_link_is_in(link));
+}
+
+M0_INTERNAL bool m0_be_list_link_is_in(const struct m0_be_list_link *link)
+{
+        return link->ll_prev.n_virtual_address != (void *)link;
+}
+
+M0_INTERNAL bool m0_be_list_link_is_last(const struct m0_be_list_link *link,
+                                         const struct m0_be_list      *head)
+{
+        return link->ll_next.n_virtual_address == (void *)head;
+}
+
+/** @} end of be_list group */
+
+/*
+ *  Local variables:
+ *  c-indentation-style: "K&R"
+ *  c-basic-offset: 8
+ *  tab-width: 8
+ *  fill-column: 80
+ *  scroll-step: 1
+ *  End:
+ */
diff --git a/be/be_list.h b/be/be_list.h
new file mode 100644
index 0000000..15aac85
--- /dev/null
+++ b/be/be_list.h
@@ -0,0 +1,246 @@
+/* -*- C -*- */
+/*
+ * COPYRIGHT 2012 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: Zishan Shaikh <zishan_shaikh@xyratex.com>
+ * Original creation date: 11/28/2012
+ */
+#pragma once
+
+#ifndef __MERO_BE_BE_LIST_H__
+#define __MERO_BE_BE_LIST_H__
+
+#include "be/be_types.h"
+#include "lib/cdefs.h"
+#include "lib/assert.h"
+
+/**
+  @defgroup be_list Double-linked list.
+  Extension of m0_list
+  @{
+ */
+
+struct m0_be_list_link;
+
+/**
+  Structure to support the linkage in tlist and store the logical address
+  details of the object.
+ */
+struct m0_be_reference_ll {
+        union {
+                /* Node's virtual address */
+                struct m0_be_list_link  *n_virtual_address;
+                /* Node's logical address on BE domain */
+                struct m0_be_reference   n_logical_address;
+        };
+};
+
+/**
+  List entry.
+  Modified to support traversal in tlist via references.
+ */
+struct m0_be_list_link {
+        /* Next entry in the list */
+        struct m0_be_reference_ll ll_next;
+        /* Previous entry in the list */
+        struct m0_be_reference_ll ll_prev;
+};
+
+/**
+  Initialize list link entry for be domain
+ 
+  @param link - pointer to link entry
+  @param ref  - pointer to struct m0_be_reference in m0_buf
+ */
+M0_INTERNAL void m0_be_list_link_init(struct m0_be_list_link *link,
+                                      struct m0_be_reference *ref);
+
+/**
+  Free resources associated with link entry
+
+  @param link - pointer to link enty
+ */
+M0_INTERNAL void m0_be_list_link_fini(struct m0_be_list_link *link);
+
+M0_INTERNAL bool m0_be_list_link_invariant(const struct m0_be_list_link *link);
+
+/**
+  List head.
+ */
+struct m0_be_list {
+        /*
+         * Pointer to the first entry in the list.
+         */
+        struct m0_be_reference_ll l_head;
+        /*
+         * Pointer to the last entry in the list.
+         */
+        struct m0_be_reference_ll l_tail;
+};
+
+/**
+  It is necessary that m0_be_list and m0_be_list_link structures have exactly
+  the same layout.
+ */
+
+M0_BASSERT(offsetof(struct m0_be_list, l_head) ==
+           offsetof(struct m0_be_list_link, ll_next));
+M0_BASSERT(offsetof(struct m0_be_list, l_tail) ==
+           offsetof(struct m0_be_list_link, ll_prev));
+
+M0_INTERNAL void m0_be_list_init(struct m0_be_list *head);
+
+M0_INTERNAL void m0_be_list_fini(struct m0_be_list *head);
+
+M0_INTERNAL bool m0_be_list_is_empty(const struct m0_be_list *head);
+
+/**
+  Returns true iff @link is in @list.
+ */
+M0_INTERNAL bool m0_be_list_contains(const struct m0_be_list      *list,
+                                     const struct m0_be_list_link *link);
+
+/**
+  This function iterates over the argument list checking that double-linked
+  list invariant holds (x->ll_prev->ll_next == x && x->ll_next->ll_prev == x).
+ 
+  @return true if @list isn't corrupted
+ */
+M0_INTERNAL bool m0_be_list_invariant(const struct m0_be_list *list);
+
+M0_INTERNAL size_t m0_be_list_length(const struct m0_be_list *list);
+
+/**
+  Add list to top on the list.
+
+  This function can be called on an uninitialised @new link. All @new fields are
+  overwritten.
+
+  @param head pointer to list head
+  @param new  pointer to list entry
+ */
+M0_INTERNAL void m0_be_list_add(struct m0_be_list       *head,
+                                struct m0_be_list_link  *new);
+
+/**
+  Add list to tail on the list. This function can be called on an
+  uninitialised @new link. All @new fields are overwritten.
+ 
+  @param head pointer to list head
+  @param new  pointer to list entry
+ */
+M0_INTERNAL void m0_be_list_add_tail(struct m0_be_list      *head,
+                                     struct m0_be_list_link *new);
+
+/**
+  adds an element to the list right after the specified element
+  
+  This function can be called on an uninitialised @new link.
+  All @new fields are overwritten.
+ */
+M0_INTERNAL void m0_be_list_add_after (struct m0_be_list_link *anchor,
+                                       struct m0_be_list_link *new);
+
+/**
+  Adds an element to the list right before the specified element. This function
+  can be called on an uninitialised @new link. All @new fields are overwritten.
+ */
+M0_INTERNAL void m0_be_list_add_before(struct m0_be_list_link *anchor,
+                                       struct m0_be_list_link *new);
+
+/**
+  Deletes an entry from the list and re-initializes the entry.
+ */
+M0_INTERNAL void m0_be_list_del(struct m0_be_list_link *old);
+
+/**
+  Moves an entry to head of the list.
+ */
+M0_INTERNAL void m0_be_list_move(struct m0_be_list      *head,
+                                 struct m0_be_list_link *new);
+
+/**
+  Moves an entry to tail of the list.
+ */
+M0_INTERNAL void m0_be_list_move_tail(struct m0_be_list      *head,
+                                      struct m0_be_list_link *new);
+
+/**
+  Return first entry from the list.
+ 
+  @param head pointer to list head
+  @return pointer to first list entry or NULL if list empty
+ */
+static inline struct m0_be_list_link
+*m0_be_list_first(const struct m0_be_list *head)
+{
+        return head->l_head.n_virtual_address !=
+               (void *)head ? head->l_head.n_virtual_address : NULL;
+}
+
+
+/**
+  Is link entry connected to the list.
+ 
+  @param link - pointer to link entry
+  @retval true - entry connected to a list
+  @retval false - entry disconnected from a list
+*/
+M0_INTERNAL bool m0_be_list_link_is_in(const struct m0_be_list_link *link);
+
+M0_INTERNAL bool m0_be_list_link_is_last(const struct m0_be_list_link *link,
+                                         const struct m0_be_list      *head);
+
+M0_INTERNAL size_t m0_be_list_length(const struct m0_be_list *list);
+
+#define m0_be_list_entry(link, type, member) \
+        container_of(link, type, member)
+
+#define m0_be_list_for_each(head, pos) \
+        for (pos = (head)->l_head.n_virtual_address; pos != (void *)(head); \
+             pos = (pos)->ll_next.n_virtual_address)
+
+#define m0_be_list_for_each_entry(head, pos, type, member) \
+        for (pos = m0_be_list_entry((head)->l_head.n_virtual_address, type, \
+                                    member);\
+             &(pos->member) != (void *)head; \
+             pos = m0_be_list_entry((pos)->member.ll_next.n_virtual_address,\
+                                    type, member))
+
+#define m0_be_list_for_each_entry_safe(head, pos, next, type, member)   \
+        for (pos = m0_be_list_entry((head)->l_head.n_virtual_address, type, \
+                                    member),\
+             next = m0_be_list_entry((pos)->member.ll_next.n_virtual_address,\
+                                     type, member);                         \
+             &(pos)->member != (void *)head;                            \
+             pos  = next,                                               \
+             next = m0_be_list_entry((next)->member.ll_next.n_virtual_address,\
+                                     type, member))
+
+
+/** @} end of be_list group */
+
+#endif /* __MERO_BE_BE_LIST_H__ */
+
+
+/*
+ *  Local variables:
+ *  c-indentation-style: "K&R"
+ *  c-basic-offset: 8
+ *  tab-width: 8
+ *  fill-column: 80
+ *  scroll-step: 1
+ *  End:
+ */
diff --git a/be/be_private.h b/be/be_private.h
index 6aaee05..e9cfdfc 100644
--- a/be/be_private.h
+++ b/be/be_private.h
@@ -13,8 +13,8 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Sachin Patil <sachin_patil@xyratex.com>
- * Original creation date: 22 Jan 2013
+ * Original author              : Sachin Patil <sachin_patil@xyratex.com>
+ * Original creation date       : 01/22/2013
  */
 
 #pragma once
diff --git a/be/be_rvm.c b/be/be_rvm.c
index 5a01362..6448e76 100644
--- a/be/be_rvm.c
+++ b/be/be_rvm.c
@@ -13,8 +13,8 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Sachin Patil <sachin_patil@xyratex.com>
- * Original creation date: 28 Nov 2012
+ * Original author              : Sachin Patil <sachin_patil@xyratex.com>
+ * Original creation date       : 11/28/2012
  */
 
 #include "be/be.h"
@@ -28,7 +28,6 @@ const char *log_file="/tmp/log_file";
 
 extern void *RecoverableHeapStartAddress;
 
-
 /**
  * Initialize RVM
  * @todo - most of the rvm options are hardcoded for now
diff --git a/be/be_rvm.h b/be/be_rvm.h
index 560d299..a229e7a 100644
--- a/be/be_rvm.h
+++ b/be/be_rvm.h
@@ -13,8 +13,8 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Sachin Patil <sachin_patil@xyratex.com>
- * Original creation date: 27 Nov 2012
+ * Original author              : Sachin Patil <sachin_patil@xyratex.com>
+ * Original creation date       : 11/27/2012
  */
 
 #pragma once
diff --git a/be/be_tlist.c b/be/be_tlist.c
new file mode 100644
index 0000000..32e4f63
--- /dev/null
+++ b/be/be_tlist.c
@@ -0,0 +1,304 @@
+/* -*- C -*- */
+/*
+ * COPYRIGHT 2012 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author        : Zishan Shaikh <zishan_shaikh@xyratex.com>
+ * Original creation date : 12/04/2012
+ */
+
+#include "be/be_tlist.h"
+
+/**
+   @addtogroup be_tlist
+   @{
+ */
+
+/**
+   Returns the address of a link embedded in an ambient object.
+ */
+static struct m0_be_list_link
+*be_link(const struct m0_be_tl_descr *d, const void *obj);
+/**
+   Returns the value of the magic field in an ambient object
+ */
+static uint64_t be_magic(const struct m0_be_tl_descr *d,
+                         const void *obj);
+
+/**
+   Casts a link to its ambient object.
+ */
+static void *be_amb(const struct m0_be_tl_descr *d,
+                    struct m0_be_list_link *link);
+
+M0_INTERNAL void m0_be_tlist_init(const struct m0_be_tl_descr *d,
+                                   struct m0_be_tl *list)
+{
+        list->t_magic = d->td_head_magic;
+        m0_be_list_init(&list->t_head);
+        M0_POST(m0_be_tlist_invariant(d, list));
+}
+
+M0_INTERNAL void m0_be_tlist_fini(const struct m0_be_tl_descr *d,
+                                  struct m0_be_tl *list)
+{
+        M0_PRE(m0_be_tlist_invariant(d, list));
+        m0_be_list_fini(&list->t_head);
+}
+
+M0_INTERNAL void m0_be_tlink_init(const struct m0_be_tl_descr *d,
+                                  struct m0_be_reference      *ref)
+{
+        void *obj = ref->be_virtual_address;
+        m0_be_list_link_init(be_link(d,obj), ref);
+        if (d->td_link_magic != 0)
+                *(uint64_t *)(obj + d->td_link_magic_offset) = d->td_link_magic;
+        M0_POST(m0_be_tlink_invariant(d, obj));
+}
+
+M0_INTERNAL void m0_be_tlink_init_at(const struct m0_be_tl_descr *d,
+                                     struct m0_be_tl             *list,
+                                     struct m0_be_reference      *ref)
+{
+        void *obj = ref->be_virtual_address;
+        m0_be_tlink_init(d, ref);
+        m0_be_tlist_add(d, list, obj);
+}
+
+M0_INTERNAL void m0_be_tlink_init_at_tail(const struct m0_be_tl_descr *d,
+                                          struct m0_be_tl             *list,
+                                          struct m0_be_reference      *ref)
+{
+        void *obj = ref->be_virtual_address;
+        m0_be_tlink_init(d, ref);
+        m0_be_tlist_add_tail(d, list, obj);
+}
+
+M0_INTERNAL void m0_be_tlink_fini(const struct m0_be_tl_descr *d, void *obj)
+{
+        m0_be_list_link_fini(be_link(d, obj));
+}
+
+M0_INTERNAL void m0_be_tlink_del_fini(const struct m0_be_tl_descr *d, void *obj)
+{
+        m0_be_tlist_del(d, obj);
+        m0_be_tlink_fini(d, obj);
+}
+
+M0_INTERNAL bool m0_be_tlist_is_empty(const struct m0_be_tl_descr *d,
+                                      const struct m0_be_tl *list)
+{
+        M0_PRE(m0_be_tlist_invariant(d, list));
+        return m0_be_list_is_empty(&list->t_head);
+}
+
+M0_INTERNAL bool m0_be_tlink_is_in(const struct m0_be_tl_descr *d,
+                                   const void *obj)
+{
+        M0_PRE(m0_be_tlink_invariant(d, obj));
+        return m0_be_list_link_is_in(be_link(d, obj));
+}
+
+M0_INTERNAL bool m0_be_tlist_contains(const struct m0_be_tl_descr *d,
+                                      const struct m0_be_tl       *list,
+                                      const void                  *obj)
+{
+        M0_PRE(m0_be_tlist_invariant(d, list));
+        M0_PRE(m0_be_tlink_invariant(d, obj));
+        return m0_be_list_contains(&list->t_head, be_link(d, obj));
+}
+
+M0_INTERNAL size_t m0_be_tlist_length(const struct m0_be_tl_descr *d,
+                                      const struct m0_be_tl       *list)
+{
+        M0_PRE(m0_be_tlist_invariant(d, list));
+        return m0_be_list_length(&list->t_head);
+}
+M0_EXPORTED(m0_be_tlist_length);
+
+M0_INTERNAL void m0_be_tlist_add(const struct m0_be_tl_descr *d,
+                                 struct m0_be_tl *list, void *obj)
+{
+        M0_PRE(m0_be_tlist_invariant(d, list));
+        M0_PRE(!m0_be_tlink_is_in(d, obj));
+        m0_be_list_add(&list->t_head, be_link(d, obj));
+}
+
+M0_INTERNAL void m0_be_tlist_add_tail(const struct m0_be_tl_descr *d,
+                                      struct m0_be_tl *list, void *obj)
+{
+        M0_PRE(m0_be_tlist_invariant(d, list));
+        M0_PRE(!m0_be_tlink_is_in(d, obj));
+        m0_be_list_add_tail(&list->t_head, be_link(d, obj));
+}
+
+M0_INTERNAL void m0_be_tlist_add_after(const struct m0_be_tl_descr *d,
+                                       void *obj, void *new)
+{
+        M0_PRE(m0_be_tlink_is_in(d, obj));
+        M0_PRE(!m0_be_tlink_is_in(d, new));
+        m0_be_list_add_after(be_link(d, obj), be_link(d, new));
+}
+
+M0_INTERNAL void m0_be_tlist_add_before(const struct m0_be_tl_descr *d,
+                                        void *obj, void *new)
+{
+        M0_PRE(m0_be_tlink_is_in(d, obj));
+        M0_PRE(!m0_be_tlink_is_in(d, new));
+        m0_be_list_add_before(be_link(d, obj), be_link(d, new));
+}
+
+M0_INTERNAL void m0_be_tlist_del(const struct m0_be_tl_descr *d, void *obj)
+{
+        M0_PRE(m0_be_tlink_invariant(d, obj));
+        M0_PRE(m0_be_tlink_is_in(d, obj));
+        m0_be_list_del(be_link(d, obj));
+        M0_PRE(!m0_be_tlink_is_in(d, obj));
+}
+
+M0_INTERNAL void m0_be_tlist_move(const struct m0_be_tl_descr *d,
+                                  struct m0_be_tl *list, void *obj)
+{
+        M0_PRE(m0_be_tlist_invariant(d, list));
+        M0_PRE(m0_be_tlink_is_in(d, obj));
+
+        m0_be_list_move(&list->t_head, be_link(d, obj));
+}
+
+M0_INTERNAL void m0_be_tlist_move_tail(const struct m0_be_tl_descr *d,
+                                       struct m0_be_tl *list, void *obj)
+{
+        M0_PRE(m0_be_tlist_invariant(d, list));
+        M0_PRE(m0_be_tlink_is_in(d, obj));
+
+        m0_be_list_move_tail(&list->t_head, be_link(d, obj));
+}
+
+M0_INTERNAL void *m0_be_tlist_head(const struct m0_be_tl_descr *d,
+                                   const struct m0_be_tl *list)
+{
+        const struct m0_be_list *head;
+
+        M0_PRE(m0_be_tlist_invariant(d, list));
+
+        head = &list->t_head;
+        return (head->l_head.n_virtual_address !=
+               (void *)head ? be_amb(d, head->l_head.n_virtual_address) : NULL);
+}
+
+M0_INTERNAL void *m0_be_tlist_tail(const struct m0_be_tl_descr *d,
+                                   const struct m0_be_tl *list)
+{
+        const struct m0_be_list *head;
+
+        M0_PRE(m0_be_tlist_invariant(d, list));
+
+        head = &list->t_head;
+        return (head->l_tail.n_virtual_address !=
+               (void *)head ? be_amb(d, head->l_tail.n_virtual_address) : NULL);
+}
+
+M0_INTERNAL void *m0_be_tlist_next(const struct m0_be_tl_descr *d,
+                                   const struct m0_be_tl *list, void *obj)
+{
+        struct m0_be_list_link *next;
+
+        M0_PRE(m0_be_tlist_contains(d, list, obj));
+
+        next = (struct m0_be_list_link *)
+                be_link(d, obj)->ll_next.n_virtual_address;
+        return (void *)next != &list->t_head ? be_amb(d, next) : NULL;
+}
+
+M0_INTERNAL void *m0_be_tlist_prev(const struct m0_be_tl_descr *d,
+                                   const struct m0_be_tl *list, void *obj)
+{
+        struct m0_be_list_link *prev;
+
+        M0_PRE(m0_be_tlist_contains(d, list, obj));
+
+        prev = (struct m0_be_list_link *)
+                be_link(d, obj)->ll_prev.n_virtual_address;
+        return (void *)prev != &list->t_head ? be_amb(d, prev) : NULL;
+}
+
+M0_INTERNAL bool m0_be_tlist_invariant(const struct m0_be_tl_descr *d,
+                                       const struct m0_be_tl *list)
+{
+        struct m0_be_list_link *head;
+        struct m0_be_list_link *scan;
+        struct m0_be_list_link *next_temp;
+        struct m0_be_list_link *prev_temp;
+
+        head = (void *)&list->t_head;
+
+        if (list->t_magic != d->td_head_magic)
+                return false;
+        if ((head->ll_next.n_virtual_address == (void *)head) !=
+            (head->ll_prev.n_virtual_address == (void *)head))
+                return false;
+
+        for (scan = head->ll_next.n_virtual_address;
+             scan != head; scan = scan->ll_next.n_virtual_address) {
+
+                next_temp = scan->ll_next.n_virtual_address;
+                prev_temp = scan->ll_prev.n_virtual_address;
+
+                if (next_temp->ll_prev.n_virtual_address != scan ||
+                    prev_temp->ll_next.n_virtual_address != scan)
+                        return false;
+
+                if (!m0_be_tlink_invariant(d, be_amb(d, scan)))
+                        return false;
+        }
+
+        return true;
+}
+
+M0_INTERNAL bool m0_be_tlink_invariant(const struct m0_be_tl_descr *d,
+                                       const void *obj)
+{
+        return d->td_link_magic == 0 || be_magic(d, obj) == d->td_link_magic;
+}
+
+static struct m0_be_list_link
+*be_link(const struct m0_be_tl_descr *d, const void *obj)
+{
+        return &((struct m0_be_tlink *)(obj + d->td_link_offset))->t_link;
+}
+
+static uint64_t be_magic(const struct m0_be_tl_descr *d,
+                         const void *obj)
+{
+        return *(uint64_t *)(obj + d->td_link_magic_offset);
+}
+
+static void *be_amb(const struct m0_be_tl_descr *d,
+                    struct m0_be_list_link *link)
+{
+        return (void *)container_of(link, struct m0_be_tlink,
+                                    t_link) - d->td_link_offset;
+}
+
+/** @} end of be_tlist group */
+
+/*
+ *  Local variables:
+ *  c-indentation-style: "K&R"
+ *  c-basic-offset: 8
+ *  tab-width: 8
+ *  fill-column: 80
+ *  scroll-step: 1
+ *  End:
+ */
diff --git a/be/be_tlist.h b/be/be_tlist.h
new file mode 100644
index 0000000..22f4e77
--- /dev/null
+++ b/be/be_tlist.h
@@ -0,0 +1,430 @@
+/* -*- C -*- */
+/*
+ * COPYRIGHT 2012 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: Zishan Shaikh <zishan_shaikh@xyratex.com>
+ * Original creation date: 12/04/2012
+ */
+#pragma once
+#ifndef __MERO_BE_TLIST_H__
+#define __MERO_BE_TLIST_H__
+
+#include "be/be_list.h"
+#include "be/be_types.h"
+
+/**
+   @defgroup be_tlist Typed lists.
+   Extension of m0_tlist.
+
+   @{
+ */
+
+struct m0_be_tl_descr;
+struct m0_be_tl;
+struct m0_be_tlink;
+
+struct m0_be_tl_descr {
+        /** Human-readable list name, used for error messages. */
+        const char *td_name;
+        /** Offset of list link (m0_tlink) in the ambient object. */
+        int         td_link_offset;
+        /**
+            Offset of magic field in the ambient object.
+            This is used only when link magic checking is on.
+
+            @see m0_be_tl_descr::td_link_magic
+         */
+        int         td_link_magic_offset;
+        /**
+            Magic stored in an ambient object.
+
+            If this field is 0, link magic checking is disabled.
+         */
+        uint64_t    td_link_magic;
+        /**
+            Magic stored in m0_tl::t_magic and checked on all tlist
+            operations.
+         */
+        uint64_t    td_head_magic;
+};
+
+#define M0_BE_TL_DESCR(name, ambient_type, link_field, link_magic_field,\
+                       link_magic, head_magic)                          \
+{                                                                       \
+        .td_name              = name,                                   \
+        .td_link_offset       = offsetof(ambient_type, link_field),     \
+        .td_link_magic_offset = offsetof(ambient_type, link_magic_field),\
+        .td_link_magic        = link_magic,                             \
+        .td_head_magic        = head_magic                              \
+};                                                                      \
+                                                                        \
+M0_BASSERT(M0_HAS_TYPE(M0_FIELD_VALUE(ambient_type, link_field),        \
+                       struct m0_be_tlink));                            \
+M0_BASSERT(M0_HAS_TYPE(M0_FIELD_VALUE(ambient_type, link_magic_field),  \
+                       uint64_t))
+
+/**
+  Tlist head to support back-end domain
+ */
+struct m0_be_tl {
+        /**
+           Head magic. This is set to m0_tl::td_head_magic and verified by the
+           list invariant.
+         */
+        uint64_t          t_magic;
+        /** Underlying m0_be_list. */
+        struct m0_be_list t_head;
+};
+
+
+/**
+  Tlist link to support back-end domain
+ */
+struct m0_be_tlink {
+        /** Underlying m0_be_list link. */
+        struct m0_be_list_link t_link;
+};
+
+M0_INTERNAL void m0_be_tlist_init(const struct m0_be_tl_descr *d,
+                                  struct m0_be_tl *list);
+
+M0_INTERNAL void m0_be_tlist_fini(const struct m0_be_tl_descr *d,
+                                  struct m0_be_tl *list);
+
+M0_INTERNAL void m0_be_tlink_init(const struct m0_be_tl_descr *d,
+                                  struct m0_be_reference      *ref);
+
+M0_INTERNAL void m0_be_tlink_fini(const struct m0_be_tl_descr *d, void *obj);
+
+M0_INTERNAL void m0_be_tlink_init_at(const struct m0_be_tl_descr *d,
+                                     struct m0_be_tl             *list,
+                                     struct m0_be_reference      *ref);
+
+M0_INTERNAL void m0_be_tlink_init_at_tail(const struct m0_be_tl_descr *d,
+                                          struct m0_be_tl             *list,
+                                          struct m0_be_reference      *ref);
+
+M0_INTERNAL void m0_be_tlink_del_fini(const struct m0_be_tl_descr *d,
+                                      void *obj);
+
+M0_INTERNAL bool m0_be_tlist_invariant(const struct m0_be_tl_descr *d,
+                                       const struct m0_be_tl *list);
+
+M0_INTERNAL bool m0_be_tlink_invariant(const struct m0_be_tl_descr *d,
+                                       const void *obj);
+
+M0_INTERNAL bool   m0_be_tlist_is_empty(const struct m0_be_tl_descr *d,
+                                        const struct m0_be_tl *list);
+
+M0_INTERNAL bool   m0_be_tlink_is_in(const struct m0_be_tl_descr *d,
+                                     const void *obj);
+
+M0_INTERNAL bool   m0_be_tlist_contains(const struct m0_be_tl_descr *d,
+                                        const struct m0_be_tl *list,
+                                        const void *obj);
+
+M0_INTERNAL size_t m0_be_tlist_length  (const struct m0_be_tl_descr *d,
+                                        const struct m0_be_tl *list);
+
+/**
+   Adds an element to the beginning of a list.
+
+   @pre !m0_tlink_is_in(d, obj)
+   @post m0_tlink_is_in(d, obj)
+ */
+M0_INTERNAL void   m0_be_tlist_add(const struct m0_be_tl_descr *d,
+                                   struct m0_be_tl *list, void *obj);
+
+/**
+   Adds an element to the end of a list.
+
+   @pre !m0_tlink_is_in(d, obj)
+   @post m0_tlink_is_in(d, obj)
+ */
+M0_INTERNAL void   m0_be_tlist_add_tail(const struct m0_be_tl_descr *d,
+                                        struct m0_be_tl *list, void *obj);
+
+/**
+   Adds an element after another element of the list.
+
+   @pre !m0_tlink_is_in(d, new)
+   @post m0_tlink_is_in(d, new)
+ */
+M0_INTERNAL void   m0_be_tlist_add_after(const struct m0_be_tl_descr *d,
+                                         void *obj, void *new);
+
+/**
+   Adds an element before another element of the list.
+
+   @pre !m0_tlink_is_in(d, new)
+   @post m0_tlink_is_in(d, new)
+ */
+M0_INTERNAL void   m0_be_tlist_add_before(const struct m0_be_tl_descr *d,
+                                          void *obj, void *new);
+
+/**
+   Deletes an element from the list.
+
+   @pre   m0_tlink_is_in(d, obj)
+   @post !m0_tlink_is_in(d, obj)
+ */
+M0_INTERNAL void   m0_be_tlist_del(const struct m0_be_tl_descr *d, void *obj);
+
+/**
+   Moves an element from a list to the head of (possibly the same) list.
+
+   @pre  m0_tlink_is_in(d, obj)
+   @post m0_tlink_is_in(d, obj)
+ */
+M0_INTERNAL void   m0_be_tlist_move(const struct m0_be_tl_descr *d,
+                                    struct m0_be_tl *list, void *obj);
+
+/**
+   Moves an element from a list to the tail of (possibly the same) list.
+
+   @pre  m0_tlink_is_in(d, obj)
+   @post m0_tlink_is_in(d, obj)
+ */
+M0_INTERNAL void   m0_be_tlist_move_tail(const struct m0_be_tl_descr *d,
+                                         struct m0_be_tl *list, void *obj);
+
+/**
+   Returns the first element of a list or NULL if the list is empty.
+ */
+M0_INTERNAL void  *m0_be_tlist_head(const struct m0_be_tl_descr *d,
+                                    const struct m0_be_tl *list);
+
+/**
+   Returns the last element of a list or NULL if the list is empty.
+ */
+M0_INTERNAL void  *m0_be_tlist_tail(const struct m0_be_tl_descr *d,
+                                    const struct m0_be_tl *list);
+
+/**
+   Returns the next element of a list or NULL if @obj is the last element.
+
+   @pre m0_be_tlist_contains(d, list, obj)
+ */
+M0_INTERNAL void  *m0_be_tlist_next(const struct m0_be_tl_descr *d,
+                                    const struct m0_be_tl *list, void *obj);
+
+
+/**
+   Returns the previous element of a list or NULL if @obj is the first element.
+
+   @pre m0_be_tlist_contains(d, list, obj)
+ */
+M0_INTERNAL void  *m0_be_tlist_prev(const struct m0_be_tl_descr *d,
+                                    const struct m0_be_tl    *list, void *obj);
+
+#define m0_be_tlist_for(descr, head, obj)                               \
+do {                                                                    \
+        void *__be_tl;                                                  \
+                                                                        \
+        for (obj = m0_be_tlist_head(descr, head);                       \
+             obj != NULL &&                                             \
+             ((void)(__be_tl = m0_be_tlist_next(descr, head, obj)), true);\
+             obj = __be_tl)
+
+/**
+   Terminates m0_be_tlist_for() loop.
+ */
+#define m0_be_tlist_endfor ; (void)__be_tl; } while (0)
+
+#define M0_BE_TL_DECLARE(name, scope, amb_type)                         \
+                                                                        \
+scope void name ## _be_tlist_init(struct m0_be_tl *head);               \
+scope void name ## _be_tlist_fini(struct m0_be_tl *head);               \
+scope void name ## _be_tlink_init(struct m0_be_reference *ref);         \
+scope void name ## _be_tlink_init_at(struct m0_be_reference *ref,       \
+                                     struct m0_be_tl        *head);     \
+scope void name ## _be_tlink_init_at_tail(struct m0_be_reference *ref,  \
+                                          struct m0_be_tl        *head);\
+scope void name ## _be_tlink_fini(amb_type *amb);                       \
+scope void name ## _be_tlink_del_fini(amb_type *amb);                   \
+scope bool   name ## _be_tlist_is_empty(const struct m0_be_tl *list);   \
+scope bool   name ## _be_tlink_is_in   (const amb_type *amb);           \
+scope bool   name ## _be_tlist_contains(const struct m0_be_tl *list,    \
+                                        const amb_type *amb);           \
+scope size_t name ## _be_tlist_length(const struct m0_be_tl *list);     \
+scope void   name ## _be_tlist_add(struct m0_be_tl *list, amb_type *amb); \
+scope void   name ## _be_tlist_add_tail(struct m0_be_tl *list, amb_type *amb); \
+scope void   name ## _be_tlist_add_after(amb_type *amb, amb_type *new); \
+scope void   name ## _be_tlist_add_before(amb_type *amb, amb_type *new);\
+scope void   name ## _be_tlist_del(amb_type *amb);                      \
+scope void   name ## _be_tlist_move(struct m0_be_tl *list, amb_type *amb); \
+scope void   name ## _be_tlist_move_tail(struct m0_be_tl *list, amb_type *amb);\
+scope amb_type *name ## _be_tlist_head(const struct m0_be_tl *list);    \
+scope amb_type *name ## _be_tlist_tail(const struct m0_be_tl *list);    \
+scope amb_type *name ## _be_tlist_next(const struct m0_be_tl *list,     \
+                                       amb_type *amb);                  \
+scope amb_type *name ## _be_tlist_prev(const struct m0_be_tl *list, \
+                                       amb_type *amb)
+
+#define __AUN __attribute__((unused))
+
+
+/**
+   Defines a tlist descriptor (m0_be_tl_descr) for a particular ambient type.
+ */
+#define M0_BE_TL_DESCR_DEFINE(name, hname, scope, amb_type, amb_link_field, \
+                              amb_magic_field, amb_magic, head_magic)   \
+scope const struct m0_be_tl_descr name ## _tl = M0_BE_TL_DESCR(hname,   \
+                                                               amb_type,\
+                                                               amb_link_field,\
+                                                               amb_magic_field,\
+                                                               amb_magic,\
+                                                               head_magic)
+
+
+/**
+   Defines functions declared by M0_BE_TL_DECLARE().
+
+   The definitions generated assume that tlist descriptor, defined by
+   M0_BE_TL_DESC_DEFINE() is in scope.
+ */
+#define M0_BE_TL_DEFINE(name, scope, amb_type)                          \
+                                                                        \
+scope __AUN void name ## _tlist_init(struct m0_be_tl *head)             \
+{                                                                       \
+        m0_be_tlist_init(&name ## _tl, head);                           \
+}                                                                       \
+                                                                        \
+scope __AUN void name ## _tlist_fini(struct m0_be_tl *head)             \
+{                                                                       \
+        m0_be_tlist_fini(&name ## _tl, head);                           \
+}                                                                       \
+                                                                        \
+scope __AUN void name ## _tlink_init(struct m0_be_reference *ref)       \
+{                                                                       \
+        m0_be_tlink_init(&name ## _tl, ref);                            \
+}                                                                       \
+                                                                        \
+scope __AUN void name ## _tlink_init_at(struct m0_be_reference *ref,    \
+                                        struct m0_be_tl        *head)   \
+{                                                                       \
+        m0_be_tlink_init_at(&name ## _tl,  head, ref);                  \
+}                                                                       \
+                                                                        \
+scope __AUN void name ## _tlink_init_at_tail(struct m0_be_reference *ref, \
+                                             struct m0_be_tl        *head)\
+{                                                                       \
+        m0_be_tlink_init_at_tail(&name ## _tl, head, ref);              \
+}                                                                       \
+                                                                        \
+scope __AUN void name ## _tlink_fini(amb_type *amb)                     \
+{                                                                       \
+        m0_be_tlink_fini(&name ## _tl, amb);                            \
+}                                                                       \
+                                                                        \
+scope __AUN void name ## _tlink_del_fini(amb_type *amb)                 \
+{                                                                       \
+        m0_be_tlink_del_fini(&name ## _tl, amb);                        \
+}                                                                       \
+                                                                        \
+scope __AUN bool   name ## _tlist_is_empty(const struct m0_be_tl *list) \
+{                                                                       \
+        return m0_be_tlist_is_empty(&name ## _tl, list);                \
+}                                                                       \
+                                                                        \
+scope __AUN bool   name ## _tlink_is_in   (const amb_type *amb)         \
+{                                                                       \
+        return m0_be_tlink_is_in(&name ## _tl, amb);                    \
+}                                                                       \
+                                                                        \
+scope __AUN bool   name ## _tlist_contains(const struct m0_be_tl *list, \
+                                           const amb_type *amb)         \
+{                                                                       \
+        return m0_be_tlist_contains(&name ## _tl, list, amb);           \
+}                                                                       \
+                                                                        \
+scope __AUN size_t name ## _tlist_length(const struct m0_be_tl *list)   \
+{                                                                       \
+        return m0_be_tlist_length(&name ## _tl, list);                  \
+}                                                                       \
+                                                                        \
+scope __AUN void   name ## _tlist_add(struct m0_be_tl *list, amb_type *amb) \
+{                                                                       \
+        m0_be_tlist_add(&name ## _tl, list, amb);                       \
+}                                                                       \
+                                                                        \
+scope __AUN void   name ## _tlist_add_tail(struct m0_be_tl *list,       \
+                                           amb_type *amb)               \
+{                                                                       \
+        m0_be_tlist_add_tail(&name ## _tl, list, amb);                  \
+}                                                                       \
+                                                                        \
+scope __AUN void   name ## _tlist_add_after(amb_type *amb, amb_type *new) \
+{                                                                       \
+        m0_be_tlist_add_after(&name ## _tl, amb, new);                  \
+}                                                                       \
+                                                                        \
+scope __AUN void   name ## _tlist_add_before(amb_type *amb, amb_type *new) \
+{                                                                       \
+        m0_be_tlist_add_before(&name ## _tl, amb, new);                 \
+}                                                                       \
+                                                                        \
+scope __AUN void   name ## _tlist_del(amb_type *amb)                    \
+{                                                                       \
+        m0_be_tlist_del(&name ## _tl, amb);                             \
+}                                                                       \
+                                                                        \
+scope __AUN void   name ## _tlist_move(struct m0_be_tl *list, amb_type *amb)\
+{                                                                       \
+        m0_be_tlist_move(&name ## _tl, list, amb);                      \
+}                                                                       \
+                                                                        \
+scope __AUN void   name ## _tlist_move_tail(struct m0_be_tl *list,      \
+                                            amb_type *amb)              \
+{                                                                       \
+        m0_be_tlist_move_tail(&name ## _tl, list, amb);                 \
+}                                                                       \
+                                                                        \
+scope __AUN amb_type *name ## _tlist_head(const struct m0_be_tl *list)  \
+{                                                                       \
+        return m0_be_tlist_head(&name ## _tl, list);                    \
+}                                                                       \
+                                                                        \
+scope __AUN amb_type *name ## _tlist_tail(const struct m0_be_tl *list)  \
+{                                                                       \
+        return m0_be_tlist_tail(&name ## _tl, list);                    \
+}                                                                       \
+                                                                        \
+scope __AUN amb_type *name ## _tlist_next(const struct m0_be_tl *list,  \
+                                          amb_type *amb)                \
+{                                                                       \
+        return m0_be_tlist_next(&name ## _tl, list, amb);               \
+}                                                                       \
+                                                                        \
+scope __AUN amb_type *name ## _tlist_prev(const struct m0_be_tl *list,  \
+                                          amb_type *amb)                \
+{                                                                       \
+        return m0_be_tlist_prev(&name ## _tl, list, amb);               \
+}                                                                       \
+                                                                        \
+struct __ ## name ## _terminate_me_with_a_semicolon { ; }
+/** @} end of be_tlist group */
+
+#endif /* __MERO_BE_TLIST_H__ */
+
+/*
+ *  Local variables:
+ *  c-indentation-style: "K&R"
+ *  c-basic-offset: 8
+ *  tab-width: 8
+ *  fill-column: 80
+ *  scroll-step: 1
+ *  End:
+ */
diff --git a/be/be_types.h b/be/be_types.h
new file mode 100644
index 0000000..80f4e3a
--- /dev/null
+++ b/be/be_types.h
@@ -0,0 +1,55 @@
+/* -*- C -*- */
+/*
+ * COPYRIGHT 2012 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author              : Zishan Shaikh <zishan_shaikh@xyratex.com>
+ * Original creation date       : 12/04/2012
+ */
+#pragma once
+#ifndef __MERO_BE_TYPES_H__
+#define __MERO_BE_TYPES_H__
+
+#include "lib/types.h"
+
+/**
+ *      Structure added to support back-end domain wide reference pointer
+ */
+struct m0_be_reference {
+        /*
+         * Should always be the first field of this structure, stores the
+         * virtual address of the object on BE domain.
+         */
+        void             *be_virtual_address;
+        /* Higher 64 bit segment id & lower 64 bit offset within the segment */
+        struct m0_uint128 be_segid_offset;
+        /* 
+         * Set to domain magic when the object is allocated memory via be_alloc
+         */
+        uint64_t          be_magic;
+        /* usage : TBD */
+        uint64_t          be_magic_offset;
+};
+
+#endif /* __MERO_BE_BE_TYPES_H_ */
+
+/*
+ *  Local variables:
+ *  c-indentation-style: "K&R"
+ *  c-basic-offset: 8
+ *  tab-width: 8
+ *  fill-column: 80
+ *  scroll-step: 1
+ *  End:
+ */
diff --git a/be/domain.c b/be/domain.c
index 93e7a32..eccfb12 100644
--- a/be/domain.c
+++ b/be/domain.c
@@ -13,8 +13,8 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Sachin Patil <sachin_patil@xyratex.com>
- * Original creation date: 08 Nov 2012
+ * Original author              : Sachin Patil <sachin_patil@xyratex.com>
+ * Original creation date       : 11/08/2012
  */
 
 #include <stdio.h>
@@ -44,8 +44,8 @@ M0_INTERNAL void m0_be_domain_init(struct m0_be_domain *dom,
                                    struct m0_stob *log_stob,
                                    uint64_t dom_magic)
 {
-        int result;
-        m0_time_t t;
+        int          result;
+        m0_time_t    tsleep;
 
         M0_ASSERT(dom != NULL);
 
@@ -67,14 +67,14 @@ M0_INTERNAL void m0_be_domain_init(struct m0_be_domain *dom,
                 } else {
                         /** Retrying to create thread. */
                         m0_thread_fini(&dom->bd_impl.th);
-                        m0_nanosleep(m0_time_set(&t, 1, 0), NULL);
+                        m0_nanosleep(m0_time_set(&tsleep, 1, 0), NULL);
                 }
         }
         m0_be_seg_init(&dom->bd_data, dom, &dom->bd_impl.sm_group, 0);
 
         /**
          * @todo - Need to decide if m0_be_seg_init should be called
-         * instead of M0_BESEG_CLOSED state assignment
+         * instead of M0_BESEG_CLOSED state assignment.
          **/
         m0_sm_group_lock(&dom->bd_impl.sm_group);
         m0_sm_state_set(&dom->bd_data.bs_sm, M0_BESEG_CLOSED);
@@ -94,8 +94,8 @@ M0_INTERNAL void m0_be_domain_init(struct m0_be_domain *dom,
 M0_INTERNAL int m0_be_domain_lookup(struct m0_be_domain *dom, const char *name,
                                      struct m0_be_seg **out)
 {
-        struct m0_be_seg *seg_it;
-        int found = -1;
+        struct m0_be_seg        *seg_it;
+        int                      found = -1;
 
         M0_ASSERT(dom != NULL);
 
@@ -109,7 +109,6 @@ M0_INTERNAL int m0_be_domain_lookup(struct m0_be_domain *dom, const char *name,
                 }
         } m0_tlist_endfor;
 
-        /* This fills/adds segment into in-memory segment list on demand */
         if (found != 0) {
                 /* @todo - if found in persistent memory of named segment, then
                  * add into the in-memory active segment list
@@ -141,13 +140,13 @@ M0_INTERNAL void m0_be_domain_fini(struct m0_be_domain *dom)
                 m0_be_seg_fini(seg_it);
         } m0_tlist_endfor;
 
-        /* Finilize segment list */
+        /* Finilize segment list. */
         m0_be_seg_tlist_fini(&dom->bd_seg);
 
-        /* Finilize transaction list */
+        /* Finilize transaction list. */
         m0_be_tx_tlist_fini(&dom->bd_tx);
 
-        /* Finalize log device stob */
+        /* Finalize log device stob. */
         m0_stob_fini(dom->bd_impl.log_stob);
 }
 
@@ -160,7 +159,7 @@ M0_INTERNAL void m0_be_domain_restore(struct m0_be_domain *dom,
         struct  m0_stob_id        stob_id = {{0, 1}}; /** Hardcoded for now */
         int                       result;
         bool                      stob_directio = true;
-        int                       found = 0;
+        int                       found = -1;
 
         M0_ASSERT(dom != NULL);
 
@@ -169,16 +168,16 @@ M0_INTERNAL void m0_be_domain_restore(struct m0_be_domain *dom,
         m0_tlist_for(&m0_be_seg_tl, &dom->bd_seg, seg_it) {
                 if (strcmp(name, seg_it->bs_impl.segment_name) == 0) {
                         memcpy(out, seg_it, sizeof(struct m0_be_seg));
-                        found = 1;
+                        found = 0;
                         break;
                 }
         } m0_tlist_endfor;
 
-        if (found && (m0_be_seg_state_get(out) == M0_BESEG_CLOSED)) {
+        if ((found == 0) && (m0_be_seg_state_get(out) == M0_BESEG_CLOSED)) {
                 m0_be_seg_open(out);
         }
 
-        if (!found) {
+        if (found == -1) {
                 out->bs_impl.segment_id = 1;
 
                 m0_be_seg_init(out, dom, &dom->bd_impl.sm_group, 0);
@@ -201,6 +200,7 @@ M0_INTERNAL void m0_be_domain_restore(struct m0_be_domain *dom,
                         out->bs_stob->so_state = CSS_UNKNOWN;
                 }
 
+                strcpy(out->bs_impl.segment_name, name);
                 m0_be_seg_open(out);
 
                 m0_be_seg_tlink_init(out);
@@ -225,17 +225,17 @@ M0_INTERNAL void m0_be_handler_thread(struct m0_sm_group *sm_group)
                  */
                 m0_chan_wait(&sm_group->s_clink);
                 m0_sm_group_lock(sm_group);
-                m0_sm_asts_run(sm_group);
                 m0_sm_group_unlock(sm_group);
         }
 }
 
-struct m0_sm_group *m0_be_domain_sm_group(struct m0_be_domain *dom) {
+struct m0_sm_group *m0_be_domain_sm_group(struct m0_be_domain *dom)
+{
         return &dom->bd_impl.sm_group;
 }
 
-bool m0_be_domain_invariant(const struct m0_be_domain *dom) {
-
+bool m0_be_domain_invariant(const struct m0_be_domain *dom)
+{
         return true;
 }
 
diff --git a/be/domain.h b/be/domain.h
index 43c2d95..5b07e2b 100644
--- a/be/domain.h
+++ b/be/domain.h
@@ -13,8 +13,8 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Sachin Patil <sachin_patil@xyratex.com>
- * Original creation date: 25 Jan 2013
+ * Original author              : Sachin Patil <sachin_patil@xyratex.com>
+ * Original creation date       : 01/25/2013
  */
 
 #pragma once
@@ -26,8 +26,8 @@
   @defgroup be (Meta-data) back-end
   @{
 */
-
 #include "be/be.h"
+
 /**
  * Handler thread for backend domain.
  */
diff --git a/be/handle_store.c b/be/handle_store.c
new file mode 100644
index 0000000..fd10ca4
--- /dev/null
+++ b/be/handle_store.c
@@ -0,0 +1,120 @@
+/*
+ * COPYRIGHT 2013 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: Prashant Dhange <prashant_dhange@xyratex.com>
+ * Original creation date: 01/04/2013
+ */
+
+/**
+  @addtogroup handle_store
+  @{
+  */
+
+#include "be/be.h"
+#include "be/domain.h"
+#include "be/reg.h"
+#include "be/tx.h"
+#include "lib/memory.h"
+
+/**
+ * Handle store APIs
+ *
+ * m0_be_hs_init()           - Initialize handle store
+ * m0_be_hs_update()         - Update handle store address on RVM
+ * m0_be_hs_get()            - Get handle store reference (m0_uint128) from RVM
+ */
+static struct m0_be_seg *seg = NULL;
+
+M0_INTERNAL void m0_be_hs_init(struct m0_be_seg *segin)
+{
+        M0_ASSERT(segin != NULL);
+
+        seg = segin;
+
+        m0_be_static_reg_init(seg->bs_static_addr);
+}
+
+M0_INTERNAL void m0_be_hs_update(uint64_t index, struct m0_uint128 *h_addr)
+{
+        struct m0_be_tx         tx;
+        struct m0_uint128      *elem;
+        struct m0_be_reg       *reg;
+        uint64_t                offset;
+
+        m0_be_tx_init(&tx, seg->bs_dom, 0);
+
+        m0_sm_group_lock(m0_be_domain_sm_group(tx.bt_dom));
+        m0_sm_timedwait(&tx.bt_sm,
+                        (1 << M0_BETX_INIT) | (1 << M0_BETX_FAILED),
+                        M0_TIME_NEVER);
+        m0_sm_group_unlock(m0_be_domain_sm_group(tx.bt_dom));
+        
+        M0_ALLOC_PTR(reg);
+
+        M0_ASSERT(reg != NULL);
+
+        offset = index * sizeof(struct m0_uint128);
+
+        m0_be_static_reg_capture_buf(offset, seg, reg, &tx);
+
+        m0_sm_group_lock(m0_be_domain_sm_group(tx.bt_dom));
+        m0_sm_timedwait(&tx.bt_sm,
+                        (1 << M0_BETX_PREPARED) | (1 << M0_BETX_FAILED),
+                        M0_TIME_NEVER);
+        m0_sm_group_unlock(m0_be_domain_sm_group(tx.bt_dom));
+
+        m0_be_tx_start(&tx);
+        m0_sm_group_lock(m0_be_domain_sm_group(tx.bt_dom));
+        m0_sm_timedwait(&tx.bt_sm,
+                        (1 << M0_BETX_OPEN) | (1 << M0_BETX_FAILED),
+                        M0_TIME_NEVER);
+        m0_sm_group_unlock(m0_be_domain_sm_group(tx.bt_dom));
+
+        elem = (struct m0_uint128 *) m0_be_static_reg_get_handle_addr(offset);
+
+        elem->u_hi = h_addr->u_hi;
+        elem->u_lo = h_addr->u_lo;
+
+        m0_be_tx_done(&tx);
+
+        m0_sm_group_lock(m0_be_domain_sm_group(tx.bt_dom));
+        m0_sm_timedwait(&tx.bt_sm,
+                        (1 << M0_BETX_DONE) | (1 << M0_BETX_FAILED),
+                        M0_TIME_NEVER);
+        m0_sm_group_unlock(m0_be_domain_sm_group(tx.bt_dom));
+        m0_be_tx_fini(&tx);
+
+        m0_free(reg);
+}
+
+
+M0_INTERNAL struct m0_uint128 *m0_be_hs_get(uint64_t index)
+{
+        uint64_t offset = index * sizeof(struct m0_uint128);
+
+        return (struct m0_uint128 *) m0_be_static_reg_get_handle_addr(offset);
+}
+
+/** @} end group handle_store */
+
+/*
+ *  Local variables:
+ *  c-indentation-style: "K&R"
+ *  c-basic-offset: 8
+ *  tab-width: 8
+ *  fill-column: 80
+ *  scroll-step: 1
+ *  End:
+ */
diff --git a/be/handle_store.h b/be/handle_store.h
new file mode 100644
index 0000000..97c9f9b
--- /dev/null
+++ b/be/handle_store.h
@@ -0,0 +1,53 @@
+/*
+ * COPYRIGHT 2013 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: Prashant Dhange <prashant_dhange@xyratex.com>
+ * Original creation date: 01/04/2013
+ */
+
+#pragma once
+
+#ifndef __MERO_BE_HANDLE_STORE_H__
+#define __MERO_BE_HANDLE_STORE_H__
+
+/**
+  @defgroup be (Meta-data) back-end
+
+  Contains routines to make the kv_store handle persistent and to retrieve it
+  back from RVM.
+  @{
+  */
+#include "be/be.h"
+
+M0_INTERNAL void m0_be_hs_init(struct m0_be_seg *segin);
+
+M0_INTERNAL void m0_be_hs_update(uint64_t index, struct m0_uint128 *h_addr);
+
+M0_INTERNAL struct m0_uint128 *m0_be_hs_get(uint64_t index);
+
+/** @} end of be group */
+
+/* __MERO_BE_HANDLE_STORE_H__ */
+#endif
+
+/*
+ *  Local variables:
+ *  c-indentation-style: "K&R"
+ *  c-basic-offset: 8
+ *  tab-width: 8
+ *  fill-column: 80
+ *  scroll-step: 1
+ *  End:
+ */
diff --git a/be/helper.c b/be/helper.c
new file mode 100644
index 0000000..de08c21
--- /dev/null
+++ b/be/helper.c
@@ -0,0 +1,207 @@
+/* -*- C -*- */
+/*
+ * COPYRIGHT 2012 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author              : Zishan Shaikh <zishan_shaikh@xyratex.com>
+ * Original creation date       : 12/28/2012
+ */
+
+/**
+   @addtogroup helper Helper Routines
+   @{
+ */
+#include "be/helper.h"
+#include "be/seg.h"
+
+M0_INTERNAL void m0_be_ks_init_domain(struct m0_be_domain  **out_dom)
+{
+        struct m0_be_domain  *dom;
+
+        M0_ALLOC_PTR(dom);
+        M0_ASSERT(dom != NULL);
+
+        if ((*out_dom) == NULL) {
+                m0_be_domain_create(dom, NULL);
+                M0_ASSERT(dom != NULL);
+        }
+
+        /**
+          Initialise the domain with some magic.
+          For now, we use M0_BE_DOMAIN_MAGIC.
+         */
+        m0_be_domain_init(dom, NULL, NULL, M0_BE_DOMAIN_MAGIC);
+        dom->bd_data.bs_sm.sm_state = M0_BESEG_ACTIVE;
+
+        *out_dom = dom;
+}
+M0_EXPORTED(m0_be_ks_init_domain);
+
+M0_INTERNAL int m0_be_ks_domain_lookup(struct m0_be_domain     *dom,
+                                       struct m0_be_seg       **seg,
+                                       char                    *name)
+{
+        struct m0_sm_group *sm_group;
+        int                 ret_val;
+
+        sm_group = m0_be_domain_sm_group(dom);
+
+        ret_val = m0_be_domain_lookup(dom, name, seg);
+
+        /** Wait only if lookup succeeds. */
+        if (ret_val == 0 && m0_be_seg_state_get(*seg) != M0_BESEG_ACTIVE) {
+                m0_be_wait(sm_group, &(*seg)->bs_sm,
+                           M0_BITS(M0_BESEG_ACTIVE, M0_BESEG_FAILED));
+        }
+
+        return ret_val;
+}
+M0_EXPORTED(m0_be_ks_domain_lookup);
+
+M0_INTERNAL int m0_be_ks_domain_restore(struct m0_be_domain *dom,
+                                        struct m0_be_seg    *seg,
+                                        char                *name)
+{
+        struct m0_sm_group *sm_group;
+        
+        sm_group = m0_be_domain_sm_group(dom);
+
+        m0_be_domain_restore(dom, name, seg);
+        m0_be_wait(sm_group, &seg->bs_sm,
+                   M0_BITS(M0_BESEG_ACTIVE, M0_BESEG_FAILED));
+
+        /** If opening the segment failed, fini the @seg and return. */
+        if (seg->bs_sm.sm_state == M0_BESEG_FAILED) {
+                m0_be_seg_fini(seg);
+                return BE_KV_FAILURE;
+        }
+        return BE_KV_SUCCESS;
+}
+M0_EXPORTED(m0_be_ks_domain_restore);
+
+M0_INTERNAL void *m0_be_ks_obj_malloc(struct m0_be_reg        *obj_reg,
+                                      struct m0_be_reference **obj_ref)
+{
+        M0_PRE(obj_reg->br_sm.sm_state == M0_BEREG_INIT);
+        struct m0_be_domain     *dom;
+        void                    *obj;
+        struct m0_sm_group      *sm_group;
+
+        M0_ASSERT(obj_reg != NULL);
+
+        dom      = obj_reg->br_seg->bs_dom;
+        sm_group = m0_be_domain_sm_group(dom);
+
+        /** Allocate memory from RVM. */
+        m0_be_alloc(obj_reg);
+        m0_be_wait(sm_group, &obj_reg->br_sm,
+                   M0_BITS(M0_BEREG_ALLOCATED, M0_BEREG_FAILED));
+
+        /** Capture this region explicitly. */
+        m0_be_reg_capture(obj_reg);
+        m0_be_wait(sm_group, &obj_reg->br_sm,
+                   M0_BITS(M0_BEREG_CAPTURED, M0_BEREG_FAILED));
+
+        obj = obj_reg->br_buf.b_addr;
+        if (obj == NULL)
+                goto exit_failure;
+
+        /** Collect the reference to be returned to the user. */
+        (*obj_ref) = &obj_reg->br_buf.b_logical_address;
+
+        return obj;
+
+exit_failure:
+        return NULL;
+}
+M0_EXPORTED(m0_be_ks_obj_malloc);
+
+M0_INTERNAL void m0_be_ks_fini(struct m0_be_domain *dom, struct m0_be_seg *seg)
+{
+        m0_be_seg_done(seg);
+        dom->bd_data.bs_sm.sm_state = M0_BESEG_CLOSED;
+        rvm_truncate();
+        m0_be_domain_fini(dom);
+}
+M0_EXPORTED(m0_be_ks_fini);
+
+M0_INTERNAL void m0_be_ks_tx_prep(struct m0_be_tx *tx)
+{
+        struct m0_sm_group      *sm_group;
+
+        sm_group = m0_be_domain_sm_group(tx->bt_dom);
+
+        m0_be_tx_prep(tx);
+        m0_be_wait(sm_group, &tx->bt_sm,
+                   M0_BITS(M0_BETX_PREPARED, M0_BETX_FAILED));
+}
+M0_EXPORTED(m0_be_ks_tx_prep);
+
+M0_INTERNAL void m0_be_ks_tx_start(struct m0_be_tx *tx)
+{
+        struct m0_sm_group      *sm_group;
+
+        sm_group = m0_be_domain_sm_group(tx->bt_dom);
+
+        m0_be_tx_start(tx);
+        m0_be_wait(sm_group, &tx->bt_sm,
+                   M0_BITS(M0_BETX_OPEN, M0_BETX_FAILED));
+}
+M0_EXPORTED(m0_be_ks_tx_prep_start);
+
+M0_INTERNAL void m0_be_ks_prep_link_reg(struct m0_be_domain    *dom,
+                                        struct m0_be_list_link *link,
+                                        struct m0_be_tx        *tx,
+                                        struct m0_be_reg      **reg)
+{
+        struct m0_be_seg        *seg = NULL;
+        struct m0_sm_group      *sm_group;
+        struct m0_be_buf         buf;
+        int                      ret_val;
+
+        sm_group = m0_be_domain_sm_group(dom);
+
+        /** Lookup for the kv_store segment. If not found, create one. */
+        ret_val = m0_be_ks_domain_lookup(dom, &seg, BE_KV_SEG_NAME);
+        M0_ASSERT(ret_val == 0);
+        M0_ASSERT(seg != NULL);
+
+        M0_ALLOC_PTR((*reg));
+        M0_ASSERT((*reg) != NULL);
+        buf.b_nob = sizeof(struct m0_be_list_link);
+        buf.b_addr = (void *)link;
+        m0_be_reg_init((*reg), tx, seg, &buf);
+}
+M0_EXPORTED(m0_be_ks_prep_link);
+
+M0_INTERNAL void m0_be_wait(struct m0_sm_group *sm_group,
+                            struct m0_sm       *sm, uint64_t allowed_states)
+{
+        m0_sm_group_lock(sm_group);
+        m0_sm_timedwait(sm, allowed_states, M0_TIME_NEVER);
+        m0_sm_group_unlock(sm_group);
+}
+M0_EXPORTED(m0_be_wait);
+
+/* @} end of helper group */
+
+/*
+ * Local variables:
+ * c-indentation-style: "K&R"
+ * c-basic-offset: 8
+ * tab-width: 8
+ * fill-column: 80
+ * scroll-step: 1
+ * End:
+ */
diff --git a/be/helper.h b/be/helper.h
new file mode 100644
index 0000000..2afce2d
--- /dev/null
+++ b/be/helper.h
@@ -0,0 +1,131 @@
+/* -*- C -*- */
+/*
+ * COPYRIGHT 2012 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author              : Zishan Shaikh <zishan_shaikh@xyratex.com>
+ * Original creation date       : 12/28/2012
+ */
+#pragma once
+#ifndef __MERO_BE_HELPER_H__
+#define __MERO_BE_HELPER_H__
+
+#include "be/be.h"
+#include "be/domain.h"
+#include "lib/memory.h"
+#include "be/be_list.h"
+#include "mero/magic.h"
+
+/**
+  @defgroup helper Helper Routines
+
+  Contains helper routines and enum used by key value store.
+  @{
+ */
+
+/**
+  Return values and control operations used by kv_store.
+ */
+enum {
+        /** Return Values. */
+        BE_KV_SUCCESS        = 0,
+        BE_KV_FAILURE        = 111,
+        BE_KV_DUPLICATE      = 222,
+        BE_KV_OUT_OF_DOMAIN  = 333,
+        BE_KV_INVALID_REQ    = 444,
+
+        /** Control operations in specific functions. */
+        BE_KV_INSERT         = 555,
+        BE_KV_DELETE         = 666,
+        BE_KV_IN_TX_NULL     = 777,
+        BE_KV_IN_TX_NOT_NULL = 888,
+};
+
+/**
+  Segment name used for kv_store objects.
+ */
+#define BE_KV_SEG_NAME "kv_store"
+M0_INTERNAL void m0_be_ks_init_domain(struct m0_be_domain  **out_dom);
+
+M0_INTERNAL void m0_be_ks_fini(struct m0_be_domain *dom, struct m0_be_seg *seg);
+
+/**
+  Lookup for a segment identified by the @segid within the domain.
+  @param dom    :       domain to lookup in.
+  @param seg    :       segment to be returned.
+  @param name   :       name of the segment to be looked up.
+  @retval 0     :       on successful lookup.
+  @retval -1    :       on failed lookup.
+ */
+M0_INTERNAL int m0_be_ks_domain_lookup(struct m0_be_domain   *dom,
+                                       struct m0_be_seg     **seg,
+                                       char                  *name);
+
+/**
+  Tries to open a segment with @segid.
+  Used while recovery of kv store handle.
+
+  @param dom    :       domain to lookup in.
+  @param seg    :       segment to be returned.
+  @param name   :       name of the segment to be looked up.
+  @retval BE_KV_FAILURE :       on failure to open a segment.
+  @return BE_KV_SUCCESS :       on successful restore of segment.
+ */
+M0_INTERNAL int m0_be_ks_domain_restore(struct m0_be_domain *dom,
+                                        struct m0_be_seg    *seg,
+                                        char                *name);
+
+/**
+  Allocates memory to an object.
+  
+  @param obj_reg        :       initialised region for the object.
+  @param obj_ref        :       reference to be filled up.
+  @return allocated chunk of memory.
+  @return the reference of the allocated chunk in @obj_ref.
+  PRE: reg_init must be already done on @obj_reg.
+ */
+M0_INTERNAL void *m0_be_ks_obj_malloc(struct m0_be_reg        *obj_reg,
+                                      struct m0_be_reference **obj_ref);
+
+M0_INTERNAL void m0_be_ks_tx_prep(struct m0_be_tx *tx);
+
+M0_INTERNAL void m0_be_ks_tx_start(struct m0_be_tx *tx);
+
+/**
+  Prepares and carries out reg_init for @reg for the linkage @link.
+ */
+M0_INTERNAL void m0_be_ks_prep_link_reg(struct m0_be_domain    *dom,
+                                        struct m0_be_list_link *link,
+                                        struct m0_be_tx        *tx,
+                                        struct m0_be_reg      **reg);
+
+/**
+  Helper routine for timedwait.
+ */
+M0_INTERNAL void m0_be_wait(struct m0_sm_group *sm_group,
+                            struct m0_sm       *sm, uint64_t allowed_states);
+
+/** @} end of helper group */
+
+#endif /* __MERO_BE_HELPER_H__ */
+
+/*
+ * Local variables:
+ * c-indentation-style: "K&R"
+ * c-basic-offset: 8
+ * tab-width: 8
+ * fill-column: 80
+ * scroll-step: 1
+ * End:
+ */
diff --git a/be/kv_store.c b/be/kv_store.c
new file mode 100644
index 0000000..c912663
--- /dev/null
+++ b/be/kv_store.c
@@ -0,0 +1,734 @@
+/* -*- C -*- */
+/*
+ * COPYRIGHT 2012 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: Zishan Shaikh <zishan_shaikh@xyratex.com>
+ * Original creation date: 12/24/2012
+ */
+#include "be/kv_store.h"
+#include "be/handle_store.h"
+#include "be/be_buf.h"
+#include "be/helper.h"
+
+/**
+   @addtogroup be_kv_store
+   @{
+ */
+
+/**
+  Gives the linkage of the previous object for current. The previous pointer is
+  updated in @link_prev.
+ */
+static void __ks_get_prev(struct m0_be_tl_descr   *d,
+                          void                    *current,
+                          struct m0_be_list_link **link_prev);
+
+/**
+  Gives the linkage of the next object for current. The next pointer is
+  updated in @link_next.
+ */
+static void __ks_get_next(struct m0_be_tl_descr   *d,
+                          void                    *current,
+                          struct m0_be_list_link **link_next);
+
+/**
+  Gives the linkage of the current object. The pointer is updated in
+  @link_current.
+ */
+static void __ks_get_current(struct m0_be_tl_descr   *d,
+                             void                    *current,
+                             struct m0_be_list_link **link_cuurent);
+
+/**
+  Adds or captures the regions of the current, next & previous pointers of
+  @current object, depending upon @in_tx_state.
+ */
+static void __ks_prev_next_add_cred(struct m0_be_kv_store     *handle,
+                                    struct m0_be_tx           *tx,
+                                    void                      *current,
+                                    int                        in_tx_state,
+                                    int                        operation);
+
+M0_INTERNAL void m0_be_ks_create_handle(struct m0_be_domain        *dom,
+                                        struct m0_be_tl_descr      *descr,
+                                        struct m0_be_kv_store_rvm **rvm_han_out)
+{
+        struct m0_be_tx             *tx;
+        struct m0_be_reg            *rvm_handle_reg;
+        struct m0_be_reference_ll   *head;
+        struct m0_be_reference_ll   *tail;
+        struct m0_be_reference      *rvm_handle_ref;
+        struct m0_be_kv_store_rvm   *rvm_handle;
+        struct m0_uint128           *temp_head_offset;
+        struct m0_uint128           *temp_tail_offset;
+        struct m0_sm_group          *sm_group;
+        struct m0_be_seg            *rvm_handle_seg = NULL;
+        struct m0_be_buf             rvm_handle_buf;
+        int                          ret_val;
+
+        M0_ALLOC_PTR(tx);
+        M0_ASSERT(tx != NULL);
+
+        if (tx == NULL)
+                return;
+
+        /** Lookup for the kv_store segment. */
+        sm_group = m0_be_domain_sm_group(dom);
+
+        ret_val = m0_be_ks_domain_lookup(dom, &rvm_handle_seg, BE_KV_SEG_NAME);
+        M0_ASSERT(ret_val == 0);
+        M0_ASSERT(rvm_handle_seg != NULL);
+
+        /** Initialise the handle_store with the static addr in this segment. */
+        m0_be_hs_init(rvm_handle_seg);
+
+        m0_be_tx_init(tx, dom, 0);
+        m0_be_wait(sm_group, &tx->bt_sm, M0_BITS(M0_BETX_INIT, M0_BETX_FAILED));
+
+        /** Prepare a region for the rvm_handle. */
+        M0_ALLOC_PTR(rvm_handle_reg);
+        M0_ASSERT(rvm_handle_reg != NULL);
+
+        rvm_handle_buf.b_nob = sizeof(struct m0_be_kv_store_rvm);
+        m0_be_reg_init(rvm_handle_reg, tx, rvm_handle_seg, &rvm_handle_buf);
+
+        m0_be_ks_tx_start(tx);
+
+        rvm_handle = (struct m0_be_kv_store_rvm *)
+                      m0_be_ks_obj_malloc(rvm_handle_reg, &rvm_handle_ref);
+
+        M0_ASSERT(rvm_handle != NULL);
+        M0_ASSERT(rvm_handle_ref != NULL);
+
+        /**
+          Store this handle information at index 0 in handle_store.
+         */
+        m0_be_hs_update(0, &rvm_handle_ref->be_segid_offset);
+
+        m0_be_tlist_init(descr, &rvm_handle->ks_tlist);
+
+        /* Update segment id & offset in head & tail. */
+        head = &rvm_handle->ks_tlist.t_head.l_head;
+        tail = &rvm_handle->ks_tlist.t_head.l_tail;
+
+        temp_head_offset       = &head->n_logical_address.be_segid_offset;
+        temp_head_offset->u_hi = rvm_handle_ref->be_segid_offset.u_hi;
+        temp_head_offset->u_lo = rvm_handle_ref->be_segid_offset.u_lo;
+
+        temp_tail_offset       = &tail->n_logical_address.be_segid_offset;
+        temp_tail_offset->u_hi = rvm_handle_ref->be_segid_offset.u_hi;
+        temp_tail_offset->u_lo = rvm_handle_ref->be_segid_offset.u_lo;
+
+        head->n_logical_address.be_magic = dom->bd_magic;
+        tail->n_logical_address.be_magic = dom->bd_magic;
+
+        (*rvm_han_out) = rvm_handle;
+        M0_ASSERT((*rvm_han_out) != NULL);
+
+        m0_be_tx_done(tx);
+        m0_be_wait(sm_group, &tx->bt_sm, M0_BITS(M0_BETX_DONE, M0_BETX_FAILED));
+
+        m0_be_tx_fini(tx);
+        m0_free(tx);
+}
+M0_EXPORTED(m0_be_ks_create_handle);
+
+M0_INTERNAL void m0_be_ks_init(struct m0_be_kv_store    **out_handle,
+                               struct m0_be_tl_descr     *descr,
+                               struct m0_be_domain       *dom,
+                               kv_key_cmp                 cmp_fp,
+                               kv_key_match               match_fp,
+                               char                      *mode)
+{
+        struct m0_be_kv_store      *handle = NULL;
+        struct m0_be_kv_store_rvm  *rvm_handle;
+        struct m0_sm_group         *sm_group;
+        struct m0_be_seg           *rvm_handle_seg = NULL;
+        int                         ret_val;
+        int                         recovery_status = -1;
+
+        if ((*out_handle) == NULL) {
+                        M0_ALLOC_PTR(handle);
+                        M0_ASSERT(handle != NULL);
+        }
+
+
+        sm_group = m0_be_domain_sm_group(dom);
+
+        if (strcmp(mode, "RECOVER") == 0 || strcmp(mode, "recover") == 0) {
+                M0_ALLOC_PTR(rvm_handle_seg);
+                M0_ASSERT(rvm_handle_seg != NULL);
+                recovery_status = m0_be_ks_domain_restore(dom, rvm_handle_seg,
+                                                          BE_KV_SEG_NAME);
+                M0_ASSERT(recovery_status == BE_KV_SUCCESS);
+        } else {
+                /**
+                  Lookup for the kv_store segment.
+                  If not found, create one.
+                 */
+                ret_val = m0_be_ks_domain_lookup(dom, &rvm_handle_seg,
+                                                 BE_KV_SEG_NAME);
+                if (ret_val !=0) {
+                        M0_ALLOC_PTR(rvm_handle_seg);
+                        M0_ASSERT(rvm_handle_seg != NULL);
+
+                        m0_be_seg_init(rvm_handle_seg, dom, sm_group, 0);
+                        m0_be_seg_create(rvm_handle_seg, NULL,  BE_KV_SEG_NAME,
+                                         NULL);
+                        m0_be_wait(sm_group, &rvm_handle_seg->bs_sm,
+                                   M0_BITS(M0_BESEG_ACTIVE, M0_BESEG_FAILED));
+                }
+        }
+
+        m0_be_hs_init(rvm_handle_seg);
+
+        /**
+          Try to recover the handle from index 0 in the handle_store.
+          If recovery fails, create a new handle.
+         */
+        ret_val = m0_be_ks_deref_handle(handle, rvm_handle_seg);
+
+        if (ret_val == BE_KV_FAILURE && recovery_status != BE_KV_SUCCESS) {
+                m0_be_ks_create_handle(dom, descr, &rvm_handle);
+                M0_ASSERT(rvm_handle != NULL);
+                handle->handle_rvm = rvm_handle;
+        }
+
+        /** Set the non_rvm part of the handle with user values. */
+        handle->handle_heap = (struct m0_be_kv_store_heap){
+                .ks_key_cmp    = cmp_fp,
+                .ks_key_match  = match_fp,
+                .ks_list_descr = descr,
+                .ks_dom        = dom
+        };
+
+        (*out_handle) = handle;
+}
+M0_EXPORTED(m0_be_ks_init);
+
+M0_INTERNAL struct m0_be_reference
+*m0_be_ks_get_next_val(struct m0_be_kv_store *handle, void *obj)
+{
+        struct m0_be_list_link  *link_next;
+        struct m0_be_reference  *ret_ref;
+        void                    *temp_tail;
+        struct m0_be_tl         *ks_tlist;
+        struct m0_be_tl_descr   *ks_list_descr;
+
+        ks_tlist      = &handle->handle_rvm->ks_tlist;
+        ks_list_descr = handle->handle_heap.ks_list_descr;
+
+        temp_tail = m0_be_tlist_tail(ks_list_descr, ks_tlist);
+
+        /** If object is last in linked list, then its next will be itself. */
+        if (temp_tail == obj) {
+                __ks_get_current(ks_list_descr, obj, &link_next);
+                goto get_ref;
+        }
+
+        __ks_get_next(ks_list_descr, obj, &link_next);
+
+get_ref:
+        ret_ref  = &link_next->ll_next.n_logical_address;
+        return ret_ref;
+}
+M0_EXPORTED(m0_be_ks_get_next_value);
+
+M0_INTERNAL void *m0_be_ks_find(struct m0_be_kv_store *handle,
+                                void                  *key)
+{
+        /**
+          In case the target is not found, the function returns "target"
+          as NULL.
+         */
+        void                    *scan;
+        void                    *target = NULL;
+        struct m0_be_tl         *ks_tlist;
+        struct m0_be_tl_descr   *ks_list_descr;
+
+        ks_tlist = &handle->handle_rvm->ks_tlist;
+        ks_list_descr = handle->handle_heap.ks_list_descr;
+
+        m0_be_tlist_for(ks_list_descr, ks_tlist, scan) {
+                if (handle->handle_heap.ks_key_match(scan, key) == 0) {
+                        target = scan;
+                        break;
+                }
+        } m0_be_tlist_endfor;
+
+        return target;
+}
+M0_EXPORTED(m0_be_ks_find);
+
+M0_INTERNAL int m0_be_ks_delete(struct m0_be_kv_store  *handle,
+                                void                   *obj,
+                                struct m0_be_tx        *del_tx)
+{
+        void                    *scan;
+        void                    *target = NULL;
+        struct m0_be_reg        *t_head_reg;
+        struct m0_be_list_link  *temp_link;
+        struct m0_be_list_link  *t_head_link;
+        struct m0_be_list_link  *head;
+        struct m0_be_tl         *ks_tlist;
+        struct m0_be_tl_descr   *ks_list_descr;
+        struct m0_be_domain     *ks_dom;
+        struct m0_sm_group      *sm_group;
+        struct m0_be_tx         *tx             = del_tx;
+        int                      del_tx_state   = BE_KV_IN_TX_NOT_NULL;
+        int                      target_found;
+
+        ks_list_descr  = handle->handle_heap.ks_list_descr;
+        ks_tlist       = &handle->handle_rvm->ks_tlist;
+        head           = (void *)&ks_tlist->t_head;
+        ks_dom         = handle->handle_heap.ks_dom;
+        sm_group       = m0_be_domain_sm_group(ks_dom);
+
+        /** If tx is not provided create and start a new one. */
+        if (del_tx == NULL) {
+                del_tx_state = BE_KV_IN_TX_NULL;
+
+                M0_ALLOC_PTR(tx);
+                M0_ASSERT(tx != NULL);
+
+                m0_be_tx_init(tx, ks_dom, 0);
+                m0_be_wait(sm_group, &tx->bt_sm,
+                           M0_BITS(M0_BETX_INIT, M0_BETX_FAILED));
+        }
+
+        /** Find the target node to be deleted. */
+        m0_be_tlist_for(ks_list_descr, ks_tlist, scan) {
+                if (handle->handle_heap.ks_key_cmp(scan, obj) == 0) {
+                        target = scan;
+                        target_found = BE_KV_SUCCESS;
+                        break;
+                }
+        } m0_be_tlist_endfor;
+
+        if (target_found == BE_KV_SUCCESS) {
+                /** Capture t_head. */
+                temp_link   = head->ll_next.n_virtual_address;
+                t_head_link = temp_link->ll_prev.n_virtual_address;
+                M0_ASSERT(t_head_link != NULL);
+
+                m0_be_ks_prep_link_reg(ks_dom, t_head_link, tx, &t_head_reg);
+                M0_ASSERT(t_head_reg != NULL);
+
+                if (del_tx == NULL) {
+                        m0_be_tx_add_cred(tx, t_head_reg);
+                } else {
+                        m0_be_reg_capture(t_head_reg);
+                        m0_be_wait(sm_group, &t_head_reg->br_sm,
+                                   M0_BITS(M0_BEREG_CAPTURED, M0_BEREG_FAILED));
+                }
+
+                /**
+                  Add the current, previous and next pointers about to
+                  be modified to the credit or captures them depending
+                  upon the transaction received.
+                 */
+                __ks_prev_next_add_cred(handle, tx, target, del_tx_state,
+                                        BE_KV_DELETE);
+
+                if (del_tx == NULL) {
+                        m0_be_ks_tx_prep(tx);
+                        m0_be_ks_tx_start(tx);
+                }
+
+                /** Now delete. */
+                m0_be_tlink_del_fini(ks_list_descr, target);
+
+                if (del_tx == NULL) {
+                        m0_be_tx_done(tx);
+                        m0_be_wait(sm_group, &tx->bt_sm,
+                                   M0_BITS(M0_BETX_DONE, M0_BETX_FAILED));
+                        m0_be_tx_fini(tx);
+                        m0_free(tx);
+                }
+                goto exit_success;
+        }
+
+        goto exit_failure;
+
+exit_success:
+        return BE_KV_SUCCESS;
+exit_failure:
+        return BE_KV_FAILURE;
+}
+M0_EXPORTED(m0_be_ks_delete);
+
+M0_INTERNAL int __ks_tlist_add_at_tail(struct m0_be_kv_store     *handle,
+                                       void                      *new,
+                                       struct m0_be_tx           *tx,
+                                       int                        in_tx_state)
+{
+        struct m0_be_reg        *tail_obj_reg;
+        struct m0_be_list_link  *tail_obj_link;
+        struct m0_be_tl         *ks_tlist;
+        struct m0_be_tl_descr   *ks_list_descr;
+        struct m0_be_domain     *ks_dom;
+        struct m0_sm_group      *sm_group;
+        void                    *tail_obj;
+
+        ks_list_descr = handle->handle_heap.ks_list_descr;
+        ks_tlist      = &handle->handle_rvm->ks_tlist;
+        ks_dom        = handle->handle_heap.ks_dom;
+        sm_group      = m0_be_domain_sm_group(ks_dom);
+
+        /** Add current tail to credit. */
+        tail_obj  = m0_be_tlist_tail(ks_list_descr, ks_tlist);
+
+        __ks_get_current(ks_list_descr, tail_obj, &tail_obj_link);
+        M0_ASSERT(tail_obj_link != NULL);
+
+        /** Init a region for this link. */
+        m0_be_ks_prep_link_reg(ks_dom, tail_obj_link, tx, &tail_obj_reg);
+        M0_ASSERT(tail_obj_reg != NULL);
+
+        if (in_tx_state == BE_KV_IN_TX_NULL) {
+                m0_be_tx_add_cred(tx, tail_obj_reg);
+                m0_be_ks_tx_prep(tx);
+                m0_be_ks_tx_start(tx);
+        } else {
+                m0_be_reg_capture(tail_obj_reg);
+                m0_be_wait(sm_group, &tail_obj_reg->br_sm,
+                           M0_BITS(M0_BEREG_CAPTURED, M0_BEREG_FAILED));
+        }
+
+        /** Finally, add at tail in tlist. */
+        m0_be_tlist_add_tail(ks_list_descr, ks_tlist, new);
+        return BE_KV_SUCCESS;
+}
+
+M0_INTERNAL int m0_be_ks_insert(struct m0_be_kv_store      *handle,
+                                struct m0_be_reference     *obj_ref,
+                                struct m0_be_tx            *ins_tx)
+{
+        struct m0_be_reg        *obj_link_reg;
+        struct m0_be_domain     *dom;
+        struct m0_be_reg        *t_head_reg;
+        struct m0_be_list_link  *link;
+        struct m0_be_tl         *ks_tlist;
+        struct m0_be_tl_descr   *ks_list_descr;
+        struct m0_be_list_link  *head;
+        struct m0_be_tx         *tx = ins_tx;
+        struct m0_sm_group      *sm_group;
+        void                    *new;
+        void                    *scan;
+        int                      ret_val       = BE_KV_INVALID_REQ;
+        int                      in_tx_state   = BE_KV_IN_TX_NOT_NULL;
+
+        ks_list_descr = handle->handle_heap.ks_list_descr;
+
+        ks_tlist = &handle->handle_rvm->ks_tlist;
+        dom      = handle->handle_heap.ks_dom;
+        sm_group = m0_be_domain_sm_group(dom);
+
+        /** Ensure object is allocated on same domain as that of handle. */
+        if (obj_ref->be_magic != dom->bd_magic) {
+                ret_val = BE_KV_OUT_OF_DOMAIN;
+                goto exit_insert;
+        }
+
+        /** Collect the object to be inserted. */
+        new = obj_ref->be_virtual_address;
+
+        /** Check for duplicate insertion. */
+        m0_be_tlist_for(ks_list_descr, ks_tlist, scan) {
+                if (handle->handle_heap.ks_key_cmp(new, scan) == 0) {
+                        ret_val = BE_KV_DUPLICATE;
+                        goto exit_insert;
+                }
+        } m0_be_tlist_endfor;
+
+        /** If tx is not provided, create and start a new one. */
+        if (ins_tx == NULL) {
+                in_tx_state = BE_KV_IN_TX_NULL;
+                M0_ALLOC_PTR(tx);
+                M0_ASSERT(tx != NULL);
+
+                m0_be_tx_init(tx, dom, 0);
+
+                m0_be_wait(sm_group, &tx->bt_sm,
+                           M0_BITS(M0_BETX_INIT, M0_BETX_FAILED));
+        }
+
+        /** Tlink init for this object. */
+        m0_be_tlink_init(ks_list_descr, obj_ref);
+
+        __ks_get_current(ks_list_descr, new, &link);
+        M0_ASSERT(link != NULL);
+
+        /** Init a region for this link. */
+        m0_be_ks_prep_link_reg(dom, link, tx, &obj_link_reg);
+        M0_ASSERT(obj_link_reg != NULL);
+
+        /** Capture this region. */
+        if (ins_tx == NULL)
+                m0_be_tx_add_cred(tx, obj_link_reg);
+        else {
+                m0_be_reg_capture(obj_link_reg);
+                m0_be_wait(sm_group, &obj_link_reg->br_sm,
+                           M0_BITS(M0_BEREG_CAPTURED, M0_BEREG_FAILED));
+        }
+
+        head = (void *)&ks_tlist->t_head;
+
+        /** Check if tlist is empty. */
+        if ((head->ll_next.n_virtual_address == (void *)head) &&
+            (head->ll_prev.n_virtual_address == (void *)head)) {
+
+                /** Capture t_head. */
+                m0_be_ks_prep_link_reg(dom, head, tx, &t_head_reg);
+                M0_ASSERT(t_head_reg != NULL);
+
+                /** Capture this region. */
+                if (ins_tx == NULL) {
+                        m0_be_tx_add_cred(tx, t_head_reg);
+                        m0_be_ks_tx_prep(tx);
+                        m0_be_ks_tx_start(tx);
+                } else {
+                        m0_be_reg_capture(t_head_reg);
+                        m0_be_wait(sm_group, &t_head_reg->br_sm,
+                                   M0_BITS(M0_BEREG_CAPTURED, M0_BEREG_FAILED));
+                }
+
+                /** Add to tlist now. */
+                m0_be_tlist_add(ks_list_descr, ks_tlist, new);
+                ret_val = BE_KV_SUCCESS;
+        } else {
+                /**
+                  Else, find the appropriate position for the obj and insert.
+                 */
+                m0_be_tlist_for(ks_list_descr, ks_tlist, scan)
+                {
+                        if (handle->handle_heap.ks_key_cmp(new, scan) < 0) {
+
+                                /** Capture t_head. */
+                                m0_be_ks_prep_link_reg(dom, head, tx,
+                                                       &t_head_reg);
+                                M0_ASSERT(t_head_reg != NULL);
+
+                                /**
+                                  Add the current, previous and next pointers
+                                  about to be modified to the credit.
+                                 */
+                                __ks_prev_next_add_cred(handle, tx, scan,
+                                                        in_tx_state,
+                                                        BE_KV_INSERT);
+                                if (ins_tx == NULL) {
+                                        m0_be_tx_add_cred(tx, t_head_reg);
+                                        m0_be_ks_tx_prep(tx);
+                                        m0_be_ks_tx_start(tx);
+                                } else {
+                                        m0_be_reg_capture(t_head_reg);
+                                        m0_be_wait(sm_group, &t_head_reg->br_sm,
+                                                   M0_BITS(M0_BEREG_CAPTURED,
+                                                           M0_BEREG_FAILED));
+                                }
+
+                                /** Now add the object to the tlist. */
+                                m0_be_tlist_add_before(ks_list_descr, scan,
+                                                       new);
+
+                                ret_val = BE_KV_SUCCESS;
+                                break;
+                        }
+                } m0_be_tlist_endfor;
+
+                /** If key is largest in the list, add at tail. */
+                if (ret_val == BE_KV_INVALID_REQ) {
+
+                        /** Capture t_head. */
+                        m0_be_ks_prep_link_reg(dom, head, tx, &t_head_reg);
+                        M0_ASSERT(t_head_reg != NULL);
+
+                        if (ins_tx == NULL) {
+                                m0_be_tx_add_cred(tx, t_head_reg);
+                        } else {
+                                m0_be_reg_capture(t_head_reg);
+                                m0_be_wait(sm_group, &t_head_reg->br_sm,
+                                           M0_BITS(M0_BEREG_CAPTURED,
+                                                   M0_BEREG_FAILED));
+                        }
+
+                        ret_val = __ks_tlist_add_at_tail(handle, new, tx,
+                                                         in_tx_state);
+                }
+        }
+
+        if (ins_tx == NULL) {
+                m0_be_tx_done(tx);
+
+                m0_be_wait(sm_group, &tx->bt_sm,
+                           M0_BITS(M0_BETX_DONE, M0_BETX_FAILED));
+                m0_be_tx_fini(tx);
+                m0_free(tx);
+        }
+
+exit_insert:
+        return ret_val;
+}
+M0_EXPORTED(m0_be_ks_insert);
+
+M0_INTERNAL int m0_be_ks_deref_handle(struct m0_be_kv_store *handle,
+                                      struct m0_be_seg      *seg)
+{
+        struct m0_be_kv_store_rvm *handle_rvm;
+        struct m0_uint128         *kv_store;
+        long int                   lo;
+        int                        ret_val;
+
+        /** Get the segid_offset representation stored at index 0. */
+        kv_store = m0_be_hs_get(0);
+
+        if (kv_store->u_hi == 0) {
+                ret_val = BE_KV_FAILURE;
+                goto exit_deref;
+        }
+
+        /** Retrieve the offset. */
+        lo = (long int)(seg->bs_addr + (kv_store->u_lo));
+
+        handle_rvm = (struct m0_be_kv_store_rvm *)lo;
+        M0_ASSERT(handle_rvm != NULL);
+
+        handle->handle_rvm = handle_rvm;
+        ret_val = BE_KV_SUCCESS;
+
+exit_deref:
+        return ret_val;
+}
+M0_EXPORTED(m0_be_ks_deref_handle);
+
+static void __ks_get_prev(struct m0_be_tl_descr   *d,
+                          void                    *current,
+                          struct m0_be_list_link **link_prev)
+{
+        struct m0_be_list_link *link;
+        int                     link_offset;
+
+        link_offset = d->td_link_offset;
+
+        link = &((struct m0_be_tlink *)(current + link_offset))->t_link;
+
+        *link_prev = link->ll_prev.n_virtual_address;
+}
+
+static void __ks_get_next(struct m0_be_tl_descr   *d,
+                          void                    *current,
+                          struct m0_be_list_link **link_next)
+{
+        struct m0_be_list_link *link;
+        int                     link_offset;
+
+        link_offset = d->td_link_offset;
+
+        link = &((struct m0_be_tlink *)(current + link_offset))->t_link;
+
+        *link_next = link->ll_next.n_virtual_address;
+}
+
+static void __ks_get_current(struct m0_be_tl_descr  *d,
+                             void                   *current,
+                             struct m0_be_list_link **link_current)
+{
+        struct m0_be_list_link *link;
+        int                     link_offset;
+
+        link_offset = d->td_link_offset;
+
+        link = &((struct m0_be_tlink *)(current + link_offset))->t_link;
+
+        *link_current = link;
+}
+static void __ks_prev_next_add_cred(struct m0_be_kv_store *handle,
+                                    struct m0_be_tx       *tx,
+                                    void                  *current,
+                                    int                    in_tx_state,
+                                    int                    operation)
+{
+        struct m0_be_reg         *prev_reg;
+        struct m0_be_reg         *next_reg;
+        struct m0_be_reg         *curr_reg;
+        struct m0_be_list_link   *link_prev;
+        struct m0_be_list_link   *link_curr;
+        struct m0_be_list_link   *link_next = NULL;
+        struct m0_be_tl_descr    *ks_list_descr;
+        struct m0_be_domain      *ks_dom;
+        struct m0_sm_group       *sm_group;
+
+        ks_list_descr = handle->handle_heap.ks_list_descr;
+        ks_dom        = handle->handle_heap.ks_dom;
+
+        sm_group      = m0_be_domain_sm_group(ks_dom);
+
+        /** Get previous and current pointers. */
+        __ks_get_prev(ks_list_descr, current, &link_prev);
+        __ks_get_current(ks_list_descr, current, &link_curr);
+
+        /** Get next pointer only if operation is BE_KV_DELETE. */
+        if (operation == BE_KV_DELETE)
+                __ks_get_next(ks_list_descr, current, &link_next);
+
+        m0_be_ks_prep_link_reg(ks_dom, link_curr, tx, &curr_reg);
+        M0_ASSERT(curr_reg != NULL);
+
+        m0_be_ks_prep_link_reg(ks_dom, link_prev, tx, &prev_reg);
+        M0_ASSERT(prev_reg != NULL);
+
+        /**
+          Capture next region only if operation is delete, for insert
+          only current and prev regions need to be captured.
+         */
+        if (operation == BE_KV_DELETE) {
+                m0_be_ks_prep_link_reg(ks_dom, link_next, tx, &next_reg);
+                M0_ASSERT(next_reg != NULL);
+        }
+
+        /** Capture the regions. */
+        if (in_tx_state == BE_KV_IN_TX_NULL) {
+                m0_be_tx_add_cred(tx, prev_reg);
+                m0_be_tx_add_cred(tx, curr_reg);
+                if (operation == BE_KV_DELETE)
+                        m0_be_tx_add_cred(tx, next_reg);
+        } else {
+                m0_be_reg_capture(prev_reg);
+                m0_be_wait(sm_group, &prev_reg->br_sm,
+                           M0_BITS(M0_BEREG_CAPTURED, M0_BEREG_FAILED));
+
+                if (operation == BE_KV_DELETE) {
+                        m0_be_reg_capture(next_reg);
+                        m0_be_wait(sm_group, &next_reg->br_sm,
+                                   M0_BITS(M0_BEREG_CAPTURED, M0_BEREG_FAILED));
+                }
+
+                m0_be_reg_capture(curr_reg);
+                m0_be_wait(sm_group, &curr_reg->br_sm,
+                           M0_BITS(M0_BEREG_CAPTURED, M0_BEREG_FAILED));
+       }
+}
+
+/* @} end of kv_store group */
+
+/*
+ * Local variables:
+ * c-indentation-style: "K&R"
+ * c-basic-offset: 8
+ * tab-width: 8
+ * fill-column: 80
+ * scroll-step: 1
+ * End:
+ */
diff --git a/be/kv_store.h b/be/kv_store.h
new file mode 100644
index 0000000..468bac3
--- /dev/null
+++ b/be/kv_store.h
@@ -0,0 +1,281 @@
+/* -*- C -*- */
+/*
+ * COPYRIGHT 2012 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: Zishan Shaikh <zishan_shaikh@xyratex.com>
+ * Original creation date: 12/06/2012
+ */
+#pragma once
+#ifndef __MERO_BE_KV_STORE_H__
+#define __MERO_BE_KV_STORE_H__
+
+#include "be/be.h"
+#include "be/tx.h"
+#include "be/be_tlist.h"
+
+/**
+   @defgroup kv_store Key Value Store
+
+   Key value store module provides functionality to store objects based on
+   "keys". A single kv-store is managed by a handle of type
+   struct m0_be_kv_store. Key value store is recoverable. For this purpose,
+   key value store internally uses m0_be_tlist to store these objects and make
+   them persistent on storage.
+
+   The kv_store handle is divided in two parts:
+        1. struct m0_be_kv_store_heap;
+             Fields that need not be made persistent. i.e. can be provided to
+             the kv_store again.
+        2. struct m0_be_kv_store_rvm;
+             Fields that have to be made persistent. i.e. fields like the
+             m0_be_tlist that stores the objects.
+
+   The kv_store is instructed to initialise either in "create" or recovery mode.
+   Depending upon the mode, the handle is either created or retrieved from RVM.
+
+   The object to be inserted should look like:
+   
+   @code:
+   struct foo {
+        ....
+        char               key[];
+        struct m0_be_tlink link;
+        uint64_t           magic;
+        ....
+   };
+
+   Usage:
+
+   Initialisation:
+       PRE: @dom should have been initialised already.
+            @cmp_routine and @match_routine must be pointing to the key compare
+            and match routines which return integer value.
+       @code:
+
+       int function_match(void *, void *);
+       int function_compare(void *, void *);
+
+       struct m0_be_kv_store *handle;
+       struct m0_be_tl_descr *list_descr;
+       struct m0_be_domain   *dom;
+       kv_key_cmp             cmp_routine;
+       kv_key_match           match_routine;
+       char                  *mode = "create" or "recover";
+
+       cmp_routine   = &function_compare;
+       match_routine = &function_match(void *, void *);
+       m0_be_ks_init(handle, list_descr, dom, cmp_routine, match_routine, mode);
+       @endcode
+
+   Insertion:
+       PRE: object to be allocated MUST be allocated memory via m0_be_alloc
+            on RVM.
+       
+       @code
+       int                     status;
+       struct foo             *object;
+       struct m0_be_reg       *region;
+       struct m0_be_reference *reference;
+       struct m0_be_tx        *tx;
+
+       object = m0_be_ks_obj_malloc(region, &reference);
+
+       strcpy(object->key, "mero-rvm");
+       status = m0_be_ks_insert(handle, reference, tx);
+       M0_ASSERT(status == BE_KV_SUCCESS);
+       @endcode
+
+   Search:
+       @code:
+       struct foo *object;
+       char       *key;
+
+       object = m0_be_ks_find(handle, key);
+       M0_ASSERT(object != NULL);
+       @endcode
+
+  Deletion:
+       PRE: Prepare and capture a region for the @object to be deleted.
+
+       @code:
+       struct foo *object;
+       char       *key;
+
+
+       object = m0_be_ks_find(handle, key);
+       status = m0_be_ks_delete(handle, object, tx);
+       @endcode
+
+   Fini:
+       @param seg: segment that was used to allocate memory to object while
+                   insertion
+       @code:
+       struct m0_be_seg *seg;
+
+       m0_be_ks_fini(dom, seg);
+       @endcode
+  @{
+ */
+
+/**
+  Function compare routines. Used in key value store while searching for key.
+ */
+typedef int     (*kv_key_cmp)(void *, void *);
+typedef int     (*kv_key_match)(void *, void *);
+
+/**
+  Structure that stores the fields of the kv_store handle that neeed to be made
+  persistent.
+ */
+struct m0_be_kv_store_rvm {
+        /* The tlist */
+        struct m0_be_tl         ks_tlist;
+};
+
+/**
+  Structure that stores fields of the kv_store that need not be persistent.
+ */
+struct m0_be_kv_store_heap {
+        /** List descriptor for the tlist. */
+        struct m0_be_tl_descr   *ks_list_descr;
+        /** Domain pointer. */
+        struct m0_be_domain     *ks_dom;
+        /** Compare function from user. */
+        kv_key_cmp               ks_key_cmp;
+        /** Match function from user. */
+        kv_key_match             ks_key_match;
+};
+
+/**
+  Structure to hold the handle to current tlist and its descriptor.
+ */
+struct m0_be_kv_store {
+        struct m0_be_kv_store_rvm  *handle_rvm;
+        struct m0_be_kv_store_heap  handle_heap;
+};
+
+/**
+  Creates the persistent part of key value store handle.
+  Called by m0_be_ks_init internally if init mode is create.
+
+  @param dom           :       pointer to the domain in which handle
+                               is to be created.
+  @param descr         :       the list descriptor to be assigned to the handle.
+  @param handle        :       the rvm_handle to be returned to the caller.
+ */
+M0_INTERNAL void m0_be_ks_create_handle(struct m0_be_domain        *dom,
+                                        struct m0_be_tl_descr      *descr,
+                                        struct m0_be_kv_store_rvm **handle);
+
+/**
+  Create/update the handle for the key_value_store.
+
+  @param handle        :       pointer to the handle.
+  @param descr         :       the tlist descriptor to be given to the tlist in
+                               kv_store.
+  @param dom           :       the domain pointer to be given to the handle.
+  @param cmp_fp        :       user defined function to compare keys.
+  @param match_fp      :       user defined function to match keys.
+  @param mode          :       decides whether kv_store is new or has to be
+                               recovered.
+                               Allowed modes: CREATE/RECOVER or create/recover.
+ */
+M0_INTERNAL void m0_be_ks_init(struct m0_be_kv_store    **handle,
+                               struct m0_be_tl_descr     *descr,
+                               struct m0_be_domain       *dom,
+                               kv_key_cmp                 cmp_fp,
+                               kv_key_match               match_fp,
+                               char                      *mode);
+
+/**
+  Insert a key value pair in the tlist contained in @handle.
+
+  @param handle                :      handle containing the tlist in which the
+                                      object will be stored.
+  @param obj_ref               :      the reference allocated to the actual
+                                      object.
+  @param tx                    :      transaction handle. Can be NULL.
+  @retval BE_KV_FAILURE        :      upon failure to insert key.
+  @retval BE_KV_SUCCESS        :      upon successful insert.
+  @retval BE_KV_DUPLICATE      :      upon trying to insert duplicate key.
+  @retval BE_KV_OUT_OF_DOMAIN  :      when there's a mismatch in the object
+                                      magic and the domain magic in handle.
+ */
+M0_INTERNAL int  m0_be_ks_insert(struct m0_be_kv_store  *handle,
+                                 struct m0_be_reference *obj_ref,
+                                 struct m0_be_tx        *tx);
+
+/**
+  Find the object with @key in the tlist contained in @handle.
+
+  @param handle        :       handle containing the tlist in which the
+                               object containing the @key is stored.
+  @param key           :       the key to be searched for in the list.
+  @return              :       object holding the @key or NULL if fails.
+ */
+M0_INTERNAL void  *m0_be_ks_find(struct m0_be_kv_store *handle,
+                                 void                  *key);
+
+/**
+  Delete the object in the tlist contained in @handle.
+
+  @param handle         :       handle containing the tlist in which the @obj is
+                                stored.
+  @param obj            :       the object to be deleted.
+  @param tx             :       transaction handle. Can be NULL.
+  @retval BE_KV_FAILURE :       in case of failures.
+  @retval BE_KV_SUCCESS :       in case of success.
+ */
+M0_INTERNAL int m0_be_ks_delete(struct m0_be_kv_store *handle,
+                                void                  *obj,
+                                struct m0_be_tx       *tx);
+
+/**
+  Finds the m0_be_reference i.e logical address of the object present next to
+  @obj in the tlist contained in @handle.
+
+  @return               :       logical address of next object.
+  @return               :       NULL on failure.
+ */
+M0_INTERNAL struct m0_be_reference
+*m0_be_ks_get_next_val(struct m0_be_kv_store *handle, void *obj);
+
+/**
+  Recovers the persistent part of the kv_store handle from rvm and puts it back
+  in the @handle.
+
+  @param handle               :       the kv_store handle.
+  @param seg                  :       segment pointer containing heap address.
+  @param kv_store             :       pointer containing segment id and offset
+                                      of the persistent kv_store handle.
+  @retval BE_KV_SUCCESS       :       upon successful retrieval.
+  @retval BE_KV_FAILURE       :       upon retrival failure.
+ */
+M0_INTERNAL int m0_be_ks_deref_handle(struct m0_be_kv_store *handle,
+                                      struct m0_be_seg      *seg);
+
+/** @} end of kv_store group */
+
+#endif /* __MERO_BE_KV_STORE_H__ */
+
+/*
+ * Local variables:
+ * c-indentation-style: "K&R"
+ * c-basic-offset: 8
+ * tab-width: 8
+ * fill-column: 80
+ * scroll-step: 1
+ * End:
+ */
diff --git a/be/lib/Makefile.sub b/be/lib/Makefile.sub
deleted file mode 100644
index c8242b0..0000000
--- a/be/lib/Makefile.sub
+++ /dev/null
@@ -1,14 +0,0 @@
-nobase_mero_include_HEADERS +=  be/lib/be_buf.h         \
-                                be/lib/be_list.h        \
-                                be/lib/be_tlist.h       \
-                                be/lib/be_types.h       \
-                                be/lib/be_kv_store.h    \
-                                be/lib/be_helper.h      \
-                                be/lib/be_handle_store.h
-
-mero_libmero_la_SOURCES     +=  be/lib/be_buf.c         \
-                                be/lib/be_list.c        \
-                                be/lib/be_tlist.c       \
-                                be/lib/be_kv_store.c    \
-                                be/lib/be_helper.c      \
-                                be/lib/be_handle_store.c
diff --git a/be/lib/be_buf.c b/be/lib/be_buf.c
deleted file mode 100644
index 2079f99..0000000
--- a/be/lib/be_buf.c
+++ /dev/null
@@ -1,51 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2012 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Zishan Shaikh <zishan_shaikh@xyratex.com>
- * Original creation date: 12/04/2012
- */
-
-#include "lib/cdefs.h"
-#include "be/lib/be_buf.h"
-
-/**
-   @addtogroup be_buf Basic buffer type
-   @{
-*/
-
-M0_INTERNAL void m0_be_buf_init(struct m0_be_buf *buf, void *data, uint32_t nob,
-                                uint64_t segment_id, uint64_t segment_offset,
-                                void *virtual_addr)
-{
-        buf->b_addr = data;
-        buf->b_nob  = nob;
-
-        buf->logical_address.segid_offset.u_hi = segment_id;
-        buf->logical_address.segid_offset.u_lo = segment_offset;
-        buf->logical_address.virtual_address   = virtual_addr;
-}
-
-/** @} end of be_buf group */
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
diff --git a/be/lib/be_buf.h b/be/lib/be_buf.h
deleted file mode 100644
index d998adf..0000000
--- a/be/lib/be_buf.h
+++ /dev/null
@@ -1,60 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2012 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Zishan Shaikh <zishan_shaikh@xyratex.com>
- * Original creation date : 12/04/2012
- */
-#pragma once
-#ifndef __MERO_BE_LIB_BE_BUF_H__
-#define __MERO_BE_LIB_BE_BUF_H__
-
-#include "be/lib/be_types.h"
-#include "lib/cdefs.h"
-
-/**
-   @defgroup be_buf Basic buffer type
-   @{
-*/
-
-/* Backend domain type buffer */
-struct m0_be_buf {
-        m0_bcount_t                      b_nob;
-        union {
-                void                    *b_addr;
-                /* holds the m0_reference for the object */
-                struct m0_reference      logical_address;
-        };
-};
-
-/* Backend domain type buffer initialization */
-M0_INTERNAL void m0_be_buf_init(struct m0_be_buf *buf, void *data, uint32_t nob,
-                                uint64_t segment_id, uint64_t segment_offset,
-                                void *virtual_addr);
-
-/** @} end of be_buf group */
-
-#endif /* __MERO_BE_LIB_BE_BUF_H__ */
-
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
diff --git a/be/lib/be_handle_store.c b/be/lib/be_handle_store.c
deleted file mode 100644
index 2dd67cb..0000000
--- a/be/lib/be_handle_store.c
+++ /dev/null
@@ -1,112 +0,0 @@
-/*
- * COPYRIGHT 2013 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Prashant Dhange <prashant_dhange@xyratex.com>
- * Original creation date: 04 Jan 2013
- */
-
-/**
-  @addtogroup be_handle_store
-  @{
-  */
-
-#include "be/be.h"
-
-/**
- * Handle store APIs
- *
- * m0_be_hs_init()           - Initialize handle store
- * m0_be_hs_update()         - Update handle store address on RVM
- * m0_be_hs_get()            - Get handle store reference (m0_uint128) from RVM
- */
-
-static struct m0_be_seg *seg = NULL;
-
-M0_INTERNAL void m0_be_hs_init(struct m0_be_seg *segin)
-{
-        M0_ASSERT(segin != NULL);
-
-        seg = segin;
-
-        m0_be_static_reg_init(seg->bs_static_addr);
-}
-
-
-M0_INTERNAL void m0_be_hs_update(uint64_t index, struct m0_uint128 *h_addr)
-{
-        struct m0_be_tx         tx;
-        struct m0_be_buf        buf;
-        struct m0_uint128      *elem;
-        uint64_t                offset;
-
-        m0_be_tx_init(&tx, seg->bs_dom, 0);
-
-        m0_sm_group_lock(tx.bt_impl.sm_group);
-        m0_sm_timedwait(&tx.bt_sm,
-                        (1 << M0_BETX_INIT) | (1 << M0_BETX_FAILED),
-                        M0_TIME_NEVER);
-        m0_sm_group_unlock(tx.bt_impl.sm_group);
-
-        m0_be_buf_init(&buf, NULL, sizeof(struct m0_uint128), 0, 0, 0);
-        offset = index * sizeof(struct m0_uint128);
-        m0_be_static_reg_capture_buf(offset, &buf, seg, &tx);
-
-        m0_sm_group_lock(tx.bt_impl.sm_group);
-        m0_sm_timedwait(&tx.bt_sm,
-                        (1 << M0_BETX_PREPARED) | (1 << M0_BETX_FAILED),
-                        M0_TIME_NEVER);
-        m0_sm_group_unlock(tx.bt_impl.sm_group);
-
-        m0_be_tx_start(&tx);
-        m0_sm_group_lock(tx.bt_impl.sm_group);
-        m0_sm_timedwait(&tx.bt_sm,
-                        (1 << M0_BETX_OPEN) | (1 << M0_BETX_FAILED),
-                        M0_TIME_NEVER);
-        m0_sm_group_unlock(tx.bt_impl.sm_group);
-
-        elem = (struct m0_uint128 *) m0_be_static_reg_get_handle_addr(offset);
-
-        elem->u_hi = h_addr->u_hi;
-        elem->u_lo = h_addr->u_lo;
-
-        m0_be_tx_done(&tx);
-
-        m0_sm_group_lock(tx.bt_impl.sm_group);
-        m0_sm_timedwait(&tx.bt_sm,
-                        (1 << M0_BETX_DONE) | (1 << M0_BETX_FAILED),
-                        M0_TIME_NEVER);
-        m0_sm_group_unlock(tx.bt_impl.sm_group);
-        m0_be_tx_fini(&tx);
-}
-
-
-M0_INTERNAL struct m0_uint128 *m0_be_hs_get(uint64_t index)
-{
-        uint64_t offset = index * sizeof(struct m0_uint128);
-
-        return (struct m0_uint128 *) m0_be_static_reg_get_handle_addr(offset);
-}
-
-/** @} end group be_ut */
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
diff --git a/be/lib/be_handle_store.h b/be/lib/be_handle_store.h
deleted file mode 100644
index e17f201..0000000
--- a/be/lib/be_handle_store.h
+++ /dev/null
@@ -1,50 +0,0 @@
-/*
- * COPYRIGHT 2013 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Prashant Dhange <prashant_dhange@xyratex.com>
- * Original creation date: 04 Jan 2013
- */
-
-#pragma once
-
-#ifndef __MERO_BE_LIB_BE_HANDLE_STORE_H__
-#define __MERO_BE_LIB_BE_HANDLE_STORE_H__
-
-/**
-  @defgroup be (Meta-data) back-end
-  @{
-  */
-#include "be/be.h"
-
-M0_INTERNAL void m0_be_hs_init(struct m0_be_seg *segin);
-
-M0_INTERNAL void m0_be_hs_update(uint64_t index, struct m0_uint128 *h_addr);
-
-M0_INTERNAL struct m0_uint128 *m0_be_hs_get(uint64_t index);
-
-/** @} end of be group */
-
-/* __MERO_BE_LIB_BE_HANDLE_STORE_H__ */
-#endif
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
diff --git a/be/lib/be_helper.c b/be/lib/be_helper.c
deleted file mode 100644
index 88ab2a3..0000000
--- a/be/lib/be_helper.c
+++ /dev/null
@@ -1,165 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2012 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author              : Zishan Shaikh <zishan_shaikh@xyratex.com>
- * Original creation date       : 12/28/2012
- */
-
-/**
-   @addtogroup be_helper
-   @{
- */
-#include "be/lib/be_helper.h"
-#include "be/lib/be_kv_store.h"
-
-M0_INTERNAL void m0_ks_init_domain(struct m0_be_domain  **out_dom)
-{
-        struct m0_be_domain  *dom = NULL;
-
-        /* Allocate memory to @dom pointer */
-        m0_be_domain_create(&dom);
-        M0_ASSERT(dom != NULL);
-
-        /* Initializing domain */
-        m0_be_domain_init(dom, BE_DOMAIN_MAGIC);
-        dom->bd_data.bs_sm.sm_state = M0_BESEG_ACTIVE;
-
-        *out_dom = dom;
-}
-M0_EXPORTED(m0_ks_init_domain);
-
-M0_INTERNAL void m0_ks_domain_lookup(struct m0_be_domain    *dom,
-                                     struct m0_be_seg      **seg,
-                                     uint64_t                segid)
-{
-        m0_be_domain_lookup(dom, segid, seg);
-        M0_ASSERT((*seg) != NULL);
-        M0_BE_WAIT((*seg)->bs_impl.sm_group, &((*seg)->bs_sm),
-                   (1 << M0_BESEG_ACTIVE) | (1 << M0_BESEG_FAILED));
-}
-M0_EXPORTED(m0_ks_domain_lookup);
-
-M0_INTERNAL int m0_ks_domain_lookup_recover(struct m0_be_domain *dom,
-                                            struct m0_be_seg   **seg,
-                                            uint64_t             segid)
-{
-        m0_be_domain_lookup_recover(dom, segid, seg);
-        M0_BE_WAIT((*seg)->bs_impl.sm_group, &((*seg)->bs_sm),
-                   (1 << M0_BESEG_ACTIVE) | (1 << M0_BESEG_FAILED));
-        M0_ASSERT((*seg) != NULL);
-
-        if ((*seg)->bs_sm.sm_state == M0_BESEG_FAILED) {
-                m0_be_seg_fini((*seg));
-                return BE_KV_FAILURE;
-        }
-
-        return BE_KV_SUCCESS;
-}
-M0_EXPORTED(m0_ks_domain_lookup_recover);
-
-M0_INTERNAL void *m0_ks_obj_malloc(struct m0_be_reg     *obj_reg,
-                                   struct m0_reference **obj_ref)
-{
-        struct m0_be_domain     *dom;
-        void                    *obj;
-
-        M0_ASSERT(obj_reg != NULL);
-
-        dom = obj_reg->br_seg->bs_dom;
-
-        m0_be_alloc(obj_reg);
-        M0_BE_WAIT(obj_reg->br_impl.sm_group, &obj_reg->br_sm,
-                   (1 << M0_BEREG_ALLOCATED) | (1 << M0_BEREG_FAILED));
-
-        m0_be_reg_capture(obj_reg);
-        M0_BE_WAIT(obj_reg->br_impl.sm_group, &obj_reg->br_sm,
-                   (1 << M0_BEREG_CAPTURED) | (1 << M0_BEREG_FAILED));
-
-        obj = obj_reg->br_buf.b_addr;
-        if (obj == NULL)
-                goto exit_failure;
-
-        (*obj_ref) = &(obj_reg->br_buf.logical_address);
-
-        return obj;
-
-exit_failure:
-        return NULL;
-}
-M0_EXPORTED(m0_ks_obj_malloc);
-
-M0_INTERNAL void m0_ks_fini(struct m0_be_domain *dom, struct m0_be_seg *seg)
-{
-        m0_be_seg_done(seg);
-        dom->bd_data.bs_sm.sm_state = M0_BESEG_CLOSED;
-        rvm_truncate();
-        m0_be_domain_fini(dom);
-}
-M0_EXPORTED(m0_ks_fini);
-
-M0_INTERNAL void m0_ks_tx_prep(struct m0_be_tx *tx)
-{
-        m0_be_tx_prep(tx);
-        M0_BE_WAIT(tx->bt_impl.sm_group, &tx->bt_sm,
-                   (1 << M0_BETX_PREPARED) | (1 << M0_BETX_FAILED));
-}
-M0_EXPORTED(m0_ks_tx_prep);
-
-M0_INTERNAL void m0_ks_tx_start(struct m0_be_tx *tx)
-{
-        m0_be_tx_start(tx);
-        M0_BE_WAIT(tx->bt_impl.sm_group, &tx->bt_sm,
-                   (1 << M0_BETX_OPEN) | (1 << M0_BETX_FAILED));
-}
-M0_EXPORTED(m0_ks_tx_prep_start);
-
-M0_INTERNAL void m0_ks_prep_link_reg(struct m0_be_domain    *dom,
-                                     struct m0_be_list_link *link,
-                                     struct m0_be_tx        *tx,
-                                     struct m0_be_reg      **reg)
-{
-        struct m0_be_buf   buf;
-        struct m0_uint128 *t_offset;
-        struct m0_be_seg  *seg;
-        uint64_t           segid;
-
-        buf.b_nob = sizeof(struct m0_be_list_link);
-
-        t_offset = &(link->ll_next.logical_address.segid_offset);
-        segid    = t_offset->u_hi;
-
-        m0_ks_domain_lookup(dom, &seg, segid);
-        M0_ASSERT(seg != NULL);
-
-        buf.b_addr = (void *)link;
-        m0_be_reg_init(reg, tx, seg, &buf);
-        M0_ASSERT((*reg) != NULL);
-}
-M0_EXPORTED(m0_ks_prep_link);
-
-
-
-/* @} end of be_helper group */
-
-/*
- * Local variables:
- * c-indentation-style: "K&R"
- * c-basic-offset: 8
- * tab-width: 8
- * fill-column: 80
- * scroll-step: 1
- * End:
- */
diff --git a/be/lib/be_helper.h b/be/lib/be_helper.h
deleted file mode 100644
index 72c743b..0000000
--- a/be/lib/be_helper.h
+++ /dev/null
@@ -1,98 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2012 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author              : Zishan Shaikh <zishan_shaikh@xyratex.com>
- * Original creation date       : 12/28/2012
- */
-#pragma once
-#ifndef __MERO_BE_LIB_BE_HELPER_H__
-#define __MERO_BE_LIB_BE_HELPER_H__
-
-#include "be/be.h"
-
-#define M0_BE_WAIT(sm_group, sm, allowed_states)                        \
-        m0_sm_group_lock(sm_group);                                     \
-        m0_sm_timedwait(sm, allowed_states, M0_TIME_NEVER);             \
-        m0_sm_group_unlock(sm_group);
-
-/**
- * @defgroup be_helper
- */
-
-/*
- * Initialise a domain and return it to the user.
- */
-M0_INTERNAL void m0_ks_init_domain(struct m0_be_domain  **out_dom);
-
-/*
- * NOTE: Finalises the domain.
- */
-M0_INTERNAL void m0_ks_fini(struct m0_be_domain *dom, struct m0_be_seg *seg);
-
-/*
- * Lookup for a segment identified by the @segid within the domain.
- */
-M0_INTERNAL void m0_ks_domain_lookup(struct m0_be_domain   *dom,
-                                     struct m0_be_seg     **seg,
-                                     uint64_t               segid);
-
-/*
- * Tries to open a segment. If failed returns BE_KV_FAILURE, else returns
- * BE_KV_SUCCESS. Used while recovery of kv store handle.
- */
-M0_INTERNAL int m0_ks_domain_lookup_recover(struct m0_be_domain *dom,
-                                            struct m0_be_seg   **seg,
-                                            uint64_t             segid);
-
-/*
- * Allocates memory to an object. Returns allocated chunk of memory.
- * Returns the reference of the allocated chunk in @obj_ref.
- * PRE: reg_init done on @obj_reg
- */
-M0_INTERNAL void *m0_ks_obj_malloc(struct m0_be_reg     *objreg,
-                                   struct m0_reference **obj_ref);
-
-/*
- * Prepares a transaction
- */
-M0_INTERNAL void m0_ks_tx_prep(struct m0_be_tx *tx);
-
-/*
- * Starts a transaction
- */
-M0_INTERNAL void m0_ks_tx_start(struct m0_be_tx *tx);
-
-/*
- * Prepares and carries out reg_init for @reg for the linkage @link
- */
-M0_INTERNAL void m0_ks_prep_link_reg(struct m0_be_domain    *dom,
-                                     struct m0_be_list_link *link,
-                                     struct m0_be_tx        *tx,
-                                     struct m0_be_reg      **reg);
-
-/** @} end of be_helper group */
-
-#endif /* __MERO_BE_LIB_BE_HELPER__H__ */
-
-/*
- * Local variables:
- * c-indentation-style: "K&R"
- * c-basic-offset: 8
- * tab-width: 8
- * fill-column: 80
- * scroll-step: 1
- * End:
- */
diff --git a/be/lib/be_kv_store.c b/be/lib/be_kv_store.c
deleted file mode 100644
index 3c6410e..0000000
--- a/be/lib/be_kv_store.c
+++ /dev/null
@@ -1,679 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2012 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Zishan Shaikh <zishan_shaikh@xyratex.com>
- * Original creation date: 12/24/2012
- */
-#include "be/lib/be_kv_store.h"
-#include "be/lib/be_handle_store.h"
-
-/**
-   @addtogroup be_kv_store
-   @{
- */
-
-/**
- * Gives the linkage of the previous object for current. The previous pointer is
- * updated in @link_prev
- */
-static void __get_prev(struct m0_be_tl_descr   *d,
-                       void                    *current,
-                       struct m0_be_list_link **link_prev);
-
-/**
- * Gives the linkage of the next object for current. The next pointer is
- * updated in @link_next
- */
-static void __get_next(struct m0_be_tl_descr   *d,
-                       void                    *current,
-                       struct m0_be_list_link **link_next);
-
-/**
- * Gives the linkage of the current object. The pointer is updated in
- * @link_current.
- */
-static void __get_current(struct m0_be_tl_descr   *d,
-                          void                    *current,
-                          struct m0_be_list_link **link_cuurent);
-
-/*
- * Adds or captures the regions of the current, next & previous pointers of
- * @current object, depending upon @in_tx_state.
- */
-static void __m0_ks_add_prev_next_to_cred(struct m0_kv_store     *handle,
-                                          struct m0_be_tx        *tx,
-                                          void                   *current,
-                                          int                     in_tx_state,
-                                          int                     operation);
-
-M0_INTERNAL void m0_ks_create_handle(struct m0_be_domain     *dom,
-                                     struct m0_be_tl_descr   *descr,
-                                     struct m0_kv_store_rvm **rvm_handle_out)
-{
-        struct m0_be_tx         *tx             = NULL;
-        struct m0_be_reg        *rvm_handle_reg = NULL;
-        struct m0_be_seg        *rvm_handle_seg = NULL;
-        struct m0_be_list       *head           = NULL;
-        struct m0_reference     *rvm_handle_ref = NULL;
-        struct m0_kv_store_rvm  *rvm_handle     = NULL;
-        struct m0_uint128       *temp_head_offset;
-        struct m0_uint128       *temp_tail_offset;
-        struct m0_be_buf         rvm_handle_buf;
-
-        M0_ALLOC_PTR(tx);
-
-        if (tx == NULL)
-                return;
-
-        /* For now segid is always == 1*/
-        m0_ks_domain_lookup(dom, &rvm_handle_seg, 1);
-        M0_ASSERT(rvm_handle_seg != NULL);
-
-        m0_be_hs_init(rvm_handle_seg);
-
-        m0_be_tx_init(tx, dom, 0);
-        M0_BE_WAIT(tx->bt_impl.sm_group, &tx->bt_sm,
-                   (1 << M0_BETX_INIT) | (1 << M0_BETX_FAILED));
-
-        /* Prepare a region for the rvm_handle */
-        rvm_handle_buf.b_nob = sizeof(struct m0_kv_store_rvm);
-        m0_be_reg_init(&rvm_handle_reg, tx, rvm_handle_seg, &rvm_handle_buf);
-
-        m0_ks_tx_start(tx);
-
-        rvm_handle = (struct m0_kv_store_rvm *)m0_ks_obj_malloc(rvm_handle_reg,
-                                                               &rvm_handle_ref);
-        M0_ASSERT(rvm_handle != NULL);
-        M0_ASSERT(rvm_handle_ref != NULL);
-
-        m0_be_hs_update(0, &rvm_handle_ref->segid_offset);
-
-        /* be_tlist init */
-        m0_be_tlist_init(descr, &rvm_handle->ks_tlist);
-
-        /* Update segment id & offset in head & tail */
-        head = &(rvm_handle->ks_tlist.t_head);
-
-        printf("handle offset = %ld\n", rvm_handle_ref->segid_offset.u_lo);
-        printf("size = %ld\n", sizeof(*rvm_handle));
-
-        temp_head_offset       = &(head->l_head.logical_address.segid_offset);
-        temp_head_offset->u_hi = rvm_handle_ref->segid_offset.u_hi;
-        temp_head_offset->u_lo = rvm_handle_ref->segid_offset.u_lo;
-
-        temp_tail_offset       = &(head->l_tail.logical_address.segid_offset);
-        temp_tail_offset->u_hi = rvm_handle_ref->segid_offset.u_hi;
-        temp_tail_offset->u_lo = rvm_handle_ref->segid_offset.u_lo;
-
-        head->l_head.logical_address.magic = dom->bd_magic;
-        head->l_tail.logical_address.magic = dom->bd_magic;
-
-        (*rvm_handle_out) = rvm_handle;
-        M0_ASSERT((*rvm_handle_out) != NULL);
-
-        m0_be_tx_done(tx);
-        M0_BE_WAIT(tx->bt_impl.sm_group, &tx->bt_sm,
-                   (1 << M0_BETX_DONE) | (1 << M0_BETX_FAILED));
-
-        m0_be_tx_fini(tx);
-        m0_free(tx);
-}
-M0_EXPORTED(m0_ks_create_handle);
-
-M0_INTERNAL void m0_ks_init(struct m0_kv_store    **out_handle,
-                            struct m0_be_tl_descr  *descr,
-                            struct m0_be_domain    *dom,
-                            kv_key_cmp              cmp_fp,
-                            kv_key_match            match_fp,
-                            char                   *mode)
-{
-        struct m0_kv_store      *handle         = NULL;
-        struct m0_kv_store_rvm  *rvm_handle     = NULL;
-        struct m0_be_seg        *rvm_handle_seg = NULL;
-        int                      handle_status;
-
-        if((*out_handle) == NULL) {
-                        M0_ALLOC_PTR(handle);
-                        M0_ASSERT(handle != NULL);
-        }
-
-        if (strcmp(mode, "RECOVER") == 0 || strcmp(mode, "recover") == 0) {
-                m0_ks_domain_lookup_recover(dom, &rvm_handle_seg, 1);
-                M0_ASSERT(rvm_handle_seg != NULL);
-        } else {
-                m0_ks_domain_lookup(dom, &rvm_handle_seg, 1);
-                M0_ASSERT(rvm_handle_seg != NULL);
-        }
-
-        m0_be_hs_init(rvm_handle_seg);
-
-        handle_status = m0_ks_deref_handle(handle, rvm_handle_seg);
-
-        if (handle_status == BE_KV_FAILURE) {
-                printf("Creating new handle...\n");
-                m0_ks_create_handle(dom, descr, &rvm_handle);
-                M0_ASSERT(rvm_handle != NULL);
-                handle->handle_rvm = rvm_handle;
-        }
-
-        /* Set the non_rvm part of the handle with user values */
-        handle->handle_heap.kv_key_cmp    = cmp_fp;
-        handle->handle_heap.kv_key_match  = match_fp;
-        handle->handle_heap.ks_list_descr = descr;
-        handle->handle_heap.ks_dom        = dom;
-
-        (*out_handle) = handle;
-}
-M0_EXPORTED(m0_ks_init);
-
-M0_INTERNAL struct m0_reference *m0_ks_get_next_val(struct m0_kv_store *handle,
-                                                    void               *obj)
-{
-        struct m0_be_list_link  *link_next      = NULL;
-        struct m0_reference     *ret_ref        = NULL;
-        void                    *temp_tail      = NULL;
-        struct m0_be_tl         *ks_tlist       = NULL;
-        struct m0_be_tl_descr   *ks_list_descr  = NULL;
-
-        ks_tlist      = &handle->handle_rvm->ks_tlist;
-        ks_list_descr = handle->handle_heap.ks_list_descr;
-
-        temp_tail = m0_be_tlist_tail(ks_list_descr, ks_tlist);
-
-        /* If object is last in linked list, then its next will be itself */
-        if (temp_tail == obj) {
-                __get_current(ks_list_descr, obj, &link_next);
-                goto get_ref;
-        }
-
-        __get_next(ks_list_descr, obj, &link_next);
-
-get_ref:
-        ret_ref  = &(link_next->ll_next.logical_address);
-        return ret_ref;
-}
-M0_EXPORTED(m0_ks_get_next_value);
-
-
-M0_INTERNAL void *m0_ks_find(struct m0_kv_store *handle,
-                             void               *key)
-{
-        void                   *scan;
-        void                   *target = NULL;
-        struct m0_be_tl         *ks_tlist  = NULL;
-        struct m0_be_tl_descr   *ks_list_descr  = NULL;
-
-        ks_tlist = &handle->handle_rvm->ks_tlist;
-        ks_list_descr = handle->handle_heap.ks_list_descr;
-
-        m0_be_tlist_for(ks_list_descr, ks_tlist, scan) {
-                if (handle->handle_heap.kv_key_match(scan, key) == 0) {
-                        target = scan;
-                        break;
-                }
-        }m0_be_tlist_endfor;
-
-        return target;
-}
-M0_EXPORTED(m0_ks_find);
-
-M0_INTERNAL int m0_ks_delete(struct m0_kv_store  *handle,
-                             void                *obj,
-                             struct m0_be_tx     *del_tx)
-{
-        void                   *scan;
-        void                   *target         = NULL;
-        struct m0_be_reg       *t_head_reg     = NULL;
-        struct m0_be_list_link *temp_link      = NULL;
-        struct m0_be_list_link *t_head_link    = NULL;
-        struct m0_be_list_link *head           = NULL;
-        struct m0_be_tx         *tx            = del_tx;
-        int                     del_tx_state   = IN_TX_NOT_NULL;
-        struct m0_be_tl         *ks_tlist      = NULL;
-        struct m0_be_tl_descr   *ks_list_descr = NULL;
-
-        ks_list_descr = handle->handle_heap.ks_list_descr;
-
-        ks_tlist = &handle->handle_rvm->ks_tlist;
-
-        head = (void *)&ks_tlist->t_head;
-
-        if (del_tx == NULL) {
-                del_tx_state = IN_TX_NULL;
-
-                M0_ALLOC_PTR(tx);
-                M0_ASSERT(tx != NULL);
-
-                m0_be_tx_init(tx, handle->handle_heap.ks_dom, 0);
-                M0_BE_WAIT(tx->bt_impl.sm_group, &tx->bt_sm,
-                           (1 << M0_BETX_INIT) | (1 << M0_BETX_FAILED));
-        }
-
-        /* Find the target node to be deleted */
-        m0_be_tlist_for(ks_list_descr, ks_tlist, scan) {
-                if (handle->handle_heap.kv_key_cmp(scan, obj) == 0)
-                        target = scan;
-        }m0_be_tlist_endfor;
-
-        if (target != NULL) {
-
-                /* Capture t_head */
-                temp_link   = head->ll_next.virtual_address;
-                t_head_link = temp_link->ll_prev.virtual_address;
-                M0_ASSERT(t_head_link != NULL);
-
-                m0_ks_prep_link_reg(handle->handle_heap.ks_dom, t_head_link, tx,
-                                    &t_head_reg);
-                M0_ASSERT(t_head_reg != NULL);
-
-                if (del_tx == NULL) {
-                        m0_be_tx_add_cred(tx, t_head_reg);
-                } else {
-                        m0_be_reg_capture(t_head_reg);
-                        M0_BE_WAIT(t_head_reg->br_impl.sm_group,
-                                   &t_head_reg->br_sm,
-                                   (1 << M0_BEREG_CAPTURED) |
-                                   (1 << M0_BEREG_FAILED));
-                }
-
-                /*
-                 * Add the current, previous and next pointers about to
-                 * be modified to the credit or captures them depending
-                 * upon the transaction received.
-                 */
-                __m0_ks_add_prev_next_to_cred(handle, tx, target, del_tx_state,
-                                              KS_DELETE);
-
-                if (del_tx == NULL) {
-                        m0_ks_tx_prep(tx);
-                        m0_ks_tx_start(tx);
-                }
-
-                /* Now delete */
-                m0_be_tlink_del_fini(ks_list_descr, target);
-
-                if (del_tx == NULL) {
-                        m0_be_tx_done(tx);
-                        M0_BE_WAIT(tx->bt_impl.sm_group, &tx->bt_sm,
-                                   (1 << M0_BETX_DONE) | (1 << M0_BETX_FAILED));
-                        m0_be_tx_fini(tx);
-                        m0_free(tx);
-                }
-                goto exit_success;
-        }
-
-        goto exit_failure;
-
-exit_success:
-        return BE_KV_SUCCESS;
-exit_failure:
-        return BE_KV_FAILURE;
-}
-M0_EXPORTED(m0_ks_delete);
-
-M0_INTERNAL int __add_at_tail_to_tlist(struct m0_kv_store     *handle,
-                                       void                   *new,
-                                       struct m0_be_tx        *tx,
-                                       int                     in_tx_state)
-{
-        struct m0_be_reg        *tail_obj_reg  = NULL;
-        struct m0_be_list_link  *tail_obj_link = NULL;
-        void                    *tail_obj      = NULL;
-        struct m0_be_tl         *ks_tlist      = NULL;
-        struct m0_be_tl_descr   *ks_list_descr = NULL;
-
-        ks_list_descr = handle->handle_heap.ks_list_descr;
-        ks_tlist      = &handle->handle_rvm->ks_tlist;
-
-        /* Add current tail to credit */
-        tail_obj  = m0_be_tlist_tail(ks_list_descr, ks_tlist);
-
-        tail_obj_link = &((struct m0_be_tlink *)
-                          (tail_obj + ks_list_descr->td_link_offset))->t_link;
-
-        /* Init a region for this link */
-        m0_ks_prep_link_reg(handle->handle_heap.ks_dom, tail_obj_link, tx,
-                            &tail_obj_reg);
-        M0_ASSERT(tail_obj_reg != NULL);
-
-        if (in_tx_state == IN_TX_NULL) {
-                m0_be_tx_add_cred(tx, tail_obj_reg);
-                m0_ks_tx_prep(tx);
-                m0_ks_tx_start(tx);
-        } else {
-                m0_be_reg_capture(tail_obj_reg);
-                M0_BE_WAIT(tail_obj_reg->br_impl.sm_group, &tail_obj_reg->br_sm,
-                           (1 << M0_BEREG_CAPTURED) | (1 << M0_BEREG_FAILED));
-        }
-
-        /* Finally, add at tail in tlist */
-        m0_be_tlist_add_tail(ks_list_descr, ks_tlist, new);
-        return BE_KV_SUCCESS;
-}
-
-M0_INTERNAL int m0_ks_insert(struct m0_kv_store  *handle,
-                             struct m0_reference *obj_ref,
-                             struct m0_be_tx     *ins_tx)
-{
-        struct m0_be_reg        *obj_link_reg  = NULL;
-        struct m0_be_reg        *t_head_reg    = NULL;
-        struct m0_be_list_link  *link          = NULL;
-        struct m0_be_tl         *ks_tlist      = NULL;
-        struct m0_be_tl_descr   *ks_list_descr = NULL;
-        struct m0_be_list_link  *head          = NULL;
-        struct m0_be_tx         *tx            = ins_tx;
-        void                    *new           = NULL;
-        void                    *scan;
-        int                      ret_val       = BE_KV_INVALID_REQ;
-        int                      in_tx_state   = IN_TX_NOT_NULL;
-
-        ks_list_descr = handle->handle_heap.ks_list_descr;
-
-        ks_tlist = &handle->handle_rvm->ks_tlist;
-
-        /* Ensure object is allocated on same domain as that of handle */
-        if (obj_ref->magic != handle->handle_heap.ks_dom->bd_magic)
-                goto exit_failure;
-
-        /* Collect the object to be inserted */
-        new = obj_ref->virtual_address;
-
-        /* Check for duplicate insertion */
-        m0_be_tlist_for(ks_list_descr, ks_tlist, scan) {
-                if (handle->handle_heap.kv_key_cmp(new, scan) == 0) {
-                        goto exit_failure;
-                }
-        }m0_be_tlist_endfor;
-
-        if (ins_tx == NULL) {
-                in_tx_state = IN_TX_NULL;
-                M0_ALLOC_PTR(tx);
-                M0_ASSERT(tx != NULL);
-
-                m0_be_tx_init(tx, handle->handle_heap.ks_dom, 0);
-
-                M0_BE_WAIT(tx->bt_impl.sm_group, &tx->bt_sm,
-                           (1 << M0_BETX_INIT) | (1 << M0_BETX_FAILED));
-        }
-
-        /* Tlink init for this object */
-        m0_be_tlink_init(ks_list_descr, obj_ref);
-
-        link = &((struct m0_be_tlink *)
-                 (new + ks_list_descr->td_link_offset))->t_link;
-        M0_ASSERT(link != NULL);
-
-        /* Init a region for this link */
-        m0_ks_prep_link_reg(handle->handle_heap.ks_dom, link, tx,
-                            &obj_link_reg);
-        M0_ASSERT(obj_link_reg != NULL);
-
-        /* Capture this region */
-        if (ins_tx == NULL)
-                m0_be_tx_add_cred(tx, obj_link_reg);
-        else {
-                m0_be_reg_capture(obj_link_reg);
-                M0_BE_WAIT(obj_link_reg->br_impl.sm_group, &obj_link_reg->br_sm,
-                           (1 << M0_BEREG_CAPTURED) | (1 << M0_BEREG_FAILED));
-        }
-
-        head = (void *)&ks_tlist->t_head;
-
-        if ((head->ll_next.virtual_address == (void *)head) &&
-            (head->ll_prev.virtual_address == (void *)head)) {
-
-                /* Capture t_head */
-                m0_ks_prep_link_reg(handle->handle_heap.ks_dom, head, tx,
-                                    &t_head_reg);
-                M0_ASSERT(t_head_reg != NULL);
-
-                /* Capture this region */
-                if (ins_tx == NULL) {
-                        /*m0_be_tx_add_cred(tx, head_reg);*/
-                        m0_be_tx_add_cred(tx, t_head_reg);
-                        m0_ks_tx_prep(tx);
-                        m0_ks_tx_start(tx);
-                } else {
-                        m0_be_reg_capture(t_head_reg);
-                        M0_BE_WAIT(t_head_reg->br_impl.sm_group,
-                                   &t_head_reg->br_sm,
-                                   (1 << M0_BEREG_CAPTURED) |
-                                   (1 << M0_BEREG_FAILED));
-                }
-
-                /* Add to tlist now */
-                m0_be_tlist_add(ks_list_descr, ks_tlist, new);
-                ret_val = BE_KV_SUCCESS;
-
-        } else {
-                /* Else, find the appropriate position for the obj and insert */
-                m0_be_tlist_for(ks_list_descr, ks_tlist, scan)
-                {
-                        if (handle->handle_heap.kv_key_cmp(new, scan) < 0) {
-
-                                /* Capture t_head */
-                                m0_ks_prep_link_reg(handle->handle_heap.ks_dom,
-                                                    head, tx,
-                                                    &t_head_reg);
-                                M0_ASSERT(t_head_reg != NULL);
-
-                                /*
-                                 * Add the current, previous and next pointers
-                                 * about to be modified to the credit.
-                                 */
-                                __m0_ks_add_prev_next_to_cred(handle, tx, scan,
-                                                              in_tx_state,
-                                                              KS_INSERT);
-                                if (ins_tx == NULL) {
-                                        m0_be_tx_add_cred(tx, t_head_reg);
-                                        m0_ks_tx_prep(tx);
-                                        m0_ks_tx_start(tx);
-                                } else {
-                                        m0_be_reg_capture(t_head_reg);
-                                        M0_BE_WAIT(t_head_reg->br_impl.sm_group,
-                                                   &t_head_reg->br_sm,
-                                                   (1 << M0_BEREG_CAPTURED) |
-                                                   (1 << M0_BEREG_FAILED));
-                                }
-
-                                /*
-                                 * Now add the object to the tlist
-                                 */
-                                m0_be_tlist_add_before(ks_list_descr, scan,
-                                                       new);
-
-                                ret_val = BE_KV_SUCCESS;
-                                break;
-                        }
-                }m0_be_tlist_endfor;
-
-                /* If key is largest in the list, add at tail */
-                if (ret_val == BE_KV_INVALID_REQ) {
-
-                        /* Capture t_head */
-                        m0_ks_prep_link_reg(handle->handle_heap.ks_dom,
-                                            head, tx, &t_head_reg);
-                        M0_ASSERT(t_head_reg != NULL);
-
-                        if (ins_tx == NULL) {
-                                m0_be_tx_add_cred(tx, t_head_reg);
-                        } else {
-                                m0_be_reg_capture(t_head_reg);
-                                M0_BE_WAIT(t_head_reg->br_impl.sm_group,
-                                           &t_head_reg->br_sm,
-                                           (1 << M0_BEREG_CAPTURED) |
-                                           (1 << M0_BEREG_FAILED));
-                        }
-
-                        ret_val = __add_at_tail_to_tlist(handle, new, tx,
-                                                         in_tx_state);
-                }
-        }
-
-        if (ins_tx == NULL) {
-                m0_be_tx_done(tx);
-
-                M0_BE_WAIT(tx->bt_impl.sm_group, &tx->bt_sm,
-                           (1 << M0_BETX_DONE) | (1 << M0_BETX_FAILED));
-                m0_be_tx_fini(tx);
-                m0_free(tx);
-        }
-
-        return ret_val;
-
-exit_failure:
-        return BE_KV_FAILURE;
-}
-M0_EXPORTED(m0_ks_insert);
-
-static void __get_prev(struct m0_be_tl_descr   *d,
-                       void                    *current,
-                       struct m0_be_list_link **link_prev)
-{
-        int                     link_offset;
-        struct m0_be_list_link *link;
-
-        link_offset = d->td_link_offset;
-
-        link = &((struct m0_be_tlink *)(current + link_offset))->t_link;
-
-        *link_prev = link->ll_prev.virtual_address;
-}
-
-static void __get_next(struct m0_be_tl_descr   *d,
-                       void                    *current,
-                       struct m0_be_list_link **link_next)
-{
-        int                     link_offset;
-        struct m0_be_list_link *link;
-
-        link_offset = d->td_link_offset;
-
-        link = &((struct m0_be_tlink *)(current + link_offset))->t_link;
-
-        *link_next = link->ll_next.virtual_address;
-}
-
-static void __get_current(struct m0_be_tl_descr  *d,
-                          void                   *current,
-                          struct m0_be_list_link **link_current)
-{
-        int                     link_offset;
-        struct m0_be_list_link *link;
-        struct m0_be_list_link *temp;
-
-        link_offset = d->td_link_offset;
-
-        link = &((struct m0_be_tlink *)(current + link_offset))->t_link;
-
-        temp = link->ll_prev.virtual_address;
-        *link_current = temp->ll_next.virtual_address;
-}
-static void __m0_ks_add_prev_next_to_cred(struct m0_kv_store *handle,
-                                          struct m0_be_tx    *tx,
-                                          void               *current,
-                                          int                 in_tx_state,
-                                          int                 operation)
-{
-        struct m0_be_reg         *prev_reg      = NULL;
-        struct m0_be_reg         *next_reg      = NULL;
-        struct m0_be_reg         *curr_reg      = NULL;
-        struct m0_be_list_link   *link_prev     = NULL;
-        struct m0_be_list_link   *link_curr     = NULL;
-        struct m0_be_list_link   *link_next     = NULL;
-        struct m0_be_tl_descr    *ks_list_descr = NULL;
-
-        ks_list_descr = handle->handle_heap.ks_list_descr;
-
-        __get_prev(ks_list_descr, current, &link_prev);
-        __get_current(ks_list_descr, current, &link_curr);
-
-        if (operation == KS_DELETE)
-                __get_next(ks_list_descr, current, &link_next);
-
-        m0_ks_prep_link_reg(handle->handle_heap.ks_dom, link_curr, tx,
-                            &curr_reg);
-        M0_ASSERT(curr_reg != NULL);
-
-        m0_ks_prep_link_reg(handle->handle_heap.ks_dom, link_prev, tx,
-                            &prev_reg);
-        M0_ASSERT(prev_reg != NULL);
-
-        if (link_next != NULL) {
-                m0_ks_prep_link_reg(handle->handle_heap.ks_dom, link_next, tx,
-                                    &next_reg);
-                M0_ASSERT(next_reg != NULL);
-        }
-
-
-        if (in_tx_state == IN_TX_NULL) {
-                m0_be_tx_add_cred(tx, prev_reg);
-                m0_be_tx_add_cred(tx, curr_reg);
-                if (operation == KS_DELETE)
-                        m0_be_tx_add_cred(tx, next_reg);
-        } else {
-                m0_be_reg_capture(prev_reg);
-                M0_BE_WAIT(prev_reg->br_impl.sm_group, &prev_reg->br_sm,
-                           (1 << M0_BEREG_CAPTURED) | (1 << M0_BEREG_FAILED));
-
-                if (operation == KS_DELETE) {
-                        m0_be_reg_capture(next_reg);
-                        M0_BE_WAIT(next_reg->br_impl.sm_group, &next_reg->br_sm,
-                                   (1 << M0_BEREG_CAPTURED) |
-                                   (1 << M0_BEREG_FAILED));
-                }
-
-                m0_be_reg_capture(curr_reg);
-                M0_BE_WAIT(curr_reg->br_impl.sm_group, &curr_reg->br_sm,
-                           (1 << M0_BEREG_CAPTURED) | (1 << M0_BEREG_FAILED));
-       }
-}
-
-M0_INTERNAL int m0_ks_deref_handle(struct m0_kv_store *handle,
-                                   struct m0_be_seg   *seg)
-{
-        struct m0_kv_store_rvm *handle_rvm  = NULL;
-        struct m0_uint128      *kv_store    = NULL;
-        long int                lo;
-
-        kv_store = m0_be_hs_get(0);
-
-        if (kv_store->u_hi == 0)
-                return BE_KV_FAILURE;
-
-        lo = (long int)(seg->bs_heap_addr + (kv_store->u_lo));
-
-        handle_rvm = (struct m0_kv_store_rvm *)lo;
-        M0_ASSERT(handle_rvm != NULL);
-
-        handle->handle_rvm = handle_rvm;
-        return BE_KV_SUCCESS;
-}
-M0_EXPORTED(m0_ks_deref_handle);
-
-
-
-/* @} end of be_kv_store group */
-
-/*
- * Local variables:
- * c-indentation-style: "K&R"
- * c-basic-offset: 8
- * tab-width: 8
- * fill-column: 80
- * scroll-step: 1
- * End:
- */
diff --git a/be/lib/be_kv_store.h b/be/lib/be_kv_store.h
deleted file mode 100644
index d2571a1..0000000
--- a/be/lib/be_kv_store.h
+++ /dev/null
@@ -1,185 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2012 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Zishan Shaikh <zishan_shaikh@xyratex.com>
- * Original creation date: 12/06/2012
- */
-#pragma once
-#ifndef __MERO_BE_LIB_BE_KV_STORE_H__
-#define __MERO_BE_LIB_BE_KV_STORE_H__
-
-#include "be/lib/be_tlist.h"
-#include "be/lib/be_buf.h"
-#include "be/lib/be_types.h"
-#include "be/lib/be_helper.h"
-#include "be/be.h"
-
-enum {
-        BE_KV_SUCCESS,
-        BE_KV_FAILURE,
-        BE_KV_INVALID_REQ,
-        IN_TX_NULL,
-        IN_TX_NOT_NULL,
-        CREATE,
-        RECOVER,
-        KS_INSERT,
-        KS_DELETE
-};
-/**
-   @defgroup be_kv_store Key Value Store
- */
-
-/* Function compare routines. Used in key value store while searching for key */
-typedef int     (*kv_key_cmp)(void *, void *);
-typedef int     (*kv_key_match)(void *, void *);
-
-/**
- * Structure that stores the fields of the kv_store handle that neeed to be made
- * persistent.
- */
-struct m0_kv_store_rvm {
-        /* The tlist */
-        struct m0_be_tl         ks_tlist;
-};
-
-/**
- * Structure that stores fields of the kv_store that need not be persistent.
- */
-struct m0_kv_store_heap {
-        /* List descriptor for the tlist */
-        struct m0_be_tl_descr   *ks_list_descr;
-        /* Domain pointer */
-        struct m0_be_domain     *ks_dom;
-        /* Compare function from user */
-        kv_key_cmp               kv_key_cmp;
-        /* Match function from user */
-        kv_key_match             kv_key_match;
-};
-
-
-/**
- * Structure to hold the handle to current tlist and its descriptor
- */
-struct m0_kv_store {
-        struct m0_kv_store_rvm  *handle_rvm;
-        struct m0_kv_store_heap  handle_heap;
-};
-
-/*
- * Creates the persistent part of key value store handle.
- * Called by m0_ks_init internally.
- * Returns NULL on failure.
- *
- * @param dom           :       pointer to the domain in which handle
- *                              is to be created
- * @param descr         :       the list descriptor to be assigned to the handle
- * @param rvm_handle_out:       the rvm_handle to be returned to the caller.
- */
-M0_INTERNAL void m0_ks_create_handle(struct m0_be_domain     *dom,
-                                     struct m0_be_tl_descr   *descr,
-                                     struct m0_kv_store_rvm **handle);
-
-
-/*
- * Create/update the handle for the key_value_store
- *
- * @param handle        :       pointer to the handle
- * @param descr         :       the tlist descriptor to be given to the tlist in
- *                              kv_store
- * @param dom           :       the domain pointer to be given to the handle
- * @param cmp_fp        :       user defined function to compare keys
- * @param match_fp      :       user defined function to match keys
- * @param mode          :       decides whether kv_store is new or has to be
- *                              recovered.
- */
-M0_INTERNAL void m0_ks_init(struct m0_kv_store    **handle,
-                            struct m0_be_tl_descr  *descr,
-                            struct m0_be_domain    *dom,
-                            kv_key_cmp              cmp_fp,
-                            kv_key_match            match_fp,
-                            char                   *mode);
-
-/*
- * Insert a key value pair in the tlist contained in @handle.
- * Returns BE_KV_FAILURE or BE_KV_SUCCESS
- *
- * @param handle        :       handle containing the tlist in which the
- *                              object will be stored
- * @param obj_ref       :       the reference allocated to the actual object
- * @param tx            :       transaction handle. Can be NULL.
- */
-M0_INTERNAL int  m0_ks_insert(struct m0_kv_store  *handle,
-                              struct m0_reference *obj_ref,
-                              struct m0_be_tx     *tx);
-
-/*
- * Find object with @key in the tlist contained in @handle.
- * Returns the object containing the @key
- *
- * @param handle        :       handle containing the tlist in which the
- *                              object containing the @key is stored.
- * @param key           :       the key to be searched for in the list
- */
-M0_INTERNAL void  *m0_ks_find(struct m0_kv_store *handle,
-                              void               *key);
-
-/*
- * Delete the object in the tlist contained in @handle.
- * Returns BE_KV_FAILURE in case of failures.
- *
- * @param handle        :       handle containing the tlist in which the @obj is
- *                              stored
- * @param obj           :       the object to be deleted
- * @param tx            :       transaction handle. Can be NULL.
- */
-M0_INTERNAL int m0_ks_delete(struct m0_kv_store *handle,
-                             void               *obj,
-                             struct m0_be_tx    *tx);
-
-/*
- * Returns the m0_reference i.e logical address of the object present next to
- * @obj in the tlist contained in @handle
- * Returns NULL on failure
- */
-M0_INTERNAL struct m0_reference *m0_ks_get_next_val(struct m0_kv_store *handle,
-                                                    void               *obj);
-
-/*
- * Recovres the persistent part of the kv_store handle from rvm and puts it back
- * in the @handle.
- *
- * @param handle        :       the kv_store handle
- * @param seg           :       segment pointer containing heap address
- * @param kv_store      :       pointer containing segment id and offset of the
- *                              persistent kv_store handle
- */
-M0_INTERNAL int m0_ks_deref_handle(struct m0_kv_store *handle,
-                                   struct m0_be_seg   *seg);
-
-
-/** @} end of be_kv_store group */
-
-#endif /* __MERO_BE_LIB_BE_KV_STORE_H__ */
-
-/*
- * Local variables:
- * c-indentation-style: "K&R"
- * c-basic-offset: 8
- * tab-width: 8
- * fill-column: 80
- * scroll-step: 1
- * End:
- */
diff --git a/be/lib/be_list.c b/be/lib/be_list.c
deleted file mode 100644
index c4b0a9a..0000000
--- a/be/lib/be_list.c
+++ /dev/null
@@ -1,275 +0,0 @@
-/*
- * COPYRIGHT 2012 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Zishan Shaikh <zishan_shaikh@xyratex.com>
- * Original creation date : 12/04/2012
- */
-#include "lib/assert.h"
-#include "be/lib/be_list.h"
-
-/** @addtogroup be_list
- * @{
- */
-
-M0_INTERNAL void m0_be_list_init(struct m0_be_list *head)
-{
-        head->l_head.virtual_address = (struct m0_be_list_link *)head;
-        head->l_tail.virtual_address = (struct m0_be_list_link *)head;
-}
-M0_EXPORTED(m0_be_list_init);
-
-M0_INTERNAL void m0_be_list_fini(struct m0_be_list *head)
-{
-        M0_ASSERT(m0_be_list_is_empty(head));
-}
-M0_EXPORTED(m0_be_list_fini);
-
-M0_INTERNAL bool m0_be_list_is_empty(const struct m0_be_list *head)
-{
-        return head->l_head.virtual_address == (void *)head;
-}
-M0_EXPORTED(m0_be_list_is_empty);
-
-M0_INTERNAL bool m0_be_list_link_invariant(const struct m0_be_list_link *link)
-{
-        struct m0_be_list_link *scan;
-        struct m0_be_list_link *next_temp;
-        struct m0_be_list_link *prev_temp;
-
-        if ((link->ll_next.virtual_address == link) !=
-            (link->ll_prev.virtual_address == link))
-                return false;
-
-        for (scan = link->ll_next.virtual_address;
-             scan != link;
-             scan = scan->ll_next.virtual_address) {
-                next_temp = scan->ll_next.virtual_address;
-                prev_temp = scan->ll_prev.virtual_address;
-
-                if (next_temp->ll_prev.virtual_address != scan ||
-                    prev_temp->ll_next.virtual_address != scan)
-                        return false;
-        }
-        return true;
-}
-
-M0_INTERNAL bool m0_be_list_invariant(const struct m0_be_list *head)
-{
-        return m0_be_list_link_invariant((void *)head);
-}
-
-M0_INTERNAL size_t m0_be_list_length(const struct m0_be_list *list)
-{
-        struct m0_be_list_link *scan;
-        size_t                 length;
-
-        M0_ASSERT(m0_be_list_invariant(list));
-        length = 0;
-
-        for (scan = list->l_head.virtual_address;
-             scan != (void *)list;
-             scan = scan->ll_next.virtual_address)
-                length++;
-
-        return length;
-}
-
-M0_INTERNAL bool m0_be_list_contains(const struct m0_be_list *list,
-                                     const struct m0_be_list_link *link)
-{
-        struct m0_be_list_link *scan;
-
-        M0_ASSERT(m0_be_list_invariant(list));
-
-        for (scan = list->l_head.virtual_address;
-             scan != (void *)list;
-             scan = scan->ll_next.virtual_address)
-                if (scan == link)
-                        return true;
-        return false;
-}
-
-static inline void __m0_be_list_add(struct m0_be_list_link *next,
-                                    struct m0_be_list_link *prev,
-                                    struct m0_be_list_link *new)
-{
-        uint64_t prev_magic;
-        uint64_t next_magic;
-        uint64_t new_magic;
-
-        M0_ASSERT(prev->ll_next.virtual_address == (void *)next &&
-                  next->ll_prev.virtual_address == (void *)prev);
-        M0_ASSERT(m0_be_list_link_invariant(next));
-
-        /* Make sure all belong in same domain */
-        prev_magic = prev->ll_next.logical_address.magic;
-        next_magic = next->ll_next.logical_address.magic;
-        new_magic  = new->ll_next.logical_address.magic;
-
-        M0_ASSERT(new_magic == prev_magic);
-        M0_ASSERT(new_magic == next_magic);
-
-        prev_magic = prev->ll_prev.logical_address.magic;
-        next_magic = next->ll_prev.logical_address.magic;
-        new_magic  = new->ll_prev.logical_address.magic;
-
-        M0_ASSERT(new_magic == prev_magic);
-        M0_ASSERT(new_magic == next_magic);
-
-        /* Now add to the tlist finally */
-        new->ll_next.virtual_address  = next;
-        new->ll_prev.virtual_address  = prev;
-
-        next->ll_prev.virtual_address = new;
-        prev->ll_next.virtual_address = new;
-
-        M0_ASSERT(m0_be_list_link_invariant(next));
-}
-
-M0_INTERNAL void m0_be_list_add(struct m0_be_list *head,
-                                struct m0_be_list_link *new)
-{
-        __m0_be_list_add(head->l_head.virtual_address, (void *)head, new);
-}
-M0_EXPORTED(m0_be_list_add);
-
-M0_INTERNAL void m0_be_list_add_tail(struct m0_be_list *head,
-                                     struct m0_be_list_link *new)
-{
-        __m0_be_list_add((void *)head, head->l_tail.virtual_address, new);
-}
-M0_EXPORTED(m0_be_list_add_tail);
-
-M0_INTERNAL void m0_be_list_add_after(struct m0_be_list_link *anchor,
-                                      struct m0_be_list_link *new)
-{
-        __m0_be_list_add(anchor->ll_next.virtual_address, anchor, new);
-}
-M0_EXPORTED(m0_be_list_add_after);
-
-M0_INTERNAL void m0_be_list_add_before(struct m0_be_list_link *anchor,
-                                       struct m0_be_list_link *new)
-{
-        __m0_be_list_add(anchor, anchor->ll_prev.virtual_address, new);
-}
-M0_EXPORTED(m0_be_list_add_before);
-
-static void __m0_be_list_del(struct m0_be_list_link *old)
-{
-        M0_ASSERT(m0_be_list_link_invariant(old));
-        struct m0_be_list_link *prev_temp;
-        struct m0_be_list_link *next_temp;
-        uint64_t                prev_magic;
-        uint64_t                next_magic;
-
-        prev_temp = old->ll_prev.virtual_address;
-        next_temp = old->ll_next.virtual_address;
-
-        /* Magic check to confirm prev and next are from same domain */
-        prev_magic = prev_temp->ll_prev.logical_address.magic;
-        next_magic = next_temp->ll_prev.logical_address.magic;
-        M0_ASSERT(prev_magic == next_magic);
-
-        prev_magic = prev_temp->ll_next.logical_address.magic;
-        next_magic = next_temp->ll_next.logical_address.magic;
-        M0_ASSERT(prev_magic == next_magic);
-
-        /* Now delete */
-        prev_temp->ll_next.virtual_address = next_temp;
-        next_temp->ll_prev.virtual_address = prev_temp;
-}
-
-M0_INTERNAL void m0_be_list_del(struct m0_be_list_link *old)
-{
-        __m0_be_list_del(old);
-        m0_be_list_link_init(old, NULL);
-}
-M0_EXPORTED(m0_be_list_del);
-
-M0_INTERNAL void m0_be_list_move(struct m0_be_list      *head,
-                                 struct m0_be_list_link *old)
-{
-        __m0_be_list_del(old);
-        m0_be_list_add(head, old);
-        M0_ASSERT(m0_be_list_invariant(head));
-}
-
-M0_INTERNAL void m0_be_list_move_tail(struct m0_be_list      *head,
-                                      struct m0_be_list_link *old)
-{
-        __m0_be_list_del(old);
-        m0_be_list_add_tail(head, old);
-        M0_ASSERT(m0_be_list_invariant(head));
-}
-
-M0_INTERNAL void m0_be_list_link_init(struct m0_be_list_link *link,
-                                      struct m0_reference    *ref)
-{
-        struct m0_uint128      *next_temp;
-        struct m0_uint128      *prev_temp;
-        uint64_t                seg_id;
-        uint64_t                offset;
-
-        link->ll_prev.virtual_address = (void *)link;
-        link->ll_next.virtual_address = (void *)link;
-
-        if (ref != NULL) {
-                seg_id    = ref->segid_offset.u_hi;
-                offset    = ref->segid_offset.u_lo;
-
-                next_temp = &(link->ll_next.logical_address.segid_offset);
-                prev_temp = &(link->ll_prev.logical_address.segid_offset);
-
-                next_temp->u_hi = seg_id;
-                next_temp->u_lo = offset;
-
-                prev_temp->u_hi = seg_id;
-                prev_temp->u_lo = offset;
-
-                /* update magic in logical address with the one in reference */
-                link->ll_prev.logical_address.magic = ref->magic;
-                link->ll_next.logical_address.magic = ref->magic;
-        }
-}
-M0_EXPORTED(m0_be_list_link_init);
-
-
-M0_INTERNAL void m0_be_list_link_fini(struct m0_be_list_link *link)
-{
-        M0_ASSERT(!m0_be_list_link_is_in(link));
-}
-
-M0_INTERNAL bool m0_be_list_link_is_in(const struct m0_be_list_link *link)
-{
-        return link->ll_prev.virtual_address != (void *)link;
-}
-
-M0_INTERNAL bool m0_be_list_link_is_last(const struct m0_be_list_link *link,
-                                         const struct m0_be_list      *head)
-{
-        return link->ll_next.virtual_address == (void *)head;
-}
-
-/** @} end of be_list group */
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
diff --git a/be/lib/be_list.h b/be/lib/be_list.h
deleted file mode 100644
index d58c92a..0000000
--- a/be/lib/be_list.h
+++ /dev/null
@@ -1,281 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2012 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Zishan Shaikh <zishan_shaikh@xyratex.com>
- * Original creation date: 11/28/2012
- */
-#pragma once
-
-#ifndef __MERO_BE_LIB_BE_LIST_H__
-#define __MERO_BE_LIB_BE_LIST_H__
-
-#include "be/lib/be_types.h"
-#include "lib/cdefs.h"
-#include "lib/assert.h"
-
-/**
- * @defgroup be_list Double-linked list.
- * @{
- */
-
-struct m0_be_list_link;
-
-/**
- * Structure to support the linkage in tlist and store the logical address
- * details of the object
- */
-struct m0_reference_ll {
-        union {
-                struct m0_be_list_link  *virtual_address;
-                struct m0_reference      logical_address;
-        };
-};
-
-/**
- * List entry.
- * Modified to support traversal in tlist via references
- */
-struct m0_be_list_link {
-        /* Next entry in the list */
-        struct m0_reference_ll ll_next;
-        /* Previous entry in the list */
-        struct m0_reference_ll ll_prev;
-};
-
-/**
- * initialize list link entry for be domain
- *
- * @param link - pointer to link entry
- * @param ref  - pointer to struct m0_reference in m0_buf
- */
-M0_INTERNAL void m0_be_list_link_init(struct m0_be_list_link *link,
-                                      struct m0_reference    *ref);
-
-/**
- * free resources associated with link entry
- *
- * @param link - pointer to link enty
- */
-M0_INTERNAL void m0_be_list_link_fini(struct m0_be_list_link *link);
-
-M0_INTERNAL bool m0_be_list_link_invariant(const struct m0_be_list_link *link);
-
-/**
- * List head.
- */
-struct m0_be_list {
-        /*
-         * Pointer to the first entry in the list.
-         */
-        struct m0_reference_ll l_head;
-        /*
-         * Pointer to the last entry in the list.
-         */
-        struct m0_reference_ll l_tail;
-};
-
-/*
- * It is necessary that m0_be_list and m0_be_list_link structures have exactly
- * the same layout.
- */
-
-M0_BASSERT(offsetof(struct m0_be_list, l_head) ==
-           offsetof(struct m0_be_list_link, ll_next));
-M0_BASSERT(offsetof(struct m0_be_list, l_tail) ==
-           offsetof(struct m0_be_list_link, ll_prev));
-
-
-/**
- * Initializes list head.
- */
-M0_INTERNAL void m0_be_list_init(struct m0_be_list *head);
-
-/**
- * Finalizes the list.
- */
-M0_INTERNAL void m0_be_list_fini(struct m0_be_list *head);
-
-/**
- * check list is empty
- *
- * @param head pointer to list head
- */
-M0_INTERNAL bool m0_be_list_is_empty(const struct m0_be_list *head);
-
-/**
- * Returns true iff @link is in @list.
- */
-M0_INTERNAL bool m0_be_list_contains(const struct m0_be_list      *list,
-                                     const struct m0_be_list_link *link);
-
-/**
- * This function iterates over the argument list checking that double-linked
- * list invariant holds (x->ll_prev->ll_next == x && x->ll_next->ll_prev == x).
- *
- * @return true if @list isn't corrupted
- */
-M0_INTERNAL bool m0_be_list_invariant(const struct m0_be_list *list);
-
-M0_INTERNAL size_t m0_be_list_length(const struct m0_be_list *list);
-
-/**
- * add list to top on the list
- *
- * This function can be called on an uninitialised @new link. All @new fields
- * are overwritten.
-
- * @param head pointer to list head
- * @param new  pointer to list entry
- */
-M0_INTERNAL void m0_be_list_add(struct m0_be_list       *head,
-                                struct m0_be_list_link  *new);
-
-/**
- * add list to tail on the list
- *
- * This function can be called on an uninitialised @new link. All @new fields
- * are overwritten.
- *
- * @param head pointer to list head
- * @param new  pointer to list entry
- */
-M0_INTERNAL void m0_be_list_add_tail(struct m0_be_list      *head,
-                                     struct m0_be_list_link *new);
-
-/**
- * Adds an element to the list right after the specified element.
- *
- * This function can be called on an uninitialised @new link. All @new fields
- * are overwritten.
- */
-M0_INTERNAL void m0_be_list_add_after (struct m0_be_list_link *anchor,
-                                       struct m0_be_list_link *new);
-
-/**
- * Adds an element to the list right before the specified element.
- *
- * This function can be called on an uninitialised @new link. All @new fields
- * are overwritten.
- */
-M0_INTERNAL void m0_be_list_add_before(struct m0_be_list_link *anchor,
-                                       struct m0_be_list_link *new);
-
-/**
- * Deletes an entry from the list and re-initializes the entry.
- */
-M0_INTERNAL void m0_be_list_del(struct m0_be_list_link *old);
-
-/**
- * Moves an entry to head of the list.
- */
-M0_INTERNAL void m0_be_list_move(struct m0_be_list      *head,
-                                 struct m0_be_list_link *new);
-
-/**
- * Moves an entry to tail of the list.
- */
-M0_INTERNAL void m0_be_list_move_tail(struct m0_be_list      *head,
-                                      struct m0_be_list_link *new);
-
-/**
- * return first entry from the list
- *
- * @param head pointer to list head
- *
- * @return pointer to first list entry or NULL if list empty
- */
-static inline struct m0_be_list_link
-*m0_be_list_first(const struct m0_be_list *head)
-{
-        return head->l_head.virtual_address !=
-               (void *)head ? head->l_head.virtual_address : NULL;
-}
-
-
-/**
- * is link entry connected to the list
- *
- * @param link - pointer to link entry
- * @retval true - entry connected to a list
- * @retval false - entry disconnected from a list
-*/
-M0_INTERNAL bool m0_be_list_link_is_in(const struct m0_be_list_link *link);
-
-M0_INTERNAL bool m0_be_list_link_is_last(const struct m0_be_list_link *link,
-                                         const struct m0_be_list      *head);
-
-M0_INTERNAL size_t m0_be_list_length(const struct m0_be_list *list);
-
-/**
- * get pointer to object from pointer to list link entry
- */
-#define m0_be_list_entry(link, type, member) \
-        container_of(link, type, member)
-
-/**
- * Iterates over a list
- *
- * @param head : the head of list.
- * @param pos  : the pointer to list_link to use as a loop counter.
- */
-#define m0_be_list_for_each(head, pos) \
-        for (pos = (head)->l_head.virtual_address; pos != (void *)(head); \
-             pos = (pos)->ll_next.virtual_address)
-
-/**
- * Read-only iterates over a "typed" list.
- *
- * The loop body is not allowed to modify the list.
- */
-#define m0_be_list_for_each_entry(head, pos, type, member) \
-        for (pos = m0_be_list_entry((head)->l_head.virtual_address, type, \
-                                    member);\
-             &(pos->member) != (void *)head; \
-             pos = m0_be_list_entry((pos)->member.ll_next.virtual_address,     \
-                                    type, member))
-
-/**
-   Iterates over a "typed" list safely: the loop body is allowed to remove the
-   current element.
-
-   @param head : the head of list.
-   @param pos  : the pointer to list_link to use as a loop counter.
- */
-#define m0_be_list_for_each_entry_safe(head, pos, next, type, member)   \
-        for (pos = m0_be_list_entry((head)->l_head.virtual_address, type, \
-                                    member),\
-             next = m0_be_list_entry((pos)->member.ll_next.virtual_address,    \
-                                     type, member);                         \
-             &(pos)->member != (void *)head;                            \
-             pos  = next,                                               \
-             next = m0_be_list_entry((next)->member.ll_next.virtual_address, \
-                                     type, member))
-
-
-/** @} end of be_list group */
-
-#endif /* __MERO_BE_LIB_BE_LIST_H__ */
-
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
diff --git a/be/lib/be_tlist.c b/be/lib/be_tlist.c
deleted file mode 100644
index 4f8ee99..0000000
--- a/be/lib/be_tlist.c
+++ /dev/null
@@ -1,303 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2012 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author        : Zishan Shaikh <zishan_shaikh@xyratex.com>
- * Original creation date : 12/04/2012
- */
-
-#include "be/lib/be_tlist.h"
-/**
-   @addtogroup be_tlist
-   @{
- */
-
-/**
-   Returns the address of a link embedded in an ambient object.
- */
-static struct m0_be_list_link
-*be_link(const struct m0_be_tl_descr *d, const void *obj);
-/**
-   Returns the value of the magic field in an ambient object
- */
-static uint64_t be_magic(const struct m0_be_tl_descr *d,
-                         const void *obj);
-
-/**
-   Casts a link to its ambient object.
- */
-static void *be_amb(const struct m0_be_tl_descr *d,
-                    struct m0_be_list_link *link);
-
-M0_INTERNAL void m0_be_tlist_init(const struct m0_be_tl_descr *d,
-                                   struct m0_be_tl *list)
-{
-        list->t_magic = d->td_head_magic;
-        m0_be_list_init(&list->t_head);
-        M0_POST(m0_be_tlist_invariant(d, list));
-}
-
-M0_INTERNAL void m0_be_tlist_fini(const struct m0_be_tl_descr *d,
-                                  struct m0_be_tl *list)
-{
-        M0_PRE(m0_be_tlist_invariant(d, list));
-        m0_be_list_fini(&list->t_head);
-}
-
-M0_INTERNAL void m0_be_tlink_init(const struct m0_be_tl_descr *d,
-                                  struct m0_reference         *ref)
-{
-        void *obj = ref->virtual_address;
-        m0_be_list_link_init(be_link(d,obj), ref);
-        if (d->td_link_magic != 0)
-                *(uint64_t *)(obj + d->td_link_magic_offset) = d->td_link_magic;
-        M0_POST(m0_be_tlink_invariant(d, obj));
-}
-
-M0_INTERNAL void m0_be_tlink_init_at(const struct m0_be_tl_descr *d,
-                                     struct m0_be_tl *list,
-                                     struct m0_reference *ref)
-{
-        void *obj = ref->virtual_address;
-        m0_be_tlink_init(d, ref);
-        m0_be_tlist_add(d, list, obj);
-}
-
-M0_INTERNAL void m0_be_tlink_init_at_tail(const struct m0_be_tl_descr *d,
-                                          struct m0_be_tl *list,
-                                          struct m0_reference *ref)
-{
-        void *obj = ref->virtual_address;
-        m0_be_tlink_init(d, ref);
-        m0_be_tlist_add_tail(d, list, obj);
-}
-
-M0_INTERNAL void m0_be_tlink_fini(const struct m0_be_tl_descr *d, void *obj)
-{
-        m0_be_list_link_fini(be_link(d, obj));
-}
-
-M0_INTERNAL void m0_be_tlink_del_fini(const struct m0_be_tl_descr *d, void *obj)
-{
-        m0_be_tlist_del(d, obj);
-        m0_be_tlink_fini(d, obj);
-}
-
-M0_INTERNAL bool m0_be_tlist_is_empty(const struct m0_be_tl_descr *d,
-                                      const struct m0_be_tl *list)
-{
-        M0_PRE(m0_be_tlist_invariant(d, list));
-        return m0_be_list_is_empty(&list->t_head);
-}
-
-M0_INTERNAL bool m0_be_tlink_is_in(const struct m0_be_tl_descr *d,
-                                   const void *obj)
-{
-        M0_PRE(m0_be_tlink_invariant(d, obj));
-        return m0_be_list_link_is_in(be_link(d, obj));
-}
-
-M0_INTERNAL bool m0_be_tlist_contains(const struct m0_be_tl_descr *d,
-                                      const struct m0_be_tl       *list,
-                                      const void                  *obj)
-{
-        M0_PRE(m0_be_tlist_invariant(d, list));
-        M0_PRE(m0_be_tlink_invariant(d, obj));
-        return m0_be_list_contains(&list->t_head, be_link(d, obj));
-}
-
-M0_INTERNAL size_t m0_be_tlist_length(const struct m0_be_tl_descr *d,
-                                      const struct m0_be_tl       *list)
-{
-        M0_PRE(m0_be_tlist_invariant(d, list));
-        return m0_be_list_length(&list->t_head);
-}
-M0_EXPORTED(m0_be_tlist_length);
-
-M0_INTERNAL void m0_be_tlist_add(const struct m0_be_tl_descr *d,
-                                 struct m0_be_tl *list, void *obj)
-{
-        M0_PRE(m0_be_tlist_invariant(d, list));
-        M0_PRE(!m0_be_tlink_is_in(d, obj));
-        m0_be_list_add(&list->t_head, be_link(d, obj));
-}
-
-M0_INTERNAL void m0_be_tlist_add_tail(const struct m0_be_tl_descr *d,
-                                      struct m0_be_tl *list, void *obj)
-{
-        M0_PRE(m0_be_tlist_invariant(d, list));
-        M0_PRE(!m0_be_tlink_is_in(d, obj));
-        m0_be_list_add_tail(&list->t_head, be_link(d, obj));
-}
-
-M0_INTERNAL void m0_be_tlist_add_after(const struct m0_be_tl_descr *d,
-                                       void *obj, void *new)
-{
-        M0_PRE(m0_be_tlink_is_in(d, obj));
-        M0_PRE(!m0_be_tlink_is_in(d, new));
-        m0_be_list_add_after(be_link(d, obj), be_link(d, new));
-}
-
-M0_INTERNAL void m0_be_tlist_add_before(const struct m0_be_tl_descr *d,
-                                        void *obj, void *new)
-{
-        M0_PRE(m0_be_tlink_is_in(d, obj));
-        M0_PRE(!m0_be_tlink_is_in(d, new));
-        m0_be_list_add_before(be_link(d, obj), be_link(d, new));
-}
-
-M0_INTERNAL void m0_be_tlist_del(const struct m0_be_tl_descr *d, void *obj)
-{
-        M0_PRE(m0_be_tlink_invariant(d, obj));
-        M0_PRE(m0_be_tlink_is_in(d, obj));
-        m0_be_list_del(be_link(d, obj));
-        M0_PRE(!m0_be_tlink_is_in(d, obj));
-}
-
-M0_INTERNAL void m0_be_tlist_move(const struct m0_be_tl_descr *d,
-                                  struct m0_be_tl *list, void *obj)
-{
-        M0_PRE(m0_be_tlist_invariant(d, list));
-        M0_PRE(m0_be_tlink_is_in(d, obj));
-
-        m0_be_list_move(&list->t_head, be_link(d, obj));
-}
-
-M0_INTERNAL void m0_be_tlist_move_tail(const struct m0_be_tl_descr *d,
-                                       struct m0_be_tl *list, void *obj)
-{
-        M0_PRE(m0_be_tlist_invariant(d, list));
-        M0_PRE(m0_be_tlink_is_in(d, obj));
-
-        m0_be_list_move_tail(&list->t_head, be_link(d, obj));
-}
-
-M0_INTERNAL void *m0_be_tlist_head(const struct m0_be_tl_descr *d,
-                                   const struct m0_be_tl *list)
-{
-        const struct m0_be_list *head;
-
-        M0_PRE(m0_be_tlist_invariant(d, list));
-
-        head = &list->t_head;
-        return (head->l_head.virtual_address !=
-               (void *)head ? be_amb(d, head->l_head.virtual_address) : NULL);
-}
-
-M0_INTERNAL void *m0_be_tlist_tail(const struct m0_be_tl_descr *d,
-                                   const struct m0_be_tl *list)
-{
-        const struct m0_be_list *head;
-
-        M0_PRE(m0_be_tlist_invariant(d, list));
-
-        head = &list->t_head;
-        return (head->l_tail.virtual_address !=
-               (void *)head ? be_amb(d, head->l_tail.virtual_address) : NULL);
-}
-
-M0_INTERNAL void *m0_be_tlist_next(const struct m0_be_tl_descr *d,
-                                   const struct m0_be_tl *list, void *obj)
-{
-        struct m0_be_list_link *next;
-
-        M0_PRE(m0_be_tlist_contains(d, list, obj));
-
-        next = (struct m0_be_list_link *)
-                be_link(d, obj)->ll_next.virtual_address;
-        return (void *)next != &list->t_head ? be_amb(d, next) : NULL;
-}
-
-M0_INTERNAL void *m0_be_tlist_prev(const struct m0_be_tl_descr *d,
-                                   const struct m0_be_tl *list, void *obj)
-{
-        struct m0_be_list_link *prev;
-
-        M0_PRE(m0_be_tlist_contains(d, list, obj));
-
-        prev = (struct m0_be_list_link *)
-                be_link(d, obj)->ll_prev.virtual_address;
-        return (void *)prev != &list->t_head ? be_amb(d, prev) : NULL;
-}
-
-M0_INTERNAL bool m0_be_tlist_invariant(const struct m0_be_tl_descr *d,
-                                       const struct m0_be_tl *list)
-{
-        struct m0_be_list_link *head;
-        struct m0_be_list_link *scan;
-        struct m0_be_list_link *next_temp;
-        struct m0_be_list_link *prev_temp;
-
-        head = (void *)&list->t_head;
-
-        if (list->t_magic != d->td_head_magic)
-                return false;
-        if ((head->ll_next.virtual_address == (void *)head) !=
-            (head->ll_prev.virtual_address == (void *)head))
-                return false;
-
-        for (scan = head->ll_next.virtual_address;
-             scan != head; scan = scan->ll_next.virtual_address) {
-
-                next_temp = scan->ll_next.virtual_address;
-                prev_temp = scan->ll_prev.virtual_address;
-
-                if (next_temp->ll_prev.virtual_address != scan ||
-                    prev_temp->ll_next.virtual_address != scan)
-                        return false;
-
-                if (!m0_be_tlink_invariant(d, be_amb(d, scan)))
-                        return false;
-        }
-
-        return true;
-}
-
-M0_INTERNAL bool m0_be_tlink_invariant(const struct m0_be_tl_descr *d,
-                                       const void *obj)
-{
-        return d->td_link_magic == 0 || be_magic(d, obj) == d->td_link_magic;
-}
-
-static struct m0_be_list_link
-*be_link(const struct m0_be_tl_descr *d, const void *obj)
-{
-        return &((struct m0_be_tlink *)(obj + d->td_link_offset))->t_link;
-}
-
-static uint64_t be_magic(const struct m0_be_tl_descr *d,
-                         const void *obj)
-{
-        return *(uint64_t *)(obj + d->td_link_magic_offset);
-}
-
-static void *be_amb(const struct m0_be_tl_descr *d,
-                    struct m0_be_list_link *link)
-{
-        return (void *)container_of(link, struct m0_be_tlink,
-                                    t_link) - d->td_link_offset;
-}
-
-/** @} end of be_tlist group */
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
diff --git a/be/lib/be_tlist.h b/be/lib/be_tlist.h
deleted file mode 100644
index 08a61ed..0000000
--- a/be/lib/be_tlist.h
+++ /dev/null
@@ -1,651 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2012 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Zishan Shaikh <zishan_shaikh@xyratex.com>
- * Original creation date: 12/04/2012
- */
-#pragma once
-#ifndef __MERO_BE_LIB_BE_TLIST_H__
-#define __MERO_BE_LIB_BE_TLIST_H__
-
-#include "be/lib/be_list.h"
-#include "be/lib/be_types.h"
-
-/**
-   @defgroup be_tlist Typed lists.
-
-   Typed list module provides a double-linked list implementation that
-   eliminates some chores and sources of errors typical for the "raw" m0_be_list
-   interface.
-
-   Typed list is implemented on top of m0_be_list and adds the following
-   features:
-
-       - a "list descriptor" (m0_be_tl_descr) object holding information about
-         this
-         list type, including its human readable name;
-
-       - "magic" numbers embedded in list header and list links and checked by
-         the code to catch corruptions;
-
-       - automatic conversion to and from list links and ambient objects they
-         are embedded to, obviating the need in container_of() and
-         m0_be_list_entry() calls. In fact, links (m0_be_tlink) are not
-         mentioned in tlist interface at all;
-
-       - gdb (7.0) pretty-printer for lists (not yet implemented).
-
-   tlist is a safe and more convenient alternative to m0_be_list. As a general
-   rule, m0_be_list should be used only when performance is critical or some
-   flexibility beyond what tlist provides (e.g., a cyclic list without a head
-   object) is necessary.
-
-   Similarly to m0_be_list, tlist is a purely algorithmic module: it deals with
-   neither concurrency nor liveness nor with any similar issues that its callers
-   are supposed to handle.
-
-   To describe a typical tlist usage pattern, suppose that one wants a list of
-   objects of type foo hanging off every object of type bar.
-
-   First, two things have to be done:
-
-   - "list link" has to be embedded in foo:
-
-     @code
-     struct foo {
-             ...
-             // linkage into a list of foo-s hanging off bar::b_list
-             struct m0_be_tlink f_linkage;
-             ...
-     };
-     @endcode
-
-   - then, a "list head" has to be embedded in bar:
-
-     @code
-     struct bar {
-             ...
-             // list of foo-s, linked through foo::f_linkage
-             struct m0_be_tl b_list;
-             ...
-     };
-     @endcode
-
-   - now, define a tlist type:
-
-     @code
-     static const struct m0_be_tl_descr foobar_list = {
-             .td_name        = "foo-s of bar",
-             .td_link_offset = offsetof(struct foo, f_linkage),
-             .td_head_magic  = 0x666f6f6261726865 // "foobarhe"
-     };
-     @endcode
-
-   This defines the simplest form of tlist without magic checking in list links
-   (the magic embedded in a list head is checked anyway). To add magic checking,
-   place a magic field in foo:
-
-   @code
-   struct foo {
-           ...
-           uint64_t f_magic;
-           ...
-   };
-
-   static const struct m0_be_tl_descr foobar_list = {
-           ...
-           .td_link_magic_offset = offsetof(struct foo, f_magic),
-           .td_link_magic        = 0x666f6f6261726c69 // "foobarli"
-   };
-   @endcode
-
-   Magic field can be shared by multiple tlist links embedded in the same object
-   and can be used for other sanity checking. An "outermost" finaliser function
-   must clear the magic as its last step to catch use-after-fini errors.
-
-   Now, one can populate and manipulate foo-bar lists:
-
-   @code
-   struct bar  B;
-   struct foo  F;
-   struct foo *scan;
-
-   m0_be_tlist_init(&B.b_list);
-   m0_be_tlink_init(&F.f_linkage);
-
-   m0_be_tlist_add(&foobar_list, &B.b_list, &F);
-   M0_ASSERT(m0_be_tl_contains(&foobar_list, &B.b_list, &F));
-
-   m0_be_tlist_for(&foobar_list, &B.b_list, scan)
-           m0_ASSERT(scan == &F);
-   m0_be_tlist_endfor;
-   @endcode
-
-   @note Differently from m0_be_list, tlist heads and links must be initialised
-   before use, even when first usage overwrites the entity completely. This
-   allows stronger checking in tlist manipulation functions.
-
-   <b>Type-safe macros.</b>
-
-   M0_BE_TL_DESCR_DECLARE(), M0_BE_TL_DECLARE(), M0_BE_TL_DESCR_DEFINE() and
-   M0_BE_TL_DEFINE() macros generate versions of tlist interface tailored for a
-   particular use case.
-
-   4 separate macros are necessary for flexibility. They should be used in
-   exactly one of the following ways for any given typed list:
-
-       - static tlist, used in a single module only: M0_BE_TL_DEFINE() and
-         M0_BE_TL_DESCR_DEFINE() with scope "static" in the module .c file;
-
-       - tlist exported from a module: M0_BE_TL_DEFINE() and
-         M0_BE_TL_DESCR_DEFINE()with scope "" in .c file and
-         M0_BE_TL_DESCR_DECLARE(), M0_BE_TL_DECLARE() with scope "extern"
-         in .h file;
-
-       - tlist exported from a module as a collection of inline functions:
-         M0_BE_TL_DESCR_DEFINE() in .c file and M0_BE_TL_DESCR_DECLARE()
-         with scope "extern" followed by M0_BE_TL_DEFINE() with scope
-         "static inline" in .h file.
-   @{
- */
-
-struct m0_be_tl_descr;
-struct m0_be_tl;
-struct m0_be_tlink;
-
-/**
-   An instance of this type must be defined for each "tlist type", specifically
-   for each link embedded in an ambient type.
-
-   @verbatim
-                              ambient object
-                          +  +-----------   +
-     td_link_magic_offset |  |           |  |
-                          v  |           |  |
-                             |-----------|  |
-                             |link magic |  | td_link_offset
-                             |-----------|  |
-                             |           |  |
-        head                 |           |  |
-    +->+----------+          |           |  |
-    |  |head magic|          |           |  v
-    |  |----------|          |-----------|
-    |  |        +----------->|link     +------------> . . . ---+
-    |  +----------+          |-----------|                     |
-    |                        |           |                     |
-    |                        |           |                     |
-    |                        |           |                     |
-    |                        |           |                     |
-    |                        +-----------+                     |
-    |                                                          |
-    +----------------------------------------------------------+
-
-   @endverbatim
- */
-struct m0_be_tl_descr {
-        /** Human-readable list name, used for error messages. */
-        const char *td_name;
-        /** Offset of list link (m0_tlink) in the ambient object. */
-        int         td_link_offset;
-        /**
-            Offset of magic field in the ambient object.
-            This is used only when link magic checking is on.
-
-            @see m0_be_tl_descr::td_link_magic
-         */
-        int         td_link_magic_offset;
-        /**
-            Magic stored in an ambient object.
-
-            If this field is 0, link magic checking is disabled.
-         */
-        uint64_t    td_link_magic;
-        /**
-            Magic stored in m0_tl::t_magic and checked on all tlist
-            operations.
-         */
-        uint64_t    td_head_magic;
-};
-
-#define M0_BE_TL_DESCR(name, ambient_type, link_field, link_magic_field,\
-                       link_magic, head_magic)                          \
-{                                                                       \
-        .td_name              = name,                                   \
-        .td_link_offset       = offsetof(ambient_type, link_field),     \
-        .td_link_magic_offset = offsetof(ambient_type, link_magic_field), \
-        .td_link_magic        = link_magic,                             \
-        .td_head_magic        = head_magic                              \
-};                                                                      \
-                                                                        \
-M0_BASSERT(M0_HAS_TYPE(M0_FIELD_VALUE(ambient_type, link_field),        \
-                       struct m0_be_tlink));                            \
-M0_BASSERT(M0_HAS_TYPE(M0_FIELD_VALUE(ambient_type, link_magic_field),  \
-                       uint64_t))
-
-/**
- * tlist head tp support back-end domain
- */
-struct m0_be_tl {
-        /**
-           Head magic. This is set to m0_tl::td_head_magic and verified by the
-           list invariant.
-         */
-        uint64_t          t_magic;
-        /** Underlying m0_be_list. */
-        struct m0_be_list t_head;
-};
-
-
-/**
- * tlist link to support back-end domain
- */
-struct m0_be_tlink {
-        /** Underlying m0_be_list link. */
-        struct m0_be_list_link t_link;
-};
-
-M0_INTERNAL void m0_be_tlist_init(const struct m0_be_tl_descr *d,
-                                  struct m0_be_tl *list);
-
-M0_INTERNAL void m0_be_tlist_fini(const struct m0_be_tl_descr *d,
-                                  struct m0_be_tl *list);
-
-M0_INTERNAL void m0_be_tlink_init(const struct m0_be_tl_descr *d,
-                                  struct m0_reference *ref);
-
-M0_INTERNAL void m0_be_tlink_fini(const struct m0_be_tl_descr *d, void *obj);
-
-M0_INTERNAL void m0_be_tlink_init_at(const struct m0_be_tl_descr *d,
-                                     struct m0_be_tl *list,
-                                     struct m0_reference *ref);
-
-M0_INTERNAL void m0_be_tlink_init_at_tail(const struct m0_be_tl_descr *d,
-                                          struct m0_be_tl *list,
-                                          struct m0_reference *ref);
-
-M0_INTERNAL void m0_be_tlink_del_fini(const struct m0_be_tl_descr *d,
-                                      void *obj);
-
-M0_INTERNAL bool m0_be_tlist_invariant(const struct m0_be_tl_descr *d,
-                                       const struct m0_be_tl *list);
-
-M0_INTERNAL bool m0_be_tlink_invariant(const struct m0_be_tl_descr *d,
-                                       const void *obj);
-
-M0_INTERNAL bool   m0_be_tlist_is_empty(const struct m0_be_tl_descr *d,
-                                        const struct m0_be_tl *list);
-
-M0_INTERNAL bool   m0_be_tlink_is_in(const struct m0_be_tl_descr *d,
-                                     const void *obj);
-
-M0_INTERNAL bool   m0_be_tlist_contains(const struct m0_be_tl_descr *d,
-                                        const struct m0_be_tl *list,
-                                        const void *obj);
-
-M0_INTERNAL size_t m0_be_tlist_length  (const struct m0_be_tl_descr *d,
-                                        const struct m0_be_tl *list);
-
-/**
-   Adds an element to the beginning of a list.
-
-   @pre !m0_tlink_is_in(d, obj)
-   @post m0_tlink_is_in(d, obj)
- */
-M0_INTERNAL void   m0_be_tlist_add(const struct m0_be_tl_descr *d,
-                                   struct m0_be_tl *list, void *obj);
-
-/**
-   Adds an element to the end of a list.
-
-   @pre !m0_tlink_is_in(d, obj)
-   @post m0_tlink_is_in(d, obj)
- */
-M0_INTERNAL void   m0_be_tlist_add_tail(const struct m0_be_tl_descr *d,
-                                        struct m0_be_tl *list, void *obj);
-
-/**
-   Adds an element after another element of the list.
-
-   @pre !m0_tlink_is_in(d, new)
-   @post m0_tlink_is_in(d, new)
- */
-M0_INTERNAL void   m0_be_tlist_add_after(const struct m0_be_tl_descr *d,
-                                         void *obj, void *new);
-
-/**
-   Adds an element before another element of the list.
-
-   @pre !m0_tlink_is_in(d, new)
-   @post m0_tlink_is_in(d, new)
- */
-M0_INTERNAL void   m0_be_tlist_add_before(const struct m0_be_tl_descr *d,
-                                          void *obj, void *new);
-
-/**
-   Deletes an element from the list.
-
-   @pre   m0_tlink_is_in(d, obj)
-   @post !m0_tlink_is_in(d, obj)
- */
-M0_INTERNAL void   m0_be_tlist_del(const struct m0_be_tl_descr *d, void *obj);
-
-/**
-   Moves an element from a list to the head of (possibly the same) list.
-
-   @pre  m0_tlink_is_in(d, obj)
-   @post m0_tlink_is_in(d, obj)
- */
-M0_INTERNAL void   m0_be_tlist_move(const struct m0_be_tl_descr *d,
-                                    struct m0_be_tl *list, void *obj);
-
-/**
-   Moves an element from a list to the tail of (possibly the same) list.
-
-   @pre  m0_tlink_is_in(d, obj)
-   @post m0_tlink_is_in(d, obj)
- */
-M0_INTERNAL void   m0_be_tlist_move_tail(const struct m0_be_tl_descr *d,
-                                         struct m0_be_tl *list, void *obj);
-
-/**
-   Returns the first element of a list or NULL if the list is empty.
- */
-M0_INTERNAL void  *m0_be_tlist_head(const struct m0_be_tl_descr *d,
-                                    const struct m0_be_tl *list);
-
-/**
-   Returns the last element of a list or NULL if the list is empty.
- */
-M0_INTERNAL void  *m0_be_tlist_tail(const struct m0_be_tl_descr *d,
-                                    const struct m0_be_tl *list);
-
-/**
-   Returns the next element of a list or NULL if @obj is the last element.
-
-   @pre m0_be_tlist_contains(d, list, obj)
- */
-M0_INTERNAL void  *m0_be_tlist_next(const struct m0_be_tl_descr *d,
-                                    const struct m0_be_tl *list, void *obj);
-
-
-/**
-   Returns the previous element of a list or NULL if @obj is the first element.
-
-   @pre m0_be_tlist_contains(d, list, obj)
- */
-M0_INTERNAL void  *m0_be_tlist_prev(const struct m0_be_tl_descr *d,
-                                    const struct m0_be_tl    *list, void *obj);
-
-
-/**
-   Iterates over elements of list @head of type @descr, assigning them in order
-   (from head to tail) to @obj.
-
-   It is safe to delete the "current" object in the body of the loop or modify
-   the portion of the list preceding the current element. It is *not* safe to
-   modify the list after the current point.
-
-   @code
-   m0_be_tlist_for(&foobar_list, &B.b_list, foo)
-           sum += foo->f_value;
-   m0_be_tlist_endfor;
-
-   m0_be_tlist_for(&foobar_list, &B.b_list, foo) {
-           if (foo->f_value % sum == 0)
-                   m0_be_tlist_del(&foobar_list, foo);
-   } m0_be_tlist_endfor;
-   @endcode
-
-   m0_be_tlist_for() macro has a few points of technical interest:
-
-       - it introduces a scope to declare a temporary variable to hold the
-         pointer to a "next" list element. The undesirable result of this is
-         that the loop has to be terminated by the matching m0_be_tlist_endfor
-         macro, closing the hidden scope. An alternative would be to use C99
-         syntax for iterative statement, which allows a declaration in the
-         for-loop header. Unfortunately, even though C99 mode can be enforced
-         for compilation of linux kernel modules (by means of CFLAGS_MODULE),
-         the kernel doesn't compile correctly in this mode;
-
-       - "inventive" use of comma expression in the loop condition allows to
-         calculate next element only once and only when the current element is
-         not NULL.
-
-   @see m0_be_tlist_endfor
- */
-
-#define m0_be_tlist_for(descr, head, obj)                               \
-do {                                                                    \
-        void *__be_tl;                                                  \
-                                                                        \
-        for (obj = m0_be_tlist_head(descr, head);                       \
-             obj != NULL &&                                             \
-             ((void)(__be_tl = m0_be_tlist_next(descr, head, obj)), true);\
-             obj = __be_tl)
-
-/**
-   Terminates m0_be_tlist_for() loop.
- */
-#define m0_be_tlist_endfor ; (void)__be_tl; } while (0)
-
-/**
-   Declares a version of tlist interface with definitions adjusted to take
-   parameters of a specified ambient type (rather than void) and to hide
-   m0_be_tl_descr from signatures.
-
-   @code
-   M0_BE_TL_DECLARE(foo, static, struct foo);
-   @endcode
-
-   declares
-
-   @code
-   static void foo_tlist_init(struct m0_tl *head);
-   static void foo_tlink_init(struct foo *amb);
-   static void foo_tlist_move(struct m0_tl *list, struct foo *amb);
-   static struct foo *foo_tlist_head(const struct m0_tl *list);
-   @endcode
-
-   &c.
-
-   @see M0_BE_TL_DEFINE()
-   @see M0_BE_TL_DESCR_DEFINE()
- */
-#define M0_BE_TL_DECLARE(name, scope, amb_type)                         \
-                                                                        \
-scope void name ## _be_tlist_init(struct m0_be_tl *head);               \
-scope void name ## _be_tlist_fini(struct m0_be_tl *head);               \
-scope void name ## _be_tlink_init(struct m0_reference *ref);             \
-scope void name ## _be_tlink_init_at(struct m0_reference *ref,           \
-                                     struct m0_be_tl *head);            \
-scope void name ## _be_tlink_init_at_tail(struct m0_reference *ref,      \
-                                          struct m0_be_tl *head);       \
-scope void name ## _be_tlink_fini(amb_type *amb);                       \
-scope void name ## _be_tlink_del_fini(amb_type *amb);                   \
-scope bool   name ## _be_tlist_is_empty(const struct m0_be_tl *list);   \
-scope bool   name ## _be_tlink_is_in   (const amb_type *amb);           \
-scope bool   name ## _be_tlist_contains(const struct m0_be_tl *list,    \
-                                        const amb_type *amb);           \
-scope size_t name ## _be_tlist_length(const struct m0_be_tl *list);     \
-scope void   name ## _be_tlist_add(struct m0_be_tl *list, amb_type *amb); \
-scope void   name ## _be_tlist_add_tail(struct m0_be_tl *list, amb_type *amb); \
-scope void   name ## _be_tlist_add_after(amb_type *amb, amb_type *new); \
-scope void   name ## _be_tlist_add_before(amb_type *amb, amb_type *new);\
-scope void   name ## _be_tlist_del(amb_type *amb);                      \
-scope void   name ## _be_tlist_move(struct m0_be_tl *list, amb_type *amb); \
-scope void   name ## _be_tlist_move_tail(struct m0_be_tl *list, amb_type *amb);\
-scope amb_type *name ## _be_tlist_head(const struct m0_be_tl *list);    \
-scope amb_type *name ## _be_tlist_tail(const struct m0_be_tl *list);    \
-scope amb_type *name ## _be_tlist_next(const struct m0_be_tl *list,     \
-                                       amb_type *amb);                  \
-scope amb_type *name ## _be_tlist_prev(const struct m0_be_tl *list, \
-                                       amb_type *amb)
-
-#define __AUN __attribute__((unused))
-
-
-/**
-   Defines a tlist descriptor (m0_be_tl_descr) for a particular ambient type.
- */
-#define M0_BE_TL_DESCR_DEFINE(name, hname, scope, amb_type, amb_link_field, \
-                              amb_magic_field, amb_magic, head_magic)   \
-scope const struct m0_be_tl_descr name ## _tl = M0_BE_TL_DESCR(hname,   \
-                                                               amb_type,\
-                                                               amb_link_field,\
-                                                               amb_magic_field,\
-                                                               amb_magic,\
-                                                               head_magic)
-
-
-/**
-   Defines functions declared by M0_BE_TL_DECLARE().
-
-   The definitions generated assume that tlist descriptor, defined by
-   M0_BE_TL_DESC_DEFINE() is in scope.
- */
-#define M0_BE_TL_DEFINE(name, scope, amb_type)                          \
-                                                                        \
-scope __AUN void name ## _tlist_init(struct m0_be_tl *head)             \
-{                                                                       \
-        m0_be_tlist_init(&name ## _tl, head);                           \
-}                                                                       \
-                                                                        \
-scope __AUN void name ## _tlist_fini(struct m0_be_tl *head)             \
-{                                                                       \
-        m0_be_tlist_fini(&name ## _tl, head);                           \
-}                                                                       \
-                                                                        \
-scope __AUN void name ## _tlink_init(struct m0_reference *ref)           \
-{                                                                       \
-        m0_be_tlink_init(&name ## _tl, ref);                            \
-}                                                                       \
-                                                                        \
-scope __AUN void name ## _tlink_init_at(struct m0_reference *ref,       \
-                                        struct m0_be_tl *head)          \
-{                                                                       \
-        m0_be_tlink_init_at(&name ## _tl,  head, ref);                  \
-}                                                                       \
-                                                                        \
-scope __AUN void name ## _tlink_init_at_tail(struct m0_reference *ref,  \
-                                             struct m0_be_tl *head)     \
-{                                                                       \
-        m0_be_tlink_init_at_tail(&name ## _tl, head, ref);              \
-}                                                                       \
-                                                                        \
-scope __AUN void name ## _tlink_fini(amb_type *amb)                     \
-{                                                                       \
-        m0_be_tlink_fini(&name ## _tl, amb);                            \
-}                                                                       \
-                                                                        \
-scope __AUN void name ## _tlink_del_fini(amb_type *amb)                 \
-{                                                                       \
-        m0_be_tlink_del_fini(&name ## _tl, amb);                        \
-}                                                                       \
-                                                                        \
-scope __AUN bool   name ## _tlist_is_empty(const struct m0_be_tl *list) \
-{                                                                       \
-        return m0_be_tlist_is_empty(&name ## _tl, list);                \
-}                                                                       \
-                                                                        \
-scope __AUN bool   name ## _tlink_is_in   (const amb_type *amb)         \
-{                                                                       \
-        return m0_be_tlink_is_in(&name ## _tl, amb);                    \
-}                                                                       \
-                                                                        \
-scope __AUN bool   name ## _tlist_contains(const struct m0_be_tl *list, \
-                                           const amb_type *amb)         \
-{                                                                       \
-        return m0_be_tlist_contains(&name ## _tl, list, amb);           \
-}                                                                       \
-                                                                        \
-scope __AUN size_t name ## _tlist_length(const struct m0_be_tl *list)   \
-{                                                                       \
-        return m0_be_tlist_length(&name ## _tl, list);                  \
-}                                                                       \
-                                                                        \
-scope __AUN void   name ## _tlist_add(struct m0_be_tl *list, amb_type *amb) \
-{                                                                       \
-        m0_be_tlist_add(&name ## _tl, list, amb);                       \
-}                                                                       \
-                                                                        \
-scope __AUN void   name ## _tlist_add_tail(struct m0_be_tl *list,       \
-                                           amb_type *amb)               \
-{                                                                       \
-        m0_be_tlist_add_tail(&name ## _tl, list, amb);                  \
-}                                                                       \
-                                                                        \
-scope __AUN void   name ## _tlist_add_after(amb_type *amb, amb_type *new) \
-{                                                                       \
-        m0_be_tlist_add_after(&name ## _tl, amb, new);                  \
-}                                                                       \
-                                                                        \
-scope __AUN void   name ## _tlist_add_before(amb_type *amb, amb_type *new) \
-{                                                                       \
-        m0_be_tlist_add_before(&name ## _tl, amb, new);                 \
-}                                                                       \
-                                                                        \
-scope __AUN void   name ## _tlist_del(amb_type *amb)                    \
-{                                                                       \
-        m0_be_tlist_del(&name ## _tl, amb);                             \
-}                                                                       \
-                                                                        \
-scope __AUN void   name ## _tlist_move(struct m0_be_tl *list, amb_type *amb)\
-{                                                                       \
-        m0_be_tlist_move(&name ## _tl, list, amb);                      \
-}                                                                       \
-                                                                        \
-scope __AUN void   name ## _tlist_move_tail(struct m0_be_tl *list,      \
-                                            amb_type *amb)              \
-{                                                                       \
-        m0_be_tlist_move_tail(&name ## _tl, list, amb);                 \
-}                                                                       \
-                                                                        \
-scope __AUN amb_type *name ## _tlist_head(const struct m0_be_tl *list)  \
-{                                                                       \
-        return m0_be_tlist_head(&name ## _tl, list);                    \
-}                                                                       \
-                                                                        \
-scope __AUN amb_type *name ## _tlist_tail(const struct m0_be_tl *list)  \
-{                                                                       \
-        return m0_be_tlist_tail(&name ## _tl, list);                    \
-}                                                                       \
-                                                                        \
-scope __AUN amb_type *name ## _tlist_next(const struct m0_be_tl *list,  \
-                                          amb_type *amb)                \
-{                                                                       \
-        return m0_be_tlist_next(&name ## _tl, list, amb);               \
-}                                                                       \
-                                                                        \
-scope __AUN amb_type *name ## _tlist_prev(const struct m0_be_tl *list,  \
-                                          amb_type *amb)                \
-{                                                                       \
-        return m0_be_tlist_prev(&name ## _tl, list, amb);               \
-}                                                                       \
-                                                                        \
-struct __ ## name ## _terminate_me_with_a_semicolon { ; }
-/** @} end of be_tlist group */
-
-#endif /* __MERO_BE_LIB_BE_TLIST_H__ */
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
diff --git a/be/lib/be_types.h b/be/lib/be_types.h
deleted file mode 100644
index 30ae145..0000000
--- a/be/lib/be_types.h
+++ /dev/null
@@ -1,55 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2012 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author              : Zishan Shaikh <zishan_shaikh@xyratex.com>
- * Original creation date       : 12/04/2012
- */
-#pragma once
-#ifndef __MERO_BE_LIB_BE_TYPES_H__
-#define __MERO_BE_LIB_BE_TYPES_H__
-
-#include "lib/types.h"
-
-/**
- *      Structure added to support back-end domain wide reference pointer
- */
-struct m0_reference {
-        /*
-         * Should always be the first field of this structure, stores the
-         * virtual address of the object.
-         */
-        void *virtual_address;
-        /* Higher 64 bit segment id & lower 64 bit offset within the segment */
-        struct m0_uint128 segid_offset;
-
-        /* usage : TBD */
-        uint64_t magic;
-
-        /* usage : TBD */
-        uint64_t magic_offset;
-};
-
-#endif /* __MERO_BE_LIB_BE_TYPES_H_ */
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
diff --git a/be/lib/ut/Makefile b/be/lib/ut/Makefile
deleted file mode 100644
index f607b7f..0000000
--- a/be/lib/ut/Makefile
+++ /dev/null
@@ -1,10 +0,0 @@
-.PHONY:all
-
-all:
-	gcc .libs/ut_libmero_ut_la-be_tlist.o  ../../../mero/.libs/libmero.a  -o ./be_tlist_ut  -lpthread  -ldb  -lrt -laio -lrvm -lrds -lseg -L../../../../rvm/rvm/.libs -L../../../../rvm/rds/.libs -L../../../../rvm/seg/.libs
-	gcc .libs/ut_libmero_ut_la-be_kv_store.o  ../../../mero/.libs/libmero.a  -o ./be_kv_store_ut  -lpthread  -ldb  -lrt -laio -lrvm -lrds -lseg -L../../../../rvm/rvm/.libs -L../../../../rvm/rds/.libs -L../../../../rvm/seg/.libs
-	rm -rf /tmp/log_file
-clean:
-	rm -f ./be_tlist_ut
-	rm -f ./be_kv_store_ut
-	rm -f  /tmp/log_file
diff --git a/be/lib/ut/Makefile.sub b/be/lib/ut/Makefile.sub
deleted file mode 100644
index 555e443..0000000
--- a/be/lib/ut/Makefile.sub
+++ /dev/null
@@ -1,2 +0,0 @@
-ut_libmero_ut_la_SOURCES += be/lib/ut/be_tlist.c \
-                            be/lib/ut/be_kv_store.c
diff --git a/be/lib/ut/be_kv_store.c b/be/lib/ut/be_kv_store.c
deleted file mode 100644
index 10881e3..0000000
--- a/be/lib/ut/be_kv_store.c
+++ /dev/null
@@ -1,294 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2012 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Zishan Shaikh <zishan_shaikh@xyratex.com>
- * Original creation date: 12/24/2012
- */
-
-#include "be/lib/be_kv_store.h"
-#include "be/lib/be_handle_store.h"
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#define MAX_KEY_SIZE 256
-
-/* User defined structure */
-struct m0_kv_store_obj {
-        char                    key[MAX_KEY_SIZE];
-        int                     obj_val;
-        struct m0_be_tlink      linkage;
-        uint64_t                magic;
-};
-
-struct m0_be_tl_descr list_descr = M0_BE_TL_DESCR("kv_store_obj",
-                                                  struct m0_kv_store_obj,
-                                                  linkage,
-                                                  magic,
-                                                  0xab5ce55edba1b0a0,
-                                                  0xba1dba11adba0bab);
-
-struct m0_be_domain     *dom;
-struct m0_be_seg        *seg;
-struct m0_kv_store_obj  *object[1024]      = {NULL};
-struct m0_kv_store_obj  *ret_obj[1024]  = {NULL};
-struct m0_kv_store      *handle         = NULL;
-struct m0_kv_store_rvm  *handle_rvm     = NULL;
-
-int function_comp(void *key1, void *key2)
-{
-        struct m0_kv_store_obj *obj1;
-        struct m0_kv_store_obj *obj2;
-
-        obj1 = (struct m0_kv_store_obj *)key1;
-        obj2 = (struct m0_kv_store_obj *)key2;
-        return strcmp(obj1->key, obj2->key);
-}
-
-int function_match(void *in_obj, void *key)
-{
-        struct m0_kv_store_obj *obj;
-        obj = (struct m0_kv_store_obj *)in_obj;
-        return strcmp(obj->key, (char *)key);
-}
-
-static void init(char *mode)
-{
-        kv_key_cmp     cmp_routine;
-        kv_key_match   match_routine;
-
-        cmp_routine   = &function_comp;
-        match_routine = &function_match;
-
-        m0_ks_init_domain(&dom);
-        M0_ASSERT(dom != NULL);
-
-
-        m0_ks_init(&handle, &list_descr, dom, cmp_routine, match_routine, mode);
-        M0_ASSERT(handle != NULL);
-}
-
-static void fini()
-{
-        m0_ks_fini(dom, seg);
-}
-
-static int insert(char *key_name, int val)
-{
-        int                      status  = -2;
-        struct m0_be_tx         *tx;
-        struct m0_reference     *obj_ref = NULL;
-        struct m0_be_buf         obj_buf;
-        struct m0_be_reg        *obj_reg = NULL;
-
-        M0_ALLOC_PTR(tx);
-
-        if (tx == NULL)
-                goto exit_failure;
-
-        m0_be_tx_init(tx, dom, 0);
-        M0_BE_WAIT(tx->bt_impl.sm_group, &tx->bt_sm,
-                   (1 << M0_BETX_INIT) | (1 << M0_BETX_FAILED));
-
-        /* Prepare a region for the object */
-        obj_buf.b_nob = sizeof(struct m0_kv_store_obj);
-        m0_be_reg_init(&obj_reg, tx, seg, &obj_buf);
-
-        /* as nothing in credit list, so can start tx directly */
-        m0_ks_tx_start(tx);
-
-        /* Memory alloc to the object via rvm */
-        object[val] = (struct m0_kv_store_obj *)m0_ks_obj_malloc(obj_reg,
-                                                                 &obj_ref);
-
-        if(val < 10)
-                printf("object offset = %ld\n", obj_ref->segid_offset.u_lo);
-
-        if (object[val] == NULL)
-                goto exit_failure;
-
-        M0_ASSERT(obj_ref != NULL);
-
-        strncpy(object[val]->key, key_name, strlen(key_name));
-        /*memcpy( object[val]->key, key_name, strlen(key_name)+1);*/
-
-        object[val]->obj_val = val;
-
-        /* Insert this into the kv_store*/
-        status = m0_ks_insert(handle, obj_ref, tx);
-        if (status == BE_KV_FAILURE)
-                goto exit_failure;
-
-        m0_be_tx_done(tx);
-        M0_BE_WAIT(tx->bt_impl.sm_group, &tx->bt_sm,
-                   (1 << M0_BETX_DONE) | (1 << M0_BETX_FAILED));
-
-        m0_be_tx_fini(tx);
-
-        m0_free(tx);
-        return BE_KV_SUCCESS;
-
-exit_failure:
-        return BE_KV_FAILURE;
-}
-
-static void *find(char *key)
-{
-        return m0_ks_find(handle, key);
-}
-
-static int delete(struct m0_kv_store_obj *target)
-{
-        struct m0_be_tx      *tx = NULL;
-        struct m0_be_buf      obj_buf;
-        struct m0_be_reg     *obj_reg = NULL;
-        int                   ret_val;
-
-        M0_ALLOC_PTR(tx);
-
-        if (tx == NULL)
-                return BE_KV_FAILURE;
-
-        m0_be_tx_init(tx, dom, 0);
-        M0_BE_WAIT(tx->bt_impl.sm_group, &tx->bt_sm,
-                   (1 << M0_BETX_INIT) | (1 << M0_BETX_FAILED));
-
-        /* Prepare a region for this object */
-        obj_buf.b_nob = sizeof(struct m0_kv_store_obj);
-        obj_buf.b_addr = (void *)target;
-        m0_be_reg_init(&obj_reg, tx, seg, &obj_buf);
-        M0_ASSERT(obj_reg != NULL);
-
-        m0_be_tx_add_cred(tx, obj_reg);
-
-        m0_ks_tx_prep(tx);
-        m0_ks_tx_start(tx);
-
-        /* Delete this obj from kv store */
-        ret_val = m0_ks_delete(handle, (void *)target, tx);
-
-        if (ret_val != BE_KV_FAILURE) {
-                m0_be_tx_done(tx);
-                M0_BE_WAIT(tx->bt_impl.sm_group, &tx->bt_sm,
-                           (1 << M0_BETX_DONE) | (1 << M0_BETX_FAILED));
-
-                ret_val = BE_KV_SUCCESS;
-        }
-
-        m0_be_tx_fini(tx);
-        m0_free(tx);
-        return ret_val;
-}
-
-int main(int argc, char *argv[]) {
-        int                      status = -2;
-        int                      i      =  0;
-        int                      count  =  0;
-        size_t                   length =  0;
-        char                     obj_name[MAX_KEY_SIZE]   = "a";
-
-        if (argc != 4) {
-                printf("Usage : ./be_kv_store_ut recover/create "
-                        "object_name insert/delete\n");
-                return 0;
-        }
-
-        /* Init */
-        init(argv[1]);
-
-        m0_ks_domain_lookup(dom, &seg, 1);
-        M0_ASSERT(seg != NULL);
-
-        strcat(obj_name, argv[2]);
-
-        /* Insert 1K objects */
-        if (strcmp(argv[3], "insert") == 0) {
-                for(i = 0; i < 10; i++) {
-                        status = insert(obj_name, i);
-                        M0_ASSERT(status == BE_KV_SUCCESS);
-
-                        if (strlen(obj_name) < 255)
-                                strcat(obj_name, "a");
-                        else
-                                strcpy(obj_name, "akv");
-                }
-                printf("Inserted 10 objects!!\n");
-        }
-
-        /* Find the inserted objects */
-        count = 0;
-        strcpy(obj_name, "a");
-        strcat(obj_name, argv[2]);
-
-        length = m0_be_tlist_length(&list_descr, &handle->handle_rvm->ks_tlist);
-        if (length == 0) {
-                printf("Nothing to do\n");
-                fini();
-                m0_free(handle);
-                return 0;
-        }
-
-        for(i = 0; i < 10; i++) {
-                ret_obj[i]  = (struct m0_kv_store_obj *)find(obj_name);
-                M0_ASSERT(ret_obj[i] != NULL);
-
-                if (strlen(obj_name) < 255)
-                        strcat(obj_name, "a");
-                else
-                        strcpy(obj_name, "akv");
-        }
-
-        printf("List length = %ld\n", length);
-        printf("Found objects, last val= %d\n", ret_obj[9]->obj_val);
-
-        /* Delete'em */
-        if (strcmp(argv[3], "delete") == 0) {
-                for(i =0; i < 10; i++) {
-                        status = delete(ret_obj[i]);
-                        M0_ASSERT(status == BE_KV_SUCCESS);
-                }
-                printf("Deleted 10 objects!!\n");
-                length = m0_be_tlist_length(&list_descr,
-                                            &handle->handle_rvm->ks_tlist);
-                printf("List length = %ld\n", length);
-        }
-
-        fini();
-        m0_free(handle);
-        return 0;
-}
-
-/*const struct m0_test_suite be_kvs_ut = {
-        .ts_name = "be-kv-ut",
-        .ts_init = init,
-        .ts_fini = fini,
-        .ts_tests = {
-                { "insert", insert },
-                { "find",   find },
-                { "delete", delete },
-        { NULL, NULL }
-        }
-};
-M0_EXPORTED(be_kvs_ut);
-*/
-/*
- * Local variables:
- * c-indentation-style: "K&R"
- * c-basic-offset: 8
- * tab-width: 8
- * fill-column: 80
- * scroll-step: 1
- * End:
- */
diff --git a/be/lib/ut/be_tlist.c b/be/lib/ut/be_tlist.c
deleted file mode 100644
index 7462bb7..0000000
--- a/be/lib/ut/be_tlist.c
+++ /dev/null
@@ -1,267 +0,0 @@
-/*
- * COPYRIGHT 2012 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author              : Zishan Shaikh <zishan_shaikh@xyratex.com>
- * Original creation date       : 12/12/2012
- */
-
-/**
- *             BE Tlist UT
- */
-
-/**
-  @addtogroup be_lib_ut
-  @{
-  */
-
-#include <stdio.h>
-#include <unistd.h>
-#include "be/be.h"
-#include "be/lib/be_tlist.h"
-#include "be/lib/be_helper.h"
-
-typedef struct foo {
-        int                key;
-        int                value;
-        struct m0_be_tlink linkage;
-        unsigned long int  ref_magic;
-}foo;
-
-struct m0_be_tl_descr list_descr = M0_BE_TL_DESCR("foo",
-                                                  struct foo,
-                                                  linkage,
-                                                  ref_magic,
-                                                  0xab5ce55edba1b0a0,
-                                                  0xba1dba11adba0bab);
-
-struct m0_be_tl         *tlist = NULL;
-struct m0_be_seg        *seg;
-struct m0_be_domain      dom;
-uint64_t                 tlist_segid;
-uint64_t                 tlist_offset;
-
-void alloc_memory_tlist_rvm()
-{
-        struct m0_be_tx         *tx = NULL;
-        struct m0_be_reg        *reg = NULL;
-        struct m0_reference     *ref = NULL;
-        struct m0_be_buf         buf;
-
-        M0_ALLOC_PTR(tx);
-        M0_ASSERT(tx != NULL);
-
-        m0_be_tx_init(tx, &dom, 0);
-        M0_BE_WAIT(tx->bt_impl.sm_group, &tx->bt_sm,
-                   (1 << M0_BETX_INIT) | (1 << M0_BETX_FAILED));
-
-        /* Prepare a region for the rvm_handle */
-        buf.b_nob = sizeof(struct m0_be_tl);
-        m0_be_reg_init(&reg, tx, seg, &buf);
-
-        m0_ks_tx_start(tx);
-
-        tlist = (struct m0_be_tl *)m0_ks_obj_malloc(reg, &ref);
-        M0_ASSERT(tlist != NULL);
-        M0_ASSERT(ref != NULL);
-
-        tlist_segid = ref->segid_offset.u_hi;
-        tlist_offset = ref->segid_offset.u_lo;
-
-        m0_be_tx_done(tx);
-        M0_BE_WAIT(tx->bt_impl.sm_group, &tx->bt_sm,
-                   (1 << M0_BETX_DONE) | (1 << M0_BETX_FAILED));
-
-        m0_be_tx_fini(tx);
-        m0_free(tx);
-}
-
-/** Displays the @tlist */
-void print_list()
-{
-       struct foo *scan;
-       m0_be_tlist_for(&list_descr, tlist, scan) {
-               printf("key = %d value = %d\n", scan->key, scan->value);
-       }m0_be_tlist_endfor;
-}
-
-/** Adds a new @obj to the tlist */
-void add_to_tlist(struct foo *obj, struct m0_reference *ref)
-{
-       m0_be_tlink_init(&list_descr, ref);
-       m0_be_tlist_add(&list_descr, tlist, obj);
-       M0_ASSERT(m0_be_tlink_is_in(&list_descr, obj));
-}
-
-/** Initialise the tlist, domain and the segment */
-void init_tlist_domain_and_segment()
-{
-        struct m0_be_list *head = NULL;
-        struct m0_uint128 *temp_head_offset = NULL;
-        struct m0_uint128 *temp_tail_offset = NULL;
-
-        /* Initializing domain and segment */
-        m0_be_domain_init(&dom, BE_DOMAIN_MAGIC);
-        dom.bd_data.bs_sm.sm_state = M0_BESEG_ACTIVE;
-
-        /*Create and Open Segment */
-        m0_be_domain_lookup(&dom, 1, &seg);
-
-        m0_sm_group_lock(seg->bs_impl.sm_group);
-        m0_sm_timedwait(&(seg->bs_sm),
-                        (1 << M0_BESEG_ACTIVE) | (1 << M0_BESEG_FAILED),
-                        M0_TIME_NEVER);
-        m0_sm_group_unlock(seg->bs_impl.sm_group);
-
-        alloc_memory_tlist_rvm();
-        m0_be_tlist_init(&list_descr, tlist);
-
-        /* Update segment id & offset in head & tail */
-        head = &(tlist->t_head);
-
-        temp_head_offset       = &(head->l_head.logical_address.segid_offset);
-        temp_head_offset->u_hi = tlist_segid;
-        temp_head_offset->u_lo = tlist_offset;
-
-        temp_tail_offset       = &(head->l_tail.logical_address.segid_offset);
-        temp_tail_offset->u_hi = tlist_segid;
-        temp_tail_offset->u_lo = tlist_offset;
-
-        head->l_head.logical_address.magic = dom.bd_magic;
-        head->l_tail.logical_address.magic = dom.bd_magic;
-}
-
-/** Allocates memory to an object and adds it to the tlist */
-void test_add_be_tlist(struct foo **new_obj, int incoming_key,
-                       int incoming_value)
-{
-        /** Be Domain Transaction */
-        struct m0_be_tx         tx;
-        struct m0_be_reg        *reg;
-        struct m0_be_buf        buf;
-
-        /** Initialise and start transaction */
-        m0_be_tx_init(&tx, &dom, 0);
-        m0_sm_group_lock(tx.bt_impl.sm_group);
-        m0_sm_timedwait(&tx.bt_sm,
-                        (1 << M0_BETX_INIT) | (1 << M0_BETX_FAILED),
-                        M0_TIME_NEVER);
-        m0_sm_group_unlock(tx.bt_impl.sm_group);
-
-        m0_be_tx_start(&tx);
-        m0_sm_group_lock(tx.bt_impl.sm_group);
-        m0_sm_timedwait(&tx.bt_sm,
-                        (1 << M0_BETX_OPEN) | (1 << M0_BETX_FAILED),
-                        M0_TIME_NEVER);
-        m0_sm_group_unlock(tx.bt_impl.sm_group);
-
-        m0_be_buf_init(&buf, NULL, sizeof(struct foo), 0, 0, 0);
-        m0_be_reg_init(&reg, &tx, seg, &buf);
-
-        m0_be_alloc(reg);
-        m0_sm_group_lock(reg->br_impl.sm_group);
-        m0_sm_timedwait(&reg->br_sm,
-                       (1 << M0_BEREG_ALLOCATED) | (1 << M0_BEREG_FAILED),
-                        M0_TIME_NEVER);
-        m0_sm_group_unlock(reg->br_impl.sm_group);
-
-        m0_be_reg_capture(reg);
-        m0_sm_group_lock(reg->br_impl.sm_group);
-        m0_sm_timedwait(&reg->br_sm,
-                       (1 << M0_BEREG_CAPTURED) | (1 << M0_BEREG_FAILED),
-                        M0_TIME_NEVER);
-        m0_sm_group_unlock(reg->br_impl.sm_group);
-
-
-        /** Allocate the memory to the object from @reg->br_buf */
-        *new_obj = (struct foo *)reg->br_buf.b_addr;
-        if (*new_obj == NULL) {
-                printf("Failed to allocate memory!!\n");
-                return;
-        }
-
-        (*new_obj)->key   = incoming_key;
-        (*new_obj)->value = incoming_value;
-
-        /** Insert in tlist */
-        printf("Adding %d:%d to tlist\n", incoming_key, incoming_value);
-        add_to_tlist(*new_obj, &reg->br_buf.logical_address);
-
-        m0_be_tx_done(&tx);
-        m0_sm_group_lock(tx.bt_impl.sm_group);
-        m0_sm_timedwait(&tx.bt_sm,
-                        (1 << M0_BETX_DONE) | (1 << M0_BETX_FAILED),
-                        M0_TIME_NEVER);
-        m0_sm_group_unlock(tx.bt_impl.sm_group);
-
-        m0_be_tx_fini(&tx);
-}
-
-int main()
-{
-        struct foo *test1 = NULL;
-        struct foo *test2 = NULL;
-        struct foo *test3 = NULL;
-        struct foo *test4 = NULL;
-
-        /* Initialisse the tlsit, domain and the segment */
-        init_tlist_domain_and_segment();
-
-        /* Add @test1, @test2, @test3 & @test4 to tlist, added to head */
-        printf("\n");
-        test_add_be_tlist(&test1, 10, 20);
-        test_add_be_tlist(&test2, 20, 30);
-        test_add_be_tlist(&test3, 30, 40);
-        test_add_be_tlist(&test4, 40, 10);
-
-        /* Check the length of the list */
-        printf("List length= %ld\n\n", m0_be_tlist_length(&list_descr, tlist));
-        printf("List contents:\n");
-        print_list();
-
-        /* Try and delete some node. Here @test1 */
-        if (m0_be_tlink_is_in(&list_descr, test1)) {
-                m0_be_tlink_del_fini(&list_descr, test1);
-                printf("\nDeleted  10:20. Now list contents:\n");
-        }
-        print_list();
-
-        /* Move @test3 to head */
-        m0_be_tlist_move(&list_descr, tlist, test3);
-        printf("\nMoved 30:40 to head Now list:- .\n");
-        print_list();
-
-        /* Move @test4 to tail */
-        m0_be_tlist_move_tail(&list_descr, tlist, test4);
-        printf("\nMoved 40:10 to tail. Now list:- \n");
-        print_list();
-
-        m0_be_seg_done(seg);
-        dom.bd_data.bs_sm.sm_state = M0_BESEG_CLOSED;
-        m0_be_domain_fini(&dom);
-
-        return 0;
-}
-
-/** @} end group be_lib_ut */
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
diff --git a/be/reg.c b/be/reg.c
index 1205852..e1d9b33 100644
--- a/be/reg.c
+++ b/be/reg.c
@@ -13,8 +13,8 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Sachin Patil <sachin_patil@xyratex.com>
- * Original creation date: 30 Nov 2012
+ * Original author              : Sachin Patil <sachin_patil@xyratex.com>
+ * Original creation date       : 11/30/2012
  */
 
 #include "be/be.h"
@@ -121,7 +121,7 @@ M0_INTERNAL void m0_be_reg_init(struct m0_be_reg *reg, struct m0_be_tx *tx,
         reg->br_seg = seg;
 
         reg->br_buf.b_nob = buf->b_nob;
-        reg->br_buf.logical_address = buf->logical_address;
+        reg->br_buf.b_logical_address = buf->b_logical_address;
 
         /* Lock sm group */
         m0_sm_group_lock(m0_be_domain_sm_group(reg->br_seg->bs_dom));
@@ -136,7 +136,7 @@ M0_INTERNAL void m0_be_reg_init(struct m0_be_reg *reg, struct m0_be_tx *tx,
 
 /**
  * Allocates a region.
- * Updates m0_reference of region that can be used to persist pointers
+ * Updates m0_be_reference of region that can be used to persist pointers
  *
  * @pre m0_be_reg_state_get(reg) == M0_BEREG_INIT
  * @pre reg->br_buf.b_addr == NULL
@@ -246,7 +246,7 @@ M0_INTERNAL void m0_be_reg_capture(struct m0_be_reg *reg)
         M0_ASSERT(sm_group != NULL);
 
         /* Locking sm group before setting sm_state if not locked */
-        if(!m0_mutex_is_locked(&sm_group->s_lock)) {
+        if (!m0_mutex_is_locked(&sm_group->s_lock)) {
                 grp_locked = 1;
                 m0_sm_group_lock(sm_group);
         }
@@ -254,7 +254,7 @@ M0_INTERNAL void m0_be_reg_capture(struct m0_be_reg *reg)
         m0_sm_state_set(&reg->br_sm, M0_BEREG_CAPTURING);
 
         /* Unlock locked sm group if locked locally */
-        if(grp_locked)
+        if (grp_locked)
                 m0_sm_group_unlock(sm_group);
 
         reg->br_sm_ast.sa_cb    = m0_be_reg_capture_cb;
@@ -294,12 +294,13 @@ M0_INTERNAL void m0_be_reg_req_post(struct m0_sm_group *sm_group,
 M0_INTERNAL void m0_be_alloc_cb(struct m0_sm_group *sm_group,
                                   struct m0_sm_ast *sm_ast)
 {
-        struct m0_be_reg *reg;
-        struct m0_uint128 *toffset;
-        rvm_tid_t *tid = NULL;
-        int             err;
-        uint64_t hi;
-        long int lo;
+        struct m0_be_reg        *reg;
+        struct m0_uint128       *toffset;
+        rvm_tid_t               *tid = NULL;
+        struct m0_be_reference  *reg_laddress;
+        int                      err;
+        uint64_t                 hi;
+        long int                 lo;
 
         /* Asserting on required pointers */
         M0_ASSERT(sm_group != NULL);
@@ -315,13 +316,13 @@ M0_INTERNAL void m0_be_alloc_cb(struct m0_sm_group *sm_group,
         reg->br_buf.b_addr = (void *)rds_malloc(reg->br_buf.b_nob,
                                                 tid, &err);
 
-
         /* Assign domain magic to reg reference magic  to identify references
          * within the domain.
          */
-        reg->br_buf.logical_address.magic = reg->br_seg->bs_dom->bd_magic;
+        reg_laddress            = &reg->br_buf.b_logical_address;
+        reg_laddress->be_magic  = reg->br_seg->bs_dom->bd_magic;
 
-        toffset = &reg->br_buf.logical_address.segid_offset;
+        toffset = &reg->br_buf.b_logical_address.be_segid_offset;
 
         hi = reg->br_seg->bs_impl.segment_id;
         lo = (reg->br_seg->bs_addr - reg->br_buf.b_addr);
@@ -346,9 +347,10 @@ M0_INTERNAL void m0_be_alloc_cb(struct m0_sm_group *sm_group,
 M0_INTERNAL void m0_be_free_cb(struct m0_sm_group *sm_group,
                                   struct m0_sm_ast *sm_ast)
 {
-        int             err;
-        rvm_tid_t      *tid = NULL;
-        struct m0_be_reg *reg;
+        int                      err;
+        rvm_tid_t               *tid = NULL;
+        struct m0_be_reg        *reg;
+        struct m0_uint128       *toffset;
 
         /* Asserting on required pointers */
         M0_ASSERT(sm_group != NULL);
@@ -370,9 +372,11 @@ M0_INTERNAL void m0_be_free_cb(struct m0_sm_group *sm_group,
         if (err != SUCCESS)
                 goto error_exit;
 
-        reg->br_buf.b_addr                              = NULL;
-        reg->br_buf.logical_address.segid_offset.u_hi   = 0;
-        reg->br_buf.logical_address.segid_offset.u_lo   = 0;
+        toffset = &reg->br_buf.b_logical_address.be_segid_offset;
+
+        reg->br_buf.b_addr  = NULL;
+        toffset->u_hi       = 0;
+        toffset->u_lo       = 0;
 
         m0_sm_state_set(&reg->br_sm, M0_BEREG_FREED);
 
@@ -437,9 +441,17 @@ M0_INTERNAL void m0_be_static_reg_init(void *start_addr)
 }
 
 M0_INTERNAL void m0_be_static_reg_capture_buf(uint64_t offset,
+                                              struct m0_be_seg *seg,
                                               struct m0_be_reg *reg,
                                               struct m0_be_tx *tx)
 {
+        struct m0_be_buf buf;
+
+        buf.b_nob = sizeof(struct m0_uint128);
+        buf.b_addr = seg->bs_static_addr + offset; 
+        
+        m0_be_reg_init(reg, NULL, seg, &buf);
+        
         m0_be_tx_add_cred(tx, reg);
 
         m0_be_tx_prep(tx);
diff --git a/be/reg.h b/be/reg.h
index 6118904..e2ed787 100644
--- a/be/reg.h
+++ b/be/reg.h
@@ -13,14 +13,14 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Sachin Patil <sachin_patil@xyratex.com>
- * Original creation date: 27 Dec 2012
+ * Original author              : Sachin Patil <sachin_patil@xyratex.com>
+ * Original creation date       : 12/27/2012
  */
 
 #pragma once
 
-#ifndef __MERO_BE_BE_REG_H__
-#define __MERO_BE_BE_REG_H__
+#ifndef __MERO_BE_REG_H__
+#define __MERO_BE_REG_H__
 
 /**
   @defgroup be (Meta-data) back-end
@@ -48,6 +48,7 @@ M0_INTERNAL void m0_be_reg_req_post(struct m0_sm_group *sm_group,
 M0_INTERNAL void m0_be_static_reg_init();
 
 M0_INTERNAL void m0_be_static_reg_capture_buf(uint64_t offset,
+                                             struct m0_be_seg *seg,
                                              struct m0_be_reg *reg,
                                              struct m0_be_tx *tx);
 
@@ -57,7 +58,7 @@ uint32_t m0_be_reg_state_get(const struct m0_be_reg *reg);
 
 /** @} end of be group */
 
-/* __MERO_BE_BE_REG_H__ */
+/* __MERO_BE_REG_H__ */
 #endif
 
 /*
diff --git a/be/seg.c b/be/seg.c
index ab1b594..25f48a1 100644
--- a/be/seg.c
+++ b/be/seg.c
@@ -13,10 +13,11 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Sachin Patil <sachin_patil@xyratex.com>
- * Original creation date: 12 Nov 2012
+ * Original author              : Sachin Patil <sachin_patil@xyratex.com>
+ * Original creation date       : 11/12/2012
  */
 
+#include "lib/memory.h"
 #include "be/be.h"
 #include "be/be_private.h"
 #include "be/seg.h"
@@ -30,9 +31,9 @@
 /**
   @addtogroup be_seg
   @{
-*/
+ */
 
-/** State machine states for backend segment */
+/** State machine states for backend segment. */
 
 static const struct m0_sm_state_descr m0_be_seg_states[] = {
         [M0_BESEG_INIT] = {
@@ -47,14 +48,6 @@ static const struct m0_sm_state_descr m0_be_seg_states[] = {
                 .sd_name      = "Creating",
                 .sd_allowed   = M0_BITS(M0_BESEG_ACTIVE, M0_BESEG_FAILED)
         },
-        /**
-         * [M0_BESEG_CREATED] = {
-                .sd_flags     = 0,
-                .sd_name      = "BE SEG CREATED",
-                .sd_allowed   = M0_BITS(M0_BESEG_OPENING, M0_BESEG_ACTIVE,
-                                        M0_BESEG_FAILED)
-         * },
-         */
 
         [M0_BESEG_OPENING] = {
                 .sd_flags     = 0,
@@ -70,7 +63,7 @@ static const struct m0_sm_state_descr m0_be_seg_states[] = {
         },
 
         [M0_BESEG_CLOSING] = {
-                .sd_flags     = 0,
+                .sd_flags     = M0_SDF_FINAL,
                 .sd_name      = "Closing",
                 .sd_allowed   = M0_BITS(M0_BESEG_CLOSED, M0_BESEG_FAILED)
         },
@@ -113,6 +106,21 @@ M0_INTERNAL void m0_be_seg_create(struct m0_be_seg *seg, struct m0_be_tx *tx,
                                   const char *name, struct m0_stob *stob)
 {
         M0_PRE(seg->bs_sm.sm_state == M0_BESEG_INIT);
+        struct m0_be_seg        *scan;
+
+        /**
+          Check for duplicate segment name.
+          If found set state to M0_BESEG_FAILED and return.
+         */
+
+        m0_tlist_for(&m0_be_seg_tl, &seg->bs_dom->bd_seg, scan) {
+                if (strcmp(name, scan->bs_impl.segment_name) == 0) {
+                        m0_sm_group_lock(m0_be_domain_sm_group(seg->bs_dom));
+                        m0_sm_state_set(&seg->bs_sm, M0_BESEG_FAILED);
+                        m0_sm_group_unlock(m0_be_domain_sm_group(seg->bs_dom));
+                        return;
+                }
+        } m0_tl_endfor;
 
         m0_sm_group_lock(m0_be_domain_sm_group(seg->bs_dom));
 
@@ -137,7 +145,7 @@ M0_INTERNAL void m0_be_seg_init(struct m0_be_seg *seg,
         M0_ASSERT(seg != NULL);
         M0_ASSERT(dom != NULL);
 
-        /* Initialise domain structure with required values */
+        /* Initialise domain structure with required values. */
         seg->bs_dom = dom;
 
         /* Hardcoded for time being. */
@@ -145,13 +153,13 @@ M0_INTERNAL void m0_be_seg_init(struct m0_be_seg *seg,
 
         /**
          * Need to make it null because it is referenced into rvm callback to
-         * decide operation status
+         * decide operation status.
          */
         seg->bs_page.bp_addr = NULL;
 
         m0_sm_group_lock(sm_group);
 
-        /* Register the state machine of the segment into sm_group */
+        /* Register the state machine of the segment into sm_group. */
         m0_sm_init(&seg->bs_sm, &seg_conf, M0_BESEG_INIT, sm_group,
                         &seg->bs_addb);
 
@@ -191,7 +199,7 @@ M0_INTERNAL void m0_be_seg_done(struct m0_be_seg *seg)
 
         m0_sm_group_unlock(m0_be_domain_sm_group(seg->bs_dom));
 
-        /* @todo - Start unmapping the segment */
+        /* @todo - Start unmapping the segment. */
 }
 
 M0_INTERNAL void m0_be_seg_fini(struct m0_be_seg *seg)
@@ -201,15 +209,17 @@ M0_INTERNAL void m0_be_seg_fini(struct m0_be_seg *seg)
         M0_PRE(M0_IN(m0_be_seg_state_get(seg), (M0_BESEG_CLOSED,
                                                 M0_BESEG_FAILED)));
 
-        /* Finalizing on state machine */
+        /* Finalizing on state machine. */
         m0_sm_fini(&seg->bs_sm);
 
-        /* Finalizing respective stob */
+        /* Finalizing respective stob. */
         m0_stob_fini(seg->bs_stob);
 
-        /* Removing entry from in memory segment list if present */
+        /* Removing entry from in memory segment list if present. */
         if (m0_be_seg_tlink_is_in(seg))
                 m0_be_seg_tlink_del_fini(seg);
+
+        m0_free(seg);
 }
 
 M0_INTERNAL void m0_be_seg_delete(struct m0_be_seg *seg, struct m0_be_tx *tx)
@@ -228,19 +238,19 @@ M0_INTERNAL void m0_be_seg_delete(struct m0_be_seg *seg, struct m0_be_tx *tx)
 
         m0_sm_group_unlock(m0_be_domain_sm_group(seg->bs_dom));
 
-        /* Removing entry from in memory in segment list if present */
-        /* todo@ Need some kind of log here if condition is false */
+        /* Removing entry from in memory in segment list if present. */
+        /* todo@ Need some kind of log here if condition is false. */
         if (m0_be_seg_tlink_is_in(seg))
                 m0_be_seg_tlink_del_fini(seg);
 
         /**
          * The following veriables are needed to remove entry from named
-         * segment
+         * segment.
          */
         segment_id = seg->bs_impl.segment_id;
         dom        = seg->bs_dom;
 
-        /* @todo - remove entry from named segment transactionally */
+        /* @todo - remove entry from named segment transactionally. */
 }
 
 M0_INTERNAL void m0_be_seg_check(struct m0_be_seg *seg, struct m0_be_tx *tx)
@@ -248,7 +258,7 @@ M0_INTERNAL void m0_be_seg_check(struct m0_be_seg *seg, struct m0_be_tx *tx)
         M0_ASSERT(seg != NULL);
         M0_ASSERT(tx != NULL);
 
-        /* @todo - not clear idea about what to do in this at the moment */
+        /* @todo - not clear idea about what to do in this at the moment. */
 }
 
 M0_INTERNAL void m0_be_seg_fail(struct m0_be_seg *seg)
@@ -275,30 +285,10 @@ M0_INTERNAL void m0_seg_req_post(struct m0_sm_group *sm_group,
 M0_INTERNAL void m0_be_seg_create_cb(struct m0_sm_group *sm_group,
                                      struct m0_sm_ast *sm_ast)
 {
-        struct m0_be_seg *seg;
-
-        M0_ASSERT(sm_group != NULL);
-        M0_ASSERT(sm_ast != NULL);
-
-        seg = (struct m0_be_seg *)sm_ast->sa_datum;
-
-        /* Generate new segment id */
-
-        /**
-        struct m0_be_named_seg_hdr *named_seg_hdr;
-        named_seg_hdr = (struct m0_be_named_seg_hdr *)
-                        seg->bs_dom->bd_data.bs_addr;
-        M0_ASSERT(NULL != named_seg_hdr);
-        seg->bs_impl.segment_id = named_seg_hdr->max_segment_index + 1;
-        */
-
-        /* Create linux stob */
-        /* @todo - Please revisit this when have better understanding
-         * of linux stob
-         */
+        struct m0_be_seg         *seg;
         struct  m0_stob_domain   *stob_dom;
         bool                      stob_directio = true;
-        struct  m0_stob_id        stob_id = {{0, seg->bs_impl.segment_id}};
+        struct  m0_stob_id        stob_id;
         int                       result;
         struct linux_stob        *lstob;
         struct linux_domain      *ldom;
@@ -311,10 +301,18 @@ M0_INTERNAL void m0_be_seg_create_cb(struct m0_sm_group *sm_group,
         long                      rds_static_len    = 0;
         long                      nlist             = RVM_NLIST;
         long                      chunk_size        = RVM_CHUNK_SIZE;
-        /* initialize stob type */
+
+        M0_ASSERT(sm_group != NULL);
+        M0_ASSERT(sm_ast != NULL);
+
+        seg                     = (struct m0_be_seg *)sm_ast->sa_datum;
+        stob_id.si_bits.u_hi    = 0;
+        stob_id.si_bits.u_lo    = seg->bs_impl.segment_id;
+
+        /* Initialize stob type. */
         m0_stob_type_init(&m0_linux_stob_type);
 
-        /* @todo - stob path is hardcoded for now */
+        /* @todo - stob path is hardcoded for now. */
         result = m0_stob_domain_locate(&m0_linux_stob_type,
                                        "./__be",
                                        &stob_dom);
@@ -335,10 +333,6 @@ M0_INTERNAL void m0_be_seg_create_cb(struct m0_sm_group *sm_group,
 
         M0_ASSERT(lstob != NULL);
 
-        /* Get fle-path for segment stob */
-        /* @note - can not use linux_stob_path as it is declared as static in
-         *  linux.[hc] */
-
         ldom = domain2linux(seg->bs_stob->so_domain);
         nbytes = snprintf(seg->bs_impl.path_name,
                           ARRAY_SIZE(seg->bs_impl.path_name),
@@ -350,11 +344,8 @@ M0_INTERNAL void m0_be_seg_create_cb(struct m0_sm_group *sm_group,
         if (nbytes < 0)
                 goto error;
 
-        /* @todo - need to handle rvm errors in callback */
-        /* create heap structure */
-        /* result = rds_zap_heap(DevName, DevLength, startAddr, staticLength,
-         *                       heapLength, nlists, chunkSize, err); */
-
+        /* @todo - need to handle rvm errors in callback. */
+        /* Create heap structure. */
         rds_static_len    = RVM_ROUND_LENGTH_DOWN_TO_PAGE_SIZE(4096);
 
         result = rds_zap_heap(seg->bs_impl.path_name,
@@ -369,11 +360,10 @@ M0_INTERNAL void m0_be_seg_create_cb(struct m0_sm_group *sm_group,
         if (result < 0)
                 goto error;
 
-        /* @todo - begin transaction */
-        /* update the named segment transactionally */
-        /* @todo - end transaction */
-        /* Assuption : create implicitely opens the segment */
-
+        /* @todo - begin transaction. */
+        /* update the named segment transactionally. */
+        /* @todo - end transaction. */
+        /* Assumption : create implicitely opens the segment. */
         result = rds_load_heap(seg->bs_impl.path_name,
                                RVM_LENGTH_TO_OFFSET(dev_length),
                                &static_addr,
@@ -388,6 +378,9 @@ M0_INTERNAL void m0_be_seg_create_cb(struct m0_sm_group *sm_group,
 
         m0_sm_state_set((&seg->bs_sm), M0_BESEG_ACTIVE);
 
+        m0_be_seg_tlink_init(seg);
+        m0_be_seg_tlist_add(&seg->bs_dom->bd_seg, seg);
+
         return;
 
 error:
@@ -396,18 +389,19 @@ error:
 
 /**
  * The function calls rvm api's to open the segment.
- *
  */
-
 M0_INTERNAL void m0_be_seg_open_cb(struct m0_sm_group *sm_group,
                                    struct m0_sm_ast *sm_ast)
 {
         int                      nbytes;
         int                      result;
-
         struct linux_stob       *lstob;
         struct linux_domain     *ldom;
         struct m0_be_seg        *seg;
+        unsigned long            dev_length = RVM_SEGMENT_SIZE;
+        int                      err;
+        char                    *static_addr = NULL;
+
 
         M0_ASSERT(sm_group != NULL);
         M0_ASSERT(sm_ast != NULL);
@@ -421,8 +415,8 @@ M0_INTERNAL void m0_be_seg_open_cb(struct m0_sm_group *sm_group,
 
         M0_ASSERT(lstob != NULL);
 
-        /* Get fle-path for segment stob */
-        /* @note - can not use linux_stob_path as its declared as static */
+        /* Get fle-path for segment stob. */
+        /* @note - can not use linux_stob_path as its declared as static. */
         ldom = domain2linux(seg->bs_stob->so_domain);
         nbytes = snprintf(seg->bs_impl.path_name,
                           ARRAY_SIZE(seg->bs_impl.path_name),
@@ -434,14 +428,8 @@ M0_INTERNAL void m0_be_seg_open_cb(struct m0_sm_group *sm_group,
         if (nbytes < 0)
                 goto error;
 
-        /* @todo - need to handle rvm errors in callback */
-        /* load heap */
-        /* rds_load_heap(*DevName, DevLength, **staticAddr, *err); */
-
-        unsigned long dev_length = RVM_SEGMENT_SIZE;
-        int  err;
-        char *static_addr = NULL;
-
+        /* @todo - need to handle rvm errors in callback. */
+        /* Load heap */
         result = rds_load_heap(seg->bs_impl.path_name,
                                RVM_LENGTH_TO_OFFSET(dev_length),
                                &static_addr,
diff --git a/be/seg.h b/be/seg.h
index 076df25..56f1b3e 100644
--- a/be/seg.h
+++ b/be/seg.h
@@ -13,14 +13,14 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Sachin Patil <sachin_patil@xyratex.com>
- * Original creation date: 26 Nov 2012
+ * Original author              : Sachin Patil <sachin_patil@xyratex.com>
+ * Original creation date       : 11/26/2012
  */
 
 #pragma once
 
-#ifndef __MERO_BE_BE_SEG_H__
-#define __MERO_BE_BE_SEG_H__
+#ifndef __MERO_BE_SEG_H__
+#define __MERO_BE_SEG_H__
 
 /**
   @defgroup be (Meta-data) back-end
@@ -29,6 +29,18 @@
 
 #include "be/be.h"
 
+/**
+ * These params will be used to call rvm API's from segment layer.
+ */
+enum BE_RVM_PARAMS {
+        RVM_HEAP_SIZE     = 100 * 1024 * 1024,
+        /** RVM_PAGE_SIZE was conflicting with RVM variable declarations. */
+        RVM_PG_SIZE       = 1024 * 4,
+        RVM_SEGMENT_SIZE  = RVM_PG_SIZE + RVM_HEAP_SIZE + RVM_PG_SIZE,
+        RVM_NLIST         = 16,
+        RVM_CHUNK_SIZE    = 64,
+};
+
 M0_INTERNAL void m0_seg_req_post(struct m0_sm_group *sm_grp,
                                  struct m0_sm_ast *sm_ast);
 
@@ -48,21 +60,9 @@ M0_INTERNAL void m0_be_seg_open_cb(struct m0_sm_group *sm_group,
  */
 M0_INTERNAL uint32_t m0_be_seg_state_get(const struct m0_be_seg *seg);
 
-/**
- * These params will be used to call rvm API's from segment layer.
- */
-enum BE_RVM_PARAMS {
-        RVM_HEAP_SIZE     = 100 * 1024 * 1024,
-        /** RVM_PAGE_SIZE was conflicting with RVM variable declarations. */
-        RVM_PG_SIZE       = 1024 * 4,
-        RVM_SEGMENT_SIZE  = RVM_PG_SIZE + RVM_HEAP_SIZE + RVM_PG_SIZE,
-        RVM_NLIST         = 16,
-        RVM_CHUNK_SIZE    = 64,
-};
-
 /** @} end of be group */
 
-/* __MERO_BE_BE_SEG_H__ */
+/* __MERO_BE_SEG_H__ */
 #endif
 
 /*
diff --git a/be/tx.c b/be/tx.c
index 7e301bf..1f42b32 100644
--- a/be/tx.c
+++ b/be/tx.c
@@ -14,7 +14,7 @@
  * http://www.xyratex.com/contact
  *
  * Original author: Prashant Dhange <prashant_dhange@xyratex.com>
- * Original creation date: 03 Dec 2012
+ * Original creation date: 12/03/2012
  */
 
 #include "be/be.h"
@@ -23,7 +23,7 @@
 #include "be/reg.h"
 #include "be/domain.h"
 
-/* State machine variable declarations  */
+/* State machine variable declarations.  */
 static const struct m0_sm_state_descr tx_states[] = {
          [M0_BETX_INITIALIZING] = {
                 .sd_flags     = M0_SDF_INITIAL,
@@ -92,40 +92,33 @@ static const struct m0_sm_conf tx_conf = {
         .scf_state     = tx_states
 };
 
-/**
- * Initialises the transaction structure.
- *
- * @pre m0_be_seg_state_get(dom->bd_data) == M0_BESEG_ACTIVE
- * @post m0_be_tx_state_get(tx) == M0_BETX_PREPARING
- * @post tx->bt_dom == dom
- */
 M0_INTERNAL void m0_be_tx_init(struct m0_be_tx *tx,
                                struct m0_be_domain *dom, uint64_t flags)
 {
-        /* Asserting on required pointers */
+        /* Asserting on required pointers. */
         M0_ASSERT(tx != NULL);
         M0_ASSERT(dom != NULL);
         M0_ASSERT(&dom->bd_impl.sm_group != NULL);
 
-        /* Initialise domain structure with required values */
+        /* Initialise domain structure with required values. */
         tx->bt_dom = dom;
 
-        /* Initialize bt_impl->bc_tl list */
+        /* Initialize bt_impl->bc_tl list. */
         m0_be_reg_tlist_init(&tx->bt_impl.bc_tl);
 
         /*
          * Locking sm_group is required before initializing sm
          * TODO@ Need to confirm with Nikita, do we need to move the state
          * transition logic to CALLBACKS. This Applies for state change
-         * accross the segments, regions, transactions
+         * accross the segments, regions, transactions.
          */
         m0_sm_group_lock(m0_be_domain_sm_group(tx->bt_dom));
 
-        /* Register the state machine of the tx into sm_group */
+        /* Register the state machine of the tx into sm_group. */
         m0_sm_init(&tx->bt_sm, &tx_conf, M0_BETX_INITIALIZING,
                    m0_be_domain_sm_group(tx->bt_dom), NULL);
 
-        /* unlock locked sm group */
+        /* Unlock locked sm group. */
         m0_sm_group_unlock(m0_be_domain_sm_group(tx->bt_dom));
 
         tx->bt_sm_ast.sa_cb    = m0_be_tx_init_cb;
@@ -134,33 +127,27 @@ M0_INTERNAL void m0_be_tx_init(struct m0_be_tx *tx,
         m0_tx_req_post(m0_be_domain_sm_group(tx->bt_dom), &tx->bt_sm_ast);
 }
 
-/**
- * Indicates that a transaction will use certain amount of resources.
- *
- * @pre m0_be_tx_state_get(tx) == M0_BETX_INIT
- *
- */
 M0_INTERNAL void m0_be_tx_prep(struct m0_be_tx *tx)
 {
         struct m0_be_reg *reg_it;
 
-        /* Asserting on required pointers */
+        /* Asserting on required pointers. */
         M0_ASSERT(tx != NULL);
 
-        /* Is m0_be_tx_state_get(tx) in M0_BETX_INIT state */
+        /* Is m0_be_tx_state_get(tx) in M0_BETX_INIT state. */
         M0_PRE(m0_be_tx_state_get(tx) == M0_BETX_INIT);
 
-        /* Iterate credit list of regions */
+        /* Iterate credit list of regions. */
         m0_tlist_for(&m0_be_reg_tl, &tx->bt_impl.bc_tl, reg_it) {
 
-                /* check reg_it->br_sm.sm_state for region state */
+                /* Check reg_it->br_sm.sm_state for region state. */
 
                 if (!M0_IN(m0_be_reg_state_get(reg_it), (M0_BEREG_INIT, 
                                                          M0_BEREG_ALLOCATED))) {
 
                         m0_be_sm_state_change(m0_be_domain_sm_group(tx->bt_dom),
                                               &tx->bt_sm, M0_BETX_FAILED);
-                        /* TODO@ add error log message */
+                        /* TODO@ add error log message. */
                         goto exit_error;
                 }
 
@@ -182,13 +169,6 @@ exit:
         return;
 }
 
-/**
- * Starts a prepared transaction.
- *
- * @pre m0_be_tx_state_get(tx) == M0_BETX_PREPARING
- * @post M0_IN(m0_be_tx_state_get(tx), (M0_BETX_PREPARED, M0_BETX_OPEN,
- *                                      M0_BETX_FAILED))
- */
 M0_INTERNAL void m0_be_tx_start(struct m0_be_tx *tx)
 {
 
@@ -196,7 +176,7 @@ M0_INTERNAL void m0_be_tx_start(struct m0_be_tx *tx)
 
         /*
          * Added M0_IN support to call start when theres nothing in
-         * credit list i.e. without calling tx_prep
+         * credit list i.e. without calling tx_prep.
          */
         M0_IN(m0_be_tx_state_get(tx), (M0_BETX_PREPARED, M0_BETX_PREPARING));
 
@@ -206,16 +186,9 @@ M0_INTERNAL void m0_be_tx_start(struct m0_be_tx *tx)
         m0_tx_req_post(m0_be_domain_sm_group(tx->bt_dom), &tx->bt_sm_ast);
 }
 
-/**
- * Closes a transaction.
- *
- * @pre m0_be_tx_state_get(tx) == M0_BETX_OPEN
- * @post M0_IN(m0_be_tx_state_get(tx), (M0_BETX_CLOSED, M0_BETX_COMMITTED,
- *                                      M0_BETX_DONE, M0_BETX_FAILED))
- */
 M0_INTERNAL void m0_be_tx_done(struct m0_be_tx *tx)
 {
-        /* Asserting on required pointers */
+        /* Asserting on required pointers. */
         M0_ASSERT(tx != NULL);
 
         M0_PRE(m0_be_tx_state_get(tx) == M0_BETX_OPEN);
@@ -226,24 +199,19 @@ M0_INTERNAL void m0_be_tx_done(struct m0_be_tx *tx)
         m0_tx_req_post(m0_be_domain_sm_group(tx->bt_dom), &tx->bt_sm_ast);
 }
 
-/**
- * Finalises transaction structure.
- *
- * @pre M0_IN(m0_be_tx_state_get(tx), (M0_BETX_DONE, M0_BETX_FAILED))
- */
 M0_INTERNAL void m0_be_tx_fini(struct m0_be_tx *tx)
 {
         struct m0_be_reg *reg_it;
 
-        /* Asserting on required pointers */
+        /* Asserting on required pointers. */
         M0_ASSERT(tx != NULL);
 
         M0_PRE(M0_IN(m0_be_tx_state_get(tx), (M0_BETX_DONE, M0_BETX_FAILED)));
 
         rvm_free_tid(tx->bt_impl.tx_id);
 
-         /* Removing entries from reg list if present */
-         /* Iterate credit list of regions */
+         /* Removing entries from reg list if present. */
+         /* Iterate credit list of regions. */
          m0_tlist_for(&m0_be_reg_tl, &tx->bt_impl.bc_tl, reg_it) {
                 if (m0_be_reg_tlink_is_in(reg_it)) {
                          m0_be_reg_tlink_del_fini(reg_it);
@@ -252,22 +220,22 @@ M0_INTERNAL void m0_be_tx_fini(struct m0_be_tx *tx)
                 }
          } m0_tlist_endfor;
 
-        /* Finalise bt_impl->bc_tl list */
+        /* Finalise bt_impl->bc_tl list. */
         m0_be_reg_tlist_fini(&tx->bt_impl.bc_tl);
 
         m0_be_sm_state_change(m0_be_domain_sm_group(tx->bt_dom),
                               &tx->bt_sm, M0_BETX_CLOSED);
 
-        /* Remove entry from in memory active transaction list if present */
+        /* Remove entry from in memory active transaction list if present. */
         if (m0_be_tx_tlink_is_in(tx))
                 m0_be_tx_tlink_del_fini(tx);
 
-        /* Finalizing on state machine */
+        /* Finalizing on state machine. */
         m0_sm_fini(&tx->bt_sm);
 }
 
-/*
- *    m0_be_tx_init callback function
+/**
+ *    m0_be_tx_init callback function.
  */
 M0_INTERNAL void m0_be_tx_init_cb(struct m0_sm_group *sm_group,
                                   struct m0_sm_ast *sm_ast)
@@ -276,7 +244,7 @@ M0_INTERNAL void m0_be_tx_init_cb(struct m0_sm_group *sm_group,
         rvm_return_t             ret;
         rvm_tid_t               *tid;
 
-        /* Asserting on required pointers */
+        /* Asserting on required pointers. */
         M0_ASSERT(sm_group != NULL);
         M0_ASSERT(sm_ast != NULL);
 
@@ -286,7 +254,7 @@ M0_INTERNAL void m0_be_tx_init_cb(struct m0_sm_group *sm_group,
         tid = rvm_malloc_tid();
 
         if (tid == NULL) {
-                /* TODO@ add error log message */
+                /* TODO@ add error log message. */
                 goto exit_alloc;
         }
 
@@ -295,7 +263,7 @@ M0_INTERNAL void m0_be_tx_init_cb(struct m0_sm_group *sm_group,
         ret = rvm_begin_transaction(tx->bt_impl.tx_id, restore);
 
         if (RVM_SUCCESS != ret) {
-                /* TODO@ add error log message */
+                /* TODO@ add error log message. */
                 goto exit_begin_tx;
         }
         m0_sm_state_set(&tx->bt_sm, M0_BETX_INIT);
@@ -309,8 +277,8 @@ exit:
         return;
 }
 
-/*
- * m0_be_tx_prep callback function
+/**
+ * m0_be_tx_prep callback function.
  */
 M0_INTERNAL void m0_be_tx_prep_cb(struct m0_sm_group *sm_group,
                                   struct m0_sm_ast *sm_ast)
@@ -318,7 +286,7 @@ M0_INTERNAL void m0_be_tx_prep_cb(struct m0_sm_group *sm_group,
         struct m0_be_tx         *tx;
         struct m0_be_reg        *reg_it;
 
-        /* Asserting on required pointers */
+        /* Asserting on required pointers. */
         M0_ASSERT(sm_group != NULL);
         M0_ASSERT(sm_ast != NULL);
 
@@ -326,16 +294,16 @@ M0_INTERNAL void m0_be_tx_prep_cb(struct m0_sm_group *sm_group,
 
         M0_ASSERT(tx != NULL);
 
-        /* Iterate credit list of regions */
+        /* Iterate credit list of regions. */
         m0_tlist_for(&m0_be_reg_tl, &tx->bt_impl.bc_tl, reg_it) {
-                /* Assumption: reg_it->br_tx will be updated to tx */
+                /* Assumption: reg_it->br_tx will be updated to tx. */
                 reg_it->br_tx = tx;
                 reg_it->br_tx_cbdata.datum = (void *)tx;
 
-                /*
-                * Capture region function which changes
-                * the region state to InProgress
-                */
+                /**
+                 * Capture region function which changes
+                 * the region state to InProgress.
+                 */
                 m0_be_reg_capture(reg_it);
 
         } m0_tlist_endfor;
@@ -343,21 +311,21 @@ M0_INTERNAL void m0_be_tx_prep_cb(struct m0_sm_group *sm_group,
         return;
 }
 
-/*
- *    m0_be_tx_start callback function
+/**
+ *  m0_be_tx_start callback function.
  */
 M0_INTERNAL void m0_be_tx_start_cb(struct m0_sm_group *sm_group,
                                    struct m0_sm_ast *sm_ast)
 {
         struct m0_be_tx         *tx;
 
-        /* Asserting on required pointers */
+        /* Asserting on required pointers. */
         M0_ASSERT(sm_group != NULL);
         M0_ASSERT(sm_ast != NULL);
 
         tx = (struct m0_be_tx *) sm_ast->sa_datum;
 
-        /* Add this transaction to domain's active transaction list */
+        /* Add this transaction to domain's active transaction list. */
         m0_be_tx_tlink_init(tx);
 
         m0_be_tx_tlist_add(&tx->bt_dom->bd_tx, tx);
@@ -365,8 +333,8 @@ M0_INTERNAL void m0_be_tx_start_cb(struct m0_sm_group *sm_group,
         m0_sm_state_set(&tx->bt_sm, M0_BETX_OPEN);
 }
 
-/*
- *    m0_be_tx_done callback function
+/**
+ *  m0_be_tx_done callback function.
  */
 M0_INTERNAL void m0_be_tx_done_cb(struct m0_sm_group *sm_group,
                                   struct m0_sm_ast *sm_ast)
@@ -375,7 +343,7 @@ M0_INTERNAL void m0_be_tx_done_cb(struct m0_sm_group *sm_group,
         struct m0_be_reg        *reg_it;
         rvm_return_t ret;
 
-        /* Asserting on required pointers */
+        /* Asserting on required pointers. */
         M0_ASSERT(sm_group != NULL);
         M0_ASSERT(sm_ast != NULL);
 
@@ -384,14 +352,14 @@ M0_INTERNAL void m0_be_tx_done_cb(struct m0_sm_group *sm_group,
         ret = rvm_end_transaction(tx->bt_impl.tx_id, flush);
 
         if (RVM_SUCCESS != ret) {
-                /* TODO@ add error log message */
+                /* TODO@ add error log message. */
                 goto exit_end_tx;
         }
 
-        /* Iterate credit list of regions */
+        /* Iterate credit list of regions. */
         m0_tlist_for(&m0_be_reg_tl, &tx->bt_impl.bc_tl, reg_it) {
-                /* Mark all regions for completion */
-                /* TODO@ need to call function m0_sm_state_set() */
+                /* Mark all regions for completion. */
+                /* TODO@ need to call function m0_sm_state_set(). */
                 m0_sm_state_set(&reg_it->br_sm, M0_BEREG_DONE);
         } m0_tlist_endfor;
 
@@ -408,19 +376,18 @@ exit:
 M0_INTERNAL void m0_be_tx_add_cred(struct m0_be_tx *tx,
                                    struct m0_be_reg *reg)
 {
-        /* Asserting on required pointers */
+        /* Asserting on required pointers. */
         M0_ASSERT(tx != NULL);
         M0_ASSERT(reg != NULL);
 
-        /* Add reg to credit list, default would be add to tail */
+        /* Add reg to credit list, default would be add to tail. */
         m0_be_reg_tlink_init(reg);
 
         m0_be_reg_tlist_add_tail(&tx->bt_impl.bc_tl, reg);
 }
 
 /**
- * The function posts tx request to state machine thread
- *
+ * The function posts tx request to state machine thread.
  */
 M0_INTERNAL void m0_tx_req_post(struct m0_sm_group *sm_group,
                                 struct m0_sm_ast *sm_ast)
@@ -442,7 +409,7 @@ M0_INTERNAL int m0_be_tx_get_capture_status(void * data)
 
         /* Iterate credit list to check the capture status for each region. */
         m0_tlist_for(&m0_be_reg_tl, &tx->bt_impl.bc_tl, reg_it) {
-                /* check reg_it->br_sm.sm_state for region state */
+                /* Check reg_it->br_sm.sm_state for region state. */
 
                 if (m0_be_reg_state_get(reg_it) == M0_BEREG_FAILED) {
                         result = M0_BETX_PREP_FAILED;
@@ -469,13 +436,13 @@ M0_INTERNAL void m0_be_tx_set_capture_status(void * data)
 
         /* Iterate credit list to check the capture status for each region. */
         m0_tlist_for(&m0_be_reg_tl, &tx->bt_impl.bc_tl, reg_it) {
-                /* check if region capture is in prorgess */
+                /* Check if region capture is in prorgess. */
                 if (m0_be_reg_state_get(reg_it) == M0_BEREG_CAPTURING) {
                         capturing_res = true;
                         break;
                 }
 
-                /* check if region capture is failed */
+                /* Check if region capture is failed. */
                 if (m0_be_reg_state_get(reg_it) == M0_BEREG_FAILED) {
                         failed_res = true;
                 }
diff --git a/be/tx.h b/be/tx.h
index 12ec28d..5191c38 100644
--- a/be/tx.h
+++ b/be/tx.h
@@ -14,18 +14,18 @@
  * http://www.xyratex.com/contact
  *
  * Original author: Prashant Dhange <prashant_dhange@xyratex.com>
- * Original creation date: 10 Dec 2012
+ * Original creation date: 12/10/2012
  */
 
 #pragma once
 
-#ifndef __MERO_BE_BE_TX_H__
-#define __MERO_BE_BE_TX_H__
+#ifndef __MERO_BE_TX_H__
+#define __MERO_BE_TX_H__
 
 /**
   @defgroup be (Meta-data) back-end
   @{
-  */
+ */
 #include "be/be.h"
 
 enum m0_be_tx_prep_state {
@@ -58,7 +58,7 @@ M0_INTERNAL void m0_be_tx_set_capture_status(void * data);
 uint32_t m0_be_tx_state_get(const struct m0_be_tx *tx);
 /** @} end of be group */
 
-/* __MERO_BE_BE_TX_H__ */
+/* __MERO_BE_TX_H__ */
 #endif
 
 /*
diff --git a/be/ut/Makefile b/be/ut/Makefile
deleted file mode 100644
index 1b45755..0000000
--- a/be/ut/Makefile
+++ /dev/null
@@ -1,10 +0,0 @@
-.PHONY:all
-
-all:
-	gcc .libs/ut_libmero_ut_la-be.o  ../../mero/.libs/libmero.a  -o ./be  -lpthread  -ldb  -lrt -laio -lrvm -lrds -lseg -L../../../rvm/rvm/.libs -L../../../rvm/rds/.libs -L../../../rvm/seg/.libs
-	#gcc .libs/ut_libmero_ut_la-handle_store.o  ../../mero/.libs/libmero.a -o ./handle_store -lpthread -ldb -lrt -laio -lrvm -lrds -lseg -L../../../rvm/rvm/.libs -L../../../rvm/rds/.libs -L../../../rvm/seg/.libs
-	rm -rf /tmp/log_file
-
-clean:
-	rm -rf ./be
-	rm -rf ./handle_store
diff --git a/be/ut/Makefile.sub b/be/ut/Makefile.sub
index 6c4175e..4f6cff3 100644
--- a/be/ut/Makefile.sub
+++ b/be/ut/Makefile.sub
@@ -1,2 +1,4 @@
-ut_libmero_ut_la_SOURCES += be/ut/be.c \
-			    be/ut/handle_store.c
+ut_libmero_ut_la_SOURCES += be/ut/be.c		 \
+			    be/ut/handle_store.c \
+			    be/ut/be_tlist.c	 \
+			    be/ut/kv_store.c
diff --git a/be/ut/be.c b/be/ut/be.c
index 0b0a088..69a7de8 100644
--- a/be/ut/be.c
+++ b/be/ut/be.c
@@ -13,8 +13,8 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Sachin Patil <sachin_patil@xyratex.com>
- * Original creation date: 28 Nov 2012
+ * Original author              : Sachin Patil <sachin_patil@xyratex.com>
+ * Original creation date       : 11/28/2012
  */
 
 /**
@@ -30,32 +30,52 @@
   */
 
 #include <stdio.h>
+#include <stdlib.h>
 #include <unistd.h>
+#include "mero/magic.h"
+#include "sm/sm.h"
+#include "lib/ut.h"
+#include "lib/memory.h"
 
 #include "be/be.h"
 #include "be/domain.h"
+#include "be/seg.h"
 #include "be/tx.h"
 
-#include "mero/magic.h"
-#include "sm/sm.h"
-#include "lib/memory.h"
+static struct m0_be_seg        *seg;
+static struct m0_be_domain      dom;
+static struct m0_be_reg         reg;
+static struct m0_be_tx          tx;
+static struct m0_sm_group      *sm_group;
+static struct m0_be_buf         buf;
 
-struct m0_be_seg *seg;
-struct m0_be_domain dom;
-struct m0_be_reg reg;
-struct m0_be_tx tx;
+char be_cmd[1024];
+static const char      *stob_dir  = "./__be/o";
+static const char      *stob_file = "0000000000000000.0000000000000001";
+extern const char      *log_file;
 
-int main()
+static int ts_be_init(void)   /* ts_ for "test suite" */
 {
-        /** Be Domain Transaction */
-        struct m0_sm_group *sm_group;
-        struct m0_be_buf buf;
+        int rc = 0;
         int result;
 
-        /* Initializing domain */
-        printf("\n\tBackend UT\n");
+
+        sprintf(be_cmd, "rm -rf %s", log_file);
+        rc = system(be_cmd);
+        M0_ASSERT(rc == 0);
+
+        sprintf(be_cmd, "mkdir -p %s", stob_dir);
+        rc = system(be_cmd);
+        M0_ASSERT(rc == 0);
+
+        sprintf(be_cmd,
+                "dd if=/dev/zero of=%s/%s bs=1024 count=102408 2>/dev/null",
+                stob_dir, stob_file);
+        rc = system(be_cmd);
+        M0_ASSERT(rc == 0);
+
+        /* Initializing domain. */
         m0_be_domain_init(&dom, NULL, NULL, M0_BE_DOMAIN_MAGIC);
-        printf("\nDomain is initialized\n");
 
         /**
          * This is just done to work other part of the code.
@@ -70,10 +90,8 @@ int main()
         m0_sm_group_unlock(sm_group);
 
         result = m0_be_domain_lookup(&dom, "first", &seg);
-        printf("\nDomain Lookup Result : %d\n", result);
 
         if(result != 0) {
-                printf("\nCreating Segment\n");
                 M0_ALLOC_PTR(seg);
                 m0_be_seg_init(seg, &dom, sm_group, 0);
                 m0_be_seg_create(seg, NULL,  "first", NULL);
@@ -85,16 +103,34 @@ int main()
                         M0_TIME_NEVER);
         m0_sm_group_unlock(sm_group);
 
-        if (M0_BESEG_FAILED == seg->bs_sm.sm_state) {
-                printf("\nFailed to create segment \n");
-                return -1;
+        if (m0_be_seg_state_get(seg) == M0_BESEG_FAILED) {
+                rc = -1;
         }
 
-        printf("\nSegment is created and opened\n");
+        return rc;
+}
+
+static int ts_be_fini(void)
+{
+        int rc = 0;
+
+        rvm_truncate();
+        m0_be_seg_done(seg);
+        m0_sm_group_lock(sm_group);
+        m0_sm_state_set(&dom.bd_data.bs_sm, M0_BESEG_CLOSED);
+        m0_sm_group_unlock(sm_group);
+        m0_be_domain_fini(&dom);
+
+        sprintf(be_cmd, "rm -rf %s", stob_dir);
+        rc = system(be_cmd);
+        M0_ASSERT(rc == 0);
 
-        printf("\ndata_file_path : %s\n", seg->bs_impl.path_name);
+        return rc;
+}
 
-        /* Transaction list initialization */
+static void test_be_transaction()
+{
+        /* Transaction list initialization. */
         m0_be_tx_init(&tx, &dom, 0);
 
         m0_sm_group_lock(sm_group);
@@ -102,63 +138,38 @@ int main()
                         (1 << M0_BETX_INIT) | (1 << M0_BETX_FAILED),
                         M0_TIME_NEVER);
         m0_sm_group_unlock(sm_group);
-        printf("\nTx is initiated\n");
 
-
-        /*m0_be_buf_init(&buf, NULL, 1024, 0, 0, 0); */
         buf.b_nob = 1024;
         m0_be_reg_init(&reg, NULL, seg, &buf);
-        printf("reg_state[%d]\n", reg.br_sm.sm_state);
         m0_be_alloc(&reg);
 
-        printf("\nReg is allocating\n");
         m0_sm_group_lock(sm_group);
         m0_sm_timedwait(&reg.br_sm,
                         (1 << M0_BEREG_ALLOCATED) | (1 << M0_BEREG_FAILED),
                          M0_TIME_NEVER);
 
         m0_sm_group_unlock(sm_group);
-        printf("\nReg is allocated\n");
-
-        printf("\nsegment_id : %ld segment_offset : %ld\n",
-                        reg.br_buf.logical_address.segid_offset.u_hi,
-                        reg.br_buf.logical_address.segid_offset.u_lo);
-
 
         m0_be_tx_add_cred(&tx, &reg);
 
-        printf("reg_state[%d]\n", reg.br_sm.sm_state);
         m0_be_tx_prep(&tx);
 
-        printf("\nTx is Preparing\n");
         m0_sm_group_lock(sm_group);
         m0_sm_timedwait(&tx.bt_sm,
                         (1 << M0_BETX_PREPARED) | (1 << M0_BETX_FAILED),
                         M0_TIME_NEVER);
         m0_sm_group_unlock(sm_group);
-        printf("\nTx is Prepared\n");
 
-        printf("\nTx is Opening\n");
         m0_be_tx_start(&tx);
         m0_sm_group_lock(sm_group);
         m0_sm_timedwait(&tx.bt_sm,
                         (1 << M0_BETX_OPEN) | (1 << M0_BETX_FAILED),
                         M0_TIME_NEVER);
         m0_sm_group_unlock(sm_group);
-        printf("\nTx Opened\n");
-
-        strcpy(reg.br_buf.logical_address.virtual_address, "VIRTUAL WORLD");
-        printf("\ndata : [%s]\n",
-                        (char *)reg.br_buf.logical_address.virtual_address);
-
-        printf("\nsegment_id : %ld segment_offset : %ld\n",
-                        reg.br_buf.logical_address.segid_offset.u_hi,
-                        reg.br_buf.logical_address.segid_offset.u_lo);
 
-        printf("\nvirtual_addr : %p\n",
-                        reg.br_buf.logical_address.virtual_address);
+        strcpy(reg.br_buf.b_logical_address.be_virtual_address,
+               "Be UT - VIRTUAL WORLD");
 
-        strcpy(reg.br_buf.logical_address.virtual_address, "START --> END");
         m0_be_tx_done(&tx);
         m0_sm_group_lock(sm_group);
         m0_sm_timedwait(&tx.bt_sm,
@@ -166,24 +177,19 @@ int main()
                         M0_TIME_NEVER);
         m0_sm_group_unlock(sm_group);
 
-        printf("\ndata : [%s]\n",
-                        (char *)reg.br_buf.logical_address.virtual_address);
-
-        rvm_truncate();
-
         m0_be_tx_fini(&tx);
-
-        m0_be_seg_done(seg);
-        dom.bd_data.bs_sm.sm_state = M0_BESEG_CLOSED;
-        m0_be_domain_fini(&dom);
-
-        printf("\nExiting from Backend UT\n");
-
-        printf("\n");
-
-        return 0;
 }
 
+const struct m0_test_suite be_ut = {
+        .ts_name = "be-ut",
+        .ts_init = ts_be_init,
+        .ts_fini = ts_be_fini,
+        .ts_tests = {
+                { "be-transaction", test_be_transaction },
+                { NULL, NULL },
+        }
+};
+
 /** @} end group be_ut */
 
 /*
diff --git a/be/ut/be_tlist.c b/be/ut/be_tlist.c
new file mode 100644
index 0000000..d611f09
--- /dev/null
+++ b/be/ut/be_tlist.c
@@ -0,0 +1,346 @@
+/*
+ * COPYRIGHT 2012 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author              : Zishan Shaikh <zishan_shaikh@xyratex.com>
+ * Original creation date       : 12/12/2012
+ */
+
+/**
+ *             BE Tlist UT
+ */
+
+/**
+  @addtogroup be_ut
+  @{
+  */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include "lib/ut.h"
+#include "be/be.h"
+#include "be/be_tlist.h"
+#include "be/helper.h"
+
+typedef struct foo {
+        int                key;
+        int                value;
+        struct m0_be_tlink linkage;
+        unsigned long int  ref_magic;
+}foo;
+
+struct m0_be_tl_descr list_descr = M0_BE_TL_DESCR("foo",
+                                                  struct foo,
+                                                  linkage,
+                                                  ref_magic,
+                                                  0xab5ce55edba1b0a0,
+                                                  0xba1dba11adba0bab);
+
+struct m0_be_tl         *tlist;
+struct m0_be_seg        *seg;
+struct foo              *test1;
+struct foo              *test2;
+struct foo              *test3;
+struct foo              *test4;
+struct m0_be_domain      dom;
+uint64_t                 tlist_segid;
+uint64_t                 tlist_offset;
+char                     cmd[1024];
+
+static const char      *stob_dir  = "./__be/o";
+static const char      *stob_file = "0000000000000000.0000000000000001";
+extern const char      *log_file;
+
+/** Allocates and stores the tlist on RVM. */
+void alloc_memory_tlist_rvm()
+{
+        struct m0_be_tx         *tx;
+        struct m0_be_reg        *reg;
+        struct m0_be_reference  *ref;
+        struct m0_be_buf         buf;
+
+        M0_ALLOC_PTR(tx);
+        M0_ASSERT(tx != NULL);
+
+        M0_ALLOC_PTR(reg);
+        M0_ASSERT(reg != NULL);
+
+        m0_be_tx_init(tx, &dom, 0);
+        m0_be_wait(m0_be_domain_sm_group(tx->bt_dom), &tx->bt_sm,
+                   M0_BITS(M0_BETX_INIT, M0_BETX_FAILED));
+
+        /** Prepare a region for the rvm_handle. */
+        buf.b_nob = sizeof(struct m0_be_tl);
+        m0_be_reg_init(reg, tx, seg, &buf);
+
+        m0_be_ks_tx_start(tx);
+
+        tlist = (struct m0_be_tl *)m0_be_ks_obj_malloc(reg, &ref);
+        M0_ASSERT(tlist != NULL);
+        M0_ASSERT(ref != NULL);
+
+        tlist_segid = ref->be_segid_offset.u_hi;
+        tlist_offset = ref->be_segid_offset.u_lo;
+
+        m0_be_tx_done(tx);
+        m0_be_wait(m0_be_domain_sm_group(tx->bt_dom), &tx->bt_sm,
+                   M0_BITS(M0_BETX_DONE, M0_BETX_FAILED));
+
+        m0_be_tx_fini(tx);
+        m0_free(tx);
+}
+
+/** Adds a new @obj to the tlist. */
+void add_to_tlist(struct foo *obj, struct m0_be_reference *ref)
+{
+       m0_be_tlink_init(&list_descr, ref);
+       m0_be_tlist_add(&list_descr, tlist, obj);
+       M0_ASSERT(m0_be_tlink_is_in(&list_descr, obj));
+}
+
+/** Initialise the tlist, domain and the segment. */
+static int ts_be_tlist_init(void)
+{
+        struct m0_be_reference_ll *head;
+        struct m0_be_reference_ll *tail;
+        struct m0_uint128         *temp_head_offset;
+        struct m0_uint128         *temp_tail_offset;
+        struct m0_sm_group        *sm_group;
+        int                        ret_dom;
+        int                        rc = 0;
+
+        sprintf(cmd, "rm -rf %s", log_file);
+        rc = system(cmd);
+        M0_ASSERT(rc == 0);
+
+        sprintf(cmd, "mkdir -p %s", stob_dir);
+        rc = system(cmd);
+        M0_ASSERT(rc == 0);
+
+        sprintf(cmd,
+                "dd if=/dev/zero of=%s/%s bs=1024 count=102408 2>/dev/null",
+                stob_dir, stob_file);
+        rc = system(cmd);
+        M0_ASSERT(rc == 0);
+
+        /** Initializing domain and segment. */
+        m0_be_domain_init(&dom, NULL, NULL, M0_BE_DOMAIN_MAGIC);
+        dom.bd_data.bs_sm.sm_state = M0_BESEG_ACTIVE;
+
+        /** Create and Open Segment. */
+        sm_group = m0_be_domain_sm_group(&dom);
+        ret_dom = m0_be_domain_lookup(&dom, "first", &seg);
+
+        if (ret_dom !=0) {
+                M0_ALLOC_PTR(seg);
+                M0_ASSERT(seg != NULL);
+
+                m0_be_seg_init(seg, &dom, sm_group, 0);
+                m0_be_seg_create(seg, NULL,  "first", NULL);
+                m0_be_wait(sm_group, &seg->bs_sm,
+                           M0_BITS(M0_BESEG_ACTIVE, M0_BESEG_FAILED));
+        }
+
+        m0_sm_group_lock(m0_be_domain_sm_group(seg->bs_dom));
+        m0_sm_timedwait(&(seg->bs_sm),
+                        (1 << M0_BESEG_ACTIVE) | (1 << M0_BESEG_FAILED),
+                        M0_TIME_NEVER);
+        m0_sm_group_unlock(m0_be_domain_sm_group(seg->bs_dom));
+
+        alloc_memory_tlist_rvm();
+        m0_be_tlist_init(&list_descr, tlist);
+
+        /** Update segment id & offset in head & tail. */
+        head = &(tlist->t_head.l_head);
+        tail = &(tlist->t_head.l_tail);
+
+        temp_head_offset       = &(head->n_logical_address.be_segid_offset);
+        temp_head_offset->u_hi = tlist_segid;
+        temp_head_offset->u_lo = tlist_offset;
+
+        temp_tail_offset       = &(tail->n_logical_address.be_segid_offset);
+        temp_tail_offset->u_hi = tlist_segid;
+        temp_tail_offset->u_lo = tlist_offset;
+
+        head->n_logical_address.be_magic = dom.bd_magic;
+        tail->n_logical_address.be_magic = dom.bd_magic;
+
+        return rc;
+}
+
+/** Allocates memory to an object and adds it to the tlist. */
+void test_add_be_tlist(struct foo **new_obj, int incoming_key,
+                       int incoming_value)
+{
+        struct m0_be_tx         tx;
+        struct m0_be_buf        buf;
+        struct m0_be_reg       *reg;
+
+        M0_ALLOC_PTR(reg);
+        M0_ASSERT(reg != NULL);
+
+        /** Initialise and start transaction */
+        m0_be_tx_init(&tx, &dom, 0);
+        m0_sm_group_lock(m0_be_domain_sm_group(tx.bt_dom));
+        m0_sm_timedwait(&tx.bt_sm,
+                        (1 << M0_BETX_INIT) | (1 << M0_BETX_FAILED),
+                        M0_TIME_NEVER);
+        m0_sm_group_unlock(m0_be_domain_sm_group(tx.bt_dom));
+
+        m0_be_tx_start(&tx);
+        m0_sm_group_lock(m0_be_domain_sm_group(tx.bt_dom));
+        m0_sm_timedwait(&tx.bt_sm,
+                        (1 << M0_BETX_OPEN) | (1 << M0_BETX_FAILED),
+                        M0_TIME_NEVER);
+        m0_sm_group_unlock(m0_be_domain_sm_group(tx.bt_dom));
+
+        /** Initialise a region for this object. */
+        m0_be_buf_init(&buf, NULL, sizeof(struct foo), 0, 0, 0);
+        m0_be_reg_init(reg, &tx, seg, &buf);
+
+        /** Allocate memory on RVM. */
+        m0_be_alloc(reg);
+        m0_sm_group_lock(m0_be_domain_sm_group(reg->br_seg->bs_dom));
+        m0_sm_timedwait(&reg->br_sm,
+                       (1 << M0_BEREG_ALLOCATED) | (1 << M0_BEREG_FAILED),
+                        M0_TIME_NEVER);
+        m0_sm_group_unlock(m0_be_domain_sm_group(reg->br_seg->bs_dom));
+
+        /** Capture this region. */
+        m0_be_reg_capture(reg);
+        m0_sm_group_lock(m0_be_domain_sm_group(reg->br_seg->bs_dom));
+        m0_sm_timedwait(&reg->br_sm,
+                       (1 << M0_BEREG_CAPTURED) | (1 << M0_BEREG_FAILED),
+                        M0_TIME_NEVER);
+        m0_sm_group_unlock(m0_be_domain_sm_group(reg->br_seg->bs_dom));
+
+
+        /** Point the memory to the object from @reg->br_buf. */
+        *new_obj = (struct foo *)reg->br_buf.b_addr;
+        if (*new_obj == NULL) {
+                return;
+        }
+
+        (*new_obj)->key   = incoming_key;
+        (*new_obj)->value = incoming_value;
+
+        /** Insert in tlist. */
+        add_to_tlist(*new_obj, &reg->br_buf.b_logical_address);
+
+        m0_be_tx_done(&tx);
+        m0_sm_group_lock(m0_be_domain_sm_group(tx.bt_dom));
+        m0_sm_timedwait(&tx.bt_sm,
+                        (1 << M0_BETX_DONE) | (1 << M0_BETX_FAILED),
+                        M0_TIME_NEVER);
+        m0_sm_group_unlock(m0_be_domain_sm_group(tx.bt_dom));
+
+        m0_be_tx_fini(&tx);
+}
+
+
+void test_move_del_be_tlist()
+{
+        /** Move @test3 to head. */
+        m0_be_tlist_move(&list_descr, tlist, test3);
+
+        /** Move @test4 to tail. */
+        m0_be_tlist_move_tail(&list_descr, tlist, test4);
+
+        M0_ASSERT(m0_be_tlist_length(&list_descr, tlist) == 4);
+
+        /** Try and delete some node. Here @test1. */
+        if (m0_be_tlink_is_in(&list_descr, test1)) {
+                m0_be_tlink_del_fini(&list_descr, test1);
+        }
+        M0_ASSERT(!m0_be_tlink_is_in(&list_descr, test1));
+        M0_ASSERT(m0_be_tlist_length(&list_descr, tlist) == 3);
+
+        if (m0_be_tlink_is_in(&list_descr, test2)) {
+                m0_be_tlink_del_fini(&list_descr, test2);
+        }
+        M0_ASSERT(!m0_be_tlink_is_in(&list_descr, test2));
+        M0_ASSERT(m0_be_tlist_length(&list_descr, tlist) == 2);
+
+        if (m0_be_tlink_is_in(&list_descr, test3)) {
+                m0_be_tlink_del_fini(&list_descr, test3);
+        }
+        M0_ASSERT(!m0_be_tlink_is_in(&list_descr, test3));
+        M0_ASSERT(m0_be_tlist_length(&list_descr, tlist) == 1);
+
+        if (m0_be_tlink_is_in(&list_descr, test4)) {
+                m0_be_tlink_del_fini(&list_descr, test4);
+        }
+        M0_ASSERT(!m0_be_tlink_is_in(&list_descr, test4));
+        M0_ASSERT(m0_be_tlist_length(&list_descr, tlist) == 0);
+}
+
+void test_be_tlist()
+{
+        test_add_be_tlist(&test1, 10, 20);
+        M0_ASSERT(m0_be_tlink_is_in(&list_descr, test1));
+        M0_ASSERT(m0_be_tlist_length(&list_descr, tlist) == 1);
+
+        test_add_be_tlist(&test2, 20, 30);
+        M0_ASSERT(m0_be_tlink_is_in(&list_descr, test2));
+        M0_ASSERT(m0_be_tlist_length(&list_descr, tlist) == 2);
+
+        test_add_be_tlist(&test3, 30, 40);
+        M0_ASSERT(m0_be_tlink_is_in(&list_descr, test3));
+        M0_ASSERT(m0_be_tlist_length(&list_descr, tlist) == 3);
+
+        test_add_be_tlist(&test4, 40, 10);
+        M0_ASSERT(m0_be_tlink_is_in(&list_descr, test4));
+        M0_ASSERT(m0_be_tlist_length(&list_descr, tlist) == 4);
+
+        test_move_del_be_tlist();
+}
+
+/** Finalise. */
+static int ts_be_tlist_fini(void)
+{
+        int rc;
+        m0_be_seg_done(seg);
+        dom.bd_data.bs_sm.sm_state = M0_BESEG_CLOSED;
+        rvm_truncate();
+        m0_be_domain_fini(&dom);
+
+        sprintf(cmd, "rm -rf %s", stob_dir);
+        rc = system(cmd);
+        M0_ASSERT(rc == 0);
+
+        return rc;
+}
+
+const struct m0_test_suite be_tlist_ut = {
+        .ts_name = "be-tlist-ut",
+        .ts_init = ts_be_tlist_init,
+        .ts_fini = ts_be_tlist_fini,
+        .ts_tests = {
+                { "be-tlist", test_be_tlist },
+                { NULL, NULL },
+        }
+};
+
+/** @} end group be_ut */
+
+/*
+ *  Local variables:
+ *  c-indentation-style: "K&R"
+ *  c-basic-offset: 8
+ *  tab-width: 8
+ *  fill-column: 80
+ *  scroll-step: 1
+ *  End:
+ */
diff --git a/be/ut/handle_store.c b/be/ut/handle_store.c
index 38a8e5d..2fe856d 100644
--- a/be/ut/handle_store.c
+++ b/be/ut/handle_store.c
@@ -14,118 +14,138 @@
  * http://www.xyratex.com/contact
  *
  * Original author: Prashant Dhange <prashant_dhange@xyratex.com>
- * Original creation date: 28 Dec 2012
+ * Original creation date: 12/28/2012
  */
 
 /**
- *              Be Domain UT
- *
- * The UT does not create Named Segment and thus named segment related
- * function is not completed for time being
- */
-
-/**
-  @addtogroup be_ut
+  @addtogroup behs_ut
   @{
   */
 
 #include <stdio.h>
 #include <unistd.h>
 #include <stdlib.h>
-
+#include "lib/memory.h"
+#include "lib/ut.h"
 #include "be/be.h"
+#include "be/seg.h"
+#include "be/tx.h"
 #include "be/domain.h"
 #include "mero/magic.h"
-
-#include "be/lib/handle_store.h"
-
-struct m0_be_seg seg;
-struct m0_be_domain dom;
-struct m0_stob ns_stob, stob;
-struct m0_stob log_stob;
-struct m0_be_tx tx;
-
-void __init()
+#include "be/handle_store.h"
+
+struct m0_be_seg        *seg;
+struct m0_be_domain      dom;
+struct m0_stob           ns_stob, stob;
+struct m0_stob           log_stob;
+struct m0_be_tx          tx;
+struct m0_sm_group      *sm_group;
+struct m0_be_reg         reg;
+struct m0_be_buf         buf;
+
+char hs_cmd[1024];
+static const char      *stob_dir  = "./__be/o";
+static const char      *stob_file = "0000000000000000.0000000000000001";
+extern const char      *log_file;
+
+static int ts_be_init(void)   /* ts_ for "test suite" */
 {
-        struct m0_sm_group *sm_group;
+        int rc = 0;
+        int result;
+
+        sprintf(hs_cmd, "rm -rf %s", log_file);
+        rc = system(hs_cmd);
+        M0_ASSERT(rc == 0);
+        
+        sprintf(hs_cmd, "mkdir -p %s", stob_dir);
+        rc = system(hs_cmd);
+        M0_ASSERT(rc == 0);
+        
+        sprintf(hs_cmd, 
+                "dd if=/dev/zero of=%s/%s bs=1024 count=102408 2>/dev/null",
+                stob_dir, stob_file);
+        rc = system(hs_cmd);
+        M0_ASSERT(rc == 0);
 
         /* Initializing domain */
-        printf("\n\tBackend UT\n");
         m0_be_domain_init(&dom, NULL, NULL, M0_BE_DOMAIN_MAGIC);
-        printf("\nDomain is initialized\n");
-
-        sm_group = m0_be_domain_sm_group(&dom);
 
         /**
          * This is just done to work other part of the code.
          * We are not dealing with named segment for this moment.
          */
+        sm_group = m0_be_domain_sm_group(&dom);
+
+        M0_ASSERT(sm_group != NULL);
+
         m0_sm_group_lock(sm_group);
         m0_sm_state_set(&dom.bd_data.bs_sm, M0_BESEG_ACTIVE);
         m0_sm_group_unlock(sm_group);
 
-        m0_be_domain_lookup(&dom, "first", &seg);
+        result = m0_be_domain_lookup(&dom, "first", &seg);
+
+        if(result != 0) {
+                M0_ALLOC_PTR(seg);
+                m0_be_seg_init(seg, &dom, sm_group, 0);
+                m0_be_seg_create(seg, NULL,  "first", NULL);
+        }
 
         m0_sm_group_lock(sm_group);
-        m0_sm_timedwait(&(seg.bs_sm),
+        m0_sm_timedwait(&seg->bs_sm,
                         (1 << M0_BESEG_ACTIVE) | (1 << M0_BESEG_FAILED),
                         M0_TIME_NEVER);
         m0_sm_group_unlock(sm_group);
 
-
-        if (M0_BESEG_FAILED == seg.bs_sm.sm_state) {
-                printf("\nFailed to create segment \n");
-                return;
+        if (m0_be_seg_state_get(seg) == M0_BESEG_FAILED) {
+                rc = -1;
         }
-        printf("\nSegment is opened\n");
-        printf("\nheap addr : %p\n", seg.bs_addr);
-        printf("\nstatic addr : %p\n", seg.bs_static_addr);
+
+        return rc;
 }
 
-void __fini()
+static int ts_be_fini(void)
 {
-        rvm_truncate();
-        rvm_flush();
+        int rc = 0;
 
-        m0_be_seg_done(&seg);
-        dom.bd_data.bs_sm.sm_state = M0_BESEG_CLOSED;
+        rvm_truncate();
+        m0_be_seg_done(seg);
+        m0_sm_group_lock(sm_group);
+        m0_sm_state_set(&dom.bd_data.bs_sm, M0_BESEG_CLOSED);
+        m0_sm_group_unlock(sm_group);
         m0_be_domain_fini(&dom);
 
-        printf("\nExiting from Backend UT\n");
+        sprintf(hs_cmd, "rm -rf %s", stob_dir);
+        rc = system(hs_cmd);
+        M0_ASSERT(rc == 0);
 
-        printf("\n");
+        return rc;
 }
 
-int main(int argc, char *argv[])
+static void test_be_handlestore()
 {
-        int i=0;
-        int run_mode = atoi(argv[1]);
-
-        __init();
-        m0_be_hs_init(&seg);
-
-        if (!run_mode) {
-                for (i = 0; i < 10; i++) {
-                        struct m0_uint128 kvstore;
-                        kvstore.u_hi = 1 + i;
-                        kvstore.u_lo = 88779911231 + i;
-                        m0_be_hs_update(i, &kvstore);
-                }
-                for (i = 0; i < 10; i = i+2) {
-                        struct m0_uint128 *kvstore = m0_be_hs_get(i);
-                        printf("Address [%ld, %ld] \n", kvstore->u_hi, kvstore->u_lo);
-                }
-        } else {
-                for (i = 0; i < 10; i = i+2) {
-                        struct m0_uint128 *kvstore = m0_be_hs_get(i);
-                        printf("Address [%ld, %ld] \n", kvstore->u_hi, kvstore->u_lo);
-                }
+        int i;
+
+        m0_be_hs_init(seg);
+
+        for (i = 0; i < 10; i++) {
+                struct m0_uint128 kvstore;
+                kvstore.u_hi = 1 + i;
+                kvstore.u_lo = 88779911231 + i;
+                m0_be_hs_update(i, &kvstore);
         }
-        __fini();
-        return 0;
 }
 
-/** @} end group be_ut */
+const struct m0_test_suite be_hs_ut = {
+        .ts_name = "be_hs-ut",
+        .ts_init = ts_be_init,
+        .ts_fini = ts_be_fini,
+        .ts_tests = {
+                { "be-hs", test_be_handlestore },
+                { NULL, NULL },
+        }
+};
+
+/** @} end group behs_ut */
 
 /*
  *  Local variables:
diff --git a/be/ut/init-be.sh b/be/ut/init-be.sh
deleted file mode 100755
index 70a72e5..0000000
--- a/be/ut/init-be.sh
+++ /dev/null
@@ -1,15 +0,0 @@
-export LD_LIBRARY_PATH=../../../rvm/rvm/.libs/:../../../rvm/rds/.libs
-export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:../../../rvm/seg/.libs
-
-rm -rf /tmp/log_file
-
-data_file_path="./__be/o/0000000000000000.0000000000000001"
-
-if [ -e $data_file_path ]; then
-        file_size=`stat -c %s $data_file_path`
-        if [ $file_size -le 100000000 ]; then
-             dd if=/dev/zero of=$data_file_path bs=1024 count=102408 2>/dev/null
-        fi
-else
-        dd if=/dev/zero of=$data_file_path bs=1024 count=102408 2>/dev/null
-fi
diff --git a/be/ut/kv_store.c b/be/ut/kv_store.c
new file mode 100644
index 0000000..975d7c1
--- /dev/null
+++ b/be/ut/kv_store.c
@@ -0,0 +1,332 @@
+/* -*- C -*- */
+/*
+ * COPYRIGHT 2012 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: Zishan Shaikh <zishan_shaikh@xyratex.com>
+ * Original creation date: 12/24/2012
+ */
+
+/**
+              KV_STORE UT
+ */
+
+/**
+  @addtogroup be_ut
+  @{
+  */
+
+#include "be/kv_store.h"
+#include "be/be_private.h"
+#include "be/handle_store.h"
+#include "be/helper.h"
+#include "lib/ut.h"
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#define MAX_KEY_SIZE 256
+
+/** User defined structure. */
+struct m0_kv_store_obj {
+        char                    key[MAX_KEY_SIZE];
+        int                     obj_val;
+        struct m0_be_tlink      linkage;
+        uint64_t                magic;
+};
+
+struct m0_be_tl_descr list_descr = M0_BE_TL_DESCR("kv_store_obj",
+                                                  struct m0_kv_store_obj,
+                                                  linkage,
+                                                  magic,
+                                                  0xab5ce55edba1b0a0,
+                                                  0xba1dba11adba0bab);
+
+struct m0_be_domain        *kv_dom;
+struct m0_be_seg           *kv_seg;
+struct m0_kv_store_obj     *object[1024]   = {NULL};
+struct m0_kv_store_obj     *ret_obj[1024]  = {NULL};
+struct m0_be_kv_store      *handle         = NULL;
+struct m0_be_kv_store_rvm  *handle_rvm     = NULL;
+struct m0_sm_group         *sm_group;
+
+static const char          *stob_dir  = "./__be/o";
+static const char          *stob_file = "0000000000000000.0000000000000001";
+extern const char          *log_file;
+char                        kv_cmd[1024];
+
+/** Key compare routine. */
+int function_comp(void *key1, void *key2)
+{
+        struct m0_kv_store_obj *obj1;
+        struct m0_kv_store_obj *obj2;
+
+        obj1 = (struct m0_kv_store_obj *)key1;
+        obj2 = (struct m0_kv_store_obj *)key2;
+        return strcmp(obj1->key, obj2->key);
+}
+
+/** Match routine. */
+int function_match(void *in_obj, void *key)
+{
+        struct m0_kv_store_obj *obj;
+        obj = (struct m0_kv_store_obj *)in_obj;
+        return strcmp(obj->key, (char *)key);
+}
+
+static int ts_kv_store_init(void)
+{
+        int rc;
+
+        sprintf(kv_cmd, "rm -rf %s", log_file);
+        rc = system(kv_cmd);
+        M0_ASSERT(rc == 0);
+
+        sprintf(kv_cmd, "mkdir -p %s", stob_dir);
+        rc = system(kv_cmd);
+        M0_ASSERT(rc == 0);
+
+        sprintf(kv_cmd,
+                "dd if=/dev/zero of=%s/%s bs=1024 count=102408 2>/dev/null",
+                stob_dir, stob_file);
+        rc = system(kv_cmd);
+        M0_ASSERT(rc == 0);
+
+        kv_key_cmp     cmp_routine;
+        kv_key_match   match_routine;
+
+        cmp_routine   = &function_comp;
+        match_routine = &function_match;
+
+        m0_be_ks_init_domain(&kv_dom);
+        M0_ASSERT(kv_dom != NULL);
+
+        m0_be_ks_init(&handle, &list_descr, kv_dom, cmp_routine, match_routine,
+                      "create");
+        M0_ASSERT(handle != NULL);
+        return 0;
+}
+
+static int ts_kv_store_fini()
+{
+        int rc;
+
+        m0_be_ks_fini(kv_dom, kv_seg);
+        m0_free(handle);
+
+        sprintf(kv_cmd, "rm -rf %s", stob_dir);
+        rc = system(kv_cmd);
+        M0_ASSERT(rc == 0);
+
+        return 0;
+}
+
+static int insert(char *key_name, int val)
+{
+        int                      status  = -2;
+        struct m0_be_tx         *tx;
+        struct m0_be_reference  *obj_ref;
+        struct m0_be_reg        *obj_reg;
+        struct m0_be_buf         obj_buf;
+        struct m0_sm_group      *sm_group;
+
+        M0_ALLOC_PTR(tx);
+
+        if (tx == NULL) {
+                status = BE_KV_FAILURE;
+                goto exit;
+        }
+
+        sm_group = m0_be_domain_sm_group(kv_dom);
+
+        m0_be_tx_init(tx, kv_dom, 0);
+        m0_be_wait(sm_group, &tx->bt_sm,
+                   M0_BITS(M0_BETX_INIT, M0_BETX_FAILED));
+
+        /** Prepare a region for the object. */
+        M0_ALLOC_PTR(obj_reg);
+        M0_ASSERT(obj_reg != NULL);
+        obj_buf.b_nob = sizeof(struct m0_kv_store_obj);
+        m0_be_reg_init(obj_reg, tx, kv_seg, &obj_buf);
+
+        /** As nothing in credit list, so can start tx directly. */
+        m0_be_ks_tx_start(tx);
+
+        /** Memory alloc to the object via rvm. */
+        object[val] = (struct m0_kv_store_obj *)m0_be_ks_obj_malloc(obj_reg,
+                                                                    &obj_ref);
+        if (object[val] == NULL) {
+                status = BE_KV_FAILURE;
+                goto exit;
+        }
+        M0_ASSERT(obj_ref != NULL);
+
+        /** Make changes to object. */
+        strncpy(object[val]->key, key_name, strlen(key_name));
+        object[val]->obj_val = val;
+
+        /** Insert this into the kv_store. */
+        status = m0_be_ks_insert(handle, obj_ref, tx);
+        if (status == BE_KV_FAILURE || status == BE_KV_OUT_OF_DOMAIN ||
+            status == BE_KV_DUPLICATE)
+                goto exit;
+
+        m0_be_tx_done(tx);
+        m0_be_wait(sm_group, &tx->bt_sm,
+                   M0_BITS(M0_BETX_DONE, M0_BETX_FAILED));
+
+        m0_be_tx_fini(tx);
+
+        m0_free(tx);
+
+exit:
+        return status;
+}
+
+static void *find(char *key)
+{
+        return m0_be_ks_find(handle, key);
+}
+
+static int delete(struct m0_kv_store_obj *target)
+{
+        struct m0_be_tx      *tx = NULL;
+        struct m0_be_buf      obj_buf;
+        struct m0_be_reg     *obj_reg = NULL;
+        struct m0_sm_group   *sm_group;
+        int                   ret_val;
+
+        M0_ALLOC_PTR(tx);
+
+        if (tx == NULL)
+                return BE_KV_FAILURE;
+
+        sm_group = m0_be_domain_sm_group(kv_dom);
+
+        m0_be_tx_init(tx, kv_dom, 0);
+        m0_be_wait(sm_group, &tx->bt_sm,
+                   M0_BITS(M0_BETX_INIT, M0_BETX_FAILED));
+
+        /** Prepare a region for this object. */
+        M0_ALLOC_PTR(obj_reg);
+        M0_ASSERT(obj_reg != NULL);
+        obj_buf.b_nob = sizeof(struct m0_kv_store_obj);
+        obj_buf.b_addr = (void *)target;
+        m0_be_reg_init(obj_reg, tx, kv_seg, &obj_buf);
+        M0_ASSERT(obj_reg != NULL);
+
+        m0_be_tx_add_cred(tx, obj_reg);
+
+        m0_be_ks_tx_prep(tx);
+        m0_be_ks_tx_start(tx);
+
+        /** Delete this obj from kv store. */
+        ret_val = m0_be_ks_delete(handle, (void *)target, tx);
+
+        if (ret_val != BE_KV_FAILURE) {
+                m0_be_tx_done(tx);
+                m0_be_wait(sm_group, &tx->bt_sm,
+                           M0_BITS(M0_BETX_DONE, M0_BETX_FAILED));
+
+                ret_val = BE_KV_SUCCESS;
+        }
+
+        m0_be_tx_fini(tx);
+        m0_free(tx);
+        return ret_val;
+}
+
+void test_kv_store() {
+        int     status = -2;
+        int     i      =  0;
+        int     count  =  0;
+        int     ret_dom;
+        size_t  length =  0;
+        char    obj_name[MAX_KEY_SIZE]   = "a";
+
+        /**
+          Lookup for the kv_store segment to be used for allocations while
+          insertion.
+         */
+        sm_group = m0_be_domain_sm_group(kv_dom);
+
+        ret_dom = m0_be_ks_domain_lookup(kv_dom, &kv_seg, BE_KV_SEG_NAME);
+        M0_ASSERT(ret_dom == 0);
+        M0_ASSERT(kv_seg != NULL);
+
+        strcat(obj_name, "b");
+
+        /** Insert objects. */
+        for(i = 0; i < 10; i++) {
+                status = insert(obj_name, i);
+                M0_ASSERT(status != BE_KV_FAILURE);
+                M0_ASSERT(status != BE_KV_OUT_OF_DOMAIN);
+                M0_ASSERT(status != BE_KV_DUPLICATE);
+
+                if (strlen(obj_name) < 255)
+                        strcat(obj_name, "a");
+                else
+                        strcpy(obj_name, "akv");
+        }
+        length = m0_be_tlist_length(&list_descr,
+                                    &handle->handle_rvm->ks_tlist);
+        M0_ASSERT(length == 10);
+
+        /** Find the inserted objects. */
+        count = 0;
+        strcpy(obj_name, "a");
+        strcat(obj_name, "b");
+
+        for(i = 0; i < 10; i++) {
+                ret_obj[i]  = (struct m0_kv_store_obj *)find(obj_name);
+                M0_ASSERT(ret_obj[i] != NULL);
+
+                if (strlen(obj_name) < 255)
+                        strcat(obj_name, "a");
+                else
+                        strcpy(obj_name, "akv");
+        }
+
+
+        /** Delete'em. */
+        for(i =0; i < 10; i++) {
+                status = delete(ret_obj[i]);
+                M0_ASSERT(status == BE_KV_SUCCESS);
+        }
+        length = m0_be_tlist_length(&list_descr,
+                                    &handle->handle_rvm->ks_tlist);
+
+        M0_ASSERT(length == 0);
+}
+
+const struct m0_test_suite be_kv_store_ut = {
+        .ts_name = "be-kv-store-ut",
+        .ts_init = ts_kv_store_init,
+        .ts_fini = ts_kv_store_fini,
+        .ts_tests = {
+                { "be-kv-store", test_kv_store },
+                { NULL, NULL },
+        }
+};
+
+/** @} end group be_ut */
+
+/*
+ * Local variables:
+ * c-indentation-style: "K&R"
+ * c-basic-offset: 8
+ * tab-width: 8
+ * fill-column: 80
+ * scroll-step: 1
+ * End:
+ */
diff --git a/utils/ut_main.c b/utils/ut_main.c
index 8dfc624..7d98e90 100644
--- a/utils/ut_main.c
+++ b/utils/ut_main.c
@@ -35,6 +35,10 @@ extern const struct m0_test_suite libm0_ut; /* test lib first */
 extern const struct m0_test_suite ad_ut;
 extern const struct m0_test_suite addb_ut;
 extern const struct m0_test_suite adieu_ut;
+extern const struct m0_test_suite be_hs_ut;
+extern const struct m0_test_suite be_kv_store_ut;
+extern const struct m0_test_suite be_tlist_ut;
+extern const struct m0_test_suite be_ut;
 extern const struct m0_test_suite balloc_ut;
 extern const struct m0_test_suite buffer_pool_ut;
 extern const struct m0_test_suite bulkio_client_ut;
@@ -89,9 +93,13 @@ extern const struct m0_test_suite yaml2db_ut;
 void add_uts(void)
 {
 	/* sort test suites in alphabetic order */
-	m0_ut_add(&libm0_ut); /* test lib first */
-	m0_ut_add(&ad_ut);
-	m0_ut_add(&adieu_ut);
+        m0_ut_add(&libm0_ut); /* test lib first */
+        m0_ut_add(&ad_ut);
+        m0_ut_add(&adieu_ut);
+        /*m0_ut_add(&be_hs_ut);*/
+        m0_ut_add(&be_kv_store_ut);
+        /*m0_ut_add(&be_tlist_ut);*/
+        /*m0_ut_add(&be_ut);*/
 	m0_ut_add(&balloc_ut);
 	m0_ut_add(&buffer_pool_ut);
 	m0_ut_add(&bulkio_client_ut);
-- 
1.8.3.2

