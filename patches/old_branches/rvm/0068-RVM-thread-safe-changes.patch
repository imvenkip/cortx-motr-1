From a0bb8bcca28f4d64cb8b1ddeacec336f3cebf034 Mon Sep 17 00:00:00 2001
From: Zishan Shaikh <zishan_shaikh@xyratex.com>
Date: Mon, 25 Mar 2013 23:15:23 -0700
Subject: [PATCH 068/121] RVM thread safe changes

---
 Makefile.am               |   1 +
 be/be.h                   |   2 +
 be/be_rvm.c               |   6 +-
 be/be_rvm.h               |   4 +-
 be/reg.c                  |   8 +-
 be/seg.c                  |  17 ++-
 be/ut/be.c                |  10 +-
 lib/trace.h               |   3 +-
 rvm/rds.h                 |  36 +++--
 rvm/rds_coalesce.c        |  66 ++++-----
 rvm/rds_free.c            |  81 +++++------
 rvm/rds_init.c            |  31 +++--
 rvm/rds_malloc.c          |  47 +++----
 rvm/rds_maxblock.c        |  14 +-
 rvm/rds_prealloc.c        |  33 ++---
 rvm/rds_private.h         |  88 +++++-------
 rvm/rds_split.c           |  67 ++++-----
 rvm/rds_start.c           |  55 +++-----
 rvm/rds_stats.c           | 181 +++++++++++++-----------
 rvm/rds_util.c            | 122 +++++++++--------
 rvm/rds_zap.c             |  35 +++--
 rvm/rvm.h                 |  54 ++++++--
 rvm/rvm_createseg.c       |  30 ++--
 rvm/rvm_debug.c           |   7 +-
 rvm/rvm_io.c              |  26 ++--
 rvm/rvm_loadseg.c         |  26 ++--
 rvm/rvm_logrecovr.c       |  88 ++++++------
 rvm/rvm_map.c             | 109 +++++++++------
 rvm/rvm_private.h         |  62 ++++-----
 rvm/rvm_pthread.c         |   2 +-
 rvm/rvm_releaseseg.c      |  13 +-
 rvm/rvm_segment.h         |  19 +--
 rvm/rvm_segment_private.h |  11 +-
 rvm/rvm_segutil.c         |  43 ++++--
 rvm/rvm_status.c          |  13 +-
 rvm/rvm_trans.c           |  20 +--
 rvm/rvm_unmap.c           |  17 ++-
 rvm/rvm_utils.c           |   6 +-
 rvm/ut/Makefile.sub       |   1 +
 rvm/ut/rvm.c              | 342 ++++++++++++++++++++++++++++++++++++++++++++++
 rvm/ut/rvmlib.h           | 140 +++++++++++++++++++
 rvm/ut/util.h             | 113 +++++++++++++++
 utils/ut_main.c           |   4 +-
 43 files changed, 1386 insertions(+), 667 deletions(-)
 create mode 100644 rvm/ut/Makefile.sub
 create mode 100644 rvm/ut/rvm.c
 create mode 100644 rvm/ut/rvmlib.h
 create mode 100644 rvm/ut/util.h

diff --git a/Makefile.am b/Makefile.am
index a93f5b7..c2fde63 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -221,6 +221,7 @@ include $(top_srcdir)/net/ut/Makefile.sub
 include $(top_srcdir)/pool/ut/Makefile.sub
 include $(top_srcdir)/reqh/ut/Makefile.sub
 include $(top_srcdir)/rpc/ut/Makefile.sub
+include $(top_srcdir)/rvm/ut/Makefile.sub
 include $(top_srcdir)/sm/ut/Makefile.sub
 include $(top_srcdir)/sns/ut/Makefile.sub
 include $(top_srcdir)/sns/repair/ut/Makefile.sub
diff --git a/be/be.h b/be/be.h
index 70acdc2..7764cac 100644
--- a/be/be.h
+++ b/be/be.h
@@ -470,6 +470,8 @@ struct m0_be_seg {
         struct m0_addb_ctx    bs_addb;
         /** Implementation private fields. */
         struct m0_be_seg_impl bs_impl;
+        /** RVM seg related info. */
+        struct rvm_seg_hdr   *bs_rvm;
 };
 
 /**
diff --git a/be/be_rvm.c b/be/be_rvm.c
index 5080c7a..72a832a 100644
--- a/be/be_rvm.c
+++ b/be/be_rvm.c
@@ -26,8 +26,6 @@
   */
 const char *log_file="/tmp/log_file";
 
-extern heap_header_t *RecoverableHeapStartAddress;
-
 /**
  * Initialize RVM
  * @todo - most of the rvm options are hardcoded for now
@@ -54,9 +52,9 @@ void m0_be_rvm_init()
         rvm_free_options(options);
 };
 
-void *m0_be_rvm_get_heapaddr()
+void *m0_be_rvm_get_heapaddr(struct m0_be_seg *seg)
 {
-        return (void *)RecoverableHeapStartAddress;
+        return rds_heap_addr(seg->bs_rvm);
 }
 /** @} end group be_rvm */
 
diff --git a/be/be_rvm.h b/be/be_rvm.h
index a229e7a..0e221bf 100644
--- a/be/be_rvm.h
+++ b/be/be_rvm.h
@@ -21,7 +21,7 @@
 
 #ifndef __MERO_BE_BE_RVM_H__
 #define __MERO_BE_BE_RVM_H__
-
+#include "be/be.h"
 /**
   @defgroup be interface
   @{
@@ -34,7 +34,7 @@ void m0_be_rvm_init();
 /*
  * Returns address of the heap start form the RVM segment.
  */
-void *m0_be_rvm_get_heapaddr();
+void *m0_be_rvm_get_heapaddr(struct m0_be_seg *seg);
 
 /** @} end of be interface */
 
diff --git a/be/reg.c b/be/reg.c
index f08c98a..e044881 100644
--- a/be/reg.c
+++ b/be/reg.c
@@ -137,7 +137,7 @@ M0_INTERNAL void m0_be_alloc(struct m0_be_reg *reg)
         if (reg->br_tx != NULL)
                 tid = reg->br_tx->bt_impl.tx_id;
 
-        reg->br_buf.b_addr = (void *)rds_malloc(reg->br_buf.b_nob, tid, &err);
+        reg->br_buf.b_addr = (void *)rds_malloc(reg->br_seg->bs_rvm, reg->br_buf.b_nob, tid, &err);
 
         /* Assign domain magic to reg reference magic  to identify references
          * within the domain.
@@ -173,7 +173,7 @@ M0_INTERNAL void m0_be_free(struct m0_be_reg *reg)
         if (reg->br_tx != NULL)
                 tid = reg->br_tx->bt_impl.tx_id;
 
-        rds_free((char *)reg->br_buf.b_addr, tid, &err);
+        rds_free(reg->br_seg->bs_rvm, (char *)reg->br_buf.b_addr, tid, &err);
 
         if (err != SUCCESS) {
                 m0_be_reg_state_change(reg, M0_BEREG_FAILED);
@@ -219,8 +219,8 @@ M0_INTERNAL void m0_be_reg_capture(struct m0_be_reg *reg)
         sm_group = m0_be_domain_sm_group(reg->br_seg->bs_dom);
         M0_ASSERT(sm_group != NULL);
 
-        ret = rvm_set_range(reg->br_tx->bt_impl.tx_id, reg->br_buf.b_addr,
-                            reg->br_buf.b_nob);
+        ret = rvm_set_range(reg->br_seg->bs_rvm, reg->br_tx->bt_impl.tx_id,
+                            reg->br_buf.b_addr, reg->br_buf.b_nob);
 
         if (RVM_SUCCESS == ret)
                 reg_st = M0_BEREG_CAPTURED;
diff --git a/be/seg.c b/be/seg.c
index a323dd9..e263bc7 100644
--- a/be/seg.c
+++ b/be/seg.c
@@ -294,7 +294,8 @@ static int be_rvm_rds_zap_heap(struct m0_be_seg *seg)
                               heap_length,
                               nlist,
                               chunk_size,
-                              &err);
+                              &err,
+                              seg->bs_rvm);
 
         return result;
 }
@@ -381,15 +382,16 @@ M0_INTERNAL void m0_be_seg_create_cb(void *cb_data)
         result = rds_load_heap(seg->bs_impl.path_name,
                                RVM_LENGTH_TO_OFFSET(dev_length),
                                &static_addr,
-                               &err);
+                               &err,
+                               seg->bs_rvm);
 
         if (result < 0) {
                 M0_LOG(M0_ERROR, "rds_load_heap failed in m0_be_seg_create_cb");
                 goto exit;
         }
 
-        seg->bs_static_addr = (void *)(static_addr);
-        seg->bs_addr = (void *)m0_be_rvm_get_heapaddr();
+        seg->bs_static_addr = (void *)(seg->bs_rvm->static_addr);
+        seg->bs_addr = (void *)m0_be_rvm_get_heapaddr(seg);
         m0_be_seg_tlink_init(seg);
         m0_be_seg_tlist_add(&seg->bs_dom->bd_seg, seg);
 
@@ -452,7 +454,8 @@ M0_INTERNAL void m0_be_seg_open_cb(void *cb_data)
         result = rds_load_heap(seg->bs_impl.path_name,
                                RVM_LENGTH_TO_OFFSET(dev_length),
                                &static_addr,
-                               &err);
+                               &err,
+                               seg->bs_rvm);
 
         if (result < 0) {
                 M0_LOG(M0_ERROR, "rds_load_heap failed in m0_be_seg_open_cb");
@@ -460,8 +463,8 @@ M0_INTERNAL void m0_be_seg_open_cb(void *cb_data)
                 goto exit;
         }
 
-        seg->bs_static_addr = (void *)(static_addr);
-        seg->bs_addr = (void *)m0_be_rvm_get_heapaddr();
+        seg->bs_static_addr = (void *)(seg->bs_rvm->static_addr);
+        seg->bs_addr = (void *)m0_be_rvm_get_heapaddr(seg);
 
         seg_state = M0_BESEG_ACTIVE;
         M0_LOG(M0_INFO, "Segment opened! seg = %p", seg);
diff --git a/be/ut/be.c b/be/ut/be.c
index 5f8673b..af39581 100644
--- a/be/ut/be.c
+++ b/be/ut/be.c
@@ -89,6 +89,7 @@ static int ts_be_init(void)   /* ts_ for "test suite" */
 
         if (result == false) {
                 M0_ALLOC_PTR(seg);
+                seg->bs_rvm = (rvm_seg_hdr_t *)malloc(sizeof(rvm_seg_hdr_t));
                 m0_be_seg_init(seg, dom, sm_group, 0);
                 m0_be_seg_create(seg, NULL,  "first", NULL);
         }
@@ -122,7 +123,7 @@ static int ts_be_fini(void)
         sprintf(be_cmd, "rm -rf %s", stob_dir);
         rc = system(be_cmd);
         M0_ASSERT(rc == 0);
-        rvm_terminate();
+        /*rvm_terminate();*/
 
         return rc;
 }
@@ -181,6 +182,13 @@ const struct m0_test_suite be_ut = {
         }
 };
 
+int main()
+{
+        ts_be_init();
+        test_be_transaction();
+        ts_be_fini();
+        return 0;
+}
 #undef M0_TRACE_SUBSYSTEM
 /** @} end group be_ut */
 
diff --git a/lib/trace.h b/lib/trace.h
index 1cc5af0..790c5ba 100644
--- a/lib/trace.h
+++ b/lib/trace.h
@@ -209,7 +209,8 @@ M0_INTERNAL void m0_trace_fini(void);
   M0_TRACE_SUBSYS(LIB,       17) \
   M0_TRACE_SUBSYS(STOB,      18) \
   M0_TRACE_SUBSYS(FOP,       19) \
-  M0_TRACE_SUBSYS(BE,        20)
+  M0_TRACE_SUBSYS(BE,        20) \
+  M0_TRACE_SUBSYS(RVM,       21)
 
 #define M0_TRACE_SUBSYS(name, value) M0_TRACE_SUBSYS_ ## name = (1 << value),
 /** The subsystem bitmask definitions */
diff --git a/rvm/rds.h b/rvm/rds.h
index 2f4c3b0..3461ec1 100644
--- a/rvm/rds.h
+++ b/rvm/rds.h
@@ -19,10 +19,9 @@ Coda are listed in the file CREDITS.
 /*
  * Public definitions for the Recoverable Dynamic Storage package.
  */
-#pragma once
 
-#ifndef	__MERO_RVM_RDS_H__
-#define	__MERO_RVM_RDS_H__
+#ifndef	_RDS_H_
+#define	_RDS_H_
 
 #include <stdio.h>
 #include "rvm.h"
@@ -50,10 +49,12 @@ extern int rds_zap_heap(
       rvm_length_t          heapLength,
       unsigned long         nlists,
       unsigned long         chunkSize,
-      int                   *err
+      int                   *err,
+      rvm_seg_hdr_t         *seg_hdr
      );
 
 extern int rds_init_heap(
+      rvm_seg_hdr_t         *seg_hdr,
       char                  *base,
       rvm_length_t          length,
       unsigned long         chunkSize,
@@ -66,15 +67,18 @@ extern int rds_load_heap(
       char                  *DevName,
       rvm_offset_t          DevLength,
       char                  **staticAddr,
-      int                   *err
+      int                   *err,
+      rvm_seg_hdr_t         *seg_hdr
     );
 
 extern int rds_start_heap(
+      rvm_seg_hdr_t         *seg_hdr,
       char                  *startAddr,
       int                   *err
     );
 
 extern int rds_prealloc(
+      rvm_seg_hdr_t         *seg_hdr,
       unsigned long         size,
       unsigned long         nblocks,
       rvm_tid_t             *tid,
@@ -82,18 +86,24 @@ extern int rds_prealloc(
     );
 
 extern char *rds_malloc(
-      unsigned long size,
+      rvm_seg_hdr_t         *seg_hdr,
+      unsigned long         size,
       rvm_tid_t             *tid,
       int                   *err
     );
 
 extern int rds_free(
+      rvm_seg_hdr_t         *seg_hdr,
       char                  *addr,
       rvm_tid_t             *tid,
       int                   *err
     );
 
-int rds_maxblock(unsigned long size);
+int rds_maxblock(rvm_seg_hdr_t *seg_hdr, unsigned long size);
+
+extern rvm_bool_t rvm_init_segment(
+      rvm_seg_hdr_t         *seg_hdr
+    );
 
 /*
  * Because a transaction may abort we don't actually want to free
@@ -111,11 +121,13 @@ typedef struct intlist {
 #define STARTSIZE 128   /* Initial size of list, may grow over time */
 
 extern int rds_fake_free(
+      rvm_seg_hdr_t        *seg_hdr,
       char                 *addr,
       intentionList_t      *list
     );
 
 extern int rds_do_free(
+      rvm_seg_hdr_t         *seg_hdr,
       intentionList_t       *list,
       rvm_mode_t            mode
     );
@@ -137,13 +149,13 @@ typedef struct {
     unsigned            mallocbytes;    /* Bytes allocated */
 } rds_stats_t;
 
-extern int rds_print_stats();
-extern int rds_clear_stats(int *err);
-extern int rds_get_stats(rds_stats_t *stats);
+extern int rds_print_stats(rvm_seg_hdr_t *seg_hdr);
+extern int rds_clear_stats(rvm_seg_hdr_t *seg_hdr, int *err);
+extern int rds_get_stats(rvm_seg_hdr_t *seg_hdr, rds_stats_t *stats);
 
 extern int rds_tracing;
 extern FILE *rds_tracing_file;
-extern int rds_trace_on(FILE *);
+extern int rds_trace_on(rvm_seg_hdr_t *seg_hdr, FILE *);
 extern int rds_trace_off();
 extern int rds_trace_dump_heap();
 #define RDS_LOG(format, a...)\
@@ -154,4 +166,4 @@ extern int rds_trace_dump_heap();
 } while (0) ;
 
 
-#endif /* __MERO_RVM_RDS_H__ */
+#endif /* _RDS_H_ */
diff --git a/rvm/rds_coalesce.c b/rvm/rds_coalesce.c
index dbecc2b..6b59f8a 100644
--- a/rvm/rds_coalesce.c
+++ b/rvm/rds_coalesce.c
@@ -19,7 +19,7 @@ Coda are listed in the file CREDITS.
 
 #include <stdio.h>
 #include <stdlib.h>
-#include "rvm/rds_private.h"
+#include "rds_private.h"
 
 /*
  * Coalescing has proven necessary. This approach is to invoke it rarely,
@@ -30,7 +30,7 @@ Coda are listed in the file CREDITS.
  */
 
 /* this function merges a freeblock with all of the following free blocks */
-int merge_with_next_free(free_block_t *fbp, rvm_tid_t *tid, int *err)
+int merge_with_next_free(rvm_seg_hdr_t *seg_hdr, free_block_t *fbp, rvm_tid_t *tid, int *err)
 {
     free_block_t *nfbp;
     guard_t *block_end;
@@ -39,12 +39,12 @@ int merge_with_next_free(free_block_t *fbp, rvm_tid_t *tid, int *err)
 
     assert(fbp->type == FREE_GUARD);	/* Ensure fbp is a free block */
 
-    nfbp = NEXT_CONSECUTIVE_BLOCK(fbp);
+    nfbp = NEXT_CONSECUTIVE_BLOCK(fbp, seg_hdr->heap_hdr);
     merged = 0;
 
     /* Do the set_range outside of next loop if appropriate. */
-    if ((nfbp->type == FREE_GUARD) && (nfbp < RDS_HIGH_ADDR)) {
-	rvmret = rvm_set_range(tid, (char *)fbp, sizeof(free_block_t));
+    if ((nfbp->type == FREE_GUARD) && (nfbp < RDS_HIGH_ADDR(seg_hdr->heap_hdr))) {
+	rvmret = rvm_set_range(seg_hdr,tid, (char *)fbp, sizeof(free_block_t));
 	if (rvmret != RVM_SUCCESS) {
 	    (*err) = (int)rvmret;
 	    return 0;
@@ -52,23 +52,23 @@ int merge_with_next_free(free_block_t *fbp, rvm_tid_t *tid, int *err)
     }
 
     /* See if the next consecutive object is free. */
-    while ((nfbp->type == FREE_GUARD) && (nfbp < RDS_HIGH_ADDR)) {
-	block_end = BLOCK_END(fbp);/* Save a ptr to the endguard */
+    while ((nfbp->type == FREE_GUARD) && (nfbp < RDS_HIGH_ADDR(seg_hdr->heap_hdr))) {
+	block_end = BLOCK_END(fbp, seg_hdr->heap_hdr);/* Save a ptr to the endguard */
 	merged = 1;
-	RDS_STATS.merged++;		/* Update merged object stat */
+	RDS_STATS(seg_hdr->heap_hdr).merged++;		/* Update merged object stat */
 	fbp->size += nfbp->size;	/* Update the object's size */
 
 	/* remove the second object from it's list */
-	list = (nfbp->size >= RDS_MAXLIST) ? RDS_MAXLIST : nfbp->size;
-	assert(RDS_FREE_LIST[list].head != NULL);
+	list = (nfbp->size >= RDS_MAXLIST(seg_hdr->heap_hdr)) ? RDS_MAXLIST(seg_hdr->heap_hdr) : nfbp->size;
+	assert(RDS_FREE_LIST(seg_hdr->heap_hdr)[list].head != NULL);
 
-	rm_from_list(&RDS_FREE_LIST[list], nfbp, tid, err);
+	rm_from_list(seg_hdr, &RDS_FREE_LIST(seg_hdr->heap_hdr)[list], nfbp, tid, err);
 	if (*err != SUCCESS) return 0;
 
 	/* Take out the guards to avoid future confusion. I'm going
 	 * to assume that the next block follows immediately on
 	 * the endguard of the first block */
-	rvmret = rvm_set_range(tid, (char *)block_end,
+	rvmret = rvm_set_range(seg_hdr,tid, (char *)block_end,
 			       sizeof(guard_t) + sizeof(free_block_t));
 	if (rvmret != RVM_SUCCESS) {
 	    (*err) = (int)rvmret;
@@ -77,26 +77,26 @@ int merge_with_next_free(free_block_t *fbp, rvm_tid_t *tid, int *err)
 	*block_end = 0;
 	BZERO(nfbp, sizeof(free_block_t));
 
-	nfbp = NEXT_CONSECUTIVE_BLOCK(fbp);
+	nfbp = NEXT_CONSECUTIVE_BLOCK(fbp, seg_hdr->heap_hdr);
     }
     return merged;
 }
 
 
-void coalesce(rvm_tid_t *tid, int *err)
+void coalesce(rvm_seg_hdr_t *seg_hdr, rvm_tid_t *tid, int *err)
 {
     free_block_t *fbp, *save;
     rvm_return_t rvmret;
     int i, old_maxlist, merged;
 
     /* Make sure the heap has been initialized */
-    if (!HEAP_INIT) {
+    if (!HEAP_INIT(seg_hdr->heap_hdr)) {
 	(*err) = EHEAP_INIT;
 	return;
     }
 
     /* Update stats - don't need setrange, assume caller already has done that. */
-    RDS_STATS.coalesce++;
+    RDS_STATS(seg_hdr->heap_hdr).coalesce++;
 
     *err = SUCCESS; 		/* Initialize the error value */
 
@@ -109,30 +109,30 @@ void coalesce(rvm_tid_t *tid, int *err)
      * Need to make sure objects aren't pulled off the list from under our feet.
      */
 
-    for (i = RDS_NLISTS; i > 0; i--) {
+    for (i = RDS_NLISTS(seg_hdr->heap_hdr); i > 0; i--) {
 	/* Check to see if the list's guard is alright. */
-	if (RDS_FREE_LIST[i].guard != FREE_LIST_GUARD) {
+	if (RDS_FREE_LIST(seg_hdr->heap_hdr)[i].guard != FREE_LIST_GUARD) {
 	    (*err) = ECORRUPT;
 	    return;
 	}
 
-	fbp = RDS_FREE_LIST[i].head;
+	fbp = RDS_FREE_LIST(seg_hdr->heap_hdr)[i].head;
 
 	while (fbp != NULL) {
-	    merged = merge_with_next_free(fbp, tid, err);
+	    merged = merge_with_next_free(seg_hdr, fbp, tid, err);
 	    if (*err)
 		return;
 
 	    if (!merged)
-		RDS_STATS.unmerged++;
+		RDS_STATS(seg_hdr->heap_hdr).unmerged++;
 
 	    /* Move fbp, if merged, it must be larger. Don't move if already
 	     * on the highest list. -- Use NLISTS here if MAXLIST < NLISTS.
 	     */
 
-	    if (merged && i < RDS_NLISTS) {
+	    if (merged && i < RDS_NLISTS(seg_hdr->heap_hdr)) {
 		/* remove fbp from it's list */
-		rm_from_list(&RDS_FREE_LIST[i], fbp, tid, err);
+		rm_from_list(seg_hdr, &RDS_FREE_LIST(seg_hdr->heap_hdr)[i], fbp, tid, err);
 		if (*err != SUCCESS) {
 		    return;
 		}
@@ -140,7 +140,7 @@ void coalesce(rvm_tid_t *tid, int *err)
 		save = fbp->next; /* Save the old value of next */
 
 		/* place fbp in its new list. */
-		put_block((char *)fbp, tid, err);
+		put_block(seg_hdr, (char *)fbp, tid, err);
 		if (*err != SUCCESS) {
 		    return;
 		}
@@ -160,21 +160,21 @@ void coalesce(rvm_tid_t *tid, int *err)
        belong. Reset maxlist to it's highest value, RDS_NLIST. Obviously don't
        need to do the second or third phases if RDS_MAXLIST == RDS_NLISTS. */
 
-    if (RDS_MAXLIST < RDS_NLISTS) {
-	old_maxlist = RDS_MAXLIST;
+    if (RDS_MAXLIST(seg_hdr->heap_hdr) < RDS_NLISTS(seg_hdr->heap_hdr)) {
+	old_maxlist = RDS_MAXLIST(seg_hdr->heap_hdr);
 
-	rvmret = rvm_set_range(tid, (char *)&(RDS_MAXLIST), sizeof(RDS_MAXLIST));
+	rvmret = rvm_set_range(seg_hdr,tid, (char *)&(RDS_MAXLIST(seg_hdr->heap_hdr)), sizeof(RDS_MAXLIST(seg_hdr->heap_hdr)));
 	if (rvmret != RVM_SUCCESS) {
 	    (*err) = (int)rvmret;
 	    return;
 	}
-	RDS_MAXLIST = RDS_NLISTS;
+	RDS_MAXLIST(seg_hdr->heap_hdr) = RDS_NLISTS(seg_hdr->heap_hdr);
 
-	fbp = RDS_FREE_LIST[old_maxlist].head;
+	fbp = RDS_FREE_LIST(seg_hdr->heap_hdr)[old_maxlist].head;
 	while (fbp != NULL) {
 	    if (fbp->size > old_maxlist) {
 
-		rm_from_list(&RDS_FREE_LIST[old_maxlist], fbp, tid, err);
+		rm_from_list(seg_hdr, &RDS_FREE_LIST(seg_hdr->heap_hdr)[old_maxlist], fbp, tid, err);
 		if (*err != SUCCESS) {
 		    return;
 		}
@@ -182,7 +182,7 @@ void coalesce(rvm_tid_t *tid, int *err)
 		save = fbp->next; /* Save the old value of next */
 
 		/* Place the object in it's appropriate list. */
-		put_block((char *)fbp, tid, err);
+		put_block(seg_hdr, (char *)fbp, tid, err);
 		if (*err != SUCCESS) {
 		    return;
 		}
@@ -198,8 +198,8 @@ void coalesce(rvm_tid_t *tid, int *err)
 	/* Used to be an assertion that maxlist != 1 in the next loop,
 	 * Is this really a problem? I don't see it 1/29 -- dcs
 	 */
-	while ((RDS_FREE_LIST[RDS_MAXLIST].head == NULL) && (RDS_MAXLIST > 1)) {
-	    RDS_MAXLIST--;
+	while ((RDS_FREE_LIST(seg_hdr->heap_hdr)[RDS_MAXLIST(seg_hdr->heap_hdr)].head == NULL) && (RDS_MAXLIST(seg_hdr->heap_hdr) > 1)) {
+	    RDS_MAXLIST(seg_hdr->heap_hdr)--;
 	}
     }
 
diff --git a/rvm/rds_free.c b/rvm/rds_free.c
index 2093501..93c39be 100644
--- a/rvm/rds_free.c
+++ b/rvm/rds_free.c
@@ -21,7 +21,7 @@ Coda are listed in the file CREDITS.
 #include <unistd.h>
 #include <stdlib.h>
 #include "rds_private.h"
-    
+
               /************** NOTE: ***************/
 /* we create our own transactions in the following routines, even
  * though there is a tid in the interface. This might result in unreferenced
@@ -47,9 +47,10 @@ Coda are listed in the file CREDITS.
  * rds_do_free(list, mode) actually frees the objects on the list, using
  * mode as the end_transaction mode.
  */
-     
+
 int
-rds_free(addr, tid, err)
+rds_free(seg_hdr,addr, tid, err)
+     rvm_seg_hdr_t   *seg_hdr;
      char	  *addr;
      rvm_tid_t    *tid;
      int	  *err;
@@ -57,9 +58,9 @@ rds_free(addr, tid, err)
     free_block_t *bp = BLOCK_HDR(addr);  /* find pointer to block header */
     rvm_tid_t *atid;
     rvm_return_t rvmret;
-    
+
     /* Make sure the heap has been initialized */
-    if (!HEAP_INIT) {
+    if (!HEAP_INIT(seg_hdr->heap_hdr)) {
 	(*err) = EHEAP_INIT;
 	return -1;
     }
@@ -71,7 +72,7 @@ rds_free(addr, tid, err)
 	(*err) = EBAD_ARGS;
 	return -1;
     }
-    
+
     /* Verify that the guards are intact */
     if (bp->type == FREE_GUARD) { 	/* object was already freed */
 	(*err) = EFREED_TWICE;
@@ -79,7 +80,7 @@ rds_free(addr, tid, err)
     }
 
     /* improper guard --> memory corruption */
-    if ((bp->type != ALLOC_GUARD) || (*BLOCK_END(bp) != END_GUARD)) {
+    if ((bp->type != ALLOC_GUARD) || (*BLOCK_END(bp, seg_hdr->heap_hdr) != END_GUARD)) {
 	(*err) = ECORRUPT;
 	return -1;
     }
@@ -96,15 +97,15 @@ rds_free(addr, tid, err)
 	atid = tid;
 
     *err = SUCCESS; 		/* Initialize the error value */
-    START_CRITICAL;
+    START_CRITICAL(seg_hdr->heap_hdr);
     {
 	/* Update statistics */
-	rvmret = rvm_set_range(atid, &RDS_STATS, sizeof(rds_stats_t));
+	rvmret = rvm_set_range(seg_hdr, atid, &RDS_STATS(seg_hdr->heap_hdr), sizeof(rds_stats_t));
 	if (rvmret != RVM_SUCCESS) {
 	    (*err) = (int)rvmret;
 	} else {
 	    /* Set the lowguard to reflect that the block has been allocated. */
-	    rvmret = rvm_set_range(atid, &(bp->type), sizeof(guard_t));
+	    rvmret = rvm_set_range(seg_hdr, atid, &(bp->type), sizeof(guard_t));
 	    if (rvmret != RVM_SUCCESS) {
 		if (tid == NULL) {
 		    rvm_abort_transaction(atid);
@@ -114,16 +115,16 @@ rds_free(addr, tid, err)
 	    } else {
 		bp->type = FREE_GUARD;
 
-		RDS_STATS.free++;
-		RDS_STATS.freebytes   += bp->size * RDS_CHUNK_SIZE;
-		RDS_STATS.mallocbytes -= bp->size * RDS_CHUNK_SIZE;    
+		RDS_STATS(seg_hdr->heap_hdr).free++;
+		RDS_STATS(seg_hdr->heap_hdr).freebytes   += bp->size * RDS_CHUNK_SIZE(seg_hdr->heap_hdr);
+		RDS_STATS(seg_hdr->heap_hdr).mallocbytes -= bp->size * RDS_CHUNK_SIZE(seg_hdr->heap_hdr);
 
 		/* try to merge with trailing free blocks */
-		merge_with_next_free(bp, atid, err);
+		merge_with_next_free(seg_hdr, bp, atid, err);
 
 		/* Add the block to the approprite free list. */
 		if (*err == SUCCESS)
-		    put_block(bp, atid, err); /* Error is picked up below... */
+		    put_block(seg_hdr, bp, atid, err); /* Error is picked up below... */
 	    }
 	}
 
@@ -138,24 +139,25 @@ rds_free(addr, tid, err)
 	    }
 	}
     }
-    END_CRITICAL;
-	
+    END_CRITICAL(seg_hdr->heap_hdr);
+
     return 0;
 }
 
 /* Assume only one thread can have an open tid at a time. Since we're only
  * modifying per-tid structures, we don't have any concurency.
  */
-int rds_fake_free(addr, list)
+int rds_fake_free(seg_hdr,addr, list)
+     rvm_seg_hdr_t *seg_hdr;
      char *addr;
      intentionList_t *list;
 {
     char **temp;
     free_block_t *bp = BLOCK_HDR(addr);  /* find pointer to block header */
 
-    
+
     /* Make sure the heap has been initialized */
-    if (!HEAP_INIT) {
+    if (!HEAP_INIT(seg_hdr->heap_hdr)) {
 	return EHEAP_INIT;
     }
 
@@ -166,13 +168,13 @@ int rds_fake_free(addr, list)
     /* Make sure that the pointer is word aligned */
     if (((unsigned long)bp % sizeof(void *)) != 0)
 	return EBAD_ARGS;
-    
+
     /* Verify that the guards are intact */
     if (bp->type == FREE_GUARD) 	/* object was already freed */
 	return EFREED_TWICE;
 
     /* improper guard --> memory corruption */
-    if ((bp->type != ALLOC_GUARD) || (*BLOCK_END(bp) != END_GUARD))
+    if ((bp->type != ALLOC_GUARD) || (*BLOCK_END(bp, seg_hdr->heap_hdr) != END_GUARD))
 	return ECORRUPT;
 
     /* If no intention list has been built for this tid yet, build one. */
@@ -192,37 +194,38 @@ int rds_fake_free(addr, list)
     return(SUCCESS);
 }
 
-int rds_do_free(list, mode)
+int rds_do_free(seg_hdr,list, mode)
+     rvm_seg_hdr_t  *seg_hdr;
      intentionList_t *list;
      rvm_mode_t mode;
 {
     int i, err;
     rvm_tid_t *tid = rvm_malloc_tid();
     rvm_return_t rvmret;
-    
+
     rvmret = rvm_begin_transaction(tid, restore);
     if (rvmret != RVM_SUCCESS) {
         rvm_free_tid(tid);
 	return (int) rvmret;
     }
-    
+
     RDS_LOG("rdstrace: start do_free\n");
 
     err = SUCCESS; 		/* Initialize the error value */
-    START_CRITICAL;
+    START_CRITICAL(seg_hdr->heap_hdr);
     {
 	/* Only need to set the range once. To be safe, doing in critical...*/
-	rvmret = rvm_set_range(tid, &RDS_STATS, sizeof(rds_stats_t));
+	rvmret = rvm_set_range(seg_hdr, tid, &RDS_STATS(seg_hdr->heap_hdr), sizeof(rds_stats_t));
 	if (rvmret != RVM_SUCCESS) {
 	    err = (int)rvmret;
 	} else
 	  for (i = 0; i < list->count; i++) {
 	    /* find pointer to block header */
-	    free_block_t *bp = BLOCK_HDR((list->table)[i]); 
+	    free_block_t *bp = BLOCK_HDR((list->table)[i]);
 
 	    /* Set the lowguard to reflect that the block has been allocated. */
 	    assert(bp->type == ALLOC_GUARD);
-	    rvmret = rvm_set_range(tid, &(bp->type), sizeof(guard_t));
+	    rvmret = rvm_set_range(seg_hdr,tid, &(bp->type), sizeof(guard_t));
 	    if (rvmret != RVM_SUCCESS) {
 		err = (int)rvmret;
 		break;
@@ -230,24 +233,24 @@ int rds_do_free(list, mode)
 	    bp->type = FREE_GUARD;
 
 	    /* Update statistics */
-	    RDS_STATS.free++;
-	    RDS_STATS.freebytes   += bp->size * RDS_CHUNK_SIZE;
-	    RDS_STATS.mallocbytes -= bp->size * RDS_CHUNK_SIZE; 
-	    
+	    RDS_STATS(seg_hdr->heap_hdr).free++;
+	    RDS_STATS(seg_hdr->heap_hdr).freebytes   += bp->size * RDS_CHUNK_SIZE(seg_hdr->heap_hdr);
+	    RDS_STATS(seg_hdr->heap_hdr).mallocbytes -= bp->size * RDS_CHUNK_SIZE(seg_hdr->heap_hdr);
+
 	    RDS_LOG("rdstrace: addr %p size %lx\n",
-				     USER_BLOCK(bp)  , bp->size * RDS_CHUNK_SIZE);
+				     USER_BLOCK(bp)  , bp->size * RDS_CHUNK_SIZE(seg_hdr->heap_hdr));
 
 	    /* try to merge with trailing free blocks */
-	    merge_with_next_free(bp, tid, &err);
+	    merge_with_next_free(seg_hdr, bp, tid, &err);
 	    if (err != SUCCESS)
 		break;
 
 	    /* Add the block to the approprite free list. */
-	    put_block(bp, tid, &err); 
+	    put_block(bp, tid, &err);
 	    if (err != SUCCESS)
 		break;
 	}
-	
+
 	RDS_LOG("rdstrace: end do_free\n");
 
 	if (err != SUCCESS) {
@@ -256,8 +259,8 @@ int rds_do_free(list, mode)
 	    rvmret = rvm_end_transaction(tid, mode);
 	}
     }
-    END_CRITICAL;
-	
+    END_CRITICAL(seg_hdr->heap_hdr);
+
     rvm_free_tid(tid);
     free(list->table);
     list->table = NULL;		/* Just to be safe */
diff --git a/rvm/rds_init.c b/rvm/rds_init.c
index a6feff1..9e9cf2c 100644
--- a/rvm/rds_init.c
+++ b/rvm/rds_init.c
@@ -29,7 +29,8 @@ Coda are listed in the file CREDITS.
  */
 
 int
-rds_init_heap(base, length, chunk_size, nlists, tid, err)
+rds_init_heap(seg_hdr,base, length, chunk_size, nlists, tid, err)
+     rvm_seg_hdr_t *seg_hdr;
      char *base;
      rvm_length_t length;
      unsigned long chunk_size;
@@ -37,13 +38,13 @@ rds_init_heap(base, length, chunk_size, nlists, tid, err)
      rvm_tid_t *tid;
      int       *err;
 {
-    heap_header_t *hdrp = (heap_header_t *)base;
+    heap_header_t *hdrp = seg_hdr->heap_hdr->RecoverableHeapStartAddress = (heap_header_t *)base;
     free_block_t *fbp;
     int i, remaining_space;
     unsigned long heap_hdr_len;
     rvm_return_t rvmret;
     guard_t *addr;
-    
+
     /* heap consists of a heap_header_t followed by nlist list headers */
     heap_hdr_len = sizeof(heap_header_t) + nlists * sizeof(free_list_t);
     if (heap_hdr_len > length) {
@@ -51,8 +52,8 @@ rds_init_heap(base, length, chunk_size, nlists, tid, err)
 	(*err) = ENO_ROOM;
 	return -1;
     }
-
-    rvmret = rvm_set_range(tid, base, heap_hdr_len);
+    printf("head header size : %ld \n ", heap_hdr_len);
+    rvmret = rvm_set_range(seg_hdr,tid, base, heap_hdr_len);
     if (rvmret != RVM_SUCCESS) {
 	(*err) = (int) rvmret;
 	return -1;
@@ -67,7 +68,7 @@ rds_init_heap(base, length, chunk_size, nlists, tid, err)
 
     /* Initialize the statistics to zero */
     BZERO(&(hdrp->stats), sizeof(rds_stats_t));
-    
+
     /* create nlists free list structures, making each list null. */
     /* Since the lists are indexed by number of chunks,
      * 1 should be the first entry, not zero. */
@@ -84,14 +85,14 @@ rds_init_heap(base, length, chunk_size, nlists, tid, err)
     remaining_space = length - heap_hdr_len;
 
     /* determine where the first block will start */
-    fbp = (free_block_t *)((char *)&(hdrp->lists[nlists]) + sizeof(free_list_t)); 
+    fbp = (free_block_t *)((char *)&(hdrp->lists[nlists]) + sizeof(free_list_t));
     /* Round this up to the chunk size */
     fbp = (free_block_t *)(((long)((char *)fbp + chunk_size - 1) / chunk_size) * chunk_size);
 
-    rvmret = rvm_set_range(tid, fbp, sizeof(free_block_t));
+    rvmret = rvm_set_range(seg_hdr, tid, fbp, sizeof(free_block_t));
     if (rvmret != RVM_SUCCESS) {
 	(*err) = (int) rvmret;
-	return -1; 
+	return -1;
     }
 
     /* put the block on the list, making it null */
@@ -105,10 +106,10 @@ rds_init_heap(base, length, chunk_size, nlists, tid, err)
     /* Add the guard to the end of the block */
     addr = (guard_t *)((char *)fbp + fbp->size * chunk_size);
     assert((char *)addr <= base + length);
-    
+
     addr--;  /* point to last word in the block */
-    rvmret = rvm_set_range(tid, addr, sizeof(guard_t));
-    if (rvmret != RVM_SUCCESS) {  
+    rvmret = rvm_set_range(seg_hdr, tid, addr, sizeof(guard_t));
+    if (rvmret != RVM_SUCCESS) {
 	(*err) = (int) rvmret;
 	return -1;
     }
@@ -117,3 +118,9 @@ rds_init_heap(base, length, chunk_size, nlists, tid, err)
     (*err) = SUCCESS;
     return 0;
 }
+
+void *rds_heap_addr(rvm_seg_hdr_t *seg_hdr)
+{
+        heap_header_t *hdrp = seg_hdr->heap_hdr->RecoverableHeapStartAddress;
+        return hdrp;
+}
diff --git a/rvm/rds_malloc.c b/rvm/rds_malloc.c
index 46d646f..6b05314 100644
--- a/rvm/rds_malloc.c
+++ b/rvm/rds_malloc.c
@@ -32,13 +32,14 @@ Coda are listed in the file CREDITS.
  * in a non-null tid ptr and it will be used. So if you aren't sure, make the
  * tidptr is zero!
  */
-  
+
 /* Allocate a free block which will hold size + some bytes. The some refers to
  * a size field, and two guards to detect overwriting of memory, which will
  * be added to the object. Treat the last list seperately since it holds objects
- * of that size chunks OR LARGER. A pointer to size bytes will be returned. */ 
+ * of that size chunks OR LARGER. A pointer to size bytes will be returned. */
 char *
-rds_malloc(size, tid, err)
+rds_malloc(seg_hdr, size, tid, err)
+     rvm_seg_hdr_t    *seg_hdr;
      unsigned long size;
      rvm_tid_t     *tid;
      int	   *err;
@@ -50,7 +51,7 @@ rds_malloc(size, tid, err)
     unsigned long orig_size = size;
 
     /* Make sure the heap has been initialized */
-    if (!HEAP_INIT) {
+    if (!HEAP_INIT(seg_hdr->heap_hdr)) {
 	(*err) = EHEAP_INIT;
 	return NULL;
     }
@@ -58,8 +59,8 @@ rds_malloc(size, tid, err)
     /* Reserve bytes to hold the block's size and 2 guards, hidden from user */
     size += RDS_BLOCK_HDR_SIZE;
 
-    i = (size / RDS_CHUNK_SIZE) + 1;         /* determine which list to use */
-    
+    i = (size / RDS_CHUNK_SIZE(seg_hdr->heap_hdr)) + 1;         /* determine which list to use */
+
     if (tid == NULL) {			     /* Use input tid if non-null */
 	atid = rvm_malloc_tid();
 	rvmret = rvm_begin_transaction(atid, restore);
@@ -70,13 +71,13 @@ rds_malloc(size, tid, err)
 	}
     } else
 	atid = tid;
-    
+
 
     *err = SUCCESS; 		/* Initialize the error value */
-    START_CRITICAL;
+    START_CRITICAL(seg_hdr->heap_hdr);
     {
 	/* Update stats */
-	rvmret = rvm_set_range(atid, &RDS_STATS, sizeof(rds_stats_t));
+	rvmret = rvm_set_range(seg_hdr,atid, &RDS_STATS(seg_hdr->heap_hdr), sizeof(rds_stats_t));
 	if (rvmret != RVM_SUCCESS) {
 	    (*err) = (int)rvmret;
 	    if (tid == NULL) {
@@ -84,14 +85,14 @@ rds_malloc(size, tid, err)
 		rvm_free_tid(atid);
 	    }
 	    LEAVE_CRITICAL_SECTION;
-	} 
+	}
+
+	RDS_STATS(seg_hdr->heap_hdr).malloc++;
+	RDS_STATS(seg_hdr->heap_hdr).freebytes -= i * RDS_CHUNK_SIZE(seg_hdr->heap_hdr);
+	RDS_STATS(seg_hdr->heap_hdr).mallocbytes += i * RDS_CHUNK_SIZE(seg_hdr->heap_hdr);
 
-	RDS_STATS.malloc++;	
-	RDS_STATS.freebytes -= i * RDS_CHUNK_SIZE;
-	RDS_STATS.mallocbytes += i * RDS_CHUNK_SIZE;
-		
 	/* Get a block of the correct size. */
-	fbp = get_block(i, atid, err); 
+	fbp = get_block(seg_hdr, i, atid, err);
 	if (*err != SUCCESS) {
 	    if (tid == NULL) {
 		rvm_abort_transaction(atid);
@@ -101,12 +102,12 @@ rds_malloc(size, tid, err)
 	}
 
 	assert(fbp->size == i);	/* Sanity check */
-    
+
 	/* Check to see that the guards are valid and the type is free */
-	assert((fbp->type == FREE_GUARD) && ((*BLOCK_END(fbp)) == END_GUARD));
-		
+        assert((fbp->type == FREE_GUARD) && ((*BLOCK_END(fbp, seg_hdr->heap_hdr)) == END_GUARD));
+
 	/* Set the lowguard to reflect that the block has been allocated. */
-	rvmret = rvm_set_range(atid, fbp, sizeof(free_block_t));
+	rvmret = rvm_set_range(seg_hdr, atid, fbp, sizeof(free_block_t));
 	if (rvmret != RVM_SUCCESS) {
 	    if (tid == NULL) {
 		rvm_abort_transaction(atid);
@@ -118,19 +119,19 @@ rds_malloc(size, tid, err)
 	}
 	fbp->type = ALLOC_GUARD;
 	fbp->prev = fbp->next = NULL;
-    
+
 	if (tid == NULL) {		/* Let code below pick up the error. */
 	    (*err) =(int) rvm_end_transaction(atid, no_flush);
 	    rvm_free_tid(atid);
 	}
     }
-    END_CRITICAL;
+    END_CRITICAL(seg_hdr->heap_hdr);
 
     if (*err != SUCCESS) return NULL;
 
     RDS_LOG("rdstrace: malloc addr %p size %lx req %lx\n",
-			     USER_BLOCK(fbp), i * RDS_CHUNK_SIZE, orig_size);
-    
+			     USER_BLOCK(fbp), i * RDS_CHUNK_SIZE(seg_hdr->heap_hdr), orig_size);
+
     return(USER_BLOCK(fbp));
 }
 
diff --git a/rvm/rds_maxblock.c b/rvm/rds_maxblock.c
index 288f2b6..0f9f1dc 100644
--- a/rvm/rds_maxblock.c
+++ b/rvm/rds_maxblock.c
@@ -21,22 +21,22 @@ Coda are listed in the file CREDITS.
 
 #include "rds_private.h"
 
-int rds_maxblock(unsigned long size) 
+int rds_maxblock(rvm_seg_hdr_t *seg_hdr, unsigned long size)
 {
-    unsigned long nblocks = size / RDS_CHUNK_SIZE;
+    unsigned long nblocks = size / RDS_CHUNK_SIZE(seg_hdr->heap_hdr);
     free_block_t *tempbp;
     int i;
 
-    if (RDS_FREE_LIST[RDS_MAXLIST].head != NULL) {
-	tempbp = RDS_FREE_LIST[RDS_MAXLIST].head;
+    if (RDS_FREE_LIST(seg_hdr->heap_hdr)[RDS_MAXLIST(seg_hdr->heap_hdr)].head != NULL) {
+	tempbp = RDS_FREE_LIST(seg_hdr->heap_hdr)[RDS_MAXLIST(seg_hdr->heap_hdr)].head;
 	while (tempbp) {
-	    if (tempbp->size >= nblocks) 
+	    if (tempbp->size >= nblocks)
 		return 1;
 	    tempbp = tempbp->next;
 	}
     } else {
-	for (i = RDS_MAXLIST - 1; i > nblocks; i--) {
-	    if (RDS_FREE_LIST[i].head) 
+	for (i = RDS_MAXLIST(seg_hdr->heap_hdr) - 1; i > nblocks; i--) {
+	    if (RDS_FREE_LIST(seg_hdr->heap_hdr)[i].head)
 		return 1;
 	}
     }
diff --git a/rvm/rds_prealloc.c b/rvm/rds_prealloc.c
index 7a0df6e..84cdb95 100644
--- a/rvm/rds_prealloc.c
+++ b/rvm/rds_prealloc.c
@@ -38,7 +38,8 @@ Coda are listed in the file CREDITS.
  */
 
 int
-rds_prealloc(size, nblocks, tid, err)
+rds_prealloc(seg_hdr,size, nblocks, tid, err)
+     rvm_seg_hdr_t    *seg_hdr;
      unsigned long size, nblocks;
      rvm_tid_t     *tid;
      int	   *err;
@@ -47,22 +48,22 @@ rds_prealloc(size, nblocks, tid, err)
     rvm_tid_t *atid;
     int i;
     rvm_return_t rvmerr;
-    
-    if (!HEAP_INIT) {  /* Make sure the heap is initialized */
-	(*err) = EHEAP_INIT;    
+
+    if (!HEAP_INIT(seg_hdr->heap_hdr)) {  /* Make sure the heap is initialized */
+	(*err) = EHEAP_INIT;
 	return -1;
     }
 
     /* Reserve bytes to hold the block's size and 2 guards, hidden from user */
     /* Calculate the chunk size which holds that many bytes. */
-    size = ((size + RDS_BLOCK_HDR_SIZE) / RDS_CHUNK_SIZE) + 1;
-    
+    size = ((size + RDS_BLOCK_HDR_SIZE) / RDS_CHUNK_SIZE(seg_hdr->heap_hdr)) + 1;
+
     /*
      * if size == maxlist, then preallocing is pointless. The new object
      * is placed on the beginning of the list, then every split after that
      * will return that same block, and put_block will put it back at the head.
      */
-    if (size == RDS_MAXLIST) {
+    if (size == RDS_MAXLIST(seg_hdr->heap_hdr)) {
 	*err = SUCCESS;
 	return -1;
     }
@@ -79,14 +80,14 @@ rds_prealloc(size, nblocks, tid, err)
 	atid = tid;
 
     /* Update statistics */
-    rvmerr = rvm_set_range(atid, &RDS_STATS, sizeof(rds_stats_t));
+    rvmerr = rvm_set_range(seg_hdr, atid, &RDS_STATS(seg_hdr->heap_hdr), sizeof(rds_stats_t));
     if ((rvmerr != RVM_SUCCESS) && (tid == NULL)) {
 	rvm_abort_transaction(atid);
 	(*err) = (int)rvmerr;
 	rvm_free_tid(atid);
 	return -1;
     }
-    RDS_STATS.prealloc++;	/* Update statistics. */
+    RDS_STATS(seg_hdr->heap_hdr).prealloc++;	/* Update statistics. */
 
     *err = SUCCESS; 		/* Initialize the error value */
 
@@ -96,16 +97,16 @@ rds_prealloc(size, nblocks, tid, err)
      */
 
     for (i = 0; i < nblocks; i++) {
-	START_CRITICAL;
+	START_CRITICAL(seg_hdr->heap_hdr);
 	{
-	    /* Get a block */	
-	    bp = split(size, atid, err); 
-	    if (bp != NULL) { 
+	    /* Get a block */
+	    bp = split(size, atid, err);
+	    if (bp != NULL) {
 		/* Add the block to the appropriate list. */
 		put_block(bp, atid, err);
 	    }
 	}
-	END_CRITICAL;
+	END_CRITICAL(seg_hdr->heap_hdr);
 
 	if (*err != SUCCESS) {
 	    if (tid == NULL) {
@@ -123,10 +124,10 @@ rds_prealloc(size, nblocks, tid, err)
 	    rvm_free_tid(atid);
 	    return -1;
 	}
-	
+
 	rvm_free_tid(atid);
     }
-    
+
     *err = SUCCESS;
     return 0;
 }
diff --git a/rvm/rds_private.h b/rvm/rds_private.h
index be41c53..2d25b37 100644
--- a/rvm/rds_private.h
+++ b/rvm/rds_private.h
@@ -20,23 +20,18 @@ Coda are listed in the file CREDITS.
 /*
  * Internal type definitions for the Recoverable Dynamic Storage package.
  */
-#pragma once
-
-#ifndef __MERO_RVM_RDS_PRIVATE_H__
-#define __MERO_RVM_RDS_PRIVATE_H__
-
-#ifdef HAVE_CONFIG_H
-#include "config.h"
-#endif
 
 #ifdef __STDC__
 #include <string.h>
 #include "assert.h"
 #endif
 
-#include "rvm/rvm.h"
-#include "rvm/rvm_segment.h"
-#include "rvm/rds.h"
+#include "rvm.h"
+#include "rvm_segment.h"
+#include "rds.h"
+
+#ifndef _RDS_PRIVATE_H_
+#define _RDS_PRIVATE_H_
 
 /********************
  *Type definitions
@@ -69,21 +64,21 @@ Coda are listed in the file CREDITS.
  */
 
 #ifdef RVM_USELWP	 /* special thread support for Coda */
-#include "rvm/rvm_lwp.h"
+#include "rvm_lwp.h"
 #elif defined(RVM_USEPT) /* special support for pthreads */
-#include "rvm/rvm_pthread.h"
+#include "rvm_pthread.h"
 #else			 /* normal: use Cthreads */
-#include "rvm/cthreads.h"
+#include "cthreads.h"
 
 /* define types symbolically to permit use of non-Cthread thread support */
 #define RVM_MUTEX       struct mutex
 #define RVM_CONDITION	struct condition
 #endif
 
-#define START_CRITICAL	mutex_lock(&heap_lock)
+#define START_CRITICAL(ptr)	mutex_lock(&ptr->heap_lock)
 #define LEAVE_CRITICAL_SECTION	goto end_critical
-#define END_CRITICAL	goto end_critical; \
-    end_critical:	mutex_unlock(&heap_lock)
+#define END_CRITICAL(ptr)	goto end_critical; \
+    end_critical:	mutex_unlock(&ptr->heap_lock)
 
 /* Guards detect if the block structure had been illegally overwritten.
  * One is placed after the size, and before user's data. The other is placed
@@ -94,7 +89,7 @@ Coda are listed in the file CREDITS.
 #define END_GUARD   0xfd10a32e
 
 #define RDS_BLOCK_HDR_SIZE (sizeof(block_size_t) + 2 * sizeof(guard_t))
-#define BLOCK_END(bp) ((guard_t *)((char *)(bp) + ((bp)->size * RDS_CHUNK_SIZE)) - 1)
+#define BLOCK_END(bp, ptr) ((guard_t *)((char *)(bp) + ((bp)->size * RDS_CHUNK_SIZE(ptr))) - 1)
 
 #define USER_BLOCK(bp) ((char *)&((bp)->prev))
 #define BLOCK_HDR(bp)  ((free_block_t *)((char *)(bp) - \
@@ -116,15 +111,14 @@ typedef struct {
     free_block_t *head;
 } free_list_t;
 
-#define NEXT_CONSECUTIVE_BLOCK(bp) ((free_block_t *)((char *)(bp) + ((bp)->size * RDS_CHUNK_SIZE)))
+#define NEXT_CONSECUTIVE_BLOCK(bp, ptr) ((free_block_t *)((char *)(bp) + ((bp)->size * RDS_CHUNK_SIZE(ptr))))
 
 #define HEAP_LIST_GROWSIZE 20		/* Number of blocks to prealloc */
 
 #define RDS_HEAP_VERSION "Dynamic Allocator Using Rvm Release 0.1 1 Dec 1990"
 #define RDS_VERSION_MAX 80
 
-/*typedef struct {*/
-struct heap_header {
+struct heap_header{
     char          version[RDS_VERSION_MAX]; /* Version String */
     unsigned long heaplength;
     unsigned long chunk_size;
@@ -135,37 +129,28 @@ struct heap_header {
     free_list_t lists[1];              /* Number of lists is dynamically set */
 };
 
-/* Global data extern declarations. */
-extern heap_header_t *RecoverableHeapStartAddress;
-extern free_block_t  *RecoverableHeapHighAddress;
-extern RVM_MUTEX heap_lock;
-
 extern int rds_tracing;
 extern FILE *rds_tracing_file;
 
+struct heap_def {
+        heap_header_t          *RecoverableHeapStartAddress;
+        free_block_t           *RecoverableHeapHighAddress;
+        rvm_region_def_t       *RegionDefs;
+        unsigned long           NRegionDefs;
+        RVM_MUTEX               heap_lock;
+};
+
 
-#define HEAP_INIT   		(RecoverableHeapStartAddress != 0)
-#define RDS_VERSION_STAMP	(RecoverableHeapStartAddress->version)
-#define RDS_HEAPLENGTH 		(RecoverableHeapStartAddress->heaplength)
-#define RDS_CHUNK_SIZE 		(RecoverableHeapStartAddress->chunk_size)
-#define RDS_FREE_LIST  		(RecoverableHeapStartAddress->lists)
-#define RDS_NLISTS		(RecoverableHeapStartAddress->nlists)
-#define RDS_MAXLIST		(RecoverableHeapStartAddress->maxlist)
-#define RDS_STATS		(RecoverableHeapStartAddress->stats)
-#define RDS_HIGH_ADDR		(RecoverableHeapHighAddress)
 
-/*******************
- * byte <-> string
- */
-#ifndef BZERO
-#ifdef __STDC__
-#define BCOPY(S,D,L)   memcpy((D),(S),(L))
-#define BZERO(D,L)     memset((D),0,(L))
-#else
-#define BCOPY(S,D,L)   bcopy((S),(D),(L))
-#define BZERO(D,L)     bzero((D),(L))
-#endif
-#endif
+#define HEAP_INIT(pheap)   		(pheap->RecoverableHeapStartAddress != 0)
+#define RDS_VERSION_STAMP(pheap)	(pheap->RecoverableHeapStartAddress->version)
+#define RDS_HEAPLENGTH(pheap)           (pheap->RecoverableHeapStartAddress->heaplength)
+#define RDS_CHUNK_SIZE(pheap) 		(pheap->RecoverableHeapStartAddress->chunk_size)
+#define RDS_FREE_LIST(pheap)  		(pheap->RecoverableHeapStartAddress->lists)
+#define RDS_NLISTS(pheap)		(pheap->RecoverableHeapStartAddress->nlists)
+#define RDS_MAXLIST(pheap)		(pheap->RecoverableHeapStartAddress->maxlist)
+#define RDS_STATS(pheap)		(pheap->RecoverableHeapStartAddress->stats)
+#define RDS_HIGH_ADDR(pheap)		(pheap->RecoverableHeapHighAddress)
 
 /********************
  * Definitions of worker functions.
@@ -186,7 +171,8 @@ int           rm_from_list();
 /***********************
  * Coalesce
  */
-int merge_with_next_free(free_block_t *fbp, rvm_tid_t *tid, int *err);
-void coalesce(rvm_tid_t *tid, int *err);
-
-#endif /* __MERO_RVM_RDS_PRIVATE_H__ */
+int merge_with_next_free(rvm_seg_hdr_t *seg_hdr, free_block_t *fbp, rvm_tid_t *tid, int *err);
+void coalesce(rvm_seg_hdr_t *seg_hdr, rvm_tid_t *tid, int *err);
+rvm_bool_t init_rvm_seg_region_tree(rvm_seg_hdr_t *seg_hdr);
+void *rds_heap_addr(rvm_seg_hdr_t *seg_hdr);
+#endif /* _RDS_PRIVATE_H_ */
diff --git a/rvm/rds_split.c b/rvm/rds_split.c
index 547978d..62b9b95 100644
--- a/rvm/rds_split.c
+++ b/rvm/rds_split.c
@@ -28,7 +28,8 @@ Coda are listed in the file CREDITS.
  */
 
 free_block_t *
-split(size, tid, err)
+split(seg_hdr, size, tid, err)
+     rvm_seg_hdr_t   *seg_hdr;
      int 	  size;
      rvm_tid_t	  *tid;
      int	  *err;
@@ -39,29 +40,29 @@ split(size, tid, err)
     int remaining_size, i;
     free_list_t  *list;
     int second_attempt = 0;
-    
+
     /* Find the list with the largest blocks that is non-empty. */
     /* Only do the setrange if necessary... */
-    if (RDS_FREE_LIST[RDS_MAXLIST].head == NULL) {
-	rvmerr = rvm_set_range(tid, &RDS_MAXLIST, sizeof(unsigned long));
+    if (RDS_FREE_LIST(seg_hdr->heap_hdr)[RDS_MAXLIST(seg_hdr->heap_hdr)].head == NULL) {
+	rvmerr = rvm_set_range(seg_hdr,tid, &RDS_MAXLIST(seg_hdr->heap_hdr), sizeof(unsigned long));
 	if (rvmerr != RVM_SUCCESS) {
 	    (*err) = (int) rvmerr;
 	    return NULL;
 	}
-	
+
 	/* Don't need a set range, assume caller already did that. */
-	RDS_STATS.large_list++; /* Only bump once, not once per MAXLIST-- */
-	
+	RDS_STATS(seg_hdr->heap_hdr).large_list++; /* Only bump once, not once per MAXLIST-- */
+
 	/* find the first nonempty list larger than size */
-	while (RDS_MAXLIST > size && RDS_FREE_LIST[RDS_MAXLIST].head == NULL) {
-	    RDS_MAXLIST--;
+	while (RDS_MAXLIST(seg_hdr->heap_hdr) > size && RDS_FREE_LIST(seg_hdr->heap_hdr)[RDS_MAXLIST(seg_hdr->heap_hdr)].head == NULL) {
+	    RDS_MAXLIST(seg_hdr->heap_hdr)--;
 	}
-	
+
 	/* If no possible block big enough now, see if coalesce will save us.
 	 * Coalesce resets MAXLIST to the highest nonempty list.
 	 */
-	if (RDS_FREE_LIST[RDS_MAXLIST].head == NULL) { 
-	    coalesce(tid, err);        
+	if (RDS_FREE_LIST(seg_hdr->heap_hdr)[RDS_MAXLIST(seg_hdr->heap_hdr)].head == NULL) {
+	    coalesce(seg_hdr,tid, err);
 	    if (*err)
 		return NULL;
 	}
@@ -70,14 +71,14 @@ split(size, tid, err)
 retry:
     /* Kind of a hack, try to avoid fragmenting the blocks on MAXLIST by
      * picking from a list that is a multiple of the requested size. */
-    list = &RDS_FREE_LIST[RDS_MAXLIST];
-    for (i = size * 2; i < RDS_MAXLIST; i += size) {
-	if (RDS_FREE_LIST[i].head) {
-	    list = &RDS_FREE_LIST[i];
+    list = &RDS_FREE_LIST(seg_hdr->heap_hdr)[RDS_MAXLIST(seg_hdr->heap_hdr)];
+    for (i = size * 2; i < RDS_MAXLIST(seg_hdr->heap_hdr); i += size) {
+	if (RDS_FREE_LIST(seg_hdr->heap_hdr)[i].head) {
+	    list = &RDS_FREE_LIST(seg_hdr->heap_hdr)[i];
 	    break;
 	}
     }
-    
+
     bp = NULL;
     tempbp = list->head;
     while (tempbp) {
@@ -96,38 +97,38 @@ retry:
 	if (!second_attempt) {
 	    /* No block was big enough on the first try,
 	     * coalesce and try again */
-	    coalesce(tid, err);  
+	    coalesce(seg_hdr,tid, err);
 	    if (*err) return NULL;
 
 	    second_attempt = 1;
 	    goto retry;
 	}
 
-	*err = ENO_ROOM; 
+	*err = ENO_ROOM;
 	return NULL;
     }
 
     assert(bp && bp->size >= size); /* Assume we found an appropriate block */
-    
+
     if (size == bp->size) { /* We have an exact fit */
-	rm_from_list(list, bp, tid, err);
+	rm_from_list(seg_hdr, list, bp, tid, err);
 	if (*err != SUCCESS)
 	    return NULL;
 	return bp;
     }
-    
+
     /* Calculate size of block remaining after desired block is split off. */
     remaining_size = bp->size - size;
     assert(remaining_size > 0);
-    
+
     newObject1 = bp;
     newObject2 = (free_block_t *)	/* Cast as char * to get byte addition */
-	((char *)bp + remaining_size * RDS_CHUNK_SIZE);
+	((char *)bp + remaining_size * RDS_CHUNK_SIZE(seg_hdr->heap_hdr));
 
     /* Init the headers for the new objects. */
-    
+
     /* For newObject1, lowguard is set, size and highguard need updating. */
-    rvmerr = rvm_set_range(tid, newObject1, sizeof(free_block_t));
+    rvmerr = rvm_set_range(seg_hdr,tid, newObject1, sizeof(free_block_t));
     if (rvmerr != RVM_SUCCESS) {
 	(*err) = (int) rvmerr;
 	return NULL;
@@ -135,15 +136,15 @@ retry:
     newObject1->size = remaining_size;
 
     /* Add the highguard to the end of the block */
-    rvmerr = rvm_set_range(tid, BLOCK_END(newObject1), sizeof(guard_t));
+    rvmerr = rvm_set_range(seg_hdr,tid, BLOCK_END(newObject1, seg_hdr->heap_hdr), sizeof(guard_t));
     if (rvmerr != RVM_SUCCESS)  {
 	(*err) = (int) rvmerr;
 	return NULL;
     }
-    (*BLOCK_END(newObject1)) = END_GUARD;
-    
+    (*BLOCK_END(newObject1, seg_hdr->heap_hdr)) = END_GUARD;
+
     /* for newObject2, size and lowguard need setting, highguard doesn't */
-    rvmerr = rvm_set_range(tid, newObject2, sizeof(free_block_t));
+    rvmerr = rvm_set_range(seg_hdr,tid, newObject2, sizeof(free_block_t));
     if (rvmerr != RVM_SUCCESS)  {
 	(*err) = (int) rvmerr;
 	return NULL;
@@ -155,13 +156,13 @@ retry:
     /* If Object1 doesn't need to be moved, nothing needs to happen. */
 
     /* Otherwise Object1 is taken off the old list and moved to a new one. */
-    if (newObject1->size < RDS_MAXLIST) {
-	rm_from_list(list, newObject1, tid, err);
+    if (newObject1->size < RDS_MAXLIST(seg_hdr->heap_hdr)) {
+	rm_from_list(seg_hdr, list, newObject1, tid, err);
 	if (*err != SUCCESS)
 	    return NULL;
 
 	/* newObject1 has been removed, now add it to the appropriate list */
-	put_block(newObject1, tid, err);
+	put_block(seg_hdr, newObject1, tid, err);
 	if (*err != SUCCESS) return NULL;
     }
 
diff --git a/rvm/rds_start.c b/rvm/rds_start.c
index 05fd859..b18b94f 100644
--- a/rvm/rds_start.c
+++ b/rvm/rds_start.c
@@ -19,7 +19,7 @@ Coda are listed in the file CREDITS.
 #include <stdlib.h>
 #include <stdio.h>
 #include "rds_private.h"
-    
+
               /************** NOTE: ***************/
 /* we create our own transactions in the following routines, even
  * though there is a tid in the interface. This might result in unreferenced
@@ -34,67 +34,47 @@ Coda are listed in the file CREDITS.
  */
 
 
-/* Global pointer to the start of the heap, but only accessed via heap macros
- * and routines. Should never be directly addressed by outside code.
- */
-    
-heap_header_t *RecoverableHeapStartAddress;
-
-/*
- * Global pointer to last address in heap region. Make it a block ptr to
- * avoid casts in comparisons.
- */
-free_block_t *RecoverableHeapHighAddress;
-rvm_region_def_t *RegionDefs;
-unsigned long     NRegionDefs;
-rvm_bool_t       rds_testsw = rvm_false;   /* switch to allow special
-                                              test modes */
 /*
  * Global lock for the heap. See comment in rds_private.h.
  */
 
-/* 
+/*
  * Cannot statically initialize locks in pthreads.  So, we also need a flag
  * for double initialization.
  */
-#ifndef RVM_USEPT
-RVM_MUTEX	   heap_lock = MUTEX_INITIALIZER;
-#else
-RVM_MUTEX          heap_lock;
-static rvm_bool_t  inited = rvm_false;
-#endif
 
 /* Let the application know the starting address of the heap. This is
  * EFFECTIVELY idempotent since it will fail in rvm_load_segment without
  * modifying any structures if it has already been called.
  */
 int
-rds_load_heap(DevName, DevLength, static_addr, err)
+rds_load_heap(DevName, DevLength, static_addr, err, seg_hdr)
      char	  *DevName;
      rvm_offset_t DevLength;
      char	  **static_addr; /* Start of region holding statics */
      int	  *err;
+     rvm_seg_hdr_t   *seg_hdr;
 {
     rvm_return_t     rvmret;
 
     /* Map in the appropriate structures by calling Rvm_Load_Segment. */
     rvmret = rvm_load_segment(DevName, DevLength, NULL,
-			      &NRegionDefs, &RegionDefs);
+			      &seg_hdr->heap_hdr->NRegionDefs, &seg_hdr->heap_hdr->RegionDefs, seg_hdr);
     if (rvmret != RVM_SUCCESS) {
 	    printf("Error rvm_load_segment returns %d\n", rvmret);
 	    (*err) = (int) rvmret;
 	    return -1;
     }
 
-    if (NRegionDefs != 2) {
-	free(RegionDefs);
+    if (seg_hdr->heap_hdr->NRegionDefs != 2) {
+	free(seg_hdr->heap_hdr->RegionDefs);
 	(*err) = EBAD_SEGMENT_HDR;
 	return -1;
     }
-    
-    (*static_addr) = (char *)RegionDefs[1].vmaddr;
 
-    rds_start_heap(RegionDefs[0].vmaddr, err);
+    (*static_addr) = seg_hdr->static_addr = (char *)seg_hdr->heap_hdr->RegionDefs[1].vmaddr;
+
+    rds_start_heap(seg_hdr, seg_hdr->heap_hdr->RegionDefs[0].vmaddr, err);
 
     return 0;
 }
@@ -104,7 +84,8 @@ rds_load_heap(DevName, DevLength, static_addr, err)
  */
 
 int
-rds_start_heap(startAddr, err)
+rds_start_heap(seg_hdr, startAddr, err)
+     rvm_seg_hdr_t *seg_hdr;
      char *startAddr;
      int *err;
 {
@@ -118,18 +99,18 @@ rds_start_heap(startAddr, err)
 	mutex_init(&heap_lock);
     }
 #endif
-    RecoverableHeapStartAddress = (heap_header_t *)startAddr;
+    seg_hdr->heap_hdr->RecoverableHeapStartAddress = (heap_header_t *)startAddr;
 
     /* Match version stamps */
-    if (strcmp(RDS_HEAP_VERSION, RDS_VERSION_STAMP) != 0) {
+    if (strcmp(RDS_HEAP_VERSION, RDS_VERSION_STAMP(seg_hdr->heap_hdr)) != 0) {
 	*err = EHEAP_VERSION_SKEW;
         return -1;
     }
 
-    heap_hdr_len = sizeof(heap_header_t) + RDS_NLISTS * sizeof(free_list_t);
-    RecoverableHeapHighAddress = (free_block_t *)
-	((char *)RecoverableHeapStartAddress +
-	    ((RDS_HEAPLENGTH - heap_hdr_len)/ RDS_CHUNK_SIZE) * RDS_CHUNK_SIZE +
+    heap_hdr_len = sizeof(heap_header_t) + RDS_NLISTS(seg_hdr->heap_hdr) * sizeof(free_list_t);
+    seg_hdr->heap_hdr->RecoverableHeapHighAddress = (free_block_t *)
+	((char *)seg_hdr->heap_hdr->RecoverableHeapStartAddress +
+	    ((RDS_HEAPLENGTH(seg_hdr->heap_hdr) - heap_hdr_len)/ RDS_CHUNK_SIZE(seg_hdr->heap_hdr)) * RDS_CHUNK_SIZE(seg_hdr->heap_hdr) +
 		heap_hdr_len);
 
     *err = SUCCESS;
diff --git a/rvm/rds_stats.c b/rvm/rds_stats.c
index 32de07d..275c334 100644
--- a/rvm/rds_stats.c
+++ b/rvm/rds_stats.c
@@ -22,41 +22,42 @@ Coda are listed in the file CREDITS.
 
 int rds_tracing = FALSE;
 FILE *rds_tracing_file = NULL;
-    
+
 /*
  * Print out the current statistics
  */
 int
-rds_print_stats()
+rds_print_stats(rvm_seg_hdr_t *seg_hdr)
 {
-    if (!HEAP_INIT)	/* Make sure RecoverableHeapStartAddress is inited */
-	return -1;	
+    if (!HEAP_INIT(seg_hdr->heap_hdr))	/* Make sure RecoverableHeapStartAddress is inited */
+	return -1;
 
     /* Not making this a critical section since a race condition only reports
        slightly bogus statistics -- and off by one over several thousand isn't
        significant. */
-       
+
     printf("Number of\n");
-    printf(" Free bytes: \t %x\n", RDS_STATS.freebytes);
-    printf(" Alloced bytes:\t %x\n", RDS_STATS.mallocbytes);
-    printf(" Mallocs: \t %d\n", RDS_STATS.malloc);
-    printf(" Frees: \t %d\n",  RDS_STATS.free);
-    printf(" Preallocs: \t %d\n",  RDS_STATS.prealloc);
-    printf(" Hits: \t\t %d\n",  RDS_STATS.hits);
-    printf(" Misses: \t %d\n",  RDS_STATS.misses);
-    printf(" Large Hits: \t %d\n",  RDS_STATS.large_hits);
-    printf(" Large Misses: \t %d\n",  RDS_STATS.large_misses);
-    printf(" Coalesces: \t %d\n",  RDS_STATS.coalesce);
-    printf(" Merges \t %d\n", RDS_STATS.merged);
-    printf(" Not Merged: \t %d\n", RDS_STATS.unmerged);
-    printf(" Times the Large List pointer has changed: %d\n", RDS_STATS.large_list);
+    printf(" Free bytes: \t %d\n", RDS_STATS(seg_hdr->heap_hdr).freebytes);
+    printf(" Alloced bytes:\t %d\n", RDS_STATS(seg_hdr->heap_hdr).mallocbytes);
+    printf(" Mallocs: \t %d\n", RDS_STATS(seg_hdr->heap_hdr).malloc);
+    printf(" Frees: \t %d\n",  RDS_STATS(seg_hdr->heap_hdr).free);
+    printf(" Preallocs: \t %d\n",  RDS_STATS(seg_hdr->heap_hdr).prealloc);
+    printf(" Hits: \t\t %d\n",  RDS_STATS(seg_hdr->heap_hdr).hits);
+    printf(" Misses: \t %d\n",  RDS_STATS(seg_hdr->heap_hdr).misses);
+    printf(" Large Hits: \t %d\n",  RDS_STATS(seg_hdr->heap_hdr).large_hits);
+    printf(" Large Misses: \t %d\n",  RDS_STATS(seg_hdr->heap_hdr).large_misses);
+    printf(" Coalesces: \t %d\n",  RDS_STATS(seg_hdr->heap_hdr).coalesce);
+    printf(" Merges \t %d\n", RDS_STATS(seg_hdr->heap_hdr).merged);
+    printf(" Not Merged: \t %d\n", RDS_STATS(seg_hdr->heap_hdr).unmerged);
+    printf(" Times the Large List pointer has changed: %d\n", RDS_STATS(seg_hdr->heap_hdr).large_list);
 
     return 0;
 }
 
 /* Zero out the stats structure. */
 int
-rds_clear_stats(err)
+rds_clear_stats(seg_hdr,err)
+     rvm_seg_hdr_t *seg_hdr;
      int *err;
 {
     rvm_return_t rvmret;
@@ -67,15 +68,15 @@ rds_clear_stats(err)
 	(*err) = (int)rvmret;
 	rvm_free_tid(atid);
 	return -1;
-    }    
+    }
 
-    START_CRITICAL;
+    START_CRITICAL(seg_hdr->heap_hdr);
     {
-	rvmret = rvm_set_range(atid, &RDS_STATS, sizeof(rds_stats_t));
-	if (rvmret == RVM_SUCCESS) 
-	    BZERO(&RDS_STATS, sizeof(rds_stats_t));
+	rvmret = rvm_set_range(seg_hdr, atid, &RDS_STATS(seg_hdr->heap_hdr), sizeof(rds_stats_t));
+	if (rvmret == RVM_SUCCESS)
+	    BZERO(&RDS_STATS(seg_hdr->heap_hdr), sizeof(rds_stats_t));
     }
-    END_CRITICAL;
+    END_CRITICAL(seg_hdr->heap_hdr);
 
     if (rvmret != RVM_SUCCESS) {
 	rvm_abort_transaction(atid);
@@ -83,14 +84,14 @@ rds_clear_stats(err)
 	rvm_free_tid(atid);
 	return -1;
     }
-    
+
     rvmret = rvm_end_transaction(atid, no_flush);
     if (rvmret != RVM_SUCCESS) {
 	(*err) = (int)rvmret;
 	rvm_free_tid(atid);
 	return -1; /* should I abort here just in case? */
     }
-	
+
     *err = SUCCESS;
     rvm_free_tid(atid);
     return 0;
@@ -101,19 +102,20 @@ rds_clear_stats(err)
  * Like print_stats, this really doesn't need to be critical -- dcs 1/29
  */
 
-int rds_get_stats(stats)
+int rds_get_stats(seg_hdr, stats)
+     rvm_seg_hdr_t  *seg_hdr;
      rds_stats_t *stats;
 {
     if (stats == NULL)    /* stats structure must be already allocated */
 	return EBAD_ARGS;
 
-    BCOPY(&RDS_STATS, stats, sizeof(rds_stats_t));
+    BCOPY(&RDS_STATS(seg_hdr->heap_hdr), stats, sizeof(rds_stats_t));
     return 0;
 }
 
-int rds_trace_on(FILE *file)
+int rds_trace_on(rvm_seg_hdr_t *seg_hdr, FILE *file)
 {
-  assert(HEAP_INIT);
+  assert(HEAP_INIT(seg_hdr->heap_hdr));
   assert(file);
   rds_tracing = TRUE;
   rds_tracing_file = file;
@@ -124,100 +126,121 @@ int rds_trace_on(FILE *file)
 
 
 int
-rds_trace_off ()
+rds_trace_off (rvm_seg_hdr_t *seg_hdr)
 {
-  assert(HEAP_INIT);
+  assert(HEAP_INIT(seg_hdr->heap_hdr));
   RDS_LOG("rdstrace: tracing off\n");
   rds_tracing = FALSE;
   return 0;
 }
 
-void rds_trace_dump_stats()
+void rds_trace_dump_stats(rvm_seg_hdr_t *seg_hdr)
 {
   RDS_LOG("rdstrace: start dump_stats\n");
-  RDS_LOG("rdstrace: Free_bytes \t %x\n", RDS_STATS.freebytes);
+  RDS_LOG("rdstrace: Free_bytes \t %x\n", RDS_STATS(seg_hdr->heap_hdr).freebytes);
   RDS_LOG("rdstrace: Alloced_bytes\t %x\n",
-		       RDS_STATS.mallocbytes);
-  RDS_LOG("rdstrace: Mallocs \t %d\n", RDS_STATS.malloc);
-  RDS_LOG("rdstrace: Frees \t %d\n",  RDS_STATS.free);
-  RDS_LOG("rdstrace: Preallocs \t %d\n",  RDS_STATS.prealloc);
-  RDS_LOG("rdstrace: Hits \t\t %d\n",  RDS_STATS.hits);
-  RDS_LOG("rdstrace: Misses \t %d\n",  RDS_STATS.misses);
-  RDS_LOG("rdstrace: Large_Hits \t %d\n",  RDS_STATS.large_hits);
+		       RDS_STATS(seg_hdr->heap_hdr).mallocbytes);
+  RDS_LOG("rdstrace: Mallocs \t %d\n", RDS_STATS(seg_hdr->heap_hdr).malloc);
+  RDS_LOG("rdstrace: Frees \t %d\n",  RDS_STATS(seg_hdr->heap_hdr).free);
+  RDS_LOG("rdstrace: Preallocs \t %d\n",  RDS_STATS(seg_hdr->heap_hdr).prealloc);
+  RDS_LOG("rdstrace: Hits \t\t %d\n",  RDS_STATS(seg_hdr->heap_hdr).hits);
+  RDS_LOG("rdstrace: Misses \t %d\n",  RDS_STATS(seg_hdr->heap_hdr).misses);
+  RDS_LOG("rdstrace: Large_Hits \t %d\n",  RDS_STATS(seg_hdr->heap_hdr).large_hits);
   RDS_LOG("rdstrace: Large_Misses \t %d\n",
-		       RDS_STATS.large_misses);
-  RDS_LOG("rdstrace: Coalesces \t %d\n",  RDS_STATS.coalesce);
-  RDS_LOG("rdstrace: Merges \t %d\n", RDS_STATS.merged);
-  RDS_LOG("rdstrace: Not_Merged \t %d\n", RDS_STATS.unmerged);
-  RDS_LOG("rdstrace: Large_List %d\n", RDS_STATS.large_list);
+		       RDS_STATS(seg_hdr->heap_hdr).large_misses);
+  RDS_LOG("rdstrace: Coalesces \t %d\n",  RDS_STATS(seg_hdr->heap_hdr).coalesce);
+  RDS_LOG("rdstrace: Merges \t %d\n", RDS_STATS(seg_hdr->heap_hdr).merged);
+  RDS_LOG("rdstrace: Not_Merged \t %d\n", RDS_STATS(seg_hdr->heap_hdr).unmerged);
+  RDS_LOG("rdstrace: Large_List %d\n", RDS_STATS(seg_hdr->heap_hdr).large_list);
   RDS_LOG("rdstrace: stop dump_stats\n");
 }
 
-void rds_trace_dump_free_lists()
+void rds_trace_dump_free_lists(rvm_seg_hdr_t *seg_hdr)
 {
   int i, j;
   free_block_t *fbp, *ptr;
-  
+
   RDS_LOG("rdstrace: start dump_free_lists\n");
-  
-  for (i = 1; i < RDS_NLISTS + 1; i++) {
 
-    fbp = RDS_FREE_LIST[i].head;
-    
-    if (RDS_FREE_LIST[i].guard != FREE_LIST_GUARD)
+  for (i = 1; i < RDS_NLISTS(seg_hdr->heap_hdr) + 1; i++) {
+
+    fbp = RDS_FREE_LIST(seg_hdr->heap_hdr)[i].head;
+
+    if (RDS_FREE_LIST(seg_hdr->heap_hdr)[i].guard != FREE_LIST_GUARD)
       RDS_LOG("rdstrace: Error!!! Bad guard on list %d!!!\n", i);
-    
+
     if (fbp && (fbp->prev != (free_block_t *)NULL))
       RDS_LOG("rdstrace: Error!!! Non-null Initial prev pointer.\n");
-    
+
     j = 0;
     while (fbp != NULL) {
       j++;
 
-      if (i == RDS_MAXLIST) {
+      if (i == RDS_MAXLIST(seg_hdr->heap_hdr)) {
 	RDS_LOG("rdstrace: size %ld count 1\n", fbp->size);
       }
-      
+
       if (fbp->type != FREE_GUARD)
 	RDS_LOG("rdstrace: Error!!! Bad lowguard on block\n");
-      
-      if ((*BLOCK_END(fbp)) != END_GUARD)
+
+      if ((*BLOCK_END(fbp, seg_hdr->heap_hdr)) != END_GUARD)
 	RDS_LOG("rdstrace: Error!!! Bad highguard, %p=%lx\n",
-			     BLOCK_END(fbp), *BLOCK_END(fbp));
-      
+			     BLOCK_END(fbp, seg_hdr->heap_hdr), *BLOCK_END(fbp, seg_hdr->heap_hdr));
+
       ptr = fbp->next;
-      
+
       if (ptr && (ptr->prev != fbp))
 	RDS_LOG("rdstrace: Error!!! Bad chain link %p <-> %p\n",
 			     fbp, ptr);
-      
-      if (i != RDS_MAXLIST && fbp->size != i)
+
+      if (i != RDS_MAXLIST(seg_hdr->heap_hdr) && fbp->size != i)
 	RDS_LOG("rdstrace: Error!!! OBJECT IS ON WRONG LIST!!!!\n");
-      
+
       fbp = fbp->next;
     }
-    
-    if (i != RDS_MAXLIST)
+
+    if (i != RDS_MAXLIST(seg_hdr->heap_hdr))
       RDS_LOG("rdstrace: size %d count %d\n", i, j);
   }
   RDS_LOG("rdstrace: stop dump_free_lists\n");
 }
 
-int rds_trace_dump_heap(void)
+int rds_trace_dump_heap(rvm_seg_hdr_t *seg_hdr)
 {
-    assert(HEAP_INIT);
-    START_CRITICAL;
+    assert(HEAP_INIT(seg_hdr->heap_hdr));
+    START_CRITICAL(seg_hdr->heap_hdr);
     {
       RDS_LOG("rdstrace: start heap_dump\n");
-      RDS_LOG("rdstrace: version_string %s\n", RDS_VERSION_STAMP);
-      RDS_LOG("rdstrace: heaplength %ld\n", RDS_HEAPLENGTH);
-      RDS_LOG("rdstrace: chunk_size %ld\n", RDS_CHUNK_SIZE);
-      RDS_LOG("rdstrace: nlists %ld\n", RDS_NLISTS);
-      rds_trace_dump_stats();
-      RDS_LOG("rdstrace: maxlist %ld\n", RDS_MAXLIST);
-      rds_trace_dump_free_lists();
+      RDS_LOG("rdstrace: version_string %s\n", RDS_VERSION_STAMP(seg_hdr->heap_hdr));
+      RDS_LOG("rdstrace: heaplength %ld\n", RDS_HEAPLENGTH(seg_hdr->heap_hdr));
+      RDS_LOG("rdstrace: chunk_size %ld\n", RDS_CHUNK_SIZE(seg_hdr->heap_hdr));
+      RDS_LOG("rdstrace: nlists %ld\n", RDS_NLISTS(seg_hdr->heap_hdr));
+      rds_trace_dump_stats(seg_hdr);
+      RDS_LOG("rdstrace: maxlist %ld\n", RDS_MAXLIST(seg_hdr->heap_hdr));
+      rds_trace_dump_free_lists(seg_hdr);
       RDS_LOG("rdstrace: stop heap_dump\n");
     }
-    END_CRITICAL;
+    END_CRITICAL(seg_hdr->heap_hdr);
+    return 0;
+}
+
+int print_heap_hdr(rvm_seg_hdr_t *seg_hdr)
+{
+    assert(HEAP_INIT(seg_hdr->heap_hdr));
+    START_CRITICAL(seg_hdr->heap_hdr);
+    {
+      printf("rdstrace: start heap_dump\n");
+      printf("rdstrace: version_string %s\n", RDS_VERSION_STAMP(seg_hdr->heap_hdr));
+      printf("rdstrace: heaplength %ld\n", RDS_HEAPLENGTH(seg_hdr->heap_hdr));
+      printf("rdstrace: chunk_size %ld\n", RDS_CHUNK_SIZE(seg_hdr->heap_hdr));
+      printf("rdstrace: nlists %ld\n", RDS_NLISTS(seg_hdr->heap_hdr));
+      rds_trace_dump_stats(seg_hdr);
+      printf("rdstrace: maxlist %ld\n", RDS_MAXLIST(seg_hdr->heap_hdr));
+      rds_trace_dump_free_lists(seg_hdr);
+      printf("rdstrace: stop heap_dump\n");
+      printf("rdstrace: start address : %p\n", seg_hdr->heap_hdr->RecoverableHeapStartAddress);
+      printf("rdstrace: end address : %p\n", seg_hdr->heap_hdr->RecoverableHeapHighAddress);
+    }
+    END_CRITICAL(seg_hdr->heap_hdr);
     return 0;
 }
diff --git a/rvm/rds_util.c b/rvm/rds_util.c
index 4fe6f4b..fdb429b 100644
--- a/rvm/rds_util.c
+++ b/rvm/rds_util.c
@@ -19,7 +19,7 @@ Coda are listed in the file CREDITS.
 
 #include <stdio.h>
 #include "rds_private.h"
-    
+
 #ifndef ZERO
 #define ZERO 0
 #endif
@@ -40,7 +40,8 @@ enqueue(list, block, tid, err)
  */
 
 free_block_t *
-dequeue(list, tid, err)
+dequeue(seg_hdr, list, tid, err)
+     rvm_seg_hdr_t   *seg_hdr;
      free_list_t  *list;
      rvm_tid_t    *tid;
      int	   *err;
@@ -48,9 +49,9 @@ dequeue(list, tid, err)
     free_block_t *block = list->head;
     free_block_t *ptr;
     rvm_return_t rvmerr;
-    
+
     /* Take the block off the head of the list. */
-    rvmerr = rvm_set_range(tid, list, sizeof(free_list_t));
+    rvmerr = rvm_set_range(seg_hdr,tid, list, sizeof(free_list_t));
     if (rvmerr != RVM_SUCCESS) {
 	(*err) = (int) rvmerr;
 	return NULL;
@@ -58,14 +59,14 @@ dequeue(list, tid, err)
     ptr = list->head = block->next;
 
     if (ptr) {
-	rvmerr = rvm_set_range(tid, &(ptr->prev), sizeof(free_list_t *));
+	rvmerr = rvm_set_range(seg_hdr,tid, &(ptr->prev), sizeof(free_list_t *));
 	if (rvmerr != RVM_SUCCESS) {
 	    (*err) = (int) rvmerr;
 	    return NULL;
 	}
 	ptr->prev = (free_block_t *)NULL;
     }
-	
+
     *err = SUCCESS;
     return block;
 }
@@ -77,7 +78,8 @@ dequeue(list, tid, err)
  * is the first one on the list, prev isn't used.
  */
 int
-rm_from_list(list, bp, tid, err)
+rm_from_list(seg_hdr,list, bp, tid, err)
+     rvm_seg_hdr_t   *seg_hdr;
      free_list_t   *list;
      free_block_t  *bp;
      rvm_tid_t     *tid;
@@ -85,7 +87,7 @@ rm_from_list(list, bp, tid, err)
 {
     rvm_return_t rvmret;
     free_block_t *ptr;
-    
+
     /* If block is at the head of the list, dequeue will cleanly remove it. */
     if (bp == list->head) {
 	bp = dequeue(list, tid, err);
@@ -94,16 +96,16 @@ rm_from_list(list, bp, tid, err)
     } else {
 	/* Because we're not at the end, we know bp->prev is a valid pointer. */
 	ptr = bp->prev;
-	rvmret = rvm_set_range(tid, &(ptr->next), sizeof(free_block_t *));
+	rvmret = rvm_set_range(seg_hdr,tid, &(ptr->next), sizeof(free_block_t *));
 	if (rvmret != RVM_SUCCESS) {
 	    (*err) = (int) rvmret;
 	    return ZERO;
 	}
 	ptr->next = bp->next;
-	
+
 	ptr = bp->next;
 	if (ptr) {
-	    rvmret = rvm_set_range(tid, &(ptr->prev), sizeof(free_block_t *));
+	    rvmret = rvm_set_range(seg_hdr,tid, &(ptr->prev), sizeof(free_block_t *));
 	    if (rvmret != RVM_SUCCESS) {
 		(*err) = (int) rvmret;
 		return ZERO;
@@ -118,55 +120,55 @@ rm_from_list(list, bp, tid, err)
 
 /* Print out the free list structure */
 int
-print_heap()
+print_heap(rvm_seg_hdr_t *seg_hdr)
 {
     int i, j;
     int total_size = 0;
     free_block_t *fbp, *ptr;
-    
-    if (!HEAP_INIT)	/* Make sure RecoverableHeapStartAddress is inited */
+
+    if (!HEAP_INIT(seg_hdr->heap_hdr))	/* Make sure RecoverableHeapStartAddress is inited */
 	return -1;
 
-    START_CRITICAL;
+    START_CRITICAL(seg_hdr->heap_hdr);
     {
 	printf("Heap starts at %lx, uses %ld sized chunks, and use %ld of %ld lists\n",
-	       (long)RecoverableHeapStartAddress, RDS_CHUNK_SIZE, 
-	       RDS_MAXLIST, RDS_NLISTS);
+	       (long)seg_hdr->heap_hdr->RecoverableHeapStartAddress, RDS_CHUNK_SIZE(seg_hdr->heap_hdr),
+	       RDS_MAXLIST(seg_hdr->heap_hdr), RDS_NLISTS(seg_hdr->heap_hdr));
 
-	for (i = 1; i < RDS_NLISTS + 1; i++) {
-	    printf("list %d %c\n",i, ((i == RDS_MAXLIST)?'+':' '));
-	    fbp = RDS_FREE_LIST[i].head;
+	for (i = 1; i < RDS_NLISTS(seg_hdr->heap_hdr) + 1; i++) {
+	    printf("list %d %c\n",i, ((i == RDS_MAXLIST(seg_hdr->heap_hdr))?'+':' '));
+	    fbp = RDS_FREE_LIST(seg_hdr->heap_hdr)[i].head;
 
-	    if (RDS_FREE_LIST[i].guard != FREE_LIST_GUARD)
+	    if (RDS_FREE_LIST(seg_hdr->heap_hdr)[i].guard != FREE_LIST_GUARD)
 		printf("Bad guard on list %d!!!\n", i);
 
 	    if (fbp && (fbp->prev != (free_block_t *)NULL))
 		printf("Non-null Initial prev pointer.\n");
-	    
+
 	    j = 1;
 	    while (fbp != NULL) {
-		printf("%d	block %lx, size %ld\n", j++, (long)fbp, 
+		printf("%d	block %lx, size %ld\n", j++, (long)fbp,
 		       fbp->size);
 		total_size += fbp->size;
-	    
+
 		if (fbp->type != FREE_GUARD)
 		    printf("Bad lowguard on block\n");
-		if ((*BLOCK_END(fbp)) != END_GUARD)
-		    printf("Bad highguard, %p=%lx\n", BLOCK_END(fbp), 
-						      *BLOCK_END(fbp));
+		if ((*BLOCK_END(fbp, seg_hdr->heap_hdr)) != END_GUARD)
+		    printf("Bad highguard, %p=%lx\n", BLOCK_END(fbp, seg_hdr->heap_hdr),
+						      *BLOCK_END(fbp, seg_hdr->heap_hdr));
 		ptr = fbp->next;
 		if (ptr && (ptr->prev != fbp))
-		    printf("Bad chain link %lx <-> %lx\n", (long)fbp, 
+		    printf("Bad chain link %lx <-> %lx\n", (long)fbp,
 			   (long)ptr);
-		if (i != RDS_MAXLIST && fbp->size != i)
+		if (i != RDS_MAXLIST((seg_hdr->heap_hdr)) && fbp->size != i)
 		    printf("OBJECT IS ON WRONG LIST!!!!\n");
-		    
+
 		fbp = fbp->next;
 	    }
 	}
     }
-    END_CRITICAL;
-    
+    END_CRITICAL(seg_hdr->heap_hdr);
+
     printf("Sum of sizes of objects in free lists is %d.\n", total_size);
     return 0;
 }
@@ -177,53 +179,55 @@ print_heap()
  */
 
 free_block_t *
-get_block(size, tid, err)
+get_block(seg_hdr, size, tid, err)
+      rvm_seg_hdr_t *seg_hdr;
       int       size;
       rvm_tid_t *tid;
       int	*err;
 {
-    int list = ((size >= RDS_MAXLIST)?RDS_MAXLIST:size);
-    
+    int list = ((size >= RDS_MAXLIST(seg_hdr->heap_hdr))?RDS_MAXLIST(seg_hdr->heap_hdr):size);
+
     /* Check the guard on the list. */
-    if (RDS_FREE_LIST[list].guard != FREE_LIST_GUARD) {
+    if (RDS_FREE_LIST(seg_hdr->heap_hdr)[list].guard != FREE_LIST_GUARD) {
 	*err = ECORRUPT;
 	return NULL;
     }
-    
+
     /* Update stats. Don't need a setrange, caller should have done that. */
-    if ((RDS_FREE_LIST[list].head == NULL) ||	   /* For smaller blocks */
-	(RDS_FREE_LIST[list].head->size != size)) { /* In case of large block */
+    if ((RDS_FREE_LIST(seg_hdr->heap_hdr)[list].head == NULL) ||	   /* For smaller blocks */
+	(RDS_FREE_LIST(seg_hdr->heap_hdr)[list].head->size != size)) { /* In case of large block */
 	/* A block isn't available so we need to split one. */
-	if (list < RDS_MAXLIST)
-	    RDS_STATS.misses++;
+	if (list < RDS_MAXLIST(seg_hdr->heap_hdr))
+	    RDS_STATS(seg_hdr->heap_hdr).misses++;
 	else
-	    RDS_STATS.large_misses++;
-	
-	return split(size, tid, err);
+	    RDS_STATS(seg_hdr->heap_hdr).large_misses++;
+
+	return split(seg_hdr, size, tid, err);
     }
 
-    assert(RDS_FREE_LIST[list].head->size == size); /* Sanity check */
+    assert(RDS_FREE_LIST(seg_hdr->heap_hdr)[list].head->size == size); /* Sanity check */
 
-    if (list < RDS_MAXLIST)
-	RDS_STATS.hits++;	
+    if (list < RDS_MAXLIST(seg_hdr->heap_hdr))
+	RDS_STATS(seg_hdr->heap_hdr).hits++;
     else
-	RDS_STATS.large_hits++;	
-	
+	RDS_STATS(seg_hdr->heap_hdr).large_hits++;
+
 
     /* Fbp could be null indicating an error occured in dequeue. Let
        the calling routine handle this error. */
-    return dequeue(&RDS_FREE_LIST[list], tid, err);
+    return dequeue(seg_hdr, &RDS_FREE_LIST(seg_hdr->heap_hdr)[list], tid, err);
 }
 
 int
-put_block(bp, tid, err)
+put_block(seg_hdr,bp, tid, err)
+     rvm_seg_hdr_t   *seg_hdr;
      free_block_t *bp;
      rvm_tid_t    *tid;
      int	  *err;
 {
     rvm_return_t rvmerr;
-    int size = (((bp->size) >= RDS_MAXLIST)?RDS_MAXLIST:(bp->size));
-    free_list_t *list = &RDS_FREE_LIST[size];
+    int size = (((bp->size) >= RDS_MAXLIST(seg_hdr->heap_hdr))?RDS_MAXLIST(seg_hdr->heap_hdr):(bp->size));
+    free_list_t *list = &RDS_FREE_LIST(seg_hdr->heap_hdr)[size];
     free_block_t *ptr;
 
     /* Check the guard on the list. */
@@ -231,9 +235,9 @@ put_block(bp, tid, err)
 	*err = ECORRUPT;
 	return -1;
     }
-    
+
     /* Add the block to the head of the list */
-    rvmerr = rvm_set_range(tid, bp, sizeof(free_block_t));
+    rvmerr = rvm_set_range(seg_hdr,tid, bp, sizeof(free_block_t));
     if (rvmerr != RVM_SUCCESS) {
 	(*err) = (int) rvmerr;
 	return -1;
@@ -244,22 +248,22 @@ put_block(bp, tid, err)
     /* Make the old head of the list point to the new block. */
     ptr = bp->next;
     if (ptr) {
-	rvmerr = rvm_set_range(tid, &(ptr->prev), sizeof(free_block_t *));
+	rvmerr = rvm_set_range(seg_hdr,tid, &(ptr->prev), sizeof(free_block_t *));
 	if (rvmerr != RVM_SUCCESS) {
 	    (*err) = (int) rvmerr;
 	    return -1;
 	}
 	ptr->prev = bp;
     }
-	
+
     /* Make the head point to the freed block */
-    rvmerr = rvm_set_range(tid, list, sizeof(free_list_t));
+    rvmerr = rvm_set_range(seg_hdr,tid, list, sizeof(free_list_t));
     if (rvmerr != RVM_SUCCESS) {
 	(*err) = (int) rvmerr;
 	return -1;
     }
     list->head = bp;
-    
+
     (*err) = SUCCESS;
     return 0;
 }
diff --git a/rvm/rds_zap.c b/rvm/rds_zap.c
index 55546fa..2fef7b7 100644
--- a/rvm/rds_zap.c
+++ b/rvm/rds_zap.c
@@ -19,13 +19,13 @@ Coda are listed in the file CREDITS.
 #include <stdlib.h>
 #include <stdio.h>
 #include "rds_private.h"
-    
+
 /*
  * Put the heap in the first, or lower address range, and the statics in the
  * upper address range.
  */
 int
-rds_zap_heap(DevName, DevLength, startAddr, staticLength, heapLength, nlists, chunkSize, err)
+rds_zap_heap(DevName, DevLength, startAddr, staticLength, heapLength, nlists, chunkSize, err, seg_hdr)
      char 		*DevName;
      rvm_offset_t 	DevLength;
      char  		*startAddr;
@@ -34,12 +34,18 @@ rds_zap_heap(DevName, DevLength, startAddr, staticLength, heapLength, nlists, ch
      unsigned long 	nlists;
      unsigned long 	chunkSize;
      int		*err;
+     rvm_seg_hdr_t      *seg_hdr;
 {
     rvm_region_def_t regions[2], *loadregions = NULL;
     rvm_tid_t *tid = NULL;
     unsigned long n_loadregions;
     rvm_return_t rvmret;
-    
+
+    if(startAddr == NULL) {
+        startAddr = rvm_get_vm_addr(heapLength + staticLength + RVM_SEGMENT_HDR_SIZE);
+        assert(startAddr != NULL);
+    }
+
     memset(regions, 0, 2 * sizeof(rvm_region_def_t));
     regions[0].length = heapLength;
     regions[0].vmaddr = startAddr;
@@ -49,8 +55,12 @@ rds_zap_heap(DevName, DevLength, startAddr, staticLength, heapLength, nlists, ch
     /* Determine the length of the segment, and create a region which makes the
      * rest of it air. */
 
+    /* @TODO: move to segment header */
+    seg_hdr->heap_hdr = (heap_def_t *) malloc(sizeof(heap_def_t));
+    init_rvm_seg_region_tree(seg_hdr);
+
     /* Create the segments */
-    rvmret = rvm_create_segment(DevName, DevLength, NULL, 2, regions);
+    rvmret = rvm_create_segment(DevName, DevLength, NULL, 2, regions, seg_hdr);
     if (rvmret != RVM_SUCCESS) {
 	(*err) = (int) rvmret;
 	return -1;
@@ -61,9 +71,9 @@ rds_zap_heap(DevName, DevLength, startAddr, staticLength, heapLength, nlists, ch
 	(*err) = (int) rvmret;
 	return -1;
     }
-    
+
     /* Map in the appropriate structures by calling Rvm_Load_Segment. */
-    rvmret = rvm_load_segment(DevName, DevLength, NULL, &n_loadregions, &loadregions);
+    rvmret = rvm_load_segment(DevName, DevLength, NULL, &n_loadregions, &loadregions, seg_hdr);
     if (rvmret != RVM_SUCCESS) {
 	(*err) = (int) rvmret;
         return -1;
@@ -72,26 +82,26 @@ rds_zap_heap(DevName, DevLength, startAddr, staticLength, heapLength, nlists, ch
     /* Total sanity checks -- since we just created the segment */
     if (n_loadregions != 2) {
 	*err = EBAD_SEGMENT_HDR;
-        rvm_release_segment(n_loadregions, &loadregions);
+        rvm_release_segment(n_loadregions, &loadregions, seg_hdr);
         return -1;
     }
-    
+
     /* Start a transaction to initialize the heap */
     tid = rvm_malloc_tid();
     rvmret = rvm_begin_transaction(tid, restore);
     if (rvmret != RVM_SUCCESS) {
 	(*err) = (int) rvmret;
         rvm_free_tid(tid);
-        rvm_release_segment(n_loadregions, &loadregions);
+        rvm_release_segment(n_loadregions, &loadregions, seg_hdr);
         return -1;
     }
 
     *err = SUCCESS; 		/* Initialize the error value */
-    rds_init_heap(startAddr, heapLength, chunkSize, nlists, tid, err);
+    rds_init_heap(seg_hdr, startAddr, heapLength, chunkSize, nlists, tid, err);
     if (*err != SUCCESS) {
 	rvm_abort_transaction(tid);
         rvm_free_tid(tid);
-        rvm_release_segment(n_loadregions, &loadregions);
+        rvm_release_segment(n_loadregions, &loadregions, seg_hdr);
         return -1;
     }
 
@@ -106,8 +116,7 @@ rds_zap_heap(DevName, DevLength, startAddr, staticLength, heapLength, nlists, ch
     rvm_flush();
     rvm_truncate();
 
-    rvm_release_segment(n_loadregions, &loadregions);
+    rvm_release_segment(n_loadregions, &loadregions, seg_hdr);
 
     return (*err == SUCCESS ? 0 : -1);
 }
-
diff --git a/rvm/rvm.h b/rvm/rvm.h
index abbd4d2..742e562 100644
--- a/rvm/rvm.h
+++ b/rvm/rvm.h
@@ -23,10 +23,9 @@ Coda are listed in the file CREDITS.
 */
 
 /*LINTLIBRARY*/
-#pragma once
 
-#ifndef __MERO_RVM_RVM_H__
-#define __MERO_RVM_RVM_H__
+/* permit multiple includes */
+#ifndef RVM_VERSION
 
 /* Version string for initialization */
 #define RVM_VERSION         "RVM Interface Version 1.3  7 Mar 1994"
@@ -149,6 +148,16 @@ typedef struct
     }
 rvm_offset_t;
 
+/* bcopy <=> memcpy, defs of syscalls */
+#ifdef __STDC__
+#define BCOPY(x,y,n)     memcpy((y),(x),(n))
+#define BZERO(x,n)       memset((x),0,(n))
+#else
+#define BCOPY(x,y,n)     bcopy((x),(y),(n))
+#define BZERO(x,n)       bzero((x),(n))
+#endif
+
+
 /* construct offset from two rvm_length_t sized quantities x,y
    -- this will construct an offset from two lengths even if
    8*sizeof(rvm_length_t) is > sizeof(rvm_offset_t); the "extra"
@@ -357,6 +366,31 @@ extern void rvm_init_region(rvm_region_t *region);
 extern rvm_region_t *rvm_copy_region(rvm_region_t *region);
 extern void rvm_free_region(rvm_region_t *region);
 
+
+/*  Listing/bundling of global variables used by segments
+    (allowing RVM code to be scalable) and passing it as an instance to RVM
+*/
+
+typedef struct rvm_page_entry rvm_page_entry_t;
+typedef struct rw_lock rw_lock_t;
+typedef struct heap_def heap_def_t;
+typedef struct heap_header heap_header_t;
+typedef struct tree_root tree_root_t;
+
+typedef struct rvm_seg_hdr
+    {
+        char                   *seg_name;
+        int                     seg_id;
+        rvm_page_entry_t       *rvm_allocations;
+        rvm_page_entry_t       *rvm_allocations_tail;
+
+        rw_lock_t              *region_tree_lock;
+        tree_root_t            *region_tree;
+
+        void                   *static_addr;
+        heap_def_t             *heap_hdr;
+    } rvm_seg_hdr_t;
+
 /*
         Main Function Declarations
 */
@@ -370,20 +404,25 @@ extern rvm_return_t rvm_initialize(const char *version, rvm_options_t *opts);
 /* shutdown RVM */
 extern rvm_return_t rvm_terminate (void);   /* no parameters */
 
+/* Return heap address */
+extern void *rds_heap_addr(rvm_seg_hdr_t *seg_hdr);
+
 /* map recoverable storage */
 extern rvm_return_t rvm_map(
+    rvm_seg_hdr_t           *seg_hdr,
     rvm_region_t         *region,       /* pointer to region descriptor */
     rvm_options_t        *options       /* optional ptr to option descriptor */
     );
 
 /* unmap recoverable storage */
-extern rvm_return_t rvm_unmap(rvm_region_t *region);
+extern rvm_return_t rvm_unmap(rvm_seg_hdr_t *seg_hdr, rvm_region_t *region);
 
 /* set RVM options */
 extern rvm_return_t rvm_set_options(rvm_options_t *options);
 
 /* query RVM options */
 extern rvm_return_t rvm_query(
+    rvm_seg_hdr_t          *seg_hdr,
     rvm_options_t       *options,       /* address of pointer to option
                                            descriptor [out] */
     rvm_region_t        *region         /* optional pointer to region descriptor */
@@ -397,6 +436,7 @@ extern rvm_return_t rvm_begin_transaction(
 
 /* declare a modification region for a transaction */
 extern rvm_return_t rvm_set_range(
+    rvm_seg_hdr_t          *seg_hdr,
     rvm_tid_t           *tid,           /* pointer to transaction identifier */
     void                *dest,          /* base address of modification range */
     rvm_length_t        length          /* length of modification range */
@@ -404,6 +444,7 @@ extern rvm_return_t rvm_set_range(
 
 /* modification of a region for a transaction */
 extern rvm_return_t rvm_modify_bytes(
+    rvm_seg_hdr_t          *seg_hdr,
     rvm_tid_t           *tid,           /* pointer to transaction identifier */
     void                *dest,          /* base address of modification range */
     const void          *src,           /* base address of source range */
@@ -463,9 +504,6 @@ extern rvm_offset_t rvm_sub_length_from_offset(
     rvm_length_t        length
     );
 
-// TODO
-typedef struct heap_header heap_header_t;
-
 /* private functions to support page rounding */
 
 extern rvm_length_t rvm_page_size ();
@@ -473,4 +511,4 @@ extern rvm_length_t rvm_page_mask ();
 extern rvm_offset_t rvm_rnd_offset_up_to_page(rvm_offset_t *x);
 extern rvm_offset_t rvm_rnd_offset_dn_to_page(rvm_offset_t *x);
 
-#endif /* __MERO_RVM_RVM_H__ */
+#endif /* RVM_VERSION */
diff --git a/rvm/rvm_createseg.c b/rvm/rvm_createseg.c
index 1263d64..c91e3e5 100644
--- a/rvm/rvm_createseg.c
+++ b/rvm/rvm_createseg.c
@@ -20,9 +20,9 @@ Coda are listed in the file CREDITS.
 #include <string.h>
 #include <assert.h>
 
-#include "rvm/rvm.h"
-#include "rvm/rvm_segment.h"
-#include "rvm/rvm_segment_private.h"
+#include "rvm.h"
+#include "rvm_segment.h"
+#include "rvm_segment_private.h"
 
 /* rvm_create_segment erases the old contents of the recoverable
  * segment, and write a new structure to it. The arguments specify the
@@ -31,12 +31,13 @@ Coda are listed in the file CREDITS.
  * used to exist in the segment will no longer be accessible.  */
 
 rvm_return_t
-rvm_create_segment(DevName, DevLength, options, nregions, regionDefs)
+rvm_create_segment(DevName, DevLength, options, nregions, regionDefs, seg_hdr)
      char 	    	*DevName;
      rvm_offset_t	DevLength;
      rvm_options_t  	*options;
      rvm_length_t	nregions;
      rvm_region_def_t   regionDefs[];
+     rvm_seg_hdr_t      *seg_hdr;
 {
     rvm_region_t *region = rvm_malloc_region();
     rvm_segment_hdr_t *hptr;
@@ -62,13 +63,13 @@ rvm_create_segment(DevName, DevLength, options, nregions, regionDefs)
     region->vmaddr = 0;
 
     /* allocate the address range for this region */
-    err = allocate_vm(&(region->vmaddr), region->length);
+    err = allocate_vm(seg_hdr, &(region->vmaddr), region->length);
     if (err != RVM_SUCCESS) {
 	rvm_free_region(region);
 	return err;
     }
 
-    err = rvm_map(region, options);
+    err = rvm_map(seg_hdr, region, options);
     if (err != RVM_SUCCESS) {
 	rvm_free_region(region);
 	return err; 	/* Some error condition exists, return the error code */
@@ -85,7 +86,7 @@ rvm_create_segment(DevName, DevLength, options, nregions, regionDefs)
     /* Set up the header region. This is always a fixed size. */
     hptr = (rvm_segment_hdr_t *) region->vmaddr;
 
-    err = rvm_set_range(tid, (char *)hptr, RVM_SEGMENT_HDR_SIZE);
+    err = rvm_set_range(seg_hdr, tid, (char *)hptr, RVM_SEGMENT_HDR_SIZE);
     if (err != RVM_SUCCESS) {
 	rvm_abort_transaction(tid);
 	rvm_free_tid(tid);
@@ -126,13 +127,24 @@ rvm_create_segment(DevName, DevLength, options, nregions, regionDefs)
     }
 
     /* The segment should now be all set to go, clean up. */
-    err = rvm_unmap(region);
+    err = rvm_unmap(seg_hdr, region);
     if (err != RVM_SUCCESS)
 	printf("create_segment unmap failed %s\n", rvm_return(err));
 
-    deallocate_vm(region->vmaddr, region->length);
+    deallocate_vm(seg_hdr, region->vmaddr, region->length);
 
     rvm_free_region(region);
     return err;
 }
 
+char *rvm_get_vm_addr(unsigned long length)
+{
+        char *addr = NULL;
+        rvm_bool_t ret = rvm_false;
+
+        ret = find_available_vm_addr(&addr, length);
+
+        assert(ret == rvm_true);
+
+        return addr;
+}
diff --git a/rvm/rvm_debug.c b/rvm/rvm_debug.c
index 8823abe..224038a 100644
--- a/rvm/rvm_debug.c
+++ b/rvm/rvm_debug.c
@@ -25,7 +25,7 @@ Coda are listed in the file CREDITS.
 #include <sys/types.h>
 #include <sys/uio.h>
 #include <stdio.h>
-#include "rvm/rvm_private.h"
+#include "rvm_private.h"
 
 /* globals */
 
@@ -45,7 +45,8 @@ extern long             cache_type_sizes[NUM_CACHE_TYPES];
 
 /* main structures roots */
 extern list_entry_t     seg_root;       /* segment list */
-extern tree_root_t      region_tree;   /* mapped regions tree */
+/*extern tree_node_t      *region_tree;   *//* mapped regions tree */
+tree_node_t      *region_tree;   /* mapped regions tree */
 extern list_entry_t     page_list;      /* free page list */
 extern list_entry_t     log_root;       /* log list */
 
@@ -627,7 +628,7 @@ rvm_bool_t in_region_tree(addr)
 
     printf("Searching mapped region tree\n");
 
-    return search_mem_region(addr,(mem_region_t *)&region_tree);
+    return search_mem_region(addr,(mem_region_t *)region_tree);
     }
 /* */
 rvm_bool_t search_dev_region(addr,node)
diff --git a/rvm/rvm_io.c b/rvm/rvm_io.c
index 2b531a3..c00af4f 100644
--- a/rvm/rvm_io.c
+++ b/rvm/rvm_io.c
@@ -33,7 +33,7 @@ Coda are listed in the file CREDITS.
 #include <stdlib.h>
 #include "rvm_private.h"
 
-#ifndef UIO_MAXIOV 
+#ifndef UIO_MAXIOV
 #define UIO_MAXIOV 16
 #endif
 
@@ -69,9 +69,9 @@ static rvm_bool_t in_wrt_buf(char *addr, rvm_length_t len)
     char            *end_addr;
     char            *buf_end_addr;
 
-    if (default_log == NULL) 
+    if (default_log == NULL)
 	return rvm_false;
-    if (default_log->dev.wrt_buf == NULL) 
+    if (default_log->dev.wrt_buf == NULL)
 	return rvm_false;
 
     end_addr = RVM_ADD_LENGTH_TO_ADDR(addr,len);
@@ -86,7 +86,7 @@ static rvm_bool_t in_wrt_buf(char *addr, rvm_length_t len)
     return rvm_false;
 }
 
-/* seek to position if required: raw devices must 
+/* seek to position if required: raw devices must
    seek to a sector index. Sanity checks size of
    device against offset. */
 static long chk_seek(device_t *dev, rvm_offset_t *offset)
@@ -146,14 +146,14 @@ long set_dev_char(device_t *dev, rvm_offset_t *dev_length)
         break;
 	/* Linux doesn't have BSD style raw character devices.
 	   However, one can write to the block device directly.
-	   This takes care, since we must sync it as if we 
-	   do file IO.  We use dev->type == S_IFBLK 
+	   This takes care, since we must sync it as if we
+	   do file IO.  We use dev->type == S_IFBLK
 	   to achieve this. The result could be good, since the
-	   buffer cache will flush the blocks to the disk more 
-	   efficiently than individual synchronous writes would 
+	   buffer cache will flush the blocks to the disk more
+	   efficiently than individual synchronous writes would
 	   take place.
                      */
-      case S_IFBLK:  
+      case S_IFBLK:
 	dev->raw_io = rvm_true;
 	break;
       case S_IFREG:
@@ -260,9 +260,9 @@ long read_dev(dev,offset,dest,length)
     retval = 0;
     while (length != 0)
         {
-        if (length <= rvm_max_read_len) 
+        if (length <= rvm_max_read_len)
 		read_len = length;
-        else 
+        else
 		read_len = rvm_max_read_len;
 	nbytes=read((int)dev->handle,dest,(int)read_len);
         if (nbytes < 0) {
@@ -309,7 +309,7 @@ long write_dev(dev,offset,src,length,sync)
 
     /* seek if necessary */
     errno = 0;
-    if ((retval = chk_seek(dev,offset)) < 0) 
+    if ((retval = chk_seek(dev,offset)) < 0)
 	return retval;
     last_position = RVM_ADD_LENGTH_TO_OFFSET(dev->last_position,
                                              length);
@@ -349,7 +349,7 @@ static long gather_write_file(dev,offset,wrt_len)
     long            retval;             /* kernel return value */
     long            iov_index = 0;      /* index of current iov entry */
     int             count;              /* iov count for Unix i/o */
- 
+
     assert(((dev == &default_log->dev) && (!rvm_utlsw)) ?
            (!LOCK_FREE(default_log->dev_lock)) : 1);
 
diff --git a/rvm/rvm_loadseg.c b/rvm/rvm_loadseg.c
index 98dc179..1390b4f 100644
--- a/rvm/rvm_loadseg.c
+++ b/rvm/rvm_loadseg.c
@@ -17,12 +17,12 @@ Coda are listed in the file CREDITS.
 
 #include <stdlib.h>
 #include <string.h>
-#include "rvm/rvm.h"
-#include "rvm/rvm_segment.h"
-#include "rvm/rvm_segment_private.h"
+#include "rvm.h"
+#include "rvm_segment.h"
+#include "rvm_segment_private.h"
 
 /* from rvm_private.h */
-rvm_bool_t rvm_register_page(char *vmaddr, rvm_length_t length);
+rvm_bool_t rvm_register_page(rvm_seg_hdr_t *seg_hdr, char *vmaddr, rvm_length_t length);
 
 /* Global variables */
 
@@ -42,7 +42,7 @@ char *rds_startaddr;
  */
 rvm_return_t
 rvm_load_segment(char *DevName, rvm_offset_t DevLength, rvm_options_t *options,
-		 unsigned long *nregions, rvm_region_def_t **regions)
+		 unsigned long *nregions, rvm_region_def_t **regions, rvm_seg_hdr_t *seg_hdr)
 {
     rvm_region_t *region = rvm_malloc_region();
     rvm_region_t *hdr_region = rvm_malloc_region();
@@ -61,14 +61,14 @@ rvm_load_segment(char *DevName, rvm_offset_t DevLength, rvm_options_t *options,
 
     hdr_region->vmaddr = NULL;
     if (!rvm_map_private) {
-        err = allocate_vm(&(hdr_region->vmaddr), hdr_region->length);
+        err = allocate_vm(seg_hdr, &(hdr_region->vmaddr), hdr_region->length);
 	if (err != RVM_SUCCESS)
 	    return err;
     }
     /* else, as vmaddr is NULL, the segment will be pre-allocated and
      * registered by rvm_map->establish_range->round_region->page_alloc -JH */
 
-    err = rvm_map(hdr_region,options);
+    err = rvm_map(seg_hdr, hdr_region,options);
     if (err != RVM_SUCCESS)
 	return err;    /* Some error condition exists, return the error code */
 
@@ -105,26 +105,26 @@ rvm_load_segment(char *DevName, rvm_offset_t DevLength, rvm_options_t *options,
 	    /* HACK */ rds_rvmsize += region->length; /* HACK */
 
 	    if (!rvm_map_private) {
-	        err = allocate_vm(&(region->vmaddr), region->length);
+	        err = allocate_vm(seg_hdr, &(region->vmaddr), region->length);
 		if (err != RVM_SUCCESS)
 		    return err;
 	    } else
-	      if (!rvm_register_page(region->vmaddr, region->length))
+	      if (!rvm_register_page(seg_hdr, region->vmaddr, region->length))
 		return RVM_EINTERNAL;
 
-	    err = rvm_map(region, options);
+	    err = rvm_map(seg_hdr, region, options);
 	    if (err != RVM_SUCCESS)
 		return err; 	/* Some error condition exists, abort */
 
  	}
 
     /* Clean up, we no longer need the header region */
-    switch (err = rvm_unmap(hdr_region)) {
+    switch (err = rvm_unmap(seg_hdr, hdr_region)) {
       case RVM_EREGION:
       case RVM_EUNCOMMIT:
       case RVM_ENOT_MAPPED:
       case RVM_ERANGE:
-	deallocate_vm(hdr_region->vmaddr, hdr_region->length);
+	deallocate_vm(seg_hdr, hdr_region->vmaddr, hdr_region->length);
 	return err;
 	break;
       default:
@@ -132,7 +132,7 @@ rvm_load_segment(char *DevName, rvm_offset_t DevLength, rvm_options_t *options,
 	break;
     }
 
-    err = deallocate_vm(hdr_region->vmaddr, hdr_region->length);
+    err = deallocate_vm(seg_hdr, hdr_region->vmaddr, hdr_region->length);
 
     rvm_free_region(hdr_region);
     return err;
diff --git a/rvm/rvm_logrecovr.c b/rvm/rvm_logrecovr.c
index cfd8a95..9de2c40 100644
--- a/rvm/rvm_logrecovr.c
+++ b/rvm/rvm_logrecovr.c
@@ -95,7 +95,7 @@ static void monitor_vmaddr(nv_addr,nv_len,nv_data,nv_offset,rec_hdr,msg)
                          rvm_chk_vec[i].vmaddr,rvm_chk_vec[i].length);
         last_nv_addr =
             (rvm_length_t)RVM_ADD_LENGTH_TO_ADDR(nv_addr,nv_len);
-        
+
         if ((((rvm_length_t)rvm_chk_vec[i].vmaddr
               >= (rvm_length_t)nv_addr)
              && ((rvm_length_t)rvm_chk_vec[i].vmaddr < last_nv_addr))
@@ -120,7 +120,7 @@ rvm_return_t alloc_log_buf(log)
     {
     log_buf_t       *log_buf = &log->log_buf; /* log buffer descriptor */
 
-    if ((log_buf->buf=page_alloc(log_buf->length)) == NULL)
+    if ((log_buf->buf = page_alloc(log_buf->length)) == NULL)
         return RVM_ENO_MEMORY;
 #ifdef SPECIAL_DEBUG
     if ((log_buf->shadow_buf=page_alloc(log_buf->length)) == NULL)
@@ -161,7 +161,7 @@ void free_log_buf(log)
 
     if (log_buf->buf != NULL)
         {
-        page_free(log_buf->buf,log_buf->length);
+        page_free(NULL, log_buf->buf,log_buf->length);
         log_buf->buf = NULL;
         log_buf->length = 0;
         RVM_ZERO_OFFSET(log_buf->buf_len);
@@ -170,7 +170,7 @@ void free_log_buf(log)
 
     if (log_buf->aux_buf != NULL)
         {
-        page_free(log_buf->aux_buf,log_buf->aux_length);
+        page_free(NULL, log_buf->aux_buf,log_buf->aux_length);
         log_buf->aux_buf = NULL;
         log_buf->aux_length = 0;
         }
@@ -470,9 +470,9 @@ rvm_return_t load_aux_buf(log,log_offset,length,aux_ptr,
         }
     else
         *data_len = length;
-    
+
     /* lock device and allow swap if necessary */
-    if (synch) 
+    if (synch)
         {
         if (!rvm_no_yield) cthread_yield(); /* allow swap now */
         assert(log->trunc_thread == cthread_self());
@@ -545,7 +545,7 @@ rvm_bool_t chk_hdr_currency(log,rec_hdr)
     if ((status->first_rec_num != 0) &&
         (rec_hdr->rec_num < status->first_rec_num))
         return rvm_false;               /* obsolete record */
-    
+
     /* be sure record written after previous truncation & before this one */
     if (TIME_LSS(rec_hdr->timestamp,status->prev_trunc)
         || TIME_GTR(rec_hdr->timestamp,status->last_trunc))
@@ -677,7 +677,7 @@ rvm_return_t scan_nv_forward(log,synch)
     rvm_offset_t    offset;             /* offset calculation temp */
     rec_hdr_t       *rec_hdr;           /* temporary cast for record header */
     rvm_return_t    retval;             /* return value */
- 
+
     /* see if new header is entirely within buffer */
     if ((log_buf->ptr+sizeof(rec_hdr_t)) >= log_buf->r_length)
         {
@@ -704,7 +704,7 @@ rvm_return_t scan_nv_forward(log,synch)
         if ((retval=refill_buffer(log,FORWARD,synch))
             != RVM_SUCCESS) return retval;
         }
- 
+
     return RVM_SUCCESS;
     }
 /* get previous new value range by reverse scan of transaction record
@@ -752,7 +752,7 @@ rvm_return_t scan_nv_reverse(log,synch)
             offset = RVM_SUB_LENGTH_FROM_OFFSET(offset,len);
             if ((retval=init_buffer(log,&offset,REVERSE,synch))
                 != RVM_SUCCESS) return retval;
-            log_buf->ptr -= sizeof(nv_range_t);           
+            log_buf->ptr -= sizeof(nv_range_t);
             }
         }
     else log_buf->ptr -= len;
@@ -761,7 +761,7 @@ rvm_return_t scan_nv_reverse(log,synch)
     if (rec_hdr->struct_id == trans_hdr_id)
         return RVM_SUCCESS;
     assert(rec_hdr->struct_id == nv_range_id);
- 
+
     return RVM_SUCCESS;
     }
 /* validate record in buffer in forward scan */
@@ -782,7 +782,7 @@ rvm_return_t validate_rec_forward(log,synch)
         {
         /* no, re-init buffer */
         end_offset = RVM_ADD_LENGTH_TO_OFFSET(log_buf->offset,
-                                              log_buf->ptr); 
+                                              log_buf->ptr);
        if ((retval=init_buffer(log,&end_offset,FORWARD,synch))
            != RVM_SUCCESS) return retval;
         }
@@ -914,17 +914,17 @@ rvm_return_t scan_wrap_reverse(log,synch)
     /* scan for wrap marker */
     /* for the purpose of locating the wrap marker, we use the (duplicated)
        struct_id2 which, while positions at the end of the record, guarantees
-       that we must interpret it first, otherwise, we may possibly 
-       mis-interpret other field of the record to have a struct_id of 
+       that we must interpret it first, otherwise, we may possibly
+       mis-interpret other field of the record to have a struct_id of
        log_wrap_id ! */
     for (tmp_ptr = (log_buf->ptr - sizeof(log_wrap_t));
          tmp_ptr >= 0; tmp_ptr -= sizeof(rvm_length_t))
         {
         log_wrap = (log_wrap_t *)&log_buf->buf[tmp_ptr];
-        if (log_wrap->struct_id2 == log_wrap_id) 
+        if (log_wrap->struct_id2 == log_wrap_id)
             {
 		assert( (log_wrap->rec_hdr.struct_id==log_wrap_id) || rvm_utlsw );
-		/* XXXX fix this */ 
+		/* XXXX fix this */
 #if 0
 		if (!((log_wrap->struct_id == log_wrap_id) || rvm_utlsw)) {
 		    printf("not true!\n");
@@ -1296,7 +1296,7 @@ rvm_return_t locate_tail(log)
             status->last_write = rec_hdr->timestamp;
             if (rec_hdr->struct_id == log_wrap_id)
                 status->wrap_time = rec_hdr->timestamp;
-            
+
             if (rec_hdr->struct_id == trans_hdr_id)
                 {                       /* transaction found */
                 status->first_uname = ((trans_hdr_t *)
@@ -1318,7 +1318,7 @@ rvm_return_t locate_tail(log)
             }
             while (log_buf->ptr != -1); /* tail found, no transactions */
 
-    /* re-init scanner sequence checking state since small logs can cause 
+    /* re-init scanner sequence checking state since small logs can cause
        a few records to be rescanned and re-init read buffer at tail
     */
     tail = status->log_tail;
@@ -1423,7 +1423,7 @@ rvm_return_t enter_seg_dict(log,seg_code)
 
     /* lengthen seg_dict_vec if necessary */
     if (log->seg_dict_len < seg_code)
-        {                              
+        {
         new_dict_size = seg_code*sizeof(seg_dict_t);
         old_dict_size = log->seg_dict_len*sizeof(seg_dict_t);
         log->seg_dict_vec = (seg_dict_t *)
@@ -1753,7 +1753,7 @@ static rvm_return_t do_trans(log,skip_trans)
     {
     log_status_t    *status = &log->status; /* status descriptor */
     log_buf_t       *log_buf = &log->log_buf; /* log buffer descriptor */
-    
+
     rec_hdr_t       *rec_hdr;           /* last record header scanned */
     rec_end_t       *rec_end;           /* end marker for transaction */
     trans_hdr_t     *trans_hdr;         /* transaction header ptr */
@@ -1944,7 +1944,7 @@ static rvm_return_t chk_wrap(log,force_wrap_chk,skip_trans)
 /* Recovery: phase 2 -- build modification trees, and
    construct dictionary of segment short names
 */
-#define X(a) 
+#define X(a)
 static rvm_return_t build_tree(log)
     log_t           *log;               /* log descriptor */
     {
@@ -2049,7 +2049,7 @@ static dev_region_t *pre_scan(log,tree)
     tree_root_t     *tree;              /* current tree root */
     {
     log_buf_t       *log_buf = &log->log_buf; /* log buffer descriptor */
-    dev_region_t    *last_node = NULL; 
+    dev_region_t    *last_node = NULL;
     dev_region_t    *node;              /* current change tree node */
     rvm_offset_t    temp;
 
@@ -2108,7 +2108,7 @@ static rvm_return_t disk_merge(log,node,preload)
     rvm_bool_t      was_preloaded = preload; /* save preload state */
 
     assert(log->trunc_thread == cthread_self());
-    assert((status->trunc_state & RVM_TRUNC_PHASES) 
+    assert((status->trunc_state & RVM_TRUNC_PHASES)
            == RVM_TRUNC_APPLY);
     assert(node->links.node.struct_id == dev_region_id);
 
@@ -2126,7 +2126,7 @@ static rvm_return_t disk_merge(log,node,preload)
             /* see how much to get in this pass & load aux_buf */
             if ((log_buf->length-buf_ptr) < node->length)
                 rw_length = log_buf->length-buf_ptr; /* fill log_buf */
-            else                      
+            else
                 rw_length = node->length; /* get all remaining */
             if ((retval=load_aux_buf(log,&node->log_offset,rw_length,
                                      &aux_ptr,&data_len,SYNCH,rvm_true))
@@ -2157,7 +2157,7 @@ static rvm_return_t disk_merge(log,node,preload)
                              &log_buf->buf[tmp_ptr],SECTOR_SIZE)) < 0)
                     return RVM_EIO;
                 assert(log->trunc_thread == cthread_self());
-                assert((status->trunc_state & RVM_TRUNC_PHASES) 
+                assert((status->trunc_state & RVM_TRUNC_PHASES)
                        == RVM_TRUNC_APPLY);
                 assert(rw_length == SECTOR_SIZE);
                 preload = rvm_true;
@@ -2208,7 +2208,7 @@ static rvm_return_t disk_merge(log,node,preload)
                                  SYNCH))
             < 0) return RVM_EIO;
         assert(log->trunc_thread == cthread_self());
-        assert((status->trunc_state & RVM_TRUNC_PHASES) 
+        assert((status->trunc_state & RVM_TRUNC_PHASES)
                == RVM_TRUNC_APPLY);
         assert(rw_length == log_buf->length);
         if (rvm_chk_len != 0)
@@ -2219,7 +2219,7 @@ static rvm_return_t disk_merge(log,node,preload)
             {
             cthread_yield();            /* allow reschedule */
             assert(log->trunc_thread == cthread_self());
-            assert((status->trunc_state & RVM_TRUNC_PHASES) 
+            assert((status->trunc_state & RVM_TRUNC_PHASES)
                    == RVM_TRUNC_APPLY);
             }
         log_buf->offset =
@@ -2289,7 +2289,7 @@ static rvm_return_t update_seg(log,seg_dict,seg_dev)
     /* sanity checks and initializations */
     assert(&log->dev != seg_dev);
     assert(log->trunc_thread == cthread_self());
-    assert((status->trunc_state & RVM_TRUNC_PHASES) 
+    assert((status->trunc_state & RVM_TRUNC_PHASES)
            == RVM_TRUNC_APPLY);
     rvm_num_nodes = seg_dict->mod_tree.n_nodes;
     rvm_max_depth = seg_dict->mod_tree.max_depth;
@@ -2301,7 +2301,7 @@ static rvm_return_t update_seg(log,seg_dict,seg_dev)
         {
         mutex_lock(&seg_dict->seg->dev_lock);
         assert(log->trunc_thread == cthread_self());
-        assert((status->trunc_state & RVM_TRUNC_PHASES) 
+        assert((status->trunc_state & RVM_TRUNC_PHASES)
                == RVM_TRUNC_APPLY);
         }
     while (seg_dict->mod_tree.root != NULL)
@@ -2334,7 +2334,7 @@ static rvm_return_t update_seg(log,seg_dict,seg_dev)
             {
             cthread_yield();
             assert(log->trunc_thread == cthread_self());
-            assert((status->trunc_state & RVM_TRUNC_PHASES) 
+            assert((status->trunc_state & RVM_TRUNC_PHASES)
                    == RVM_TRUNC_APPLY);
             }
         if ((r_length=read_dev(seg_dev,&log_buf->offset,
@@ -2344,7 +2344,7 @@ static rvm_return_t update_seg(log,seg_dict,seg_dev)
             goto err_exit;
             }
         assert(log->trunc_thread == cthread_self());
-        assert((status->trunc_state & RVM_TRUNC_PHASES) 
+        assert((status->trunc_state & RVM_TRUNC_PHASES)
                == RVM_TRUNC_APPLY);
         assert(r_length == log_buf->r_length);
 
@@ -2381,7 +2381,7 @@ static rvm_return_t update_seg(log,seg_dict,seg_dev)
             goto err_exit;
             }
         assert(log->trunc_thread == cthread_self());
-        assert((status->trunc_state & RVM_TRUNC_PHASES) 
+        assert((status->trunc_state & RVM_TRUNC_PHASES)
                == RVM_TRUNC_APPLY);
         assert(r_length == log_buf->r_length);
         /* do monitoring */
@@ -2405,7 +2405,7 @@ err_exit:
         {
         mutex_unlock(&seg_dict->seg->dev_lock);
         assert(log->trunc_thread == cthread_self());
-        assert((status->trunc_state & RVM_TRUNC_PHASES) 
+        assert((status->trunc_state & RVM_TRUNC_PHASES)
                == RVM_TRUNC_APPLY);
         }
     return retval;
@@ -2422,7 +2422,7 @@ rvm_return_t apply_mods(log)
     rvm_length_t    flags = O_RDWR;
 
     assert(log->trunc_thread == cthread_self());
-    assert((status->trunc_state & RVM_TRUNC_PHASES) 
+    assert((status->trunc_state & RVM_TRUNC_PHASES)
            == RVM_TRUNC_BUILD_TREE);
     status->trunc_state = (status->trunc_state & ~RVM_TRUNC_BUILD_TREE)
                            | RVM_TRUNC_APPLY;
@@ -2450,7 +2450,7 @@ rvm_return_t apply_mods(log)
                 return RVM_EIO;
                 }
             assert(log->trunc_thread == cthread_self());
-            assert((status->trunc_state & RVM_TRUNC_PHASES) 
+            assert((status->trunc_state & RVM_TRUNC_PHASES)
                    == RVM_TRUNC_APPLY);
             }
         else
@@ -2464,7 +2464,7 @@ rvm_return_t apply_mods(log)
         if ((retval=update_seg(log,seg_dict,seg_dev))
             != RVM_SUCCESS) return retval;
         assert(log->trunc_thread == cthread_self());
-        assert((status->trunc_state & RVM_TRUNC_PHASES) 
+        assert((status->trunc_state & RVM_TRUNC_PHASES)
                == RVM_TRUNC_APPLY);
 
         /* close segment device if in recovery */
@@ -2492,7 +2492,7 @@ static rvm_return_t status_update(log, new_1st_rec_num)
     rvm_return_t    retval = RVM_SUCCESS; /* return value */
 
     assert(log->trunc_thread == cthread_self());
-    assert((status->trunc_state & RVM_TRUNC_PHASES) 
+    assert((status->trunc_state & RVM_TRUNC_PHASES)
            == RVM_TRUNC_APPLY);
     status->trunc_state = (status->trunc_state & ~RVM_TRUNC_APPLY)
                            | RVM_TRUNC_UPDATE;
@@ -2501,7 +2501,7 @@ static rvm_return_t status_update(log, new_1st_rec_num)
     CRITICAL(log->dev_lock,             /* begin log device lock crit sec */
         {
         assert(log->trunc_thread == cthread_self());
-        assert((status->trunc_state & RVM_TRUNC_PHASES) 
+        assert((status->trunc_state & RVM_TRUNC_PHASES)
            == RVM_TRUNC_UPDATE);
         status->prev_trunc = status->last_trunc;
 
@@ -2513,7 +2513,7 @@ static rvm_return_t status_update(log, new_1st_rec_num)
             RVM_ZERO_OFFSET(status->prev_log_tail);
             status->first_rec_num = new_1st_rec_num;
             }
-        
+
         /* end timings */
         kretval= gettimeofday(&end_time,(struct timezone *)NULL);
         if (kretval != 0) goto err_exit;
@@ -2536,7 +2536,7 @@ static rvm_return_t status_update(log, new_1st_rec_num)
         retval = write_log_status(log,NULL);
 err_exit:;
         assert(log->trunc_thread == cthread_self());
-        assert((status->trunc_state & RVM_TRUNC_PHASES) 
+        assert((status->trunc_state & RVM_TRUNC_PHASES)
            == RVM_TRUNC_UPDATE);
         });                             /* end log device lock crit sec */
     if (kretval != 0) return RVM_EIO;
@@ -2602,7 +2602,7 @@ rvm_return_t log_recover(log,count,is_daemon,flag)
     int             kretval;
     rvm_bool_t      do_truncation = rvm_false;
     rvm_return_t    retval = RVM_SUCCESS;
-    rvm_length_t    new_1st_rec_num=0; 
+    rvm_length_t    new_1st_rec_num=0;
 X(start)
     CRITICAL(log->truncation_lock,      /* begin truncation lock crit sec */
         {
@@ -2683,7 +2683,7 @@ X(build_tree done)
             assert(log->trunc_thread == cthread_self());
             assert((status->trunc_state & RVM_TRUNC_PHASES)
                    == RVM_TRUNC_BUILD_TREE);
-	    
+
             kretval= gettimeofday(&end_time,(struct timezone *)NULL);
             if (kretval != 0) assert(0); /* return RVM_EIO; */
             end_time = sub_times(&end_time,&tmp_time);
@@ -2750,9 +2750,9 @@ rvm_return_t rvm_truncate()
 	rvm_return_t    retval;
 
 	/* initial checks */
-	if (bad_init()) 
+	if (bad_init())
 		return RVM_EINIT;
-	if (default_log == NULL) 
+	if (default_log == NULL)
 		return RVM_ELOG;
 
     /* flush any queued records */
diff --git a/rvm/rvm_map.c b/rvm/rvm_map.c
index 5d6dfb7..dd6ba5b 100644
--- a/rvm/rvm_map.c
+++ b/rvm/rvm_map.c
@@ -22,10 +22,6 @@ Coda are listed in the file CREDITS.
 *
 */
 
-#ifdef HAVE_CONFIG_H
-#include "config.h"
-#endif
-
 #ifdef __STDC__
 #include <stdlib.h>
 #else
@@ -46,7 +42,7 @@ Coda are listed in the file CREDITS.
 #include <unistd.h>
 #include <stdlib.h>
 #include <errno.h>
-#include "rvm/rvm_private.h"
+#include "rvm_private.h"
 
 #ifdef __CYGWIN32__
 #include <windows.h>
@@ -63,9 +59,6 @@ extern char         *rvm_errmsg;        /* internal error message buffer */
 list_entry_t        seg_root;           /* global segment list */
 rw_lock_t           seg_root_lock;      /* lock for segment list header & links */
 
-rw_lock_t           region_tree_lock;   /* lock for region tree */
-tree_root_t         region_tree;        /* root of mapped region tree */
-
 list_entry_t        page_list;          /* list of usable pages */
 RVM_MUTEX           page_list_lock;     /* lock for usable page list */
 rvm_length_t        page_size;          /* system page size */
@@ -82,8 +75,6 @@ void init_map_roots()
 {
     init_list_header(&seg_root,seg_id);
     init_rw_lock(&seg_root_lock);
-    init_rw_lock(&region_tree_lock);
-    init_tree_root(&region_tree);
     mutex_init(&seg_code_lock);
 
 #ifdef HAVE_MMAP
@@ -119,7 +110,7 @@ rvm_return_t bad_region(rvm_region)
 #define PAGE_ALLOC_DEFINED
 #include <sys/types.h>
 #include <sys/mman.h>
-#include "rvm/coda_mmap_anon.h"
+#include "coda_mmap_anon.h"
 
 /*
  * Page table management code
@@ -161,8 +152,15 @@ rvm_return_t bad_region(rvm_region)
 /* This is a doubly-linked list of allocated regions of memory. The regions
    are stored in increasing order, so that once you have passed the area
    where a questionable region has been stored, you can stop looking. */
-rvm_page_entry_t *rvm_allocations      = NULL; /* allocated pages */
-rvm_page_entry_t *rvm_allocations_tail = NULL; /* tail of list */
+
+rvm_bool_t init_rvm_seg_region_tree(rvm_seg_hdr_t *seg_hdr)
+{
+        seg_hdr->region_tree = (tree_root_t *)malloc(sizeof(tree_root_t));
+        init_tree_root(seg_hdr->region_tree);
+        seg_hdr->region_tree_lock =(rw_lock_t *)malloc(sizeof(rw_lock_t));
+        init_rw_lock(seg_hdr->region_tree_lock);
+        return rvm_true;
+}
 
 /*
  * rvm_register_page -- registers a page as being allocated.
@@ -172,10 +170,12 @@ rvm_page_entry_t *rvm_allocations_tail = NULL; /* tail of list */
  * TODO: should add optimization which coalesces page records.
  *       should round end up to be at end of page boundary.
  */
-rvm_bool_t rvm_register_page(char *vmaddr, rvm_length_t length)
+rvm_bool_t rvm_register_page(rvm_seg_hdr_t *seg_hdr, char *vmaddr, rvm_length_t length)
 {
     rvm_page_entry_t *bookmark, *entry;
     char *end = vmaddr + length - 1;
+    rvm_page_entry_t *rvm_allocations      = seg_hdr->rvm_allocations;
+    rvm_page_entry_t *rvm_allocations_tail = seg_hdr->rvm_allocations_tail;
 
     if(rvm_allocations == NULL) {
 	/* There are no other allocated pages, so this is the trivial case */
@@ -187,7 +187,7 @@ rvm_bool_t rvm_register_page(char *vmaddr, rvm_length_t length)
 	entry->next     = NULL;	 /* indicates end of list */
 	rvm_allocations      = entry; /* set this to be head of list */
 	rvm_allocations_tail = entry; /* also set it to be the tail */
-	return(rvm_true);
+        goto exit;
     }
 
     /* XXX check if tail is before this region for "quick" verification */
@@ -239,7 +239,7 @@ rvm_bool_t rvm_register_page(char *vmaddr, rvm_length_t length)
 		/* bookmark must be the head of the list */
 		rvm_allocations = entry;
 	    bookmark->prev  = entry;          /* the entry before bookmark */
-	    return(rvm_true);
+            goto exit;
 	}
 
 	/* if we're at the end, and we haven't tripped yet, we should
@@ -253,7 +253,7 @@ rvm_bool_t rvm_register_page(char *vmaddr, rvm_length_t length)
 	    entry->next     = NULL;	      /* after bookmark */
 	    bookmark->next  = entry;
 	    rvm_allocations_tail = entry;     /* set the new tail */
-	    return(rvm_true);
+            goto exit;
 	} else {
 	    bookmark = bookmark->next;
 	}
@@ -262,6 +262,13 @@ rvm_bool_t rvm_register_page(char *vmaddr, rvm_length_t length)
     /* we shouldn't be able to get here. */
     assert(rvm_false);
     return(rvm_false);
+
+exit:
+    if(seg_hdr != NULL) {
+        seg_hdr->rvm_allocations = rvm_allocations;
+        seg_hdr->rvm_allocations_tail = rvm_allocations_tail;
+    }
+    return(rvm_true);
 }
 
 /*
@@ -270,11 +277,15 @@ rvm_bool_t rvm_register_page(char *vmaddr, rvm_length_t length)
  *                        successfully unregistered; returns false if the
  *                        page was not previously allocated.
  */
-rvm_bool_t rvm_unregister_page(char *vmaddr, rvm_length_t length)
+rvm_bool_t rvm_unregister_page(rvm_seg_hdr_t *seg_hdr, char *vmaddr, rvm_length_t length)
 {
     rvm_page_entry_t *entry, *previous_entry, *next_entry;
+    rvm_page_entry_t *rvm_allocations      = NULL;
 
-    entry = find_page_entry(vmaddr);
+    if(seg_hdr != NULL)
+        rvm_allocations      = seg_hdr->rvm_allocations;
+
+    entry = find_page_entry(seg_hdr, vmaddr);
     if(entry == NULL)
 	return(rvm_false);
 
@@ -305,6 +316,8 @@ rvm_bool_t rvm_unregister_page(char *vmaddr, rvm_length_t length)
     /* free this entry */
     free(entry);
 
+    if(seg_hdr != NULL)
+        seg_hdr->rvm_allocations = rvm_allocations;
     return(rvm_true);
 }
 
@@ -315,9 +328,10 @@ rvm_bool_t rvm_unregister_page(char *vmaddr, rvm_length_t length)
  *                    us to support both rvm_unregister_page and
  *                    chk_mem, which need slightly different things.
  */
-rvm_page_entry_t *find_page_entry(char *vmaddr)
+rvm_page_entry_t *find_page_entry(rvm_seg_hdr_t *seg_hdr, char *vmaddr)
 {
     rvm_page_entry_t *bookmark;
+    rvm_page_entry_t *rvm_allocations      = seg_hdr->rvm_allocations;
 
     bookmark = rvm_allocations;
 
@@ -338,6 +352,11 @@ char *page_alloc(len)
     rvm_length_t    len;
     {
     char           *vmaddr;
+    rvm_seg_hdr_t     seg_hdr;
+
+    seg_hdr.rvm_allocations = NULL;
+    seg_hdr.rvm_allocations_tail = NULL;
+
     /* printf ("page_alloc(%ul)\n", len); */
 #ifdef HAVE_MMAP
     mmap_anon(vmaddr, NULL, len, PROT_READ | PROT_WRITE);
@@ -371,7 +390,7 @@ char *page_alloc(len)
        not only wrong [since we don't if it's allocated, or
        actually allocated in the RVM heap!!], but doesn't
        work with mmap()). */
-    if (rvm_register_page(vmaddr, len) == rvm_false)
+    if (rvm_register_page(&seg_hdr, vmaddr, len) == rvm_false)
         {
 	assert(rvm_false);	/* Registering shouldn't have failed */
 	}
@@ -381,7 +400,8 @@ char *page_alloc(len)
 
 
 /* BSD44 page deallocator */
-void page_free(vmaddr, length)
+void page_free(seg_hdr, vmaddr, length)
+    rvm_seg_hdr_t *seg_hdr;
     char            *vmaddr;
     rvm_length_t     length;
     {
@@ -393,7 +413,7 @@ void page_free(vmaddr, length)
 	UnmapViewOfFile(vmaddr);
 #endif
 
-	if (rvm_unregister_page(vmaddr, length) == rvm_false) {
+	if (rvm_unregister_page(seg_hdr, vmaddr, length) == rvm_false) {
 	    assert(0); /* should never fail */
 	}
     }
@@ -404,14 +424,14 @@ void page_free(vmaddr, length)
  *            this means either that it is on the list,
  *            or it is wholly contained by one or more list entries.
  */
-rvm_bool_t mem_chk(char *vmaddr, rvm_length_t length)
+rvm_bool_t mem_chk(rvm_seg_hdr_t *seg_hdr, char *vmaddr, rvm_length_t length)
 {
     rvm_page_entry_t *entry;
     char *start = vmaddr;
     char *end   = vmaddr + length - 1;
 
     while(rvm_true) {
-	entry = find_page_entry(start);
+	entry = find_page_entry(seg_hdr, start);
 	if(entry == NULL)
 	    return(rvm_false);
 
@@ -692,7 +712,8 @@ long mem_total_include(tnode1,tnode2)
    -- region tree is left lock if mode = w
    -- used by transaction functions and unmap
 */
-region_t *find_whole_range(dest,length,mode)
+region_t *find_whole_range(seg_hdr,dest,length,mode)
+    rvm_seg_hdr_t      *seg_hdr;
     char            *dest;
     rvm_length_t    length;
     rw_lock_mode_t  mode;               /* lock mode for region descriptor */
@@ -705,9 +726,9 @@ region_t *find_whole_range(dest,length,mode)
     range.length = length;
     range.links.node.struct_id = mem_region_id;
 
-    RW_CRITICAL(region_tree_lock,mode,  /* begin region_tree_lock crit sect */
+    RW_CRITICAL(*seg_hdr->region_tree_lock,mode,  /* begin region_tree_lock crit sect */
         {
-        node = (mem_region_t *)tree_lookup(&region_tree,
+        node = (mem_region_t *)tree_lookup(seg_hdr->region_tree,
                                           (tree_node_t *)&range,
                                           mem_total_include);
         if (node != NULL)
@@ -727,7 +748,8 @@ region_t *find_whole_range(dest,length,mode)
 /* find and lock a region record if vm range is at least partially
    within a single mapped region; return code for inclusion
 */
-region_t *find_partial_range(dest,length,code)
+region_t *find_partial_range(seg_hdr,dest,length,code)
+    rvm_seg_hdr_t      *seg_hdr;
     char            *dest;
     rvm_length_t    length;
     long            *code;
@@ -740,9 +762,9 @@ region_t *find_partial_range(dest,length,code)
     range.length = length;
     range.links.node.struct_id = mem_region_id;
 
-    RW_CRITICAL(region_tree_lock,r,     /* begin region_tree_lock crit sect */
+    RW_CRITICAL(seg_hdr->region_tree_lock,r,     /* begin region_tree_lock crit sect */
         {
-        node = (mem_region_t *)tree_lookup(&region_tree,
+        node = (mem_region_t *)tree_lookup(seg_hdr->region_tree,
                                           (tree_node_t *)&range,
                                           mem_partial_include);
         if (node != NULL)
@@ -761,7 +783,8 @@ region_t *find_partial_range(dest,length,code)
     }
 
 /* apply mapping options, compute region size, and round to page size */
-static rvm_return_t round_region(rvm_region,seg)
+static rvm_return_t round_region(seg_hdr, rvm_region,seg)
+    rvm_seg_hdr_t      *seg_hdr;
     rvm_region_t    *rvm_region;        /* user region specs [in/out] */
     seg_t           *seg;               /* segment descriptor */
     {
@@ -799,7 +822,7 @@ static rvm_return_t round_region(rvm_region,seg)
         if (rvm_region->vmaddr != (char *)
                              CHOP_TO_PAGE_SIZE(rvm_region->vmaddr))
             return RVM_ERANGE;          /* buffer not page aligned */
-        if (!mem_chk(rvm_region->vmaddr,rvm_region->length))
+        if (!mem_chk(seg_hdr, rvm_region->vmaddr,rvm_region->length))
             return RVM_ERANGE;          /* buffer not within task's vm */
         }
     else
@@ -813,7 +836,8 @@ static rvm_return_t round_region(rvm_region,seg)
     }
 
 /* validate region and construct descriptors */
-static rvm_return_t establish_range(rvm_region,region,mem_region,seg)
+static rvm_return_t establish_range(seg_hdr, rvm_region,region,mem_region,seg)
+    rvm_seg_hdr_t      *seg_hdr;
     rvm_region_t    *rvm_region;        /* user request region descriptor */
     region_t        **region;           /* internal region descriptor [out]*/
     mem_region_t    **mem_region;       /* region tree descriptor [out] */
@@ -825,7 +849,7 @@ static rvm_return_t establish_range(rvm_region,region,mem_region,seg)
 
     /* get exact region size, address */
     *region = NULL; *mem_region = NULL;
-    if ((retval=round_region(rvm_region,seg)) != RVM_SUCCESS)
+    if ((retval=round_region(seg_hdr, rvm_region, seg)) != RVM_SUCCESS)
         return retval;
 
     /* build new region descriptor */
@@ -847,9 +871,9 @@ static rvm_return_t establish_range(rvm_region,region,mem_region,seg)
     mem_node->region = NULL;
 
     /* put range tree node in tree to reserve range */
-    RW_CRITICAL(region_tree_lock,w,     /* begin region_tree_lock crit sect */
+    RW_CRITICAL(*seg_hdr->region_tree_lock,w,     /* begin region_tree_lock crit sect */
         {
-        if (!tree_insert(&region_tree,(tree_node_t *)mem_node,
+        if (!tree_insert(seg_hdr->region_tree,(tree_node_t *)mem_node,
                             mem_partial_include))
             retval = RVM_EVM_OVERLAP;         /* vm range already mapped */
         });                             /* end region_tree_lock crit sect */
@@ -975,7 +999,8 @@ static rvm_return_t map_data(rvm_options,region)
     }
 
 /* error exit cleanup */
-static void clean_up(region,mem_region)
+static void clean_up(seg_hdr,region,mem_region)
+    rvm_seg_hdr_t      *seg_hdr;
     region_t        *region;
     mem_region_t    *mem_region;
 {
@@ -997,9 +1022,9 @@ static void clean_up(region,mem_region)
     /* kill region tree node if created */
     if (mem_region != NULL)
         {
-        RW_CRITICAL(region_tree_lock,w,
+        RW_CRITICAL(seg_hdr->region_tree_lock,w,
             {
-            (void)tree_delete(&region_tree,(tree_node_t *)mem_region,
+            (void)tree_delete(seg_hdr->region_tree,(tree_node_t *)mem_region,
                               mem_partial_include);
             });
         free_mem_region(mem_region);
@@ -1007,7 +1032,7 @@ static void clean_up(region,mem_region)
 }
 
 /* rvm_map */
-rvm_return_t rvm_map(rvm_region_t *rvm_region, rvm_options_t *rvm_options)
+rvm_return_t rvm_map(rvm_seg_hdr_t *seg_hdr, rvm_region_t *rvm_region, rvm_options_t *rvm_options)
 {
     seg_t               *seg;              /* segment descriptor */
     region_t            *region = NULL;    /* new region descriptor */
@@ -1041,7 +1066,7 @@ rvm_return_t rvm_map(rvm_region_t *rvm_region, rvm_options_t *rvm_options)
         if (seg->dev.handle == 0) return RVM_EIO;
 
     /* check for vm overlap with existing mappings & build descriptors */
-    if ((retval = establish_range(rvm_region,&region,&mem_region,seg))
+    if ((retval = establish_range(seg_hdr, rvm_region,&region,&mem_region,seg))
                 != RVM_SUCCESS)
         goto err_exit;
 
diff --git a/rvm/rvm_private.h b/rvm/rvm_private.h
index 5e533c8..aa47e0f 100644
--- a/rvm/rvm_private.h
+++ b/rvm/rvm_private.h
@@ -22,11 +22,10 @@ Coda are listed in the file CREDITS.
 *
 */
 
-#pragma once
 
 /* permit multiple includes */
-#ifndef __MERO_RVM_RVM_PRIVATE_H__
-#define __MERO_RVM_RVM_PRIVATE_H__
+#ifndef _RVM_PRIVATE_
+#define _RVM_PRIVATE_ 1
 
 /* turn on debuging for now */
 #ifndef DEBUG
@@ -34,15 +33,15 @@ Coda are listed in the file CREDITS.
 #endif
 
 #ifdef HAVE_CONFIG_H
-#include "config.h"
+/*#include "config.h"*/
 #endif
 
 #include <sys/types.h>
 #include <stdlib.h>
 #include <string.h>
 #include <assert.h>
-#include "rvm/rvm.h"
-#include "rvm/rvm_statistics.h"
+#include "rvm.h"
+#include "rvm_statistics.h"
 
 #include <fcntl.h>
 #ifndef O_BINARY
@@ -57,17 +56,6 @@ Coda are listed in the file CREDITS.
 /* make sure realloc knows what to do with null ptr */
 #define REALLOC(x,l)      (((x)==NULL) ? malloc(l) : realloc((x),(l)))
 
-/* bcopy <=> memcpy, defs of syscalls */
-#ifndef BZERO
-#ifdef __STDC__
-#define BCOPY(x,y,n)     memcpy((y),(x),(n))
-#define BZERO(x,n)       memset((x),0,(n))
-#else
-#define BCOPY(x,y,n)     bcopy((x),(y),(n))
-#define BZERO(x,n)       bzero((x),(n))
-#endif
-#endif
-
 /* loop terminated by explicit break */
 #define DO_FOREVER  for (;;)
 #define MACRO_BEGIN			do {
@@ -393,11 +381,11 @@ free_page_t;
  */
 
 #ifdef RVM_USELWP	 /* special thread support for Coda */
-#include "rvm/rvm_lwp.h"
+#include "rvm_lwp.h"
 #elif defined(RVM_USEPT) /* special support for pthreads */
-#include "rvm/rvm_pthread.h"
+#include "rvm_pthread.h"
 #else			 /* normal: use Cthreads */
-#include "rvm/cthreads.h"
+#include "cthreads.h"
 
 /* define types symbolically to permit use of non-Cthread thread support */
 #define RVM_MUTEX       struct mutex
@@ -435,15 +423,14 @@ typedef enum                            /* rw_lock access modes */
     }
 rw_lock_mode_t;
 
-typedef struct                          /* rw_lock structure */
+struct rw_lock                         /* rw_lock structure */
     {
     RVM_MUTEX           mutex;          /* mutex to protect rw_lock innards */
     long                read_cnt;       /* read lock count, 0 ==> free */
     long                write_cnt;      /* write lock count, 0 ==> free */
     list_entry_t        queue;          /* blocked thread queue */
     rw_lock_mode_t      lock_mode;      /* current lock mode */
-    }
-rw_lock_t;
+    };
 
 typedef struct                          /* rw_lock queue entry */
     {
@@ -502,7 +489,7 @@ typedef struct                          /* tree traversal position entry */
     }
 tree_pos_t;
 
-typedef struct                          /* tree root structure */
+struct tree_root                         /* tree root structure */
     {
     struct_id_t         struct_id;      /* self identifier */
     tree_node_t         *root;          /* ptr to root node */
@@ -513,8 +500,7 @@ typedef struct                          /* tree root structure */
     rvm_length_t        n_nodes;        /* number of nodes in tree */
     rvm_length_t        max_depth;      /* length of deepest path in tree */
     rvm_bool_t          unlink;         /* unlink nodes as traversed */
-    }
-tree_root_t;
+    };
 
 #define TRAVERSE_LEN_INCR  15           /* allocate 15 slots at a time */
 /* tree structure iterators
@@ -1131,17 +1117,17 @@ int_tid_t;
 /* functions and structures for managing list of RVM-allocated
      regions of memory (added by tilt, Nov 19 1996) */
 
-typedef struct rvm_page_entry {
+struct rvm_page_entry {
     char                   *start;
     char                   *end;
     struct rvm_page_entry  *prev;
     struct rvm_page_entry  *next;
-} rvm_page_entry_t;
+};
 
-rvm_bool_t rvm_register_page(char *vmaddr, rvm_length_t length);
-rvm_bool_t rvm_unregister_page(char *vmaddr, rvm_length_t length);
-rvm_bool_t mem_chk(char *vmaddr, rvm_length_t length);
-rvm_page_entry_t *find_page_entry(char *vmaddr);
+rvm_bool_t rvm_register_page(rvm_seg_hdr_t *seg_hdr, char *vmaddr, rvm_length_t length);
+rvm_bool_t rvm_unregister_page(rvm_seg_hdr_t *seg_hdr, char *vmaddr, rvm_length_t length);
+rvm_bool_t mem_chk(rvm_seg_hdr_t *seg_hdr, char *vmaddr, rvm_length_t length);
+rvm_page_entry_t *find_page_entry(rvm_seg_hdr_t *seg_hdr, char *vmaddr);
 /* list management functions */
 
 extern
@@ -1483,7 +1469,7 @@ void free_log_buf();                    /* [rvm_logrecovr.c] */
 void init_map_roots(void);
 rvm_return_t bad_region(rvm_region_t *rvm_region);
 char *page_alloc(rvm_length_t len);
-void page_free(char *vmaddr, rvm_length_t length);
+void page_free(rvm_seg_hdr_t *seg_hdr, char *vmaddr, rvm_length_t length);
 long open_seg_dev(seg_t *seg, rvm_offset_t *dev_length);
 long close_seg_dev(seg_t *seg);
 rvm_return_t close_all_segs(void);
@@ -1494,9 +1480,9 @@ long dev_partial_include(rvm_offset_t *base1, rvm_offset_t *end1, rvm_offset_t *
 long dev_total_include(rvm_offset_t *base1, rvm_offset_t *end1, rvm_offset_t *base2, rvm_offset_t *end2);
 long mem_partial_include(tree_node_t *tnode1, tree_node_t *tnode2);
 long mem_total_include(tree_node_t *tnode1, tree_node_t *tnode2);
-region_t *find_whole_range(char *dest, rvm_length_t length, rw_lock_mode_t mode);
-region_t *find_partial_range(char *dest, rvm_length_t length, long *code);
-rvm_return_t rvm_map(rvm_region_t *rvm_region, rvm_options_t *rvm_options);
+region_t *find_whole_range(rvm_seg_hdr_t *seg_hdr, char *dest, rvm_length_t length, rw_lock_mode_t mode);
+region_t *find_partial_range(rvm_seg_hdr_t *seg_hdr, char *dest, rvm_length_t length, long *code);
+rvm_return_t rvm_map(rvm_seg_hdr_t *seg_hdr, rvm_region_t *rvm_region, rvm_options_t *rvm_options);
 
 
 /* segment dictionary functions */
@@ -1622,7 +1608,7 @@ tree_node_t *tree_predecessor();        /* [rvm_utils.c] */
 */
 /* initialization, query, and structure checkers */
 
-extern rvm_bool_t bad_init(void);        /* [rvm_init.c] */
+extern rvm_bool_t bad_init();                  /* [rvm_init.c] */
 
 /* [rvm_status.c] */
 rvm_return_t bad_options(rvm_options_t *rvm_options, rvm_bool_t chk_log_dev);
@@ -1713,4 +1699,4 @@ void rvm_debug();                       /* [rvm_debug] */
 /*  rvm_length_t    val; */
 
 
-#endif /* __MERO_RVM_RVM_PRIVATE_H__ */
+#endif /* _RVM_PRIVATE_ */
diff --git a/rvm/rvm_pthread.c b/rvm/rvm_pthread.c
index fdef818..158f936 100644
--- a/rvm/rvm_pthread.c
+++ b/rvm/rvm_pthread.c
@@ -17,7 +17,7 @@ Coda are listed in the file CREDITS.
 #*/
 
 #include <pthread.h>
-#include "rvm/rvm.h"
+#include "rvm.h"
 
 pthread_t       rvm_pthreadid;
 void		*rvm_ptstat;
diff --git a/rvm/rvm_releaseseg.c b/rvm/rvm_releaseseg.c
index 2d5c580..8d68251 100644
--- a/rvm/rvm_releaseseg.c
+++ b/rvm/rvm_releaseseg.c
@@ -19,15 +19,16 @@ Coda are listed in the file CREDITS.
 #include <stdio.h>
 #include <stdlib.h>
 
-#include "rvm/rvm.h"
-#include "rvm/rvm_segment.h"
-#include "rvm/rvm_segment_private.h"
+#include "rvm.h"
+#include "rvm_segment.h"
+#include "rvm_segment_private.h"
 
 /* release regions of a segment */
 rvm_return_t
 rvm_release_segment (
     unsigned long       nregions,     /* number of regions mapped */
-    rvm_region_def_t    **regions)    /* array of region descriptors */
+    rvm_region_def_t    **regions,    /* array of region descriptors */
+    rvm_seg_hdr_t       *seg_hdr)
 {
     rvm_region_t *region = rvm_malloc_region();
     rvm_return_t err = RVM_SUCCESS;
@@ -38,11 +39,11 @@ rvm_release_segment (
         region->length = (*regions)[i].length;
         region->vmaddr = (*regions)[i].vmaddr;
 
-        err = rvm_unmap(region);
+        err = rvm_unmap(seg_hdr, region);
         if (err != RVM_SUCCESS)
             printf("release_segment unmap failed %s\n", rvm_return(err));
 
-        deallocate_vm(region->vmaddr, region->length);
+        deallocate_vm(seg_hdr, region->vmaddr, region->length);
     }
     rvm_free_region(region);
     free(*regions);
diff --git a/rvm/rvm_segment.h b/rvm/rvm_segment.h
index ea2723d..6464973 100644
--- a/rvm/rvm_segment.h
+++ b/rvm/rvm_segment.h
@@ -19,12 +19,11 @@ Coda are listed in the file CREDITS.
 /*
  * Segment Loader public definitions
  */
-#pragma once
 
-#ifndef __MERO_RVM_RVM_SEGMENT_H__
-#define __MERO_RVM_RVM_SEGMENT_H__
+#ifndef _RVM_SEGMENT_H_
+#define _RVM_SEGMENT_H_
 
-#include "rvm/rvm.h"
+#include "rvm.h"
 
 /* taken from rvm_segment_private.h */
 #define RVM_SEGMENT_HDR_SIZE RVM_PAGE_SIZE /* length of segment header */
@@ -53,7 +52,8 @@ extern rvm_return_t rvm_create_segment (
     rvm_offset_t        DevLength,      /* Length of dataDev if really a device */
     rvm_options_t       *options,       /* options record for RVM */
     rvm_length_t        nregions,       /* number of regions defined for segment*/
-    rvm_region_def_t    *region_defs    /* array of region defs for segment */
+    rvm_region_def_t    *region_defs,   /* array of region defs for segment */
+    rvm_seg_hdr_t          *seg_hdr
     );
 
 /* load regions of a segment */
@@ -62,13 +62,16 @@ extern rvm_return_t rvm_load_segment (
     rvm_offset_t        DevLength,      /* Length of dataDev if really a device */
     rvm_options_t       *options,       /* options record for RVM */
     unsigned long       *nregions,      /* returned -- number of regions mapped */
-    rvm_region_def_t    *regions[]      /* returned array of region descriptors */
+    rvm_region_def_t    *regions[],     /* returned array of region descriptors */
+    rvm_seg_hdr_t          *seg_hdr
     );
 
 /* release regions of a segment */
 extern rvm_return_t rvm_release_segment (
     unsigned long       nregions,      /* number of regions mapped */
-    rvm_region_def_t    **regions      /* array of region descriptors */
+    rvm_region_def_t    **regions,     /* array of region descriptors */
+    rvm_seg_hdr_t          *seg_hdr
     );
 
-#endif /* __MERO_RVM_RVM_SEGMENT_H__ */
+extern char *rvm_get_vm_addr(unsigned long length);
+#endif /* _RVM_SEGMENT_H_ */
diff --git a/rvm/rvm_segment_private.h b/rvm/rvm_segment_private.h
index 5daa005..25711c6 100644
--- a/rvm/rvm_segment_private.h
+++ b/rvm/rvm_segment_private.h
@@ -15,14 +15,15 @@ Coda are listed in the file CREDITS.
                            none currently
 
 #*/
-/* segment loader private declarations */
 
-#pragma once
 
-#ifndef __MERO_RVM_RVM_SEGMENT_PRIVATE_H__
-#define __MERO_RVM_RVM_SEGMENT_PRIVATE_H__
+/* segment loader private declarations */
+
+#ifndef _RVM_SEGMENT_PRIVATE_H_
+#define _RVM_SEGMENT_PRIVATE_H_
 /* Worker definitions */
 
+extern rvm_return_t find_available_vm_addr(char **addr, unsigned long length);
 extern rvm_return_t allocate_vm();
 extern rvm_return_t deallocate_vm();
 
@@ -55,4 +56,4 @@ typedef struct
     }
 rvm_segment_hdr_t;
 
-#endif /* __MERO_RVM_RVM_SEGMENT_PRIVATE_H__ */
+#endif /* _RVM_SEGMENT_PRIVATE_H_ */
diff --git a/rvm/rvm_segutil.c b/rvm/rvm_segutil.c
index a021a8e..47ac983 100644
--- a/rvm/rvm_segutil.c
+++ b/rvm/rvm_segutil.c
@@ -16,22 +16,18 @@ Coda are listed in the file CREDITS.
 
 #*/
 
-#ifdef HAVE_CONFIG_H
-#include "config.h"
-#endif
-
 #include <unistd.h>
 #include <stdlib.h>
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <fcntl.h>
 
-#include "rvm/rvm.h"
-#include "rvm/rvm_segment.h"
+#include "rvm.h"
+#include "rvm_segment.h"
 
 /* from rvm_private.h */
-rvm_bool_t rvm_register_page(char *vmaddr, rvm_length_t length);
-rvm_bool_t rvm_unregister_page(char *vmaddr, rvm_length_t length);
+rvm_bool_t rvm_register_page(rvm_seg_hdr_t *seg_hdr, char *vmaddr, rvm_length_t length);
+rvm_bool_t rvm_unregister_page(rvm_seg_hdr_t *seg_hdr, char *vmaddr, rvm_length_t length);
 
 #ifdef __CYGWIN32__
 #include <windows.h>
@@ -79,13 +75,14 @@ int overlap(nregions, regionDefs)
 
 #include <sys/types.h>
 #include <sys/mman.h>
-#include "rvm/coda_mmap_anon.h"
+#include "coda_mmap_anon.h"
 #include <errno.h>
 #define ALLOCATE_VM_DEFINED
 
 
 rvm_return_t
-allocate_vm(addr, length)
+allocate_vm(seg_hdr, addr, length)
+     rvm_seg_hdr_t *seg_hdr;
      char **addr;
      unsigned long length;
 {
@@ -138,15 +135,15 @@ allocate_vm(addr, length)
        not only wrong [since we don't if it's allocated, or
        actually allocated in the RVM heap!!], but doesn't
        work with mmap()). */
-    if (rvm_register_page(*addr, length) == rvm_false) {
+    if (rvm_register_page(seg_hdr, *addr, length) == rvm_false) {
 	ret = RVM_EINTERNAL;
     }
-
     return ret;
 }
 
 rvm_return_t
-deallocate_vm(addr, length)
+deallocate_vm(seg_hdr, addr, length)
+     rvm_seg_hdr_t *seg_hdr;
      char *addr;
      unsigned long length;
 {
@@ -160,11 +157,29 @@ deallocate_vm(addr, length)
     UnmapViewOfFile(addr);
 #endif
 
-    if (rvm_unregister_page(addr, length) == rvm_false) {
+    if (rvm_unregister_page(seg_hdr, addr, length) == rvm_false) {
 	ret = RVM_EINTERNAL;
     }
 
     return ret;
 }
 
+rvm_return_t
+find_available_vm_addr(addr, length)
+     char **addr;
+     unsigned long length;
+{
+    char *umaddr = NULL;
+#ifdef HAVE_MMAP
+    int flags = MAP_ANON | MAP_PRIVATE;
+    *addr = mmap(NULL, length, PROT_READ | PROT_WRITE, flags, -1, 0);
+
+    /*mmap_anon(*addr, NULL, length, (PROT_READ | PROT_WRITE));*/
 
+    umaddr = *addr;
+
+    if(-1 == munmap(umaddr, length))
+        return rvm_false;
+#endif
+    return rvm_true;
+}
diff --git a/rvm/rvm_status.c b/rvm/rvm_status.c
index 757d565..064130e 100644
--- a/rvm/rvm_status.c
+++ b/rvm/rvm_status.c
@@ -29,7 +29,7 @@ extern rvm_bool_t   rvm_utlsw;          /* true if call by rvmutl */
 extern char         *rvm_errmsg;        /* internal error message buffer */
 extern rvm_length_t rvm_max_read_len;   /* maximum Mach read length */
 extern rvm_length_t flush_times_vec[flush_times_len]; /* flush timing histogram defs */
-extern rvm_length_t truncation_times_vec[truncation_times_len]; /* truncation timing 
+extern rvm_length_t truncation_times_vec[truncation_times_len]; /* truncation timing
                                                                    histogram defs */
 extern rvm_length_t range_lengths_vec[range_lengths_len]; /* range length
                                                              histogram defs */
@@ -131,7 +131,7 @@ rvm_return_t do_rvm_options(rvm_options)
         rvm_optimizations = rvm_options->flags & (RVM_ALL_OPTIMIZATIONS);
         if (rvm_optimizations & RVM_COALESCE_TRANS)
             rvm_optimizations |= RVM_COALESCE_RANGES;
-	
+
 	/* set mapping kind */
 	rvm_map_private = rvm_options->flags & RVM_MAP_PRIVATE;
         }
@@ -140,7 +140,8 @@ rvm_return_t do_rvm_options(rvm_options)
     return RVM_SUCCESS;
     }
 /* rvm_query */
-rvm_return_t rvm_query(rvm_options,rvm_region)
+rvm_return_t rvm_query(seg_hdr,rvm_options,rvm_region)
+    rvm_seg_hdr_t          *seg_hdr;
     rvm_options_t       *rvm_options;
     rvm_region_t        *rvm_region;
     {
@@ -190,7 +191,7 @@ rvm_return_t rvm_query(rvm_options,rvm_region)
         /* if region specified, look it up */
         if (rvm_region != NULL)
             {                           /* begin region_lock crit sect */
-            region = find_whole_range(rvm_region->vmaddr,
+            region = find_whole_range(seg_hdr, rvm_region->vmaddr,
                                       rvm_region->length,r);
             if (region == NULL)
                 return RVM_ENOT_MAPPED; /* not locked if not found
@@ -291,7 +292,7 @@ rvm_return_t rvm_statistics(const char *version, rvm_statistics_t *rvm_statistic
         {
         rvm_statistics->n_abort = status->n_abort;
         rvm_statistics->n_flush_commit = status->n_flush_commit;
-        rvm_statistics->n_no_flush_commit = 
+        rvm_statistics->n_no_flush_commit =
             status->n_no_flush_commit;
         rvm_statistics->n_split = status->n_split;
         rvm_statistics->n_flush = status->n_flush;
@@ -311,7 +312,7 @@ rvm_return_t rvm_statistics(const char *version, rvm_statistics_t *rvm_statistic
             status->tot_async_truncation;
         rvm_statistics->tot_sync_truncation =
             status->tot_sync_truncation;
-        rvm_statistics->tot_truncation_wait = 
+        rvm_statistics->tot_truncation_wait =
             status->tot_truncation_wait;
         rvm_statistics->tot_recovery = status->tot_recovery;
         rvm_statistics->tot_flush = status->tot_flush;
diff --git a/rvm/rvm_trans.c b/rvm/rvm_trans.c
index 304f49d..a63de6c 100644
--- a/rvm/rvm_trans.c
+++ b/rvm/rvm_trans.c
@@ -248,7 +248,7 @@ static long segment_partial_include(range1,range2)
             return -1;
         return 0;
         }
-    
+
     /* compare segment codes */
     if (range1->nv.seg_code > range2->nv.seg_code)
         return 1;
@@ -448,17 +448,18 @@ static rvm_return_t merge_range(tid,region,new_range)
         range->nv.length = new_range->nv.length;
         range->nv.offset = new_range->nv.offset;
         range->end_offset = new_range->end_offset;
-        free_range(new_range); 
+        free_range(new_range);
 
         /* update region uncommitted reference count */
         CRITICAL(region->count_lock,
             region->n_uncommit -= (tid->x_ranges_len-1));
-        }    
+        }
 
     return RVM_SUCCESS;
     }
 /* rvm_set_range */
-rvm_return_t rvm_set_range(rvm_tid,dest,length)
+rvm_return_t rvm_set_range(seg_hdr, rvm_tid,dest,length)
+    rvm_seg_hdr_t      *seg_hdr;
     rvm_tid_t       *rvm_tid;           /* transaction affected */
     void            *dest;              /* base vm address of range */
     rvm_length_t    length;             /* length of range */
@@ -480,7 +481,7 @@ rvm_return_t rvm_set_range(rvm_tid,dest,length)
         return RVM_ETID;
 
     /* lookup and lock region */
-    region = find_whole_range(dest,length,r); /* begin region_lock crit sect */
+    region = find_whole_range(seg_hdr, dest,length,r); /* begin region_lock crit sect */
     if (region == NULL)
         retval = RVM_ENOT_MAPPED;
     else
@@ -495,7 +496,8 @@ rvm_return_t rvm_set_range(rvm_tid,dest,length)
     return retval;
     }
 /* rvm_modify_bytes */
-rvm_return_t rvm_modify_bytes(rvm_tid,dest,src,length)
+rvm_return_t rvm_modify_bytes(seg_hdr,rvm_tid,dest,src,length)
+    rvm_seg_hdr_t          *seg_hdr;
     rvm_tid_t           *rvm_tid;       /* transaction affected */
     void                *dest;          /* base vm address of range */
     const void                *src;           /* source of nv's */
@@ -504,7 +506,7 @@ rvm_return_t rvm_modify_bytes(rvm_tid,dest,src,length)
     rvm_return_t        retval;
 
     /* call rvm_set_range to do most of the work */
-    if ((retval = rvm_set_range(rvm_tid,dest,length)) != RVM_SUCCESS)
+    if ((retval = rvm_set_range(seg_hdr,rvm_tid,dest,length)) != RVM_SUCCESS)
         return retval;
 
     /* must memmove since there is no guarantee
@@ -564,7 +566,7 @@ static rvm_return_t save_nv(range)
             range->data_len = range_len;
             }
         assert(range->data_len >= range_len);
-    
+
         /* copy to old value space */
         src_aligned_bcopy(range->nv.vmaddr,range->data,
                           range->nv.length);
@@ -979,7 +981,7 @@ rvm_return_t rvm_end_transaction(rvm_tid,mode)
     /* remove tid from log's tid_list */
     log = tid->log;
     CRITICAL(log->dev_lock,		/* begin dev_lock crit section */
-    {                          
+    {
 	CRITICAL(log->tid_list_lock,	/* unlink tid from log's tid_list*/
 		 move_list_entry(&log->tid_list,NULL,&tid->links));
         if (mode == flush)              /* record flush mode and count */
diff --git a/rvm/rvm_unmap.c b/rvm/rvm_unmap.c
index 3984232..5b22580 100644
--- a/rvm/rvm_unmap.c
+++ b/rvm/rvm_unmap.c
@@ -29,12 +29,11 @@ Coda are listed in the file CREDITS.
 extern log_t    *default_log;           /* default log descriptor ptr */
 extern char     *rvm_errmsg;            /* internal error message buffer */
 
-extern
-rw_lock_t       region_tree_lock;       /* lock for region tree */
-extern
-tree_root_t     region_tree;           /* root of mapped region tree */
+/*extern rw_lock_t       region_tree_lock;       *//* lock for region tree */
+/*extern tree_node_t     *region_tree;           *//* root of mapped region tree */
 /* rvm_unmap */
-rvm_return_t rvm_unmap(rvm_region)
+rvm_return_t rvm_unmap(seg_hdr,rvm_region)
+    rvm_seg_hdr_t          *seg_hdr;
     rvm_region_t        *rvm_region;    /* region to unmap */
     {
     rvm_return_t        retval;
@@ -46,7 +45,7 @@ rvm_return_t rvm_unmap(rvm_region)
         return retval;
 
     /* find and lock region descriptor */
-    region = find_whole_range(rvm_region->vmaddr,    /* begin region_tree_lock, */
+    region = find_whole_range(seg_hdr,rvm_region->vmaddr,    /* begin region_tree_lock, */
                               rvm_region->length,w); /* region_lock crit sects */
     if (region == NULL)
         return RVM_ENOT_MAPPED;
@@ -67,10 +66,10 @@ rvm_return_t rvm_unmap(rvm_region)
         }
 
     /* remove from region tree and unlock tree */
-    if (!tree_delete(&region_tree,(tree_node_t *)region->mem_region,
+    if (!tree_delete(seg_hdr->region_tree,(tree_node_t *)region->mem_region,
                       mem_total_include))
         assert(rvm_false);              /* couldn't find node */
-    rw_unlock(&region_tree_lock,w);     /* end region_tree_lock crit sect */
+    rw_unlock(seg_hdr->region_tree_lock,w);     /* end region_tree_lock crit sect */
     rw_unlock(&region->region_lock,w);  /* end region_lock crit sect */
 
     /* unlink from seg's map_list */
@@ -95,6 +94,6 @@ rvm_return_t rvm_unmap(rvm_region)
 
 err_exit:
     rw_unlock(&region->region_lock,w);
-    rw_unlock(&region_tree_lock,w);
+    rw_unlock(seg_hdr->region_tree_lock,w);
     return retval;
     }
diff --git a/rvm/rvm_utils.c b/rvm/rvm_utils.c
index 83f61c9..dc7261a 100644
--- a/rvm/rvm_utils.c
+++ b/rvm/rvm_utils.c
@@ -28,10 +28,6 @@ Coda are listed in the file CREDITS.
 *
 */
 
-#ifdef HAVE_CONFIG_H
-#include "config.h"
-#endif
-
 #if defined(hpux) || defined(__hpux)
 #include <hp_bsd.h>
 #endif /* hpux */
@@ -622,7 +618,7 @@ void free_log(log)
     if (log->dev.iov != NULL)
         free((char *)log->dev.iov);     /* kill io vector */
     if (log->dev.wrt_buf != NULL)       /* kill raw io gather write buffer */
-        page_free(log->dev.wrt_buf,log->dev.wrt_buf_len);
+        page_free(NULL, log->dev.wrt_buf,log->dev.wrt_buf_len);
     log->dev.wrt_buf_len = 0;
     log->dev.name = NULL;
     log->dev.iov = NULL;
diff --git a/rvm/ut/Makefile.sub b/rvm/ut/Makefile.sub
new file mode 100644
index 0000000..181ae65
--- /dev/null
+++ b/rvm/ut/Makefile.sub
@@ -0,0 +1 @@
+ut_libmero_ut_la_SOURCES += rvm/ut/rvm.c
diff --git a/rvm/ut/rvm.c b/rvm/ut/rvm.c
new file mode 100644
index 0000000..30a4556
--- /dev/null
+++ b/rvm/ut/rvm.c
@@ -0,0 +1,342 @@
+/*
+ * COPYRIGHT 2013 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author              : Prashant Dhange <prahsant_dhange@xyratex.com>
+ * Original creation date       : 03/19/2013
+ */
+
+/**
+ *              RVM UT
+ *
+ */
+
+/**
+  @addtogroup rvm_ut
+  @{
+*/
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include "lib/ut.h"
+#include "lib/trace.h"
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <errno.h>
+#include "rvm/rds_private.h"
+#include "rvmlib.h"
+#include "util.h"
+#include "rvm/rvm.h"
+#include "rvm/rds.h"
+#include "rvm/rvm_segment.h"
+#include "rvm/rvm_statistics.h"
+
+
+#undef M0_TRACE_SUBSYSTEM
+#define M0_TRACE_SUBSYSTEM M0_TRACE_SUBSYS_RVM
+
+#undef M0_TRACE_SUBSYS_RVM
+#ifdef M0_TRACE_SUBSYS_RVM
+#define RVM_LOG  M0_LOG
+#define RVM_DEBUG  M0_DEBUG
+#else
+#define RVM_LOG fprintf
+#define RVM_DEBUG stdout
+#endif
+#define MAPPED_LOG_FILE "build/test_log_segments"
+#define MAPPED_DATA_FILE "build/test_data_segments"
+#define ONE_MB 1048576
+#define SEG_SIZE (4096 + (100 * 1024 * 1024) + 4096)
+#define ALLO_SIZE (65 * 1024)
+#define MAX_BLOCK_SIZE 12000
+#define NUM_OF_DATA_FILE 4
+#define NDFILE 4
+#define INIT_INDEX 0
+
+char              sys_cmd[1024];
+const char       *VM_RVMADDR = (char *)0xbebd000;
+const char       *VM_RVMADDR_ARR[NUM_OF_DATA_FILE] = {
+                                                (char *)0xBEBD0000,
+                                                (char *)0x16B8A000,
+                                                (char *)0x4429E000,
+                                                (char *)0x8853C000,
+                                              };
+rvm_options_t     Recov_Options;
+rvm_seg_hdr_t       *seg_hdr[NDFILE];
+rvm_seg_hdr_t       *mseg_hdr = NULL;
+
+rvm_return_t      ret;
+rvm_length_t      devsize;
+rvm_length_t      rvgLength;
+rvm_length_t      rdsLength;
+struct stat      *buf = NULL;
+char             *rdsAddrs = NULL;
+char             *rvgAddrs = NULL;
+int               fd;
+int               nLists = 16;
+int               chkSize = 64;
+int               i = 0;
+
+static int ts_be_init(void)   /* ts_ for "test suite" */
+{
+        int       rc = -1;
+
+        sprintf(sys_cmd, "rm -rf /tmp/log_file");
+        rc = system(sys_cmd);
+        sprintf(sys_cmd, "rm -rf build");
+        rc = system(sys_cmd);
+        sprintf(sys_cmd, "mkdir -p build");
+        rc = system(sys_cmd);
+        RVM_LOG(RVM_DEBUG,"rc : %d\n", rc);
+        assert(rc == 0);
+
+	// Initialize rvm options
+	rvm_init_options(&Recov_Options);
+
+	unlink(MAPPED_LOG_FILE);
+	Recov_Options.log_dev   = MAPPED_LOG_FILE;
+	Recov_Options.truncate  = TRUNCATE;
+	Recov_Options.flags     = RVM_ALL_OPTIMIZATIONS;
+
+	RVM_LOG(RVM_DEBUG,"%d : %ld %ld\n", chkSize, sizeof(free_block_t),
+               sizeof(guard_t));
+
+	if(stat(MAPPED_LOG_FILE, buf)!=0)
+	{
+		Recov_Options.flags |= RVM_ALL_OPTIMIZATIONS;
+	        Recov_Options.log_dev = MAPPED_LOG_FILE;
+        	Recov_Options.create_log_file = rvm_true;
+	        Recov_Options.create_log_size = RVM_MK_OFFSET(0,20971520);
+        	Recov_Options.create_log_mode = 0600;
+
+		ret = RVM_INIT(&Recov_Options);
+		if(ret == RVM_SUCCESS) {
+		       RVM_LOG(RVM_DEBUG,"Success in creating rvm log device \n");
+		 }
+		else {
+		       RVM_LOG(RVM_DEBUG,"Error in the rvm init ::%s ",
+                              rvm_return(ret));
+                       return -1;
+		}
+	}
+
+	RVM_LOG(RVM_DEBUG,"\n");
+
+	//Initialise rds heap
+
+        for(i=INIT_INDEX;i < NDFILE;i++)
+        {
+                char datafile[80];
+
+                sprintf(datafile, "%s%d", MAPPED_DATA_FILE, i);
+        	if(stat(datafile, buf) != 0) {
+        		fd = open(datafile ,O_WRONLY|O_CREAT, 0600);
+        		if(fd < 0) {
+        		   RVM_LOG(RVM_DEBUG,
+                                  "1. rds mapped file creat failed %d\n",
+                                  errno);
+        		   fd = open(datafile,O_WRONLY|O_CREAT|O_EXCL, 0600);
+        		   if(fd < 0) {
+        			RVM_LOG(RVM_DEBUG,
+                                       "2. rds mapped file creat failed %d\n",
+                                       errno);
+        			return -1;
+        		   }
+        		}
+        		if(ftruncate(fd,(SEG_SIZE)) < 0 ) {
+        		  RVM_LOG(RVM_DEBUG,
+                                 "rds mapped file of size %ld creat failed \n",
+                                 devsize);
+        		  return -1;
+        		}
+        		close(fd);
+                }
+        }
+        return rc;
+}
+
+static int ts_be_fini(void)
+{
+        for(i=INIT_INDEX;i < NDFILE;i++)
+        {
+                free(seg_hdr[i]->seg_name);
+                free(seg_hdr[i]->heap_hdr);
+                free(seg_hdr[i]->region_tree);
+                free(seg_hdr[i]->region_tree_lock);
+                free(seg_hdr[i]);
+        }
+        return 0;
+}
+
+static void test_seg_load()
+{
+        char                datafile[80];
+        long                dev_len = SEG_SIZE;
+        rvm_offset_t        devlen;
+        long                heap_length = 100 * 1024 * 1024;
+
+        for(i = INIT_INDEX;i < NDFILE;i++)
+        {
+                sprintf(datafile, "%s%d", MAPPED_DATA_FILE, i);
+
+   		devlen.high = 0;
+   		devlen.low = dev_len;
+
+   		devsize = SEG_SIZE;
+                rdsAddrs = (char*) VM_RVMADDR_ARR[i]; // for linux
+                rdsAddrs = NULL; // for linux
+   		rvgLength = RVM_ROUND_LENGTH_DOWN_TO_PAGE_SIZE(4096);
+   		rdsLength = heap_length;
+
+   		RVM_LOG(RVM_DEBUG,"rdsAddrs : [%p]\n", rdsAddrs);
+
+                seg_hdr[i] = (rvm_seg_hdr_t *)malloc(sizeof(rvm_seg_hdr_t));
+                seg_hdr[i]->seg_name = (char *)malloc(strlen(datafile));
+                strcpy(seg_hdr[i]->seg_name, datafile);
+                seg_hdr[i]->seg_id = i + 1;
+                seg_hdr[i]->rvm_allocations = NULL;
+                seg_hdr[i]->rvm_allocations_tail = NULL;
+
+  		rds_zap_heap(datafile,RVM_LENGTH_TO_OFFSET(devsize),
+                             rdsAddrs, rvgLength, rdsLength, nLists,
+                             chkSize, &ret, seg_hdr[i]);
+
+   		if(ret != SUCCESS)
+   		{
+   			RVM_LOG(RVM_DEBUG,
+                               "rds zap heap failed .%s\n", rvm_return(ret));
+   			return;
+   		}
+   		RVM_LOG(RVM_DEBUG,"RDS heap allocateed successfully\n");
+
+   		rds_load_heap(datafile,RVM_LENGTH_TO_OFFSET(devsize),
+                              &rvgAddrs, &ret, seg_hdr[i]);
+
+   		if (ret != SUCCESS) {
+   			RVM_LOG(RVM_DEBUG,
+                               "rds_load_heap failed (%s)", rvm_return(ret));
+   			return;
+   		}
+   		RVM_LOG(RVM_DEBUG,"starting address of heap : %p \n", rvgAddrs);
+        }
+}
+
+static void test_rvm()
+{
+        rvm_tid_t               *tid = rvm_malloc_tid();
+        int                      err=0;
+        int                      bSize = (2 * 900);
+        char                    *mptr;
+        char                    *seg1_mptr[3];
+
+        RVM_LOG(RVM_DEBUG,"--------------------------------------------------\n");
+        mseg_hdr = seg_hdr[3];
+	//Initialise rds heap
+        rvm_begin_transaction(tid, restore);
+        mptr = rds_malloc(mseg_hdr, bSize, tid, &err);
+        if(mptr == NULL)	{
+        	RVM_LOG(RVM_DEBUG,"Failed to allocate block \n");
+        	exit(-1);
+        }
+        RVM_LOG(RVM_DEBUG,"starting address of mptr on seg[%p]: %p \n",
+               mseg_hdr, mptr);
+        rds_free(mseg_hdr, mptr, tid, &err);
+        mseg_hdr = seg_hdr[0];
+        seg1_mptr[0] = rds_malloc(mseg_hdr, bSize, tid, &err);
+        if(mptr == NULL)	{
+                RVM_LOG(RVM_DEBUG,"Failed to allocate block \n");
+                exit(-1);
+        }
+        RVM_LOG(RVM_DEBUG,"starting address of mptr on seg[%p]: %p \n",
+               mseg_hdr, seg1_mptr[0]);
+        mseg_hdr = seg_hdr[2];
+        seg1_mptr[1] = rds_malloc(mseg_hdr, bSize, tid, &err);
+        if(mptr == NULL)	{
+                RVM_LOG(RVM_DEBUG,"Failed to allocate block \n");
+                exit(-1);
+        }
+        RVM_LOG(RVM_DEBUG,"starting address of mptr on seg[%p]: %p \n",
+               mseg_hdr, seg1_mptr[1]);
+        seg1_mptr[1] = rds_malloc(mseg_hdr, bSize, tid, &err);
+        if(mptr == NULL)	{
+                RVM_LOG(RVM_DEBUG,"Failed to allocate block \n");
+                exit(-1);
+        }
+        RVM_LOG(RVM_DEBUG,"starting address of mptr on seg[%p]: %p \n",
+               mseg_hdr, seg1_mptr[1]);
+
+        mseg_hdr = seg_hdr[3];
+        rds_free(mseg_hdr, mptr, tid, &err);
+        RVM_LOG(RVM_DEBUG,"free allocate memory to mptr on seg[%p] : %p \n",
+               mseg_hdr, mptr);
+
+        rvm_end_transaction(tid, flush);
+}
+
+
+static void test_rds_stat()
+{
+      RVM_LOG(RVM_DEBUG,"--------------------------------------------------\n");
+      RVM_LOG(RVM_DEBUG,"Segment : seg[%p] static : %p \n", seg_hdr[0], seg_hdr[0]->static_addr);
+      rds_print_stats(seg_hdr[0]);
+      RVM_LOG(RVM_DEBUG,"--------------------------------------------------\n");
+      RVM_LOG(RVM_DEBUG,"Segment : seg[%p] static : %p \n", seg_hdr[1], seg_hdr[1]->static_addr);
+      rds_print_stats(seg_hdr[1]);
+      RVM_LOG(RVM_DEBUG,"--------------------------------------------------\n");
+      RVM_LOG(RVM_DEBUG,"Segment : seg[%p] static : %p \n", seg_hdr[2], seg_hdr[2]->static_addr);
+      rds_print_stats(seg_hdr[2]);
+      RVM_LOG(RVM_DEBUG,"--------------------------------------------------\n");
+      RVM_LOG(RVM_DEBUG,"Segment : seg[%p] static : %p \n", seg_hdr[3], seg_hdr[3]->static_addr);
+      rds_print_stats(seg_hdr[3]);
+      RVM_LOG(RVM_DEBUG,"--------------------------------------------------\n");
+}
+
+const struct m0_test_suite rvm_ut = {
+        .ts_name = "rvm-ut",
+        .ts_init = ts_be_init,
+        .ts_fini = ts_be_fini,
+        .ts_tests = {
+                { "rvm-segload", test_seg_load },
+                { "rvm-test", test_rvm },
+                { "rvm-rdsstat", test_rds_stat },
+                { NULL, NULL },
+        }
+};
+
+#if 1
+int main()
+{
+        ts_be_init();
+        test_seg_load();
+        test_rvm();
+        test_rds_stat();
+        /*sleep(30);*/
+        ts_be_fini();
+        return 0;
+}
+#endif
+#undef M0_TRACE_SUBSYSTEM
+/** @} end group rvm_ut */
+
+/*
+ *  Local variables:
+ *  c-indentation-style: "K&R"
+ *  c-basic-offset: 8
+ *  tab-width: 8
+ *  fill-column: 80
+ *  scroll-step: 1
+ *  End:
+ */
diff --git a/rvm/ut/rvmlib.h b/rvm/ut/rvmlib.h
new file mode 100644
index 0000000..098ab80
--- /dev/null
+++ b/rvm/ut/rvmlib.h
@@ -0,0 +1,140 @@
+/* BLURB gpl
+
+                           Coda File System
+                              Release 6
+
+          Copyright (c) 1987-2003 Carnegie Mellon University
+                  Additional copyrights listed below
+
+This  code  is  distributed "AS IS" without warranty of any kind under
+the terms of the GNU General Public Licence Version 2, as shown in the
+file  LICENSE.  The  technical and financial  contributors to Coda are
+listed in the file CREDITS.
+
+                        Additional copyrights
+                           none currently
+
+#*/
+
+
+#ifndef _RVMLIB_H_
+#define _RVMLIB_H_ 1
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <unistd.h>
+#include <stdlib.h>
+#include <setjmp.h>
+
+#include "lwp/lwp.h"
+#include "rvm/rvm.h"
+#include "rvm/rds.h"
+#include "util.h"
+
+#ifdef __cplusplus
+}
+#endif
+
+
+
+/*  *****  Types  *****  */
+
+typedef enum {	UNSET =	0,		/* uninitialized */
+		RAWIO = 1,		/* raw disk partition */
+		UFS = 2,		/* Unix file system */
+		VM = 3			/* virtual memory */
+} rvm_type_t;
+
+typedef struct {
+	rvm_tid_t *tid;
+	rvm_tid_t tids;
+	/*	jmp_buf abort; */
+	intentionList_t list;
+} rvm_perthread_t;
+
+
+/*  *****  Variables  *****  */
+
+extern rvm_type_t RvmType;	 /* your program must supply this! */
+extern long rvm_no_yield;	 /*  exported by rvm */
+
+/*  ***** Functions  ***** */
+
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+int rvmlib_in_transaction(void);
+void rvmlib_abort(int);
+
+void rvmlib_set_range(void *base, unsigned long size);
+void rvmlib_modify_bytes(void *dest, const void *newval, int len);
+char *rvmlib_strdup(const char *src, const char *file, int line);
+
+void *rvmlib_malloc(unsigned long size, const char *file, int line);
+void rvmlib_free(void *p, const char *file, int line);
+
+void rvmlib_init_threaddata(rvm_perthread_t *rvmptt);
+extern void rvmlib_set_thread_data(void *);
+rvm_perthread_t *rvmlib_thread_data(void);
+
+void rvmlib_begin_transaction(int restore_mode);
+void rvmlib_end_transaction(int flush_mode, rvm_return_t *statusp);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#define CODA_STACK_LENGTH 0x20000	/* 128 K */
+#define LOGTHRESHOLD	50
+
+/* pointer to rvm_perthread_t must be under this rock! */
+extern int optimizationson;
+
+#define RVMLIB_ASSERT(errmsg) \
+do { \
+    fprintf(stderr, "RVMLIB_ASSERT: %s\n", errmsg); \
+    fflush(stderr); \
+    coda_assert("0", __FILE__, __LINE__); \
+} while (0)
+
+
+#define rvmlib_rec_malloc(size) rvmlib_malloc(size, __FILE__, __LINE__)
+#define rvmlib_rec_free(addr) rvmlib_free(addr, __FILE__, __LINE__)
+#define rvmlib_rec_strdup(size) rvmlib_strdup(size, __FILE__, __LINE__)
+
+#define RVMLIB_REC_OBJECT(object) rvmlib_set_range(&(object), sizeof(object))
+
+
+inline void rvmlib_check_trans(char *where, char *file);
+#define rvmlib_intrans()  rvmlib_check_trans(__FUNCTION__, __FILE__)
+
+
+/* macros */
+
+#define RVMLIB_MODIFY(object, newValue)					    \
+do {									    \
+    rvm_perthread_t *_rvm_data = rvmlib_thread_data();\
+    if (RvmType == VM) (object) = (newValue);	    	    		    \
+    else if (RvmType == RAWIO || RvmType == UFS) { /* is object a pointer? */		    \
+        rvm_return_t ret = rvm_set_range(_rvm_data->tid, (char *)&object, sizeof(object)); \
+	if (ret != RVM_SUCCESS)						    \
+	    printf("Modify Bytes error %s\n",rvm_return(ret));		    \
+        CODA_ASSERT(ret == RVM_SUCCESS);					    \
+        (object) = (newValue);						    \
+    }									    \
+    else {								    \
+       CODA_ASSERT(0);							    \
+    }								    	    \
+} while(0)
+
+
+
+
+#endif /* _RVMLIB_H_ */
+
diff --git a/rvm/ut/util.h b/rvm/ut/util.h
new file mode 100644
index 0000000..7f0ee97
--- /dev/null
+++ b/rvm/ut/util.h
@@ -0,0 +1,113 @@
+/* BLURB gpl
+
+                           Coda File System
+                              Release 6
+
+          Copyright (c) 1987-2003 Carnegie Mellon University
+                  Additional copyrights listed below
+
+This  code  is  distributed "AS IS" without warranty of any kind under
+the terms of the GNU General Public Licence Version 2, as shown in the
+file  LICENSE.  The  technical and financial  contributors to Coda are
+listed in the file CREDITS.
+
+                        Additional copyrights
+
+#*/
+
+/*
+                         IBM COPYRIGHT NOTICE
+
+                          Copyright (C) 1986
+             International Business Machines Corporation
+                         All Rights Reserved
+
+This  file  contains  some  code identical to or derived from the 1986
+version of the Andrew File System ("AFS"), which is owned by  the  IBM
+Corporation.   This  code is provided "AS IS" and IBM does not warrant
+that it is free of infringement of  any  intellectual  rights  of  any
+third  party.    IBM  disclaims  liability of any kind for any damages
+whatsoever resulting directly or indirectly from use of this  software
+or  of  any  derivative work.  Carnegie Mellon University has obtained
+permission to  modify,  distribute and sublicense this code,  which is
+based on Version 2  of  AFS  and  does  not  contain  the features and
+enhancements that are part of  Version 3 of  AFS.  Version 3 of AFS is
+commercially   available   and  supported  by   Transarc  Corporation,
+Pittsburgh, PA.
+
+*/
+
+//#include "coda_assert.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <unistd.h>
+#include <stdlib.h>
+#include <signal.h>
+#include <stdio.h>
+
+#ifndef IN  /* rpc2.private.h also defines these */
+/* Parameter usage */
+#define	IN	/* Input parameter */
+#define OUT	/* Output parameter */
+#define INOUT	/* Obvious */
+#endif /* !IN */
+
+
+#define TRUE 1
+#define FALSE 0
+
+/* Useful functions in libutil.a */
+int SafeStrCat(char *dest, char *src, int totalspace);
+int SafeStrCpy(char *dest, char *src, int totalspace);
+int HashString(char *s, unsigned int size);
+void eprint(char *, ...);
+void fdprint(long afd, char *fmt, ...);
+
+/* Routine for conditionally printing timestamped log messages */
+extern void LogMsg(int msglevel, int debuglevel, FILE *fout, char *fmt,  ...);
+#define VLog(level, format, a...)   LogMsg(level, VolDebugLevel, stdout, format, ## a)
+#define SLog(level, format, a...)   LogMsg(level, SrvDebugLevel, stdout, format, ## a)
+#define DLog(level, format, a...)   LogMsg(level, DirDebugLevel, stdout, format, ## a)
+#define ALog(level, format, a...)   LogMsg(level, VolDebugLevel, stdout, format, ## a)
+#define CLog(level, format, a...)   LogMsg(level, VolDebugLevel, stdout, format, ## a)
+
+/* The routine that prints the timestamp */
+extern void PrintTimeStamp(FILE *fout);
+
+/* Hostname related utilities */
+int UtilHostEq(const char *name1, const char *name2);
+char *hostname(char *name);
+
+  /* Process releted utilities */
+void UtilDetach();
+
+/* Useful locking macros */
+#define U_wlock(b)      ObtainWriteLock(&((b)->lock))
+#define U_rlock(b)      ObtainReadLock(&((b)->lock))
+#define U_wunlock(b)    ReleaseWriteLock(&((b)->lock))
+#define U_runlock(b)    ReleaseReadLock(&((b)->lock))
+
+/* Extern decls for variables used in Coda to control verbosity of
+   messages from LogMsg(). Should these be here?
+*/
+
+extern int SrvDebugLevel;	/* Server */
+extern int VolDebugLevel;	/* Vol package */
+extern int DirDebugLevel;	/* Dir package */
+extern int AL_DebugLevel;	/* ACL package */
+extern int AuthDebugLevel;	/* Auth package */
+
+#ifdef __CYGWIN32__
+#include <stdarg.h>
+  /* int vsnprintf(char *buf, size_t len, char *fmt, va_list ap); */
+int snprintf(char *buf, size_t len, const char *fmt, ...);
+long int gethostid(void);
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
diff --git a/utils/ut_main.c b/utils/ut_main.c
index 3c05a5b..fa59a30 100644
--- a/utils/ut_main.c
+++ b/utils/ut_main.c
@@ -75,6 +75,7 @@ extern const struct m0_test_suite reqh_ut;
 extern const struct m0_test_suite rpc_mc_ut;
 extern const struct m0_test_suite rpc_service_ut;
 extern const struct m0_test_suite rpclib_ut;
+extern const struct m0_test_suite rvm_ut;
 extern const struct m0_test_suite session_ut;
 extern const struct m0_test_suite sm_ut;
 extern const struct m0_test_suite sns_repair_ut;
@@ -95,8 +96,9 @@ void add_uts(void)
         m0_ut_add(&libm0_ut); /* test lib first */
         m0_ut_add(&ad_ut);
         m0_ut_add(&adieu_ut);
+        /*m0_ut_add(&rvm_ut);*/
         /*m0_ut_add(&be_hs_ut);*/
-        m0_ut_add(&be_kv_store_ut);
+        /*m0_ut_add(&be_kv_store_ut);*/
         /*m0_ut_add(&be_ut);*/
 	m0_ut_add(&balloc_ut);
         m0_ut_add(&buffer_pool_ut);
-- 
1.8.3.2

