From 05db926df9767313617bbfbcba68ebf2987313e5 Mon Sep 17 00:00:00 2001
From: Zishan Shaikh <zishan_shaikh@xyratex.com>
Date: Mon, 6 May 2013 05:11:00 -0700
Subject: [PATCH 085/121] Modified kv_store and cob UT to support log_stob
 impl, removed helpers for ks insert and delete, cob and kv_store UTs both use
 async implementation

---
 be/helper.c         | 120 +----------------
 be/helper.h         |  16 +--
 be/ut/be.c          |   5 +-
 be/ut/kv_store.c    | 372 ++++++++++++++++++++++++++++++++++++--------------
 cob/cob.c           | 381 +++++++++++++++++++++++++++++++++++++++++++++-------
 cob/cob.h           |  40 +++++-
 cob/ut/cob.c        |  98 +++++++++++++-
 rvm/rds_zap.c       |   7 +-
 rvm/rvm_logrecovr.c |   4 +-
 9 files changed, 742 insertions(+), 301 deletions(-)

diff --git a/be/helper.c b/be/helper.c
index c32809c..1ef3870 100644
--- a/be/helper.c
+++ b/be/helper.c
@@ -119,107 +119,6 @@ M0_INTERNAL void m0_be_wait(struct m0_sm_group *sm_group,
 }
 M0_EXPORTED(m0_be_wait);
 
-M0_INTERNAL void m0_kv_init_helper(struct m0_be_domain      **dom,
-                                   struct m0_be_kv_store    **handle,
-                                   struct m0_tl_descr        *list_descr,
-                                   kv_key_cmp_t               cmp_routine,
-                                   kv_key_match_t             match_routine,
-                                   struct m0_be_kv_store_cb  *cb_info,
-                                   enum   m0_be_ks_init_mode  init_mode,
-                                   int32_t                    handle_index,
-                                   struct m0_stob            *bd_stob,
-                                   struct m0_stob            *log_stob)
-
-{
-        struct m0_sm_group        *sm_group;
-        struct m0_be_seg          *kv_seg;
-        const char                *stob_dir;
-        const char                *stob_file;
-        const char                *log_file;
-        char                       kv_cmd[1024];
-        int                        rc;
-
-        if (init_mode == M0_BE_KS_CREATE) {
-                stob_file = "0000000000000000.0000000000000001";
-                stob_dir  = "/tmp/__be/o";
-                log_file  = "/tmp/log_file";
-
-                sprintf(kv_cmd, "mkdir -p %s", stob_dir);
-                rc = system(kv_cmd);
-                M0_ASSERT(rc == 0);
-
-                sprintf(kv_cmd,
-                        "dd if=/dev/zero of=%s/%s bs=1024 count=204800"
-                        " 2>/dev/null",
-                        stob_dir, stob_file);
-                rc = system(kv_cmd);
-                M0_ASSERT(rc == 0);
-        }
-
-        m0_be_ks_init_domain(dom, bd_stob, log_stob);
-        M0_ASSERT(dom != NULL);
-
-        M0_ALLOC_PTR(kv_seg);
-        M0_ASSERT(kv_seg != NULL);
-        sm_group = m0_be_domain_sm_group(*dom);
-
-        if (init_mode == M0_BE_KS_CREATE) {
-                m0_be_seg_init(kv_seg, *dom, sm_group, 0);
-                m0_be_seg_create(kv_seg, NULL, BE_KV_SEG_NAME, NULL, NULL);
-        } else {
-                /* Try to restore (open) the segment in @dom */
-                m0_be_domain_seg_restore(*dom, BE_KV_SEG_NAME, kv_seg, NULL);
-        }
-
-        m0_be_wait(sm_group, &kv_seg->bs_sm, M0_BITS(M0_BESEG_ACTIVE,
-                                                     M0_BESEG_FAILED));
-        /* Create a kv-store handle */
-        m0_be_ks_create(list_descr, *dom,
-                        cmp_routine, match_routine, handle_index, handle);
-        M0_ASSERT(*handle != NULL);
-
-
-        /* Initialise the kv-store i.e. create or recover from RVM */
-        m0_be_ks_init(*handle, cb_info, init_mode);
-        m0_be_wait(sm_group, &(*handle)->ks_handle_heap.ksh_sm,
-                   M0_BITS(M0_BEKS_DONE));
-
-        M0_ASSERT((*handle)->ks_handle_rvm != NULL);
-}
-M0_EXPORTED(m0_kv_init_helper);
-
-M0_INTERNAL int32_t m0_kv_insert_helper(struct m0_be_kv_store  *handle,
-                                        struct m0_be_reference *ref,
-                                        struct m0_be_tx        *tx)
-{
-        int32_t                    status  = -2;
-        struct m0_sm_group        *sm_group;
-        struct m0_be_domain       *dom;
-
-        M0_PRE(tx->bt_sm.sm_state == M0_BETX_OPEN);
-
-        dom = handle->ks_handle_heap.ksh_dom;
-        M0_ASSERT(dom != NULL);
-        M0_ASSERT(ref != NULL);
-
-        sm_group = m0_be_domain_sm_group(dom);
-
-        /* Insert this into the kv_store */
-        status = m0_be_ks_insert(handle, NULL, ref, tx);
-        if (status != 0)
-                goto exit;
-
-        m0_be_tx_done(tx, NULL);
-        m0_be_wait(sm_group, &tx->bt_sm,
-                   M0_BITS(M0_BETX_DONE, M0_BETX_FAILED));
-        m0_be_tx_fini(tx);
-        m0_free(tx);
-
-exit:
-        return status;
-}
-M0_EXPORTED(m0_kv_insert_helper);
-
 M0_INTERNAL void *m0_kv_malloc_helper(struct m0_be_domain     *cob_be_domain,
                                       struct m0_be_tx        **tx_out,
                                       struct m0_be_reference **ref_out,
@@ -303,10 +202,10 @@ M0_INTERNAL void *m0_kv_find_helper(struct m0_be_kv_store *handle,
 M0_EXPORTED(m0_kv_find_helper);
 
 M0_INTERNAL int32_t m0_kv_delete_helper(struct m0_be_kv_store *handle,
+                                        struct m0_be_tx       *tx,
                                         void                  *target,
                                         uint64_t               sizeof_target)
 {
-        struct m0_be_tx           *tx = NULL;
         struct m0_be_reg          *obj_reg = NULL;
         struct m0_be_seg          *kv_seg  = NULL;
         struct m0_sm_group        *sm_group;
@@ -315,11 +214,6 @@ M0_INTERNAL int32_t m0_kv_delete_helper(struct m0_be_kv_store *handle,
         int32_t                    ret_val;
         bool                       ret_dom;
 
-        M0_ALLOC_PTR(tx);
-
-        if (tx == NULL)
-                return -ENOMEM;
-
         kv_dom = handle->ks_handle_heap.ksh_dom;
         M0_ASSERT(kv_dom != NULL);
 
@@ -330,8 +224,6 @@ M0_INTERNAL int32_t m0_kv_delete_helper(struct m0_be_kv_store *handle,
 
         sm_group = m0_be_domain_sm_group(kv_dom);
 
-        m0_be_tx_init(tx, kv_dom, 0);
-
         /* Prepare a region for this object */
         M0_ALLOC_PTR(obj_reg);
         M0_ASSERT(obj_reg != NULL);
@@ -341,19 +233,11 @@ M0_INTERNAL int32_t m0_kv_delete_helper(struct m0_be_kv_store *handle,
         m0_be_reg_init(obj_reg, tx, kv_seg, &obj_buf);
         M0_ASSERT(obj_reg != NULL);
 
-        m0_be_tx_add_cred(tx, obj_reg);
-
-        m0_be_tx_prep(tx);
-        m0_be_tx_start(tx);
+        m0_be_reg_capture(obj_reg);
 
         /* Delete this obj from kv store */
         ret_val = m0_be_ks_delete(handle, NULL, target, tx);
 
-        m0_be_tx_done(tx, NULL);
-        m0_be_wait(sm_group, &tx->bt_sm, M0_BITS(M0_BETX_DONE, M0_BETX_FAILED));
-
-        m0_be_tx_fini(tx);
-        m0_free(tx);
         m0_free(obj_reg);
         return ret_val;
 }
diff --git a/be/helper.h b/be/helper.h
index 7171221..897f96d 100644
--- a/be/helper.h
+++ b/be/helper.h
@@ -65,17 +65,6 @@ M0_INTERNAL void m0_be_ks_prep_link_reg(struct m0_be_domain    *dom,
 M0_INTERNAL void m0_be_wait(struct m0_sm_group *sm_group,
                             struct m0_sm       *sm, uint64_t allowed_states);
 
-M0_INTERNAL void m0_kv_init_helper(struct m0_be_domain       **dom,
-                                   struct m0_be_kv_store     **handle,
-                                   struct m0_tl_descr         *list_descr,
-                                   kv_key_cmp_t                cmp_routine,
-                                   kv_key_match_t              match_routine,
-                                   struct m0_be_kv_store_cb   *cb_info,
-                                   enum   m0_be_ks_init_mode   init_mode,
-                                   int32_t                     handle_index,
-                                   struct m0_stob             *bd_stob,
-                                   struct m0_stob             *log_stob);
-
 /**
   Wrapper over m0_be_ks_obj_malloc. tx_out maybe NULL.
   If tx_out is NULL, it starts a transaction and returns it back.
@@ -85,10 +74,6 @@ M0_INTERNAL void *m0_kv_malloc_helper(struct m0_be_domain     *cob_be_domain,
                                       struct m0_be_reference **ref_out,
                                       uint64_t                 sizeof_obj);
 
-M0_INTERNAL int32_t m0_kv_insert_helper(struct m0_be_kv_store  *handle,
-                                        struct m0_be_reference *ref,
-                                        struct m0_be_tx        *tx);
-
 M0_INTERNAL void *m0_kv_find_helper(struct m0_be_kv_store *handle,
                                     void                  *key,
                                     void                  *cbdata,
@@ -97,6 +82,7 @@ M0_INTERNAL void *m0_kv_find_helper(struct m0_be_kv_store *handle,
                                                                     int   rc));
 
 M0_INTERNAL int32_t m0_kv_delete_helper(struct m0_be_kv_store *handle,
+                                        struct m0_be_tx       *tx,
                                         void                  *target,
                                         uint64_t               sizeof_target);
 
diff --git a/be/ut/be.c b/be/ut/be.c
index 8d91c78..eaeeb08 100644
--- a/be/ut/be.c
+++ b/be/ut/be.c
@@ -68,7 +68,6 @@ struct m0_stob_domain    *stob_dom;
 struct m0_be_cbinfo       pcbinfo;
 char                      path_name[MAXPATHLEN];
 
-
 /*
  * Holds ast callback info and user sm_goup, used to return control from handler
  * thread to user.
@@ -235,9 +234,7 @@ static int ts_be_init(void)   /* ts_ for "test suite" */
                 m0_sm_group_lock(&usr_sm_group);
                 m0_sm_asts_run(&usr_sm_group);
                 m0_sm_group_unlock(&usr_sm_group);
-        }
-
-        /* while(bt_cbdata->completed == false);*/
+       }
 
         if (m0_be_seg_state(seg) == M0_BESEG_FAILED) {
                 rc = -1;
diff --git a/be/ut/kv_store.c b/be/ut/kv_store.c
index a313aa9..6e99dd9 100644
--- a/be/ut/kv_store.c
+++ b/be/ut/kv_store.c
@@ -56,6 +56,23 @@ struct m0_kv_store_obj {
         uint64_t              magic;
 };
 
+/*
+ * Holds ast callback info and user sm_goup, used to return control from handler
+ * thread to user.
+ */
+struct m0_be_usr_astinfo {
+        struct m0_sm_group        *bua_sm_group;
+        struct m0_sm_ast           bua_ast;
+        enum   m0_be_ks_init_mode  bua_ks_init_mode;
+        m0_be_msg_type_t           bua_msg;
+        int                        bua_status;
+};
+
+struct m0_be_ts_cbdata {
+        struct m0_be_cbinfo        cbinfo;
+        struct m0_be_usr_astinfo  *be_usr_ast;
+};
+
 struct m0_tl_descr kv_list_descr1 = M0_TL_DESCR("kv_store_obj1",
                                                 struct m0_kv_store_obj,
                                                 linkage,
@@ -75,22 +92,46 @@ struct m0_kv_store_obj     *object1[UT_UB_ITER]   = {NULL};
 struct m0_kv_store_obj     *object2[UT_UB_ITER]   = {NULL};
 struct m0_kv_store_obj     *ret_obj1[UT_UB_ITER]  = {NULL};
 struct m0_kv_store_obj     *ret_obj2[UT_UB_ITER]  = {NULL};
-struct m0_be_kv_store      *handle1         =  NULL;
-struct m0_be_kv_store      *handle2         =  NULL;
+struct m0_be_kv_store      *handle1               =  NULL;
+struct m0_be_kv_store      *handle2               =  NULL;
+struct m0_be_kv_store_cb   *cb_info;
+struct m0_be_ts_cbdata     *bt_cbdata;
 struct m0_sm_group         *sm_group;
 static const char          *stob_dir  = "/tmp/__be/o";
 static const char          *stob_file = "0000000000000000.0000000000000001";
 extern const char          *log_file;
 struct m0_stob             *log_stob;
 struct m0_stob_domain      *stob_dom;
+struct m0_sm_group          usr_sm_group;
+char                       *operation_name;
 char                        path_name[MAXPATHLEN];
 char                        kv_cmd[1024];
+int                         count;
+
+static void be_usr_ast_post_helper(struct m0_be_usr_astinfo *be_usr_ast)
+{
+        struct m0_sm_ast   *usr_ast;
+        usr_ast      = &be_usr_ast->bua_ast;
+        m0_sm_group_lock(sm_group);
+        m0_sm_ast_post(&usr_sm_group, usr_ast);
+        m0_sm_group_unlock(sm_group);
+}
 
+void increment_count_ast_cb(struct m0_sm_group *sm_group, struct m0_sm_ast *ast)
+{
+        count++;
+}
 
 /** Callback function to be called after operation completion. */
 void init_operation_callback(void *operation_name, void *result, int rc)
 {
+        printf("init_kv_store pid = %x\n", (unsigned int)pthread_self());
+        struct m0_be_usr_astinfo *astinfo;
         m0_free(operation_name);
+
+        M0_ALLOC_PTR(astinfo);
+        astinfo->bua_ast.sa_cb = increment_count_ast_cb;
+        be_usr_ast_post_helper(astinfo);
 }
 
 /** Callback function to be called after operation completion. */
@@ -166,6 +207,14 @@ void function_update(void *old_obj, void *new_obj, struct m0_be_tx *tx)
         old->obj_val = new->obj_val;
 }
 
+static void wait_and_lock_usr_sm_group()
+{
+        m0_chan_wait(&usr_sm_group.s_clink);
+        m0_sm_group_lock(&usr_sm_group);
+        m0_sm_asts_run(&usr_sm_group);
+        m0_sm_group_unlock(&usr_sm_group);
+}
+
 static int log_stob_create(void)
 {
         struct linux_stob        *lstob;
@@ -196,7 +245,7 @@ static int log_stob_create(void)
         result = m0_stob_create(log_stob, NULL);
 
         if (result < 0) {
-                M0_LOG(M0_ERROR, "Failed to creat stob in m0_be_seg_create_cb");
+                M0_LOG(M0_ERROR, "Failed to creat stob.");
                 return -1;
         }
 
@@ -215,37 +264,82 @@ static int log_stob_create(void)
         if (nbytes < 0)
                 return -1;
 
-        printf("log stob : %s\n", path_name);
         return 0;
 }
 
-static int ts_kv_store_init()
+static void __init_kv_store1(struct m0_sm_group *sm_group,
+                             struct m0_sm_ast   *ast)
 {
-        struct m0_be_kv_store_cb  *cb_info;
-        int                        rc;
-        char                      *operation_name;
+        struct m0_be_usr_astinfo   *astinfo;
+        enum   m0_be_ks_init_mode  init_mode;
 
-        M0_LOG(M0_DEBUG,"KV Store Initialization");
+        astinfo   = container_of(ast, struct m0_be_usr_astinfo, bua_ast);
+        init_mode = astinfo->bua_ks_init_mode;
 
-        sprintf(kv_cmd, "mkdir -p %s", stob_dir);
-        rc = system(kv_cmd);
-        M0_ASSERT(rc == 0);
+        /* Initialise the kv-store i.e. create on RVM */
+        m0_be_ks_init(handle1, cb_info, init_mode);
+}
 
-        sprintf(kv_cmd,
-                "dd if=/dev/zero of=%s/%s bs=1024 count=204800 2>/dev/null",
-                stob_dir, stob_file);
-        rc = system(kv_cmd);
-        M0_ASSERT(rc == 0);
+static void __init_kv_store2(enum m0_be_ks_init_mode init_mode)
+{
+        operation_name = (char *)malloc(10);
+        strcpy(operation_name, "KS_INIT");
+        cb_info->ksc_cb      = init_operation_callback;
+        cb_info->ksc_cbdata  = (void *)operation_name;
+
+        m0_be_ks_init(handle2, cb_info, init_mode);
+
+        M0_LOG(M0_INFO, "kv_store initialised!");
+        m0_free(cb_info);
+
+        M0_ASSERT(handle1->ks_handle_rvm != NULL);
+        M0_ASSERT(handle2->ks_handle_rvm != NULL);
+}
+
+
+void be_kv_ts_cb(struct m0_be_cbinfo *cbinfo, int status,
+                 m0_be_msg_type_t msg_type)
+{
+        struct m0_be_ts_cbdata *cbdata;
+        M0_ASSERT(cbinfo != NULL);
+        cbdata = container_of(cbinfo, struct m0_be_ts_cbdata, cbinfo);
+
+        if (cbdata->be_usr_ast != NULL) {
+                cbdata->be_usr_ast->bua_status    = status;
+                cbdata->be_usr_ast->bua_msg       = msg_type;
 
-        kv_key_cmp_t     cmp_routine;
-        kv_key_match_t   match_routine;
+                be_usr_ast_post_helper(cbdata->be_usr_ast);
+        }
+}
+
+static void __initialise_handle1(enum m0_be_ks_init_mode init_mode)
+{
+        kv_key_cmp_t             cmp_routine;
+        kv_key_match_t           match_routine;
+        int                      rc;
 
         cmp_routine   = &function_comp;
         match_routine = &function_match;
 
+        sprintf(kv_cmd, "mkdir -p %s", stob_dir);
+        rc = system(kv_cmd);
+        M0_ASSERT(rc == 0);
+
         rc = log_stob_create();
         M0_ASSERT(rc == 0);
 
+        M0_ALLOC_PTR(bt_cbdata);
+
+        /* set cbinfo for tx_done. */
+        bt_cbdata->cbinfo.bc_cb              =  be_kv_ts_cb;
+        bt_cbdata->cbinfo.bc_sm_group        =  sm_group;
+        bt_cbdata->cbinfo.bc_hq              = &kv_dom->bd_hq;
+        bt_cbdata->cbinfo.bc_pcbinfo         =  NULL;
+
+        M0_ALLOC_PTR(bt_cbdata->be_usr_ast);
+        bt_cbdata->be_usr_ast->bua_sm_group  = &usr_sm_group;
+
+        /* Initialise the kv store. */
         m0_be_ks_init_domain(&kv_dom, NULL, log_stob);
         M0_ASSERT(kv_dom != NULL);
 
@@ -254,13 +348,9 @@ static int ts_kv_store_init()
                         cmp_routine, match_routine, 0, &handle1);
         M0_ASSERT(handle1 != NULL);
 
-        m0_be_ks_create(&kv_list_descr2, kv_dom,
-                        cmp_routine, match_routine, 1, &handle2);
-        M0_ASSERT(handle2 != NULL);
-
         sm_group = m0_be_domain_sm_group(kv_dom);
 
-        /* Set the callback information */
+        /* Set the callback information for ks_init*/
         M0_ALLOC_PTR(cb_info);
         M0_ASSERT(cb_info != NULL);
 
@@ -270,40 +360,81 @@ static int ts_kv_store_init()
         cb_info->ksc_cb      = init_operation_callback;
         cb_info->ksc_cbdata  = (void *)operation_name;
 
-        /* Create a new segment */
+        /* Create a new segment, and also the callback information needed */
         /* @todo: segment name is hardcoded for now */
         M0_ALLOC_PTR(kv_seg);
         M0_ASSERT(kv_seg != NULL);
-        m0_be_seg_init(kv_seg, kv_dom, sm_group, 0);
-        m0_be_seg_create(kv_seg, NULL, BE_KV_SEG_NAME, NULL, NULL);
-        m0_be_wait(sm_group, &kv_seg->bs_sm, M0_BITS(M0_BESEG_ACTIVE,
-                                                     M0_BESEG_FAILED));
 
-        /* Initialise the kv-store i.e. create on RVM */
-        m0_be_ks_init(handle1, cb_info, M0_BE_KS_CREATE);
-        m0_be_wait(sm_group, &handle1->ks_handle_heap.ksh_sm,
-                   M0_BITS(M0_BEKS_DONE));
-        M0_ASSERT(handle1->ks_handle_rvm != NULL);
+        bt_cbdata->cbinfo.bc_cb        = be_kv_ts_cb;
+        bt_cbdata->cbinfo.bc_sm_group  = sm_group;
+        bt_cbdata->cbinfo.bc_hq        = &kv_dom->bd_hq;
+        bt_cbdata->cbinfo.bc_pcbinfo   = NULL;
+
+        M0_ALLOC_PTR(bt_cbdata->be_usr_ast);
+        bt_cbdata->be_usr_ast->bua_ks_init_mode = init_mode;
+        bt_cbdata->be_usr_ast->bua_sm_group     = &usr_sm_group;
+        bt_cbdata->be_usr_ast->bua_ast.sa_cb    = __init_kv_store1;
+
+        if (init_mode == M0_BE_KS_CREATE) {
+                m0_be_seg_init(kv_seg, kv_dom, sm_group, 0);
+                m0_be_seg_create(kv_seg, NULL, BE_KV_SEG_NAME, NULL,
+                                 &bt_cbdata->cbinfo);
+        } else {
+                m0_be_domain_seg_restore(kv_dom, BE_KV_SEG_NAME, kv_seg,
+                                         &bt_cbdata->cbinfo);
+        }
 
-        operation_name = (char *)malloc(10);
-        strcpy(operation_name, "KS_INIT");
-        cb_info->ksc_cb      = init_operation_callback;
-        cb_info->ksc_cbdata  = (void *)operation_name;
+        /* Wait for segment create completion. */
+        wait_and_lock_usr_sm_group();
 
-        m0_be_ks_init(handle2, cb_info, M0_BE_KS_CREATE);
-        m0_be_wait(sm_group, &handle2->ks_handle_heap.ksh_sm,
-                   M0_BITS(M0_BEKS_DONE));
-        M0_ASSERT(handle2->ks_handle_rvm != NULL);
+        /*
+         * Wait for ks_init for handle1 to be completed,
+         * called after seg_create_cb completion.
+         */
+        wait_and_lock_usr_sm_group();
+}
 
-        M0_LOG(M0_INFO, "kv_store initialised!");
-        m0_free(cb_info);
+static int ts_kv_store_init()
+{
+        int                        rc;
+        kv_key_cmp_t               cmp_routine;
+        kv_key_match_t             match_routine;
+
+        M0_LOG(M0_DEBUG,"KV Store Initialization");
+
+        sprintf(kv_cmd, "mkdir -p %s", stob_dir);
+        rc = system(kv_cmd);
+        M0_ASSERT(rc == 0);
+
+        sprintf(kv_cmd,
+                "dd if=/dev/zero of=%s/%s bs=1024 count=204800 2>/dev/null",
+                stob_dir, stob_file);
+        rc = system(kv_cmd);
+        M0_ASSERT(rc == 0);
+
+        m0_sm_group_init(&usr_sm_group);
+
+        cmp_routine   = &function_comp;
+        match_routine = &function_match;
+
+        rc = log_stob_create();
+        M0_ASSERT(rc == 0);
+        __initialise_handle1(M0_BE_KS_CREATE);
+
+        /* Initialise handle2. */
+        m0_be_ks_create(&kv_list_descr2, kv_dom,
+                        cmp_routine, match_routine, 1, &handle2);
+        M0_ASSERT(handle2 != NULL);
+
+        __init_kv_store2(M0_BE_KS_CREATE);
+        wait_and_lock_usr_sm_group();
+
+        m0_free(bt_cbdata->be_usr_ast);
         return 0;
 }
 
 void ts_kv_store_fini()
 {
-        struct m0_be_kv_store_cb  *cb_info;
-        char                      *operation_name;
         /* Set the callback information */
         M0_ALLOC_PTR(cb_info);
         M0_ASSERT(cb_info != NULL);
@@ -326,8 +457,10 @@ void ts_kv_store_fini()
 
         m0_be_domain_fini(kv_dom);
         m0_free(kv_dom);
-        kv_dom = NULL;
+        kv_dom  = NULL;
+        handle1 = handle2 = NULL;
         m0_free(cb_info);
+        m0_free(bt_cbdata);
 }
 
 static int insert(struct m0_be_kv_store   *handle,
@@ -338,9 +471,7 @@ static int insert(struct m0_be_kv_store   *handle,
         struct m0_be_reference    *obj_ref;
         struct m0_be_reg          *obj_reg;
         struct m0_be_buf          *obj_buf;
-        struct m0_be_kv_store_cb  *cb_info;
         struct m0_kv_store_obj    *object;
-        char                      *operation_name;
 
         M0_ALLOC_PTR(tx);
 
@@ -394,14 +525,24 @@ static int insert(struct m0_be_kv_store   *handle,
         if (status != 0)
                 goto exit;
 
-        m0_be_tx_done(tx, NULL);
-        m0_be_wait(sm_group, &tx->bt_sm,
-                   M0_BITS(M0_BETX_DONE, M0_BETX_FAILED));
+        /* set cbinfo for tx_done. */
+        bt_cbdata->cbinfo.bc_cb              =  be_kv_ts_cb;
+        bt_cbdata->cbinfo.bc_sm_group        =  sm_group;
+        bt_cbdata->cbinfo.bc_hq              = &kv_dom->bd_hq;
+        bt_cbdata->cbinfo.bc_pcbinfo         =  NULL;
+        M0_ALLOC_PTR(bt_cbdata->be_usr_ast);
+        bt_cbdata->be_usr_ast->bua_sm_group  = &usr_sm_group;
+        bt_cbdata->be_usr_ast->bua_ast.sa_cb = increment_count_ast_cb;
+
+        m0_be_tx_done(tx, &bt_cbdata->cbinfo);
+        wait_and_lock_usr_sm_group();
         m0_be_tx_fini(tx);
+
         m0_free(tx);
         m0_free(obj_reg);
         m0_free(obj_buf);
         m0_free(cb_info);
+        m0_free(bt_cbdata->be_usr_ast);
         *out_object = object;
 exit:
         return status;
@@ -410,8 +551,6 @@ exit:
 static struct m0_kv_store_obj *find(struct m0_be_kv_store *handle,
                                     long int *key)
 {
-        struct m0_be_kv_store_cb  *cb_info;
-        char                      *operation_name;
         void                      *ret_val;
 
         /* Set the callback information */
@@ -435,8 +574,6 @@ static int delete(struct m0_be_kv_store *handle, struct m0_kv_store_obj *target)
         struct m0_be_tx           *tx = NULL;
         struct m0_be_buf          *obj_buf;
         struct m0_be_reg          *obj_reg = NULL;
-        struct m0_be_kv_store_cb  *cb_info;
-        char                      *operation_name;
         int32_t                    ret_val;
 
         M0_ALLOC_PTR(tx);
@@ -476,14 +613,25 @@ static int delete(struct m0_be_kv_store *handle, struct m0_kv_store_obj *target)
         ret_val = m0_be_ks_delete(handle, cb_info, (void *)target, tx);
         m0_be_free_helper(kv_dom, tx, target, sizeof *target);
 
-        m0_be_tx_done(tx, NULL);
-
-        m0_be_wait(sm_group, &tx->bt_sm, M0_BITS(M0_BETX_DONE, M0_BETX_FAILED));
+        /* set cbinfo for tx_done. */
+        bt_cbdata->cbinfo.bc_cb              =  be_kv_ts_cb;
+        bt_cbdata->cbinfo.bc_sm_group        =  sm_group;
+        bt_cbdata->cbinfo.bc_hq              = &kv_dom->bd_hq;
+        bt_cbdata->cbinfo.bc_pcbinfo         =  NULL;
+        M0_ALLOC_PTR(bt_cbdata->be_usr_ast);
+        bt_cbdata->be_usr_ast->bua_sm_group  = &usr_sm_group;
+        bt_cbdata->be_usr_ast->bua_ast.sa_cb = increment_count_ast_cb;
+
+        m0_be_tx_done(tx, &bt_cbdata->cbinfo);
+        wait_and_lock_usr_sm_group();
         m0_be_tx_fini(tx);
+
         m0_free(tx);
         m0_free(obj_reg);
         m0_free(obj_buf);
         m0_free(cb_info);
+        m0_free(bt_cbdata->be_usr_ast);
+        /*m0_free(bt_cbdata);*/
         return ret_val;
 }
 
@@ -493,6 +641,9 @@ void test_kv_store()
         long int i;
         int32_t  status;
 
+        M0_ASSERT(count == 2);
+        count = 0;
+
         /*
          * Lookup for the kv_store segment to be used for allocations while
          * insertion
@@ -537,19 +688,17 @@ void test_recover_and_delete()
         cmp_routine   = &function_comp;
         match_routine = &function_match;
 
-        /*
-         * Recover kv_store handle1.
-         * Segment will be loaded and ready in memory after this.
-         */
-        m0_kv_init_helper(&kv_dom, &handle1, &kv_list_descr1, cmp_routine,
-                          match_routine, NULL, M0_BE_KS_RECOVER, 0, NULL,
-                          log_stob);
+        rc = log_stob_create();
+        M0_ASSERT(rc == 0);
+        M0_ALLOC_PTR(bt_cbdata);
+
+        __initialise_handle1(M0_BE_KS_RECOVER);
+        M0_ASSERT(handle1->ks_handle_rvm != NULL);
 
         length = m0_tlist_length(&kv_list_descr1,
                                  &handle1->ks_handle_rvm->ksr_tlist);
         M0_ASSERT(length == UT_UB_ITER);
 
-        sm_group = m0_be_domain_sm_group(kv_dom);
 
         /* Recover kv_store handle2.*/
         m0_be_ks_create(&kv_list_descr2, kv_dom,
@@ -557,9 +706,8 @@ void test_recover_and_delete()
         M0_ASSERT(handle2 != NULL);
 
         /* Initialise (recover back) handle2. */
-        m0_be_ks_init(handle2, NULL, M0_BE_KS_RECOVER);
-        m0_be_wait(sm_group, &handle2->ks_handle_heap.ksh_sm,
-                   M0_BITS(M0_BEKS_DONE));
+        __init_kv_store2(M0_BE_KS_RECOVER);
+        wait_and_lock_usr_sm_group();
         M0_ASSERT(handle2->ks_handle_rvm != NULL);
 
         length = m0_tlist_length(&kv_list_descr2,
@@ -621,9 +769,22 @@ void test_kv_store_update()
                                      sizeof *ret_obj1[i], function_update);
                 rc = m0_be_ks_update(handle2, tx, NULL, ret_obj2[i],
                                      sizeof *ret_obj2[i], function_update);
-                m0_be_tx_done(tx, NULL);
-                m0_be_wait(sm_group, &tx->bt_sm, M0_BITS(M0_BETX_DONE,
-                                                         M0_BETX_FAILED));
+
+                /* set cbinfo for tx_done. */
+                bt_cbdata->cbinfo.bc_cb              =  be_kv_ts_cb;
+                bt_cbdata->cbinfo.bc_sm_group        =  sm_group;
+                bt_cbdata->cbinfo.bc_hq              = &kv_dom->bd_hq;
+                bt_cbdata->cbinfo.bc_pcbinfo         =  NULL;
+                M0_ALLOC_PTR(bt_cbdata->be_usr_ast);
+                bt_cbdata->be_usr_ast->bua_sm_group  = &usr_sm_group;
+                bt_cbdata->be_usr_ast->bua_ast.sa_cb = increment_count_ast_cb;
+
+                m0_be_tx_done(tx, &bt_cbdata->cbinfo);
+                wait_and_lock_usr_sm_group();
+                m0_be_tx_fini(tx);
+
+                m0_free(tx);
+                m0_free(bt_cbdata->be_usr_ast);
                 M0_UT_ASSERT(rc == 0);
         }
 
@@ -699,17 +860,24 @@ static void ub_kv_insert()
                 goto exit;
         }
 
-        m0_be_tx_done(tx, NULL);
-
-        sleep(3);
-        m0_be_wait(sm_group, &tx->bt_sm,
-                   M0_BITS(M0_BETX_DONE, M0_BETX_FAILED));
-
+        /* set cbinfo for tx_done. */
+        /*M0_ALLOC_PTR(bt_cbdata);*/
+        bt_cbdata->cbinfo.bc_cb              =  be_kv_ts_cb;
+        bt_cbdata->cbinfo.bc_sm_group        =  sm_group;
+        bt_cbdata->cbinfo.bc_hq              = &kv_dom->bd_hq;
+        bt_cbdata->cbinfo.bc_pcbinfo         =  NULL;
+        M0_ALLOC_PTR(bt_cbdata->be_usr_ast);
+        bt_cbdata->be_usr_ast->bua_sm_group  = &usr_sm_group;
+        bt_cbdata->be_usr_ast->bua_ast.sa_cb = increment_count_ast_cb;
+
+        m0_be_tx_done(tx, &bt_cbdata->cbinfo);
+        wait_and_lock_usr_sm_group();
         m0_be_tx_fini(tx);
 
 exit:
         ref_i++;
         m0_free(tx);
+        m0_free(bt_cbdata->be_usr_ast);
 }
 
 static void ub_kv_find()
@@ -733,25 +901,20 @@ static void ub_init(void)
         struct m0_be_reference  *obj_ref;
         struct m0_be_reg        *obj_reg;
         struct m0_be_buf        *obj_buf;
-        kv_key_cmp_t             cmp_routine;
-        kv_key_match_t           match_routine;
         int                      rc;
-        bool                     ret_dom;
-
-        cmp_routine   = &function_comp;
-        match_routine = &function_match;
 
-        rc = log_stob_create();
+        sprintf(kv_cmd, "mkdir -p %s", stob_dir);
+        rc = system(kv_cmd);
         M0_ASSERT(rc == 0);
 
-        /* Initialise the kv store. */
-        m0_kv_init_helper(&kv_dom, &handle1, &kv_list_descr1, cmp_routine,
-                          match_routine, NULL, M0_BE_KS_CREATE, 0, NULL,
-                          log_stob);
+        sprintf(kv_cmd,
+                "dd if=/dev/zero of=%s/%s bs=1024 count=204800 2>/dev/null",
+                stob_dir, stob_file);
+        rc = system(kv_cmd);
+        M0_ASSERT(rc == 0);
 
-        ret_dom = m0_be_domain_lookup(kv_dom, BE_KV_SEG_NAME, &kv_seg);
-        M0_ASSERT(ret_dom);
-        sm_group = m0_be_domain_sm_group(kv_dom);
+        m0_sm_group_init(&usr_sm_group);
+        __initialise_handle1(M0_BE_KS_CREATE);
 
         /*
          * Allocate memory to the objects to be inserted and keep them ready
@@ -796,17 +959,23 @@ static void ub_init(void)
                 object1[val]->key     = val;
                 object1[val]->obj_val = val;
 
-                m0_be_tx_done(tx, NULL);
-
-                sleep(3);
-                m0_be_wait(sm_group, &tx->bt_sm,
-                           M0_BITS(M0_BETX_DONE, M0_BETX_FAILED));
-
+                /* set cbinfo for tx_done. */
+                /*M0_ALLOC_PTR(bt_cbdata);*/
+                bt_cbdata->cbinfo.bc_cb              =  be_kv_ts_cb;
+                bt_cbdata->cbinfo.bc_sm_group        =  sm_group;
+                bt_cbdata->cbinfo.bc_hq              = &kv_dom->bd_hq;
+                bt_cbdata->cbinfo.bc_pcbinfo         =  NULL;
+                M0_ALLOC_PTR(bt_cbdata->be_usr_ast);
+                bt_cbdata->be_usr_ast->bua_sm_group  = &usr_sm_group;
+                bt_cbdata->be_usr_ast->bua_ast.sa_cb = increment_count_ast_cb;
+
+                m0_be_tx_done(tx, &bt_cbdata->cbinfo);
+                wait_and_lock_usr_sm_group();
                 m0_be_tx_fini(tx);
-
                 m0_free(tx);
                 m0_free(obj_reg);
                 m0_free(obj_buf);
+                m0_free(bt_cbdata->be_usr_ast);
         }
 
 }
@@ -826,7 +995,10 @@ static void ub_fini()
         m0_be_ks_fini(handle1, NULL);
         m0_be_seg_done(kv_seg);
         m0_be_domain_fini(kv_dom);
+        m0_stob_domain_fini(stob_dom);
+
         m0_free(kv_dom);
+        m0_free(bt_cbdata);
 
         sprintf(kv_cmd, "rm -rf %s", stob_dir);
         rc = system(kv_cmd);
diff --git a/cob/cob.c b/cob/cob.c
index f922f79..e63b706 100644
--- a/cob/cob.c
+++ b/cob/cob.c
@@ -38,6 +38,7 @@
 /** Declarations needed for kv_store integration. */
 #include "be/helper.h"
 #include "be/kv_store.h"
+#include <stdlib.h>
 extern const char BE_KV_SEG_NAME[];
 
 /**
@@ -55,6 +56,46 @@ struct m0_tl_descr cob_ns_list_descr = M0_TL_DESCR("cob-nsrec-pair",
 
 /* Global here for now */
 struct m0_be_domain  *cob_be_domain = NULL;
+/** All user call backs are executed in caller context via this sm_group. */
+struct m0_sm_group    cob_sm_group;
+
+static void wait_and_lock_cob_sm_group()
+{
+        m0_chan_wait(&cob_sm_group.s_clink);
+
+        m0_sm_group_lock(&cob_sm_group);
+        m0_sm_asts_run(&cob_sm_group);
+        m0_sm_group_unlock(&cob_sm_group);
+}
+
+void __be_tx_done_ast_cb(struct m0_sm_group *sm_group, struct m0_sm_ast *ast)
+{
+        struct m0_be_tx *tx;
+
+        tx = (struct m0_be_tx *)ast->sa_datum;
+        m0_be_tx_fini(tx);
+        m0_free(tx);
+}
+
+/** Called by m0_be_tx_done_cb at the very end of tx done termination. */
+void __be_tx_done_cb(struct m0_be_cbinfo *cbinfo, int status,
+                     m0_be_msg_type_t msg_type)
+{
+        struct m0_cob_be_cbinfo  *cob_cbinfo;
+        struct m0_sm_ast         *ast;
+        struct m0_sm_group       *post_sm_group;
+
+        cob_cbinfo = container_of(cbinfo, struct m0_cob_be_cbinfo, cbc_cbinfo);
+
+        ast           = &cob_cbinfo->cbc_ast;
+        post_sm_group = cob_cbinfo->cbc_sm_group;
+
+        m0_sm_group_lock(cbinfo->bc_sm_group);
+        m0_sm_ast_post(post_sm_group, ast);
+        m0_sm_group_unlock(cbinfo->bc_sm_group);
+        m0_free(cob_cbinfo);
+}
+
 
 /** Compare and match routines for kv_store. */
 M0_INTERNAL int m0_cob_kv_ns_cmp(void *in_obj1, void *in_obj2)
@@ -396,37 +437,180 @@ static char *cob_dom_id_make(char *buf, const struct m0_cob_domain_id *id,
 }
 
 #ifndef __KERNEL__
-void __cob_nsrec_kv_store_init(struct m0_be_kv_store    **handle,
-                               enum   m0_be_ks_init_mode  init_mode)
+void __kv_store_init_helper(struct m0_be_kv_store    **handle,
+                            struct m0_stob            *log_stob,
+                            int32_t                    handle_index,
+                            enum   m0_be_ks_init_mode  init_mode)
 {
-        kv_key_cmp_t   cmp_routine;
-        kv_key_match_t match_routine;
+        const  char             *stob_dir;
+        const  char             *stob_file;
+        char                     kv_cmd[1024];
+        kv_key_cmp_t             cmp_routine;
+        kv_key_match_t           match_routine;
+        int                      rc;
+
+        if (init_mode == M0_BE_KS_CREATE) {
+                stob_file = "0000000000000000.0000000000000001";
+                stob_dir  = "/tmp/__be/o";
+
+                sprintf(kv_cmd,
+                        "dd if=/dev/zero of=%s/%s bs=1024 count=204800"
+                        " 2>/dev/null",
+                        stob_dir, stob_file);
+                rc = system(kv_cmd);
+                M0_ASSERT(rc == 0);
+        }
 
         cmp_routine     = m0_cob_kv_ns_cmp;
         match_routine   = m0_cob_kv_ns_match;
 
-        m0_kv_init_helper(&cob_be_domain, handle, &cob_ns_list_descr,
-                          cmp_routine, match_routine, NULL, init_mode, 0, NULL, NULL);
+        m0_be_ks_init_domain(&cob_be_domain, NULL, log_stob);
+        M0_ASSERT(&cob_be_domain != NULL);
+
+        /* Create a kv-store handle */
+        m0_be_ks_create(&cob_ns_list_descr, cob_be_domain,
+                        cmp_routine, match_routine, handle_index, handle);
+        M0_ASSERT(*handle != NULL);
 }
-#endif
 
-M0_INTERNAL int m0_cob_domain_init_recovery(struct m0_cob_domain *dom,
-                                            struct m0_dbenv *env,
-		                            const struct m0_cob_domain_id *id)
+void __kv_init_operation_ast_cb(struct m0_sm_group *sm_group,
+                                struct m0_sm_ast *ast)
 {
+        printf("KV store initialised!!!!!");
+}
 
-#ifndef __KERNEL__
-        if (cob_be_domain == NULL) {
-                __cob_nsrec_kv_store_init(&dom->cd_kvnamespace,
-                                          M0_BE_KS_RECOVER);
+void cob_nsrec_kv_init_operation_cb(void *cbdata, void *result, int rc)
+{
+        struct m0_cob_be_cbinfo   *cob_cbinfo;
+        struct m0_be_cbinfo       *be_cbinfo;
+        struct m0_sm_ast          *ast;
+        struct m0_sm_group        *post_sm_group;
+
+        M0_ASSERT(rc == 0);
+
+        cob_cbinfo    = (struct m0_cob_be_cbinfo *)cbdata;
+        be_cbinfo     = &cob_cbinfo->cbc_cbinfo;
+        ast           = &cob_cbinfo->cbc_ast;
+        post_sm_group = cob_cbinfo->cbc_sm_group;
+
+        m0_sm_group_lock(be_cbinfo->bc_sm_group);
+        m0_sm_ast_post(post_sm_group, ast);
+        m0_sm_group_unlock(be_cbinfo->bc_sm_group);
+
+        m0_free(cob_cbinfo);
+}
+
+void __ast_init_kv_store(struct m0_sm_group *sm_group, struct m0_sm_ast *ast)
+{
+        struct m0_be_kv_store     *handle;
+        struct m0_be_kv_store_cb  *kv_cbinfo;
+        struct m0_cob_be_cbinfo   *cob_cbinfo;
+        enum   m0_be_ks_init_mode  init_mode;
+
+        cob_cbinfo = container_of(ast, struct m0_cob_be_cbinfo, cbc_ast);
+        handle     = cob_cbinfo->cbc_ks_handle;
+        M0_ASSERT(handle != NULL);
+        init_mode  = cob_cbinfo->cbc_ks_init_mode;
+
+        /*
+         * Set ast call back to be called after ks_init operation operation
+         * completes.
+         */
+        cob_cbinfo->cbc_ast.sa_cb = __kv_init_operation_ast_cb;
+
+        M0_ALLOC_PTR(kv_cbinfo);
+        M0_ASSERT(kv_cbinfo != NULL);
+
+        kv_cbinfo->ksc_cb      = cob_nsrec_kv_init_operation_cb;
+        kv_cbinfo->ksc_cbdata  = (void *)cob_cbinfo;
+
+        /* Initialise kv_store. */
+        m0_be_ks_init(handle, kv_cbinfo, init_mode);
+}
+
+void cob_ns_kv_store_init(struct m0_be_cbinfo *cbinfo, int status,
+                          m0_be_msg_type_t     msg)
+{
+        struct m0_cob_be_cbinfo  *cob_cbinfo;
+        struct m0_sm_ast         *ast;
+        struct m0_sm_group       *post_sm_group;
+
+        M0_ASSERT(cbinfo != NULL);
+        cob_cbinfo    = container_of(cbinfo, struct m0_cob_be_cbinfo,
+                                     cbc_cbinfo);
+
+        if (msg == M0_BE_SUCCESS) {
+                ast           = &cob_cbinfo->cbc_ast;
+                post_sm_group = cob_cbinfo->cbc_sm_group;
+
+                m0_sm_group_lock(cbinfo->bc_sm_group);
+                m0_sm_ast_post(post_sm_group, ast);
+                m0_sm_group_unlock(cbinfo->bc_sm_group);
         }
+}
 
-        M0_ASSERT(cob_be_domain != NULL);
-#endif
+M0_INTERNAL
+int m0_cob_domain_init_nsrec_recovery(struct m0_cob_domain          *dom,
+                                      struct m0_dbenv               *env,
+                                      const struct m0_cob_domain_id *id)
+{
+        struct m0_be_seg         *kv_seg;
+        struct m0_cob_be_cbinfo  *cob_cbinfo;
+        struct m0_be_cbinfo      *be_cbinfo;
+        struct m0_sm_group       *sm_group;
+        int32_t                   handle_index;
+
+        if (cob_be_domain == NULL) {
+                handle_index = dom->cd_kvnamespace_index_in_static_reg;
+                __kv_store_init_helper(&dom->cd_kvnamespace,
+                                       dom->cd_kv_log_stob, handle_index,
+                                       M0_BE_KS_RECOVER);
+                /*
+                 * Set the callback info to be called after segment
+                 * creation operation.
+                 */
+                sm_group = m0_be_domain_sm_group(cob_be_domain);
+                M0_ALLOC_PTR(cob_cbinfo);
+                M0_ASSERT(cob_cbinfo != NULL);
+                M0_ALLOC_PTR(kv_seg);
+                M0_ASSERT(kv_seg != NULL);
+
+                /*
+                 * This be_cbinfo will be used after segment opening completes.
+                 * The function cob_ns_kv_store_init will be called in
+                 * be_handler context.
+                 */
+                be_cbinfo               = &cob_cbinfo->cbc_cbinfo;
+                be_cbinfo->bc_hq        = &cob_be_domain->bd_hq;
+                be_cbinfo->bc_cb        =  cob_ns_kv_store_init;
+                be_cbinfo->bc_sm_group  =  sm_group;
+                be_cbinfo->bc_pcbinfo   =  NULL;
+
+                /*
+                 * This cbinfo will be used cob_ns_kv_store_init to post
+                 * __ast_init_kv_store on cob_sm_group.After ast_post,the
+                 * function __ast_init_kv_store will be called in caller
+                 * context, not in be_handler context.
+                 */
+                m0_sm_group_init(&cob_sm_group);
+                cob_cbinfo->cbc_sm_group     = &cob_sm_group;
+                cob_cbinfo->cbc_ast.sa_cb    = __ast_init_kv_store;
+                cob_cbinfo->cbc_ks_handle    = dom->cd_kvnamespace;
+                cob_cbinfo->cbc_ks_init_mode = M0_BE_KS_RECOVER;
+
+                m0_be_domain_seg_restore(cob_be_domain, BE_KV_SEG_NAME, kv_seg,
+                                         be_cbinfo);
+
+                /* Wait for segment open. */
+                wait_and_lock_cob_sm_group();
+
+                /* Wait for handle initialisation. */
+                wait_and_lock_cob_sm_group();
+        }
 
         return m0_cob_domain_init(dom, env, id);
 }
-
+#endif
 /**
    Set up a new cob domain
 
@@ -447,9 +631,61 @@ int m0_cob_domain_init(struct m0_cob_domain *dom, struct m0_dbenv *env,
 
 #ifndef __KERNEL__
         /* Initialise be_domain for kv_store */
+
+        struct m0_be_seg         *kv_seg;
+        struct m0_cob_be_cbinfo  *cob_cbinfo;
+        struct m0_be_cbinfo      *be_cbinfo;
+        struct m0_sm_group       *sm_group;
+        int32_t                   handle_index;
+
+        handle_index = dom->cd_kvnamespace_index_in_static_reg;
+
         if (cob_be_domain == NULL) {
-                __cob_nsrec_kv_store_init(&dom->cd_kvnamespace,
-                                          M0_BE_KS_CREATE);
+                __kv_store_init_helper(&dom->cd_kvnamespace,
+                                       dom->cd_kv_log_stob, handle_index,
+                                       M0_BE_KS_CREATE);
+
+                /*
+                 * Set the callback info to be called after segment
+                 * creation operation.
+                 */
+                sm_group = m0_be_domain_sm_group(cob_be_domain);
+                M0_ALLOC_PTR(cob_cbinfo);
+                M0_ASSERT(cob_cbinfo != NULL);
+                M0_ALLOC_PTR(kv_seg);
+                M0_ASSERT(kv_seg != NULL);
+
+                /*
+                 * This be_cbinfo will be used after segment creation completes.
+                 * The function cob_ns_kv_store_init will be called in
+                 * be_handler context.
+                 */
+                be_cbinfo               = &cob_cbinfo->cbc_cbinfo;
+                be_cbinfo->bc_hq        = &cob_be_domain->bd_hq;
+                be_cbinfo->bc_cb        =  cob_ns_kv_store_init;
+                be_cbinfo->bc_sm_group  =  sm_group;
+                be_cbinfo->bc_pcbinfo   =  NULL;
+
+                /*
+                 * This cbinfo will be used cob_ns_kv_store_init to post
+                 * __ast_init_kv_store on cob_sm_group.After ast_post,the
+                 * function __ast_init_kv_store will be called in caller
+                 * context, not in be_handler context.
+                 */
+                m0_sm_group_init(&cob_sm_group);
+                cob_cbinfo->cbc_sm_group     = &cob_sm_group;
+                cob_cbinfo->cbc_ast.sa_cb    = __ast_init_kv_store;
+                cob_cbinfo->cbc_ks_handle    = dom->cd_kvnamespace;
+                cob_cbinfo->cbc_ks_init_mode = M0_BE_KS_CREATE;
+
+                m0_be_seg_init(kv_seg, cob_be_domain, sm_group, 0);
+                m0_be_seg_create(kv_seg, NULL, BE_KV_SEG_NAME, NULL, be_cbinfo);
+
+                /* Wait for segment creation. */
+                wait_and_lock_cob_sm_group();
+
+                /* Wait for handle initialisation. */
+                wait_and_lock_cob_sm_group();
         }
 #endif
 
@@ -499,16 +735,17 @@ void m0_cob_domain_fini(struct m0_cob_domain *dom)
         struct m0_be_seg *kv_seg;
         bool              ret_dom;
 
+        m0_be_ks_fini(dom->cd_kvnamespace, NULL);
+
         ret_dom = m0_be_domain_lookup(cob_be_domain, BE_KV_SEG_NAME, &kv_seg);
         M0_ASSERT(ret_dom);
         M0_ASSERT(kv_seg != NULL);
         m0_be_seg_done(kv_seg);
 
         m0_be_domain_fini(cob_be_domain);
-
         m0_free(cob_be_domain);
-        m0_be_ks_fini(dom->cd_kvnamespace, NULL);
         cob_be_domain = NULL;
+
 #endif
 
         m0_table_fini(&dom->cd_fileattr_omg);
@@ -1398,11 +1635,13 @@ M0_INTERNAL int m0_cob_update(struct m0_cob *cob,
 
         /* KV Store declarations */
 #ifndef __KERNEL__
-        struct m0_be_kv_store  *handle;
-        struct m0_be_ks_pair   *kv_pair;
-        struct m0_be_tx        *be_tx;
-        struct m0_be_domain    *kv_dom;
-        struct m0_sm_group     *sm_group;
+        struct m0_be_kv_store    *handle;
+        struct m0_be_ks_pair     *kv_pair;
+        struct m0_be_tx          *be_tx;
+        struct m0_be_domain      *kv_dom;
+        struct m0_sm_group       *sm_group;
+        struct m0_cob_be_cbinfo  *cob_cbinfo;
+        struct m0_be_cbinfo      *be_cbinfo;
 
         if (nsrec != NULL) {
                 handle   = cob->co_dom->cd_kvnamespace;
@@ -1429,15 +1668,21 @@ M0_INTERNAL int m0_cob_update(struct m0_cob *cob,
                 rc = m0_be_ks_update(handle, be_tx, NULL, kv_pair,
                                      sizeof *kv_pair, m0_be_kv_cob_pair_copy);
 
-                /*
-                 * For now, no cob_info has been provided, so sending NULL to
-                 * m0_be_tx_done.
-                 */
-                m0_be_tx_done(be_tx, NULL);
-                m0_be_wait(sm_group, &be_tx->bt_sm, M0_BITS(M0_BETX_DONE,
-                                                            M0_BETX_FAILED));
-                m0_be_tx_fini(be_tx);
-                m0_free(be_tx);
+                /* Set the callback information for tx_done. */
+                M0_ALLOC_PTR(cob_cbinfo);
+                M0_ASSERT(cob_cbinfo != NULL);
+                be_cbinfo               = &cob_cbinfo->cbc_cbinfo;
+                be_cbinfo->bc_hq        = &cob_be_domain->bd_hq;
+                be_cbinfo->bc_cb        =  __be_tx_done_cb;
+                be_cbinfo->bc_sm_group  =  sm_group;
+                be_cbinfo->bc_pcbinfo   =  NULL;
+
+                cob_cbinfo->cbc_sm_group     = &cob_sm_group;
+                cob_cbinfo->cbc_ast.sa_cb    = __be_tx_done_ast_cb;
+                cob_cbinfo->cbc_ast.sa_datum = (void *)be_tx;
+
+                m0_be_tx_done(be_tx, be_cbinfo);
+                wait_and_lock_cob_sm_group();
 
                 if (rc != 0)
                         goto out;
@@ -1500,6 +1745,10 @@ M0_INTERNAL int m0_cob_name_add(struct m0_cob *cob,
         struct m0_be_reference  *pair_ref;
         struct m0_be_tx         *be_tx;
         struct m0_be_ks_pair    *kv_pair;
+        struct m0_sm_group      *sm_group;
+        struct m0_be_kv_store   *handle;
+        struct m0_cob_be_cbinfo *cob_cbinfo;
+        struct m0_be_cbinfo     *be_cbinfo;
 #endif
 
         M0_PRE(cob != NULL);
@@ -1528,8 +1777,9 @@ M0_INTERNAL int m0_cob_name_add(struct m0_cob *cob,
 
 #ifndef __KERNEL__
         /* Insert nsrec in kv_store */
-        be_tx   = cob->cnr_betx;
+        be_tx  = cob->cnr_betx;
         M0_ASSERT(be_tx != NULL);
+        handle = cob->co_dom->cd_kvnamespace;
 
         rc = m0_be_ks_pair_setup(cob_be_domain, nskey, nsrec, &be_tx, &kv_pair,
                                  &pair_ref, M0_BE_KS_PAIR_RVM);
@@ -1537,8 +1787,24 @@ M0_INTERNAL int m0_cob_name_add(struct m0_cob *cob,
         M0_ASSERT(kv_pair  != NULL);
         M0_ASSERT(pair_ref != NULL);
 
-        rc  = m0_kv_insert_helper(cob->co_dom->cd_kvnamespace, pair_ref,
-                                  be_tx);
+        sm_group = m0_be_domain_sm_group(cob_be_domain);
+        rc = m0_be_ks_insert(handle, NULL, pair_ref, be_tx);
+
+        M0_ALLOC_PTR(cob_cbinfo);
+        M0_ASSERT(cob_cbinfo != NULL);
+        be_cbinfo               = &cob_cbinfo->cbc_cbinfo;
+        be_cbinfo->bc_hq        = &cob_be_domain->bd_hq;
+        be_cbinfo->bc_cb        =  __be_tx_done_cb;
+        be_cbinfo->bc_sm_group  =  sm_group;
+        be_cbinfo->bc_pcbinfo   =  NULL;
+
+        cob_cbinfo->cbc_sm_group     = &cob_sm_group;
+        cob_cbinfo->cbc_ast.sa_cb    = __be_tx_done_ast_cb;
+        cob_cbinfo->cbc_ast.sa_datum = (void *)be_tx;
+
+
+        m0_be_tx_done(be_tx, be_cbinfo);
+        wait_and_lock_cob_sm_group();
 #endif
 out:
         M0_ADDB_ADD(&cob->co_dom->cd_addb, &cob_addb_loc,
@@ -1562,8 +1828,10 @@ M0_INTERNAL int m0_cob_name_del(struct m0_cob *cob,
 
 #ifndef __KERNEL__
 
-        struct m0_sm_group  *sm_group;
-        struct m0_be_tx     *be_tx;
+        struct m0_sm_group      *sm_group;
+        struct m0_be_tx         *be_tx;
+        struct m0_cob_be_cbinfo *cob_cbinfo;
+        struct m0_be_cbinfo     *be_cbinfo;
 
         /*
          * Kill name kv store.
@@ -1578,18 +1846,19 @@ M0_INTERNAL int m0_cob_name_del(struct m0_cob *cob,
         nsrec         =  &cob->co_nsrec;
         M0_ASSERT(nsrec != NULL);
 
-        /* Now delete pair ultimately in cob->co_pair. */
-        rc = m0_kv_delete_helper(cob->co_dom->cd_kvnamespace, cob->co_pair,
-                                 sizeof *cob->co_pair);
-        M0_ASSERT(rc == 0);
-
-        /* Delete key, value and pair from RVM */
         M0_ALLOC_PTR(be_tx);
         M0_ASSERT(be_tx != NULL);
 
         m0_be_tx_init(be_tx, cob_be_domain, 0);
         m0_be_tx_start(be_tx);
 
+        /* Now delete pair ultimately in cob->co_pair. */
+        rc = m0_kv_delete_helper(cob->co_dom->cd_kvnamespace, be_tx,
+                                 cob->co_pair, sizeof *cob->co_pair);
+        M0_ASSERT(rc == 0);
+
+        /* Delete key, value and pair from RVM */
+
         /* Free the ns key */
         m0_be_free_helper(cob_be_domain, be_tx, cob->co_pair->ksp_key,
                           sizeof (struct m0_cob_nskey));
@@ -1603,11 +1872,21 @@ M0_INTERNAL int m0_cob_name_del(struct m0_cob *cob,
                           sizeof cob->co_pair);
 
         sm_group = m0_be_domain_sm_group(cob_be_domain);
-        m0_be_tx_done(be_tx, NULL);
-        m0_be_wait(sm_group, &be_tx->bt_sm,
-                   M0_BITS(M0_BETX_DONE, M0_BETX_FAILED));
-        m0_be_tx_fini(be_tx);
-        m0_free(be_tx);
+
+        M0_ALLOC_PTR(cob_cbinfo);
+        M0_ASSERT(cob_cbinfo != NULL);
+        be_cbinfo               = &cob_cbinfo->cbc_cbinfo;
+        be_cbinfo->bc_hq        = &cob_be_domain->bd_hq;
+        be_cbinfo->bc_cb        =  __be_tx_done_cb;
+        be_cbinfo->bc_sm_group  =  sm_group;
+        be_cbinfo->bc_pcbinfo   =  NULL;
+
+        cob_cbinfo->cbc_sm_group     = &cob_sm_group;
+        cob_cbinfo->cbc_ast.sa_cb    = __be_tx_done_ast_cb;
+        cob_cbinfo->cbc_ast.sa_datum = (void *)be_tx;
+
+        m0_be_tx_done(be_tx, be_cbinfo);
+        wait_and_lock_cob_sm_group();
         cob->co_pair = NULL;
 #endif
         /*
diff --git a/cob/cob.h b/cob/cob.h
index ac3970d..cc4774f 100644
--- a/cob/cob.h
+++ b/cob/cob.h
@@ -39,6 +39,7 @@
 
 #ifndef __KERNEL__
   #include "be/kv_store.h"
+  #include "be/be.h"
 #endif
 
 /* import */
@@ -277,6 +278,13 @@ struct m0_cob_domain {
 #ifndef __KERNEL__
         /** KV-Store handle for namespaces. */
         struct m0_be_kv_store  *cd_kvnamespace;
+        /** Underlying stob for log file. */
+        struct m0_stob         *cd_kv_log_stob;
+        /**
+         * The index at which the RVM allocation info for cd_kvnamespace
+         * will be stored in the static region.
+         */
+        int32_t                 cd_kvnamespace_index_in_static_reg;
 #endif
 
         struct m0_table         cd_fileattr_basic;
@@ -293,9 +301,10 @@ int m0_cob_domain_init(struct m0_cob_domain *dom, struct m0_dbenv *env,
 /**
   Recovers kv_store for nsrec and then calls m0_cob_domain_init.
  */
-M0_INTERNAL int m0_cob_domain_init_recovery(struct m0_cob_domain *dom,
-                                            struct m0_dbenv      *env,
-		                            const struct m0_cob_domain_id *id);
+M0_INTERNAL
+int m0_cob_domain_init_nsrec_recovery(struct m0_cob_domain           *dom,
+                                      struct m0_dbenv                *env,
+		                      const struct m0_cob_domain_id  *id);
 
 void m0_cob_domain_fini(struct m0_cob_domain *dom);
 
@@ -512,11 +521,10 @@ struct m0_cob {
         struct m0_cob_oikey    co_oikey;    /**< object fid, linkno */
         struct m0_cob_nsrec    co_nsrec;    /**< object fid, basic stat data */
 
-        /** This object goes onto RVM. */
-        /*struct m0_cob_nsrec   *co_kv_nsrec;*/
-
         /** Used while deleting a pair, after look up. */
         struct m0_be_ks_pair  *co_pair;
+        /** Underlying object for log file. */
+        struct m0_stob        *co_log_stob;
 
         struct m0_cob_fabrec  *co_fabrec;   /**< fileattr_basic data (acl...) */
         struct m0_cob_omgrec   co_omgrec;   /**< permission data */
@@ -558,6 +566,26 @@ struct m0_cob_iterator {
         struct m0_db_pair      ci_pair;     /**< used for iterator cursor */
 };
 
+#ifndef __KERNEL__
+/**
+ * Callback info for BE domain related operations, consumed by cob-nsrec.
+ */
+struct m0_cob_be_cbinfo {
+        /** The cbinfo used by BE domain. */
+        struct m0_be_cbinfo        cbc_cbinfo;
+        /**
+         * The sm_group on which the ast will be posted back in caller thread.
+         */
+        struct m0_sm_group        *cbc_sm_group;
+        /** The ast used to call user call back in user thread context. */
+        struct m0_sm_ast           cbc_ast;
+        /** The kv_store handle to be used for ks_related async operations. */
+        struct m0_be_kv_store     *cbc_ks_handle;
+        /** The kv_store init_mode.*/
+        enum   m0_be_ks_init_mode  cbc_ks_init_mode;
+};
+#endif
+
 /**
  * Cob flags and valid attributes.
  */
diff --git a/cob/ut/cob.c b/cob/ut/cob.c
index 8aedaf2..52c27a3 100644
--- a/cob/ut/cob.c
+++ b/cob/ut/cob.c
@@ -24,6 +24,8 @@
 #include "lib/misc.h"              /* M0_SET0 */
 #include "lib/bitstring.h"
 #include "cob/cob.h"
+#include "stob/linux.h"
+#include "stob/linux_internal.h"
 #include "be/helper.h"
 #include <stdlib.h>
 
@@ -35,12 +37,81 @@ static const char wrong_name[] = "wrong_name";
 static struct m0_cob_domain_id id = { 42 };
 static struct m0_dbenv       db;
 static struct m0_cob_domain  dom;
-static struct m0_cob         *cob;
+static struct m0_cob        *cob;
 static int rc;
 
+/* For stob creation. */
+static struct m0_stob             *log_stob;
+static struct m0_stob_domain      *stob_dom;
+static const  char                *stob_dir  = "/tmp/__be/o";
+char                               path_name[MAXPATHLEN];
+char                               kv_cmd[1024];
+int32_t                            handle_index;
+
 /* defined in cob/cob.c */
 extern struct m0_be_domain  *cob_be_domain;
 
+static int log_stob_create(void)
+{
+        struct linux_stob        *lstob;
+        struct linux_domain      *ldom;
+        bool                      stob_directio     = false;
+        int                       nbytes            = 0;
+        struct  m0_stob_id        stob_id;
+        int                       result;
+
+        stob_id.si_bits.u_hi    = 0;
+        stob_id.si_bits.u_lo    = 2;
+
+        /* Initialize stob type. */
+        m0_stob_type_init(&m0_linux_stob_type);
+
+        /* @todo - stob path is hardcoded for now. */
+        result = m0_stob_domain_locate(&m0_linux_stob_type,
+                                       "/tmp/__be",
+                                       &stob_dom);
+        M0_ASSERT(result == 0);
+
+        result = m0_linux_stob_setup(stob_dom, stob_directio);
+        M0_ASSERT(result == 0);
+
+        result = m0_stob_find(stob_dom, &stob_id, &log_stob);
+        M0_ASSERT(result == 0);
+        M0_ASSERT(log_stob->so_state == CSS_UNKNOWN);
+        result = m0_stob_create(log_stob, NULL);
+
+        if (result < 0)
+                return -1;
+
+        lstob = stob2linux(log_stob);
+
+        M0_ASSERT(lstob != NULL);
+
+        ldom = domain2linux(log_stob->so_domain);
+        nbytes = snprintf(path_name,
+                          ARRAY_SIZE(path_name),
+                          "%s/o/%016lx.%016lx",
+                          ldom->sdl_path,
+                          log_stob->so_id.si_bits.u_hi,
+                          log_stob->so_id.si_bits.u_lo);
+
+        if (nbytes < 0)
+                return -1;
+
+        return 0;
+}
+
+static int stob_create()
+{
+        sprintf(kv_cmd, "mkdir -p %s", stob_dir);
+        rc = system(kv_cmd);
+        M0_ASSERT(rc == 0);
+        rc = log_stob_create();
+        M0_ASSERT(rc == 0);
+        dom.cd_kv_log_stob = log_stob;
+        return rc;
+}
+
 static int db_reset(void)
 {
         rc = m0_ut_db_reset(db_name);
@@ -53,10 +124,15 @@ static void test_mkfs(void)
 {
         struct m0_db_tx         tx;
         int                     rc;
+        /*void                    *scan;*/
 
         rc = m0_dbenv_init(&db, db_name, 0);
         M0_UT_ASSERT(rc == 0);
 
+        /* Create the log stob. */
+        rc = stob_create();
+        M0_ASSERT(rc == 0);
+
         rc = m0_cob_domain_init(&dom, &db, &id);
         M0_UT_ASSERT(rc == 0);
 
@@ -64,6 +140,7 @@ static void test_mkfs(void)
         M0_UT_ASSERT(rc == 0);
 
         /* Create root and other structures */
+        dom.cd_kvnamespace_index_in_static_reg = handle_index++;
         rc = m0_cob_domain_mkfs(&dom, &M0_COB_SLASH_FID,
                                 &M0_COB_SESSIONS_FID, &tx);
         M0_UT_ASSERT(rc == 0);
@@ -72,6 +149,12 @@ static void test_mkfs(void)
         /* Fini everything */
         m0_cob_domain_fini(&dom);
         m0_dbenv_fini(&db);
+
+        /* Remove the data file. */
+        sprintf(kv_cmd, "rm -rf %s", stob_dir);
+        rc = system(kv_cmd);
+        M0_ASSERT(rc == 0);
+        log_stob = NULL;
 }
 
 static void test_init(void)
@@ -80,6 +163,11 @@ static void test_init(void)
         /*test_init is called by ub_init which hates M0_UT_ASSERT*/
         M0_ASSERT(rc == 0);
 
+        /* Create the log stob. */
+        rc = stob_create();
+        M0_ASSERT(rc == 0);
+
+        dom.cd_kvnamespace_index_in_static_reg = handle_index;
         rc = m0_cob_domain_init(&dom, &db, &id);
         M0_ASSERT(rc == 0);
 }
@@ -94,12 +182,16 @@ static void test_fini(void)
 static void test_recovery_nsrec_kvstore(void)
 {
         char  kv_cmd[1024];
-        char *stob_dir = "/tmp/__be/o";
 
         rc = m0_dbenv_init(&db, db_name, 0);
         M0_UT_ASSERT(rc == 0);
 
-        rc = m0_cob_domain_init_recovery(&dom, &db, &id);
+        /* Create the log stob. */
+        rc = stob_create();
+        M0_ASSERT(rc == 0);
+
+        dom.cd_kvnamespace_index_in_static_reg = handle_index;
+        rc = m0_cob_domain_init_nsrec_recovery(&dom, &db, &id);
         M0_UT_ASSERT(rc == 0);
         test_fini();
 
diff --git a/rvm/rds_zap.c b/rvm/rds_zap.c
index 1702e60..5cb5c39 100644
--- a/rvm/rds_zap.c
+++ b/rvm/rds_zap.c
@@ -69,8 +69,8 @@ rds_zap_heap(DevName, DevLength, startAddr, staticLength, heapLength, nlists, ch
 
     /* Force the writes from create to appear in the data segment. */
     if ((rvmret = rvm_truncate()) != RVM_SUCCESS) {
-	(*err) = (int) rvmret;
-	return -1;
+            (*err) = (int) rvmret;
+            return -1;
     }
 
     /* Map in the appropriate structures by calling Rvm_Load_Segment. */
@@ -124,9 +124,10 @@ rds_zap_heap(DevName, DevLength, startAddr, staticLength, heapLength, nlists, ch
 
 int rds_done(rvm_seg_hdr_t *seg_hdr)
 {
+    int retval;
     /* Make sure the initialization has been committed to rvm data */
     rvm_flush();
-    rvm_truncate();
+    retval = rvm_truncate();
 
     rvm_release_segment(seg_hdr->n_loadregions, &seg_hdr->regions, seg_hdr);
 
diff --git a/rvm/rvm_logrecovr.c b/rvm/rvm_logrecovr.c
index aacb7ce..6cc6a64 100644
--- a/rvm/rvm_logrecovr.c
+++ b/rvm/rvm_logrecovr.c
@@ -2294,6 +2294,7 @@ static rvm_return_t  update_seg(log, seg_dict, seg_dev)
     void                  **io_addr;
     m0_bindex_t            *io_offset;
     m0_bcount_t            *io_count;
+    m0_bcount_t             io_total_count = 0;
     uint32_t                io_bshift;
     uint32_t                iter_count;
     uint32_t                iter_remained;
@@ -2340,12 +2341,13 @@ static rvm_return_t  update_seg(log, seg_dict, seg_dev)
         io_addr[i]      = m0_stob_addr_pack(node->nv_ptr, io_bshift);
         io_count[i]     = node->length >> io_bshift;
         io_offset[i]    = node->offset.low >> io_bshift;
+        io_total_count += io_count[i];
         i++;
         nodes_done++;
         if (i == iter_count) {
             retval = launch_stob_io(SIO_WRITE, iter_count, io_count, io_offset,
                                     io_addr, stob);
-            if(retval != *io_count)
+            if(retval != io_total_count)
                 return RVM_EOFFSET;
 
             iter_remained -= iter_count;
-- 
1.8.3.2

