From 1bf7a8706ce1aef7eabcbc1da9a1a12c36b89008 Mon Sep 17 00:00:00 2001
From: Sachin Patil <sachin_patil@xyratex.com>
Date: Tue, 5 Feb 2013 08:23:21 -0800
Subject: [PATCH 045/121] Only file i/o is blocking for segment, region and
 transaction. Also changes for few review comments from nikita on new diff

---
 be/be.h              | 222 +++++++++++++-------------------
 be/domain.c          |  94 +++++---------
 be/domain.h          |   5 +-
 be/handle_store.c    |   8 +-
 be/helper.c          |   2 +-
 be/reg.c             | 345 +++++++++-----------------------------------------
 be/reg.h             |   6 +-
 be/seg.c             |  30 ++---
 be/seg.h             |   6 +-
 be/tx.c              | 347 +++++++++------------------------------------------
 be/tx.h              |  16 ++-
 be/ut/be.c           |   9 +-
 be/ut/handle_store.c |   2 +-
 13 files changed, 287 insertions(+), 805 deletions(-)

diff --git a/be/be.h b/be/be.h
index 7a0568b..5220382 100644
--- a/be/be.h
+++ b/be/be.h
@@ -173,6 +173,8 @@
  */
 
 /* export */
+struct m0_stob;
+
 struct m0_be_domain;
 struct m0_be_seg;
 struct m0_be_tx;
@@ -182,7 +184,6 @@ struct m0_be_reg;
 /* import */
 #include "sm/sm.h"
 #include "addb/addb.h"
-#include "stob/stob.h"
 #include "lib/misc.h"
 
 #include "be/be_impl.h"
@@ -192,7 +193,7 @@ struct m0_be_reg;
  * Initialises the in-memory part of domain structure. This function does not
  * initiate any IO.
  *
- * @post m0_be_seg_state_get(dom->bd_data) == M0_BESEG_CLOSED
+ * @post m0_be_seg_state(dom->bd_data) == M0_BESEG_CLOSED
  */
 M0_INTERNAL void m0_be_domain_init(struct m0_be_domain *dom,
                                    struct m0_stob *stob,
@@ -202,7 +203,7 @@ M0_INTERNAL void m0_be_domain_init(struct m0_be_domain *dom,
 /**
  * Finalises the in-memory part of domain structure.
  *
- * @pre M0_IN(m0_be_seg_state_get(dom->bd_data), (M0_BESEG_CLOSED,
+ * @pre M0_IN(m0_be_seg_state(dom->bd_data), (M0_BESEG_CLOSED,
  *                                                M0_BESEG_FAILED))
  */
 M0_INTERNAL void m0_be_domain_fini(struct m0_be_domain *dom);
@@ -212,11 +213,11 @@ M0_INTERNAL void m0_be_domain_fini(struct m0_be_domain *dom);
  *
  * Note that this operation is *not* transactional (there is no domain yet).
  *
- * @pre m0_be_seg_state_get(dom->bd_data) == M0_BESEG_CLOSED
- * @pre M0_IN(m0_be_seg_state_get(dom->bd_data), (M0_BESEG_CLOSED, 
- *                                                M0_BESEG_FAILED, 
- *                                                M0_BESEG_ACTIVE, 
- *                                                M0_BESEG_CREATING))
+ * @pre m0_be_seg_state(dom->bd_data) == M0_BESEG_CLOSED
+ * @pre M0_IN(m0_be_seg_state(dom->bd_data), (M0_BESEG_CLOSED,
+ *                                            M0_BESEG_FAILED,
+ *                                            M0_BESEG_ACTIVE,
+ *                                            M0_BESEG_CREATING))
  */
 M0_INTERNAL void m0_be_domain_create(struct m0_be_domain *dom,
                                      struct m0_stob *stob);
@@ -224,24 +225,24 @@ M0_INTERNAL void m0_be_domain_create(struct m0_be_domain *dom,
 /**
  * Searches a domain for the existing segment with a given name.
  *
- * @pre m0_be_seg_state_get(dom->bd_data) == M0_BESEG_ACTIVE
- * @pre m0_be_seg_state_get(seg) == M0_BESEG_CLOSED
+ * @pre m0_be_seg_state(dom->bd_data) == M0_BESEG_ACTIVE
+ * @pre m0_be_seg_state(seg) == M0_BESEG_CLOSED
  * @pre seg->bs_dom == dom
- * @post M0_IN(m0_be_seg_state_get(seg), (M0_BESEG_OPENING, M0_BESEG_ACTIVE,
- *                                        M0_BESEG_FAILED))
+ * @post M0_IN(m0_be_seg_state(seg), (M0_BESEG_OPENING, M0_BESEG_ACTIVE,
+ *                                    M0_BESEG_FAILED))
  */
-M0_INTERNAL int m0_be_domain_lookup(struct m0_be_domain *dom, const char *name,
-                                    struct m0_be_seg **out);
+M0_INTERNAL bool m0_be_domain_lookup(struct m0_be_domain *dom, const char *name,
+                                     struct m0_be_seg **out);
 
 /**
  * Loads/Restores named segment in memory on recovery of kv-store.
  * Note - This function does not create new segment, if segment not found.
  *        This will return BE_SEG_FAILED for non existing segment lookups.
  *
- * @pre m0_be_seg_state_get(dom->bd_data) == M0_BESEG_ACTIVE
+ * @pre m0_be_seg_state(dom->bd_data) == M0_BESEG_ACTIVE
  * @pre seg->bs_dom == dom
- * @post M0_IN(m0_be_seg_state_get(seg), (M0_BESEG_OPENING, M0_BESEG_ACTIVE,
- *                                        M0_BESEG_FAILED))
+ * @post M0_IN(m0_be_seg_state(seg), (M0_BESEG_OPENING, M0_BESEG_ACTIVE,
+ *                                    M0_BESEG_FAILED))
  */
 M0_INTERNAL void m0_be_domain_restore(struct m0_be_domain *dom,
                                              const char *name,
@@ -250,7 +251,7 @@ M0_INTERNAL void m0_be_domain_restore(struct m0_be_domain *dom,
 /**
  * Initialises the segment structure in memory.
  *
- * @post m0_be_seg_state_get(seg) == M0_BESEG_CLOSED
+ * @post m0_be_seg_state(seg) == M0_BESEG_CLOSED
  */
 M0_INTERNAL void m0_be_seg_init(struct m0_be_seg *seg, struct m0_be_domain *dom,
                                 struct m0_sm_group *sm_group, uint64_t flags);
@@ -258,15 +259,15 @@ M0_INTERNAL void m0_be_seg_init(struct m0_be_seg *seg, struct m0_be_domain *dom,
 /**
  * Initialises segment opening.
  *
- * @pre M0_IN(m0_be_seg_state_get(seg), (M0_BESEG_CLOSED, M0_BESEG_CREATING))
- * @pre m0_be_seg_state_get(dom->bd_data) == M0_BESEG_ACTIVE
- * @post M0_IN(m0_be_seg_state_get(seg), (M0_BESEG_OPENING,
- *                                        M0_BESEG_ACTIVE, M0_BESEG_FAILED))
+ * @pre M0_IN(m0_be_seg_state(seg), (M0_BESEG_CLOSED, M0_BESEG_CREATING))
+ * @pre m0_be_seg_state(dom->bd_data) == M0_BESEG_ACTIVE
+ * @post M0_IN(m0_be_seg_state(seg), (M0_BESEG_OPENING,M0_BESEG_ACTIVE,
+ *                                    M0_BESEG_FAILED))
  */
 M0_INTERNAL void m0_be_seg_open(struct m0_be_seg *seg);
 
 /**
- * @pre M0_IN(m0_be_seg_state_get(seg), (M0_BESEG_CLOSED, M0_BESEG_FAILED))
+ * @pre M0_IN(m0_be_seg_state(seg), (M0_BESEG_CLOSED, M0_BESEG_FAILED))
  */
 M0_INTERNAL void m0_be_seg_fini(struct m0_be_seg *seg);
 
@@ -275,64 +276,64 @@ M0_INTERNAL void m0_be_seg_fini(struct m0_be_seg *seg);
  * In case of duplicate @name, the state of @seg is set as failed and
  * the function returns.
  *
- * @pre m0_be_seg_state_get(dom->bd_data) == M0_BESEG_ACTIVE
- * @pre m0_be_seg_state_get(seg) == M0_BESEG_CLOSED
- * @post M0_IN(m0_be_seg_state_get(seg), (M0_BESEG_CREATING,
- *                                        M0_BESEG_ACTIVE, M0_BESEG_FAILED))
+ * @pre m0_be_seg_state(dom->bd_data) == M0_BESEG_ACTIVE
+ * @pre m0_be_seg_state(seg) == M0_BESEG_CLOSED
+ * @post M0_IN(m0_be_seg_state(seg), (M0_BESEG_CREATING, M0_BESEG_ACTIVE,
+ *                                    M0_BESEG_FAILED))
  */
 M0_INTERNAL void m0_be_seg_create(struct m0_be_seg *seg, struct m0_be_tx *tx,
                                   const char *name, struct m0_stob *stob);
 /**
  * Starts segment consistency check.
  *
- * @pre m0_be_seg_state_get(seg) == M0_BESEG_CLOSED
- * @post M0_IN(m0_be_seg_state_get(seg), (M0_BESEG_CLOSED,
- *                                        M0_BESEG_CHECKING, M0_BESEG_FAILED))
+ * @pre m0_be_seg_state(seg) == M0_BESEG_CLOSED
+ * @post M0_IN(m0_be_seg_state(seg), (M0_BESEG_CLOSED, M0_BESEG_CHECKING,
+ *                                    M0_BESEG_FAILED))
  */
 M0_INTERNAL void m0_be_seg_check(struct m0_be_seg *seg, struct m0_be_tx *tx);
 
 /**
  * Starts segment deletion.
  *
- * @pre m0_be_seg_state_get(seg) == M0_BESEG_CLOSED
- * @post M0_IN(m0_be_seg_state_get(seg), (M0_BESEG_CLOSED,
- *                                        M0_BESEG_DELETING, M0_BESEG_FAILED))
+ * @pre m0_be_seg_state(seg) == M0_BESEG_CLOSED
+ * @post M0_IN(m0_be_seg_state(seg), (M0_BESEG_CLOSED, M0_BESEG_DELETING,
+ *                                    M0_BESEG_FAILED))
  */
 M0_INTERNAL void m0_be_seg_delete(struct m0_be_seg *seg, struct m0_be_tx *tx);
 
 /**
  * Starts segment closing.
  *
- * @pre m0_be_seg_state_get(seg) == M0_BESEG_ACTIVE
- * @post M0_IN(m0_be_seg_state_get(seg), (M0_BESEG_CLOSED,
- *                                        M0_BESEG_CLOSING, M0_BESEG_FAILED))
+ * @pre m0_be_seg_state(seg) == M0_BESEG_ACTIVE
+ * @post M0_IN(m0_be_seg_state(seg), (M0_BESEG_CLOSED, M0_BESEG_CLOSING,
+ *                                    M0_BESEG_FAILED))
  */
 M0_INTERNAL void m0_be_seg_done(struct m0_be_seg *seg);
 
 /**
  * Marks the segment as failed.
  *
- * @post m0_be_seg_state_get(seg) == M0_BESEG_FAILED
+ * @post m0_be_seg_state(seg) == M0_BESEG_FAILED
  */
 M0_INTERNAL void m0_be_seg_fail(struct m0_be_seg *seg);
 
 /**
  * Initializes segment in memory
  *
- * @post m0_be_reg_state_get(reg) == M0_BEREG_INIT
+ * @post m0_be_reg_state(reg) == M0_BEREG_INIT
  */
 M0_INTERNAL void m0_be_reg_init(struct m0_be_reg *reg, struct m0_be_tx *tx,
                                 struct m0_be_seg *seg, struct m0_be_buf *buf);
 /**
- * @pre m0_be_reg_state_get(reg) != M0_BEREG_INPROGRESS
+ * @pre m0_be_reg_state(reg) != M0_BEREG_INPROGRESS
  */
 M0_INTERNAL void m0_be_reg_fini(struct m0_be_reg *reg);
 
 /**
  * Initialises the transaction structure.
  *
- * @pre m0_be_seg_state_get(dom->bd_data) == M0_BESEG_ACTIVE
- * @post m0_be_tx_state_get(tx) == M0_BETX_PREPARING
+ * @pre m0_be_seg_state(dom->bd_data) == M0_BESEG_ACTIVE
+ * @post m0_be_tx_state(tx) == M0_BETX_INIT
  * @post tx->bt_dom == dom
  */
 M0_INTERNAL void m0_be_tx_init(struct m0_be_tx *tx,
@@ -342,42 +343,42 @@ M0_INTERNAL void m0_be_tx_init(struct m0_be_tx *tx,
 /**
  * Indicates that a transaction will use certain amount of resources.
  *
- * @pre m0_be_tx_state_get(tx) == M0_BETX_PREPARING
+ * @pre m0_be_tx_state(tx) == M0_BETX_INIT
  */
 M0_INTERNAL void m0_be_tx_prep(struct m0_be_tx *tx);
 
 /**
  * Starts a prepared transaction.
  *
- * @pre m0_be_tx_state_get(tx) == M0_BETX_PREPARING
- * @post M0_IN(m0_be_tx_state_get(tx), (M0_BETX_PREPARED, M0_BETX_OPEN,
- *                                      M0_BETX_FAILED))
+ * @pre m0_be_tx_state(tx) == M0_BETX_PREPARED
+ * @post M0_IN(m0_be_tx_state(tx), (M0_BETX_PREPARED, M0_BETX_OPEN,
+ *                                  M0_BETX_FAILED))
  */
 M0_INTERNAL void m0_be_tx_start(struct m0_be_tx *tx);
 
 /**
  * Closes a transaction.
  *
- * @pre m0_be_tx_state_get(tx) == M0_BETX_OPEN
- * @post M0_IN(m0_be_tx_state_get(tx), (M0_BETX_CLOSED, M0_BETX_COMMITTED,
- *                                      M0_BETX_DONE, M0_BETX_FAILED))
+ * @pre m0_be_tx_state(tx) == M0_BETX_OPEN
+ * @post M0_IN(m0_be_tx_state(tx), (M0_BETX_CLOSED, M0_BETX_COMMITTED,
+ *                                  M0_BETX_DONE, M0_BETX_FAILED))
  */
 M0_INTERNAL void m0_be_tx_done(struct m0_be_tx *tx);
 
 /**
  * Finalises transaction structure.
  *
- * @pre M0_IN(m0_be_tx_state_get(tx), (M0_BETX_DONE, M0_BETX_FAILED))
+ * @pre M0_IN(m0_be_tx_state(tx), (M0_BETX_DONE, M0_BETX_FAILED))
  */
 M0_INTERNAL void m0_be_tx_fini(struct m0_be_tx *tx);
 
 /**
  * Captures a region in a transaction.
  *
- * @pre m0_be_tx_state_get(tx) == M0_BETX_OPEN
- * @pre m0_be_reg_state_get(reg) == M0_BEREG_INIT
- * @post M0_IN(m0_be_reg_state_get(reg), (M0_BEREG_INPROGRESS, M0_BEREG_SUCCEED,
- *                                        M0_BEREG_FAILED))
+ * @pre m0_be_tx_state(tx) == M0_BETX_OPEN
+ * @pre m0_be_reg_state(reg) == M0_BEREG_INIT
+ * @post M0_IN(m0_be_reg_state(reg), (M0_BEREG_INPROGRESS, M0_BEREG_SUCCEED,
+ *                                    M0_BEREG_FAILED))
  */
 M0_INTERNAL void m0_be_reg_capture(struct m0_be_reg *reg);
 
@@ -385,10 +386,10 @@ M0_INTERNAL void m0_be_reg_capture(struct m0_be_reg *reg);
 /**
  * Allocates a region.
  *
- * @pre m0_be_reg_state_get(reg) == M0_BEREG_INIT
+ * @pre m0_be_reg_state(reg) == M0_BEREG_INIT
  * @pre reg->br_buf.b_addr == NULL
- * @post M0_IN(m0_be_reg_state_get(reg), (M0_BEREG_INPROGRESS, M0_BEREG_SUCCEED,
- *                                        M0_BEREG_FAILED))
+ * @post M0_IN(m0_be_reg_state(reg), (M0_BEREG_INPROGRESS, M0_BEREG_SUCCEED,
+ *                                    M0_BEREG_FAILED))
  */
 M0_INTERNAL void m0_be_alloc(struct m0_be_reg *reg);
 
@@ -396,9 +397,9 @@ M0_INTERNAL void m0_be_alloc(struct m0_be_reg *reg);
  * Frees a region.
  * Freeing NULL is a no-op.
  *
- * @pre m0_be_reg_state_get(reg) == M0_BEREG_INIT
- * @post M0_IN(m0_be_reg_state_get(reg), (M0_BEREG_INPROGRESS, M0_BEREG_SUCCEED,
- *                                        M0_BEREG_FAILED))
+ * @pre m0_be_reg_state(reg) == M0_BEREG_INIT
+ * @post M0_IN(m0_be_reg_state(reg), (M0_BEREG_INPROGRESS, M0_BEREG_SUCCEED,
+ *                                    M0_BEREG_FAILED))
  */
 M0_INTERNAL void m0_be_free(struct m0_be_reg *reg);
 
@@ -408,7 +409,7 @@ M0_INTERNAL void m0_be_free(struct m0_be_reg *reg);
  * This doesn't incur a state change in region state machine and doesn't report
  * failures.
  *
- * @pre m0_be_reg_state_get(reg) == M0_BEREG_INIT
+ * @pre m0_be_reg_state(reg) == M0_BEREG_INIT
  * @pre reg->br_buf.b_addr != NULL
  */
 M0_INTERNAL void m0_be_prefetch(const struct m0_be_reg *reg);
@@ -416,20 +417,20 @@ M0_INTERNAL void m0_be_prefetch(const struct m0_be_reg *reg);
 /**
  * Pins the region in memory, fetching it in first, if necessary.
  *
- * @pre m0_be_reg_state_get(reg) == M0_BEREG_INIT
+ * @pre m0_be_reg_state(reg) == M0_BEREG_INIT
  * @pre reg->br_buf.b_addr != NULL
- * @post M0_IN(m0_be_reg_state_get(reg), (M0_BEREG_INPROGRESS, M0_BEREG_SUCCEED,
- *                                        M0_BEREG_FAILED))
+ * @post M0_IN(m0_be_reg_state(reg), (M0_BEREG_INPROGRESS, M0_BEREG_SUCCEED,
+ *                                    M0_BEREG_FAILED))
  */
 M0_INTERNAL void m0_be_get(const struct m0_be_reg *reg);
 
 /**
  * Un-pins the region, pinned by m0_be_get().
  *
- * @pre m0_be_reg_state_get(reg) == M0_BEREG_INIT
+ * @pre m0_be_reg_state(reg) == M0_BEREG_INIT
  * @pre reg->br_buf.b_addr != NULL
- * @post M0_IN(m0_be_reg_state_get(reg), (M0_BEREG_INPROGRESS, M0_BEREG_SUCCEED,
- *                                        M0_BEREG_FAILED))
+ * @post M0_IN(m0_be_reg_state(reg), (M0_BEREG_INPROGRESS, M0_BEREG_SUCCEED,
+ *                                    M0_BEREG_FAILED))
  */
 M0_INTERNAL void m0_be_put(const struct m0_be_reg *reg);
 
@@ -489,25 +490,6 @@ struct m0_be_domain {
 };
 
 /**
- * Region callback data from transaction layer.
- *
- * The m0_be_tx_pre_cb function is used to check, any of the previous capture is
- * failed. The return value is used in to take decision whether to capture 
- * current region or not in region layer.
- *
- * The m0_be_tx_post_cb function is used to set the transaction status to 
- * M0_BETX_PREPARED if all the region's captured successfully.
- *
- */
-struct m0_be_capture_cb {
-        void    *datum;
-        /** Pre-Capture callback function. */
-        int    (*m0_be_tx_pre_cb)(void *tx);
-        /** Post-Capture callback function. */
-        void   (*m0_be_tx_post_cb)(void *tx);
-};
-
-/**
  * Back-end transaction.
  */
 struct m0_be_tx {
@@ -535,8 +517,6 @@ struct m0_be_reg {
         struct m0_sm_ast br_sm_ast;
         /** Transaction this region is used in. */
         struct m0_be_tx *br_tx;
-        /** This should be filled along with br_tx. */
-        struct m0_be_capture_cb br_tx_cbdata;
         /** Segment for this region */
         struct m0_be_seg *br_seg;
         /** Extent in the segment. */
@@ -561,7 +541,7 @@ struct m0_be_reg {
           +-----------------------CREATING
 	  |   create_failed           | create successful
 	  V                           |
-	FAILED <------+               |  
+	FAILED <------+               |
 	  |           |               +
 	  |           |               |
 	  |           |failed         |
@@ -580,18 +560,18 @@ struct m0_be_reg {
 	  |                           |
 	  |                           V
 	  +----------------------> CLOSED<------------------+
-	  |                        ^  |                     |   
-	  |                        |  |                     |   
-	  |      +-----------------+  |                     |   
-	  |      |     ---------------+--------------       |   
-	  |      |     |              |             |       |   
+	  |                        ^  |                     |
+	  |                        |  |                     |
+	  |      +-----------------+  |                     |
+	  |      |     ---------------+--------------       |
+	  |      |     |              |             |       |
 	  |      |     |              |             |       | m0_be_seg_delete()
 	  |      |     |              |             |       |
-	  |      +--CHECKING--------->|<---------DELETING---+           
-	  |     m0_be_seg_check()     |                      
-	  |                           |                      
-	  |                           |                      
-	  +---------------------------+                      
+	  |      +--CHECKING--------->|<---------DELETING---+
+	  |     m0_be_seg_check()     |
+	  |                           |
+	  |                           |
+	  +---------------------------+
 
    @endverbatim
 
@@ -615,27 +595,17 @@ enum m0_be_seg_state {
                                       |
                                       | m0_be_tx_init()
                                       V
-          +----------------------INITIALIZING
-          |                           |
-          |                           | 
-          |                           |
-          |     timed-out             V
           +-------------------------INIT
 	  |   init_failed             | init successful
 	  |                           |
-	  |                           | 
+	  |                           | m0_be_tx_prep()
 	  |                           V
-          +-------------------------PREPARING
-	  |                           |
+          +-------------------------PREPARED
 	  |                           |
 	  |                           |
-	FAILED <------+               |  
-	  |           |               | m0_be_tx_prep()
+	FAILED <------+               |
 	  |           |               |
 	  |           |failed         |
-	  |           |               V
-	  |           +-------------PREPARED
-	  |           |               |
 	  | fini()    |               | m0_be_tx_start()
 	  |           |               V
 	  |           +-------------OPEN
@@ -646,16 +616,14 @@ enum m0_be_seg_state {
 	  |                           V
 	  |<-------------------------DONE
 	  |                           |
-	  |                           | 
+	  |                           |
 	  |                           V
 	  +----------------------->CLOSED
 
    @endverbatim
 */
 enum m0_be_tx_state {
-        M0_BETX_INITIALIZING,
         M0_BETX_INIT,
-        M0_BETX_PREPARING,
         /* M0_BETX_OPENING renamed to M0_BETX_PREPARED */
         M0_BETX_PREPARED,
         M0_BETX_OPEN,
@@ -672,37 +640,27 @@ enum m0_be_tx_state {
                                       V
           +-------------------------INIT
           |                           |
-          |                           | 
           |                           |
+          |                           | m0_be_alloc()
           |     timed-out             V
-          +-----------------------ALLOCATING
-	  |   alloc_failed            | allocation successful
-	  |                           |
-	  |                           | m0_be_alloc()
-	  |                           V
-          +------------------------ALLOCATED
+          +-----------------------ALLOCATED
+	  |   alloc_failed            |
 	  |                           |
 	  |                           |
-	  |                           |
-	FAILED <------+               |  
+	FAILED <------+               |
 	  |           |               | m0_be_reg_capture()
 	  |           |               |
 	  |           |failed         |
 	  |           |               V
-	  |           +-------------CAPTURING
-	  |           |               |
-	  | fini()    |               | 
-	  |           |               V
 	  |           +-------------CAPTURED
-	  |                           |
-	  |                           |
+	  | fini()                    |
 	  |                           |
 	  |                           | m0_be_free()
 	  |                           V
 	  +-------------------------FREEING
 	  |                           |
-	  |                           | 
-	  |                         FREED  
+	  |                           |
+	  |                         FREED
 	  |                           |
 	  |                           |
 	  |                           |
@@ -712,9 +670,7 @@ enum m0_be_tx_state {
 */
 enum m0_be_reg_state {
         M0_BEREG_INIT,
-        M0_BEREG_ALLOCATING,
         M0_BEREG_ALLOCATED,
-        M0_BEREG_CAPTURING,
         M0_BEREG_CAPTURED,
         M0_BEREG_FREEING,
         M0_BEREG_FREED,
diff --git a/be/domain.c b/be/domain.c
index eccfb12..4315542 100644
--- a/be/domain.c
+++ b/be/domain.c
@@ -45,7 +45,6 @@ M0_INTERNAL void m0_be_domain_init(struct m0_be_domain *dom,
                                    uint64_t dom_magic)
 {
         int          result;
-        m0_time_t    tsleep;
 
         M0_ASSERT(dom != NULL);
 
@@ -55,20 +54,11 @@ M0_INTERNAL void m0_be_domain_init(struct m0_be_domain *dom,
 
         m0_sm_group_init(&dom->bd_impl.sm_group);
 
-        /** Do not worry this is not infinite loop. */
-        while(1) {
-                result = M0_THREAD_INIT(&dom->bd_impl.th, struct m0_sm_group *,
-                                        NULL, &m0_be_handler_thread,
-                                        &dom->bd_impl.sm_group,
-                                        "Backend handler thread");
-                if (result == 0) {
-                        /** Thread creation successfully. */
-                        break;
-                } else {
-                        /** Retrying to create thread. */
-                        m0_thread_fini(&dom->bd_impl.th);
-                        m0_nanosleep(m0_time_set(&tsleep, 1, 0), NULL);
-                }
+        result = M0_THREAD_INIT(&dom->bd_impl.th, struct m0_sm_group *, NULL,
+                                &m0_be_handler_thread, &dom->bd_impl.sm_group,
+                                "Backend handler thread");
+        if (result != 0) {
+                m0_thread_fini(&dom->bd_impl.th);
         }
         m0_be_seg_init(&dom->bd_data, dom, &dom->bd_impl.sm_group, 0);
 
@@ -91,32 +81,24 @@ M0_INTERNAL void m0_be_domain_init(struct m0_be_domain *dom,
         m0_be_init();
 }
 
-M0_INTERNAL int m0_be_domain_lookup(struct m0_be_domain *dom, const char *name,
+M0_INTERNAL bool m0_be_domain_lookup(struct m0_be_domain *dom, const char *name,
                                      struct m0_be_seg **out)
 {
         struct m0_be_seg        *seg_it;
-        int                      found = -1;
+        bool                     found = false;
 
         M0_ASSERT(dom != NULL);
+        M0_PRE(m0_be_seg_state(&dom->bd_data) == M0_BESEG_ACTIVE);
 
-        M0_PRE(m0_be_seg_state_get(&dom->bd_data) == M0_BESEG_ACTIVE);
-
-        m0_tlist_for(&m0_be_seg_tl, &dom->bd_seg, seg_it) {
+        m0_tl_for(m0_be_seg, &dom->bd_seg, seg_it) {
                 if (strcmp(name, seg_it->bs_impl.segment_name) == 0) {
                         *out = seg_it;
-                        found = 0;
+                        found = true;
                         break;
                 }
-        } m0_tlist_endfor;
-
-        if (found != 0) {
-                /* @todo - if found in persistent memory of named segment, then
-                 * add into the in-memory active segment list
-                 * m0_be_seg_tlist_add(&dom->bd_seg, out);
-                 */
-        }
+        } m0_tl_endfor;
 
-        if ((found == 0) && (m0_be_seg_state_get(*out) == M0_BESEG_CLOSED)) {
+        if (found && m0_be_seg_state(*out) == M0_BESEG_CLOSED) {
                 m0_be_seg_open(*out);
         }
 
@@ -128,63 +110,58 @@ M0_INTERNAL void m0_be_domain_fini(struct m0_be_domain *dom)
         struct m0_be_seg         *seg_it;
         struct m0_be_tx          *tx_it;
 
-        M0_PRE(M0_IN(m0_be_seg_state_get(&dom->bd_data), (M0_BESEG_CLOSED,
-                                                         M0_BESEG_FAILED)));
+        M0_PRE(M0_IN(m0_be_seg_state(&dom->bd_data), (M0_BESEG_CLOSED,
+                                                      M0_BESEG_FAILED)));
 
-        m0_tlist_for (&m0_be_tx_tl, &dom->bd_tx, tx_it) {
+        m0_tl_for(m0_be_tx, &dom->bd_tx, tx_it) {
                 m0_be_tx_tlink_del_fini(tx_it);
-        } m0_tlist_endfor;
+        } m0_tl_endfor;
 
-        m0_tlist_for (&m0_be_seg_tl, &dom->bd_seg, seg_it) {
+        m0_tl_for(m0_be_seg, &dom->bd_seg, seg_it) {
                 m0_be_seg_tlink_del_fini(seg_it);
                 m0_be_seg_fini(seg_it);
-        } m0_tlist_endfor;
+        } m0_tl_endfor;
 
-        /* Finilize segment list. */
         m0_be_seg_tlist_fini(&dom->bd_seg);
-
-        /* Finilize transaction list. */
         m0_be_tx_tlist_fini(&dom->bd_tx);
-
-        /* Finalize log device stob. */
         m0_stob_fini(dom->bd_impl.log_stob);
 }
 
-M0_INTERNAL void m0_be_domain_restore(struct m0_be_domain *dom, 
+M0_INTERNAL void m0_be_domain_restore(struct m0_be_domain *dom,
                                       const char          *name,
                                       struct m0_be_seg    *out)
 {
         struct  m0_be_seg        *seg_it;
         struct  m0_stob_domain   *stob_dom;
-        struct  m0_stob_id        stob_id = {{0, 1}}; /** Hardcoded for now */
+        struct  m0_stob_id        stob_id = {{0, 1}}; /* Hardcoded for now. */
         int                       result;
         bool                      stob_directio = true;
-        int                       found = -1;
+        bool                      found = false;
 
         M0_ASSERT(dom != NULL);
 
-        M0_PRE(m0_be_seg_state_get(&dom->bd_data) == M0_BESEG_ACTIVE);
+        M0_PRE(m0_be_seg_state(&dom->bd_data) == M0_BESEG_ACTIVE);
 
-        m0_tlist_for(&m0_be_seg_tl, &dom->bd_seg, seg_it) {
+        m0_tl_for(m0_be_seg, &dom->bd_seg, seg_it) {
                 if (strcmp(name, seg_it->bs_impl.segment_name) == 0) {
-                        memcpy(out, seg_it, sizeof(struct m0_be_seg));
-                        found = 0;
+                        *out = *seg_it;
+                        found = true;
                         break;
                 }
-        } m0_tlist_endfor;
+        } m0_tl_endfor;
 
-        if ((found == 0) && (m0_be_seg_state_get(out) == M0_BESEG_CLOSED)) {
+        if (found && m0_be_seg_state(out) == M0_BESEG_CLOSED) {
                 m0_be_seg_open(out);
         }
 
-        if (found == -1) {
+        if (!found) {
+                /* Hardcoded for now. */
                 out->bs_impl.segment_id = 1;
 
                 m0_be_seg_init(out, dom, &dom->bd_impl.sm_group, 0);
 
-                m0_stob_type_init(&m0_linux_stob_type);
-                result = m0_stob_domain_locate(&m0_linux_stob_type,
-                                               "./__be",
+                //m0_stob_type_init(&m0_linux_stob_type);
+                result = m0_stob_domain_locate(&m0_linux_stob_type, "./__be",
                                                &stob_dom);
                 M0_ASSERT(result == 0);
 
@@ -195,12 +172,8 @@ M0_INTERNAL void m0_be_domain_restore(struct m0_be_domain *dom,
                 M0_ASSERT(result == 0);
 
                 result = m0_stob_create(out->bs_stob, NULL);
-
-                if (result < 0) {
-                        out->bs_stob->so_state = CSS_UNKNOWN;
-                }
-
-                strcpy(out->bs_impl.segment_name, name);
+                strncpy(out->bs_impl.segment_name, name,
+                        sizeof(out->bs_impl.segment_name));
                 m0_be_seg_open(out);
 
                 m0_be_seg_tlink_init(out);
@@ -208,7 +181,6 @@ M0_INTERNAL void m0_be_domain_restore(struct m0_be_domain *dom,
         }
 }
 
-
 M0_INTERNAL void m0_be_handler_thread(struct m0_sm_group *sm_group)
 {
         while(1) {
diff --git a/be/domain.h b/be/domain.h
index 5b07e2b..e7c9285 100644
--- a/be/domain.h
+++ b/be/domain.h
@@ -23,9 +23,10 @@
 #define __MERO_BE_DOMAIN_H__
 
 /**
-  @defgroup be (Meta-data) back-end
+  @defgroup be_domain
   @{
 */
+
 #include "be/be.h"
 
 /**
@@ -38,7 +39,7 @@ M0_INTERNAL void m0_be_handler_thread(struct m0_sm_group *sm_group);
  */
 struct m0_sm_group *m0_be_domain_sm_group(struct m0_be_domain *dom);
 
-/** @} end of be group */
+/** @} end of be_domain group */
 
 /* __MERO_BE_DOMAIN_H__ */
 #endif
diff --git a/be/handle_store.c b/be/handle_store.c
index a4a3e01..84c803b 100644
--- a/be/handle_store.c
+++ b/be/handle_store.c
@@ -51,7 +51,7 @@ M0_INTERNAL void m0_be_hs_update(struct m0_be_seg *seg, uint64_t index,
                         M0_TIME_NEVER);
         m0_sm_group_unlock(m0_be_domain_sm_group(tx.bt_dom));
 
-        if (m0_be_tx_state_get(&tx) == M0_BETX_FAILED)
+        if (m0_be_tx_state(&tx) == M0_BETX_FAILED)
                 goto hs_exit;
 
         offset = index * sizeof(struct m0_uint128);
@@ -64,7 +64,7 @@ M0_INTERNAL void m0_be_hs_update(struct m0_be_seg *seg, uint64_t index,
                         M0_TIME_NEVER);
         m0_sm_group_unlock(m0_be_domain_sm_group(tx.bt_dom));
 
-        if (m0_be_tx_state_get(&tx) == M0_BETX_FAILED)
+        if (m0_be_tx_state(&tx) == M0_BETX_FAILED)
                 goto hs_exit;
 
         m0_be_tx_start(&tx);
@@ -74,7 +74,7 @@ M0_INTERNAL void m0_be_hs_update(struct m0_be_seg *seg, uint64_t index,
                         M0_TIME_NEVER);
         m0_sm_group_unlock(m0_be_domain_sm_group(tx.bt_dom));
 
-        if (m0_be_tx_state_get(&tx) == M0_BETX_FAILED)
+        if (m0_be_tx_state(&tx) == M0_BETX_FAILED)
                 goto hs_exit;
 
         elem = (struct m0_uint128 *) m0_be_static_reg_get_handle_addr(seg,
@@ -89,7 +89,7 @@ M0_INTERNAL void m0_be_hs_update(struct m0_be_seg *seg, uint64_t index,
                         M0_TIME_NEVER);
         m0_sm_group_unlock(m0_be_domain_sm_group(tx.bt_dom));
 
-        if (m0_be_tx_state_get(&tx) == M0_BETX_FAILED)
+        if (m0_be_tx_state(&tx) == M0_BETX_FAILED)
                 goto hs_exit;
 
         m0_be_tx_fini(&tx);
diff --git a/be/helper.c b/be/helper.c
index ce239ef..e04309f 100644
--- a/be/helper.c
+++ b/be/helper.c
@@ -59,7 +59,7 @@ M0_INTERNAL int m0_be_ks_domain_lookup(struct m0_be_domain     *dom,
         ret_val = m0_be_domain_lookup(dom, name, seg);
 
         /* Wait only if lookup succeeds */
-        if (ret_val == 0 && m0_be_seg_state_get(*seg) != M0_BESEG_ACTIVE) {
+        if (ret_val == 0 && m0_be_seg_state(*seg) != M0_BESEG_ACTIVE) {
                 m0_be_wait(sm_group, &(*seg)->bs_sm,
                            M0_BITS(M0_BESEG_ACTIVE, M0_BESEG_FAILED));
         }
diff --git a/be/reg.c b/be/reg.c
index 88155cb..b3d9b43 100644
--- a/be/reg.c
+++ b/be/reg.c
@@ -24,42 +24,25 @@
 
 #include "be/rds.h"
 
-
 /**
         Back-end
-
-  @addtogroup be
+  @addtogroup be_reg
   @{
-  */
+*/
 
-/* State machine variable declarations  */
 static const struct m0_sm_state_descr reg_states[] = {
         [M0_BEREG_INIT] = {
                 .sd_flags     = M0_SDF_INITIAL,
                 .sd_name      = "Init",
-                .sd_allowed   = M0_BITS(M0_BEREG_ALLOCATING,
-                                        M0_BEREG_FREEING,
-                                        M0_BEREG_CAPTURING,
-                                        M0_BEREG_FAILED)
-        },
-        [M0_BEREG_ALLOCATING] = {
-                .sd_flags     = 0,
-                .sd_name      = "Allocating",
                 .sd_allowed   = M0_BITS(M0_BEREG_ALLOCATED,
+                                        M0_BEREG_FREEING,
                                         M0_BEREG_FAILED)
         },
         [M0_BEREG_ALLOCATED] = {
                 .sd_flags     = 0,
                 .sd_name      = "Allocated",
-                .sd_allowed   = M0_BITS(M0_BEREG_CAPTURING,
-                                        M0_BEREG_FREEING,
-                                        M0_BEREG_FAILED)
-        },
-        [M0_BEREG_CAPTURING] = {
-                .sd_flags     = 0,
-                .sd_name      = "Capturing",
                 .sd_allowed   = M0_BITS(M0_BEREG_CAPTURED,
-                                        M0_BEREG_DONE,
+                                        M0_BEREG_FREEING,
                                         M0_BEREG_FAILED)
         },
         [M0_BEREG_CAPTURED] = {
@@ -98,220 +81,39 @@ static const struct m0_sm_conf reg_conf = {
         .scf_state     = reg_states
 };
 
-/**
- * @post m0_be_reg_state_get(reg) == M0_BEREG_INIT
- */
 M0_INTERNAL void m0_be_reg_init(struct m0_be_reg *reg, struct m0_be_tx *tx,
                                 struct m0_be_seg *seg,  struct m0_be_buf *buf)
 {
-        /* Asserting on required pointers */
         M0_ASSERT(reg != NULL);
         M0_ASSERT(seg != NULL);
         M0_ASSERT(buf != NULL);
 
-        /* Initialise region structure with required values */
-        reg->br_tx  = tx;
-        reg->br_tx_cbdata.datum = NULL;
-        reg->br_tx_cbdata.m0_be_tx_pre_cb = m0_be_tx_get_capture_status;
-        reg->br_tx_cbdata.m0_be_tx_post_cb = m0_be_tx_set_capture_status;
-
-        reg->br_seg = seg;
-
-        reg->br_buf.b_nob = buf->b_nob;
-        reg->br_buf.b_logical_address = buf->b_logical_address;
+        reg->br_seg                        = seg;
+        reg->br_tx                         = tx;
+        reg->br_buf.b_nob                  = buf->b_nob;
+        reg->br_buf.b_logical_address      = buf->b_logical_address;
 
-        /* Lock sm group */
         m0_sm_group_lock(m0_be_domain_sm_group(reg->br_seg->bs_dom));
-
-        /* Register the state machine of the tx into sm_group */
         m0_sm_init(&reg->br_sm, &reg_conf, M0_BEREG_INIT,
                   m0_be_domain_sm_group(reg->br_seg->bs_dom), NULL);
-
-        /* Unlock locked sm group */
         m0_sm_group_unlock(m0_be_domain_sm_group(reg->br_seg->bs_dom));
 }
 
-/**
- * Allocates a region.
- * Updates m0_be_reference of region that can be used to persist pointers
- *
- * @pre m0_be_reg_state_get(reg) == M0_BEREG_INIT
- * @pre reg->br_buf.b_addr == NULL
- * @post M0_IN(m0_be_reg_state_get(reg), (M0_BEREG_ALLOCATING
- *                                        M0_BEREG_ALLOCATED,M0_BEREG_FAILED))
- */
-
 M0_INTERNAL void m0_be_alloc(struct m0_be_reg *reg)
 {
-        /* Asserting on required pointers */
-        M0_ASSERT(reg != NULL);
-
-        /* Locking sm group before setting sm_state */
-        m0_sm_group_lock(m0_be_domain_sm_group(reg->br_seg->bs_dom));
-
-        m0_sm_state_set(&reg->br_sm, M0_BEREG_ALLOCATING);
-
-        /* Unlock locked sm group */
-        m0_sm_group_unlock(m0_be_domain_sm_group(reg->br_seg->bs_dom));
-
-        reg->br_sm_ast.sa_cb    = m0_be_alloc_cb;
-        reg->br_sm_ast.sa_datum = (void *)reg;
-
-        m0_be_reg_req_post(m0_be_domain_sm_group(reg->br_seg->bs_dom),
-                           &reg->br_sm_ast);
-}
-
-/**
- * Frees a region.
- *
- * Freeing NULL is a no-op.
- *
- * @pre M0_IN(m0_be_reg_state_get(reg), (M0_BEREG_INIT, M0_BEREG_ALLOCATED,
- *                                       M0_BEREG_DONE, M0_BEREG_FAILED))
- * @post M0_IN(m0_be_reg_state_get(reg), (M0_BEREG_FREEING, M0_BEREG_FREED,
- *                                        M0_BEREG_FAILED))
- */
-M0_INTERNAL void m0_be_free(struct m0_be_reg *reg)
-{
-        /* Asserting on required pointers */
-        M0_ASSERT(reg != NULL);
-
-        /* @todo - Need to understand pre condition check */
-        /* Locking sm group before setting sm_state */
-        m0_sm_group_lock(m0_be_domain_sm_group(reg->br_seg->bs_dom));
-        m0_sm_state_set(&reg->br_sm, M0_BEREG_FREEING);
-        /* Unlock locked sm group */
-        m0_sm_group_unlock(m0_be_domain_sm_group(reg->br_seg->bs_dom));
-
-        reg->br_sm_ast.sa_cb    = m0_be_free_cb;
-        reg->br_sm_ast.sa_datum = (void *)reg;
-
-        m0_be_reg_req_post(m0_be_domain_sm_group(reg->br_seg->bs_dom),
-                           &reg->br_sm_ast);
-}
-
-/**
- * Pre-fetches a region.
- *
- * This doesn't incur a state change in region state machine and doesn't report
- * failures.
- *
- * @pre m0_be_reg_state_get(reg) == M0_BEREG_INIT
- * @pre reg->br_buf.b_addr != NULL
- */
-M0_INTERNAL void m0_be_prefetch(const struct m0_be_reg *reg)
-{
-
-}
-
-
-/**
- * Un-pins the region, pinned by m0_be_get().
- *
- * @pre m0_be_reg_state_get(reg) == M0_BEREG_INIT
- * @pre reg->br_buf.b_addr != NULL
- * @post M0_IN(m0_be_reg_state_get(reg), (M0_BEREG_INPROGRESS, M0_BEREG_SUCCEED,
- *                                        M0_BEREG_FAILED))
- */
-M0_INTERNAL void m0_be_put(const struct m0_be_reg *reg)
-{
-
-}
-
-/**
- * Captures a region in a transaction.
- *
- * @pre m0_be_tx_state_get(tx) == M0_BETX_OPEN
- * @pre M0_IN(m0_be_reg_state_get(reg), (M0_BEREG_INIT, M0_BEREG_ALLOCATED))
- * @post M0_IN(m0_be_reg_state_get(reg), (M0_BEREG_CAPTURING, M0_BEREG_CAPTURED,
- *                                        M0_BEREG_FAILED))
- */
-M0_INTERNAL void m0_be_reg_capture(struct m0_be_reg *reg)
-{
-        struct m0_sm_group *sm_group;
-        int                 grp_locked = 0;
-
-        /* Asserting on required pointers */
-        M0_ASSERT(reg != NULL);
-        M0_ASSERT(reg->br_tx != NULL);
-
-        M0_PRE(M0_IN(m0_be_reg_state_get(reg), (M0_BEREG_INIT,
-                                                M0_BEREG_ALLOCATED)));
-
-        sm_group = m0_be_domain_sm_group(reg->br_seg->bs_dom);
-
-        M0_ASSERT(sm_group != NULL);
-
-        /* Locking sm group before setting sm_state if not locked */
-        if (!m0_mutex_is_locked(&sm_group->s_lock)) {
-                grp_locked = 1;
-                m0_sm_group_lock(sm_group);
-        }
-
-        m0_sm_state_set(&reg->br_sm, M0_BEREG_CAPTURING);
-
-        /* Unlock locked sm group if locked locally */
-        if (grp_locked)
-                m0_sm_group_unlock(sm_group);
-
-        reg->br_sm_ast.sa_cb    = m0_be_reg_capture_cb;
-        reg->br_sm_ast.sa_datum = (void *)reg;
-
-        m0_be_reg_req_post(sm_group, &reg->br_sm_ast);
-
-}
-
-/**
- * @pre M0_IN(m0_be_reg_state_get(reg), (M0_BEREG_DONE, M0_BEREG_FAILED))
- */
-M0_INTERNAL void m0_be_reg_fini(struct m0_be_reg *reg)
-{
-
-        M0_PRE(M0_IN(m0_be_reg_state_get(reg), (M0_BEREG_DONE,
-                                                M0_BEREG_FAILED)));
-
-        /* todo@ Finalizing on state machine */
-}
-
-/**
- * The function posts reg request to state machine thread
- *
- */
-M0_INTERNAL void m0_be_reg_req_post(struct m0_sm_group *sm_group,
-                                 struct m0_sm_ast *sm_ast)
-{
-        m0_sm_ast_post(sm_group, sm_ast);
-}
-
-/**
- * Callback function for allocation of region
- *
- */
-
-M0_INTERNAL void m0_be_alloc_cb(struct m0_sm_group *sm_group,
-                                  struct m0_sm_ast *sm_ast)
-{
-        struct m0_be_reg        *reg;
-        struct m0_uint128       *toffset;
-        rvm_tid_t               *tid = NULL;
-        struct m0_be_reference  *reg_laddress;
-        int                      err;
         uint64_t                 hi;
         long int                 lo;
-
-        /* Asserting on required pointers */
-        M0_ASSERT(sm_group != NULL);
-        M0_ASSERT(sm_ast != NULL);
-
-        reg = (struct m0_be_reg *)sm_ast->sa_datum;
+        int                      err;
+        rvm_tid_t               *tid = NULL;
+        struct m0_be_reference  *reg_laddress;
+        struct m0_uint128       *toffset;
 
         M0_ASSERT(reg != NULL);
 
         if (reg->br_tx != NULL)
                 tid = reg->br_tx->bt_impl.tx_id;
 
-        reg->br_buf.b_addr = (void *)rds_malloc(reg->br_buf.b_nob,
-                                                tid, &err);
+        reg->br_buf.b_addr = (void *)rds_malloc(reg->br_buf.b_nob, tid, &err);
 
         /* Assign domain magic to reg reference magic  to identify references
          * within the domain.
@@ -319,55 +121,40 @@ M0_INTERNAL void m0_be_alloc_cb(struct m0_sm_group *sm_group,
         reg_laddress            = &reg->br_buf.b_logical_address;
         reg_laddress->be_magic  = reg->br_seg->bs_dom->bd_magic;
 
-        toffset = &reg->br_buf.b_logical_address.be_segid_offset;
-
-        hi = reg->br_seg->bs_impl.segment_id;
-        lo = (reg->br_seg->bs_addr - reg->br_buf.b_addr);
-
+        hi      = reg->br_seg->bs_impl.segment_id;
+        lo      = (reg->br_seg->bs_addr - reg->br_buf.b_addr);
 
-       if (lo < 0)
-                 lo = -1 * lo;
+        if (lo < 0)
+                lo = -1 * lo;
 
-        toffset->u_hi = hi;
-        toffset->u_lo = lo;
+        toffset         = &reg->br_buf.b_logical_address.be_segid_offset;
+        toffset->u_hi   = hi;
+        toffset->u_lo   = lo;
 
+        m0_sm_group_lock(m0_be_domain_sm_group(reg->br_seg->bs_dom));
         m0_sm_state_set(&reg->br_sm, M0_BEREG_ALLOCATED);
-
-        return;
+        m0_sm_group_unlock(m0_be_domain_sm_group(reg->br_seg->bs_dom));
 }
 
-/**
- * Callback function for freeing of region
- *
- */
-
-M0_INTERNAL void m0_be_free_cb(struct m0_sm_group *sm_group,
-                                  struct m0_sm_ast *sm_ast)
+M0_INTERNAL void m0_be_free(struct m0_be_reg *reg)
 {
         int                      err;
         rvm_tid_t               *tid = NULL;
-        struct m0_be_reg        *reg;
         struct m0_uint128       *toffset;
 
-        /* Asserting on required pointers */
-        M0_ASSERT(sm_group != NULL);
-        M0_ASSERT(sm_ast != NULL);
-
-        reg = (struct m0_be_reg *)sm_ast->sa_datum;
-
         M0_ASSERT(reg != NULL);
 
         if (reg->br_tx != NULL)
                 tid = reg->br_tx->bt_impl.tx_id;
-        /*
-         * Allocate memory from RDS Heap.
-         * Update br_buf to store virtual address.
-         */
 
         rds_free((char *)reg->br_buf.b_addr, tid, &err);
 
-        if (err != SUCCESS)
-                goto error_exit;
+        if (err != SUCCESS) {
+                m0_sm_group_lock(m0_be_domain_sm_group(reg->br_seg->bs_dom));
+                m0_sm_state_set(&reg->br_sm, M0_BEREG_FAILED);
+                m0_sm_group_unlock(m0_be_domain_sm_group(reg->br_seg->bs_dom));
+                return;
+        }
 
         toffset = &reg->br_buf.b_logical_address.be_segid_offset;
 
@@ -375,61 +162,52 @@ M0_INTERNAL void m0_be_free_cb(struct m0_sm_group *sm_group,
         toffset->u_hi       = 0;
         toffset->u_lo       = 0;
 
+        m0_sm_group_lock(m0_be_domain_sm_group(reg->br_seg->bs_dom));
         m0_sm_state_set(&reg->br_sm, M0_BEREG_FREED);
-
-error_exit:
-        m0_sm_state_set(&reg->br_sm, M0_BEREG_FAILED);
+        m0_sm_group_unlock(m0_be_domain_sm_group(reg->br_seg->bs_dom));
 }
 
-
-/**
- * Callback function for capturing region
- *
- */
-M0_INTERNAL void m0_be_reg_capture_cb(struct m0_sm_group *sm_group,
-                                      struct m0_sm_ast *sm_ast)
+M0_INTERNAL void m0_be_prefetch(const struct m0_be_reg *reg)
 {
-        struct m0_be_reg *reg;
-        rvm_return_t ret;
-        int result;
-        enum m0_be_reg_state reg_st = M0_BEREG_FAILED;
 
+}
 
-        /* Asserting on required pointers */
-        M0_ASSERT(sm_group != NULL);
-        M0_ASSERT(sm_ast != NULL);
+M0_INTERNAL void m0_be_put(const struct m0_be_reg *reg)
+{
 
-        reg = (struct m0_be_reg *)sm_ast->sa_datum;
+}
+
+M0_INTERNAL void m0_be_reg_capture(struct m0_be_reg *reg)
+{
+        struct m0_sm_group      *sm_group;
+        rvm_return_t             ret;
+        enum m0_be_reg_state     reg_st;
 
         M0_ASSERT(reg != NULL);
+        M0_ASSERT(reg->br_tx != NULL);
+
+        M0_PRE(M0_IN(m0_be_reg_state(reg), (M0_BEREG_INIT, M0_BEREG_ALLOCATED)));
+
+        sm_group = m0_be_domain_sm_group(reg->br_seg->bs_dom);
+        M0_ASSERT(sm_group != NULL);
 
-        if(reg->br_tx_cbdata.datum) {
-                result = reg->br_tx_cbdata.m0_be_tx_pre_cb(
-                                        reg->br_tx_cbdata.datum);
-                /**
-                 * Do not perform rvm_set_range on current region if region
-                 * capture is failed for any previous region
-                 */
-                if( result == M0_BETX_PREP_FAILED) {
-                        reg_st = M0_BEREG_DONE;
-                        goto reg_done_exit;
-                }
-         }
-
-        ret = rvm_set_range(reg->br_tx->bt_impl.tx_id,
-                            reg->br_buf.b_addr,
+        ret = rvm_set_range(reg->br_tx->bt_impl.tx_id, reg->br_buf.b_addr,
                             reg->br_buf.b_nob);
 
-        if(RVM_SUCCESS == ret)
+        if (RVM_SUCCESS == ret)
                 reg_st = M0_BEREG_CAPTURED;
+        else
+                reg_st = M0_BEREG_FAILED;
 
-
-reg_done_exit:
+        m0_sm_group_lock(sm_group);
         m0_sm_state_set(&reg->br_sm, reg_st);
+        m0_sm_group_unlock(sm_group);
+}
 
-        if(reg->br_tx_cbdata.datum) {
-                reg->br_tx_cbdata.m0_be_tx_post_cb(reg->br_tx_cbdata.datum);
-        }
+M0_INTERNAL void m0_be_reg_fini(struct m0_be_reg *reg)
+{
+        M0_PRE(M0_IN(m0_be_reg_state(reg), (M0_BEREG_DONE, M0_BEREG_FAILED)));
+        /* todo@ Finalizing on state machine */
 }
 
 M0_INTERNAL void m0_be_static_reg_capture_buf(uint64_t offset,
@@ -441,13 +219,12 @@ M0_INTERNAL void m0_be_static_reg_capture_buf(uint64_t offset,
 
         M0_ASSERT(reg != NULL);
         M0_ASSERT(seg->bs_static_addr != NULL);
+
         buf.b_nob = sizeof(struct m0_uint128);
         buf.b_addr = seg->bs_static_addr + offset;
 
         m0_be_reg_init(reg, NULL, seg, &buf);
-
         m0_be_tx_add_cred(tx, reg);
-
         m0_be_tx_prep(tx);
 }
 
@@ -458,7 +235,7 @@ M0_INTERNAL void *m0_be_static_reg_get_handle_addr(struct m0_be_seg *seg,
         return (seg->bs_static_addr + offset);
 }
 
-M0_INTERNAL uint32_t m0_be_reg_state_get(const struct m0_be_reg *reg)
+M0_INTERNAL uint32_t m0_be_reg_state(const struct m0_be_reg *reg)
 {
         return reg->br_sm.sm_state;
 }
diff --git a/be/reg.h b/be/reg.h
index fca6341..7f74e66 100644
--- a/be/reg.h
+++ b/be/reg.h
@@ -25,7 +25,7 @@
 /**
   @defgroup be (Meta-data) back-end
   @{
-  */
+*/
 #include "be/be.h"
 
 M0_INTERNAL void m0_be_alloc_cb(struct m0_sm_group  *sm_group,
@@ -53,9 +53,9 @@ M0_INTERNAL void m0_be_static_reg_capture_buf(uint64_t offset,
 M0_INTERNAL void *m0_be_static_reg_get_handle_addr(struct m0_be_seg *seg,
                                                    uint64_t offset);
 
-M0_INTERNAL uint32_t m0_be_reg_state_get(const struct m0_be_reg *reg);
+M0_INTERNAL uint32_t m0_be_reg_state(const struct m0_be_reg *reg);
 
-/** @} end of be group */
+/** @} end of be_reg group */
 
 /* __MERO_BE_REG_H__ */
 #endif
diff --git a/be/seg.c b/be/seg.c
index 25f48a1..ab77307 100644
--- a/be/seg.c
+++ b/be/seg.c
@@ -31,9 +31,7 @@
 /**
   @addtogroup be_seg
   @{
- */
-
-/** State machine states for backend segment. */
+*/
 
 static const struct m0_sm_state_descr m0_be_seg_states[] = {
         [M0_BESEG_INIT] = {
@@ -112,8 +110,7 @@ M0_INTERNAL void m0_be_seg_create(struct m0_be_seg *seg, struct m0_be_tx *tx,
           Check for duplicate segment name.
           If found set state to M0_BESEG_FAILED and return.
          */
-
-        m0_tlist_for(&m0_be_seg_tl, &seg->bs_dom->bd_seg, scan) {
+        m0_tl_for(m0_be_seg, &seg->bs_dom->bd_seg, scan) {
                 if (strcmp(name, scan->bs_impl.segment_name) == 0) {
                         m0_sm_group_lock(m0_be_domain_sm_group(seg->bs_dom));
                         m0_sm_state_set(&seg->bs_sm, M0_BESEG_FAILED);
@@ -123,14 +120,12 @@ M0_INTERNAL void m0_be_seg_create(struct m0_be_seg *seg, struct m0_be_tx *tx,
         } m0_tl_endfor;
 
         m0_sm_group_lock(m0_be_domain_sm_group(seg->bs_dom));
-
         m0_sm_state_set(&seg->bs_sm, M0_BESEG_CREATING);
-
         m0_sm_group_unlock(m0_be_domain_sm_group(seg->bs_dom));
 
-        seg->bs_stob = stob;
-        strcpy(seg->bs_impl.segment_name, name);
-
+        strncpy(seg->bs_impl.segment_name, name,
+                sizeof(seg->bs_impl.segment_name));
+        seg->bs_stob            = stob;
         seg->bs_sm_ast.sa_cb    = m0_be_seg_create_cb;
         seg->bs_sm_ast.sa_datum = (void *)seg;
 
@@ -158,11 +153,8 @@ M0_INTERNAL void m0_be_seg_init(struct m0_be_seg *seg,
         seg->bs_page.bp_addr = NULL;
 
         m0_sm_group_lock(sm_group);
-
-        /* Register the state machine of the segment into sm_group. */
         m0_sm_init(&seg->bs_sm, &seg_conf, M0_BESEG_INIT, sm_group,
                         &seg->bs_addb);
-
         m0_sm_group_unlock(sm_group);
 }
 
@@ -170,10 +162,9 @@ M0_INTERNAL void m0_be_seg_open(struct m0_be_seg *seg)
 {
         M0_ASSERT(seg != NULL);
 
-        M0_PRE(M0_IN(m0_be_seg_state_get(seg), (M0_BESEG_INIT,
-                                                M0_BESEG_CLOSED)));
+        M0_PRE(M0_IN(m0_be_seg_state(seg), (M0_BESEG_INIT, M0_BESEG_CLOSED)));
 
-        M0_PRE(m0_be_seg_state_get(&seg->bs_dom->bd_data) == M0_BESEG_ACTIVE);
+        M0_PRE(m0_be_seg_state(&seg->bs_dom->bd_data) == M0_BESEG_ACTIVE);
 
         m0_sm_group_lock(m0_be_domain_sm_group(seg->bs_dom));
 
@@ -191,7 +182,7 @@ M0_INTERNAL void m0_be_seg_done(struct m0_be_seg *seg)
 {
         M0_ASSERT(seg != NULL);
 
-        M0_PRE(m0_be_seg_state_get(seg) == M0_BESEG_ACTIVE);
+        M0_PRE(m0_be_seg_state(seg) == M0_BESEG_ACTIVE);
 
         m0_sm_group_lock(m0_be_domain_sm_group(seg->bs_dom));
 
@@ -206,8 +197,7 @@ M0_INTERNAL void m0_be_seg_fini(struct m0_be_seg *seg)
 {
         M0_ASSERT(seg != NULL);
 
-        M0_PRE(M0_IN(m0_be_seg_state_get(seg), (M0_BESEG_CLOSED,
-                                                M0_BESEG_FAILED)));
+        M0_PRE(M0_IN(m0_be_seg_state(seg), (M0_BESEG_CLOSED, M0_BESEG_FAILED)));
 
         /* Finalizing on state machine. */
         m0_sm_fini(&seg->bs_sm);
@@ -452,7 +442,7 @@ error:
         return;
 }
 
-uint32_t m0_be_seg_state_get(const struct m0_be_seg *seg)
+M0_INTERNAL uint32_t m0_be_seg_state(const struct m0_be_seg *seg)
 {
         return seg->bs_sm.sm_state;
 }
diff --git a/be/seg.h b/be/seg.h
index 56f1b3e..561f72b 100644
--- a/be/seg.h
+++ b/be/seg.h
@@ -23,7 +23,7 @@
 #define __MERO_BE_SEG_H__
 
 /**
-  @defgroup be (Meta-data) back-end
+  @defgroup be_seg
   @{
 */
 
@@ -58,9 +58,9 @@ M0_INTERNAL void m0_be_seg_open_cb(struct m0_sm_group *sm_group,
 /**
  * This function returns state machine for the segment.
  */
-M0_INTERNAL uint32_t m0_be_seg_state_get(const struct m0_be_seg *seg);
+M0_INTERNAL uint32_t m0_be_seg_state(const struct m0_be_seg *seg);
 
-/** @} end of be group */
+/** @} end of be_seg group */
 
 /* __MERO_BE_SEG_H__ */
 #endif
diff --git a/be/tx.c b/be/tx.c
index 1f42b32..2232021 100644
--- a/be/tx.c
+++ b/be/tx.c
@@ -16,33 +16,22 @@
  * Original author: Prashant Dhange <prashant_dhange@xyratex.com>
  * Original creation date: 12/03/2012
  */
-
 #include "be/be.h"
 #include "be/be_private.h"
 #include "be/tx.h"
 #include "be/reg.h"
 #include "be/domain.h"
 
-/* State machine variable declarations.  */
+/**
+  @addtogroup be_tx
+  @{
+*/
+
 static const struct m0_sm_state_descr tx_states[] = {
-         [M0_BETX_INITIALIZING] = {
-                .sd_flags     = M0_SDF_INITIAL,
-                .sd_name      = "Initializing",
-                .sd_allowed   = M0_BITS(M0_BETX_INIT,
-                                        M0_BETX_FAILED)
-        },
         [M0_BETX_INIT] = {
-                .sd_flags     = 0,
+                .sd_flags     = M0_SDF_INITIAL,
                 .sd_name      = "Initialize",
-                .sd_allowed   = M0_BITS(M0_BETX_PREPARING,
-                                        M0_BETX_OPEN,
-                                        M0_BETX_FAILED)
-        },
-        [M0_BETX_PREPARING] = {
-                .sd_flags     = 0,
-                .sd_name      = "Preparing",
                 .sd_allowed   = M0_BITS(M0_BETX_PREPARED,
-                                        M0_BETX_PREPARING,
                                         M0_BETX_OPEN,
                                         M0_BETX_FAILED)
         },
@@ -65,7 +54,6 @@ static const struct m0_sm_state_descr tx_states[] = {
                 .sd_name      = "Done",
                 .sd_allowed   = M0_BITS(M0_BETX_CLOSED,
                                         M0_BETX_COMMITTED,
-                                        M0_BETX_PREPARING,
                                         M0_BETX_FAILED)
         },
         [M0_BETX_CLOSED] = {
@@ -92,110 +80,94 @@ static const struct m0_sm_conf tx_conf = {
         .scf_state     = tx_states
 };
 
-M0_INTERNAL void m0_be_tx_init(struct m0_be_tx *tx,
-                               struct m0_be_domain *dom, uint64_t flags)
+M0_INTERNAL void m0_be_tx_init(struct m0_be_tx *tx, struct m0_be_domain *dom,
+                               uint64_t flags)
 {
-        /* Asserting on required pointers. */
+        enum m0_be_tx_state   tx_state;
+        rvm_tid_t            *tid;
+        rvm_return_t          ret;
+
         M0_ASSERT(tx != NULL);
         M0_ASSERT(dom != NULL);
         M0_ASSERT(&dom->bd_impl.sm_group != NULL);
 
-        /* Initialise domain structure with required values. */
         tx->bt_dom = dom;
-
-        /* Initialize bt_impl->bc_tl list. */
         m0_be_reg_tlist_init(&tx->bt_impl.bc_tl);
 
-        /*
-         * Locking sm_group is required before initializing sm
-         * TODO@ Need to confirm with Nikita, do we need to move the state
-         * transition logic to CALLBACKS. This Applies for state change
-         * accross the segments, regions, transactions.
-         */
         m0_sm_group_lock(m0_be_domain_sm_group(tx->bt_dom));
-
-        /* Register the state machine of the tx into sm_group. */
-        m0_sm_init(&tx->bt_sm, &tx_conf, M0_BETX_INITIALIZING,
+        m0_sm_init(&tx->bt_sm, &tx_conf, M0_BETX_INIT,
                    m0_be_domain_sm_group(tx->bt_dom), NULL);
-
-        /* Unlock locked sm group. */
         m0_sm_group_unlock(m0_be_domain_sm_group(tx->bt_dom));
 
-        tx->bt_sm_ast.sa_cb    = m0_be_tx_init_cb;
-        tx->bt_sm_ast.sa_datum = (void *)tx;
+        tid = rvm_malloc_tid();
+        if (tid == NULL) {
+                tx_state = M0_BETX_FAILED;
+                goto err_exit;
+        }
 
-        m0_tx_req_post(m0_be_domain_sm_group(tx->bt_dom), &tx->bt_sm_ast);
+        tx->bt_impl.tx_id = tid;
+        ret = rvm_begin_transaction(tx->bt_impl.tx_id, restore);
+        if (RVM_SUCCESS != ret) {
+                rvm_free_tid(tid);
+                tx_state = M0_BETX_FAILED;
+                goto err_exit;
+        }
+        return;
+err_exit:
+        m0_be_sm_state_change(m0_be_domain_sm_group(tx->bt_dom), &tx->bt_sm,
+                              M0_BETX_FAILED);
 }
 
 M0_INTERNAL void m0_be_tx_prep(struct m0_be_tx *tx)
 {
-        struct m0_be_reg *reg_it;
+        struct m0_be_reg        *reg_it;
+        enum m0_be_tx_state      tx_state;
 
-        /* Asserting on required pointers. */
         M0_ASSERT(tx != NULL);
 
-        /* Is m0_be_tx_state_get(tx) in M0_BETX_INIT state. */
-        M0_PRE(m0_be_tx_state_get(tx) == M0_BETX_INIT);
-
-        /* Iterate credit list of regions. */
-        m0_tlist_for(&m0_be_reg_tl, &tx->bt_impl.bc_tl, reg_it) {
-
-                /* Check reg_it->br_sm.sm_state for region state. */
-
-                if (!M0_IN(m0_be_reg_state_get(reg_it), (M0_BEREG_INIT, 
-                                                         M0_BEREG_ALLOCATED))) {
-
-                        m0_be_sm_state_change(m0_be_domain_sm_group(tx->bt_dom),
-                                              &tx->bt_sm, M0_BETX_FAILED);
-                        /* TODO@ add error log message. */
-                        goto exit_error;
+        M0_PRE(m0_be_tx_state(tx) == M0_BETX_INIT);
+        m0_tl_for(m0_be_reg, &tx->bt_impl.bc_tl, reg_it) {
+                if (!M0_IN(m0_be_reg_state(reg_it), (M0_BEREG_INIT,
+                                                     M0_BEREG_ALLOCATED))) {
+                        tx_state = M0_BETX_FAILED;
+                        rvm_abort_transaction(tx->bt_impl.tx_id);
+                        rvm_free_tid(tx->bt_impl.tx_id);
+                        goto exit;
                 }
-
         } m0_tlist_endfor;
 
-        m0_be_sm_state_change(m0_be_domain_sm_group(tx->bt_dom),
-                              &tx->bt_sm, M0_BETX_PREPARING);
-
-        tx->bt_sm_ast.sa_cb    = m0_be_tx_prep_cb;
-        tx->bt_sm_ast.sa_datum = (void *)tx;
-
-        m0_tx_req_post(m0_be_domain_sm_group(tx->bt_dom), &tx->bt_sm_ast);
-        goto exit;
+        m0_tl_for(m0_be_reg, &tx->bt_impl.bc_tl, reg_it) {
+                reg_it->br_tx = tx;
+                m0_be_reg_capture(reg_it);
+                if (m0_be_reg_state(reg_it) != M0_BEREG_CAPTURED) {
+                        tx_state = M0_BETX_FAILED;
+                        goto exit;
+                }
+        } m0_tlist_endfor;
 
-exit_error:
-        rvm_abort_transaction(tx->bt_impl.tx_id);
-        rvm_free_tid(tx->bt_impl.tx_id);
+        tx_state = M0_BETX_PREPARED;
 exit:
-        return;
+        m0_be_sm_state_change(m0_be_domain_sm_group(tx->bt_dom), &tx->bt_sm,
+                              tx_state);
 }
 
 M0_INTERNAL void m0_be_tx_start(struct m0_be_tx *tx)
 {
-
         M0_ASSERT(tx != NULL);
+        M0_PRE(m0_be_tx_state(tx) == M0_BETX_PREPARED);
 
-        /*
-         * Added M0_IN support to call start when theres nothing in
-         * credit list i.e. without calling tx_prep.
-         */
-        M0_IN(m0_be_tx_state_get(tx), (M0_BETX_PREPARED, M0_BETX_PREPARING));
-
-        tx->bt_sm_ast.sa_cb    = m0_be_tx_start_cb;
-        tx->bt_sm_ast.sa_datum = (void *)tx;
-
-        m0_tx_req_post(m0_be_domain_sm_group(tx->bt_dom), &tx->bt_sm_ast);
+        m0_be_tx_tlink_init(tx);
+        m0_be_tx_tlist_add(&tx->bt_dom->bd_tx, tx);
+        m0_be_sm_state_change(m0_be_domain_sm_group(tx->bt_dom), &tx->bt_sm,
+                              M0_BETX_OPEN);
 }
 
 M0_INTERNAL void m0_be_tx_done(struct m0_be_tx *tx)
 {
-        /* Asserting on required pointers. */
         M0_ASSERT(tx != NULL);
-
-        M0_PRE(m0_be_tx_state_get(tx) == M0_BETX_OPEN);
-
+        M0_PRE(m0_be_tx_state(tx) == M0_BETX_OPEN);
         tx->bt_sm_ast.sa_cb    = m0_be_tx_done_cb;
         tx->bt_sm_ast.sa_datum = (void *)tx;
-
         m0_tx_req_post(m0_be_domain_sm_group(tx->bt_dom), &tx->bt_sm_ast);
 }
 
@@ -203,137 +175,25 @@ M0_INTERNAL void m0_be_tx_fini(struct m0_be_tx *tx)
 {
         struct m0_be_reg *reg_it;
 
-        /* Asserting on required pointers. */
         M0_ASSERT(tx != NULL);
-
-        M0_PRE(M0_IN(m0_be_tx_state_get(tx), (M0_BETX_DONE, M0_BETX_FAILED)));
-
+        M0_PRE(M0_IN(m0_be_tx_state(tx), (M0_BETX_DONE, M0_BETX_FAILED)));
         rvm_free_tid(tx->bt_impl.tx_id);
-
-         /* Removing entries from reg list if present. */
-         /* Iterate credit list of regions. */
-         m0_tlist_for(&m0_be_reg_tl, &tx->bt_impl.bc_tl, reg_it) {
+         m0_tl_for(m0_be_reg, &tx->bt_impl.bc_tl, reg_it) {
                 if (m0_be_reg_tlink_is_in(reg_it)) {
                          m0_be_reg_tlink_del_fini(reg_it);
-
                          m0_be_reg_fini(reg_it);
                 }
          } m0_tlist_endfor;
 
-        /* Finalise bt_impl->bc_tl list. */
         m0_be_reg_tlist_fini(&tx->bt_impl.bc_tl);
-
         m0_be_sm_state_change(m0_be_domain_sm_group(tx->bt_dom),
                               &tx->bt_sm, M0_BETX_CLOSED);
-
-        /* Remove entry from in memory active transaction list if present. */
         if (m0_be_tx_tlink_is_in(tx))
                 m0_be_tx_tlink_del_fini(tx);
-
-        /* Finalizing on state machine. */
         m0_sm_fini(&tx->bt_sm);
 }
 
 /**
- *    m0_be_tx_init callback function.
- */
-M0_INTERNAL void m0_be_tx_init_cb(struct m0_sm_group *sm_group,
-                                  struct m0_sm_ast *sm_ast)
-{
-        struct m0_be_tx         *tx;
-        rvm_return_t             ret;
-        rvm_tid_t               *tid;
-
-        /* Asserting on required pointers. */
-        M0_ASSERT(sm_group != NULL);
-        M0_ASSERT(sm_ast != NULL);
-
-        tx = (struct m0_be_tx *) sm_ast->sa_datum;
-        M0_ASSERT(tx != NULL);
-
-        tid = rvm_malloc_tid();
-
-        if (tid == NULL) {
-                /* TODO@ add error log message. */
-                goto exit_alloc;
-        }
-
-        tx->bt_impl.tx_id = tid;
-
-        ret = rvm_begin_transaction(tx->bt_impl.tx_id, restore);
-
-        if (RVM_SUCCESS != ret) {
-                /* TODO@ add error log message. */
-                goto exit_begin_tx;
-        }
-        m0_sm_state_set(&tx->bt_sm, M0_BETX_INIT);
-        goto exit;
-
-exit_begin_tx:
-        rvm_free_tid(tid);
-exit_alloc:
-        m0_sm_state_set(&tx->bt_sm, M0_BETX_FAILED);
-exit:
-        return;
-}
-
-/**
- * m0_be_tx_prep callback function.
- */
-M0_INTERNAL void m0_be_tx_prep_cb(struct m0_sm_group *sm_group,
-                                  struct m0_sm_ast *sm_ast)
-{
-        struct m0_be_tx         *tx;
-        struct m0_be_reg        *reg_it;
-
-        /* Asserting on required pointers. */
-        M0_ASSERT(sm_group != NULL);
-        M0_ASSERT(sm_ast != NULL);
-
-        tx = (struct m0_be_tx *) sm_ast->sa_datum;
-
-        M0_ASSERT(tx != NULL);
-
-        /* Iterate credit list of regions. */
-        m0_tlist_for(&m0_be_reg_tl, &tx->bt_impl.bc_tl, reg_it) {
-                /* Assumption: reg_it->br_tx will be updated to tx. */
-                reg_it->br_tx = tx;
-                reg_it->br_tx_cbdata.datum = (void *)tx;
-
-                /**
-                 * Capture region function which changes
-                 * the region state to InProgress.
-                 */
-                m0_be_reg_capture(reg_it);
-
-        } m0_tlist_endfor;
-
-        return;
-}
-
-/**
- *  m0_be_tx_start callback function.
- */
-M0_INTERNAL void m0_be_tx_start_cb(struct m0_sm_group *sm_group,
-                                   struct m0_sm_ast *sm_ast)
-{
-        struct m0_be_tx         *tx;
-
-        /* Asserting on required pointers. */
-        M0_ASSERT(sm_group != NULL);
-        M0_ASSERT(sm_ast != NULL);
-
-        tx = (struct m0_be_tx *) sm_ast->sa_datum;
-
-        /* Add this transaction to domain's active transaction list. */
-        m0_be_tx_tlink_init(tx);
-
-        m0_be_tx_tlist_add(&tx->bt_dom->bd_tx, tx);
-
-        m0_sm_state_set(&tx->bt_sm, M0_BETX_OPEN);
-}
-
-/**
  *  m0_be_tx_done callback function.
  */
 M0_INTERNAL void m0_be_tx_done_cb(struct m0_sm_group *sm_group,
@@ -341,25 +201,18 @@ M0_INTERNAL void m0_be_tx_done_cb(struct m0_sm_group *sm_group,
 {
         struct m0_be_tx         *tx;
         struct m0_be_reg        *reg_it;
-        rvm_return_t ret;
+        rvm_return_t            ret;
 
-        /* Asserting on required pointers. */
         M0_ASSERT(sm_group != NULL);
         M0_ASSERT(sm_ast != NULL);
 
         tx = (struct m0_be_tx *) sm_ast->sa_datum;
-
         ret = rvm_end_transaction(tx->bt_impl.tx_id, flush);
-
         if (RVM_SUCCESS != ret) {
-                /* TODO@ add error log message. */
                 goto exit_end_tx;
         }
 
-        /* Iterate credit list of regions. */
-        m0_tlist_for(&m0_be_reg_tl, &tx->bt_impl.bc_tl, reg_it) {
-                /* Mark all regions for completion. */
-                /* TODO@ need to call function m0_sm_state_set(). */
+        m0_tl_for(m0_be_reg, &tx->bt_impl.bc_tl, reg_it) {
                 m0_sm_state_set(&reg_it->br_sm, M0_BEREG_DONE);
         } m0_tlist_endfor;
 
@@ -376,101 +229,25 @@ exit:
 M0_INTERNAL void m0_be_tx_add_cred(struct m0_be_tx *tx,
                                    struct m0_be_reg *reg)
 {
-        /* Asserting on required pointers. */
         M0_ASSERT(tx != NULL);
         M0_ASSERT(reg != NULL);
 
-        /* Add reg to credit list, default would be add to tail. */
         m0_be_reg_tlink_init(reg);
-
         m0_be_reg_tlist_add_tail(&tx->bt_impl.bc_tl, reg);
 }
 
-/**
- * The function posts tx request to state machine thread.
- */
 M0_INTERNAL void m0_tx_req_post(struct m0_sm_group *sm_group,
                                 struct m0_sm_ast *sm_ast)
 {
         m0_sm_ast_post(sm_group, sm_ast);
 }
 
-/**
- * The function iterates the region list to check if any region capture has
- * failed.
- * If any earlier capture is failed, then the current region won't be captured.
- */
-M0_INTERNAL int m0_be_tx_get_capture_status(void * data)
-{
-        struct m0_be_tx *tx = (struct m0_be_tx *)data;
-        struct m0_be_reg *reg_it;
-
-        int result = M0_BETX_PREP_INPROGRESS;
-
-        /* Iterate credit list to check the capture status for each region. */
-        m0_tlist_for(&m0_be_reg_tl, &tx->bt_impl.bc_tl, reg_it) {
-                /* Check reg_it->br_sm.sm_state for region state. */
-
-                if (m0_be_reg_state_get(reg_it) == M0_BEREG_FAILED) {
-                        result = M0_BETX_PREP_FAILED;
-                        break;
-                }
-
-        } m0_tlist_endfor;
-
-        return result;
-}
-
-/**
- * The function iterates all the region list to check if they are captured
- * successfully.
- * This is pre-requisite for transaction to be marked as PREPARED.
- */
-M0_INTERNAL void m0_be_tx_set_capture_status(void * data)
-{
-        struct m0_be_tx *tx = (struct m0_be_tx *)data;
-        struct m0_be_reg *reg_it;
-
-        bool failed_res = false;
-        bool capturing_res = false;
-
-        /* Iterate credit list to check the capture status for each region. */
-        m0_tlist_for(&m0_be_reg_tl, &tx->bt_impl.bc_tl, reg_it) {
-                /* Check if region capture is in prorgess. */
-                if (m0_be_reg_state_get(reg_it) == M0_BEREG_CAPTURING) {
-                        capturing_res = true;
-                        break;
-                }
-
-                /* Check if region capture is failed. */
-                if (m0_be_reg_state_get(reg_it) == M0_BEREG_FAILED) {
-                        failed_res = true;
-                }
-
-        } m0_tlist_endfor;
-
-        if(!capturing_res) {
-                /**
-                 * This function will be called from callback function, so
-                 * sm_group lock is not required while setting tx state.
-                 */
-                if(failed_res) {
-                        m0_sm_state_set(&tx->bt_sm, M0_BETX_FAILED);
-                }
-                else {
-                        m0_sm_state_set(&tx->bt_sm, M0_BETX_PREPARED);
-                }
-        }
-
-        return;
-}
-
-uint32_t m0_be_tx_state_get(const struct m0_be_tx *tx)
+uint32_t m0_be_tx_state(const struct m0_be_tx *tx)
 {
         return tx->bt_sm.sm_state;
 }
 
-/** @} end group be_trans */
+/** @} end group be_tx */
 
 /*
  *  Local variables:
diff --git a/be/tx.h b/be/tx.h
index 5191c38..5f29365 100644
--- a/be/tx.h
+++ b/be/tx.h
@@ -23,7 +23,7 @@
 #define __MERO_BE_TX_H__
 
 /**
-  @defgroup be (Meta-data) back-end
+  @defgroup be_tx
   @{
  */
 #include "be/be.h"
@@ -51,12 +51,22 @@ M0_INTERNAL void m0_be_tx_fini_cb(struct m0_sm_group *sm_group,
 M0_INTERNAL void m0_tx_req_post(struct m0_sm_group *sm_group,
                                 struct m0_sm_ast *sm_ast);
 
+/**
+ * The function iterates the region list to check if any region capture has
+ * failed.
+ * If any earlier capture is failed, then the current region won't be captured.
+ */
 M0_INTERNAL int m0_be_tx_get_capture_status(void * data);
 
+/**
+ * The function iterates all the region list to check if they are captured
+ * successfully.
+ * This is pre-requisite for transaction to be marked as PREPARED.
+ */
 M0_INTERNAL void m0_be_tx_set_capture_status(void * data);
 
-uint32_t m0_be_tx_state_get(const struct m0_be_tx *tx);
-/** @} end of be group */
+uint32_t m0_be_tx_state(const struct m0_be_tx *tx);
+/** @} end of be_tx group */
 
 /* __MERO_BE_TX_H__ */
 #endif
diff --git a/be/ut/be.c b/be/ut/be.c
index 6184edb..ea5cf51 100644
--- a/be/ut/be.c
+++ b/be/ut/be.c
@@ -57,7 +57,8 @@ extern const char      *log_file;
 static int ts_be_init(void)   /* ts_ for "test suite" */
 {
         int rc = 0;
-        int result;
+        bool result;
+
 
         sprintf(be_cmd, "rm -rf %s", log_file);
         rc = system(be_cmd);
@@ -90,7 +91,7 @@ static int ts_be_init(void)   /* ts_ for "test suite" */
 
         result = m0_be_domain_lookup(&dom, "first", &seg);
 
-        if(result != 0) {
+        if(result == false) {
                 M0_ALLOC_PTR(seg);
                 m0_be_seg_init(seg, &dom, sm_group, 0);
                 m0_be_seg_create(seg, NULL,  "first", NULL);
@@ -102,7 +103,7 @@ static int ts_be_init(void)   /* ts_ for "test suite" */
                         M0_TIME_NEVER);
         m0_sm_group_unlock(sm_group);
 
-        if (m0_be_seg_state_get(seg) == M0_BESEG_FAILED) {
+        if (m0_be_seg_state(seg) == M0_BESEG_FAILED) {
                 rc = -1;
         }
 
@@ -149,9 +150,7 @@ static void test_be_transaction()
                          M0_TIME_NEVER);
 
         m0_sm_group_unlock(sm_group);
-
         m0_be_tx_add_cred(&tx, &reg);
-
         m0_be_tx_prep(&tx);
 
         m0_sm_group_lock(sm_group);
diff --git a/be/ut/handle_store.c b/be/ut/handle_store.c
index 63ed415..9947c97 100644
--- a/be/ut/handle_store.c
+++ b/be/ut/handle_store.c
@@ -96,7 +96,7 @@ static int ts_be_init(void)   /* ts_ for "test suite" */
                         M0_TIME_NEVER);
         m0_sm_group_unlock(sm_group);
 
-        if (m0_be_seg_state_get(seg) == M0_BESEG_FAILED) {
+        if (m0_be_seg_state(seg) == M0_BESEG_FAILED) {
                 rc = -1;
         }
 
-- 
1.8.3.2

