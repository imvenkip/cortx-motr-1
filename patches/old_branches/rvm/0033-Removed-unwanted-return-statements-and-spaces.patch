From 702576557eaaf659ee50516d261031669ca232ec Mon Sep 17 00:00:00 2001
From: Prashant Dhange <prashant_dhange@xyratex.com>
Date: Thu, 10 Jan 2013 06:02:05 -0800
Subject: [PATCH 033/121] Removed unwanted return statements and spaces

---
 be/Makefile.sub          | 12 ++++++------
 be/be.h                  |  2 +-
 be/be_reg.c              | 27 ++++++++++-----------------
 be/be_reg.h              |  2 +-
 be/be_seg.c              |  4 ----
 be/be_tx.c               |  8 ++++----
 be/lib/Makefile.sub      |  4 ++--
 be/lib/be_handle_store.c |  4 ++--
 be/lib/ut/be_kv_store.c  |  2 +-
 be/lib/ut/be_tlist.c     |  4 ++--
 be/rds.h                 | 10 +++++-----
 be/rvm.h                 | 14 +++++++-------
 be/ut/be.c               |  2 +-
 be/ut/be_handle_store.c  |  2 +-
 14 files changed, 43 insertions(+), 54 deletions(-)

diff --git a/be/Makefile.sub b/be/Makefile.sub
index e67e0a9..52793e7 100644
--- a/be/Makefile.sub
+++ b/be/Makefile.sub
@@ -1,7 +1,7 @@
-nobase_mero_include_HEADERS +=  be/be.h                 
+nobase_mero_include_HEADERS +=  be/be.h
 
-mero_libmero_la_SOURCES	    += 	be/be_domain.c          \
-			      	be/be_seg.c             \
-			    	be/be_reg.c             \
-			    	be/be_rvm.c             \
-			    	be/be_tx.c              
+mero_libmero_la_SOURCES	    +=	be/be_domain.c          \
+				be/be_seg.c             \
+				be/be_reg.c             \
+				be/be_rvm.c             \
+				be/be_tx.c
diff --git a/be/be.h b/be/be.h
index 2197bfc..30ad6ee 100644
--- a/be/be.h
+++ b/be/be.h
@@ -214,7 +214,7 @@ struct m0_be_buf;
  */
 //void m0_be_domain_init  (struct m0_be_domain *dom, struct m0_stob *stob,
 //                                      struct m0_stob *log_stob);
-M0_INTERNAL void m0_be_domain_init(struct m0_be_domain *dom, 
+M0_INTERNAL void m0_be_domain_init(struct m0_be_domain *dom,
                                    uint64_t dom_magic);
 
 /**
diff --git a/be/be_reg.c b/be/be_reg.c
index f8569ed..306c83b 100644
--- a/be/be_reg.c
+++ b/be/be_reg.c
@@ -129,7 +129,7 @@ M0_INTERNAL void m0_be_reg_init(struct m0_be_reg **reg_out, struct m0_be_tx *tx,
                                 struct m0_be_seg *seg,  struct m0_be_buf *buf)
 {
         struct m0_be_reg *reg;
-                
+
         /* Asserting on required pointers */
         M0_ASSERT(reg_out != NULL);
         M0_ASSERT(seg != NULL);
@@ -199,8 +199,6 @@ M0_INTERNAL void m0_be_alloc(struct m0_be_reg *reg)
         reg->br_sm_ast.sa_datum = (void *)reg;
 
         m0_be_reg_req_post(reg->br_impl.sm_group, &(reg->br_sm_ast));
-
-        return;
 }
 
 /**
@@ -229,8 +227,6 @@ M0_INTERNAL void m0_be_free(struct m0_be_reg *reg)
         reg->br_sm_ast.sa_datum = (void *)reg;
 
         m0_be_reg_req_post(reg->br_impl.sm_group, &(reg->br_sm_ast));
-
-        return;
 }
 
 /**
@@ -245,7 +241,6 @@ M0_INTERNAL void m0_be_free(struct m0_be_reg *reg)
 M0_INTERNAL void m0_be_prefetch(const struct m0_be_reg *reg)
 {
 
-        return;
 }
 
 
@@ -260,7 +255,6 @@ M0_INTERNAL void m0_be_prefetch(const struct m0_be_reg *reg)
 M0_INTERNAL void m0_be_put(const struct m0_be_reg *reg)
 {
 
-        return;
 }
 
 /**
@@ -299,7 +293,6 @@ M0_INTERNAL void m0_be_reg_capture(struct m0_be_reg *reg)
 
         m0_be_reg_req_post(reg->br_impl.sm_group, &(reg->br_sm_ast));
 
-        return;
 }
 
 /**
@@ -350,13 +343,13 @@ M0_INTERNAL void m0_be_alloc_cb(struct m0_sm_group *sm_group,
         M0_ASSERT(reg != NULL);
 
         if (reg->br_tx != NULL)
-                tid = reg->br_tx->bt_impl.tx_id; 
+                tid = reg->br_tx->bt_impl.tx_id;
 
         reg->br_buf.b_addr = (void *)rds_malloc(reg->br_buf.b_nob,
                                                 tid, &err);
-                                                
 
-        /* Assign domain magic to reg reference magic  to identify references 
+
+        /* Assign domain magic to reg reference magic  to identify references
          * within the domain.
          */
         reg->br_buf.logical_address.magic = reg->br_seg->bs_dom->bd_magic;
@@ -399,7 +392,7 @@ M0_INTERNAL void m0_be_free_cb(struct m0_sm_group *sm_group,
         M0_ASSERT(reg != NULL);
 
         if (reg->br_tx != NULL)
-                tid = reg->br_tx->bt_impl.tx_id; 
+                tid = reg->br_tx->bt_impl.tx_id;
         /*
          * Allocate memory from RDS Heap.
          * Update br_buf to store virtual address.
@@ -432,7 +425,7 @@ M0_INTERNAL void m0_be_reg_capture_cb(struct m0_sm_group *sm_group,
         rvm_return_t ret;
         int result;
         enum m0_be_reg_state reg_st = M0_BEREG_FAILED;
-        
+
 
         /* Asserting on required pointers */
         M0_ASSERT(sm_group != NULL);
@@ -446,7 +439,7 @@ M0_INTERNAL void m0_be_reg_capture_cb(struct m0_sm_group *sm_group,
                 result = reg->br_tx_cbdata.m0_be_tx_pre_cb(
                                         reg->br_tx_cbdata.datum);
                 /**
-                 * Do not perform rvm_set_range on current region if region 
+                 * Do not perform rvm_set_range on current region if region
                  * capture is failed for any previous region
                  */
                 if( result == M0_BETX_PREP_FAILED) {
@@ -461,8 +454,8 @@ M0_INTERNAL void m0_be_reg_capture_cb(struct m0_sm_group *sm_group,
 
         if(RVM_SUCCESS == ret)
                 reg_st = M0_BEREG_CAPTURED;
-                
-                
+
+
 reg_done_exit:
         m0_sm_state_set(&(reg->br_sm), reg_st);
 
@@ -489,7 +482,7 @@ M0_INTERNAL void m0_be_static_reg_capture_buf(uint64_t offset,
         struct m0_be_reg       *reg;
         struct m0_be_buf        buf;
 
-        m0_be_buf_init(&buf, NULL, ubuf->b_nob, 0, 0, 0);       
+        m0_be_buf_init(&buf, NULL, ubuf->b_nob, 0, 0, 0);
 
         buf.b_addr = static_reg_start_addr + offset;
 
diff --git a/be/be_reg.h b/be/be_reg.h
index 23ce54b..2457432 100644
--- a/be/be_reg.h
+++ b/be/be_reg.h
@@ -36,7 +36,7 @@ M0_INTERNAL void m0_be_free_cb(struct m0_sm_group *sm_group,
 
 M0_INTERNAL void m0_be_reg_capture_cb(struct m0_sm_group *sm_group,
                                       struct m0_sm_ast *sm_ast);
-                                  
+
 M0_INTERNAL void m0_be_reg_req_post(struct m0_sm_group *sm_group,
                                     struct m0_sm_ast *sm_ast);
 
diff --git a/be/be_seg.c b/be/be_seg.c
index 24470b1..a6367e9 100644
--- a/be/be_seg.c
+++ b/be/be_seg.c
@@ -258,8 +258,6 @@ M0_INTERNAL void m0_be_seg_open(struct m0_be_seg *seg)
         M0_POST( (seg->bs_sm.sm_state == M0_BESEG_OPENING) ||
                  (seg->bs_sm.sm_state == M0_BESEG_ACTIVE)  ||
                  (seg->bs_sm.sm_state == M0_BESEG_FAILED)  );
-
-        return;
 }
 
 /**
@@ -412,8 +410,6 @@ M0_INTERNAL void m0_be_seg_fail(struct m0_be_seg *seg)
         m0_sm_group_unlock(seg->bs_impl.sm_group);
 
         M0_POST(seg->bs_sm.sm_state == M0_BESEG_FAILED);
-
-        return;
 }
 
 
diff --git a/be/be_tx.c b/be/be_tx.c
index 5348d8d..a8024f8 100644
--- a/be/be_tx.c
+++ b/be/be_tx.c
@@ -210,7 +210,7 @@ M0_INTERNAL void m0_be_tx_prep(struct m0_be_tx *tx)
 
                 /* check reg_it->br_sm.sm_state for region state */
 
-                if (reg_it->br_sm.sm_state != M0_BEREG_INIT && 
+                if (reg_it->br_sm.sm_state != M0_BEREG_INIT &&
                     reg_it->br_sm.sm_state != M0_BEREG_ALLOCATED) {
 
                         M0_TX_SM_STATE_SET(tx, M0_BETX_FAILED);
@@ -482,7 +482,7 @@ M0_INTERNAL void m0_tx_req_post(struct m0_sm_group *sm_group,
 }
 
 /**
- * The function iterates the region list to check if any region capture has 
+ * The function iterates the region list to check if any region capture has
  * failed.
  * If any earlier capture is failed, then the current region won't be captured.
  */
@@ -508,7 +508,7 @@ M0_INTERNAL int m0_be_tx_get_capture_status(void * data)
 }
 
 /**
- * The function iterates all the region list to check if they are captured 
+ * The function iterates all the region list to check if they are captured
  * successfully.
  * This is pre-requisite for transaction to be marked as PREPARED.
  */
@@ -537,7 +537,7 @@ M0_INTERNAL void m0_be_tx_set_capture_status(void * data)
 
         if(!capturing_res) {
                 /**
-                 * This function will be called from callback function, so 
+                 * This function will be called from callback function, so
                  * sm_group lock is not required while setting tx state.
                  */
                 if(failed_res) {
diff --git a/be/lib/Makefile.sub b/be/lib/Makefile.sub
index 67e8ead..8235e87 100644
--- a/be/lib/Makefile.sub
+++ b/be/lib/Makefile.sub
@@ -7,8 +7,8 @@ nobase_mero_include_HEADERS +=  be/lib/be_buf.h         \
 				be/lib/be_handle_store.h
 
 mero_libmero_la_SOURCES	    +=  be/lib/be_buf.c         \
-			    	be/lib/be_list.c        \
-			    	be/lib/be_tlist.c	\
+				be/lib/be_list.c        \
+				be/lib/be_tlist.c	\
 				be/lib/be_kv_store.c	\
 				be/lib/be_helper.c	\
 				be/lib/be_handle_store.c
diff --git a/be/lib/be_handle_store.c b/be/lib/be_handle_store.c
index 497a2b1..2dd67cb 100644
--- a/be/lib/be_handle_store.c
+++ b/be/lib/be_handle_store.c
@@ -32,7 +32,7 @@
  * m0_be_hs_get()            - Get handle store reference (m0_uint128) from RVM
  */
 
-static struct m0_be_seg *seg = NULL; 
+static struct m0_be_seg *seg = NULL;
 
 M0_INTERNAL void m0_be_hs_init(struct m0_be_seg *segin)
 {
@@ -61,7 +61,7 @@ M0_INTERNAL void m0_be_hs_update(uint64_t index, struct m0_uint128 *h_addr)
 
         m0_be_buf_init(&buf, NULL, sizeof(struct m0_uint128), 0, 0, 0);
         offset = index * sizeof(struct m0_uint128);
-        m0_be_static_reg_capture_buf(offset, &buf, seg, &tx); 
+        m0_be_static_reg_capture_buf(offset, &buf, seg, &tx);
 
         m0_sm_group_lock(tx.bt_impl.sm_group);
         m0_sm_timedwait(&tx.bt_sm,
diff --git a/be/lib/ut/be_kv_store.c b/be/lib/ut/be_kv_store.c
index 41f5173..23b9f1f 100644
--- a/be/lib/ut/be_kv_store.c
+++ b/be/lib/ut/be_kv_store.c
@@ -205,7 +205,7 @@ int main(int argc, char *argv[]) {
                 printf("Usage:./be_kv_store_ut CREATE ./be_kv_store RECOVER\n");
                 return 0;
         }
-                
+
         strcpy(mode, argv[1]);
 
         if(strncmp(mode, "CREATE", 6) == 0)
diff --git a/be/lib/ut/be_tlist.c b/be/lib/ut/be_tlist.c
index 420dc76..7462bb7 100644
--- a/be/lib/ut/be_tlist.c
+++ b/be/lib/ut/be_tlist.c
@@ -61,7 +61,7 @@ void alloc_memory_tlist_rvm()
 
         M0_ALLOC_PTR(tx);
         M0_ASSERT(tx != NULL);
-       
+
         m0_be_tx_init(tx, &dom, 0);
         M0_BE_WAIT(tx->bt_impl.sm_group, &tx->bt_sm,
                    (1 << M0_BETX_INIT) | (1 << M0_BETX_FAILED));
@@ -165,7 +165,7 @@ void test_add_be_tlist(struct foo **new_obj, int incoming_key,
                         (1 << M0_BETX_OPEN) | (1 << M0_BETX_FAILED),
                         M0_TIME_NEVER);
         m0_sm_group_unlock(tx.bt_impl.sm_group);
-        
+
         m0_be_buf_init(&buf, NULL, sizeof(struct foo), 0, 0, 0);
         m0_be_reg_init(&reg, &tx, seg, &buf);
 
diff --git a/be/rds.h b/be/rds.h
index 494c1b0..440f2a7 100644
--- a/be/rds.h
+++ b/be/rds.h
@@ -43,14 +43,14 @@ Coda are listed in the file CREDITS.
 /* Function definitions */
 
 extern int rds_zap_heap(
-      char 	            *DevName,
+      char                 *DevName,
       rvm_offset_t          DevLength,
-      char                  *startAddr,
+      char                 *startAddr,
       rvm_length_t          staticLength,
       rvm_length_t          heapLength,
       unsigned long         nlists,
       unsigned long         chunkSize,
-      int                   *err
+      int                  *err
      );
 
 extern int rds_init_heap(
@@ -139,7 +139,7 @@ typedef struct {
 
 extern int rds_print_stats();
 extern int rds_clear_stats(int *err);
-extern int rds_get_stats(rds_stats_t *stats);  
+extern int rds_get_stats(rds_stats_t *stats);
 
 extern int rds_tracing;
 extern FILE *rds_tracing_file;
@@ -151,7 +151,7 @@ extern int rds_trace_dump_heap();
   if (rds_tracing && rds_tracing_file) { \
     fprintf(rds_tracing_file, format, ## a);\
     fflush(rds_tracing_file); }\
-} while (0) ;                            
+} while (0) ;
 
 
 #endif /* __MERO_BE_RDS_H__ */
diff --git a/be/rvm.h b/be/rvm.h
index 9e00304..1b2e24b 100644
--- a/be/rvm.h
+++ b/be/rvm.h
@@ -22,7 +22,7 @@ Coda are listed in the file CREDITS.
 *
 */
 
-#pragma once 
+#pragma once
 
 #ifndef __MERO_BE_RVM_H__
 #define __MERO_BE_RVM_H__
@@ -67,7 +67,7 @@ typedef enum { rvm_false = 0, rvm_true = 1 } rvm_bool_t;
     codes placed in the first field of each
     structure instance to identify the object.
 */
-typedef enum 
+typedef enum
     {
     rvm_first_struct_id = 39,           /* internal use only */
 
@@ -76,7 +76,7 @@ typedef enum
     rvm_tid_id,                         /* identifier for rvm_tid's */
     rvm_statistics_id,                  /* identifier for rvm_statistics rec's */
     rvm_last_struct_id                  /* internal use only */
-    } 
+    }
 rvm_struct_id_t;
 
 /*  Transaction mode codes: rvm_mode_t */
@@ -146,7 +146,7 @@ typedef unsigned long rvm_length_t;
 /*  region offset descriptor: rvm_offset_t supports 64 bit unsigned integers
     struct unecessary if machine has 64-bit ops */
 
-typedef struct                                           
+typedef struct
     {                                   /* INTERNAL FIELDS static */
     rvm_length_t    high;               /* private */
     rvm_length_t    low;                /* private */
@@ -168,7 +168,7 @@ rvm_offset_t;
 
 /* offset and length conversion macros */
 
-/* return low-order bits of offset x as length 
+/* return low-order bits of offset x as length
    -- "low-order bits" are the lowest numerically valued bits
    of the same size as rvm_length_t */
 #define RVM_OFFSET_TO_LENGTH(x) ((x).low)
@@ -185,7 +185,7 @@ rvm_offset_t;
 /* rvm_offset_t and rvm_length_t arithmetic support */
 
 /* add rvm_offset to rvm_offset; returns result (x+y)
-   implemented as function call -- or simple add if 
+   implemented as function call -- or simple add if
    machine has 64-bit integer operations */
 #define RVM_ADD_OFFSETS(x,y) \
     rvm_add_offsets(&(x),&(y))
@@ -248,7 +248,7 @@ rvm_offset_t;
 
 /* return address x rounded up to next page boundary */
 #define RVM_ROUND_ADDR_UP_TO_PAGE_SIZE(x)  ((char *)( \
-    ((rvm_length_t)(x)+rvm_page_size()-1) & rvm_page_mask()))             
+    ((rvm_length_t)(x)+rvm_page_size()-1) & rvm_page_mask()))
 
 /* return address x rounded down to page boundary */
 #define RVM_ROUND_ADDR_DOWN_TO_PAGE_SIZE(x)  ((char *)( \
diff --git a/be/ut/be.c b/be/ut/be.c
index ee238a3..32d09bc 100644
--- a/be/ut/be.c
+++ b/be/ut/be.c
@@ -71,7 +71,7 @@ int main()
         printf("\nSegment is created\n");
 
         /**
-         * @todo :Implement UT to test segment open 
+         * @todo :Implement UT to test segment open
          */
 
         printf("\nWaiting for segment to be active\n");
diff --git a/be/ut/be_handle_store.c b/be/ut/be_handle_store.c
index 359c9d8..dbf20bb 100644
--- a/be/ut/be_handle_store.c
+++ b/be/ut/be_handle_store.c
@@ -96,7 +96,7 @@ int main(int argc, char *argv[])
         m0_be_hs_init(seg);
 
         if (!run_mode) {
-                for (i = 0; i < 10; i++) { 
+                for (i = 0; i < 10; i++) {
                         struct m0_uint128 kvstore;
                         kvstore.u_hi = 1 + i;
                         kvstore.u_lo = 88779911231 + i;
-- 
1.8.3.2

