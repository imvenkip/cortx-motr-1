From 58d79c50f41cdd0498f36330cdea9a5bd253b30c Mon Sep 17 00:00:00 2001
From: Zishan Shaikh <zishan_shaikh@xyratex.com>
Date: Thu, 25 Apr 2013 04:12:52 -0700
Subject: [PATCH 077/121] Incorporated comments from RB request 1371

---
 be/be.h              |   6 +-
 be/be_buf.c          |  13 +-
 be/be_init.c         |   7 +-
 be/be_private.h      |  43 +++-
 be/domain.c          | 149 +++++++------
 be/domain.h          |   5 +-
 be/handle_store.c    |   4 +-
 be/handler.c         |  27 +--
 be/helper.c          | 159 ++++++--------
 be/helper.h          |  47 ++--
 be/kv_store.c        | 239 ++++++++++-----------
 be/kv_store.h        | 114 +++++++---
 be/reg.c             |  43 ++--
 be/seg.c             |  61 ++----
 be/tx.c              |  53 ++---
 be/tx.h              |   2 +-
 be/ut/Makefile.sub   |   7 +-
 be/ut/be.c           |   9 +-
 be/ut/handle_store.c |   3 +-
 be/ut/kv_store.c     | 591 ++++++++++++++++++++++++++++++++++++++-------------
 be/ut/kv_store_ub.c  | 400 ----------------------------------
 cob/cob.c            |  43 ++--
 cob/cob.h            |   5 +-
 cob/ut/cob.c         |   8 +-
 utils/ut_main.c      |   4 +-
 25 files changed, 963 insertions(+), 1079 deletions(-)
 delete mode 100644 be/ut/kv_store_ub.c

diff --git a/be/be.h b/be/be.h
index 579c494..091c0bc 100644
--- a/be/be.h
+++ b/be/be.h
@@ -202,8 +202,7 @@ M0_INTERNAL void m0_be_domain_init(struct m0_be_domain *dom);
 /**
  * Finalises the in-memory part of domain structure.
  *
- * @pre M0_IN(m0_be_seg_state(dom->bd_data), (M0_BESEG_CLOSED,
- *                                                M0_BESEG_FAILED))
+ * @pre M0_IN(m0_be_seg_state(dom->bd_data), (M0_BESEG_INIT, M0_BESEG_FAILED))
  */
 M0_INTERNAL void m0_be_domain_fini(struct m0_be_domain *dom);
 
@@ -220,8 +219,7 @@ M0_INTERNAL void m0_be_domain_fini(struct m0_be_domain *dom);
  */
 M0_INTERNAL void m0_be_domain_create(struct m0_be_domain *dom,
                                      struct m0_stob *stob,
-                                     struct m0_stob *log_stob,
-                                     uint64_t dom_magic);
+                                     struct m0_stob *log_stob);
 /**
  * Searches a domain for the existing segment with a given name.
  *
diff --git a/be/be_buf.c b/be/be_buf.c
index 22f4c49..d828747 100644
--- a/be/be_buf.c
+++ b/be/be_buf.c
@@ -29,11 +29,18 @@ M0_INTERNAL void m0_be_buf_init(struct m0_be_buf *buf, void *data, uint32_t nob,
                                 uint64_t segment_id, uint64_t segment_offset,
                                 void *virtual_addr)
 {
+        struct m0_uint128       *segid_offset;
+        struct m0_be_reference  *ref;
+
         buf->b_addr = data;
         buf->b_nob  = nob;
-        buf->b_logical_address.be_segid_offset.u_hi = segment_id;
-        buf->b_logical_address.be_segid_offset.u_lo = segment_offset;
-        buf->b_logical_address.be_virtual_address   = virtual_addr;
+
+        ref                       = &buf->b_logical_address;
+        ref->be_virtual_address   = virtual_addr;
+
+        segid_offset       = &ref->be_segid_offset;
+        segid_offset->u_hi = segment_id;
+        segid_offset->u_lo = segment_offset;
 }
 
 /** @} end of be_buf group */
diff --git a/be/be_init.c b/be/be_init.c
index 342e56d..d130fcb 100644
--- a/be/be_init.c
+++ b/be/be_init.c
@@ -20,6 +20,7 @@
 #include "be/be.h"
 #include "be/be_init.h"
 #include "be/be_rvm.h"
+#include "be/be_private.h"
 
 /**
   @addtogroup be
@@ -28,14 +29,16 @@
 
 M0_INTERNAL int m0_be_init(void)
 {
-        /*m0_threads_init();*/
+        /* Initialise bob types for segment, regions and transactions */
+        m0_bob_type_tlist_init(&m0_be_seg_type_bob, &m0_be_seg_tl);
+        m0_bob_type_tlist_init(&m0_be_reg_type_bob, &m0_be_reg_tl);
+        m0_bob_type_tlist_init(&m0_be_tx_type_bob,  &m0_be_tx_tl);
         m0_be_rvm_init();
         return 0;
 }
 
 M0_INTERNAL void m0_be_fini(void)
 {
-        m0_threads_fini();
 }
 
 /** @} end group be */
diff --git a/be/be_private.h b/be/be_private.h
index 668a039..293345b 100644
--- a/be/be_private.h
+++ b/be/be_private.h
@@ -23,35 +23,56 @@
 #define __MERO_BE_BE_PRIVATE_H__
 
 /**
-  @defgroup be
+  @defgroup be_private
   @{
 */
 
 #include "mero/magic.h"
+#include "lib/bob.h"
 
+/** List of segments in domain. */
 M0_TL_DESCR_DEFINE(m0_be_seg, "m0_be_seg", static, struct m0_be_seg, bs_linkage,
                    bs_magic, M0_BE_SEG_MAGIC, M0_BE_SEG_HDR_MAGIC);
 M0_TL_DEFINE(m0_be_seg, static inline, struct m0_be_seg);
 
-M0_TL_DESCR_DEFINE(m0_be_tx, "m0_be_tx", static, struct m0_be_tx, bt_linkage,
-                   bt_magic, M0_BE_TX_MAGIC, M0_BE_TX_HDR_MAGIC);
-M0_TL_DEFINE(m0_be_tx, static inline, struct m0_be_tx);
-
+/** List of regions in domain. */
 M0_TL_DESCR_DEFINE(m0_be_reg, "m0_be_reg", static, struct m0_be_reg, br_linkage,
                    br_magic, M0_BE_REG_MAGIC, M0_BE_REG_HDR_MAGIC);
 M0_TL_DEFINE(m0_be_reg, static inline, struct m0_be_reg);
 
-M0_TL_DESCR_DEFINE(m0_be_runq, "m0_be_runq", static, struct m0_be_sm_obj, bso_linkage,
-                   bso_magic, M0_BE_DOMAIN_MAGIC, M0_BE_DOMAIN_RUNQ_MAGIC);
+/** List of transactions in domain. */
+M0_TL_DESCR_DEFINE(m0_be_tx, "m0_be_tx", static, struct m0_be_tx, bt_linkage,
+                   bt_magic, M0_BE_TX_MAGIC, M0_BE_TX_HDR_MAGIC);
+M0_TL_DEFINE(m0_be_tx, static inline, struct m0_be_tx);
 
+/** Run queue for BE handler thread. */
+M0_TL_DESCR_DEFINE(m0_be_runq, "m0_be_runq", static, struct m0_be_sm_obj,
+                   bso_linkage, bso_magic, M0_BE_DOMAIN_MAGIC,
+                   M0_BE_DOMAIN_RUNQ_MAGIC);
 M0_TL_DEFINE(m0_be_runq, static, struct m0_be_sm_obj);
 
-M0_TL_DESCR_DEFINE(m0_be_waitq, "m0_be_waitq", static, struct m0_be_sm_obj, bso_linkage,
-                   bso_magic, M0_BE_DOMAIN_MAGIC, M0_BE_DOMAIN_WAITQ_MAGIC);
-
+/** Wait queue for BE handler thread. */
+M0_TL_DESCR_DEFINE(m0_be_waitq, "m0_be_waitq", static, struct m0_be_sm_obj,
+                   bso_linkage, bso_magic, M0_BE_DOMAIN_MAGIC,
+                   M0_BE_DOMAIN_WAITQ_MAGIC);
 M0_TL_DEFINE(m0_be_waitq, static, struct m0_be_sm_obj);
 
-/** @} end of be */
+/**
+ * Bob type for segment.
+ */
+M0_INTERNAL struct m0_bob_type m0_be_seg_type_bob;
+
+/**
+ * Bob type for regions.
+ */
+M0_INTERNAL struct m0_bob_type m0_be_reg_type_bob;
+
+/**
+ * Bob type for transactions.
+ */
+M0_INTERNAL struct m0_bob_type m0_be_tx_type_bob;
+
+/** @} end of be_private */
 
 /* __MERO_BE_BE_PRIVATE_H__ */
 #endif
diff --git a/be/domain.c b/be/domain.c
index 860a62b..f3dae88 100644
--- a/be/domain.c
+++ b/be/domain.c
@@ -19,7 +19,6 @@
 
 #undef M0_TRACE_SUBSYSTEM
 #define M0_TRACE_SUBSYSTEM M0_TRACE_SUBSYS_BE
-#include <string.h>
 
 #include "lib/trace.h"
 #include "lib/memory.h"
@@ -27,6 +26,7 @@
 #include "be/be.h"
 #include "be/domain.h"
 #include "be/seg.h"
+#include "be/tx.h"
 #include "be/be_private.h"
 #include "be/be_init.h"
 #include "be/kv_store.h"
@@ -42,30 +42,42 @@
 extern struct  m0_tl    be_sm_runq;
 extern struct  m0_tl    be_sm_waitq;
 
+/**
+ * Bob type for domain.
+ */
+M0_INTERNAL struct m0_bob_type m0_be_domain_type_bob = {
+	.bt_name         = "BE_DOMAIN_BOB",
+	.bt_magix        = M0_BE_DOMAIN_MAGIC,
+	.bt_magix_offset = offsetof(struct m0_be_domain, bd_magic)
+};
+M0_BOB_DEFINE(M0_INTERNAL, &m0_be_domain_type_bob, m0_be_domain);
+
 M0_INTERNAL void m0_be_domain_create(struct m0_be_domain *dom,
-                                     struct m0_stob *stob,
-                                     struct m0_stob *log_stob,
-                                     uint64_t dom_magic)
+                                     struct m0_stob      *stob,
+                                     struct m0_stob      *log_stob)
 {
         M0_ENTRY("domain: %p", dom);
         M0_ASSERT(dom != NULL);
 
-        dom->bd_data.bs_stob    = stob;
-        dom->bd_impl.log_stob   = log_stob;
-        dom->bd_magic           = dom_magic;
+        if (stob != NULL)
+                m0_stob_get(stob);
 
-        M0_POST(m0_be_domain_invariant(dom));
+        if (log_stob != NULL)
+                m0_stob_get(log_stob);
+
+        dom->bd_data.bs_stob  = stob;
+        dom->bd_impl.log_stob = log_stob;
+        dom->bd_magic         = M0_BE_DOMAIN_MAGIC;
         M0_LEAVE();
 }
 
 M0_INTERNAL void m0_be_domain_init(struct m0_be_domain *dom)
 {
-        int          result;
+        int result;
 
         M0_ENTRY("domain: %p", dom);
-        M0_ASSERT(m0_be_domain_invariant(dom));
-        m0_threads_init();
 
+        m0_be_domain_bob_init(dom);
         m0_sm_group_init(&dom->bd_impl.sm_group);
 
         /* Start be_handler thread. */
@@ -73,93 +85,85 @@ M0_INTERNAL void m0_be_domain_init(struct m0_be_domain *dom)
                                 &m0_be_handler_thread, &dom->bd_impl.sm_group,
                                 "Backend handler thread");
         if (result != 0) {
-                m0_thread_fini(&dom->bd_impl.th);
+                M0_LOG(M0_FATAL, "Failed to create BE handler thread!");
+                return;
         }
 
+        /* Initialise named segment. */
         m0_be_seg_init(&dom->bd_data, dom, &dom->bd_impl.sm_group, 0);
 
-        /**
-         * @todo - Need to decide if m0_be_seg_init should be called
-         * instead of M0_BESEG_CLOSED state assignment.
-         **/
-        m0_be_seg_state_change(&dom->bd_data, M0_BESEG_CLOSED);
-
         m0_be_seg_tlist_init(&dom->bd_seg);
         m0_be_tx_tlist_init(&dom->bd_tx);
 
         m0_be_runq_tlist_init(&be_sm_runq);
         m0_be_waitq_tlist_init(&be_sm_waitq);
 
-        /**
-         * This is just temporary, when we integrate backend-domain with mero
-         * this needs to be removed.
-         */
-        m0_be_init();
         M0_POST(m0_be_domain_invariant(dom));
-        M0_LOG(M0_INFO, "Domain initialised, dom = %p", dom);
-        M0_LEAVE();
+        M0_LEAVE("Domain initialised, dom = %p", dom);
 }
 
 M0_INTERNAL bool m0_be_domain_lookup(struct m0_be_domain *dom, const char *name,
                                      struct m0_be_seg **out)
 {
         struct m0_be_seg        *seg;
-        bool                     found = false;
 
         M0_ENTRY("domain: %p, name: %p", dom, name);
         M0_ASSERT(m0_be_domain_invariant(dom));
-        M0_PRE(m0_be_seg_state(&dom->bd_data) == M0_BESEG_ACTIVE);
+        M0_PRE(m0_be_domain_state(dom) == M0_BESEG_INIT);
 
-        seg = m0_be_domain_get_seg(dom, name);
+        *out = seg = m0_be_domain_get_seg(dom, name);
 
-        if (seg) {
-                if (m0_be_seg_state(seg) == M0_BESEG_CLOSED) {
-                        m0_be_seg_open(seg);
-                        found = true;
-                } else if (m0_be_seg_state(seg) == M0_BESEG_ACTIVE) {
-                        found = true;
-                }
-        } else {
-                found = false;
-        }
+        if (seg != NULL && m0_be_seg_state(seg) == M0_BESEG_CLOSED)
+                m0_be_seg_open(seg);
 
-        *out = seg;
         M0_LEAVE("seg : %p", *out);
-        return found;
+        return seg != NULL;
 }
 
 M0_INTERNAL void m0_be_domain_fini(struct m0_be_domain *dom)
 {
         struct m0_be_seg         *seg_it;
         struct m0_be_tx          *tx_it;
+        struct m0_be_domain_impl *bd_impl;
+        bool                     *handler_flag;
 
         M0_ENTRY("domain: %p", dom);
         M0_ASSERT(m0_be_domain_invariant(dom));
-        M0_PRE(M0_IN(m0_be_seg_state(&dom->bd_data), (M0_BESEG_CLOSED,
-                                                      M0_BESEG_FAILED)));
+        M0_PRE(M0_IN(m0_be_domain_state(dom), (M0_BESEG_INIT,
+                                               M0_BESEG_FAILED)));
 
-        for_each_tx_in_domain(tx_it, dom)
+        bd_impl      = &dom->bd_impl;
+        handler_flag = &bd_impl->th_status_flag;
+
+        for_each_tx_in_domain(tx_it, dom) {
+                M0_ASSERT(M0_IN(m0_be_tx_state(tx_it), (M0_BETX_CLOSED,
+                                                        M0_BETX_FAILED)));
                 m0_be_tx_tlink_del_fini(tx_it);
-        end_for_each_tx_in_domain
+        } end_for_each_tx_in_domain;
 
-        for_each_seg_in_domain(seg_it, dom)
+        for_each_seg_in_domain(seg_it, dom) {
+                M0_ASSERT(M0_IN(m0_be_seg_state(seg_it), (M0_BESEG_CLOSED,
+                                                          M0_BESEG_FAILED)));
                 m0_be_seg_tlink_del_fini(seg_it);
                 m0_be_seg_fini(seg_it);
-        end_for_each_seg_in_domain
+        } end_for_each_seg_in_domain;
 
         m0_be_seg_tlist_fini(&dom->bd_seg);
         m0_be_tx_tlist_fini(&dom->bd_tx);
-        m0_stob_fini(dom->bd_impl.log_stob);
+
+        if (dom->bd_impl.log_stob != NULL)
+                m0_stob_put(bd_impl->log_stob);
+        if (dom->bd_data.bs_stob  != NULL)
+                m0_stob_put(dom->bd_data.bs_stob);
 
         /* Fini be_handler_thread */
-        dom->bd_impl.th_status_flag = false;
-        m0_clink_signal(&dom->bd_impl.sm_group.s_clink);
-        m0_thread_join(&dom->bd_impl.th);
-        m0_thread_fini(&dom->bd_impl.th);
+        *handler_flag = false;
+        m0_clink_signal(&bd_impl->sm_group.s_clink);
+        m0_thread_join(&bd_impl->th);
+        m0_thread_fini(&bd_impl->th);
 
         M0_POST(m0_be_domain_invariant(dom));
-        M0_LOG(M0_INFO, "Domain finalised, dom = %p", dom);
-        M0_LEAVE();
+        M0_LEAVE("Domain finalised, dom = %p", dom);
 }
 
 M0_INTERNAL void m0_be_domain_seg_restore(struct m0_be_domain *dom,
@@ -167,15 +171,15 @@ M0_INTERNAL void m0_be_domain_seg_restore(struct m0_be_domain *dom,
                                           struct m0_be_seg    *seg)
 {
         struct  m0_stob_domain   *stob_dom;
-        struct  m0_stob_id        stob_id = {{0, 1}}; /* Hardcoded for now. */
         struct m0_be_seg         *seg_rec;
+        struct  m0_stob_id        stob_id = {{0, 1}}; /* Hardcoded for now. */
         int                       result;
         bool                      stob_directio = false;
 
         M0_ENTRY("domain: %p, seg: %p", dom, seg);
         M0_ASSERT(m0_be_domain_invariant(dom));
 
-        M0_PRE(m0_be_seg_state(&dom->bd_data) == M0_BESEG_ACTIVE);
+        M0_PRE(m0_be_domain_state(dom) == M0_BESEG_INIT);
 
         seg_rec = m0_be_domain_get_seg(dom, name);
 
@@ -202,9 +206,9 @@ M0_INTERNAL void m0_be_domain_seg_restore(struct m0_be_domain *dom,
                 M0_ASSERT(result == 0);
 
                 result = m0_stob_create(seg->bs_stob, NULL);
-                strncpy(seg->bs_impl.segment_name, name,
-                        sizeof(seg->bs_impl.segment_name));
 
+                strcpy(seg->bs_impl.segment_name, "\0");
+                strncat(seg->bs_impl.segment_name, name, strlen(name));
                 seg->bs_rvm.seg_stob = seg->bs_stob;
                 m0_be_seg_open(seg);
 
@@ -225,27 +229,48 @@ M0_INTERNAL bool m0_be_domain_invariant(const struct m0_be_domain *dom)
 {
         struct m0_sm_group      *sm_group;
         struct m0_be_domain     *sdom;
+        struct m0_be_seg        *seg_it;
+        struct m0_be_tx         *tx_it;
 
         sdom     = (struct m0_be_domain *)dom;
         sm_group = m0_be_domain_sm_group(sdom);
+        M0_PRE(!m0_mutex_is_locked(&sm_group->s_lock));
+
+        /* Check named segment is sane. */
+        M0_ASSERT(m0_be_seg_invariant(&dom->bd_data));
 
-        return  dom != NULL && dom->bd_magic == M0_BE_DOMAIN_MAGIC;
+        /* Check all segments in the domain are sane. */
+        for_each_seg_in_domain(seg_it, sdom) {
+                M0_ASSERT(m0_be_seg_invariant(seg_it));
+        } end_for_each_seg_in_domain;
+
+        /* Check all transactions in the domain are sane. */
+        for_each_tx_in_domain(tx_it, sdom) {
+                M0_ASSERT(m0_be_tx_invariant(tx_it));
+        } end_for_each_tx_in_domain;
+
+        return  dom != NULL && m0_be_domain_bob_check(dom);
 }
 
 M0_INTERNAL struct m0_be_seg *m0_be_domain_get_seg(struct m0_be_domain *dom,
                                                    const char *name)
 {
-        struct m0_be_seg        *seg_it = NULL;
+        struct m0_be_seg        *seg_it;
 
-        for_each_seg_in_domain(seg_it, dom)
+        for_each_seg_in_domain(seg_it, dom) {
                 if (strcmp(name, seg_it->bs_impl.segment_name) == 0) {
-                        return seg_it;
+                        break;
                 }
-        end_for_each_seg_in_domain
+        } end_for_each_seg_in_domain;
 
         return seg_it;
 }
 
+M0_INTERNAL uint32_t m0_be_domain_state(const struct m0_be_domain *dom)
+{
+        return m0_be_seg_state(&dom->bd_data);
+}
+
 #undef M0_TRACE_SUBSYSTEM
 /** @} end group be_domain */
 
diff --git a/be/domain.h b/be/domain.h
index 1480c8f..5837080 100644
--- a/be/domain.h
+++ b/be/domain.h
@@ -32,12 +32,12 @@
 #define for_each_seg_in_domain(seg_it, dom) \
         m0_tl_for(m0_be_seg, &dom->bd_seg, seg_it) {
 
-#define end_for_each_seg_in_domain } m0_tl_endfor;
+#define end_for_each_seg_in_domain } m0_tl_endfor
 
 #define for_each_tx_in_domain(tx_it, dom) \
         m0_tl_for(m0_be_tx, &dom->bd_tx, tx_it) {
 
-#define end_for_each_tx_in_domain } m0_tl_endfor;
+#define end_for_each_tx_in_domain } m0_tl_endfor
 
 /**
  * Helper function for domain to get segment from domain's segment list
@@ -57,6 +57,7 @@ struct m0_sm_group *m0_be_domain_sm_group(struct m0_be_domain *dom);
 
 M0_INTERNAL bool m0_be_domain_invariant(const struct m0_be_domain *dom);
 
+M0_INTERNAL uint32_t m0_be_domain_state(const struct m0_be_domain *dom);
 /** @} end of be_domain group */
 
 /* __MERO_BE_DOMAIN_H__ */
diff --git a/be/handle_store.c b/be/handle_store.c
index 4c2e1cb..69bd42f 100644
--- a/be/handle_store.c
+++ b/be/handle_store.c
@@ -86,8 +86,8 @@ M0_INTERNAL void m0_be_hs_update(struct m0_be_hs_opdata *bh_opdata)
         if (m0_be_tx_state(tx) == M0_BETX_FAILED)
                 goto hs_exit;
 
-        elem = (struct m0_uint128 *) m0_be_static_reg_get_handle_addr(seg,
-                                                                      offset);
+        elem = (struct m0_uint128 *)m0_be_static_reg_get_handle_addr(seg,
+                                                                     offset);
         *elem              = *h_addr;
         bh_opdata->bho_tx  = tx;
         m0_be_tx_done(tx);
diff --git a/be/handler.c b/be/handler.c
index 1170801..7c21985 100644
--- a/be/handler.c
+++ b/be/handler.c
@@ -24,7 +24,6 @@
 #include "be/be.h"
 #include "be/be_private.h"
 #include "be/handler.h"
-#include <stdio.h>
 
 /**
   @addtogroup be_handler
@@ -61,7 +60,7 @@ M0_INTERNAL void enqueue_cb(struct m0_be_sm_obj *be_sm_obj, int type)
                         m0_be_waitq_tlink_init(be_sm_obj);
                         is_empty = m0_be_waitq_tlist_is_empty(&be_sm_waitq);
 
-                        if (is_empty == true)
+                        if (is_empty)
                                 m0_be_waitq_tlist_add(&be_sm_waitq, be_sm_obj);
                         else
                                 m0_be_waitq_tlist_add_tail(&be_sm_waitq,
@@ -72,16 +71,15 @@ M0_INTERNAL void enqueue_cb(struct m0_be_sm_obj *be_sm_obj, int type)
 
 M0_INTERNAL struct m0_be_sm_obj *m0_sm_dequeue_obj(struct m0_sm_group *sm_group)
 {
-        struct m0_be_sm_obj  *be_sm_obj = NULL;
-        void                 *scan      = NULL;
+        struct m0_be_sm_obj  *be_sm_obj;
 
         m0_sm_group_lock(sm_group);
 
         if (m0_be_runq_tlist_is_empty(&be_sm_runq)) {
-                m0_tl_for(m0_be_waitq, &be_sm_waitq, scan) {
-                        if (scan == NULL)
+                m0_tl_for(m0_be_waitq, &be_sm_waitq, be_sm_obj) {
+                        if (be_sm_obj == NULL)
                                 break;
-                        be_sm_obj = (struct m0_be_sm_obj *)scan;
+                        /*be_sm_obj = (struct m0_be_sm_obj *)scan;*/
                         m0_be_waitq_tlink_del_fini(be_sm_obj);
 
                         M0_ASSERT(!m0_be_waitq_tlink_is_in(be_sm_obj));
@@ -90,8 +88,6 @@ M0_INTERNAL struct m0_be_sm_obj *m0_sm_dequeue_obj(struct m0_sm_group *sm_group)
                 } m0_tl_endfor;
         }
 
-        be_sm_obj  = NULL;
-        scan       = NULL;
         be_sm_obj  = m0_be_runq_tlist_head(&be_sm_runq);
         if (be_sm_obj != NULL)
                 m0_be_runq_tlink_del_fini(be_sm_obj);
@@ -105,8 +101,8 @@ M0_INTERNAL void m0_sm_enqueue_post(struct m0_sm_group *sm_group, void *cb_data,
                                     void (*obj_cb)(void *cb_data))
 {
         struct m0_be_sm_obj *be_sm_obj;
-        M0_ALLOC_PTR(be_sm_obj);
 
+        M0_ALLOC_PTR(be_sm_obj);
         M0_ASSERT(be_sm_obj != NULL);
 
         m0_sm_group_lock(sm_group);
@@ -124,16 +120,11 @@ M0_INTERNAL void m0_be_handler_thread(struct m0_sm_group *sm_group)
 {
         struct m0_be_sm_obj      *be_sm_obj;
         struct m0_be_domain_impl *bd_impl;
-        bool                     *thread_running;
-
-        bd_impl        = (struct m0_be_domain_impl *)
-                          container_of(sm_group, struct m0_be_domain_impl,
-                                       sm_group);
 
-        thread_running  = &bd_impl->th_status_flag;
-        *thread_running = true;
+        bd_impl = container_of(sm_group, struct m0_be_domain_impl, sm_group);
+        bd_impl->th_status_flag = true;
 
-        while(*thread_running) {
+        while(bd_impl->th_status_flag) {
                 be_sm_obj = NULL;
                 m0_chan_wait(&sm_group->s_clink);
                 be_sm_obj = m0_sm_dequeue_obj(sm_group);
diff --git a/be/helper.c b/be/helper.c
index 7e2a32c..e8ebfc5 100644
--- a/be/helper.c
+++ b/be/helper.c
@@ -19,47 +19,35 @@
  */
 
 /**
-   @addtogroup helper Helper Routines
+   @addtogroup be_helper BE Helper Routines
    @{
  */
 
-#undef M0_TRACE_SUBSYSTEM
-#define M0_TRACE_SUBSYSTEM M0_TRACE_SUBSYS_BE
-#include "lib/trace.h"
+#include "lib/errno.h"
 #include "be/helper.h"
 #include "be/seg.h"
 #include "be/kv_store.h"
 #include <stdio.h>
 #include <stdlib.h>
 
+/**
+  Segment name used for kv_store objects.
+ */
+const char BE_KV_SEG_NAME[] = "kv_store";
+
 M0_INTERNAL void m0_be_ks_init_domain(struct m0_be_domain  **out_dom)
 {
         struct m0_be_domain  *dom;
-        struct m0_sm_group   *sm_group;
-
-        M0_ENTRY();
 
         M0_ALLOC_PTR(dom);
         M0_ASSERT(dom != NULL);
 
         if (*out_dom == NULL) {
-                m0_be_domain_create(dom, NULL, NULL, M0_BE_DOMAIN_MAGIC);
+                m0_be_domain_create(dom, NULL, NULL);
         }
 
-        /*
-         * Initialise the domain with some magic.
-         * For now, we use M0_BE_DOMAIN_MAGIC
-         */
         m0_be_domain_init(dom);
-
-        sm_group = m0_be_domain_sm_group(dom);
-
-        m0_sm_group_lock(sm_group);
-        m0_sm_state_set(&dom->bd_data.bs_sm, M0_BESEG_ACTIVE);
-        m0_sm_group_unlock(sm_group);
-
         *out_dom = dom;
-        M0_LEAVE();
 }
 M0_EXPORTED(m0_be_ks_init_domain);
 
@@ -70,7 +58,6 @@ M0_INTERNAL void *m0_be_ks_obj_malloc(struct m0_be_reg        *obj_reg,
         void                    *obj;
         struct m0_sm_group      *sm_group;
 
-        M0_ENTRY("obj_reg: %p", obj_reg);
         M0_PRE(obj_reg->br_sm.sm_state == M0_BEREG_INIT);
 
         M0_ASSERT(obj_reg != NULL);
@@ -92,7 +79,6 @@ M0_INTERNAL void *m0_be_ks_obj_malloc(struct m0_be_reg        *obj_reg,
         *obj_ref = &obj_reg->br_buf.b_logical_address;
 
 exit_malloc:
-        M0_LEAVE();
         return obj;
 }
 M0_EXPORTED(m0_be_ks_obj_malloc);
@@ -104,12 +90,10 @@ M0_INTERNAL void m0_be_ks_prep_link_reg(struct m0_be_domain    *dom,
 {
         struct m0_be_seg        *seg = NULL;
         struct m0_sm_group      *sm_group;
-        struct m0_be_buf        *buf;
+        struct m0_be_buf         buf;
         bool                     ret_val;
 
-        M0_ENTRY();
         sm_group = m0_be_domain_sm_group(dom);
-
         /* Lookup for the kv_store segment. If not found, create one */
         ret_val = m0_be_domain_lookup(dom, BE_KV_SEG_NAME, &seg);
         M0_ASSERT(ret_val);
@@ -118,51 +102,44 @@ M0_INTERNAL void m0_be_ks_prep_link_reg(struct m0_be_domain    *dom,
         M0_ALLOC_PTR((*reg));
         M0_ASSERT(*reg != NULL);
 
-        M0_ALLOC_PTR(buf);
-        M0_ASSERT(buf != NULL);
-
-        buf->b_nob = sizeof *link;
-        buf->b_addr = (void *)link;
-        m0_be_reg_init(*reg, tx, seg, buf);
-        m0_free(buf);
-        M0_LEAVE();
+        buf.b_nob = sizeof *link;
+        buf.b_addr = (void *)link;
+        m0_be_reg_init(*reg, tx, seg, &buf);
 }
 M0_EXPORTED(m0_be_ks_prep_link);
 
 M0_INTERNAL void m0_be_wait(struct m0_sm_group *sm_group,
                             struct m0_sm       *sm, uint64_t allowed_states)
 {
-        M0_ENTRY();
         m0_sm_group_lock(sm_group);
         m0_sm_timedwait(sm, allowed_states, M0_TIME_NEVER);
         m0_sm_group_unlock(sm_group);
-        M0_LEAVE();
 }
 M0_EXPORTED(m0_be_wait);
 
-M0_INTERNAL void m0_kv_init_helper(struct m0_be_domain     **dom,
-                                   struct m0_be_kv_store   **handle,
-                                   struct m0_tl_descr       *list_descr,
-                                   kv_key_cmp_t              cmp_routine,
-                                   kv_key_match_t            match_routine,
-                                   struct m0_be_kv_store_cb *cb_info,
-                                   const  char              *init_mode)
+M0_INTERNAL void m0_kv_init_helper(struct m0_be_domain      **dom,
+                                   struct m0_be_kv_store    **handle,
+                                   struct m0_tl_descr        *list_descr,
+                                   kv_key_cmp_t               cmp_routine,
+                                   kv_key_match_t             match_routine,
+                                   struct m0_be_kv_store_cb  *cb_info,
+                                   enum   m0_be_ks_init_mode  init_mode,
+                                   int32_t                    handle_index)
 
 {
         struct m0_sm_group        *sm_group;
+        struct m0_be_seg          *kv_seg;
         const char                *stob_dir;
         const char                *stob_file;
         const char                *log_file;
         char                       kv_cmd[1024];
         int                        rc;
 
-        if (strcasecmp(init_mode, "create") == 0) {
+        if (init_mode == M0_BE_KS_CREATE) {
                 stob_file = "0000000000000000.0000000000000001";
                 stob_dir  = "/tmp/__be/o";
                 log_file  = "/tmp/log_file";
 
-
-                M0_LOG(M0_DEBUG,"KV Store Initialization");
                 sprintf(kv_cmd, "rm -rf %s", log_file);
                 rc = system(kv_cmd);
                 M0_ASSERT(rc == 0);
@@ -172,7 +149,8 @@ M0_INTERNAL void m0_kv_init_helper(struct m0_be_domain     **dom,
                 M0_ASSERT(rc == 0);
 
                 sprintf(kv_cmd,
-                        "dd if=/dev/zero of=%s/%s bs=1024 count=204800 2>/dev/null",
+                        "dd if=/dev/zero of=%s/%s bs=1024 count=204800"
+                        " 2>/dev/null",
                         stob_dir, stob_file);
                 rc = system(kv_cmd);
                 M0_ASSERT(rc == 0);
@@ -181,12 +159,25 @@ M0_INTERNAL void m0_kv_init_helper(struct m0_be_domain     **dom,
         m0_be_ks_init_domain(dom);
         M0_ASSERT(dom != NULL);
 
+        M0_ALLOC_PTR(kv_seg);
+        M0_ASSERT(kv_seg != NULL);
+        sm_group = m0_be_domain_sm_group(*dom);
+
+        if (init_mode == M0_BE_KS_CREATE) {
+                m0_be_seg_init(kv_seg, *dom, sm_group, 0);
+                m0_be_seg_create(kv_seg, NULL, BE_KV_SEG_NAME, NULL);
+        } else {
+                /* Try to restore (open) the segment in @dom */
+                m0_be_domain_seg_restore(*dom, BE_KV_SEG_NAME, kv_seg);
+        }
+
+        m0_be_wait(sm_group, &kv_seg->bs_sm, M0_BITS(M0_BESEG_ACTIVE,
+                                                     M0_BESEG_FAILED));
         /* Create a kv-store handle */
         m0_be_ks_create(list_descr, *dom,
-                        cmp_routine, match_routine, handle);
+                        cmp_routine, match_routine, handle_index, handle);
         M0_ASSERT(*handle != NULL);
 
-        sm_group = m0_be_domain_sm_group(*dom);
 
         /* Initialise the kv-store i.e. create or recover from RVM */
         m0_be_ks_init(*handle, cb_info, init_mode);
@@ -194,7 +185,6 @@ M0_INTERNAL void m0_kv_init_helper(struct m0_be_domain     **dom,
                    M0_BITS(M0_BEKS_DONE));
 
         M0_ASSERT((*handle)->ks_handle_rvm != NULL);
-        M0_LOG(M0_INFO, "kv_store initialised!");
 }
 M0_EXPORTED(m0_kv_init_helper);
 
@@ -216,7 +206,7 @@ M0_INTERNAL int32_t m0_kv_insert_helper(struct m0_be_kv_store  *handle,
 
         /* Insert this into the kv_store */
         status = m0_be_ks_insert(handle, NULL, ref, tx);
-        if (status != BE_KV_SUCCESS)
+        if (status != 0)
                 goto exit;
 
         m0_be_tx_done(tx);
@@ -237,9 +227,9 @@ M0_INTERNAL void *m0_kv_malloc_helper(struct m0_be_domain     *cob_be_domain,
 {
         struct m0_be_seg        *kv_seg;
         struct m0_be_reg        *obj_reg;
-        struct m0_be_buf        *obj_buf;
         struct m0_be_tx         *be_tx = *tx_out;
         struct m0_be_reference  *obj_ref;
+        struct m0_be_buf         obj_buf;
         void                    *ret_val;
         bool                     ret_dom;
 
@@ -260,12 +250,9 @@ M0_INTERNAL void *m0_kv_malloc_helper(struct m0_be_domain     *cob_be_domain,
         M0_ALLOC_PTR(obj_reg);
         M0_ASSERT(obj_reg != NULL);
 
-        M0_ALLOC_PTR(obj_buf);
-        M0_ASSERT(obj_buf != NULL);
-
-        obj_buf->b_nob = sizeof_obj;
+        obj_buf.b_nob = sizeof_obj;
 
-        m0_be_reg_init(obj_reg, be_tx, kv_seg, obj_buf);
+        m0_be_reg_init(obj_reg, be_tx, kv_seg, &obj_buf);
 
         if (*tx_out == NULL) {
                 /* As nothing in credit list, so can start tx directly */
@@ -286,7 +273,6 @@ M0_INTERNAL void *m0_kv_malloc_helper(struct m0_be_domain     *cob_be_domain,
         if (*tx_out == NULL)
                 *tx_out     = be_tx;
 exit:
-        m0_free(obj_buf);
         m0_free(obj_reg);
         return ret_val;
 }
@@ -321,18 +307,18 @@ M0_INTERNAL int32_t m0_kv_delete_helper(struct m0_be_kv_store *handle,
                                         uint64_t               sizeof_target)
 {
         struct m0_be_tx           *tx = NULL;
-        struct m0_be_buf          *obj_buf;
         struct m0_be_reg          *obj_reg = NULL;
         struct m0_be_seg          *kv_seg  = NULL;
         struct m0_sm_group        *sm_group;
         struct m0_be_domain       *kv_dom;
+        struct m0_be_buf           obj_buf;
         int32_t                    ret_val;
         bool                       ret_dom;
 
         M0_ALLOC_PTR(tx);
 
         if (tx == NULL)
-                return BE_KV_FAILURE;
+                return -ENOMEM;
 
         kv_dom = handle->ks_handle_heap.ksh_dom;
         M0_ASSERT(kv_dom != NULL);
@@ -350,12 +336,9 @@ M0_INTERNAL int32_t m0_kv_delete_helper(struct m0_be_kv_store *handle,
         M0_ALLOC_PTR(obj_reg);
         M0_ASSERT(obj_reg != NULL);
 
-        M0_ALLOC_PTR(obj_buf);
-        M0_ASSERT(obj_buf != NULL);
-
-        obj_buf->b_nob  = sizeof_target;
-        obj_buf->b_addr = target;
-        m0_be_reg_init(obj_reg, tx, kv_seg, obj_buf);
+        obj_buf.b_nob  = sizeof_target;
+        obj_buf.b_addr = target;
+        m0_be_reg_init(obj_reg, tx, kv_seg, &obj_buf);
         M0_ASSERT(obj_reg != NULL);
 
         m0_be_tx_add_cred(tx, obj_reg);
@@ -365,20 +348,13 @@ M0_INTERNAL int32_t m0_kv_delete_helper(struct m0_be_kv_store *handle,
 
         /* Delete this obj from kv store */
         ret_val = m0_be_ks_delete(handle, NULL, target, tx);
-
-        if (ret_val == BE_KV_SUCCESS) {
-                m0_be_tx_done(tx);
-                m0_be_wait(sm_group, &tx->bt_sm,
-                           M0_BITS(M0_BETX_DONE, M0_BETX_FAILED));
-        } else {
-                M0_LOG(M0_ERROR, "Failed to delete object in kv_store, err %d",
-                       ret_val);
-        }
+        m0_be_tx_done(tx);
+        m0_be_wait(sm_group, &tx->bt_sm,
+                   M0_BITS(M0_BETX_DONE, M0_BETX_FAILED));
 
         m0_be_tx_fini(tx);
         m0_free(tx);
         m0_free(obj_reg);
-        m0_free(obj_buf);
         return ret_val;
 }
 M0_EXPORTED(m0_kv_delete_helper);
@@ -389,7 +365,7 @@ M0_INTERNAL void m0_be_free_helper(struct m0_be_domain *dom,
 {
         struct m0_be_reg     *reg;
         struct m0_be_seg     *kv_seg;
-        struct m0_be_buf     *buf;
+        struct m0_be_buf      buf;
         bool                  ret_dom;
 
         ret_dom = m0_be_domain_lookup(dom, BE_KV_SEG_NAME, &kv_seg);
@@ -400,38 +376,31 @@ M0_INTERNAL void m0_be_free_helper(struct m0_be_domain *dom,
         M0_ALLOC_PTR(reg);
         M0_ASSERT(reg != NULL);
 
-        M0_ALLOC_PTR(buf);
-        M0_ASSERT(buf != NULL);
-
-        buf->b_nob  = sizeof_obj;
-        buf->b_addr = obj;
-        m0_be_reg_init(reg, tx, kv_seg, buf);
+        buf.b_nob  = sizeof_obj;
+        buf.b_addr = obj;
+        m0_be_reg_init(reg, tx, kv_seg, &buf);
 
         m0_be_reg_capture(reg);
 
         /* Delete from RVM */
         m0_be_free(reg);
 
+        /*m0_free(buf);*/
         m0_free(reg);
-        m0_free(buf);
 }
 M0_EXPORTED(m0_be_free_helper);
 
-M0_INTERNAL void m0_be_ks_fini_helper(struct m0_be_kv_store *handle,
-                                      struct m0_be_domain   *dom)
+M0_INTERNAL void m0_be_sm_lock_state_change_helper(struct m0_sm       *sm,
+                                                   struct m0_sm_group *sm_group,
+                                                   int                 state)
 {
-        struct m0_be_seg *kv_seg;
-        bool              ret_dom;
-
-        ret_dom = m0_be_domain_lookup(dom, BE_KV_SEG_NAME, &kv_seg);
-        M0_ASSERT(ret_dom);
-        M0_ASSERT(kv_seg != NULL);
-        m0_be_ks_fini(handle, NULL, kv_seg);
+        m0_sm_group_lock(sm_group);
+        m0_sm_state_set(sm, state);
+        m0_sm_group_unlock(sm_group);
 }
-M0_EXPORTED(m0_be_ks_fini_helper);
+M0_EXPORTED(m0_be_sm_lock_state_change_helper);
 
-#undef M0_TRACE_SUBSYSTEM
-/* @} end of helper group */
+/* @} end of be_helper group */
 
 /*
  * Local variables:
diff --git a/be/helper.h b/be/helper.h
index dd423fc..514b15b 100644
--- a/be/helper.h
+++ b/be/helper.h
@@ -29,33 +29,12 @@
 #include "be/kv_store.h"
 
 /**
-  Segment name used for kv_store objects.
- */
-#define BE_KV_SEG_NAME "kv_store"
-
-/**
-  @defgroup helper Helper Routines
+  @defgroup be_helper BE Helper Routines
 
-  Contains helper routines and enum used by key value store.
+  Contains helper routines for kv_store and kv_store consumers.
   @{
  */
 
-/**
-  Return values and control operations used by kv_store.
- */
-enum m0_be_kv_status {
-        /** Return Values. */
-        BE_KV_SUCCESS        = 0,
-        BE_KV_FAILURE        = -111,
-        BE_KV_DUPLICATE      = -222,
-        BE_KV_OUT_OF_DOMAIN  = -333,
-        BE_KV_INVALID_REQ    = -444,
-
-        /** Control operations in specific functions. */
-        BE_KV_INSERT         = 555,
-        BE_KV_DELETE         = 666,
-};
-
 M0_INTERNAL void m0_be_ks_init_domain(struct m0_be_domain  **out_dom);
 
 /**
@@ -84,13 +63,14 @@ M0_INTERNAL void m0_be_ks_prep_link_reg(struct m0_be_domain    *dom,
 M0_INTERNAL void m0_be_wait(struct m0_sm_group *sm_group,
                             struct m0_sm       *sm, uint64_t allowed_states);
 
-M0_INTERNAL void m0_kv_init_helper(struct m0_be_domain     **dom,
-                                   struct m0_be_kv_store   **handle,
-                                   struct m0_tl_descr       *list_descr,
-                                   kv_key_cmp_t              cmp_routine,
-                                   kv_key_match_t            match_routine,
-                                   struct m0_be_kv_store_cb *cb_info,
-                                   const  char              *init_mode);
+M0_INTERNAL void m0_kv_init_helper(struct m0_be_domain       **dom,
+                                   struct m0_be_kv_store     **handle,
+                                   struct m0_tl_descr         *list_descr,
+                                   kv_key_cmp_t                cmp_routine,
+                                   kv_key_match_t              match_routine,
+                                   struct m0_be_kv_store_cb   *cb_info,
+                                   enum   m0_be_ks_init_mode   init_mode,
+                                   int32_t                     handle_index);
 
 /**
   Wrapper over m0_be_ks_obj_malloc. tx_out maybe NULL.
@@ -124,9 +104,10 @@ M0_INTERNAL void m0_be_free_helper(struct m0_be_domain *dom,
                                    struct m0_be_tx     *tx, void *obj,
                                    uint64_t             sizeof_obj);
 
-M0_INTERNAL void m0_be_ks_fini_helper(struct m0_be_kv_store *handle,
-                                      struct m0_be_domain   *dom);
-/** @} end of helper group */
+M0_INTERNAL void m0_be_sm_lock_state_change_helper(struct m0_sm       *sm,
+                                                   struct m0_sm_group *sm_group,
+                                                   int                 state);
+/** @} end of be_helper group */
 
 #endif /* __MERO_BE_HELPER_H__ */
 
diff --git a/be/kv_store.c b/be/kv_store.c
index 3c0b38f..1276845 100644
--- a/be/kv_store.c
+++ b/be/kv_store.c
@@ -22,13 +22,16 @@
 #define M0_TRACE_SUBSYSTEM M0_TRACE_SUBSYS_BE
 
 #include "lib/trace.h"
+#include "lib/errno.h"
 #include "be/kv_store.h"
 #include "be/handle_store.h"
 #include "be/be_buf.h"
 #include "be/helper.h"
 #include "be/handler.h"
+#include "be/seg.h"      /* For m0_be_seg_state() */
 #include "be/kv_store_private.h"
 
+extern const char BE_KV_SEG_NAME[];
 /**
    @addtogroup be_kv_store
    @{
@@ -95,6 +98,7 @@ M0_INTERNAL void m0_be_ks_create(struct m0_tl_descr      *descr,
                                  struct m0_be_domain     *dom,
                                  kv_key_cmp_t             cmp_fp,
                                  kv_key_match_t           match_fp,
+                                 int32_t                  handle_index,
                                  struct m0_be_kv_store  **handle)
 {
         struct m0_sm_group *sm_group;
@@ -108,10 +112,11 @@ M0_INTERNAL void m0_be_ks_create(struct m0_tl_descr      *descr,
 
         /* Set the non_rvm part of the handle with user values */
         (*handle)->ks_handle_heap = (struct m0_be_kv_store_heap){
-                .ksh_key_cmp      = cmp_fp,
-                .ksh_key_match    = match_fp,
-                .ksh_list_descr   = descr,
-                .ksh_dom          = dom
+                .ksh_key_cmp          = cmp_fp,
+                .ksh_key_match        = match_fp,
+                .ksh_list_descr       = descr,
+                .ksh_dom              = dom,
+                .ksh_static_reg_index = handle_index
         };
 
         /*
@@ -130,7 +135,7 @@ M0_EXPORTED(m0_be_ks_create);
 
 M0_INTERNAL void m0_be_ks_init(struct m0_be_kv_store     *handle,
                                struct m0_be_kv_store_cb  *cb_info,
-                               const  char               *mode)
+                               enum   m0_be_ks_init_mode  mode)
 {
         struct m0_sm_group         *sm_group;
         struct m0_be_seg           *rvm_handle_seg = NULL;
@@ -138,35 +143,31 @@ M0_INTERNAL void m0_be_ks_init(struct m0_be_kv_store     *handle,
         struct m0_tl_descr         *descr;
         struct m0_be_domain        *dom;
         struct m0_be_kv_store_cb   *bko_cbinfo;
+        bool                        ret_dom;
 
-        M0_ENTRY("handle: %p mode: %s", handle, mode);
+        M0_ENTRY("handle: %p mode: %d", handle, mode);
         M0_PRE(m0_be_ks_get_handle_state(handle) == M0_BEKS_CREATED);
 
         descr    = handle->ks_handle_heap.ksh_list_descr;
         dom      = handle->ks_handle_heap.ksh_dom;
         sm_group = m0_be_domain_sm_group(dom);
 
+        /**
+         * @todo: Right now there is a single segment named BE_KV_SEG_NAME,
+         *        so can plainly lookup on it. It is always in memory 'for now',
+         *        so domain_lookup will simply return it and not open.
+         *        Hence no need of using m0_be_wait() here.
+         */
+        ret_dom = m0_be_domain_lookup(dom, BE_KV_SEG_NAME, &rvm_handle_seg);
+        M0_ASSERT(ret_dom);
+        M0_PRE(m0_be_seg_state(rvm_handle_seg) == M0_BESEG_ACTIVE);
+
         M0_ALLOC_PTR(bk_opdata);
         M0_ASSERT(bk_opdata != NULL);
 
-        M0_ALLOC_PTR(rvm_handle_seg);
-        M0_ASSERT(rvm_handle_seg != NULL);
-
         /* Mark key store initialisation as in progress */
-        m0_sm_group_lock(sm_group);
-        m0_sm_state_set(&handle->ks_handle_heap.ksh_sm, M0_BEKS_INPROGRESS);
-        m0_sm_group_unlock(sm_group);
-
-        if (strcasecmp(mode, "recover") == 0) {
-                /* Try to restore (open) the segment in @dom */
-                m0_be_domain_seg_restore(dom, BE_KV_SEG_NAME, rvm_handle_seg);
-        } else {
-                /* Create a new segment */
-                /* @todo: segment name is hardcoded for now */
-                m0_be_seg_init(rvm_handle_seg, dom, sm_group, 0);
-                m0_be_seg_create(rvm_handle_seg, NULL, BE_KV_SEG_NAME,
-                                 NULL);
-        }
+        m0_be_sm_lock_state_change_helper(&handle->ks_handle_heap.ksh_sm,
+                                          sm_group, M0_BEKS_INPROGRESS);
 
         /* Prepare call back data */
         bk_opdata->bko_handle   = handle;
@@ -196,29 +197,20 @@ M0_INTERNAL void m0_be_ks_init(struct m0_be_kv_store     *handle,
 M0_EXPORTED(m0_be_ks_init);
 
 M0_INTERNAL void m0_be_ks_fini(struct m0_be_kv_store     *handle,
-                               struct m0_be_kv_store_cb  *cb_info,
-                               struct m0_be_seg          *seg)
+                               struct m0_be_kv_store_cb  *cb_info)
 {
-        struct m0_be_domain *dom;
         void                *ksc_cbdata;
+        int32_t              ret_val;
 
         M0_ENTRY();
         M0_PRE(m0_be_ks_get_handle_state(handle) == M0_BEKS_DONE);
-
-        dom = handle->ks_handle_heap.ksh_dom;
-
-        /* calls rvm_truncate as well. */
-        m0_be_seg_done(seg);
-        dom->bd_data.bs_sm.sm_state = M0_BESEG_CLOSED;
-
-        m0_be_domain_fini(dom);
-        m0_free(dom);
+        ret_val = 0;
 
         /* Call the callback function provided by the user. */
         if (cb_info != NULL) {
                 ksc_cbdata = cb_info->ksc_cbdata;
                 M0_ASSERT(ksc_cbdata != NULL);
-                cb_info->ksc_cb(ksc_cbdata, NULL, BE_KV_SUCCESS);
+                cb_info->ksc_cb(ksc_cbdata, NULL, ret_val);
         }
 
         m0_free(handle);
@@ -235,7 +227,7 @@ M0_INTERNAL void *m0_be_ks_find(struct m0_be_kv_store     *handle,
         void                    *ksc_cbdata;
         struct m0_tl            *ks_tlist;
         struct m0_tl_descr      *ks_list_descr;
-        int                      rc = BE_KV_INVALID_REQ;
+        int32_t                  rc;
 
         M0_ENTRY();
 
@@ -245,17 +237,17 @@ M0_INTERNAL void *m0_be_ks_find(struct m0_be_kv_store     *handle,
         m0_tlist_for(ks_list_descr, ks_tlist, scan) {
                 if (handle->ks_handle_heap.ksh_key_match(scan, key) == 0) {
                         target = scan;
-                        rc     = BE_KV_SUCCESS;
+                        rc     = 0;
                         break;
                 }
         } m0_tlist_endfor;
 
-        if (rc == BE_KV_SUCCESS)
+        if (rc == 0 && scan != NULL)
                 goto exit_find;
 
-        /* Target was not found, so we return NULL */
-        target = NULL;
-        rc     = BE_KV_FAILURE;
+        /* No such object was found, return NULL. */
+        target =  NULL;
+        rc     = -ENOENT;
 
 exit_find:
         /* Call the callback function provided by the user. */
@@ -286,8 +278,7 @@ M0_INTERNAL int32_t m0_be_ks_delete(struct m0_be_kv_store     *handle,
         struct m0_tl_descr      *ks_list_descr;
         struct m0_be_domain     *ks_dom;
         struct m0_sm_group      *sm_group;
-        enum m0_be_kv_status     ret_val;
-        bool                     target_found;
+        int32_t                  ret_val;
 
         M0_ENTRY();
         M0_ASSERT(tx != NULL);
@@ -302,12 +293,12 @@ M0_INTERNAL int32_t m0_be_ks_delete(struct m0_be_kv_store     *handle,
         m0_tlist_for(ks_list_descr, ks_tlist, scan) {
                 if (handle->ks_handle_heap.ksh_key_cmp(scan, obj) == 0) {
                         target = scan;
-                        target_found = true;
                         break;
                 }
         } m0_tlist_endfor;
 
-        if (target_found == true) {
+        /* If target was not found, scan will be NULL */
+        if (scan != NULL) {
                 /* Capture t_head */
                 temp_link   = head->ll_next;
                 t_head_link = temp_link->ll_prev;
@@ -324,15 +315,18 @@ M0_INTERNAL int32_t m0_be_ks_delete(struct m0_be_kv_store     *handle,
                  * be modified to the credit or captures them depending
                  * upon the transaction received
                  */
-                __ks_prev_next_add_cred(handle, tx, target, BE_KV_DELETE);
+                __ks_prev_next_add_cred(handle, tx, target, M0_BE_KV_DELETE);
 
                 /* Now delete */
                 m0_tlink_del_fini(ks_list_descr, target);
-                ret_val = BE_KV_SUCCESS;
-        } else {
-                ret_val = BE_KV_FAILURE;
+                ret_val = 0;
+                goto exit_delete;
         }
 
+        /* The object to be deleted was not found. */
+        ret_val = -ENOENT;
+
+exit_delete:
         /* Call the callback function provided by the user. */
         if (cb_info != NULL) {
                 ksc_cbdata = cb_info->ksc_cbdata;
@@ -349,20 +343,20 @@ M0_INTERNAL int32_t m0_be_ks_update(struct m0_be_kv_store     *handle,
                                     struct m0_be_kv_store_cb  *cb_info,
                                     void                      *in_obj,
                                     uint64_t                   sizeof_obj,
-                                    kv_obj_copy_t              obj_copy)
+                                    kv_obj_update_t            obj_update)
 {
         struct m0_be_domain     *dom;
         struct m0_tl            *ks_tlist;
         struct m0_tl_descr      *ks_list_descr;
         struct m0_sm_group      *sm_group;
-        struct m0_be_buf        *buf;
+        struct m0_be_buf         buf;
         struct m0_be_reg        *reg;
         struct m0_be_seg        *seg;
         struct m0_be_tx         *tx;
-        void                    *current = NULL;
+        void                    *current;
         void                    *scan;
         void                    *ksc_cbdata;
-        int32_t                  ret_val       = BE_KV_INVALID_REQ;
+        int32_t                  ret_val;
         bool                     ret_dom;
         kv_key_cmp_t             cmp_fp;
 
@@ -383,18 +377,17 @@ M0_INTERNAL int32_t m0_be_ks_update(struct m0_be_kv_store     *handle,
                         }
         } m0_tlist_endfor;
 
-
-        /* If object was found, capture it and update it with incoming object */
-        if (current != NULL) {
+        /*
+         * If object was found, scan will not be NULL,
+         * capture it and update it with incoming object
+         */
+        if (scan != NULL) {
                 M0_ALLOC_PTR(tx);
                 M0_ASSERT(tx != NULL);
 
                 M0_ALLOC_PTR(reg);
                 M0_ASSERT(reg != NULL);
 
-                M0_ALLOC_PTR(buf);
-                M0_ASSERT(buf != NULL);
-
                 m0_be_tx_init(tx, dom, 0);
 
                 /* Lookup for the kv_store segment. If not found, create one */
@@ -403,9 +396,9 @@ M0_INTERNAL int32_t m0_be_ks_update(struct m0_be_kv_store     *handle,
                 M0_ASSERT(seg != NULL);
 
                 /* Prepare a region to capture the object */
-                buf->b_nob  = sizeof_obj;
-                buf->b_addr = current;
-                m0_be_reg_init(reg, tx, seg, buf);
+                buf.b_nob  = sizeof_obj;
+                buf.b_addr = current;
+                m0_be_reg_init(reg, tx, seg, &buf);
 
                 /* Add this region to tx credit list and start the tx */
                 m0_be_tx_add_cred(tx, reg);
@@ -413,8 +406,8 @@ M0_INTERNAL int32_t m0_be_ks_update(struct m0_be_kv_store     *handle,
                 m0_be_tx_start(tx);
 
                 /* Update the current object */
-                if (obj_copy != NULL) {
-                        obj_copy(current, in_obj, tx);
+                if (obj_update != NULL) {
+                        obj_update(current, in_obj, tx);
                 } else {
                         memcpy(current, in_obj, sizeof_obj);
                 }
@@ -429,13 +422,12 @@ M0_INTERNAL int32_t m0_be_ks_update(struct m0_be_kv_store     *handle,
                 m0_be_tx_fini(tx);
                 m0_free(tx);
                 m0_free(reg);
-                m0_free(buf);
 
-                ret_val = BE_KV_SUCCESS;
+                ret_val = 0;
                 goto exit_update;
         }
 
-        ret_val = BE_KV_FAILURE;
+        ret_val = -ENOENT;
 
 exit_update:
         /* Call the callback function provided by the user. */
@@ -484,7 +476,7 @@ M0_INTERNAL int32_t __ks_tlist_add_at_tail(struct m0_be_kv_store     *handle,
         m0_tlist_add_tail(ks_list_descr, ks_tlist, new);
         M0_LEAVE();
 
-        return BE_KV_SUCCESS;
+        return 0;
 }
 
 M0_INTERNAL int32_t m0_be_ks_insert(struct m0_be_kv_store     *handle,
@@ -500,7 +492,7 @@ M0_INTERNAL int32_t m0_be_ks_insert(struct m0_be_kv_store     *handle,
         void                    *scan;
         void                    *new;
         void                    *ksc_cbdata;
-        enum m0_be_kv_status     ret_val       = BE_KV_INVALID_REQ;
+        int32_t                  ret_val;
         kv_key_cmp_t             cmp_fp;
 
         M0_ENTRY("handle: %p obj:%p", handle, obj_ref->be_virtual_address);
@@ -510,8 +502,8 @@ M0_INTERNAL int32_t m0_be_ks_insert(struct m0_be_kv_store     *handle,
 
         /* Ensure object is allocated on same domain as that of handle */
         if (obj_ref->be_magic != dom->bd_magic) {
-                ret_val = BE_KV_OUT_OF_DOMAIN;
-                M0_LOG(M0_ERROR, "kv_insert: object out of domain!");
+                ret_val = -EPERM;
+                M0_LOG(M0_DEBUG, "kv_insert: object out of domain!");
                 goto exit_insert;
         }
 
@@ -530,43 +522,42 @@ M0_INTERNAL int32_t m0_be_ks_insert(struct m0_be_kv_store     *handle,
         /* Check if tlist is empty */
         if ((head->ll_next == (void *)head) &&
             (head->ll_prev == (void *)head)) {
-
                /* Add to tlist now */
                 m0_tlist_add(ks_list_descr, ks_tlist, new);
-                ret_val = BE_KV_SUCCESS;
+                ret_val  = 0;
         } else {
                 /*
                  * Else, find the appropriate position for the obj and insert
                  */
-                m0_tlist_for(ks_list_descr, ks_tlist, scan)
-                {
+                m0_tlist_for(ks_list_descr, ks_tlist, scan) {
                         if (cmp_fp(new, scan) < 0) {
                                 /*
                                  * Add the current, previous and next pointers
                                  * about to be modified to the credit
                                  */
                                 __ks_prev_next_add_cred(handle, tx, scan,
-                                                        BE_KV_INSERT);
+                                                        M0_BE_KV_INSERT);
 
                                 /* Now add the object to the tlist */
                                 m0_tlist_add_before(ks_list_descr, scan, new);
-                                ret_val = BE_KV_SUCCESS;
+                                ret_val  = 0;
                                 break;
                         } else if (cmp_fp(new, scan) == 0) {
                                 /* Check for duplicate insertion */
-                                ret_val = BE_KV_DUPLICATE;
-                                M0_LOG(M0_ERROR,
+                                ret_val  = -EPERM;
+                                M0_LOG(M0_DEBUG,
                                        "kv_insert: duplicate insertion!");
                                 goto exit_insert;
                         }
                 } m0_tlist_endfor;
 
-                /* If key is largest in the list, add at tail */
-                if (ret_val == BE_KV_INVALID_REQ) {
+                /*
+                 * If key is largest in the list, add at tail
+                 * scan will be NULL if we no appropriate position was found
+                 */
+                if (scan == NULL)
                         ret_val = __ks_tlist_add_at_tail(handle, new, tx);
-                }
         }
-
 exit_insert:
         /* Call the callback function provided by the user. */
         if (cb_info != NULL) {
@@ -586,7 +577,7 @@ M0_INTERNAL int32_t m0_be_ks_pair_setup(struct m0_be_domain        *dom,
                                         struct m0_be_tx           **tx,
                                         struct m0_be_ks_pair      **out_pair,
                                         struct m0_be_reference    **out_ref,
-                                        enum   pair_allocate_area   alloc_area)
+                                        enum   m0_be_pair_type      alloc_area)
 {
         struct m0_be_reference  *obj_ref;
         struct m0_be_ks_pair    *pair;
@@ -594,7 +585,7 @@ M0_INTERNAL int32_t m0_be_ks_pair_setup(struct m0_be_domain        *dom,
 
         M0_ASSERT(dom != NULL);
 
-        if (tx == NULL &&  alloc_area == KS_PAIR_ON_HEAP) {
+        if (tx == NULL &&  alloc_area == M0_BE_KS_PAIR_HEAP) {
                M0_ALLOC_PTR(pair);
         } else {
                 pair = (struct m0_be_ks_pair *)
@@ -604,13 +595,13 @@ M0_INTERNAL int32_t m0_be_ks_pair_setup(struct m0_be_domain        *dom,
         }
 
         if (pair == NULL) {
-                ret_val = BE_KV_FAILURE;
+                ret_val = -ENOMEM;
                 goto exit_setup;
         }
 
         pair->ksp_key   = key;
         pair->ksp_value = rec_value;
-        ret_val         = BE_KV_SUCCESS;
+        ret_val         = 0;
 
 exit_setup:
         *out_pair       = pair;
@@ -626,16 +617,17 @@ M0_INTERNAL bool m0_be_ks_deref_handle(struct m0_be_kv_store *handle,
         struct m0_be_kv_store_rvm *handle_rvm;
         struct m0_uint128         *kv_store;
         long int                   lo;
+        int32_t                    target_index;
         bool                       ret_val;
 
         M0_ENTRY();
 
-        /* Get the segid_offset representation stored at index 0 */
-        kv_store = m0_be_hs_get(seg, 0);
+        target_index = handle->ks_handle_heap.ksh_static_reg_index;
+        /* Get the segid_offset representation stored at target_index. */
+        kv_store = m0_be_hs_get(seg, target_index);
 
         if (kv_store->u_hi == 0) {
                 ret_val = false;
-                M0_LOG(M0_DEBUG, "Failed to restore handle from index 0!");
                 goto exit_deref;
         }
 
@@ -648,7 +640,7 @@ M0_INTERNAL bool m0_be_ks_deref_handle(struct m0_be_kv_store *handle,
         ret_val = true;
 
 exit_deref:
-        M0_LEAVE();
+        M0_LEAVE("Handle retrival success = %d!", !!ret_val);
         return ret_val;
 }
 M0_EXPORTED(m0_be_ks_deref_handle);
@@ -680,7 +672,7 @@ static void __ks_insert_capture_head_new(struct m0_be_kv_store  *handle,
         m0_be_ks_prep_link_reg(dom, link, tx, &obj_link_reg);
         M0_ASSERT(obj_link_reg != NULL);
 
-        /** Capture this region. */
+        /* Capture this region. */
         m0_be_reg_capture(obj_link_reg);
         m0_free(obj_link_reg);
 
@@ -754,7 +746,7 @@ static void __ks_prev_next_add_cred(struct m0_be_kv_store *handle,
         struct m0_be_reg         *curr_reg;
         struct m0_list_link      *link_prev;
         struct m0_list_link      *link_curr;
-        struct m0_list_link      *link_next = NULL;
+        struct m0_list_link      *link_next;
         struct m0_tl_descr       *ks_list_descr;
         struct m0_be_domain      *ks_dom;
 
@@ -768,8 +760,8 @@ static void __ks_prev_next_add_cred(struct m0_be_kv_store *handle,
         __ks_get_prev(ks_list_descr, current, &link_prev);
         __ks_get_current(ks_list_descr, current, &link_curr);
 
-        /* Get next pointer only if operation is BE_KV_DELETE */
-        if (operation == BE_KV_DELETE)
+        /* Get next pointer only if operation is M0_BE_KV_DELETE */
+        if (operation == M0_BE_KV_DELETE)
                 __ks_get_next(ks_list_descr, current, &link_next);
 
         m0_be_ks_prep_link_reg(ks_dom, link_curr, tx, &curr_reg);
@@ -782,7 +774,7 @@ static void __ks_prev_next_add_cred(struct m0_be_kv_store *handle,
          * Capture next region only if operation is delete, for insert
          * only current and prev regions need to be captured
          */
-        if (operation == BE_KV_DELETE) {
+        if (operation == M0_BE_KV_DELETE) {
                 m0_be_ks_prep_link_reg(ks_dom, link_next, tx, &next_reg);
                 M0_ASSERT(next_reg != NULL);
         }
@@ -791,27 +783,26 @@ static void __ks_prev_next_add_cred(struct m0_be_kv_store *handle,
         m0_be_reg_capture(prev_reg);
         m0_free(prev_reg);
 
-        if (operation == BE_KV_DELETE) {
+        if (operation == M0_BE_KV_DELETE) {
                 m0_be_reg_capture(next_reg);
                 m0_free(next_reg);
         }
 
         m0_be_reg_capture(curr_reg);
         m0_free(curr_reg);
-
         M0_LEAVE();
 }
 
 M0_INTERNAL void m0_be_ksi_handle_cb(void *cb_data)
 {
-        struct m0_be_ks_opdata  *bk_opdata;
-        struct m0_be_domain     *dom;
-        struct m0_be_kv_store   *handle;
-        struct m0_tl_descr      *descr;
-        struct m0_be_seg        *seg;
-        struct m0_sm_group      *sm_group;
-        const  char             *mode;
-        bool                     ret_val;
+        struct m0_be_ks_opdata   *bk_opdata;
+        struct m0_be_domain      *dom;
+        struct m0_be_kv_store    *handle;
+        struct m0_tl_descr       *descr;
+        struct m0_be_seg         *seg;
+        struct m0_sm_group       *sm_group;
+        enum   m0_be_ks_init_mode mode;
+        bool                      ret_val;
 
         M0_ENTRY();
 
@@ -826,15 +817,13 @@ M0_INTERNAL void m0_be_ksi_handle_cb(void *cb_data)
         M0_ASSERT(handle != NULL);
         M0_ASSERT(dom    != NULL);
         M0_ASSERT(seg    != NULL);
-        M0_ASSERT(mode   != NULL);
         M0_ASSERT(descr  != NULL);
 
         sm_group = m0_be_domain_sm_group(dom);
-
-        ret_val = m0_be_ks_deref_handle(handle, seg);
+        ret_val  = m0_be_ks_deref_handle(handle, seg);
 
         /* Create handle */
-        if (ret_val == false && strcasecmp(mode, "create") == 0) {
+        if (ret_val == false && mode == M0_BE_KS_CREATE) {
                 __ks_create_handle(cb_data);
                 goto exit;
         }
@@ -882,7 +871,6 @@ M0_INTERNAL void m0_be_ksi_tx_cb(void *cb_data)
         struct m0_be_ks_opdata  *bk_opdata;
         struct m0_be_tx         *tx;
         struct m0_be_reg        *reg;
-        struct m0_be_buf        *buf;
 
         M0_ENTRY();
 
@@ -890,17 +878,14 @@ M0_INTERNAL void m0_be_ksi_tx_cb(void *cb_data)
 
         tx  = bk_opdata->bko_tx;
         reg = bk_opdata->bko_reg;
-        buf = bk_opdata->bko_buf;
 
         M0_ASSERT(tx  != NULL);
         M0_ASSERT(reg != NULL);
-        M0_ASSERT(buf != NULL);
 
         m0_be_tx_fini(tx);
 
         m0_free(tx);
         m0_free(reg);
-        m0_free(buf);
 
         /* Complete the kv-store initialisation process */
         m0_be_ksi_init_done(bk_opdata);
@@ -916,6 +901,7 @@ M0_INTERNAL void m0_be_ksi_init_done(void *cb_data)
         struct m0_be_domain        *dom;
         struct m0_sm_group         *sm_group;
         void                       *ksc_cbdata;
+        int32_t                     ret_val;
 
         M0_ENTRY();
 
@@ -934,16 +920,15 @@ M0_INTERNAL void m0_be_ksi_init_done(void *cb_data)
 
         /* Set kv-store state to done */
         sm_group = m0_be_domain_sm_group(dom);
-
-        m0_sm_group_lock(sm_group);
-        m0_sm_state_set(&handle->ks_handle_heap.ksh_sm, M0_BEKS_DONE);
-        m0_sm_group_unlock(sm_group);
+        m0_be_sm_lock_state_change_helper(&handle->ks_handle_heap.ksh_sm,
+                                          sm_group, M0_BEKS_DONE);
+        ret_val = 0;
 
         /* If provided, call the callback function assigned by the user */
         if (cb_info != NULL) {
                 ksc_cbdata = cb_info->ksc_cbdata;
                 M0_ASSERT(ksc_cbdata != NULL);
-                cb_info->ksc_cb(ksc_cbdata, NULL, BE_KV_SUCCESS);
+                cb_info->ksc_cb(ksc_cbdata, NULL, ret_val);
                 /* Was allocated in m0_be_ks_init */
                 m0_free(cb_info);
         }
@@ -964,11 +949,13 @@ M0_INTERNAL void __ks_create_handle(struct m0_be_ks_opdata *bk_opdata)
         struct m0_be_kv_store       *handle;
         struct m0_tl_descr          *descr;
         struct m0_be_hs_opdata      *bh_opdata;
-        struct m0_be_buf            *rvm_handle_buf;
+        struct m0_be_buf             rvm_handle_buf;
+        int32_t                      target_index;
 
         M0_ENTRY();
 
         handle         = bk_opdata->bko_handle;
+        target_index   = handle->ks_handle_heap.ksh_static_reg_index;
         dom            = handle->ks_handle_heap.ksh_dom;
         descr          = handle->ks_handle_heap.ksh_list_descr;
         rvm_handle_seg = bk_opdata->bko_seg;
@@ -981,9 +968,6 @@ M0_INTERNAL void __ks_create_handle(struct m0_be_ks_opdata *bk_opdata)
         M0_ALLOC_PTR(tx);
         M0_ASSERT(tx != NULL);
 
-        M0_ALLOC_PTR(rvm_handle_buf);
-        M0_ASSERT(rvm_handle_buf != NULL);
-
         sm_group = m0_be_domain_sm_group(dom);
 
         m0_be_tx_init(tx, dom, 0);
@@ -992,8 +976,8 @@ M0_INTERNAL void __ks_create_handle(struct m0_be_ks_opdata *bk_opdata)
         M0_ALLOC_PTR(rvm_handle_reg);
         M0_ASSERT(rvm_handle_reg != NULL);
 
-        rvm_handle_buf->b_nob = sizeof *rvm_handle;
-        m0_be_reg_init(rvm_handle_reg, tx, rvm_handle_seg, rvm_handle_buf);
+        rvm_handle_buf.b_nob = sizeof *rvm_handle;
+        m0_be_reg_init(rvm_handle_reg, tx, rvm_handle_seg, &rvm_handle_buf);
 
         m0_be_tx_start(tx);
 
@@ -1016,14 +1000,13 @@ M0_INTERNAL void __ks_create_handle(struct m0_be_ks_opdata *bk_opdata)
          * to be called after m0_be_hs_update completion
          */
         bk_opdata->bko_tx               = tx;
-        bk_opdata->bko_buf              = rvm_handle_buf;
         bk_opdata->bko_reg              = rvm_handle_reg;
 
         /*
          * Prepare call back data and function to be used by
          * m0_be_hs_update() and its callback routine
          */
-        bh_opdata->bho_index            = 0;
+        bh_opdata->bho_index            = target_index;
         bh_opdata->bho_segid_offset     = &rvm_handle_ref->be_segid_offset;
         bh_opdata->bho_seg              = rvm_handle_seg;
 
diff --git a/be/kv_store.h b/be/kv_store.h
index 74c11a1..c16fcfb 100644
--- a/be/kv_store.h
+++ b/be/kv_store.h
@@ -59,9 +59,11 @@
    Usage:
 
    Initialisation:
-       PRE: @dom should have been initialised already.
-            @cmp_routine and @match_routine must be pointing to the key compare
-            and match routines which return integer value.
+       PRE: 1. @dom should have been initialised already.
+            2. @cmp_routine and @match_routine must be pointing to the key
+               compare and match routines which return integer value.
+            3. Segment is assumed to be loaded in memory. It does not create
+               or load a segment.
 
        @code:
        int  function_match(void *, void *);
@@ -162,9 +164,38 @@
        status = m0_be_ks_delete(handle, cb_info, object, tx);
        @endcode
 
+   Update:
+       Updation of an already inserted object in the kv_store needs a
+       function pointer of type kv_obj_update_t, provided by the user.
+       This function of the user should first free the old value
+       (if it was on RVM via m0_be_free or any other free, if a pointer) and
+       then update the new value.
+
+       NOTE: This function updates only the value associated with the object.
+             The key, as a unique entity for an object in the kv_store, is
+             assumed to be left untouched by the user's object update function
+             pointer.
+
+       Here, the @object_to_update contains new value but old 'key'.
+       m0_be_ks_update() will find the old object in kv_store based on the old
+       key in @object_to_update. The user's function pointer decides how to
+       update the value of old_object found with the new value in
+       @object_to_update.
+
+       @code:
+       struct m0_be_kv_store_cb *cb_info;
+       kv_obj_copy_t             obj_update;
+
+       cb_info->ksc_cbdata  = cb_data;
+       cb_info->ksc_cb      = update_callback;
+       obj_copy             = user_obj_update_routine;
+
+       rc = m0_be_ks_update(handle, cb_info, object_to_update,
+                            sizeof *object_to_update, obj_update);
+       @endcode
+
+
    Fini:
-       @param seg: segment that was used to allocate memory to object while
-                   insertion
        @code:
 
        void fini_callback(void *);
@@ -175,7 +206,7 @@
        cb_info->ksc_cbdata     = cb_data;
        cb_info->ksc_cb         = fini_callback;
 
-       m0_be_ks_fini(handle, cb_info, seg);
+       m0_be_ks_fini(handle, cb_info);
        @endcode
   @{
  */
@@ -183,13 +214,13 @@
 /**
   Function compare routines. Used in key value store while searching for key.
  */
-typedef int     (*kv_key_cmp_t)(void *, void *);
-typedef int     (*kv_key_match_t)(void *, void *);
+typedef int     (*kv_key_cmp_t)(void *obj1, void *obj2);
+typedef int     (*kv_key_match_t)(void *obj, void *key);
 
 /**
   Object update routine, used by m0_be_ks_update.
  */
-typedef void    (*kv_obj_copy_t)(void *, void *, struct m0_be_tx *);
+typedef void    (*kv_obj_update_t)(void *, void *, struct m0_be_tx *);
 
 /**
   Structure that stores the fields of the kv_store handle that neeed to be made
@@ -214,6 +245,10 @@ struct m0_be_kv_store_heap {
         kv_key_cmp_t               ksh_key_cmp;
         /** Match function from user. */
         kv_key_match_t             ksh_key_match;
+        /**
+         * Index at which the handle info will be stored in static region of RVM
+         */
+        int32_t                    ksh_static_reg_index;
 };
 
 /**
@@ -256,6 +291,14 @@ struct m0_be_ks_pair {
 };
 
 /**
+  KV Store initialisation method (creation or recovery).
+ */
+enum m0_be_ks_init_mode {
+        M0_BE_KS_CREATE,
+        M0_BE_KS_RECOVER
+};
+
+/**
   Structure to hold callback data when transferring control
   from callback to another.
  */
@@ -271,11 +314,9 @@ struct m0_be_ks_opdata {
         /** Transaction pointer under which handle is created. */
         struct m0_be_tx           *bko_tx;
         /** Buffer used for bko_reg. */
-        struct m0_be_buf          *bko_buf;
-        /** Callback information to be used after operation completion. */
         struct m0_be_kv_store_cb  *bko_cbinfo;
         /** Kv-store init mode. */
-        const  char               *bko_ksi_mode;
+        enum m0_be_ks_init_mode    bko_ksi_mode;
 };
 
 /**
@@ -299,12 +340,21 @@ enum m0_be_ks_op_state {
 };
 
 /**
- *
+  Determines where is a pair allocated memory, whether on regular heap or RVM.
+ */
+enum m0_be_pair_type {
+        M0_BE_KS_PAIR_RVM,
+        M0_BE_KS_PAIR_HEAP
+};
+
+/**
+  Control operations used by kv_store internally.
  */
-enum pair_allocate_area {
-        KS_PAIR_ON_RVM,
-        KS_PAIR_ON_HEAP
+enum m0_be_kv_operation_type {
+        M0_BE_KV_INSERT,
+        M0_BE_KV_DELETE
 };
+
 /**
   Create a key value store handle with the specified paramaters.
   It will initialise the kv-store with heap values that need not be
@@ -316,15 +366,15 @@ enum pair_allocate_area {
   @param cmp_fp        :       user defined function to compare keys.
   @param match_fp      :       user defined function to match keys,
                                allowed modes: CREATE/RECOVER or create/recover.
+  @param handle_index  :       the index at which the handle allocation info
+                               will be stored in RVM static regions
   @param handle        :       pointer to the handle to be created and returned.
-
-  @retval true         :       upon succesful  initialisation/recovery.
-  @retval false        :       upon failure to initialise/recover kv_store
  */
 M0_INTERNAL void m0_be_ks_create(struct m0_tl_descr      *descr,
                                  struct m0_be_domain     *dom,
                                  kv_key_cmp_t             cmp_fp,
                                  kv_key_match_t           match_fp,
+                                 int32_t                  handle_index,
                                  struct m0_be_kv_store  **handle);
 
 /**
@@ -337,11 +387,11 @@ M0_INTERNAL void m0_be_ks_create(struct m0_tl_descr      *descr,
                                initialization.
   @param mode          :       decides whether kv_store is new or has to be
                                recovered.
-                               allowed modes: CREATE/RECOVER or create/recover.
+                               allowed modes: M0_BE_KS_CREATE, M0_BE_KS_RECOVER.
  */
 M0_INTERNAL void m0_be_ks_init(struct m0_be_kv_store     *handle,
                                struct m0_be_kv_store_cb  *cb_info,
-                               const  char               *mode);
+                               enum   m0_be_ks_init_mode  init_mode);
 
 /**
   Finalise a kv-store.
@@ -349,14 +399,10 @@ M0_INTERNAL void m0_be_ks_init(struct m0_be_kv_store     *handle,
   @param handle        :        the kv-store handle.
   @param cb_info       :        the callback information that will be used
                                 to call the callback function after completion
-                                of fini operation.
-  @param seg           :        segment used by kv-store.
 
-  @todo: as we have just segment now, segment parameter needed for now.
  */
 M0_INTERNAL void m0_be_ks_fini(struct m0_be_kv_store     *handle,
-                               struct m0_be_kv_store_cb  *cb_info,
-                               struct m0_be_seg          *seg);
+                               struct m0_be_kv_store_cb  *cb_info);
 /**
   Insert a key value pair in the kv_store contained in @handle.
 
@@ -437,7 +483,7 @@ M0_INTERNAL int32_t m0_be_ks_update(struct m0_be_kv_store     *handle,
                                     struct m0_be_kv_store_cb  *cb_info,
                                     void                      *obj,
                                     uint64_t                   sizeof_obj,
-                                    kv_obj_copy_t              obj_copy);
+                                    kv_obj_update_t            obj_update);
 
 /**
   Prepares a key value pair to be inserted in kv_store.
@@ -445,13 +491,13 @@ M0_INTERNAL int32_t m0_be_ks_update(struct m0_be_kv_store     *handle,
 
   @PRE: key and @rec_value have already been allocated on RVM.
  */
-M0_INTERNAL int32_t m0_be_ks_pair_setup(struct m0_be_domain        *dom,
-                                        void                       *key,
-                                        void                       *rec_value,
-                                        struct m0_be_tx           **tx,
-                                        struct m0_be_ks_pair      **out_pair,
-                                        struct m0_be_reference    **out_ref,
-                                        enum   pair_allocate_area   alloc_area);
+M0_INTERNAL int32_t m0_be_ks_pair_setup(struct m0_be_domain     *dom,
+                                        void                    *key,
+                                        void                    *rec_value,
+                                        struct m0_be_tx        **tx,
+                                        struct m0_be_ks_pair   **out_pair,
+                                        struct m0_be_reference **out_ref,
+                                        enum   m0_be_pair_type   alloc_area);
 /** @} end of kv_store group */
 #endif /* __MERO_BE_KV_STORE_H__ */
 
diff --git a/be/reg.c b/be/reg.c
index 96787e6..77098a0 100644
--- a/be/reg.c
+++ b/be/reg.c
@@ -19,15 +19,15 @@
 
 #undef M0_TRACE_SUBSYSTEM
 #define M0_TRACE_SUBSYSTEM M0_TRACE_SUBSYS_BE
+#include <stdlib.h>
 #include "lib/trace.h"
-#include "lib/bob.h"
 #include "mero/magic.h"
 #include "be/be.h"
 #include "be/be_private.h"
 #include "be/domain.h"
 #include "be/reg.h"
 #include "be/tx.h"
-
+#include "be/helper.h"
 #include "rvm/rds.h"
 
 /**
@@ -36,15 +36,7 @@
   @{
 */
 
-static struct m0_bob_type m0_be_reg_type_bob;
-
-static void m0_be_reg_bob_init(struct m0_be_reg *)
-                               __attribute__((unused));
-
-static void m0_be_reg_bob_fini(struct m0_be_reg *)
-                               __attribute__((unused));
-
-M0_BOB_DEFINE(static, &m0_be_reg_type_bob, m0_be_reg);
+M0_BOB_DEFINE(M0_INTERNAL, &m0_be_reg_type_bob, m0_be_reg);
 
 static const struct m0_sm_state_descr reg_states[] = {
         [M0_BEREG_INIT] = {
@@ -107,13 +99,11 @@ M0_INTERNAL void m0_be_reg_init(struct m0_be_reg *reg, struct m0_be_tx *tx,
         M0_ASSERT(seg != NULL);
         M0_ASSERT(buf != NULL);
 
-        reg->br_seg                        = seg;
-        reg->br_tx                         = tx;
-        reg->br_buf.b_nob                  = buf->b_nob;
-        reg->br_buf.b_logical_address      = buf->b_logical_address;
-        reg->br_magic                      = M0_BE_REG_MAGIC;
-
-        m0_bob_type_tlist_init(&m0_be_reg_type_bob, &m0_be_reg_tl);
+        m0_be_reg_bob_init(reg);
+        reg->br_seg   = seg;
+        reg->br_tx    = tx;
+        reg->br_buf   = *buf;
+        reg->br_magic = M0_BE_REG_MAGIC;
 
         m0_sm_group_lock(m0_be_domain_sm_group(reg->br_seg->bs_dom));
         m0_sm_init(&reg->br_sm, &reg_conf, M0_BEREG_INIT,
@@ -138,7 +128,13 @@ M0_INTERNAL void m0_be_alloc(struct m0_be_reg *reg)
         if (reg->br_tx != NULL)
                 tid = reg->br_tx->bt_impl.tx_id;
 
-        reg->br_buf.b_addr = (void *)rds_malloc(&reg->br_seg->bs_rvm, reg->br_buf.b_nob, tid, &err);
+        reg->br_buf.b_addr = (void *)rds_malloc(&reg->br_seg->bs_rvm,
+                                                reg->br_buf.b_nob, tid, &err);
+
+        if (reg->br_buf.b_addr == NULL) {
+                m0_be_reg_state_change(reg, M0_BEREG_FAILED);
+                return;
+        }
 
         /* Assign domain magic to reg reference magic  to identify references
          * within the domain.
@@ -148,9 +144,7 @@ M0_INTERNAL void m0_be_alloc(struct m0_be_reg *reg)
 
         hi      = reg->br_seg->bs_impl.segment_id;
         lo      = (reg->br_seg->bs_addr - reg->br_buf.b_addr);
-
-        if (lo < 0)
-                lo = -1 * lo;
+        lo      = labs(lo);
 
         toffset         = &reg->br_buf.b_logical_address.be_segid_offset;
         toffset->u_hi   = hi;
@@ -293,10 +287,7 @@ M0_INTERNAL void m0_be_reg_state_change(struct m0_be_reg *reg,
         struct m0_sm_group      *sm_group;
 
         sm_group = m0_be_domain_sm_group(reg->br_seg->bs_dom);
-
-        m0_sm_group_lock(sm_group);
-        m0_sm_state_set(&reg->br_sm, state);
-        m0_sm_group_unlock(sm_group);
+        m0_be_sm_lock_state_change_helper(&reg->br_sm, sm_group, state);
 }
 
 #undef M0_TRACE_SUBSYSTEM
diff --git a/be/seg.c b/be/seg.c
index 75f12e1..1d782a1 100644
--- a/be/seg.c
+++ b/be/seg.c
@@ -28,6 +28,7 @@
 #include "be/seg.h"
 #include "be/domain.h"
 #include "be/be_rvm.h"
+#include "be/helper.h"
 #include "rvm/rds.h"
 
 #include "stob/linux.h"
@@ -38,15 +39,7 @@
   @{
 */
 
-static struct m0_bob_type m0_be_seg_type_bob;
-
-static void m0_be_seg_bob_init(struct m0_be_seg *)
-                               __attribute__((unused));
-
-static void m0_be_seg_bob_fini(struct m0_be_seg *)
-                               __attribute__((unused));
-
-M0_BOB_DEFINE(static, &m0_be_seg_type_bob, m0_be_seg);
+M0_BOB_DEFINE(M0_INTERNAL, &m0_be_seg_type_bob, m0_be_seg);
 
 static const struct m0_sm_state_descr m0_be_seg_states[] = {
         [M0_BESEG_INIT] = {
@@ -123,8 +116,7 @@ M0_INTERNAL void m0_be_seg_init(struct m0_be_seg *seg,
         M0_ENTRY("dom: %p, seg: %p", dom, seg);
         M0_ASSERT(dom != NULL);
 
-        m0_bob_type_tlist_init(&m0_be_seg_type_bob, &m0_be_seg_tl);
-
+        m0_be_seg_bob_init(seg);
         /* Initialise domain structure with required values. */
         seg->bs_dom = dom;
 
@@ -132,7 +124,7 @@ M0_INTERNAL void m0_be_seg_init(struct m0_be_seg *seg,
         seg->bs_impl.segment_id = 1;
         seg->bs_magic           = M0_BE_SEG_MAGIC;
 
-        /**
+        /*
          * Need to make it null because it is referenced into rvm callback to
          * decide operation status.
          */
@@ -155,17 +147,17 @@ M0_INTERNAL void m0_be_seg_create(struct m0_be_seg *seg, struct m0_be_tx *tx,
         M0_PRE(m0_be_seg_invariant(seg) &&
                m0_be_seg_state(seg) == M0_BESEG_INIT);
 
-        for_each_seg_in_domain(scan, seg->bs_dom)
+        for_each_seg_in_domain(scan, seg->bs_dom) {
                 if (strcmp(name, scan->bs_impl.segment_name) == 0) {
                         m0_be_seg_state_change(seg, M0_BESEG_FAILED);
                         return;
                 }
-        end_for_each_seg_in_domain
+        } end_for_each_seg_in_domain;
 
         m0_be_seg_state_change(seg, M0_BESEG_CREATING);
 
-        strncpy(seg->bs_impl.segment_name, name,
-                sizeof(seg->bs_impl.segment_name));
+        strcpy(seg->bs_impl.segment_name, "\0");
+        strncat(seg->bs_impl.segment_name, name,strlen(name));
         seg->bs_stob         = stob;
         seg->bs_rvm.seg_stob = stob;
 
@@ -181,7 +173,7 @@ M0_INTERNAL void m0_be_seg_open(struct m0_be_seg *seg)
         M0_ENTRY("seg: %p", seg);
         M0_PRE(m0_be_seg_invariant(seg) &&
                M0_IN(m0_be_seg_state(seg), (M0_BESEG_INIT, M0_BESEG_CLOSED)) &&
-               m0_be_seg_state(&seg->bs_dom->bd_data) == M0_BESEG_ACTIVE);
+               m0_be_domain_state(seg->bs_dom) == M0_BESEG_INIT);
 
         sm_group = m0_be_domain_sm_group(seg->bs_dom);
         m0_be_seg_state_change(seg, M0_BESEG_OPENING);
@@ -213,8 +205,11 @@ M0_INTERNAL void m0_be_seg_fini(struct m0_be_seg *seg)
         /* Finalizing on state machine. */
         m0_sm_fini(&seg->bs_sm);
 
-        /* Finalizing respective stob. */
-        m0_stob_fini(seg->bs_stob);
+        /*
+         * Finalizing respective stob domain, this domain was initialised in
+         * m0_stob_locate in m0_be_seg_create_cb.
+         */
+        m0_stob_domain_fini(seg->bs_stob->so_domain);
 
         /* Removing entry from in memory segment list if present. */
         if (m0_be_seg_tlink_is_in(seg))
@@ -241,7 +236,7 @@ M0_INTERNAL void m0_be_seg_delete(struct m0_be_seg *seg, struct m0_be_tx *tx)
         if (m0_be_seg_tlink_is_in(seg))
                 m0_be_seg_tlink_del_fini(seg);
 
-        /**
+        /*
          * The following veriables are needed to remove entry from named
          * segment.
          */
@@ -331,9 +326,6 @@ M0_INTERNAL void m0_be_seg_create_cb(void *cb_data)
         stob_id.si_bits.u_hi    = 0;
         stob_id.si_bits.u_lo    = seg->bs_impl.segment_id;
 
-        /* Initialize stob type. */
-        m0_stob_type_init(&m0_linux_stob_type);
-
         /* @todo - stob path is hardcoded for now. */
         result = m0_stob_domain_locate(&m0_linux_stob_type,
                                        "/tmp/__be",
@@ -401,13 +393,9 @@ M0_INTERNAL void m0_be_seg_create_cb(void *cb_data)
         m0_be_seg_tlist_add(&seg->bs_dom->bd_seg, seg);
 
         seg_state = M0_BESEG_ACTIVE;
-        M0_LOG(M0_INFO, "Segment created! seg = %p", seg);
 exit:
-        m0_sm_group_lock(sm_group);
-        m0_sm_state_set((&seg->bs_sm), seg_state);
-        m0_sm_group_unlock(sm_group);
-
-        M0_LEAVE();
+        m0_be_sm_lock_state_change_helper(&seg->bs_sm, sm_group, seg_state);
+        M0_LEAVE("Seg = %p segment state = %d", seg, seg_state);
 }
 
 /**
@@ -472,14 +460,10 @@ M0_INTERNAL void m0_be_seg_open_cb(void *cb_data)
         seg->bs_addr = (void *)m0_be_rvm_get_heapaddr(seg);
 
         seg_state = M0_BESEG_ACTIVE;
-        M0_LOG(M0_INFO, "Segment opened! seg = %p", seg);
 
 exit:
-        m0_sm_group_lock(sm_group);
-        m0_sm_state_set((&seg->bs_sm), seg_state);
-        m0_sm_group_unlock(sm_group);
-
-        M0_LEAVE();
+        m0_be_sm_lock_state_change_helper(&seg->bs_sm, sm_group, seg_state);
+        M0_LEAVE("Segment = %p  Opened state = %d", seg, seg_state);
 }
 
 M0_INTERNAL uint32_t m0_be_seg_state(const struct m0_be_seg *seg)
@@ -491,7 +475,7 @@ M0_INTERNAL bool m0_be_seg_invariant(const struct m0_be_seg *seg)
 {
         struct m0_sm_group      *sm_group;
 
-        seg     = (struct m0_be_seg *)seg;
+        seg      = (struct m0_be_seg *)seg;
         sm_group = m0_be_domain_sm_group(seg->bs_dom);
 
         return  seg != NULL &&
@@ -505,10 +489,7 @@ M0_INTERNAL void m0_be_seg_state_change(struct m0_be_seg *seg,
         struct m0_sm_group      *sm_group;
 
         sm_group = m0_be_domain_sm_group(seg->bs_dom);
-
-        m0_sm_group_lock(sm_group);
-        m0_sm_state_set(&seg->bs_sm, state);
-        m0_sm_group_unlock(sm_group);
+        m0_be_sm_lock_state_change_helper(&seg->bs_sm, sm_group, state);
 }
 
 #undef M0_TRACE_SUBSYSTEM
diff --git a/be/tx.c b/be/tx.c
index 01ad82e..6daf77d 100644
--- a/be/tx.c
+++ b/be/tx.c
@@ -26,6 +26,7 @@
 #include "be/handler.h"
 #include "be/tx.h"
 #include "be/reg.h"
+#include "be/helper.h"
 #include "be/domain.h"
 
 /**
@@ -33,15 +34,7 @@
   @{
 */
 
-static struct m0_bob_type m0_be_tx_type_bob;
-
-static void m0_be_tx_bob_init(struct m0_be_tx *)
-                              __attribute__((unused));
-
-static void m0_be_tx_bob_fini(struct m0_be_tx *)
-                              __attribute__((unused));
-
-M0_BOB_DEFINE(static, &m0_be_tx_type_bob, m0_be_tx);
+M0_BOB_DEFINE(M0_INTERNAL, &m0_be_tx_type_bob, m0_be_tx);
 
 static const struct m0_sm_state_descr tx_states[] = {
         [M0_BETX_INIT] = {
@@ -108,10 +101,10 @@ M0_INTERNAL void m0_be_tx_init(struct m0_be_tx *tx, struct m0_be_domain *dom,
                   dom != NULL &&
                   &dom->bd_impl.sm_group != NULL);
 
+        m0_be_tx_bob_init(tx);
         tx->bt_dom   = dom;
         tx->bt_magic = M0_BE_TX_MAGIC;
 
-        m0_bob_type_tlist_init(&m0_be_tx_type_bob, &m0_be_tx_tl);
         m0_be_reg_tlist_init(&tx->bt_impl.bc_tl);
 
         m0_sm_group_lock(m0_be_domain_sm_group(tx->bt_dom));
@@ -148,7 +141,7 @@ M0_INTERNAL void m0_be_tx_prep(struct m0_be_tx *tx)
         M0_PRE(m0_be_tx_invariant(tx) &&
                m0_be_tx_state(tx) == M0_BETX_INIT);
 
-        for_each_reg_in_tx(reg_it, tx)
+        for_each_reg_in_tx(reg_it, tx) {
                 if (!M0_IN(m0_be_reg_state(reg_it), (M0_BEREG_INIT,
                                                      M0_BEREG_ALLOCATED))) {
                         tx_state = M0_BETX_FAILED;
@@ -156,16 +149,16 @@ M0_INTERNAL void m0_be_tx_prep(struct m0_be_tx *tx)
                         rvm_free_tid(tx->bt_impl.tx_id);
                         goto exit;
                 }
-        end_for_each_reg_in_tx
+        } end_for_each_reg_in_tx;
 
-        for_each_reg_in_tx(reg_it, tx)
+        for_each_reg_in_tx(reg_it, tx) {
                 reg_it->br_tx = tx;
                 m0_be_reg_capture(reg_it);
                 if (m0_be_reg_state(reg_it) != M0_BEREG_CAPTURED) {
                         tx_state = M0_BETX_FAILED;
                         goto exit;
                 }
-        end_for_each_reg_in_tx
+        } end_for_each_reg_in_tx;
 
         tx_state = M0_BETX_PREPARED;
 exit:
@@ -184,8 +177,7 @@ M0_INTERNAL void m0_be_tx_start(struct m0_be_tx *tx)
         m0_be_tx_state_change(tx, M0_BETX_OPEN);
 
         M0_POST(m0_be_tx_invariant(tx));
-        M0_LOG(M0_INFO, "Transaction started. tx = %p", tx);
-        M0_LEAVE();
+        M0_LEAVE("Transaction started. tx = %p", tx);
 }
 
 M0_INTERNAL void m0_be_tx_done(struct m0_be_tx *tx)
@@ -210,12 +202,12 @@ M0_INTERNAL void m0_be_tx_fini(struct m0_be_tx *tx)
 
         rvm_free_tid(tx->bt_impl.tx_id);
 
-        for_each_reg_in_tx(reg_it, tx)
+        for_each_reg_in_tx(reg_it, tx) {
                 if (m0_be_reg_tlink_is_in(reg_it)) {
                          m0_be_reg_tlink_del_fini(reg_it);
                          m0_be_reg_fini(reg_it);
                 }
-        end_for_each_reg_in_tx
+        } end_for_each_reg_in_tx;
 
         m0_be_reg_tlist_fini(&tx->bt_impl.bc_tl);
         m0_be_tx_state_change(tx, M0_BETX_CLOSED);
@@ -251,20 +243,15 @@ M0_INTERNAL void m0_be_tx_done_cb(void *cb_data)
                 goto tx_exit;
         }
 
-        for_each_reg_in_tx(reg_it, tx)
-                m0_sm_group_lock(sm_group);
-                m0_sm_state_set(&reg_it->br_sm, M0_BEREG_DONE);
-                m0_sm_group_unlock(sm_group);
-        end_for_each_reg_in_tx
+        for_each_reg_in_tx(reg_it, tx) {
+                m0_be_sm_lock_state_change_helper(&reg_it->br_sm, sm_group,
+                                                  M0_BEREG_DONE);
+        } end_for_each_reg_in_tx;
 
         tx_state = M0_BETX_DONE;
-        M0_LOG(M0_INFO, "Transaction done tx = %p", tx);
 tx_exit:
-        m0_sm_group_lock(sm_group);
-        m0_sm_state_set(&tx->bt_sm, tx_state);
-        m0_sm_group_unlock(sm_group);
-
-        M0_LEAVE();
+        m0_be_sm_lock_state_change_helper(&tx->bt_sm, sm_group, tx_state);
+        M0_LEAVE("Transaction = %p state = %d", tx, tx_state);
 }
 
 M0_INTERNAL void m0_be_tx_add_cred(struct m0_be_tx *tx,
@@ -281,10 +268,11 @@ M0_INTERNAL void m0_be_tx_add_cred(struct m0_be_tx *tx,
         M0_LEAVE();
 }
 
-uint32_t m0_be_tx_state(const struct m0_be_tx *tx)
+M0_INTERNAL uint32_t m0_be_tx_state(const struct m0_be_tx *tx)
 {
         return tx->bt_sm.sm_state;
 }
+M0_EXPORTED(m0_be_tx_state);
 
 M0_INTERNAL bool m0_be_tx_invariant(const struct m0_be_tx *tx)
 {
@@ -304,10 +292,7 @@ M0_INTERNAL void m0_be_tx_state_change(struct m0_be_tx *tx,
         struct m0_sm_group      *sm_group;
 
         sm_group = m0_be_domain_sm_group(tx->bt_dom);
-
-        m0_sm_group_lock(sm_group);
-        m0_sm_state_set(&tx->bt_sm, state);
-        m0_sm_group_unlock(sm_group);
+        m0_be_sm_lock_state_change_helper(&tx->bt_sm, sm_group, state);
 }
 
 #undef M0_TRACE_SUBSYSTEM
diff --git a/be/tx.h b/be/tx.h
index 112dd85..eecd55f 100644
--- a/be/tx.h
+++ b/be/tx.h
@@ -52,7 +52,7 @@ M0_INTERNAL int m0_be_tx_get_capture_status(void * data);
  */
 M0_INTERNAL void m0_be_tx_set_capture_status(void * data);
 
-uint32_t m0_be_tx_state(const struct m0_be_tx *tx);
+M0_INTERNAL uint32_t m0_be_tx_state(const struct m0_be_tx *tx);
 
 M0_INTERNAL bool m0_be_tx_invariant(const struct m0_be_tx *tx);
 
diff --git a/be/ut/Makefile.sub b/be/ut/Makefile.sub
index 2726512..0cce06a 100644
--- a/be/ut/Makefile.sub
+++ b/be/ut/Makefile.sub
@@ -1,5 +1,4 @@
 #be/ut/handle_store.c
-ut_libmero_ut_la_SOURCES += be/ut/be.c			\
-			    be/ut/kv_store.c		\
-			    be/ut/handle_store.c	\
-			    be/ut/kv_store_ub.c
+ut_libmero_ut_la_SOURCES += be/ut/be.c		 \
+			    be/ut/kv_store.c	 \
+			    be/ut/handle_store.c
diff --git a/be/ut/be.c b/be/ut/be.c
index 14c338e..7dcdf16 100644
--- a/be/ut/be.c
+++ b/be/ut/be.c
@@ -31,7 +31,6 @@
 
 #undef M0_TRACE_SUBSYSTEM
 #define M0_TRACE_SUBSYSTEM M0_TRACE_SUBSYS_BE
-#include <stdio.h>
 #include <stdlib.h>
 #include <unistd.h>
 #include "mero/magic.h"
@@ -83,13 +82,11 @@ static int ts_be_init(void)   /* ts_ for "test suite" */
         M0_ASSERT(dom != NULL);
 
         M0_LOG(M0_DEBUG, "Domain create");
-        m0_be_domain_create(dom, NULL, NULL, M0_BE_DOMAIN_MAGIC);
+        m0_be_domain_create(dom, NULL, NULL);
         m0_be_domain_init(dom);
         sm_group = m0_be_domain_sm_group(dom);
         M0_ASSERT(sm_group != NULL);
 
-        m0_be_seg_state_change(&dom->bd_data, M0_BESEG_ACTIVE);
-
         result = m0_be_domain_lookup(dom, "first", &seg);
 
         if (result == false) {
@@ -114,7 +111,7 @@ static int ts_be_init(void)   /* ts_ for "test suite" */
         M0_ASSERT(dom != NULL);
 
         M0_LOG(M0_DEBUG, "Domain recreate");
-        m0_be_domain_create(dom, NULL, NULL, M0_BE_DOMAIN_MAGIC);
+        m0_be_domain_create(dom, NULL, NULL);
         m0_be_domain_init(dom);
         sm_group = m0_be_domain_sm_group(dom);
         M0_ASSERT(sm_group != NULL);
@@ -148,7 +145,6 @@ static int ts_be_fini(void)
         rvm_truncate();
         m0_be_seg_done(seg);
         m0_sm_group_lock(sm_group);
-        m0_sm_state_set(&dom->bd_data.bs_sm, M0_BESEG_CLOSED);
         m0_sm_group_unlock(sm_group);
         m0_be_domain_fini(dom);
 
@@ -156,7 +152,6 @@ static int ts_be_fini(void)
 #else
         m0_be_seg_done(seg);
         m0_sm_group_lock(sm_group);
-        m0_sm_state_set(&dom->bd_data.bs_sm, M0_BESEG_CLOSED);
         m0_sm_group_unlock(sm_group);
         m0_be_domain_fini(dom);
 
diff --git a/be/ut/handle_store.c b/be/ut/handle_store.c
index aadca23..7c93a55 100644
--- a/be/ut/handle_store.c
+++ b/be/ut/handle_store.c
@@ -22,7 +22,6 @@
   @{
   */
 
-#include <stdio.h>
 #include <unistd.h>
 #include <stdlib.h>
 #include "lib/memory.h"
@@ -69,7 +68,7 @@ static int ts_be_init(void)
         rc = system(hs_cmd);
         M0_ASSERT(rc == 0);
 
-        m0_be_domain_create(&dom, NULL, NULL, M0_BE_DOMAIN_MAGIC);
+        m0_be_domain_create(&dom, NULL, NULL);
         m0_be_domain_init(&dom);
         sm_group = m0_be_domain_sm_group(&dom);
         M0_ASSERT(sm_group != NULL);
diff --git a/be/ut/kv_store.c b/be/ut/kv_store.c
index 1a47a33..8559235 100644
--- a/be/ut/kv_store.c
+++ b/be/ut/kv_store.c
@@ -26,48 +26,59 @@
   @addtogroup be_ut
   @{
 */
-
 #undef M0_TRACE_SUBSYSTEM
 #define M0_TRACE_SUBSYSTEM M0_TRACE_SUBSYS_BE
 #include "lib/trace.h"
 #include "lib/ut.h"
+#include "lib/ub.h"
+#include "lib/errno.h"
 #include "be/kv_store.h"
 #include "be/be_private.h"
 #include "be/handle_store.h"
 #include "be/helper.h"
-#include <string.h>
 #include <stdlib.h>
-#define MAX_KEY_SIZE 256
+#include <stdio.h>
+
+extern const char BE_KV_SEG_NAME[];
+
+enum {
+	UT_UB_ITER   = 1000
+};
 
-/** User defined structure. */
+/** Structure to insert in the store. */
 struct m0_kv_store_obj {
-        char                    key[MAX_KEY_SIZE];
-        int                     obj_val;
-        struct m0_tlink         linkage;
-        uint64_t                magic;
+        long int              key;
+        long int              obj_val;
+        struct m0_tlink       linkage;
+        uint64_t              magic;
 };
 
-struct m0_tl_descr kv_list_descr = M0_TL_DESCR("kv_store_obj",
+struct m0_tl_descr kv_list_descr1 = M0_TL_DESCR("kv_store_obj1",
                                                 struct m0_kv_store_obj,
                                                 linkage,
                                                 magic,
                                                 0xab5ce55edba1b0a0,
                                                 0xba1dba11adba0bab);
 
+struct m0_tl_descr kv_list_descr2 = M0_TL_DESCR("kv_store_obj2",
+                                                struct m0_kv_store_obj,
+                                                linkage,
+                                                magic,
+                                                0xba1dba11adba0bab,
+                                                0xab5ce55edba1b0a0);
 struct m0_be_domain        *kv_dom;
 struct m0_be_seg           *kv_seg;
-struct m0_kv_store_obj     *object[1024]   = {NULL};
-struct m0_kv_store_obj     *ret_obj[1024]  = {NULL};
-struct m0_be_kv_store      *handle         = NULL;
-struct m0_be_kv_store_rvm  *handle_rvm     = NULL;
+struct m0_kv_store_obj     *object1[UT_UB_ITER]   = {NULL};
+struct m0_kv_store_obj     *object2[UT_UB_ITER]   = {NULL};
+struct m0_kv_store_obj     *ret_obj1[UT_UB_ITER]  = {NULL};
+struct m0_kv_store_obj     *ret_obj2[UT_UB_ITER]  = {NULL};
+struct m0_be_kv_store      *handle1         =  NULL;
+struct m0_be_kv_store      *handle2         =  NULL;
 struct m0_sm_group         *sm_group;
-
 static const char          *stob_dir  = "/tmp/__be/o";
 static const char          *stob_file = "0000000000000000.0000000000000001";
 extern const char          *log_file;
 char                        kv_cmd[1024];
-int                         kv_val;
-
 /** Callback function to be called after operation completion. */
 void init_operation_callback(void *operation_name, void *result, int rc)
 {
@@ -83,43 +94,69 @@ void fini_operation_callback(void *operation_name, void *result, int rc)
 /** Callback function to be called after operation completion. */
 void insert_operation_callback(void *operation_name, void *result, int rc)
 {
-        M0_ASSERT(rc == BE_KV_SUCCESS);
+        M0_ASSERT(rc == 0);
         m0_free(operation_name);
 }
 
 /** Callback function to be called after operation completion. */
 void find_operation_callback(void *operation_name, void *result, int rc)
 {
-        M0_ASSERT(rc == BE_KV_SUCCESS);
+        M0_ASSERT(rc == 0);
         m0_free(operation_name);
 }
 
 /** Callback function to be called after operation completion. */
 void delete_operation_callback(void *operation_name, void *result, int rc)
 {
-        M0_ASSERT(rc == BE_KV_SUCCESS);
+        M0_ASSERT(rc == 0);
         m0_free(operation_name);
 }
 
 /** Key compare routine. */
-int function_comp(void *key1, void *key2)
+int function_comp(void *in_obj1, void *in_obj2)
 {
         struct m0_kv_store_obj *obj1;
         struct m0_kv_store_obj *obj2;
+        int                     ret_val = 1;
 
-        obj1 = (struct m0_kv_store_obj *)key1;
-        obj2 = (struct m0_kv_store_obj *)key2;
-        return strcmp(obj1->key, obj2->key);
+        obj1 = (struct m0_kv_store_obj *)in_obj1;
+        obj2 = (struct m0_kv_store_obj *)in_obj2;
+
+        if (obj1->key == obj2->key)
+                ret_val = 0;
+        else if (obj1->key < obj2->key)
+                ret_val = -1;
+
+        return ret_val;
 }
 
 /** Match routine. */
 int function_match(void *in_obj, void *key)
 {
         struct m0_kv_store_obj *obj;
-        obj = (struct m0_kv_store_obj *)in_obj;
-        return strcmp(obj->key, (char *)key);
+        long int                in_key;
+
+        obj     = (struct m0_kv_store_obj *)in_obj;
+        in_key  = *(long int *)key;
+
+        return (in_key == obj->key) ? 0 : 1;
 }
 
+/** Object update routine. */
+void function_update(void *old_obj, void *new_obj, struct m0_be_tx *tx)
+{
+        struct m0_kv_store_obj *old;
+        struct m0_kv_store_obj *new;
+
+        /*
+         * Here, the value was not allocated on RVM.
+         * So @tx will not be used in this case.
+         */
+        old = (struct m0_kv_store_obj *)old_obj;
+        new = (struct m0_kv_store_obj *)new_obj;
+
+        old->obj_val = new->obj_val;
+}
 static int ts_kv_store_init()
 {
         struct m0_be_kv_store_cb  *cb_info;
@@ -151,9 +188,13 @@ static int ts_kv_store_init()
         M0_ASSERT(kv_dom != NULL);
 
         /* Create a kv-store handle */
-        m0_be_ks_create(&kv_list_descr, kv_dom,
-                        cmp_routine, match_routine, &handle);
-        M0_ASSERT(handle != NULL);
+        m0_be_ks_create(&kv_list_descr1, kv_dom,
+                        cmp_routine, match_routine, 0, &handle1);
+        M0_ASSERT(handle1 != NULL);
+
+        m0_be_ks_create(&kv_list_descr2, kv_dom,
+                        cmp_routine, match_routine, 1, &handle2);
+        M0_ASSERT(handle2 != NULL);
 
         sm_group = m0_be_domain_sm_group(kv_dom);
 
@@ -164,25 +205,43 @@ static int ts_kv_store_init()
         operation_name = (char *)malloc(10);
         strcpy(operation_name, "KS_INIT");
 
-        cb_info->ksc_cb                 = init_operation_callback;
-        cb_info->ksc_cbdata             = (void *)operation_name;
+        cb_info->ksc_cb      = init_operation_callback;
+        cb_info->ksc_cbdata  = (void *)operation_name;
 
-        /* Initialise the kv-store i.e. create or recover from RVM */
-        m0_be_ks_init(handle, cb_info, "create");
-        m0_be_wait(sm_group, &handle->ks_handle_heap.ksh_sm,
+        /* Create a new segment */
+        /* @todo: segment name is hardcoded for now */
+        M0_ALLOC_PTR(kv_seg);
+        M0_ASSERT(kv_seg != NULL);
+        m0_be_seg_init(kv_seg, kv_dom, sm_group, 0);
+        m0_be_seg_create(kv_seg, NULL, BE_KV_SEG_NAME, NULL);
+        m0_be_wait(sm_group, &kv_seg->bs_sm, M0_BITS(M0_BESEG_ACTIVE,
+                                                     M0_BESEG_FAILED));
+
+        /* Initialise the kv-store i.e. create on RVM */
+        m0_be_ks_init(handle1, cb_info, M0_BE_KS_CREATE);
+        m0_be_wait(sm_group, &handle1->ks_handle_heap.ksh_sm,
+                   M0_BITS(M0_BEKS_DONE));
+        M0_ASSERT(handle1->ks_handle_rvm != NULL);
+
+        operation_name = (char *)malloc(10);
+        strcpy(operation_name, "KS_INIT");
+        cb_info->ksc_cb      = init_operation_callback;
+        cb_info->ksc_cbdata  = (void *)operation_name;
+
+        m0_be_ks_init(handle2, cb_info, M0_BE_KS_CREATE);
+        m0_be_wait(sm_group, &handle2->ks_handle_heap.ksh_sm,
                    M0_BITS(M0_BEKS_DONE));
+        M0_ASSERT(handle2->ks_handle_rvm != NULL);
 
-        M0_ASSERT(handle->ks_handle_rvm != NULL);
         M0_LOG(M0_INFO, "kv_store initialised!");
         m0_free(cb_info);
         return 0;
 }
 
-static int ts_kv_store_fini()
+void ts_kv_store_fini()
 {
         struct m0_be_kv_store_cb  *cb_info;
         char                      *operation_name;
-        int                        rc;
 
         /* Set the callback information */
         M0_ALLOC_PTR(cb_info);
@@ -190,37 +249,42 @@ static int ts_kv_store_fini()
 
         operation_name = (char *)malloc(10);
         strcpy(operation_name, "KS_FINI");
+        cb_info->ksc_cbdata     = (void *)operation_name;
+        cb_info->ksc_cb         = fini_operation_callback;
 
+        m0_be_ks_fini(handle1, cb_info);
+
+        operation_name = (char *)malloc(10);
+        strcpy(operation_name, "KS_FINI");
         cb_info->ksc_cbdata     = (void *)operation_name;
         cb_info->ksc_cb         = fini_operation_callback;
 
-        m0_be_ks_fini(handle, cb_info, kv_seg);
+        m0_be_ks_fini(handle2, cb_info);
 
-        sprintf(kv_cmd, "rm -rf %s", stob_dir);
-        rc = system(kv_cmd);
-        M0_ASSERT(rc == 0);
+        m0_be_seg_done(kv_seg);
 
+        m0_be_domain_fini(kv_dom);
+        m0_free(kv_dom);
+        kv_dom = NULL;
         m0_free(cb_info);
-        return 0;
 }
 
-static int insert(char *key_name, int val)
+static int insert(struct m0_be_kv_store   *handle,
+                  struct m0_kv_store_obj **out_object, int key, int val)
 {
         int32_t                    status  = -2;
         struct m0_be_tx           *tx;
         struct m0_be_reference    *obj_ref;
         struct m0_be_reg          *obj_reg;
         struct m0_be_buf          *obj_buf;
-        struct m0_sm_group        *sm_group;
         struct m0_be_kv_store_cb  *cb_info;
+        struct m0_kv_store_obj    *object;
         char                      *operation_name;
 
-        kv_val = val;
-
         M0_ALLOC_PTR(tx);
 
         if (tx == NULL) {
-                status = BE_KV_FAILURE;
+                status = -ENOMEM;
                 goto exit;
         }
 
@@ -235,24 +299,24 @@ static int insert(char *key_name, int val)
         M0_ALLOC_PTR(obj_buf);
         M0_ASSERT(obj_buf != NULL);
 
-        obj_buf->b_nob = sizeof *object[val];
+        obj_buf->b_nob = sizeof *object;
         m0_be_reg_init(obj_reg, tx, kv_seg, obj_buf);
 
         /* As nothing in credit list, so can start tx directly */
         m0_be_tx_start(tx);
 
         /* Memory alloc to the object via rvm */
-        object[val] = (struct m0_kv_store_obj *)m0_be_ks_obj_malloc(obj_reg,
-                                                                    &obj_ref);
-        if (object[val] == NULL) {
-                status = BE_KV_FAILURE;
+        object = (struct m0_kv_store_obj *)m0_be_ks_obj_malloc(obj_reg,
+                                                               &obj_ref);
+        if (object == NULL) {
+                status = -ENOMEM;
                 goto exit;
         }
         M0_ASSERT(obj_ref != NULL);
 
         /* Make changes to object */
-        strncpy(object[val]->key, key_name, strlen(key_name));
-        object[val]->obj_val = kv_val;
+        object->key     = key;
+        object->obj_val = val;
 
         /* Set the callback information */
         M0_ALLOC_PTR(cb_info);
@@ -266,8 +330,7 @@ static int insert(char *key_name, int val)
 
         /* Insert this into the kv_store */
         status = m0_be_ks_insert(handle, cb_info, obj_ref, tx);
-        if (status == BE_KV_FAILURE || status == BE_KV_OUT_OF_DOMAIN ||
-            status == BE_KV_DUPLICATE)
+        if (status != 0)
                 goto exit;
 
         m0_be_tx_done(tx);
@@ -278,11 +341,13 @@ static int insert(char *key_name, int val)
         m0_free(obj_reg);
         m0_free(obj_buf);
         m0_free(cb_info);
+        *out_object = object;
 exit:
         return status;
 }
 
-static void *find(char *key)
+static struct m0_kv_store_obj *find(struct m0_be_kv_store *handle,
+                                    long int *key)
 {
         struct m0_be_kv_store_cb  *cb_info;
         char                      *operation_name;
@@ -298,31 +363,28 @@ static void *find(char *key)
         cb_info->ksc_cbdata     = (void *)operation_name;
         cb_info->ksc_cb         = find_operation_callback;
 
-        ret_val =  m0_be_ks_find(handle, cb_info, key);
+        ret_val = m0_be_ks_find(handle, cb_info, key);
         m0_free(cb_info);
 
         return ret_val;
 }
 
-static int delete(struct m0_kv_store_obj *target)
+static int delete(struct m0_be_kv_store *handle, struct m0_kv_store_obj *target)
 {
         struct m0_be_tx           *tx = NULL;
         struct m0_be_buf          *obj_buf;
         struct m0_be_reg          *obj_reg = NULL;
-        struct m0_sm_group        *sm_group;
         struct m0_be_kv_store_cb  *cb_info;
         char                      *operation_name;
         int32_t                    ret_val;
 
         M0_ALLOC_PTR(tx);
-
         if (tx == NULL)
-                return BE_KV_FAILURE;
+                return -ENOMEM;
 
         sm_group = m0_be_domain_sm_group(kv_dom);
 
         m0_be_tx_init(tx, kv_dom, 0);
-
         /* Prepare a region for this object */
         M0_ALLOC_PTR(obj_reg);
         M0_ASSERT(obj_reg != NULL);
@@ -336,7 +398,6 @@ static int delete(struct m0_kv_store_obj *target)
         M0_ASSERT(obj_reg != NULL);
 
         m0_be_tx_add_cred(tx, obj_reg);
-
         m0_be_tx_prep(tx);
         m0_be_tx_start(tx);
 
@@ -354,15 +415,8 @@ static int delete(struct m0_kv_store_obj *target)
         ret_val = m0_be_ks_delete(handle, cb_info, (void *)target, tx);
         m0_be_free_helper(kv_dom, tx, target, sizeof *target);
 
-        if (ret_val == BE_KV_SUCCESS) {
-                m0_be_tx_done(tx);
-                m0_be_wait(sm_group, &tx->bt_sm,
-                           M0_BITS(M0_BETX_DONE, M0_BETX_FAILED));
-        } else {
-                M0_LOG(M0_ERROR, "Failed to delete object in kv_store, err %d",
-                       ret_val);
-        }
-
+        m0_be_tx_done(tx);
+        m0_be_wait(sm_group, &tx->bt_sm, M0_BITS(M0_BETX_DONE, M0_BETX_FAILED));
         m0_be_tx_fini(tx);
         m0_free(tx);
         m0_free(obj_reg);
@@ -371,128 +425,361 @@ static int delete(struct m0_kv_store_obj *target)
         return ret_val;
 }
 
-static void __insert(int start, int last, char *obj_name, char *cat_name,
-                     char *cp_name)
+void test_kv_store()
 {
-        int     i;
-        int32_t status;
+        size_t   length;
+        long int i;
+        int32_t  status;
+
+        /*
+         * Lookup for the kv_store segment to be used for allocations while
+         * insertion
+         */
+        sm_group = m0_be_domain_sm_group(kv_dom);
 
-        for(i = start; i < last; i++) {
-                status = insert(obj_name, i);
-                M0_ASSERT(status != BE_KV_FAILURE);
-                M0_ASSERT(status != BE_KV_OUT_OF_DOMAIN);
-                M0_ASSERT(status != BE_KV_DUPLICATE);
+        for (i = 0; i < UT_UB_ITER; i++) {
+                status = insert(handle1, &object1[i], i, i+1);
+                M0_ASSERT(status == 0 && object1[i] != NULL);
 
-                if (strlen(obj_name) < 254)
-                        strcat(obj_name, cat_name);
-                else
-                        strcpy(obj_name, cp_name);
+                status = insert(handle2, &object2[i], i, i+1);
+                M0_ASSERT(status == 0 && object2[i] != NULL);
         }
-}
 
-static void __find(int start, int last, char *obj_name, char *cat_name,
-                   char *cp_name)
-{
-        int i;
+        length = m0_tlist_length(&kv_list_descr1,
+                                 &handle1->ks_handle_rvm->ksr_tlist);
+        M0_ASSERT(length == UT_UB_ITER);
+
+        length = m0_tlist_length(&kv_list_descr2,
+                                 &handle2->ks_handle_rvm->ksr_tlist);
+        M0_ASSERT(length == UT_UB_ITER);
 
-        for(i = start; i < last; i++) {
-                ret_obj[i]  = (struct m0_kv_store_obj *)find(obj_name);
-                M0_ASSERT(ret_obj[i] != NULL);
+        /* Find the inserted objects */
+        for (i = 0; i < UT_UB_ITER; i++) {
+                ret_obj1[i] = find(handle1, &i);
+                M0_ASSERT(ret_obj1[i] != NULL);
 
-                if (strlen(obj_name) < 254)
-                        strcat(obj_name, cat_name);
-                else
-                        strcpy(obj_name, cp_name);
+                ret_obj2[i] = find(handle2, &i);
+                M0_ASSERT(ret_obj2[i] != NULL);
         }
 }
 
-void test_kv_store()
+void test_recover_and_delete()
 {
-        int32_t     status;
-        int         i;
-        bool        ret_dom;
-        size_t      length;
-        char        obj_name[MAX_KEY_SIZE] = "a";
+        kv_key_cmp_t        cmp_routine;
+        kv_key_match_t      match_routine;
+        long int            i;
+        int                 rc;
+        size_t              length;
+        bool                ret_dom;
+
+        cmp_routine   = &function_comp;
+        match_routine = &function_match;
 
         /*
-         * Lookup for the kv_store segment to be used for allocations while
-         * insertion
+         * Recover kv_store handle1.
+         * Segment will be loaded and ready in memory after this.
          */
-        sm_group = m0_be_domain_sm_group(kv_dom);
+        m0_kv_init_helper(&kv_dom, &handle1, &kv_list_descr1, cmp_routine,
+                          match_routine, NULL, M0_BE_KS_RECOVER, 0);
 
-        ret_dom = m0_be_domain_lookup(kv_dom, BE_KV_SEG_NAME, &kv_seg);
-        M0_ASSERT(ret_dom);
-        M0_ASSERT(kv_seg != NULL);
+        length = m0_tlist_length(&kv_list_descr1,
+                                 &handle1->ks_handle_rvm->ksr_tlist);
+        M0_ASSERT(length == UT_UB_ITER);
 
-        strcat(obj_name, "b");
-        __insert(0, 256, obj_name, "a", "akv");
+        sm_group = m0_be_domain_sm_group(kv_dom);
 
-        strcpy(obj_name, "a");
-        strcat(obj_name, "c");
-        __insert(256, 512, obj_name, "b", "bkv");
+        /* Recover kv_store handle2.*/
+        m0_be_ks_create(&kv_list_descr2, kv_dom,
+                        cmp_routine, match_routine, 1, &handle2);
+        M0_ASSERT(handle2 != NULL);
 
-        strcpy(obj_name, "a");
-        strcat(obj_name, "d");
-        __insert(512, 768, obj_name, "c", "ckv");
+        /* Initialise (recover back) handle2. */
+        m0_be_ks_init(handle2, NULL, M0_BE_KS_RECOVER);
+        m0_be_wait(sm_group, &handle2->ks_handle_heap.ksh_sm,
+                   M0_BITS(M0_BEKS_DONE));
+        M0_ASSERT(handle2->ks_handle_rvm != NULL);
 
-        strcpy(obj_name, "a");
-        strcat(obj_name, "e");
-        __insert(768, 1024, obj_name, "d", "dkv");
+        length = m0_tlist_length(&kv_list_descr2,
+                                 &handle2->ks_handle_rvm->ksr_tlist);
+        M0_ASSERT(length == UT_UB_ITER);
 
-        length = m0_tlist_length(&kv_list_descr,
-                                 &handle->ks_handle_rvm->ksr_tlist);
-        M0_ASSERT(length == 1024);
+        for (i = 0; i < length; i++)
+                  ret_obj1[i] = ret_obj2[i] = NULL;
 
         /* Find the inserted objects */
-        strcpy(obj_name, "a");
-        strcat(obj_name, "b");
-
-        __find(0, 256, obj_name, "a", "akv");
-
-        strcpy(obj_name, "a");
-        strcat(obj_name, "c");
-        __find(256, 512, obj_name, "b", "bkv");
+        for (i = 0; i < length; i++) {
+                ret_obj1[i] = find(handle1, &i);
+                M0_ASSERT(ret_obj1[i] != NULL);
 
-        strcpy(obj_name, "a");
-        strcat(obj_name, "d");
-        __find(512, 768, obj_name, "c", "ckv");
+                ret_obj2[i] = find(handle2, &i);
+                M0_ASSERT(ret_obj2[i] != NULL);
+        }
 
-        strcpy(obj_name, "a");
-        strcat(obj_name, "e");
-        __find(768, 1024, obj_name, "d", "dkv");
+        ret_dom = m0_be_domain_lookup(kv_dom, BE_KV_SEG_NAME, &kv_seg);
+        M0_ASSERT(ret_dom);
 
         /* Delete'em */
+        for (i =0; i < length; i++) {
+                rc = delete(handle1, ret_obj1[i]);
+                M0_ASSERT(rc == 0);
 
-        for(i =0; i < 1024; i++) {
-                status = delete(ret_obj[i]);
-                M0_ASSERT(status == BE_KV_SUCCESS);
+                rc = delete(handle2, ret_obj2[i]);
+                M0_ASSERT(rc == 0);
         }
-        length = m0_tlist_length(&kv_list_descr,
-                                 &handle->ks_handle_rvm->ksr_tlist);
+        length = m0_tlist_length(&kv_list_descr1,
+                                 &handle1->ks_handle_rvm->ksr_tlist);
+        M0_ASSERT(length == 0);
 
+        length = m0_tlist_length(&kv_list_descr2,
+                                 &handle2->ks_handle_rvm->ksr_tlist);
         M0_ASSERT(length == 0);
+
+        ts_kv_store_fini();
+
+        sprintf(kv_cmd, "rm -rf %s", stob_dir);
+        rc = system(kv_cmd);
+        M0_ASSERT(rc == 0);
 }
 
+void test_kv_store_update()
+{
+        long int    i;
+        int         rc;
+
+        for (i = 0; i < UT_UB_ITER; i++) {
+                /* Put some new value in the object and keep key intact. */
+                ret_obj1[i]->obj_val = i + 1000;
+                ret_obj2[i]->obj_val = i + 2000;
+                rc = m0_be_ks_update(handle1, NULL, ret_obj1[i],
+                                     sizeof *ret_obj1[i], function_update);
+                rc = m0_be_ks_update(handle2, NULL, ret_obj2[i],
+                                     sizeof *ret_obj2[i], function_update);
+
+                M0_UT_ASSERT(rc == 0);
+        }
+
+        for (i = 0; i < UT_UB_ITER; i++)
+                ret_obj1[i] = ret_obj2[i] = NULL;
+
+        /* Check if value has been updated in kv_store correctly. */
+        for (i = 0; i < UT_UB_ITER; i++) {
+                ret_obj1[i] = find(handle1, &i);
+                M0_ASSERT(ret_obj1[i] != NULL);
+
+                ret_obj2[i] = find(handle2, &i);
+                M0_ASSERT(ret_obj2[i] != NULL);
+        }
+
+        /* Check if new value is found correctly. */
+        for (i = 0; i < UT_UB_ITER; i++) {
+                M0_ASSERT(ret_obj1[i]->obj_val == (i + 1000));
+                M0_ASSERT(ret_obj2[i]->obj_val == (i + 2000));
+        }
+}
+
+/*
+ * Initialise the kv_store, insert, lookup and update the items, then finalize
+ * the store. After finalizing, recover the kv_store and delete previously
+ * inserted items.
+ */
 const struct m0_test_suite be_kv_store_ut = {
-        .ts_name = "be-kv-store-ut",
+        .ts_name = "kvstore-ut",
         .ts_init = ts_kv_store_init,
-        .ts_fini = ts_kv_store_fini,
         .ts_tests = {
-                { "be-kv-store", test_kv_store },
+                { "be-kv-store-ins-find", test_kv_store },
+                { "be-kv-store-update", test_kv_store_update },
+                { "be-kv-store fini", ts_kv_store_fini },
+                { "be-kv-store-recover-delete", test_recover_and_delete },
                 { NULL, NULL },
         }
 };
 
-#if 0
-int main()
+/**
+ * KV Store UB
+ */
+
+struct m0_be_reference      ins_ref[UT_UB_ITER];
+long int                    ref_i      = 0;
+long int                    find_index = 0;
+long int                    del_index = 0;
+long int                    val;
+
+static void ub_kv_insert()
 {
-        ts_kv_store_init();
-        test_kv_store();
-        ts_kv_store_fini();
-        return 0;
+        int32_t                  status;
+        struct m0_be_tx         *tx;
+
+        M0_ALLOC_PTR(tx);
+
+        if (tx == NULL) {
+                status = -ENOMEM;
+                goto exit;
+        }
+
+        sm_group = m0_be_domain_sm_group(kv_dom);
+
+        m0_be_tx_init(tx, kv_dom, 0);
+
+        /* As nothing in credit list, so can start tx directly */
+        m0_be_tx_start(tx);
+
+        /* Insert current object identified by ref_i into the kv_store */
+        status = m0_be_ks_insert(handle1, NULL, &ins_ref[ref_i], tx);
+        if (status != 0) {
+                M0_LOG(M0_FATAL, "Failed to insert object number %ld", ref_i);
+                goto exit;
+        }
+
+        m0_be_tx_done(tx);
+        m0_be_wait(sm_group, &tx->bt_sm,
+                   M0_BITS(M0_BETX_DONE, M0_BETX_FAILED));
+
+        m0_be_tx_fini(tx);
+
+exit:
+        ref_i++;
+        m0_free(tx);
+}
+
+static void ub_kv_find()
+{
+        ret_obj1[find_index] = find(handle1, &find_index);
+        M0_ASSERT(ret_obj1[find_index] != NULL);
+        find_index++;
+}
+
+void ub_kv_delete()
+{
+        int32_t status;
+        status = delete(handle1, ret_obj1[del_index]);
+        M0_ASSERT(status == 0);
+        del_index++;
+}
+
+static void ub_init(void)
+{
+        struct m0_be_tx         *tx;
+        struct m0_be_reference  *obj_ref;
+        struct m0_be_reg        *obj_reg;
+        struct m0_be_buf        *obj_buf;
+        kv_key_cmp_t             cmp_routine;
+        kv_key_match_t           match_routine;
+        bool                     ret_dom;
+
+        cmp_routine   = &function_comp;
+        match_routine = &function_match;
+
+        /* Initialise the kv store. */
+        m0_kv_init_helper(&kv_dom, &handle1, &kv_list_descr1, cmp_routine,
+                          match_routine, NULL, M0_BE_KS_CREATE, 0);
+
+        ret_dom = m0_be_domain_lookup(kv_dom, BE_KV_SEG_NAME, &kv_seg);
+        M0_ASSERT(ret_dom);
+        sm_group = m0_be_domain_sm_group(kv_dom);
+
+        /*
+         * Allocate memory to the objects to be inserted and keep them ready
+         * for insertion
+         */
+        for (val = 0; val < UT_UB_ITER; val++) {
+                M0_ALLOC_PTR(tx);
+                M0_ASSERT(tx != NULL);
+
+                M0_ALLOC_PTR(obj_buf);
+                M0_ASSERT(obj_buf != NULL);
+
+                m0_be_tx_init(tx, kv_dom, 0);
+
+                /* Prepare a region for the object */
+                M0_ALLOC_PTR(obj_reg);
+                M0_ASSERT(obj_reg != NULL);
+
+                obj_buf->b_nob = sizeof *object1[val];
+                m0_be_reg_init(obj_reg, tx, kv_seg, obj_buf);
+
+                /* As nothing in credit list, so can start tx directly */
+                m0_be_tx_start(tx);
+
+                /* Memory alloc to the object via rvm */
+                obj_ref = NULL;
+                object1[val] = (struct m0_kv_store_obj *)
+                                m0_be_ks_obj_malloc(obj_reg, &obj_ref);
+
+                if (object1[val] == NULL) {
+                        M0_LOG(M0_FATAL,
+                               "Failed to allocate memory to object number %ld",
+                               val);
+                }
+
+                M0_ASSERT(obj_ref != NULL);
+
+                /* This will be used for insertion */
+                ins_ref[val] = *obj_ref;
+
+                /* Make changes to object */
+                object1[val]->key     = val;
+                object1[val]->obj_val = val;
+
+                m0_be_tx_done(tx);
+                m0_be_wait(sm_group, &tx->bt_sm,
+                           M0_BITS(M0_BETX_DONE, M0_BETX_FAILED));
+
+                m0_be_tx_fini(tx);
+
+                m0_free(tx);
+                m0_free(obj_reg);
+                m0_free(obj_buf);
+        }
+
 }
-#endif
+
+static void ub_fini()
+{
+        size_t  length;
+        int     rc;
+
+        /* To ensure that deletion was successful */
+        length = m0_tlist_length(&kv_list_descr1,
+                                 &handle1->ks_handle_rvm->ksr_tlist);
+        M0_ASSERT(length == 0);
+
+        sm_group = m0_be_domain_sm_group(kv_dom);
+
+        m0_be_ks_fini(handle1, NULL);
+        m0_be_seg_done(kv_seg);
+        m0_be_domain_fini(kv_dom);
+        m0_free(kv_dom);
+
+        sprintf(kv_cmd, "rm -rf %s", stob_dir);
+        rc = system(kv_cmd);
+        M0_ASSERT(rc == 0);
+        M0_LOG(M0_INFO, "kv_store finilise");
+}
+
+struct m0_ub_set m0_kvstore_ub = {
+	.us_name = "kvstore-ub",
+	.us_init = ub_init,
+	.us_fini = ub_fini,
+	.us_run  = {
+		{ .ut_name  = "kv-store-insert",
+		  .ut_iter  = UT_UB_ITER,
+		  .ut_round = ub_kv_insert },
+
+		{ .ut_name  = "kv-store-find",
+		  .ut_iter  = UT_UB_ITER,
+		  .ut_round = ub_kv_find },
+
+		{ .ut_name  = "kv-store-delete",
+		  .ut_iter  = UT_UB_ITER,
+		  .ut_round = ub_kv_delete },
+
+		{ .ut_name = NULL }
+	}
+};
+
 #undef M0_TRACE_SUBSYSTEM
+
+
 /** @} end group be_ut */
 
 /*
diff --git a/be/ut/kv_store_ub.c b/be/ut/kv_store_ub.c
deleted file mode 100644
index 5d26a18..0000000
--- a/be/ut/kv_store_ub.c
+++ /dev/null
@@ -1,400 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2013 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Zishan Shaikh <zishan_shaikh@xyratex.com>
- * Original creation date: 02/08/2013
- */
-
-#undef M0_TRACE_SUBSYSTEM
-#define M0_TRACE_SUBSYSTEM M0_TRACE_SUBSYS_BE
-#include "lib/trace.h"
-#include "lib/ub.h"
-#include "lib/ut.h"
-#include "be/kv_store.h"
-#include "be/be_private.h"
-#include "be/handle_store.h"
-#include "be/helper.h"
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-
-enum {
-	UB_ITER   = 1000,
-};
-
-
-/** User defined structure. */
-struct m0_kv_store_obj {
-        long int                key;
-        long int                obj_val;
-        struct m0_tlink         linkage;
-        uint64_t                magic;
-};
-
-struct m0_tl_descr kv_list_descr = M0_TL_DESCR("kv_store_obj",
-                                                struct m0_kv_store_obj,
-                                                linkage,
-                                                magic,
-                                                0xab5ce55edba1b0a0,
-                                                0xba1dba11adba0bab);
-
-struct m0_be_domain        *kv_dom;
-struct m0_be_seg           *kv_seg;
-struct m0_kv_store_obj     *object[UB_ITER]   = {NULL};
-struct m0_kv_store_obj     *ret_obj[UB_ITER]  = {NULL};
-struct m0_be_kv_store      *handle         = NULL;
-struct m0_be_kv_store_rvm  *handle_rvm     = NULL;
-struct m0_sm_group         *sm_group;
-struct m0_be_reference      ins_ref[UB_ITER];
-
-static const char          *stob_dir  = "./__be/o";
-static const char          *stob_file = "0000000000000000.0000000000000001";
-extern const char          *log_file;
-char                        kv_cmd[1024];
-long int                    ref_i      = 0;
-long int                    find_index = 0;
-long int                    del_index = 0;
-long int                    val;
-
-/** Callback function to be called after operation completion. */
-void init_operation_callback(void *operation_name, void *result, int rc)
-{
-        m0_free(operation_name);
-}
-
-/** Callback function to be called after operation completion. */
-void fini_operation_callback(void *operation_name, void *result, int rc)
-{
-        m0_free(operation_name);
-}
-
-/** Callback function to be called after operation completion. */
-void insert_operation_callback(void *operation_name, void *result, int rc)
-{
-        M0_ASSERT(rc == BE_KV_SUCCESS);
-        m0_free(operation_name);
-}
-
-/** Callback function to be called after operation completion. */
-void find_operation_callback(void *operation_name, void *result, int rc)
-{
-        M0_ASSERT(rc == BE_KV_SUCCESS);
-        ret_obj[find_index]  = (struct m0_kv_store_obj *)result;
-        M0_ASSERT(ret_obj[find_index] != NULL);
-        find_index++;
-        m0_free(operation_name);
-}
-
-/** Callback function to be called after operation completion. */
-void delete_operation_callback(void *operation_name, void *result, int rc)
-{
-        M0_ASSERT(rc == BE_KV_SUCCESS);
-        m0_free(operation_name);
-}
-
-/** Key compare routine. */
-int function_comp(void *key1, void *key2)
-{
-        int ret_val = 1;
-
-        if (*(long int *)key1 == *(long int *)key2)
-                ret_val = 0;
-        else if (*(long int *)key1 < *(long int *)key2)
-                ret_val = -1;
-
-        return ret_val;
-}
-
-/** Match routine. */
-int function_match(void *in_obj, void *key)
-{
-        struct m0_kv_store_obj *obj;
-        long int                in_key;
-
-        obj     = (struct m0_kv_store_obj *)in_obj;
-        in_key  = *(long int *)key;
-
-        return (in_key == obj->key) ? 0 : 1;
-}
-
-static void ub_kv_insert()
-{
-        int32_t                  status;
-        struct m0_be_tx         *tx;
-
-        M0_ALLOC_PTR(tx);
-
-        if (tx == NULL) {
-                status = BE_KV_FAILURE;
-                goto exit;
-        }
-
-        sm_group = m0_be_domain_sm_group(kv_dom);
-
-        m0_be_tx_init(tx, kv_dom, 0);
-
-        /* As nothing in credit list, so can start tx directly */
-        m0_be_tx_start(tx);
-
-        /* Insert current object identified by ref_i into the kv_store */
-        status = m0_be_ks_insert(handle, NULL, &ins_ref[ref_i], tx);
-        if (status == BE_KV_FAILURE || status == BE_KV_OUT_OF_DOMAIN ||
-            status == BE_KV_DUPLICATE) {
-                M0_LOG(M0_FATAL, "Failed to insert object number %ld", ref_i);
-                goto exit;
-        }
-
-        m0_be_tx_done(tx);
-        m0_be_wait(sm_group, &tx->bt_sm,
-                   M0_BITS(M0_BETX_DONE, M0_BETX_FAILED));
-
-        m0_be_tx_fini(tx);
-
-exit:
-        ref_i++;
-        m0_free(tx);
-}
-
-static void ub_kv_find()
-{
-        struct m0_be_kv_store_cb        *cb_info;
-        char                            *operation_name;
-        M0_ALLOC_PTR(cb_info);
-
-        operation_name = (char *)malloc(10);
-        strcpy(operation_name, "KS_FIND");
-
-        cb_info->ksc_cbdata     = (void *)operation_name;
-        cb_info->ksc_cb         = find_operation_callback;
-
-        m0_be_ks_find(handle, cb_info, &find_index);
-        m0_free(cb_info);
-}
-
-static int __delete(struct m0_kv_store_obj *target)
-{
-        struct m0_be_tx      *tx = NULL;
-        struct m0_be_buf     *obj_buf;
-        struct m0_be_reg     *obj_reg = NULL;
-        int32_t               ret_val;
-
-        M0_ALLOC_PTR(tx);
-
-        if (tx == NULL)
-                return BE_KV_FAILURE;
-
-        M0_ALLOC_PTR(obj_buf);
-
-        M0_ASSERT(obj_buf != NULL);
-
-        sm_group = m0_be_domain_sm_group(kv_dom);
-
-        m0_be_tx_init(tx, kv_dom, 0);
-
-        /* Prepare a region for this object */
-        M0_ALLOC_PTR(obj_reg);
-        M0_ASSERT(obj_reg != NULL);
-        obj_buf->b_nob = sizeof(struct m0_kv_store_obj);
-        obj_buf->b_addr = (void *)target;
-        m0_be_reg_init(obj_reg, tx, kv_seg, obj_buf);
-        M0_ASSERT(obj_reg != NULL);
-
-        m0_be_tx_add_cred(tx, obj_reg);
-
-        m0_be_tx_prep(tx);
-        m0_be_tx_start(tx);
-
-        /* Delete this obj from kv store */
-        ret_val = m0_be_ks_delete(handle, NULL, (void *)target, tx);
-
-        if (ret_val != BE_KV_FAILURE) {
-                m0_be_tx_done(tx);
-                m0_be_wait(sm_group, &tx->bt_sm,
-                           M0_BITS(M0_BETX_DONE, M0_BETX_FAILED));
-
-                ret_val = BE_KV_SUCCESS;
-        }
-
-        m0_be_tx_fini(tx);
-        m0_free(tx);
-        m0_free(obj_reg);
-        m0_free(obj_buf);
-        return ret_val;
-}
-
-void ub_kv_delete()
-{
-        int32_t status;
-        status = __delete(ret_obj[del_index]);
-        M0_ASSERT(status == BE_KV_SUCCESS);
-        del_index++;
-}
-
-static void ub_init(void)
-{
-        struct m0_be_tx         *tx;
-        struct m0_be_reference  *obj_ref;
-        struct m0_be_reg        *obj_reg;
-        struct m0_be_buf        *obj_buf;
-        struct m0_sm_group      *sm_group;
-        bool                     ret_dom;
-        int                      rc;
-
-        M0_LOG(M0_DEBUG,"KV Store Initialization");
-        sprintf(kv_cmd, "rm -rf %s", log_file);
-        rc = system(kv_cmd);
-        M0_ASSERT(rc == 0);
-
-        sprintf(kv_cmd, "mkdir -p %s", stob_dir);
-        rc = system(kv_cmd);
-        M0_ASSERT(rc == 0);
-
-        sprintf(kv_cmd,
-                "dd if=/dev/zero of=%s/%s bs=1024 count=133120 2>/dev/null",
-                stob_dir, stob_file);
-        rc = system(kv_cmd);
-        M0_ASSERT(rc == 0);
-
-        kv_key_cmp_t     cmp_routine;
-        kv_key_match_t   match_routine;
-
-        cmp_routine   = &function_comp;
-        match_routine = &function_match;
-
-        m0_be_ks_init_domain(&kv_dom);
-        M0_ASSERT(kv_dom != NULL);
-
-        /* Create a kv-store handle */
-        m0_be_ks_create(&kv_list_descr, kv_dom,
-                        cmp_routine, match_routine, &handle);
-        M0_ASSERT(handle != NULL);
-
-        sm_group = m0_be_domain_sm_group(kv_dom);
-
-        /* Initialise the kv-store i.e. create or recover from RVM */
-        m0_be_ks_init(handle, NULL, "create");
-        m0_be_wait(sm_group, &handle->ks_handle_heap.ksh_sm,
-                   M0_BITS(M0_BEKS_DONE));
-
-        M0_ASSERT(handle->ks_handle_rvm != NULL);
-
-        ret_dom = m0_be_domain_lookup(kv_dom, BE_KV_SEG_NAME, &kv_seg);
-        M0_ASSERT(ret_dom);
-        M0_ASSERT(kv_seg != NULL);
-
-        /*
-         * Allocate memory to the objects to be inserted and keep them ready
-         * for insertion
-         */
-        for(val = 0; val < UB_ITER; val++) {
-                M0_ALLOC_PTR(tx);
-                M0_ASSERT(tx != NULL);
-
-                M0_ALLOC_PTR(obj_buf);
-                M0_ASSERT(obj_buf != NULL);
-
-                m0_be_tx_init(tx, kv_dom, 0);
-
-                /* Prepare a region for the object */
-                M0_ALLOC_PTR(obj_reg);
-                M0_ASSERT(obj_reg != NULL);
-
-                obj_buf->b_nob = sizeof *object[val];
-                m0_be_reg_init(obj_reg, tx, kv_seg, obj_buf);
-
-                /* As nothing in credit list, so can start tx directly */
-                m0_be_tx_start(tx);
-
-                /* Memory alloc to the object via rvm */
-                obj_ref = NULL;
-                object[val] = (struct m0_kv_store_obj *)
-                               m0_be_ks_obj_malloc(obj_reg, &obj_ref);
-
-                if (object[val] == NULL) {
-                        M0_LOG(M0_FATAL,
-                               "Failed to allocate memory to object number %ld",
-                               val);
-                }
-
-                M0_ASSERT(obj_ref != NULL);
-
-                /* This will be used for insertion */
-                ins_ref[val] = *obj_ref;
-
-                /* Make changes to object */
-                object[val]->key     = val;
-                object[val]->obj_val = val;
-
-                m0_be_tx_done(tx);
-                m0_be_wait(sm_group, &tx->bt_sm,
-                           M0_BITS(M0_BETX_DONE, M0_BETX_FAILED));
-
-                m0_be_tx_fini(tx);
-
-                m0_free(tx);
-                m0_free(obj_reg);
-                m0_free(obj_buf);
-        }
-
-}
-
-static void ub_fini()
-{
-        int    rc;
-        size_t length;
-
-        /* To ensure that deletion was successful */
-        length = m0_tlist_length(&kv_list_descr,
-                                 &handle->ks_handle_rvm->ksr_tlist);
-        M0_ASSERT(length == 0);
-
-        m0_be_ks_fini(handle, NULL, kv_seg);
-
-        sprintf(kv_cmd, "rm -rf %s", stob_dir);
-        rc = system(kv_cmd);
-        M0_ASSERT(rc == 0);
-        M0_LOG(M0_INFO, "kv_store finilise");
-}
-
-struct m0_ub_set m0_kvstore_ub = {
-	.us_name = "kvstore-ub",
-	.us_init = ub_init,
-	.us_fini = ub_fini,
-	.us_run  = {
-		{ .ut_name  = "kv-store-insert",
-		  .ut_iter  = UB_ITER,
-		  .ut_round = ub_kv_insert },
-
-		{ .ut_name  = "kv-store-find",
-		  .ut_iter  = UB_ITER,
-		  .ut_round = ub_kv_find },
-
-		{ .ut_name  = "kv-store-delete",
-		  .ut_iter  = UB_ITER,
-		  .ut_round = ub_kv_delete },
-
-		{ .ut_name = NULL }
-	}
-};
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
diff --git a/cob/cob.c b/cob/cob.c
index 9af4c74..2b9f107 100644
--- a/cob/cob.c
+++ b/cob/cob.c
@@ -38,6 +38,7 @@
 /** Declarations needed for kv_store integration. */
 #include "be/helper.h"
 #include "be/kv_store.h"
+extern const char BE_KV_SEG_NAME[];
 
 /**
    @addtogroup cob
@@ -395,8 +396,8 @@ static char *cob_dom_id_make(char *buf, const struct m0_cob_domain_id *id,
 }
 
 #ifndef __KERNEL__
-void __cob_nsrec_kv_store_init(struct m0_be_kv_store **handle,
-                               const char             *init_mode)
+void __cob_nsrec_kv_store_init(struct m0_be_kv_store    **handle,
+                               enum   m0_be_ks_init_mode  init_mode)
 {
         kv_key_cmp_t   cmp_routine;
         kv_key_match_t match_routine;
@@ -405,17 +406,19 @@ void __cob_nsrec_kv_store_init(struct m0_be_kv_store **handle,
         match_routine   = m0_cob_kv_ns_match;
 
         m0_kv_init_helper(&cob_be_domain, handle, &cob_ns_list_descr,
-                          cmp_routine, match_routine, NULL, init_mode);
+                          cmp_routine, match_routine, NULL, init_mode, 0);
 }
 #endif
 
-int m0_cob_domain_init_recovery(struct m0_cob_domain *dom, struct m0_dbenv *env,
-		                const struct m0_cob_domain_id *id)
+M0_INTERNAL int m0_cob_domain_init_recovery(struct m0_cob_domain *dom,
+                                            struct m0_dbenv *env,
+		                            const struct m0_cob_domain_id *id)
 {
 
 #ifndef __KERNEL__
         if (cob_be_domain == NULL) {
-                __cob_nsrec_kv_store_init(&dom->cd_kvnamespace, "recover");
+                __cob_nsrec_kv_store_init(&dom->cd_kvnamespace,
+                                          M0_BE_KS_RECOVER);
         }
 
         M0_ASSERT(cob_be_domain != NULL);
@@ -445,7 +448,8 @@ int m0_cob_domain_init(struct m0_cob_domain *dom, struct m0_dbenv *env,
 #ifndef __KERNEL__
         /* Initialise be_domain for kv_store */
         if (cob_be_domain == NULL) {
-                __cob_nsrec_kv_store_init(&dom->cd_kvnamespace, "create");
+                __cob_nsrec_kv_store_init(&dom->cd_kvnamespace,
+                                          M0_BE_KS_CREATE);
         }
 #endif
 
@@ -492,7 +496,18 @@ void m0_cob_domain_fini(struct m0_cob_domain *dom)
 {
 #ifndef __KERNEL__
         /* Fini kv_store for nsrec. Finis cob_be_domain as well*/
-        m0_be_ks_fini_helper(dom->cd_kvnamespace, cob_be_domain);
+        struct m0_be_seg *kv_seg;
+        bool              ret_dom;
+
+        ret_dom = m0_be_domain_lookup(cob_be_domain, BE_KV_SEG_NAME, &kv_seg);
+        M0_ASSERT(ret_dom);
+        M0_ASSERT(kv_seg != NULL);
+        m0_be_seg_done(kv_seg);
+
+        m0_be_domain_fini(cob_be_domain);
+
+        m0_free(cob_be_domain);
+        m0_be_ks_fini(dom->cd_kvnamespace, NULL);
         cob_be_domain = NULL;
 #endif
 
@@ -1396,15 +1411,15 @@ M0_INTERNAL int m0_cob_update(struct m0_cob *cob,
                  */
                 rc = m0_be_ks_pair_setup(cob_be_domain, cob->co_nskey, nsrec,
                                          NULL, &kv_pair, NULL,
-                                         KS_PAIR_ON_HEAP);
+                                         M0_BE_KS_PAIR_HEAP);
 
-                M0_ASSERT(rc == BE_KV_SUCCESS);
+                M0_ASSERT(rc == 0);
                 M0_ASSERT(kv_pair  != NULL);
 
                 rc = m0_be_ks_update(handle, NULL, kv_pair, sizeof *kv_pair,
                                      m0_be_kv_cob_pair_copy);
 
-                if (rc != BE_KV_SUCCESS)
+                if (rc != 0)
                         goto out;
 
                 m0_free(kv_pair);
@@ -1497,8 +1512,8 @@ M0_INTERNAL int m0_cob_name_add(struct m0_cob *cob,
         M0_ASSERT(be_tx != NULL);
 
         rc = m0_be_ks_pair_setup(cob_be_domain, nskey, nsrec, &be_tx, &kv_pair,
-                                 &pair_ref, KS_PAIR_ON_RVM);
-        M0_ASSERT(rc == BE_KV_SUCCESS);
+                                 &pair_ref, M0_BE_KS_PAIR_RVM);
+        M0_ASSERT(rc == 0);
         M0_ASSERT(kv_pair  != NULL);
         M0_ASSERT(pair_ref != NULL);
 
@@ -1546,7 +1561,7 @@ M0_INTERNAL int m0_cob_name_del(struct m0_cob *cob,
         /* Now delete pair ultimately in cob->co_pair. */
         rc = m0_kv_delete_helper(cob->co_dom->cd_kvnamespace, cob->co_pair,
                                  sizeof *cob->co_pair);
-        M0_ASSERT(rc == BE_KV_SUCCESS);
+        M0_ASSERT(rc == 0);
 
         /* Delete key, value and pair from RVM */
         M0_ALLOC_PTR(be_tx);
diff --git a/cob/cob.h b/cob/cob.h
index d86cd30..ac3970d 100644
--- a/cob/cob.h
+++ b/cob/cob.h
@@ -293,8 +293,9 @@ int m0_cob_domain_init(struct m0_cob_domain *dom, struct m0_dbenv *env,
 /**
   Recovers kv_store for nsrec and then calls m0_cob_domain_init.
  */
-int m0_cob_domain_init_recovery(struct m0_cob_domain *dom, struct m0_dbenv *env,
-		                const struct m0_cob_domain_id *id);
+M0_INTERNAL int m0_cob_domain_init_recovery(struct m0_cob_domain *dom,
+                                            struct m0_dbenv      *env,
+		                            const struct m0_cob_domain_id *id);
 
 void m0_cob_domain_fini(struct m0_cob_domain *dom);
 
diff --git a/cob/ut/cob.c b/cob/ut/cob.c
index f875c7f..7eb72bc 100644
--- a/cob/ut/cob.c
+++ b/cob/ut/cob.c
@@ -93,7 +93,8 @@ static void test_fini(void)
 /* Just recover the kv_store for nsrec. */
 static void test_recovery_nsrec_kvstore(void)
 {
-        int                     rc;
+        char  kv_cmd[1024];
+        char *stob_dir = "/tmp/__be/o";
 
         rc = m0_dbenv_init(&db, db_name, 0);
         M0_UT_ASSERT(rc == 0);
@@ -101,6 +102,11 @@ static void test_recovery_nsrec_kvstore(void)
         rc = m0_cob_domain_init_recovery(&dom, &db, &id);
         M0_UT_ASSERT(rc == 0);
         test_fini();
+
+        /* Remove the data file. */
+        sprintf(kv_cmd, "rm -rf %s", stob_dir);
+        rc = system(kv_cmd);
+        M0_ASSERT(rc == 0);
 }
 
 static void test_create(void)
diff --git a/utils/ut_main.c b/utils/ut_main.c
index 13367d0..01e48c6 100644
--- a/utils/ut_main.c
+++ b/utils/ut_main.c
@@ -99,8 +99,8 @@ void add_uts(void)
         /*m0_ut_add(&rvm_ut);*/
         /*m0_ut_add(&be_hs_ut);*/
         m0_ut_add(&be_kv_store_ut);
-        /*m0_ut_add(&be_ut);*/
-	m0_ut_add(&balloc_ut);
+        m0_ut_add(&be_ut);
+        m0_ut_add(&balloc_ut);
         m0_ut_add(&buffer_pool_ut);
         m0_ut_add(&bulkio_client_ut);
         m0_ut_add(&bulkio_server_ut);
-- 
1.8.3.2

