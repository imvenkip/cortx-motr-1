From 691784d8154e22e1290997c725bb560e51e55da2 Mon Sep 17 00:00:00 2001
From: Prashant Dhange <prashant_dhange@xyratex.com>
Date: Tue, 28 May 2013 02:11:03 -0700
Subject: [PATCH 102/121] Added async support for open_log, fixed issues

---
 rvm/rvm_init.c      |   4 +-
 rvm/rvm_io.c        |  95 ++++++++++-
 rvm/rvm_logrecovr.c |   4 +-
 rvm/rvm_logstatus.c | 474 +++++++++++++++++++++++++++++++++++++---------------
 rvm/rvm_private.h   |   6 +
 5 files changed, 433 insertions(+), 150 deletions(-)

diff --git a/rvm/rvm_init.c b/rvm/rvm_init.c
index 97af6ba..37b60e4 100644
--- a/rvm/rvm_init.c
+++ b/rvm/rvm_init.c
@@ -95,7 +95,7 @@ void do_rvm_options_post_cb(struct m0_be_cbinfo *cbinfo, int status,
 	printf("\n function : %s\n", __func__);
         /* take care of default log */
         if (default_log == NULL) {
-		if ((retval=do_log_options(NULL,
+		if ((retval = do_log_options(NULL,
                                            rvm_options,
                                            cbinfo)) != RVM_SUCCESS) {
 			printf("do_rvm_options failed\n");
@@ -183,7 +183,7 @@ rvm_return_t rvm_initialize(const char *rvm_version, rvm_options_t *rvm_options,
         goto exit;
     }
 
-	rvm_create_log_cb(ri_cbinfo, status, msg_type);
+    rvm_create_log_cb(ri_cbinfo, status, msg_type);
 
 exit:
         if ((status != 0 || !rvm_options->create_log_file) &&
diff --git a/rvm/rvm_io.c b/rvm/rvm_io.c
index e4abae3..7b2eec1 100644
--- a/rvm/rvm_io.c
+++ b/rvm/rvm_io.c
@@ -639,11 +639,11 @@ long read_stob(dev,offset,dest,length)
 }
 
 /* read bytes from device or file */
-long read_dev(dev,offset,dest,length)
-    device_t        *dev;               /* device descriptor */
-    rvm_offset_t    *offset;            /* device offset */
-    char            *dest;              /* address of data destination */
-    rvm_length_t    length;             /* length of transfer */
+long read_dev_old(dev,offset,dest,length)
+    device_t        	  *dev;               /* device descriptor */
+    rvm_offset_t    	  *offset;            /* device offset */
+    char            	  *dest;              /* address of data destination */
+    rvm_length_t    	   length;             /* length of transfer */
     {
         rvm_offset_t    last_position;
         long            nbytes;
@@ -704,6 +704,74 @@ long read_dev(dev,offset,dest,length)
             return retval;
        }
     }
+
+/* read bytes from device or file */
+long read_dev(dev,offset,dest,length,cbinfo)
+    device_t        	  *dev;               /* device descriptor */
+    rvm_offset_t    	  *offset;            /* device offset */
+    char            	  *dest;              /* address of data destination */
+    rvm_length_t    	   length;             /* length of transfer */
+    struct m0_be_cbinfo   *cbinfo;
+    {
+        rvm_offset_t    last_position;
+        long            nbytes;
+        long            read_len;
+        long            retval;
+
+
+        if(dev->stob_io) {
+            return read_stob_new(dev, offset, dest, length, cbinfo);
+        }
+        else {
+            assert(dev->handle != ZERO);
+            assert(length != 0);
+            assert((dev->raw_io) ? (SECTOR_INDEX(length) == 0) : 1);
+            assert(((dev == &default_log->dev) && (!rvm_utlsw)) ?
+                   (!LOCK_FREE(default_log->dev_lock)) : 1);
+
+            /* seek if necessary */
+            errno = 0;
+            if ((retval = chk_seek(dev,offset)) < 0)
+                return retval; last_position = RVM_ADD_LENGTH_TO_OFFSET(dev->last_position,
+                                                     length);
+            assert(RVM_OFFSET_EQL_ZERO(*offset) ? 1
+                   : RVM_OFFSET_LEQ(last_position,dev->num_bytes));
+
+            /* do read in larg-ish blocks to avoid kernel buffer availability problems
+               also zero region if /dev/null being read */
+            retval = 0;
+            while (length != 0)
+                {
+                if (length <= rvm_max_read_len)
+        		read_len = length;
+                else
+        		read_len = rvm_max_read_len;
+        	nbytes=read((int)dev->handle,dest,(int)read_len);
+                if (nbytes < 0) {
+        		rvm_errdev = dev;
+        		rvm_ioerrno = errno;
+        		return nbytes;
+        	}
+                if (nbytes == 0)                /* force a cheap negative test */
+                    if (rvm_utlsw && dev->raw_io) /* since rarely used */
+                        if (!strcmp(dev->name,"/dev/null"))
+                            {
+                            retval = length;
+                            BZERO(dest,length); /* zero the read region */
+                            break;
+                            }
+                assert((dev->raw_io) ? (nbytes == read_len) : 1);
+                retval += nbytes;
+                dest += nbytes;
+                length -= nbytes;
+                }
+
+            /* update position */
+            dev->last_position = RVM_ADD_LENGTH_TO_OFFSET(dev->last_position,
+                                                          retval);
+            return retval;
+       }
+    }
 void write_dev_post_async(cbinfo, status, msg_type)
         struct m0_be_cbinfo     *cbinfo;
         int                      status;
@@ -731,7 +799,7 @@ void write_dev_post_async(cbinfo, status, msg_type)
 exit:
         if (cbinfo->bc_pcbinfo != NULL && cbinfo->bc_pcbinfo->bc_cb != NULL) {
                 m0_be_handler_post(cbinfo->bc_pcbinfo, status, msg_type);
-                m0_free(tx_cbdata);
+		m0_free(tx_cbdata);
         }
 }
 /* write bytes to device or file */
@@ -753,6 +821,7 @@ long write_dev(dev,offset,src,length,sync,cbinfo)
     uint32_t        iter_count = 0;
     rvm_tx_cbdata_t      *rtx_data;
     struct m0_be_cbinfo  *rtxc_cbinfo;
+    m0_be_msg_type_t	  msg_type=M0_BE_SUCCESS;
 
         printf("\nfunction : %s\n", __FUNCTION__);
 
@@ -765,8 +834,10 @@ long write_dev(dev,offset,src,length,sync,cbinfo)
 
     /* seek if necessary */
     errno = 0;
-    if ((retval = chk_seek(dev,offset)) < 0)
-	return retval;
+    if ((retval = chk_seek(dev,offset)) < 0) {
+    	msg_type = RVM_EIO;
+	goto exit;
+    }
 
     M0_ALLOC_PTR(rtx_data);
     M0_ASSERT(rtx_data != NULL);
@@ -833,6 +904,12 @@ long write_dev(dev,offset,src,length,sync,cbinfo)
         dev->last_position = RVM_ADD_LENGTH_TO_OFFSET(dev->last_position,
                                                   wrt_len);
      }
+  }
+exit:
+        if (retval != 0 && cbinfo->bc_pcbinfo != NULL &&
+	    cbinfo->bc_pcbinfo->bc_cb != NULL) {
+                m0_be_handler_post(cbinfo->bc_pcbinfo, retval, msg_type);
+                m0_free(rtx_data);
     }
      return wrt_len;
 }
@@ -1054,7 +1131,7 @@ static long gather_write_stob(dev, offset, wrt_len, cbinfo)
     M0_ASSERT(rtx_data != NULL);
 
     rtxc_cbinfo             = &rtx_data->rtc_cbinfo;
-    rtx_data->rtc_dev	    = dev;
+    rtx_data->rtc_dev       = dev;
     rtx_data->rtc_io_offset = io_offset;
     rtx_data->rtc_io_addr   = io_addr;
     rtx_data->rtc_io_count  = io_count;
diff --git a/rvm/rvm_logrecovr.c b/rvm/rvm_logrecovr.c
index c19b14e..6f817ed 100644
--- a/rvm/rvm_logrecovr.c
+++ b/rvm/rvm_logrecovr.c
@@ -253,8 +253,8 @@ rvm_return_t init_buffer(log,offset,direction,synch)
  */
 
     /* read data from log device */
-    if ((log_buf->r_length=read_dev(&log->dev,&log_buf->offset,
-                                   log_buf->buf,length)) < 0)
+    if ((log_buf->r_length=read_dev_old(&log->dev,&log_buf->offset,
+                                        log_buf->buf,length)) < 0)
         {
         retval = RVM_EIO;               /* i/o error */
         log_buf->r_length = 0;          /* buffer invalid */
diff --git a/rvm/rvm_logstatus.c b/rvm/rvm_logstatus.c
index 9bfc9c5..68b1941 100644
--- a/rvm/rvm_logstatus.c
+++ b/rvm/rvm_logstatus.c
@@ -309,38 +309,161 @@ rvm_return_t close_all_logs()
 
     return retval;
     }
-/* pre-load log raw i/o gather write buffer with tail log sector */
-static rvm_return_t preload_wrt_buf(log)
-    log_t           *log;               /* log descriptor */
-    {
-    device_t        *dev = &log->dev;   /* device descriptor ptr */
-    log_status_t    *status = &log->status; /* log status descriptor */
-    rvm_offset_t    tail_sector;        /* log tail sector */
+void pwb_read_dev_cb(struct m0_be_cbinfo *cbinfo, int be_status,
+                     m0_be_msg_type_t msg_type)
+{
+    log_t             *log;
+    device_t          *dev = NULL;   /* device descriptor ptr */
+    log_status_t      *status = NULL; /* log status descriptor */
+    rcl_cbdata_t      *rcl_cbdata;
 
-    tail_sector = CHOP_OFFSET_TO_SECTOR_SIZE(status->log_tail);
-    if (read_dev(dev,&tail_sector,dev->wrt_buf,SECTOR_SIZE) < 0)
-        return RVM_EIO;
+    if(be_status != 0)
+     	goto exit;
+    rcl_cbdata  = container_of(cbinfo, rcl_cbdata_t, rclc_cbinfo);
+    log         = rcl_cbdata->rclc_log;
 
+    status   = &log->status;
+    dev      = &log->dev;
     dev->ptr = RVM_ADD_LENGTH_TO_ADDR(dev->wrt_buf,
                    OFFSET_TO_SECTOR_INDEX(status->log_tail));
     dev->buf_start = dev->ptr;
     dev->sync_offset = status->log_tail;
 
+exit:
+     if (cbinfo->bc_pcbinfo != NULL &&
+         cbinfo->bc_pcbinfo->bc_cb != NULL) {
+             printf("\nErr function : %s\n", __FUNCTION__);
+             m0_be_handler_post(cbinfo->bc_pcbinfo, be_status, msg_type);
+     }
+     m0_free(rcl_cbdata);
+}
+/* pre-load log raw i/o gather write buffer with tail log sector */
+static rvm_return_t preload_wrt_buf(log,cbinfo)
+    log_t           	 *log;               /* log descriptor */
+    struct m0_be_cbinfo  *cbinfo;
+    {
+    device_t              *dev = &log->dev;   /* device descriptor ptr */
+    log_status_t          *status = &log->status; /* log status descriptor */
+    rvm_offset_t           tail_sector;        /* log tail sector */
+    rcl_cbdata_t          *rcl_cbdata;
+    struct m0_be_cbinfo   *rcl_cbinfo;
+    m0_be_msg_type_t       msg_type = M0_BE_SUCCESS;
+    int		           be_status = 0;
+
+    M0_ALLOC_PTR(rcl_cbdata);
+    M0_ASSERT(rcl_cbdata != NULL);
+
+    rcl_cbdata->rclc_log                = log;
+
+    rcl_cbinfo                          = &rcl_cbdata->rclc_cbinfo;
+    m0_be_cbinfo_copy_helper(cbinfo, rcl_cbinfo, pwb_read_dev_cb);
+
+    tail_sector = CHOP_OFFSET_TO_SECTOR_SIZE(status->log_tail);
+    if (read_dev(dev,&tail_sector,
+    		 dev->wrt_buf,SECTOR_SIZE, rcl_cbinfo) < 0) {
+        msg_type = RVM_EIO;
+	be_status = -1;
+    }
+
+    if (be_status != 0 &&
+            cbinfo->bc_pcbinfo != NULL &&
+            cbinfo->bc_pcbinfo->bc_cb != NULL) {
+                printf("\nErr function : %s\n", __FUNCTION__);
+                m0_be_handler_post(cbinfo->bc_pcbinfo, be_status, msg_type);
+                m0_free(rcl_cbdata);
+    }
     return RVM_SUCCESS;
     }
+
+void ol_read_log_status_cb(struct m0_be_cbinfo *cbinfo, int status,
+                           m0_be_msg_type_t msg_type)
+{
+    rvm_return_t                 retval;
+    log_t                       *log = NULL;
+    log_t    		       **log_ptr;
+    device_t        		*dev;
+    rcl_cbdata_t                *rcl_cbdata;
+    rvm_options_t               *rvm_options;
+
+    if(status != 0)
+    	goto ol_err_exit;
+
+    rcl_cbdata  = container_of(cbinfo, rcl_cbdata_t, rclc_cbinfo);
+    log         = rcl_cbdata->rclc_log;
+    rvm_options = rcl_cbdata->rclc_rvm_options;
+    log_ptr     = rcl_cbdata->rclc_out_log_ptr;
+    dev = &log->dev;
+
+    enter_log(log);
+    *log_ptr = log;
+
+    log->status.trunc_state = 0;
+    log->status.flush_state = 0;
+
+    /* create daemon truncation thread */
+    if ((retval=set_truncate_options(log,rvm_options))
+        != RVM_SUCCESS) goto err_exit;
+    /* raw i/o support */
+    if (dev->raw_io)
+        {
+        /* assign gather write buffer */
+        if ((long)(rvm_options->flush_buf_len) < MIN_FLUSH_BUF_LEN)
+            rvm_options->flush_buf_len = MIN_FLUSH_BUF_LEN;
+        dev->wrt_buf_len =
+            ROUND_TO_PAGE_SIZE(rvm_options->flush_buf_len);
+        dev->wrt_buf = page_alloc(log->seg_hdr, dev->wrt_buf_len);
+        if (dev->wrt_buf == NULL)
+            {
+            retval = RVM_ENO_MEMORY;
+            goto err_exit;
+            }
+        dev->buf_end = RVM_ADD_LENGTH_TO_ADDR(dev->wrt_buf,
+                                              dev->wrt_buf_len);
+
+        /* pre-load write buffer */
+        printf("\n___dev_rawio function : %s\n", __FUNCTION__);
+        if ((retval=preload_wrt_buf(log, cbinfo->bc_pcbinfo)) != RVM_SUCCESS)
+            goto err_exit;
+	else
+	    goto exit;
+        }
+	goto ol_err_exit;
+    /* enter in log list*/
+err_exit:
+    (void)close_dev(dev);
+    free_log(log);
+    *log_ptr = (log_t *)NULL;
+
+ol_err_exit:
+        if (cbinfo->bc_pcbinfo != NULL &&
+            cbinfo->bc_pcbinfo->bc_cb != NULL) {
+                printf("\nfunction : %s\n", __FUNCTION__);
+                m0_be_handler_post(cbinfo->bc_pcbinfo, retval, msg_type);
+        }
+exit:
+        m0_free(rcl_cbdata);
+}
+
 /* create log descriptor and open log device */
-rvm_return_t open_log(dev_name,log_ptr,status_buf,rvm_options)
-    char            *dev_name;          /* name of log storage device */
-    log_t           **log_ptr;          /* addr of log descriptor ptr */
-    char            *status_buf;        /* optional i/o buffer */
-    rvm_options_t   *rvm_options;       /* optional options descriptor */
+rvm_return_t open_log(dev_name,log_ptr,status_buf,rvm_options,cbinfo)
+    char                 *dev_name;          /* name of log storage device */
+    log_t               **log_ptr;          /* addr of log descriptor ptr */
+    char            	 *status_buf;        /* optional i/o buffer */
+    rvm_options_t   	 *rvm_options;       /* optional options descriptor */
+    struct m0_be_cbinfo  *cbinfo;
     {
-    log_t           *log;               /* log descriptor ptr */
-    log_buf_t       *log_buf;           /* log buffer descriptor ptr */
-    device_t        *dev;               /* device descriptor ptr */
-    rvm_length_t    flags = O_RDWR;     /* device open flags */
-    rvm_options_t   local_options;      /* local options record */
-    rvm_return_t    retval;
+    log_t            	*log;               /* log descriptor ptr */
+    log_buf_t       	*log_buf;           /* log buffer descriptor ptr */
+    device_t        	*dev;               /* device descriptor ptr */
+    rvm_length_t    	 flags = O_RDWR;     /* device open flags */
+    rvm_options_t   	 local_options;      /* local options record */
+    rvm_return_t    	 retval;
+    rcl_cbdata_t        *rcl_cbdata;
+    struct m0_be_cbinfo *rcl_cbinfo;
+    m0_be_msg_type_t	 msg_type;
+
+    M0_ALLOC_PTR(rcl_cbdata);
+    M0_ASSERT(rcl_cbdata != NULL);
 
     /* build internal log structure */
     if ((log = make_log(dev_name,&retval)) == NULL)
@@ -359,8 +482,10 @@ rvm_return_t open_log(dev_name,log_ptr,status_buf,rvm_options)
         rvm_options->recovery_buf_len = MIN_RECOVERY_BUF_LEN;
     log_buf->length=ROUND_TO_PAGE_SIZE(rvm_options->recovery_buf_len);
     log_buf->aux_length = ROUND_TO_PAGE_SIZE(log_buf->length/2);
-    if ((retval=alloc_log_buf(log)) != RVM_SUCCESS)
-        return retval;
+    if ((retval=alloc_log_buf(log)) != RVM_SUCCESS) {
+        msg_type = retval;
+        goto ol_err_exit;
+    }
 
     /* open the device and determine characteristics */
     if (rvm_no_update) flags = O_RDONLY;
@@ -379,51 +504,37 @@ rvm_return_t open_log(dev_name,log_ptr,status_buf,rvm_options)
     if (dev->raw_io) dev->num_bytes =   /* enought to read status area */
         RVM_ADD_LENGTH_TO_OFFSET(raw_status_offset,
                                  LOG_DEV_STATUS_SIZE);
+
+    rcl_cbdata->rclc_rvm_options        = rvm_options;
+    rcl_cbdata->rclc_log                = log;
+    rcl_cbdata->rclc_out_log_ptr	= log_ptr;
+
+    rcl_cbinfo                          = &rcl_cbdata->rclc_cbinfo;
+    m0_be_cbinfo_copy_helper(cbinfo, rcl_cbinfo, ol_read_log_status_cb);
+
+    printf("\nfunction : %s\n", __FUNCTION__);
     /* open status area */
-    if ((retval=read_log_status(log,status_buf)) != RVM_SUCCESS)
+    if ((retval=read_log_status(log,status_buf,rcl_cbinfo)) != RVM_SUCCESS)
         {
-        if (rvm_utlsw) goto keep_log; /* keep damaged status */
+		/*if (rvm_utlsw) goto keep_log; *//* keep damaged status */
         goto err_exit;
         }
-    log->status.trunc_state = 0;
-    log->status.flush_state = 0;
-
-    /* create daemon truncation thread */
-    if ((retval=set_truncate_options(log,rvm_options))
-        != RVM_SUCCESS) goto err_exit;
-    /* raw i/o support */
-    if (dev->raw_io)
-        {
-        /* assign gather write buffer */
-        if ((long)(rvm_options->flush_buf_len) < MIN_FLUSH_BUF_LEN)
-            rvm_options->flush_buf_len = MIN_FLUSH_BUF_LEN;
-        dev->wrt_buf_len =
-            ROUND_TO_PAGE_SIZE(rvm_options->flush_buf_len);
-        dev->wrt_buf = page_alloc(log->seg_hdr, dev->wrt_buf_len);
-        if (dev->wrt_buf == NULL)
-            {
-            retval = RVM_ENO_MEMORY;
-            goto err_exit;
-            }
-        dev->buf_end = RVM_ADD_LENGTH_TO_ADDR(dev->wrt_buf,
-                                              dev->wrt_buf_len);
+	goto ol_err_exit;
+err_exit:
+       (void)close_dev(dev);
+err_exit2:
+       free_log(log);
+       *log_ptr = (log_t *)NULL;
 
-        /* pre-load write buffer */
-        if ((retval=preload_wrt_buf(log)) != RVM_SUCCESS)
-            goto err_exit;
+ol_err_exit:
+        if (retval != 0 &&
+            cbinfo->bc_pcbinfo != NULL &&
+            cbinfo->bc_pcbinfo->bc_cb != NULL) {
+                printf("\nErr function : %s\n", __FUNCTION__);
+                m0_be_handler_post(cbinfo->bc_pcbinfo, retval, msg_type);
+                m0_free(rcl_cbdata);
         }
 
-    /* enter in log list*/
-keep_log:
-    enter_log(log);
-    *log_ptr = log;
-    return retval;
-
-err_exit:
-    (void)close_dev(dev);
-err_exit2:
-    free_log(log);
-    *log_ptr = (log_t *)NULL;
     return retval;
     }
 
@@ -471,6 +582,43 @@ exit:
                 m0_free(rcl_cbdata);
         }
 }
+
+void dlo_open_log_cb(struct m0_be_cbinfo *cbinfo, int status,
+                     m0_be_msg_type_t msg_type)
+{
+      rvm_return_t                 retval;
+      log_t                       *log = NULL;
+      rcl_cbdata_t                *rcl_cbdata;
+      struct m0_be_cbinfo         *rcl_cbinfo;
+
+      rcl_cbdata  = container_of(cbinfo, rcl_cbdata_t, rclc_cbinfo);
+      log         = rcl_cbdata->rclc_log;
+
+      rcl_cbinfo	= &rcl_cbdata->rclc_cbinfo;
+      cbinfo->bc_cb 	= do_log_options_cb;
+
+      /* do recovery processing for log */
+      log->in_recovery = rvm_true;
+      printf("\n function __enter__: %s\n", __func__);
+      if ((retval = log_recover(log,&log->status.tot_recovery,
+                                rvm_false,
+                                RVM_RECOVERY, rcl_cbinfo)) != RVM_SUCCESS) {
+  		printf("log_recover failed.\n");
+                status    = -1;
+                msg_type  = M0_BE_RVM_INIT_FAILED;
+                retval    = RVM_ELOG;
+      }
+
+      printf("\nfunction __exit__: %s\n", __FUNCTION__);
+      if (status != 0 &&
+          cbinfo->bc_pcbinfo != NULL &&
+          cbinfo->bc_pcbinfo->bc_cb != NULL) {
+               printf("\nErr function : %s\n", __FUNCTION__);
+               m0_be_handler_post(cbinfo->bc_pcbinfo, status, msg_type);
+               m0_free(rcl_cbdata);
+      }
+}
+
 /* log options processing */
 rvm_return_t do_log_options(log_ptr,rvm_options, cbinfo)
     log_t               **log_ptr;          /* addr of log descriptor ptr */
@@ -478,7 +626,7 @@ rvm_return_t do_log_options(log_ptr,rvm_options, cbinfo)
     struct m0_be_cbinfo  *cbinfo;
     {
     rvm_return_t                 retval;
-    log_t                       *log = NULL;
+    /*log_t                       *log = NULL;*/
     char                        *log_dev;
     int                          status = 0;
     m0_be_msg_type_t             msg_type= M0_BE_SUCCESS;
@@ -486,55 +634,43 @@ rvm_return_t do_log_options(log_ptr,rvm_options, cbinfo)
     struct m0_be_cbinfo         *rcl_cbinfo;
 
 
-    if ((rvm_options == NULL) || (rvm_options->log_dev == NULL))
-        return RVM_SUCCESS;
+   M0_ALLOC_PTR(rcl_cbdata);
+   M0_ASSERT(rcl_cbdata != NULL);
+
+    if ((rvm_options == NULL) || (rvm_options->log_dev == NULL)) {
+        status = RVM_SUCCESS;
+        goto exit;
+    }
 
     /* see if need to build a log descriptor */
     log_dev = rvm_options->log_dev;
-    if ((log=find_log(log_dev)) == NULL)
+    if ((rcl_cbdata->rclc_log = find_log(log_dev)) == NULL)
         {
-        /* see if already have a log */
-        if (default_log != NULL) {
-            status    = -1;
-            msg_type  = M0_BE_RVM_INIT_FAILED;
-            retval    = RVM_ELOG;
-            goto exit;
+           /* see if already have a log */
+           if (default_log != NULL) {
+               status    = -1;
+               msg_type  = M0_BE_RVM_INIT_FAILED;
+               retval    = RVM_ELOG;
+               goto exit;
+           }
+           rcl_cbdata->rclc_rvm_options        = rvm_options;
+	   /*rcl_cbdata->rclc_log                = log;*/
+           rcl_cbdata->rclc_out_log_ptr        = log_ptr;
+
+           rcl_cbinfo                          = &rcl_cbdata->rclc_cbinfo;
+           m0_be_cbinfo_copy_helper(cbinfo, rcl_cbinfo, dlo_open_log_cb);
+
+    	   printf("\nfunction : %s\n", __FUNCTION__);
+           /* build log descriptor */
+           if ((retval = open_log(log_dev, &rcl_cbdata->rclc_log, NULL,
+	   			rvm_options, rcl_cbinfo))
+               != RVM_SUCCESS) {
+   		printf("open_log failed.\n");
+                   status    = -1;
+                   msg_type  = M0_BE_RVM_INIT_FAILED;
+                   retval    = RVM_ELOG;
+   	   }
         }
-
-        /* build log descriptor */
-        if ((retval=open_log(log_dev,&log,NULL,rvm_options))
-            != RVM_SUCCESS) {
-		printf("open_log failed.\n");
-                status    = -1;
-                msg_type  = M0_BE_RVM_INIT_FAILED;
-                retval    = RVM_ELOG;
-                goto exit;
-	}
-
-        M0_ALLOC_PTR(rcl_cbdata);
-        M0_ASSERT(rcl_cbdata != NULL);
-
-	rcl_cbdata->rclc_rvm_options        = rvm_options;
-        rcl_cbdata->rclc_log                = log;
-        rcl_cbdata->rclc_out_log_ptr        = log_ptr;
-
-        rcl_cbinfo                          = &rcl_cbdata->rclc_cbinfo;
-        m0_be_cbinfo_copy_helper(cbinfo, rcl_cbinfo, do_log_options_cb);
-        /* do recovery processing for log */
-        log->in_recovery = rvm_true;
-	printf("\n function __enter__: %s\n", __func__);
-        if ((retval = log_recover(log,&log->status.tot_recovery,
-                                  rvm_false,
-                                  RVM_RECOVERY, rcl_cbinfo)) != RVM_SUCCESS) {
-		printf("log_recover failed.\n");
-                status    = -1;
-                msg_type  = M0_BE_RVM_INIT_FAILED;
-                retval    = RVM_ELOG;
-                goto exit;
-	}
-    }
-
-      printf("\nfunction __exit__: %s\n", __FUNCTION__);
 exit:
         if (status != 0 &&
             cbinfo->bc_pcbinfo != NULL &&
@@ -740,30 +876,23 @@ rvm_return_t init_log_status(log, cbinfo)
     /* write the device areas */
     return write_log_status(log,NULL, cbinfo);
     }
-/* read log status area from log device */
-rvm_return_t read_log_status(log,status_buf)
-    log_t               *log;           /* log descriptor */
-    char                *status_buf;    /* optional i/o buffer */
-    {
-    log_status_t        *status = &log->status; /* status area descriptor */
-    rvm_offset_t        *status_offset; /* device status area offset */
-    log_dev_status_t    *dev_status;    /* status i/o area typed ptr */
-    char                status_io[LOG_DEV_STATUS_SIZE]; /* i/o buffer */
-    rvm_length_t        saved_chk_sum;  /* save area for checksum read */
 
-    /* read the status areas */
-    if (status_buf != NULL)
-        dev_status = (log_dev_status_t *)status_buf;
-    else {
-	BZERO(status_io, LOG_DEV_STATUS_SIZE); /* clear buffer */
-        dev_status = (log_dev_status_t *)status_io;
-    }
-    if (log->dev.raw_io) status_offset = &raw_status_offset;
-    else
-    status_offset = &file_status_offset;
-    if (read_dev(&log->dev,status_offset,
-                  dev_status,LOG_DEV_STATUS_SIZE) < 0)
-        return RVM_EIO;
+void rls_read_dev_cb(struct m0_be_cbinfo *cbinfo, int be_status,
+                     m0_be_msg_type_t msg_type)
+{
+    log_t		  *log;
+    log_status_t          *status = NULL; /* status area descriptor */
+    log_dev_status_t      *dev_status;    /* status i/o area typed ptr */
+    rcl_cbdata_t          *rcl_cbdata;
+    rvm_length_t           saved_chk_sum;  /* save area for checksum read */
+
+    if(be_status != 0)
+    	goto err_exit;
+
+    rcl_cbdata  = container_of(cbinfo, rcl_cbdata_t, rclc_cbinfo);
+    log         = rcl_cbdata->rclc_log;
+    status      = &log->status; /* status area descriptor */
+    dev_status  = rcl_cbdata->rclc_dev_status;
 
     /* save old checksum and compute new */
     saved_chk_sum = dev_status->chk_sum;
@@ -778,20 +907,91 @@ rvm_return_t read_log_status(log,status_buf)
 
     /* compare checksum, struct_id, and version */
     if ((dev_status->chk_sum != saved_chk_sum)
-        || (dev_status->struct_id != log_dev_status_id))
-        return RVM_ELOG;                /* status area damaged */
-    if (strcmp(dev_status->version,RVM_VERSION) != 0)
-        return RVM_ELOG_VERSION_SKEW;
-    if (strcmp(dev_status->log_version,RVM_LOG_VERSION) != 0)
-        return RVM_ELOG_VERSION_SKEW;
-    if (strcmp(dev_status->statistics_version,RVM_STATISTICS_VERSION) != 0)
-        return RVM_ESTAT_VERSION_SKEW;
+        || (dev_status->struct_id != log_dev_status_id)) {
+	msg_type = RVM_ELOG;
+	be_status = -1;
+	goto err_exit;
+    }
+    if (strcmp(dev_status->version,RVM_VERSION) != 0) {
+        msg_type = RVM_ELOG_VERSION_SKEW;
+	be_status = -1;
+	goto err_exit;
+    }
+    if (strcmp(dev_status->log_version,RVM_LOG_VERSION) != 0) {
+        msg_type = RVM_ELOG_VERSION_SKEW;
+	be_status = -1;
+	goto err_exit;
+    }
+    if (strcmp(dev_status->statistics_version,RVM_STATISTICS_VERSION) != 0) {
+        msg_type = RVM_ESTAT_VERSION_SKEW;
+	be_status = -1;
+	goto err_exit;
+    }
 
     /* set log device length to log size at creation */
     if (log->dev.raw_io)
         log->dev.num_bytes = RVM_ADD_OFFSETS(status->log_size,
                                              status->log_start);
     status->update_cnt = UPDATE_STATUS;
+
+    printf("\nfunction : %s\n", __FUNCTION__);
+err_exit:
+     if (cbinfo->bc_pcbinfo != NULL &&
+         cbinfo->bc_pcbinfo->bc_cb != NULL) {
+             printf("\nErr function : %s\n", __FUNCTION__);
+             m0_be_handler_post(cbinfo->bc_pcbinfo, be_status, msg_type);
+     }
+     m0_free(rcl_cbdata);
+}
+/* read log status area from log device */
+rvm_return_t read_log_status(log,status_buf,cbinfo)
+    log_t               *log;           /* log descriptor */
+    char                *status_buf;    /* optional i/o buffer */
+    struct m0_be_cbinfo *cbinfo;
+    {
+    rvm_offset_t          *status_offset; /* device status area offset */
+    log_dev_status_t      *dev_status;    /* status i/o area typed ptr */
+    rcl_cbdata_t          *rcl_cbdata;
+    struct m0_be_cbinfo   *rcl_cbinfo;
+    m0_be_msg_type_t       msg_type = M0_BE_SUCCESS;
+    int		           be_status = 0;
+
+
+    M0_ALLOC_PTR(rcl_cbdata);
+    M0_ASSERT(rcl_cbdata != NULL);
+    /* read the status areas */
+    if (status_buf != NULL)
+        dev_status = (log_dev_status_t *)status_buf;
+    else {
+        dev_status = (log_dev_status_t *)malloc(LOG_DEV_STATUS_SIZE);
+	BZERO(dev_status, LOG_DEV_STATUS_SIZE); /* clear buffer */
+    	rcl_cbdata->rclc_is_alloc_devstatus = rvm_true;
+    }
+
+    rcl_cbdata->rclc_log                = log;
+    rcl_cbdata->rclc_dev_status		= dev_status;
+
+    rcl_cbinfo                          = &rcl_cbdata->rclc_cbinfo;
+    m0_be_cbinfo_copy_helper(cbinfo, rcl_cbinfo, rls_read_dev_cb);
+
+    if (log->dev.raw_io) status_offset = &raw_status_offset;
+    else
+    status_offset = &file_status_offset;
+    printf("\nfunction : %s\n", __FUNCTION__);
+    if (read_dev(&log->dev,status_offset,
+                  dev_status,LOG_DEV_STATUS_SIZE, rcl_cbinfo) < 0) {
+        msg_type = RVM_EIO;
+	be_status = -1;
+    }
+
+    if (be_status != 0 &&
+            cbinfo->bc_pcbinfo != NULL &&
+            cbinfo->bc_pcbinfo->bc_cb != NULL) {
+                printf("\nErr function : %s\n", __FUNCTION__);
+                m0_be_handler_post(cbinfo->bc_pcbinfo, be_status, msg_type);
+                m0_free(rcl_cbdata);
+    }
+
     return RVM_SUCCESS;
     }
 /* write log status area on log device */
diff --git a/rvm/rvm_private.h b/rvm/rvm_private.h
index 69c2048..3313db0 100644
--- a/rvm/rvm_private.h
+++ b/rvm/rvm_private.h
@@ -1563,6 +1563,10 @@ long read_dev();                        /* [rvm_io.c] */
     char            *dest;
     rvm_length_t    length;
 */
+
+extern
+long read_dev_old();                        /* [rvm_io.c] */
+
 extern
 long write_dev();                       /* [rvm_io.c] */
 /*  device_t        *dev;
@@ -1762,6 +1766,8 @@ typedef struct rcl_cbdata {
         log_t                   *rclc_log;
         rvm_options_t           *rclc_rvm_options;
         log_t                  **rclc_out_log_ptr;
+	log_dev_status_t        *rclc_dev_status;
+	rvm_bool_t		 rclc_is_alloc_devstatus;
 }rcl_cbdata_t;
 
 /* flush_log_cbdata */
-- 
1.8.3.2

