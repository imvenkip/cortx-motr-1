From e046c68bda34b17b60d4ac5413ed11ea38c07161 Mon Sep 17 00:00:00 2001
From: Zishan Shaikh <zishan_shaikh@xyratex.com>
Date: Mon, 24 Dec 2012 10:24:39 -0800
Subject: [PATCH 017/121] Adapted be_kv_store to domain, reg & seg changes

---
 be/be_reg.c             |   8 +-
 be/lib/be_buf.c         |  10 +-
 be/lib/be_buf.h         |  12 +-
 be/lib/be_kv_store.c    | 766 +++++++++++++++++++++++++-----------------------
 be/lib/be_kv_store.h    | 162 ++++------
 be/lib/be_list.c        | 202 +++++++------
 be/lib/be_list.h        | 275 ++++++++---------
 be/lib/be_tlist.c       | 276 ++++++++---------
 be/lib/be_tlist.h       | 522 +++++++++++++++++----------------
 be/lib/be_types.h       |   9 +-
 be/lib/ut/be_kv_store.c | 310 ++++++++++++++------
 be/lib/ut/be_tlist.c    |  84 +++---
 12 files changed, 1399 insertions(+), 1237 deletions(-)

diff --git a/be/be_reg.c b/be/be_reg.c
index a2a481b..4355f8c 100644
--- a/be/be_reg.c
+++ b/be/be_reg.c
@@ -184,21 +184,19 @@ M0_INTERNAL void m0_be_alloc(struct m0_be_reg *reg)
 M0_INTERNAL void m0_be_free(struct m0_be_reg *reg)
 {
         int             err;
-        rvm_tid_t      *tid;
+        rvm_tid_t      *tid = NULL;
 
         /* Asserting on required pointers */
         M0_ASSERT(reg != NULL);
 
-        if (reg->br_tx == NULL)
-                tid = NULL;
-        else
+        if (reg->br_tx != NULL)
                 tid = reg->br_tx->bt_impl.tx_id; 
         /*
          * Allocate memory from RDS Heap.
          * Update br_buf to store virtual address.
          */
 
-        rds_free((char *)reg->br_buf.b_addr, NULL, &err);
+        rds_free((char *)reg->br_buf.b_addr, tid, &err);
 
         if (err != SUCCESS) {
                 /* todo@ need to call function m0_sm_state_set() for same not
diff --git a/be/lib/be_buf.c b/be/lib/be_buf.c
index 7b5adb2..2079f99 100644
--- a/be/lib/be_buf.c
+++ b/be/lib/be_buf.c
@@ -26,12 +26,12 @@
    @{
 */
 
-void m0_be_buf_init(struct m0_be_buf *buf, void *data, uint32_t nob,
-                    uint64_t segment_id, uint64_t segment_offset,
-                    void *virtual_addr)
+M0_INTERNAL void m0_be_buf_init(struct m0_be_buf *buf, void *data, uint32_t nob,
+                                uint64_t segment_id, uint64_t segment_offset,
+                                void *virtual_addr)
 {
-	buf->b_addr = data;
-	buf->b_nob  = nob;
+        buf->b_addr = data;
+        buf->b_nob  = nob;
 
         buf->logical_address.segid_offset.u_hi = segment_id;
         buf->logical_address.segid_offset.u_lo = segment_offset;
diff --git a/be/lib/be_buf.h b/be/lib/be_buf.h
index 8ed8c0b..d998adf 100644
--- a/be/lib/be_buf.h
+++ b/be/lib/be_buf.h
@@ -14,7 +14,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author   	  : Zishan Shaikh <zishan_shaikh@xyratex.com>
+ * Original author: Zishan Shaikh <zishan_shaikh@xyratex.com>
  * Original creation date : 12/04/2012
  */
 #pragma once
@@ -40,14 +40,14 @@ struct m0_be_buf {
 };
 
 /* Backend domain type buffer initialization */
-void m0_be_buf_init(struct m0_be_buf *buf, void *data, uint32_t nob,
-                    uint64_t segment_id, uint64_t segment_offset,
-                    void *virtual_addr);
+M0_INTERNAL void m0_be_buf_init(struct m0_be_buf *buf, void *data, uint32_t nob,
+                                uint64_t segment_id, uint64_t segment_offset,
+                                void *virtual_addr);
 
 /** @} end of be_buf group */
 
-/* __MERO_BE_LIB_BE_BUF_H__ */
-#endif
+#endif /* __MERO_BE_LIB_BE_BUF_H__ */
+
 
 /*
  *  Local variables:
diff --git a/be/lib/be_kv_store.c b/be/lib/be_kv_store.c
index f059473..454a822 100644
--- a/be/lib/be_kv_store.c
+++ b/be/lib/be_kv_store.c
@@ -14,8 +14,8 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author              : Zishan Shaikh <zishan_shaikh@xyratex.com>
- * Original creation date       : 12/14/2012
+ * Original author: Zishan Shaikh <zishan_shaikh@xyratex.com>
+ * Original creation date: 12/24/2012
  */
 
 #include "be/lib/be_kv_store.h"
@@ -27,485 +27,533 @@
    @{
  */
 
-int m0_ks_init_domain_and_segment(struct m0_be_domain  *dom,
-                                  struct m0_be_seg    *seg,
-                                  struct m0_stob      *ns_stob,
-                                  struct m0_stob      *stob,
-                                  struct m0_stob      *log_stob)
+M0_INTERNAL int m0_ks_init_domain(struct m0_kv_store    *handle,
+                                  struct m0_be_domain  **dom)
 {
-        /* Initializing domain and segment */
-        m0_be_domain_init(dom, ns_stob, log_stob);
-        m0_be_seg_init(seg, dom, &(dom->bd_impl.sm_group), 0);
-        dom->bd_data.bs_sm.sm_state = M0_BESEG_ACTIVE;
+        struct m0_be_seg    *seg = NULL;
+        struct m0_stob      *ns_stob;
+        struct m0_stob      *log_stob;
 
-        m0_be_seg_create(seg, NULL, stob);
-        m0_sm_group_lock(seg->bs_impl.sm_group);
-        m0_sm_timedwait(&(seg->bs_sm),
-                        (1 << M0_BESEG_ACTIVE)|(1 << M0_BESEG_FAILED),
-                        M0_TIME_NEVER);
-        m0_sm_group_unlock(seg->bs_impl.sm_group);
+        *dom = (struct m0_be_domain *)malloc(sizeof(struct m0_be_domain));
+        M0_ASSERT(*dom != NULL);
 
-        /* If segment creation failed, then return */
-        if (seg->bs_sm.sm_state == M0_BESEG_FAILED ) {
-                return BE_KV_FAILURE;
-        }
+        ns_stob = (struct m0_stob *)malloc(2 * sizeof(struct m0_stob));
+        M0_ASSERT(ns_stob != NULL);
+
+        log_stob = (struct m0_stob *)(ns_stob + 1);
+
+        /* Initializing domain and segment */
+        m0_be_domain_init(*dom, ns_stob, log_stob);
+        (*dom)->bd_data.bs_sm.sm_state = M0_BESEG_ACTIVE;
+
+        /*Create and Open Segment */
+        m0_be_domain_lookup((*dom), 1, &seg);
 
-        m0_be_seg_open(seg);
         m0_sm_group_lock(seg->bs_impl.sm_group);
         m0_sm_timedwait(&(seg->bs_sm),
                         (1 << M0_BESEG_ACTIVE) | (1 << M0_BESEG_FAILED),
                         M0_TIME_NEVER);
         m0_sm_group_unlock(seg->bs_impl.sm_group);
+        
+        handle->ks_dom = *dom;
+
         return BE_KV_SUCCESS;
 }
 
-/**
- * Initialise a descriptor @d with values specified
- *
- * @param d		:	list descriptor to be initialised
- * @param list_name	:	name to be given to the tlist
- * @param link_magic	:	magic value for the linkage in the tlist
- * @param head_magic	:	magic value for the head in the tlist
- */
-static void __m0_ks_list_init(struct m0_be_tl_descr *d,
-                              char                  *list_name,
-			      uint64_t               link_magic,
-		     	      uint64_t               head_magic)
+M0_INTERNAL void m0_ks_init(struct m0_kv_store     *handle,
+                            struct m0_be_tl_descr  *descr,
+                            struct m0_be_domain   **dom,
+                            kv_key_cmp              cmp_fp,
+                            kv_key_match            match_fp)
 {
-	d->td_name  	        = list_name;
-        d->td_link_offset       = offsetof(struct m0_kv_store_obj, kvs_linkage);
-        d->td_link_magic_offset = offsetof(struct m0_kv_store_obj,
-					   kvs_ref_magic);
-        d->td_link_magic        = link_magic;
-        d->td_head_magic        = head_magic;
-}
+        /* Set compare and match routines */
+        handle->kv_key_cmp    = cmp_fp;
+        handle->kv_key_match  = match_fp;
+        handle->ks_list_descr = descr;
+
+        m0_ks_init_domain(handle, dom);
 
+        /* be_tlist init */
+        m0_be_tlist_init(handle->ks_list_descr, &handle->ks_tlist);
+
+}
+M0_EXPORTED(m0_ks_init);
+/**
+ * Gives the linkage of the previous object for current. The previous pointer is
+ * updated in @link_prev
+ */
 static void __get_prev(struct m0_be_tl_descr   *d,
-                       struct m0_kv_store_obj *current,
+                       void                    *current,
                        struct m0_be_list_link **link_prev)
 {
-        *link_prev = current->kvs_linkage.t_link.ll_prev.virtual_address;
+        int                     link_offset;
+        struct m0_be_list_link *link;
+
+        link_offset = d->td_link_offset;
+
+        link = &((struct m0_be_tlink *)(current + link_offset))->t_link;
+
+        *link_prev = link->ll_prev.virtual_address;
 }
 
+/**
+ * Gives the linkage of the next object for current. The next pointer is
+ * updated in @link_next
+ */
 static void __get_next(struct m0_be_tl_descr   *d,
-                       struct m0_kv_store_obj *current,
-                       struct m0_be_list_link **link_next)
+                                   void                    *current,
+                                   struct m0_be_list_link **link_next)
 {
-        *link_next = current->kvs_linkage.t_link.ll_next.virtual_address;
+        int                     link_offset;
+        struct m0_be_list_link *link;
+
+        link_offset = d->td_link_offset;
+
+        link = &((struct m0_be_tlink *)(current + link_offset))->t_link;
+
+        *link_next = link->ll_next.virtual_address;
 }
 
-static void __prep_prev_next_reg(struct m0_kv_store     *handle,
-                                 struct m0_be_buf       *prev_buf,
-                                 struct m0_be_buf       *next_buf,
-                                 struct m0_be_reg       *prev_reg,
-                                 struct m0_be_reg       *next_reg,
-                                 struct m0_be_list_link *link_prev,
-                                 struct m0_be_list_link *link_next)
+M0_INTERNAL struct m0_reference
+*m0_ks_get_next_value(struct m0_kv_store *handle, void               *obj)
 {
-        prev_reg->br_sm.sm_state = M0_BEREG_DONE;
-        next_reg->br_sm.sm_state = M0_BEREG_DONE;
+        void                            *scan;
+        void                            *current_obj = NULL;
+        struct m0_be_list_link          *link_next   = NULL;
+        struct m0_reference             *ret_ref     = NULL;
+
+        m0_be_tlist_for(handle->ks_list_descr, &handle->ks_tlist, scan) {
+                if (handle->kv_key_cmp(scan, obj) == 0) {
+                        current_obj = scan;
+                        break;
+                }
+        }m0_be_tlist_endfor;
 
-        m0_be_buf_init(prev_buf, NULL, sizeof(struct m0_be_list_link), 0, 0, 0);
-        m0_be_buf_init(next_buf, NULL, sizeof(struct m0_be_list_link), 0, 0, 0);
+        if (current_obj == NULL)
+                return NULL;
 
-        m0_be_reg_init(&prev_reg, NULL, handle->ks_seg, prev_buf);
-        m0_be_reg_init(&next_reg, NULL, handle->ks_seg, next_buf);
+        __get_next(handle->ks_list_descr, current_obj, &link_next);
 
-        prev_reg->br_buf.b_addr = (void *)link_prev;
-        next_reg->br_buf.b_addr = (void *)link_next;
+        ret_ref  = &(link_next->ll_next.logical_address);
+        return ret_ref;
 }
+M0_EXPORTED(m0_ks_get_next_value);
 
-static int malloc_for_reg(struct m0_be_reg **prev_reg,
-                          struct m0_be_reg **next_reg,
-                          struct m0_be_buf **prev_buf,
-                          struct m0_be_buf **next_buf)
+/*
+ * Prepared the regions for the previous and next pointers to be modified in the
+ * list. Called in m0_ks_insert and m0_ks_delete.
+ */
+static void __prep_prev_next_reg(struct m0_kv_store     *handle,
+                                 struct m0_be_reg       **prev_reg,
+                                 struct m0_be_reg       **next_reg,
+                                 struct m0_be_list_link *link_prev,
+                                 struct m0_be_list_link *link_next)
 {
-        *prev_buf = (struct m0_be_buf *)malloc(sizeof(struct m0_be_buf));
-        if (prev_buf == NULL)
-                return BE_KV_FAILURE;
-
-        *next_buf = (struct m0_be_buf *)malloc(sizeof(struct m0_be_buf));
-        if (next_buf == NULL) {
-                free(prev_buf);
-                return BE_KV_FAILURE;
+        struct m0_be_seg *prev_seg = NULL;
+        struct m0_be_seg *next_seg = NULL;
+        struct m0_be_buf  prev_buf;
+        struct m0_be_buf  next_buf;
+        uint64_t          prev_segid;
+        uint64_t          next_segid;
+
+        prev_buf.b_nob  = sizeof(struct m0_be_list_link);
+        next_buf.b_nob  = sizeof(struct m0_be_list_link);
+
+        prev_segid = link_prev->ll_next.logical_address.segid_offset.u_hi;
+        next_segid = link_next->ll_prev.logical_address.segid_offset.u_hi;
+
+        if (prev_segid == next_segid) {
+                m0_be_domain_lookup(handle->ks_dom, prev_segid, &prev_seg);
+                m0_sm_group_lock(prev_seg->bs_impl.sm_group);
+                m0_sm_timedwait(&(prev_seg->bs_sm),
+                        (1 << M0_BESEG_ACTIVE) | (1 << M0_BESEG_FAILED),
+                        M0_TIME_NEVER);
+                m0_sm_group_unlock(prev_seg->bs_impl.sm_group);
+  
+                next_seg = prev_seg;
+        } else {
+                m0_be_domain_lookup(handle->ks_dom, next_segid, &next_seg);
+                m0_sm_group_lock(next_seg->bs_impl.sm_group);
+                m0_sm_timedwait(&(next_seg->bs_sm),
+                        (1 << M0_BESEG_ACTIVE) | (1 << M0_BESEG_FAILED),
+                        M0_TIME_NEVER);
+                m0_sm_group_unlock(next_seg->bs_impl.sm_group);
+ 
+                m0_be_domain_lookup(handle->ks_dom, prev_segid, &prev_seg);
+                m0_sm_group_lock(prev_seg->bs_impl.sm_group);
+                m0_sm_timedwait(&(prev_seg->bs_sm),
+                        (1 << M0_BESEG_ACTIVE) | (1 << M0_BESEG_FAILED),
+                        M0_TIME_NEVER);
+                m0_sm_group_unlock(prev_seg->bs_impl.sm_group);
+ 
         }
 
-        *prev_reg = (struct m0_be_reg *)malloc(sizeof(struct m0_be_reg));
-        if (*prev_reg == NULL) {
-                free(prev_buf);
-                free(next_buf);
-                return BE_KV_FAILURE;
-        }
+        M0_ASSERT(next_seg != NULL);
+        M0_ASSERT(prev_reg != NULL);
 
-       *next_reg = (struct m0_be_reg *)malloc(sizeof(struct m0_be_reg));
-       if (next_reg == NULL) {
-                free(prev_buf);
-                free(next_buf);
-                free(*prev_reg);
-                return BE_KV_FAILURE;
-       }
-       return BE_KV_SUCCESS;
-}
+        m0_be_reg_init(prev_reg, NULL, prev_seg, &prev_buf);
+        m0_be_reg_init(next_reg, NULL, next_seg, &next_buf);
 
+        (*prev_reg)->br_buf.b_addr = (void *)link_prev;
+        (*next_reg)->br_buf.b_addr = (void *)link_next;
+}
 
-void m0_ks_init(struct m0_kv_store *handle,
-                char               *list_name,
-		uint64_t            link_magic,
-                uint64_t            head_magic)
+M0_INTERNAL struct m0_reference *m0_ks_find(struct m0_kv_store *handle,
+                                            void               *obj)
 {
-        /* Initialise tlist descriptor */
-        __m0_ks_list_init(&handle->ks_list_descr, list_name,
-			  link_magic, head_magic);
+        struct m0_reference    *ret_ref = NULL;
+        struct m0_be_list_link *link = NULL;
+        void                   *scan;
+        int                     link_offset;
 
-        /* be_tlist init */
-	m0_be_tlist_init(&handle->ks_list_descr, &handle->ks_tlist);
-}
+        link_offset = handle->ks_list_descr->td_link_offset;
 
-void m0_ks_update_handle(struct m0_kv_store  *handle, struct m0_be_domain *dom,
-                         struct m0_be_seg    *seg, struct m0_stob      *ns_stob,
-                         struct m0_stob      *stob,
-                         struct m0_stob      *log_stob)
-{
-        handle->ks_dom          = dom;
-        handle->ks_seg          = seg;
-        handle->ks_ns_stob      = ns_stob;
-        handle->ks_stob         = stob;
-        handle->ks_log_stob     = log_stob;
-}
+        m0_be_tlist_for(handle->ks_list_descr, &handle->ks_tlist, scan) {
+                if (handle->kv_key_cmp(scan, obj) == 0) {
 
-struct m0_be_buf *m0_ks_find(struct m0_kv_store *handle,
-		             struct m0_kv_key   *key)
-{
-        struct m0_be_buf       *ret_buf = NULL;
-        struct m0_kv_store_obj *scan;
-
-	/* Ensure valid key is sent from user */
-	if (key->kv_logical_addr.kv_magic !=
-            handle->ks_list_descr.td_link_magic)
-			return NULL;
-
-	/*
-         * Magic check success. Proceed to find the correct <key, value>
-	 * pair in the node
-	 */
-
-	m0_be_tlist_for(&handle->ks_list_descr, &handle->ks_tlist, scan) {
-		if (strcmp(scan->kvs_key_hold.kv_key, key->kv_key) == 0) {
-                        ret_buf = &scan->kvs_val_reg->br_buf;
+                        link = &((struct m0_be_tlink *)
+                                 (scan + link_offset))->t_link;
+
+                        ret_ref  = &(link->ll_next.logical_address);
                         break;
-		}
-	}m0_be_tlist_endfor;
+                }
+        }m0_be_tlist_endfor;
 
-	return ret_buf;
+        return ret_ref;
 }
+M0_EXPORTED(m0_ks_find);
 
-struct m0_be_reg *m0_ks_delete(struct m0_kv_store  *handle,
-                               struct m0_kv_key    *key,
-                               struct m0_be_tx *tx)
+M0_INTERNAL int m0_ks_delete(struct m0_kv_store  *handle,
+                             void                *obj,
+                             struct m0_be_tx     *del_tx)
 {
-        int                    ret_val;
-	struct m0_kv_store_obj *scan;
-	struct m0_kv_store_obj *target  = NULL;
-        struct m0_be_reg       *ret_reg = NULL;
-        struct m0_be_buf       *prev_buf  = NULL;
-        struct m0_be_buf       *next_buf  = NULL;
+        void                   *scan;
+        void                   *target    = NULL;
+        struct m0_be_reg       *curr_reg  = NULL;
         struct m0_be_reg       *prev_reg  = NULL;
         struct m0_be_reg       *next_reg  = NULL;
         struct m0_be_list_link *link_prev = NULL;
         struct m0_be_list_link *link_next = NULL;
+        struct m0_be_list_link *link_curr = NULL;
+        struct m0_be_seg       *curr_seg  = NULL;
+        struct m0_be_tl_descr  *desc_t    = NULL; /* temporary */
+        struct m0_uint128      *temp_offset;
+        struct m0_be_tx         *tx = del_tx;
+        struct m0_be_buf        curr_buf;
+        uint64_t                curr_segid;
+
+        if (del_tx == NULL){
+                tx = (struct m0_be_tx *)malloc(sizeof(struct m0_be_tx));
+                M0_ASSERT(tx != NULL);
+                m0_be_tx_init(tx, handle->ks_dom, 0);
+        }
+
+        /* Find the target node to be deleted */
+        m0_be_tlist_for(handle->ks_list_descr, &handle->ks_tlist, scan) {
+                if (handle->kv_key_cmp(scan, obj) == 0)
+                        target = scan;
+        }m0_be_tlist_endfor;
+
+        if (target != NULL) {
+                desc_t = handle->ks_list_descr;
+
+                /* Add current object to transaction */
+                curr_buf.b_nob = sizeof(struct m0_be_list_link);
+                link_curr = &((struct m0_be_tlink *)
+                              (target + desc_t->td_link_offset))->t_link;
+
+                temp_offset = &(link_curr->ll_next.logical_address.segid_offset);
+                curr_segid  = temp_offset->u_hi;
 
-	m0_be_tlist_for(&handle->ks_list_descr, &handle->ks_tlist, scan) {
-		if (strcmp(scan->kvs_key_hold.kv_key, key->kv_key) == 0)
-				target = scan;
-	}m0_be_tlist_endfor;
+                m0_be_domain_lookup(handle->ks_dom, curr_segid, &curr_seg);
+                m0_sm_group_lock(curr_seg->bs_impl.sm_group);
+                m0_sm_timedwait(&(curr_seg->bs_sm),
+                        (1 << M0_BESEG_ACTIVE) | (1 << M0_BESEG_FAILED),
+                        M0_TIME_NEVER);
+                m0_sm_group_unlock(curr_seg->bs_impl.sm_group);
+ 
+                M0_ASSERT(curr_seg != NULL);
+
+                m0_be_reg_init(&curr_reg, NULL, curr_seg, &curr_buf);
+                curr_reg->br_buf.b_addr = (void *)link_curr;
+                m0_be_tx_add_cred(tx, curr_reg);
 
-	if (target != NULL) {
                 /*
                  * Add the previous and next pointers about to
                  * be modified to the credit.
                  */
-               ret_val = malloc_for_reg(&prev_reg, &next_reg, &prev_buf,
-                                        &next_buf);
+                __get_prev(handle->ks_list_descr, target, &link_prev);
+                __get_next(handle->ks_list_descr, target, &link_next);
 
-               if (ret_val == BE_KV_FAILURE || prev_reg == NULL ||
-                   next_reg == NULL)
-                        return NULL;
-         
-                __get_prev(&handle->ks_list_descr, scan, &link_prev);
-                __get_next(&handle->ks_list_descr, scan, &link_next);
+                M0_ASSERT(link_prev != NULL);
+                M0_ASSERT(link_next != NULL);
 
-                __prep_prev_next_reg(handle, prev_buf, next_buf, prev_reg,
-                                     next_reg, link_prev, link_next);
+                __prep_prev_next_reg(handle, &prev_reg, &next_reg,
+                                     link_prev, link_next);
 
                 m0_be_tx_add_cred(tx, prev_reg);
                 m0_be_tx_add_cred(tx, next_reg);
 
-                /* collect return values */
-                ret_reg = target->kvs_val_reg;
+                m0_be_tx_prep(tx);
+                m0_sm_group_lock(tx->bt_impl.sm_group);
+                m0_sm_timedwait(&(tx->bt_sm),
+                                (1 << M0_BETX_PREPARED) | (1 << M0_BETX_FAILED),
+                                 M0_TIME_NEVER);
+                m0_sm_group_unlock(tx->bt_impl.sm_group);
+
+                m0_be_tx_start(tx);
+                m0_sm_group_lock(tx->bt_impl.sm_group);
+                m0_sm_timedwait(&tx->bt_sm,
+                                (1 << M0_BETX_OPEN) | (1 << M0_BETX_FAILED),
+                                M0_TIME_NEVER);
+                m0_sm_group_unlock(tx->bt_impl.sm_group);
+
+                if (del_tx == NULL) {
+                        m0_be_tx_done(tx);
+                        m0_sm_group_lock(tx->bt_impl.sm_group);
+                        m0_sm_timedwait(&tx->bt_sm,
+                                        (1 << M0_BETX_DONE) | (1 << M0_BETX_FAILED),
+                                        M0_TIME_NEVER);
+                        m0_sm_group_unlock(tx->bt_impl.sm_group);
+       
+                        m0_be_tx_fini(tx);
+                        free(tx);
+                }
+
                 /* Now delete */
-		m0_be_tlink_del_fini(&handle->ks_list_descr, target);
-		return ret_reg;
-	}
-        return ret_reg;
+                m0_be_tlink_del_fini(handle->ks_list_descr, target);
+                return BE_KV_SUCCESS;
+        }
+        return BE_KV_FAILURE;
 }
+M0_EXPORTED(m0_ks_delete);
 
-static int __ks_alloc_memory_obj(struct m0_kv_store      *handle,
-                                 struct m0_kv_store_obj **new_obj,
-                                 struct m0_be_buf       **ret_buf,
-                                 struct m0_be_tx         *tx)
+static int __add_at_tail_to_tlist(struct m0_kv_store     *handle,
+                                  void                   *new,
+                                  struct m0_be_tx        *tx)
 {
-        /* Be Domain Transaction */
-        struct m0_be_buf        *obj_buf;
-        struct m0_be_reg        *obj_reg;
+        struct m0_be_reg          *tail_reg  = NULL;
+        struct m0_be_list_link    *tail_link = NULL;
+        struct m0_be_seg          *tail_seg  = NULL;
+        struct m0_be_tl_descr     *desc_t    = NULL; /* temporary */
+        void                      *tail_obj  = NULL;
+        struct m0_uint128         *temp_offset;
+        struct m0_be_buf           tail_buf;
+        uint64_t                   tail_segid;
 
-        obj_reg = (struct m0_be_reg *)malloc(sizeof(struct m0_be_reg));
-        obj_buf = (struct m0_be_buf *)malloc(sizeof(struct m0_be_buf));
+        /* Add current tail to credit */
+        /* TODO : add actual tail *pointer* also the credit....reg init etc.
+         * tail can be taken from
+         *
+         *       const struct m0_be_list *head;
+         *       head = &list->t_head;
+         *       actual_tail_ptr = head->l_tail;
+         */
 
-        if(obj_reg == NULL || obj_buf == NULL)
-                return BE_KV_FAILURE;
+        tail_obj  = m0_be_tlist_tail(handle->ks_list_descr, &handle->ks_tlist);
 
-        obj_reg->br_sm.sm_state = M0_BEREG_INIT;
-        m0_be_buf_init(obj_buf, NULL, sizeof(struct m0_kv_store_obj), 0, 0, 0);
-        m0_be_reg_init(&obj_reg, NULL, (handle->ks_seg), obj_buf);
-        m0_be_tx_add_cred(tx, obj_reg);
+        desc_t    = handle->ks_list_descr;
+        tail_link = &((struct m0_be_tlink *)
+                      (tail_obj + desc_t->td_link_offset))->t_link;
 
-        /* Initialise and start transaction */
-        m0_be_tx_init(tx, handle->ks_dom, 0);
+        tail_buf.b_nob = sizeof(struct m0_be_list_link);
 
-        m0_sm_group_lock(tx->bt_impl.sm_group);
-        m0_sm_timedwait(&tx->bt_sm,
-                        (1 << M0_BETX_PREPARING) | (1 << M0_BETX_FAILED),
+        temp_offset    = &(tail_link->ll_next.logical_address.segid_offset);
+        tail_segid     = temp_offset->u_hi;
+
+        m0_be_domain_lookup(handle->ks_dom, tail_segid, &tail_seg);
+        m0_sm_group_lock(tail_seg->bs_impl.sm_group);
+        m0_sm_timedwait(&(tail_seg->bs_sm),
+                       (1 << M0_BESEG_ACTIVE) | (1 << M0_BESEG_FAILED),
                         M0_TIME_NEVER);
-        m0_sm_group_unlock(tx->bt_impl.sm_group);
+        m0_sm_group_unlock(tail_seg->bs_impl.sm_group);
 
-        m0_be_tx_prep(tx);
+        M0_ASSERT(tail_seg != NULL);
+
+        m0_be_reg_init(&tail_reg, NULL, tail_seg, &tail_buf);
+        tail_reg->br_buf.b_addr = (void *)tail_link;
+        m0_be_tx_add_cred(tx, tail_reg);
 
+        m0_be_tx_prep(tx);
         m0_sm_group_lock(tx->bt_impl.sm_group);
-        m0_sm_timedwait(&tx->bt_sm,
+        m0_sm_timedwait(&(tx->bt_sm),
                         (1 << M0_BETX_PREPARED) | (1 << M0_BETX_FAILED),
-                        M0_TIME_NEVER);
+                         M0_TIME_NEVER);
         m0_sm_group_unlock(tx->bt_impl.sm_group);
 
         m0_be_tx_start(tx);
-        
         m0_sm_group_lock(tx->bt_impl.sm_group);
         m0_sm_timedwait(&tx->bt_sm,
-                        (1 << M0_BETX_OPEN) | (1 << M0_BETX_FAILED),
+                       (1 << M0_BETX_OPEN) | (1 << M0_BETX_FAILED),
                         M0_TIME_NEVER);
         m0_sm_group_unlock(tx->bt_impl.sm_group);
 
 
 
-        /* Allocate the memory to the object from @reg.br_buf */
-        *new_obj = (struct m0_kv_store_obj *)obj_reg->br_buf.b_addr;
-
-        /* Update return buf, used while m0_be_tlink_init */
-        *ret_buf  = &(obj_reg->br_buf);
-        if (*new_obj == NULL) {
-                return BE_KV_FAILURE;
-        }
-
+        /* Finally, add at tail in tlist */
+        m0_be_tlist_add_tail(desc_t, &handle->ks_tlist, new);
         return BE_KV_SUCCESS;
 }
 
-static int __obj_memory_alloc(struct m0_kv_store      *handle,
-                              struct m0_kv_store_obj **new,
-                              struct m0_kv_key        *key,
-                              struct m0_be_buf        *buf,
-                              struct m0_be_tx         *tx)
-{
-        int      ret_val;
-        uint64_t link_magic;
-        uint64_t seg_id;
-        uint64_t offset;
-
-        /* Allocate memory to the object in which the key will be stored */
-        ret_val = __ks_alloc_memory_obj(handle, new, &buf, tx);
-	if (new == NULL || buf == NULL || ret_val == BE_KV_FAILURE)
-                return BE_KV_FAILURE;
-
-	link_magic = handle->ks_list_descr.td_link_magic;
-	seg_id	   = buf->logical_address.segid_offset.u_hi;
-	offset	   = buf->logical_address.segid_offset.u_lo;
 
-	/* prepare kv_key */
-	strcpy((*new)->kvs_key_hold.kv_key, key->kv_key);
-
-	/* update incoming key structure's @segid & @offset */
-	key->kv_logical_addr.kv_magic  = link_magic;
-	key->kv_logical_addr.kv_segid  = seg_id;
-	key->kv_logical_addr.kv_offset = offset;
-
-	/* initialise the tlink linkage */
-	m0_be_tlink_init(&handle->ks_list_descr, buf->logical_address);
-
-        return BE_KV_SUCCESS;
-}
-
-static int __add_at_tail_to_tlist(struct m0_kv_store     *handle,
-                                  struct m0_kv_store_obj *new,
-                                  struct m0_kv_key       *key,
-                                  struct m0_be_buf       *buf,
-                                  struct m0_be_tx        *tx)
+M0_INTERNAL int m0_ks_insert(struct m0_kv_store  *handle, void *new,
+                             struct m0_be_tx     *ins_tx)
 {
-        int                        ret_val;
-        struct m0_be_buf          *prev_buf  = NULL;
-        struct m0_be_reg          *prev_reg  = NULL;
-        struct m0_be_reg          *temp_reg  = NULL;
-        struct m0_be_list_link    *link_prev = NULL;
-        struct m0_kv_store_obj    *obj_t     = NULL;
+        struct m0_be_reg                *prev_reg      = NULL;
+        struct m0_be_reg                *next_reg      = NULL;
+        struct m0_be_reg                *obj_link_reg  = NULL;
+        struct m0_be_reg                *obj_reg       = NULL;
+        struct m0_be_list_link          *link_prev     = NULL;
+        struct m0_be_list_link          *link_next     = NULL;
+        struct m0_be_tl_descr           *desc_t        = NULL; /* temporary */
+        void                            *scan;
+        struct m0_be_list_link          *head;
+        struct m0_be_list_link          *link;
+        struct m0_be_seg                *link_seg;
+        struct m0_be_tx                 *tx = ins_tx;
+        struct m0_be_buf                 obj_link_buf;
+        int                              ret_val = BE_KV_INVALID_REQ;
+        uint64_t                         link_segid;
 
-        /* Add current tail to credit */
-        prev_buf = (struct m0_be_buf *)malloc(sizeof(struct m0_be_buf));
-        if (prev_buf == NULL)
-                return BE_KV_FAILURE;
-
-        prev_reg = (struct m0_be_reg *)malloc(sizeof(struct m0_be_reg));
-        if (prev_reg == NULL) {
-                free(prev_buf);
-                return BE_KV_FAILURE;
+        /* Check for duplicate insertion */
+        m0_be_tlist_for(handle->ks_list_descr, &handle->ks_tlist, scan) {
+                if (handle->kv_key_cmp(new, scan) == 0) {
+                        return BE_KV_FAILURE;
+                }
+        }m0_be_tlist_endfor;
+
+        if (ins_tx == NULL){
+                tx = (struct m0_be_tx *)malloc(sizeof(struct m0_be_tx));
+                if (tx == NULL)
+                        return BE_KV_FAILURE;
+                m0_be_tx_init(tx, handle->ks_dom, 0);
         }
 
-        obj_t = (struct m0_kv_store_obj *)
-                 m0_be_tlist_tail(&handle->ks_list_descr, &handle->ks_tlist);
+        obj_link_buf.b_nob = sizeof(struct m0_be_list_link);
+        link = &((struct m0_be_tlink *)
+                 (new + handle->ks_list_descr->td_link_offset))->t_link;
 
-        link_prev = obj_t->kvs_linkage.t_link.ll_prev.virtual_address;
+        /* Tlink init for object */
+        obj_reg = (struct m0_be_reg *)
+                   m0_be_reg_tlist_head(&(tx->bt_impl.bc_tl));
+        M0_ASSERT(obj_reg != NULL);
 
-        prev_reg->br_sm.sm_state = M0_BEREG_DONE;
-        m0_be_buf_init(prev_buf, NULL, sizeof(struct m0_be_list_link),
-                       0, 0, 0);
+        m0_be_tlink_init(handle->ks_list_descr,
+                         obj_reg->br_buf.logical_address);
 
-        m0_be_reg_init(&prev_reg, NULL, handle->ks_seg, prev_buf);
-        prev_reg->br_buf.b_addr = (void *)link_prev;
+        /* Get segment for linkage in object */
+        link_segid = link->ll_next.logical_address.segid_offset.u_hi;
 
-        m0_be_tx_add_cred(tx, prev_reg);
+        m0_be_domain_lookup(handle->ks_dom, link_segid, &link_seg);
+        m0_sm_group_lock(link_seg->bs_impl.sm_group);
+        m0_sm_timedwait(&(link_seg->bs_sm),
+                       (1 << M0_BESEG_ACTIVE) | (1 << M0_BESEG_FAILED),
+                        M0_TIME_NEVER);
+        m0_sm_group_unlock(link_seg->bs_impl.sm_group);
 
-        /* Now allocate memory to the object and add at tail */
-        ret_val          = __obj_memory_alloc(handle, &new, key,
-                                              buf, tx);
-        temp_reg         = (struct m0_be_reg *)
-                            m0_be_reg_tlist_head(&(tx->bt_impl.bc_tl));
-        new->kvs_val_reg = temp_reg;
-        
-        if (ret_val == BE_KV_SUCCESS) {
-                m0_be_tlist_add_tail(&handle->ks_list_descr,
-                                     &handle->ks_tlist, new);
-                }
-        return ret_val;
-}
 
+        M0_ASSERT(link_seg != NULL);
 
-int m0_ks_insert(struct m0_kv_store  *handle, struct m0_kv_key *key,
-                 struct m0_be_tx    *tx)
-{
-	struct m0_be_buf 		*buf       = NULL;
-        struct m0_be_buf                *prev_buf  = NULL;
-        struct m0_be_buf                *next_buf  = NULL;
-        struct m0_be_reg                *prev_reg  = NULL;
-        struct m0_be_reg                *next_reg  = NULL;
-        struct m0_be_reg                *reg_t     = NULL; /* temporary use*/
-        struct m0_be_list_link          *link_prev = NULL;
-        struct m0_be_list_link          *link_next = NULL;
-	struct m0_kv_store_obj 		*new       = NULL;
-        struct m0_be_tl_descr           *desc_t    = NULL; /* temporary use*/
-        struct m0_kv_store_obj 		*scan;
-	struct m0_be_list_link 		*head;
-        int                              ret_val;
-
-	head = (void *)&handle->ks_tlist.t_head;
+        m0_be_reg_init(&obj_link_reg, NULL, link_seg, &obj_link_buf);
+        obj_link_reg->br_buf.b_addr = (void *)link;
 
-        /* Check for duplicate insertion */
-        m0_be_tlist_for(&handle->ks_list_descr, &handle->ks_tlist, scan) {
-	        if (strcmp(key->kv_key,
-                           scan->kvs_key_hold.kv_key) == 0) {
-                		return BE_KV_FAILURE;
-	        }
-        }m0_be_tlist_endfor;
+        /* Add this region in the credit list */
+        m0_be_tx_add_cred(tx, obj_link_reg);
 
-	if ((head->ll_next.virtual_address == (void *)head) &&
-	    (head->ll_prev.virtual_address == (void *)head)) {
+        head = (void *)&handle->ks_tlist.t_head;
 
+        if ((head->ll_next.virtual_address == (void *)head) &&
+            (head->ll_prev.virtual_address == (void *)head)) {
                 /* Check if list empty, if yes then add as head */
-                ret_val           = __obj_memory_alloc(handle, &new, key,
-                                                       buf, tx);
-                new->kvs_val_reg  = (struct m0_be_reg *)
-                                    m0_be_reg_tlist_head(&(tx->bt_impl.bc_tl));
-
-               	if(ret_val == BE_KV_SUCCESS) {
-                        m0_be_tlist_add(&handle->ks_list_descr,
-                                        &handle->ks_tlist, new);
-                }
-
-	} else {
+                /* TODO: Add actual head pointer region in credit,
+                 * just like add_tail above
+                 */
+                m0_be_tx_prep(tx);
+                m0_sm_group_lock(tx->bt_impl.sm_group);
+                m0_sm_timedwait(&(tx->bt_sm),
+                               (1 << M0_BETX_PREPARED) | (1 << M0_BETX_FAILED),
+                                         M0_TIME_NEVER);
+                m0_sm_group_unlock(tx->bt_impl.sm_group);
+
+                m0_be_tx_start(tx);
+                m0_sm_group_lock(tx->bt_impl.sm_group);
+                m0_sm_timedwait(&tx->bt_sm,
+                               (1 << M0_BETX_OPEN) | (1 << M0_BETX_FAILED),
+                                M0_TIME_NEVER);
+                m0_sm_group_unlock(tx->bt_impl.sm_group);
+
+                m0_be_tlist_add(handle->ks_list_descr, &handle->ks_tlist, new);
+                ret_val = BE_KV_SUCCESS;
+        } else {
                 /* Else, find the appropriate position for the obj and insert */
-		m0_be_tlist_for(&handle->ks_list_descr, &handle->ks_tlist, scan)
+                m0_be_tlist_for(handle->ks_list_descr, &handle->ks_tlist, scan)
                 {
-			if (strcmp(key->kv_key,
-                            scan->kvs_key_hold.kv_key) < 0) {
+                        if (handle->kv_key_cmp(new, scan) < 0) {
                                 /*
                                  * Add the previous and next pointers about to
                                  * be modified to the credit.
                                  */
-                                ret_val = malloc_for_reg(&prev_reg, &next_reg,
-                                                         &prev_buf, &next_buf);
-                                if (ret_val == BE_KV_FAILURE)
-                                        return BE_KV_FAILURE;
-
-                                __get_prev(&handle->ks_list_descr, scan,
+                                __get_prev(handle->ks_list_descr, scan,
                                            &link_prev);
-                                __get_next(&handle->ks_list_descr, scan,
+                                __get_next(handle->ks_list_descr, scan,
                                            &link_next);
 
-                                __prep_prev_next_reg(handle, prev_buf, next_buf,
-                                                     prev_reg, next_reg,
-                                                     link_prev, link_next);
+                                __prep_prev_next_reg(handle, &prev_reg,
+                                                     &next_reg, link_prev,
+                                                     link_next);
 
                                 m0_be_tx_add_cred(tx, prev_reg);
                                 m0_be_tx_add_cred(tx, next_reg);
 
+                                m0_be_tx_prep(tx);
+                                m0_sm_group_lock(tx->bt_impl.sm_group);
+                                m0_sm_timedwait(&(tx->bt_sm),
+                                                (1 << M0_BETX_PREPARED) |
+                                                (1 << M0_BETX_FAILED),
+                                                 M0_TIME_NEVER);
+                                m0_sm_group_unlock(tx->bt_impl.sm_group);
+
+                                m0_be_tx_start(tx);
+                                m0_sm_group_lock(tx->bt_impl.sm_group);
+                                m0_sm_timedwait(&tx->bt_sm,
+                                                (1 << M0_BETX_OPEN) |
+                                                (1 << M0_BETX_FAILED),
+                                                M0_TIME_NEVER);
+                                m0_sm_group_unlock(tx->bt_impl.sm_group);
+
                                 /*
-                                 * Now allocate memory to the object to be
-                                 * stored in the list
+                                 * Now add the object to the tlist
                                  */
-                                ret_val = __obj_memory_alloc(handle, &new,
-                                                             key, buf, tx);
-                                reg_t   = (struct m0_be_reg *)
-                                       m0_be_reg_tlist_head(&(tx->bt_impl.bc_tl)
-                                                            );
-                                new->kvs_val_reg = reg_t;
-
-               	        	if(ret_val == BE_KV_SUCCESS) {
-                                        desc_t = &handle->ks_list_descr;
-                                        m0_be_tlist_add_before(desc_t, scan,
-                                                               new);
-                                }
-
-				return ret_val;
-		        }
-	        }m0_be_tlist_endfor;
-
-		/* If key is largest in the list, add at tail */
-                /* First capture the original tail to add in credit */
-                ret_val = __add_at_tail_to_tlist(handle, new, key, buf,
-                                                 tx);
-	}
-	return ret_val;
-}
+                                desc_t = handle->ks_list_descr;
+                                m0_be_tlist_add_before(desc_t, scan,
+                                                       new);
 
-void m0_be_ks_obj_fini(struct m0_be_tx *tx)
-{
-        m0_be_tx_done(tx);
-        m0_sm_group_lock(tx->bt_impl.sm_group);
-        m0_sm_timedwait(&tx->bt_sm,
-                        (1 << M0_BETX_DONE) | (1 << M0_BETX_FAILED),
-                        M0_TIME_NEVER);
-        m0_sm_group_unlock(tx->bt_impl.sm_group);
+                                ret_val = BE_KV_SUCCESS;
+                                break;
+                        }
+                }m0_be_tlist_endfor;
 
+                /* If key is largest in the list, add at tail */
+                if (ret_val == BE_KV_INVALID_REQ)
+                        ret_val = __add_at_tail_to_tlist(handle, new, tx);
 
-        m0_be_tx_fini(tx);
-        rvm_truncate();
-}
+        }
+
+       if (ins_tx == NULL) {
+             m0_be_tx_done(tx);
+             m0_sm_group_lock(tx->bt_impl.sm_group);
+             m0_sm_timedwait(&tx->bt_sm, (1 << M0_BETX_DONE) |
+                             (1 << M0_BETX_FAILED), M0_TIME_NEVER);
+             m0_sm_group_unlock(tx->bt_impl.sm_group);
+             m0_be_tx_fini(tx);
+             free(tx);
+       }
 
+
+
+        return ret_val;
+}
+M0_EXPORTED(m0_ks_init);
 /* @} end of be_kv_store group */
 
 /*
diff --git a/be/lib/be_kv_store.h b/be/lib/be_kv_store.h
index 1799e0a..540d190 100644
--- a/be/lib/be_kv_store.h
+++ b/be/lib/be_kv_store.h
@@ -1,6 +1,6 @@
 /* -*- C -*- */
 /*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
+ * COPYRIGHT 2012 XYRATEX TECHNOLOGY LIMITED
  *
  * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
  * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
@@ -14,7 +14,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: 	   Zishan Shaikh <zishan_shaikh@xyratex.com>
+ * Original author: Zishan Shaikh <zishan_shaikh@xyratex.com>
  * Original creation date: 12/06/2012
  */
 #pragma once
@@ -29,153 +29,103 @@
 #define BE_KV_FAILURE     -1
 #define BE_KV_SUCCESS      0
 #define BE_KV_INVALID_REQ  1
-#define MAX_KEY_SIZE  	   256
 /**
    @defgroup be_kv_store Key Value Store
  */
 
-/*
- *	Structure to hold logical address for object that stores key
- */
-struct m0_kv_key_ref {
-	/* segment id of the key's object */
-	uint64_t	kv_segid;
-	/* offset within the segment */
-	uint64_t	kv_offset;
-	/* magic value, set to the linkage magic value */
-	uint64_t	kv_magic;
-};
-
-/*
- *	Structure to hold the key
- */
-struct m0_kv_key {
-	/* actual key */
-	char 			kv_key[MAX_KEY_SIZE];
-	/* logical_address details of key's object */
-	struct m0_kv_key_ref	kv_logical_addr;
-};
+/* Function compare routines. Used in key value store while searching for key */
+typedef int     (*kv_key_cmp)(void *, void *);
+typedef int     (*kv_key_match)(void *, void *);
 
 /**
- *	Structure to hold the actual <key, value> pair in an object
- */
-struct m0_kv_store_obj {
-	struct m0_kv_key   	kvs_key_hold;
-	struct m0_be_reg       *kvs_val_reg;
-	struct m0_be_tlink 	kvs_linkage;
-        uint64_t 	   	kvs_ref_magic;
-};
-
-/**
- *	Structure to hold the handle to current tlist and its descriptor
+ * Structure to hold the handle to current tlist and its descriptor
  */
 struct m0_kv_store {
-	/* List descriptor for the tlist */
-	struct m0_be_tl_descr   ks_list_descr;
-	/* The tlist itself */
-	struct m0_be_tl	        ks_tlist;
-        /* Segment pointer */
-        struct m0_be_seg        *ks_seg;
+        /* List descriptor for the tlist */
+        struct m0_be_tl_descr   *ks_list_descr;
+        /* The tlist itself */
+        struct m0_be_tl          ks_tlist;
         /* Domain pointer */
         struct m0_be_domain     *ks_dom;
+        /* Compare function from user */
+        kv_key_cmp               kv_key_cmp;
+        /* Match function from user */
+        kv_key_match             kv_key_match;
 
-        struct m0_stob          *ks_ns_stob;
-        struct m0_stob          *ks_stob;
-        struct m0_stob          *ks_log_stob;
 };
 
 /**
  * Initialises the domain and segment to be used in the tlist.
  *
+ * @param handle        :       m0_kv_store handle to be initialised with @dom
  * @param dom           :       be_domain to be initialised
- * @param seg           :       segment in the domain to be initialised
- * @param ns_stob       :       underlying storage object(given to seg in @dom)
- * @param stob          :       storage object to create the segment
- * @param log_stob      :       Stob which is used as log device for entire back
- *                              -end domain.
  */
-int m0_ks_init_domain_and_segment(struct m0_be_domain *dom,
-                                   struct m0_be_seg    *seg,
-                                   struct m0_stob      *ns_stob,
-                                   struct m0_stob      *stob,
-                                   struct m0_stob      *log_stob);
+M0_INTERNAL int m0_ks_init_domain(struct m0_kv_store   *handle,
+                                  struct m0_be_domain **dom);
 
 /*
  * Create and return the handle the user for the key_value_store
  *
- * @param handle	:	pointer to the handle, out parameter
- * @param list_name	:	name to be given the @tlist in @list_descr
- * link_magic		:	magic value to be assigned to the linkage in
-  				the tlist
- * head_magic		:	magic value to be assigned to the head in the
-  				tlist
- */
-void  m0_ks_init(struct m0_kv_store *handle, char *list_name,
-		 uint64_t link_magic, uint64_t head_magic);
-
-/**
- * Updates the domain, segment and values in the @handle
- *
- * @param handle        :       handle to be updated
- * @param dom           :       be_domain pointer
- * @param seg           :       segment pointer to be assigned
- * @param ns_stob       :       underlying storage object(given to seg in @dom)
- * @param stob          :       storage object in @seg to be assigned
- * @param log_stob      :       log device storage object to be assigned
+ * @param handle        :       pointer to the handle, out parameter
+ * @param descr         :       the tlist descriptor to be given to the tlist in
+ *                              kv_store
+ * @param dom           :       the domain pointer to be initialised
+ * @param cmp_fp        :       user defined function to compare keys
+ * @param match_fp      :       user defined function to match keys
  */
-void m0_ks_update_handle(struct m0_kv_store  *handle,
-                         struct m0_be_domain *dom,
-                         struct m0_be_seg    *seg,
-                         struct m0_stob      *ns_stob,
-                         struct m0_stob      *stob,
-                         struct m0_stob      *log_stob);
+M0_INTERNAL void m0_ks_init(struct m0_kv_store     *handle,
+                            struct m0_be_tl_descr  *descr,
+                            struct m0_be_domain   **dom,
+                            kv_key_cmp              cmp_fp,
+                            kv_key_match            match_fp);
 
 /*
  * Insert a key value pair in the tlist contained in @handle.
  * Returns BE_KV_FAILURE or BE_KV_SUCCESS
  *
- * @param handle	:	handle containing the tlist in which the
- 				<key, value> pair has to be stored
- * @param key		:	key to be inserted into the list
- * @param ref_value	:	value associated with the key
+ * @param handle        :       handle containing the tlist in which the
+ *                              object will be stored
+ * @param obj           :       user object to stored in the tlist
+ * @param tx            :       transaction handle. Can be NULL.
  */
-int  m0_ks_insert(struct m0_kv_store  *handle, struct m0_kv_key *key,
-		  struct m0_be_tx  *tx);
+M0_INTERNAL int  m0_ks_insert(struct m0_kv_store  *handle, void *obj,
+                              struct m0_be_tx  *tx);
 
 /*
- * Find value with the @key in the tlist contained in @handle.
- * Returns the value associated if the key is found, else NULL
+ * Find @obj in the tlist contained in @handle.
+ * Returns the value i.e. m0_reference associated if the key is found, else NULL
  *
- * @param handle	:	handle containing the tlist in which the
- 				<key, value> pair has to be stored
- * @param key		:	key to be searched into the list
+ * @param handle        :       handle containing the tlist in which the
+ *                              @obj is stored.
+ * @param obj           :       object whose key is to be searched in the tlist
  */
-struct m0_be_buf  *m0_ks_find(struct m0_kv_store *handle,
-                              struct m0_kv_key   *key);
+M0_INTERNAL struct m0_reference  *m0_ks_find(struct m0_kv_store *handle,
+                                             void *obj);
 
 /*
- * Delete the object with the @key in the tlist contained in @handle.
- * Returns NULL in case of failures.
- * Returns the region associated with the key. User may decide the fate of
- * return value
+ * Delete the object in the tlist contained in @handle.
+ * Returns BE_KV_FAILURE in case of failures.
  *
- * @param handle	:	handle containing the tlist in which the
- 				<key, value> pair has to be stored
- * @param key		:	key to be removed from the list
+ * @param handle        :       handle containing the tlist in which the @obj is
+ *                              stored
+ * @param obj           :       obj whose key has to be delted
+ * @param tx            :       transaction handle. Can be NULL.
  */
-struct m0_be_reg  *m0_ks_delete(struct m0_kv_store *handle,
-                                struct m0_kv_key *key,
-                                struct m0_be_tx *tx);
+M0_INTERNAL int m0_ks_delete(struct m0_kv_store *handle,
+                             void *obj,
+                             struct m0_be_tx *tx);
 
 /*
- * Fini and end the transaction.
+ * Returns the m0_reference i.e logical address of the object present next to
+ * @obj in the tlist contained in @handle
+ * Returns NULL on failure
  */
-void m0_be_ks_obj_fini(struct m0_be_tx *tx);
+M0_INTERNAL struct m0_reference
+*m0_ks_get_next_value(struct m0_kv_store *handle, void *obj);
 
 /** @} end of be_kv_store group */
 
-/* __MERO_BE_LIB_BE_KV_STORE_H__ */
-#endif
+#endif /* __MERO_BE_LIB_BE_KV_STORE_H__ */
 
 /*
  * Local variables:
diff --git a/be/lib/be_list.c b/be/lib/be_list.c
index 571a48e..e912ed5 100644
--- a/be/lib/be_list.c
+++ b/be/lib/be_list.c
@@ -13,42 +13,52 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author  	  : Zishan Shaikh <zishan_shaikh@xyratex.com>
+ * Original author: Zishan Shaikh <zishan_shaikh@xyratex.com>
  * Original creation date : 12/04/2012
  */
 #include "lib/assert.h"
 #include "be/lib/be_list.h"
 
-/** @addtogroup be_list @{ */
+/** @addtogroup be_list
+ * @{
+ */
 
-void m0_be_list_init(struct m0_be_list *head)
+M0_INTERNAL void m0_be_list_init(struct m0_be_list *head)
 {
-	head->l_head.virtual_address = (struct m0_be_list_link *)head;
-	head->l_tail.virtual_address = (struct m0_be_list_link *)head;
+        head->l_head.virtual_address = (struct m0_be_list_link *)head;
+        head->l_tail.virtual_address = (struct m0_be_list_link *)head;
+
+        /*
+         * Temporary change. Will be upgraded with proper details.
+         * Set to 1 as we are using just one segment, FOR NOW.
+         */
+        head->l_head.logical_address.segid_offset.u_hi = 1;
+        head->l_tail.logical_address.segid_offset.u_hi = 1;
+
 }
 M0_EXPORTED(m0_be_list_init);
 
-void m0_be_list_fini(struct m0_be_list *head)
+M0_INTERNAL void m0_be_list_fini(struct m0_be_list *head)
 {
-	M0_ASSERT(m0_be_list_is_empty(head));
+        M0_ASSERT(m0_be_list_is_empty(head));
 }
 M0_EXPORTED(m0_be_list_fini);
 
-bool m0_be_list_is_empty(const struct m0_be_list *head)
+M0_INTERNAL bool m0_be_list_is_empty(const struct m0_be_list *head)
 {
-	return head->l_head.virtual_address == (void *)head;
+        return head->l_head.virtual_address == (void *)head;
 }
 M0_EXPORTED(m0_be_list_is_empty);
 
-bool m0_be_list_link_invariant(const struct m0_be_list_link *link)
+M0_INTERNAL bool m0_be_list_link_invariant(const struct m0_be_list_link *link)
 {
         struct m0_be_list_link *scan;
         struct m0_be_list_link *next_temp;
         struct m0_be_list_link *prev_temp;
 
         if ((link->ll_next.virtual_address == link) !=
-     	    (link->ll_prev.virtual_address == link))
-                	return false;
+            (link->ll_prev.virtual_address == link))
+                return false;
 
         for (scan = link->ll_next.virtual_address;
              scan != link;
@@ -56,168 +66,172 @@ bool m0_be_list_link_invariant(const struct m0_be_list_link *link)
                 next_temp = scan->ll_next.virtual_address;
                 prev_temp = scan->ll_prev.virtual_address;
 
-		if (next_temp->ll_prev.virtual_address != scan ||
+                if (next_temp->ll_prev.virtual_address != scan ||
                     prev_temp->ll_next.virtual_address != scan)
-			return false;
+                        return false;
         }
         return true;
 }
 
-bool m0_be_list_invariant(const struct m0_be_list *head)
+M0_INTERNAL bool m0_be_list_invariant(const struct m0_be_list *head)
 {
-	return m0_be_list_link_invariant((void *)head);
+        return m0_be_list_link_invariant((void *)head);
 }
 
-size_t m0_be_list_length(const struct m0_be_list *list)
+M0_INTERNAL size_t m0_be_list_length(const struct m0_be_list *list)
 {
-	size_t                 length;
-	struct m0_be_list_link *scan;
+        struct m0_be_list_link *scan;
+        size_t                 length;
 
-	M0_ASSERT(m0_be_list_invariant(list));
-	length = 0;
+        M0_ASSERT(m0_be_list_invariant(list));
+        length = 0;
 
-	for (scan = list->l_head.virtual_address;
-	     scan != (void *)list;
-	     scan = scan->ll_next.virtual_address)
-        		length++;
+        for (scan = list->l_head.virtual_address;
+             scan != (void *)list;
+             scan = scan->ll_next.virtual_address)
+                length++;
 
         return length;
 }
 
-bool m0_be_list_contains(const struct m0_be_list *list,
-  		         const struct m0_be_list_link *link)
+M0_INTERNAL bool m0_be_list_contains(const struct m0_be_list *list,
+                                     const struct m0_be_list_link *link)
 {
-	struct m0_be_list_link *scan;
+        struct m0_be_list_link *scan;
 
-	M0_ASSERT(m0_be_list_invariant(list));
+        M0_ASSERT(m0_be_list_invariant(list));
 
-	for (scan = list->l_head.virtual_address;
-	     scan != (void *)list;
-	     scan = scan->ll_next.virtual_address)
-        		if (scan == link)
-	        		return true;
-	return false;
+        for (scan = list->l_head.virtual_address;
+             scan != (void *)list;
+             scan = scan->ll_next.virtual_address)
+                if (scan == link)
+                        return true;
+        return false;
 }
 
 static inline void __m0_be_list_add(struct m0_be_list_link *next,
-				    struct m0_be_list_link *prev,
-			            struct m0_be_list_link *new)
+                                    struct m0_be_list_link *prev,
+                                    struct m0_be_list_link *new)
 {
-	M0_ASSERT(prev->ll_next.virtual_address == (void *)next &&
-		  next->ll_prev.virtual_address == (void *)prev);
-	M0_ASSERT(m0_be_list_link_invariant(next));
+        M0_ASSERT(prev->ll_next.virtual_address == (void *)next &&
+                  next->ll_prev.virtual_address == (void *)prev);
+        M0_ASSERT(m0_be_list_link_invariant(next));
 
-	new->ll_next.virtual_address  = (void *)next;
-	new->ll_prev.virtual_address  = (void *)prev;
+        new->ll_next.virtual_address  = next;
+        new->ll_prev.virtual_address  = prev;
 
-	next->ll_prev.virtual_address = (void *)new;
-	prev->ll_next.virtual_address = (void *)new;
+        next->ll_prev.virtual_address = new;
+        prev->ll_next.virtual_address = new;
 
-	M0_ASSERT(m0_be_list_link_invariant(next));
+        M0_ASSERT(m0_be_list_link_invariant(next));
 }
 
-void m0_be_list_add(struct m0_be_list *head, struct m0_be_list_link *new)
+M0_INTERNAL void m0_be_list_add(struct m0_be_list *head,
+                                struct m0_be_list_link *new)
 {
-	__m0_be_list_add(head->l_head.virtual_address, (void *)head, new);
+        __m0_be_list_add(head->l_head.virtual_address, (void *)head, new);
 }
 M0_EXPORTED(m0_be_list_add);
 
-void m0_be_list_add_tail(struct m0_be_list *head, struct m0_be_list_link *new)
+M0_INTERNAL void m0_be_list_add_tail(struct m0_be_list *head,
+                                     struct m0_be_list_link *new)
 {
-	__m0_be_list_add((void *)head, head->l_tail.virtual_address, new);
+        __m0_be_list_add((void *)head, head->l_tail.virtual_address, new);
 }
 M0_EXPORTED(m0_be_list_add_tail);
 
-void m0_be_list_add_after(struct m0_be_list_link *anchor,
-			  struct m0_be_list_link *new)
+M0_INTERNAL void m0_be_list_add_after(struct m0_be_list_link *anchor,
+                                      struct m0_be_list_link *new)
 {
-	__m0_be_list_add(anchor->ll_next.virtual_address, anchor, new);
+        __m0_be_list_add(anchor->ll_next.virtual_address, anchor, new);
 }
 M0_EXPORTED(m0_be_list_add_after);
 
-void m0_be_list_add_before(struct m0_be_list_link *anchor,
-			   struct m0_be_list_link *new)
+M0_INTERNAL void m0_be_list_add_before(struct m0_be_list_link *anchor,
+                                       struct m0_be_list_link *new)
 {
-	__m0_be_list_add(anchor, anchor->ll_prev.virtual_address, new);
+        __m0_be_list_add(anchor, anchor->ll_prev.virtual_address, new);
 }
 M0_EXPORTED(m0_be_list_add_before);
 
 static void __m0_be_list_del(struct m0_be_list_link *old)
 {
-	M0_ASSERT(m0_be_list_link_invariant(old));
-	struct m0_be_list_link *prev_temp;
-	struct m0_be_list_link *next_temp;
+        M0_ASSERT(m0_be_list_link_invariant(old));
+        struct m0_be_list_link *prev_temp;
+        struct m0_be_list_link *next_temp;
 
         prev_temp = old->ll_prev.virtual_address;
-	next_temp = old->ll_next.virtual_address;
+        next_temp = old->ll_next.virtual_address;
 
-	prev_temp->ll_next.virtual_address = next_temp;
+        prev_temp->ll_next.virtual_address = next_temp;
         next_temp->ll_prev.virtual_address = prev_temp;
 }
 
-void m0_be_list_del(struct m0_be_list_link *old)
+M0_INTERNAL void m0_be_list_del(struct m0_be_list_link *old)
 {
-	__m0_be_list_del(old);
-	m0_be_list_link_init(old, NULL);
+        __m0_be_list_del(old);
+        m0_be_list_link_init(old, NULL);
 }
 M0_EXPORTED(m0_be_list_del);
 
-void m0_be_list_move(struct m0_be_list *head, struct m0_be_list_link *old)
+M0_INTERNAL void m0_be_list_move(struct m0_be_list      *head,
+                                 struct m0_be_list_link *old)
 {
-	__m0_be_list_del(old);
-	m0_be_list_add(head, old);
-	M0_ASSERT(m0_be_list_invariant(head));
+        __m0_be_list_del(old);
+        m0_be_list_add(head, old);
+        M0_ASSERT(m0_be_list_invariant(head));
 }
 
-void m0_be_list_move_tail(struct m0_be_list *head, struct m0_be_list_link *old)
+M0_INTERNAL void m0_be_list_move_tail(struct m0_be_list      *head,
+                                      struct m0_be_list_link *old)
 {
-	__m0_be_list_del(old);
-	m0_be_list_add_tail(head, old);
-	M0_ASSERT(m0_be_list_invariant(head));
+        __m0_be_list_del(old);
+        m0_be_list_add_tail(head, old);
+        M0_ASSERT(m0_be_list_invariant(head));
 }
 
-void m0_be_list_link_init(struct m0_be_list_link *link,
-                          struct m0_reference *ref)
+M0_INTERNAL void m0_be_list_link_init(struct m0_be_list_link *link,
+                                      struct m0_reference    *ref)
 {
-	uint64_t 	  seg_id;
-	uint64_t 	  offset;
-        struct m0_uint128 *next_temp;
-        struct m0_uint128 *prev_temp;
+        struct m0_uint128      *next_temp;
+        struct m0_uint128      *prev_temp;
+        uint64_t                seg_id;
+        uint64_t                offset;
 
-	link->ll_prev.virtual_address = (void *)link;
-	link->ll_next.virtual_address = (void *)link;
+        link->ll_prev.virtual_address = (void *)link;
+        link->ll_next.virtual_address = (void *)link;
 
-	if (ref != NULL) {
-		seg_id    = ref->segid_offset.u_hi;
-		offset    = ref->segid_offset.u_lo;
+        if (ref != NULL) {
+                seg_id    = ref->segid_offset.u_hi;
+                offset    = ref->segid_offset.u_lo;
 
                 next_temp = &(link->ll_next.logical_address.segid_offset);
                 prev_temp = &(link->ll_prev.logical_address.segid_offset);
 
-		next_temp->u_hi = seg_id;
-		next_temp->u_lo = offset;
+                next_temp->u_hi = seg_id;
+                next_temp->u_lo = offset;
 
-		prev_temp->u_hi = seg_id;
-		prev_temp->u_lo = offset;
-	}
+                prev_temp->u_hi = seg_id;
+                prev_temp->u_lo = offset;
+        }
 }
 M0_EXPORTED(m0_be_list_link_init);
 
 
-void m0_be_list_link_fini(struct m0_be_list_link *link)
+M0_INTERNAL void m0_be_list_link_fini(struct m0_be_list_link *link)
 {
-	M0_ASSERT(!m0_be_list_link_is_in(link));
+        M0_ASSERT(!m0_be_list_link_is_in(link));
 }
 
-bool m0_be_list_link_is_in(const struct m0_be_list_link *link)
+M0_INTERNAL bool m0_be_list_link_is_in(const struct m0_be_list_link *link)
 {
-	return link->ll_prev.virtual_address != (void *)link;
+        return link->ll_prev.virtual_address != (void *)link;
 }
 
-bool m0_be_list_link_is_last(const struct m0_be_list_link	*link,
-                             const struct m0_be_list		*head)
+M0_INTERNAL bool m0_be_list_link_is_last(const struct m0_be_list_link *link,
+                                         const struct m0_be_list      *head)
 {
-	return link->ll_next.virtual_address == (void *)head;
+        return link->ll_next.virtual_address == (void *)head;
 }
 
 /** @} end of be_list group */
diff --git a/be/lib/be_list.h b/be/lib/be_list.h
index 72578c4..d58c92a 100644
--- a/be/lib/be_list.h
+++ b/be/lib/be_list.h
@@ -14,8 +14,8 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author  	  : Zishan Shaikh <zishan_shaikh@xyratex.com>
- * Original creation date : 11/28/2012
+ * Original author: Zishan Shaikh <zishan_shaikh@xyratex.com>
+ * Original creation date: 11/28/2012
  */
 #pragma once
 
@@ -26,169 +26,169 @@
 #include "lib/cdefs.h"
 #include "lib/assert.h"
 
+/**
+ * @defgroup be_list Double-linked list.
+ * @{
+ */
+
 struct m0_be_list_link;
 
 /**
- *	Structure to support the linkage in tlist and store the logical address
- *	details of the object
+ * Structure to support the linkage in tlist and store the logical address
+ * details of the object
  */
 struct m0_reference_ll {
-	union {
-		struct m0_be_list_link  *virtual_address;
-	        struct m0_reference      logical_address;
-	};
+        union {
+                struct m0_be_list_link  *virtual_address;
+                struct m0_reference      logical_address;
+        };
 };
 
 /**
-   @defgroup be_list Double-linked list.
-
-   @{
+ * List entry.
+ * Modified to support traversal in tlist via references
  */
-
-/**
-   List entry.
-   Modified to support traversal in tlist via references
- */
-
 struct m0_be_list_link {
-	/* Next entry in the list */
-	struct m0_reference_ll ll_next;
-	/* Previous entry in the list */
-	struct m0_reference_ll ll_prev;
+        /* Next entry in the list */
+        struct m0_reference_ll ll_next;
+        /* Previous entry in the list */
+        struct m0_reference_ll ll_prev;
 };
 
 /**
- initialize list link entry for be domain
-
- @param link - pointer to link entry
- @param ref  - pointer to struct m0_reference in m0_buf
-*/
-void m0_be_list_link_init(struct m0_be_list_link *link,
-                          struct m0_reference *ref);
+ * initialize list link entry for be domain
+ *
+ * @param link - pointer to link entry
+ * @param ref  - pointer to struct m0_reference in m0_buf
+ */
+M0_INTERNAL void m0_be_list_link_init(struct m0_be_list_link *link,
+                                      struct m0_reference    *ref);
 
 /**
- free resources associated with link entry
-
- @param link - pointer to link enty
-*/
-void m0_be_list_link_fini(struct m0_be_list_link *link);
+ * free resources associated with link entry
+ *
+ * @param link - pointer to link enty
+ */
+M0_INTERNAL void m0_be_list_link_fini(struct m0_be_list_link *link);
 
-bool m0_be_list_link_invariant(const struct m0_be_list_link *link);
+M0_INTERNAL bool m0_be_list_link_invariant(const struct m0_be_list_link *link);
 
 /**
-   List head.
+ * List head.
  */
 struct m0_be_list {
-	/**
-	 * Pointer to the first entry in the list.
-	 */
-	struct m0_reference_ll l_head;
-	/**
-	 * Pointer to the last entry in the list.
-	 */
-	struct m0_reference_ll l_tail;
+        /*
+         * Pointer to the first entry in the list.
+         */
+        struct m0_reference_ll l_head;
+        /*
+         * Pointer to the last entry in the list.
+         */
+        struct m0_reference_ll l_tail;
 };
 
 /*
-   It is necessary that m0_list and m0_list_link structures have exactly the
-   same layout as.
+ * It is necessary that m0_be_list and m0_be_list_link structures have exactly
+ * the same layout.
  */
 
-
 M0_BASSERT(offsetof(struct m0_be_list, l_head) ==
-	   offsetof(struct m0_be_list_link, ll_next));
+           offsetof(struct m0_be_list_link, ll_next));
 M0_BASSERT(offsetof(struct m0_be_list, l_tail) ==
-	   offsetof(struct m0_be_list_link, ll_prev));
+           offsetof(struct m0_be_list_link, ll_prev));
 
 
 /**
-   Initializes list head.
+ * Initializes list head.
  */
-void m0_be_list_init(struct m0_be_list *head);
+M0_INTERNAL void m0_be_list_init(struct m0_be_list *head);
 
 /**
-   Finalizes the list.
+ * Finalizes the list.
  */
-void m0_be_list_fini(struct m0_be_list *head);
+M0_INTERNAL void m0_be_list_fini(struct m0_be_list *head);
 
 /**
- check list is empty
-
- @param head pointer to list head
+ * check list is empty
+ *
+ * @param head pointer to list head
  */
-bool m0_be_list_is_empty(const struct m0_be_list *head);
+M0_INTERNAL bool m0_be_list_is_empty(const struct m0_be_list *head);
 
 /**
-   Returns true iff @link is in @list.
+ * Returns true iff @link is in @list.
  */
-bool m0_be_list_contains(const struct m0_be_list      *list,
-                         const struct m0_be_list_link *link);
+M0_INTERNAL bool m0_be_list_contains(const struct m0_be_list      *list,
+                                     const struct m0_be_list_link *link);
 
 /**
- This function iterates over the argument list checking that double-linked
- list invariant holds (x->ll_prev->ll_next == x && x->ll_next->ll_prev == x).
-
- @return true if @list isn't corrupted
-*/
-bool m0_be_list_invariant(const struct m0_be_list *list);
+ * This function iterates over the argument list checking that double-linked
+ * list invariant holds (x->ll_prev->ll_next == x && x->ll_next->ll_prev == x).
+ *
+ * @return true if @list isn't corrupted
+ */
+M0_INTERNAL bool m0_be_list_invariant(const struct m0_be_list *list);
 
-size_t m0_be_list_length(const struct m0_be_list *list);
+M0_INTERNAL size_t m0_be_list_length(const struct m0_be_list *list);
 
 /**
- add list to top on the list
-
- This function can be called on an uninitialised @new link. All @new fields are
- overwritten.
-
- @param head pointer to list head
- @param new  pointer to list entry
+ * add list to top on the list
+ *
+ * This function can be called on an uninitialised @new link. All @new fields
+ * are overwritten.
 
+ * @param head pointer to list head
+ * @param new  pointer to list entry
  */
-void m0_be_list_add(struct m0_be_list *head, struct m0_be_list_link *new);
+M0_INTERNAL void m0_be_list_add(struct m0_be_list       *head,
+                                struct m0_be_list_link  *new);
 
 /**
- add list to tail on the list
-
- This function can be called on an uninitialised @new link. All @new fields are
- overwritten.
-
- @param head pointer to list head
- @param new  pointer to list entry
+ * add list to tail on the list
+ *
+ * This function can be called on an uninitialised @new link. All @new fields
+ * are overwritten.
+ *
+ * @param head pointer to list head
+ * @param new  pointer to list entry
  */
-void m0_be_list_add_tail(struct m0_be_list *head, struct m0_be_list_link *new);
+M0_INTERNAL void m0_be_list_add_tail(struct m0_be_list      *head,
+                                     struct m0_be_list_link *new);
 
 /**
-   Adds an element to the list right after the specified element.
-
-   This function can be called on an uninitialised @new link. All @new fields
-   are overwritten.
+ * Adds an element to the list right after the specified element.
+ *
+ * This function can be called on an uninitialised @new link. All @new fields
+ * are overwritten.
  */
-void m0_be_list_add_after (struct m0_be_list_link *anchor,
-			   struct m0_be_list_link *new);
+M0_INTERNAL void m0_be_list_add_after (struct m0_be_list_link *anchor,
+                                       struct m0_be_list_link *new);
 
 /**
-   Adds an element to the list right before the specified element.
-
-   This function can be called on an uninitialised @new link. All @new fields
-   are overwritten.
+ * Adds an element to the list right before the specified element.
+ *
+ * This function can be called on an uninitialised @new link. All @new fields
+ * are overwritten.
  */
-void m0_be_list_add_before(struct m0_be_list_link *anchor,
-			   struct m0_be_list_link *new);
+M0_INTERNAL void m0_be_list_add_before(struct m0_be_list_link *anchor,
+                                       struct m0_be_list_link *new);
 
 /**
-   Deletes an entry from the list and re-initializes the entry.
+ * Deletes an entry from the list and re-initializes the entry.
  */
-void m0_be_list_del(struct m0_be_list_link *old);
+M0_INTERNAL void m0_be_list_del(struct m0_be_list_link *old);
 
 /**
-   Moves an entry to head of the list.
+ * Moves an entry to head of the list.
  */
-void m0_be_list_move(struct m0_be_list *head, struct m0_be_list_link *new);
+M0_INTERNAL void m0_be_list_move(struct m0_be_list      *head,
+                                 struct m0_be_list_link *new);
 
 /**
-   Moves an entry to tail of the list.
+ * Moves an entry to tail of the list.
  */
-void m0_be_list_move_tail(struct m0_be_list *head, struct m0_be_list_link *new);
+M0_INTERNAL void m0_be_list_move_tail(struct m0_be_list      *head,
+                                      struct m0_be_list_link *new);
 
 /**
  * return first entry from the list
@@ -200,74 +200,75 @@ void m0_be_list_move_tail(struct m0_be_list *head, struct m0_be_list_link *new);
 static inline struct m0_be_list_link
 *m0_be_list_first(const struct m0_be_list *head)
 {
-	return head->l_head.virtual_address !=
-	       (void *)head ? head->l_head.virtual_address : NULL;
+        return head->l_head.virtual_address !=
+               (void *)head ? head->l_head.virtual_address : NULL;
 }
 
 
 /**
- is link entry connected to the list
-
- @param link - pointer to link entry
-
- @retval true - entry connected to a list
- @retval false - entry disconnected from a list
+ * is link entry connected to the list
+ *
+ * @param link - pointer to link entry
+ * @retval true - entry connected to a list
+ * @retval false - entry disconnected from a list
 */
-bool m0_be_list_link_is_in(const struct m0_be_list_link *link);
+M0_INTERNAL bool m0_be_list_link_is_in(const struct m0_be_list_link *link);
 
-bool m0_be_list_link_is_last(const struct m0_be_list_link *link,
-			     const struct m0_be_list      *head);
+M0_INTERNAL bool m0_be_list_link_is_last(const struct m0_be_list_link *link,
+                                         const struct m0_be_list      *head);
 
-size_t m0_be_list_length(const struct m0_be_list *list);
+M0_INTERNAL size_t m0_be_list_length(const struct m0_be_list *list);
 
 /**
  * get pointer to object from pointer to list link entry
  */
-#define m0_list_entry(link, type, member) \
-	container_of(link, type, member)
+#define m0_be_list_entry(link, type, member) \
+        container_of(link, type, member)
 
 /**
  * Iterates over a list
  *
- * @param head	the head of list.
- * @param pos	the pointer to list_link to use as a loop counter.
+ * @param head : the head of list.
+ * @param pos  : the pointer to list_link to use as a loop counter.
  */
 #define m0_be_list_for_each(head, pos) \
-	for (pos = (head)->l_head.virtual_address; pos != (void *)(head); \
-	     pos = (pos)->ll_next.virtual_address)
+        for (pos = (head)->l_head.virtual_address; pos != (void *)(head); \
+             pos = (pos)->ll_next.virtual_address)
 
 /**
-   Read-only iterates over a "typed" list.
-
-   The loop body is not allowed to modify the list.
+ * Read-only iterates over a "typed" list.
+ *
+ * The loop body is not allowed to modify the list.
  */
 #define m0_be_list_for_each_entry(head, pos, type, member) \
-	for (pos = m0_list_entry((head)->l_head.virtual_address, type, member);\
-	     &(pos->member) != (void *)head; \
-	     pos = m0_list_entry((pos)->member.ll_next.virtual_address,        \
-	                         type, member))
+        for (pos = m0_be_list_entry((head)->l_head.virtual_address, type, \
+                                    member);\
+             &(pos->member) != (void *)head; \
+             pos = m0_be_list_entry((pos)->member.ll_next.virtual_address,     \
+                                    type, member))
 
 /**
    Iterates over a "typed" list safely: the loop body is allowed to remove the
    current element.
 
-   @param head	the head of list.
-   @param pos	the pointer to list_link to use as a loop counter.
+   @param head : the head of list.
+   @param pos  : the pointer to list_link to use as a loop counter.
  */
-#define m0_be_list_for_each_entry_safe(head, pos, next, type, member)	\
-	for (pos = m0_list_entry((head)->l_head.virtual_address, type, member),\
-	     next = m0_list_entry((pos)->member.ll_next.virtual_address, \
-	  		         type, member);                         \
-	     &(pos)->member != (void *)head;				\
-	     pos = next,						\
-	     next = m0_list_entry((next)->member.ll_next.virtual_address, \
-	     			  type, member))
+#define m0_be_list_for_each_entry_safe(head, pos, next, type, member)   \
+        for (pos = m0_be_list_entry((head)->l_head.virtual_address, type, \
+                                    member),\
+             next = m0_be_list_entry((pos)->member.ll_next.virtual_address,    \
+                                     type, member);                         \
+             &(pos)->member != (void *)head;                            \
+             pos  = next,                                               \
+             next = m0_be_list_entry((next)->member.ll_next.virtual_address, \
+                                     type, member))
 
 
 /** @} end of be_list group */
 
-/* __MERO_BE_LIB_BE_LIST_H__ */
-#endif
+#endif /* __MERO_BE_LIB_BE_LIST_H__ */
+
 
 /*
  *  Local variables:
diff --git a/be/lib/be_tlist.c b/be/lib/be_tlist.c
index f6bef6d..b85ced2 100644
--- a/be/lib/be_tlist.c
+++ b/be/lib/be_tlist.c
@@ -27,12 +27,13 @@
 /**
    Returns the address of a link embedded in an ambient object.
  */
-static struct m0_be_list_link *be_link(const struct m0_be_tl_descr *d,
-				       const void *obj);
+static struct m0_be_list_link
+*be_link(const struct m0_be_tl_descr *d, const void *obj);
 /**
    Returns the value of the magic field in an ambient object
  */
-static uint64_t be_magic(const struct m0_be_tl_descr *d, const void *obj);
+static uint64_t be_magic(const struct m0_be_tl_descr *d,
+                         const void *obj);
 
 /**
    Casts a link to its ambient object.
@@ -40,244 +41,253 @@ static uint64_t be_magic(const struct m0_be_tl_descr *d, const void *obj);
 static void *be_amb(const struct m0_be_tl_descr *d,
                     struct m0_be_list_link *link);
 
-void m0_be_tlist_init(const struct m0_be_tl_descr *d, struct m0_be_tl *list)
+M0_INTERNAL void m0_be_tlist_init(const struct m0_be_tl_descr *d,
+                                   struct m0_be_tl *list)
 {
-	list->t_magic = d->td_head_magic;
-	m0_be_list_init(&list->t_head);
-	M0_POST(m0_be_tlist_invariant(d, list));
+        list->t_magic = d->td_head_magic;
+        m0_be_list_init(&list->t_head);
+        M0_POST(m0_be_tlist_invariant(d, list));
 }
 
-void m0_be_tlist_fini(const struct m0_be_tl_descr *d, struct m0_be_tl *list)
+M0_INTERNAL void m0_be_tlist_fini(const struct m0_be_tl_descr *d,
+                                  struct m0_be_tl *list)
 {
-	M0_PRE(m0_be_tlist_invariant(d, list));
-	m0_be_list_fini(&list->t_head);
+        M0_PRE(m0_be_tlist_invariant(d, list));
+        m0_be_list_fini(&list->t_head);
 }
 
-void m0_be_tlink_init(const struct m0_be_tl_descr *d, struct m0_reference ref)
+M0_INTERNAL void m0_be_tlink_init(const struct m0_be_tl_descr *d,
+                                  struct m0_reference ref)
 {
-	void *obj = ref.virtual_address;
-	m0_be_list_link_init(be_link(d,obj), &ref);
-	if (d->td_link_magic != 0)
-		*(uint64_t *)(obj + d->td_link_magic_offset) = d->td_link_magic;
-	M0_POST(m0_be_tlink_invariant(d, obj));
+        void *obj = ref.virtual_address;
+        m0_be_list_link_init(be_link(d,obj), &ref);
+        if (d->td_link_magic != 0)
+                *(uint64_t *)(obj + d->td_link_magic_offset) = d->td_link_magic;
+        M0_POST(m0_be_tlink_invariant(d, obj));
 }
 
-void m0_be_tlink_init_at(const struct m0_be_tl_descr *d, struct m0_be_tl *list,
-		         struct m0_reference ref)
+M0_INTERNAL void m0_be_tlink_init_at(const struct m0_be_tl_descr *d,
+                                     struct m0_be_tl *list,
+                                     struct m0_reference ref)
 {
-	void *obj = ref.virtual_address;
-	m0_be_tlink_init(d, ref);
-	m0_be_tlist_add(d, list, obj);
+        void *obj = ref.virtual_address;
+        m0_be_tlink_init(d, ref);
+        m0_be_tlist_add(d, list, obj);
 }
 
-void m0_be_tlink_init_at_tail(const struct m0_be_tl_descr *d,
-                              struct m0_be_tl *list, struct m0_reference ref)
+M0_INTERNAL void m0_be_tlink_init_at_tail(const struct m0_be_tl_descr *d,
+                                          struct m0_be_tl *list,
+                                          struct m0_reference ref)
 {
-	void *obj = ref.virtual_address;
-	m0_be_tlink_init(d, ref);
-	m0_be_tlist_add_tail(d, list, obj);
+        void *obj = ref.virtual_address;
+        m0_be_tlink_init(d, ref);
+        m0_be_tlist_add_tail(d, list, obj);
 }
 
-void m0_be_tlink_fini(const struct m0_be_tl_descr *d, void *obj)
+M0_INTERNAL void m0_be_tlink_fini(const struct m0_be_tl_descr *d, void *obj)
 {
-	m0_be_list_link_fini(be_link(d, obj));
+        m0_be_list_link_fini(be_link(d, obj));
 }
 
-void m0_be_tlink_del_fini(const struct m0_be_tl_descr *d, void *obj)
+M0_INTERNAL void m0_be_tlink_del_fini(const struct m0_be_tl_descr *d, void *obj)
 {
-	m0_be_tlist_del(d, obj);
-	m0_be_tlink_fini(d, obj);
+        m0_be_tlist_del(d, obj);
+        m0_be_tlink_fini(d, obj);
 }
 
-bool m0_be_tlist_is_empty(const struct m0_be_tl_descr *d,
-			  const struct m0_be_tl *list)
+M0_INTERNAL bool m0_be_tlist_is_empty(const struct m0_be_tl_descr *d,
+                                      const struct m0_be_tl *list)
 {
-	M0_PRE(m0_be_tlist_invariant(d, list));
-	return m0_be_list_is_empty(&list->t_head);
+        M0_PRE(m0_be_tlist_invariant(d, list));
+        return m0_be_list_is_empty(&list->t_head);
 }
 
-bool m0_be_tlink_is_in(const struct m0_be_tl_descr *d, const void *obj)
+M0_INTERNAL bool m0_be_tlink_is_in(const struct m0_be_tl_descr *d,
+                                   const void *obj)
 {
-	M0_PRE(m0_be_tlink_invariant(d, obj));
-	return m0_be_list_link_is_in(be_link(d, obj));
+        M0_PRE(m0_be_tlink_invariant(d, obj));
+        return m0_be_list_link_is_in(be_link(d, obj));
 }
 
-bool m0_be_tlist_contains(const struct m0_be_tl_descr *d,
-			  const struct m0_be_tl *list,
-		          const void *obj)
+M0_INTERNAL bool m0_be_tlist_contains(const struct m0_be_tl_descr *d,
+                                      const struct m0_be_tl       *list,
+                                      const void                  *obj)
 {
-	M0_PRE(m0_be_tlist_invariant(d, list));
-	M0_PRE(m0_be_tlink_invariant(d, obj));
-	return m0_be_list_contains(&list->t_head, be_link(d, obj));
+        M0_PRE(m0_be_tlist_invariant(d, list));
+        M0_PRE(m0_be_tlink_invariant(d, obj));
+        return m0_be_list_contains(&list->t_head, be_link(d, obj));
 }
 
-size_t m0_be_tlist_length(const struct m0_be_tl_descr *d,
-			  const struct m0_be_tl *list)
+M0_INTERNAL size_t m0_be_tlist_length(const struct m0_be_tl_descr *d,
+                                      const struct m0_be_tl       *list)
 {
-	M0_PRE(m0_be_tlist_invariant(d, list));
-	return m0_be_list_length(&list->t_head);
+        M0_PRE(m0_be_tlist_invariant(d, list));
+        return m0_be_list_length(&list->t_head);
 }
 M0_EXPORTED(m0_be_tlist_length);
 
-void m0_be_tlist_add(const struct m0_be_tl_descr *d, struct m0_be_tl *list,
-		     void *obj)
+M0_INTERNAL void m0_be_tlist_add(const struct m0_be_tl_descr *d,
+                                 struct m0_be_tl *list, void *obj)
 {
-	M0_PRE(m0_be_tlist_invariant(d, list));
-	M0_PRE(!m0_be_tlink_is_in(d, obj));
-	m0_be_list_add(&list->t_head, be_link(d, obj));
+        M0_PRE(m0_be_tlist_invariant(d, list));
+        M0_PRE(!m0_be_tlink_is_in(d, obj));
+        m0_be_list_add(&list->t_head, be_link(d, obj));
 }
 
-void m0_be_tlist_add_tail(const struct m0_be_tl_descr *d,
-		       struct m0_be_tl *list, void *obj)
+M0_INTERNAL void m0_be_tlist_add_tail(const struct m0_be_tl_descr *d,
+                                      struct m0_be_tl *list, void *obj)
 {
-	M0_PRE(m0_be_tlist_invariant(d, list));
-	M0_PRE(!m0_be_tlink_is_in(d, obj));
-	m0_be_list_add_tail(&list->t_head, be_link(d, obj));
+        M0_PRE(m0_be_tlist_invariant(d, list));
+        M0_PRE(!m0_be_tlink_is_in(d, obj));
+        m0_be_list_add_tail(&list->t_head, be_link(d, obj));
 }
 
-void m0_be_tlist_add_after(const struct m0_be_tl_descr *d, void *obj, void *new)
+M0_INTERNAL void m0_be_tlist_add_after(const struct m0_be_tl_descr *d,
+                                       void *obj, void *new)
 {
-	M0_PRE(m0_be_tlink_is_in(d, obj));
-	M0_PRE(!m0_be_tlink_is_in(d, new));
-	m0_be_list_add_after(be_link(d, obj), be_link(d, new));
+        M0_PRE(m0_be_tlink_is_in(d, obj));
+        M0_PRE(!m0_be_tlink_is_in(d, new));
+        m0_be_list_add_after(be_link(d, obj), be_link(d, new));
 }
 
-void m0_be_tlist_add_before(const struct m0_be_tl_descr *d, void *obj,
-                            void *new)
+M0_INTERNAL void m0_be_tlist_add_before(const struct m0_be_tl_descr *d,
+                                        void *obj, void *new)
 {
-	M0_PRE(m0_be_tlink_is_in(d, obj));
-	M0_PRE(!m0_be_tlink_is_in(d, new));
-	m0_be_list_add_before(be_link(d, obj), be_link(d, new));
+        M0_PRE(m0_be_tlink_is_in(d, obj));
+        M0_PRE(!m0_be_tlink_is_in(d, new));
+        m0_be_list_add_before(be_link(d, obj), be_link(d, new));
 }
 
-void m0_be_tlist_del(const struct m0_be_tl_descr *d, void *obj)
+M0_INTERNAL void m0_be_tlist_del(const struct m0_be_tl_descr *d, void *obj)
 {
-	M0_PRE(m0_be_tlink_invariant(d, obj));
-	M0_PRE(m0_be_tlink_is_in(d, obj));
-	m0_be_list_del(be_link(d, obj));
-	M0_PRE(!m0_be_tlink_is_in(d, obj));
+        M0_PRE(m0_be_tlink_invariant(d, obj));
+        M0_PRE(m0_be_tlink_is_in(d, obj));
+        m0_be_list_del(be_link(d, obj));
+        M0_PRE(!m0_be_tlink_is_in(d, obj));
 }
 
-void m0_be_tlist_move(const struct m0_be_tl_descr *d, struct m0_be_tl *list,
-		      void *obj)
+M0_INTERNAL void m0_be_tlist_move(const struct m0_be_tl_descr *d,
+                                  struct m0_be_tl *list, void *obj)
 {
-	M0_PRE(m0_be_tlist_invariant(d, list));
-	M0_PRE(m0_be_tlink_is_in(d, obj));
+        M0_PRE(m0_be_tlist_invariant(d, list));
+        M0_PRE(m0_be_tlink_is_in(d, obj));
 
-	m0_be_list_move(&list->t_head, be_link(d, obj));
+        m0_be_list_move(&list->t_head, be_link(d, obj));
 }
 
-void m0_be_tlist_move_tail(const struct m0_be_tl_descr *d,
-			   struct m0_be_tl *list, void *obj)
+M0_INTERNAL void m0_be_tlist_move_tail(const struct m0_be_tl_descr *d,
+                                       struct m0_be_tl *list, void *obj)
 {
-	M0_PRE(m0_be_tlist_invariant(d, list));
-	M0_PRE(m0_be_tlink_is_in(d, obj));
+        M0_PRE(m0_be_tlist_invariant(d, list));
+        M0_PRE(m0_be_tlink_is_in(d, obj));
 
-	m0_be_list_move_tail(&list->t_head, be_link(d, obj));
+        m0_be_list_move_tail(&list->t_head, be_link(d, obj));
 }
 
-void *m0_be_tlist_head(const struct m0_be_tl_descr *d,
-                       const struct m0_be_tl *list)
+M0_INTERNAL void *m0_be_tlist_head(const struct m0_be_tl_descr *d,
+                                   const struct m0_be_tl *list)
 {
-	const struct m0_be_list *head;
+        const struct m0_be_list *head;
 
-	M0_PRE(m0_be_tlist_invariant(d, list));
+        M0_PRE(m0_be_tlist_invariant(d, list));
 
-	head = &list->t_head;
-	return (head->l_head.virtual_address !=
-	       (void *)head ? be_amb(d, head->l_head.virtual_address) : NULL);
+        head = &list->t_head;
+        return (head->l_head.virtual_address !=
+               (void *)head ? be_amb(d, head->l_head.virtual_address) : NULL);
 }
 
-void *m0_be_tlist_tail(const struct m0_be_tl_descr *d,
-                       const struct m0_be_tl *list)
+M0_INTERNAL void *m0_be_tlist_tail(const struct m0_be_tl_descr *d,
+                                   const struct m0_be_tl *list)
 {
-	const struct m0_be_list *head;
+        const struct m0_be_list *head;
 
-	M0_PRE(m0_be_tlist_invariant(d, list));
+        M0_PRE(m0_be_tlist_invariant(d, list));
 
-	head = &list->t_head;
-	return (head->l_tail.virtual_address !=
-	       (void *)head ? be_amb(d, head->l_tail.virtual_address) : NULL);
+        head = &list->t_head;
+        return (head->l_tail.virtual_address !=
+               (void *)head ? be_amb(d, head->l_tail.virtual_address) : NULL);
 }
 
-void *m0_be_tlist_next(const struct m0_be_tl_descr *d,
-		    const struct m0_be_tl *list, void *obj)
+M0_INTERNAL void *m0_be_tlist_next(const struct m0_be_tl_descr *d,
+                                   const struct m0_be_tl *list, void *obj)
 {
-	struct m0_be_list_link *next;
+        struct m0_be_list_link *next;
 
-	M0_PRE(m0_be_tlist_contains(d, list, obj));
+        M0_PRE(m0_be_tlist_contains(d, list, obj));
 
-	next = (struct m0_be_list_link *)
+        next = (struct m0_be_list_link *)
                 be_link(d, obj)->ll_next.virtual_address;
-	return (void *)next != &list->t_head ? be_amb(d, next) : NULL;
+        return (void *)next != &list->t_head ? be_amb(d, next) : NULL;
 }
 
-void *m0_be_tlist_prev(const struct m0_be_tl_descr *d,
- 		       const struct m0_be_tl *list, void *obj)
+M0_INTERNAL void *m0_be_tlist_prev(const struct m0_be_tl_descr *d,
+                                   const struct m0_be_tl *list, void *obj)
 {
-	struct m0_be_list_link *prev;
+        struct m0_be_list_link *prev;
 
-	M0_PRE(m0_be_tlist_contains(d, list, obj));
+        M0_PRE(m0_be_tlist_contains(d, list, obj));
 
-	prev = (struct m0_be_list_link *)
+        prev = (struct m0_be_list_link *)
                 be_link(d, obj)->ll_prev.virtual_address;
-	return (void *)prev != &list->t_head ? be_amb(d, prev) : NULL;
+        return (void *)prev != &list->t_head ? be_amb(d, prev) : NULL;
 }
 
-bool m0_be_tlist_invariant(const struct m0_be_tl_descr *d,
-			   const struct m0_be_tl *list)
+M0_INTERNAL bool m0_be_tlist_invariant(const struct m0_be_tl_descr *d,
+                                       const struct m0_be_tl *list)
 {
-	struct m0_be_list_link *head;
-	struct m0_be_list_link *scan;
-	struct m0_be_list_link *next_temp;
-	struct m0_be_list_link *prev_temp;
+        struct m0_be_list_link *head;
+        struct m0_be_list_link *scan;
+        struct m0_be_list_link *next_temp;
+        struct m0_be_list_link *prev_temp;
 
         head = (void *)&list->t_head;
 
-	if (list->t_magic != d->td_head_magic)
-		return false;
-	if ((head->ll_next.virtual_address == (void *)head) !=
-   	    (head->ll_prev.virtual_address == (void *)head))
-		return false;
+        if (list->t_magic != d->td_head_magic)
+                return false;
+        if ((head->ll_next.virtual_address == (void *)head) !=
+            (head->ll_prev.virtual_address == (void *)head))
+                return false;
 
-	for (scan = head->ll_next.virtual_address;
-	     scan != head; scan = scan->ll_next.virtual_address) {
+        for (scan = head->ll_next.virtual_address;
+             scan != head; scan = scan->ll_next.virtual_address) {
 
                 next_temp = scan->ll_next.virtual_address;
                 prev_temp = scan->ll_prev.virtual_address;
 
                 if (next_temp->ll_prev.virtual_address != scan ||
                     prev_temp->ll_next.virtual_address != scan)
-	                        return false;
+                        return false;
 
                 if (!m0_be_tlink_invariant(d, be_amb(d, scan)))
-	                        return false;
+                        return false;
         }
 
-	return true;
+        return true;
 }
 
-bool m0_be_tlink_invariant(const struct m0_be_tl_descr *d, const void *obj)
+M0_INTERNAL bool m0_be_tlink_invariant(const struct m0_be_tl_descr *d,
+                                       const void *obj)
 {
-	return d->td_link_magic == 0 || be_magic(d, obj) == d->td_link_magic;
+        return d->td_link_magic == 0 || be_magic(d, obj) == d->td_link_magic;
 }
 
-static struct m0_be_list_link *be_link(const struct m0_be_tl_descr *d,
-				       const void *obj)
+static struct m0_be_list_link
+*be_link(const struct m0_be_tl_descr *d, const void *obj)
 {
-	return &((struct m0_be_tlink *)(obj + d->td_link_offset))->t_link;
+        return &((struct m0_be_tlink *)(obj + d->td_link_offset))->t_link;
 }
 
-static uint64_t be_magic(const struct m0_be_tl_descr *d, const void *obj)
+static uint64_t be_magic(const struct m0_be_tl_descr *d,
+                         const void *obj)
 {
-	return *(uint64_t *)(obj + d->td_link_magic_offset);
+        return *(uint64_t *)(obj + d->td_link_magic_offset);
 }
 
 static void *be_amb(const struct m0_be_tl_descr *d,
                     struct m0_be_list_link *link)
 {
-	return (void *)container_of(link, struct m0_be_tlink,
-				    t_link) - d->td_link_offset;
+        return (void *)container_of(link, struct m0_be_tlink,
+                                    t_link) - d->td_link_offset;
 }
 
 /** @} end of be_tlist group */
diff --git a/be/lib/be_tlist.h b/be/lib/be_tlist.h
index f38b983..a16fc36 100644
--- a/be/lib/be_tlist.h
+++ b/be/lib/be_tlist.h
@@ -14,16 +14,15 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author  	  : Zishan Shaikh <zishan_shaikh@xyratex.com>
- * Original creation date : 12/04/2012
+ * Original author: Zishan Shaikh <zishan_shaikh@xyratex.com>
+ * Original creation date: 12/04/2012
  */
 #pragma once
-
 #ifndef __MERO_BE_LIB_BE_TLIST_H__
 #define __MERO_BE_LIB_BE_TLIST_H__
 
 #include "be/lib/be_list.h"
-#include "be/lib/be_types.h"                    /* uint64_t */
+#include "be/lib/be_types.h"
 
 /**
    @defgroup be_tlist Typed lists.
@@ -32,7 +31,8 @@
    eliminates some chores and sources of errors typical for the "raw" m0_be_list
    interface.
 
-   Typed list is implemented on top of m0_list and adds the following features:
+   Typed list is implemented on top of m0_be_list and adds the following
+   features:
 
        - a "list descriptor" (m0_be_tl_descr) object holding information about
          this
@@ -48,12 +48,12 @@
 
        - gdb (7.0) pretty-printer for lists (not yet implemented).
 
-   tlist is a safe and more convenient alternative to m0_list. As a general
-   rule, m0_list should be used only when performance is critical or some
+   tlist is a safe and more convenient alternative to m0_be_list. As a general
+   rule, m0_be_list should be used only when performance is critical or some
    flexibility beyond what tlist provides (e.g., a cyclic list without a head
    object) is necessary.
 
-   Similarly to m0_list, tlist is a purely algorithmic module: it deals with
+   Similarly to m0_be_list, tlist is a purely algorithmic module: it deals with
    neither concurrency nor liveness nor with any similar issues that its callers
    are supposed to handle.
 
@@ -67,9 +67,9 @@
      @code
      struct foo {
              ...
-	     // linkage into a list of foo-s hanging off bar::b_list
-	     struct m0_be_tlink f_linkage;
-	     ...
+             // linkage into a list of foo-s hanging off bar::b_list
+             struct m0_be_tlink f_linkage;
+             ...
      };
      @endcode
 
@@ -78,9 +78,9 @@
      @code
      struct bar {
              ...
-	     // list of foo-s, linked through foo::f_linkage
-	     struct m0_be_tl b_list;
-	     ...
+             // list of foo-s, linked through foo::f_linkage
+             struct m0_be_tl b_list;
+             ...
      };
      @endcode
 
@@ -89,8 +89,8 @@
      @code
      static const struct m0_be_tl_descr foobar_list = {
              .td_name        = "foo-s of bar",
-	     .td_link_offset = offsetof(struct foo, f_linkage),
-	     .td_head_magic  = 0x666f6f6261726865 // "foobarhe"
+             .td_link_offset = offsetof(struct foo, f_linkage),
+             .td_head_magic  = 0x666f6f6261726865 // "foobarhe"
      };
      @endcode
 
@@ -101,14 +101,14 @@
    @code
    struct foo {
            ...
-	   uint64_t f_magic;
-	   ...
+           uint64_t f_magic;
+           ...
    };
 
    static const struct m0_be_tl_descr foobar_list = {
            ...
-	   .td_link_magic_offset = offsetof(struct foo, f_magic),
-	   .td_link_magic        = 0x666f6f6261726c69 // "foobarli"
+           .td_link_magic_offset = offsetof(struct foo, f_magic),
+           .td_link_magic        = 0x666f6f6261726c69 // "foobarli"
    };
    @endcode
 
@@ -171,8 +171,8 @@ struct m0_be_tlink;
    for each link embedded in an ambient type.
 
    @verbatim
-			      ambient object
-                          +  +-----------+  +
+                              ambient object
+                          +  +-----------   +
      td_link_magic_offset |  |           |  |
                           v  |           |  |
                              |-----------|  |
@@ -196,56 +196,56 @@ struct m0_be_tlink;
    @endverbatim
  */
 struct m0_be_tl_descr {
-	/** Human-readable list name, used for error messages. */
-	const char *td_name;
-	/** Offset of list link (m0_tlink) in the ambient object. */
-	int         td_link_offset;
-	/**
-	    Offset of magic field in the ambient object.
-	    This is used only when link magic checking is on.
-
-	    @see m0_be_tl_descr::td_link_magic
-	 */
-	int         td_link_magic_offset;
-	/**
-	    Magic stored in an ambient object.
-
-	    If this field is 0, link magic checking is disabled.
-	 */
-	uint64_t    td_link_magic;
-	/**
-	    Magic stored in m0_tl::t_magic and checked on all tlist
-	    operations.
-	 */
-	uint64_t    td_head_magic;
+        /** Human-readable list name, used for error messages. */
+        const char *td_name;
+        /** Offset of list link (m0_tlink) in the ambient object. */
+        int         td_link_offset;
+        /**
+            Offset of magic field in the ambient object.
+            This is used only when link magic checking is on.
+
+            @see m0_be_tl_descr::td_link_magic
+         */
+        int         td_link_magic_offset;
+        /**
+            Magic stored in an ambient object.
+
+            If this field is 0, link magic checking is disabled.
+         */
+        uint64_t    td_link_magic;
+        /**
+            Magic stored in m0_tl::t_magic and checked on all tlist
+            operations.
+         */
+        uint64_t    td_head_magic;
 };
 
 #define M0_BE_TL_DESCR(name, ambient_type, link_field, link_magic_field,\
-                       link_magic, head_magic)				\
-{									\
-	.td_name              = name,					\
-	.td_link_offset       = offsetof(ambient_type, link_field),	\
-	.td_link_magic_offset = offsetof(ambient_type, link_magic_field), \
-	.td_link_magic        = link_magic,				\
-	.td_head_magic        = head_magic				\
-};									\
-									\
-M0_BASSERT(M0_HAS_TYPE(M0_FIELD_VALUE(ambient_type, link_field),	\
-		       struct m0_be_tlink));				\
-M0_BASSERT(M0_HAS_TYPE(M0_FIELD_VALUE(ambient_type, link_magic_field),	\
-		       uint64_t))
+                       link_magic, head_magic)                          \
+{                                                                       \
+        .td_name              = name,                                   \
+        .td_link_offset       = offsetof(ambient_type, link_field),     \
+        .td_link_magic_offset = offsetof(ambient_type, link_magic_field), \
+        .td_link_magic        = link_magic,                             \
+        .td_head_magic        = head_magic                              \
+};                                                                      \
+                                                                        \
+M0_BASSERT(M0_HAS_TYPE(M0_FIELD_VALUE(ambient_type, link_field),        \
+                       struct m0_be_tlink));                            \
+M0_BASSERT(M0_HAS_TYPE(M0_FIELD_VALUE(ambient_type, link_magic_field),  \
+                       uint64_t))
 
 /**
  * tlist head tp support back-end domain
  */
 struct m0_be_tl {
-	/**
-	   Head magic. This is set to m0_tl::td_head_magic and verified by the
-	   list invariant.
-	 */
-	uint64_t          t_magic;
-	/** Underlying m0_list. */
-	struct m0_be_list t_head;
+        /**
+           Head magic. This is set to m0_tl::td_head_magic and verified by the
+           list invariant.
+         */
+        uint64_t          t_magic;
+        /** Underlying m0_be_list. */
+        struct m0_be_list t_head;
 };
 
 
@@ -253,43 +253,50 @@ struct m0_be_tl {
  * tlist link to support back-end domain
  */
 struct m0_be_tlink {
-	/** Underlying m0_list link. */
-	struct m0_be_list_link t_link;
+        /** Underlying m0_be_list link. */
+        struct m0_be_list_link t_link;
 };
 
-void m0_be_tlist_init(const struct m0_be_tl_descr *d, struct m0_be_tl *list);
+M0_INTERNAL void m0_be_tlist_init(const struct m0_be_tl_descr *d,
+                                  struct m0_be_tl *list);
 
-void m0_be_tlist_fini(const struct m0_be_tl_descr *d, struct m0_be_tl *list);
+M0_INTERNAL void m0_be_tlist_fini(const struct m0_be_tl_descr *d,
+                                  struct m0_be_tl *list);
 
-void m0_be_tlink_init(const struct m0_be_tl_descr *d, struct m0_reference ref);
+M0_INTERNAL void m0_be_tlink_init(const struct m0_be_tl_descr *d,
+                                  struct m0_reference ref);
 
-void m0_be_tlink_fini(const struct m0_be_tl_descr *d, void *obj);
+M0_INTERNAL void m0_be_tlink_fini(const struct m0_be_tl_descr *d, void *obj);
 
-void m0_be_tlink_init_at(const struct m0_be_tl_descr *d, struct m0_be_tl *list,
-		         struct m0_reference ref);
+M0_INTERNAL void m0_be_tlink_init_at(const struct m0_be_tl_descr *d,
+                                     struct m0_be_tl *list,
+                                     struct m0_reference ref);
 
-void m0_be_tlink_init_at_tail(const struct m0_be_tl_descr *d,
-                              struct m0_be_tl *list,
-			      struct m0_reference ref);
+M0_INTERNAL void m0_be_tlink_init_at_tail(const struct m0_be_tl_descr *d,
+                                          struct m0_be_tl *list,
+                                          struct m0_reference ref);
 
-void m0_be_tlink_del_fini    (const struct m0_be_tl_descr *d, void *obj);
+M0_INTERNAL void m0_be_tlink_del_fini(const struct m0_be_tl_descr *d,
+                                      void *obj);
 
-bool m0_be_tlist_invariant (const struct m0_be_tl_descr *d,
-			    const struct m0_be_tl *list);
+M0_INTERNAL bool m0_be_tlist_invariant(const struct m0_be_tl_descr *d,
+                                       const struct m0_be_tl *list);
 
-bool m0_be_tlink_invariant  (const struct m0_be_tl_descr *d, const void *obj);
+M0_INTERNAL bool m0_be_tlink_invariant(const struct m0_be_tl_descr *d,
+                                       const void *obj);
 
-bool   m0_be_tlist_is_empty (const struct m0_be_tl_descr *d,
-			     const struct m0_be_tl *list);
+M0_INTERNAL bool   m0_be_tlist_is_empty(const struct m0_be_tl_descr *d,
+                                        const struct m0_be_tl *list);
 
-bool   m0_be_tlink_is_in   (const struct m0_be_tl_descr *d, const void *obj);
+M0_INTERNAL bool   m0_be_tlink_is_in(const struct m0_be_tl_descr *d,
+                                     const void *obj);
 
-bool   m0_be_tlist_contains (const struct m0_be_tl_descr *d,
-			     const struct m0_be_tl *list,
- 			     const void *obj);
+M0_INTERNAL bool   m0_be_tlist_contains(const struct m0_be_tl_descr *d,
+                                        const struct m0_be_tl *list,
+                                        const void *obj);
 
-size_t m0_be_tlist_length  (const struct m0_be_tl_descr *d,
-			    const struct m0_be_tl *list);
+M0_INTERNAL size_t m0_be_tlist_length  (const struct m0_be_tl_descr *d,
+                                        const struct m0_be_tl *list);
 
 /**
    Adds an element to the beginning of a list.
@@ -297,8 +304,8 @@ size_t m0_be_tlist_length  (const struct m0_be_tl_descr *d,
    @pre !m0_tlink_is_in(d, obj)
    @post m0_tlink_is_in(d, obj)
  */
-void   m0_be_tlist_add  (const struct m0_be_tl_descr *d, struct m0_be_tl *list,
-	 	         void *obj);
+M0_INTERNAL void   m0_be_tlist_add(const struct m0_be_tl_descr *d,
+                                   struct m0_be_tl *list, void *obj);
 
 /**
    Adds an element to the end of a list.
@@ -306,8 +313,8 @@ void   m0_be_tlist_add  (const struct m0_be_tl_descr *d, struct m0_be_tl *list,
    @pre !m0_tlink_is_in(d, obj)
    @post m0_tlink_is_in(d, obj)
  */
-void   m0_be_tlist_add_tail (const struct m0_be_tl_descr *d,
-		  	     struct m0_be_tl *list, void *obj);
+M0_INTERNAL void   m0_be_tlist_add_tail(const struct m0_be_tl_descr *d,
+                                        struct m0_be_tl *list, void *obj);
 
 /**
    Adds an element after another element of the list.
@@ -315,8 +322,8 @@ void   m0_be_tlist_add_tail (const struct m0_be_tl_descr *d,
    @pre !m0_tlink_is_in(d, new)
    @post m0_tlink_is_in(d, new)
  */
-void   m0_be_tlist_add_after(const struct m0_be_tl_descr *d, void *obj,
-                             void *new);
+M0_INTERNAL void   m0_be_tlist_add_after(const struct m0_be_tl_descr *d,
+                                         void *obj, void *new);
 
 /**
    Adds an element before another element of the list.
@@ -324,8 +331,8 @@ void   m0_be_tlist_add_after(const struct m0_be_tl_descr *d, void *obj,
    @pre !m0_tlink_is_in(d, new)
    @post m0_tlink_is_in(d, new)
  */
-void   m0_be_tlist_add_before(const struct m0_be_tl_descr *d, void *obj,
-                              void *new);
+M0_INTERNAL void   m0_be_tlist_add_before(const struct m0_be_tl_descr *d,
+                                          void *obj, void *new);
 
 /**
    Deletes an element from the list.
@@ -333,7 +340,7 @@ void   m0_be_tlist_add_before(const struct m0_be_tl_descr *d, void *obj,
    @pre   m0_tlink_is_in(d, obj)
    @post !m0_tlink_is_in(d, obj)
  */
-void   m0_be_tlist_del (const struct m0_be_tl_descr *d, void *obj);
+M0_INTERNAL void   m0_be_tlist_del(const struct m0_be_tl_descr *d, void *obj);
 
 /**
    Moves an element from a list to the head of (possibly the same) list.
@@ -341,8 +348,8 @@ void   m0_be_tlist_del (const struct m0_be_tl_descr *d, void *obj);
    @pre  m0_tlink_is_in(d, obj)
    @post m0_tlink_is_in(d, obj)
  */
-void   m0_be_tlist_move (const struct m0_be_tl_descr *d, struct m0_be_tl *list,
-			 void *obj);
+M0_INTERNAL void   m0_be_tlist_move(const struct m0_be_tl_descr *d,
+                                    struct m0_be_tl *list, void *obj);
 
 /**
    Moves an element from a list to the tail of (possibly the same) list.
@@ -350,37 +357,37 @@ void   m0_be_tlist_move (const struct m0_be_tl_descr *d, struct m0_be_tl *list,
    @pre  m0_tlink_is_in(d, obj)
    @post m0_tlink_is_in(d, obj)
  */
-void   m0_be_tlist_move_tail (const struct m0_be_tl_descr *d,
-			      struct m0_be_tl *list, void *obj);
+M0_INTERNAL void   m0_be_tlist_move_tail(const struct m0_be_tl_descr *d,
+                                         struct m0_be_tl *list, void *obj);
 
 /**
    Returns the first element of a list or NULL if the list is empty.
  */
-void  *m0_be_tlist_head(const struct m0_be_tl_descr *d,
-			const struct m0_be_tl *list);
+M0_INTERNAL void  *m0_be_tlist_head(const struct m0_be_tl_descr *d,
+                                    const struct m0_be_tl *list);
 
 /**
    Returns the last element of a list or NULL if the list is empty.
  */
-void  *m0_be_tlist_tail(const struct m0_be_tl_descr *d,
-			const struct m0_be_tl *list);
+M0_INTERNAL void  *m0_be_tlist_tail(const struct m0_be_tl_descr *d,
+                                    const struct m0_be_tl *list);
 
 /**
    Returns the next element of a list or NULL if @obj is the last element.
 
-   @pre m0_tlist_contains(d, list, obj)
+   @pre m0_be_tlist_contains(d, list, obj)
  */
-void  *m0_be_tlist_next (const struct m0_be_tl_descr *d,
-		         const struct m0_be_tl *list, void *obj);
+M0_INTERNAL void  *m0_be_tlist_next(const struct m0_be_tl_descr *d,
+                                    const struct m0_be_tl *list, void *obj);
 
 
 /**
    Returns the previous element of a list or NULL if @obj is the first element.
 
-   @pre m0_tlist_contains(d, list, obj)
+   @pre m0_be_tlist_contains(d, list, obj)
  */
-void  *m0_be_tlist_prev (const struct m0_be_tl_descr *d,
-		         const struct m0_be_tl    *list, void *obj);
+M0_INTERNAL void  *m0_be_tlist_prev(const struct m0_be_tl_descr *d,
+                                    const struct m0_be_tl    *list, void *obj);
 
 
 /**
@@ -398,7 +405,7 @@ void  *m0_be_tlist_prev (const struct m0_be_tl_descr *d,
 
    m0_be_tlist_for(&foobar_list, &B.b_list, foo) {
            if (foo->f_value % sum == 0)
-	           m0_tlist_del(&foobar_list, foo);
+                   m0_be_tlist_del(&foobar_list, foo);
    } m0_be_tlist_endfor;
    @endcode
 
@@ -420,17 +427,17 @@ void  *m0_be_tlist_prev (const struct m0_be_tl_descr *d,
    @see m0_be_tlist_endfor
  */
 
-#define m0_be_tlist_for(descr, head, obj)				\
-do {									\
-	void *__be_tl;							\
-									\
-	for (obj = m0_be_tlist_head(descr, head);			\
-	     obj != NULL &&						\
+#define m0_be_tlist_for(descr, head, obj)                               \
+do {                                                                    \
+        void *__be_tl;                                                  \
+                                                                        \
+        for (obj = m0_be_tlist_head(descr, head);                       \
+             obj != NULL &&                                             \
              ((void)(__be_tl = m0_be_tlist_next(descr, head, obj)), true);\
-	     obj = __be_tl)
+             obj = __be_tl)
 
 /**
-   Terminates m0_tlist_for() loop.
+   Terminates m0_be_tlist_for() loop.
  */
 #define m0_be_tlist_endfor ; (void)__be_tl; } while (0)
 
@@ -457,33 +464,33 @@ do {									\
    @see M0_BE_TL_DEFINE()
    @see M0_BE_TL_DESCR_DEFINE()
  */
-#define M0_BE_TL_DECLARE(name, scope, amb_type)				\
-									\
-scope void name ## _be_tlist_init(struct m0_be_tl *head);		\
-scope void name ## _be_tlist_fini(struct m0_be_tl *head);		\
-scope void name ## _be_tlink_init(struct m0_reference ref);		\
-scope void name ## _be_tlink_init_at(struct m0_reference ref,		\
-				     struct m0_be_tl *head);\
-scope void name ## _be_tlink_init_at_tail(struct m0_reference ref, 	\
-					  struct m0_be_tl *head);\
-scope void name ## _be_tlink_fini(amb_type *amb);			\
-scope void name ## _be_tlink_del_fini(amb_type *amb);			\
-scope bool   name ## _be_tlist_is_empty(const struct m0_be_tl *list);	\
-scope bool   name ## _be_tlink_is_in   (const amb_type *amb);		\
-scope bool   name ## _be_tlist_contains(const struct m0_be_tl *list,	\
-				        const amb_type *amb);		\
-scope size_t name ## _be_tlist_length(const struct m0_be_tl *list);	\
+#define M0_BE_TL_DECLARE(name, scope, amb_type)                         \
+                                                                        \
+scope void name ## _be_tlist_init(struct m0_be_tl *head);               \
+scope void name ## _be_tlist_fini(struct m0_be_tl *head);               \
+scope void name ## _be_tlink_init(struct m0_reference ref);             \
+scope void name ## _be_tlink_init_at(struct m0_reference ref,           \
+                                     struct m0_be_tl *head);            \
+scope void name ## _be_tlink_init_at_tail(struct m0_reference ref,      \
+                                          struct m0_be_tl *head);       \
+scope void name ## _be_tlink_fini(amb_type *amb);                       \
+scope void name ## _be_tlink_del_fini(amb_type *amb);                   \
+scope bool   name ## _be_tlist_is_empty(const struct m0_be_tl *list);   \
+scope bool   name ## _be_tlink_is_in   (const amb_type *amb);           \
+scope bool   name ## _be_tlist_contains(const struct m0_be_tl *list,    \
+                                        const amb_type *amb);           \
+scope size_t name ## _be_tlist_length(const struct m0_be_tl *list);     \
 scope void   name ## _be_tlist_add(struct m0_be_tl *list, amb_type *amb); \
 scope void   name ## _be_tlist_add_tail(struct m0_be_tl *list, amb_type *amb); \
-scope void   name ## _be_tlist_add_after(amb_type *amb, amb_type *new);	\
-scope void   name ## _be_tlist_add_before(amb_type *amb, amb_type *new); \
-scope void   name ## _be_tlist_del(amb_type *amb);			  \
+scope void   name ## _be_tlist_add_after(amb_type *amb, amb_type *new); \
+scope void   name ## _be_tlist_add_before(amb_type *amb, amb_type *new);\
+scope void   name ## _be_tlist_del(amb_type *amb);                      \
 scope void   name ## _be_tlist_move(struct m0_be_tl *list, amb_type *amb); \
 scope void   name ## _be_tlist_move_tail(struct m0_be_tl *list, amb_type *amb);\
-scope amb_type *name ## _be_tlist_head(const struct m0_be_tl *list);	\
-scope amb_type *name ## _be_tlist_tail(const struct m0_be_tl *list);	\
-scope amb_type *name ## _be_tlist_next(const struct m0_be_tl *list, 	\
-				       amb_type *amb);	\
+scope amb_type *name ## _be_tlist_head(const struct m0_be_tl *list);    \
+scope amb_type *name ## _be_tlist_tail(const struct m0_be_tl *list);    \
+scope amb_type *name ## _be_tlist_next(const struct m0_be_tl *list,     \
+                                       amb_type *amb);                  \
 scope amb_type *name ## _be_tlist_prev(const struct m0_be_tl *list, \
                                        amb_type *amb)
 
@@ -494,13 +501,13 @@ scope amb_type *name ## _be_tlist_prev(const struct m0_be_tl *list, \
    Defines a tlist descriptor (m0_be_tl_descr) for a particular ambient type.
  */
 #define M0_BE_TL_DESCR_DEFINE(name, hname, scope, amb_type, amb_link_field, \
-		     amb_magic_field, amb_magic, head_magic)		\
-scope const struct m0_be_tl_descr name ## _tl = m0_BE_TL_DESCR(hname,	\
-							 amb_type,	\
-							 amb_link_field, \
-							 amb_magic_field, \
-							 amb_magic,	  \
-							 head_magic)
+                              amb_magic_field, amb_magic, head_magic)   \
+scope const struct m0_be_tl_descr name ## _tl = M0_BE_TL_DESCR(hname,   \
+                                                               amb_type,\
+                                                               amb_link_field,\
+                                                               amb_magic_field,\
+                                                               amb_magic,\
+                                                               head_magic)
 
 
 /**
@@ -509,130 +516,129 @@ scope const struct m0_be_tl_descr name ## _tl = m0_BE_TL_DESCR(hname,	\
    The definitions generated assume that tlist descriptor, defined by
    M0_BE_TL_DESC_DEFINE() is in scope.
  */
-#define M0_BE_TL_DEFINE(name, scope, amb_type)				\
-									\
-scope __AUN void name ## _tlist_init(struct m0_be_tl *head)		\
-{									\
-	m0_be_tlist_init(&name ## _tl, head);			        \
-}									\
-									\
-scope __AUN void name ## _tlist_fini(struct m0_be_tl *head)		\
-{									\
-	m0_be_tlist_fini(&name ## _tl, head);			        \
-}									\
-									\
-scope __AUN void name ## _tlink_init(struct m0_reference ref)		\
-{									\
-	m0_be_tlink_init(&name ## _tl, ref);				\
-}									\
-									\
-scope __AUN void name ## _tlink_init_at(struct m0_reference  ref,	\
-					   struct m0_be_tl *head)       \
-{									\
-	m0_be_tlink_init_at(&name ## _tl,  head, ref);		        \
-}									\
-									\
+#define M0_BE_TL_DEFINE(name, scope, amb_type)                          \
+                                                                        \
+scope __AUN void name ## _tlist_init(struct m0_be_tl *head)             \
+{                                                                       \
+        m0_be_tlist_init(&name ## _tl, head);                           \
+}                                                                       \
+                                                                        \
+scope __AUN void name ## _tlist_fini(struct m0_be_tl *head)             \
+{                                                                       \
+        m0_be_tlist_fini(&name ## _tl, head);                           \
+}                                                                       \
+                                                                        \
+scope __AUN void name ## _tlink_init(struct m0_reference ref)           \
+{                                                                       \
+        m0_be_tlink_init(&name ## _tl, ref);                            \
+}                                                                       \
+                                                                        \
+scope __AUN void name ## _tlink_init_at(struct m0_reference  ref,       \
+                                        struct m0_be_tl *head)          \
+{                                                                       \
+        m0_be_tlink_init_at(&name ## _tl,  head, ref);                  \
+}                                                                       \
+                                                                        \
 scope __AUN void name ## _tlink_init_at_tail(struct m0_reference ref,   \
-						struct m0_be_tl *head)  \
-{									\
-	m0_be_tlink_init_at_tail(&name ## _tl, head, ref);		\
-}									\
-									\
-scope __AUN void name ## _tlink_fini(amb_type *amb)			\
-{									\
-	m0_be_tlink_fini(&name ## _tl, amb);				\
-}									\
-									\
-scope __AUN void name ## _tlink_del_fini(amb_type *amb)		        \
-{									\
-	m0_be_tlink_del_fini(&name ## _tl, amb);			\
-}									\
-									\
+                                             struct m0_be_tl *head)     \
+{                                                                       \
+        m0_be_tlink_init_at_tail(&name ## _tl, head, ref);              \
+}                                                                       \
+                                                                        \
+scope __AUN void name ## _tlink_fini(amb_type *amb)                     \
+{                                                                       \
+        m0_be_tlink_fini(&name ## _tl, amb);                            \
+}                                                                       \
+                                                                        \
+scope __AUN void name ## _tlink_del_fini(amb_type *amb)                 \
+{                                                                       \
+        m0_be_tlink_del_fini(&name ## _tl, amb);                        \
+}                                                                       \
+                                                                        \
 scope __AUN bool   name ## _tlist_is_empty(const struct m0_be_tl *list) \
-{									\
-	return m0_be_tlist_is_empty(&name ## _tl, list);		\
-}									\
-									\
-scope __AUN bool   name ## _tlink_is_in   (const amb_type *amb)	        \
-{									\
-	return m0_be_tlink_is_in(&name ## _tl, amb);			\
-}									\
-									\
+{                                                                       \
+        return m0_be_tlist_is_empty(&name ## _tl, list);                \
+}                                                                       \
+                                                                        \
+scope __AUN bool   name ## _tlink_is_in   (const amb_type *amb)         \
+{                                                                       \
+        return m0_be_tlink_is_in(&name ## _tl, amb);                    \
+}                                                                       \
+                                                                        \
 scope __AUN bool   name ## _tlist_contains(const struct m0_be_tl *list, \
-				     const amb_type *amb)		\
-{									\
-	return m0_be_tlist_contains(&name ## _tl, list, amb);	        \
-}									\
-									\
+                                           const amb_type *amb)         \
+{                                                                       \
+        return m0_be_tlist_contains(&name ## _tl, list, amb);           \
+}                                                                       \
+                                                                        \
 scope __AUN size_t name ## _tlist_length(const struct m0_be_tl *list)   \
-{									\
-	return m0_be_tlist_length(&name ## _tl, list);		        \
-}									\
-									\
+{                                                                       \
+        return m0_be_tlist_length(&name ## _tl, list);                  \
+}                                                                       \
+                                                                        \
 scope __AUN void   name ## _tlist_add(struct m0_be_tl *list, amb_type *amb) \
-{									\
-	m0_be_tlist_add(&name ## _tl, list, amb);			\
-}									\
-									\
-scope __AUN void   name ## _tlist_add_tail(struct m0_be_tl *list, 	\
-					      amb_type *amb)            \
-{									\
-	m0_be_tlist_add_tail(&name ## _tl, list, amb);		        \
-}									\
-									\
+{                                                                       \
+        m0_be_tlist_add(&name ## _tl, list, amb);                       \
+}                                                                       \
+                                                                        \
+scope __AUN void   name ## _tlist_add_tail(struct m0_be_tl *list,       \
+                                           amb_type *amb)               \
+{                                                                       \
+        m0_be_tlist_add_tail(&name ## _tl, list, amb);                  \
+}                                                                       \
+                                                                        \
 scope __AUN void   name ## _tlist_add_after(amb_type *amb, amb_type *new) \
-{									\
-	m0_be_tlist_add_after(&name ## _tl, amb, new);		        \
-}									\
-									\
+{                                                                       \
+        m0_be_tlist_add_after(&name ## _tl, amb, new);                  \
+}                                                                       \
+                                                                        \
 scope __AUN void   name ## _tlist_add_before(amb_type *amb, amb_type *new) \
-{									\
-	m0_be_tlist_add_before(&name ## _tl, amb, new);		        \
-}									\
-									\
-scope __AUN void   name ## _tlist_del(amb_type *amb)			\
-{									\
-	m0_be_tlist_del(&name ## _tl, amb);				\
-}									\
-									\
+{                                                                       \
+        m0_be_tlist_add_before(&name ## _tl, amb, new);                 \
+}                                                                       \
+                                                                        \
+scope __AUN void   name ## _tlist_del(amb_type *amb)                    \
+{                                                                       \
+        m0_be_tlist_del(&name ## _tl, amb);                             \
+}                                                                       \
+                                                                        \
 scope __AUN void   name ## _tlist_move(struct m0_be_tl *list, amb_type *amb)\
-{									\
-	m0_be_tlist_move(&name ## _tl, list, amb);			\
-}									\
-									\
-scope __AUN void   name ## _tlist_move_tail(struct m0_be_tl *list, 	\
-					       amb_type *amb)           \
-{									\
-	m0_be_tlist_move_tail(&name ## _tl, list, amb);		        \
-}									\
-									\
+{                                                                       \
+        m0_be_tlist_move(&name ## _tl, list, amb);                      \
+}                                                                       \
+                                                                        \
+scope __AUN void   name ## _tlist_move_tail(struct m0_be_tl *list,      \
+                                            amb_type *amb)              \
+{                                                                       \
+        m0_be_tlist_move_tail(&name ## _tl, list, amb);                 \
+}                                                                       \
+                                                                        \
 scope __AUN amb_type *name ## _tlist_head(const struct m0_be_tl *list)  \
-{									\
-	return m0_be_tlist_head(&name ## _tl, list);			\
-}									\
-									\
+{                                                                       \
+        return m0_be_tlist_head(&name ## _tl, list);                    \
+}                                                                       \
+                                                                        \
 scope __AUN amb_type *name ## _tlist_tail(const struct m0_be_tl *list)  \
-{									\
-	return m0_be_tlist_tail(&name ## _tl, list);			\
-}									\
-									\
+{                                                                       \
+        return m0_be_tlist_tail(&name ## _tl, list);                    \
+}                                                                       \
+                                                                        \
 scope __AUN amb_type *name ## _tlist_next(const struct m0_be_tl *list,  \
-				     amb_type *amb)			\
-{									\
-	return m0_be_tlist_next(&name ## _tl, list, amb);		\
-}									\
-									\
+                                          amb_type *amb)                \
+{                                                                       \
+        return m0_be_tlist_next(&name ## _tl, list, amb);               \
+}                                                                       \
+                                                                        \
 scope __AUN amb_type *name ## _tlist_prev(const struct m0_be_tl *list,  \
-				     amb_type *amb)                     \
-{									\
-	return m0_be_tlist_prev(&name ## _tl, list, amb);		\
-}									\
-									\
+                                          amb_type *amb)                \
+{                                                                       \
+        return m0_be_tlist_prev(&name ## _tl, list, amb);               \
+}                                                                       \
+                                                                        \
 struct __ ## name ## _terminate_me_with_a_semicolon { ; }
 /** @} end of be_tlist group */
 
-/* __MERO_BE_LIB_BE_TLIST_H__ */
-#endif
+#endif /* __MERO_BE_LIB_BE_TLIST_H__ */
 
 /*
  *  Local variables:
diff --git a/be/lib/be_types.h b/be/lib/be_types.h
index f97ff9f..30ae145 100644
--- a/be/lib/be_types.h
+++ b/be/lib/be_types.h
@@ -18,10 +18,6 @@
  * Original creation date       : 12/04/2012
  */
 #pragma once
-
-
-
-
 #ifndef __MERO_BE_LIB_BE_TYPES_H__
 #define __MERO_BE_LIB_BE_TYPES_H__
 
@@ -46,10 +42,7 @@ struct m0_reference {
         uint64_t magic_offset;
 };
 
-
-
-/* __MERO_BE_LIB_BE_TYPES_H_ */
-#endif
+#endif /* __MERO_BE_LIB_BE_TYPES_H_ */
 
 /*
  *  Local variables:
diff --git a/be/lib/ut/be_kv_store.c b/be/lib/ut/be_kv_store.c
index 87e30a2..1030046 100644
--- a/be/lib/ut/be_kv_store.c
+++ b/be/lib/ut/be_kv_store.c
@@ -1,6 +1,6 @@
 /* -*- C -*- */
 /*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
+ * COPYRIGHT 2012 XYRATEX TECHNOLOGY LIMITED
  *
  * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
  * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
@@ -14,109 +14,237 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: 	   Zishan Shaikh <zishan_shaikh@xyratex.com>
- * Original creation date: 12/18/2012
+ * Original author: Zishan Shaikh <zishan_shaikh@xyratex.com>
+ * Original creation date: 12/24/2012
  */
 
 #include "be/lib/be_kv_store.h"
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
+#define MAX_KEY_SIZE 256
 
-#define link_magic 0xab5ce55edba1b0a0
-#define head_magic 0xba1dba11adba0bab
+/* User defined structure */
+struct m0_kv_store_obj {
+        char                    key[MAX_KEY_SIZE];
+        int                     val;
+        struct m0_be_tlink      linkage;
+        uint64_t                magic;
+};
 
-struct m0_be_domain     dom;
-struct m0_be_seg        seg;
-struct m0_stob          ns_stob;
-struct m0_stob          stob;
-struct m0_stob          log_stob;
+struct m0_be_tl_descr list_descr = M0_BE_TL_DESCR("kv_store_obj",
+                                                  struct m0_kv_store_obj,
+                                                  linkage,
+                                                  magic,
+                                                  0xab5ce55edba1b0a0,
+                                                  0xba1dba11adba0bab);
+
+struct m0_be_domain     *dom;
+struct m0_be_seg        *seg;
+struct m0_kv_store      handle;
+
+int function_comp(void *key1, void *key2)
+{
+        struct m0_kv_store_obj *obj1;
+        struct m0_kv_store_obj *obj2;
+
+        obj1 = (struct m0_kv_store_obj *)key1;
+        obj2 = (struct m0_kv_store_obj *)key2;
+        return strcmp(obj1->key, obj2->key);
+}
+
+int function_match(void *key1, void *key2)
+{
+        return 0;
+}
+
+static void init()
+{
+        kv_key_cmp     cmp_routine;
+        kv_key_match   match_routine;
+
+        cmp_routine   = &function_comp;
+        match_routine = &function_match;
+
+        m0_ks_init(&handle,  &list_descr, &dom, cmp_routine, match_routine);
+}
+
+static void fini()
+{
+        m0_be_seg_done(seg);
+        dom->bd_data.bs_sm.sm_state = M0_BESEG_CLOSED;
+        m0_be_domain_fini(dom);
+}
+
+static int insert(struct m0_kv_store_obj **obj, char *key_name)
+{
+        int                      status = -2;
+        struct m0_be_reg        *obj_reg = NULL;
+        struct m0_be_buf         obj_buf;
+        struct m0_be_tx          tx;
+
+        m0_be_tx_init(&tx, dom, 0);
+        m0_sm_group_lock(tx.bt_impl.sm_group);
+        m0_sm_timedwait(&tx.bt_sm,
+                        (1 << M0_BETX_PREPARING) | (1 << M0_BETX_FAILED),
+                        M0_TIME_NEVER);
+        m0_sm_group_unlock(tx.bt_impl.sm_group);
+
+
+        obj_buf.b_nob = sizeof(struct m0_kv_store_obj);
+        m0_be_reg_init(&obj_reg, NULL, seg, &obj_buf);
+        m0_be_alloc(obj_reg);
+        m0_be_tx_add_cred(&tx, obj_reg);
+
+        *obj = (struct m0_kv_store_obj *)obj_reg->br_buf.b_addr;
+        M0_ASSERT (obj != NULL);
+
+        strcpy((*obj)->key, key_name);
+
+        status = m0_ks_insert(&handle, *obj, &tx);
+
+        m0_be_tx_done(&tx);
+        m0_sm_group_lock(tx.bt_impl.sm_group);
+        m0_sm_timedwait(&tx.bt_sm,
+                        (1 << M0_BETX_DONE) | (1 << M0_BETX_FAILED),
+                        M0_TIME_NEVER);
+        m0_sm_group_unlock(tx.bt_impl.sm_group);
+
+        m0_be_tx_fini(&tx);
+
+        return status;
+}
+
+static struct m0_reference *find(struct m0_kv_store_obj *obj)
+{
+        return m0_ks_find(&handle, obj);
+}
+
+static int delete(struct m0_kv_store_obj *target)
+{
+        struct m0_be_tx       tx;
+        struct m0_be_buf      obj_buf;
+        struct m0_be_reg     *obj_reg = NULL;
+        int                   ret_val;
+
+        m0_be_tx_init(&tx, dom, 0);
+        m0_sm_group_lock(tx.bt_impl.sm_group);
+        m0_sm_timedwait(&tx.bt_sm,
+                        (1 << M0_BETX_PREPARING) | (1 << M0_BETX_FAILED),
+                        M0_TIME_NEVER);
+        m0_sm_group_unlock(tx.bt_impl.sm_group);
+
+        /* Add current obj to credit */
+        obj_buf.b_nob = sizeof(struct m0_kv_store_obj);
+        obj_buf.b_addr = (void *)target;
+        m0_be_reg_init(&obj_reg, &tx, seg, &obj_buf);
+
+        m0_be_tx_add_cred(&tx, obj_reg);
+
+        ret_val = m0_ks_delete(&handle, target, &tx);
+
+        if (ret_val != BE_KV_FAILURE) {
+                        m0_be_free(obj_reg);
+
+                m0_be_tx_done(&tx);
+                m0_sm_group_lock(tx.bt_impl.sm_group);
+                m0_sm_timedwait(&tx.bt_sm,
+                                (1 << M0_BETX_DONE) | (1 << M0_BETX_FAILED),
+                                M0_TIME_NEVER);
+                m0_sm_group_unlock(tx.bt_impl.sm_group);
+                ret_val = BE_KV_SUCCESS;
+        }
+
+        m0_be_tx_fini(&tx);
+        return ret_val;
+}
 
 int main() {
-	struct m0_kv_store       handle;
-	struct m0_kv_key         key1;
-        struct m0_kv_key         key2;
-        struct m0_kv_key         key3;
-        struct m0_be_reg         *obj1_reg;
-        struct m0_be_reg         *obj2_reg;
-        struct m0_be_reg         *obj3_reg;
-        struct m0_be_buf        obj1_buf;
-        struct m0_be_buf        obj2_buf;
-        struct m0_be_buf        obj3_buf;
-        struct m0_be_buf        *ret1_buf = NULL;
-        struct m0_be_buf        *ret2_buf = NULL;
-        struct m0_be_buf        *ret3_buf = NULL;
-        struct m0_be_tx         *tx1      = NULL;
-        struct m0_be_tx         *tx2      = NULL;
-        struct m0_be_tx         *tx3      = NULL;
-
-	int                     status = -2;
-        char                    list_name[]="list";
-	char                    obj1_name[] = "abc";
-        char                    obj2_name[] = "def";
-        char                    obj3_name[] = "ghi";
-
-        m0_ks_init_domain_and_segment(&dom, &seg, &ns_stob, &stob, &log_stob);
-        m0_ks_init(&handle,  list_name, 0xab5ce55edba1b0a0, 0xba1dba11adba0bab);
-        m0_ks_update_handle(&handle, &dom, &seg, &ns_stob, &stob, &log_stob);
-
-        /* insert "name" */
-        obj1_reg->br_sm.sm_state = M0_BEREG_INIT;
-        m0_be_buf_init(&obj1_buf, NULL, sizeof(struct m0_kv_store_obj), 0, 0, 0);
-        m0_be_reg_init(&obj1_reg, NULL, handle.ks_seg, &obj1_buf);
-
-        tx1 = (struct m0_be_tx *)malloc(sizeof(struct m0_be_tx));
-
-	strcpy(key1.kv_key, obj1_name);
-	status = m0_ks_insert(&handle, &key1, tx1);
-	if (status == BE_KV_SUCCESS)
-		printf("inserted obj1_name\n");
-
-        m0_be_ks_obj_fini(tx1);
-
-        /* insert midname */
-        obj2_reg->br_sm.sm_state = M0_BEREG_INIT;
-        m0_be_buf_init(&obj2_buf, NULL, sizeof(struct m0_kv_store_obj), 0, 0, 0);
-        m0_be_reg_init(&obj2_reg, NULL, handle.ks_seg, &obj2_buf);
-
-        tx2 = (struct m0_be_tx *)malloc(sizeof(struct m0_be_tx));
-
-	strcpy(key2.kv_key, obj2_name);
-	status = m0_ks_insert(&handle, &key2, tx2);
-	if (status == BE_KV_SUCCESS)
-		printf("inserted obj2_name\n");
-
-        m0_be_ks_obj_fini(tx2);
-
-        /* insert surname */
-        obj3_reg->br_sm.sm_state = M0_BEREG_INIT;
-        m0_be_buf_init(&obj3_buf, NULL, sizeof(struct m0_kv_store_obj), 0, 0, 0);
-        m0_be_reg_init(&obj3_reg, NULL, handle.ks_seg, &obj3_buf);
-
-        tx3 = (struct m0_be_tx *)malloc(sizeof(struct m0_be_tx));
-
-	strcpy(key3.kv_key, obj3_name);
-	status = m0_ks_insert(&handle, &key3, tx3);
-	if (status == BE_KV_SUCCESS)
-		printf("inserted obj3_name\n");
-
-        m0_be_ks_obj_fini(tx3);
-
-        ret1_buf = m0_ks_find(&handle, &key1);
-        ret2_buf = m0_ks_find(&handle, &key2);
-        ret3_buf = m0_ks_find(&handle, &key3);
-
-        if (ret1_buf != NULL)
-                printf("Found obj1\n");
-
-        if (ret2_buf != NULL)
-                printf("Found obj2\n");
-
-        if (ret3_buf != NULL)
-                printf("Found obj3\n");
+        struct m0_reference     *ret_ref = NULL;
+        struct m0_kv_store_obj  *obj1 = NULL;
+        struct m0_kv_store_obj  *obj2 = NULL;
+        struct m0_kv_store_obj  *obj3 = NULL;
+
+        int                      status = -2;
+        char                    obj1_name[] = "abc";
+        char                    obj2_name[] = "ghi";
+        char                    obj3_name[] = "def";
+
+        init();
 
+        m0_be_domain_lookup(dom, 1, &seg);
+        m0_sm_group_lock(seg->bs_impl.sm_group);
+        m0_sm_timedwait(&(seg->bs_sm),
+                        (1 << M0_BESEG_ACTIVE) | (1 << M0_BESEG_FAILED),
+                        M0_TIME_NEVER);
+        m0_sm_group_unlock(seg->bs_impl.sm_group);
+
+        M0_ASSERT(seg != NULL);
+
+        /* insert obj1 */
+        status = insert(&obj1, obj1_name);
+        M0_ASSERT(status == BE_KV_SUCCESS);
+        printf("Inserted obj1...\n");
+        /* insert obj2 */
+        status = insert(&obj2, obj2_name);
+        M0_ASSERT(status == BE_KV_SUCCESS);
+        printf("Inserted obj2...\n");
+
+        /* insert obj3 */
+        status = insert(&obj3, obj3_name);
+        M0_ASSERT(status == BE_KV_SUCCESS);
+        printf("Inserted obj3...\n");
+
+
+        printf("Finding obj1...\n");
+        ret_ref  = find(obj1);
+        M0_ASSERT(ret_ref != NULL);
+        printf("Found\n");
+
+        ret_ref = NULL;
+        printf("Finding obj2\n");
+        ret_ref  = find(obj2);
+        M0_ASSERT(ret_ref != NULL);
+        printf("Found\n");
+
+        ret_ref = NULL;
+        printf("Finding obj3\n");
+        ret_ref  = find(obj2);
+        M0_ASSERT(ret_ref != NULL);
+        printf("Found\n");
+
+        printf("Deleting obj3\n");
+        status = delete(obj3);
+        M0_ASSERT(status == BE_KV_SUCCESS);
+        printf("Deleted\n");
+
+        printf("Deleting obj2\n");
+        status = delete(obj2);
+        M0_ASSERT(status == BE_KV_SUCCESS);
+        printf("Deleted\n");
+
+        printf("Deleting obj1\n");
+        status = delete(obj1);
+        M0_ASSERT(status == BE_KV_SUCCESS);
+        printf("Deleted\n");
+
+        fini();
         return 0;
 }
+
+/*const struct m0_test_suite be_kvs_ut = {
+        .ts_name = "be-kv-ut",
+        .ts_init = init,
+        .ts_fini = fini,
+        .ts_tests = {
+                { "insert", insert },
+                { "find",   find },
+                { "delete", delete },
+        { NULL, NULL }
+        }
+};
+M0_EXPORTED(be_kvs_ut);
+*/
 /*
  * Local variables:
  * c-indentation-style: "K&R"
diff --git a/be/lib/ut/be_tlist.c b/be/lib/ut/be_tlist.c
index 2fb8ca5..d3cf329 100644
--- a/be/lib/ut/be_tlist.c
+++ b/be/lib/ut/be_tlist.c
@@ -32,21 +32,21 @@
 #include "be/lib/be_tlist.h"
 
 typedef struct foo {
-	int                key;
-	int                value;
-	struct m0_be_tlink linkage;
-	unsigned long int  ref_magic;
+        int                key;
+        int                value;
+        struct m0_be_tlink linkage;
+        unsigned long int  ref_magic;
 }foo;
 
 struct m0_be_tl_descr list_descr = M0_BE_TL_DESCR("foo",
-					  	  struct foo,
-						  linkage,
-						  ref_magic,
-						  0xab5ce55edba1b0a0,
-						  0xba1dba11adba0bab);
+                                                  struct foo,
+                                                  linkage,
+                                                  ref_magic,
+                                                  0xab5ce55edba1b0a0,
+                                                  0xba1dba11adba0bab);
 
 struct m0_be_tl         tlist;
-struct m0_be_seg        seg;
+struct m0_be_seg        *seg;
 struct m0_be_domain     dom;
 struct m0_stob          ns_stob;
 struct m0_stob          stob;
@@ -57,7 +57,6 @@ struct m0_stob          log_stob;
 void print_list()
 {
        struct foo *scan;
-
        m0_be_tlist_for(&list_descr, &tlist, scan) {
                printf("key = %d value = %d\n", scan->key, scan->value);
        }m0_be_tlist_endfor;
@@ -74,33 +73,20 @@ void add_to_tlist(struct foo *obj, struct m0_reference ref)
 /** Initialise the tlist, domain and the segment */
 void init_tlist_domain_and_segment()
 {
-        /* initialise tlist as well */
-        m0_be_tlist_init(&list_descr, &tlist);
-
         /* Initializing domain and segment */
         m0_be_domain_init(&dom, &ns_stob, &log_stob);
-        m0_be_seg_init(&seg, &dom, &(dom.bd_impl.sm_group), 0);
         dom.bd_data.bs_sm.sm_state = M0_BESEG_ACTIVE;
 
-        m0_be_seg_create(&seg, NULL, &stob);
-        m0_sm_group_lock(seg.bs_impl.sm_group);
-        m0_sm_timedwait(&seg.bs_sm,
-                        (1 << M0_BESEG_ACTIVE)|(1 << M0_BESEG_FAILED),
-                        M0_TIME_NEVER);
-        m0_sm_group_unlock(seg.bs_impl.sm_group);
+        /*Create and Open Segment */
+        m0_be_domain_lookup(&dom, 1, &seg);
 
-        /* If segment creation failed, then return */
-        if (seg.bs_sm.sm_state == M0_BESEG_FAILED ) {
-                printf("\nFailed to create segment \n");
-                return;
-        }
-
-        m0_be_seg_open(&seg);
-        m0_sm_group_lock(seg.bs_impl.sm_group);
-        m0_sm_timedwait(&seg.bs_sm,
+        m0_sm_group_lock(seg->bs_impl.sm_group);
+        m0_sm_timedwait(&(seg->bs_sm),
                         (1 << M0_BESEG_ACTIVE) | (1 << M0_BESEG_FAILED),
                         M0_TIME_NEVER);
-        m0_sm_group_unlock(seg.bs_impl.sm_group);
+        m0_sm_group_unlock(seg->bs_impl.sm_group);
+
+        m0_be_tlist_init(&list_descr, &tlist);
 }
 
 /** Allocates memory to an object and adds it to the tlist */
@@ -112,15 +98,32 @@ void test_add_be_tlist(struct foo **new_obj, int incoming_key,
         struct m0_be_reg        *reg;
         struct m0_be_buf        buf;
 
-        reg->br_sm.sm_state = M0_BEREG_INIT;
-
         /** Initialise and start transaction */
         m0_be_tx_init(&tx, &dom, 0);
+        m0_sm_group_lock(tx.bt_impl.sm_group);
+        m0_sm_timedwait(&tx.bt_sm,
+                        (1 << M0_BETX_PREPARING) | (1 << M0_BETX_FAILED),
+                        M0_TIME_NEVER);
+        m0_sm_group_unlock(tx.bt_impl.sm_group);
+
         m0_be_buf_init(&buf, NULL, sizeof(struct foo), 0, 0, 0);
-        m0_be_reg_init(&reg, &tx, &seg, &buf);
+        m0_be_reg_init(&reg, &tx, seg, &buf);
+        m0_be_alloc(reg);
+        m0_be_tx_add_cred(&tx, reg);
 
         m0_be_tx_prep(&tx);
+        m0_sm_group_lock(tx.bt_impl.sm_group);
+        m0_sm_timedwait(&(tx.bt_sm),
+                        (1 << M0_BETX_PREPARED) | (1 << M0_BETX_FAILED),
+                         M0_TIME_NEVER);
+        m0_sm_group_unlock(tx.bt_impl.sm_group);
+
         m0_be_tx_start(&tx);
+        m0_sm_group_lock(tx.bt_impl.sm_group);
+        m0_sm_timedwait(&tx.bt_sm,
+                        (1 << M0_BETX_OPEN) | (1 << M0_BETX_FAILED),
+                        M0_TIME_NEVER);
+        m0_sm_group_unlock(tx.bt_impl.sm_group);
 
         /** Allocate the memory to the object from @reg->br_buf */
         *new_obj = (struct foo *)reg->br_buf.b_addr;
@@ -137,8 +140,13 @@ void test_add_be_tlist(struct foo **new_obj, int incoming_key,
         add_to_tlist(*new_obj, reg->br_buf.logical_address);
 
         m0_be_tx_done(&tx);
+        m0_sm_group_lock(tx.bt_impl.sm_group);
+        m0_sm_timedwait(&tx.bt_sm,
+                        (1 << M0_BETX_DONE) | (1 << M0_BETX_FAILED),
+                        M0_TIME_NEVER);
+        m0_sm_group_unlock(tx.bt_impl.sm_group);
+
         m0_be_tx_fini(&tx);
-        rvm_truncate();
 }
 
 int main()
@@ -150,6 +158,7 @@ int main()
 
         /* Initialisse the tlsit, domain and the segment */
         init_tlist_domain_and_segment();
+        printf("\n after init\n");
 
         /* Add @test1, @test2, @test3 & @test4 to tlist, added to head */
         printf("\n");
@@ -179,6 +188,11 @@ int main()
         m0_be_tlist_move_tail(&list_descr, &tlist, test4);
         printf("\nMoved 40:10 to tail. Now list:- \n");
         print_list();
+
+        m0_be_seg_done(seg);
+        dom.bd_data.bs_sm.sm_state = M0_BESEG_CLOSED;
+        m0_be_domain_fini(&dom);
+
         return 0;
 }
 
-- 
1.8.3.2

