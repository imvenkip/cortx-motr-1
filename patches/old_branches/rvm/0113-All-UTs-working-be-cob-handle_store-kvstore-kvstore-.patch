From 7219337030905195ff470a7d6e25168e7b119e76 Mon Sep 17 00:00:00 2001
From: Zishan Shaikh <zishan_shaikh@xyratex.com>
Date: Mon, 3 Jun 2013 23:45:26 -0700
Subject: [PATCH 113/121] All UTs working (be, cob, handle_store, kvstore,
 kvstore-UB). Removed debug printf's from related files.

---
 be/be_rvm.c          |   2 -
 be/domain.c          |   1 -
 be/seg.c             |   1 -
 be/ut/be.c           |  12 ------
 be/ut/handle_store.c | 115 ++++++++++++++++++++++++++++++++++-----------------
 be/ut/kv_store.c     |   6 ---
 cob/cob.c            |   1 -
 rvm/rds_zap.c        |   3 --
 rvm/rvm_createseg.c  |   3 --
 rvm/rvm_init.c       |   6 ---
 rvm/rvm_io.c         |   9 ----
 rvm/rvm_logflush.c   |  31 +-------------
 rvm/rvm_logrecovr.c  |  63 ----------------------------
 rvm/rvm_logstatus.c  |  25 -----------
 rvm/rvm_map.c        |  11 -----
 rvm/rvm_status.c     |   2 -
 rvm/rvm_trans.c      |   2 -
 rvm/rvm_unmap.c      |   1 -
 18 files changed, 77 insertions(+), 217 deletions(-)

diff --git a/be/be_rvm.c b/be/be_rvm.c
index 06c2d33..e7ff9ba 100644
--- a/be/be_rvm.c
+++ b/be/be_rvm.c
@@ -78,7 +78,6 @@ int m0_be_rvm_init(struct m0_be_domain *dom,
         rvm_cbinfo->bc_hq       = cbinfo->bc_hq;
         rvm_cbinfo->bc_cb       = rvm_initialize_cb;
 
-        printf("\nfunction : %s\n", __FUNCTION__);
         retval = rvm_initialize(RVM_VERSION, options, rvm_cbinfo);
 
         if(retval != RVM_SUCCESS)
@@ -102,7 +101,6 @@ void rvm_initialize_cb(struct m0_be_cbinfo     *cbinfo,
         rvm_cbd   = container_of(cbinfo, rvm_cbdata_t, rvm_cbinfo);
         options   = rvm_cbd->rvm_options;
 
-        printf("\nfunction : %s\n", __FUNCTION__);
         rvm_free_options(options);
 
         if (cbinfo->bc_pcbinfo != NULL && cbinfo->bc_pcbinfo->bc_cb != NULL) {
diff --git a/be/domain.c b/be/domain.c
index f41c57c..c9f0b4d 100644
--- a/be/domain.c
+++ b/be/domain.c
@@ -110,7 +110,6 @@ M0_INTERNAL void m0_be_domain_init(struct m0_be_domain *dom,
         m0_be_seg_tlist_init(&dom->bd_seg);
         m0_be_tx_tlist_init(&dom->bd_tx);
 
-        printf("\nfunction : %s\n", __FUNCTION__);
 
 	/* Do no init RVM if already initialised. */
 	if (bad_init())
diff --git a/be/seg.c b/be/seg.c
index 125b944..8e6a4f6 100644
--- a/be/seg.c
+++ b/be/seg.c
@@ -382,7 +382,6 @@ M0_INTERNAL void m0_be_seg_create_cb(struct m0_be_cbinfo *cbinfo, int status,
         rds_static_len = RVM_ROUND_LENGTH_DOWN_TO_PAGE_SIZE(4096);
         cbinfo->bc_cb  = m0_bs_create_rds_zap_cb;
 
-	printf("\nfunction : %s\n", __FUNCTION__);
         rds_zap_heap(seg->bs_impl.path_name,
 		     RVM_LENGTH_TO_OFFSET(dev_length),
 		     start_addr,
diff --git a/be/ut/be.c b/be/ut/be.c
index 0ba6c33..9104a9f 100644
--- a/be/ut/be.c
+++ b/be/ut/be.c
@@ -50,7 +50,6 @@
 #include "stob/linux_internal.h"
 
 #define RVM_CREATE      1
-#define BE_DEBUG        1
 
 static struct m0_be_seg         *seg;
 static struct m0_be_domain      *dom;
@@ -139,8 +138,6 @@ static int log_stob_create(void)
         if (nbytes < 0)
                 return -1;
 
-	if (BE_DEBUG)
-		printf("log stob : %s\n", path_name);
 
         return 0;
 }
@@ -157,8 +154,6 @@ static void be_usr_ast_post_helper(struct m0_be_usr_astinfo *be_usr_ast)
 
 void be_ts_ast_post_cb(struct m0_sm_group *sm_group, struct m0_sm_ast *ast)
 {
-	if (BE_DEBUG)
-		printf("\nbe_tx_ast_post_cb id = %x\n", (unsigned int)pthread_self());
 }
 
 void be_ts_cb(struct m0_be_cbinfo *cbinfo, int status, m0_be_msg_type_t msg_type)
@@ -170,17 +165,12 @@ void be_ts_cb(struct m0_be_cbinfo *cbinfo, int status, m0_be_msg_type_t msg_type
 
         cbdata->counter++;
         cbdata->completed = true;
-        if(BE_DEBUG)
-                printf("\n%s - counter : %d completed : %d\n", __FUNCTION__,
-                       cbdata->counter, (cbdata->completed) ? 1 : 0);
 
         if ((void*)&cbdata->be_usr_ast != NULL) {
                 cbdata->be_usr_ast.bua_status    = status;
                 cbdata->be_usr_ast.bua_msg       = msg_type;
                 cbdata->be_usr_ast.bua_ast.sa_cb = be_ts_ast_post_cb;
 
-		if (BE_DEBUG)
-			printf("\nbe_ts_cb id = %x\n", (unsigned int)pthread_self());
                 be_usr_ast_post_helper(&cbdata->be_usr_ast);
         }
 }
@@ -232,7 +222,6 @@ static int ts_be_init(void)   /* ts_ for "test suite" */
         bt_dom_cbdata->completed                =  false;
         bt_dom_cbdata->be_usr_ast.bua_sm_group  = &usr_sm_group;
 
-        printf("\nfunction : %s\n", __FUNCTION__);
         m0_be_domain_init(dom, &bt_dom_cbdata->cbinfo);
         m0_chan_wait(&usr_sm_group.s_clink);
         m0_sm_group_lock(&usr_sm_group);
@@ -256,7 +245,6 @@ static int ts_be_init(void)   /* ts_ for "test suite" */
                 m0_sm_group_lock(&usr_sm_group);
                 m0_sm_asts_run(&usr_sm_group);
                 m0_sm_group_unlock(&usr_sm_group);
-		printf("\n\n$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$ DONE WITH SEG CREATE$$#$$$$$ \n");
        }
 
         if (m0_be_seg_state(seg) == M0_BESEG_FAILED) {
diff --git a/be/ut/handle_store.c b/be/ut/handle_store.c
index 96dd27c..d35ebfc 100644
--- a/be/ut/handle_store.c
+++ b/be/ut/handle_store.c
@@ -38,10 +38,10 @@
 #include "stob/linux.h"
 #include "stob/linux_internal.h"
 
-#define BE_DEBUG 0
 
 struct m0_be_seg        *seg;
 struct m0_sm_group      *sm_group;
+struct m0_sm_group       usr_sm_group;
 struct m0_be_hs_cbdata  *bh_cbdata;
 struct m0_uint128       *kvstore;
 
@@ -58,6 +58,33 @@ struct m0_stob         *log_stob;
 struct m0_stob_domain  *stob_dom;
 char                    path_name[MAXPATHLEN];
 
+/*
+ * Holds ast callback info and user sm_goup, used to return control from handler
+ * thread to user.
+ */
+struct m0_be_usr_astinfo {
+        struct m0_sm_group  *bua_sm_group;
+        struct m0_sm_ast     bua_ast;
+        m0_be_msg_type_t     bua_msg;
+        int                  bua_status;
+};
+
+struct m0_be_ts_cbdata {
+        struct m0_be_cbinfo       cbinfo;
+        struct m0_be_usr_astinfo be_usr_ast;
+        int                       counter;
+        /* current operation is completed or not */
+        bool                      completed;
+} *bht_cbdata;
+
+static void wait_and_lock_usr_sm_group()
+{
+	m0_chan_wait(&usr_sm_group.s_clink);
+        m0_sm_group_lock(&usr_sm_group);
+        m0_sm_asts_run(&usr_sm_group);
+        m0_sm_group_unlock(&usr_sm_group);
+}
+
 static int log_stob_create(void)
 {
         struct linux_stob        *lstob;
@@ -107,41 +134,48 @@ static int log_stob_create(void)
         if (nbytes < 0)
                 return -1;
 
-	if (BE_DEBUG)
-		printf("log stob : %s\n", path_name);
 
         return 0;
 }
 
-struct m0_be_hs_ts_cbdata {
-        struct m0_be_cbinfo cbinfo;
-        int                 counter;
-        bool                completed; /* current operation is completed or not */
-};
+static void be_usr_ast_post_helper(struct m0_be_usr_astinfo *be_usr_ast)
+{
+        struct m0_sm_ast *usr_ast;
+        usr_ast      = &be_usr_ast->bua_ast;
+
+        m0_sm_ast_post(&usr_sm_group, usr_ast);
+}
+
+static void be_ts_ast_post_cb(struct m0_sm_group *sm_group, struct m0_sm_ast *ast)
+{
+}
 
 void be_ts_hs_cb(struct m0_be_cbinfo *cbinfo, int status, m0_be_msg_type_t msg_type)
 {
-        struct m0_be_hs_ts_cbdata *cbdata;
+        struct m0_be_ts_cbdata *cbdata;
 
         M0_ASSERT(cbinfo != NULL);
-        cbdata = container_of(cbinfo, struct m0_be_hs_ts_cbdata, cbinfo);
+        cbdata = container_of(cbinfo, struct m0_be_ts_cbdata, cbinfo);
 
         cbdata->counter++;
         cbdata->completed = true;
-        if(BE_DEBUG)
-                printf("\n%s - counter : %d completed : %d\n", __FUNCTION__,
-                       cbdata->counter, (cbdata->completed) ? 1 : 0);
 
-        if(cbinfo->bc_pcbinfo != NULL && cbinfo->bc_pcbinfo->bc_cb != NULL)
-                m0_be_handler_post(cbinfo->bc_pcbinfo, status, msg_type);
+	if ((void*)&cbdata->be_usr_ast != NULL) {
+		cbdata->be_usr_ast.bua_status    = status;
+		cbdata->be_usr_ast.bua_msg       = msg_type;
+		cbdata->be_usr_ast.bua_ast.sa_cb = be_ts_ast_post_cb;
+		be_usr_ast_post_helper(&cbdata->be_usr_ast);
+	}
 }
 
 static int ts_be_init(void)
 {
         int  rc = 0;
         bool result;
-        struct m0_be_hs_ts_cbdata *bht_cbdata;
 
+        M0_ALLOC_PTR(bht_cbdata);
+        M0_ASSERT(bht_cbdata != NULL);
+        m0_sm_group_init(&usr_sm_group);
 
         sprintf(hs_cmd, "mkdir -p %s", stob_dir);
         rc = system(hs_cmd);
@@ -157,34 +191,31 @@ static int ts_be_init(void)
         M0_ASSERT(rc == 0);
 
         m0_be_domain_create(&dom, NULL, log_stob);
-        m0_be_domain_init(&dom, NULL);
-        sm_group = m0_be_domain_sm_group(&dom);
+	sm_group = m0_be_domain_sm_group(&dom);
         M0_ASSERT(sm_group != NULL);
 
-        result = m0_be_domain_lookup(&dom, "first", &seg);
+	bht_cbdata->cbinfo.bc_cb             =  be_ts_hs_cb;
+        bht_cbdata->cbinfo.bc_sm_group       =  sm_group;
+        bht_cbdata->cbinfo.bc_hq             = &dom.bd_hq;
+        bht_cbdata->cbinfo.bc_pcbinfo        =  NULL;
+        bht_cbdata->counter                  =  0;
+        bht_cbdata->completed                =  false;
+        bht_cbdata->be_usr_ast.bua_sm_group  = &usr_sm_group;
 
-        M0_ALLOC_PTR(bht_cbdata);
-        M0_ASSERT(bht_cbdata != NULL);
+        m0_be_domain_init(&dom, &bht_cbdata->cbinfo);
+	wait_and_lock_usr_sm_group();
+
+        result = m0_be_domain_lookup(&dom, "first", &seg);
 
         if (result == false) {
                 M0_ALLOC_PTR(seg);
                 m0_be_seg_init(seg, &dom, sm_group, 0);
-
-                bht_cbdata->cbinfo.bc_cb            = be_ts_hs_cb;
-                bht_cbdata->cbinfo.bc_sm_group      = sm_group;
-                bht_cbdata->cbinfo.bc_hq            = &dom.bd_hq;
-                bht_cbdata->cbinfo.bc_pcbinfo       = NULL;
-
-                bht_cbdata->completed               = false;
-                bht_cbdata->counter                 = 100;
-
+		/* cbdata already available. */
                 m0_be_seg_create(seg, NULL,  "first", NULL, &bht_cbdata->cbinfo);
+		wait_and_lock_usr_sm_group();
         }
 
-        while(bht_cbdata->completed == false);
         M0_ALLOC_PTR(kvstore);
-        m0_free(bht_cbdata);
-
         return rc;
 }
 
@@ -192,8 +223,16 @@ static int ts_be_fini(void)
 {
         int rc = 0;
 
-        rvm_truncate();
-        m0_be_seg_done(seg, NULL);
+	bht_cbdata->cbinfo.bc_cb             =  be_ts_hs_cb;
+        bht_cbdata->cbinfo.bc_sm_group       =  sm_group;
+        bht_cbdata->cbinfo.bc_hq             = &dom.bd_hq;
+        bht_cbdata->cbinfo.bc_pcbinfo        =  NULL;
+        bht_cbdata->counter                  =  0;
+        bht_cbdata->completed                =  false;
+        bht_cbdata->be_usr_ast.bua_sm_group  = &usr_sm_group;
+
+        m0_be_seg_done(seg, &bht_cbdata->cbinfo);
+	wait_and_lock_usr_sm_group();
         m0_stob_domain_fini(stob_dom);
         m0_be_domain_fini(&dom);
 
@@ -201,6 +240,7 @@ static int ts_be_fini(void)
         rc = system(hs_cmd);
         M0_ASSERT(rc == 0);
         m0_free(kvstore);
+        m0_free(bht_cbdata);
 
         return rc;
 }
@@ -208,11 +248,9 @@ static int ts_be_fini(void)
 static void test_be_handlestore()
 {
         int i;
-        struct m0_be_hs_ts_cbdata *bht_cbdata;
 
         M0_ALLOC_PTR(bh_cbdata);
         M0_ASSERT(bh_cbdata != NULL);
-        M0_ALLOC_PTR(bht_cbdata);
         M0_ASSERT(bht_cbdata != NULL);
 
         for (i = 0; i < 10; i++) {
@@ -232,14 +270,13 @@ static void test_be_handlestore()
                 bht_cbdata->counter                 = i;
 
                 m0_be_hs_update(bh_cbdata, &bht_cbdata->cbinfo);
-                while(bht_cbdata->completed == false);
+		wait_and_lock_usr_sm_group();
         }
         for (i = 0; i < 10; i = i+2) {
                 struct m0_uint128 *kvs = m0_be_hs_get(seg, i);
                 M0_ASSERT(kvs != NULL);
         }
         m0_free(bh_cbdata);
-        m0_free(bht_cbdata);
 }
 
 const struct m0_test_suite be_hs_ut = {
diff --git a/be/ut/kv_store.c b/be/ut/kv_store.c
index 0a05d25..f2d64c7 100644
--- a/be/ut/kv_store.c
+++ b/be/ut/kv_store.c
@@ -287,7 +287,6 @@ static void __init_kv_store1(struct m0_sm_group *sm_group,
 	struct m0_be_cbinfo	   *cbinfo;
         enum   m0_be_ks_init_mode  init_mode;
 
-	printf("\n!@@@@@ in init_kv_store 1!!@@@@@\n");
 
 	cbinfo = &bt_cbdata->cbinfo;
 	cbinfo->bc_cb = be_kv_ts_cb;
@@ -360,7 +359,6 @@ static void __initialise_handle1(enum m0_be_ks_init_mode init_mode)
         m0_be_domain_init(kv_dom, &bt_cbdata->cbinfo);
         /* Wait for domain_init completion. */
         wait_and_lock_usr_sm_group();
-	printf("\n\n$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$DOM INIT\nnnnnnn");
 
 	/* Create and init kvstore handle1. */
         /* Create a kv-store handle */
@@ -393,14 +391,12 @@ static void __initialise_handle1(enum m0_be_ks_init_mode init_mode)
         /* Wait for segment create completion. */
         wait_and_lock_usr_sm_group();
 
-	printf("\n\n######################segment created. ##########\n");
 
         /*
          * Wait for ks_init for handle1 to be completed,
          * called after seg_create_cb completion.
          */
         wait_and_lock_usr_sm_group();
-	printf("%%%%%%%%%%%%%%%%%%%%intitialised 1%%%%%%%%%%%%\n");
 }
 
 static int ts_kv_store_init()
@@ -722,7 +718,6 @@ void test_recover_and_delete()
                                  &handle2->ks_handle_rvm->ksr_tlist);
         M0_ASSERT(length == 0);
 
-	printf("\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! callinf fini in recovery!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
         ts_kv_store_fini();
 
         sprintf(kv_cmd, "rm -rf %s", stob_dir);
@@ -946,7 +941,6 @@ static void ub_fini()
         size_t  length;
         int     rc;
 
-	printf("\n\n^^^^^^^^^^^^^^^^^^^^^^^^in ub_fini^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n");
 	__set_bt_cbdata();
         bt_cbdata->be_usr_ast->bua_ast.sa_cb = increment_count_ast_cb;
 
diff --git a/cob/cob.c b/cob/cob.c
index 58a717c..72071eb 100644
--- a/cob/cob.c
+++ b/cob/cob.c
@@ -724,7 +724,6 @@ int m0_cob_domain_init(struct m0_cob_domain *dom, struct m0_dbenv *env,
 void m0_cob_domain_fini(struct m0_cob_domain *dom)
 {
 #ifndef __KERNEL__
-	printf("\n**********************************COB DOMAIN FINI*************************\n");
         /* Fini kv_store for nsrec. Finis cob_be_domain as well*/
         struct m0_be_seg	*kv_seg;
 	struct m0_cob_be_cbinfo	*cob_cbinfo;
diff --git a/rvm/rds_zap.c b/rvm/rds_zap.c
index e39fa06..f3115c6 100644
--- a/rvm/rds_zap.c
+++ b/rvm/rds_zap.c
@@ -198,7 +198,6 @@ void rzh_create_seg_cb(cbinfo, status, msg_type)
 	if (status != 0)
 		goto exit;
 
-	printf("\nfunction : %s\n", __FUNCTION__);
 	M0_ASSERT(cbinfo != NULL);
 
 	rzh_cbdata = container_of(cbinfo, rzh_cbdata_t, rzhc_cbinfo);
@@ -232,7 +231,6 @@ int rds_zap_heap(dev_name, dev_length, start_addr, static_length, heap_length,
 	rvm_seg_hdr_t         	*seg_hdr;
 	struct m0_be_cbinfo   	*cbinfo;
 {
-	printf("\nfunction : %s\n", __FUNCTION__);
 	rzh_cbdata_t 		*rzh_cbdata;
 	struct m0_be_cbinfo 	*rzhc_cbinfo;
 	int			 status = 0;
@@ -247,7 +245,6 @@ int rds_zap_heap(dev_name, dev_length, start_addr, static_length, heap_length,
 		assert(start_addr != NULL);
 	}
 
-	printf("\nfunction : %s\n", __FUNCTION__);
 
 	/* Initialization of seg->bs_rvm */
 	seg_hdr->n_loadregions = 2;
diff --git a/rvm/rvm_createseg.c b/rvm/rvm_createseg.c
index cab9938..9279659 100644
--- a/rvm/rvm_createseg.c
+++ b/rvm/rvm_createseg.c
@@ -36,7 +36,6 @@ void rcs_rvm_end_transaction_cb(struct m0_be_cbinfo *cbinfo,
 	rvm_seg_hdr_t	*seg_hdr;
 	rvm_region_t	*region;
 	rvm_tid_t	*tid;
-	printf("\nfunction : %s\n", __FUNCTION__);
 
 
 	rcs_cbdata = container_of(cbinfo, rcs_cbdata_t, rcsc_cbinfo);
@@ -86,7 +85,6 @@ void rcs_rvm_map_cb(struct m0_be_cbinfo *cbinfo,
 	rvm_region_def_t	*region_defs;
 	rvm_length_t 		 nregions;
 
-	printf("\nfunction : %s\n", __FUNCTION__);
 
 	rcs_cbdata = container_of(cbinfo, rcs_cbdata_t, rcsc_cbinfo);
 	M0_ASSERT(rcs_cbdata != NULL);
@@ -173,7 +171,6 @@ rvm_return_t rvm_create_segment(char *dev_name,
 	M0_ALLOC_PTR(rcs_cbdata);
 	M0_ASSERT(rcs_cbdata != NULL);
 
-	printf("\nfunction : %s\n", __FUNCTION__);
 
 	rvm_region_t *region = rvm_malloc_region();
 
diff --git a/rvm/rvm_init.c b/rvm/rvm_init.c
index 19245fa..30744f1 100644
--- a/rvm/rvm_init.c
+++ b/rvm/rvm_init.c
@@ -64,9 +64,7 @@ void rvm_create_log_cb(struct m0_be_cbinfo *cbinfo, int status,
 
         cbinfo->bc_cb = do_rvm_options_post_cb;
         /* process options */
-        printf("\nfunction : %s\n", __FUNCTION__);
         if ((retval=do_rvm_options(rvm_options, cbinfo)) != RVM_SUCCESS) {
-		printf("do_rvm_options failed\n");
                 status = -1;
 	}
 exit:
@@ -92,13 +90,11 @@ void do_rvm_options_post_cb(struct m0_be_cbinfo *cbinfo, int status,
         ri_cbdata  = container_of(cbinfo, ri_cbdata_t, ric_cbinfo);
         rvm_options = ri_cbdata->ric_rvm_options;
 
-	printf("\n function : %s\n", __func__);
         /* take care of default log */
         if (default_log == NULL) {
 		if ((retval = do_log_options(NULL,
                                            rvm_options,
                                            cbinfo)) != RVM_SUCCESS) {
-			printf("do_rvm_options failed\n");
                         status = -1;
 			goto err_exit;
 		}
@@ -163,7 +159,6 @@ rvm_return_t rvm_initialize(const char *rvm_version, rvm_options_t *rvm_options,
     if ((init_utils()) != 0)
         {
         retval =  RVM_EIO;          /* can't get time stamp */
-        printf("Error in init_utils\n");
         status = -1;
         msg_type = M0_BE_RVM_INIT_FAILED;
         goto exit;
@@ -171,7 +166,6 @@ rvm_return_t rvm_initialize(const char *rvm_version, rvm_options_t *rvm_options,
     init_map_roots();               /* mapping list and tree */
     init_log_list();                /* log device list */
 
-        printf("\nfunction : %s\n", __FUNCTION__);
     if (rvm_options && rvm_options->create_log_file) {
 
         retval = rvm_create_log(rvm_options, &rvm_options->create_log_size,
diff --git a/rvm/rvm_io.c b/rvm/rvm_io.c
index 7b2eec1..319cf14 100644
--- a/rvm/rvm_io.c
+++ b/rvm/rvm_io.c
@@ -270,7 +270,6 @@ static bool stob_io_complete_cb(struct m0_clink *clink)
 	lsi_cbdata = container_of(clink, lsi_cbdata_t, lsic_clink);
 	cbinfo 	   = &lsi_cbdata->lsic_cbinfo;
 
-        printf("\nfunction : %s\n", __FUNCTION__);
 
 	if (cbinfo != NULL && cbinfo->bc_cb != NULL) {
 		m0_be_handler_post(cbinfo, status, msg_type);
@@ -287,7 +286,6 @@ void launch_stob_io_cb(struct m0_be_cbinfo *cbinfo, int status,
 	struct m0_stob_io	*io;
 	struct m0_clink		*clink;
 
-        printf("\nfunction : %s\n", __FUNCTION__);
 
 	lsi_cbdata = container_of(cbinfo, lsi_cbdata_t, lsic_cbinfo);
 
@@ -328,7 +326,6 @@ uint32_t launch_stob_io_new(enum m0_stob_io_opcode opcode,
 
 	lsi_cbdata_t		*lsi_cbdata;
 
-        printf("\nfunction : %s\n", __FUNCTION__);
 
 	M0_ALLOC_PTR(lsi_cbdata);
 	M0_ASSERT(lsi_cbdata != NULL);
@@ -386,7 +383,6 @@ uint32_t launch_stob_io(opcode, io_nr, io_count, io_offset, io_addr, stob)
     struct m0_clink         clink;
     uint32_t                rc;
     uint64_t                nr;
-	printf("\n ERROROROROR __function %s\n", __FUNCTION__);
     m0_stob_io_init(&io);
 
     io.si_opcode              = opcode;
@@ -517,7 +513,6 @@ long read_stob_new(device_t *dev, rvm_offset_t *rvm_offset, char *dest,
 	int 			status;
 	m0_be_msg_type_t	msg_type = M0_BE_SUCCESS;
 
-	printf("\nfunction : %s\n", __FUNCTION__);
 
 	assert(dev->stob != NULL);
 	assert(length != 0);
@@ -780,7 +775,6 @@ void write_dev_post_async(cbinfo, status, msg_type)
    rvm_tx_cbdata_t *tx_cbdata;
    device_t         *dev;
 
-   printf("\nfunction : %s status : %d\n", __FUNCTION__, status);
 
    tx_cbdata = container_of(cbinfo, rvm_tx_cbdata_t, rtc_cbinfo);
    if (status != 0)
@@ -823,7 +817,6 @@ long write_dev(dev,offset,src,length,sync,cbinfo)
     struct m0_be_cbinfo  *rtxc_cbinfo;
     m0_be_msg_type_t	  msg_type=M0_BE_SUCCESS;
 
-        printf("\nfunction : %s\n", __FUNCTION__);
 
 
     assert(dev->stob != NULL);
@@ -881,7 +874,6 @@ long write_dev(dev,offset,src,length,sync,cbinfo)
                                        rtxc_cbinfo);
    }
    else {
-   	printf("\n in else for write_dev\n");
     /* do write if not in no update mode */
     if (!(rvm_utlsw && rvm_no_update)) {
         if ((wrt_len=write((int)dev->handle,src,(int)length)) < 0) {
@@ -1073,7 +1065,6 @@ void gather_write_stob_post_async(cbinfo, status, msg_type)
         rvm_tx_cbdata_t *tx_cbdata;
         device_t        *dev;
 
-	printf("\nfunction %s\n", __FUNCTION__);
         M0_ASSERT(cbinfo != NULL);
         tx_cbdata = container_of(cbinfo, rvm_tx_cbdata_t, rtc_cbinfo);
 
diff --git a/rvm/rvm_logflush.c b/rvm/rvm_logflush.c
index eb8ed35..5f1b01c 100644
--- a/rvm/rvm_logflush.c
+++ b/rvm/rvm_logflush.c
@@ -121,7 +121,6 @@ void wl_gather_write_dev_cb(cbinfo, be_status, msg)
 	log	      = lfs_cbdata->lfsc_log;
 	wrap	      = &log->log_wrap;
 
-		printf("\n function %s\n", __FUNCTION__);
 
 	#ifdef RVM_LOG_TAIL_SHADOW
 	/*
@@ -162,7 +161,6 @@ static rvm_return_t write_log_wrap(log, cbinfo)
 	int		 	be_status = 0;
 	m0_be_msg_type_t 	msg 	  = M0_BE_SUCCESS;
 
-		printf("\n function %s\n", __FUNCTION__);
 	M0_ALLOC_PTR(lfs_cbdata);
         if (lfs_cbdata == NULL) {
                 be_status = -1;
@@ -390,7 +388,6 @@ void wtid_gather_write_dev_cb(cbinfo, status, msg_type)
    log_t               *log;
    rvm_return_t	        retval;
 
-	printf("\nfunction %s \n", __FUNCTION__);
 
 
    if (status != 0)
@@ -415,10 +412,7 @@ exit:
         cbinfo->bc_pcbinfo->bc_cb != NULL) {
             m0_be_handler_post(cbinfo->bc_pcbinfo, status, msg_type);
 	     m0_free(tx_cbdata);
-     } else {
-
-	     /*printf("\n freeing tx_cbdata in %s\n", __FUNCTION__);*/
-	}
+     } 
 }
 
 void wtid_write_log_wrap_cb(cbinfo, be_status, msg_type)
@@ -434,8 +428,6 @@ void wtid_write_log_wrap_cb(cbinfo, be_status, msg_type)
    if (be_status != 0)
        goto exit;
 
-	printf("\n function %s \n", __FUNCTION__);
-
    tx_cbdata = container_of(cbinfo, rvm_tx_cbdata_t, rtc_cbinfo);
 
    log         = tx_cbdata->rtc_log;
@@ -496,7 +488,6 @@ void __wtid_write_log_wrap_loop(cbinfo, be_status, msg_type)
    if (be_status != 0)
        goto exit;
 
-   printf("\n function %s\n", __FUNCTION__);
 
    tx_cbdata = container_of(cbinfo, rvm_tx_cbdata_t, rtc_cbinfo);
 
@@ -561,7 +552,6 @@ void wtid_write_log_wrap(cbinfo, status, msg_type)
 	rvm_return_t	 	 retval = RVM_SUCCESS;
 
 
-	printf("\n function %s\n", __FUNCTION__);
 	if (status != 0)
 		goto exit;
 
@@ -583,7 +573,6 @@ void wtid_write_log_wrap(cbinfo, status, msg_type)
 					       FORWARD,rvm_false);
 
 	if(range == NULL) {
-		printf("\nfound range 0x0 in %s \n", __FUNCTION__);
 		wtid_write_log_wrap_cb(cbinfo, status, msg_type);
 		return;
 	}
@@ -631,7 +620,6 @@ static rvm_return_t write_tid(int_tid_t *tid, struct m0_be_cbinfo *cbinfo)
 	int		     be_status = 0;
 	m0_be_msg_type_t     msg_type  = M0_BE_SUCCESS;
 
-	printf("\n function %s\n", __FUNCTION__);
 
 	M0_ALLOC_PTR(rtx_data);
 	M0_ASSERT(rtx_data != NULL);
@@ -666,7 +654,6 @@ static rvm_return_t write_tid(int_tid_t *tid, struct m0_be_cbinfo *cbinfo)
 	    		goto exit;
 		}
 	} else {
-		printf("\n calling from else %s\n", __FUNCTION__);
 		rtx_data->rtc_is_wrap_done = rvm_false;
 		wtid_write_log_wrap(rtxc_cbinfo, be_status, msg_type);
 	}
@@ -688,7 +675,6 @@ void ls_update_log_tail_cb(cbinfo, be_status, msg)
 	lfsc_cbdata_t	*lfs_cbdata;
 	log_special_t	*special;
 
-	printf("\nfunction %s\n", __FUNCTION__);
 
 	if (be_status != 0)
 		goto exit;
@@ -715,7 +701,6 @@ void ls_gather_write_dev_cb(cbinfo, be_status, msg)
 	log_special_t	*special;
 	rvm_return_t	 retval;
 
-	printf("\nfunction %s\n", __FUNCTION__);
 	if (be_status != 0)
 		goto exit;
 
@@ -784,7 +769,6 @@ void ls_write_log_wrap_cb(cbinfo, be_status, msg)
 	log_t		*log;
 	log_special_t	*special;
 
-	printf("\nfunction %s\n", __FUNCTION__);
 
 	if (be_status != 0)
 		goto exit;
@@ -826,7 +810,6 @@ void ls_wait_for_space_cb(cbinfo, be_status, msg)
 	rvm_offset_t	*special_size;
 	rvm_return_t	 retval;
 	rvm_offset_t     log_free;        /* size calculation temp */
-	printf("\nfunction : %s\n", __FUNCTION__);
 
 	if (be_status != 0)
 		goto exit;
@@ -917,8 +900,6 @@ void wfs_wft_cb(struct m0_be_cbinfo *cbinfo, int status,
 	rvm_bool_t 	*wfsc_did_wait;
 	wfs_cbdata_t	*wfs_cbdata;
 
-	printf("\n function %s\n", __FUNCTION__);
-
 	wfs_cbdata = container_of(cbinfo, wfs_cbdata_t, wfsc_cbinfo);
         M0_ASSERT(wfs_cbdata != NULL);
 
@@ -959,7 +940,6 @@ static rvm_return_t wait_for_space(log_t 		*log,
 	m0_be_msg_type_t	 msg_type = M0_BE_SUCCESS;
 	rvm_return_t     	 retval = RVM_SUCCESS;
 	rvm_bool_t		 trun_needed = rvm_true;
-	printf("\nfunction : %s\n", __FUNCTION__);
 
 	/* see if enough space for current record */
 	*did_wait = rvm_false;
@@ -1018,7 +998,6 @@ static rvm_return_t log_special(log_t *log, log_special_t *special,
 	rvm_return_t         retval;          /* return value */
 	int		     be_status = 0;
 	m0_be_msg_type_t     msg = M0_BE_SUCCESS;
-	printf("\nfunction : %s\n", __FUNCTION__);
 
 	M0_ALLOC_PTR(lfs_cbdata);
         if (lfs_cbdata == NULL) {
@@ -1072,7 +1051,6 @@ void fls_log_special_cb(cbinfo, be_status, msg)
 	log_t		*log;
 	log_special_t	*special;
 	rvm_return_t	 retval;
-	printf("\nfunction : %s\n", __FUNCTION__);
 
 	if (be_status != 0)
 		goto exit;
@@ -1119,7 +1097,6 @@ rvm_return_t flush_log_special(log, cbinfo)
 	rvm_return_t      	 retval    = RVM_SUCCESS;
 	int		  	 be_status = 0;
 	m0_be_msg_type_t  	 msg 	   = M0_BE_SUCCESS;
-	printf("\nfunction : %s\n", __FUNCTION__);
 
         M0_ALLOC_PTR(lfs_cbdata);
         if (lfs_cbdata == NULL) {
@@ -1221,7 +1198,6 @@ void lt_wait_for_space_cb(struct m0_be_cbinfo *cbinfo,
 	{
 		cbinfo->bc_cb = lt_write_tid_cb;
 
-		printf("\n function %s\n", __FUNCTION__);
 		/* transfer tid to log device */
 		if ((retval = write_tid(lt_cbdata->ltc_tid, cbinfo)) != RVM_SUCCESS) {
 			status   = -1;
@@ -1292,7 +1268,6 @@ static rvm_return_t log_tid(log_t *log,
 
 	lt_cbdata_t		*lt_cbdata;
 	struct m0_be_cbinfo	*ltc_cbinfo;
-	printf("\nfunction : %s\n", __FUNCTION__);
 
 	M0_ALLOC_PTR(lt_cbdata);
 	M0_ASSERT(lt_cbdata != 0);
@@ -1339,7 +1314,6 @@ void fl_log_tid_cb(struct m0_be_cbinfo *cbinfo,
 	struct timeval   	 end_time;
 	long             	 kretval;
 	rvm_return_t     	 retval = RVM_SUCCESS;
-	printf("\nfunction : %s\n", __FUNCTION__);
 
 	fl_cbdata = container_of(cbinfo, fl_cbdata_t, flc_cbinfo);
 	log 	  = fl_cbdata->flc_log;
@@ -1421,7 +1395,6 @@ rvm_return_t flush_log(log,count,cbinfo)
 
 	M0_ALLOC_PTR(fl_cbdata);
 	M0_ASSERT(fl_cbdata != NULL);
-	printf("\nfunction : %s\n", __FUNCTION__);
 
 	RW_CRITICAL(log->flush_lock, w,
 	{
@@ -1452,7 +1425,6 @@ rvm_return_t flush_log(log,count,cbinfo)
 		});
 
 		if (tid == NULL) {
-			printf("\ntid NULL yes.\n");
 			done_looping = rvm_true;
 			goto exit;
 		}
@@ -1467,7 +1439,6 @@ rvm_return_t flush_log(log,count,cbinfo)
 		retval 	 = log_tid(log, tid, flc_cbinfo);
 
 		if (break_sw) {
-			printf("\nbreak_sq something\n");
 			done_looping = rvm_true;
 			goto exit;
 		}
diff --git a/rvm/rvm_logrecovr.c b/rvm/rvm_logrecovr.c
index 72cd8e3..30faf0f 100644
--- a/rvm/rvm_logrecovr.c
+++ b/rvm/rvm_logrecovr.c
@@ -200,7 +200,6 @@ void init_buffer_cb(cbinfo, status, msg)
 	log_t		*log;
 	rvm_bool_t	 synch;
 
-	printf("\n function %s \n", __FUNCTION__);
 	if (status != 0)
 		goto exit;
 
@@ -240,7 +239,6 @@ rvm_return_t init_buffer(log, offset, direction, synch, cbinfo)
 	int		 	 be_status = 0;
 	m0_be_msg_type_t  	 msg 	   = M0_BE_SUCCESS;
 
-	printf("\n function %s \n", __FUNCTION__);
 
 	M0_ALLOC_PTR(lrc_cbdata);
         if (lrc_cbdata == NULL) {
@@ -336,7 +334,6 @@ static rvm_return_t refill_buffer(log, direction, synch, cbinfo)
 	log_buf_t       *log_buf = &log->log_buf; /* log buffer descriptor */
 	rvm_offset_t     offset;             /* new buffer offset temp */
 
-	printf("\n function %s \n", __FUNCTION__);
 	/* compute new offset for buffer fill */
 	offset = RVM_ADD_LENGTH_TO_OFFSET(log_buf->offset,log_buf->ptr);
 
@@ -452,7 +449,6 @@ void load_aux_buf_cb(cbinfo, status, msg_type)
 	if (status != 0)
 		goto exit;
 
-	printf("\n function %s \n", __FUNCTION__);
 
 	lrc_cbdata =  container_of(cbinfo, lrc_cbdata_t, lrc_cbinfo);
 	log	   =  lrc_cbdata->lrc_log;
@@ -494,8 +490,6 @@ rvm_return_t load_aux_buf(log, log_offset, length,aux_ptr,
 	int		     be_status 	      = 0;
 	m0_be_msg_type_t     msg              = M0_BE_SUCCESS;
 
-	printf("\n function %s \n", __FUNCTION__);
-
 	assert(log->trunc_thread == cthread_self());
 
 	/* check offset */
@@ -769,7 +763,6 @@ void scan_nv_forward_cb(cbinfo, status, msg)
 	rvm_bool_t		 synch;
 	rvm_bool_t		 fwd_done = rvm_false;
 
-	printf("\nfunction %s \n", __FUNCTION__);
 
 	if (status != 0)
 		goto exit;
@@ -828,7 +821,6 @@ rvm_return_t scan_nv_forward(log, synch, cbinfo)
 	int			 be_status = 0;
 	m0_be_msg_type_t	 msg 	   = M0_BE_SUCCESS;
 
-	printf("\nfunction %s\n", __FUNCTION__);
 
 	M0_ALLOC_PTR(lrc_cbdata);
         if (lrc_cbdata == NULL) {
@@ -877,7 +869,6 @@ void scan_wrap_reverse_cb(struct m0_be_cbinfo *cbinfo, int  be_status,
 	long            tmp_ptr;            /* temporary buffer ptr */
 	lrc_cbdata_t   *lrc_cbdata;
 
-	printf("\nfunction %s\n", __FUNCTION__);
 	if (be_status != 0)
 		goto exit;
 
@@ -976,7 +967,6 @@ void __validate_rec_reverse_cb(struct m0_be_cbinfo *cbinfo,
 	long		 tmp_ptr;
 	rec_hdr_t       *rec_hdr;
 
-	printf("\nfunction %s\n", __FUNCTION__);
 	if (be_status != 0)
 		goto exit;
 
@@ -1023,7 +1013,6 @@ void validate_rec_reverse_cb(struct m0_be_cbinfo *cbinfo, int  be_status,
 	rvm_bool_t 	 synch;
 	rvm_bool_t 	 is_vrc_complete = rvm_false;
 
-	printf("\nfunction %s\n", __FUNCTION__);
 	if(be_status != 0)
 	    goto exit;
 
@@ -1126,7 +1115,6 @@ rvm_return_t validate_rec_reverse(log_t *log, rvm_bool_t synch,
 	rvm_return_t         retval = RVM_SUCCESS;
 	/*rvm_bool_t	     wrap_end = rvm_false;*/
 
-	printf("\nfunction %s\n", __FUNCTION__);
         M0_ALLOC_PTR(lrc_cbdata);
         if (lrc_cbdata == NULL) {
                 be_status = -1;
@@ -1186,7 +1174,6 @@ void scan_reverse_vrr_cb(struct m0_be_cbinfo *cbinfo, int  be_status,
 	rvm_return_t   retval;
 	lrc_cbdata_t  *lrc_cbdata;
 
-	printf("\nfunction %s\n", __FUNCTION__);
 	if(be_status != 0)
 		goto exit;
 	lrc_cbdata	= container_of(cbinfo, lrc_cbdata_t, lrc_cbinfo);
@@ -1214,7 +1201,6 @@ void rcs_done_loop(range_chk_sum_cbdata_t *rcs_cbdata)
 	m0_be_msg_type_t 	 msg_type = M0_BE_SUCCESS;
 	log_buf_t       	*log_buf;
 
-	printf("\nfunction %s\n", __FUNCTION__);
 	cbinfo  = &rcs_cbdata->rcsc_cbinfo;
 	log_buf = &rcs_cbdata->rcsc_log->log_buf;
 
@@ -1244,7 +1230,6 @@ void rcs_refill_buffer_cb(struct m0_be_cbinfo *cbinfo, int be_status,
 	rvm_bool_t		 done = rvm_false;
 	rvm_return_t		 retval;
 
-	printf("\nfunction %s\n", __FUNCTION__);
         rcs_cbdata = container_of(cbinfo, range_chk_sum_cbdata_t, rcsc_cbinfo);
 	M0_ASSERT(rcs_cbdata != NULL);
 
@@ -1314,7 +1299,6 @@ struct m0_be_cbinfo 	*cbinfo;
 	int			 be_status = 0;
 	m0_be_msg_type_t 	 msg_type = M0_BE_SUCCESS;
 
-	printf("\nfunction %s\n", __FUNCTION__);
 
 	M0_ALLOC_PTR(rcs_cbdata);
 	M0_ASSERT(rcs_cbdata != NULL);
@@ -1378,7 +1362,6 @@ void scan_reverse_snr_loop_cb(struct m0_be_cbinfo *cbinfo, int  be_status,
 	lrc_cbdata_t        *lrc_cbdata;
 	rvm_return_t	     retval;
 
-	printf("\nfunction %s\n", __FUNCTION__);
         if(be_status != 0)
                 goto exit;
 
@@ -1416,7 +1399,6 @@ void scan_reverse_cb(struct m0_be_cbinfo *cbinfo, int  be_status,
 	lrc_cbdata_t        *lrc_cbdata;
 	rvm_return_t	     retval;
 
-	printf("\nfunction %s\n", __FUNCTION__);
 	if(be_status != 0)
 		goto exit;
 
@@ -1456,7 +1438,6 @@ void scan_reverse_snr_cb(struct m0_be_cbinfo *cbinfo, int  be_status,
 	lrc_cbdata_t        *lrc_cbdata;
 	rvm_return_t	     retval = RVM_EINTERNAL;
 
-	printf("\nfunction %s\n", __FUNCTION__);
 	if(be_status != 0)
 		goto exit;
 
@@ -1532,7 +1513,6 @@ rvm_return_t scan_reverse(log, synch, cbinfo)
 	int			 be_status = 0;
 	assert(log_buf->ptr != -1);         /* can't reposition from this! */
 
-	printf("\nfunction %s\n", __FUNCTION__);
 
 	/* test if scan starting from tail */
 	offset = RVM_ADD_LENGTH_TO_OFFSET(log_buf->offset,log_buf->ptr);
@@ -1583,7 +1563,6 @@ void scan_nv_reverse_cb(cbinfo, status, msg)
 	rec_hdr_t	*rec_hdr;
 	long             len;
 
-	printf("\nfunction %s\n", __FUNCTION__);
 	if (status != 0)
 		goto exit;
 
@@ -1628,7 +1607,6 @@ rvm_return_t scan_nv_reverse(log, synch, cbinfo)
 	int			 be_status = 0;
 	m0_be_msg_type_t	 msg = M0_BE_SUCCESS;
 
-	printf("\nfunction %s\n", __FUNCTION__);
 	M0_ALLOC_PTR(lrc_cbdata);
         if (lrc_cbdata == NULL) {
                 be_status = -1;
@@ -1716,7 +1694,6 @@ void vrf_refill_buffer_cb(cbinfo, status, msg)
 	rec_end_t       	*rec_end = NULL;
 	long            	 tmp_ptr;
 
-	printf("\nfunction %s\n", __FUNCTION__);
 	if (status != 0)
 		goto exit;
 
@@ -1752,7 +1729,6 @@ void vrf_load_aux_buf_cb(cbinfo, status, msg)
 	rec_end_t       	*rec_end = NULL;
 	long            	 tmp_ptr;
 
-	printf("\nfunction %s\n", __FUNCTION__);
 	if (status != 0)
 		goto exit;
 
@@ -1794,7 +1770,6 @@ void validate_rec_forward_cb(cbinfo, status, msg)
 	rvm_bool_t		 synch;
 	rvm_bool_t		 val_rec_fwd_done = rvm_false;
 
-	printf("\nfunction %s\n", __FUNCTION__);
 
 	if (status != 0)
 		goto exit;
@@ -1914,7 +1889,6 @@ rvm_return_t validate_rec_forward(log, synch, cbinfo)
 	int			 be_status = 0;
 	m0_be_msg_type_t	 msg 	   = M0_BE_SUCCESS;
 
-	printf("\nfunction %s\n", __FUNCTION__);
 
 	M0_ALLOC_PTR(lrc_cbdata);
         if (lrc_cbdata == NULL) {
@@ -1968,7 +1942,6 @@ void sf_scan_nv_forward_cb(cbinfo, status, msg)
 	rvm_bool_t		 loop_continue = rvm_false;
 	long 		 	 ptr;
 
-	printf("\nfunction %s \n", __FUNCTION__);
 
 	if (status != 0)
 		goto exit;
@@ -2037,7 +2010,6 @@ void sf_init_buffer_cb(cbinfo, status, msg)
 	rvm_return_t     	 retval;
 	rvm_bool_t		 synch;
 
-	printf("\nfunction %s \n", __FUNCTION__);
 
 	if (status != 0)
 		goto exit;
@@ -2081,7 +2053,6 @@ rvm_return_t scan_forward(log, synch, cbinfo)
 	int			 be_status	  = 0;
 	m0_be_msg_type_t	 msg		  = M0_BE_SUCCESS;
 
-	printf("\nfunction %s \n", __FUNCTION__);
 
 	M0_ALLOC_PTR(lrc_cbdata);
         if (lrc_cbdata == NULL) {
@@ -2191,7 +2162,6 @@ void set_trans_status_cb(cbinfo, be_status, msg)
 	log_status_t	*status;
 	trans_hdr_t	*trans_hdr;
 
-	printf("\n function %s \n", __FUNCTION__);
 	if (be_status != 0)
 		goto exit;
 
@@ -2233,7 +2203,6 @@ void sts_range_chk_sum_cb(cbinfo, be_status, msg)
 	rvm_bool_t       chk_val;
 	rvm_return_t	 retval;
 
-	printf("\n function %s \n", __FUNCTION__);
 	if (be_status != 0)
 		goto exit;
 
@@ -2281,7 +2250,6 @@ void sts_nv_fwd_cb(cbinfo, be_status, msg)
 	rvm_bool_t      	 is_bad_record  = rvm_false;
 	rvm_return_t    	 retval	        = RVM_SUCCESS;
 
-	printf("\n function %s\n", __FUNCTION__);
 	if (be_status != 0)
 		goto exit;
 
@@ -2353,7 +2321,6 @@ static rvm_return_t set_trans_status(log, rec_hdr, cbinfo)
 	m0_be_msg_type_t	 msg	    = M0_BE_SUCCESS;
 	rvm_return_t    	 retval	    = RVM_SUCCESS;
 
-	printf("\n function %s \n", __FUNCTION__);
 	M0_ALLOC_PTR(lrc_cbdata);
         if (lrc_cbdata == NULL) {
                 be_status = -1;
@@ -2408,7 +2375,6 @@ void locate_tail_cb(loc_tail_cbdata_t *loc_tail_cbdata)
 	int			 be_status = 0;
 	m0_be_msg_type_t	 msg_type  = M0_BE_SUCCESS;
 
-	printf("\nfunction %s\n", __FUNCTION__);
 	cbinfo 		= &loc_tail_cbdata->ltc_cbinfo;
 	last_rec_num	= loc_tail_cbdata->ltc_last_rec_num;
 
@@ -2482,7 +2448,6 @@ void loc_tail_set_trans_status_cb(struct m0_be_cbinfo *cbinfo, int be_status,
 	struct timeval   	 last_write; /* last write to log */
 
 
-	printf("\nfunction %s\n", __FUNCTION__);
 
         loc_tail_cbdata = container_of(cbinfo, loc_tail_cbdata_t, ltc_cbinfo);
 	M0_ASSERT(loc_tail_cbdata != NULL);
@@ -2554,7 +2519,6 @@ void loc_tail_vrf_cb(struct m0_be_cbinfo *cbinfo, int be_status,
 	struct timeval   	 last_write; /* last write to log */
 	uint32_t		 set_trans_called = rvm_false;
 
-	printf("\nfunction %s\n", __FUNCTION__);
 
         loc_tail_cbdata = container_of(cbinfo, loc_tail_cbdata_t, ltc_cbinfo);
 	M0_ASSERT(loc_tail_cbdata != NULL);
@@ -3393,7 +3357,6 @@ void do_trans_cb(cbinfo, be_status, msg)
 	long            	 prev_range = 0;
 	rvm_return_t    	 retval     = RVM_SUCCESS;
 
-	printf("\n function %s\n", __FUNCTION__);
 	if (be_status != 0)
 		goto exit;
 
@@ -3479,8 +3442,6 @@ static rvm_return_t do_trans(log, skip_trans, cbinfo)
 	m0_be_msg_type_t	 msg	    = M0_BE_SUCCESS;
 	rvm_return_t    	 retval     = RVM_SUCCESS;
 
-	printf("\n function %s\n", __FUNCTION__);
-
 	assert(log->trunc_thread == cthread_self());
 	assert((status->trunc_state & RVM_TRUNC_PHASES) ==
 	       RVM_TRUNC_BUILD_TREE);
@@ -3941,7 +3902,6 @@ void bt_scan_reverse_cb(struct m0_be_cbinfo *cbinfo, int be_status,
 	if(be_status != 0)
 		goto exit;
 
-	printf("\nfunction %s\n", __FUNCTION__);
 
 	bt_cbdata   = container_of(cbinfo, bt_cbdata_t, bt_cbinfo);
 	log         = bt_cbdata->bt_log;
@@ -3983,7 +3943,6 @@ X(else)
 		switch (rec_end->rec_type)
                 {
 			case trans_hdr_id:        /* process transaction */
-printf("\n!@#$^!@*&^*(!@(*!&@(*!&@(*&!*(@&(!@&(* CALLING CHECK WRAP!@##$$^&^&^!@&*&*^\n");
 X( trans_hdr_id: chk_wrap)
 			        if ((retval = chk_wrap(
 				                  log,
@@ -4140,7 +4099,6 @@ X(init_buf)
 		status_offset = &status->prev_log_tail;
 		direction     = REVERSE;
 	}
-    	printf("\n function __%s__ \n", __FUNCTION__);
         retval = init_buffer(log, status_offset, direction, SYNCH, bt_cbinfo);
 
 	if (retval != RVM_SUCCESS && cbinfo->bc_pcbinfo != NULL &&
@@ -4410,7 +4368,6 @@ void __update_seg_cb(cbinfo, be_status, msg)
         if (be_status != 0)
                 goto exit;
 
-	printf("\nfunction %s\n", __FUNCTION__);
 
         lrc_cbdata     = container_of(cbinfo, lrc_cbdata_t, lrc_cbinfo);
         log            = lrc_cbdata->lrc_log;
@@ -4534,7 +4491,6 @@ static rvm_return_t  update_seg(log, seg_dict, seg_dev, cbinfo)
         stob          = seg_dev->stob;
         rvm_num_nodes = mod_tree->n_nodes;
         iter_remained = rvm_num_nodes;
-        printf("\nfunction %s\n",__FUNCTION__);
         /* sanity checks and initializations */
         assert(&log->dev != seg_dev);
         assert(log->trunc_thread == cthread_self());
@@ -4788,7 +4744,6 @@ void __lrc_apply_mod_update_seg(cbinfo, be_status, msg)
         seg_dev    = &seg_dict->dev;
         status     = &log->status;
 
-        printf("\n function %s\n",__FUNCTION__);
         if (iter == 0 || be_status != 0)
                 goto exit;
 
@@ -4898,7 +4853,6 @@ rvm_return_t apply_mods(log, cbinfo)
                == RVM_TRUNC_BUILD_TREE);
         status->trunc_state = (status->trunc_state & ~RVM_TRUNC_BUILD_TREE) |
                                RVM_TRUNC_APPLY;
-        printf("\n function %s\n",__FUNCTION__);
         /* Prepare cbdata. */
         M0_ALLOC_PTR(lrc_cbdata);
         if (lrc_cbdata == NULL) {
@@ -5022,7 +4976,6 @@ void write_log_status_cb(cbinfo, be_status, msg)
         if (be_status != 0)
                 goto exit;
 
-        printf("\nfunction = %s \n", __FUNCTION__);
         lrc_cbdata = container_of(cbinfo, lrc_cbdata_t, lrc_cbinfo);
         log        = lrc_cbdata->lrc_log;
         status     = &log->status;
@@ -5066,7 +5019,6 @@ static rvm_return_t status_update(log, new_1st_rec_num, cbinfo)
     status->trunc_state = (status->trunc_state & ~RVM_TRUNC_APPLY)
                            | RVM_TRUNC_UPDATE;
 
-    printf("\nfunction : %s\n", __FUNCTION__);
 
     M0_ALLOC_PTR(lrc_cbdata);
     if (lrc_cbdata == NULL) {
@@ -5237,7 +5189,6 @@ void wake_up_waiting_threads(log_t *log, rvm_bool_t is_daemon,
 			     log_daemon_t *daemon, rvm_return_t err_status)
 {
         log_status_t    *status = &log->status;
-	printf("\n function %s\n", __FUNCTION__);
 
 	/* Wake up waiting threads if any. */
         CRITICAL(log->truncation_lock,   /* begin truncation lock crit sec */
@@ -5286,7 +5237,6 @@ void status_update_cb(cbinfo, be_status, msg)
         status      = &log->status;
         daemon      = &log->daemon;
 
-        printf("\nfunction = %s \n", __FUNCTION__);
         if (be_status != 0)
                 goto exit;
 
@@ -5332,7 +5282,6 @@ void log_recover_cb(cbinfo, be_status, msg)
         struct timeval   tmp_time;           /* local timing temp */
         int              kretval;
 
-        printf("\nfunction : %s\n", __FUNCTION__);
         /* On some error, wake up waiting threads if any. */
         if (be_status != 0)
                 goto exit;
@@ -5537,7 +5486,6 @@ void lr_epoch_cb(cbinfo, be_status, msg)
 
 		/* do log scan if truncation actually needed */
 		if (do_truncation) {
-			printf("\nin if in %s\n", __FUNCTION__);
 			X(do_trunc)
 			/* build tree and time */
 			kretval= gettimeofday(&tmp_time,
@@ -5550,7 +5498,6 @@ void lr_epoch_cb(cbinfo, be_status, msg)
 			X(build_tree)
 			/* phase 2 */
 			if ((retval = build_tree(log, cbinfo)) != RVM_SUCCESS) {
-				printf("\n CRITICAL, build_tree failed! \n");
 				be_status = -1;
 				msg	  =  retval;
 				goto err_exit;
@@ -5569,14 +5516,12 @@ void lr_epoch_cb(cbinfo, be_status, msg)
 			X(status_upd)
 			/* always update the status */
 			/* phase 4 */
-			printf("\n function __enter__: %s\n", __FUNCTION__);
 			retval = status_update(log, new_1st_rec_num, cbinfo);
 
 			if (retval != RVM_SUCCESS) {
 				be_status = -1;
 				msg       = retval;
 			}
-			printf("\n function __exit__: %s\n", __FUNCTION__);
 			goto exit_log_recover;
 		}
 
@@ -5611,7 +5556,6 @@ void lr_locate_tail_cb(cbinfo, be_status, msg)
         rvm_length_t         new_1st_rec_num;
 	rvm_length_t        *count;             /* ptr to statistics counter */
 
-	printf("\nfunction : %s\n", __FUNCTION__);
 
 	if (be_status != 0)
 		goto exit_log_recover;
@@ -5625,7 +5569,6 @@ void lr_locate_tail_cb(cbinfo, be_status, msg)
 	new_1st_rec_num = lrc_cbdata->lrc_recnr;
 	count		= lrc_cbdata->lrc_count;
 
-	printf("\nfunction : %s before crit sec be_status : %d\n", __FUNCTION__,be_status);
 
         CRITICAL(log->truncation_lock,      /* begin truncation lock crit sec */
         {
@@ -5643,7 +5586,6 @@ void lr_locate_tail_cb(cbinfo, be_status, msg)
 					   status->log_head))
 				status->log_empty = rvm_true;
 			else {
-				printf("\n in a complete new trace!!\n");
 				status->log_empty = rvm_false;
 				do_truncation 	  = rvm_true;
 				new_1st_rec_num   = status->next_rec_num;
@@ -5727,7 +5669,6 @@ rvm_return_t log_recover(log, count, is_daemon, flag, cbinfo)
         m0_be_msg_type_t     msg       = M0_BE_SUCCESS;
         rvm_return_t         retval = RVM_SUCCESS;
 
-        printf("\nfunction : %s\n", __FUNCTION__);
 
 	M0_ALLOC_PTR(lrc_cbdata);
 	if (lrc_cbdata == NULL) {
@@ -5785,7 +5726,6 @@ rvm_return_t log_recover(log, count, is_daemon, flag, cbinfo)
 					RVM_TRUNC_FIND_TAIL);
 			}
 			else {
-				printf("\nfunction : %s !log->in_recovery", __FUNCTION__);
 				lr_locate_tail_cb(lrc_cbinfo, be_status, msg);
 
 			}
@@ -5844,7 +5784,6 @@ void rt_flush_log_cb(struct m0_be_cbinfo *cbinfo, int status,
 		goto exit;
 	}
 
-        printf("\nfunction : %s\n", __FUNCTION__);
 	retval = log_recover(default_log,
 			     &default_log->status.tot_rvm_truncate,
 			     rvm_false,
@@ -5881,7 +5820,6 @@ rvm_return_t rvm_truncate(struct m0_be_cbinfo *cbinfo)
 	M0_ALLOC_PTR(rt_cbinfo);
 	M0_ASSERT(rt_cbinfo != NULL);
 
-        printf("\nfunction : %s\n", __FUNCTION__);
 
 	m0_be_cbinfo_copy_helper(cbinfo, rt_cbinfo, rt_flush_log_cb);
 
@@ -5946,7 +5884,6 @@ rvm_return_t wait_for_truncation(log_t *log,
 	int 		 status   = 0;
 	m0_be_msg_type_t msg_type = M0_BE_SUCCESS;
 
-	printf("\nfunction : %s\n", __FUNCTION__);
 
 	while (!exit_sw)
 	{
diff --git a/rvm/rvm_logstatus.c b/rvm/rvm_logstatus.c
index bb959a5..abbf17a 100644
--- a/rvm/rvm_logstatus.c
+++ b/rvm/rvm_logstatus.c
@@ -332,7 +332,6 @@ void pwb_read_dev_cb(struct m0_be_cbinfo *cbinfo, int be_status,
 exit:
      if (cbinfo->bc_pcbinfo != NULL &&
          cbinfo->bc_pcbinfo->bc_cb != NULL) {
-             printf("\nErr function : %s\n", __FUNCTION__);
              m0_be_handler_post(cbinfo->bc_pcbinfo, be_status, msg_type);
      }
      m0_free(rcl_cbdata);
@@ -368,7 +367,6 @@ static rvm_return_t preload_wrt_buf(log,cbinfo)
     if (be_status != 0 &&
             cbinfo->bc_pcbinfo != NULL &&
             cbinfo->bc_pcbinfo->bc_cb != NULL) {
-                printf("\nErr function : %s\n", __FUNCTION__);
                 m0_be_handler_post(cbinfo->bc_pcbinfo, be_status, msg_type);
                 m0_free(rcl_cbdata);
     }
@@ -421,7 +419,6 @@ void ol_read_log_status_cb(struct m0_be_cbinfo *cbinfo, int status,
                                               dev->wrt_buf_len);
 
         /* pre-load write buffer */
-        printf("\n___dev_rawio function : %s\n", __FUNCTION__);
         if ((retval=preload_wrt_buf(log, cbinfo->bc_pcbinfo)) != RVM_SUCCESS)
             goto err_exit;
 	else
@@ -437,7 +434,6 @@ err_exit:
 ol_err_exit:
         if (cbinfo->bc_pcbinfo != NULL &&
             cbinfo->bc_pcbinfo->bc_cb != NULL) {
-                printf("\nfunction : %s\n", __FUNCTION__);
                 m0_be_handler_post(cbinfo->bc_pcbinfo, retval, msg_type);
         }
 exit:
@@ -512,7 +508,6 @@ rvm_return_t open_log(dev_name,log_ptr,status_buf,rvm_options,cbinfo)
     rcl_cbinfo                          = &rcl_cbdata->rclc_cbinfo;
     m0_be_cbinfo_copy_helper(cbinfo, rcl_cbinfo, ol_read_log_status_cb);
 
-    printf("\nfunction : %s\n", __FUNCTION__);
     /* open status area */
     if ((retval=read_log_status(log,status_buf,rcl_cbinfo)) != RVM_SUCCESS)
         {
@@ -530,7 +525,6 @@ ol_err_exit:
         if (retval != 0 &&
             cbinfo->bc_pcbinfo != NULL &&
             cbinfo->bc_pcbinfo->bc_cb != NULL) {
-                printf("\nErr function : %s\n", __FUNCTION__);
                 m0_be_handler_post(cbinfo->bc_pcbinfo, retval, msg_type);
                 m0_free(rcl_cbdata);
         }
@@ -553,7 +547,6 @@ void do_log_options_cb(struct m0_be_cbinfo *cbinfo, int status,
     log_ptr     = rcl_cbdata->rclc_out_log_ptr;
     rvm_options = rcl_cbdata->rclc_rvm_options;
 
-    printf("\nfunction : %s\n", __FUNCTION__);
 
     if(log != NULL)
     {
@@ -562,7 +555,6 @@ void do_log_options_cb(struct m0_be_cbinfo *cbinfo, int status,
             {
             CRITICAL(log->dev_lock,retval=preload_wrt_buf(log));
             if (retval != RVM_SUCCESS) {
-		    printf("preload_wrt_buff failed\n");
                     retval = RVM_ELOG;
                     status = -1;
                     msg_type = M0_BE_RVM_INIT_FAILED;
@@ -574,7 +566,6 @@ void do_log_options_cb(struct m0_be_cbinfo *cbinfo, int status,
     retval = set_truncate_options(log,rvm_options);
     if (log_ptr != NULL)
        *log_ptr = log;
-      printf("\nfunction : %s\n", __FUNCTION__);
 exit:
         if (cbinfo->bc_pcbinfo != NULL &&
             cbinfo->bc_pcbinfo->bc_cb != NULL) {
@@ -599,21 +590,17 @@ void dlo_open_log_cb(struct m0_be_cbinfo *cbinfo, int status,
 
       /* do recovery processing for log */
       log->in_recovery = rvm_true;
-      printf("\n function __enter__: %s\n", __func__);
       if ((retval = log_recover(log,&log->status.tot_recovery,
                                 rvm_false,
                                 RVM_RECOVERY, rcl_cbinfo)) != RVM_SUCCESS) {
-  		printf("log_recover failed.\n");
                 status    = -1;
                 msg_type  = M0_BE_RVM_INIT_FAILED;
                 retval    = RVM_ELOG;
       }
 
-      printf("\nfunction __exit__: %s\n", __FUNCTION__);
       if (status != 0 &&
           cbinfo->bc_pcbinfo != NULL &&
           cbinfo->bc_pcbinfo->bc_cb != NULL) {
-               printf("\nErr function : %s\n", __FUNCTION__);
                m0_be_handler_post(cbinfo->bc_pcbinfo, status, msg_type);
                m0_free(rcl_cbdata);
       }
@@ -660,12 +647,10 @@ rvm_return_t do_log_options(log_ptr,rvm_options, cbinfo)
            rcl_cbinfo                          = &rcl_cbdata->rclc_cbinfo;
            m0_be_cbinfo_copy_helper(cbinfo, rcl_cbinfo, dlo_open_log_cb);
 
-    	   printf("\nfunction : %s\n", __FUNCTION__);
            /* build log descriptor */
            if ((retval = open_log(log_dev, &rcl_cbdata->rclc_log, NULL,
 	   			rvm_options, rcl_cbinfo))
                != RVM_SUCCESS) {
-   		printf("open_log failed.\n");
                    status    = -1;
                    msg_type  = M0_BE_RVM_INIT_FAILED;
                    retval    = RVM_ELOG;
@@ -675,7 +660,6 @@ exit:
         if (status != 0 &&
             cbinfo->bc_pcbinfo != NULL &&
             cbinfo->bc_pcbinfo->bc_cb != NULL) {
-                printf("\nErr function : %s\n", __FUNCTION__);
                 m0_be_handler_post(cbinfo->bc_pcbinfo, status, msg_type);
                 m0_free(rcl_cbdata);
         }
@@ -936,11 +920,9 @@ void rls_read_dev_cb(struct m0_be_cbinfo *cbinfo, int be_status,
                                              status->log_start);
     status->update_cnt = UPDATE_STATUS;
 
-    printf("\nfunction : %s\n", __FUNCTION__);
 err_exit:
      if (cbinfo->bc_pcbinfo != NULL &&
          cbinfo->bc_pcbinfo->bc_cb != NULL) {
-             printf("\nErr function : %s\n", __FUNCTION__);
              m0_be_handler_post(cbinfo->bc_pcbinfo, be_status, msg_type);
      }
      m0_free(rcl_cbdata);
@@ -979,7 +961,6 @@ rvm_return_t read_log_status(log,status_buf,cbinfo)
     if (log->dev.raw_io) status_offset = &raw_status_offset;
     else
     status_offset = &file_status_offset;
-    printf("\nfunction : %s\n", __FUNCTION__);
     if (read_dev(&log->dev,status_offset,
                   dev_status,LOG_DEV_STATUS_SIZE, rcl_cbinfo) < 0) {
         msg_type = RVM_EIO;
@@ -989,7 +970,6 @@ rvm_return_t read_log_status(log,status_buf,cbinfo)
     if (be_status != 0 &&
             cbinfo->bc_pcbinfo != NULL &&
             cbinfo->bc_pcbinfo->bc_cb != NULL) {
-                printf("\nErr function : %s\n", __FUNCTION__);
                 m0_be_handler_post(cbinfo->bc_pcbinfo, be_status, msg_type);
                 m0_free(rcl_cbdata);
     }
@@ -1007,7 +987,6 @@ rvm_return_t write_log_status(log,dev, cbinfo)
     log_dev_status_t    *dev_status;    /* status i/o area typed ptr */
     char                status_io[LOG_DEV_STATUS_SIZE]; /* i/o buffer */
 
-	printf("\n function %s\n", __FUNCTION__);
     /* initializations */
 #ifdef RVM_LOG_TAIL_SHADOW
     assert(RVM_OFFSET_EQL(log_tail_shadow,log->status.log_tail));
@@ -1140,8 +1119,6 @@ rvm_return_t update_log_tail(log,rec_hdr,cbinfo)
     m0_be_msg_type_t 	msg_type = M0_BE_SUCCESS;
     rvm_bool_t		write_dev_needed = rvm_true;
 
-	printf("\n function %s\n", __FUNCTION__);
-
     assert(((&log->dev == &default_log->dev) && (!rvm_utlsw)) ?
            (!LOCK_FREE(default_log->dev_lock)) : 1);
 
@@ -1345,7 +1322,6 @@ void rcl_write_dev_cb(struct m0_be_cbinfo *cbinfo, int status,
         log = rcl_cbdata->rclc_log;
 
         /* complete initialization */
-        printf("\nfunction : %s\n", __FUNCTION__);
         retval = init_log_status(log, cbinfo->bc_pcbinfo);
 
         if (retval != RVM_SUCCESS) {
@@ -1377,7 +1353,6 @@ rvm_return_t rvm_create_log(rvm_options, log_len,mode, cbinfo)
     struct m0_be_cbinfo     *rclc_cbinfo;
     m0_be_msg_type_t         msg_type = M0_BE_SUCCESS;
 
-    printf("\nfunction : %s\n", __FUNCTION__);
 
     if ((retval = bad_options(rvm_options,rvm_true)) != RVM_SUCCESS)
         return retval;                  /* bad options ptr or record */
diff --git a/rvm/rvm_map.c b/rvm/rvm_map.c
index 0ec64bd..0fdd65b 100644
--- a/rvm/rvm_map.c
+++ b/rvm/rvm_map.c
@@ -353,7 +353,6 @@ char *page_alloc(seg_hdr,len)
     {
     char           *vmaddr;
 
-    /* printf ("page_alloc(%ul)\n", len); */
 #ifdef HAVE_MMAP
     mmap_anon(vmaddr, NULL, len, PROT_READ | PROT_WRITE);
 #else
@@ -967,7 +966,6 @@ static rvm_return_t chk_dependencies(seg, region, cbinfo)
 	int		     be_status = 0;
 	m0_be_msg_type_t     msg       = M0_BE_SUCCESS;
 
-	printf("\nfunction : %s\n", __FUNCTION__);
 
 	/* check for multiple mappings of same segment region */
 	CRITICAL(seg->seg_lock,            /* begin seg_lock crit sect */
@@ -975,7 +973,6 @@ static rvm_return_t chk_dependencies(seg, region, cbinfo)
 		x_region = chk_seg_mappings(region,&seg->map_list);
 
 		if (x_region == NULL) {
-			printf("\nStarted in first if %s\n", __FUNCTION__);
 			/* enter region in map_list */
 			region->seg = seg;
 			(void)move_list_entry(NULL,&seg->map_list,
@@ -1003,7 +1000,6 @@ static rvm_return_t chk_dependencies(seg, region, cbinfo)
 			x_region = chk_seg_mappings(region, &seg->unmap_list);
 
 			if (x_region != NULL) {
-				printf("about to call wait_for_truncation...\n");
 				cd_cbdata->cdc_x_region = x_region;
 
 				(void)initiate_truncation(seg->log,100);
@@ -1017,7 +1013,6 @@ static rvm_return_t chk_dependencies(seg, region, cbinfo)
 					goto err_exit;
 				}
 			} else {
-				printf("\n THISSSSSSSSS \n");
 			}
 
 		} else {
@@ -1049,7 +1044,6 @@ static rvm_return_t map_data(rvm_options_t 	 *rvm_options,
 	#if defined(__NetBSD__) || defined(__FreeBSD__)
 	char            *addr;
 	#endif
-	printf("\nfunction : %s\n", __FUNCTION__);
 	/* check for pager mapping */
 	if (rvm_options != NULL)
 		if (rvm_options->pager != NULL) {
@@ -1147,7 +1141,6 @@ void rm_map_data_cb(struct m0_be_cbinfo *cbinfo,
 	mem_region_t	*mem_region;
 	region_t	*region;
 
-	printf("\nfunction : %s\n", __FUNCTION__);
 
 	rm_cbdata = container_of(cbinfo, rm_cbdata_t, rmc_cbinfo);
         M0_ASSERT(rm_cbdata != NULL);
@@ -1187,7 +1180,6 @@ void rm_chk_dependencies_cb(struct m0_be_cbinfo *cbinfo, int status,
 	int		 	 fd;		   /* For private mappings */
 	rvm_return_t		 retval;
 
-	printf("\nfunction : %s\n", __FUNCTION__);
 
 	rm_cbdata = container_of(cbinfo, rm_cbdata_t, rmc_cbinfo);
 	rvm_region 	= rm_cbdata->rmc_rvm_region;
@@ -1268,7 +1260,6 @@ void rm_do_rvm_options_cb(struct m0_be_cbinfo *cbinfo, int status,
 	rvm_region = rm_cbdata->rmc_rvm_region;
 	seg_hdr    = rm_cbdata->rmc_seg_hdr;
 
-	printf("\nfunction : %s\n", __FUNCTION__);
 
 	if (status != 0)
 		goto exit;
@@ -1349,7 +1340,6 @@ rvm_return_t rvm_map(rvm_seg_hdr_t 		*seg_hdr,
 	M0_ALLOC_PTR(rm_cbdata);
 	M0_ASSERT(rm_cbdata != NULL);
 
-	printf("\nfunction : %s\n", __FUNCTION__);
 
 	rm_cbdata->rmc_rvm_region 	= rvm_region;
 	rm_cbdata->rmc_rvm_options 	= rvm_options;
@@ -1374,7 +1364,6 @@ rvm_return_t rvm_map(rvm_seg_hdr_t 		*seg_hdr,
 	}
 
 	if (rvm_options != NULL) {
-		printf("here __ function : %s\n",__func__);
 		rmc_cbinfo->bc_cb = rm_do_rvm_options_cb;
 		retval = do_rvm_options(rvm_options, rmc_cbinfo);
 
diff --git a/rvm/rvm_status.c b/rvm/rvm_status.c
index 25c0816..3260025 100644
--- a/rvm/rvm_status.c
+++ b/rvm/rvm_status.c
@@ -134,7 +134,6 @@ void do_rvm_options_cb(struct m0_be_cbinfo *cbinfo, int status,
              /* set mapping kind */
              rvm_map_private = rvm_options->flags & RVM_MAP_PRIVATE;
        }
-       printf("\nfunction : %s\n", __FUNCTION__);
 
 err_exit:
         if (cbinfo->bc_pcbinfo != NULL &&
@@ -172,7 +171,6 @@ rvm_return_t do_rvm_options(rvm_options, cbinfo)
         ri_cbinfo                          = &ri_cbdata->ric_cbinfo;
         m0_be_cbinfo_copy_helper(cbinfo, ri_cbinfo, do_rvm_options_cb);
 
-	printf("\n function : %s\n", __func__);
         /* do log - modifying options */
         if ((retval=do_log_options(&log,rvm_options, ri_cbinfo)) != RVM_SUCCESS)
             return retval;
diff --git a/rvm/rvm_trans.c b/rvm/rvm_trans.c
index 60db5fd..c81caf2 100644
--- a/rvm/rvm_trans.c
+++ b/rvm/rvm_trans.c
@@ -846,7 +846,6 @@ static rvm_return_t queue_tid(int_tid_t *tid, struct m0_be_cbinfo *cbinfo)
 	int			 status = 0;
 	m0_be_msg_type_t 	 msg_type = M0_BE_SUCCESS;
 
-	printf("\nfunction : %s\n", __FUNCTION__);
 
 	/* make sure transaction not too large for log */
 	if ((retval = nv_io_size(tid,&tid->log_size)) != RVM_SUCCESS) {
@@ -1013,7 +1012,6 @@ rvm_return_t rvm_end_transaction(rvm_tid_t *rvm_tid, rvm_mode_t mode,
 	m0_be_msg_type_t msg_type = M0_BE_SUCCESS;
 	rvm_bool_t	 null_tid = rvm_false;
 
-	printf("\nfunction : %s\n", __FUNCTION__);
 
 	/* basic entry checks */
 	if (bad_init()) {
diff --git a/rvm/rvm_unmap.c b/rvm/rvm_unmap.c
index 5599930..e529680 100644
--- a/rvm/rvm_unmap.c
+++ b/rvm/rvm_unmap.c
@@ -61,7 +61,6 @@ rvm_return_t rvm_unmap(seg_hdr,rvm_region)
     if ((region->vmaddr != rvm_region->vmaddr) ||
         (region->length != rvm_region->length))
         {
-	printf("\n\nhere only\n\n");
         retval = RVM_ERANGE;
         goto err_exit;
         }
-- 
1.8.3.2

