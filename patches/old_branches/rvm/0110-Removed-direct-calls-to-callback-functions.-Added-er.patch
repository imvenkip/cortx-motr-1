From 5f658b8087cbc53e083aade91b267743997a50c7 Mon Sep 17 00:00:00 2001
From: Sachin Patil <sachin_patil@xyratex.com>
Date: Fri, 31 May 2013 03:16:38 -0700
Subject: [PATCH 110/121] Removed direct calls to callback functions. Added
 error check at the start of cb's.

---
 rvm/rvm_logrecovr.c | 109 ++++++++++++++++++++++++++++++++++------------------
 1 file changed, 72 insertions(+), 37 deletions(-)

diff --git a/rvm/rvm_logrecovr.c b/rvm/rvm_logrecovr.c
index f23b921..c84bf24 100644
--- a/rvm/rvm_logrecovr.c
+++ b/rvm/rvm_logrecovr.c
@@ -1221,11 +1221,12 @@ void rcs_refill_buffer_cb(struct m0_be_cbinfo *cbinfo, int be_status,
 	rvm_return_t		 retval;
 
 	printf("\nfunction %s\n", __FUNCTION__);
+        rcs_cbdata = container_of(cbinfo, range_chk_sum_cbdata_t, rcsc_cbinfo);
+	M0_ASSERT(rcs_cbdata != NULL);
+
 	if (be_status != 0)
 		goto exit;
 
-        rcs_cbdata 	= container_of(cbinfo, range_chk_sum_cbdata_t,
-				       rcsc_cbinfo);
 	log	   	= rcs_cbdata->rcsc_log;
 	log_buf	   	= &log->log_buf;
 	nv_length  	= rcs_cbdata->rcsc_nv_length;
@@ -1245,7 +1246,7 @@ void rcs_refill_buffer_cb(struct m0_be_cbinfo *cbinfo, int be_status,
 		goto done_looping;
 	}
 
-	retval = refill_buffer(log, FORWARD, synch);
+	retval = refill_buffer(log, FORWARD, synch, cbinfo);
 
 	if (retval != RVM_SUCCESS) {
 		be_status = -1;
@@ -1320,7 +1321,7 @@ struct m0_be_cbinfo 	*cbinfo;
 
         m0_be_cbinfo_copy_helper(cbinfo, rcsc_cbinfo, rcs_refill_buffer_cb);
 
-	retval = refill_buffer(log, FORWARD, synch);
+	retval = refill_buffer(log, FORWARD, synch, rcsc_cbinfo);
 
 	if (retval != RVM_SUCCESS) {
 		msg_type  = retval;
@@ -1368,7 +1369,7 @@ void scan_reverse_snr_loop_cb(struct m0_be_cbinfo *cbinfo, int  be_status,
 		/* Loop Terminates */
 		scan_reverse_vrr_cb(cbinfo, be_status, msg_type);
 	}
-	else if ((retval=scan_nv_reverse(log,synch,cbinfo)) != RVM_SUCCESS) {
+	else if ((retval=scan_nv_reverse(log, synch, cbinfo)) != RVM_SUCCESS) {
 		be_status = -1;
 		msg_type  = retval;
 	}
@@ -2389,6 +2390,9 @@ void locate_tail_cb(loc_tail_cbdata_t *loc_tail_cbdata)
 	log_buf 	= &log->log_buf;
 	last_write 	= status->last_write;
 
+	if (be_status != 0)
+		goto err_exit;
+
 	/* tail found, update in-memory status */
 #ifdef RVM_LOG_TAIL_BUG
 	unprotect_page__Fi(ClobberAddress);
@@ -2419,6 +2423,9 @@ void locate_tail_cb(loc_tail_cbdata_t *loc_tail_cbdata)
 			status->last_rec_num = last_rec_num;
 	}
 
+	status->valid 	   = rvm_true;
+
+err_exit:
 	rvm_utlsw 	   = loc_tail_cbdata->ltc_save_rvm_utlsw;
 	status->last_trunc = loc_tail_cbdata->ltc_save_last_trunc;
 
@@ -2445,8 +2452,6 @@ void loc_tail_set_trans_status_cb(struct m0_be_cbinfo *cbinfo, int be_status,
 
 
 	printf("\nfunction %s\n", __FUNCTION__);
-	if (be_status != 0)
-		goto exit;
 
         loc_tail_cbdata = container_of(cbinfo, loc_tail_cbdata_t, ltc_cbinfo);
 	M0_ASSERT(loc_tail_cbdata != NULL);
@@ -2456,11 +2461,15 @@ void loc_tail_set_trans_status_cb(struct m0_be_cbinfo *cbinfo, int be_status,
 	log_buf 	= &log->log_buf;
 	last_write 	= status->last_write;
 
+	if (be_status != 0)
+		goto exit;
+
 	if (log_buf->ptr == -1) {
 		goto done_looping;
 	}
 
-	if ((retval = scan_forward(log, NO_SYNCH)) != RVM_SUCCESS) {
+	cbinfo->bc_cb = loc_tail_vrf_cb;
+	if ((retval = scan_forward(log, NO_SYNCH, cbinfo)) != RVM_SUCCESS) {
 		be_status = -1;
 		msg_type  = retval;
 
@@ -2477,8 +2486,6 @@ void loc_tail_set_trans_status_cb(struct m0_be_cbinfo *cbinfo, int be_status,
 			goto err_exit;
 		}
 
-	loc_tail_vrf_cb(cbinfo, be_status, msg_type);
-
 	goto exit;
 
 done_looping:
@@ -2517,8 +2524,6 @@ void loc_tail_vrf_cb(struct m0_be_cbinfo *cbinfo, int be_status,
 	uint32_t		 set_trans_called = rvm_false;
 
 	printf("\nfunction %s\n", __FUNCTION__);
-	if (be_status != 0)
-		goto err_exit;
 
         loc_tail_cbdata = container_of(cbinfo, loc_tail_cbdata_t, ltc_cbinfo);
 	M0_ASSERT(loc_tail_cbdata != NULL);
@@ -2528,6 +2533,9 @@ void loc_tail_vrf_cb(struct m0_be_cbinfo *cbinfo, int be_status,
 	log_buf 	= &log->log_buf;
 	last_write 	= status->last_write;
 
+	if (be_status != 0)
+		goto err_exit;
+
 	if (log_buf->ptr == -1)		/* tail located */
 		goto done_looping;
 
@@ -2547,7 +2555,7 @@ void loc_tail_vrf_cb(struct m0_be_cbinfo *cbinfo, int be_status,
 			break;
 		case trans_hdr_id:
 			cbinfo->bc_cb = loc_tail_set_trans_status_cb;
-			retval = set_trans_status(log, rec_hdr);
+			retval = set_trans_status(log, rec_hdr, cbinfo);
 			if (retval != RVM_SUCCESS) {
 				be_status = -1;
 				msg_type = retval;
@@ -2555,9 +2563,7 @@ void loc_tail_vrf_cb(struct m0_be_cbinfo *cbinfo, int be_status,
 			}
 
 			set_trans_called = rvm_true;
-			/** This needs to be removed when set_trans_status
-			 * becomes async. */
-			loc_tail_set_trans_status_cb(cbinfo, be_status, msg_type);
+
 			assert(log->trunc_thread == cthread_self());
 			assert((status->trunc_state & RVM_TRUNC_PHASES) == RVM_TRUNC_FIND_TAIL);
 			if (log_buf->ptr != -1)
@@ -2618,13 +2624,19 @@ void loc_tail_init_buf_cb1(struct m0_be_cbinfo *cbinfo, int be_status,
 	log_buf 	= &log->log_buf;
 	last_write 	= status->last_write;
 
+	if (be_status != 0)
+		goto err_exit;
+
+	assert(log->trunc_thread == cthread_self());
+	assert((status->trunc_state & RVM_TRUNC_PHASES) == RVM_TRUNC_FIND_TAIL);
 
 	/* see if record at tail is valid, scan until bad record found */
 	cbinfo->bc_cb = loc_tail_vrf_cb;
 
-	if ((retval = validate_rec_forward(log, NO_SYNCH)) != RVM_SUCCESS) {
+	retval = validate_rec_forward(log, NO_SYNCH, cbinfo);
+	if (retval != RVM_SUCCESS) {
 		be_status = -1;
-		msg_type = retval;
+		msg_type  = retval;
 		goto err_exit;
 	}
 
@@ -2636,7 +2648,7 @@ err_exit:
 	assert(log->trunc_thread == cthread_self());
 	assert((status->trunc_state & RVM_TRUNC_PHASES) == RVM_TRUNC_FIND_TAIL);
 
-	if (status != 0 && cbinfo->bc_pcbinfo != NULL &&
+	if (be_status != 0 && cbinfo->bc_pcbinfo != NULL &&
 	    cbinfo->bc_pcbinfo->bc_cb != NULL) {
                 m0_be_handler_post(cbinfo->bc_pcbinfo, be_status, msg_type);
                 m0_free(loc_tail_cbdata);
@@ -2668,6 +2680,9 @@ void loc_tail_scan_forward_cb(loc_tail_cbdata_t *loc_tail_cbdata)
 	log_buf 	= &log->log_buf;
 	last_write 	= status->last_write;
 
+	if (be_status != 0)
+		goto err_exit;
+
 	/* re-init scanner sequence checking state since small logs can cause
 	a few records to be rescanned and re-init read buffer at tail
 	*/
@@ -2677,7 +2692,7 @@ void loc_tail_scan_forward_cb(loc_tail_cbdata_t *loc_tail_cbdata)
 	cbinfo->bc_cb = loc_tail_init_buf_cb1;
 
 	/* need to update status: init read buffer at head */
-	retval = init_buffer(log, &tail, FORWARD, NO_SYNCH);
+	retval = init_buffer(log, &tail, FORWARD, NO_SYNCH, cbinfo);
 
 	assert(log->trunc_thread == cthread_self());
 	assert((status->trunc_state & RVM_TRUNC_PHASES) == RVM_TRUNC_FIND_TAIL);
@@ -2687,6 +2702,8 @@ void loc_tail_scan_forward_cb(loc_tail_cbdata_t *loc_tail_cbdata)
 		msg_type 	= retval;
 	}
 
+	goto exit;
+err_exit:
 	rvm_utlsw 	   = loc_tail_cbdata->ltc_save_rvm_utlsw;
 	status->last_trunc = loc_tail_cbdata->ltc_save_last_trunc;
 
@@ -2698,6 +2715,7 @@ void loc_tail_scan_forward_cb(loc_tail_cbdata_t *loc_tail_cbdata)
                 m0_be_handler_post(cbinfo->bc_pcbinfo, be_status, msg_type);
                 m0_free(loc_tail_cbdata);
         }
+exit:;
 }
 
 void loc_tail_init_buf_loop_cb(struct m0_be_cbinfo *cbinfo, int be_status,
@@ -2723,6 +2741,9 @@ void loc_tail_init_buf_loop_cb(struct m0_be_cbinfo *cbinfo, int be_status,
 	log_buf 	= &log->log_buf;
 	last_write 	= status->last_write;
 
+	if (be_status != 0)
+		goto err_exit;
+
 	assert(log->trunc_thread == cthread_self());
 	assert((status->trunc_state & RVM_TRUNC_PHASES) == RVM_TRUNC_FIND_TAIL);
 
@@ -2755,8 +2776,7 @@ void loc_tail_init_buf_loop_cb(struct m0_be_cbinfo *cbinfo, int be_status,
 		status->wrap_time = rec_hdr->timestamp;
 
 	old_ptr = log_buf->ptr;
-
-	if ((retval = scan_forward(log, NO_SYNCH)) != RVM_SUCCESS) {
+	if ((retval = scan_forward(log, NO_SYNCH, cbinfo)) != RVM_SUCCESS) {
 		be_status = -1;
 		msg_type  = retval;
 
@@ -2781,7 +2801,7 @@ err_exit:
 	assert(log->trunc_thread == cthread_self());
 	assert((status->trunc_state & RVM_TRUNC_PHASES) == RVM_TRUNC_FIND_TAIL);
 
-	if (status != 0 && cbinfo->bc_pcbinfo!= NULL &&
+	if (be_status != 0 && cbinfo->bc_pcbinfo!= NULL &&
 	    cbinfo->bc_pcbinfo->bc_cb != NULL) {
                 m0_be_handler_post(cbinfo->bc_pcbinfo, be_status, msg_type);
                 m0_free(loc_tail_cbdata);
@@ -2866,17 +2886,15 @@ void loc_tail_init_buf_cb(struct m0_be_cbinfo *cbinfo, int be_status,
 			status->wrap_time = rec_hdr->timestamp;
 
 		old_ptr = log_buf->ptr;
+
 		cbinfo->bc_cb = loc_tail_init_buf_loop_cb;
-		if ((retval = scan_forward(log,NO_SYNCH)) != RVM_SUCCESS) {
+		retval = scan_forward(log, NO_SYNCH, cbinfo);
+		if (retval != RVM_SUCCESS) {
 			be_status = -1;
 			msg_type  = retval;
 			goto err_exit;
 		}
 	}
-
-	/* Need to remove this when scan_forward becomes async. */
-	loc_tail_init_buf_loop_cb(cbinfo, be_status, msg_type);
-
 	goto exit;
 
 status_valid:
@@ -2965,7 +2983,8 @@ struct m0_be_cbinfo *cbinfo;
         m0_be_cbinfo_copy_helper(cbinfo, ltc_cbinfo, loc_tail_init_buf_cb);
 
 	/* need to update status: init read buffer at head */
-	retval = init_buffer(log, &status->log_head, FORWARD, NO_SYNCH);
+	retval = init_buffer(log, &status->log_head, FORWARD, NO_SYNCH,
+			     ltc_cbinfo);
 
 	if (retval != RVM_SUCCESS) {
 		be_status	= -1;
@@ -2973,11 +2992,7 @@ struct m0_be_cbinfo *cbinfo;
 		goto err_exit;
 	}
 
-	/* Need to remove this when init_buffer becomes async. */
-        loc_tail_init_buf_cb(ltc_cbinfo, be_status, msg_type);
-
 	goto exit;
-
 err_exit:
 	rvm_utlsw 	   = save_rvm_utlsw;
 	status->last_trunc = loc_tail_cbdata->ltc_save_last_trunc;
@@ -3477,6 +3492,10 @@ M0_INTERNAL void cw_init_buffer_cb(struct m0_be_cbinfo *cbinfo,
 	log_buf_t       	*log_buf; 	/* log buffer descriptor. */
 
 	cw_cbdata = container_of(cbinfo, chk_wrap_cbdata_t, cwc_cbinfo);
+	M0_ASSERT(cw_cbdata != NULL);
+
+	if (be_status != 0)
+		goto exit;
 
 	log	= cw_cbdata->cwc_log;
 	status	= &log->status;
@@ -3487,6 +3506,7 @@ M0_INTERNAL void cw_init_buffer_cb(struct m0_be_cbinfo *cbinfo,
 	log_buf->ptr -= sizeof(rec_end_t);
 	log_buf->split_ok = rvm_true;
 
+exit:
 	if (cbinfo->bc_pcbinfo != NULL && cbinfo->bc_pcbinfo->bc_cb != NULL) {
                 m0_be_handler_post(cbinfo->bc_pcbinfo, be_status, msg_type);
         }
@@ -3509,6 +3529,10 @@ M0_INTERNAL void cw_scan_reverse_cb1(struct m0_be_cbinfo *cbinfo,
 	rvm_return_t    	 retval;             	/* return value */
 
 	cw_cbdata = container_of(cbinfo, chk_wrap_cbdata_t, cwc_cbinfo);
+	M0_ASSERT(cw_cbdata != NULL);
+
+	if (be_status != 0)
+		goto exit;
 
 	log	= cw_cbdata->cwc_log;
 	status	= &log->status;
@@ -3553,13 +3577,15 @@ M0_INTERNAL void cw_scan_reverse_cb1(struct m0_be_cbinfo *cbinfo,
 
 	cbinfo->bc_cb = cw_init_buffer_cb;
 
-	retval = init_buffer(log, &cw_cbdata->cwc_end_offset, REVERSE, SYNCH);
+	retval = init_buffer(log, &cw_cbdata->cwc_end_offset, REVERSE, SYNCH,
+			     cbinfo);
 
 	if (retval != RVM_SUCCESS) {
 		be_status = -1;
 		msg_type  = retval;
 	}
 
+exit:
 	if (be_status != 0 && cbinfo->bc_pcbinfo != NULL &&
 	    cbinfo->bc_pcbinfo->bc_cb != NULL) {
                 m0_be_handler_post(cbinfo->bc_pcbinfo, be_status, msg_type);
@@ -3581,6 +3607,10 @@ M0_INTERNAL void cw_scan_reverse_cb(struct m0_be_cbinfo *cbinfo,
 	chk_wrap_cbdata_t	*cw_cbdata;
 
 	cw_cbdata = container_of(cbinfo, chk_wrap_cbdata_t, cwc_cbinfo);
+	M0_ASSERT(cw_cbdata != NULL);
+
+	if (be_status != 0)
+		goto exit;
 
         log     = cw_cbdata->cwc_log;
         status  = &log->status;
@@ -3600,11 +3630,12 @@ M0_INTERNAL void cw_scan_reverse_cb(struct m0_be_cbinfo *cbinfo,
 	cbinfo->bc_cb = cw_scan_reverse_cb1;
 
 	/* now scan for first record of transaction */
-	if ((retval = scan_reverse(log, SYNCH)) != RVM_SUCCESS) {
+	if ((retval = scan_reverse(log, SYNCH, cbinfo)) != RVM_SUCCESS) {
 		be_status = -1;
 		msg_type  = retval;
 	}
 
+exit:
 	if (be_status != 0 && cbinfo->bc_pcbinfo != NULL &&
 	    cbinfo->bc_pcbinfo->bc_cb != NULL) {
                 m0_be_handler_post(cbinfo->bc_pcbinfo, be_status, msg_type);
@@ -3631,6 +3662,10 @@ M0_INTERNAL void cw_load_aux_buf_cb(struct m0_be_cbinfo *cbinfo,
 	rvm_bool_t		 post_parent = rvm_false;
 
 	cw_cbdata = container_of(cbinfo, chk_wrap_cbdata_t, cwc_cbinfo);
+	M0_ASSERT(cw_cbdata != NULL);
+
+	if (be_status != 0)
+		goto exit;
 
         log     = cw_cbdata->cwc_log;
         status  = &log->status;
@@ -3690,7 +3725,7 @@ M0_INTERNAL void cw_load_aux_buf_cb(struct m0_be_cbinfo *cbinfo,
 
 	cbinfo->bc_cb = cw_scan_reverse_cb;
 
-	if ((retval = scan_reverse(log, SYNCH)) != RVM_SUCCESS) {
+	if ((retval = scan_reverse(log, SYNCH, cbinfo)) != RVM_SUCCESS) {
 		be_status = -1;
 		msg_type  = retval;
 	}
@@ -3754,7 +3789,7 @@ static rvm_return_t chk_wrap(log, force_wrap_chk, skip_trans, cbinfo)
 		if (RVM_OFFSET_LSS(offset, log_buf->offset)) {
 			retval = load_aux_buf(log,&offset,sizeof(trans_hdr_t),
 					      &cw_cbdata->cwc_tmp_ptr, data_len,
-					      SYNCH, rvm_false);
+					      SYNCH, rvm_false, cwc_cbinfo);
 
 			if (retval != RVM_SUCCESS) {
 				be_status = -1;
-- 
1.8.3.2

