From 80d83eaaf544a76b80c7ac68c623383f8496db76 Mon Sep 17 00:00:00 2001
From: Zishan Shaikh <zishan_shaikh@xyratex.com>
Date: Mon, 6 May 2013 23:07:24 -0700
Subject: [PATCH 086/121] Added internal helper functions in cob.c and
 kvstore-ut to reduce LOC.

---
 be/ut/kv_store.c |  70 +++++++--------------
 cob/cob.c        | 188 +++++++++++++++++++++++++++----------------------------
 2 files changed, 112 insertions(+), 146 deletions(-)

diff --git a/be/ut/kv_store.c b/be/ut/kv_store.c
index 6e99dd9..36b0d71 100644
--- a/be/ut/kv_store.c
+++ b/be/ut/kv_store.c
@@ -125,7 +125,6 @@ void increment_count_ast_cb(struct m0_sm_group *sm_group, struct m0_sm_ast *ast)
 /** Callback function to be called after operation completion. */
 void init_operation_callback(void *operation_name, void *result, int rc)
 {
-        printf("init_kv_store pid = %x\n", (unsigned int)pthread_self());
         struct m0_be_usr_astinfo *astinfo;
         m0_free(operation_name);
 
@@ -312,6 +311,17 @@ void be_kv_ts_cb(struct m0_be_cbinfo *cbinfo, int status,
         }
 }
 
+static void __set_bt_cbdata()
+{
+        bt_cbdata->cbinfo.bc_cb       =  be_kv_ts_cb;
+        bt_cbdata->cbinfo.bc_sm_group =  sm_group;
+        bt_cbdata->cbinfo.bc_hq       = &kv_dom->bd_hq;
+        bt_cbdata->cbinfo.bc_pcbinfo  =  NULL;
+
+        M0_ALLOC_PTR(bt_cbdata->be_usr_ast);
+        bt_cbdata->be_usr_ast->bua_sm_group  = &usr_sm_group;
+}
+
 static void __initialise_handle1(enum m0_be_ks_init_mode init_mode)
 {
         kv_key_cmp_t             cmp_routine;
@@ -330,15 +340,6 @@ static void __initialise_handle1(enum m0_be_ks_init_mode init_mode)
 
         M0_ALLOC_PTR(bt_cbdata);
 
-        /* set cbinfo for tx_done. */
-        bt_cbdata->cbinfo.bc_cb              =  be_kv_ts_cb;
-        bt_cbdata->cbinfo.bc_sm_group        =  sm_group;
-        bt_cbdata->cbinfo.bc_hq              = &kv_dom->bd_hq;
-        bt_cbdata->cbinfo.bc_pcbinfo         =  NULL;
-
-        M0_ALLOC_PTR(bt_cbdata->be_usr_ast);
-        bt_cbdata->be_usr_ast->bua_sm_group  = &usr_sm_group;
-
         /* Initialise the kv store. */
         m0_be_ks_init_domain(&kv_dom, NULL, log_stob);
         M0_ASSERT(kv_dom != NULL);
@@ -365,14 +366,12 @@ static void __initialise_handle1(enum m0_be_ks_init_mode init_mode)
         M0_ALLOC_PTR(kv_seg);
         M0_ASSERT(kv_seg != NULL);
 
-        bt_cbdata->cbinfo.bc_cb        = be_kv_ts_cb;
-        bt_cbdata->cbinfo.bc_sm_group  = sm_group;
-        bt_cbdata->cbinfo.bc_hq        = &kv_dom->bd_hq;
-        bt_cbdata->cbinfo.bc_pcbinfo   = NULL;
-
-        M0_ALLOC_PTR(bt_cbdata->be_usr_ast);
+        /*
+         * Set the callback information to be called after segment
+         * creation/open completes.
+         */
+        __set_bt_cbdata();
         bt_cbdata->be_usr_ast->bua_ks_init_mode = init_mode;
-        bt_cbdata->be_usr_ast->bua_sm_group     = &usr_sm_group;
         bt_cbdata->be_usr_ast->bua_ast.sa_cb    = __init_kv_store1;
 
         if (init_mode == M0_BE_KS_CREATE) {
@@ -526,12 +525,7 @@ static int insert(struct m0_be_kv_store   *handle,
                 goto exit;
 
         /* set cbinfo for tx_done. */
-        bt_cbdata->cbinfo.bc_cb              =  be_kv_ts_cb;
-        bt_cbdata->cbinfo.bc_sm_group        =  sm_group;
-        bt_cbdata->cbinfo.bc_hq              = &kv_dom->bd_hq;
-        bt_cbdata->cbinfo.bc_pcbinfo         =  NULL;
-        M0_ALLOC_PTR(bt_cbdata->be_usr_ast);
-        bt_cbdata->be_usr_ast->bua_sm_group  = &usr_sm_group;
+        __set_bt_cbdata();
         bt_cbdata->be_usr_ast->bua_ast.sa_cb = increment_count_ast_cb;
 
         m0_be_tx_done(tx, &bt_cbdata->cbinfo);
@@ -614,12 +608,7 @@ static int delete(struct m0_be_kv_store *handle, struct m0_kv_store_obj *target)
         m0_be_free_helper(kv_dom, tx, target, sizeof *target);
 
         /* set cbinfo for tx_done. */
-        bt_cbdata->cbinfo.bc_cb              =  be_kv_ts_cb;
-        bt_cbdata->cbinfo.bc_sm_group        =  sm_group;
-        bt_cbdata->cbinfo.bc_hq              = &kv_dom->bd_hq;
-        bt_cbdata->cbinfo.bc_pcbinfo         =  NULL;
-        M0_ALLOC_PTR(bt_cbdata->be_usr_ast);
-        bt_cbdata->be_usr_ast->bua_sm_group  = &usr_sm_group;
+        __set_bt_cbdata();
         bt_cbdata->be_usr_ast->bua_ast.sa_cb = increment_count_ast_cb;
 
         m0_be_tx_done(tx, &bt_cbdata->cbinfo);
@@ -771,12 +760,7 @@ void test_kv_store_update()
                                      sizeof *ret_obj2[i], function_update);
 
                 /* set cbinfo for tx_done. */
-                bt_cbdata->cbinfo.bc_cb              =  be_kv_ts_cb;
-                bt_cbdata->cbinfo.bc_sm_group        =  sm_group;
-                bt_cbdata->cbinfo.bc_hq              = &kv_dom->bd_hq;
-                bt_cbdata->cbinfo.bc_pcbinfo         =  NULL;
-                M0_ALLOC_PTR(bt_cbdata->be_usr_ast);
-                bt_cbdata->be_usr_ast->bua_sm_group  = &usr_sm_group;
+                __set_bt_cbdata();
                 bt_cbdata->be_usr_ast->bua_ast.sa_cb = increment_count_ast_cb;
 
                 m0_be_tx_done(tx, &bt_cbdata->cbinfo);
@@ -861,13 +845,7 @@ static void ub_kv_insert()
         }
 
         /* set cbinfo for tx_done. */
-        /*M0_ALLOC_PTR(bt_cbdata);*/
-        bt_cbdata->cbinfo.bc_cb              =  be_kv_ts_cb;
-        bt_cbdata->cbinfo.bc_sm_group        =  sm_group;
-        bt_cbdata->cbinfo.bc_hq              = &kv_dom->bd_hq;
-        bt_cbdata->cbinfo.bc_pcbinfo         =  NULL;
-        M0_ALLOC_PTR(bt_cbdata->be_usr_ast);
-        bt_cbdata->be_usr_ast->bua_sm_group  = &usr_sm_group;
+        __set_bt_cbdata();
         bt_cbdata->be_usr_ast->bua_ast.sa_cb = increment_count_ast_cb;
 
         m0_be_tx_done(tx, &bt_cbdata->cbinfo);
@@ -960,13 +938,7 @@ static void ub_init(void)
                 object1[val]->obj_val = val;
 
                 /* set cbinfo for tx_done. */
-                /*M0_ALLOC_PTR(bt_cbdata);*/
-                bt_cbdata->cbinfo.bc_cb              =  be_kv_ts_cb;
-                bt_cbdata->cbinfo.bc_sm_group        =  sm_group;
-                bt_cbdata->cbinfo.bc_hq              = &kv_dom->bd_hq;
-                bt_cbdata->cbinfo.bc_pcbinfo         =  NULL;
-                M0_ALLOC_PTR(bt_cbdata->be_usr_ast);
-                bt_cbdata->be_usr_ast->bua_sm_group  = &usr_sm_group;
+                __set_bt_cbdata();
                 bt_cbdata->be_usr_ast->bua_ast.sa_cb = increment_count_ast_cb;
 
                 m0_be_tx_done(tx, &bt_cbdata->cbinfo);
diff --git a/cob/cob.c b/cob/cob.c
index e63b706..16a475a 100644
--- a/cob/cob.c
+++ b/cob/cob.c
@@ -59,16 +59,17 @@ struct m0_be_domain  *cob_be_domain = NULL;
 /** All user call backs are executed in caller context via this sm_group. */
 struct m0_sm_group    cob_sm_group;
 
-static void wait_and_lock_cob_sm_group()
+static void __cob_wait_and_lock_sm_group(struct m0_sm_group *in_group)
 {
-        m0_chan_wait(&cob_sm_group.s_clink);
+        m0_chan_wait(&in_group->s_clink);
 
-        m0_sm_group_lock(&cob_sm_group);
-        m0_sm_asts_run(&cob_sm_group);
-        m0_sm_group_unlock(&cob_sm_group);
+        m0_sm_group_lock(in_group);
+        m0_sm_asts_run(in_group);
+        m0_sm_group_unlock(in_group);
 }
 
-void __be_tx_done_ast_cb(struct m0_sm_group *sm_group, struct m0_sm_ast *ast)
+static void __cob_be_tx_done_ast_cb(struct m0_sm_group *sm_group,
+                                    struct m0_sm_ast   *ast)
 {
         struct m0_be_tx *tx;
 
@@ -78,8 +79,8 @@ void __be_tx_done_ast_cb(struct m0_sm_group *sm_group, struct m0_sm_ast *ast)
 }
 
 /** Called by m0_be_tx_done_cb at the very end of tx done termination. */
-void __be_tx_done_cb(struct m0_be_cbinfo *cbinfo, int status,
-                     m0_be_msg_type_t msg_type)
+static void __cob_be_tx_done_cb(struct m0_be_cbinfo *cbinfo, int status,
+                                m0_be_msg_type_t     msg_type)
 {
         struct m0_cob_be_cbinfo  *cob_cbinfo;
         struct m0_sm_ast         *ast;
@@ -96,6 +97,25 @@ void __be_tx_done_cb(struct m0_be_cbinfo *cbinfo, int status,
         m0_free(cob_cbinfo);
 }
 
+static void __cob_set_be_tx_done_cbinfo(struct m0_cob_be_cbinfo  *cob_cbinfo,
+                                        struct m0_be_cbinfo     **out_be_cbinfo,
+                                        struct m0_sm_group       *sm_group,
+                                        struct m0_be_tx          *be_tx)
+{
+        struct m0_be_cbinfo *be_cbinfo;
+
+        be_cbinfo               = &cob_cbinfo->cbc_cbinfo;
+        be_cbinfo->bc_hq        = &cob_be_domain->bd_hq;
+        be_cbinfo->bc_cb        =  __cob_be_tx_done_cb;
+        be_cbinfo->bc_sm_group  =  sm_group;
+        be_cbinfo->bc_pcbinfo   =  NULL;
+
+        cob_cbinfo->cbc_sm_group     = &cob_sm_group;
+        cob_cbinfo->cbc_ast.sa_cb    = __cob_be_tx_done_ast_cb;
+        cob_cbinfo->cbc_ast.sa_datum = (void *)be_tx;
+
+        *out_be_cbinfo = be_cbinfo;
+}
 
 /** Compare and match routines for kv_store. */
 M0_INTERNAL int m0_cob_kv_ns_cmp(void *in_obj1, void *in_obj2)
@@ -437,10 +457,10 @@ static char *cob_dom_id_make(char *buf, const struct m0_cob_domain_id *id,
 }
 
 #ifndef __KERNEL__
-void __kv_store_init_helper(struct m0_be_kv_store    **handle,
-                            struct m0_stob            *log_stob,
-                            int32_t                    handle_index,
-                            enum   m0_be_ks_init_mode  init_mode)
+static void __kv_store_init_helper(struct m0_be_kv_store    **handle,
+                                   struct m0_stob            *log_stob,
+                                   int32_t                    handle_index,
+                                   enum   m0_be_ks_init_mode  init_mode)
 {
         const  char             *stob_dir;
         const  char             *stob_file;
@@ -473,10 +493,10 @@ void __kv_store_init_helper(struct m0_be_kv_store    **handle,
         M0_ASSERT(*handle != NULL);
 }
 
-void __kv_init_operation_ast_cb(struct m0_sm_group *sm_group,
-                                struct m0_sm_ast *ast)
+static void __kv_init_operation_ast_cb(struct m0_sm_group *sm_group,
+                                       struct m0_sm_ast   *ast)
 {
-        printf("KV store initialised!!!!!");
+        M0_LOG(M0_INFO, "cob-nsrec kv-store init");
 }
 
 void cob_nsrec_kv_init_operation_cb(void *cbdata, void *result, int rc)
@@ -549,6 +569,39 @@ void cob_ns_kv_store_init(struct m0_be_cbinfo *cbinfo, int status,
         }
 }
 
+static void __cob_set_seg_cbinfo(struct m0_cob_be_cbinfo    *cob_cbinfo,
+                                 struct m0_be_kv_store      *handle,
+                                 struct m0_sm_group         *sm_group,
+                                 enum   m0_be_ks_init_mode   init_mode,
+                                 struct m0_be_cbinfo       **out_be_cbinfo)
+{
+        struct m0_be_cbinfo     *be_cbinfo;
+
+        /*
+         * This be_cbinfo will be used after segment creation completes.
+         * The function cob_ns_kv_store_init will be called in
+         * be_handler context.
+         */
+        be_cbinfo               = &cob_cbinfo->cbc_cbinfo;
+        be_cbinfo->bc_hq        = &cob_be_domain->bd_hq;
+        be_cbinfo->bc_cb        =  cob_ns_kv_store_init;
+        be_cbinfo->bc_sm_group  =  sm_group;
+        be_cbinfo->bc_pcbinfo   =  NULL;
+
+        /*
+         * This cbinfo will be used cob_ns_kv_store_init to post
+         * __ast_init_kv_store on cob_sm_group.After ast_post,the
+         * function __ast_init_kv_store will be called in caller
+         * context, not in be_handler context.
+         */
+        cob_cbinfo->cbc_sm_group     = &cob_sm_group;
+        cob_cbinfo->cbc_ast.sa_cb    = __ast_init_kv_store;
+        cob_cbinfo->cbc_ks_handle    = handle;
+        cob_cbinfo->cbc_ks_init_mode = M0_BE_KS_CREATE;
+
+        *out_be_cbinfo = be_cbinfo;
+}
+
 M0_INTERNAL
 int m0_cob_domain_init_nsrec_recovery(struct m0_cob_domain          *dom,
                                       struct m0_dbenv               *env,
@@ -569,43 +622,24 @@ int m0_cob_domain_init_nsrec_recovery(struct m0_cob_domain          *dom,
                  * Set the callback info to be called after segment
                  * creation operation.
                  */
+                m0_sm_group_init(&cob_sm_group);
                 sm_group = m0_be_domain_sm_group(cob_be_domain);
                 M0_ALLOC_PTR(cob_cbinfo);
                 M0_ASSERT(cob_cbinfo != NULL);
-                M0_ALLOC_PTR(kv_seg);
-                M0_ASSERT(kv_seg != NULL);
-
-                /*
-                 * This be_cbinfo will be used after segment opening completes.
-                 * The function cob_ns_kv_store_init will be called in
-                 * be_handler context.
-                 */
-                be_cbinfo               = &cob_cbinfo->cbc_cbinfo;
-                be_cbinfo->bc_hq        = &cob_be_domain->bd_hq;
-                be_cbinfo->bc_cb        =  cob_ns_kv_store_init;
-                be_cbinfo->bc_sm_group  =  sm_group;
-                be_cbinfo->bc_pcbinfo   =  NULL;
 
-                /*
-                 * This cbinfo will be used cob_ns_kv_store_init to post
-                 * __ast_init_kv_store on cob_sm_group.After ast_post,the
-                 * function __ast_init_kv_store will be called in caller
-                 * context, not in be_handler context.
-                 */
-                m0_sm_group_init(&cob_sm_group);
-                cob_cbinfo->cbc_sm_group     = &cob_sm_group;
-                cob_cbinfo->cbc_ast.sa_cb    = __ast_init_kv_store;
-                cob_cbinfo->cbc_ks_handle    = dom->cd_kvnamespace;
-                cob_cbinfo->cbc_ks_init_mode = M0_BE_KS_RECOVER;
+                __cob_set_seg_cbinfo(cob_cbinfo, dom->cd_kvnamespace, sm_group,
+                                     M0_BE_KS_RECOVER, &be_cbinfo);
 
+                M0_ALLOC_PTR(kv_seg);
+                M0_ASSERT(kv_seg != NULL);
                 m0_be_domain_seg_restore(cob_be_domain, BE_KV_SEG_NAME, kv_seg,
                                          be_cbinfo);
 
                 /* Wait for segment open. */
-                wait_and_lock_cob_sm_group();
+                __cob_wait_and_lock_sm_group(&cob_sm_group);
 
                 /* Wait for handle initialisation. */
-                wait_and_lock_cob_sm_group();
+                __cob_wait_and_lock_sm_group(&cob_sm_group);
         }
 
         return m0_cob_domain_init(dom, env, id);
@@ -649,43 +683,23 @@ int m0_cob_domain_init(struct m0_cob_domain *dom, struct m0_dbenv *env,
                  * Set the callback info to be called after segment
                  * creation operation.
                  */
+                m0_sm_group_init(&cob_sm_group);
                 sm_group = m0_be_domain_sm_group(cob_be_domain);
                 M0_ALLOC_PTR(cob_cbinfo);
                 M0_ASSERT(cob_cbinfo != NULL);
+                __cob_set_seg_cbinfo(cob_cbinfo, dom->cd_kvnamespace, sm_group,
+                                     M0_BE_KS_CREATE, &be_cbinfo);
+
                 M0_ALLOC_PTR(kv_seg);
                 M0_ASSERT(kv_seg != NULL);
-
-                /*
-                 * This be_cbinfo will be used after segment creation completes.
-                 * The function cob_ns_kv_store_init will be called in
-                 * be_handler context.
-                 */
-                be_cbinfo               = &cob_cbinfo->cbc_cbinfo;
-                be_cbinfo->bc_hq        = &cob_be_domain->bd_hq;
-                be_cbinfo->bc_cb        =  cob_ns_kv_store_init;
-                be_cbinfo->bc_sm_group  =  sm_group;
-                be_cbinfo->bc_pcbinfo   =  NULL;
-
-                /*
-                 * This cbinfo will be used cob_ns_kv_store_init to post
-                 * __ast_init_kv_store on cob_sm_group.After ast_post,the
-                 * function __ast_init_kv_store will be called in caller
-                 * context, not in be_handler context.
-                 */
-                m0_sm_group_init(&cob_sm_group);
-                cob_cbinfo->cbc_sm_group     = &cob_sm_group;
-                cob_cbinfo->cbc_ast.sa_cb    = __ast_init_kv_store;
-                cob_cbinfo->cbc_ks_handle    = dom->cd_kvnamespace;
-                cob_cbinfo->cbc_ks_init_mode = M0_BE_KS_CREATE;
-
                 m0_be_seg_init(kv_seg, cob_be_domain, sm_group, 0);
                 m0_be_seg_create(kv_seg, NULL, BE_KV_SEG_NAME, NULL, be_cbinfo);
 
                 /* Wait for segment creation. */
-                wait_and_lock_cob_sm_group();
+                __cob_wait_and_lock_sm_group(&cob_sm_group);
 
                 /* Wait for handle initialisation. */
-                wait_and_lock_cob_sm_group();
+                __cob_wait_and_lock_sm_group(&cob_sm_group);
         }
 #endif
 
@@ -1671,18 +1685,11 @@ M0_INTERNAL int m0_cob_update(struct m0_cob *cob,
                 /* Set the callback information for tx_done. */
                 M0_ALLOC_PTR(cob_cbinfo);
                 M0_ASSERT(cob_cbinfo != NULL);
-                be_cbinfo               = &cob_cbinfo->cbc_cbinfo;
-                be_cbinfo->bc_hq        = &cob_be_domain->bd_hq;
-                be_cbinfo->bc_cb        =  __be_tx_done_cb;
-                be_cbinfo->bc_sm_group  =  sm_group;
-                be_cbinfo->bc_pcbinfo   =  NULL;
-
-                cob_cbinfo->cbc_sm_group     = &cob_sm_group;
-                cob_cbinfo->cbc_ast.sa_cb    = __be_tx_done_ast_cb;
-                cob_cbinfo->cbc_ast.sa_datum = (void *)be_tx;
+                __cob_set_be_tx_done_cbinfo(cob_cbinfo, &be_cbinfo, sm_group,
+                                            be_tx);
 
                 m0_be_tx_done(be_tx, be_cbinfo);
-                wait_and_lock_cob_sm_group();
+                __cob_wait_and_lock_sm_group(&cob_sm_group);
 
                 if (rc != 0)
                         goto out;
@@ -1792,19 +1799,12 @@ M0_INTERNAL int m0_cob_name_add(struct m0_cob *cob,
 
         M0_ALLOC_PTR(cob_cbinfo);
         M0_ASSERT(cob_cbinfo != NULL);
-        be_cbinfo               = &cob_cbinfo->cbc_cbinfo;
-        be_cbinfo->bc_hq        = &cob_be_domain->bd_hq;
-        be_cbinfo->bc_cb        =  __be_tx_done_cb;
-        be_cbinfo->bc_sm_group  =  sm_group;
-        be_cbinfo->bc_pcbinfo   =  NULL;
-
-        cob_cbinfo->cbc_sm_group     = &cob_sm_group;
-        cob_cbinfo->cbc_ast.sa_cb    = __be_tx_done_ast_cb;
-        cob_cbinfo->cbc_ast.sa_datum = (void *)be_tx;
 
+        /* Set the callback information for tx_done. */
+        __cob_set_be_tx_done_cbinfo(cob_cbinfo, &be_cbinfo, sm_group, be_tx);
 
         m0_be_tx_done(be_tx, be_cbinfo);
-        wait_and_lock_cob_sm_group();
+        __cob_wait_and_lock_sm_group(&cob_sm_group);
 #endif
 out:
         M0_ADDB_ADD(&cob->co_dom->cd_addb, &cob_addb_loc,
@@ -1875,18 +1875,12 @@ M0_INTERNAL int m0_cob_name_del(struct m0_cob *cob,
 
         M0_ALLOC_PTR(cob_cbinfo);
         M0_ASSERT(cob_cbinfo != NULL);
-        be_cbinfo               = &cob_cbinfo->cbc_cbinfo;
-        be_cbinfo->bc_hq        = &cob_be_domain->bd_hq;
-        be_cbinfo->bc_cb        =  __be_tx_done_cb;
-        be_cbinfo->bc_sm_group  =  sm_group;
-        be_cbinfo->bc_pcbinfo   =  NULL;
-
-        cob_cbinfo->cbc_sm_group     = &cob_sm_group;
-        cob_cbinfo->cbc_ast.sa_cb    = __be_tx_done_ast_cb;
-        cob_cbinfo->cbc_ast.sa_datum = (void *)be_tx;
 
+        /* Set the callback information for tx_done. */
+        __cob_set_be_tx_done_cbinfo(cob_cbinfo, &be_cbinfo, sm_group, be_tx);
         m0_be_tx_done(be_tx, be_cbinfo);
-        wait_and_lock_cob_sm_group();
+        __cob_wait_and_lock_sm_group(&cob_sm_group);
+
         cob->co_pair = NULL;
 #endif
         /*
-- 
1.8.3.2

