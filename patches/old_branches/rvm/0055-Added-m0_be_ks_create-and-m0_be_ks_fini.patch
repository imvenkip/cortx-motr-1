From 888e08df8b15a92fa6207f78782e3e405e9236de Mon Sep 17 00:00:00 2001
From: Zishan Shaikh <zishan_shaikh@xyratex.com>
Date: Thu, 21 Feb 2013 23:56:29 -0800
Subject: [PATCH 055/121] Added m0_be_ks_create and m0_be_ks_fini

---
 be/helper.c           |  12 --
 be/helper.h           |  19 +--
 be/kv_store.c         | 311 +++++++++++++++++++++++++++-----------------------
 be/kv_store.h         | 111 +++++++++---------
 be/kv_store_private.h | 130 +++++++++++++++++++++
 be/ut/kv_store.c      |  15 ++-
 be/ut/kv_store_ub.c   |  15 ++-
 7 files changed, 371 insertions(+), 242 deletions(-)
 create mode 100644 be/kv_store_private.h

diff --git a/be/helper.c b/be/helper.c
index 712dc32..a2bf281 100644
--- a/be/helper.c
+++ b/be/helper.c
@@ -94,18 +94,6 @@ exit_malloc:
 }
 M0_EXPORTED(m0_be_ks_obj_malloc);
 
-M0_INTERNAL void m0_be_ks_fini(struct m0_be_domain *dom, struct m0_be_seg *seg)
-{
-        M0_ENTRY();
-        m0_be_seg_done(seg);
-        dom->bd_data.bs_sm.sm_state = M0_BESEG_CLOSED;
-        rvm_truncate();
-        m0_be_domain_fini(dom);
-        m0_free(dom);
-        M0_LEAVE();
-}
-M0_EXPORTED(m0_be_ks_fini);
-
 M0_INTERNAL void m0_be_ks_prep_link_reg(struct m0_be_domain    *dom,
                                         struct m0_list_link    *link,
                                         struct m0_be_tx        *tx,
diff --git a/be/helper.h b/be/helper.h
index e33ccf4..4b33e4f 100644
--- a/be/helper.h
+++ b/be/helper.h
@@ -27,6 +27,8 @@
 #include "lib/list.h"
 #include "mero/magic.h"
 
+#define BE_KV_SEG_NAME "kv_store"
+
 /**
   @defgroup helper Helper Routines
 
@@ -53,25 +55,8 @@ enum {
 /**
   Segment name used for kv_store objects.
  */
-#define BE_KV_SEG_NAME "kv_store"
 M0_INTERNAL void m0_be_ks_init_domain(struct m0_be_domain  **out_dom);
 
-M0_INTERNAL void m0_be_ks_fini(struct m0_be_domain *dom, struct m0_be_seg *seg);
-
-/**
-  Tries to open a segment with @segid.
-  Used while recovery of kv store handle.
-
-  @param dom    :       domain to lookup in.
-  @param seg    :       segment to be returned.
-  @param name   :       name of the segment to be looked up.
-  @retval BE_KV_FAILURE :       on failure to open a segment.
-  @return BE_KV_SUCCESS :       on successful restore of segment.
- */
-M0_INTERNAL bool m0_be_ks_restore(struct m0_be_domain *dom,
-                                  struct m0_be_seg    *seg,
-                                  char                *name);
-
 /**
   Allocates memory to an object.
 
diff --git a/be/kv_store.c b/be/kv_store.c
index f5e8aeb..594740f 100644
--- a/be/kv_store.c
+++ b/be/kv_store.c
@@ -26,46 +26,13 @@
 #include "be/be_buf.h"
 #include "be/helper.h"
 #include "be/handler.h"
+#include "be/kv_store_private.h"
 #include <string.h>
 
 /**
    @addtogroup be_kv_store
    @{
  */
-
-/**
-  Gives the linkage of the previous object for current. The previous pointer is
-  updated in @link_prev.
- */
-static void __ks_get_prev(struct m0_tl_descr   *d,
-                          void                 *current,
-                          struct m0_list_link **link_prev);
-
-/**
-  Gives the linkage of the next object for current. The next pointer is
-  updated in @link_next.
- */
-static void __ks_get_next(struct m0_tl_descr   *d,
-                          void                 *current,
-                          struct m0_list_link **link_next);
-
-/**
-  Gives the linkage of the current object. The pointer is updated in
-  @link_current.
- */
-static void __ks_get_current(struct m0_tl_descr   *d,
-                             void                 *current,
-                             struct m0_list_link **link_cuurent);
-
-/**
-  Adds or captures the regions of the current, next & previous pointers of
-  @current object, depending upon @in_tx_state.
- */
-static void __ks_prev_next_add_cred(struct m0_be_kv_store     *handle,
-                                    struct m0_be_tx           *tx,
-                                    void                      *current,
-                                    int                        operation);
-
 static const struct m0_sm_state_descr m0_be_ks_op_states[] = {
         [M0_BEKSOP_INIT] = {
                 .sd_flags     = M0_SDF_INITIAL,
@@ -99,6 +66,11 @@ static const struct m0_sm_state_descr m0_be_ks_states[] = {
         [M0_BEKS_INIT] = {
                 .sd_flags     = M0_SDF_INITIAL,
                 .sd_name      = "KS Init",
+                .sd_allowed   = M0_BITS(M0_BEKS_CREATED)
+        },
+        [M0_BEKS_CREATED] = {
+                .sd_flags     = 0,
+                .sd_name      = "KS Created",
                 .sd_allowed   = M0_BITS(M0_BEKS_INPROGRESS)
         },
         [M0_BEKS_INPROGRESS] = {
@@ -119,147 +91,116 @@ static const struct m0_sm_conf m0_be_ks_conf = {
         .scf_state     = m0_be_ks_states
 };
 
-M0_INTERNAL void m0_be_ks_create_handle(struct m0_be_ks_opdata *bk_opdata)
+M0_INTERNAL void m0_be_ks_create(struct m0_tl_descr      *descr,
+                                 struct m0_be_domain     *dom,
+                                 kv_key_cmp_t             cmp_fp,
+                                 kv_key_match_t           match_fp,
+                                 struct m0_be_kv_store  **handle)
 {
-        struct m0_be_tx             *tx;
-        struct m0_be_reg            *rvm_handle_reg;
-        struct m0_be_reference      *rvm_handle_ref;
-        struct m0_be_kv_store_rvm   *rvm_handle;
-        struct m0_sm_group          *sm_group;
-        struct m0_be_seg            *rvm_handle_seg;
-        struct m0_be_domain         *dom;
-        struct m0_be_kv_store       *handle;
-        struct m0_tl_descr          *descr;
-        struct m0_be_hs_opdata      *bh_opdata;
-        struct m0_be_buf            *rvm_handle_buf;
-
-        M0_ENTRY();
-
-        handle         = *bk_opdata->bko_handle;
-        dom            = handle->ks_handle_heap.ksh_dom;
-        descr          = handle->ks_handle_heap.ksh_list_descr;
-        rvm_handle_seg = bk_opdata->bko_seg;
-
-        M0_ASSERT(dom    != NULL);
-        M0_ASSERT(descr  != NULL);
-        M0_ASSERT(handle != NULL);
-        M0_ASSERT(rvm_handle_seg != NULL);
+        struct m0_sm_group *sm_group;
 
-        M0_ALLOC_PTR(tx);
-        M0_ASSERT(tx != NULL);
+        M0_ENTRY("dom: %p, descr: %p", dom, descr);
 
-        M0_ALLOC_PTR(rvm_handle_buf);
-        M0_ASSERT(rvm_handle_buf != NULL);
+        M0_ALLOC_PTR(*handle);
+        M0_ASSERT(*handle != NULL);
 
         sm_group = m0_be_domain_sm_group(dom);
 
-        m0_be_tx_init(tx, dom, 0);
-
-        /* Prepare a region for the rvm_handle. */
-        M0_ALLOC_PTR(rvm_handle_reg);
-        M0_ASSERT(rvm_handle_reg != NULL);
-
-        rvm_handle_buf->b_nob = sizeof *rvm_handle;
-        m0_be_reg_init(rvm_handle_reg, tx, rvm_handle_seg, rvm_handle_buf);
-
-        m0_be_tx_start(tx);
-
-        rvm_handle = (struct m0_be_kv_store_rvm *)
-                      m0_be_ks_obj_malloc(rvm_handle_reg, &rvm_handle_ref);
-
-        (*bk_opdata->bko_handle)->ks_handle_rvm = rvm_handle;
-
-        M0_ASSERT(rvm_handle != NULL);
-        M0_ASSERT(rvm_handle_ref != NULL);
-
-        /*
-         * Store this handle information at index 0 in handle_store
-         */
-        M0_ALLOC_PTR(bh_opdata);
-        M0_ASSERT(bh_opdata != NULL);
-
-        /*
-         * Set the call back data and call back function
-         * to be called after m0_be_hs_update completion
-         */
-        bk_opdata->bko_tx               = tx;
-        bk_opdata->bko_buf              = rvm_handle_buf;
-        bk_opdata->bko_reg              = rvm_handle_reg;
+        /* Set the non_rvm part of the handle with user values */
+        (*handle)->ks_handle_heap = (struct m0_be_kv_store_heap){
+                .ksh_key_cmp      = cmp_fp,
+                .ksh_key_match    = match_fp,
+                .ksh_list_descr   = descr,
+                .ksh_dom          = dom
+        };
 
         /*
-         * Prepare call back data and function to be used by
-         * m0_be_hs_update() and its callback routine
+         * Initialise kv-store sm with CREATED state and then mark it as
+         * initialised
          */
-        bh_opdata->bho_index            = 0;
-        bh_opdata->bho_segid_offset     = &rvm_handle_ref->be_segid_offset;
-        bh_opdata->bho_seg              = rvm_handle_seg;
-
-        m0_be_hs_update(bh_opdata);
+        m0_sm_group_lock(sm_group);
+        m0_sm_init(&(*handle)->ks_handle_heap.ksh_sm, &m0_be_ks_conf,
+                   M0_BEKS_INIT, sm_group, NULL);
+        m0_sm_state_set(&(*handle)->ks_handle_heap.ksh_sm, M0_BEKS_CREATED);
+        m0_sm_group_unlock(sm_group);
 
-        m0_sm_enqueue_post(sm_group, bk_opdata, m0_be_ksi_hs_cb);
-        M0_LEAVE();
+        M0_LEAVE("handle: %p, dom: %p, descr: %p", *handle, dom, descr);
 }
+M0_EXPORTED(m0_be_ks_create);
 
-M0_INTERNAL void m0_be_ks_init(struct m0_be_kv_store **handle,
-                               struct m0_tl_descr     *descr,
-                               struct m0_be_domain    *dom,
-                               kv_key_cmp_t            cmp_fp,
-                               kv_key_match_t          match_fp,
+M0_INTERNAL void m0_be_ks_init(struct m0_be_kv_store  *handle,
                                char                   *mode)
 {
         struct m0_sm_group         *sm_group;
         struct m0_be_seg           *rvm_handle_seg = NULL;
-
         struct m0_be_ks_opdata     *bk_opdata;
-
-        M0_ENTRY("dom: %p, descr: %p", dom, descr);
-
-        if (*handle == NULL) {
-                M0_ALLOC_PTR(*handle);
-                M0_ASSERT(*handle != NULL);
-        }
+        struct m0_tl_descr         *descr;
+        struct m0_be_domain        *dom;
+        kv_key_cmp_t                cmp_fp;
+        kv_key_match_t              match_fp;
+
+        M0_ENTRY("handle: %p mode: %s", handle, mode);
+        M0_PRE(m0_be_ks_get_handle_state(handle) == M0_BEKS_CREATED);
+
+        descr    = handle->ks_handle_heap.ksh_list_descr;
+        dom      = handle->ks_handle_heap.ksh_dom;
+        cmp_fp   = handle->ks_handle_heap.ksh_key_cmp;
+        match_fp = handle->ks_handle_heap.ksh_key_match;
+        sm_group = m0_be_domain_sm_group(dom);
 
         M0_ALLOC_PTR(bk_opdata);
         M0_ASSERT(bk_opdata != NULL);
 
-        /* Set the non_rvm part of the handle with user values */
-        (*handle)->ks_handle_heap = (struct m0_be_kv_store_heap){
-                .ksh_key_cmp    = cmp_fp,
-                .ksh_key_match  = match_fp,
-                .ksh_list_descr = descr,
-                .ksh_dom        = dom
-        };
-
-        sm_group = m0_be_domain_sm_group(dom);
+        M0_ALLOC_PTR(rvm_handle_seg);
+        M0_ASSERT(rvm_handle_seg != NULL);
 
+        /* Mark key store initialisation as in progress */
         m0_sm_group_lock(sm_group);
-        m0_sm_init(&(*handle)->ks_handle_heap.ksh_sm, &m0_be_ks_conf,
-                   M0_BEKS_INIT, sm_group, NULL);
-        m0_sm_state_set(&(*handle)->ks_handle_heap.ksh_sm, M0_BEKS_INPROGRESS);
+        m0_sm_state_set(&handle->ks_handle_heap.ksh_sm, M0_BEKS_INPROGRESS);
         m0_sm_group_unlock(sm_group);
 
-        M0_ALLOC_PTR(rvm_handle_seg);
-        M0_ASSERT(rvm_handle_seg != NULL);
-
         if (strcasecmp(mode, "recover") == 0) {
                 /* Try to restore (open) the segment in @dom */
                 m0_be_domain_seg_restore(dom, BE_KV_SEG_NAME, rvm_handle_seg);
         } else {
                 /* Create a new segment */
                 /* @todo: segment name is hardcoded for now */
-
                 m0_be_seg_init(rvm_handle_seg, dom, sm_group, 0);
                 m0_be_seg_create(rvm_handle_seg, NULL, BE_KV_SEG_NAME,
                                  NULL);
         }
+
         /* Prepare call back data */
         bk_opdata->bko_handle   = handle;
         bk_opdata->bko_ksi_mode = mode;
         bk_opdata->bko_seg      = rvm_handle_seg;
         m0_sm_enqueue_post(sm_group, bk_opdata, m0_be_ksi_handle_cb);
+        M0_LEAVE("handle: %p", handle);
 }
 M0_EXPORTED(m0_be_ks_init);
 
+M0_INTERNAL void m0_be_ks_fini(struct m0_be_kv_store *handle,
+                               struct m0_be_seg      *seg)
+{
+        struct m0_be_domain *dom;
+
+        M0_ENTRY();
+        M0_PRE(m0_be_ks_get_handle_state(handle) == M0_BEKS_DONE);
+
+        dom = handle->ks_handle_heap.ksh_dom;
+
+        m0_be_seg_done(seg);
+        dom->bd_data.bs_sm.sm_state = M0_BESEG_CLOSED;
+
+        rvm_truncate();
+
+        m0_be_domain_fini(dom);
+        m0_free(dom);
+        m0_free(handle);
+        M0_LEAVE();
+}
+M0_EXPORTED(m0_be_ks_fini);
+
 M0_INTERNAL struct m0_list_link
 *m0_be_ks_get_next_val(struct m0_be_kv_store *handle, void *obj)
 {
@@ -420,9 +361,9 @@ M0_INTERNAL int32_t __ks_tlist_add_at_tail(struct m0_be_kv_store     *handle,
         return BE_KV_SUCCESS;
 }
 
-M0_INTERNAL int32_t m0_be_ks_insert(struct m0_be_kv_store      *handle,
-                                    struct m0_be_reference     *obj_ref,
-                                    struct m0_be_tx            *tx)
+M0_INTERNAL int32_t m0_be_ks_insert(struct m0_be_kv_store   *handle,
+                                    struct m0_be_reference  *obj_ref,
+                                    struct m0_be_tx         *tx)
 {
         struct m0_be_reg        *obj_link_reg;
         struct m0_be_domain     *dom;
@@ -436,7 +377,7 @@ M0_INTERNAL int32_t m0_be_ks_insert(struct m0_be_kv_store      *handle,
         void                    *new;
         int32_t                  ret_val       = BE_KV_INVALID_REQ;
 
-        M0_ENTRY("obj_ref: %p", obj_ref);
+        M0_ENTRY("handle: %p obj:%p", handle, obj_ref->be_virtual_address);
         M0_ASSERT(tx != NULL);
 
         ks_list_descr = handle->ks_handle_heap.ksh_list_descr;
@@ -684,7 +625,7 @@ M0_INTERNAL void m0_be_ksi_handle_cb(void *cb_data)
 
         bk_opdata = (struct m0_be_ks_opdata *)cb_data;
 
-        handle = *bk_opdata->bko_handle;
+        handle = bk_opdata->bko_handle;
         seg    = bk_opdata->bko_seg;
         mode   = bk_opdata->bko_ksi_mode;
         dom    = handle->ks_handle_heap.ksh_dom;
@@ -702,7 +643,7 @@ M0_INTERNAL void m0_be_ksi_handle_cb(void *cb_data)
 
         /* Create handle */
         if (ret_val == false && strcasecmp(mode, "create") == 0) {
-                m0_be_ks_create_handle(cb_data);
+                __ks_create_handle(cb_data);
                 goto exit;
         }
 
@@ -725,9 +666,9 @@ M0_INTERNAL void m0_be_ksi_hs_cb(void *cb_data)
 
         bk_opdata  = (struct m0_be_ks_opdata *)cb_data;
         tx         = bk_opdata->bko_tx;
-        descr      = (*bk_opdata->bko_handle)->ks_handle_heap.ksh_list_descr;
-        rvm_handle = (*bk_opdata->bko_handle)->ks_handle_rvm;
-        dom        = (*bk_opdata->bko_handle)->ks_handle_heap.ksh_dom;
+        descr      = bk_opdata->bko_handle->ks_handle_heap.ksh_list_descr;
+        rvm_handle = bk_opdata->bko_handle->ks_handle_rvm;
+        dom        = bk_opdata->bko_handle->ks_handle_heap.ksh_dom;
 
         M0_ASSERT(tx          != NULL);
         M0_ASSERT(descr       != NULL);
@@ -786,7 +727,7 @@ M0_INTERNAL void m0_be_ksi_init_done(void *cb_data)
 
         bk_opdata = (struct m0_be_ks_opdata *)cb_data;
 
-        handle = *bk_opdata->bko_handle;
+        handle = bk_opdata->bko_handle;
         dom    = handle->ks_handle_heap.ksh_dom;
 
         M0_ASSERT(handle != NULL);
@@ -802,6 +743,92 @@ M0_INTERNAL void m0_be_ksi_init_done(void *cb_data)
         M0_LEAVE();
 }
 
+M0_INTERNAL void __ks_create_handle(struct m0_be_ks_opdata *bk_opdata)
+{
+        struct m0_be_tx             *tx;
+        struct m0_be_reg            *rvm_handle_reg;
+        struct m0_be_reference      *rvm_handle_ref;
+        struct m0_be_kv_store_rvm   *rvm_handle;
+        struct m0_sm_group          *sm_group;
+        struct m0_be_seg            *rvm_handle_seg;
+        struct m0_be_domain         *dom;
+        struct m0_be_kv_store       *handle;
+        struct m0_tl_descr          *descr;
+        struct m0_be_hs_opdata      *bh_opdata;
+        struct m0_be_buf            *rvm_handle_buf;
+
+        M0_ENTRY();
+
+        handle         = bk_opdata->bko_handle;
+        dom            = handle->ks_handle_heap.ksh_dom;
+        descr          = handle->ks_handle_heap.ksh_list_descr;
+        rvm_handle_seg = bk_opdata->bko_seg;
+
+        M0_ASSERT(dom    != NULL);
+        M0_ASSERT(descr  != NULL);
+        M0_ASSERT(handle != NULL);
+        M0_ASSERT(rvm_handle_seg != NULL);
+
+        M0_ALLOC_PTR(tx);
+        M0_ASSERT(tx != NULL);
+
+        M0_ALLOC_PTR(rvm_handle_buf);
+        M0_ASSERT(rvm_handle_buf != NULL);
+
+        sm_group = m0_be_domain_sm_group(dom);
+
+        m0_be_tx_init(tx, dom, 0);
+
+        /* Prepare a region for the rvm_handle. */
+        M0_ALLOC_PTR(rvm_handle_reg);
+        M0_ASSERT(rvm_handle_reg != NULL);
+
+        rvm_handle_buf->b_nob = sizeof *rvm_handle;
+        m0_be_reg_init(rvm_handle_reg, tx, rvm_handle_seg, rvm_handle_buf);
+
+        m0_be_tx_start(tx);
+
+        rvm_handle = (struct m0_be_kv_store_rvm *)
+                      m0_be_ks_obj_malloc(rvm_handle_reg, &rvm_handle_ref);
+
+        bk_opdata->bko_handle->ks_handle_rvm = rvm_handle;
+
+        M0_ASSERT(rvm_handle != NULL);
+        M0_ASSERT(rvm_handle_ref != NULL);
+
+        /*
+         * Store this handle information at index 0 in handle_store
+         */
+        M0_ALLOC_PTR(bh_opdata);
+        M0_ASSERT(bh_opdata != NULL);
+
+        /*
+         * Set the call back data and call back function
+         * to be called after m0_be_hs_update completion
+         */
+        bk_opdata->bko_tx               = tx;
+        bk_opdata->bko_buf              = rvm_handle_buf;
+        bk_opdata->bko_reg              = rvm_handle_reg;
+
+        /*
+         * Prepare call back data and function to be used by
+         * m0_be_hs_update() and its callback routine
+         */
+        bh_opdata->bho_index            = 0;
+        bh_opdata->bho_segid_offset     = &rvm_handle_ref->be_segid_offset;
+        bh_opdata->bho_seg              = rvm_handle_seg;
+
+        m0_be_hs_update(bh_opdata);
+
+        m0_sm_enqueue_post(sm_group, bk_opdata, m0_be_ksi_hs_cb);
+        M0_LEAVE();
+}
+
+M0_INTERNAL enum m0_be_ks_state
+m0_be_ks_get_handle_state(struct m0_be_kv_store *handle)
+{
+        return handle->ks_handle_heap.ksh_sm.sm_state;
+}
 #undef M0_TRACE_SUBSYSTEM
 /* @} end of kv_store group */
 
diff --git a/be/kv_store.h b/be/kv_store.h
index 84d7a4b..9ea8915 100644
--- a/be/kv_store.h
+++ b/be/kv_store.h
@@ -21,9 +21,9 @@
 #ifndef __MERO_BE_KV_STORE_H__
 #define __MERO_BE_KV_STORE_H__
 
+#include "lib/tlist.h"
 #include "be/be.h"
 #include "be/tx.h"
-#include "lib/tlist.h"
 
 /**
    @defgroup kv_store Key Value Store
@@ -77,9 +77,18 @@
 
        cmp_routine   = &function_compare;
        match_routine = &function_match(void *, void *);
-       status = m0_be_ks_init(handle, list_descr, dom, cmp_routine,
-                              match_routine, mode);
-       M0_ASSERT(status == true);
+
+       m0_be_ks_create(&kv_list_descr, kv_dom,
+                       cmp_routine, match_routine, &handle);
+       M0_ASSERT(handle != NULL);
+
+       sm_group = m0_be_domain_sm_group(kv_dom);
+
+       m0_be_ks_init(handle, "create");
+       m0_be_wait(sm_group, &handle->ks_handle_heap.ksh_sm,
+                  M0_BITS(M0_BEKS_DONE));
+
+       M0_ASSERT(handle->ks_handle_rvm != NULL);
        @endcode
 
    Insertion:
@@ -179,7 +188,7 @@ struct m0_be_ks_opdata {
         /* key value store state machine */
         struct m0_sm             bko_sm;
         /* Actual kv-store handle */
-        struct m0_be_kv_store  **bko_handle;
+        struct m0_be_kv_store   *bko_handle;
         /* Segment used as input to hs_update */
         struct m0_be_seg        *bko_seg;
         /* Region on which handle is created */
@@ -197,6 +206,7 @@ struct m0_be_ks_opdata {
  */
 enum m0_be_ks_state {
         M0_BEKS_INIT,
+        M0_BEKS_CREATED,
         M0_BEKS_INPROGRESS,
         M0_BEKS_DONE
 };
@@ -212,13 +222,30 @@ enum m0_be_ks_op_state {
 };
 
 /**
-  Creates the persistent part of key value store handle.
-  Called by m0_be_ks_init indirectly if ks-init mode is create.
+  Create a key value store handle with the specified paramaters.
+  It will initialise the kv-store with heap values that need not be
+  made persistent.
+
+  @param descr         :       the tlist descriptor to be given to the tlist in
+                               kv_store.
+  @param dom           :       the domain pointer to be given to the handle.
+  @param cmp_fp        :       user defined function to compare keys.
+  @param match_fp      :       user defined function to match keys,
+                               allowed modes: CREATE/RECOVER or create/recover.
+  @param handle        :       pointer to the handle to be created and returned.
+
+  @retval true         :       upon succesful  initialisation/recovery.
+  @retval false        :       upon failure to initialise/recover kv_store
  */
-M0_INTERNAL void m0_be_ks_create_handle(struct m0_be_ks_opdata *bk_opdata);
+M0_INTERNAL void m0_be_ks_create(struct m0_tl_descr      *descr,
+                                 struct m0_be_domain     *dom,
+                                 kv_key_cmp_t             cmp_fp,
+                                 kv_key_match_t           match_fp,
+                                 struct m0_be_kv_store  **handle);
 
 /**
-  Create/update the handle for the key_value_store.
+  Initialise a key value store. It either recovers or creates the rvm part
+  of the @handle.
 
   @param handle        :       pointer to the handle.
   @param descr         :       the tlist descriptor to be given to the tlist in
@@ -228,24 +255,28 @@ M0_INTERNAL void m0_be_ks_create_handle(struct m0_be_ks_opdata *bk_opdata);
   @param match_fp      :       user defined function to match keys.
   @param mode          :       decides whether kv_store is new or has to be
                                recovered.
-                               Allowed modes: CREATE/RECOVER or create/recover.
-  @retval true         :       upon succesful initialisation/recovery.
-  @retval false        :       upon failure to initialise/recover kv_store
+                               allowed modes: CREATE/RECOVER or create/recover.
  */
-M0_INTERNAL void m0_be_ks_init(struct m0_be_kv_store **handle,
-                               struct m0_tl_descr     *descr,
-                               struct m0_be_domain    *dom,
-                               kv_key_cmp_t            cmp_fp,
-                               kv_key_match_t          match_fp,
+M0_INTERNAL void m0_be_ks_init(struct m0_be_kv_store  *handle,
                                char                   *mode);
 
 /**
+  Finalise a kv-store.
+
+  @param handle        :        the kv-store handle.
+  @param seg           :        segment used by kv-store.
+
+  @todo: as we have just segment now, segment parameter needed for now.
+ */
+M0_INTERNAL void m0_be_ks_fini(struct m0_be_kv_store *handle,
+                               struct m0_be_seg      *seg);
+/**
   Insert a key value pair in the tlist contained in @handle.
 
-  @param handle                :      handle containing the tlist in which the
+  @param handle                :      Handle containing the tlist in which the
                                       object will be stored.
-  @param obj_ref               :      the reference allocated to the actual
-                                      object.
+  @param obj_ref               :      the m0_be_reference of the object to
+                                      be inserted
   @param tx                    :      transaction handle.
   @retval BE_KV_FAILURE        :      upon failure to insert key.
   @retval BE_KV_SUCCESS        :      upon successful insert.
@@ -291,46 +322,6 @@ M0_INTERNAL int32_t m0_be_ks_delete(struct m0_be_kv_store *handle,
 M0_INTERNAL struct m0_list_link
 *m0_be_ks_get_next_val(struct m0_be_kv_store *handle, void *obj);
 
-/**
-  Recovers the persistent part of the kv_store handle from rvm and puts it back
-  in the @handle.
-
-  @param handle               :       the kv_store handle.
-  @param seg                  :       segment pointer containing heap address.
-  @param kv_store             :       pointer containing segment id and offset
-                                      of the persistent kv_store handle.
-  @retval true                :       upon successful retrieval.
-  @retval false               :       upon retrival failure.
- */
-M0_INTERNAL bool m0_be_ks_deref_handle(struct m0_be_kv_store *handle,
-                                       struct m0_be_seg      *seg);
-
-/**
-  Callback routine that completes the KS initialization.
-  Marks the current state of KS state machine as done.
- */
-M0_INTERNAL void m0_be_ksi_init_done(void *cb_data);
-
-/**
-  Callback routine that carries out m0_be_tx_fini for m0_be_ks_create handle.
-  Frees pointers allocated previously in m0_be_ks_create handle.
-  Last step in m0_be_ks_create_handle.
-  Calls m0_be_ksi_init_done to complete m0_be_ks_init.
- */
-M0_INTERNAL void m0_be_ksi_tx_cb(void *cb_data);
-
-/**
-  Callback routine that is called after completing m0_be_hs_update in
-  m0_be_ks_create_handle. Initialises underlying tlist contained in cb_data.
-  Carries out tx_done part via m0_be_ksi_tx_cb.
- */
-M0_INTERNAL void m0_be_ksi_hs_cb(void *cb_data);
-
-/**
-  Callback routine that actually creates or restores a ks-handle.
- */
-M0_INTERNAL void m0_be_ksi_handle_cb(void *cb_data);
-
 /** @} end of kv_store group */
 #endif /* __MERO_BE_KV_STORE_H__ */
 
diff --git a/be/kv_store_private.h b/be/kv_store_private.h
new file mode 100644
index 0000000..67ea921
--- /dev/null
+++ b/be/kv_store_private.h
@@ -0,0 +1,130 @@
+/* -*- C -*- */
+/*
+ * COPYRIGHT 2012 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: Zishan Shaikh <zishan_shaikh@xyratex.com>
+ * Original creation date: 12/06/2012
+ */
+#pragma once
+#ifndef __MERO_BE_KV_STORE_PRIVATE_H__
+#define __MERO_BE_KV_STORE_PRIVATE_H__
+
+#include "lib/tlist.h"
+#include "be/be.h"
+#include "be/kv_store.h"
+
+/**
+   @defgroup kv_store_private
+
+   Contains APIs used by kv-store internally.
+
+ */
+/**
+  Gives the linkage of the previous object for current. The previous pointer is
+  updated in @link_prev.
+ */
+static void __ks_get_prev(struct m0_tl_descr   *d,
+                          void                 *current,
+                          struct m0_list_link **link_prev);
+
+/**
+  Gives the linkage of the next object for current. The next pointer is
+  updated in @link_next.
+ */
+static void __ks_get_next(struct m0_tl_descr   *d,
+                          void                 *current,
+                          struct m0_list_link **link_next);
+
+/**
+  Gives the linkage of the current object. The pointer is updated in
+  @link_current.
+ */
+static void __ks_get_current(struct m0_tl_descr   *d,
+                             void                 *current,
+                             struct m0_list_link **link_cuurent);
+
+/**
+  Adds or captures the regions of the current, next & previous pointers of
+  @current object, depending upon @in_tx_state.
+ */
+static void __ks_prev_next_add_cred(struct m0_be_kv_store     *handle,
+                                    struct m0_be_tx           *tx,
+                                    void                      *current,
+                                    int                        operation);
+
+/**
+  Recovers the persistent part of the kv_store handle from rvm and puts it back
+  in the @handle.
+
+  @param handle               :       the kv_store handle.
+  @param seg                  :       segment pointer containing heap address.
+  @param kv_store             :       pointer containing segment id and offset
+                                      of the persistent kv_store handle.
+  @retval true                :       upon successful retrieval.
+  @retval false               :       upon retrival failure.
+ */
+M0_INTERNAL bool m0_be_ks_deref_handle(struct m0_be_kv_store *handle,
+                                       struct m0_be_seg      *seg);
+
+/**
+  Callback routine that completes the KS initialization.
+  Marks the current state of KS state machine as done.
+ */
+M0_INTERNAL void m0_be_ksi_init_done(void *cb_data);
+
+/**
+  Callback routine that carries out m0_be_tx_fini for m0_be_ks_create handle.
+  Frees pointers allocated previously in m0_be_ks_create handle.
+  Last step in m0_be_ks_create_handle.
+  Calls m0_be_ksi_init_done to complete m0_be_ks_init.
+ */
+M0_INTERNAL void m0_be_ksi_tx_cb(void *cb_data);
+
+/**
+  Callback routine that is called after completing m0_be_hs_update in
+  m0_be_ks_create_handle. Initialises underlying tlist contained in cb_data.
+  Carries out tx_done part via m0_be_ksi_tx_cb.
+ */
+M0_INTERNAL void m0_be_ksi_hs_cb(void *cb_data);
+
+/**
+  Callback routine that actually creates or restores a ks-handle.
+ */
+M0_INTERNAL void m0_be_ksi_handle_cb(void *cb_data);
+
+/**
+  Returns the current state of the kv-store state machine.
+ */
+M0_INTERNAL enum m0_be_ks_state
+m0_be_ks_get_handle_state(struct m0_be_kv_store *handle);
+
+/**
+  Creates the persistent part of key value store handle.
+  Called by m0_be_ks_init indirectly if ks-init mode is create.
+ */
+M0_INTERNAL void __ks_create_handle(struct m0_be_ks_opdata *bk_opdata);
+
+/** @} end of kv_store_private group */
+#endif /* __MERO_BE_KV_STORE_PRIVATE_H__ */
+
+/*
+ * Local variables:
+ * c-indentation-style: "K&R"
+ * c-basic-offset: 8
+ * tab-width: 8
+ * fill-column: 80
+ * scroll-step: 1
+ * End:
+ */
diff --git a/be/ut/kv_store.c b/be/ut/kv_store.c
index 75939d2..dfa81fe 100644
--- a/be/ut/kv_store.c
+++ b/be/ut/kv_store.c
@@ -115,15 +115,19 @@ static int ts_kv_store_init()
         m0_be_ks_init_domain(&kv_dom);
         M0_ASSERT(kv_dom != NULL);
 
-        sm_group = m0_be_domain_sm_group(kv_dom);
+        /* Create a kv-store handle */
+        m0_be_ks_create(&kv_list_descr, kv_dom,
+                        cmp_routine, match_routine, &handle);
+        M0_ASSERT(handle != NULL);
 
-        m0_be_ks_init(&handle, &kv_list_descr, kv_dom,
-                      cmp_routine, match_routine, "create");
+        sm_group = m0_be_domain_sm_group(kv_dom);
 
+        /* Initialise the kv-store i.e. create or recover from RVM */
+        m0_be_ks_init(handle, "create");
         m0_be_wait(sm_group, &handle->ks_handle_heap.ksh_sm,
                    M0_BITS(M0_BEKS_DONE));
 
-        M0_ASSERT(handle != NULL);
+        M0_ASSERT(handle->ks_handle_rvm != NULL);
         M0_LOG(M0_INFO, "kv_store initialised!");
         return 0;
 }
@@ -132,8 +136,7 @@ static int ts_kv_store_fini()
 {
         int rc;
 
-        m0_be_ks_fini(kv_dom, kv_seg);
-        m0_free(handle);
+        m0_be_ks_fini(handle, kv_seg);
 
         sprintf(kv_cmd, "rm -rf %s", stob_dir);
         rc = system(kv_cmd);
diff --git a/be/ut/kv_store_ub.c b/be/ut/kv_store_ub.c
index 7b0e3c8..dbd9620 100644
--- a/be/ut/kv_store_ub.c
+++ b/be/ut/kv_store_ub.c
@@ -339,21 +339,26 @@ static void ub_init(void)
         m0_be_ks_init_domain(&kv_dom);
         M0_ASSERT(kv_dom != NULL);
 
+        /* Create a kv-store handle */
+        m0_be_ks_create(&kv_list_descr, kv_dom,
+                        cmp_routine, match_routine, &handle);
+        M0_ASSERT(handle != NULL);
+
         sm_group = m0_be_domain_sm_group(kv_dom);
 
-        m0_be_ks_init(&handle, &kv_list_descr, kv_dom, cmp_routine,
-                      match_routine, "create");
+        /* Initialise the kv-store i.e. create or recover from RVM */
+        m0_be_ks_init(handle, "create");
         m0_be_wait(sm_group, &handle->ks_handle_heap.ksh_sm,
                    M0_BITS(M0_BEKS_DONE));
-        M0_ASSERT(handle != NULL);
+
+        M0_ASSERT(handle->ks_handle_rvm != NULL);
 }
 
 static void ub_fini()
 {
         int rc;
 
-        m0_be_ks_fini(kv_dom, kv_seg);
-        m0_free(handle);
+        m0_be_ks_fini(handle, kv_seg);
 
         sprintf(kv_cmd, "rm -rf %s", stob_dir);
         rc = system(kv_cmd);
-- 
1.8.3.2

