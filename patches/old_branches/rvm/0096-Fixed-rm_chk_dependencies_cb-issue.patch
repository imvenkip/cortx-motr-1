From 0adf9dc1e266fe75891b08021f1ef5d9a7b31ea8 Mon Sep 17 00:00:00 2001
From: Prashant Dhange <prashant_dhange@xyratex.com>
Date: Wed, 22 May 2013 10:52:52 -0700
Subject: [PATCH 096/121] Fixed rm_chk_dependencies_cb issue

---
 be/seg.c            |  1 +
 rvm/rds_zap.c       |  3 +++
 rvm/rvm_createseg.c |  2 ++
 rvm/rvm_io.c        |  2 ++
 rvm/rvm_logrecovr.c |  2 ++
 rvm/rvm_map.c       | 57 +++++++++++++++++++++++++++++++++++------------------
 6 files changed, 48 insertions(+), 19 deletions(-)

diff --git a/be/seg.c b/be/seg.c
index 8e6a4f6..125b944 100644
--- a/be/seg.c
+++ b/be/seg.c
@@ -382,6 +382,7 @@ M0_INTERNAL void m0_be_seg_create_cb(struct m0_be_cbinfo *cbinfo, int status,
         rds_static_len = RVM_ROUND_LENGTH_DOWN_TO_PAGE_SIZE(4096);
         cbinfo->bc_cb  = m0_bs_create_rds_zap_cb;
 
+	printf("\nfunction : %s\n", __FUNCTION__);
         rds_zap_heap(seg->bs_impl.path_name,
 		     RVM_LENGTH_TO_OFFSET(dev_length),
 		     start_addr,
diff --git a/rvm/rds_zap.c b/rvm/rds_zap.c
index 55ad131..b017086 100644
--- a/rvm/rds_zap.c
+++ b/rvm/rds_zap.c
@@ -198,6 +198,7 @@ void rzh_create_seg_cb(cbinfo, status, msg_type)
 	if (status != 0)
 		goto exit;
 
+	printf("\nfunction : %s\n", __FUNCTION__);
 	M0_ASSERT(cbinfo != NULL);
 
 	rzh_cbdata = container_of(cbinfo, rzh_cbdata_t, rzhc_cbinfo);
@@ -245,6 +246,8 @@ int rds_zap_heap(dev_name, dev_length, start_addr, static_length, heap_length,
 		assert(start_addr != NULL);
 	}
 
+	printf("\nfunction : %s\n", __FUNCTION__);
+
 	/* Initialization of seg->bs_rvm */
 	seg_hdr->n_loadregions = 2;
 	rds_init(seg_hdr);
diff --git a/rvm/rvm_createseg.c b/rvm/rvm_createseg.c
index 3095078..0a90032 100644
--- a/rvm/rvm_createseg.c
+++ b/rvm/rvm_createseg.c
@@ -172,6 +172,8 @@ rvm_return_t rvm_create_segment(char *dev_name,
 	M0_ALLOC_PTR(rcs_cbdata);
 	M0_ASSERT(rcs_cbdata != NULL);
 
+	printf("\nfunction : %s\n", __FUNCTION__);
+
 	rvm_region_t *region = rvm_malloc_region();
 
 	/* Make sure the region definitions do not overlap. */
diff --git a/rvm/rvm_io.c b/rvm/rvm_io.c
index a0c0a84..2fecd45 100644
--- a/rvm/rvm_io.c
+++ b/rvm/rvm_io.c
@@ -517,6 +517,8 @@ long read_stob_new(device_t *dev, rvm_offset_t *rvm_offset, char *dest,
 	int 			status;
 	m0_be_msg_type_t	msg_type = M0_BE_SUCCESS;
 
+	printf("\nfunction : %s\n", __FUNCTION__);
+
 	assert(dev->stob != NULL);
 	assert(length != 0);
 	assert((dev->raw_io) ? (SECTOR_INDEX(length) == 0) : 1);
diff --git a/rvm/rvm_logrecovr.c b/rvm/rvm_logrecovr.c
index fcb78b6..5b22901 100644
--- a/rvm/rvm_logrecovr.c
+++ b/rvm/rvm_logrecovr.c
@@ -3587,6 +3587,8 @@ rvm_return_t wait_for_truncation(log_t *log,
 	int 		 status   = 0;
 	m0_be_msg_type_t msg_type = M0_BE_SUCCESS;
 
+	printf("\nfunction : %s\n", __FUNCTION__);
+
 	while (!exit_sw)
 	{
 		CRITICAL(daemon->lock,          /* begin daemon lock crit sec */
diff --git a/rvm/rvm_map.c b/rvm/rvm_map.c
index 1def371..b03ff9f 100644
--- a/rvm/rvm_map.c
+++ b/rvm/rvm_map.c
@@ -920,6 +920,8 @@ void cd_wait_for_truncate_cb(cbinfo, status, msg)
 	region	  = cd_cbdata->cdc_region;
 	x_region  = cd_cbdata->cdc_x_region;
 
+	if (x_region == NULL)
+		goto exit;
 
 	CRITICAL(seg->seg_lock, /* begin seg_lock crit sect */
 	{
@@ -930,7 +932,7 @@ void cd_wait_for_truncate_cb(cbinfo, status, msg)
 
 		if (x_region != NULL) {
 			cd_cbdata->cdc_x_region = x_region;
-			/*cbinfo->bc_cb = cd_wait_for_truncate_cb;*/
+			cbinfo->bc_cb = cd_wait_for_truncate_cb;
 
 			(void)initiate_truncation(seg->log, 100);
 
@@ -965,6 +967,8 @@ static rvm_return_t chk_dependencies(seg, region, cbinfo)
 	int		     be_status = 0;
 	m0_be_msg_type_t     msg       = M0_BE_SUCCESS;
 
+	printf("\nfunction : %s\n", __FUNCTION__);
+
 	/* check for multiple mappings of same segment region */
 	CRITICAL(seg->seg_lock,            /* begin seg_lock crit sect */
 	{
@@ -998,6 +1002,7 @@ static rvm_return_t chk_dependencies(seg, region, cbinfo)
 			x_region = chk_seg_mappings(region, &seg->unmap_list);
 
 			if (x_region != NULL) {
+				printf("about to call wait_for_truncation...\n");
 				cd_cbdata->cdc_x_region = x_region;
 
 				(void)initiate_truncation(seg->log,100);
@@ -1011,6 +1016,7 @@ static rvm_return_t chk_dependencies(seg, region, cbinfo)
 					goto err_exit;
 				}
 			}
+
 		} else {
 			ret = RVM_EOVERLAP;      /* multiply mapped */
 			be_status = -1;
@@ -1020,9 +1026,9 @@ static rvm_return_t chk_dependencies(seg, region, cbinfo)
 	err_exit:;
 	});              /* end seg_lock crit sect */
 
-	if (be_status != 0  && cbinfo->bc_pcbinfo != NULL &&
-            cbinfo->bc_pcbinfo->bc_cb != NULL) {
-                m0_be_handler_post(cbinfo->bc_pcbinfo, be_status, msg);
+	if ((x_region == NULL || be_status != 0)  &&
+	    cbinfo != NULL && cbinfo->bc_cb != NULL) {
+                m0_be_handler_post(cbinfo, be_status, msg);
 		m0_free(cd_cbdata);
         }
 	return ret;
@@ -1040,6 +1046,7 @@ static rvm_return_t map_data(rvm_options_t 	 *rvm_options,
 	#if defined(__NetBSD__) || defined(__FreeBSD__)
 	char            *addr;
 	#endif
+	printf("\nfunction : %s\n", __FUNCTION__);
 	/* check for pager mapping */
 	if (rvm_options != NULL)
 		if (rvm_options->pager != NULL) {
@@ -1086,7 +1093,7 @@ static rvm_return_t map_data(rvm_options_t 	 *rvm_options,
 			}
 		}
 
-	return RVM_SUCCESS;
+	/*return RVM_SUCCESS;*/
 exit:
 	if (status != 0 && cbinfo->bc_pcbinfo != NULL &&
 	    cbinfo->bc_pcbinfo->bc_cb != NULL) {
@@ -1135,11 +1142,17 @@ void rm_map_data_cb(struct m0_be_cbinfo *cbinfo,
 	rvm_region_t	*rvm_region;
 	rm_cbdata_t 	*rm_cbdata;
 
+	printf("\nfunction : %s\n", __FUNCTION__);
+
 	rm_cbdata = container_of(cbinfo, rm_cbdata_t, rmc_cbinfo);
         M0_ASSERT(rm_cbdata != NULL);
 
+	if (status != 0)
+		goto exit;
+
         rvm_region = rm_cbdata->rmc_rvm_region;
 
+exit:
 	if (status != 0) {
 		rvm_region->length = 0;
 		clean_up(rm_cbdata->rmc_region, rm_cbdata->rmc_mem_region);
@@ -1166,6 +1179,8 @@ void rm_chk_dependencies_cb(struct m0_be_cbinfo *cbinfo, int status,
 	int		 	 fd;		   /* For private mappings */
 	rvm_return_t		 retval;
 
+	printf("\nfunction : %s\n", __FUNCTION__);
+
 	rm_cbdata = container_of(cbinfo, rm_cbdata_t, rmc_cbinfo);
 	rvm_region 	= rm_cbdata->rmc_rvm_region;
 	region 	   	= rm_cbdata->rmc_region;
@@ -1233,19 +1248,20 @@ exit:
 void rm_do_rvm_options_cb(struct m0_be_cbinfo *cbinfo, int status,
 			  m0_be_msg_type_t msg_type)
 {
-	rm_cbdata_t 	*rm_cbdata;
-	seg_t       	*seg;              /* segment descriptor */
-	rvm_region_t	*rvm_region;
-	rvm_seg_hdr_t	*seg_hdr;
-
-	uint32_t	 region_saved = 0;
-	rvm_return_t	 retval;
+	rm_cbdata_t 		*rm_cbdata;
+	seg_t       		*seg;              /* segment descriptor */
+	rvm_region_t		*rvm_region;
+	rvm_seg_hdr_t		*seg_hdr;
+	uint32_t	 	region_saved = 0;
+	rvm_return_t	 	retval;
 
 	rm_cbdata = container_of(cbinfo, rm_cbdata_t, rmc_cbinfo);
 
 	rvm_region = rm_cbdata->rmc_rvm_region;
 	seg_hdr    = rm_cbdata->rmc_seg_hdr;
 
+	printf("\nfunction : %s\n", __FUNCTION__);
+
 	if (status != 0)
 		goto exit;
 
@@ -1289,6 +1305,7 @@ void rm_do_rvm_options_cb(struct m0_be_cbinfo *cbinfo, int status,
 		goto exit;
 	}
 
+	cbinfo->bc_cb = rm_chk_dependencies_cb;
 	retval = chk_dependencies(seg, rm_cbdata->rmc_region, cbinfo);
 	if (retval != RVM_SUCCESS) {
 		status 	 = -1;
@@ -1296,15 +1313,15 @@ void rm_do_rvm_options_cb(struct m0_be_cbinfo *cbinfo, int status,
 		goto exit;
 	}
 exit:
-	if(region_saved) {
-		clean_up(rm_cbdata->rmc_region, rm_cbdata->rmc_mem_region);
-		(void)BCOPY((char *)&rm_cbdata->rmc_save_rvm_region,
-			    (char *)rvm_region, sizeof(rvm_region_t));
-	}
-
 	if (status != 0 && cbinfo->bc_pcbinfo != NULL &&
 	    cbinfo->bc_pcbinfo->bc_cb != NULL) {
                 m0_be_handler_post(cbinfo->bc_pcbinfo, status, msg_type);
+		if(region_saved) {
+			clean_up(rm_cbdata->rmc_region,
+				 rm_cbdata->rmc_mem_region);
+			(void)BCOPY((char *)&rm_cbdata->rmc_save_rvm_region,
+				    (char *)rvm_region, sizeof(rvm_region_t));
+		}
 		m0_free(rm_cbdata);
         }
 }
@@ -1324,6 +1341,8 @@ rvm_return_t rvm_map(rvm_seg_hdr_t 		*seg_hdr,
 	M0_ALLOC_PTR(rm_cbdata);
 	M0_ASSERT(rm_cbdata != NULL);
 
+	printf("\nfunction : %s\n", __FUNCTION__);
+
 	rm_cbdata->rmc_rvm_region 	= rvm_region;
 	rm_cbdata->rmc_rvm_options 	= rvm_options;
 	rm_cbdata->rmc_seg_hdr 	  	= seg_hdr;
@@ -1347,6 +1366,7 @@ rvm_return_t rvm_map(rvm_seg_hdr_t 		*seg_hdr,
 	}
 
 	if (rvm_options != NULL) {
+		printf("here __ function : %s\n",__func__);
 		rmc_cbinfo->bc_cb = rm_do_rvm_options_cb;
 		retval = do_rvm_options(rvm_options, rmc_cbinfo);
 
@@ -1365,6 +1385,5 @@ exit:
                 m0_be_handler_post(cbinfo->bc_pcbinfo, status, msg_type);
 		m0_free(rm_cbdata);
         }
-
 	return status;
 }
-- 
1.8.3.2

