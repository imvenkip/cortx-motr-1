From 4a74ebe57edd9a10f9a71863a1f9b50b217c7c3b Mon Sep 17 00:00:00 2001
From: Zishan Shaikh <zishan_shaikh@xyratex.com>
Date: Mon, 7 Jan 2013 00:36:11 -0800
Subject: [PATCH 027/121] Handle seperated into rvm & non-rvm part

---
 be/lib/be_kv_store.c    | 223 +++++++++++++++++++++++++++++-------------------
 be/lib/be_kv_store.h    |  38 ++++++---
 be/lib/ut/be_kv_store.c |   6 +-
 3 files changed, 167 insertions(+), 100 deletions(-)

diff --git a/be/lib/be_kv_store.c b/be/lib/be_kv_store.c
index ecd0107..5e87de3 100644
--- a/be/lib/be_kv_store.c
+++ b/be/lib/be_kv_store.c
@@ -59,18 +59,19 @@ static void __m0_ks_add_prev_next_to_cred(struct m0_kv_store     *handle,
                                           void                   *current,
                                           int                     in_tx_state);
 
-M0_INTERNAL void m0_ks_create_handle(struct m0_be_domain    *dom,
-                                     struct m0_be_tl_descr  *descr,
-                                     struct m0_kv_store    **handle)
+M0_INTERNAL void m0_ks_create_handle(struct m0_be_domain     *dom,
+                                     struct m0_be_tl_descr   *descr,
+                                     struct m0_kv_store_rvm **rvm_handle_out)
 {
-        struct m0_be_tx      *tx = NULL;
-        struct m0_be_reg     *handle_reg = NULL;
-        struct m0_be_seg     *handle_seg = NULL;
-        struct m0_be_buf      handle_buf;
-        struct m0_be_list    *head;
-        struct m0_uint128    *temp_head_offset;
-        struct m0_uint128    *temp_tail_offset;
-        struct m0_reference  *handle_ref = NULL;
+        struct m0_be_tx         *tx             = NULL;
+        struct m0_be_reg        *rvm_handle_reg = NULL;
+        struct m0_be_seg        *rvm_handle_seg = NULL;
+        struct m0_be_list       *head           = NULL;
+        struct m0_reference     *rvm_handle_ref = NULL;
+        struct m0_kv_store_rvm  *rvm_handle     = NULL;
+        struct m0_uint128       *temp_head_offset;
+        struct m0_uint128       *temp_tail_offset;
+        struct m0_be_buf         rvm_handle_buf;
 
         M0_ALLOC_PTR(tx);
 
@@ -78,37 +79,40 @@ M0_INTERNAL void m0_ks_create_handle(struct m0_be_domain    *dom,
                 return;
 
         /* For now segid is always == 1*/
-        m0_ks_domain_lookup(dom, &handle_seg, 1);
-        M0_ASSERT(handle_seg != NULL);
+        m0_ks_domain_lookup(dom, &rvm_handle_seg, 1);
+        M0_ASSERT(rvm_handle_seg != NULL);
 
         m0_be_tx_init(tx, dom, 0);
         M0_BE_WAIT(tx->bt_impl.sm_group, &tx->bt_sm,
                    (1 << M0_BETX_INIT) | (1 << M0_BETX_FAILED));
 
-        /* Prepare a region of the handle */
-        handle_buf.b_nob = sizeof(struct m0_kv_store);
-        m0_be_reg_init(&handle_reg, tx, handle_seg, &handle_buf);
+        /* Prepare a region for the rvm_handle */
+        rvm_handle_buf.b_nob = sizeof(struct m0_kv_store_rvm);
+        m0_be_reg_init(&rvm_handle_reg, tx, rvm_handle_seg, &rvm_handle_buf);
 
         m0_ks_tx_start(tx);
 
-        (*handle) = (struct m0_kv_store *)m0_ks_obj_malloc(handle_reg,
-                                                           &handle_ref);
-        M0_ASSERT((*handle) != NULL);
-        M0_ASSERT(handle_ref != NULL);
+        rvm_handle = (struct m0_kv_store_rvm *)m0_ks_obj_malloc(rvm_handle_reg,
+                                                               &rvm_handle_ref);
+        M0_ASSERT(rvm_handle != NULL);
+        M0_ASSERT(rvm_handle_ref != NULL);
 
         /* be_tlist init */
-        m0_be_tlist_init(descr, &(*handle)->ks_tlist);
+        m0_be_tlist_init(descr, &rvm_handle->ks_tlist);
 
         /* Update segment id & offset in head & tail */
-        head = &((*handle)->ks_tlist.t_head);
+        head = &(rvm_handle->ks_tlist.t_head);
 
         temp_head_offset       = &(head->l_head.logical_address.segid_offset);
-        temp_head_offset->u_hi = handle_ref->segid_offset.u_hi;
-        temp_head_offset->u_lo = handle_ref->segid_offset.u_lo;
+        temp_head_offset->u_hi = rvm_handle_ref->segid_offset.u_hi;
+        temp_head_offset->u_lo = rvm_handle_ref->segid_offset.u_lo;
 
         temp_tail_offset       = &(head->l_tail.logical_address.segid_offset);
-        temp_tail_offset->u_hi = handle_ref->segid_offset.u_hi;
-        temp_tail_offset->u_lo = handle_ref->segid_offset.u_lo;
+        temp_tail_offset->u_hi = rvm_handle_ref->segid_offset.u_hi;
+        temp_tail_offset->u_lo = rvm_handle_ref->segid_offset.u_lo;
+
+        (*rvm_handle_out) = rvm_handle;
+        M0_ASSERT((*rvm_handle_out) != NULL);
 
         m0_be_tx_done(tx);
         M0_BE_WAIT(tx->bt_impl.sm_group, &tx->bt_sm,
@@ -119,36 +123,58 @@ M0_INTERNAL void m0_ks_create_handle(struct m0_be_domain    *dom,
 }
 M0_EXPORTED(m0_ks_create_handle);
 
-M0_INTERNAL void m0_ks_init(struct m0_kv_store     *handle,
+M0_INTERNAL void m0_ks_init(struct m0_kv_store    **handle,
                             struct m0_be_tl_descr  *descr,
                             struct m0_be_domain    *dom,
                             kv_key_cmp              cmp_fp,
                             kv_key_match            match_fp)
 {
-        M0_ASSERT(handle != NULL);
-        handle->kv_key_cmp    = cmp_fp;
-        handle->kv_key_match  = match_fp;
-        handle->ks_list_descr = descr;
-        handle->ks_dom        = dom;
+        struct m0_kv_store_rvm  *rvm_handle = NULL;
+
+        if((*handle) == NULL) {
+                M0_ALLOC_PTR((*handle));
+                M0_ASSERT(handle != NULL);
+        }
+
+        /* if (recover_possible)
+         *      recover;
+         * else {
+         */
+        m0_ks_create_handle(dom, descr, &rvm_handle);
+        /* } */
+        M0_ASSERT(rvm_handle != NULL);
+
+        (*handle)->handle_rvm = rvm_handle;
+
+        /* Set the non_rvm part of the handle with user values */
+        (*handle)->handle_heap.kv_key_cmp    = cmp_fp;
+        (*handle)->handle_heap.kv_key_match  = match_fp;
+        (*handle)->handle_heap.ks_list_descr = descr;
+        (*handle)->handle_heap.ks_dom        = dom;
 }
 M0_EXPORTED(m0_ks_init);
 
 M0_INTERNAL struct m0_reference *m0_ks_get_next_val(struct m0_kv_store *handle,
                                                     void               *obj)
 {
-        struct m0_be_list_link          *link_next   = NULL;
-        struct m0_reference             *ret_ref     = NULL;
-        void                            *temp_tail   = NULL;
+        struct m0_be_list_link  *link_next      = NULL;
+        struct m0_reference     *ret_ref        = NULL;
+        void                    *temp_tail      = NULL;
+        struct m0_be_tl         *ks_tlist       = NULL;
+        struct m0_be_tl_descr   *ks_list_descr  = NULL;
 
-        temp_tail = m0_be_tlist_tail(handle->ks_list_descr, &handle->ks_tlist);
+        ks_tlist      = &handle->handle_rvm->ks_tlist;
+        ks_list_descr = handle->handle_heap.ks_list_descr;
+
+        temp_tail = m0_be_tlist_tail(ks_list_descr, ks_tlist);
 
         /* If object is last in linked list, then its next will be itself */
         if (temp_tail == obj) {
-                __get_current(handle->ks_list_descr, obj, &link_next);
+                __get_current(ks_list_descr, obj, &link_next);
                 goto get_ref;
         }
 
-        __get_next(handle->ks_list_descr, obj, &link_next);
+        __get_next(ks_list_descr, obj, &link_next);
 
 get_ref:
         ret_ref  = &(link_next->ll_next.logical_address);
@@ -162,9 +188,14 @@ M0_INTERNAL void *m0_ks_find(struct m0_kv_store *handle,
 {
         void                   *scan;
         void                   *target = NULL;
+        struct m0_be_tl         *ks_tlist  = NULL;      
+        struct m0_be_tl_descr   *ks_list_descr  = NULL;
+
+        ks_tlist = &handle->handle_rvm->ks_tlist;
+        ks_list_descr = handle->handle_heap.ks_list_descr;
 
-        m0_be_tlist_for(handle->ks_list_descr, &handle->ks_tlist, scan) {
-                if (handle->kv_key_match(scan, key) == 0) {
+        m0_be_tlist_for(ks_list_descr, ks_tlist, scan) {
+                if (handle->handle_heap.kv_key_match(scan, key) == 0) {
                         target = scan;
                         break;
                 }
@@ -182,9 +213,14 @@ M0_INTERNAL int m0_ks_delete(struct m0_kv_store  *handle,
         void                   *target    = NULL;
         struct m0_be_reg       *curr_reg  = NULL;
         struct m0_be_list_link *link_curr = NULL;
-        struct m0_be_tl_descr  *desc_t    = NULL; /* temporary */
         struct m0_be_tx         *tx = del_tx;
         int                     del_tx_state = IN_TX_NOT_NULL;
+        struct m0_be_tl         *ks_tlist  = NULL;      
+        struct m0_be_tl_descr   *ks_list_descr  = NULL;
+
+        ks_list_descr = handle->handle_heap.ks_list_descr;
+
+        ks_tlist = &handle->handle_rvm->ks_tlist;
 
         if (del_tx == NULL) {
                 del_tx_state = IN_TX_NULL;
@@ -192,26 +228,24 @@ M0_INTERNAL int m0_ks_delete(struct m0_kv_store  *handle,
                 M0_ALLOC_PTR(tx);
                 M0_ASSERT(tx != NULL);
 
-                m0_be_tx_init(tx, handle->ks_dom, 0);
+                m0_be_tx_init(tx, handle->handle_heap.ks_dom, 0);
                 M0_BE_WAIT(tx->bt_impl.sm_group, &tx->bt_sm,
                            (1 << M0_BETX_INIT) | (1 << M0_BETX_FAILED));
         }
 
         /* Find the target node to be deleted */
-        m0_be_tlist_for(handle->ks_list_descr, &handle->ks_tlist, scan) {
-                if (handle->kv_key_cmp(scan, obj) == 0)
+        m0_be_tlist_for(ks_list_descr, ks_tlist, scan) {
+                if (handle->handle_heap.kv_key_cmp(scan, obj) == 0)
                         target = scan;
         }m0_be_tlist_endfor;
 
         if (target != NULL) {
-                desc_t = handle->ks_list_descr;
-
                 /* Add linkage of current object to transaction */
                 link_curr = &((struct m0_be_tlink *)
-                              (target + desc_t->td_link_offset))->t_link;
+                              (target + ks_list_descr->td_link_offset))->t_link;
                 
                 /* Init a region for this link */
-                m0_ks_prep_link_reg(handle->ks_dom, link_curr, tx,
+                m0_ks_prep_link_reg(handle->handle_heap.ks_dom, link_curr, tx,
                                     &curr_reg);
                 M0_ASSERT(curr_reg != NULL);
 
@@ -237,7 +271,7 @@ M0_INTERNAL int m0_ks_delete(struct m0_kv_store  *handle,
                 }
 
                 /* Now delete */
-                m0_be_tlink_del_fini(handle->ks_list_descr, target);
+                m0_be_tlink_del_fini(ks_list_descr, target);
 
                 if (del_tx == NULL) {
                         m0_be_tx_done(tx);
@@ -263,32 +297,38 @@ M0_INTERNAL int __add_at_tail_to_tlist(struct m0_kv_store     *handle,
                                        struct m0_be_tx        *tx,
                                        int                     in_tx_state)
 {
-        struct m0_be_reg          *tail_reg  = NULL;
-        struct m0_be_list_link    *tail_link = NULL;
-        struct m0_be_reg          *tail_obj_reg  = NULL;
-        struct m0_be_list_link    *tail_obj_link = NULL;
-        struct m0_be_tl_descr     *desc_t    = NULL; /* temporary */
-        void                      *tail_obj  = NULL;
-        struct m0_be_list         *list_head;
+        struct m0_be_reg        *tail_reg  = NULL;
+        struct m0_be_list_link  *tail_link = NULL;
+        struct m0_be_reg        *tail_obj_reg  = NULL;
+        struct m0_be_list_link  *tail_obj_link = NULL;
+        void                    *tail_obj  = NULL;
+        struct m0_be_list       *list_head;
+        struct m0_be_tl         *ks_tlist  = NULL;      
+        struct m0_be_tl_descr   *ks_list_descr  = NULL;
+
+        ks_list_descr = handle->handle_heap.ks_list_descr;
+
+        ks_tlist = &handle->handle_rvm->ks_tlist;
 
         /* Add current tail object to credit */
-        tail_obj  = m0_be_tlist_tail(handle->ks_list_descr, &handle->ks_tlist);
-        desc_t    = handle->ks_list_descr;
+        tail_obj  = m0_be_tlist_tail(ks_list_descr, ks_tlist);
 
         tail_obj_link = &((struct m0_be_tlink *)
-                          (tail_obj + desc_t->td_link_offset))->t_link;
+                          (tail_obj + ks_list_descr->td_link_offset))->t_link;
 
         /* Init a region for this link */
-        m0_ks_prep_link_reg(handle->ks_dom, tail_obj_link, tx, &tail_obj_reg);
+        m0_ks_prep_link_reg(handle->handle_heap.ks_dom, tail_obj_link, tx,
+                            &tail_obj_reg);
         M0_ASSERT(tail_obj_reg != NULL);
 
         /* Add the current tail itself to credit */
-        list_head = &(handle->ks_tlist.t_head);
+        list_head = &ks_tlist->t_head;
         tail_link = list_head->l_tail.virtual_address;
         M0_ASSERT(tail_link != NULL);
  
         /* Init a region for this link */
-        m0_ks_prep_link_reg(handle->ks_dom, tail_link, tx, &tail_reg);
+        m0_ks_prep_link_reg(handle->handle_heap.ks_dom, tail_link, tx,
+                            &tail_reg);
         M0_ASSERT(tail_reg != NULL);
 
         if (in_tx_state == IN_TX_NULL) {
@@ -307,7 +347,7 @@ M0_INTERNAL int __add_at_tail_to_tlist(struct m0_kv_store     *handle,
         }
 
         /* Finally, add at tail in tlist */
-        m0_be_tlist_add_tail(desc_t, &handle->ks_tlist, new);
+        m0_be_tlist_add_tail(ks_list_descr, ks_tlist, new);
         return BE_KV_SUCCESS;
 }
 
@@ -317,7 +357,6 @@ M0_INTERNAL int m0_ks_insert(struct m0_kv_store  *handle,
 {
         struct m0_be_reg        *obj_link_reg  = NULL;
         struct m0_be_reg        *head_reg      = NULL;
-        struct m0_be_tl_descr   *desc_t        = NULL; /* temporary */
         struct m0_be_list_link  *link          = NULL;
         struct m0_be_list_link  *link_head;
         struct m0_be_list_link  *head;
@@ -327,6 +366,12 @@ M0_INTERNAL int m0_ks_insert(struct m0_kv_store  *handle,
         void                    *scan;
         int                      ret_val       = BE_KV_INVALID_REQ;
         int                      in_tx_state   = IN_TX_NOT_NULL;
+        struct m0_be_tl         *ks_tlist  = NULL;      
+        struct m0_be_tl_descr   *ks_list_descr  = NULL;
+
+        ks_list_descr = handle->handle_heap.ks_list_descr;
+
+        ks_tlist = &handle->handle_rvm->ks_tlist;
 
         /*
          * TODO: Check magic with magic that would be defined in handle->ks_dom.
@@ -340,8 +385,8 @@ M0_INTERNAL int m0_ks_insert(struct m0_kv_store  *handle,
         new = obj_ref->virtual_address;
 
         /* Check for duplicate insertion */
-        m0_be_tlist_for(handle->ks_list_descr, &handle->ks_tlist, scan) {
-                if (handle->kv_key_cmp(new, scan) == 0) {
+        m0_be_tlist_for(ks_list_descr, ks_tlist, scan) {
+                if (handle->handle_heap.kv_key_cmp(new, scan) == 0) {
                         goto exit_failure;
                 }
         }m0_be_tlist_endfor;
@@ -351,21 +396,22 @@ M0_INTERNAL int m0_ks_insert(struct m0_kv_store  *handle,
                 M0_ALLOC_PTR(tx);
                 M0_ASSERT(tx != NULL);
 
-                m0_be_tx_init(tx, handle->ks_dom, 0);
+                m0_be_tx_init(tx, handle->handle_heap.ks_dom, 0);
 
                 M0_BE_WAIT(tx->bt_impl.sm_group, &tx->bt_sm,
                            (1 << M0_BETX_INIT) | (1 << M0_BETX_FAILED));
         }
 
         /* Tlink init for this object */
-        m0_be_tlink_init(handle->ks_list_descr, obj_ref);
+        m0_be_tlink_init(ks_list_descr, obj_ref);
 
         link = &((struct m0_be_tlink *)
-                 (new + handle->ks_list_descr->td_link_offset))->t_link;
+                 (new + ks_list_descr->td_link_offset))->t_link;
         M0_ASSERT(link != NULL);
 
         /* Init a region for this link */
-        m0_ks_prep_link_reg(handle->ks_dom, link, tx, &obj_link_reg);
+        m0_ks_prep_link_reg(handle->handle_heap.ks_dom, link, tx,
+                            &obj_link_reg);
         M0_ASSERT(obj_link_reg != NULL);
 
         /* Capture this region */
@@ -377,19 +423,20 @@ M0_INTERNAL int m0_ks_insert(struct m0_kv_store  *handle,
                            (1 << M0_BEREG_CAPTURED) | (1 << M0_BEREG_FAILED));
         }
 
-        head = (void *)&handle->ks_tlist.t_head;
+        head = (void *)&ks_tlist->t_head;
 
         if ((head->ll_next.virtual_address == (void *)head) &&
             (head->ll_prev.virtual_address == (void *)head)) {
 
                 /* Check if list empty, if yes then add as head */
                 /* Capture actual head pointer */
-                list_head = &(handle->ks_tlist.t_head);
+                list_head = &(ks_tlist->t_head);
                 link_head = list_head->l_head.virtual_address;
                 M0_ASSERT(link_head != NULL);
                 
                 /* Init a region for head */
-                m0_ks_prep_link_reg(handle->ks_dom, link_head, tx, &head_reg);
+                m0_ks_prep_link_reg(handle->handle_heap.ks_dom, link_head, tx,
+                                    &head_reg);
                 M0_ASSERT(head_reg != NULL);
 
                 /* Capture this region */
@@ -406,14 +453,14 @@ M0_INTERNAL int m0_ks_insert(struct m0_kv_store  *handle,
                 }
 
                 /* Add to tlist now */
-                m0_be_tlist_add(handle->ks_list_descr, &handle->ks_tlist, new);
+                m0_be_tlist_add(ks_list_descr, ks_tlist, new);
                 ret_val = BE_KV_SUCCESS;
 
         } else {
                 /* Else, find the appropriate position for the obj and insert */
-                m0_be_tlist_for(handle->ks_list_descr, &handle->ks_tlist, scan)
+                m0_be_tlist_for(ks_list_descr, ks_tlist, scan)
                 {
-                        if (handle->kv_key_cmp(new, scan) < 0) {
+                        if (handle->handle_heap.kv_key_cmp(new, scan) < 0) {
                                 /*
                                  * Add the previous and next pointers about to
                                  * be modified to the credit.
@@ -428,8 +475,7 @@ M0_INTERNAL int m0_ks_insert(struct m0_kv_store  *handle,
                                 /*
                                  * Now add the object to the tlist
                                  */
-                                desc_t = handle->ks_list_descr;
-                                m0_be_tlist_add_before(desc_t, scan,
+                                m0_be_tlist_add_before(ks_list_descr, scan,
                                                        new);
 
                                 ret_val = BE_KV_SUCCESS;
@@ -508,18 +554,23 @@ static void __m0_ks_add_prev_next_to_cred(struct m0_kv_store *handle,
                                           void               *current,
                                           int                 in_tx_state)
 {
-        struct m0_be_reg         *prev_reg  = NULL;
-        struct m0_be_reg         *next_reg  = NULL;
-        struct m0_be_list_link   *link_prev = NULL;
-        struct m0_be_list_link   *link_next = NULL;
+        struct m0_be_reg         *prev_reg      = NULL;
+        struct m0_be_reg         *next_reg      = NULL;
+        struct m0_be_list_link   *link_prev     = NULL;
+        struct m0_be_list_link   *link_next     = NULL;
+        struct m0_be_tl_descr    *ks_list_descr = NULL;
+
+        ks_list_descr = handle->handle_heap.ks_list_descr;
 
-        __get_prev(handle->ks_list_descr, current, &link_prev);
-        __get_next(handle->ks_list_descr, current, &link_next);
+        __get_prev(ks_list_descr, current, &link_prev);
+        __get_next(ks_list_descr, current, &link_next);
 
-        m0_ks_prep_link_reg(handle->ks_dom, link_prev, tx, &prev_reg);
+        m0_ks_prep_link_reg(handle->handle_heap.ks_dom, link_prev, tx,
+                            &prev_reg);
         M0_ASSERT(prev_reg != NULL);
 
-        m0_ks_prep_link_reg(handle->ks_dom, link_next, tx, &next_reg);
+        m0_ks_prep_link_reg(handle->handle_heap.ks_dom, link_next, tx,
+                            &next_reg);
         M0_ASSERT(next_reg != NULL);
 
         if (in_tx_state == IN_TX_NULL) {
diff --git a/be/lib/be_kv_store.h b/be/lib/be_kv_store.h
index 9667013..44e62f0 100644
--- a/be/lib/be_kv_store.h
+++ b/be/lib/be_kv_store.h
@@ -42,38 +42,54 @@ typedef int     (*kv_key_cmp)(void *, void *);
 typedef int     (*kv_key_match)(void *, void *);
 
 /**
- * Structure to hold the handle to current tlist and its descriptor
+ * Structure that stores the fields of the kv_store handle that neeed to be made
+ * persistent.
  */
-struct m0_kv_store {
+struct m0_kv_store_rvm {
+        /* The tlist */
+        struct m0_be_tl         ks_tlist;
+};
+
+/**
+ * Structure that stores fields of the kv_store that need not be persistent.
+ */
+struct m0_kv_store_heap {
         /* List descriptor for the tlist */
         struct m0_be_tl_descr   *ks_list_descr;
-        /* The tlist itself */
-        struct m0_be_tl          ks_tlist;
         /* Domain pointer */
         struct m0_be_domain     *ks_dom;
         /* Compare function from user */
         kv_key_cmp               kv_key_cmp;
         /* Match function from user */
         kv_key_match             kv_key_match;
+};
+
 
+/**
+ * Structure to hold the handle to current tlist and its descriptor
+ */
+struct m0_kv_store {
+        struct m0_kv_store_rvm  *handle_rvm;
+        struct m0_kv_store_heap  handle_heap;
 };
 
 /*
- * Creates a key value store handle.
+ * Creates the persistent part of key value store handle.
+ * Called by m0_ks_init internally.
  * Returns NULL on failure.
  *
  * @param dom           :       pointer to the domain in which handle
  *                              is to be created
  * @param descr         :       the list descriptor to be assigned to the handle
- * @param handle        :       handle to be returned to the user.
+ * @param rvm_handle_out:       the rvm_handle to be returned to the caller.
  */
-M0_INTERNAL void m0_ks_create_handle(struct m0_be_domain   *dom,
-                                     struct m0_be_tl_descr *descr,
-                                     struct m0_kv_store   **handle);
+M0_INTERNAL void m0_ks_create_handle(struct m0_be_domain     *dom,
+                                     struct m0_be_tl_descr   *descr,
+                                     struct m0_kv_store_rvm **handle);
 
 
 /*
- * Update the handle for the key_value_store
+ * Create/update the handle for the key_value_store
  *
  * @param handle        :       pointer to the handle
  * @param descr         :       the tlist descriptor to be given to the tlist in
@@ -82,7 +98,7 @@ M0_INTERNAL void m0_ks_create_handle(struct m0_be_domain   *dom,
  * @param cmp_fp        :       user defined function to compare keys
  * @param match_fp      :       user defined function to match keys
  */
-M0_INTERNAL void m0_ks_init(struct m0_kv_store     *handle,
+M0_INTERNAL void m0_ks_init(struct m0_kv_store    **handle,
                             struct m0_be_tl_descr  *descr,
                             struct m0_be_domain    *dom,
                             kv_key_cmp              cmp_fp,
diff --git a/be/lib/ut/be_kv_store.c b/be/lib/ut/be_kv_store.c
index d633888..188026d 100644
--- a/be/lib/ut/be_kv_store.c
+++ b/be/lib/ut/be_kv_store.c
@@ -71,10 +71,9 @@ static void init()
         m0_ks_init_domain(&dom);
         M0_ASSERT(dom != NULL);
 
-        m0_ks_create_handle(dom, &list_descr, &handle);
+        m0_ks_init(&handle, &list_descr, dom, cmp_routine, match_routine);
         M0_ASSERT(handle != NULL);
-
-        m0_ks_init(handle, &list_descr, dom, cmp_routine, match_routine);
+        M0_ASSERT(handle->handle_rvm != NULL);
 }
 
 static void fini()
@@ -262,6 +261,7 @@ int main() {
         printf("Deleted obj4\n");
 
         fini();
+        m0_free(handle);
         return 0;
 }
 
-- 
1.8.3.2

