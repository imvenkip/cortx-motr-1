From 0ec251c08e7c55b0c37fafdf13ffe60cea5d0579 Mon Sep 17 00:00:00 2001
From: Sachin Patil <sachin_patil@xyratex.com>
Date: Wed, 29 May 2013 05:28:28 -0700
Subject: [PATCH 104/121] Locate tail function is split to support async
 mechanism.

---
 be/helper.c         |   12 +-
 rvm/rvm_logrecovr.c | 1025 ++++++++++++++++++++++++++++++++++++++-------------
 rvm/rvm_logstatus.c |   10 +-
 rvm/rvm_private.h   |    9 +
 4 files changed, 796 insertions(+), 260 deletions(-)

diff --git a/be/helper.c b/be/helper.c
index 05cc4ec..e65af05 100644
--- a/be/helper.c
+++ b/be/helper.c
@@ -279,14 +279,14 @@ M0_INTERNAL void m0_be_sm_lock_state_change_helper(struct m0_sm       *sm,
 }
 M0_EXPORTED(m0_be_sm_lock_state_change_helper);
 
-M0_INTERNAL void m0_be_cbinfo_copy_helper(struct m0_be_cbinfo *icbinfo,
-                                          struct m0_be_cbinfo *ocbinfo,
+M0_INTERNAL void m0_be_cbinfo_copy_helper(struct m0_be_cbinfo *pcbinfo,
+                                          struct m0_be_cbinfo *cbinfo,
                                           m0_be_callback       cb)
 {
-    ocbinfo->bc_pcbinfo  = icbinfo;
-    ocbinfo->bc_cb       = cb;
-    ocbinfo->bc_sm_group = icbinfo->bc_sm_group;
-    ocbinfo->bc_hq       = icbinfo->bc_hq;
+    cbinfo->bc_pcbinfo  = pcbinfo;
+    cbinfo->bc_cb       = cb;
+    cbinfo->bc_sm_group = pcbinfo->bc_sm_group;
+    cbinfo->bc_hq       = pcbinfo->bc_hq;
 }
 M0_EXPORTED(m0_be_cbinfo_copy_helper);
 /* @} end of be_helper group */
diff --git a/rvm/rvm_logrecovr.c b/rvm/rvm_logrecovr.c
index 6f817ed..b3b7978 100644
--- a/rvm/rvm_logrecovr.c
+++ b/rvm/rvm_logrecovr.c
@@ -523,6 +523,7 @@ void clear_aux_buf(log)
     RVM_ZERO_OFFSET(log_buf->aux_offset);
     log_buf->aux_rlength = 0;
     }
+
 /* record header type validation */
 rvm_bool_t chk_hdr_type(rec_hdr)
     rec_hdr_t       *rec_hdr;           /* generic record header */
@@ -549,16 +550,21 @@ rvm_bool_t chk_hdr_currency(log,rec_hdr)
 
     /* be sure record number makes sense */
     if ((status->first_rec_num != 0) &&
-        (rec_hdr->rec_num < status->first_rec_num))
+        (rec_hdr->rec_num < status->first_rec_num)) {
+	printf("\nfunction : %s status->firsrt_rec_num != 0", __FUNCTION__);
         return rvm_false;               /* obsolete record */
+    }
 
     /* be sure record written after previous truncation & before this one */
     if (TIME_LSS(rec_hdr->timestamp,status->prev_trunc)
-        || TIME_GTR(rec_hdr->timestamp,status->last_trunc))
+        || TIME_GTR(rec_hdr->timestamp,status->last_trunc)) {
+	printf("\nfunction : %s TIME_LESS || TIME_GTR", __FUNCTION__);
         return rvm_false;                   /* obsolete record */
+    }
+	printf("\nfunction : %s Returning true", __FUNCTION__);
 
     return rvm_true;
-    }
+}
 
 void reset_hdr_chks(log)
     log_t           *log;               /* log descriptor */
@@ -789,7 +795,7 @@ rvm_return_t validate_rec_forward(log,synch)
         /* no, re-init buffer */
         end_offset = RVM_ADD_LENGTH_TO_OFFSET(log_buf->offset,
                                               log_buf->ptr);
-       if ((retval=init_buffer(log,&end_offset,FORWARD,synch))
+       if ((retval = init_buffer(log,&end_offset,FORWARD,synch))
            != RVM_SUCCESS) return retval;
         }
 
@@ -810,8 +816,9 @@ rvm_return_t validate_rec_forward(log,synch)
             > log_buf->length)
             {
             /* refill buffer */
-            if ((retval=refill_buffer(log,FORWARD,synch))
-                != RVM_SUCCESS) return retval;
+            if ((retval = refill_buffer(log, FORWARD, synch))
+                != RVM_SUCCESS)
+			return retval;
             rec_hdr = (rec_hdr_t *)&log_buf->buf[log_buf->ptr];
             }
         tmp_ptr = log_buf->ptr + rec_hdr->rec_length;
@@ -1053,8 +1060,8 @@ rvm_return_t scan_reverse(log,synch)
 
     /* test if scan starting from tail */
     offset = RVM_ADD_LENGTH_TO_OFFSET(log_buf->offset,log_buf->ptr);
-    if (RVM_OFFSET_EQL(offset,status->prev_log_tail)
-        || (rvm_utlsw && RVM_OFFSET_EQL(offset,status->log_tail)))
+    if (RVM_OFFSET_EQL(offset, status->prev_log_tail)
+        || (rvm_utlsw && RVM_OFFSET_EQL(offset, status->log_tail)))
         return validate_rec_reverse(log,synch);
 
     /* test if at start of log & must wrap around */
@@ -1215,210 +1222,628 @@ bad_record:
     log_buf->ptr = -1;
     return RVM_SUCCESS;
     }
-/* Locate tail, update in-memory copy of status block; always reads forward */
-rvm_return_t locate_tail(log)
-    log_t           *log;               /* log descriptor */
-    {
-    log_status_t    *status = &log->status;   /* status descriptor */
-    log_buf_t       *log_buf = &log->log_buf; /* log buffer descriptor */
-    rvm_offset_t    tail;               /* tail offset */
-    rvm_offset_t    temp_tail;          /* tail offset temp */
-    rvm_length_t    last_rec_num = 0;   /* record number of tail record */
-    rec_hdr_t       *rec_hdr;           /* current record scanned in buffer */
-    long            old_ptr;            /* buffer ptr to last record found */
-    struct timeval  save_last_trunc;
-    struct timeval  last_write = status->last_write; /* last write to log */
-    rvm_bool_t      save_rvm_utlsw = rvm_utlsw;
-    rvm_return_t    retval = RVM_SUCCESS; /* return value */
 
-    assert(log->trunc_thread == cthread_self());
-    assert((status->trunc_state & RVM_TRUNC_PHASES) == ZERO);
-    status->trunc_state |= RVM_TRUNC_FIND_TAIL;
+void loc_tail_vrf_cb(struct m0_be_cbinfo *cbinfo, int be_status,
+                     m0_be_msg_type_t msg_type);
 
-    /* initialize scanner sequence checking state and buffers */
-    rvm_utlsw = rvm_false;
-    reset_hdr_chks(log);
-    clear_aux_buf(log);
+void locate_tail_cb(loc_tail_cbdata_t *loc_tail_cbdata)
+{
+	log_t 			*log;
+	log_status_t    	*status;   /* status descriptor */
+	log_buf_t       	*log_buf; /* log buffer descriptor */
+	struct m0_be_cbinfo	*cbinfo;
 
-    /* if truncation caught in crash, reset head */
-    if (!RVM_OFFSET_EQL_ZERO(status->prev_log_head))
-        {
-        status->log_head = status->prev_log_head;
-        status->last_rec_num = status->next_rec_num-1;
-        }
+	rvm_offset_t     	 tail;               /* tail offset */
+	rvm_length_t     	 last_rec_num;   /* number of tail record */
 
-    /* set temporary timestamp for record validation */
-    save_last_trunc = status->last_trunc;
-    make_uname(&status->last_trunc);
-    if (TIME_GTR(save_last_trunc,status->last_trunc))
-        {                               /* date/time wrong! */
-        retval = RVM_EINTERNAL;
-        rvm_errmsg = ERR_DATE_SKEW;
-        goto err_exit;
-        }
+	struct timeval   	 last_write; /* last write to log */
 
-    /* need to update status: init read buffer at head */
-    if ((retval=init_buffer(log,&status->log_head,
-                            FORWARD,NO_SYNCH))
-        != RVM_SUCCESS) goto err_exit;
-    assert(log->trunc_thread == cthread_self());
-    assert((status->trunc_state & RVM_TRUNC_PHASES) == RVM_TRUNC_FIND_TAIL);
+	int			 be_status = 0;
+	m0_be_msg_type_t	 msg_type  = M0_BE_SUCCESS;
 
-    /* validate 1st record, none ==> log empty */
-    rec_hdr = (rec_hdr_t *)&(log_buf->buf[log_buf->ptr]);
-    if (!validate_hdr(log,rec_hdr,NULL,FORWARD))
-        {
+	cbinfo 		= &loc_tail_cbdata->ltc_cbinfo;
+	last_rec_num	= loc_tail_cbdata->ltc_last_rec_num;
+
+	log 		= loc_tail_cbdata->ltc_log;
+	status 		= &log->status;
+	log_buf 	= &log->log_buf;
+	last_write 	= status->last_write;
+
+	/* tail found, update in-memory status */
 #ifdef RVM_LOG_TAIL_BUG
-        unprotect_page__Fi(ClobberAddress);
+	unprotect_page__Fi(ClobberAddress);
 #endif /* RVM_LOG_TAIL_BUG */
+
 #ifdef RVM_LOG_TAIL_SHADOW
-	assert(RVM_OFFSET_EQL(log_tail_shadow,status->log_tail));
+	assert(RVM_OFFSET_EQL(log_tail_shadow, status->log_tail));
 #endif /* RVM_LOG_TAIL_SHADOW */
-        status->log_tail = status->log_head;
+
+	status->log_tail = tail;
 #ifdef RVM_LOG_TAIL_SHADOW
-	RVM_ASSIGN_OFFSET(log_tail_shadow,status->log_tail);
+	RVM_ASSIGN_OFFSET(log_tail_shadow, status->log_tail);
 #endif /* RVM_LOG_TAIL_SHADOW */
+
 #ifdef RVM_LOG_TAIL_BUG
-        protect_page__Fi(ClobberAddress);
+	protect_page__Fi(ClobberAddress);
 #endif /* RVM_LOG_TAIL_BUG */
-        clear_log_status(log);
-        goto exit;
+
+	status->last_write = last_write;
+	if (RVM_OFFSET_EQL(status->log_head,status->log_tail))
+		clear_log_status(log);	/* log empty */
+	else {	/* log not empty */
+		status->log_empty = rvm_false;
+
+		if (status->next_rec_num <= last_rec_num)
+			status->next_rec_num = last_rec_num + 1;
+		if (status->last_rec_num != last_rec_num)
+			status->last_rec_num = last_rec_num;
+	}
+
+	rvm_utlsw 	   = loc_tail_cbdata->ltc_save_rvm_utlsw;
+	status->last_trunc = loc_tail_cbdata->ltc_save_last_trunc;
+
+	assert(log->trunc_thread == cthread_self());
+	assert((status->trunc_state & RVM_TRUNC_PHASES) == RVM_TRUNC_FIND_TAIL);
+
+	if (cbinfo->bc_pcbinfo != NULL && cbinfo->bc_pcbinfo->bc_cb != NULL) {
+                m0_be_handler_post(cbinfo->bc_pcbinfo, be_status, msg_type);
         }
-    /* update status block head info if necessary */
-    if (status->first_rec_num == 0)
-        status->first_rec_num = rec_hdr->rec_num;
-    if (TIME_EQL_ZERO(status->first_write))
-        status->first_write = rec_hdr->timestamp;
-    if (rec_hdr->struct_id == log_wrap_id)
-        status->wrap_time = rec_hdr->timestamp;
+	m0_free(loc_tail_cbdata);
+}
 
-    /* locate first transaction, if needed */
-    if (TIME_EQL_ZERO(status->first_uname))
-        do
-            {
-            /* update other status data */
-            rec_hdr = (rec_hdr_t *)&(log_buf->buf[log_buf->ptr]);
-            last_rec_num = rec_hdr->rec_num;
-            status->last_write = rec_hdr->timestamp;
-            if (rec_hdr->struct_id == log_wrap_id)
-                status->wrap_time = rec_hdr->timestamp;
+void set_trans_status_cb(struct m0_be_cbinfo *cbinfo, int be_status,
+			 m0_be_msg_type_t msg_type)
+{
+	loc_tail_cbdata_t 	*loc_tail_cbdata;
+	log_t 			*log;
+	log_status_t    	*status;   /* status descriptor */
+	log_buf_t       	*log_buf; /* log buffer descriptor */
 
-            if (rec_hdr->struct_id == trans_hdr_id)
-                {                       /* transaction found */
-                status->first_uname = ((trans_hdr_t *)
-                                       rec_hdr)->uname;
-                status->last_uname = ((trans_hdr_t *)
-                                      rec_hdr)->uname;
-                break;
-                }
-            if (rec_hdr->struct_id == log_wrap_id)
-                status->wrap_time = rec_hdr->timestamp;
-            old_ptr = log_buf->ptr;
-            if ((retval = scan_forward(log,NO_SYNCH)) != RVM_SUCCESS)
-                goto err_exit;
-            assert(log->trunc_thread == cthread_self());
-            assert((status->trunc_state & RVM_TRUNC_PHASES)
-                   == RVM_TRUNC_FIND_TAIL);
-            if (rvm_chk_sigint != NULL) /* test for interrupt */
-                if ((*rvm_chk_sigint)(NULL)) goto err_exit;
-            }
-            while (log_buf->ptr != -1); /* tail found, no transactions */
+	rvm_return_t     	 retval = RVM_SUCCESS; /* return value */
 
-    /* re-init scanner sequence checking state since small logs can cause
-       a few records to be rescanned and re-init read buffer at tail
-    */
-    tail = status->log_tail;
-    reset_hdr_chks(log);
-    if ((retval=init_buffer(log,&tail,FORWARD,NO_SYNCH))
-        != RVM_SUCCESS) goto err_exit;
-    assert(log->trunc_thread == cthread_self());
-    assert((status->trunc_state & RVM_TRUNC_PHASES) == RVM_TRUNC_FIND_TAIL);
-    /* see if record at tail is valid, scan until bad record found */
-    if ((retval=validate_rec_forward(log,NO_SYNCH)) != RVM_SUCCESS)
-        goto err_exit;
-    DO_FOREVER
-        {
-        if (log_buf->ptr == -1) break; /* tail located */
-
-        /* compute provisional new tail offset, rec_num, timestamp */
-        rec_hdr = (rec_hdr_t *)(&log_buf->buf[log_buf->ptr]);
-        temp_tail = RVM_ADD_LENGTH_TO_OFFSET(log_buf->offset,
-                        (log_buf->ptr+rec_hdr->rec_length
-                        +sizeof(rec_end_t)));
-        last_rec_num = rec_hdr->rec_num;
-        last_write = rec_hdr->timestamp;
-
-        /* type-specific status data recovery */
-        switch (rec_hdr->struct_id)
-            {
-          case log_wrap_id:
-            set_wrap_status(status,rec_hdr);
-            tail = status->log_start;
-            break;
+	struct timeval   	 last_write; /* last write to log */
 
-          case trans_hdr_id:
-            if ((retval=set_trans_status(log,rec_hdr)) != RVM_SUCCESS)
-                goto err_exit;
-            assert(log->trunc_thread == cthread_self());
-            assert((status->trunc_state & RVM_TRUNC_PHASES)
-                   == RVM_TRUNC_FIND_TAIL);
-            if (log_buf->ptr != -1)
-                tail = temp_tail;       /* update if trans OK */
-            break;
+        loc_tail_cbdata = container_of(cbinfo, loc_tail_cbdata_t, ltc_cbinfo);
+	M0_ASSERT(loc_tail_cbdata != NULL);
 
-          case log_seg_id:
-            status->n_special++;
-            tail = temp_tail;
-            break;
+	log 		= loc_tail_cbdata->ltc_log;
+	status 		= &log->status;
+	log_buf 	= &log->log_buf;
+	last_write 	= status->last_write;
 
-          default:  assert(rvm_false);  /* error - should have header */
-            }
+	if (log_buf->ptr == -1) {
+		goto done_looping;
+	}
 
-        /* scan to next record */
-        if (log_buf->ptr == -1) break; /* tail located */
-        if ((retval=scan_forward(log,NO_SYNCH)) != RVM_SUCCESS)
-            goto err_exit;
-        assert(log->trunc_thread == cthread_self());
-        assert((status->trunc_state & RVM_TRUNC_PHASES) == RVM_TRUNC_FIND_TAIL);
-        if (rvm_chk_sigint != NULL)     /* test for interrupt */
-            if ((*rvm_chk_sigint)(NULL)) goto err_exit;
+	if ((retval = scan_forward(log, NO_SYNCH)) != RVM_SUCCESS) {
+		be_status = -1;
+		msg_type  = retval;
+
+		goto err_exit;
+	}
+
+	assert(log->trunc_thread == cthread_self());
+	assert((status->trunc_state & RVM_TRUNC_PHASES) == RVM_TRUNC_FIND_TAIL);
+
+	if (rvm_chk_sigint != NULL)     /* test for interrupt */
+		if ((*rvm_chk_sigint)(NULL)) {
+			be_status = -1;
+			msg_type  = retval;
+			goto err_exit;
+		}
+
+	loc_tail_vrf_cb(cbinfo, be_status, msg_type);
+
+	goto exit;
+
+done_looping:
+		locate_tail_cb(loc_tail_cbdata);
+		goto exit;
+err_exit:
+	rvm_utlsw 	   = loc_tail_cbdata->ltc_save_rvm_utlsw;
+	status->last_trunc = loc_tail_cbdata->ltc_save_last_trunc;
+
+	assert(log->trunc_thread == cthread_self());
+	assert((status->trunc_state & RVM_TRUNC_PHASES) == RVM_TRUNC_FIND_TAIL);
+
+	if (be_status != 0 && cbinfo->bc_pcbinfo != NULL &&
+	    cbinfo->bc_pcbinfo->bc_cb != NULL) {
+                m0_be_handler_post(cbinfo->bc_pcbinfo, be_status, msg_type);
+                m0_free(loc_tail_cbdata);
         }
-    /* tail found, update in-memory status */
-#ifdef RVM_LOG_TAIL_BUG
-    unprotect_page__Fi(ClobberAddress);
-#endif /* RVM_LOG_TAIL_BUG */
-#ifdef RVM_LOG_TAIL_SHADOW
-    assert(RVM_OFFSET_EQL(log_tail_shadow,status->log_tail));
-#endif /* RVM_LOG_TAIL_SHADOW */
-    status->log_tail = tail;
-#ifdef RVM_LOG_TAIL_SHADOW
-	RVM_ASSIGN_OFFSET(log_tail_shadow,status->log_tail);
-#endif /* RVM_LOG_TAIL_SHADOW */
-#ifdef RVM_LOG_TAIL_BUG
-    protect_page__Fi(ClobberAddress);
-#endif /* RVM_LOG_TAIL_BUG */
-    status->last_write = last_write;
-    if (RVM_OFFSET_EQL(status->log_head,status->log_tail))
-        clear_log_status(log);          /* log empty */
-    else
-        {                               /* log not empty */
-        status->log_empty = rvm_false;
+exit:;
+}
+
+/** locate_tail_validate_rec_forward. */
+void loc_tail_vrf_cb(struct m0_be_cbinfo *cbinfo, int be_status,
+		     m0_be_msg_type_t msg_type)
+{
+	loc_tail_cbdata_t 	*loc_tail_cbdata;
+	log_t 			*log;
+	log_status_t    	*status;   /* status descriptor */
+	log_buf_t       	*log_buf; /* log buffer descriptor */
+	rec_hdr_t       	*rec_hdr; /* current record scanned in buffer */
+
+	rvm_offset_t     	 tail;               /* tail offset */
+	rvm_offset_t     	 temp_tail;          /* tail offset temp */
+	rvm_return_t     	 retval = RVM_SUCCESS; /* return value */
+
+	struct timeval   	 last_write; /* last write to log */
+	uint32_t		 set_trans_called = rvm_false;
+
+        loc_tail_cbdata = container_of(cbinfo, loc_tail_cbdata_t, ltc_cbinfo);
+	M0_ASSERT(loc_tail_cbdata != NULL);
+
+	log 		= loc_tail_cbdata->ltc_log;
+	status 		= &log->status;
+	log_buf 	= &log->log_buf;
+	last_write 	= status->last_write;
+
+	if (log_buf->ptr == -1)		/* tail located */
+		goto done_looping;
+
+	/* compute provisional new tail offset, rec_num, timestamp */
+	rec_hdr   = (rec_hdr_t *)(&log_buf->buf[log_buf->ptr]);
+	temp_tail = RVM_ADD_LENGTH_TO_OFFSET(log_buf->offset,
+		    (log_buf->ptr+rec_hdr->rec_length + sizeof(rec_end_t)));
+
+	loc_tail_cbdata->ltc_last_rec_num = rec_hdr->rec_num;
+	last_write   = rec_hdr->timestamp;
+
+	/* type-specific status data recovery */
+	switch (rec_hdr->struct_id) {
+		case log_wrap_id:
+			set_wrap_status(status, rec_hdr);
+			tail = status->log_start;
+			break;
+		case trans_hdr_id:
+			cbinfo->bc_cb = set_trans_status_cb;
+			retval = set_trans_status(log, rec_hdr);
+			if (retval != RVM_SUCCESS) {
+				be_status = -1;
+				msg_type = retval;
+				goto err_exit;
+			}
 
-        if (status->next_rec_num <= last_rec_num)
-            status->next_rec_num = last_rec_num+1;
-        if (status->last_rec_num != last_rec_num)
-            status->last_rec_num = last_rec_num;
+			set_trans_called = rvm_true;
+			/** This needs to be removed when set_trans_status
+			 * becomes async. */
+			set_trans_status_cb(cbinfo, be_status, msg_type);
+			assert(log->trunc_thread == cthread_self());
+			assert((status->trunc_state & RVM_TRUNC_PHASES) == RVM_TRUNC_FIND_TAIL);
+			if (log_buf->ptr != -1)
+				/* update if trans OK */
+				tail = temp_tail;
+			break;
+		case log_seg_id:
+			status->n_special++;
+			tail = temp_tail;
+			break;
+		default:
+			/* error - should have header */
+			assert(rvm_false);
+	}
+
+	if(!set_trans_called) {
+		set_trans_status_cb(cbinfo, be_status, msg_type);
+	}
+
+	goto exit;
+
+done_looping:
+	locate_tail_cb(loc_tail_cbdata);
+	goto exit;
+err_exit:
+	rvm_utlsw = loc_tail_cbdata->ltc_save_rvm_utlsw;
+	status->last_trunc = loc_tail_cbdata->ltc_save_last_trunc;
+
+	assert(log->trunc_thread == cthread_self());
+	assert((status->trunc_state & RVM_TRUNC_PHASES) == RVM_TRUNC_FIND_TAIL);
+
+	if (be_status != 0 && cbinfo->bc_pcbinfo != NULL &&
+	    cbinfo->bc_pcbinfo->bc_cb != NULL) {
+                m0_be_handler_post(cbinfo->bc_pcbinfo, be_status, msg_type);
+                m0_free(loc_tail_cbdata);
         }
+exit:;
+}
 
-exit:
-    status->valid = rvm_true;
+void loc_tail_init_buf_cb1(struct m0_be_cbinfo *cbinfo, int be_status,
+			   m0_be_msg_type_t msg_type)
+{
+	loc_tail_cbdata_t 	*loc_tail_cbdata;
+	log_t 			*log;
+	log_status_t    	*status;   /* status descriptor */
+	log_buf_t       	*log_buf; /* log buffer descriptor */
+
+	rvm_return_t     	 retval = RVM_SUCCESS; /* return value */
+
+	struct timeval   	 last_write; /* last write to log */
+
+
+        loc_tail_cbdata = container_of(cbinfo, loc_tail_cbdata_t, ltc_cbinfo);
+	M0_ASSERT(loc_tail_cbdata != NULL);
+
+	log 		= loc_tail_cbdata->ltc_log;
+	status 		= &log->status;
+	log_buf 	= &log->log_buf;
+	last_write 	= status->last_write;
+
+
+	/* see if record at tail is valid, scan until bad record found */
+	cbinfo->bc_cb = loc_tail_vrf_cb;
+
+	if ((retval = validate_rec_forward(log, NO_SYNCH)) != RVM_SUCCESS) {
+		be_status = -1;
+		msg_type = retval;
+		goto err_exit;
+	}
+
+	goto exit;
 err_exit:
-    rvm_utlsw = save_rvm_utlsw;
-    status->last_trunc = save_last_trunc;
-    assert(log->trunc_thread == cthread_self());
-    assert((status->trunc_state & RVM_TRUNC_PHASES) == RVM_TRUNC_FIND_TAIL);
-    return retval;
-    }
+	rvm_utlsw 	   = loc_tail_cbdata->ltc_save_rvm_utlsw;
+	status->last_trunc = loc_tail_cbdata->ltc_save_last_trunc;
+
+	assert(log->trunc_thread == cthread_self());
+	assert((status->trunc_state & RVM_TRUNC_PHASES) == RVM_TRUNC_FIND_TAIL);
+
+	if (status != 0 && cbinfo->bc_pcbinfo != NULL &&
+	    cbinfo->bc_pcbinfo->bc_cb != NULL) {
+                m0_be_handler_post(cbinfo->bc_pcbinfo, be_status, msg_type);
+                m0_free(loc_tail_cbdata);
+        }
+exit:;
+}
+
+void loc_tail_scan_forward_cb(loc_tail_cbdata_t *loc_tail_cbdata)
+{
+	log_t 			*log;
+	log_status_t    	*status;   /* status descriptor */
+	log_buf_t       	*log_buf; /* log buffer descriptor */
+	struct m0_be_cbinfo	*cbinfo;
+
+	rvm_offset_t     	 tail;               /* tail offset */
+	rvm_return_t     	 retval = RVM_SUCCESS; /* return value */
+
+	struct timeval   	 last_write; /* last write to log */
+
+	int			 be_status = 0;
+	m0_be_msg_type_t	 msg_type = M0_BE_SUCCESS;
+
+
+	M0_ASSERT(loc_tail_cbdata != NULL);
+
+	log 		= loc_tail_cbdata->ltc_log;
+	cbinfo		= &loc_tail_cbdata->ltc_cbinfo;
+	status 		= &log->status;
+	log_buf 	= &log->log_buf;
+	last_write 	= status->last_write;
+
+	/* re-init scanner sequence checking state since small logs can cause
+	a few records to be rescanned and re-init read buffer at tail
+	*/
+	tail = status->log_tail;
+	reset_hdr_chks(log);
+
+	cbinfo->bc_cb = loc_tail_init_buf_cb1;
+
+	/* need to update status: init read buffer at head */
+	retval = init_buffer(log, &tail, FORWARD, NO_SYNCH);
+
+	assert(log->trunc_thread == cthread_self());
+	assert((status->trunc_state & RVM_TRUNC_PHASES) == RVM_TRUNC_FIND_TAIL);
+
+	if (retval != RVM_SUCCESS) {
+		be_status	= -1;
+		msg_type 	= retval;
+	}
+
+	rvm_utlsw 	   = loc_tail_cbdata->ltc_save_rvm_utlsw;
+	status->last_trunc = loc_tail_cbdata->ltc_save_last_trunc;
+
+	assert(log->trunc_thread == cthread_self());
+	assert((status->trunc_state & RVM_TRUNC_PHASES) == RVM_TRUNC_FIND_TAIL);
+
+	if (status != 0 && cbinfo->bc_pcbinfo != NULL &&
+	    cbinfo->bc_pcbinfo->bc_cb != NULL) {
+                m0_be_handler_post(cbinfo->bc_pcbinfo, be_status, msg_type);
+                m0_free(loc_tail_cbdata);
+        }
+}
+
+void loc_tail_init_buf_loop_cb(struct m0_be_cbinfo *cbinfo, int be_status,
+			       m0_be_msg_type_t msg_type)
+{
+	loc_tail_cbdata_t 	*loc_tail_cbdata;
+	log_t 			*log;
+	log_status_t    	*status;   /* status descriptor */
+	log_buf_t       	*log_buf; /* log buffer descriptor */
+	rec_hdr_t       	*rec_hdr; /* current record scanned in buffer */
+
+	rvm_return_t     	 retval = RVM_SUCCESS; /* return value */
+
+	long             	 old_ptr;  /* buffer ptr to last record found */
+	struct timeval   	 last_write; /* last write to log */
+
+
+        loc_tail_cbdata = container_of(cbinfo, loc_tail_cbdata_t, ltc_cbinfo);
+	M0_ASSERT(loc_tail_cbdata != NULL);
+
+	log 		= loc_tail_cbdata->ltc_log;
+	status 		= &log->status;
+	log_buf 	= &log->log_buf;
+	last_write 	= status->last_write;
+
+	assert(log->trunc_thread == cthread_self());
+	assert((status->trunc_state & RVM_TRUNC_PHASES) == RVM_TRUNC_FIND_TAIL);
+
+	if (rvm_chk_sigint != NULL)  /* test for interrupt */
+		if ((*rvm_chk_sigint)(NULL)) {
+			be_status = -1;
+			msg_type  = RVM_EINTERNAL;
+			goto err_exit;
+		}
+
+	if(log_buf->ptr != -1); /* tail found, no transactions */
+		goto done_looping;
+
+	/* update other status data */
+	rec_hdr = (rec_hdr_t *)&(log_buf->buf[log_buf->ptr]);
+	loc_tail_cbdata->ltc_last_rec_num = rec_hdr->rec_num;
+	status->last_write = rec_hdr->timestamp;
+
+	if (rec_hdr->struct_id == log_wrap_id)
+		status->wrap_time = rec_hdr->timestamp;
+
+	if (rec_hdr->struct_id == trans_hdr_id) {
+	/* transaction found */
+		status->first_uname = ((trans_hdr_t *) rec_hdr)->uname;
+		status->last_uname = ((trans_hdr_t *) rec_hdr)->uname;
+		goto done_looping;
+	}
+
+	if (rec_hdr->struct_id == log_wrap_id)
+		status->wrap_time = rec_hdr->timestamp;
+
+	old_ptr = log_buf->ptr;
+
+	if ((retval = scan_forward(log, NO_SYNCH)) != RVM_SUCCESS) {
+		be_status = -1;
+		msg_type  = retval;
+
+		goto err_exit;
+	}
+
+	assert(log->trunc_thread == cthread_self());
+	assert((status->trunc_state & RVM_TRUNC_PHASES) == RVM_TRUNC_FIND_TAIL);
+	if (rvm_chk_sigint != NULL) /* test for interrupt */
+		if ((*rvm_chk_sigint)(NULL)) {
+			be_status = -1;
+			msg_type  = RVM_EINTERNAL;
+			goto err_exit;
+		}
+done_looping:
+	loc_tail_scan_forward_cb(loc_tail_cbdata);
+	goto exit;
+
+err_exit:
+	rvm_utlsw = loc_tail_cbdata->ltc_save_rvm_utlsw;
+	status->last_trunc = loc_tail_cbdata->ltc_save_last_trunc;
+	assert(log->trunc_thread == cthread_self());
+	assert((status->trunc_state & RVM_TRUNC_PHASES) == RVM_TRUNC_FIND_TAIL);
+
+	if (status != 0 && cbinfo->bc_pcbinfo!= NULL &&
+	    cbinfo->bc_pcbinfo->bc_cb != NULL) {
+                m0_be_handler_post(cbinfo->bc_pcbinfo, be_status, msg_type);
+                m0_free(loc_tail_cbdata);
+        }
+exit:;
+}
+
+void loc_tail_init_buf_cb(struct m0_be_cbinfo *cbinfo, int be_status,
+			  m0_be_msg_type_t msg_type)
+{
+	loc_tail_cbdata_t 	*loc_tail_cbdata;
+	log_t 			*log;
+	log_status_t    	*status;   /* status descriptor */
+	log_buf_t       	*log_buf; /* log buffer descriptor */
+	rec_hdr_t       	*rec_hdr; /* current record scanned in buffer */
+
+	rvm_return_t     	 retval = RVM_SUCCESS; /* return value */
+
+	long             	 old_ptr;  /* buffer ptr to last record found */
+	struct timeval   	 last_write; /* last write to log */
+
+
+        loc_tail_cbdata = container_of(cbinfo, loc_tail_cbdata_t, ltc_cbinfo);
+	M0_ASSERT(loc_tail_cbdata != NULL);
+
+	log 		= loc_tail_cbdata->ltc_log;
+	status 		= &log->status;
+	log_buf 	= &log->log_buf;
+	last_write 	= status->last_write;
+
+	assert(log->trunc_thread == cthread_self());
+	assert((status->trunc_state & RVM_TRUNC_PHASES) == RVM_TRUNC_FIND_TAIL);
+
+	/* validate 1st record, none ==> log empty */
+	rec_hdr = (rec_hdr_t *)&(log_buf->buf[log_buf->ptr]);
+	if (!validate_hdr(log, rec_hdr, NULL, FORWARD)) {
+		#ifdef RVM_LOG_TAIL_BUG
+		unprotect_page__Fi(ClobberAddress);
+		#endif /* RVM_LOG_TAIL_BUG */
+		#ifdef RVM_LOG_TAIL_SHADOW
+		assert(RVM_OFFSET_EQL(log_tail_shadow,status->log_tail));
+		#endif /* RVM_LOG_TAIL_SHADOW */
+		status->log_tail = status->log_head;
+		#ifdef RVM_LOG_TAIL_SHADOW
+		RVM_ASSIGN_OFFSET(log_tail_shadow,status->log_tail);
+		#endif /* RVM_LOG_TAIL_SHADOW */
+		#ifdef RVM_LOG_TAIL_BUG
+		protect_page__Fi(ClobberAddress);
+		#endif /* RVM_LOG_TAIL_BUG */
+		clear_log_status(log);
+		goto status_valid;
+	}
+
+	/* update status block head info if necessary */
+	if (status->first_rec_num == 0)
+		status->first_rec_num = rec_hdr->rec_num;
+
+	if (TIME_EQL_ZERO(status->first_write))
+		status->first_write = rec_hdr->timestamp;
+
+	if (rec_hdr->struct_id == log_wrap_id)
+		status->wrap_time = rec_hdr->timestamp;
+
+	/* locate first transaction, if needed */
+	if (TIME_EQL_ZERO(status->first_uname)) {
+		/* update other status data */
+		rec_hdr = (rec_hdr_t *)&(log_buf->buf[log_buf->ptr]);
+		loc_tail_cbdata->ltc_last_rec_num = rec_hdr->rec_num;
+		status->last_write = rec_hdr->timestamp;
+
+		if (rec_hdr->struct_id == log_wrap_id)
+			status->wrap_time = rec_hdr->timestamp;
+
+		if (rec_hdr->struct_id == trans_hdr_id) {
+		/* transaction found */
+			status->first_uname = ((trans_hdr_t *) rec_hdr)->uname;
+			status->last_uname = ((trans_hdr_t *) rec_hdr)->uname;
+			goto done_looping;
+		}
+
+		if (rec_hdr->struct_id == log_wrap_id)
+			status->wrap_time = rec_hdr->timestamp;
+
+		old_ptr = log_buf->ptr;
+		cbinfo->bc_cb = loc_tail_init_buf_loop_cb;
+		if ((retval = scan_forward(log,NO_SYNCH)) != RVM_SUCCESS) {
+			be_status = -1;
+			msg_type  = retval;
+			goto err_exit;
+		}
+	}
+
+	/* Need to remove this when scan_forward becomes async. */
+	loc_tail_init_buf_loop_cb(cbinfo, be_status, msg_type);
+
+	goto exit;
+
+status_valid:
+	status->valid = rvm_true;
+
+	rvm_utlsw = loc_tail_cbdata->ltc_save_rvm_utlsw;
+	status->last_trunc = loc_tail_cbdata->ltc_save_last_trunc;
+	assert(log->trunc_thread == cthread_self());
+	assert((status->trunc_state & RVM_TRUNC_PHASES) == RVM_TRUNC_FIND_TAIL);
+
+	if (cbinfo->bc_pcbinfo != NULL && cbinfo->bc_pcbinfo->bc_cb != NULL) {
+                m0_be_handler_post(cbinfo->bc_pcbinfo, be_status, msg_type);
+        }
+	m0_free(loc_tail_cbdata);
+	goto exit;
+
+done_looping:
+	loc_tail_scan_forward_cb(loc_tail_cbdata);
+	goto exit;
+
+err_exit:
+	rvm_utlsw = loc_tail_cbdata->ltc_save_rvm_utlsw;
+	status->last_trunc = loc_tail_cbdata->ltc_save_last_trunc;
+	assert(log->trunc_thread == cthread_self());
+	assert((status->trunc_state & RVM_TRUNC_PHASES) == RVM_TRUNC_FIND_TAIL);
+
+	if (status != 0 && cbinfo->bc_pcbinfo!= NULL &&
+	    cbinfo->bc_pcbinfo->bc_cb != NULL) {
+                m0_be_handler_post(cbinfo->bc_pcbinfo, be_status, msg_type);
+                m0_free(loc_tail_cbdata);
+        }
+exit:;
+}
+
+/* Locate tail, update in-memory copy of status block; always reads forward */
+rvm_return_t locate_tail(log, cbinfo)
+log_t *log;
+struct m0_be_cbinfo *cbinfo;
+{
+	log_status_t    	*status  = &log->status;   /* status descriptor */
+	loc_tail_cbdata_t 	*loc_tail_cbdata;
+	struct m0_be_cbinfo	*ltc_cbinfo;
+
+	rvm_return_t     	 retval = RVM_SUCCESS; /* return value */
+
+	int 		 	 be_status   = 0;
+	m0_be_msg_type_t 	 msg_type = M0_BE_SUCCESS;
+	rvm_bool_t       	 save_rvm_utlsw = rvm_utlsw;
+
+	M0_ALLOC_PTR(loc_tail_cbdata);
+	M0_ASSERT(loc_tail_cbdata != NULL);
+
+	loc_tail_cbdata->ltc_last_rec_num = 0;
+
+	assert(log->trunc_thread == cthread_self());
+	assert((status->trunc_state & RVM_TRUNC_PHASES) == ZERO);
+	status->trunc_state |= RVM_TRUNC_FIND_TAIL;
+
+	/* initialize scanner sequence checking state and buffers */
+	rvm_utlsw = rvm_false;
+	reset_hdr_chks(log);
+	clear_aux_buf(log);
+
+	/* if truncation caught in crash, reset head */
+	if (!RVM_OFFSET_EQL_ZERO(status->prev_log_head)) {
+		status->log_head 	= status->prev_log_head;
+		status->last_rec_num 	= status->next_rec_num - 1;
+	}
+
+	/* set temporary timestamp for record validation */
+	loc_tail_cbdata->ltc_save_last_trunc = status->last_trunc;
+	make_uname(&status->last_trunc);
+	if (TIME_GTR(loc_tail_cbdata->ltc_save_last_trunc, status->last_trunc)) {
+		/* date/time wrong! */
+		retval 	   	= RVM_EINTERNAL;
+		rvm_errmsg 	= ERR_DATE_SKEW;
+		be_status	= -1;
+		msg_type 	= retval;
+		goto err_exit;
+	}
+
+	loc_tail_cbdata->ltc_log 	    = log;
+	ltc_cbinfo 		 	    = &loc_tail_cbdata->ltc_cbinfo;
+	loc_tail_cbdata->ltc_save_rvm_utlsw = save_rvm_utlsw;
+
+        m0_be_cbinfo_copy_helper(cbinfo, ltc_cbinfo, loc_tail_init_buf_cb);
+
+	/* need to update status: init read buffer at head */
+	retval = init_buffer(log, &status->log_head, FORWARD, NO_SYNCH);
+
+	if (retval != RVM_SUCCESS) {
+		be_status	= -1;
+		msg_type 	= retval;
+		goto err_exit;
+	}
+
+	/* Need to remove this when init_buffer becomes async. */
+        loc_tail_init_buf_cb(ltc_cbinfo, be_status, msg_type);
+
+	goto exit;
+
+err_exit:
+	rvm_utlsw 	   = save_rvm_utlsw;
+	status->last_trunc = loc_tail_cbdata->ltc_save_last_trunc;
+
+	assert(log->trunc_thread == cthread_self());
+	assert((status->trunc_state & RVM_TRUNC_PHASES) == RVM_TRUNC_FIND_TAIL);
+
+	if (be_status != 0 && cbinfo!= NULL && cbinfo->bc_cb != NULL) {
+                m0_be_handler_post(cbinfo, be_status, msg_type);
+                m0_free(loc_tail_cbdata);
+        }
+exit:;
+	return retval;
+}
+
 /* add segment short id to dictionary */
 rvm_return_t enter_seg_dict(log,seg_code)
     log_t           *log;
@@ -3464,82 +3889,50 @@ exit_log_recover:
 	}
 }
 
-/* recover committed state from log */
-rvm_return_t log_recover(log, count, is_daemon, flag, cbinfo)
-    log_t               *log;               /* log descriptor */
-    rvm_length_t        *count;             /* ptr to statistics counter */
-    rvm_bool_t           is_daemon;          /* true if called by daemon */
-    rvm_length_t         flag;               /* truncation type flag */
-    struct m0_be_cbinfo *cbinfo;
+void lr_locate_tail_cb(cbinfo, be_status, msg)
+	struct m0_be_cbinfo	*cbinfo;
+	int			 be_status;
+	m0_be_msg_type_t	 msg;
 {
-        lrc_cbdata_t        *lrc_cbdata;
-        struct m0_be_cbinfo *lrc_cbinfo;
-        log_status_t        *status = &log->status; /* log status descriptor */
-        log_daemon_t        *daemon = &log->daemon; /* log daemon descriptor */
-        int                  kretval;
-        int                  be_status = 0;
-        m0_be_msg_type_t     msg       = M0_BE_SUCCESS;
-        rvm_bool_t           do_truncation = rvm_false;
+	lrc_cbdata_t        *lrc_cbdata;
+	log_t		    *log;
+        log_status_t        *status;
+        log_daemon_t        *daemon;
+
+	rvm_bool_t           is_daemon;
         rvm_return_t         retval = RVM_SUCCESS;
-        rvm_length_t         new_1st_rec_num = 0;
 
-        printf("\nfunction : %s\n", __FUNCTION__);
+        rvm_bool_t           do_truncation;
+        rvm_length_t         new_1st_rec_num;
+	rvm_length_t        *count;             /* ptr to statistics counter */
 
-	M0_ALLOC_PTR(lrc_cbdata);
-	if (lrc_cbdata == NULL) {
-		be_status = -1;
-		retval    = msg = -ENOMEM;
+	printf("\nfunction : %s\n", __FUNCTION__);
+
+	if (be_status != 0)
 		goto exit_log_recover;
-	}
 
-	/* Prepare lrc_cbdata. */
-	lrc_cbdata->lrc_log             = log;
-	lrc_cbdata->lrc_is_daemon       = is_daemon;
+	lrc_cbdata      = container_of(cbinfo, lrc_cbdata_t, lrc_cbinfo);
+	log	        = lrc_cbdata->lrc_log;
+	do_truncation   = lrc_cbdata->lrc_do_trunc;
+	is_daemon	= lrc_cbdata->lrc_is_daemon;
+	status	        = &log->status;
+	daemon	        = &log->daemon;
+	new_1st_rec_num = lrc_cbdata->lrc_recnr;
+	count		= lrc_cbdata->lrc_count;
 
-	/* Prepare cbinfo to be given to apply_mods. */
-	lrc_cbinfo             = &lrc_cbdata->lrc_cbinfo;
+	printf("\nfunction : %s before crit sec be_status : %d\n", __FUNCTION__,be_status);
 
-        X(start)
         CRITICAL(log->truncation_lock,      /* begin truncation lock crit sec */
         {
-                /* capture truncation thread & flag for checking */
-                assert(log->trunc_thread == (cthread_t)NULL);
-                assert(status->trunc_state == ZERO);
-                log->trunc_thread = cthread_self();
-                status->trunc_state = flag;
-
-                X(dev_lock)
                 CRITICAL(log->dev_lock, /* begin dev_lock crit sec */
                         {
-                                /* process statistics */
-                                assert(log->trunc_thread == cthread_self());
-                                kretval= gettimeofday(&trunc_start_time,
-                                                  (struct timezone *)NULL);
-                                if (kretval != 0) {
-                                        retval = RVM_EIO;
-                                        goto err_exit1;
-                                }
-
-                                last_tree_build_time = 0;
-                                last_tree_apply_time = 0;
-
-                                X(in_recovery)
-                                /* phase 1: locate tail & start new epoch */
-                                if (log->in_recovery) {
-                                        if ((retval = locate_tail(log)) !=
-                                            RVM_SUCCESS)
-                                                goto err_exit1;
-                                        assert((status->trunc_state &
-                                                RVM_TRUNC_PHASES) ==
-                                                RVM_TRUNC_FIND_TAIL);
-                                }
-
                                 assert(log->trunc_thread == cthread_self());
 
                                 /* test for interrupt */
                                 if (rvm_chk_sigint != NULL)
                                         if ((*rvm_chk_sigint)(NULL))
                                                 goto err_exit1;
+				printf("\nfunction : %s after rvm_chk_sigint be_status : %d\n", __FUNCTION__,be_status);
 
                                 /* see if truncation actually needed */
                                 if (RVM_OFFSET_EQL(status->log_tail,
@@ -3555,12 +3948,9 @@ rvm_return_t log_recover(log, count, is_daemon, flag, cbinfo)
 					lrc_cbdata->lrc_is_epoch_done = rvm_true;
 					lrc_cbdata->lrc_do_trunc      = do_truncation;
 
-					m0_be_cbinfo_copy_helper(cbinfo,
-								 lrc_cbinfo,
-								 lr_epoch_cb);
+					cbinfo->bc_cb = lr_epoch_cb;
 
-				   	retval = new_epoch(log, count,
-							   lrc_cbinfo);
+				   	retval = new_epoch(log, count, cbinfo);
                                         /* switch epochs */
 					msg = retval;
                                         if (retval != RVM_SUCCESS) {
@@ -3590,6 +3980,8 @@ rvm_return_t log_recover(log, count, is_daemon, flag, cbinfo)
                                 }
                         }); /* end dev_lock crit sec */
 
+		printf("\nfunction : %s after rvm_chk_sigint be_status : %d\n", __FUNCTION__,be_status);
+
                 if (retval != RVM_SUCCESS) {
                         be_status = -1;
                         msg       = retval;
@@ -3605,9 +3997,11 @@ rvm_return_t log_recover(log, count, is_daemon, flag, cbinfo)
 	lrc_cbdata->lrc_is_epoch_done	= rvm_false;
 	lrc_cbdata->lrc_do_trunc	= do_truncation;
 	/* Calling this function just to setup lrc_cbinfo with cbinfo. */
-	m0_be_cbinfo_copy_helper(cbinfo, lrc_cbinfo, NULL);
+	/*cbinfo->bc_cb = lrc_cbinfo;*/
 
-	lr_epoch_cb(lrc_cbinfo, be_status, msg);
+	/*m0_be_cbinfo_copy_helper(cbinfo, lrc_cbinfo, NULL);*/
+
+	lr_epoch_cb(cbinfo, be_status, msg);
 	goto exit_log_recover;
 
 
@@ -3645,8 +4039,139 @@ rvm_return_t log_recover(log, count, is_daemon, flag, cbinfo)
 		                           be_status, msg);
 			m0_free(lrc_cbdata);
                 }
+}
+
+/* recover committed state from log */
+rvm_return_t log_recover(log, count, is_daemon, flag, cbinfo)
+    log_t               *log;               /* log descriptor */
+    rvm_length_t        *count;             /* ptr to statistics counter */
+    rvm_bool_t           is_daemon;          /* true if called by daemon */
+    rvm_length_t         flag;               /* truncation type flag */
+    struct m0_be_cbinfo *cbinfo;
+{
+        lrc_cbdata_t        *lrc_cbdata;
+        struct m0_be_cbinfo *lrc_cbinfo;
+        log_status_t        *status = &log->status; /* log status descriptor */
+        log_daemon_t        *daemon = &log->daemon; /* log daemon descriptor */
+        int                  kretval;
+        int                  be_status = 0;
+        m0_be_msg_type_t     msg       = M0_BE_SUCCESS;
+        rvm_return_t         retval = RVM_SUCCESS;
+
+        printf("\nfunction : %s\n", __FUNCTION__);
+
+	M0_ALLOC_PTR(lrc_cbdata);
+	if (lrc_cbdata == NULL) {
+		be_status = -1;
+		retval    = msg = -ENOMEM;
+		goto exit_log_recover;
+	}
+
+	/* Prepare lrc_cbdata. */
+	lrc_cbdata->lrc_log             = log;
+	lrc_cbdata->lrc_is_daemon       = is_daemon;
+	lrc_cbdata->lrc_count       	= count;
+
+	/* Prepare cbinfo to be given to apply_mods. */
+	lrc_cbinfo             = &lrc_cbdata->lrc_cbinfo;
+
+        X(start)
+        CRITICAL(log->truncation_lock,      /* begin truncation lock crit sec */
+        {
+                /* capture truncation thread & flag for checking */
+                assert(log->trunc_thread == (cthread_t)NULL);
+                assert(status->trunc_state == ZERO);
+                log->trunc_thread = cthread_self();
+                status->trunc_state = flag;
+
+                X(dev_lock)
+                CRITICAL(log->dev_lock, /* begin dev_lock crit sec */
+                        {
+                                /* process statistics */
+                                assert(log->trunc_thread == cthread_self());
+                                kretval= gettimeofday(&trunc_start_time,
+                                                  (struct timezone *)NULL);
+                                if (kretval != 0) {
+                                        retval = RVM_EIO;
+                                        goto err_exit1;
+                                }
+
+                                last_tree_build_time = 0;
+                                last_tree_apply_time = 0;
+
+                                X(in_recovery)
+                                /* phase 1: locate tail & start new epoch */
+				m0_be_cbinfo_copy_helper(cbinfo, lrc_cbinfo,
+							 lr_locate_tail_cb);
+                                if (log->in_recovery) {
+					retval = locate_tail(log, lrc_cbinfo);
+                                        if (retval != RVM_SUCCESS)
+                                        assert((status->trunc_state &
+                                                RVM_TRUNC_PHASES) ==
+                                                RVM_TRUNC_FIND_TAIL);
+                                }
+				else {
+					printf("\nfunction : %s !log->in_recovery", __FUNCTION__);
+					lr_locate_tail_cb(lrc_cbinfo, be_status,
+							  msg);
+
+				}
+X(err_exit1)
+	err_exit1:;
+                        }); /* end dev_lock crit sec */
+	}); /* end truncation_lock crit sec */
+
+	if (is_daemon) {
+		mutex_lock(&daemon->lock);
+		assert(log->daemon.thread == cthread_self());
+		assert(daemon->state == truncating);
+		assert((status->trunc_state & RVM_ASYNC_TRUNCATE) != 0);
+		condition_signal(&daemon->flush_flag);
+		mutex_unlock(&daemon->lock);
+	}
+
+	if (retval != RVM_SUCCESS) {
+		be_status = -1;
+		msg       = retval;
+		goto err_exit;
+	}
+
+	goto exit_log_recover;
+err_exit:
+        CRITICAL(log->truncation_lock,   /* begin truncation lock crit sec */
+	{
+                /* wake up any threads waiting on a truncation */
+                assert(log->trunc_thread == cthread_self());
+                CRITICAL(daemon->lock,        /* begin daemon->lock crit sec */
+                {
+                        assert(log->trunc_thread == cthread_self());
+                        if (is_daemon) {
+                        assert(log->daemon.thread == cthread_self());
+                        assert((status->trunc_state &
+                                        RVM_ASYNC_TRUNCATE) != 0);
+
+                        assert(daemon->state == truncating);
+                        if (retval != RVM_SUCCESS)
+                        daemon->state = error;
+                        }
+
+                        assert(log->trunc_thread == cthread_self());
+                }); /* end daemon->lock crit sec */
+
+                log->trunc_thread   = (cthread_t)NULL;
+                status->trunc_state = ZERO;
+
+        }); /* end truncation lock crit sec */
+
+exit_log_recover:
+	if (be_status != 0 && cbinfo != NULL && cbinfo->bc_cb != NULL) {
+		m0_be_handler_post(cbinfo->bc_pcbinfo, be_status, msg);
+		m0_free(lrc_cbdata);
+	}
+
         return retval;
 }
+
 #undef X
 
 void rt_flush_log_cb(struct m0_be_cbinfo *cbinfo, int status,
diff --git a/rvm/rvm_logstatus.c b/rvm/rvm_logstatus.c
index 68b1941..bb959a5 100644
--- a/rvm/rvm_logstatus.c
+++ b/rvm/rvm_logstatus.c
@@ -680,7 +680,8 @@ exit:
                 m0_free(rcl_cbdata);
         }
         return retval;
-    }
+}
+
 /* accumulate running statistics totals */
 void copy_log_stats(log)
     log_t           *log;
@@ -756,11 +757,12 @@ void copy_log_stats(log)
         status->trans_elims[i] = 0;
         }
     ZERO_TIME(status->flush_time);
-    }
+}
+
 /* clear non-permenant log status area fields */
 void clear_log_status(log)
     log_t           *log;
-    {
+{
     log_status_t    *status = &log->status; /* status area descriptor */
 
     assert(((&log->dev == &default_log->dev) && (!rvm_utlsw)) ?
@@ -781,7 +783,7 @@ void clear_log_status(log)
     RVM_ZERO_OFFSET(status->prev_log_tail);
 
     copy_log_stats(log);
-    }
+}
 /* log status block initialization */
 rvm_return_t init_log_status(log, cbinfo)
     log_t                *log;               /* log descriptor */
diff --git a/rvm/rvm_private.h b/rvm/rvm_private.h
index 203b995..cc16b52 100644
--- a/rvm/rvm_private.h
+++ b/rvm/rvm_private.h
@@ -1836,6 +1836,7 @@ typedef struct log_recover_cbdata {
         m0_bindex_t             *lrc_io_offset;
         m0_bcount_t             *lrc_io_count;
         void                   **lrc_io_addr;
+	rvm_length_t		*lrc_count;
 }lrc_cbdata_t;
 
 /* wait_for_space_cbdata. */
@@ -1882,6 +1883,14 @@ typedef struct check_dependency_cbdata {
 	seg_t			*cdc_seg;
 } chk_depend_cbdata_t;
 
+typedef struct loc_tail_cbdata {
+	struct m0_be_cbinfo	 ltc_cbinfo;
+	log_t			*ltc_log;
+	rvm_bool_t		 ltc_save_rvm_utlsw;
+	rvm_length_t		 ltc_last_rec_num;
+	struct timeval           ltc_save_last_trunc;
+} loc_tail_cbdata_t;
+
 void rvm_initialize_cb(struct m0_be_cbinfo *cbinfo, int status,
                        m0_be_msg_type_t msg_type);
 
-- 
1.8.3.2

