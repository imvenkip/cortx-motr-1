From 3fa01edac81901f59817bfd01ad68a99dbc7de88 Mon Sep 17 00:00:00 2001
From: Zishan Shaikh <zishan_shaikh@xyratex.com>
Date: Wed, 8 May 2013 07:24:20 -0700
Subject: [PATCH 088/121] Splitting rds_load_heap and rvm_load_segment

---
 be/seg.c                  |  78 +++++++----
 rvm/rds_private.h         |   8 +-
 rvm/rds_start.c           |  88 ++++++++----
 rvm/rds_zap.c             |   4 +-
 rvm/rvm_loadseg.c         | 340 +++++++++++++++++++++++++++++++++-------------
 rvm/rvm_segment.h         |   3 +-
 rvm/rvm_segment_private.h |  12 +-
 7 files changed, 382 insertions(+), 151 deletions(-)

diff --git a/be/seg.c b/be/seg.c
index 18171f9..63e93e9 100644
--- a/be/seg.c
+++ b/be/seg.c
@@ -426,7 +426,7 @@ M0_INTERNAL void m0_be_seg_create_cb(struct m0_be_cbinfo *cbinfo, int status,
 		     cbinfo);
 exit:
         if (status != 0 && cbinfo->bc_pcbinfo != NULL &&
-           cbinfo->bc_pcbinfo->bc_cb != NULL) {
+            cbinfo->bc_pcbinfo->bc_cb != NULL) {
                 m0_be_handler_post(cbinfo->bc_pcbinfo, status, msg_type);
 		m0_free(bs_cbdata);
         }
@@ -448,24 +448,20 @@ M0_INTERNAL void m0_bs_create_rds_zap_cb(struct m0_be_cbinfo *cbinfo,
 
         bs_cbdata = container_of(cbinfo, struct m0_be_seg_cbdata, bsc_cbinfo);
         seg       = bs_cbdata->bsc_seg;
-
         M0_ASSERT(seg != NULL);
 
-        cbinfo->bc_cb  = m0_bs_create_rds_load_cb;
+        cbinfo->bc_cb = m0_bs_create_rds_load_cb;
 
         status = rds_load_heap(seg->bs_impl.path_name,
-                      RVM_LENGTH_TO_OFFSET(RVM_SEGMENT_SIZE), &static_addr,
-                      &err, &seg->bs_rvm, cbinfo);
+                               RVM_LENGTH_TO_OFFSET(RVM_SEGMENT_SIZE),
+                               &static_addr, &err, &seg->bs_rvm, cbinfo);
+
 exit:
         if (status != 0 && cbinfo->bc_pcbinfo != NULL &&
-           cbinfo->bc_pcbinfo->bc_cb != NULL) {
+            cbinfo->bc_pcbinfo->bc_cb != NULL) {
                 m0_be_handler_post(cbinfo->bc_pcbinfo, status, msg_type);
-		if(status != 0)
-			m0_free(bs_cbdata);
+                m0_free(bs_cbdata);
         }
-	else {
-		m0_bs_create_rds_load_cb(cbinfo, status, M0_BE_SUCCESS);
-	}
 }
 
 M0_INTERNAL void m0_bs_create_rds_load_cb(struct m0_be_cbinfo *cbinfo,
@@ -493,13 +489,46 @@ M0_INTERNAL void m0_bs_create_rds_load_cb(struct m0_be_cbinfo *cbinfo,
         m0_be_sm_lock_state_change_helper(&seg->bs_sm, cbinfo->bc_sm_group,
                                           M0_BESEG_ACTIVE);
 exit:
-        if(cbinfo->bc_pcbinfo != NULL && cbinfo->bc_pcbinfo->bc_cb != NULL)
+        if (cbinfo->bc_pcbinfo != NULL && cbinfo->bc_pcbinfo->bc_cb != NULL)
                 m0_be_handler_post(cbinfo->bc_pcbinfo, status, msg_type);
 
         m0_free(bs_cbdata);
         M0_LEAVE("Seg = %p segment state = %d", seg, seg->bs_sm.sm_state);
 }
 
+M0_INTERNAL void m0_be_seg_open_rds_load_heap_cb(struct m0_be_cbinfo *cbinfo,
+                                                 int                  status,
+                                                 m0_be_msg_type_t     msg)
+{
+        struct m0_be_seg_cbdata  *bs_cbdata;
+        struct m0_be_seg         *seg;
+        enum m0_be_seg_state      seg_state;
+
+        if(status != 0) {
+                seg_state = M0_BESEG_FAILED;
+                goto exit;
+        }
+        M0_ASSERT(cbinfo != NULL);
+
+        bs_cbdata = container_of(cbinfo, struct m0_be_seg_cbdata, bsc_cbinfo);
+        seg       = bs_cbdata->bsc_seg;
+        M0_ASSERT(seg != NULL);
+
+        seg->bs_static_addr = (void *)(seg->bs_rvm.static_addr);
+        seg->bs_addr        = (void *)m0_be_rvm_get_heapaddr(seg);
+        seg_state           = M0_BESEG_ACTIVE;
+exit:
+        m0_be_sm_lock_state_change_helper(&seg->bs_sm, cbinfo->bc_sm_group,
+                                          seg_state);
+
+        if(cbinfo->bc_pcbinfo != NULL && cbinfo->bc_pcbinfo->bc_cb != NULL)
+                m0_be_handler_post(cbinfo->bc_pcbinfo, status, msg);
+
+        m0_free(bs_cbdata);
+        M0_LEAVE("Segment = %p  Opened state = %d", seg, seg_state);
+}
+
+
 /**
  * The function calls rvm api's to open the segment.
  */
@@ -543,30 +572,25 @@ M0_INTERNAL void m0_be_seg_open_cb(struct m0_be_cbinfo *cbinfo, int status,
 
         /* @todo - need to handle rvm errors in callback. */
         /* Load heap */
+        cbinfo->bc_cb = m0_be_seg_open_rds_load_heap_cb;
+
         result = rds_load_heap(seg->bs_impl.path_name,
                                RVM_LENGTH_TO_OFFSET(dev_length),
                                &static_addr, &err, &seg->bs_rvm, cbinfo);
-
-        if (result < 0) {
+        if (result != 0) {
                 M0_LOG(M0_ERROR, "rds_load_heap failed in m0_be_seg_open_cb");
                 seg_state = M0_BESEG_FAILED;
-                goto exit;
         }
 
-        seg->bs_static_addr = (void *)(seg->bs_rvm.static_addr);
-        seg->bs_addr = (void *)m0_be_rvm_get_heapaddr(seg);
-
-        seg_state = M0_BESEG_ACTIVE;
-
 exit:
-        if(cbinfo->bc_pcbinfo != NULL && cbinfo->bc_pcbinfo->bc_cb != NULL)
+        if (result != 0 && cbinfo->bc_pcbinfo != NULL &&
+            cbinfo->bc_pcbinfo->bc_cb != NULL) {
+                m0_be_sm_lock_state_change_helper(&seg->bs_sm,
+                                                  cbinfo->bc_sm_group,
+                                                  seg_state);
                 m0_be_handler_post(cbinfo->bc_pcbinfo, status, msg_type);
-
-        m0_be_sm_lock_state_change_helper(&seg->bs_sm, cbinfo->bc_sm_group,
-                                          seg_state);
-
-        m0_free(bs_cbdata);
-        M0_LEAVE("Segment = %p  Opened state = %d", seg, seg_state);
+                m0_free(bs_cbdata);
+        }
 }
 
 M0_INTERNAL uint32_t m0_be_seg_state(const struct m0_be_seg *seg)
diff --git a/rvm/rds_private.h b/rvm/rds_private.h
index e29e44d..8753ac3 100644
--- a/rvm/rds_private.h
+++ b/rvm/rds_private.h
@@ -154,7 +154,13 @@ typedef struct rds_zap_heap_cbdata {
 	unsigned long	     	rzhc_chunk_size;
 	unsigned long	     	rzhc_nlists;
 	unsigned long        	rzhc_n_loadregions;
-}rzh_cbdata_t;
+} rzh_cbdata_t;
+
+typedef struct rds_load_heap_cbdata {
+	struct m0_be_cbinfo	 rlhc_cbinfo;
+	rvm_seg_hdr_t	    	*rlhc_seg_hdr;
+} rlh_cbdata_t;
+
 
 #define HEAP_INIT(pheap)   		(pheap->RecoverableHeapStartAddress != 0)
 #define RDS_VERSION_STAMP(pheap)	(pheap->RecoverableHeapStartAddress->version)
diff --git a/rvm/rds_start.c b/rvm/rds_start.c
index 6bc2702..59f5267 100644
--- a/rvm/rds_start.c
+++ b/rvm/rds_start.c
@@ -19,6 +19,8 @@ Coda are listed in the file CREDITS.
 #include <stdlib.h>
 #include <stdio.h>
 #include "rvm/rds_private.h"
+#include "be/handler.h"
+#include "lib/memory.h"
 
               /************** NOTE: ***************/
 /* we create our own transactions in the following routines, even
@@ -38,6 +40,43 @@ Coda are listed in the file CREDITS.
  * Global lock for the heap. See comment in rds_private.h.
  */
 
+void rlh_load_seg_cb(cbinfo, status, msg_type)
+        struct m0_be_cbinfo *cbinfo;
+        int                  status;
+        m0_be_msg_type_t     msg_type;
+{
+        rvm_region_def_t        *region_defs;
+        rlh_cbdata_t            *rlh_cbdata;
+        rvm_seg_hdr_t           *seg_hdr;
+        int                      err;
+
+        M0_ASSERT(cbinfo != NULL);
+        if (status != 0) {
+            printf("Error rvm_load_segment returns %d\n", status);
+            goto exit;
+        }
+
+	rlh_cbdata  = container_of(cbinfo, rlh_cbdata_t, rlhc_cbinfo);
+        seg_hdr     = rlh_cbdata->rlhc_seg_hdr;
+        region_defs = seg_hdr->heap_hdr->RegionDefs;
+
+        if (seg_hdr->heap_hdr->NRegionDefs != 2) {
+                free(seg_hdr->heap_hdr->RegionDefs);
+                msg_type = EBAD_SEGMENT_HDR;
+                status   = -1;
+                goto exit;
+        }
+
+        seg_hdr->static_addr = (char *)seg_hdr->heap_hdr->RegionDefs[1].vmaddr;
+
+        rds_start_heap(seg_hdr, seg_hdr->heap_hdr->RegionDefs[0].vmaddr, &err);
+exit:
+        if (cbinfo->bc_pcbinfo != NULL && cbinfo->bc_pcbinfo->bc_cb != NULL) {
+                m0_be_handler_post(cbinfo->bc_pcbinfo, status, msg_type);
+        }
+        m0_free(rlh_cbdata);
+}
+
 /*
  * Cannot statically initialize locks in pthreads.  So, we also need a flag
  * for double initialization.
@@ -55,31 +94,30 @@ int rds_load_heap(DevName, DevLength, static_addr, err, seg_hdr, cbinfo)
      rvm_seg_hdr_t         *seg_hdr;
      struct m0_be_cbinfo   *cbinfo;
 {
-    rvm_return_t     rvmret;
-
-    /* Initialization of seg->bs_rvm */
-    rds_init(seg_hdr);
-
-    /* Map in the appropriate structures by calling Rvm_Load_Segment. */
-    rvmret = rvm_load_segment(DevName, DevLength, NULL,
-			      &seg_hdr->heap_hdr->NRegionDefs, &seg_hdr->heap_hdr->RegionDefs, seg_hdr);
-    if (rvmret != RVM_SUCCESS) {
-	    printf("Error rvm_load_segment returns %d\n", rvmret);
-	    (*err) = (int) rvmret;
-	    return -1;
-    }
-
-    if (seg_hdr->heap_hdr->NRegionDefs != 2) {
-	free(seg_hdr->heap_hdr->RegionDefs);
-	(*err) = EBAD_SEGMENT_HDR;
-	return -1;
-    }
-
-    (*static_addr) = seg_hdr->static_addr = (char *)seg_hdr->heap_hdr->RegionDefs[1].vmaddr;
-
-    rds_start_heap(seg_hdr, seg_hdr->heap_hdr->RegionDefs[0].vmaddr, err);
-
-    return 0;
+        struct m0_be_cbinfo 	*rlh_cbinfo;
+        rlh_cbdata_t 		*rlh_cbdata;
+        rvm_return_t             rvmret;
+
+        /* Initialization of seg->bs_rvm */
+        rds_init(seg_hdr);
+
+        M0_ALLOC_PTR(rlh_cbdata);
+	M0_ASSERT(rlh_cbdata != NULL);
+
+        rlh_cbinfo = &rlh_cbdata->rlhc_cbinfo;
+
+        rlh_cbdata->rlhc_seg_hdr = seg_hdr;
+	rlh_cbinfo->bc_pcbinfo 	 = cbinfo;
+	rlh_cbinfo->bc_cb 	 = rlh_load_seg_cb;
+	rlh_cbinfo->bc_sm_group  = cbinfo->bc_sm_group;
+	rlh_cbinfo->bc_hq 	 = cbinfo->bc_hq;
+
+        /* Map in the appropriate structures by calling Rvm_Load_Segment. */
+        rvmret = rvm_load_segment(DevName, DevLength, NULL,
+                                  &seg_hdr->heap_hdr->NRegionDefs,
+                                  &seg_hdr->heap_hdr->RegionDefs, seg_hdr,
+                                  rlh_cbinfo);
+        return 0;
 }
 
 /*
diff --git a/rvm/rds_zap.c b/rvm/rds_zap.c
index be75e39..c25805b 100644
--- a/rvm/rds_zap.c
+++ b/rvm/rds_zap.c
@@ -182,14 +182,14 @@ void rzh_rvm_truncate_cb(cbinfo, status, msg_type)
 			 	  NULL,
 				  &rzh_cbdata->rzhc_n_loadregions,
 			 	  &rzh_cbdata->rzhc_loadregions,
-				  rzh_cbdata->rzhc_seg_hdr);
+				  rzh_cbdata->rzhc_seg_hdr,
+                                  &rzh_cbdata->rzhc_cbinfo);
 exit:
 	if (status != 0 && cbinfo->bc_pcbinfo != NULL &&
             cbinfo->bc_pcbinfo->bc_cb != NULL) {
                 m0_be_handler_post(cbinfo->bc_pcbinfo, status, msg_type);
 		m0_free(rzh_cbdata);
         }
-	rzh_rvm_load_seg_cb(&rzh_cbdata->rzhc_cbinfo, status, msg_type);
 }
 
 void rzh_create_seg_cb(cbinfo, status, msg_type)
diff --git a/rvm/rvm_loadseg.c b/rvm/rvm_loadseg.c
index d1473f9..56d6a68 100644
--- a/rvm/rvm_loadseg.c
+++ b/rvm/rvm_loadseg.c
@@ -20,9 +20,13 @@ Coda are listed in the file CREDITS.
 #include "rvm/rvm.h"
 #include "rvm/rvm_segment.h"
 #include "rvm/rvm_segment_private.h"
+#include "be/handler.h"
+#include "lib/memory.h"
+#include "lib/errno.h"
 
 /* from rvm_private.h */
-rvm_bool_t rvm_register_page(rvm_seg_hdr_t *seg_hdr, char *vmaddr, rvm_length_t length);
+rvm_bool_t rvm_register_page(rvm_seg_hdr_t *seg_hdr, char *vmaddr,
+                             rvm_length_t length);
 
 /* Global variables */
 
@@ -34,6 +38,169 @@ extern rvm_bool_t rvm_map_private;  /* Do we map private or not. */
 long rds_rvmsize;
 char *rds_startaddr;
 
+void rls_loop_rvm_map_cb(cbinfo, status, msg)
+        struct m0_be_cbinfo *cbinfo;
+        int                  status;
+        m0_be_msg_type_t     msg;
+{
+        rls_cbdata_t            *rls_cbdata;
+        rvm_seg_hdr_t           *seg_hdr;
+        rvm_region_t            *hdr_region;
+        int                      err;
+
+        if (status != 0)
+                goto exit;
+
+        rls_cbdata = container_of(cbinfo, rls_cbdata_t, rlsc_cbinfo);
+        seg_hdr    = rls_cbdata->rlsc_seg_hdr;
+        hdr_region = rls_cbdata->rlsc_hdr_region;
+
+        /* Clean up, we no longer need the header region */
+        switch (err = rvm_unmap(seg_hdr, hdr_region)) {
+                case RVM_EREGION:
+                case RVM_EUNCOMMIT:
+                case RVM_ENOT_MAPPED:
+                case RVM_ERANGE:
+                        deallocate_vm(seg_hdr, hdr_region->vmaddr,
+                                      hdr_region->length);
+                        status = -1;
+                        msg = RVM_ERANGE;
+                        goto exit;
+                        break;
+                default:
+                        /* do nothing */
+                        break;
+        }
+
+        status = 0;
+        msg    = M0_BE_SUCCESS;
+        err    = deallocate_vm(seg_hdr, hdr_region->vmaddr, hdr_region->length);
+        rvm_free_region(hdr_region);
+
+        if (err != RVM_SUCCESS) {
+                status = -1;
+                msg    = err;
+        }
+exit:
+        if (cbinfo->bc_pcbinfo != NULL && cbinfo->bc_pcbinfo->bc_cb != NULL) {
+                m0_be_handler_post(cbinfo->bc_pcbinfo, status, msg);
+        }
+        m0_free(rls_cbdata);
+}
+
+void rls_rvm_map_cb(cbinfo, status, msg)
+        struct m0_be_cbinfo *cbinfo;
+        int                  status;
+        m0_be_msg_type_t     msg;
+{
+        rls_cbdata_t            *rls_cbdata;
+        rvm_segment_hdr_t       *hdrp;
+        rvm_seg_hdr_t           *seg_hdr;
+        rvm_region_t            *hdr_region;
+        rvm_region_t            *region;
+        rvm_length_t            *nregions;
+        rvm_options_t           *options;
+        struct m0_be_cbinfo     *rvm_map_cbinfo;
+        rvm_region_def_t       **regions;
+        int                      i;
+        int                      err;
+
+        rls_cbdata = container_of(cbinfo, rls_cbdata_t, rlsc_cbinfo);
+        seg_hdr    = rls_cbdata->rlsc_seg_hdr;
+        hdr_region = rls_cbdata->rlsc_hdr_region;
+        region     = rls_cbdata->rlsc_region;
+        nregions   = rls_cbdata->rlsc_nregions;
+        options    = rls_cbdata->rlsc_options;
+        regions    = rls_cbdata->rlsc_regions_defs;
+
+        M0_ALLOC_PTR(rvm_map_cbinfo);
+        if (rvm_map_cbinfo == NULL) {
+                status = -1;
+                msg    = -ENOMEM;
+                goto exit;
+        }
+
+        rvm_map_cbinfo->bc_sm_group = cbinfo->bc_sm_group;
+        rvm_map_cbinfo->bc_hq       = cbinfo->bc_hq;
+        rvm_map_cbinfo->bc_cb       = NULL;
+        rvm_map_cbinfo->bc_pcbinfo  = NULL;
+
+        hdrp = (rvm_segment_hdr_t *)(hdr_region->vmaddr);
+
+        /* Make sure struct_id is correct */
+        if (hdrp->struct_id != rvm_segment_hdr_id) {
+                msg    = RVM_ESEGMENT_HDR;
+                status = -1;
+                goto exit;
+        }
+
+        /* Match version stamps */
+        if (strcmp(hdrp->version, RVM_SEGMENT_VERSION) != 0) {
+                msg    = RVM_EVERSION_SKEW;
+                status = -1;
+                goto exit;
+        }
+
+        /* Make sure the regions do not overlap */
+        if (overlap(hdrp->nregions, hdrp->regions)) {
+                msg    = RVM_EVM_OVERLAP;
+                status = -1;
+                goto exit;
+        }
+
+        /* Setup return region definition array */
+        (*nregions)= hdrp->nregions;
+        (*regions) = (rvm_region_def_t *)malloc(sizeof(rvm_region_def_t) *
+                                                (*nregions));
+
+        /* HACK */ rds_startaddr = hdrp->regions[0].vmaddr; /* HACK */
+
+        for (i = 0; i < hdrp->nregions; i++)
+                if ((unsigned long)(hdrp->regions[i].vmaddr) >= 0) {
+                        (*regions)[i].offset = hdrp->regions[i].offset;
+                        (*regions)[i].length = hdrp->regions[i].length;
+                        (*regions)[i].vmaddr = hdrp->regions[i].vmaddr;
+
+                        region->offset       = (*regions)[i].offset;
+                        region->length       = (*regions)[i].length;
+                        region->vmaddr       = (*regions)[i].vmaddr;
+
+                        /* HACK */ rds_rvmsize += region->length; /* HACK */
+
+                        if (!rvm_map_private) {
+                                err = allocate_vm(seg_hdr, &(region->vmaddr),
+                                                  region->length);
+                                if (err != RVM_SUCCESS) {
+                                        status = -1;
+                                        msg    = (m0_be_msg_type_t)err;
+                                        goto exit;
+                                }
+                        } else
+                                if (!rvm_register_page(seg_hdr, region->vmaddr,
+                                                       region->length)) {
+                                        status = -1;
+                                        msg    = RVM_EINTERNAL;
+                                        goto exit;
+                                }
+
+                        if (i == hdrp->nregions-1) {
+                                rvm_map_cbinfo->bc_cb     = rls_loop_rvm_map_cb;
+                                rvm_map_cbinfo->bc_pcbinfo = cbinfo;
+                        }
+
+                        /* Pass rvm_map_cbinfo as param to rvm_map. */
+                        err = rvm_map(seg_hdr, region, options);
+                        if (err != RVM_SUCCESS) {
+                                status = -1;
+                                msg    = (m0_be_msg_type_t)err;
+                                goto exit;
+                        }
+                }
+exit:
+        rls_loop_rvm_map_cb(cbinfo, status, msg);
+}
+
+
 /*
  * rvm_load_segment
  * - locates the place in the process's address where to load segments
@@ -42,98 +209,83 @@ char *rds_startaddr;
  */
 rvm_return_t
 rvm_load_segment(char *DevName, rvm_offset_t DevLength, rvm_options_t *options,
-		 unsigned long *nregions, rvm_region_def_t **regions, rvm_seg_hdr_t *seg_hdr)
+		 unsigned long *nregions, rvm_region_def_t **regions,
+                 rvm_seg_hdr_t *seg_hdr, struct m0_be_cbinfo *cbinfo)
 {
-    rvm_region_t *region = rvm_malloc_region();
-    rvm_region_t *hdr_region = rvm_malloc_region();
-    rvm_segment_hdr_t *hdrp;
-    rvm_return_t err;
-    int i;
-
-    /* HACK */ rds_rvmsize = 0; /* HACK */
-
-    /* Read in the header region of the segment. */
-    hdr_region->data_dev = DevName;
-    hdr_region->dev_length = DevLength;		/* Struct assignment */
-    RVM_ZERO_OFFSET(hdr_region->offset);
-    hdr_region->length = RVM_SEGMENT_HDR_SIZE;
-    hdr_region->vmaddr = 0;
-
-    hdr_region->vmaddr = NULL;
-    if (!rvm_map_private) {
-        err = allocate_vm(seg_hdr, &(hdr_region->vmaddr), hdr_region->length);
-	if (err != RVM_SUCCESS)
-	    return err;
-    }
-    /* else, as vmaddr is NULL, the segment will be pre-allocated and
-     * registered by rvm_map->establish_range->round_region->page_alloc -JH */
-
-    err = rvm_map(seg_hdr, hdr_region,options);
-    if (err != RVM_SUCCESS)
-	return err;    /* Some error condition exists, return the error code */
-
-    hdrp = (rvm_segment_hdr_t *)(hdr_region->vmaddr);
-
-    /* Make sure struct_id is correct */
-    if (hdrp->struct_id != rvm_segment_hdr_id)
-	return (rvm_return_t)RVM_ESEGMENT_HDR;
-
-    /* Match version stamps */
-    if (strcmp(hdrp->version, RVM_SEGMENT_VERSION) != 0)
-	return RVM_EVERSION_SKEW;
-
-    /* Make sure the regions do not overlap */
-    if (overlap(hdrp->nregions, hdrp->regions))
-	return RVM_EVM_OVERLAP;
-
-    /* Map in the regions */
-    region->data_dev = DevName;
-    region->dev_length = DevLength;		/* Struct assignment */
-
-    /* Setup return region definition array */
-    (*nregions) = hdrp->nregions;
-    (*regions) = (rvm_region_def_t *)malloc(sizeof(rvm_region_def_t)*(*nregions));
-
-    /* HACK */ rds_startaddr = hdrp->regions[0].vmaddr; /* HACK */
-
-    for (i = 0; i < hdrp->nregions; i++)
-	if ((unsigned long)(hdrp->regions[i].vmaddr) >= 0) {
-	    region->offset = (*regions)[i].offset = hdrp->regions[i].offset;
-	    region->length = (*regions)[i].length = hdrp->regions[i].length;
-	    region->vmaddr = (*regions)[i].vmaddr = hdrp->regions[i].vmaddr;
-
-	    /* HACK */ rds_rvmsize += region->length; /* HACK */
-
-	    if (!rvm_map_private) {
-	        err = allocate_vm(seg_hdr, &(region->vmaddr), region->length);
-		if (err != RVM_SUCCESS)
-		    return err;
-	    } else
-	      if (!rvm_register_page(seg_hdr, region->vmaddr, region->length))
-		return RVM_EINTERNAL;
-
-	    err = rvm_map(seg_hdr, region, options);
-	    if (err != RVM_SUCCESS)
-		return err; 	/* Some error condition exists, abort */
-
- 	}
-
-    /* Clean up, we no longer need the header region */
-    switch (err = rvm_unmap(seg_hdr, hdr_region)) {
-      case RVM_EREGION:
-      case RVM_EUNCOMMIT:
-      case RVM_ENOT_MAPPED:
-      case RVM_ERANGE:
-	deallocate_vm(seg_hdr, hdr_region->vmaddr, hdr_region->length);
-	return err;
-	break;
-      default:
-	/* do nothing */
-	break;
-    }
-
-    err = deallocate_vm(seg_hdr, hdr_region->vmaddr, hdr_region->length);
-
-    rvm_free_region(hdr_region);
-    return err;
+        rls_cbdata_t            *rls_cbdata;
+        rvm_region_t            *region;
+        rvm_region_t            *hdr_region;
+        m0_be_msg_type_t         msg = M0_BE_SUCCESS;
+        struct m0_be_cbinfo     *rlsc_cbinfo;
+        int                      err;
+        int                      status = 0;
+
+        region     = rvm_malloc_region();
+        hdr_region = rvm_malloc_region();
+
+        M0_ALLOC_PTR(rls_cbdata);
+        if (rls_cbdata == NULL) {
+                msg    = err = -ENOMEM;
+                status = -1;
+                goto exit;
+        }
+        /* HACK */ rds_rvmsize = 0; /* HACK */
+        /* Read in the header region of the segment. */
+        hdr_region->data_dev   = DevName;
+        /* Struct assignment */
+        hdr_region->dev_length = DevLength;
+
+        RVM_ZERO_OFFSET(hdr_region->offset);
+        hdr_region->length     = RVM_SEGMENT_HDR_SIZE;
+        hdr_region->vmaddr     = NULL;
+
+        /* Set up region */
+        region->data_dev   = DevName;
+        region->dev_length = DevLength;		/* Struct assignment */
+
+        if (!rvm_map_private) {
+                err = allocate_vm(seg_hdr, &(hdr_region->vmaddr),
+                                  hdr_region->length);
+
+                if (err != RVM_SUCCESS) {
+                        status = -1;
+                        msg = err;
+                        goto exit;
+                }
+        }
+
+        rls_cbdata->rlsc_seg_hdr      = seg_hdr;
+        rls_cbdata->rlsc_hdr_region   = hdr_region;
+        rls_cbdata->rlsc_region       = region;
+        rls_cbdata->rlsc_nregions     = nregions;
+        rls_cbdata->rlsc_options      = options;
+        rls_cbdata->rlsc_regions_defs = regions;
+
+        rlsc_cbinfo = &rls_cbdata->rlsc_cbinfo;
+	rlsc_cbinfo->bc_hq 	 = cbinfo->bc_hq;
+	rlsc_cbinfo->bc_sm_group = cbinfo->bc_sm_group;
+	rlsc_cbinfo->bc_cb 	 = rls_rvm_map_cb;
+        rlsc_cbinfo->bc_pcbinfo  = cbinfo;
+
+        /*
+         * else, as vmaddr is NULL, the segment will be pre-allocated and
+         * registered by rvm_map->establish_range->round_region->page_alloc -JH
+         */
+        err = rvm_map(seg_hdr, hdr_region, options);
+        if (err != RVM_SUCCESS) {
+                status = -1;
+                msg    = err;
+        }
+exit:
+        if (status != 0 && cbinfo->bc_pcbinfo != NULL &&
+            cbinfo->bc_pcbinfo->bc_cb != NULL) {
+                rvm_free_region(hdr_region);
+                rvm_free_region(region);
+
+                m0_be_handler_post(cbinfo->bc_pcbinfo, status, msg);
+                m0_free(rls_cbdata);
+        }
+
+        rls_rvm_map_cb(rlsc_cbinfo, status, msg);
+        return status;
 }
diff --git a/rvm/rvm_segment.h b/rvm/rvm_segment.h
index aff3bc1..84d8f3e 100644
--- a/rvm/rvm_segment.h
+++ b/rvm/rvm_segment.h
@@ -65,7 +65,8 @@ extern rvm_return_t rvm_load_segment (
     rvm_options_t	*options,       /* options record for RVM */
     unsigned long	*nregions,      /* returned -- number of regions mapped */
     rvm_region_def_t	*regions[],     /* returned array of region descriptors */
-    rvm_seg_hdr_t	*seg_hdr
+    rvm_seg_hdr_t	*seg_hdr,
+    struct m0_be_cbinfo *cbinfo
     );
 
 /* release regions of a segment */
diff --git a/rvm/rvm_segment_private.h b/rvm/rvm_segment_private.h
index 682c542..bbd8794 100644
--- a/rvm/rvm_segment_private.h
+++ b/rvm/rvm_segment_private.h
@@ -65,6 +65,16 @@ typedef struct rvm_create_segment_cbdata {
         rvm_region_def_t        *rcsc_region_defs;
         rvm_region_t            *rcsc_region;
         rvm_length_t            rcsc_nregions;
-}rcs_cbdata_t;
+} rcs_cbdata_t;
+
+typedef struct rvm_load_segment_cbdata {
+        struct m0_be_cbinfo      rlsc_cbinfo;
+        rvm_seg_hdr_t           *rlsc_seg_hdr;
+        rvm_region_t            *rlsc_hdr_region;
+        rvm_region_t            *rlsc_region;
+        rvm_length_t            *rlsc_nregions;
+        rvm_options_t           *rlsc_options;
+        rvm_region_def_t       **rlsc_regions_defs;
+} rls_cbdata_t;
 
 #endif /* __MERO_RVM_RVM_SEGMENT_PRIVATE_H__ */
-- 
1.8.3.2

