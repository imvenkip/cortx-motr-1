From f16fe059a8b6da31c21cff7306e4914148a3480b Mon Sep 17 00:00:00 2001
From: Prashant Dhange <prashant_dhange@xyratex.com>
Date: Fri, 14 Dec 2012 01:46:31 -0800
Subject: [PATCH 010/121] Transaction state machine and callback functions

---
 be/be.h      |   3 +
 be/be_impl.h |   2 +
 be/be_tx.c   | 209 ++++++++++++++++++++++++++++++++++++++++++-----------------
 be/be_tx.h   |  16 +++--
 be/ut/be.c   |  19 ++++--
 5 files changed, 180 insertions(+), 69 deletions(-)

diff --git a/be/be.h b/be/be.h
index 26e1bed..889afaf 100644
--- a/be/be.h
+++ b/be/be.h
@@ -186,6 +186,7 @@ struct m0_be_reg;
 #include "lib/thread.h"
 #include "addb/addb.h"
 #include "lib/memory.h"
+#include "lib/misc.h"
 
 #include "stob/stob.h"
 #include "stob/linux.h"
@@ -505,6 +506,8 @@ struct m0_be_domain {
 struct m0_be_tx {
         /** State machine. @see enum m0_be_tx_state. */
         struct m0_sm             bt_sm;
+        /* callback object for sm */
+        struct m0_sm_ast         bt_sm_ast;
         /** Domain of this transaction. */
         struct m0_be_domain     *bt_dom;
         /** Linkage in the list of active transactions, m0_be_dom::bd_tx. */
diff --git a/be/be_impl.h b/be/be_impl.h
index 4d54561..96be956 100644
--- a/be/be_impl.h
+++ b/be/be_impl.h
@@ -63,6 +63,8 @@ struct m0_be_tx_impl {
 
         /* Credit list associated with this transaction */
         struct m0_be_credit     *tx_bc;
+
+        struct m0_sm_group      *sm_group;
 };
 
 /** @} end of be group */
diff --git a/be/be_tx.c b/be/be_tx.c
index cf71465..fbe42c7 100644
--- a/be/be_tx.c
+++ b/be/be_tx.c
@@ -51,67 +51,76 @@
   */
 
 /* State machine variable declarations  */
-/* todo@  State machine for transaction */
 static const struct m0_sm_state_descr tx_states[] = {
         [M0_BETX_PREPARING] = {
                 .sd_flags     = M0_SDF_INITIAL,
-                .sd_name      = "SM init",
+                .sd_name      = "BE TX PREPARING",
                 .sd_in        = NULL,
                 .sd_ex        = NULL,
                 .sd_invariant = NULL,
                 .sd_allowed   = (1 << M0_BETX_OPENING)     |
+                                (1 << M0_BETX_PREPARING)   |
+                                (1 << M0_BETX_OPEN)        |
                                 (1 << M0_BETX_FAILED)
         },
 
         [M0_BETX_OPENING] = {
-                .sd_flags     = M0_SDF_INITIAL,
-                .sd_name      = "SM init",
+                .sd_flags     = 0,
+                .sd_name      = "BE TX OPENING",
                 .sd_in        = NULL,
                 .sd_ex        = NULL,
                 .sd_invariant = NULL,
                 .sd_allowed   = (1 << M0_BETX_OPENING)     |
                                 (1 << M0_BETX_OPEN)        |
                                 (1 << M0_BETX_FAILED)
-
         },
         [M0_BETX_OPEN] = {
                 .sd_flags     = 0,
-                .sd_name      = "SM Creating",
+                .sd_name      = "BE TX OPEN",
                 .sd_in        = NULL,
                 .sd_ex        = NULL,
                 .sd_invariant = NULL,
-                .sd_allowed   = (1 << M0_BETX_OPEN)        |
+                .sd_allowed   = (1 << M0_BETX_DONE)        |
+                                (1 << M0_BETX_COMMITTED)   |
                                 (1 << M0_BETX_FAILED)
         },
         [M0_BETX_DONE] = {
                 .sd_flags     = 0,
-                .sd_name      = "SM active",
+                .sd_name      = "BE TX DONE",
                 .sd_in        = NULL,
                 .sd_ex        = NULL,
                 .sd_invariant = NULL,
                 .sd_allowed   = (1 << M0_BETX_CLOSED)      |
                                 (1 << M0_BETX_COMMITTED)   |
-                                (1 << M0_BETX_DONE)        |
+                                (1 << M0_BETX_PREPARING)   |
                                 (1 << M0_BETX_FAILED)
         },
         [M0_BETX_CLOSED] = {
                 .sd_flags     = 0,
-                .sd_name      = "SM closing",
+                .sd_name      = "BE TX CLOSED",
                 .sd_in        = NULL,
                 .sd_ex        = NULL,
                 .sd_invariant = NULL,
-                .sd_allowed   = (1 << M0_BETX_CLOSED)      |
+                .sd_allowed   = (1 << M0_BETX_PREPARING)   |
                                 (1 << M0_BETX_FAILED)
         },
         [M0_BETX_COMMITTED] = {
                 .sd_flags     = 0,
-                .sd_name      = "SM checking",
+                .sd_name      = "BE TX COMMITTED",
                 .sd_in        = NULL,
                 .sd_ex        = NULL,
                 .sd_invariant = NULL,
-                .sd_allowed   = (1 << M0_BETX_COMMITTED)   |
+                .sd_allowed   = (1 << M0_BETX_CLOSED)      |
                                 (1 << M0_BETX_FAILED)
         },
+        [M0_BETX_FAILED] = {
+                .sd_flags     = M0_SDF_TERMINAL,
+                .sd_name      = "BE TX FAILED",
+                .sd_in        = NULL,
+                .sd_ex        = NULL,
+                .sd_invariant = NULL,
+                .sd_allowed   = 0
+        },
 };
 
 static const struct m0_sm_conf tx_conf = {
@@ -130,36 +139,36 @@ static const struct m0_sm_conf tx_conf = {
 void m0_be_tx_init   (struct m0_be_tx *tx,
                       struct m0_be_domain *dom, uint64_t flags)
 {
-        rvm_return_t ret;
-        rvm_tid_t    *tid;
-
         /* Asserting on required pointers */
         M0_ASSERT(tx != NULL);
         M0_ASSERT(dom != NULL);
+        M0_ASSERT(&(dom->bd_impl.sm_group) != NULL);
 
         /* Initialise domain structure with required values */
-        tx->bt_dom = dom;
+        tx->bt_dom              = dom;
+        tx->bt_impl.sm_group    = &(dom->bd_impl.sm_group);
+
+        /*
+         * Locking sm_group is required before initializing sm
+         * TODO@ Need to confirm with Nikita, do we need to move the state
+         * transition logic to CALLBACKS. This Applies for state change
+         * accross the segments, regions, transactions
+         */
+        m0_sm_group_lock(tx->bt_impl.sm_group);
 
-        tid = rvm_malloc_tid();
+        /* Register the state machine of the tx into sm_group */
+        m0_sm_init(&tx->bt_sm, &tx_conf, M0_BETX_PREPARING, tx->bt_impl.sm_group,
+                        NULL);
 
-        if (tid == NULL) {
-               /* todo@ need to call m0_sm_state_set() to change state */
-                tx->bt_sm.sm_state = M0_BETX_FAILED;
-                return;
-        }
+        /* unlock locked sm group */
+        m0_sm_group_unlock(tx->bt_impl.sm_group);
 
-        tx->bt_impl.tx_id = tid;
-
-        ret = rvm_begin_transaction(tx->bt_impl.tx_id, restore);
+        tx->bt_sm_ast.sa_cb    = m0_be_tx_init_cb;
+        tx->bt_sm_ast.sa_datum = (void *)tx;
 
-        if (RVM_SUCCESS != ret) {
-                /* todo@ need to call m0_sm_state_set() to change state */
-                tx->bt_sm.sm_state = M0_BETX_FAILED;
-                return;
-        }
+        m0_tx_req_post(&(tx->bt_dom->bd_impl.sm_group), &(tx->bt_sm_ast));
 
-        /* todo@ need to call m0_sm_state_set() to change state */
-        tx->bt_sm.sm_state = M0_BETX_PREPARING;
+        M0_POST(M0_IN(tx->bt_sm.sm_state, (M0_BETX_PREPARING, M0_BETX_FAILED)));
 }
 
 /**
@@ -170,7 +179,6 @@ void m0_be_tx_init   (struct m0_be_tx *tx,
  */
 void m0_be_tx_prep   (struct m0_be_tx *tx, struct m0_be_credit *cred)
 {
-        rvm_return_t ret;
         struct m0_be_reg *reg_it;
 
         /* Asserting on required pointers */
@@ -180,7 +188,8 @@ void m0_be_tx_prep   (struct m0_be_tx *tx, struct m0_be_credit *cred)
         /* Is tx->bt_sm.sm_state in M0_BETX_PREPARING state */
         M0_PRE(tx->bt_sm.sm_state == M0_BETX_PREPARING);
 
-        /* Assign cred to tx->bt_impl.tx_bc, required in m0_be_tx_done
+        /*
+         * Assign cred to tx->bt_impl.tx_bc, required in m0_be_tx_done
          * to mark regions from credit list for completion
          */
         tx->bt_impl.tx_bc = cred;
@@ -192,16 +201,25 @@ void m0_be_tx_prep   (struct m0_be_tx *tx, struct m0_be_credit *cred)
 
                 if ( (reg_it->br_sm.sm_state != M0_BEREG_INIT) &&
                      (reg_it->br_sm.sm_state != M0_BEREG_DONE) ) {
-                        ret = rvm_abort_transaction(tx->bt_impl.tx_id);
 
-                        /* todo@ need to call m0_sm_state_set() */
-                        tx->bt_sm.sm_state = M0_BETX_FAILED;
-                        return;
+                        M0_TX_SM_STATE_SET(tx, M0_BETX_FAILED);
+                        /* TODO@ add error log message */
+                        goto exit_error;
                 }
 
         } m0_tlist_endfor;
 
-        m0_be_tx_prep_cb(tx, cred);
+        tx->bt_sm_ast.sa_cb    = m0_be_tx_prep_cb;
+        tx->bt_sm_ast.sa_datum = (void *)tx;
+
+        m0_tx_req_post(&(tx->bt_dom->bd_impl.sm_group), &(tx->bt_sm_ast));
+        goto exit;
+
+exit_error:
+        rvm_abort_transaction(tx->bt_impl.tx_id);
+        rvm_free_tid(tx->bt_impl.tx_id);
+exit:
+        return;
 }
 
 /**
@@ -216,16 +234,19 @@ void m0_be_tx_start  (struct m0_be_tx *tx)
 
         M0_ASSERT(tx != NULL);
 
-        /* Is tx->bt_sm.sm_state in M0_BETX_PREPARING state */
+        /* Is tx->bt_sm.sm_state in M0_BETX_OPENING state */
         M0_PRE(tx->bt_sm.sm_state == M0_BETX_PREPARING);
 
-        /* todo@ need to call function m0_sm_state_set() */
-        tx->bt_sm.sm_state = M0_BETX_OPEN;
+        M0_TX_SM_STATE_SET(tx, M0_BETX_OPEN);
 
         /* Add this transaction to domain's active transaction list */
         m0_be_tx_tlink_init(tx);
 
         m0_be_tx_tlist_add(&tx->bt_dom->bd_tx, tx);
+
+        M0_POST(M0_IN(tx->bt_sm.sm_state, (M0_BETX_OPENING,
+                                           M0_BETX_OPEN,
+                                           M0_BETX_FAILED)));
 }
 
 /**
@@ -247,29 +268,33 @@ void m0_be_tx_done   (struct m0_be_tx *tx)
         ret = rvm_end_transaction(tx->bt_impl.tx_id, flush);
 
         if (RVM_SUCCESS != ret) {
-                /* todo@ need to call function m0_sm_state_set() */
-                tx->bt_sm.sm_state = M0_BETX_FAILED;
-                return;
+                /* TODO@ add error log message */
+                goto exit_end_tx;
         }
 
         /* set state of all the regions in the credit */
         cred = tx->bt_impl.tx_bc;
 
         if (cred == NULL) {
-                /* todo@ need to call function m0_sm_state_set() */
-                tx->bt_sm.sm_state = M0_BETX_FAILED;
-                return;
+                /* TODO@ add error log message */
+                goto exit_end_tx;
         }
         /* Iterate credit list of regions */
         m0_tlist_for(&m0_be_reg_tl, &(cred->bc_tl), reg_it) {
                 /* Mark all regions for completion */
-                /* todo@ need to call function m0_sm_state_set() */
+                /* TODO@ need to call function m0_sm_state_set() */
                 reg_it->br_sm.sm_state = M0_BEREG_DONE;
 
         } m0_tlist_endfor;
 
-        /* todo@ need to call function m0_sm_state_set() */
-        tx->bt_sm.sm_state = M0_BETX_DONE;
+        M0_TX_SM_STATE_SET(tx, M0_BETX_DONE);
+        goto exit;
+
+exit_end_tx:
+        rvm_free_tid(tx->bt_impl.tx_id);
+        M0_TX_SM_STATE_SET(tx, M0_BETX_FAILED);
+exit:
+        return;
 }
 
 /**
@@ -282,23 +307,78 @@ void m0_be_tx_fini   (struct m0_be_tx *tx)
         /* Asserting on required pointers */
         M0_ASSERT(tx != NULL);
 
+        M0_PRE(M0_IN(tx->bt_sm.sm_state, (M0_BETX_DONE,
+                                          M0_BETX_FAILED)));
+
         rvm_free_tid(tx->bt_impl.tx_id);
 
         /* Remove entry from in memory active transaction list if present */
         if (m0_be_tx_tlink_is_in(tx))
                 m0_be_tx_tlink_del_fini(tx);
 
+        /* Finalizing on state machine */
+        m0_sm_fini(&(tx->bt_sm));
 }
 
-
 /*
- *    m0_be_prep callback function
- *    todo@ use  with bt_sm
+ *    m0_be_tx_init callback function
  */
+void m0_be_tx_init_cb(struct m0_sm_group *sm_group, struct m0_sm_ast *sm_ast)
+{
+        struct m0_be_tx         *tx;
+        rvm_return_t             ret;
+        rvm_tid_t               *tid;
 
-void m0_be_tx_prep_cb(struct m0_be_tx *tx, struct m0_be_credit *cred)
+        /* Asserting on required pointers */
+        M0_ASSERT(sm_group != NULL);
+        M0_ASSERT(sm_ast != NULL);
+
+        tx = (struct m0_be_tx *) sm_ast->sa_datum;
+        M0_ASSERT(tx != NULL);
+
+        tid = rvm_malloc_tid();
+
+        if (tid == NULL) {
+                /* TODO@ add error log message */
+                goto exit_alloc;
+        }
+
+        tx->bt_impl.tx_id = tid;
+
+        ret = rvm_begin_transaction(tx->bt_impl.tx_id, restore);
+
+        if (RVM_SUCCESS != ret) {
+                /* TODO@ add error log message */
+                goto exit_begin_tx;
+        }
+        goto exit;
+
+exit_begin_tx:
+        rvm_free_tid(tid);
+exit_alloc:
+        m0_sm_state_set(&(tx->bt_sm), M0_BETX_FAILED);
+exit:
+        return;
+}
+
+/*
+ *    m0_be_tx_prep callback function
+ */
+void m0_be_tx_prep_cb(struct m0_sm_group *sm_group, struct m0_sm_ast *sm_ast)
 {
-        struct m0_be_reg *reg_it;
+        struct m0_be_tx         *tx;
+        struct m0_be_reg        *reg_it;
+        struct m0_be_credit     *cred;
+
+        /* Asserting on required pointers */
+        M0_ASSERT(sm_group != NULL);
+        M0_ASSERT(sm_ast != NULL);
+
+        tx = (struct m0_be_tx *) sm_ast->sa_datum;
+
+        M0_ASSERT(tx != NULL);
+
+        cred = tx->bt_impl.tx_bc;
 
         /* Iterate credit list of regions */
         m0_tlist_for(&m0_be_reg_tl, &(cred->bc_tl), reg_it) {
@@ -311,8 +391,10 @@ void m0_be_tx_prep_cb(struct m0_be_tx *tx, struct m0_be_credit *cred)
                 }
 
                 if (reg_it->br_sm.sm_state == M0_BEREG_DONE) {
-                        /* Capture region function which changes the region
-                         * state to InProgress */
+                        /*
+                         * Capture region function which changes the region
+                         * state to InProgress
+                         */
                         m0_be_reg_capture(reg_it);
                 }
 
@@ -363,6 +445,15 @@ void m0_be_credit_fini(struct m0_be_credit *cred)
 }
 
 
+/**
+ * The function posts tx request to state machine thread
+ *
+ */
+void m0_tx_req_post(struct m0_sm_group *sm_group, struct m0_sm_ast *sm_ast)
+{
+        m0_sm_ast_post(sm_group, sm_ast);
+}
+
 /** @} end group be_trans */
 
 /*
diff --git a/be/be_tx.h b/be/be_tx.h
index 3d9d085..acedee7 100644
--- a/be/be_tx.h
+++ b/be/be_tx.h
@@ -13,8 +13,8 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Sachin Patil <spatil@xyratex.com>
- * Original creation date: 26 Nov 2012
+ * Original author: Prashant Dhange <prashant_dhange@xyratex.com>
+ * Original creation date: 10 Dec 2012
  */
 
 #pragma once
@@ -26,17 +26,21 @@
   @defgroup be (Meta-data) back-end
   @{
   */
-
-#include <stdio.h>
-
 #include "be/be.h"
 
+#define M0_TX_SM_STATE_SET(tx, state)                                 \
+        m0_sm_group_lock((tx)->bt_impl.sm_group);                     \
+        m0_sm_state_set(&((tx)->bt_sm), state);                       \
+        m0_sm_group_unlock((tx)->bt_impl.sm_group);
+
 void m0_be_credit_init(struct m0_be_credit *cred);
 void m0_be_credit_add(struct m0_be_credit *cred, struct m0_be_reg *reg);
 void m0_be_credit_fini(struct m0_be_credit *cred);
 
-void m0_be_tx_prep_cb(struct m0_be_tx *tx, struct m0_be_credit *cred);
+void m0_be_tx_init_cb(struct m0_sm_group *sm_group, struct m0_sm_ast *sm_ast);
+void m0_be_tx_prep_cb(struct m0_sm_group *sm_group, struct m0_sm_ast *sm_ast);
 
+void m0_tx_req_post(struct m0_sm_group *sm_group, struct m0_sm_ast *sm_ast);
 /** @} end of be group */
 
 /* __MERO_BE_BE_TX_H__ */
diff --git a/be/ut/be.c b/be/ut/be.c
index e3cdb3e..0b28d5d 100644
--- a/be/ut/be.c
+++ b/be/ut/be.c
@@ -98,6 +98,14 @@ int main()
 
         m0_be_tx_init(&tx, &dom, 0);
 
+        m0_sm_group_lock(tx.bt_impl.sm_group);
+        m0_sm_timedwait(&tx.bt_sm,
+                        (1 << M0_BETX_PREPARING) | (1 << M0_BETX_FAILED),
+                        M0_TIME_NEVER);
+        m0_sm_group_unlock(tx.bt_impl.sm_group);
+        printf("\nTx is initiated\n");
+
+
         m0_be_buf_init(&buf, NULL, 1024, 0, 0, 0);
         m0_be_reg_init(&reg, &tx, &seg, &buf);
 
@@ -106,12 +114,15 @@ int main()
         printf("reg : %p reg_state[%d]\n", &reg, reg.br_sm.sm_state);
         m0_be_tx_prep(&tx, &cred);
 
-        if(tx.bt_sm.sm_state == M0_BETX_FAILED) {
-                printf("Failed to prepare transaction with cred list \n");
-                return 0;
-        }
+        m0_sm_group_lock(tx.bt_impl.sm_group);
+        m0_sm_timedwait(&tx.bt_sm,
+                        (1 << M0_BETX_PREPARING) | (1 << M0_BETX_FAILED),
+                        M0_TIME_NEVER);
+        m0_sm_group_unlock(tx.bt_impl.sm_group);
+        printf("\nTx is Opening\n");
 
         m0_be_tx_start(&tx);
+        printf("\nTx Opened\n");
 
         strcpy(reg.br_buf.logical_address.virtual_address, "VIRTUAL WORLD");
         printf("\ndata : [%s]\n",
-- 
1.8.3.2

