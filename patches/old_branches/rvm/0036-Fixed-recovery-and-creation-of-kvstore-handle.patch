From b9d96921021094424df73ad2108300070fb3468b Mon Sep 17 00:00:00 2001
From: Zishan Shaikh <zishan_shaikh@xyratex.com>
Date: Wed, 16 Jan 2013 13:08:06 -0800
Subject: [PATCH 036/121] Fixed recovery and creation of kvstore handle

---
 be/be.h                 |   4 +-
 be/be_domain.c          |  33 +++++++--
 be/be_seg.c             |  13 ++--
 be/lib/be_helper.c      |  20 +++++-
 be/lib/be_helper.h      |  10 ++-
 be/lib/be_kv_store.c    |  54 ++++++++++-----
 be/lib/be_kv_store.h    |   8 ++-
 be/lib/ut/be_kv_store.c | 174 +++++++++++++++++++++++-------------------------
 8 files changed, 188 insertions(+), 128 deletions(-)

diff --git a/be/be.h b/be/be.h
index fe114c3..2c14c77 100644
--- a/be/be.h
+++ b/be/be.h
@@ -267,8 +267,8 @@ M0_INTERNAL void m0_be_domain_lookup(struct m0_be_domain *dom,
  */
 
 M0_INTERNAL void m0_be_domain_lookup_recover(struct m0_be_domain *dom,
-                                             const uint64_t segment_id,
-                                             struct m0_be_seg **out);
+                                             const uint64_t       segment_id,
+                                             struct m0_be_seg   **out);
 
 /**
  * Initialises the segment structure in memory.
diff --git a/be/be_domain.c b/be/be_domain.c
index 79ed756..9d02002 100644
--- a/be/be_domain.c
+++ b/be/be_domain.c
@@ -222,7 +222,6 @@ M0_INTERNAL void m0_be_domain_fini(struct m0_be_domain *dom)
 }
 
 /**
- * 
  * Searches a domain for the existing segment with a given name.
  * Note - This function does not create new segment, if segment not found.
  *        This will return BE_SEG_FAILED for non existing segment lookups.
@@ -234,10 +233,14 @@ M0_INTERNAL void m0_be_domain_fini(struct m0_be_domain *dom)
  */
 
 M0_INTERNAL void m0_be_domain_lookup_recover(struct m0_be_domain *dom,
-                                             const uint64_t segment_id,
-                                             struct m0_be_seg **out)
+                                             const uint64_t       segment_id,
+                                             struct m0_be_seg   **out)
 {
-        struct m0_be_seg *seg_it;
+        struct  m0_be_seg        *seg_it;
+        struct  m0_stob_domain   *stob_dom;
+        struct  m0_stob_id        stob_id = {{0, segment_id}};
+        int                       result;
+        bool                      stob_directio = true;
 
         /* Asserting on required conditions */
         M0_ASSERT(dom != NULL);
@@ -261,6 +264,7 @@ M0_INTERNAL void m0_be_domain_lookup_recover(struct m0_be_domain *dom,
                 m0_be_seg_open(*out);
         }
 
+
         if (*out == NULL) {
                 /* Now allocate, init and open the segment */
 
@@ -269,13 +273,30 @@ M0_INTERNAL void m0_be_domain_lookup_recover(struct m0_be_domain *dom,
 
                 (*out)->bs_impl.segment_id = segment_id;
 
-                m0_be_seg_tlink_init(*out);
-
                 /* Last 2 arguments - sm_grp and flags */
                 m0_be_seg_init(*out, dom, &(dom->bd_impl.sm_group), 0);
 
+                m0_stob_type_init(&m0_linux_stob_type);
+                result = m0_stob_domain_locate(&m0_linux_stob_type,
+                                               "./__be",
+                                               &stob_dom);
+                M0_ASSERT(result == 0);
+
+                result = m0_linux_stob_setup(stob_dom, stob_directio);
+                M0_ASSERT(result == 0);
+
+                result = m0_stob_find(stob_dom, &stob_id, &((*out)->bs_stob));
+                M0_ASSERT(result == 0);
+
+                result = m0_stob_create((*out)->bs_stob, NULL);
+
+                if (result < 0) {
+                        (*out)->bs_stob->so_state = CSS_UNKNOWN;
+                }
+                
                 m0_be_seg_open(*out);
 
+                m0_be_seg_tlink_init(*out);
                 m0_be_seg_tlist_add(&(dom->bd_seg), *out);
         }
 }
diff --git a/be/be_seg.c b/be/be_seg.c
index 4ef75c5..edebef5 100644
--- a/be/be_seg.c
+++ b/be/be_seg.c
@@ -547,12 +547,12 @@ M0_INTERNAL void m0_be_seg_create_cb(struct m0_sm_group *sm_group,
         /* @note - can not use linux_stob_path as it is declared as static in
          *  linux.[hc] */
 
-	ldom = domain2linux(seg->bs_stob->so_domain);
-	nbytes = snprintf(seg->bs_impl.path_name,
+        ldom = domain2linux(seg->bs_stob->so_domain);
+        nbytes = snprintf(seg->bs_impl.path_name,
                           ARRAY_SIZE(seg->bs_impl.path_name),
                           "%s/o/%016lx.%016lx",
                           ldom->sdl_path,
-		          seg->bs_stob->so_id.si_bits.u_hi,
+                          seg->bs_stob->so_id.si_bits.u_hi,
                           seg->bs_stob->so_id.si_bits.u_lo);
 
         if (nbytes < 0)
@@ -626,14 +626,17 @@ M0_INTERNAL void m0_be_seg_open_cb(struct m0_sm_group *sm_group,
 
         seg = (struct m0_be_seg *)sm_ast->sa_datum;
 
+        if (seg->bs_stob->so_state == CSS_UNKNOWN)
+                goto error;
+
         lstob = stob2linux(seg->bs_stob);
 
         M0_ASSERT(lstob != NULL);
 
         /* Get fle-path for segment stob */
         /* @note - can not use linux_stob_path as its declared as static */
-	ldom = domain2linux(seg->bs_stob->so_domain);
-	nbytes = snprintf(seg->bs_impl.path_name,
+        ldom = domain2linux(seg->bs_stob->so_domain);
+        nbytes = snprintf(seg->bs_impl.path_name,
                           ARRAY_SIZE(seg->bs_impl.path_name),
                           "%s/o/%016lx.%016lx",
                           ldom->sdl_path,
diff --git a/be/lib/be_helper.c b/be/lib/be_helper.c
index 9061518..88ab2a3 100644
--- a/be/lib/be_helper.c
+++ b/be/lib/be_helper.c
@@ -46,12 +46,30 @@ M0_INTERNAL void m0_ks_domain_lookup(struct m0_be_domain    *dom,
                                      uint64_t                segid)
 {
         m0_be_domain_lookup(dom, segid, seg);
-
+        M0_ASSERT((*seg) != NULL);
         M0_BE_WAIT((*seg)->bs_impl.sm_group, &((*seg)->bs_sm),
                    (1 << M0_BESEG_ACTIVE) | (1 << M0_BESEG_FAILED));
 }
 M0_EXPORTED(m0_ks_domain_lookup);
 
+M0_INTERNAL int m0_ks_domain_lookup_recover(struct m0_be_domain *dom,
+                                            struct m0_be_seg   **seg,
+                                            uint64_t             segid)
+{
+        m0_be_domain_lookup_recover(dom, segid, seg);
+        M0_BE_WAIT((*seg)->bs_impl.sm_group, &((*seg)->bs_sm),
+                   (1 << M0_BESEG_ACTIVE) | (1 << M0_BESEG_FAILED));
+        M0_ASSERT((*seg) != NULL);
+
+        if ((*seg)->bs_sm.sm_state == M0_BESEG_FAILED) {
+                m0_be_seg_fini((*seg));
+                return BE_KV_FAILURE;
+        }
+
+        return BE_KV_SUCCESS;
+}
+M0_EXPORTED(m0_ks_domain_lookup_recover);
+
 M0_INTERNAL void *m0_ks_obj_malloc(struct m0_be_reg     *obj_reg,
                                    struct m0_reference **obj_ref)
 {
diff --git a/be/lib/be_helper.h b/be/lib/be_helper.h
index 6cce633..72c743b 100644
--- a/be/lib/be_helper.h
+++ b/be/lib/be_helper.h
@@ -43,13 +43,21 @@ M0_INTERNAL void m0_ks_init_domain(struct m0_be_domain  **out_dom);
 M0_INTERNAL void m0_ks_fini(struct m0_be_domain *dom, struct m0_be_seg *seg);
 
 /*
- * Lookup for a segment identified by the @segid within the domain/
+ * Lookup for a segment identified by the @segid within the domain.
  */
 M0_INTERNAL void m0_ks_domain_lookup(struct m0_be_domain   *dom,
                                      struct m0_be_seg     **seg,
                                      uint64_t               segid);
 
 /*
+ * Tries to open a segment. If failed returns BE_KV_FAILURE, else returns
+ * BE_KV_SUCCESS. Used while recovery of kv store handle.
+ */
+M0_INTERNAL int m0_ks_domain_lookup_recover(struct m0_be_domain *dom,
+                                            struct m0_be_seg   **seg,
+                                            uint64_t             segid);
+
+/*
  * Allocates memory to an object. Returns allocated chunk of memory.
  * Returns the reference of the allocated chunk in @obj_ref.
  * PRE: reg_init done on @obj_reg
diff --git a/be/lib/be_kv_store.c b/be/lib/be_kv_store.c
index cf1c33b..3c6410e 100644
--- a/be/lib/be_kv_store.c
+++ b/be/lib/be_kv_store.c
@@ -107,6 +107,9 @@ M0_INTERNAL void m0_ks_create_handle(struct m0_be_domain     *dom,
         /* Update segment id & offset in head & tail */
         head = &(rvm_handle->ks_tlist.t_head);
 
+        printf("handle offset = %ld\n", rvm_handle_ref->segid_offset.u_lo);
+        printf("size = %ld\n", sizeof(*rvm_handle));
+
         temp_head_offset       = &(head->l_head.logical_address.segid_offset);
         temp_head_offset->u_hi = rvm_handle_ref->segid_offset.u_hi;
         temp_head_offset->u_lo = rvm_handle_ref->segid_offset.u_lo;
@@ -130,37 +133,49 @@ M0_INTERNAL void m0_ks_create_handle(struct m0_be_domain     *dom,
 }
 M0_EXPORTED(m0_ks_create_handle);
 
-M0_INTERNAL void m0_ks_init(struct m0_kv_store    **handle,
+M0_INTERNAL void m0_ks_init(struct m0_kv_store    **out_handle,
                             struct m0_be_tl_descr  *descr,
                             struct m0_be_domain    *dom,
                             kv_key_cmp              cmp_fp,
                             kv_key_match            match_fp,
-                            int                     control)
+                            char                   *mode)
 {
-        struct m0_kv_store_rvm  *rvm_handle = NULL;
+        struct m0_kv_store      *handle         = NULL;
+        struct m0_kv_store_rvm  *rvm_handle     = NULL;
         struct m0_be_seg        *rvm_handle_seg = NULL;
+        int                      handle_status;
 
-        if((*handle) == NULL) {
-                        M0_ALLOC_PTR((*handle));
+        if((*out_handle) == NULL) {
+                        M0_ALLOC_PTR(handle);
                         M0_ASSERT(handle != NULL);
         }
 
-        if(control == CREATE) {
-                m0_ks_create_handle(dom, descr, &rvm_handle);
-                M0_ASSERT(rvm_handle != NULL);
-                (*handle)->handle_rvm = rvm_handle;
+        if (strcmp(mode, "RECOVER") == 0 || strcmp(mode, "recover") == 0) {
+                m0_ks_domain_lookup_recover(dom, &rvm_handle_seg, 1);
+                M0_ASSERT(rvm_handle_seg != NULL);
         } else {
-                /* For now segid is always == 1*/
                 m0_ks_domain_lookup(dom, &rvm_handle_seg, 1);
                 M0_ASSERT(rvm_handle_seg != NULL);
-                m0_be_hs_init(rvm_handle_seg);
+        }
+
+        m0_be_hs_init(rvm_handle_seg);
+
+        handle_status = m0_ks_deref_handle(handle, rvm_handle_seg);
+
+        if (handle_status == BE_KV_FAILURE) {
+                printf("Creating new handle...\n");
+                m0_ks_create_handle(dom, descr, &rvm_handle);
+                M0_ASSERT(rvm_handle != NULL);
+                handle->handle_rvm = rvm_handle;
         }
 
         /* Set the non_rvm part of the handle with user values */
-        (*handle)->handle_heap.kv_key_cmp    = cmp_fp;
-        (*handle)->handle_heap.kv_key_match  = match_fp;
-        (*handle)->handle_heap.ks_list_descr = descr;
-        (*handle)->handle_heap.ks_dom        = dom;
+        handle->handle_heap.kv_key_cmp    = cmp_fp;
+        handle->handle_heap.kv_key_match  = match_fp;
+        handle->handle_heap.ks_list_descr = descr;
+        handle->handle_heap.ks_dom        = dom;
+
+        (*out_handle) = handle;
 }
 M0_EXPORTED(m0_ks_init);
 
@@ -627,15 +642,17 @@ static void __m0_ks_add_prev_next_to_cred(struct m0_kv_store *handle,
        }
 }
 
-M0_INTERNAL void m0_ks_deref_handle(struct m0_kv_store *handle,
-                                    struct m0_be_seg   *seg)
+M0_INTERNAL int m0_ks_deref_handle(struct m0_kv_store *handle,
+                                   struct m0_be_seg   *seg)
 {
         struct m0_kv_store_rvm *handle_rvm  = NULL;
         struct m0_uint128      *kv_store    = NULL;
         long int                lo;
 
         kv_store = m0_be_hs_get(0);
-        M0_ASSERT(kv_store != NULL);
+
+        if (kv_store->u_hi == 0)
+                return BE_KV_FAILURE;
 
         lo = (long int)(seg->bs_heap_addr + (kv_store->u_lo));
 
@@ -643,6 +660,7 @@ M0_INTERNAL void m0_ks_deref_handle(struct m0_kv_store *handle,
         M0_ASSERT(handle_rvm != NULL);
 
         handle->handle_rvm = handle_rvm;
+        return BE_KV_SUCCESS;
 }
 M0_EXPORTED(m0_ks_deref_handle);
 
diff --git a/be/lib/be_kv_store.h b/be/lib/be_kv_store.h
index 92f7a31..d2571a1 100644
--- a/be/lib/be_kv_store.h
+++ b/be/lib/be_kv_store.h
@@ -102,13 +102,15 @@ M0_INTERNAL void m0_ks_create_handle(struct m0_be_domain     *dom,
  * @param dom           :       the domain pointer to be given to the handle
  * @param cmp_fp        :       user defined function to compare keys
  * @param match_fp      :       user defined function to match keys
+ * @param mode          :       decides whether kv_store is new or has to be
+ *                              recovered.
  */
 M0_INTERNAL void m0_ks_init(struct m0_kv_store    **handle,
                             struct m0_be_tl_descr  *descr,
                             struct m0_be_domain    *dom,
                             kv_key_cmp              cmp_fp,
                             kv_key_match            match_fp,
-                            int                     control);
+                            char                   *mode);
 
 /*
  * Insert a key value pair in the tlist contained in @handle.
@@ -164,8 +166,8 @@ M0_INTERNAL struct m0_reference *m0_ks_get_next_val(struct m0_kv_store *handle,
  * @param kv_store      :       pointer containing segment id and offset of the
  *                              persistent kv_store handle
  */
-M0_INTERNAL void m0_ks_deref_handle(struct m0_kv_store *handle,
-                                    struct m0_be_seg   *seg);
+M0_INTERNAL int m0_ks_deref_handle(struct m0_kv_store *handle,
+                                   struct m0_be_seg   *seg);
 
 
 /** @} end of be_kv_store group */
diff --git a/be/lib/ut/be_kv_store.c b/be/lib/ut/be_kv_store.c
index 23b9f1f..10881e3 100644
--- a/be/lib/ut/be_kv_store.c
+++ b/be/lib/ut/be_kv_store.c
@@ -28,7 +28,7 @@
 /* User defined structure */
 struct m0_kv_store_obj {
         char                    key[MAX_KEY_SIZE];
-        int                     val;
+        int                     obj_val;
         struct m0_be_tlink      linkage;
         uint64_t                magic;
 };
@@ -42,8 +42,10 @@ struct m0_be_tl_descr list_descr = M0_BE_TL_DESCR("kv_store_obj",
 
 struct m0_be_domain     *dom;
 struct m0_be_seg        *seg;
-struct m0_kv_store      *handle = NULL;
-struct m0_kv_store_rvm  *handle_rvm = NULL;
+struct m0_kv_store_obj  *object[1024]      = {NULL};
+struct m0_kv_store_obj  *ret_obj[1024]  = {NULL};
+struct m0_kv_store      *handle         = NULL;
+struct m0_kv_store_rvm  *handle_rvm     = NULL;
 
 int function_comp(void *key1, void *key2)
 {
@@ -62,7 +64,7 @@ int function_match(void *in_obj, void *key)
         return strcmp(obj->key, (char *)key);
 }
 
-static void init(int control)
+static void init(char *mode)
 {
         kv_key_cmp     cmp_routine;
         kv_key_match   match_routine;
@@ -73,8 +75,8 @@ static void init(int control)
         m0_ks_init_domain(&dom);
         M0_ASSERT(dom != NULL);
 
-        m0_ks_init(&handle, &list_descr, dom, cmp_routine, match_routine,
-                   control);
+
+        m0_ks_init(&handle, &list_descr, dom, cmp_routine, match_routine, mode);
         M0_ASSERT(handle != NULL);
 }
 
@@ -83,8 +85,7 @@ static void fini()
         m0_ks_fini(dom, seg);
 }
 
-static int insert(struct m0_kv_store_obj **obj,
-                                   char *key_name, int val)
+static int insert(char *key_name, int val)
 {
         int                      status  = -2;
         struct m0_be_tx         *tx;
@@ -109,15 +110,21 @@ static int insert(struct m0_kv_store_obj **obj,
         m0_ks_tx_start(tx);
 
         /* Memory alloc to the object via rvm */
-        (*obj) = (struct m0_kv_store_obj *)m0_ks_obj_malloc(obj_reg, &obj_ref);
+        object[val] = (struct m0_kv_store_obj *)m0_ks_obj_malloc(obj_reg,
+                                                                 &obj_ref);
+
+        if(val < 10)
+                printf("object offset = %ld\n", obj_ref->segid_offset.u_lo);
 
-        if ((*obj) == NULL)
+        if (object[val] == NULL)
                 goto exit_failure;
 
         M0_ASSERT(obj_ref != NULL);
 
-        strcpy((*obj)->key, key_name);
-        (*obj)->val = val;
+        strncpy(object[val]->key, key_name, strlen(key_name));
+        /*memcpy( object[val]->key, key_name, strlen(key_name)+1);*/
+
+        object[val]->obj_val = val;
 
         /* Insert this into the kv_store*/
         status = m0_ks_insert(handle, obj_ref, tx);
@@ -186,95 +193,78 @@ static int delete(struct m0_kv_store_obj *target)
 }
 
 int main(int argc, char *argv[]) {
-        struct m0_kv_store_obj  *obj1 = NULL;
-        struct m0_kv_store_obj  *obj2 = NULL;
-        struct m0_kv_store_obj  *obj3 = NULL;
-        struct m0_kv_store_obj  *obj4 = NULL;
-        struct m0_kv_store_obj  *ret_obj1 = NULL;
-        struct m0_kv_store_obj  *ret_obj2 = NULL;
-        struct m0_kv_store_obj  *ret_obj3 = NULL;
-        struct m0_kv_store_obj  *ret_obj4 = NULL;
         int                      status = -2;
-        char                     obj1_name[] = "abc";
-        char                     obj2_name[] = "jkl";
-        char                     obj3_name[] = "ghi";
-        char                     obj4_name[] = "def";
-        char                     mode[8];
-
-        if (argc != 2) {
-                printf("Usage:./be_kv_store_ut CREATE ./be_kv_store RECOVER\n");
+        int                      i      =  0;
+        int                      count  =  0;
+        size_t                   length =  0;
+        char                     obj_name[MAX_KEY_SIZE]   = "a";
+
+        if (argc != 4) {
+                printf("Usage : ./be_kv_store_ut recover/create "
+                        "object_name insert/delete\n");
                 return 0;
         }
 
-        strcpy(mode, argv[1]);
+        /* Init */
+        init(argv[1]);
 
-        if(strncmp(mode, "CREATE", 6) == 0)
-                init(CREATE);
-        else
-                init(RECOVER);
+        m0_ks_domain_lookup(dom, &seg, 1);
+        M0_ASSERT(seg != NULL);
 
-        m0_be_domain_lookup(dom, 1, &seg);
-        M0_BE_WAIT(seg->bs_impl.sm_group, &(seg->bs_sm),
-                        (1 << M0_BESEG_ACTIVE) | (1 << M0_BESEG_FAILED));
+        strcat(obj_name, argv[2]);
 
-        M0_ASSERT(seg != NULL);
+        /* Insert 1K objects */
+        if (strcmp(argv[3], "insert") == 0) {
+                for(i = 0; i < 10; i++) {
+                        status = insert(obj_name, i);
+                        M0_ASSERT(status == BE_KV_SUCCESS);
 
-        if(strncmp(mode, "CREATE", 6) == 0) {
-                /* insert obj1 */
-                status = insert(&obj1, obj1_name, 1);
-                M0_ASSERT(status == BE_KV_SUCCESS);
-                printf("\nInserted obj1...\n");
-
-                /*insert obj2 */
-                status = insert(&obj2, obj2_name, 2);
-                M0_ASSERT(status == BE_KV_SUCCESS);
-                printf("Inserted obj2...\n");
-
-                /* insert obj3 */
-                status = insert(&obj3, obj3_name, 3);
-                M0_ASSERT(status == BE_KV_SUCCESS);
-                printf("Inserted obj3...\n");
-
-                /* insert obj4 */
-                status = insert(&obj4, obj4_name, 4);
-                M0_ASSERT(status == BE_KV_SUCCESS);
-                printf("Inserted obj4...\n");
-       } else {
-               /* Recover the handle from rvm */
-                m0_ks_deref_handle(handle, seg);
-
-                ret_obj1  = (struct m0_kv_store_obj *)find(obj1_name);
-                M0_ASSERT(ret_obj1 != NULL);
-                printf("\nFound obj1 with val = %d\n", ret_obj1->val);
-
-                ret_obj2  = (struct m0_kv_store_obj *)find(obj2_name);
-                M0_ASSERT(ret_obj2 != NULL);
-                printf("Found obj2 with val = %d\n", ret_obj2->val);
-
-                ret_obj3  = (struct m0_kv_store_obj *)find(obj3_name);
-                M0_ASSERT(ret_obj3 != NULL);
-                printf("Found obj3 with val = %d\n", ret_obj3->val);
-
-                ret_obj4  = (struct m0_kv_store_obj *)find(obj4_name);
-                M0_ASSERT(ret_obj4 != NULL);
-                printf("Found obj4 with val = %d\n", ret_obj4->val);
-
-                status = delete(ret_obj1);
-                M0_ASSERT(status == BE_KV_SUCCESS);
-                printf("\nDeleted obj1\n");
-
-                status = delete(ret_obj2);
-                M0_ASSERT(status == BE_KV_SUCCESS);
-                printf("Deleted obj2\n");
-
-                status = delete(ret_obj3);
-                M0_ASSERT(status == BE_KV_SUCCESS);
-                printf("Deleted obj3\n");
-
-                status = delete(ret_obj4);
-                M0_ASSERT(status == BE_KV_SUCCESS);
-                printf("Deleted obj4\n");
+                        if (strlen(obj_name) < 255)
+                                strcat(obj_name, "a");
+                        else
+                                strcpy(obj_name, "akv");
+                }
+                printf("Inserted 10 objects!!\n");
         }
+
+        /* Find the inserted objects */
+        count = 0;
+        strcpy(obj_name, "a");
+        strcat(obj_name, argv[2]);
+
+        length = m0_be_tlist_length(&list_descr, &handle->handle_rvm->ks_tlist);
+        if (length == 0) {
+                printf("Nothing to do\n");
+                fini();
+                m0_free(handle);
+                return 0;
+        }
+
+        for(i = 0; i < 10; i++) {
+                ret_obj[i]  = (struct m0_kv_store_obj *)find(obj_name);
+                M0_ASSERT(ret_obj[i] != NULL);
+
+                if (strlen(obj_name) < 255)
+                        strcat(obj_name, "a");
+                else
+                        strcpy(obj_name, "akv");
+        }
+
+        printf("List length = %ld\n", length);
+        printf("Found objects, last val= %d\n", ret_obj[9]->obj_val);
+
+        /* Delete'em */
+        if (strcmp(argv[3], "delete") == 0) {
+                for(i =0; i < 10; i++) {
+                        status = delete(ret_obj[i]);
+                        M0_ASSERT(status == BE_KV_SUCCESS);
+                }
+                printf("Deleted 10 objects!!\n");
+                length = m0_be_tlist_length(&list_descr,
+                                            &handle->handle_rvm->ks_tlist);
+                printf("List length = %ld\n", length);
+        }
+
         fini();
         m0_free(handle);
         return 0;
-- 
1.8.3.2

