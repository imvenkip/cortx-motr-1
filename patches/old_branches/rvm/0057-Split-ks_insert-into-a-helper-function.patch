From 83b20c9661bc156f3b7526dcdc88d8c3ef5c3222 Mon Sep 17 00:00:00 2001
From: Zishan Shaikh <zishan_shaikh@xyratex.com>
Date: Fri, 22 Feb 2013 01:52:53 -0800
Subject: [PATCH 057/121] Split ks_insert into a helper function

---
 be/kv_store.c         | 88 +++++++++++++++++++++++++++++++--------------------
 be/kv_store_private.h |  7 ++++
 2 files changed, 60 insertions(+), 35 deletions(-)

diff --git a/be/kv_store.c b/be/kv_store.c
index 594740f..dcbe5cc 100644
--- a/be/kv_store.c
+++ b/be/kv_store.c
@@ -365,10 +365,7 @@ M0_INTERNAL int32_t m0_be_ks_insert(struct m0_be_kv_store   *handle,
                                     struct m0_be_reference  *obj_ref,
                                     struct m0_be_tx         *tx)
 {
-        struct m0_be_reg        *obj_link_reg;
         struct m0_be_domain     *dom;
-        struct m0_be_reg        *t_head_reg;
-        struct m0_list_link     *link;
         struct m0_tl            *ks_tlist;
         struct m0_tl_descr      *ks_list_descr;
         struct m0_list_link     *head;
@@ -380,10 +377,7 @@ M0_INTERNAL int32_t m0_be_ks_insert(struct m0_be_kv_store   *handle,
         M0_ENTRY("handle: %p obj:%p", handle, obj_ref->be_virtual_address);
         M0_ASSERT(tx != NULL);
 
-        ks_list_descr = handle->ks_handle_heap.ksh_list_descr;
-        ks_tlist      = &handle->ks_handle_rvm->ksr_tlist;
         dom           = handle->ks_handle_heap.ksh_dom;
-        sm_group      = m0_be_domain_sm_group(dom);
 
         /* Ensure object is allocated on same domain as that of handle */
         if (obj_ref->be_magic != dom->bd_magic) {
@@ -392,44 +386,25 @@ M0_INTERNAL int32_t m0_be_ks_insert(struct m0_be_kv_store   *handle,
                 goto exit_insert;
         }
 
-        /** Collect the object to be inserted. */
-        new = obj_ref->be_virtual_address;
+        ks_list_descr = handle->ks_handle_heap.ksh_list_descr;
+        ks_tlist      = &handle->ks_handle_rvm->ksr_tlist;
+        sm_group      = m0_be_domain_sm_group(dom);
+        head          = (void *)&ks_tlist->t_head;
+
+        /* Collect the object to be inserted. */
+        new           = obj_ref->be_virtual_address;
 
         /* Check for duplicate insertion */
         m0_tlist_for(ks_list_descr, ks_tlist, scan) {
-                if (handle->ks_handle_heap.ksh_key_cmp(new, scan) == 0) {
+                if (handle->ks_handle_heap.ksh_key_match(new, scan) == 0) {
                         ret_val = BE_KV_DUPLICATE;
                         M0_LOG(M0_ERROR, "kv_insert: duplicate insertion!");
                         goto exit_insert;
                 }
         } m0_tlist_endfor;
 
-        /* Tlink init for this object */
-        m0_tlink_init(ks_list_descr, new);
-
-        __ks_get_current(ks_list_descr, new, &link);
-        M0_ASSERT(link != NULL);
-
-        /* Init a region for this link */
-        m0_be_ks_prep_link_reg(dom, link, tx, &obj_link_reg);
-        M0_ASSERT(obj_link_reg != NULL);
-
-        /** Capture this region. */
-        m0_be_reg_capture(obj_link_reg);
-        m0_free(obj_link_reg);
-
-        head = (void *)&ks_tlist->t_head;
-
-        /*
-         * Prepare t_head.
-         * Because object could be added at head or before head
-         */
-        m0_be_ks_prep_link_reg(dom, head, tx, &t_head_reg);
-        M0_ASSERT(t_head_reg != NULL);
-
-        /* Capture t_head */
-        m0_be_reg_capture(t_head_reg);
-        m0_free(t_head_reg);
+        /* Capture the linkages of head and @new object */
+        __ks_insert_capture_head_new(handle, new, tx);
 
         /* Check if tlist is empty */
         if ((head->ll_next == (void *)head) &&
@@ -504,6 +479,49 @@ exit_deref:
 }
 M0_EXPORTED(m0_be_ks_deref_handle);
 
+static void __ks_insert_capture_head_new(struct m0_be_kv_store  *handle,
+                                         void                   *new,
+                                         struct m0_be_tx        *tx)
+{
+        struct m0_be_domain     *dom;
+        struct m0_be_reg        *t_head_reg;
+        struct m0_be_reg        *obj_link_reg;
+        struct m0_list_link     *link;
+        struct m0_list_link     *head;
+        struct m0_tl            *ks_tlist;
+        struct m0_tl_descr      *ks_list_descr;
+
+        ks_list_descr = handle->ks_handle_heap.ksh_list_descr;
+        ks_tlist      = &handle->ks_handle_rvm->ksr_tlist;
+        head          = (void *)&ks_tlist->t_head;
+        dom           = handle->ks_handle_heap.ksh_dom;
+
+        /* Tlink init for this object */
+        m0_tlink_init(ks_list_descr, new);
+
+        __ks_get_current(ks_list_descr, new, &link);
+        M0_ASSERT(link != NULL);
+
+        /* Init a region for this link */
+        m0_be_ks_prep_link_reg(dom, link, tx, &obj_link_reg);
+        M0_ASSERT(obj_link_reg != NULL);
+
+        /** Capture this region. */
+        m0_be_reg_capture(obj_link_reg);
+        m0_free(obj_link_reg);
+
+        /*
+         * Prepare t_head.
+         * Because object could be added at head or before head
+         */
+        m0_be_ks_prep_link_reg(dom, head, tx, &t_head_reg);
+        M0_ASSERT(t_head_reg != NULL);
+
+        /* Capture t_head */
+        m0_be_reg_capture(t_head_reg);
+        m0_free(t_head_reg);
+}
+
 static void __ks_get_prev(struct m0_tl_descr   *d,
                           void                 *current,
                           struct m0_list_link **link_prev)
diff --git a/be/kv_store_private.h b/be/kv_store_private.h
index 951d8de..d806064 100644
--- a/be/kv_store_private.h
+++ b/be/kv_store_private.h
@@ -65,6 +65,13 @@ static void __ks_prev_next_add_cred(struct m0_be_kv_store     *handle,
                                     int                        operation);
 
 /**
+  Captures the regions for head and new object.
+ */
+static void __ks_insert_capture_head_new(struct m0_be_kv_store *handle,
+                                         void                  *new,
+                                         struct m0_be_tx       *tx);
+
+/**
   Recovers the persistent part of the kv_store handle from rvm and puts it back
   in the @handle.
 
-- 
1.8.3.2

