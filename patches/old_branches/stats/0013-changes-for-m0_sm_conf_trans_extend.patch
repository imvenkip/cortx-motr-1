From 803f2d3227562f27aebf823069103c279cac9cf0 Mon Sep 17 00:00:00 2001
From: Rajanikant Chirmade <rajanikant_chirmade@xyratex.com>
Date: Thu, 30 Jan 2014 12:26:46 +0530
Subject: [PATCH 13/50]  - changes for m0_sm_conf_trans_extend(),  - moved fom
 phase transition counter macros to function.

---
 fop/fom.c                | 18 ++++++++++++++----
 fop/fom.h                | 13 +++++++++++--
 fop/ut/stats/stats_fom.c |  7 +++----
 ioservice/io_foms.c      |  6 +++---
 ioservice/io_fops.c      | 13 ++++++-------
 sm/sm.c                  | 39 ++++++++++++++++++++-------------------
 sm/sm.h                  | 15 ++++++++++-----
 7 files changed, 67 insertions(+), 44 deletions(-)

diff --git a/fop/fom.c b/fop/fom.c
index 8a4c020..d2fabf6 100644
--- a/fop/fom.c
+++ b/fop/fom.c
@@ -427,7 +427,7 @@ static void fom_ready(struct m0_fom *fom)
 	bool                    empty;
 
 	fom_state_set(fom, M0_FOS_READY);
-	fom->fo_sched_epoch = fom->fo_sm_state.sm_state_epoch ?: m0_time_now();
+	fom->fo_sched_epoch = fom->fo_sm_state.sm_state_epoch;
 	loc = fom->fo_loc;
 	empty = runq_tlist_is_empty(&loc->fl_runq);
 	runq_tlist_add_tail(&loc->fl_runq, fom);
@@ -630,7 +630,7 @@ static void fom_exec(struct m0_fom *fom)
 	loc = fom->fo_loc;
 	fom->fo_thread = loc->fl_handler;
 	fom_state_set(fom, M0_FOS_RUNNING);
-	exec_time = fom->fo_sm_state.sm_state_epoch ?: m0_time_now();
+	exec_time = fom->fo_sm_state.sm_state_epoch;
 	do {
 		M0_ASSERT(m0_fom_invariant(fom));
 		M0_ASSERT(m0_fom_phase(fom) != M0_FOM_PHASE_FINISH);
@@ -1173,8 +1173,6 @@ void m0_fom_init(struct m0_fom *fom, struct m0_fom_type *fom_type,
 		m0_fop_get(reply);
 	fom->fo_rep_fop = reply;
 
-	fom->fo_phase_stats_data = NULL;
-
 	/**
 	 * NOTE: The service may be in M0_RST_STARTING state
 	 * if the fom was launched on startup
@@ -1542,6 +1540,18 @@ M0_INTERNAL int m0_fom_fol_rec_add(struct m0_fom *fom)
 	return rc;
 }
 
+M0_INTERNAL int m0_fom_phase_trans_size(struct m0_fom *fom)
+{
+	int size;
+
+	M0_PRE(fom != NULL);
+	M0_PRE(fom->fo_type != NULL);
+	M0_PRE(fom->fo_type->ft_conf != NULL);
+
+	size = M0_FOM_STATS_CNTR_DATA * fom->fo_type->ft_conf->scf_trans_nr;
+	return size;
+}
+
 /** @} endgroup fom */
 #undef FOM_RATE_KEY
 /*
diff --git a/fop/fom.h b/fop/fom.h
index adf3bdb..641aa2d 100644
--- a/fop/fom.h
+++ b/fop/fom.h
@@ -928,8 +928,17 @@ M0_INTERNAL int m0_fom_op_addb_ctx_import(struct m0_fom *fom,
  */
 M0_INTERNAL int m0_fom_fol_rec_add(struct m0_fom *fom);
 
-#define M0_FOM_PHASE_TRANS_SZ(fom)                                      \
-	(FOM_PHASE_STATS_DATA_SZ((fom)->fo_type->ft_conf->scf_trans_nr))
+/**
+ * Returns size of counter data depending on number of possible transitions.
+ *
+ * @pre fom != NULL
+ * @pre fom->fo_type != NULL
+ * @pre fom->fo_type->ft_conf != NULL
+ *
+ * @param fom pointer to FOM structure.
+ * @return size of counter data on success.
+ */
+M0_INTERNAL int m0_fom_phase_trans_size(struct m0_fom *fom);
 
 #endif /* __MERO_FOP_FOM_H__ */
 /** @} end of fom group */
diff --git a/fop/ut/stats/stats_fom.c b/fop/ut/stats/stats_fom.c
index b6e0e6f..6aaa94b 100644
--- a/fop/ut/stats/stats_fom.c
+++ b/fop/ut/stats/stats_fom.c
@@ -100,17 +100,16 @@ static size_t fom_stats_home_locality(const struct m0_fom *fom)
 static void fom_stats_addb_init(struct m0_fom *fom, struct m0_addb_mc *mc)
 {
 	struct fom_stats *fom_obj;
+	int trans_size = m0_fom_phase_trans_size(fom);
 	fom_obj = container_of(fom, struct fom_stats, fs_gen);
 
 	M0_ADDB_CTX_INIT(&m0_addb_gmc, &fom->fo_addb_ctx, &m0_addb_ct_fop_mod,
 			 &m0_addb_proc_ctx);
 
-	M0_ALLOC_ARR(fom->fo_phase_stats_data,
-		     FOM_PHASE_STATS_DATA_SZ(fom_phases_conf.scf_trans_nr));
+	M0_ALLOC_ARR(fom->fo_phase_stats_data, trans_size);
 	m0_addb_sm_counter_init(&fom->fo_sm_phase_stats,
 				&addb_rt_fom_phase_stats,
-				fom->fo_phase_stats_data,
-				FOM_PHASE_STATS_DATA_SZ(fom_phases_conf.scf_trans_nr));
+				fom->fo_phase_stats_data, trans_size);
 }
 
 static int stats_fom_create(struct m0_fom **m, struct m0_reqh *reqh)
diff --git a/ioservice/io_foms.c b/ioservice/io_foms.c
index 470ca85..159402b 100644
--- a/ioservice/io_foms.c
+++ b/ioservice/io_foms.c
@@ -2087,6 +2087,7 @@ static void m0_io_fom_cob_rw_addb_init(struct m0_fom *fom,
 				       struct m0_addb_mc *mc)
 {
         struct m0_fop_cob_rw *rwfop;
+	int trans_size = m0_fom_phase_trans_size(fom);
 
 	rwfop = io_rw_get(fom->fo_fop);
 	M0_ADDB_CTX_INIT(mc, &fom->fo_addb_ctx, &m0_addb_ct_cob_io_rw_fom,
@@ -2095,13 +2096,12 @@ static void m0_io_fom_cob_rw_addb_init(struct m0_fom *fom,
 			 rwfop->crw_desc.id_nr, rwfop->crw_flags);
 	m0_fom_op_addb_ctx_import(fom, &rwfop->crw_addb_ctx_id);
 
-	IOS_ALLOC_ARR(fom->fo_phase_stats_data, M0_FOM_PHASE_TRANS_SZ(fom),
+	IOS_ALLOC_ARR(fom->fo_phase_stats_data, trans_size,
 		      &m0_ios_addb_ctx, FOM_COB_RW_ADDB_INIT);
 	if (fom->fo_phase_stats_data != NULL) {
 		m0_addb_sm_counter_init(&fom->fo_sm_phase_stats,
 					&m0_addb_rt_ios_io_fom_phase_stats,
-					fom->fo_phase_stats_data,
-					M0_FOM_PHASE_TRANS_SZ(fom));
+					fom->fo_phase_stats_data, trans_size);
 	}
 }
 
diff --git a/ioservice/io_fops.c b/ioservice/io_fops.c
index edb0623..0410f34 100644
--- a/ioservice/io_fops.c
+++ b/ioservice/io_fops.c
@@ -218,8 +218,7 @@ M0_INTERNAL int m0_ioservice_fop_init(void)
 {
 	struct m0_sm_conf *p_cob_ops_conf;
 #ifndef __KERNEL__
-	int                       rc;
-
+	uint32_t           new_nr;
 	p_cob_ops_conf = &cob_ops_conf;
 #else
 	p_cob_ops_conf = &m0_generic_conf;
@@ -237,15 +236,15 @@ M0_INTERNAL int m0_ioservice_fop_init(void)
 	m0_sm_conf_extend(m0_generic_conf.scf_state, cob_ops_phases,
 			  m0_generic_conf.scf_nr_states);
 
-	rc = m0_sm_conf_trans_extend(&m0_generic_conf, &io_conf, &new_trans);
-	if (rc != 0) {
+	new_nr = io_conf.scf_trans_nr + m0_generic_conf.scf_trans_nr;
+	M0_ALLOC_ARR(new_trans, new_nr);
+	if (new_trans == NULL) {
 		m0_xc_io_fops_fini();
 		m0_addb_ctx_fini(&m0_ios_addb_ctx);
-		return rc;
+		return -ENOMEM;
 	}
-
 	io_conf.scf_trans    = new_trans;
-	io_conf.scf_trans_nr += m0_generic_conf.scf_trans_nr;
+	m0_sm_conf_trans_extend(&m0_generic_conf, &io_conf, new_nr);
 
 	m0_sm_conf_init(&io_conf);
 #endif
diff --git a/sm/sm.c b/sm/sm.c
index 1db6545..14b7ab4 100644
--- a/sm/sm.c
+++ b/sm/sm.c
@@ -639,31 +639,32 @@ M0_INTERNAL bool m0_sm_timeout_is_armed(const struct m0_sm_timeout *to)
 	return m0_sm_timer_is_armed(&to->st_timer);
 }
 
-M0_INTERNAL int m0_sm_conf_trans_extend(const struct m0_sm_conf   *base,
-				        const struct m0_sm_conf   *sub,
-					struct m0_sm_trans_descr **new)
+static bool trans_exists(const struct m0_sm_conf *conf,
+			 uint32_t src, uint32_t tgt)
+{
+	return !m0_forall(i, conf->scf_trans_nr,
+			  conf->scf_trans[i].td_src != src ||
+			  conf->scf_trans[i].td_tgt != tgt);
+}
+
+M0_INTERNAL void m0_sm_conf_trans_extend(const struct m0_sm_conf *base,
+					 struct m0_sm_conf *sub,
+					 uint32_t max_size)
 {
-	uint32_t new_nr;
 	uint32_t i;
-	uint32_t j;
 
-	M0_PRE(base != NULL && sub != NULL);
 	M0_PRE(conf_invariant(base));
-	M0_PRE(conf_invariant(sub));
-
-	new_nr  = base->scf_trans_nr + sub->scf_trans_nr;
-
-	M0_ALLOC_ARR(*new, new_nr);
-	if (*new == NULL)
-		M0_RETURN(-ENOMEM);
+	M0_PRE(sub->scf_trans_nr <= max_size);
 
-	for (i = 0; i < base->scf_trans_nr; ++i)
-		(*new)[i] = base->scf_trans[i];
+	for (i = 0; i < base->scf_trans_nr;) {
+		const struct m0_sm_trans_descr *b = &base->scf_trans[i];
 
-	for (j = 0; i < new_nr && j < sub->scf_trans_nr; ++i, j++)
-		(*new)[i] = sub->scf_trans[j];
-
-	return 0;
+		if (!trans_exists(sub, b->td_src, b->td_tgt)) {
+			sub->scf_trans[sub->scf_trans_nr++] = *b;
+			M0_ASSERT(sub->scf_trans_nr <= max_size);
+		}
+	}
+	M0_POST(conf_invariant(sub));
 }
 
 M0_INTERNAL void m0_sm_conf_extend(const struct m0_sm_state_descr *base,
diff --git a/sm/sm.h b/sm/sm.h
index e89b771..69561c6 100644
--- a/sm/sm.h
+++ b/sm/sm.h
@@ -350,7 +350,7 @@ struct m0_sm_conf {
 	/** Number of state transitions in this state machine. */
 	uint32_t                        scf_trans_nr;
 	/** Array of state transitions descriptions. */
-	const struct m0_sm_trans_descr *scf_trans;
+	struct m0_sm_trans_descr       *scf_trans;
 };
 
 enum {
@@ -727,11 +727,16 @@ enum m0_sm_return {
 };
 
 /**
- * "Extends" base transition descriptions with the given sub descriptions.
+ * Extends transition table of "base" with new transitions from "sub".
+ *
+ * Resulting table is stored in "sub", which should be of sufficient size.
+ * Transitions in "sub" override matching transitions in "base".
+ *
+ * @param max_size size of array allocated for sub->scf_trans[].
  */
-M0_INTERNAL int m0_sm_conf_trans_extend(const struct m0_sm_conf   *base,
-			                const struct m0_sm_conf   *sub,
-					struct m0_sm_trans_descr **new);
+M0_INTERNAL void m0_sm_conf_trans_extend(const struct m0_sm_conf *base,
+					 struct m0_sm_conf *sub,
+					 uint32_t max_size);
 /**
  * "Extends" base state descriptions with the given sub descriptions.
  *
-- 
1.8.3.2

