From 3f753942cb8eef21c5611adcf21fe7aaabe8c78e Mon Sep 17 00:00:00 2001
From: Rajanikant Chirmade <rajanikant_chirmade@xyratex.com>
Date: Thu, 26 Dec 2013 18:21:52 +0530
Subject: [PATCH 11/50]  - Inspection comment cleared.

---
 fop/fom.c                | 18 +++++-----------
 fop/fom.h                | 29 ++++---------------------
 fop/fom_generic.c        | 56 +++++++++++++++++++++++-------------------------
 fop/fom_generic.h        |  6 +-----
 fop/ut/stats/stats_fom.c |  8 +++----
 fop/ut/stats/stats_fom.h |  6 ------
 ioservice/io_foms.c      |  7 +++---
 ioservice/io_fops.c      |  2 +-
 ioservice/ut/bulkio_ut.c | 33 +++++++++++++++++++---------
 sm/sm.c                  | 13 +++++++----
 10 files changed, 77 insertions(+), 101 deletions(-)

diff --git a/fop/fom.c b/fop/fom.c
index d9185d1..8a4c020 100644
--- a/fop/fom.c
+++ b/fop/fom.c
@@ -1124,8 +1124,10 @@ void m0_fom_fini(struct m0_fom *fom)
 		m0_sm_stats_post(&fom->fo_sm_state, &reqh->rh_addb_mc,
 				M0_FOM_ADDB_CTX_VEC(fom));
 		m0_addb_sm_counter_fini(&fom->fo_sm_state_stats);
-		if (fom->fo_sm_phase.sm_state_epoch != 0)
+		if (fom->fo_phase_stats_data != NULL) {
+			m0_free(fom->fo_phase_stats_data);
 			m0_addb_sm_counter_fini(&fom->fo_sm_phase_stats);
+		}
 	}
 	m0_sm_fini(&fom->fo_sm_phase);
 	m0_sm_fini(&fom->fo_sm_state);
@@ -1171,6 +1173,8 @@ void m0_fom_init(struct m0_fom *fom, struct m0_fom_type *fom_type,
 		m0_fop_get(reply);
 	fom->fo_rep_fop = reply;
 
+	fom->fo_phase_stats_data = NULL;
+
 	/**
 	 * NOTE: The service may be in M0_RST_STARTING state
 	 * if the fom was launched on startup
@@ -1196,21 +1200,9 @@ void m0_fom_init(struct m0_fom *fom, struct m0_fom_type *fom_type,
 	}
 	if (m0_addb_ctx_is_initialized(&fom->fo_addb_ctx))
 		M0_FOM_ADDB_POST(fom, &reqh->rh_addb_mc, &m0_addb_rt_fom_init);
-	fom->fo_sm_phase.sm_state_epoch =
-		fom->fo_phase_stats_data == NULL ? 0 : m0_time_now();
 }
 M0_EXPORTED(m0_fom_init);
 
-M0_INTERNAL void m0_fom_phase_stats_enable(struct m0_fom *fom,
-					   struct m0_addb_sm_counter *c)
-{
-	M0_PRE(fom != NULL);
-	M0_PRE(fom->fo_sm_phase.sm_state_epoch == 0);
-
-	fom->fo_sm_phase.sm_state_epoch = 1;
-	fom->fo_sm_phase.sm_addb_stats = c;
-}
-
 static bool fom_clink_cb(struct m0_clink *link)
 {
 	struct m0_fom_callback *cb = container_of(link, struct m0_fom_callback,
diff --git a/fop/fom.h b/fop/fom.h
index 61fa04f..adf3bdb 100644
--- a/fop/fom.h
+++ b/fop/fom.h
@@ -381,6 +381,8 @@ enum { M0_FOS_TRANS_NR = 8 };
  * Histogram arguments for m0_addb_rt_fom_[state|phase]_stats.
  * Define the macro with histogram arguments if desired.
  * e.g. #define M0_FOM_SM_STATS_HIST_ARGS 100, 200, 500
+ * @note Histogtam may different for states & phases stats.
+ *       May differentiate it later if required.
  */
 #undef M0_FOM_SM_STATS_HIST_ARGS
 
@@ -557,11 +559,10 @@ struct m0_fom {
 	/** addb sm counter for phases statistics */
 	struct m0_addb_sm_counter fo_sm_phase_stats;
 	/**
-         * counter data for states statistics
+         * counter data for phases statistics
          * fo_addb_init() allocates it.
          */
 	uint8_t                  *fo_phase_stats_data;
-	uint32_t                  fo_phase_stats_data_size;
 
 	/** Thread executing current phase transition. */
 	struct m0_loc_thread     *fo_thread;
@@ -646,28 +647,6 @@ void m0_fom_init(struct m0_fom *fom, struct m0_fom_type *fom_type,
 void m0_fom_fini(struct m0_fom *fom);
 
 /**
- * Enables m0_sm state statistics for the fom's phases.
- * Must be called between m0_fom_init() and m0_fom_queue()
- * (which calls m0_fom_sm_init() inside).
- * It is caller's responsibility to:
- *
- *  - initialize the counter;
- *
- *  - serialize access to the counter between different state machines
- *    along with posting; for this reason it is encouraged that the counter
- *    is shared only among the state machines of the same group;
- *
- *  - finalize the counter.
- *
- * @param c counter initialized by caller.
- *
- * @pre fom != NULL
- * @pre fom->fo_sm_phase.sm_state_epoch == 0
- */
-M0_INTERNAL void m0_fom_phase_stats_enable(struct m0_fom *fom,
-					   struct m0_addb_sm_counter *c);
-
-/**
  * Iterates over m0_fom members and check if they are consistent,
  * and also checks if the fom resides on correct list (i.e runq or
  * wait list) of the locality at any given instance.
@@ -949,7 +928,7 @@ M0_INTERNAL int m0_fom_op_addb_ctx_import(struct m0_fom *fom,
  */
 M0_INTERNAL int m0_fom_fol_rec_add(struct m0_fom *fom);
 
-#define M0_FOM_PHASE_TRANS_NR(fom)                                      \
+#define M0_FOM_PHASE_TRANS_SZ(fom)                                      \
 	(FOM_PHASE_STATS_DATA_SZ((fom)->fo_type->ft_conf->scf_trans_nr))
 
 #endif /* __MERO_FOP_FOM_H__ */
diff --git a/fop/fom_generic.c b/fop/fom_generic.c
index 3c27955..7c8217f 100644
--- a/fop/fom_generic.c
+++ b/fop/fom_generic.c
@@ -660,32 +660,32 @@ static struct m0_sm_state_descr generic_phases[] = {
 
 /* @todo Need alignment and proper cause */
 static struct m0_sm_trans_descr generic_phases_trans[] = {
-	{"Initialised",	M0_FOPH_INIT,	M0_FOPH_AUTHENTICATE},
-	{"Initialised",	M0_FOPH_INIT,	M0_FOPH_FINISH},
-	{"Initialised",	M0_FOPH_INIT,	M0_FOPH_SUCCESS},
-	{"Init failed",	M0_FOPH_INIT,	M0_FOPH_FAILURE},
-	{"Initialised",	M0_FOPH_INIT,	M0_FOPH_TYPE_SPECIFIC},
-	{"FOM authentication initialised", M0_FOPH_AUTHENTICATE,
-					   M0_FOPH_AUTHENTICATE_WAIT},
-	{"FOM authentication initialised", M0_FOPH_AUTHENTICATE,
-					   M0_FOPH_RESOURCE_LOCAL},
+	{"FOM initialised",	M0_FOPH_INIT,	M0_FOPH_AUTHENTICATE},
+	{"FOM finished",	M0_FOPH_INIT,	M0_FOPH_FINISH},
+	{"FOM Success",	M0_FOPH_INIT,	M0_FOPH_SUCCESS},
+	{"FOM failed",	M0_FOPH_INIT,	M0_FOPH_FAILURE},
+	{"FOM initialised",	M0_FOPH_INIT,	M0_FOPH_TYPE_SPECIFIC},
+	{"FOM wait authentication", M0_FOPH_AUTHENTICATE,
+				    M0_FOPH_AUTHENTICATE_WAIT},
+	{"FOM authentication finished", M0_FOPH_AUTHENTICATE,
+					M0_FOPH_RESOURCE_LOCAL},
 	{"FOM authentication failed",	M0_FOPH_AUTHENTICATE, M0_FOPH_FAILURE},
 	{"FOM authentication finished", M0_FOPH_AUTHENTICATE_WAIT,
 					M0_FOPH_RESOURCE_LOCAL},
 	{"FOM authentication failed", M0_FOPH_AUTHENTICATE_WAIT,
 				      M0_FOPH_FAILURE},
-	{"Identify local resource", M0_FOPH_RESOURCE_LOCAL,
-						M0_FOPH_RESOURCE_LOCAL_WAIT},
+	{"Wait identify local resource", M0_FOPH_RESOURCE_LOCAL,
+					 M0_FOPH_RESOURCE_LOCAL_WAIT},
 	{"Local resource identified", M0_FOPH_RESOURCE_LOCAL,
-						M0_FOPH_RESOURCE_DISTRIBUTED},
+				      M0_FOPH_RESOURCE_DISTRIBUTED},
 	{"Local resource identification failed", M0_FOPH_RESOURCE_LOCAL,
-						M0_FOPH_FAILURE},
+						 M0_FOPH_FAILURE},
 	{"Local resource identified", M0_FOPH_RESOURCE_LOCAL_WAIT,
-						M0_FOPH_RESOURCE_DISTRIBUTED},
+				      M0_FOPH_RESOURCE_DISTRIBUTED},
 	{"Local resource identification failed", M0_FOPH_RESOURCE_LOCAL_WAIT,
-						     M0_FOPH_FAILURE},
-	{"Identify distributed resource", M0_FOPH_RESOURCE_DISTRIBUTED,
-					  M0_FOPH_RESOURCE_DISTRIBUTED_WAIT},
+					         M0_FOPH_FAILURE},
+	{"Wait identify distributed resource", M0_FOPH_RESOURCE_DISTRIBUTED,
+					     M0_FOPH_RESOURCE_DISTRIBUTED_WAIT},
 	{"Distributed resource identified", M0_FOPH_RESOURCE_DISTRIBUTED,
 					    M0_FOPH_OBJECT_CHECK},
 	{"Distributed resource identification failed",
@@ -696,8 +696,8 @@ static struct m0_sm_trans_descr generic_phases_trans[] = {
 	{"Distributed resource identification failed",
 					M0_FOPH_RESOURCE_DISTRIBUTED_WAIT,
 					M0_FOPH_FAILURE},
-	{"Check for FS objects initiate", M0_FOPH_OBJECT_CHECK,
-				       M0_FOPH_OBJECT_CHECK_WAIT},
+	{"Wait check for FS objects initiate", M0_FOPH_OBJECT_CHECK,
+				               M0_FOPH_OBJECT_CHECK_WAIT},
 	{"FS objects located", M0_FOPH_OBJECT_CHECK, M0_FOPH_AUTHORISATION},
 	{"Check for FS objects init failed", M0_FOPH_OBJECT_CHECK,
 					     M0_FOPH_FAILURE},
@@ -705,10 +705,10 @@ static struct m0_sm_trans_descr generic_phases_trans[] = {
 						M0_FOPH_AUTHORISATION},
 	{"Check for FS object failed", M0_FOPH_OBJECT_CHECK_WAIT,
 				       M0_FOPH_FAILURE},
-	{"Authorisation initiate", M0_FOPH_AUTHORISATION,
-				   M0_FOPH_AUTHORISATION_WAIT},
+	{"Wait authorisation", M0_FOPH_AUTHORISATION,
+			       M0_FOPH_AUTHORISATION_WAIT},
 	{"Authorisation finish", M0_FOPH_AUTHORISATION, M0_FOPH_TXN_INIT},
-	{"Autorisation init failed", M0_FOPH_AUTHORISATION, M0_FOPH_FAILURE},
+	{"Autorisation failed",  M0_FOPH_AUTHORISATION, M0_FOPH_FAILURE},
 	{"Authorisation finish", M0_FOPH_AUTHORISATION_WAIT, M0_FOPH_TXN_INIT},
 	{"Authorisation failed", M0_FOPH_AUTHORISATION_WAIT, M0_FOPH_FAILURE},
 	{"Transaction initialised", M0_FOPH_TXN_INIT, M0_FOPH_TXN_OPEN},
@@ -717,13 +717,11 @@ static struct m0_sm_trans_descr generic_phases_trans[] = {
 	{"Transaction opened", M0_FOPH_TXN_WAIT, M0_FOPH_TYPE_SPECIFIC},
 	{"FOM successfully completed", M0_FOPH_SUCCESS, M0_FOPH_FOL_REC_ADD},
 	{"FOL record added", M0_FOPH_FOL_REC_ADD, M0_FOPH_TXN_COMMIT},
-	{"Transaction commit init", M0_FOPH_TXN_COMMIT, M0_FOPH_QUEUE_REPLY},
-	{"Reply queue init", M0_FOPH_QUEUE_REPLY, M0_FOPH_QUEUE_REPLY_WAIT},
-	{"Reply sent", M0_FOPH_QUEUE_REPLY, M0_FOPH_FINISH},
-	{"Reply sent and transaction commit wait", M0_FOPH_QUEUE_REPLY_WAIT,
-						   M0_FOPH_TXN_COMMIT_WAIT},
-	{"Reply sent", M0_FOPH_QUEUE_REPLY_WAIT,
-						M0_FOPH_FINISH},
+	{"Transaction commited", M0_FOPH_TXN_COMMIT, M0_FOPH_QUEUE_REPLY},
+	{"Wait reply queue", M0_FOPH_QUEUE_REPLY, M0_FOPH_QUEUE_REPLY_WAIT},
+	{"Reply sent FOM finish", M0_FOPH_QUEUE_REPLY, M0_FOPH_FINISH},
+	{"Reply queued", M0_FOPH_QUEUE_REPLY_WAIT, M0_FOPH_TXN_COMMIT_WAIT},
+	{"Reply queued", M0_FOPH_QUEUE_REPLY_WAIT, M0_FOPH_FINISH},
 	{"Transaction commited", M0_FOPH_TXN_COMMIT_WAIT, M0_FOPH_FINISH},
 	{"FOM timed out", M0_FOPH_TIMEOUT, M0_FOPH_FAILURE},
 	{"FOM failed", M0_FOPH_FAILURE, M0_FOPH_TXN_COMMIT},
diff --git a/fop/fom_generic.h b/fop/fom_generic.h
index cc73ccc..ccb4402 100644
--- a/fop/fom_generic.h
+++ b/fop/fom_generic.h
@@ -35,11 +35,7 @@ struct m0_rpc_item;
  * @addtogroup fom
  */
 
-enum {
-	M0_FOM_GENERIC_PHASES_TRANS_NR = 44,
-};
-
-#define FOM_PHASE_STATS_DATA_SZ(NR)	(M0_FOM_STATS_CNTR_DATA * NR)
+#define FOM_PHASE_STATS_DATA_SZ(nr)	(M0_FOM_STATS_CNTR_DATA * (nr))
 
 /**
  * "Phases" through which fom execution typically passes.
diff --git a/fop/ut/stats/stats_fom.c b/fop/ut/stats/stats_fom.c
index 04e750f..b6e0e6f 100644
--- a/fop/ut/stats/stats_fom.c
+++ b/fop/ut/stats/stats_fom.c
@@ -44,7 +44,7 @@ static struct m0_sm_state_descr phases[] = {
 	}
 };
 
-static struct m0_sm_trans_descr trans[NR] = {
+static struct m0_sm_trans_descr trans[] = {
 	{ "Start",    PH_INIT,   PH_RUN },
 	{ "Failed",   PH_INIT,   PH_FINISH },
 	{ "Stop",     PH_RUN,    PH_FINISH }
@@ -105,12 +105,12 @@ static void fom_stats_addb_init(struct m0_fom *fom, struct m0_addb_mc *mc)
 	M0_ADDB_CTX_INIT(&m0_addb_gmc, &fom->fo_addb_ctx, &m0_addb_ct_fop_mod,
 			 &m0_addb_proc_ctx);
 
-	fom->fo_phase_stats_data = fom_obj->fs_stats_data;
-        fom->fo_phase_stats_data_size = sizeof(fom_obj->fs_stats_data);
+	M0_ALLOC_ARR(fom->fo_phase_stats_data,
+		     FOM_PHASE_STATS_DATA_SZ(fom_phases_conf.scf_trans_nr));
 	m0_addb_sm_counter_init(&fom->fo_sm_phase_stats,
 				&addb_rt_fom_phase_stats,
 				fom->fo_phase_stats_data,
-				fom->fo_phase_stats_data_size);
+				FOM_PHASE_STATS_DATA_SZ(fom_phases_conf.scf_trans_nr));
 }
 
 static int stats_fom_create(struct m0_fom **m, struct m0_reqh *reqh)
diff --git a/fop/ut/stats/stats_fom.h b/fop/ut/stats/stats_fom.h
index c5f8069..ae6a59d 100644
--- a/fop/ut/stats/stats_fom.h
+++ b/fop/ut/stats/stats_fom.h
@@ -33,10 +33,6 @@ enum fom_stats_phase {
 };
 
 enum {
-	NR = 3,
-};
-
-enum {
 	ADDB_RECID_FOM_PHASE_STATS = 1777123,
 };
 
@@ -50,8 +46,6 @@ struct fom_stats {
 
 	/** addb sm counter for states statistics */
 	struct m0_addb_sm_counter fs_phase_stats;
-	/** counter data for states statistics */
-	uint8_t                   fs_stats_data[FOM_PHASE_STATS_DATA_SZ(NR)];
 };
 
 #endif /* __MERO_FOP_UT_STATS_FOM_H__ */
diff --git a/ioservice/io_foms.c b/ioservice/io_foms.c
index 97f5e85..c063d45 100644
--- a/ioservice/io_foms.c
+++ b/ioservice/io_foms.c
@@ -610,7 +610,7 @@ static inline struct m0_addb_mc *fom_to_addb_mc(const struct m0_fom *fom);
 /**
  * I/O FOM operation vector.
  */
-static const struct m0_fom_ops ops = {
+struct m0_fom_ops ops = {
 	.fo_fini = m0_io_fom_cob_rw_fini,
 	.fo_tick = m0_io_fom_cob_rw_tick,
 	.fo_home_locality = m0_io_fom_cob_rw_locality_get,
@@ -2092,14 +2092,13 @@ static void m0_io_fom_cob_rw_addb_init(struct m0_fom *fom,
 			 rwfop->crw_desc.id_nr, rwfop->crw_flags);
 	m0_fom_op_addb_ctx_import(fom, &rwfop->crw_addb_ctx_id);
 
-	IOS_ALLOC_ARR(fom->fo_phase_stats_data, M0_FOM_PHASE_TRANS_NR(fom),
+	IOS_ALLOC_ARR(fom->fo_phase_stats_data, M0_FOM_PHASE_TRANS_SZ(fom),
 		      &m0_ios_addb_ctx, FOM_COB_RW_ADDB_INIT);
 	if (fom->fo_phase_stats_data != NULL) {
-		fom->fo_phase_stats_data_size = M0_FOM_PHASE_TRANS_NR(fom) * 8;
 		m0_addb_sm_counter_init(&fom->fo_sm_phase_stats,
 					&m0_addb_rt_ios_io_fom_phase_stats,
 					fom->fo_phase_stats_data,
-					fom->fo_phase_stats_data_size);
+					M0_FOM_PHASE_TRANS_SZ(fom));
 	}
 }
 
diff --git a/ioservice/io_fops.c b/ioservice/io_fops.c
index 463a17f..4c553c4 100644
--- a/ioservice/io_fops.c
+++ b/ioservice/io_fops.c
@@ -228,7 +228,7 @@ M0_INTERNAL int m0_ioservice_fop_init(void)
 	m0_sm_conf_extend(m0_generic_conf.scf_state, cob_ops_phases,
 			  m0_generic_conf.scf_nr_states);
 
-	rc = m0_sm_conf_trans_extend(&io_conf, &m0_generic_conf);
+	rc = m0_sm_conf_trans_extend(&m0_generic_conf, &io_conf);
 	if (rc != 0) {
 		m0_xc_io_fops_fini();
 		m0_addb_ctx_fini(&m0_ios_addb_ctx);
diff --git a/ioservice/ut/bulkio_ut.c b/ioservice/ut/bulkio_ut.c
index f28ae6f..b2f64b5 100644
--- a/ioservice/ut/bulkio_ut.c
+++ b/ioservice/ut/bulkio_ut.c
@@ -1152,19 +1152,32 @@ static int io_fop_stob_create_fom_create(struct m0_fop  *fop,
 					 struct m0_fom **m,
 					 struct m0_reqh *reqh)
 {
-	int            rc;
-	struct m0_fom *fom;
+	struct m0_io_fom_cob_rw *fom_obj;
+	struct m0_fop           *rep_fop;
+	struct m0_fom           *fom;
+
+	M0_ALLOC_PTR(fom_obj);
+	M0_UT_ASSERT(fom_obj != NULL);
+
+        rep_fop = m0_is_read_fop(fop) ?
+                    m0_fop_alloc(&m0_fop_cob_readv_rep_fopt, NULL) :
+                    m0_fop_alloc(&m0_fop_cob_writev_rep_fopt, NULL);
+        if (rep_fop == NULL) {
+                m0_free(fom_obj);
+                M0_UT_ASSERT(rep_fop != NULL);
+        }
 
-	rc = m0_io_fom_cob_rw_create(fop, &fom, reqh);
-        M0_UT_ASSERT(rc == 0);
+        fom = &fom_obj->fcrw_gen;
+        m0_fom_init(fom, &fop->f_type->ft_fom_type,
+                    &bulkio_stob_create_fom_ops, fop, rep_fop, reqh,
+                    fop->f_type->ft_fom_type.ft_rstype);
 
-	/* Ignore fom stats */
-	fom->fo_phase_stats_data = NULL;
+        m0_fop_put(rep_fop);
+        m0_fop_put(fop);
 
-	fom->fo_ops = &bulkio_stob_create_fom_ops;
-	*m = fom;
-        M0_UT_ASSERT(fom->fo_fop != 0);
-	return rc;
+        *m = fom;
+
+        return 0;
 }
 
 static int io_fop_server_write_fom_create(struct m0_fop  *fop,
diff --git a/sm/sm.c b/sm/sm.c
index 7e1288c..6f823c4 100644
--- a/sm/sm.c
+++ b/sm/sm.c
@@ -639,8 +639,8 @@ M0_INTERNAL bool m0_sm_timeout_is_armed(const struct m0_sm_timeout *to)
 	return m0_sm_timer_is_armed(&to->st_timer);
 }
 
-M0_INTERNAL int m0_sm_conf_trans_extend(struct m0_sm_conf       *base,
-				        const struct m0_sm_conf *sub)
+M0_INTERNAL int m0_sm_conf_trans_extend(const struct m0_sm_conf *base,
+				        struct m0_sm_conf       *sub)
 {
 	struct m0_sm_trans_descr *trans_descr;
 	uint32_t                  trans_nr;
@@ -662,8 +662,13 @@ M0_INTERNAL int m0_sm_conf_trans_extend(struct m0_sm_conf       *base,
 	for (j = 0; i < trans_nr && j < sub->scf_trans_nr; ++i, j++)
 		trans_descr[i] = sub->scf_trans[j];
 
-	base->scf_trans_nr = trans_nr;
-	base->scf_trans    = trans_descr;
+	/*
+	 * Since ->scf_trans statically allocated array, no need to free here.
+	 * This may required when ->scf_trans
+	 * created programatically from conf.
+	 */
+	sub->scf_trans_nr = trans_nr;
+	sub->scf_trans    = trans_descr;
 
 	return 0;
 }
-- 
1.8.3.2

