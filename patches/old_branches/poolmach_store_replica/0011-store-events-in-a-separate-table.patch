From 1ffd1da59dd66356a72d908bea806813118dee37 Mon Sep 17 00:00:00 2001
From: Hua Huang <hua_huang@xyratex.com>
Date: Tue, 7 May 2013 22:46:40 +0800
Subject: [PATCH 11/14] store events in a separate table. add ut to load
 events.

---
 cm/ut/common_service.c |  2 +-
 pool/pool.c            |  2 ++
 pool/pool.h            |  6 +++++-
 pool/pool_store.c      | 45 ++++++++++++++++++++++++++++++++++++---------
 pool/ut/test_pm.c      | 50 ++++++++++++++++++++++++++++++++++++++++----------
 5 files changed, 84 insertions(+), 21 deletions(-)

diff --git a/cm/ut/common_service.c b/cm/ut/common_service.c
index 0313741..3483767 100644
--- a/cm/ut/common_service.c
+++ b/cm/ut/common_service.c
@@ -231,7 +231,7 @@ static const struct m0_reqh_service_type_ops cm_ut_service_type_ops = {
 M0_CM_TYPE_DECLARE(cm_ut, &cm_ut_service_type_ops, "cm_ut",
 		   &m0_addb_ct_ut_service);
 
-struct m0_mero         mero = { .cc_pool_width = 3 };
+struct m0_mero         mero = { .cc_pool_width = 10 };
 struct m0_reqh_context rctx = { .rc_mero = &mero };
 
 void cm_ut_service_alloc_init()
diff --git a/pool/pool.c b/pool/pool.c
index a49a9e1..d6b8e1b 100644
--- a/pool/pool.c
+++ b/pool/pool.c
@@ -346,6 +346,8 @@ M0_INTERNAL void m0_poolmach_fini(struct m0_poolmach *pm)
 	m0_free(pm->pm_state.pst_nodes_array);
 	m0_rwlock_write_unlock(&pm->pm_lock);
 
+	m0_table_fini(&pm->pm_table);
+	m0_table_fini(&pm->pm_events_table);
 	pm->pm_is_initialised = false;
 	m0_rwlock_fini(&pm->pm_lock);
 }
diff --git a/pool/pool.h b/pool/pool.h
index 7fc9d11..afdaab8 100644
--- a/pool/pool.h
+++ b/pool/pool.h
@@ -301,10 +301,14 @@ struct m0_poolmach {
 
 	/**
 	 * the db table to store poolmach state.
-	 * Only valid for Master Pool Machine.
 	 */
 	struct m0_table          pm_table;
 
+	/**
+	 * events stored here.
+	 */
+	struct m0_table          pm_events_table;
+
 	/** the db env */
 	struct m0_dbenv         *pm_dbenv;
 
diff --git a/pool/pool_store.c b/pool/pool_store.c
index e240dbb..64981d7 100644
--- a/pool/pool_store.c
+++ b/pool/pool_store.c
@@ -61,6 +61,18 @@ struct m0_pool_event_rec {
 	struct m0_pool_event           per_event;
 };
 
+static const struct m0_table_ops m0_poolmach_store_events_ops = {
+	.to = {
+		[TO_KEY] = {
+			.max_size = sizeof (struct m0_pool_version_numbers)
+			},
+		[TO_REC] = {
+			.max_size = sizeof (struct m0_pool_event_rec)
+			}
+	},
+	.key_cmp = NULL
+};
+
 static const struct m0_table_ops m0_poolmach_store_ops = {
 	.to = {
 		[TO_KEY] = {
@@ -157,14 +169,18 @@ static int m0_poolmach_events_load(struct m0_poolmach *pm,
 
 	M0_ENTRY();
 
-	rc = m0_db_cursor_init(&cursor, &pm->pm_table, tx, 0);
+	rc = m0_db_cursor_init(&cursor, &pm->pm_events_table, tx, 0);
 	if (rc != 0)
 		M0_RETURN(rc);
 
-	m0_db_pair_setup(&pair, &pm->pm_table, &event_key, sizeof event_key,
+	m0_db_pair_setup(&pair, &pm->pm_events_table, &event_key, sizeof event_key,
 			 &event_rec, sizeof event_rec);
 	rc = m0_db_cursor_get(&cursor, &pair);
-	while (rc == 0) {
+	if (rc == -ENOENT) {
+		rc = 0;
+		goto out;
+	}
+	do {
 		M0_ALLOC_PTR(event_link);
 		if (event_link == NULL) {
 			rc = -ENOMEM;
@@ -176,7 +192,7 @@ static int m0_poolmach_events_load(struct m0_poolmach *pm,
 		poolmach_events_tlink_init_at_tail(event_link,
 					 &pm->pm_state.pst_events_list);
 		rc = m0_db_cursor_next(&cursor, &pair);
-	}
+	} while (rc == 0);
 
 out:
 	m0_db_pair_release(&pair);
@@ -196,7 +212,7 @@ M0_INTERNAL int m0_poolmach_event_store(struct m0_poolmach *pm,
 	event_key = event_link->pel_new_version;
 	event_rec.per_event = event_link->pel_event;
 
-	rc = store_into_db(&pm->pm_table, tx, &event_key,
+	rc = store_into_db(&pm->pm_events_table, tx, &event_key,
 			   &event_rec, sizeof (event_rec));
 	return rc;
 }
@@ -298,7 +314,7 @@ static int m0_poolmach_load(struct m0_poolmach *pm,
 	int                             rc;
 
 	poolnode_rec = m0_alloc(nr_nodes * sizeof (*poolnode_rec));
-	pooldev_rec  = m0_alloc(nr_devices * sizeof (*pooldev_rec));
+	pooldev_rec  = m0_alloc((nr_devices + 1) * sizeof (*pooldev_rec));
 	pool_spare_usage_rec = m0_alloc(max_device_failures *
 					 sizeof (*pool_spare_usage_rec));
 	if (poolnode_rec == NULL ||
@@ -315,7 +331,7 @@ static int m0_poolmach_load(struct m0_poolmach *pm,
 		goto out_free;
 
 	if (poolmach_rec.psr_nr_nodes != nr_nodes ||
-	    poolmach_rec.psr_nr_devices != nr_devices ||
+	    poolmach_rec.psr_nr_devices != nr_devices + 1 ||
 	    poolmach_rec.psr_max_node_failures != max_node_failures ||
 	    poolmach_rec.psr_max_device_failures != max_device_failures) {
 		M0_LOG(M0_ERROR, "Pool Machine persistent state does not match!");
@@ -332,7 +348,7 @@ static int m0_poolmach_load(struct m0_poolmach *pm,
 
 	rc = load_from_db(&pm->pm_table, tx, &poolmach_device_state_key,
 			  pooldev_rec,
-			  nr_devices * sizeof (*pooldev_rec));
+			  (nr_devices + 1) * sizeof (*pooldev_rec));
 	if (rc != 0)
 		goto out_free;
 
@@ -388,9 +404,18 @@ M0_INTERNAL int m0_poolmach_store_init(struct m0_poolmach *pm,
 	if (rc != 0)
 		M0_RETURN(rc);
 
+	rc = m0_table_init(&pm->pm_events_table, dbenv,
+			   "poolmach_events", 0,
+			   &m0_poolmach_store_events_ops);
+	if (rc != 0) {
+		m0_table_fini(&pm->pm_table);
+		M0_RETURN(rc);
+	}
+
 	rc = m0_db_tx_init(&init_tx, dbenv, 0);
 	if (rc != 0) {
 		m0_table_fini(&pm->pm_table);
+		m0_table_fini(&pm->pm_events_table);
 		M0_RETURN(rc);
 	}
 
@@ -404,8 +429,10 @@ M0_INTERNAL int m0_poolmach_store_init(struct m0_poolmach *pm,
 	else
 		m0_db_tx_abort(&init_tx);
 
-	if (rc != 0)
+	if (rc != 0) {
 		m0_table_fini(&pm->pm_table);
+		m0_table_fini(&pm->pm_events_table);
+	}
 	return rc;
 }
 
diff --git a/pool/ut/test_pm.c b/pool/ut/test_pm.c
index ac13ae9..b5a9a07 100644
--- a/pool/ut/test_pm.c
+++ b/pool/ut/test_pm.c
@@ -30,19 +30,23 @@ enum {
 	PM_TEST_DEFAULT_MAX_DEVICE_FAILURE = 1,
 	PM_TEST_DEFAULT_MAX_NODE_FAILURE   = 1
 };
+static struct m0_dbenv           dbenv;
 
 static void pm_test_init_fini(void)
 {
 	struct m0_poolmach pm;
 	int                rc;
 
+	rc = m0_dbenv_init(&dbenv, "pm_testing", 0);
+	M0_ASSERT(rc == 0);
 	M0_SET0(&pm);
-	rc = m0_poolmach_init(&pm, NULL, NULL, PM_TEST_DEFAULT_NODE_NUMBER,
+	rc = m0_poolmach_init(&pm, &dbenv, NULL, PM_TEST_DEFAULT_NODE_NUMBER,
 					 PM_TEST_DEFAULT_DEVICE_NUMBER,
 					 PM_TEST_DEFAULT_MAX_NODE_FAILURE,
 					 PM_TEST_DEFAULT_MAX_DEVICE_FAILURE);
 	M0_UT_ASSERT(rc == 0);
 	m0_poolmach_fini(&pm);
+	m0_dbenv_fini(&dbenv);
 }
 
 static void pm_test_transit(void)
@@ -61,8 +65,10 @@ static void pm_test_transit(void)
 	uint32_t                       count;
 	uint32_t                       index;
 
+	rc = m0_dbenv_init(&dbenv, "pm_test_transit", 0);
+	M0_ASSERT(rc == 0);
 	M0_SET0(&pm);
-	rc = m0_poolmach_init(&pm, NULL, NULL, PM_TEST_DEFAULT_NODE_NUMBER,
+	rc = m0_poolmach_init(&pm, &dbenv, NULL, PM_TEST_DEFAULT_NODE_NUMBER,
 					 PM_TEST_DEFAULT_DEVICE_NUMBER,
 					 PM_TEST_DEFAULT_MAX_NODE_FAILURE,
 					 PM_TEST_DEFAULT_MAX_DEVICE_FAILURE);
@@ -346,6 +352,7 @@ static void pm_test_transit(void)
 
 	/* finally */
 	m0_poolmach_fini(&pm);
+	m0_dbenv_fini(&dbenv);
 }
 
 static void pm_test_spare_slot(void)
@@ -358,8 +365,10 @@ static void pm_test_spare_slot(void)
 	enum m0_pool_nd_state state;
 	uint32_t              spare_slot;
 
+	rc = m0_dbenv_init(&dbenv, "pm_test_spare_slot", 0);
+	M0_ASSERT(rc == 0);
 	M0_SET0(&pm);
-	rc = m0_poolmach_init(&pm, NULL, NULL, PM_TEST_DEFAULT_NODE_NUMBER,
+	rc = m0_poolmach_init(&pm, &dbenv, NULL, PM_TEST_DEFAULT_NODE_NUMBER,
 					 PM_TEST_DEFAULT_DEVICE_NUMBER,
 					 PM_TEST_DEFAULT_MAX_NODE_FAILURE,
 					 2 /* two spare device */);
@@ -508,9 +517,9 @@ static void pm_test_spare_slot(void)
 
 	/* finally */
 	m0_poolmach_fini(&pm);
+	m0_dbenv_fini(&dbenv);
 }
 
-
 static void pm_test_multi_fail(void)
 {
 	struct m0_poolmach    pm;
@@ -520,8 +529,10 @@ static void pm_test_multi_fail(void)
 	enum m0_pool_nd_state target_state;
 	uint32_t              spare_slot;
 
+	rc = m0_dbenv_init(&dbenv, "pm_test_multi_fail", 0);
+	M0_ASSERT(rc == 0);
 	M0_SET0(&pm);
-	rc = m0_poolmach_init(&pm, NULL, NULL, PM_TEST_DEFAULT_NODE_NUMBER,
+	rc = m0_poolmach_init(&pm, &dbenv, NULL, PM_TEST_DEFAULT_NODE_NUMBER,
 					 PM_TEST_DEFAULT_DEVICE_NUMBER,
 					 PM_TEST_DEFAULT_MAX_NODE_FAILURE,
 					 3 /*three spare device */);
@@ -690,19 +701,38 @@ static void pm_test_multi_fail(void)
 
 	/* finally */
 	m0_poolmach_fini(&pm);
+	m0_dbenv_fini(&dbenv);
 }
 
+/* load from last test case */
+static void pm_test_load_from_persistent_storage(void)
+{
+	struct m0_poolmach pm;
+	int                rc;
+
+	rc = m0_dbenv_init(&dbenv, "pm_test_multi_fail", 0);
+	M0_ASSERT(rc == 0);
+	M0_SET0(&pm);
+	rc = m0_poolmach_init(&pm, &dbenv, NULL, PM_TEST_DEFAULT_NODE_NUMBER,
+					 PM_TEST_DEFAULT_DEVICE_NUMBER,
+					 PM_TEST_DEFAULT_MAX_NODE_FAILURE,
+					 3);
+	M0_UT_ASSERT(rc == 0);
+	m0_poolmach_fini(&pm);
+	m0_dbenv_fini(&dbenv);
+}
 
 const struct m0_test_suite poolmach_ut = {
 	.ts_name = "poolmach-ut",
 	.ts_init = NULL,
 	.ts_fini = NULL,
 	.ts_tests = {
-		{ "pm_test init & fini",   pm_test_init_fini },
-		{ "pm_test state transit", pm_test_transit   },
-		{ "pm_test spare slot",    pm_test_spare_slot},
-		{ "pm_test multi fail",    pm_test_multi_fail},
-		{ NULL,                    NULL              }
+		{ "pm_test init & fini",   pm_test_init_fini                  },
+		{ "pm_test state transit", pm_test_transit                    },
+		{ "pm_test spare slot",    pm_test_spare_slot                 },
+		{ "pm_test multi fail",    pm_test_multi_fail                 },
+		{ "pm_test load",         pm_test_load_from_persistent_storage},
+		{ NULL,                    NULL                               }
 	}
 };
 M0_EXPORTED(poolmach_ut);
-- 
1.8.3.2

