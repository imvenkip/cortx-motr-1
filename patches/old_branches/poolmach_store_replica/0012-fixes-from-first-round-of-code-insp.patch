From 928632bdd02fc10bd2a415a8434f082d07c3ee6a Mon Sep 17 00:00:00 2001
From: Hua Huang <hua_huang@xyratex.com>
Date: Wed, 8 May 2013 17:25:30 +0800
Subject: [PATCH 12/14] fixes from first round of code insp. use uint64_t as
 key for pool machine state, device state, etc.

---
 m0t1fs/linux_kernel/super.c |   8 +++-
 pool/pool.c                 |  18 ++++---
 pool/pool.h                 |   7 +--
 pool/pool_store.c           | 112 +++++++++++++++++++++++---------------------
 4 files changed, 76 insertions(+), 69 deletions(-)

diff --git a/m0t1fs/linux_kernel/super.c b/m0t1fs/linux_kernel/super.c
index 0070280..4070e13 100644
--- a/m0t1fs/linux_kernel/super.c
+++ b/m0t1fs/linux_kernel/super.c
@@ -659,12 +659,18 @@ static int m0t1fs_poolmach_create(struct m0_poolmach **out, uint32_t pool_width,
 {
 	struct m0_poolmach *m;
 	int                 rc;
+	enum {
+		/* @todo this should be retrieved from confc */
+		NR_NODES          = 1,
+		MAX_NODE_FAILURES = 1
+	};
 
 	M0_ALLOC_PTR(m);
 	if (m == NULL)
 		return -ENOMEM;
 
-	rc = m0_poolmach_init(m, NULL, NULL, 1, pool_width, 1, nr_parity_units);
+	rc = m0_poolmach_init(m, NULL, NULL, NR_NODES, pool_width,
+			      MAX_NODE_FAILURES, nr_parity_units);
 	if (rc == 0)
 		*out = m;
 	else
diff --git a/pool/pool.c b/pool/pool.c
index d6b8e1b..e1d3dfd 100644
--- a/pool/pool.c
+++ b/pool/pool.c
@@ -275,14 +275,11 @@ M0_INTERNAL int m0_poolmach_init(struct m0_poolmach *pm,
 	pm->pm_state.pst_max_node_failures = max_node_failures;
 	pm->pm_state.pst_max_device_failures = max_device_failures;
 
-	pm->pm_state.pst_nodes_array = m0_alloc(pm->pm_state.pst_nr_nodes *
-						sizeof (struct m0_poolnode));
-	pm->pm_state.pst_devices_array = m0_alloc(pm->pm_state.pst_nr_devices *
-						  sizeof (struct m0_pooldev));
-
-	pm->pm_state.pst_spare_usage_array
-			= m0_alloc(pm->pm_state.pst_max_device_failures *
-				   sizeof (struct m0_pool_spare_usage));
+	M0_ALLOC_ARR(pm->pm_state.pst_nodes_array, pm->pm_state.pst_nr_nodes);
+	M0_ALLOC_ARR(pm->pm_state.pst_devices_array,
+		     pm->pm_state.pst_nr_devices);
+	M0_ALLOC_ARR(pm->pm_state.pst_spare_usage_array,
+		     pm->pm_state.pst_max_device_failures);
 	if (pm->pm_state.pst_nodes_array == NULL ||
 	    pm->pm_state.pst_devices_array == NULL ||
 	    pm->pm_state.pst_spare_usage_array == NULL) {
@@ -452,7 +449,7 @@ M0_INTERNAL int m0_poolmach_state_transit(struct m0_poolmach *pm,
 	m0_rwlock_write_lock(&pm->pm_lock);
 
 	/* step 2: Update the state according to event */
-	event_link = m0_alloc(sizeof *event_link);
+	M0_ALLOC_PTR(event_link);
 	if (event_link == NULL) {
 		rc = -ENOMEM;
 		goto out_unlock;
@@ -533,6 +530,7 @@ M0_INTERNAL int m0_poolmach_state_transit(struct m0_poolmach *pm,
 	}
 
 	if (pm->pm_dbenv != NULL) {
+		/* This poolmach is on server. Update to persistent storage. */
 		rc = m0_db_tx_init(&local_tx, pm->pm_dbenv, 0);
 		if (rc == 0) {
 			rc = m0_poolmach_store(pm, &local_tx);
@@ -586,7 +584,7 @@ M0_INTERNAL int m0_poolmach_state_query(struct m0_poolmach *pm,
 		/* allocate a copy of the event and event link,
 		 * add it to output list.
 		 */
-		event_link = m0_alloc(sizeof *event_link);
+		M0_ALLOC_PTR(event_link);
 		if (event_link == NULL) {
 			struct m0_pool_event_link *tmp;
 			rc = -ENOMEM;
diff --git a/pool/pool.h b/pool/pool.h
index afdaab8..551a5fd 100644
--- a/pool/pool.h
+++ b/pool/pool.h
@@ -38,7 +38,6 @@
 struct m0_stob_id;
 struct m0_dtm;
 struct m0_io_req;
-struct m0_dbenv;
 struct m0_dtx;
 
 /* export */
@@ -309,7 +308,7 @@ struct m0_poolmach {
 	 */
 	struct m0_table          pm_events_table;
 
-	/** the db env */
+	/** the dbenv. if this is NULL, the poolmach is on client. */
 	struct m0_dbenv         *pm_dbenv;
 
 	/** this pool machine initialized or not */
@@ -335,9 +334,7 @@ M0_INTERNAL bool m0_poolmach_version_before(const struct m0_pool_version_numbers
  * Initialises the pool machine.
  *
  * Pool machine will load its data from persistent storage. If this is the first
- * call, it will initialise the persistent data. For a pool machine replica or
- * a pool machine on client, it only caches data. So, it will not load data from
- * persistent storage. It will update its data from master pool machine.
+ * call, it will initialise the persistent data.
  */
 M0_INTERNAL int m0_poolmach_init(struct m0_poolmach *pm,
 				 struct m0_dbenv *dbenv,
diff --git a/pool/pool_store.c b/pool/pool_store.c
index 64981d7..722c149 100644
--- a/pool/pool_store.c
+++ b/pool/pool_store.c
@@ -61,7 +61,7 @@ struct m0_pool_event_rec {
 	struct m0_pool_event           per_event;
 };
 
-static const struct m0_table_ops m0_poolmach_store_events_ops = {
+static const struct m0_table_ops m0_poolmach_events_table_ops = {
 	.to = {
 		[TO_KEY] = {
 			.max_size = sizeof (struct m0_pool_version_numbers)
@@ -76,7 +76,7 @@ static const struct m0_table_ops m0_poolmach_store_events_ops = {
 static const struct m0_table_ops m0_poolmach_store_ops = {
 	.to = {
 		[TO_KEY] = {
-			.max_size = sizeof (struct m0_pool_version_numbers)
+			.max_size = sizeof (uint64_t)
 			},
 		[TO_REC] = {
 			.max_size = ~0
@@ -85,46 +85,30 @@ static const struct m0_table_ops m0_poolmach_store_ops = {
 	.key_cmp = NULL
 };
 
-static struct m0_pool_version_numbers poolmach_state_key = {
-	.pvn_version = {
-		[PVE_READ]  = ~0ULL - 1,
-		[PVE_WRITE] = ~0ULL - 1
-	}
-};
+/** key for poolmach state */
+static uint64_t poolmach_state_key = 1ULL;
 
+/** key for device state array record */
+static uint64_t poolmach_device_state_key = 2ULL;
 
-static struct m0_pool_version_numbers poolmach_device_state_key = {
-	.pvn_version = {
-		[PVE_READ]  = ~0ULL - 2,
-		[PVE_WRITE] = ~0ULL - 2
-	}
-};
-
-static struct m0_pool_version_numbers poolmach_node_state_key = {
-	.pvn_version = {
-		[PVE_READ]  = ~0ULL - 3,
-		[PVE_WRITE] = ~0ULL - 3
-	}
-};
+/** key for node state array record */
+static uint64_t poolmach_node_state_key = 3ULL;
 
-static struct m0_pool_version_numbers poolmach_spare_key = {
-	.pvn_version = {
-		[PVE_READ]  = ~0ULL - 4,
-		[PVE_WRITE] = ~0ULL - 4
-	}
-};
+/** key for spare space slot array record */
+static uint64_t poolmach_spare_key = 4ULL;
 
-static int load_from_db(struct m0_table                *table,
-			struct m0_db_tx                *tx,
-			struct m0_pool_version_numbers *key,
-			void                           *rec,
-			int                             size_of_rec)
+static int load_from_db(struct m0_table *table,
+			struct m0_db_tx *tx,
+			void            *key,
+			int             size_of_key,
+			void            *rec,
+			int             size_of_rec)
 {
 	struct m0_db_pair pair;
 	int               rc;
 
 	m0_db_pair_setup(&pair, table,
-			 key, sizeof *key,
+			 key, size_of_key,
 			 rec, size_of_rec);
 
 	rc = m0_table_lookup(tx, &pair);
@@ -133,17 +117,18 @@ static int load_from_db(struct m0_table                *table,
 	return rc;
 }
 
-static int store_into_db(struct m0_table                *table,
-			 struct m0_db_tx                *tx,
-			 struct m0_pool_version_numbers *key,
-			 void                           *rec,
-			 int                             size_of_rec)
+static int store_into_db(struct m0_table *table,
+			 struct m0_db_tx *tx,
+			 void            *key,
+			 int              size_of_key,
+			 void            *rec,
+			 int              size_of_rec)
 {
 	struct m0_db_pair pair;
 	int               rc;
 
 	m0_db_pair_setup(&pair, table,
-			 key, sizeof *key,
+			 key, size_of_key,
 			 rec, size_of_rec);
 
 	rc = m0_table_update(tx, &pair);
@@ -212,11 +197,18 @@ M0_INTERNAL int m0_poolmach_event_store(struct m0_poolmach *pm,
 	event_key = event_link->pel_new_version;
 	event_rec.per_event = event_link->pel_event;
 
-	rc = store_into_db(&pm->pm_events_table, tx, &event_key,
+	rc = store_into_db(&pm->pm_events_table, tx,
+			   &event_key, sizeof (event_key),
 			   &event_rec, sizeof (event_rec));
 	return rc;
 }
 
+
+/**
+ * Store all pool machine state into db.
+ *
+ * Existing records are overwritten.
+ */
 M0_INTERNAL int m0_poolmach_store(struct m0_poolmach *pm,
 				  struct m0_db_tx    *tx)
 {
@@ -252,7 +244,8 @@ M0_INTERNAL int m0_poolmach_store(struct m0_poolmach *pm,
 	poolmach_rec.psr_nr_devices = nr_devices;
 	poolmach_rec.psr_max_node_failures = max_node_failures;
 	poolmach_rec.psr_max_device_failures = max_device_failures;
-	rc = store_into_db(&pm->pm_table, tx, &poolmach_state_key,
+	rc = store_into_db(&pm->pm_table, tx,
+			   &poolmach_state_key, sizeof poolmach_state_key,
 			   &poolmach_rec, sizeof poolmach_rec);
 	if (rc != 0)
 		goto out_free;
@@ -260,9 +253,11 @@ M0_INTERNAL int m0_poolmach_store(struct m0_poolmach *pm,
 	for (i = 0; i < nr_nodes; i++) {
 		poolnode_rec[i].pn_state =
 				pm->pm_state.pst_nodes_array[i].pn_state;
-		/* poolnode_rec[i].pn_node_id = uuid */
+		/* @todo retrieve uuid: poolnode_rec[i].pn_node_id = uuid */
 	}
-	rc = store_into_db(&pm->pm_table, tx, &poolmach_node_state_key,
+	rc = store_into_db(&pm->pm_table, tx,
+			   &poolmach_node_state_key,
+			   sizeof poolmach_node_state_key,
 			   poolnode_rec,
 			   nr_nodes * sizeof (*poolnode_rec));
 	if (rc != 0)
@@ -272,10 +267,12 @@ M0_INTERNAL int m0_poolmach_store(struct m0_poolmach *pm,
 	for (i = 0; i < nr_devices; i++) {
 		pooldev_rec[i].pd_state =
 				pm->pm_state.pst_devices_array[i].pd_state;
-		/* pooldev_rec[i].pd_node_id = uuid */
-		/* pooldev_rec[i].pd_dev_id = uuid */
+		/* @todo pooldev_rec[i].pd_node_id = uuid */
+		/* @todo pooldev_rec[i].pd_dev_id = uuid */
 	}
-	rc = store_into_db(&pm->pm_table, tx, &poolmach_device_state_key,
+	rc = store_into_db(&pm->pm_table, tx,
+			   &poolmach_device_state_key,
+			   sizeof poolmach_device_state_key,
 			   pooldev_rec,
 			   nr_devices * sizeof (*pooldev_rec));
 	if (rc != 0)
@@ -287,7 +284,9 @@ M0_INTERNAL int m0_poolmach_store(struct m0_poolmach *pm,
 		pool_spare_usage_rec[i].psu_device_state =
 			pm->pm_state.pst_spare_usage_array[i].psu_device_state;
 	}
-	rc = store_into_db(&pm->pm_table, tx, &poolmach_spare_key,
+	rc = store_into_db(&pm->pm_table, tx,
+			   &poolmach_spare_key,
+			   sizeof poolmach_spare_key,
 			   pool_spare_usage_rec,
 			   max_device_failures * sizeof (*pool_spare_usage_rec));
 
@@ -325,7 +324,8 @@ static int m0_poolmach_load(struct m0_poolmach *pm,
 		goto out_free;
 	}
 
-	rc = load_from_db(&pm->pm_table, tx, &poolmach_state_key,
+	rc = load_from_db(&pm->pm_table, tx,
+			  &poolmach_state_key, sizeof poolmach_state_key,
 			  &poolmach_rec, sizeof poolmach_rec);
 	if (rc != 0)
 		goto out_free;
@@ -334,25 +334,31 @@ static int m0_poolmach_load(struct m0_poolmach *pm,
 	    poolmach_rec.psr_nr_devices != nr_devices + 1 ||
 	    poolmach_rec.psr_max_node_failures != max_node_failures ||
 	    poolmach_rec.psr_max_device_failures != max_device_failures) {
-		M0_LOG(M0_ERROR, "Pool Machine persistent state does not match!");
+		M0_LOG(M0_ERROR, "Pool Machine persistent state doesn't match");
 		rc = -ESTALE;
 		goto out_free;
 	}
 	pm->pm_state.pst_version = poolmach_rec.psr_version;
 
-	rc = load_from_db(&pm->pm_table, tx, &poolmach_node_state_key,
+	rc = load_from_db(&pm->pm_table, tx,
+			  &poolmach_node_state_key,
+			  sizeof poolmach_node_state_key,
 			  poolnode_rec,
 			  nr_nodes * sizeof (*poolnode_rec));
 	if (rc != 0)
 		goto out_free;
 
-	rc = load_from_db(&pm->pm_table, tx, &poolmach_device_state_key,
+	rc = load_from_db(&pm->pm_table, tx,
+			  &poolmach_device_state_key,
+			  sizeof poolmach_device_state_key,
 			  pooldev_rec,
 			  (nr_devices + 1) * sizeof (*pooldev_rec));
 	if (rc != 0)
 		goto out_free;
 
-	rc = load_from_db(&pm->pm_table, tx, &poolmach_spare_key,
+	rc = load_from_db(&pm->pm_table, tx,
+			  &poolmach_spare_key,
+			  sizeof poolmach_spare_key,
 			  pool_spare_usage_rec,
 			  max_device_failures * sizeof (*pool_spare_usage_rec));
 	if (rc != 0)
@@ -406,7 +412,7 @@ M0_INTERNAL int m0_poolmach_store_init(struct m0_poolmach *pm,
 
 	rc = m0_table_init(&pm->pm_events_table, dbenv,
 			   "poolmach_events", 0,
-			   &m0_poolmach_store_events_ops);
+			   &m0_poolmach_events_table_ops);
 	if (rc != 0) {
 		m0_table_fini(&pm->pm_table);
 		M0_RETURN(rc);
-- 
1.8.3.2

