From 4f6532cf281243f65c99070fef951bb94ab9cde2 Mon Sep 17 00:00:00 2001
From: Hua Huang <hua_huang@xyratex.com>
Date: Wed, 1 May 2013 18:51:20 +0800
Subject: [PATCH 04/14] more for storing and loading events

---
 pool/pool.c       |  52 +++++++++++++++++++++-------
 pool/pool.h       |   6 +++-
 pool/pool_store.c | 100 +++++++++++++++++++++++++++++++++++++++++++-----------
 3 files changed, 124 insertions(+), 34 deletions(-)

diff --git a/pool/pool.c b/pool/pool.c
index a2cfdc4..60b6874 100644
--- a/pool/pool.c
+++ b/pool/pool.c
@@ -194,6 +194,20 @@
    @{
  */
 
+/* Import following interfaces which are defined in pool/pool_store.c */
+M0_INTERNAL int m0_poolmach_store_init(struct m0_poolmach *pm,
+				       struct m0_dbenv    *dbenv,
+				       struct m0_dtm      *dtm,
+				       uint32_t            nr_nodes,
+				       uint32_t            nr_devices,
+				       uint32_t            max_node_failures,
+				       uint32_t            max_device_failures);
+M0_INTERNAL int m0_poolmach_store(struct m0_poolmach *pm,
+				  struct m0_db_tx    *tx);
+M0_INTERNAL int m0_poolmach_event_store(struct m0_poolmach *pm,
+					struct m0_db_tx    *tx,
+					struct m0_pool_event_link *event_link);
+
 M0_TL_DESCR_DEFINE(poolmach_events, "pool machine events list", M0_INTERNAL,
                    struct m0_pool_event_link, pel_linkage, pel_magic,
                    M0_POOL_EVENTS_LIST_MAGIC, M0_POOL_EVENTS_HEAD_MAGIC);
@@ -205,7 +219,6 @@ enum {
 	POOL_PM_SPARE_SLOT_UNUSED = 0xFFFFFFFF
 };
 
-
 M0_INTERNAL int m0_pool_init(struct m0_pool *pool, uint32_t width)
 {
 	pool->po_width = width;
@@ -267,15 +280,11 @@ M0_INTERNAL int m0_poolmach_init(struct m0_poolmach *pm,
 				 uint32_t max_device_failures)
 {
 	uint32_t i;
+	int      rc;
 	M0_PRE(!pm->pm_is_initialised);
 
-	/* TODO Init pool machine, build its state from persistent storage
-	 * This involves to read latest pool machine state from storage,
-	 * and build its state transit history (represented by list of events).
-	 *
-	 * XXX temoprarily, we build this from scratch.
-	 */
-	M0_SET0(&pm->pm_state);
+	M0_SET0(pm);
+	pm->pm_dbenv = dbenv;
 	pm->pm_state.pst_version.pvn_version[PVE_READ]  = 0;
 	pm->pm_state.pst_version.pvn_version[PVE_WRITE] = 0;
 	pm->pm_state.pst_nr_nodes = nr_nodes;
@@ -283,6 +292,7 @@ M0_INTERNAL int m0_poolmach_init(struct m0_poolmach *pm,
 	pm->pm_state.pst_nr_devices = nr_devices + 1;
 	pm->pm_state.pst_max_node_failures = max_node_failures;
 	pm->pm_state.pst_max_device_failures = max_device_failures;
+
 	pm->pm_state.pst_nodes_array = m0_alloc(pm->pm_state.pst_nr_nodes *
 						sizeof (struct m0_poolnode));
 	pm->pm_state.pst_devices_array = m0_alloc(pm->pm_state.pst_nr_devices *
@@ -319,12 +329,15 @@ M0_INTERNAL int m0_poolmach_init(struct m0_poolmach *pm,
 		pm->pm_state.pst_spare_usage_array[i].psu_device_index =
 						POOL_PM_SPARE_SLOT_UNUSED;
 	}
-
 	poolmach_events_tlist_init(&pm->pm_state.pst_events_list);
-
 	m0_rwlock_init(&pm->pm_lock);
-	pm->pm_is_initialised = true;
-	return 0;
+	rc = m0_poolmach_store_init(pm, dbenv, dtm, nr_nodes, nr_devices,
+				    max_node_failures, max_device_failures);
+	if (rc == 0)
+		pm->pm_is_initialised = true;
+	else
+		m0_poolmach_fini(pm);
+	return rc;
 }
 
 M0_INTERNAL void m0_poolmach_fini(struct m0_poolmach *pm)
@@ -379,6 +392,7 @@ M0_INTERNAL int m0_poolmach_state_transit(struct m0_poolmach *pm,
 	struct m0_pool_event_link  *event_link;
 	enum m0_pool_nd_state       old_state = M0_PNDS_FAILED;
 	int                         rc = 0;
+	struct m0_db_tx             local_tx;
 	int                         i;
 
 	M0_PRE(pm != NULL);
@@ -530,7 +544,19 @@ M0_INTERNAL int m0_poolmach_state_transit(struct m0_poolmach *pm,
 		;
 	}
 
-
+	if (pm->pm_flags & M0_POOLMACH_FLAG_MASTER) {
+		rc = m0_db_tx_init(&local_tx, pm->pm_dbenv, 0);
+		if (rc == 0) {
+			rc = m0_poolmach_store(pm, &local_tx);
+			if (rc == 0)
+				rc = m0_poolmach_event_store(pm, &local_tx,
+							     event_link);
+			if (rc == 0)
+				rc = m0_db_tx_commit(&local_tx);
+			else
+				m0_db_tx_abort(&local_tx);
+		}
+	}
 
 out_unlock:
 	/* Finally: unlock the poolmach */
diff --git a/pool/pool.h b/pool/pool.h
index 20dd7e4..3a2fec0 100644
--- a/pool/pool.h
+++ b/pool/pool.h
@@ -303,11 +303,15 @@ struct m0_poolmach {
 	/** struct m0_persistent_sm  pm_mach; */
 	struct m0_poolmach_state pm_state;
 
-	/** the db table to store poolmach state.
+	/**
+	 * the db table to store poolmach state.
 	 * Only valid for Master Pool Machine.
 	 */
 	struct m0_table          pm_table;
 
+	/** the db env */
+	struct m0_dbenv         *pm_dbenv;
+
 	/**
 	 * flag bits. See enum m0_poolmach_flags.
 	 */
diff --git a/pool/pool_store.c b/pool/pool_store.c
index 30d75f8..90b276c 100644
--- a/pool/pool_store.c
+++ b/pool/pool_store.c
@@ -58,8 +58,7 @@ struct m0_poolmach_state_rec {
 };
 
 struct m0_pool_event_rec {
-	struct m0_pool_version_numbers pel_version;
-	struct m0_pool_event           pel_event;
+	struct m0_pool_event           per_event;
 };
 
 static const struct m0_table_ops m0_poolmach_store_ops = {
@@ -135,21 +134,80 @@ static int store_into_db(struct m0_table                *table,
 			 key, sizeof *key,
 			 rec, size_of_rec);
 
-	rc = m0_table_insert(tx, &pair);
+	rc = m0_table_update(tx, &pair);
 	m0_db_pair_release(&pair);
 	m0_db_pair_fini(&pair);
 	return rc;
 }
 
+static int m0_poolmach_events_load(struct m0_poolmach *pm,
+			           struct m0_db_tx    *tx)
+{
+	struct m0_db_pair              pair;
+	struct m0_pool_version_numbers event_key = {
+					.pvn_version = {
+						[PVE_READ]  = 0ULL,
+						[PVE_WRITE] = 0ULL
+					}
+				       };
+	struct m0_pool_event_rec       event_rec;
+	struct m0_db_cursor            cursor;
+	struct m0_pool_event_link      *event_link;
+	int                            rc;
+
+	M0_ENTRY();
+
+	rc = m0_db_cursor_init(&cursor, &pm->pm_table, tx, 0);
+	if (rc != 0)
+		M0_RETURN(rc);
+
+	m0_db_pair_setup(&pair, &pm->pm_table, &event_key, sizeof event_key,
+			 &event_rec, sizeof event_rec);
+	rc = m0_db_cursor_get(&cursor, &pair);
+	while (rc == 0) {
+		M0_ALLOC_PTR(event_link);
+		if (event_link == NULL) {
+			rc = -ENOMEM;
+			goto out;
+		}
+
+		event_link->pel_event = event_rec.per_event;
+		event_link->pel_new_version = event_key;
+		poolmach_events_tlink_init_at_tail(event_link,
+					 &pm->pm_state.pst_events_list);
+		rc = m0_db_cursor_next(&cursor, &pair);
+	}
 
-static int m0_poolmach_store(struct m0_poolmach *pm,
-			     struct m0_dbenv    *dbenv,
-			     struct m0_db_tx    *tx,
-			     uint32_t            nr_nodes,
-			     uint32_t            nr_devices,
-			     uint32_t            max_node_failures,
-			     uint32_t            max_device_failures)
+out:
+	m0_db_pair_release(&pair);
+	m0_db_pair_fini(&pair);
+	m0_db_cursor_fini(&cursor);
+	M0_RETURN(rc);
+}
+
+M0_INTERNAL int m0_poolmach_event_store(struct m0_poolmach *pm,
+					struct m0_db_tx    *tx,
+					struct m0_pool_event_link *event_link)
 {
+	struct m0_pool_version_numbers event_key;
+	struct m0_pool_event_rec       event_rec;
+	int                            rc;
+
+	event_key = event_link->pel_new_version;
+	event_rec.per_event = event_link->pel_event;
+
+	rc = store_into_db(&pm->pm_table, tx, &event_key,
+			   &event_rec, sizeof (event_rec));
+	return rc;
+}
+
+M0_INTERNAL int m0_poolmach_store(struct m0_poolmach *pm,
+				  struct m0_db_tx    *tx)
+{
+	uint32_t                        nr_nodes;
+	uint32_t                        nr_devices;
+	uint32_t                        max_node_failures;
+	uint32_t                        max_device_failures;
 	struct m0_poolmach_state_rec    poolmach_rec;
 	struct m0_poolnode_rec         *poolnode_rec;
 	struct m0_pooldev_rec          *pooldev_rec;
@@ -157,9 +215,13 @@ static int m0_poolmach_store(struct m0_poolmach *pm,
 	uint32_t                        i;
 	int                             rc;
 
-        poolnode_rec = m0_alloc(nr_nodes * sizeof (*poolnode_rec));
-        pooldev_rec  = m0_alloc(nr_devices * sizeof (*pooldev_rec));
-        pool_spare_usage_rec = m0_alloc(max_device_failures *
+	nr_nodes = pm->pm_state.pst_nr_nodes;
+	nr_devices = pm->pm_state.pst_nr_devices;
+	max_node_failures = pm->pm_state.pst_max_node_failures;
+	max_device_failures = pm->pm_state.pst_max_device_failures;
+	poolnode_rec = m0_alloc(nr_nodes * sizeof (*poolnode_rec));
+	pooldev_rec  = m0_alloc(nr_devices * sizeof (*pooldev_rec));
+	pool_spare_usage_rec = m0_alloc(max_device_failures *
 					 sizeof (*pool_spare_usage_rec));
 	if (poolnode_rec == NULL || pooldev_rec == NULL ||
 	    pool_spare_usage_rec == NULL) {
@@ -233,9 +295,9 @@ static int m0_poolmach_load(struct m0_poolmach *pm,
 	uint32_t                        i;
 	int                             rc;
 
-        poolnode_rec = m0_alloc(nr_nodes * sizeof (*poolnode_rec));
-        pooldev_rec  = m0_alloc(nr_devices * sizeof (*pooldev_rec));
-        pool_spare_usage_rec = m0_alloc(max_device_failures *
+	poolnode_rec = m0_alloc(nr_nodes * sizeof (*poolnode_rec));
+	pooldev_rec  = m0_alloc(nr_devices * sizeof (*pooldev_rec));
+	pool_spare_usage_rec = m0_alloc(max_device_failures *
 					 sizeof (*pool_spare_usage_rec));
 	if (poolnode_rec == NULL || pooldev_rec == NULL ||
 	    pool_spare_usage_rec == NULL) {
@@ -294,6 +356,7 @@ static int m0_poolmach_load(struct m0_poolmach *pm,
 				pool_spare_usage_rec[i].psu_device_state;
 	}
 
+	rc = m0_poolmach_events_load(pm, tx);
 out_free:
 	m0_free(poolnode_rec);
 	m0_free(pooldev_rec);
@@ -316,8 +379,6 @@ M0_INTERNAL int m0_poolmach_store_init(struct m0_poolmach *pm,
 	M0_PRE((dbenv == NULL) == (dtm == NULL));
 	M0_ENTRY();
 
-	M0_SET0(pm);
-
 	if (dbenv == NULL) {
 		pm->pm_flags &= ~M0_POOLMACH_FLAG_MASTER;
 		M0_RETURN(0);
@@ -339,8 +400,7 @@ M0_INTERNAL int m0_poolmach_store_init(struct m0_poolmach *pm,
 	rc = m0_poolmach_load(pm, dbenv, &init_tx, nr_nodes, nr_devices,
 			      max_node_failures, max_device_failures);
 	if (rc == -ENOENT) {
-		rc = m0_poolmach_store(pm, dbenv, &init_tx, nr_nodes, nr_devices,
-				       max_node_failures, max_device_failures);
+		rc = m0_poolmach_store(pm, &init_tx);
 	}
 	if (rc == 0)
 		rc = m0_db_tx_commit(&init_tx);
-- 
1.8.3.2

