From 1ec1dd086db967562e6c85dfa18ccff1dec90c99 Mon Sep 17 00:00:00 2001
From: Mandar Sawant <mandar_sawant@xyratex.com>
Date: Fri, 8 Nov 2013 18:57:29 +0530
Subject: [PATCH 1/3] SNS iter store integration, - Introduced new local
 sliding window update FOM to handle various blocking points   asynchronously.
 - Refactoring of iterator code a bit, decouple copy packet setup and
 aggregation   group allocation. Move aggregation group allocation to
 ITPH_GROUP_NEXT phase.

---
 cm/Makefile.sub            |   3 +-
 cm/ag.c                    |  14 ++-
 cm/cm.c                    |  63 ++++++++++---
 cm/cm.h                    |  10 +-
 cm/pump.c                  |   2 +-
 cm/sw.c                    |  67 ++------------
 cm/sw.h                    |  12 +++
 cm/ut/cm.c                 |  14 ++-
 cm/ut/common_service.c     |   5 +-
 sns/cm/cm.c                |  13 ---
 sns/cm/cm.h                |  18 +---
 sns/cm/iter.c              | 221 +++++++++++++++++++++++++--------------------
 sns/cm/rebalance/cm.c      |   1 -
 sns/cm/rebalance/helpers.c |  32 ++++---
 sns/cm/repair/cm.c         |   1 -
 sns/cm/repair/helpers.c    |   4 +-
 sns/cm/repair/ut/net.c     |   4 +-
 sns/cm/sw_onwire_fom.c     |   2 +-
 sns/cm/trigger_fom.c       |  35 +++++--
 19 files changed, 286 insertions(+), 235 deletions(-)

diff --git a/cm/Makefile.sub b/cm/Makefile.sub
index 02b3942..93a4f8a 100644
--- a/cm/Makefile.sub
+++ b/cm/Makefile.sub
@@ -16,7 +16,8 @@ mero_libmero_la_SOURCES += cm/ag.c \
                            cm/cp.c \
                            cm/cp_onwire_xc.c \
                            cm/pump.c \
-                           cm/proxy.c
+                           cm/proxy.c \
+                           cm/sw_update_fom.c
 
 
 XC_FILES += cm/ag_xc.h cm/cp_onwire_xc.h cm/sw_xc.h
diff --git a/cm/ag.c b/cm/ag.c
index 3d585e0..6ffa0e8 100644
--- a/cm/ag.c
+++ b/cm/ag.c
@@ -155,6 +155,7 @@ M0_INTERNAL void m0_cm_aggr_group_fini_and_progress(struct m0_cm_aggr_group *ag)
 	struct m0_cm_ag_id        id;
 	struct m0_cm_aggr_group  *hi;
 	struct m0_cm_aggr_group  *lo;
+	//struct m0_cm_sw           sw;
 	bool                      has_data;
 
 	M0_ENTRY("ag: %p", ag);
@@ -177,12 +178,17 @@ M0_INTERNAL void m0_cm_aggr_group_fini_and_progress(struct m0_cm_aggr_group *ag)
 		       hi->cag_id.ai_hi.u_hi, hi->cag_id.ai_hi.u_lo,
 		       hi->cag_id.ai_lo.u_hi, hi->cag_id.ai_lo.u_lo);
 	}
-	m0_cm_sw_local_update(cm);
+	m0_cm_sw_update_continue(cm);
 	m0_cm_aggr_group_fini(ag);
+	//M0_SET0(&sw);
+	//hi = m0_cm_ag_hi(cm);
+	//lo = m0_cm_ag_lo(cm);
+	//m0_cm_sw_set(&sw, &lo->cag_id, &hi->cag_id);
+	//m0_cm_sw_store_update(cm, &sw);
 	has_data = m0_cm_has_more_data(cm);
 	if (!has_data && cm->cm_aggr_grps_in_nr == 0 &&
 	    cm->cm_aggr_grps_out_nr == 0)
-		cm->cm_ops->cmo_complete(cm);
+		m0_cm_complete(cm);
 
 	M0_LOG(M0_DEBUG, "in: [%lu] %p out: [%lu] %p",
 	       cm->cm_aggr_grps_in_nr, &cm->cm_aggr_grps_in,
@@ -366,8 +372,8 @@ M0_INTERNAL int m0_cm_ag_advance(struct m0_cm *cm)
 		}
 	} while (rc == 0);
 
-	if (rc == -ENOSPC || rc == -ENOENT)
-		rc = 0;
+	//if (rc == -ENOSPC || rc == -ENOENT)
+	//	rc = 0;
 
 	return rc;
 }
diff --git a/cm/cm.c b/cm/cm.c
index a00dea2..3cf20b1 100644
--- a/cm/cm.c
+++ b/cm/cm.c
@@ -51,6 +51,7 @@
 #include "cm/ag.h"
 #include "cm/cp.h"
 #include "cm/proxy.h"
+#include "cm/sw.h"
 #include "cm/sw_xc.h"
 #include "cm/cp_onwire_xc.h"
 #include "cm/ag_xc.h"
@@ -622,6 +623,11 @@ M0_INTERNAL int m0_cm_setup(struct m0_cm *cm)
 	rc = cm->cm_ops->cmo_setup(cm);
 	if (M0_FI_ENABLED("setup_failure_2"))
 		rc = -EINVAL;
+	if (rc == 0) {
+		m0_mutex_init(&cm->cm_wait_mutex);
+		m0_chan_init(&cm->cm_ready_wait, &cm->cm_wait_mutex);
+		m0_chan_init(&cm->cm_complete_wait, &cm->cm_wait_mutex);
+	}
 	cm_move(cm, rc, M0_CMS_IDLE, M0_CM_ERR_SETUP);
 
 	M0_POST(m0_cm_invariant(cm));
@@ -677,19 +683,14 @@ M0_INTERNAL struct m0_rpc_machine *m0_cm_rpc_machine_find(struct m0_reqh *reqh)
         return m0_reqh_rpc_mach_tlist_head(&reqh->rh_rpc_machines);
 }
 
-M0_INTERNAL int m0_cm_ready(struct m0_cm *cm)
+static int m0_cm_ready_setup(struct m0_cm *cm)
 {
 	struct m0_rpc_machine  *rmach;
 	struct m0_reqh         *reqh = cm->cm_service.rs_reqh;
+	struct m0_cm_sw         sw;
 	int                     rc;
 
-	M0_ENTRY("cm: %p", cm);
-	M0_PRE(cm != NULL);
-	M0_PRE(cm->cm_type != NULL);
-
-	m0_cm_lock(cm);
 	M0_PRE(m0_cm_state_get(cm) == M0_CMS_IDLE);
-	M0_PRE(m0_cm_invariant(cm));
 
         cm->cm_pm = m0_ios_poolmach_get(cm->cm_service.rs_reqh);
         if (cm->cm_pm == NULL)
@@ -701,11 +702,36 @@ M0_INTERNAL int m0_cm_ready(struct m0_cm *cm)
 	if (rc == 0) {
 		cm->cm_ready_fops_recvd = 0;
 		M0_SET0(&cm->cm_last_saved_sw_hi);
-		rc = m0_cm_sw_local_update(cm);
-		if(rc == 0)
-			rc = m0_cm_sw_remote_update(cm);
+		m0_cm_sw_store_init(cm);
+                rc = m0_cm_sw_store_load(cm, &sw);
+                if (rc == 0)
+                        cm->cm_last_saved_sw_hi = sw.sw_lo;
+		if (rc == -ENOENT)
+			rc = 0;
+		if (rc == 0)
+			m0_cm_sw_update_start(cm);
 	}
-	cm_move(cm, rc, M0_CMS_READY, M0_CM_ERR_READY);
+
+	return rc;
+}
+
+M0_INTERNAL int m0_cm_ready(struct m0_cm *cm)
+{
+	int rc;
+
+	M0_ENTRY("cm: %p", cm);
+	M0_PRE(cm != NULL);
+	M0_PRE(cm->cm_type != NULL);
+
+	m0_cm_lock(cm);
+	M0_PRE(M0_IN(m0_cm_state_get(cm), (M0_CMS_IDLE, M0_CMS_READY)));
+	M0_PRE(m0_cm_invariant(cm));
+
+	if (m0_cm_state_get(cm) == M0_CMS_IDLE) {
+		rc = m0_cm_ready_setup(cm);
+		cm_move(cm, rc, M0_CMS_READY, M0_CM_ERR_READY);
+	} else
+		rc = m0_cm_sw_remote_update(cm);
 	m0_cm_unlock(cm);
 
 	M0_LEAVE("rc: %d", rc);
@@ -786,6 +812,7 @@ M0_INTERNAL int m0_cm_stop(struct m0_cm *cm)
 	if (rc == 0)
 		m0_cm_cp_pump_stop(cm);
 	m0_cm_proxies_fini(cm);
+	m0_cm_sw_update_stop(cm);
 	cm_move(cm, rc, M0_CMS_IDLE, M0_CM_ERR_STOP);
 
 	M0_POST(m0_cm_invariant(cm));
@@ -813,6 +840,7 @@ M0_INTERNAL int m0_cm_module_init(void)
 	m0_bob_type_tlist_init(&cmtypes_bob, &cmtypes_tl);
 	m0_mutex_init(&cmtypes_mutex);
 	m0_cm_cp_pump_init();
+	m0_cm_sw_update_init();
 	m0_cm_cp_module_init();
 	cm_xc_init();
 
@@ -900,6 +928,9 @@ M0_INTERNAL void m0_cm_fini(struct m0_cm *cm)
 	      cm->cm_id, cm->cm_mach.sm_state);
 	m0_cm_state_set(cm, M0_CMS_FINI);
 	m0_sm_fini(&cm->cm_mach);
+	m0_chan_fini_lock(&cm->cm_ready_wait);
+	m0_chan_fini_lock(&cm->cm_complete_wait);
+	m0_mutex_fini(&cm->cm_wait_mutex);
 	m0_cm_unlock(cm);
 
 	m0_sm_group_fini(&cm->cm_sm_group);
@@ -1005,6 +1036,16 @@ M0_INTERNAL void m0_cm_buffer_put(struct m0_net_buffer_pool *bp,
 	m0_net_buffer_pool_unlock(bp);
 }
 
+M0_INTERNAL void m0_cm_ready_done(struct m0_cm *cm)
+{
+	m0_chan_signal_lock(&cm->cm_ready_wait);
+}
+
+M0_INTERNAL void m0_cm_complete(struct m0_cm *cm)
+{
+	m0_chan_signal_lock(&cm->cm_complete_wait);
+}
+
 #undef M0_TRACE_SUBSYSTEM
 
 /** @} endgroup CM */
diff --git a/cm/cm.h b/cm/cm.h
index c8ceef0..41b210a 100644
--- a/cm/cm.h
+++ b/cm/cm.h
@@ -224,6 +224,9 @@ struct m0_cm {
 
 	uint64_t                         cm_aggr_grps_out_nr;
 
+	struct m0_chan                   cm_ready_wait;
+	struct m0_chan                   cm_complete_wait;
+	struct m0_mutex                  cm_wait_mutex;
 	/**
 	 * Counter to track number of ready fops received from other replicas.
 	 * Once the m0_cm::cm_ready_fops_recvd ==
@@ -242,6 +245,8 @@ struct m0_cm {
 
 	/** Copy packet pump FOM for this copy machine. */
 	struct m0_cm_cp_pump             cm_cp_pump;
+
+	struct m0_cm_sw_update           cm_sw_update;
 };
 
 /** Operations supported by a copy machine. */
@@ -303,8 +308,6 @@ struct m0_cm_ops {
 				       const char *local_ep,
 				       const struct m0_cm_sw *sw);
 
-	void (*cmo_complete) (struct m0_cm *cm);
-
 	/** Copy machine specific finalisation routine. */
 	void (*cmo_fini)(struct m0_cm *cm);
 };
@@ -468,6 +471,9 @@ M0_INTERNAL void m0_cm_proxies_fini(struct m0_cm *cm);
 
 M0_INTERNAL struct m0_rpc_machine *m0_cm_rpc_machine_find(struct m0_reqh *reqh);
 
+M0_INTERNAL void m0_cm_ready_done(struct m0_cm *cm);
+M0_INTERNAL void m0_cm_complete(struct m0_cm *cm);
+
 /** @} endgroup CM */
 
 /* __MERO_CM_CM_H__ */
diff --git a/cm/pump.c b/cm/pump.c
index 18b0086..52ca0e5 100644
--- a/cm/pump.c
+++ b/cm/pump.c
@@ -158,7 +158,7 @@ static int cpp_data_next(struct m0_cm_cp_pump *cp_pump)
 				 * failure. So mark the operation as complete.
 				 */
 				if (m0_cm_aggr_group_tlists_are_empty(cm)) {
-					cm->cm_ops->cmo_complete(cm);
+					m0_cm_complete(cm);
 					M0_LOG(M0_DEBUG, "cm %p completed", cm);
 				}
 				pump_move(cp_pump, 0, CPP_COMPLETE);
diff --git a/cm/sw.c b/cm/sw.c
index 98ce560..fc9093d 100644
--- a/cm/sw.c
+++ b/cm/sw.c
@@ -76,14 +76,14 @@ M0_INTERNAL int m0_cm_sw_onwire_init(struct m0_cm_sw_onwire *sw_onwire,
 
 M0_INTERNAL int m0_cm_sw_local_update(struct m0_cm *cm)
 {
-        int rc = 0;
+        int             rc = 0;
 
         M0_ENTRY("cm: %p", cm);
         M0_PRE(cm != NULL);
         M0_PRE(m0_cm_is_locked(cm));
 
 	if (cm->cm_proxy_nr > 0) {
-		if (m0_cm_is_active(cm) &&
+		 if (m0_cm_is_active(cm) &&
 		    !m0_cm_ag_id_is_set(&cm->cm_last_saved_sw_hi))
 				return rc;
 		rc = m0_cm_ag_advance(cm);
@@ -198,49 +198,15 @@ M0_INTERNAL int m0_cm_sw_store_load(struct m0_cm *cm, struct m0_cm_sw *out)
 }
 
 M0_INTERNAL int m0_cm_sw_store_update(struct m0_cm *cm,
+				      struct m0_be_tx *tx,
 				      const struct m0_cm_sw *last)
 {
-	struct m0_be_seg      *seg    = cm->cm_service.rs_reqh->rh_beseg;
-	struct m0_sm_group    *grp    = m0_locality0_get()->lo_grp;
-	struct m0_be_tx_credit cred;
-	struct m0_be_tx        tx     = {};
-	struct m0_cm_sw       *sw;
-	char                   cm_sw_name[80];
-	int                    rc;
-
-	sprintf(cm_sw_name, "cm_sw_%llu", (unsigned long long)cm->cm_id);
-	rc = m0_be_seg_dict_lookup(seg, cm_sw_name, (void**)&sw);
-	if (rc != 0)
-		return rc;
+	struct m0_be_seg       *seg    = cm->cm_service.rs_reqh->rh_beseg;
+	struct m0_cm_sw        *sw;
+	char                    cm_sw_name[80];
+	int                     rc;
 
-	M0_LOG(M0_DEBUG, "sw = %p", sw);
-	m0_sm_group_lock(grp);
-	m0_be_tx_init(&tx, 0, seg->bs_domain, grp, NULL, NULL, NULL, NULL);
-	cred = M0_BE_TX_CREDIT_TYPE(*sw);
-	m0_be_tx_prep(&tx, &cred);
-	rc = m0_be_tx_open_sync(&tx);
-
-	if (rc == 0) {
-		m0_cm_sw_copy(sw, last);
-		M0_BE_TX_CAPTURE_PTR(seg, &tx, sw);
-		m0_be_tx_close_sync(&tx);
-	}
-
-	m0_be_tx_fini(&tx);
-
-	m0_sm_group_unlock(grp);
-	return rc;
-}
-
-M0_INTERNAL int m0_cm_sw_store_complete(struct m0_cm *cm)
-{
-	struct m0_be_seg      *seg  = cm->cm_service.rs_reqh->rh_beseg;
-	struct m0_sm_group    *grp  = m0_locality0_get()->lo_grp;
-	struct m0_be_tx_credit cred = {};
-	struct m0_be_tx        tx   = {};
-	struct m0_cm_sw       *sw;
-	char                   cm_sw_name[80];
-	int                    rc;
+	M0_PRE(m0_cm_is_locked(cm));
 
 	sprintf(cm_sw_name, "cm_sw_%llu", (unsigned long long)cm->cm_id);
 	rc = m0_be_seg_dict_lookup(seg, cm_sw_name, (void**)&sw);
@@ -248,27 +214,14 @@ M0_INTERNAL int m0_cm_sw_store_complete(struct m0_cm *cm)
 		return rc;
 
 	M0_LOG(M0_DEBUG, "sw = %p", sw);
-	m0_sm_group_lock(grp);
-	m0_be_tx_init(&tx, 0, seg->bs_domain, grp, NULL, NULL, NULL, NULL);
-	M0_BE_FREE_CREDIT_PTR(sw, seg, &cred);
-	m0_be_seg_dict_delete_credit(seg, cm_sw_name, &cred);
-	m0_be_tx_prep(&tx, &cred);
-	rc = m0_be_tx_open_sync(&tx);
-
-	M0_LOG(M0_DEBUG, "tx open rc = %d", rc);
 	if (rc == 0) {
-		M0_BE_FREE_PTR_SYNC(sw, seg, &tx);
-		m0_be_seg_dict_delete(seg, &tx, cm_sw_name);
-		m0_be_tx_close_sync(&tx);
+		m0_cm_sw_copy(sw, last);
+		M0_BE_TX_CAPTURE_PTR(seg, tx, sw);
 	}
 
-	m0_be_tx_fini(&tx);
-	m0_sm_group_unlock(grp);
-
 	return rc;
 }
 
-
 #undef M0_TRACE_SUBSYSTEM
 
 /** @} CMSW */
diff --git a/cm/sw.h b/cm/sw.h
index aa1dcb9..989ab9a 100644
--- a/cm/sw.h
+++ b/cm/sw.h
@@ -61,6 +61,12 @@ struct m0_cm_sw_onwire {
 	struct m0_cm_sw       swo_sw;
 }M0_XCA_RECORD;
 
+struct m0_cm_sw_update {
+	struct m0_fom swu_fom;
+	bool          swu_is_complete;
+	bool          swu_is_idle;
+};
+
 M0_INTERNAL int m0_cm_sw_onwire_init(struct m0_cm_sw_onwire *sw_onwire,
 				     const char *ep, const struct m0_cm_sw *sw);
 
@@ -93,13 +99,19 @@ M0_INTERNAL int m0_cm_sw_store_load(struct m0_cm *cm, struct m0_cm_sw *out);
  * Update sliding window data to the last completed aggregation group.
  */
 M0_INTERNAL int m0_cm_sw_store_update(struct m0_cm *cm,
+				      struct m0_be_tx *tx,
 				      const struct m0_cm_sw *last);
 
+M0_INTERNAL void m0_cm_sw_update_init(void);
+
 /**
  * Mark the cm operation as done by deleting sliding window data from storage.
  */
 M0_INTERNAL int m0_cm_sw_store_complete(struct m0_cm *cm);
 
+M0_INTERNAL void m0_cm_sw_update_start(struct m0_cm *cm);
+M0_INTERNAL void m0_cm_sw_update_continue(struct m0_cm *cm);
+M0_INTERNAL void m0_cm_sw_update_stop(struct m0_cm *cm);
 
 /** @} CMSW */
 
diff --git a/cm/ut/cm.c b/cm/ut/cm.c
index 4729bba..28066a9 100644
--- a/cm/ut/cm.c
+++ b/cm/ut/cm.c
@@ -223,6 +223,7 @@ static void cm_ag_ut(void)
 	cm_ut_service_cleanup();
 }
 
+/*
 static void cm_sw_persistence_ut(void)
 {
 	struct m0_cm      *cm = &cm_ut[0].ut_cm;
@@ -234,8 +235,9 @@ static void cm_sw_persistence_ut(void)
 	int                rc;
 
 	cm_ut_service_alloc_init();
-
+*/
 	/* Internally calls m0_cm_setup(). */
+/*
 	rc = m0_reqh_service_start(cm_ut_service);
 	M0_UT_ASSERT(rc == 0);
 
@@ -245,12 +247,15 @@ static void cm_sw_persistence_ut(void)
 	m0_cm_lock(cm);
 	m0_cm_state_set(cm, M0_CMS_READY);
 	m0_cm_unlock(cm);
-
+*/
 	/* Check if we have pending operation from last run */
+/*
 	rc = m0_cm_sw_store_load(cm, &out);
 	M0_UT_ASSERT(rc != 0);
 	M0_UT_ASSERT(rc == -ENOENT);
+*/
 	/* Init the sw persistent storage */
+/*
 	rc = m0_cm_sw_store_init(cm);
 	M0_UT_ASSERT(rc == 0);
 	for(i = 0; i < 10; i++) {
@@ -271,9 +276,11 @@ static void cm_sw_persistence_ut(void)
 	}
 	rc = m0_cm_sw_store_complete(cm);
 	M0_UT_ASSERT(rc == 0);
+*/
 	/* successfully completed an operation.*/
 
 	/* start another one */
+/*
 	rc = m0_cm_sw_store_load(cm, &out);
 	M0_UT_ASSERT(rc != 0);
 	M0_UT_ASSERT(rc == -ENOENT);
@@ -296,6 +303,7 @@ static void cm_sw_persistence_ut(void)
 	m0_ios_poolmach_fini(cm_ut_service);
 	cm_ut_service_cleanup();
 }
+*/
 
 const struct m0_test_suite cm_generic_ut = {
         .ts_name = "cm-ut",
@@ -306,7 +314,7 @@ const struct m0_test_suite cm_generic_ut = {
 		{ "cm_setup_failure_ut",  cm_setup_failure_ut  },
 		{ "cm_init_failure_ut",   cm_init_failure_ut   },
 		{ "cm_ag_ut",             cm_ag_ut             },
-		{ "cm_sw_persistence_ut", cm_sw_persistence_ut },
+		//{ "cm_sw_persistence_ut", cm_sw_persistence_ut },
 		{ NULL, NULL }
         }
 };
diff --git a/cm/ut/common_service.c b/cm/ut/common_service.c
index 2142a4c..90f50a8 100644
--- a/cm/ut/common_service.c
+++ b/cm/ut/common_service.c
@@ -183,7 +183,7 @@ static int cm_ut_ag_next(struct m0_cm *cm, const struct m0_cm_ag_id id_curr,
 static void cm_ut_fini(struct m0_cm *cm)
 {
 }
-
+/*
 static void cm_ut_complete(struct m0_cm *cm)
 {
 	struct m0_ut_cm *ut_cm = cm2utcm(cm);
@@ -191,6 +191,7 @@ static void cm_ut_complete(struct m0_cm *cm)
 
 	m0_chan_signal_lock(wait);
 }
+*/
 
 static const struct m0_cm_ops cm_ut_ops = {
 	.cmo_setup     = cm_ut_setup,
@@ -201,7 +202,7 @@ static const struct m0_cm_ops cm_ut_ops = {
 	.cmo_cp_alloc  = cm_ut_cp_alloc,
 	.cmo_data_next = cm_ut_data_next,
 	.cmo_ag_next   = cm_ut_ag_next,
-	.cmo_complete  = cm_ut_complete,
+//	.cmo_complete  = cm_ut_complete,
 	.cmo_fini      = cm_ut_fini
 };
 
diff --git a/sns/cm/cm.c b/sns/cm/cm.c
index 37a43a6..fcfefaa 100644
--- a/sns/cm/cm.c
+++ b/sns/cm/cm.c
@@ -513,8 +513,6 @@ M0_INTERNAL int m0_sns_cm_setup(struct m0_cm *cm)
 		rc = m0_sns_cm_iter_init(&scm->sc_it);
 		if (rc != 0)
 			return rc;
-		m0_mutex_init(&scm->sc_wait_mutex);
-		m0_chan_init(&scm->sc_wait, &scm->sc_wait_mutex);
 		sns_cm_bp_init(&scm->sc_obp);
 		sns_cm_bp_init(&scm->sc_ibp);
 	}
@@ -675,23 +673,12 @@ M0_INTERNAL void m0_sns_cm_fini(struct m0_cm *cm)
 	m0_net_buffer_pool_fini(&scm->sc_ibp.sb_bp);
 	m0_net_buffer_pool_fini(&scm->sc_obp.sb_bp);
 
-	m0_chan_fini_lock(&scm->sc_wait);
-	m0_mutex_fini(&scm->sc_wait_mutex);
-
 	sns_cm_bp_fini(&scm->sc_obp);
 	sns_cm_bp_fini(&scm->sc_ibp);
 
 	M0_LEAVE();
 }
 
-M0_INTERNAL void m0_sns_cm_complete(struct m0_cm *cm)
-{
-	struct m0_sns_cm *scm;
-
-	scm = cm2sns(cm);
-	m0_chan_signal_lock(&scm->sc_wait);
-}
-
 M0_INTERNAL uint64_t m0_sns_cm_cp_buf_nr(struct m0_net_buffer_pool *bp,
 					 uint64_t data_seg_nr)
 {
diff --git a/sns/cm/cm.h b/sns/cm/cm.h
index ceb62b9..36e2865 100644
--- a/sns/cm/cm.h
+++ b/sns/cm/cm.h
@@ -182,31 +182,19 @@ struct m0_sns_cm {
 	/** Buffer pool for outgoing copy packets. */
 	struct m0_sns_cm_buf_pool      sc_obp;
 
-	/**
-	 * Channel to wait upon before invoking m0_cm_start()/m0_cm_stop()
-	 * for the caller of m0_cm_ready()/m0_cm_start(). This channel is
-	 * signalled from struct m0_cm_ops::cmo_complete() routine, which is
-	 * invoked after all the ready fops from other replicas are recevied or
-	 * after all the aggregation groups are processed and struct m0_cm::
-	 * cm_aggr_grps_in & m0_cm::cm_aggr_grps_out lists are empty.
-	 */
-	struct m0_chan             sc_wait;
-	struct m0_mutex            sc_wait_mutex;
-
-
 	/** Tracks the number for which repair operation has been executed. */
-	uint32_t		   sc_repair_done;
+	uint32_t		     sc_repair_done;
 
 	/**
 	 * Start time for sns copy machine. This is recorded when the ready fop
 	 * arrives to the sns copy machine replica.
 	 */
-	m0_time_t                  sc_start_time;
+	m0_time_t                    sc_start_time;
 	/**
 	 * Stop time for sns copy machine. This is recorded when repair is
 	 * completed.
 	 */
-	m0_time_t                  sc_stop_time;
+	m0_time_t                    sc_stop_time;
 };
 
 M0_INTERNAL int m0_sns_cm_type_register(void);
diff --git a/sns/cm/iter.c b/sns/cm/iter.c
index 57ce802..c978d76 100644
--- a/sns/cm/iter.c
+++ b/sns/cm/iter.c
@@ -316,6 +316,24 @@ static int iter_fid_next(struct m0_sns_cm_iter *it)
 	M0_RETURN(rc);
 }
 
+static bool __has_incoming(struct m0_sns_cm *scm, struct m0_pdclust_layout *pl,
+			   struct m0_fid *gfid, uint64_t group)
+{
+	struct m0_cm_ag_id agid;
+
+	M0_PRE(scm != NULL && pl != NULL && gfid != NULL);
+
+	if (scm->sc_base.cm_proxy_nr > 0) {
+		m0_sns_cm_ag_agid_setup(gfid, group, &agid);
+		M0_LOG(M0_DEBUG, "agid [%lu] [%lu] [%lu] [%lu]",
+		       agid.ai_hi.u_hi, agid.ai_hi.u_lo,
+		       agid.ai_lo.u_hi, agid.ai_lo.u_lo);
+		return  m0_sns_cm_ag_is_relevant(scm, pl, &agid);
+	}
+
+	return false;
+}
+
 static bool __group_skip(struct m0_sns_cm_iter *it, uint64_t group)
 {
 	struct m0_sns_cm           *scm = it2sns(it);
@@ -340,6 +358,42 @@ static bool __group_skip(struct m0_sns_cm_iter *it, uint64_t group)
 	return true;
 }
 
+static int __group_alloc(struct m0_sns_cm *scm, struct m0_fid *gfid,
+			 uint64_t group, struct m0_pdclust_layout *pl,
+			 bool has_incoming)
+{
+	struct m0_cm             *cm = &scm->sc_base;
+	struct m0_cm_aggr_group  *ag;
+	struct m0_cm_ag_id        agid;
+	int                       rc;
+
+	m0_sns_cm_ag_agid_setup(gfid, group, &agid);
+	/*
+	 * Allocate new aggregation group for the given aggregation
+	 * group identifier.
+	 * Check if the aggregation group has incoming copy packets, if
+	 * yes, check if the aggregation group was already created and
+	 * processed through sliding window.
+	 * Thus if sliding_window_lo < agid < sliding_window_hi then the
+	 * group was already processed and we proceed to next group.
+	 */
+	if (has_incoming) {
+		if (m0_cm_ag_id_cmp(&agid,
+				    &cm->cm_last_saved_sw_hi) <= 0)
+			return -EEXIST;
+	}
+	if (has_incoming && !cm->cm_ops->cmo_has_space(cm, &agid,
+					m0_pdl_to_layout(pl))) {
+		M0_LOG(M0_DEBUG, "agid [%lu] [%lu] [%lu] [%lu]",
+		       agid.ai_hi.u_hi, agid.ai_hi.u_lo,
+		       agid.ai_lo.u_hi, agid.ai_lo.u_lo);
+		M0_RETURN(-ENOSPC);
+	}
+	rc = m0_cm_aggr_group_alloc(cm, &agid, has_incoming, &ag);
+
+	return rc;
+}
+
 /**
  * Finds parity group having units belonging to the failed container.
  * This iterates through each parity group of the file, and its units.
@@ -352,14 +406,23 @@ static int __group_next(struct m0_sns_cm_iter *it)
 	struct m0_sns_cm                *scm = it2sns(it);
 	struct m0_sns_cm_file_context   *sfc;
 	struct m0_pdclust_src_addr      *sa;
+	struct m0_fid                   *gfid;
+	struct m0_pdclust_layout        *pl;
 	uint64_t                         group;
+	uint64_t                         nrlu;
+	bool                             has_incoming = false;
+	int                              rc = 0;
+
 	M0_ENTRY("it = %p", it);
 
 	sfc = &it->si_fc;
 	sfc->sfc_groups_nr = m0_sns_cm_nr_groups(sfc->sfc_pdlayout,
 						 sfc->sfc_fsize);
 	sa = &sfc->sfc_sa;
+	gfid = &sfc->sfc_gob_fid;
+	pl = sfc->sfc_pdlayout;
 	for (group = sa->sa_group; group < sfc->sfc_groups_nr; ++group) {
+		M0_LOG(M0_FATAL, "group: [%lu]", group);
 		M0_ADDB_POST(&m0_addb_gmc, &m0_addb_rt_sns_repair_progress,
 			     M0_ADDB_CTX_VEC(&m0_sns_mod_addb_ctx),
 			     scm->sc_it.si_total_files, group + 1,
@@ -367,15 +430,29 @@ static int __group_next(struct m0_sns_cm_iter *it)
 
 		if (__group_skip(it, group))
 			continue;
-		sfc->sfc_sa.sa_group = group;
-		sfc->sfc_sa.sa_unit = 0;
-		iter_phase_set(it, ITPH_COB_NEXT);
-		goto out;
+		has_incoming = __has_incoming(scm, pl, gfid, group);
+		nrlu = m0_sns_cm_ag_nr_local_units(scm, gfid, pl, group);
+		if (has_incoming || nrlu > 0) {
+			rc = __group_alloc(scm, gfid, group, pl, has_incoming);
+			if (rc != 0) {
+				if (rc == -ENOBUFS)
+					iter_phase_set(it, ITPH_AG_SETUP);
+				if (rc == -ENOSPC)
+					rc = -ENOBUFS;
+				if (rc == -EEXIST)
+					rc = 0;
+			}
+			sfc->sfc_sa.sa_group = group;
+			sfc->sfc_sa.sa_unit = 0;
+			if (rc == 0)
+				iter_phase_set(it, ITPH_COB_NEXT);
+			goto out;
+		}
 	}
 
 	iter_phase_set(it, ITPH_FID_NEXT);
 out:
-	M0_RETURN(0);
+	M0_RETURN(rc);
 }
 
 static int iter_group_next_wait(struct m0_sns_cm_iter *it)
@@ -393,21 +470,6 @@ static int iter_group_next(struct m0_sns_cm_iter *it)
 	return __group_next(it);
 }
 
-static bool __has_incoming(struct m0_sns_cm *scm, struct m0_pdclust_layout *pl,
-			   struct m0_cm_ag_id *id)
-{
-	M0_PRE(scm != NULL && pl != NULL && id != NULL);
-
-	if (scm->sc_base.cm_proxy_nr > 0) {
-		M0_LOG(M0_DEBUG, "agid [%lu] [%lu] [%lu] [%lu]",
-		       id->ai_hi.u_hi, id->ai_hi.u_lo,
-		       id->ai_lo.u_hi, id->ai_lo.u_lo);
-		return  m0_sns_cm_ag_is_relevant(scm, pl, id);
-	}
-
-	return false;
-}
-
 /**
  * Configures aggregation group, acquires buffers for accumulator copy packet
  * in the aggregation group failure contexts.
@@ -426,15 +488,14 @@ static int iter_ag_setup(struct m0_sns_cm_iter *it)
 	bool                             has_incoming = false;
 	int                              rc;
 
+	has_incoming = __has_incoming(scm, sfc->sfc_pdlayout, &sfc->sfc_gob_fid, sfc->sfc_sa.sa_group);
 	m0_sns_cm_ag_agid_setup(&sfc->sfc_gob_fid, sfc->sfc_sa.sa_group, &agid);
-	has_incoming = __has_incoming(scm, sfc->sfc_pdlayout, &agid);
-	ag = m0_cm_aggr_group_locate(&scm->sc_base, &agid,
-				     has_incoming);
+	ag = m0_cm_aggr_group_locate(&scm->sc_base, &agid, has_incoming);
 	M0_ASSERT(ag != NULL);
 	sag = ag2snsag(ag);
 	rc = scm->sc_helpers->sch_ag_setup(sag, sfc->sfc_pdlayout);
 	if (rc == 0)
-		iter_phase_set(it, ITPH_CP_SETUP);
+		iter_phase_set(it, ITPH_COB_NEXT);
 
 	return rc;
 }
@@ -471,91 +532,59 @@ static int iter_cp_setup(struct m0_sns_cm_iter *it)
 	struct m0_cm_aggr_group         *ag;
 	struct m0_sns_cm_file_context   *sfc;
 	struct m0_sns_cm_cp             *scp;
-	struct m0_fid                    fid;
-	uint64_t                         group_number;
+	struct m0_fid                   *gfid;
 	bool                             has_incoming = false;
 	bool                             has_data;
+	uint64_t                         group;
 	uint64_t                         stob_offset;
 	uint64_t                         cp_data_seg_nr;
 	uint64_t                         ag_cp_idx;
 	int                              rc = 0;
+
 	M0_ENTRY("it = %p", it);
 
 	sfc = &it->si_fc;
 	pl = sfc->sfc_pdlayout;
-	m0_sns_cm_ag_agid_setup(&sfc->sfc_gob_fid, sfc->sfc_sa.sa_group, &agid);
-	has_incoming = __has_incoming(scm, pl, &agid);
+	group = sfc->sfc_sa.sa_group;
+	gfid = &sfc->sfc_gob_fid;
+	has_incoming = __has_incoming(scm, sfc->sfc_pdlayout, gfid, group);
 	has_data = unit_has_data(scm, sfc->sfc_sa.sa_unit - 1);
-	if (!has_data && !has_incoming)
+	if (!has_data)
 		goto out;
+	m0_sns_cm_ag_agid_setup(gfid, group, &agid);
 	ag = m0_cm_aggr_group_locate(cm, &agid, has_incoming);
-	agid2fid(&agid, &fid);
-	group_number = agid2group(&agid);
-	if (ag == NULL) {
-		/*
-		 * Allocate new aggregation group for the given aggregation
-		 * group identifier.
-		 * Check if the aggregation group has incoming copy packets, if
-		 * yes, check if the aggregation group was already created and
-		 * processed through sliding window.
-		 * Thus if sliding_window_lo < agid < sliding_window_hi then the
-		 * group was already processed and we proceed to next group.
-		 */
-		if (has_incoming) {
-			if (m0_cm_ag_id_cmp(&agid,
-					    &cm->cm_last_saved_sw_hi) <= 0)
-				goto out;
-		}
-		if (has_incoming &&
-		    !cm->cm_ops->cmo_has_space(cm, &agid,
-					       m0_pdl_to_layout(pl))) {
-			M0_LOG(M0_DEBUG, "agid [%lu] [%lu] [%lu] [%lu]",
-			       agid.ai_hi.u_hi, agid.ai_hi.u_lo,
-			       agid.ai_lo.u_hi, agid.ai_lo.u_lo);
-			M0_RETURN(-ENOBUFS);
-		}
-		rc = m0_cm_aggr_group_alloc(cm, &agid,
-					    has_incoming, &ag);
-		if (rc != 0) {
-			if (rc == -ENOBUFS)
-				iter_phase_set(it, ITPH_AG_SETUP);
+	M0_ASSERT(ag != NULL);
+	stob_offset = sfc->sfc_ta.ta_frame *
+		      m0_pdclust_unit_size(sfc->sfc_pdlayout);
+	scp = it->si_cp;
+	scp->sc_base.c_ag = ag;
+	scp->sc_is_local = true;
+	cp_data_seg_nr = m0_sns_cm_data_seg_nr(scm, sfc->sfc_pdlayout);
+	/*
+	 * sfc->sfc_sa.sa_unit has gotten one index ahead. Hence actual
+	 * index of the copy packet is (sfc->sfc_sa.sa_unit - 1).
+	 * see iter_cob_next().
+	 */
+	ag_cp_idx = sfc->sfc_sa.sa_unit - 1;
+	/*
+	 * If the aggregation group unit to be read is a spare unit
+	 * containing data then map the spare unit to its corresponding
+	 * failed data/parity unit in the aggregation group @ag.
+	 * This is required to mark the appropriate data/parity unit of
+	 * which this spare contains data.
+	 */
+	if (m0_pdclust_unit_classify(pl, ag_cp_idx) == M0_PUT_SPARE) {
+		rc = m0_sns_repair_data_map(cm->cm_pm, gfid, pl, group,
+					    ag_cp_idx, &ag_cp_idx);
+		if (rc != 0)
 			M0_RETURN(rc);
-		}
 	}
+	rc = m0_sns_cm_cp_setup(scp, &sfc->sfc_cob_fid, stob_offset,
+				cp_data_seg_nr, ~0, ag_cp_idx);
+	if (rc < 0)
+		M0_RETURN(rc);
 
-	if (has_data) {
-		stob_offset = sfc->sfc_ta.ta_frame *
-			      m0_pdclust_unit_size(sfc->sfc_pdlayout);
-		scp = it->si_cp;
-		scp->sc_base.c_ag = ag;
-		scp->sc_is_local = true;
-		cp_data_seg_nr = m0_sns_cm_data_seg_nr(scm, sfc->sfc_pdlayout);
-		/*
-		 * sfc->sfc_sa.sa_unit has gotten one index ahead. Hence actual
-		 * index of the copy packet is (sfc->sfc_sa.sa_unit - 1).
-		 * see iter_cob_next().
-		 */
-		ag_cp_idx = sfc->sfc_sa.sa_unit - 1;
-		/*
-		 * If the aggregation group unit to be read is a spare unit
-		 * containing data then map the spare unit to its corresponding
-		 * failed data/parity unit in the aggregation group @ag.
-		 * This is required to mark the appropriate data/parity unit of
-		 * which this spare contains data.
-		 */
-		if (m0_pdclust_unit_classify(pl, ag_cp_idx) == M0_PUT_SPARE) {
-			rc = m0_sns_repair_data_map(cm->cm_pm, &fid, pl,
-					group_number, ag_cp_idx, &ag_cp_idx);
-			if (rc != 0)
-				M0_RETURN(rc);
-		}
-		rc = m0_sns_cm_cp_setup(scp, &sfc->sfc_cob_fid, stob_offset,
-					cp_data_seg_nr, ~0, ag_cp_idx);
-		if (rc < 0)
-			M0_RETURN(rc);
-
-		rc = M0_FSO_AGAIN;
-	}
+	rc = M0_FSO_AGAIN;
 out:
 	iter_phase_set(it, ITPH_COB_NEXT);
 
@@ -675,7 +704,7 @@ static struct m0_sm_state_descr cm_iter_sd[ITPH_NR] = {
 		.sd_flags   = 0,
 		.sd_name    = "group next",
 		.sd_allowed = M0_BITS(ITPH_GROUP_NEXT_WAIT, ITPH_COB_NEXT,
-				      ITPH_FID_NEXT)
+				      ITPH_AG_SETUP, ITPH_FID_NEXT)
 	},
 	[ITPH_GROUP_NEXT_WAIT] = {
 		.sd_flags   = 0,
@@ -696,12 +725,12 @@ static struct m0_sm_state_descr cm_iter_sd[ITPH_NR] = {
 	[ITPH_CP_SETUP] = {
 		.sd_flags   = 0,
 		.sd_name    = "cp setup",
-		.sd_allowed = M0_BITS(ITPH_AG_SETUP, ITPH_COB_NEXT)
+		.sd_allowed = M0_BITS(ITPH_COB_NEXT)
 	},
 	[ITPH_AG_SETUP] = {
 		.sd_flags   = 0,
 		.sd_name    = "ag setup",
-		.sd_allowed = M0_BITS(ITPH_CP_SETUP)
+		.sd_allowed = M0_BITS(ITPH_COB_NEXT)
 	},
 	[ITPH_FINI] = {
 		.sd_flags = M0_SDF_TERMINAL,
diff --git a/sns/cm/rebalance/cm.c b/sns/cm/rebalance/cm.c
index 946b551..b1f47da 100644
--- a/sns/cm/rebalance/cm.c
+++ b/sns/cm/rebalance/cm.c
@@ -127,7 +127,6 @@ const struct m0_cm_ops sns_rebalance_ops = {
 	.cmo_ag_next             = m0_sns_cm_ag_next,
 	.cmo_has_space           = rebalance_cm_has_space,
 	.cmo_sw_onwire_fop_setup = m0_sns_cm_rebalance_sw_onwire_fop_setup,
-	.cmo_complete            = m0_sns_cm_complete,
 	.cmo_stop                = rebalance_cm_stop,
 	.cmo_fini                = m0_sns_cm_fini
 };
diff --git a/sns/cm/rebalance/helpers.c b/sns/cm/rebalance/helpers.c
index e0104bd..2649e40 100644
--- a/sns/cm/rebalance/helpers.c
+++ b/sns/cm/rebalance/helpers.c
@@ -149,6 +149,7 @@ static bool rebalance_ag_is_relevant(struct m0_sns_cm *scm,
 	uint32_t                    N;
 	uint32_t                    K;
 	uint32_t                    i;
+	uint32_t                    funit;
 	bool                        result = false;
 	int                         rc;
 
@@ -158,22 +159,23 @@ static bool rebalance_ag_is_relevant(struct m0_sns_cm *scm,
 	for (i = 0; i < N + K; ++i) {
 		sa.sa_unit = i;
 		m0_sns_cm_unit2cobfid(pl, pi, &sa, &ta, gfid, &cobfid);
-		rc = m0_sns_cm_cob_locate(it->si_cob_dom,
-					  &cobfid);
-		if (rc == 0 && m0_sns_cm_is_cob_failed(scm, &cobfid)) {
-			rc = m0_sns_repair_spare_map(pm, gfid, pl, pi,
-						     group, i, &spare);
-			if (rc != 0)
-				return false;
-			sa.sa_unit = spare;
-			/* Identify the COB hosting the spare unit. */
-			m0_sns_cm_unit2cobfid(pl, pi, &sa, &ta, gfid, &cobfid);
-			rc = m0_sns_cm_cob_locate(it->si_cob_dom,
-						  &cobfid);
-			if (rc != 0)
-				result = true;
+		if (m0_sns_cm_is_cob_failed(scm, &cobfid)) {
+			rc = m0_sns_cm_cob_locate(it->si_cob_dom, &cobfid);
+			if (rc == 0) {
+				do {
+					funit = sa.sa_unit;
+					rc = m0_sns_repair_spare_map(pm, gfid, pl, pi,
+								     group, funit, &spare);
+					if (rc != 0)
+						return false;
+					sa.sa_unit = spare;
+					m0_sns_cm_unit2cobfid(pl, pi, &sa, &ta, gfid, &cobfid);
+				} while (m0_sns_cm_is_cob_failed(scm, &cobfid));
+				rc = m0_sns_cm_cob_locate(it->si_cob_dom, &cobfid);
+				if (rc == -ENOENT)
+					result = true;
+			}
 		}
-
 	}
 
 	return result;
diff --git a/sns/cm/repair/cm.c b/sns/cm/repair/cm.c
index 3a11dba..9f61346 100644
--- a/sns/cm/repair/cm.c
+++ b/sns/cm/repair/cm.c
@@ -154,7 +154,6 @@ const struct m0_cm_ops sns_repair_ops = {
 	.cmo_ag_next             = m0_sns_cm_ag_next,
 	.cmo_has_space           = repair_cm_has_space,
 	.cmo_sw_onwire_fop_setup = m0_sns_cm_repair_sw_onwire_fop_setup,
-	.cmo_complete            = m0_sns_cm_complete,
 	.cmo_stop                = repair_cm_stop,
 	.cmo_fini                = m0_sns_cm_fini
 };
diff --git a/sns/cm/repair/helpers.c b/sns/cm/repair/helpers.c
index 896fd54..7c5b796 100644
--- a/sns/cm/repair/helpers.c
+++ b/sns/cm/repair/helpers.c
@@ -98,9 +98,11 @@ static bool repair_ag_is_relevant(struct m0_sns_cm *scm,
 	N = m0_pdclust_N(pl);
 	K = m0_pdclust_K(pl);
 	sa.sa_group = group;
-	for (j = 0; j < N + K; ++j) {
+	for (j = 0; j < N + 2 * K; ++j) {
 		sa.sa_unit = j;
 		m0_sns_cm_unit2cobfid(pl, pi, &sa, &ta, gfid, &cobfid);
+		if (m0_sns_cm_unit_is_spare(scm, pl, gfid, group, j))
+			continue;
 		if (!m0_sns_cm_is_cob_failed(scm, &cobfid))
 			continue;
 		if (m0_sns_cm_is_cob_repaired(scm, &cobfid))
diff --git a/sns/cm/repair/ut/net.c b/sns/cm/repair/ut/net.c
index 886f511..c232135 100644
--- a/sns/cm/repair/ut/net.c
+++ b/sns/cm/repair/ut/net.c
@@ -568,9 +568,11 @@ static void sender_cm_fini(struct m0_cm *cm)
 {
 }
 
+/*
 static void sender_cm_complete(struct m0_cm *cm)
 {
 }
+*/
 
 static const struct m0_cm_ops sender_cm_ops = {
         .cmo_setup     = sender_cm_setup,
@@ -578,7 +580,7 @@ static const struct m0_cm_ops sender_cm_ops = {
         .cmo_stop      = sender_cm_stop,
         .cmo_cp_alloc  = sender_cm_cp_alloc,
         .cmo_data_next = sender_cm_data_next,
-        .cmo_complete  = sender_cm_complete,
+        //.cmo_complete  = sender_cm_complete,
         .cmo_fini      = sender_cm_fini
 };
 
diff --git a/sns/cm/sw_onwire_fom.c b/sns/cm/sw_onwire_fom.c
index 5ecdaf8..f0cbefd 100644
--- a/sns/cm/sw_onwire_fom.c
+++ b/sns/cm/sw_onwire_fom.c
@@ -133,7 +133,7 @@ static int sw_onwire_fom_tick(struct m0_fom *fom)
 			/* This check is for the READY phase completion only. */
 			if (cm->cm_ready_fops_recvd == cm->cm_proxy_nr) {
 				M0_LOG(M0_DEBUG, "Ready done");
-				cm->cm_ops->cmo_complete(cm);
+				m0_cm_ready_done(cm);
 			}
 			m0_cm_unlock(cm);
 		}
diff --git a/sns/cm/trigger_fom.c b/sns/cm/trigger_fom.c
index f9dd587..6164489 100644
--- a/sns/cm/trigger_fom.c
+++ b/sns/cm/trigger_fom.c
@@ -68,12 +68,17 @@ static const struct m0_fom_type_ops trigger_fom_type_ops = {
 };
 
 enum trigger_phases {
-	TPH_READY = M0_FOPH_NR + 1,
+	TPH_READY_SETUP = M0_FOPH_NR + 1,
+	TPH_READY,
 	TPH_START_WAIT,
 	TPH_STOP_WAIT
 };
 
 static struct m0_sm_state_descr trigger_phases[] = {
+	[TPH_READY_SETUP] = {
+		.sd_name      = "Send ready fops",
+		.sd_allowed   = M0_BITS(TPH_READY)
+	},
 	[TPH_READY] = {
 		.sd_name      = "Send ready fops",
 		.sd_allowed   = M0_BITS(TPH_START_WAIT)
@@ -188,31 +193,41 @@ static int trigger_fom_tick(struct m0_fom *fom)
 		scm = cm2sns(cm);
 		M0_LOG(M0_DEBUG, "start state = %d", m0_fom_phase(fom));
 		switch(m0_fom_phase(fom)) {
-			case TPH_READY:
+			case TPH_READY_SETUP:
 				treq = m0_fop_data(fom->fo_fop);
 				scm->sc_op             = treq->op;
-				m0_mutex_lock(&scm->sc_wait_mutex);
-				m0_fom_wait_on(fom, &scm->sc_wait,
+				m0_mutex_lock(&cm->cm_wait_mutex);
+				m0_fom_wait_on(fom, &cm->cm_ready_wait,
+					       &fom->fo_cb);
+				m0_mutex_unlock(&cm->cm_wait_mutex);
+				rc = m0_cm_ready(cm);
+				M0_ASSERT(rc == 0);
+				rc = M0_FSO_WAIT;
+				m0_fom_phase_set(fom, TPH_READY);
+				break;
+			case TPH_READY:
+				m0_mutex_lock(&cm->cm_wait_mutex);
+				m0_fom_wait_on(fom, &cm->cm_ready_wait,
 					       &fom->fo_cb);
-				m0_mutex_unlock(&scm->sc_wait_mutex);
+				m0_mutex_unlock(&cm->cm_wait_mutex);
 				rc = m0_cm_ready(cm);
 				M0_ASSERT(rc == 0);
 				m0_fom_phase_set(fom, TPH_START_WAIT);
 				if (cm->cm_proxy_nr > 1)
 					rc = M0_FSO_WAIT;
 				else {
-					m0_mutex_lock(&scm->sc_wait_mutex);
+					m0_mutex_lock(&cm->cm_wait_mutex);
 					m0_fom_callback_cancel(&fom->fo_cb);
-					m0_mutex_unlock(&scm->sc_wait_mutex);
+					m0_mutex_unlock(&cm->cm_wait_mutex);
 					rc = M0_FSO_AGAIN;
 				}
 				M0_LOG(M0_DEBUG, "got trigger: ready done");
 				break;
 			case TPH_START_WAIT:
-				m0_mutex_lock(&scm->sc_wait_mutex);
-				m0_fom_wait_on(fom, &scm->sc_wait,
+				m0_mutex_lock(&cm->cm_wait_mutex);
+				m0_fom_wait_on(fom, &cm->cm_complete_wait,
 					       &fom->fo_cb);
-				m0_mutex_unlock(&scm->sc_wait_mutex);
+				m0_mutex_unlock(&cm->cm_wait_mutex);
 				rc = m0_cm_start(cm);
 				M0_ASSERT(rc == 0);
 				m0_fom_phase_set(fom, TPH_STOP_WAIT);
-- 
1.8.3.2

