From c532c093096f35eb6202e2afcb69ec4511cf1ba2 Mon Sep 17 00:00:00 2001
From: Mandar Sawant <mandar_sawant@xyratex.com>
Date: Tue, 12 Nov 2013 17:54:07 +0530
Subject: [PATCH 3/3] SNS iter store integration, - Add M0_CMS_PREPARE phase to
 generic copy machine infrastructure   to handle local sliding window update
 before READY phase asynchronously. - Fix UT's accordingly. - Update
 documentation.

---
 cm/ag.c                |   9 ----
 cm/cm.c                | 112 +++++++++++++++++++++++++++++++++----------------
 cm/cm.h                |   6 ++-
 cm/sw.c                |  22 +++++-----
 cm/sw.h                |   8 ++++
 cm/sw_update_fom.c     |  34 +++++++++------
 cm/ut/cm.c             |  89 +++------------------------------------
 cm/ut/common_service.c |  16 ++-----
 sns/cm/cm.c            |  40 ++++--------------
 sns/cm/cm.h            |   2 +-
 sns/cm/iter.c          |  13 +++---
 sns/cm/rebalance/cm.c  |   6 +--
 sns/cm/repair/cm.c     |   6 +--
 sns/cm/repair/ut/cm.c  |   4 +-
 sns/cm/repair/ut/net.c |  20 ++++++---
 sns/cm/trigger_fom.c   |  11 ++---
 16 files changed, 169 insertions(+), 229 deletions(-)

diff --git a/cm/ag.c b/cm/ag.c
index 6ffa0e8..d9cf688 100644
--- a/cm/ag.c
+++ b/cm/ag.c
@@ -155,7 +155,6 @@ M0_INTERNAL void m0_cm_aggr_group_fini_and_progress(struct m0_cm_aggr_group *ag)
 	struct m0_cm_ag_id        id;
 	struct m0_cm_aggr_group  *hi;
 	struct m0_cm_aggr_group  *lo;
-	//struct m0_cm_sw           sw;
 	bool                      has_data;
 
 	M0_ENTRY("ag: %p", ag);
@@ -180,11 +179,6 @@ M0_INTERNAL void m0_cm_aggr_group_fini_and_progress(struct m0_cm_aggr_group *ag)
 	}
 	m0_cm_sw_update_continue(cm);
 	m0_cm_aggr_group_fini(ag);
-	//M0_SET0(&sw);
-	//hi = m0_cm_ag_hi(cm);
-	//lo = m0_cm_ag_lo(cm);
-	//m0_cm_sw_set(&sw, &lo->cag_id, &hi->cag_id);
-	//m0_cm_sw_store_update(cm, &sw);
 	has_data = m0_cm_has_more_data(cm);
 	if (!has_data && cm->cm_aggr_grps_in_nr == 0 &&
 	    cm->cm_aggr_grps_out_nr == 0)
@@ -372,9 +366,6 @@ M0_INTERNAL int m0_cm_ag_advance(struct m0_cm *cm)
 		}
 	} while (rc == 0);
 
-	//if (rc == -ENOSPC || rc == -ENOENT)
-	//	rc = 0;
-
 	return rc;
 }
 
diff --git a/cm/cm.c b/cm/cm.c
index 3cf20b1..4851ea0 100644
--- a/cm/cm.c
+++ b/cm/cm.c
@@ -134,6 +134,7 @@
     agents" in @ref CMDLD-ref
    - @ref CMDLD-lspec-state
    - @ref CMDLD-lspec-cm-setup
+   - @ref CMDLD-lspec-cm-prepare
    - @ref CMDLD-lspec-cm-ready
    - @ref CMDLD-lspec-cm-start
       - @ref CMDLD-lspec-cm-cp-pump
@@ -150,12 +151,15 @@
        node [shape=record, fontsize=12]
        INIT [label="INTIALISING"]
        IDLE [label="IDLE"]
+       PREPARE [label="PREPARE"]
        READY [label="READY"]
        ACTIVE [label="ACTIVE"]
        FAIL [label="FAIL"]
        STOP [label="STOP"]
        INIT -> IDLE [label="Configuration received from confc"]
-       IDLE -> READY [label="Initialisation complete.Broadcast READY fop"]
+       IDLE -> PREPARE [label="Initialise sliding window"]
+       PREPARE -> READY [label="Initialisation complete.Broadcast READY fop"]
+       PREPARE -> FAIL [label="Sliding window initialisation error"]
        IDLE -> FAIL [label="Timed out or self destruct"]
        READY -> ACTIVE [label="All READY fops received"]
        READY -> FAIL [label="Timed out waiting for READY fops"]
@@ -177,6 +181,10 @@
    service startup, and thus copy machine is finalised during copy machine
    service finalisation.
 
+   @subsection CMDLD-lspec-cm-prepare Copy machine prepare
+   Initialise local sliding window and sliding window persistent store.
+   Persist sliding window after initialisation and proceed to READY phase.
+
    @subsection CMDLD-lspec-cm-ready Copy machine ready
    In case of multiple nodes, every copy machine replica allocates an instance
    of struct m0_cm_proxy representing a particular remote replica and
@@ -184,6 +192,14 @@
    After successfully establishing the rpc connections, copy machine specific
    m0_cm_ops::cmo_ready() operation is invoked to further setup the specific
    copy machine data structures.
+   After creating proxies representing the remote replicas, for each remote
+   replica the READY FOPs are allocated and initialised with the calculated
+   local sliding window. The copy machine then broadcasts these READY FOPs to
+   every remote replica using the rpc connection in the corresponding
+   m0_cm_proxy. A READY FOP is a one-way fop and thus do not have a reply
+   associated with it. Once every replica receives READY FOPs from all the
+   corresponding remote replicas, the copy machine proceeds to the START phase.
+   @see struct m0_cm_ready
 
    @subsection CMDLD-lspec-cm-start Copy machine operation start
    After copy machine service is successfully started, it is ready to perform
@@ -240,8 +256,16 @@
    M0_CMS_READY phase and updated during finalisation of a completed aggregation
    group (i.e. aggregation group for which all the copy packets are processed).
    Periodically, updated sliding window is communicated to remote replica.
-   @see m0_cm_proxy_sw_update_ast_post()
-   @see m0_cm_proxy_remote_update()
+   @ref m0_cm_proxy_sw_update_ast_post() @ref m0_cm_proxy_remote_update()
+
+   Updating the local sliding window and saving it to persistent store is
+   implemented through sliding window update FOM. This helps in perfoming
+   various tasks asynchronously, viz:- updating the local sliding window
+   and saving it to persistent store.
+   @see struct m0_cm_sw_update
+   @see m0_cm_sw_update_start()
+   @see m0_cm_sw_update_continue()
+   @see m0_cm_sw_update_stop()
 
    @subsection CMDLD-lspec-cm-sliding-window-persistence Copy machine sliding \
  window persistence
@@ -266,7 +290,6 @@
    - m0_cm_sw_store_init()            Init data on persistent storage.
    - m0_cm_sw_store_load()            Load data from persistent storage.
    - m0_cm_sw_store_update()          Update data to the last completed AG.
-   - m0_cm_sw_store_complete()        Mark the cm operation as done.
 
    These interfaces will be used in various copy machine operations to manage
    the persistent information. For example, m0_cm_sw_store_load() will be used
@@ -278,15 +301,20 @@
    node failure happens at this time, and then restarts again, it loads from
    storage, and -ENOENT indicates no pending copy machine operation is progress.
 
-   The call sequence of these interfaces is:
+   The call sequence of interface and sliding window update FOM execution is as
+   below:
 
    @verbatim
                                          |
                                          |
                                          V
-                             --------------------------
-                             | m0_cm_sw_store_load()? |
-                             --------------------------
+                             ------------------------------------
+                             | m0_cm_sw_store_load() |
+                             Read sliding window from persistent
+                             store to continue from any previously
+                             pending repair operation.
+                             Also start sliding update FOM.
+                             ------------------------------------
                                    /         \
                                   /           \
                   ret == 0       /             \ ret == -ENOENT
@@ -305,7 +333,7 @@
                               \                    /
                                \                  /
                                 \                /
-                                 V              V
+                                 V  SWU_STORE   V
                             ---------------------------     operation completed
                    -------> | m0_cm_sw_store_update() |----------------------->
                    |        ---------------------------                       |
@@ -314,7 +342,7 @@
                    |                    |                                     |
                    <--------------------V                                     |
                      operation continue                                       |
-                                                                              V
+                                                        SWU_COMPLETE          V
                                                    ----------------------------
                                                    |m0_cm_sw_store_complete():|
                                                    |delete sw info from       |
@@ -440,9 +468,15 @@ static struct m0_sm_state_descr cm_state_descr[M0_CMS_NR] = {
 	[M0_CMS_IDLE] = {
 		.sd_flags	= 0,
 		.sd_name	= "cm_idle",
-		.sd_allowed	= M0_BITS(M0_CMS_FAIL, M0_CMS_READY,
+		.sd_allowed	= M0_BITS(M0_CMS_FAIL, M0_CMS_PREPARE,
 					  M0_CMS_FINI)
 	},
+	[M0_CMS_PREPARE] = {
+		.sd_flags	= 0,
+		.sd_name	= "cm_prepare",
+		.sd_allowed	= M0_BITS(M0_CMS_READY, M0_CMS_FINI,
+					  M0_CMS_FAIL)
+	},
 	[M0_CMS_READY] = {
 		.sd_flags	= 0,
 		.sd_name	= "cm_ready",
@@ -525,7 +559,9 @@ M0_INTERNAL void m0_cm_fail(struct m0_cm *cm, enum m0_cm_failure failure,
 		M0_ADDB_FUNC_FAIL(addb_mc, M0_CM_ADDB_LOC_SETUP_FAIL, rc,
 				  &m0_cm_mod_ctx, &cm->cm_service.rs_addb_ctx);
 		break;
-
+	case M0_CM_ERR_PREPARE:
+		__cm_fail(cm, 0, M0_CMS_IDLE);
+		break;
 	case M0_CM_ERR_READY:
 		__cm_fail(cm, 0, M0_CMS_IDLE);
 		break;
@@ -593,8 +629,8 @@ M0_INTERNAL bool m0_cm_invariant(const struct m0_cm *cm)
 		cm != NULL && cm->cm_ops != NULL && cm->cm_type != NULL &&
 		m0_sm_invariant(&cm->cm_mach) &&
 		/* Copy machine state sanity checks. */
-		ergo(M0_IN(state, (M0_CMS_IDLE, M0_CMS_READY, M0_CMS_ACTIVE,
-				   M0_CMS_STOP)),
+		ergo(M0_IN(state, (M0_CMS_IDLE, M0_CMS_PREPARE, M0_CMS_READY,
+				   M0_CMS_ACTIVE, M0_CMS_STOP)),
 		     m0_reqh_service_invariant(&cm->cm_service));
 }
 
@@ -683,55 +719,58 @@ M0_INTERNAL struct m0_rpc_machine *m0_cm_rpc_machine_find(struct m0_reqh *reqh)
         return m0_reqh_rpc_mach_tlist_head(&reqh->rh_rpc_machines);
 }
 
-static int m0_cm_ready_setup(struct m0_cm *cm)
+M0_INTERNAL int m0_cm_prepare(struct m0_cm *cm)
 {
-	struct m0_rpc_machine  *rmach;
-	struct m0_reqh         *reqh = cm->cm_service.rs_reqh;
-	struct m0_cm_sw         sw;
-	int                     rc;
+	struct m0_cm_sw sw;
+	int             rc;
 
+	m0_cm_lock(cm);
 	M0_PRE(m0_cm_state_get(cm) == M0_CMS_IDLE);
 
         cm->cm_pm = m0_ios_poolmach_get(cm->cm_service.rs_reqh);
-        if (cm->cm_pm == NULL)
-                return -EINVAL;
-        rmach = m0_cm_rpc_machine_find(reqh);
-        rc = cm_replicas_connect(cm, rmach, reqh);
-        if (rc == 0 || rc == -ENOENT)
-		rc = cm->cm_ops->cmo_ready(cm);
+        if (cm->cm_pm == NULL) {
+                rc = -EINVAL;
+		goto out;
+	}
+	rc = cm->cm_ops->cmo_prepare(cm);
 	if (rc == 0) {
-		cm->cm_ready_fops_recvd = 0;
 		M0_SET0(&cm->cm_last_saved_sw_hi);
 		m0_cm_sw_store_init(cm);
-                rc = m0_cm_sw_store_load(cm, &sw);
-                if (rc == 0)
-                        cm->cm_last_saved_sw_hi = sw.sw_lo;
+		rc = m0_cm_sw_store_load(cm, &sw);
+		if (rc == 0)
+			cm->cm_last_saved_sw_hi = sw.sw_lo;
 		if (rc == -ENOENT)
 			rc = 0;
 		if (rc == 0)
 			m0_cm_sw_update_start(cm);
 	}
+out:
+	cm_move(cm, rc, M0_CMS_PREPARE, M0_CM_ERR_PREPARE);
+	m0_cm_unlock(cm);
 
 	return rc;
 }
 
 M0_INTERNAL int m0_cm_ready(struct m0_cm *cm)
 {
-	int rc;
+	struct m0_rpc_machine  *rmach;
+	struct m0_reqh         *reqh = cm->cm_service.rs_reqh;
+	int                     rc;
 
 	M0_ENTRY("cm: %p", cm);
 	M0_PRE(cm != NULL);
 	M0_PRE(cm->cm_type != NULL);
 
 	m0_cm_lock(cm);
-	M0_PRE(M0_IN(m0_cm_state_get(cm), (M0_CMS_IDLE, M0_CMS_READY)));
+	M0_PRE(m0_cm_state_get(cm) == M0_CMS_PREPARE);
 	M0_PRE(m0_cm_invariant(cm));
 
-	if (m0_cm_state_get(cm) == M0_CMS_IDLE) {
-		rc = m0_cm_ready_setup(cm);
-		cm_move(cm, rc, M0_CMS_READY, M0_CM_ERR_READY);
-	} else
+	cm->cm_ready_fops_recvd = 0;
+        rmach = m0_cm_rpc_machine_find(reqh);
+        rc = cm_replicas_connect(cm, rmach, reqh);
+        if (rc == 0 || rc == -ENOENT)
 		rc = m0_cm_sw_remote_update(cm);
+	cm_move(cm, rc, M0_CMS_READY, M0_CM_ERR_READY);
 	m0_cm_unlock(cm);
 
 	M0_LEAVE("rc: %d", rc);
@@ -809,8 +848,7 @@ M0_INTERNAL int m0_cm_stop(struct m0_cm *cm)
 	m0_cm_unlock(cm);
 	m0_cm_lock(cm);
 	rc = cm->cm_ops->cmo_stop(cm);
-	if (rc == 0)
-		m0_cm_cp_pump_stop(cm);
+	m0_cm_cp_pump_stop(cm);
 	m0_cm_proxies_fini(cm);
 	m0_cm_sw_update_stop(cm);
 	cm_move(cm, rc, M0_CMS_IDLE, M0_CM_ERR_STOP);
diff --git a/cm/cm.h b/cm/cm.h
index 41b210a..08fdd22 100644
--- a/cm/cm.h
+++ b/cm/cm.h
@@ -81,6 +81,7 @@
    @subsection CMDLD-fspec-sub-opi Operational Interfaces
    Lists the various external interfaces exported by the copy machine.
    - m0_cm_setup()		     Setup a copy machine.
+   - m0_cm_prepare()                 Initialises local sliding window.
    - m0_cm_ready()                   Synchronizes copy machine with remote
 				     replicas.
    - m0_cm_start()                   Starts copy machine operation.
@@ -119,6 +120,7 @@ struct m0_net_buffer_pool;
 enum m0_cm_state {
 	M0_CMS_INIT,
 	M0_CMS_IDLE,
+	M0_CMS_PREPARE,
 	M0_CMS_READY,
 	M0_CMS_ACTIVE,
 	M0_CMS_FAIL,
@@ -135,6 +137,7 @@ enum m0_cm_state {
 enum m0_cm_failure {
 	/** Copy machine setup failure */
 	M0_CM_ERR_SETUP = 1,
+	M0_CM_ERR_PREPARE,
 	/** Copy machine start failure */
 	M0_CM_ERR_READY,
 	M0_CM_ERR_START,
@@ -258,7 +261,7 @@ struct m0_cm_ops {
 	 */
 	int (*cmo_setup)(struct m0_cm *cm);
 
-	int (*cmo_ready)(struct m0_cm *cm);
+	int (*cmo_prepare)(struct m0_cm *cm);
 
 	/**
 	 * Starts copy machine operation. Acquires copy machine specific
@@ -364,6 +367,7 @@ M0_INTERNAL void m0_cm_fini(struct m0_cm *cm);
  */
 M0_INTERNAL int m0_cm_setup(struct m0_cm *cm);
 
+M0_INTERNAL int m0_cm_prepare(struct m0_cm *cm);
 M0_INTERNAL int m0_cm_ready(struct m0_cm *cm);
 
 M0_INTERNAL bool m0_cm_is_ready(struct m0_cm *cm);
diff --git a/cm/sw.c b/cm/sw.c
index fc9093d..624d1bd 100644
--- a/cm/sw.c
+++ b/cm/sw.c
@@ -76,21 +76,19 @@ M0_INTERNAL int m0_cm_sw_onwire_init(struct m0_cm_sw_onwire *sw_onwire,
 
 M0_INTERNAL int m0_cm_sw_local_update(struct m0_cm *cm)
 {
-        int             rc = 0;
+	int             rc = -ENOENT;
 
-        M0_ENTRY("cm: %p", cm);
-        M0_PRE(cm != NULL);
-        M0_PRE(m0_cm_is_locked(cm));
+	M0_ENTRY("cm: %p", cm);
+	M0_PRE(cm != NULL);
+	M0_PRE(m0_cm_is_locked(cm));
 
-	if (cm->cm_proxy_nr > 0) {
-		 if (m0_cm_is_active(cm) &&
-		    !m0_cm_ag_id_is_set(&cm->cm_last_saved_sw_hi))
-				return rc;
-		rc = m0_cm_ag_advance(cm);
-	}
+	if (m0_cm_is_active(cm) &&
+	    !m0_cm_ag_id_is_set(&cm->cm_last_saved_sw_hi))
+		return rc;
+	rc = m0_cm_ag_advance(cm);
 
-        M0_LEAVE("rc: %d", rc);
-        return rc;
+	M0_LEAVE("rc: %d", rc);
+	return rc;
 }
 
 M0_INTERNAL int m0_cm_sw_remote_update(struct m0_cm *cm)
diff --git a/cm/sw.h b/cm/sw.h
index 989ab9a..a7e19d0 100644
--- a/cm/sw.h
+++ b/cm/sw.h
@@ -109,7 +109,15 @@ M0_INTERNAL void m0_cm_sw_update_init(void);
  */
 M0_INTERNAL int m0_cm_sw_store_complete(struct m0_cm *cm);
 
+/**
+ * Starts sliding window update FOM by submitting the corresponding FOM to
+ * request handler.
+ */
 M0_INTERNAL void m0_cm_sw_update_start(struct m0_cm *cm);
+
+/**
+ * Wakes up the FOM iff it is idle.
+ */
 M0_INTERNAL void m0_cm_sw_update_continue(struct m0_cm *cm);
 M0_INTERNAL void m0_cm_sw_update_stop(struct m0_cm *cm);
 
diff --git a/cm/sw_update_fom.c b/cm/sw_update_fom.c
index 62d5628..67b039e 100644
--- a/cm/sw_update_fom.c
+++ b/cm/sw_update_fom.c
@@ -23,7 +23,7 @@
 
 #include "lib/bob.h"
 #include "lib/misc.h"  /* M0_BITS */
-#include "lib/errno.h" /* ENOBUFS, ENODATA */
+#include "lib/errno.h" /* ENOENT EPERM */
 
 #include "reqh/reqh.h"
 #include "sm/sm.h"
@@ -33,6 +33,13 @@
 
 /**
    @addtogroup CM
+
+   Implementation of sliding window update FOM.
+   Provides mechanism to handle blocking operations like local sliding
+   update and updating the persistent store with new sliding window.
+   Provides interfaces to start, wakeup (if idle) and stop the sliding
+   window update FOM.
+
    @{
 */
 
@@ -85,19 +92,19 @@ static struct m0_sm_conf cm_sw_update_conf = {
 	.scf_state     = cm_sw_update_sd
 };
 
-struct m0_cm *m0_cm_swu2cm(struct m0_cm_sw_update *swu)
+static struct m0_cm *cm_swu2cm(struct m0_cm_sw_update *swu)
 {
 	return container_of(swu, struct m0_cm, cm_sw_update);
 }
 
-struct m0_cm_sw_update *m0_cm_fom2swu(struct m0_fom *fom)
+static struct m0_cm_sw_update *cm_fom2swu(struct m0_fom *fom)
 {
 	return container_of(fom, struct m0_cm_sw_update, swu_fom);
 }
 
 static int swu_update(struct m0_cm_sw_update *swu)
 {
-	struct m0_cm  *cm = m0_cm_swu2cm(swu); 
+	struct m0_cm  *cm = cm_swu2cm(swu);
 	struct m0_fom *fom = &swu->swu_fom;
 	int            rc = M0_FSO_AGAIN;
 
@@ -123,7 +130,7 @@ static int swu_update(struct m0_cm_sw_update *swu)
 
 static int swu_store(struct m0_cm_sw_update *swu)
 {
-	struct m0_cm             *cm = m0_cm_swu2cm(swu);
+	struct m0_cm             *cm = cm_swu2cm(swu);
 	struct m0_fom            *fom = &swu->swu_fom;
 	struct m0_dtx            *tx = &fom->fo_tx;
 	struct m0_be_seg         *seg  = cm->cm_service.rs_reqh->rh_beseg;
@@ -141,6 +148,10 @@ static int swu_store(struct m0_cm_sw_update *swu)
 		M0_SET0(&sw);
 		hi = m0_cm_ag_hi(cm);
 		lo = m0_cm_ag_lo(cm);
+		if (hi == NULL && lo == NULL) {
+			rc = -EINVAL;
+			goto err;
+		}
 		m0_cm_sw_set(&sw, &lo->cag_id, &hi->cag_id);
 		rc = m0_cm_sw_store_update(cm, &tx->tx_betx, &sw);
 		if (rc == 0) {
@@ -151,6 +162,7 @@ static int swu_store(struct m0_cm_sw_update *swu)
 		}
 	}
 
+err:
 	if (rc != 0)
 		m0_fom_phase_move(fom, rc, SWU_FINI);
 
@@ -159,7 +171,7 @@ static int swu_store(struct m0_cm_sw_update *swu)
 
 static int swu_wait(struct m0_cm_sw_update *swu)
 {
-	struct m0_cm   *cm = m0_cm_swu2cm(swu);
+	struct m0_cm   *cm = cm_swu2cm(swu);
 	struct m0_fom  *fom = &swu->swu_fom;
 	struct m0_dtx  *tx = &fom->fo_tx;
 
@@ -185,7 +197,7 @@ out:
 
 static int swu_complete(struct m0_cm_sw_update *swu)
 {
-	struct m0_cm             *cm = m0_cm_swu2cm(swu);
+	struct m0_cm             *cm = cm_swu2cm(swu);
 	struct m0_fom            *fom = &swu->swu_fom;
 	struct m0_dtx            *tx = &fom->fo_tx;
 	struct m0_be_seg         *seg  = cm->cm_service.rs_reqh->rh_beseg;
@@ -239,8 +251,8 @@ static int cm_swu_fom_tick(struct m0_fom *fom)
 	int                     phase = m0_fom_phase(fom);
 	int                     rc;
 
-	swu = m0_cm_fom2swu(fom);
-	cm = m0_cm_swu2cm(swu);
+	swu = cm_fom2swu(fom);
+	cm = cm_swu2cm(swu);
 	m0_cm_lock(cm);
 	rc = swu_action[phase](swu);
 	m0_cm_unlock(cm);
@@ -255,10 +267,6 @@ static void cm_swu_fom_fini(struct m0_fom *fom)
 
 static void cm_swu_fom_addb_init(struct m0_fom *fom, struct m0_addb_mc *mc)
 {
-	/**
-	 * @todo: Do the actual impl, need to set MAGIC, so that
-	 * m0_fom_init() can pass
-	 */
 	fom->fo_addb_ctx.ac_magic = M0_ADDB_CTX_MAGIC;
 }
 
diff --git a/cm/ut/cm.c b/cm/ut/cm.c
index 28066a9..0142379 100644
--- a/cm/ut/cm.c
+++ b/cm/ut/cm.c
@@ -77,7 +77,13 @@ static void cm_setup_ut(void)
 	rc = m0_ios_poolmach_init(cm_ut_service);
 	M0_UT_ASSERT(rc == 0);
 
+	m0_cm_prepare(cm);
 	m0_cm_lock(cm);
+	//m0_cm_sw_update_start(cm);
+	/*
+	 * Start sliding window update FOM to avoid failure during
+	 * m0_cm_stop().
+	 */
 	m0_cm_state_set(cm, M0_CMS_READY);
 	m0_cm_unlock(cm);
 	/* Checks if the restructuring process is started successfully. */
@@ -223,88 +229,6 @@ static void cm_ag_ut(void)
 	cm_ut_service_cleanup();
 }
 
-/*
-static void cm_sw_persistence_ut(void)
-{
-	struct m0_cm      *cm = &cm_ut[0].ut_cm;
-	struct m0_cm_sw    sw;
-	struct m0_cm_sw    out;
-	struct m0_cm_ag_id id_lo;
-	struct m0_cm_ag_id id_hi;
-	int                i;
-	int                rc;
-
-	cm_ut_service_alloc_init();
-*/
-	/* Internally calls m0_cm_setup(). */
-/*
-	rc = m0_reqh_service_start(cm_ut_service);
-	M0_UT_ASSERT(rc == 0);
-
-	rc = m0_ios_poolmach_init(cm_ut_service);
-	M0_UT_ASSERT(rc == 0);
-
-	m0_cm_lock(cm);
-	m0_cm_state_set(cm, M0_CMS_READY);
-	m0_cm_unlock(cm);
-*/
-	/* Check if we have pending operation from last run */
-/*
-	rc = m0_cm_sw_store_load(cm, &out);
-	M0_UT_ASSERT(rc != 0);
-	M0_UT_ASSERT(rc == -ENOENT);
-*/
-	/* Init the sw persistent storage */
-/*
-	rc = m0_cm_sw_store_init(cm);
-	M0_UT_ASSERT(rc == 0);
-	for(i = 0; i < 10; i++) {
-
-		M0_SET0(&id_lo);
-		M0_SET0(&id_hi);
-		ag_id_assign(&id_lo, i, i, i, i);
-		ag_id_assign(&id_hi, i + 1, i + 1, i + 1, i + 1);
-		m0_cm_sw_set(&sw, &id_lo, &id_hi);
-		rc = m0_cm_sw_store_update(cm, &sw);
-		M0_UT_ASSERT(rc == 0);
-		rc = m0_cm_sw_store_load(cm, &out);
-		M0_UT_ASSERT(rc == 0);
-		rc = m0_cm_ag_id_cmp(&sw.sw_lo, &out.sw_lo);
-		M0_UT_ASSERT(rc == 0);
-		rc = m0_cm_ag_id_cmp(&sw.sw_hi, &out.sw_hi);
-		M0_UT_ASSERT(rc == 0);
-	}
-	rc = m0_cm_sw_store_complete(cm);
-	M0_UT_ASSERT(rc == 0);
-*/
-	/* successfully completed an operation.*/
-
-	/* start another one */
-/*
-	rc = m0_cm_sw_store_load(cm, &out);
-	M0_UT_ASSERT(rc != 0);
-	M0_UT_ASSERT(rc == -ENOENT);
-	rc = m0_cm_sw_store_update(cm, &sw);
-	M0_UT_ASSERT(rc != 0);
-	M0_UT_ASSERT(rc == -ENOENT);
-	rc = m0_cm_sw_store_init(cm);
-	M0_UT_ASSERT(rc == 0);
-	rc = m0_cm_sw_store_update(cm, &sw);
-	M0_UT_ASSERT(rc == 0);
-	rc = m0_cm_sw_store_load(cm, &out);
-	M0_UT_ASSERT(rc == 0);
-	rc = m0_cm_ag_id_cmp(&sw.sw_lo, &out.sw_lo);
-	M0_UT_ASSERT(rc == 0);
-	rc = m0_cm_ag_id_cmp(&sw.sw_hi, &out.sw_hi);
-	M0_UT_ASSERT(rc == 0);
-	rc = m0_cm_sw_store_complete(cm);
-	M0_UT_ASSERT(rc == 0);
-
-	m0_ios_poolmach_fini(cm_ut_service);
-	cm_ut_service_cleanup();
-}
-*/
-
 const struct m0_test_suite cm_generic_ut = {
         .ts_name = "cm-ut",
         .ts_init = &cm_ut_init,
@@ -314,7 +238,6 @@ const struct m0_test_suite cm_generic_ut = {
 		{ "cm_setup_failure_ut",  cm_setup_failure_ut  },
 		{ "cm_init_failure_ut",   cm_init_failure_ut   },
 		{ "cm_ag_ut",             cm_ag_ut             },
-		//{ "cm_sw_persistence_ut", cm_sw_persistence_ut },
 		{ NULL, NULL }
         }
 };
diff --git a/cm/ut/common_service.c b/cm/ut/common_service.c
index 90f50a8..7f4d358 100644
--- a/cm/ut/common_service.c
+++ b/cm/ut/common_service.c
@@ -101,7 +101,7 @@ static int cm_ut_setup(struct m0_cm *cm)
 	return 0;
 }
 
-static int cm_ut_ready(struct m0_cm *cm)
+static int cm_ut_prepare(struct m0_cm *cm)
 {
 	return 0;
 }
@@ -163,7 +163,7 @@ static int cm_ut_ag_next(struct m0_cm *cm, const struct m0_cm_ag_id id_curr,
 
 	if (ag_id_cnt[cid] == MAX_CM_NR || !test_ready_fop) {
 		ag_id_cnt[cid] = 0;
-		return -ENOSPC;
+		return -ENOENT;
 	}
 
 	if (test_ready_fop) {
@@ -183,26 +183,16 @@ static int cm_ut_ag_next(struct m0_cm *cm, const struct m0_cm_ag_id id_curr,
 static void cm_ut_fini(struct m0_cm *cm)
 {
 }
-/*
-static void cm_ut_complete(struct m0_cm *cm)
-{
-	struct m0_ut_cm *ut_cm = cm2utcm(cm);
-	struct m0_chan *wait = &ut_cm->ut_cm_wait;
-
-	m0_chan_signal_lock(wait);
-}
-*/
 
 static const struct m0_cm_ops cm_ut_ops = {
 	.cmo_setup     = cm_ut_setup,
-	.cmo_ready     = cm_ut_ready,
+	.cmo_prepare   = cm_ut_prepare,
 	.cmo_start     = cm_ut_start,
 	.cmo_stop      = cm_ut_stop,
 	.cmo_ag_alloc  = cm_ut_ag_alloc,
 	.cmo_cp_alloc  = cm_ut_cp_alloc,
 	.cmo_data_next = cm_ut_data_next,
 	.cmo_ag_next   = cm_ut_ag_next,
-//	.cmo_complete  = cm_ut_complete,
 	.cmo_fini      = cm_ut_fini
 };
 
diff --git a/sns/cm/cm.c b/sns/cm/cm.c
index fcfefaa..075c5d8 100644
--- a/sns/cm/cm.c
+++ b/sns/cm/cm.c
@@ -58,9 +58,8 @@
   - @subpage SNSCMDLD-fspec
   - @ref SNSCMDLD-lspec
      - @ref SNSCMDLD-lspec-cm-setup
-     - @ref SNSCMDLD-lspec-cm-ready
+     - @ref SNSCMDLD-lspec-cm-prepare
      - @ref SNSCMDLD-lspec-cm-start
-        - @ref SNSCMDLD-lspec-cm-start-cp-create
      - @ref SNSCMDLD-lspec-cm-data-next
      - @ref SNSCMDLD-lspec-cm-sliding-window
      - @ref SNSCMDLD-lspec-cm-stop
@@ -160,9 +159,8 @@
   <hr>
   @section SNSCMDLD-lspec Logical specification
   - @ref SNSCMDLD-lspec-cm-setup
-  - @ref SNSCMDLD-lspec-cm-ready
+  - @ref SNSCMDLD-lspec-cm-prepare
   - @ref SNSCMDLD-lspec-cm-start
-     - @ref SNSCMDLD-lspec-cm-start-cp-create
   - @ref SNSCMDLD-lspec-cm-data-next
   - @ref SNSCMDLD-lspec-cm-sliding-window
   - @ref SNSCMDLD-lspec-cm-stop
@@ -193,36 +191,12 @@
   device/s. In re-balance operation the data from the spare units of the repaired
   parity groups is copied to the new device using the layout.
 
-  @subsection SNSCMDLD-lspec-cm-ready Copy machine ready
-  After creating proxies representing the remote replicas, sns copy machine
-  calculates its local sliding window (i.e lo and hi aggregation group
-  identifiers). Then for each remote replica the READY FOPs are allocated and
-  initialised with the calculated sliding window. The sns copy machine then
-  broadcasts these READY FOPs to every remote replica using the rpc connection
-  in the corresponding m0_cm_proxy. A READY FOP is a one-way fop and thus do not
-  have a reply associated with it. Once every replica receives READY FOPs from
-  all the corresponding remote replicas, the sns copy machine is ready to start
-  the repair/re-balance operation.
-  @see struct m0_cm_ready
-  @see cm_ready_post()
+  @subsection SNSCMDLD-lspec-cm-prepare Copy machine ready
+  Allocates buffers for incoming and outgoing sns copy machine buffer pools.
 
   @subsection SNSCMDLD-lspec-cm-start Copy machine startup
-  The SNS specific start routine provisions the buffer pools, viz. m0_sns_cm::
-  sc_ibp m0_sns_cm::sc_obp with SNS_INCOMING_BUF_NR and SNS_OUTGOING_BUF_NR
-  number of buffers.
-  @note Buffer provisioning operation can block.
-
-  @subsubsection SNSCMDLD-lspec-cm-start-cp-create Copy packet create
-  Once the buffer pools are provisioned, if resources permit (e.g. if there
-  exist a free buffer in the outgoing buffer pool), Copy machine creates and
-  initialises copy packets. Then by invoking m0_cm_data_next(), a copy packet is
-  assigned an aggregation group and stobid. Once the copy packet is ready, an
-  empty buffer is fetched from the outgoing buffer pool and attached to the copy
-  packet (m0_cm_cp::c_data). Copy packet FOM (m0_cm_cp::c_fom) is then submitted
-  to the request handler for further processing. Copy packets are created during
-  startup and during finalisation of another completed copy packet.
-
-  @see @ref CPDLD "Copy Packet DLD" for more details.
+  Starts and initialises sns copy machine data iterator.
+  @see m0_sns_cm_iter_start()
 
   @subsection SNSCMDLD-lspec-cm-data-next Copy machine data iterator
   SNS copy machine implements an iterator to efficiently select next data to
@@ -596,7 +570,7 @@ M0_INTERNAL int m0_sns_cm_pm_event_post(struct m0_sns_cm *scm,
 	return rc;
 }
 
-M0_INTERNAL int m0_sns_cm_ready(struct m0_cm *cm)
+M0_INTERNAL int m0_sns_cm_prepare(struct m0_cm *cm)
 {
 	struct m0_sns_cm      *scm = cm2sns(cm);
 	int                    bufs_nr;
diff --git a/sns/cm/cm.h b/sns/cm/cm.h
index 36e2865..8839b8e 100644
--- a/sns/cm/cm.h
+++ b/sns/cm/cm.h
@@ -216,7 +216,7 @@ M0_INTERNAL struct m0_sns_cm *cm2sns(struct m0_cm *cm);
 
 M0_INTERNAL struct m0_cm_cp *m0_sns_cm_cp_alloc(struct m0_cm *cm);
 
-M0_INTERNAL int m0_sns_cm_ready(struct m0_cm *cm);
+M0_INTERNAL int m0_sns_cm_prepare(struct m0_cm *cm);
 
 M0_INTERNAL int m0_sns_cm_stop(struct m0_cm *cm);
 
diff --git a/sns/cm/iter.c b/sns/cm/iter.c
index c978d76..7cd8d2c 100644
--- a/sns/cm/iter.c
+++ b/sns/cm/iter.c
@@ -323,13 +323,11 @@ static bool __has_incoming(struct m0_sns_cm *scm, struct m0_pdclust_layout *pl,
 
 	M0_PRE(scm != NULL && pl != NULL && gfid != NULL);
 
-	if (scm->sc_base.cm_proxy_nr > 0) {
-		m0_sns_cm_ag_agid_setup(gfid, group, &agid);
-		M0_LOG(M0_DEBUG, "agid [%lu] [%lu] [%lu] [%lu]",
-		       agid.ai_hi.u_hi, agid.ai_hi.u_lo,
-		       agid.ai_lo.u_hi, agid.ai_lo.u_lo);
-		return  m0_sns_cm_ag_is_relevant(scm, pl, &agid);
-	}
+	m0_sns_cm_ag_agid_setup(gfid, group, &agid);
+	M0_LOG(M0_DEBUG, "agid [%lu] [%lu] [%lu] [%lu]",
+	       agid.ai_hi.u_hi, agid.ai_hi.u_lo,
+	       agid.ai_lo.u_hi, agid.ai_lo.u_lo);
+	return  m0_sns_cm_ag_is_relevant(scm, pl, &agid);
 
 	return false;
 }
@@ -422,7 +420,6 @@ static int __group_next(struct m0_sns_cm_iter *it)
 	gfid = &sfc->sfc_gob_fid;
 	pl = sfc->sfc_pdlayout;
 	for (group = sa->sa_group; group < sfc->sfc_groups_nr; ++group) {
-		M0_LOG(M0_FATAL, "group: [%lu]", group);
 		M0_ADDB_POST(&m0_addb_gmc, &m0_addb_rt_sns_repair_progress,
 			     M0_ADDB_CTX_VEC(&m0_sns_mod_addb_ctx),
 			     scm->sc_it.si_total_files, group + 1,
diff --git a/sns/cm/rebalance/cm.c b/sns/cm/rebalance/cm.c
index b1f47da..09d7399 100644
--- a/sns/cm/rebalance/cm.c
+++ b/sns/cm/rebalance/cm.c
@@ -62,7 +62,7 @@ static struct m0_cm_cp *rebalance_cm_cp_alloc(struct m0_cm *cm)
 	return &scp->sc_base;
 }
 
-static int rebalance_cm_ready(struct m0_cm *cm)
+static int rebalance_cm_prepare(struct m0_cm *cm)
 {
 	struct m0_sns_cm      *scm = cm2sns(cm);
 	int                    rc;
@@ -75,7 +75,7 @@ static int rebalance_cm_ready(struct m0_cm *cm)
 	if (rc != 0)
 		return rc;
 	scm->sc_helpers = &rebalance_helpers;
-	return m0_sns_cm_ready(cm);
+	return m0_sns_cm_prepare(cm);
 }
 
 static int rebalance_cm_stop(struct m0_cm *cm)
@@ -119,7 +119,7 @@ static bool rebalance_cm_has_space(struct m0_cm *cm,
 /** Copy machine operations. */
 const struct m0_cm_ops sns_rebalance_ops = {
 	.cmo_setup               = m0_sns_cm_setup,
-	.cmo_ready               = rebalance_cm_ready,
+	.cmo_prepare             = rebalance_cm_prepare,
 	.cmo_start               = m0_sns_cm_start,
 	.cmo_ag_alloc            = m0_sns_cm_rebalance_ag_alloc,
 	.cmo_cp_alloc            = rebalance_cm_cp_alloc,
diff --git a/sns/cm/repair/cm.c b/sns/cm/repair/cm.c
index 9f61346..5e1db7d 100644
--- a/sns/cm/repair/cm.c
+++ b/sns/cm/repair/cm.c
@@ -59,7 +59,7 @@ static struct m0_cm_cp *repair_cm_cp_alloc(struct m0_cm *cm)
 	return cp;
 }
 
-static int repair_cm_ready(struct m0_cm *cm)
+static int repair_cm_prepare(struct m0_cm *cm)
 {
 	struct m0_sns_cm *scm = cm2sns(cm);
 	int               rc;
@@ -72,7 +72,7 @@ static int repair_cm_ready(struct m0_cm *cm)
 	if (rc != 0)
 		return rc;
 	scm->sc_helpers = &repair_helpers;
-	return m0_sns_cm_ready(cm);
+	return m0_sns_cm_prepare(cm);
 }
 
 static int repair_cm_stop(struct m0_cm *cm)
@@ -146,7 +146,7 @@ m0_sns_cm_fid_repair_done(struct m0_fid *gfid, struct m0_reqh *reqh)
 /** Copy machine operations. */
 const struct m0_cm_ops sns_repair_ops = {
 	.cmo_setup               = m0_sns_cm_setup,
-	.cmo_ready               = repair_cm_ready,
+	.cmo_prepare             = repair_cm_prepare,
 	.cmo_start               = m0_sns_cm_start,
 	.cmo_ag_alloc            = m0_sns_cm_repair_ag_alloc,
 	.cmo_cp_alloc            = repair_cm_cp_alloc,
diff --git a/sns/cm/repair/ut/cm.c b/sns/cm/repair/ut/cm.c
index 302efcb..06e4cd4 100644
--- a/sns/cm/repair/ut/cm.c
+++ b/sns/cm/repair/ut/cm.c
@@ -120,7 +120,7 @@ static void iter_setup(enum m0_sns_cm_op op, uint64_t fd)
 	scm = cm2sns(cm);
 	pool_mach_transit(cm->cm_pm, fd, M0_PNDS_FAILED);
 	scm->sc_op = op;
-	rc = cm->cm_ops->cmo_ready(cm);
+	rc = cm->cm_ops->cmo_prepare(cm);
 	M0_UT_ASSERT(rc == 0);
 	rc = cm->cm_ops->cmo_start(cm);
 	M0_UT_ASSERT(rc == 0);
@@ -311,8 +311,8 @@ static void iter_stop(uint64_t pool_width, uint64_t nr_files, uint64_t fd)
 	int rc;
 
 	m0_cm_lock(cm);
-	ag_destroy();
 	/* Destroy previously created aggregation groups manually. */
+	ag_destroy();
 	rc = cm->cm_ops->cmo_stop(cm);
 	M0_UT_ASSERT(rc == 0);
 	m0_cm_unlock(cm);
diff --git a/sns/cm/repair/ut/net.c b/sns/cm/repair/ut/net.c
index c232135..9c8ee86 100644
--- a/sns/cm/repair/ut/net.c
+++ b/sns/cm/repair/ut/net.c
@@ -472,7 +472,9 @@ static void receiver_stob_create()
 
 static void cm_ready(struct m0_cm *cm)
 {
+	m0_cm_prepare(cm);
 	m0_cm_lock(cm);
+	//m0_cm_sw_update_start(cm);
 	m0_cm_state_set(cm, M0_CMS_READY);
 	m0_cm_unlock(cm);
 }
@@ -507,11 +509,10 @@ static void receiver_init()
 	//sns_cm_ut_dev_state(ps->pst_devices_array[DEV_ID].pd_state,
 	//                    M0_PNDS_FAILED);
 
-	cm->cm_ops->cmo_ready(cm);
+	//cm->cm_ops->cmo_prepare(cm);
 	m0_cm_unlock(cm);
 	cm_ready(cm);
         M0_UT_ASSERT(m0_cm_start(cm) == 0);
-
         while (m0_fom_domain_is_idle(&s0_reqh->rh_fom_dom) ||
                         !m0_cm_cp_pump_is_complete(&cm->cm_cp_pump))
                 usleep(200);
@@ -568,19 +569,26 @@ static void sender_cm_fini(struct m0_cm *cm)
 {
 }
 
-/*
-static void sender_cm_complete(struct m0_cm *cm)
+static int sender_cm_prepare(struct m0_cm *cm)
+{
+	return 0;
+}
+
+static int sender_cm_ag_next(struct m0_cm *cm,
+			     const struct m0_cm_ag_id id_curr,
+			     struct m0_cm_ag_id *id_next)
 {
+	return -ENOENT;
 }
-*/
 
 static const struct m0_cm_ops sender_cm_ops = {
         .cmo_setup     = sender_cm_setup,
+	.cmo_prepare   = sender_cm_prepare,
         .cmo_start     = sender_cm_start,
         .cmo_stop      = sender_cm_stop,
         .cmo_cp_alloc  = sender_cm_cp_alloc,
         .cmo_data_next = sender_cm_data_next,
-        //.cmo_complete  = sender_cm_complete,
+	.cmo_ag_next   = sender_cm_ag_next,
         .cmo_fini      = sender_cm_fini
 };
 
diff --git a/sns/cm/trigger_fom.c b/sns/cm/trigger_fom.c
index 6164489..eba718e 100644
--- a/sns/cm/trigger_fom.c
+++ b/sns/cm/trigger_fom.c
@@ -68,15 +68,15 @@ static const struct m0_fom_type_ops trigger_fom_type_ops = {
 };
 
 enum trigger_phases {
-	TPH_READY_SETUP = M0_FOPH_NR + 1,
+	TPH_PREPARE = M0_FOPH_NR + 1,
 	TPH_READY,
 	TPH_START_WAIT,
 	TPH_STOP_WAIT
 };
 
 static struct m0_sm_state_descr trigger_phases[] = {
-	[TPH_READY_SETUP] = {
-		.sd_name      = "Send ready fops",
+	[TPH_PREPARE] = {
+		.sd_name      = "Initialise local sliding window",
 		.sd_allowed   = M0_BITS(TPH_READY)
 	},
 	[TPH_READY] = {
@@ -193,17 +193,18 @@ static int trigger_fom_tick(struct m0_fom *fom)
 		scm = cm2sns(cm);
 		M0_LOG(M0_DEBUG, "start state = %d", m0_fom_phase(fom));
 		switch(m0_fom_phase(fom)) {
-			case TPH_READY_SETUP:
+			case TPH_PREPARE:
 				treq = m0_fop_data(fom->fo_fop);
 				scm->sc_op             = treq->op;
 				m0_mutex_lock(&cm->cm_wait_mutex);
 				m0_fom_wait_on(fom, &cm->cm_ready_wait,
 					       &fom->fo_cb);
 				m0_mutex_unlock(&cm->cm_wait_mutex);
-				rc = m0_cm_ready(cm);
+				rc = m0_cm_prepare(cm);
 				M0_ASSERT(rc == 0);
 				rc = M0_FSO_WAIT;
 				m0_fom_phase_set(fom, TPH_READY);
+				M0_LOG(M0_DEBUG, "got trigger: prepare done");
 				break;
 			case TPH_READY:
 				m0_mutex_lock(&cm->cm_wait_mutex);
-- 
1.8.3.2

