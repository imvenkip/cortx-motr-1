From bae6cd9557a4adb176fca52f0d522348c01bbc3d Mon Sep 17 00:00:00 2001
From: Amit Jambure <Amit_Jambure@xyratex.com>
Date: Thu, 23 May 2013 14:46:19 +0530
Subject: [PATCH 4/9] rpc: Fold m0_rpc_rcv_conn_establish in its caller.

---
 rpc/conn.c          | 27 +++------------------------
 rpc/conn.h          |  3 ---
 rpc/conn_internal.h | 15 ++-------------
 rpc/session.h       |  3 ---
 rpc/session_foms.c  | 27 ++++++++++++---------------
 rpc/slot_internal.h |  3 ---
 6 files changed, 17 insertions(+), 61 deletions(-)

diff --git a/rpc/conn.c b/rpc/conn.c
index 1aa9ef6..330180d 100644
--- a/rpc/conn.c
+++ b/rpc/conn.c
@@ -86,6 +86,7 @@ static struct m0_sm_state_descr conn_states[] = {
 		.sd_flags     = M0_SDF_INITIAL,
 		.sd_name      = "Initialised",
 		.sd_allowed   = M0_BITS(M0_RPC_CONN_CONNECTING,
+					M0_RPC_CONN_ACTIVE, /* rcvr side only */
 					M0_RPC_CONN_FINALISED,
 					M0_RPC_CONN_FAILED)
 	},
@@ -97,6 +98,7 @@ static struct m0_sm_state_descr conn_states[] = {
 	[M0_RPC_CONN_ACTIVE] = {
 		.sd_name      = "Active",
 		.sd_allowed   = M0_BITS(M0_RPC_CONN_TERMINATING,
+					M0_RPC_CONN_TERMINATED, /* rcvr side */
 					M0_RPC_CONN_FAILED)
 	},
 	[M0_RPC_CONN_TERMINATING] = {
@@ -125,7 +127,7 @@ static const struct m0_sm_conf conn_conf = {
 	.scf_state     = conn_states
 };
 
-static void conn_state_set(struct m0_rpc_conn *conn, int state)
+M0_INTERNAL void conn_state_set(struct m0_rpc_conn *conn, int state)
 {
 	M0_PRE(conn != NULL);
 
@@ -869,29 +871,6 @@ M0_INTERNAL void m0_rpc_conn_terminate_reply_received(struct m0_rpc_item *item)
 	M0_POST(m0_rpc_machine_is_locked(machine));
 }
 
-M0_INTERNAL int m0_rpc_rcv_conn_establish(struct m0_rpc_conn *conn)
-{
-	struct m0_rpc_machine *machine;
-
-	M0_ENTRY("conn: %p", conn);
-	M0_PRE(conn != NULL);
-
-	machine = conn->c_rpc_machine;
-	M0_PRE(m0_rpc_machine_is_locked(machine));
-	M0_PRE(machine->rm_dom != NULL);
-
-	M0_ASSERT(m0_rpc_conn_invariant(conn));
-	M0_ASSERT(conn_state(conn) == M0_RPC_CONN_INITIALISED &&
-		  m0_rpc_conn_is_rcv(conn));
-
-	conn_state_set(conn, M0_RPC_CONN_CONNECTING);
-	conn->c_sender_id = m0_rpc_id_generate();
-	conn_state_set(conn, M0_RPC_CONN_ACTIVE);
-
-	M0_POST(m0_rpc_machine_is_locked(machine));
-	M0_RETURN(0);
-}
-
 M0_INTERNAL void m0_rpc_conn_cleanup_all_sessions(struct m0_rpc_conn *conn)
 {
 	struct m0_rpc_session *session;
diff --git a/rpc/conn.h b/rpc/conn.h
index eb88488..ad5096d 100644
--- a/rpc/conn.h
+++ b/rpc/conn.h
@@ -282,9 +282,6 @@ struct m0_rpc_conn {
 	/** Identifies destination of this connection. */
 	struct m0_rpc_chan       *c_rpcchan;
 
-	/** cob representing the connection */
-	struct m0_cob            *c_cob;
-
 	/** RPC connection state machine
 	    @see m0_rpc_conn_state, conn_conf
 	 */
diff --git a/rpc/conn_internal.h b/rpc/conn_internal.h
index a9a68fa..efc757e 100644
--- a/rpc/conn_internal.h
+++ b/rpc/conn_internal.h
@@ -49,6 +49,8 @@ static inline int conn_state(const struct m0_rpc_conn *conn)
 	return conn->c_sm.sm_state;
 }
 
+M0_INTERNAL void conn_state_set(struct m0_rpc_conn *conn, int state);
+
 /**
    Searches in conn->c_sessions list, a session object whose session id
    matches with given @session_id.
@@ -108,19 +110,6 @@ M0_INTERNAL int m0_rpc_rcv_conn_init(struct m0_rpc_conn *conn,
 				     struct m0_rpc_machine *machine,
 				     const struct m0_uint128 *uuid);
 /**
-   Creates a receiver end of conn.
-
-   @pre conn_state(conn) == M0_RPC_CONN_INITIALISED
-   @post ergo(result == 0, conn_state(conn) == M0_RPC_CONN_ACTIVE &&
-			   conn->c_sender_id != SENDER_ID_INVALID &&
-			   m0_list_contains(&machine->rm_incoming_conns,
-					    &conn->c_link)
-   @post ergo(result != 0, conn_state(conn) == M0_RPC_CONN_FAILED)
-   @post ergo(result == 0, conn_state(conn) == M0_RPC_CONN_ACTIVE)
- */
-M0_INTERNAL int m0_rpc_rcv_conn_establish(struct m0_rpc_conn *conn);
-
-/**
    Terminates receiver end of rpc connection.
 
    Terminates alive sessions if any.
diff --git a/rpc/session.h b/rpc/session.h
index fa59ee5..97a4868 100644
--- a/rpc/session.h
+++ b/rpc/session.h
@@ -464,9 +464,6 @@ struct m0_rpc_session {
 	 */
 	struct m0_tlink		  s_link;
 
-	/** Cob representing this session in persistent state */
-	struct m0_cob            *s_cob;
-
 	/** Number of items that needs to be sent or their reply is
 	    not yet received. i.e. count of items in {FUTURE, IN_PROGRESS}
 	    state in all slots belonging to this session.
diff --git a/rpc/session_foms.c b/rpc/session_foms.c
index 5c5fffd..6d722bf 100644
--- a/rpc/session_foms.c
+++ b/rpc/session_foms.c
@@ -233,21 +233,18 @@ M0_INTERNAL int m0_rpc_fom_conn_establish_tick(struct m0_fom *fom)
 			m0_rpc_conn_fini_locked(conn);
 			goto out;
 		}
-		rc = m0_rpc_rcv_conn_establish(conn);
-		if (rc == 0) {
-			/* See [1] at the end of function */
-			slot = session0->s_slot_table[ow_sref->osr_slot_id];
-			M0_ASSERT(slot != NULL);
-			item->ri_session = session0;
-			m0_rpc_slot_item_add_internal(slot, item);
-			/* See [2] at the end of function */
-			ow_sref->osr_sender_id = SENDER_ID_INVALID;
-			M0_ASSERT(conn_state(conn) == M0_RPC_CONN_ACTIVE);
-			M0_ASSERT(m0_rpc_conn_invariant(conn));
-		} else {
-			/* conn establish failed */
-			m0_rpc_conn_fini_locked(conn);
-		}
+		conn->c_sender_id = m0_rpc_id_generate();
+		conn_state_set(conn, M0_RPC_CONN_ACTIVE);
+
+		/* See [1] at the end of function */
+		slot = session0->s_slot_table[ow_sref->osr_slot_id];
+		M0_ASSERT(slot != NULL);
+		item->ri_session = session0;
+		m0_rpc_slot_item_add_internal(slot, item);
+		/* See [2] at the end of function */
+		ow_sref->osr_sender_id = SENDER_ID_INVALID;
+		M0_ASSERT(conn_state(conn) == M0_RPC_CONN_ACTIVE);
+		M0_ASSERT(m0_rpc_conn_invariant(conn));
 	}
 	m0_rpc_machine_unlock(machine);
 
diff --git a/rpc/slot_internal.h b/rpc/slot_internal.h
index 3df69f1..d22e832 100644
--- a/rpc/slot_internal.h
+++ b/rpc/slot_internal.h
@@ -152,9 +152,6 @@ struct m0_rpc_slot {
 	/** identifier of slot, unique within the session */
 	uint32_t                      sl_slot_id;
 
-	/** Cob representing this slot in persistent state */
-	struct m0_cob                *sl_cob;
-
 	/** list anchor to put in m0_rpc_session::s_ready_slots */
 	struct m0_tlink		      sl_link;
 
-- 
1.8.3.2

