From 0c1f1c2377603461f3e0b9aab7e97c0428ab4b3f Mon Sep 17 00:00:00 2001
From: Madhavrao Vemuri <madhav_vemuri@xyratex.com>
Date: Tue, 24 Sep 2013 17:07:34 +0530
Subject: [PATCH 1/7] stob_write_credit() is added for adding credit for AD
 write operations.

stob_object_find() is added to locate stob object.

stob type for bulk server ut is changed to AD.
AD update credit operation is called before undo operation.
---
 ioservice/io_foms.c          | 97 ++++++++++++++++++++++++++++++++++++--------
 ioservice/ut/bulkio_common.c |  2 +-
 ioservice/ut/bulkio_ut.c     |  4 +-
 3 files changed, 83 insertions(+), 20 deletions(-)

diff --git a/ioservice/io_foms.c b/ioservice/io_foms.c
index 7783f35..e6f2795 100644
--- a/ioservice/io_foms.c
+++ b/ioservice/io_foms.c
@@ -988,6 +988,39 @@ static inline m0_bcount_t io_descs_count(const struct m0_io_descs *io_descs)
 }
 
 /**
+ * Locates a storage object.
+ */
+static int stob_object_find(struct m0_fom *fom)
+{
+	int			 result;
+	struct m0_io_fom_cob_rw	*fom_obj;
+	struct m0_stob_id	 stobid;
+	struct m0_fop_cob_rw	*rwfop;
+	struct m0_stob_domain	*fom_stdom;
+
+	M0_PRE(fom != NULL);
+        M0_PRE(m0_is_io_fop(fom->fo_fop));
+
+	fom_obj = container_of(fom, struct m0_io_fom_cob_rw, fcrw_gen);
+	M0_ASSERT(m0_io_fom_cob_rw_invariant(fom_obj));
+
+	rwfop = io_rw_get(fom->fo_fop);
+
+	io_fom_cob_rw_fid2stob_map(&rwfop->crw_fid, &stobid);
+	fom_stdom = m0_cs_stob_domain_find(m0_fom_reqh(fom), &stobid);
+	if (fom_stdom == NULL)
+		return -EINVAL;
+
+	result = m0_stob_find(fom_stdom, &stobid, &fom_obj->fcrw_stob);
+	if (result != 0)
+		return result;
+	result = m0_stob_locate(fom_obj->fcrw_stob);
+	if (result != 0)
+		m0_stob_put(fom_obj->fcrw_stob);
+	return result;
+}
+
+/**
  * Create and initiate I/O FOM and return generic struct m0_fom
  * Find the corresponding fom_type and associate it with m0_fom.
  * Associate fop with fom type.
@@ -1485,12 +1518,9 @@ static int io_launch(struct m0_fom *fom)
 	uint32_t		 bshift;
 	struct m0_fop		*fop;
 	struct m0_io_fom_cob_rw	*fom_obj;
-	struct m0_stob_id	 stobid;
 	struct m0_net_buffer    *nb;
 	struct m0_fop_cob_rw	*rwfop;
 	struct m0_io_indexvec    wire_ivec;
-	struct m0_stob_domain	*fom_stdom;
-	struct m0_reqh          *reqh;
 
 	M0_PRE(fom != NULL);
         M0_PRE(m0_is_io_fop(fom->fo_fop));
@@ -1505,22 +1535,10 @@ static int io_launch(struct m0_fom *fom)
 	fop = fom->fo_fop;
 	rwfop = io_rw_get(fop);
 
-	io_fom_cob_rw_fid2stob_map(&rwfop->crw_fid, &stobid);
-	reqh = m0_fom_reqh(fom);
-	fom_stdom = m0_cs_stob_domain_find(reqh, &stobid);
-	if (fom_stdom == NULL) {
-		rc = -EINVAL;
-		goto cleanup;
-	}
-
-	rc = m0_stob_find(fom_stdom, &stobid, &fom_obj->fcrw_stob);
+	rc = stob_object_find(fom);
 	if (rc != 0)
 		goto cleanup;
 
-	rc = m0_stob_locate(fom_obj->fcrw_stob);
-	if (rc != 0)
-		goto cleanup_st;
-
 	/*
 	   Since the upper layer IO block size could differ with IO block size
 	   of storage object, the block alignment and mapping is necessary.
@@ -1631,7 +1649,6 @@ static int io_launch(struct m0_fom *fom)
 		return M0_FSO_WAIT;
 	}
 
-cleanup_st:
 	m0_stob_put(fom_obj->fcrw_stob);
 cleanup:
 	M0_ASSERT(rc != 0);
@@ -1703,6 +1720,46 @@ static int io_finish(struct m0_fom *fom)
         return M0_FSO_AGAIN;
 }
 
+static void stob_write_credit(struct m0_fom *fom)
+{
+	int			 rc;
+	uint32_t		 bshift;
+	struct m0_io_fom_cob_rw	*fom_obj;
+	struct m0_fop_cob_rw	*rwfop;
+	struct m0_io_indexvec    wire_ivec;
+	struct m0_stob_domain	*fom_stdom;
+	m0_bcount_t		 count;
+	int			 i;
+	int			 j;
+
+	M0_PRE(fom != NULL);
+        M0_PRE(m0_is_io_fop(fom->fo_fop));
+
+	fom_obj = container_of(fom, struct m0_io_fom_cob_rw, fcrw_gen);
+	M0_ASSERT(m0_io_fom_cob_rw_invariant(fom_obj));
+
+	rwfop = io_rw_get(fom->fo_fop);
+
+	rc = stob_object_find(fom);
+	M0_ASSERT(rc == 0);
+	fom_stdom = m0_cs_stob_domain_find(m0_fom_reqh(fom),
+			&fom_obj->fcrw_stob->so_id);
+	M0_ASSERT(fom_stdom != NULL);
+	/*
+	   Since the upper layer IO block size could differ with IO block size
+	   of storage object, the block alignment and mapping is necessary.
+	 */
+	bshift = fom_obj->fcrw_stob->so_op->sop_block_shift(fom_obj->fcrw_stob);
+
+	for (i = 0; i < rwfop->crw_ivecs.cis_nr; i++) {
+		wire_ivec = rwfop->crw_ivecs.cis_ivecs[i];
+		for (j = 0; j < wire_ivec.ci_nr; j++)
+			count += wire_ivec.ci_iosegs[j].ci_count >> bshift;
+	}
+	m0_stob_write_credit(fom_stdom, count, &fom->fo_tx.tx_betx_cred);
+}
+
+
 /**
  * State Transition function for I/O operation that executes
  * on data server.
@@ -1733,8 +1790,12 @@ static int m0_io_fom_cob_rw_tick(struct m0_fom *fom)
 	poolmach = m0_ios_poolmach_get(reqh);
 
 	/* first handle generic phase */
-        if (m0_fom_phase(fom) < M0_FOPH_NR)
+        if (m0_fom_phase(fom) < M0_FOPH_NR) {
+			if (m0_is_write_fop(fom->fo_fop) &&
+			    m0_fom_phase(fom) == M0_FOPH_TXN_OPEN)
+				stob_write_credit(fom);
                 return m0_fom_tick_generic(fom);
+	}
 
 	st = m0_is_read_fop(fom->fo_fop) ?
 		io_fom_read_st[m0_fom_phase(fom)] :
diff --git a/ioservice/ut/bulkio_common.c b/ioservice/ut/bulkio_common.c
index 1e2f27a..b6d2806 100644
--- a/ioservice/ut/bulkio_common.c
+++ b/ioservice/ut/bulkio_common.c
@@ -89,7 +89,7 @@ int bulkio_server_start(struct bulkio_params *bp, const char *saddr)
 	strcpy(server_args[2], "-p");
 	strcpy(server_args[3], "-T");
 /** @todo Needs to be changed back to AD, once io works on AD stob type. */
-	strcpy(server_args[4], "Linux");
+	strcpy(server_args[4], "AD");
 	strcpy(server_args[5], "-D");
 	strcpy(server_args[6], S_DBFILE);
 	strcpy(server_args[7], "-S");
diff --git a/ioservice/ut/bulkio_ut.c b/ioservice/ut/bulkio_ut.c
index 4d72e01..e62a55b 100644
--- a/ioservice/ut/bulkio_ut.c
+++ b/ioservice/ut/bulkio_ut.c
@@ -1373,6 +1373,8 @@ static void bulkio_server_write_fol_rec_undo_verify(void)
 		} else {
 			m0_sm_group_lock(grp);
 			m0_dtx_init(&dtx, reqh->rh_beseg->bs_domain, grp);
+			dec_part->rp_ops->rpo_undo_credit(dec_part,
+				&dtx.tx_betx_cred);
 			m0_dtx_open_sync(&dtx);
 			result = dec_part->rp_ops->rpo_undo(dec_part,
 							    &dtx.tx_betx);
@@ -1386,7 +1388,7 @@ static void bulkio_server_write_fol_rec_undo_verify(void)
 
 	/* Read that data from file and compare it with data "b". */
 	/** @todo Add this after AD stob type is enabled. */
-	/*	io_single_fop_submit(M0_IOSERVICE_READV_OPCODE); */
+	io_single_fop_submit(M0_IOSERVICE_READV_OPCODE);
 	io_fops_destroy(bp);
 }
 
-- 
1.8.3.2

