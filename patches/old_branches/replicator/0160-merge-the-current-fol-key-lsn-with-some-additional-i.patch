From 5c6ee64c5659ff3788e86f0ff61e8dce7888a599 Mon Sep 17 00:00:00 2001
From: Andrew Perepechko <andrew_perepechko@xyratex.com>
Date: Wed, 13 Jul 2011 20:25:07 +0400
Subject: [PATCH 160/177] merge the current fol key (lsn) with some additional
 information (recno)

---
 dtm/verno.c  |  4 ++--
 fol/fol.c    | 28 ++++++++++++++--------------
 fol/fol.h    |  7 ++++++-
 fol/ut/fol.c | 16 ++++++++--------
 fop/fop.c    |  3 ++-
 fop/fop.h    |  1 +
 6 files changed, 33 insertions(+), 26 deletions(-)

diff --git a/dtm/verno.c b/dtm/verno.c
index 3b411d0..8b588dd 100644
--- a/dtm/verno.c
+++ b/dtm/verno.c
@@ -81,11 +81,11 @@ int c2_verno_cmp_invariant(const struct c2_verno *vn0,
 void c2_verno_inc(struct c2_verno *unit, struct c2_fol_rec *rec, uint32_t index)
 {
 	C2_PRE(index < rec->fr_desc.rd_header.rh_obj_nr);
-	C2_PRE(c2_lsn_is_valid(rec->fr_desc.rd_lsn));
+	C2_PRE(c2_lsn_is_valid(rec->fr_desc.rd_key.fk_lsn));
 
 	rec->fr_desc.rd_ref[index].or_before_ver = *unit;
 	unit->vn_vc++;
-	unit->vn_lsn = rec->fr_desc.rd_lsn;
+	unit->vn_lsn = rec->fr_desc.rd_key.fk_lsn;
 
 	C2_POST(unit->vn_vc != 0); /* overflow */
 	C2_POST(c2_verno_cmp(&rec->fr_desc.rd_ref[index].or_before_ver,
diff --git a/fol/fol.c b/fol/fol.c
index cb8d9e9..9979a0f 100644
--- a/fol/fol.c
+++ b/fol/fol.c
@@ -88,7 +88,7 @@ static int lsn_cmp(struct c2_table *table, const void *key0, const void *key1)
 static const struct c2_table_ops fol_ops = {
 	.to = {
 		[TO_KEY] = {
-			.max_size = sizeof(c2_lsn_t)
+			.max_size = sizeof(struct c2_fol_key)
 		},
 		[TO_REC] = {
 			.max_size = ~0
@@ -179,7 +179,7 @@ static int rec_open(struct c2_fol_rec *rec)
    Initializes fields in @rec.
 
    Note, that key buffer in the cursor is initialized to point to
-   rec->fr_desc.rd_lsn. As a result, the cursor's key follows lsn changes
+   rec->fr_desc.rd_key.fk_lsn. As a result, the cursor's key follows lsn changes
    automagically.
 
    @see rec_fini()
@@ -191,8 +191,8 @@ static int rec_init(struct c2_fol_rec *rec, struct c2_db_tx *tx)
 	C2_PRE(rec->fr_fol != NULL);
 
 	pair = &rec->fr_pair;
-	c2_db_pair_setup(pair, &rec->fr_fol->f_table, &rec->fr_desc.rd_lsn,
-			 sizeof rec->fr_desc.rd_lsn, NULL, 0);
+	c2_db_pair_setup(pair, &rec->fr_fol->f_table, &rec->fr_desc.rd_key,
+			 sizeof rec->fr_desc.rd_key, NULL, 0);
 	return c2_db_cursor_init(&rec->fr_ptr, &rec->fr_fol->f_table, tx);
 }
 
@@ -264,7 +264,7 @@ int c2_fol_init(struct c2_fol *fol, struct c2_dbenv *env)
 				d->rd_header.rh_refcount = 1;
 				d->rd_header.rh_opcode = anchor_type.rt_opcode;
 				d->rd_type = &anchor_type;
-				d->rd_lsn = C2_LSN_ANCHOR;
+				d->rd_key.fk_lsn = C2_LSN_ANCHOR; /* fk_recno is 0 */
 				fol->f_lsn = C2_LSN_ANCHOR + 1;
 				result = c2_fol_add(fol, &tx, d);
 			} else if (result == 0) {
@@ -272,7 +272,7 @@ int c2_fol_init(struct c2_fol *fol, struct c2_dbenv *env)
 							   &r.fr_pair);
 				if (result == 0) {
 					result = rec_open_internal(&r);
-					fol->f_lsn = lsn_inc(d->rd_lsn);
+					fol->f_lsn = lsn_inc(d->rd_key.fk_lsn);
 				}
 				c2_fol_rec_fini(&r);
 			}
@@ -346,7 +346,7 @@ int c2_fol_add(struct c2_fol *fol, struct c2_db_tx *tx,
 	int           result;
 	struct c2_buf buf;
 
-	C2_PRE(c2_lsn_is_valid(rec->rd_lsn));
+	C2_PRE(c2_lsn_is_valid(rec->rd_key.fk_lsn));
 
 	result = c2_fol_rec_pack(rec, &buf);
 	if (result == 0) {
@@ -362,10 +362,10 @@ int c2_fol_add_buf(struct c2_fol *fol, struct c2_db_tx *tx,
 {
 	struct c2_db_pair pair;
 
-	C2_PRE(c2_lsn_is_valid(drec->rd_lsn));
+	C2_PRE(c2_lsn_is_valid(drec->rd_key.fk_lsn));
 
 	c2_db_pair_setup(&pair, &fol->f_table,
-			 &drec->rd_lsn, sizeof drec->rd_lsn,
+			 &drec->rd_key, sizeof drec->rd_key,
 			 buf->b_addr, buf->b_nob);
 	return c2_table_insert(tx, &pair);
 }
@@ -382,7 +382,7 @@ bool c2_fol_rec_invariant(const struct c2_fol_rec_desc *drec)
 	uint32_t i;
 	uint32_t j;
 
-	if (!c2_lsn_is_valid(drec->rd_lsn))
+	if (!c2_lsn_is_valid(drec->rd_key.fk_lsn))
 		return false;
 	for (i = 0; i < drec->rd_header.rh_obj_nr; ++i) {
 		struct c2_fol_obj_ref *ref;
@@ -393,7 +393,7 @@ bool c2_fol_rec_invariant(const struct c2_fol_rec_desc *drec)
 		if (!c2_lsn_is_valid(ref->or_before_ver.vn_lsn) &&
 		    ref->or_before_ver.vn_lsn != C2_LSN_NONE)
 			return false;
-		if (drec->rd_lsn <= ref->or_before_ver.vn_lsn)
+		if (drec->rd_key.fk_lsn <= ref->or_before_ver.vn_lsn)
 			return false;
 		for (j = 0; j < i; ++j) {
 			if (c2_fid_eq(&ref->or_fid, &drec->rd_ref[j].or_fid))
@@ -432,13 +432,13 @@ int c2_fol_rec_lookup(struct c2_fol *fol, struct c2_db_tx *tx, c2_lsn_t lsn,
 	out->fr_fol = fol;
 	result = rec_init(out, tx);
 	if (result == 0) {
-		out->fr_desc.rd_lsn = lsn;
+		out->fr_desc.rd_key.fk_lsn = lsn;
 		result = c2_db_cursor_get(&out->fr_ptr, &out->fr_pair);
 		if (result == 0) {
 			struct c2_fol_rec_header *h;
 
 			h = out->fr_pair.dp_rec.db_buf.b_addr;
-			if (out->fr_desc.rd_lsn == lsn && h->rh_refcount > 0)
+			if (out->fr_desc.rd_key.fk_lsn == lsn && h->rh_refcount > 0)
 				result = rec_open(out);
 			else
 				result = -ENOENT;
@@ -446,7 +446,7 @@ int c2_fol_rec_lookup(struct c2_fol *fol, struct c2_db_tx *tx, c2_lsn_t lsn,
 		if (result != 0)
 			rec_fini(out);
 	}
-	C2_POST(ergo(result == 0, out->fr_desc.rd_lsn == lsn));
+	C2_POST(ergo(result == 0, out->fr_desc.rd_key.fk_lsn == lsn));
 	C2_POST(ergo(result == 0, out->fr_desc.rd_header.rh_refcount > 0));
 	C2_POST(ergo(result == 0, c2_fol_rec_invariant(&out->fr_desc)));
 	return result;
diff --git a/fol/fol.h b/fol/fol.h
index e5efe47..c551ac0 100644
--- a/fol/fol.h
+++ b/fol/fol.h
@@ -220,6 +220,11 @@ C2_BASSERT(C2_IS_8ALIGNED(sizeof(struct c2_fol_rec_header)));
 C2_BASSERT(C2_IS_8ALIGNED(sizeof(struct c2_fol_obj_ref)));
 C2_BASSERT(C2_IS_8ALIGNED(sizeof(struct c2_fol_update_ref)));
 
+struct c2_fol_key {
+        c2_lsn_t fk_lsn;
+        uint64_t fk_recno;
+};
+
 /**
    In-memory representation of a fol record.
 
@@ -237,7 +242,7 @@ C2_BASSERT(C2_IS_8ALIGNED(sizeof(struct c2_fol_update_ref)));
  */
 struct c2_fol_rec_desc {
 	/** record log sequence number */
-	c2_lsn_t                      rd_lsn;
+	struct c2_fol_key             rd_key;
 	struct c2_fol_rec_header      rd_header;
 	const struct c2_fol_rec_type *rd_type;
 	/** pointer for use by fol record type. */
diff --git a/fol/ut/fol.c b/fol/ut/fol.c
index d01e02e..965dd9b 100644
--- a/fol/ut/fol.c
+++ b/fol/ut/fol.c
@@ -102,7 +102,7 @@ static void test_add(void)
 	d->rd_type = &ut_fol_type;
 	h->rh_refcount = 1;
 
-	d->rd_lsn = c2_fol_lsn_allocate(&fol);
+	d->rd_key.fk_lsn = c2_fol_lsn_allocate(&fol);
 	result = c2_fol_add(&fol, &tx, d);
 	C2_ASSERT(result == 0);
 
@@ -116,20 +116,20 @@ static void test_lookup(void)
 {
 	struct c2_fol_rec dup;
 
-	d->rd_lsn = c2_fol_lsn_allocate(&fol);
+	d->rd_key.fk_lsn = c2_fol_lsn_allocate(&fol);
 	result = c2_fol_add(&fol, &tx, d);
 	C2_ASSERT(result == 0);
 
-	result = c2_fol_rec_lookup(&fol, &tx, d->rd_lsn, &dup);
+	result = c2_fol_rec_lookup(&fol, &tx, d->rd_key.fk_lsn, &dup);
 	C2_ASSERT(result == 0);
 
-	C2_ASSERT(dup.fr_desc.rd_lsn == d->rd_lsn);
+	C2_ASSERT(dup.fr_desc.rd_key.fk_lsn == d->rd_key.fk_lsn);
 	C2_ASSERT(memcmp(&d->rd_header, 
 			 &dup.fr_desc.rd_header, sizeof d->rd_header) == 0);
 
 	c2_fol_rec_fini(&dup);
 
-	result = c2_fol_rec_lookup(&fol, &tx, lsn_inc(d->rd_lsn), &dup);
+	result = c2_fol_rec_lookup(&fol, &tx, lsn_inc(d->rd_key.fk_lsn), &dup);
 	C2_ASSERT(result == -ENOENT);
 }
 
@@ -194,10 +194,10 @@ static void checkpoint()
 
 static void ub_insert(int i)
 {
-	d->rd_lsn = c2_fol_lsn_allocate(&fol);
+	d->rd_key.fk_lsn = c2_fol_lsn_allocate(&fol);
 	result = c2_fol_add(&fol, &tx, d);
 	C2_ASSERT(result == 0);
-	last = d->rd_lsn;
+	last = d->rd_key.fk_lsn;
 	if (i%1000 == 0)
 		checkpoint();
 }
@@ -218,7 +218,7 @@ static void ub_lookup(int i)
 
 static void ub_insert_buf(int i)
 {
-	d->rd_lsn = c2_fol_lsn_allocate(&fol);
+	d->rd_key.fk_lsn = c2_fol_lsn_allocate(&fol);
 	result = c2_fol_add_buf(&fol, &tx, d, &buf);
 	C2_ASSERT(result == 0);
 	if (i%1000 == 0)
diff --git a/fop/fop.c b/fop/fop.c
index 067e9f5..72ffc69 100644
--- a/fop/fop.c
+++ b/fop/fop.c
@@ -330,7 +330,8 @@ int c2_fop_fol_rec_add(struct c2_fop *fop, struct c2_fol *fol,
 	C2_SET0(&desc);
 	desc.rd_type               = &fop->f_type->ft_rec_type;
 	desc.rd_type_private       = fop;
-	desc.rd_lsn                = c2_fol_lsn_allocate(fol);
+	desc.rd_key.fk_lsn         = c2_fol_lsn_allocate(fol);
+        desc.rd_key.fk_recno       = fop->f_recno;
 	/* XXX an arbitrary number for now */
 	desc.rd_header.rh_refcount = 1;
 	/*
diff --git a/fop/fop.h b/fop/fop.h
index 808b488..bcf8529 100644
--- a/fop/fop.h
+++ b/fop/fop.h
@@ -175,6 +175,7 @@ struct c2_fop_data {
 /** fop. */
 struct c2_fop {
 	struct c2_fop_type *f_type;
+        uint64_t            f_recno;
 	/** Pointer to the data where fop is serialised or will be
 	    serialised. */
 	struct c2_fop_data  f_data;
-- 
1.8.3.2

