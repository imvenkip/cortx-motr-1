From 99ea298868e504a9ed8ef0fbf18dfe6bee854481 Mon Sep 17 00:00:00 2001
From: Yuriy Umanets <yuriy_umanets@xyratex.com>
Date: Wed, 22 Feb 2012 02:41:53 +0400
Subject: [PATCH 172/177] - more merge changes

---
 c2t1fs/Makefile.in    | 419 ++++++++++++++++++++++++++++++++++++++++++++------
 cob/cob.c             | 183 ----------------------
 colibri/Makefile.am   |  12 --
 colibri/init.c        |  15 +-
 configure.ac          |   1 -
 fid/fid.c             |   3 -
 fop/fom.h             |  30 ----
 fop/fop.h             |  21 +--
 ioservice/io_foms.c   | 220 --------------------------
 ioservice/io_foms.h   |  18 ---
 ioservice/io_fops.c   |  17 --
 ioservice/io_fops.h   |   8 -
 iostore/iostore.h     |   5 -
 lib/Makefile.am       |  19 ---
 lib/ut/main.c         |   4 -
 reqh/reqh.c           |  78 +---------
 stob/ut/io_fop_init.c |  14 --
 stob/ut/server.c      | 393 ----------------------------------------------
 utils/Makefile.am     |   6 +-
 utils/ut_main.c       |  32 +---
 20 files changed, 377 insertions(+), 1121 deletions(-)

diff --git a/c2t1fs/Makefile.in b/c2t1fs/Makefile.in
index 1f76bbf..83d924d 100644
--- a/c2t1fs/Makefile.in
+++ b/c2t1fs/Makefile.in
@@ -1,48 +1,371 @@
-C2T1FS_SRCDIR = @SRCDIR@/c2t1fs
-FOPDIR = @SRCDIR@/fop
-ADDBDIR = @SRCDIR@/addb
-STOBDIR = @SRCDIR@/stob/ut
-GALOISDIR = @SRCDIR@/../galois
-IOSERVICEDIR = @SRCDIR@/ioservice
-
-obj-m := c2t1fs.o c2t1fs_loop.o 
-c2t1fs-y := main.o io_k.o io_fops_k.o io_foms.o io_fops.o io_fop_init.o addb_store.o addb_k.o
-
-EXTRA_CFLAGS = -DHAVE_CONFIG_H -I@SRCDIR@ @KCFLAGS@
-
-prepare: io_k.h io_k.c addb_k.c addb_k.h
-	sh $(FOPDIR)/fop2c -k $(STOBDIR)/io.ff 
-
-	ln -sf $(STOBDIR)/io_fop_init.c .
-	ln -sf $(ADDBDIR)/addb_store.c .
-	ln -sf $(GALOISDIR)/galois.h @SRCDIR@/sns
-	ln -sf $(IOSERVICEDIR)/io_fops_k.h
-	ln -sf $(IOSERVICEDIR)/io_fops_k.c
-	ln -sf $(IOSERVICEDIR)/io_fops.h
-	ln -sf $(IOSERVICEDIR)/io_foms.h
-	ln -sf $(IOSERVICEDIR)/io_foms.c
-	ln -sf $(IOSERVICEDIR)/io_fops.c
-
-io_k.h io_k.c: $(STOBDIR)/io.ff
-	$(FOPDIR)/fop2c -k $(STOBDIR)/io.ff
-
-addb_k.h addb_k.c: $(ADDBDIR)/addb.ff
-	$(FOPDIR)/fop2c -k $(ADDBDIR)/addb.ff
-
-install modules_install:
-	$(MAKE) INSTALL_MOD_DIR=kernel/fs/c2t1fs -C @LINUX_OBJ@ M=`pwd` modules_install
-
-uninstall:
-	rm -fr @LINUX_MOD@/kernel/fs/c2t1fs
-
-distclean clean:
-	$(MAKE) -C @LINUX_OBJ@ M=`pwd` clean;
-	rm -fr Module.symvers io_k.[ch] io_fop_init.c
-	rm -fr @SRCDIR@/sns/galois.h
-	rm -rf io_fops_k.* io_fops.* io_foms.*
-	rm -rf fop_types.h
-
-distdir:
-	cp $(C2T1FS_SRCDIR)/Makefile.in $(C2T1FS_SRCDIR)/c2t1fs.h \
-$(C2T1FS_SRCDIR)/c2t1fs_loop.c $(C2T1FS_SRCDIR)/main.c \
-@top_builddir@/@PACKAGE@-@VERSION@/c2t1fs
+# Makefile.in generated by automake 1.11.1 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005, 2006, 2007, 2008, 2009  Free Software Foundation,
+# Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkglibexecdir = $(libexecdir)/@PACKAGE@
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+subdir = c2t1fs
+DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/m4/libtool.m4 \
+	$(top_srcdir)/m4/ltoptions.m4 $(top_srcdir)/m4/ltsugar.m4 \
+	$(top_srcdir)/m4/ltversion.m4 $(top_srcdir)/m4/lt~obsolete.m4 \
+	$(top_srcdir)/configure.ac
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(install_sh) -d
+CONFIG_HEADER = $(top_builddir)/config.h
+CONFIG_CLEAN_FILES =
+CONFIG_CLEAN_VPATH_FILES =
+SOURCES =
+DIST_SOURCES =
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+AIO_LIBS = @AIO_LIBS@
+AMTAR = @AMTAR@
+AR = @AR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CUNIT_LIBS = @CUNIT_LIBS@
+CYGPATH_W = @CYGPATH_W@
+DB_LIBS = @DB_LIBS@
+DB_SRC = @DB_SRC@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+DSYMUTIL = @DSYMUTIL@
+DUMPBIN = @DUMPBIN@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+ENABLE_COVERAGE = @ENABLE_COVERAGE@
+EXEEXT = @EXEEXT@
+FGREP = @FGREP@
+GALOIS_LIBS = @GALOIS_LIBS@
+GALOIS_SRC = @GALOIS_SRC@
+GALOIS_SYMVERS = @GALOIS_SYMVERS@
+GREP = @GREP@
+INSTALL = @INSTALL@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+KCFLAGS = @KCFLAGS@
+K_ENABLE_COVERAGE = @K_ENABLE_COVERAGE@
+LD = @LD@
+LDFLAGS = @LDFLAGS@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LINUX_MOD = @LINUX_MOD@
+LINUX_OBJ = @LINUX_OBJ@
+LIPO = @LIPO@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+LT_RELEASE = @LT_RELEASE@
+MAKEINFO = @MAKEINFO@
+MKDIR_P = @MKDIR_P@
+NM = @NM@
+NMEDIT = @NMEDIT@
+NM_B = @NM_B@
+NSL_LIBS = @NSL_LIBS@
+OBJDUMP = @OBJDUMP@
+OBJEXT = @OBJEXT@
+OTOOL = @OTOOL@
+OTOOL64 = @OTOOL64@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+PTHREAD_LIBS = @PTHREAD_LIBS@
+RANLIB = @RANLIB@
+SED = @SED@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+SRCDIR = @SRCDIR@
+STRIP = @STRIP@
+VERSION = @VERSION@
+YAML_LIBS = @YAML_LIBS@
+abs_builddir = @abs_builddir@
+abs_srcdir = @abs_srcdir@
+abs_top_builddir = @abs_top_builddir@
+abs_top_srcdir = @abs_top_srcdir@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_DUMPBIN = @ac_ct_DUMPBIN@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+builddir = @builddir@
+datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+dvidir = @dvidir@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localedir = @localedir@
+localstatedir = @localstatedir@
+lt_ECHO = @lt_ECHO@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+srcdir = @srcdir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
+top_build_prefix = @top_build_prefix@
+top_builddir = @top_builddir@
+top_srcdir = @top_srcdir@
+EXTRA_DIST = linux_kernel/main.c \
+                   linux_kernel/c2t1fs.h \
+                   linux_kernel/c2t1fs_loop.c
+
+all: all-am
+
+.SUFFIXES:
+$(srcdir)/Makefile.in:  $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
+	        && { if test -f $@; then exit 0; else break; fi; }; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --gnu c2t1fs/Makefile'; \
+	$(am__cd) $(top_srcdir) && \
+	  $(AUTOMAKE) --gnu c2t1fs/Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure:  $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4):  $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(am__aclocal_m4_deps):
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+tags: TAGS
+TAGS:
+
+ctags: CTAGS
+CTAGS:
+
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	list='$(DISTFILES)'; \
+	  dist_files=`for file in $$list; do echo $$file; done | \
+	  sed -e "s|^$$srcdirstrip/||;t" \
+	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
+	case $$dist_files in \
+	  */*) $(MKDIR_P) `echo "$$dist_files" | \
+			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
+			   sort -u` ;; \
+	esac; \
+	for file in $$dist_files; do \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  if test -d $$d/$$file; then \
+	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
+	    if test -d "$(distdir)/$$file"; then \
+	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
+	    fi; \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -fpR $(srcdir)/$$file "$(distdir)$$dir" || exit 1; \
+	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
+	    fi; \
+	    cp -fpR $$d/$$file "$(distdir)$$dir" || exit 1; \
+	  else \
+	    test -f "$(distdir)/$$file" \
+	    || cp -p $$d/$$file "$(distdir)/$$file" \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile
+installdirs:
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+	-test . = "$(srcdir)" || test -z "$(CONFIG_CLEAN_VPATH_FILES)" || rm -f $(CONFIG_CLEAN_VPATH_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic clean-libtool mostlyclean-am
+
+distclean: distclean-am
+	-rm -f Makefile
+distclean-am: clean-am distclean-generic
+
+dvi: dvi-am
+
+dvi-am:
+
+html: html-am
+
+html-am:
+
+info: info-am
+
+info-am:
+
+install-data-am:
+
+install-dvi: install-dvi-am
+
+install-dvi-am:
+
+install-exec-am:
+
+install-html: install-html-am
+
+install-html-am:
+
+install-info: install-info-am
+
+install-info-am:
+
+install-man:
+
+install-pdf: install-pdf-am
+
+install-pdf-am:
+
+install-ps: install-ps-am
+
+install-ps-am:
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-generic mostlyclean-libtool
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am:
+
+.MAKE: install-am install-strip
+
+.PHONY: all all-am check check-am clean clean-generic clean-libtool \
+	distclean distclean-generic distclean-libtool distdir dvi \
+	dvi-am html html-am info info-am install install-am \
+	install-data install-data-am install-dvi install-dvi-am \
+	install-exec install-exec-am install-html install-html-am \
+	install-info install-info-am install-man install-pdf \
+	install-pdf-am install-ps install-ps-am install-strip \
+	installcheck installcheck-am installdirs maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-generic \
+	mostlyclean-libtool pdf pdf-am ps ps-am uninstall uninstall-am
+
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff --git a/cob/cob.c b/cob/cob.c
index a5acec5..f70f59d 100644
--- a/cob/cob.c
+++ b/cob/cob.c
@@ -207,7 +207,6 @@ static const struct c2_table_ops cob_oi_ops = {
 
 static int fb_cmp(struct c2_table *table, const void *key0, const void *key1)
 {
-<<<<<<< HEAD
 	const struct c2_cob_fabkey *cok0 = key0;
 	const struct c2_cob_fabkey *cok1 = key1;
 
@@ -217,16 +216,6 @@ static int fb_cmp(struct c2_table *table, const void *key0, const void *key1)
         return c2_fid_cmp(&cok0->cfb_fid, &cok1->cfb_fid);
 }
 
-=======
-	const struct c2_stob_id	*id0 = key0;
-	const struct c2_stob_id *id1 = key1;
-
-	C2_PRE(c2_stob_id_is_set(id0));
-	C2_PRE(c2_stob_id_is_set(id1));
-
-	return c2_stob_id_cmp(id0, id1);
-}
->>>>>>> master
 static const struct c2_table_ops cob_fab_ops = {
 	.to = {
 		[TO_KEY] = {
@@ -237,7 +226,6 @@ static const struct c2_table_ops cob_fab_ops = {
 		}
 	},
 	.key_cmp = fb_cmp
-<<<<<<< HEAD
 };
 
 /**
@@ -260,8 +248,6 @@ static const struct c2_table_ops cob_omg_ops = {
 		}
 	},
 	.key_cmp = omg_cmp
-=======
->>>>>>> master
 };
 
 static char *cob_dom_id_make(char *buf, const struct c2_cob_domain_id *id,
@@ -799,7 +785,6 @@ int c2_cob_create(struct c2_cob_domain *dom,
                   struct c2_cob       **out,
                   struct c2_db_tx      *tx)
 {
-<<<<<<< HEAD
         struct c2_db_pair     pair;
         struct c2_cob_omgkey  omgkey;
         struct c2_cob_fabkey  fabkey;
@@ -809,12 +794,6 @@ int c2_cob_create(struct c2_cob_domain *dom,
 
         C2_PRE(out != NULL);
         *out = NULL;
-=======
-        struct c2_cob      *cob = NULL;
-        struct c2_cob_oikey oikey;
-        struct c2_db_pair   pair;
-	int rc;
->>>>>>> master
 
         C2_PRE(nskey != NULL);
         C2_PRE(nsrec != NULL);
@@ -936,19 +915,11 @@ int c2_cob_create(struct c2_cob_domain *dom,
 
         cob->co_valid |= CA_NSKEY_FREE | CA_FABREC;
         *out = cob;
-<<<<<<< HEAD
 out:
         C2_ADDB_ADD(&cob->co_dom->cd_addb, &cob_addb_loc, 
                     c2_addb_func_fail, "cob_create", rc);
         if (rc)
                 c2_cob_put(cob);
-=======
-	return 0;
-
-out_free:
-        c2_cob_put(cob);
-        C2_ADDB_ADD(&dom->cd_addb, &cob_addb_loc, cob_eexist, rc);
->>>>>>> master
         return rc;
 }
 
@@ -1238,7 +1209,6 @@ int c2_cob_update_name(struct c2_cob        *cob,
                          NULL, 0);
         rc = c2_table_delete(tx, &pair);
         c2_db_pair_release(&pair);
-<<<<<<< HEAD
         c2_db_pair_fini(&pair);
         if (rc)
                 goto out;
@@ -1253,18 +1223,6 @@ int c2_cob_update_name(struct c2_cob        *cob,
         c2_db_pair_fini(&pair);
         if (rc)
                 goto out;
-=======
-	c2_db_pair_fini(&pair);
-
-        /* Remove from the fileattr_basic table */
-        c2_db_pair_setup(&pair, &cob->co_dom->cd_fileattr_basic,
-			 &cob->co_stobid, sizeof cob->co_stobid,
-			 NULL, 0);
-        /* ignore errors; it's a dangling table entry but causes no harm */
-        c2_table_delete(tx, &pair);
-        c2_db_pair_release(&pair);
-	c2_db_pair_fini(&pair);
->>>>>>> master
 
         /*
          * Update key to new one.
@@ -1284,147 +1242,6 @@ out:
         return rc;
 }
 
-<<<<<<< HEAD
-=======
-int c2_cob_update(struct c2_cob		*cob,
-		  struct c2_cob_nsrec	*nsrec,
-		  struct c2_cob_fabrec	*fabrec,
-		  struct c2_db_tx	*tx)
-{
-	struct c2_db_pair	pair;
-	int			rc;
-
-	C2_PRE(c2_cob_is_valid(cob));
-	C2_PRE(cob->co_valid & CA_NSKEY);
-
-	if (nsrec != NULL) {
-		cob->co_nsrec = *nsrec;
-		cob->co_valid |= CA_NSREC;
-
-		c2_db_pair_setup(&pair, &cob->co_dom->cd_namespace,
-				cob->co_nskey, c2_cob_nskey_size(cob->co_nskey),
-				&cob->co_nsrec, sizeof cob->co_nsrec);
-
-		rc = c2_table_update(tx, &pair);
-
-		c2_db_pair_release(&pair);
-		c2_db_pair_fini(&pair);
-
-		if (rc)
-			goto out;
-	}
-
-	if (fabrec != NULL) {
-		cob->co_fabrec = *fabrec;
-		cob->co_valid |= CA_FABREC;
-
-		c2_db_pair_setup(&pair, &cob->co_dom->cd_fileattr_basic,
-			&cob->co_nsrec.cnr_stobid, sizeof cob->co_nsrec.cnr_stobid,
-			&cob->co_fabrec, sizeof cob->co_fabrec);
-
-		rc = c2_table_update(tx, &pair);
-
-		c2_db_pair_release(&pair);
-		c2_db_pair_fini(&pair);
-	}
-
-out:
-	C2_ADDB_ADD(&cob->co_dom->cd_addb, &cob_addb_loc,
-			c2_addb_func_fail, "cob_update", rc);
-	return rc;
-}
-
-void c2_cob_nskey_make(struct c2_cob_nskey **keyh, uint64_t hi, uint64_t lo,
-			const char *name)
-{
-        struct c2_cob_nskey *key;
-
-        key = c2_alloc(sizeof(*key) + strlen(name));
-	if (key == NULL)
-		return;
-
-        key->cnk_pfid.si_bits.u_hi = hi;
-        key->cnk_pfid.si_bits.u_lo = lo;
-        memcpy(c2_bitstring_buf_get(&key->cnk_name), name, strlen(name));
-        c2_bitstring_len_set(&key->cnk_name, strlen(name));
-        *keyh = key;
-}
-
-void c2_cob_namespace_traverse(struct c2_cob_domain	*dom)
-{
-	struct c2_db_cursor	cursor;
-	struct c2_db_pair	pair;
-	struct c2_cob_nskey	*nskey;
-	struct c2_cob_nsrec	nsrec;
-	struct c2_db_tx		tx;
-	int			rc;
-
-	nskey = c2_alloc(sizeof (*nskey) + 20);
-
-	c2_db_tx_init(&tx, dom->cd_dbenv, 0);
-	rc = c2_db_cursor_init(&cursor, &dom->cd_namespace, &tx);
-	if (rc != 0) {
-		printf("ns_traverse: error during cursor init %d\n", rc);
-		return;
-	}
-
-	printf("=============== Namespace Table ================\n");
-	c2_db_pair_setup(&pair, &dom->cd_namespace, nskey, sizeof (*nskey) + 20,
-				&nsrec, sizeof nsrec);
-	while ((rc = c2_db_cursor_next(&cursor, &pair)) == 0) {
-#ifndef __KERNEL__
-		printf("[%lx:%lx:%s] -> [%lx:%lx]\n", nskey->cnk_pfid.si_bits.u_hi,
-				nskey->cnk_pfid.si_bits.u_lo,
-				nskey->cnk_name.b_data,
-				nsrec.cnr_stobid.si_bits.u_hi,
-				nsrec.cnr_stobid.si_bits.u_lo);
-#endif
-	}
-
-	printf("=================================================\n");
-	c2_db_cursor_fini(&cursor);
-	c2_db_pair_release(&pair);
-	c2_db_pair_fini(&pair);
-	c2_db_tx_commit(&tx);
-
-}
-
-void c2_cob_fb_traverse(struct c2_cob_domain	*dom)
-{
-	struct c2_db_cursor	cursor;
-	struct c2_db_pair	pair;
-	struct c2_stob_id	key;
-	struct c2_cob_fabrec	rec;
-	struct c2_db_tx		tx;
-	int			rc;
-
-	c2_db_tx_init(&tx, dom->cd_dbenv, 0);
-	rc = c2_db_cursor_init(&cursor, &dom->cd_fileattr_basic, &tx);
-	if (rc != 0) {
-		printf("fb_traverse: error during cursor init %d\n", rc);
-		return;
-	}
-
-	printf("=============== FB Table ================\n");
-	c2_db_pair_setup(&pair, &dom->cd_fileattr_basic, &key, sizeof key,
-				&rec, sizeof rec);
-	while ((rc = c2_db_cursor_next(&cursor, &pair)) == 0) {
-#ifndef __KERNEL__
-		printf("[%lx:%lx] -> [%lu:%lu]\n", key.si_bits.u_hi,
-				key.si_bits.u_lo,
-				rec.cfb_version.vn_lsn,
-				rec.cfb_version.vn_vc);
-#endif
-	}
-
-	printf("=================================================\n");
-	c2_db_cursor_fini(&cursor);
-	c2_db_pair_release(&pair);
-	c2_db_pair_fini(&pair);
-	c2_db_tx_commit(&tx);
-
-}
->>>>>>> master
 /** @} end group cob */
 
 /*
diff --git a/colibri/Makefile.am b/colibri/Makefile.am
index f111774..e270fd8 100644
--- a/colibri/Makefile.am
+++ b/colibri/Makefile.am
@@ -9,16 +9,9 @@ colibri_setup_LDADD       = $(top_builddir)/colibri/libcolibri.la
 colibri_setup_CFLAGS      = $(AM_CFLAGS)
 
 lib_LTLIBRARIES           = libcolibri.la
-<<<<<<< HEAD
-
-libcolibri_la_SOURCES     = init.h init.c
-libcolibri_la_LDFLAGS     = -release @LT_RELEASE@ -pthread 
-libcolibri_la_LIBADD      = @AIO_LIBS@ @PTHREAD_LIBS@ @DB_LIBS@ @GALOIS_LIBS@ @CUNIT_LIBS@ \
-=======
 libcolibri_la_SOURCES     = init.h init.c colibri_setup.c colibri_setup.h
 libcolibri_la_LDFLAGS     = -release @LT_RELEASE@ -pthread
 libcolibri_la_LIBADD      = @AIO_LIBS@ @PTHREAD_LIBS@ @DB_LIBS@ @GALOIS_LIBS@ @YAML_LIBS@ @CUNIT_LIBS@ \
->>>>>>> master
                             -lm -lncurses \
                             $(top_builddir)/addb/libcolibri-addb.la \
                             $(top_builddir)/balloc/libcolibri-balloc.la \
@@ -45,19 +38,14 @@ libcolibri_la_LIBADD      = @AIO_LIBS@ @PTHREAD_LIBS@ @DB_LIBS@ @GALOIS_LIBS@ @Y
                             $(top_builddir)/sns/libcolibri-sns.la \
                             $(top_builddir)/stob/libcolibri-stob.la \
                             $(top_builddir)/udb/libcolibri-udb.la \
-<<<<<<< HEAD
                             $(top_builddir)/site/libcolibri-site.la \
                             $(top_builddir)/ioservice/libcolibri-ioservice.la \
                             $(top_builddir)/mdservice/libcolibri-mdservice.la \
                             $(top_builddir)/mdstore/libcolibri-mdstore.la \
                             $(top_builddir)/iostore/libcolibri-iostore.la \
-			    $(top_builddir)/xdr/libcolibri-xdr.la
-#                            $(top_builddir)/rpc/libcolibri-rpc.la
-=======
                             $(top_builddir)/ut/libcolibri-ut.la \
                             $(top_builddir)/ioservice/libcolibri-ioservice.la \
                             $(top_builddir)/rpc/libcolibri-rpc.la \
                             $(top_builddir)/xcode/libcolibri-xcode.la \
                             $(top_builddir)/xcode/ff2c/libcolibri-xcode-ff2c.la \
                             $(top_builddir)/yaml2db/libcolibri-yaml2db.la
->>>>>>> master
diff --git a/colibri/init.c b/colibri/init.c
index 4fd73de..320f947 100644
--- a/colibri/init.c
+++ b/colibri/init.c
@@ -44,15 +44,11 @@
 #include "stob/linux.h"
 #include "stob/ad.h"
 #include "fol/fol.h"
-<<<<<<< HEAD
-#include "desim/sim.h"
 #include "site/site.h"
 #include "cob/cob.h"
 #include "mdservice/md_fops.h"
-=======
 #include "reqh/reqh.h"
 #include "lib/timer.h"
->>>>>>> master
 
 #include "colibri/init.h"
 
@@ -101,14 +97,6 @@ struct init_fini_call subsystem[] = {
 	{ &c2_sunrpc_fop_init, &c2_sunrpc_fop_fini, "bulk/sunrpc" },
 #ifndef __KERNEL__
 	{ &usunrpc_init,     &usunrpc_fini,     "user/sunrpc"},
-<<<<<<< HEAD
-	{ &linux_stobs_init, &linux_stobs_fini, "linux-stob" },
-	{ &ad_stobs_init,    &ad_stobs_fini,    "ad-stob" },
-	{ &c2_fols_init,     &c2_fols_fini,     "fol" },
-	{ &sim_global_init,  &sim_global_fini,  "desim" },
-	{ &c2_sites_init,    &c2_sites_fini,    "sites" },
-	{ &c2_md_fop_init,   &c2_md_fop_fini,   "mdservice"}
-=======
 #else
 	{ &c2_ksunrpc_init,  &c2_ksunrpc_fini,     "ksunrpc"},
 	{ &c2t1fs_init_module, &c2t1fs_cleanup_module, "c2t1fs" },
@@ -117,8 +105,9 @@ struct init_fini_call subsystem[] = {
 	{ &c2_ad_stobs_init,    &c2_ad_stobs_fini,    "ad-stob" },
 	{ &sim_global_init,  &sim_global_fini,  "desim" },
 	{ &c2_ioservice_fop_init, &c2_ioservice_fop_fini, "ioservice" },
+	{ &c2_sites_init,    &c2_sites_fini,    "sites" },
+	{ &c2_md_fop_init,   &c2_md_fop_fini,   "mdservice"}
 	{ &c2_reqhs_init,    &c2_reqhs_fini,    "reqh" }
->>>>>>> master
 };
 
 static void fini_nr(int i)
diff --git a/configure.ac b/configure.ac
index 150e1ea..2f99633 100644
--- a/configure.ac
+++ b/configure.ac
@@ -691,7 +691,6 @@ AC_CONFIG_FILES([
                  mdstore/Makefile
                  mdstore/ut/Makefile
                  iostore/Makefile
-		 ioservice/Makefile
 		 mdservice/Makefile
                  udb/Makefile
                  udb/ut/Makefile
diff --git a/fid/fid.c b/fid/fid.c
index 997e048..eeea910 100644
--- a/fid/fid.c
+++ b/fid/fid.c
@@ -38,7 +38,6 @@ bool c2_fid_is_valid(const struct c2_fid *fid)
 	return true;
 }
 
-<<<<<<< HEAD
 bool c2_fid_is_set(const struct c2_fid *fid)
 {
 	static const struct c2_fid zero = {
@@ -47,8 +46,6 @@ bool c2_fid_is_set(const struct c2_fid *fid)
 	};
 	return !c2_fid_eq(fid, &zero);
 }
-=======
->>>>>>> master
 
 bool c2_fid_eq(const struct c2_fid *fid0, const struct c2_fid *fid1)
 {
diff --git a/fop/fom.h b/fop/fom.h
index 2cde45f..fa2d61f 100644
--- a/fop/fom.h
+++ b/fop/fom.h
@@ -281,16 +281,6 @@ bool c2_fom_domain_invariant(const struct c2_fom_domain *dom);
    @see c2_fom_invariant()
 */
 struct c2_fom {
-<<<<<<< HEAD
-	enum c2_fom_state        fo_state;
-	int 			 fo_phase;
-	struct c2_fom_locality  *fo_loc;
-	struct c2_fom_type      *fo_type;
-	const struct c2_fom_ops *fo_ops;
-	struct c2_clink          fo_clink;
-	/** FOP ctx prepared by reqh. It has we need to handle fop. */
-	struct c2_fop_ctx	*fo_fop_ctx;
-=======
 	/**
 	   State a fom can be in at any given instance throughout its
 	   life cycle.This feild is protected by c2_fom_locality:fl_lock
@@ -327,7 +317,6 @@ struct c2_fom {
 
 	/** Result of fom execution, -errno on failure */
 	int32_t			 fo_rc;
->>>>>>> master
 };
 
 /**
@@ -432,24 +421,6 @@ struct c2_fom_type_ops {
 
 /** Fom operations vector. */
 struct c2_fom_ops {
-<<<<<<< HEAD
-        /**
-           Execute fom fini actions. Free memory if needed.
-        */
-        void (*fo_fini)(struct c2_fom *fom);
-        /**
-           Execute pre-state actions. Operation sanity checks
-           may be done this way in reqh and errors handled before
-           calling fo_state()
-        */
-        int  (*fo_sanity)(struct c2_fom *fom);
-        /**
-            Execute the next state transition.
-
-            Returns value of enum c2_fom_state_outcome or error code.
-        */
-        int  (*fo_state)(struct c2_fom *fom);
-=======
 	/** Finalise this fom. */
 	void (*fo_fini)(struct c2_fom *fom);
 	/**
@@ -467,7 +438,6 @@ struct c2_fom_ops {
 	    array.
 	 */
 	size_t  (*fo_home_locality) (const struct c2_fom *fom);
->>>>>>> master
 };
 
 /** Handler thread. */
diff --git a/fop/fop.h b/fop/fop.h
index 5575689..bf1341e 100644
--- a/fop/fop.h
+++ b/fop/fop.h
@@ -115,21 +115,6 @@ struct c2_fop_ctx {
 	int                 fc_retval;
 };
 
-<<<<<<< HEAD
-/** fop type operations. */
-struct c2_fop_type_ops {
-	/** Create a fom that will carry out operation described by the fop. */
-	int (*fto_fom_init)(struct c2_fop *fop, struct c2_fop_ctx *ctx,
-	                    struct c2_fom **fom);
-	/** XXX temporary entry point for threaded fop execution. */
-	int (*fto_execute) (struct c2_fop *fop, struct c2_fop_ctx *ctx);
-	/** fol record type operations for this fop type, or NULL is standard
-	    operations are to be used. */
-	const struct c2_fol_rec_type_ops  *fto_rec_ops;
-};
-
-=======
->>>>>>> master
 /**
     fop storage.
 
@@ -141,12 +126,8 @@ struct c2_fop_data {
 
 /** fop. */
 struct c2_fop {
-<<<<<<< HEAD
-	struct c2_fop_type *f_type;
-        uint64_t            f_recno;
-=======
 	struct c2_fop_type	*f_type;
->>>>>>> master
+        uint64_t                 f_recno;
 	/** Pointer to the data where fop is serialised or will be
 	    serialised. */
 	struct c2_fop_data	 f_data;
diff --git a/ioservice/io_foms.c b/ioservice/io_foms.c
index 692cd93..2f8711d 100644
--- a/ioservice/io_foms.c
+++ b/ioservice/io_foms.c
@@ -30,14 +30,11 @@
 #include "lib/errno.h"
 #include "lib/memory.h"
 #include "net/net.h"
-<<<<<<< HEAD
 #include "site/site.h"
 #include "iostore/iostore.h"
-=======
 #include "fid/fid.h"
 #include "reqh/reqh.h"
 #include "stob/linux.h"
->>>>>>> master
 
 #ifdef __KERNEL__
 #include "ioservice/linux_kernel/io_fops_k.h"
@@ -50,39 +47,6 @@
  * @{
  */
 
-<<<<<<< HEAD
-#ifndef __KERNEL__
-
-/** Generic ops object for c2_fop_cob_writev */
-static struct c2_fom_ops c2_io_fom_write_ops = {
-	.fo_fini  = c2_io_fom_cob_rwv_fini,
-	.fo_state = c2_io_fom_cob_rwv_state
-};
-
-/** Generic ops object for c2_fop_cob_readv */
-static struct c2_fom_ops c2_io_fom_read_ops = {
-	.fo_fini  = c2_io_fom_cob_rwv_fini,
-	.fo_state = c2_io_fom_cob_rwv_state
-};
-
-/** Generic ops object for readv and writev reply FOPs */
-struct c2_fom_ops c2_io_fom_rwv_rep = {0,};
-
-/** FOM type specific functions for readv FOP. */
-static const struct c2_fom_type_ops c2_io_cob_readv_type_ops = {0,};
-
-/** FOM type specific functions for writev FOP. */
-static const struct c2_fom_type_ops c2_io_cob_writev_type_ops = {0,};
-
-/** Readv specific FOM type operations vector. */
-static struct c2_fom_type c2_io_fom_cob_readv_mopt = {
-	.ft_ops = &c2_io_cob_readv_type_ops,
-};
-
-/** Writev specific FOM type operations vector. */
-static struct c2_fom_type c2_io_fom_cob_writev_mopt = {
-	.ft_ops = &c2_io_cob_writev_type_ops,
-=======
 extern bool is_read(const struct c2_fop *fop);
 extern bool is_write(const struct c2_fop *fop);
 extern bool is_io(const struct c2_fop *fop);
@@ -106,7 +70,6 @@ static const struct c2_fom_type_ops c2_io_cob_rwv_type_ops = {
 
 static struct c2_fom_type c2_io_cob_rwv_type = {
 	.ft_ops = &c2_io_cob_rwv_type_ops,
->>>>>>> master
 };
 
 /**
@@ -136,12 +99,7 @@ static void io_fid_wire2mem(struct c2_fop_file_fid *in, struct c2_fid *out)
  * Find the corresponding fom_type and associate it with c2_fom.
  * Associate fop with fom type.
  */
-<<<<<<< HEAD
-int c2_io_fop_cob_rwv_fom_init(struct c2_fop *fop, struct c2_fop_ctx *ctx, 
-                               struct c2_fom **m)
-=======
 static int io_fop_cob_rwv_fom_init(struct c2_fop *fop, struct c2_fom **m)
->>>>>>> master
 {
 	struct c2_io_fom_cob_rwv *fom_obj;
 	struct c2_fop		 *rep_fop;
@@ -153,33 +111,6 @@ static int io_fop_cob_rwv_fom_init(struct c2_fop *fop, struct c2_fom **m)
 	C2_ALLOC_PTR(fom_obj);
 	if (fom_obj == NULL)
 		return -ENOMEM;
-<<<<<<< HEAD
-	fom_type = c2_io_fom_type_map(fop->f_type->ft_code);
-	C2_ASSERT(fom_type != NULL);
-	fop->f_type->ft_fom_type = *fom_type;
-	fom = &fom_obj->fcrw_gen;
-	fom->fo_type = fom_type;
-        fom->fo_phase = FOPH_INIT;
-        fom->fo_fop_ctx = ctx;
-
-	if (fop->f_type->ft_code == c2_io_service_readv_opcode) {
-		fom->fo_ops = &c2_io_fom_read_ops;
-		fom_obj->fcrw_rep_fop = 
-			c2_fop_alloc(&c2_fop_cob_readv_rep_fopt, NULL);
-		if (fom_obj->fcrw_rep_fop == NULL) {
-			c2_free(fom_obj);
-			return -ENOMEM;
-		}
-	}
-	else if (fop->f_type->ft_code == c2_io_service_writev_opcode) {
-		fom->fo_ops = &c2_io_fom_write_ops;
-		fom_obj->fcrw_rep_fop = 
-			c2_fop_alloc(&c2_fop_cob_writev_rep_fopt, NULL);
-		if (fom_obj->fcrw_rep_fop == NULL) {
-			c2_free(fom_obj);
-			return -ENOMEM;
-		}
-=======
 
 	fop->f_type->ft_fom_type.ft_ops = &c2_io_cob_rwv_type_ops;
 	if (is_read(fop))
@@ -190,7 +121,6 @@ static int io_fop_cob_rwv_fom_init(struct c2_fop *fop, struct c2_fom **m)
 	if (rep_fop == NULL) {
 		c2_free(fom_obj);
 		return -ENOMEM;
->>>>>>> master
 	}
 
 	c2_fom_create(&fom_obj->fcrw_gen, &c2_io_cob_rwv_type,
@@ -203,29 +133,12 @@ static int io_fop_cob_rwv_fom_init(struct c2_fop *fop, struct c2_fom **m)
 
 static int io_fom_rwv_io_launch(struct c2_fom *fom)
 {
-<<<<<<< HEAD
-        struct c2_site                  *site;
-        struct c2_fop_ctx               *ctx;
-	struct c2_fop_file_fid		*ffid;
-	struct c2_fid 			 fid;
-	struct c2_io_fom_cob_rwv 	*fom_obj;
-	struct c2_stob_id		 stobid;
-=======
 	int				 rc;
 	void				*addr;
->>>>>>> master
 	uint32_t			 bshift;
 	uint64_t			 bmask;
 	c2_bcount_t			 count;
 	c2_bindex_t			 offset;
-<<<<<<< HEAD
-	struct c2_clink			 clink;
-	int				 rc = 0;
-	struct c2_fop_cob_writev	*write_fop = NULL;
-	struct c2_fop_cob_readv		*read_fop = NULL;
-	struct c2_fop_cob_writev_rep	*wr_rep_fop = NULL;
-	struct c2_fop_cob_readv_rep	*rd_rep_fop = NULL;
-=======
 	struct c2_fid			 fid;
 	struct c2_fop			*fop;
 	struct c2_bufvec		*bufvec;
@@ -238,81 +151,22 @@ static int io_fom_rwv_io_launch(struct c2_fom *fom)
 	struct c2_fop_file_fid		*ffid;
 	struct c2_io_fom_cob_rwv	*fom_obj;
 	struct c2_fop_cob_readv_rep	*rrfop;
->>>>>>> master
 
 	C2_PRE(fom != NULL);
 
 	fom_obj = container_of(fom, struct c2_io_fom_cob_rwv, fcrw_gen);
 	fop = fom->fo_fop;
 
-<<<<<<< HEAD
-        ctx = fom->fo_fop_ctx;
-        C2_ASSERT(ctx != NULL);
-
-        site = ctx->fc_site;
-        C2_ASSERT(site != NULL);
-
-	/* 
-	 * Allocate and initialize stob io object 
-	 */
-	fom_obj->fcrw_st_io = c2_alloc(sizeof(struct c2_stob_io));
-	if (fom_obj->fcrw_st_io == NULL) {
-		result = -ENOMEM;
-		goto out;
-        }
-=======
 	iofop = io_rw_get(fop);
 	ffid = &iofop->crw_fid;
 	ioseg = iofop->crw_iovec.iv_segs;
 	stio = &fom_obj->fcrw_st_io;
 	fom->fo_phase = FOPH_COB_IO;
->>>>>>> master
 
 	io_fid_wire2mem(ffid, &fid);
 	io_fid2stob_map(&fid, &stobid);
 	fom_stdom = fom->fo_loc->fl_dom->fd_reqh->rh_stdom;
 
-<<<<<<< HEAD
-	/* Find out the in-core fid from on-wire fid. */
-	c2_io_fid_wire2mem(ffid, &fid);
-
-	/* 
-	 * Map the given fid to find out corresponding stob id.
-	 */
-	c2_io_fid2stob_map(&fid, &stobid);
-
-	/* 
-	 * This is a transaction IO and should be a separate phase 
-	 * with full fledged FOM. 
-	 */
-	 
-	/*
-	 * @todo: Use ctx->fc_tx prepared by reqh.
-	 */
-	result = site->s_iostore->ds_dom->sd_ops->sdo_tx_make(
-	        site->s_iostore->ds_dom, ctx->fc_tx);
-	C2_ASSERT(result == 0);
-
-	/*
-	 * Allocate and find out the c2_stob object from given domain. 
-	 */
-	result = c2_stob_find(site->s_iostore->ds_dom, 
-	        (const struct c2_stob_id*)&stobid, &fom_obj->fcrw_stob);
-	C2_ASSERT(result == 0);
-	result = c2_stob_locate(fom_obj->fcrw_stob, ctx->fc_tx);
-	C2_ASSERT(result == 0);
-
-	/*
-	 * Initialize the stob io routine.
-	 */
-	c2_stob_io_init(fom_obj->fcrw_st_io);
-
-	/*
-	 * Since the upper layer IO block size could differ
-	 * with IO block size of storage object, the block
-	 * alignment and mapping is necesary. 
-	 */
-=======
 	rc = c2_stob_find(fom_stdom, &stobid, &fom_obj->fcrw_stob);
 	if (rc != 0)
 		goto cleanup;
@@ -325,7 +179,6 @@ static int io_fom_rwv_io_launch(struct c2_fom *fom)
 
 	/* Since the upper layer IO block size could differ with IO block size
 	   of storage object, the block alignment and mapping is necesary. */
->>>>>>> master
 	bshift = fom_obj->fcrw_stob->so_op->sop_block_shift(fom_obj->fcrw_stob);
 	bmask = (1 << bshift) - 1;
 
@@ -365,43 +218,6 @@ static int io_fom_rwv_io_launch(struct c2_fom *fom)
 	count = count >> bshift;
 	offset = offset >> bshift;
 
-<<<<<<< HEAD
-	fom_obj->fcrw_st_io->si_user.div_vec.ov_vec.v_count = &count;
-	fom_obj->fcrw_st_io->si_user.div_vec.ov_buf = &addr;
-
-	fom_obj->fcrw_st_io->si_stob.iv_index = &offset;
-	fom_obj->fcrw_st_io->si_stob.iv_vec.v_count = &count;
-
-	/*
-	 * Total number of segments in IO vector 
-	 */
-	fom_obj->fcrw_st_io->si_user.div_vec.ov_vec.v_nr = 1;
-	fom_obj->fcrw_st_io->si_stob.iv_vec.v_nr = 1;
-	fom_obj->fcrw_st_io->si_flags = 0;
-
-	/* 
-	 * A new clink is used to wait on the channel 
-	 * from c2_stob_io.
-	 */
-	c2_clink_init(&clink, NULL);
-	c2_clink_add(&fom_obj->fcrw_st_io->si_wait, &clink);
-
-	/*
-	 * Launch IO and wait for status. 
-	 */
-	result = c2_stob_io_launch(fom_obj->fcrw_st_io, fom_obj->fcrw_stob, 
-	                           ctx->fc_tx, NULL);
-	if (result == 0)
-		c2_chan_wait(&clink);
-
-	/* 
-	 * Retrieve the status code and no of bytes read/written
-	 * and place it in respective reply FOP. 
-	 */
-	if (fom_obj->fcrw_fop->f_type->ft_code == c2_io_service_writev_opcode) {
-		wr_rep_fop->fwrr_rc = fom_obj->fcrw_st_io->si_rc;
-		wr_rep_fop->fwrr_count = fom_obj->fcrw_st_io->si_count << bshift;;
-=======
 	bufvec = &stio->si_user;
 	bufvec->ov_vec.v_count = &count;
 	bufvec->ov_buf = &addr;
@@ -418,7 +234,6 @@ static int io_fom_rwv_io_launch(struct c2_fom *fom)
 	if (rc == 0) {
 		fom->fo_rc = rc;
 		fom->fo_phase = FOPH_COB_IO_WAIT;
->>>>>>> master
 	}
 	else {
 		if (is_read(fop))
@@ -446,34 +261,6 @@ static int io_fom_rwv_io_launch_wait(struct c2_fom *fom)
 
 	C2_PRE(fom != NULL);
 
-<<<<<<< HEAD
-	if (result != -EDEADLK)	{
-		rc = c2_db_tx_commit(&ctx->fc_tx->tx_dbtx);
-		C2_ASSERT(rc == 0);
-	} else {
-		rc = c2_db_tx_abort(&ctx->fc_tx->tx_dbtx);
-		C2_ASSERT(rc == 0);
-		/* This should go into FAILURE phase */
-		fom_obj->fcrw_gen.fo_phase = FOPH_FAILED;
-                c2_fop_free(fom_obj->fcrw_rep_fop);
-		return FSO_AGAIN;
-	}
-
-	/*
-	 * Send reply FOP
-	 */
-	c2_net_reply_post(fom->fo_fop_ctx->fc_service, fom_obj->fcrw_rep_fop, 
-			  fom->fo_fop_ctx->fc_cookie);
-
-out:
-        ctx->fc_retval = rc;
-        if (rc)
-                c2_fop_free(fom_obj->fcrw_rep_fop);
-	/* 
-	 * This goes into DONE phase if not a error 
-	 */
-	fom_obj->fcrw_gen.fo_phase = rc ? FOPH_FAILED : FOPH_DONE;
-=======
 	fom_obj = container_of(fom, struct c2_io_fom_cob_rwv, fcrw_gen);
 	bshift = fom_obj->fcrw_stob->so_op->sop_block_shift(fom_obj->fcrw_stob);
 	stio = &fom_obj->fcrw_st_io;
@@ -497,7 +284,6 @@ out:
 
 	fom->fo_rc = 0;
 	fom->fo_phase = FOPH_SUCCESS;
->>>>>>> master
 	return FSO_AGAIN;
 }
 
@@ -537,11 +323,6 @@ static void io_fom_cob_rwv_fini(struct c2_fom *fom)
 {
 	struct c2_io_fom_cob_rwv *fom_obj;
 
-<<<<<<< HEAD
-	fom_obj = container_of(fom, struct c2_io_fom_cob_rwv, fcrw_gen);
-	c2_free(fom_obj);
-}
-=======
 	fom_ctx = container_of(fom, struct c2_io_fom_cob_rwv, fcrw_gen);
 	c2_free(fom_ctx);
 }
@@ -550,7 +331,6 @@ static size_t io_fom_locality_get(const struct c2_fom *fom)
 {
 	C2_PRE(fom != NULL);
 	C2_PRE(fom->fo_fop != NULL);
->>>>>>> master
 
 	return fom->fo_fop->f_type->ft_rpc_item_type.rit_opcode;
 }
diff --git a/ioservice/io_foms.h b/ioservice/io_foms.h
index b02d41e..e4ad291 100644
--- a/ioservice/io_foms.h
+++ b/ioservice/io_foms.h
@@ -65,26 +65,8 @@ struct c2_io_fom_cob_rwv {
 };
 
 /**
-<<<<<<< HEAD
- * <b> State Transition function for "read and write IO" operation
- *     that executes on data server. </b>
- *  - Submit the read/write IO request to the corresponding cob.
- *  - Send reply FOP to client.
- */
-int c2_io_fom_cob_rwv_state(struct c2_fom *fom); 
-
-/**
-   Free memory in passed @fom.
-*/
-void c2_fom_cob_rwv_fini(struct c2_fom *fom);
-
-/** 
- * The various phases for readv FOM. 
- * Not used as of now. Will be used once the 
-=======
  * The various phases for readv FOM.
  * Not used as of now. Will be used once the
->>>>>>> master
  * complete FOM and reqh infrastructure is in place.
  */
 enum c2_io_fom_cob_rwv_phases {
diff --git a/ioservice/io_fops.c b/ioservice/io_fops.c
index a0c9e2b..fd33726 100644
--- a/ioservice/io_fops.c
+++ b/ioservice/io_fops.c
@@ -40,13 +40,8 @@
 #include "lib/vec.h"	/* c2_0vec */
 #include "rpc/rpc_opcodes.h"
 
-<<<<<<< HEAD
-int c2_io_fop_cob_rwv_fom_init(struct c2_fop *fop, struct c2_fop_ctx *ctx, 
-                               struct c2_fom **m);
-=======
 extern const struct c2_rpc_item_ops      rpc_item_iov_ops;
 extern const struct c2_rpc_item_type_ops rpc_item_iov_type_ops;
->>>>>>> master
 
 /**
    The IO fops code has been generalized to suit both read and write fops
@@ -157,13 +152,7 @@ struct c2_fop_cob_rw_reply *io_rw_rep_get(struct c2_fop *fop)
 /**
    Returns IO vector from given IO fop.
  */
-<<<<<<< HEAD
-static int c2_io_fop_cob_rwv_rep_fom_init(struct c2_fop *fop, 
-                                          struct c2_fop_ctx *ctx, 
-                                          struct c2_fom **m)
-=======
 static struct c2_fop_io_vec *iovec_get(struct c2_fop *fop)
->>>>>>> master
 {
 	return &io_rw_get(fop)->crw_iovec;
 }
@@ -543,11 +532,6 @@ static struct c2_fop_type_format *ioservice_fmts[] = {
 	&c2_fop_cob_rw_reply_tfmt,
 };
 
-<<<<<<< HEAD
-/** Placeholder API for c2t1fs build. */
-int c2_io_fop_cob_rwv_fom_init(struct c2_fop *fop, struct c2_fop_ctx *ctx, 
-                               struct c2_fom **m)
-=======
 static struct c2_fop_type *ioservice_fops[] = {
 	&c2_fop_cob_readv_fopt,
 	&c2_fop_cob_writev_fopt,
@@ -556,7 +540,6 @@ static struct c2_fop_type *ioservice_fops[] = {
 };
 
 int c2_ioservice_fops_nr(void)
->>>>>>> master
 {
 	return ARRAY_SIZE(ioservice_fops);
 }
diff --git a/ioservice/io_fops.h b/ioservice/io_fops.h
index 02868da..201278f 100644
--- a/ioservice/io_fops.h
+++ b/ioservice/io_fops.h
@@ -36,13 +36,6 @@ struct c2_io_ioseg;
 /**
    Returns the number of fops registered by ioservice.
  */
-<<<<<<< HEAD
-enum c2_io_service_opcodes {
-	c2_io_service_readv_opcode = 15,
-	c2_io_service_writev_opcode,
-	c2_io_service_writev_rep_opcode = 25,
-	c2_io_service_readv_rep_opcode
-=======
 int c2_ioservice_fops_nr(void);
 
 /**
@@ -80,7 +73,6 @@ struct io_zeroseg {
 	void			*is_buf;
 	/* Linkage to have such zero segments in a list. */
 	struct c2_list_link	 is_linkage;
->>>>>>> master
 };
 
 /**
diff --git a/iostore/iostore.h b/iostore/iostore.h
index f9b8444..700c4b2 100644
--- a/iostore/iostore.h
+++ b/iostore/iostore.h
@@ -14,13 +14,8 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
-<<<<<<< HEAD:iostore/iostore.h
- * Original author: Yuriy Umanets <yuriy_umanets@xyratex.com>
- * Original creation date: 04/21/2011
-=======
  * Original author: Yuriy Umanets <Yuriy_Umanets@xyratex.com>
  * Original creation date: 01/12/2010
->>>>>>> master:mds/mds.c
  */
 
 #ifndef __COLIBRI_IOSTORE_DATASTORE_H__
diff --git a/lib/Makefile.am b/lib/Makefile.am
index 4f91ee7..53f88e6 100644
--- a/lib/Makefile.am
+++ b/lib/Makefile.am
@@ -40,24 +40,6 @@ UT_SOURCES           =
 endif
 
 noinst_LTLIBRARIES   = libc2.la
-<<<<<<< HEAD
-libc2_la_SOURCES     = libc2.c memory.c list.c refs.c \
-                       queue.c vec.c chan.c mutex.c cond.c buf.c \
-                       assert.c time.c timer.c thread.c bitmap.c \
-                       adt.h rwlock.h memory.h list.h \
-                       refs.h atomic.h queue.h arith.h thread.h buf.h \
-                       vec.h chan.h mutex.h cond.h types.h errno.h \
-                       user_space/user_x86_64_atomic.h assert.h cdefs.h \
-                       misc.c misc.h ext.c ext.h bitstring.h bitstring.c \
-                       $(UT_SOURCES) trace.h user_space/trace.c \
-                       getopts.c getopts.h user_space/assert.h \
-                       user_space/mutex.h user_space/cdefs.h \
-                       user_space/utime.c user_space/types.h \
-                       user_space/uthread.c user_space/thread.h \
-                       user_space/processor.c user_space/rwlock.c \
-                       user_space/timer.h semaphore.h \
-                       user_space/semaphore.c user_space/semaphore.h
-=======
 libc2_la_SOURCES     = \
                        adt.h \
                        arith.h \
@@ -126,7 +108,6 @@ libc2_la_SOURCES     = \
                        ut.h \
                        vec.c \
                        vec.h
->>>>>>> master
 
 libc2_la_LDFLAGS       = @PTHREAD_LIBS@ -lrt
 EXTRA_DIST             = \
diff --git a/lib/ut/main.c b/lib/ut/main.c
index d86efdf..f4376d1 100644
--- a/lib/ut/main.c
+++ b/lib/ut/main.c
@@ -58,10 +58,6 @@ const struct c2_test_suite libc2_ut = {
 		{ "processor", test_processor },
 		{ "queue",     test_queue     },
 		{ "refs",      test_refs      },
-<<<<<<< HEAD
-//		{ "processor", test_processor },
-=======
->>>>>>> master
 		{ "thread",    test_thread    },
 		{ "time",      test_time      },
 		{ "timer",     test_timer     },
diff --git a/reqh/reqh.c b/reqh/reqh.c
index 740f08f..e36fe26 100644
--- a/reqh/reqh.c
+++ b/reqh/reqh.c
@@ -140,83 +140,11 @@ void c2_reqh_fini(struct c2_reqh *reqh)
 	c2_mutex_fini(&reqh->rh_lock);
 }
 
-<<<<<<< HEAD
-int c2_reqh_fop_handle(struct c2_reqh *reqh, struct c2_fop *fop, void *cookie)
-{
-	struct c2_fop_ctx    ctx;
-        struct c2_fop_env    env;
-        struct c2_dtx        tx;
-	struct c2_fom	    *fom;
-	int                  result;
-
-restart:
-        fom = NULL;
-        C2_SET0(&ctx);
-        C2_SET0(&env);
-
-        result = c2_db_tx_init(&tx.tx_dbtx, 
-                               reqh->rh_site->s_mdstore->md_dom.cd_dbenv, 0);
-        if (result != 0)
-                return result;
-
-        ctx.fc_site = reqh->rh_site;
-        ctx.fc_fol  = reqh->rh_fol;
-        ctx.fc_service = reqh->rh_svc;
-        ctx.fc_cookie  = cookie;
-        ctx.fc_env = &env;
-        ctx.fc_tx = &tx;
-
-        /*
-         * Init fom for the fop start handling it.
-         */
-        result = fop->f_type->ft_ops->fto_fom_init(fop, &ctx, &fom);
-        if (result)
-                goto out;
-	        
-        C2_ASSERT(fom != NULL);
-
-        if (fom->fo_ops->fo_sanity) {
-                result = fom->fo_ops->fo_sanity(fom);
-                if (result)
-                        goto out_fini;
-        }
-
-        /*
-         * Add this fop to the fol.
-         */
-        result = c2_fop_fol_rec_add(fop, ctx.fc_fol, &tx.tx_dbtx);
-        if (result)
-                goto out_fini;
-
-        /* 
-         * Start the FOM. Return value from ->fo_state() is something
-         * from FSO_* which will be used here for making decision on
-         * how to act in various cases. What we return to caller is
-         * retval from fop handling code.
-         */
-        fom->fo_ops->fo_state(fom);
-        result = ctx.fc_retval;
-out_fini:
-        if (fom->fo_ops->fo_fini)
-                fom->fo_ops->fo_fini(fom);
-out:
-        if (result < 0) {
-                c2_db_tx_abort(&tx.tx_dbtx);
-                if (result == -EDEADLK)
-                        goto restart;
-        } else {
-                c2_db_tx_commit(&tx.tx_dbtx);
-//                c2_dbenv_sync(reqh->rh_site->s_mdstore->md_dom.cd_dbenv);
-        }
-        
-        return result;
-=======
 void c2_reqhs_fini(void)
 {
 	c2_addb_ctx_fini(&c2_reqh_addb_ctx);
 	c2_reqh_service_types_fini();
 	c2_reqh_fop_fini();
->>>>>>> master
 }
 
 int c2_reqhs_init(void)
@@ -227,7 +155,7 @@ int c2_reqhs_init(void)
 	return c2_reqh_fop_init();
 }
 
-void c2_reqh_fop_handle(struct c2_reqh *reqh,  struct c2_fop *fop)
+void c2_reqh_fop_handle(struct c2_reqh *reqh, struct c2_fop *fop, void *cookie)
 {
 	struct c2_fom	       *fom;
 	struct c2_fom_domain   *dom;
@@ -261,10 +189,6 @@ void c2_reqh_fop_handle(struct c2_reqh *reqh,  struct c2_fop *fop)
 		loc_idx = fom->fo_ops->fo_home_locality(fom) % dom->fd_localities_nr;
 		C2_ASSERT(loc_idx >= 0 && loc_idx < dom->fd_localities_nr);
 		fom->fo_loc = &reqh->rh_fom_dom.fd_localities[loc_idx];
-		if (result != 0) {
-			fom->fo_phase = FOPH_FAILURE;
-			fom->fo_rc = result;
-		}
 		c2_fom_queue(fom);
 	} else
 		REQH_ADDB_ADD(c2_reqh_addb_ctx, "c2_reqh_fop_handle", result);
diff --git a/stob/ut/io_fop_init.c b/stob/ut/io_fop_init.c
index 4da4757..a3a362a 100644
--- a/stob/ut/io_fop_init.c
+++ b/stob/ut/io_fop_init.c
@@ -49,12 +49,7 @@ int read_handler(struct c2_fop *fop, struct c2_fop_ctx *ctx);
 int write_handler(struct c2_fop *fop, struct c2_fop_ctx *ctx);
 int quit_handler(struct c2_fop *fop, struct c2_fop_ctx *ctx);*/
 
-<<<<<<< HEAD
-# include "io_u.h"
-# include "ioservice/io_fops_u.h"
-=======
 #include "io_u.h"
->>>>>>> master
 # include "addb/addb_u.h"
 #endif
 
@@ -106,15 +101,6 @@ static struct c2_fop_type *fops[] = {
 	&c2_io_write_rep_fopt,
 	&c2_io_read_rep_fopt,
 	&c2_io_create_rep_fopt,
-<<<<<<< HEAD
-	&c2_addb_reply_fopt,
-
-	&c2_fop_cob_readv_fopt,
-	&c2_fop_cob_writev_fopt,
-	&c2_fop_cob_writev_rep_fopt,
-	&c2_fop_cob_readv_rep_fopt,
-=======
->>>>>>> master
 };
 
 static struct c2_fop_type_format *fmts[] = {
diff --git a/stob/ut/server.c b/stob/ut/server.c
index 560b581..81170ba 100644
--- a/stob/ut/server.c
+++ b/stob/ut/server.c
@@ -42,380 +42,20 @@
    @{
  */
 
-<<<<<<< HEAD
-static struct c2_addb_ctx server_addb_ctx;
-
-static const struct c2_addb_loc server_addb_loc = {
-	.al_name = "server"
-};
-
-const struct c2_addb_ctx_type server_addb_ctx_type = {
-	.act_name = "t1-server",
-};
-
-#define SERVER_ADDB_ADD(name, rc)                                       \
-C2_ADDB_ADD(&server_addb_ctx, &server_addb_loc, c2_addb_func_fail, (name), (rc))
-
-static struct c2_stob_domain *dom;
-static struct c2_fol          fol;
-static struct c2_reqh         reqh;
-static struct c2_site         site;
-static struct c2_io_store   iostore;
-
-static struct c2_stob *object_find(const struct c2_fop_fid *fid,
-				   struct c2_dtx *tx)
-{
-	struct c2_stob_id  id;
-	struct c2_stob    *obj;
-	int result;
-
-	id.si_bits.u_hi = fid->f_seq;
-	id.si_bits.u_lo = fid->f_oid;
-	result = dom->sd_ops->sdo_stob_find(dom, &id, &obj);
-	C2_ASSERT(result == 0);
-	result = c2_stob_locate(obj, tx);
-	return obj;
-}
-
-int create_handler(struct c2_fop *fop, struct c2_fop_ctx *ctx)
-{
-	struct c2_io_create     *in = c2_fop_data(fop);
-	struct c2_io_create_rep *ex;
-	struct c2_fop           *reply;
-	struct c2_stob          *obj;
-	struct c2_dtx            tx;
-	int                      result;
-
-	reply = c2_fop_alloc(&c2_io_create_rep_fopt, NULL);
-	C2_ASSERT(reply != NULL);
-	ex = c2_fop_data(reply);
-
-	result = dom->sd_ops->sdo_tx_make(dom, &tx);
-	C2_ASSERT(result == 0);
-
-	obj = object_find(&in->sic_object, &tx);
-
-	result = c2_stob_create(obj, &tx);
-	C2_ASSERT(result == 0);
-	ex->sicr_rc = 0;
-	c2_net_reply_post(ctx->fc_service, reply, ctx->fc_cookie);
-
-	c2_stob_put(obj);
-
-	result = c2_fop_fol_rec_add(fop, &fol, &tx.tx_dbtx);
-	C2_ASSERT(result == 0);
-
-	result = c2_db_tx_commit(&tx.tx_dbtx);
-	C2_ASSERT(result == 0);
-
-	return 1;
-}
-
-int read_handler(struct c2_fop *fop, struct c2_fop_ctx *ctx)
-{
-	struct c2_io_read     *in = c2_fop_data(fop);
-	struct c2_io_read_rep *ex;
-	struct c2_fop         *reply;
-	struct c2_stob        *obj;
-	struct c2_stob_io      io;
-	struct c2_clink        clink;
-	struct c2_dtx          tx;
-	void                  *addr;
-	uint32_t               bshift;
-	uint64_t               bmask;
-	int                    result;
-	int                    rc;
-
-	reply = c2_fop_alloc(&c2_io_read_rep_fopt, NULL);
-	C2_ASSERT(reply != NULL);
-	ex = c2_fop_data(reply);
-
-	while (1) {
-		result = dom->sd_ops->sdo_tx_make(dom, &tx);
-		C2_ASSERT(result == 0);
-
-		obj = object_find(&in->sir_object, &tx);
-
-		bshift = obj->so_op->sop_block_shift(obj);
-		bmask  = (1 << bshift) - 1;
-
-		C2_ASSERT((in->sir_seg.f_count & bmask) == 0);
-		C2_ASSERT((in->sir_seg.f_offset & bmask) == 0);
-
-		C2_ALLOC_ARR(ex->sirr_buf.cib_value, in->sir_seg.f_count);
-		C2_ASSERT(ex->sirr_buf.cib_value != NULL);
-
-		in->sir_seg.f_count >>= bshift;
-		in->sir_seg.f_offset >>= bshift;
-
-		addr = c2_stob_addr_pack(ex->sirr_buf.cib_value, bshift);
-
-		c2_stob_io_init(&io);
-
-		io.si_user.div_vec.ov_vec.v_nr    = 1;
-		io.si_user.div_vec.ov_vec.v_count = &in->sir_seg.f_count;
-		io.si_user.div_vec.ov_buf = &addr;
-
-		io.si_stob.iv_vec.v_nr    = 1;
-		io.si_stob.iv_vec.v_count = &in->sir_seg.f_count;
-		io.si_stob.iv_index       = &in->sir_seg.f_offset;
-
-		io.si_opcode = SIO_READ;
-		io.si_flags  = 0;
-
-		c2_clink_init(&clink, NULL);
-		c2_clink_add(&io.si_wait, &clink);
-
-		result = c2_stob_io_launch(&io, obj, &tx, NULL);
-		C2_ASSERT(result == 0);
-
-		c2_chan_wait(&clink);
-
-		ex->sirr_rc            = io.si_rc;
-		ex->sirr_buf.cib_count = io.si_count << bshift;
-
-		c2_clink_del(&clink);
-		c2_clink_fini(&clink);
-
-		c2_stob_io_fini(&io);
-
-		c2_stob_put(obj);
-
-		if (result != -EDEADLK) {
-			rc = c2_db_tx_commit(&tx.tx_dbtx);
-			C2_ASSERT(rc == 0);
-			break;
-		} else {
-			fprintf(stderr, "Deadlock, aborting read.\n");
-			rc = c2_db_tx_abort(&tx.tx_dbtx);
-			C2_ASSERT(rc == 0);
-		}
-	}
-	c2_net_reply_post(ctx->fc_service, reply, ctx->fc_cookie);
-
-	return 1;
-}
-
-int write_handler(struct c2_fop *fop, struct c2_fop_ctx *ctx)
-{
-	struct c2_io_write     *in = c2_fop_data(fop);
-	struct c2_io_write_rep *ex;
-	struct c2_fop          *reply;
-	struct c2_stob         *obj;
-	struct c2_stob_io       io;
-	struct c2_dtx           tx;
-	void                   *addr;
-	c2_bcount_t             count;
-	c2_bindex_t             offset;
-	struct c2_clink         clink;
-	uint32_t                bshift;
-	uint64_t                bmask;
-	int                     result;
-	int                     rc;
-
-	reply = c2_fop_alloc(&c2_io_write_rep_fopt, NULL);
-	C2_ASSERT(reply != NULL);
-	ex = c2_fop_data(reply);
-
-	while (1) {
-		result = dom->sd_ops->sdo_tx_make(dom, &tx);
-		C2_ASSERT(result == 0);
-
-		obj = object_find(&in->siw_object, &tx);
-
-		bshift = obj->so_op->sop_block_shift(obj);
-		bmask  = (1 << bshift) - 1;
-
-		C2_ASSERT((in->siw_buf.cib_count & bmask) == 0);
-		C2_ASSERT((in->siw_offset & bmask) == 0);
-
-		addr = c2_stob_addr_pack(in->siw_buf.cib_value, bshift);
-		count = in->siw_buf.cib_count >> bshift;
-		offset = in->siw_offset >> bshift;
-
-		c2_stob_io_init(&io);
-
-		io.si_user.div_vec.ov_vec.v_nr    = 1;
-		io.si_user.div_vec.ov_vec.v_count = &count;
-		io.si_user.div_vec.ov_buf = &addr;
-
-		io.si_stob.iv_vec.v_nr    = 1;
-		io.si_stob.iv_vec.v_count = &count;
-		io.si_stob.iv_index       = &offset;
-
-		io.si_opcode = SIO_WRITE;
-		io.si_flags  = 0;
-
-		c2_clink_init(&clink, NULL);
-		c2_clink_add(&io.si_wait, &clink);
-
-		result = c2_stob_io_launch(&io, obj, &tx, NULL);
-
-		if (result == 0)
-			c2_chan_wait(&clink);
-
-		ex->siwr_rc    = io.si_rc;
-		ex->siwr_count = io.si_count << bshift;
-
-		c2_clink_del(&clink);
-		c2_clink_fini(&clink);
-
-		c2_stob_io_fini(&io);
-
-		c2_stob_put(obj);
-
-		if (result != -EDEADLK) {
-			result = c2_fop_fol_rec_add(fop, &fol, &tx.tx_dbtx);
-			C2_ASSERT(result == 0);
-
-			rc = c2_db_tx_commit(&tx.tx_dbtx);
-			C2_ASSERT(rc == 0);
-			break;
-		} else {
-			fprintf(stderr, "Deadlock, aborting write.\n");
-			rc = c2_db_tx_abort(&tx.tx_dbtx);
-			C2_ASSERT(rc == 0);
-		}
-	}
-	c2_net_reply_post(ctx->fc_service, reply, ctx->fc_cookie);
-
-	return 1;
-}
-=======
 #define SERVER_ENDPOINT_ADDR	"127.0.0.1:12346:1"
 #define SERVER_ENDPOINT		"bulk-sunrpc:" SERVER_ENDPOINT_ADDR
 #define SERVER_DB_FILE_NAME	"stob_ut_server.db"
 #define SERVER_STOB_FILE_NAME	"stob_ut_server.stob"
 #define SERVER_LOG_FILE_NAME	"stob_ut_server.log"
->>>>>>> master
 
 static bool stop = false;
 
 static void sigint_handler(int signum)
 {
 	stop = true;
-<<<<<<< HEAD
-
-	c2_net_reply_post(ctx->fc_service, reply, ctx->fc_cookie);
-	return 1;
-}
-
-static int io_handler(struct c2_service *service, struct c2_fop *fop,
-		      void *cookie)
-{
-	struct c2_fop_ctx  ctx;
-	int                result;
-
-	/* 
-	 * FOMs are implemented only for read and write operations 
-	 */
-	if ((fop->f_type->ft_code >= c2_io_service_readv_opcode)) {
-	        result = c2_reqh_fop_handle(&reqh, fop, cookie);
-		return result;
-	} else {
-	        ctx.fc_service = service;
-	        ctx.fc_cookie  = cookie;
-	        result = fop->f_type->ft_ops->fto_execute(fop, &ctx);
-	}
-	SERVER_ADDB_ADD("io_handler", result);
-	return result;
-}
-
-extern struct c2_fop_type c2_addb_record_fopt; /* opcode = 14 */
-
-static struct c2_fop_type *fopt[] = {
-	&c2_io_write_fopt,
-	&c2_io_read_fopt,
-	&c2_io_create_fopt,
-	&c2_io_quit_fopt,
-
-	&c2_addb_record_fopt,
-
-	&c2_fop_cob_readv_fopt,
-	&c2_fop_cob_writev_fopt,
-	&c2_fop_cob_writev_rep_fopt,
-	&c2_fop_cob_readv_rep_fopt,
-};
-
-struct mock_balloc {
-	struct c2_mutex  mb_lock;
-	c2_bindex_t      mb_next;
-	struct ad_balloc mb_ballroom;
-};
-
-static struct mock_balloc *b2mock(struct ad_balloc *ballroom)
-{
-	return container_of(ballroom, struct mock_balloc, mb_ballroom);
-}
-
-static int mock_balloc_init(struct ad_balloc *ballroom, struct c2_dbenv *db,
-			    uint32_t bshift)
-{
-	struct mock_balloc *mb = b2mock(ballroom);
-
-	c2_mutex_init(&mb->mb_lock);
-	return 0;
-}
-
-static void mock_balloc_fini(struct ad_balloc *ballroom)
-{
-	struct mock_balloc *mb = b2mock(ballroom);
-
-	c2_mutex_fini(&mb->mb_lock);
-}
-
-static int mock_balloc_alloc(struct ad_balloc *ballroom, struct c2_dtx *tx,
-			     c2_bcount_t count, struct c2_ext *out)
-{
-	struct mock_balloc *mb = b2mock(ballroom);
-	c2_bcount_t giveout;
-
-	c2_mutex_lock(&mb->mb_lock);
-	giveout = min64u(count, 500000);
-	out->e_start = mb->mb_next;
-	out->e_end   = mb->mb_next + giveout;
-	mb->mb_next += giveout + 1;
-	/*
-	printf("allocated %8lx/%8lx bytes: [%8lx .. %8lx)\n", giveout, count,
-	       out->e_start, out->e_end); */
-	c2_mutex_unlock(&mb->mb_lock);
-	return 0;
-}
-
-static int mock_balloc_free(struct ad_balloc *ballroom, struct c2_dtx *tx,
-			    struct c2_ext *ext)
-{
-	printf("freed     %8lx bytes: [%8lx .. %8lx)\n", c2_ext_length(ext),
-	       ext->e_start, ext->e_end);
-	return 0;
-}
-
-static const struct ad_balloc_ops mock_balloc_ops = {
-	.bo_init  = mock_balloc_init,
-	.bo_fini  = mock_balloc_fini,
-	.bo_alloc = mock_balloc_alloc,
-	.bo_free  = mock_balloc_free,
-};
-
-static struct mock_balloc mb = {
-	.mb_next = 0,
-	.mb_ballroom = {
-		.ab_ops = &mock_balloc_ops
-	}
-};
-
-static const struct c2_table_ops c2_addb_record_ops = {
-	.to = {
-		[TO_KEY] = { .max_size = sizeof (uint64_t) },
-		[TO_REC] = { .max_size = 4096 }
-	},
-	.key_cmp = NULL
-};
-=======
 }
 
 extern struct c2_net_xprt c2_net_bulk_sunrpc_xprt;
->>>>>>> master
 
 /**
    Simple server for unit-test purposes.
@@ -471,47 +111,14 @@ int main(int argc, char **argv)
 	rc = c2_rpc_server_start(&sctx);
 	C2_ASSERT(rc == 0);
 
-<<<<<<< HEAD
-        /*
-         * Set up data store to be used.
-         */
-        result = c2_io_store_init(&iostore, bdom);
-        C2_ASSERT(result == 0);
-
-        /*
-         * Set up site.
-         */
-        result = c2_site_init(&site, NULL, &iostore);
-        C2_ASSERT(result == 0);
-
-        /*
-         * Set up reqh.
-         */
-        result = c2_reqh_init(&reqh, NULL, &fol, &site, &service);
-        C2_ASSERT(result == 0);
-
-	result = c2_service_start(&service, &sid);
-	C2_ASSERT(result >= 0);
-=======
 	printf(" done\n");
 	printf("Press ^C to quit\n");
->>>>>>> master
 
 	while (!stop) {
 		sleep(1);
         }
 
-<<<<<<< HEAD
-	c2_service_stop(&service);
-	c2_service_id_fini(&sid);
-	c2_reqh_fini(&reqh);
-	c2_site_fini(&site);
-	c2_io_store_fini(&iostore);
-	c2_net_domain_fini(&ndom);
-	c2_net_xprt_fini(&c2_net_usunrpc_xprt);
-=======
 	printf("\nStopping server...");
->>>>>>> master
 
 	c2_rpc_server_stop(&sctx);
 	c2_stob_io_fop_fini();
diff --git a/utils/Makefile.am b/utils/Makefile.am
index 94c415d..139b75c 100644
--- a/utils/Makefile.am
+++ b/utils/Makefile.am
@@ -27,10 +27,7 @@ ut_LDADD     = $(top_builddir)/colibri/libcolibri.la \
                $(top_builddir)/net/bulk_emulation/ut/libnet-bulkem-ut.la \
                $(top_builddir)/udb/ut/libudb-ut.la \
                $(top_builddir)/capa/ut/libcapa-ut.la \
-<<<<<<< HEAD
                $(top_builddir)/mdstore/ut/libmdstore-ut.la \
-	       $(top_builddir)/xdr/ut/libxdr-ut.la
-=======
                $(top_builddir)/sm/ut/libsm-ut.la \
                $(top_builddir)/xcode/ut/libxcode-ut.la \
                $(top_builddir)/reqh/ut/libreqh-ut.la \
@@ -39,8 +36,7 @@ ut_LDADD     = $(top_builddir)/colibri/libcolibri.la \
                $(top_builddir)/rpc/ut/librpclib-ut.la \
                $(top_builddir)/ioservice/ut/libcfm-ut.la \
                $(top_builddir)/yaml2db/ut/libyaml2db-ut.la \
-	       $(top_builddir)/balloc/ut/libballoc-ut.la
->>>>>>> master
+               $(top_builddir)/balloc/ut/libballoc-ut.la
 
 ub_SOURCES   = ub_main.c common.c common.h
 ub_LDFLAGS   = -pthread
diff --git a/utils/ut_main.c b/utils/ut_main.c
index ac3b73b..62fb8e3 100644
--- a/utils/ut_main.c
+++ b/utils/ut_main.c
@@ -48,10 +48,7 @@ extern const struct c2_test_suite parity_math_ut;
 extern const struct c2_test_suite sm_ut;
 extern const struct c2_test_suite stobio_ut;
 extern const struct c2_test_suite udb_ut;
-<<<<<<< HEAD
 extern const struct c2_test_suite mdstore_ut;
-extern const struct c2_test_suite xdr_ut;
-=======
 extern const struct c2_test_suite xcode_bufvec_fop_ut;
 extern const struct c2_test_suite xcode_bufvec_ut;
 extern const struct c2_test_suite xcode_ff2c_ut;
@@ -64,7 +61,6 @@ extern const struct c2_test_suite cfm_ut;
 extern const struct c2_test_suite yaml2db_ut;
 extern const struct c2_test_suite buffer_pool_ut;
 extern const struct c2_test_suite balloc_ut;
->>>>>>> master
 
 #define UT_SANDBOX "./ut-sandbox"
 
@@ -79,6 +75,7 @@ void add_uts(void)
 	c2_ut_add(&capa_ut);
 	c2_ut_add(&cfm_ut);
 	c2_ut_add(&cob_ut);
+        c2_ut_add(&mdstore_ut);
 	c2_ut_add(&colibri_setup_ut);
 	c2_ut_add(&console_ut);
 	c2_ut_add(&db_ut);
@@ -172,32 +169,6 @@ int main(int argc, char *argv[])
 	if (result != 0)
 		return result;
 
-<<<<<<< HEAD
-	if (unit_start(UT_SANDBOX) == 0) {
-		/* sort test suites in alphabetic order */
-		c2_ut_add(&libc2_ut);
-		c2_ut_add(&adieu_ut);
-		c2_ut_add(&ad_ut);
-		c2_ut_add(&capa_ut);
-		c2_ut_add(&cob_ut);
-		c2_ut_add(&mdstore_ut);
-		c2_ut_add(&db_ut);
-		c2_ut_add(&emap_ut);
-		c2_ut_add(&fit_ut);
-		c2_ut_add(&fol_ut);
-		c2_ut_add(&fop_ut);
-		c2_ut_add(&net_bulk_if_ut);
-		c2_ut_add(&net_bulk_mem_ut);
-		c2_ut_add(&net_bulk_sunrpc_ut);
-		c2_ut_add(&net_client_ut);
-		c2_ut_add(&parity_math_ut);
-		c2_ut_add(&stobio_ut);
-		c2_ut_add(&udb_ut);
-		c2_ut_add(&xdr_ut);
-		c2_ut_run("c2ut.log");
-		if (!keep)
-			unit_end(UT_SANDBOX);
-=======
 	result = C2_GETOPTS("ut", argc, argv,
 		    C2_HELPARG('h'),
 		    C2_VOIDARG('T', "parse trace log produced earlier",
@@ -257,7 +228,6 @@ int main(int argc, char *argv[])
 				" the same time\n");
 		result = EXIT_FAILURE;
 		goto out;
->>>>>>> master
 	}
 
 	c2_list_init(&test_list);
-- 
1.8.3.2

