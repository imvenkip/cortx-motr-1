From 4b12c8f79e57f9abe568486d5f2bbe658aa8a186 Mon Sep 17 00:00:00 2001
From: Yuriy Umanets <yuriy_umanets@xyratex.com>
Date: Sat, 25 Feb 2012 00:01:22 +0400
Subject: [PATCH 177/177] Revert to e3ec33e58584049ab6dd03167fa098e946d7d791

---
 addb/linux_kernel/.gitignore    |    3 +
 addb/linux_kernel/Makefile.in   |   32 +
 c2t1fs/.gitignore               |    7 +
 c2t1fs/c2t1fs.h                 |  136 ++++
 c2t1fs/c2t1fs_loop.c            | 1548 +++++++++++++++++++++++++++++++++++++++
 c2t1fs/main.c                   | 1545 ++++++++++++++++++++++++++++++++++++++
 c2t1fs/st/common.sh             |   37 +
 c2t1fs/st/dbench.sh             |   74 ++
 c2t1fs/st/fs_common.sh          |   87 +++
 c2t1fs/st/mini.sh               |   61 ++
 c2t1fs/st/mount.sh              |   12 +
 c2t1fs/st/perf.sh               |   24 +
 c2t1fs/st/standard_loop.sh      |   76 ++
 c2t1fs/st/test.sh               |   89 +++
 c2t1fs/st/test2.sh              |   23 +
 c2t1fs/st/unmount.sh            |   12 +
 colibri/DS-Reqh.gif             |  Bin 22519 -> 0 bytes
 configure.ac                    |    0
 db/linux_kernel/.gitignore      |    1 +
 db/linux_kernel/Makefile.in     |   26 +
 doc/dld-sample-uml.png          |  Bin 40112 -> 0 bytes
 fop/linux_kernel/.gitignore     |    3 +
 fop/linux_kernel/Makefile.in    |   26 +
 fop/linux_kernel/fop_kernel.c   |   51 ++
 galois/linux_kernel/.gitignore  |    1 +
 galois/linux_kernel/Makefile.in |   21 +
 layout/linux_kernel/.gitignore  |    2 +
 layout/linux_kernel/Makefile.in |   20 +
 lib/libc2.c                     |   41 ++
 lib/linux_kernel/.gitignore     |   11 +
 lib/linux_kernel/Makefile.in    |   37 +
 lib/linux_kernel/ut/.gitignore  |    2 +
 lib/memory.c                    |  174 +++++
 lib/user_space/chan.h           |  140 ++++
 lib/user_space/time.c           |    1 +
 lib/user_space/trace.c          |  297 ++++++++
 net/ksunrpc/Makefile.in         |   29 +
 net/lnet/lnet_xo.dia            |  Bin 7308 -> 0 bytes
 net/lnet/lnet_xo.png            |  Bin 70749 -> 0 bytes
 net/st/connection.c             |  132 ++++
 pool/linux_kernel/.gitignore    |    1 +
 pool/linux_kernel/Makefile.in   |   21 +
 pool/linux_kernel/kpool.c       |   22 +
 rpc/compound.c                  |   32 +
 rpc/compound_cli.h              |   71 ++
 rpc/compound_types.h            |  130 ++++
 rpc/pcache.c                    |   47 ++
 rpc/pcache.h                    |  213 ++++++
 rpc/rpc_ops.h                   |   41 ++
 rpc/rpc_types.h                 |   64 ++
 rpc/session_cli.c               |  135 ++++
 rpc/session_cli.h               |  113 +++
 rpc/session_srv.c               |   62 ++
 rpc/session_srv.h               |  150 ++++
 rpc/session_svc.c               |   61 ++
 rpc/session_svc.h               |   60 ++
 rpc/session_types.h             |  111 +++
 rpc/ut/rpc-client.c             |   40 +
 rpc/ut/rpc-server.c             |   53 ++
 sns/linux_kernel/.gitignore     |    4 +
 sns/linux_kernel/Makefile.in    |   22 +
 sns/linux_kernel/ksns.c         |   23 +
 stob/linux_kernel/.gitignore    |    1 +
 stob/linux_kernel/Makefile.in   |   20 +
 utils/linux_kernel/.gitignore   |    4 +
 xdr/Makefile.am                 |    5 +
 xdr/ut/Makefile.am              |    6 +
 xdr/ut/xdr_test.c               |  484 ++++++++++++
 xdr/xdr_rec.h                   |  232 ++++++
 69 files changed, 7009 insertions(+)
 create mode 100644 addb/linux_kernel/.gitignore
 create mode 100644 addb/linux_kernel/Makefile.in
 create mode 100644 c2t1fs/.gitignore
 create mode 100644 c2t1fs/c2t1fs.h
 create mode 100644 c2t1fs/c2t1fs_loop.c
 create mode 100644 c2t1fs/main.c
 create mode 100755 c2t1fs/st/common.sh
 create mode 100755 c2t1fs/st/dbench.sh
 create mode 100644 c2t1fs/st/fs_common.sh
 create mode 100644 c2t1fs/st/mini.sh
 create mode 100755 c2t1fs/st/mount.sh
 create mode 100755 c2t1fs/st/perf.sh
 create mode 100644 c2t1fs/st/standard_loop.sh
 create mode 100755 c2t1fs/st/test.sh
 create mode 100755 c2t1fs/st/test2.sh
 create mode 100755 c2t1fs/st/unmount.sh
 delete mode 100644 colibri/DS-Reqh.gif
 mode change 100644 => 100755 configure.ac
 create mode 100644 db/linux_kernel/.gitignore
 create mode 100644 db/linux_kernel/Makefile.in
 delete mode 100644 doc/dld-sample-uml.png
 create mode 100644 fop/linux_kernel/.gitignore
 create mode 100644 fop/linux_kernel/Makefile.in
 create mode 100644 fop/linux_kernel/fop_kernel.c
 create mode 100644 galois/linux_kernel/.gitignore
 create mode 100644 galois/linux_kernel/Makefile.in
 create mode 100644 layout/linux_kernel/.gitignore
 create mode 100644 layout/linux_kernel/Makefile.in
 create mode 100644 lib/libc2.c
 create mode 100644 lib/linux_kernel/.gitignore
 create mode 100644 lib/linux_kernel/Makefile.in
 create mode 100644 lib/linux_kernel/ut/.gitignore
 create mode 100644 lib/memory.c
 create mode 100644 lib/user_space/chan.h
 create mode 120000 lib/user_space/time.c
 create mode 100644 lib/user_space/trace.c
 create mode 100644 net/ksunrpc/Makefile.in
 delete mode 100644 net/lnet/lnet_xo.dia
 delete mode 100644 net/lnet/lnet_xo.png
 create mode 100644 net/st/connection.c
 create mode 100644 pool/linux_kernel/.gitignore
 create mode 100644 pool/linux_kernel/Makefile.in
 create mode 100644 pool/linux_kernel/kpool.c
 create mode 100644 rpc/compound.c
 create mode 100644 rpc/compound_cli.h
 create mode 100644 rpc/compound_types.h
 create mode 100644 rpc/pcache.c
 create mode 100644 rpc/pcache.h
 create mode 100644 rpc/rpc_ops.h
 create mode 100644 rpc/rpc_types.h
 create mode 100644 rpc/session_cli.c
 create mode 100644 rpc/session_cli.h
 create mode 100644 rpc/session_srv.c
 create mode 100644 rpc/session_srv.h
 create mode 100644 rpc/session_svc.c
 create mode 100644 rpc/session_svc.h
 create mode 100644 rpc/session_types.h
 create mode 100644 rpc/ut/rpc-client.c
 create mode 100644 rpc/ut/rpc-server.c
 create mode 100644 sns/linux_kernel/.gitignore
 create mode 100644 sns/linux_kernel/Makefile.in
 create mode 100644 sns/linux_kernel/ksns.c
 create mode 100644 stob/linux_kernel/.gitignore
 create mode 100644 stob/linux_kernel/Makefile.in
 create mode 100644 utils/linux_kernel/.gitignore
 create mode 100644 xdr/Makefile.am
 create mode 100644 xdr/ut/Makefile.am
 create mode 100644 xdr/ut/xdr_test.c
 create mode 100644 xdr/xdr_rec.h

diff --git a/addb/linux_kernel/.gitignore b/addb/linux_kernel/.gitignore
new file mode 100644
index 0000000..fda6da4
--- /dev/null
+++ b/addb/linux_kernel/.gitignore
@@ -0,0 +1,3 @@
+addb.c
+addb_fop.c
+addb_k.[ch]
diff --git a/addb/linux_kernel/Makefile.in b/addb/linux_kernel/Makefile.in
new file mode 100644
index 0000000..7f99581
--- /dev/null
+++ b/addb/linux_kernel/Makefile.in
@@ -0,0 +1,32 @@
+ADDB_SRCDIR = @SRCDIR@/addb/linux_kernel
+FOPDIR = @SRCDIR@/fop
+ADDBDIR = @SRCDIR@/addb
+
+obj-m       := kaddb.o
+shared_src  := addb.c addb_fop.c
+kernel_src  := addb_console.c addb_k.c
+kaddb-y     := $(shared_src:.c=.o) $(kernel_src:.c=.o)
+orig        := $(shared_src:%=../%)
+
+EXTRA_CFLAGS = -DHAVE_CONFIG_H -I@SRCDIR@ @KCFLAGS@
+
+prepare: addb_k.c addb_k.h
+	ln -fs $(orig) .
+
+addb_k.c addb_k.h: $(ADDBDIR)/addb.ff
+	$(FOPDIR)/fop2c -k $(ADDBDIR)/addb.ff
+
+install modules_install:
+	$(MAKE) INSTALL_MOD_DIR=kernel/fs/addb -C @LINUX_OBJ@ M=`pwd` modules_install
+
+uninstall:
+	rm -fr @LUNUX_MOD@/kernel/fs/addb
+
+clean distclean:
+	$(RM) addb_k.[ch]
+	$(RM) $(shared_src) Module.markers Module.symvers modules.order
+	$(MAKE) -C @LINUX_OBJ@ M=`pwd` clean
+
+distdir:
+	cp $(ADDB_SRCDIR)/Makefile.in $(ADDB_SRCDIR)/addb_console.c \
+@top_builddir@/@PACKAGE@-@VERSION@/addb/linux_kernel
diff --git a/c2t1fs/.gitignore b/c2t1fs/.gitignore
new file mode 100644
index 0000000..7aeb47d
--- /dev/null
+++ b/c2t1fs/.gitignore
@@ -0,0 +1,7 @@
+io_k.[ch]
+io_fop_init.c
+addb_k.[ch]
+addb_store.c
+io_foms.[ch]
+io_fops.[ch]
+io_fops_k.[ch]
diff --git a/c2t1fs/c2t1fs.h b/c2t1fs/c2t1fs.h
new file mode 100644
index 0000000..e50a3cc
--- /dev/null
+++ b/c2t1fs/c2t1fs.h
@@ -0,0 +1,136 @@
+/* -*- C -*- */
+/*
+ * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: Yuriy Umanets <yuriy_umanets@xyratex.com>
+ *		    Huang Hua <hua_huang@xyratex.com>
+ * Original creation date: 05/03/2010
+ */
+
+#ifndef __COLIBRI_C2T1FS_H
+#define __COLIBRI_C2T1FS_H
+
+#include <linux/in.h> /* for sockaddr_in */
+
+#include "lib/list.h"
+#include "net/net.h"
+#include "config.h"
+
+#define C2T1FS_DEBUG 1
+#ifdef C2T1FS_DEBUG
+#define ENTER   printk("Enter into function %s\n", __FUNCTION__)
+#define LEAVE   printk("Leave function %s\n", __FUNCTION__)
+#define GETHERE printk("Get %s line %d\n", __FUNCTION__, __LINE__)
+#else
+#define ENTER
+#define LEAVE
+#define GETHERE
+#endif
+
+#define s2csi(sb)       \
+        ((struct c2t1fs_sb_info *)((sb)->s_fs_info))
+
+#define s2csi_nocast(sb) \
+        ((sb)->s_fs_info)
+
+/* 0x\C\2\T\1 */
+#define C2T1FS_SUPER_MAGIC    0x43325431
+#define C2T1FS_ROOT_INODE     0x10000000
+#define C2T1FS_INIT_OBJSIZE   (4 << 20)
+
+#define C2TIME_S(time)        (time.tv_sec)
+
+/* 1M */
+#define C2_MAX_BRW_BITS       (20)
+
+/* 4*1M */
+#define C2_MAX_BLKSIZE_BITS   (22)
+
+#ifndef log2
+#define log2(n) ffz(~(n))
+#endif
+
+enum {
+	/* for now, 4k page size for ksunrpc_{read,write}(...) */
+	C2T1FS_DEFAULT_UNIT_SIZE = 4096
+};
+
+/**
+   This is the data structure to describe a client transport,
+   identified by its container id.
+*/
+struct c2t1fs_conn_clt {
+	/** container id */
+	uint64_t                  xc_cid;
+
+	/** node service id on which this container is running */
+        struct c2_service_id      xc_srvid;
+
+	/** the connection for this container */
+        struct c2_net_conn       *xc_conn;
+
+	/** linkage in hash table */
+	struct c2_list_link       xc_link;
+};
+
+/**
+   Object parameter on client.
+
+   This object is shown on client and can be read from and written to.
+   Also this object can be exported by loop device.
+*/
+struct c2t1fs_object_param {
+        uint64_t        cop_objid;    /*< The object id will be mapped */
+        uint64_t        cop_objsize;  /*< The initial object size */
+        uint64_t        cop_layoutid; /*< layout id this client uses */
+	c2_bcount_t     cop_unitsize; /*< data or parity unit size in bytes */
+
+	struct c2_pdclust_layout *cop_play; /*< parity de-clustered layout */
+};
+
+struct c2t1fs_sb_info {
+        atomic_t        csi_mounts;
+        int             csi_flags;
+
+	struct c2t1fs_object_param csi_object_param; /*< the object on client */
+
+        struct c2_service_id  csi_mgmt_srvid; /*< mgmt node service id */
+        struct c2_net_conn   *csi_mgmt_conn;  /*< mgmt node xprt */
+
+        struct c2_list  csi_conn_list; /*< transport list or hash table */
+        struct c2_mutex csi_mutex;      /*< mutex to protect this sb */
+
+	struct c2_net_domain csi_net_domain;
+};
+
+struct c2t1fs_inode_info {
+        struct inode    cii_vfs_inode;
+};
+
+static inline struct c2t1fs_inode_info *i2cii(struct inode *inode)
+{
+        return container_of(inode, struct c2t1fs_inode_info, cii_vfs_inode);
+}
+
+#endif
+/*
+ *  Local variables:
+ *  c-indentation-style: "K&R"
+ *  c-basic-offset: 8
+ *  tab-width: 8
+ *  fill-column: 80
+ *  scroll-step: 1
+ *  End:
+ */
diff --git a/c2t1fs/c2t1fs_loop.c b/c2t1fs/c2t1fs_loop.c
new file mode 100644
index 0000000..9b50155
--- /dev/null
+++ b/c2t1fs/c2t1fs_loop.c
@@ -0,0 +1,1548 @@
+/*
+ *  linux/drivers/block/loop.c
+ *
+ *  Written by Theodore Ts'o, 3/29/93
+ *
+ * Copyright 1993 by Theodore Ts'o.  Redistribution of this file is
+ * permitted under the GNU General Public License.
+ *
+ * DES encryption plus some minor changes by Werner Almesberger, 30-MAY-1993
+ * more DES encryption plus IDEA encryption by Nicholas J. Leon, June 20, 1996
+ *
+ * Modularized and updated for 1.1.16 kernel - Mitch Dsouza 28th May 1994
+ * Adapted for 1.3.59 kernel - Andries Brouwer, 1 Feb 1996
+ *
+ * Fixed do_loop_request() re-entrancy - Vincent.Renardias@waw.com Mar 20, 1997
+ *
+ * Added devfs support - Richard Gooch <rgooch@atnf.csiro.au> 16-Jan-1998
+ *
+ * Handle sparse backing files correctly - Kenn Humborg, Jun 28, 1998
+ *
+ * Loadable modules and other fixes by AK, 1998
+ *
+ * Make real block number available to downstream transfer functions, enables
+ * CBC (and relatives) mode encryption requiring unique IVs per data block.
+ * Reed H. Petty, rhp@draper.net
+ *
+ * Maximum number of loop devices now dynamic via max_loop module parameter.
+ * Russell Kroll <rkroll@exploits.org> 19990701
+ *
+ * Maximum number of loop devices when compiled-in now selectable by passing
+ * max_loop=<1-255> to the kernel on boot.
+ * Erik I. Bols√∏, <eriki@himolde.no>, Oct 31, 1999
+ *
+ * Completely rewrite request handling to be make_request_fn style and
+ * non blocking, pushing work to a helper thread. Lots of fixes from
+ * Al Viro too.
+ * Jens Axboe <axboe@suse.de>, Nov 2000
+ *
+ * Support up to 256 loop devices
+ * Heinz Mauelshagen <mge@sistina.com>, Feb 2002
+ *
+ * Support for falling back on the write file operation when the address space
+ * operations write_begin is not available on the backing filesystem.
+ * Anton Altaparmakov, 16 Feb 2005
+ *
+ * Still To Fix:
+ * - Advisory locking is ignored here.
+ * - Should use an own CAP_* category instead of CAP_SYS_ADMIN
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/sched.h>
+#include <linux/fs.h>
+#include <linux/file.h>
+#include <linux/stat.h>
+#include <linux/major.h>
+#include <linux/wait.h>
+#include <linux/blkdev.h>
+#include <linux/blkpg.h>
+#include <linux/init.h>
+#include <linux/swap.h>
+#include <linux/slab.h>
+#include <linux/loop.h>
+#include <linux/compat.h>
+#include <linux/suspend.h>
+#include <linux/freezer.h>
+#include <linux/writeback.h>
+#include <linux/buffer_head.h>		/* for invalidate_bdev() */
+#include <linux/completion.h>
+#include <linux/highmem.h>
+#include <linux/kthread.h>
+#include <linux/splice.h>
+
+#include <asm/uaccess.h>
+
+#include "lib/misc.h"   /* C2_SET0 */
+#include "lib/errno.h"
+#include "lib/cdefs.h"    /* C2_EXPORTED */
+#include "c2t1fs/c2t1fs.h"
+
+static LIST_HEAD(loop_devices);
+static DEFINE_MUTEX(loop_devices_mutex);
+
+static int max_part;
+static int part_shift;
+
+/*
+ * Transfer functions
+ */
+static int transfer_none(struct loop_device *lo, int cmd,
+			 struct page *raw_page, unsigned raw_off,
+			 struct page *loop_page, unsigned loop_off,
+			 int size, sector_t real_block)
+{
+	char *raw_buf = kmap_atomic(raw_page, KM_USER0) + raw_off;
+	char *loop_buf = kmap_atomic(loop_page, KM_USER1) + loop_off;
+
+	if (cmd == READ)
+		memcpy(loop_buf, raw_buf, size);
+	else
+		memcpy(raw_buf, loop_buf, size);
+
+	kunmap_atomic(raw_buf, KM_USER0);
+	kunmap_atomic(loop_buf, KM_USER1);
+	cond_resched();
+	return 0;
+}
+
+static int transfer_xor(struct loop_device *lo, int cmd,
+			struct page *raw_page, unsigned raw_off,
+			struct page *loop_page, unsigned loop_off,
+			int size, sector_t real_block)
+{
+	char *raw_buf = kmap_atomic(raw_page, KM_USER0) + raw_off;
+	char *loop_buf = kmap_atomic(loop_page, KM_USER1) + loop_off;
+	char *in, *out, *key;
+	int i, keysize;
+
+	if (cmd == READ) {
+		in = raw_buf;
+		out = loop_buf;
+	} else {
+		in = loop_buf;
+		out = raw_buf;
+	}
+
+	key = lo->lo_encrypt_key;
+	keysize = lo->lo_encrypt_key_size;
+	for (i = 0; i < size; i++)
+		*out++ = *in++ ^ key[(i & 511) % keysize];
+
+	kunmap_atomic(raw_buf, KM_USER0);
+	kunmap_atomic(loop_buf, KM_USER1);
+	cond_resched();
+	return 0;
+}
+
+static int xor_init(struct loop_device *lo, const struct loop_info64 *info)
+{
+	if (unlikely(info->lo_encrypt_key_size <= 0))
+		return -EINVAL;
+	return 0;
+}
+
+static struct loop_func_table none_funcs = {
+	.number = LO_CRYPT_NONE,
+	.transfer = transfer_none,
+}; 	
+
+static struct loop_func_table xor_funcs = {
+	.number = LO_CRYPT_XOR,
+	.transfer = transfer_xor,
+	.init = xor_init
+}; 	
+
+/* xfer_funcs[0] is special - its release function is never called */
+static struct loop_func_table *xfer_funcs[MAX_LO_CRYPT] = {
+	&none_funcs,
+	&xor_funcs
+};
+
+static loff_t get_loop_size(struct loop_device *lo, struct file *file)
+{
+	loff_t size, offset, loopsize;
+
+	/* Compute loopsize in bytes */
+	size = i_size_read(file->f_mapping->host);
+	offset = lo->lo_offset;
+	loopsize = size - offset;
+	if (lo->lo_sizelimit > 0 && lo->lo_sizelimit < loopsize)
+		loopsize = lo->lo_sizelimit;
+
+	/*
+	 * Unfortunately, if we want to do I/O on the device,
+	 * the number of 512-byte sectors has to fit into a sector_t.
+	 */
+	return loopsize >> 9;
+}
+
+static int
+figure_loop_size(struct loop_device *lo)
+{
+	loff_t size = get_loop_size(lo, lo->lo_backing_file);
+	sector_t x = (sector_t)size;
+
+	if (unlikely((loff_t)x != size))
+		return -EFBIG;
+
+	set_capacity(lo->lo_disk, x);
+	return 0;					
+}
+
+static inline int
+lo_do_transfer(struct loop_device *lo, int cmd,
+	       struct page *rpage, unsigned roffs,
+	       struct page *lpage, unsigned loffs,
+	       int size, sector_t rblock)
+{
+	if (unlikely(!lo->transfer))
+		return 0;
+
+	return lo->transfer(lo, cmd, rpage, roffs, lpage, loffs, size, rblock);
+}
+
+#if 0
+/**
+ * do_lo_send_aops - helper for writing data to a loop device
+ *
+ * This is the fast version for backing filesystems which implement the address
+ * space operations write_begin and write_end.
+ */
+static int do_lo_send_aops(struct loop_device *lo, struct bio_vec *bvec,
+		loff_t pos, struct page *unused)
+{
+	struct file *file = lo->lo_backing_file; /* kudos to NFsckingS */
+	struct address_space *mapping = file->f_mapping;
+	pgoff_t index;
+	unsigned offset, bv_offs;
+	int len, ret;
+
+	mutex_lock(&mapping->host->i_mutex);
+	index = pos >> PAGE_CACHE_SHIFT;
+	offset = pos & ((pgoff_t)PAGE_CACHE_SIZE - 1);
+	bv_offs = bvec->bv_offset;
+	len = bvec->bv_len;
+	while (len > 0) {
+		sector_t IV;
+		unsigned size, copied;
+		int transfer_result;
+		struct page *page;
+		void *fsdata;
+
+		IV = ((sector_t)index << (PAGE_CACHE_SHIFT - 9))+(offset >> 9);
+		size = PAGE_CACHE_SIZE - offset;
+		if (size > len)
+			size = len;
+
+		ret = pagecache_write_begin(file, mapping, pos, size, 0,
+							&page, &fsdata);
+		if (ret)
+			goto fail;
+
+		file_update_time(file);
+
+		transfer_result = lo_do_transfer(lo, WRITE, page, offset,
+				bvec->bv_page, bv_offs, size, IV);
+		copied = size;
+		if (unlikely(transfer_result))
+			copied = 0;
+
+		ret = pagecache_write_end(file, mapping, pos, size, copied,
+							page, fsdata);
+		if (ret < 0 || ret != copied)
+			goto fail;
+
+		if (unlikely(transfer_result))
+			goto fail;
+
+		bv_offs += copied;
+		len -= copied;
+		offset = 0;
+		index++;
+		pos += copied;
+	}
+	ret = 0;
+out:
+	mutex_unlock(&mapping->host->i_mutex);
+	return ret;
+fail:
+	ret = -1;
+	goto out;
+}
+
+/**
+ * __do_lo_send_write - helper for writing data to a loop device
+ *
+ * This helper just factors out common code between do_lo_send_direct_write()
+ * and do_lo_send_write().
+ */
+static int __do_lo_send_write(struct file *file,
+		u8 *buf, const int len, loff_t pos)
+{
+	ssize_t bw;
+	mm_segment_t old_fs = get_fs();
+
+	set_fs(get_ds());
+	bw = file->f_op->write(file, buf, len, &pos);
+	set_fs(old_fs);
+	if (likely(bw == len))
+		return 0;
+	printk(KERN_ERR "loop: Write error at byte offset %llu, length %i.\n",
+			(unsigned long long)pos, len);
+	if (bw >= 0)
+		bw = -EIO;
+	return bw;
+}
+
+/**
+ * do_lo_send_direct_write - helper for writing data to a loop device
+ *
+ * This is the fast, non-transforming version for backing filesystems which do
+ * not implement the address space operations write_begin and write_end.
+ * It uses the write file operation which should be present on all writeable
+ * filesystems.
+ */
+static int do_lo_send_direct_write(struct loop_device *lo,
+		struct bio_vec *bvec, loff_t pos, struct page *page)
+{
+	ssize_t bw = __do_lo_send_write(lo->lo_backing_file,
+			kmap(bvec->bv_page) + bvec->bv_offset,
+			bvec->bv_len, pos);
+	kunmap(bvec->bv_page);
+	cond_resched();
+	return bw;
+}
+
+/**
+ * do_lo_send_write - helper for writing data to a loop device
+ *
+ * This is the slow, transforming version for filesystems which do not
+ * implement the address space operations write_begin and write_end.  It
+ * uses the write file operation which should be present on all writeable
+ * filesystems.
+ *
+ * Using fops->write is slower than using aops->{prepare,commit}_write in the
+ * transforming case because we need to double buffer the data as we cannot do
+ * the transformations in place as we do not have direct access to the
+ * destination pages of the backing file.
+ */
+static int do_lo_send_write(struct loop_device *lo, struct bio_vec *bvec,
+		loff_t pos, struct page *page)
+{
+	int ret = lo_do_transfer(lo, WRITE, page, 0, bvec->bv_page,
+			bvec->bv_offset, bvec->bv_len, pos >> 9);
+	if (likely(!ret))
+		return __do_lo_send_write(lo->lo_backing_file,
+				page_address(page), bvec->bv_len,
+				pos);
+	printk(KERN_ERR "loop: Transfer error at byte offset %llu, "
+			"length %i.\n", (unsigned long long)pos, bvec->bv_len);
+	if (ret > 0)
+		ret = -EIO;
+	return ret;
+}
+#endif
+
+static struct iovec iov_static[BIO_MAX_PAGES];
+static int do_bio_filebacked(struct loop_device *lo, struct bio *bio)
+{
+	loff_t pos;
+	struct file *file = lo->lo_backing_file;
+	struct iovec *iov;
+ 	struct bio_vec *bvec;
+	int i;
+	int j = 0;
+	ssize_t bw;
+	struct kiocb kiocb;
+	mm_segment_t old_fs = get_fs();
+
+	init_sync_kiocb(&kiocb, file);
+	kiocb.ki_nbytes = kiocb.ki_left = bio->bi_size;
+
+	pos = ((loff_t) bio->bi_sector << 9) + lo->lo_offset;
+        kiocb.ki_pos = pos;
+ 	bio_for_each_segment(bvec, bio, i) {
+		iov = &iov_static[j++];
+		iov->iov_base = page_address(bvec->bv_page) + bvec->bv_offset;
+		iov->iov_len = bvec->bv_len;
+ 	}
+
+	set_fs(get_ds());
+	bw = (bio_rw(bio) == READ ? file->f_op->aio_read : file->f_op->aio_write)
+		(&kiocb, iov_static, j, pos);
+	set_fs(old_fs);
+	if (likely(bio->bi_size == bw))
+		return 0;
+	return -EIO;
+}
+ 
+
+/*
+ * Add bio to back of pending list
+ */
+static void loop_add_bio(struct loop_device *lo, struct bio *bio)
+{
+	bio_list_add(&lo->lo_bio_list, bio);
+}
+
+/*
+ * Grab first pending buffer
+ */
+static struct bio *loop_get_bio(struct loop_device *lo)
+{
+	return bio_list_pop(&lo->lo_bio_list);
+}
+
+static int loop_make_request(struct request_queue *q, struct bio *old_bio)
+{
+	struct loop_device *lo = q->queuedata;
+	int rw = bio_rw(old_bio);
+
+	if (rw == READA)
+		rw = READ;
+
+	BUG_ON(!lo || (rw != READ && rw != WRITE));
+
+	spin_lock_irq(&lo->lo_lock);
+	if (lo->lo_state != Lo_bound)
+		goto out;
+	if (unlikely(rw == WRITE && (lo->lo_flags & LO_FLAGS_READ_ONLY)))
+		goto out;
+	loop_add_bio(lo, old_bio);
+	wake_up(&lo->lo_event);
+	spin_unlock_irq(&lo->lo_lock);
+	return 0;
+
+out:
+	spin_unlock_irq(&lo->lo_lock);
+	bio_io_error(old_bio);
+	return 0;
+}
+
+/*
+ * kick off io on the underlying address space
+ */
+static void loop_unplug(struct request_queue *q)
+{
+	struct loop_device *lo = q->queuedata;
+
+	queue_flag_clear_unlocked(QUEUE_FLAG_PLUGGED, q);
+	blk_run_address_space(lo->lo_backing_file->f_mapping);
+}
+
+struct switch_request {
+	struct file *file;
+	struct completion wait;
+};
+
+static void do_loop_switch(struct loop_device *, struct switch_request *);
+
+static inline void loop_handle_bio(struct loop_device *lo, struct bio *bio)
+{
+	if (unlikely(!bio->bi_bdev)) {
+		do_loop_switch(lo, bio->bi_private);
+		bio_put(bio);
+	} else {
+		int ret = do_bio_filebacked(lo, bio);
+		bio_endio(bio, ret);
+	}
+}
+
+/*
+ * worker thread that handles reads/writes to file backed loop devices,
+ * to avoid blocking in our make_request_fn. it also does loop decrypting
+ * on reads for block backed loop, as that is too heavy to do from
+ * b_end_io context where irqs may be disabled.
+ *
+ * Loop explanation:  loop_clr_fd() sets lo_state to Lo_rundown before
+ * calling kthread_stop().  Therefore once kthread_should_stop() is
+ * true, make_request will not place any more requests.  Therefore
+ * once kthread_should_stop() is true and lo_bio is NULL, we are
+ * done with the loop.
+ */
+static int loop_thread(void *data)
+{
+	struct loop_device *lo = data;
+	struct bio *bio;
+
+	set_user_nice(current, -20);
+
+	while (!kthread_should_stop() || !bio_list_empty(&lo->lo_bio_list)) {
+
+		wait_event_interruptible(lo->lo_event,
+				!bio_list_empty(&lo->lo_bio_list) ||
+				kthread_should_stop());
+
+		if (bio_list_empty(&lo->lo_bio_list))
+			continue;
+		spin_lock_irq(&lo->lo_lock);
+		bio = loop_get_bio(lo);
+		spin_unlock_irq(&lo->lo_lock);
+
+		BUG_ON(!bio);
+		loop_handle_bio(lo, bio);
+	}
+
+	return 0;
+}
+
+/*
+ * loop_switch performs the hard work of switching a backing store.
+ * First it needs to flush existing IO, it does this by sending a magic
+ * BIO down the pipe. The completion of this BIO does the actual switch.
+ */
+static int loop_switch(struct loop_device *lo, struct file *file)
+{
+	struct switch_request w;
+	struct bio *bio = bio_alloc(GFP_KERNEL, 0);
+	if (!bio)
+		return -ENOMEM;
+	init_completion(&w.wait);
+	w.file = file;
+	bio->bi_private = &w;
+	bio->bi_bdev = NULL;
+	loop_make_request(lo->lo_queue, bio);
+	wait_for_completion(&w.wait);
+	return 0;
+}
+
+/*
+ * Helper to flush the IOs in loop, but keeping loop thread running
+ */
+static int loop_flush(struct loop_device *lo)
+{
+	/* loop not yet configured, no running thread, nothing to flush */
+	if (!lo->lo_thread)
+		return 0;
+
+	return loop_switch(lo, NULL);
+}
+
+/*
+ * Do the actual switch; called from the BIO completion routine
+ */
+static void do_loop_switch(struct loop_device *lo, struct switch_request *p)
+{
+	struct file *file = p->file;
+	struct file *old_file = lo->lo_backing_file;
+	struct address_space *mapping;
+
+	/* if no new file, only flush of queued bios requested */
+	if (!file)
+		goto out;
+
+	mapping = file->f_mapping;
+	mapping_set_gfp_mask(old_file->f_mapping, lo->old_gfp_mask);
+	lo->lo_backing_file = file;
+	lo->lo_blocksize = S_ISBLK(mapping->host->i_mode) ?
+		mapping->host->i_bdev->bd_block_size : PAGE_SIZE;
+	lo->old_gfp_mask = mapping_gfp_mask(mapping);
+	mapping_set_gfp_mask(mapping, lo->old_gfp_mask & ~(__GFP_IO|__GFP_FS));
+out:
+	complete(&p->wait);
+}
+
+
+/*
+ * loop_change_fd switched the backing store of a loopback device to
+ * a new file. This is useful for operating system installers to free up
+ * the original file and in High Availability environments to switch to
+ * an alternative location for the content in case of server meltdown.
+ * This can only work if the loop device is used read-only, and if the
+ * new backing store is the same size and type as the old backing store.
+ */
+static int loop_change_fd(struct loop_device *lo, struct block_device *bdev,
+			  unsigned int arg)
+{
+	struct file	*file, *old_file;
+	struct inode	*inode;
+	int		error;
+
+	error = -ENXIO;
+	if (lo->lo_state != Lo_bound)
+		goto out;
+
+	/* the loop device has to be read-only */
+	error = -EINVAL;
+	if (!(lo->lo_flags & LO_FLAGS_READ_ONLY))
+		goto out;
+
+	error = -EBADF;
+	file = fget(arg);
+	if (!file)
+		goto out;
+
+	inode = file->f_mapping->host;
+	old_file = lo->lo_backing_file;
+
+	error = -EINVAL;
+
+	if (!S_ISREG(inode->i_mode) && !S_ISBLK(inode->i_mode))
+		goto out_putf;
+
+	/* size of the new backing store needs to be the same */
+	if (get_loop_size(lo, file) != get_loop_size(lo, old_file))
+		goto out_putf;
+
+	/* and ... switch */
+	error = loop_switch(lo, file);
+	if (error)
+		goto out_putf;
+
+	fput(old_file);
+	if (max_part > 0)
+		ioctl_by_bdev(bdev, BLKRRPART, 0);
+	return 0;
+
+ out_putf:
+	fput(file);
+ out:
+	return error;
+}
+
+static inline int is_loop_device(struct file *file)
+{
+	struct inode *i = file->f_mapping->host;
+
+	return i && S_ISBLK(i->i_mode) && MAJOR(i->i_rdev) == LOOP_MAJOR;
+}
+
+static int loop_set_fd(struct loop_device *lo, fmode_t mode,
+		       struct block_device *bdev, unsigned int arg)
+{
+	struct file	*file, *f;
+	struct inode	*inode;
+	struct address_space *mapping;
+	unsigned lo_blocksize;
+	int		lo_flags = 0;
+	int		error;
+	loff_t		size;
+
+	/* This is safe, since we have a reference from open(). */
+	__module_get(THIS_MODULE);
+
+	error = -EBADF;
+	file = fget(arg);
+	if (!file)
+		goto out;
+
+	error = -EBUSY;
+	if (lo->lo_state != Lo_unbound)
+		goto out_putf;
+
+	/* Avoid recursion */
+	f = file;
+	while (is_loop_device(f)) {
+		struct loop_device *l;
+
+		if (f->f_mapping->host->i_bdev == bdev)
+			goto out_putf;
+
+		l = f->f_mapping->host->i_bdev->bd_disk->private_data;
+		if (l->lo_state == Lo_unbound) {
+			error = -EINVAL;
+			goto out_putf;
+		}
+		f = l->lo_backing_file;
+	}
+
+	mapping = file->f_mapping;
+	inode = mapping->host;
+
+	if (!(file->f_mode & FMODE_WRITE))
+		lo_flags |= LO_FLAGS_READ_ONLY;
+
+	error = -EINVAL;
+	if (S_ISREG(inode->i_mode) || S_ISBLK(inode->i_mode)) {
+		const struct address_space_operations *aops = mapping->a_ops;
+
+		if (aops->write_begin)
+			lo_flags |= LO_FLAGS_USE_AOPS;
+		if (!(lo_flags & LO_FLAGS_USE_AOPS) && !file->f_op->write)
+			lo_flags |= LO_FLAGS_READ_ONLY;
+
+		lo_blocksize = S_ISBLK(inode->i_mode) ?
+			inode->i_bdev->bd_block_size : PAGE_SIZE;
+
+		error = 0;
+	} else {
+		goto out_putf;
+	}
+
+	size = get_loop_size(lo, file);
+
+	if ((loff_t)(sector_t)size != size) {
+		error = -EFBIG;
+		goto out_putf;
+	}
+
+	if (!(mode & FMODE_WRITE))
+		lo_flags |= LO_FLAGS_READ_ONLY;
+
+	set_device_ro(bdev, (lo_flags & LO_FLAGS_READ_ONLY) != 0);
+
+	lo->lo_blocksize = lo_blocksize;
+	lo->lo_device = bdev;
+	lo->lo_flags = lo_flags;
+	lo->lo_backing_file = file;
+	lo->transfer = transfer_none;
+	lo->ioctl = NULL;
+	lo->lo_sizelimit = 0;
+	lo->old_gfp_mask = mapping_gfp_mask(mapping);
+	mapping_set_gfp_mask(mapping, lo->old_gfp_mask & ~(__GFP_IO|__GFP_FS));
+
+	bio_list_init(&lo->lo_bio_list);
+
+	/*
+	 * set queue make_request_fn, and add limits based on lower level
+	 * device
+	 */
+	blk_queue_make_request(lo->lo_queue, loop_make_request);
+	lo->lo_queue->queuedata = lo;
+	lo->lo_queue->unplug_fn = loop_unplug;
+
+	if (!(lo_flags & LO_FLAGS_READ_ONLY) && file->f_op->fsync)
+		blk_queue_ordered(lo->lo_queue, QUEUE_ORDERED_DRAIN, NULL);
+
+	set_capacity(lo->lo_disk, size);
+	bd_set_size(bdev, size << 9);
+
+	set_blocksize(bdev, lo_blocksize);
+
+	lo->lo_thread = kthread_create(loop_thread, lo, "loop%d",
+						lo->lo_number);
+	if (IS_ERR(lo->lo_thread)) {
+		error = PTR_ERR(lo->lo_thread);
+		goto out_clr;
+	}
+	lo->lo_state = Lo_bound;
+	wake_up_process(lo->lo_thread);
+	if (max_part > 0)
+		ioctl_by_bdev(bdev, BLKRRPART, 0);
+	return 0;
+
+out_clr:
+	lo->lo_thread = NULL;
+	lo->lo_device = NULL;
+	lo->lo_backing_file = NULL;
+	lo->lo_flags = 0;
+	set_capacity(lo->lo_disk, 0);
+	invalidate_bdev(bdev);
+	bd_set_size(bdev, 0);
+	mapping_set_gfp_mask(mapping, lo->old_gfp_mask);
+	lo->lo_state = Lo_unbound;
+ out_putf:
+	fput(file);
+ out:
+	/* This is safe: open() is still holding a reference. */
+	module_put(THIS_MODULE);
+	return error;
+}
+
+static int
+loop_release_xfer(struct loop_device *lo)
+{
+	int err = 0;
+	struct loop_func_table *xfer = lo->lo_encryption;
+
+	if (xfer) {
+		if (xfer->release)
+			err = xfer->release(lo);
+		lo->transfer = NULL;
+		lo->lo_encryption = NULL;
+		module_put(xfer->owner);
+	}
+	return err;
+}
+
+static int
+loop_init_xfer(struct loop_device *lo, struct loop_func_table *xfer,
+	       const struct loop_info64 *i)
+{
+	int err = 0;
+
+	if (xfer) {
+		struct module *owner = xfer->owner;
+
+		if (!try_module_get(owner))
+			return -EINVAL;
+		if (xfer->init)
+			err = xfer->init(lo, i);
+		if (err)
+			module_put(owner);
+		else
+			lo->lo_encryption = xfer;
+	}
+	return err;
+}
+
+static int loop_clr_fd(struct loop_device *lo, struct block_device *bdev)
+{
+	struct file *filp = lo->lo_backing_file;
+	gfp_t gfp = lo->old_gfp_mask;
+
+	if (lo->lo_state != Lo_bound)
+		return -ENXIO;
+
+	if (lo->lo_refcnt > 1)	/* we needed one fd for the ioctl */
+		return -EBUSY;
+
+	if (filp == NULL)
+		return -EINVAL;
+
+	spin_lock_irq(&lo->lo_lock);
+	lo->lo_state = Lo_rundown;
+	spin_unlock_irq(&lo->lo_lock);
+
+	kthread_stop(lo->lo_thread);
+
+	lo->lo_queue->unplug_fn = NULL;
+	lo->lo_backing_file = NULL;
+
+	loop_release_xfer(lo);
+	lo->transfer = NULL;
+	lo->ioctl = NULL;
+	lo->lo_device = NULL;
+	lo->lo_encryption = NULL;
+	lo->lo_offset = 0;
+	lo->lo_sizelimit = 0;
+	lo->lo_encrypt_key_size = 0;
+	lo->lo_flags = 0;
+	lo->lo_thread = NULL;
+	memset(lo->lo_encrypt_key, 0, LO_KEY_SIZE);
+	memset(lo->lo_crypt_name, 0, LO_NAME_SIZE);
+	memset(lo->lo_file_name, 0, LO_NAME_SIZE);
+	if (bdev)
+		invalidate_bdev(bdev);
+	set_capacity(lo->lo_disk, 0);
+	if (bdev)
+		bd_set_size(bdev, 0);
+	mapping_set_gfp_mask(filp->f_mapping, gfp);
+	lo->lo_state = Lo_unbound;
+	/* This is safe: open() is still holding a reference. */
+	module_put(THIS_MODULE);
+	if (max_part > 0 && bdev)
+		ioctl_by_bdev(bdev, BLKRRPART, 0);
+	mutex_unlock(&lo->lo_ctl_mutex);
+	/*
+	 * Need not hold lo_ctl_mutex to fput backing file.
+	 * Calling fput holding lo_ctl_mutex triggers a circular
+	 * lock dependency possibility warning as fput can take
+	 * bd_mutex which is usually taken before lo_ctl_mutex.
+	 */
+	fput(filp);
+	return 0;
+}
+
+static int
+loop_set_status(struct loop_device *lo, const struct loop_info64 *info)
+{
+	int err;
+	struct loop_func_table *xfer;
+	uid_t uid = current_uid();
+
+	if (lo->lo_encrypt_key_size &&
+	    lo->lo_key_owner != uid &&
+	    !capable(CAP_SYS_ADMIN))
+		return -EPERM;
+	if (lo->lo_state != Lo_bound)
+		return -ENXIO;
+	if ((unsigned int) info->lo_encrypt_key_size > LO_KEY_SIZE)
+		return -EINVAL;
+
+	err = loop_release_xfer(lo);
+	if (err)
+		return err;
+
+	if (info->lo_encrypt_type) {
+		unsigned int type = info->lo_encrypt_type;
+
+		if (type >= MAX_LO_CRYPT)
+			return -EINVAL;
+		xfer = xfer_funcs[type];
+		if (xfer == NULL)
+			return -EINVAL;
+	} else
+		xfer = NULL;
+
+	err = loop_init_xfer(lo, xfer, info);
+	if (err)
+		return err;
+
+	if (lo->lo_offset != info->lo_offset ||
+	    lo->lo_sizelimit != info->lo_sizelimit) {
+		lo->lo_offset = info->lo_offset;
+		lo->lo_sizelimit = info->lo_sizelimit;
+		if (figure_loop_size(lo))
+			return -EFBIG;
+	}
+
+	memcpy(lo->lo_file_name, info->lo_file_name, LO_NAME_SIZE);
+	memcpy(lo->lo_crypt_name, info->lo_crypt_name, LO_NAME_SIZE);
+	lo->lo_file_name[LO_NAME_SIZE-1] = 0;
+	lo->lo_crypt_name[LO_NAME_SIZE-1] = 0;
+
+	if (!xfer)
+		xfer = &none_funcs;
+	lo->transfer = xfer->transfer;
+	lo->ioctl = xfer->ioctl;
+
+	if ((lo->lo_flags & LO_FLAGS_AUTOCLEAR) !=
+	     (info->lo_flags & LO_FLAGS_AUTOCLEAR))
+		lo->lo_flags ^= LO_FLAGS_AUTOCLEAR;
+
+	lo->lo_encrypt_key_size = info->lo_encrypt_key_size;
+	lo->lo_init[0] = info->lo_init[0];
+	lo->lo_init[1] = info->lo_init[1];
+	if (info->lo_encrypt_key_size) {
+		memcpy(lo->lo_encrypt_key, info->lo_encrypt_key,
+		       info->lo_encrypt_key_size);
+		lo->lo_key_owner = uid;
+	}	
+
+	return 0;
+}
+
+static int
+loop_get_status(struct loop_device *lo, struct loop_info64 *info)
+{
+	struct file *file = lo->lo_backing_file;
+	struct kstat stat;
+	int error;
+
+	if (lo->lo_state != Lo_bound)
+		return -ENXIO;
+	error = vfs_getattr(file->f_path.mnt, file->f_path.dentry, &stat);
+	if (error)
+		return error;
+	C2_SET0(info);
+	info->lo_number = lo->lo_number;
+	info->lo_device = huge_encode_dev(stat.dev);
+	info->lo_inode = stat.ino;
+	info->lo_rdevice = huge_encode_dev(lo->lo_device ? stat.rdev : stat.dev);
+	info->lo_offset = lo->lo_offset;
+	info->lo_sizelimit = lo->lo_sizelimit;
+	info->lo_flags = lo->lo_flags;
+	memcpy(info->lo_file_name, lo->lo_file_name, LO_NAME_SIZE);
+	memcpy(info->lo_crypt_name, lo->lo_crypt_name, LO_NAME_SIZE);
+	info->lo_encrypt_type =
+		lo->lo_encryption ? lo->lo_encryption->number : 0;
+	if (lo->lo_encrypt_key_size && capable(CAP_SYS_ADMIN)) {
+		info->lo_encrypt_key_size = lo->lo_encrypt_key_size;
+		memcpy(info->lo_encrypt_key, lo->lo_encrypt_key,
+		       lo->lo_encrypt_key_size);
+	}
+	return 0;
+}
+
+static void
+loop_info64_from_old(const struct loop_info *info, struct loop_info64 *info64)
+{
+	C2_SET0(info64);
+	info64->lo_number = info->lo_number;
+	info64->lo_device = info->lo_device;
+	info64->lo_inode = info->lo_inode;
+	info64->lo_rdevice = info->lo_rdevice;
+	info64->lo_offset = info->lo_offset;
+	info64->lo_sizelimit = 0;
+	info64->lo_encrypt_type = info->lo_encrypt_type;
+	info64->lo_encrypt_key_size = info->lo_encrypt_key_size;
+	info64->lo_flags = info->lo_flags;
+	info64->lo_init[0] = info->lo_init[0];
+	info64->lo_init[1] = info->lo_init[1];
+	if (info->lo_encrypt_type == LO_CRYPT_CRYPTOAPI)
+		memcpy(info64->lo_crypt_name, info->lo_name, LO_NAME_SIZE);
+	else
+		memcpy(info64->lo_file_name, info->lo_name, LO_NAME_SIZE);
+	memcpy(info64->lo_encrypt_key, info->lo_encrypt_key, LO_KEY_SIZE);
+}
+
+static int
+loop_info64_to_old(const struct loop_info64 *info64, struct loop_info *info)
+{
+	C2_SET0(info);
+	info->lo_number = info64->lo_number;
+	info->lo_device = info64->lo_device;
+	info->lo_inode = info64->lo_inode;
+	info->lo_rdevice = info64->lo_rdevice;
+	info->lo_offset = info64->lo_offset;
+	info->lo_encrypt_type = info64->lo_encrypt_type;
+	info->lo_encrypt_key_size = info64->lo_encrypt_key_size;
+	info->lo_flags = info64->lo_flags;
+	info->lo_init[0] = info64->lo_init[0];
+	info->lo_init[1] = info64->lo_init[1];
+	if (info->lo_encrypt_type == LO_CRYPT_CRYPTOAPI)
+		memcpy(info->lo_name, info64->lo_crypt_name, LO_NAME_SIZE);
+	else
+		memcpy(info->lo_name, info64->lo_file_name, LO_NAME_SIZE);
+	memcpy(info->lo_encrypt_key, info64->lo_encrypt_key, LO_KEY_SIZE);
+
+	/* error in case values were truncated */
+	if (info->lo_device != info64->lo_device ||
+	    info->lo_rdevice != info64->lo_rdevice ||
+	    info->lo_inode != info64->lo_inode ||
+	    info->lo_offset != info64->lo_offset)
+		return -EOVERFLOW;
+
+	return 0;
+}
+
+static int
+loop_set_status_old(struct loop_device *lo, const struct loop_info __user *arg)
+{
+	struct loop_info info;
+	struct loop_info64 info64;
+
+	if (copy_from_user(&info, arg, sizeof (struct loop_info)))
+		return -EFAULT;
+	loop_info64_from_old(&info, &info64);
+	return loop_set_status(lo, &info64);
+}
+
+static int
+loop_set_status64(struct loop_device *lo, const struct loop_info64 __user *arg)
+{
+	struct loop_info64 info64;
+
+	if (copy_from_user(&info64, arg, sizeof (struct loop_info64)))
+		return -EFAULT;
+	return loop_set_status(lo, &info64);
+}
+
+static int
+loop_get_status_old(struct loop_device *lo, struct loop_info __user *arg) {
+	struct loop_info info;
+	struct loop_info64 info64;
+	int err = 0;
+
+	if (!arg)
+		err = -EINVAL;
+	if (!err)
+		err = loop_get_status(lo, &info64);
+	if (!err)
+		err = loop_info64_to_old(&info64, &info);
+	if (!err && copy_to_user(arg, &info, sizeof(info)))
+		err = -EFAULT;
+
+	return err;
+}
+
+static int
+loop_get_status64(struct loop_device *lo, struct loop_info64 __user *arg) {
+	struct loop_info64 info64;
+	int err = 0;
+
+	if (!arg)
+		err = -EINVAL;
+	if (!err)
+		err = loop_get_status(lo, &info64);
+	if (!err && copy_to_user(arg, &info64, sizeof(info64)))
+		err = -EFAULT;
+
+	return err;
+}
+
+static int loop_set_capacity(struct loop_device *lo, struct block_device *bdev)
+{
+	int err;
+	sector_t sec;
+	loff_t sz;
+
+	err = -ENXIO;
+	if (unlikely(lo->lo_state != Lo_bound))
+		goto out;
+	err = figure_loop_size(lo);
+	if (unlikely(err))
+		goto out;
+	sec = get_capacity(lo->lo_disk);
+	/* the width of sector_t may be narrow for bit-shift */
+	sz = sec;
+	sz <<= 9;
+	mutex_lock(&bdev->bd_mutex);
+	bd_set_size(bdev, sz);
+	mutex_unlock(&bdev->bd_mutex);
+
+ out:
+	return err;
+}
+
+static int lo_ioctl(struct block_device *bdev, fmode_t mode,
+	unsigned int cmd, unsigned long arg)
+{
+	struct loop_device *lo = bdev->bd_disk->private_data;
+	int err;
+
+	mutex_lock_nested(&lo->lo_ctl_mutex, 1);
+	switch (cmd) {
+	case LOOP_SET_FD:
+		err = loop_set_fd(lo, mode, bdev, arg);
+		break;
+	case LOOP_CHANGE_FD:
+		err = loop_change_fd(lo, bdev, arg);
+		break;
+	case LOOP_CLR_FD:
+		/* loop_clr_fd would have unlocked lo_ctl_mutex on success */
+		err = loop_clr_fd(lo, bdev);
+		if (!err)
+			goto out_unlocked;
+		break;
+	case LOOP_SET_STATUS:
+		err = loop_set_status_old(lo, (struct loop_info __user *) arg);
+		break;
+	case LOOP_GET_STATUS:
+		err = loop_get_status_old(lo, (struct loop_info __user *) arg);
+		break;
+	case LOOP_SET_STATUS64:
+		err = loop_set_status64(lo, (struct loop_info64 __user *) arg);
+		break;
+	case LOOP_GET_STATUS64:
+		err = loop_get_status64(lo, (struct loop_info64 __user *) arg);
+		break;
+	case LOOP_SET_CAPACITY:
+		err = -EPERM;
+		if ((mode & FMODE_WRITE) || capable(CAP_SYS_ADMIN))
+			err = loop_set_capacity(lo, bdev);
+		break;
+	default:
+		err = lo->ioctl ? lo->ioctl(lo, cmd, arg) : -EINVAL;
+	}
+	mutex_unlock(&lo->lo_ctl_mutex);
+
+out_unlocked:
+	return err;
+}
+
+#ifdef CONFIG_COMPAT
+struct compat_loop_info {
+	compat_int_t	lo_number;      /* ioctl r/o */
+	compat_dev_t	lo_device;      /* ioctl r/o */
+	compat_ulong_t	lo_inode;       /* ioctl r/o */
+	compat_dev_t	lo_rdevice;     /* ioctl r/o */
+	compat_int_t	lo_offset;
+	compat_int_t	lo_encrypt_type;
+	compat_int_t	lo_encrypt_key_size;    /* ioctl w/o */
+	compat_int_t	lo_flags;       /* ioctl r/o */
+	char		lo_name[LO_NAME_SIZE];
+	unsigned char	lo_encrypt_key[LO_KEY_SIZE]; /* ioctl w/o */
+	compat_ulong_t	lo_init[2];
+	char		reserved[4];
+};
+
+/*
+ * Transfer 32-bit compatibility structure in userspace to 64-bit loop info
+ * - noinlined to reduce stack space usage in main part of driver
+ */
+static noinline int
+loop_info64_from_compat(const struct compat_loop_info __user *arg,
+			struct loop_info64 *info64)
+{
+	struct compat_loop_info info;
+
+	if (copy_from_user(&info, arg, sizeof(info)))
+		return -EFAULT;
+
+	C2_SET0(info64);
+	info64->lo_number = info.lo_number;
+	info64->lo_device = info.lo_device;
+	info64->lo_inode = info.lo_inode;
+	info64->lo_rdevice = info.lo_rdevice;
+	info64->lo_offset = info.lo_offset;
+	info64->lo_sizelimit = 0;
+	info64->lo_encrypt_type = info.lo_encrypt_type;
+	info64->lo_encrypt_key_size = info.lo_encrypt_key_size;
+	info64->lo_flags = info.lo_flags;
+	info64->lo_init[0] = info.lo_init[0];
+	info64->lo_init[1] = info.lo_init[1];
+	if (info.lo_encrypt_type == LO_CRYPT_CRYPTOAPI)
+		memcpy(info64->lo_crypt_name, info.lo_name, LO_NAME_SIZE);
+	else
+		memcpy(info64->lo_file_name, info.lo_name, LO_NAME_SIZE);
+	memcpy(info64->lo_encrypt_key, info.lo_encrypt_key, LO_KEY_SIZE);
+	return 0;
+}
+
+/*
+ * Transfer 64-bit loop info to 32-bit compatibility structure in userspace
+ * - noinlined to reduce stack space usage in main part of driver
+ */
+static noinline int
+loop_info64_to_compat(const struct loop_info64 *info64,
+		      struct compat_loop_info __user *arg)
+{
+	struct compat_loop_info info;
+
+	C2_SET0(&info);
+	info.lo_number = info64->lo_number;
+	info.lo_device = info64->lo_device;
+	info.lo_inode = info64->lo_inode;
+	info.lo_rdevice = info64->lo_rdevice;
+	info.lo_offset = info64->lo_offset;
+	info.lo_encrypt_type = info64->lo_encrypt_type;
+	info.lo_encrypt_key_size = info64->lo_encrypt_key_size;
+	info.lo_flags = info64->lo_flags;
+	info.lo_init[0] = info64->lo_init[0];
+	info.lo_init[1] = info64->lo_init[1];
+	if (info.lo_encrypt_type == LO_CRYPT_CRYPTOAPI)
+		memcpy(info.lo_name, info64->lo_crypt_name, LO_NAME_SIZE);
+	else
+		memcpy(info.lo_name, info64->lo_file_name, LO_NAME_SIZE);
+	memcpy(info.lo_encrypt_key, info64->lo_encrypt_key, LO_KEY_SIZE);
+
+	/* error in case values were truncated */
+	if (info.lo_device != info64->lo_device ||
+	    info.lo_rdevice != info64->lo_rdevice ||
+	    info.lo_inode != info64->lo_inode ||
+	    info.lo_offset != info64->lo_offset ||
+	    info.lo_init[0] != info64->lo_init[0] ||
+	    info.lo_init[1] != info64->lo_init[1])
+		return -EOVERFLOW;
+
+	if (copy_to_user(arg, &info, sizeof(info)))
+		return -EFAULT;
+	return 0;
+}
+
+static int
+loop_set_status_compat(struct loop_device *lo,
+		       const struct compat_loop_info __user *arg)
+{
+	struct loop_info64 info64;
+	int ret;
+
+	ret = loop_info64_from_compat(arg, &info64);
+	if (ret < 0)
+		return ret;
+	return loop_set_status(lo, &info64);
+}
+
+static int
+loop_get_status_compat(struct loop_device *lo,
+		       struct compat_loop_info __user *arg)
+{
+	struct loop_info64 info64;
+	int err = 0;
+
+	if (!arg)
+		err = -EINVAL;
+	if (!err)
+		err = loop_get_status(lo, &info64);
+	if (!err)
+		err = loop_info64_to_compat(&info64, arg);
+	return err;
+}
+
+static int lo_compat_ioctl(struct block_device *bdev, fmode_t mode,
+			   unsigned int cmd, unsigned long arg)
+{
+	struct loop_device *lo = bdev->bd_disk->private_data;
+	int err;
+
+	switch(cmd) {
+	case LOOP_SET_STATUS:
+		mutex_lock(&lo->lo_ctl_mutex);
+		err = loop_set_status_compat(
+			lo, (const struct compat_loop_info __user *) arg);
+		mutex_unlock(&lo->lo_ctl_mutex);
+		break;
+	case LOOP_GET_STATUS:
+		mutex_lock(&lo->lo_ctl_mutex);
+		err = loop_get_status_compat(
+			lo, (struct compat_loop_info __user *) arg);
+		mutex_unlock(&lo->lo_ctl_mutex);
+		break;
+	case LOOP_SET_CAPACITY:
+	case LOOP_CLR_FD:
+	case LOOP_GET_STATUS64:
+	case LOOP_SET_STATUS64:
+		arg = (unsigned long) compat_ptr(arg);
+	case LOOP_SET_FD:
+	case LOOP_CHANGE_FD:
+		err = lo_ioctl(bdev, mode, cmd, arg);
+		break;
+	default:
+		err = -ENOIOCTLCMD;
+		break;
+	}
+	return err;
+}
+#endif
+
+static int lo_open(struct block_device *bdev, fmode_t mode)
+{
+	struct loop_device *lo = bdev->bd_disk->private_data;
+
+	mutex_lock(&lo->lo_ctl_mutex);
+	lo->lo_refcnt++;
+	mutex_unlock(&lo->lo_ctl_mutex);
+
+	return 0;
+}
+
+static int lo_release(struct gendisk *disk, fmode_t mode)
+{
+	struct loop_device *lo = disk->private_data;
+	int err;
+
+	mutex_lock(&lo->lo_ctl_mutex);
+
+	if (--lo->lo_refcnt)
+		goto out;
+
+	if (lo->lo_flags & LO_FLAGS_AUTOCLEAR) {
+		/*
+		 * In autoclear mode, stop the loop thread
+		 * and remove configuration after last close.
+		 */
+		err = loop_clr_fd(lo, NULL);
+		if (!err)
+			goto out_unlocked;
+	} else {
+		/*
+		 * Otherwise keep thread (if running) and config,
+		 * but flush possible ongoing bios in thread.
+		 */
+		loop_flush(lo);
+	}
+
+out:
+	mutex_unlock(&lo->lo_ctl_mutex);
+out_unlocked:
+	return 0;
+}
+
+static const struct block_device_operations lo_fops = {
+	.owner =	THIS_MODULE,
+	.open =		lo_open,
+	.release =	lo_release,
+	.ioctl =	lo_ioctl,
+#ifdef CONFIG_COMPAT
+	.compat_ioctl =	lo_compat_ioctl,
+#endif
+};
+
+/*
+ * And now the modules code and kernel interface.
+ */
+static int max_loop;
+module_param(max_loop, int, 0);
+MODULE_PARM_DESC(max_loop, "Maximum number of loop devices");
+module_param(max_part, int, 0);
+MODULE_PARM_DESC(max_part, "Maximum number of partitions per loop device");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS_BLOCKDEV_MAJOR(LOOP_MAJOR);
+
+int loop_register_transfer(struct loop_func_table *funcs)
+{
+	unsigned int n = funcs->number;
+
+	if (n >= MAX_LO_CRYPT || xfer_funcs[n])
+		return -EINVAL;
+	xfer_funcs[n] = funcs;
+	return 0;
+}
+
+int loop_unregister_transfer(int number)
+{
+	unsigned int n = number;
+	struct loop_device *lo;
+	struct loop_func_table *xfer;
+
+	if (n == 0 || n >= MAX_LO_CRYPT || (xfer = xfer_funcs[n]) == NULL)
+		return -EINVAL;
+
+	xfer_funcs[n] = NULL;
+
+	list_for_each_entry(lo, &loop_devices, lo_list) {
+		mutex_lock(&lo->lo_ctl_mutex);
+
+		if (lo->lo_encryption == xfer)
+			loop_release_xfer(lo);
+
+		mutex_unlock(&lo->lo_ctl_mutex);
+	}
+
+	return 0;
+}
+
+C2_EXPORTED(loop_register_transfer);
+C2_EXPORTED(loop_unregister_transfer);
+
+static struct loop_device *loop_alloc(int i)
+{
+	struct loop_device *lo;
+	struct gendisk *disk;
+
+	lo = kzalloc(sizeof(*lo), GFP_KERNEL);
+	if (!lo)
+		goto out;
+
+	lo->lo_queue = blk_alloc_queue(GFP_KERNEL);
+	if (!lo->lo_queue)
+		goto out_free_dev;
+
+	disk = lo->lo_disk = alloc_disk(1 << part_shift);
+	if (!disk)
+		goto out_free_queue;
+
+	mutex_init(&lo->lo_ctl_mutex);
+	lo->lo_number		= i;
+	lo->lo_thread		= NULL;
+	init_waitqueue_head(&lo->lo_event);
+	spin_lock_init(&lo->lo_lock);
+	disk->major		= LOOP_MAJOR;
+	disk->first_minor	= i << part_shift;
+	disk->fops		= &lo_fops;
+	disk->private_data	= lo;
+	disk->queue		= lo->lo_queue;
+	sprintf(disk->disk_name, "loop%d", i);
+	return lo;
+
+out_free_queue:
+	blk_cleanup_queue(lo->lo_queue);
+out_free_dev:
+	kfree(lo);
+out:
+	return NULL;
+}
+
+static void loop_free(struct loop_device *lo)
+{
+	blk_cleanup_queue(lo->lo_queue);
+	put_disk(lo->lo_disk);
+	list_del(&lo->lo_list);
+	kfree(lo);
+}
+
+static struct loop_device *loop_init_one(int i)
+{
+	struct loop_device *lo;
+
+	list_for_each_entry(lo, &loop_devices, lo_list) {
+		if (lo->lo_number == i)
+			return lo;
+	}
+
+	lo = loop_alloc(i);
+	if (lo) {
+		add_disk(lo->lo_disk);
+		list_add_tail(&lo->lo_list, &loop_devices);
+	}
+	return lo;
+}
+
+static void loop_del_one(struct loop_device *lo)
+{
+	del_gendisk(lo->lo_disk);
+	loop_free(lo);
+}
+
+static struct kobject *loop_probe(dev_t dev, int *part, void *data)
+{
+	struct loop_device *lo;
+	struct kobject *kobj;
+
+	mutex_lock(&loop_devices_mutex);
+	lo = loop_init_one(dev & MINORMASK);
+	kobj = lo ? get_disk(lo->lo_disk) : ERR_PTR(-ENOMEM);
+	mutex_unlock(&loop_devices_mutex);
+
+	*part = 0;
+	return kobj;
+}
+
+static int __init loop_init(void)
+{
+	int i, nr;
+	unsigned long range;
+	struct loop_device *lo, *next;
+
+	/*
+	 * loop module now has a feature to instantiate underlying device
+	 * structure on-demand, provided that there is an access dev node.
+	 * However, this will not work well with user space tool that doesn't
+	 * know about such "feature".  In order to not break any existing
+	 * tool, we do the following:
+	 *
+	 * (1) if max_loop is specified, create that many upfront, and this
+	 *     also becomes a hard limit.
+	 * (2) if max_loop is not specified, create 8 loop device on module
+	 *     load, user can further extend loop device by create dev node
+	 *     themselves and have kernel automatically instantiate actual
+	 *     device on-demand.
+	 */
+
+	part_shift = 0;
+	if (max_part > 0)
+		part_shift = fls(max_part);
+
+	if (max_loop > 1UL << (MINORBITS - part_shift))
+		return -EINVAL;
+
+	if (max_loop) {
+		nr = max_loop;
+		range = max_loop;
+	} else {
+		nr = 8;
+		range = 1UL << (MINORBITS - part_shift);
+	}
+
+	if (register_blkdev(LOOP_MAJOR, "loop"))
+		return -EIO;
+
+	for (i = 0; i < nr; i++) {
+		lo = loop_alloc(i);
+		if (!lo)
+			goto Enomem;
+		list_add_tail(&lo->lo_list, &loop_devices);
+	}
+
+	/* point of no return */
+
+	list_for_each_entry(lo, &loop_devices, lo_list)
+		add_disk(lo->lo_disk);
+
+	blk_register_region(MKDEV(LOOP_MAJOR, 0), range,
+				  THIS_MODULE, loop_probe, NULL, NULL);
+
+	printk(KERN_INFO "loop: module loaded\n");
+	return 0;
+
+Enomem:
+	printk(KERN_INFO "loop: out of memory\n");
+
+	list_for_each_entry_safe(lo, next, &loop_devices, lo_list)
+		loop_free(lo);
+
+	unregister_blkdev(LOOP_MAJOR, "loop");
+	return -ENOMEM;
+}
+
+static void __exit loop_exit(void)
+{
+	unsigned long range;
+	struct loop_device *lo, *next;
+
+	range = max_loop ? max_loop :  1UL << (MINORBITS - part_shift);
+
+	list_for_each_entry_safe(lo, next, &loop_devices, lo_list)
+		loop_del_one(lo);
+
+	blk_unregister_region(MKDEV(LOOP_MAJOR, 0), range);
+	unregister_blkdev(LOOP_MAJOR, "loop");
+}
+
+module_init(loop_init);
+module_exit(loop_exit);
+
+#ifndef MODULE
+static int __init max_loop_setup(char *str)
+{
+	max_loop = simple_strtol(str, NULL, 0);
+	return 1;
+}
+
+__setup("max_loop=", max_loop_setup);
+#endif
diff --git a/c2t1fs/main.c b/c2t1fs/main.c
new file mode 100644
index 0000000..6f8ab7e
--- /dev/null
+++ b/c2t1fs/main.c
@@ -0,0 +1,1545 @@
+/*
+ * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: Yuriy Umanets <yuriy_umanets@xyratex.com>
+ *		    Huang Hua <hua_huang@xyratex.com>
+ *		    Anatoliy Belinko
+ * Original creation date: 05/04/2010
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/slab.h>
+#include <linux/fs.h>
+#include <linux/mount.h>
+#include <linux/smp_lock.h>
+#include <linux/vfs.h>
+#include <linux/uio.h>
+#include <linux/inet.h>
+#include <linux/in.h>
+
+#include "lib/misc.h"  /* C2_SET0 */
+#include "lib/memory.h"
+#include "lib/errno.h"
+#include "lib/arith.h"
+#include "fop/fop.h"
+
+#include "c2t1fs.h"
+#include "io_k.h"
+#include "io_fops_k.h"
+
+#include "stob/ut/io_fop.h"
+#include "sns/parity_math.h"
+#include "layout/pdclust.h"
+#include "pool/pool.h"
+#include "lib/buf.h"
+#include "io_fops.h"
+
+#define DBG(fmt, args...) printk("%s:%d " fmt, __FUNCTION__, __LINE__, ##args)
+
+/**
+   @page c2t1fs C2T1FS detailed level design specification.
+
+   @section Overview
+
+   C2T1FS is native linux nodev file system, which lies exactly between colibri
+   block device and colibri servers. It is in fact client file system for the
+   colibri cluster.
+
+   It is decided that colibri block device is based on loop.c loop back driver.
+   This dictates, despite the requirements, specific impelementation, which will
+   be discussed below.
+
+   @section def Definitions and requirements
+
+   Here is brief list of requirements:
+
+   @li direct IO support (all the caching is done on upper layet). In
+       our case this means no page cache in IO functions. All the IO,
+       no matter how big, gets imidiately sent to the server. Do not
+       mix it up with cache on upper layer. For example,
+       ->prepare_write and ->commit_write methods work with pages from
+       page cache but they belong to upper layer cache. When loop
+       device driver works with pages it delegates some works to
+       underlaying FS;
+
+   @li no read ahead (nothing to say more);
+
+   @li no ACL or selinux support. Unix security model (permission
+       masks) is followed with client inventing it;
+
+   @li loop back device driver with minimal changes should work and
+       losetup tool should also work with C2T1FS;
+
+   @li readdir() is only supported for root dir. A single regular file named
+       with object number is filled in the root dir.
+
+   @li read/write, readv/writev methods should work. Asynchronous
+       interface should be supported;
+
+   @li file exported by the server and which we want to use as a
+       back-end for the block device should be specified as part of
+       device specification in mount command in a way like this:
+
+       mount -t c2t1fs -o objid=<objid> ipaddr:port /mnt/c2t1fs
+
+     where objid is object id exported by the server.
+
+     If the server does not know this object - a error is returned and mount
+     fails and meaningful error is reported.
+
+   @section c2t1fsfuncspec Functional specification
+
+   There are three interaces we need to interact with:
+
+   @li linux VFS - super_block operations should have
+       c2t1fs_get_super() and c2t1fs_fill_super() methods
+       implemented. Root inode and dentry should be created in mount
+       time;
+
+   @li loop back device driver interface: ->write(),
+       ->prepare_write/commit_write() and ->sendfile() methods should be
+       implemented;
+
+   @li networking layer needs: connect/disconnect rpc. Connect should
+       have one field: obj_id, that is, what object we are attaching
+       to. We need also read/write rpcs capable to work with iovec
+       structures.
+
+   @section c2t1fslogspec Logical specification
+
+   C2T1FS is implemented as linux native nodev file system. It may be used in
+   a way like this:
+
+   modprobe c2t1fs
+   mount -t c2t1fs -o objid=<objid> ipaddr:port /mnt/c2t1fs
+   losetup /dev/loop0 /mnt/c2t1fs/$objid
+   dd if=/dev/zero of=/dev/loop0 bs=1M count=10
+
+   To support this functionality, we implement the following parts:
+
+   @li mount (super block init), which parses device name, sends
+       connect rpc to the server and creates root inode and dentry
+       upon success. We also create inode and dentry for the file
+       exported by the server. It is easier to handle wrong file id
+       during mount rather than in file IO time;
+
+   @li losetup part requires ->lookup method;
+
+   @li working IO part requires ->prepare_write/commit_write(),
+       ->sendfile() and ->write() file operations to being implemented.
+
+ */
+static struct kmem_cache     *c2t1fs_inode_cachep = NULL;
+static struct c2_net_domain  c2t1fs_domain;
+
+MODULE_AUTHOR("Yuriy V. Umanets <yuriy.umanets@clusterstor.com>, Huang Hua, Jinshan Xiong");
+MODULE_DESCRIPTION("Colibri C2T1 File System");
+MODULE_LICENSE("GPL");
+
+
+/**
+ * Global container id used to identify the corresponding
+ * component object at the server side.
+ * In future, this will be changed. 
+ */
+#define c2_global_container_id	10
+
+extern struct c2_fop_type c2_fop_cob_writev_rep_fopt;
+extern struct c2_fop_type c2_fop_cob_readv_rep_fopt;
+
+/**
+ * Some user/group identification functions to fill up 
+ * the uid/gid fields from various FOPs.
+ * These are hard coded for now. They will be replaced
+ * with proper user authorization routines in future.
+ */
+static uint64_t c2_get_uid(void)
+{
+	return (uint64_t)1234;
+}
+
+static uint64_t c2_get_gid(void)
+{
+	return (uint64_t)4321;
+}
+
+static uint64_t c2_get_nid(void)
+{
+	return (uint64_t)5678;
+}
+
+
+static int ksunrpc_read_write(struct c2_net_conn *conn,
+			      uint64_t objid, struct page **pages, int off,
+			      size_t len, loff_t pos, int rw)
+{
+        int rc;
+	struct c2_fop       *f;
+	struct c2_fop       *r;
+	struct c2_net_call  kcall;
+
+        if (rw == WRITE) {
+		struct c2_fop_cob_writev 	*arg;
+                struct c2_fop_cob_writev_rep	*ret;
+
+		f = c2_fop_alloc(&c2_fop_cob_writev_fopt, NULL);
+		r = c2_fop_alloc(&c2_fop_cob_writev_rep_fopt, NULL);
+
+		BUG_ON(f == NULL || r == NULL);
+
+		kcall.ac_arg = f;
+		kcall.ac_ret = r;
+
+		arg = c2_fop_data(f);
+		ret = c2_fop_data(r);
+
+ 		/* With introduction of FOMs, a reply FOP will be allocated 
+ 		 * by the request FOP and a pointer to it will be 
+ 		 * sent across. 
+ 		 * XXX The reply FOP pointer is not used as of now.
+ 		 */
+ 		arg->fwr_foprep 		= (uint64_t)ret;
+ 		arg->fwr_fid.f_seq		= c2_global_container_id;
+ 		arg->fwr_fid.f_oid		= objid;
+ 		arg->fwr_iovec.iov_count 	= 1;
+ 
+ 		/* Populate the vector of write FOP */
+		arg->fwr_iovec.iov_seg.f_offset = pos;
+		arg->fwr_iovec.iov_seg.f_buf.cfib_pgoff = off;
+		arg->fwr_iovec.iov_seg.f_buf.f_buf = pages;
+		arg->fwr_iovec.iov_seg.f_buf.f_count = len;
+
+ 		arg->fwr_uid = c2_get_uid();
+ 		arg->fwr_gid = c2_get_gid();
+ 		arg->fwr_nid = c2_get_nid();
+ 		arg->fwr_flags = 0;
+  
+                DBG("writing data to server(%llu/%d/%ld/%lld)\n",
+                    objid, off, len, pos);
+		rc = c2_net_cli_call(conn, &kcall);
+
+                DBG("write to server returns %d\n", rc);
+
+                if (rc)
+                        return rc;
+                rc = ret->fwrr_rc ? : ret->fwrr_count;
+        } else {
+
+ 		struct c2_fop_cob_readv		*arg;
+                struct c2_fop_cob_readv_rep	*ret;
+  
+ 		f = c2_fop_alloc(&c2_fop_cob_readv_fopt, NULL);
+ 		r = c2_fop_alloc(&c2_fop_cob_readv_rep_fopt, NULL);
+
+		BUG_ON(f == NULL || r == NULL);
+
+		kcall.ac_arg = f;
+		kcall.ac_ret = r;
+
+		arg = c2_fop_data(f);
+		ret = c2_fop_data(r);
+
+ 		/* With introduction of FOMs, a reply FOP will be allocated 
+ 		 * by the request FOP and a pointer to it will be 
+ 		 * sent across. 
+ 		 * XXX The reply FOP pointer is not used as of now.
+ 		 */
+ 		arg->frd_foprep 		= (uint64_t)ret;
+ 		arg->frd_fid.f_seq		= c2_global_container_id;
+ 		arg->frd_fid.f_oid		= objid;
+ 		arg->frd_ioseg.f_count 	= 1;
+ 
+ 		/* Populate the vector of read FOP */
+		arg->frd_ioseg.f_offset = pos;
+		arg->frd_ioseg.f_count = len;
+
+ 		arg->frd_uid = c2_get_uid();
+ 		arg->frd_gid = c2_get_gid();
+ 		arg->frd_nid = c2_get_nid();
+ 		arg->frd_flags = 0;
+
+		ret->frdr_buf.f_buf = pages;
+		ret->frdr_buf.f_count = len;
+		ret->frdr_buf.cfib_pgoff = off;
+
+                DBG("reading data from server(%llu/%d/%ld/%lld)\n",
+                    objid, off, len, pos);
+		rc = c2_net_cli_call(conn, &kcall);
+
+                DBG("read from server returns %d\n", rc);
+
+                if (rc)
+                        return rc;
+                rc = ret->frdr_rc ? : ret->frdr_buf.f_count;
+        }
+	c2_fop_free(r);
+	c2_fop_free(f);
+	return rc;
+}
+
+static int ksunrpc_create(struct c2_net_conn *conn,
+			  uint64_t objid)
+{
+        int rc;
+	struct c2_io_create      *arg;
+	struct c2_io_create_rep  *ret;
+	struct c2_fop            *f;
+	struct c2_fop            *r;
+	struct c2_net_call       kcall;
+
+	f = c2_fop_alloc(&c2_io_create_fopt, NULL);
+	r = c2_fop_alloc(&c2_io_create_rep_fopt, NULL);
+
+	BUG_ON(f == NULL || r == NULL);
+
+	kcall.ac_arg = f;
+	kcall.ac_ret = r;
+
+	arg = c2_fop_data(f);
+	ret = c2_fop_data(r);
+
+        arg->sic_object.f_seq = c2_global_container_id;
+        arg->sic_object.f_oid = objid;
+
+        DBG("%s create object %llu\n", __FUNCTION__, objid);
+	rc = c2_net_cli_call(conn, &kcall);
+        DBG("create obj returns %d/%d\n", rc, ret->sicr_rc);
+        rc = rc ? : ret->sicr_rc;
+	c2_fop_free(r);
+	c2_fop_free(f);
+	return rc;
+}
+
+static struct c2t1fs_sb_info *c2t1fs_init_csi(struct super_block *sb)
+{
+        struct c2t1fs_sb_info *csi;
+
+	csi = kmalloc(sizeof(*csi), GFP_KERNEL);
+	if (!csi)
+		return NULL;
+        s2csi_nocast(sb) = csi;
+        C2_SET0(csi);
+
+        atomic_set(&csi->csi_mounts, 1);
+	c2_mutex_init(&csi->csi_mutex);
+	c2_list_init(&csi->csi_conn_list);
+        return csi;
+}
+
+static int c2t1fs_free_csi(struct super_block *sb)
+{
+        struct c2t1fs_sb_info *csi = s2csi(sb);
+
+        kfree(csi);
+        s2csi_nocast(sb) = NULL;
+
+        return 0;
+}
+
+static int c2t1fs_put_csi(struct super_block *sb)
+{
+        struct c2t1fs_sb_info *csi = s2csi(sb);
+
+        if (atomic_dec_and_test(&csi->csi_mounts)) {
+                c2t1fs_free_csi(sb);
+                return 1;
+        }
+
+        return 0;
+}
+
+static struct inode *c2t1fs_alloc_inode(struct super_block *sb)
+{
+	struct c2t1fs_inode_info *cii;
+
+	cii = kmem_cache_alloc(c2t1fs_inode_cachep, GFP_NOFS);
+	if (!cii)
+		return NULL;
+	inode_init_once(&cii->cii_vfs_inode);
+	return &cii->cii_vfs_inode;
+}
+
+static void c2t1fs_destroy_inode(struct inode *inode)
+{
+	kmem_cache_free(c2t1fs_inode_cachep, i2cii(inode));
+}
+
+static void c2t1fs_put_super(struct super_block *sb)
+{
+        c2t1fs_put_csi(sb);
+}
+
+static int c2t1fs_statfs(struct dentry *dentry, struct kstatfs *buf)
+{
+        buf->f_type   = dentry->d_sb->s_magic;
+        buf->f_bsize  = PAGE_SIZE;
+        buf->f_blocks = 1024 * 1024;
+        buf->f_bfree  = 1024 * 1024;
+        buf->f_bavail = 1024 * 1024;
+        buf->f_namelen = NAME_MAX;
+        return 0;
+}
+
+
+struct super_operations c2t1fs_super_operations = {
+        .alloc_inode   = c2t1fs_alloc_inode,
+        .destroy_inode = c2t1fs_destroy_inode,
+        .put_super     = c2t1fs_put_super,
+        .statfs        = c2t1fs_statfs,
+};
+
+static int pdclust_layout_init(struct c2_pdclust_layout **play, int N, int K)
+{
+	int                 result;
+	struct c2_uint128   id;
+	struct c2_uint128   seed;
+	struct c2_pool     *pool;
+
+	C2_ALLOC_PTR(pool);
+	if (pool == NULL)
+		return -ENOMEM;
+
+	c2_uint128_init(&id,   "jinniesisjillous");
+	c2_uint128_init(&seed, "upjumpandpumpim,");
+
+	result = c2_pool_init(pool, N+2*K);
+
+	if (result != 0) {
+		c2_free(pool);
+		return result;
+	}
+
+	result = c2_pdclust_build(pool, &id, N, K, &seed, play);
+
+	if (result != 0) {
+		c2_pool_fini(pool);
+		c2_free(pool);
+	}
+
+	return result;
+}
+
+static void pdclust_layout_fini(struct c2_pdclust_layout *play)
+{
+	c2_pool_fini(play->pl_pool);
+	c2_pdclust_fini(play);
+}
+
+/**
+   Adding a container connection into list.
+
+   Container id, service id is provided by caller. Connection will be
+   established in this function.
+
+   TODO: Initially, this is maintained as a list. I will improve it into
+   a hash table.
+*/
+static int c2t1fs_container_add(struct super_block *sb,
+				struct c2t1fs_conn_clt *clt)
+{
+        struct c2t1fs_sb_info *csi = s2csi(sb);
+	ENTER;
+
+	DBG("Adding container %llu\n", (unsigned long long)clt->xc_cid);
+	c2_mutex_lock(&csi->csi_mutex);
+	c2_list_link_init(&clt->xc_link);
+	c2_list_add_tail(&csi->csi_conn_list, &clt->xc_link);
+	c2_mutex_unlock(&csi->csi_mutex);
+
+	return 0;
+}
+
+/**
+   Lookup a container connection from list.
+
+   container id is the key.
+*/
+static struct c2t1fs_conn_clt* c2t1fs_container_lookup(struct super_block *sb,
+						       uint64_t container_id)
+{
+        struct c2t1fs_sb_info  *csi = s2csi(sb);
+	struct c2t1fs_conn_clt *conn;
+	struct c2t1fs_conn_clt *ret = NULL;
+	ENTER;
+
+	DBG("Looking for container %llu\n", (unsigned long long)container_id);
+	c2_mutex_lock(&csi->csi_mutex);
+	c2_list_for_each_entry(&csi->csi_conn_list, conn, struct c2t1fs_conn_clt, xc_link) {
+		if (conn->xc_cid == container_id) {
+			ret = conn;
+			break;
+		}
+	}
+	c2_mutex_unlock(&csi->csi_mutex);
+	DBG("Looking for container result=%p\n", ret);
+	return ret;
+}
+
+/**
+   Destroy all container connection infomation and free them.
+*/
+static int c2t1fs_container_fini(struct super_block *sb)
+{
+        struct c2t1fs_sb_info *csi = s2csi(sb);
+	struct c2_list_link   *first;
+	struct c2t1fs_conn_clt *conn;
+	ENTER;
+
+	while (!c2_list_is_empty(&csi->csi_conn_list)) {
+		c2_mutex_lock(&csi->csi_mutex);
+		first = c2_list_first(&csi->csi_conn_list);
+		if (first != NULL)
+			c2_list_del(first);
+		c2_mutex_unlock(&csi->csi_mutex);
+
+		if (first == NULL)
+			break;
+
+		conn = c2_list_entry(first, struct c2t1fs_conn_clt, xc_link);
+		DBG("Freeing container %llu\n", (unsigned long long)conn->xc_cid);
+		if (conn->xc_conn != NULL) {
+			c2_net_conn_unlink(conn->xc_conn);
+			c2_net_conn_release(conn->xc_conn);
+		}
+		c2_free(conn);
+	}
+	return 0;
+}
+
+/**
+   establish container connections.
+*/
+static int c2t1fs_container_connect(struct super_block *sb)
+{
+        struct c2t1fs_sb_info  *csi = s2csi(sb);
+	struct c2t1fs_conn_clt *conn;
+	int rc = 0;
+	ENTER;
+
+	c2_mutex_lock(&csi->csi_mutex);
+	c2_list_for_each_entry(&csi->csi_conn_list, conn, struct c2t1fs_conn_clt, xc_link) {
+		rc = c2_net_conn_create(&conn->xc_srvid);
+	        if (rc)
+			break;
+
+		conn->xc_conn = c2_net_conn_find(&conn->xc_srvid);
+		rc = ksunrpc_create(conn->xc_conn, csi->csi_object_param.cop_objid);
+		if (rc) {
+			printk("Create objid %llu on %llu failed %d\n",
+				csi->csi_object_param.cop_objid, conn->xc_cid, rc);
+			break;
+		}
+		DBG("Connectted container %llu\n", (unsigned long long)conn->xc_cid);
+	}
+	c2_mutex_unlock(&csi->csi_mutex);
+	return rc;
+}
+
+static int c2t1fs_parse_address(struct super_block *sb, const char *address,
+				struct c2_service_id *sid)
+{
+        char *hostname;
+	char *port;
+	int   tcp_port;
+	int   rc;
+	ENTER;
+
+	hostname = kstrdup(address, GFP_KERNEL);
+
+        port = strchr(hostname, ':');
+	if (port == NULL || hostname == port || *(port+1) == '\0') {
+		printk("server:port is expected as the device\n");
+		kfree(hostname);
+		return -EINVAL;
+	}
+
+	*port++ = 0;
+	if (in_aton(hostname) == 0) {
+		printk("only dotted ipaddr is accepted now: e.g. 1.2.3.4\n");
+		kfree(hostname);
+		return -EINVAL;
+	}
+
+	tcp_port = simple_strtol(port, NULL, 0);
+	if (tcp_port <= 0) {
+		printk("invalid tcp port: %s\n", port);
+		kfree(hostname);
+		return -EINVAL;
+	}
+	DBG("server:port=%s:%d\n", hostname, tcp_port);
+
+        rc = c2_service_id_init(sid, &c2t1fs_domain, hostname, tcp_port);
+
+	kfree(hostname);
+	return rc;
+}
+
+
+static bool optcheck(const char *s, const char *opt, size_t *optlen)
+{
+	*optlen = strlen(opt);
+        return strncmp(s, opt, *optlen) == 0;
+}
+
+static int optparse(struct super_block *sb, char *options)
+{
+        struct c2t1fs_sb_info *csi = s2csi(sb);
+ 	struct c2t1fs_object_param *obj_param = &csi->csi_object_param;
+        char *s1, *s2;
+	char *objid = NULL;
+	char *objsize = NULL;
+	char *layoutid = NULL;
+	char *unitsize = NULL;
+	char *layout_data = NULL;
+	char *layout_parity = NULL;
+	uint32_t N; /* layout data   unit count */
+	uint32_t K; /* layout parity unit count */
+	uint64_t cid = 0;
+	uint32_t container_nr = 0;
+        size_t optlen;
+	struct c2t1fs_conn_clt *clt;
+	int rc;
+	ENTER;
+
+        if (!options) {
+                printk(KERN_ERR "Missing mount data: objid=xxx,objsize=yyy\n");
+                return -EINVAL;
+        }
+
+        s1 = options;
+        while (*s1) {
+                while (*s1 == ' ' || *s1 == ',')
+                        s1++;
+
+                if (optcheck(s1, "objid=", &optlen)) {
+                        objid = s1 + optlen;
+                } else if (optcheck(s1, "objsize=", &optlen)) {
+                        objsize = s1 + 8;
+                } else if (optcheck(s1, "layoutid=", &optlen)) {
+			/* add layout id for this client */
+			layoutid = s1 + optlen;
+		} else if (optcheck(s1, "unitsize=", &optlen)) {
+			unitsize = s1 + optlen;
+		} else if (optcheck(s1, "layout-data=", &optlen)) {
+			/* will remove this option when layout id will be added */
+			layout_data = s1 + optlen;
+		} else if (optcheck(s1, "layout-parity=", &optlen)) {
+			/* will remove this option when layout id will be added */
+			layout_parity = s1 + optlen;
+		} else if (optcheck(s1, "ds=", &optlen)) {
+			/*
+			   Add container server information here.
+			   There may be multiple container servers. This option
+			   Will appear multiple times.
+			 */
+			clt = c2_alloc(sizeof *clt);
+			if (clt == NULL)
+				return -ENOMEM;
+			rc = c2t1fs_parse_address(sb, s1 + optlen, &clt->xc_srvid);
+			if (rc) {
+				c2_free(clt);
+				return rc;
+			}
+			/* adding container one by one */
+			clt->xc_cid = cid;
+			rc = c2t1fs_container_add(sb, clt);
+			if (rc) {
+				c2_free(clt);
+				return rc;
+			}
+			cid ++;
+			container_nr++;
+		}
+
+                /* Find next opt */
+                s2 = strchr(s1, ',');
+                if (s2 == NULL) {
+                        break;
+                }
+                s2++;
+                s1 = s2;
+        }
+
+        if (objid != NULL) {
+                obj_param->cop_objid = simple_strtol(objid, NULL, 0);
+                if (obj_param->cop_objid <= 0) {
+                        printk(KERN_ERR "Invalid objid=%s specified\n", objid);
+                        return -EINVAL;
+                }
+        } else {
+                printk(KERN_ERR "No device id specified (need mount option 'objid=...')\n");
+                return -EINVAL;
+        }
+        if (layoutid != NULL) {
+                obj_param->cop_layoutid = simple_strtol(layoutid, NULL, 0);
+                if (obj_param->cop_layoutid <= 0) {
+                        printk(KERN_ERR "Invalid objid=%s specified\n", layoutid);
+                        return -EINVAL;
+                }
+        } else {
+		/* use default value */
+                obj_param->cop_layoutid = 0;
+        }
+	if (layout_data != NULL && layout_parity != NULL) {
+		printk("layout_data && layout_parity: ");
+		N = simple_strtol(layout_data,   NULL, 0);
+		K = simple_strtol(layout_parity, NULL, 0);
+		printk("N=%d, K=%d, cnt_nr=%d", N, K, container_nr);
+		if (N + 2*K != container_nr) { /* *2 for SPARE UNITS */
+			printk(KERN_ERR "Unable to create layout with the following settigns:"
+			       " N=%u, K=%u, transport count=%u\n", N, K, container_nr);
+			return -EINVAL;
+		}
+
+		rc = pdclust_layout_init(&obj_param->cop_play, N, K);
+		if (rc)
+			return rc;
+	} else {
+                printk(KERN_ERR "No layout specified "
+		       "(need mount option 'layout-parity=...' and 'layout-data=...')\n");
+		obj_param->cop_play = NULL;
+                return -EINVAL;
+	}
+        if (objsize != NULL) {
+                obj_param->cop_objsize = simple_strtol(objsize, NULL, 0);
+                if (obj_param->cop_objsize <= 0) {
+                        printk(KERN_WARNING "Invalid objsize=%s specified."
+                               " Default value is used\n", objsize);
+                        obj_param->cop_objsize = C2T1FS_INIT_OBJSIZE;
+                }
+        } else {
+                printk(KERN_WARNING "no objsize specified. Default value is used\n");
+                obj_param->cop_objsize = C2T1FS_INIT_OBJSIZE;
+        }
+        if (unitsize != NULL) {
+                obj_param->cop_unitsize = simple_strtol(unitsize, NULL, 0);
+                if (obj_param->cop_unitsize < C2T1FS_DEFAULT_UNIT_SIZE) {
+                        printk(KERN_WARNING "Invalid unitsize=%s specified."
+                               " Default value is used\n", unitsize);
+                        obj_param->cop_unitsize = C2T1FS_DEFAULT_UNIT_SIZE;
+                }
+        } else {
+                printk(KERN_WARNING "no unitsize specified. Default value is used\n");
+                obj_param->cop_unitsize = C2T1FS_DEFAULT_UNIT_SIZE;
+        }
+
+        return 0;
+}
+
+struct rpc_desc {
+	loff_t rd_offset;
+	int    rd_units;
+};
+
+struct obj_map {
+	/* 2D array of page-pointers: struct page *om_map[N][M] */
+	struct page ***om_map;
+};
+
+static void obj_map_fini(struct obj_map *objmap, uint32_t P, uint32_t I)
+{
+        uint32_t i;
+
+        for (i = 0; i < P; ++i) {
+                c2_free(objmap->om_map[i]);
+                objmap->om_map[i] = NULL;
+	}
+
+        c2_free(objmap->om_map);
+}
+
+static int obj_map_init(struct obj_map *objmap, uint32_t P, uint32_t I)
+{
+        uint32_t i;
+
+        C2_ALLOC_ARR(objmap->om_map, P);
+        if (objmap->om_map == NULL)
+		return -ENOMEM;
+
+        for (i = 0; i < P; ++i) {
+                C2_ALLOC_ARR(objmap->om_map[i], I);
+		if (objmap->om_map[i] == NULL) {
+                        obj_map_fini(objmap, P, I);
+                        return -ENOMEM;
+                }
+        }
+
+        return 0;
+}
+
+static int c2t1fs_internal_read_write(struct c2t1fs_sb_info    *csi,
+				      struct inode             *inode,
+				      struct page **pages, int npages,
+				      loff_t in_pos, int off,
+				      struct c2_pdclust_layout *play,
+				      int rw)
+{
+	int                         i;
+	int                         rc = 0;
+	int                         rpc_rc;
+	int	                    group;
+	int	                    unit;
+	int                         N = play->pl_N;
+	int                         K = play->pl_K;
+	int                         P = play->pl_P;
+	int                         W = N + 2*K;
+	int                         I = npages / N;
+
+	int                         parity;
+	int			    parity_nr = K*I;
+	int                         spare;
+	int                         spare_nr = K*I;
+
+	uint64_t                    objid;
+	uint32_t                    unitsize;
+
+	struct c2_pdclust_src_addr  src;
+	struct c2_pdclust_tgt_addr  tgt;
+	enum c2_pdclust_unit_type   unit_type;
+
+	loff_t                      pos;
+	uint64_t                    obj;
+
+	struct c2t1fs_conn_clt     *con;
+	struct page                *page;
+	struct page	          **parity_pages = NULL;
+
+	struct c2_buf              *data_buf = NULL;
+	struct c2_buf              *parity_buf = NULL;
+
+	struct c2t1fs_object_param *obj_param;
+
+	struct obj_map              objmap;
+	struct rpc_desc            *rpc = NULL;
+
+	ENTER;
+
+	C2_ASSERT(csi != NULL);
+	C2_PRE(off == 0);
+
+	DBG("layout settings: N=%d, K=%d, W=%d, I=%d, P=%d\n", N, K, W, I, P);
+
+	obj_param = &csi->csi_object_param;
+	objid = obj_param->cop_objid;
+	unitsize = obj_param->cop_unitsize;
+	C2_ASSERT(unitsize >= C2T1FS_DEFAULT_UNIT_SIZE);
+
+	rc = obj_map_init(&objmap, P, I);
+	if (rc)
+		goto int_out;
+
+	C2_ALLOC_ARR(data_buf, N);
+	C2_ALLOC_ARR(rpc, P);
+	C2_ALLOC_ARR(parity_pages, parity_nr);
+	C2_ALLOC_ARR(parity_buf, parity_nr);
+
+	if (rpc == NULL || parity_pages == NULL ||
+	    data_buf == NULL || parity_buf == NULL) {
+		rc = -ENOMEM;
+		goto int_out;
+	}
+
+	for (i = 0; i < parity_nr; ++i) {
+		parity_pages[i] = alloc_page(GFP_KERNEL);
+		if (parity_pages[i] == NULL) {
+			rc = -ENOMEM;
+			goto int_out;
+		}
+
+		c2_buf_init(&parity_buf[i], page_address(parity_pages[i]),
+			    unitsize);
+	}
+
+	for (i = 0; i < P; ++i) {
+		rpc[i].rd_offset = C2_BSIGNED_MAX;
+		rpc[i].rd_units  = 0;
+	}
+
+	src.sa_group = in_pos / (N * unitsize);
+	for (group = 0, parity = 0, spare = 0; group < I ; ++group, src.sa_group++) {
+		for (unit = 0; unit < W; ++unit) {
+			src.sa_unit = unit;
+			c2_pdclust_layout_map(play, &src, &tgt);
+			pos = tgt.ta_frame * unitsize;
+			obj = tgt.ta_obj;
+
+			rpc[obj].rd_offset = min_check(pos, rpc[obj].rd_offset);
+			rpc[obj].rd_units++;
+
+			unit_type = c2_pdclust_unit_classify(play, unit);
+			if (unit_type == PUT_DATA) {
+				page = pages[unit + group*N];
+				c2_buf_init(&data_buf[unit],
+					    page_address(page),
+					    unitsize);
+			} else if (unit_type == PUT_PARITY) {
+				if (rw == WRITE)
+					c2_parity_math_calculate(&play->pl_math,
+								 data_buf,
+								 &parity_buf[group*K]);
+
+				C2_ASSERT(parity < parity_nr);
+				page = parity_pages[parity++];
+			} else { /* PUT_SPARE */
+				C2_ASSERT(spare < spare_nr);
+				page = parity_pages[spare++]; /* just use parity pages for now */
+			}
+
+			objmap.om_map[obj][group] = page;
+			DBG("prepare: obj=%llu, group=%d, pos=%llu, page=%p\n", obj, group, pos, page);
+		}
+	}
+
+	for (obj = 0; obj < P; ++obj) {
+		if (rpc[obj].rd_units == 0)
+			continue;
+		con = c2t1fs_container_lookup(inode->i_sb, obj);
+		if (con != NULL) {
+			rpc_rc = ksunrpc_read_write(con->xc_conn,
+						    objid,
+						    objmap.om_map[obj],
+						    off,
+						    /* rpc[obj].rd_units * I, */
+						    unitsize * I,
+						    rpc[obj].rd_offset, rw);
+
+			if (rpc_rc < 0) {
+				rc = rpc_rc;
+				goto int_out;
+			}
+		} else {
+			rc = -ENODEV;
+			goto int_out;
+		}
+		rc = I*N*unitsize;
+	}
+
+ int_out:
+	for (i = 0; i < parity_nr; ++i) {
+		if (parity_pages[i] != NULL)
+			__free_page(parity_pages[i]);
+	}
+
+        if (parity_buf)
+	        c2_free(parity_buf);
+	if (parity_pages)
+	        c2_free(parity_pages);
+	if (rpc)
+	        c2_free(rpc);
+	if (data_buf)
+	        c2_free(data_buf);
+	obj_map_fini(&objmap, W, I);
+
+	return rc;
+}
+
+/* common rw function for c2t1fs, it just does sync RPC. */
+static ssize_t c2t1fs_read_write(struct file *file, char *buf, size_t count,
+                                 loff_t *ppos, int rw)
+{
+	struct inode          *inode = file->f_dentry->d_inode;
+	struct c2t1fs_sb_info *csi = s2csi(inode->i_sb);
+        unsigned long          addr;
+        struct page          **pages;
+        int                    npages;
+        int                    off;
+        loff_t                 pos = *ppos;
+	struct c2t1fs_conn_clt *conn;
+	struct c2t1fs_object_param *obj_param = &csi->csi_object_param;
+	struct c2_pdclust_layout   *play    = obj_param->cop_play;
+	c2_bcount_t                unitsize = obj_param->cop_unitsize;
+        int rc;
+
+	DBG("%s: %ld@%ld <i_size=%ld>\n", rw == READ ? "read" : "write",
+		count, (unsigned long)pos, (unsigned long)inode->i_size);
+
+	if (rw == READ) {
+                if (pos >= inode->i_size)
+                        return 0;
+
+		/* check if pos beyond the file size */
+		if (pos + count > inode->i_size)
+			count = inode->i_size - pos;
+	}
+
+	if (count == 0)
+		return 0;
+
+        if (rw == WRITE && file->f_flags & O_APPEND)
+                pos = inode->i_size;
+
+        addr = (unsigned long)buf;
+        off  = (addr & (PAGE_SIZE - 1));
+        addr &= PAGE_MASK;
+
+	/* suppose addr = 0x400386, count=5, then one page is enough */
+        npages = (off + count + PAGE_SIZE - 1) >> PAGE_SHIFT;
+        pages = kmalloc(sizeof(*pages) * npages, GFP_KERNEL);
+        if (pages == NULL)
+                return -ENOMEM;
+
+        DBG("addr = %lx, count = %ld, npages = %d, off = %d\n",
+		addr, count, npages, off);
+
+        if (addr > PAGE_OFFSET) {
+                int i;
+                unsigned long va = addr;
+                for (i = 0; i < npages; i++, va += PAGE_SIZE) {
+                        pages[i] = virt_to_page(va);
+                        get_page(pages[i]);
+                }
+                rc = npages;
+        } else {
+                down_read(&current->mm->mmap_sem);
+                rc = get_user_pages(current, current->mm, addr, npages,
+                                    rw == READ, 1, pages, NULL);
+                up_read(&current->mm->mmap_sem);
+        }
+        if (rc != npages) {
+                printk("expect %d, got %d\n", npages, rc);
+                npages = rc > 0 ? rc : 0;
+                rc = -EFAULT;
+                goto out;
+        }
+
+	C2_ASSERT(play != NULL);
+	C2_ASSERT(unitsize >= C2T1FS_DEFAULT_UNIT_SIZE);
+	/* XXX: just for now, full-stripe read/write */
+	if (npages % play->pl_N != 0 || off != 0
+	    || pos % (play->pl_N * unitsize) != 0) {
+		/* rc = -EPARSE; */
+		DBG("Supporting only full-stripe read/write for now: "
+		    "npages=%d, off=%d, pos=%llu\n", npages, off, pos);
+		rc = -EINVAL;
+		goto out;
+	}
+#if 0
+	conn = c2t1fs_container_lookup(inode->i_sb, 0);
+	if (conn)
+	        rc = ksunrpc_read_write(conn->xc_conn,
+					csi->csi_object_param.cop_objid,
+					pages, npages,
+					off, count, pos, rw);
+	else
+		rc = -ENODEV;
+#endif
+	conn = 0; /* XXX: fix compilability */
+	rc = c2t1fs_internal_read_write(csi, inode, pages, npages, pos, off, play, rw);
+
+        DBG("call read_write returns %d\n", rc);
+	if (rc > 0) {
+		pos += rc;
+		if (rw == WRITE && pos > inode->i_size)
+			inode->i_size = pos;
+		*ppos = pos;
+	}
+out:
+        for (off = 0; off < npages; off++)
+                put_page(pages[off]);
+        kfree(pages);
+        return rc;
+}
+
+static ssize_t c2t1fs_file_aio_read(struct kiocb *iocb, const struct iovec *iov,
+                                    unsigned long nr_segs, loff_t pos)
+{
+	unsigned long seg;
+	ssize_t result = 0;
+        ssize_t count = 0;
+
+        if (nr_segs == 0)
+                return 0;
+
+        for (seg = 0; seg < nr_segs; seg++) {
+		const struct iovec *vec = &iov[seg];
+		result = c2t1fs_read_write(iocb->ki_filp,(char *)vec->iov_base,
+					   vec->iov_len, &iocb->ki_pos,
+					   READ);
+                if (result <= 0)
+                        break;
+                if ((size_t)result < vec->iov_len)
+                        break;
+		count += result;
+        }
+	return count ? count : result;
+}
+
+static ssize_t c2t1fs_file_aio_write(struct kiocb *iocb, const struct iovec *iov,
+                                     unsigned long nr_segs, loff_t pos)
+{
+        struct inode          *inode = iocb->ki_filp->f_dentry->d_inode;
+        struct c2t1fs_sb_info *csi = s2csi(inode->i_sb);
+        ssize_t count = 0;
+        ssize_t rc;
+        int i;
+        int j;
+        int nr_pages = 0;
+        struct page **pages;
+        const struct iovec *iv;
+	unsigned long seg;
+	ssize_t result = 0;
+	struct c2t1fs_conn_clt *conn;
+
+        if (nr_segs == 0)
+                return 0;
+        if (nr_segs == 1)
+                goto normal_write;
+
+        iv = iov;
+        for (i = 0; i < nr_segs; i++, iv++) {
+                unsigned long addr = (unsigned long)iv->iov_base;
+                if (addr < PAGE_OFFSET)
+                        goto normal_write;
+                if (addr & (PAGE_SIZE - 1))
+                        goto normal_write;
+                if (iv->iov_len & (PAGE_SIZE - 1))
+                        goto normal_write;
+                nr_pages += iv->iov_len >> PAGE_SHIFT;
+        }
+
+        pages = kmalloc(sizeof(struct page *) * nr_pages, GFP_KERNEL);
+        if (pages == NULL)
+                goto normal_write;
+
+        iv = iov;
+        for (i = 0, j = 0; i < nr_segs; i++, iv++) {
+                unsigned long base = (unsigned long)iv->iov_base;
+                int len = iv->iov_len;
+                while (len) {
+                        pages[j++] = virt_to_page(base);
+                        base += PAGE_SIZE;
+                        len -= PAGE_SIZE;
+                }
+        }
+        BUG_ON(nr_pages != j);
+#if 0
+	conn = c2t1fs_container_lookup(inode->i_sb, 0);
+	if (conn)
+	        rc = ksunrpc_read_write(conn->xc_conn,
+					csi->csi_object_param.cop_objid,
+					pages, nr_pages,
+					0, nr_pages << PAGE_SHIFT, pos, WRITE);
+	else
+		rc = -ENODEV;
+        if (rc > 0) {
+                pos += rc;
+                if (pos > inode->i_size)
+                        inode->i_size = pos;
+        }
+#endif
+	conn = NULL; /* XXX: fix compilability */
+	csi = NULL; /* XXX: fix compilability */
+	DBG("Currently supported normal writes only!\n");
+	rc = -EINVAL; /* -EPARSE */
+
+        kfree(pages);
+        return rc;
+
+normal_write:
+        DBG("doing normal write for %d segments\n", (int)nr_segs);
+        for (seg = 0; seg < nr_segs; seg++) {
+		const struct iovec *vec = &iov[seg];
+		result = c2t1fs_read_write(iocb->ki_filp,(char *)vec->iov_base,
+					   vec->iov_len, &iocb->ki_pos,
+					   WRITE);
+                if (result <= 0)
+                        break;
+                if ((size_t)result < vec->iov_len)
+                        break;
+		count += result;
+        }
+	return count ? count : result;
+}
+
+
+struct inode_operations c2t1fs_file_inode_operations = {
+};
+
+struct file_operations c2t1fs_file_operations = {
+        .aio_read       = c2t1fs_file_aio_read,
+        .aio_write      = c2t1fs_file_aio_write,
+        .read           = do_sync_read,
+        .write          = do_sync_write,
+};
+
+
+struct address_space_operations c2t1fs_file_aops = {
+};
+
+struct address_space_operations c2t1fs_dir_aops = {
+};
+
+static struct dentry *c2t1fs_lookup(struct inode *dir, struct dentry *dentry,
+                                    struct nameidata *nd);
+
+static int
+c2t1fs_readdir(struct file * filp, void * dirent, filldir_t filldir)
+{
+        struct inode *inode = filp->f_dentry->d_inode;
+        struct c2t1fs_sb_info *csi = s2csi(inode->i_sb);
+        unsigned int ino;
+        int i;
+
+        ino = inode->i_ino;
+	if (ino != C2T1FS_ROOT_INODE)
+		return 0;
+
+        i = filp->f_pos;
+        switch (i) {
+        case 0:
+                if (filldir(dirent, ".", 1, i, ino, DT_DIR) < 0)
+                        goto out;
+                i++;
+                filp->f_pos++;
+                /* fall thru */
+        case 1:
+                if (filldir(dirent, "..", 2, i, ino, DT_DIR) < 0)
+                        goto out;
+                i++;
+                filp->f_pos++;
+                /* fall thru */
+	case 2:
+	{
+		char fn[256];
+		sprintf(fn, "%d", (int)csi->csi_object_param.cop_objid);
+                if (filldir(dirent, fn, strlen(fn), i, csi->csi_object_param.cop_objid, DT_REG) < 0)
+                        goto out;
+                i++;
+                filp->f_pos++;
+                /* fall thru */
+	}
+	default:
+		break;
+	}
+out:
+	return 0;
+}
+
+
+
+static const struct inode_operations c2t1fs_dir_inode_operations = {
+        .lookup = c2t1fs_lookup
+};
+
+static const struct file_operations c2t1fs_dir_operations = {
+        .readdir        = c2t1fs_readdir,
+};
+
+static int c2t1fs_update_inode(struct inode *inode, void *opaque)
+{
+        ino_t ino = *((ino_t *)opaque);
+        __u32 mode;
+
+        inode->i_ino = ino;
+
+        /* FIXME: This is a hack to make it mount (we need root dir) */
+        if (inode->i_ino == C2T1FS_ROOT_INODE)
+                mode = ((S_IRWXUGO | S_ISVTX) & ~current_umask()) | S_IFDIR;
+        else
+                mode = ((S_IRUGO | S_IXUGO) & ~current_umask()) | S_IFREG;
+        inode->i_mode = (inode->i_mode & S_IFMT) | (mode & ~S_IFMT);
+        inode->i_mode = (inode->i_mode & ~S_IFMT) | (mode & S_IFMT);
+        if (S_ISREG(inode->i_mode)) {
+                /* FIXME: This needs to be taken from rpc layer */
+                inode->i_blkbits = min(C2_MAX_BRW_BITS + 1, C2_MAX_BLKSIZE_BITS);
+        } else {
+                inode->i_blkbits = inode->i_sb->s_blocksize_bits;
+        }
+#ifdef HAVE_INODE_BLKSIZE
+        inode->i_blksize = 1 << inode->i_blkbits;
+#endif
+
+        /* FIXME: This needs to be taken from an getattr rpc */
+        if (inode->i_ino == C2T1FS_ROOT_INODE)
+                inode->i_nlink = 2;
+        else
+                inode->i_nlink = 1;
+
+        if (S_ISDIR(inode->i_mode)) {
+                inode->i_size = PAGE_SIZE;
+                inode->i_blocks = 1;
+        } else {
+                inode->i_size = s2csi(inode->i_sb)->csi_object_param.cop_objsize;
+                inode->i_blocks = inode->i_size >> PAGE_SHIFT;
+        }
+
+        return 0;
+}
+
+static int c2t1fs_read_inode(struct inode *inode, void *opaque)
+{
+        C2TIME_S(inode->i_mtime) = 0;
+        C2TIME_S(inode->i_atime) = 0;
+        C2TIME_S(inode->i_ctime) = 0;
+        inode->i_rdev = 0;
+
+        c2t1fs_update_inode(inode, opaque);
+
+        if (S_ISREG(inode->i_mode)) {
+                inode->i_op = &c2t1fs_file_inode_operations;
+                inode->i_fop = &c2t1fs_file_operations;
+                inode->i_mapping->a_ops = &c2t1fs_file_aops;
+        } else if (S_ISDIR(inode->i_mode)) {
+                inode->i_op = &c2t1fs_dir_inode_operations;
+                inode->i_fop = &c2t1fs_dir_operations;
+                inode->i_mapping->a_ops = &c2t1fs_dir_aops;
+        } else {
+                return -ENOSYS;
+        }
+        return 0;
+}
+
+/* called from iget5_locked->find_inode() under inode_lock spinlock */
+static int c2t1fs_test_inode(struct inode *inode, void *opaque)
+{
+        ino_t *ino = opaque;
+        return inode->i_ino == *ino;
+}
+
+static int c2t1fs_set_inode(struct inode *inode, void *opaque)
+{
+        /* FIXME: Set inode info from passed rpc data */
+        return 0;
+}
+
+static struct inode *c2t1fs_iget(struct super_block *sb, ino_t hash)
+{
+        struct inode *inode;
+
+        inode = iget5_locked(sb, hash, c2t1fs_test_inode, c2t1fs_set_inode, &hash);
+        if (inode) {
+                if (inode->i_state & I_NEW) {
+                        c2t1fs_read_inode(inode, &hash);
+                        unlock_new_inode(inode);
+                } else {
+                        if (!(inode->i_state & (I_FREEING | I_CLEAR)))
+                                c2t1fs_update_inode(inode, &hash);
+                }
+        }
+
+        return inode;
+}
+
+static struct dentry *c2t1fs_lookup(struct inode *dir, struct dentry *dentry,
+                                    struct nameidata *nd)
+{
+	struct inode *inode = NULL;
+	unsigned long ino;
+
+	lock_kernel();
+	ino = simple_strtol(dentry->d_name.name, NULL, 0);
+	if (!ino) {
+	        unlock_kernel();
+	        return ERR_PTR(-EINVAL);
+	}
+        inode = c2t1fs_iget(dir->i_sb, ino);
+        if (!inode) {
+                unlock_kernel();
+                return ERR_PTR(-ENOENT);
+        }
+	unlock_kernel();
+	d_add(dentry, inode);
+	return NULL;
+}
+
+static int c2t1fs_fill_super(struct super_block *sb, void *data, int silent)
+{
+        struct c2t1fs_sb_info *csi;
+        struct inode          *root;
+        int rc;
+
+        csi = c2t1fs_init_csi(sb);
+        if (!csi)
+                return -ENOMEM;
+
+        rc = optparse(sb, (char *)data);
+        if (rc) {
+                c2t1fs_put_csi(sb);
+                return rc;
+        }
+        sb->s_blocksize = PAGE_SIZE;
+        sb->s_blocksize_bits = log2(PAGE_SIZE);
+        sb->s_magic = C2T1FS_SUPER_MAGIC;
+        sb->s_maxbytes = MAX_LFS_FILESIZE;
+        sb->s_op = &c2t1fs_super_operations;
+
+        /* make root inode */
+        root = c2t1fs_iget(sb, C2T1FS_ROOT_INODE);
+        if (root == NULL || is_bad_inode(root)) {
+                c2t1fs_put_csi(sb);
+                return -EBADF;
+        }
+
+        sb->s_root = d_alloc_root(root);
+
+        return 0;
+}
+
+static int c2t1fs_get_super(struct file_system_type *fs_type,
+                            int flags, const char *devname, void *data,
+                            struct vfsmount *mnt)
+{
+        struct c2t1fs_sb_info *csi;
+	struct super_block    *sb;
+        int   rc;
+
+	DBG("flags=%x devname=%s, data=%s\n", flags, devname, (char*)data);
+
+        rc = get_sb_nodev(fs_type, flags, data, c2t1fs_fill_super, mnt);
+        if (rc < 0)
+                return rc;
+
+        sb  = mnt->mnt_sb;
+        csi = s2csi(sb);
+
+	rc = c2t1fs_parse_address(sb, devname, &csi->csi_mgmt_srvid);
+	if (rc) {
+		dput(sb->s_root); /* aka mnt->mnt_root, as set by get_sb_nodev() */
+		deactivate_locked_super(sb);
+                return rc;
+	}
+
+	/* connect to mgmt node */
+if (0) {
+	/* XXX no need to connect to mgmt node right now */
+        rc = c2_net_conn_create(&csi->csi_mgmt_srvid);
+        if (rc) {
+		c2t1fs_container_fini(sb);
+		dput(sb->s_root);
+		deactivate_locked_super(sb);
+                return rc;
+	}
+
+        csi->csi_mgmt_conn = c2_net_conn_find(&csi->csi_mgmt_srvid);
+}
+	rc = c2t1fs_container_connect(sb);
+	if (rc) {
+		if (csi->csi_mgmt_conn != NULL) {
+			c2_net_conn_unlink(csi->csi_mgmt_conn);
+			c2_net_conn_release(csi->csi_mgmt_conn);
+			csi->csi_mgmt_conn = NULL;
+		}
+		c2t1fs_container_fini(sb);
+		dput(sb->s_root);
+		deactivate_locked_super(sb);
+	}
+
+        return rc;
+}
+
+static void c2t1fs_kill_super(struct super_block *sb)
+{
+        struct c2t1fs_sb_info *csi = s2csi(sb);
+	struct c2_pdclust_layout *play = csi->csi_object_param.cop_play;
+
+        GETHERE;
+	if (csi->csi_mgmt_conn != NULL) {
+		c2_net_conn_unlink(csi->csi_mgmt_conn);
+		c2_net_conn_release(csi->csi_mgmt_conn);
+		csi->csi_mgmt_conn = NULL;
+	}
+
+	if (play)
+		pdclust_layout_fini(play);
+
+	/* disconnect from container server and free them */
+	c2t1fs_container_fini(sb);
+        kill_anon_super(sb);
+}
+
+static struct file_system_type c2t1fs_fs_type = {
+        .owner        = THIS_MODULE,
+        .name         = "c2t1fs",
+        .get_sb       = c2t1fs_get_super,
+        .kill_sb      = c2t1fs_kill_super,
+        .fs_flags     = FS_BINARY_MOUNTDATA | FS_REQUIRES_DEV
+};
+
+static int c2t1fs_init_inodecache(void)
+{
+	c2t1fs_inode_cachep = kmem_cache_create("c2t1fs_inode_cache",
+					        sizeof(struct c2t1fs_inode_info),
+					        0, SLAB_HWCACHE_ALIGN, NULL);
+	if (c2t1fs_inode_cachep == NULL)
+		return -ENOMEM;
+	return 0;
+}
+
+static void c2t1fs_destroy_inodecache(void)
+{
+        if (!c2t1fs_inode_cachep)
+                return;
+
+	kmem_cache_destroy(c2t1fs_inode_cachep);
+	c2t1fs_inode_cachep = NULL;
+}
+
+int init_module(void)
+{
+	struct c2_net_domain *dom = &c2t1fs_domain;
+        int rc;
+
+        printk(KERN_INFO
+	       "Colibri C2T1 File System (http://www.clusterstor.com)\n");
+
+	rc = c2_net_xprt_init(&c2_net_ksunrpc_xprt);
+	if (rc)
+		return rc;
+
+	dom->nd_xprt = NULL;
+	rc = c2_net_domain_init(dom, &c2_net_ksunrpc_xprt);
+	if (rc) {
+		c2_net_xprt_fini(&c2_net_ksunrpc_xprt);
+		return rc;
+	}
+
+        rc = c2t1fs_init_inodecache();
+        if (rc)
+                return rc;
+
+
+        rc = register_filesystem(&c2t1fs_fs_type);
+        if (rc == 0) {
+		rc = io_fop_init();
+		if (rc != 0)
+			unregister_filesystem(&c2t1fs_fs_type);
+	} else
+                c2t1fs_destroy_inodecache();
+
+        return rc;
+}
+
+void cleanup_module(void)
+{
+        int rc;
+
+	io_fop_fini();
+        rc = unregister_filesystem(&c2t1fs_fs_type);
+        c2t1fs_destroy_inodecache();
+        if (rc)
+                printk(KERN_INFO "Colibri C2T1 File System cleanup: %d\n", rc);
+}
+
+/*
+ *  Local variables:
+ *  c-indentation-style: "K&R"
+ *  c-basic-offset: 8
+ *  tab-width: 8
+ *  fill-column: 80
+ *  scroll-step: 1
+ *  End:
+ */
diff --git a/c2t1fs/st/common.sh b/c2t1fs/st/common.sh
new file mode 100755
index 0000000..303495f
--- /dev/null
+++ b/c2t1fs/st/common.sh
@@ -0,0 +1,37 @@
+#! /bin/sh
+
+MODLIST="lib/linux_kernel/klibc2.ko \
+         addb/linux_kernel/kaddb.ko \
+         db/linux_kernel/kdb.ko \
+         fop/linux_kernel/kfop.ko \
+         net/ksunrpc/ksunrpc.ko \
+         galois/linux_kernel/kgalois.ko \
+         sns/linux_kernel/ksns.ko \
+         stob/linux_kernel/kstob.ko \
+         pool/linux_kernel/kpool.ko \
+         layout/linux_kernel/klayout.ko \
+         c2t1fs/c2t1fs.ko"
+#         c2t1fs/c2t1fs_loop.ko"
+
+abort()
+{
+    msg="$1"
+    echo "$1 Aborting."
+    exit 1
+}
+
+modload()
+{
+    for m in $MODLIST ;do
+	insmod $m                   || abort "Error loading $m."
+    done
+}
+
+modunload()
+{
+    for m in $MODLIST ;do
+	echo $m
+    done | tac | while read ;do
+	rmmod $REPLY                || echo "Error unloading $m."
+    done
+}
diff --git a/c2t1fs/st/dbench.sh b/c2t1fs/st/dbench.sh
new file mode 100755
index 0000000..424dffa
--- /dev/null
+++ b/c2t1fs/st/dbench.sh
@@ -0,0 +1,74 @@
+#
+# Script is temporary disabled, use test2.sh instead.
+#
+echo Script is temporary DISABLED!!!
+exit 1
+
+DBENCH_DIR=""
+
+if [ -z $DBENCH_DIR ] ; then
+	echo "please specify dbench dir";
+	exit;
+fi
+
+cd ../..
+pwd
+
+# get the first non-loopback IP address
+IPAddr=$(/sbin/ifconfig | grep "inet addr" | grep -v "127.0.0.1" | awk -F: '{print $2}' | awk '{print $1}' | head -n 1)
+Port="2222"
+echo "server address is $IPAddr:$Port"
+
+rmmod loop
+
+ulimit -c unlimited
+insmod lib/linux_kernel/klibc2.ko
+insmod addb/linux_kernel/kaddb.ko
+insmod fop/linux_kernel/kfop.ko
+insmod net/ksunrpc/ksunrpc.ko
+insmod c2t1fs/c2t1fs.ko
+lsmod | grep -c "c2t1fs" || exit
+
+rm -rf /tmp/test/
+mkdir -p /tmp/test/
+
+(./stob/ut/server -d/tmp/test -p$Port &)
+sleep 5
+mkdir -p /mnt/c2t1fs
+mount -t c2t1fs -o objid=12345,ds=$IPAddr:$Port $IPAddr:$Port /mnt/c2t1fs
+
+#large file write & read
+dd if=/dev/zero of=/mnt/c2t1fs/12345 bs=1M count=200
+ls -l /mnt/c2t1fs/12345
+
+umount /mnt/c2t1fs
+
+# mount again and check its content
+# 1024 * 1024 * 256 = 268435456
+mount -t c2t1fs -o objid=12345,objsize=268435456,ds=$IPAddr:$Port $IPAddr:$Port /mnt/c2t1fs
+
+#attach loop device over c2t1fs file
+insmod c2t1fs/c2t1fs_loop.ko
+sleep 1
+losetup /dev/loop0 /mnt/c2t1fs/12345
+
+mkfs.ext3 /dev/loop0
+mkdir -p /mnt/loop
+mount /dev/loop0 /mnt/loop
+
+# please use your own dbench options here!
+$DBENCH_DIR/dbench -D /mnt/loop/ 2 -t 10 -c $DBENCH_DIR/client.txt
+
+umount /mnt/loop
+losetup -d /dev/loop0
+umount /mnt/c2t1fs
+
+rmmod c2t1fs_loop
+rmmod c2t1fs
+rmmod ksunrpc
+rmmod kfop
+rmmod kaddb
+rmmod klibc2
+
+killall lt-server
+echo ======================done=====================
diff --git a/c2t1fs/st/fs_common.sh b/c2t1fs/st/fs_common.sh
new file mode 100644
index 0000000..19199c2
--- /dev/null
+++ b/c2t1fs/st/fs_common.sh
@@ -0,0 +1,87 @@
+#!/bin/bash
+
+set -x
+. common.sh
+
+fsmount()
+{
+# get the first non-loopback IP address
+IPAddr=$(/sbin/ifconfig | grep "inet addr" | grep -v "127.0.0.1" | awk -F: '{print $2}' | awk '{print $1}' | head -n 1)
+Port0="1111"
+Port1="1112"
+Port2="1113"
+Port3="1114"
+Port4="1115"
+echo "server0 address is $IPAddr:$Port0"
+echo "server1 address is $IPAddr:$Port1"
+echo "server2 address is $IPAddr:$Port2"
+echo "server3 address is $IPAddr:$Port3"
+echo "server4 address is $IPAddr:$Port4"
+
+modunload
+modload
+
+# Run servers on different ports with different stobs:
+cd /tmp
+rm -rf 0 1 2 3 4
+mkdir -p 0 1 2 3 4 
+cd -
+
+(./stob/ut/server -d/tmp/0 -p$Port0 &)
+(./stob/ut/server -d/tmp/1 -p$Port1 &)
+(./stob/ut/server -d/tmp/2 -p$Port2 &)
+(./stob/ut/server -d/tmp/3 -p$Port3 &)
+(./stob/ut/server -d/tmp/4 -p$Port4 &)
+sleep 3
+
+mkdir -p /mnt/c2t1fs
+
+mount -t c2t1fs -o layout-data=3,layout-parity=1,objid=12345,objsize=196608,\
+ds=$IPAddr:$Port0,ds=$IPAddr:$Port1,ds=$IPAddr:$Port2,ds=$IPAddr:$Port3,ds=$IPAddr:$Port4\
+ $IPAddr:$Port1 /mnt/c2t1fs
+}
+
+fsumount()
+{
+umount /mnt/c2t1fs
+modunload
+killall lt-server
+}
+
+#arg0 max_count - maximal count per read/write
+#arg1 max_bs    - maximal block size
+fsrwtest()
+{
+max_count_=$1
+max_bs_=$2
+echo "fsrwtest max_count=$max_count, max_bs=$max_bs"
+
+dd if=/dev/urandom of=dummy.bin bs=$(($max_bs_*$max_count_)) count=1
+
+#for count_ in {1..$max_count_}
+for (( count_ = 1; count_ <= $max_count_; count_++ ))
+do
+     #for bs_ in {12288,24576,$max_bs_}
+     for (( bs_ = 12288; bs_ <= $max_bs_; bs_ += 12288))
+     do
+        dd if=dummy.bin of=/mnt/c2t1fs/12345 bs=$bs_ count=$count_
+        left=$(dd if=dummy.bin         bs=$bs_ count=$count_ 2>/dev/null | md5sum)
+	#sleep 2
+        right=$(dd if=/mnt/c2t1fs/12345 bs=$bs_ count=$count_ 2>/dev/null | md5sum)
+	#sleep 2
+	
+	if [ "$left" == "$right" ]
+	then
+	    echo "test {$count_,$bs_} passed."
+	else
+	    echo "test {$count_,$bs_} failed."
+	    echo =========== FFFFF FFFFF  F  F     FFFFF FFFF  FF ===========
+	    echo =========== F     F   F  F  F     F     F   F FF ===========
+	    echo =========== FFF   FFFFF  F  F     FFF   F   F FF ===========
+	    echo =========== F     F   F  F  F     F     F   F    ===========
+	    echo =========== F     F   F  F  FFFFF FFFFF FFFF  FF ===========
+	fi
+     done
+ done
+rm dummy.bin
+}
\ No newline at end of file
diff --git a/c2t1fs/st/mini.sh b/c2t1fs/st/mini.sh
new file mode 100644
index 0000000..b7d46c6
--- /dev/null
+++ b/c2t1fs/st/mini.sh
@@ -0,0 +1,61 @@
+#
+# Script is temporary disabled, use test2.sh instead.
+#
+echo Script is temporary DISABLED!!!
+exit 1
+
+set -x
+
+. common.sh
+
+cd ../..
+pwd
+
+# get the first non-loopback IP address
+IPAddr=$(/sbin/ifconfig | grep "inet addr" | grep -v "127.0.0.1" | awk -F: '{print $2}' | awk '{print $1}' | head -n 1)
+Port="2222"
+echo "server address is $IPAddr:$Port"
+rmmod loop
+
+ulimit -c unlimited
+
+modunload
+modload
+
+rm -rf /tmp/test/
+mkdir -p /tmp/test/
+
+(./stob/ut/server -d/tmp/test -p$Port &)
+sleep 5
+mkdir -p /mnt/c2t1fs
+mount -t c2t1fs -o objid=12345,ds=$IPAddr:$Port $IPAddr:$Port /mnt/c2t1fs
+
+#small file write & read
+ls -l /mnt/c2t1fs/12345
+cat c2t1fs/main.c > /mnt/c2t1fs/12345
+ls -l /mnt/c2t1fs/12345
+cat c2t1fs/main.c | md5sum
+cat /mnt/c2t1fs/12345 | md5sum
+
+#large file write & read
+dd if=/dev/zero of=/mnt/c2t1fs/12345 bs=128 count=200
+dd if=/dev/zero of=/mnt/c2t1fs/12345 bs=256 count=200
+dd if=/dev/zero of=/mnt/c2t1fs/12345 bs=512 count=200
+dd if=/dev/zero of=/mnt/c2t1fs/12345 bs=1024 count=200
+dd if=/dev/zero of=/mnt/c2t1fs/12345 bs=1M count=200
+ls -l /mnt/c2t1fs/12345
+dd if=/mnt/c2t1fs/12345 bs=1M count=256 2>/dev/null | md5sum
+dd if=/dev/zero bs=1M count=256 2>/dev/null | md5sum
+
+umount /mnt/c2t1fs
+
+# mount again and check its content
+# 1024 * 1024 * 256 = 268435456
+mount -t c2t1fs -o objid=12345,objsize=268435456,ds=$IPAddr:$Port $IPAddr:$Port /mnt/c2t1fs
+dd if=/mnt/c2t1fs/12345 bs=1M count=256 2>/dev/null | md5sum
+umount /mnt/c2t1fs
+
+modunload
+
+killall lt-server
+echo ======================done=====================
diff --git a/c2t1fs/st/mount.sh b/c2t1fs/st/mount.sh
new file mode 100755
index 0000000..cf2290c
--- /dev/null
+++ b/c2t1fs/st/mount.sh
@@ -0,0 +1,12 @@
+set -x
+
+. common.sh
+. fs_common.sh
+
+cd ../..
+pwd
+ulimit -c unlimited
+
+fsmount
+
+echo ======================done=====================
diff --git a/c2t1fs/st/perf.sh b/c2t1fs/st/perf.sh
new file mode 100755
index 0000000..c5f5195
--- /dev/null
+++ b/c2t1fs/st/perf.sh
@@ -0,0 +1,24 @@
+# Using simple layout N/K = 3/1 (with 1 parity and 1 spare unit).
+
+set -x
+
+. common.sh
+. fs_common.sh
+
+cd ../..
+pwd
+ulimit -c unlimited
+
+# 1. mount
+fsmount
+
+# 2. test read/write
+#arg0 max_count_
+#arg1 max_bs_
+#note: 10 * 12582912 ~ 120MiB of data, reads and write
+fsrwtest 10 12582912
+
+# 3. umount
+fsumount
+
+echo ======================done=====================
diff --git a/c2t1fs/st/standard_loop.sh b/c2t1fs/st/standard_loop.sh
new file mode 100644
index 0000000..4201867
--- /dev/null
+++ b/c2t1fs/st/standard_loop.sh
@@ -0,0 +1,76 @@
+#
+# Script is temporary disabled, use test2.sh instead.
+#
+echo Script is temporary DISABLED!!!
+exit 1
+
+set -x
+
+. common.sh
+
+cd ../..
+pwd
+
+# get the first non-loopback IP address
+IPAddr=$(/sbin/ifconfig | grep "inet addr" | grep -v "127.0.0.1" | awk -F: '{print $2}' | awk '{print $1}' | head -n 1)
+Port="2222"
+echo "server address is $IPAddr:$Port"
+
+ulimit -c unlimited
+
+modunload
+modload
+
+# we will use built-in loop driver.
+rmmod c2t1fs_loop
+modprobe loop
+
+rm -rf /tmp/test/
+mkdir -p /tmp/test
+
+(./stob/ut/server -d/tmp/test -p$Port &)
+sleep 5
+mkdir -p /mnt/c2t1fs
+mount -t c2t1fs -o objid=12345,ds=$IPAddr:$Port $IPAddr:$Port /mnt/c2t1fs
+
+#small file write & read
+ls -l /mnt/c2t1fs/12345
+cat c2t1fs/main.c > /mnt/c2t1fs/12345
+ls -l /mnt/c2t1fs/12345
+cat c2t1fs/main.c | md5sum
+cat /mnt/c2t1fs/12345 | md5sum
+
+#large file write & read
+dd if=/dev/zero of=/mnt/c2t1fs/12345 bs=1M count=256
+ls -l /mnt/c2t1fs/12345
+dd if=/mnt/c2t1fs/12345 bs=1M count=256 2>/dev/null | md5sum
+dd if=/dev/zero bs=1M count=256 2>/dev/null | md5sum
+
+umount /mnt/c2t1fs
+
+# mount again and check its content
+# 1024 * 1024 * 256 = 268435456
+mount -t c2t1fs -o objid=12345,objsize=268435456,ds=$IPAddr:$Port $IPAddr:$Port /mnt/c2t1fs
+dd if=/mnt/c2t1fs/12345 bs=1M count=256 2>/dev/null | md5sum
+
+# mkfs
+mkfs.ext3 -F /mnt/c2t1fs/12345
+
+
+#attach loop device over c2t1fs file
+sleep 1
+losetup /dev/loop0 /mnt/c2t1fs/12345
+
+mkfs.ext3 /dev/loop0
+mount -t ext3 /dev/loop0 /mnt/loop
+mount
+umount /mnt/loop
+
+losetup -d /dev/loop0
+umount /mnt/c2t1fs
+
+modunload
+rmmod loop
+
+killall lt-server
+echo ======================done=====================
diff --git a/c2t1fs/st/test.sh b/c2t1fs/st/test.sh
new file mode 100755
index 0000000..aaa7d44
--- /dev/null
+++ b/c2t1fs/st/test.sh
@@ -0,0 +1,89 @@
+#
+# Script is temporary disabled, use test2.sh instead.
+#
+echo Script is temporary DISABLED!!!
+exit 1
+
+set -x
+
+. common.sh
+
+cd ../..
+pwd
+
+# get the first non-loopback IP address
+IPAddr=$(/sbin/ifconfig | grep "inet addr" | grep -v "127.0.0.1" | awk -F: '{print $2}' | awk '{print $1}' | head -n 1)
+Port="2222"
+echo "server address is $IPAddr:$Port"
+rmmod loop
+
+ulimit -c unlimited
+
+modunload
+modload
+
+rm -rf /tmp/test/
+mkdir -p /tmp/test
+
+(./stob/ut/server -d/tmp/test -p$Port 2>/tmp/test/stderr-$$.log &)
+sleep 5
+mkdir -p /mnt/c2t1fs
+mount -t c2t1fs -o objid=12345,ds=$IPAddr:$Port $IPAddr:$Port /mnt/c2t1fs
+
+#small file write & read
+ls -l /mnt/c2t1fs/12345
+cat c2t1fs/main.c > /mnt/c2t1fs/12345
+ls -l /mnt/c2t1fs/12345
+cat c2t1fs/main.c | md5sum
+cat /mnt/c2t1fs/12345 | md5sum
+
+#large file write & read
+dd if=/dev/zero of=/mnt/c2t1fs/12345 bs=1M count=256
+ls -l /mnt/c2t1fs/12345
+dd if=/mnt/c2t1fs/12345 bs=1M count=256 2>/dev/null | md5sum
+dd if=/dev/zero bs=1M count=256 2>/dev/null | md5sum
+
+umount /mnt/c2t1fs
+
+# mount again and check its content
+# 1024 * 1024 * 256 = 268435456
+# !!!! please note:  the file size is 256MB  !!!!
+mount -t c2t1fs -o objid=12345,objsize=268435456,ds=$IPAddr:$Port $IPAddr:$Port /mnt/c2t1fs
+dd if=/mnt/c2t1fs/12345 bs=1M count=256 2>/dev/null | md5sum
+
+#attach loop device over c2t1fs file
+sleep 1
+losetup /dev/loop0 /mnt/c2t1fs/12345
+
+mkfs.ext3 /dev/loop0 || abort "mkfs failed"
+mkdir -p /mnt/loop
+mount /dev/loop0 /mnt/loop || abort "mount failed"
+
+# read & write the loop device file system.
+dd if=/dev/zero of=/mnt/loop/10M bs=1M count=10 oflag=direct
+ls -l /mnt/loop/10M
+dd if=/mnt/loop/10M bs=1M count=10 2>/dev/null | md5sum
+dd if=/dev/zero bs=1M count=10 2>/dev/null | md5sum
+umount /mnt/loop
+
+# again, read & write the loop device file system.
+mount /dev/loop0 /mnt/loop  || abort "mount again failed"
+dd if=/mnt/loop/10M bs=1M count=10 2>/dev/null | md5sum
+umount /mnt/loop
+
+losetup -d /dev/loop0
+umount /mnt/c2t1fs
+
+###### mount c2t1fs and loop again
+mount -t c2t1fs -o objid=12345,objsize=268435456,ds=$IPAddr:$Port $IPAddr:$Port /mnt/c2t1fs
+losetup /dev/loop0 /mnt/c2t1fs/12345
+mount /dev/loop0 /mnt/loop
+dd if=/mnt/loop/10M bs=1M count=10 2>/dev/null | md5sum
+umount /mnt/loop
+losetup -d /dev/loop0
+umount /mnt/c2t1fs
+
+modunload
+
+killall lt-server
+echo ======================done=====================
diff --git a/c2t1fs/st/test2.sh b/c2t1fs/st/test2.sh
new file mode 100755
index 0000000..f1b5987
--- /dev/null
+++ b/c2t1fs/st/test2.sh
@@ -0,0 +1,23 @@
+# Using simple layout N/K = 3/1 (with 1 parity and 1 spare unit).
+
+set -x
+
+. common.sh
+. fs_common.sh
+
+cd ../..
+pwd
+ulimit -c unlimited
+
+# 1. mount
+fsmount
+
+# 2. test read/write
+#arg0 max_count_=3
+#arg1 max_bs_=49152
+fsrwtest 3 49152
+
+# 3. umount
+fsumount
+
+echo ======================done=====================
diff --git a/c2t1fs/st/unmount.sh b/c2t1fs/st/unmount.sh
new file mode 100755
index 0000000..e956a74
--- /dev/null
+++ b/c2t1fs/st/unmount.sh
@@ -0,0 +1,12 @@
+set -x
+
+. common.sh
+. fs_common.sh
+
+cd ../..
+pwd
+ulimit -c unlimited
+
+fsumount
+
+echo ======================done=====================
diff --git a/colibri/DS-Reqh.gif b/colibri/DS-Reqh.gif
deleted file mode 100644
index 18e37e13898b5adac5f8238affe2823368d9416f..0000000000000000000000000000000000000000
GIT binary patch
literal 0
HcmV?d00001

literal 22519
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

diff --git a/configure.ac b/configure.ac
old mode 100644
new mode 100755
diff --git a/db/linux_kernel/.gitignore b/db/linux_kernel/.gitignore
new file mode 100644
index 0000000..8206227
--- /dev/null
+++ b/db/linux_kernel/.gitignore
@@ -0,0 +1 @@
+db_common.c
diff --git a/db/linux_kernel/Makefile.in b/db/linux_kernel/Makefile.in
new file mode 100644
index 0000000..5259e68
--- /dev/null
+++ b/db/linux_kernel/Makefile.in
@@ -0,0 +1,26 @@
+DB_SRCDIR = @SRCDIR@/db/linux_kernel
+
+obj-m       := kdb.o
+shared_src  := db_common.c
+kernel_src  := db.c
+kdb-y       := $(shared_src:.c=.o) $(kernel_src:.c=.o)
+orig        := $(shared_src:%=../%)
+
+EXTRA_CFLAGS = -DHAVE_CONFIG_H -I@SRCDIR@ @KCFLAGS@
+
+prepare:
+	ln -fs $(orig) .
+
+install modules_install:
+	$(MAKE) INSTALL_MOD_DIR=kernel/fs/db -C @LINUX_OBJ@ M=`pwd` modules_install
+
+uninstall:
+	rm -fr @LUNUX_MOD@/kernel/fs/db
+
+clean distclean:
+	$(RM) $(shared_src) Module.markers Module.symvers modules.order
+	$(MAKE) -C @LINUX_OBJ@ M=`pwd` clean
+
+distdir:
+	cp $(DB_SRCDIR)/Makefile.in $(DB_SRCDIR)/db.c $(DB_SRCDIR)/db_impl.h \
+           @top_builddir@/@PACKAGE@-@VERSION@/db/linux_kernel
diff --git a/doc/dld-sample-uml.png b/doc/dld-sample-uml.png
deleted file mode 100644
index e7c85018bb734dfe3b28ba6458257f72a5bc3540..0000000000000000000000000000000000000000
GIT binary patch
literal 0
HcmV?d00001

literal 40112
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

diff --git a/fop/linux_kernel/.gitignore b/fop/linux_kernel/.gitignore
new file mode 100644
index 0000000..a5ab6b5
--- /dev/null
+++ b/fop/linux_kernel/.gitignore
@@ -0,0 +1,3 @@
+fop.c
+fop_format.c
+fop_iterator.c
diff --git a/fop/linux_kernel/Makefile.in b/fop/linux_kernel/Makefile.in
new file mode 100644
index 0000000..227d126
--- /dev/null
+++ b/fop/linux_kernel/Makefile.in
@@ -0,0 +1,26 @@
+FOP_SRCDIR = @SRCDIR@/fop/linux_kernel
+
+obj-m       := kfop.o
+shared_src  := fop.c fop_format.c fop_iterator.c
+kernel_src  := fop_kernel.c
+kfop-y      := $(shared_src:.c=.o) $(kernel_src:.c=.o)
+orig        := $(shared_src:%=../%)
+
+EXTRA_CFLAGS = -DHAVE_CONFIG_H -I@SRCDIR@ @KCFLAGS@
+
+prepare:
+	ln -fs $(orig) .
+
+install modules_install:
+	$(MAKE) INSTALL_MOD_DIR=kernel/fs/fop -C @LINUX_OBJ@ M=`pwd` modules_install
+
+uninstall:
+	rm -fr @LUNUX_MOD@/kernel/fs/fop
+
+clean distclean:
+	$(RM) $(shared_src) Module.markers Module.symvers modules.order
+	$(MAKE) -C @LINUX_OBJ@ M=`pwd` clean
+
+distdir:
+	cp $(FOP_SRCDIR)/Makefile.in $(FOP_SRCDIR)/fop_kernel.c $(FOP_SRCDIR)/fop_kernel.h \
+           @top_builddir@/@PACKAGE@-@VERSION@/fop/linux_kernel
diff --git a/fop/linux_kernel/fop_kernel.c b/fop/linux_kernel/fop_kernel.c
new file mode 100644
index 0000000..3c90cf6
--- /dev/null
+++ b/fop/linux_kernel/fop_kernel.c
@@ -0,0 +1,51 @@
+/* -*- C -*- */
+/*
+ * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: Nikita Danilov <nikita_danilov@xyratex.com>
+ * Original creation date: 08/04/2010
+ */
+
+#include <linux/module.h>
+
+#include "fop/fop.h"
+
+/**
+   @addtogroup fop
+   @{
+ */
+
+int init_module(void)
+{
+        return c2_fops_init();
+}
+
+void cleanup_module(void)
+{
+        c2_fops_fini();
+}
+
+
+/** @} end of fop group */
+
+/* 
+ *  Local variables:
+ *  c-indentation-style: "K&R"
+ *  c-basic-offset: 8
+ *  tab-width: 8
+ *  fill-column: 80
+ *  scroll-step: 1
+ *  End:
+ */
diff --git a/galois/linux_kernel/.gitignore b/galois/linux_kernel/.gitignore
new file mode 100644
index 0000000..6406c60
--- /dev/null
+++ b/galois/linux_kernel/.gitignore
@@ -0,0 +1 @@
+galois.c
diff --git a/galois/linux_kernel/Makefile.in b/galois/linux_kernel/Makefile.in
new file mode 100644
index 0000000..063be3f
--- /dev/null
+++ b/galois/linux_kernel/Makefile.in
@@ -0,0 +1,21 @@
+GALOIS_KERNEL_SRCDIR = @SRCDIR@/galois/linux_kernel
+GALOIS_SRCDIR = @SRCDIR@/../galois
+
+obj-m       := kgalois.o
+shared_src  := galois.c
+kernel_src  := kgalois.c
+kgalois-y   := $(shared_src:.c=.o) $(kernel_src:.c=.o)
+orig        := $(shared_src:%=$(GALOIS_SRCDIR)/%)
+
+EXTRA_CFLAGS = -DHAVE_CONFIG_H -I@SRCDIR@ -I$(GALOIS_SRCDIR) @KCFLAGS@
+
+prepare:
+	ln -fs $(orig) .
+
+clean distclean:
+	$(RM) $(shared_src) Module.markers Module.symvers modules.order
+	$(MAKE) -C @LINUX_OBJ@ M=`pwd` clean
+
+distdir:
+	cp $(GALOIS_KERNEL_SRCDIR)/Makefile.in \
+           @top_builddir@/@PACKAGE@-@VERSION@/galois/linux_kernel
diff --git a/layout/linux_kernel/.gitignore b/layout/linux_kernel/.gitignore
new file mode 100644
index 0000000..55c5c67
--- /dev/null
+++ b/layout/linux_kernel/.gitignore
@@ -0,0 +1,2 @@
+layout.c
+pdclust.c
diff --git a/layout/linux_kernel/Makefile.in b/layout/linux_kernel/Makefile.in
new file mode 100644
index 0000000..254407f
--- /dev/null
+++ b/layout/linux_kernel/Makefile.in
@@ -0,0 +1,20 @@
+LAYOUT_SRCDIR = @SRCDIR@/layout/linux_kernel
+
+obj-m       := klayout.o
+shared_src  := layout.c pdclust.c
+kernel_src  := klayout.c
+klayout-y   := $(shared_src:.c=.o) $(kernel_src:.c=.o)
+orig        := $(shared_src:%=../%)
+
+EXTRA_CFLAGS = -DHAVE_CONFIG_H -I@SRCDIR@ @KCFLAGS@
+
+prepare:
+	ln -fs $(orig) .
+
+clean distclean:
+	$(RM) $(shared_src) Module.markers Module.symvers modules.order
+	$(MAKE) -C @LINUX_OBJ@ M=`pwd` clean
+
+distdir:
+	cp $(LAYOUT_SRCDIR)/Makefile.in \
+           @top_builddir@/@PACKAGE@-@VERSION@/layout/linux_kernel
diff --git a/lib/libc2.c b/lib/libc2.c
new file mode 100644
index 0000000..c5fd906
--- /dev/null
+++ b/lib/libc2.c
@@ -0,0 +1,41 @@
+/*
+ * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: Yuriy Umanets <Yuriy_Umanets@xyratex.com>
+ * Original creation date: 01/23/2010
+ */
+
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+
+int libc2_init()
+{
+	return 0;
+}
+
+void libc2_fini()
+{
+}
+
+/*
+ *  Local variables:
+ *  c-indentation-style: "K&R"
+ *  c-basic-offset: 8
+ *  tab-width: 8
+ *  fill-column: 80
+ *  scroll-step: 1
+ *  End:
+ */
diff --git a/lib/linux_kernel/.gitignore b/lib/linux_kernel/.gitignore
new file mode 100644
index 0000000..5c77498
--- /dev/null
+++ b/lib/linux_kernel/.gitignore
@@ -0,0 +1,11 @@
+list.c
+queue.c
+vec.c
+thread.c
+time.c
+refs.c
+bitmap.c
+buf.c
+misc.c
+chan.c
+cond.c
diff --git a/lib/linux_kernel/Makefile.in b/lib/linux_kernel/Makefile.in
new file mode 100644
index 0000000..0c10a522
--- /dev/null
+++ b/lib/linux_kernel/Makefile.in
@@ -0,0 +1,37 @@
+LIB_SRCDIR = @SRCDIR@/lib/linux_kernel
+
+obj-m       := klibc2.o
+shared_src  := vec.c list.c queue.c refs.c time.c bitmap.c chan.c misc.c buf.c\
+               cond.c thread.c
+kernel_src  := memory.c mutex.c refs.c rwlock.c ktime.c timer.c kthread.c \
+               semaphore.c main.c processor.c ut.c
+klibc2-y    := $(shared_src:.c=.o) $(kernel_src:.c=.o)
+orig_src    := $(shared_src:%=../%)
+
+EXTRA_CFLAGS = -DHAVE_CONFIG_H -I@SRCDIR@ @KCFLAGS@
+
+prepare:
+	ln -fs $(orig_src) .
+
+install modules_install:
+	$(MAKE) INSTALL_MOD_DIR=kernel/fs/libc2 -C @LINUX_OBJ@ M=`pwd` modules_install
+
+uninstall:
+	rm -fr @LUNUX_MOD@/kernel/fs/libc2
+
+clean distclean:
+	$(RM) $(shared_src) Module.markers Module.symvers modules.order
+	$(MAKE) -C @LINUX_OBJ@ M=`pwd` clean
+
+distdir:
+	cp $(LIB_SRCDIR)/Makefile.in $(LIB_SRCDIR)/main.c \
+	$(LIB_SRCDIR)/memory.c $(LIB_SRCDIR)/mutex.c \
+	$(LIB_SRCDIR)/time.c $(LIB_SRCDIR)/ktime.c \
+	$(LIB_SRCDIR)/kthread.c $(LIB_SRCDIR)/thread.h \
+	$(LIB_SRCDIR)/assert.h $(LIB_SRCDIR)/cdefs.h \
+	$(LIB_SRCDIR)/mutex.h $(LIB_SRCDIR)/time.h \
+	$(LIB_SRCDIR)/types.h $(LIB_SRCDIR)/chan.h \
+	$(LIB_SRCDIR)/timer.h $(LIB_SRCDIR)/timer.c \
+	$(LIB_SRCDIR)/rwlock.h $(LIB_SRCDIR)/rwlock.c \
+	$(LIB_SRCDIR)/atomic64.h \
+@top_builddir@/@PACKAGE@-@VERSION@/lib/linux_kernel
diff --git a/lib/linux_kernel/ut/.gitignore b/lib/linux_kernel/ut/.gitignore
new file mode 100644
index 0000000..ce3bb5b
--- /dev/null
+++ b/lib/linux_kernel/ut/.gitignore
@@ -0,0 +1,2 @@
+chan.c
+thread.c
diff --git a/lib/memory.c b/lib/memory.c
new file mode 100644
index 0000000..ce75708
--- /dev/null
+++ b/lib/memory.c
@@ -0,0 +1,174 @@
+/*
+ * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: Nikita Danilov
+ * Original creation date: 05/17/2010
+ */
+
+
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+
+#include <stdlib.h>
+#include <string.h>
+
+#include "lib/arith.h"   /* min_type, c2_is_po2 */
+#include "lib/assert.h"
+#include "lib/atomic.h"
+#include "lib/memory.h"
+
+/**
+   @addtogroup memory
+
+   <b>User level malloc(3) based implementation.</b>
+
+   The only interesting detail is implementation of c2_allocated(). No standard
+   function returns the amount of memory allocated in the arena.
+
+   GNU Libc defines mallinfo() function, returning the amount of allocated
+   memory among other things. In OS X (of all places) there is malloc_size()
+   function that, given a pointer to an allocated block of memory, returns its
+   size. On other platforms c2_allocates() is always 0.
+
+   @{
+*/
+
+static struct c2_atomic64 allocated;
+
+#ifdef HAVE_MALLINFO
+
+#include <malloc.h>
+static size_t __allocated(void)
+{
+	struct mallinfo mi;
+
+	mi = mallinfo();
+	return mi.uordblks;
+}
+#define __free free
+#define __malloc malloc
+
+/* HAVE_MALLINFO */
+#elif HAVE_MALLOC_SIZE
+
+#include <malloc/malloc.h>
+
+static void __free(void *ptr)
+{
+	c2_atomic64_sub(&allocated, malloc_size(ptr));
+	free(ptr);
+}
+
+void *__malloc(size_t size)
+{
+	void *area;
+
+	area = malloc(size);
+	c2_atomic64_add(&allocated, malloc_size(area));
+	return area;
+}
+
+static size_t __allocated(void)
+{
+	return c2_atomic64_get(&allocated);
+}
+
+/* HAVE_MALLOC_SIZE */
+#else
+
+static size_t __allocated(void)
+{
+	return 0;
+}
+
+#define __free free
+#define __malloc malloc
+
+#endif
+
+void *c2_alloc(size_t size)
+{
+	void *ret;
+
+	ret = __malloc(size);
+	if (ret)
+		memset(ret, 0, size);
+
+	return ret;
+}
+
+void c2_free(void *data)
+{
+	__free(data);
+}
+
+static size_t used0;
+
+size_t c2_allocated(void)
+{
+	size_t used;
+
+	used = __allocated();
+	if (used < used0)
+		used = used0;
+	return used - used0;
+}
+
+void *c2_alloc_aligned(size_t size, unsigned shift)
+{
+	void  *result;
+	int    rc;
+	size_t alignment;
+
+	/*
+	 * posix_memalign(3):
+	 *
+	 *         The requested alignment must be a power of 2 at least as
+	 *         large as sizeof(void *).
+	 */
+
+	alignment = max_type(size_t, 1 << shift, sizeof result);
+	C2_ASSERT(c2_is_po2(alignment));
+	rc = posix_memalign(&result, alignment, size);
+	if (rc == 0)
+		memset(result, 0, size);
+	else
+		result = NULL;
+	return result;
+}
+
+int c2_memory_init()
+{
+	c2_atomic64_set(&allocated, 0);
+	used0 = __allocated();
+	return 0;
+}
+
+void c2_memory_fini()
+{
+}
+
+/** @} end of memory group */
+
+/*
+ *  Local variables:
+ *  c-indentation-style: "K&R"
+ *  c-basic-offset: 8
+ *  tab-width: 8
+ *  fill-column: 80
+ *  scroll-step: 1
+ *  End:
+ */
diff --git a/lib/user_space/chan.h b/lib/user_space/chan.h
new file mode 100644
index 0000000..b667a20
--- /dev/null
+++ b/lib/user_space/chan.h
@@ -0,0 +1,140 @@
+/* -*- C -*- */
+/*
+ * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: Huang Hua
+ * Original creation date: 12/02/2010
+ */
+
+#ifndef __COLIBRI_LIB_USER_SPACE_CHAN_H__
+#define __COLIBRI_LIB_USER_SPACE_CHAN_H__
+
+#include <semaphore.h>
+
+/**
+   @addtogroup chan
+
+   <b>User space chan.</b>
+   @{
+*/
+
+/**
+   A stream of asynchronous events.
+
+   <b>Concurrency control</b>
+
+   Implementation serializes producer interface calls, but see
+   c2_chan_broadcast() description. Implementation serializes c2_clink_add() and
+   c2_clink_del() calls against a given channel.
+
+   <b>Liveness</b>
+
+   A user has to enforce a serialization between event production and channel
+   destruction. Implementation guarantees that call to c2_chan_fini() first
+   waits until calls to c2_chan_{signal,broadcast}() that started before this
+   c2_chan_fini() call complete. This make the following idiomatic usage safe:
+
+   @code
+   struct c2_chan *complete;
+
+   producer() {
+           ...
+           c2_chan_signal(complete);
+   }
+
+   consumer() {
+           c2_clink_add(complete, &wait);
+           for (i = 0; i < nr_producers; ++i)
+                   c2_chan_wait(&wait);
+           c2_clink_del(&wait);
+           c2_chan_fini(complete);
+           c2_free(complete);
+   }
+   @endcode
+
+   <b>Invariants</b>
+
+   c2_chan_invariant()
+ */
+struct c2_chan {
+	/** Lock protecting other fields. */
+	struct c2_mutex ch_guard;
+	/** List of registered clinks. */
+	struct c2_list  ch_links;
+	/** Number of clinks in c2_chan::ch_links. This is used to speed up
+	    c2_chan_broadcast(). */
+	uint32_t        ch_waiters;
+};
+
+struct c2_clink;
+typedef void (*c2_chan_cb_t)(struct c2_clink *link);
+/**
+   A record of interest in events on a stream.
+
+   A clink records the appearance of events in the stream.
+
+   There are two mutually exclusive ways to use a clink:
+
+   @li an asynchronous call-back can be specified as an argument to clink
+   constructor c2_clink_init(). This call-back is called when an event happens
+   in the channel the clink is registered with. It is guaranteed that a
+   call-back is executed in the same context where event producer declared new
+   event. A per-channel mutex c2_chan::ch_guard is held while call-backs are
+   executed.
+
+   @li once a clink is registered with a channel, it is possible to wait until
+   an event happens by calling c2_clink_wait().
+
+   <b>Concurrency control</b>
+
+   A user must guarantee that at most one thread waits on a
+   clink. Synchronization between call-backs, waits and clink destruction is
+   also up to user.
+
+   A user owns a clink before call to c2_chan_add() and after return from the
+   c2_chan_del() call. At any other time clink can be concurrently accessed by
+   the implementation.
+
+   <b>Liveness</b>
+
+   A user is free to dispose a clink whenever it owns the latter.
+ */
+struct c2_clink {
+	/** Channel this clink is registered with. */
+	struct c2_chan     *cl_chan;
+	/** Call-back to be called when event is declared. */
+	c2_chan_cb_t        cl_cb;
+	/** Linkage into c2_chan::ch_links */
+	struct c2_list_link cl_linkage;
+	/** POSIX.1-2001 semaphore for now. */
+	sem_t               cl_wait;
+};
+
+
+
+/** @} end of chan group */
+
+/* __COLIBRI_LIB_USER_SPACE_CHAN_H__ */
+#endif
+
+/* 
+ *  Local variables:
+ *  c-indentation-style: "K&R"
+ *  c-basic-offset: 8
+ *  tab-width: 8
+ *  fill-column: 80
+ *  scroll-step: 1
+ *  End:
+ */
diff --git a/lib/user_space/time.c b/lib/user_space/time.c
new file mode 120000
index 0000000..c82d4a7
--- /dev/null
+++ b/lib/user_space/time.c
@@ -0,0 +1 @@
+../time.c
\ No newline at end of file
diff --git a/lib/user_space/trace.c b/lib/user_space/trace.c
new file mode 100644
index 0000000..2f1f43e
--- /dev/null
+++ b/lib/user_space/trace.c
@@ -0,0 +1,297 @@
+/* -*- C -*- */
+/*
+ * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: Nikita Danilov
+ * Original creation date: 08/12/2010
+ */
+
+#include <sys/mman.h> /* mmap */
+#include <time.h>
+#include <unistd.h>   /* getpagesize */
+#include <fcntl.h>    /* open, O_RDWR|O_CREAT|O_TRUNC */
+#include <string.h>   /* memset */
+#include <stdio.h>    /* getchar */
+#include <ctype.h>    /* isspace */
+
+#include "lib/errno.h"
+#include "lib/atomic.h"
+#include "lib/cdefs.h"
+#include "lib/arith.h" /* c2_align */
+#include "lib/trace.h"
+
+/**
+   @addtogroup trace
+
+   <b>User space trace implementation.</b>
+
+   Trace entries are placed in a largish buffer backed up by a memory mapped
+   file. Buffer space allocation is controlled by a single atomic variable
+   (cur).
+
+   Trace entries contain pointers from the process address space. To interpret
+   them, c2_trace_parse() must be called in the same binary. See utils/ut_main.c
+   for example.
+
+   @note things like address space layout randomization might break this
+   implementation.
+
+   @{
+ */
+
+/* single buffer for now */
+static void              *logbuf;
+static uint32_t           bufshift;
+static uint32_t           bufsize;
+static uint32_t           bufmask;
+static int                logfd;
+static struct c2_atomic64 cur;
+
+enum {
+	MAGIC = 0xc0de1eafacc01adeULL,
+};
+
+/*
+ * XXX x86_64 version.
+ */
+static inline uint64_t rdtsc(void)
+{
+	uint32_t count_hi;
+	uint32_t count_lo;
+
+	__asm__ __volatile__("rdtsc" : "=a"(count_lo), "=d"(count_hi));
+
+	return ((uint64_t)count_lo) | (((uint64_t)count_hi) << 32);
+}
+
+void *c2_trace_allot(const struct c2_trace_descr *td)
+{
+	uint32_t                    record_len;
+	uint32_t                    header_len;
+	struct c2_trace_rec_header *header;
+	uint64_t                    pos;
+	uint64_t                    endpos;
+	uint32_t                    pos_in_buf;
+
+	/*
+	 * Allocate space in trace buffer to store trace record header
+	 * (header_len bytes) and record payload (record_len bytes).
+	 *
+	 * Record and payload always start at 8-byte aligned address.
+	 *
+	 * First free byte in the trace buffer is at "cur" offset. Note, that
+	 * cur is not wrapped to 0 when the end of the buffer is reached (that
+	 * would require additional synchronization between contending threads).
+	 */
+
+	header_len = c2_align(sizeof *header, 8);
+	record_len = header_len + c2_align(td->td_size, 8);
+
+	while (1) {
+		endpos = c2_atomic64_add_return(&cur, record_len);
+		pos    = endpos - record_len;
+		pos_in_buf = pos & bufmask;
+		/*
+		 * If allocated space crosses buffer end, zero allocated parts
+		 * of the buffer and allocate anew. Allocated space remains lost
+		 * until the buffer is wrapped over again.
+		 */
+		if ((pos >> bufshift) != (endpos >> bufshift)) {
+			memset(logbuf + pos_in_buf, 0, bufsize - pos_in_buf);
+			memset(logbuf, 0, endpos & bufmask);
+		} else
+			break;
+	}
+
+	header                = logbuf + pos_in_buf;
+	header->thr_magic     = MAGIC;
+	/* select thr_no so that it increases over time but never 0. */
+	header->thr_no        = (pos & ((1ULL << 62) - 1)) + 1;
+	header->trh_timestamp = rdtsc();
+	header->trh_descr     = td;
+	return ((void *)header) + header_len;
+}
+
+static void align(unsigned align)
+{
+	C2_ASSERT(c2_is_po2(align));
+	while (ftell(stdin) & (align - 1))
+		getchar();
+}
+
+static void trace_decl(const char *decl)
+{
+	void skip(void) {
+		while (isspace(*decl))
+			decl++;
+	}
+
+	bool gotmatch(const char *keyword) {
+		if (!strncmp(decl, keyword, strlen(keyword))) {
+			decl += strlen(keyword);
+			return true;
+		} else
+			return false;
+	}
+
+	void field(int size, const char *fmt, int alignment) {
+		union {
+			uint16_t v16;
+			uint32_t v32;
+			uint64_t v64;
+		} val;
+		int  nr;
+
+		align(alignment);
+		nr = fread(&val, size, 1, stdin);
+		C2_ASSERT(nr == 1);
+
+		skip();
+		/* skip field name */
+		while (('A' <= toupper(*decl) && toupper(*decl) <= 'Z') ||
+		       ('0' <= *decl && *decl <= '9') ||
+		       index("_$", *decl) != NULL)
+			printf("%c", *decl++);
+
+		printf(": ");
+		printf(fmt, val);
+		printf(" ");
+
+		skip();
+		C2_ASSERT(*decl == ';');
+		decl++;
+		skip();
+	}
+
+#define DECL(type, fmt)						\
+	if (gotmatch(#type)) {					\
+		field(sizeof(type), "%"fmt, __alignof__(type));	\
+		continue;					\
+	}
+
+	skip();
+	C2_ASSERT(*decl == '{');
+	decl++;
+	skip();
+	while (*decl != '}') {
+		while (gotmatch("const") || gotmatch("volatile") ||
+		       gotmatch("unsigned"))
+			skip();
+
+		DECL(uint32_t, "u");
+		DECL(uint16_t, "u");
+		DECL(uint64_t, "lu");
+		DECL(int32_t,  "d");
+		DECL(int16_t,  "d");
+		DECL(int64_t,  "ld");
+	}
+}
+
+/**
+   Parse log buffer supplied at stderr.
+
+   When a trace record is defined by C2_TRACE_POINT(), a declaration of its
+   format is stored in c2_trace_descr::td_decl as a NUL-terminated string
+   containing C declaration. trace_decl() is an extremely crude ad-hoc parser
+   for this string.
+ */
+int c2_trace_parse(void)
+{
+	uint64_t                     magic;
+	uint64_t                     no;
+	uint64_t                     timestamp;
+	const struct c2_trace_descr *td;
+	int                          nr;
+
+	char int2ch(int x) {
+		return x < 10 ? '0' + x : 'a' + x - 10;
+	}
+
+	while (!feof(stdin)) {
+		/* At the beginning of a record */
+		align(8);
+
+		do {
+			nr = fread(&magic, sizeof magic, 1, stdin);
+			if (nr == 0) {
+				C2_ASSERT(feof(stdin));
+				return 0;
+			}
+		} while (magic != MAGIC);
+
+		nr = fread(&no, sizeof no, 1, stdin);
+		C2_ASSERT(nr == 1);
+
+		nr = fread(&timestamp, sizeof timestamp, 1, stdin);
+		C2_ASSERT(nr == 1);
+
+		nr = fread(&td, sizeof td, 1, stdin);
+		C2_ASSERT(nr == 1);
+
+		printf("%10.10lu  %10.10lu  %15s %15s %4i %3.3i %s\n\t",
+		       no, timestamp, td->td_func, td->td_file,
+		       td->td_line, td->td_size, td->td_decl);
+		align(8);
+		trace_decl(td->td_decl);
+		align(8);
+		printf("\n");
+	}
+	return 0;
+}
+
+enum {
+	BUFSHIFT = 10 + 12, /* 4MB log buffer */
+	BUFSIZE  = 1 << BUFSHIFT
+};
+
+int c2_trace_init(void)
+{
+	int psize;
+
+	c2_atomic64_set(&cur, 0);
+	bufshift = BUFSHIFT;
+	bufsize  = BUFSIZE;
+	bufmask  = bufsize - 1;
+
+	psize = getpagesize();
+	C2_ASSERT((BUFSIZE % psize) == 0);
+
+	logfd = open("c2.trace", O_RDWR|O_CREAT|O_TRUNC, 0700);
+	if (logfd != -1) {
+		if (ftruncate(logfd, BUFSIZE) == 0) {
+			logbuf = mmap(NULL, BUFSIZE, PROT_WRITE,
+				      MAP_SHARED, logfd, 0);
+		}
+	}
+	return -errno;
+}
+
+void c2_trace_fini(void)
+{
+	munmap(logbuf, bufsize);
+	close(logfd);
+}
+
+/** @} end of trace group */
+
+/*
+ *  Local variables:
+ *  c-indentation-style: "K&R"
+ *  c-basic-offset: 8
+ *  tab-width: 8
+ *  fill-column: 80
+ *  scroll-step: 1
+ *  End:
+ */
diff --git a/net/ksunrpc/Makefile.in b/net/ksunrpc/Makefile.in
new file mode 100644
index 0000000..a1761cd
--- /dev/null
+++ b/net/ksunrpc/Makefile.in
@@ -0,0 +1,29 @@
+KSUNRPC_SRCDIR = @SRCDIR@/net/ksunrpc
+OTW_K_HEADERS = net_otw_types_k.h
+
+obj-m := ksunrpc.o
+shared_src  := connection.c net.c net_cli.c net_utils.c net_otw_types_k.c
+kernel_src  := client.c kxdr.c domain.c
+ksunrpc-y   := $(shared_src:.c=.o) $(kernel_src:.c=.o)
+orig        := $(shared_src:%=../%) $(OTW_K_HEADERS:%=../%)
+
+EXTRA_CFLAGS = -DHAVE_CONFIG_H -I@SRCDIR@ @KCFLAGS@ -O2
+
+prepare:
+	ln -fs $(orig) .
+
+install modules_install:
+	$(MAKE) INSTALL_MOD_DIR=kernel/fs/ksunrpc -C @LINUX_OBJ@ M=`pwd` modules_install
+
+uninstall:
+	rm -fr @LUNUX_MOD@/kernel/fs/ksunrpc
+
+distclean clean:
+	$(MAKE) -C @LINUX_OBJ@ M=`pwd` clean;
+	rm -fr $(shared_src) $(OTW_K_HEADERS) Module.symvers
+
+distdir:
+	cp $(KSUNRPC_SRCDIR)/Makefile.in $(KSUNRPC_SRCDIR)/ksunrpc.h \
+           $(KSUNRPC_SRCDIR)/kxdr.c $(KSUNRPC_SRCDIR)/client.c \
+           $(KSUNRPC_SRCDIR)/domain.c \
+           @top_builddir@/@PACKAGE@-@VERSION@/net/ksunrpc
diff --git a/net/lnet/lnet_xo.dia b/net/lnet/lnet_xo.dia
deleted file mode 100644
index 51608e3892bcf7abc14025d4083058b571ba6c94..0000000000000000000000000000000000000000
GIT binary patch
literal 0
HcmV?d00001

literal 7308
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
Hg^KiF@ZpFv

diff --git a/net/lnet/lnet_xo.png b/net/lnet/lnet_xo.png
deleted file mode 100644
index d0597e5e32d5e81de8437d536df320a0d9a42b20..0000000000000000000000000000000000000000
GIT binary patch
literal 0
HcmV?d00001

literal 70749
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
L#NaN~{+E9MEl~Am

diff --git a/net/st/connection.c b/net/st/connection.c
new file mode 100644
index 0000000..281849a
--- /dev/null
+++ b/net/st/connection.c
@@ -0,0 +1,132 @@
+/*
+ * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: Alexey Lyashkov
+ * Original creation date: 05/07/2010
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "lib/assert.h"
+#include "net/net.h"
+#include "net/usunrpc/usunrpc.h"
+
+#define CU_ASSERT(a)	C2_ASSERT(a)
+
+static struct c2_net_domain dom;
+static struct c2_service_id sid;
+static char *test_addr;
+static int test_port;
+
+/* The suite initialization function.
+ * Returns zero on success, non-zero otherwise.
+ */
+static int init_suite(void)
+{
+	int rc;
+
+	rc = c2_net_init();
+	CU_ASSERT(rc == 0);
+
+	rc = c2_net_xprt_init(&c2_net_usunrpc_xprt);
+	CU_ASSERT(rc == 0);
+	
+	rc = c2_net_domain_init(&dom, &c2_net_usunrpc_xprt);
+	CU_ASSERT(rc == 0);
+
+	rc = c2_service_id_init(&sid, &dom, test_addr, test_port);
+	CU_ASSERT(rc == 0);
+
+	return 0;
+}
+
+/* The suite cleanup function.
+ * Returns zero on success, non-zero otherwise.
+ */
+static int clean_suite(void)
+{
+	c2_service_id_fini(&sid);
+	c2_net_domain_fini(&dom);
+	c2_net_xprt_fini(&c2_net_usunrpc_xprt);
+	c2_net_fini();
+	return 0;
+}
+
+static void test_create(void)
+{
+	int rc;
+
+	rc = c2_net_conn_create(&sid);
+	CU_ASSERT(rc == 0);
+}
+
+static void test_destroy(void)
+{
+	struct c2_net_conn *conn1;
+	struct c2_net_conn *conn2;
+
+	conn1 = c2_net_conn_find(&sid);
+	CU_ASSERT(conn1 != NULL);
+	c2_net_conn_unlink(conn1);
+	conn2 = c2_net_conn_find(&sid);
+	CU_ASSERT(conn2 == NULL);
+	c2_net_conn_release(conn1);
+}
+
+static void test_create2(void)
+{
+	int rc;
+
+	rc = c2_net_conn_create(&sid);
+	CU_ASSERT(rc == 0);
+}
+
+int usage(char *appname)
+{
+	printf("%s ip-address port\nex: %s %s %s",
+	       appname, appname, "127.0.0.1", "10001");
+	return 1;
+}
+
+int main(int argc, char *argv[])
+{
+	if (argc != 3)
+		return usage(argv[0]);
+	test_addr = argv[1];
+	test_port = atoi(argv[2]);
+
+	init_suite();
+
+	test_create();
+	test_destroy();
+
+	test_create2();
+	test_destroy();
+
+	clean_suite();
+	return 0;
+}
+
+/* 
+ *  Local variables:
+ *  c-indentation-style: "K&R"
+ *  c-basic-offset: 8
+ *  tab-width: 8
+ *  fill-column: 80
+ *  scroll-step: 1
+ *  End:
+ */
diff --git a/pool/linux_kernel/.gitignore b/pool/linux_kernel/.gitignore
new file mode 100644
index 0000000..a02f2d4
--- /dev/null
+++ b/pool/linux_kernel/.gitignore
@@ -0,0 +1 @@
+pool.c
diff --git a/pool/linux_kernel/Makefile.in b/pool/linux_kernel/Makefile.in
new file mode 100644
index 0000000..57ba414
--- /dev/null
+++ b/pool/linux_kernel/Makefile.in
@@ -0,0 +1,21 @@
+POOL_SRCDIR = @SRCDIR@/pool/linux_kernel
+
+obj-m       := kpool.o
+shared_src  := pool.c
+kernel_src  := kpool.c
+kpool-y     := $(shared_src:.c=.o) $(kernel_src:.c=.o)
+orig        := $(shared_src:%=../%)
+
+
+EXTRA_CFLAGS = -DHAVE_CONFIG_H -I@SRCDIR@ @KCFLAGS@
+
+prepare:
+	ln -fs $(orig) .
+
+clean distclean:
+	$(RM) $(shared_src) Module.markers Module.symvers modules.order
+	$(MAKE) -C @LINUX_OBJ@ M=`pwd` clean
+
+distdir:
+	cp $(POOL_SRCDIR)/Makefile.in \
+           @top_builddir@/@PACKAGE@-@VERSION@/pool/linux_kernel
diff --git a/pool/linux_kernel/kpool.c b/pool/linux_kernel/kpool.c
new file mode 100644
index 0000000..bbc9223
--- /dev/null
+++ b/pool/linux_kernel/kpool.c
@@ -0,0 +1,22 @@
+/*
+ * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: Nikita Danilov
+ * Original creation date: 07/15/2010
+ */
+
+void __pool_dummy_foo(void)
+{
+}
diff --git a/rpc/compound.c b/rpc/compound.c
new file mode 100644
index 0000000..a63741b
--- /dev/null
+++ b/rpc/compound.c
@@ -0,0 +1,32 @@
+/*
+ * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: Alexey Lyashkov
+ * Original creation date: 04/11/2010
+ */
+
+#include <rpc/compound.h>
+int compound_send_noseq(const struct rpc_client *cli,
+		        unsigned int num_ops, void *ops)
+{
+
+}
+
+int compound_send_seq(const struct rpc_client *cli, struct c2_cli_slot *slot,
+		      unsigned int num_ops, void *ops);
+{
+
+}
+
diff --git a/rpc/compound_cli.h b/rpc/compound_cli.h
new file mode 100644
index 0000000..d36f201
--- /dev/null
+++ b/rpc/compound_cli.h
@@ -0,0 +1,71 @@
+/* -*- C -*- */
+/*
+ * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: Alexey Lyashkov
+ * Original creation date: 05/12/2010
+ */
+
+#ifndef __COLIBRI_RPC_COMPOUND_CLI_H__
+
+#define __COLIBRI_RPC_COMPOUND_CLI_H__
+/**
+ @page rpc-compound COMPOUND related functions
+
+ COMPOUND is ability to send many operations with own parameters
+ inside single RPC command.
+ this will reduce latencety to process single rpc
+
+ @ref rpc-compound-types
+ */
+
+/**
+ @section rpc-compound-client functions is related to client side
+ */
+
+/**
+ send COMPOUND rpc without update seqence, and not uses a slot.
+ function allocate request, put operations in own body and quered
+ to send.
+
+ @param cli - connected rpc client
+ @param num_ops - number of operations (not used now)
+ @param ops - pointer to array of operation (not used now)
+
+ @retval 0 - RPC is quered to send.
+ @retval <0 - RPC not quered to send due errors
+ */
+int c2_compound_send_noseq(const struct rpc_client *cli,
+			   const unsigned int num_ops, const void *ops);
+
+/**
+ send COMPOUND rpc with uses slot and update sequence.
+
+ in additionaly to c2_compound_send_noseq function - that functions
+ create sequence operation and insert as first operation in RPC.
+ others operations is added after sequence operation.
+
+ @param cli - connected rpc client
+ @param slot - session slot used to send message.
+ @param num_ops - number of operations (not used now)
+ @param ops - pointer to array of operation (not used now)
+
+ @retval 0 - RPC is quered to send.
+ @retval <0 - RPC not quered to send due errors
+ */
+int c2_compound_send_seq(const struct c2_rpc_client *cli, struct c2_cli_slot *slot,
+			 const unsigned int num_ops, const void *ops);
+
+#endif
diff --git a/rpc/compound_types.h b/rpc/compound_types.h
new file mode 100644
index 0000000..d616367
--- /dev/null
+++ b/rpc/compound_types.h
@@ -0,0 +1,130 @@
+/* -*- C -*- */
+/*
+ * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: Alexey Lyashkov
+ * Original creation date: 05/12/2010
+ */
+
+#ifndef __COLIBRI_RPC_COMPOUND_TYPES_H__
+
+#define __COLIBRI_RPC_COMPOUND_TYPES_H__
+
+#include <rpc/rpc_types.h>
+
+/**
+ Operations inside compound request
+ */
+enum c2_compound_op {
+	C2_COMP_NULL = 0,
+	C2_COMP_SEQUENCE,
+	C2_COMP_MAX_OP
+};
+
+/**
+ parameters to sequence operation
+ */
+struct c2_session_sequence_args {
+	/**
+	 slot indetifyer to sequence protection
+	 */
+	uint32_t ssa_slot_id;
+	/**
+	 new sequence in the slot
+	 */
+	c2_seq_id ssa_sequence_id;
+};
+/**
+ reply to sequence operation
+ */
+struct c2_session_sequence_reply {
+	/**
+	 status of operation
+	 */
+	int32_t error;
+};
+
+
+/**
+ body of one operation
+ */
+struct c2_compound_op_arg {
+	enum c2_session_compound_op c2op;
+	/**
+	 all arguments of operation should be listed here and xdr function need
+	 to be updated
+	*/
+	union {
+		struct c2_session_sequence_args sess_args;
+	} compound_op_arg_u;
+};
+
+/**
+ C2_COMPOUND_COMMAND body
+ send many operations inside single command.
+ */
+struct c2_compound_args {
+	/**
+	 service to have addressed this request
+	*/
+	struct c2_service_id	ca_node;
+	/**
+	 session associated with that request (if exist)
+	*/
+	struct session_id	ca_session;
+	/**
+	 number operations inside compound
+	*/
+	uint32_t		ca_oparray_len;
+	/**
+	 array with operations
+	*/
+	struct c2_compound_op_arg *ca_oparray_val;
+};
+
+
+/**
+ one reply structure
+*/
+struct c2_session_resop {
+	/**
+	 operation to get a reply
+	 */
+	enum c2_session_compound_op c2op;
+	/**
+	 all reply's should be listed here and xdr function need
+	 to be updated
+	*/
+	union {
+		struct c2_sequence_reply c2seq_reply;
+	} c2_session_resop_u;
+};
+
+struct c2_compound_reply {
+	/**
+	 status of last operation
+	 */
+	uint32_t status;
+	/**
+	 number of reply's in answers
+	 */
+	uint32_t resarray_len;
+	/**
+	 array wiyh reply's
+	 */
+	struct c2_session_resop *resarray_val;
+};
+
+#endif
diff --git a/rpc/pcache.c b/rpc/pcache.c
new file mode 100644
index 0000000..e93f3fb
--- /dev/null
+++ b/rpc/pcache.c
@@ -0,0 +1,47 @@
+/*
+ * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: Alexey Lyashkov
+ * Original creation date: 05/12/2010
+ */
+
+#include <lib/cdefs.h>
+#include <lib/memory.h>
+
+#include <rpc/rpclib.h>
+#include <rpc/pcache.h>
+
+static const char pcache_db_name[] = "pcache";
+
+static int pcache_key_enc(void *buffer, void **rec, uint32_t *size)
+{
+	/** XXX */
+	*rec = buffer;
+	*size = sizeof(struct c2_rcid);
+
+	return 0;
+}
+
+int c2_pcache_init(struct c2_rpc_server *srv)
+{
+	srv->rs_cache.c_pkey_enc = pcache_key_enc;
+	return 	c2_cache_init(&srv->rs_cache, srv->rs_env, "test_db1", 0);
+}
+
+void c2_pcache_fini(struct c2_rpc_server *srv)
+{
+	c2_cache_fini(&srv->rs_cache);
+}
+
diff --git a/rpc/pcache.h b/rpc/pcache.h
new file mode 100644
index 0000000..ef93bcd
--- /dev/null
+++ b/rpc/pcache.h
@@ -0,0 +1,213 @@
+/*
+ * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: Alexey Lyashkov
+ * Original creation date: 05/12/2010
+ */
+
+#ifndef __COLIBRI_RPC_PCACHE_H__
+#define __COLIBRI_RPC_PCACHE_H__
+
+#include <lib/cdefs.h>
+
+#include <lib/cache.h>
+#include <net/net.h>
+
+/**
+ @page rpc-pcache persistent cache definitions
+*/
+
+/**
+ @section overview
+
+  Persistence cache is used to meet the EOS (Exactly Once Semantics) requirement
+in C2 service, this is because some update operations are non-idempotent, so
+that the server must run the RPC once and exactly once. This attribute can be
+always met in a normally running system, but problems arise if
+network(connection loss, route path changed, etc) or node fails.
+
+ The purpose of persistence cache is to store the replied requests into a
+database, which have a stable storage attached. By storing the request replies
+in the database, if the server fails and restarts, it can consult the
+persistence cache to know if the corresponding requests had been executed. In
+this case, server just replies the client with the reply contents in the
+persistence cache - we call this reply reconstruction. Otherwise, if the server
+knows that the replies has been received by clients, it will delete the
+corresponding entries from persistence cache.
+
+ @section definition
+
+ Persistence Table: Persistence Table is a table used to store the persistence
+cache in stable storage. Currently, we define a table in the DB4 database as
+persistence table. The key value of persistence table is slot id.
+
+ Reply reconstruction: To meet EOS, if a retrying request had already executed by
+server, the server will just compose a reply to send to the client, w/o actually
+executing the request once again. The process of reconstructing the reply RPC
+request is called `reply reconstruction'.
+
+ FOP: File Operation Packet. A FOP represents a single, atomic operation to
+access file. One important thing has to be stated: RPC is just a container, a
+unit of network transfer, to transfer FOPs over network. FOP is actually the
+representation of file access. By this means, recovery, transaction management,
+etc must be based on FOP; they have nothing to do with RPC.
+
+@section functional-specification Functional Specification
+
+In C2, the persistence cache only exists on the server side where stable storage
+equips. We don't implement it on the client side, so that client must not
+support any non-idempotent operations. For example, client must be able to
+handle multiple lock revocation callback against the same lock; and server must
+be able to handle the case that clients complain about non-existence of locks.
+
+First of all, to meet the EOS requirements, we need to label each FOP uniquely,
+this is done by tuple <clientID, FOPID>. Then after the request has been
+executed by the server, it must cache the result of execution, until it is known
+that the client has received the reply. We refer to this cache as `persistence
+reply cache' or `persistence cache', or `reply cache' - those three
+terminologies are exchangeable. Executing a FOP and inserting the FOP result
+into the persistence cache must be atomic.
+
+To make the retrying of requests to be sane, we may need the server to execute
+the requests in strictly order, so that if one requests tries failed (because
+replier didn't execute it yet), it implicitly indicates the following
+outstanding requests from the same client weren't executed as well. This is
+because a request B may be relying on the previous request A to be successful,
+for example, request A creates a directory, and request B creates a file under
+that directory, and if request A is not executed, retrying request B doesn't
+make any sense. But how this requirements can be met is out of the scope of this
+document. In fact, in C2, we're going to use version based recovery plus DTM
+undo-only and redo to recover the nodes from crash, so reply cache is just used
+to solve some special cases where version based recovery can't be used - for
+example, we may cache directory entries in client side with a stale inode
+version, and then operate the inode based on this stale version.
+
+
+@section logic-specification Logic Specification
+
+We use a database to implement persistence cache in C2. The key value of
+persistence cache is structure c2_crid, and the record is the contents of reply
+which is provide by server.
+
+In case the server failure or connection loss occurs, the server will enter into
+a so-called grace period, during this period, only retrying requests are
+accepted. We then need to consult persistence cache entries from the database
+and use them to reconstruct the reply. After all entries have been served, or
+grace period times out, it will purge the persistence cache, and then can serve
+new requests.
+
+@ref rpc-server
+*/
+
+
+/*
+* Used to describe an unique FOP for reply cache at server side.
+*/
+struct c2_rcid {
+	struct c2_service_id	cr_clid;  /* client ID of this request */
+	uint64_t		cr_xid;   /* FOP ID */
+};
+
+/**
+ Persistent cache object.
+ cache have created by calling c2_pcache_init from c2_rpc_server constructor.
+ cache a live all time until rpc service is live, and destroyed via call
+ c2_pcache_fini from a c2_rpc_server destructor.
+
+ all modifications in cache need to be synchronized with transaction which
+ used to execute folling FOP.
+*/
+
+struct c2_rpc_server;
+
+/**
+ persistent cache constructor
+
+ initialize a pcache database(s)
+ */
+int c2_pcache_init(struct c2_rpc_server *srv);
+
+/**
+ persistent cache destructor
+
+ close database(s) and release resources
+ */
+void c2_pcache_fini(struct c2_rpc_server *srv);
+
+
+/**
+ This function is used by server process to store the reply of FOP @reqid
+ into persistence cache table.
+ If reply with same key exist, it will overwrited.
+
+ @param cache is the cache to store reply contents
+ @param db_txn is the transaction which is used to execute the FOP
+ @param reqid is the unique ID of FOP
+ @param reply is the reply contents of FOP request @reqid, its contents
+              must have been converted host independent byte order
+
+ @retval 0           success
+ @retval -EEXIST     There've already been a reply in the database
+ @retval < 0         error occurs
+ */
+static inline
+int c2_pcache_insert(struct c2_cache *cache, DB_TXN *db_txn,
+		     struct c2_rcid *reqid, c2_cache_encode_t enc,
+		     void *reply, size_t size)
+{
+	return c2_cache_insert(cache, db_txn, reqid, enc, reply, size);
+}
+
+/**
+ This function is used to delete a record from the database.
+
+ @param cache is the cache to store reply contents
+ @param db_txn is the transaction which is used to execute the FOP
+ @param slotid the slotid
+
+ @retval 0          success
+ @retval -ENOENT    no such key exists in the database
+ @reval < 0 error   other error
+*/
+static inline
+int c2_pcache_delete(struct c2_cache *cache, DB_TXN *db_txn,
+		     struct c2_rcid *reqid)
+{
+	return c2_cache_delete(cache, db_txn, reqid);
+}
+
+
+/*
+ c2_pcache_search: check if there exists a persistent reply cache in the database.
+ If exists, return the record.
+
+ @param reqid, the fop ID the caller wants to get
+ @param db_txn is the transaction which is used to execute the FOP
+ @param reply, this is a return parameter, if the slotid exists, it will be filled
+               by reply pointer which is returned by @decode
+
+ @retval >0       the bytes of reply buffer filled
+ @retval -ENOSPC  the reply buffer is too short to store the record
+ @retval -ENOSRC  no such entry in database
+ @retval < 0      error occurs.
+ */
+static inline
+int c2_pcache_search(struct c2_cache *cache, struct c2_rcid *reqid,
+		     c2_cache_decode_t dec_fn, void **reply, uint32_t *size)
+{
+	return c2_cache_search(cache, reqid, dec_fn, reply, size);
+}
+#endif
+
diff --git a/rpc/rpc_ops.h b/rpc/rpc_ops.h
new file mode 100644
index 0000000..3353047
--- /dev/null
+++ b/rpc/rpc_ops.h
@@ -0,0 +1,41 @@
+/*
+ * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: Alexey Lyashkov
+ * Original creation date: 05/17/2010
+ */
+
+#ifndef __COLIBRI_RPC_RPC_OPS_H__
+#define __COLIBRI_RPC_RPC_OPS_H__
+
+/**
+ RPC commands supported by rpc library
+ */
+enum c2_rpc_ops {
+	/**
+	 Create new session on server
+	 */
+	C2_SESSION_CREATE = 1,
+	/**
+	 Destroy session on server
+	 */
+	C2_SESSION_DESTROY,
+	/**
+	 send compound request over session
+	 */
+	C2_SESSION_COMPOUND
+};
+
+#endif
diff --git a/rpc/rpc_types.h b/rpc/rpc_types.h
new file mode 100644
index 0000000..c0aae1d
--- /dev/null
+++ b/rpc/rpc_types.h
@@ -0,0 +1,64 @@
+/* -*- C -*- */
+/*
+ * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: Alexey Lyashkov
+ * Original creation date: 04/22/2010
+ */
+
+#ifndef __COLIBRI_RPC_TYPES_H__
+
+#define __COLIBRI_RPC_TYPES_H__
+
+#include <lib/cdefs.h>
+
+/**
+ @page rpc-types type definitions used in rpc library
+ */
+
+/**
+ unique session identifier
+ - generated by server and and should be don't used until we will be know that
+   client will newer connected.
+ */
+struct c2_session_id {
+	uint64_t id;
+};
+
+/**
+ compare sessions identifier
+
+ @param s1 first session identifier
+ @param s2 second session identifier
+
+ @retval true if session identifiers is same
+ @retval false if session identifiers is different
+*/
+bool c2_session_is_same(const struct c2_session_id *s1,
+			const struct c2_session_id *s2);
+
+
+/**
+ type to define slot id
+*/
+typedef uint32_t c2_slot_t;
+
+
+/**
+ type to define sequence in a slot
+ */
+typedef uint64_t c2_seq_t;
+
+#endif
diff --git a/rpc/session_cli.c b/rpc/session_cli.c
new file mode 100644
index 0000000..d70ec29
--- /dev/null
+++ b/rpc/session_cli.c
@@ -0,0 +1,135 @@
+/* -*- C -*- */
+/*
+ * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: Alexey Lyashkov
+ * Original creation date: 04/22/2010
+ */
+#include <lib/list.h>
+
+#include <rpc_common.h>
+#include <session.h>
+#include <session_proto.h>
+
+static void c2_session_free(struct c2_ref *ref)
+{
+	struct c2_cli_session *sess;
+
+	sess = container_of(ref, struct c2_cli_session, sess_ref);
+
+	C2_FREE_PTR(sess);
+}
+
+static void session_create_cb(struct session_create_arg const *arg,
+			      struct session_create_ret const *ret,
+			      struct c2_rpc_client const *cli)
+{
+	struct c2_cli_session *cli_s;
+
+	if (ret->errno)
+		return;
+
+	C2_ALLOC_PTR(cli_s);
+	if (!cli_s)
+		return;
+
+	c2_list_link_init(&cli_s->sess_link);
+	cli_s->sess_id = ret->session_create_ret_u.sco_session_id;
+
+	session_slot_table_adjust(&cli_s->sess_slots,
+				  ret->session_create_ret_u.sco_high_slot_id);
+	c2_ref_init(&cli_s->sess_ref, 1, session_dtor);
+
+	c2_rwlock_read_lock(&cli->rc_sessions_lock);
+	c2_list_add(&cli->rc_sessions, &cli_s->sess_link);
+	c2_rwlock_write_lock(&cli->rc_sessions_lock);
+}
+
+int c2_cli_session_create(struct rpc_client *cli)
+{
+	struct session_create_arg req;
+	struct session_create_ret ret;
+
+	req.sca_client = cli->cl_id;
+	req.sca_server = cli->srv_uuid;
+	req.sca_high_slot_id = C2_SLOTS_INIT;
+	/* XXX need change later */
+	req.cca_max_rpc_size = 0;
+
+	return c2_net_cli_call_async(cli->rc_net, cli->rc_ops,
+	/* call rpc */
+	session_create_cb(&arg, &ret, cli, net);
+}
+
+void session_destroy_cb(struct session_destroy_ret *ret,
+			const struct c2_cli_session *sess)
+{
+	bool need_put = false;
+	session_slot_table_adjust(&sess->sess_slots, 0);
+	/* XXX wait until all rpc's finished */
+
+	c2_rwlock_write_lock(&cli->rc_sessions_lock);
+	c2_list_del(&sess->sess_link);
+	c2_rwlock_write_unlock(&cli->rc_sessions_lock);
+
+	if (need_put)
+		c2_ref_put(&sess->sess_ref);
+}
+
+int c2_session_cli_destroy(const struct c2_cli_session *sess)
+{
+	struct session_destroy_arg arg;
+
+	arg.da_session_id = sess.sess_id;
+
+	/* call rpc */
+	session_destroy_cb(&ret, sess);
+}
+
+struct c2_cli_session *c2_session_cli_find(const struct rpc_client *cli,
+					   const struct client_id * srv_uuid)
+{
+	struct c2_list_link *pos;
+	struct c2_cli_session *sess = NULL;
+	bool found = FALSE;
+
+	c2_rwlock_read_lock(&cli->cli_sessions_lock);
+	c2_list_for_each(&cli->sessions, pos) {
+		sess = c2_list_entry(pos, struct c2_cli_session, sess_link);
+		if (client_are_same(&sess->sess_srv, srv_uuid)) {
+			c2_ref_get(&sess->sess_ref);
+			found = TRUE;
+			break;
+		}
+	}
+	c2_rwlock_read_unlock(&cli->cli_sessions_lock);
+	
+	return found ? sess : NULL;
+}
+
+int c2_session_check(struct rpc_client *cli, const struct c2_cli_session *sess)
+{
+	struct c2_cli_slot *slot;
+
+	slot = find_empty_slot(sess);
+	/* need handle delayed queue */
+	if (!slot)
+		return -ENOSPC;
+
+	rc = compound_send_seq(slot, 0, NULL);
+	c2_ref_put(&sess->sess_ref);
+
+	return rc;
+}
diff --git a/rpc/session_cli.h b/rpc/session_cli.h
new file mode 100644
index 0000000..d2af62a
--- /dev/null
+++ b/rpc/session_cli.h
@@ -0,0 +1,113 @@
+/* -*- C -*- */
+/*
+ * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: Alexey Lyashkov
+ * Original creation date: 04/22/2010
+ */
+
+#ifndef __COLIBRI_RPC_SESSION_CLI_H__
+
+#define __COLIBRI_RPC_SESSION_CLI_H__
+
+#include <lib/cdefs.h>
+#include <lib/refs.h>
+
+#include <rpc/rpc_types.h>
+
+/**
+ @page rpc-cli-session client side session part
+*/
+
+
+/**
+ client side part of session.
+ session isn't visible outside of rpc layer.
+
+ one session always created for each server connection, if client node need more
+ parallel RPC's additional sessions can be created.
+
+ session live until rpc code is ask to destroy session via calling function
+ c2_cli_session_destroy.
+
+ session have a reference counting protection.
+*/
+struct c2_cli_session {
+	/**
+	 linking into list of sessions assigned to rpc client
+	 */
+	struct c2_list_link	sess_link;
+	/**
+	 reference counter
+	 */
+	struct c2_refs		sess_ref;
+	/**
+	 server assigned session id
+	 */
+	struct c2_session_id	sess_id;
+	/**
+	 session slot table
+	 */
+	struct c2_cli_slot_table *sess_slots;
+};
+
+/**
+ session constructor.
+ allocate slot's memory and connect session to server.
+ if server is unreachable, function is return error without allocate new session.
+
+ @param cli - rpc client to create new session.
+ @param srv - server identifier
+
+ @retval 0   success
+ @retval -ve failure, e.g., server don't connected
+ */
+int c2_cli_session_create(const struct c2_rpc_client *cli);
+
+/**
+ * session destructor
+ * release resources and destroy connection to server.
+ *
+ * @param sess - session structure
+ *
+ * @retval 0   success
+ * @retval -ve failure, e.g., server don't connected, responded
+ */
+int c2_cli_session_destroy(struct c2_cli_session *sess);
+
+/**
+ * find session associated with server
+ *
+ * @param cli_uuid - client identifier
+ * @param srv_uuid - server identifier
+ *
+ * @retval NULL, session don't found or don't init correctly
+ * @retval !NULL, OK
+ */
+struct c2_cli_session *c2_cli_session_find(const struct c2_rpc_client *cli,
+					   const struct c2_service_id *srv_uuid);
+
+/**
+ verify session @a sess by sending single "sequence" op and check response.
+ RFC suggested method to check service livnes.
+
+ @param sess - pointer to fully inited session object
+
+ @retval 0   success
+ @retval -ve failure, e.g., server don't connected
+ */
+int c2_cli_session_check(const struct c2_cli_session *sess);
+
+#endif
diff --git a/rpc/session_srv.c b/rpc/session_srv.c
new file mode 100644
index 0000000..9a633d5
--- /dev/null
+++ b/rpc/session_srv.c
@@ -0,0 +1,62 @@
+/* -*- C -*- */
+/*
+ * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: Alexey Lyashkov
+ * Original creation date: 04/22/2010
+ */
+#include "rpc/rpclib.h"
+#if 0
+
+#include "lib/errno.h"
+#include "lib/atomic.h"
+#include "lib/memory.h"
+
+#include "net/net.h"
+
+#include "rpc/session_srv.h"
+
+int c2_server_session_init(struct c2_rpc_server *srv)
+{
+	int rc;
+
+	rc = c2_cache_init(&srv->rs_sessions);
+	if (rc < 0)
+		goto out;
+}
+
+void c2_server_session_fini(struct c2_rpc_server *srv)
+{
+	c2_cache_fini(&srv->rs_session);
+}
+
+
+/*** ***/
+int c2_srv_session_init(struct c2_rpc_server *srv, uint32_t highslot,
+			struct c2_service_id *cli_id;
+			struct c2_srv_session **sess)
+{
+}
+
+void c2_srv_session_unlink(struct c2_rpc_server *srv, struct c2_srv_session *sess)
+{
+}
+
+struct c2_srv_session *c2_srv_session_find_by_id(struct c2_rpc_server *srv,
+						 const c2_session_id *ss_id)
+{
+}
+
+#endif
diff --git a/rpc/session_srv.h b/rpc/session_srv.h
new file mode 100644
index 0000000..49f43dd
--- /dev/null
+++ b/rpc/session_srv.h
@@ -0,0 +1,150 @@
+/* -*- C -*- */
+/*
+ * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: Alexey Lyashkov
+ * Original creation date: 04/22/2010
+ */
+
+#ifndef __COLIBRI_RPC_SESSION_SRV_H__
+
+#define __COLIBRI_RPC_SESSION_SRV_H__
+
+#include <lib/cdefs.h>
+
+#include <net/net.h>
+#include <rpc/rpc_types.h>
+#include <rpc/rpclib.h>
+
+/**
+ @page rpc-srv-session  server side session handler.
+
+@section rpc-srv-s-f functional specification
+
+On server side, sessions is stored on database with BTREE structure and
+structure c2_srv_session_key is used as primary key in the database,
+
+@section rpc-srv-s-l Logical specification
+
+when rpc service started it need to call c2_server_session_init
+to intialize internal structures with correct data.
+
+
+*/
+
+/**
+ key to store in session db,
+ one record describe one slot in request handling.
+ */
+struct c2_server_session_key {
+	/**
+	 client which send a request
+	 */
+	struct c2_service_id	ssk_client;
+	/**
+	 session to handle that request
+	 */
+	struct c2_session_id	ssk_sess;
+	/**
+	 slot to handle that request
+	 */
+	c2_slot_t		skk_slotid;
+};
+
+
+/**
+ data to store in session db
+*/
+struct c2_server_session_data {
+	/**
+	 sequence in the slot
+	 */
+	c2_seq_t	ssd_sequence;
+};
+
+/**
+ request ordering enumeration
+ */
+enum c2_request_order {
+	/**
+	 request out of order
+	 */
+	REQ_ORD_BAD,
+	/**
+	 normal request in expected order,
+	 sequence id is greater last used by one.
+	 */
+	REQ_ORD_NORMAL,
+	/**
+	 resend of already handled request.
+	 request sequence is same prevoisly hanlded
+	 */
+	REQ_ORD_RESEND,
+};
+
+/**
+ check request order in given slot info.
+
+ @param sess - server side session info
+ @param cli_seq - client provided info in sequence operation.
+
+ @return enum request code to describe request status.
+ */
+enum c2_request_order c2_check_request(const struct c2_server_session_data *sess,
+					const struct c2_session_sequence_args *cli_seq);
+
+/**
+ open or create session for the server
+*/
+int c2_server_session_init(struct c2_rpc_server *srv);
+
+/**
+ close session db and free allocated resources
+*/
+void c2_server_session_fini(struct c2_rpc_server *srv);
+
+/**
+ create new session on a server.
+ 
+ @param srv - server to create new session
+ @param sess - ponter to new created session, with 2 references.
+               need a call c2_srv_session release after using.
+
+ @retval 0 - creation OK
+ @retval -ENOMEM not have enogth memory
+ */
+int c2_server_session_create(struct c2_rpc_server *srv,
+			     struct c2_session_id **sess);
+
+/**
+ unlink session from a list and release one reference
+ */
+void c2_server_session_delete(const struct c2_rpc_server *srv,
+			      const struct c2_session_id *sess);
+
+/**
+ find session by session id
+
+ @param srv - server to find session
+ @param ss_id - session identifier
+ 
+ @retval NULL - session not exist or unlinked
+ @retval !NULL - session with that identifier
+*/
+struct c2_server_session_data *
+c2_server_session_lookup(const struct c2_rpc_server *srv,
+			 const c2_session_id *ss_id);
+
+#endif
diff --git a/rpc/session_svc.c b/rpc/session_svc.c
new file mode 100644
index 0000000..69f2623
--- /dev/null
+++ b/rpc/session_svc.c
@@ -0,0 +1,61 @@
+/* -*- C -*- */
+/*
+ * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: Alexey Lyashkov
+ * Original creation date: 04/22/2010
+ */
+
+#include <errno.h>
+
+#include "lib/errno.h"
+#include "lib/memory.h"
+#include "net/net.h"
+
+#include "rpc/rpc_ops.h"
+
+#include "rpc/session_types.h"
+#include "rpc/session_svc.h"
+#include "rpc/xdr/session.h"
+
+static struct c2_rpc_op  create_session = {
+	.ro_op = C2_SESSION_CREATE,
+	.ro_arg_size = sizeof(struct c2_session_create_arg),
+	.ro_xdr_arg = (c2_xdrproc_t)c2_xdr_session_create_arg,
+	.ro_result_size = sizeof(struct c2_session_create_ret),
+	.ro_xdr_result = (c2_xdrproc_t)c2_xdr_session_create_ret,
+	.ro_handler = c2_session_create_svc
+};
+
+static struct c2_rpc_op  destroy_session = {
+	.ro_op = C2_SESSION_DESTROY,
+	.ro_arg_size = sizeof(struct c2_session_destroy_arg),
+	.ro_xdr_arg = (c2_xdrproc_t)c2_xdr_session_destroy_arg,
+	.ro_result_size = sizeof(struct c2_session_destroy_ret),
+	.ro_xdr_result = (c2_xdrproc_t)c2_xdr_session_destroy_ret,
+	.ro_handler = c2_session_destroy_svc
+};
+
+/** rpc handlers */
+bool c2_session_create_svc(const struct c2_rpc_op *op, void *in, void **out)
+{
+	return true;
+}
+
+bool c2_session_destroy_svc(const struct c2_rpc_op *op, void *in, void **out)
+{
+	return true;
+}
+
diff --git a/rpc/session_svc.h b/rpc/session_svc.h
new file mode 100644
index 0000000..a32e7bc
--- /dev/null
+++ b/rpc/session_svc.h
@@ -0,0 +1,60 @@
+/* -*- C -*- */
+/*
+ * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: Alexey Lyashkov
+ * Original creation date: 04/22/2010
+ */
+#ifndef __COLIBRI_RPC_SVC_H__
+
+#define __COLIBRI_RPC_SVC_H__
+
+#include <lib/cdefs.h>
+
+/**
+ @page rpc-svc server side handlers.
+ 
+ server side is reponsible to handle commands:
+ SESSION_CREATE,
+ SESSION_DESTROY,
+
+ All these commands need to be listed in enum c2_session_cmd
+*/
+
+/**
+ server handler for the SESSION_CREATE command.
+ create new session on server and connect session into session list.
+
+ @param in  - structure with arguments from client to creation session.
+ @param out - structure returned to client
+
+ @retval true  - need send a reply
+ @retval false - not need send a reply - some generic error is hit.
+ */
+bool c2_session_create_svc(const struct c2_rpc_op *op, void *in, void **out);
+
+/**
+ server handler for the SESSION_DESTROY cmd.
+ destroy session on server side.
+ 
+ @param in  - session id + parameters to destroy session from client
+ @param out - resulting info to send to client
+ 
+ @retval true  - need send a reply
+ @retval false - not need send a reply - some generic error is hit.
+ */
+bool c2_session_destroy_svc(const struct c2_rpc_op *op, void *in, void **out);
+
+#endif
diff --git a/rpc/session_types.h b/rpc/session_types.h
new file mode 100644
index 0000000..fbf1e97
--- /dev/null
+++ b/rpc/session_types.h
@@ -0,0 +1,111 @@
+/* -*- C -*- */
+/*
+ * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: Alexey Lyashkov
+ * Original creation date: 04/22/2010
+ */
+
+#ifndef __COLIBRI_RPC_SESSION_TYPES_H__
+
+#define __COLIBRI_RPC_SESSION_TYPES_H__
+
+#include <lib/cdefs.h>
+#include <rpc/rpc_types.h>
+
+/**
+ @page rpc-session-types
+*/
+
+/**
+ C2_SESSION_CREATE command
+ */
+
+/**
+ parameters to the C2_SESSION_CREATE command
+ */
+struct c2_session_create_arg {
+	/**
+	client requested a new session
+	*/
+	struct c2_service_id	sca_client;
+	/**
+	server to accept connection
+	*/
+	struct c2_service_id	sca_server;
+	/**
+	maximal slot count handled by client
+	*/
+	uint32_t		sca_high_slot_id;
+	/**
+	maximal rpc size can be handled by client
+	*/
+	uint32_t		sca_max_rpc_size;
+};
+
+/**
+ * server reply to SESSION_CREATE command.
+ */
+struct c2_session_create_ret {
+	/**
+	 status of operation.
+	 if operation failed - not need a decoding reply
+	*/
+	int32_t error;
+	/**
+	server assigned session identifier
+	*/
+	struct c2_session_id sco_session_id;
+	/**
+	 maximal slot id (slot's count) assigned to the client
+	*/
+	uint32_t sco_high_slot_id;
+	/**
+	 maximal rpc size can be handle by client
+	*/
+	uint32_t sco_max_rpc_size;
+};
+
+
+/**
+  C2_SESSION_DESTROY command
+ */
+
+/**
+ argument to server side procedure
+ */
+struct c2_session_destroy_arg {
+	/**
+	 node to have addressed this request
+	 */
+	struct c2_service_id	da_service;
+	/**
+	session identifier to destroy
+	*/
+	struct c2_session_id	da_session;
+};
+
+/**
+ reply to C2_SESSION_DESTOY command
+ */
+struct c2_session_destroy_ret {
+	/**
+	status of operation
+	*/
+	int32_t sda_errno;
+};
+
+#endif
+
diff --git a/rpc/ut/rpc-client.c b/rpc/ut/rpc-client.c
new file mode 100644
index 0000000..4be4621
--- /dev/null
+++ b/rpc/ut/rpc-client.c
@@ -0,0 +1,40 @@
+/*
+ * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: Alexey Lyashkov
+ * Original creation date: 05/18/2010
+ */
+
+#include <net/net.h>
+#include <rpc/rpclib.h>
+
+int main(int argc, char *argv[])
+{
+	struct c2_service_id srv_id = { .si_uuid = "srv-1" };
+	struct c2_rpc_client *cli;
+	int rc;
+
+	c2_rpclib_init();
+
+	/* in config*/
+	rc = c2_net_conn_create(&srv_id);
+
+	cli = c2_rpc_client_create(&srv_id);
+
+
+	c2_rpc_client_unlink(cli);
+
+	return 0;
+}
diff --git a/rpc/ut/rpc-server.c b/rpc/ut/rpc-server.c
new file mode 100644
index 0000000..40576ba
--- /dev/null
+++ b/rpc/ut/rpc-server.c
@@ -0,0 +1,53 @@
+/*
+ * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: Alexey Lyashkov
+ * Original creation date: 05/18/2010
+ */
+
+#include <net/net.h>
+#include <rpc/rpclib.h>
+#include <rpc/rpc_ops.h>
+#include <rpc/pcache.h>
+
+
+int main(void)
+{
+	struct c2_service_id srv_id = { .si_uuid = "srv-1" };
+	struct c2_rpc_server *srv;
+	struct c2_service	s;
+	int rc;
+
+	c2_rpclib_init();
+
+	rc = c2_service_start(&s, &srv_id);
+
+	srv = c2_rpc_server_create(&srv_id);
+
+	/* init storage if need */
+
+	/* service want pcache support */
+	c2_pcache_init(srv);
+
+	/* service want session support */
+	/* need add commands to service */
+	// c2_server_session_init(srv);
+
+	/* add compound rpc in list*/
+	// c2_server_compond_init(srv);
+
+	//c2_server_register(srv);
+	return 0;
+}
diff --git a/sns/linux_kernel/.gitignore b/sns/linux_kernel/.gitignore
new file mode 100644
index 0000000..b0ee301
--- /dev/null
+++ b/sns/linux_kernel/.gitignore
@@ -0,0 +1,4 @@
+ls_solve.c
+matvec.c
+parity_math.c
+parity_ops.c
diff --git a/sns/linux_kernel/Makefile.in b/sns/linux_kernel/Makefile.in
new file mode 100644
index 0000000..b1b7ad9
--- /dev/null
+++ b/sns/linux_kernel/Makefile.in
@@ -0,0 +1,22 @@
+SNS_SRCDIR = @SRCDIR@/sns/linux_kernel
+GALOIS_SRCDIR = @SRCDIR@/../galois
+
+obj-m       := ksns.o
+shared_src  := ls_solve.c matvec.c parity_math.c parity_ops.c
+kernel_src  := ksns.c
+ksns-y      := $(shared_src:.c=.o) $(kernel_src:.c=.o)
+orig        := $(shared_src:%=../%)
+
+
+EXTRA_CFLAGS = -DHAVE_CONFIG_H -I@SRCDIR@ @KCFLAGS@
+
+prepare:
+	ln -fs $(orig) .
+
+clean distclean:
+	$(RM) $(shared_src) Module.markers Module.symvers modules.order
+	$(MAKE) -C @LINUX_OBJ@ M=`pwd` clean
+
+distdir:
+	cp $(SNS_SRCDIR)/Makefile.in \
+           @top_builddir@/@PACKAGE@-@VERSION@/sns/linux_kernel
diff --git a/sns/linux_kernel/ksns.c b/sns/linux_kernel/ksns.c
new file mode 100644
index 0000000..061da86
--- /dev/null
+++ b/sns/linux_kernel/ksns.c
@@ -0,0 +1,23 @@
+/*
+ * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: $NAME
+ * Original creation date: MM/DD/YYYY
+ */
+
+void __sns_dummy_foo(void)
+{
+
+}
diff --git a/stob/linux_kernel/.gitignore b/stob/linux_kernel/.gitignore
new file mode 100644
index 0000000..6261bac
--- /dev/null
+++ b/stob/linux_kernel/.gitignore
@@ -0,0 +1 @@
+stob_id.c
diff --git a/stob/linux_kernel/Makefile.in b/stob/linux_kernel/Makefile.in
new file mode 100644
index 0000000..a986d32
--- /dev/null
+++ b/stob/linux_kernel/Makefile.in
@@ -0,0 +1,20 @@
+STOB_SRCDIR = @SRCDIR@/stob/linux_kernel
+
+obj-m       := kstob.o
+shared_src  := stob_id.c
+kernel_src  := kstob.c
+kstob-y     := $(shared_src:.c=.o) $(kernel_src:.c=.o)
+orig        := $(shared_src:%=../%)
+
+EXTRA_CFLAGS = -DHAVE_CONFIG_H -I@SRCDIR@ @KCFLAGS@
+
+prepare:
+	ln -fs $(orig) .
+
+clean distclean:
+	$(RM) $(shared_src) Module.markers Module.symvers modules.order
+	$(MAKE) -C @LINUX_OBJ@ M=`pwd` clean
+
+distdir:
+	cp $(STOB_SRCDIR)/Makefile.in \
+           @top_builddir@/@PACKAGE@-@VERSION@/stob/linux_kernel
diff --git a/utils/linux_kernel/.gitignore b/utils/linux_kernel/.gitignore
new file mode 100644
index 0000000..c14dcb8
--- /dev/null
+++ b/utils/linux_kernel/.gitignore
@@ -0,0 +1,4 @@
+bitmap.c
+chan.c
+rwlock.c
+thread.c
diff --git a/xdr/Makefile.am b/xdr/Makefile.am
new file mode 100644
index 0000000..86dbcad
--- /dev/null
+++ b/xdr/Makefile.am
@@ -0,0 +1,5 @@
+noinst_LTLIBRARIES         = libcolibri-xdr.la
+libcolibri_xdr_la_SOURCES  = xdr_rec.c
+
+INCLUDES                      = -I. -I$(top_srcdir) -I$(top_srcdir)/include
+
diff --git a/xdr/ut/Makefile.am b/xdr/ut/Makefile.am
new file mode 100644
index 0000000..be0f8db
--- /dev/null
+++ b/xdr/ut/Makefile.am
@@ -0,0 +1,6 @@
+noinst_LTLIBRARIES   = libxdr-ut.la
+libxdr_ut_la_SOURCES  = xdr_test.c
+
+INCLUDES           = -I. -I$(top_srcdir)/include -I$(top_srcdir)
+
+
diff --git a/xdr/ut/xdr_test.c b/xdr/ut/xdr_test.c
new file mode 100644
index 0000000..a877f8b
--- /dev/null
+++ b/xdr/ut/xdr_test.c
@@ -0,0 +1,484 @@
+/* -*- C -*- */
+/*
+ * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: Subhash Arya
+ * Original creation date: 06/02/2011
+ */
+
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <sys/types.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include "xdr/xdr_rec.h"
+#include "lib/errno.h"
+#include "lib/ut.h"
+#include "lib/ub.h"
+#include "lib/memory.h"
+#include "lib/assert.h"
+
+enum {
+	MAX_BUF_SIZE = 140,
+	SEND_SIZE    = 120,
+	RECV_SIZE    = 120,
+	UB_ITER      = 5000000
+};
+
+/* Use C2_ASSERT for UB since C2_UT_ASSERT doesn't work for UB */
+#define XDR_TEST_ASSERT(cond)				\
+	if(ub_flag)					\
+		C2_ASSERT(cond);			\
+	else						\
+		C2_UT_ASSERT(cond);
+
+/* The various tests */
+#define XDR_ENCODE_TESTS                                \
+        TEST_XDR_ENCODE(int, 0)                         \
+        TEST_XDR_ENCODE(int, INT_MAX)                   \
+        TEST_XDR_ENCODE(int, INT_MIN)                   \
+        TEST_XDR_ENCODE(u_int, 0)                       \
+        TEST_XDR_ENCODE(u_int, UINT_MAX)                \
+        TEST_XDR_ENCODE(long, 0)                        \
+        TEST_XDR_ENCODE(long, 2147483647L)              \
+        TEST_XDR_ENCODE(long, -2147483648L)             \
+        TEST_XDR_ENCODE(u_long, 0)                      \
+        TEST_XDR_ENCODE(u_long, 0xffffffffUL)           \
+        TEST_XDR_ENCODE(short, SHRT_MAX)                \
+        TEST_XDR_ENCODE(short, SHRT_MIN)                \
+        TEST_XDR_ENCODE(u_short, 0)                     \
+        TEST_XDR_ENCODE(u_short, USHRT_MAX)             \
+        TEST_XDR_ENCODE(char, CHAR_MAX)                 \
+        TEST_XDR_ENCODE(char, CHAR_MIN)                 \
+        TEST_XDR_ENCODE(u_char, 0)                      \
+        TEST_XDR_ENCODE(u_char, UCHAR_MAX)              \
+        TEST_XDR_ENCODE(bool, 0)                        \
+        TEST_XDR_ENCODE(bool, 1)                        \
+        TEST_XDR_ENCODE(enum, 0)                        \
+        TEST_XDR_ENCODE(enum, INT_MAX)                  \
+        TEST_XDR_ENCODE(enum, INT_MIN)                  \
+
+/* The xdr encode  test macro */
+#define TEST_XDR_ENCODE( type, value )                  \
+        test_##type = value;                            \
+        result = xdr_##type(xdrs, &test_##type);        \
+	XDR_TEST_ASSERT(result == 1);
+
+#define XDR_DECODE_TESTS                                \
+        TEST_XDR_DECODE(int, 0)                         \
+        TEST_XDR_DECODE(int, INT_MAX)                   \
+        TEST_XDR_DECODE(int, INT_MIN)                   \
+        TEST_XDR_DECODE(u_int, 0)                       \
+        TEST_XDR_DECODE(u_int, UINT_MAX)                \
+        TEST_XDR_DECODE(long, 0)                        \
+        TEST_XDR_DECODE(long, 2147483647L)              \
+        TEST_XDR_DECODE(long, -2147483648L)             \
+        TEST_XDR_DECODE(u_long, 0)                      \
+        TEST_XDR_DECODE(u_long, 0xffffffffUL)           \
+        TEST_XDR_DECODE(short, SHRT_MAX)                \
+        TEST_XDR_DECODE(short, SHRT_MIN)                \
+        TEST_XDR_DECODE(u_short, 0)                     \
+        TEST_XDR_DECODE(u_short, USHRT_MAX)             \
+        TEST_XDR_DECODE(char, CHAR_MAX)                 \
+        TEST_XDR_DECODE(char, CHAR_MIN)                 \
+        TEST_XDR_DECODE(u_char, 0)                      \
+        TEST_XDR_DECODE(u_char, UCHAR_MAX)              \
+        TEST_XDR_DECODE(bool, 0)                        \
+        TEST_XDR_DECODE(bool, 1)                        \
+        TEST_XDR_DECODE(enum, 0)                        \
+        TEST_XDR_DECODE(enum, INT_MAX)                  \
+        TEST_XDR_DECODE(enum, INT_MIN)
+
+#define TEST_XDR_DECODE( type, value )                  \
+        test_##type = 0x15;                             \
+        result = xdr_##type ( xdrs, &test_##type );     \
+	XDR_TEST_ASSERT(result == 1);			\
+	XDR_TEST_ASSERT(test_##type == value);
+
+struct xdr_test_handle {
+        int                     xt_sock;
+        /* The XDR stream handle for this connection to be used for
+	   marshalling/unmarshalling */
+        XDR                     xt_xdrs;
+};
+
+
+static XDR *xdrs;
+static int fd;
+static bool ub_flag;
+static struct xdr_test_handle *xt;
+
+/**
+  Read and Write functions for the XDR stream. Instead of writing the data to
+  a TCP stream, we are writing it to a file.
+*/
+
+static int write_file(char *cptr, char *buf, int len)
+{
+        int count, fd;
+        struct xdr_test_handle *xt_ptr;
+
+        xt_ptr = (struct xdr_test_handle *)cptr;
+        fd = xt_ptr->xt_sock;
+
+        if (len == 0)
+                return 0;
+        count = write(fd, buf, len);
+        return count;
+}
+
+static int read_file(char *cptr, char *buf, int len)
+{
+        int count, fd;
+        struct xdr_test_handle *xt_ptr;
+
+        xt_ptr = (struct xdr_test_handle *)cptr;
+        fd = xt_ptr->xt_sock;
+
+        if (len == 0)
+                return 0;
+        count = read(fd, buf, len);
+        return count;
+}
+
+static void ub_xdr_init()
+{
+	ub_flag = true;
+	C2_ALLOC_PTR(xt);
+	fd = open("xdr_stream.txt", O_CREAT|O_RDWR, S_IRUSR | S_IWUSR);
+	XDR_TEST_ASSERT(fd >= 0);
+	xt->xt_sock = fd;
+	xdrs = &(xt->xt_xdrs);
+	xdrrec_create(xdrs, SEND_SIZE, RECV_SIZE,
+	(caddr_t)xt, read_file, write_file);
+	xdrs->x_ops = (struct xdr_ops *)&c2_xdrrec_ops;
+}
+
+static void ub_xdr_fin()
+{
+	ub_flag = false;
+	close(fd);
+	c2_free(xt);
+	xdr_destroy(xdrs);
+}
+
+/* Unit benchmark tests for each data type */
+
+static void ub_encode_init()
+{
+	ub_xdr_init();
+	xdrs->x_op = XDR_ENCODE;
+}
+
+static void ub_encode_fin()
+{
+	xdrrec_endofrecord(xdrs, TRUE);
+	ub_xdr_fin();
+}
+
+static void ub_decode_init()
+{
+	ub_xdr_init();
+	xdrs->x_op = XDR_DECODE;
+	xdrrec_skiprecord(xdrs);
+}
+
+static void ub_decode_fin()
+{
+	ub_xdr_fin();
+}
+
+static void ub_encode_uint32(int i)
+{
+	uint32_t test_uint32_t;
+	int	 result;
+	TEST_XDR_ENCODE( uint32_t, UINT_MAX );
+}
+
+static void ub_encode_uint64(int i)
+{
+	uint64_t test_uint64_t;
+	int	 result;
+	TEST_XDR_ENCODE(uint64_t, ULLONG_MAX);
+}
+
+static void ub_encode_uint16(int i)
+{
+	uint16_t test_uint16_t;
+	int 	 result;
+	TEST_XDR_ENCODE(uint16_t, USHRT_MAX);
+}
+
+static void ub_encode_uchar(int i)
+{
+	u_char test_u_char;
+	int    result;
+	TEST_XDR_ENCODE(u_char, UCHAR_MAX);
+}
+
+static void ub_encode_bool(int i)
+{
+	bool_t test_bool;
+	int    result;
+	TEST_XDR_ENCODE(bool, true);
+}
+
+static void ub_encode_enum(int i)
+{
+	enum_t test_enum;
+	int    result;
+	TEST_XDR_ENCODE(enum, INT_MAX);
+}
+
+static void ub_decode_uint32(int i)
+{
+	uint32_t test_uint32_t;
+	int      result;
+	TEST_XDR_DECODE(uint32_t, UINT_MAX);
+}
+
+static void ub_decode_uint64(int i)
+{
+	uint64_t test_uint64_t;
+	int      result;
+	TEST_XDR_DECODE(uint64_t, ULLONG_MAX);
+}
+
+static void ub_decode_uint16(int i)
+{
+	uint16_t test_uint16_t;
+	int      result;
+	TEST_XDR_DECODE(uint16_t, USHRT_MAX);
+}
+
+static void ub_decode_uchar(int i)
+{
+	u_char test_u_char;
+	int    result;
+	TEST_XDR_DECODE(u_char, UCHAR_MAX);
+}
+
+static void ub_decode_bool(int i)
+{
+	bool_t test_bool;
+	int    result;
+	TEST_XDR_DECODE(bool, true);
+}
+
+static void ub_decode_enum(int i)
+{
+	enum_t test_enum;
+	int    result;
+	TEST_XDR_DECODE(enum, INT_MAX);
+}
+
+static void fill_buf(char *buf)
+{
+        int i;
+        char c = 'a'; /* fill the buf with  random charachters */
+        for(  i = 0; i < MAX_BUF_SIZE; i++) {
+                *buf = c++;
+                buf++;
+        }
+}
+
+static void xdr_client( void )
+{
+        int                     fd, result;
+        u_int                   len;
+        char                    *buf;
+        XDR                     *xdrs;
+        struct xdr_test_handle  *xt;
+
+        /* XDR test data */
+        int                     test_int;
+        u_int                   test_u_int;
+        long                    test_long;
+        u_long                  test_u_long;
+        short                   test_short;
+        u_short                 test_u_short;
+        char                    test_char;
+        u_char                  test_u_char;
+        bool_t                  test_bool;
+        enum_t                  test_enum;
+
+        C2_ALLOC_PTR(xt);
+        C2_ALLOC_ARR( buf, MAX_BUF_SIZE );
+
+        fd = open("xdr_stream.txt", O_CREAT | O_RDWR, S_IRUSR | S_IWUSR);
+        C2_UT_ASSERT(fd >= 0 );
+        xt->xt_sock = fd;
+        xdrs = &(xt->xt_xdrs);
+        xdrrec_create(xdrs, SEND_SIZE, RECV_SIZE,
+                     (caddr_t)xt, read_file, write_file);
+        xdrs->x_ops = (struct xdr_ops *)&c2_xdrrec_ops;
+        xdrs->x_op = XDR_ENCODE;
+
+        /* Everything is ready,  run our tests, start XDR encoding */
+        XDR_ENCODE_TESTS;
+
+        /* Test XDR record marking */
+        fill_buf(buf);
+        len = MAX_BUF_SIZE;
+        xdr_bytes(xdrs, &buf, &len, MAX_BUF_SIZE);
+        C2_UT_ASSERT(result == 1);
+        xdrrec_endofrecord(xdrs, TRUE);
+
+        /*  Cleanup */
+        close( fd );
+        c2_free(xt);
+        c2_free(buf);
+        xdr_destroy(xdrs);
+}
+
+static void xdr_server( void )
+{
+        int                     fd, result;
+        u_int                   len;
+        char                    *in_buf, *buf;
+        XDR                     *xdrs;
+        struct xdr_test_handle  *xt;
+
+        /* XDR Test data */
+        int                     test_int;
+        u_int                   test_u_int;
+        long                    test_long;
+        u_long                  test_u_long;
+        short                   test_short;
+        u_short                 test_u_short;
+        char                    test_char;
+        u_char                  test_u_char;
+        bool_t                  test_bool;
+        enum_t                  test_enum;
+
+        C2_ALLOC_PTR(xt);
+        C2_ALLOC_ARR(buf, MAX_BUF_SIZE );
+        C2_ALLOC_ARR(in_buf, MAX_BUF_SIZE );
+
+        fd = open("xdr_stream.txt", O_RDWR);
+        C2_UT_ASSERT(fd >= 0);
+        xt->xt_sock = fd;
+        xdrs = &(xt->xt_xdrs);
+        xdrrec_create(xdrs, SEND_SIZE, RECV_SIZE,(caddr_t) xt,
+                     read_file, write_file);
+        xdrs->x_op = XDR_DECODE;
+        xdrs->x_ops = (struct xdr_ops *)&c2_xdrrec_ops;
+        xdrrec_skiprecord(xdrs);
+
+        /* Start unmarshalling the XDR test data */
+        XDR_DECODE_TESTS;
+
+        /* Unmarshal XDR record marking test data */
+        fill_buf(buf);
+        len = MAX_BUF_SIZE;
+        result = xdr_bytes(xdrs, &in_buf, &len, MAX_BUF_SIZE);
+        C2_UT_ASSERT(result == 1);
+        result = memcmp(buf, in_buf, MAX_BUF_SIZE);
+        C2_UT_ASSERT(result == 0);
+
+        /* Cleanup */
+        close(fd);
+        c2_free(buf);
+        c2_free(in_buf);
+        c2_free(xt);
+        xdr_destroy(xdrs);
+}
+
+const struct c2_test_suite xdr_ut = {
+        .ts_name = "xdr-ut",
+        .ts_init = NULL,
+        .ts_fini = NULL,
+        .ts_tests = {
+                { "xdr-client", xdr_client },
+                { "xdr-server", xdr_server },
+                { NULL, NULL }
+        }
+};
+
+const struct c2_ub_set c2_xdr_ub = {
+	.us_name = "xdr-ub",
+	.us_init = NULL,
+	.us_fini = NULL,
+	.us_run  = {
+		{ .ut_name  = "encode int16",
+		  .ut_iter  = UB_ITER,
+		  .ut_round = ub_encode_uint16,
+		  .ut_init  = ub_encode_init },
+
+		{ .ut_name  = "encode int32",
+		  .ut_iter  = UB_ITER,
+		  .ut_round = ub_encode_uint32 },
+
+		{ .ut_name  = "encode int64",
+		  .ut_iter  = UB_ITER,
+		  .ut_round = ub_encode_uint64 },
+
+		{ .ut_name  = "encode char",
+		  .ut_iter  = UB_ITER,
+		  .ut_round = ub_encode_uchar },
+
+		{ .ut_name  = "encode bool",
+		  .ut_iter  = UB_ITER,
+		  .ut_round = ub_encode_bool },
+
+		{ .ut_name  = "encode enum",
+		  .ut_iter  = UB_ITER,
+		  .ut_fini  = ub_encode_fin,
+		  .ut_round = ub_encode_enum },
+
+		{ .ut_name  = "decode int16",
+		  .ut_iter  = UB_ITER,
+		  .ut_init  = ub_decode_init,
+		  .ut_round = ub_decode_uint16 },
+
+		{ .ut_name  = "decode int32",
+		  .ut_iter  = UB_ITER,
+		  .ut_round = ub_decode_uint32 },
+
+		{ .ut_name  = "decode int64",
+		  .ut_iter  = UB_ITER,
+		  .ut_round = ub_decode_uint64 },
+
+		{ .ut_name  = "decode char",
+		  .ut_iter  = UB_ITER,
+		  .ut_round = ub_decode_uchar },
+
+		{ .ut_name  = "decode bool",
+		  .ut_iter  = UB_ITER,
+		  .ut_round = ub_decode_bool },
+
+		{ .ut_name  = "decode enum",
+		  .ut_iter  = UB_ITER,
+		  .ut_round = ub_decode_enum,
+		  .ut_fini  = ub_decode_fin },
+
+		{ .ut_name = NULL }
+	}
+};
+
+/*
+ *  Local variables:
+ *  c-indentation-style: "K&R"
+ *  c-basic-offset: 8
+ *  tab-width: 8
+ *  fill-column: 80
+ *  scroll-step: 1
+ *  End:
+ */
+
diff --git a/xdr/xdr_rec.h b/xdr/xdr_rec.h
new file mode 100644
index 0000000..615d8b6
--- /dev/null
+++ b/xdr/xdr_rec.h
@@ -0,0 +1,232 @@
+/*
+ * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: Subhash Arya
+ * Original creation date: 06/02/2011
+ */
+#ifndef C2_XDR_REC_H_
+#define C2_XDR_REC_H_
+/**
+   @page le XDR Little Endian library.
+
+   @section Overview
+
+   XDR is inherently big endian. A majority of processors now are little
+   endian, and we would save processor and bus cycles by not converting the XDR
+   data from LE to BE and then back to LE.
+
+   @section req Requirements.
+
+   For colibri, we need to implement little-endianness in XDR for both kernel
+   and user layer code.
+
+   @section defn Definitions.
+
+   - XDR Stream : An instance of struct XDR ( see usr/include/rpc/xdr.h ) which
+   contains operation to be applied to that stream ( ENCODE, DECODE, FREE), an
+   operations vector for the particular implementation of xdr.
+
+   - XDR operation vectors: These operation vectors are part of XDR stream
+   and these are initialized to the various XDR operations based on the XDR
+   implementations. It is in these ops where the actual conversions of
+   little endian to big endian and vice versa occur. Refer xdr_mem.c, xdr_rec.c
+   and xdr_stdio.c of glibc sunrpc source code for more details.
+
+    @section background Background
+
+   - A fop format describes fop instance. Each fop instance data
+   structure is described as a tree of fields. Leaves of this tree are fields
+   of "atomic" types (void, byte, u32 and u64) and non-leaf nodes are
+   "aggregation" types ( record, union, sequence or typedef).
+
+   - Currently the fields of atomic types use the following standard
+   XDR filters ( generic XDR routines ) for conversion :
+
+	void  - xdr_void (....)
+	byte -  xdr_char (....)
+	uint32 - xdr_uint32_t (.....)
+	uint64 - xdr_uint64_t (.....)
+
+	- Each of the aggregation fields is composed of childs and the
+	corresponding XDR filters are used for conversion for each child based
+	on their types.
+
+	- li In addition to the above, xdr_bytes( ... ), xdr_array ( ... ) and
+	xdr_u_int ( ... ) filters have been used in 'union' and 'sequence'
+	aggregation fields.
+
+
+   @section spec Functional and Logical Specifications
+
+   @subsection Kernel-layer-XDR
+   For the kernel layer little endianness, we replace htonl() and ntohl() with
+   inbuilt linux kernel macros cpu_to_le32() and le32_to_cpu()
+
+   @subsection User-Layer-XDR
+
+   - An XDR stream is obtained by calling the appropriate creation routine which
+     creates an instance of an XDR object/handle that is tailored to the
+     specific properties of the stream.
+
+   - Streams currently exist for  deserialization of data to or from standard
+     I/O FILE streams ( xdr_stdio.c ), record streams ( xdr_rec.c ) and memory
+     ( xdr_mem.c ).
+
+   - For colibri, currently, we use sunrpc over TCP ( though this might change
+     soon ).The XDR stream is created by the sunrpc by internally calling
+     xdrrec_create() function defined in xdr_rec.c. On the client side the call
+     sequence is : clnttcp_create () --> xdrrec_create().
+
+   - In future, once the use of sunrpc is deprecated in colibri,
+     we can use xdrrec_create to register our own functions tailored to the
+     specific transport used ( eg: RDMA ).
+
+   - The various  xdr operation vectors would be initialized
+     to the functions defined in c2_xdr_rec.c. The actual conversion
+     of little endian to big endian and vice versa takes place in
+     these functions. The operation vectors defined in c2_xdr_rec.c are :-
+
+	xdrrec_getlong,
+	xdrrec_putlong,
+	xdrrec_getbytes,
+	xdrrec_putbytes,
+	xdrrec_getpos,
+	xdrrec_setpos,
+	xdrrec_inline,
+	xdrrec_destroy,
+	xdrrec_getint32,
+	xdrrec_putint32
+
+    - For making the XDR library as little endian, we need to replace the
+      htonl and ntohl macros in the various xdr_ops defined in xdr_rec.c
+      ( from the glibc rpc source ) with the c2_le().The rewritten xdr_rec.c
+      with our little endian macros would be compiled to build a
+      "xdr-little-endian"library. The various operation vectors shown above
+      would be exported by our library.
+
+    - The symbols that would be exported by this library would be
+      internally invoked by the various xdr filters used in colibri fops.
+      For eg: xdr_uint32_t ( ... ) will invoke the xdrrec_getlong ( ... )
+      and xdrrec_putlong ( ... ) for decoding and encoding from and to an
+      XDR stream. Similarly xdr_bytes ( ... ) internally will invoke
+      xdrrec_getbytes( ... ) and xdr_putbytes(...) exported from our library.
+
+    - In future, once the use of sunrpc is deprecated in colibri, we can use
+      xdrrec_create to register our own functions tailored to the specific
+      transport used ( eg: RDMA ).
+*/
+#include <rpc/xdr.h>
+#include <rpc/rpc.h>
+
+#define LAST_FRAG (1UL << 31)
+#define MCALL_MSG_SIZE 24
+
+/**
+   A record is composed of one or more record fragments.A record fragment is a
+   two-byte header followed by zero to 2**32-1 bytes.  The header is treated as
+   a long unsigned The low order 31 bits are a byte count of the fragment.
+   The highest order bit is a boolean:1 => this fragment is the last
+   fragment of the record, 0 => this fragment is followed by more fragment(s).
+   The fragment/record machinery is not general;  it is constructed to meet the
+   needs of xdr and rpc based on tcp
+*/
+struct c2_xdr_rec_strm {
+        /** The opaque tcp connection handle which is passed as a parameter
+        to readit and writeit functions */
+        caddr_t         tcp_handle;
+        /** Data to be serialized/deserialized goes here */
+        caddr_t         the_buffer;
+        /*
+        * out-going bits
+        */
+        /** Procedure to write the serialized data onto the tcp stream */
+        int             (*writeit)(char *, char *, int);
+        /** output buffer (points to frag header) */
+        caddr_t         out_base;
+        /** next output position */
+        caddr_t         out_finger;
+        /** can write data up to this address */
+        caddr_t         out_boundry;
+        /** beginning of curren fragment */
+        u_int32_t       *frag_header;
+        /** true if buffer sent in middle of record */
+        bool_t          frag_sent;
+        /*
+         * in-coming bits
+         */
+        /** Procedure to read incoming data from the tcp stream */
+        int             (*readit) (char *, char *, int);
+        /** fixed size of the input buffer */
+        u_long          in_size;
+        /** reading will start from this address */
+        caddr_t         in_base;
+        /** location of next byte to be had */
+        caddr_t         in_finger;
+        /** can read up to this location */
+        caddr_t         in_boundry;
+        /** fragment bytes to be consumed  */
+        long            fbtbc;
+        /** True if this is the last fragment in the record */
+        bool_t          last_frag;
+        /** The send buffer size */
+        u_int           sendsize;
+        /** The receive buffer size */
+        u_int           recvsize;
+};
+
+/**
+   These are the operation vectors which are defined on an XDR record based
+   stream - refer rpc/xdr.h
+*/
+bool_t xdrrec_getlong (XDR *, long *);
+bool_t xdrrec_putlong (XDR *, const long *);
+bool_t xdrrec_getbytes (XDR *, caddr_t, u_int);
+bool_t xdrrec_putbytes (XDR *, const char *, u_int);
+u_int xdrrec_getpos (const XDR *);
+bool_t xdrrec_setpos (XDR *, u_int);
+int32_t *xdrrec_inline (XDR *, u_int);
+void xdrrec_destroy (XDR *);
+bool_t xdrrec_getint32 (XDR *, int32_t *);
+bool_t xdrrec_putint32 (XDR *, const int32_t *);
+
+const struct xdr_ops c2_xdrrec_ops;
+
+/**
+   Convert the incoming 4 byte data to little endian format. This inline func
+   will replace the existing htonl() and ntohl() macrosin colibri's XDR library
+   On most of the CPUs today, this will just return the passed data without any
+   conversion, thus savinga few processor and bus cycles spent on converting
+   le to be and then back to le.The BIG_ENDIAN option is available just in case
+   we want to run colibri in BIG_ENDIAN machines.
+
+   @param x -> integer to be converted
+
+   @retval the passed parameter in little endian format.
+*/
+
+static inline uint32_t c2_le (uint32_t x)
+{
+#if BYTE_ORDER == LITTLE_ENDIAN
+	return x;
+
+#elif BYTE_ORDER == BIG_ENDIAN
+	return __bswap_32 (x);
+#else
+#error "What system are you on?"
+#endif
+}
+
+#endif /* C2_NET_XDR_REC_H_ */
+
-- 
1.8.3.2

