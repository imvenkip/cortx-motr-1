From 83500857fe83b4bcb8dc1f58863da024c901bd07 Mon Sep 17 00:00:00 2001
From: Yuriy Umanets <yuriy_umanets@xyratex.com>
Date: Fri, 24 Feb 2012 22:35:13 +0400
Subject: [PATCH 176/177] - rollback broken merge

---
 .gitignore                                     |    7 -
 Makefile.am                                    |   79 +-
 addb/.gitignore                                |    1 -
 addb/Makefile.am                               |    9 +-
 addb/addb.c                                    |   18 +-
 addb/addb.ff                                   |   20 -
 addb/addb_fop.c                                |   26 +-
 addb/addb_pseudo/Makefile.am                   |    3 +
 addb/addb_store.c                              |   11 +-
 addb/linux_kernel/addb_console.c               |    8 +-
 autogen.sh                                     |    2 +-
 balloc/Makefile.am                             |    3 +-
 balloc/balloc.c                                |  743 ++++++-----
 balloc/balloc.h                                |   62 +-
 balloc/ut/Makefile.am                          |   52 +-
 balloc/ut/balloc.c                             |  338 ++---
 balloc/ut/dump_free_extent.c                   |   20 +-
 balloc/ut/dump_group_desc.c                    |   16 +-
 balloc/ut/dump_super_block.c                   |   14 +-
 balloc/ut/format.c                             |   13 +-
 balloc/ut/free.c                               |   17 +-
 balloc/ut/mperf.c                              |   64 +-
 balloc/ut/perf.c                               |   34 +-
 build_kernel_modules/.gitignore                |   20 -
 build_kernel_modules/Makefile.in               |  206 +--
 build_kernel_modules/dummy_init_fini.c         |  120 --
 build_kernel_modules/dummy_init_fini.h         |   51 -
 build_kernel_modules/main.c                    |   43 -
 c2t1fs/Makefile.am                             |    4 -
 c2t1fs/Makefile.in                             |  419 +------
 c2t1fs/linux_kernel/.gitignore                 |    7 -
 c2t1fs/linux_kernel/c2t1fs.h                   |  135 --
 c2t1fs/linux_kernel/c2t1fs_loop.c              | 1546 -----------------------
 c2t1fs/linux_kernel/main.c                     | 1509 ----------------------
 c2t1fs/linux_kernel/st/common.sh.in            |   41 -
 c2t1fs/linux_kernel/st/dbench.sh               |   69 -
 c2t1fs/linux_kernel/st/fs_common.sh            |   87 --
 c2t1fs/linux_kernel/st/mini.sh                 |   61 -
 c2t1fs/linux_kernel/st/mount.sh                |   12 -
 c2t1fs/linux_kernel/st/perf.sh                 |   24 -
 c2t1fs/linux_kernel/st/standard_loop.sh        |   76 --
 c2t1fs/linux_kernel/st/test.sh                 |   89 --
 c2t1fs/linux_kernel/st/test2.sh                |   23 -
 c2t1fs/linux_kernel/st/unmount.sh              |   12 -
 capa/Makefile.am                               |    2 +-
 capa/ut/capa_ut.c                              |    2 +-
 cfg/Makefile.am                                |    6 -
 cfg/cfg.c                                      |   66 -
 cfg/cfg.h                                      |  503 --------
 cob/Makefile.am                                |    2 +-
 cob/cob.c                                      |    8 +-
 cob/cob.h                                      |   10 -
 colibri.spec.in                                |   50 -
 colibri/.gitignore                             |    1 -
 colibri/Makefile.am                            |   27 +-
 colibri/colibri_setup.c                        | 1602 ------------------------
 colibri/colibri_setup.h                        |  224 ----
 colibri/cs_main.c                              |  127 --
 colibri/init.c                                 |   48 +-
 colibri/ut/Makefile.am                         |    5 -
 colibri/ut/cs_ut_main.c                        |  383 ------
 configure.ac                                   |  464 +++----
 console/.gitignore                             |    6 -
 console/Makefile.am                            |   25 -
 console/bin/Makefile.am                        |   10 -
 console/console.c                              |   43 -
 console/console.ff                             |   79 --
 console/console.h                              |   58 -
 console/console_fom.c                          |  147 ---
 console/console_fom.h                          |   51 -
 console/console_fop.c                          |  117 --
 console/console_fop.h                          |   68 -
 console/console_it.c                           |  416 ------
 console/console_it.h                           |  110 --
 console/console_mesg.c                         |  131 --
 console/console_mesg.h                         |   75 --
 console/console_yaml.c                         |  216 ----
 console/console_yaml.h                         |  102 --
 console/main.c                                 |  355 ------
 console/st/Makefile.am                         |    7 -
 console/st/server.c                            |  133 --
 console/ut/Makefile.am                         |    3 -
 console/ut/console.c                           |  745 -----------
 db/Makefile.am                                 |    5 +-
 db/db.c                                        |   39 +-
 db/db.h                                        |   31 +-
 db/db_common.c                                 |   20 +-
 db/db_common.h                                 |    4 +-
 db/db_impl.h                                   |    4 +-
 db/linux_kernel/db.c                           |  135 +-
 db/linux_kernel/db_impl.h                      |   13 +-
 db/nobl.h                                      |  106 --
 desim/Makefile.am                              |    2 +-
 desim/chs.h                                    |    2 +
 desim/client.c                                 |   43 +-
 desim/client.h                                 |    6 +-
 desim/cnt.c                                    |   27 +-
 desim/cnt.h                                    |   11 +-
 desim/elevator.c                               |   18 +-
 desim/elevator.h                               |    6 +-
 desim/net.c                                    |   33 +-
 desim/net.h                                    |   10 +-
 desim/sim.c                                    |  103 +-
 desim/sim.h                                    |   32 +-
 doc/Doxyfile                                   | 1342 ++++++++++----------
 doc/coding-style                               |   20 +-
 doc/dld-index.c                                |   24 -
 doc/dld-template.c                             |  587 ---------
 doc/dld-template.h                             |  211 ----
 doc/git-policy                                 |  444 -------
 doc/magix                                      |   10 -
 doc/reading-list.html                          |   99 --
 doc/source-structure                           |   40 +-
 doc/test-coverage                              |  145 ---
 dtm/Makefile.am                                |    2 +-
 dtm/verno.c                                    |   14 +-
 fid/Makefile.am                                |    2 +-
 fid/fid.c                                      |    9 +-
 fol/Makefile.am                                |    2 +-
 fol/fol.c                                      |   22 +-
 fol/fol.h                                      |   12 +
 fol/lsn.h                                      |    5 +-
 fol/ut/fol.c                                   |    3 +-
 fop/Makefile.am                                |   23 +-
 fop/fom.c                                      |  769 ------------
 fop/fom.h                                      |  355 ++----
 fop/fop.c                                      |  302 +++--
 fop/fop.h                                      |  206 ++-
 fop/fop2c.in                                   |   14 +-
 fop/fop_base.c                                 |  256 ----
 fop/fop_base.h                                 |  253 ----
 fop/fop_format.c                               |   11 +-
 fop/fop_format.h                               |   25 +-
 fop/fop_format_c.c                             |   18 +-
 fop/fop_format_def.h                           |    4 +-
 fop/fop_item_type.c                            |  108 --
 fop/fop_item_type.h                            |   81 --
 fop/fop_iterator.c                             |   95 +-
 fop/fop_iterator.h                             |   26 +-
 fop/fop_user.h                                 |    2 +-
 fop/rt/Makefile.am                             |   18 -
 fop/rt/stub.c                                  |   54 -
 fop/ut/Makefile.am                             |    9 +-
 fop/ut/iterator_test.c                         |    6 +-
 fop/ut/iterator_test.ff                        |   19 -
 fop/ut/test_format.ff                          |   19 -
 ioservice/Makefile.am                          |   25 +-
 ioservice/cobfid_map.c                         |  705 -----------
 ioservice/cobfid_map.h                         |  288 -----
 ioservice/io_foms.c                            |  511 ++++----
 ioservice/io_foms.h                            |   93 +-
 ioservice/io_fops.c                            |  594 +--------
 ioservice/io_fops.ff                           |  165 ++-
 ioservice/io_fops.h                            |  120 +-
 ioservice/ut/Makefile.am                       |    3 -
 ioservice/ut/cobfid_map.c                      |  689 ----------
 iostore/iostore.h                              |    4 +-
 layout/Makefile.am                             |    2 +-
 layout/pdclust.c                               |   34 +-
 lib/Makefile.am                                |  161 +--
 lib/arith.h                                    |   20 +-
 lib/assert.c                                   |    8 +-
 lib/atomic.h                                   |   32 +-
 lib/bitmap.c                                   |   13 +-
 lib/bitmap.h                                   |    9 -
 lib/bitstring.c                                |    1 +
 lib/bob.c                                      |   76 --
 lib/bob.h                                      |  138 --
 lib/buf.c                                      |    3 +-
 lib/buf.h                                      |    2 +-
 lib/c2lib.c                                    |   42 -
 lib/cdefs.h                                    |   45 +-
 lib/chan.c                                     |  112 +-
 lib/chan.h                                     |  167 +--
 lib/cond.c                                     |    7 +-
 lib/cond.h                                     |   15 +-
 lib/getopts.c                                  |   14 +-
 lib/getopts.h                                  |   18 +-
 lib/linux_kernel/atomic64.h                    |   44 +-
 lib/linux_kernel/kthread.c                     |  115 +-
 lib/linux_kernel/ktime.c                       |    9 +-
 lib/linux_kernel/ktrace.c                      |   72 --
 lib/linux_kernel/kvec.c                        |   47 -
 lib/linux_kernel/main.c                        |   51 +-
 lib/linux_kernel/memory.c                      |   10 +-
 lib/linux_kernel/mutex.c                       |    3 +
 lib/linux_kernel/processor.c                   |   11 +
 lib/linux_kernel/rwlock.c                      |    6 +
 lib/linux_kernel/semaphore.c                   |   26 +-
 lib/linux_kernel/timer.c                       |   78 +-
 lib/linux_kernel/timer.h                       |   26 +-
 lib/linux_kernel/types.h                       |    1 -
 lib/linux_kernel/ut.c                          |    9 +-
 lib/linux_kernel/vec.h                         |   60 -
 lib/list.c                                     |   17 +-
 lib/list.h                                     |    6 +-
 lib/memory.h                                   |    8 +-
 lib/misc.c                                     |    7 +-
 lib/misc.h                                     |    2 +-
 lib/mutex.c                                    |    2 +-
 lib/mutex.h                                    |    2 +-
 lib/processor.h                                |    5 +-
 lib/queue.c                                    |    2 +-
 lib/queue.h                                    |    2 +-
 lib/refs.c                                     |    6 +-
 lib/refs.h                                     |    2 +-
 lib/rwlock.h                                   |    2 +-
 lib/semaphore.h                                |    2 +-
 lib/thread.c                                   |    4 +-
 lib/thread.h                                   |   17 +-
 lib/time.c                                     |   16 +-
 lib/time.h                                     |   16 +-
 lib/timer.c                                    |  562 +--------
 lib/timer.h                                    |  130 +-
 lib/tlist.c                                    |  264 ----
 lib/tlist.h                                    |  613 ---------
 lib/trace.c                                    |  227 ----
 lib/trace.h                                    |  397 +-----
 lib/types.h                                    |    2 +-
 lib/ub.c                                       |    2 +-
 lib/ub.h                                       |    2 +-
 lib/user_space/Makefile.am                     |    4 +-
 lib/user_space/assert.h                        |    2 +-
 lib/user_space/cdefs.h                         |    2 +-
 lib/user_space/memory.c                        |  187 ---
 lib/user_space/mutex.h                         |    2 +-
 lib/user_space/processor.c                     |  155 +--
 lib/user_space/rwlock.c                        |    2 +-
 lib/user_space/rwlock.h                        |    2 +-
 lib/user_space/semaphore.c                     |    2 +-
 lib/user_space/semaphore.h                     |    2 +-
 lib/user_space/thread.h                        |    2 +-
 lib/user_space/time.h                          |    2 +-
 lib/user_space/timer.h                         |   85 +-
 lib/user_space/trace.h                         |   46 -
 lib/user_space/types.h                         |    2 +-
 lib/user_space/user_x86_64_atomic.h            |   17 +-
 lib/user_space/uthread.c                       |    3 +-
 lib/user_space/utime.c                         |   12 +-
 lib/user_space/utrace.c                        |  193 ---
 lib/ut.c                                       |  253 +---
 lib/ut.h                                       |   95 +-
 lib/ut/Makefile.am                             |   25 +-
 lib/ut/atomic.c                                |  137 +-
 lib/ut/bitmap.c                                |   34 +-
 lib/ut/bob.c                                   |  135 --
 lib/ut/chan.c                                  |  126 +-
 lib/ut/getopts.c                               |   18 +-
 lib/ut/list.c                                  |    5 +-
 lib/ut/main.c                                  |   14 +-
 lib/ut/memory.c                                |    2 +-
 lib/ut/mutex.c                                 |    2 +-
 lib/ut/processor.c                             |   24 +-
 lib/ut/queue.c                                 |    8 +-
 lib/ut/refs.c                                  |    2 +-
 lib/ut/rwlock.c                                |    2 +-
 lib/ut/thread.c                                |    9 +-
 lib/ut/time.c                                  |    6 +-
 lib/ut/timer.c                                 |  575 ++-------
 lib/ut/tlist.c                                 |  347 -----
 lib/ut/trace.c                                 |   49 +-
 lib/ut/vec.c                                   |    8 +-
 lib/ut/zerovec.c                               |  230 ----
 lib/vec.c                                      |  155 +--
 lib/vec.h                                      |  127 +-
 m4/xyratex.m4                                  |   40 -
 mw/Makefile.am                                 |    2 +-
 mw/consensus.h                                 |    2 +-
 net/.gitignore                                 |    6 +-
 net/Makefile.am                                |   23 +-
 net/buf.c                                      |  108 +-
 net/buffer_pool.c                              |  295 -----
 net/buffer_pool.h                              |  260 ----
 net/bulk_emulation/.gitignore                  |    6 +-
 net/bulk_emulation/Makefile.am                 |   25 +-
 net/bulk_emulation/ksunrpc_server.c            |  509 --------
 net/bulk_emulation/mem_xprt.h                  |   45 +-
 net/bulk_emulation/mem_xprt_bulk.c             |   23 +-
 net/bulk_emulation/mem_xprt_ep.c               |   49 +-
 net/bulk_emulation/mem_xprt_msg.c              |   18 +-
 net/bulk_emulation/mem_xprt_pvt.h              |   37 +-
 net/bulk_emulation/mem_xprt_tm.c               |   28 +-
 net/bulk_emulation/mem_xprt_xo.c               |   63 +-
 net/bulk_emulation/st/Makefile.am              |    8 +-
 net/bulk_emulation/st/linux_kernel/.gitignore  |    1 -
 net/bulk_emulation/st/linux_kernel/Makefile.in |   26 -
 net/bulk_emulation/st/linux_kernel/main.c      |  245 ----
 net/bulk_emulation/st/linux_kernel/test.sh     |   39 -
 net/bulk_emulation/st/main.c                   |   64 +-
 net/bulk_emulation/st/ping.c                   |  350 +++---
 net/bulk_emulation/st/ping.h                   |   21 +-
 net/bulk_emulation/sunrpc_io.ff                |   21 +-
 net/bulk_emulation/sunrpc_xprt.h               |  132 +-
 net/bulk_emulation/sunrpc_xprt_bulk.c          |  163 ++-
 net/bulk_emulation/sunrpc_xprt_ep.c            |  294 ++---
 net/bulk_emulation/sunrpc_xprt_msg.c           |   52 +-
 net/bulk_emulation/sunrpc_xprt_pvt.h           |   12 +-
 net/bulk_emulation/sunrpc_xprt_tm.c            |   73 +-
 net/bulk_emulation/sunrpc_xprt_xo.c            |  472 +------
 net/bulk_emulation/ut/Makefile.am              |    2 +-
 net/bulk_emulation/ut/bulk_mem_ut.c            |  234 ++--
 net/bulk_emulation/ut/bulk_sunrpc_ut.c         |  656 +++-------
 net/bulk_emulation/ut/ksunrpc_ut.c             |  391 ------
 net/bulk_mem.h                                 |    6 +-
 net/bulk_sunrpc.h                              |   52 +-
 net/connection.c                               |    6 +-
 net/domain.c                                   |   10 +-
 net/ep.c                                       |   46 +-
 net/ksunrpc/client.c                           |   22 +-
 net/ksunrpc/domain.c                           |   41 +-
 net/ksunrpc/ksunrpc.h                          |   24 +-
 net/ksunrpc/kxdr.c                             |  192 +--
 net/lnet/bev_cqueue.c                          |  696 ----------
 net/lnet/linux_kernel/klnet_core.c             |  736 -----------
 net/lnet/linux_kernel/klnet_core.h             |  126 --
 net/lnet/lnet.h                                |  100 --
 net/lnet/lnet_core.h                           |  640 ----------
 net/lnet/lnet_main.c                           |  764 -----------
 net/lnet/lnet_xo.c                             |  153 ---
 net/lnet/lnet_xo.h                             |  139 --
 net/lnet/ulnet_core.h                          |   73 --
 net/net.c                                      |    2 +-
 net/net.h                                      |  472 ++-----
 net/net_cli.c                                  |    6 +-
 net/net_internal.h                             |   18 +-
 net/net_otw_types.ff                           |   20 -
 net/net_srv.c                                  |   26 +-
 net/net_utils.c                                |    7 +-
 net/net_xdr.c                                  |    3 +-
 net/st/Makefile.am                             |    5 +-
 net/st/kclient.c                               |    2 +-
 net/tm.c                                       |  148 +--
 net/usunrpc/Makefile.am                        |    2 +-
 net/usunrpc/client.c                           |   76 +-
 net/usunrpc/domain.c                           |   10 +-
 net/usunrpc/server.c                           |   48 +-
 net/usunrpc/usunrpc.h                          |    2 +-
 net/usunrpc/usunrpc_internal.h                 |    3 +-
 net/usunrpc/uxdr.c                             |    2 +-
 net/ut/.gitignore                              |    2 +
 net/ut/Makefile.am                             |   17 +-
 net/ut/buffer_pool_ut.c                        |  224 ----
 net/ut/bulk_if.c                               |  594 ++-------
 net/ut/net.ff                                  |   19 -
 net/ut/net_fop.h                               |    2 +-
 net/ut/net_fop_init.c                          |    7 +-
 net/ut/utils.c                                 |    2 +-
 net/xdr.h                                      |    3 +-
 nrs/Makefile.am                                |    2 +-
 nrs/nrs.c                                      |   14 +-
 nrs/nrs.h                                      |    3 +-
 pool/Makefile.am                               |    2 +-
 pool/pool.c                                    |    6 +-
 pool/pool.h                                    |    2 +-
 reqh/.gitignore                                |    2 -
 reqh/Makefile.am                               |   20 +-
 reqh/reqh.c                                    |  240 ++--
 reqh/reqh.h                                    |  240 +---
 reqh/reqh_fops.c                               |   82 --
 reqh/reqh_fops.ff                              |   45 -
 reqh/reqh_generic.c                            |  517 --------
 reqh/reqh_service.c                            |  221 ----
 reqh/reqh_service.h                            |  515 --------
 reqh/ut/.gitignore                             |    2 -
 reqh/ut/Makefile.am                            |    5 -
 reqh/ut/reqh_fom_ut.c                          |  458 -------
 rpc/.gitignore                                 |    1 -
 rpc/Makefile.am                                |   32 +-
 rpc/compound_srv.h                             |    2 +-
 rpc/conn.c                                     | 1198 ------------------
 rpc/formation.c                                | 1413 ---------------------
 rpc/formation.h                                |  325 -----
 rpc/it/.gitignore                              |    2 -
 rpc/it/Makefile.am                             |   22 -
 rpc/it/linux_kernel/.gitignore                 |    4 -
 rpc/it/linux_kernel/Makefile.in                |   26 -
 rpc/it/linux_kernel/load.sh                    |    4 -
 rpc/it/linux_kernel/rpc_ping.h                 |   22 -
 rpc/it/linux_kernel/rpcload.sh                 |   27 -
 rpc/it/linux_kernel/rpcping_kernel.c           |   46 -
 rpc/it/linux_kernel/unload.sh                  |    4 -
 rpc/it/ping_fom.c                              |  137 --
 rpc/it/ping_fom.h                              |   58 -
 rpc/it/ping_fop.c                              |  103 --
 rpc/it/ping_fop.ff                             |   40 -
 rpc/it/ping_fop.h                              |   56 -
 rpc/it/rpc_ping.c                              |  577 ---------
 rpc/linux_kernel/rpc_kernel.h                  |   37 -
 rpc/rpc2.c                                     | 1309 -------------------
 rpc/rpc2.h                                     | 1000 ---------------
 rpc/rpc_base.c                                 |  125 --
 rpc/rpc_base.h                                 |  194 ---
 rpc/rpc_onwire.c                               |  336 -----
 rpc/rpc_onwire.h                               |  143 ---
 rpc/rpc_opcodes.h                              |  120 --
 rpc/rpcdbg.h                                   |   24 -
 rpc/rpclib.c                                   |  323 +++--
 rpc/rpclib.h                                   |  262 ++--
 rpc/session.c                                  | 1241 ------------------
 rpc/session.ff                                 |  153 ---
 rpc/session.h                                  | 1196 +-----------------
 rpc/session_foms.c                             |  556 --------
 rpc/session_foms.h                             |  113 --
 rpc/session_fops.c                             |  256 ----
 rpc/session_fops.h                             |  107 --
 rpc/session_internal.h                         |  531 --------
 rpc/session_utils.c                            |  241 ----
 rpc/slot.c                                     |  982 ---------------
 rpc/slot.h                                     |    2 +-
 rpc/ut/.gitignore                              |    2 -
 rpc/ut/Makefile.am                             |   36 +-
 rpc/ut/onwire_ut.c                             |  197 ---
 rpc/ut/rpclib_ut.c                             |  190 ---
 rpc/ut/test.ff                                 |    8 -
 rpc/xdr/common.c                               |    2 +-
 rpc/xdr/common.h                               |    2 +-
 rpc/xdr/session.c                              |    2 +-
 rpc/xdr/session.h                              |    2 +-
 sm/Makefile.am                                 |    2 +-
 sm/sm.c                                        |  315 +----
 sm/sm.h                                        |  535 +-------
 sm/ut/Makefile.am                              |    4 -
 sm/ut/sm.c                                     |  372 ------
 sns/Makefile.am                                |    2 +-
 sns/ls_solve.c                                 |    2 +-
 sns/ls_solve.h                                 |    2 +-
 sns/matvec.c                                   |    2 +-
 sns/matvec.h                                   |    2 +-
 sns/parity_math.c                              |    6 +-
 sns/parity_math.h                              |    2 +-
 sns/parity_ops.c                               |    4 +-
 sns/parity_ops.h                               |    4 +-
 sns/poolmach.c                                 |   11 +-
 sns/repair.c                                   |    3 +-
 sns/repair.h                                   |   33 +-
 sns/sns.c                                      |    2 +-
 sns/sns.h                                      |    2 +-
 sns/ut/parity_math_mt_ub.c                     |    2 +-
 sns/ut/parity_math_ut.c                        |   17 +-
 stob/.gitignore                                |    3 +-
 stob/Makefile.am                               |   13 +-
 stob/ad.c                                      |  122 +-
 stob/ad.h                                      |   26 +-
 stob/io_fop.c                                  |  678 ----------
 stob/io_fop.ff                                 |   69 -
 stob/io_fop.h                                  |   55 -
 stob/linux.c                                   |  141 +--
 stob/linux.h                                   |   14 +-
 stob/linux_adieu.c                             |   74 +-
 stob/linux_getevents.h                         |    2 +-
 stob/linux_internal.h                          |   41 +-
 stob/stob.c                                    |   30 +-
 stob/stob.h                                    |   60 +-
 stob/stob_id.c                                 |    5 +-
 stob/stob_id.h                                 |    2 +-
 stob/ut/Makefile.am                            |   19 +-
 stob/ut/ad.c                                   |   74 +-
 stob/ut/adieu.c                                |   70 +-
 stob/ut/client.c                               |  333 ++---
 stob/ut/io.ff                                  |   19 -
 stob/ut/io_fop.h                               |   16 +-
 stob/ut/io_fop_init.c                          |   69 +-
 stob/ut/io_fop_xdr.c                           |    2 +-
 stob/ut/server.c                               |  653 +++++++++-
 stob/ut/stobio.c                               |  188 +--
 udb/Makefile.am                                |    2 +-
 udb/udb.c                                      |    2 +-
 udb/udb.h                                      |    2 +-
 udb/ut/udb_ut.c                                |    2 +-
 ut/.gitignore                                  |    1 -
 ut/Makefile.am                                 |   21 -
 ut/README                                      |   10 -
 ut/cs_fop_foms.c                               |  371 ------
 ut/cs_fop_foms.h                               |   74 --
 ut/cs_service.c                                |  167 ---
 ut/cs_service.h                                |   30 -
 ut/cs_test_fops.ff                             |   45 -
 ut/linux_kernel/.gitignore                     |    1 -
 ut/linux_kernel/Makefile.in                    |   22 -
 ut/net.c                                       |   87 --
 ut/net.h                                       |   30 -
 ut/rpc.c                                       |  108 --
 ut/rpc.h                                       |   65 -
 ut/ut.h                                        |   51 -
 utils/Makefile.am                              |   30 +-
 utils/branchmeter.sh                           |   88 --
 utils/common.c                                 |    8 +-
 utils/common.h                                 |    4 +-
 utils/gcov_stats_genhtml.sh                    |  131 --
 utils/linux_kernel/Makefile.in                 |   12 +-
 utils/linux_kernel/main.c                      |   62 +-
 utils/linux_kernel/ut.sh                       |   32 -
 utils/ploss/Makefile.am                        |    2 +-
 utils/ploss/pl.h                               |    6 +-
 utils/ploss/pl_svc.c                           |    6 +-
 utils/process_lcov.sh                          |  128 --
 utils/run_tests.sh                             |  536 --------
 utils/ub_main.c                                |    8 +-
 utils/ut.valgrind                              |   15 -
 utils/ut_main.c                                |  246 +---
 xcode/Makefile.am                              |   12 -
 xcode/bufvec_xcode.c                           |  373 ------
 xcode/bufvec_xcode.h                           |  198 ---
 xcode/bufvec_xcode_fop.c                       |  400 ------
 xcode/bufvec_xcode_size.c                      |  329 -----
 xcode/cursor.c                                 |  136 --
 xcode/ff2c/.gitignore                          |    1 -
 xcode/ff2c/Makefile.am                         |    9 -
 xcode/ff2c/bnf                                 |   33 -
 xcode/ff2c/ff2c.c                              |  204 ---
 xcode/ff2c/gen.c                               |  250 ----
 xcode/ff2c/gen.h                               |   56 -
 xcode/ff2c/lex.c                               |  267 ----
 xcode/ff2c/lex.h                               |  159 ---
 xcode/ff2c/parser.c                            |  252 ----
 xcode/ff2c/parser.h                            |   77 --
 xcode/ff2c/sample.ff                           |  147 ---
 xcode/ff2c/sem.c                               |  275 ----
 xcode/ff2c/sem.h                               |  109 --
 xcode/ut/.gitignore                            |    2 -
 xcode/ut/Makefile.am                           |   18 -
 xcode/ut/ff2c.c                                |  227 ----
 xcode/ut/test.ff                               |   28 -
 xcode/ut/xcode.c                               |  554 --------
 xcode/ut/xcode_fop_test.c                      |  275 ----
 xcode/ut/xcode_test.c                          |  271 ----
 xcode/xcode.c                                  |  472 -------
 xcode/xcode.h                                  |  652 ----------
 yaml2db/Makefile.am                            |    9 -
 yaml2db/st/.gitignore                          |    1 -
 yaml2db/st/Makefile.am                         |    6 -
 yaml2db/st/main.c                              |  265 ----
 yaml2db/st/test.sh                             |   50 -
 yaml2db/ut/Makefile.am                         |    3 -
 yaml2db/ut/yaml2db.c                           |  460 -------
 yaml2db/yaml2db.c                              |  762 -----------
 yaml2db/yaml2db.h                              |  316 -----
 537 files changed, 7081 insertions(+), 62562 deletions(-)
 delete mode 100644 build_kernel_modules/.gitignore
 delete mode 100644 build_kernel_modules/dummy_init_fini.c
 delete mode 100644 build_kernel_modules/dummy_init_fini.h
 delete mode 100644 build_kernel_modules/main.c
 delete mode 100644 c2t1fs/Makefile.am
 delete mode 100644 c2t1fs/linux_kernel/.gitignore
 delete mode 100644 c2t1fs/linux_kernel/c2t1fs.h
 delete mode 100644 c2t1fs/linux_kernel/c2t1fs_loop.c
 delete mode 100644 c2t1fs/linux_kernel/main.c
 delete mode 100644 c2t1fs/linux_kernel/st/common.sh.in
 delete mode 100755 c2t1fs/linux_kernel/st/dbench.sh
 delete mode 100644 c2t1fs/linux_kernel/st/fs_common.sh
 delete mode 100644 c2t1fs/linux_kernel/st/mini.sh
 delete mode 100755 c2t1fs/linux_kernel/st/mount.sh
 delete mode 100755 c2t1fs/linux_kernel/st/perf.sh
 delete mode 100644 c2t1fs/linux_kernel/st/standard_loop.sh
 delete mode 100755 c2t1fs/linux_kernel/st/test.sh
 delete mode 100755 c2t1fs/linux_kernel/st/test2.sh
 delete mode 100755 c2t1fs/linux_kernel/st/unmount.sh
 delete mode 100644 cfg/Makefile.am
 delete mode 100644 cfg/cfg.c
 delete mode 100644 cfg/cfg.h
 delete mode 100644 colibri.spec.in
 delete mode 100644 colibri/.gitignore
 delete mode 100644 colibri/colibri_setup.c
 delete mode 100644 colibri/colibri_setup.h
 delete mode 100644 colibri/cs_main.c
 delete mode 100644 colibri/ut/Makefile.am
 delete mode 100644 colibri/ut/cs_ut_main.c
 delete mode 100644 console/.gitignore
 delete mode 100644 console/Makefile.am
 delete mode 100644 console/bin/Makefile.am
 delete mode 100644 console/console.c
 delete mode 100644 console/console.ff
 delete mode 100644 console/console.h
 delete mode 100644 console/console_fom.c
 delete mode 100644 console/console_fom.h
 delete mode 100644 console/console_fop.c
 delete mode 100644 console/console_fop.h
 delete mode 100644 console/console_it.c
 delete mode 100644 console/console_it.h
 delete mode 100644 console/console_mesg.c
 delete mode 100644 console/console_mesg.h
 delete mode 100644 console/console_yaml.c
 delete mode 100644 console/console_yaml.h
 delete mode 100644 console/main.c
 delete mode 100644 console/st/Makefile.am
 delete mode 100644 console/st/server.c
 delete mode 100644 console/ut/Makefile.am
 delete mode 100644 console/ut/console.c
 delete mode 100644 db/nobl.h
 delete mode 100644 doc/dld-index.c
 delete mode 100644 doc/dld-template.c
 delete mode 100644 doc/dld-template.h
 delete mode 100644 doc/git-policy
 delete mode 100755 doc/magix
 delete mode 100644 doc/reading-list.html
 delete mode 100644 doc/test-coverage
 delete mode 100644 fop/fom.c
 delete mode 100644 fop/fop_base.c
 delete mode 100644 fop/fop_base.h
 delete mode 100644 fop/fop_item_type.c
 delete mode 100644 fop/fop_item_type.h
 delete mode 100644 fop/rt/Makefile.am
 delete mode 100644 fop/rt/stub.c
 delete mode 100644 ioservice/cobfid_map.c
 delete mode 100644 ioservice/cobfid_map.h
 delete mode 100644 ioservice/ut/Makefile.am
 delete mode 100644 ioservice/ut/cobfid_map.c
 delete mode 100644 lib/bob.c
 delete mode 100644 lib/bob.h
 delete mode 100644 lib/c2lib.c
 delete mode 100644 lib/linux_kernel/ktrace.c
 delete mode 100644 lib/linux_kernel/kvec.c
 delete mode 100644 lib/linux_kernel/vec.h
 delete mode 100644 lib/tlist.c
 delete mode 100644 lib/tlist.h
 delete mode 100644 lib/trace.c
 delete mode 100644 lib/user_space/memory.c
 delete mode 100644 lib/user_space/trace.h
 delete mode 100644 lib/user_space/utrace.c
 delete mode 100644 lib/ut/bob.c
 delete mode 100644 lib/ut/tlist.c
 delete mode 100644 lib/ut/zerovec.c
 delete mode 100644 m4/xyratex.m4
 delete mode 100644 net/buffer_pool.c
 delete mode 100644 net/buffer_pool.h
 delete mode 100644 net/bulk_emulation/ksunrpc_server.c
 delete mode 100644 net/bulk_emulation/st/linux_kernel/.gitignore
 delete mode 100644 net/bulk_emulation/st/linux_kernel/Makefile.in
 delete mode 100644 net/bulk_emulation/st/linux_kernel/main.c
 delete mode 100755 net/bulk_emulation/st/linux_kernel/test.sh
 delete mode 100644 net/bulk_emulation/ut/ksunrpc_ut.c
 delete mode 100644 net/lnet/bev_cqueue.c
 delete mode 100644 net/lnet/linux_kernel/klnet_core.c
 delete mode 100644 net/lnet/linux_kernel/klnet_core.h
 delete mode 100644 net/lnet/lnet.h
 delete mode 100644 net/lnet/lnet_core.h
 delete mode 100644 net/lnet/lnet_main.c
 delete mode 100644 net/lnet/lnet_xo.c
 delete mode 100644 net/lnet/lnet_xo.h
 delete mode 100644 net/lnet/ulnet_core.h
 delete mode 100644 net/ut/buffer_pool_ut.c
 delete mode 100644 reqh/.gitignore
 delete mode 100644 reqh/reqh_fops.c
 delete mode 100644 reqh/reqh_fops.ff
 delete mode 100644 reqh/reqh_generic.c
 delete mode 100644 reqh/reqh_service.c
 delete mode 100644 reqh/reqh_service.h
 delete mode 100644 reqh/ut/.gitignore
 delete mode 100644 reqh/ut/Makefile.am
 delete mode 100644 reqh/ut/reqh_fom_ut.c
 delete mode 100644 rpc/.gitignore
 delete mode 100644 rpc/conn.c
 delete mode 100644 rpc/formation.c
 delete mode 100644 rpc/formation.h
 delete mode 100644 rpc/it/.gitignore
 delete mode 100644 rpc/it/Makefile.am
 delete mode 100644 rpc/it/linux_kernel/.gitignore
 delete mode 100644 rpc/it/linux_kernel/Makefile.in
 delete mode 100644 rpc/it/linux_kernel/load.sh
 delete mode 100644 rpc/it/linux_kernel/rpc_ping.h
 delete mode 100755 rpc/it/linux_kernel/rpcload.sh
 delete mode 100644 rpc/it/linux_kernel/rpcping_kernel.c
 delete mode 100644 rpc/it/linux_kernel/unload.sh
 delete mode 100644 rpc/it/ping_fom.c
 delete mode 100644 rpc/it/ping_fom.h
 delete mode 100644 rpc/it/ping_fop.c
 delete mode 100644 rpc/it/ping_fop.ff
 delete mode 100644 rpc/it/ping_fop.h
 delete mode 100644 rpc/it/rpc_ping.c
 delete mode 100644 rpc/linux_kernel/rpc_kernel.h
 delete mode 100644 rpc/rpc2.c
 delete mode 100644 rpc/rpc2.h
 delete mode 100644 rpc/rpc_base.c
 delete mode 100644 rpc/rpc_base.h
 delete mode 100644 rpc/rpc_onwire.c
 delete mode 100644 rpc/rpc_onwire.h
 delete mode 100644 rpc/rpc_opcodes.h
 delete mode 100644 rpc/rpcdbg.h
 delete mode 100644 rpc/session.c
 delete mode 100644 rpc/session.ff
 delete mode 100644 rpc/session_foms.c
 delete mode 100644 rpc/session_foms.h
 delete mode 100644 rpc/session_fops.c
 delete mode 100644 rpc/session_fops.h
 delete mode 100644 rpc/session_internal.h
 delete mode 100644 rpc/session_utils.c
 delete mode 100644 rpc/slot.c
 delete mode 100644 rpc/ut/onwire_ut.c
 delete mode 100644 rpc/ut/rpclib_ut.c
 delete mode 100644 rpc/ut/test.ff
 delete mode 100644 sm/ut/Makefile.am
 delete mode 100644 sm/ut/sm.c
 delete mode 100644 stob/io_fop.c
 delete mode 100644 stob/io_fop.ff
 delete mode 100644 stob/io_fop.h
 delete mode 100644 ut/.gitignore
 delete mode 100644 ut/Makefile.am
 delete mode 100644 ut/README
 delete mode 100644 ut/cs_fop_foms.c
 delete mode 100644 ut/cs_fop_foms.h
 delete mode 100644 ut/cs_service.c
 delete mode 100644 ut/cs_service.h
 delete mode 100644 ut/cs_test_fops.ff
 delete mode 100644 ut/linux_kernel/.gitignore
 delete mode 100644 ut/linux_kernel/Makefile.in
 delete mode 100644 ut/net.c
 delete mode 100644 ut/net.h
 delete mode 100644 ut/rpc.c
 delete mode 100644 ut/rpc.h
 delete mode 100644 ut/ut.h
 delete mode 100755 utils/branchmeter.sh
 delete mode 100755 utils/gcov_stats_genhtml.sh
 delete mode 100755 utils/linux_kernel/ut.sh
 delete mode 100755 utils/process_lcov.sh
 delete mode 100755 utils/run_tests.sh
 delete mode 100755 utils/ut.valgrind
 delete mode 100644 xcode/Makefile.am
 delete mode 100644 xcode/bufvec_xcode.c
 delete mode 100644 xcode/bufvec_xcode.h
 delete mode 100644 xcode/bufvec_xcode_fop.c
 delete mode 100644 xcode/bufvec_xcode_size.c
 delete mode 100644 xcode/cursor.c
 delete mode 100644 xcode/ff2c/.gitignore
 delete mode 100644 xcode/ff2c/Makefile.am
 delete mode 100644 xcode/ff2c/bnf
 delete mode 100644 xcode/ff2c/ff2c.c
 delete mode 100644 xcode/ff2c/gen.c
 delete mode 100644 xcode/ff2c/gen.h
 delete mode 100644 xcode/ff2c/lex.c
 delete mode 100644 xcode/ff2c/lex.h
 delete mode 100644 xcode/ff2c/parser.c
 delete mode 100644 xcode/ff2c/parser.h
 delete mode 100644 xcode/ff2c/sample.ff
 delete mode 100644 xcode/ff2c/sem.c
 delete mode 100644 xcode/ff2c/sem.h
 delete mode 100644 xcode/ut/.gitignore
 delete mode 100644 xcode/ut/Makefile.am
 delete mode 100644 xcode/ut/ff2c.c
 delete mode 100644 xcode/ut/test.ff
 delete mode 100644 xcode/ut/xcode.c
 delete mode 100644 xcode/ut/xcode_fop_test.c
 delete mode 100644 xcode/ut/xcode_test.c
 delete mode 100644 xcode/xcode.c
 delete mode 100644 xcode/xcode.h
 delete mode 100644 yaml2db/Makefile.am
 delete mode 100644 yaml2db/st/.gitignore
 delete mode 100644 yaml2db/st/Makefile.am
 delete mode 100644 yaml2db/st/main.c
 delete mode 100644 yaml2db/st/test.sh
 delete mode 100644 yaml2db/ut/Makefile.am
 delete mode 100644 yaml2db/ut/yaml2db.c
 delete mode 100644 yaml2db/yaml2db.c
 delete mode 100644 yaml2db/yaml2db.h

diff --git a/.gitignore b/.gitignore
index 6d6e311..fa9c23c 100644
--- a/.gitignore
+++ b/.gitignore
@@ -39,13 +39,8 @@ missing
 .*.o.cmd
 .*.o.d
 *.ko
-*.ko.unsigned
-*.ko.unsigned.cmd
 *.mod.c
 *.mod.o
-*.gcda
-*.gcno
-*.gcov
 *~
 doc/html/
 .#*
@@ -68,5 +63,3 @@ ut-sandbox
 ub-sandbox
 gmon.out
 doxygen_*tmp
-cscope.out
-tags
diff --git a/Makefile.am b/Makefile.am
index 9bc9366..566ba16 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -1,73 +1,30 @@
 SUBDIRS_BASE = m4 doc man patches
 
-# Order is important until fop/rt is reached. Fop needs all libs
-# before it in the list built in order to use fop2c addb_pseudo is
-# used only for build fop2c, with which full addb can be built. Keep
-# this list alphabetically sorted after "net".
+# Order is important until fop is reached. Fop needs all libs before it in the
+# list built in order to use fop2c
+# addb_pseudo is used only for build fop2c, with which full addb can be built
+SUBDIRS_LIBS = lib addb/addb_pseudo fol db fid fop sm stob xdr net addb dtm nrs \
+               sns mw layout pool balloc desim cob capa udb ioservice mdservice \
+               site reqh mdstore iostore # rpc
 
-SUBDIRS_LIBS = \
-               lib \
-               addb/addb_pseudo \
-               c2t1fs \
-               fol \
-               db \
-               fid \
-               fop/rt \
-               \
-               net \
-               fop \
-               addb \
-               balloc \
-               capa \
-               cfg \
-               cob \
-	       console \
-               desim \
-               dtm \
-               ioservice \
-               mdservice \
-               site \
-               layout \
-               mw \
-               nrs \
-               pool \
-               reqh \
-               mdstore \
-               iostore \
-               rpc \
-               sm \
-               sns \
-               stob \
-               udb \
-               ut \
-               xcode \
-               xcode/ff2c \
-	       yaml2db
-SUBDIR_IT = rpc/it
-SUBDIR_UT = fop/ut lib/ut stob/ut layout/ut balloc/ut db/ut fol/ut \
-	    sns/ut desim/ut cob/ut console/ut colibri/ut net/ut \
-	    net/bulk_emulation/ut udb/ut capa/ut ioservice/ut reqh/ut rpc/ut \
-	    sm/ut xcode/ut yaml2db/ut
 SUBDIR_KERNEL = build_kernel_modules
-SUBDIR_ST = console/st net/st net/bulk_emulation/st yaml2db/st
-
+if HAVE_CUNIT_SUPPORT
+SUBDIR_UT = fop/ut lib/ut stob/ut layout/ut balloc/ut db/ut \
+            fol/ut sns/ut desim/ut cob/ut xdr/ut net/ut net/bulk_emulation/ut \
+            udb/ut capa/ut mdstore/ut #rpc/ut
+else
+SUBDIR_UT = 
+endif
+SUBDIR_ST = net/st net/bulk_emulation/st
 SUBDIR_UB =
+SUBDIR_BIN = utils
 
-SUBDIR_BIN = console/bin utils
-
-SUBDIRS    = $(SUBDIRS_BASE) $(SUBDIRS_LIBS) colibri $(SUBDIR_IT) \
-	     $(SUBDIR_UT) $(SUBDIR_ST) $(SUBDIR_KERNEL) $(SUBDIR_UB) \
-	     $(SUBDIR_BIN)
+SUBDIRS    = $(SUBDIRS_BASE) $(SUBDIRS_LIBS) colibri $(SUBDIR_KERNEL) \
+             $(SUBDIR_UT) $(SUBDIR_ST) $(SUBDIR_UB) $(SUBDIR_BIN)
 
 etags:
 	find . -name '*.[ch]' | xargs etags
 
-EXTRA_DIST = autogen.sh README NEWS AUTHORS COPYING ChangeLog colibri.spec.in colibri.spec
+EXTRA_DIST = autogen.sh README NEWS AUTHORS COPYING ChangeLog headers.in
 ETAGS_ARGS = automake.in --lang=none \ --regex=’/^@node[ \t]+\([^,]+\)/\1/’ automake.texi
 ACLOCAL_AMFLAGS = -I m4
-
-clean-local:
-	if test "x@ENABLE_COVERAGE@" = "x1"; \
-	then \
-		find . -name "*.gcno" | xargs rm -f; \
-	fi
diff --git a/addb/.gitignore b/addb/.gitignore
index 8cfa3f4..85c2551 100644
--- a/addb/.gitignore
+++ b/addb/.gitignore
@@ -1,2 +1 @@
-addb_k.[ch]
 addb_u.[ch]
diff --git a/addb/Makefile.am b/addb/Makefile.am
index 7f50251..8bfefa4 100644
--- a/addb/Makefile.am
+++ b/addb/Makefile.am
@@ -3,8 +3,8 @@
 # which is only a pseudo framework of addb.
 # after fop is built, we build addb library again with full functionally.
 
-addbdir                     = $(includedir)/colibri/addb
-addb_HEADERS                = addb.h addb_u.h addb_k.h 
+addbdir                     = $(includedir)/addb
+addb_HEADERS                = addb.h
 
 noinst_LTLIBRARIES          = libcolibri-addb.la
 libcolibri_addb_la_SOURCES  = addb_u.h addb_u.c addb.c addb.h addb_console.c \
@@ -14,12 +14,11 @@ INCLUDES                    = -I. -I$(top_srcdir)/include
 
 addb_u.h addb_u.c: addb.ff \
                   $(top_builddir)/fop/fop2c
-	$(top_builddir)/fop/fop2c -uk $<
+	$(top_builddir)/fop/fop2c -u $<
 
 addb.c : addb.h addb_u.h
 
-EXTRA_DIST       = addb.ff linux_kernel/addb_console.c
+EXTRA_DIST       = addb.ff
 
 clean-local:
-	cd @SRCDIR@/addb ; \
 	rm -fr addb_[uk].[hc]
diff --git a/addb/addb.c b/addb/addb.c
index 9520286..5cedfff 100644
--- a/addb/addb.c
+++ b/addb/addb.c
@@ -48,6 +48,7 @@
  * This can be changed.
  */
 enum c2_addb_ev_level c2_addb_level_default = AEL_NOTE;
+C2_EXPORTED(c2_addb_level_default);
 
 /**
    ADDB record store type.
@@ -71,10 +72,12 @@ int c2_addb_init(void)
 {
 	return 0;
 }
+C2_EXPORTED(c2_addb_init);
 
 void c2_addb_fini(void)
 {
 }
+C2_EXPORTED(c2_addb_fini);
 
 /**
    Choose default addb event level, return the original level.
@@ -88,7 +91,6 @@ enum c2_addb_ev_level c2_addb_choose_default_level(enum c2_addb_ev_level level)
 	c2_addb_level_default = level;
 	return orig;
 }
-C2_EXPORTED(c2_addb_choose_default_level);
 
 void c2_addb_ctx_init(struct c2_addb_ctx *ctx, const struct c2_addb_ctx_type *t,
 		      struct c2_addb_ctx *parent)
@@ -96,10 +98,12 @@ void c2_addb_ctx_init(struct c2_addb_ctx *ctx, const struct c2_addb_ctx_type *t,
 	ctx->ac_type = t;
 	ctx->ac_parent = parent;
 }
+C2_EXPORTED(c2_addb_ctx_init);
 
 void c2_addb_ctx_fini(struct c2_addb_ctx *ctx)
 {
 }
+C2_EXPORTED(c2_addb_ctx_fini);
 
 /* defined in {,linux_kernel/}addb_console.c */
 void c2_addb_console(enum c2_addb_ev_level lev, struct c2_addb_dp *dp);
@@ -137,6 +141,7 @@ void c2_addb_add(struct c2_addb_dp *dp)
 		break;
 	}
 }
+C2_EXPORTED(c2_addb_add);
 
 static int subst_name_int(struct c2_addb_dp *dp, const char *name, int rc)
 {
@@ -172,6 +177,7 @@ const struct c2_addb_ev_ops C2_ADDB_SYSCALL = {
 	.aeo_name  = "syscall-failure",
 	.aeo_level = AEL_NOTE
 };
+C2_EXPORTED(C2_ADDB_SYSCALL);
 
 /** get size for data point opaque data */
 extern int c2_addb_func_fail_getsize(struct c2_addb_dp *dp);
@@ -204,6 +210,7 @@ const struct c2_addb_ev_ops C2_ADDB_FUNC_CALL = {
 	.aeo_name    = "function-failure",
 	.aeo_level   = AEL_NOTE
 };
+C2_EXPORTED(C2_ADDB_FUNC_CALL);
 
 const struct c2_addb_ev_ops C2_ADDB_CALL = {
 	.aeo_subst   = (c2_addb_ev_subst_t)subst_int,
@@ -213,6 +220,7 @@ const struct c2_addb_ev_ops C2_ADDB_CALL = {
 	.aeo_name    = "call-failure",
 	.aeo_level   = AEL_NOTE
 };
+C2_EXPORTED(C2_ADDB_CALL);
 
 const struct c2_addb_ev_ops C2_ADDB_STAMP = {
 	.aeo_subst   = (c2_addb_ev_subst_t)subst_void,
@@ -226,6 +234,7 @@ const struct c2_addb_ev_ops C2_ADDB_STAMP = {
 	.aeo_size    = 0,
 	.aeo_name    = "."
 };
+C2_EXPORTED(C2_ADDB_STAMP);
 
 const struct c2_addb_ev_ops C2_ADDB_FLAG = {
 	.aeo_subst   = (c2_addb_ev_subst_t)subst_void,
@@ -234,6 +243,7 @@ const struct c2_addb_ev_ops C2_ADDB_FLAG = {
 	.aeo_size    = sizeof(bool),
 	.aeo_name    = "flag"
 };
+C2_EXPORTED(C2_ADDB_FLAG);
 
 const struct c2_addb_ev_ops C2_ADDB_INVAL = {
 	.aeo_subst   = (c2_addb_ev_subst_t)subst_uint64_t,
@@ -242,27 +252,32 @@ const struct c2_addb_ev_ops C2_ADDB_INVAL = {
 	.aeo_size    = sizeof(uint64_t),
 	.aeo_name    = "inval"
 };
+C2_EXPORTED(C2_ADDB_INVAL);
 
 struct c2_addb_ev c2_addb_oom = {
 	.ae_name = "oom",
 	.ae_id   = 0x3,
 	.ae_ops  = &C2_ADDB_STAMP
 };
+C2_EXPORTED(c2_addb_oom);
 
 struct c2_addb_ev c2_addb_func_fail = {
 	.ae_name = "func-fail",
 	.ae_id   = 0x4,
 	.ae_ops  = &C2_ADDB_FUNC_CALL
 };
+C2_EXPORTED(c2_addb_func_fail);
 
 static const struct c2_addb_ctx_type c2_addb_global_ctx_type = {
 	.act_name = "global"
 };
+C2_EXPORTED(c2_addb_global_ctx_type);
 
 struct c2_addb_ctx c2_addb_global_ctx = {
 	.ac_type   = &c2_addb_global_ctx_type,
 	.ac_parent = NULL
 };
+C2_EXPORTED(c2_addb_global_ctx);
 
 int c2_addb_choose_store_media(enum c2_addb_rec_store_type type, ...)
 {
@@ -308,6 +323,7 @@ int c2_addb_choose_store_media(enum c2_addb_rec_store_type type, ...)
         va_end(varargs);
 	return 0;
 }
+C2_EXPORTED(c2_addb_choose_store_media);
 /** @} end of addb group */
 
 /* 
diff --git a/addb/addb.ff b/addb/addb.ff
index 32f6021..8d99b38 100644
--- a/addb/addb.ff
+++ b/addb/addb.ff
@@ -1,25 +1,5 @@
 /* -*- C -*- */
 
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Huang Hua <hua_huang@xyratex.com>
- * Original creation date: 03/17/2011
- */
-
-
 /* buf in memory */
 DEF(c2_mem_buf, SEQUENCE,
     _(cmb_count, U32),
diff --git a/addb/addb_fop.c b/addb/addb_fop.c
index 889be68..d0b1d2f 100644
--- a/addb/addb_fop.c
+++ b/addb/addb_fop.c
@@ -43,17 +43,22 @@ int c2_addb_handler(struct c2_fop *fop, struct c2_fop_ctx *ctx);
 
 #include "fop/fop_format_def.h"
 #include "addb/addb.ff"
-#include "rpc/rpc_opcodes.h"
+
+
+/*
+C2_EXPORTED(c2_mem_buf_tfmt);
+C2_EXPORTED(c2_addb_record_header_tfmt);
+C2_EXPORTED(c2_addb_record_tfmt);
+C2_EXPORTED(c2_addb_reply_tfmt);
+*/
 
 static struct c2_fop_type_ops addb_ops = {
 	.fto_execute = c2_addb_handler,
 };
 
-C2_FOP_TYPE_DECLARE(c2_addb_record, "addb", &addb_ops,
-		    C2_ADDB_RECORD_REQUEST_OPCODE, C2_RPC_ITEM_TYPE_REQUEST);
+C2_FOP_TYPE_DECLARE(c2_addb_record, "addb",       14, &addb_ops);
+C2_FOP_TYPE_DECLARE(c2_addb_reply,  "addb reply", 24,  NULL);
 
-C2_FOP_TYPE_DECLARE(c2_addb_reply,  "addb reply", NULL, C2_ADDB_REPLY_OPCODE,
-		    C2_RPC_ITEM_TYPE_REPLY);
 /**
    ADDB record body for function fail event.
 
@@ -155,11 +160,14 @@ static int c2_addb_record_header_pack(struct c2_addb_dp *dp,
 				      struct c2_addb_record_header *header,
 				      int size)
 {
+	c2_time_t now;
+
+	c2_time_now(&now);
 	header->arh_magic1    = ADDB_REC_HEADER_MAGIC1;
 	header->arh_version   = ADDB_REC_HEADER_VERSION;
 	header->arh_len       = size;
 	header->arh_event_id  = dp->ad_ev->ae_id;
-	header->arh_timestamp = c2_time_now();
+	header->arh_timestamp = now;
 	header->arh_magic2    = ADDB_REC_HEADER_MAGIC2;
 
 	return 0;
@@ -280,9 +288,9 @@ int c2_addb_empty_pack(struct c2_addb_dp *dp,
 	return c2_addb_record_header_pack(dp, header, rec->ar_data.cmb_count);
 }
 
-extern const struct c2_fop_type_format C2_FOP_TYPE_FORMAT_U32_tfmt;
-extern const struct c2_fop_type_format C2_FOP_TYPE_FORMAT_U64_tfmt;
-extern const struct c2_fop_type_format C2_FOP_TYPE_FORMAT_BYTE_tfmt;
+const struct c2_fop_type_format C2_FOP_TYPE_FORMAT_U32_tfmt;
+const struct c2_fop_type_format C2_FOP_TYPE_FORMAT_U64_tfmt;
+const struct c2_fop_type_format C2_FOP_TYPE_FORMAT_BYTE_tfmt;
 /*
  *  Local variables:
  *  c-indentation-style: "K&R"
diff --git a/addb/addb_pseudo/Makefile.am b/addb/addb_pseudo/Makefile.am
index b974f6a..961d80d 100644
--- a/addb/addb_pseudo/Makefile.am
+++ b/addb/addb_pseudo/Makefile.am
@@ -3,6 +3,9 @@
 # which is only a pseudo framework of addb.
 # after fop is built, we build addb library again with full functionally.
 
+addbdir                     = $(includedir)/addb
+addb_HEADERS                = ../addb.h
+
 noinst_LTLIBRARIES          = libcolibri-addb-pseudo.la
 libcolibri_addb_pseudo_la_SOURCES  = ../addb.c ../addb_console.c addb_pseudo.c
 
diff --git a/addb/addb_store.c b/addb/addb_store.c
index 5fa66f5..ce96179 100644
--- a/addb/addb_store.c
+++ b/addb/addb_store.c
@@ -85,9 +85,9 @@ int c2_addb_stob_add(struct c2_addb_dp *dp, struct c2_dtx *tx,
 
 		c2_stob_io_init(&io);
 
-		io.si_user.ov_vec.v_nr    = 1;
-		io.si_user.ov_vec.v_count = count;
-		io.si_user.ov_buf         = addr;
+		io.si_user.div_vec.ov_vec.v_nr    = 1;
+		io.si_user.div_vec.ov_vec.v_count = count;
+		io.si_user.div_vec.ov_buf         = addr;
 
 		io.si_stob.iv_vec.v_nr    = 1;
 		io.si_stob.iv_vec.v_count = count;
@@ -100,7 +100,7 @@ int c2_addb_stob_add(struct c2_addb_dp *dp, struct c2_dtx *tx,
 			addr[1]   = c2_stob_addr_pack(event_data, bshift);
 			count[1]  = data_len >> bshift;
 			offset[1] = (offset[0] + count[0]) >> bshift;
-			io.si_user.ov_vec.v_nr = 2;
+			io.si_user.div_vec.ov_vec.v_nr = 2;
 			io.si_stob.iv_vec.v_nr = 2;
 		}
 		io.si_opcode = SIO_WRITE;
@@ -198,6 +198,8 @@ int c2_addb_db_add(struct c2_addb_dp *dp, struct c2_dbenv *env,
 }
 
 #endif
+C2_EXPORTED(c2_addb_stob_add);
+C2_EXPORTED(c2_addb_db_add);
 
 int c2_addb_net_add(struct c2_addb_dp *dp, struct c2_net_conn *conn)
 {
@@ -250,6 +252,7 @@ out:
 
 	return result;
 }
+C2_EXPORTED(c2_addb_net_add);
 
 /*
  *  Local variables:
diff --git a/addb/linux_kernel/addb_console.c b/addb/linux_kernel/addb_console.c
index 214e436..e07dacf 100644
--- a/addb/linux_kernel/addb_console.c
+++ b/addb/linux_kernel/addb_console.c
@@ -9,13 +9,13 @@
  * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
  * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
  * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
+
  * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
- *
- * Original author: Nikita Danilov <Nikita_Danilov@xyratex.com>
- * Original creation date: 08/09/2010
+
+ * Original author: $NAME
+ * Original creation date: MM/DD/YYYY
  */
 
 #ifdef HAVE_CONFIG_H
diff --git a/autogen.sh b/autogen.sh
index 9a3dacc..ec3e89b 100755
--- a/autogen.sh
+++ b/autogen.sh
@@ -1 +1 @@
-autoreconf --install --force
+autoreconf --install --force
\ No newline at end of file
diff --git a/balloc/Makefile.am b/balloc/Makefile.am
index 3752af7..0208f26 100644
--- a/balloc/Makefile.am
+++ b/balloc/Makefile.am
@@ -1,4 +1,5 @@
-ballocdir                     = $(includedir)/colibri/balloc
+ballocdir                     = $(includedir)/balloc
 balloc_HEADERS                = balloc.h
+
 noinst_LTLIBRARIES            = libcolibri-balloc.la
 libcolibri_balloc_la_SOURCES  = balloc.c balloc.h
diff --git a/balloc/balloc.c b/balloc/balloc.c
index 1224637..6237cef 100644
--- a/balloc/balloc.c
+++ b/balloc/balloc.c
@@ -24,11 +24,10 @@
 #include <sys/stat.h>
 #include <sys/time.h>
 
-#include "dtm/dtm.h"	  /* c2_dtx */
-#include "lib/misc.h"	  /* C2_SET0 */
+#include "lib/misc.h"   /* C2_SET0 */
 #include "lib/errno.h"
 #include "lib/types.h"
-#include "lib/arith.h"	  /* min_check, c2_is_po2 */
+#include "lib/arith.h"    /* min_check, c2_is_po2 */
 #include "lib/memory.h"
 #include "balloc.h"
 
@@ -45,16 +44,16 @@
 */
 
 #ifdef BALLOC_DEBUG
-#define ENTER fprintf(stderr, "===>>> %s:%d:%s\n", __FILE__, __LINE__, __func__)
-#define LEAVE fprintf(stderr, "<<<=== %s:%d:%s\n", __FILE__, __LINE__, __func__)
-#define GOTHERE fprintf(stderr "!!! %s:%d:%s\n", __FILE__, __LINE__, __func__)
+  #define ENTER fprintf(stderr, "===>>> %s:%d:%s\n", __FILE__, __LINE__, __func__)
+  #define LEAVE fprintf(stderr, "<<<=== %s:%d:%s\n", __FILE__, __LINE__, __func__)
+  #define GOTHERE fprintf(stderr "!!! %s:%d:%s\n", __FILE__, __LINE__, __func__)
 
-  #define debugp(fmt, a...)					\
-	do {							\
-		fprintf(stderr, "(%s, %d): %s: ",		\
-		       __FILE__, __LINE__, __func__);		\
-		fprintf(stderr, fmt, ## a);			\
-	} while (0)
+  #define debugp(fmt, a...)                                     \
+        do {                                                    \
+                fprintf(stderr, "(%s, %d): %s: ",               \
+                       __FILE__, __LINE__, __func__);           \
+                fprintf(stderr, fmt, ## a);                     \
+        } while (0)
 
 #else
   #define ENTER
@@ -66,7 +65,7 @@
 /*
 #define BALLOC_ENABLE_DUMP
 */
-static void balloc_debug_dump_extent(const char *tag, struct c2_ext *ex)
+void c2_balloc_debug_dump_extent(const char *tag, struct c2_ext *ex)
 {
 #ifdef BALLOC_ENABLE_DUMP
 
@@ -83,16 +82,14 @@ static void balloc_debug_dump_extent(const char *tag, struct c2_ext *ex)
 #endif
 }
 
-void c2_balloc_debug_dump_group(const char *tag,
-				struct c2_balloc_group_info *grp)
+void c2_balloc_debug_dump_group(const char *tag, struct c2_balloc_group_info *grp)
 {
 #ifdef BALLOC_ENABLE_DUMP
 	if (grp == NULL)
 		return;
 
 	fprintf(stderr, "dumping group_desc@%p:%s\n"
-	       "|-----groupno=%08llx, freeblocks=%08llx, maxchunk=0x%08llx, "
-		"fragments=0x%08llx\n",
+	       "|-----groupno=%08llx, freeblocks=%08llx, maxchunk=0x%08llx, fragments=0x%08llx\n",
 		grp, tag,
 		(unsigned long long) grp->bgi_groupno,
 		(unsigned long long) grp->bgi_freeblocks,
@@ -101,12 +98,11 @@ void c2_balloc_debug_dump_group(const char *tag,
 #endif
 }
 
-void c2_balloc_debug_dump_group_extent(const char *tag,
-				       struct c2_balloc_group_info *grp)
+void c2_balloc_debug_dump_group_extent(const char *tag, struct c2_balloc_group_info *grp)
 {
 #ifdef BALLOC_ENABLE_DUMP
-	c2_bcount_t	 i;
-	struct c2_ext	*ex;
+	c2_bcount_t i;
+	struct c2_ext *ex;
 
 	if (grp == NULL || grp->bgi_extents == NULL)
 		return;
@@ -145,9 +141,9 @@ void c2_balloc_debug_dump_sb(const char *tag, struct c2_balloc_super_block *sb)
 		(unsigned long long) sb->bsb_totalsize,
 		(unsigned long long) sb->bsb_freeblocks,
 		(unsigned long long) sb->bsb_blocksize,
-		(unsigned long	   ) sb->bsb_bsbits,
+		(unsigned long     ) sb->bsb_bsbits,
 		(unsigned long long) sb->bsb_groupsize,
-		(unsigned long	   ) sb->bsb_gsbits,
+		(unsigned long     ) sb->bsb_gsbits,
 		(unsigned long long) sb->bsb_groupcount,
 		(unsigned long long) sb->bsb_reserved_groups,
 		(unsigned long long) sb->bsb_prealloc_count,
@@ -163,7 +159,7 @@ void c2_balloc_debug_dump_sb(const char *tag, struct c2_balloc_super_block *sb)
 }
 
 static inline c2_bindex_t
-balloc_bn2gn(c2_bindex_t blockno, struct c2_balloc *cb)
+c2_balloc_bn2gn(c2_bindex_t blockno, struct c2_balloc *cb)
 {
 	return blockno >> cb->cb_sb.bsb_gsbits;
 }
@@ -208,11 +204,11 @@ void c2_balloc_unlock_group(struct c2_balloc_group_info *grp)
 /**
    finaliazation of the balloc environment.
  */
-static int balloc_fini_internal(struct c2_balloc *colibri,
-				struct c2_db_tx  *tx)
+static int c2_balloc_fini_internal(struct c2_balloc *colibri,
+				   struct c2_db_tx  *tx)
 {
-	struct c2_balloc_group_info	*gi;
-	int				 i;
+	struct c2_balloc_group_info *gi;
+	int	 i;
 	ENTER;
 
 	if (colibri->cb_group_info) {
@@ -237,8 +233,8 @@ static int balloc_fini_internal(struct c2_balloc *colibri,
 /**
    Comparison function for block number, supplied to database.
  */
-static int balloc_blockno_compare(struct c2_table *t,
-				  const void *k0, const void *k1)
+static int c2_balloc_blockno_compare(struct c2_table *t,
+                                     const void *k0, const void *k1)
 {
 	const c2_bindex_t *bn0;
 	const c2_bindex_t *bn1;
@@ -261,7 +257,7 @@ static const struct c2_table_ops c2_group_extent_ops = {
 		[TO_KEY] = { .max_size = sizeof (c2_bindex_t) },
 		[TO_REC] = { .max_size = sizeof (c2_bindex_t) }
 	},
-	.key_cmp = balloc_blockno_compare,
+	.key_cmp = c2_balloc_blockno_compare,
 };
 
 static const struct c2_table_ops c2_group_desc_ops = {
@@ -282,31 +278,32 @@ static const struct c2_table_ops c2_group_desc_ops = {
    be used by normal allocation routines.
 
    @param req pointer to this format request. All configuration will be passed
-	  by this parameter.
+          by this parameter.
    @return 0 means success. Otherwize, error number will be returned.
  */
-static int balloc_format(struct c2_balloc *colibri,
-			 struct c2_balloc_format_req *req)
+static int c2_balloc_format(struct c2_balloc *colibri,
+			    struct c2_balloc_format_req *req)
 {
-	struct timeval			 now;
-	struct c2_db_pair		 pair;
-	c2_bcount_t			 number_of_groups;
-	c2_bcount_t			 i;
-	int				 sz;
-	int				 rc;
-	struct c2_db_tx			 format_tx;
-	int				 tx_started = 0;
-	struct c2_balloc_group_info	*grp;
-	struct c2_ext			 ext;
-	struct c2_balloc_group_desc	 gd;
-	struct c2_balloc_super_block	*sb	    = &colibri->cb_sb;
+	struct timeval    now;
+	struct c2_db_pair pair;
+	c2_bcount_t       number_of_groups;
+	c2_bcount_t       i;
+	int  		  sz;
+	int            	  rc;
+	struct c2_db_tx   format_tx;
+	int		  tx_started = 0;
+
+	struct c2_balloc_group_info *grp;
+	struct c2_ext                ext;
+	struct c2_balloc_group_desc  gd;
+	struct c2_balloc_super_block *sb = &colibri->cb_sb;
 	ENTER;
 
 	C2_PRE(c2_is_po2(req->bfr_blocksize));
 	C2_PRE(c2_is_po2(req->bfr_groupsize));
 
-	number_of_groups = req->bfr_totalsize / req->bfr_groupsize /
-		req->bfr_blocksize;
+	number_of_groups = req->bfr_totalsize / req->bfr_blocksize /
+			   req->bfr_groupsize;
 
 	if (number_of_groups == 0)
 		number_of_groups = 1;
@@ -314,7 +311,7 @@ static int balloc_format(struct c2_balloc *colibri,
 	debugp("total=%llu, bs=%llu, groupsize=%llu, groups=%llu resvd=%llu\n",
 		(unsigned long long)req->bfr_totalsize,
 		(unsigned long long)req->bfr_blocksize,
-		(unsigned long long)req->bfr_groupsize,
+                (unsigned long long)req->bfr_groupsize,
 		(unsigned long long)number_of_groups,
 		(unsigned long long)req->bfr_reserved_groups);
 
@@ -325,26 +322,26 @@ static int balloc_format(struct c2_balloc *colibri,
 
 	gettimeofday(&now, NULL);
 	/* TODO verification of these parameters */
-	sb->bsb_magic		= C2_BALLOC_SB_MAGIC;
-	sb->bsb_state		= 0;
-	sb->bsb_version		= C2_BALLOC_SB_VERSION;
-	sb->bsb_totalsize	= req->bfr_totalsize;
-	sb->bsb_blocksize	= req->bfr_blocksize;/* should be power of 2*/
-	sb->bsb_groupsize	= req->bfr_groupsize;/* should be power of 2*/
-	sb->bsb_bsbits		= ffs(req->bfr_blocksize) - 1;
-	sb->bsb_gsbits		= ffs(req->bfr_groupsize) - 1;
-	sb->bsb_groupcount	= number_of_groups;
+	sb->bsb_magic = C2_BALLOC_SB_MAGIC;
+	sb->bsb_state = 0;
+	sb->bsb_version = C2_BALLOC_SB_VERSION;
+	sb->bsb_totalsize = req->bfr_totalsize;
+	sb->bsb_blocksize = req->bfr_blocksize; /* should be power of 2*/
+	sb->bsb_groupsize = req->bfr_groupsize; /* should be power of 2*/
+	sb->bsb_bsbits    = ffs(req->bfr_blocksize) - 1;
+	sb->bsb_gsbits    = ffs(req->bfr_groupsize) - 1;
+	sb->bsb_groupcount = number_of_groups;
 	sb->bsb_reserved_groups = req->bfr_reserved_groups;
-	sb->bsb_freeblocks	= (number_of_groups - sb->bsb_reserved_groups)
+	sb->bsb_freeblocks = (number_of_groups - sb->bsb_reserved_groups)
 				<< sb->bsb_gsbits;
-	sb->bsb_prealloc_count	= 16;
-	sb->bsb_format_time	= ((uint64_t)now.tv_sec) << 32 | now.tv_usec;
-	sb->bsb_write_time	= sb->bsb_format_time;
-	sb->bsb_mnt_time	= sb->bsb_format_time;
-	sb->bsb_last_check_time	= sb->bsb_format_time;
-	sb->bsb_mnt_count	= 0;
-	sb->bsb_max_mnt_count	= 1024;
-	sb->bsb_stripe_size	= 0;
+	sb->bsb_prealloc_count  = 16;
+	sb->bsb_format_time = ((uint64_t)now.tv_sec) << 32 | now.tv_usec;
+	sb->bsb_write_time  = sb->bsb_format_time;
+	sb->bsb_mnt_time    = sb->bsb_format_time;
+	sb->bsb_last_check_time  = sb->bsb_format_time;
+	sb->bsb_mnt_count   = 0;
+	sb->bsb_max_mnt_count   = 1024;
+	sb->bsb_stripe_size   = 0;
 
 	c2_db_pair_setup(&pair, &colibri->cb_db_sb,
 			 &sb->bsb_magic, sizeof sb->bsb_magic,
@@ -376,8 +373,7 @@ static int balloc_format(struct c2_balloc *colibri,
 	for (i = 0; i < number_of_groups; i++) {
 		grp = &colibri->cb_group_info[i];
 
-		debugp("creating group_extents for group %llu\n",
-		       (unsigned long long)i);
+		debugp("creating group_extents for group %llu\n", (unsigned long long)i);
 		ext.e_start = i << sb->bsb_gsbits;
 		if (i < req->bfr_reserved_groups) {
 			ext.e_end = ext.e_start;
@@ -399,22 +395,20 @@ static int balloc_format(struct c2_balloc *colibri,
 		c2_db_pair_fini(&pair);
 		if (rc != 0) {
 			fprintf(stderr, "insert extent failed:"
-				"group=%llu, rc=%d\n", (unsigned long long)i,
-				rc);
+				"group=%llu, rc=%d\n", (unsigned long long)i, rc);
 			break;
 		}
 
-		debugp("creating group_desc for group %llu\n",
-		       (unsigned long long)i);
+		debugp("creating  group_desc for group %llu\n", (unsigned long long)i);
 		gd.bgd_groupno = i;
 		if (i < req->bfr_reserved_groups) {
 			gd.bgd_freeblocks = 0;
 			gd.bgd_fragments  = 0;
-			gd.bgd_maxchunk	  = 0;
+			gd.bgd_maxchunk   = 0;
 		} else {
 			gd.bgd_freeblocks = req->bfr_groupsize;
 			gd.bgd_fragments  = 1;
-			gd.bgd_maxchunk	  = req->bfr_groupsize;
+			gd.bgd_maxchunk   = req->bfr_groupsize;
 		}
 		c2_db_pair_setup(&pair, &colibri->cb_db_group_desc,
 				 &gd.bgd_groupno,
@@ -430,8 +424,7 @@ static int balloc_format(struct c2_balloc *colibri,
 		c2_db_pair_fini(&pair);
 		if (rc != 0) {
 			fprintf(stderr, "insert gd failed:"
-				"group=%llu, rc=%d\n", (unsigned long long)i,
-				rc);
+				"group=%llu, rc=%d\n", (unsigned long long)i, rc);
 			break;
 		}
 		if ((i & 0x3ff) == 0) {
@@ -452,11 +445,11 @@ static int balloc_format(struct c2_balloc *colibri,
 	return rc;
 }
 
-static int balloc_read_sb(struct c2_balloc *cb, struct c2_db_tx *tx)
+static int c2_balloc_read_sb(struct c2_balloc *cb, struct c2_db_tx *tx)
 {
-	struct c2_balloc_super_block	*sb = &cb->cb_sb;
-	struct c2_db_pair		 pair;
-	int				 rc;
+	struct c2_balloc_super_block *sb = &cb->cb_sb;
+	struct c2_db_pair pair;
+	int    rc;
 
 	sb->bsb_magic = C2_BALLOC_SB_MAGIC;
 	c2_db_pair_setup(&pair, &cb->cb_db_sb,
@@ -470,12 +463,12 @@ static int balloc_read_sb(struct c2_balloc *cb, struct c2_db_tx *tx)
 	return rc;
 }
 
-static int balloc_sync_sb(struct c2_balloc *cb, struct c2_db_tx *tx)
+static int c2_balloc_sync_sb(struct c2_balloc *cb, struct c2_db_tx *tx)
 {
-	struct c2_balloc_super_block	*sb = &cb->cb_sb;
-	struct c2_db_pair		 pair;
-	struct timeval			 now;
-	int				 rc;
+	struct c2_balloc_super_block *sb = &cb->cb_sb;
+	struct c2_db_pair pair;
+	struct timeval    now;
+	int    rc;
 	ENTER;
 
 	if (!(cb->cb_sb.bsb_state & C2_BALLOC_SB_DIRTY)) {
@@ -500,13 +493,13 @@ static int balloc_sync_sb(struct c2_balloc *cb, struct c2_db_tx *tx)
 	return rc;
 }
 
-static int balloc_sync_group_info(struct c2_balloc *cb,
-				  struct c2_db_tx *tx,
-				  struct c2_balloc_group_info *gi)
+static int c2_balloc_sync_group_info(struct c2_balloc *cb,
+				     struct c2_db_tx *tx,
+				     struct c2_balloc_group_info *gi)
 {
-	struct c2_balloc_group_desc	gd;
-	struct c2_db_pair		pair;
-	int				rc;
+	struct c2_balloc_group_desc gd;
+	struct c2_db_pair pair;
+	int    rc;
 	ENTER;
 
 	if (! (gi->bgi_state & C2_BALLOC_GROUP_INFO_DIRTY)) {
@@ -514,10 +507,10 @@ static int balloc_sync_group_info(struct c2_balloc *cb,
 		return 0;
 	}
 
-	gd.bgd_groupno	  = gi->bgi_groupno;
+	gd.bgd_groupno    = gi->bgi_groupno;
 	gd.bgd_freeblocks = gi->bgi_freeblocks;
 	gd.bgd_fragments  = gi->bgi_fragments;
-	gd.bgd_maxchunk	  = gi->bgi_maxchunk;
+	gd.bgd_maxchunk   = gi->bgi_maxchunk;
 	c2_db_pair_setup(&pair, &cb->cb_db_group_desc,
 			 &gd.bgd_groupno, sizeof gd.bgd_groupno,
 			 &gd, sizeof gd);
@@ -532,16 +525,15 @@ static int balloc_sync_group_info(struct c2_balloc *cb,
 }
 
 
-static int balloc_load_group_info(struct c2_balloc *cb,
-				  struct c2_db_tx *tx,
-				  struct c2_balloc_group_info *gi)
+static int c2_balloc_load_group_info(struct c2_balloc *cb,
+				     struct c2_db_tx *tx,
+				     struct c2_balloc_group_info *gi)
 {
-	struct c2_balloc_group_desc	gd = { 0 };
-	struct c2_db_pair		pair;
-	int				rc;
+	struct c2_balloc_group_desc gd = { 0 };
+	struct c2_db_pair pair;
+	int    rc;
 
-	// debugp("loading group info for = %llu\n",
-	// (unsigned long long)gi->bgi_groupno);
+//	debugp("loading group info for = %llu\n", (unsigned long long)gi->bgi_groupno);
 
 	c2_db_pair_setup(&pair, &cb->cb_db_group_desc,
 			 &gd.bgd_groupno, sizeof gd.bgd_groupno,
@@ -550,12 +542,12 @@ static int balloc_load_group_info(struct c2_balloc *cb,
 	rc = c2_table_lookup(tx, &pair);
 
 	if (rc == 0) {
-		gi->bgi_groupno	   = gd.bgd_groupno;
+		gi->bgi_groupno    = gd.bgd_groupno;
 		gi->bgi_freeblocks = gd.bgd_freeblocks;
 		gi->bgi_fragments  = gd.bgd_fragments;
 		gi->bgi_maxchunk   = gd.bgd_maxchunk;
-		gi->bgi_state	   = C2_BALLOC_GROUP_INFO_INIT;
-		gi->bgi_extents	   = NULL;
+		gi->bgi_state      = C2_BALLOC_GROUP_INFO_INIT;
+		gi->bgi_extents    = NULL;
 		c2_list_init(&gi->bgi_prealloc_list);
 		c2_mutex_init(&gi->bgi_mutex);
 	}
@@ -571,19 +563,16 @@ static int balloc_load_group_info(struct c2_balloc *cb,
  * is used here.
  * The same reason for format().
  */
-static int balloc_init_internal(struct c2_balloc *colibri,
-				struct c2_dbenv  *dbenv,
-				uint32_t bshift,
-				c2_bcount_t container_size,
-				c2_bcount_t blocks_per_group,
-				c2_bcount_t res_groups)
+static int c2_balloc_init_internal(struct c2_balloc *colibri,
+				   struct c2_dbenv  *dbenv,
+				   uint32_t bshift)
 {
-	struct c2_balloc_group_info	*gi;
-	int				 rc;
-	c2_bcount_t			 i;
-	struct c2_db_tx			 init_tx;
-	struct timeval			 now;
-	int				 tx_started = 0;
+	struct c2_balloc_group_info *gi;
+	int            	 rc;
+	c2_bcount_t 	 i;
+	struct c2_db_tx  init_tx;
+	struct timeval    now;
+	int		 tx_started = 0;
 	ENTER;
 
 	colibri->cb_dbenv = dbenv;
@@ -598,7 +587,7 @@ static int balloc_init_internal(struct c2_balloc *colibri,
 			   &c2_super_block_ops) ||
 	     c2_table_init(&colibri->cb_db_group_desc, dbenv,
 			   "group_desc", 0,
-			   &c2_group_desc_ops)	||
+			   &c2_group_desc_ops)  ||
 	     c2_table_init(&colibri->cb_db_group_extents, dbenv,
 			   "group_extents", 0,
 			   &c2_group_extent_ops);
@@ -607,7 +596,7 @@ static int balloc_init_internal(struct c2_balloc *colibri,
 
 	rc = c2_db_tx_init(&init_tx, dbenv, 0);
 	if (rc == 0) {
-		rc = balloc_read_sb(colibri, &init_tx);
+		rc = c2_balloc_read_sb(colibri, &init_tx);
 		c2_db_tx_commit(&init_tx);
 	}
 
@@ -615,14 +604,14 @@ static int balloc_init_internal(struct c2_balloc *colibri,
 		struct c2_balloc_format_req req = { 0 };
 
 		/* let's format this container */
-		req.bfr_totalsize = container_size;
+		req.bfr_totalsize = 4096ULL * 1024 * 1024 * 1000; //=400GB
 		req.bfr_blocksize = 1 << bshift;
-		req.bfr_groupsize = blocks_per_group;
-		req.bfr_reserved_groups = res_groups;
+		req.bfr_groupsize = 4096 * 8; //=128MB = ext4 group size
+		req.bfr_reserved_groups = 2;
 
-		rc = balloc_format(colibri, &req);
+		rc = c2_balloc_format(colibri, &req);
 		if (rc != 0)
-			balloc_fini_internal(colibri, NULL);
+			c2_balloc_fini_internal(colibri, NULL);
 		LEAVE;
 		return rc;
 	} else if (rc != 0)
@@ -631,13 +620,12 @@ static int balloc_init_internal(struct c2_balloc *colibri,
 	/* update the db */
 	++ colibri->cb_sb.bsb_mnt_count;
 	gettimeofday(&now, NULL);
-	colibri->cb_sb.bsb_mnt_time = ((uint64_t)now.tv_sec) << 32 |
-		now.tv_usec;
+	colibri->cb_sb.bsb_mnt_time = ((uint64_t)now.tv_sec) << 32 | now.tv_usec;
 	colibri->cb_sb.bsb_state |= C2_BALLOC_SB_DIRTY;
 
 	rc = c2_db_tx_init(&init_tx, dbenv, 0);
 	if (rc == 0) {
-		rc = balloc_sync_sb(colibri, &init_tx);
+		rc = c2_balloc_sync_sb(colibri, &init_tx);
 		if (rc == 0)
 			rc = c2_db_tx_commit(&init_tx);
 		else
@@ -654,8 +642,7 @@ static int balloc_init_internal(struct c2_balloc *colibri,
 		goto out;
 	}
 
-	i = colibri->cb_sb.bsb_groupcount *
-		sizeof (struct c2_balloc_group_info);
+	i = colibri->cb_sb.bsb_groupcount * sizeof (struct c2_balloc_group_info);
 	colibri->cb_group_info = c2_alloc(i);
 	if (colibri->cb_group_info == NULL) {
 		rc = -ENOMEM;
@@ -673,7 +660,7 @@ static int balloc_init_internal(struct c2_balloc *colibri,
 				break;
 			tx_started = 1;
 		}
-		rc = balloc_load_group_info(colibri, &init_tx, gi);
+		rc = c2_balloc_load_group_info(colibri, &init_tx, gi);
 
 		if ((i & 0x3ff) == 0) {
 			if (rc == 0)
@@ -695,7 +682,7 @@ static int balloc_init_internal(struct c2_balloc *colibri,
 	}
 out:
 	if (rc != 0)
-		balloc_fini_internal(colibri, NULL);
+		c2_balloc_fini_internal(colibri, NULL);
 	LEAVE;
 	return rc;
 }
@@ -707,7 +694,7 @@ enum c2_balloc_allocation_status {
 };
 
 struct c2_balloc_allocation_context {
-	struct c2_balloc	      *bac_ctxt;
+	struct c2_balloc              *bac_ctxt;
 	struct c2_db_tx		      *bac_tx;
 	struct c2_balloc_allocate_req *bac_req;
 	struct c2_ext		       bac_orig; /*< original */
@@ -717,36 +704,36 @@ struct c2_balloc_allocation_context {
 
 	uint64_t		       bac_flags;
 	uint64_t		       bac_criteria;
-	uint32_t		       bac_order2;  /* order of 2 */
-	uint32_t		       bac_scanned; /* groups scanned */
-	uint32_t		       bac_found;   /* count of found */
-	uint32_t		       bac_status;  /* allocation status */
+	uint32_t	               bac_order2;  /* order of 2 */
+	uint32_t	               bac_scanned; /* groups scanned */
+	uint32_t	               bac_found;   /* count of found */
+	uint32_t	               bac_status;  /* allocation status */
 };
 
-static int balloc_init_ac(struct c2_balloc_allocation_context *bac,
-			  struct c2_balloc *colibri,
-			  struct c2_db_tx * tx,
-			  struct c2_balloc_allocate_req *req)
+static int c2_balloc_init_ac(struct c2_balloc_allocation_context *bac,
+			     struct c2_balloc *colibri,
+			     struct c2_db_tx * tx,
+			     struct c2_balloc_allocate_req *req)
 {
 	ENTER;
 
 	C2_SET0(&req->bar_result);
 
-	bac->bac_ctxt	  = colibri;
-	bac->bac_tx	  = tx;
-	bac->bac_req	  = req;
-	bac->bac_order2	  = 0;
-	bac->bac_scanned  = 0;
-	bac->bac_found	  = 0;
-	bac->bac_flags	  = req->bar_flags;
-	bac->bac_status	  = C2_BALLOC_AC_CONTINUE;
+	bac->bac_ctxt = colibri;
+	bac->bac_tx   = tx;
+	bac->bac_req  = req;
+	bac->bac_order2  = 0;
+	bac->bac_scanned = 0;
+	bac->bac_found   = 0;
+	bac->bac_flags   = req->bar_flags;
+	bac->bac_status  = C2_BALLOC_AC_CONTINUE;
 	bac->bac_criteria = 0;
 
 	if (req->bar_goal == 0)
 		req->bar_goal = colibri->cb_last.e_end;
 
-	bac->bac_orig.e_start	= req->bar_goal;
-	bac->bac_orig.e_end	= req->bar_goal + req->bar_len;
+	bac->bac_orig.e_start   = req->bar_goal;
+	bac->bac_orig.e_end     = req->bar_goal + req->bar_len;
 	bac->bac_goal = bac->bac_orig;
 
 	C2_SET0(&bac->bac_best);
@@ -757,13 +744,13 @@ static int balloc_init_ac(struct c2_balloc_allocation_context *bac,
 }
 
 
-static int balloc_use_prealloc(struct c2_balloc_allocation_context *bac)
+static int c2_balloc_use_prealloc(struct c2_balloc_allocation_context *bac)
 {
 	return 0;
 }
 
-static int balloc_claim_free_blocks(struct c2_balloc *colibri,
-				    c2_bcount_t blocks)
+static int c2_balloc_claim_free_blocks(struct c2_balloc *colibri,
+				       c2_bcount_t blocks)
 {
 	int rc;
 	ENTER;
@@ -783,7 +770,7 @@ static int balloc_claim_free_blocks(struct c2_balloc *colibri,
  * here we normalize request for locality group
  */
 static void
-balloc_normalize_group_request(struct c2_balloc_allocation_context *bac)
+c2_balloc_normalize_group_request(struct c2_balloc_allocation_context *bac)
 {
 }
 
@@ -792,7 +779,7 @@ balloc_normalize_group_request(struct c2_balloc_allocation_context *bac)
  * size and alignment
  */
 static void
-balloc_normalize_request(struct c2_balloc_allocation_context *bac)
+c2_balloc_normalize_request(struct c2_balloc_allocation_context *bac)
 {
 	c2_bcount_t size = c2_ext_length(&bac->bac_orig);
 	ENTER;
@@ -812,7 +799,7 @@ balloc_normalize_request(struct c2_balloc_allocation_context *bac)
 		return;
 
 	if (bac->bac_flags & C2_BALLOC_HINT_GROUP_ALLOC) {
-		balloc_normalize_group_request(bac);
+		c2_balloc_normalize_group_request(bac);
 		return;
 	}
 
@@ -845,10 +832,7 @@ balloc_normalize_request(struct c2_balloc_allocation_context *bac)
 	if (size > bac->bac_ctxt->cb_sb.bsb_groupsize)
 		size = bac->bac_ctxt->cb_sb.bsb_groupsize;
 
-	/*
-          Now prepare new goal. Extra space we get will be consumed and
-          reserved by preallocation.
-        */
+	/* now prepare goal request */
 	bac->bac_goal.e_end = bac->bac_goal.e_start + size;
 
 	debugp("goal: start=%llu=(0x%08llx), size=%llu(was %llu)\n",
@@ -864,15 +848,15 @@ int c2_balloc_load_extents(struct c2_balloc *cb,
 			   struct c2_balloc_group_info *grp,
 			   struct c2_db_tx *tx)
 {
-	struct c2_table		*db_ext	  = &cb->cb_db_group_extents;
-	struct c2_db_cursor	 cursor;
-	struct c2_db_pair	 pair;
-	struct c2_ext		*ex;
-	struct c2_ext		 start;
-	int			 result	  = 0;
-	int			 size;
-	c2_bcount_t		 maxchunk = 0;
-	c2_bcount_t		 count	  = 0;
+	struct c2_table    *db_ext = &cb->cb_db_group_extents;
+	struct c2_db_cursor cursor;
+	struct c2_db_pair   pair;
+	struct c2_ext      *ex;
+	struct c2_ext       start;
+	int result = 0;
+	int size;
+        c2_bcount_t maxchunk = 0;
+	c2_bcount_t count = 0;
 
 	C2_ASSERT(c2_mutex_is_locked(&grp->bgi_mutex));
 	if (grp->bgi_extents != NULL) {
@@ -920,7 +904,7 @@ int c2_balloc_load_extents(struct c2_balloc *cb,
 
 		if (c2_ext_length(ex) > maxchunk)
 			maxchunk = c2_ext_length(ex);
-		//balloc_debug_dump_extent("loading...", ex);
+//		c2_balloc_debug_dump_extent("loading...", ex);
 
 		count++;
 	}
@@ -936,21 +920,21 @@ int c2_balloc_load_extents(struct c2_balloc *cb,
 	if (grp->bgi_maxchunk != maxchunk) {
 		grp->bgi_state |= C2_BALLOC_GROUP_INFO_DIRTY;
 		grp->bgi_maxchunk = maxchunk;
-		balloc_sync_group_info(cb, tx, grp);
+		c2_balloc_sync_group_info(cb, tx, grp);
 	}
 
 	return result;
 }
 
 /* called under group lock */
-static int balloc_find_extent_exact(struct c2_balloc_allocation_context *bac,
-				    struct c2_balloc_group_info *grp,
-				    struct c2_ext *goal,
-				    struct c2_ext *ex)
+static int c2_balloc_find_extent_exact(struct c2_balloc_allocation_context *bac,
+				       struct c2_balloc_group_info *grp,
+				       struct c2_ext *goal,
+				       struct c2_ext *ex)
 {
-	c2_bcount_t	 i;
-	int	 	 found = 0;
-	struct c2_ext	*fragment;
+	c2_bcount_t i;
+	c2_bcount_t found = 0;
+	struct c2_ext *fragment;
 
 	C2_ASSERT(c2_mutex_is_locked(&grp->bgi_mutex));
 
@@ -960,7 +944,7 @@ static int balloc_find_extent_exact(struct c2_balloc_allocation_context *bac,
 		if (c2_ext_is_partof(fragment, goal)) {
 			found = 1;
 			*ex = *fragment;
-			balloc_debug_dump_extent(__func__, ex);
+			c2_balloc_debug_dump_extent(__func__, ex);
 			break;
 		}
 		if (fragment->e_start > goal->e_start)
@@ -971,22 +955,21 @@ static int balloc_find_extent_exact(struct c2_balloc_allocation_context *bac,
 }
 
 /* called under group lock */
-static int balloc_find_extent_buddy(struct c2_balloc_allocation_context *bac,
-				    struct c2_balloc_group_info *grp,
-				    c2_bcount_t len,
-				    struct c2_ext *ex)
+static int c2_balloc_find_extent_buddy(struct c2_balloc_allocation_context *bac,
+				       struct c2_balloc_group_info *grp,
+				       c2_bcount_t len,
+				       struct c2_ext *ex)
 {
-	struct c2_balloc_super_block	*sb    = &bac->bac_ctxt->cb_sb;
-	c2_bcount_t			 i;
-	c2_bcount_t			 found = 0;
-	c2_bindex_t			 start;
-	struct c2_ext			*fragment;
-	struct c2_ext			min = {
-						.e_start = 0,
-						.e_end = 0xffffffff };
+	struct c2_balloc_super_block *sb = &bac->bac_ctxt->cb_sb;
+	c2_bcount_t i;
+	c2_bcount_t found = 0;
+	c2_bindex_t start;
+	struct c2_ext *fragment;
+	struct c2_ext min = {
+			.e_start = 0,
+			.e_end = 0xffffffff };
 
 	C2_ASSERT(c2_mutex_is_locked(&grp->bgi_mutex));
-
 	start = grp->bgi_groupno << sb->bsb_gsbits;
 
 	for (i = 0; i < grp->bgi_fragments; i++) {
@@ -996,15 +979,14 @@ repeat:
 		{
 			char msg[128];
 			sprintf(msg, "buddy[s=%llu:0x%08llx, l=%u:0x%08x]",
-			(unsigned long long)start,
-			(unsigned long long)start,
-			(int)len, (int)len);
+				(unsigned long long)start,
+				(unsigned long long)start,
+				(int)len, (int)len);
 			(void)msg;
-			balloc_debug_dump_extent(msg, fragment);
-			}
+			c2_balloc_debug_dump_extent(msg, fragment);
+		}
 		*/
-		if ((fragment->e_start == start) &&
-		       (c2_ext_length(fragment) >= len)) {
+		if ((fragment->e_start == start) && (c2_ext_length(fragment) >= len)) {
 			found = 1;
 			if (c2_ext_length(fragment) < c2_ext_length(&min))
 				min = *fragment;
@@ -1027,7 +1009,7 @@ repeat:
 }
 
 
-static int balloc_use_best_found(struct c2_balloc_allocation_context *bac)
+static int c2_balloc_use_best_found(struct c2_balloc_allocation_context *bac)
 {
 	bac->bac_final.e_start = bac->bac_best.e_start;
 	bac->bac_final.e_end   = bac->bac_final.e_start +
@@ -1038,39 +1020,34 @@ static int balloc_use_best_found(struct c2_balloc_allocation_context *bac)
 	return 0;
 }
 
-static int balloc_new_preallocation(struct c2_balloc_allocation_context *bac)
+static int c2_balloc_new_preallocation(struct c2_balloc_allocation_context *bac)
 {
-	/* XXX No Preallocation now. So, trim the result to the original length. */
-
-	bac->bac_final.e_end = bac->bac_final.e_start +
-					min_check(c2_ext_length(&bac->bac_orig),
-					          c2_ext_length(&bac->bac_final));
 	return 0;
 }
 
 enum c2_balloc_update_operation {
 	C2_BALLOC_ALLOC = 1,
-	C2_BALLOC_FREE	= 2,
+	C2_BALLOC_FREE  = 2,
 };
 
 
 /* the group is under lock now */
-static int balloc_update_db(struct c2_balloc *colibri,
-			    struct c2_db_tx *tx,
-			    struct c2_balloc_group_info *grp,
-			    struct c2_ext *tgt,
-			    enum c2_balloc_update_operation op)
+static int c2_balloc_update_db(struct c2_balloc *colibri,
+			       struct c2_db_tx *tx,
+			       struct c2_balloc_group_info *grp,
+			       struct c2_ext *tgt,
+			       enum c2_balloc_update_operation op)
 {
-	size_t			 keysize = sizeof (tgt->e_start);
-	size_t			 recsize = sizeof (tgt->e_end);
-	struct c2_table		*db	 = &colibri->cb_db_group_extents;
-	c2_bcount_t		 i;
-	struct c2_db_pair	 pair;
-	int			 rc	 = 0;
+	size_t keysize = sizeof (tgt->e_start);
+	size_t recsize = sizeof (tgt->e_end);
+	struct c2_table *db = &colibri->cb_db_group_extents;
+	c2_bcount_t i;
+	struct c2_db_pair pair;
+	int rc = 0;
 	ENTER;
 
 	C2_ASSERT(c2_mutex_is_locked(&grp->bgi_mutex));
-	balloc_debug_dump_extent("target=", tgt);
+	c2_balloc_debug_dump_extent("target=", tgt);
 	if (op == C2_BALLOC_ALLOC) {
 		struct c2_ext *cur = NULL;
 
@@ -1083,7 +1060,7 @@ static int balloc_update_db(struct c2_balloc *colibri,
 
 		C2_ASSERT(i < grp->bgi_fragments);
 
-		balloc_debug_dump_extent("current=", cur);
+		c2_balloc_debug_dump_extent("current=", cur);
 
 		if (cur->e_start == tgt->e_start) {
 			c2_db_pair_setup(&pair, db,
@@ -1152,9 +1129,9 @@ static int balloc_update_db(struct c2_balloc *colibri,
 		grp->bgi_state |= C2_BALLOC_GROUP_INFO_DIRTY;
 		colibri->cb_sb.bsb_state |= C2_BALLOC_SB_DIRTY;
 
-		rc = balloc_sync_sb(colibri, tx);
+		rc = c2_balloc_sync_sb(colibri, tx);
 		if (rc == 0)
-			rc = balloc_sync_group_info(colibri, tx, grp);
+			rc = c2_balloc_sync_group_info(colibri, tx, grp);
 
 		LEAVE;
 	} else if (op == C2_BALLOC_FREE) {
@@ -1171,19 +1148,17 @@ static int balloc_update_db(struct c2_balloc *colibri,
 			}
 			pre = cur;
 		}
-		balloc_debug_dump_extent("prev=", pre);
-		balloc_debug_dump_extent("current=", cur);
+		c2_balloc_debug_dump_extent("prev=", pre);
+		c2_balloc_debug_dump_extent("current=", cur);
 
 		if (found && cur && tgt->e_end > cur->e_start) {
 			fprintf(stderr, "!!!!!!!!!!!!!double free\n");
-			c2_balloc_debug_dump_group_extent(
-				    "double free with cur", grp);
+			c2_balloc_debug_dump_group_extent("double free with cur", grp);
 			return -EINVAL;
 		}
 		if (pre && pre->e_end > tgt->e_start) {
 			fprintf(stderr, "!!!!!!!!!!!!!double free\n");
-			c2_balloc_debug_dump_group_extent(
-				    "double free with pre", grp);
+			c2_balloc_debug_dump_group_extent("double free with pre", grp);
 			return -EINVAL;
 		}
 
@@ -1269,7 +1244,7 @@ static int balloc_update_db(struct c2_balloc *colibri,
 			}
 		} else {
 			/* in the middle */
-			if (pre->e_end	 == tgt->e_start &&
+			if (pre->e_end   == tgt->e_start &&
 			    tgt->e_end == cur->e_start) {
 				/* joint to both */
 
@@ -1355,9 +1330,9 @@ static int balloc_update_db(struct c2_balloc *colibri,
 		grp->bgi_state |= C2_BALLOC_GROUP_INFO_DIRTY;
 		colibri->cb_sb.bsb_state |= C2_BALLOC_SB_DIRTY;
 
-		rc = balloc_sync_sb(colibri, tx);
+		rc = c2_balloc_sync_sb(colibri, tx);
 		if (rc == 0)
-			rc = balloc_sync_group_info(colibri, tx, grp);
+			rc = c2_balloc_sync_group_info(colibri, tx, grp);
 
 		LEAVE;
 	} else {
@@ -1367,17 +1342,15 @@ static int balloc_update_db(struct c2_balloc *colibri,
 	return rc;
 }
 
-static int balloc_find_by_goal(struct c2_balloc_allocation_context *bac)
+static int c2_balloc_find_by_goal(struct c2_balloc_allocation_context *bac)
 {
-	c2_bindex_t group = balloc_bn2gn(bac->bac_goal.e_start,
-					 bac->bac_ctxt);
-	struct c2_balloc_group_info *grp = c2_balloc_gn2info(bac->bac_ctxt,
-							     group);
-
-	struct c2_db_tx *tx  = bac->bac_tx;
-	struct c2_ext	 ex  = { 0 };
-	int		 found;
-	int		 ret = 0;
+	c2_bindex_t group = c2_balloc_bn2gn(bac->bac_goal.e_start, bac->bac_ctxt);
+	struct c2_balloc_group_info *grp = c2_balloc_gn2info(bac->bac_ctxt, group);
+
+	struct c2_db_tx *tx = bac->bac_tx;
+	struct c2_ext ex = { 0 };
+	int found;
+	int ret = 0;
 	ENTER;
 
 	if (!(bac->bac_flags & C2_BALLOC_HINT_TRY_GOAL))
@@ -1388,7 +1361,7 @@ static int balloc_find_by_goal(struct c2_balloc_allocation_context *bac)
 		(unsigned long long)bac->bac_goal.e_start,
 		(unsigned long long)c2_ext_length(&bac->bac_goal),
 		(unsigned long long)bac->bac_ctxt->cb_sb.bsb_groupsize
-	);
+        );
 
 	c2_balloc_lock_group(grp);
 	if (grp->bgi_maxchunk < c2_ext_length(&bac->bac_goal)) {
@@ -1406,23 +1379,22 @@ static int balloc_find_by_goal(struct c2_balloc_allocation_context *bac)
 		goto out_unlock;
 	}
 
-	found = balloc_find_extent_exact(bac, grp, &bac->bac_goal, &ex);
-	debugp("found?max len = %llu\n",
-	       (unsigned long long)c2_ext_length(&ex));
+	found = c2_balloc_find_extent_exact(bac, grp, &bac->bac_goal, &ex);
+	debugp("found?max len = %llu\n", (unsigned long long)c2_ext_length(&ex));
 
 	if (found) {
 		bac->bac_found++;
 		bac->bac_best.e_start = bac->bac_goal.e_start;
 		bac->bac_best.e_end   = ex.e_end;
-		ret = balloc_use_best_found(bac);
+		ret = c2_balloc_use_best_found(bac);
 	}
 
 	/* update db according to the allocation result */
 	if (ret == 0 && bac->bac_status == C2_BALLOC_AC_FOUND) {
 		if (bac->bac_goal.e_end < bac->bac_best.e_end)
-			balloc_new_preallocation(bac);
+			c2_balloc_new_preallocation(bac);
 
-		ret = balloc_update_db(bac->bac_ctxt, tx, grp,
+		ret = c2_balloc_update_db(bac->bac_ctxt, tx, grp,
 					  &bac->bac_final, C2_BALLOC_ALLOC);
 	}
 
@@ -1435,11 +1407,11 @@ out:
 }
 
 /* group is locked */
-static int balloc_good_group(struct c2_balloc_allocation_context *bac,
-			     struct c2_balloc_group_info *gi)
+static int c2_balloc_good_group(struct c2_balloc_allocation_context *bac,
+			        struct c2_balloc_group_info *gi)
 {
-	c2_bcount_t	free	  = gi->bgi_freeblocks;
-	c2_bcount_t	fragments = gi->bgi_fragments;
+	c2_bcount_t free = gi->bgi_freeblocks;
+	c2_bcount_t fragments = gi->bgi_fragments;
 
 	if (free == 0)
 		return 0;
@@ -1467,15 +1439,15 @@ static int balloc_good_group(struct c2_balloc_allocation_context *bac,
 }
 
 /* group is locked */
-static int balloc_simple_scan_group(struct c2_balloc_allocation_context *bac,
-				    struct c2_balloc_group_info *grp)
+static int c2_balloc_simple_scan_group(struct c2_balloc_allocation_context *bac,
+				       struct c2_balloc_group_info *grp)
 {
 /*
 	struct c2_balloc_super_block *sb = &bac->bac_ctxt->cb_sb;
 */
-	struct c2_ext	ex;
-	c2_bcount_t	len;
-	int		found = 0;
+	struct c2_ext ex;
+	c2_bcount_t len;
+	int found = 0;
 	ENTER;
 
 	C2_ASSERT(bac->bac_order2 > 0);
@@ -1489,28 +1461,27 @@ static int balloc_simple_scan_group(struct c2_balloc_allocation_context *bac,
 			(int)len,
 			(int)len);
 
-		found = balloc_find_extent_buddy(bac, grp, len, &ex);
+		found = c2_balloc_find_extent_buddy(bac, grp, len, &ex);
 		if (found)
 			break;
 	}
 */
 
-	found = balloc_find_extent_buddy(bac, grp, len, &ex);
+	found = c2_balloc_find_extent_buddy(bac, grp, len, &ex);
 	if (found) {
-		balloc_debug_dump_extent("found at simple scan", &ex);
+		c2_balloc_debug_dump_extent("found at simple scan", &ex);
 
 		bac->bac_found++;
 		bac->bac_best = ex;
-		balloc_use_best_found(bac);
+		c2_balloc_use_best_found(bac);
 	}
 
 	LEAVE;
 	return 0;
 }
 
-__attribute__((unused))
-static int balloc_aligned_scan_group(struct c2_balloc_allocation_context *bac,
-				     struct c2_balloc_group_info *grp)
+int c2_balloc_aligned_scan_group(struct c2_balloc_allocation_context *bac,
+				 struct c2_balloc_group_info *grp)
 {
 	return 0;
 }
@@ -1518,12 +1489,12 @@ static int balloc_aligned_scan_group(struct c2_balloc_allocation_context *bac,
 /*
  * How long balloc can look for a best extent (in found extents)
  */
-#define C2_BALLOC_DEFAULT_MAX_TO_SCAN	       200
+#define C2_BALLOC_DEFAULT_MAX_TO_SCAN          200
 
 /*
  * How long balloc must look for a best extent
  */
-#define C2_BALLOC_DEFAULT_MIN_TO_SCAN	       10
+#define C2_BALLOC_DEFAULT_MIN_TO_SCAN          10
 
 /*
  * How many groups balloc will scan looking for the best chunk
@@ -1531,12 +1502,12 @@ static int balloc_aligned_scan_group(struct c2_balloc_allocation_context *bac,
 #define C2_BALLOC_DEFAULT_MAX_GROUPS_TO_SCAN   5
 
 
-static int balloc_check_limits(struct c2_balloc_allocation_context *bac,
-			       struct c2_balloc_group_info *grp,
-			       int end_of_group)
+int c2_balloc_check_limits(struct c2_balloc_allocation_context *bac,
+			   struct c2_balloc_group_info *grp,
+			   int end_of_group)
 {
 	int max_to_scan = C2_BALLOC_DEFAULT_MAX_TO_SCAN;
-	int max_groups	= C2_BALLOC_DEFAULT_MAX_GROUPS_TO_SCAN;
+	int max_groups  = C2_BALLOC_DEFAULT_MAX_GROUPS_TO_SCAN;
 	int min_to_scan = C2_BALLOC_DEFAULT_MIN_TO_SCAN;
 	ENTER;
 
@@ -1557,31 +1528,30 @@ static int balloc_check_limits(struct c2_balloc_allocation_context *bac,
 		return 0;
 
 	if ((end_of_group || bac->bac_found >= min_to_scan)) {
-		c2_bindex_t group = balloc_bn2gn(bac->bac_best.e_start,
-						    bac->bac_ctxt);
+		c2_bindex_t group = c2_balloc_bn2gn(bac->bac_best.e_start, bac->bac_ctxt);
 		if (group == grp->bgi_groupno)
-			balloc_use_best_found(bac);
+			c2_balloc_use_best_found(bac);
 	}
 
 	return 0;
 }
 
-static int balloc_measure_extent(struct c2_balloc_allocation_context *bac,
-				 struct c2_balloc_group_info *grp,
-				 struct c2_ext *ex)
+static int c2_balloc_measure_extent(struct c2_balloc_allocation_context *bac,
+				    struct c2_balloc_group_info *grp,
+				    struct c2_ext *ex)
 {
 	struct c2_ext *goal = &bac->bac_goal;
 	struct c2_ext *best = &bac->bac_best;
 	int rc;
 	ENTER;
 
-	balloc_debug_dump_extent(__func__, ex);
+	c2_balloc_debug_dump_extent(__func__, ex);
 	bac->bac_found++;
 
 	if ((bac->bac_flags & C2_BALLOC_HINT_FIRST) ||
 	     c2_ext_length(ex) == c2_ext_length(goal)) {
 		*best = *ex;
-		balloc_use_best_found(bac);
+		c2_balloc_use_best_found(bac);
 		LEAVE;
 		return 0;
 	}
@@ -1605,7 +1575,7 @@ static int balloc_measure_extent(struct c2_balloc_allocation_context *bac,
 		}
 	}
 
-	rc = balloc_check_limits(bac, grp, 0);
+	rc = c2_balloc_check_limits(bac, grp, 0);
 	LEAVE;
 	return rc;
 }
@@ -1614,20 +1584,19 @@ static int balloc_measure_extent(struct c2_balloc_allocation_context *bac,
  * This function scans the specified group for a goal. If maximal
  * group is locked.
  */
-static int balloc_wild_scan_group(struct c2_balloc_allocation_context *bac,
-				  struct c2_balloc_group_info *grp)
+static int c2_balloc_wild_scan_group(struct c2_balloc_allocation_context *bac,
+				     struct c2_balloc_group_info *grp)
 {
-	c2_bcount_t	 i;
-	c2_bcount_t	 free;
-	struct c2_ext	*ex;
-	int		 rc;
+	c2_bcount_t i;
+	c2_bcount_t free;
+	struct c2_ext *ex;
+	int rc;
 	ENTER;
 
-	free = grp->bgi_freeblocks;
+	debugp("Wild scanning at group %llu\n",
+		(unsigned long long)grp->bgi_groupno);
 
-	debugp("Wild scanning at group %llu: freeblocks = %llu\n",
-		(unsigned long long)grp->bgi_groupno,
-		(unsigned long long)free);
+	free = grp->bgi_freeblocks;
 
 	for (i = 0; i < grp->bgi_fragments; i++) {
 		ex = &grp->bgi_extents[i];
@@ -1640,7 +1609,7 @@ static int balloc_wild_scan_group(struct c2_balloc_allocation_context *bac,
 			LEAVE;
 			return -EINVAL;
 		}
-		balloc_measure_extent(bac, grp, ex);
+		c2_balloc_measure_extent(bac, grp, ex);
 
 		free -= c2_ext_length(ex);
 		if (free == 0 || bac->bac_status != C2_BALLOC_AC_CONTINUE) {
@@ -1649,7 +1618,7 @@ static int balloc_wild_scan_group(struct c2_balloc_allocation_context *bac,
 		}
 	}
 
-	rc = balloc_check_limits(bac, grp, 1);
+	rc = c2_balloc_check_limits(bac, grp, 1);
 	LEAVE;
 	return rc;
 }
@@ -1659,16 +1628,14 @@ static int balloc_wild_scan_group(struct c2_balloc_allocation_context *bac,
  * The best result may be already used by others who are more lukcy.
  * Group lock should be taken again.
  */
-static int balloc_try_best_found(struct c2_balloc_allocation_context *bac)
+static int c2_balloc_try_best_found(struct c2_balloc_allocation_context *bac)
 {
-	struct c2_ext			*best  = &bac->bac_best;
-	c2_bindex_t			 group = balloc_bn2gn(best->e_start,
-								 bac->bac_ctxt);
-	struct c2_balloc_group_info	*grp   =c2_balloc_gn2info(bac->bac_ctxt,
-								  group);
-	struct c2_ext			*ex;
-	c2_bcount_t			 i;
-	int				 rc    = -ENOENT;
+	struct c2_ext *best = &bac->bac_best;
+	c2_bindex_t    group = c2_balloc_bn2gn(best->e_start, bac->bac_ctxt);
+	struct c2_balloc_group_info *grp = c2_balloc_gn2info(bac->bac_ctxt, group);
+	struct c2_ext *ex;
+	c2_bcount_t    i;
+	int rc = -ENOENT;
 	ENTER;
 
 	c2_balloc_lock_group(grp);
@@ -1684,7 +1651,7 @@ static int balloc_try_best_found(struct c2_balloc_allocation_context *bac)
 	for (i = 0; i < grp->bgi_fragments; i++) {
 		ex = &grp->bgi_extents[i];
 		if (c2_ext_equal(ex, best)) {
-			rc = balloc_use_best_found(bac);
+			rc = c2_balloc_use_best_found(bac);
 			break;
 		} else if (ex->e_start > best->e_start)
 			goto out_release;
@@ -1693,10 +1660,10 @@ static int balloc_try_best_found(struct c2_balloc_allocation_context *bac)
 	/* update db according to the allocation result */
 	if (rc == 0 && bac->bac_status == C2_BALLOC_AC_FOUND) {
 		if (c2_ext_length(&bac->bac_goal) < c2_ext_length(best))
-			balloc_new_preallocation(bac);
+			c2_balloc_new_preallocation(bac);
 
-		balloc_debug_dump_extent(__func__, &bac->bac_final);
-		rc = balloc_update_db(bac->bac_ctxt, bac->bac_tx, grp,
+		c2_balloc_debug_dump_extent(__func__, &bac->bac_final);
+		rc = c2_balloc_update_db(bac->bac_ctxt, bac->bac_tx, grp,
 					 &bac->bac_final,
 					 C2_BALLOC_ALLOC);
 	}
@@ -1709,18 +1676,18 @@ out:
 }
 
 static int
-balloc_regular_allocator(struct c2_balloc_allocation_context *bac)
+c2_balloc_regular_allocator(struct c2_balloc_allocation_context *bac)
 {
-	c2_bcount_t	ngroups, group, i, len;
-	int		cr;
-	int		rc = 0;
+	c2_bcount_t ngroups, group, i, len;
+	int cr;
+	int rc = 0;
 	ENTER;
 
 	ngroups = bac->bac_ctxt->cb_sb.bsb_groupcount;
 	len = c2_ext_length(&bac->bac_goal);
 
 	/* first, try the goal */
-	rc = balloc_find_by_goal(bac);
+	rc = c2_balloc_find_by_goal(bac);
 	if (rc != 0 || bac->bac_status == C2_BALLOC_AC_FOUND ||
 	    (bac->bac_flags & C2_BALLOC_HINT_GOAL_ONLY)) {
 		LEAVE;
@@ -1732,7 +1699,7 @@ balloc_regular_allocator(struct c2_balloc_allocation_context *bac)
 	bac->bac_order2 = 0;
 	/*
 	 * We search using buddy data only if the order of the request
-	 * is greater than equal to the threshold.
+	 * is greater than equal to the threshould.
 	 */
 	if (i >= 2) {
 		/*
@@ -1740,12 +1707,11 @@ balloc_regular_allocator(struct c2_balloc_allocation_context *bac)
 		 */
 		if ((len & (~(1 << (i - 1)))) == 0)
 			bac->bac_order2 = i - 1;
-	}
+        }
 
 	cr = bac->bac_order2 ? 0 : 1;
 	/*
 	 * cr == 0 try to get exact allocation,
-	 * cr == 1 striped allocation. Not implemented currently.
 	 * cr == 2 try to get anything
 	 */
 repeat:
@@ -1755,7 +1721,7 @@ repeat:
 		 * searching for the right group start
 		 * from the goal value specified
 		 */
-		group = balloc_bn2gn(bac->bac_goal.e_start, bac->bac_ctxt);
+		group = c2_balloc_bn2gn(bac->bac_goal.e_start, bac->bac_ctxt);
 
 		for (i = 0; i < ngroups; group++, i++) {
 			struct c2_balloc_group_info *grp;
@@ -1764,8 +1730,7 @@ repeat:
 				group = 0;
 
 			grp = c2_balloc_gn2info(bac->bac_ctxt, group);
-			// c2_balloc_debug_dump_group("searching group ...\n",
-			//			 grp);
+//			c2_balloc_debug_dump_group("searching group ...\n", grp);
 
 			rc = c2_balloc_trylock_group(grp);
 			if (rc != 0) {
@@ -1779,36 +1744,34 @@ repeat:
 				continue;
 			}
 
-			rc = c2_balloc_load_extents(bac->bac_ctxt, grp,
-						    bac->bac_tx);
+			rc = c2_balloc_load_extents(bac->bac_ctxt, grp, bac->bac_tx);
 			if (rc != 0) {
 				c2_balloc_unlock_group(grp);
 				goto out;
 			}
 
-			if (!balloc_good_group(bac, grp)) {
+			if (!c2_balloc_good_group(bac, grp)) {
 				c2_balloc_release_extents(grp);
 				c2_balloc_unlock_group(grp);
 				continue;
 			}
 			bac->bac_scanned++;
 
-			c2_balloc_debug_dump_group_extent("AAAAAAAAAAAAAAAAAA",
-							  grp);
+			c2_balloc_debug_dump_group_extent("AAAAAAAAAAAAAAAAAAAAAAAAAAA", grp);
 			if (cr == 0)
-				rc = balloc_simple_scan_group(bac, grp);
+				rc = c2_balloc_simple_scan_group(bac, grp);
 			else if (cr == 1 &&
-				len == bac->bac_ctxt->cb_sb.bsb_stripe_size)
-				rc = balloc_simple_scan_group(bac, grp);
+					len == bac->bac_ctxt->cb_sb.bsb_stripe_size)
+				rc = c2_balloc_simple_scan_group(bac, grp);
 			else
-				rc = balloc_wild_scan_group(bac, grp);
+				rc = c2_balloc_wild_scan_group(bac, grp);
 
 			/* update db according to the allocation result */
 			if (rc == 0 && bac->bac_status == C2_BALLOC_AC_FOUND) {
 				if (len < c2_ext_length(&bac->bac_best))
-					balloc_new_preallocation(bac);
+					c2_balloc_new_preallocation(bac);
 
-				rc = balloc_update_db(bac->bac_ctxt,
+				rc = c2_balloc_update_db(bac->bac_ctxt,
 							 bac->bac_tx, grp,
 							 &bac->bac_final,
 							 C2_BALLOC_ALLOC);
@@ -1831,7 +1794,7 @@ repeat:
 		 * the best chunk we've found so far
 		 */
 
-		rc = balloc_try_best_found(bac);
+		rc = c2_balloc_try_best_found(bac);
 		if (rc || bac->bac_status != C2_BALLOC_AC_FOUND) {
 			/*
 			 * Someone more lucky has already allocated it.
@@ -1852,6 +1815,8 @@ out:
 	return rc;
 }
 
+
+
 /**
    Allocate multiple blocks for some object.
 
@@ -1872,7 +1837,7 @@ out:
 
    While searching free space from group to group, the free space extent will be
    loaded into cache.  We cache as much free space extent up to some
-   specified memory limitation.	 This is a configurable parameter, or default
+   specified memory limitation.  This is a configurable parameter, or default
    value will be choosed based on system memory.
 
    @param ctxt balloc operation context environment.
@@ -1881,36 +1846,36 @@ out:
 	   Result allocated blocks are again stored in "req":
 	   result physical block number = bar_physical,
 	   result count of blocks = bar_len.
-	   Upon failure, non-zero error number is returned.
+           Upon failure, non-zero error number is returned.
  */
 static
-int balloc_allocate_internal(struct c2_balloc *colibri,
-			     struct c2_db_tx *tx,
-			     struct c2_balloc_allocate_req *req)
+int c2_balloc_allocate_internal(struct c2_balloc *colibri,
+				struct c2_db_tx *tx,
+				struct c2_balloc_allocate_req *req)
 {
-	struct c2_balloc_allocation_context	bac;
-	int					rc;
+	struct c2_balloc_allocation_context bac;
+	int rc;
 	ENTER;
 
 	while (req->bar_len &&
-	       !balloc_claim_free_blocks(colibri, req->bar_len)) {
+	       !c2_balloc_claim_free_blocks(colibri, req->bar_len)) {
 		req->bar_len = req->bar_len >> 1;
 	}
-	if (req->bar_len == 0) {
+	if (!req->bar_len) {
 		rc = -ENOSPC;
 		goto out;
 	}
 
-	balloc_init_ac(&bac, colibri, tx, req);
+	c2_balloc_init_ac(&bac, colibri, tx, req);
 
 	/* Step 1. query the pre-allocation */
-	if (!balloc_use_prealloc(&bac)) {
+	if (!c2_balloc_use_prealloc(&bac)) {
 		/* we did not find suitable free space in prealloc. */
 
-		balloc_normalize_request(&bac);
+		c2_balloc_normalize_request(&bac);
 
 		/* Step 2. Iterate over groups */
-		rc = balloc_regular_allocator(&bac);
+		rc = c2_balloc_regular_allocator(&bac);
 		if (rc == 0 && bac.bac_status == C2_BALLOC_AC_FOUND) {
 			/* store the result in req and they will be returned */
 			req->bar_result = bac.bac_final;
@@ -1928,36 +1893,36 @@ out:
    @param req block free request which includes all parameters.
    @return 0 means success. Upon failure, non-zero error number is returned.
  */
-static int balloc_free_internal(struct c2_balloc *colibri,
-				struct c2_db_tx *tx,
-				struct c2_balloc_free_req *req)
+static int c2_balloc_free_internal(struct c2_balloc *colibri,
+				   struct c2_db_tx *tx,
+				   struct c2_balloc_free_req *req)
 {
-	struct c2_ext			 fex;
-	struct c2_balloc_group_info	*grp;
-	struct c2_balloc_super_block	*sb = &colibri->cb_sb;
-	c2_bcount_t			 group;
-	c2_bindex_t			 start, off;
-	c2_bcount_t			 len, step;
-	int				 rc = 0;
+	struct c2_ext fex;
+	struct c2_balloc_group_info *grp;
+	struct c2_balloc_super_block *sb = &colibri->cb_sb;
+	c2_bcount_t group;
+	c2_bindex_t start, off;
+	c2_bcount_t len, step;
+	int rc = 0;
 	ENTER;
 
 	start = req->bfr_physical;
 	len = req->bfr_len;
 
-	group = balloc_bn2gn(start + len, colibri);
+	group = c2_balloc_bn2gn(start + len, colibri);
 	debugp("start=0x%llx, len=0x%llx, start_group=%llu, "
 		"end_group=%llu, group count=%llu\n",
 		(unsigned long long)start,
 		(unsigned long long)len,
-		(unsigned long long)balloc_bn2gn(start, colibri),
-		(unsigned long long)balloc_bn2gn(start + len, colibri),
+		(unsigned long long)c2_balloc_bn2gn(start, colibri),
+		(unsigned long long)c2_balloc_bn2gn(start + len, colibri),
 		(unsigned long long)sb->bsb_groupcount
 		);
 	if (group > sb->bsb_groupcount)
 		return -EINVAL;
 
 	while (rc == 0 && len > 0) {
-		group = balloc_bn2gn(start, colibri);
+		group = c2_balloc_bn2gn(start, colibri);
 
 		grp = c2_balloc_gn2info(colibri, group);
 		c2_balloc_lock_group(grp);
@@ -1968,15 +1933,14 @@ static int balloc_free_internal(struct c2_balloc *colibri,
 			goto out;
 		}
 
-		c2_balloc_debug_dump_group_extent(
-			    "FFFFFFFFFFFFFFFFFFFFFFFFFFFF", grp);
+		c2_balloc_debug_dump_group_extent("FFFFFFFFFFFFFFFFFFFFFFFFFFFF", grp);
 		off = start & (sb->bsb_groupsize - 1);
 		step = (off + len > sb->bsb_groupsize) ?
 			sb->bsb_groupsize  - off : len;
 
 		fex.e_start = start;
 		fex.e_end   = start + step;
-		rc = balloc_update_db(colibri, tx, grp,
+		rc = c2_balloc_update_db(colibri, tx, grp,
 					 &fex, C2_BALLOC_FREE);
 		c2_balloc_release_extents(grp);
 		c2_balloc_unlock_group(grp);
@@ -1996,9 +1960,8 @@ out:
    @param req discard request which includes all parameters.
    @return 0 means success. Upon failure, non-zero error number is returned.
  */
-__attribute__((unused))
-static int balloc_discard_prealloc(struct c2_balloc *colibri,
-				   struct c2_balloc_discard_req *req)
+int c2_balloc_discard_prealloc(struct c2_balloc *colibri,
+			       struct c2_balloc_discard_req *req)
 {
 	return 0;
 }
@@ -2011,13 +1974,12 @@ static int balloc_discard_prealloc(struct c2_balloc *colibri,
 
    @param ctxt balloc operation context environment.
    @param alloc true to make the specifed extent as allocated, otherwise make
-	  the extent as free.
+          the extent as free.
    @param ext user supplied extent to check.
    @return 0 means success. Upon failure, non-zero error number is returned.
  */
-__attribute__((unused))
-static int balloc_enforce(struct c2_balloc *colibri, bool alloc,
-			  struct c2_ext *ex)
+int c2_balloc_enforce(struct c2_balloc *colibri, bool alloc,
+		      struct c2_ext *ex)
 {
 	return 0;
 }
@@ -2030,8 +1992,7 @@ static int balloc_enforce(struct c2_balloc *colibri, bool alloc,
    @param ext user supplied extent to check.
    @return true if the extent is fully allocated. Otherwise, false is returned.
  */
-__attribute__((unused))
-static bool balloc_query(struct c2_balloc *colibri, struct c2_ext *ex)
+bool c2_balloc_query(struct c2_balloc *colibri, struct c2_ext *ex)
 {
 
 	return false;
@@ -2042,22 +2003,22 @@ static bool balloc_query(struct c2_balloc *colibri, struct c2_ext *ex)
  * @param count count of bytes. count will be first aligned to block boundry.
  * @param out result is stored there. space is still in bytes.
  */
-int c2_balloc_alloc(struct ad_balloc *ballroom, struct c2_dtx *tx,
-		    c2_bcount_t count, struct c2_ext *out)
+static int c2_balloc_alloc(struct ad_balloc *ballroom, struct c2_dtx *tx,
+			   c2_bcount_t count, struct c2_ext *out)
 {
-	struct c2_balloc		*colibri = b2c2(ballroom);
-	struct c2_balloc_allocate_req	 req;
-	int				 rc;
+	struct c2_balloc *colibri = b2c2(ballroom);
+	struct c2_balloc_allocate_req req;
+	int rc;
 
 	C2_ASSERT(count > 0);
 
 	req.bar_goal  = out->e_start; /* this also plays as the goal */
 	req.bar_len   = count;
-	req.bar_flags = 0;/*C2_BALLOC_HINT_DATA | C2_BALLOC_HINT_TRY_GOAL;*/
+	req.bar_flags = C2_BALLOC_HINT_DATA ;//| C2_BALLOC_HINT_TRY_GOAL;
 
 	C2_SET0(out);
 
-	rc = balloc_allocate_internal(colibri, &tx->tx_dbtx, &req);
+	rc = c2_balloc_allocate_internal(colibri, &tx->tx_dbtx, &req);
 	if (rc == 0 && !c2_ext_is_empty(&req.bar_result)) {
 		out->e_start = req.bar_result.e_start;
 		out->e_end   = req.bar_result.e_end;
@@ -2072,47 +2033,45 @@ int c2_balloc_alloc(struct ad_balloc *ballroom, struct c2_dtx *tx,
  * free spaces to container.
  * @param ext the space to be freed. This space must align to block boundry.
  */
-int c2_balloc_free(struct ad_balloc *ballroom, struct c2_dtx *tx,
-		   struct c2_ext *ext)
+static int c2_balloc_free(struct ad_balloc *ballroom, struct c2_dtx *tx,
+			  struct c2_ext *ext)
 {
-	struct c2_balloc		*colibri = b2c2(ballroom);
-	struct c2_balloc_free_req	 req;
-	int				 rc;
+	struct c2_balloc *colibri = b2c2(ballroom);
+	struct c2_balloc_free_req req;
+	int rc;
 
 	req.bfr_physical = ext->e_start;
-	req.bfr_len	 = c2_ext_length(ext);
+	req.bfr_len      = c2_ext_length(ext);
 
-	rc = balloc_free_internal(colibri, &tx->tx_dbtx, &req);
+	rc = c2_balloc_free_internal(colibri, &tx->tx_dbtx, &req);
 	return rc;
 }
 
-int c2_balloc_init(struct ad_balloc *ballroom, struct c2_dbenv *db,
-		   uint32_t bshift, c2_bcount_t container_size,
-		   c2_bcount_t blocks_per_group, c2_bcount_t res_groups)
+static int c2_balloc_init(struct ad_balloc *ballroom, struct c2_dbenv *db,
+			  uint32_t bshift)
 {
-	struct c2_balloc	*colibri;
-	int			 rc;
+	struct c2_balloc *colibri;
+	int rc;
 	ENTER;
 
 	colibri = b2c2(ballroom);
 
-	rc = balloc_init_internal(colibri, db, bshift, container_size,
-				     blocks_per_group, res_groups);
+	rc = c2_balloc_init_internal(colibri, db, bshift);
 
 	LEAVE;
 	return rc;
 }
 
-void c2_balloc_fini(struct ad_balloc *ballroom)
+static void c2_balloc_fini(struct ad_balloc *ballroom)
 {
-	struct c2_balloc	*colibri = b2c2(ballroom);
-	struct c2_db_tx		 fini_tx;
-	int			 rc;
+	struct c2_balloc *colibri = b2c2(ballroom);
+	struct c2_db_tx  fini_tx;
+	int rc;
 	ENTER;
 
 	rc = c2_db_tx_init(&fini_tx, colibri->cb_dbenv, 0);
 	if (rc == 0) {
-		rc = balloc_fini_internal(colibri, &fini_tx);
+		rc = c2_balloc_fini_internal(colibri, &fini_tx);
 		if (rc == 0)
 			rc = c2_db_tx_commit(&fini_tx);
 		else
diff --git a/balloc/balloc.h b/balloc/balloc.h
index d1f378d..4a7116b 100644
--- a/balloc/balloc.h
+++ b/balloc/balloc.h
@@ -37,6 +37,8 @@
    @{
 */
 
+#define MAXPATHLEN 1024
+
 /**
    On-disk data structure for group, stored in db.
 
@@ -63,11 +65,11 @@ struct c2_balloc_group_info {
         struct c2_mutex bgi_mutex;      /*< per-group lock */
 
 	struct c2_ext   *bgi_extents;   /*< (bgi_fragments+1) of extents */
-
-        /**
+	
+        /** 
 	   Nr of free power-of-two-block regions, index is order.
            bb_counters[3] = 5 means 5 free 8-block regions.
-	   c2_bcount_t     bgi_counters[];
+        c2_bcount_t     bgi_counters[];
         */
 };
 
@@ -109,7 +111,7 @@ struct c2_balloc_super_block {
         c2_bcount_t	bsb_stripe_size;   /*< stripe size in blocks */
 };
 
-enum c2_balloc_super_block_magic {
+enum c2_balloc_super_block_magic { 
 	C2_BALLOC_SB_MAGIC =  0xC011B21AC08EC08EULL,
 };
 
@@ -136,7 +138,7 @@ struct c2_balloc {
 	struct c2_table  cb_db_group_extents;/*< db for free extent */
 	struct c2_table  cb_db_group_desc;   /*< db for group desc */
 	struct c2_balloc_group_info *cb_group_info; /*< array of group info */
-
+	
 	struct c2_ext    cb_last;
 
 	struct ad_balloc cb_ballroom;
@@ -151,10 +153,10 @@ static inline struct c2_balloc *b2c2(struct ad_balloc *ballroom)
    Request to format a container.
  */
 struct c2_balloc_format_req {
-	c2_bcount_t 	bfr_totalsize;	      /*< total size in bytes  */
-	c2_bcount_t	bfr_blocksize;        /*< block size in bytes  */
-	c2_bcount_t	bfr_groupsize;        /*< group size in blocks */
-	c2_bcount_t	bfr_reserved_groups;  /*< # of reserved groups */
+	c2_bindex_t 	bfr_totalsize;	      /*< total size in bytes */
+	c2_bcount_t	bfr_blocksize;        /*< block size in bytes */
+	c2_bcount_t	bfr_groupsize;        /*< block size in blocks */
+	c2_bcount_t	bfr_reserved_groups;  /*< # of resvered groups */
 };
 
 struct c2_balloc_free_extent {
@@ -172,14 +174,13 @@ struct c2_balloc_free_extent {
    the maximum available chunk size is returned in bar_max_avail.
  */
 struct c2_balloc_allocate_req {
-	c2_bindex_t	bar_logical; /*< [in]logical offset within the object */
-	c2_bcount_t	bar_len;     /*< [in]count of blocks, */
-	c2_bindex_t	bar_goal;    /*< [in]prefered physical block number */
-	uint64_t	bar_flags;   /*< [in]allocation flags from
-				      * c2_balloc_allocation_flag */
-        struct c2_ext   bar_result;  /*< [out]physical offset, result */
-
-	void           *bar_prealloc;/*< [in][out]User opaque prealloc result */
+	c2_bindex_t	bar_logical;   /*< [in]logical offset within the object */
+	c2_bcount_t	bar_len;       /*< [in]count of blocks, */
+	c2_bindex_t	bar_goal;      /*< [in]prefered physical block number */
+	uint64_t	bar_flags;     /*< [in]allocation flags from c2_balloc_allocation_flag */
+        struct c2_ext   bar_result;    /*< [out]physical offset, result */
+
+	void           *bar_prealloc;  /*< [in][out]User opaque prealloc result */
 };
 
 enum c2_balloc_allocation_flag {
@@ -235,38 +236,27 @@ struct c2_balloc_discard_req {
 	void           *bdr_prealloc; /*< User opaque prealloc result */
 };
 
-/*
- * BALLOC_DEF_BLOCKS_PER_GROUP * 1 << BALLOC_DEF_BLOCK_SHIFT = 128 MB -->
- * which equals group size in ext4
- */
-
-enum {
-	BALLOC_DEF_CONTAINER_SIZE	= 4096ULL * 1024 * 1024 * 1000,
-	BALLOC_DEF_BLOCK_SHIFT		= 12,// 4K Blocks
-	BALLOC_DEF_BLOCKS_PER_GROUP     = 32768,
-	BALLOC_DEF_RESERVED_GROUPS	= 2
-};
 
 extern struct c2_balloc colibri_balloc;
 
+
+
 /* Interfaces for UT */
-extern void c2_balloc_debug_dump_sb(const char *tag,
-				    struct c2_balloc_super_block *sb);
-extern void c2_balloc_debug_dump_group_extent(const char *tag,
-					      struct c2_balloc_group_info *grp);
+extern void c2_balloc_debug_dump_sb(const char *tag, struct c2_balloc_super_block *sb);
+extern void c2_balloc_debug_dump_group_extent(const char *tag, struct c2_balloc_group_info *grp);
 
 extern int c2_balloc_release_extents(struct c2_balloc_group_info *grp);
 extern int c2_balloc_load_extents(struct c2_balloc *cb,
-				  struct c2_balloc_group_info *grp,
-				  struct c2_db_tx *tx);
+			   struct c2_balloc_group_info *grp,
+			   struct c2_db_tx *tx);
 extern struct c2_balloc_group_info * c2_balloc_gn2info(struct c2_balloc *cb,
 						       c2_bindex_t groupno);
-extern void c2_balloc_debug_dump_group(const char *tag,
-				       struct c2_balloc_group_info *grp);
+extern void c2_balloc_debug_dump_group(const char *tag, struct c2_balloc_group_info *grp);
 extern void c2_balloc_lock_group(struct c2_balloc_group_info *grp);
 extern int c2_balloc_trylock_group(struct c2_balloc_group_info *grp);
 extern void c2_balloc_unlock_group(struct c2_balloc_group_info *grp);
 
+
 /** @} end of balloc */
 
 #endif /*__COLIBRI_BALLOC_BALLOC_H__*/
diff --git a/balloc/ut/Makefile.am b/balloc/ut/Makefile.am
index 3d9a4b0..c80a6c9 100644
--- a/balloc/ut/Makefile.am
+++ b/balloc/ut/Makefile.am
@@ -1,35 +1,33 @@
-UT_SRCDIR=@SRCDIR@/balloc/ut
+noinst_PROGRAMS  = balloc dump_super_block free dump_free_extent dump_group_desc format perf mperf
 
-noinst_LTLIBRARIES		= libballoc-ut.la
-libballoc_ut_la_SOURCES		= balloc.c
+format_SOURCES   = format.c
+format_LDFLAGS   =
+format_LDADD     = $(top_builddir)/colibri/libcolibri.la
 
-noinst_PROGRAMS			= dump_super_block free dump_free_extent \
-				  dump_group_desc format perf mperf
+balloc_SOURCES   = balloc.c
+balloc_LDFLAGS   =
+balloc_LDADD     = $(top_builddir)/colibri/libcolibri.la
 
-format_SOURCES			= format.c
-format_LDFLAGS			=
-format_LDADD			= $(top_builddir)/colibri/libcolibri.la
+free_SOURCES     = free.c
+free_LDFLAGS     =
+free_LDADD       = $(top_builddir)/colibri/libcolibri.la
 
-free_SOURCES			= free.c
-free_LDFLAGS			=
-free_LDADD			= $(top_builddir)/colibri/libcolibri.la
+dump_free_extent_SOURCES   = dump_free_extent.c
+dump_free_extent_LDFLAGS   =
+dump_free_extent_LDADD     = $(top_builddir)/colibri/libcolibri.la
 
-dump_free_extent_SOURCES	= dump_free_extent.c
-dump_free_extent_LDFLAGS	=
-dump_free_extent_LDADD		= $(top_builddir)/colibri/libcolibri.la
+dump_group_desc_SOURCES    = dump_group_desc.c
+dump_group_desc_LDFLAGS    =
+dump_group_desc_LDADD      = $(top_builddir)/colibri/libcolibri.la
 
-dump_group_desc_SOURCES		= dump_group_desc.c
-dump_group_desc_LDFLAGS		=
-dump_group_desc_LDADD		= $(top_builddir)/colibri/libcolibri.la
+dump_super_block_SOURCES   = dump_super_block.c
+dump_super_block_LDFLAGS   =
+dump_super_block_LDADD     = $(top_builddir)/colibri/libcolibri.la
 
-dump_super_block_SOURCES	= dump_super_block.c
-dump_super_block_LDFLAGS	=
-dump_super_block_LDADD		= $(top_builddir)/colibri/libcolibri.la
+perf_SOURCES   = perf.c
+perf_LDFLAGS   =
+perf_LDADD     = $(top_builddir)/colibri/libcolibri.la
 
-perf_SOURCES			= perf.c
-perf_LDFLAGS			=
-perf_LDADD			= $(top_builddir)/colibri/libcolibri.la
-
-mperf_SOURCES			= mperf.c
-mperf_LDFLAGS			=
-mperf_LDADD			= $(top_builddir)/colibri/libcolibri.la
+mperf_SOURCES  = mperf.c
+mperf_LDFLAGS  =
+mperf_LDADD    = $(top_builddir)/colibri/libcolibri.la
diff --git a/balloc/ut/balloc.c b/balloc/ut/balloc.c
index b687ffc..00417b6 100644
--- a/balloc/ut/balloc.c
+++ b/balloc/ut/balloc.c
@@ -21,281 +21,145 @@
 #include <stdio.h>        /* fprintf */
 #include <stdlib.h>       /* srand, rand */
 #include <errno.h>
-#include <sys/time.h>
 #include <err.h>
 
-#include "dtm/dtm.h"      /* c2_dtx */
 #include "lib/arith.h"    /* C2_3WAY, c2_uint128 */
 #include "lib/misc.h"     /* C2_SET0 */
 #include "lib/assert.h"
-#include "lib/memory.h"
-#include "lib/thread.h"
-#include "lib/getopts.h"
 #include "db/db.h"
-#include "lib/ut.h"
 #include "balloc/balloc.h"
 
-#define BALLOC_DBNAME "./__balloc_db"
+extern	struct c2_balloc colibri_balloc;
+const int MAX = 100;
 
-#define GROUP_SIZE (BALLOC_DEF_CONTAINER_SIZE / (BALLOC_DEF_BLOCKS_PER_GROUP * \
-						 (1 << BALLOC_DEF_BLOCK_SHIFT)))
-
-extern	struct c2_balloc	 colibri_balloc;
-static const char		*db_name = BALLOC_DBNAME;
-static const int		 MAX	 = 100;
-static c2_bcount_t		 prev_free_blocks;
-c2_bcount_t			*prev_group_info_free_blocks;
-
-enum balloc_invariant_enum {
-	INVAR_ALLOC,
-	INVAR_FREE
-};
-
-bool balloc_ut_invariant(struct c2_ext	alloc_ext,
-			 int		balloc_invariant_flag)
+int main(int argc, char **argv)
 {
-	c2_bcount_t	len = c2_ext_length(&alloc_ext),
-			group;
-
-	group = alloc_ext.e_start >> colibri_balloc.cb_sb.bsb_gsbits;
-
-	if (colibri_balloc.cb_sb.bsb_magic != C2_BALLOC_SB_MAGIC)
-		return false;
-
-	switch (balloc_invariant_flag) {
-	    case INVAR_ALLOC:
-		 prev_free_blocks		    -= len;
-		 prev_group_info_free_blocks[group] -= len;
-		 break;
-	    case INVAR_FREE:
-		 prev_free_blocks		    += len;
-		 prev_group_info_free_blocks[group] += len;
-		 break;
-	    default:
-		 return false;
+	const char           *db_name;
+	struct c2_dbenv       db;
+	struct c2_dtx         dtx;
+	int                   result;
+	struct c2_ext         ext[MAX];
+	struct c2_ext         tmp = { 0 };
+	c2_bcount_t	      count = 539;
+	int		      i = 0;
+	time_t		      now;
+
+	if (argc != 2) {
+		fprintf(stderr, "Usage: %s <db-dir>\n", argv[0]);
+		return 1;
 	}
-
-	return colibri_balloc.cb_group_info[group].bgi_freeblocks ==
-		prev_group_info_free_blocks[group] &&
-		colibri_balloc.cb_sb.bsb_freeblocks ==
-		prev_free_blocks;
-}
-
-int test_balloc_ut_ops()
-{
-	struct c2_dbenv	db;
-	struct c2_dtx	dtx;
-	int		result;
-	struct c2_ext	ext[MAX];
-	struct c2_ext	tmp   = { 0 };
-	c2_bcount_t	count = 539;
-	int		i     = 0;
-	time_t		now;
+	db_name = argv[1];
+	memset(ext, 0, ARRAY_SIZE(ext));
 
 	time(&now);
 	srand(now);
 
 	result = c2_dbenv_init(&db, db_name, 0);
-	C2_UT_ASSERT(result == 0);
+	C2_ASSERT(result == 0);
 
 	result = colibri_balloc.cb_ballroom.ab_ops->bo_init
-		(&colibri_balloc.cb_ballroom, &db, BALLOC_DEF_BLOCK_SHIFT,
-		 BALLOC_DEF_CONTAINER_SIZE, BALLOC_DEF_BLOCKS_PER_GROUP,
-		 BALLOC_DEF_RESERVED_GROUPS);
-
-	if(result == 0) {
-
-		prev_free_blocks = colibri_balloc.cb_sb.bsb_freeblocks;
-
-		C2_ALLOC_ARR(prev_group_info_free_blocks, GROUP_SIZE);
-
-		for(i=0; i<GROUP_SIZE; i++)
-		{
-			prev_group_info_free_blocks[i] =
-				colibri_balloc.cb_group_info[i].bgi_freeblocks;
-		}
-
-		for (i = 0; i < MAX; i++ ) {
-			do  {
-				count = rand() % 1500;
-			} while (count == 0);
-
-			result = c2_db_tx_init(&dtx.tx_dbtx, &db, 0);
-			C2_UT_ASSERT(result == 0);
-
-			/* pass last result as goal. comment out this to turn
-			   off goal */
-			//tmp.e_start = tmp.e_end;
-			result = colibri_balloc.cb_ballroom.ab_ops->bo_alloc(
-				    &colibri_balloc.cb_ballroom, &dtx, count,
-				    &tmp);
-			if(result < 0) {
-				fprintf(stderr, "Error in allocation\n");
-				return result;
-			}
-
-			ext[i] = tmp;
+		(&colibri_balloc.cb_ballroom, &db, 12);
+	
+	for (i = 0; i < MAX && result == 0; i++ ) {
+		do  {
+			count = rand() % 1500;
+		} while (count == 0);
+
+		result = c2_db_tx_init(&dtx.tx_dbtx, &db, 0);
+		C2_ASSERT(result == 0);
+
+		/* pass last result as goal. comment out this to turn off goal */
+		//tmp.e_start = tmp.e_end;
+		result = colibri_balloc.cb_ballroom.ab_ops->bo_alloc(&colibri_balloc.cb_ballroom, &dtx, count, &tmp);
+		ext[i] = tmp;
+
+		printf("%3d:rc = %d: requested count=%5d, result count=%5d: [%08llx,%08llx)=[%8llu,%8llu)\n",
+			i, result, (int)count,
+			(int)c2_ext_length(&ext[i]),
+			(unsigned long long)ext[i].e_start,
+			(unsigned long long)ext[i].e_end,
+			(unsigned long long)ext[i].e_start,
+			(unsigned long long)ext[i].e_end);
+		if (result == 0)
+			c2_db_tx_commit(&dtx.tx_dbtx);
+		else
+			c2_db_tx_abort(&dtx.tx_dbtx);
+	}
 
-			/* The result extent length should be less than
-			 * or equal to the requested length. */
-			if(c2_ext_length(&ext[i]) > count) {
-				fprintf(stderr, "Allocation size mismatch: "
-					"requested count = %5d, result = %5d\n",
-					(int)count,
-					(int)c2_ext_length(&ext[i]));
-				result = -EINVAL;
-			}
+	for (i = colibri_balloc.cb_sb.bsb_reserved_groups;
+	     i < colibri_balloc.cb_sb.bsb_groupcount && result == 0; i++ ) {
+		struct c2_balloc_group_info *grp = c2_balloc_gn2info(&colibri_balloc, i);
 
-			C2_UT_ASSERT(balloc_ut_invariant(ext[i], INVAR_ALLOC));
-#ifdef BALLOC_DEBUG
-			printf("%3d:rc = %d: requested count=%5d, result"
-			       " count=%5d: [%08llx,%08llx)=[%8llu,%8llu)\n",
-			       i, result, (int)count,
-			       (int)c2_ext_length(&ext[i]),
-			       (unsigned long long)ext[i].e_start,
-			       (unsigned long long)ext[i].e_end,
-			       (unsigned long long)ext[i].e_start,
-			       (unsigned long long)ext[i].e_end);
-#endif
+		result = c2_db_tx_init(&dtx.tx_dbtx, &db, 0);
+		C2_ASSERT(result == 0);
+		if (grp) {
+			c2_balloc_lock_group(grp);
+			result = c2_balloc_load_extents(&colibri_balloc, grp, &dtx.tx_dbtx);
 			if (result == 0)
-				c2_db_tx_commit(&dtx.tx_dbtx);
-			else
-				c2_db_tx_abort(&dtx.tx_dbtx);
+				c2_balloc_debug_dump_group_extent(argv[0], grp);
+			c2_balloc_release_extents(grp);
+			c2_balloc_unlock_group(grp);
 		}
+		c2_db_tx_commit(&dtx.tx_dbtx);
+	}
 
-		for (i = colibri_balloc.cb_sb.bsb_reserved_groups;
-		     i < colibri_balloc.cb_sb.bsb_groupcount && result == 0;
-		     i++) {
-			struct c2_balloc_group_info *grp = c2_balloc_gn2info
-				(&colibri_balloc, i);
+	/* randonmize the array */
+	for (i = 0; i < MAX; i++ ) {
+		int a, b;
+		a = rand() % MAX;
+		b = rand() % MAX;
+		C2_SWAP(ext[a], ext[b]);
+	}
 
-			result = c2_db_tx_init(&dtx.tx_dbtx, &db, 0);
-			C2_UT_ASSERT(result == 0);
-			if (grp) {
-				c2_balloc_lock_group(grp);
-				result = c2_balloc_load_extents(&colibri_balloc,
-							     grp,
-							     &dtx.tx_dbtx);
-				if (result == 0)
-					c2_balloc_debug_dump_group_extent(
-						    "balloc ut", grp);
-				c2_balloc_release_extents(grp);
-				c2_balloc_unlock_group(grp);
-			}
-			c2_db_tx_commit(&dtx.tx_dbtx);
-		}
+	for (i = 0; i < MAX && result == 0; i++ ) {
 
-		/* randomize the array */
-		for (i = 0; i < MAX; i++ ) {
-			int a, b;
-			a = rand() % MAX;
-			b = rand() % MAX;
-			C2_SWAP(ext[a], ext[b]);
-		}
+		result = c2_db_tx_init(&dtx.tx_dbtx, &db, 0);
+		C2_ASSERT(result == 0);
+		if (ext[i].e_start != 0)
+			result = colibri_balloc.cb_ballroom.ab_ops->bo_free(&colibri_balloc.cb_ballroom, &dtx, &ext[i]);
 
-		for (i = 0; i < MAX && result == 0; i++ ) {
+		printf("%3d:rc = %d: freed:                          len=%5d: [%08llx,%08llx)=[%8llu,%8llu)\n",
+			i, result, (int)c2_ext_length(&ext[i]),
+			(unsigned long long)ext[i].e_start,
+			(unsigned long long)ext[i].e_end,
+			(unsigned long long)ext[i].e_start,
+			(unsigned long long)ext[i].e_end);
+		if (result == 0)
+			c2_db_tx_commit(&dtx.tx_dbtx);
+		else
+			c2_db_tx_abort(&dtx.tx_dbtx);
+	}
 
-			result = c2_db_tx_init(&dtx.tx_dbtx, &db, 0);
-			C2_UT_ASSERT(result == 0);
-			if (ext[i].e_start != 0)
-				result =
-				colibri_balloc.cb_ballroom.ab_ops->bo_free(
-					    &colibri_balloc.cb_ballroom, &dtx,
-					    &ext[i]);
-			if(result < 0) {
-				fprintf(stderr,"Error during free for size %5d",
-					(int)c2_ext_length(&ext[i]));
-				return result;
-			}
+	for (i = colibri_balloc.cb_sb.bsb_reserved_groups;
+	     i < colibri_balloc.cb_sb.bsb_groupcount && result == 0; i++ ) {
+		struct c2_balloc_group_info *grp = c2_balloc_gn2info(&colibri_balloc, i);
 
-			C2_UT_ASSERT(balloc_ut_invariant(ext[i], INVAR_FREE));
-#ifdef BALLOC_DEBUG
-			printf("%3d:rc = %d: freed:                          "
-			       "len=%5d: [%08llx,%08llx)=[%8llu,%8llu)\n",
-			       i, result, (int)c2_ext_length(&ext[i]),
-			       (unsigned long long)ext[i].e_start,
-			       (unsigned long long)ext[i].e_end,
-			       (unsigned long long)ext[i].e_start,
-			       (unsigned long long)ext[i].e_end);
-#endif
+		result = c2_db_tx_init(&dtx.tx_dbtx, &db, 0);
+		C2_ASSERT(result == 0);
+		if (grp) {
+			c2_balloc_lock_group(grp);
+			result = c2_balloc_load_extents(&colibri_balloc, grp, &dtx.tx_dbtx);
 			if (result == 0)
-				c2_db_tx_commit(&dtx.tx_dbtx);
-			else
-				c2_db_tx_abort(&dtx.tx_dbtx);
-		}
-
-		if(colibri_balloc.cb_sb.bsb_freeblocks != prev_free_blocks) {
-			fprintf(stderr, "Size mismatch during block reclaim\n");
-			result = -EINVAL;
-		}
-
-		for (i = colibri_balloc.cb_sb.bsb_reserved_groups;
-		     i < colibri_balloc.cb_sb.bsb_groupcount && result == 0;
-		     i++) {
-			struct c2_balloc_group_info *grp = c2_balloc_gn2info
-				(&colibri_balloc, i);
-
-			result = c2_db_tx_init(&dtx.tx_dbtx, &db, 0);
-			C2_UT_ASSERT(result == 0);
-			if (grp) {
-				c2_balloc_lock_group(grp);
-				result = c2_balloc_load_extents(&colibri_balloc,
-								grp,
-								&dtx.tx_dbtx);
-				if (result == 0)
-					c2_balloc_debug_dump_group_extent(
-						    "balloc ut", grp);
-				if (grp->bgi_freeblocks !=
-				    colibri_balloc.cb_sb.bsb_groupsize) {
-					printf("corrupted grp %d: %llx != %llx\n",
-					       i, (unsigned long long)
-					       grp->bgi_freeblocks,
-					       (unsigned long long)
-					       colibri_balloc.cb_sb.bsb_groupsize);
-					result = -EINVAL;
-				}
-				c2_balloc_release_extents(grp);
-				c2_balloc_unlock_group(grp);
+				c2_balloc_debug_dump_group_extent(argv[0], grp);
+			if (grp->bgi_freeblocks != colibri_balloc.cb_sb.bsb_groupsize) {
+				printf("corrupted grp %d: %llx != %llx\n",
+					i,
+					(unsigned long long)grp->bgi_freeblocks,
+					(unsigned long long)colibri_balloc.cb_sb.bsb_groupsize);
+				result = -EINVAL;
 			}
-			c2_db_tx_commit(&dtx.tx_dbtx);
+			c2_balloc_release_extents(grp);
+			c2_balloc_unlock_group(grp);
 		}
-
-		colibri_balloc.cb_ballroom.ab_ops->bo_fini(
-			    &colibri_balloc.cb_ballroom);
+		c2_db_tx_commit(&dtx.tx_dbtx);
 	}
 
-	c2_free(prev_group_info_free_blocks);
-
+	colibri_balloc.cb_ballroom.ab_ops->bo_fini(&colibri_balloc.cb_ballroom);
 	c2_dbenv_fini(&db);
-
-#ifdef BALLOC_DEBUG
 	printf("done. status = %d\n", result);
-#endif
-
 	return result;
 }
 
-void test_balloc()
-{
-	int result;
-
-	result = test_balloc_ut_ops();
-	C2_UT_ASSERT(result == 0);
-
-	result = system("rm -fr "BALLOC_DBNAME);
-	C2_UT_ASSERT(result == 0);
-}
-
-const struct c2_test_suite balloc_ut = {
-        .ts_name  = "balloc-ut",
-        .ts_init  = NULL,
-        .ts_fini  = NULL,
-        .ts_tests = {
-                { "balloc", test_balloc},
-		{ NULL, NULL }
-        }
-};
-
 /*
  *  Local variables:
  *  c-indentation-style: "K&R"
diff --git a/balloc/ut/dump_free_extent.c b/balloc/ut/dump_free_extent.c
index 825884c..d23b426 100644
--- a/balloc/ut/dump_free_extent.c
+++ b/balloc/ut/dump_free_extent.c
@@ -17,21 +17,16 @@
  * Original author: Huang Hua <hua_huang@xyratex.com>
  * Original creation date: 09/02/2010
  */
+
 #include <stdio.h>        /* fprintf */
-#include <stdlib.h>       /* srand, rand */
+#include <stdlib.h>       /* atoll */
 #include <errno.h>
-#include <sys/time.h>
 #include <err.h>
 
-#include "dtm/dtm.h"      /* c2_dtx */
 #include "lib/arith.h"    /* C2_3WAY, c2_uint128 */
 #include "lib/misc.h"     /* C2_SET0 */
 #include "lib/assert.h"
-#include "lib/memory.h"
-#include "lib/thread.h"
-#include "lib/getopts.h"
 #include "db/db.h"
-#include "lib/ut.h"
 #include "balloc/balloc.h"
 
 extern	struct c2_balloc colibri_balloc;
@@ -56,18 +51,13 @@ int main(int argc, char **argv)
 	result = c2_db_tx_init(&dtx.tx_dbtx, &db, 0);
 	C2_ASSERT(result == 0);
 
-	result = colibri_balloc.cb_ballroom.ab_ops->bo_init
-		(&colibri_balloc.cb_ballroom, &db, BALLOC_DEF_BLOCK_SHIFT,
-		 BALLOC_DEF_CONTAINER_SIZE, BALLOC_DEF_BLOCKS_PER_GROUP,
-		 BALLOC_DEF_RESERVED_GROUPS);
+	result = colibri_balloc.cb_ballroom.ab_ops->bo_init(&colibri_balloc.cb_ballroom, &db, 12);
 
 	if (result == 0) {
-		struct c2_balloc_group_info *grp =
-			c2_balloc_gn2info(&colibri_balloc, gn);
+		struct c2_balloc_group_info *grp = c2_balloc_gn2info(&colibri_balloc, gn);
 		if (grp) {
 			c2_balloc_lock_group(grp);
-			result = c2_balloc_load_extents(
-				    &colibri_balloc, grp, &dtx.tx_dbtx);
+			result = c2_balloc_load_extents(&colibri_balloc, grp, &dtx.tx_dbtx);
 			if (result == 0)
 				c2_balloc_debug_dump_group_extent(argv[0], grp);
 			c2_balloc_release_extents(grp);
diff --git a/balloc/ut/dump_group_desc.c b/balloc/ut/dump_group_desc.c
index 272b8aa..d60b967 100644
--- a/balloc/ut/dump_group_desc.c
+++ b/balloc/ut/dump_group_desc.c
@@ -19,20 +19,14 @@
  */
 
 #include <stdio.h>        /* fprintf */
-#include <stdlib.h>       /* srand, rand */
+#include <stdlib.h>       /* atoll */
 #include <errno.h>
-#include <sys/time.h>
 #include <err.h>
 
-#include "dtm/dtm.h"      /* c2_dtx */
 #include "lib/arith.h"    /* C2_3WAY, c2_uint128 */
 #include "lib/misc.h"     /* C2_SET0 */
 #include "lib/assert.h"
-#include "lib/memory.h"
-#include "lib/thread.h"
-#include "lib/getopts.h"
 #include "db/db.h"
-#include "lib/ut.h"
 #include "balloc/balloc.h"
 
 extern	struct c2_balloc colibri_balloc;
@@ -57,14 +51,10 @@ int main(int argc, char **argv)
 	result = c2_db_tx_init(&dtx.tx_dbtx, &db, 0);
 	C2_ASSERT(result == 0);
 
-	result = colibri_balloc.cb_ballroom.ab_ops->bo_init
-		(&colibri_balloc.cb_ballroom, &db, BALLOC_DEF_BLOCK_SHIFT,
-		 BALLOC_DEF_CONTAINER_SIZE, BALLOC_DEF_BLOCKS_PER_GROUP,
-		 BALLOC_DEF_RESERVED_GROUPS);
+	result = colibri_balloc.cb_ballroom.ab_ops->bo_init(&colibri_balloc.cb_ballroom, &db, 12);
 
 	if (result == 0) {
-		struct c2_balloc_group_info *grp =
-			c2_balloc_gn2info(&colibri_balloc, gn);
+		struct c2_balloc_group_info *grp = c2_balloc_gn2info(&colibri_balloc, gn);
 		if (grp)
 			c2_balloc_debug_dump_group(argv[0], grp);
 	}
diff --git a/balloc/ut/dump_super_block.c b/balloc/ut/dump_super_block.c
index 9fb55d0..0a94e8b 100644
--- a/balloc/ut/dump_super_block.c
+++ b/balloc/ut/dump_super_block.c
@@ -17,25 +17,20 @@
  * Original author: Huang Hua <hua_huang@xyratex.com>
  * Original creation date: 09/02/2010
  */
+
 #include <stdio.h>        /* fprintf */
-#include <stdlib.h>       /* srand, rand */
 #include <errno.h>
-#include <sys/time.h>
 #include <err.h>
 
-#include "dtm/dtm.h"      /* c2_dtx */
 #include "lib/arith.h"    /* C2_3WAY, c2_uint128 */
 #include "lib/misc.h"     /* C2_SET0 */
 #include "lib/assert.h"
-#include "lib/memory.h"
-#include "lib/thread.h"
-#include "lib/getopts.h"
 #include "db/db.h"
-#include "lib/ut.h"
 #include "balloc/balloc.h"
 
 extern	struct c2_balloc colibri_balloc;
 
+
 int main(int argc, char **argv)
 {
 	const char           *db_name;
@@ -55,10 +50,7 @@ int main(int argc, char **argv)
 	result = c2_db_tx_init(&dtx.tx_dbtx, &db, 0);
 	C2_ASSERT(result == 0);
 
-	result = colibri_balloc.cb_ballroom.ab_ops->bo_init
-		(&colibri_balloc.cb_ballroom, &db, BALLOC_DEF_BLOCK_SHIFT,
-		 BALLOC_DEF_CONTAINER_SIZE, BALLOC_DEF_BLOCKS_PER_GROUP,
-		 BALLOC_DEF_RESERVED_GROUPS);
+	result = colibri_balloc.cb_ballroom.ab_ops->bo_init(&colibri_balloc.cb_ballroom, &db, 12);
 
 	if (result == 0) {
 		c2_balloc_debug_dump_sb(argv[0], &colibri_balloc.cb_sb);
diff --git a/balloc/ut/format.c b/balloc/ut/format.c
index f3cb16f..7c41582 100644
--- a/balloc/ut/format.c
+++ b/balloc/ut/format.c
@@ -19,20 +19,13 @@
  */
 
 #include <stdio.h>        /* fprintf */
-#include <stdlib.h>       /* srand, rand */
 #include <errno.h>
-#include <sys/time.h>
 #include <err.h>
 
-#include "dtm/dtm.h"      /* c2_dtx */
 #include "lib/arith.h"    /* C2_3WAY, c2_uint128 */
 #include "lib/misc.h"     /* C2_SET0 */
 #include "lib/assert.h"
-#include "lib/memory.h"
-#include "lib/thread.h"
-#include "lib/getopts.h"
 #include "db/db.h"
-#include "lib/ut.h"
 #include "balloc/balloc.h"
 
 extern	struct c2_balloc colibri_balloc;
@@ -57,10 +50,8 @@ int main(int argc, char **argv)
 	C2_ASSERT(result == 0);
 
 	result = colibri_balloc.cb_ballroom.ab_ops->bo_init
-		(&colibri_balloc.cb_ballroom, &db, BALLOC_DEF_BLOCK_SHIFT,
-		 BALLOC_DEF_CONTAINER_SIZE, BALLOC_DEF_BLOCKS_PER_GROUP,
-		 BALLOC_DEF_RESERVED_GROUPS);
-
+		(&colibri_balloc.cb_ballroom, &db, 12);
+	
 	result = c2_db_tx_commit(&dtx.tx_dbtx);
 	C2_ASSERT(result == 0);
 	colibri_balloc.cb_ballroom.ab_ops->bo_fini(&colibri_balloc.cb_ballroom);
diff --git a/balloc/ut/free.c b/balloc/ut/free.c
index 29daa9b..1a5ba2d 100644
--- a/balloc/ut/free.c
+++ b/balloc/ut/free.c
@@ -17,21 +17,16 @@
  * Original author: Huang Hua <hua_huang@xyratex.com>
  * Original creation date: 09/02/2010
  */
+
 #include <stdio.h>        /* fprintf */
-#include <stdlib.h>       /* srand, rand */
+#include <stdlib.h>       /* atoll */
 #include <errno.h>
-#include <sys/time.h>
 #include <err.h>
 
-#include "dtm/dtm.h"      /* c2_dtx */
 #include "lib/arith.h"    /* C2_3WAY, c2_uint128 */
 #include "lib/misc.h"     /* C2_SET0 */
 #include "lib/assert.h"
-#include "lib/memory.h"
-#include "lib/thread.h"
-#include "lib/getopts.h"
 #include "db/db.h"
-#include "lib/ut.h"
 #include "balloc/balloc.h"
 
 extern	struct c2_balloc colibri_balloc;
@@ -63,14 +58,10 @@ int main(int argc, char **argv)
 	result = c2_db_tx_init(&dtx.tx_dbtx, &db, 0);
 	C2_ASSERT(result == 0);
 
-	result = colibri_balloc.cb_ballroom.ab_ops->bo_init
-		(&colibri_balloc.cb_ballroom, &db, BALLOC_DEF_BLOCK_SHIFT,
-		 BALLOC_DEF_CONTAINER_SIZE, BALLOC_DEF_BLOCKS_PER_GROUP,
-		 BALLOC_DEF_RESERVED_GROUPS);
+	result = colibri_balloc.cb_ballroom.ab_ops->bo_init(&colibri_balloc.cb_ballroom, &db, 12);
 
 	if (result == 0) {
-		result = colibri_balloc.cb_ballroom.ab_ops->bo_free(
-			    &colibri_balloc.cb_ballroom, &dtx, &ext);
+		result = colibri_balloc.cb_ballroom.ab_ops->bo_free(&colibri_balloc.cb_ballroom, &dtx, &ext);
 		printf("rc = %d: freed [%08llx,%08llx)\n", result,
 			(unsigned long long)ext.e_start,
 			(unsigned long long)ext.e_end);
diff --git a/balloc/ut/mperf.c b/balloc/ut/mperf.c
index 2c71835..f7c4799 100644
--- a/balloc/ut/mperf.c
+++ b/balloc/ut/mperf.c
@@ -24,15 +24,12 @@
 #include <sys/time.h>
 #include <err.h>
 
-#include "dtm/dtm.h"      /* c2_dtx */
 #include "lib/arith.h"    /* C2_3WAY, c2_uint128 */
 #include "lib/misc.h"     /* C2_SET0 */
 #include "lib/assert.h"
 #include "lib/memory.h"
 #include "lib/thread.h"
-#include "lib/getopts.h"
 #include "db/db.h"
-#include "lib/ut.h"
 #include "balloc/balloc.h"
 
 extern	struct c2_balloc colibri_balloc;
@@ -43,7 +40,7 @@ int		      loops;
 c2_bcount_t	      count = 32;
 
 unsigned long timesub(struct timeval *begin, struct timeval *end) {
-	unsigned long interval =
+	unsigned long interval = 
 		(unsigned long)((end->tv_sec - begin->tv_sec) * 1000000 +
 		                end->tv_usec - begin->tv_usec
 			        );
@@ -79,8 +76,7 @@ repeat:
 		C2_ASSERT(result == 0);
 		tmp.e_start = tmp.e_end;
 		gettimeofday(&alloc_begin, NULL);
-		result = colibri_balloc.cb_ballroom.ab_ops->bo_alloc(
-			    &colibri_balloc.cb_ballroom, &dtx, count, &ext[i]);
+		result = colibri_balloc.cb_ballroom.ab_ops->bo_alloc(&colibri_balloc.cb_ballroom, &dtx, count, &ext[i]);
 		gettimeofday(&alloc_end, NULL);
 		alloc_usec += timesub(&alloc_begin, &alloc_end);
 		tmp = ext[i];
@@ -96,25 +92,20 @@ repeat:
 			usleep( rand() & 0xfff);
 			goto repeat;
 		}
-#ifdef BALLOC_DEBUG
-
-		printf("%lx %5d: rc = %d: requested count=%5d, result count=%5d:"
-		       "[%08llx,%08llx)=[%10llu,%10llu)\n",
+/*
+		printf("%lx %5d: rc = %d: requested count=%5d, result count=%5d: [%08llx,%08llx)=[%10llu,%10llu)\n",
 			(long)pthread_self(), i, result, (int)count,
 			(int)c2_ext_length(&ext[i]),
 			(unsigned long long)ext[i].e_start,
 			(unsigned long long)ext[i].e_end,
 			(unsigned long long)ext[i].e_start,
 			(unsigned long long)ext[i].e_end);
-#endif
+*/
 	}
 
-	printf("=======%lx====%d========\tPerf: alloc/sec = %lu\n",
-	       (long)pthread_self(), i, (unsigned long)i * 1000000 / alloc_usec);
+	printf("=======%lx====%d========\tPerf: alloc/sec = %lu\n", (long)pthread_self(), i, (unsigned long)i * 1000000 / alloc_usec);
 	alloc = i;
-
-	/* Uncomment the following region to perform a worst case test */
-	/* randomize the array */
+	/* randonmize the array*/
 	/*
 	for (i = 0; i < alloc * 2; i++ ) {
 		int a, b;
@@ -133,8 +124,7 @@ repeat_free:
 
 		gettimeofday(&free_begin, NULL);
 		if (ext[i].e_start != 0)
-			result = colibri_balloc.cb_ballroom.ab_ops->bo_free(
-				    &colibri_balloc.cb_ballroom, &dtx, &ext[i]);
+			result = colibri_balloc.cb_ballroom.ab_ops->bo_free(&colibri_balloc.cb_ballroom, &dtx, &ext[i]);
 		gettimeofday(&free_end, NULL);
 		free_usec += timesub(&free_begin, &free_end);
 		if (result == 0 )
@@ -145,21 +135,18 @@ repeat_free:
 			usleep( rand() & 0xfff);
 			goto repeat_free;
 		}
-#ifdef BALLOC_DEBUG
-		printf("%lx %5d: rc = %d: freed: len=%5d: [%08llx,%08llx)="
-		       "[%10llu,%10llu)\n",
-		       (long)pthread_self(), i, result,
-		       (int)c2_ext_length(&ext[i]),
-		       (unsigned long long)ext[i].e_start,
-		       (unsigned long long)ext[i].e_end,
-		       (unsigned long long)ext[i].e_start,
-		       (unsigned long long)ext[i].e_end);
-#endif
+/*
+		printf("%lx %5d: rc = %d: freed: len=%5d: [%08llx,%08llx)=[%10llu,%10llu)\n",
+			(long)pthread_self(), i, result, (int)c2_ext_length(&ext[i]),
+			(unsigned long long)ext[i].e_start,
+			(unsigned long long)ext[i].e_end,
+			(unsigned long long)ext[i].e_start,
+			(unsigned long long)ext[i].e_end);
+*/
 	}
 
-	printf("=======%lx====%d========\tPerf: free/sec  = %lu\n",
-	       (long)pthread_self(), i, (unsigned long)alloc * 1000000
-	       / free_usec);
+
+	printf("=======%lx====%d========\tPerf: free/sec  = %lu\n", (long)pthread_self(), i, (unsigned long)alloc * 1000000 / free_usec);
 }
 
 int main(int argc, char **argv)
@@ -174,8 +161,7 @@ int main(int argc, char **argv)
 	struct c2_thread      *threads;
 
 	if (argc != 5) {
-		fprintf(stderr, "Usage: %s <db-dir> number_of_loops"
-			"num_of_threads num_of_blocks\n", argv[0]);
+		fprintf(stderr, "Usage: %s <db-dir> number_of_loops num_of_threads num_of_blocks\n", argv[0]);
 		return 1;
 	}
 	db_name = argv[1];
@@ -198,11 +184,7 @@ int main(int argc, char **argv)
 	threads = c2_alloc(num_threads * sizeof (struct c2_thread));
 	C2_ASSERT(threads != NULL);
 
-	result = colibri_balloc.cb_ballroom.ab_ops->bo_init
-		(&colibri_balloc.cb_ballroom, &db, BALLOC_DEF_BLOCK_SHIFT,
-		 BALLOC_DEF_CONTAINER_SIZE, BALLOC_DEF_BLOCKS_PER_GROUP,
-		 BALLOC_DEF_RESERVED_GROUPS);
-
+	result = colibri_balloc.cb_ballroom.ab_ops->bo_init(&colibri_balloc.cb_ballroom, &db, 12);
 	C2_ASSERT(result == 0);
 	for (i = 0; i < num_threads; i++) {
 		result = C2_THREAD_INIT(&threads[i], struct c2_balloc*, NULL,
@@ -214,15 +196,11 @@ int main(int argc, char **argv)
 		result = c2_thread_join(&threads[i]);
 		C2_ASSERT(result == 0);
 	}
-#ifdef BALLOC_DEBUG
+
 	printf("all threads exited\n");
-#endif
 	colibri_balloc.cb_ballroom.ab_ops->bo_fini(&colibri_balloc.cb_ballroom);
 	c2_dbenv_fini(&db);
-
-#ifdef BALLOC_DEBUG
 	printf("done\n");
-#endif
 	return 0;
 }
 
diff --git a/balloc/ut/perf.c b/balloc/ut/perf.c
index fc6279e..bf8232c 100644
--- a/balloc/ut/perf.c
+++ b/balloc/ut/perf.c
@@ -24,23 +24,21 @@
 #include <sys/time.h>
 #include <err.h>
 
-#include "dtm/dtm.h"      /* c2_dtx */
 #include "lib/arith.h"    /* C2_3WAY, c2_uint128 */
 #include "lib/misc.h"     /* C2_SET0 */
 #include "lib/assert.h"
-#include "lib/memory.h"
 #include "lib/thread.h"
 #include "lib/getopts.h"
 #include "db/db.h"
-#include "lib/ut.h"
 #include "balloc/balloc.h"
 
 extern	struct c2_balloc colibri_balloc;
 const int MAX = 1000 * 1000;
 const int DEF = 1000 * 1;
 
+
 unsigned long timesub(struct timeval *begin, struct timeval *end) {
-	unsigned long interval =
+	unsigned long interval = 
 		(unsigned long)((end->tv_sec - begin->tv_sec) * 1000000 +
 		                end->tv_usec - begin->tv_usec
 			        );
@@ -78,7 +76,7 @@ int main(int argc, char **argv)
                                                db_name = string; })),
                             C2_FORMATARG('l', "loops to run", "%i", &loops),
                             C2_FORMATARG('r', "randomize the result", "%i", &r),
-                            C2_FORMATARG('c', "count to alloc", "%lu",
+                            C2_FORMATARG('c', "count to alloc", "%lu", 
 					 &count),
                             C2_FLAGARG('v', "verbose", &verbose),
                             C2_FLAGARG('g', "use goal or not", &g));
@@ -107,9 +105,7 @@ int main(int argc, char **argv)
 	C2_ASSERT(result == 0);
 
 	result = colibri_balloc.cb_ballroom.ab_ops->bo_init
-		(&colibri_balloc.cb_ballroom, &db, BALLOC_DEF_BLOCK_SHIFT,
-		 BALLOC_DEF_CONTAINER_SIZE, BALLOC_DEF_BLOCKS_PER_GROUP,
-		 BALLOC_DEF_RESERVED_GROUPS);
+		(&colibri_balloc.cb_ballroom, &db, 12);
 
 	for (i = 0; i < loops && result == 0; i++ ) {
 		if (count > 0)
@@ -127,14 +123,12 @@ int main(int argc, char **argv)
 			tmp.e_start = 0;
 
 		gettimeofday(&alloc_begin, NULL);
-		result = colibri_balloc.cb_ballroom.ab_ops->bo_alloc(
-			    &colibri_balloc.cb_ballroom, &dtx, target, &tmp);
+		result = colibri_balloc.cb_ballroom.ab_ops->bo_alloc(&colibri_balloc.cb_ballroom, &dtx, target, &tmp);
 		gettimeofday(&alloc_end, NULL);
 		alloc_usec += timesub(&alloc_begin, &alloc_end);
 		ext[i] = tmp;
 		if (verbose)
-		printf("%d: rc = %d: requested count=%5d, result count=%5d:"
-		       " [%08llx,%08llx)=[%8llu,%8llu)\n",
+		printf("%d: rc = %d: requested count=%5d, result count=%5d: [%08llx,%08llx)=[%8llu,%8llu)\n",
 			i, result, (int)count,
 			(int)c2_ext_length(&ext[i]),
 			(unsigned long long)ext[i].e_start,
@@ -150,10 +144,9 @@ int main(int argc, char **argv)
 			break;
 		}
 	}
-	printf("==================\nPerf: alloc/sec = %lu\n",
-	       (unsigned long)loops * 1000000 / alloc_usec);
+	printf("==================\nPerf: alloc/sec = %lu\n", (unsigned long)loops * 1000000 / alloc_usec);
 
-	/* randomize the array */
+	/* randonmize the array */
 	if (r) {
 		for (i = 0; i < loops * 2; i++ ) {
 			int a, b;
@@ -168,14 +161,12 @@ int main(int argc, char **argv)
 		C2_ASSERT(result == 0);
 
 		gettimeofday(&free_begin, NULL);
-		if (ext[i].e_start !=
-		    0) result = colibri_balloc.cb_ballroom.ab_ops->bo_free(
-				&colibri_balloc.cb_ballroom, &dtx, &ext[i]);
+		if (ext[i].e_start != 0)
+			result = colibri_balloc.cb_ballroom.ab_ops->bo_free(&colibri_balloc.cb_ballroom, &dtx, &ext[i]);
 		gettimeofday(&free_end, NULL);
 		free_usec += timesub(&free_begin, &free_end);
 		if (verbose)
-		printf("%d: rc = %d: freed: len=%5d: [%08llx,%08llx)=[%8llu,"
-		       "%8llu)\n",
+		printf("%d: rc = %d: freed: len=%5d: [%08llx,%08llx)=[%8llu,%8llu)\n",
 			i, result, (int)c2_ext_length(&ext[i]),
 			(unsigned long long)ext[i].e_start,
 			(unsigned long long)ext[i].e_end,
@@ -191,8 +182,7 @@ int main(int argc, char **argv)
 
 	colibri_balloc.cb_ballroom.ab_ops->bo_fini(&colibri_balloc.cb_ballroom);
 	c2_dbenv_fini(&db);
-	printf("==================\nPerf: free/sec = %lu\n",
-	       (unsigned long)loops * 1000000 / free_usec);
+	printf("==================\nPerf: free/sec = %lu\n", (unsigned long)loops * 1000000 / free_usec);
 	printf("done\n");
 	return 0;
 }
diff --git a/build_kernel_modules/.gitignore b/build_kernel_modules/.gitignore
deleted file mode 100644
index 6adaf74..0000000
--- a/build_kernel_modules/.gitignore
+++ /dev/null
@@ -1,20 +0,0 @@
-init.c
-addb
-c2t1fs
-cob
-db
-dtm
-fid
-fol
-fop
-galois
-ioservice
-layout
-lib
-net
-pool
-rpc
-sm
-sns
-stob
-xcode
diff --git a/build_kernel_modules/Makefile.in b/build_kernel_modules/Makefile.in
index bff68cc..3d89d0b 100644
--- a/build_kernel_modules/Makefile.in
+++ b/build_kernel_modules/Makefile.in
@@ -1,201 +1,29 @@
-CORE_SRCDIR     = @SRCDIR@
-BUILD_DIR       = $(CORE_SRCDIR)/build_kernel_modules
-KERNEL_BUILDDIR = @LINUX_OBJ@
+C2T1FS_SRCDIR = @SRCDIR@/c2t1fs
+KSUNRPC_SRCDIR = @SRCDIR@/net/ksunrpc
+FOPDIR = @SRCDIR@/fop
+STOBDIR = @SRCDIR@/stob/ut
 
-GCOV_PROFILE    = @K_ENABLE_COVERAGE@
+subdirs := ../c2t1fs/ ../net/ksunrpc/ ../lib/linux_kernel/ \
+           ../fop/linux_kernel/ ../addb/linux_kernel/ ../db/linux_kernel/ \
+           ../sns/linux_kernel/ ../galois/linux_kernel/ ../pool/linux_kernel/ \
+	   ../layout/linux_kernel/ ../stob/linux_kernel/ ../utils/linux_kernel/
 
-testdirs        = ../net/bulk_emulation/st/linux_kernel/                \
-                  ../rpc/it/linux_kernel/                               \
-                  ../utils/linux_kernel/
-
-EXTRA_CFLAGS    = -DHAVE_CONFIG_H -I. -I$(CORE_SRCDIR) @KCFLAGS@
-
-#       NOTE:
-#       It is assumed that user space build is done before starting to
-#       build kernel modules.
-
-#       Below is the directory listing from which we have to create kcolibri.ko
-#       To add a new directory 'd' to this list, add directory name
-#       to $(dirs); then add the names of '.c' files to d_SOURCES and the
-#       headers to d_HEADERS.
-
-#       The $(dirs) list is maintained alphabetically
-
-dirs  = addb addb/linux_kernel c2t1fs/linux_kernel cob colibri db \
-        db/linux_kernel dtm fid fol fop ioservice layout lib      \
-        lib/linux_kernel lib/ut net net/bulk_emulation            \
-        net/bulk_emulation/ut net/ksunrpc net/ut pool rpc         \
-        sm sns stob stob/ut ut xcode xcode/ut
-
-#       Source Listing
-
-addb_SOURCES                    := addb.c addb_fop.c addb_k.c
-addb_HEADERS                    := addb_k.h
-
-addb_linux_kernel_SOURCES       := addb_console.c
-
-#       If there's a directory 'd' in $(dirs) then the listing of files given
-#       for d_SOURCES is relative to $(CORE_SRCDIR)/d; e.g. in the following,
-#       ../../ioservice/ points to $(CORE_SRCDIR)/c2t1fs/../../ioservice/
-
-c2t1fs_linux_kernel_SOURCES     := main.c
-c2t1fs_linux_kernel_HEADERS     := c2t1fs.h ../../ioservice/io_fops_k.h \
-                                   ../../stob/ut/io_k.h
-
-cob_SOURCES                     := cob.c
-
-colibri_SOURCES                 := init.c
-
-db_SOURCES                      := db_common.c
-
-db_linux_kernel_SOURCES         := db.c
-db_linux_kernel_HEADERS         := db_impl.h
-
-dtm_SOURCES                     := verno.c
-
-fid_SOURCES                     := fid.c
-fid_HEADERS                     := fid.h
-
-fol_SOURCES                     := fol.c
-fol_HEADERS                     := fol.h
-
-fop_SOURCES                     := fop.c fom.c fop_format.c fop_iterator.c \
-                                   fop_base.c fop_item_type.c
-
-ioservice_SOURCES               := io_fops.c io_fops_k.c
-ioservice_HEADERS               := io_fops.h io_fops_k.h
-
-layout_SOURCES                  := layout.c pdclust.c
-layout_HEADERS                  := layout.h pdclust.h
-
-lib_SOURCES                     := bitstring.c vec.c list.c queue.c refs.c    \
-                                   time.c bitmap.c chan.c misc.c buf.c cond.c \
-                                   thread.c tlist.c bob.c trace.c
-
-lib_HEADERS                     := misc.h memory.h errno.h arith.h buf.h \
-                                   trace.h
-
-lib_linux_kernel_SOURCES        := memory.c mutex.c rwlock.c ktime.c timer.c  \
-                                   kthread.c semaphore.c processor.c kvec.c   \
-                                   ktrace.c ut.c main.c
-
-lib_ut_SOURCES                  := rwlock.c bitmap.c tlist.c chan.c list.c    \
-                                   mutex.c queue.c refs.c tlist.c time.c      \
-                                   vec.c zerovec.c thread.c bob.c trace.c
-
-net_SOURCES                     := buf.c buffer_pool.c domain.c ep.c net.c    \
-                                   tm.c connection.c net_cli.c net_utils.c    \
-                                   net_srv.c net_otw_types_k.c
-net_HEADERS                     := net.h net_internal.h net_otw_types_k.h
-
-net_bulk_emulation_SOURCES      := ksunrpc_server.c sunrpc_io_k.c
-net_bulk_emulation_HEADERS      := sunrpc_xprt.h mem_xprt.h sunrpc_io_k.h     \
-                                   ../ksunrpc/ksunrpc.h ../net_otw_types_k.h
-
-net_bulk_emulation_ut_SOURCES   := ksunrpc_ut.c bulk_mem_ut.c bulk_sunrpc_ut.c
-
-net_ksunrpc_SOURCES             := domain.c client.c kxdr.c
-net_ksunrpc_HEADERS             := ksunrpc.h
-
-net_ut_SOURCES                  := bulk_if.c buffer_pool_ut.c
-
-pool_SOURCES                    := pool.c
-
-rpc_SOURCES                     := formation.c rpc2.c rpc_base.c session.c    \
-                                   session_foms.c conn.c slot.c               \
-                                   session_utils.c session_fops.c             \
-                                   rpc_onwire.c session_k.c rpclib.c
-rpc_HEADERS                     := session_k.h
-
-sm_SOURCES                      := sm.c
-
-sns_SOURCES                     := ls_solve.c matvec.c parity_math.c          \
-                                   parity_ops.c
-sns_HEADERS                     := parity_math.h
-
-stob_SOURCES                    := stob.c
-stob_HEADERS                    := stob.h
-
-stob_ut_SOURCES                 := io_fop_init.c io_k.c
-stob_ut_HEADERS                 := io_fop.h io_k.h
-
-ut_SOURCES                      := rpc.c
-ut_HEADERS                      := rpc.h
-
-xcode_SOURCES                   := bufvec_xcode.c bufvec_xcode_fop.c          \
-                                   bufvec_xcode_size.c xcode.c
-
-xcode_HEADERS                   := xcode.h
-
-xcode_ut_SOURCES                := xcode.c
-
-#       Following lines create the list of objects required for creating
-#       kcolibri by putting %.o for each %.c file listed for each target of
-#       $(dirs). The following definition of kcolibri_objects is functionally
-#       equivalent to following shell script code snippet
-#       for d in $(dirs); do
-#               var=`echo $d | sed 's/\//_/'`
-#               varsrc="${var}_SOURCES"
-#               for f in ${!varsrc}; do
-#                       objfname=`basename $f | sed 's/.c$/.o'`
-#                       kcolibri_objects = "$kcolibri_objects $d/$objfname"
-#               done
-#       done
-#       $(notdir names...)
-#               extracts all but the directory-part of each file name in names
-#       e.g. $(notdir src/foo.c hacks) Produces the result 'foo.c hacks'
-
-kcolibri_objects = $(foreach d, $(dirs), $(foreach f,                     \
-                        $($(subst /,_,$(d))_SOURCES), $(addprefix $(d)/,  \
-                                $(subst .c,.o, $(notdir $(f))))))
-
-obj-m += kcolibri.o
-
-kcolibri-y += main.o dummy_init_fini.o $(kcolibri_objects)
-
-#       Besides the kcolibri.ko, the UT's would be build separately by
-#       recursing into directories specified by $(testdirs)
-
-obj-y += $(testdirs)
-
-create_links = $(shell ln -s $(CORE_SRCDIR)/$(d)/$(f) $(d)/$(notdir $(f)) \
-                2> /dev/null)
+obj-y += $(subdirs)
 
 all:
-	@echo $(kcolibri-y)
-	for s in $(testdirs); do $(MAKE) -C $$s prepare; done
-#       Following lines create links to files from core/ tree to
-#       build_kernel_modules/ tree if links does not already exists.
-#       for d in $(dirs); do
-#               for f in $(d)_SOURCES; do
-#                   ln -sf core/$(d)/$(f) core/build_kernel_modules/$(d)/$(f)
-#               done
-#       done
+	for s in $(subdirs) ;do $(MAKE) -C $$s prepare ;done
+	$(MAKE) -C @LINUX_OBJ@ M=`pwd` modules
 
-	$(foreach d, $(dirs), $(shell  [ -d $(d) ] || mkdir -p $(d)))
-	$(foreach d, $(dirs), $(foreach f, $($(subst /,_,$(d))_SOURCES),  \
-		$(create_links)))
-	$(foreach d, $(dirs), $(foreach f, $($(subst /,_,$(d))_HEADERS),  \
-		$(create_links)))
-#       DO NOT append 'modules' target to the following $(MAKE)
-	$(MAKE) -C $(KERNEL_BUILDDIR) KBUILD_EXTRA_SYMBOLS=@GALOIS_SYMVERS@ \
-		M=`pwd`
+clean distclean:
+	for s in $(subdirs) ;do $(MAKE) -C $$s clean ;done
+	$(RM) Module.markers modules.order
 
 install modules_install:
-	$(MAKE) INSTALL_MOD_DIR=kernel/fs/colibri -C $(KERNEL_BUILDDIR) M=`pwd` modules_install
+	for s in $(subdirs) ;do $(MAKE) -C $$s install ;done
 
 uninstall:
-	su -c "$(RM) -r @LINUX_MOD@/kernel/fs/colibri && \
-	       $(RM) -r @LINUX_MOD@/kernel/fs/utils && \
-	       $(RM) -r @LINUX_MOD@/kernel/fs/rpc && \
-	       $(RM) -r @LINUX_MOD@/kernel/fs/net && /sbin/depmod -a"
+	for s in $(subdirs) ;do $(MAKE) -C $$s uninstall ;done
 
 dist distdir:
-	cp -v dummy_init_fini.[ch] main.c Makefile.in \
-		@top_builddir@/@PACKAGE@-@VERSION@/build_kernel_modules
+	for s in $(subdirs) ;do $(MAKE) -C $$s distdir ;done
 
-clean distclean:
-	$(MAKE) -C $(KERNEL_BUILDDIR) M=`pwd` clean
-	$(RM) Module.markers modules.order
-	$(foreach d, $(dirs), $(shell rm -rf $(firstword $(subst /, , $(d)))))
-	for s in $(testdirs) ;do $(MAKE) -C $$s clean ;done
diff --git a/build_kernel_modules/dummy_init_fini.c b/build_kernel_modules/dummy_init_fini.c
deleted file mode 100644
index b42b9e6..0000000
--- a/build_kernel_modules/dummy_init_fini.c
+++ /dev/null
@@ -1,120 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Amit Jambure <Amit_Jambure@xyratex.com>
- * Original creation date: 10/13/2011
- */
-
-#include <linux/module.h>
-
-/*
-  This file contains dummy init() and fini() routines for modules, that are
-  not yet ported to kernel.
-
-  Once the module compiles successfully for kernel mode, dummy routines from
-  this file should be removed.
- */
-
-#define DUMMY_IMPLEMENTATION \
-	printk("dummy implementation of %s called\n", __FUNCTION__)
-
-int c2_memory_init(void)
-{
-	DUMMY_IMPLEMENTATION;
-	return 0;
-}
-
-void c2_memory_fini(void)
-{
-
-}
-
-int c2_threads_init(void)
-{
-	DUMMY_IMPLEMENTATION;
-	return 0;
-}
-
-void c2_threads_fini(void)
-{
-
-}
-
-int c2_db_init(void)
-{
-	DUMMY_IMPLEMENTATION;
-	return 0;
-}
-
-void c2_db_fini(void)
-{
-
-}
-
-int c2_linux_stobs_init(void)
-{
-	DUMMY_IMPLEMENTATION;
-	return 0;
-}
-
-void c2_linux_stobs_fini(void)
-{
-
-}
-
-int c2_ad_stobs_init(void)
-{
-	DUMMY_IMPLEMENTATION;
-	return 0;
-}
-
-void c2_ad_stobs_fini(void)
-{
-
-}
-
-int sim_global_init(void)
-{
-	DUMMY_IMPLEMENTATION;
-	return 0;
-}
-
-void sim_global_fini(void)
-{
-
-}
-
-int c2_reqhs_init(void)
-{
-	DUMMY_IMPLEMENTATION;
-	return 0;
-}
-
-void c2_reqhs_fini(void)
-{
-
-}
-
-int c2_timers_init(void)
-{
-	DUMMY_IMPLEMENTATION;
-	return 0;
-}
-
-void c2_timers_fini(void)
-{
-
-}
diff --git a/build_kernel_modules/dummy_init_fini.h b/build_kernel_modules/dummy_init_fini.h
deleted file mode 100644
index a36822d..0000000
--- a/build_kernel_modules/dummy_init_fini.h
+++ /dev/null
@@ -1,51 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Amit Jambure <Amit_Jambure@xyratex.com>
- * Original creation date: 10/13/2011
- */
-
-#ifndef __C2_DUMMY_INIT_FINI_H
-#define __C2_DUMMY_INIT_FINI_H
-
-int c2_trace_init(void);
-void c2_trace_fini(void);
-
-int c2_memory_init(void);
-void c2_memory_fini(void);
-
-int c2_threads_init(void);
-void c2_threads_fini(void);
-
-int c2_db_init(void);
-void c2_db_fini(void);
-
-int c2_linux_stobs_init(void);
-void c2_linux_stobs_fini(void);
-
-int c2_ad_stobs_init(void);
-void c2_ad_stobs_fini(void);
-
-int sim_global_init(void);
-void sim_global_fini(void);
-
-int c2_reqhs_init(void);
-void c2_reqhs_fini(void);
-
-int c2_timers_init(void);
-void c2_timers_fini(void);
-
-#endif /* __C2_DUMMY_INIT_FINI_H */
diff --git a/build_kernel_modules/main.c b/build_kernel_modules/main.c
deleted file mode 100644
index e7b3f61..0000000
--- a/build_kernel_modules/main.c
+++ /dev/null
@@ -1,43 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Amit Jambure <Amit_Jambure@xyratex.com>
- * Original creation date: 10/13/2011
- */
-
-#include <linux/module.h>
-#include <linux/init.h>
-#include "lib/list.h"
-#include "colibri/init.h"
-
-MODULE_AUTHOR("Xyratex International");
-MODULE_DESCRIPTION("Colibri Library");
-MODULE_LICENSE("GPL");
-
-
-int init_module(void)
-{
-        printk("Colibri init\n");
-	c2_init();
-        return 0;
-}
-
-void cleanup_module(void)
-{
-        printk("Colibri cleanup\n");
-	c2_fini();
-}
-
diff --git a/c2t1fs/Makefile.am b/c2t1fs/Makefile.am
deleted file mode 100644
index c1825a8..0000000
--- a/c2t1fs/Makefile.am
+++ /dev/null
@@ -1,4 +0,0 @@
-EXTRA_DIST       = linux_kernel/main.c \
-                   linux_kernel/c2t1fs.h \
-                   linux_kernel/c2t1fs_loop.c
-
diff --git a/c2t1fs/Makefile.in b/c2t1fs/Makefile.in
index 83d924d..1f76bbf 100644
--- a/c2t1fs/Makefile.in
+++ b/c2t1fs/Makefile.in
@@ -1,371 +1,48 @@
-# Makefile.in generated by automake 1.11.1 from Makefile.am.
-# @configure_input@
-
-# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
-# 2003, 2004, 2005, 2006, 2007, 2008, 2009  Free Software Foundation,
-# Inc.
-# This Makefile.in is free software; the Free Software Foundation
-# gives unlimited permission to copy and/or distribute it,
-# with or without modifications, as long as this notice is preserved.
-
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
-# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
-# PARTICULAR PURPOSE.
-
-@SET_MAKE@
-VPATH = @srcdir@
-pkgdatadir = $(datadir)/@PACKAGE@
-pkgincludedir = $(includedir)/@PACKAGE@
-pkglibdir = $(libdir)/@PACKAGE@
-pkglibexecdir = $(libexecdir)/@PACKAGE@
-am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
-install_sh_DATA = $(install_sh) -c -m 644
-install_sh_PROGRAM = $(install_sh) -c
-install_sh_SCRIPT = $(install_sh) -c
-INSTALL_HEADER = $(INSTALL_DATA)
-transform = $(program_transform_name)
-NORMAL_INSTALL = :
-PRE_INSTALL = :
-POST_INSTALL = :
-NORMAL_UNINSTALL = :
-PRE_UNINSTALL = :
-POST_UNINSTALL = :
-build_triplet = @build@
-host_triplet = @host@
-subdir = c2t1fs
-DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in
-ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
-am__aclocal_m4_deps = $(top_srcdir)/m4/libtool.m4 \
-	$(top_srcdir)/m4/ltoptions.m4 $(top_srcdir)/m4/ltsugar.m4 \
-	$(top_srcdir)/m4/ltversion.m4 $(top_srcdir)/m4/lt~obsolete.m4 \
-	$(top_srcdir)/configure.ac
-am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
-	$(ACLOCAL_M4)
-mkinstalldirs = $(install_sh) -d
-CONFIG_HEADER = $(top_builddir)/config.h
-CONFIG_CLEAN_FILES =
-CONFIG_CLEAN_VPATH_FILES =
-SOURCES =
-DIST_SOURCES =
-DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
-ACLOCAL = @ACLOCAL@
-AIO_LIBS = @AIO_LIBS@
-AMTAR = @AMTAR@
-AR = @AR@
-AUTOCONF = @AUTOCONF@
-AUTOHEADER = @AUTOHEADER@
-AUTOMAKE = @AUTOMAKE@
-AWK = @AWK@
-CC = @CC@
-CCDEPMODE = @CCDEPMODE@
-CFLAGS = @CFLAGS@
-CPP = @CPP@
-CPPFLAGS = @CPPFLAGS@
-CUNIT_LIBS = @CUNIT_LIBS@
-CYGPATH_W = @CYGPATH_W@
-DB_LIBS = @DB_LIBS@
-DB_SRC = @DB_SRC@
-DEFS = @DEFS@
-DEPDIR = @DEPDIR@
-DSYMUTIL = @DSYMUTIL@
-DUMPBIN = @DUMPBIN@
-ECHO_C = @ECHO_C@
-ECHO_N = @ECHO_N@
-ECHO_T = @ECHO_T@
-EGREP = @EGREP@
-ENABLE_COVERAGE = @ENABLE_COVERAGE@
-EXEEXT = @EXEEXT@
-FGREP = @FGREP@
-GALOIS_LIBS = @GALOIS_LIBS@
-GALOIS_SRC = @GALOIS_SRC@
-GALOIS_SYMVERS = @GALOIS_SYMVERS@
-GREP = @GREP@
-INSTALL = @INSTALL@
-INSTALL_DATA = @INSTALL_DATA@
-INSTALL_PROGRAM = @INSTALL_PROGRAM@
-INSTALL_SCRIPT = @INSTALL_SCRIPT@
-INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
-KCFLAGS = @KCFLAGS@
-K_ENABLE_COVERAGE = @K_ENABLE_COVERAGE@
-LD = @LD@
-LDFLAGS = @LDFLAGS@
-LIBOBJS = @LIBOBJS@
-LIBS = @LIBS@
-LIBTOOL = @LIBTOOL@
-LINUX_MOD = @LINUX_MOD@
-LINUX_OBJ = @LINUX_OBJ@
-LIPO = @LIPO@
-LN_S = @LN_S@
-LTLIBOBJS = @LTLIBOBJS@
-LT_RELEASE = @LT_RELEASE@
-MAKEINFO = @MAKEINFO@
-MKDIR_P = @MKDIR_P@
-NM = @NM@
-NMEDIT = @NMEDIT@
-NM_B = @NM_B@
-NSL_LIBS = @NSL_LIBS@
-OBJDUMP = @OBJDUMP@
-OBJEXT = @OBJEXT@
-OTOOL = @OTOOL@
-OTOOL64 = @OTOOL64@
-PACKAGE = @PACKAGE@
-PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
-PACKAGE_NAME = @PACKAGE_NAME@
-PACKAGE_STRING = @PACKAGE_STRING@
-PACKAGE_TARNAME = @PACKAGE_TARNAME@
-PACKAGE_VERSION = @PACKAGE_VERSION@
-PATH_SEPARATOR = @PATH_SEPARATOR@
-PTHREAD_LIBS = @PTHREAD_LIBS@
-RANLIB = @RANLIB@
-SED = @SED@
-SET_MAKE = @SET_MAKE@
-SHELL = @SHELL@
-SRCDIR = @SRCDIR@
-STRIP = @STRIP@
-VERSION = @VERSION@
-YAML_LIBS = @YAML_LIBS@
-abs_builddir = @abs_builddir@
-abs_srcdir = @abs_srcdir@
-abs_top_builddir = @abs_top_builddir@
-abs_top_srcdir = @abs_top_srcdir@
-ac_ct_CC = @ac_ct_CC@
-ac_ct_DUMPBIN = @ac_ct_DUMPBIN@
-am__include = @am__include@
-am__leading_dot = @am__leading_dot@
-am__quote = @am__quote@
-am__tar = @am__tar@
-am__untar = @am__untar@
-bindir = @bindir@
-build = @build@
-build_alias = @build_alias@
-build_cpu = @build_cpu@
-build_os = @build_os@
-build_vendor = @build_vendor@
-builddir = @builddir@
-datadir = @datadir@
-datarootdir = @datarootdir@
-docdir = @docdir@
-dvidir = @dvidir@
-exec_prefix = @exec_prefix@
-host = @host@
-host_alias = @host_alias@
-host_cpu = @host_cpu@
-host_os = @host_os@
-host_vendor = @host_vendor@
-htmldir = @htmldir@
-includedir = @includedir@
-infodir = @infodir@
-install_sh = @install_sh@
-libdir = @libdir@
-libexecdir = @libexecdir@
-localedir = @localedir@
-localstatedir = @localstatedir@
-lt_ECHO = @lt_ECHO@
-mandir = @mandir@
-mkdir_p = @mkdir_p@
-oldincludedir = @oldincludedir@
-pdfdir = @pdfdir@
-prefix = @prefix@
-program_transform_name = @program_transform_name@
-psdir = @psdir@
-sbindir = @sbindir@
-sharedstatedir = @sharedstatedir@
-srcdir = @srcdir@
-sysconfdir = @sysconfdir@
-target_alias = @target_alias@
-top_build_prefix = @top_build_prefix@
-top_builddir = @top_builddir@
-top_srcdir = @top_srcdir@
-EXTRA_DIST = linux_kernel/main.c \
-                   linux_kernel/c2t1fs.h \
-                   linux_kernel/c2t1fs_loop.c
-
-all: all-am
-
-.SUFFIXES:
-$(srcdir)/Makefile.in:  $(srcdir)/Makefile.am  $(am__configure_deps)
-	@for dep in $?; do \
-	  case '$(am__configure_deps)' in \
-	    *$$dep*) \
-	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
-	        && { if test -f $@; then exit 0; else break; fi; }; \
-	      exit 1;; \
-	  esac; \
-	done; \
-	echo ' cd $(top_srcdir) && $(AUTOMAKE) --gnu c2t1fs/Makefile'; \
-	$(am__cd) $(top_srcdir) && \
-	  $(AUTOMAKE) --gnu c2t1fs/Makefile
-.PRECIOUS: Makefile
-Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
-	@case '$?' in \
-	  *config.status*) \
-	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
-	  *) \
-	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
-	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
-	esac;
-
-$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
-	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
-
-$(top_srcdir)/configure:  $(am__configure_deps)
-	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
-$(ACLOCAL_M4):  $(am__aclocal_m4_deps)
-	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
-$(am__aclocal_m4_deps):
-
-mostlyclean-libtool:
-	-rm -f *.lo
-
-clean-libtool:
-	-rm -rf .libs _libs
-tags: TAGS
-TAGS:
-
-ctags: CTAGS
-CTAGS:
-
-
-distdir: $(DISTFILES)
-	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
-	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
-	list='$(DISTFILES)'; \
-	  dist_files=`for file in $$list; do echo $$file; done | \
-	  sed -e "s|^$$srcdirstrip/||;t" \
-	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
-	case $$dist_files in \
-	  */*) $(MKDIR_P) `echo "$$dist_files" | \
-			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
-			   sort -u` ;; \
-	esac; \
-	for file in $$dist_files; do \
-	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
-	  if test -d $$d/$$file; then \
-	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
-	    if test -d "$(distdir)/$$file"; then \
-	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
-	    fi; \
-	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
-	      cp -fpR $(srcdir)/$$file "$(distdir)$$dir" || exit 1; \
-	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
-	    fi; \
-	    cp -fpR $$d/$$file "$(distdir)$$dir" || exit 1; \
-	  else \
-	    test -f "$(distdir)/$$file" \
-	    || cp -p $$d/$$file "$(distdir)/$$file" \
-	    || exit 1; \
-	  fi; \
-	done
-check-am: all-am
-check: check-am
-all-am: Makefile
-installdirs:
-install: install-am
-install-exec: install-exec-am
-install-data: install-data-am
-uninstall: uninstall-am
-
-install-am: all-am
-	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
-
-installcheck: installcheck-am
-install-strip:
-	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
-	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
-	  `test -z '$(STRIP)' || \
-	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
-mostlyclean-generic:
-
-clean-generic:
-
-distclean-generic:
-	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
-	-test . = "$(srcdir)" || test -z "$(CONFIG_CLEAN_VPATH_FILES)" || rm -f $(CONFIG_CLEAN_VPATH_FILES)
-
-maintainer-clean-generic:
-	@echo "This command is intended for maintainers to use"
-	@echo "it deletes files that may require special tools to rebuild."
-clean: clean-am
-
-clean-am: clean-generic clean-libtool mostlyclean-am
-
-distclean: distclean-am
-	-rm -f Makefile
-distclean-am: clean-am distclean-generic
-
-dvi: dvi-am
-
-dvi-am:
-
-html: html-am
-
-html-am:
-
-info: info-am
-
-info-am:
-
-install-data-am:
-
-install-dvi: install-dvi-am
-
-install-dvi-am:
-
-install-exec-am:
-
-install-html: install-html-am
-
-install-html-am:
-
-install-info: install-info-am
-
-install-info-am:
-
-install-man:
-
-install-pdf: install-pdf-am
-
-install-pdf-am:
-
-install-ps: install-ps-am
-
-install-ps-am:
-
-installcheck-am:
-
-maintainer-clean: maintainer-clean-am
-	-rm -f Makefile
-maintainer-clean-am: distclean-am maintainer-clean-generic
-
-mostlyclean: mostlyclean-am
-
-mostlyclean-am: mostlyclean-generic mostlyclean-libtool
-
-pdf: pdf-am
-
-pdf-am:
-
-ps: ps-am
-
-ps-am:
-
-uninstall-am:
-
-.MAKE: install-am install-strip
-
-.PHONY: all all-am check check-am clean clean-generic clean-libtool \
-	distclean distclean-generic distclean-libtool distdir dvi \
-	dvi-am html html-am info info-am install install-am \
-	install-data install-data-am install-dvi install-dvi-am \
-	install-exec install-exec-am install-html install-html-am \
-	install-info install-info-am install-man install-pdf \
-	install-pdf-am install-ps install-ps-am install-strip \
-	installcheck installcheck-am installdirs maintainer-clean \
-	maintainer-clean-generic mostlyclean mostlyclean-generic \
-	mostlyclean-libtool pdf pdf-am ps ps-am uninstall uninstall-am
-
-
-# Tell versions [3.59,3.63) of GNU make to not export all variables.
-# Otherwise a system limit (for SysV at least) may be exceeded.
-.NOEXPORT:
+C2T1FS_SRCDIR = @SRCDIR@/c2t1fs
+FOPDIR = @SRCDIR@/fop
+ADDBDIR = @SRCDIR@/addb
+STOBDIR = @SRCDIR@/stob/ut
+GALOISDIR = @SRCDIR@/../galois
+IOSERVICEDIR = @SRCDIR@/ioservice
+
+obj-m := c2t1fs.o c2t1fs_loop.o 
+c2t1fs-y := main.o io_k.o io_fops_k.o io_foms.o io_fops.o io_fop_init.o addb_store.o addb_k.o
+
+EXTRA_CFLAGS = -DHAVE_CONFIG_H -I@SRCDIR@ @KCFLAGS@
+
+prepare: io_k.h io_k.c addb_k.c addb_k.h
+	sh $(FOPDIR)/fop2c -k $(STOBDIR)/io.ff 
+
+	ln -sf $(STOBDIR)/io_fop_init.c .
+	ln -sf $(ADDBDIR)/addb_store.c .
+	ln -sf $(GALOISDIR)/galois.h @SRCDIR@/sns
+	ln -sf $(IOSERVICEDIR)/io_fops_k.h
+	ln -sf $(IOSERVICEDIR)/io_fops_k.c
+	ln -sf $(IOSERVICEDIR)/io_fops.h
+	ln -sf $(IOSERVICEDIR)/io_foms.h
+	ln -sf $(IOSERVICEDIR)/io_foms.c
+	ln -sf $(IOSERVICEDIR)/io_fops.c
+
+io_k.h io_k.c: $(STOBDIR)/io.ff
+	$(FOPDIR)/fop2c -k $(STOBDIR)/io.ff
+
+addb_k.h addb_k.c: $(ADDBDIR)/addb.ff
+	$(FOPDIR)/fop2c -k $(ADDBDIR)/addb.ff
+
+install modules_install:
+	$(MAKE) INSTALL_MOD_DIR=kernel/fs/c2t1fs -C @LINUX_OBJ@ M=`pwd` modules_install
+
+uninstall:
+	rm -fr @LINUX_MOD@/kernel/fs/c2t1fs
+
+distclean clean:
+	$(MAKE) -C @LINUX_OBJ@ M=`pwd` clean;
+	rm -fr Module.symvers io_k.[ch] io_fop_init.c
+	rm -fr @SRCDIR@/sns/galois.h
+	rm -rf io_fops_k.* io_fops.* io_foms.*
+	rm -rf fop_types.h
+
+distdir:
+	cp $(C2T1FS_SRCDIR)/Makefile.in $(C2T1FS_SRCDIR)/c2t1fs.h \
+$(C2T1FS_SRCDIR)/c2t1fs_loop.c $(C2T1FS_SRCDIR)/main.c \
+@top_builddir@/@PACKAGE@-@VERSION@/c2t1fs
diff --git a/c2t1fs/linux_kernel/.gitignore b/c2t1fs/linux_kernel/.gitignore
deleted file mode 100644
index 7aeb47d..0000000
--- a/c2t1fs/linux_kernel/.gitignore
+++ /dev/null
@@ -1,7 +0,0 @@
-io_k.[ch]
-io_fop_init.c
-addb_k.[ch]
-addb_store.c
-io_foms.[ch]
-io_fops.[ch]
-io_fops_k.[ch]
diff --git a/c2t1fs/linux_kernel/c2t1fs.h b/c2t1fs/linux_kernel/c2t1fs.h
deleted file mode 100644
index 30b16ea..0000000
--- a/c2t1fs/linux_kernel/c2t1fs.h
+++ /dev/null
@@ -1,135 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Yuriy Umanets <yuriy_umanets@xyratex.com>
- *		    Huang Hua <hua_huang@xyratex.com>
- * Original creation date: 05/03/2010
- */
-
-#ifndef __COLIBRI_C2T1FS_H
-#define __COLIBRI_C2T1FS_H
-
-#include <linux/in.h> /* for sockaddr_in */
-#include <linux/fs.h> /* inode */
-
-#include "lib/list.h"
-#include "net/net.h"
-#include "config.h"
-
-#define C2T1FS_DEBUG 1
-#ifdef C2T1FS_DEBUG
-#define ENTER   printk("Enter into function %s\n", __FUNCTION__)
-#define LEAVE   printk("Leave function %s\n", __FUNCTION__)
-#define GETHERE printk("Get %s line %d\n", __FUNCTION__, __LINE__)
-#else
-#define ENTER
-#define LEAVE
-#define GETHERE
-#endif
-
-#define s2csi(sb)       \
-        ((struct c2t1fs_sb_info *)((sb)->s_fs_info))
-
-#define s2csi_nocast(sb) \
-        ((sb)->s_fs_info)
-
-/* 0x\C\2\T\1 */
-#define C2T1FS_SUPER_MAGIC    0x43325431
-#define C2T1FS_ROOT_INODE     0x10000000
-#define C2T1FS_INIT_OBJSIZE   (4 << 20)
-
-#define C2TIME_S(time)        (time.tv_sec)
-
-/* 1M */
-#define C2_MAX_BRW_BITS       (20)
-
-/* 4*1M */
-#define C2_MAX_BLKSIZE_BITS   (22)
-
-#ifndef log2
-#define log2(n) ffz(~(n))
-#endif
-
-enum {
-	/* for now, 4k page size for ksunrpc_{read,write}(...) */
-	C2T1FS_DEFAULT_UNIT_SIZE = 4096
-};
-
-/**
-   This is the data structure to describe a client transport,
-   identified by its container id.
-*/
-struct c2t1fs_conn_clt {
-	/** container id */
-	uint64_t                  xc_cid;
-
-	/** node service id on which this container is running */
-        struct c2_service_id      xc_srvid;
-
-	/** the connection for this container */
-        struct c2_net_conn       *xc_conn;
-
-	/** linkage in hash table */
-	struct c2_list_link       xc_link;
-};
-
-/**
-   Object parameter on client.
-
-   This object is shown on client and can be read from and written to.
-   Also this object can be exported by loop device.
-*/
-struct c2t1fs_object_param {
-        uint64_t        cop_objid;    /*< The object id will be mapped */
-        uint64_t        cop_objsize;  /*< The initial object size */
-        uint64_t        cop_layoutid; /*< layout id this client uses */
-	c2_bcount_t     cop_unitsize; /*< data or parity unit size in bytes */
-
-	struct c2_pdclust_layout *cop_play; /*< parity de-clustered layout */
-};
-
-struct c2t1fs_sb_info {
-        atomic_t        csi_mounts;
-        int             csi_flags;
-
-	struct c2t1fs_object_param csi_object_param; /*< the object on client */
-
-        struct c2_service_id  csi_mgmt_srvid; /*< mgmt node service id */
-        struct c2_net_conn   *csi_mgmt_conn;  /*< mgmt node xprt */
-
-        struct c2_list  csi_conn_list; /*< transport list or hash table */
-        struct c2_mutex csi_mutex;      /*< mutex to protect this sb */
-
-	struct c2_net_domain csi_net_domain;
-};
-
-struct c2t1fs_inode_info {
-        struct inode    cii_vfs_inode;
-};
-
-int c2t1fs_init_module(void);
-void c2t1fs_cleanup_module(void);
-
-#endif
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
diff --git a/c2t1fs/linux_kernel/c2t1fs_loop.c b/c2t1fs/linux_kernel/c2t1fs_loop.c
deleted file mode 100644
index 17f65a9..0000000
--- a/c2t1fs/linux_kernel/c2t1fs_loop.c
+++ /dev/null
@@ -1,1546 +0,0 @@
-/*
- *  linux/drivers/block/loop.c
- *
- *  Written by Theodore Ts'o, 3/29/93
- *
- * Copyright 1993 by Theodore Ts'o.  Redistribution of this file is
- * permitted under the GNU General Public License.
- *
- * DES encryption plus some minor changes by Werner Almesberger, 30-MAY-1993
- * more DES encryption plus IDEA encryption by Nicholas J. Leon, June 20, 1996
- *
- * Modularized and updated for 1.1.16 kernel - Mitch Dsouza 28th May 1994
- * Adapted for 1.3.59 kernel - Andries Brouwer, 1 Feb 1996
- *
- * Fixed do_loop_request() re-entrancy - Vincent.Renardias@waw.com Mar 20, 1997
- *
- * Added devfs support - Richard Gooch <rgooch@atnf.csiro.au> 16-Jan-1998
- *
- * Handle sparse backing files correctly - Kenn Humborg, Jun 28, 1998
- *
- * Loadable modules and other fixes by AK, 1998
- *
- * Make real block number available to downstream transfer functions, enables
- * CBC (and relatives) mode encryption requiring unique IVs per data block.
- * Reed H. Petty, rhp@draper.net
- *
- * Maximum number of loop devices now dynamic via max_loop module parameter.
- * Russell Kroll <rkroll@exploits.org> 19990701
- *
- * Maximum number of loop devices when compiled-in now selectable by passing
- * max_loop=<1-255> to the kernel on boot.
- * Erik I. Bolsø, <eriki@himolde.no>, Oct 31, 1999
- *
- * Completely rewrite request handling to be make_request_fn style and
- * non blocking, pushing work to a helper thread. Lots of fixes from
- * Al Viro too.
- * Jens Axboe <axboe@suse.de>, Nov 2000
- *
- * Support up to 256 loop devices
- * Heinz Mauelshagen <mge@sistina.com>, Feb 2002
- *
- * Support for falling back on the write file operation when the address space
- * operations write_begin is not available on the backing filesystem.
- * Anton Altaparmakov, 16 Feb 2005
- *
- * Still To Fix:
- * - Advisory locking is ignored here.
- * - Should use an own CAP_* category instead of CAP_SYS_ADMIN
- *
- */
-
-#include <linux/module.h>
-#include <linux/moduleparam.h>
-#include <linux/sched.h>
-#include <linux/fs.h>
-#include <linux/file.h>
-#include <linux/stat.h>
-#include <linux/major.h>
-#include <linux/wait.h>
-#include <linux/blkdev.h>
-#include <linux/blkpg.h>
-#include <linux/init.h>
-#include <linux/swap.h>
-#include <linux/slab.h>
-#include <linux/loop.h>
-#include <linux/compat.h>
-#include <linux/suspend.h>
-#include <linux/freezer.h>
-#include <linux/writeback.h>
-#include <linux/buffer_head.h>		/* for invalidate_bdev() */
-#include <linux/completion.h>
-#include <linux/highmem.h>
-#include <linux/kthread.h>
-#include <linux/splice.h>
-
-#include <asm/uaccess.h>
-
-#include "lib/misc.h"   /* C2_SET0 */
-#include "lib/errno.h"
-#include "lib/cdefs.h"    /* C2_EXPORTED */
-#include "c2t1fs/linux_kernel/c2t1fs.h"
-
-static LIST_HEAD(loop_devices);
-static DEFINE_MUTEX(loop_devices_mutex);
-
-static int max_part;
-static int part_shift;
-
-/*
- * Transfer functions
- */
-static int transfer_none(struct loop_device *lo, int cmd,
-			 struct page *raw_page, unsigned raw_off,
-			 struct page *loop_page, unsigned loop_off,
-			 int size, sector_t real_block)
-{
-	char *raw_buf = kmap_atomic(raw_page, KM_USER0) + raw_off;
-	char *loop_buf = kmap_atomic(loop_page, KM_USER1) + loop_off;
-
-	if (cmd == READ)
-		memcpy(loop_buf, raw_buf, size);
-	else
-		memcpy(raw_buf, loop_buf, size);
-
-	kunmap_atomic(raw_buf, KM_USER0);
-	kunmap_atomic(loop_buf, KM_USER1);
-	cond_resched();
-	return 0;
-}
-
-static int transfer_xor(struct loop_device *lo, int cmd,
-			struct page *raw_page, unsigned raw_off,
-			struct page *loop_page, unsigned loop_off,
-			int size, sector_t real_block)
-{
-	char *raw_buf = kmap_atomic(raw_page, KM_USER0) + raw_off;
-	char *loop_buf = kmap_atomic(loop_page, KM_USER1) + loop_off;
-	char *in, *out, *key;
-	int i, keysize;
-
-	if (cmd == READ) {
-		in = raw_buf;
-		out = loop_buf;
-	} else {
-		in = loop_buf;
-		out = raw_buf;
-	}
-
-	key = lo->lo_encrypt_key;
-	keysize = lo->lo_encrypt_key_size;
-	for (i = 0; i < size; i++)
-		*out++ = *in++ ^ key[(i & 511) % keysize];
-
-	kunmap_atomic(raw_buf, KM_USER0);
-	kunmap_atomic(loop_buf, KM_USER1);
-	cond_resched();
-	return 0;
-}
-
-static int xor_init(struct loop_device *lo, const struct loop_info64 *info)
-{
-	if (unlikely(info->lo_encrypt_key_size <= 0))
-		return -EINVAL;
-	return 0;
-}
-
-static struct loop_func_table none_funcs = {
-	.number = LO_CRYPT_NONE,
-	.transfer = transfer_none,
-}; 	
-
-static struct loop_func_table xor_funcs = {
-	.number = LO_CRYPT_XOR,
-	.transfer = transfer_xor,
-	.init = xor_init
-}; 	
-
-/* xfer_funcs[0] is special - its release function is never called */
-static struct loop_func_table *xfer_funcs[MAX_LO_CRYPT] = {
-	&none_funcs,
-	&xor_funcs
-};
-
-static loff_t get_loop_size(struct loop_device *lo, struct file *file)
-{
-	loff_t size, offset, loopsize;
-
-	/* Compute loopsize in bytes */
-	size = i_size_read(file->f_mapping->host);
-	offset = lo->lo_offset;
-	loopsize = size - offset;
-	if (lo->lo_sizelimit > 0 && lo->lo_sizelimit < loopsize)
-		loopsize = lo->lo_sizelimit;
-
-	/*
-	 * Unfortunately, if we want to do I/O on the device,
-	 * the number of 512-byte sectors has to fit into a sector_t.
-	 */
-	return loopsize >> 9;
-}
-
-static int
-figure_loop_size(struct loop_device *lo)
-{
-	loff_t size = get_loop_size(lo, lo->lo_backing_file);
-	sector_t x = (sector_t)size;
-
-	if (unlikely((loff_t)x != size))
-		return -EFBIG;
-
-	set_capacity(lo->lo_disk, x);
-	return 0;					
-}
-
-static inline int
-lo_do_transfer(struct loop_device *lo, int cmd,
-	       struct page *rpage, unsigned roffs,
-	       struct page *lpage, unsigned loffs,
-	       int size, sector_t rblock)
-{
-	if (unlikely(!lo->transfer))
-		return 0;
-
-	return lo->transfer(lo, cmd, rpage, roffs, lpage, loffs, size, rblock);
-}
-
-#if 0
-/**
- * do_lo_send_aops - helper for writing data to a loop device
- *
- * This is the fast version for backing filesystems which implement the address
- * space operations write_begin and write_end.
- */
-static int do_lo_send_aops(struct loop_device *lo, struct bio_vec *bvec,
-		loff_t pos, struct page *unused)
-{
-	struct file *file = lo->lo_backing_file; /* kudos to NFsckingS */
-	struct address_space *mapping = file->f_mapping;
-	pgoff_t index;
-	unsigned offset, bv_offs;
-	int len, ret;
-
-	mutex_lock(&mapping->host->i_mutex);
-	index = pos >> PAGE_CACHE_SHIFT;
-	offset = pos & ((pgoff_t)PAGE_CACHE_SIZE - 1);
-	bv_offs = bvec->bv_offset;
-	len = bvec->bv_len;
-	while (len > 0) {
-		sector_t IV;
-		unsigned size, copied;
-		int transfer_result;
-		struct page *page;
-		void *fsdata;
-
-		IV = ((sector_t)index << (PAGE_CACHE_SHIFT - 9))+(offset >> 9);
-		size = PAGE_CACHE_SIZE - offset;
-		if (size > len)
-			size = len;
-
-		ret = pagecache_write_begin(file, mapping, pos, size, 0,
-							&page, &fsdata);
-		if (ret)
-			goto fail;
-
-		file_update_time(file);
-
-		transfer_result = lo_do_transfer(lo, WRITE, page, offset,
-				bvec->bv_page, bv_offs, size, IV);
-		copied = size;
-		if (unlikely(transfer_result))
-			copied = 0;
-
-		ret = pagecache_write_end(file, mapping, pos, size, copied,
-							page, fsdata);
-		if (ret < 0 || ret != copied)
-			goto fail;
-
-		if (unlikely(transfer_result))
-			goto fail;
-
-		bv_offs += copied;
-		len -= copied;
-		offset = 0;
-		index++;
-		pos += copied;
-	}
-	ret = 0;
-out:
-	mutex_unlock(&mapping->host->i_mutex);
-	return ret;
-fail:
-	ret = -1;
-	goto out;
-}
-
-/**
- * __do_lo_send_write - helper for writing data to a loop device
- *
- * This helper just factors out common code between do_lo_send_direct_write()
- * and do_lo_send_write().
- */
-static int __do_lo_send_write(struct file *file,
-		u8 *buf, const int len, loff_t pos)
-{
-	ssize_t bw;
-	mm_segment_t old_fs = get_fs();
-
-	set_fs(get_ds());
-	bw = file->f_op->write(file, buf, len, &pos);
-	set_fs(old_fs);
-	if (likely(bw == len))
-		return 0;
-	printk(KERN_ERR "loop: Write error at byte offset %llu, length %i.\n",
-			(unsigned long long)pos, len);
-	if (bw >= 0)
-		bw = -EIO;
-	return bw;
-}
-
-/**
- * do_lo_send_direct_write - helper for writing data to a loop device
- *
- * This is the fast, non-transforming version for backing filesystems which do
- * not implement the address space operations write_begin and write_end.
- * It uses the write file operation which should be present on all writeable
- * filesystems.
- */
-static int do_lo_send_direct_write(struct loop_device *lo,
-		struct bio_vec *bvec, loff_t pos, struct page *page)
-{
-	ssize_t bw = __do_lo_send_write(lo->lo_backing_file,
-			kmap(bvec->bv_page) + bvec->bv_offset,
-			bvec->bv_len, pos);
-	kunmap(bvec->bv_page);
-	cond_resched();
-	return bw;
-}
-
-/**
- * do_lo_send_write - helper for writing data to a loop device
- *
- * This is the slow, transforming version for filesystems which do not
- * implement the address space operations write_begin and write_end.  It
- * uses the write file operation which should be present on all writeable
- * filesystems.
- *
- * Using fops->write is slower than using aops->{prepare,commit}_write in the
- * transforming case because we need to double buffer the data as we cannot do
- * the transformations in place as we do not have direct access to the
- * destination pages of the backing file.
- */
-static int do_lo_send_write(struct loop_device *lo, struct bio_vec *bvec,
-		loff_t pos, struct page *page)
-{
-	int ret = lo_do_transfer(lo, WRITE, page, 0, bvec->bv_page,
-			bvec->bv_offset, bvec->bv_len, pos >> 9);
-	if (likely(!ret))
-		return __do_lo_send_write(lo->lo_backing_file,
-				page_address(page), bvec->bv_len,
-				pos);
-	printk(KERN_ERR "loop: Transfer error at byte offset %llu, "
-			"length %i.\n", (unsigned long long)pos, bvec->bv_len);
-	if (ret > 0)
-		ret = -EIO;
-	return ret;
-}
-#endif
-
-static struct iovec iov_static[BIO_MAX_PAGES];
-static int do_bio_filebacked(struct loop_device *lo, struct bio *bio)
-{
-	loff_t pos;
-	struct file *file = lo->lo_backing_file;
-	struct iovec *iov;
- 	struct bio_vec *bvec;
-	int i;
-	int j = 0;
-	ssize_t bw;
-	struct kiocb kiocb;
-	mm_segment_t old_fs = get_fs();
-
-	init_sync_kiocb(&kiocb, file);
-	kiocb.ki_nbytes = kiocb.ki_left = bio->bi_size;
-
-	pos = ((loff_t) bio->bi_sector << 9) + lo->lo_offset;
-        kiocb.ki_pos = pos;
- 	bio_for_each_segment(bvec, bio, i) {
-		iov = &iov_static[j++];
-		iov->iov_base = page_address(bvec->bv_page) + bvec->bv_offset;
-		iov->iov_len = bvec->bv_len;
- 	}
-
-	set_fs(get_ds());
-	bw = (bio_rw(bio) == READ ? file->f_op->aio_read : file->f_op->aio_write)
-		(&kiocb, iov_static, j, pos);
-	set_fs(old_fs);
-	if (likely(bio->bi_size == bw))
-		return 0;
-	return -EIO;
-}
- 
-
-/*
- * Add bio to back of pending list
- */
-static void loop_add_bio(struct loop_device *lo, struct bio *bio)
-{
-	bio_list_add(&lo->lo_bio_list, bio);
-}
-
-/*
- * Grab first pending buffer
- */
-static struct bio *loop_get_bio(struct loop_device *lo)
-{
-	return bio_list_pop(&lo->lo_bio_list);
-}
-
-static int loop_make_request(struct request_queue *q, struct bio *old_bio)
-{
-	struct loop_device *lo = q->queuedata;
-	int rw = bio_rw(old_bio);
-
-	if (rw == READA)
-		rw = READ;
-
-	BUG_ON(!lo || (rw != READ && rw != WRITE));
-
-	spin_lock_irq(&lo->lo_lock);
-	if (lo->lo_state != Lo_bound)
-		goto out;
-	if (unlikely(rw == WRITE && (lo->lo_flags & LO_FLAGS_READ_ONLY)))
-		goto out;
-	loop_add_bio(lo, old_bio);
-	wake_up(&lo->lo_event);
-	spin_unlock_irq(&lo->lo_lock);
-	return 0;
-
-out:
-	spin_unlock_irq(&lo->lo_lock);
-	bio_io_error(old_bio);
-	return 0;
-}
-
-/*
- * kick off io on the underlying address space
- */
-static void loop_unplug(struct request_queue *q)
-{
-	struct loop_device *lo = q->queuedata;
-
-	queue_flag_clear_unlocked(QUEUE_FLAG_PLUGGED, q);
-	blk_run_address_space(lo->lo_backing_file->f_mapping);
-}
-
-struct switch_request {
-	struct file *file;
-	struct completion wait;
-};
-
-static void do_loop_switch(struct loop_device *, struct switch_request *);
-
-static inline void loop_handle_bio(struct loop_device *lo, struct bio *bio)
-{
-	if (unlikely(!bio->bi_bdev)) {
-		do_loop_switch(lo, bio->bi_private);
-		bio_put(bio);
-	} else {
-		int ret = do_bio_filebacked(lo, bio);
-		bio_endio(bio, ret);
-	}
-}
-
-/*
- * worker thread that handles reads/writes to file backed loop devices,
- * to avoid blocking in our make_request_fn. it also does loop decrypting
- * on reads for block backed loop, as that is too heavy to do from
- * b_end_io context where irqs may be disabled.
- *
- * Loop explanation:  loop_clr_fd() sets lo_state to Lo_rundown before
- * calling kthread_stop().  Therefore once kthread_should_stop() is
- * true, make_request will not place any more requests.  Therefore
- * once kthread_should_stop() is true and lo_bio is NULL, we are
- * done with the loop.
- */
-static int loop_thread(void *data)
-{
-	struct loop_device *lo = data;
-	struct bio *bio;
-
-	set_user_nice(current, -20);
-
-	while (!kthread_should_stop() || !bio_list_empty(&lo->lo_bio_list)) {
-
-		wait_event_interruptible(lo->lo_event,
-				!bio_list_empty(&lo->lo_bio_list) ||
-				kthread_should_stop());
-
-		if (bio_list_empty(&lo->lo_bio_list))
-			continue;
-		spin_lock_irq(&lo->lo_lock);
-		bio = loop_get_bio(lo);
-		spin_unlock_irq(&lo->lo_lock);
-
-		BUG_ON(!bio);
-		loop_handle_bio(lo, bio);
-	}
-
-	return 0;
-}
-
-/*
- * loop_switch performs the hard work of switching a backing store.
- * First it needs to flush existing IO, it does this by sending a magic
- * BIO down the pipe. The completion of this BIO does the actual switch.
- */
-static int loop_switch(struct loop_device *lo, struct file *file)
-{
-	struct switch_request w;
-	struct bio *bio = bio_alloc(GFP_KERNEL, 0);
-	if (!bio)
-		return -ENOMEM;
-	init_completion(&w.wait);
-	w.file = file;
-	bio->bi_private = &w;
-	bio->bi_bdev = NULL;
-	loop_make_request(lo->lo_queue, bio);
-	wait_for_completion(&w.wait);
-	return 0;
-}
-
-/*
- * Helper to flush the IOs in loop, but keeping loop thread running
- */
-static int loop_flush(struct loop_device *lo)
-{
-	/* loop not yet configured, no running thread, nothing to flush */
-	if (!lo->lo_thread)
-		return 0;
-
-	return loop_switch(lo, NULL);
-}
-
-/*
- * Do the actual switch; called from the BIO completion routine
- */
-static void do_loop_switch(struct loop_device *lo, struct switch_request *p)
-{
-	struct file *file = p->file;
-	struct file *old_file = lo->lo_backing_file;
-	struct address_space *mapping;
-
-	/* if no new file, only flush of queued bios requested */
-	if (!file)
-		goto out;
-
-	mapping = file->f_mapping;
-	mapping_set_gfp_mask(old_file->f_mapping, lo->old_gfp_mask);
-	lo->lo_backing_file = file;
-	lo->lo_blocksize = S_ISBLK(mapping->host->i_mode) ?
-		mapping->host->i_bdev->bd_block_size : PAGE_SIZE;
-	lo->old_gfp_mask = mapping_gfp_mask(mapping);
-	mapping_set_gfp_mask(mapping, lo->old_gfp_mask & ~(__GFP_IO|__GFP_FS));
-out:
-	complete(&p->wait);
-}
-
-
-/*
- * loop_change_fd switched the backing store of a loopback device to
- * a new file. This is useful for operating system installers to free up
- * the original file and in High Availability environments to switch to
- * an alternative location for the content in case of server meltdown.
- * This can only work if the loop device is used read-only, and if the
- * new backing store is the same size and type as the old backing store.
- */
-static int loop_change_fd(struct loop_device *lo, struct block_device *bdev,
-			  unsigned int arg)
-{
-	struct file	*file, *old_file;
-	struct inode	*inode;
-	int		error;
-
-	error = -ENXIO;
-	if (lo->lo_state != Lo_bound)
-		goto out;
-
-	/* the loop device has to be read-only */
-	error = -EINVAL;
-	if (!(lo->lo_flags & LO_FLAGS_READ_ONLY))
-		goto out;
-
-	error = -EBADF;
-	file = fget(arg);
-	if (!file)
-		goto out;
-
-	inode = file->f_mapping->host;
-	old_file = lo->lo_backing_file;
-
-	error = -EINVAL;
-
-	if (!S_ISREG(inode->i_mode) && !S_ISBLK(inode->i_mode))
-		goto out_putf;
-
-	/* size of the new backing store needs to be the same */
-	if (get_loop_size(lo, file) != get_loop_size(lo, old_file))
-		goto out_putf;
-
-	/* and ... switch */
-	error = loop_switch(lo, file);
-	if (error)
-		goto out_putf;
-
-	fput(old_file);
-	if (max_part > 0)
-		ioctl_by_bdev(bdev, BLKRRPART, 0);
-	return 0;
-
- out_putf:
-	fput(file);
- out:
-	return error;
-}
-
-static inline int is_loop_device(struct file *file)
-{
-	struct inode *i = file->f_mapping->host;
-
-	return i && S_ISBLK(i->i_mode) && MAJOR(i->i_rdev) == LOOP_MAJOR;
-}
-
-static int loop_set_fd(struct loop_device *lo, fmode_t mode,
-		       struct block_device *bdev, unsigned int arg)
-{
-	struct file	*file, *f;
-	struct inode	*inode;
-	struct address_space *mapping;
-	unsigned lo_blocksize;
-	int		lo_flags = 0;
-	int		error;
-	loff_t		size;
-
-	/* This is safe, since we have a reference from open(). */
-	__module_get(THIS_MODULE);
-
-	error = -EBADF;
-	file = fget(arg);
-	if (!file)
-		goto out;
-
-	error = -EBUSY;
-	if (lo->lo_state != Lo_unbound)
-		goto out_putf;
-
-	/* Avoid recursion */
-	f = file;
-	while (is_loop_device(f)) {
-		struct loop_device *l;
-
-		if (f->f_mapping->host->i_bdev == bdev)
-			goto out_putf;
-
-		l = f->f_mapping->host->i_bdev->bd_disk->private_data;
-		if (l->lo_state == Lo_unbound) {
-			error = -EINVAL;
-			goto out_putf;
-		}
-		f = l->lo_backing_file;
-	}
-
-	mapping = file->f_mapping;
-	inode = mapping->host;
-
-	if (!(file->f_mode & FMODE_WRITE))
-		lo_flags |= LO_FLAGS_READ_ONLY;
-
-	error = -EINVAL;
-	if (S_ISREG(inode->i_mode) || S_ISBLK(inode->i_mode)) {
-		const struct address_space_operations *aops = mapping->a_ops;
-
-		if (aops->write_begin)
-			lo_flags |= LO_FLAGS_USE_AOPS;
-		if (!(lo_flags & LO_FLAGS_USE_AOPS) && !file->f_op->write)
-			lo_flags |= LO_FLAGS_READ_ONLY;
-
-		lo_blocksize = S_ISBLK(inode->i_mode) ?
-			inode->i_bdev->bd_block_size : PAGE_SIZE;
-
-		error = 0;
-	} else {
-		goto out_putf;
-	}
-
-	size = get_loop_size(lo, file);
-
-	if ((loff_t)(sector_t)size != size) {
-		error = -EFBIG;
-		goto out_putf;
-	}
-
-	if (!(mode & FMODE_WRITE))
-		lo_flags |= LO_FLAGS_READ_ONLY;
-
-	set_device_ro(bdev, (lo_flags & LO_FLAGS_READ_ONLY) != 0);
-
-	lo->lo_blocksize = lo_blocksize;
-	lo->lo_device = bdev;
-	lo->lo_flags = lo_flags;
-	lo->lo_backing_file = file;
-	lo->transfer = transfer_none;
-	lo->ioctl = NULL;
-	lo->lo_sizelimit = 0;
-	lo->old_gfp_mask = mapping_gfp_mask(mapping);
-	mapping_set_gfp_mask(mapping, lo->old_gfp_mask & ~(__GFP_IO|__GFP_FS));
-
-	bio_list_init(&lo->lo_bio_list);
-
-	/*
-	 * set queue make_request_fn, and add limits based on lower level
-	 * device
-	 */
-	blk_queue_make_request(lo->lo_queue, loop_make_request);
-	lo->lo_queue->queuedata = lo;
-	lo->lo_queue->unplug_fn = loop_unplug;
-
-	if (!(lo_flags & LO_FLAGS_READ_ONLY) && file->f_op->fsync)
-		blk_queue_ordered(lo->lo_queue, QUEUE_ORDERED_DRAIN, NULL);
-
-	set_capacity(lo->lo_disk, size);
-	bd_set_size(bdev, size << 9);
-
-	set_blocksize(bdev, lo_blocksize);
-
-	lo->lo_thread = kthread_create(loop_thread, lo, "loop%d",
-						lo->lo_number);
-	if (IS_ERR(lo->lo_thread)) {
-		error = PTR_ERR(lo->lo_thread);
-		goto out_clr;
-	}
-	lo->lo_state = Lo_bound;
-	wake_up_process(lo->lo_thread);
-	if (max_part > 0)
-		ioctl_by_bdev(bdev, BLKRRPART, 0);
-	return 0;
-
-out_clr:
-	lo->lo_thread = NULL;
-	lo->lo_device = NULL;
-	lo->lo_backing_file = NULL;
-	lo->lo_flags = 0;
-	set_capacity(lo->lo_disk, 0);
-	invalidate_bdev(bdev);
-	bd_set_size(bdev, 0);
-	mapping_set_gfp_mask(mapping, lo->old_gfp_mask);
-	lo->lo_state = Lo_unbound;
- out_putf:
-	fput(file);
- out:
-	/* This is safe: open() is still holding a reference. */
-	module_put(THIS_MODULE);
-	return error;
-}
-
-static int
-loop_release_xfer(struct loop_device *lo)
-{
-	int err = 0;
-	struct loop_func_table *xfer = lo->lo_encryption;
-
-	if (xfer) {
-		if (xfer->release)
-			err = xfer->release(lo);
-		lo->transfer = NULL;
-		lo->lo_encryption = NULL;
-		module_put(xfer->owner);
-	}
-	return err;
-}
-
-static int
-loop_init_xfer(struct loop_device *lo, struct loop_func_table *xfer,
-	       const struct loop_info64 *i)
-{
-	int err = 0;
-
-	if (xfer) {
-		struct module *owner = xfer->owner;
-
-		if (!try_module_get(owner))
-			return -EINVAL;
-		if (xfer->init)
-			err = xfer->init(lo, i);
-		if (err)
-			module_put(owner);
-		else
-			lo->lo_encryption = xfer;
-	}
-	return err;
-}
-
-static int loop_clr_fd(struct loop_device *lo, struct block_device *bdev)
-{
-	struct file *filp = lo->lo_backing_file;
-	gfp_t gfp = lo->old_gfp_mask;
-
-	if (lo->lo_state != Lo_bound)
-		return -ENXIO;
-
-	if (lo->lo_refcnt > 1)	/* we needed one fd for the ioctl */
-		return -EBUSY;
-
-	if (filp == NULL)
-		return -EINVAL;
-
-	spin_lock_irq(&lo->lo_lock);
-	lo->lo_state = Lo_rundown;
-	spin_unlock_irq(&lo->lo_lock);
-
-	kthread_stop(lo->lo_thread);
-
-	lo->lo_queue->unplug_fn = NULL;
-	lo->lo_backing_file = NULL;
-
-	loop_release_xfer(lo);
-	lo->transfer = NULL;
-	lo->ioctl = NULL;
-	lo->lo_device = NULL;
-	lo->lo_encryption = NULL;
-	lo->lo_offset = 0;
-	lo->lo_sizelimit = 0;
-	lo->lo_encrypt_key_size = 0;
-	lo->lo_flags = 0;
-	lo->lo_thread = NULL;
-	memset(lo->lo_encrypt_key, 0, LO_KEY_SIZE);
-	memset(lo->lo_crypt_name, 0, LO_NAME_SIZE);
-	memset(lo->lo_file_name, 0, LO_NAME_SIZE);
-	if (bdev)
-		invalidate_bdev(bdev);
-	set_capacity(lo->lo_disk, 0);
-	if (bdev)
-		bd_set_size(bdev, 0);
-	mapping_set_gfp_mask(filp->f_mapping, gfp);
-	lo->lo_state = Lo_unbound;
-	/* This is safe: open() is still holding a reference. */
-	module_put(THIS_MODULE);
-	if (max_part > 0 && bdev)
-		ioctl_by_bdev(bdev, BLKRRPART, 0);
-	mutex_unlock(&lo->lo_ctl_mutex);
-	/*
-	 * Need not hold lo_ctl_mutex to fput backing file.
-	 * Calling fput holding lo_ctl_mutex triggers a circular
-	 * lock dependency possibility warning as fput can take
-	 * bd_mutex which is usually taken before lo_ctl_mutex.
-	 */
-	fput(filp);
-	return 0;
-}
-
-static int
-loop_set_status(struct loop_device *lo, const struct loop_info64 *info)
-{
-	int err;
-	struct loop_func_table *xfer;
-	uid_t uid = current_uid();
-
-	if (lo->lo_encrypt_key_size &&
-	    lo->lo_key_owner != uid &&
-	    !capable(CAP_SYS_ADMIN))
-		return -EPERM;
-	if (lo->lo_state != Lo_bound)
-		return -ENXIO;
-	if ((unsigned int) info->lo_encrypt_key_size > LO_KEY_SIZE)
-		return -EINVAL;
-
-	err = loop_release_xfer(lo);
-	if (err)
-		return err;
-
-	if (info->lo_encrypt_type) {
-		unsigned int type = info->lo_encrypt_type;
-
-		if (type >= MAX_LO_CRYPT)
-			return -EINVAL;
-		xfer = xfer_funcs[type];
-		if (xfer == NULL)
-			return -EINVAL;
-	} else
-		xfer = NULL;
-
-	err = loop_init_xfer(lo, xfer, info);
-	if (err)
-		return err;
-
-	if (lo->lo_offset != info->lo_offset ||
-	    lo->lo_sizelimit != info->lo_sizelimit) {
-		lo->lo_offset = info->lo_offset;
-		lo->lo_sizelimit = info->lo_sizelimit;
-		if (figure_loop_size(lo))
-			return -EFBIG;
-	}
-
-	memcpy(lo->lo_file_name, info->lo_file_name, LO_NAME_SIZE);
-	memcpy(lo->lo_crypt_name, info->lo_crypt_name, LO_NAME_SIZE);
-	lo->lo_file_name[LO_NAME_SIZE-1] = 0;
-	lo->lo_crypt_name[LO_NAME_SIZE-1] = 0;
-
-	if (!xfer)
-		xfer = &none_funcs;
-	lo->transfer = xfer->transfer;
-	lo->ioctl = xfer->ioctl;
-
-	if ((lo->lo_flags & LO_FLAGS_AUTOCLEAR) !=
-	     (info->lo_flags & LO_FLAGS_AUTOCLEAR))
-		lo->lo_flags ^= LO_FLAGS_AUTOCLEAR;
-
-	lo->lo_encrypt_key_size = info->lo_encrypt_key_size;
-	lo->lo_init[0] = info->lo_init[0];
-	lo->lo_init[1] = info->lo_init[1];
-	if (info->lo_encrypt_key_size) {
-		memcpy(lo->lo_encrypt_key, info->lo_encrypt_key,
-		       info->lo_encrypt_key_size);
-		lo->lo_key_owner = uid;
-	}	
-
-	return 0;
-}
-
-static int
-loop_get_status(struct loop_device *lo, struct loop_info64 *info)
-{
-	struct file *file = lo->lo_backing_file;
-	struct kstat stat;
-	int error;
-
-	if (lo->lo_state != Lo_bound)
-		return -ENXIO;
-	error = vfs_getattr(file->f_path.mnt, file->f_path.dentry, &stat);
-	if (error)
-		return error;
-	C2_SET0(info);
-	info->lo_number = lo->lo_number;
-	info->lo_device = huge_encode_dev(stat.dev);
-	info->lo_inode = stat.ino;
-	info->lo_rdevice = huge_encode_dev(lo->lo_device ? stat.rdev : stat.dev);
-	info->lo_offset = lo->lo_offset;
-	info->lo_sizelimit = lo->lo_sizelimit;
-	info->lo_flags = lo->lo_flags;
-	memcpy(info->lo_file_name, lo->lo_file_name, LO_NAME_SIZE);
-	memcpy(info->lo_crypt_name, lo->lo_crypt_name, LO_NAME_SIZE);
-	info->lo_encrypt_type =
-		lo->lo_encryption ? lo->lo_encryption->number : 0;
-	if (lo->lo_encrypt_key_size && capable(CAP_SYS_ADMIN)) {
-		info->lo_encrypt_key_size = lo->lo_encrypt_key_size;
-		memcpy(info->lo_encrypt_key, lo->lo_encrypt_key,
-		       lo->lo_encrypt_key_size);
-	}
-	return 0;
-}
-
-static void
-loop_info64_from_old(const struct loop_info *info, struct loop_info64 *info64)
-{
-	C2_SET0(info64);
-	info64->lo_number = info->lo_number;
-	info64->lo_device = info->lo_device;
-	info64->lo_inode = info->lo_inode;
-	info64->lo_rdevice = info->lo_rdevice;
-	info64->lo_offset = info->lo_offset;
-	info64->lo_sizelimit = 0;
-	info64->lo_encrypt_type = info->lo_encrypt_type;
-	info64->lo_encrypt_key_size = info->lo_encrypt_key_size;
-	info64->lo_flags = info->lo_flags;
-	info64->lo_init[0] = info->lo_init[0];
-	info64->lo_init[1] = info->lo_init[1];
-	if (info->lo_encrypt_type == LO_CRYPT_CRYPTOAPI)
-		memcpy(info64->lo_crypt_name, info->lo_name, LO_NAME_SIZE);
-	else
-		memcpy(info64->lo_file_name, info->lo_name, LO_NAME_SIZE);
-	memcpy(info64->lo_encrypt_key, info->lo_encrypt_key, LO_KEY_SIZE);
-}
-
-static int
-loop_info64_to_old(const struct loop_info64 *info64, struct loop_info *info)
-{
-	C2_SET0(info);
-	info->lo_number = info64->lo_number;
-	info->lo_device = info64->lo_device;
-	info->lo_inode = info64->lo_inode;
-	info->lo_rdevice = info64->lo_rdevice;
-	info->lo_offset = info64->lo_offset;
-	info->lo_encrypt_type = info64->lo_encrypt_type;
-	info->lo_encrypt_key_size = info64->lo_encrypt_key_size;
-	info->lo_flags = info64->lo_flags;
-	info->lo_init[0] = info64->lo_init[0];
-	info->lo_init[1] = info64->lo_init[1];
-	if (info->lo_encrypt_type == LO_CRYPT_CRYPTOAPI)
-		memcpy(info->lo_name, info64->lo_crypt_name, LO_NAME_SIZE);
-	else
-		memcpy(info->lo_name, info64->lo_file_name, LO_NAME_SIZE);
-	memcpy(info->lo_encrypt_key, info64->lo_encrypt_key, LO_KEY_SIZE);
-
-	/* error in case values were truncated */
-	if (info->lo_device != info64->lo_device ||
-	    info->lo_rdevice != info64->lo_rdevice ||
-	    info->lo_inode != info64->lo_inode ||
-	    info->lo_offset != info64->lo_offset)
-		return -EOVERFLOW;
-
-	return 0;
-}
-
-static int
-loop_set_status_old(struct loop_device *lo, const struct loop_info __user *arg)
-{
-	struct loop_info info;
-	struct loop_info64 info64;
-
-	if (copy_from_user(&info, arg, sizeof (struct loop_info)))
-		return -EFAULT;
-	loop_info64_from_old(&info, &info64);
-	return loop_set_status(lo, &info64);
-}
-
-static int
-loop_set_status64(struct loop_device *lo, const struct loop_info64 __user *arg)
-{
-	struct loop_info64 info64;
-
-	if (copy_from_user(&info64, arg, sizeof (struct loop_info64)))
-		return -EFAULT;
-	return loop_set_status(lo, &info64);
-}
-
-static int
-loop_get_status_old(struct loop_device *lo, struct loop_info __user *arg) {
-	struct loop_info info;
-	struct loop_info64 info64;
-	int err = 0;
-
-	if (!arg)
-		err = -EINVAL;
-	if (!err)
-		err = loop_get_status(lo, &info64);
-	if (!err)
-		err = loop_info64_to_old(&info64, &info);
-	if (!err && copy_to_user(arg, &info, sizeof(info)))
-		err = -EFAULT;
-
-	return err;
-}
-
-static int
-loop_get_status64(struct loop_device *lo, struct loop_info64 __user *arg) {
-	struct loop_info64 info64;
-	int err = 0;
-
-	if (!arg)
-		err = -EINVAL;
-	if (!err)
-		err = loop_get_status(lo, &info64);
-	if (!err && copy_to_user(arg, &info64, sizeof(info64)))
-		err = -EFAULT;
-
-	return err;
-}
-
-static int loop_set_capacity(struct loop_device *lo, struct block_device *bdev)
-{
-	int err;
-	sector_t sec;
-	loff_t sz;
-
-	err = -ENXIO;
-	if (unlikely(lo->lo_state != Lo_bound))
-		goto out;
-	err = figure_loop_size(lo);
-	if (unlikely(err))
-		goto out;
-	sec = get_capacity(lo->lo_disk);
-	/* the width of sector_t may be narrow for bit-shift */
-	sz = sec;
-	sz <<= 9;
-	mutex_lock(&bdev->bd_mutex);
-	bd_set_size(bdev, sz);
-	mutex_unlock(&bdev->bd_mutex);
-
- out:
-	return err;
-}
-
-static int lo_ioctl(struct block_device *bdev, fmode_t mode,
-	unsigned int cmd, unsigned long arg)
-{
-	struct loop_device *lo = bdev->bd_disk->private_data;
-	int err;
-
-	mutex_lock_nested(&lo->lo_ctl_mutex, 1);
-	switch (cmd) {
-	case LOOP_SET_FD:
-		err = loop_set_fd(lo, mode, bdev, arg);
-		break;
-	case LOOP_CHANGE_FD:
-		err = loop_change_fd(lo, bdev, arg);
-		break;
-	case LOOP_CLR_FD:
-		/* loop_clr_fd would have unlocked lo_ctl_mutex on success */
-		err = loop_clr_fd(lo, bdev);
-		if (!err)
-			goto out_unlocked;
-		break;
-	case LOOP_SET_STATUS:
-		err = loop_set_status_old(lo, (struct loop_info __user *) arg);
-		break;
-	case LOOP_GET_STATUS:
-		err = loop_get_status_old(lo, (struct loop_info __user *) arg);
-		break;
-	case LOOP_SET_STATUS64:
-		err = loop_set_status64(lo, (struct loop_info64 __user *) arg);
-		break;
-	case LOOP_GET_STATUS64:
-		err = loop_get_status64(lo, (struct loop_info64 __user *) arg);
-		break;
-	case LOOP_SET_CAPACITY:
-		err = -EPERM;
-		if ((mode & FMODE_WRITE) || capable(CAP_SYS_ADMIN))
-			err = loop_set_capacity(lo, bdev);
-		break;
-	default:
-		err = lo->ioctl ? lo->ioctl(lo, cmd, arg) : -EINVAL;
-	}
-	mutex_unlock(&lo->lo_ctl_mutex);
-
-out_unlocked:
-	return err;
-}
-
-#ifdef CONFIG_COMPAT
-struct compat_loop_info {
-	compat_int_t	lo_number;      /* ioctl r/o */
-	compat_dev_t	lo_device;      /* ioctl r/o */
-	compat_ulong_t	lo_inode;       /* ioctl r/o */
-	compat_dev_t	lo_rdevice;     /* ioctl r/o */
-	compat_int_t	lo_offset;
-	compat_int_t	lo_encrypt_type;
-	compat_int_t	lo_encrypt_key_size;    /* ioctl w/o */
-	compat_int_t	lo_flags;       /* ioctl r/o */
-	char		lo_name[LO_NAME_SIZE];
-	unsigned char	lo_encrypt_key[LO_KEY_SIZE]; /* ioctl w/o */
-	compat_ulong_t	lo_init[2];
-	char		reserved[4];
-};
-
-/*
- * Transfer 32-bit compatibility structure in userspace to 64-bit loop info
- * - noinlined to reduce stack space usage in main part of driver
- */
-static noinline int
-loop_info64_from_compat(const struct compat_loop_info __user *arg,
-			struct loop_info64 *info64)
-{
-	struct compat_loop_info info;
-
-	if (copy_from_user(&info, arg, sizeof(info)))
-		return -EFAULT;
-
-	C2_SET0(info64);
-	info64->lo_number = info.lo_number;
-	info64->lo_device = info.lo_device;
-	info64->lo_inode = info.lo_inode;
-	info64->lo_rdevice = info.lo_rdevice;
-	info64->lo_offset = info.lo_offset;
-	info64->lo_sizelimit = 0;
-	info64->lo_encrypt_type = info.lo_encrypt_type;
-	info64->lo_encrypt_key_size = info.lo_encrypt_key_size;
-	info64->lo_flags = info.lo_flags;
-	info64->lo_init[0] = info.lo_init[0];
-	info64->lo_init[1] = info.lo_init[1];
-	if (info.lo_encrypt_type == LO_CRYPT_CRYPTOAPI)
-		memcpy(info64->lo_crypt_name, info.lo_name, LO_NAME_SIZE);
-	else
-		memcpy(info64->lo_file_name, info.lo_name, LO_NAME_SIZE);
-	memcpy(info64->lo_encrypt_key, info.lo_encrypt_key, LO_KEY_SIZE);
-	return 0;
-}
-
-/*
- * Transfer 64-bit loop info to 32-bit compatibility structure in userspace
- * - noinlined to reduce stack space usage in main part of driver
- */
-static noinline int
-loop_info64_to_compat(const struct loop_info64 *info64,
-		      struct compat_loop_info __user *arg)
-{
-	struct compat_loop_info info;
-
-	C2_SET0(&info);
-	info.lo_number = info64->lo_number;
-	info.lo_device = info64->lo_device;
-	info.lo_inode = info64->lo_inode;
-	info.lo_rdevice = info64->lo_rdevice;
-	info.lo_offset = info64->lo_offset;
-	info.lo_encrypt_type = info64->lo_encrypt_type;
-	info.lo_encrypt_key_size = info64->lo_encrypt_key_size;
-	info.lo_flags = info64->lo_flags;
-	info.lo_init[0] = info64->lo_init[0];
-	info.lo_init[1] = info64->lo_init[1];
-	if (info.lo_encrypt_type == LO_CRYPT_CRYPTOAPI)
-		memcpy(info.lo_name, info64->lo_crypt_name, LO_NAME_SIZE);
-	else
-		memcpy(info.lo_name, info64->lo_file_name, LO_NAME_SIZE);
-	memcpy(info.lo_encrypt_key, info64->lo_encrypt_key, LO_KEY_SIZE);
-
-	/* error in case values were truncated */
-	if (info.lo_device != info64->lo_device ||
-	    info.lo_rdevice != info64->lo_rdevice ||
-	    info.lo_inode != info64->lo_inode ||
-	    info.lo_offset != info64->lo_offset ||
-	    info.lo_init[0] != info64->lo_init[0] ||
-	    info.lo_init[1] != info64->lo_init[1])
-		return -EOVERFLOW;
-
-	if (copy_to_user(arg, &info, sizeof(info)))
-		return -EFAULT;
-	return 0;
-}
-
-static int
-loop_set_status_compat(struct loop_device *lo,
-		       const struct compat_loop_info __user *arg)
-{
-	struct loop_info64 info64;
-	int ret;
-
-	ret = loop_info64_from_compat(arg, &info64);
-	if (ret < 0)
-		return ret;
-	return loop_set_status(lo, &info64);
-}
-
-static int
-loop_get_status_compat(struct loop_device *lo,
-		       struct compat_loop_info __user *arg)
-{
-	struct loop_info64 info64;
-	int err = 0;
-
-	if (!arg)
-		err = -EINVAL;
-	if (!err)
-		err = loop_get_status(lo, &info64);
-	if (!err)
-		err = loop_info64_to_compat(&info64, arg);
-	return err;
-}
-
-static int lo_compat_ioctl(struct block_device *bdev, fmode_t mode,
-			   unsigned int cmd, unsigned long arg)
-{
-	struct loop_device *lo = bdev->bd_disk->private_data;
-	int err;
-
-	switch(cmd) {
-	case LOOP_SET_STATUS:
-		mutex_lock(&lo->lo_ctl_mutex);
-		err = loop_set_status_compat(
-			lo, (const struct compat_loop_info __user *) arg);
-		mutex_unlock(&lo->lo_ctl_mutex);
-		break;
-	case LOOP_GET_STATUS:
-		mutex_lock(&lo->lo_ctl_mutex);
-		err = loop_get_status_compat(
-			lo, (struct compat_loop_info __user *) arg);
-		mutex_unlock(&lo->lo_ctl_mutex);
-		break;
-	case LOOP_SET_CAPACITY:
-	case LOOP_CLR_FD:
-	case LOOP_GET_STATUS64:
-	case LOOP_SET_STATUS64:
-		arg = (unsigned long) compat_ptr(arg);
-	case LOOP_SET_FD:
-	case LOOP_CHANGE_FD:
-		err = lo_ioctl(bdev, mode, cmd, arg);
-		break;
-	default:
-		err = -ENOIOCTLCMD;
-		break;
-	}
-	return err;
-}
-#endif
-
-static int lo_open(struct block_device *bdev, fmode_t mode)
-{
-	struct loop_device *lo = bdev->bd_disk->private_data;
-
-	mutex_lock(&lo->lo_ctl_mutex);
-	lo->lo_refcnt++;
-	mutex_unlock(&lo->lo_ctl_mutex);
-
-	return 0;
-}
-
-static int lo_release(struct gendisk *disk, fmode_t mode)
-{
-	struct loop_device *lo = disk->private_data;
-	int err;
-
-	mutex_lock(&lo->lo_ctl_mutex);
-
-	if (--lo->lo_refcnt)
-		goto out;
-
-	if (lo->lo_flags & LO_FLAGS_AUTOCLEAR) {
-		/*
-		 * In autoclear mode, stop the loop thread
-		 * and remove configuration after last close.
-		 */
-		err = loop_clr_fd(lo, NULL);
-		if (!err)
-			goto out_unlocked;
-	} else {
-		/*
-		 * Otherwise keep thread (if running) and config,
-		 * but flush possible ongoing bios in thread.
-		 */
-		loop_flush(lo);
-	}
-
-out:
-	mutex_unlock(&lo->lo_ctl_mutex);
-out_unlocked:
-	return 0;
-}
-
-static const struct block_device_operations lo_fops = {
-	.owner =	THIS_MODULE,
-	.open =		lo_open,
-	.release =	lo_release,
-	.ioctl =	lo_ioctl,
-#ifdef CONFIG_COMPAT
-	.compat_ioctl =	lo_compat_ioctl,
-#endif
-};
-
-/*
- * And now the modules code and kernel interface.
- */
-static int max_loop;
-module_param(max_loop, int, 0);
-MODULE_PARM_DESC(max_loop, "Maximum number of loop devices");
-module_param(max_part, int, 0);
-MODULE_PARM_DESC(max_part, "Maximum number of partitions per loop device");
-MODULE_LICENSE("GPL");
-MODULE_ALIAS_BLOCKDEV_MAJOR(LOOP_MAJOR);
-
-int loop_register_transfer(struct loop_func_table *funcs)
-{
-	unsigned int n = funcs->number;
-
-	if (n >= MAX_LO_CRYPT || xfer_funcs[n])
-		return -EINVAL;
-	xfer_funcs[n] = funcs;
-	return 0;
-}
-
-int loop_unregister_transfer(int number)
-{
-	unsigned int n = number;
-	struct loop_device *lo;
-	struct loop_func_table *xfer;
-
-	if (n == 0 || n >= MAX_LO_CRYPT || (xfer = xfer_funcs[n]) == NULL)
-		return -EINVAL;
-
-	xfer_funcs[n] = NULL;
-
-	list_for_each_entry(lo, &loop_devices, lo_list) {
-		mutex_lock(&lo->lo_ctl_mutex);
-
-		if (lo->lo_encryption == xfer)
-			loop_release_xfer(lo);
-
-		mutex_unlock(&lo->lo_ctl_mutex);
-	}
-
-	return 0;
-}
-
-
-static struct loop_device *loop_alloc(int i)
-{
-	struct loop_device *lo;
-	struct gendisk *disk;
-
-	lo = kzalloc(sizeof(*lo), GFP_KERNEL);
-	if (!lo)
-		goto out;
-
-	lo->lo_queue = blk_alloc_queue(GFP_KERNEL);
-	if (!lo->lo_queue)
-		goto out_free_dev;
-
-	disk = lo->lo_disk = alloc_disk(1 << part_shift);
-	if (!disk)
-		goto out_free_queue;
-
-	mutex_init(&lo->lo_ctl_mutex);
-	lo->lo_number		= i;
-	lo->lo_thread		= NULL;
-	init_waitqueue_head(&lo->lo_event);
-	spin_lock_init(&lo->lo_lock);
-	disk->major		= LOOP_MAJOR;
-	disk->first_minor	= i << part_shift;
-	disk->fops		= &lo_fops;
-	disk->private_data	= lo;
-	disk->queue		= lo->lo_queue;
-	sprintf(disk->disk_name, "loop%d", i);
-	return lo;
-
-out_free_queue:
-	blk_cleanup_queue(lo->lo_queue);
-out_free_dev:
-	kfree(lo);
-out:
-	return NULL;
-}
-
-static void loop_free(struct loop_device *lo)
-{
-	blk_cleanup_queue(lo->lo_queue);
-	put_disk(lo->lo_disk);
-	list_del(&lo->lo_list);
-	kfree(lo);
-}
-
-static struct loop_device *loop_init_one(int i)
-{
-	struct loop_device *lo;
-
-	list_for_each_entry(lo, &loop_devices, lo_list) {
-		if (lo->lo_number == i)
-			return lo;
-	}
-
-	lo = loop_alloc(i);
-	if (lo) {
-		add_disk(lo->lo_disk);
-		list_add_tail(&lo->lo_list, &loop_devices);
-	}
-	return lo;
-}
-
-static void loop_del_one(struct loop_device *lo)
-{
-	del_gendisk(lo->lo_disk);
-	loop_free(lo);
-}
-
-static struct kobject *loop_probe(dev_t dev, int *part, void *data)
-{
-	struct loop_device *lo;
-	struct kobject *kobj;
-
-	mutex_lock(&loop_devices_mutex);
-	lo = loop_init_one(dev & MINORMASK);
-	kobj = lo ? get_disk(lo->lo_disk) : ERR_PTR(-ENOMEM);
-	mutex_unlock(&loop_devices_mutex);
-
-	*part = 0;
-	return kobj;
-}
-
-static int __init loop_init(void)
-{
-	int i, nr;
-	unsigned long range;
-	struct loop_device *lo, *next;
-
-	/*
-	 * loop module now has a feature to instantiate underlying device
-	 * structure on-demand, provided that there is an access dev node.
-	 * However, this will not work well with user space tool that doesn't
-	 * know about such "feature".  In order to not break any existing
-	 * tool, we do the following:
-	 *
-	 * (1) if max_loop is specified, create that many upfront, and this
-	 *     also becomes a hard limit.
-	 * (2) if max_loop is not specified, create 8 loop device on module
-	 *     load, user can further extend loop device by create dev node
-	 *     themselves and have kernel automatically instantiate actual
-	 *     device on-demand.
-	 */
-
-	part_shift = 0;
-	if (max_part > 0)
-		part_shift = fls(max_part);
-
-	if (max_loop > 1UL << (MINORBITS - part_shift))
-		return -EINVAL;
-
-	if (max_loop) {
-		nr = max_loop;
-		range = max_loop;
-	} else {
-		nr = 8;
-		range = 1UL << (MINORBITS - part_shift);
-	}
-
-	if (register_blkdev(LOOP_MAJOR, "loop"))
-		return -EIO;
-
-	for (i = 0; i < nr; i++) {
-		lo = loop_alloc(i);
-		if (!lo)
-			goto Enomem;
-		list_add_tail(&lo->lo_list, &loop_devices);
-	}
-
-	/* point of no return */
-
-	list_for_each_entry(lo, &loop_devices, lo_list)
-		add_disk(lo->lo_disk);
-
-	blk_register_region(MKDEV(LOOP_MAJOR, 0), range,
-				  THIS_MODULE, loop_probe, NULL, NULL);
-
-	printk(KERN_INFO "loop: module loaded\n");
-	return 0;
-
-Enomem:
-	printk(KERN_INFO "loop: out of memory\n");
-
-	list_for_each_entry_safe(lo, next, &loop_devices, lo_list)
-		loop_free(lo);
-
-	unregister_blkdev(LOOP_MAJOR, "loop");
-	return -ENOMEM;
-}
-
-static void __exit loop_exit(void)
-{
-	unsigned long range;
-	struct loop_device *lo, *next;
-
-	range = max_loop ? max_loop :  1UL << (MINORBITS - part_shift);
-
-	list_for_each_entry_safe(lo, next, &loop_devices, lo_list)
-		loop_del_one(lo);
-
-	blk_unregister_region(MKDEV(LOOP_MAJOR, 0), range);
-	unregister_blkdev(LOOP_MAJOR, "loop");
-}
-
-module_init(loop_init);
-module_exit(loop_exit);
-
-#ifndef MODULE
-static int __init max_loop_setup(char *str)
-{
-	max_loop = simple_strtol(str, NULL, 0);
-	return 1;
-}
-
-__setup("max_loop=", max_loop_setup);
-#endif
diff --git a/c2t1fs/linux_kernel/main.c b/c2t1fs/linux_kernel/main.c
deleted file mode 100644
index 8f6a317..0000000
--- a/c2t1fs/linux_kernel/main.c
+++ /dev/null
@@ -1,1509 +0,0 @@
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Yuriy Umanets <yuriy_umanets@xyratex.com>
- *		    Huang Hua <hua_huang@xyratex.com>
- *		    Anatoliy Bilenko
- * Original creation date: 05/04/2010
- */
-
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/mm.h>
-#include <linux/slab.h>
-#include <linux/fs.h>
-#include <linux/mount.h>
-#include <linux/smp_lock.h>
-#include <linux/vfs.h>
-#include <linux/uio.h>
-#include <linux/inet.h>
-#include <linux/in.h>
-
-#include "lib/misc.h"  /* C2_SET0 */
-#include "lib/memory.h"
-#include "lib/errno.h"
-#include "lib/arith.h"
-#include "fop/fop.h"
-
-#include "c2t1fs.h"
-#include "io_k.h"
-#include "io_fops_k.h"
-#include "ioservice/io_fops.h"
-
-#include "stob/ut/io_fop.h"
-#include "sns/parity_math.h"
-#include "layout/pdclust.h"
-#include "pool/pool.h"
-#include "lib/buf.h"
-
-#define DBG(fmt, args...) printk("%s:%d " fmt, __FUNCTION__, __LINE__, ##args)
-
-/**
-   @page c2t1fs C2T1FS detailed level design specification.
-
-   @section Overview
-
-   C2T1FS is native linux nodev file system, which lies exactly between colibri
-   block device and colibri servers. It is in fact client file system for the
-   colibri cluster.
-
-   It is decided that colibri block device is based on loop.c loop back driver.
-   This dictates, despite the requirements, specific impelementation, which will
-   be discussed below.
-
-   @section def Definitions and requirements
-
-   Here is brief list of requirements:
-
-   @li direct IO support (all the caching is done on upper layet). In
-       our case this means no page cache in IO functions. All the IO,
-       no matter how big, gets imidiately sent to the server. Do not
-       mix it up with cache on upper layer. For example,
-       ->prepare_write and ->commit_write methods work with pages from
-       page cache but they belong to upper layer cache. When loop
-       device driver works with pages it delegates some works to
-       underlaying FS;
-
-   @li no read ahead (nothing to say more);
-
-   @li no ACL or selinux support. Unix security model (permission
-       masks) is followed with client inventing it;
-
-   @li loop back device driver with minimal changes should work and
-       losetup tool should also work with C2T1FS;
-
-   @li readdir() is only supported for root dir. A single regular file named
-       with object number is filled in the root dir.
-
-   @li read/write, readv/writev methods should work. Asynchronous
-       interface should be supported;
-
-   @li file exported by the server and which we want to use as a
-       back-end for the block device should be specified as part of
-       device specification in mount command in a way like this:
-
-       mount -t c2t1fs -o objid=<objid> ipaddr:port /mnt/c2t1fs
-
-     where objid is object id exported by the server.
-
-     If the server does not know this object - a error is returned and mount
-     fails and meaningful error is reported.
-
-   @section c2t1fsfuncspec Functional specification
-
-   There are three interaces we need to interact with:
-
-   @li linux VFS - super_block operations should have
-       c2t1fs_get_super() and c2t1fs_fill_super() methods
-       implemented. Root inode and dentry should be created in mount
-       time;
-
-   @li loop back device driver interface: ->write(),
-       ->prepare_write/commit_write() and ->sendfile() methods should be
-       implemented;
-
-   @li networking layer needs: connect/disconnect rpc. Connect should
-       have one field: obj_id, that is, what object we are attaching
-       to. We need also read/write rpcs capable to work with iovec
-       structures.
-
-   @section c2t1fslogspec Logical specification
-
-   C2T1FS is implemented as linux native nodev file system. It may be used in
-   a way like this:
-
-   modprobe c2t1fs
-   mount -t c2t1fs -o objid=<objid> ipaddr:port /mnt/c2t1fs
-   losetup /dev/loop0 /mnt/c2t1fs/$objid
-   dd if=/dev/zero of=/dev/loop0 bs=1M count=10
-
-   To support this functionality, we implement the following parts:
-
-   @li mount (super block init), which parses device name, sends
-       connect rpc to the server and creates root inode and dentry
-       upon success. We also create inode and dentry for the file
-       exported by the server. It is easier to handle wrong file id
-       during mount rather than in file IO time;
-
-   @li losetup part requires ->lookup method;
-
-   @li working IO part requires ->prepare_write/commit_write(),
-       ->sendfile() and ->write() file operations to being implemented.
-
- */
-
-extern const struct c2_rpc_item_ops rpc_item_iov_ops;
-
-static struct kmem_cache     *c2t1fs_inode_cachep = NULL;
-static struct c2_net_domain  c2t1fs_domain;
-
-static inline struct c2t1fs_inode_info *i2cii(struct inode *inode)
-{
-	return container_of(inode, struct c2t1fs_inode_info, cii_vfs_inode);
-}
-
-/**
- * Global container id used to identify the corresponding
- * component object at the server side.
- * In future, this will be changed.
- */
-#define c2_global_container_id	10
-
-static int ksunrpc_read_write(struct c2_net_conn *conn,
-			      uint64_t objid, struct page **pages, int off,
-			      size_t len, loff_t pos, int rw)
-{
-        int rc;
-	struct c2_fop			*f;
-	struct c2_fop			*r;
-	struct c2_net_call		 kcall;
-	struct c2_fop_io_seg		 ioseg;
-	struct c2_fop_cob_writev	*warg;
-	struct c2_fop_cob_writev_rep	*wret;
-	struct c2_fop_cob_readv		*rarg;
-	struct c2_fop_cob_readv_rep	*rret;
-	struct c2_fop_cob_rw		*iofop;
-
-        if (rw == WRITE) {
-		f = c2_fop_alloc(&c2_fop_cob_writev_fopt, NULL);
-		r = c2_fop_alloc(&c2_fop_cob_writev_rep_fopt, NULL);
-	} else {
-		f = c2_fop_alloc(&c2_fop_cob_readv_fopt, NULL);
-		r = c2_fop_alloc(&c2_fop_cob_readv_rep_fopt, NULL);
-	}
-
-	f->f_item.ri_ops = &rpc_item_iov_ops;
-	r->f_item.ri_ops = &rpc_item_iov_ops;
-
-	DBG("%s data %s server(%llu/%d/%ld/%lld)\n",
-	    rw == WRITE? "writing":"reading", rw == WRITE? "to":"from",
-			objid, off, len, pos);
-	if (f == NULL) {
-		DBG("Memory allocation failed for %s request fop.\n",
-			rw == WRITE? "write":"read");
-		return -ENOMEM;
-	}
-	if (r == NULL) {
-		DBG("Memory allocation failed for %s reply fop.\n",
-			rw == WRITE? "write":"read");
-		return -ENOMEM;
-	}
-
-	kcall.ac_arg = f;
-	kcall.ac_ret = r;
-
-	if (rw == WRITE) {
-		warg = c2_fop_data(f);
-		wret = c2_fop_data(r);
-		iofop = &warg->c_rwv;
-	} else {
-		rarg = c2_fop_data(f);
-		rret = c2_fop_data(r);
-		iofop = &rarg->c_rwv;
-	}
-
-	/* With introduction of FOMs, a reply FOP will be allocated
-	 * by the request FOP and a pointer to it will be
-	 * sent across. */
-	iofop->crw_fid.f_seq		= c2_global_container_id;
-	iofop->crw_fid.f_oid		= objid;
-	iofop->crw_iovec.iv_count	= 1;
-
-	/* Populate the vector of write FOP */
-	iofop->crw_iovec.iv_segs = &ioseg;
-	ioseg.is_offset = pos;
-	ioseg.is_buf.cfib_pgoff = off;
-	ioseg.is_buf.ib_buf = pages;
-	ioseg.is_buf.ib_count = len;
-	iofop->crw_flags = 0;
-
-	/* kxdr expects a SEQUENCE of bytes in reply fop. */
-	if (rw == READ) {
-		rret->c_iobuf.ib_buf = pages;
-		rret->c_iobuf.ib_count = len;
-		rret->c_iobuf.cfib_pgoff = off;
-	}
-
-	rc = c2_net_cli_call(conn, &kcall);
-
-	DBG("%s server returns %d\n", rw == WRITE? "write to":"read from", rc);
-
-	if (rc != 0)
-		return rc;
-
-	/* Since read and write replies are not same at the moment, this
-	   condition has to be put. */
-	if (rw == WRITE)
-		rc = wret->c_rep.rwr_rc ? : wret->c_rep.rwr_count;
-	else
-		rc = rret->c_rep.rwr_rc ? : rret->c_iobuf.ib_count;
-
-	c2_fop_free(r);
-	c2_fop_free(f);
-	return rc;
-}
-
-static int ksunrpc_create(struct c2_net_conn *conn,
-			  uint64_t objid)
-{
-        int rc;
-	struct c2_io_create      *arg;
-	struct c2_io_create_rep  *ret;
-	struct c2_fop            *f;
-	struct c2_fop            *r;
-	struct c2_net_call       kcall;
-
-	f = c2_fop_alloc(&c2_io_create_fopt, NULL);
-	r = c2_fop_alloc(&c2_io_create_rep_fopt, NULL);
-
-	BUG_ON(f == NULL || r == NULL);
-
-	kcall.ac_arg = f;
-	kcall.ac_ret = r;
-
-	arg = c2_fop_data(f);
-	ret = c2_fop_data(r);
-
-        arg->sic_object.f_seq = c2_global_container_id;
-        arg->sic_object.f_oid = objid;
-
-        DBG("%s create object %llu\n", __FUNCTION__, objid);
-	rc = c2_net_cli_call(conn, &kcall);
-        DBG("create obj returns %d/%d\n", rc, ret->sicr_rc);
-        rc = rc ? : ret->sicr_rc;
-	c2_fop_free(r);
-	c2_fop_free(f);
-	return rc;
-}
-
-static struct c2t1fs_sb_info *c2t1fs_init_csi(struct super_block *sb)
-{
-        struct c2t1fs_sb_info *csi;
-
-	csi = kmalloc(sizeof(*csi), GFP_KERNEL);
-	if (!csi)
-		return NULL;
-        s2csi_nocast(sb) = csi;
-        C2_SET0(csi);
-
-        atomic_set(&csi->csi_mounts, 1);
-	c2_mutex_init(&csi->csi_mutex);
-	c2_list_init(&csi->csi_conn_list);
-        return csi;
-}
-
-static int c2t1fs_free_csi(struct super_block *sb)
-{
-        struct c2t1fs_sb_info *csi = s2csi(sb);
-
-        kfree(csi);
-        s2csi_nocast(sb) = NULL;
-
-        return 0;
-}
-
-static int c2t1fs_put_csi(struct super_block *sb)
-{
-        struct c2t1fs_sb_info *csi = s2csi(sb);
-
-        if (atomic_dec_and_test(&csi->csi_mounts)) {
-                c2t1fs_free_csi(sb);
-                return 1;
-        }
-
-        return 0;
-}
-
-static struct inode *c2t1fs_alloc_inode(struct super_block *sb)
-{
-	struct c2t1fs_inode_info *cii;
-
-	cii = kmem_cache_alloc(c2t1fs_inode_cachep, GFP_NOFS);
-	if (!cii)
-		return NULL;
-	inode_init_once(&cii->cii_vfs_inode);
-	return &cii->cii_vfs_inode;
-}
-
-static void c2t1fs_destroy_inode(struct inode *inode)
-{
-	kmem_cache_free(c2t1fs_inode_cachep, i2cii(inode));
-}
-
-static void c2t1fs_put_super(struct super_block *sb)
-{
-        c2t1fs_put_csi(sb);
-}
-
-static int c2t1fs_statfs(struct dentry *dentry, struct kstatfs *buf)
-{
-        buf->f_type   = dentry->d_sb->s_magic;
-        buf->f_bsize  = PAGE_SIZE;
-        buf->f_blocks = 1024 * 1024;
-        buf->f_bfree  = 1024 * 1024;
-        buf->f_bavail = 1024 * 1024;
-        buf->f_namelen = NAME_MAX;
-        return 0;
-}
-
-
-struct super_operations c2t1fs_super_operations = {
-        .alloc_inode   = c2t1fs_alloc_inode,
-        .destroy_inode = c2t1fs_destroy_inode,
-        .put_super     = c2t1fs_put_super,
-        .statfs        = c2t1fs_statfs,
-};
-
-static int pdclust_layout_init(struct c2_pdclust_layout **play, int N, int K)
-{
-	int                 result;
-	struct c2_uint128   id;
-	struct c2_uint128   seed;
-	struct c2_pool     *pool;
-
-	C2_ALLOC_PTR(pool);
-	if (pool == NULL)
-		return -ENOMEM;
-
-	c2_uint128_init(&id,   "jinniesisjillous");
-	c2_uint128_init(&seed, "upjumpandpumpim,");
-
-	result = c2_pool_init(pool, N+2*K);
-
-	if (result != 0) {
-		c2_free(pool);
-		return result;
-	}
-
-	result = c2_pdclust_build(pool, &id, N, K, &seed, play);
-
-	if (result != 0) {
-		c2_pool_fini(pool);
-		c2_free(pool);
-	}
-
-	return result;
-}
-
-static void pdclust_layout_fini(struct c2_pdclust_layout *play)
-{
-	c2_pool_fini(play->pl_pool);
-	c2_pdclust_fini(play);
-}
-
-/**
-   Adding a container connection into list.
-
-   Container id, service id is provided by caller. Connection will be
-   established in this function.
-
-   TODO: Initially, this is maintained as a list. I will improve it into
-   a hash table.
-*/
-static int c2t1fs_container_add(struct super_block *sb,
-				struct c2t1fs_conn_clt *clt)
-{
-        struct c2t1fs_sb_info *csi = s2csi(sb);
-	ENTER;
-
-	DBG("Adding container %llu\n", (unsigned long long)clt->xc_cid);
-	c2_mutex_lock(&csi->csi_mutex);
-	c2_list_link_init(&clt->xc_link);
-	c2_list_add_tail(&csi->csi_conn_list, &clt->xc_link);
-	c2_mutex_unlock(&csi->csi_mutex);
-
-	return 0;
-}
-
-/**
-   Lookup a container connection from list.
-
-   container id is the key.
-*/
-static struct c2t1fs_conn_clt* c2t1fs_container_lookup(struct super_block *sb,
-						       uint64_t container_id)
-{
-        struct c2t1fs_sb_info  *csi = s2csi(sb);
-	struct c2t1fs_conn_clt *conn;
-	struct c2t1fs_conn_clt *ret = NULL;
-	ENTER;
-
-	DBG("Looking for container %llu\n", (unsigned long long)container_id);
-	c2_mutex_lock(&csi->csi_mutex);
-	c2_list_for_each_entry(&csi->csi_conn_list, conn, struct c2t1fs_conn_clt, xc_link) {
-		if (conn->xc_cid == container_id) {
-			ret = conn;
-			break;
-		}
-	}
-	c2_mutex_unlock(&csi->csi_mutex);
-	DBG("Looking for container result=%p\n", ret);
-	return ret;
-}
-
-/**
-   Destroy all container connection infomation and free them.
-*/
-static int c2t1fs_container_fini(struct super_block *sb)
-{
-        struct c2t1fs_sb_info *csi = s2csi(sb);
-	struct c2_list_link   *first;
-	struct c2t1fs_conn_clt *conn;
-	ENTER;
-
-	while (!c2_list_is_empty(&csi->csi_conn_list)) {
-		c2_mutex_lock(&csi->csi_mutex);
-		first = c2_list_first(&csi->csi_conn_list);
-		if (first != NULL)
-			c2_list_del(first);
-		c2_mutex_unlock(&csi->csi_mutex);
-
-		if (first == NULL)
-			break;
-
-		conn = c2_list_entry(first, struct c2t1fs_conn_clt, xc_link);
-		DBG("Freeing container %llu\n", (unsigned long long)conn->xc_cid);
-		if (conn->xc_conn != NULL) {
-			c2_net_conn_unlink(conn->xc_conn);
-			c2_net_conn_release(conn->xc_conn);
-		}
-		c2_free(conn);
-	}
-	return 0;
-}
-
-/**
-   establish container connections.
-*/
-static int c2t1fs_container_connect(struct super_block *sb)
-{
-        struct c2t1fs_sb_info  *csi = s2csi(sb);
-	struct c2t1fs_conn_clt *conn;
-	int rc = 0;
-	ENTER;
-
-	c2_mutex_lock(&csi->csi_mutex);
-	c2_list_for_each_entry(&csi->csi_conn_list, conn, struct c2t1fs_conn_clt, xc_link) {
-		rc = c2_net_conn_create(&conn->xc_srvid);
-	        if (rc)
-			break;
-
-		conn->xc_conn = c2_net_conn_find(&conn->xc_srvid);
-		rc = ksunrpc_create(conn->xc_conn, csi->csi_object_param.cop_objid);
-		if (rc) {
-			printk("Create objid %llu on %llu failed %d\n",
-				csi->csi_object_param.cop_objid, conn->xc_cid, rc);
-			break;
-		}
-		DBG("Connectted container %llu\n", (unsigned long long)conn->xc_cid);
-	}
-	c2_mutex_unlock(&csi->csi_mutex);
-	return rc;
-}
-
-static int c2t1fs_parse_address(struct super_block *sb, const char *address,
-				struct c2_service_id *sid)
-{
-        char *hostname;
-	char *port;
-	int   tcp_port;
-	int   rc;
-	ENTER;
-
-	hostname = kstrdup(address, GFP_KERNEL);
-
-        port = strchr(hostname, ':');
-	if (port == NULL || hostname == port || *(port+1) == '\0') {
-		printk("server:port is expected as the device\n");
-		kfree(hostname);
-		return -EINVAL;
-	}
-
-	*port++ = 0;
-	if (in_aton(hostname) == 0) {
-		printk("only dotted ipaddr is accepted now: e.g. 1.2.3.4\n");
-		kfree(hostname);
-		return -EINVAL;
-	}
-
-	tcp_port = simple_strtol(port, NULL, 0);
-	if (tcp_port <= 0) {
-		printk("invalid tcp port: %s\n", port);
-		kfree(hostname);
-		return -EINVAL;
-	}
-	DBG("server:port=%s:%d\n", hostname, tcp_port);
-
-        rc = c2_service_id_init(sid, &c2t1fs_domain, hostname, tcp_port);
-
-	kfree(hostname);
-	return rc;
-}
-
-
-static bool optcheck(const char *s, const char *opt, size_t *optlen)
-{
-	*optlen = strlen(opt);
-        return strncmp(s, opt, *optlen) == 0;
-}
-
-static int optparse(struct super_block *sb, char *options)
-{
-        struct c2t1fs_sb_info *csi = s2csi(sb);
- 	struct c2t1fs_object_param *obj_param = &csi->csi_object_param;
-        char *s1, *s2;
-	char *objid = NULL;
-	char *objsize = NULL;
-	char *layoutid = NULL;
-	char *unitsize = NULL;
-	char *layout_data = NULL;
-	char *layout_parity = NULL;
-	uint32_t N; /* layout data   unit count */
-	uint32_t K; /* layout parity unit count */
-	uint64_t cid = 0;
-	uint32_t container_nr = 0;
-        size_t optlen;
-	struct c2t1fs_conn_clt *clt;
-	int rc;
-	ENTER;
-
-        if (!options) {
-                printk(KERN_ERR "Missing mount data: objid=xxx,objsize=yyy\n");
-                return -EINVAL;
-        }
-
-        s1 = options;
-        while (*s1) {
-                while (*s1 == ' ' || *s1 == ',')
-                        s1++;
-
-                if (optcheck(s1, "objid=", &optlen)) {
-                        objid = s1 + optlen;
-                } else if (optcheck(s1, "objsize=", &optlen)) {
-                        objsize = s1 + 8;
-                } else if (optcheck(s1, "layoutid=", &optlen)) {
-			/* add layout id for this client */
-			layoutid = s1 + optlen;
-		} else if (optcheck(s1, "unitsize=", &optlen)) {
-			unitsize = s1 + optlen;
-		} else if (optcheck(s1, "layout-data=", &optlen)) {
-			/* will remove this option when layout id will be added */
-			layout_data = s1 + optlen;
-		} else if (optcheck(s1, "layout-parity=", &optlen)) {
-			/* will remove this option when layout id will be added */
-			layout_parity = s1 + optlen;
-		} else if (optcheck(s1, "ds=", &optlen)) {
-			/*
-			   Add container server information here.
-			   There may be multiple container servers. This option
-			   Will appear multiple times.
-			 */
-			clt = c2_alloc(sizeof *clt);
-			if (clt == NULL)
-				return -ENOMEM;
-			rc = c2t1fs_parse_address(sb, s1 + optlen, &clt->xc_srvid);
-			if (rc) {
-				c2_free(clt);
-				return rc;
-			}
-			/* adding container one by one */
-			clt->xc_cid = cid;
-			rc = c2t1fs_container_add(sb, clt);
-			if (rc) {
-				c2_free(clt);
-				return rc;
-			}
-			cid ++;
-			container_nr++;
-		}
-
-                /* Find next opt */
-                s2 = strchr(s1, ',');
-                if (s2 == NULL) {
-                        break;
-                }
-                s2++;
-                s1 = s2;
-        }
-
-        if (objid != NULL) {
-                obj_param->cop_objid = simple_strtol(objid, NULL, 0);
-                if (obj_param->cop_objid <= 0) {
-                        printk(KERN_ERR "Invalid objid=%s specified\n", objid);
-                        return -EINVAL;
-                }
-        } else {
-                printk(KERN_ERR "No device id specified (need mount option 'objid=...')\n");
-                return -EINVAL;
-        }
-        if (layoutid != NULL) {
-                obj_param->cop_layoutid = simple_strtol(layoutid, NULL, 0);
-                if (obj_param->cop_layoutid <= 0) {
-                        printk(KERN_ERR "Invalid objid=%s specified\n", layoutid);
-                        return -EINVAL;
-                }
-        } else {
-		/* use default value */
-                obj_param->cop_layoutid = 0;
-        }
-	if (layout_data != NULL && layout_parity != NULL) {
-		printk("layout_data && layout_parity: ");
-		N = simple_strtol(layout_data,   NULL, 0);
-		K = simple_strtol(layout_parity, NULL, 0);
-		printk("N=%d, K=%d, cnt_nr=%d", N, K, container_nr);
-		if (N + 2*K != container_nr) { /* *2 for SPARE UNITS */
-			printk(KERN_ERR "Unable to create layout with the following settigns:"
-			       " N=%u, K=%u, transport count=%u\n", N, K, container_nr);
-			return -EINVAL;
-		}
-
-		rc = pdclust_layout_init(&obj_param->cop_play, N, K);
-		if (rc)
-			return rc;
-	} else {
-                printk(KERN_ERR "No layout specified "
-		       "(need mount option 'layout-parity=...' and 'layout-data=...')\n");
-		obj_param->cop_play = NULL;
-                return -EINVAL;
-	}
-        if (objsize != NULL) {
-                obj_param->cop_objsize = simple_strtol(objsize, NULL, 0);
-                if (obj_param->cop_objsize <= 0) {
-                        printk(KERN_WARNING "Invalid objsize=%s specified."
-                               " Default value is used\n", objsize);
-                        obj_param->cop_objsize = C2T1FS_INIT_OBJSIZE;
-                }
-        } else {
-                printk(KERN_WARNING "no objsize specified. Default value is used\n");
-                obj_param->cop_objsize = C2T1FS_INIT_OBJSIZE;
-        }
-        if (unitsize != NULL) {
-                obj_param->cop_unitsize = simple_strtol(unitsize, NULL, 0);
-                if (obj_param->cop_unitsize < C2T1FS_DEFAULT_UNIT_SIZE) {
-                        printk(KERN_WARNING "Invalid unitsize=%s specified."
-                               " Default value is used\n", unitsize);
-                        obj_param->cop_unitsize = C2T1FS_DEFAULT_UNIT_SIZE;
-                }
-        } else {
-                printk(KERN_WARNING "no unitsize specified. Default value is used\n");
-                obj_param->cop_unitsize = C2T1FS_DEFAULT_UNIT_SIZE;
-        }
-
-        return 0;
-}
-
-struct rpc_desc {
-	loff_t rd_offset;
-	int    rd_units;
-};
-
-struct obj_map {
-	/* 2D array of page-pointers: struct page *om_map[N][M] */
-	struct page ***om_map;
-};
-
-static void obj_map_fini(struct obj_map *objmap, uint32_t P, uint32_t I)
-{
-        uint32_t i;
-
-        for (i = 0; i < P; ++i) {
-                c2_free(objmap->om_map[i]);
-                objmap->om_map[i] = NULL;
-	}
-
-        c2_free(objmap->om_map);
-}
-
-static int obj_map_init(struct obj_map *objmap, uint32_t P, uint32_t I)
-{
-        uint32_t i;
-
-        C2_ALLOC_ARR(objmap->om_map, P);
-        if (objmap->om_map == NULL)
-		return -ENOMEM;
-
-        for (i = 0; i < P; ++i) {
-                C2_ALLOC_ARR(objmap->om_map[i], I);
-		if (objmap->om_map[i] == NULL) {
-                        obj_map_fini(objmap, P, I);
-                        return -ENOMEM;
-                }
-        }
-
-        return 0;
-}
-
-static int c2t1fs_internal_read_write(struct c2t1fs_sb_info    *csi,
-				      struct inode             *inode,
-				      struct page **pages, int npages,
-				      loff_t in_pos, int off,
-				      struct c2_pdclust_layout *play,
-				      int rw)
-{
-	int                         i;
-	int                         rc = 0;
-	int                         rpc_rc;
-	int	                    group;
-	int	                    unit;
-	int                         N = play->pl_N;
-	int                         K = play->pl_K;
-	int                         P = play->pl_P;
-	int                         W = N + 2*K;
-	int                         I = npages / N;
-
-	int                         parity;
-	int			    parity_nr = K*I;
-	int                         spare;
-	int                         spare_nr = K*I;
-
-	uint64_t                    objid;
-	uint32_t                    unitsize;
-
-	struct c2_pdclust_src_addr  src;
-	struct c2_pdclust_tgt_addr  tgt;
-	enum c2_pdclust_unit_type   unit_type;
-
-	loff_t                      pos;
-	uint64_t                    obj;
-
-	struct c2t1fs_conn_clt     *con;
-	struct page                *page;
-	struct page	          **parity_pages = NULL;
-
-	struct c2_buf              *data_buf = NULL;
-	struct c2_buf              *parity_buf = NULL;
-
-	struct c2t1fs_object_param *obj_param;
-
-	struct obj_map              objmap;
-	struct rpc_desc            *rpc = NULL;
-
-	ENTER;
-
-	C2_ASSERT(csi != NULL);
-	C2_PRE(off == 0);
-
-	DBG("layout settings: N=%d, K=%d, W=%d, I=%d, P=%d\n", N, K, W, I, P);
-
-	obj_param = &csi->csi_object_param;
-	objid = obj_param->cop_objid;
-	unitsize = obj_param->cop_unitsize;
-	C2_ASSERT(unitsize >= C2T1FS_DEFAULT_UNIT_SIZE);
-
-	rc = obj_map_init(&objmap, P, I);
-	if (rc)
-		goto int_out;
-
-	C2_ALLOC_ARR(data_buf, N);
-	C2_ALLOC_ARR(rpc, P);
-	C2_ALLOC_ARR(parity_pages, parity_nr);
-	C2_ALLOC_ARR(parity_buf, parity_nr);
-
-	if (rpc == NULL || parity_pages == NULL ||
-	    data_buf == NULL || parity_buf == NULL) {
-		rc = -ENOMEM;
-		goto int_out;
-	}
-
-	for (i = 0; i < parity_nr; ++i) {
-		parity_pages[i] = alloc_page(GFP_KERNEL);
-		if (parity_pages[i] == NULL) {
-			rc = -ENOMEM;
-			goto int_out;
-		}
-
-		c2_buf_init(&parity_buf[i], page_address(parity_pages[i]),
-			    unitsize);
-	}
-
-	for (i = 0; i < P; ++i) {
-		rpc[i].rd_offset = C2_BSIGNED_MAX;
-		rpc[i].rd_units  = 0;
-	}
-
-	src.sa_group = in_pos / (N * unitsize);
-	for (group = 0, parity = 0, spare = 0; group < I ; ++group, src.sa_group++) {
-		for (unit = 0; unit < W; ++unit) {
-			src.sa_unit = unit;
-			c2_pdclust_layout_map(play, &src, &tgt);
-			pos = tgt.ta_frame * unitsize;
-			obj = tgt.ta_obj;
-
-			rpc[obj].rd_offset = min_check(pos, rpc[obj].rd_offset);
-			rpc[obj].rd_units++;
-
-			unit_type = c2_pdclust_unit_classify(play, unit);
-			if (unit_type == PUT_DATA) {
-				page = pages[unit + group*N];
-				c2_buf_init(&data_buf[unit],
-					    page_address(page),
-					    unitsize);
-			} else if (unit_type == PUT_PARITY) {
-				if (rw == WRITE)
-					c2_parity_math_calculate(&play->pl_math,
-								 data_buf,
-								 &parity_buf[group*K]);
-
-				C2_ASSERT(parity < parity_nr);
-				page = parity_pages[parity++];
-			} else { /* PUT_SPARE */
-				C2_ASSERT(spare < spare_nr);
-				page = parity_pages[spare++]; /* just use parity pages for now */
-			}
-
-			objmap.om_map[obj][group] = page;
-			DBG("prepare: obj=%llu, group=%d, pos=%llu, page=%p\n", obj, group, pos, page);
-		}
-	}
-
-	for (obj = 0; obj < P; ++obj) {
-		if (rpc[obj].rd_units == 0)
-			continue;
-		con = c2t1fs_container_lookup(inode->i_sb, obj);
-		if (con != NULL) {
-			rpc_rc = ksunrpc_read_write(con->xc_conn,
-						    objid,
-						    objmap.om_map[obj],
-						    off,
-						    /* rpc[obj].rd_units * I, */
-						    unitsize * I,
-						    rpc[obj].rd_offset, rw);
-
-			if (rpc_rc < 0) {
-				rc = rpc_rc;
-				goto int_out;
-			}
-		} else {
-			rc = -ENODEV;
-			goto int_out;
-		}
-		rc = I*N*unitsize;
-	}
-
- int_out:
-	for (i = 0; i < parity_nr; ++i) {
-		if (parity_pages[i] != NULL)
-			__free_page(parity_pages[i]);
-	}
-
-        if (parity_buf)
-	        c2_free(parity_buf);
-	if (parity_pages)
-	        c2_free(parity_pages);
-	if (rpc)
-	        c2_free(rpc);
-	if (data_buf)
-	        c2_free(data_buf);
-	obj_map_fini(&objmap, W, I);
-
-	return rc;
-}
-
-/* common rw function for c2t1fs, it just does sync RPC. */
-static ssize_t c2t1fs_read_write(struct file *file, char *buf, size_t count,
-                                 loff_t *ppos, int rw)
-{
-	struct inode          *inode = file->f_dentry->d_inode;
-	struct c2t1fs_sb_info *csi = s2csi(inode->i_sb);
-        unsigned long          addr;
-        struct page          **pages;
-        int                    npages;
-        int                    off;
-        loff_t                 pos = *ppos;
-	struct c2t1fs_conn_clt *conn;
-	struct c2t1fs_object_param *obj_param = &csi->csi_object_param;
-	struct c2_pdclust_layout   *play    = obj_param->cop_play;
-	c2_bcount_t                unitsize = obj_param->cop_unitsize;
-        int rc;
-
-	DBG("%s: %ld@%ld <i_size=%ld>\n", rw == READ ? "read" : "write",
-		count, (unsigned long)pos, (unsigned long)inode->i_size);
-
-	if (rw == READ) {
-                if (pos >= inode->i_size)
-                        return 0;
-
-		/* check if pos beyond the file size */
-		if (pos + count > inode->i_size)
-			count = inode->i_size - pos;
-	}
-
-	if (count == 0)
-		return 0;
-
-        if (rw == WRITE && file->f_flags & O_APPEND)
-                pos = inode->i_size;
-
-        addr = (unsigned long)buf;
-        off  = (addr & (PAGE_SIZE - 1));
-        addr &= PAGE_MASK;
-
-	/* suppose addr = 0x400386, count=5, then one page is enough */
-        npages = (off + count + PAGE_SIZE - 1) >> PAGE_SHIFT;
-        pages = kmalloc(sizeof(*pages) * npages, GFP_KERNEL);
-        if (pages == NULL)
-                return -ENOMEM;
-
-        DBG("addr = %lx, count = %ld, npages = %d, off = %d\n",
-		addr, count, npages, off);
-
-        if (addr > PAGE_OFFSET) {
-                int i;
-                unsigned long va = addr;
-                for (i = 0; i < npages; i++, va += PAGE_SIZE) {
-                        pages[i] = virt_to_page(va);
-                        get_page(pages[i]);
-                }
-                rc = npages;
-        } else {
-                down_read(&current->mm->mmap_sem);
-                rc = get_user_pages(current, current->mm, addr, npages,
-                                    rw == READ, 1, pages, NULL);
-                up_read(&current->mm->mmap_sem);
-        }
-        if (rc != npages) {
-                printk("expect %d, got %d\n", npages, rc);
-                npages = rc > 0 ? rc : 0;
-                rc = -EFAULT;
-                goto out;
-        }
-
-	C2_ASSERT(play != NULL);
-	C2_ASSERT(unitsize >= C2T1FS_DEFAULT_UNIT_SIZE);
-	/* XXX: just for now, full-stripe read/write */
-	if (npages % play->pl_N != 0 || off != 0
-	    || pos % (play->pl_N * unitsize) != 0) {
-		/* rc = -EPARSE; */
-		DBG("Supporting only full-stripe read/write for now: "
-		    "npages=%d, off=%d, pos=%llu\n", npages, off, pos);
-		rc = -EINVAL;
-		goto out;
-	}
-#if 0
-	conn = c2t1fs_container_lookup(inode->i_sb, 0);
-	if (conn)
-	        rc = ksunrpc_read_write(conn->xc_conn,
-					csi->csi_object_param.cop_objid,
-					pages, npages,
-					off, count, pos, rw);
-	else
-		rc = -ENODEV;
-#endif
-	conn = 0; /* XXX: fix compilability */
-	rc = c2t1fs_internal_read_write(csi, inode, pages, npages, pos, off, play, rw);
-
-        DBG("call read_write returns %d\n", rc);
-	if (rc > 0) {
-		pos += rc;
-		if (rw == WRITE && pos > inode->i_size)
-			inode->i_size = pos;
-		*ppos = pos;
-	}
-out:
-        for (off = 0; off < npages; off++)
-                put_page(pages[off]);
-        kfree(pages);
-        return rc;
-}
-
-static ssize_t c2t1fs_file_aio_read(struct kiocb *iocb, const struct iovec *iov,
-                                    unsigned long nr_segs, loff_t pos)
-{
-	unsigned long seg;
-	ssize_t result = 0;
-        ssize_t count = 0;
-
-        if (nr_segs == 0)
-                return 0;
-
-        for (seg = 0; seg < nr_segs; seg++) {
-		const struct iovec *vec = &iov[seg];
-		result = c2t1fs_read_write(iocb->ki_filp,(char *)vec->iov_base,
-					   vec->iov_len, &iocb->ki_pos,
-					   READ);
-                if (result <= 0)
-                        break;
-                if ((size_t)result < vec->iov_len)
-                        break;
-		count += result;
-        }
-	return count ? count : result;
-}
-
-static ssize_t c2t1fs_file_aio_write(struct kiocb *iocb, const struct iovec *iov,
-                                     unsigned long nr_segs, loff_t pos)
-{
-        struct inode          *inode = iocb->ki_filp->f_dentry->d_inode;
-        struct c2t1fs_sb_info *csi = s2csi(inode->i_sb);
-        ssize_t count = 0;
-        ssize_t rc;
-        int i;
-        int j;
-        int nr_pages = 0;
-        struct page **pages;
-        const struct iovec *iv;
-	unsigned long seg;
-	ssize_t result = 0;
-	struct c2t1fs_conn_clt *conn;
-
-        if (nr_segs == 0)
-                return 0;
-        if (nr_segs == 1)
-                goto normal_write;
-
-        iv = iov;
-        for (i = 0; i < nr_segs; i++, iv++) {
-                unsigned long addr = (unsigned long)iv->iov_base;
-                if (addr < PAGE_OFFSET)
-                        goto normal_write;
-                if (addr & (PAGE_SIZE - 1))
-                        goto normal_write;
-                if (iv->iov_len & (PAGE_SIZE - 1))
-                        goto normal_write;
-                nr_pages += iv->iov_len >> PAGE_SHIFT;
-        }
-
-        pages = kmalloc(sizeof(struct page *) * nr_pages, GFP_KERNEL);
-        if (pages == NULL)
-                goto normal_write;
-
-        iv = iov;
-        for (i = 0, j = 0; i < nr_segs; i++, iv++) {
-                unsigned long base = (unsigned long)iv->iov_base;
-                int len = iv->iov_len;
-                while (len) {
-                        pages[j++] = virt_to_page(base);
-                        base += PAGE_SIZE;
-                        len -= PAGE_SIZE;
-                }
-        }
-        BUG_ON(nr_pages != j);
-#if 0
-	conn = c2t1fs_container_lookup(inode->i_sb, 0);
-	if (conn)
-	        rc = ksunrpc_read_write(conn->xc_conn,
-					csi->csi_object_param.cop_objid,
-					pages, nr_pages,
-					0, nr_pages << PAGE_SHIFT, pos, WRITE);
-	else
-		rc = -ENODEV;
-        if (rc > 0) {
-                pos += rc;
-                if (pos > inode->i_size)
-                        inode->i_size = pos;
-        }
-#endif
-	conn = NULL; /* XXX: fix compilability */
-	csi = NULL; /* XXX: fix compilability */
-	DBG("Currently supported normal writes only!\n");
-	rc = -EINVAL; /* -EPARSE */
-
-        kfree(pages);
-        return rc;
-
-normal_write:
-        DBG("doing normal write for %d segments\n", (int)nr_segs);
-        for (seg = 0; seg < nr_segs; seg++) {
-		const struct iovec *vec = &iov[seg];
-		result = c2t1fs_read_write(iocb->ki_filp,(char *)vec->iov_base,
-					   vec->iov_len, &iocb->ki_pos,
-					   WRITE);
-                if (result <= 0)
-                        break;
-                if ((size_t)result < vec->iov_len)
-                        break;
-		count += result;
-        }
-	return count ? count : result;
-}
-
-
-struct inode_operations c2t1fs_file_inode_operations = {
-};
-
-struct file_operations c2t1fs_file_operations = {
-        .aio_read       = c2t1fs_file_aio_read,
-        .aio_write      = c2t1fs_file_aio_write,
-        .read           = do_sync_read,
-        .write          = do_sync_write,
-};
-
-
-struct address_space_operations c2t1fs_file_aops = {
-};
-
-struct address_space_operations c2t1fs_dir_aops = {
-};
-
-static struct dentry *c2t1fs_lookup(struct inode *dir, struct dentry *dentry,
-                                    struct nameidata *nd);
-
-static int
-c2t1fs_readdir(struct file * filp, void * dirent, filldir_t filldir)
-{
-        struct inode *inode = filp->f_dentry->d_inode;
-        struct c2t1fs_sb_info *csi = s2csi(inode->i_sb);
-        unsigned int ino;
-        int i;
-
-        ino = inode->i_ino;
-	if (ino != C2T1FS_ROOT_INODE)
-		return 0;
-
-        i = filp->f_pos;
-        switch (i) {
-        case 0:
-                if (filldir(dirent, ".", 1, i, ino, DT_DIR) < 0)
-                        goto out;
-                i++;
-                filp->f_pos++;
-                /* fall thru */
-        case 1:
-                if (filldir(dirent, "..", 2, i, ino, DT_DIR) < 0)
-                        goto out;
-                i++;
-                filp->f_pos++;
-                /* fall thru */
-	case 2:
-	{
-		char fn[256];
-		sprintf(fn, "%d", (int)csi->csi_object_param.cop_objid);
-                if (filldir(dirent, fn, strlen(fn), i, csi->csi_object_param.cop_objid, DT_REG) < 0)
-                        goto out;
-                i++;
-                filp->f_pos++;
-                /* fall thru */
-	}
-	default:
-		break;
-	}
-out:
-	return 0;
-}
-
-
-
-static const struct inode_operations c2t1fs_dir_inode_operations = {
-        .lookup = c2t1fs_lookup
-};
-
-static const struct file_operations c2t1fs_dir_operations = {
-        .readdir        = c2t1fs_readdir,
-};
-
-static int c2t1fs_update_inode(struct inode *inode, void *opaque)
-{
-        ino_t ino = *((ino_t *)opaque);
-        __u32 mode;
-
-        inode->i_ino = ino;
-
-        /* FIXME: This is a hack to make it mount (we need root dir) */
-        if (inode->i_ino == C2T1FS_ROOT_INODE)
-                mode = ((S_IRWXUGO | S_ISVTX) & ~current_umask()) | S_IFDIR;
-        else
-                mode = ((S_IRUGO | S_IXUGO) & ~current_umask()) | S_IFREG;
-        inode->i_mode = (inode->i_mode & S_IFMT) | (mode & ~S_IFMT);
-        inode->i_mode = (inode->i_mode & ~S_IFMT) | (mode & S_IFMT);
-        if (S_ISREG(inode->i_mode)) {
-                /* FIXME: This needs to be taken from rpc layer */
-                inode->i_blkbits = min(C2_MAX_BRW_BITS + 1, C2_MAX_BLKSIZE_BITS);
-        } else {
-                inode->i_blkbits = inode->i_sb->s_blocksize_bits;
-        }
-#ifdef HAVE_INODE_BLKSIZE
-        inode->i_blksize = 1 << inode->i_blkbits;
-#endif
-
-        /* FIXME: This needs to be taken from an getattr rpc */
-        if (inode->i_ino == C2T1FS_ROOT_INODE)
-                inode->i_nlink = 2;
-        else
-                inode->i_nlink = 1;
-
-        if (S_ISDIR(inode->i_mode)) {
-                inode->i_size = PAGE_SIZE;
-                inode->i_blocks = 1;
-        } else {
-                inode->i_size = s2csi(inode->i_sb)->csi_object_param.cop_objsize;
-                inode->i_blocks = inode->i_size >> PAGE_SHIFT;
-        }
-
-        return 0;
-}
-
-static int c2t1fs_read_inode(struct inode *inode, void *opaque)
-{
-        C2TIME_S(inode->i_mtime) = 0;
-        C2TIME_S(inode->i_atime) = 0;
-        C2TIME_S(inode->i_ctime) = 0;
-        inode->i_rdev = 0;
-
-        c2t1fs_update_inode(inode, opaque);
-
-        if (S_ISREG(inode->i_mode)) {
-                inode->i_op = &c2t1fs_file_inode_operations;
-                inode->i_fop = &c2t1fs_file_operations;
-                inode->i_mapping->a_ops = &c2t1fs_file_aops;
-        } else if (S_ISDIR(inode->i_mode)) {
-                inode->i_op = &c2t1fs_dir_inode_operations;
-                inode->i_fop = &c2t1fs_dir_operations;
-                inode->i_mapping->a_ops = &c2t1fs_dir_aops;
-        } else {
-                return -ENOSYS;
-        }
-        return 0;
-}
-
-/* called from iget5_locked->find_inode() under inode_lock spinlock */
-static int c2t1fs_test_inode(struct inode *inode, void *opaque)
-{
-        ino_t *ino = opaque;
-        return inode->i_ino == *ino;
-}
-
-static int c2t1fs_set_inode(struct inode *inode, void *opaque)
-{
-        /* FIXME: Set inode info from passed rpc data */
-        return 0;
-}
-
-static struct inode *c2t1fs_iget(struct super_block *sb, ino_t hash)
-{
-        struct inode *inode;
-
-        inode = iget5_locked(sb, hash, c2t1fs_test_inode, c2t1fs_set_inode, &hash);
-        if (inode) {
-                if (inode->i_state & I_NEW) {
-                        c2t1fs_read_inode(inode, &hash);
-                        unlock_new_inode(inode);
-                } else {
-                        if (!(inode->i_state & (I_FREEING | I_CLEAR)))
-                                c2t1fs_update_inode(inode, &hash);
-                }
-        }
-
-        return inode;
-}
-
-static struct dentry *c2t1fs_lookup(struct inode *dir, struct dentry *dentry,
-                                    struct nameidata *nd)
-{
-	struct inode *inode = NULL;
-	unsigned long ino;
-
-	lock_kernel();
-	ino = simple_strtol(dentry->d_name.name, NULL, 0);
-	if (!ino) {
-	        unlock_kernel();
-	        return ERR_PTR(-EINVAL);
-	}
-        inode = c2t1fs_iget(dir->i_sb, ino);
-        if (!inode) {
-                unlock_kernel();
-                return ERR_PTR(-ENOENT);
-        }
-	unlock_kernel();
-	d_add(dentry, inode);
-	return NULL;
-}
-
-static int c2t1fs_fill_super(struct super_block *sb, void *data, int silent)
-{
-        struct c2t1fs_sb_info *csi;
-        struct inode          *root;
-        int rc;
-
-        csi = c2t1fs_init_csi(sb);
-        if (!csi)
-                return -ENOMEM;
-
-        rc = optparse(sb, (char *)data);
-        if (rc) {
-                c2t1fs_put_csi(sb);
-                return rc;
-        }
-        sb->s_blocksize = PAGE_SIZE;
-        sb->s_blocksize_bits = log2(PAGE_SIZE);
-        sb->s_magic = C2T1FS_SUPER_MAGIC;
-        sb->s_maxbytes = MAX_LFS_FILESIZE;
-        sb->s_op = &c2t1fs_super_operations;
-
-        /* make root inode */
-        root = c2t1fs_iget(sb, C2T1FS_ROOT_INODE);
-        if (root == NULL || is_bad_inode(root)) {
-                c2t1fs_put_csi(sb);
-                return -EBADF;
-        }
-
-        sb->s_root = d_alloc_root(root);
-
-        return 0;
-}
-
-static int c2t1fs_get_super(struct file_system_type *fs_type,
-                            int flags, const char *devname, void *data,
-                            struct vfsmount *mnt)
-{
-        struct c2t1fs_sb_info *csi;
-	struct super_block    *sb;
-        int   rc;
-
-	DBG("flags=%x devname=%s, data=%s\n", flags, devname, (char*)data);
-
-        rc = get_sb_nodev(fs_type, flags, data, c2t1fs_fill_super, mnt);
-        if (rc < 0)
-                return rc;
-
-        sb  = mnt->mnt_sb;
-        csi = s2csi(sb);
-
-	rc = c2t1fs_parse_address(sb, devname, &csi->csi_mgmt_srvid);
-	if (rc) {
-		dput(sb->s_root); /* aka mnt->mnt_root, as set by get_sb_nodev() */
-		deactivate_locked_super(sb);
-                return rc;
-	}
-
-	/* connect to mgmt node */
-if (0) {
-	/* XXX no need to connect to mgmt node right now */
-        rc = c2_net_conn_create(&csi->csi_mgmt_srvid);
-        if (rc) {
-		c2t1fs_container_fini(sb);
-		dput(sb->s_root);
-		deactivate_locked_super(sb);
-                return rc;
-	}
-
-        csi->csi_mgmt_conn = c2_net_conn_find(&csi->csi_mgmt_srvid);
-}
-	rc = c2t1fs_container_connect(sb);
-	if (rc) {
-		if (csi->csi_mgmt_conn != NULL) {
-			c2_net_conn_unlink(csi->csi_mgmt_conn);
-			c2_net_conn_release(csi->csi_mgmt_conn);
-			csi->csi_mgmt_conn = NULL;
-		}
-		c2t1fs_container_fini(sb);
-		dput(sb->s_root);
-		deactivate_locked_super(sb);
-	}
-
-        return rc;
-}
-
-static void c2t1fs_kill_super(struct super_block *sb)
-{
-        struct c2t1fs_sb_info *csi = s2csi(sb);
-	struct c2_pdclust_layout *play = csi->csi_object_param.cop_play;
-
-        GETHERE;
-	if (csi->csi_mgmt_conn != NULL) {
-		c2_net_conn_unlink(csi->csi_mgmt_conn);
-		c2_net_conn_release(csi->csi_mgmt_conn);
-		csi->csi_mgmt_conn = NULL;
-	}
-
-	if (play)
-		pdclust_layout_fini(play);
-
-	/* disconnect from container server and free them */
-	c2t1fs_container_fini(sb);
-        kill_anon_super(sb);
-}
-
-static struct file_system_type c2t1fs_fs_type = {
-        .owner        = THIS_MODULE,
-        .name         = "c2t1fs",
-        .get_sb       = c2t1fs_get_super,
-        .kill_sb      = c2t1fs_kill_super,
-        .fs_flags     = FS_BINARY_MOUNTDATA | FS_REQUIRES_DEV
-};
-
-static int c2t1fs_init_inodecache(void)
-{
-	c2t1fs_inode_cachep = kmem_cache_create("c2t1fs_inode_cache",
-					        sizeof(struct c2t1fs_inode_info),
-					        0, SLAB_HWCACHE_ALIGN, NULL);
-	if (c2t1fs_inode_cachep == NULL)
-		return -ENOMEM;
-	return 0;
-}
-
-static void c2t1fs_destroy_inodecache(void)
-{
-        if (!c2t1fs_inode_cachep)
-                return;
-
-	kmem_cache_destroy(c2t1fs_inode_cachep);
-	c2t1fs_inode_cachep = NULL;
-}
-
-int c2t1fs_init_module(void)
-{
-	struct c2_net_domain *dom = &c2t1fs_domain;
-        int rc;
-
-        printk(KERN_INFO
-	       "Colibri C2T1 File System (http://www.clusterstor.com)\n");
-
-	rc = c2_net_xprt_init(&c2_net_ksunrpc_xprt);
-	if (rc)
-		return rc;
-
-	dom->nd_xprt = NULL;
-	rc = c2_net_domain_init(dom, &c2_net_ksunrpc_xprt);
-	if (rc) {
-		c2_net_xprt_fini(&c2_net_ksunrpc_xprt);
-		return rc;
-	}
-
-        rc = c2t1fs_init_inodecache();
-        if (rc)
-                return rc;
-
-
-        rc = register_filesystem(&c2t1fs_fs_type);
-        if (rc == 0) {
-		rc = io_fop_init();
-		if (rc != 0)
-			unregister_filesystem(&c2t1fs_fs_type);
-	} else
-                c2t1fs_destroy_inodecache();
-
-        return rc;
-}
-
-void c2t1fs_cleanup_module(void)
-{
-        int rc;
-
-	io_fop_fini();
-        rc = unregister_filesystem(&c2t1fs_fs_type);
-        c2t1fs_destroy_inodecache();
-        if (rc)
-                printk(KERN_INFO "Colibri C2T1 File System cleanup: %d\n", rc);
-}
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
diff --git a/c2t1fs/linux_kernel/st/common.sh.in b/c2t1fs/linux_kernel/st/common.sh.in
deleted file mode 100644
index c50e9a4..0000000
--- a/c2t1fs/linux_kernel/st/common.sh.in
+++ /dev/null
@@ -1,41 +0,0 @@
-#! /bin/sh
-
-MODLIST="build_kernel_modules/kcolibri.ko"
-
-abort()
-{
-    msg="$1"
-    echo "$1 Aborting."
-    exit 1
-}
-
-modload_galois()
-{
-    BASE=@GALOIS_SRC@
-    if test "x$BASE" = "x"; then
-        modprobe galois
-    else
-        insmod $BASE/src/linux_kernel/galois.ko
-    fi
-}
-
-modunload_galois()
-{
-    rmmod galois
-}
-
-modload()
-{
-    for m in $MODLIST ;do
-	insmod $m                   || abort "Error loading $m."
-    done
-}
-
-modunload()
-{
-    for m in $MODLIST ;do
-	echo $m
-    done | tac | while read ;do
-	rmmod $REPLY                || echo "Error unloading $m."
-    done
-}
diff --git a/c2t1fs/linux_kernel/st/dbench.sh b/c2t1fs/linux_kernel/st/dbench.sh
deleted file mode 100755
index b24a9f8..0000000
--- a/c2t1fs/linux_kernel/st/dbench.sh
+++ /dev/null
@@ -1,69 +0,0 @@
-#
-# Script is temporary disabled, use test2.sh instead.
-#
-echo Script is temporary DISABLED!!!
-exit 1
-
-DBENCH_DIR=""
-
-if [ -z $DBENCH_DIR ] ; then
-	echo "please specify dbench dir";
-	exit;
-fi
-
-cd ../..
-pwd
-
-# get the first non-loopback IP address
-IPAddr=$(/sbin/ifconfig | grep "inet addr" | grep -v "127.0.0.1" | awk -F: '{print $2}' | awk '{print $1}' | head -n 1)
-Port="2222"
-echo "server address is $IPAddr:$Port"
-
-rmmod loop
-
-ulimit -c unlimited
-
-. c2t1fs/linux_kernel/st/common.sh
-
-modload_galois
-insmod build_kernel_modules/kcolibri.ko
-
-lsmod | grep -c "c2t1fs" || exit
-
-rm -rf /tmp/test/
-mkdir -p /tmp/test/
-
-(./stob/ut/server -d/tmp/test -p$Port &)
-sleep 5
-mkdir -p /mnt/c2t1fs
-mount -t c2t1fs -o objid=12345,ds=$IPAddr:$Port $IPAddr:$Port /mnt/c2t1fs
-
-#large file write & read
-dd if=/dev/zero of=/mnt/c2t1fs/12345 bs=1M count=200
-ls -l /mnt/c2t1fs/12345
-
-umount /mnt/c2t1fs
-
-# mount again and check its content
-# 1024 * 1024 * 256 = 268435456
-mount -t c2t1fs -o objid=12345,objsize=268435456,ds=$IPAddr:$Port $IPAddr:$Port /mnt/c2t1fs
-
-sleep 1
-losetup /dev/loop0 /mnt/c2t1fs/12345
-
-mkfs.ext3 /dev/loop0
-mkdir -p /mnt/loop
-mount /dev/loop0 /mnt/loop
-
-# please use your own dbench options here!
-$DBENCH_DIR/dbench -D /mnt/loop/ 2 -t 10 -c $DBENCH_DIR/client.txt
-
-umount /mnt/loop
-losetup -d /dev/loop0
-umount /mnt/c2t1fs
-
-rmmod kcolibri
-modunload_galois
-
-killall lt-server
-echo ======================done=====================
diff --git a/c2t1fs/linux_kernel/st/fs_common.sh b/c2t1fs/linux_kernel/st/fs_common.sh
deleted file mode 100644
index b3b0ab0..0000000
--- a/c2t1fs/linux_kernel/st/fs_common.sh
+++ /dev/null
@@ -1,87 +0,0 @@
-#!/bin/bash
-
-set -x
-. common.sh
-
-fsmount()
-{
-# get the first non-loopback IP address
-IPAddr=$(/sbin/ifconfig | grep "inet addr" | grep -v "127.0.0.1" | awk -F: '{print $2}' | awk '{print $1}' | head -n 1)
-Port0="1111"
-Port1="1112"
-Port2="1113"
-Port3="1114"
-Port4="1115"
-echo "server0 address is $IPAddr:$Port0"
-echo "server1 address is $IPAddr:$Port1"
-echo "server2 address is $IPAddr:$Port2"
-echo "server3 address is $IPAddr:$Port3"
-echo "server4 address is $IPAddr:$Port4"
-
-modunload
-modload
-
-# Run servers on different ports with different stobs:
-cd /tmp
-rm -rf 0 1 2 3 4
-mkdir -p 0 1 2 3 4 
-cd -
-
-(./stob/ut/server -d/tmp/0 -p$Port0 &)
-(./stob/ut/server -d/tmp/1 -p$Port1 &)
-(./stob/ut/server -d/tmp/2 -p$Port2 &)
-(./stob/ut/server -d/tmp/3 -p$Port3 &)
-(./stob/ut/server -d/tmp/4 -p$Port4 &)
-sleep 3
-
-mkdir -p /mnt/c2t1fs
-
-mount -t c2t1fs -o layout-data=3,layout-parity=1,objid=12345,objsize=196608,\
-ds=$IPAddr:$Port0,ds=$IPAddr:$Port1,ds=$IPAddr:$Port2,ds=$IPAddr:$Port3,ds=$IPAddr:$Port4\
- $IPAddr:$Port1 /mnt/c2t1fs
-}
-
-fsumount()
-{
-umount /mnt/c2t1fs
-modunload
-killall lt-server
-}
-
-#arg0 max_count - maximal count per read/write
-#arg1 max_bs    - maximal block size
-fsrwtest()
-{
-max_count_=$1
-max_bs_=$2
-echo "fsrwtest max_count=$max_count, max_bs=$max_bs"
-
-dd if=/dev/urandom of=dummy.bin bs=$(($max_bs_*$max_count_)) count=1
-
-#for count_ in {1..$max_count_}
-for (( count_ = 1; count_ <= $max_count_; count_++ ))
-do
-     #for bs_ in {12288,24576,$max_bs_}
-     for (( bs_ = 12288; bs_ <= $max_bs_; bs_ += 12288))
-     do
-        dd if=dummy.bin of=/mnt/c2t1fs/12345 bs=$bs_ count=$count_
-        left=$(dd if=dummy.bin         bs=$bs_ count=$count_ 2>/dev/null | md5sum)
-	#sleep 2
-        right=$(dd if=/mnt/c2t1fs/12345 bs=$bs_ count=$count_ 2>/dev/null | md5sum)
-	#sleep 2
-	
-	if [ "$left" == "$right" ]
-	then
-	    echo "test {$count_,$bs_} passed."
-	else
-	    echo "test {$count_,$bs_} failed."
-	    echo =========== FFFFF FFFFF  F  F     FFFFF FFFF  FF ===========
-	    echo =========== F     F   F  F  F     F     F   F FF ===========
-	    echo =========== FFF   FFFFF  F  F     FFF   F   F FF ===========
-	    echo =========== F     F   F  F  F     F     F   F    ===========
-	    echo =========== F     F   F  F  FFFFF FFFFF FFFF  FF ===========
-	fi
-     done
- done
-rm dummy.bin
-}
diff --git a/c2t1fs/linux_kernel/st/mini.sh b/c2t1fs/linux_kernel/st/mini.sh
deleted file mode 100644
index b7d46c6..0000000
--- a/c2t1fs/linux_kernel/st/mini.sh
+++ /dev/null
@@ -1,61 +0,0 @@
-#
-# Script is temporary disabled, use test2.sh instead.
-#
-echo Script is temporary DISABLED!!!
-exit 1
-
-set -x
-
-. common.sh
-
-cd ../..
-pwd
-
-# get the first non-loopback IP address
-IPAddr=$(/sbin/ifconfig | grep "inet addr" | grep -v "127.0.0.1" | awk -F: '{print $2}' | awk '{print $1}' | head -n 1)
-Port="2222"
-echo "server address is $IPAddr:$Port"
-rmmod loop
-
-ulimit -c unlimited
-
-modunload
-modload
-
-rm -rf /tmp/test/
-mkdir -p /tmp/test/
-
-(./stob/ut/server -d/tmp/test -p$Port &)
-sleep 5
-mkdir -p /mnt/c2t1fs
-mount -t c2t1fs -o objid=12345,ds=$IPAddr:$Port $IPAddr:$Port /mnt/c2t1fs
-
-#small file write & read
-ls -l /mnt/c2t1fs/12345
-cat c2t1fs/main.c > /mnt/c2t1fs/12345
-ls -l /mnt/c2t1fs/12345
-cat c2t1fs/main.c | md5sum
-cat /mnt/c2t1fs/12345 | md5sum
-
-#large file write & read
-dd if=/dev/zero of=/mnt/c2t1fs/12345 bs=128 count=200
-dd if=/dev/zero of=/mnt/c2t1fs/12345 bs=256 count=200
-dd if=/dev/zero of=/mnt/c2t1fs/12345 bs=512 count=200
-dd if=/dev/zero of=/mnt/c2t1fs/12345 bs=1024 count=200
-dd if=/dev/zero of=/mnt/c2t1fs/12345 bs=1M count=200
-ls -l /mnt/c2t1fs/12345
-dd if=/mnt/c2t1fs/12345 bs=1M count=256 2>/dev/null | md5sum
-dd if=/dev/zero bs=1M count=256 2>/dev/null | md5sum
-
-umount /mnt/c2t1fs
-
-# mount again and check its content
-# 1024 * 1024 * 256 = 268435456
-mount -t c2t1fs -o objid=12345,objsize=268435456,ds=$IPAddr:$Port $IPAddr:$Port /mnt/c2t1fs
-dd if=/mnt/c2t1fs/12345 bs=1M count=256 2>/dev/null | md5sum
-umount /mnt/c2t1fs
-
-modunload
-
-killall lt-server
-echo ======================done=====================
diff --git a/c2t1fs/linux_kernel/st/mount.sh b/c2t1fs/linux_kernel/st/mount.sh
deleted file mode 100755
index cf2290c..0000000
--- a/c2t1fs/linux_kernel/st/mount.sh
+++ /dev/null
@@ -1,12 +0,0 @@
-set -x
-
-. common.sh
-. fs_common.sh
-
-cd ../..
-pwd
-ulimit -c unlimited
-
-fsmount
-
-echo ======================done=====================
diff --git a/c2t1fs/linux_kernel/st/perf.sh b/c2t1fs/linux_kernel/st/perf.sh
deleted file mode 100755
index c5f5195..0000000
--- a/c2t1fs/linux_kernel/st/perf.sh
+++ /dev/null
@@ -1,24 +0,0 @@
-# Using simple layout N/K = 3/1 (with 1 parity and 1 spare unit).
-
-set -x
-
-. common.sh
-. fs_common.sh
-
-cd ../..
-pwd
-ulimit -c unlimited
-
-# 1. mount
-fsmount
-
-# 2. test read/write
-#arg0 max_count_
-#arg1 max_bs_
-#note: 10 * 12582912 ~ 120MiB of data, reads and write
-fsrwtest 10 12582912
-
-# 3. umount
-fsumount
-
-echo ======================done=====================
diff --git a/c2t1fs/linux_kernel/st/standard_loop.sh b/c2t1fs/linux_kernel/st/standard_loop.sh
deleted file mode 100644
index 4201867..0000000
--- a/c2t1fs/linux_kernel/st/standard_loop.sh
+++ /dev/null
@@ -1,76 +0,0 @@
-#
-# Script is temporary disabled, use test2.sh instead.
-#
-echo Script is temporary DISABLED!!!
-exit 1
-
-set -x
-
-. common.sh
-
-cd ../..
-pwd
-
-# get the first non-loopback IP address
-IPAddr=$(/sbin/ifconfig | grep "inet addr" | grep -v "127.0.0.1" | awk -F: '{print $2}' | awk '{print $1}' | head -n 1)
-Port="2222"
-echo "server address is $IPAddr:$Port"
-
-ulimit -c unlimited
-
-modunload
-modload
-
-# we will use built-in loop driver.
-rmmod c2t1fs_loop
-modprobe loop
-
-rm -rf /tmp/test/
-mkdir -p /tmp/test
-
-(./stob/ut/server -d/tmp/test -p$Port &)
-sleep 5
-mkdir -p /mnt/c2t1fs
-mount -t c2t1fs -o objid=12345,ds=$IPAddr:$Port $IPAddr:$Port /mnt/c2t1fs
-
-#small file write & read
-ls -l /mnt/c2t1fs/12345
-cat c2t1fs/main.c > /mnt/c2t1fs/12345
-ls -l /mnt/c2t1fs/12345
-cat c2t1fs/main.c | md5sum
-cat /mnt/c2t1fs/12345 | md5sum
-
-#large file write & read
-dd if=/dev/zero of=/mnt/c2t1fs/12345 bs=1M count=256
-ls -l /mnt/c2t1fs/12345
-dd if=/mnt/c2t1fs/12345 bs=1M count=256 2>/dev/null | md5sum
-dd if=/dev/zero bs=1M count=256 2>/dev/null | md5sum
-
-umount /mnt/c2t1fs
-
-# mount again and check its content
-# 1024 * 1024 * 256 = 268435456
-mount -t c2t1fs -o objid=12345,objsize=268435456,ds=$IPAddr:$Port $IPAddr:$Port /mnt/c2t1fs
-dd if=/mnt/c2t1fs/12345 bs=1M count=256 2>/dev/null | md5sum
-
-# mkfs
-mkfs.ext3 -F /mnt/c2t1fs/12345
-
-
-#attach loop device over c2t1fs file
-sleep 1
-losetup /dev/loop0 /mnt/c2t1fs/12345
-
-mkfs.ext3 /dev/loop0
-mount -t ext3 /dev/loop0 /mnt/loop
-mount
-umount /mnt/loop
-
-losetup -d /dev/loop0
-umount /mnt/c2t1fs
-
-modunload
-rmmod loop
-
-killall lt-server
-echo ======================done=====================
diff --git a/c2t1fs/linux_kernel/st/test.sh b/c2t1fs/linux_kernel/st/test.sh
deleted file mode 100755
index aaa7d44..0000000
--- a/c2t1fs/linux_kernel/st/test.sh
+++ /dev/null
@@ -1,89 +0,0 @@
-#
-# Script is temporary disabled, use test2.sh instead.
-#
-echo Script is temporary DISABLED!!!
-exit 1
-
-set -x
-
-. common.sh
-
-cd ../..
-pwd
-
-# get the first non-loopback IP address
-IPAddr=$(/sbin/ifconfig | grep "inet addr" | grep -v "127.0.0.1" | awk -F: '{print $2}' | awk '{print $1}' | head -n 1)
-Port="2222"
-echo "server address is $IPAddr:$Port"
-rmmod loop
-
-ulimit -c unlimited
-
-modunload
-modload
-
-rm -rf /tmp/test/
-mkdir -p /tmp/test
-
-(./stob/ut/server -d/tmp/test -p$Port 2>/tmp/test/stderr-$$.log &)
-sleep 5
-mkdir -p /mnt/c2t1fs
-mount -t c2t1fs -o objid=12345,ds=$IPAddr:$Port $IPAddr:$Port /mnt/c2t1fs
-
-#small file write & read
-ls -l /mnt/c2t1fs/12345
-cat c2t1fs/main.c > /mnt/c2t1fs/12345
-ls -l /mnt/c2t1fs/12345
-cat c2t1fs/main.c | md5sum
-cat /mnt/c2t1fs/12345 | md5sum
-
-#large file write & read
-dd if=/dev/zero of=/mnt/c2t1fs/12345 bs=1M count=256
-ls -l /mnt/c2t1fs/12345
-dd if=/mnt/c2t1fs/12345 bs=1M count=256 2>/dev/null | md5sum
-dd if=/dev/zero bs=1M count=256 2>/dev/null | md5sum
-
-umount /mnt/c2t1fs
-
-# mount again and check its content
-# 1024 * 1024 * 256 = 268435456
-# !!!! please note:  the file size is 256MB  !!!!
-mount -t c2t1fs -o objid=12345,objsize=268435456,ds=$IPAddr:$Port $IPAddr:$Port /mnt/c2t1fs
-dd if=/mnt/c2t1fs/12345 bs=1M count=256 2>/dev/null | md5sum
-
-#attach loop device over c2t1fs file
-sleep 1
-losetup /dev/loop0 /mnt/c2t1fs/12345
-
-mkfs.ext3 /dev/loop0 || abort "mkfs failed"
-mkdir -p /mnt/loop
-mount /dev/loop0 /mnt/loop || abort "mount failed"
-
-# read & write the loop device file system.
-dd if=/dev/zero of=/mnt/loop/10M bs=1M count=10 oflag=direct
-ls -l /mnt/loop/10M
-dd if=/mnt/loop/10M bs=1M count=10 2>/dev/null | md5sum
-dd if=/dev/zero bs=1M count=10 2>/dev/null | md5sum
-umount /mnt/loop
-
-# again, read & write the loop device file system.
-mount /dev/loop0 /mnt/loop  || abort "mount again failed"
-dd if=/mnt/loop/10M bs=1M count=10 2>/dev/null | md5sum
-umount /mnt/loop
-
-losetup -d /dev/loop0
-umount /mnt/c2t1fs
-
-###### mount c2t1fs and loop again
-mount -t c2t1fs -o objid=12345,objsize=268435456,ds=$IPAddr:$Port $IPAddr:$Port /mnt/c2t1fs
-losetup /dev/loop0 /mnt/c2t1fs/12345
-mount /dev/loop0 /mnt/loop
-dd if=/mnt/loop/10M bs=1M count=10 2>/dev/null | md5sum
-umount /mnt/loop
-losetup -d /dev/loop0
-umount /mnt/c2t1fs
-
-modunload
-
-killall lt-server
-echo ======================done=====================
diff --git a/c2t1fs/linux_kernel/st/test2.sh b/c2t1fs/linux_kernel/st/test2.sh
deleted file mode 100755
index f1b5987..0000000
--- a/c2t1fs/linux_kernel/st/test2.sh
+++ /dev/null
@@ -1,23 +0,0 @@
-# Using simple layout N/K = 3/1 (with 1 parity and 1 spare unit).
-
-set -x
-
-. common.sh
-. fs_common.sh
-
-cd ../..
-pwd
-ulimit -c unlimited
-
-# 1. mount
-fsmount
-
-# 2. test read/write
-#arg0 max_count_=3
-#arg1 max_bs_=49152
-fsrwtest 3 49152
-
-# 3. umount
-fsumount
-
-echo ======================done=====================
diff --git a/c2t1fs/linux_kernel/st/unmount.sh b/c2t1fs/linux_kernel/st/unmount.sh
deleted file mode 100755
index e956a74..0000000
--- a/c2t1fs/linux_kernel/st/unmount.sh
+++ /dev/null
@@ -1,12 +0,0 @@
-set -x
-
-. common.sh
-. fs_common.sh
-
-cd ../..
-pwd
-ulimit -c unlimited
-
-fsumount
-
-echo ======================done=====================
diff --git a/capa/Makefile.am b/capa/Makefile.am
index 96bcb66..8bd06db 100644
--- a/capa/Makefile.am
+++ b/capa/Makefile.am
@@ -1,4 +1,4 @@
-capadir                        = $(includedir)/colibri/capa
+capadir                        = $(includedir)/capa
 capa_HEADERS                   = capa.h
 
 noinst_LTLIBRARIES            = libcolibri-capa.la
diff --git a/capa/ut/capa_ut.c b/capa/ut/capa_ut.c
index a25cefb..dce0117 100644
--- a/capa/ut/capa_ut.c
+++ b/capa/ut/capa_ut.c
@@ -13,7 +13,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Anatoliy Bilenko <Anatoliy_Bilenko@xyratex.com>
+ * Original author: Anatoliy Belinko
  * Original creation date: 01/24/2011
  */
 
diff --git a/cfg/Makefile.am b/cfg/Makefile.am
deleted file mode 100644
index 876fffe..0000000
--- a/cfg/Makefile.am
+++ /dev/null
@@ -1,6 +0,0 @@
-cfgdir                     = $(includedir)/colibri/cfg
-cfg_HEADERS                = cfg.h
-
-noinst_LTLIBRARIES         = libcolibri-cfg.la
-libcolibri_cfg_la_SOURCES  = cfg.h cfg.c
-INCLUDES                   = -I. -I$(top_srcdir) -I$(top_srcdir)/include
diff --git a/cfg/cfg.c b/cfg/cfg.c
deleted file mode 100644
index a3c0c43..0000000
--- a/cfg/cfg.c
+++ /dev/null
@@ -1,66 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Huang Hua <Hua_Huang@xyratex.com>
- *                  Anup Barve <Anup_Barve@xyratex.com>
- * Original creation date: 09/27/2011
- */
-
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif
-
-#include "lib/arith.h"
-#include "lib/misc.h" 
-#include "cfg/cfg.h"
-
-/**
- * @addtogroup conf_schema
- * @{
- */
-
-/* DB Table ops */
-static int dev_key_cmp(struct c2_table *table, const void *key0,
-			const void *key1)
-{
-	const struct c2_cfg_storage_device__key *dev_key0 = key0;
-	const struct c2_cfg_storage_device__key *dev_key1 = key1;
-
-	return memcmp(dev_key0, dev_key1, sizeof *dev_key0);
-}
-
-/* Table ops for disk table */
-const struct c2_table_ops c2_cfg_storage_device_table_ops = {
-        .to = {
-                [TO_KEY] = {
-			.max_size = sizeof(struct c2_cfg_storage_device__key)
-		},
-                [TO_REC] = {
-			.max_size = sizeof(struct c2_cfg_storage_device__val)
-		}
-        },
-        .key_cmp = dev_key_cmp
-};
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 79
- *  scroll-step: 1
- *  End:
- */
diff --git a/cfg/cfg.h b/cfg/cfg.h
deleted file mode 100644
index b3924e1..0000000
--- a/cfg/cfg.h
+++ /dev/null
@@ -1,503 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Huang Hua <Hua_Huang@xyratex.com>
- * Original creation date: 09/27/2011
- */
-
-#ifndef __COLIBRI_CFG_CFG_H__
-#define __COLIBRI_CFG_CFG_H__
-
-/* import */
-#include "lib/types.h"
-#include "fid/fid.h" /** import c2_fid */
-#include "db/db.h"
-
-/**
-   @page DLD_conf_schema DLD for configuration schema
-
-   This page contains the internal on-disk data structures for Colibri
-   configuration information.
-
-   - @ref conf_schema "DLD for Configuration Schema"
- */
-
-/**
-   @defgroup conf_schema Configuration Schema
-   @brief DLD of configuration schema
-
-   This file defines the interfaces and data structures to store and
-   access the Colibri configuration information in database. Colibri
-   configuration information is used to describe how a Colibri file system
-   is organized by storage, nodes, devices, containers, services, etc.
-
-   These data structures are used for on-disk purpose.
-
-   <hr>
-   @section DLD-ovw Overview
-
-   This DLD contains the data structures and routines to organize the
-   configuration information of Colibri, to access these information.
-   These configuration information is stored in database, and is populated
-   to clients and servers who are using these information to take the whole
-   Colibri system up. These information is cached on clients and servers.
-   These information is treated as resources, which are protected by locks.
-   So configuration may be invalidated and re-acquired (that is update)
-   by users when resources are revoked.
-
-   The configuration schema is to provide a way to store, load, and update
-   these informations. How to maintain the relations in-between these data
-   strucctures is done by its upper layer.
-
-   @see HLD of configuration schema <a>https://docs.google.com/a/xyratex.com/document/d/1JmsVBV8B4R-FrrYyJC_kX2ibzC1F-yTHEdrm3-FLQYk/edit?hl=en_US</a>
-   @{
-*/
-
-enum {
-	/** uuid string size */
-	C2_CFG_UUID_SIZE = 40
-};
-
-/**
-   config uuid
- */
-struct c2_cfg_uuid {
-	/** uuid */
-	char cu_uuid[C2_CFG_UUID_SIZE];
-};
-
-/**
-   state bits for node, device, nic, etc. These bits can be OR'd and tested.
-*/
-enum c2_cfg_state_bit {
-	/** set if Online, and clear if Offline */
-	C2_CFG_STATE_ONLINE  = 1 << 0,
-
-	/** set if Good, and clear if Failed    */
-	C2_CFG_STATE_GOOD    = 1 << 1
-};
-
-/**
-   Property flag bits for node, device, nic, etc. These bits can be OR'd and tested.
-*/
-enum c2_cfg_flag_bit {
-	/** set if real machine, and clear if virtual machine */
-	C2_CFG_FLAG_REAL          = 1 << 0,
-
-	/** set if Little-endian CPU, and clear if Big-endian CPU */
-	C2_CFG_FLAG_LITTLE_ENDIAN = 1 << 1,
-
-	/** set if a disk/device is removable */
-	C2_CFG_FLAG_REMOVABLE     = 1 << 2,
-};
-
-
-enum {
-	/** maximum name length */
-	C2_CFG_NAME_LEN  = 128,
-
-	/** double of the maximum name length */
-	C2_CFG_NAME_LEN2 = C2_CFG_NAME_LEN * 2
-};
-
-/**
-   Colibri node configuration key.
-   Keyed by human readable node name.
-
-*/
-struct c2_cfg_node__key {
-	/** node name */
-	char               cn_name[C2_CFG_NAME_LEN];
-};
-
-/**
-   Colibri node configuration value.
-*/
-struct c2_cfg_node__val {
-	/** node uuid         */
-	struct c2_cfg_uuid cn_uuid;
-
-	/** memory size in MB */
-	uint32_t	   cn_memory_size;
-
-	/** # of processors   */
-	uint32_t	   cn_nr_processors;
-
-	/** last known state. @see c2_cfg_state_bit  */
-	uint64_t           cn_last_state;
-
-	/** node property flag. @see c2_cfg_flag_bit  */
-	uint64_t           cn_flags;
-
-	/** pool id, foreign-key. @see c2_cfg_pool__key    */
-	uint64_t	   cn_pool_id;
-};
-
-
-/**
-   Network interface types.
-*/
-enum c2_cfg_nic_type {
-	/** Ethernet, 10Mb */
-	C2_CFG_NIC_ETHER10 = 1,
-
-	/** Ethernet, 100Mb */
-	C2_CFG_NIC_ETHER100,
-
-	/** Ethernet, 1000Mb */
-	C2_CFG_NIC_ETHER1000,
-
-	/** Ethernet, 10gb */
-	C2_CFG_NIC_ETHER10GB,
-
-	/** Infini/Band */
-	C2_CFG_NIC_INFINIBAND
-};
-
-/**
-   Colibri network intercase card key.
-   keyed by nic name.
-*/
-struct c2_cfg_nic__key {
-	/** HW address. */
-	char     cn_hw_addr[C2_CFG_NAME_LEN];
-};
-
-/**
-   Colibri network intercase card value.
-*/
-struct c2_cfg_nic__val {
-	/** network interface type. @see c2_cfg_nic_type */
-	uint32_t cn_interface_type;
-
-	/** MTU  */
-	uint32_t cn_mtu;
-
-	/** speed, Mbits/second */
-	uint64_t cn_speed;
-
-	/** host node name, foreign-key     */
-	char     cn_node_name[C2_CFG_NAME_LEN];
-
-	/** nic's file name in host OS  */
-	char     cn_file_name[C2_CFG_NAME_LEN];
-
-	/** state. @see c2_cfg_state_bit  */
-	uint64_t cn_last_state;
-};
-
-
-/**
-   Colibri device interface types.
-*/
-enum c2_cfg_storage_device_interface_type {
-	C2_CFG_DEVICE_INTERFACE_ATA = 1,  /**< ATA     */
-	C2_CFG_DEVICE_INTERFACE_SATA,     /**< SATA    */
-	C2_CFG_DEVICE_INTERFACE_SCSI,     /**< SCSI    */
-	C2_CFG_DEVICE_INTERFACE_SATA2,    /**< SATA II */
-	C2_CFG_DEVICE_INTERFACE_SCSI2,    /**< SCSI II */
-	C2_CFG_DEVICE_INTERFACE_SAS,      /**< SAS     */
-	C2_CFG_DEVICE_INTERFACE_SAS2      /**< SAS II  */
-};
-
-
-/**
-   Colibri device media types.
-*/
-enum c2_cfg_storage_device_media_type {
-	/** spin disk       */
-	C2_CFG_DEVICE_MEDIA_DISK = 1,
-
-	/** SSD or flash memory */
-	C2_CFG_DEVICE_MEDIA_SSD,
-
-	/** tape            */
-	C2_CFG_DEVICE_MEDIA_TAPE,
-
-	/** read-only memory, like CD */
-	C2_CFG_DEVICE_MEDIA_ROM
-};
-
-/**
-   Colibri storage device configuration key.
-   Keyed by uuid.
-*/
-struct c2_cfg_storage_device__key {
-	/** device uuid */
-	struct c2_cfg_uuid csd_uuid;
-};
-
-/**
-   Colibri storage device configuration value.
-
-   @see c2_cfg_storage_device_interface_type and,
-   @see c2_cfg_storage_device_media_type for type and media field.
-*/
-struct c2_cfg_storage_device__val {
-	/** interface type. @see c2_cfg_storage_device_interface_type  */
-	uint32_t csd_type;
-
-	/** media type. @see c2_cfg_storage_device_media_type */
-	uint32_t csd_media;
-
-	/** size in bytes    */
-	uint64_t csd_size;
-
-	/** last known state. @see c2_cfg_state_bit */
-	uint64_t csd_last_state;
-
-	/** property flags. @see c2_cfg_flag_bit */
-	uint64_t csd_flags;
-
-	/** filename in host OS */
-	char     csd_filename[C2_CFG_NAME_LEN];
-
-	/** the hosting node, foreign-key */
-	char     csd_nodename[C2_CFG_NAME_LEN];
-};
-
-const struct c2_table_ops c2_cfg_storage_device_table_ops;
-
-/**
-   Colibri partition types.
-*/
-enum c2_cfg_storage_device_partition_type {
-	/** RAW partition. Used as raw device.  */
-	C2_CFG_PARTITION_TYPE_RAW = 0,
-
-	/** ext2 fs partition   */
-	C2_CFG_PARTITION_TYPE_EXT2,
-
-	/** ext3 fs partition   */
-	C2_CFG_PARTITION_TYPE_EXT3,
-
-	/** ext4 fs partition   */
-	C2_CFG_PARTITION_TYPE_EXT4,
-
-	/** xfs fs partition    */
-	C2_CFG_PARTITION_TYPE_XFS,
-
-	/** jfs fs partition    */
-	C2_CFG_PARTITION_TYPE_JFS,
-
-	/** reiser fs partition */
-	C2_CFG_PARTITION_TYPE_REISERFS,
-
-	/** btrfs fs partition  */
-	C2_CFG_PARTITION_TYPE_BTRFS,
-};
-
-/**
-   Colibri storage devide partitions configuration key.
-   Keyed by partition uuid.
-*/
-struct c2_cfg_storage_device_partition__key {
-	/** partition uuid  */
-	struct c2_cfg_uuid csdp_uuid;
-};
-
-/**
-   Colibri storage devide partitions configuration value.
-*/
-struct c2_cfg_storage_device_partition__val {
-	/** start offset in bytes */
-	uint64_t           csdp_start;
-
-	/** size in bytes         */
-	uint64_t           csdp_size;
-
-	/** host device uuid,foreign-key*/
-	struct c2_cfg_uuid csdp_devide_uuid;
-
-	/** partition index       */
-	uint32_t           csdp_index;
-
-	/** partition type. @see c2_cfg_storage_device_partition_type */
-	uint32_t           csdp_type;
-
-	/** filename in OS  */
-	char               csdp_filename[C2_CFG_NAME_LEN];
-};
-
-enum {
-	/** maximum number of params */
-	C2_CFG_PARAM_LEN = 128
-};
-
-/**
-   Colibri pool configuration key.
-   Keyed by pool id.
-*/
-struct c2_cfg_pool__key {
-	/** pool id */
-	uint64_t cp_id;
-};
-
-/**
-   Colibri pool configuration value.
-*/
-struct c2_cfg_pool__val {
-	/** pool name */
-	char     cp_name[C2_CFG_NAME_LEN];
-
-	/** pool state bits. @see c2_cfg_state_bit */
-	uint64_t cp_last_state;
-
-	/** list of parameters for this pool, identified by param id. */
-	uint64_t cp_param_list[C2_CFG_PARAM_LEN];
-};
-
-/**
-   Colibri file system configuration key.
-   keyed by file system name.
-*/
-struct c2_cfg_filesystem__key {
-	/** file system name   */
-	char          cf_name[C2_CFG_NAME_LEN];
-};
-
-/**
-   Colibri file system configuration val.
-   keyed by file system name.
-*/
-struct c2_cfg_filesystem__val {
-	/** file system root fid    */
-	struct c2_fid cf_rootfid;
-
-	/** list of parameters for this file system, identified by param id.*/
-	uint64_t cp_param_list[C2_CFG_PARAM_LEN];
-};
-
-/**
-   Colibri service type.
-*/
-enum c2_cfg_service_type {
-	/** metadata service       */
-	C2_CFG_SERVICE_METADATA = 1,
-
-	/** io/data service        */
-	C2_CFG_SERVICE_IO,
-
-	/** management service     */
-	C2_CFG_SERVICE_MGMT,
-
-	/** DLM service            */
-	C2_CFG_SERVICE_DLM,
-};
-
-/**
-   Colibri service configuration key.
-   Keyed by service uuid.
-*/
-struct c2_cfg_service__key {
-	/** service uuid  */
-	struct c2_cfg_uuid       cs_uuid;
-};
-
-enum {
-	C2_CFG_SERVICE_MAX_END_POINTS = 16
-};
-
-/**
-   Colibri service configuration val.
-*/
-struct c2_cfg_service__val {
-	/** service type. @see c2_cfg_service_type */
-	uint32_t cs_type;
-
-	/** unused. 64-bit alligned. */
-	uint32_t cs_unsed;
-
-	/** host node name,   foreign-key  */
-	char     cs_host_node_name[C2_CFG_NAME_LEN];
-
-	/** file system name, foreign-key  */
-	char     cs_fs_name[C2_CFG_NAME_LEN];
-
-	/**
-	   The array end_points[] gives a list of end-points from which
-	   the service is reachable.
-
-	   end_points[] is an array of character strings. Each element is a
-	   string that can be passed to c2_net_end_point_create() as 'addr'
-	   argument, to create a c2_net_end_point object.
-	   See doxygen header of c2_net_end_point_create(), to know more
-	   about addr argument.
-	 */
-	char     cs_end_points[C2_CFG_SERVICE_MAX_END_POINTS][C2_CFG_NAME_LEN];
-};
-
-
-/**
-   Colibri profile configuration key.
-   Keyed by profile name.
-*/
-struct c2_cfg_profile__key {
-	/** profile name */
-	char cp_name[C2_CFG_NAME_LEN];
-};
-
-/**
-   Colibri profile configuration value.
-*/
-struct c2_cfg_profile__val {
-	/** its file system name  */
-	char cp_fs_name[C2_CFG_NAME_LEN];
-};
-
-/**
-   Colibri configure parameters configuration key.
-   Keyed by param id. The param is represented by "key=value".
-   Sometimes, only keys exist, e.g. "readonly".
-*/
-struct c2_cfg_param__key {
-	/** param id */
-	uint64_t cp_id;
-};
-
-/**
-   Colibri configure parameters configuration value.
-*/
-struct c2_cfg_param__val {
-	/** param itself: key=value */
-	char     cp_param[C2_CFG_NAME_LEN2];
-};
-
-#define C2_CFG_DEVICE_DB_TABLE     "devices"
-#define C2_CFG_FS_DB_TABLE         "fs"
-#define C2_CFG_NIC_DB_TABLE        "nics"
-#define C2_CFG_NODE_DB_TABLE       "nodes"
-#define C2_CFG_PARTITION_DB_TABLE  "partitions"
-#define C2_CFG_PARAM_DB_TABLE      "params"
-#define C2_CFG_POOL_DB_TABLE       "pools"
-#define C2_CFG_PROFILE_DB_TABLE    "profiles"
-#define C2_CFG_SERVICE_DB_TABLE    "services"
-
-/**
-   @} conf_schema end group
-*/
-
-#endif /*  __COLIBRI_CFG_CFG_H__ */
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 79
- *  scroll-step: 1
- *  End:
- */
diff --git a/cob/Makefile.am b/cob/Makefile.am
index 0980f8c..d588255 100644
--- a/cob/Makefile.am
+++ b/cob/Makefile.am
@@ -1,4 +1,4 @@
-cobdir                     = $(includedir)/colibri/cob
+cobdir                     = $(includedir)/cob
 cob_HEADERS                = cob.h
 
 noinst_LTLIBRARIES         = libcolibri-cob.la
diff --git a/cob/cob.c b/cob/cob.c
index f70f59d..ff32052 100644
--- a/cob/cob.c
+++ b/cob/cob.c
@@ -32,11 +32,7 @@
 #include "lib/memory.h"
 #include "lib/bitstring.h"
 
-#include "cob/cob.h"
-
-#ifdef __KERNEL__
-#define printf printk
-#endif
+#include "cob.h"
 
 /**
    @addtogroup cob
@@ -311,7 +307,6 @@ int c2_cob_domain_init(struct c2_cob_domain *dom, struct c2_dbenv *env,
 
         return 0;
 }
-C2_EXPORTED(c2_cob_domain_init);
 
 void c2_cob_domain_fini(struct c2_cob_domain *dom)
 {
@@ -322,7 +317,6 @@ void c2_cob_domain_fini(struct c2_cob_domain *dom)
 	c2_rwlock_fini(&dom->cd_guard);
 	c2_addb_ctx_fini(&dom->cd_addb);
 }
-C2_EXPORTED(c2_cob_domain_fini);
 
 static void cob_free_cb(struct c2_ref *ref);
 
diff --git a/cob/cob.h b/cob/cob.h
index 836dce5..c5d5dbc 100644
--- a/cob/cob.h
+++ b/cob/cob.h
@@ -590,16 +590,6 @@ int c2_cob_fabrec_size_max(void);
 
 void c2_cob_make_fabrec_max(struct c2_cob_fabrec **rech);
 
-/**
-   Helper routine to allocate and initialize c2_cob_nskey
-
-   If memory allocation fails then *keyh is set to NULL
- */
-void c2_cob_nskey_make(struct c2_cob_nskey **keyh, uint64_t hi, uint64_t lo,
-                        const char *name);
-
-void c2_cob_namespace_traverse(struct c2_cob_domain *dom);
-void c2_cob_fb_traverse(struct c2_cob_domain *dom);
 /** @} end group cob */
 
 /* __COLIBRI_COB_COB_H__ */
diff --git a/colibri.spec.in b/colibri.spec.in
deleted file mode 100644
index bd228d6..0000000
--- a/colibri.spec.in
+++ /dev/null
@@ -1,50 +0,0 @@
-Name:    colibri
-Version: @VERSION@
-Release: 1
-Summary: Colibri filesystem and development libraries
-Group: System Environment/Base
-License: Xyratex
-Source: %{name}-%{version}.tar.gz
-BuildRoot: %{_tmppath}/%{name}-%{version}
-Requires: CUnit = 2.1-2 libyaml galois db4
-BuildRequires: CUnit = 2.1-2 libyaml-devel galois-devel db4-devel automake autoconf libtool
-
-%description
-Colibri filesystem runtime environment and servers.
-
-%package devel
-Summary:	%{name} development package
-Group:		Development/Libraries
-Requires:	%{name} = %{version} libyaml-devel galois-devel db4-devel
-
-%description devel
-Colibri filesystem development environment.
-
-%prep
-%setup  -q -n %{name}-%{version}
-
-%build
-%configure --program-prefix=%{?_program_prefix:%{_program_prefix}}
-make 
-
-%install
-rm -rf $RPM_BUILD_ROOT
-export INSTALL_MOD_PATH=$RPM_BUILD_ROOT
-DESTDIR="$RPM_BUILD_ROOT" make install
-
-%files
-%defattr(-,root,root)
-%doc AUTHORS README NEWS ChangeLog COPYING INSTALL
-%{_libdir}/libcolibri*.so*
-/lib/modules/*
-/usr/sbin/*
-
-%post
-/sbin/depmod -a
-
-%files devel
-%defattr(-,root,root)
-%doc AUTHORS README NEWS ChangeLog COPYING INSTALL doc
-%{_includedir}/*
-%{_libdir}/libcolibri*.a*
-%{_libdir}/libcolibri*.la*
diff --git a/colibri/.gitignore b/colibri/.gitignore
deleted file mode 100644
index c29e20d..0000000
--- a/colibri/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-colibri_setup
diff --git a/colibri/Makefile.am b/colibri/Makefile.am
index e270fd8..4d44275 100644
--- a/colibri/Makefile.am
+++ b/colibri/Makefile.am
@@ -1,24 +1,15 @@
-colibridir                = $(includedir)/colibri/colibri
-colibri_HEADERS           = init.h colibri_setup.h
-
-SUBDIRS                   = .
-
-sbin_PROGRAMS             = colibri_setup
-colibri_setup_SOURCES     = cs_main.c colibri_setup.c colibri_setup.h
-colibri_setup_LDADD       = $(top_builddir)/colibri/libcolibri.la
-colibri_setup_CFLAGS      = $(AM_CFLAGS)
+SUBDIRS                   = . 
 
 lib_LTLIBRARIES           = libcolibri.la
-libcolibri_la_SOURCES     = init.h init.c colibri_setup.c colibri_setup.h
-libcolibri_la_LDFLAGS     = -release @LT_RELEASE@ -pthread
-libcolibri_la_LIBADD      = @AIO_LIBS@ @PTHREAD_LIBS@ @DB_LIBS@ @GALOIS_LIBS@ @YAML_LIBS@ @CUNIT_LIBS@ \
+
+libcolibri_la_SOURCES     = init.h init.c
+libcolibri_la_LDFLAGS     = -release @LT_RELEASE@ -pthread 
+libcolibri_la_LIBADD      = @AIO_LIBS@ @PTHREAD_LIBS@ @DB_LIBS@ @GALOIS_LIBS@ @CUNIT_LIBS@ \
                             -lm -lncurses \
                             $(top_builddir)/addb/libcolibri-addb.la \
                             $(top_builddir)/balloc/libcolibri-balloc.la \
                             $(top_builddir)/capa/libcolibri-capa.la \
-                            $(top_builddir)/cfg/libcolibri-cfg.la \
                             $(top_builddir)/cob/libcolibri-cob.la \
-                            $(top_builddir)/console/libcolibri-console.la \
                             $(top_builddir)/db/libcolibri-db.la \
                             $(top_builddir)/desim/libcolibri-desim.la \
                             $(top_builddir)/dtm/libcolibri-dtm.la \
@@ -43,9 +34,5 @@ libcolibri_la_LIBADD      = @AIO_LIBS@ @PTHREAD_LIBS@ @DB_LIBS@ @GALOIS_LIBS@ @Y
                             $(top_builddir)/mdservice/libcolibri-mdservice.la \
                             $(top_builddir)/mdstore/libcolibri-mdstore.la \
                             $(top_builddir)/iostore/libcolibri-iostore.la \
-                            $(top_builddir)/ut/libcolibri-ut.la \
-                            $(top_builddir)/ioservice/libcolibri-ioservice.la \
-                            $(top_builddir)/rpc/libcolibri-rpc.la \
-                            $(top_builddir)/xcode/libcolibri-xcode.la \
-                            $(top_builddir)/xcode/ff2c/libcolibri-xcode-ff2c.la \
-                            $(top_builddir)/yaml2db/libcolibri-yaml2db.la
+			    $(top_builddir)/xdr/libcolibri-xdr.la
+#                            $(top_builddir)/rpc/libcolibri-rpc.la
diff --git a/colibri/colibri_setup.c b/colibri/colibri_setup.c
deleted file mode 100644
index 9da575b..0000000
--- a/colibri/colibri_setup.c
+++ /dev/null
@@ -1,1602 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Mandar Sawant <mandar_sawant@xyratex.com>
- * Original creation date: 05/08/2011
- */
-
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif
-
-#include <stdio.h>     /* fprintf */
-#include <sys/stat.h>  /* mkdir */
-#include <sys/types.h> /* mkdir */
-#include <string.h>    /* strtok_r, strcmp */
-
-#include "lib/errno.h"
-#include "lib/assert.h"
-#include "lib/memory.h"
-#include "lib/getopts.h"
-#include "lib/processor.h"
-#include "lib/time.h"
-
-#include "stob/stob.h"
-#include "stob/ad.h"
-#include "stob/linux.h"
-#include "net/net.h"
-#include "rpc/rpc2.h"
-#include "reqh/reqh_service.h"
-#include "reqh/reqh.h"
-#include "balloc/balloc.h"
-#include "colibri/colibri_setup.h"
-
-/**
-   @addtogroup colibri_setup
-   @{
- */
-
-/**
-   Represents cob domain id, it is incremented for every new cob domain.
-
-   @todo Have a generic mechanism to generate unique cob domain id.
- */
-static int cdom_id;
-
-/**
-   Magic used to check consistency of cs_reqh_context.
- */
-enum {
-	/** Hex value for "csrhctxs" */
-	CS_REQH_CTX_MAGIC = 0x6373726863747873,
-	/** Hex value for "csnetdom" */
-	CS_NET_DOMS_MAGIC = 0x63736e6574646f6d
-};
-
-enum {
-	WAIT_FOR_REQH_SHUTDOWN = 1000000,
-};
-
-extern const struct c2_tl_descr c2_rstypes_descr;
-extern struct c2_tl c2_rstypes;
-extern struct c2_mutex c2_rstypes_mutex;
-
-extern const struct c2_tl_descr c2_rh_sl_descr;
-extern const struct c2_tl_descr c2_rh_rpml_descr;
-
-/**
-   Internal structure which encapsulates stob type and
-   stob domain references for linux and ad stobs respectively.
- */
-struct cs_reqh_stobs {
-	/**
-	   Type of storage domain to be initialise (e.g. Linux or AD)
-	 */
-	const char            *stype;
-	/**
-	   Backend storage object id
-	 */
-	struct c2_stob_id      stob_id;
-	/**
-	   Linux storage domain type.
-	 */
-	struct c2_stob_domain *linuxstob;
-	/**
-	   Allocation data storage domain type.
-	 */
-	struct c2_stob_domain *adstob;
-};
-
-/**
-   Represents state of a request handler context.
- */
-enum {
-        /**
-	   A request handler context is in RC_UNINTIALISED state when it is
-	   allocated and added to the list of the same in struct c2_colibri.
-
-	   @see c2_colibri::cc_reqh_ctxs
-	 */
-	RC_UNINITIALISED,
-	/**
-	   A request handler context is in RC_INITIALISED state once the
-	   request handler (embedded inside the context) is successfully
-	   initialised.
-
-	   @see cs_reqh_context::rc_reqh
-	 */
-	RC_INITIALISED
-};
-
-/**
-   Contains extracted network endpoint and transport from colibri endpoint.
- */
-struct cs_endpoint_and_xprt {
-	/**
-	   3-tuple network layer endpoint address.
-	   e.g. 127.0.0.1:1024:1
-	 */
-	const char *endpoint;
-	/** Supported network transport. */
-	const char *xprt;
-	/**
-	   Scratch buffer for endpoint and transport extraction.
-	 */
-	char *scrbuf;
-};
-
-/**
-   Represents a request handler environment.
-   It contains configuration information about the various global entities
-   to be configured and their corresponding instances that are needed to be
-   initialised before the request handler is started, which by itself is
-   contained in the same structure.
- */
-struct cs_reqh_context {
-	/** Storage path for request handler context. */
-	const char                  *rc_stpath;
-
-	/** Type of storage to be initialised. */
-	const char                  *rc_stype;
-
-	/** Database environment path for request handler context. */
-	const char                  *rc_dbpath;
-
-	/** Services running in request handler context. */
-	const char                 **rc_services;
-
-	/** Number services in request handler context. */
-	int                          rc_snr;
-
-	/**
-	    Maximum number of services allowed per request handler context.
-	 */
-	int                          rc_max_services;
-
-	/** Endpoints and xprts per request handler context. */
-	struct cs_endpoint_and_xprt *rc_eps;
-
-	/** Number of endpoints configured per request handler context. */
-	int                          rc_enr;
-
-	/**
-	    Maximum number of endpoints allowed per request handler context.
-	 */
-	int                          rc_max_eps;
-
-	/**
-	    State of a request handler context, i.e. RC_INITIALISED or
-	    RC_UNINTIALISED.
-	 */
-	int                          rc_state;
-
-	/** Storage domain for a request handler */
-	struct cs_reqh_stobs         rc_stob;
-
-	/** Database used by the request handler */
-	struct c2_dbenv              rc_db;
-
-	/** Cob domain to be used by the request handler */
-	struct c2_cob_domain         rc_cdom;
-
-	struct c2_cob_domain_id      rc_cdom_id;
-
-	/** File operation log for a request handler */
-	struct c2_fol                rc_fol;
-
-	/** Request handler instance to be initialised */
-	struct c2_reqh               rc_reqh;
-
-	/** Reqh context magic */
-	uint64_t                     rc_magic;
-
-	/** Linkage into reqh context list */
-	struct c2_tlink              rc_linkage;
-};
-
-enum {
-	LINUX_STOB,
-	AD_STOB,
-	STOBS_NR
-};
-
-/**
-   Currently supported stob types in colibri context.
- */
-static const char *cs_stobs[] = {
-	[LINUX_STOB] = "Linux",
-	[AD_STOB]    = "AD"
-};
-
-extern struct c2_balloc colibri_balloc;
-
-static const struct c2_tl_descr rctx_descr = C2_TL_DESCR("reqh contexts",
-                                                         struct cs_reqh_context,
-                                                         rc_linkage,
-                                                         rc_magic,
-                                                         CS_REQH_CTX_MAGIC,
-                                                         CS_REQH_CTX_MAGIC);
-
-static const struct c2_tl_descr ndoms_descr = C2_TL_DESCR("network domains",
-                                                   struct c2_net_domain,
-                                                   nd_app_linkage,
-                                                   nd_magic,
-                                                   C2_NET_MAGIC,
-                                                   CS_NET_DOMS_MAGIC);
-
-static struct c2_net_domain *cs_net_domain_locate(struct c2_colibri *cctx,
-							const char *xprt);
-/**
-   Looks up an xprt by the name.
-
-   @param xprt_name Network transport name
-   @param xprts Array of network transports supported in a colibri environment
-   @param xprts_nr Size of xprts array
-
-   @pre xprt_name != NULL && xprts != NULL && xprts_nr > 0
-
- */
-static struct c2_net_xprt *cs_xprt_lookup(const char *xprt_name,
-		struct c2_net_xprt **xprts, int xprts_nr)
-{
-        int   i;
-
-	C2_PRE(xprt_name != NULL && xprts != NULL && xprts_nr > 0);
-
-        for (i = 0; i < xprts_nr; ++i)
-                if (strcmp(xprt_name, xprts[i]->nx_name) == 0)
-                        return xprts[i];
-        return NULL;
-}
-
-/**
-   Lists supported network transports.
- */
-static void cs_xprts_list(FILE *out, struct c2_net_xprt **xprts, int xprts_nr)
-{
-        int i;
-
-	C2_PRE(out != NULL && xprts != NULL);
-
-        fprintf(out, "\nSupported transports:\n");
-        for (i = 0; i < xprts_nr; ++i)
-                fprintf(out, " %s\n", xprts[i]->nx_name);
-}
-
-/**
-   Lists supported stob types.
- */
-static void cs_stob_types_list(FILE *out)
-{
-	int i;
-
-	C2_PRE(out != NULL);
-
-	fprintf(out, "\nSupported stob types:\n");
-	for (i = 0; i < STOBS_NR; ++i)
-		fprintf(out, " %s\n", cs_stobs[i]);
-}
-
-/**
-   Checks if the specified storage type is supported in a colibri context.
-
-   @param stype Storage type
-
-   @pre stype != NULL
- */
-static bool stype_is_valid(const char *stype)
-{
-	C2_PRE(stype != NULL);
-
-	return  strcasecmp(stype, cs_stobs[AD_STOB]) == 0 ||
-		strcasecmp(stype, cs_stobs[LINUX_STOB]) == 0;
-}
-
-/**
-   Lists supported services.
- */
-static void cs_services_list(FILE *out)
-{
-	struct c2_reqh_service_type *stype;
-
-	C2_PRE(out != NULL);
-
-	if (c2_tlist_is_empty(&c2_rstypes_descr, &c2_rstypes)) {
-		fprintf(out, "No available services\n");
-		return;
-	}
-
-	fprintf(out, "Supported services:\n");
-	c2_tlist_for(&c2_rstypes_descr, &c2_rstypes, stype) {
-		fprintf(out, " %s\n", stype->rst_name);
-	} c2_tlist_endfor;
-}
-
-/**
-   Checks if given network transport and network endpoint address are already
-   in use in a request handler context.
-
-   @param cctx Colibri context
-   @param xprt Network transport
-   @param ep Network end point address
-
-   @pre cctx != NULL && xprt != NULL && ep != NULL
- */
-static bool cs_endpoint_is_duplicate(struct c2_colibri *cctx,
-				const struct c2_net_xprt *xprt, const char *ep)
-{
-	int                      cnt;
-	int                      idx;
-	struct cs_reqh_context  *rctx;
-
-	C2_PRE(cctx != NULL && xprt != NULL && ep != NULL);
-
-        C2_ASSERT(!c2_tlist_is_empty(&rctx_descr, &cctx->cc_reqh_ctxs));
-
-	c2_tlist_for(&rctx_descr, &cctx->cc_reqh_ctxs, rctx) {
-		for (idx = 0, cnt = 0; idx < rctx->rc_enr; ++idx) {
-			if (strcmp(rctx->rc_eps[idx].endpoint, ep) == 0 ||
-                            strcmp(rctx->rc_eps[idx].xprt, xprt->nx_name) == 0)
-				++cnt;
-			if (cnt > 1)
-				return true;
-		}
-	} c2_tlist_endfor;
-
-	return false;
-}
-
-/**
-   Checks if given network endpoint address and network transport are valid
-   and if they are already in use in given colibri context.
-
-   @param cctx Colibri context
-   @param ep Network endpoint address
-   @param xprt_name Network transport name
-
-   @pre cctx != NULL && ep != NULL && xprt_name != NULL
-
-   @retval 0 On success
-	-EINVAL If endpoint is invalid
-	-EADDRINUSE If endpoint is already in use
-*/
-static int cs_endpoint_validate(struct c2_colibri *cctx, const char *ep,
-							const char *xprt_name)
-{
-	int                 rc;
-	struct c2_net_xprt *xprt;
-
-	C2_PRE(cctx != NULL && ep != NULL && xprt_name != NULL);
-
-	rc = 0;
-	xprt = cs_xprt_lookup(xprt_name, cctx->cc_xprts, cctx->cc_xprts_nr);
-	if (xprt == NULL)
-		rc = -EINVAL;
-
-	if (rc == 0 && cs_endpoint_is_duplicate(cctx, xprt, ep))
-		rc = -EADDRINUSE;
-
-	return rc;
-}
-
-/**
-   Extracts network transport name and network endpoint address from given
-   colibri endpoint.
-   Colibri endpoint is of 2 parts network xprt:network endpoint.
- */
-static int ep_and_xprt_get(struct cs_endpoint_and_xprt *ep_xprt, const char *ep)
-{
-	char *sptr;
-
-	C2_PRE(ep_xprt != NULL && ep != NULL);
-
-	C2_ALLOC_ARR(ep_xprt->scrbuf, strlen(ep) + 1);
-	strcpy(ep_xprt->scrbuf, ep);
-	ep_xprt->xprt = strtok_r(ep_xprt->scrbuf, ":", &sptr);
-	if (ep_xprt->xprt == NULL)
-		return -EINVAL;
-
-	ep_xprt->endpoint = strtok_r(NULL , "\0", &sptr);
-	if (ep_xprt->endpoint == NULL)
-		return -EINVAL;
-
-	return 0;
-}
-
-/**
-   Checks if specified service has already a duplicate entry in given request
-   handler context.
- */
-static bool service_is_duplicate(const struct c2_colibri *cctx, const char *sname)
-{
-	int                     idx;
-	int                     cnt;
-        struct cs_reqh_context *rctx;
-
-        cnt = 0;
-        c2_tlist_for(&rctx_descr, &cctx->cc_reqh_ctxs, rctx) {
-                for (idx = 0; idx < rctx->rc_snr; ++idx) {
-                        if (strcasecmp(rctx->rc_services[idx], sname) == 0)
-                                ++cnt;
-                        if (cnt > 1)
-                                return true;
-                }
-        } c2_tlist_endfor;
-
-	return false;
-}
-
-static bool service_is_registered(const char *service_name)
-{
-	struct c2_reqh_service_type *stype;
-
-	c2_tlist_for(&c2_rstypes_descr, &c2_rstypes, stype) {
-		if (strcasecmp(stype->rst_name, service_name) == 0)
-			return true;
-	} c2_tlist_endfor;
-
-	return false;
-}
-
-struct c2_rpcmachine *c2_cs_rpcmach_get(struct c2_colibri *cctx,
-					const struct c2_net_xprt *xprt,
-					const char *sname)
-{
-	struct c2_reqh            *reqh;
-	struct cs_reqh_context    *rctx;
-	struct c2_reqh_service    *service;
-	struct c2_rpcmachine      *rpcmach;
-	struct c2_net_xprt        *nxprt;
-
-        C2_PRE(cctx != NULL);
-
-        C2_ASSERT(!c2_tlist_is_empty(&rctx_descr, &cctx->cc_reqh_ctxs));
-
-        c2_tlist_for(&rctx_descr, &cctx->cc_reqh_ctxs, rctx) {
-		reqh = &rctx->rc_reqh;
-                c2_tlist_for(&c2_rh_sl_descr, &reqh->rh_services, service) {
-			if (strcmp(service->rs_type->rst_name, sname) != 0)
-				continue;
-			c2_tlist_for(&c2_rh_rpml_descr, &reqh->rh_rpcmachines,
-								rpcmach) {
-				nxprt = rpcmach->cr_tm.ntm_dom->nd_xprt;
-				C2_ASSERT(nxprt != NULL);
-				if (strcmp(nxprt->nx_name, xprt->nx_name) == 0)
-					return rpcmach;
-			} c2_tlist_endfor;
-                } c2_tlist_endfor;
-        } c2_tlist_endfor;
-
-        return NULL;
-
-}
-C2_EXPORTED(c2_cs_rpcmach_get);
-
-struct c2_net_transfer_mc *c2_cs_tm_get(struct c2_colibri *cctx,
-					const struct c2_net_xprt *xprt,
-					const char *sname)
-{
-	struct c2_rpcmachine *rpcmach;
-
-	rpcmach = c2_cs_rpcmach_get(cctx, xprt, sname);
-
-	return (rpcmach == NULL) ? NULL : &rpcmach->cr_tm;
-}
-
-/**
-   Checks consistency of request handler context.
- */
-static bool cs_reqh_context_invariant(const struct cs_reqh_context *rctx)
-{
-	if (rctx == NULL)
-		return false;
-	switch (rctx->rc_state) {
-	case RC_UNINITIALISED:
-		return rctx->rc_stype != NULL && rctx->rc_dbpath != NULL &&
-			rctx->rc_stpath != NULL && rctx->rc_enr != 0 &&
-			rctx->rc_snr != 0;
-	case RC_INITIALISED:
-		return rctx->rc_magic == CS_REQH_CTX_MAGIC &&
-			c2_reqh_invariant(&rctx->rc_reqh);
-	default:
-		return false;
-	}
-}
-
-/**
-   Allocates a request handler and adds it to the list of the same in given
-   colibri context.
-
-   @param cctx Colibri context
-
-   @see c2_colibri
- */
-static struct cs_reqh_context *cs_reqh_ctx_alloc(struct c2_colibri *cctx)
-{
-	struct cs_reqh_context *rctx;
-
-	C2_PRE(cctx != NULL);
-
-	C2_ALLOC_PTR(rctx);
-	if (rctx == NULL)
-		goto out;
-
-	rctx->rc_max_eps = cctx->cc_xprts_nr;
-	C2_ALLOC_ARR(rctx->rc_eps, rctx->rc_max_eps);
-	if (rctx->rc_eps == NULL)
-		goto cleanup_rctx;
-
-	rctx->rc_max_services = c2_tlist_length(&c2_rstypes_descr, &c2_rstypes);
-	if (rctx->rc_max_services == 0) {
-		fprintf(cctx->cc_outfile, "No available services\n");
-		goto cleanup_endpoints;
-	}
-
-	C2_ALLOC_ARR(rctx->rc_services, rctx->rc_max_services);
-	if (rctx->rc_services == NULL)
-		goto cleanup_endpoints;
-
-	rctx->rc_magic = CS_REQH_CTX_MAGIC;
-	c2_tlink_init(&rctx_descr, rctx);
-	c2_tlist_add_tail(&rctx_descr, &cctx->cc_reqh_ctxs, rctx);
-
-	goto out;
-
-cleanup_endpoints:
-	c2_free(rctx->rc_eps);
-cleanup_rctx:
-	c2_free(rctx);
-	rctx = NULL;
-out:
-	return rctx;
-}
-
-static void cs_reqh_ctx_free(struct cs_reqh_context *rctx)
-{
-	int i;
-
-	C2_PRE(rctx != NULL);
-
-	for (i = 0; i < rctx->rc_max_eps; ++i) {
-		if (rctx->rc_eps[i].scrbuf != NULL)
-			c2_free(rctx->rc_eps[i].scrbuf);
-	}
-	c2_free(rctx->rc_eps);
-	c2_free(rctx->rc_services);
-	c2_tlist_del(&rctx_descr, rctx);
-	c2_free(rctx);
-}
-
-/**
-   Finds network domain for specified network transport in a given colibri
-   context.
-
-   @param cctx Colibri context
-   @param xprt_name Type of network transport to be initialised
-
-   @pre cctx != NULL && xprt_name != NULL
-
-   @see c2_cs_init()
- */
-static struct c2_net_domain *cs_net_domain_locate(struct c2_colibri *cctx,
-							const char *xprt_name)
-{
-	struct c2_net_domain *ndom;
-
-	C2_PRE(cctx != NULL && xprt_name != NULL);
-
-        C2_ASSERT(!c2_tlist_is_empty(&ndoms_descr, &cctx->cc_ndoms));
-
-	c2_tlist_for(&ndoms_descr, &cctx->cc_ndoms, ndom) {
-		if (strcmp(ndom->nd_xprt->nx_name, xprt_name) == 0)
-			return ndom;
-	} c2_tlist_endfor;
-
-	return NULL;
-}
-
-/**
-   Initialises rpc machine for the given endpoint address.
-   Once the new rpcmachine is created it is added to list of rpc machines
-   in given request handler.
-   Request handler should be initialised before invoking this function.
-
-   @param cctx Colibri context
-   @param xprt_name Network transport
-   @param ep Network endpoint address
-   @param reqh Request handler to which the newly created
-		rpcmachine belongs
-
-   @pre cctx != NULL && xprt_name != NULL && ep != NULL && reqh != NULL
- */
-static int cs_rpcmachine_init(struct c2_colibri *cctx, const char *xprt_name,
-				const char *ep, struct c2_reqh *reqh)
-{
-	struct c2_rpcmachine         *rpcmach;
-	struct c2_net_domain         *ndom;
-	struct c2_net_xprt           *xprt;
-	int                           rc;
-
-	C2_PRE(cctx != NULL && xprt_name != NULL && ep != NULL &&
-							reqh != NULL);
-
-	xprt = cs_xprt_lookup(xprt_name, cctx->cc_xprts, cctx->cc_xprts_nr);
-
-	if (xprt == NULL)
-		return -EINVAL;
-
-	ndom = cs_net_domain_locate(cctx, xprt->nx_name);
-	if (ndom == NULL)
-		return -EINVAL;
-
-	C2_ALLOC_PTR(rpcmach);
-	if (rpcmach == NULL)
-		return -ENOMEM;
-
-	rc = c2_rpcmachine_init(rpcmach, reqh->rh_cob_domain, ndom, ep, reqh);
-	if (rc != 0) {
-		c2_free(rpcmach);
-		return rc;
-	}
-
-	c2_tlink_init(&c2_rh_rpml_descr, rpcmach);
-	c2_tlist_add_tail(&c2_rh_rpml_descr, &reqh->rh_rpcmachines, rpcmach);
-
-	return rc;
-}
-
-/**
-   Intialises rpc machines in a colibri context.
-
-   @param cctx Colibri context
- */
-static int cs_rpcmachines_init(struct c2_colibri *cctx)
-{
-	int                      idx;
-	int                      rc;
-	FILE                    *ofd;
-	struct  cs_reqh_context *rctx;
-
-	C2_PRE(cctx != NULL);
-
-        C2_ASSERT(!c2_tlist_is_empty(&rctx_descr, &cctx->cc_reqh_ctxs));
-
-	ofd = cctx->cc_outfile;
-        c2_tlist_for(&rctx_descr, &cctx->cc_reqh_ctxs, rctx) {
-
-		C2_ASSERT(cs_reqh_context_invariant(rctx));
-
-		for (idx = 0; idx < rctx->rc_enr; ++idx) {
-			rc = cs_rpcmachine_init(cctx,
-						rctx->rc_eps[idx].xprt,
-						rctx->rc_eps[idx].endpoint,
-						&rctx->rc_reqh);
-			if (rc != 0) {
-				fprintf(ofd,
-					"COLIBRI: Invalid endpoint: %s:%s\n",
-					rctx->rc_eps[idx].xprt,
-					rctx->rc_eps[idx].endpoint);
-				return rc;
-			}
-		}
-	} c2_tlist_endfor;
-
-	return rc;
-}
-
-/**
-   Finalises all the rpc machines from the list of rpc machines present in
-   c2_reqh.
-
-   @param reqh Request handler of which the rpc machines belong
-
-   @pre reqh != NULL
- */
-static void cs_rpcmachines_fini(struct c2_reqh *reqh)
-{
-	struct c2_rpcmachine *rpcmach;
-
-	C2_PRE(reqh != NULL);
-
-	c2_tlist_for(&c2_rh_rpml_descr, &reqh->rh_rpcmachines, rpcmach) {
-		C2_ASSERT(rpcmach != NULL);
-		c2_rpcmachine_fini(rpcmach);
-		c2_tlist_del(&c2_rh_rpml_descr, rpcmach);
-		c2_tlink_fini(&c2_rh_rpml_descr, rpcmach);
-		c2_free(rpcmach);
-	} c2_tlist_endfor;
-}
-
-/**
-   Initialises AD type stob.
- */
-static int cs_ad_stob_init(const char *stob_path, struct cs_reqh_stobs *stob,
-			   struct c2_dbenv *db, struct c2_stob **bstob)
-{
-	int rc;
-
-	rc = ad_stob_type.st_op->sto_domain_locate(&ad_stob_type,
-				stob_path, &stob->adstob);
-
-	if (rc == 0)
-		rc = c2_ad_stob_setup(stob->adstob, db, *bstob,
-				      &colibri_balloc.cb_ballroom,
-				      BALLOC_DEF_CONTAINER_SIZE,
-				      BALLOC_DEF_BLOCK_SHIFT,
-				      BALLOC_DEF_BLOCKS_PER_GROUP,
-				      BALLOC_DEF_RESERVED_GROUPS);
-	return rc;
-}
-
-/**
-   Initialises linux type stob.
- */
-static int cs_linux_stob_init(const char *stob_path, struct cs_reqh_stobs *stob,
-							struct c2_stob **bstob)
-{
-	int                    rc;
-	struct c2_stob_domain *sdom;
-
-	rc = linux_stob_type.st_op->sto_domain_locate(&linux_stob_type,
-					stob_path, &stob->linuxstob);
-	if  (rc == 0) {
-		sdom = stob->linuxstob;
-		rc = c2_linux_stob_setup(sdom, false);
-		if  (rc == 0)
-			rc = sdom->sd_ops->sdo_stob_find(stob->linuxstob,
-						&stob->stob_id, bstob);
-	}
-
-	return rc;
-}
-
-/**
-   Initialises storage including database environment and stob domain of given
-   type (e.g. linux or ad). There is a stob domain and a database environment
-   created per request handler context.
-
-   @param stob_type Type of stob to be initialised (e.g. linux or ad)
-   @param stob_path Path at which storage object should be created
-   @param stob Pre allocated struct reqh_stob_domain object encapsulates
-               c2_stob_domain references for linux and ad stob types
-   @param db Pre allocated struct c2_dbenv instance to be initialised
-
-   @see struct reqh_stob_domain
-
-   @pre stob_type != NULL && stob_path != NULL && stob != NULL && db != NULL
-
-   @todo Use generic mechanism to generate stob ids
- */
-static int cs_storage_init(const char *stob_type, const char *stob_path,
-                           struct cs_reqh_stobs *stob, struct c2_dbenv *db)
-{
-	int                      rc;
-	int                      slen;
-	char                    *objpath;
-        struct c2_stob          *bstore;
-
-	C2_PRE(stob_type != NULL && stob_path != NULL && stob != NULL &&
-								db != NULL);
-
-	stob->stype = stob_type;
-
-	/*
-	   XXX Need generic mechanism to generate stob ids
-	 */
-        stob->stob_id.si_bits.u_hi = 0x0;
-        stob->stob_id.si_bits.u_lo = 0xdf11e;
-
-	slen = strlen(stob_path);
-	C2_ALLOC_ARR(objpath, slen + sizeof("/o"));
-	if (objpath == NULL)
-		return -ENOMEM;
-
-	sprintf(objpath, "%s%s", stob_path, "/o");
-
-	rc = mkdir(stob_path, 0700);
-        if (rc != 0 && errno != EEXIST)
-		goto cleanup;
-
-        rc = mkdir(objpath, 0700);
-        if (rc != 0 && errno != EEXIST)
-		goto cleanup;
-
-	rc = cs_linux_stob_init(stob_path, stob, &bstore);
-	if (rc != 0)
-		goto cleanup;
-
-	rc = c2_stob_create(bstore, NULL);
-	if (rc != 0)
-		goto cleanup;
-
-	if (strcasecmp(stob_type, cs_stobs[AD_STOB]) == 0)
-		rc = cs_ad_stob_init(stob_path, stob, db, &bstore);
-
-	if (rc != 0)
-		goto cleanup;
-
-	C2_ASSERT(bstore->so_state == CSS_EXISTS);
-
-cleanup:
-	if (bstore != NULL)
-		c2_stob_put(bstore);
-	c2_free(objpath);
-
-	return rc;
-}
-
-/**
-   Finalises storage for a request handler in a colibri context.
-
-   @param stob Generic stob encapsulating c2_stob_domain references for linux
-          and ad stobs to be finalised
-
-   @see struct reqh_stob_domain
-
-   @pre stob != NULL
- */
-static void cs_storage_fini(struct cs_reqh_stobs *stob)
-{
-	C2_PRE(stob != NULL);
-
-	if (stob->linuxstob != NULL) {
-		if (stob->adstob != NULL)
-			stob->adstob->sd_ops->sdo_fini(stob->adstob);
-		stob->linuxstob->sd_ops->sdo_fini(stob->linuxstob);
-	}
-}
-
-/**
-   Initialises and starts a particular service.
-   Once the service is initialised it is started and registered with the
-   appropriate request handler.
-
-   @param service_name Name of service to be initialised
-   @param reqh Request handler this service is registered with
-
-   @pre service_name != NULL && reqh != NULL
-
-   @post c2_reqh_service_invariant(service)
- */
-static int cs_service_init(const char *service_name, struct c2_reqh *reqh)
-{
-	int                           rc;
-	struct c2_reqh_service_type  *stype;
-	struct c2_reqh_service       *service;
-
-	C2_PRE(service_name != NULL && reqh != NULL);
-
-        stype = c2_reqh_service_type_find(service_name);
-        if (stype == NULL) {
-                rc = -EINVAL;
-                goto out;
-        }
-
-	rc = stype->rst_ops->rsto_service_alloc_and_init(stype, &service);
-	if (rc != 0)
-		goto out;
-
-	C2_ASSERT(c2_reqh_service_invariant(service));
-
-	rc = c2_reqh_service_init(service, reqh);
-	if (rc != 0) {
-		service->rs_phase = C2_RSPH_FAILED;
-		goto cleanup3;
-	}
-
-	C2_ASSERT(c2_reqh_service_invariant(service));
-
-	service->rs_phase = C2_RSPH_STARTING;
-	rc = service->rs_ops->rso_start(service);
-	if (rc != 0) {
-		service->rs_phase = C2_RSPH_FAILED;
-		goto cleanup2;
-	}
-
-	rc = c2_reqh_service_start(service);
-	if (rc != 0) {
-		service->rs_phase = C2_RSPH_FAILED;
-		goto cleanup1;
-	}
-
-	C2_POST(c2_reqh_service_invariant(service));
-	goto out;
-
-cleanup1:
-	service->rs_ops->rso_stop(service);
-cleanup2:
-	c2_reqh_service_fini(service);
-cleanup3:
-	service->rs_ops->rso_fini(service);
-out:
-	return rc;
-}
-
-/**
-   Initialises set of services specified in a request handler context.
-   Services are started once the colibri context is configured successfully
-   which includes network domains, request handlers, and rpc machines.
-
-   @param cctx Colibri context
- */
-static int cs_services_init(struct c2_colibri *cctx)
-{
-	int                      idx;
-	int                      rc;
-	struct cs_reqh_context  *rctx;
-
-	C2_PRE(cctx != NULL);
-
-        c2_tlist_for(&rctx_descr, &cctx->cc_reqh_ctxs, rctx) {
-		C2_ASSERT(cs_reqh_context_invariant(rctx));
-
-		for (idx = 0; idx < rctx->rc_snr; ++idx) {
-			rc = cs_service_init(rctx->rc_services[idx],
-							&rctx->rc_reqh);
-			if (rc != 0)
-				return rc;
-		}
-	} c2_tlist_endfor;
-
-	return rc;
-}
-
-/**
-   Finalises a service.
-   Transitions service to C2_RSPH_STOPPING phase, stops a service and then
-   finalises the same.
-
-   @param service Service to be finalised
-
-   @pre service != NULL
-
-   @see c2_reqh_service_stop()
-   @see c2_reqh_service_fini()
- */
-static void cs_service_fini(struct c2_reqh_service *service)
-{
-	C2_PRE(service != NULL);
-
-	service->rs_phase = C2_RSPH_STOPPING;
-	service->rs_ops->rso_stop(service);
-	c2_reqh_service_stop(service);
-	C2_ASSERT(service->rs_phase == C2_RSPH_STOPPED &&
-			service->rs_state == C2_RSS_STOPPED);
-	c2_reqh_service_fini(service);
-	service->rs_ops->rso_fini(service);
-}
-
-/**
-   Finalises all the services registered with a request handler.
-   Also traverses through the services list and invokes cs_service_fini() on
-   each individual service.
-
-   @param reqh Request handler of which the services are to be finalised
-
-   @pre reqh != NULL
- */
-static void cs_services_fini(struct c2_reqh *reqh)
-{
-	struct c2_reqh_service *service;
-	struct c2_tl           *services;
-
-	C2_PRE(reqh != NULL);
-
-	services = &reqh->rh_services;
-        c2_tlist_for(&c2_rh_sl_descr, services, service) {
-		C2_ASSERT(c2_reqh_service_invariant(service));
-		cs_service_fini(service);
-	} c2_tlist_endfor;
-}
-
-/**
-   Initialises network domains per given distinct xport:endpoint pair in a
-   colibri context.
-
-   @param cctx Colibri context
- */
-static int cs_net_domains_init(struct c2_colibri *cctx)
-{
-	int                     idx;
-	int                     rc;
-	int                     xprts_nr;
-	struct c2_net_xprt    **xprts;
-	struct c2_net_xprt     *xprt;
-	struct cs_reqh_context *rctx;
-
-	C2_PRE(cctx != NULL);
-
-	xprts = cctx->cc_xprts;
-	xprts_nr = cctx->cc_xprts_nr;
-
-        c2_tlist_for(&rctx_descr, &cctx->cc_reqh_ctxs, rctx) {
-
-		C2_ASSERT(cs_reqh_context_invariant(rctx));
-
-		for (idx = 0; idx < rctx->rc_enr; ++idx) {
-			struct c2_net_domain *ndom;
-
-			xprt = cs_xprt_lookup(rctx->rc_eps[idx].xprt, xprts,
-								xprts_nr);
-			C2_ASSERT(xprt != NULL);
-
-			rc = c2_net_xprt_init(xprt);
-			if (rc != 0)
-				return rc;
-
-			C2_ALLOC_PTR(ndom);
-			if (ndom == NULL)
-				return -ENOMEM;
-
-			rc = c2_net_domain_init(ndom, xprt);
-			if (rc != 0) {
-				c2_free(ndom);
-				return rc;
-			}
-			c2_tlink_init(&ndoms_descr, ndom);
-			c2_tlist_add_tail(&ndoms_descr, &cctx->cc_ndoms, ndom);
-		}
-	} c2_tlist_endfor;
-
-	return rc;
-}
-
-/**
-   Finalises all the network domains within a colibri context.
-
-   @param cctx Colibri context to which the network domains belong
- */
-static void cs_net_domains_fini(struct c2_colibri *cctx)
-{
-	struct c2_net_domain  *ndom;
-	struct c2_net_xprt   **xprts;
-	int                    idx;
-
-	C2_PRE(cctx != NULL);
-
-	xprts = cctx->cc_xprts;
-	c2_tlist_for(&ndoms_descr, &cctx->cc_ndoms, ndom) {
-		c2_net_domain_fini(ndom);
-		c2_tlist_del(&ndoms_descr, ndom);
-		c2_tlink_fini(&ndoms_descr, ndom);
-		c2_free(ndom);
-	} c2_tlist_endfor;
-
-	for (idx = 0; idx < cctx->cc_xprts_nr; ++idx)
-		c2_net_xprt_fini(xprts[idx]);
-}
-
-/**
-   Initialises a request handler context.
-   A request handler context consists of the storage domain, database,
-   cob domain, fol and request handler instance to be initialised.
-   The request handler context is allocated and initialised per request handler
-   in a colibri process per node. So, there can exist multiple request handlers
-   and thus multiple request handler contexts in a colibri context.
-
-   @param rctx Request handler context to be initialised
- */
-static int cs_start_request_handler(struct cs_reqh_context *rctx)
-{
-	int                      rc;
-	struct cs_reqh_stobs    *rstob;
-	struct c2_stob_domain   *sdom;
-
-	if (rctx->rc_dbpath != NULL)
-		rc = c2_dbenv_init(&rctx->rc_db, rctx->rc_dbpath, 0);
-
-	if (rc != 0)
-		goto out;
-
-	rc = cs_storage_init(rctx->rc_stype, rctx->rc_stpath,
-				&rctx->rc_stob, &rctx->rc_db);
-	if (rc != 0)
-		goto cleanup_db;
-
-	rctx->rc_cdom_id.id = ++cdom_id;
-	rc = c2_cob_domain_init(&rctx->rc_cdom, &rctx->rc_db,
-					&rctx->rc_cdom_id);
-	if (rc != 0)
-		goto cleanup_stob;
-
-	rc = c2_fol_init(&rctx->rc_fol, &rctx->rc_db);
-	if (rc != 0)
-		goto cleanup_cob;
-
-	rstob = &rctx->rc_stob;
-	if (strcasecmp(rstob->stype, cs_stobs[AD_STOB]) == 0)
-		sdom = rstob->adstob;
-	else
-		sdom = rstob->linuxstob;
-
-	rc = c2_reqh_init(&rctx->rc_reqh, NULL, sdom, &rctx->rc_db,
-					&rctx->rc_cdom, &rctx->rc_fol);
-	if (rc != 0)
-		goto cleanup_fol;
-
-	rctx->rc_state = RC_INITIALISED;
-	goto out;
-
-cleanup_fol:
-	c2_fol_fini(&rctx->rc_fol);
-cleanup_cob:
-	c2_cob_domain_fini(&rctx->rc_cdom);
-cleanup_stob:
-	cs_storage_fini(&rctx->rc_stob);
-cleanup_db:
-	c2_dbenv_fini(&rctx->rc_db);
-out:
-	return rc;
-}
-
-/**
-   Configures one or more request handler contexts and starts corresponding
-   request handlers in each context.
- */
-static int cs_start_request_handlers(struct c2_colibri *cctx)
-{
-	int                     rc;
-	struct cs_reqh_context *rctx;
-	FILE                   *ofd;
-
-	C2_PRE(cctx != NULL);
-        C2_ASSERT(!c2_tlist_is_empty(&rctx_descr, &cctx->cc_reqh_ctxs));
-
-	ofd = cctx->cc_outfile;
-        c2_tlist_for(&rctx_descr, &cctx->cc_reqh_ctxs, rctx) {
-
-		C2_ASSERT(cs_reqh_context_invariant(rctx));
-
-		rc = cs_start_request_handler(rctx);
-		if (rc != 0) {
-			fprintf(ofd,
-				"COLIBRI: Failed to start request handler\n");
-			return rc;
-		}
-	} c2_tlist_endfor;
-
-	return rc;
-}
-
-/**
-   Finalises a request handler context.
-   Sets c2_reqh::rh_shutdown true, and checks if the request handler can be
-   shutdown by invoking c2_reqh_can_shutdown().
-   This waits until c2_reqh_can_shutdown() returns true and then proceeds for
-   further cleanup.
-
-   @param rctx Request handler context to be finalised
-
-   @pre cs_reqh_context_invariant()
- */
-static void cs_request_handler_stop(struct cs_reqh_context *rctx)
-{
-	struct c2_reqh *reqh;
-	c2_time_t       rdelay;
-	uint64_t        sleepcnt;
-
-	C2_PRE(cs_reqh_context_invariant(rctx));
-
-	reqh = &rctx->rc_reqh;
-        c2_mutex_lock(&reqh->rh_lock);
-        reqh->rh_shutdown = true;
-        c2_mutex_unlock(&reqh->rh_lock);
-
-	sleepcnt = 1;
-	while (!c2_reqh_can_shutdown(reqh)) {
-		c2_nanosleep(c2_time_set(&rdelay, 0,
-			WAIT_FOR_REQH_SHUTDOWN * sleepcnt), NULL);
-                ++sleepcnt;
-	}
-
-	cs_services_fini(reqh);
-	cs_rpcmachines_fini(reqh);
-	c2_reqh_fini(reqh);
-	c2_fol_fini(&rctx->rc_fol);
-	c2_cob_domain_fini(&rctx->rc_cdom);
-	cs_storage_fini(&rctx->rc_stob);
-	c2_dbenv_fini(&rctx->rc_db);
-}
-
-/**
-   Finalises all the request handler contexts within a colibri context.
-
-   @param cctx Colibri context to which the reqeust handler contexts belong
- */
-static void cs_request_handlers_stop(struct c2_colibri *cctx)
-{
-	struct cs_reqh_context *rctx;
-
-	c2_tlist_for(&rctx_descr, &cctx->cc_reqh_ctxs, rctx) {
-		if (rctx->rc_state == RC_INITIALISED)
-			cs_request_handler_stop(rctx);
-		cs_reqh_ctx_free(rctx);
-	} c2_tlist_endfor;
-}
-
-/**
-   Initialises a colibri context.
-
-   @param cctx Colibri context to be initialised
-
-   @pre cctx != NULL
- */
-static int cs_colibri_init(struct c2_colibri *cctx)
-{
-	C2_PRE(cctx != NULL);
-
-	c2_tlist_init(&ndoms_descr, &cctx->cc_ndoms);
-	c2_tlist_init(&rctx_descr, &cctx->cc_reqh_ctxs);
-
-	return 0;
-}
-
-/**
-   Finalises a colibri context.
-
-   @pre cctx != NULL
-
-   @param cctx Colibri context to be finalised
- */
-static void cs_colibri_fini(struct c2_colibri *cctx)
-{
-	C2_PRE(cctx != NULL);
-
-	cs_net_domains_fini(cctx);
-	c2_tlist_fini(&ndoms_descr, &cctx->cc_ndoms);
-	c2_tlist_fini(&rctx_descr, &cctx->cc_reqh_ctxs);
-}
-
-/**
-   Displays usage of colibri_setup program.
-
-   @param f File to which the output is written
- */
-static void cs_usage(FILE *out)
-{
-	C2_PRE(out != NULL);
-
-	fprintf(out, "Usage: colibri_setup [-h] [-x] [-l]\n"
-		   "    or colibri_setup {-r -T stobtype -D dbpath"
-		   " -S stobfile {-e xport:endpoint}+\n"
-		   "                     { -s service}+ }\n");
-}
-
-/**
-   Displays help for colibri_setup program.
-
-   @param f File to which the output is written
- */
-static void cs_help(FILE *out)
-{
-	C2_PRE(out != NULL);
-
-	cs_usage(out);
-	fprintf(out, "Every -r option represents a request handler set.\n"
-		   "All the parameters in a request handler set are "
-		   "mandatory.\nThere can be "
-		   "multiple such request handler sets in a single colibri "
-		   "process.\n"
-		   "Endpoints and services can be specified multiple times "
-		   "using -e and -s options\nin a request handler set.\n"
-		   "-h Prints colibri usage help.\n"
-		   "   e.g. colibri_setup -h\n"
-		   "-x Lists supported network transports.\n"
-		   "   e.g. colibri_setup -x\n"
-		   "-l Lists supported services on this node.\n"
-		   "   e.g. colibri_setup -l\n"
-		   "-r Represents a request handler context.\n"
-		   "-T Type of storage to be used by the request handler in "
-		   "current context.\n"
-		   "   This is specified once per request handler context, "
-		   "e.g. linux, ad\n"
-		   "-D Database file to be used in a request handler.\n"
-		   "   This is specified once per request handler set.\n"
-		   "-S Stob file for request handler context.\n"
-		   "   This is specified once per request handler set.\n"
-		   "-e Network layer endpoint to which clients connect. "
-		   "Network layer endpoint\n   consists of 2 parts "
-		   "network transport:endpoint address.\n"
-		   "   Currently supported transport is bulk-sunrpc which "
-		   "takes 3-tuple endpoint\n   address."
-		   " e.g. bulk-sunrpc:127.0.0.1:1024:1\n"
-		   "   This can be specified multiple times, per request "
-		   "handler set. Thus there\n   can exist multiple endpoints "
-		   "per network transport with different ids,\n"
-		   "   i.e. 3rd component of 3-tuple endpoint address in "
-		   "this case.\n"
-		   "-s Services to be started in given request handler "
-		   "context.\n   This can be specified multiple times "
-		   "per request handler set.\n"
-		   "   e.g. ./colibri -r -T linux -D dbpath -S stobfile\n"
-		   "        -e xport:127.0.0.1:1024:1 -s mds\n");
-}
-
-static int reqh_ctxs_are_valid(struct c2_colibri *cctx)
-{
-	int                     rc;
-	int                     idx;
-	FILE                   *ofd;
-	struct cs_reqh_context *rctx;
-
-	C2_PRE(cctx != NULL);
-
-        C2_ASSERT(!c2_tlist_is_empty(&rctx_descr, &cctx->cc_reqh_ctxs));
-
-	ofd = cctx->cc_outfile;
-        c2_tlist_for(&rctx_descr, &cctx->cc_reqh_ctxs, rctx) {
-
-                if (!cs_reqh_context_invariant(rctx)) {
-                        fprintf(ofd, "COLIBRI: Missing or invalid parameters\n");
-			cs_usage(ofd);
-                        return -EINVAL;
-                }
-
-		if (!stype_is_valid(rctx->rc_stype)) {
-                        fprintf(ofd, "COLIBRI: Invalid storage type\n");
-			cs_stob_types_list(ofd);
-                        return -EINVAL;
-                }
-		/*
-		   Check if all the given end points in a reqh context are
-		   valid.
-		 */
-		for (idx = 0; idx < rctx->rc_enr; ++idx) {
-			rc = cs_endpoint_validate(cctx,
-					rctx->rc_eps[idx].endpoint,
-					rctx->rc_eps[idx].xprt);
-			if (rc == -EADDRINUSE)
-				fprintf(ofd,
-					"COLIBRI: Duplicate end point: %s:%s\n",
-					rctx->rc_eps[idx].xprt,
-					rctx->rc_eps[idx].endpoint);
-			else if (rc == -EINVAL)
-				fprintf(ofd,
-					"COLIBRI: Invalid endpoint: %s:%s\n",
-					rctx->rc_eps[idx].xprt,
-					rctx->rc_eps[idx].endpoint);
-			if (rc != 0)
-				return rc;
-		}
-
-		/*
-		   Check if the services are registered and are valid in a
-		   reqh context are valid.
-		 */
-		if (rctx->rc_snr == 0) {
-			fprintf(ofd, "COLIBRI: Services unavailable\n");
-			return -EINVAL;
-		}
-
-		for (idx = 0; idx < rctx->rc_snr; ++idx) {
-			if (!service_is_registered(rctx->rc_services[idx])) {
-				fprintf(ofd, "COLIBRI: Unknown service: %s\n",
-                                                       rctx->rc_services[idx]);
-				cs_services_list(ofd);
-				return -ENOENT;
-			}
-			if (service_is_duplicate(cctx, rctx->rc_services[idx])) {
-				fprintf(ofd, "COLIBRI: Duplicate service: %s\n",
-                                                       rctx->rc_services[idx]);
-				return -EADDRINUSE;
-			}
-		}
-	} c2_tlist_endfor;
-
-	return rc;
-}
-
-/**
-   Parses given arguments and allocates request handler context, if all the
-   required arguments are provided and valid.
-   Every allocated request handler context is added to the list of the same
-   in given colibri context.
-
-   @param cctx Colibri context to be setup
- */
-static int cs_parse_args(struct c2_colibri *cctx, int argc, char **argv)
-{
-	int                     rc = 0;
-	struct cs_reqh_context *vrctx = NULL;
-	FILE                   *ofd;
-
-	C2_PRE(cctx != NULL);
-
-	if (argc <= 1)
-		return -EINVAL;;
-
-	ofd = cctx->cc_outfile;
-        C2_GETOPTS("colibri_setup", argc, argv,
-                C2_VOIDARG('h', "Colibri_setup usage help",
-                        LAMBDA(void, (void)
-                        {
-				cs_help(ofd);
-				rc = 1;
-                                return;
-                        })),
-		C2_VOIDARG('x', "List Supported transports",
-			LAMBDA(void, (void)
-			{
-				cs_xprts_list(ofd, cctx->cc_xprts,
-						cctx->cc_xprts_nr);
-				rc = 1;
-				return;
-			})),
-		C2_VOIDARG('l', "List Supported services",
-			LAMBDA(void, (void)
-			{
-				cs_services_list(ofd);
-				rc = 1;
-				return;
-			})),
-                C2_VOIDARG('r', "Start request handler",
-                        LAMBDA(void, (void)
-                        {
-				vrctx = NULL;
-				vrctx = cs_reqh_ctx_alloc(cctx);
-				if (vrctx == NULL) {
-					rc = -ENOMEM;
-					return;
-				}
-				vrctx->rc_snr = 0;
-				vrctx->rc_enr = 0;
-                        })),
-                C2_STRINGARG('T', "Storage domain type",
-                        LAMBDA(void, (const char *str)
-			{
-				if (vrctx == NULL) {
-					rc = -EINVAL;
-					return;
-				}
-                                vrctx->rc_stype = str;
-			})),
-                C2_STRINGARG('D', "Database environment path",
-                        LAMBDA(void, (const char *str)
-			{
-				if (vrctx == NULL) {
-					rc = -EINVAL;
-					return;
-				}
-                                vrctx->rc_dbpath = str;
-			})),
-                C2_STRINGARG('S', "Storage name",
-                        LAMBDA(void, (const char *str)
-			{
-				if (vrctx == NULL) {
-					rc = -EINVAL;
-					return;
-				}
-                                vrctx->rc_stpath = str;
-			})),
-                C2_STRINGARG('e', "Network endpoint, eg:- transport:address",
-                        LAMBDA(void, (const char *str)
-                        {
-				struct cs_endpoint_and_xprt *ep_xprt;
-				if (vrctx == NULL) {
-					rc = -EINVAL;
-					return;
-				}
-				if (vrctx->rc_enr == vrctx->rc_max_eps) {
-					fprintf(ofd, "Too many endpoints\n");
-					rc = -E2BIG;
-					return;
-				}
-				ep_xprt = &vrctx->rc_eps[vrctx->rc_enr];
-                                rc = ep_and_xprt_get(ep_xprt, str);
-				if (rc != 0)
-					return;
-
-				C2_CNT_INC(vrctx->rc_enr);
-                        })),
-                C2_STRINGARG('s', "Services to be configured",
-                        LAMBDA(void, (const char *str)
-			{
-				if (vrctx == NULL) {
-					rc = -EINVAL;
-					return;
-				}
-				if (vrctx->rc_snr == vrctx->rc_max_services) {
-					fprintf(ofd, "Too many services\n");
-					rc = -E2BIG;
-					return;
-				}
-                                vrctx->rc_services[vrctx->rc_snr] = str;
-				C2_CNT_INC(vrctx->rc_snr);
-                        })));
-
-	return rc;
-}
-
-int c2_cs_setup_env(struct c2_colibri *cctx, int argc, char **argv)
-{
-	int   rc;
-
-	C2_PRE(cctx != NULL);
-
-	rc = cs_parse_args(cctx, argc, argv);
-	if (rc < 0) {
-		cs_usage(cctx->cc_outfile);
-		return rc;
-	}
-
-	rc = reqh_ctxs_are_valid(cctx);
-	if (rc != 0)
-		return rc;
-
-	rc = cs_net_domains_init(cctx);
-	if (rc != 0)
-		return rc;
-
-	rc = cs_start_request_handlers(cctx);
-	if (rc != 0)
-		return rc;
-
-	rc = cs_rpcmachines_init(cctx);
-
-	return rc;
-}
-
-int c2_cs_start(struct c2_colibri *cctx)
-{
-	int   rc;
-
-	C2_PRE(cctx != NULL);
-
-	rc = cs_services_init(cctx);
-	if (rc != 0)
-		fprintf(cctx->cc_outfile,
-			"COLIBRI: Service initialisation failed\n");
-
-	return rc;
-}
-
-int c2_cs_init(struct c2_colibri *cctx, struct c2_net_xprt **xprts,
-						int xprts_nr, FILE *out)
-{
-        int rc;
-
-        C2_PRE(cctx != NULL && xprts != NULL && xprts_nr > 0 && out != NULL);
-
-        cctx->cc_xprts = xprts;
-	cctx->cc_xprts_nr = xprts_nr;
-	cctx->cc_outfile = out;
-
-	rc = cs_colibri_init(cctx);
-	C2_ASSERT(rc == 0);
-
-        return c2_processors_init();
-}
-
-void c2_cs_fini(struct c2_colibri *cctx)
-{
-	C2_PRE(cctx != NULL);
-
-        cs_request_handlers_stop(cctx);
-        cs_colibri_fini(cctx);
-	c2_processors_fini();
-}
-
-/** @} endgroup colibri_setup */
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
diff --git a/colibri/colibri_setup.h b/colibri/colibri_setup.h
deleted file mode 100644
index 123a428..0000000
--- a/colibri/colibri_setup.h
+++ /dev/null
@@ -1,224 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Mandar Sawant <mandar_sawant@xyratex.com>
- * Original creation date: 05/08/2011
- */
-
-#ifndef __COLIBRI_COLIBRI_COLIBRI_SETUP_H__
-#define __COLIBRI_COLIBRI_COLIBRI_SETUP_H__
-
-#include "lib/tlist.h"
-
-/**
-   @defgroup colibri_setup Configures user space colibri environment
-
-   Colibri setup program configures a user space colibri context
-   on a node in a cluster.
-   There exist a list of network transports supported by a node,
-   which is used to initialise corresponding network domains per colibri
-   context, so there exist a network domain per network transport.
-   There can exist multiple request handlers per colibri context.
-   Every colibri context configures one or more request handler
-   contexts, one per request handler, each containing a storage domain,
-   data base, cob domain, fol and request handler to be initialised.
-   Every request handler contains a list of rpc machines, each configured
-   per given endpoint per network domain.
-   Network domains are shared between multiple request handlers in a
-   colibri context.
-   There exist multiple services within a colibri context.
-   Each service identifies a particular set of operations that can be
-   executed on a particular node.
-   Services are registered with the request handler which performs the
-   execution of requests directed to a particular service. Thus the
-   services run under request handler context.
-
-   Colibri setup can be done internally through colibri code or externally
-   through cli using colibri_setup program. As colibri setup configures
-   the server it should be used in server side initialisation, if done
-   through code.
-   Following has to be done to configure a colibri context:
-
-   - Initialise colibri context:
-     For this you have to first define an array of network transports
-     to be used in the colibri context and pass it along with the array
-     size to the initialisation routine.
-
-   @note Also user should pass a output file descriptor to which the error
-         messages will be directed.
-   @code
-   struct c2_colibri colibri_ctx;
-   static struct c2_net_xprt *xprts[] = {
-        &c2_net_bulk_sunrpc_xprt,
-	...
-    };
-
-   c2_cs_init(&colibri_ctx, xprts, ARRAY_SIZE(xprts), outfile);
-   @endcode
-
-   Define parameters for colibri setup and setup environment as below,
-
-   @code
-   static char *cmd[] = { "colibri_setup", "-r", "-T", "AD",
-                   "-D", "cs_db", "-S", "cs_stob",
-                   "-e", "bulk-sunrpc:127.0.0.1:1024:2",
-                   "-s", "dummy"};
-
-    c2_cs_setup_env(&colibri_ctx, ARRAY_SIZE(cs_cmd), cs_cmd);
-    @endcode
-
-    Once the environment is setup successfully, the services can be started
-    as below,
-    @code
-    c2_cs_start(&srv_colibri_ctx);
-    @endcode
-
-    @note The specified services to be started should be registered before
-          startup.
-
-    Similarly, to setup colibri externally, using colibri_setup program along
-    with parameters specified as above.
-    e.g. ./colibri -r -T linux -D dbpath -S stobfile -e xport:127.0.0.1:1024:1
-          -s service
-
-    Below image gives an overview of entire colibri context.
-    @note This image is borrowed from the "New developer guide for colibri"
-          document in section "Starting Colibri services".
-
-    @image html "../../colibri/DS-Reqh.gif"
-
-   @{
- */
-
-/**
-   Defines a colibri context containing a set of network transports,
-   network domains and request handler contexts.
-
-   Every request handler context is a set of parsed values of setup arguments
-   and corresponding in-memory representations of storage, database environment,
-   cob domain, fol, network domains, services and request handler.
- */
-struct c2_colibri {
-	/**
-	   Array of network transports supported in a colibri context.
-	 */
-	struct c2_net_xprt       **cc_xprts;
-
-	/**
-	   Size of cc_xprts array.
-	 */
-	int                        cc_xprts_nr;
-
-        /**
-           List of network domain per colibri context.
-
-	   @see c2_net_domain::nd_app_linkage
-         */
-        struct c2_tl               cc_ndoms;
-
-        /**
-           List of request handler contexts running under one colibri context
-	   on a node.
-
-	   @see cs_reqh_context::rc_linkage
-         */
-	struct c2_tl               cc_reqh_ctxs;
-
-	/**
-	   File to which the output is written.
-	   This is set to stdout by default if no output file
-	   is specified.
-	   Default is set to stdout.
-
-	   @see c2_cs_init()
-	 */
-	FILE                      *cc_outfile;
-};
-
-/**
-   Initialises colibri context.
-
-   @param cs_colibri Represents a colibri context
-   @param xprts Array or network transports supported in a colibri context
-   @param xprts_nr Size of xprts array
-   @param out File descriptor to which output is written
- */
-int c2_cs_init(struct c2_colibri *cs_colibri, struct c2_net_xprt **xprts,
-						int xprts_nr, FILE *out);
-
-/**
-   Finalises colibri context.
- */
-void c2_cs_fini(struct c2_colibri *cs_colibri);
-
-/**
-   Configures colibri context before starting the services.
-   Parses the given arguments and allocates request handler contexts.
-   Validates allocated request handler contexts which includes validation
-   of given arguments and their values.
-   Once all the arguments are validated, initialises network domains, creates
-   and initialises request handler contexts, configures rpc machines each per
-   request handler end point.
-
-   @param cs_colibri Colibri context to be initialised
- */
-int c2_cs_setup_env(struct c2_colibri *cs_colibri, int argc, char **argv);
-
-/**
-   Starts all the specified services in the colibri context.
-   Only once the colibri environment is configured with network domains,
-   request handlers and rpc machines, specified services are started.
-
-   @param cs_colibri Colibri context in which services are started
- */
-int c2_cs_start(struct c2_colibri *cs_colibri);
-
-/**
-   Returns server side rpc machine in a colibri context for given service
-   and network transport.
-
-   @retval Returns c2_rpcmachine if found, else returns NULL
- */
-struct c2_rpcmachine *c2_cs_rpcmach_get(struct c2_colibri *cctx,
-					const struct c2_net_xprt *xprt,
-					const char *sname);
-
-/**
-   Returns server side transfer machine in a colibri context for given service
-   and network transport.
-
-   @retval Returns c2_net_transfer_mc if found,
-	else returns NULL
- */
-struct c2_net_transfer_mc *c2_cs_tm_get(struct c2_colibri *cctx,
-					const struct c2_net_xprt *xprt,
-					const char *service);
-
-/** @} endgroup colibri_setup */
-
-/* __COLIBRI_COLIBRI_COLIBRI_SETUP_H__ */
-#endif
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
-
diff --git a/colibri/cs_main.c b/colibri/cs_main.c
deleted file mode 100644
index e6f9bbe..0000000
--- a/colibri/cs_main.c
+++ /dev/null
@@ -1,127 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Mandar Sawant <mandar_sawant@xyratex.com>
- * Original creation date: 05/08/2011
- */
-
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif
-
-#include <stdio.h>     /* fprintf */
-#include <unistd.h>    /* pause */
-#include <signal.h>    /* sigaction */
-
-#include "lib/errno.h"
-#include "lib/memory.h"
-
-#include "colibri/colibri_setup.h"
-#include "colibri/init.h"
-#include "net/bulk_sunrpc.h"
-#include "reqh/reqh_service.h"
-
-/**
-   @addtogroup colibri_setup
-   @{
- */
-
-/**
-   Represents various network transports supported
-   by a particular node in a cluster.
- */
-static struct c2_net_xprt *cs_xprts[] = {
-	&c2_net_bulk_sunrpc_xprt
-};
-
-/**
-   Global colibri context.
- */
-static struct c2_colibri colibri_ctx;
-
-/**
-   Signal handler registered so that pause()
-   returns in order to trigger proper cleanup.
- */
-static void cs_term_sig_handler(int signum)
-{
-
-}
-
-/**
-   Registers signal handler to catch SIGTERM, SIGINT and
-   SIGQUIT signals and pause the colibri process.
- */
-static void cs_wait_for_termination(void)
-{
-	struct sigaction        term_act;
-
-	term_act.sa_handler = cs_term_sig_handler;
-	sigemptyset(&term_act.sa_mask);
-	term_act.sa_flags = 0;
-	sigaction(SIGTERM, &term_act, NULL);
-	sigaction(SIGINT,  &term_act, NULL);
-	sigaction(SIGQUIT, &term_act, NULL);
-
-	pause();
-}
-
-int main(int argc, char **argv)
-{
-	int     rc;
-
-	errno = 0;
-	rc = c2_init();
-	if (rc != 0) {
-		fprintf(stderr, "\n Failed to initialise Colibri \n");
-		goto out;
-	}
-
-	rc = c2_cs_init(&colibri_ctx, cs_xprts, ARRAY_SIZE(cs_xprts), stderr);
-	if (rc != 0) {
-		fprintf(stderr, "\n Failed to initialise Colibri \n");
-		goto cleanup2;
-	}
-
-        rc = c2_cs_setup_env(&colibri_ctx, argc, argv);
-        if (rc != 0)
-                goto cleanup1;
-
-	rc = c2_cs_start(&colibri_ctx);
-
-	if (rc == 0)
-		cs_wait_for_termination();
-
-cleanup1:
-	c2_cs_fini(&colibri_ctx);
-cleanup2:
-	c2_fini();
-out:
-	errno = rc < 0 ? -rc : rc;
-	return errno;
-}
-
-/** @} endgroup colibri_setup */
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
diff --git a/colibri/init.c b/colibri/init.c
index 320f947..f300785 100644
--- a/colibri/init.c
+++ b/colibri/init.c
@@ -19,19 +19,15 @@
  */
 
 #include "lib/cdefs.h"
-#include "fop/fop.h"
-
-#ifndef __KERNEL__
-#   include "lib/user_space/thread.h"
-#   include "net/usunrpc/usunrpc.h"
-#   include "desim/sim.h"
-#endif
 
+#include "lib/user_space/thread.h"
 #include "stob/stob.h"
 #include "net/net.h"
 #include "net/bulk_emulation/sunrpc_xprt.h"
 #include "net/bulk_emulation/mem_xprt.h"
-#include "rpc/rpc2.h"
+#include "net/usunrpc/usunrpc.h"
+/* #include "rpc/rpclib.h" */
+#include "fop/fop.h"
 #include "addb/addb.h"
 #ifdef HAVE_CUNIT
 #include "lib/ut.h"
@@ -44,22 +40,13 @@
 #include "stob/linux.h"
 #include "stob/ad.h"
 #include "fol/fol.h"
+#include "desim/sim.h"
 #include "site/site.h"
 #include "cob/cob.h"
 #include "mdservice/md_fops.h"
-#include "reqh/reqh.h"
-#include "lib/timer.h"
 
 #include "colibri/init.h"
 
-#ifdef __KERNEL__
-#   include "c2t1fs/linux_kernel/c2t1fs.h"
-#   include "net/ksunrpc/ksunrpc.h"
-#   include "build_kernel_modules/dummy_init_fini.h"
-#endif
-
-#include "ioservice/io_fops.h"
-
 extern int  c2_memory_init(void);
 extern void c2_memory_fini(void);
 
@@ -71,10 +58,6 @@ struct init_fini_call {
 	const char *ifc_name;
 };
 
-/*
-  XXX dummy_init_fini.c defines dummy init() and fini() routines for
-  subsystems, that are not yet ported to kernel mode.
- */
 struct init_fini_call subsystem[] = {
 	{ &c2_trace_init,    &c2_trace_fini,   "trace" },
 	{ &c2_memory_init,   &c2_memory_fini,  "memory" },
@@ -82,32 +65,22 @@ struct init_fini_call subsystem[] = {
 	{ &c2_uts_init,      &c2_uts_fini,     "ut" },
 #endif
 	{ &c2_threads_init,  &c2_threads_fini, "thread" },
-	{ &c2_timers_init,   &c2_timers_fini,  "timer" },
 	{ &c2_addb_init,     &c2_addb_fini,    "addb" },
 	{ &c2_db_init,       &c2_db_fini,      "db" },
-	/* fol must be initialised before fops, because fop type registration
-	   registers a fol record type. */
-	{ &c2_fols_init,     &c2_fols_fini,     "fol" },
+/*	{ &c2_rpclib_init,   &c2_rpclib_fini,  "rpc" }, */
 	{ &c2_layouts_init,  &c2_layouts_fini, "layout" },
 	{ &c2_pools_init,    &c2_pools_fini,   "pool" },
 	{ &c2_fops_init,     &c2_fops_fini,    "fop" },
 	{ &c2_net_init,      &c2_net_fini,     "net" },
-	{ &c2_rpc_core_init, &c2_rpc_core_fini, "rpc"},
 	{ &c2_mem_xprt_init, &c2_mem_xprt_fini, "bulk/mem" },
 	{ &c2_sunrpc_fop_init, &c2_sunrpc_fop_fini, "bulk/sunrpc" },
-#ifndef __KERNEL__
 	{ &usunrpc_init,     &usunrpc_fini,     "user/sunrpc"},
-#else
-	{ &c2_ksunrpc_init,  &c2_ksunrpc_fini,     "ksunrpc"},
-	{ &c2t1fs_init_module, &c2t1fs_cleanup_module, "c2t1fs" },
-#endif
-	{ &c2_linux_stobs_init, &c2_linux_stobs_fini, "linux-stob" },
-	{ &c2_ad_stobs_init,    &c2_ad_stobs_fini,    "ad-stob" },
+	{ &linux_stobs_init, &linux_stobs_fini, "linux-stob" },
+	{ &ad_stobs_init,    &ad_stobs_fini,    "ad-stob" },
+	{ &c2_fols_init,     &c2_fols_fini,     "fol" },
 	{ &sim_global_init,  &sim_global_fini,  "desim" },
-	{ &c2_ioservice_fop_init, &c2_ioservice_fop_fini, "ioservice" },
 	{ &c2_sites_init,    &c2_sites_fini,    "sites" },
 	{ &c2_md_fop_init,   &c2_md_fop_fini,   "mdservice"}
-	{ &c2_reqhs_init,    &c2_reqhs_fini,    "reqh" }
 };
 
 static void fini_nr(int i)
@@ -126,6 +99,9 @@ int c2_init(void)
 	for (result = i = 0; i < ARRAY_SIZE(subsystem); ++i) {
 		result = subsystem[i].ifc_init();
 		if (result != 0) {
+			fprintf(stderr,
+				"Subsystem \"%s\" failed to initialize: %i.\n",
+				subsystem[i].ifc_name, result);
 			fini_nr(i);
 			break;
 		}
diff --git a/colibri/ut/Makefile.am b/colibri/ut/Makefile.am
deleted file mode 100644
index fe16fa0..0000000
--- a/colibri/ut/Makefile.am
+++ /dev/null
@@ -1,5 +0,0 @@
-noinst_LTLIBRARIES = libcs-ut.la
-libcs_ut_la_SOURCES = cs_ut_main.c
-libcs_ut_la_LIBADD = $(top_builddir)/colibri/libcolibri.la
-
-INCLUDES           = -I. -I$(top_srcdir)/include -I$(top_srcdir)
diff --git a/colibri/ut/cs_ut_main.c b/colibri/ut/cs_ut_main.c
deleted file mode 100644
index baa26a7..0000000
--- a/colibri/ut/cs_ut_main.c
+++ /dev/null
@@ -1,383 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Mandar Sawant <mandar_sawant@xyratex.com>
- * Original creation date: 12/10/2011
- */
-
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif
-
-#include "lib/ut.h"    /* C2_UT_ASSERT */
-#include "lib/misc.h"  /* C2_SET_ARR0 */
-#include "lib/errno.h"
-#include "lib/memory.h"
-#include "lib/tlist.h"
-
-#include "ut/rpc.h"
-#include "rpc/rpclib.h"
-#include "fop/fop.h"
-#include "net/bulk_sunrpc.h"
-#include "net/bulk_mem.h"
-#include "reqh/reqh_service.h"
-#include "colibri/colibri_setup.h"
-
-#include "fop/fop_format_def.h"
-
-#include "ut/cs_service.h"
-#include "ut/cs_fop_foms.h"
-#include "ut/cs_test_fops_u.h"
-#include "ut/cs_test_fops.ff"
-#include "rpc/rpc_opcodes.h"
-
-extern const struct c2_tl_descr ndoms_descr;
-
-/* Client context */
-struct cl_ctx {
-	/* Client network domain.*/
-	struct c2_net_domain cl_ndom;
-	/* Client db.*/
-	struct c2_dbenv      cl_dbenv;
-	/* Client cob domain.*/
-	struct c2_cob_domain cl_cdom;
-	/* Client rpc context.*/
-	struct c2_rpc_client_ctx    cl_ctx;
-};
-
-/* Configures colibri environment with given parameters. */
-static char *cs_ut_service_one_cmd[] = { "colibri_setup", "-r", "-T", "AD",
-                                "-D", "cs_sdb", "-S", "cs_stob",
-                                "-e", "bulk-sunrpc:127.0.0.1:34567:2",
-                                "-s", "ds1"};
-
-static char *cs_ut_services_many_cmd[] = { "colibri_setup", "-r", "-T", "AD",
-                                "-D", "cs_sdb", "-S", "cs_stob",
-                                "-e", "bulk-sunrpc:127.0.0.1:34567:2",
-                                "-e", "bulk-mem:127.0.0.1:35678",
-                                "-s", "ds1", "-s" "ds2"};
-
-static char *cs_ut_reqhs_many_cmd[] = { "colibri_setup", "-r", "-T", "AD",
-                                "-D", "cs_r1sdb", "-S", "cs_r1stob",
-                                "-e", "bulk-sunrpc:127.0.0.1:34567:2",
-                                "-s", "ds1",
-				"-r", "-T", "AD",
-                                "-D", "cs_r2sdb", "-S", "cs_r2stob",
-                                "-e", "bulk-mem:127.0.0.1:35678",
-                                "-s" "ds2"};
-
-static char *cs_ut_opts_jumbled_cmd[] = { "colibri_setup", "-r", "-D",
-                                "cs_sdb", "-T", "AD", "-s", "ds1",
-                                "-e", "bulk-sunrpc:127.0.0.1:34567:2",
-                                "-S", "cs_stob"};
-
-static char *cs_ut_reqh_none_cmd[] = { "colibri_setup", "-T", "AD",
-                                "-D", "cs_sdb", "-S", "cs_stob",
-                                "-e", "bulk-sunrpc:127.0.0.1:34567:2",
-                                "-s", "ds1"};
-
-static char *cs_ut_stype_bad_cmd[] = { "colibri_setup", "-r", "-T", "asdadd",
-                                "-D", "cs_sdb", "-S", "cs_stob",
-                                "-e", "bulk-sunrpc:127.0.0.1:34567:2",
-                                "-s", "ds1"};
-
-static char *cs_ut_xprt_bad_cmd[] = { "colibri_setup", "-r", "-T", "AD",
-                                "-D", "cs_sdb", "-S", "cs_stob",
-                                "-e", "asdasdada:127.0.0.1:34567:2",
-                                "-s", "ds1"};
-
-static char *cs_ut_ep_bad_cmd[] = { "colibri_setup", "-r", "-T", "AD",
-                                "-D", "cs_sdb", "-S", "cs_stob",
-                                "-e", "bulk-sunrpc:asdad:asdsd:sadasd",
-                                "-s", "ds1"};
-
-static char *cs_ut_service_bad_cmd[] = { "colibri_setup", "-r", "-T", "AD",
-                                "-D", "cs_sdb", "-S", "cs_stob",
-                                "-e", "bulk-sunrpc:127.0.0.1:34567:2",
-                                "-s", "dasdadasd"};
-
-static char *cs_ut_args_bad_cmd[] = { "colibri_setup", "-r", "-D", "cs_sdb",
-                                "-S", "cs_stob", "-e",
-                                "bulk-sunrpc:127.0.0.1:34567:2"};
-
-static const char *cl_ep_addrs[] = {
-				"127.0.0.1:34567:1",
-				"127.0.0.1:34569"};
-
-static const char *srv_ep_addrs[] = {
-				"127.0.0.1:34567:2",
-				"127.0.0.1:35678"};
-
-static const char *cdbnames[] = {
-				"cdb1",
-				"cdb2"};
-
-/*
-  Transports used in colibri a context.
- */
-static struct c2_net_xprt *cs_xprts[] = {
-	&c2_net_bulk_sunrpc_xprt,
-	&c2_net_bulk_mem_xprt
-};
-
-static int cl_cdom_id = 10001;
-
-enum {
-	MAX_RPCS_IN_FLIGHT = 10,
-	MAX_RPC_SLOTS_NR   = 2,
-	RPC_TIMEOUTS       = 5
-};
-
-enum {
-	BULK_SUNRPC_XPRT,
-	BULK_MEM_XPRT
-};
-
-#define SERVER_LOG_FILE_NAME	"cs_ut.errlog"
-
-static int cs_ut_client_init(struct cl_ctx *cctx, const char *cl_ep_addr,
-			const char *srv_ep_addr, const char* dbname,
-			struct c2_net_xprt *xprt)
-{
-	int rc;
-	struct c2_rpc_client_ctx *cl_ctx;
-
-	C2_PRE(cctx != NULL && cl_ep_addr != NULL && srv_ep_addr != NULL &&
-		dbname != NULL && xprt != NULL);
-
-	rc = c2_net_domain_init(&cctx->cl_ndom, xprt);
-	C2_UT_ASSERT(rc == 0);
-
-	cl_ctx = &cctx->cl_ctx;
-
-	cl_ctx->rcx_net_dom            = &cctx->cl_ndom;
-	cl_ctx->rcx_local_addr         = cl_ep_addr;
-	cl_ctx->rcx_remote_addr        = srv_ep_addr;
-	cl_ctx->rcx_db_name            = dbname;
-	cl_ctx->rcx_dbenv              = &cctx->cl_dbenv;
-	cl_ctx->rcx_cob_dom_id         = ++cl_cdom_id;
-	cl_ctx->rcx_cob_dom            = &cctx->cl_cdom;
-	cl_ctx->rcx_nr_slots           = MAX_RPC_SLOTS_NR;
-	cl_ctx->rcx_timeout_s          = RPC_TIMEOUTS;
-	cl_ctx->rcx_max_rpcs_in_flight = MAX_RPCS_IN_FLIGHT;
-
-	rc = c2_rpc_client_init(cl_ctx);
-	C2_UT_ASSERT(rc == 0);
-
-	return rc;
-}
-
-static void cs_ut_client_fini(struct cl_ctx *cctx)
-{
-	int rc;
-
-	C2_PRE(cctx != NULL);
-
-	rc = c2_rpc_client_fini(&cctx->cl_ctx);
-	C2_UT_ASSERT(rc == 0);
-
-	c2_net_domain_fini(&cctx->cl_ndom);
-}
-
-/*
-  Sends fops to server.
- */
-int c2_cs_ut_send_fops(struct c2_rpc_session *cl_rpc_session, int dstype)
-{
-	int                      rc;
-        uint32_t                 i;
-        struct c2_fop           *fop[10] = { 0 };
-	struct cs_ds1_req_fop   *cs_ds1_fop;
-	struct cs_ds2_req_fop   *cs_ds2_fop;
-
-	C2_PRE(cl_rpc_session != NULL && dstype > 0);
-
-	switch (dstype) {
-	case CS_UT_SERVICE1:
-		for (i = 0; i < 10; ++i) {
-			fop[i] = c2_fop_alloc(&cs_ds1_req_fop_fopt, NULL);
-			cs_ds1_fop = c2_fop_data(fop[i]);
-			cs_ds1_fop->csr_value = i;
-			rc = c2_rpc_client_call(fop[i], cl_rpc_session,
-						&cs_ds_req_fop_rpc_item_ops, 60);
-			C2_UT_ASSERT(rc == 0);
-		}
-		break;
-	case CS_UT_SERVICE2:
-		for (i = 0; i < 10; ++i) {
-			fop[i] = c2_fop_alloc(&cs_ds2_req_fop_fopt, NULL);
-			cs_ds2_fop = c2_fop_data(fop[i]);
-			cs_ds2_fop->csr_value = i;
-			rc = c2_rpc_client_call(fop[i], cl_rpc_session,
-						&cs_ds_req_fop_rpc_item_ops, 60);
-			C2_UT_ASSERT(rc == 0);
-		}
-		break;
-	default:
-		C2_ASSERT("Invalid service type" == 0);
-	}
-
-	return rc;
-}
-
-static int cs_ut_test_helper_success(struct cl_ctx *cctx, size_t cctx_nr,
-				     char *cs_argv[], int cs_argc)
-{
-	int rc;
-	int i;
-	int stype;
-
-	C2_RPC_SERVER_CTX_DECLARE(sctx, cs_xprts, ARRAY_SIZE(cs_xprts),
-				  cs_argv, cs_argc, SERVER_LOG_FILE_NAME);
-
-	rc = c2_rpc_server_start(&sctx);
-	C2_UT_ASSERT(rc == 0);
-
-	for (i = 0; i < cctx_nr; ++i) {
-		rc = cs_ut_client_init(&cctx[i], cl_ep_addrs[i], srv_ep_addrs[i],
-				       cdbnames[i], cs_xprts[i]);
-		C2_UT_ASSERT(rc == 0);
-	}
-
-	stype = CS_UT_SERVICE1;
-	for (i = 0; i < cctx_nr; ++i, ++stype)
-		c2_cs_ut_send_fops(&cctx[i].cl_ctx.rcx_session, stype);
-
-	for (i = 0; i < cctx_nr; ++i)
-		cs_ut_client_fini(&cctx[i]);
-
-	c2_rpc_server_stop(&sctx);
-
-	return rc;
-}
-
-static void cs_ut_test_helper_failure(char *cs_argv[], int cs_argc)
-{
-	int rc;
-
-	C2_RPC_SERVER_CTX_DECLARE(sctx, cs_xprts, ARRAY_SIZE(cs_xprts),
-				  cs_argv, cs_argc, SERVER_LOG_FILE_NAME);
-
-	rc = c2_rpc_server_start(&sctx);
-	C2_UT_ASSERT(rc != 0);
-
-	/*
-	 * If, for some reason, c2_rpc_server_start() completed without error,
-	 * we need to stop server.
-	 */
-	if (rc == 0)
-		c2_rpc_server_stop(&sctx);
-}
-
-static void test_cs_ut_service_one(void)
-{
-	struct cl_ctx  cctx[1] = { };
-
-	cs_ut_test_helper_success(cctx, ARRAY_SIZE(cctx), cs_ut_service_one_cmd,
-				  ARRAY_SIZE(cs_ut_service_one_cmd));
-}
-
-static void test_cs_ut_services_many(void)
-{
-	struct cl_ctx  cctx[2] = { };
-
-	cs_ut_test_helper_success(cctx, ARRAY_SIZE(cctx), cs_ut_services_many_cmd,
-				  ARRAY_SIZE(cs_ut_services_many_cmd));
-}
-
-static void test_cs_ut_reqhs_many(void)
-{
-	struct cl_ctx  cctx[2] = { };
-
-	cs_ut_test_helper_success(cctx, ARRAY_SIZE(cctx), cs_ut_reqhs_many_cmd,
-				  ARRAY_SIZE(cs_ut_reqhs_many_cmd));
-}
-
-static void test_cs_ut_opts_jumbled(void)
-{
-	struct cl_ctx  cctx[1] = { };
-
-	cs_ut_test_helper_success(cctx, ARRAY_SIZE(cctx), cs_ut_opts_jumbled_cmd,
-				  ARRAY_SIZE(cs_ut_opts_jumbled_cmd));
-}
-
-/*
-  Tests server side bad colibri setup commands.
- */
-static void test_cs_ut_reqh_none(void)
-{
-	cs_ut_test_helper_failure(cs_ut_reqh_none_cmd,
-				  ARRAY_SIZE(cs_ut_reqh_none_cmd));
-}
-
-static void test_cs_ut_stype_bad(void)
-{
-	cs_ut_test_helper_failure(cs_ut_stype_bad_cmd,
-				  ARRAY_SIZE(cs_ut_stype_bad_cmd));
-}
-
-static void test_cs_ut_xprt_bad(void)
-{
-	cs_ut_test_helper_failure(cs_ut_xprt_bad_cmd,
-				  ARRAY_SIZE(cs_ut_xprt_bad_cmd));
-}
-
-static void test_cs_ut_ep_bad(void)
-{
-	cs_ut_test_helper_failure(cs_ut_ep_bad_cmd,
-				  ARRAY_SIZE(cs_ut_ep_bad_cmd));
-}
-
-static void test_cs_ut_service_bad(void)
-{
-	cs_ut_test_helper_failure(cs_ut_service_bad_cmd,
-				  ARRAY_SIZE(cs_ut_service_bad_cmd));
-}
-
-static void test_cs_ut_args_bad(void)
-{
-	cs_ut_test_helper_failure(cs_ut_args_bad_cmd,
-				  ARRAY_SIZE(cs_ut_args_bad_cmd));
-}
-
-const struct c2_test_suite colibri_setup_ut = {
-        .ts_name = "colibri_setup-ut",
-        .ts_init = NULL,
-        .ts_fini = NULL,
-        .ts_tests = {
-                { "cs-single-service", test_cs_ut_service_one},
-		{ "cs-multiple-services", test_cs_ut_services_many},
-		{ "cs-multiple-request-handlers", test_cs_ut_reqhs_many},
-		{ "cs-command-options-jumbled", test_cs_ut_opts_jumbled},
-		{ "cs-missing-reqh-option", test_cs_ut_reqh_none},
-		{ "cs-bad-storage-type", test_cs_ut_stype_bad},
-		{ "cs-bad-network-xprt", test_cs_ut_xprt_bad},
-		{ "cs-bad-network-ep", test_cs_ut_ep_bad},
-		{ "cs-bad-service", test_cs_ut_service_bad},
-		{ "cs-missing-options", test_cs_ut_args_bad},
-                { NULL, NULL }
-        }
-};
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
diff --git a/configure.ac b/configure.ac
index 2f99633..e66dbe8 100644
--- a/configure.ac
+++ b/configure.ac
@@ -1,5 +1,5 @@
 AC_PREREQ([2.59])
-AC_INIT([colibri], [0.1], [colibri@xyratex.com])
+AC_INIT([colibri], [0.1], [colibri@clusterstor.com])
 AC_CONFIG_SRCDIR([colibri/init.c])
 AC_CONFIG_HEADER([config.h])
 AC_CONFIG_MACRO_DIR([m4])
@@ -14,11 +14,10 @@ AH_TEMPLATE([HAVE_FILE_AIO_READ], [Have fops->aio_read function])
 AH_TEMPLATE([HAVE_INODE_BLKSIZE], [Have inode->i_blksize field])
 AH_TEMPLATE([HAVE_WRITE_BEGIN_END], [Have .begin_write/end_write])
 AH_TEMPLATE([HAVE_SENDFILE], [Have .sendfile])
-AH_TEMPLATE([HAVE_STRUCT_NET], [Use struct net in sunrpc])
-AH_TEMPLATE([HAVE_CRED_IN_REQ], [Have rq_cred in rpc_rqst])
 AH_TEMPLATE([HAVE_MALLINFO], [Have mallinfo() function])
 AH_TEMPLATE([HAVE_MALLOC_SIZE], [Have malloc_size() function])
 AH_TEMPLATE([HAVE_BACKTRACE], [Have backtrace(3) function])
+AH_TEMPLATE([HAVE_CUNIT], [Have cunit library])
 
 COLIBRI_MAJOR_VERSION=0
 COLIBRI_MINOR_VERSION=1
@@ -33,17 +32,15 @@ AC_SUBST([LT_RELEASE])
 
 AC_DEFUN([COLIBRI_LINUX_CHECK_SYMBOL],
         AC_MSG_CHECKING([for symbols file])
-        if test -f $LINUX_OBJ/Module.symvers; then
-                SYMVERFILE=$LINUX_OBJ/Module.symvers
-        elif test -f $LINUX_OBJ/Modules.symvers; then
-                SYMVERFILE=$LINUX_OBJ/Modules.symvers
+        if grep -q Modules.symvers $LINUX/scripts/Makefile.modpost ; then
+                SYMVERFILE=Modules.symvers
         else
-                AC_MSG_ERROR([Failed to find symbols files in $LINUX_OBJ])
-        fi
-	AC_MSG_RESULT([$SYMVERFILE])
+                SYMVERFILE=Module.symvers
+	fi
+	AC_MSG_RESULT([$LINUX/$SYMVERFILE])
 
         [AC_MSG_CHECKING([for symbol $1 exported])
-        grep -q -E '[[[:space:]]]$1[[[:space:]]]' $SYMVERFILE 2>/dev/null
+        grep -q -E '[[[:space:]]]$1[[[:space:]]]' $LINUX/$SYMVERFILE 2>/dev/null
         rc=$?
         if test $rc -eq 0; then
     	        AC_MSG_RESULT([yes])
@@ -192,40 +189,6 @@ COLIBRI_LINUX_TRY_COMPILE([
 ])
 ])
 
-AC_DEFUN([COLIBRI_LINUX_STRUCT_NET],
-[
-AC_MSG_CHECKING([if kernel sunrpc uses struct net])
-COLIBRI_LINUX_TRY_COMPILE([
-#include <linux/sunrpc/clnt.h>
-],[
-        struct rpc_create_args a;
-
-        a.net = NULL;
-], [
-        AC_MSG_RESULT([yes])
-        AC_DEFINE([HAVE_STRUCT_NET])
-],[
-        AC_MSG_RESULT([no])
-])
-])
-
-AC_DEFUN([COLIBRI_LINUX_CRED_IN_REQ],
-[
-AC_MSG_CHECKING([if kernel sunrpc has rq_cred in rpc_rqst])
-COLIBRI_LINUX_TRY_COMPILE([
-#include <linux/sunrpc/clnt.h>
-],[
-        struct rpc_rqst r;
-
-        r.rq_cred = NULL;
-], [
-        AC_MSG_RESULT([yes])
-        AC_DEFINE([HAVE_CRED_IN_REQ])
-],[
-        AC_MSG_RESULT([no])
-])
-])
-
 AC_DEFUN([COLIBRI_LINUX_INIT_CONFIG], [
 rm -fr config > /dev/null 2>&1
 mkdir config
@@ -238,7 +201,7 @@ _ACEOF
 ])
 
 # Checks for programs.
-AM_PROG_CC_C_O
+AC_PROG_CC
 AC_PROG_CPP
 AM_PROG_CC_C_O
 AC_PROG_INSTALL
@@ -257,14 +220,6 @@ if ! test -d $SRCDIR; then
 fi
 AC_SUBST([SRCDIR])
 
-AC_MSG_CHECKING([whether target platform is 64bit one])
-AC_COMPUTE_INT(n_bits, [sizeof(long) * 8])
-if test $n_bits -lt 64; then
-	AC_MSG_RESULT([no])
-	AC_MSG_ERROR([Only 64bit platforms are supported!])
-fi
-AC_MSG_RESULT([yes])
-
 # Checks for libraries.
 OLD_LIBS=$LIBS
 AC_SEARCH_LIBS([xdr_domainname], [c nsl], [], [AC_MSG_ERROR([xdr_domainname cannot be found!])])
@@ -284,6 +239,43 @@ AC_CHECK_HEADERS([stdlib.h])
 AC_CHECK_HEADERS([pthread.h], [], [AC_MSG_ERROR([pthread.h cannot be found!])])
 AC_CHECK_HEADERS([netinet/in.h], [AC_DEFINE([HAVE_NETINET_IN_H])])
 
+# Checking for CUnit
+OLD_CFLAGS=$CFLAGS
+
+enable_cunit=yes
+# Make sure that CUnit is found on Mac OS X where it is usually instalelled from ports to /opt/local
+CFLAGS="-I/usr/local/include -I/opt/local/include"
+AC_CHECK_HEADERS([CUnit/CUnit.h CUnit/Basic.h CUnit/Automated.h], [], [
+    AC_MSG_NOTICE([CUnit/Cunit.h cannot be found!])
+    enable_cunit=no
+], 
+[
+#ifdef CUNIT_CUNIT_H
+#include <CUnit/CUnit.h>
+#endif
+])
+OLD_LIBS=$LIBS
+
+OLD_LIBS=$LIBS
+if test x$enable_cunit = xyes; then
+    # Make sure that CUnit is found on Mac OS X where it is usually instalelled from ports to /opt/local
+    LIBS="$LIBS -L/usr/local/lib -L/opt/local/lib"
+    AC_SEARCH_LIBS([CU_basic_run_tests], [cunit], [], [
+        AC_MSG_NOTICE([CU_basic_run_tests() cannot be found!])
+        enable_cunit=no
+    ])
+    if test x$enable_cunit = xyes; then
+        CUNIT_LIBS=$LIBS
+        AC_SUBST([CUNIT_LIBS])
+        LIBS=$OLD_LIBS
+        CFLAGS=$OLD_CFLAGS
+        AC_DEFINE([HAVE_CUNIT])
+    fi
+fi
+LIBS=$OLD_LIBS
+
+AM_CONDITIONAL([HAVE_CUNIT_SUPPORT], [test x$enable_cunit = xyes])
+
 # Checks for typedefs, structures, and compiler characteristics.
 AC_TYPE_SIZE_T
 
@@ -306,58 +298,44 @@ AC_ARG_ENABLE([gssrpc],
         [enable_gssrpc=no]
 )
 
-AC_ARG_ENABLE([rpm],
-        [AC_HELP_STRING([--enable-rpm], [enable rpm build mode])], [],
-        [enable_rpm=no]
+AC_ARG_ENABLE([db-o_direct],
+        [AC_HELP_STRING([--enable-db-o_direct], [enable db direct IO support])], [],
+        [enable_db_o_direct=no]
 )
 
 AC_MSG_CHECKING([for operating system])
 AC_MSG_RESULT([$host_os])
 case $host_os in
-        linux*)
+        linux*) 
                 ;;
         *)
                 AC_MSG_ERROR([Unsupported platform detected!])
                 ;;
 esac
 
+AC_MSG_CHECKING([for linux sources dir])
+AC_ARG_WITH([linux],
+        [AC_HELP_STRING([--with-linux=path], [set path to linux sources])],
+        [LINUX=$with_linux],
+        [LINUX=/lib/modules/`uname -r`/build]
+)
+
+AC_MSG_RESULT([$LINUX])
+AC_SUBST([LINUX])
+
 AC_MSG_CHECKING([for linux objects dir])
 AC_ARG_WITH([linux-obj],
-        [AC_HELP_STRING([--with-linux-obj=path],
-                        [set path to Linux objects dir (default=/lib/modules/$(uname -r)/build])],
+        [AC_HELP_STRING([--with-linux-obj=path], [set path to linux objects dir])],
         [LINUX_OBJ=$with_linux_obj],
-        [LINUX_OBJ=/lib/modules/`uname -r`/build]
+        [LINUX_OBJ=$LINUX]
 )
 
 AC_MSG_RESULT([$LINUX_OBJ])
 AC_SUBST([LINUX_OBJ])
 
-LINUX_MOD=$(dirname $LINUX_OBJ)
+LINUX_MOD="/lib/modules/`uname -r`"
 AC_SUBST([LINUX_MOD])
 
-AC_ARG_ENABLE([coverage],
-	[AC_HELP_STRING([--enable-coverage], [build for test coverage analysis])],
-	[case "${enableval}" in
-		yes) ENABLE_COVERAGE=1 ;;
-		no) ENABLE_COVERAGE=0 ;;
-		*) AC_MSG_ERROR([Invalid value ${enableval} for --enable-coverage]) ;;
-	esac],
-	[ENABLE_COVERAGE=0])
-
-AC_SUBST([ENABLE_COVERAGE])
-
-if test "x[$]ENABLE_COVERAGE" = "x1"
-then
-	# Remove -O<digit> flag from $CFLAGS
-	CFLAGS="`echo $CFLAGS | sed 's/-O[0-9]//g'` --coverage"
-	LDFLAGS="-lgcov"
-	K_ENABLE_COVERAGE=y
-else
-	K_ENABLE_COVERAGE=n
-fi
-
-AC_SUBST([K_ENABLE_COVERAGE])
-
 # Prepare linux configuration checks facility. Should be done before
 # any *_LINUX_* checks.
 COLIBRI_LINUX_INIT_CONFIG
@@ -370,167 +348,93 @@ COLIBRI_LINUX_FILE_READV
 COLIBRI_LINUX_FILE_AIO_READ
 COLIBRI_LINUX_WRITE_BEGIN_END
 COLIBRI_LINUX_SENDFILE
-COLIBRI_LINUX_STRUCT_NET
-COLIBRI_LINUX_CRED_IN_REQ
-
-build_lib() {
-       NAME=$1
-       SRC=$2
-       LIBS=$3
-       SUBP=$4
-       OPTS=$5
-       if ! test -e $LIBS; then
-               AC_MSG_RESULT([building $SRC])
-               oldcwd=$(pwd)
-               cd $SRC && $SUBP/configure $OPTS && make
-               res=$?
-               cd $oldcwd
-               if ! test $res -eq 0 ; then
-                       AC_MSG_ERROR([An error occured while building lib$NAME!])
-               fi
-               if ! test -e $LIBS; then
-                       AC_MSG_ERROR([$LIBS not found! Build failed?])
-               fi
-       else
-               AC_MSG_RESULT([$LIBS])
-       fi
-}
+
+AC_ARG_WITH([db],
+        [AC_HELP_STRING([--with-db=path], [path where db was built])])
 
 OLD_LIBS=$LIBS
 OLD_CFLAGS=$CFLAGS
 LIBS=""
 CFLAGS=""
 
-# Check for galois
-if test x$enable_rpm = xyes; then
-
-OLD_LIBS=$LIBS
-LIBS=""
-AC_SEARCH_LIBS([galois_create_mult_tables], [galois], [
-        AC_CHECK_HEADERS([galois/galois.h], [],
-        [
-                AC_MSG_ERROR([galois/galois.h is not found. Try install galois from $SRCDIR/../galois or from rpm])
-        ],[])
-], [
-        AC_MSG_ERROR([galois_create_mult_tables cannot be found! Try install galois package from $SRCDIR/../galois or from rpm])
-])
-GALOIS_SRC=""
-GALOIS_LIBS=$LIBS
-LIBS=$OLD_LIBS
-
-galois_locations="/usr /usr/local /opt /opt/local"
-AC_MSG_CHECKING([galois symvers])
-GALOIS_SYMVERS=""
-for p in $galois_locations; do
-        symvers="$p/share/galois/symvers/Module.symvers"
-        if test -f $symvers; then
-                GALOIS_SYMVERS=$symvers
-                break
-        fi
-done
-
-if ! test x$GALOIS_SYMVERS = "x"; then
-        AC_MSG_RESULT([$GALOIS_SYMVERS])
-        AC_SUBST([GALOIS_SYMVERS])
+AC_MSG_CHECKING([for db libs])
+if test x$with_db != x; then
+	DB_SRC="$with_db"
+        DB_LIBS="$DB_SRC/build_unix/libdb.a"
+	if ! test -e $DB_LIBS; then
+		AC_MSG_ERROR([$DB_LIBS not found! Did you build db?])
+	fi
+        AC_MSG_RESULT([$DB_LIBS])
 else
-        AC_MSG_ERROR([Galois Module.symvers is not found in the following locations: ${galois_locations}])
+	DB_SRC="$SRCDIR/../db4"
+        DB_LIBS="$DB_SRC/build_unix/libdb.a"
+	if ! test -e $DB_LIBS; then
+		oldcwd=$(pwd)
+		if test x$enable_db_o_direct = xyes; then
+		        o_direct_options="--enable-o_direct"
+		else
+		        o_direct_options=""
+		fi
+                AC_MSG_RESULT([building $DB_SRC])
+
+                # We need -fPIC to link libdb.a (static library) into so libraries, which should
+                # have position intependent code as nobody case foresee in what addresses inside
+                # calling process it will be mapped
+                AC_MSG_NOTICE([cd $DB_SRC/build_unix && ../dist/configure $o_direct_options && make])
+		cd $DB_SRC/build_unix && ../dist/configure CFLAGS="$CFLAGS -fPIC" $o_direct_options && make
+		res=$?
+		cd $oldcwd
+		if ! test $res -eq 0 ; then
+			AC_MSG_ERROR([An error occured while building db!])
+		fi
+		if ! test -e $DB_LIBS; then
+			AC_MSG_ERROR([$DB_LIBS not found! Build failed?])
+	        fi
+	else
+                DB_LIBS="$DB_SRC/build_unix/libdb.a"
+                AC_MSG_RESULT([$DB_LIBS])
+	fi
 fi
 
-else
-
+# Check for galois
 GALOIS_SRC=$SRCDIR/../galois
-GALOIS_LIBS="$GALOIS_SRC/src/libgalois.la"
+GALOIS_LIBS="$GALOIS_SRC/libgalois.la"
 AC_MSG_CHECKING([for galois libs])
-build_lib galois $GALOIS_SRC $GALOIS_LIBS "." "--with-linux-obj=$LINUX_OBJ"
-
-AC_MSG_CHECKING([galois symvers])
-GALOIS_SYMVERS="$GALOIS_SRC/src/linux_kernel/Module.symvers"
-if test -f $GALOIS_SYMVERS; then
-        AC_MSG_RESULT([$GALOIS_SYMVERS])
-        AC_SUBST([GALOIS_SYMVERS])
+if ! test -e $GALOIS_LIBS; then
+        AC_MSG_RESULT([building $GALOIS_SRC])
+	oldcwd=$(pwd)
+	cd $GALOIS_SRC && ./configure && make
+        res=$?
+        cd $oldcwd
+	if ! test $res -eq 0 ; then
+                AC_MSG_ERROR([An error occured while building libgalois!])
+        fi
+	if ! test -e $GALOIS_LIBS; then
+                AC_MSG_ERROR([$GALOIS_LIBS not found! Build failed?])
+        fi
 else
-        AC_MSG_ERROR([Can't find ${GALOIS_SYMVERS}! Make sure that galois is built correctly.])
+	AC_MSG_RESULT([$GALOIS_LIBS])
 fi
-fi
-
-# Check for yaml
-if test x$enable_rpm = xyes; then
 
-OLD_LIBS=$LIBS
-LIBS=""
-AC_SEARCH_LIBS([yaml_parser_initialize], [yaml], [], [AC_MSG_ERROR([yaml_parser_initialize cannot be found! Try install yaml package from $SRCDIR/../yaml or from rpm])])
-YAML_LIBS=$LIBS
 LIBS=$OLD_LIBS
+CFLAGS=$OLD_CFLAGS
 
-else
-
-YAML_SRC=$SRCDIR/../yaml
-YAML_LIBS="$YAML_SRC/src/libyaml.la"
-AC_MSG_CHECKING([for yaml libs])
-build_lib yaml $YAML_SRC $YAML_LIBS "."
-
-fi
-
-# Check for CUnit
-if test x$enable_rpm = xyes; then
-
-OLD_LIBS=$LIBS
-LIBS=""
-AC_SEARCH_LIBS([CU_add_suite], [cunit],
-[
-        AC_CHECK_HEADERS([CUnit/Basic.h], [],
-        [
-                AC_MSG_ERROR([CUnit/Basic.h is not found. Try install CUnit from $SRCDIR/../cunit or CUnit-devel rpm package])
-        ],[])
-], [
-        AC_MSG_ERROR([CU_add_suite cannot be found! Try install CUnit package from $SRCDIR/../cunit or from rpm])
-], [-lncurses])
-CUNIT_LIBS=$LIBS
-LIBS=$OLD_LIBS
-
-else
-
-CUNIT_SRC=$SRCDIR/../cunit
-CUNIT_LIBS="$CUNIT_SRC/CUnit/Sources/libcunit.la"
-CUNIT_HEADERS="$CUNIT_SRC/CUnit/Headers"
-AC_MSG_CHECKING([for cunit libs])
-build_lib cunit $CUNIT_SRC $CUNIT_LIBS "." "--enable-curses"
-
-fi
-
-# Check for berkley db
-if test x$enable_rpm = xyes; then
-
-OLD_LIBS=$LIBS
-LIBS=""
-AC_SEARCH_LIBS([db_env_create], [db], [
-        AC_CHECK_HEADERS([db.h], [],
-        [
-                AC_MSG_ERROR([db.h is not found. Try install db4-devel package])
-        ],[])
-], [
-        AC_MSG_ERROR([db_env_create cannot be found! Try install db4-devel package])
-])
-DB_LIBS=$LIBS
-
-else
-
-DB_SRC="$SRCDIR/../db4/build_unix"
-DB_LIBS="$DB_SRC/libdb.a"
-AC_MSG_CHECKING([for db libs])
-build_lib db $DB_SRC $DB_LIBS "../dist" "--with-pic"
-
+# Check if o_direct patch applied
+if test x$enable_db_o_direct = xyes; then
+        AC_MSG_CHECKING([for direct I/O patch applied to db])
+        $NM_B $DB_LIBS | grep -q -E '[[[:digit:]]]*[[[:space:]]]T[[[:space:]]]__os_calloc_for_IO';
+        rc=$?
+        if ! test $rc -eq 0; then
+                AC_MSG_RESULT([no])
+                AC_MSG_ERROR([No direct I/O patch applied to db at $DB_SRC found!])
+        else
+                AC_MSG_RESULT([yes])
+        fi
 fi
 
-LIBS=$OLD_LIBS
-CFLAGS=$OLD_CFLAGS
-
 AC_SUBST([DB_SRC])
 AC_SUBST([DB_LIBS])
-AC_SUBST([GALOIS_SRC])
 AC_SUBST([GALOIS_LIBS])
-AC_SUBST([YAML_LIBS])
-AC_SUBST([CUNIT_LIBS])
 
 if test x$enable_gssrpc = xyes; then
         AC_CHECK_LIB([gssrpc], [xdr_int], [
@@ -556,7 +460,6 @@ if test x$enable_gssrpc = xyes; then
         fi
 fi
 
-# Check for libaio
 OLD_LIBS=$LIBS
 LIBS=""
 AC_SEARCH_LIBS([io_getevents], [c aio], [], [AC_MSG_ERROR([io_getevents cannot be found! Try install libaio-devel.])])
@@ -572,45 +475,17 @@ if test x$enable_debug = xyes; then
         AC_DEFINE([ENABLE_DEBUG])
 else
         # Remove debug flags but keep default or user optimizations
-        # passed via construction like ./configure CFLAGS=-O3
+        # passed via construction like ./configure CFLAGS=-O3 
         CFLAGS="$(echo $CFLAGS | sed 's/-g//')"
 fi
 
-# Check if gcc option is supported in current gcc version.
-AC_DEFUN([COLIBRI_COMPILER_OPTION_CHECK],
-[AC_MSG_CHECKING([whether compiler $CC supports $1 option])
-OLD_CFLAGS="$CFLAGS"
-CFLAGS="$OLD_CFLAGS $1"
-AC_COMPILE_IFELSE([COLIBRI_LANG_PROGRAM()],
-        [AC_MSG_RESULT([yes]);
-         KCFLAGS="$KCFLAGS $1"],
-        [AC_MSG_RESULT([no]);
-	 KCFLAGS="$KCFLAGS"]
-)]
-CFLAGS="$OLD_CFLAGS")
-
-#
-# _GNU_SOURCE for asprintf(3), open(2) O_DIRECT flag
-#
-if test x$enable_rpm = xyes; then
-
-GALOIS_INCLUDES="-I/usr/local/include -I/usr/include"
-CFLAGS="-Wall -Werror -D_REENTRANT -D_GNU_SOURCE -fno-strict-aliasing -I. -I$SRCDIR $CFLAGS"
-
-else
-
-GALOIS_INCLUDES="-I$GALOIS_SRC/include"
-CFLAGS="-Wall -Werror -D_REENTRANT -D_GNU_SOURCE -fno-strict-aliasing \
-        -I$DB_SRC/build_unix $GALOIS_INCLUDES -I$YAML_SRC/include \
-        -I$CUNIT_HEADERS -I. -I$SRCDIR $CFLAGS"
-fi
-
 #
-# Galois header may be in one of the following standard loctions. Kernel needs to know about.
+# _GNU_SOURCE for asprintf(3)
 #
-KCFLAGS="-Wall -Werror $KCFLAGS $GALOIS_INCLUDES"
-COLIBRI_COMPILER_OPTION_CHECK([-Wno-unused-but-set-variable])
-
+COLIBRI_HEADERS="-I$DB_SRC/build_unix -I$GALOIS_SRC"
+AC_SUBST([COLIBRI_HEADERS])
+CFLAGS="-Wall -Werror -D_REENTRANT -D_GNU_SOURCE -fno-strict-aliasing -I$DB_SRC/build_unix -I$GALOIS_SRC -I. -I$SRCDIR $CFLAGS"
+KCFLAGS="-Wall -Werror $KCFLAGS"
 LDFLAGS="-rdynamic $LDFLAGS"
 
 # trim spaces at the end of flags
@@ -622,26 +497,22 @@ AC_SUBST([KCFLAGS])
 # Please keep this list sorted (always appending new items at the end
 # results in needless merge conflicts)
 AC_CONFIG_FILES([
-                 Makefile
+		 Makefile
+		 headers
                  addb/Makefile
                  addb/addb_pseudo/Makefile
+                 addb/linux_kernel/Makefile
                  balloc/Makefile
                  balloc/ut/Makefile
                  build_kernel_modules/Makefile
-                 capa/Makefile
-                 capa/ut/Makefile
                  c2t1fs/Makefile
-                 c2t1fs/linux_kernel/st/common.sh
-                 cfg/Makefile
+                 capa/Makefile
+		 capa/ut/Makefile
                  cob/Makefile
                  cob/ut/Makefile
                  colibri/Makefile
-                 colibri/ut/Makefile
-		 console/Makefile
-                 console/bin/Makefile
-                 console/ut/Makefile
-                 console/st/Makefile
                  db/Makefile
+                 db/linux_kernel/Makefile
                  db/ut/Makefile
                  desim/Makefile
                  desim/ut/Makefile
@@ -652,13 +523,12 @@ AC_CONFIG_FILES([
                  fol/ut/Makefile
                  fop/Makefile
                  fop/fop2c
-                 fop/rt/Makefile
+                 fop/linux_kernel/Makefile
                  fop/ut/Makefile
-                 ioservice/Makefile
-                 ioservice/ut/Makefile
                  layout/Makefile
                  layout/ut/Makefile
                  lib/Makefile
+                 lib/linux_kernel/Makefile
                  lib/user_space/Makefile
                  lib/ut/Makefile
                  m4/Makefile
@@ -667,8 +537,8 @@ AC_CONFIG_FILES([
                  net/Makefile
 		 net/bulk_emulation/Makefile
 		 net/bulk_emulation/st/Makefile
-		 net/bulk_emulation/st/linux_kernel/Makefile
 		 net/bulk_emulation/ut/Makefile
+                 net/ksunrpc/Makefile
                  net/usunrpc/Makefile
 		 net/ut/Makefile
 		 net/st/Makefile
@@ -676,14 +546,8 @@ AC_CONFIG_FILES([
                  patches/Makefile
                  pool/Makefile
                  reqh/Makefile
-		 reqh/ut/Makefile
                  site/Makefile
-                 rpc/Makefile
-                 rpc/ut/Makefile
-                 rpc/it/Makefile
-		 rpc/it/linux_kernel/Makefile
                  sm/Makefile
-                 sm/ut/Makefile
                  sns/Makefile
                  sns/ut/Makefile
                  stob/Makefile
@@ -691,22 +555,25 @@ AC_CONFIG_FILES([
                  mdstore/Makefile
                  mdstore/ut/Makefile
                  iostore/Makefile
+		 ioservice/Makefile
 		 mdservice/Makefile
                  udb/Makefile
                  udb/ut/Makefile
-                 ut/Makefile
-                 ut/linux_kernel/Makefile
                  utils/Makefile
                  utils/linux_kernel/Makefile
-                 utils/ploss/Makefile
-                 xcode/Makefile
-                 xcode/ff2c/Makefile
-                 xcode/ut/Makefile
-		 yaml2db/Makefile
-		 yaml2db/ut/Makefile
-		 yaml2db/st/Makefile
-		 colibri.spec
+		 utils/ploss/Makefile
+		 sns/linux_kernel/Makefile
+		 galois/linux_kernel/Makefile
+		 layout/linux_kernel/Makefile
+		 pool/linux_kernel/Makefile
+		 stob/linux_kernel/Makefile
+		 xdr/Makefile
+		 xdr/ut/Makefile
                 ])
+                
+                #rpc/Makefile
+                #rpc/ut/Makefile
+                #net/ut/Makefile
 AC_OUTPUT
 
 #
@@ -717,18 +584,15 @@ chmod +x $SRCDIR/fop/fop2c
 chmod +x $SRCDIR/headers
 
 echo ""
-echo "GALOIS_LIBS :  \"$GALOIS_LIBS\""
-echo "CUNIT_LIBS  :  \"$CUNIT_LIBS\""
-echo "YAML_LIBS   :  \"$YAML_LIBS\""
-echo "DB_LIBS     :  \"$DB_LIBS\""
-echo "AIO_LIBS    :  \"$AIO_LIBS\""
-echo ""
-echo "CFLAGS      :  \"$CFLAGS\""
-echo "KCFLAGS     :  \"$KCFLAGS\""
-echo "LDFLAGS     :  \"$LDFLAGS\""
+echo "LIBS   :  \"$LIBS\""
+echo "CFLAGS :  \"$CFLAGS\""
+echo "KCFLAGS:  \"$KCFLAGS\""
+echo "LDFLAGS:  \"$LDFLAGS\""
 echo ""
 
-echo "Linux Obj   :  \"$LINUX_OBJ\""
+echo "Galois :  \"$GALOIS_SRC\""
+echo "Db     :  \"$DB_SRC\""
+echo "Linux  :  \"$LINUX\""
 echo ""
 
 echo "Type 'make' to build Colibri"
diff --git a/console/.gitignore b/console/.gitignore
deleted file mode 100644
index fe9f227..0000000
--- a/console/.gitignore
+++ /dev/null
@@ -1,6 +0,0 @@
-bin/c2console
-console_[uk].[ch]
-st/server
-rm/
-../rm/
-bin/main.c
diff --git a/console/Makefile.am b/console/Makefile.am
deleted file mode 100644
index 7bdc15e..0000000
--- a/console/Makefile.am
+++ /dev/null
@@ -1,25 +0,0 @@
-consoledir                      = $(includedir)/colibri/console
-console_HEADERS                 = console.h console_fom.h console_fop.h console_it.h \
-                                  console_mesg.h console_u.h console_yaml.h
-
-INCLUDES			= -I. -I$(top_srcdir) -I$(top_srcdir)/include
-
-console_U_SOURCES		= console_u.h console_u.c
-
-$(console_U_SOURCES):	console.ff \
-			$(top_builddir)/fop/rt/libc2rt.la \
-			$(top_builddir)/fop/fop2c
-			$(top_builddir)/fop/fop2c -u $<
-
-noinst_LTLIBRARIES		= libcolibri-console.la
-libcolibri_console_la_SOURCES	= $(console_U_SOURCES) console.ff \
-				  console_fop.c console_fop.h \
-				  console_fom.c console_fom.h \
-				  console_yaml.h console_yaml.c \
-				  console_it.h console_it.c \
-				  console_mesg.h console_mesg.c \
-				  console.h console.c
-
-EXTRA_DIST			= console.ff main.c
-
-MOSTLYCLEANFILES		= $(console_U_SOURCES)
diff --git a/console/bin/Makefile.am b/console/bin/Makefile.am
deleted file mode 100644
index 35e32b1..0000000
--- a/console/bin/Makefile.am
+++ /dev/null
@@ -1,10 +0,0 @@
-INCLUDES			= -I. -I$(top_srcdir) -I$(top_srcdir)/include
-main.c:
-	ln -sf $(top_builddir)/console/main.c main.c
-
-noinst_PROGRAMS			= c2console
-
-c2console_SOURCES		= main.c
-
-c2console_LDADD			= $(top_builddir)/colibri/libcolibri.la \
-				  $(top_builddir)/ut/libcolibri-ut.la
diff --git a/console/console.c b/console/console.c
deleted file mode 100644
index d47ad70..0000000
--- a/console/console.c
+++ /dev/null
@@ -1,43 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Dipak Dudhabhate <dipak_dudhabhate@xyratex.com>
- * Original creation date: 08/03/2011
- */
-#ifdef HAVE_CONFIG_H
-#  include <config.h>
-#endif
-
-#include "console/console.h"
-
-/**
-   @addtogroup console
-   @{
- */
-
-bool verbose;
-
-/** @} end of console group */
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
diff --git a/console/console.ff b/console/console.ff
deleted file mode 100644
index fa957bf..0000000
--- a/console/console.ff
+++ /dev/null
@@ -1,79 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Dipak Dudhabhate <dipak_dudhabhate@xyratex.com>
- * Original creation date: 08/03/2011
- */
-
-/**
-  @addtogroup rm
-  @{
- */
-
-/** @file console.ff
- *
- * Failure fops should be defined by not yet existing "failure" module. For the
- * time being, it makes sense to put them in cm/ or console/. ioservice is not
- * directly responsible for handling failures, it is intersected by copy-machine
- * (cm).
- * <b>Console fop formats</b>
- */
-
-DEF(c2_cons_fop_fid, RECORD,
-    _(cons_seq, U64),
-    _(cons_oid, U64));
-
-DEF(c2_cons_fop_buf, SEQUENCE,
-    _(cons_size, U32),
-    _(cons_buf, BYTE));
-
-DEF(c2_cons_fop_test, RECORD,
-    _(cons_id, c2_cons_fop_fid),
-    _(cons_test_type, BYTE),
-    _(cons_test_id, U64));
-
-/** Device failure notification fop
-    - id	  : Console id.
-    - notify_type : Device failure notification.
-    - dev_id 	  : Device ID(Disk ID in case disk failure).
-    - dev_name 	  : Device name(In case of disk it could be volume name).
- */
-DEF(c2_cons_fop_device, RECORD,
-    _(cons_id, c2_cons_fop_fid),
-    _(cons_notify_type, U32),
-    _(cons_dev_id, U64),
-    _(cons_dev_name, c2_cons_fop_buf));
-
-/** Reply fop to the notification fop
-    - notify_type : Notification type of request fop.
-    - return 	  : Opcode of request fop.
- */
-DEF(c2_cons_fop_reply, RECORD,
-    _(cons_notify_type, U32),
-    _(cons_return, U32));
-
-/** @} end of console group */
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
-
diff --git a/console/console.h b/console/console.h
deleted file mode 100644
index 9a9a8c5..0000000
--- a/console/console.h
+++ /dev/null
@@ -1,58 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Dipak Dudhabhate <dipak_dudhabhate@xyratex.com>
- * Original creation date: 08/03/2011
- */
-
-#ifndef __COLIBRI_CONSOLE_H__
-#define __COLIBRI_CONSOLE_H__
-
-#include <stdbool.h>
-
-/**
-   @defgroup console Console
-
-   Build a standalone utility that
-
-   - connects to a specified service.
-   - constructs a fop of a specified fop type and with specified
-     values of fields and sends it to the service.
-   - waits fop reply.
-   - outputs fop reply to the user.
-
-   The console utility can send a DEVICE_FAILURE fop to a server. Server-side
-   processing for fops of this type consists of calling a single stub function.
-   Real implementation will be supplied by the middleware.cm-setup task.
-
-   @{
-*/
-
-extern bool verbose;
-
-/* __COLIBRI_CONSOLE_H__ */
-#endif
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
-
diff --git a/console/console_fom.c b/console/console_fom.c
deleted file mode 100644
index 52d439f..0000000
--- a/console/console_fom.c
+++ /dev/null
@@ -1,147 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Dipak Dudhabhate <Dipak_Dudhabhate@xyratex.com>
- * Original creation date: 08/04/2011
- */
-/*
- * Failure fops should be defined by not yet existing "failure" module. For the
- * time being, it makes sense to put them in cm/ or console/. ioservice is not
- * directly responsible for handling failures, it is intersected by copy-machine
- * (cm).
- */
-
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif
-
-#include "lib/errno.h"		/* EINVAL */
-#include "lib/memory.h"		/* C2_ALLOC_PTR */
-#include "console/console_fom.h"
-#include "console/console_fop.h"
-#include "console/console_mesg.h"
-#include "console/console_u.h"
-
-/**
-   @addtogroup console
-   @{
-*/
-
-static size_t home_locality(const struct c2_fom *fom)
-{
-        C2_PRE(fom != NULL);
-
-        return fom->fo_fop->f_type->ft_rpc_item_type.rit_opcode;
-}
-
-static void default_fom_fini(struct c2_fom *fom)
-{
-	c2_fom_fini(fom);
-	c2_free(fom);
-
-        return;
-}
-
-static int cons_fop_fom_create(struct c2_fop *fop, struct c2_fom **m)
-{
-        struct c2_fom *fom;
-	struct c2_fop *rep_fop;
-
-        C2_PRE(fop != NULL);
-        C2_PRE(m != NULL);
-	C2_PRE(fop->f_type == &c2_cons_fop_device_fopt);
-
-	/*
-	 * XXX
-	 * The proper way to do this is to do
-	 * struct c2_cons_fom {
-	 *         struct c2_fom cf_fom;
-	 *         struct c2_fop cf_reply;
-	 *         struct c2_cons_fop_reply cf_reply_data;
-	 * };
-	 * Then fom, reply fop and its data packet can be allocated at once,
-	 * simplifying memory management.
-	 */
-        C2_ALLOC_PTR(fom);
-        if (fom == NULL)
-                return -ENOMEM;
-        rep_fop = c2_fop_alloc(&c2_cons_fop_reply_fopt, NULL);
-	if (rep_fop == NULL) {
-		c2_free(fom);
-		return -ENOMEM;
-	}
-
-	c2_fom_create(fom, &fop->f_type->ft_fom_type, &c2_cons_fom_device_ops,
-			fop, rep_fop);
-
-        *m = fom;
-        return 0;
-}
-
-static int cons_fom_state(struct c2_fom *fom)
-{
-        struct c2_cons_fop_reply *reply_fop;
-        struct c2_rpc_item       *reply_item;
-        struct c2_rpc_item       *req_item;
-	struct c2_fop		 *fop = fom->fo_fop;
-	struct c2_fop		 *rfop = fom->fo_rep_fop;
-
-	C2_PRE(fom != NULL && fop != NULL && rfop != NULL);
-
-	/* Reply fop */
-        reply_fop = c2_fop_data(rfop);
-	if (reply_fop == NULL)
-		return -EINVAL;
-
-	/* Request item */
-        req_item = &fop->f_item;
-
-	/* Set repy FOP */
-	reply_fop->cons_notify_type = req_item->ri_type->rit_opcode;
-        reply_fop->cons_return = 0;
-
-	/* Reply item */
-	reply_item = &rfop->f_item;
-	fom->fo_phase = FOPH_FINISH;
-        return c2_rpc_reply_post(req_item, reply_item);
-}
-
-const struct c2_fom_ops c2_cons_fom_device_ops = {
-        .fo_state	  = cons_fom_state,
-	.fo_fini	  = default_fom_fini,
-	.fo_home_locality = home_locality,
-};
-
-static const struct c2_fom_type_ops c2_cons_fom_device_type_ops = {
-        .fto_create = cons_fop_fom_create
-};
-
-struct c2_fom_type c2_cons_fom_device_type = {
-        .ft_ops = &c2_cons_fom_device_type_ops
-};
-
-/** @} end of console */
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
-
diff --git a/console/console_fom.h b/console/console_fom.h
deleted file mode 100644
index cdd4e13..0000000
--- a/console/console_fom.h
+++ /dev/null
@@ -1,51 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Dipak Dudhabhate <Dipak_Dudhabhate@xyratex.com>
- * Original creation date: 08/04/2011
- */
-
-/*
- * Failure fops should be defined by not yet existing "failure" module. For the
- * time being, it makes sense to put them in cm/ or console/. ioservice is not
- * directly responsible for handling failures, it is intersected by copy-machine
- * (cm).
- */
-
-#ifndef __COLIBRI_CONSOLE_FOM_H__
-#define __COLIBRI_CONSOLE_FOM_H__
-
-#include "fop/fop.h" /* c2_fop_ */
-#include "fop/fom.h" /* c2_fom_ */
-
-extern const struct c2_fom_ops c2_cons_fom_disk_ops;
-extern const struct c2_fom_ops c2_cons_fom_device_ops;
-extern struct c2_fom_type c2_cons_fom_disk_type;
-extern struct c2_fom_type c2_cons_fom_device_type;
-
-/* __COLIBRI_CONSOLE_FOM_H__ */
-#endif
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
-
diff --git a/console/console_fop.c b/console/console_fop.c
deleted file mode 100644
index ddd872c..0000000
--- a/console/console_fop.c
+++ /dev/null
@@ -1,117 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Dipak Dudhabhate <dipak_dudhabhate@xyratex.com>
- * Original creation date: 08/03/2011
- */
-/*
- * Failure fops should be defined by not yet existing "failure" module. For the
- * time being, it makes sense to put them in cm/ or console/. ioservice is not
- * directly responsible for handling failures, it is intersected by copy-machine
- * (cm).
- */
-
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif
-
-#include "lib/memory.h"		/* C2_ALLOC_PTR */
-#include "lib/errno.h"		/* ENOMEM */
-#include "fop/fop_item_type.h"	/* default fop encode/decode */
-#include "fop/fop_format_def.h" /* console.ff */
-
-
-#include "console/console_fop.h" /*FOPs defs */
-#include "console/console_fom.h" /*FOMs defs */
-#include "console/console_u.h"	 /* FOP memory layout */
-#include "console/console.ff"
-#include "xcode/bufvec_xcode.h"  /* c2_xcode_fop_size_get() */
-
-/**
-   @addtogroup console fops
-   @{
-*/
-
-/* Ops vector for device failure notification */
-static const struct c2_fop_type_ops c2_cons_fop_device_ops = {
-	.fto_size_get = c2_xcode_fop_size_get
-};
-
-/* Ops vector for reply of any failure notification */
-static const struct c2_fop_type_ops c2_cons_fop_reply_ops = {
-	.fto_size_get = c2_xcode_fop_size_get
-};
-
-/* Fop and RPC Item type definitions for device failures and replies
-   and replies */
-C2_FOP_TYPE_DECLARE(c2_cons_fop_device, "Device Failed",
-		    &c2_cons_fop_device_ops,
-		    C2_CONS_FOP_DEVICE_OPCODE,
-		    C2_RPC_ITEM_TYPE_REQUEST);
-
-C2_FOP_TYPE_DECLARE(c2_cons_fop_reply, "Console Reply",
-		    &c2_cons_fop_reply_ops,
-		    C2_CONS_FOP_REPLY_OPCODE,
-		    C2_RPC_ITEM_TYPE_REPLY);
-
-C2_FOP_TYPE_DECLARE(c2_cons_fop_test, "Console Test", NULL, C2_CONS_TEST, 0);
-
-static struct c2_fop_type *fops[] = {
-        &c2_cons_fop_device_fopt,
-        &c2_cons_fop_reply_fopt,
-        &c2_cons_fop_test_fopt
-};
-
-static struct c2_fop_type_format *fmts[] = {
-	&c2_cons_fop_fid_tfmt,
-	&c2_cons_fop_buf_tfmt,
-};
-
-void c2_console_fop_fini(void)
-{
-        c2_fop_type_fini_nr(fops, ARRAY_SIZE(fops));
-	c2_fop_type_format_fini_nr(fmts, ARRAY_SIZE(fmts));
-}
-
-int c2_console_fop_init(void)
-{
-        int result;
-
-
-	result = c2_fop_type_format_parse_nr(fmts, ARRAY_SIZE(fmts));
-	if (result == 0)
-		result = c2_fop_type_build_nr(fops, ARRAY_SIZE(fops));
-
-	/* Initialize fom type once */
-	c2_cons_fop_device_fopt.ft_fom_type = c2_cons_fom_device_type;
-
-	if (result != 0)
-		c2_console_fop_fini();
-
-        return result;
-}
-
-/** @} end of console */
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
-
diff --git a/console/console_fop.h b/console/console_fop.h
deleted file mode 100644
index cd46248..0000000
--- a/console/console_fop.h
+++ /dev/null
@@ -1,68 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Dipak Dudhabhate <dipak_dudhabhate@xyratex.com>
- * Original creation date: 08/03/2011
- */
-/*
- * Failure fops should be defined by not yet existing "failure" module. For the
- * time being, it makes sense to put them in cm/ or console/. ioservice is not
- * directly responsible for handling failures, it is intersected by copy-machine
- * (cm).
- */
-
-#ifndef __COLIBRI_CONSOLE_FOP_H__
-#define __COLIBRI_CONSOLE_FOP_H__
-
-#include "fop/fop.h"
-#include "rpc/rpc_opcodes.h"
-
-/**
- * Init console FOP
- */
-int c2_console_fop_init(void);
-/**
- * Fini console FOP
- */
-void c2_console_fop_fini(void);
-
-
-/**
- * FOP definitions and corresponding fop type formats
- */
-extern struct c2_fop_type_format c2_cons_fop_disk_tfmt;
-extern struct c2_fop_type_format c2_cons_fop_device_tfmt;
-extern struct c2_fop_type_format c2_cons_fop_reply_tfmt;
-extern struct c2_fop_type_format c2_cons_fop_test_tfmt;
-
-extern struct c2_fop_type c2_cons_fop_disk_fopt;
-extern struct c2_fop_type c2_cons_fop_device_fopt;
-extern struct c2_fop_type c2_cons_fop_reply_fopt;
-extern struct c2_fop_type c2_cons_fop_test_fopt;
-
-/* __COLIBRI_CONSOLE_FOP_H__ */
-#endif
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
-
diff --git a/console/console_it.c b/console/console_it.c
deleted file mode 100644
index 6c20d01..0000000
--- a/console/console_it.c
+++ /dev/null
@@ -1,416 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Dipak Dudhabhate <dipak_dudhabhate@xyratex.com>
- * Original creation date: 08/17/2011
- */
-#ifdef HAVE_CONFIG_H
-#  include <config.h>
-#endif
-
-#include "lib/memory.h"		  /* C2_ALLOC_ARR */
-#include "fop/fop.h"		  /* c2_fop */
-
-#include "console/console.h"	  /* verbose */
-#include "console/console_it.h"	  /* c2_fit */
-#include "console/console_yaml.h" /* c2_cons_yaml_get_value */
-#include "console/console_u.h"
-/**
-   @addtogroup console_it
-   @{
- */
-
-static struct c2_cons_atom_ops atom_ops[FPF_NR];
-static struct c2_cons_aggr_ops aggr_ops[FFA_NR];
-
-static void depth_print(int depth)
-{
-	static const char ruler[] = "\t\t\t\t\t.....\t";
-	printf("%*.*s", depth, depth, ruler);
-}
-
-static void default_show(const struct c2_fop_field_type *ftype,
-		     const char *name, void *data)
-{
-	printf("%s:%s\n", name, ftype->fft_name);
-}
-
-
-static void void_get(const struct c2_fop_field_type *ftype,
-		     const char *name, void *data)
-{
-}
-
-static void void_set(const struct c2_fop_field_type *ftype,
-		     const char *name, void *data)
-{
-}
-
-static void byte_get(const struct c2_fop_field_type *ftype,
-		     const char *name, void *data)
-{
-	char value = *(char *)data;
-
-	if (verbose)
-		printf("%s(%s) = %c\n", name, ftype->fft_name, value);
-}
-
-static void byte_set(const struct c2_fop_field_type *ftype,
-		     const char *name, void *data)
-{
-	void *tmp_value;
-	char value;
-
-	if (yaml_support) {
-		tmp_value = c2_cons_yaml_get_value(name);
-		C2_ASSERT(tmp_value != NULL);
-		*(char *)data = *(char *)tmp_value;
-		if (verbose)
-			printf("%s(%s) = %c\n", name, ftype->fft_name,
-						  *(char *)data);
-	} else {
-		printf("%s(%s) = ", name, ftype->fft_name);
-		scanf("\r%c", &value);
-		*(char *)data = value;
-	}
-}
-
-
-static void u32_get(const struct c2_fop_field_type *ftype,
-		    const char *name, void *data)
-{
-	uint32_t value = *(uint32_t *)data;
-
-	if (verbose)
-		printf("%s(%s) = %d\n", name, ftype->fft_name, value);
-}
-
-static void u32_set(const struct c2_fop_field_type *ftype,
-		    const char *name, void *data)
-{
-	uint32_t  value;
-	void	 *tmp_value;
-
-	if (yaml_support) {
-		tmp_value = c2_cons_yaml_get_value(name);
-		C2_ASSERT(tmp_value != NULL);
-		*(uint32_t *)data = atoi((const char *)tmp_value);
-		if (verbose)
-			printf("%s(%s) = %u\n", name, ftype->fft_name,
-						  *(uint32_t *)data);
-	} else {
-		printf("%s(%s) = ", name, ftype->fft_name);
-		scanf("%u", &value);
-		*(uint32_t *)data = value;
-	}
-}
-
-static void u64_get(const struct c2_fop_field_type *ftype,
-		    const char *name, void *data)
-{
-	uint64_t value = *(uint64_t *)data;
-
-	if (verbose)
-		printf("%s(%s) = %ld\n", name, ftype->fft_name, value);
-}
-
-static void u64_set(const struct c2_fop_field_type *ftype,
-		    const char *name, void *data)
-{
-	void *tmp_value;
-	uint64_t value;
-
-	if (yaml_support) {
-		tmp_value = c2_cons_yaml_get_value(name);
-		C2_ASSERT(tmp_value != NULL);
-		*(uint64_t *)data = atol((const char *)tmp_value);
-		if (verbose)
-			printf("%s(%s) = %ld\n", name, ftype->fft_name,
-						   *(uint64_t *)data);
-	} else {
-		printf("%s(%s) = ", name, ftype->fft_name);
-		scanf("%lu", &value);
-		*(uint64_t *)data = value;
-	}
-}
-
-
-/**
- * @brief Methods to hadle U64, U32, etc.
- */
-static struct c2_cons_atom_ops atom_ops[FPF_NR] = {
-        [FPF_VOID] = { void_get, void_set, default_show },
-        [FPF_BYTE] = { byte_get, byte_set, default_show },
-        [FPF_U32]  = { u32_get, u32_set, default_show },
-        [FPF_U64]  = { u64_get, u64_set, default_show }
-};
-
-static void record_process(const struct c2_fop_field_type *ftype,
-			   const char *name, void *data,
-			   enum c2_cons_data_process_type type,
-			   int depth)
-{
-	struct c2_fop_field	 *child;
-        struct c2_fop_field_type *cftype;
-        enum c2_fop_field_aggr    cgtype;
-	int			  i;
-	enum c2_fop_field_primitive_type atype;
-
-	for (i = 0; i < ftype->fft_nr; i++) {
-		child = ftype->fft_child[i];
-		cftype = child->ff_type;
-		cgtype = cftype->fft_aggr;
-		if (cgtype != FFA_ATOM && verbose) {
-			++depth;
-			depth_print(depth);
-			printf("%s:%s {\n", child->ff_name,
-					    child->ff_type->fft_name);
-		}
-		aggr_ops[cgtype].caggr_val_process(cftype, child->ff_name,
-						   data, type, depth);
-		if (cgtype != FFA_ATOM && verbose) {
-			depth_print(depth);
-			printf("}\n");
-			--depth;
-		}
-		atype = cftype->fft_u.u_atom.a_type;
-
-		switch (atype) {
-		case FPF_NR:
-		case FPF_VOID:
-			break;
-		case FPF_BYTE:
-			data = data + sizeof(char);
-			break;
-		case FPF_U32:
-			data = data + sizeof(uint32_t);
-			break;
-		case FPF_U64:
-			data = data + sizeof(uint64_t);
-			break;
-		}
-	}
-}
-
-static void union_process(const struct c2_fop_field_type *ftype,
-			  const char *name, void *data,
-			  enum c2_cons_data_process_type type,
-			  int depth)
-{
-	struct c2_fop_field	 *child;
-        struct c2_fop_field_type *cftype;
-        enum c2_fop_field_aggr    cgtype;
-
-	child = ftype->fft_child[0];
-	cftype = child->ff_type;
-	cgtype = cftype->fft_aggr;
-	aggr_ops[cgtype].caggr_val_process(cftype, child->ff_name,
-					   data, type, depth);
-}
-
-static void byte_pointer_process(const struct c2_fop_field *child, void *data,
-				 enum c2_cons_data_process_type type, int depth)
-{
-	struct c2_cons_fop_buf	*buf;
-	void			*tmp_value;
-
-	++depth;
-	depth_print(depth);
-	buf = (struct c2_cons_fop_buf *)data;
-	if (type == CONS_IT_OUTPUT) {
-		printf("%s(%s) = %s\n", child->ff_name,
-					  child->ff_type->fft_name, buf->cons_buf);
-	} else {
-		C2_ALLOC_ARR(buf->cons_buf, buf->cons_size);
-		C2_ASSERT(buf->cons_buf != NULL);
-		if (yaml_support) {
-			tmp_value = c2_cons_yaml_get_value(child->ff_name);
-			C2_ASSERT(tmp_value != NULL);
-			memcpy(buf->cons_buf, tmp_value, buf->cons_size);
-			if (verbose)
-				printf("%s(%s) = %s", child->ff_name,
-						      child->ff_type->fft_name,
-						      buf->cons_buf);
-		} else {
-			printf("%s(%s) = ", child->ff_name,
-					    child->ff_type->fft_name);
-			scanf("%s", buf->cons_buf);
-		}
-	}
-	--depth;
-}
-
-static void sequence_process(const struct c2_fop_field_type *ftype,
-			     const char *name, void *data,
-			     enum c2_cons_data_process_type type,
-			     int depth)
-{
-	struct c2_fop_field		 *child;
-        struct c2_fop_field_type	 *cftype;
-        enum c2_fop_field_aggr		  cgtype;
-	enum c2_fop_field_primitive_type  atype;
-
-	child = ftype->fft_child[0];
-	cftype = child->ff_type;
-	cgtype = cftype->fft_aggr;
-	aggr_ops[cgtype].caggr_val_process(cftype, child->ff_name,
-					   data, type, depth);
-	child = ftype->fft_child[1];
-	cftype = child->ff_type;
-	cgtype = cftype->fft_aggr;
-	atype = cftype->fft_u.u_atom.a_type;
-	if (cgtype == FFA_ATOM && atype == FPF_BYTE && type != CONS_IT_SHOW)
-		byte_pointer_process(child, data, type, depth);
-	else {
-		data = data + sizeof(uint32_t);
-		if (cgtype != FFA_ATOM && verbose) {
-			++depth;
-			depth_print(depth);
-			printf("%s:%s {\n", child->ff_name,
-					    child->ff_type->fft_name);
-		}
-		aggr_ops[cgtype].caggr_val_process(cftype, child->ff_name,
-						   data, type, depth);
-		if (cgtype != FFA_ATOM && verbose) {
-			depth_print(depth);
-			printf("}\n");
-			--depth;
-		}
-	}
-}
-
-static void typedef_process(const struct c2_fop_field_type *ftype,
-			    const char *name, void *data,
-			    enum c2_cons_data_process_type type,
-			    int depth)
-{
-}
-
-static void atom_process(const struct c2_fop_field_type *ftype,
-			 const char *name, void *data,
-			 enum c2_cons_data_process_type type,
-			 int depth)
-{
-	enum c2_fop_field_primitive_type  atype;
-
-	++depth;
-	depth_print(depth);
-	atype = ftype->fft_u.u_atom.a_type;
-	switch (type) {
-	case CONS_IT_INPUT:
-		atom_ops[atype].catom_val_set(ftype, name, data);
-		break;
-	case CONS_IT_OUTPUT:
-		atom_ops[atype].catom_val_get(ftype, name, data);
-		break;
-	case CONS_IT_SHOW:
-	default:
-		atom_ops[atype].catom_val_show(ftype, name, data);
-	}
-	--depth;
-}
-
-/**
- * @brief Methods to handle RECORD, SEQUENCE, etc.
- */
-static struct c2_cons_aggr_ops aggr_ops[FFA_NR] = {
-        [FFA_RECORD]   = { record_process   },
-        [FFA_UNION]    = { union_process    },
-        [FFA_SEQUENCE] = { sequence_process },
-        [FFA_TYPEDEF]  = { typedef_process  },
-        [FFA_ATOM]     = { atom_process     }
-};
-
-void c2_cons_fop_obj_input_output(struct c2_fit *it,
-				  enum c2_cons_data_process_type type)
-{
-        struct c2_fit_yield	   yield;
-	struct c2_fop_field	  *field;
-	struct c2_fop_field_type  *ftype;
-	struct c2_fop_type_format *fop_format;
-	enum c2_fop_field_aggr     gtype;
-	int			   fop_depth;
-
-	fop_depth = 0;
-	fop_format = it->fi_fop->f_type->ft_fmt;
-	C2_ASSERT(fop_format != NULL);
-	if (verbose)
-		printf("\n%s {\n", fop_format->ftf_name);
-        while(c2_fit_yield(it, &yield) > 0) {
-		field = yield.fy_val.ffi_field;
-		ftype = field->ff_type;
-		gtype = ftype->fft_aggr;
-		if (gtype != FFA_ATOM && verbose) {
-			++fop_depth;
-			depth_print(fop_depth);
-			printf("%s:%s {\n", field->ff_name,
-					    field->ff_type->fft_name);
-		}
-		aggr_ops[gtype].caggr_val_process(ftype, field->ff_name,
-						  yield.fy_val.ffi_val,
-						  type, fop_depth);
-		if (gtype != FFA_ATOM && verbose) {
-			depth_print(fop_depth);
-			printf("}\n");
-			--fop_depth;
-		}
-        }
-	if (verbose)
-		printf("}\n");
-}
-
-void c2_cons_fop_obj_input(struct c2_fop *fop)
-{
-	struct c2_fit it;
-
-	/* FOP iterator will prompt for each field in fop. */
-	c2_fop_all_object_it_init(&it, fop);
-	c2_cons_fop_obj_input_output(&it, CONS_IT_INPUT);
-	c2_fop_all_object_it_fini(&it);
-}
-
-void c2_cons_fop_obj_output(struct c2_fop *fop)
-{
-	struct c2_fit it;
-
-	c2_fop_all_object_it_init(&it, fop);
-	c2_cons_fop_obj_input_output(&it, CONS_IT_OUTPUT);
-	c2_fop_all_object_it_fini(&it);
-}
-
-void c2_cons_fop_fields_show(struct c2_fop *fop)
-{
-	struct c2_fit it;
-
-	verbose = true;
-	c2_fop_all_object_it_init(&it, fop);
-	c2_cons_fop_obj_input_output(&it, CONS_IT_SHOW);
-	c2_fop_all_object_it_fini(&it);
-	verbose = false;
-}
-
-/** @} end of console_it group */
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
-
diff --git a/console/console_it.h b/console/console_it.h
deleted file mode 100644
index 9a2fb4e..0000000
--- a/console/console_it.h
+++ /dev/null
@@ -1,110 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Dipak Dudhabhate <dipak_dudhabhate@xyratex.com>
- * Original creation date: 08/17/2011
- */
-
-#ifndef __COLIBRI_CONSOLE_IT_H__
-#define __COLIBRI_CONSOLE_IT_H__
-
-#ifdef HAVE_CONFIG_H
-#  include <config.h>
-#endif
-
-#include "fop/fop_iterator.h"	/* c2_fit */
-#include "fop/fop_base.h"	/* c2_fop_field_type */
-
-/**
-   @addtogroup console console iterator
-   @{
- */
-
-enum c2_cons_data_process_type {
-	CONS_IT_INPUT,
-	CONS_IT_OUTPUT,
-	CONS_IT_SHOW
-};
-
-/**
- * @struct c2_cons_atom_ops
- * @brief operation to get/set values of ATOM type (i.e. CHAR, U64 etc).
- */
-struct c2_cons_atom_ops {
-	void (*catom_val_get)(const struct c2_fop_field_type *ftype,
-			      const char *name, void *data);
-	void (*catom_val_set)(const struct c2_fop_field_type *ftype,
-			      const char *name, void *data);
-	void (*catom_val_show)(const struct c2_fop_field_type *ftype,
-			       const char *name, void *data);
-};
-
-/**
- * @struct c2_cons_atom_ops
- * @brief Operation to get/set values of UNION, SEQUENCE, etc.
- */
-struct c2_cons_aggr_ops {
-	void (*caggr_val_process)(const struct c2_fop_field_type *ftype,
-				  const char *name, void *data,
-				  enum c2_cons_data_process_type type,
-				  int depth);
-};
-
-/**
- * @brief Iterate over FOP fields and prints the names.
- *
- * @param it Iterator ref.
- */
-void c2_cons_fop_fields_show(struct c2_fop *fop);
-
-/**
- * @brief Iterate over FOP for Input and output.
- *
- * @param it   Iterator ref.
- * @param output false input, true output.
- */
-void c2_cons_fop_obj_input_output(struct c2_fit *it,
-				  enum c2_cons_data_process_type type);
-
-/**
- * @brief Helper function for FOP input
- *
- * @param it Iterator ref.
- */
-void c2_cons_fop_obj_input(struct c2_fop *fop);
-
-/**
- * @brief Helper function for FOP output.
- *
- * @param it Iterator ref.
- */
-void c2_cons_fop_obj_output(struct c2_fop *fop);
-
-/** @} end of console_it */
-
-/* __COLIBRI_CONSOLE_IT_H__ */
-#endif
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
-
diff --git a/console/console_mesg.c b/console/console_mesg.c
deleted file mode 100644
index ed63acf..0000000
--- a/console/console_mesg.c
+++ /dev/null
@@ -1,131 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Dipak Dudhabhate <dipak_dudhabhate@xyratex.com>
- * Original creation date: 09/09/2011
- */
-#ifdef HAVE_CONFIG_H
-#  include <config.h>
-#endif
-
-#include "lib/errno.h" /* ENOTSUP */
-
-#include "console/console_fop.h"
-#include "console/console_it.h"
-#include "console/console_mesg.h"
-
-void c2_cons_fop_name_print(const struct c2_fop_type *ftype)
-{
-	fprintf(stdout, "%.2d, %s", ftype->ft_rpc_item_type.rit_opcode,
-				    ftype->ft_name);
-}
-
-int c2_cons_fop_send(struct c2_fop *fop, struct c2_rpc_session *session,
-		     c2_time_t deadline)
-{
-	struct c2_rpc_item *item;
-	struct c2_clink	    clink;
-	int		    rc = 0;
-	bool		    wait;
-
-	C2_PRE(fop != NULL && session != NULL);
-
-	/* Init rpc item and assign priority, session, etc */
-	item = &fop->f_item;
-	/* Add link to wait for item reply */
-	c2_clink_init(&clink, NULL);
-	c2_clink_add(&item->ri_chan, &clink);
-	item->ri_deadline = 0;
-	item->ri_prio     = C2_RPC_ITEM_PRIO_MAX;
-	item->ri_group    = NULL;
-	item->ri_session  = session;
-	item->ri_error    = 0;
-        rc = c2_rpc_post(item);
-	if (rc != 0) {
-		fprintf(stderr, "c2_rpc_post failed!\n");
-		goto error;
-	}
-
-	/* Wait for reply */
-	wait = c2_chan_timedwait(&clink, deadline);
-	if (!wait) {
-		fprintf(stderr, "Timed out for reply.\n");
-		rc = -ETIMEDOUT;
-	}
-error:
-	/* Fini clink */
-	c2_clink_del(&clink);
-	c2_clink_fini(&clink);
-
-	return rc;
-}
-
-int c2_cons_fop_show(struct c2_fop_type *fopt)
-{
-	struct c2_fop *fop;
-	void	      *fdata;
-
-	fop = c2_fop_alloc(fopt, NULL);
-	if (fop != NULL) {
-		fdata = c2_fop_data(fop);
-		if (fdata != NULL) {
-			c2_cons_fop_fields_show(fop);
-			c2_fop_free(fop);
-		} else {
-			fprintf(stderr, "FOP data does not exist\n");
-			return -EINVAL;
-		}
-	} else {
-		fprintf(stderr, "FOP allocation failed\n");
-		return -EINVAL;
-	}
-	return 0;
-}
-
-void c2_cons_fop_list_show(void)
-{
-        struct c2_fop_type *ftype;
-
-	fprintf(stdout, "List of FOP's: \n");
-	ftype = NULL;
-	while ((ftype = c2_fop_type_next(ftype)) != NULL) {
-		c2_cons_fop_name_print(ftype);
-		fprintf(stdout, "\n");
-	}
-}
-
-struct c2_fop_type *c2_cons_fop_type_find(uint32_t opcode)
-{
-        struct c2_fop_type *ftype;
-
-	ftype = NULL;
-	while ((ftype = c2_fop_type_next(ftype)) != NULL) {
-		if(ftype->ft_rpc_item_type.rit_opcode == opcode)
-			break;
-	}
-	return ftype;
-}
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
-
diff --git a/console/console_mesg.h b/console/console_mesg.h
deleted file mode 100644
index 2f1d7d1..0000000
--- a/console/console_mesg.h
+++ /dev/null
@@ -1,75 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Dipak Dudhabhate <dipak_dudhabhate@xyratex.com>
- * Original creation date: 09/09/2011
- */
-
-#ifndef __COLIBRI_CONSOLE_MESG_H__
-#define __COLIBRI_CONSOLE_MESG_H__
-
-#include "fop/fop.h"
-#include "rpc/rpc2.h"
-#include "rpc/session.h"
-
-/**
- *  Prints name and opcode of FOP.
- *  It can be used to print more info if required.
- */
-void c2_cons_fop_name_print(const struct c2_fop_type *ftype);
-
-/**
- * @brief Builds and send FOP using rpc_post and waits for reply.
- *
- * @param ftype	   FOP to be send.
- * @param session  RPC connection session.
- * @param deadline Time to to wait for RPC reply.
- */
-int c2_cons_fop_send(struct c2_fop *fop, struct c2_rpc_session *session,
-		     c2_time_t deadline);
-
-/**
- *  @brief Iterate over FOP fields and print names.
- */
-int c2_cons_fop_show(struct c2_fop_type *fopt);
-
-/**
- * @brief Helper function to print list of FOPs.
- */
-void c2_cons_fop_list_show(void);
-
-/**
- * @brief Find the fop type equals to @opcode and returns.
- *
- * @param opcode FOP opcode.
- *
- * @return c2_fop_type ref. or NULL
- */
-struct c2_fop_type *c2_cons_fop_type_find(uint32_t opcode);
-
-/* __COLIBRI_CONSOLE_MESG_H__ */
-#endif
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
-
diff --git a/console/console_yaml.c b/console/console_yaml.c
deleted file mode 100644
index 0267149..0000000
--- a/console/console_yaml.c
+++ /dev/null
@@ -1,216 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Dipak Dudhabhate <dipak_dudhabhate@xyratex.com>
- * Original creation date: 22/03/2011
- */
-#ifdef HAVE_CONFIG_H
-#  include <config.h>
-#endif
-
-#include "lib/errno.h"
-#include "lib/ut.h"
-#include "lib/cdefs.h"
-#include "lib/memory.h"
-
-#include <console/console_yaml.h>
-
-/**
-   @addtogroup console_yaml
-   @{
-*/
-
-static struct c2_cons_yaml_info yaml_info;
-
-/**
- * @brief Function to detect and print parsing errors.
- *
- * @param parser YAML parser ref.
- */
-static void yaml_parser_error_detect(yaml_parser_t *parser)
-{
-        C2_PRE(parser != NULL);
-
-        switch (parser->error) {
-        case YAML_MEMORY_ERROR:
-                fprintf(stderr, "Memory error: Not enough memory for parsing\n");
-                break;
-        case YAML_READER_ERROR:
-                if (parser->problem_value != -1) {
-                        fprintf(stderr, "Reader error: %s: #%X at %lu\n",
-                                parser->problem, parser->problem_value,
-                                parser->problem_offset);
-                }
-                else {
-                        fprintf(stderr, "Reader error: %s at %lu\n",
-                                        parser->problem, parser->problem_offset);
-                }
-                break;
-        case YAML_SCANNER_ERROR:
-                if (parser->context) {
-                        fprintf(stderr, "Scanner error: %s at line %lu,\
-                                column %lu""%s at line %lu, column %lu\n",
-                                parser->context, parser->context_mark.line+1,
-                                parser->context_mark.column+1, parser->problem,
-                                parser->problem_mark.line+1,
-                                parser->problem_mark.column+1);
-                } else {
-                        fprintf(stderr, "Scanner error: %s at line %lu,\
-                                column %lu\n", parser->problem,
-                                parser->problem_mark.line+1,
-                                parser->problem_mark.column+1);
-                }
-                break;
-        case YAML_PARSER_ERROR:
-                if (parser->context) {
-                        fprintf(stderr, "Parser error: %s at line %lu,\
-                                column %lu""%s at line %lu, column %lu\n",
-                                parser->context, parser->context_mark.line+1,
-                                parser->context_mark.column+1,parser->problem,
-                                parser->problem_mark.line+1,
-                                parser->problem_mark.column+1);
-                } else {
-                        fprintf(stderr, "Parser error: %s at line %lu,\
-                                column %lu\n", parser->problem,
-                                parser->problem_mark.line+1,
-                                parser->problem_mark.column+1);
-                }
-                break;
-        case YAML_COMPOSER_ERROR:
-        case YAML_WRITER_ERROR:
-        case YAML_EMITTER_ERROR:
-        case YAML_NO_ERROR:
-                break;
-        default:
-                C2_IMPOSSIBLE("Invalid error");
-        }
-}
-
-int c2_cons_yaml_init(const char *file_path)
-{
-	int          rc;
-	yaml_node_t *root_node;
-
-	C2_PRE(file_path != NULL);
-
-	yaml_info.cyi_file = fopen(file_path, "r");
-
-	if(yaml_info.cyi_file == NULL) {
-		perror("Failed to open file ");
-		printf("%s, errno = %d\n", file_path, errno);
-		goto error;
-	}
-	/* Initialize parser */
-	rc = yaml_parser_initialize(&yaml_info.cyi_parser);
-	if(rc != 1) {
-		fprintf(stderr, "Failed to initialize parser!\n");
-		fclose(yaml_info.cyi_file);
-		goto error;
-	}
-
-	/* Set input file */
-	yaml_parser_set_input_file(&yaml_info.cyi_parser, yaml_info.cyi_file);
-
-	/* Load document */
-	rc = yaml_parser_load(&yaml_info.cyi_parser, &yaml_info.cyi_document);
-        if (rc != 1) {
-		yaml_parser_delete(&yaml_info.cyi_parser);
-		fclose(yaml_info.cyi_file);
-		fprintf(stderr, "yaml parser load failed!!\n");
-		goto error;
-	}
-
-	root_node = yaml_document_get_root_node(&yaml_info.cyi_document);
-        if (root_node == NULL) {
-                yaml_document_delete(&yaml_info.cyi_document);
-		fclose(yaml_info.cyi_file);
-                fprintf(stderr, "document get root node failed\n");
-		goto error;
-        }
-
-	yaml_info.cyi_current = yaml_info.cyi_document.nodes.start;
-	yaml_support = true;
-
-	return 0;
-error:
-	yaml_parser_error_detect(&yaml_info.cyi_parser);
-	return -EINVAL;
-}
-
-void c2_cons_yaml_fini(void)
-{
-	yaml_support = false;
-	yaml_parser_delete(&yaml_info.cyi_parser);
-	fclose(yaml_info.cyi_file);
-}
-
-static yaml_node_t *search_node(const char *name)
-{
-	yaml_document_t *doc   = &yaml_info.cyi_document;
-	yaml_node_t     *node  = yaml_info.cyi_current;
-        bool             found = false;
-	unsigned char   *data_value;
-
-        for ( ; node < doc->nodes.top; node++) {
-                if(node->type == YAML_SCALAR_NODE) {
-			data_value = node->data.scalar.value;
-                        if (strcmp((const char *)data_value, name) == 0){
-				node++;
-				found = true;
-                        }
-                }
-		if (found) {
-			yaml_info.cyi_current = node;
-			break;
-		}
-        }
-
-	if (!found)
-		node = NULL;
-
-	return node;
-}
-
-void *c2_cons_yaml_get_value(const char *name)
-{
-	yaml_node_t *node;
-
-	node = search_node(name);
-	if (node == NULL)
-		return NULL;
-
-	return node->data.scalar.value;
-}
-
-int c2_cons_yaml_set_value(const char *name, void *data)
-{
-	int rc = -ENOTSUP;
-
-	return rc;
-}
-
-/** @} end of console_yaml group */
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
-
diff --git a/console/console_yaml.h b/console/console_yaml.h
deleted file mode 100644
index 30c1fb5..0000000
--- a/console/console_yaml.h
+++ /dev/null
@@ -1,102 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Dipak Dudhabhate <dipak_dudhabhate@xyratex.com>
- * Original creation date: 22/03/2011
- */
-#ifndef __COLIBRI_CONSOLE_YAML_H__
-#define __COLIBRI_CONSOLE_YAML_H__
-
-#ifdef HAVE_CONFIG_H
-#  include <config.h>
-#endif
-
-#include <yaml.h>
-
-/**
-   @addtogroup console_yaml
-   @{
-*/
-
-/** enable/disable yaml support */
-bool yaml_support;
-
-/**
- * @brief Keeps info for YAML parser.
- */
-struct c2_cons_yaml_info {
-        /** YAML parser structure */
-        yaml_parser_t    cyi_parser;
-        /** YAML event structure */
-        yaml_event_t     cyi_event;
-        /** YAML document structure */
-        yaml_document_t  cyi_document;
-        /** Current Node in document */
-	yaml_node_t	*cyi_current;
-        /** YAML file pointer */
-        FILE            *cyi_file;
-};
-
-/**
- * @brief Inititalizes parser by opening given file.
- *	  and also checks for error by getting root node.
- *
- * @param path YAML file path.
- *
- * @return 0 success and -errno failure.
- */
-int c2_cons_yaml_init(const char *path);
-
-/**
- * @brief  Search for specified string and get the respctive value
- *	   form YAML file. (like "name : console")
- *
- * @param value Search string(like name).
- * @param data  Respective data(like console).
- *
- * @return 0 success and -errno failure.
- */
-int c2_cons_yaml_set_value(const char *value, void *data);
-
-/**
- * @brief  Search for specified string and set the respctive value
- *	   form YAML file. (like "name : console")
- *
- * @param value Search string(like name).
- * @param data  Respective data(like console).
- *
- * @return 0 success and -errno failure.
- */
-void *c2_cons_yaml_get_value(const char *value);
-
-/**
- * @brief Deletes the parser and closes the YAML file.
- */
-void c2_cons_yaml_fini(void);
-
-/** @} end of console_yaml group */
-/* __COLIBRI_CONSOLE_YAML_H__ */
-#endif
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
-
diff --git a/console/main.c b/console/main.c
deleted file mode 100644
index e1250e9..0000000
--- a/console/main.c
+++ /dev/null
@@ -1,355 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Dipak Dudhabhate <dipak_dudhabhate@xyratex.com>
- * Original creation date: 08/03/2011
- */
-#ifdef HAVE_CONFIG_H
-#  include <config.h>
-#endif
-
-#include <sysexits.h>
-
-#include "lib/errno.h"		  /* ETIMEDOUT */
-#include "net/bulk_sunrpc.h"	  /* bulk transport */
-#include "colibri/init.h"	  /* c2_init */
-#include "lib/processor.h"        /* c2_processors_init/fini */
-#include "lib/getopts.h"	  /* C2_GETOPTS */
-#include "rpc/rpclib.h"
-#include "ut/rpc.h"
-
-#include "console/console.h"
-#include "console/console_mesg.h"
-#include "console/console_it.h"
-#include "console/console_yaml.h"
-#include "console/console_fop.h"
-
-/**
-   @addtogroup console main
-   @{
- */
-
-uint32_t timeout;
-
-/**
- * @brief Iterator over FOP and prints names of its members.
- *
- * @param type 0 shows list of FOPS.
- *	       ~0 displays info related to FOP.
- */
-static int fop_info_show(uint32_t opcode)
-{
-	struct c2_fop_type *ftype;
-
-	fprintf(stdout, "\n");
-	ftype = c2_cons_fop_type_find(opcode);
-	if (ftype == NULL) {
-		fprintf(stderr, "Invalid FOP opcode %.2d.\n", opcode);
-		return -EINVAL;
-	}
-	c2_cons_fop_name_print(ftype);
-	fprintf(stdout, "\n");
-	return c2_cons_fop_show(ftype);
-}
-
-/**
- * @brief Build the RPC item using FOP(Embedded into item) and send it.
- *
- * @param cons Console object ref.
- * @param opcode FOP opcode.
- */
-static int fop_send_and_print(struct c2_rpc_client_ctx *cctx, uint32_t opcode)
-{
-	struct c2_fop_type *ftype;
-	struct c2_rpc_item *item;
-	struct c2_fop	   *fop;
-	struct c2_fop	   *rfop;
-	int		    rc;
-
-	ftype = c2_cons_fop_type_find(opcode);
-	if (ftype == NULL)
-		return -EINVAL;
-
-	/* Allocate fop */
-	fop = c2_fop_alloc(ftype, NULL);
-	if (fop == NULL)
-		return -EINVAL;
-
-	fprintf(stdout, "\nSending message for ");
-	c2_cons_fop_name_print(ftype);
-	c2_cons_fop_obj_input(fop);
-	rc = c2_rpc_client_call(fop, &cctx->rcx_session,
-				&c2_fop_default_item_ops, timeout);
-	if (rc != 0) {
-		fprintf(stderr, "Sending message failed!\n");
-		return -EINVAL;
-	}
-
-	/* Fetch the FOP reply */
-	item = &fop->f_item;
-        if (item->ri_error != 0) {
-		fprintf(stderr, "rpc item receive failed.\n");
-		return -EINVAL;
-	}
-
-	rfop = c2_rpc_item_to_fop(item->ri_reply);
-	if(rfop == NULL) {
-		fprintf(stderr, "RPC item reply not received.\n");
-		return -EINVAL;
-	}
-
-	/* Print reply */
-	fprintf(stdout, "Print reply FOP: \n");
-	c2_cons_fop_obj_output(rfop);
-
-	return 0;
-}
-
-const char *usage_msg =	"Usage: c2console "
-			" { -l FOP list | -f FOP opcode }"
-			" [-s server (e.g. 127.0.0.1:1024:1) ]"
-			" [-c client (e.g. 127.0.0.1:1025:1) ]"
-			" [-t timeout]"
-			" [[-i] [-y yaml file path]]"
-			" [-h] [-v]";
-
-static void usage(void)
-{
-	fprintf(stderr, "%s\n", usage_msg);
-}
-
-extern struct c2_net_xprt c2_net_bulk_sunrpc_xprt;
-
-/**
- * @brief The service to connect to is specified at the command line.
- *
- *	  The fop type to be sent is specified at the command line.
- *
- *	  The values of fop fields are specified interactively. The program
- *	  locates the fop type format (c2_fop_type_format) corresponding to the
- *	  specified fop type and iterates over fop fields, prompting the user
- *	  for the field values.
- *
- *	  Fop iterator code should be used. The program should support RECORD,
- *	  SEQUENCE and UNION aggregation types, as well as all atomic types
- *	  (U32, U64, BYTE and VOID).
- *
- *	  Usage:
- *	  c2console :	{ -l FOP list | -f FOP opcode }
- *			[-s server (e.g. 127.0.0.1:1024:1) ]
- *			[-c client (e.g. 127.0.0.1:1025:1) ] 
- *			[-t timeout] [[-i] [-y yaml file path]] [-v]
- *
- * @return 0 success, -errno failure.
- */
-#ifdef CONSOLE_UT
-int console_main(int argc, char **argv)
-#else
-int main(int argc, char **argv)
-#endif
-{
-	int         result;
-	uint32_t    opcode     = 0;
-	bool        show       = false;
-	bool        input      = false;
-	const char  *server    = NULL;
-	const char  *client    = NULL;
-	const char  *yaml_path = NULL;
-
-	struct c2_net_xprt    *xprt = &c2_net_bulk_sunrpc_xprt;
-	struct c2_net_domain  client_net_dom = { };
-	struct c2_dbenv       client_dbenv;
-	struct c2_cob_domain  client_cob_dom;
-
-	struct c2_rpc_client_ctx cctx = {
-		.rcx_net_dom            = &client_net_dom,
-		.rcx_local_addr         = "127.0.0.1:123456:1",
-		.rcx_remote_addr        = "127.0.0.1:123457:1",
-		.rcx_db_name            = "cons_client_db",
-		.rcx_dbenv              = &client_dbenv,
-		.rcx_cob_dom_id         = 14,
-		.rcx_cob_dom            = &client_cob_dom,
-		.rcx_nr_slots           = 1,
-		.rcx_timeout_s          = 5,
-		.rcx_max_rpcs_in_flight = 1,
-	};
-
-	verbose = false;
-	yaml_support = false;
-	timeout = 10;
-
-	/*
-	 * Gets the info to connect to the service and type of fop to be send.
-	 */
-	result = C2_GETOPTS("c2console", argc, argv,
-			    C2_HELPARG('h'),
-			    C2_FLAGARG('l', "show list of fops", &show),
-			    C2_FORMATARG('f', "fop type", "%u", &opcode),
-			    C2_STRINGARG('s', "server",
-			    LAMBDA(void, (const char *name){ server = name; })),
-			    C2_STRINGARG('c', "client",
-			    LAMBDA(void, (const char *name){ client = name; })),
-			    C2_FORMATARG('t', "wait time(in seconds)",
-					 "%u", &timeout),
-			    C2_FLAGARG('i', "yaml input", &input),
-			    C2_STRINGARG('y', "yaml file path",
-			    LAMBDA(void, (const char *name){ yaml_path = name; })),
-			    C2_FLAGARG('v', "verbose", &verbose));
-	if (result != 0)
-		/*
-		 * No need to print "usage" here, C2_GETOPTS will automatically
-		 * do it for us
-		 */
-		return EX_USAGE;
-
-	/* If no argument provided */
-	if (argc == 1) {
-		usage();
-		return EX_USAGE;
-	}
-
-	/* Verbose is true but no other input is valid */
-	if (verbose && argc == 2) {
-		usage();
-		return EX_USAGE;
-	}
-
-	/* Input is false but yaml is assigned path */
-	if ((!input && yaml_path != NULL) ||
-	    (input && yaml_path == NULL)) {
-		usage();
-		return EX_USAGE;
-	}
-
-	/* Init YAML info */
-	if (input) {
-		result = c2_cons_yaml_init(yaml_path);
-		if (result != 0) {
-			fprintf(stderr, "YAML Init failed\n");
-			return EX_NOINPUT;
-		}
-
-		server = c2_cons_yaml_get_value("server");
-		if (server == NULL) {
-			fprintf(stderr, "Server assignment failed\n");
-			result = EX_DATAERR;
-			goto yaml;
-		}
-
-		client = c2_cons_yaml_get_value("client");
-		if (client == NULL) {
-			fprintf(stderr, "Client assignment failed\n");
-			result = EX_DATAERR;
-			goto yaml;
-		}
-	}
-
-	/* Init the console members from CLI input */
-	if (server != NULL)
-		cctx.rcx_remote_addr = server;
-	if (client != NULL)
-		cctx.rcx_local_addr = client;
-
-#ifndef CONSOLE_UT
-	result = c2_init();
-	if (result != 0) {
-		fprintf(stderr, "c2_init failed\n");
-		return EX_SOFTWARE;
-	}
-
-	result = c2_console_fop_init();
-	if (result != 0) {
-		fprintf(stderr, "c2_console_fop_init failed\n");
-		goto end0;
-	}
-
-	result = c2_processors_init();
-	if (result != 0) {
-		fprintf(stderr, "c2_processors_init failed\n");
-		result = EX_SOFTWARE;
-		goto end1;
-	}
-#endif
-	if (show && opcode <= 0) {
-		c2_cons_fop_list_show();
-		usage();
-		result = EX_USAGE;
-		goto end1;
-	}
-
-	if (show && opcode > 0) {
-		result = fop_info_show(opcode);
-		if (result == 0)
-			result = EX_OK;
-		goto end1;
-	}
-
-	result = c2_net_xprt_init(xprt);
-	C2_ASSERT(result == 0);
-
-	result = c2_net_domain_init(&client_net_dom, xprt);
-	C2_ASSERT(result == 0);
-
-	result = c2_rpc_client_init(&cctx);
-	if (result != 0) {
-		fprintf(stderr, "c2_rpc_client_init failed\n");
-		result = EX_SOFTWARE;
-		goto end2;
-	}
-
-	printf("Console Address = %s\n", cctx.rcx_local_addr);
-	printf("Server Address = %s\n", cctx.rcx_remote_addr);
-
-	/* Build the fop/fom/item and send */
-	result = fop_send_and_print(&cctx, opcode);
-	if (result != 0) {
-		fprintf(stderr, "fop_send_and_print failed\n");
-		result = EX_SOFTWARE;
-		goto cleanup;
-	}
-
-cleanup:
-	result = c2_rpc_client_fini(&cctx);
-	C2_ASSERT(result == 0);
-end2:
-#ifndef CONSOLE_UT
-	c2_processors_fini();
-#endif
-end1:
-#ifndef CONSOLE_UT
-	c2_console_fop_fini();
-end0:
-	c2_fini();
-#endif
-
-yaml:
-	if (input)
-		c2_cons_yaml_fini();
-
-	return result;
-}
-
-/** @} end of console group */
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
diff --git a/console/st/Makefile.am b/console/st/Makefile.am
deleted file mode 100644
index 54fd979..0000000
--- a/console/st/Makefile.am
+++ /dev/null
@@ -1,7 +0,0 @@
-INCLUDES                        = -I. -I$(top_srcdir) -I$(top_srcdir)/include
-
-noinst_PROGRAMS                 = server
-
-server_SOURCES                  = server.c
-
-server_LDADD                    = $(top_builddir)/colibri/libcolibri.la
diff --git a/console/st/server.c b/console/st/server.c
deleted file mode 100644
index 1f26ae1..0000000
--- a/console/st/server.c
+++ /dev/null
@@ -1,133 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Dipak Dudhabhate <dipak_dudhabhate@xyratex.com>
- * Original creation date: 08/03/2011
- */
-#ifdef HAVE_CONFIG_H
-#  include <config.h>
-#endif
-
-#include <signal.h>
-#include <unistd.h>               /* sleep */
-
-#include "net/bulk_sunrpc.h"      /* bulk transport */
-#include "colibri/init.h"         /* c2_init */
-#include "lib/getopts.h"	  /* C2_GETOPTS */
-
-#include "rpc/rpclib.h"           /* c2_rpc_server_start */
-#include "ut/rpc.h"               /* C2_RPC_SERVER_CTX_DECLARE */
-
-#include "console/console.h"
-#include "console/console_fop.h"
-
-/**
-   @addtogroup console main
-   @{
- */
-
-#define SERVER_ENDPOINT_ADDR	"127.0.0.1:123457:1"
-#define SERVER_ENDPOINT		"bulk-sunrpc:" SERVER_ENDPOINT_ADDR
-#define SERVER_DB_FILE_NAME	"cons_server.db"
-#define SERVER_STOB_FILE_NAME	"cons_server.stob"
-#define SERVER_LOG_FILE_NAME	"cons_server.log"
-
-extern struct c2_net_xprt c2_net_bulk_sunrpc_xprt;
-
-static int signaled = 0;
-
-static void sig_handler(int num)
-{
-	signaled = 1;
-}
-
-/**
- * @brief Test server for c2console
- *
- *	  Usage: server options...
- *	  where valid options are
- *
- *		-v       : verbose
- */
-int main(int argc, char **argv)
-{
-	int                 result;
-	struct c2_net_xprt  *xprt   = &c2_net_bulk_sunrpc_xprt;
-
-	char *default_server_argv[] = {
-		argv[0], "-r", "-T", "AD", "-D", SERVER_DB_FILE_NAME,
-		"-S", SERVER_STOB_FILE_NAME, "-e", SERVER_ENDPOINT,
-		"-s", "ds1", "-s", "ds2"
-	};
-
-	C2_RPC_SERVER_CTX_DECLARE_SIMPLE(sctx, xprt, default_server_argv,
-					 SERVER_LOG_FILE_NAME);
-
-	verbose = false;
-
-	result = C2_GETOPTS("server", argc, argv,
-			C2_FLAGARG('v', "verbose", &verbose));
-
-	if (result != 0) {
-		printf("c2_getopts failed\n");
-		return result;
-	}
-
-	result = c2_init();
-	if (result != 0) {
-		printf("c2_init failed\n");
-		return result;
-	}
-
-	result = c2_console_fop_init();
-	if (result != 0) {
-		printf("c2_console_fop_init failed\n");
-		goto c2_fini;
-	}
-
-	result = c2_rpc_server_start(&sctx);
-	if (result != 0) {
-		printf("failed to start rpc server\n");
-		goto fop_fini;
-	}
-
-        printf("Server Address = %s\n", SERVER_ENDPOINT);
-	printf("Press CTRL+C to quit.\n");
-
-	signal(SIGINT, sig_handler);
-	while (!signaled)
-		sleep(1);
-	printf("\nExiting Server.\n");
-
-	c2_rpc_server_stop(&sctx);
-fop_fini:
-	c2_console_fop_fini();
-c2_fini:
-	c2_fini();
-	return result;
-}
-
-/** @} end of console group */
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
diff --git a/console/ut/Makefile.am b/console/ut/Makefile.am
deleted file mode 100644
index b2dd48d..0000000
--- a/console/ut/Makefile.am
+++ /dev/null
@@ -1,3 +0,0 @@
-noinst_LTLIBRARIES	 = libconsole-ut.la
-libconsole_ut_la_SOURCES = console.c
-INCLUDES		 = -I. -I$(top_srcdir) -I$(top_srcdir)/include
diff --git a/console/ut/console.c b/console/ut/console.c
deleted file mode 100644
index cf717ad..0000000
--- a/console/ut/console.c
+++ /dev/null
@@ -1,745 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Dipak Dudhabhate <dipak_dudhabhate@xyratex.com>
- * Original creation date: 08/03/2011
- */
-
-#ifdef HAVE_CONFIG_H
-#  include <config.h>
-#endif
-
-#ifndef CONSOLE_UT
-#define CONSOLE_UT
-#endif
-
-#include <sysexits.h>
-
-#include "lib/types.h"            /* uint64_t */
-#include "lib/ut.h"
-#include "lib/assert.h"
-#include "lib/ub.h"
-#include "lib/memory.h"
-#include "fop/fop_iterator.h"
-#include "lib/errno.h"            /* ETIMEDOUT */
-#include "net/bulk_sunrpc.h"      /* bulk transport */
-#include "lib/processor.h"        /* c2_processors_init/fini */
-#include "lib/thread.h"		  /* c2_thread */
-#include "lib/trace.h"
-#include "lib/misc.h"		  /* C2_SET0 */
-#include "rpc/rpclib.h"           /* c2_rpc_server_start */
-#include "ut/rpc.h"               /* c2_rpc_client_init */
-
-#include "console/console.h"
-#include "console/console_u.h"
-#include "console/console_fop.h"
-#include "console/console_it.h"
-#include "console/console_yaml.h"
-#include "console/console_mesg.h"
-#include "console/main.c"
-
-/**
-   @addtogroup console
-   @{
- */
-
-enum {
-	COB_DOM_CLIENT_ID  = 14,
-	COB_DOM_SERVER_ID = 15,
-};
-
-static const char *yaml_file = "/tmp/console_ut.yaml";
-static const char *err_file = "/tmp/stderr";
-static const char *out_file = "/tmp/stdout";
-static const char *in_file = "/tmp/stdin";
-
-static struct c2_ut_redirect in_redir;
-static struct c2_ut_redirect out_redir;
-static struct c2_ut_redirect err_redir;
-
-#define CLIENT_ENDPOINT_ADDR	"127.0.0.1:123456:1"
-#define CLIENT_DB_NAME		"cons_client_db"
-
-#define SERVER_ENDPOINT_ADDR	"127.0.0.1:123456:2"
-#define SERVER_ENDPOINT		"bulk-sunrpc:" SERVER_ENDPOINT_ADDR
-#define SERVER_DB_FILE_NAME	"cons_server_db"
-#define SERVER_STOB_FILE_NAME	"cons_server_stob"
-#define SERVER_LOG_FILE_NAME	"cons_server.log"
-
-enum {
-	CLIENT_COB_DOM_ID	= 14,
-	SESSION_SLOTS		= 1,
-	MAX_RPCS_IN_FLIGHT	= 1,
-	CONNECT_TIMEOUT		= 5,
-};
-
-extern struct c2_net_xprt c2_net_bulk_sunrpc_xprt;
-
-static struct c2_net_xprt    *xprt = &c2_net_bulk_sunrpc_xprt;
-static struct c2_net_domain  client_net_dom = { };
-static struct c2_dbenv       client_dbenv;
-static struct c2_cob_domain  client_cob_dom;
-
-static struct c2_rpc_client_ctx cctx = {
-	.rcx_net_dom            = &client_net_dom,
-	.rcx_local_addr         = CLIENT_ENDPOINT_ADDR,
-	.rcx_remote_addr        = SERVER_ENDPOINT_ADDR,
-	.rcx_db_name            = CLIENT_DB_NAME,
-	.rcx_dbenv              = &client_dbenv,
-	.rcx_cob_dom_id         = CLIENT_COB_DOM_ID,
-	.rcx_cob_dom            = &client_cob_dom,
-	.rcx_nr_slots           = SESSION_SLOTS,
-	.rcx_timeout_s          = CONNECT_TIMEOUT,
-	.rcx_max_rpcs_in_flight = MAX_RPCS_IN_FLIGHT,
-};
-
-static char *server_argv[] = {
-	"console_ut", "-r", "-T", "AD", "-D", SERVER_DB_FILE_NAME,
-	"-S", SERVER_STOB_FILE_NAME, "-e", SERVER_ENDPOINT,
-	"-s", "ds1", "-s", "ds2"
-};
-
-static struct c2_rpc_server_ctx sctx = {
-	.rsx_xprts            = &xprt,
-	.rsx_xprts_nr         = 1,
-	.rsx_argv             = server_argv,
-	.rsx_argc             = ARRAY_SIZE(server_argv),
-	.rsx_service_types    = cs_default_stypes,
-	/*
-	 * can't use cs_default_stypes_nr to initialize rsx_service_types_nr,
-	 * since it leads to compile-time error 'initializer element is not
-	 * constant', because sctx here is a global/static variable, which not
-	 * allowed to be initialized with non-constant values
-	 */
-	.rsx_service_types_nr = 2,
-	.rsx_log_file_name    = SERVER_LOG_FILE_NAME,
-};
-
-
-static int cons_init(void)
-{
-	int result;
-
-	timeout = 10;
-	result = c2_console_fop_init();
-        C2_ASSERT(result == 0);
-	/*result = c2_processors_init();*/
-	C2_ASSERT(result == 0);
-
-	/*
-	 * There is no need to initialize xprt explicitly if client and server
-	 * run withing a single process, because in this case transport is
-	 * initialized by c2_rpc_server_start().
-	 */
-
-	result = c2_net_domain_init(&client_net_dom, xprt);
-	C2_ASSERT(result == 0);
-
-	return result;
-}
-
-static int cons_fini(void)
-{
-	c2_net_domain_fini(&client_net_dom);
-	/*c2_processors_fini();*/
-	c2_console_fop_fini();
-	return 0;
-}
-
-static void file_redirect_init(void)
-{
-	c2_stream_redirect(stdin, in_file, &in_redir);
-	c2_stream_redirect(stdout, out_file, &out_redir);
-	c2_stream_redirect(stderr, err_file, &err_redir);
-}
-
-static void file_redirect_fini(void)
-{
-	int result;
-
-	c2_stream_restore(&in_redir);
-	c2_stream_restore(&out_redir);
-	c2_stream_restore(&err_redir);
-
-	result = remove(in_file);
-	C2_UT_ASSERT(result == 0);
-	result = remove(out_file);
-	C2_UT_ASSERT(result == 0);
-	result = remove(err_file);
-	C2_UT_ASSERT(result == 0);
-}
-
-static int generate_yaml_file(const char *name)
-{
-	FILE *fp;
-
-	C2_PRE(name != NULL);
-
-        fp = fopen(name, "w");
-        if (fp == NULL) {
-                fprintf(stderr, "Failed to create yaml file\n");
-                return -errno;
-        }
-
-	fprintf(fp, "# Generated yaml file for console UT\n\n");
-	fprintf(fp, "server  : localhost\n");
-	fprintf(fp, "sport   : 23125\n");
-	fprintf(fp, "client  : localhost\n");
-	fprintf(fp, "cport   : 23126\n");
-	fprintf(fp, "\n\n");
-	fprintf(fp, "Test FOP:\n");
-	fprintf(fp, "  - cons_seq : 1\n");
-	fprintf(fp, "    cons_oid : 2\n");
-	fprintf(fp, "    cons_test_type : d\n");
-	fprintf(fp, "    cons_test_id : 64\n");
-
-	fclose(fp);
-	return 0;
-}
-
-static void init_test_fop(struct c2_cons_fop_test *fop)
-{
-	fop->cons_id.cons_seq = 1;
-        fop->cons_id.cons_oid = 2;
-	fop->cons_test_type = 'd';
-	fop->cons_test_id = 64;
-}
-
-static void check_values(struct c2_fop *fop)
-{
-	struct c2_fit		  it;
-        struct c2_fit_yield       yield;
-	struct c2_fid		 *fid;
-	char			 *data;
-	uint64_t		 *value;
-	int			  result;
-
-	c2_fop_all_object_it_init(&it, fop);
-	result = c2_fit_yield(&it, &yield);
-	C2_UT_ASSERT(result != 0);
-	fid = (struct c2_fid *)yield.fy_val.ffi_val;
-	C2_UT_ASSERT(fid->f_container == 1);
-	C2_UT_ASSERT(fid->f_key == 2);
-
-	result = c2_fit_yield(&it, &yield);
-	C2_UT_ASSERT(result != 0);
-	data = (char *)yield.fy_val.ffi_val;
-	C2_UT_ASSERT(*data == 'd');
-
-	result = c2_fit_yield(&it, &yield);
-	C2_UT_ASSERT(result != 0);
-	value = (uint64_t *)yield.fy_val.ffi_val;
-	C2_UT_ASSERT(*value == 64);
-	c2_fop_all_object_it_fini(&it);
-}
-
-static void fop_iterator_test(void)
-{
-	struct c2_fit		 it;
-	struct c2_fop		*fop;
-        struct c2_cons_fop_test *f;
-
-        fop = c2_fop_alloc(&c2_cons_fop_test_fopt, NULL);
-        C2_UT_ASSERT(fop != NULL);
-	f = c2_fop_data(fop);
-        C2_UT_ASSERT(f != NULL);
-
-        c2_fop_all_object_it_init(&it, fop);
-	init_test_fop(f);
-	check_values(fop);
-        c2_fop_free(fop);
-	c2_fop_all_object_it_fini(&it);
-}
-
-static void yaml_basic_test(void)
-{
-	int result;
-
-	result = generate_yaml_file(yaml_file);
-	C2_UT_ASSERT(result == 0);
-	result = c2_cons_yaml_init(yaml_file);
-	C2_UT_ASSERT(result == 0);
-
-	/* Init and Fini */
-	c2_cons_yaml_fini();
-	result = c2_cons_yaml_init(yaml_file);
-	C2_UT_ASSERT(result == 0);
-	c2_cons_yaml_fini();
-
-	result = remove(yaml_file);
-	C2_UT_ASSERT(result == 0);
-}
-
-static void input_test(void)
-{
-        struct c2_fop	*fop;
-	int		 result;
-
-	file_redirect_init();
-	result = generate_yaml_file(yaml_file);
-	C2_UT_ASSERT(result == 0);
-	result = c2_cons_yaml_init(yaml_file);
-	C2_UT_ASSERT(result == 0);
-
-        fop = c2_fop_alloc(&c2_cons_fop_test_fopt, NULL);
-        C2_UT_ASSERT(fop != NULL);
-
-        c2_cons_fop_obj_input(fop);
-	check_values(fop);
-        c2_fop_free(fop);
-	c2_cons_yaml_fini();
-	result = remove(yaml_file);
-	C2_UT_ASSERT(result == 0);
-	file_redirect_fini();
-}
-
-static void file_compare(const char *in, const char *out)
-{
-	FILE *infp;
-	FILE *outfp;
-	int   inc;
-	int   outc;
-
-	infp = fopen(in, "r");
-	C2_UT_ASSERT(infp != NULL);
-	outfp = fopen(out, "r");
-	C2_UT_ASSERT(outfp != NULL);
-
-	while ((inc = fgetc(infp)) != EOF &&
-	       (outc = fgetc(outfp)) != EOF) {
-	       C2_UT_ASSERT(inc == outc);
-	}
-
-	fclose(infp);
-	fclose(outfp);
-}
-
-static void output_test(void)
-{
-        struct c2_fop	*f;
-	int		 result;
-
-	verbose = true;
-	result = generate_yaml_file(yaml_file);
-	C2_UT_ASSERT(result == 0);
-	result = c2_cons_yaml_init(yaml_file);
-	C2_UT_ASSERT(result == 0);
-
-        f = c2_fop_alloc(&c2_cons_fop_test_fopt, NULL);
-        C2_UT_ASSERT(f != NULL);
-
-	file_redirect_init();
-
-        c2_cons_fop_obj_input(f);
-	c2_cons_fop_obj_output(f);
-
-	file_compare(in_file, out_file);
-	file_redirect_fini();
-
-	verbose = false;
-        c2_fop_free(f);
-	c2_cons_yaml_fini();
-	result = remove(yaml_file);
-	C2_UT_ASSERT(result == 0);
-}
-
-static void yaml_file_test(void)
-{
-	int   result;
-
-	file_redirect_init();
-	result = c2_cons_yaml_init(yaml_file);
-	C2_UT_ASSERT(result != 0);
-	file_redirect_fini();
-}
-
-static void yaml_parser_test(void)
-{
-	FILE *fp;
-	int   result;
-
-	file_redirect_init();
-        fp = fopen(yaml_file, "w");
-        C2_UT_ASSERT(fp != NULL);
-	fprintf(fp, "# Generated yaml file for console UT\n\n");
-	fprintf(fp, "server  : localhost\n");
-	fprintf(fp, "sport   : 23125\n");
-	fprintf(fp, "client  : localhost\n");
-	fprintf(fp, "cport   : 23126\n");
-	fprintf(fp, "\n\n");
-	fprintf(fp, "Test FOP:\n");
-	fprintf(fp, "  - cons_seq : 1\n");
-	/* Error introduced here */
-	fprintf(fp, "cons_oid : 2\n");
-	fprintf(fp, "    cons_test_type : d\n");
-	fprintf(fp, "    cons_test_id : 64\n");
-	fclose(fp);
-
-	result = c2_cons_yaml_init(yaml_file);
-	C2_UT_ASSERT(result != 0);
-	result = remove(yaml_file);
-	C2_UT_ASSERT(result == 0);
-	file_redirect_fini();
-}
-
-static void yaml_root_get_test(void)
-{
-	FILE *fp;
-	int   result;
-
-	file_redirect_init();
-        fp = fopen(yaml_file, "w");
-        C2_UT_ASSERT(fp != NULL);
-	fclose(fp);
-
-	result = c2_cons_yaml_init(yaml_file);
-	C2_UT_ASSERT(result != 0);
-	result = remove(yaml_file);
-	C2_UT_ASSERT(result == 0);
-	file_redirect_fini();
-}
-
-static void yaml_get_value_test(void)
-{
-	uint32_t  number;
-	int	  result;
-	char	 *value;
-
-	result = generate_yaml_file(yaml_file);
-	C2_UT_ASSERT(result == 0);
-	result = c2_cons_yaml_init(yaml_file);
-	C2_UT_ASSERT(result == 0);
-
-	value = c2_cons_yaml_get_value("server");
-	C2_UT_ASSERT(value != NULL);
-	C2_UT_ASSERT(strcmp("localhost", value) == 0);
-
-	value = c2_cons_yaml_get_value("sport");
-	C2_UT_ASSERT(value != NULL);
-	number = strtoul(value, NULL, 10);
-	C2_UT_ASSERT(number == 23125);
-
-	value = c2_cons_yaml_get_value("client");
-	C2_UT_ASSERT(value != NULL);
-	C2_UT_ASSERT(strcmp("localhost", value) == 0);
-
-	value = c2_cons_yaml_get_value("cport");
-	C2_UT_ASSERT(value != NULL);
-	number = strtoul(value, NULL, 10);
-	C2_UT_ASSERT(number == 23126);
-
-	value = c2_cons_yaml_get_value("cons_seq");
-	C2_UT_ASSERT(value != NULL);
-	number = strtoul(value, NULL, 10);
-	C2_UT_ASSERT(number == 1);
-
-	value = c2_cons_yaml_get_value("cons_oid");
-	C2_UT_ASSERT(value != NULL);
-	number = strtoul(value, NULL, 10);
-	C2_UT_ASSERT(number == 2);
-
-	value = c2_cons_yaml_get_value("cons_test_type");
-	C2_UT_ASSERT(value != NULL);
-	C2_UT_ASSERT(value[0] == 'd');
-
-	value = c2_cons_yaml_get_value("cons_test_id");
-	C2_UT_ASSERT(value != NULL);
-	number = strtoul(value, NULL, 10);
-	C2_UT_ASSERT(number == 64);
-
-	value = c2_cons_yaml_get_value("xxxx");
-	C2_UT_ASSERT(value == NULL);
-
-	c2_cons_yaml_fini();
-	result = remove(yaml_file);
-	C2_UT_ASSERT(result == 0);
-}
-
-
-static int device_yaml_file(const char *name)
-{
-	FILE *fp;
-
-	C2_PRE(name != NULL);
-
-        fp = fopen(name, "w");
-        if (fp == NULL) {
-                fprintf(stderr, "Failed to create yaml file\n");
-                return -errno;
-        }
-
-	fprintf(fp, "# Generated yaml file for console UT\n\n");
-	fprintf(fp, "server  : localhost\n");
-	fprintf(fp, "sport   : 23125\n");
-	fprintf(fp, "client  : localhost\n");
-	fprintf(fp, "cport   : 23126\n");
-	fprintf(fp, "\n\n");
-	fprintf(fp, "Test FOP:\n");
-	fprintf(fp, "  - cons_seq : 1\n");
-	fprintf(fp, "    cons_oid : 2\n");
-	fprintf(fp, "    cons_notify_type : 0\n");
-	fprintf(fp, "    cons_dev_id : 64\n");
-	fprintf(fp, "    cons_size : 8\n");
-	fprintf(fp, "    cons_buf  : console\n");
-
-	fclose(fp);
-	return 0;
-}
-
-static void cons_client_init(struct c2_rpc_client_ctx *cctx)
-{
-	int result;
-
-	/* Init Test */
-	result = device_yaml_file(yaml_file);
-	C2_UT_ASSERT(result == 0);
-	result = c2_cons_yaml_init(yaml_file);
-	C2_UT_ASSERT(result == 0);
-	result = c2_rpc_client_init(cctx);
-	C2_UT_ASSERT(result == 0);
-}
-
-static void cons_client_fini(struct c2_rpc_client_ctx *cctx)
-{
-	int result;
-
-	/* Fini Test */
-	result = c2_rpc_client_fini(cctx);
-	C2_UT_ASSERT(result == 0);
-	c2_cons_yaml_fini();
-	result = remove(yaml_file);
-	C2_UT_ASSERT(result == 0);
-}
-
-static void cons_server_init(struct c2_rpc_server_ctx *sctx)
-{
-	int result;
-
-	result = c2_rpc_server_start(sctx);
-	C2_UT_ASSERT(result == 0);
-}
-
-static void cons_server_fini(struct c2_rpc_server_ctx *sctx)
-{
-	c2_rpc_server_stop(sctx);
-}
-
-static void conn_basic_test(void)
-{
-	cons_server_init(&sctx);
-	cons_client_init(&cctx);
-	cons_client_fini(&cctx);
-	cons_server_fini(&sctx);
-}
-
-static void success_client(int dummy)
-{
-	cons_client_init(&cctx);
-	cons_client_fini(&cctx);
-}
-
-static void conn_success_test(void)
-{
-	struct c2_thread client_handle;
-	int		 result;
-
-	cons_server_init(&sctx);
-	C2_SET0(&client_handle);
-	result = C2_THREAD_INIT(&client_handle, int, NULL, &success_client,
-				0, "console-client");
-	C2_UT_ASSERT(result == 0);
-	c2_thread_join(&client_handle);
-	c2_thread_fini(&client_handle);
-	cons_server_fini(&sctx);
-}
-
-static void mesg_send_client(int dummy)
-{
-	struct c2_fop_type *ftype;
-	struct c2_fop	   *fop;
-	int		    result;
-
-	cons_client_init(&cctx);
-
-	ftype = c2_cons_fop_type_find(C2_CONS_FOP_DEVICE_OPCODE);
-	C2_UT_ASSERT(ftype != NULL);
-	c2_cons_fop_name_print(ftype);
-	printf("\n");
-	fop = c2_fop_alloc(ftype, NULL);
-	C2_UT_ASSERT(fop != NULL);
-	c2_cons_fop_obj_input(fop);
-	result = c2_rpc_client_call(fop, &cctx.rcx_session,
-				    &c2_fop_default_item_ops, CONNECT_TIMEOUT);
-	C2_UT_ASSERT(result == 0);
-
-	cons_client_fini(&cctx);
-}
-
-static void mesg_send_test(void)
-{
-	struct c2_thread client_handle;
-	int		 result;
-
-	file_redirect_init();
-	cons_server_init(&sctx);
-	C2_SET0(&client_handle);
-	result = C2_THREAD_INIT(&client_handle, int, NULL, &mesg_send_client,
-				0, "console-client");
-	C2_UT_ASSERT(result == 0);
-	c2_thread_join(&client_handle);
-	c2_thread_fini(&client_handle);
-	cons_server_fini(&sctx);
-	file_redirect_fini();
-}
-
-static int console_cmd(const char *name, ...)
-{
-        va_list      list;
-        va_list      clist;
-        int          argc = 0;
-        const char **argv;
-        const char **argp;
-        const char  *arg;
-
-        va_start(list, name);
-        va_copy(clist, list);
-
-        /* Count number of arguments */
-        do {
-                arg = va_arg(clist, const char *);
-                argc++;
-        } while(arg);
-        va_end(clist);
-
-        /* Allocate memory for pointer array */
-        argp = argv = c2_alloc((argc + 1) * sizeof(const char *));
-        C2_UT_ASSERT(argv != NULL);
-	argv[argc] = NULL;
-
-        /* Init list to array */
-        *argp++ = name;
-        do {
-                arg = va_arg(list, const char *);
-                *argp++ = arg;
-        } while (arg);
-        va_end(list);
-
-        return console_main(argc, (char **)argv);
-}
-
-static void console_input_test(void)
-{
-	int   result;
-	char  buf[35];
-
-	file_redirect_init();
-	/* starts UT test for console main */
-	result = console_cmd("no_input", NULL);
-	C2_UT_ASSERT(result == EX_USAGE);
-	C2_UT_ASSERT(c2_error_mesg_match(stderr, usage_msg));
-	truncate(err_file, 0L);
-	fseek(stderr, 0L, SEEK_SET);
-
-	result = console_cmd("no_input", "-v", NULL);
-	C2_UT_ASSERT(result == EX_USAGE);
-	C2_UT_ASSERT(c2_error_mesg_match(stderr, usage_msg));
-	truncate(err_file, 0L);
-	fseek(stderr, 0L, SEEK_SET);
-
-	fseek(stdout, 0L, SEEK_SET);
-	result = console_cmd("list_fops", "-l", NULL);
-	C2_UT_ASSERT(result == EX_USAGE);
-	C2_UT_ASSERT(c2_error_mesg_match(stdout, "List of FOP's:"));
-	truncate(out_file, 0L);
-	fseek(stdout, 0L, SEEK_SET);
-
-	sprintf(buf, "%d", C2_CONS_FOP_DEVICE_OPCODE);
-	result = console_cmd("show_fops", "-l", "-f", buf, NULL);
-	C2_UT_ASSERT(result == EX_OK);
-	sprintf(buf, "%.2d, Device Failed",
-		     C2_CONS_FOP_DEVICE_OPCODE);
-	C2_UT_ASSERT(c2_error_mesg_match(stdout, buf));
-	truncate(out_file, 0L);
-	fseek(stdout, 0L, SEEK_SET);
-
-	sprintf(buf, "%d", C2_CONS_FOP_REPLY_OPCODE);
-	result = console_cmd("show_fops", "-l", "-f", buf, NULL);
-	C2_UT_ASSERT(result == EX_OK);
-	sprintf(buf, "%.2d, Console Reply",
-		     C2_CONS_FOP_REPLY_OPCODE);
-	C2_UT_ASSERT(c2_error_mesg_match(stdout, buf));
-	truncate(out_file, 0L);
-	fseek(stdout, 0L, SEEK_SET);
-
-	result = console_cmd("show_fops", "-l", "-f", 0, NULL);
-	C2_UT_ASSERT(result == EX_USAGE);
-	C2_UT_ASSERT(c2_error_mesg_match(stderr, usage_msg));
-	truncate(err_file, 0L);
-	fseek(stderr, 0L, SEEK_SET);
-
-	result = console_cmd("yaml_input", "-i", NULL);
-	C2_UT_ASSERT(result == EX_USAGE);
-	C2_UT_ASSERT(c2_error_mesg_match(stderr, usage_msg));
-	truncate(err_file, 0L);
-	fseek(stderr, 0L, SEEK_SET);
-
-	result = console_cmd("yaml_input", "-y", yaml_file, NULL);
-	C2_UT_ASSERT(result == EX_USAGE);
-	C2_UT_ASSERT(c2_error_mesg_match(stderr, usage_msg));
-	truncate(err_file, 0L);
-	fseek(stderr, 0L, SEEK_SET);
-
-	/* last UT test for console main */
-	result = console_cmd("yaml_input", "-i", "-y", yaml_file, NULL);
-	C2_UT_ASSERT(result == EX_NOINPUT);
-	C2_UT_ASSERT(c2_error_mesg_match(stderr, "YAML Init failed"));
-
-	file_redirect_fini();
-}
-
-const struct c2_test_suite console_ut = {
-        .ts_name = "libconsole-ut",
-        .ts_init = cons_init,
-        .ts_fini = cons_fini,
-        .ts_tests = {
-		{ "yaml_basic_test", yaml_basic_test },
-		{ "fop_iterator_test", fop_iterator_test },
-                { "input_test", input_test },
-                { "console_input_test", console_input_test },
-                { "output_test", output_test },
-                { "yaml_file_test", yaml_file_test },
-                { "yaml_parser_test", yaml_parser_test },
-                { "yaml_root_get_test", yaml_root_get_test },
-                { "yaml_get_value_test", yaml_get_value_test },
-                { "conn_basic_test", conn_basic_test },
-                { "conn_success_test", conn_success_test },
-                { "mesg_send_test", mesg_send_test },
-		{ NULL, NULL }
-	}
-};
-
-#undef CONSOLE_UT
-
-/** @} end of console group */
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
diff --git a/db/Makefile.am b/db/Makefile.am
index b278920..4ccdcca 100644
--- a/db/Makefile.am
+++ b/db/Makefile.am
@@ -1,4 +1,4 @@
-dbdir                    = $(includedir)/colibri/db
+dbdir                    = $(includedir)/db
 db_HEADERS               = db.h extmap.h extmap_internal.h db_impl.h db_common.h
 
 noinst_LTLIBRARIES       = libcolibri-db.la
@@ -6,6 +6,3 @@ libcolibri_db_la_SOURCES = db.c db.h extmap.c extmap.h extmap_internal.h \
                            db_impl.h db_common.c db_common.h
 
 INCLUDES                 = -I. -I$(top_srcdir) -I$(top_srcdir)/include
-
-EXTRA_DIST               = linux_kernel/db.c \
-                           linux_kernel/db_impl.h
\ No newline at end of file
diff --git a/db/db.c b/db/db.c
index fb41b95..04e6586 100644
--- a/db/db.c
+++ b/db/db.c
@@ -66,13 +66,6 @@ static int key_compare(DB *db, const DBT *dbt1, const DBT *dbt2);
 static int get_lsn(struct c2_dbenv *env, DB_LSN *lsn);
 static void dbenv_thread(struct c2_dbenv *env);
 
-C2_TL_DESCR_DEFINE(enw, "env waiters", static, struct c2_db_tx_waiter,
-		   tw_env, tw_magix,
-		   C2_DB_TX_WAITER_MAGIX,
-		   0xda2edc0cc1d10515 /* dazed coccidiosis */);
-C2_TL_DEFINE(enw, static, struct c2_db_tx_waiter);
-
-
 /**
    Convert db5 specific error code into generic errno.
 
@@ -254,7 +247,7 @@ static int dbenv_setup(struct c2_dbenv *env, const char *name, uint64_t flags)
 
 	c2_dbenv_common_init(env);
 	c2_mutex_init(&di->d_lock);
-	enw_tlist_init(&di->d_waiters);
+	c2_list_init(&di->d_waiters);
 	c2_cond_init(&di->d_shutdown_cond);
 	/*
 	 * XXX translate flags from c2 to db5.
@@ -387,7 +380,7 @@ void c2_dbenv_fini(struct c2_dbenv *env)
 		di->d_errlog = NULL;
 	}
 	c2_cond_fini(&di->d_shutdown_cond);
-	enw_tlist_fini(&di->d_waiters);
+	c2_list_fini(&di->d_waiters);
 	c2_mutex_fini(&di->d_lock);
 	c2_dbenv_common_fini(env);
 }
@@ -514,7 +507,7 @@ int c2_db_tx_init(struct c2_db_tx *tx, struct c2_dbenv *env, uint64_t flags)
 
 static void waiter_fini(struct c2_db_tx_waiter *w)
 {
-	enw_tlink_del_fini(w);
+	c2_list_del(&w->tw_env);
 	w->tw_done(w);
 }
 
@@ -526,13 +519,16 @@ static int tx_fini_pre(struct c2_db_tx *tx, bool commit)
 	DB_LSN                  lsn;
 
 	env = tx->dt_env;
-	if (commit && !txw_tlist_is_empty(&tx->dt_waiters)) {
+	if (commit && !c2_list_is_empty(&tx->dt_waiters)) {
 		result = get_lsn(env, &lsn);
 		if (result != 0)
 			return result;
 	}
-	c2_tlist_for(&txw_tl, &tx->dt_waiters, w) {
-		txw_tlist_del(w);
+	while (!c2_list_is_empty(&tx->dt_waiters)) {
+		w = container_of(tx->dt_waiters.l_head, struct c2_db_tx_waiter,
+				 tw_tx);
+		C2_ASSERT(c2_list_link_is_in(&w->tw_env));
+		c2_list_del(&w->tw_tx);
 		if (!commit) {
 			w->tw_abort(w);
 			c2_mutex_lock(&env->d_i.d_lock);
@@ -542,7 +538,7 @@ static int tx_fini_pre(struct c2_db_tx *tx, bool commit)
 			w->tw_commit(w);
 			w->tw_i.tw_lsn = lsn;
 		}
-	} c2_tlist_endfor;
+	}
 	return 0;
 }
 
@@ -582,10 +578,10 @@ void c2_db_tx_waiter_add(struct c2_db_tx *tx, struct c2_db_tx_waiter *w)
 	env = tx->dt_env;
 
 	c2_mutex_lock(&env->d_i.d_lock);
-	enw_tlink_init_at(w, &env->d_i.d_waiters);
+	c2_list_add(&env->d_i.d_waiters, &w->tw_env);
 	c2_mutex_unlock(&env->d_i.d_lock);
 
-	txw_tlink_init_at(w, &tx->dt_waiters);
+	c2_list_add(&tx->dt_waiters, &w->tw_tx);
 }
 
 static DBT *pair_key(struct c2_db_pair *pair)
@@ -823,6 +819,7 @@ static void dbenv_thread(struct c2_dbenv *env)
 		int                     rc;
 		int                     nr_pages;
 		struct c2_db_tx_waiter *w;
+		struct c2_db_tx_waiter *tmp;
 		c2_time_t               deadline;
 		c2_time_t               delay;
 
@@ -838,20 +835,22 @@ static void dbenv_thread(struct c2_dbenv *env)
 			next.file   = st->st_disk_file;
 			next.offset = st->st_disk_offset;
 			c2_free(st);
-			c2_tlist_for(&enw_tl, &di->d_waiters, w) {
+			c2_list_for_each_entry_safe(&di->d_waiters, w, tmp,
+						    struct c2_db_tx_waiter,
+						    tw_env) {
 				if (log_compare(&w->tw_i.tw_lsn, &next) <= 0) {
 					w->tw_persistent(w);
 					waiter_fini(w);
 				}
-			} c2_tlist_endfor;
+			}
 		}
-		deadline = c2_time_now();
+		c2_time_now(&deadline);
 		c2_time_set(&delay, 1, 0);
 		deadline = c2_time_add(deadline, delay);
 		c2_cond_timedwait(&di->d_shutdown_cond, &di->d_lock, deadline);
 		c2_mutex_unlock(&di->d_lock);
 	} while (!last);
-	C2_ASSERT(enw_tlist_is_empty(&env->d_i.d_waiters));
+	C2_ASSERT(c2_list_is_empty(&env->d_i.d_waiters));
 }
 
 /** @} end of db group */
diff --git a/db/db.h b/db/db.h
index 613185f..3ea3460 100644
--- a/db/db.h
+++ b/db/db.h
@@ -22,7 +22,6 @@
 #define __COLIBRI_DB_DB_H__
 
 #include "addb/addb.h"
-#include "lib/tlist.h"
 #include "lib/adt.h"           /* c2_buf */
 
 /**
@@ -153,8 +152,8 @@ struct c2_table {
 
    @see http://www.oracle.com/technology/documentation/berkeley-db/db/api_reference/C/dbopen.html
  */
-int  c2_table_init(struct c2_table *table, struct c2_dbenv *env,
-		   const char *name, uint64_t flags,
+int  c2_table_init(struct c2_table *table, struct c2_dbenv *env, 
+		   const char *name, uint64_t flags, 
 		   const struct c2_table_ops *ops);
 
 /**
@@ -205,7 +204,7 @@ void c2_db_pair_fini(struct c2_db_pair *pair);
 
  */
 void c2_db_pair_setup(struct c2_db_pair *pair, struct c2_table *table,
-		      void *keybuf, uint32_t keysize,
+		      void *keybuf, uint32_t keysize, 
 		      void *recbuf, uint32_t recsize);
 
 /**
@@ -220,13 +219,13 @@ enum {
 };
 
 /**
-   Table operations vector.
+   Table operations vector. 
 
    @see c2_table
  */
 struct c2_table_ops {
 	struct {
-		/**
+		/** 
 		    Maximal size of key or record (as determined by the index in
 		    c2_table_ops::to).
 		 */
@@ -247,12 +246,12 @@ struct c2_table_ops {
 			       const void *src, void **dst);
 	} to[TO_NR];
 	/**
-	   Key comparison function.
+	   Key comparison function. 
 
 	   Should return -ve, 0 or +ve value depending on how key0 and key1
 	   compare in key ordering.
 	 */
-	int (*key_cmp)(struct c2_table *table,
+	int (*key_cmp)(struct c2_table *table, 
 		       const void *key0, const void *key1);
 };
 
@@ -266,7 +265,7 @@ struct c2_db_tx {
 	/** An environment this transaction operates in. */
 	struct c2_dbenv     *dt_env;
 	/** A list of waiters (c2_db_tx_waiter). */
-	struct c2_tl         dt_waiters;
+	struct c2_list       dt_waiters;
 	struct c2_db_tx_impl dt_i;
 	/** An ADDB context for events related to this transaction. */
 	struct c2_addb_ctx   dt_addb;
@@ -318,20 +317,12 @@ struct c2_db_tx_waiter {
 	/** Called when no further call-backs will be coming. */
 	void                      (*tw_done)(struct c2_db_tx_waiter *w);
 	/** Linkage into a list of all waiters for data-base environment. */
-	struct c2_tlink             tw_env;
+	struct c2_list_link         tw_env;
 	/** Linkage into a list of all waiters for a given transaction. */
-	struct c2_tlink             tw_tx;
+	struct c2_list_link         tw_tx;
 	struct c2_db_tx_waiter_impl tw_i;
-	uint64_t                    tw_magix;
-};
-
-enum {
-	C2_DB_TX_WAITER_MAGIX = 0xab5c155a0fa1bed0 /* abscissa of albedo */
 };
 
-C2_TL_DESCR_DECLARE(txw, extern);
-C2_TL_DEFINE(txw, static inline, struct c2_db_tx_waiter);
-
 /**
    Adds a waiter for a transaction.
 
@@ -432,7 +423,7 @@ void c2_db_fini(void);
 /* __COLIBRI_DB_REC_H__ */
 #endif
 
-/*
+/* 
  *  Local variables:
  *  c-indentation-style: "K&R"
  *  c-basic-offset: 8
diff --git a/db/db_common.c b/db/db_common.c
index 3dda701..671df7e 100644
--- a/db/db_common.c
+++ b/db/db_common.c
@@ -50,12 +50,6 @@ const struct c2_addb_ctx_type db_tx_ctx_type = {
 	.act_name = "db-tx"
 };
 
-C2_TL_DESCR_DEFINE(txw,
-		   "tx waiters", , struct c2_db_tx_waiter, tw_tx, tw_magix,
-		   C2_DB_TX_WAITER_MAGIX,
-		   0xd1550c1ab1ea11ce /* dissociable alice  */);
-
-
 extern void c2_db_buf_impl_init(struct c2_db_buf *buf);
 extern void c2_db_buf_impl_fini(struct c2_db_buf *buf);
 extern bool c2_db_buf_impl_invariant(const struct c2_db_buf *buf);
@@ -71,7 +65,7 @@ void c2_dbenv_common_fini(struct c2_dbenv *env)
 	c2_addb_ctx_fini(&env->d_addb);
 }
 
-void c2_table_common_init(struct c2_table *table, struct c2_dbenv *env,
+void c2_table_common_init(struct c2_table *table, struct c2_dbenv *env, 
 			  const struct c2_table_ops *ops)
 {
 	table->t_env = env;
@@ -86,7 +80,7 @@ void c2_table_common_fini(struct c2_table *table)
 
 bool c2_db_buf_invariant(const struct c2_db_buf *buf)
 {
-	return
+	return 
 		DBT_ZERO < buf->db_type && buf->db_type < DBT_NR &&
 		/* in-place buffers are not yet supported */
 		buf->db_type != DBT_INPLACE &&
@@ -126,12 +120,12 @@ bool c2_db_pair_invariant(const struct c2_db_pair *p)
 {
 	return
 		p->dp_table != NULL &&
-		c2_db_buf_invariant(&p->dp_key) &&
+		c2_db_buf_invariant(&p->dp_key) && 
 		c2_db_buf_invariant(&p->dp_rec);
 }
 
 void c2_db_pair_setup(struct c2_db_pair *pair, struct c2_table *table,
-		      void *keybuf, uint32_t keysize,
+		      void *keybuf, uint32_t keysize, 
 		      void *recbuf, uint32_t recsize)
 {
 	C2_PRE((keybuf != NULL) == (keysize > 0));
@@ -169,19 +163,19 @@ void c2_db_pair_release(struct c2_db_pair *pair)
 void c2_db_common_tx_init(struct c2_db_tx *tx, struct c2_dbenv *env)
 {
 	tx->dt_env = env;
-	txw_tlist_init(&tx->dt_waiters);
+	c2_list_init(&tx->dt_waiters);
 	c2_addb_ctx_init(&tx->dt_addb, &db_tx_ctx_type, &env->d_addb);
 }
 
 void c2_db_common_tx_fini(struct c2_db_tx *tx)
 {
 	c2_addb_ctx_fini(&tx->dt_addb);
-	txw_tlist_fini(&tx->dt_waiters);
+	c2_list_fini(&tx->dt_waiters);
 }
 
 /** @} end of db group */
 
-/*
+/* 
  *  Local variables:
  *  c-indentation-style: "K&R"
  *  c-basic-offset: 8
diff --git a/db/db_common.h b/db/db_common.h
index fa2286a..151213b 100644
--- a/db/db_common.h
+++ b/db/db_common.h
@@ -41,7 +41,7 @@ void c2_db_buf_fini      (struct c2_db_buf *buf);
 void c2_db_buf_steal     (struct c2_db_buf *buf);
 bool c2_db_pair_invariant(const struct c2_db_pair *p);
 void c2_db_pair_setup    (struct c2_db_pair *pair, struct c2_table *table,
-			  void *keybuf, uint32_t keysize,
+			  void *keybuf, uint32_t keysize, 
 			  void *recbuf, uint32_t recsize);
 void c2_db_pair_fini     (struct c2_db_pair *pair);
 void c2_db_pair_release  (struct c2_db_pair *pair);
@@ -58,7 +58,7 @@ extern const struct c2_addb_ctx_type db_tx_ctx_type;
 /* __COLIBRI_DB_REC_H__ */
 #endif
 
-/*
+/* 
  *  Local variables:
  *  c-indentation-style: "K&R"
  *  c-basic-offset: 8
diff --git a/db/db_impl.h b/db/db_impl.h
index e574846..eb848ea 100644
--- a/db/db_impl.h
+++ b/db/db_impl.h
@@ -25,7 +25,7 @@
 
 #include "lib/types.h"
 #include "lib/thread.h"
-#include "lib/tlist.h"
+#include "lib/list.h"
 #include "lib/mutex.h"
 #include "lib/cond.h"
 
@@ -55,7 +55,7 @@ struct c2_dbenv_impl {
 	struct c2_mutex    d_lock;
 	/** A list of waiters (c2_db_tx_waiter). Protected by
 	    c2_dbenv_impl::d_lock.  */
-	struct c2_tl       d_waiters;
+	struct c2_list     d_waiters;
 	/** Thread for asynchronous environment related work. */
 	struct c2_thread   d_thread;
 	/** True iff the environment is being shut down. Protected by
diff --git a/db/linux_kernel/db.c b/db/linux_kernel/db.c
index 698725a..5c6869e 100644
--- a/db/linux_kernel/db.c
+++ b/db/linux_kernel/db.c
@@ -37,13 +37,7 @@
    @{
  */
 
-C2_TL_DESCR_DEFINE(pair, "(key, rec) pairs",
-		   static, struct c2_db_kpair, dk_linkage, dk_magix,
-		   0x50c1a112ede1ffe1 /* socialized eiffel */,
-		   0x0551f1edca5cade5 /* ossified cascades */);
-C2_TL_DEFINE(pair, static, struct c2_db_kpair);
-
-static bool ktable_invariant_locked(struct c2_table *t,
+static bool ktable_invariant_locked(struct c2_table *t, 
 				    struct c2_table_impl *ti);
 static bool ktable_invariant(struct c2_table *t);
 
@@ -64,16 +58,23 @@ int c2_dbenv_sync(struct c2_dbenv *env)
 {
 	return 0;
 }
+C2_EXPORTED(c2_dbenv_sync);
 
-int c2_table_init(struct c2_table *table, struct c2_dbenv *env,
-		  const char *name, uint64_t flags,
+int c2_table_init(struct c2_table *table, struct c2_dbenv *env, 
+		  const char *name, uint64_t flags, 
 		  const struct c2_table_ops *ops)
 {
 	c2_table_common_init(table, env, ops);
-	pair_tlist_init(&table->t_i.tk_pair);
+	c2_list_init(&table->t_i.tk_pair);
 	c2_mutex_init(&table->t_i.tk_lock);
 	return 0;
 }
+C2_EXPORTED(c2_table_init);
+
+static struct c2_db_kpair *kpair_extract(void *link)
+{
+	return container_of(link, struct c2_db_kpair, dk_linkage);
+}
 
 void c2_table_fini(struct c2_table *table)
 {
@@ -81,21 +82,24 @@ void c2_table_fini(struct c2_table *table)
 
 	C2_ASSERT(ktable_invariant(table));
 
-	c2_tlist_for(&pair_tl, &table->t_i.tk_pair, kpair) {
-		pair_tlink_del_fini(kpair);
+	while (!c2_list_is_empty(&table->t_i.tk_pair)) {
+		kpair = kpair_extract(&table->t_i.tk_pair.l_head);
+		c2_list_del(&kpair->dk_linkage);
 		c2_free(kpair);
-	} c2_tlist_endfor;
-	pair_tlist_fini(&table->t_i.tk_pair);
+	}
+	c2_list_fini(&table->t_i.tk_pair);
 	c2_mutex_fini(&table->t_i.tk_lock);
 	c2_table_common_fini(table);
 }
+C2_EXPORTED(c2_table_fini);
 
 int c2_db_tx_init(struct c2_db_tx *tx, struct c2_dbenv *env, uint64_t flags)
 {
 	c2_db_common_tx_init(tx, env);
-	txw_tlist_init(&tx->dt_waiters);
+	c2_list_init(&tx->dt_waiters);
 	return 0;
 }
+C2_EXPORTED(c2_db_tx_init);
 
 int c2_db_tx_commit(struct c2_db_tx *tx)
 {
@@ -103,25 +107,30 @@ int c2_db_tx_commit(struct c2_db_tx *tx)
 	struct c2_dbenv        *env;
 
 	env = tx->dt_env;
-	c2_tlist_for(&txw_tl, &tx->dt_waiters, w) {
-		txw_tlist_del(w);
+	while (!c2_list_is_empty(&tx->dt_waiters)) {
+		w = container_of(tx->dt_waiters.l_head, struct c2_db_tx_waiter,
+				 tw_tx);
+		c2_list_del(&w->tw_tx);
 		w->tw_commit(w);
 		w->tw_done(w);
-	} c2_tlist_endfor;
+	}
 	c2_db_common_tx_fini(tx);
 	return 0;
 }
+C2_EXPORTED(c2_db_tx_commit);
 
 int c2_db_tx_abort(struct c2_db_tx *tx)
 {
 	C2_IMPOSSIBLE("Aborting transaction in kernel space.");
 	return 0;
 }
+C2_EXPORTED(c2_db_tx_abort);
 
 void c2_db_tx_waiter_add(struct c2_db_tx *tx, struct c2_db_tx_waiter *w)
 {
-	txw_tlist_add(&tx->dt_waiters, w);
+	c2_list_add(&tx->dt_waiters, &w->tw_tx);
 }
+C2_EXPORTED(c2_db_tx_waiter_add);
 
 static int key_cmp(struct c2_table *t,
 		   const struct c2_buf *k0, const struct c2_buf *k1)
@@ -148,7 +157,8 @@ static struct c2_db_kpair *ktable_lookup(struct c2_db_pair *pair, int *out)
 	C2_PRE(c2_mutex_is_locked(&ti->tk_lock));
 
 	*out = -ENOENT;
-	c2_tlist_for(&pair_tl, &ti->tk_pair, scan) {
+	c2_list_for_each_entry(&ti->tk_pair, scan, struct c2_db_kpair,
+			       dk_linkage) {
 		switch (key_cmp(t, &scan->dk_key, &pair->dp_key.db_buf)) {
 		case -1:
 			continue;
@@ -158,7 +168,7 @@ static struct c2_db_kpair *ktable_lookup(struct c2_db_pair *pair, int *out)
 		default:
 			break;
 		}
-	} c2_tlist_endfor;
+	}
 	return scan;
 }
 
@@ -230,7 +240,7 @@ static void pair_unlock(struct c2_db_pair *pair)
 	c2_mutex_unlock(&pair->dp_table->t_i.tk_lock);
 }
 
-static struct c2_tl *pair_list(struct c2_db_pair *pair)
+static struct c2_list *pair_list(struct c2_db_pair *pair)
 {
 	return &pair->dp_table->t_i.tk_pair;
 }
@@ -248,8 +258,9 @@ int c2_table_update(struct c2_db_tx *tx, struct c2_db_pair *pair)
 		pair_lock(pair);
 		kpair = ktable_lookup(pair, &result);
 		if (result == 0) {
-			pair_tlist_add_after(kpair, replacement);
-			pair_tlink_del_fini(kpair);
+			c2_list_add_after(&kpair->dk_linkage, 
+					  &replacement->dk_linkage);
+			c2_list_del(&kpair->dk_linkage);
 			c2_free(kpair);
 		} else
 			c2_free(replacement);
@@ -260,6 +271,7 @@ int c2_table_update(struct c2_db_tx *tx, struct c2_db_pair *pair)
 	C2_ASSERT(ktable_invariant(pair->dp_table));
 	return result;
 }
+C2_EXPORTED(c2_table_update);
 
 int table_insert(struct c2_db_pair *pair, struct c2_db_kpair **kpair_out)
 {
@@ -276,7 +288,8 @@ int table_insert(struct c2_db_pair *pair, struct c2_db_kpair **kpair_out)
 		pair_lock(pair);
 		kpair = ktable_lookup(pair, &out);
 		if (out == -ENOENT) {
-			pair_tlist_add_before(kpair, newkp);
+			c2_list_add_before(&kpair->dk_linkage, 
+					   &newkp->dk_linkage);
 			*kpair_out = newkp;
 			result = 0;
 		} else {
@@ -296,6 +309,7 @@ int c2_table_insert(struct c2_db_tx *tx, struct c2_db_pair *pair)
 
 	return table_insert(pair, &dummy);
 }
+C2_EXPORTED(c2_table_insert);
 
 int c2_table_lookup(struct c2_db_tx *tx, struct c2_db_pair *pair)
 {
@@ -311,6 +325,7 @@ int c2_table_lookup(struct c2_db_tx *tx, struct c2_db_pair *pair)
 	pair_unlock(pair);
 	return result;
 }
+C2_EXPORTED(c2_table_lookup);
 
 int c2_table_delete(struct c2_db_tx *tx, struct c2_db_pair *pair)
 {
@@ -322,7 +337,7 @@ int c2_table_delete(struct c2_db_tx *tx, struct c2_db_pair *pair)
 	pair_lock(pair);
 	kpair = ktable_lookup(pair, &result);
 	if (result == 0) {
-		pair_tlink_del_fini(kpair);
+		c2_list_del(&kpair->dk_linkage);
 		c2_free(kpair);
 	}
 	pair_unlock(pair);
@@ -331,6 +346,7 @@ int c2_table_delete(struct c2_db_tx *tx, struct c2_db_pair *pair)
 
 	return result;
 }
+C2_EXPORTED(c2_table_delete);
 
 int c2_db_cursor_init(struct c2_db_cursor *cursor, struct c2_table *table,
 		      struct c2_db_tx *tx)
@@ -338,10 +354,12 @@ int c2_db_cursor_init(struct c2_db_cursor *cursor, struct c2_table *table,
 	C2_SET0(cursor);
 	return 0;
 }
+C2_EXPORTED(c2_db_cursor_init);
 
 void c2_db_cursor_fini(struct c2_db_cursor *cursor)
 {
 }
+C2_EXPORTED(c2_db_cursor_fini);
 
 int c2_db_cursor_get(struct c2_db_cursor *cursor, struct c2_db_pair *pair)
 {
@@ -357,12 +375,12 @@ int c2_db_cursor_get(struct c2_db_cursor *cursor, struct c2_db_pair *pair)
 	c2_mutex_unlock(&cursor->c_table->t_i.tk_lock);
 	return result;
 }
+C2_EXPORTED(c2_db_cursor_get);
 
 int c2_db_cursor_next(struct c2_db_cursor *cursor, struct c2_db_pair *pair)
 {
 	struct c2_db_cursor_impl *ci;
 	int                       result;
-	struct c2_db_kpair       *next;
 
 	C2_PRE(cursor->c_table == pair->dp_table);
 	C2_ASSERT(ktable_invariant(pair->dp_table));
@@ -373,23 +391,23 @@ int c2_db_cursor_next(struct c2_db_cursor *cursor, struct c2_db_pair *pair)
 		result = -EINVAL;
 	else {
 		pair_lock(pair);
-		next = pair_tlist_next(pair_list(pair), ci->ck_current);
-		if (next == NULL)
+		if (&ci->ck_current->dk_linkage == pair_list(pair)->l_tail)
 			result = -ENOENT;
 		else {
-			ci->ck_current = next;
+			ci->ck_current = kpair_extract
+				(ci->ck_current->dk_linkage.ll_next);
 			result = kpair_copyout(ci->ck_current, pair);
 		}
 		pair_unlock(pair);
 	}
 	return result;
 }
+C2_EXPORTED(c2_db_cursor_next);
 
 int c2_db_cursor_prev(struct c2_db_cursor *cursor, struct c2_db_pair *pair)
 {
 	struct c2_db_cursor_impl *ci;
 	int                       result;
-	struct c2_db_kpair       *prev;
 
 	C2_PRE(cursor->c_table == pair->dp_table);
 	C2_ASSERT(ktable_invariant(pair->dp_table));
@@ -400,24 +418,24 @@ int c2_db_cursor_prev(struct c2_db_cursor *cursor, struct c2_db_pair *pair)
 		result = -EINVAL;
 	else {
 		pair_lock(pair);
-		prev = pair_tlist_prev(pair_list(pair), ci->ck_current);
-		if (prev == NULL)
+		if (&ci->ck_current->dk_linkage == pair_list(pair)->l_head)
 			result = -ENOENT;
 		else {
-			ci->ck_current = prev;
+			ci->ck_current = kpair_extract
+				(ci->ck_current->dk_linkage.ll_prev);
 			result = kpair_copyout(ci->ck_current, pair);
 		}
 		pair_unlock(pair);
 	}
 	return result;
 }
+C2_EXPORTED(c2_db_cursor_prev);
 
 int c2_db_cursor_first(struct c2_db_cursor *cursor, struct c2_db_pair *pair)
 {
 	struct c2_db_cursor_impl *ci;
-	struct c2_tl             *pl;
+	struct c2_list           *pl;
 	int                       result;
-	struct c2_db_kpair       *first;
 
 	C2_PRE(cursor->c_table == pair->dp_table);
 	C2_ASSERT(ktable_invariant(pair->dp_table));
@@ -426,24 +444,23 @@ int c2_db_cursor_first(struct c2_db_cursor *cursor, struct c2_db_pair *pair)
 	pl = pair_list(pair);
 
 	pair_lock(pair);
-	first = pair_tlist_head(pl);
-	if (first == NULL)
+	if (c2_list_is_empty(pl))
 		result = -ENOENT;
 	else {
-		ci->ck_current = first;
+		ci->ck_current = kpair_extract(pl->l_head);
 		kpair_copyout(ci->ck_current, pair);
 		result = 0;
 	}
 	pair_unlock(pair);
 	return result;
 }
+C2_EXPORTED(c2_db_cursor_first);
 
 int c2_db_cursor_last(struct c2_db_cursor *cursor, struct c2_db_pair *pair)
 {
 	struct c2_db_cursor_impl *ci;
-	struct c2_tl             *pl;
+	struct c2_list           *pl;
 	int                       result;
-	struct c2_db_kpair       *last;
 
 	C2_PRE(cursor->c_table == pair->dp_table);
 	C2_ASSERT(ktable_invariant(pair->dp_table));
@@ -452,17 +469,17 @@ int c2_db_cursor_last(struct c2_db_cursor *cursor, struct c2_db_pair *pair)
 	pl = pair_list(pair);
 
 	pair_lock(pair);
-	last = pair_tlist_tail(pl);
-	if (last == NULL)
+	if (c2_list_is_empty(pl))
 		result = -ENOENT;
 	else {
-		ci->ck_current = last;
+		ci->ck_current = kpair_extract(pl->l_tail);
 		kpair_copyout(ci->ck_current, pair);
 		result = 0;
 	}
 	pair_unlock(pair);
 	return result;
 }
+C2_EXPORTED(c2_db_cursor_last);
 
 int c2_db_cursor_set(struct c2_db_cursor *cursor, struct c2_db_pair *pair)
 {
@@ -489,8 +506,8 @@ int c2_db_cursor_set(struct c2_db_cursor *cursor, struct c2_db_pair *pair)
 	newkp = kpair_alloc(&replacement);
 	if (newkp != NULL) {
 		pair_lock(pair);
-		pair_tlist_add_after(cur, newkp);
-		pair_tlink_del_fini(cur);
+		c2_list_add_after(&cur->dk_linkage, &newkp->dk_linkage);
+		c2_list_del(&cur->dk_linkage);
 		c2_free(cur);
 		ci->ck_current = newkp;
 		pair_unlock(pair);
@@ -502,6 +519,7 @@ int c2_db_cursor_set(struct c2_db_cursor *cursor, struct c2_db_pair *pair)
 
 	return result;
 }
+C2_EXPORTED(c2_db_cursor_set);
 
 int c2_db_cursor_add(struct c2_db_cursor *cursor, struct c2_db_pair *pair)
 {
@@ -509,6 +527,7 @@ int c2_db_cursor_add(struct c2_db_cursor *cursor, struct c2_db_pair *pair)
 
 	return table_insert(pair, &cursor->c_i.ck_current);
 }
+C2_EXPORTED(c2_db_cursor_add);
 
 int c2_db_cursor_del(struct c2_db_cursor *cursor)
 {
@@ -523,7 +542,7 @@ int c2_db_cursor_del(struct c2_db_cursor *cursor)
 
 	if (ci->ck_current != NULL) {
 		c2_mutex_lock(&ti->tk_lock);
-		pair_tlink_del_fini(ci->ck_current);
+		c2_list_del(&ci->ck_current->dk_linkage);
 		c2_free(ci->ck_current);
 		ci->ck_current = NULL;
 		c2_mutex_unlock(&ti->tk_lock);
@@ -533,6 +552,7 @@ int c2_db_cursor_del(struct c2_db_cursor *cursor)
 	C2_ASSERT(ktable_invariant(cursor->c_table));
 	return result;
 }
+C2_EXPORTED(c2_db_cursor_del);
 
 void c2_db_buf_impl_init(struct c2_db_buf *buf)
 {
@@ -547,30 +567,31 @@ bool c2_db_buf_impl_invariant(const struct c2_db_buf *buf)
 	return true;
 }
 
-static bool ktable_invariant_locked(struct c2_table *t,
+static bool ktable_invariant_locked(struct c2_table *t, 
 				    struct c2_table_impl *ti)
 {
-	struct c2_db_kpair *scan;
-	struct c2_db_kpair *prev;
+	struct c2_db_kpair   *scan;
+	struct c2_db_kpair   *prev;
 
 	ti = &t->t_i;
 
-	if (!c2_tlist_invariant(&pair_tl, &ti->tk_pair))
+	if (!c2_list_invariant(&ti->tk_pair))
 		return false;
 
 	prev = NULL;
-	c2_tlist_for(&pair_tl, &ti->tk_pair, scan) {
+	c2_list_for_each_entry(&ti->tk_pair, scan, struct c2_db_kpair,
+			       dk_linkage) {
 		if (scan->dk_key.b_addr != scan + 1)
 			return false;
-		if (scan->dk_rec.b_addr !=
+		if (scan->dk_rec.b_addr != 
 		    scan->dk_key.b_addr + scan->dk_key.b_nob)
 			return false;
 
-		if (prev != NULL &&
+		if (prev != NULL && 
 		    key_cmp(t, &prev->dk_key, &scan->dk_key) != -1)
 			return false;
 		prev = scan;
-	} c2_tlist_endfor;
+	}
 	return true;
 }
 
@@ -578,7 +599,7 @@ static bool ktable_invariant(struct c2_table *t)
 {
 	bool                  result;
 	struct c2_table_impl *ti;
-
+	
 	ti = &t->t_i;
 
 	c2_mutex_lock(&ti->tk_lock);
@@ -589,7 +610,7 @@ static bool ktable_invariant(struct c2_table *t)
 
 /** @} end of db group */
 
-/*
+/* 
  *  Local variables:
  *  c-indentation-style: "K&R"
  *  c-basic-offset: 8
diff --git a/db/linux_kernel/db_impl.h b/db/linux_kernel/db_impl.h
index febb4ef..ce8cb95 100644
--- a/db/linux_kernel/db_impl.h
+++ b/db/linux_kernel/db_impl.h
@@ -21,7 +21,7 @@
 #ifndef __COLIBRI_DB_LINUX_KERNEL_DB_IMPL_H__
 #define __COLIBRI_DB_LINUX_KERNEL_DB_IMPL_H__
 
-#include "lib/tlist.h"
+#include "lib/list.h"
 #include "lib/mutex.h"
 
 /**
@@ -39,7 +39,7 @@ struct c2_table_impl {
 	/**
 	   Kernel "table" is simply a list of pairs in memory.
 	 */
-	struct c2_tl    tk_pair;
+	struct c2_list  tk_pair;
 	struct c2_mutex tk_lock;
 };
 
@@ -56,10 +56,9 @@ struct c2_db_tx_waiter_impl {
    (key, record) pair in a kernel memory.
  */
 struct c2_db_kpair {
-	uint64_t        dk_magix;
-	struct c2_tlink dk_linkage;
-	struct c2_buf   dk_key;
-	struct c2_buf   dk_rec;
+	struct c2_list_link dk_linkage;
+	struct c2_buf       dk_key;
+	struct c2_buf       dk_rec;
 	/* followed by dk_key.a_nob + dk_rec.a_nob bytes */
 };
 
@@ -72,7 +71,7 @@ struct c2_db_cursor_impl {
 /* __COLIBRI_DB_LINUX_KERNEL_DB_IMPL_H__ */
 #endif
 
-/*
+/* 
  *  Local variables:
  *  c-indentation-style: "K&R"
  *  c-basic-offset: 8
diff --git a/db/nobl.h b/db/nobl.h
deleted file mode 100644
index 739a1cd..0000000
--- a/db/nobl.h
+++ /dev/null
@@ -1,106 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Nikita Danilov <nikita_danilov@xyratex.com>
- * Original creation date: 08/13/2010
- */
-
-#ifndef __COLIBRI_DB_NOBL_H__
-#define __COLIBRI_DB_NOBL_H__
-
-#include "lib/chan.h"
-
-/**
-   @addtogroup db
-
-   <b>Non-blocking db interface (nobl)</b>
-
-   nobl allows non-blocking db calls where the caller remains control without
-   waiting for db operation completion. The completion is signalled later via
-   channel.
-
-   The goal of nobl is to integrate db with non-blocking request handler.
-
-   Only some db operations are supported by nobo. Others (data-base environment
-   operations, table initialisation and finalisation, flush and few others) are
-   not supposed to be called in non-blockable contexts anyway.
-
-   @{
- */
-
-/* export */
-enum c2_nobl_state;
-enum c2_nobl_opcode;
-struct c2_nobl_ctx;
-
-/**
-   A context in which nobl operation proceeds.
-
-   Context object is created by a nobl user and supplied to nobl entry
-   point. A context object is used to notify the caller about operation
-   progress and to track resources associated with the operation.
-
-   A context object is embedded into a c2_db_tx.
- */
-struct c2_nobl_ctx {
-	enum c2_nobl_opcode  nc_opcode;
-	enum c2_nobl_state   nc_state;
-	int32_t              nc_rc;
-	struct c2_chan       nc_signal;
-	struct c2_db_pair   *nc_pair;
-	struct c2_db_cursor *nc_cur;
-};
-
-enum c2_nobl_state {
-	NC_INITIALISED = 1,
-	NC_ONGOING,
-	NC_DONE
-};
-
-enum c2_nobl_opcode {
-	NOBO_TX_INIT,
-	NOBO_TX_ABORT,
-	NOBO_TX_COMMIT,
-	NOBO_TABLE_INSERT,
-	NOBO_TABLE_UPDATE,
-	NOBO_TABLE_LOOKUP,
-	NOBO_TABLE_DELETE,
-	NOBO_CURSOR_GET,
-	NOBO_CURSOR_GET,
-	NOBO_CURSOR_NEXT,
-	NOBO_CURSOR_PREV,
-	NOBO_CURSOR_FIRST,
-	NOBO_CURSOR_LAST,
-	NOBO_CURSOR_SET,
-	NOBO_CURSOR_ADD,
-	NOBO_CURSOR_DEL,
-	NOBO_NR
-};
-
-/** @} end of db group */
-
-/* __COLIBRI_DB_NOBL_H__ */
-#endif
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
diff --git a/desim/Makefile.am b/desim/Makefile.am
index 58eb55c..55a89d7 100644
--- a/desim/Makefile.am
+++ b/desim/Makefile.am
@@ -1,4 +1,4 @@
-desimdir                      = $(includedir)/colibri/desim
+desimdir                      = $(includedir)/desim
 desim_HEADERS                 = chs.h client.h cnt.h elevator.h net.h sim.h storage.h
 
 noinst_LTLIBRARIES            = libcolibri-desim.la
diff --git a/desim/chs.h b/desim/chs.h
index c0bda01..4bd1d82 100644
--- a/desim/chs.h
+++ b/desim/chs.h
@@ -14,6 +14,8 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
+ * Original author: $NAME
+ * Original creation date: MM/DD/YYYY
  */
 /*
  * Copyright 2010 ClusterStor.
diff --git a/desim/client.c b/desim/client.c
index 548be98..1d3001a 100644
--- a/desim/client.c
+++ b/desim/client.c
@@ -43,28 +43,22 @@ struct client_thread_param {
 struct client_write_ext {
 	unsigned long long  cwe_offset;
 	unsigned long       cwe_count;
-	struct c2_tlink     cwe_linkage;
-	uint64_t            cwe_magic;
+	struct c2_list_link cwe_linkage;
 };
 
-C2_TL_DESCR_DEFINE(cl, "client write extents", static, struct client_write_ext,
-		   cwe_linkage, cwe_magic, 0xFA151F1AB1EA11B1,
-		   0x0B501E5CE0FCACA0);
-C2_TL_DEFINE(cl, static, struct client_write_ext);
-
-static void client_rpc_send(struct sim_thread *t,
-			    struct client *c, struct client_conf *conf,
+static void client_rpc_send(struct sim_thread *t, 
+			    struct client *c, struct client_conf *conf, 
 			    unsigned long long offset, unsigned long count)
 {
 	struct net_rpc rpc;
 
-	net_rpc_init(&rpc, conf->cc_net, conf->cc_srv,
+	net_rpc_init(&rpc, conf->cc_net, conf->cc_srv, 
 		     c->cl_fid, offset, count);
 	net_rpc_send(t, &rpc);
 	net_rpc_bulk(t, &rpc);
 	net_rpc_fini(&rpc);
 }
-
+ 
 static void client_pageout(struct sim *s, struct sim_thread *t, void *arg)
 {
 	struct client           *c    = arg;
@@ -78,12 +72,13 @@ static void client_pageout(struct sim *s, struct sim_thread *t, void *arg)
 			if (conf->cc_shutdown)
 				sim_thread_exit(t);
 		}
-		C2_ASSERT(!cl_tlist_is_empty(&c->cl_write_ext));
-		ext = cl_tlist_head(&c->cl_write_ext);
+		C2_ASSERT(!c2_list_is_empty(&c->cl_write_ext));
+		ext = container_of(c->cl_write_ext.l_head, 
+				   struct client_write_ext, cwe_linkage);
 		/* no real cache management for now */
 		C2_ASSERT(ext->cwe_count == size);
-		cl_tlink_del_fini(ext);
-		sim_log(s, SLL_TRACE, "P%2i/%2i: %6lu %10llu %8u\n", c->cl_id,
+		c2_list_del(&ext->cwe_linkage);
+		sim_log(s, SLL_TRACE, "P%2i/%2i: %6lu %10llu %8u\n", c->cl_id, 
 			c->cl_inflight, c->cl_fid, ext->cwe_offset, size);
 		c->cl_io += size;
 		c->cl_inflight++;
@@ -121,11 +116,11 @@ static void client_write_loop(struct sim *s, struct sim_thread *t, void *arg)
 		ext = sim_alloc(sizeof *ext);
 		ext->cwe_offset = off;
 		ext->cwe_count  = count;
-		cl_tlink_init_at_tail(ext, &cl->cl_write_ext);
+		c2_list_add_tail(&cl->cl_write_ext, &ext->cwe_linkage);
 		cl->cl_cached += count;
 		cl->cl_dirty  += count;
 		sim_chan_broadcast(&cl->cl_cache_busy);
-		sim_log(s, SLL_TRACE, "W%2i/%2i: %6lu %10llu %8u\n",
+		sim_log(s, SLL_TRACE, "W%2i/%2i: %6lu %10llu %8u\n", 
 			clid, trid, cl->cl_fid, off, count);
 		nob += count;
 		off += count;
@@ -163,13 +158,13 @@ void client_init(struct sim *s, struct client_conf *conf)
 
 	cnt_init(&conf->cc_cache_free, NULL, "client::cache-free");
 	cnt_init(&conf->cc_cache_busy, NULL, "client::cache-busy");
-	conf->cc_client = sim_alloc(conf->cc_nr_clients *
+	conf->cc_client = sim_alloc(conf->cc_nr_clients * 
 				    sizeof conf->cc_client[0]);
 	for (i = 0; i < conf->cc_nr_clients; ++i) {
 		struct client *c;
 
 		c = &conf->cc_client[i];
-		cl_tlist_init(&c->cl_write_ext);
+		c2_list_init(&c->cl_write_ext);
 		c->cl_conf = conf;
 		c->cl_fid  = i;
 		c->cl_id   = i;
@@ -178,9 +173,9 @@ void client_init(struct sim *s, struct client_conf *conf)
 		c->cl_cache_free.ch_cnt_sleep.c_parent = &conf->cc_cache_free;
 		c->cl_cache_busy.ch_cnt_sleep.c_parent = &conf->cc_cache_busy;
 
-		c->cl_thread = sim_alloc(conf->cc_nr_threads *
+		c->cl_thread = sim_alloc(conf->cc_nr_threads * 
 					 sizeof c->cl_thread[0]);
-		c->cl_pageout = sim_alloc(conf->cc_inflight_max *
+		c->cl_pageout = sim_alloc(conf->cc_inflight_max * 
 					  sizeof c->cl_pageout[0]);
 	}
 	sim_timer_add(s, 0, client_threads_start, conf);
@@ -209,17 +204,17 @@ void client_fini(struct client_conf *conf)
 					sim_thread_fini(&c->cl_pageout[j]);
 				sim_free(c->cl_pageout);
 			}
-			cl_tlist_fini(&c->cl_write_ext);
+			c2_list_fini(&c->cl_write_ext);
 		}
 		sim_free(conf->cc_client);
 	}
 	cnt_fini(&conf->cc_cache_free);
 	cnt_fini(&conf->cc_cache_busy);
 }
-
+ 
 /** @} end of desim group */
 
-/*
+/* 
  *  Local variables:
  *  c-indentation-style: "K&R"
  *  c-basic-offset: 8
diff --git a/desim/client.h b/desim/client.h
index 7dc1826..f5e631a 100644
--- a/desim/client.h
+++ b/desim/client.h
@@ -27,8 +27,6 @@
    @{
  */
 
-#include "lib/tlist.h"
-
 struct net_conf;
 struct net_srv;
 
@@ -44,7 +42,7 @@ struct client {
 	struct sim_chan     cl_cache_free;
 	struct sim_chan     cl_cache_busy;
 	struct client_conf *cl_conf;
-	struct c2_tl        cl_write_ext;
+	struct c2_list      cl_write_ext;
 };
 
 struct client_conf {
@@ -73,7 +71,7 @@ void client_fini(struct client_conf *conf);
 
 /** @} end of desim group */
 
-/*
+/* 
  *  Local variables:
  *  c-indentation-style: "K&R"
  *  c-basic-offset: 8
diff --git a/desim/cnt.c b/desim/cnt.c
index ba41d17..f30b7cb 100644
--- a/desim/cnt.c
+++ b/desim/cnt.c
@@ -37,12 +37,7 @@
    @{
  */
 
-C2_TL_DESCR_DEFINE(cnts, "counters", static, struct cnt,
-		   c_linkage, c_magic, 0xFACE1E550FF1C1A1,
-		   0x5CA1AB1E011F1E1D);
-C2_TL_DEFINE(cnts, static, struct cnt);
-
-static struct c2_tl cnts;
+static struct c2_list cnts;
 
 void cnt_init(struct cnt *cnt, struct cnt *parent, const char *format, ...)
 {
@@ -55,7 +50,7 @@ void cnt_init(struct cnt *cnt, struct cnt *parent, const char *format, ...)
 	sim_name_vaset(&cnt->c_name, format, valist);
 	va_end(valist);
 	cnt->c_parent = parent;
-	cnts_tlink_init_at_tail(cnt, &cnts);
+	c2_list_add_tail(&cnts, &cnt->c_linkage);
 }
 
 void cnt_dump(struct cnt *cnt)
@@ -67,7 +62,7 @@ void cnt_dump(struct cnt *cnt)
 		avg = cnt->c_sum / cnt->c_nr;
 		sig = sqrt(cnt->c_sq/cnt->c_nr - avg*avg);
 		sim_log(NULL, SLL_INFO, "[%s: %llu (%llu) %llu %llu %f]\n",
-			cnt->c_name, avg, cnt->c_nr,
+			cnt->c_name, avg, cnt->c_nr, 
 			cnt->c_min, cnt->c_max, sig);
 	} else
 		sim_log(NULL, SLL_INFO, "[%s: empty]\n", cnt->c_name);
@@ -77,17 +72,15 @@ void cnt_dump_all(void)
 {
 	struct cnt *scan;
 
-	c2_tlist_for(&cnts_tl, &cnts, scan)
+	c2_list_for_each_entry(&cnts, scan, struct cnt, c_linkage)
 		cnt_dump(scan);
-	c2_tlist_endfor;
 }
 
 void cnt_fini(struct cnt *cnt)
 {
 	if (cnt->c_name != NULL)
 		free(cnt->c_name);
-	cnts_tlink_del_fini(cnt);
-	cnt->c_magic = 0;
+	c2_list_del(&cnt->c_linkage);
 }
 
 
@@ -106,23 +99,23 @@ void cnt_mod(struct cnt *cnt, cnt_t val)
 
 void cnt_global_init(void)
 {
-	cnts_tlist_init(&cnts);
+	c2_list_init(&cnts);
 }
 
 void cnt_global_fini(void)
 {
 	struct cnt *scan;
+	struct cnt *next;
 
-	c2_tlist_for(&cnts_tl, &cnts, scan)
+	c2_list_for_each_entry_safe(&cnts, scan, next, struct cnt, c_linkage)
 		cnt_fini(scan);
-	c2_tlist_endfor;
 
-	cnts_tlist_fini(&cnts);
+	c2_list_fini(&cnts);
 }
 
 /** @} end of desim group */
 
-/*
+/* 
  *  Local variables:
  *  c-indentation-style: "K&R"
  *  c-basic-offset: 8
diff --git a/desim/cnt.h b/desim/cnt.h
index d03d593..749ad8b 100644
--- a/desim/cnt.h
+++ b/desim/cnt.h
@@ -27,10 +27,10 @@
    @{
  */
 
-#include "lib/tlist.h"
+#include "lib/list.h"
 
 typedef unsigned long long cnt_t;
-
+ 
 struct cnt {
 	cnt_t               c_sum;
 	cnt_t               c_min;
@@ -38,12 +38,11 @@ struct cnt {
 	cnt_t               c_nr;
 	double              c_sq;
 	char               *c_name;
-	struct c2_tlink     c_linkage;
+	struct c2_list_link c_linkage;
 	struct cnt         *c_parent;
-	uint64_t            c_magic;
 };
 
-void cnt_init(struct cnt *cnt, struct cnt *parent, const char *name, ...)
+void cnt_init(struct cnt *cnt, struct cnt *parent, const char *name, ...) 
               __attribute__((format(printf, 3, 4)));
 void cnt_fini(struct cnt *cnt);
 void cnt_dump(struct cnt *cnt);
@@ -58,7 +57,7 @@ void cnt_global_fini(void);
 
 /** @} end of desim group */
 
-/*
+/* 
  *  Local variables:
  *  c-indentation-style: "K&R"
  *  c-basic-offset: 8
diff --git a/desim/elevator.c b/desim/elevator.c
index 9b645ca..660df8e 100644
--- a/desim/elevator.c
+++ b/desim/elevator.c
@@ -39,16 +39,6 @@
  * Simple FIFO elevator.
  */
 
-struct io_req {
-	struct c2_tlink ir_linkage;
-	uint64_t        ir_magic;
-};
-
-C2_TL_DESCR_DEFINE(req, "io requests", static, struct io_req,
-		   ir_linkage, ir_magic, 0xBE111C05E0DDBA11,
-		   0xFA110FFB100D1EAF);
-C2_TL_DEFINE(req, static, struct io_req);
-
 static void elevator_submit(struct elevator *el,
 			    enum storage_req_type type,
 			    sector_t sector, unsigned long count)
@@ -72,7 +62,7 @@ void el_end_io(struct storage_dev *dev)
 
 	el = dev->sd_el;
 	el->e_idle = 1;
-	if (!req_tlist_is_empty(&el->e_queue))
+	if (!c2_list_is_empty(&el->e_queue))
 		elevator_go(el);
 	sim_chan_broadcast(&el->e_wait);
 }
@@ -83,13 +73,13 @@ void elevator_init(struct elevator *el, struct storage_dev *dev)
 	el->e_idle = 1;
 	dev->sd_end_io = el_end_io;
 	dev->sd_el     = el;
-	req_tlist_init(&el->e_queue);
+	c2_list_init(&el->e_queue);
 	sim_chan_init(&el->e_wait, "xfer-queue@%p", dev);
 }
 
 void elevator_fini(struct elevator *el)
 {
-	req_tlist_fini(&el->e_queue);
+	c2_list_fini(&el->e_queue);
 	sim_chan_fini(&el->e_wait);
 }
 
@@ -103,7 +93,7 @@ void elevator_io(struct elevator *el, enum storage_req_type type,
 
 /** @} end of desim group */
 
-/*
+/* 
  *  Local variables:
  *  c-indentation-style: "K&R"
  *  c-basic-offset: 8
diff --git a/desim/elevator.h b/desim/elevator.h
index a04b569..f0f72b6 100644
--- a/desim/elevator.h
+++ b/desim/elevator.h
@@ -24,7 +24,7 @@
 
 #include "desim/sim.h"
 #include "desim/storage.h"
-#include "lib/tlist.h"
+#include "lib/list.h"
 
 /**
    @addtogroup desim desim
@@ -34,7 +34,7 @@
 struct elevator {
 	struct storage_dev *e_dev;
 	int                 e_idle;
-	struct c2_tl        e_queue;
+	struct c2_list      e_queue;
 	struct sim_chan     e_wait;
 };
 
@@ -48,7 +48,7 @@ void elevator_io(struct elevator *el, enum storage_req_type type,
 
 /** @} end of desim group */
 
-/*
+/* 
  *  Local variables:
  *  c-indentation-style: "K&R"
  *  c-basic-offset: 8
diff --git a/desim/net.c b/desim/net.c
index 13ed086..07cb3f9 100644
--- a/desim/net.c
+++ b/desim/net.c
@@ -35,11 +35,6 @@
    @{
  */
 
-C2_TL_DESCR_DEFINE(rpc, "rpcs", static, struct net_rpc,
-		   nr_inqueue, nr_magic, 0xACCE551B1E0FF1CE,
-		   0xA55A11AB1E5EABED);
-C2_TL_DEFINE(rpc, static, struct net_rpc);
-
 static void net_srv_loop(struct sim *s, struct sim_thread *t, void *arg)
 {
 	struct net_srv *srv = arg;
@@ -57,24 +52,25 @@ static void net_srv_loop(struct sim *s, struct sim_thread *t, void *arg)
 		unsigned long long count;
 		unsigned long long offset;
 
-		while (rpc_tlist_is_empty(&srv->ns_queue)) {
+		while (c2_list_is_empty(&srv->ns_queue)) {
 			sim_chan_wait(&srv->ns_incoming, t);
 			if (srv->ns_shutdown)
 				sim_thread_exit(t);
 		}
 
 		srv->ns_active++;
-		rpc = rpc_tlist_head(&srv->ns_queue);
-		rpc_tlist_del(rpc);
+		rpc = container_of(srv->ns_queue.l_head, 
+				   struct net_rpc, nr_inqueue);
+		c2_list_del(&rpc->nr_inqueue);
 		count = rpc->nr_todo;
 		offset = srv->ns_file_size * rpc->nr_fid + rpc->nr_offset;
 
-		sim_log(s, SLL_TRACE, "S%2i/%2i: %6lu %10llu %8lu %10llu\n",
+		sim_log(s, SLL_TRACE, "S%2i/%2i: %6lu %10llu %8lu %10llu\n", 
 			trid, srv->ns_active,
 			rpc->nr_fid, rpc->nr_offset, rpc->nr_todo, offset);
 		rpc->nr_srv_thread = t;
 		/* delay before bulk */
-		sim_sleep(t, sim_rnd(srv->ns_pre_bulk_min,
+		sim_sleep(t, sim_rnd(srv->ns_pre_bulk_min, 
 				     srv->ns_pre_bulk_max));
 		sim_chan_signal(&rpc->nr_wait);
 		/* wait for bulk completion */
@@ -99,9 +95,9 @@ static int net_srv_threads_start(struct sim_callout *call)
 
 void net_srv_init(struct sim *s, struct net_srv *srv)
 {
-	rpc_tlist_init(&srv->ns_queue);
+	c2_list_init(&srv->ns_queue);
 	sim_chan_init(&srv->ns_incoming, "srv::incoming");
-	srv->ns_thread = sim_alloc(srv->ns_nr_threads *
+	srv->ns_thread = sim_alloc(srv->ns_nr_threads * 
 				   sizeof srv->ns_thread[0]);
 	sim_timer_add(s, 0, net_srv_threads_start, srv);
 }
@@ -110,7 +106,7 @@ void net_srv_fini(struct net_srv *srv)
 {
 	int i;
 
-	rpc_tlist_fini(&srv->ns_queue);
+	c2_list_fini(&srv->ns_queue);
 	srv->ns_shutdown = 1;
 	sim_chan_broadcast(&srv->ns_incoming);
 
@@ -145,7 +141,6 @@ void net_rpc_init(struct net_rpc *rpc, struct net_conf *conf,
 	rpc->nr_fid    = fid;
 	rpc->nr_offset = offset;
 	rpc->nr_todo   = nob;
-	rpc_tlink_init(rpc);
 	sim_chan_init(&rpc->nr_wait, NULL);
 	sim_chan_init(&rpc->nr_bulk_wait, NULL);
 	rpc->nr_wait.ch_cnt_sleep.c_parent = &conf->nc_rpc_wait;
@@ -155,13 +150,11 @@ void net_rpc_init(struct net_rpc *rpc, struct net_conf *conf,
 void net_rpc_fini(struct net_rpc *rpc)
 {
 	C2_ASSERT(rpc->nr_todo == 0);
-	rpc_tlink_fini(rpc);
 	sim_chan_fini(&rpc->nr_wait);
 	sim_chan_fini(&rpc->nr_bulk_wait);
-	rpc->nr_magic = 0;
 }
 
-static void net_enter(struct sim_thread *t, struct net_conf *n,
+static void net_enter(struct sim_thread *t, struct net_conf *n, 
 		      unsigned long nob)
 {
 	while (n->nc_nob_inflight + nob > n->nc_nob_max ||
@@ -188,7 +181,7 @@ static void net_tx(struct sim_thread *t, struct net_conf *n,
 	sim_sleep(t, sim_rnd(min, max));
 	net_leave(t, n, nob);
 }
-
+	    
 void net_rpc_send(struct sim_thread *t, struct net_rpc *rpc)
 {
 	struct net_conf *n;
@@ -196,7 +189,7 @@ void net_rpc_send(struct sim_thread *t, struct net_rpc *rpc)
 	n = rpc->nr_conf;
 	net_tx(t, n, n->nc_rpc_size, n->nc_rpc_delay_min, n->nc_rpc_delay_max);
 	sim_chan_signal(&rpc->nr_srv->ns_incoming);
-	rpc_tlist_add_tail(&rpc->nr_srv->ns_queue, rpc);
+	c2_list_add_tail(&rpc->nr_srv->ns_queue, &rpc->nr_inqueue);
 	sim_chan_wait(&rpc->nr_wait, t);
 	net_tx(t, n, n->nc_rpc_size, n->nc_rpc_delay_min, n->nc_rpc_delay_max);
 }
@@ -217,7 +210,7 @@ void net_rpc_bulk(struct sim_thread *t, struct net_rpc *rpc)
 
 /** @} end of desim group */
 
-/*
+/* 
  *  Local variables:
  *  c-indentation-style: "K&R"
  *  c-basic-offset: 8
diff --git a/desim/net.h b/desim/net.h
index 3282eef..bc0281d 100644
--- a/desim/net.h
+++ b/desim/net.h
@@ -22,7 +22,6 @@
 #ifndef NET_H
 #define NET_H
 
-#include "lib/tlist.h"
 #include "desim/sim.h"
 
 /**
@@ -55,7 +54,7 @@ struct net_srv {
 	sim_time_t          ns_pre_bulk_min;
 	sim_time_t          ns_pre_bulk_max;
 	struct sim_chan     ns_incoming;
-	struct c2_tl        ns_queue;
+	struct c2_list      ns_queue;
 	struct sim_thread  *ns_thread;
 	struct elevator    *ns_el;
 	unsigned long long  ns_file_size;
@@ -67,13 +66,12 @@ struct net_rpc {
 	struct net_srv     *nr_srv;
 	struct net_conf    *nr_conf;
 	unsigned long       nr_fid;
-	unsigned long long  nr_offset;
+	unsigned long long  nr_offset;    
 	unsigned long       nr_todo;
-	struct c2_tlink     nr_inqueue;
+	struct c2_list_link nr_inqueue;
 	struct sim_chan     nr_wait;
 	struct sim_chan     nr_bulk_wait;
 	struct sim_thread  *nr_srv_thread;
-	uint64_t            nr_magic;
 };
 
 void net_srv_init(struct sim *s, struct net_srv *srv);
@@ -93,7 +91,7 @@ void net_rpc_bulk(struct sim_thread *t, struct net_rpc *rpc);
 
 /** @} end of desim group */
 
-/*
+/* 
  *  Local variables:
  *  c-indentation-style: "K&R"
  *  c-basic-offset: 8
diff --git a/desim/sim.c b/desim/sim.c
index ee5603f..761bf22 100644
--- a/desim/sim.c
+++ b/desim/sim.c
@@ -39,16 +39,6 @@
    @{
  */
 
-C2_TL_DESCR_DEFINE(ca, "call-outs", static, struct sim_callout,
-		   sc_linkage, sc_magic, 0xADDED0FF1C1A1E5E,
-		   0xEFFACEAB1E1ADD1E);
-C2_TL_DEFINE(ca, static, struct sim_callout);
-
-C2_TL_DESCR_DEFINE(thr, "threads", static, struct sim_thread,
-		   st_block, st_magic, 0x10ADEDC0110CA11A,
-		   0xCEA5E1E551CEFA11);
-C2_TL_DEFINE(thr, static, struct sim_thread);
-
 extern int vasprintf(char **strp, const char *fmt, va_list ap);
 
 #if 0
@@ -108,7 +98,7 @@ void sim_free(void *ptr)
 void sim_init(struct sim *state)
 {
 	state->ss_bolt = 0;
-	ca_tlist_init(&state->ss_future);
+	c2_list_init(&state->ss_future);
 	getcontext(&sim_idle_ctx);
 }
 
@@ -117,7 +107,7 @@ void sim_init(struct sim *state)
  */
 void sim_fini(struct sim *state)
 {
-	ca_tlist_fini(&state->ss_future);
+	c2_list_fini(&state->ss_future);
 }
 
 /**
@@ -134,13 +124,14 @@ void sim_run(struct sim *state)
 	unsigned long i;
 
 	i = 0;
-	while (!ca_tlist_is_empty(&state->ss_future)) {
+	while (!c2_list_is_empty(&state->ss_future)) {
 		C2_ASSERT(sim_current == NULL);
-		call = ca_tlist_head(&state->ss_future);
+		call = container_of(state->ss_future.l_head, struct sim_callout,
+				    sc_linkage);
 		C2_ASSERT(call->sc_time >= state->ss_bolt);
 		/* jump to the future */
 		state->ss_bolt = call->sc_time;
-		ca_tlist_del(call);
+		c2_list_del(&call->sc_linkage);
 		if (call->sc_call(call))
 			/*
 			 * timer wasn't rearmed.
@@ -163,17 +154,16 @@ static void sim_call_place(struct sim *sim, struct sim_callout *call)
 	 * data structure, like a tree or a skip-list of some sort.
 	 */
 
-	c2_tlist_for(&ca_tl, &sim->ss_future, scan) {
-		if (scan->sc_time > call->sc_time) {
-			ca_tlist_add_before(scan, call);
-			return;
-		}
-	} c2_tlist_endfor;
-	ca_tlist_add_tail(&sim->ss_future, call);
+	c2_list_for_each_entry(&sim->ss_future, scan, 
+			       struct sim_callout, sc_linkage) {
+		if (scan->sc_time > call->sc_time)
+			break;
+	}
+	c2_list_add_before(&scan->sc_linkage, &call->sc_linkage);
 }
 
 /**
- * Initialize callout
+ * Initialize callout 
  */
 static void sim_timer_init(struct sim *state, struct sim_callout *call,
 			   sim_time_t delta, sim_call_t *cfunc, void *datum)
@@ -183,7 +173,6 @@ static void sim_timer_init(struct sim *state, struct sim_callout *call,
 	call->sc_call  = cfunc;
 	call->sc_datum = datum;
 	call->sc_sim   = state;
-	ca_tlink_init(call);
 	sim_call_place(state, call);
 }
 
@@ -250,45 +239,6 @@ static void sim_thread_suspend(struct sim_thread *thread)
 	sim_thread_fix(thread);
 }
 
-/*
- * The sim{en,de}code*() and sim_trampoline() functions below are for
- * portability: makecontext(3) creates a context to execute a supplied function
- * with a given number of integer (int) arguments. To pass non-integer
- * parameters (pointers), they have to be encoded as integers.
- *
- * Very simple encoding scheme is used, where each pointer is encoded as a
- * couple of integers.
- *
- * Note, that this is not an idle experiment in obfuscation: in some
- * configurations alignments of integer and pointer types are different.
- */
-
-static void *sim_decode(int p0, int p1)
-{
-	return (void *)((((uint64_t)p0) << 32) | (((uint64_t)p1) & 0xffffffff));
-}
-
-static int sim_encode0(void *p)
-{
-	return ((uint64_t)p) >> 32;
-}
-
-static int sim_encode1(void *p)
-{
-	return ((uint64_t)p) & 0xffffffff;
-}
-
-static void sim_trampoline(int func0, int func1,
-			   int state0, int state1, int thread0, int thread1,
-			   int datum0, int datum1)
-{
-	sim_func_t *func;
-
-	func = sim_decode(func0, func1);
-	func(sim_decode(state0, state1), sim_decode(thread0, thread1),
-	     sim_decode(datum0, datum1));
-}
-
 /**
  * Initialize and start a new simulation thread that will be running a function
  * func with an argument arg.
@@ -321,15 +271,9 @@ void sim_thread_init(struct sim *state, struct sim_thread *thread,
 	thread->st_ctx.uc_stack.ss_sp    = thread->st_stack = valloc(stacksize);
 	thread->st_ctx.uc_stack.ss_size  = thread->st_size = stacksize;
 	thread->st_ctx.uc_stack.ss_flags = 0;
-	thr_tlink_init(thread);
 	if (thread->st_stack == NULL)
 		err(1, "malloc(%d) of a stack", stacksize);
-	makecontext(&thread->st_ctx, (void (*)())sim_trampoline,
-		    8,
-		    sim_encode0(func),   sim_encode1(func),
-		    sim_encode0(state),  sim_encode1(state),
-		    sim_encode0(thread), sim_encode1(thread),
-		    sim_encode0(arg),    sim_encode1(arg));
+	makecontext(&thread->st_ctx, (void (*)())func, 3, state, thread, arg);
 	sim_thread_resume(thread);
 }
 
@@ -338,7 +282,6 @@ void sim_thread_init(struct sim *state, struct sim_thread *thread,
  */
 void sim_thread_fini(struct sim_thread *thread)
 {
-	thr_tlink_fini(thread);
 	if (thread->st_stack != NULL)
 		sim_free(thread->st_stack);
 }
@@ -364,7 +307,7 @@ static int sim_wakeup(struct sim_callout *call)
 /**
  * Schedule a thread wake-up after a given amount of logical time.
  */
-static void sim_wakeup_post(struct sim *sim,
+static void sim_wakeup_post(struct sim *sim, 
 			    struct sim_thread *thread, sim_time_t nap)
 {
 	sim_timer_init(sim, &thread->st_wake, nap, sim_wakeup, thread);
@@ -388,7 +331,7 @@ void sim_sleep(struct sim_thread *thread, sim_time_t nap)
  */
 void sim_chan_init(struct sim_chan *chan, char *format, ...)
 {
-	thr_tlist_init(&chan->ch_threads);
+	c2_list_init(&chan->ch_threads);
 	cnt_init(&chan->ch_cnt_sleep, NULL, "chan#%p", chan);
 	if (format != NULL) {
 		va_list varg;
@@ -403,7 +346,7 @@ void sim_chan_init(struct sim_chan *chan, char *format, ...)
  */
 void sim_chan_fini(struct sim_chan *chan)
 {
-	thr_tlist_fini(&chan->ch_threads);
+	c2_list_init(&chan->ch_threads);
 	cnt_fini(&chan->ch_cnt_sleep);
 }
 
@@ -415,7 +358,7 @@ void sim_chan_fini(struct sim_chan *chan)
 void sim_chan_wait(struct sim_chan *chan, struct sim_thread *thread)
 {
 	C2_ASSERT(sim_current == thread);
-	thr_tlist_add_tail(&chan->ch_threads, thread);
+	c2_list_add_tail(&chan->ch_threads, &thread->st_block);
 	/*
 	 * The simplest way to measure the time threads are blocked on a channel
 	 * is to modify sim_chan::ch_cmt_sleep in this function, right after
@@ -440,8 +383,8 @@ static void sim_chan_wake_head(struct sim_chan *chan)
 {
 	struct sim_thread *t;
 
-	t = thr_tlist_head(&chan->ch_threads);
-	thr_tlist_del(t);
+	t = container_of(chan->ch_threads.l_head, struct sim_thread, st_block);
+	c2_list_del(&t->st_block);
 	cnt_mod(&chan->ch_cnt_sleep, t->st_sim->ss_bolt - t->st_blocked);
 	sim_wakeup_post(t->st_sim, t, 0);
 }
@@ -451,7 +394,7 @@ static void sim_chan_wake_head(struct sim_chan *chan)
  */
 void sim_chan_signal(struct sim_chan *chan)
 {
-	if (!thr_tlist_is_empty(&chan->ch_threads))
+	if (!c2_list_is_empty(&chan->ch_threads))
 		sim_chan_wake_head(chan);
 }
 
@@ -460,7 +403,7 @@ void sim_chan_signal(struct sim_chan *chan)
  */
 void sim_chan_broadcast(struct sim_chan *chan)
 {
-	if (!thr_tlist_is_empty(&chan->ch_threads))
+	while (!c2_list_is_empty(&chan->ch_threads))
 		sim_chan_wake_head(chan);
 }
 
@@ -556,7 +499,7 @@ void sim_global_fini(void)
 
 /** @} end of desim group */
 
-/*
+/* 
  *  Local variables:
  *  c-indentation-style: "K&R"
  *  c-basic-offset: 8
diff --git a/desim/sim.h b/desim/sim.h
index ed003de..190e5f1 100644
--- a/desim/sim.h
+++ b/desim/sim.h
@@ -57,9 +57,9 @@
 
    struct sim_callout represents a parametrized event scheduled for some future
    time ("callout" is a traditional UNIX name for this).
-
+   
    Sequential threads are simulated with two more data types:
-
+   
    struct sim_thread represents a simulated thread. struct sim_chan represents a
    channel (in UNIX kernel sense) that threads can synchronize on. sim_thread is
    relatively lightweight. Current implementation is based on ucontext_t calls
@@ -94,7 +94,7 @@
 #include <stdarg.h>
 
 #if defined(__APPLE__)
-/* for ucontext:
+/* for ucontext: 
    http://lists.apple.com/archives/darwin-dev/2008/Jan/msg00229.html */
 #define _XOPEN_SOURCE
 #endif
@@ -102,7 +102,7 @@
 #include <stdlib.h>
 #include <ucontext.h>
 
-#include "lib/tlist.h"
+#include "lib/list.h"
 #include "desim/cnt.h"
 
 struct sim;
@@ -125,21 +125,20 @@ typedef void sim_func_t(struct sim *, struct sim_thread *, void *);
 struct sim_callout {
 	/** logical time for which the call-out is scheduled */
 	sim_time_t         sc_time;
-	/**
+	/** 
 	 * call-back function to be invoked when the logical time is ripe. If
 	 * call-back function returns true (non-0), main simulation loop frees
 	 * the call-out structure (this is suitable for one-shot call-outs),
 	 * otherwise it is up to the call-out creator to clean up. */
 	sim_call_t         *sc_call;
-	/**
+	/** 
 	 * a datum, opaque for generic simulation code, attached to the
 	 * call-out. This field is for private use by call-back function */
 	void               *sc_datum;
 	/** linkage into a logical time list sim::ss_future */
-	struct c2_tlink     sc_linkage;
+	struct c2_list_link sc_linkage;
 	/** simulation run this call-out is an event in */
 	struct sim         *sc_sim;
-	uint64_t            sc_magic;
 };
 
 /**
@@ -161,11 +160,11 @@ struct sim {
 	 * sim_callout::sc_time field. This list represents of future events,
 	 * still to be executed by the simulation loop.
 	 */
-	struct c2_tl       ss_future;
+	struct c2_list      ss_future;
 };
 
 /**
- * A thread in a simulated world.
+ * A thread in a simulated world. 
  *
  * Conceptually, a thread can always be replaced by a collection of call-outs. A
  * thread is advantageous and natural to use when there is a lot of state to be
@@ -205,22 +204,21 @@ struct sim_thread {
 	void               *st_stack;
 	/** size of allocated stack */
 	unsigned            st_size;
-	/**
+	/** 
 	 * platform-independent structure holding thread machine state
 	 * (registers and signals mask usually) */
 	ucontext_t          st_ctx;
 	/* channel waiting */
 	/** linkage into a sim_chan::ch_threads list */
-	struct c2_tlink     st_block;
+	struct c2_list_link st_block;
 	/**
 	   time when a thread was parked onto a channel. See sim_chan_wait()
 	   comments. */
 	sim_time_t          st_blocked;
-	/**
+	/** 
 	    pre-allocated callout to wake the thread. Used by sim_sleep() and
 	    sim_chan_{signal,broadcast}(). */
 	struct sim_callout  st_wake;
-	uint64_t            st_magic;
 };
 
 /**
@@ -235,8 +233,8 @@ struct sim_thread {
  */
 struct sim_chan {
 	/** list of threads waiting on a channel */
-	struct c2_tl        ch_threads;
-	/**
+	struct c2_list      ch_threads;
+	/** 
 	    statistical counter measuring for how long threads are sleeping on
 	    this channel */
 	struct cnt          ch_cnt_sleep;
@@ -295,7 +293,7 @@ void sim_global_fini(void);
 
 /** @} end of desim group */
 
-/*
+/* 
  *  Local variables:
  *  c-indentation-style: "K&R"
  *  c-basic-offset: 8
diff --git a/doc/Doxyfile b/doc/Doxyfile
index cc638e6..00d7fcb 100644
--- a/doc/Doxyfile
+++ b/doc/Doxyfile
@@ -14,76 +14,76 @@
 # Project related configuration options
 #---------------------------------------------------------------------------
 
-# This tag specifies the encoding used for all characters in the config file
-# that follow. The default is UTF-8 which is also the encoding used for all
-# text before the first occurrence of this tag. Doxygen uses libiconv (or the
-# iconv built into libc) for the transcoding. See
+# This tag specifies the encoding used for all characters in the config file 
+# that follow. The default is UTF-8 which is also the encoding used for all 
+# text before the first occurrence of this tag. Doxygen uses libiconv (or the 
+# iconv built into libc) for the transcoding. See 
 # http://www.gnu.org/software/libiconv for the list of possible encodings.
 
 DOXYFILE_ENCODING      = UTF-8
 
-# The PROJECT_NAME tag is a single word (or a sequence of words surrounded
+# The PROJECT_NAME tag is a single word (or a sequence of words surrounded 
 # by quotes) that should identify the project.
 
 PROJECT_NAME           = colibri
 
-# The PROJECT_NUMBER tag can be used to enter a project or revision number.
-# This could be handy for archiving the generated documentation or
+# The PROJECT_NUMBER tag can be used to enter a project or revision number. 
+# This could be handy for archiving the generated documentation or 
 # if some version control system is used.
 
 PROJECT_NUMBER         = T0
 
-# The OUTPUT_DIRECTORY tag is used to specify the (relative or absolute)
-# base path where the generated documentation will be put.
-# If a relative path is entered, it will be relative to the location
+# The OUTPUT_DIRECTORY tag is used to specify the (relative or absolute) 
+# base path where the generated documentation will be put. 
+# If a relative path is entered, it will be relative to the location 
 # where doxygen was started. If left blank the current directory will be used.
 
 OUTPUT_DIRECTORY       = doc
 
-# If the CREATE_SUBDIRS tag is set to YES, then doxygen will create
-# 4096 sub-directories (in 2 levels) under the output directory of each output
-# format and will distribute the generated files over these directories.
-# Enabling this option can be useful when feeding doxygen a huge amount of
-# source files, where putting all generated files in the same directory would
+# If the CREATE_SUBDIRS tag is set to YES, then doxygen will create 
+# 4096 sub-directories (in 2 levels) under the output directory of each output 
+# format and will distribute the generated files over these directories. 
+# Enabling this option can be useful when feeding doxygen a huge amount of 
+# source files, where putting all generated files in the same directory would 
 # otherwise cause performance problems for the file system.
 
 CREATE_SUBDIRS         = NO
 
-# The OUTPUT_LANGUAGE tag is used to specify the language in which all
-# documentation generated by doxygen is written. Doxygen will use this
-# information to generate all constant output in the proper language.
-# The default language is English, other supported languages are:
-# Afrikaans, Arabic, Brazilian, Catalan, Chinese, Chinese-Traditional,
-# Croatian, Czech, Danish, Dutch, Esperanto, Farsi, Finnish, French, German,
-# Greek, Hungarian, Italian, Japanese, Japanese-en (Japanese with English
-# messages), Korean, Korean-en, Lithuanian, Norwegian, Macedonian, Persian,
-# Polish, Portuguese, Romanian, Russian, Serbian, Serbian-Cyrilic, Slovak,
+# The OUTPUT_LANGUAGE tag is used to specify the language in which all 
+# documentation generated by doxygen is written. Doxygen will use this 
+# information to generate all constant output in the proper language. 
+# The default language is English, other supported languages are: 
+# Afrikaans, Arabic, Brazilian, Catalan, Chinese, Chinese-Traditional, 
+# Croatian, Czech, Danish, Dutch, Esperanto, Farsi, Finnish, French, German, 
+# Greek, Hungarian, Italian, Japanese, Japanese-en (Japanese with English 
+# messages), Korean, Korean-en, Lithuanian, Norwegian, Macedonian, Persian, 
+# Polish, Portuguese, Romanian, Russian, Serbian, Serbian-Cyrilic, Slovak, 
 # Slovene, Spanish, Swedish, Ukrainian, and Vietnamese.
 
 OUTPUT_LANGUAGE        = English
 
-# If the BRIEF_MEMBER_DESC tag is set to YES (the default) Doxygen will
-# include brief member descriptions after the members that are listed in
-# the file and class documentation (similar to JavaDoc).
+# If the BRIEF_MEMBER_DESC tag is set to YES (the default) Doxygen will 
+# include brief member descriptions after the members that are listed in 
+# the file and class documentation (similar to JavaDoc). 
 # Set to NO to disable this.
 
 BRIEF_MEMBER_DESC      = YES
 
-# If the REPEAT_BRIEF tag is set to YES (the default) Doxygen will prepend
-# the brief description of a member or function before the detailed description.
-# Note: if both HIDE_UNDOC_MEMBERS and BRIEF_MEMBER_DESC are set to NO, the
+# If the REPEAT_BRIEF tag is set to YES (the default) Doxygen will prepend 
+# the brief description of a member or function before the detailed description. 
+# Note: if both HIDE_UNDOC_MEMBERS and BRIEF_MEMBER_DESC are set to NO, the 
 # brief descriptions will be completely suppressed.
 
 REPEAT_BRIEF           = YES
 
-# This tag implements a quasi-intelligent brief description abbreviator
-# that is used to form the text in various listings. Each string
-# in this list, if found as the leading text of the brief description, will be
-# stripped from the text and the result after processing the whole list, is
-# used as the annotated text. Otherwise, the brief description is used as-is.
-# If left blank, the following values are used ("$name" is automatically
-# replaced with the name of the entity): "The $name class" "The $name widget"
-# "The $name file" "is" "provides" "specifies" "contains"
+# This tag implements a quasi-intelligent brief description abbreviator 
+# that is used to form the text in various listings. Each string 
+# in this list, if found as the leading text of the brief description, will be 
+# stripped from the text and the result after processing the whole list, is 
+# used as the annotated text. Otherwise, the brief description is used as-is. 
+# If left blank, the following values are used ("$name" is automatically 
+# replaced with the name of the entity): "The $name class" "The $name widget" 
+# "The $name file" "is" "provides" "specifies" "contains" 
 # "represents" "a" "an" "the"
 
 ABBREVIATE_BRIEF       = "The $name class" \
@@ -98,203 +98,203 @@ ABBREVIATE_BRIEF       = "The $name class" \
                          an \
                          the
 
-# If the ALWAYS_DETAILED_SEC and REPEAT_BRIEF tags are both set to YES then
-# Doxygen will generate a detailed section even if there is only a brief
+# If the ALWAYS_DETAILED_SEC and REPEAT_BRIEF tags are both set to YES then 
+# Doxygen will generate a detailed section even if there is only a brief 
 # description.
 
 ALWAYS_DETAILED_SEC    = NO
 
-# If the INLINE_INHERITED_MEMB tag is set to YES, doxygen will show all
-# inherited members of a class in the documentation of that class as if those
-# members were ordinary class members. Constructors, destructors and assignment
+# If the INLINE_INHERITED_MEMB tag is set to YES, doxygen will show all 
+# inherited members of a class in the documentation of that class as if those 
+# members were ordinary class members. Constructors, destructors and assignment 
 # operators of the base classes will not be shown.
 
 INLINE_INHERITED_MEMB  = NO
 
-# If the FULL_PATH_NAMES tag is set to YES then Doxygen will prepend the full
-# path before files name in the file list and in the header files. If set
+# If the FULL_PATH_NAMES tag is set to YES then Doxygen will prepend the full 
+# path before files name in the file list and in the header files. If set 
 # to NO the shortest path that makes the file name unique will be used.
 
 FULL_PATH_NAMES        = YES
 
-# If the FULL_PATH_NAMES tag is set to YES then the STRIP_FROM_PATH tag
-# can be used to strip a user-defined part of the path. Stripping is
-# only done if one of the specified strings matches the left-hand part of
-# the path. The tag can be used to show relative paths in the file list.
-# If left blank the directory from which doxygen is run is used as the
+# If the FULL_PATH_NAMES tag is set to YES then the STRIP_FROM_PATH tag 
+# can be used to strip a user-defined part of the path. Stripping is 
+# only done if one of the specified strings matches the left-hand part of 
+# the path. The tag can be used to show relative paths in the file list. 
+# If left blank the directory from which doxygen is run is used as the 
 # path to strip.
 
-STRIP_FROM_PATH        =
+STRIP_FROM_PATH        = 
 
-# The STRIP_FROM_INC_PATH tag can be used to strip a user-defined part of
-# the path mentioned in the documentation of a class, which tells
-# the reader which header file to include in order to use a class.
-# If left blank only the name of the header file containing the class
-# definition is used. Otherwise one should specify the include paths that
+# The STRIP_FROM_INC_PATH tag can be used to strip a user-defined part of 
+# the path mentioned in the documentation of a class, which tells 
+# the reader which header file to include in order to use a class. 
+# If left blank only the name of the header file containing the class 
+# definition is used. Otherwise one should specify the include paths that 
 # are normally passed to the compiler using the -I flag.
 
-STRIP_FROM_INC_PATH    =
+STRIP_FROM_INC_PATH    = 
 
-# If the SHORT_NAMES tag is set to YES, doxygen will generate much shorter
-# (but less readable) file names. This can be useful is your file systems
+# If the SHORT_NAMES tag is set to YES, doxygen will generate much shorter 
+# (but less readable) file names. This can be useful is your file systems 
 # doesn't support long names like on DOS, Mac, or CD-ROM.
 
 SHORT_NAMES            = NO
 
-# If the JAVADOC_AUTOBRIEF tag is set to YES then Doxygen
-# will interpret the first line (until the first dot) of a JavaDoc-style
-# comment as the brief description. If set to NO, the JavaDoc
-# comments will behave just like regular Qt-style comments
+# If the JAVADOC_AUTOBRIEF tag is set to YES then Doxygen 
+# will interpret the first line (until the first dot) of a JavaDoc-style 
+# comment as the brief description. If set to NO, the JavaDoc 
+# comments will behave just like regular Qt-style comments 
 # (thus requiring an explicit @brief command for a brief description.)
 
 JAVADOC_AUTOBRIEF      = NO
 
-# If the QT_AUTOBRIEF tag is set to YES then Doxygen will
-# interpret the first line (until the first dot) of a Qt-style
-# comment as the brief description. If set to NO, the comments
-# will behave just like regular Qt-style comments (thus requiring
+# If the QT_AUTOBRIEF tag is set to YES then Doxygen will 
+# interpret the first line (until the first dot) of a Qt-style 
+# comment as the brief description. If set to NO, the comments 
+# will behave just like regular Qt-style comments (thus requiring 
 # an explicit \brief command for a brief description.)
 
 QT_AUTOBRIEF           = NO
 
-# The MULTILINE_CPP_IS_BRIEF tag can be set to YES to make Doxygen
-# treat a multi-line C++ special comment block (i.e. a block of //! or ///
-# comments) as a brief description. This used to be the default behaviour.
-# The new default is to treat a multi-line C++ comment block as a detailed
+# The MULTILINE_CPP_IS_BRIEF tag can be set to YES to make Doxygen 
+# treat a multi-line C++ special comment block (i.e. a block of //! or /// 
+# comments) as a brief description. This used to be the default behaviour. 
+# The new default is to treat a multi-line C++ comment block as a detailed 
 # description. Set this tag to YES if you prefer the old behaviour instead.
 
 MULTILINE_CPP_IS_BRIEF = NO
 
-# If the INHERIT_DOCS tag is set to YES (the default) then an undocumented
-# member inherits the documentation from any documented member that it
+# If the INHERIT_DOCS tag is set to YES (the default) then an undocumented 
+# member inherits the documentation from any documented member that it 
 # re-implements.
 
 INHERIT_DOCS           = YES
 
-# If the SEPARATE_MEMBER_PAGES tag is set to YES, then doxygen will produce
-# a new page for each member. If set to NO, the documentation of a member will
+# If the SEPARATE_MEMBER_PAGES tag is set to YES, then doxygen will produce 
+# a new page for each member. If set to NO, the documentation of a member will 
 # be part of the file/class/namespace that contains it.
 
 SEPARATE_MEMBER_PAGES  = NO
 
-# The TAB_SIZE tag can be used to set the number of spaces in a tab.
+# The TAB_SIZE tag can be used to set the number of spaces in a tab. 
 # Doxygen uses this value to replace tabs by spaces in code fragments.
 
 TAB_SIZE               = 8
 
-# This tag can be used to specify a number of aliases that acts
-# as commands in the documentation. An alias has the form "name=value".
-# For example adding "sideeffect=\par Side Effects:\n" will allow you to
-# put the command \sideeffect (or @sideeffect) in the documentation, which
-# will result in a user-defined paragraph with heading "Side Effects:".
+# This tag can be used to specify a number of aliases that acts 
+# as commands in the documentation. An alias has the form "name=value". 
+# For example adding "sideeffect=\par Side Effects:\n" will allow you to 
+# put the command \sideeffect (or @sideeffect) in the documentation, which 
+# will result in a user-defined paragraph with heading "Side Effects:". 
 # You can put \n's in the value part of an alias to insert newlines.
 
-ALIASES                =
+ALIASES                = 
 
-# Set the OPTIMIZE_OUTPUT_FOR_C tag to YES if your project consists of C
-# sources only. Doxygen will then generate output that is more tailored for C.
-# For instance, some of the names that are used will be different. The list
+# Set the OPTIMIZE_OUTPUT_FOR_C tag to YES if your project consists of C 
+# sources only. Doxygen will then generate output that is more tailored for C. 
+# For instance, some of the names that are used will be different. The list 
 # of all members will be omitted, etc.
 
 OPTIMIZE_OUTPUT_FOR_C  = YES
 
-# Set the OPTIMIZE_OUTPUT_JAVA tag to YES if your project consists of Java
-# sources only. Doxygen will then generate output that is more tailored for
-# Java. For instance, namespaces will be presented as packages, qualified
+# Set the OPTIMIZE_OUTPUT_JAVA tag to YES if your project consists of Java 
+# sources only. Doxygen will then generate output that is more tailored for 
+# Java. For instance, namespaces will be presented as packages, qualified 
 # scopes will look different, etc.
 
 OPTIMIZE_OUTPUT_JAVA   = NO
 
-# Set the OPTIMIZE_FOR_FORTRAN tag to YES if your project consists of Fortran
-# sources only. Doxygen will then generate output that is more tailored for
+# Set the OPTIMIZE_FOR_FORTRAN tag to YES if your project consists of Fortran 
+# sources only. Doxygen will then generate output that is more tailored for 
 # Fortran.
 
 OPTIMIZE_FOR_FORTRAN   = NO
 
-# Set the OPTIMIZE_OUTPUT_VHDL tag to YES if your project consists of VHDL
-# sources. Doxygen will then generate output that is tailored for
+# Set the OPTIMIZE_OUTPUT_VHDL tag to YES if your project consists of VHDL 
+# sources. Doxygen will then generate output that is tailored for 
 # VHDL.
 
 OPTIMIZE_OUTPUT_VHDL   = NO
 
-# Doxygen selects the parser to use depending on the extension of the files it parses.
-# With this tag you can assign which parser to use for a given extension.
-# Doxygen has a built-in mapping, but you can override or extend it using this tag.
-# The format is ext=language, where ext is a file extension, and language is one of
-# the parsers supported by doxygen: IDL, Java, Javascript, C#, C, C++, D, PHP,
-# Objective-C, Python, Fortran, VHDL, C, C++. For instance to make doxygen treat
-# .inc files as Fortran files (default is PHP), and .f files as C (default is Fortran),
+# Doxygen selects the parser to use depending on the extension of the files it parses. 
+# With this tag you can assign which parser to use for a given extension. 
+# Doxygen has a built-in mapping, but you can override or extend it using this tag. 
+# The format is ext=language, where ext is a file extension, and language is one of 
+# the parsers supported by doxygen: IDL, Java, Javascript, C#, C, C++, D, PHP, 
+# Objective-C, Python, Fortran, VHDL, C, C++. For instance to make doxygen treat 
+# .inc files as Fortran files (default is PHP), and .f files as C (default is Fortran), 
 # use: inc=Fortran f=C. Note that for custom extensions you also need to set
 # FILE_PATTERNS otherwise the files are not read by doxygen.
 
-EXTENSION_MAPPING      =
+EXTENSION_MAPPING      = 
 
-# If you use STL classes (i.e. std::string, std::vector, etc.) but do not want
-# to include (a tag file for) the STL sources as input, then you should
-# set this tag to YES in order to let doxygen match functions declarations and
-# definitions whose arguments contain STL classes (e.g. func(std::string); v.s.
-# func(std::string) {}). This also make the inheritance and collaboration
+# If you use STL classes (i.e. std::string, std::vector, etc.) but do not want 
+# to include (a tag file for) the STL sources as input, then you should 
+# set this tag to YES in order to let doxygen match functions declarations and 
+# definitions whose arguments contain STL classes (e.g. func(std::string); v.s. 
+# func(std::string) {}). This also make the inheritance and collaboration 
 # diagrams that involve STL classes more complete and accurate.
 
 BUILTIN_STL_SUPPORT    = NO
 
-# If you use Microsoft's C++/CLI language, you should set this option to YES to
+# If you use Microsoft's C++/CLI language, you should set this option to YES to 
 # enable parsing support.
 
 CPP_CLI_SUPPORT        = NO
 
-# Set the SIP_SUPPORT tag to YES if your project consists of sip sources only.
-# Doxygen will parse them like normal C++ but will assume all classes use public
+# Set the SIP_SUPPORT tag to YES if your project consists of sip sources only. 
+# Doxygen will parse them like normal C++ but will assume all classes use public 
 # instead of private inheritance when no explicit protection keyword is present.
 
 SIP_SUPPORT            = NO
 
-# For Microsoft's IDL there are propget and propput attributes to indicate getter
-# and setter methods for a property. Setting this option to YES (the default)
-# will make doxygen to replace the get and set methods by a property in the
-# documentation. This will only work if the methods are indeed getting or
-# setting a simple type. If this is not the case, or you want to show the
+# For Microsoft's IDL there are propget and propput attributes to indicate getter 
+# and setter methods for a property. Setting this option to YES (the default) 
+# will make doxygen to replace the get and set methods by a property in the 
+# documentation. This will only work if the methods are indeed getting or 
+# setting a simple type. If this is not the case, or you want to show the 
 # methods anyway, you should set this option to NO.
 
 IDL_PROPERTY_SUPPORT   = YES
 
-# If member grouping is used in the documentation and the DISTRIBUTE_GROUP_DOC
-# tag is set to YES, then doxygen will reuse the documentation of the first
-# member in the group (if any) for the other members of the group. By default
+# If member grouping is used in the documentation and the DISTRIBUTE_GROUP_DOC 
+# tag is set to YES, then doxygen will reuse the documentation of the first 
+# member in the group (if any) for the other members of the group. By default 
 # all members of a group must be documented explicitly.
 
 DISTRIBUTE_GROUP_DOC   = NO
 
-# Set the SUBGROUPING tag to YES (the default) to allow class member groups of
-# the same type (for instance a group of public functions) to be put as a
-# subgroup of that type (e.g. under the Public Functions section). Set it to
-# NO to prevent subgrouping. Alternatively, this can be done per class using
+# Set the SUBGROUPING tag to YES (the default) to allow class member groups of 
+# the same type (for instance a group of public functions) to be put as a 
+# subgroup of that type (e.g. under the Public Functions section). Set it to 
+# NO to prevent subgrouping. Alternatively, this can be done per class using 
 # the \nosubgrouping command.
 
 SUBGROUPING            = YES
 
-# When TYPEDEF_HIDES_STRUCT is enabled, a typedef of a struct, union, or enum
-# is documented as struct, union, or enum with the name of the typedef. So
-# typedef struct TypeS {} TypeT, will appear in the documentation as a struct
-# with name TypeT. When disabled the typedef will appear as a member of a file,
-# namespace, or class. And the struct will be named TypeS. This can typically
-# be useful for C code in case the coding convention dictates that all compound
+# When TYPEDEF_HIDES_STRUCT is enabled, a typedef of a struct, union, or enum 
+# is documented as struct, union, or enum with the name of the typedef. So 
+# typedef struct TypeS {} TypeT, will appear in the documentation as a struct 
+# with name TypeT. When disabled the typedef will appear as a member of a file, 
+# namespace, or class. And the struct will be named TypeS. This can typically 
+# be useful for C code in case the coding convention dictates that all compound 
 # types are typedef'ed and only the typedef is referenced, never the tag name.
 
 TYPEDEF_HIDES_STRUCT   = NO
 
-# The SYMBOL_CACHE_SIZE determines the size of the internal cache use to
-# determine which symbols to keep in memory and which to flush to disk.
-# When the cache is full, less often used symbols will be written to disk.
-# For small to medium size projects (<1000 input files) the default value is
-# probably good enough. For larger projects a too small cache size can cause
-# doxygen to be busy swapping symbols to and from disk most of the time
-# causing a significant performance penality.
-# If the system has enough physical memory increasing the cache will improve the
-# performance by keeping more symbols in memory. Note that the value works on
-# a logarithmic scale so increasing the size by one will rougly double the
-# memory usage. The cache size is given by this formula:
-# 2^(16+SYMBOL_CACHE_SIZE). The valid range is 0..9, the default is 0,
+# The SYMBOL_CACHE_SIZE determines the size of the internal cache use to 
+# determine which symbols to keep in memory and which to flush to disk. 
+# When the cache is full, less often used symbols will be written to disk. 
+# For small to medium size projects (<1000 input files) the default value is 
+# probably good enough. For larger projects a too small cache size can cause 
+# doxygen to be busy swapping symbols to and from disk most of the time 
+# causing a significant performance penality. 
+# If the system has enough physical memory increasing the cache will improve the 
+# performance by keeping more symbols in memory. Note that the value works on 
+# a logarithmic scale so increasing the size by one will rougly double the 
+# memory usage. The cache size is given by this formula: 
+# 2^(16+SYMBOL_CACHE_SIZE). The valid range is 0..9, the default is 0, 
 # corresponding to a cache size of 2^16 = 65536 symbols
 
 SYMBOL_CACHE_SIZE      = 0
@@ -303,121 +303,121 @@ SYMBOL_CACHE_SIZE      = 0
 # Build related configuration options
 #---------------------------------------------------------------------------
 
-# If the EXTRACT_ALL tag is set to YES doxygen will assume all entities in
-# documentation are documented, even if no documentation was available.
-# Private class members and static file members will be hidden unless
+# If the EXTRACT_ALL tag is set to YES doxygen will assume all entities in 
+# documentation are documented, even if no documentation was available. 
+# Private class members and static file members will be hidden unless 
 # the EXTRACT_PRIVATE and EXTRACT_STATIC tags are set to YES
 
 EXTRACT_ALL            = YES
 
-# If the EXTRACT_PRIVATE tag is set to YES all private members of a class
+# If the EXTRACT_PRIVATE tag is set to YES all private members of a class 
 # will be included in the documentation.
 
 EXTRACT_PRIVATE        = NO
 
-# If the EXTRACT_STATIC tag is set to YES all static members of a file
+# If the EXTRACT_STATIC tag is set to YES all static members of a file 
 # will be included in the documentation.
 
 EXTRACT_STATIC         = YES
 
-# If the EXTRACT_LOCAL_CLASSES tag is set to YES classes (and structs)
-# defined locally in source files will be included in the documentation.
+# If the EXTRACT_LOCAL_CLASSES tag is set to YES classes (and structs) 
+# defined locally in source files will be included in the documentation. 
 # If set to NO only classes defined in header files are included.
 
 EXTRACT_LOCAL_CLASSES  = YES
 
-# This flag is only useful for Objective-C code. When set to YES local
-# methods, which are defined in the implementation section but not in
-# the interface are included in the documentation.
+# This flag is only useful for Objective-C code. When set to YES local 
+# methods, which are defined in the implementation section but not in 
+# the interface are included in the documentation. 
 # If set to NO (the default) only methods in the interface are included.
 
 EXTRACT_LOCAL_METHODS  = NO
 
-# If this flag is set to YES, the members of anonymous namespaces will be
-# extracted and appear in the documentation as a namespace called
-# 'anonymous_namespace{file}', where file will be replaced with the base
-# name of the file that contains the anonymous namespace. By default
+# If this flag is set to YES, the members of anonymous namespaces will be 
+# extracted and appear in the documentation as a namespace called 
+# 'anonymous_namespace{file}', where file will be replaced with the base 
+# name of the file that contains the anonymous namespace. By default 
 # anonymous namespace are hidden.
 
 EXTRACT_ANON_NSPACES   = NO
 
-# If the HIDE_UNDOC_MEMBERS tag is set to YES, Doxygen will hide all
-# undocumented members of documented classes, files or namespaces.
-# If set to NO (the default) these members will be included in the
-# various overviews, but no documentation section is generated.
+# If the HIDE_UNDOC_MEMBERS tag is set to YES, Doxygen will hide all 
+# undocumented members of documented classes, files or namespaces. 
+# If set to NO (the default) these members will be included in the 
+# various overviews, but no documentation section is generated. 
 # This option has no effect if EXTRACT_ALL is enabled.
 
 HIDE_UNDOC_MEMBERS     = NO
 
-# If the HIDE_UNDOC_CLASSES tag is set to YES, Doxygen will hide all
-# undocumented classes that are normally visible in the class hierarchy.
-# If set to NO (the default) these classes will be included in the various
+# If the HIDE_UNDOC_CLASSES tag is set to YES, Doxygen will hide all 
+# undocumented classes that are normally visible in the class hierarchy. 
+# If set to NO (the default) these classes will be included in the various 
 # overviews. This option has no effect if EXTRACT_ALL is enabled.
 
 HIDE_UNDOC_CLASSES     = NO
 
-# If the HIDE_FRIEND_COMPOUNDS tag is set to YES, Doxygen will hide all
-# friend (class|struct|union) declarations.
-# If set to NO (the default) these declarations will be included in the
+# If the HIDE_FRIEND_COMPOUNDS tag is set to YES, Doxygen will hide all 
+# friend (class|struct|union) declarations. 
+# If set to NO (the default) these declarations will be included in the 
 # documentation.
 
 HIDE_FRIEND_COMPOUNDS  = NO
 
-# If the HIDE_IN_BODY_DOCS tag is set to YES, Doxygen will hide any
-# documentation blocks found inside the body of a function.
-# If set to NO (the default) these blocks will be appended to the
+# If the HIDE_IN_BODY_DOCS tag is set to YES, Doxygen will hide any 
+# documentation blocks found inside the body of a function. 
+# If set to NO (the default) these blocks will be appended to the 
 # function's detailed documentation block.
 
 HIDE_IN_BODY_DOCS      = NO
 
-# The INTERNAL_DOCS tag determines if documentation
-# that is typed after a \internal command is included. If the tag is set
-# to NO (the default) then the documentation will be excluded.
+# The INTERNAL_DOCS tag determines if documentation 
+# that is typed after a \internal command is included. If the tag is set 
+# to NO (the default) then the documentation will be excluded. 
 # Set it to YES to include the internal documentation.
 
 INTERNAL_DOCS          = NO
 
-# If the CASE_SENSE_NAMES tag is set to NO then Doxygen will only generate
-# file names in lower-case letters. If set to YES upper-case letters are also
-# allowed. This is useful if you have classes or files whose names only differ
-# in case and if your file system supports case sensitive file names. Windows
+# If the CASE_SENSE_NAMES tag is set to NO then Doxygen will only generate 
+# file names in lower-case letters. If set to YES upper-case letters are also 
+# allowed. This is useful if you have classes or files whose names only differ 
+# in case and if your file system supports case sensitive file names. Windows 
 # and Mac users are advised to set this option to NO.
 
 CASE_SENSE_NAMES       = NO
 
-# If the HIDE_SCOPE_NAMES tag is set to NO (the default) then Doxygen
-# will show members with their full class and namespace scopes in the
+# If the HIDE_SCOPE_NAMES tag is set to NO (the default) then Doxygen 
+# will show members with their full class and namespace scopes in the 
 # documentation. If set to YES the scope will be hidden.
 
 HIDE_SCOPE_NAMES       = YES
 
-# If the SHOW_INCLUDE_FILES tag is set to YES (the default) then Doxygen
-# will put a list of the files that are included by a file in the documentation
+# If the SHOW_INCLUDE_FILES tag is set to YES (the default) then Doxygen 
+# will put a list of the files that are included by a file in the documentation 
 # of that file.
 
 SHOW_INCLUDE_FILES     = YES
 
-# If the FORCE_LOCAL_INCLUDES tag is set to YES then Doxygen
-# will list include files with double quotes in the documentation
+# If the FORCE_LOCAL_INCLUDES tag is set to YES then Doxygen 
+# will list include files with double quotes in the documentation 
 # rather than with sharp brackets.
 
 FORCE_LOCAL_INCLUDES   = NO
 
-# If the INLINE_INFO tag is set to YES (the default) then a tag [inline]
+# If the INLINE_INFO tag is set to YES (the default) then a tag [inline] 
 # is inserted in the documentation for inline members.
 
 INLINE_INFO            = YES
 
-# If the SORT_MEMBER_DOCS tag is set to YES (the default) then doxygen
-# will sort the (detailed) documentation of file and class members
-# alphabetically by member name. If set to NO the members will appear in
+# If the SORT_MEMBER_DOCS tag is set to YES (the default) then doxygen 
+# will sort the (detailed) documentation of file and class members 
+# alphabetically by member name. If set to NO the members will appear in 
 # declaration order.
 
 SORT_MEMBER_DOCS       = YES
 
-# If the SORT_BRIEF_DOCS tag is set to YES then doxygen will sort the
-# brief documentation of file, namespace and class members alphabetically
-# by member name. If set to NO (the default) the members will appear in
+# If the SORT_BRIEF_DOCS tag is set to YES then doxygen will sort the 
+# brief documentation of file, namespace and class members alphabetically 
+# by member name. If set to NO (the default) the members will appear in 
 # declaration order.
 
 SORT_BRIEF_DOCS        = NO
@@ -432,179 +432,179 @@ SORT_BRIEF_DOCS        = NO
 
 SORT_MEMBERS_CTORS_1ST = NO
 
-# If the SORT_GROUP_NAMES tag is set to YES then doxygen will sort the
-# hierarchy of group names into alphabetical order. If set to NO (the default)
+# If the SORT_GROUP_NAMES tag is set to YES then doxygen will sort the 
+# hierarchy of group names into alphabetical order. If set to NO (the default) 
 # the group names will appear in their defined order.
 
-SORT_GROUP_NAMES       = YES
+SORT_GROUP_NAMES       = NO
 
-# If the SORT_BY_SCOPE_NAME tag is set to YES, the class list will be
-# sorted by fully-qualified names, including namespaces. If set to
-# NO (the default), the class list will be sorted only by class name,
-# not including the namespace part.
-# Note: This option is not very useful if HIDE_SCOPE_NAMES is set to YES.
-# Note: This option applies only to the class list, not to the
+# If the SORT_BY_SCOPE_NAME tag is set to YES, the class list will be 
+# sorted by fully-qualified names, including namespaces. If set to 
+# NO (the default), the class list will be sorted only by class name, 
+# not including the namespace part. 
+# Note: This option is not very useful if HIDE_SCOPE_NAMES is set to YES. 
+# Note: This option applies only to the class list, not to the 
 # alphabetical list.
 
 SORT_BY_SCOPE_NAME     = NO
 
-# The GENERATE_TODOLIST tag can be used to enable (YES) or
-# disable (NO) the todo list. This list is created by putting \todo
+# The GENERATE_TODOLIST tag can be used to enable (YES) or 
+# disable (NO) the todo list. This list is created by putting \todo 
 # commands in the documentation.
 
 GENERATE_TODOLIST      = YES
 
-# The GENERATE_TESTLIST tag can be used to enable (YES) or
-# disable (NO) the test list. This list is created by putting \test
+# The GENERATE_TESTLIST tag can be used to enable (YES) or 
+# disable (NO) the test list. This list is created by putting \test 
 # commands in the documentation.
 
 GENERATE_TESTLIST      = YES
 
-# The GENERATE_BUGLIST tag can be used to enable (YES) or
-# disable (NO) the bug list. This list is created by putting \bug
+# The GENERATE_BUGLIST tag can be used to enable (YES) or 
+# disable (NO) the bug list. This list is created by putting \bug 
 # commands in the documentation.
 
 GENERATE_BUGLIST       = YES
 
-# The GENERATE_DEPRECATEDLIST tag can be used to enable (YES) or
-# disable (NO) the deprecated list. This list is created by putting
+# The GENERATE_DEPRECATEDLIST tag can be used to enable (YES) or 
+# disable (NO) the deprecated list. This list is created by putting 
 # \deprecated commands in the documentation.
 
 GENERATE_DEPRECATEDLIST= YES
 
-# The ENABLED_SECTIONS tag can be used to enable conditional
+# The ENABLED_SECTIONS tag can be used to enable conditional 
 # documentation sections, marked by \if sectionname ... \endif.
 
-ENABLED_SECTIONS       =
+ENABLED_SECTIONS       = 
 
-# The MAX_INITIALIZER_LINES tag determines the maximum number of lines
-# the initial value of a variable or define consists of for it to appear in
-# the documentation. If the initializer consists of more lines than specified
-# here it will be hidden. Use a value of 0 to hide initializers completely.
-# The appearance of the initializer of individual variables and defines in the
-# documentation can be controlled using \showinitializer or \hideinitializer
+# The MAX_INITIALIZER_LINES tag determines the maximum number of lines 
+# the initial value of a variable or define consists of for it to appear in 
+# the documentation. If the initializer consists of more lines than specified 
+# here it will be hidden. Use a value of 0 to hide initializers completely. 
+# The appearance of the initializer of individual variables and defines in the 
+# documentation can be controlled using \showinitializer or \hideinitializer 
 # command in the documentation regardless of this setting.
 
 MAX_INITIALIZER_LINES  = 30
 
-# Set the SHOW_USED_FILES tag to NO to disable the list of files generated
-# at the bottom of the documentation of classes and structs. If set to YES the
+# Set the SHOW_USED_FILES tag to NO to disable the list of files generated 
+# at the bottom of the documentation of classes and structs. If set to YES the 
 # list will mention the files that were used to generate the documentation.
 
 SHOW_USED_FILES        = YES
 
-# If the sources in your project are distributed over multiple directories
-# then setting the SHOW_DIRECTORIES tag to YES will show the directory hierarchy
+# If the sources in your project are distributed over multiple directories 
+# then setting the SHOW_DIRECTORIES tag to YES will show the directory hierarchy 
 # in the documentation. The default is NO.
 
 SHOW_DIRECTORIES       = NO
 
-# Set the SHOW_FILES tag to NO to disable the generation of the Files page.
-# This will remove the Files entry from the Quick Index and from the
+# Set the SHOW_FILES tag to NO to disable the generation of the Files page. 
+# This will remove the Files entry from the Quick Index and from the 
 # Folder Tree View (if specified). The default is YES.
 
 SHOW_FILES             = YES
 
-# Set the SHOW_NAMESPACES tag to NO to disable the generation of the
-# Namespaces page.  This will remove the Namespaces entry from the Quick Index
+# Set the SHOW_NAMESPACES tag to NO to disable the generation of the 
+# Namespaces page.  This will remove the Namespaces entry from the Quick Index 
 # and from the Folder Tree View (if specified). The default is YES.
 
 SHOW_NAMESPACES        = YES
 
-# The FILE_VERSION_FILTER tag can be used to specify a program or script that
-# doxygen should invoke to get the current version for each file (typically from
-# the version control system). Doxygen will invoke the program by executing (via
-# popen()) the command <command> <input-file>, where <command> is the value of
-# the FILE_VERSION_FILTER tag, and <input-file> is the name of an input file
-# provided by doxygen. Whatever the program writes to standard output
+# The FILE_VERSION_FILTER tag can be used to specify a program or script that 
+# doxygen should invoke to get the current version for each file (typically from 
+# the version control system). Doxygen will invoke the program by executing (via 
+# popen()) the command <command> <input-file>, where <command> is the value of 
+# the FILE_VERSION_FILTER tag, and <input-file> is the name of an input file 
+# provided by doxygen. Whatever the program writes to standard output 
 # is used as the file version. See the manual for examples.
 
-FILE_VERSION_FILTER    =
+FILE_VERSION_FILTER    = 
 
-# The LAYOUT_FILE tag can be used to specify a layout file which will be parsed by
-# doxygen. The layout file controls the global structure of the generated output files
-# in an output format independent way. The create the layout file that represents
-# doxygen's defaults, run doxygen with the -l option. You can optionally specify a
-# file name after the option, if omitted DoxygenLayout.xml will be used as the name
+# The LAYOUT_FILE tag can be used to specify a layout file which will be parsed by 
+# doxygen. The layout file controls the global structure of the generated output files 
+# in an output format independent way. The create the layout file that represents 
+# doxygen's defaults, run doxygen with the -l option. You can optionally specify a 
+# file name after the option, if omitted DoxygenLayout.xml will be used as the name 
 # of the layout file.
 
-LAYOUT_FILE            =
+LAYOUT_FILE            = 
 
 #---------------------------------------------------------------------------
 # configuration options related to warning and progress messages
 #---------------------------------------------------------------------------
 
-# The QUIET tag can be used to turn on/off the messages that are generated
+# The QUIET tag can be used to turn on/off the messages that are generated 
 # by doxygen. Possible values are YES and NO. If left blank NO is used.
 
-QUIET                  = YES
+QUIET                  = NO
 
-# The WARNINGS tag can be used to turn on/off the warning messages that are
-# generated by doxygen. Possible values are YES and NO. If left blank
+# The WARNINGS tag can be used to turn on/off the warning messages that are 
+# generated by doxygen. Possible values are YES and NO. If left blank 
 # NO is used.
 
 WARNINGS               = YES
 
-# If WARN_IF_UNDOCUMENTED is set to YES, then doxygen will generate warnings
-# for undocumented members. If EXTRACT_ALL is set to YES then this flag will
+# If WARN_IF_UNDOCUMENTED is set to YES, then doxygen will generate warnings 
+# for undocumented members. If EXTRACT_ALL is set to YES then this flag will 
 # automatically be disabled.
 
 WARN_IF_UNDOCUMENTED   = YES
 
-# If WARN_IF_DOC_ERROR is set to YES, doxygen will generate warnings for
-# potential errors in the documentation, such as not documenting some
-# parameters in a documented function, or documenting parameters that
+# If WARN_IF_DOC_ERROR is set to YES, doxygen will generate warnings for 
+# potential errors in the documentation, such as not documenting some 
+# parameters in a documented function, or documenting parameters that 
 # don't exist or using markup commands wrongly.
 
 WARN_IF_DOC_ERROR      = YES
 
-# This WARN_NO_PARAMDOC option can be abled to get warnings for
-# functions that are documented, but have no documentation for their parameters
-# or return value. If set to NO (the default) doxygen will only warn about
-# wrong or incomplete parameter documentation, but not about the absence of
+# This WARN_NO_PARAMDOC option can be abled to get warnings for 
+# functions that are documented, but have no documentation for their parameters 
+# or return value. If set to NO (the default) doxygen will only warn about 
+# wrong or incomplete parameter documentation, but not about the absence of 
 # documentation.
 
 WARN_NO_PARAMDOC       = NO
 
-# The WARN_FORMAT tag determines the format of the warning messages that
-# doxygen can produce. The string should contain the $file, $line, and $text
-# tags, which will be replaced by the file and line number from which the
-# warning originated and the warning text. Optionally the format may contain
-# $version, which will be replaced by the version of the file (if it could
+# The WARN_FORMAT tag determines the format of the warning messages that 
+# doxygen can produce. The string should contain the $file, $line, and $text 
+# tags, which will be replaced by the file and line number from which the 
+# warning originated and the warning text. Optionally the format may contain 
+# $version, which will be replaced by the version of the file (if it could 
 # be obtained via FILE_VERSION_FILTER)
 
 WARN_FORMAT            = "$file:$line: $text"
 
-# The WARN_LOGFILE tag can be used to specify a file to which warning
-# and error messages should be written. If left blank the output is written
+# The WARN_LOGFILE tag can be used to specify a file to which warning 
+# and error messages should be written. If left blank the output is written 
 # to stderr.
 
-WARN_LOGFILE           =
+WARN_LOGFILE           = 
 
 #---------------------------------------------------------------------------
 # configuration options related to the input files
 #---------------------------------------------------------------------------
 
-# The INPUT tag can be used to specify the files and/or directories that contain
-# documented source files. You may enter file names like "myfile.cpp" or
-# directories like "/usr/src/myproject". Separate the files or directories
+# The INPUT tag can be used to specify the files and/or directories that contain 
+# documented source files. You may enter file names like "myfile.cpp" or 
+# directories like "/usr/src/myproject". Separate the files or directories 
 # with spaces.
 
 INPUT                  = .
 
-# This tag can be used to specify the character encoding of the source files
-# that doxygen parses. Internally doxygen uses the UTF-8 encoding, which is
-# also the default input encoding. Doxygen uses libiconv (or the iconv built
-# into libc) for the transcoding. See http://www.gnu.org/software/libiconv for
+# This tag can be used to specify the character encoding of the source files 
+# that doxygen parses. Internally doxygen uses the UTF-8 encoding, which is 
+# also the default input encoding. Doxygen uses libiconv (or the iconv built 
+# into libc) for the transcoding. See http://www.gnu.org/software/libiconv for 
 # the list of possible encodings.
 
 INPUT_ENCODING         = UTF-8
 
-# If the value of the INPUT tag contains directories, you can use the
-# FILE_PATTERNS tag to specify one or more wildcard pattern (like *.cpp
-# and *.h) to filter out the source-files in the directories. If left
-# blank the following patterns are tested:
-# *.c *.cc *.cxx *.cpp *.c++ *.java *.ii *.ixx *.ipp *.i++ *.inl *.h *.hh *.hxx
+# If the value of the INPUT tag contains directories, you can use the 
+# FILE_PATTERNS tag to specify one or more wildcard pattern (like *.cpp 
+# and *.h) to filter out the source-files in the directories. If left 
+# blank the following patterns are tested: 
+# *.c *.cc *.cxx *.cpp *.c++ *.java *.ii *.ixx *.ipp *.i++ *.inl *.h *.hh *.hxx 
 # *.hpp *.h++ *.idl *.odl *.cs *.php *.php3 *.inc *.m *.mm *.py *.f90
 
 FILE_PATTERNS          = *.c \
@@ -640,87 +640,87 @@ FILE_PATTERNS          = *.c \
                          *.vhd \
                          *.vhdl
 
-# The RECURSIVE tag can be used to turn specify whether or not subdirectories
-# should be searched for input files as well. Possible values are YES and NO.
+# The RECURSIVE tag can be used to turn specify whether or not subdirectories 
+# should be searched for input files as well. Possible values are YES and NO. 
 # If left blank NO is used.
 
 RECURSIVE              = YES
 
-# The EXCLUDE tag can be used to specify files and/or directories that should
-# excluded from the INPUT source files. This way you can easily exclude a
+# The EXCLUDE tag can be used to specify files and/or directories that should 
+# excluded from the INPUT source files. This way you can easily exclude a 
 # subdirectory from a directory tree whose root is specified with the INPUT tag.
 
 EXCLUDE                =
 
-# The EXCLUDE_SYMLINKS tag can be used select whether or not files or
-# directories that are symbolic links (a Unix filesystem feature) are excluded
+# The EXCLUDE_SYMLINKS tag can be used select whether or not files or 
+# directories that are symbolic links (a Unix filesystem feature) are excluded 
 # from the input.
 
-EXCLUDE_SYMLINKS       = YES
+EXCLUDE_SYMLINKS       = NO
 
-# If the value of the INPUT tag contains directories, you can use the
-# EXCLUDE_PATTERNS tag to specify one or more wildcard patterns to exclude
-# certain files from those directories. Note that the wildcards are matched
-# against the file with absolute path, so to exclude all test directories
+# If the value of the INPUT tag contains directories, you can use the 
+# EXCLUDE_PATTERNS tag to specify one or more wildcard patterns to exclude 
+# certain files from those directories. Note that the wildcards are matched 
+# against the file with absolute path, so to exclude all test directories 
 # for example use the pattern */test/*
 
 EXCLUDE_PATTERNS       = *.git/*
 
-# The EXCLUDE_SYMBOLS tag can be used to specify one or more symbol names
-# (namespaces, classes, functions, etc.) that should be excluded from the
-# output. The symbol name can be a fully qualified name, a word, or if the
-# wildcard * is used, a substring. Examples: ANamespace, AClass,
+# The EXCLUDE_SYMBOLS tag can be used to specify one or more symbol names 
+# (namespaces, classes, functions, etc.) that should be excluded from the 
+# output. The symbol name can be a fully qualified name, a word, or if the 
+# wildcard * is used, a substring. Examples: ANamespace, AClass, 
 # AClass::ANamespace, ANamespace::*Test
 
-EXCLUDE_SYMBOLS        =
+EXCLUDE_SYMBOLS        = 
 
-# The EXAMPLE_PATH tag can be used to specify one or more files or
-# directories that contain example code fragments that are included (see
+# The EXAMPLE_PATH tag can be used to specify one or more files or 
+# directories that contain example code fragments that are included (see 
 # the \include command).
 
-EXAMPLE_PATH           = .
+EXAMPLE_PATH           = 
 
-# If the value of the EXAMPLE_PATH tag contains directories, you can use the
-# EXAMPLE_PATTERNS tag to specify one or more wildcard pattern (like *.cpp
-# and *.h) to filter out the source-files in the directories. If left
+# If the value of the EXAMPLE_PATH tag contains directories, you can use the 
+# EXAMPLE_PATTERNS tag to specify one or more wildcard pattern (like *.cpp 
+# and *.h) to filter out the source-files in the directories. If left 
 # blank all files are included.
 
 EXAMPLE_PATTERNS       = *
 
-# If the EXAMPLE_RECURSIVE tag is set to YES then subdirectories will be
-# searched for input files to be used with the \include or \dontinclude
-# commands irrespective of the value of the RECURSIVE tag.
+# If the EXAMPLE_RECURSIVE tag is set to YES then subdirectories will be 
+# searched for input files to be used with the \include or \dontinclude 
+# commands irrespective of the value of the RECURSIVE tag. 
 # Possible values are YES and NO. If left blank NO is used.
 
 EXAMPLE_RECURSIVE      = NO
 
-# The IMAGE_PATH tag can be used to specify one or more files or
-# directories that contain image that are included in the documentation (see
+# The IMAGE_PATH tag can be used to specify one or more files or 
+# directories that contain image that are included in the documentation (see 
 # the \image command).
 
-IMAGE_PATH             =
+IMAGE_PATH             = 
 
-# The INPUT_FILTER tag can be used to specify a program that doxygen should
-# invoke to filter for each input file. Doxygen will invoke the filter program
-# by executing (via popen()) the command <filter> <input-file>, where <filter>
-# is the value of the INPUT_FILTER tag, and <input-file> is the name of an
-# input file. Doxygen will then use the output that the filter program writes
-# to standard output.  If FILTER_PATTERNS is specified, this tag will be
+# The INPUT_FILTER tag can be used to specify a program that doxygen should 
+# invoke to filter for each input file. Doxygen will invoke the filter program 
+# by executing (via popen()) the command <filter> <input-file>, where <filter> 
+# is the value of the INPUT_FILTER tag, and <input-file> is the name of an 
+# input file. Doxygen will then use the output that the filter program writes 
+# to standard output.  If FILTER_PATTERNS is specified, this tag will be 
 # ignored.
 
-INPUT_FILTER           =
+INPUT_FILTER           = 
 
-# The FILTER_PATTERNS tag can be used to specify filters on a per file pattern
-# basis.  Doxygen will compare the file name with each pattern and apply the
-# filter if there is a match.  The filters are a list of the form:
-# pattern=filter (like *.cpp=my_cpp_filter). See INPUT_FILTER for further
-# info on how filters are used. If FILTER_PATTERNS is empty, INPUT_FILTER
+# The FILTER_PATTERNS tag can be used to specify filters on a per file pattern 
+# basis.  Doxygen will compare the file name with each pattern and apply the 
+# filter if there is a match.  The filters are a list of the form: 
+# pattern=filter (like *.cpp=my_cpp_filter). See INPUT_FILTER for further 
+# info on how filters are used. If FILTER_PATTERNS is empty, INPUT_FILTER 
 # is applied to all files.
 
-FILTER_PATTERNS        =
+FILTER_PATTERNS        = 
 
-# If the FILTER_SOURCE_FILES tag is set to YES, the input filter (if set using
-# INPUT_FILTER) will be used to filter the input files when producing source
+# If the FILTER_SOURCE_FILES tag is set to YES, the input filter (if set using 
+# INPUT_FILTER) will be used to filter the input files when producing source 
 # files to browse (i.e. when SOURCE_BROWSER is set to YES).
 
 FILTER_SOURCE_FILES    = NO
@@ -729,53 +729,53 @@ FILTER_SOURCE_FILES    = NO
 # configuration options related to source browsing
 #---------------------------------------------------------------------------
 
-# If the SOURCE_BROWSER tag is set to YES then a list of source files will
-# be generated. Documented entities will be cross-referenced with these sources.
-# Note: To get rid of all source code in the generated output, make sure also
+# If the SOURCE_BROWSER tag is set to YES then a list of source files will 
+# be generated. Documented entities will be cross-referenced with these sources. 
+# Note: To get rid of all source code in the generated output, make sure also 
 # VERBATIM_HEADERS is set to NO.
 
 SOURCE_BROWSER         = YES
 
-# Setting the INLINE_SOURCES tag to YES will include the body
+# Setting the INLINE_SOURCES tag to YES will include the body 
 # of functions and classes directly in the documentation.
 
 INLINE_SOURCES         = NO
 
-# Setting the STRIP_CODE_COMMENTS tag to YES (the default) will instruct
-# doxygen to hide any special comment blocks from generated source code
+# Setting the STRIP_CODE_COMMENTS tag to YES (the default) will instruct 
+# doxygen to hide any special comment blocks from generated source code 
 # fragments. Normal C and C++ comments will always remain visible.
 
 STRIP_CODE_COMMENTS    = YES
 
-# If the REFERENCED_BY_RELATION tag is set to YES
-# then for each documented function all documented
+# If the REFERENCED_BY_RELATION tag is set to YES 
+# then for each documented function all documented 
 # functions referencing it will be listed.
 
 REFERENCED_BY_RELATION = NO
 
-# If the REFERENCES_RELATION tag is set to YES
-# then for each documented function all documented entities
+# If the REFERENCES_RELATION tag is set to YES 
+# then for each documented function all documented entities 
 # called/used by that function will be listed.
 
 REFERENCES_RELATION    = NO
 
-# If the REFERENCES_LINK_SOURCE tag is set to YES (the default)
-# and SOURCE_BROWSER tag is set to YES, then the hyperlinks from
-# functions in REFERENCES_RELATION and REFERENCED_BY_RELATION lists will
+# If the REFERENCES_LINK_SOURCE tag is set to YES (the default) 
+# and SOURCE_BROWSER tag is set to YES, then the hyperlinks from 
+# functions in REFERENCES_RELATION and REFERENCED_BY_RELATION lists will 
 # link to the source code.  Otherwise they will link to the documentation.
 
 REFERENCES_LINK_SOURCE = YES
 
-# If the USE_HTAGS tag is set to YES then the references to source code
-# will point to the HTML generated by the htags(1) tool instead of doxygen
-# built-in source browser. The htags tool is part of GNU's global source
-# tagging system (see http://www.gnu.org/software/global/global.html). You
+# If the USE_HTAGS tag is set to YES then the references to source code 
+# will point to the HTML generated by the htags(1) tool instead of doxygen 
+# built-in source browser. The htags tool is part of GNU's global source 
+# tagging system (see http://www.gnu.org/software/global/global.html). You 
 # will need version 4.8.6 or higher.
 
 USE_HTAGS              = NO
 
-# If the VERBATIM_HEADERS tag is set to YES (the default) then Doxygen
-# will generate a verbatim copy of the header file for each class for
+# If the VERBATIM_HEADERS tag is set to YES (the default) then Doxygen 
+# will generate a verbatim copy of the header file for each class for 
 # which an include is specified. Set to NO to disable this.
 
 VERBATIM_HEADERS       = YES
@@ -784,279 +784,279 @@ VERBATIM_HEADERS       = YES
 # configuration options related to the alphabetical class index
 #---------------------------------------------------------------------------
 
-# If the ALPHABETICAL_INDEX tag is set to YES, an alphabetical index
-# of all compounds will be generated. Enable this if the project
+# If the ALPHABETICAL_INDEX tag is set to YES, an alphabetical index 
+# of all compounds will be generated. Enable this if the project 
 # contains a lot of classes, structs, unions or interfaces.
 
 ALPHABETICAL_INDEX     = NO
 
-# If the alphabetical index is enabled (see ALPHABETICAL_INDEX) then
-# the COLS_IN_ALPHA_INDEX tag can be used to specify the number of columns
+# If the alphabetical index is enabled (see ALPHABETICAL_INDEX) then 
+# the COLS_IN_ALPHA_INDEX tag can be used to specify the number of columns 
 # in which this list will be split (can be a number in the range [1..20])
 
 COLS_IN_ALPHA_INDEX    = 5
 
-# In case all classes in a project start with a common prefix, all
-# classes will be put under the same header in the alphabetical index.
-# The IGNORE_PREFIX tag can be used to specify one or more prefixes that
+# In case all classes in a project start with a common prefix, all 
+# classes will be put under the same header in the alphabetical index. 
+# The IGNORE_PREFIX tag can be used to specify one or more prefixes that 
 # should be ignored while generating the index headers.
 
-IGNORE_PREFIX          =
+IGNORE_PREFIX          = 
 
 #---------------------------------------------------------------------------
 # configuration options related to the HTML output
 #---------------------------------------------------------------------------
 
-# If the GENERATE_HTML tag is set to YES (the default) Doxygen will
+# If the GENERATE_HTML tag is set to YES (the default) Doxygen will 
 # generate HTML output.
 
 GENERATE_HTML          = YES
 
-# The HTML_OUTPUT tag is used to specify where the HTML docs will be put.
-# If a relative path is entered the value of OUTPUT_DIRECTORY will be
+# The HTML_OUTPUT tag is used to specify where the HTML docs will be put. 
+# If a relative path is entered the value of OUTPUT_DIRECTORY will be 
 # put in front of it. If left blank `html' will be used as the default path.
 
 HTML_OUTPUT            = html
 
-# The HTML_FILE_EXTENSION tag can be used to specify the file extension for
-# each generated HTML page (for example: .htm,.php,.asp). If it is left blank
+# The HTML_FILE_EXTENSION tag can be used to specify the file extension for 
+# each generated HTML page (for example: .htm,.php,.asp). If it is left blank 
 # doxygen will generate files with .html extension.
 
 HTML_FILE_EXTENSION    = .html
 
-# The HTML_HEADER tag can be used to specify a personal HTML header for
-# each generated HTML page. If it is left blank doxygen will generate a
+# The HTML_HEADER tag can be used to specify a personal HTML header for 
+# each generated HTML page. If it is left blank doxygen will generate a 
 # standard header.
 
-HTML_HEADER            =
+HTML_HEADER            = 
 
-# The HTML_FOOTER tag can be used to specify a personal HTML footer for
-# each generated HTML page. If it is left blank doxygen will generate a
+# The HTML_FOOTER tag can be used to specify a personal HTML footer for 
+# each generated HTML page. If it is left blank doxygen will generate a 
 # standard footer.
 
-HTML_FOOTER            =
+HTML_FOOTER            = 
 
-# The HTML_STYLESHEET tag can be used to specify a user-defined cascading
-# style sheet that is used by each HTML page. It can be used to
-# fine-tune the look of the HTML output. If the tag is left blank doxygen
-# will generate a default style sheet. Note that doxygen will try to copy
-# the style sheet file to the HTML output directory, so don't put your own
+# The HTML_STYLESHEET tag can be used to specify a user-defined cascading 
+# style sheet that is used by each HTML page. It can be used to 
+# fine-tune the look of the HTML output. If the tag is left blank doxygen 
+# will generate a default style sheet. Note that doxygen will try to copy 
+# the style sheet file to the HTML output directory, so don't put your own 
 # stylesheet in the HTML output directory as well, or it will be erased!
 
-HTML_STYLESHEET        =
+HTML_STYLESHEET        = 
 
-# If the HTML_TIMESTAMP tag is set to YES then the footer of each generated HTML
-# page will contain the date and time when the page was generated. Setting
+# If the HTML_TIMESTAMP tag is set to YES then the footer of each generated HTML 
+# page will contain the date and time when the page was generated. Setting 
 # this to NO can help when comparing the output of multiple runs.
 
 HTML_TIMESTAMP         = YES
 
-# If the HTML_ALIGN_MEMBERS tag is set to YES, the members of classes,
-# files or namespaces will be aligned in HTML using tables. If set to
+# If the HTML_ALIGN_MEMBERS tag is set to YES, the members of classes, 
+# files or namespaces will be aligned in HTML using tables. If set to 
 # NO a bullet list will be used.
 
 HTML_ALIGN_MEMBERS     = YES
 
-# If the HTML_DYNAMIC_SECTIONS tag is set to YES then the generated HTML
-# documentation will contain sections that can be hidden and shown after the
-# page has loaded. For this to work a browser that supports
-# JavaScript and DHTML is required (for instance Mozilla 1.0+, Firefox
+# If the HTML_DYNAMIC_SECTIONS tag is set to YES then the generated HTML 
+# documentation will contain sections that can be hidden and shown after the 
+# page has loaded. For this to work a browser that supports 
+# JavaScript and DHTML is required (for instance Mozilla 1.0+, Firefox 
 # Netscape 6.0+, Internet explorer 5.0+, Konqueror, or Safari).
 
 HTML_DYNAMIC_SECTIONS  = NO
 
-# If the GENERATE_DOCSET tag is set to YES, additional index files
-# will be generated that can be used as input for Apple's Xcode 3
-# integrated development environment, introduced with OSX 10.5 (Leopard).
-# To create a documentation set, doxygen will generate a Makefile in the
-# HTML output directory. Running make will produce the docset in that
-# directory and running "make install" will install the docset in
-# ~/Library/Developer/Shared/Documentation/DocSets so that Xcode will find
-# it at startup.
+# If the GENERATE_DOCSET tag is set to YES, additional index files 
+# will be generated that can be used as input for Apple's Xcode 3 
+# integrated development environment, introduced with OSX 10.5 (Leopard). 
+# To create a documentation set, doxygen will generate a Makefile in the 
+# HTML output directory. Running make will produce the docset in that 
+# directory and running "make install" will install the docset in 
+# ~/Library/Developer/Shared/Documentation/DocSets so that Xcode will find 
+# it at startup. 
 # See http://developer.apple.com/tools/creatingdocsetswithdoxygen.html for more information.
 
 GENERATE_DOCSET        = NO
 
-# When GENERATE_DOCSET tag is set to YES, this tag determines the name of the
-# feed. A documentation feed provides an umbrella under which multiple
-# documentation sets from a single provider (such as a company or product suite)
+# When GENERATE_DOCSET tag is set to YES, this tag determines the name of the 
+# feed. A documentation feed provides an umbrella under which multiple 
+# documentation sets from a single provider (such as a company or product suite) 
 # can be grouped.
 
 DOCSET_FEEDNAME        = "Doxygen generated docs"
 
-# When GENERATE_DOCSET tag is set to YES, this tag specifies a string that
-# should uniquely identify the documentation set bundle. This should be a
-# reverse domain-name style string, e.g. com.mycompany.MyDocSet. Doxygen
+# When GENERATE_DOCSET tag is set to YES, this tag specifies a string that 
+# should uniquely identify the documentation set bundle. This should be a 
+# reverse domain-name style string, e.g. com.mycompany.MyDocSet. Doxygen 
 # will append .docset to the name.
 
 DOCSET_BUNDLE_ID       = org.doxygen.Project
 
-# If the GENERATE_HTMLHELP tag is set to YES, additional index files
-# will be generated that can be used as input for tools like the
-# Microsoft HTML help workshop to generate a compiled HTML help file (.chm)
+# If the GENERATE_HTMLHELP tag is set to YES, additional index files 
+# will be generated that can be used as input for tools like the 
+# Microsoft HTML help workshop to generate a compiled HTML help file (.chm) 
 # of the generated HTML documentation.
 
 GENERATE_HTMLHELP      = NO
 
-# If the GENERATE_HTMLHELP tag is set to YES, the CHM_FILE tag can
-# be used to specify the file name of the resulting .chm file. You
-# can add a path in front of the file if the result should not be
+# If the GENERATE_HTMLHELP tag is set to YES, the CHM_FILE tag can 
+# be used to specify the file name of the resulting .chm file. You 
+# can add a path in front of the file if the result should not be 
 # written to the html output directory.
 
-CHM_FILE               =
+CHM_FILE               = 
 
-# If the GENERATE_HTMLHELP tag is set to YES, the HHC_LOCATION tag can
-# be used to specify the location (absolute path including file name) of
-# the HTML help compiler (hhc.exe). If non-empty doxygen will try to run
+# If the GENERATE_HTMLHELP tag is set to YES, the HHC_LOCATION tag can 
+# be used to specify the location (absolute path including file name) of 
+# the HTML help compiler (hhc.exe). If non-empty doxygen will try to run 
 # the HTML help compiler on the generated index.hhp.
 
-HHC_LOCATION           =
+HHC_LOCATION           = 
 
-# If the GENERATE_HTMLHELP tag is set to YES, the GENERATE_CHI flag
-# controls if a separate .chi index file is generated (YES) or that
+# If the GENERATE_HTMLHELP tag is set to YES, the GENERATE_CHI flag 
+# controls if a separate .chi index file is generated (YES) or that 
 # it should be included in the master .chm file (NO).
 
 GENERATE_CHI           = NO
 
-# If the GENERATE_HTMLHELP tag is set to YES, the CHM_INDEX_ENCODING
-# is used to encode HtmlHelp index (hhk), content (hhc) and project file
+# If the GENERATE_HTMLHELP tag is set to YES, the CHM_INDEX_ENCODING 
+# is used to encode HtmlHelp index (hhk), content (hhc) and project file 
 # content.
 
-CHM_INDEX_ENCODING     =
+CHM_INDEX_ENCODING     = 
 
-# If the GENERATE_HTMLHELP tag is set to YES, the BINARY_TOC flag
-# controls whether a binary table of contents is generated (YES) or a
+# If the GENERATE_HTMLHELP tag is set to YES, the BINARY_TOC flag 
+# controls whether a binary table of contents is generated (YES) or a 
 # normal table of contents (NO) in the .chm file.
 
 BINARY_TOC             = NO
 
-# The TOC_EXPAND flag can be set to YES to add extra items for group members
+# The TOC_EXPAND flag can be set to YES to add extra items for group members 
 # to the contents of the HTML help documentation and to the tree view.
 
 TOC_EXPAND             = NO
 
-# If the GENERATE_QHP tag is set to YES and both QHP_NAMESPACE and QHP_VIRTUAL_FOLDER
-# are set, an additional index file will be generated that can be used as input for
-# Qt's qhelpgenerator to generate a Qt Compressed Help (.qch) of the generated
+# If the GENERATE_QHP tag is set to YES and both QHP_NAMESPACE and QHP_VIRTUAL_FOLDER 
+# are set, an additional index file will be generated that can be used as input for 
+# Qt's qhelpgenerator to generate a Qt Compressed Help (.qch) of the generated 
 # HTML documentation.
 
 GENERATE_QHP           = NO
 
-# If the QHG_LOCATION tag is specified, the QCH_FILE tag can
-# be used to specify the file name of the resulting .qch file.
+# If the QHG_LOCATION tag is specified, the QCH_FILE tag can 
+# be used to specify the file name of the resulting .qch file. 
 # The path specified is relative to the HTML output folder.
 
-QCH_FILE               =
+QCH_FILE               = 
 
-# The QHP_NAMESPACE tag specifies the namespace to use when generating
-# Qt Help Project output. For more information please see
+# The QHP_NAMESPACE tag specifies the namespace to use when generating 
+# Qt Help Project output. For more information please see 
 # http://doc.trolltech.com/qthelpproject.html#namespace
 
 QHP_NAMESPACE          = org.doxygen.Project
 
-# The QHP_VIRTUAL_FOLDER tag specifies the namespace to use when generating
-# Qt Help Project output. For more information please see
+# The QHP_VIRTUAL_FOLDER tag specifies the namespace to use when generating 
+# Qt Help Project output. For more information please see 
 # http://doc.trolltech.com/qthelpproject.html#virtual-folders
 
 QHP_VIRTUAL_FOLDER     = doc
 
-# If QHP_CUST_FILTER_NAME is set, it specifies the name of a custom filter to add.
-# For more information please see
+# If QHP_CUST_FILTER_NAME is set, it specifies the name of a custom filter to add. 
+# For more information please see 
 # http://doc.trolltech.com/qthelpproject.html#custom-filters
 
-QHP_CUST_FILTER_NAME   =
+QHP_CUST_FILTER_NAME   = 
 
-# The QHP_CUST_FILT_ATTRS tag specifies the list of the attributes of the custom filter to add.For more information please see
+# The QHP_CUST_FILT_ATTRS tag specifies the list of the attributes of the custom filter to add.For more information please see 
 # <a href="http://doc.trolltech.com/qthelpproject.html#custom-filters">Qt Help Project / Custom Filters</a>.
 
-QHP_CUST_FILTER_ATTRS  =
+QHP_CUST_FILTER_ATTRS  = 
 
-# The QHP_SECT_FILTER_ATTRS tag specifies the list of the attributes this project's
-# filter section matches.
+# The QHP_SECT_FILTER_ATTRS tag specifies the list of the attributes this project's 
+# filter section matches. 
 # <a href="http://doc.trolltech.com/qthelpproject.html#filter-attributes">Qt Help Project / Filter Attributes</a>.
 
-QHP_SECT_FILTER_ATTRS  =
+QHP_SECT_FILTER_ATTRS  = 
 
-# If the GENERATE_QHP tag is set to YES, the QHG_LOCATION tag can
-# be used to specify the location of Qt's qhelpgenerator.
-# If non-empty doxygen will try to run qhelpgenerator on the generated
+# If the GENERATE_QHP tag is set to YES, the QHG_LOCATION tag can 
+# be used to specify the location of Qt's qhelpgenerator. 
+# If non-empty doxygen will try to run qhelpgenerator on the generated 
 # .qhp file.
 
-QHG_LOCATION           =
+QHG_LOCATION           = 
 
-# If the GENERATE_ECLIPSEHELP tag is set to YES, additional index files
-# will be generated, which together with the HTML files, form an Eclipse help
-# plugin. To install this plugin and make it available under the help contents
-# menu in Eclipse, the contents of the directory containing the HTML and XML
-# files needs to be copied into the plugins directory of eclipse. The name of
-# the directory within the plugins directory should be the same as
+# If the GENERATE_ECLIPSEHELP tag is set to YES, additional index files  
+# will be generated, which together with the HTML files, form an Eclipse help  
+# plugin. To install this plugin and make it available under the help contents 
+# menu in Eclipse, the contents of the directory containing the HTML and XML 
+# files needs to be copied into the plugins directory of eclipse. The name of 
+# the directory within the plugins directory should be the same as 
 # the ECLIPSE_DOC_ID value. After copying Eclipse needs to be restarted before
 # the help appears.
 
 GENERATE_ECLIPSEHELP   = NO
 
-# A unique identifier for the eclipse help plugin. When installing the plugin
-# the directory name containing the HTML and XML files should also have
+# A unique identifier for the eclipse help plugin. When installing the plugin 
+# the directory name containing the HTML and XML files should also have 
 # this name.
 
 ECLIPSE_DOC_ID         = org.doxygen.Project
 
-# The DISABLE_INDEX tag can be used to turn on/off the condensed index at
-# top of each HTML page. The value NO (the default) enables the index and
+# The DISABLE_INDEX tag can be used to turn on/off the condensed index at 
+# top of each HTML page. The value NO (the default) enables the index and 
 # the value YES disables it.
 
 DISABLE_INDEX          = NO
 
-# This tag can be used to set the number of enum values (range [1..20])
+# This tag can be used to set the number of enum values (range [1..20]) 
 # that doxygen will group on one line in the generated HTML documentation.
 
 ENUM_VALUES_PER_LINE   = 4
 
-# The GENERATE_TREEVIEW tag is used to specify whether a tree-like index
-# structure should be generated to display hierarchical information.
-# If the tag value is set to YES, a side panel will be generated
-# containing a tree-like index structure (just like the one that
-# is generated for HTML Help). For this to work a browser that supports
-# JavaScript, DHTML, CSS and frames is required (i.e. any modern browser).
+# The GENERATE_TREEVIEW tag is used to specify whether a tree-like index 
+# structure should be generated to display hierarchical information. 
+# If the tag value is set to YES, a side panel will be generated 
+# containing a tree-like index structure (just like the one that 
+# is generated for HTML Help). For this to work a browser that supports 
+# JavaScript, DHTML, CSS and frames is required (i.e. any modern browser). 
 # Windows users are probably better off using the HTML help feature.
 
 GENERATE_TREEVIEW      = YES
 
-# By enabling USE_INLINE_TREES, doxygen will generate the Groups, Directories,
+# By enabling USE_INLINE_TREES, doxygen will generate the Groups, Directories, 
 # and Class Hierarchy pages using a tree view instead of an ordered list.
 
 USE_INLINE_TREES       = NO
 
-# If the treeview is enabled (see GENERATE_TREEVIEW) then this tag can be
-# used to set the initial width (in pixels) of the frame in which the tree
+# If the treeview is enabled (see GENERATE_TREEVIEW) then this tag can be 
+# used to set the initial width (in pixels) of the frame in which the tree 
 # is shown.
 
 TREEVIEW_WIDTH         = 250
 
-# Use this tag to change the font size of Latex formulas included
-# as images in the HTML documentation. The default is 10. Note that
-# when you change the font size after a successful doxygen run you need
-# to manually remove any form_*.png images from the HTML output directory
+# Use this tag to change the font size of Latex formulas included 
+# as images in the HTML documentation. The default is 10. Note that 
+# when you change the font size after a successful doxygen run you need 
+# to manually remove any form_*.png images from the HTML output directory 
 # to force them to be regenerated.
 
 FORMULA_FONTSIZE       = 10
 
 # When the SEARCHENGINE tag is enabled doxygen will generate a search box
-# for the HTML output. The underlying search engine uses javascript
+# for the HTML output. The underlying search engine uses javascript 
 # and DHTML and should work on any modern browser. Note that when using
 # HTML help (GENERATE_HTMLHELP), Qt help (GENERATE_QHP), or docsets
-# (GENERATE_DOCSET) there is already a search function so this one should
-# typically be disabled. For large projects the javascript based search engine
+# (GENERATE_DOCSET) there is already a search function so this one should 
+# typically be disabled. For large projects the javascript based search engine 
 # can be slow, then enabling SERVER_BASED_SEARCH may provide a better solution.
 
 SEARCHENGINE           = NO
 
 # When the SERVER_BASED_SEARCH tag is enabled the search engine will be
 # implemented using a PHP enabled web server instead of at the web client
-# using Javascript. Doxygen will generate the search PHP script and index
+# using Javascript. Doxygen will generate the search PHP script and index 
 # file to put on the web server. The advantage of the server
 # based approach is that it scales better to large projects and allows
-# full text search. The disadvances is that it is more difficult to setup
+# full text search. The disadvances is that it is more difficult to setup 
 # and does not have live searching capabilities.
 
 SERVER_BASED_SEARCH    = NO
@@ -1065,77 +1065,77 @@ SERVER_BASED_SEARCH    = NO
 # configuration options related to the LaTeX output
 #---------------------------------------------------------------------------
 
-# If the GENERATE_LATEX tag is set to YES (the default) Doxygen will
+# If the GENERATE_LATEX tag is set to YES (the default) Doxygen will 
 # generate Latex output.
 
 GENERATE_LATEX         = NO
 
-# The LATEX_OUTPUT tag is used to specify where the LaTeX docs will be put.
-# If a relative path is entered the value of OUTPUT_DIRECTORY will be
+# The LATEX_OUTPUT tag is used to specify where the LaTeX docs will be put. 
+# If a relative path is entered the value of OUTPUT_DIRECTORY will be 
 # put in front of it. If left blank `latex' will be used as the default path.
 
 LATEX_OUTPUT           = latex
 
-# The LATEX_CMD_NAME tag can be used to specify the LaTeX command name to be
-# invoked. If left blank `latex' will be used as the default command name.
-# Note that when enabling USE_PDFLATEX this option is only used for
-# generating bitmaps for formulas in the HTML output, but not in the
+# The LATEX_CMD_NAME tag can be used to specify the LaTeX command name to be 
+# invoked. If left blank `latex' will be used as the default command name. 
+# Note that when enabling USE_PDFLATEX this option is only used for 
+# generating bitmaps for formulas in the HTML output, but not in the 
 # Makefile that is written to the output directory.
 
 LATEX_CMD_NAME         = latex
 
-# The MAKEINDEX_CMD_NAME tag can be used to specify the command name to
-# generate index for LaTeX. If left blank `makeindex' will be used as the
+# The MAKEINDEX_CMD_NAME tag can be used to specify the command name to 
+# generate index for LaTeX. If left blank `makeindex' will be used as the 
 # default command name.
 
 MAKEINDEX_CMD_NAME     = makeindex
 
-# If the COMPACT_LATEX tag is set to YES Doxygen generates more compact
-# LaTeX documents. This may be useful for small projects and may help to
+# If the COMPACT_LATEX tag is set to YES Doxygen generates more compact 
+# LaTeX documents. This may be useful for small projects and may help to 
 # save some trees in general.
 
 COMPACT_LATEX          = NO
 
-# The PAPER_TYPE tag can be used to set the paper type that is used
-# by the printer. Possible values are: a4, a4wide, letter, legal and
+# The PAPER_TYPE tag can be used to set the paper type that is used 
+# by the printer. Possible values are: a4, a4wide, letter, legal and 
 # executive. If left blank a4wide will be used.
 
 PAPER_TYPE             = a4wide
 
-# The EXTRA_PACKAGES tag can be to specify one or more names of LaTeX
+# The EXTRA_PACKAGES tag can be to specify one or more names of LaTeX 
 # packages that should be included in the LaTeX output.
 
-EXTRA_PACKAGES         =
+EXTRA_PACKAGES         = 
 
-# The LATEX_HEADER tag can be used to specify a personal LaTeX header for
-# the generated latex document. The header should contain everything until
-# the first chapter. If it is left blank doxygen will generate a
+# The LATEX_HEADER tag can be used to specify a personal LaTeX header for 
+# the generated latex document. The header should contain everything until 
+# the first chapter. If it is left blank doxygen will generate a 
 # standard header. Notice: only use this tag if you know what you are doing!
 
-LATEX_HEADER           =
+LATEX_HEADER           = 
 
-# If the PDF_HYPERLINKS tag is set to YES, the LaTeX that is generated
-# is prepared for conversion to pdf (using ps2pdf). The pdf file will
-# contain links (just like the HTML output) instead of page references
+# If the PDF_HYPERLINKS tag is set to YES, the LaTeX that is generated 
+# is prepared for conversion to pdf (using ps2pdf). The pdf file will 
+# contain links (just like the HTML output) instead of page references 
 # This makes the output suitable for online browsing using a pdf viewer.
 
 PDF_HYPERLINKS         = YES
 
-# If the USE_PDFLATEX tag is set to YES, pdflatex will be used instead of
-# plain latex in the generated Makefile. Set this option to YES to get a
+# If the USE_PDFLATEX tag is set to YES, pdflatex will be used instead of 
+# plain latex in the generated Makefile. Set this option to YES to get a 
 # higher quality PDF documentation.
 
 USE_PDFLATEX           = YES
 
-# If the LATEX_BATCHMODE tag is set to YES, doxygen will add the \\batchmode.
-# command to the generated LaTeX files. This will instruct LaTeX to keep
-# running if errors occur, instead of asking the user for help.
+# If the LATEX_BATCHMODE tag is set to YES, doxygen will add the \\batchmode. 
+# command to the generated LaTeX files. This will instruct LaTeX to keep 
+# running if errors occur, instead of asking the user for help. 
 # This option is also used when generating formulas in HTML.
 
 LATEX_BATCHMODE        = NO
 
-# If LATEX_HIDE_INDICES is set to YES then doxygen will not
-# include the index chapters (such as File Index, Compound Index, etc.)
+# If LATEX_HIDE_INDICES is set to YES then doxygen will not 
+# include the index chapters (such as File Index, Compound Index, etc.) 
 # in the output.
 
 LATEX_HIDE_INDICES     = NO
@@ -1151,68 +1151,68 @@ LATEX_SOURCE_CODE      = NO
 # configuration options related to the RTF output
 #---------------------------------------------------------------------------
 
-# If the GENERATE_RTF tag is set to YES Doxygen will generate RTF output
-# The RTF output is optimized for Word 97 and may not look very pretty with
+# If the GENERATE_RTF tag is set to YES Doxygen will generate RTF output 
+# The RTF output is optimized for Word 97 and may not look very pretty with 
 # other RTF readers or editors.
 
 GENERATE_RTF           = NO
 
-# The RTF_OUTPUT tag is used to specify where the RTF docs will be put.
-# If a relative path is entered the value of OUTPUT_DIRECTORY will be
+# The RTF_OUTPUT tag is used to specify where the RTF docs will be put. 
+# If a relative path is entered the value of OUTPUT_DIRECTORY will be 
 # put in front of it. If left blank `rtf' will be used as the default path.
 
 RTF_OUTPUT             = rtf
 
-# If the COMPACT_RTF tag is set to YES Doxygen generates more compact
-# RTF documents. This may be useful for small projects and may help to
+# If the COMPACT_RTF tag is set to YES Doxygen generates more compact 
+# RTF documents. This may be useful for small projects and may help to 
 # save some trees in general.
 
 COMPACT_RTF            = NO
 
-# If the RTF_HYPERLINKS tag is set to YES, the RTF that is generated
-# will contain hyperlink fields. The RTF file will
-# contain links (just like the HTML output) instead of page references.
-# This makes the output suitable for online browsing using WORD or other
-# programs which support those fields.
+# If the RTF_HYPERLINKS tag is set to YES, the RTF that is generated 
+# will contain hyperlink fields. The RTF file will 
+# contain links (just like the HTML output) instead of page references. 
+# This makes the output suitable for online browsing using WORD or other 
+# programs which support those fields. 
 # Note: wordpad (write) and others do not support links.
 
 RTF_HYPERLINKS         = NO
 
-# Load stylesheet definitions from file. Syntax is similar to doxygen's
-# config file, i.e. a series of assignments. You only have to provide
+# Load stylesheet definitions from file. Syntax is similar to doxygen's 
+# config file, i.e. a series of assignments. You only have to provide 
 # replacements, missing definitions are set to their default value.
 
-RTF_STYLESHEET_FILE    =
+RTF_STYLESHEET_FILE    = 
 
-# Set optional variables used in the generation of an rtf document.
+# Set optional variables used in the generation of an rtf document. 
 # Syntax is similar to doxygen's config file.
 
-RTF_EXTENSIONS_FILE    =
+RTF_EXTENSIONS_FILE    = 
 
 #---------------------------------------------------------------------------
 # configuration options related to the man page output
 #---------------------------------------------------------------------------
 
-# If the GENERATE_MAN tag is set to YES (the default) Doxygen will
+# If the GENERATE_MAN tag is set to YES (the default) Doxygen will 
 # generate man pages
 
 GENERATE_MAN           = NO
 
-# The MAN_OUTPUT tag is used to specify where the man pages will be put.
-# If a relative path is entered the value of OUTPUT_DIRECTORY will be
+# The MAN_OUTPUT tag is used to specify where the man pages will be put. 
+# If a relative path is entered the value of OUTPUT_DIRECTORY will be 
 # put in front of it. If left blank `man' will be used as the default path.
 
 MAN_OUTPUT             = man
 
-# The MAN_EXTENSION tag determines the extension that is added to
+# The MAN_EXTENSION tag determines the extension that is added to 
 # the generated man pages (default is the subroutine's section .3)
 
 MAN_EXTENSION          = .3
 
-# If the MAN_LINKS tag is set to YES and Doxygen generates man output,
-# then it will generate one additional man file for each entity
-# documented in the real man page(s). These additional files
-# only source the real man page, but without them the man command
+# If the MAN_LINKS tag is set to YES and Doxygen generates man output, 
+# then it will generate one additional man file for each entity 
+# documented in the real man page(s). These additional files 
+# only source the real man page, but without them the man command 
 # would be unable to find the correct page. The default is NO.
 
 MAN_LINKS              = NO
@@ -1221,33 +1221,33 @@ MAN_LINKS              = NO
 # configuration options related to the XML output
 #---------------------------------------------------------------------------
 
-# If the GENERATE_XML tag is set to YES Doxygen will
-# generate an XML file that captures the structure of
+# If the GENERATE_XML tag is set to YES Doxygen will 
+# generate an XML file that captures the structure of 
 # the code including all documentation.
 
 GENERATE_XML           = NO
 
-# The XML_OUTPUT tag is used to specify where the XML pages will be put.
-# If a relative path is entered the value of OUTPUT_DIRECTORY will be
+# The XML_OUTPUT tag is used to specify where the XML pages will be put. 
+# If a relative path is entered the value of OUTPUT_DIRECTORY will be 
 # put in front of it. If left blank `xml' will be used as the default path.
 
 XML_OUTPUT             = xml
 
-# The XML_SCHEMA tag can be used to specify an XML schema,
-# which can be used by a validating XML parser to check the
+# The XML_SCHEMA tag can be used to specify an XML schema, 
+# which can be used by a validating XML parser to check the 
 # syntax of the XML files.
 
-XML_SCHEMA             =
+XML_SCHEMA             = 
 
-# The XML_DTD tag can be used to specify an XML DTD,
-# which can be used by a validating XML parser to check the
+# The XML_DTD tag can be used to specify an XML DTD, 
+# which can be used by a validating XML parser to check the 
 # syntax of the XML files.
 
-XML_DTD                =
+XML_DTD                = 
 
-# If the XML_PROGRAMLISTING tag is set to YES Doxygen will
-# dump the program listings (including syntax highlighting
-# and cross-referencing information) to the XML output. Note that
+# If the XML_PROGRAMLISTING tag is set to YES Doxygen will 
+# dump the program listings (including syntax highlighting 
+# and cross-referencing information) to the XML output. Note that 
 # enabling this will significantly increase the size of the XML output.
 
 XML_PROGRAMLISTING     = YES
@@ -1256,10 +1256,10 @@ XML_PROGRAMLISTING     = YES
 # configuration options for the AutoGen Definitions output
 #---------------------------------------------------------------------------
 
-# If the GENERATE_AUTOGEN_DEF tag is set to YES Doxygen will
-# generate an AutoGen Definitions (see autogen.sf.net) file
-# that captures the structure of the code including all
-# documentation. Note that this feature is still experimental
+# If the GENERATE_AUTOGEN_DEF tag is set to YES Doxygen will 
+# generate an AutoGen Definitions (see autogen.sf.net) file 
+# that captures the structure of the code including all 
+# documentation. Note that this feature is still experimental 
 # and incomplete at the moment.
 
 GENERATE_AUTOGEN_DEF   = NO
@@ -1268,97 +1268,97 @@ GENERATE_AUTOGEN_DEF   = NO
 # configuration options related to the Perl module output
 #---------------------------------------------------------------------------
 
-# If the GENERATE_PERLMOD tag is set to YES Doxygen will
-# generate a Perl module file that captures the structure of
-# the code including all documentation. Note that this
-# feature is still experimental and incomplete at the
+# If the GENERATE_PERLMOD tag is set to YES Doxygen will 
+# generate a Perl module file that captures the structure of 
+# the code including all documentation. Note that this 
+# feature is still experimental and incomplete at the 
 # moment.
 
 GENERATE_PERLMOD       = NO
 
-# If the PERLMOD_LATEX tag is set to YES Doxygen will generate
-# the necessary Makefile rules, Perl scripts and LaTeX code to be able
+# If the PERLMOD_LATEX tag is set to YES Doxygen will generate 
+# the necessary Makefile rules, Perl scripts and LaTeX code to be able 
 # to generate PDF and DVI output from the Perl module output.
 
 PERLMOD_LATEX          = NO
 
-# If the PERLMOD_PRETTY tag is set to YES the Perl module output will be
-# nicely formatted so it can be parsed by a human reader.  This is useful
-# if you want to understand what is going on.  On the other hand, if this
-# tag is set to NO the size of the Perl module output will be much smaller
+# If the PERLMOD_PRETTY tag is set to YES the Perl module output will be 
+# nicely formatted so it can be parsed by a human reader.  This is useful 
+# if you want to understand what is going on.  On the other hand, if this 
+# tag is set to NO the size of the Perl module output will be much smaller 
 # and Perl will parse it just the same.
 
 PERLMOD_PRETTY         = YES
 
-# The names of the make variables in the generated doxyrules.make file
-# are prefixed with the string contained in PERLMOD_MAKEVAR_PREFIX.
-# This is useful so different doxyrules.make files included by the same
+# The names of the make variables in the generated doxyrules.make file 
+# are prefixed with the string contained in PERLMOD_MAKEVAR_PREFIX. 
+# This is useful so different doxyrules.make files included by the same 
 # Makefile don't overwrite each other's variables.
 
-PERLMOD_MAKEVAR_PREFIX =
+PERLMOD_MAKEVAR_PREFIX = 
 
 #---------------------------------------------------------------------------
 # Configuration options related to the preprocessor
 #---------------------------------------------------------------------------
 
-# If the ENABLE_PREPROCESSING tag is set to YES (the default) Doxygen will
-# evaluate all C-preprocessor directives found in the sources and include
+# If the ENABLE_PREPROCESSING tag is set to YES (the default) Doxygen will 
+# evaluate all C-preprocessor directives found in the sources and include 
 # files.
 
 ENABLE_PREPROCESSING   = YES
 
-# If the MACRO_EXPANSION tag is set to YES Doxygen will expand all macro
-# names in the source code. If set to NO (the default) only conditional
-# compilation will be performed. Macro expansion can be done in a controlled
+# If the MACRO_EXPANSION tag is set to YES Doxygen will expand all macro 
+# names in the source code. If set to NO (the default) only conditional 
+# compilation will be performed. Macro expansion can be done in a controlled 
 # way by setting EXPAND_ONLY_PREDEF to YES.
 
 MACRO_EXPANSION        = NO
 
-# If the EXPAND_ONLY_PREDEF and MACRO_EXPANSION tags are both set to YES
-# then the macro expansion is limited to the macros specified with the
+# If the EXPAND_ONLY_PREDEF and MACRO_EXPANSION tags are both set to YES 
+# then the macro expansion is limited to the macros specified with the 
 # PREDEFINED and EXPAND_AS_DEFINED tags.
 
 EXPAND_ONLY_PREDEF     = NO
 
-# If the SEARCH_INCLUDES tag is set to YES (the default) the includes files
+# If the SEARCH_INCLUDES tag is set to YES (the default) the includes files 
 # in the INCLUDE_PATH (see below) will be search if a #include is found.
 
 SEARCH_INCLUDES        = YES
 
-# The INCLUDE_PATH tag can be used to specify one or more directories that
-# contain include files that are not input files but should be processed by
+# The INCLUDE_PATH tag can be used to specify one or more directories that 
+# contain include files that are not input files but should be processed by 
 # the preprocessor.
 
-INCLUDE_PATH           =
+INCLUDE_PATH           = 
 
-# You can use the INCLUDE_FILE_PATTERNS tag to specify one or more wildcard
-# patterns (like *.h and *.hpp) to filter out the header-files in the
-# directories. If left blank, the patterns specified with FILE_PATTERNS will
+# You can use the INCLUDE_FILE_PATTERNS tag to specify one or more wildcard 
+# patterns (like *.h and *.hpp) to filter out the header-files in the 
+# directories. If left blank, the patterns specified with FILE_PATTERNS will 
 # be used.
 
-INCLUDE_FILE_PATTERNS  =
+INCLUDE_FILE_PATTERNS  = 
 
-# The PREDEFINED tag can be used to specify one or more macro names that
-# are defined before the preprocessor is started (similar to the -D option of
-# gcc). The argument of the tag is a list of macros of the form: name
-# or name=definition (no spaces). If the definition and the = are
-# omitted =1 is assumed. To prevent a macro definition from being
-# undefined via #undef or recursively expanded use the := operator
+# The PREDEFINED tag can be used to specify one or more macro names that 
+# are defined before the preprocessor is started (similar to the -D option of 
+# gcc). The argument of the tag is a list of macros of the form: name 
+# or name=definition (no spaces). If the definition and the = are 
+# omitted =1 is assumed. To prevent a macro definition from being 
+# undefined via #undef or recursively expanded use the := operator 
 # instead of the = operator.
 
-PREDEFINED             =
+PREDEFINED             = 
 
-# If the MACRO_EXPANSION and EXPAND_ONLY_PREDEF tags are set to YES then
-# this tag can be used to specify a list of macro names that should be expanded.
-# The macro definition that is found in the sources will be used.
+# If the MACRO_EXPANSION and EXPAND_ONLY_PREDEF tags are set to YES then 
+# this tag can be used to specify a list of macro names that should be expanded. 
+# The macro definition that is found in the sources will be used. 
 # Use the PREDEFINED tag if you want to use a different macro definition.
 
-EXPAND_AS_DEFINED      =
+EXPAND_AS_DEFINED      = 
 
-# If the SKIP_FUNCTION_MACROS tag is set to YES (the default) then
-# doxygen's preprocessor will remove all function-like macros that are alone
-# on a line, have an all uppercase name, and do not end with a semicolon. Such
-# function macros are typically used for boiler-plate code, and will confuse
+# If the SKIP_FUNCTION_MACROS tag is set to YES (the default) then 
+# doxygen's preprocessor will remove all function-like macros that are alone 
+# on a line, have an all uppercase name, and do not end with a semicolon. Such 
+# function macros are typically used for boiler-plate code, and will confuse 
 # the parser if not removed.
 
 SKIP_FUNCTION_MACROS   = YES
@@ -1367,41 +1367,41 @@ SKIP_FUNCTION_MACROS   = YES
 # Configuration::additions related to external references
 #---------------------------------------------------------------------------
 
-# The TAGFILES option can be used to specify one or more tagfiles.
-# Optionally an initial location of the external documentation
-# can be added for each tagfile. The format of a tag file without
-# this location is as follows:
-#   TAGFILES = file1 file2 ...
-# Adding location for the tag files is done as follows:
-#   TAGFILES = file1=loc1 "file2 = loc2" ...
-# where "loc1" and "loc2" can be relative or absolute paths or
-# URLs. If a location is present for each tag, the installdox tool
-# does not have to be run to correct the links.
-# Note that each tag file must have a unique name
-# (where the name does NOT include the path)
-# If a tag file is not located in the directory in which doxygen
+# The TAGFILES option can be used to specify one or more tagfiles. 
+# Optionally an initial location of the external documentation 
+# can be added for each tagfile. The format of a tag file without 
+# this location is as follows: 
+#   TAGFILES = file1 file2 ... 
+# Adding location for the tag files is done as follows: 
+#   TAGFILES = file1=loc1 "file2 = loc2" ... 
+# where "loc1" and "loc2" can be relative or absolute paths or 
+# URLs. If a location is present for each tag, the installdox tool 
+# does not have to be run to correct the links. 
+# Note that each tag file must have a unique name 
+# (where the name does NOT include the path) 
+# If a tag file is not located in the directory in which doxygen 
 # is run, you must also specify the path to the tagfile here.
 
-TAGFILES               =
+TAGFILES               = 
 
-# When a file name is specified after GENERATE_TAGFILE, doxygen will create
+# When a file name is specified after GENERATE_TAGFILE, doxygen will create 
 # a tag file that is based on the input files it reads.
 
-GENERATE_TAGFILE       =
+GENERATE_TAGFILE       = 
 
-# If the ALLEXTERNALS tag is set to YES all external classes will be listed
-# in the class index. If set to NO only the inherited external classes
+# If the ALLEXTERNALS tag is set to YES all external classes will be listed 
+# in the class index. If set to NO only the inherited external classes 
 # will be listed.
 
 ALLEXTERNALS           = NO
 
-# If the EXTERNAL_GROUPS tag is set to YES all external groups will be listed
-# in the modules index. If set to NO, only the current project's groups will
+# If the EXTERNAL_GROUPS tag is set to YES all external groups will be listed 
+# in the modules index. If set to NO, only the current project's groups will 
 # be listed.
 
 EXTERNAL_GROUPS        = YES
 
-# The PERL_PATH should be the absolute path and name of the perl script
+# The PERL_PATH should be the absolute path and name of the perl script 
 # interpreter (i.e. the result of `which perl').
 
 PERL_PATH              = /usr/bin/perl
@@ -1410,192 +1410,192 @@ PERL_PATH              = /usr/bin/perl
 # Configuration options related to the dot tool
 #---------------------------------------------------------------------------
 
-# If the CLASS_DIAGRAMS tag is set to YES (the default) Doxygen will
-# generate a inheritance diagram (in HTML, RTF and LaTeX) for classes with base
-# or super classes. Setting the tag to NO turns the diagrams off. Note that
-# this option is superseded by the HAVE_DOT option below. This is only a
-# fallback. It is recommended to install and use dot, since it yields more
+# If the CLASS_DIAGRAMS tag is set to YES (the default) Doxygen will 
+# generate a inheritance diagram (in HTML, RTF and LaTeX) for classes with base 
+# or super classes. Setting the tag to NO turns the diagrams off. Note that 
+# this option is superseded by the HAVE_DOT option below. This is only a 
+# fallback. It is recommended to install and use dot, since it yields more 
 # powerful graphs.
 
-CLASS_DIAGRAMS         = NO
+CLASS_DIAGRAMS         = YES
 
-# You can define message sequence charts within doxygen comments using the \msc
-# command. Doxygen will then run the mscgen tool (see
-# http://www.mcternan.me.uk/mscgen/) to produce the chart and insert it in the
-# documentation. The MSCGEN_PATH tag allows you to specify the directory where
-# the mscgen tool resides. If left empty the tool is assumed to be found in the
+# You can define message sequence charts within doxygen comments using the \msc 
+# command. Doxygen will then run the mscgen tool (see 
+# http://www.mcternan.me.uk/mscgen/) to produce the chart and insert it in the 
+# documentation. The MSCGEN_PATH tag allows you to specify the directory where 
+# the mscgen tool resides. If left empty the tool is assumed to be found in the 
 # default search path.
 
-MSCGEN_PATH            =
+MSCGEN_PATH            = 
 
-# If set to YES, the inheritance and collaboration graphs will hide
-# inheritance and usage relations if the target is undocumented
+# If set to YES, the inheritance and collaboration graphs will hide 
+# inheritance and usage relations if the target is undocumented 
 # or is not a class.
 
 HIDE_UNDOC_RELATIONS   = YES
 
-# If you set the HAVE_DOT tag to YES then doxygen will assume the dot tool is
-# available from the path. This tool is part of Graphviz, a graph visualization
-# toolkit from AT&T and Lucent Bell Labs. The other options in this section
+# If you set the HAVE_DOT tag to YES then doxygen will assume the dot tool is 
+# available from the path. This tool is part of Graphviz, a graph visualization 
+# toolkit from AT&T and Lucent Bell Labs. The other options in this section 
 # have no effect if this option is set to NO (the default)
 
-HAVE_DOT               = YES
+HAVE_DOT               = NO
 
-# By default doxygen will write a font called FreeSans.ttf to the output
-# directory and reference it in all dot files that doxygen generates. This
-# font does not include all possible unicode characters however, so when you need
-# these (or just want a differently looking font) you can specify the font name
-# using DOT_FONTNAME. You need need to make sure dot is able to find the font,
-# which can be done by putting it in a standard location or by setting the
-# DOTFONTPATH environment variable or by setting DOT_FONTPATH to the directory
+# By default doxygen will write a font called FreeSans.ttf to the output 
+# directory and reference it in all dot files that doxygen generates. This 
+# font does not include all possible unicode characters however, so when you need 
+# these (or just want a differently looking font) you can specify the font name 
+# using DOT_FONTNAME. You need need to make sure dot is able to find the font, 
+# which can be done by putting it in a standard location or by setting the 
+# DOTFONTPATH environment variable or by setting DOT_FONTPATH to the directory 
 # containing the font.
 
 DOT_FONTNAME           = FreeSans
 
-# The DOT_FONTSIZE tag can be used to set the size of the font of dot graphs.
+# The DOT_FONTSIZE tag can be used to set the size of the font of dot graphs. 
 # The default size is 10pt.
 
 DOT_FONTSIZE           = 10
 
-# By default doxygen will tell dot to use the output directory to look for the
-# FreeSans.ttf font (which doxygen will put there itself). If you specify a
-# different font using DOT_FONTNAME you can set the path where dot
+# By default doxygen will tell dot to use the output directory to look for the 
+# FreeSans.ttf font (which doxygen will put there itself). If you specify a 
+# different font using DOT_FONTNAME you can set the path where dot 
 # can find it using this tag.
 
-DOT_FONTPATH           =
+DOT_FONTPATH           = 
 
-# If the CLASS_GRAPH and HAVE_DOT tags are set to YES then doxygen
-# will generate a graph for each documented class showing the direct and
-# indirect inheritance relations. Setting this tag to YES will force the
+# If the CLASS_GRAPH and HAVE_DOT tags are set to YES then doxygen 
+# will generate a graph for each documented class showing the direct and 
+# indirect inheritance relations. Setting this tag to YES will force the 
 # the CLASS_DIAGRAMS tag to NO.
 
-CLASS_GRAPH            = NO
+CLASS_GRAPH            = YES
 
-# If the COLLABORATION_GRAPH and HAVE_DOT tags are set to YES then doxygen
-# will generate a graph for each documented class showing the direct and
-# indirect implementation dependencies (inheritance, containment, and
+# If the COLLABORATION_GRAPH and HAVE_DOT tags are set to YES then doxygen 
+# will generate a graph for each documented class showing the direct and 
+# indirect implementation dependencies (inheritance, containment, and 
 # class references variables) of the class with other documented classes.
 
-COLLABORATION_GRAPH    = NO
+COLLABORATION_GRAPH    = YES
 
-# If the GROUP_GRAPHS and HAVE_DOT tags are set to YES then doxygen
+# If the GROUP_GRAPHS and HAVE_DOT tags are set to YES then doxygen 
 # will generate a graph for groups, showing the direct groups dependencies
 
-GROUP_GRAPHS           = NO
+GROUP_GRAPHS           = YES
 
-# If the UML_LOOK tag is set to YES doxygen will generate inheritance and
-# collaboration diagrams in a style similar to the OMG's Unified Modeling
+# If the UML_LOOK tag is set to YES doxygen will generate inheritance and 
+# collaboration diagrams in a style similar to the OMG's Unified Modeling 
 # Language.
 
 UML_LOOK               = NO
 
-# If set to YES, the inheritance and collaboration graphs will show the
+# If set to YES, the inheritance and collaboration graphs will show the 
 # relations between templates and their instances.
 
 TEMPLATE_RELATIONS     = NO
 
-# If the ENABLE_PREPROCESSING, SEARCH_INCLUDES, INCLUDE_GRAPH, and HAVE_DOT
-# tags are set to YES then doxygen will generate a graph for each documented
-# file showing the direct and indirect include dependencies of the file with
+# If the ENABLE_PREPROCESSING, SEARCH_INCLUDES, INCLUDE_GRAPH, and HAVE_DOT 
+# tags are set to YES then doxygen will generate a graph for each documented 
+# file showing the direct and indirect include dependencies of the file with 
 # other documented files.
 
 INCLUDE_GRAPH          = YES
 
-# If the ENABLE_PREPROCESSING, SEARCH_INCLUDES, INCLUDED_BY_GRAPH, and
-# HAVE_DOT tags are set to YES then doxygen will generate a graph for each
-# documented header file showing the documented files that directly or
+# If the ENABLE_PREPROCESSING, SEARCH_INCLUDES, INCLUDED_BY_GRAPH, and 
+# HAVE_DOT tags are set to YES then doxygen will generate a graph for each 
+# documented header file showing the documented files that directly or 
 # indirectly include this file.
 
-INCLUDED_BY_GRAPH      = NO
+INCLUDED_BY_GRAPH      = YES
 
-# If the CALL_GRAPH and HAVE_DOT options are set to YES then
-# doxygen will generate a call dependency graph for every global function
-# or class method. Note that enabling this option will significantly increase
-# the time of a run. So in most cases it will be better to enable call graphs
+# If the CALL_GRAPH and HAVE_DOT options are set to YES then 
+# doxygen will generate a call dependency graph for every global function 
+# or class method. Note that enabling this option will significantly increase 
+# the time of a run. So in most cases it will be better to enable call graphs 
 # for selected functions only using the \callgraph command.
 
 CALL_GRAPH             = NO
 
-# If the CALLER_GRAPH and HAVE_DOT tags are set to YES then
-# doxygen will generate a caller dependency graph for every global function
-# or class method. Note that enabling this option will significantly increase
-# the time of a run. So in most cases it will be better to enable caller
+# If the CALLER_GRAPH and HAVE_DOT tags are set to YES then 
+# doxygen will generate a caller dependency graph for every global function 
+# or class method. Note that enabling this option will significantly increase 
+# the time of a run. So in most cases it will be better to enable caller 
 # graphs for selected functions only using the \callergraph command.
 
 CALLER_GRAPH           = NO
 
-# If the GRAPHICAL_HIERARCHY and HAVE_DOT tags are set to YES then doxygen
+# If the GRAPHICAL_HIERARCHY and HAVE_DOT tags are set to YES then doxygen 
 # will graphical hierarchy of all classes instead of a textual one.
 
-GRAPHICAL_HIERARCHY    = NO
+GRAPHICAL_HIERARCHY    = YES
 
-# If the DIRECTORY_GRAPH, SHOW_DIRECTORIES and HAVE_DOT tags are set to YES
-# then doxygen will show the dependencies a directory has on other directories
-# in a graphical way. The dependency relations are determined by the #include
+# If the DIRECTORY_GRAPH, SHOW_DIRECTORIES and HAVE_DOT tags are set to YES 
+# then doxygen will show the dependencies a directory has on other directories 
+# in a graphical way. The dependency relations are determined by the #include 
 # relations between the files in the directories.
 
 DIRECTORY_GRAPH        = YES
 
-# The DOT_IMAGE_FORMAT tag can be used to set the image format of the images
-# generated by dot. Possible values are png, jpg, or gif
+# The DOT_IMAGE_FORMAT tag can be used to set the image format of the images 
+# generated by dot. Possible values are png, jpg, or gif 
 # If left blank png will be used.
 
 DOT_IMAGE_FORMAT       = png
 
-# The tag DOT_PATH can be used to specify the path where the dot tool can be
+# The tag DOT_PATH can be used to specify the path where the dot tool can be 
 # found. If left blank, it is assumed the dot tool can be found in the path.
 
-DOT_PATH               =
+DOT_PATH               = 
 
-# The DOTFILE_DIRS tag can be used to specify one or more directories that
-# contain dot files that are included in the documentation (see the
+# The DOTFILE_DIRS tag can be used to specify one or more directories that 
+# contain dot files that are included in the documentation (see the 
 # \dotfile command).
 
-DOTFILE_DIRS           =
+DOTFILE_DIRS           = 
 
-# The DOT_GRAPH_MAX_NODES tag can be used to set the maximum number of
-# nodes that will be shown in the graph. If the number of nodes in a graph
-# becomes larger than this value, doxygen will truncate the graph, which is
-# visualized by representing a node as a red box. Note that doxygen if the
-# number of direct children of the root node in a graph is already larger than
-# DOT_GRAPH_MAX_NODES then the graph will not be shown at all. Also note
+# The DOT_GRAPH_MAX_NODES tag can be used to set the maximum number of 
+# nodes that will be shown in the graph. If the number of nodes in a graph 
+# becomes larger than this value, doxygen will truncate the graph, which is 
+# visualized by representing a node as a red box. Note that doxygen if the 
+# number of direct children of the root node in a graph is already larger than 
+# DOT_GRAPH_MAX_NODES then the graph will not be shown at all. Also note 
 # that the size of a graph can be further restricted by MAX_DOT_GRAPH_DEPTH.
 
 DOT_GRAPH_MAX_NODES    = 50
 
-# The MAX_DOT_GRAPH_DEPTH tag can be used to set the maximum depth of the
-# graphs generated by dot. A depth value of 3 means that only nodes reachable
-# from the root by following a path via at most 3 edges will be shown. Nodes
-# that lay further from the root node will be omitted. Note that setting this
-# option to 1 or 2 may greatly reduce the computation time needed for large
-# code bases. Also note that the size of a graph can be further restricted by
+# The MAX_DOT_GRAPH_DEPTH tag can be used to set the maximum depth of the 
+# graphs generated by dot. A depth value of 3 means that only nodes reachable 
+# from the root by following a path via at most 3 edges will be shown. Nodes 
+# that lay further from the root node will be omitted. Note that setting this 
+# option to 1 or 2 may greatly reduce the computation time needed for large 
+# code bases. Also note that the size of a graph can be further restricted by 
 # DOT_GRAPH_MAX_NODES. Using a depth of 0 means no depth restriction.
 
 MAX_DOT_GRAPH_DEPTH    = 0
 
-# Set the DOT_TRANSPARENT tag to YES to generate images with a transparent
-# background. This is disabled by default, because dot on Windows does not
-# seem to support this out of the box. Warning: Depending on the platform used,
-# enabling this option may lead to badly anti-aliased labels on the edges of
+# Set the DOT_TRANSPARENT tag to YES to generate images with a transparent 
+# background. This is disabled by default, because dot on Windows does not 
+# seem to support this out of the box. Warning: Depending on the platform used, 
+# enabling this option may lead to badly anti-aliased labels on the edges of 
 # a graph (i.e. they become hard to read).
 
 DOT_TRANSPARENT        = NO
 
-# Set the DOT_MULTI_TARGETS tag to YES allow dot to generate multiple output
-# files in one run (i.e. multiple -o and -T options on the command line). This
-# makes dot run faster, but since only newer versions of dot (>1.8.10)
+# Set the DOT_MULTI_TARGETS tag to YES allow dot to generate multiple output 
+# files in one run (i.e. multiple -o and -T options on the command line). This 
+# makes dot run faster, but since only newer versions of dot (>1.8.10) 
 # support this, this feature is disabled by default.
 
 DOT_MULTI_TARGETS      = NO
 
-# If the GENERATE_LEGEND tag is set to YES (the default) Doxygen will
-# generate a legend page explaining the meaning of the various boxes and
+# If the GENERATE_LEGEND tag is set to YES (the default) Doxygen will 
+# generate a legend page explaining the meaning of the various boxes and 
 # arrows in the dot generated graphs.
 
 GENERATE_LEGEND        = YES
 
-# If the DOT_CLEANUP tag is set to YES (the default) Doxygen will
-# remove the intermediate dot files that are used to generate
+# If the DOT_CLEANUP tag is set to YES (the default) Doxygen will 
+# remove the intermediate dot files that are used to generate 
 # the various graphs.
 
 DOT_CLEANUP            = YES
diff --git a/doc/coding-style b/doc/coding-style
index 1dddf5a..379a01c 100644
--- a/doc/coding-style
+++ b/doc/coding-style
@@ -233,22 +233,4 @@ try to adhere to some higher level idioms.
 
     * when using long or long long qualifiers, omit int;
 
-    * declare one variable per line;
-
-    * avoid dead assignments and initializations (i.e., assignments
-      which are overwritten before the variable is read)
-
-        int x = 0;
-
-        if (y)
-                x = foo();
-        else
-                x = bar();
-
-      Instead, initialize a variable with a meaningful value, when the
-      latter is known.
-
-      (Rationale: dead initializations potentially hide errors. If,
-      after the code restructuring, the variable remains
-      un-initialized in a conditional branch or in a loop that might
-      execute 0 times, the initializer suppresses compiler warning).
+    * declare one variable per line.
diff --git a/doc/dld-index.c b/doc/dld-index.c
deleted file mode 100644
index b73a7ba..0000000
--- a/doc/dld-index.c
+++ /dev/null
@@ -1,24 +0,0 @@
-/**
-
-@page DLDIX Detailed Designs
-
-Detailed designs, ordered alphabetically:
-
-- @subpage c2t1fs "C2T1FS detailed level design specification"
-           <!-- c2t1fs/main.c -->
-- @subpage DLD_conf_schema "DLD for configuration schema"
-           <!-- cfg/cfg.h -->
-- @subpage LNetDLD "LNet Transport DLD"
-           <!-- net/lnet/lnet_main.c -->
-- @subpage rpc-layer-core-dld "RPC layer core DLD"
-           <!-- rpc/rpc2.h -->
-- @subpage rpc-slot "RPC Slot"
-           <!-- rpc/slot.h -->
-- @subpage snsrepair "SNS repair detailed level design"
-           <!-- sns/repair.h -->
-
-Detailed designs should use the <i>@subpage DLD "Colibri DLD Template"
-<!-- doc/dld-template.c --> </i> as a style guide.
-Higher level designs can be found in the <a href="https://docs.google.com/a/xyratex.com/#folders/0B-6nd3Xo8hzBZGJlNjE2NTctZDA1OC00NTIyLWJhOGItM2U5MTc2MjJjODNm">Colibri Design Folder</a>.
-
- */
diff --git a/doc/dld-template.c b/doc/dld-template.c
deleted file mode 100644
index b18061b..0000000
--- a/doc/dld-template.c
+++ /dev/null
@@ -1,587 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Carl Braganza <Carl_Braganza@us.xyratex.com>
- * Original creation date: 09/26/2011
- */
-
-/**
-   @page DLD Colibri DLD Template
-
-   - @ref DLD-ovw
-   - @ref DLD-def
-   - @ref DLD-req
-   - @ref DLD-depends
-   - @ref DLD-highlights
-   - @subpage DLD-fspec "Functional Specification" <!-- Note @subpage -->
-   - @ref DLD-lspec
-      - @ref DLD-lspec-comps
-      - @ref DLD-lspec-sc1
-      - @ref DLD-lspec-state
-      - @ref DLD-lspec-thread
-      - @ref DLD-lspec-numa
-   - @ref DLD-conformance
-   - @ref DLD-ut
-   - @ref DLD-st
-   - @ref DLD-O
-   - @ref DLD-ref
-
-
-   <hr>
-   @section DLD-ovw Overview
-   <i>All specifications must start with an Overview section that
-   briefly describes the document and provides any additional
-   instructions or hints on how to best read the specification.</i>
-
-   This document is intended to be a style guide for a detail level
-   design specification, and is designed to be viewed both through a
-   text editor and in a browser after Doxygen processing.
-
-   You can use this document as a template by deleting all content,
-   while retaining the sections referenced above and the overall
-   Doxygen structure of a page with one or more component modules.
-   You <b><i>must</i></b> change the Doxygen reference tags used in
-   @@page, @@section, @@subsection and @@defgroup examples when
-   copying this template, and adjust @@ref and @@subpage references in
-   the table of contents of your own document accordingly.
-
-   Please provide a table of contents for the major sections, as shown above.
-   Please use horizontal ruling exactly as shown in this template, and do not
-   introduce additional lines.
-
-   It is recommended that you retain the italicized instructions that
-   follow the formally recognized section headers, until at least the
-   DLD review phase.  You may leave the instructions in the final
-   document if you wish.
-
-   It is imperative that the document be neat when viewed textually
-   through an editor and when browsing the Doxygen output - it is
-   intended to be relevant for the entire code life-cycle.  Please
-   check your grammar and punctuation, and run the document through a
-   spelling checker.  It is also recommended that you run the source
-   document through a paragraph formatting tool to produce neater
-   text, though be careful while doing so as text formatters do not
-   understand Doxygen syntax and significant line breaks.
-
-   Please link your DLD to the index of all detailed designs maintained
-   in @ref DLDIX "Detailed Designs". <!-- doc/dld-index.c -->
-
-   <b>Purpose of a DLD</b><br>
-   The purpose of the Detailed Level Design (DLD) specification of a
-   component is to:
-   - Refine higher level designs
-   - To be verified by inspectors and architects
-   - To guide the coding phase
-
-   <b>Location and layout of the DLD Specification</b><br>
-   The Colibri project requires Detailed Level Designs in the source
-   code itself.  This greatly aids in keeping the design documentation
-   up to date through the lifetime of the implementation code.
-
-   The main DLD specification shall primarily be located in a C file
-   in the component being designed.  The main DLD specification can be
-   quite large and is probably not of interest to a consumer of the
-   component.
-
-   It is <i>required</i> that the <b>Functional Specification</b> and
-   the <b>Detailed Functional Specification</b> be located in the
-   primary header file - this is the header file with the declaration
-   of the external interfaces that consumers of the component's API
-   would include.  In case of stand alone components, an appropriate
-   alternative header file should be chosen.
-
-   <b>Structure of the DLD</b><br>
-   The DLD specification is <b>required</b> to be sectioned in the
-   specific manner illustrated by the <tt>dld-sample.c</tt> and
-   <tt>dld-sample.h</tt> files.  This is similar in structure and
-   purpose to the sectioning found in a High Level Design.
-
-   Not all sections may be applicable to every design, but sections
-   declared to be mandatory may not be omitted.  If a mandatory
-   section does not apply, it should clearly be marked as
-   non-applicable, along with an explanation.  Additional sections or
-   sub-sectioning may be added as required.
-
-   It is probably desirable to split the Detailed Functional
-   Specifications into separate header files for each sub-module of
-   the component.  This example illustrates a component with a single
-   module.
-
-   <b>Formatting language</b><br>
-   Doxygen is the formatting tool of choice.  The Doxygen @@page
-   format is used to define a separate top-level browsable element
-   that contains the body of the DLD. The @@section, @@subsection and
-   @@subsubsection formatting commands are used to provide internal
-   structure.  The page title will be visible in the <b>Related
-   Pages</b> tab in the main browser window, as well as displayed as a
-   top-level element in the explorer side-bar.
-
-   The Functional Specification is to be located in the primary header
-   file of the component in a Doxygen @@page that is referenced as a
-   @@subpage from the table of contents of the main DLD specification.
-   This sub-page shows up as leaf element of the DLD in the explorer
-   side-bar.
-
-   Detailed functional specifications follow the Functional
-   Specification, using Doxygen @@defgroup commands for each component
-   module.
-
-   <hr>
-   @section DLD-def Definitions
-   <i>Mandatory.
-   The DLD shall provide definitions of the terms and concepts
-   introduced by the design, as well as the relevant terms used by the
-   specification but described elsewhere.  References to the
-   C2 Glossary are permitted and encouraged.  Agreed upon terminology
-   should be incorporated in the glossary.</i>
-
-   Previously defined terms:
-   - <b>Logical Specification</b> This explains how the component works.
-   - <b>Functional Specification</b> This is explains how to use the component.
-
-   New terms:
-   - <b>Detailed Functional Specification</b> This provides
-     documentation of ll the data structures and interfaces (internal
-     and external).
-   - <b>State model</b> This explains the life cycle of component data
-     structures.
-   - <b>Concurrency and threading model</b> This explains how the the
-     component works in a multi-threaded environment.
-
-   <hr>
-   @section DLD-req Requirements
-   <i>Mandatory.
-   The DLD shall state the requirements that it attempts to meet.</i>
-
-   They should be expressed in a list, thusly:
-   - <b>R.DLD.Structured</b> The DLD shall be decomposed into a standard
-   set of section.  Sub-sections may be used to further decompose the
-   material of a section into logically disjoint units.
-   - <b>R.DLD.What</b> The DLD shall describe the externally visible
-   data structures and interfaces of the component through a
-   functional specification section.
-   - <b>R.DLD.How</b> The DLD shall explain its inner algorithms through
-   a logical specification section.
-   - <b>R.DLD.Maintainable</b> The DLD shall be easily maintainable during
-   the lifetime of the code.
-
-   <hr>
-   @section DLD-depends Dependencies
-   <i>Mandatory. Identify other components on which this specification
-   depends.</i>
-
-   The DLD specification style guide depends on the HLD and AR
-   specifications as they identify requirements, use cases, <i>\&c.</i>.
-
-   <hr>
-   @section DLD-highlights Design Highlights
-   <i>Mandatory. This section briefly summarizes the key design
-   decisions that are important for understanding the functional and
-   logical specifications, and enumerates topics that need special
-   attention.</i>
-
-   - The DLD specification requires formal sectioning to address specific
-   aspects of the design.
-   - The DLD is with the code, and the specification is designed to be
-   viewed either as text or through Doxygen.
-   - This document can be used as a template.
-
-   <hr>
-   @section DLD-lspec Logical Specification
-   <i>Mandatory.  This section describes the internal design of the component,
-   explaining how the functional specification is met.  Sub-components and
-   diagrams of their interaction should go into this section.  The section has
-   mandatory subsections created using the Doxygen @@subsection command.  The
-   designer should feel free to use additional sub-sectioning if needed, though
-   if there is significant additional sub-sectioning, provide a table of
-   contents here.</i>
-
-   - @ref DLD-lspec-comps
-   - @ref DLD-lspec-sc1
-      - @ref DLD-lspec-ds1
-      - @ref DLD-lspec-sub1
-      - @ref DLDDFSInternal  <!-- Note link -->
-   - @ref DLD-lspec-state
-   - @ref DLD-lspec-thread
-   - @ref DLD-lspec-numa
-
-
-   @subsection DLD-lspec-comps Component Overview
-   <i>Mandatory.
-   This section describes the internal logical decomposition.
-   A diagram of the interaction between internal components and
-   between external consumers and the internal components is useful.</i>
-
-   Doxygen is limited in its internal support for diagrams. It has built in
-   support for @c dot and @c mscgen, and examples of both are provided in this
-   template.  Please remember that every diagram <i>must</i> be accompanied by
-   an explanation.
-
-   The following @@dot diagram shows the internal components of the Network
-   layer, and also illustrates its primary consumer, the RPC layer.
-   @dot
-   digraph {
-     node [style=box];
-     label = "Network Layer Components and Interactions";
-     subgraph cluster_rpc {
-         label = "RPC Layer";
-         rpcC [label="Connectivity"];
-	 rpcO [label="Output"];
-     }
-     subgraph cluster_net {
-         label = "Network Layer";
-	 netM [label="Messaging"];
-	 netT [label="Transport"];
-	 netL [label="Legacy RPC emulation", style="filled"];
-	 netM -> netT;
-	 netL -> netM;
-     }
-     rpcC -> netM;
-     rpcO -> netM;
-   }
-   @enddot
-
-   The @@msc command is used to invoke @c mscgen, which creates sequence
-   diagrams. For example:
-   @msc
-   a,b,c;
-
-   a->b [ label = "ab()" ] ;
-   b->c [ label = "bc(TRUE)"];
-   c=>c [ label = "process(1)" ];
-   c=>c [ label = "process(2)" ];
-   ...;
-   c=>c [ label = "process(n)" ];
-   c=>c [ label = "process(END)" ];
-   a<<=c [ label = "callback()"];
-   ---  [ label = "If more to run", ID="*" ];
-   a->a [ label = "next()"];
-   a->c [ label = "ac1()\nac2()"];
-   b<-c [ label = "cb(TRUE)"];
-   b->b [ label = "stalled(...)"];
-   a<-b [ label = "ab() = FALSE"];
-   @endmsc
-   Note that when entering commands for @c mscgen, do not include the
-   <tt>msc { ... }</tt> block delimiters.
-   You need the @c mscgen program installed on your system - it is part
-   of the Scientific Linux based DevVM.
-
-   UML and sequence diagrams often illustrate points better than any written
-   explanation.  However, you have to resort to an external tool to generate
-   the diagram, save the image in a file, and load it into your DLD.
-
-   An image is relatively easy to load provided you remember that the
-   Doxygen output is viewed from the @c doc/html directory, so all paths
-   should be relative to that frame of reference.  For example:
-   <img src="../../doc/dld-sample-uml.png">
-   I found that a PNG format image from Visio shows up with the correct
-   image size while a GIF image was wrongly sized.  Your experience may
-   be different, so please ensure that you validate the Doxygen output
-   for correct image rendering.
-
-   If an external tool, such as Visio or @c dia, is used to create an
-   image, the source of that image (e.g. the Visio <tt>.vsd</tt> or
-   the <tt>.dia</tt> file) should be checked into the source tree so
-   that future maintainers can modify the figure.  This applies to all
-   non-embedded image source files, not just Visio or @c dia.
-
-   @subsection DLD-lspec-sc1 Subcomponent design
-   <i>Such sections briefly describes the purpose and design of each
-   sub-component. Feel free to add multiple such sections, and any additional
-   sub-sectioning within.</i>
-
-   Sample non-standard sub-section to illustrate that it is possible to
-   document the design of a sub-component.  This contrived example demonstrates
-   @@subsubsections for the sub-component's data structures and subroutines.
-
-   @subsubsection DLD-lspec-ds1 Subcomponent Data Structures
-   <i>This section briefly describes the internal data structures that are
-   significant to the design of the sub-component. These should not be a part
-   of the Functional Specification.</i>
-
-   Describe <i>briefly</i> the internal data structures that are significant to
-   the design.  These should not be described in the Functional Specification
-   as they are not part of the external interface.  It is <b>not necessary</b>
-   to describe all the internal data structures here.  They should, however, be
-   documented in Detailed Functional Specifications, though separate from the
-   external interfaces.  See @ref DLDDFSInternal for example.
-
-   - dld_sample_internal
-
-   @subsubsection DLD-lspec-sub1 Subcomponent Subroutines
-   <i>This section briefly describes the interfaces of the sub-component that
-   are of significance to the design.</i>
-
-   Describe <i>briefly</i> the internal subroutines that are significant to the
-   design.  These should not be described in the Functional Specification as
-   they are not part of the external interface.  It is <b>not necessary</b> to
-   describe all the internal subroutines here.  They should, however, be
-   documented in Detailed Functional Specifications, though separate from the
-   external interfaces.  See @ref DLDDFSInternal for example.
-
-   - dld_sample_internal_invariant()
-
-   @subsection DLD-lspec-state State Specification
-   <i>Mandatory.
-   This section describes any formal state models used by the component,
-   whether externally exposed or purely internal.</i>
-
-   Diagrams are almost essential here. The @@dot tool is the easiest way to
-   create state diagrams, and is very readable in text form too.  Here, for
-   example, is a @@dot version of a figure from the "rpc/session.h" file:
-   @dot
-   digraph example {
-       size = "5,6"
-       label = "RPC Session States"
-       node [shape=record, fontname=Helvetica, fontsize=10]
-       S0 [label="", shape="plaintext", layer=""]
-       S1 [label="Uninitialized"]
-       S2 [label="Initialized"]
-       S3 [label="Connecting"]
-       S4 [label="Active"]
-       S5 [label="Terminating"]
-       S6 [label="Terminated"]
-       S7 [label="Uninitialized"]
-       S8 [label="Failed"]
-       S0 -> S1 [label="allocate"]
-       S1 -> S2 [label="c2_rpc_conn_init()"]
-       S2 -> S3 [label="c2_rpc_conn_established()"]
-       S3 -> S4 [label="c2_rpc_conn_establish_reply_received()"]
-       S4 -> S5 [label="c2_rpc_conn_terminate()"]
-       S5 -> S6 [label="c2_rpc_conn_terminate_reply_received()"]
-       S6 -> S7 [label="c2_rpc_conn_fini()"]
-       S2 -> S8 [label="failed"]
-       S3 -> S8 [label="timeout or failed"]
-       S5 -> S8 [label="timeout or failed"]
-       S8 -> S7 [label="c2_rpc_conn_fini()"]
-   }
-   @enddot
-   The @c dot program is part of the Scientific Linux DevVM.
-
-   @subsection DLD-lspec-thread Threading and Concurrency Model
-   <i>Mandatory.
-   This section describes the threading and concurrency model.
-   It describes the various asynchronous threads of operation, identifies
-   the critical sections and synchronization primitives used
-   (such as semaphores, locks, mutexes and condition variables).</i>
-
-   This section must explain all aspects of synchronization, including locking
-   order protocols, existential protection of objects by their state, etc.
-   A diagram illustrating lock scope would be very useful here.
-   For example, here is a @@dot illustration of the scope and locking order
-   of the mutexes in the Networking Layer:
-   @dot
-   digraph {
-      node [shape=plaintext];
-      subgraph cluster_m1 { // represents mutex scope
-         // sorted R-L so put mutex name last to align on the left
-         rank = same;
-	 n1_2 [label="dom_fini()"];  // procedure using mutex
-	 n1_1 [label="dom_init()"];
-         n1_0 [label="c2_net_mutex"];// mutex name
-      }
-      subgraph cluster_m2 {
-         rank = same;
-	 n2_2 [label="tm_fini()"];
-         n2_1 [label="tm_init()"];
-         n2_4 [label="buf_deregister()"];
-	 n2_3 [label="buf_register()"];
-         n2_0 [label="nd_mutex"];
-      }
-      subgraph cluster_m3 {
-         rank = same;
-	 n3_2 [label="tm_stop()"];
-         n3_1 [label="tm_start()"];
-	 n3_6 [label="ep_put()"];
-	 n3_5 [label="ep_create()"];
-	 n3_4 [label="buf_del()"];
-	 n3_3 [label="buf_add()"];
-         n3_0 [label="ntm_mutex"];
-      }
-      label="Mutex usage and locking order in the Network Layer";
-      n1_0 -> n2_0;  // locking order
-      n2_0 -> n3_0;
-   }
-   @enddot
-
-   @subsection DLD-lspec-numa NUMA optimizations
-   <i>Mandatory for components with programmatic interfaces.
-   This section describes if optimal behavior can be supported by
-   associating the utilizing thread to a single processor.</i>
-
-   Conversely, it can describe if sub-optimal behavior arises due
-   to contention for shared component resources by multiple processors.
-
-   The section is marked mandatory because it forces the designer to
-   consider these aspects of concurrency.
-
-   <hr>
-   @section DLD-conformance Conformance
-   <i>Mandatory.
-   This section cites each requirement in the @ref DLD-req section,
-   and explains briefly how the DLD meets the requirement.</i>
-
-   Note the subtle difference in that <b>I</b> tags are used instead of
-   the <b>R</b> tags of the requirements section.  The @b I of course,
-   stands for "implements":
-
-   - <b>I.DLD.Structured</b> The DLD specification provides a structural
-   breakdown along the lines of the HLD specification.  This makes it
-   easy to understand and analyze the various facets of the design.
-   - <b>I.DLD.What</b> The DLD style guide requires that a
-   DLD contain a Functional Specification section.
-   - <b>I.DLD.How</b> The DLD style guide requires that a
-   DLD contain a Logical Specification section.
-   - <b>I.DLD.Maintainable</b> The DLD style guide requires that the
-   DLD be written in the main header file of the component.
-   It can be maintained along with the code, without
-   requiring one to resort to other documents and tools.  The only
-   exception to this would be for images referenced by the DLD specification,
-   as Doxygen does not provide sufficient support for this purpose.
-
-   This section is meant as a cross check for the DLD writer to ensure
-   that all requirements have been addressed.  It is recommended that you
-   fill it in as part of the DLD review.
-
-   <hr>
-   @section DLD-ut Unit Tests
-   <i>Mandatory. This section describes the unit tests that will be designed.
-   </i>
-
-   Unit tests should be planned for all interfaces exposed by the
-   component.  Testing should not just include correctness tests, but
-   should also test failure situations.  This includes testing of
-   <i>expected</i> return error codes when presented with invalid
-   input or when encountering unexpected data or state.  Note that
-   assertions are not testable - the unit test program terminates!
-
-   Another area of focus is boundary value tests, where variable
-   values are equal to but do not exceed their maximum or minimum
-   possible values.
-
-   As a further refinement and a plug for Test Driven Development, it
-   would be nice if the designer can plan the order of development of
-   the interfaces and their corresponding unit tests.  Code inspection
-   could overlap development in such a model.
-
-   Testing should relate to specific use cases described in the HLD if
-   possible.
-
-   It is acceptable that this section be located in a separate @@subpage like
-   along the lines of the Functional Specification.  This can be deferred
-   to the UT phase where additional details on the unit tests are available.
-
-   Use the Doxygen @@test tag to identify each test.  Doxygen collects these
-   and displays them on a "Test List" page.
-
-   <hr>
-   @section DLD-st System Tests
-   <i>Mandatory.
-   This section describes the system testing done, if applicable.</i>
-
-   Testing should relate to specific use cases described in the HLD if
-   possible.
-
-   It is acceptable that this section be located in a separate @@subpage like
-   along the lines of the Functional Specification.  This can be deferred
-   to the ST phase where additional details on the system tests are available.
-
-
-   <hr>
-   @section DLD-O Analysis
-   <i>This section estimates the performance of the component, in terms of
-   resource (memory, processor, locks, messages, etc.) consumption,
-   ideally described in big-O notation.</i>
-
-   <hr>
-   @section DLD-ref References
-   <i>Mandatory. Provide references to other documents and components that
-   are cited or used in the design.
-   In particular a link to the HLD for the DLD should be provided.</i>
-
-   - <a href="https://docs.google.com/a/xyratex.com/Doc?docid=0ATg1HFjUZcaZZGNkNXg4cXpfMjQ3Z3NraDI4ZG0&hl=en_US">Detailed level design HOWTO</a>,
-   an older document on which this style guide is partially based.
-   - <a href="http://www.stack.nl/~dimitri/doxygen/manual.html">Doxygen
-   Manual</a>
-   - <a href="http://www.graphviz.org">Graphviz - Graph Visualization
-   Software</a> for documentation on the @c dot command.
-   - <a href="http://www.mcternan.me.uk/mscgen">Mscgen home page</a>
-
- */
-
-#include "doc/dld_template.h"
-
-/**
-   @defgroup DLDDFSInternal Colibri Sample Module Internals
-   @brief Detailed functional specification of the internals of the
-   sample module.
-
-   This example is part of the DLD Template and Style Guide. It illustrates
-   how to keep internal documentation separate from external documentation
-   by using multiple @@defgroup commands in different files.
-
-   Please make sure that the module cross-reference the DLD, as shown below.
-
-   @see @ref DLD and @ref DLD-lspec
-
-   @{
- */
-
-/** Structure used internally */
-struct dld_sample_internal {
-  int dsi_f1; /**< field to do blah */
-};
-
-/** Invariant for dld_sample_internal must be called holding the mutex */
-static bool dld_sample_internal_invariant(const struct dld_sample_internal *
-					  dsi)
-{
-	if (dsi->dsi-f1 == 0)
-		return false;
-	return true;
-}
-
-/**
-   @} end internal
-*/
-
-/**
-   External documentation can be continued if need be - usually it should
-   be fully documented in the header only.
-   @addtogroup DLDFS
-   @{
-*/
-
-/**
-    This is an example of bad documentation, where an external symbol is
-    not documented in the externally visible header in which it is declared.
-    This also results in Doxygen not being able to automatically reference
-    it in the Functional Specification.
-*/
-unsigned int dld_bad_example;
-
-/** @} end-of-DLDFS */
-
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 79
- *  scroll-step: 1
- *  End:
- */
diff --git a/doc/dld-template.h b/doc/dld-template.h
deleted file mode 100644
index 58da8d6..0000000
--- a/doc/dld-template.h
+++ /dev/null
@@ -1,211 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Carl Braganza <Carl_Braganza@us.xyratex.com>
- * Original creation date: 09/16/2011
- */
-
-#ifndef __COLIBRI_DLD_TEMPLATE_H__
-#define __COLIBRI_DLD_TEMPLATE_H__
-
-/**
-   @page DLD-fspec DLD Functional Specification Template
-   <i>Mandatory. This page describes the external interfaces of the
-   component. The section has mandatory sub-divisions created using the Doxygen
-   @@section command.  It is required that there be Table of Contents at the
-   top of the page that illustrates the sectioning of the page.</i>
-
-   - @ref DLD-fspec-ds
-   - @ref DLD-fspec-sub
-   - @ref DLD-fspec-cli
-   - @ref DLD-fspec-usecases
-   - @ref DLDDFS "Detailed Functional Specification" <!-- Note link -->
-
-   The Functional Specification section of the DLD shall be placed in a
-   separate Doxygen page, identified as a @@subpage of the main specification
-   document through the table of contents in the main document page.  The
-   purpose of this separation is to co-locate the Functional Specification in
-   the same source file as the Detailed Functional Specification.
-
-   A table of contents should be created for the major sections in this page,
-   as illustrated above.  It should also contain references to other
-   <b>external</b> Detailed Functional Specification sections, which even
-   though may be present in the same source file, would not be visibly linked
-   in the Doxygen output.
-
-   @section DLD-fspec-ds Data Structures
-   <i>Mandatory for programmatic interfaces.  Components with programming
-   interfaces should provide an enumeration and <i>brief</i> description of the
-   major externally visible data structures defined by this component.  No
-   details of the data structure are required here, just the salient
-   points.</i>
-
-   For example:
-<table border="0">
-<tr><td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td><td>
-   The @c dld_sample_ds1 structure tracks the density of the
-   electro-magnetic field with the following:
-@code
-struct dld_sample_ds1 {
-  ...
-  int dsd_flux_density;
-  ...
-};
-@endcode
-   The value of this field is inversely proportional to the square of the
-   number of lines of comments in the DLD.
-</td></tr></table>
-   Note the indentation above, accomplished by means of an HTML table
-   is purely for visual effect in the Doxygen output of the style guide.
-   A real DLD should not use such constructs.
-
-   Simple lists can also suffice:
-   - dld_sample_ds1
-   - dld_bad_example
-
-   The section could also describe what use it makes of data structures
-   described elsewhere.
-
-   Note that data structures are defined in the
-   @ref DLDDFS "Detailed Functional Specification"
-   so <b>do not duplicate the definitions</b>!
-   Do not describe internal data structures here either - they can be described
-   in the @ref DLD-lspec "Logical Specification" if necessary.
-
-   @section DLD-fspec-sub Subroutines
-   <i>Mandatory for programmatic interfaces.  Components with programming
-   interfaces should provide an enumeration and brief description of the
-   externally visible programming interfaces.</i>
-
-   Externally visible interfaces should be enumerated and categorized by
-   function.  <b>Do not provide details.</b> They will be fully documented in
-   the @ref DLDDFS "Detailed Functional Specification".
-   Do not describe internal interfaces - they can be described in the
-   @ref DLD-lspec "Logical Specification" if necessary.
-
-   @subsection DLD-fspec-sub-cons Constructors and Destructors
-
-   @subsection DLD-fspec-sub-acc Accessors and Invariants
-
-   @subsection DLD-fspec-sub-opi Operational Interfaces
-   - dld_sample_sub1()
-
-   @section DLD-fspec-cli Command Usage
-   <i>Mandatory for command line programs.  Components that provide programs
-   would provide a specification of the command line invocation arguments.  In
-   addition, the format of any any structured file consumed or produced by the
-   interface must be described in this section.</i>
-
-   @section DLD-fspec-usecases Recipes
-   <i>This section could briefly explain what sequence of interface calls or
-   what program invocation flags are required to solve specific usage
-   scenarios.  It would be very nice if these examples can be linked
-   back to the HLD for the component.</i>
-
-   Note the following references to the Detailed Functional Specification
-   sections at the end of these Functional Specifications, created using the
-   Doxygen @@see command:
-
-   @see @ref DLDDFS "Sample Detailed Functional Specification"
- */
-
-/**
-   @defgroup DLDDFS Colibri Sample Module
-   @brief Detailed functional specification template.
-
-   This page is part of the DLD style template.  Detailed functional
-   specifications go into a module described by the Doxygen @@defgroup command.
-   Note that you cannot use a hyphen (-) in the tag of a @@defgroup.
-
-   Module documentation may spread across multiple source files.  Make sure
-   that the @@addtogroup Doxygen command is used in the other files to merge
-   their documentation into the main group.  When doing so, it is important to
-   ensure that the material flows logically when read through Doxygen.
-
-   You are not constrained to have only one module in the design.  If multiple
-   modules are present you may use multiple @@defgroup commands to create
-   individual documentation pages for each such module, though it is good idea
-   to use separate header files for the additional modules.  In particular, it
-   is a good idea to separate the internal detailed documentation from the
-   external documentation in this header file.  Please make sure that the DLD
-   and the modules cross-reference each other, as shown below.
-
-   @see The @ref DLD "Colibri Sample DLD" its
-   @ref DLD-fspec "Functional Specification"
-   and its @ref DLD-lspec-thread
-
-   @{
-*/
-
-/**
-   Data structure to do something.
-
- */
-struct dld_sample_ds1 {
-	/** The z field */
-	int dsd_z_field;
-	/** Flux density */
-	int dsd_flux_density;
-};
-
-/* Documented elsewhere to illustrate bad documentation of an external symbol.
-   Doxygen cannot automatically reference it from elsewhere, as can be seen in
-   the Doxygen output for the reference in the Functional Specification above.
- */
-extern unsigned int dld_bad_example;
-
-/**
-   Subroutine1 opens a foo for access.
-
-   Some particulars:
-   - Proper grammar, punctuation and spelling is required
-   in all documentation.
-   This requirement is not relaxed in the detailed functional specification.
-   - Function documentation should be in the 3rd person, singular, present
-   tense, indicative mood, active voice.  For example, "creates",
-   "initializes", "finds", etc.
-   - Functional parameters should not trivialize the
-   documentation by repeating what is already clear from the function
-   prototype.  For example it would be wrong to say, <tt>"@param read_only
-   A boolean parameter."</tt>.
-   - The default return convention (0 for success and <tt>-errno</tt>
-   on failure) should not be repeated.
-   - The @@pre and @@post conditions are preferably expressed in code.
-
-   @param param1 Parameter 1 must be locked before use.
-   @param read_only This controls the modifiability of the foo object.
-   Set to @c true to prevent modification.
-   @retval return value
-   @pre Pre-condition, preferably expressed in code.
-   @post Post-condition, preferably expressed in code.
-*/
-int dld_sample_sub1(struct dld_sample_ds1 *param1, bool read_only);
-
-/**
-   @} DLDDFS end group
-*/
-
-#endif /*  __COLIBRI_DLD_TEMPLATE_H__ */
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 79
- *  scroll-step: 1
- *  End:
- */
diff --git a/doc/git-policy b/doc/git-policy
deleted file mode 100644
index d40123d..0000000
--- a/doc/git-policy
+++ /dev/null
@@ -1,444 +0,0 @@
-                        Colibri project Git policy
-
-Some parts of this document are based on the content of a similar guides,
-found in the Linux kernel's documentations:
-
-    Documentation/development-process/5.Posting
-    Documentation/development-process/7.AdvancedTopics
-    Documentation/SubmittingPatches
-
-
-BASIC PRINCIPLES
-----------------
-
- * master is always stable: it can be built without errors and pass all
-   unit tests.
-
- * All active development is done in so called "topic" (or "feature")
-   branches (see TASK LIFECYCLE).
-
- * Try to keep history simple and straight as much as possible, as long as
-   it remains reasonable and doesn't add pain into the process.
-
- * Don't overuse merges, try to avoid them whenever it's possible, use
-   'rebase' instead (see MERGE POLICY).
-
- * Don't change history which is already public (i.e. in the central
-   repository) with 'rebase' or 'commit --amend'.
-
- * Create descriptive and meaningful commit messages (see FORMAT OF COMMIT
-   MESSAGE).
-
- * Don't publish your tangled and awkward commit history, which reflects
-   the hard times you got while working on a task. Instead, use interactive
-   'rebase' to reorganize and polish your commits before pushing them into
-   central repository.
-
- * Organize commits into a logically independent and consistent pieces
-   (see ORGANIZING YOUR COMMITS)
-
-
-TASK LIFECYCLE
--------------
-
- * For each new task a branch with a corresponding name should be created
-   on top of master.
-
- * All task-related development goes in this topic branch.
-
- * When a task is completed, the topic branch is merged back into the
-   master and a "landing" tag is created for this merge-point (see LANDING
-   TAGS).
-
- * After this, a topic branch is deleted.
-
-
-LANDING TAGS
-------------
-
-Whenever a topic branch get merged into master, a "landing" tag should be
-created for this merge-point.
-
-The tag has format
-
-    landing.BRANCH                  e.g.:  landing.cunit
-
-where BRANCH is a name of the topic branch being merged into master.
-
-For example, merging branch "net_buffer_pool" into master:
-
-    $ git checkout master
-    $ git merge net_buffer_pool
-    $ git tag landing.net_buffer_pool
-    $ git push origin master landing.net_buffer_pool
-
-Don't forget to explicitly push the new "landing" tag, because tags don't
-get pushed automatically.
-
-Tagging of each merge into master allows to track the history of master
-branch easily and helps to see more clearly it's evolution.
-
-For example, to check what was committed directly into master, starting
-from a merge of "cunit" branch, one could use the following command:
-
-    $ git log --first-parent --oneline --decorate landing.cunit..master
-
-
-SPRINT TAGS
------------
-
-Additionally to the "landing" tags, a "sprint" tag is created in master
-branch at the beginning of each sprint.
-
-The tag has format
-
-    t<P>.<L>-s<S>                   e.g.:  t1.3-s16
-
-where P, L and S are decimal numbers with the following meaning:
-
-    P - a current phase of colibri development (at the moment of writing
-        this document it's still 1 ;)
-
-    L - a sub-phase, usually it's a serial number of a "colibri launch" or
-        "re-launch" in the current phase
-
-    S - a sprint number, counting from the beginning of the phase
-
-Sprint and landing tags intended to be a kind of release points. They allow
-to see which tasks were finished within a sprint.
-
-
-MERGE POLICY
-------------
-
-In brief:
-
- * Always use 'pull --rebase' instead of a simple 'pull'. This prevents
-   unnecessary merges, when you are working on master branch or share a
-   topic branch with other developers.
-
-   It's easy to create an alias for this command in ~/.gitconfig:
-
-       [alias]
-           pullrb = pull --rebase   # you can name it whatever you want
-
- * Always rebase your local changes on top of upstream branch. For
-   example, you've created a new topic branch B on top of master and make
-   several commits locally, at the same time master has been also updated
-   in central repo - in this case don't merge master into B, instead rebase
-   B on top of new master. Or another example, when you work on some branch
-   B together with other developer(s) - never merge origin/B into your
-   local branch B, instead rebase B on top of origin/B (either with 'fetch'
-   and 'rebase' or with 'pull --rebase').
-
- * Don't publish your tangled and awkward commit history, which reflects
-   the hard times you got while working on a task. Instead, use interactive
-   rebase to reorganize and polish your commits before pushing them into
-   central repository.
-
- * Don't merge in every new commit from master into your branch, do it
-   only when it's really needed, for example when there are some changes
-   which touch your files or when some API, which is used by your code, was
-   added or changed.
-
- * When you are ready to merge your changes back to master use the following
-   rules:
-
-     (a) sync your local master branch with remote master
-
-           $ git checkout master
-           $ git pull --rebase
-
-     (b) if you don't have any merges in the history of your topic branch, then
-         rebase your topic branch on top of master, otherwise skip to step (c)
-
-           $ git rebase master YOUR_BRANCH
-
-     (c) merge your branch back to master
-
-           $ git checkout master
-           $ git merge --no-ff YOUR_BRANCH
-
-         it's essential to use '--no-ff' option for 'merge', because it will
-         group your changes into a separate line of history instead of doing
-         fast-forward, in which case there would be no way to single out your
-         changes
-
-
-Rationale:
-
-The normal git workflow involves the use of a lot of branches. Each line
-of development can be separated into a separate "topic branch" and
-maintained independently. Branches in git are cheap, there is no reason to
-not make free use of them. Merge in commits into master from development
-branches when they are in complete form and ready to go - not before.
-
-Git provides some powerful tools which can allow you to rewrite your
-development history. An inconvenient commit (one which breaks bisection,
-say, or which has some other sort of obvious bug) can be fixed in place or
-made to disappear from the history entirely. A commit series can be
-rewritten as if it had been written on top of today's mainline, even though
-you have been working on it for months. Changes can be transparently
-shifted from one branch to another. And so on. Judicious use of git's
-ability to revise history can help in the creation of clean commits sets
-with fewer problems.
-
-Excessive use of this capability can lead to other problems, though, beyond
-a simple obsession for the creation of the perfect project history.
-Rewriting history will rewrite the changes contained in that history,
-turning a tested (hopefully) program tree into an untested one.  But,
-beyond that, developers cannot easily collaborate if they do not have a
-shared view of the project history; if you rewrite history which other
-developers have pulled into their repositories, you will make life much
-more difficult for those developers, forcing them to go through a painful
-process of re-merging things, which they already merged before. So a
-simple rule of thumb applies here: history which has been exported to
-others should generally be seen as immutable thereafter.
-
-So, once you push a set of changes to your publicly-available server, those
-changes should not be rewritten. Git will attempt to enforce this rule if
-you try to push changes which do not result in a fast-forward merge (i.e.
-changes which do not share the same history). It is possible to override
-this check, and there may be times when it is necessary to rewrite an
-exported tree. But such actions should be rare. This is one of the reasons
-why development should be done in private branches (which can be rewritten
-if necessary) and only moved into public branches when it's in a reasonably
-advanced state.
-
-As the mainline (or other tree upon which a set of changes is based)
-advances, it is tempting to merge with that tree to stay on the leading
-edge. For a private branch, rebasing can be an easy way to keep up with
-another tree, but rebasing is not an option once a tree is exported to the
-world. Once that happens, a full merge must be done. Merging occasionally
-makes good sense, but overly frequent merges can clutter the history
-needlessly. Suggested technique in this case is to merge infrequently, and
-generally only at specific release points. If you are nervous about
-specific changes, you can always perform test merges in a private branch.
-The git 'rerere' tool can be useful in such situations; it remembers how
-merge conflicts were resolved so that you don't have to do the same work
-twice.
-
-
-FORMAT OF COMMIT MESSAGE
-------------------------
-
-Each commit needs to have a good log message which quickly and clearly
-communicates its purpose to the rest of the world. To that end, each
-commit message will be composed of the following:
-
- - A summary line - one-line description of what the commit does. This
-   message should be enough for a reader who sees it with no other context
-   to figure out the scope of the commit; it is the line that will show up
-   in the "short form" changelogs. It will also be the only thing that
-   people may quickly see when, two or three months later, they are going
-   through perhaps thousands of commits using tools such as 'gitk' or 'git
-   log --oneline'. For these reasons, the "summary" must be no more than
-   70-75 characters. It's usually formatted with the relevant subsystem name
-   first, followed by the purpose of the commit. For example:
-
-     rpc: embed transfer machine into c2_rpcmachine structure
-     rpc/session: add c2_rpc_session_establish_sync() function
-     stob/ut: add direct-io test
-
-   But don't put 'LogD#XXX' into the summary. It just eats up precious
-   space without holding any meaningful information. Instead, use a
-   dedicated tag line for this purpose (see TAG LINES).
-
- - A blank line, followed by a detailed description of the contents of the
-   commit. This description can be as long as is required; it should say
-   what the commit does and why it was necessary.
-
- - A blank line, followed by one or more tag lines (see TAG LINES).
-
-Be as specific as possible. The WORST descriptions possible include things
-like "update module X", "bug fix for module X", or "some changes", "some
-bugs fixed", "addressing inspection comments"... and so on.
-
-If your summary description starts to get long, that's a sign that you
-probably need to split up your patch (see ORGANIZING YOUR COMMITS).
-
-For the few simple cases it's allowed to use short one-line commit
-messages, specifically:
-
-    * fix alignment
-    * fix spaces
-    * fix typos
-    * reformat comments
-
-But subsystem name is still appreciated.
-
-To that end, the summary line should describe the effects of and motivation
-for the change as well as possible, given the one-line constraint. The
-detailed description can then amplify on those topics and provide any
-needed additional information. If the commit fixes a bug, cite the commit
-which introduced the bug if possible (and please provide both the commit ID
-and the title when citing commits). If a problem is associated with
-specific log or compiler output, include that output to help others,
-searching for a solution to the same problem. If the change is meant to
-support other changes coming in later patch, say so. If internal APIs are
-changed, detail those changes and how other developers should respond. In
-general, the more you can put yourself into the shoes of everybody who will
-be reading your changelog, the better that changelog (and the Colibri
-project as a whole) will be.
-
-
-TAG LINES
----------
-
-A tag line is just a line of text of specified format at the bottom of
-commit message, separated by a blank line from the main body. Usually, each
-of these lines has the format:
-
-    tag: Full Name <email address>  optional-other-stuff
-
-But git itself doesn't impose any restrictions on this format or on type of
-tags. These are defined by agreement. The idea is that information in tag
-line can be extracted and processed by scripts and also it provides a
-standard way to specify additional information about commit.
-
-In Colibri project we define the following tags:
-
-    Reviewed-on: URL
-
-        You *should* add this tag to commit before pushing it into
-        central repository, if it was inspected or if it's going to be
-        inspected. For example:
-
-        Reviewed-on: http://reviewboard.clusterstor.com/r/558
-
-    Reviewed-by: Full Name <email address>
-
-        This tag can be used for patches, which were reviewed (or
-        discussed) in some other ways than on ReviewBoard, for example by
-        email, skype or face to face, etc. Example:
-
-        Reviewed-by: Nikita Danilov <nikita_danilov@xyratex.com>
-
-    Acked-by: Full Name <email address>
-
-        This tag can be used to indicate that the person, mentioned in the
-        tag, agrees with the change or has approved it in a certain way.
-        Example:
-
-        Acked-by: Carl Braganza <carl_braganza@xyratex.com>
-
-    Tested-by: Full Name <email address>
-
-        It indicates that patch was successfully tested by someone else
-        besides the author. For example when you ask somebody to try your
-        patch on his side. Example:
-
-        Tested-by: Dmitriy Chumak <dmitriy_chumak@xyratex.com>
-
-    References: LogD-<X.Y> # <N>
-
-        If patch fixes some bug or defect, you *should* add this tag. X and
-        Y is the current phase and sub-phase numbers (the same as for
-        SPRINT TAGS).  And N is a defect ID (number). Its allowed to
-        specify several defect IDs, separated by comas. Example:
-
-        References: LogD-1.3 # 362
-        References: LogD-1.3 # 238, 239, 241
-
-    Reported-by: Full Name <email address>
-
-        Names a person who reported a problem which is fixed by this patch.
-        Usually this tag is used in conjunction with "References" tag.
-        Example:
-
-        Reported-by: Rajesh Bhalerao <Rajesh_Bhalerao@xyratex.com>
-
-
-ORGANIZING YOUR COMMITS
------------------------
-
-Commit locally as much as you want and in any way you want, BUT when in
-comes to making your changes public (i.e. pushing into central
-repository) - organize them into series of logically independent and
-consistent commits.
-
-Splitting up commits is a bit of an art; some developers spend a long time
-figuring out how to do it in a right way. There are a few rules of thumb,
-however, which can help considerably:
-
- - The commit series you post will almost certainly not be the series of
-   changes found in your working tree. Instead, the changes you have made
-   need to be considered in their final form, then split apart in ways
-   which make sense. The developers are interested in discrete,
-   self-contained changes, not the path you took to get to those changes.
-
- - Each logically independent change should be formatted as a separate
-   commit. These changes can be small ("add a field to this structure") or
-   large (adding a significant new API, for example), but they should be
-   conceptually small and amenable to a one-line description. Each commit
-   should make a specific change which can be reviewed on its own and
-   verified to do what it says it does.
-
- - As a way of restating the guideline above: do not mix different types of
-   changes in the same commit. If a single commit fixes a critical security
-   bug, rearranges a few structures, and reformats the code, there is a
-   good chance that it will confuse and take time away from people which
-   will analyze it, while trying to fix some bug or to understand what's
-   going on.
-
- - Ideally, each commit should yield a program which builds and runs
-   properly; if your commit series is interrupted in the middle, the result
-   should still be a working program. Partial application of a commit
-   series is a common scenario when the "git bisect" tool is used to find
-   regressions; if the result is a broken program, you will make life
-   harder for developers who are engaging in the noble work of tracking
-   down problems.
-
- - Do not overdo it, though. One developer once posted a set of edits
-   to a single file as 500 separate patches - an act which did not make him
-   the most popular person on the kernel mailing list. A single patch can
-   be reasonably large as long as it still contains a single *logical*
-   change.
-
- - It can be tempting to add a whole new infrastructure with a series of
-   commits, but to leave that infrastructure unused until the final commit
-   in the series enables the whole thing. This temptation should be
-   avoided if possible; if that series adds regressions, bisection will
-   finger the last commit as the one which caused the problem, even though
-   the real bug is elsewhere. Whenever possible, a commit which adds new
-   code should make that code active immediately.
-
-For example, if your changes include both bug fixes and performance
-enhancements for a single subsystem, separate those changes into two or
-more commits. If your changes include an API update, and a new unit test
-which uses that new API, separate those into two commits.
-
-On the other hand, if you make a single change to numerous files, group
-those changes into a single commit. Thus a single logical change is
-contained within a single commit.
-
-If you do any rearrangement of code, which doesn't change the logic and
-behavior of the program, i.e. fixing spaces, formatting code blocks,
-cutting and pasting function's implementation from one place to another or
-renaming all occurrences of some structure/function - always put such
-change into a separate commit.
-
-The same applies to the bug fixes - when you fix some issue, always do it
-in a separate commit and provide a detailed description of the bug and
-explain the fix in a commit message. Even if the fix is just one line of
-code. Don't fix two bugs in the same commit. Though, all of these relates
-only to the "real" bugs, i.e. incorrect program behavior, race condition,
-crash, etc. Defects, found during code inspection, if they are not a real
-bugs, should be treated as a normal evolution of the code.
-
-Also, ensure that all commits within a given branch stick closely to the
-associated topic; a "module A fixes" branch should not be making changes to
-the code of "module B".
-
-
-RECOMMENDED RESOURCES ON GIT
-----------------------------
-
- [1] http://progit.org         -- A really good and professional guide with
-                                  lots of examples and clean nice diagrams,
-                                  highly recommended
-
- [2] http://book.git-scm.com   -- The Git Community Book
-
- [3] http://gitcasts.com       -- A series of screencasts to help learn Git
-
diff --git a/doc/magix b/doc/magix
deleted file mode 100755
index b6d4670..0000000
--- a/doc/magix
+++ /dev/null
@@ -1,10 +0,0 @@
-Magic values used to tag Colibri structures are recorded here.
-
-type or instance   field                     value            mnemonics
----------------------------------------------------------------------------
-c2_fop_type        ft_magix                  ba11ab1ea5111dae bailable asilidae
-fop_types_list     t_magic                   d15ea5e0fed1f1ce disease of edifice
-c2_fit_watch       fif_magix                 10d15edc0a1f1e1d iodised coalfield
-c2_fit_type        fit_watch::t_magic        cea5e1e55debac1e ceaseless debacle
-c2_fit_mod         fm_magix                  be111c05ec0d1c11 bellicose codicil
-c2_fit_watch       fif_mod::t_magic          5ca1ab1e5caff01d scalable scaffold
diff --git a/doc/reading-list.html b/doc/reading-list.html
deleted file mode 100644
index f99a684..0000000
--- a/doc/reading-list.html
+++ /dev/null
@@ -1,99 +0,0 @@
-<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
-<html>
-<head>
-<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
-<title>Colibri reading list</title>
-<style type="text/css">ol{margin:0;padding:0}p{margin:0}.c4{list-style-type:circle;margin:0;padding:0}.c3{padding-left:0pt;direction:ltr;margin-left:72pt}.c8{max-width:468pt;background-color:#ffffff;padding:72pt 72pt 72pt 72pt}.c6{list-style-type:square;margin:0;padding:0}.c7{padding-left:0pt;direction:ltr;margin-left:108pt}.c5{padding-left:0pt;direction:ltr;margin-left:36pt}.c2{list-style-type:disc;margin:0;padding:0}.c9{height:11pt;direction:ltr}.c0{color:#000099;text-decoration:underline}.c10{color:#1155cc;text-decoration:underline}.c1{color:inherit;text-decoration:inherit}.title{padding-top:24pt;line-height:1.15;text-align:left;color:#000000;font-size:36pt;font-family:Arial;font-weight:bold;padding-bottom:6pt}.subtitle{padding-top:18pt;line-height:1.15;text-align:left;color:#666666;font-style:italic;font-size:24pt;font-family:Georgia;padding-bottom:4pt}body{color:#000000;font-size:11pt;font-family:Arial}h1{padding-top:24pt;line-height:1.15;text-align:left;color:#000000;font-size:24pt;font-family:Arial;font-weight:bold;padding-bottom:6pt}h2{padding-top:18pt;line-height:1.15;text-align:left;color:#000000;font-size:18pt;font-family:Arial;font-weight:bold;padding-bottom:4pt}h3{padding-top:14pt;line-height:1.15;text-align:left;color:#000000;font-size:14pt;font-family:Arial;font-weight:bold;padding-bottom:4pt}h4{padding-top:12pt;line-height:1.15;text-align:left;color:#000000;font-size:12pt;font-family:Arial;font-weight:bold;padding-bottom:2pt}h5{padding-top:11pt;line-height:1.15;text-align:left;color:#000000;font-size:11pt;font-family:Arial;font-weight:bold;padding-bottom:2pt}h6{padding-top:10pt;line-height:1.15;text-align:left;color:#000000;font-size:10pt;font-family:Arial;font-weight:bold;padding-bottom:2pt}</style>
-</head>
-<body class="c8">
-<ol class="c2" start="1">
-<li class="c5"><span class="c0"><a class="c1" href="https://docs.google.com/a/xyratex.com/document/d/1_IZk8KutJIcXdbM2ARSXtyJODfYEeQBnINo8hwLLMBs/edit?hl=en_US">this document</a></span></li>
-<li class="c5"><span>containers</span></li>
-</ol>
-<ol class="c4" start="1">
-<li class="c3"><span class="c0"><a class="c1" href="https://docs.google.com/a/xyratex.com/Doc?docid=0ATg1HFjUZcaZZGNkNXg4cXpfMjAza3NxcTJkZG0&amp;hl=en_US">containers 1-pager</a></span></li>
-<li class="c3"><span class="c0"><a class="c1" href="https://docs.google.com/a/xyratex.com/Doc?docid=0ATg1HFjUZcaZZGNkNXg4cXpfMjI3Y2RmaHdmaHE&amp;hl=en_US">Colibri data organization</a></span></li>
-</ol>
-<ol class="c2" start="3">
-<li class="c5"><span class="c0"><a class="c1" href="https://docs.google.com/a/xyratex.com/document/d/1eM8l6p3Vv9nI3vewleK_00ebtYlFfkdKjYSSrof_uDI/edit?hl=en_US">Colibri architecture 2-pager</a></span></li>
-<li class="c5">
-<span class="c10"><a class="c1" href="https://docs.google.com/a/xyratex.com/viewer?a=v&amp;pid=explorer&amp;chrome=true&amp;srcid=0Bzg1HFjUZcaZMTFkNzM2ZDEtOGIxOS00NGFhLWFiNGQtYzAzNmFhYjQwMWIy">Summary of C2 architecture</a></span><span>&nbsp;(by Peter Braam, Jul 2009)</span>
-</li>
-</ol>
-<ol class="c4" start="1"><li class="c3"><span>Note: H3S there treat as C2, DFD as Trinity... a bit outdated but still actual</span></li></ol>
-<ol class="c2" start="5">
-<li class="c5"><span class="c0"><a class="c1" href="https://docs.google.com/a/xyratex.com/Doc?docid=0ATg1HFjUZcaZZGNkNXg4cXpfMjUzeHFnbjJmajY">C2 Architecture Documentation</a></span></li>
-<li class="c5"><span class="c0"><a class="c1" href="https://docs.google.com/a/xyratex.com/document/d/13n9ddvMX77xEaLsJGbYDmNkyuJx3J39HBNupifulAXo/edit?hl=en_GB">FAQ</a></span></li>
-<li class="c5"><span class="c0"><a class="c1" href="https://docs.google.com/a/xyratex.com/spreadsheet/ccc?key=0Ajg1HFjUZcaZdEpJd0tmM3MzVy1lMG41WWxjb0t4QkE">Glossary</a></span></li>
-<li class="c5"><span>resource management</span></li>
-</ol>
-<ol class="c4" start="1">
-<li class="c3"><span class="c0"><a class="c1" href="https://docs.google.com/a/xyratex.com/document/d/13TwNcEADe-tS96RvHMWwIvfwF0z0MXBx5QOqnZLGkq4/edit?hl=en#">1-pager</a></span></li>
-<li class="c3"><span class="c0"><a class="c1" href="https://docs.google.com/a/xyratex.com/Doc?docid=0AQaCw6YRYSVSZGZmMzV6NzJfN2NiNXM1dHF3&amp;hl=en">High level design of resource management interfaces</a></span></li>
-</ol>
-<ol class="c2" start="9"><li class="c5"><span>dtm</span></li></ol>
-<ol class="c4" start="1">
-<li class="c3"><span class="c0"><a class="c1" href="https://docs.google.com/a/xyratex.com/document/d/1HovgaO3WT3kW4sWjz1RUz09oQzDoQzcA47Ul8Mh0pjQ/edit?hl=en#">1-pager</a></span></li>
-<li class="c3"><span class="c0"><a class="c1" href="https://docs.google.com/a/xyratex.com/Doc?docid=0ATg1HFjUZcaZZGNkNXg4cXpfMjA0Z2Nqc3pwZ2g&amp;hl=en_US">overview</a></span></li>
-<li class="c3"><span class="c0"><a class="c1" href="https://docs.google.com/a/xyratex.com/View?docid=dff35z72_0fhfmt6dr">High level design of version numbers</a></span></li>
-<li class="c3"><span class="c0"><a class="c1" href="http://publications.csail.mit.edu/lcs/specpub.php?id=773">Naming and synchronization in a decentralized computer system</a></span></li>
-<li class="c3"><span class="c0"><a class="c1" href="http://research.microsoft.com/en-us/um/people/gray/">Jim Gray's publications</a></span></li>
-<li class="c3"><span class="c0"><a class="c1" href="http://research.microsoft.com/en-us/um/people/lamport/pubs/pubs.html">Leslie Lamport's publications</a></span></li>
-</ol>
-<ol class="c6" start="1">
-<li class="c7"><span class="c0"><a class="c1" href="http://research.microsoft.com/en-us/um/people/lamport/pubs/pubs.html#lamport-paxos">The Part-Time Parliament (Paxos)</a></span></li>
-<li class="c7"><span class="c0"><a class="c1" href="http://research.microsoft.com/en-us/um/people/lamport/pubs/pubs.html#paxos-simple">Paxos made simple</a></span></li>
-<li class="c7"><span class="c0"><a class="c1" href="http://research.microsoft.com/en-us/um/people/lamport/pubs/pubs.html#time-clocks">Time, Clocks and the Ordering of Events in a Distributed System</a></span></li>
-</ol>
-<ol class="c4" start="7">
-<li class="c3"><span class="c0"><a class="c1" href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.109.2480">Aries: A transaction recovery method supporting fine-granularity locking and partial rollbacks using write-ahead logging</a></span></li>
-<li class="c3"><span>Echo file system</span></li>
-</ol>
-<ol class="c6" start="1">
-<li class="c7"><span class="c0"><a class="c1" href="http://www.hpl.hp.com/techreports/Compaq-DEC/SRC-RR-111.html">The Echo distributed file system</a></span></li>
-<li class="c7"><span class="c0"><a class="c1" href="http://www.hpl.hp.com/techreports/Compaq-DEC/SRC-RR-112.html">Availability in the echo file system</a></span></li>
-<li class="c7"><span class="c0"><a class="c1" href="http://www.hpl.hp.com/techreports/Compaq-DEC/SRC-RR-104.html">New value logging in the Echo replicated file system</a></span></li>
-</ol>
-<ol class="c4" start="9">
-<li class="c3"><span class="c0"><a class="c1" href="http://ksuseer1.ist.psu.edu/viewdoc/summary?doi=10.1.1.106.6258">Reliable Communication in the Presence of Failures</a></span></li>
-<li class="c3"><span class="c0"><a class="c1" href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.20.4762">Implementing Fault-Tolerant Services Using the State Machine Approach: A Tutorial</a></span></li>
-<li class="c3"><span class="c0"><a class="c1" href="https://docs.google.com/a/xyratex.com/document/d/10HjxEuQStcc9AEQJZLaSuQ0IXq308f9S_slacpom2q8/edit?hl=en_US">The black art of file system recovery</a></span></li>
-<li class="c3"><span class="c0"><a class="c1" href="http://ei.cs.vt.edu/~cs5204/sp99/distributedDBMS/duckett/tpcp.html">The Two-Phase Commit Protocol</a></span></li>
-<li class="c3"><span class="c0"><a class="c1" href="https://docs.google.com/a/xyratex.com/Doc?docid=0ATg1HFjUZcaZZGNkNXg4cXpfNzhnZzl3cGdoYg&amp;hl=en_US">Paxos overview</a></span></li>
-</ol>
-<ol class="c2" start="10"><li class="c5"><span>request handler</span></li></ol>
-<ol class="c4" start="1">
-<li class="c3"><span class="c0"><a class="c1" href="https://docs.google.com/a/xyratex.com/document/d/1JzuIYRpq483hF3_5aOHtwJjGSGr9glLPFS00QreaUR0/edit?hl=en#">request handler 1-pager</a></span></li>
-<li class="c3"><span class="c0"><a class="c1" href="https://docs.google.com/a/xyratex.com/Doc?docid=0AQaCw6YRYSVSZGZmMzV6NzJfMTNkOGNjZmdnYg&amp;hl=en">High level design of fop state machine</a></span></li>
-<li class="c3"><span class="c0"><a class="c1" href="https://docs.google.com/a/xyratex.com/Doc?tab=edit&amp;dr=true&amp;id=dcd5x8qz_206fg47r7gf">High level design of C2 request handler</a></span></li>
-<li class="c3"><span class="c0"><a class="c1" href="https://docs.google.com/a/xyratex.com/viewer?a=v&amp;pid=explorer&amp;chrome=true&amp;srcid=0BwaCw6YRYSVSMmVlODY1ZjQtMzJkMS00ZGYwLWFiZWQtNWVhNWJmZWZlZWM2&amp;hl=en_US">Non-blocking server and locality of reference</a></span></li>
-</ol>
-<ol class="c2" start="11"><li class="c5"><span>IO</span></li></ol>
-<ol class="c4" start="1">
-<li class="c3"><span class="c0"><a class="c1" href="https://docs.google.com/a/xyratex.com/document/d/1pH9jqxmSfahTOH7tqh1rUc9WgHG0PiLrAWs2YtuGmeg/edit?hl=en#">sns 1-pager</a></span></li>
-<li class="c3"><span class="c0"><a class="c1" href="https://docs.google.com/a/xyratex.com/Doc?docid=0ATg1HFjUZcaZZGNkNXg4cXpfMTkyZjlzanBrNHQ&amp;hl=en_US">sns overview</a></span></li>
-<li class="c3"><span class="c0"><a class="c1" href="https://docs.google.com/a/xyratex.com/Doc?docid=0ATg1HFjUZcaZZGNkNXg4cXpfMTMxZmZkNTZtZjg&amp;hl=en">High level design of a parity de-clustering algorithm</a></span></li>
-</ol>
-<ol class="c2" start="12">
-<li class="c5"><span class="c0"><a class="c1" href="https://docs.google.com/a/xyratex.com/Doc?docid=0ATg1HFjUZcaZZGNkNXg4cXpfMjAxbjVtZjlnZmI&amp;hl=en_US">On layouts</a></span></li>
-<li class="c5"><span>mdstore</span></li>
-</ol>
-<ol class="c4" start="1"><li class="c3"><span class="c0"><a class="c1" href="http://docs.oracle.com/cd/E17076_02/html/index.html">Oracle Berkeley DB 11g Release 2</a></span></li></ol>
-<ol class="c2" start="14"><li class="c5"><span>rpc</span></li></ol>
-<ol class="c4" start="1"><li class="c3"><span class="c0"><a class="c1" href="https://docs.google.com/a/xyratex.com/document/d/1F1dP_uXNztb7m0mU6n6VPr3IlLFWbAoQTWy_mM3XGC0/edit?hl=en_US">AR of rpc layer</a></span></li></ol>
-<ol class="c2" start="15"><li class="c5"><span>network</span></li></ol>
-<ol class="c4" start="1">
-<li class="c3"><span class="c0"><a class="c1" href="http://wiki.lustre.org/lid/ulfi/ulfi_lnet.html">LNET: Lustre Networking</a></span></li>
-<li class="c3"><span class="c0"><a class="c1" href="http://wiki.lustre.org/lid/agi/agi_lnet.html">Lustre Networking</a></span></li>
-<li class="c3"><span class="c0"><a class="c1" href="https://portals4.googlecode.com/files/portals40.pdf">The Portals 4.0.2 Message Passing Interface</a></span></li>
-</ol>
-<ol class="c2" start="16">
-<li class="c5"><span class="c0"><a class="c1" href="https://docs.google.com/a/xyratex.com/Doc?docid=0ATg1HFjUZcaZZGNkNXg4cXpfMTg0Y2tybWttZGo&amp;hl=en_US">addb 1-pager</a></span></li>
-<li class="c5"><span>other</span></li>
-</ol>
-<ol class="c4" start="1"><li class="c3"><span class="c0"><a class="c1" href="http://tools.ietf.org/html/rfc5661">Network File System (NFS) Version 4 Minor Version 1 Protocol</a></span></li></ol>
-<p class="c9"><span></span></p>
-<p class="c9"><span></span></p>
-<p class="c9"><span></span></p>
-</body>
-</html>
diff --git a/doc/source-structure b/doc/source-structure
index 5e56ccc..e0669fe 100644
--- a/doc/source-structure
+++ b/doc/source-structure
@@ -41,8 +41,7 @@ first. All libraries needed by the current configuration are linked
 together into core/colibri/libcolibri.la. Then binaries, including
 unit tests are built and linked against libcolibri.
 
-Kernel code is built by using Linux kernel build. The modules for colibri
-components are generated in build_kernel_modules directory
+Kernel code is built by using Linux kernel build.
 
 Recipes (for user space code)
 =============================
@@ -58,7 +57,7 @@ commit your changes.
 How headers should be included in C sources?
 --------------------------------------------
 
-First, your .c files should typically start with
+First, your .c files should typically start with 
 
 #ifdef HAVE_CONFIG_H
 #  include <config.h>
@@ -112,7 +111,7 @@ noinst_PROGRAMS    = baz
 baz_SOURCES        = baz.c baz.h ...
 baz_LDADD          = $(top_builddir)/colibri/libcolibri.la
 
-If necessary also add
+If necessary also add 
 
 baz_LDFLAGS   = -pthread ...
 
@@ -206,7 +205,7 @@ In core/utils/ut_main.c add
 
 extern const struct c2_test_suite foo_ut;
 
-declaration and
+declaration and 
 
 	c2_ut_add(&foo_ut);
 
@@ -242,7 +241,7 @@ How to add a new unit benchmark?
 Unit benchmarks for a component is a collection of micro-benchmarks
 measuring performance of common code-paths at the function level.
 
-It is clear that unit benchmarks are somewhat similar to unit
+It is cleat that unit benchmarks are somewhat similar to unit
 tests. Indeed, they usually happen to share a lot of code. As a
 result, unit benchmark code is typically kept in the same
 core/foo/ut/foo.c code as unit tests for the same component. See
@@ -254,28 +253,7 @@ process directory (except for possibly in its sub-directories).
 How to add a new kernel module?
 -------------------------------
 
-A new module can be added to Colibri in two ways,
-  1) functionality built into kcolibri.ko
-  2) Module for stand-alone UT's
-
-1) In colibri all the functionality for kernel side is implemented into
-a single kernel module called kcolibri.ko
-So to add your new kernel source(s) for core/module to kcolibri,
-create core/module/ directory
-
-Add the following lines into build_kernel_modules/Makefile.in:
-In macro dirs:
-add source dir "module"
-
-then the sources for the module are listed as
-module_SOURCES := foo.c bar.c baz.c
-module_HEADERS := foo.h bar.h baz.h
-
-create these source and header files in core/module directory
-
-2) If you want to build the module as separate stand-alone UT named
-core/module, create
-
+To build a new kernel module core/module create
 core/module/linux_kernel directory and add
 core/module/linux_kernel/Makefile.in into:
 
@@ -302,8 +280,8 @@ Add the following lines into configure.ac:
 In macro AC_CONFIG_FILES:
 add source "core/module/linux_kernel/Makefile".
 
-add following lines into build_kernel_modules/Makefile.in:
-In macro testdirs:
-add source dir "module/linux_kernel"
+Add the following lines into build_kernel_modules/Makefile.in:
+In macro subdirs:
+add source dir "../module/linux_kernel/".
 
 Note: build system should be reconfigured after affected changes.
diff --git a/doc/test-coverage b/doc/test-coverage
deleted file mode 100644
index 7922611..0000000
--- a/doc/test-coverage
+++ /dev/null
@@ -1,145 +0,0 @@
-* Collecting test coverage data
-================================
-- Make sure lcov is installed.
-
-  [root@xyralab_02 core]# rpm -qa | grep lcov
-  lcov-1.9-1
-
-- Edit /usr/bin/geninfo perl script to comment following line.
-  push(@gcov_options, "-a") if ($gcov_caps->{'all-blocks'});
-
-  Commenting the line prevents lcov from passing "-a" option to gcov.
-  Due to some bug in gcc, gcov with -a option hangs for some .gcda files.
-
-* Collecting test coverage data of user-space colibri:
-======================================================
-
-[root@xyralab_02 core]# pwd
-/laptop/colibri/coverage/colibri/core
-[root@xyralab_02 core]# sh autogen.sh
-[root@xyralab_02 core]# ./configure  --with-linux=/root/kernel/cov/linux-2.6.34.7 --enable-coverage
-
-Make sure in the output of configure script, that CFLAGS has --coverage option
-and LDFLAGS has '-lgcov' option present.
-
-LIBS   :  ""
-CFLAGS :  "-Wall -Werror -D_REENTRANT -D_GNU_SOURCE -fno-strict-aliasing -I/laptop/colibri/coverage/colibri/core/../db4/build_unix -I/laptop/colibri/coverage/colibri/core/../galois -I/laptop/colibri/coverage/colibri/core/../yaml/include -I. -I/laptop/colibri/coverage/colibri/core --coverage -g -O0"
-KCFLAGS:  "-Wall -Werror -g -O0"
-LDFLAGS:  "-rdynamic -lgcov"
-
-[root@xyralab_02 core]# make
-
-When build completes, you can confirm presence of gcov hooks in colibri binaries as
-
-[root@xyralab_02 core]# nm colibri/.libs/libcolibri.so | grep gcov | head
-0000000000259c20 t __gcov_close
-000000000025ab10 t __gcov_flush
-00000000004bbda0 b __gcov_indirect_call_callee
-00000000004bc400 b __gcov_indirect_call_callee
-00000000004bc460 b __gcov_indirect_call_callee
-00000000004bc610 b __gcov_indirect_call_callee
-00000000004bc640 b __gcov_indirect_call_callee
-00000000004bc850 b __gcov_indirect_call_callee
-00000000004bca60 b __gcov_indirect_call_callee
-00000000004bdbe0 b __gcov_indirect_call_callee
-
-Run utils/ut or any other binary, that causes binaries from this build directory
-to be executed.
-
-[root@xyralab_02 core]# cd utils/
-[root@xyralab_02 utils]# ./ut
-
-This will cause .gcda file getting created for each source file.
-Here is a snippet from gcc.gnu.org online documentation
-<SNIP>
-The .gcda file is generated when a program containing object files built with
-the GCC -fprofile-arcs option is executed. A separate .gcda file is created
-for each object file compiled with this option. It contains arc transition
-counts, and some summary information.
-</SNIP>
-
-[root@xyralab_02 core]# find . -name "*.gcda" | wc -l
-161
-[root@xyralab_02 core]# cd fop/.libs/
-[root@xyralab_02 .libs]# ls
-fom.gcda  fop_base.gcda  fop_format_c.gcda  fop_format.gcda  fop.gcda           fop_iterator.gcno  libcolibri-fop.a
-fom.gcno  fop_base.gcno  fop_format_c.gcno  fop_format.gcno  fop.gcno           fop_iterator.o     libcolibri-fop.la
-fom.o     fop_base.o     fop_format_c.o     fop_format.o     fop_iterator.gcda  fop.o
-
-Run gcov_stats_genhtml.sh script from core/utils/
-
-[root@xyralab_02 utils]# pwd
-/laptop/colibri/coverage/colibri/core/utils
-[root@xyralab_02 utils]# ./gcov_stats_genhtml.sh user /laptop/colibri/coverage/colibri/core/ ~/lcov/user/
-
-The script will run lcov with correct options so that html output of lcov is
-stored in ~/lcov/user/ directory.
-
-[root@xyralab_02 utils]# ls ~/lcov/user/
-addb       capa     desim        fol        index.html         ioservice  nrs   ruby.png  stob        utils
-amber.png  cob      dtm          fop        index-sort-b.html  layout     pool  sm        udb         xcode
-app.info   colibri  emerald.png  gcov.css   index-sort-f.html  lib        reqh  snow.png  updown.png  xdr
-balloc     db       fid          glass.png  index-sort-l.html  net        rpc   sns       usr
-
-Use process_lcov.sh script from core/utils, to process index.html generated by
-lcov and generate plain text table of coverage data.
-
-[root@xyralab_02 utils]# ./process_lcov.sh ~/lcov/user/index.html
-Module line_cov% lines_hit lines_total function_cov% functions_hit functions_total branch_cov% branches_hit branches_total
-
-colibri 86.7%   13 15   100.0%  3 3     75.0%   6 8
-db      90.0%   548 609 91.2%   83 91   55.6%   188 338
-lib     83.8%   887 1058        85.2%   173 203 56.8%   362 637
-..
-lib/user_space  77.4%   448 579 85.3%   58 68   51.0%   157 308
-lib/ut  90.1%   1197 1328       66.9%   93 139  82.9%   335 404
-net     86.5%   507 586 92.7%   51 55   59.8%   266 445
-net/bulk_emulation      91.2%   1533 1681       90.9%   130 143 62.4%   640 1025
-net/bulk_emulation/st   83.2%   607 730 81.8%   27 33   57.1%   234 410
-net/bulk_emulation/ut   98.5%   1144 1161       93.3%   28 30   72.2%   26 36
-net/usunrpc     75.7%   362 478 87.8%   36 41   44.8%   112 250
-net/ut  99.1%   531 536 97.3%   36 37   68.4%   78 114
-...
-xdr     51.1%   135 264 64.7%   11 17   28.8%   36 125
-xdr/ut  47.8%   64 134  21.7%   5 23    20.6%   75 364
-[root@xyralab_02 utils]#
-
-
-* Collecting test coverage data for colibri kernel modules:
-===========================================================
-
-- Compile linux kernel with CONFIG_GCOV_KERNEL=y option.
-- You might want to set CONFIG_LOCALVERSION="-gcov", so that "-gcov"
-  will be appended to kernel version suffix e.g. 2.6.34.7-gcov
-  This will make it easy to identify kernel built with CONFIG_GCOV_KERNEL option set.
-
-- Install and boot with the vmlinuz-2.6.*.*-gcov kernel.
-[root@xyralab_02 linux_kernel]# uname -r
-2.6.34.7-gcov
-
-- Mount debugfs and clear gcov counters.
-
-[root@xyralab_02 utils]# mount -t debugfs none /sys/kernel/debug/
-[root@xyralab_02 utils]# echo 1 > /sys/kernel/debug/gcov/reset
-
-- Configure and compile colibri/core in same way as given in above section.
-  Make sure that --with-linux= argument of ./configure script, points to
-  linux kernel tree compiled with CONFIG_GCOV_KERNEL option set to y.
-
-Run core/utils/linux_kernel/ut.sh or execute code from kcolibri.ko by any
-other means.
-
-[root@xyralab_02 linux_kernel]# pwd
-/laptop/colibri/coverage/colibri/core/utils/linux_kernel
-[root@xyralab_02 linux_kernel]# ./ut.sh
-
-Run core/utils/gcov_stats_genhtml.sh to collect stats, as specified in above section.
-
-[root@xyralab_02 utils]# ./gcov_stats_genhtml.sh kernel /laptop/colibri/coverage/colibri/core/ ~/lcov/kernel
-
-[root@xyralab_02 utils]# ls ~/lcov/kernel/
-addb       build_kernel_modules  dtm          fop        index.html         ioservice  pool      snow.png    xcode
-amber.png  c2t1fs                emerald.png  galois     index-sort-b.html  layout     rpc       sns
-app1.info  cob                   fid          gcov.css   index-sort-f.html  lib        ruby.png  stob
-app.info   db                    fol          glass.png  index-sort-l.html  net        sm        updown.png
-
diff --git a/dtm/Makefile.am b/dtm/Makefile.am
index 2f7060c..a5b2176 100644
--- a/dtm/Makefile.am
+++ b/dtm/Makefile.am
@@ -1,4 +1,4 @@
-dtmdir                     = $(includedir)/colibri/dtm
+dtmdir                     = $(includedir)/dtm
 dtm_HEADERS                = dtm.h verno.h
 
 noinst_LTLIBRARIES         = libcolibri-dtm.la
diff --git a/dtm/verno.c b/dtm/verno.c
index 7d453cf..8b588dd 100644
--- a/dtm/verno.c
+++ b/dtm/verno.c
@@ -30,10 +30,9 @@
 
 int c2_verno_cmp(const struct c2_verno *vn0, const struct c2_verno *vn1)
 {
-	//C2_ASSERT(c2_verno_cmp_invariant(vn0, vn1));
+	C2_ASSERT(c2_verno_cmp_invariant(vn0, vn1));
 
-	//return c2_lsn_cmp(vn0->vn_lsn, vn1->vn_lsn);
-	return C2_3WAY(vn0->vn_vc, vn1->vn_vc);
+	return c2_lsn_cmp(vn0->vn_lsn, vn1->vn_lsn);
 }
 
 int c2_verno_is_redoable(const struct c2_verno *unit, 
@@ -42,8 +41,7 @@ int c2_verno_is_redoable(const struct c2_verno *unit,
 	int result;
 	int cmp;
 
-	// XXX don't need lsn for now
-	//C2_ASSERT(c2_verno_cmp_invariant(unit, before_update));
+	C2_ASSERT(c2_verno_cmp_invariant(unit, before_update));
 
 	cmp = c2_verno_cmp(unit, before_update);
 	if (cmp < 0)
@@ -61,8 +59,7 @@ int c2_verno_is_undoable(const struct c2_verno *unit,
 	int result;
 	int cmp;
 
-	// XXX don't require lsn for now
-	//C2_ASSERT(c2_verno_cmp_invariant(unit, before_update));
+	C2_ASSERT(c2_verno_cmp_invariant(unit, before_update));
 
 	cmp = c2_verno_cmp(unit, before_update);
 	if (cmp <= 0)
@@ -73,7 +70,8 @@ int c2_verno_is_undoable(const struct c2_verno *unit,
 		result = before_update->vn_vc + 1 == unit->vn_vc ? 0 : -EAGAIN;
 	return result;
 }
-int c2_verno_cmp_invariant(const struct c2_verno *vn0,
+
+int c2_verno_cmp_invariant(const struct c2_verno *vn0, 
 			   const struct c2_verno *vn1)
 {
 	return c2_lsn_cmp(vn0->vn_lsn, vn1->vn_lsn) ==
diff --git a/fid/Makefile.am b/fid/Makefile.am
index 68f409f..badd077 100644
--- a/fid/Makefile.am
+++ b/fid/Makefile.am
@@ -1,4 +1,4 @@
-fiddir                     = $(includedir)/colibri/fid
+fiddir                     = $(includedir)/fid
 fid_HEADERS                = fid.h
 
 noinst_LTLIBRARIES         = libcolibri-fid.la
diff --git a/fid/fid.c b/fid/fid.c
index eeea910..5c06c98 100644
--- a/fid/fid.c
+++ b/fid/fid.c
@@ -18,13 +18,8 @@
  * Original creation date: 09/09/2010
  */
 
-#ifdef __KERNEL__
-#include <linux/string.h>  /* memcmp */
-#else
-#include <string.h>
-#endif
+#include <string.h>      /* memcmp */
 
-#include "lib/cdefs.h"         /* C2_EXPORTED */
 #include "fid/fid.h"
 
 /**
@@ -69,7 +64,7 @@ int c2_fid_cmp(const struct c2_fid *fid0, const struct c2_fid *fid1)
 
 /** @} end of fid group */
 
-/*
+/* 
  *  Local variables:
  *  c-indentation-style: "K&R"
  *  c-basic-offset: 8
diff --git a/fol/Makefile.am b/fol/Makefile.am
index 130674b..cf16d96 100644
--- a/fol/Makefile.am
+++ b/fol/Makefile.am
@@ -1,4 +1,4 @@
-foldir                     = $(includedir)/colibri/fol
+foldir                     = $(includedir)/fol
 fol_HEADERS                = fol.h lsn.h
 
 noinst_LTLIBRARIES         = libcolibri-fol.la
diff --git a/fol/fol.c b/fol/fol.c
index 3bfbe9a..9979a0f 100644
--- a/fol/fol.c
+++ b/fol/fol.c
@@ -24,7 +24,7 @@
 #include "lib/errno.h"
 #include "lib/misc.h"          /* C2_SET0 */
 #include "lib/cdefs.h"         /* C2_EXPORTED */
-#include "rpc/rpc_opcodes.h"
+
 #include "fol/fol.h"
 
 /**
@@ -53,10 +53,12 @@
 
   @{
  */
+
 bool c2_lsn_is_valid(c2_lsn_t lsn)
 {
 	return lsn > C2_LSN_RESERVED_NR;
 }
+C2_EXPORTED(c2_lsn_is_valid);
 
 int c2_lsn_cmp(c2_lsn_t lsn0, c2_lsn_t lsn1)
 {
@@ -65,6 +67,7 @@ int c2_lsn_cmp(c2_lsn_t lsn0, c2_lsn_t lsn1)
 
 	return C2_3WAY(lsn0, lsn1);
 }
+C2_EXPORTED(c2_lsn_cmp);
 
 c2_lsn_t lsn_inc(c2_lsn_t lsn)
 {
@@ -233,7 +236,7 @@ static const struct c2_fol_rec_type_ops anchor_ops = {
  */
 static const struct c2_fol_rec_type anchor_type = {
 	.rt_name   = "anchor",
-	.rt_opcode = C2_FOL_ANCHOR_TYPE_OPCODE,
+	.rt_opcode = 4,
 	.rt_ops    = &anchor_ops
 };
 
@@ -280,11 +283,13 @@ int c2_fol_init(struct c2_fol *fol, struct c2_dbenv *env)
 	C2_POST(ergo(result == 0, c2_lsn_is_valid(fol->f_lsn)));
 	return result;
 }
+C2_EXPORTED(c2_fol_init);
 
 void c2_fol_fini(struct c2_fol *fol)
 {
 	c2_table_fini(&fol->f_table);
 }
+C2_EXPORTED(c2_fol_fini);
 
 c2_lsn_t c2_fol_lsn_allocate(struct c2_fol *fol)
 {
@@ -301,6 +306,7 @@ c2_lsn_t c2_fol_lsn_allocate(struct c2_fol *fol)
 	C2_POST(c2_lsn_is_valid(lsn));
 	return lsn;
 }
+C2_EXPORTED(c2_fol_lsn_allocate);
 
 int c2_fol_rec_pack(struct c2_fol_rec_desc *desc, struct c2_buf *out)
 {
@@ -332,6 +338,7 @@ int c2_fol_rec_pack(struct c2_fol_rec_desc *desc, struct c2_buf *out)
 		result = -ENOMEM;
 	return result;
 }
+C2_EXPORTED(c2_fol_rec_pack);
 
 int c2_fol_add(struct c2_fol *fol, struct c2_db_tx *tx,
 	       struct c2_fol_rec_desc *rec)
@@ -348,6 +355,7 @@ int c2_fol_add(struct c2_fol *fol, struct c2_db_tx *tx,
 	}
 	return result;
 }
+C2_EXPORTED(c2_fol_add);
 
 int c2_fol_add_buf(struct c2_fol *fol, struct c2_db_tx *tx,
 		   struct c2_fol_rec_desc *drec, struct c2_buf *buf)
@@ -361,11 +369,13 @@ int c2_fol_add_buf(struct c2_fol *fol, struct c2_db_tx *tx,
 			 buf->b_addr, buf->b_nob);
 	return c2_table_insert(tx, &pair);
 }
+C2_EXPORTED(c2_fol_add_buf);
 
 int c2_fol_force(struct c2_fol *fol, c2_lsn_t upto)
 {
 	return c2_dbenv_sync(fol->f_table.t_env);
 }
+C2_EXPORTED(c2_fol_force);
 
 bool c2_fol_rec_invariant(const struct c2_fol_rec_desc *drec)
 {
@@ -412,6 +422,7 @@ bool c2_fol_rec_invariant(const struct c2_fol_rec_desc *drec)
 #endif
 	return true;
 }
+C2_EXPORTED(c2_fol_rec_invariant);
 
 int c2_fol_rec_lookup(struct c2_fol *fol, struct c2_db_tx *tx, c2_lsn_t lsn,
 		      struct c2_fol_rec *out)
@@ -440,6 +451,7 @@ int c2_fol_rec_lookup(struct c2_fol *fol, struct c2_db_tx *tx, c2_lsn_t lsn,
 	C2_POST(ergo(result == 0, c2_fol_rec_invariant(&out->fr_desc)));
 	return result;
 }
+C2_EXPORTED(c2_fol_rec_lookup);
 
 void c2_fol_rec_fini(struct c2_fol_rec *rec)
 {
@@ -450,6 +462,7 @@ void c2_fol_rec_fini(struct c2_fol_rec *rec)
 		rtype->rt_ops->rto_fini(&rec->fr_desc);
 	rec_fini(rec);
 }
+C2_EXPORTED(c2_fol_rec_fini);
 
 /*
  * FOL record type code.
@@ -469,12 +482,14 @@ int c2_fols_init(void)
 	c2_mutex_init(&rtypes_lock);
 	return c2_fol_rec_type_register(&anchor_type);
 }
+C2_EXPORTED(c2_fols_init);
 
 void c2_fols_fini(void)
 {
 	c2_fol_rec_type_unregister(&anchor_type);
 	c2_mutex_fini(&rtypes_lock);
 }
+C2_EXPORTED(c2_fols_fini);
 
 int c2_fol_rec_type_register(const struct c2_fol_rec_type *rt)
 {
@@ -492,6 +507,7 @@ int c2_fol_rec_type_register(const struct c2_fol_rec_type *rt)
 	c2_mutex_unlock(&rtypes_lock);
 	return result;
 }
+C2_EXPORTED(c2_fol_rec_type_register);
 
 void c2_fol_rec_type_unregister(const struct c2_fol_rec_type *rt)
 {
@@ -503,12 +519,14 @@ void c2_fol_rec_type_unregister(const struct c2_fol_rec_type *rt)
 	rtypes[rt->rt_opcode] = NULL;
 	c2_mutex_unlock(&rtypes_lock);
 }
+C2_EXPORTED(c2_fol_rec_type_unregister);
 
 const struct c2_fol_rec_type *c2_fol_rec_type_lookup(uint32_t opcode)
 {
 	C2_PRE(IS_IN_ARRAY(opcode, rtypes));
 	return rtypes[opcode];
 }
+C2_EXPORTED(c2_fol_rec_type_lookup);
 
 /** @} end of fol group */
 
diff --git a/fol/fol.h b/fol/fol.h
index 95cc66d..c551ac0 100644
--- a/fol/fol.h
+++ b/fol/fol.h
@@ -21,6 +21,8 @@
 #ifndef __COLIBRI_FOL_FOL_H__
 #define __COLIBRI_FOL_FOL_H__
 
+#ifndef __KERNEL__
+
 /**
    @defgroup fol File operations log
 
@@ -440,6 +442,16 @@ void c2_fols_fini(void);
 
 /** @} end of fol group */
 
+#else  /* !__KERNEL__ */
+
+struct c2_fol_rec_type {
+};
+
+struct c2_fol_rec_type_ops {
+};
+
+#endif /* !__KERNEL__ */
+
 /* __COLIBRI_FOL_FOL_H__ */
 #endif
 
diff --git a/fol/lsn.h b/fol/lsn.h
index 888c407..580ad29 100644
--- a/fol/lsn.h
+++ b/fol/lsn.h
@@ -55,11 +55,8 @@ enum {
 	/** Non-existent lsn. This is used, for example, as a prevlsn, when
 	    there is no previous operation on the object. */
 	C2_LSN_NONE,
-	/** LSN of a special dummy item always present in
-	    c2_rpc_slot::sl_item_list. */
-	C2_LSN_DUMMY_ITEM,
 	C2_LSN_RESERVED_NR,
-	/**
+	/** 
 	    LSN of a special "anchor" record always present in the fol.
 	 */
 	C2_LSN_ANCHOR = C2_LSN_RESERVED_NR + 1
diff --git a/fol/ut/fol.c b/fol/ut/fol.c
index 4696376..965dd9b 100644
--- a/fol/ut/fol.c
+++ b/fol/ut/fol.c
@@ -24,7 +24,6 @@
 #include "lib/memory.h"
 #include "lib/misc.h"              /* C2_SET0 */
 #include "fol/fol.h"
-#include "rpc/rpc_opcodes.h"
 
 static const char db_name[] = "ut-fol";
 
@@ -86,7 +85,7 @@ static const struct c2_fol_rec_type_ops ut_fol_ops = {
 
 static const struct c2_fol_rec_type ut_fol_type = {
 	.rt_name   = "ut-fol-rec",
-	.rt_opcode = C2_FOL_UT_OPCODE,
+	.rt_opcode = 5,
 	.rt_ops    = &ut_fol_ops
 };
 
diff --git a/fop/Makefile.am b/fop/Makefile.am
index b827b84..f02c934 100644
--- a/fop/Makefile.am
+++ b/fop/Makefile.am
@@ -1,15 +1,20 @@
-fopdir                        = $(includedir)/colibri/fop
-noinst_LTLIBRARIES            = libcolibri-fop.la
+fopdir                        = $(includedir)/fop
+noinst_LTLIBRARIES            = libc2rt.la libcolibri-fop.la
 
-fop_HEADERS                   = fop.h fop_base.h fom.h fop_format.h fop_iterator.h \
-                                fop_user.h fop_format_def.h fop_item_type.h
+fop_HEADERS                   = fop.h fom.h fop_format.h fop_user.h fop_format_def.h
 
-fop_SOURCES                   = fop.c fop.h fom.c fom.h fop_format.c \
-				fop_format.h fop_item_type.c fop_item_type.h \
-				fop_user.h fop_format_def.h fop_format_c.c \
-                                fop_iterator.h fop_iterator.c fop_base.c fop_base.h
+fop_SOURCES                   = fop.c fop.h fom.h fop_format.c fop_format.h \
+                                fop_user.h fop_format_def.h fop_format_c.c \
+                                fop_iterator.h fop_iterator.c
 
 libcolibri_fop_la_SOURCES     = $(fop_SOURCES)
 
+libc2rt_la_SOURCES            = $(fop_SOURCES)
+libc2rt_la_LIBADD             = $(top_builddir)/addb/addb_pseudo/libcolibri-addb-pseudo.la \
+                                $(top_builddir)/fol/libcolibri-fol.la \
+                                $(top_builddir)/db/libcolibri-db.la \
+                                $(top_builddir)/fid/libcolibri-fid.la \
+                                $(top_builddir)/lib/libc2.la
+
 INCLUDES                      = -I. -I$(top_srcdir) -I$(top_srcdir)/include
-EXTRA_DIST                    = fop2c.in linux_kernel/fop_kernel.h
+EXTRA_DIST                    = fop2c.in
diff --git a/fop/fom.c b/fop/fom.c
deleted file mode 100644
index cccf63e..0000000
--- a/fop/fom.c
+++ /dev/null
@@ -1,769 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Mandar Sawant <Mandar_Sawant@xyratex.com>
- * Original creation date: 05/04/2011
- */
-
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif
-
-#include "lib/misc.h"
-#include "lib/errno.h"
-#include "lib/assert.h"
-#include "lib/memory.h"
-#include "lib/processor.h"
-#include "lib/time.h"
-#include "lib/timer.h"
-#include "lib/arith.h"
-
-#include "addb/addb.h"
-#include "fop/fom.h"
-#include "fop/fop.h"
-#include "reqh/reqh.h"
-
-/**
-   @addtogroup fom
-   @{
- */
-
-enum locality_ht_wait {
-	LOC_HT_WAIT = 1
-};
-
-enum {
-        MIN_CPU_NR = 1
-};
-
-/**
- * Fom addb event location object
- */
-const struct c2_addb_loc c2_fom_addb_loc = {
-	.al_name = "fom"
-};
-
-/**
- * Fom addb context state.
- */
-const struct c2_addb_ctx_type c2_fom_addb_ctx_type = {
-	.act_name = "fom"
-};
-
-bool fom_wait_time_is_out(const struct c2_fom_domain *dom, const struct c2_fom *fom);
-
-#define FOM_ADDB_ADD(fom, name, rc)  \
-C2_ADDB_ADD(&(fom)->fo_fop->f_addb, &c2_fom_addb_loc, c2_addb_func_fail, (name), (rc))
-
-/**
- * Fom domain operations.
- * @todo Support fom timeout functionality.
- */
-static struct c2_fom_domain_ops c2_fom_dom_ops = {
-	.fdo_time_is_out = fom_wait_time_is_out
-};
-
-static int loc_thr_create(struct c2_fom_locality *loc);
-
-bool c2_fom_domain_invariant(const struct c2_fom_domain *dom)
-{
-	return dom != NULL && dom->fd_localities != NULL &&
-		dom->fd_ops != NULL;
-}
-
-bool c2_locality_invariant(const struct c2_fom_locality *loc)
-{
-	return	loc != NULL && loc->fl_dom != NULL &&
-		c2_mutex_is_locked(&loc->fl_lock) &&
-		c2_list_invariant(&loc->fl_runq) &&
-		c2_list_invariant(&loc->fl_wail) &&
-		c2_list_invariant(&loc->fl_threads);
-}
-
-bool c2_fom_invariant(const struct c2_fom *fom)
-{
-	struct c2_fom_locality *loc;
-
-	if ( fom == NULL || fom->fo_loc == NULL || fom->fo_type == NULL ||
-		fom->fo_ops == NULL || fom->fo_fop == NULL ||
-		!c2_list_link_invariant(&fom->fo_linkage))
-		return false;
-
-	loc = fom->fo_loc;
-	if (!c2_mutex_is_locked(&loc->fl_lock))
-		return false;
-
-	switch (fom->fo_state) {
-	case FOS_READY:
-		return c2_list_contains(&loc->fl_runq, &fom->fo_linkage);
-
-	case FOS_RUNNING:
-		return !c2_list_contains(&loc->fl_runq, &fom->fo_linkage) &&
-			!c2_list_contains(&loc->fl_wail, &fom->fo_linkage);
-
-	case FOS_WAITING:
-		return c2_list_contains(&loc->fl_wail, &fom->fo_linkage);
-
-	default:
-		return false;
-	}
-}
-
-bool fom_wait_time_is_out(const struct c2_fom_domain *dom, const struct c2_fom *fom)
-{
-	return false;
-}
-
-/**
- * Enqueues fom into locality runq list and increments
- * number of items in runq, c2_fom_locality::fl_runq_nr.
- * This function is invoked when a new fom is submitted for
- * execution or a waiting fom is re scheduled for processing.
- *
- * @pre fom->fo_state == FOS_READY
- * @param fom Ready to be executed fom, is put on locality runq
- */
-static void fom_ready(struct c2_fom *fom)
-{
-	struct c2_fom_locality *loc;
-
-	loc = fom->fo_loc;
-	C2_PRE(c2_mutex_is_locked(&loc->fl_lock));
-	C2_PRE(fom->fo_state == FOS_READY);
-
-	c2_list_add_tail(&loc->fl_runq, &fom->fo_linkage);
-	C2_CNT_INC(loc->fl_runq_nr);
-	c2_chan_signal(&loc->fl_runrun);
-}
-
-/**
- * Call back function to remove fom from the locality wait
- * list and to put it back on the locality runq list for further
- * execution.
- *
- * This function returns true, meaning that the event is "consumed", because
- * nobody is supposed to be waiting on fom->fo_clink.
- *
- * @param clink Fom linkage into waiting channel registered
- *		during a blocking operation
- *
- * @pre clink != NULL
- */
-static bool fom_cb(struct c2_clink *clink)
-{
-	struct c2_fom_locality	*loc;
-	struct c2_fom		*fom;
-
-	C2_PRE(clink != NULL);
-
-	fom = container_of(clink, struct c2_fom, fo_clink);
-	loc = fom->fo_loc;
-	c2_mutex_lock(&loc->fl_lock);
-	C2_ASSERT(c2_fom_invariant(fom));
-	C2_ASSERT(fom->fo_state == FOS_WAITING);
-	C2_ASSERT(c2_list_contains(&loc->fl_wail, &fom->fo_linkage));
-	c2_list_del(&fom->fo_linkage);
-	C2_CNT_DEC(loc->fl_wail_nr);
-	fom->fo_state = FOS_READY;
-	fom_ready(fom);
-	c2_mutex_unlock(&loc->fl_lock);
-	return true;
-}
-
-void c2_fom_block_enter(struct c2_fom *fom)
-{
-	int			rc;
-	int			i;
-	size_t			idle_threads;
-	size_t			max_idle_threads;
-	struct c2_fom_locality *loc;
-
-	loc = fom->fo_loc;
-	c2_mutex_lock(&loc->fl_lock);
-	C2_ASSERT(c2_locality_invariant(loc));
-	idle_threads = loc->fl_idle_threads_nr;
-	C2_CNT_INC(loc->fl_lo_idle_threads_nr);
-	max_idle_threads = max_check(loc->fl_lo_idle_threads_nr,
-				loc->fl_hi_idle_threads_nr);
-	c2_mutex_unlock(&loc->fl_lock);
-
-	for (i = idle_threads; i < max_idle_threads; ++i) {
-		rc = loc_thr_create(loc);
-		if (rc != 0) {
-			FOM_ADDB_ADD(fom, "c2_fom_block_enter", rc);
-			break;
-		}
-	}
-}
-
-void c2_fom_block_leave(struct c2_fom *fom)
-{
-	struct c2_fom_locality *loc;
-
-	loc = fom->fo_loc;
-	c2_mutex_lock(&loc->fl_lock);
-	C2_ASSERT(c2_locality_invariant(loc));
-	C2_CNT_DEC(loc->fl_lo_idle_threads_nr);
-	c2_mutex_unlock(&loc->fl_lock);
-}
-
-void c2_fom_queue(struct c2_fom *fom)
-{
-	struct c2_fom_locality *loc;
-
-	C2_PRE(fom->fo_phase == FOPH_INIT ||
-		fom->fo_phase == FOPH_FAILURE);
-
-	loc = fom->fo_loc;
-	c2_atomic64_inc(&loc->fl_dom->fd_foms_nr);
-	c2_mutex_lock(&loc->fl_lock);
-	fom->fo_state = FOS_READY;
-	fom_ready(fom);
-	c2_mutex_unlock(&loc->fl_lock);
-}
-
-/**
- * Puts fom on locality wait list if fom performs a blocking
- * operation, this releases the current thread to start
- * executing another fom from the runq, thus making the reqh
- * non blocking.
- * Fom state is changed to FOS_WAITING.
- * c2_fom_locality::fl_lock should be held before putting
- * fom on the locality wait list.
- * This function is invoked from fom_exec(), if the fom
- * is performing a blocking operation and c2_fom::fo_state()
- * returns FSO_WAIT.
- *
- * @pre fom->fo_state == FOS_RUNNING
- * @param fom A fom blocking on an operation that is to be
- *		put on the locality wait list
- */
-static void fom_wait(struct c2_fom *fom)
-{
-	struct c2_fom_locality *loc;
-
-	C2_PRE(fom->fo_state == FOS_RUNNING);
-
-	loc = fom->fo_loc;
-	C2_ASSERT(c2_mutex_is_locked(&loc->fl_lock));
-	fom->fo_state = FOS_WAITING;
-	c2_list_add_tail(&loc->fl_wail, &fom->fo_linkage);
-	C2_CNT_INC(loc->fl_wail_nr);
-}
-
-void c2_fom_block_at(struct c2_fom *fom, struct c2_chan *chan)
-{
-	C2_PRE(!c2_clink_is_armed(&fom->fo_clink));
-
-	c2_mutex_lock(&fom->fo_loc->fl_lock);
-	c2_clink_add(chan, &fom->fo_clink);
-}
-
-/**
- * Invokes fom state transition method, which transitions fom
- * through various phases of its execution without blocking.
- * Fom state method is executed until it returns FSO_WAIT,
- * indicating fom has either completed its execution or is
- * going to block on an operation.
- * If a fom needs to block on an operation, the state transition
- * function should register the fom's clink (by calling
- * c2_fom_block_at()) with the channel where the completion event
- * will be signalled.
- * If the state method returns FSO_WAIT, and fom has not yet
- * finished its execution, then it is put on the locality wait
- * list with c2_fom_locality::fl_lock mutex already held by
- * c2_fom_block_at().
- *
- * @see c2_fom_state_outcome
- * @see c2_fom_block_at()
- *
- * @param fom A fom under execution
- * @pre fom->fo_state == FOS_RUNNING
- */
-static void fom_exec(struct c2_fom *fom)
-{
-	int			rc;
-	struct c2_fom_locality *loc;
-
-	C2_PRE(fom->fo_state == FOS_RUNNING);
-
-	loc = fom->fo_loc;
-	/*
-	 * If fom just came out of a wait state, we need to delete the
-	 * fom->fo_clink from the waiting channel list, as it was added
-	 * into it by c2_fom_block_at().
-	 */
-	if (c2_clink_is_armed(&fom->fo_clink))
-		c2_clink_del(&fom->fo_clink);
-
-	do {
-		c2_mutex_lock(&loc->fl_lock);
-		C2_ASSERT(c2_fom_invariant(fom));
-		c2_mutex_unlock(&loc->fl_lock);
-		rc = fom->fo_ops->fo_state(fom);
-	} while (rc == FSO_AGAIN);
-
-	C2_ASSERT(rc == FSO_WAIT);
-	if (fom->fo_phase == FOPH_FINISH) {
-		fom->fo_ops->fo_fini(fom);
-	} else {
-		C2_ASSERT(c2_mutex_is_locked(&loc->fl_lock));
-		fom_wait(fom);
-		C2_ASSERT(fom->fo_state == FOS_WAITING);
-		C2_ASSERT(c2_list_contains(&loc->fl_wail, &fom->fo_linkage));
-		c2_mutex_unlock(&loc->fl_lock);
-	}
-}
-
-/**
- * Dequeues a fom from runq list of the locality.
- *
- * @param loc Locality assigned for fom execution
- *
- * @pre c2_mutex_is_locked(&loc->fl_lock)
- *
- * @retval c2_fom if succeeds
- *	else returns NULL
- */
-static struct c2_fom *fom_dequeue(struct c2_fom_locality *loc)
-{
-	struct c2_list_link	*fom_link;
-	struct c2_fom		*fom = NULL;
-
-	C2_PRE(c2_mutex_is_locked(&loc->fl_lock));
-
-	fom_link = c2_list_first(&loc->fl_runq);
-	if (fom_link != NULL) {
-		c2_list_del(fom_link);
-		fom = container_of(fom_link, struct c2_fom, fo_linkage);
-		C2_ASSERT(fom != NULL);
-		C2_CNT_DEC(loc->fl_runq_nr);
-	}
-	return fom;
-}
-
-/**
- * Locality handler thread.
- * Handler thread waits on re-scheduling channel for specific time.
- * Thread is then woken up either by fom enqueue operation in a locality runq list,
- * or if thread times out waiting on the channel.
- * When woken up, thread dequeue's a fom from the locality runq list and starts
- * executing it. If number of idle threads are higher than threshold value, they
- * are terminated.
- *
- * @see c2_fom_locality::fl_runrun
- * @see c2_fom_locality::fl_lo_idle_threads_nr
- *
- * @param th c2_fom_hthread, contains thread reference, locality reference
- *		and thread linkage in locality
- *
- * @pre th != NULL
- */
-static void loc_handler_thread(struct c2_fom_hthread *th)
-{
-	c2_time_t		delta;
-	bool			idle;
-	struct c2_clink		th_clink;
-	struct c2_fom_locality *loc;
-	struct c2_fom	       *fom;
-
-	C2_PRE(th != NULL);
-
-	loc = th->fht_locality;
-	idle = false;
-	fom = NULL;
-        c2_time_set(&delta, LOC_HT_WAIT, 0);
-	c2_clink_init(&th_clink, NULL);
-
-	c2_mutex_lock(&loc->fl_lock);
-	C2_ASSERT(c2_locality_invariant(loc));
-	c2_clink_add(&loc->fl_runrun, &th_clink);
-
-	do {
-		c2_mutex_unlock(&loc->fl_lock);
-		if (fom != NULL) {
-			C2_ASSERT(fom->fo_state == FOS_READY);
-			fom->fo_state = FOS_RUNNING;
-			fom_exec(fom);
-		}
-		c2_chan_timedwait(&th_clink, c2_time_add(c2_time_now(), delta));
-		c2_mutex_lock(&loc->fl_lock);
-		fom = fom_dequeue(loc);
-		if (fom == NULL && !idle)
-			C2_CNT_INC(loc->fl_idle_threads_nr);
-		else if (fom != NULL && idle)
-			C2_CNT_DEC(loc->fl_idle_threads_nr);
-		idle = fom == NULL;
-	} while (!idle || loc->fl_idle_threads_nr <= loc->fl_lo_idle_threads_nr);
-
-	C2_CNT_DEC(loc->fl_idle_threads_nr);
-	C2_CNT_DEC(loc->fl_threads_nr);
-	c2_mutex_unlock(&loc->fl_lock);
-	c2_clink_del(&th_clink);
-	c2_clink_fini(&th_clink);
-}
-
-/**
- * Init function for a reqh worker thread.
- * Adds thread to the locality thread list and
- * increments thread count in locality atomically.
- *
- * @param th c2_fom_hthread, contains thread reference, locality reference
- *		and thread linkage in locality
- */
-static int loc_thr_init(struct c2_fom_hthread *th)
-{
-	struct c2_fom_locality *loc;
-	int                     rc;
-
-	loc = th->fht_locality;
-	C2_ASSERT(loc != NULL);
-
-	c2_mutex_lock(&loc->fl_lock);
-	rc = c2_thread_confine(&th->fht_thread, &loc->fl_processors);
-	if (rc == 0) {
-		c2_list_add_tail(&loc->fl_threads, &th->fht_linkage);
-		C2_CNT_INC(loc->fl_threads_nr);
-	}
-	c2_mutex_unlock(&loc->fl_lock);
-
-	return rc;
-}
-
-/**
- * Creates and adds a request handler worker thread to the given
- * locality.
- *
- * @see loc_thr_init()
- *
- * @param loc Locality in which the threads are added
- *
- * @retval 0 If a thread is successfully created and
- *		added to the given locality
- *	-errno on failure
- *
- * @pre loc != NULL
- */
-static int loc_thr_create(struct c2_fom_locality *loc)
-{
-	int			result;
-	struct c2_fom_hthread  *locthr;
-	struct c2_addb_ctx     *fom_addb_ctx;
-
-	C2_PRE(loc != NULL);
-
-	fom_addb_ctx = &loc->fl_dom->fd_addb_ctx;
-	C2_ALLOC_PTR_ADDB(locthr, fom_addb_ctx, &c2_fom_addb_loc);
-	if (locthr == NULL)
-		return -ENOMEM;
-
-	locthr->fht_locality = loc;
-	result = C2_THREAD_INIT(&locthr->fht_thread, struct c2_fom_hthread *,
-			loc_thr_init, &loc_handler_thread, locthr,
-			"locality_thread");
-
-	if (result != 0) {
-		c2_list_del(&locthr->fht_linkage);
-		c2_free(locthr);
-	}
-
-	return result;
-}
-
-/**
- * Finalises a given locality.
- * Sets c2_fom_locality::fl_lo_idle_threads_nr to 0, and
- * iterates over the c2_fom_locality::fl_threads list.
- * Extracts a thread, and waits until the thread exits,
- * finalises each thread. After removing all the threads
- * from the locality, other locality members are finalised.
- *
- * @param loc Locality to be finalised
- *
- * @pre loc != NULL
- */
-static void locality_fini(struct c2_fom_locality *loc)
-{
-	struct c2_list_link	*link;
-	struct c2_fom_hthread	*th;
-
-	C2_PRE(loc != NULL);
-
-	c2_mutex_lock(&loc->fl_lock);
-	C2_ASSERT(c2_locality_invariant(loc));
-	loc->fl_lo_idle_threads_nr = 0;
-	c2_chan_broadcast(&loc->fl_runrun);
-	while (!c2_list_is_empty(&loc->fl_threads)) {
-
-		link = c2_list_first(&loc->fl_threads);
-		C2_ASSERT(link != NULL);
-		c2_list_del(link);
-		c2_mutex_unlock(&loc->fl_lock);
-		th = container_of(link, struct c2_fom_hthread,
-					fht_linkage);
-		C2_ASSERT(th != NULL);
-		c2_thread_join(&th->fht_thread);
-		c2_thread_fini(&th->fht_thread);
-		c2_free(th);
-		c2_mutex_lock(&loc->fl_lock);
-	}
-	c2_mutex_unlock(&loc->fl_lock);
-
-	c2_list_fini(&loc->fl_runq);
-	C2_ASSERT(loc->fl_runq_nr == 0);
-
-	c2_list_fini(&loc->fl_wail);
-	C2_ASSERT(loc->fl_wail_nr == 0);
-
-	c2_mutex_fini(&loc->fl_lock);
-	c2_chan_fini(&loc->fl_runrun);
-	c2_list_fini(&loc->fl_threads);
-	C2_ASSERT(loc->fl_threads_nr == 0);
-
-	c2_bitmap_fini(&loc->fl_processors);
-}
-
-/**
- * Initialises a locality in fom domain.
- * Creates and adds threads to locality, every thread is
- * confined to the cpus represented by the pmap, this is
- * done in the thread init function.
- * Number of threads in the locality corresponds to the
- * number of cpus represented by the bits set in the pmap.
- *
- * @see loc_thr_init()
- *
- * @param loc  c2_fom_locality to be initialised
- * @param pmap Bitmap representing number of cpus
- *		present in the locality
- *
- * @retval 0 If locality is initialised
- *	-errno on failure
- *
- * @pre loc != NULL
- */
-static int locality_init(struct c2_fom_locality *loc, struct c2_bitmap *pmap)
-{
-	int			result;
-	int			i;
-	int			ncpus;
-	c2_processor_nr_t	max_proc;
-
-	C2_PRE(loc != NULL);
-
-	max_proc = c2_processor_nr_max();
-
-	c2_list_init(&loc->fl_runq);
-	loc->fl_runq_nr = 0;
-
-	c2_list_init(&loc->fl_wail);
-	loc->fl_wail_nr = 0;
-
-	c2_mutex_init(&loc->fl_lock);
-	c2_chan_init(&loc->fl_runrun);
-	c2_list_init(&loc->fl_threads);
-
-	result = c2_bitmap_init(&loc->fl_processors, max_proc);
-
-	if (result == 0) {
-		for (i = 0, ncpus = 0; i < max_proc; ++i) {
-			if (c2_bitmap_get(pmap, i)) {
-				c2_bitmap_set(&loc->fl_processors, i, true);
-				C2_CNT_INC(ncpus);
-			}
-		}
-
-                if (ncpus > MIN_CPU_NR)
-                        loc->fl_lo_idle_threads_nr = ncpus/2;
-                else
-                        loc->fl_lo_idle_threads_nr = ncpus;
-
-                loc->fl_hi_idle_threads_nr = ncpus;
-
-		for (i = 0; i < ncpus; ++i) {
-			result = loc_thr_create(loc);
-			if (result != 0)
-				break;
-		}
-	}
-
-	if (result != 0)
-		locality_fini(loc);
-
-	return result;
-}
-
-/**
- * Checks if cpu resource is shared.
- *
- * @retval bool true if cpu resource is shared
- *		false if no cpu resource is shared
- */
-static bool resource_is_shared(const struct c2_processor_descr *cpu1,
-			const struct c2_processor_descr *cpu2)
-{
-	return cpu1->pd_l2 == cpu2->pd_l2 ||
-		cpu1->pd_numa_node == cpu2->pd_numa_node;
-}
-
-int  c2_fom_domain_init(struct c2_fom_domain *dom)
-{
-	int				i;
-	int				j;
-	struct c2_processor_descr	cpui;
-	struct c2_processor_descr	cpuj;
-	c2_processor_nr_t		max_proc;
-	c2_processor_nr_t		result;
-	struct c2_bitmap		onln_cpu_map;
-	struct c2_bitmap		loc_cpu_map;
-	struct c2_fom_locality	       *localities;
-
-	C2_PRE(dom != NULL);
-
-	/*
-	 * Check number of processors online and create localities
-	 * between one's sharing common resources.
-	 * Currently considering shared L2 cache and numa node,
-	 * between cores, as shared resources.
-	 */
-	max_proc = c2_processor_nr_max();
-	dom->fd_ops = &c2_fom_dom_ops;
-	result = c2_bitmap_init(&onln_cpu_map, max_proc);
-	if (result != 0)
-		return result;
-
-	result = c2_bitmap_init(&loc_cpu_map, max_proc);
-	if (result != 0) {
-		c2_bitmap_fini(&onln_cpu_map);
-		return result;
-	}
-
-	c2_processors_online(&onln_cpu_map);
-
-        c2_addb_ctx_init(&dom->fd_addb_ctx, &c2_fom_addb_ctx_type,
-						&c2_addb_global_ctx);
-	C2_ALLOC_ARR_ADDB(dom->fd_localities, max_proc, &dom->fd_addb_ctx,
-							&c2_fom_addb_loc);
-	if (dom->fd_localities == NULL) {
-		c2_addb_ctx_fini(&dom->fd_addb_ctx);
-		c2_bitmap_fini(&onln_cpu_map);
-		c2_bitmap_fini(&loc_cpu_map);
-		return -ENOMEM;
-	}
-
-	localities = dom->fd_localities;
-	for (i = 0; i < max_proc; ++i) {
-		if (!c2_bitmap_get(&onln_cpu_map, i))
-			continue;
-		result = c2_processor_describe(i, &cpui);
-		if (result != 0)
-			break;
-		for (j = i; j < max_proc; ++j) {
-			if (!c2_bitmap_get(&onln_cpu_map, j))
-				continue;
-			result = c2_processor_describe(j, &cpuj);
-			if (result == 0 && resource_is_shared(&cpui, &cpuj)) {
-				c2_bitmap_set(&loc_cpu_map, cpuj.pd_id, true);
-				c2_bitmap_set(&onln_cpu_map, j, false);
-			}
-		}
-		if (result == 0) {
-			localities[dom->fd_localities_nr].fl_dom = dom;
-			result = locality_init(&localities[dom->fd_localities_nr],
-						&loc_cpu_map);
-			if (result == 0) {
-				c2_bitmap_fini(&loc_cpu_map);
-				C2_CNT_INC(dom->fd_localities_nr);
-				result = c2_bitmap_init(&loc_cpu_map, max_proc);
-			}
-		}
-		if (result != 0)
-			break;
-
-	}
-
-	if (result != 0)
-		c2_fom_domain_fini(dom);
-
-	c2_bitmap_fini(&onln_cpu_map);
-	c2_bitmap_fini(&loc_cpu_map);
-
-	return result;
-}
-
-void c2_fom_domain_fini(struct c2_fom_domain *dom)
-{
-	int fd_loc_nr;
-
-	C2_ASSERT(c2_fom_domain_invariant(dom));
-
-	fd_loc_nr = dom->fd_localities_nr;
-	while (fd_loc_nr > 0) {
-		locality_fini(&dom->fd_localities[fd_loc_nr - 1]);
-		--fd_loc_nr;
-	}
-
-	c2_addb_ctx_fini(&dom->fd_addb_ctx);
-	c2_free(dom->fd_localities);
-}
-
-void c2_fom_init(struct c2_fom *fom)
-{
-	C2_PRE(fom != NULL);
-
-	fom->fo_phase = FOPH_INIT;
-	fom->fo_rep_fop = NULL;
-
-	c2_clink_init(&fom->fo_clink, &fom_cb);
-	c2_list_link_init(&fom->fo_linkage);
-}
-C2_EXPORTED(c2_fom_init);
-
-void c2_fom_fini(struct c2_fom *fom)
-{
-	C2_PRE(fom->fo_phase == FOPH_FINISH);
-
-	c2_atomic64_dec(&fom->fo_loc->fl_dom->fd_foms_nr);
-	c2_clink_fini(&fom->fo_clink);
-	c2_list_link_fini(&fom->fo_linkage);
-}
-C2_EXPORTED(c2_fom_fini);
-
-void c2_fom_create(struct c2_fom *fom, struct c2_fom_type *fom_type,
-		const struct c2_fom_ops *ops, struct c2_fop *fop,
-		struct c2_fop *reply)
-{
-	C2_PRE(fom != NULL);
-
-	c2_fom_init(fom);
-
-	fom->fo_type	= fom_type;
-	fom->fo_ops	= ops;
-	fom->fo_fop	= fop;
-	fom->fo_rep_fop = reply;
-}
-C2_EXPORTED(c2_fom_create);
-/** @} endgroup fom */
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
diff --git a/fop/fom.h b/fop/fom.h
index fa2d61f..5cc915f 100644
--- a/fop/fom.h
+++ b/fop/fom.h
@@ -14,8 +14,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Nikita Danilov <nikita_danilov@xyratex.com>,
- *		    Mandar Sawant <Mandar_Sawant@xyratex.com>
+ * Original author: Nikita Danilov <nikita_danilov@xyratex.com>
  * Original creation date: 05/19/2010
  */
 
@@ -51,10 +50,6 @@
 #include "lib/bitmap.h"
 #include "lib/mutex.h"
 #include "lib/chan.h"
-#include "lib/atomic.h"
-
-#include "fol/fol.h"
-#include "stob/stob.h"
 
 struct c2_fop_type;
 
@@ -79,32 +74,23 @@ struct c2_fom_ops;
 
    - part of primary store.
 
-   Lock ordering:
-
-   - no lock ordering is needed here as access to all the locality members
-     is protected by a common locality lock, c2_fom_locality::fl_lock.
-     All the operations on locality members are performed independently using
-     simple locking and unlocking semantics.
-
-   Once the locality is initialised, the locality invariant,
-   should hold true until locality is finalised.
-
-   @see c2_locality_invaraint()
+   @todo lock ordering.
  */
-
 struct c2_fom_locality {
-	struct c2_fom_domain        *fl_dom;
+	struct c2_fom_domain *fl_dom;
 
-	/** Run-queue */
-	struct c2_list               fl_runq;
-	size_t			     fl_runq_nr;
+	/** run-queue */
+	struct c2_queue       fl_runq;
+	size_t                fl_runq_nr;
+	struct c2_mutex       fl_runq_lock;
 
-	/** Wait list */
-	struct c2_list		     fl_wail;
-	size_t			     fl_wail_nr;
+	/** wait list */
+	struct c2_list        fl_wail;
+	size_t                fl_wail_nr;
+	struct c2_mutex       fl_wail_lock;
 
-	/** Common lock used to protect locality fields */
-	struct c2_mutex		     fl_lock;
+	/** Lock for the locality fields not protected by the locks above. */
+	struct c2_mutex       fl_lock;
 
 	/**
 	    Re-scheduling channel that idle threads of locality wait on for new
@@ -113,93 +99,59 @@ struct c2_fom_locality {
 	    @see http://www.tom-yam.or.jp/2238/src/slp.c.html#line2142 for
 	    the explanation of the name.
 	*/
-	struct c2_chan		     fl_runrun;
+	struct c2_chan        fl_runrun;
 
-	/** Handler threads */
-	struct c2_list		     fl_threads;
-	size_t			     fl_idle_threads_nr;
-	size_t			     fl_threads_nr;
+	/** handler threads */
+	struct c2_list        fl_threads;
+	size_t                fl_idle_threads_nr;
+	size_t                fl_threads_nr;
 
-	/**
-	    Minimum number of idle threads, that should be present in a
-	    locality.
-	 */
-	size_t			     fl_lo_idle_threads_nr;
-
-	/**
-	    Maximum number of idle threads, that should be present in a
-	    locality.
+	/*
+	 * Resources allotted to the partition.
 	 */
-	size_t			     fl_hi_idle_threads_nr;
 
-	/** Resources allotted to the partition */
-	struct c2_bitmap	     fl_processors;
+	struct c2_bitmap      fl_processors;
 
-	/** Something for memory, see set_mempolicy(2). */
+	/*
+	 * Something for memory, see set_mempolicy(2).
+	 */
 };
 
 /**
-   Iterates over c2_fom_locality members and checks if
-   they are intialised and consistent.
-   This function must be invoked with c2_fom_locality::fl_lock
-   mutex held.
- */
-bool c2_locality_invariant(const struct c2_fom_locality *loc);
-
-/**
    Domain is a collection of localities that compete for the resources. For
    example, there would be typically a domain for each service (c2_service).
-
-   Once the fom domain is initialised, fom domain invariant should hold
-   true until fom domain is finalised .
-
-   @see c2_fom_domain_invariant()
  */
 struct c2_fom_domain {
 	/** An array of localities. */
-	struct c2_fom_locality		*fd_localities;
+	struct c2_fom_locality         *fd_localities;
 	/** Number of localities in the domain. */
-	size_t				 fd_localities_nr;
-	/** Number of foms under execution in this fom domain. */
-	struct c2_atomic64               fd_foms_nr;
+	size_t                          fd_nr;
 	/** Domain operations. */
-	const struct c2_fom_domain_ops	*fd_ops;
-	/** Request handler this domain belongs to */
-	struct c2_reqh			*fd_reqh;
-	/** Addb context for fom */
-	struct c2_addb_ctx               fd_addb_ctx;
+	const struct c2_fom_domain_ops *fd_ops;
 };
 
 /** Operations vector attached to a domain. */
 struct c2_fom_domain_ops {
-	/**
-	    Returns true if waiting (FOS_WAITING) fom timed out and should be
-	    moved into FOPH_TIMEOUT phase.
-	    @todo fom timeout implementation.
-	*/
+	/** Called to select a home locality for a (new) fom. */
+	size_t (*fdo_home_locality)(const struct c2_fom_domain *dom,
+				    const struct c2_fom *fom);
+	/** Returns true iff waiting (FOS_WAITING) fom timed out and should be
+	    moved into FOPH_TIMEOUT phase. */
 	bool   (*fdo_time_is_out)(const struct c2_fom_domain *dom,
 				  const struct c2_fom *fom);
 };
 
 /**
    States a fom can be in.
+
+   @todo concurrency.
  */
 enum c2_fom_state {
-	/**
-	   Fom is in FOS_RUNNING state when its state transition function is being
-	   executed by a locality handler thread.
-	   The fom is not on any queue in this state.
-	 */
+	/** The fom is being executed by a handler thread in some locality. */
 	FOS_RUNNING,
-	/**
-	    Fom is in FOS_READY state when it is on locality runq for execution.
-	*/
+	/** The fom is in the run-queue of some locality. */
 	FOS_READY,
-	/**
-	    Fom is in FOS_WAITING state when some event must happen before the next
-	    state transition would become possible.
-	    The fom is on a locality wait list in this state.
-	 */
+	/** The fom is in the wait-list of some locality. */
 	FOS_WAITING,
 };
 
@@ -210,7 +162,6 @@ enum c2_fom_state {
    fom type.
 
    @see https://docs.google.com/a/xyratex.com/Doc?docid=0ATg1HFjUZcaZZGNkNXg4cXpfMjA2Zmc0N3I3Z2Y
-   @see c2_fom_state_generic()
  */
 enum c2_fom_phase {
 	FOPH_INIT,                  /*< fom has been initialised. */
@@ -229,156 +180,47 @@ enum c2_fom_phase {
 	FOPH_AUTHORISATION_WAIT,    /*< waiting for userdb cache miss. */
 	FOPH_TXN_CONTEXT,           /*< creating local transactional context. */
 	FOPH_TXN_CONTEXT_WAIT,      /*< waiting for log space. */
-	FOPH_SUCCESS,		    /*< fom execution completed succesfully. */
-	FOPH_TXN_COMMIT,	    /*< commit local transaction context. */
-	FOPH_TXN_COMMIT_WAIT,	    /*< waiting to commit local transaction context. */
-	FOPH_TIMEOUT,               /*< fom timed out. */
-	FOPH_FAILURE,                /*< fom execution failed. */
-	FOPH_TXN_ABORT,		    /*< abort local transaction context. */
-	FOPH_TXN_ABORT_WAIT,	    /*< waiting to abort local transaction context. */
-	FOPH_QUEUE_REPLY,           /*< queuing fop reply.  */
+	FOPH_QUEUE_REPLY,           /*< queuing reply fop-s. */
 	FOPH_QUEUE_REPLY_WAIT,      /*< waiting for fop cache space. */
-	FOPH_FINISH,		    /*< terminal state. */
+	FOPH_TIMEOUT,               /*< fom timed out. */
+	FOPH_FAILED,                /*< fom failed. */
+	FOPH_DONE,		    /*< fom succeeded. */
 	FOPH_NR                     /*< number of standard phases. fom type
 				      specific phases have numbers larger than
 				      this. */
 };
 
-/**
-   Initialises c2_fom_domain object provided by the caller.
-   Creates and initialises localities with handler threads.
-
-   @param dom, fom domain to be initialised, provided by caller
-
-   @pre dom != NULL
- */
-int  c2_fom_domain_init(struct c2_fom_domain *dom);
+int  c2_fom_domain_init(struct c2_fom_domain *dom, size_t nr);
+void c2_fom_domain_fini(struct c2_fom_domain *dom);
 
 /**
-   Finalises fom domain.
-   Also finalises the localities in fom domain and destroys
-   the handler threads per locality.
+   Queues a fom for the execution in a domain.
 
-   @param dom, fom domain to be finalised, all the
+   A home locality is selected for the fom. The fom is placed in the
+   corresponding run-queue and scheduled for the execution.
 
-   @pre dom != NULL && dom->fd_localities != NULL
- */
-void c2_fom_domain_fini(struct c2_fom_domain *dom);
+   Possible errors are reported through fom state and phase, hence the return
+   type is void.
 
-/**
-   This function iterates over c2_fom_domain members and checks
-   if they are intialised.
+   @pre fom->fo_phase == FOPH_INIT
  */
-bool c2_fom_domain_invariant(const struct c2_fom_domain *dom);
-
-/**
-   Fop state machine.
+void c2_fom_queue(struct c2_fom_domain *dom, struct c2_fom *fom);
 
-   Once the fom is initialised, fom invariant,
-   should hold true as fom execution enters various
-   phases, including before fom is finalised.
-
-   @see c2_fom_invariant()
-*/
+/** Fop state machine. */
 struct c2_fom {
-	/**
-	   State a fom can be in at any given instance throughout its
-	   life cycle.This feild is protected by c2_fom_locality:fl_lock
-	   mutex, except in reqh handler thread, when a fom is dequeued
-	   from locality runq list for execution.
-
-	   @see c2_fom_locality
-	*/
-	enum c2_fom_state	 fo_state;
-	/** FOM phase under execution */
-	int			 fo_phase;
-	/** Locality this fom belongs to */
-	struct c2_fom_locality	*fo_loc;
-	struct c2_fom_type	*fo_type;
-	const struct c2_fom_ops	*fo_ops;
-	/** FOM clink to wait upon a particular channel for an event */
-	struct c2_clink		 fo_clink;
-	/** FOP ctx sent by the network service. */
+	enum c2_fom_state        fo_state;
+	int 			 fo_phase;
+	struct c2_fom_locality  *fo_loc;
+	struct c2_fom_type      *fo_type;
+	const struct c2_fom_ops *fo_ops;
+	struct c2_clink          fo_clink;
+	/** FOP ctx prepared by reqh. It has we need to handle fop. */
 	struct c2_fop_ctx	*fo_fop_ctx;
-	/** Request fop object, this fom belongs to */
-	struct c2_fop		*fo_fop;
-	/** Reply fop object */
-	struct c2_fop		*fo_rep_fop;
-	/** Fol object for this fom */
-	struct c2_fol		*fo_fol;
-	/** Transaction object to be used by this fom */
-	struct c2_dtx		 fo_tx;
-	/**
-	    FOM linkage in the locality runq list or wait list
-	    Every access to the FOM via this linkage is
-	    protected by the c2_fom_locality::fl_lock mutex.
-	 */
-	struct c2_list_link	 fo_linkage;
-
-	/** Result of fom execution, -errno on failure */
-	int32_t			 fo_rc;
 };
 
-/**
-   Queues a fom for the execution in a locality runq.
-   Increments the number of foms in execution (c2_fom_domain::fd_foms_nr)
-   in fom domain atomically.
-   The fom is placed in the locality run-queue and scheduled for the execution.
-   Possible errors are reported through fom state and phase, hence the return
-   type is void.
-
-   @param fom, A fom to be submitted for execution
-   @pre fom->fo_phase == FOPH_INIT || fom->fo_phase == FOPH_FAILURE
- */
-void c2_fom_queue(struct c2_fom *fom);
-
-/**
-   Initialises fom allocated by the caller.
-   Invoked from c2_fom_type_ops::fto_create implementation for
-   corresponding fom.
-   Fom starts in FOPH_INIT phase and FOS_READY state to begin its
-   execution.
-
-   @param fom, A fom to be initialised
-   @pre fom != NULL
- */
 void c2_fom_init(struct c2_fom *fom);
-
-/**
-   Finalises a fom after it completes its execution,
-   i.e success or failure.
-   Also decrements the number of foms under execution in fom domain
-   atomically.
-
-   @param fom, A fom to be finalised
-   @pre fom->fo_phase == FOPH_FINISH
-*/
 void c2_fom_fini(struct c2_fom *fom);
 
-/**
-   Iterates over c2_fom members and check if they are consistent,
-   and also checks if the fom resides on correct list (i.e runq or
-   wait list) of the locality at any given instance.
-   This function must be invoked with c2_fom_locality::fl_lock
-   mutex held.
- */
-bool c2_fom_invariant(const struct c2_fom *fom);
-
-/**
-   Initialises fom allocated by caller.
-   Invokes c2_fom_init().
-   @see c2_fom_init()
-   @param fom A fom to be initialized
-   @param fom_type Fom type
-   @param ops Fom operations structure
-   @param fop Request fop object
-   @param reply Reply fop object
-   @pre fom != NULL
- */
-void c2_fom_create(struct c2_fom *fom, struct c2_fom_type *fom_type,
-		const struct c2_fom_ops *ops, struct c2_fop *fop,
-		struct c2_fop *reply);
-
 /** Type of fom. c2_fom_type is part of c2_fop_type. */
 struct c2_fom_type {
 	const struct c2_fom_type_ops *ft_ops;
@@ -393,10 +235,10 @@ enum c2_fom_state_outcome {
 	/**
 	    State transition completed. The next state transition would be
 	    possible when some future event happens. The state transition
-	    function registeres the fom's clink with the channel where this
-	    event will be signalled.
+	    function registered the fom's clink with the channel where this
+	    event will be signalised.
 
-	    When FSO_WAIT is returned, the fom is put on locality wait-list.
+	    When FSO_WAIT is returned, the fom is placed in the wait-list.
 
 	    @see c2_fom_block_at().
 	 */
@@ -415,73 +257,56 @@ enum c2_fom_state_outcome {
 
 /** Fom type operation vector. */
 struct c2_fom_type_ops {
-	/** Create a new fom for the given fop. */
-	int (*fto_create)(struct c2_fop *fop, struct c2_fom **out);
+	/** Create a new fom of this type. */
+	int (*fto_create)(struct c2_fom_type *t, struct c2_fom **out);
 };
 
 /** Fom operations vector. */
 struct c2_fom_ops {
-	/** Finalise this fom. */
-	void (*fo_fini)(struct c2_fom *fom);
-	/**
-	    Executes the next state transition.
-
-	    Returns value of enum c2_fom_state_outcome or error code.
-	 */
-	int  (*fo_state)(struct c2_fom *fom);
-
-	/**
-	    Finds home locality for this fom.
-
-	    Returns numerical value based on certain fom parameters that is
-	    used to select the home locality from c2_fom_domain::fd_localities
-	    array.
-	 */
-	size_t  (*fo_home_locality) (const struct c2_fom *fom);
+        /**
+           Execute fom fini actions. Free memory if needed.
+        */
+        void (*fo_fini)(struct c2_fom *fom);
+        /**
+           Execute pre-state actions. Operation sanity checks
+           may be done this way in reqh and errors handled before
+           calling fo_state()
+        */
+        int  (*fo_sanity)(struct c2_fom *fom);
+        /**
+            Execute the next state transition.
+
+            Returns value of enum c2_fom_state_outcome or error code.
+        */
+        int  (*fo_state)(struct c2_fom *fom);
 };
 
 /** Handler thread. */
 struct c2_fom_hthread {
-	struct c2_thread	fht_thread;
+	struct c2_thread    fht_thread;
 	/** Linkage into c2_fom_locality::fl_threads. */
-	struct c2_list_link	fht_linkage;
-	/** locality this thread belongs to */
-	struct c2_fom_locality	*fht_locality;
+	struct c2_list_link fht_linkage;
 };
 
 /**
+   Checks whether the locality has "enough" idle threads. If not, additional
+   threads is started to cope with possible blocking point.
+
    This function is called before potential blocking point.
-   Checks whether the fom locality has "enough" idle threads.
-   If not, additional threads are started to cope with possible
-   blocking point.
-   Increments c2_fom_locality::fl_lo_idle_threads_nr, so that
-   there exists atleast one idle thread to handle incoming fop if
-   the calling thread blocks.
-
-   @param fom, A fom executing a possible blocking operation
-   @see c2_fom_locality
  */
-void c2_fom_block_enter(struct c2_fom *fom);
+void c2_fom_block_enter(struct c2_fom_locality *loc);
 
 /**
    This function is called after potential blocking point.
-   Decrements c2_fom_locality::fl_lo_idle_threads_nr, so that
-   extra idle threads are destroyed automatically.
 
-   @param fom, A fom done executing a blocking operation
+   Arms a timer that would retire extra idle threads if necessary. The timer is
+   needed to amortize thread creation costs.
  */
-void c2_fom_block_leave(struct c2_fom *fom);
+void c2_fom_block_leave(struct c2_fom_locality *loc);
 
 /**
-   Registers fom with the channel provided by the caller on which
-   the fom would wait for signal after completing a blocking operation.
-   This function returns with c2_fom_locality::fl_lock held.
-   Fom resumes its execution once the chan is signalled.
-
-   @param fom, A fom executing a blocking operation
-   @param chan, waiting channel registered with the fom during its
-		blocking operation
-   @pre !c2_clink_is_armed(&fom->fo_clink)
+   Registers the fom with the channel, so that next fom's state transition would
+   happen when the channel is signalised.
  */
 void c2_fom_block_at(struct c2_fom *fom, struct c2_chan *chan);
 
diff --git a/fop/fop.c b/fop/fop.c
index d506c54..72ffc69 100644
--- a/fop/fop.c
+++ b/fop/fop.c
@@ -17,6 +17,7 @@
  * Original author: Nikita Danilov <nikita_danilov@xyratex.com>
  * Original creation date: 05/19/2010
  */
+
 #include "lib/cdefs.h"  /* C2_EXPORTED */
 #include "lib/memory.h"
 #include "lib/misc.h"   /* C2_SET0 */
@@ -25,77 +26,90 @@
 #include "lib/vec.h"
 #include "fop/fop.h"
 #include "fop/fop_iterator.h"
-#include "lib/errno.h"
 
 /**
    @addtogroup fop
    @{
  */
 
-extern struct c2_addb_ctx_type c2_fop_addb_ctx;
+int  c2_fop_field_type_prepare  (struct c2_fop_field_type *ftype);
+void c2_fop_field_type_unprepare(struct c2_fop_field_type *ftype);
 
-int c2_fop_init(struct c2_fop *fop, struct c2_fop_type *fopt, void *data)
-{
-	c2_bcount_t nob;
+static int  fop_fol_type_init(struct c2_fop_type *fopt);
+static void fop_fol_type_fini(struct c2_fop_type *fopt);
 
-	C2_PRE(fop != NULL && fopt != NULL);
+static const struct c2_fol_rec_type_ops c2_fop_fol_default_ops;
 
-	fop->f_type = fopt;
-	fop->f_private = NULL;
+static const struct c2_addb_ctx_type c2_fop_addb_ctx = {
+	.act_name = "fop"
+};
 
-	nob = fopt->ft_top->fft_layout->fm_sizeof;
+static const struct c2_addb_ctx_type c2_fop_type_addb_ctx = {
+	.act_name = "fop-type"
+};
 
-	if (data == NULL) {
-		data = c2_alloc(nob);
-		if (data == NULL)
-			return -ENOMEM;
-	}
-	fop->f_data.fd_data = data;
-	c2_addb_ctx_init(&fop->f_addb, &c2_fop_addb_ctx,
-			 &fopt->ft_addb);
-	c2_list_link_init(&fop->f_link);
+static const struct c2_addb_loc c2_fop_addb_loc = {
+	.al_name = "fop"
+};
 
-	c2_rpc_item_init(&fop->f_item);
-	fop->f_item.ri_type = &fop->f_type->ft_rpc_item_type;
+static struct c2_mutex fop_types_lock;
+static struct c2_list  fop_types_list;
+/**
+   Used to check that no new fop iterator types are registered once a fop type
+   has been built.
+ */
+bool fop_types_built = false;
 
-	return 0;
+void c2_fop_field_type_fini(struct c2_fop_field_type *t)
+{
+	size_t i;
+
+	c2_fop_field_type_unprepare(t);
+	if (t->fft_child != NULL) {
+		for (i = 0; i < t->fft_nr; ++i) {
+			if (t->fft_child[i] != NULL)
+				c2_free(t->fft_child[i]);
+		}
+		c2_free(t->fft_child);
+		t->fft_child = NULL;
+	}
 }
+C2_EXPORTED(c2_fop_field_type_fini);
 
 struct c2_fop *c2_fop_alloc(struct c2_fop_type *fopt, void *data)
 {
 	struct c2_fop *fop;
-	int            err;
 
 	C2_ALLOC_PTR(fop);
 	if (fop != NULL) {
-		err = c2_fop_init(fop, fopt, data);
-		if (err != 0) {
+		c2_bcount_t nob;
+
+		fop->f_type = fopt;
+		nob = fopt->ft_top->fft_layout->fm_sizeof;
+		if (data == NULL)
+			data = c2_alloc(nob);
+		if (data != NULL) {
+			fop->f_data.fd_data = data;
+			c2_addb_ctx_init(&fop->f_addb, &c2_fop_addb_ctx,
+					 &fopt->ft_addb);
+		} else {
 			c2_free(fop);
 			fop = NULL;
 		}
-		fop->f_item.ri_ops = &c2_fop_default_item_ops;
 	}
 	return fop;
 }
 C2_EXPORTED(c2_fop_alloc);
 
-void c2_fop_fini(struct c2_fop *fop)
-{
-	C2_ASSERT(fop != NULL);
-
-	c2_rpc_item_fini(&fop->f_item);
-	c2_addb_ctx_fini(&fop->f_addb);
-	c2_free(fop->f_data.fd_data);
-	c2_list_link_fini(&fop->f_link);
-}
-
 void c2_fop_free(struct c2_fop *fop)
 {
+	c2_addb_ctx_fini(&fop->f_addb);
 	if (fop != NULL) {
-		c2_fop_fini(fop);
+		c2_free(fop->f_data.fd_data);
 		c2_free(fop);
 	}
 }
+C2_EXPORTED(c2_fop_free);
 
 void *c2_fop_data(struct c2_fop *fop)
 {
@@ -104,6 +118,166 @@ void *c2_fop_data(struct c2_fop *fop)
 }
 C2_EXPORTED(c2_fop_data);
 
+void c2_fop_type_fini(struct c2_fop_type *fopt)
+{
+	fop_fol_type_fini(fopt);
+	if (fopt->ft_top != NULL) {
+		c2_mutex_lock(&fop_types_lock);
+		c2_list_del(&fopt->ft_linkage);
+		c2_mutex_unlock(&fop_types_lock);
+	}
+	if (fopt->ft_fmt != NULL) {
+		c2_fop_type_format_fini(fopt->ft_fmt);
+		fopt->ft_fmt = NULL;
+	}
+	c2_addb_ctx_fini(&fopt->ft_addb);
+}
+C2_EXPORTED(c2_fop_type_fini);
+
+int c2_fop_type_build(struct c2_fop_type *fopt)
+{
+	int                        result;
+	struct c2_fop_type_format *fmt;
+
+	C2_PRE(fopt->ft_top == NULL);
+
+	fmt    = fopt->ft_fmt;
+	result = c2_fop_type_format_parse(fmt);
+	if (result == 0) {
+		result = fop_fol_type_init(fopt);
+		if (result == 0) {
+			fopt->ft_top = fmt->ftf_out;
+			c2_addb_ctx_init(&fopt->ft_addb,
+					 &c2_fop_type_addb_ctx,
+					 &c2_addb_global_ctx);
+			c2_mutex_lock(&fop_types_lock);
+			c2_list_add(&fop_types_list, &fopt->ft_linkage);
+			c2_mutex_unlock(&fop_types_lock);
+		}
+		if (result != 0)
+			c2_fop_type_fini(fopt);
+	}
+	fop_types_built = true;
+	return result;
+}
+C2_EXPORTED(c2_fop_type_build);
+
+int c2_fop_type_build_nr(struct c2_fop_type **fopt, int nr)
+{
+	int i;
+	int result;
+
+	for (result = 0, i = 0; i < nr; ++i) {
+		result = c2_fop_type_build(fopt[i]);
+		if (result != 0) {
+			c2_fop_type_fini_nr(fopt, i);
+			break;
+		}
+	}
+	return result;
+}
+C2_EXPORTED(c2_fop_type_build_nr);
+
+void c2_fop_type_fini_nr(struct c2_fop_type **fopt, int nr)
+{
+	int i;
+
+	for (i = 0; i < nr; ++i)
+		c2_fop_type_fini(fopt[i]);
+}
+C2_EXPORTED(c2_fop_type_fini_nr);
+
+struct c2_fop_memlayout atom_void_memlayout = {
+	.fm_uxdr   = (xdrproc_t)xdr_void,
+	.fm_sizeof = 0
+};
+
+struct c2_fop_field_type C2_FOP_TYPE_VOID = {
+	.fft_aggr = FFA_ATOM,
+	.fft_name = "void",
+	.fft_u = {
+		.u_atom = {
+			.a_type = FPF_VOID
+		}
+	},
+	.fft_layout = &atom_void_memlayout
+};
+C2_EXPORTED(C2_FOP_TYPE_VOID);
+
+struct c2_fop_memlayout atom_byte_memlayout = {
+	.fm_uxdr   = (xdrproc_t)xdr_char,
+	.fm_sizeof = 1
+};
+
+struct c2_fop_field_type C2_FOP_TYPE_BYTE = {
+	.fft_aggr = FFA_ATOM,
+	.fft_name = "byte",
+	.fft_u = {
+		.u_atom = {
+			.a_type = FPF_BYTE
+		}
+	},
+	.fft_layout = &atom_byte_memlayout
+};
+C2_EXPORTED(C2_FOP_TYPE_BYTE);
+
+struct c2_fop_memlayout atom_u32_memlayout = {
+	.fm_uxdr   = (xdrproc_t)xdr_uint32_t,
+	.fm_sizeof = 4
+};
+
+struct c2_fop_field_type C2_FOP_TYPE_U32 = {
+	.fft_aggr = FFA_ATOM,
+	.fft_name = "u32",
+	.fft_u = {
+		.u_atom = {
+			.a_type = FPF_U32
+		}
+	},
+	.fft_layout = &atom_u32_memlayout
+};
+C2_EXPORTED(C2_FOP_TYPE_U32);
+
+struct c2_fop_memlayout atom_u64_memlayout = {
+	.fm_uxdr   = (xdrproc_t)xdr_uint64_t,
+	.fm_sizeof = 8
+};
+
+struct c2_fop_field_type C2_FOP_TYPE_U64 = {
+	.fft_aggr = FFA_ATOM,
+	.fft_name = "u64",
+	.fft_u = {
+		.u_atom = {
+			.a_type = FPF_U64
+		}
+	},
+	.fft_layout = &atom_u64_memlayout
+};
+C2_EXPORTED(C2_FOP_TYPE_U64);
+
+int c2_fops_init(void)
+{
+	c2_list_init(&fop_types_list);
+	c2_mutex_init(&fop_types_lock);
+	c2_fits_init();
+	c2_fop_field_type_prepare(&C2_FOP_TYPE_VOID);
+	c2_fop_field_type_prepare(&C2_FOP_TYPE_BYTE);
+	c2_fop_field_type_prepare(&C2_FOP_TYPE_U32);
+	c2_fop_field_type_prepare(&C2_FOP_TYPE_U64);
+	return 0;
+}
+
+void c2_fops_fini(void)
+{
+	c2_fop_field_type_unprepare(&C2_FOP_TYPE_U64);
+	c2_fop_field_type_unprepare(&C2_FOP_TYPE_U32);
+	c2_fop_field_type_unprepare(&C2_FOP_TYPE_BYTE);
+	c2_fop_field_type_unprepare(&C2_FOP_TYPE_VOID);
+	c2_fits_fini();
+	c2_mutex_fini(&fop_types_lock);
+	c2_list_fini(&fop_types_list);
+}
+
 /*
  * fop-fol interaction.
  */
@@ -112,29 +286,26 @@ C2_EXPORTED(c2_fop_data);
 
 /* XXX for now */
 
-int fop_fol_type_init(struct c2_fop_type *fopt)
+static int fop_fol_type_init(struct c2_fop_type *fopt)
 {
 	return 0;
 }
 
-void fop_fol_type_fini(struct c2_fop_type *fopt)
+static void fop_fol_type_fini(struct c2_fop_type *fopt)
 {
 }
 
 #else /* !__KERNEL__ */
 
-static const struct c2_fol_rec_type_ops c2_fop_fol_default_ops;
-
-int fop_fol_type_init(struct c2_fop_type *fopt)
+static int fop_fol_type_init(struct c2_fop_type *fopt)
 {
 	struct c2_fol_rec_type *rtype;
 
-	C2_CASSERT(sizeof rtype->rt_opcode == sizeof
-		   fopt->ft_rpc_item_type.rit_opcode);
+	C2_CASSERT(sizeof rtype->rt_opcode == sizeof fopt->ft_code);
 
 	rtype = &fopt->ft_rec_type;
 	rtype->rt_name   = fopt->ft_name;
-	rtype->rt_opcode = fopt->ft_rpc_item_type.rit_opcode;
+	rtype->rt_opcode = fopt->ft_code;
 	if (fopt->ft_ops != NULL && fopt->ft_ops->fto_rec_ops != NULL)
 		rtype->rt_ops = fopt->ft_ops->fto_rec_ops;
 	else
@@ -142,7 +313,7 @@ int fop_fol_type_init(struct c2_fop_type *fopt)
 	return c2_fol_rec_type_register(rtype);
 }
 
-void fop_fol_type_fini(struct c2_fop_type *fopt)
+static void fop_fol_type_fini(struct c2_fop_type *fopt)
 {
 	c2_fol_rec_type_unregister(&fopt->ft_rec_type);
 }
@@ -154,8 +325,7 @@ int c2_fop_fol_rec_add(struct c2_fop *fop, struct c2_fol *fol,
 	struct c2_fol_rec_desc desc;
 
 	fopt = fop->f_type;
-	C2_CASSERT(sizeof desc.rd_header.rh_opcode ==
-		   sizeof fopt->ft_rpc_item_type.rit_opcode);
+	C2_CASSERT(sizeof desc.rd_header.rh_opcode == sizeof fopt->ft_code);
 
 	C2_SET0(&desc);
 	desc.rd_type               = &fop->f_type->ft_rec_type;
@@ -169,6 +339,7 @@ int c2_fop_fol_rec_add(struct c2_fop *fop, struct c2_fol *fol,
 	 */
 	return c2_fol_add(fol, tx, &desc);
 }
+C2_EXPORTED(c2_fop_fol_rec_add);
 
 static size_t fol_pack_size(struct c2_fol_rec_desc *desc)
 {
@@ -197,43 +368,6 @@ static const struct c2_fol_rec_type_ops c2_fop_fol_default_ops = {
 
 #endif /* __KERNEL__ */
 
-struct c2_rpc_item *c2_fop_to_rpc_item(struct c2_fop *fop)
-{
-	return &fop->f_item;
-}
-C2_EXPORTED(c2_fop_to_rpc_item);
-
-struct c2_fop *c2_rpc_item_to_fop(const struct c2_rpc_item *item)
-{
-	return container_of(item, struct c2_fop, f_item);
-}
-
-struct c2_fop_type *c2_item_type_to_fop_type
-		    (const struct c2_rpc_item_type *item_type)
-{
-	C2_PRE(item_type != NULL);
-
-	return container_of(item_type, struct c2_fop_type, ft_rpc_item_type);
-}
-
-/*
-   See declaration for more information.
- */
-void c2_fop_item_free(struct c2_rpc_item *item)
-{
-	struct c2_fop *fop;
-
-	fop = c2_rpc_item_to_fop(item);
-	/* c2_fop_free() internally calls c2_fop_fini() on the fop, which
-	   calls c2_rpc_item_fini() on the rpc-item */
-	c2_fop_free(fop);
-}
-
-const struct c2_rpc_item_ops c2_fop_default_item_ops = {
-	.rio_free = c2_fop_item_free,
-};
-C2_EXPORTED(c2_fop_default_item_ops);
-
 /** @} end of fop group */
 
 /*
diff --git a/fop/fop.h b/fop/fop.h
index bf1341e..bcf8529 100644
--- a/fop/fop.h
+++ b/fop/fop.h
@@ -27,8 +27,6 @@
 #include "addb/addb.h"
 #include "fol/fol.h"
 #include "fop/fom.h"
-#include "fop/fop_base.h"
-#include "rpc/rpc2.h"
 
 /**
    @defgroup fop File operation packet
@@ -45,10 +43,6 @@
    The execution of an operation described by fop is carried out by a "fop
    machine" (fom, struct c2_fom).
 
-   This file (fop.h) is a top-level header defining all fop-related data
-   structures and entry points. The bulk of the definitions is in fop_base.h,
-   which is included from this file.
-
    @note "Had I been one of the tragic bums who lurked in the mist of that
           station platform where a brittle young FOP was pacing back and forth,
           I would not have withstood the temptation to destroy him."
@@ -57,15 +51,57 @@
 */
 
 /* import */
+struct c2_fom;
+struct c2_rpcmachine;
 struct c2_service;
 struct c2_fol;
 struct c2_db_tx;
 struct c2_site;
 
 /* export */
-struct c2_fop_ctx;
+struct c2_fop_type;
+struct c2_fop_type_ops;
 struct c2_fop_data;
 struct c2_fop;
+struct c2_fop_field;
+struct c2_fop_field_type;
+struct c2_fop_memlayout;
+struct c2_fop_type_format;
+
+typedef uint32_t c2_fop_type_code_t;
+
+/**
+   Type of a file system operation.
+
+   There is an instance of c2_fop_type for "make directory" command, an instance
+   for "write", "truncate", etc.
+ */
+struct c2_fop_type {
+	/** Unique operation code. */
+	c2_fop_type_code_t                ft_code;
+	/** Operation name. */
+	const char                       *ft_name;
+	/** Linkage into a list of all known operations. */
+	struct c2_list_link               ft_linkage;
+	/** Type of a top level field in fops of this type. */
+	struct c2_fop_field_type         *ft_top;
+	const struct c2_fop_type_ops     *ft_ops;
+	/** Format of this fop's top field. */
+	struct c2_fop_type_format        *ft_fmt;
+	struct c2_fol_rec_type            ft_rec_type;
+	/** State machine for this fop type */
+	struct c2_fom_type                ft_fom_type;
+	/**
+	   ADDB context for events related to this fop type.
+	 */
+	struct c2_addb_ctx                ft_addb;
+};
+
+int  c2_fop_type_build(struct c2_fop_type *fopt);
+void c2_fop_type_fini(struct c2_fop_type *fopt);
+
+int  c2_fop_type_build_nr(struct c2_fop_type **fopt, int nr);
+void c2_fop_type_fini_nr(struct c2_fop_type **fopt, int nr);
 
 /**
    Per-fop environment.
@@ -115,6 +151,18 @@ struct c2_fop_ctx {
 	int                 fc_retval;
 };
 
+/** fop type operations. */
+struct c2_fop_type_ops {
+	/** Create a fom that will carry out operation described by the fop. */
+	int (*fto_fom_init)(struct c2_fop *fop, struct c2_fop_ctx *ctx,
+	                    struct c2_fom **fom);
+	/** XXX temporary entry point for threaded fop execution. */
+	int (*fto_execute) (struct c2_fop *fop, struct c2_fop_ctx *ctx);
+	/** fol record type operations for this fop type, or NULL is standard
+	    operations are to be used. */
+	const struct c2_fol_rec_type_ops  *fto_rec_ops;
+};
+
 /**
     fop storage.
 
@@ -126,51 +174,139 @@ struct c2_fop_data {
 
 /** fop. */
 struct c2_fop {
-	struct c2_fop_type	*f_type;
-        uint64_t                 f_recno;
+	struct c2_fop_type *f_type;
+        uint64_t            f_recno;
 	/** Pointer to the data where fop is serialised or will be
 	    serialised. */
-	struct c2_fop_data	 f_data;
+	struct c2_fop_data  f_data;
 	/**
 	   ADDB context for events related to this fop.
 	 */
-	struct c2_addb_ctx	 f_addb;
-	/**
-	   RPC item for this FOP
-	 */
-	struct c2_rpc_item	 f_item;
-	/** Linkage could be used to have fops in a list. */
-	struct c2_list_link	 f_link;
-	/* A field reserved for upper layers. Generic fop code doesn't
-	   touch it. */
-	void                    *f_private;
+	struct c2_addb_ctx  f_addb;
 };
 
-int            c2_fop_init(struct c2_fop *fop, struct c2_fop_type *fopt,
-					void *data);
-void           c2_fop_fini(struct c2_fop *fop);
 struct c2_fop *c2_fop_alloc(struct c2_fop_type *fopt, void *data);
 void           c2_fop_free(struct c2_fop *fop);
 void          *c2_fop_data(struct c2_fop *fop);
 
-int c2_fop_fol_rec_add(struct c2_fop *fop, struct c2_fol *fol,
-		       struct c2_db_tx *tx);
+/** True iff fop describes an operation that would mutate file system state when
+    executed. */
+bool c2_fop_is_update(const struct c2_fop_type *type);
+/** True iff fop is a batch, i.e., contains other fops. */
+bool c2_fop_is_batch (const struct c2_fop_type *type);
+
+/**
+   General class to which a fop field belongs.
+
+   fop field kinds classify fop fields very broadly.
+ */
+enum c2_fop_field_kind {
+	/**
+	 * A fop field is "builtin" fop sub-system relies on the existence and
+	 * functions of this field. A builtin field might be stored differently
+	 * from other fields. For example, fields used for operation sequencing
+	 * (slot and sequence identifiers) are interpreted by the rpc
+	 * sub-system. To represent such fields uniformly, a special builtin fop
+	 * field is introduced. Another example of built-in field is a field
+	 * containing fop operation code.
+	 */
+	FFK_BUILTIN,
+	/**
+	   A fop field is standard if it belong to a small set of fields that
+	   generic fop code can interpret. Examples of such fields are object,
+	   lock, and other resource identifiers; security signatures, user
+	   identifiers, etc.
+	 */
+	FFK_STANDARD,
+	/**
+	   Fields not belonging to the above kinds fall to this kind.
+	 */
+	FFK_OTHER,
+
+	FFK_NR
+};
+
+/**
+   fop field.
+ */
+struct c2_fop_field {
+	/** Field name. */
+	const char               *ff_name;
+	struct c2_fop_field_type *ff_type;
+	uint32_t                  ff_tag;
+	void                    **ff_decor;
+};
+
+
+enum c2_fop_field_aggr {
+	FFA_RECORD,
+	FFA_UNION,
+	FFA_SEQUENCE,
+	FFA_TYPEDEF,
+	FFA_ATOM,
+	FFA_NR
+};
 
-struct c2_rpc_item *c2_fop_to_rpc_item(struct c2_fop *fop);
-struct c2_fop *c2_rpc_item_to_fop(const struct c2_rpc_item *item);
+enum c2_fop_field_primitive_type {
+	FPF_VOID,
+	FPF_BYTE,
+	FPF_U32,
+	FPF_U64,
 
-/**  Returns a fop type associated with an rpc item type */
-struct c2_fop_type *c2_item_type_to_fop_type
-		   (const struct c2_rpc_item_type *rit);
+	FPF_NR
+};
+
+/**
+   fop field type in a programming language "type" sense.
+ */
+struct c2_fop_field_type {
+	enum c2_fop_field_aggr   fft_aggr;
+	const char              *fft_name;
+	union {
+		struct c2_fop_field_record {
+		} u_record;
+		struct c2_fop_field_union {
+		} u_union;
+		struct c2_fop_field_sequence {
+			uint64_t s_max;
+		} u_sequence;
+		struct c2_fop_field_typedef {
+		} u_typedef;
+		struct c2_fop_field_atom {
+			enum c2_fop_field_primitive_type a_type;
+		} u_atom;
+	} fft_u;
+	/* a fop must be decorated, see any dictionary. */
+	void                   **fft_decor;
+	size_t                   fft_nr;
+	struct c2_fop_field    **fft_child;
+	struct c2_fop_memlayout *fft_layout;
+};
+
+void c2_fop_field_type_fini(struct c2_fop_field_type *t);
+
+extern struct c2_fop_field_type C2_FOP_TYPE_VOID;
+extern struct c2_fop_field_type C2_FOP_TYPE_BYTE;
+extern struct c2_fop_field_type C2_FOP_TYPE_U32;
+extern struct c2_fop_field_type C2_FOP_TYPE_U64;
+
+int c2_fop_fol_rec_add(struct c2_fop *fop, struct c2_fol *fol,
+		       struct c2_db_tx *tx);
 
 /**
-   Default implementation of c2_rpc_item_ops::rio_free() interface, for
-   fops. If fop is not embeded in any other object, then this routine
-   can be set to c2_rpc_item::ri_ops::rio_free().
+   Contents of a given field in a given fop instance.
+
+   @note a fop field can potentially have multiple values in the same fop. For
+   example, an element field in the array field.
  */
-void c2_fop_item_free(struct c2_rpc_item *item);
+struct c2_fop_field_instance {
+	struct c2_fop       *ffi_fop;
+	struct c2_fop_field *ffi_field;
+	void                *ffi_val;
+};
 
-extern const struct c2_rpc_item_ops c2_fop_default_item_ops;
+int  c2_fops_init(void);
+void c2_fops_fini(void);
 
 #include "fop/fop_format.h"
 
diff --git a/fop/fop2c.in b/fop/fop2c.in
index e377797..1155840 100755
--- a/fop/fop2c.in
+++ b/fop/fop2c.in
@@ -13,8 +13,8 @@ verbose=0
 topdir=$(dirname $0)/..
 
 CC=${CC:-"cc"}
-CFLAGS="@CFLAGS@"
-LDFLAGS="@LDFLAGS@ -rdynamic -pthread"
+CFLAGS=${CFLAGS:-"-Wall -Werror -g"}
+LDFLAGS=${LDFLAGS:-"-rdynamic -pthread"}
 DEFINES="-DHAVE_CONFIG"
 INC="-I$topdir -I@DB_SRC@ -I@DB_SRC@/build_unix"
 
@@ -22,8 +22,7 @@ INC="-I$topdir -I@DB_SRC@ -I@DB_SRC@/build_unix"
 # Enumerate all object files and libraries necessary for the binary linked
 # below.
 #
-#OBJS="$topdir/fop/rt/.libs/libc2rt.a @DB_SRC@/build_unix/libdb.a"
-OBJS="$topdir/fop/rt/.libs/libc2rt.a @DB_LIBS@"
+OBJS="$topdir/fop/.libs/libc2rt.a @DB_SRC@/build_unix/libdb.a"
 
 generate_u=0
 generate_k=0
@@ -91,7 +90,7 @@ gen_c()
 #include <assert.h>
 
 #define __layout(x) NULL
-#include "fop/fop_base.h"
+#include "fop/fop.h"
 #include "fop/fop_format_def.h"
 
 enum todo {
@@ -143,7 +142,9 @@ void prefix(void)
 	printf(" */\n");
 	printf("\n");
 	printf("#include \"lib/cdefs.h\"\n");
-	printf("#include \"fop/fop_base.h\"\n");
+	printf("#include \"fop/fop.h\"\n");
+	if (todo == UDEF) 
+		printf("#include <rpc/rpc.h>\n");
 	if (todo == ULAY || todo == KLAY) 
 		printf("#include \"%s\"\n", incl);
 	if (todo == ULAY) 
@@ -218,6 +219,5 @@ done
 
 if [ $verbose -eq 0 ] ;then
     rm -fr $fbase*
-    rm -fr fop2c-$tid*
 fi
 
diff --git a/fop/fop_base.c b/fop/fop_base.c
deleted file mode 100644
index 4c83358..0000000
--- a/fop/fop_base.c
+++ /dev/null
@@ -1,256 +0,0 @@
-/* -*- C -*- */
-
-#include "lib/cdefs.h"  /* C2_EXPORTED */
-#include "lib/memory.h"
-#include "lib/misc.h"   /* C2_SET0 */
-#include "lib/mutex.h"
-#include "lib/vec.h"
-#include "fop/fop_base.h"
-#include "fop/fop_iterator.h"
-
-/**
-   @addtogroup fop
-   @{
- */
-
-int  c2_fop_field_type_prepare  (struct c2_fop_field_type *ftype);
-void c2_fop_field_type_unprepare(struct c2_fop_field_type *ftype);
-
-/*
- * Imported either from fop/fop.c or from fop/rt/stub.c
- */
-int  fop_fol_type_init(struct c2_fop_type *fopt);
-void fop_fol_type_fini(struct c2_fop_type *fopt);
-
-static const struct c2_fol_rec_type_ops c2_fop_fol_default_ops;
-
-const struct c2_addb_ctx_type c2_fop_addb_ctx = {
-	.act_name = "fop"
-};
-
-static const struct c2_addb_ctx_type c2_fop_type_addb_ctx = {
-	.act_name = "fop-type"
-};
-
-static const struct c2_addb_loc c2_fop_addb_loc = {
-	.al_name = "fop"
-};
-
-static struct c2_mutex fop_types_lock;
-static struct c2_tl    fop_types_list;
-
-C2_TL_DESCR_DEFINE(ft, "fop types", static, struct c2_fop_type,
-		   ft_linkage,	ft_magix,
-		   0xba11ab1ea5111dae /* bailable asilidae */,
-		   0xd15ea5e0fed1f1ce /* disease of edifice */);
-
-C2_TL_DEFINE(ft, static, struct c2_fop_type);
-
-/**
-   Used to check that no new fop iterator types are registered once a fop type
-   has been built.
- */
-bool fop_types_built = false;
-
-void c2_fop_field_type_fini(struct c2_fop_field_type *t)
-{
-	size_t i;
-
-	c2_fop_field_type_unprepare(t);
-	if (t->fft_child != NULL) {
-		for (i = 0; i < t->fft_nr; ++i) {
-			if (t->fft_child[i] != NULL)
-				c2_free(t->fft_child[i]);
-		}
-		c2_free(t->fft_child);
-		t->fft_child = NULL;
-	}
-}
-
-void c2_fop_type_fini(struct c2_fop_type *fopt)
-{
-	fop_fol_type_fini(fopt);
-	if (fopt->ft_top != NULL) {
-		c2_mutex_lock(&fop_types_lock);
-		C2_ASSERT(&fopt->ft_rpc_item_type != NULL);
-		c2_rpc_item_type_deregister(&fopt->ft_rpc_item_type);
-		ft_tlink_del_fini(fopt);
-		fopt->ft_magix = 0;
-		c2_mutex_unlock(&fop_types_lock);
-	}
-	if (fopt->ft_fmt != NULL) {
-		c2_fop_type_format_fini(fopt->ft_fmt);
-		fopt->ft_fmt = NULL;
-	}
-	c2_addb_ctx_fini(&fopt->ft_addb);
-}
-
-
-int c2_fop_type_build(struct c2_fop_type *fopt)
-{
-	int                        result;
-	struct c2_fop_type_format *fmt;
-
-	C2_PRE(fopt->ft_top == NULL);
-
-	fmt    = fopt->ft_fmt;
-	result = c2_fop_type_format_parse(fmt);
-	if (result == 0) {
-		result = fop_fol_type_init(fopt);
-		if (result == 0) {
-			fopt->ft_top = fmt->ftf_out;
-			result =
-			c2_rpc_item_type_register(&fopt->ft_rpc_item_type);
-			c2_addb_ctx_init(&fopt->ft_addb,
-					 &c2_fop_type_addb_ctx,
-					 &c2_addb_global_ctx);
-			c2_mutex_lock(&fop_types_lock);
-			ft_tlink_init_at(fopt, &fop_types_list);
-			c2_mutex_unlock(&fop_types_lock);
-		}
-		if (result != 0)
-			c2_fop_type_fini(fopt);
-	}
-	fop_types_built = true;
-	return result;
-}
-
-int c2_fop_type_build_nr(struct c2_fop_type **fopt, int nr)
-{
-	int i;
-	int result;
-
-	for (result = 0, i = 0; i < nr; ++i) {
-		result = c2_fop_type_build(fopt[i]);
-		if (result != 0) {
-			c2_fop_type_fini_nr(fopt, i);
-			break;
-		}
-	}
-	return result;
-}
-C2_EXPORTED(c2_fop_type_build_nr);
-
-struct c2_fop_type *c2_fop_type_next(struct c2_fop_type *ftype)
-{
-	struct c2_fop_type *rtype;
-
-	c2_mutex_lock(&fop_types_lock);
-	if (ftype == NULL) {
-		/* Returns head of fop_types_list*/
-		rtype = ft_tlist_head(&fop_types_list);
-	} else {
-		/* Returns Next from fop_types_list*/
-		rtype = ft_tlist_next(&fop_types_list, ftype);
-	}
-	c2_mutex_unlock(&fop_types_lock);
-	return rtype;
-}
-
-void c2_fop_type_fini_nr(struct c2_fop_type **fopt, int nr)
-{
-	int i;
-
-	for (i = 0; i < nr; ++i)
-		c2_fop_type_fini(fopt[i]);
-}
-C2_EXPORTED(c2_fop_type_fini_nr);
-
-struct c2_fop_memlayout atom_void_memlayout = {
-	.fm_uxdr   = (xdrproc_t)xdr_void,
-	.fm_sizeof = 0
-};
-
-struct c2_fop_field_type C2_FOP_TYPE_VOID = {
-	.fft_aggr = FFA_ATOM,
-	.fft_name = "void",
-	.fft_u = {
-		.u_atom = {
-			.a_type = FPF_VOID
-		}
-	},
-	.fft_layout = &atom_void_memlayout
-};
-
-struct c2_fop_memlayout atom_byte_memlayout = {
-	.fm_uxdr   = (xdrproc_t)xdr_char,
-	.fm_sizeof = 1
-};
-
-struct c2_fop_field_type C2_FOP_TYPE_BYTE = {
-	.fft_aggr = FFA_ATOM,
-	.fft_name = "byte",
-	.fft_u = {
-		.u_atom = {
-			.a_type = FPF_BYTE
-		}
-	},
-	.fft_layout = &atom_byte_memlayout
-};
-
-struct c2_fop_memlayout atom_u32_memlayout = {
-	.fm_uxdr   = (xdrproc_t)xdr_uint32_t,
-	.fm_sizeof = 4
-};
-
-struct c2_fop_field_type C2_FOP_TYPE_U32 = {
-	.fft_aggr = FFA_ATOM,
-	.fft_name = "u32",
-	.fft_u = {
-		.u_atom = {
-			.a_type = FPF_U32
-		}
-	},
-	.fft_layout = &atom_u32_memlayout
-};
-
-struct c2_fop_memlayout atom_u64_memlayout = {
-	.fm_uxdr   = (xdrproc_t)xdr_uint64_t,
-	.fm_sizeof = 8
-};
-
-struct c2_fop_field_type C2_FOP_TYPE_U64 = {
-	.fft_aggr = FFA_ATOM,
-	.fft_name = "u64",
-	.fft_u = {
-		.u_atom = {
-			.a_type = FPF_U64
-		}
-	},
-	.fft_layout = &atom_u64_memlayout
-};
-
-int c2_fops_init(void)
-{
-	ft_tlist_init(&fop_types_list);
-	c2_mutex_init(&fop_types_lock);
-	c2_fits_init();
-	c2_fop_field_type_prepare(&C2_FOP_TYPE_VOID);
-	c2_fop_field_type_prepare(&C2_FOP_TYPE_BYTE);
-	c2_fop_field_type_prepare(&C2_FOP_TYPE_U32);
-	c2_fop_field_type_prepare(&C2_FOP_TYPE_U64);
-	return 0;
-}
-
-void c2_fops_fini(void)
-{
-	c2_fop_field_type_unprepare(&C2_FOP_TYPE_U64);
-	c2_fop_field_type_unprepare(&C2_FOP_TYPE_U32);
-	c2_fop_field_type_unprepare(&C2_FOP_TYPE_BYTE);
-	c2_fop_field_type_unprepare(&C2_FOP_TYPE_VOID);
-	c2_fits_fini();
-	c2_mutex_fini(&fop_types_lock);
-	ft_tlist_fini(&fop_types_list);
-}
-
-/** @} end of fop group */
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
diff --git a/fop/fop_base.h b/fop/fop_base.h
deleted file mode 100644
index 51fc7ba..0000000
--- a/fop/fop_base.h
+++ /dev/null
@@ -1,253 +0,0 @@
-/* -*- C -*- */
-
-#ifndef __COLIBRI_FOP_FOP_BASE_H__
-#define __COLIBRI_FOP_FOP_BASE_H__
-
-#include "lib/types.h"
-#include "lib/cdefs.h"
-#include "lib/tlist.h"
-#include "lib/vec.h"
-#include "addb/addb.h"
-#include "fol/fol.h"
-#include "fop/fom.h"
-#include "lib/vec.h"
-#include "rpc/rpc_base.h"
-
-/**
-   @addtogroup fop
-
-   This file contains "basic" fop definitions which are independent of
-   networking and store interfaces. The reason for this split is to break
-   circular dependency that otherwise forms due to usage of fop formats by the
-   networking and store code.
-
-   Technically, this file contains the part of the fop interface necessary to
-   build libc2rt library used by the fop2c-produced code. Some parts of the
-   interface are too difficult to disentangle properly. For them, fake
-   definitions are provided in fop/rt/stub.c. These definitions are used to
-   build libc2rt.
-
-   @{
- */
-
-/* import */
-struct c2_fol;
-struct c2_fop;
-struct c2_fop_io_vec;
-
-/* export */
-struct c2_fop_type;
-struct c2_fop_type_ops;
-struct c2_fop_field;
-struct c2_fop_field_type;
-struct c2_fop_memlayout;
-struct c2_fop_type_format;
-
-typedef uint32_t c2_fop_type_code_t;
-
-/**
-   Type of a file system operation.
-
-   There is an instance of c2_fop_type for "make directory" command, an instance
-   for "write", "truncate", etc.
- */
-struct c2_fop_type {
-	/** Operation name. */
-	const char                       *ft_name;
-	/** Linkage into a list of all known operations. */
-	struct c2_tlink                   ft_linkage;
-	/** Type of a top level field in fops of this type. */
-	struct c2_fop_field_type         *ft_top;
-	const struct c2_fop_type_ops     *ft_ops;
-	/** Format of this fop's top field. */
-	struct c2_fop_type_format        *ft_fmt;
-	struct c2_fol_rec_type            ft_rec_type;
-	/** State machine for this fop type */
-	struct c2_fom_type                ft_fom_type;
-	/** The rpc_item_type associated with rpc_item
-	    embedded with this fop. */
-	struct c2_rpc_item_type		  ft_rpc_item_type;
-	/**
-	   ADDB context for events related to this fop type.
-	 */
-	struct c2_addb_ctx                ft_addb;
-	uint64_t                          ft_magix;
-};
-
-/**
-    Iterates through the registered fop types.
-
-    To iterate across all registered fop types, first call this function with
-    NULL parameter. NULL is returned to indicate end of the iteration.
-
-    If a fop type is registered or unregistered while an iteration is in
-    progress, behaviour is undefined.
-
-    @code
-    ftype = NULL;
-    while ((ftype = c2_fop_type_next(ftype)) != NULL) {
-            do something with ftype
-    }
-    @endcode
- */
-struct c2_fop_type *c2_fop_type_next(struct c2_fop_type *ftype);
-int  c2_fop_type_build(struct c2_fop_type *fopt);
-void c2_fop_type_fini(struct c2_fop_type *fopt);
-
-int  c2_fop_type_build_nr(struct c2_fop_type **fopt, int nr);
-void c2_fop_type_fini_nr(struct c2_fop_type **fopt, int nr);
-
-struct c2_list;
-
-/** fop type operations. */
-struct c2_fop_type_ops {
-	/** XXX temporary entry point for threaded fop execution. */
-	int (*fto_execute) (struct c2_fop *fop, struct c2_fop_ctx *ctx);
-	/** fol record type operations for this fop type, or NULL is standard
-	    operations are to be used. */
-	const struct c2_fol_rec_type_ops  *fto_rec_ops;
-	/** Action to be taken on receiving reply of a fop. */
-	void (*fto_fop_replied)(struct c2_fop *fop);
-	/** Return the size of fop object. */
-	size_t (*fto_size_get)(struct c2_fop *fop);
-	/** Return if given fops are of same type or not. */
-	bool (*fto_op_equal)(const struct c2_fop *fop1,
-			const struct c2_fop *fop2);
-	/** Return if given fops refer to same fid or not. */
-	bool (*fto_fid_equal)(struct c2_fop *fop1, struct c2_fop *fop2);
-	/** Return the number of IO fragements in the IO vector. */
-	uint64_t (*fto_get_nfragments)(struct c2_fop *fop);
-	/** Try to coalesce multiple fops into one. */
-	int (*fto_io_coalesce)(const struct c2_list *list, struct c2_fop *fop,
-			struct c2_fop *bkpfop);
-	/** Restore the original IO vector of resultant IO fop on
-	    completion of IO request. */
-	void (*fto_iovec_restore)(struct c2_fop *fop, struct c2_fop *bkpfop);
-};
-
-/**
-   General class to which a fop field belongs.
-
-   fop field kinds classify fop fields very broadly.
- */
-enum c2_fop_field_kind {
-	/**
-	 * A fop field is "builtin" fop sub-system relies on the existence and
-	 * functions of this field. A builtin field might be stored differently
-	 * from other fields. For example, fields used for operation sequencing
-	 * (slot and sequence identifiers) are interpreted by the rpc
-	 * sub-system. To represent such fields uniformly, a special builtin fop
-	 * field is introduced. Another example of built-in field is a field
-	 * containing fop operation code.
-	 */
-	FFK_BUILTIN,
-	/**
-	   A fop field is standard if it belong to a small set of fields that
-	   generic fop code can interpret. Examples of such fields are object,
-	   lock, and other resource identifiers; security signatures, user
-	   identifiers, etc.
-	 */
-	FFK_STANDARD,
-	/**
-	   Fields not belonging to the above kinds fall to this kind.
-	 */
-	FFK_OTHER,
-
-	FFK_NR
-};
-
-/**
-   fop field.
- */
-struct c2_fop_field {
-	/** Field name. */
-	const char               *ff_name;
-	struct c2_fop_field_type *ff_type;
-	uint32_t                  ff_tag;
-	void                    **ff_decor;
-};
-
-
-enum c2_fop_field_aggr {
-	FFA_RECORD,
-	FFA_UNION,
-	FFA_SEQUENCE,
-	FFA_TYPEDEF,
-	FFA_ATOM,
-	FFA_NR
-};
-
-enum c2_fop_field_primitive_type {
-	FPF_VOID,
-	FPF_BYTE,
-	FPF_U32,
-	FPF_U64,
-
-	FPF_NR
-};
-
-/**
-   fop field type in a programming language "type" sense.
- */
-struct c2_fop_field_type {
-	enum c2_fop_field_aggr   fft_aggr;
-	const char              *fft_name;
-	union {
-		struct c2_fop_field_record {
-		} u_record;
-		struct c2_fop_field_union {
-		} u_union;
-		struct c2_fop_field_sequence {
-			uint64_t s_max;
-		} u_sequence;
-		struct c2_fop_field_typedef {
-		} u_typedef;
-		struct c2_fop_field_atom {
-			enum c2_fop_field_primitive_type a_type;
-		} u_atom;
-	} fft_u;
-	/* a fop must be decorated, see any dictionary. */
-	void                   **fft_decor;
-	size_t                   fft_nr;
-	struct c2_fop_field    **fft_child;
-	struct c2_fop_memlayout *fft_layout;
-};
-
-void c2_fop_field_type_fini(struct c2_fop_field_type *t);
-
-extern struct c2_fop_field_type C2_FOP_TYPE_VOID;
-extern struct c2_fop_field_type C2_FOP_TYPE_BYTE;
-extern struct c2_fop_field_type C2_FOP_TYPE_U32;
-extern struct c2_fop_field_type C2_FOP_TYPE_U64;
-
-/**
-   Contents of a given field in a given fop instance.
-
-   @note a fop field can potentially have multiple values in the same fop. For
-   example, an element field in the array field.
- */
-struct c2_fop_field_instance {
-	struct c2_fop       *ffi_fop;
-	struct c2_fop_field *ffi_field;
-	void                *ffi_val;
-};
-
-int  c2_fops_init(void);
-void c2_fops_fini(void);
-
-#include "fop/fop_format.h"
-
-/** @} end of fop group */
-
-/* __COLIBRI_FOP_FOP_BASE_H__ */
-#endif
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
diff --git a/fop/fop_format.c b/fop/fop_format.c
index f11d33d..4ec7636 100644
--- a/fop/fop_format.c
+++ b/fop/fop_format.c
@@ -23,7 +23,7 @@
 #include "lib/assert.h"
 #include "lib/memory.h"
 
-#include "fop/fop_base.h"
+#include "fop/fop.h"
 #include "fop/fop_iterator.h"
 
 /**
@@ -68,6 +68,7 @@ void c2_fop_field_type_unprepare(struct c2_fop_field_type *ftype)
 		field->ff_decor = NULL;
 	}
 }
+C2_EXPORTED(c2_fop_field_type_unprepare);
 
 int c2_fop_field_type_prepare(struct c2_fop_field_type *ftype)
 {
@@ -98,6 +99,7 @@ int c2_fop_field_type_prepare(struct c2_fop_field_type *ftype)
 		c2_fop_field_type_unprepare(ftype);
 	return result;
 }
+C2_EXPORTED(c2_fop_field_type_prepare);
 
 int c2_fop_type_format_parse(struct c2_fop_type_format *fmt)
 {
@@ -183,6 +185,7 @@ int c2_fop_type_format_parse(struct c2_fop_type_format *fmt)
 		c2_fop_type_format_fini(fmt);
 	return result;
 }
+C2_EXPORTED(c2_fop_type_format_parse);
 
 void *c2_fop_type_decoration_get(const struct c2_fop_field_type *ftype,
 				 const struct c2_fop_decorator *dec)
@@ -230,6 +233,7 @@ void c2_fop_type_format_fini(struct c2_fop_type_format *fmt)
 		fmt->ftf_out = NULL;
 	}
 }
+C2_EXPORTED(c2_fop_type_format_fini);
 
 int c2_fop_type_format_parse_nr(struct c2_fop_type_format **fmt, int nr)
 {
@@ -254,6 +258,7 @@ void c2_fop_type_format_fini_nr(struct c2_fop_type_format **fmt, int nr)
 	for (i = 0; i < nr; ++i)
 		c2_fop_type_format_fini(fmt[i]);
 }
+C2_EXPORTED(c2_fop_type_format_fini_nr);
 
 void *c2_fop_type_field_addr(const struct c2_fop_field_type *ftype, void *obj,
 			     int fileno, uint32_t elno)
@@ -267,6 +272,7 @@ void *c2_fop_type_field_addr(const struct c2_fop_field_type *ftype, void *obj,
 			ftype->fft_child[1]->ff_type->fft_layout->fm_sizeof;
 	return addr;
 }
+C2_EXPORTED(c2_fop_type_field_addr);
 
 struct c2_fop_field *
 c2_fop_type_field_find(const struct c2_fop_field_type *ftype, const char *fname)
@@ -279,6 +285,7 @@ c2_fop_type_field_find(const struct c2_fop_field_type *ftype, const char *fname)
 	}
 	return NULL;
 }
+C2_EXPORTED(c2_fop_type_field_find);
 
 const struct c2_fop_type_format C2_FOP_TYPE_FORMAT_VOID_tfmt = {
 	.ftf_out   = &C2_FOP_TYPE_VOID,
@@ -287,6 +294,7 @@ const struct c2_fop_type_format C2_FOP_TYPE_FORMAT_VOID_tfmt = {
 	.ftf_val   = FPF_VOID,
 	.ftf_child = { [0] = { .c_name = NULL } }
 };
+C2_EXPORTED(C2_FOP_TYPE_FORMAT_VOID_tfmt);
 
 const struct c2_fop_type_format C2_FOP_TYPE_FORMAT_BYTE_tfmt = {
 	.ftf_out   = &C2_FOP_TYPE_BYTE,
@@ -295,6 +303,7 @@ const struct c2_fop_type_format C2_FOP_TYPE_FORMAT_BYTE_tfmt = {
 	.ftf_val   = FPF_BYTE,
 	.ftf_child = { [0] = { .c_name = NULL } }
 };
+C2_EXPORTED(C2_FOP_TYPE_FORMAT_BYTE_tfmt);
 
 const struct c2_fop_type_format C2_FOP_TYPE_FORMAT_U32_tfmt = {
 	.ftf_out   = &C2_FOP_TYPE_U32,
diff --git a/fop/fop_format.h b/fop/fop_format.h
index e49578e..cd5ca52 100644
--- a/fop/fop_format.h
+++ b/fop/fop_format.h
@@ -79,8 +79,6 @@
 # include "linux_kernel/fop_kernel.h"
 #endif
 
-extern const struct c2_rpc_item_type_ops c2_rpc_fop_default_item_type_ops;
-
 struct c2_fop_memlayout;
 
 struct c2_fop_type_format {
@@ -204,21 +202,14 @@ struct c2_fop_memlayout {
 	} fm_child[];
 };
 
-#define C2_FOP_TYPE_DECLARE_OPS(fopt, name, ops, opcode, itflags, itops) \
-struct c2_fop_type fopt ## _fopt = {					\
-	.ft_name = name,						\
-	.ft_fmt  = &__paste(fopt),					\
-	.ft_ops  = (ops),						\
-	.ft_rpc_item_type = {						\
-		.rit_opcode = (opcode),					\
-		.rit_flags  = (itflags),				\
-		.rit_ops    = (itops)					\
-	}								\
-};
-
-#define C2_FOP_TYPE_DECLARE(fopt, name, ops, opcode, itflags)		\
-        C2_FOP_TYPE_DECLARE_OPS(fopt, name, ops, opcode, itflags,	\
-				&c2_rpc_fop_default_item_type_ops)
+#define C2_FOP_TYPE_DECLARE(fopt, name, opcode, ops)	\
+struct c2_fop_type fopt ## _fopt = {			\
+	.ft_code = (opcode),				\
+	.ft_name = name,				\
+	.ft_fmt  = &__paste(fopt),			\
+	.ft_ops  = (ops)				\
+};							\
+C2_EXPORTED(fopt ## _fopt)
 
 /** @} end of fop group */
 
diff --git a/fop/fop_format_c.c b/fop/fop_format_c.c
index b450a16..61864fb 100644
--- a/fop/fop_format_c.c
+++ b/fop/fop_format_c.c
@@ -21,7 +21,7 @@
 #include <stdio.h>
 #include <stdlib.h> /* free(3) */
 
-#include "fop/fop_base.h"
+#include "fop/fop.h"
 #include "lib/memory.h"
 #include "lib/assert.h"
 
@@ -172,7 +172,7 @@ static void type_decorate(struct c2_fop_field_type *ftype)
 		fdec = TD(f->ff_type);
 
 		ASPRINTF(&fd->fd_fmt, "%-20s %s", fdec->d_type, f->ff_name);
-		ASPRINTF(&fd->fd_fmt_ptr, "%-19s *%s",
+		ASPRINTF(&fd->fd_fmt_ptr, "%-19s *%s", 
 			 fdec->d_type, f->ff_name);
 		dec->d_varsize |= fdec->d_varsize;
 
@@ -215,8 +215,10 @@ static void memlayout(struct c2_fop_field_type *ftype, const char *where)
 	printf("\t.fm_child = {\n");
 	for (i = 0; i < ftype->fft_nr; ++i) {
 		struct c2_fop_field *f;
+		struct c_fop_field_decor *fd;
 
 		f  = ftype->fft_child[i];
+		fd = FD(f);
 		printf("\t\t{ ");
 		if (f->ff_name[0] != 0)
 			printf("offsetof(%s, %s%s)", TD(ftype)->d_type,
@@ -228,7 +230,7 @@ static void memlayout(struct c2_fop_field_type *ftype, const char *where)
 	printf("\t}\n};\n\n");
 }
 
-static void body_cdef(struct c2_fop_field_type *ftype,
+static void body_cdef(struct c2_fop_field_type *ftype, 
 		      int start, int indent, bool tags, int ptr)
 {
 	static const char         ruler[] = "\t\t\t\t\t\t\t\t\t\t\t\t\t";
@@ -237,7 +239,7 @@ static void body_cdef(struct c2_fop_field_type *ftype,
 
 	for (i = start; i < ftype->fft_nr; ++i) {
 		fd = FD(ftype->fft_child[i]);
-		printf("%*.*s%s;", indent, indent, ruler,
+		printf("%*.*s%s;", indent, indent, ruler, 
 		       i == ptr ? fd->fd_fmt_ptr : fd->fd_fmt);
 		if (tags)
 			printf("\t/* case %i */", ftype->fft_child[i]->ff_tag);
@@ -247,7 +249,7 @@ static void body_cdef(struct c2_fop_field_type *ftype,
 
 static void union_cdef(struct c2_fop_field_type *ftype)
 {
-	printf("%s {\n\t%s;\n\tunion {\n", TD(ftype)->d_type,
+	printf("%s {\n\t%s;\n\tunion {\n", TD(ftype)->d_type, 
 	       FD(ftype->fft_child[0])->fd_fmt);
 	body_cdef(ftype, 1, 2, true, -1);
 	printf("\t} u;\n};\n\n");
@@ -291,7 +293,7 @@ static void sequence_kdef(struct c2_fop_field_type *ftype)
 	printf("%s {\n\tuint32_t %s;\n",
 	       td->d_type, ftype->fft_child[0]->ff_name);
 	if (td->d_kanbelast) {
-		printf("\tuint32_t %s;\n\tstruct page **%s;",
+		printf("\tuint32_t %s;\n\tstruct page **%s;", 
 		       td->u.d_sequence.d_pgoff, ftype->fft_child[1]->ff_name);
 	} else
 		printf("\t%s;", fd->fd_fmt_ptr);
@@ -329,7 +331,7 @@ int c2_fop_comp_kdef(struct c2_fop_field_type *ftype)
 {
 	type_decorate(ftype);
 	kdef_ops[ftype->fft_aggr].op(ftype);
-	printf("extern struct c2_fop_memlayout %s_memlayout;\n\n",
+	printf("extern struct c2_fop_memlayout %s_memlayout;\n\n", 
 	       ftype->fft_name);
 	return 0;
 }
@@ -366,7 +368,7 @@ void c2_fop_comp_fini(void)
 
 /** @} end of fop group */
 
-/*
+/* 
  *  Local variables:
  *  c-indentation-style: "K&R"
  *  c-basic-offset: 8
diff --git a/fop/fop_format_def.h b/fop/fop_format_def.h
index 973fa41..0876264 100644
--- a/fop/fop_format_def.h
+++ b/fop/fop_format_def.h
@@ -22,7 +22,7 @@
 #define __COLIBRI_FOP_FOP_FORMAT_DEF_H__
 
 /**
-   @addtogroup fop
+   @addtogroup fop 
 
    @{
 */
@@ -52,7 +52,7 @@
 /* __COLIBRI_FOP_FOP_FORMAT_DEF_H__ */
 #endif
 
-/*
+/* 
  *  Local variables:
  *  c-indentation-style: "K&R"
  *  c-basic-offset: 8
diff --git a/fop/fop_item_type.c b/fop/fop_item_type.c
deleted file mode 100644
index 29cc286..0000000
--- a/fop/fop_item_type.c
+++ /dev/null
@@ -1,108 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Subhash Arya <subhash_arya@xyratex.com>
- * Original creation date: 11/18/2011
- */
-
-#include "lib/errno.h"
-#include "rpc/rpc_onwire.h"
-#include "xcode/bufvec_xcode.h"
-
-
-struct c2_rpc_item;
-struct c2_fop;
-struct c2_rpc_item_type;
-struct c2_bufvec_cur;
-
-size_t c2_fop_item_type_default_onwire_size(const struct c2_rpc_item *item)
-{
-	size_t		 len;
-	struct c2_fop	*fop;
-
-	C2_PRE(item != NULL);
-
-	fop = c2_rpc_item_to_fop(item);
-	C2_ASSERT(fop != NULL);
-	C2_ASSERT(fop->f_type != NULL);
-	C2_ASSERT(fop->f_type->ft_ops != NULL);
-	C2_ASSERT(fop->f_type->ft_ops->fto_size_get != NULL);
-	len = fop->f_type->ft_ops->fto_size_get(fop);
-	len += ITEM_ONWIRE_HEADER_SIZE;
-	return len;
-}
-
-int c2_fop_item_type_default_encode(struct c2_rpc_item_type *item_type,
-			      struct c2_rpc_item *item,
-			      struct c2_bufvec_cursor *cur)
-{
-	int			rc;
-	uint32_t		opcode;
-
-	C2_PRE(item != NULL);
-	C2_PRE(cur != NULL);
-
-	item_type = item->ri_type;
-	opcode = item_type->rit_opcode;
-	rc = c2_bufvec_uint32(cur, &opcode, C2_BUFVEC_ENCODE);
-	if(rc != 0)
-		return -EFAULT;
-	rc = item_encdec(cur, item, C2_BUFVEC_ENCODE);
-	return rc;
-}
-
-int c2_fop_item_type_default_decode(struct c2_rpc_item_type *item_type,
-			      struct c2_rpc_item **item,
-			      struct c2_bufvec_cursor *cur)
-{
-	int			 rc;
-	struct c2_fop		*fop;
-	struct c2_fop_type	*ftype;
-
-	C2_PRE(item != NULL);
-	C2_PRE(cur != NULL);
-
-	ftype = c2_item_type_to_fop_type(item_type);
-	C2_ASSERT(ftype != NULL);
-	fop = c2_fop_alloc(ftype, NULL);
-	if (fop == NULL)
-		return -ENOMEM;
-	*item = c2_fop_to_rpc_item(fop);
-	C2_ASSERT(*item != NULL);
-	rc = item_encdec(cur, *item, C2_BUFVEC_DECODE);
-	if (rc != 0)
-		c2_fop_free(fop);
-
-	return rc;
-}
-
-/** Default rpc item type ops for fop item types */
-const struct c2_rpc_item_type_ops c2_rpc_fop_default_item_type_ops = {
-	.rito_encode = c2_fop_item_type_default_encode,
-	.rito_decode = c2_fop_item_type_default_decode,
-	.rito_item_size = c2_fop_item_type_default_onwire_size,
-};
-C2_EXPORTED(c2_rpc_fop_default_item_type_ops);
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 79
- *  scroll-step: 1
- *  End:
- */
diff --git a/fop/fop_item_type.h b/fop/fop_item_type.h
deleted file mode 100644
index fb9849e..0000000
--- a/fop/fop_item_type.h
+++ /dev/null
@@ -1,81 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Subhash Arya <subhash_arya@xyratex.com>
- * Original creation date: 11/18/2011
- */
-
-#ifndef __COLIBRI_FOP_FOP_ONWIRE_H__
-#define __COLIBRI_FOP_FOP_ONWIRE_H__
-
-#include "xcode/bufvec_xcode.h"
-
-/**
-   @addtogroup fop
-
-   This file contains definitions for encoding/decoding a fop type rpc item
-   onto a bufvec.
-	@see rpc/rpc_onwire.h
-   @{
- */
-/**
-   Generic bufvec serialization routine for a fop rpc item type.
-   @param item_type Pointer to the item type struct for the item.
-   @param item  pointer to the item which is to be serialized.
-   @param cur current position of the cursor in the bufvec.
-   @retval 0 On success.
-   @retval -errno On failure.
-*/
-int c2_fop_item_type_default_encode(struct c2_rpc_item_type *item_type,
-			      struct c2_rpc_item *item,
-			      struct c2_bufvec_cursor *cur);
-
-/**
-   Generic deserialization routine for a fop rpc item type. Allocates a new rpc
-   item and decodes the header and the payload into this item.
-   @param item_type Pointer to the item type struct for the item.
-   @param item Pointer to the item containing deserialized rpc onwire data and
-   payload.
-   @param cur current position of the cursor in the bufvec.
-   @retval 0 On success.
-   @retval -errno if failure.
-*/
-int c2_fop_item_type_default_decode(struct c2_rpc_item_type *item_type,
-			      struct c2_rpc_item **item,
-			      struct c2_bufvec_cursor *cur);
-
-/**
-   Return the onwire size of the item type which is a fop in bytes.
-   The onwire size of an item equals = size of (header + payload).
-   @param item The rpc item for which the on wire size is to be calculated
-   @retval Size of the item in bytes.
-*/
-size_t c2_fop_item_type_default_onwire_size(const struct c2_rpc_item *item);
-
-/** @} end of fop group */
-
-/* __COLIBRI_FOP_FOP_ONWIRE_H__ */
-#endif
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
diff --git a/fop/fop_iterator.c b/fop/fop_iterator.c
index 2765293..9f9b85f 100644
--- a/fop/fop_iterator.c
+++ b/fop/fop_iterator.c
@@ -24,7 +24,6 @@
 #include "lib/misc.h"                /* C2_SET0 */
 #include "lib/cdefs.h"               /* C2_EXPORTED */
 #include "fid/fid.h"
-#include "fop/fop.h"
 #include "fop/fop_iterator.h"
 
 /**
@@ -70,18 +69,6 @@ enum {
 	FIT_TYPE_MAX = 16
 };
 
-C2_TL_DESCR_DEFINE(wat, "fop iterator watches", static, struct c2_fit_watch,
-		   fif_linkage,	fif_magix,
-		   0x10d15edc0a1f1e1d /* iodised coalfield */,
-		   0xcea5e1e55debac1e /* ceaseless debacle */);
-C2_TL_DEFINE(wat, static, struct c2_fit_watch);
-
-C2_TL_DESCR_DEFINE(mod, "fop iterator modifiers", static, struct c2_fit_mod,
-		   fm_linkage,	fm_magix,
-		   0xbe111c05ec0d1c11 /* bellicose codicil */,
-		   0x5ca1ab1e5caff01d /* scalable scaffold */);
-C2_TL_DEFINE(mod, static, struct c2_fit_mod);
-
 /**
    Per-field data kept for each fop iterator type.
 
@@ -209,7 +196,7 @@ void c2_fop_itype_init(struct c2_fit_type *itype)
 	C2_PRE(itype->fit_index == -1);
 	C2_PRE(!fop_types_built);
 
-	wat_tlist_init(&itype->fit_watch);
+	c2_list_init(&itype->fit_watch);
 
 	/*
 	 * Search for a free slot in fits[] array and install itype there.
@@ -224,6 +211,7 @@ void c2_fop_itype_init(struct c2_fit_type *itype)
 	}
 	C2_ASSERT(IS_IN_ARRAY(i, fits));
 }
+C2_EXPORTED(c2_fop_itype_init);
 
 void c2_fop_itype_fini(struct c2_fit_type *itype)
 {
@@ -231,26 +219,29 @@ void c2_fop_itype_fini(struct c2_fit_type *itype)
 
 	fits[itype->fit_index] = NULL;
 	itype->fit_index = -1;
-	wat_tlist_fini(&itype->fit_watch);
+	c2_list_fini(&itype->fit_watch);
 }
+C2_EXPORTED(c2_fop_itype_fini);
 
 void c2_fop_itype_watch_add(struct c2_fit_type *itype,
 			    struct c2_fit_watch *watch)
 {
 	struct c2_fit_watch *scan;
 
-	c2_tlist_for(&wat_tl, &itype->fit_watch, scan) {
+	c2_list_for_each_entry(&itype->fit_watch, scan, struct c2_fit_watch,
+			       fif_linkage)
 		C2_PRE(scan->fif_field != watch->fif_field);
-	} c2_tlist_endfor;
 
-	wat_tlink_init_at(watch, &itype->fit_watch);
-	mod_tlist_init(&watch->fif_mod);
+	c2_list_add(&itype->fit_watch, &watch->fif_linkage);
+	c2_list_init(&watch->fif_mod);
 }
+C2_EXPORTED(c2_fop_itype_watch_add);
 
 void c2_fop_itype_mod_add(struct c2_fit_watch *watch, struct c2_fit_mod *mod)
 {
-	mod_tlink_init_at(mod, &watch->fif_mod);
+	c2_list_add(&watch->fif_mod, &mod->fm_linkage);
 }
+C2_EXPORTED(c2_fop_itype_mod_add);
 
 int c2_fit_field_add(struct c2_fit_watch *watch,
 		     struct c2_fop_type *ftype, const char *fname,
@@ -275,6 +266,7 @@ int c2_fit_field_add(struct c2_fit_watch *watch,
 		result = -ENOENT;
 	return result;
 }
+C2_EXPORTED(c2_fit_field_add);
 
 static bool c2_fit_invariant(const struct c2_fit *it)
 {
@@ -321,12 +313,14 @@ void c2_fit_init(struct c2_fit *it, struct c2_fit_type *itype,
 	it->fi_fop              = fop;
 	it->fi_stack[0].ff_type = fop->f_type->ft_top;
 }
+C2_EXPORTED(c2_fit_init);
 
 void c2_fit_fini(struct c2_fit *it)
 {
 	/* nothing to do even if the cursor is destroyed before iteration loop
 	   is over. */
 }
+C2_EXPORTED(c2_fit_fini);
 
 int c2_fit_yield(struct c2_fit *it, struct c2_fit_yield *yield)
 {
@@ -466,6 +460,7 @@ int c2_fit_yield(struct c2_fit *it, struct c2_fit_yield *yield)
 		return +1;
 	}
 }
+C2_EXPORTED(c2_fit_yield);
 
 /**
    Destructor for fop iterator decorator.
@@ -492,28 +487,27 @@ static struct c2_fop_decorator fit_dec = {
    Additionally, if the field is watched, populate "bits" with the corresponding
    cumulative watch-bits.
  */
-static bool has_watches(struct c2_fit_type *itype,
+static bool has_watches(const struct c2_fit_type *itype,
 			const struct c2_fop_field *child, uint64_t *bits)
 {
 	struct c2_fit_watch *watch;
 	struct c2_fit_mod   *mod;
 
-	if (strcmp(itype->fit_name, "fop-all-object") == 0)
-                return true;
-
 	*bits = 0;
-	c2_tlist_for(&wat_tl, &itype->fit_watch, watch) {
+	c2_list_for_each_entry(&itype->fit_watch, watch,
+			       struct c2_fit_watch, fif_linkage) {
 		if (watch->fif_field == child->ff_type) {
 			*bits = watch->fif_bits;
-			c2_tlist_for(&mod_tl, &watch->fif_mod, mod) {
+			c2_list_for_each_entry(&watch->fif_mod, mod,
+					       struct c2_fit_mod, fm_linkage) {
 				if (mod->fm_field == child) {
 					*bits |= mod->fm_bits_add;
 					*bits &= ~mod->fm_bits_sub;
 				}
-			} c2_tlist_endfor;
+			}
 			return true;
 		}
-	} c2_tlist_endfor;
+	}
 	return false;
 }
 
@@ -535,15 +529,11 @@ int c2_fop_field_type_fit(struct c2_fop_field_type *fieldt)
 	data->ff_nr = fieldt->fft_nr;
 	for (t = 0; t < ARRAY_SIZE(data->ff_present); ++t) {
 		struct c2_fit_type *itype;
-                bool all_watches = false;
 
 		itype = fits[t];
 		if (itype == NULL)
 			continue;
 
-                if (strcmp(itype->fit_name, "fop-all-object") == 0)
-                        all_watches = true;
-
 		C2_ALLOC_ARR(data->ff_present[t], data->ff_nr + 1);
 		if (data->ff_present[t] == NULL)
 			return -ENOMEM;
@@ -574,7 +564,7 @@ int c2_fop_field_type_fit(struct c2_fop_field_type *fieldt)
 			/*
 			 * If any sub-field is watched...
 			 */
-			if (!all_watches && child_data != NULL &&
+			if (child_data != NULL &&
 			    child_data->ff_present[t][0].ffd_valid) {
 				/* ... the field itself isn't. */
 				C2_ASSERT(!el->ffd_valid);
@@ -703,14 +693,6 @@ static struct c2_fit_watch fop_object_watch = {
 	.fif_bits = 0
 };
 
-/*
- * Special FOP Iterator
- */
-static struct c2_fit_type fop_all_object_itype = {
-        .fit_name  = "fop-all-object",
-        .fit_index = -1
-};
-
 void c2_fop_object_init(const struct c2_fop_type_format *fid_fop_type)
 {
 	struct c2_fop_field_type *fid_type;
@@ -724,22 +706,26 @@ void c2_fop_object_init(const struct c2_fop_type_format *fid_fop_type)
 	fop_object_watch.fif_bits  = C2_FOB_LOAD;
 	c2_fop_itype_watch_add(&fop_object_itype, &fop_object_watch);
 }
+C2_EXPORTED(c2_fop_object_init);
 
 void c2_fop_object_fini(void)
 {
-	wat_tlist_del(&fop_object_watch);
+	c2_list_del(&fop_object_watch.fif_linkage);
 }
+C2_EXPORTED(c2_fop_object_fini);
 
 void c2_fop_object_it_init(struct c2_fit *it, struct c2_fop *fop)
 {
 	c2_fit_init(it, &fop_object_itype, fop);
 }
+C2_EXPORTED(c2_fop_object_it_init);
 
 void c2_fop_object_it_fini(struct c2_fit *it)
 {
 	C2_PRE(it->fi_type == &fop_object_itype);
 	c2_fit_fini(it);
 }
+C2_EXPORTED(c2_fop_object_it_fini);
 
 int c2_fop_object_it_yield(struct c2_fit *it,
 			   struct c2_fid *fid, uint64_t *bits)
@@ -755,39 +741,20 @@ int c2_fop_object_it_yield(struct c2_fit *it,
 	}
 	return result;
 }
+C2_EXPORTED(c2_fop_object_it_yield);
 
 void c2_fits_init(void)
 {
 	c2_fop_decorator_register(&fit_dec);
 	c2_fop_itype_init(&fop_object_itype);
-        c2_fop_itype_init(&fop_all_object_itype);
 }
+C2_EXPORTED(c2_fits_init);
 
 void c2_fits_fini(void)
 {
 	c2_fop_itype_fini(&fop_object_itype);
-        c2_fop_itype_fini(&fop_all_object_itype);
-}
-
-void c2_fop_all_object_it_init(struct c2_fit *it, struct c2_fop *fop)
-{
-        c2_fit_init(it, &fop_all_object_itype, fop);
-}
-
-void c2_fop_all_object_it_fini(struct c2_fit *it)
-{
-        C2_PRE(it->fi_type == &fop_all_object_itype);
-        c2_fit_fini(it);
-}
-
-void c2_fop_it_reset(struct c2_fit *it)
-{
-        struct c2_fit_frame *top;
-
-        it->fi_depth = 0;
-        top = fit_top(it);
-        top->ff_pos = 0;
 }
+C2_EXPORTED(c2_fits_fini);
 
 /** @} end of fop group */
 
diff --git a/fop/fop_iterator.h b/fop/fop_iterator.h
index 8f1612b..3599a1f 100644
--- a/fop/fop_iterator.h
+++ b/fop/fop_iterator.h
@@ -22,8 +22,8 @@
 #define __COLIBRI_FOP_FOP_ITERATOR_H__
 
 #include "lib/types.h"                  /* uint64_t, size_t */
-#include "lib/tlist.h"
-#include "fop/fop_base.h"               /* c2_fop_field_instance */
+#include "lib/list.h"
+#include "fop/fop.h"                    /* c2_fop_field_instance */
 
 /**
    @addtogroup fop
@@ -95,7 +95,7 @@ struct c2_fit_type {
 
 	    @see c2_fit_watch::fif_linkage
 	*/
-	struct c2_tl   fit_watch;
+	struct c2_list fit_watch;
 	/**
 	   An index assigned to this fop iterator type within a global array of
 	   fop iterator types.
@@ -126,14 +126,13 @@ struct c2_fit_watch {
 
 	   @see c2_fit_type::fit_watch
 	 */
-	struct c2_tlink                 fif_linkage;
+	struct c2_list_link             fif_linkage;
 	/**
 	   A list of per-field modifiers.
 
 	   @see c2_fit_mod::fm_linkage
 	 */
-	struct c2_tl                    fif_mod;
-	uint64_t                        fif_magix;
+	struct c2_list                  fif_mod;
 };
 
 /**
@@ -168,8 +167,7 @@ struct c2_fit_mod {
 	 *
 	 * @see c2_fit_watch::fif_mod.
 	 */
-	struct c2_tlink            fm_linkage;
-	uint64_t                   fm_magix;
+	struct c2_list_link        fm_linkage;
 };
 
 void c2_fop_itype_init(struct c2_fit_type *itype);
@@ -329,18 +327,6 @@ void c2_fop_object_it_fini (struct c2_fit *it);
 int  c2_fop_object_it_yield(struct c2_fit *it,
 			    struct c2_fid *fid, uint64_t *bits);
 
-/*
- * Special FOP iterator interfaces
- */
-
-void c2_fits_all_init(void);
-void c2_fits_all_fini(void);
-
-void c2_fop_it_reset(struct c2_fit *it);
-void c2_fop_all_object_it_init(struct c2_fit *it, struct c2_fop *fop);
-void c2_fop_all_object_it_fini(struct c2_fit *it);
-int c2_fop_all_object_it_yield(struct c2_fit *it,
-                               struct c2_fid *fid, uint64_t *bits);
 /** @} end of fop group */
 
 /* __COLIBRI_FOP_FOP_ITERATOR_H__ */
diff --git a/fop/fop_user.h b/fop/fop_user.h
index 5bb9c02..9c12031 100644
--- a/fop/fop_user.h
+++ b/fop/fop_user.h
@@ -26,7 +26,7 @@
 /* __COLIBRI_FOP_FOP_USER_H__ */
 #endif
 
-/*
+/* 
  *  Local variables:
  *  c-indentation-style: "K&R"
  *  c-basic-offset: 8
diff --git a/fop/rt/Makefile.am b/fop/rt/Makefile.am
deleted file mode 100644
index 4b9193e..0000000
--- a/fop/rt/Makefile.am
+++ /dev/null
@@ -1,18 +0,0 @@
-fopdir                        = $(includedir)/fop
-noinst_LTLIBRARIES            = libc2rt.la
-
-fop_SOURCES                   = ../fop_base.c ../fop_base.h ../fom.h \
-                                ../fop_format.c \
-                                ../fop_format.h \
-                                ../fop_user.h ../fop_format_def.h \
-                                ../fop_format_c.c \
-                                stub.c
-
-libc2rt_la_SOURCES            = $(fop_SOURCES)
-libc2rt_la_LIBADD             = $(top_builddir)/addb/addb_pseudo/libcolibri-addb-pseudo.la \
-                                $(top_builddir)/fol/libcolibri-fol.la \
-                                $(top_builddir)/db/libcolibri-db.la \
-                                $(top_builddir)/fid/libcolibri-fid.la \
-                                $(top_builddir)/lib/libc2.la
-
-INCLUDES                      = -I. -I$(top_srcdir) -I$(top_srcdir)/include
diff --git a/fop/rt/stub.c b/fop/rt/stub.c
deleted file mode 100644
index b6585ab..0000000
--- a/fop/rt/stub.c
+++ /dev/null
@@ -1,54 +0,0 @@
-/* -*- C -*- */
-/**
-   @addtogroup fop
-
-   @{
- */
-
-struct c2_fop_type;
-struct c2_rpc_item_type;
-
-int c2_rpc_item_type_register(struct c2_rpc_item_type *item_type)
-{
-	return 0;
-}
-
-void c2_rpc_item_type_deregister(struct c2_rpc_item_type *item_type)
-{
-}
-
-int fop_fol_type_init(struct c2_fop_type *fopt)
-{
-	return 0;
-}
-
-void fop_fol_type_fini(struct c2_fop_type *fopt)
-{
-}
-
-void c2_fits_init(void)
-{
-}
-
-void c2_fits_fini(void)
-{
-}
-
-struct c2_fop_field_type;
-
-int c2_fop_field_type_fit(struct c2_fop_field_type *fieldt)
-{
-	return 0;
-}
-
-/** @} end of fop group */
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
diff --git a/fop/ut/Makefile.am b/fop/ut/Makefile.am
index 214e831..31a1e11 100644
--- a/fop/ut/Makefile.am
+++ b/fop/ut/Makefile.am
@@ -1,9 +1,11 @@
+UT_SRCDIR          = @SRCDIR@/fop/ut
+
 noinst_LTLIBRARIES = libfop-ut.la
 INCLUDES           = -I. -I$(top_srcdir)/include -I$(top_srcdir)
 
 test_format_u.h test_format_u.c test_format_k.h test_format_k.c: \
                                      test_format.ff \
-                                     $(top_builddir)/fop/rt/libc2rt.la \
+                                     $(top_builddir)/fop/libc2rt.la \
                                      $(top_builddir)/fop/fop2c 
 	$(top_builddir)/fop/fop2c -ku $<
 
@@ -21,5 +23,6 @@ libfop_ut_la_SOURCES = iterator_test_u.h iterator_test_u.c \
 EXTRA_DIST = test_format.ff iterator_test.ff
 
 clean-local:
-	cd @SRCDIR@/fop/ut ; \
-	rm -fr test_format_[uk].[ch] iterator_test_u.[ch]
+	cd $(UT_SRCDIR) ; \
+	rm -fr test_format_[uk].[ch]
+	rm -fr iterator_test_u.[ch]
diff --git a/fop/ut/iterator_test.c b/fop/ut/iterator_test.c
index ca1e123..24a59db 100644
--- a/fop/ut/iterator_test.c
+++ b/fop/ut/iterator_test.c
@@ -13,7 +13,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Anatoliy Bilenko <Anatoliy_Bilenko@xyratex.com>
+ * Original author: Anatoliy Bilenko
  * Original creation date: 01/05/2011
  */
 
@@ -32,7 +32,6 @@
 #include "iterator_test_u.h"
 #include "fop/fop_format_def.h"
 #include "fop/ut/iterator_test.ff"
-#include "rpc/rpc_opcodes.h"
 
 
 /* FOP object iterator test tests iterations of the following types:
@@ -42,8 +41,7 @@
  *   - FFA_SEQUENCE.
  */
 
-C2_FOP_TYPE_DECLARE(c2_fop_iterator_test, "FOP iterator test", NULL,
-		    C2_FOP_ITERATOR_TEST_OPCODE, 0);
+C2_FOP_TYPE_DECLARE(c2_fop_iterator_test, "FOP iterator test", 0, NULL);
 
 static struct c2_fop_type *fops[] = {
 	&c2_fop_iterator_test_fopt,
diff --git a/fop/ut/iterator_test.ff b/fop/ut/iterator_test.ff
index 0463196..d019ffc 100644
--- a/fop/ut/iterator_test.ff
+++ b/fop/ut/iterator_test.ff
@@ -1,24 +1,5 @@
 /* -*- C -*- */
 
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Anatoliy Bilenko <Anatoliy_Bilenko@xyratex.com>
- * Original creation date: 01/05/2011
- */
-
 DEF(c2_fop_fid, RECORD,
     _(ff_seq, U64),
     _(ff_oid, U64));
diff --git a/fop/ut/test_format.ff b/fop/ut/test_format.ff
index 0a5ad21..36be7c8 100644
--- a/fop/ut/test_format.ff
+++ b/fop/ut/test_format.ff
@@ -1,24 +1,5 @@
 /* -*- C -*- */
 
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Nikita Danilov <nikita_danilov@xyratex.com>
- * Original creation date: 06/24/2010
- */
-
 /**
    @addtogroup fop
    @{
diff --git a/ioservice/Makefile.am b/ioservice/Makefile.am
index c4ecda2..9a575d9 100644
--- a/ioservice/Makefile.am
+++ b/ioservice/Makefile.am
@@ -1,21 +1,20 @@
-ioservicedir			= $(includedir)/colibri/ioservice
-ioservice_HEADERS		= io_foms.h io_fops.h io_fops_u.h io_fops_k.h cobfid_map.h
+ioservicedir			= @SRCDIR@/ioservice
+ioservice_HEADERS             	= io_foms.h io_fops.h
 
-io_fops_u.h io_fops_u.c: io_fops.ff \
-                  $(top_builddir)/fop/rt/libc2rt.la \
+io_fops_u.h io_fops_u.c io_fops_k.h io_fops_k.c: io_fops.ff \
+                  $(top_builddir)/fop/libc2rt.la \
                   $(top_builddir)/fop/fop2c
 	$(top_builddir)/fop/fop2c -uk $<
 
-noinst_LTLIBRARIES		= libcolibri-ioservice.la
-libcolibri_ioservice_la_SOURCES	= io_foms.h io_fops.h \
-                                  io_fops_u.h io_fops_u.c \
-				  io_foms.c io_fops.c \
-                                  cobfid_map.c cobfid_map.h
 
-INCLUDES			= -I. -I$(top_srcdir) -I$(top_srcdir)/include
+noinst_LTLIBRARIES            	= libcolibri-ioservice.la
+libcolibri_ioservice_la_SOURCES	= io_fops_u.h io_fops_u.c \
+				  io_foms.c io_foms.h io_fops.c io_fops.h
 
-EXTRA_DIST			= io_fops.ff
+INCLUDES                      	= -I. -I$(top_srcdir) -I$(top_srcdir)/include
+
+EXTRA_DIST                    	= io_fops.ff
 
 clean-local:
-	cd @SRCDIR@/ioservice ; \
-	rm -rf io_fops_u*.[ch];
+	cd $(ioservicedir); \
+	rm -rf io_fops_[uk]*.[ch];
diff --git a/ioservice/cobfid_map.c b/ioservice/cobfid_map.c
deleted file mode 100644
index abced88..0000000
--- a/ioservice/cobfid_map.c
+++ /dev/null
@@ -1,705 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Carl Braganza <Carl_Braganza@xyratex.com>
- *                  Anup Barve <Anup_Barve@xyratex.com>
- * Original creation date: 08/23/2011
- */
-
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif
-
-#include <sys/stat.h>
-#include "lib/memory.h"
-#include "lib/errno.h"
-#include "lib/misc.h"  /* SET0 */
-#include "lib/arith.h" /* C2_3WAY */
-#include "ioservice/cobfid_map.h"
-
-/**
- * @addtogroup cobfidmap
- * @{
- */
-
-enum {
-	CFM_MAP_MAGIC  = 0x6d4d4643000a7061,
-	CFM_ITER_MAGIC = 0x694d46430a726574,
-	CFM_ITER_THUNK = 16 /* #records in an iter buffer */
-};
-
-/**
-  Internal data structure used as a key for the record in cobfid_map table
- */
-struct cobfid_map_key {
-	uint64_t	cfk_ci;  /**< container id */
-	struct c2_fid	cfk_fid; /**< global file id */
-};
-
-/**
-  Internal data structure used to store a record in the iterator buffer.
- */
-struct cobfid_map_record {
-	/** key combining container id and global file id */
-	struct cobfid_map_key	cfr_key;
-	/**  cob id */
-	struct c2_uint128	cfr_cob;
-};
-
-/**
-  Compare the cobfid_map table keys
- */
-static int cfm_key_cmp(struct c2_table *table, const void *key0,
-		       const void *key1)
-{
-	const struct cobfid_map_key *map_key0 = key0;
-	const struct cobfid_map_key *map_key1 = key1;
-
-	C2_PRE(table != NULL);
-	C2_PRE(key0 != NULL);
-	C2_PRE(key1 != NULL);
-
-	if (c2_fid_eq(&map_key0->cfk_fid, &map_key1->cfk_fid) &&
-		      C2_3WAY(map_key0->cfk_ci, map_key1->cfk_ci) == 0)
-		return 0;
-	else if (C2_3WAY(map_key0->cfk_ci, map_key1->cfk_ci) == 0)
-		return map_key0->cfk_fid.f_key - map_key1->cfk_fid.f_key;
-	else
-		return map_key0->cfk_ci - map_key1->cfk_ci;
-}
-
-static const struct c2_table_ops cfm_table_ops = {
-	.to = {
-		[TO_KEY] = {
-			.max_size = sizeof(struct cobfid_map_key)
-		},
-		[TO_REC] = {
-			.max_size = sizeof(struct c2_uint128)
-		}
-	},
-	.key_cmp = cfm_key_cmp
-};
-
-/** ADDB instrumentation for cobfidmap */
-static const struct c2_addb_ctx_type cfm_ctx_type = {
-	        .act_name = "cobfid_map"
-};
-
-static const struct c2_addb_loc cfm_addb_loc = {
-	        .al_name = "cobfid_map"
-};
-
-C2_ADDB_EV_DEFINE(cfm_func_fail, "cobfid_map_func_fail",
-		  C2_ADDB_EVENT_FUNC_FAIL, C2_ADDB_FUNC_CALL);
-
-/*
- *****************************************************************************
- struct c2_cobfid_map
- *****************************************************************************
- */
-
-/**
-   Invariant for the c2_cobfid_map.
- */
-static bool cobfid_map_invariant(const struct c2_cobfid_map *cfm)
-{
-	if (cfm == NULL || cfm->cfm_magic != CFM_MAP_MAGIC)
-		return false;
-	return true;
-}
-
-int c2_cobfid_map_init(struct c2_cobfid_map *cfm, struct c2_dbenv *db_env,
-		       struct c2_addb_ctx *addb_ctx, const char *map_name)
-{
-	int rc;
-
-	C2_PRE(cfm != NULL);
-	C2_PRE(db_env != NULL);
-	C2_PRE(addb_ctx != NULL);
-	C2_PRE(map_name != NULL);
-
-	C2_SET0(cfm);
-	cfm->cfm_addb = addb_ctx;
-	cfm->cfm_dbenv = db_env;
-
-	c2_addb_ctx_init(cfm->cfm_addb, &cfm_ctx_type, &c2_addb_global_ctx);
-
-	C2_ALLOC_ARR(cfm->cfm_map_name, strlen(map_name) + 1);
-	if (cfm->cfm_map_name == NULL) {
-		C2_ADDB_ADD(cfm->cfm_addb, &cfm_addb_loc, c2_addb_oom);
-		c2_table_fini(&cfm->cfm_table);
-		return -ENOMEM;
-	}
-
-	strcpy(cfm->cfm_map_name, map_name);
-
-	rc = c2_table_init(&cfm->cfm_table, cfm->cfm_dbenv, cfm->cfm_map_name,
-			   0, &cfm_table_ops);
-	if (rc != 0) {
-		C2_ADDB_ADD(cfm->cfm_addb, &cfm_addb_loc, cfm_func_fail,
-			    "c2_table_init", rc);
-		c2_free(cfm->cfm_map_name);
-		return rc;
-	}
-
-	cfm->cfm_last_mod = c2_time_now();
-	cfm->cfm_magic = CFM_MAP_MAGIC;
-	C2_POST(cobfid_map_invariant(cfm));
-	return 0;
-}
-
-void c2_cobfid_map_fini(struct c2_cobfid_map *cfm)
-{
-	C2_PRE(cobfid_map_invariant(cfm));
-
-	c2_addb_ctx_fini(cfm->cfm_addb);
-	c2_table_fini(&cfm->cfm_table);
-	c2_free(cfm->cfm_map_name);
-}
-
-int c2_cobfid_map_add(struct c2_cobfid_map *cfm, const uint64_t container_id,
-		      const struct c2_fid file_fid, struct c2_uint128 cob_fid)
-{
-	int			 rc;
-	bool			 table_update_failed = false;
-	struct c2_db_pair	 db_pair;
-	struct cobfid_map_key	 key;
-	struct c2_db_tx		 tx;
-
-	C2_PRE(cobfid_map_invariant(cfm));
-
-	key.cfk_ci = container_id;
-	key.cfk_fid = file_fid;
-
-	rc = c2_db_tx_init(&tx, cfm->cfm_dbenv, 0);
-	if (rc != 0) {
-		C2_ADDB_ADD(cfm->cfm_addb, &cfm_addb_loc, cfm_func_fail,
-			    "c2_db_tx_init", rc);
-		return rc;
-	}
-
-	c2_db_pair_setup(&db_pair, &cfm->cfm_table, &key,
-			 sizeof(struct cobfid_map_key),
-			 &cob_fid, sizeof(struct c2_uint128));
-
-	rc = c2_table_update(&tx, &db_pair);
-	if (rc != 0) {
-		table_update_failed = true;
-		C2_ADDB_ADD(cfm->cfm_addb, &cfm_addb_loc, cfm_func_fail,
-			    "c2_table_update", rc);
-	}
-
-	c2_db_pair_release(&db_pair);
-	c2_db_pair_fini(&db_pair);
-	if (!table_update_failed) {
-		cfm->cfm_last_mod = c2_time_now();
-		c2_db_tx_commit(&tx);
-	} else
-		c2_db_tx_abort(&tx);
-
-	C2_POST(cobfid_map_invariant(cfm));
-
-	return rc;
-}
-
-int c2_cobfid_map_del(struct c2_cobfid_map *cfm, const uint64_t container_id,
-		      const struct c2_fid file_fid)
-{
-	int			 rc;
-	struct c2_db_pair	 db_pair;
-	struct cobfid_map_key	 key;
-	bool			 table_op_failed = false;
-	struct c2_db_tx		 tx;
-
-	C2_PRE(cobfid_map_invariant(cfm));
-
-	rc = c2_db_tx_init(&tx, cfm->cfm_dbenv, 0);
-	if (rc != 0) {
-		C2_ADDB_ADD(cfm->cfm_addb, &cfm_addb_loc, cfm_func_fail,
-			    "c2_db_tx_init", rc);
-		return rc;
-	}
-
-	key.cfk_ci = container_id;
-	key.cfk_fid = file_fid;
-
-	c2_db_pair_setup(&db_pair, &cfm->cfm_table, &key,
-			 sizeof(struct cobfid_map_key), NULL, 0);
-
-	rc = c2_table_delete(&tx, &db_pair);
-	if (rc != 0) {
-		C2_ADDB_ADD(cfm->cfm_addb, &cfm_addb_loc, cfm_func_fail,
-			    "c2_table_delete", rc);
-		table_op_failed = true;
-	}
-
-	c2_db_pair_release(&db_pair);
-	c2_db_pair_fini(&db_pair);
-
-	if (!table_op_failed) {
-		cfm->cfm_last_mod = c2_time_now();
-		c2_db_tx_commit(&tx);
-	} else
-		c2_db_tx_abort(&tx);
-
-	C2_POST(cobfid_map_invariant(cfm));
-
-	return rc;
-}
-
-/*
- *****************************************************************************
- struct c2_cobfid_map_iter
- *****************************************************************************
- */
-
-/**
-   Invariant for the c2_cobfid_map_iter.
- */
-static bool cobfid_map_iter_invariant(const struct c2_cobfid_map_iter *iter)
-{
-	if (iter == NULL || iter->cfmi_magic != CFM_ITER_MAGIC)
-		return false;
-	if (!cobfid_map_invariant(iter->cfmi_cfm))
-		return false;
-	if (iter->cfmi_qt == 0 || iter->cfmi_qt >= C2_COBFID_MAP_QT_NR)
-		return false;
-	if (iter->cfmi_ops == NULL ||
-	    iter->cfmi_ops->cfmio_fetch == NULL ||
-	    iter->cfmi_ops->cfmio_is_at_end == NULL ||
-	    iter->cfmi_ops->cfmio_reload == NULL)
-		return false;
-	 /* Number of records (cfmi_num_recs is set to the buffer size and
-	    will be held constant for the life of the iterator */
-	if (iter->cfmi_num_recs == 0)
-		return false;
-	/* Last record (cfmi_last_rec field) cannot exceed the count of
-	   the number of records. Both fields are 0 based */
-	if (iter->cfmi_last_rec > iter->cfmi_num_recs)
-		return false;
-	/* A valid index into records in the buffer is in the range
-	   [0, cfmi_last_rec]. The "next" index (cfmi_rec_idx) should also be
-	   allowed to both identify a valid record, and to point beyond the
-	   valid range to indicate that the buffer is exhausted,
-	   which makes the valid range of the "next" index
-	   [0, (cfmi_last_rec + 1)]. */
-	if (iter->cfmi_rec_idx > iter->cfmi_last_rec + 1)
-		return false;
-	if (iter->cfmi_buffer == NULL)
-		return false;
-	return true;
-}
-
-void c2_cobfid_map_iter_fini(struct c2_cobfid_map_iter *iter)
-{
-	C2_PRE(cobfid_map_iter_invariant(iter));
-
-	c2_free(iter->cfmi_buffer);
-	iter->cfmi_magic = 0;
-
-	C2_POST(!cobfid_map_iter_invariant(iter));
-}
-
-/**
-   Internal sub to initialize an iterator.
- */
-static int cobfid_map_iter_init(struct c2_cobfid_map *cfm,
-				struct c2_cobfid_map_iter *iter,
-				const struct c2_cobfid_map_iter_ops *ops,
-				const enum c2_cobfid_map_query_type qt)
-{
-
-	C2_PRE(iter != NULL);
-	C2_PRE(ops != NULL);
-	C2_PRE(cobfid_map_invariant(cfm));
-
-	C2_SET0(iter);
-
-	/* allocate buffer */
-	C2_ALLOC_ARR(iter->cfmi_buffer, CFM_ITER_THUNK *
-		     sizeof(struct cobfid_map_record));
-	if (iter->cfmi_buffer == NULL) {
-                C2_ADDB_ADD(cfm->cfm_addb, &cfm_addb_loc, c2_addb_oom);
-		return -ENOMEM;
-	}
-
-	iter->cfmi_cfm = cfm;
-	iter->cfmi_ops = ops;
-	iter->cfmi_qt = qt;
-	iter->cfmi_num_recs = CFM_ITER_THUNK;
-	iter->cfmi_end_of_table = false;
-	iter->cfmi_reload = false;
-
-	/* force a query by positioning at the end */
-	iter->cfmi_rec_idx = iter->cfmi_last_rec + 1;
-	iter->cfmi_magic = CFM_ITER_MAGIC;
-
-	C2_POST(cobfid_map_iter_invariant(iter));
-	C2_POST(iter->cfmi_error == 0);
-	return 0;
-}
-
-int c2_cobfid_map_iter_next(struct  c2_cobfid_map_iter *iter,
-			    uint64_t *container_id_p, struct c2_fid *file_fid_p,
-			    struct c2_uint128 *cob_fid_p)
-{
-	int			  rc;
-	struct cobfid_map_record *recs;
-	struct cobfid_map_record *record;
-
-	C2_PRE(cobfid_map_iter_invariant(iter));
-	C2_PRE(container_id_p != NULL);
-	C2_PRE(file_fid_p != NULL);
-	C2_PRE(cob_fid_p != NULL);
-
-	recs = iter->cfmi_buffer;
-
-	/* already in error */
-	if (iter->cfmi_error != 0)
-		return iter->cfmi_error;
-
-	if (iter->cfmi_rec_idx >= iter->cfmi_last_rec) {
-		iter->cfmi_rec_idx = 0;
-		/* buffer empty: fetch records into the buffer
-		   and then set cfmi_rec_idx to 0 */
-		rc = iter->cfmi_ops->cfmio_fetch(iter);
-		if (rc != 0){
-			C2_ASSERT(iter->cfmi_error != 0);
-			C2_ADDB_ADD(iter->cfmi_cfm->cfm_addb, &cfm_addb_loc,
-				    cfm_func_fail, "cfmio_fetch", rc);
-			return rc;
-		}
-		iter->cfmi_last_load = c2_time_now();
-	} else if (iter->cfmi_last_load < iter->cfmi_cfm->cfm_last_mod) {
-		/* iterator stale: reload the buffer and reset buffer index */
-		iter->cfmi_rec_idx = 0;
-		iter->cfmi_reload = true;
-		rc = iter->cfmi_ops->cfmio_reload(iter);
-		if (rc != 0){
-			C2_ASSERT(iter->cfmi_error != 0);
-			C2_ADDB_ADD(iter->cfmi_cfm->cfm_addb, &cfm_addb_loc,
-				    cfm_func_fail, "cfmio_reload", rc);
-			return rc;
-		}
-		iter->cfmi_last_load = c2_time_now();
-	}
-
-	record = &recs[iter->cfmi_rec_idx];
-	/* Set output pointer values */
-	*container_id_p = record->cfr_key.cfk_ci;
-	file_fid_p->f_container = record->cfr_key.cfk_fid.f_container;
-	file_fid_p->f_key = record->cfr_key.cfk_fid.f_key;
-	cob_fid_p->u_hi = record->cfr_cob.u_hi;
-	cob_fid_p->u_lo = record->cfr_cob.u_lo;
-
-	iter->cfmi_last_ci = record->cfr_key.cfk_ci;
-	iter->cfmi_last_fid = record->cfr_key.cfk_fid;
-
-	/* Increment the next record to return */
-	iter->cfmi_rec_idx++;
-
-	/* Check if current record exhausts the iterator.
-	   There is an implicit assumption here that the operations fail
-	   and set cfmi_error when there are no more records left in the
-	   database */
-	if (iter->cfmi_ops->cfmio_is_at_end(iter, iter->cfmi_rec_idx - 1 ))
-		iter->cfmi_error = -ENOENT;
-
-	C2_POST(cobfid_map_iter_invariant(iter));
-
-	return 0;
-}
-
-/*
- *****************************************************************************
- Enumerate map
- *****************************************************************************
- */
-
-static int enum_fetch(struct c2_cobfid_map_iter *iter)
-{
-	int				 rc;
-	int				 i;
-	bool				 last_key_reached = false;
-	struct c2_db_pair		 db_pair;
-	struct c2_cobfid_map		*cfm;
-	struct cobfid_map_key		 key;
-	struct cobfid_map_key		 last_key;
-	struct c2_uint128		 cob_fid;
-	struct cobfid_map_record	*recs;
-	struct c2_db_cursor		 db_cursor;
-	struct c2_db_tx			 tx;
-
-	C2_PRE(cobfid_map_iter_invariant(iter));
-
-	recs = iter->cfmi_buffer;
-
-	cfm = iter->cfmi_cfm;
-
-	rc = c2_db_tx_init(&tx, cfm->cfm_dbenv, 0);
-	if (rc != 0) {
-		C2_ADDB_ADD(cfm->cfm_addb, &cfm_addb_loc, cfm_func_fail,
-			    "c2_db_tx_init", rc);
-		return rc;
-	}
-
-	rc = c2_db_cursor_init(&db_cursor, &cfm->cfm_table, &tx);
-	if (rc != 0) {
-		C2_ADDB_ADD(cfm->cfm_addb, &cfm_addb_loc, cfm_func_fail,
-			    "c2_db_cursor_init", rc);
-		c2_db_tx_abort(&tx);
-		return rc;
-	}
-
-	/* Store the last key, to check if there is overrun during iterating
-	   the table */
-	c2_db_pair_setup(&db_pair, &cfm->cfm_table, &last_key,
-			 sizeof(struct cobfid_map_key),
-			 &cob_fid, sizeof(struct c2_uint128));
-
-	rc = c2_db_cursor_last(&db_cursor, &db_pair);
-	if (rc != 0) {
-		C2_ADDB_ADD(cfm->cfm_addb, &cfm_addb_loc, cfm_func_fail,
-			    "c2_db_cursor_last", rc);
-		goto cleanup;
-	}
-
-	c2_db_pair_release(&db_pair);
-
-	key.cfk_ci = iter->cfmi_next_ci;
-	key.cfk_fid = iter->cfmi_next_fid;
-
-	c2_db_pair_setup(&db_pair, &cfm->cfm_table, &key,
-			 sizeof(struct cobfid_map_key),
-			 &cob_fid, sizeof(struct c2_uint128));
-
-	rc = c2_db_cursor_get(&db_cursor, &db_pair);
-	if (rc != 0) {
-		C2_ADDB_ADD(cfm->cfm_addb, &cfm_addb_loc, cfm_func_fail,
-			    "c2_db_cursor_get", rc);
-		goto cleanup;
-	}
-
-	/* Fetch next entry while reloading the iterator. This is needed as
-	   last entries in the iterator are equated to next entries */
-	if (iter->cfmi_reload) {
-		rc = c2_db_cursor_next(&db_cursor, &db_pair);
-		if (rc != 0) {
-			C2_ADDB_ADD(cfm->cfm_addb, &cfm_addb_loc, cfm_func_fail,
-				    "c2_db_cursor_next", rc);
-			goto cleanup;
-		}
-		iter->cfmi_reload = false;
-	}
-
-	iter->cfmi_last_rec = 0;
-
-	for (i = 0; i < iter->cfmi_num_recs; ++i) {
-		/* Transaction should be committed even if records get exhausted
-		   from the table and not all CFM_ITER_THUNK entries are
-		   fetched. Iterator will be loaded with remaining records */
-		if (cfm_key_cmp(&cfm->cfm_table, &last_key, &key) == 0)
-			last_key_reached = true;
-
-		recs[i].cfr_key.cfk_ci = key.cfk_ci;
-		recs[i].cfr_key.cfk_fid = key.cfk_fid;
-		recs[i].cfr_cob = cob_fid;
-		iter->cfmi_last_rec++;
-
-		if (last_key_reached) {
-			iter->cfmi_end_of_table = true;
-			break;
-		}
-
-		c2_db_pair_setup(&db_pair, &cfm->cfm_table, &key,
-				 sizeof(struct cobfid_map_key),
-				 &cob_fid, sizeof(struct c2_uint128));
-
-		/* The call c2_db_cursor_next() breaks if one tries to go
-		   beyond the last record, hence last_key_reached check
-		   is needed */
-		rc = c2_db_cursor_next(&db_cursor, &db_pair);
-		if (rc != 0) {
-			C2_ADDB_ADD(cfm->cfm_addb, &cfm_addb_loc, cfm_func_fail,
-				    "c2_db_cursor_next", rc);
-			goto cleanup;
-		}
-	}
-
-cleanup:
-	c2_db_pair_release(&db_pair);
-	c2_db_pair_fini(&db_pair);
-	c2_db_cursor_fini(&db_cursor);
-
-	if (rc == 0) {
-		iter->cfmi_next_ci = key.cfk_ci;
-		iter->cfmi_next_fid = key.cfk_fid;
-		c2_db_tx_commit(&tx);
-	} else {
-		iter->cfmi_error = rc;
-		c2_db_tx_abort(&tx);
-	}
-
-	return rc;
-}
-
-static bool enum_is_at_end(struct c2_cobfid_map_iter *iter,
-			   const unsigned int idx)
-{
-	struct cobfid_map_record *recs;
-
-	C2_PRE(cobfid_map_iter_invariant(iter));
-
-	recs = iter->cfmi_buffer;
-
-	if (iter->cfmi_end_of_table &&
-	    iter->cfmi_last_rec == iter->cfmi_rec_idx)
-		return true;
-
-	if (idx < CFM_ITER_THUNK - 1 &&
-	    recs[idx].cfr_key.cfk_ci == recs[idx + 1].cfr_key.cfk_ci)
-		return false;
-
-	return false;
-}
-
-static int enum_reload(struct c2_cobfid_map_iter *iter)
-{
-	C2_PRE(cobfid_map_iter_invariant(iter));
-
-	iter->cfmi_next_ci = iter->cfmi_last_ci;
-	iter->cfmi_next_fid = iter->cfmi_last_fid;
-
-	return iter->cfmi_ops->cfmio_fetch(iter);
-}
-
-static const struct c2_cobfid_map_iter_ops enum_ops = {
-	.cfmio_fetch  = enum_fetch,
-	.cfmio_is_at_end = enum_is_at_end,
-	.cfmio_reload = enum_reload,
-};
-
-int c2_cobfid_map_enum(struct c2_cobfid_map *cfm,
-		       struct c2_cobfid_map_iter *iter)
-{
-	int rc;
-
-	C2_PRE(cobfid_map_invariant(cfm));
-
-	rc = cobfid_map_iter_init(cfm, iter, &enum_ops,
-				  C2_COBFID_MAP_QT_ENUM_MAP);
-	if (rc != 0)
-		C2_ADDB_ADD(iter->cfmi_cfm->cfm_addb, &cfm_addb_loc,
-			    cfm_func_fail, "cobfid_map_iter_init", rc);
-	return rc;
-}
-
-/*
- *****************************************************************************
- Enumerate container
- *****************************************************************************
- */
-
-/**
-   This subroutine fills the record buffer in the iterator.  It uses a
-   database cursor to continue enumeration of the map table with starting
-   key values based upon the cfmi_next_ci and cfmi_next_fid values.
-   After loading the records, it sets cfmi_next_fid to the value of the
-   fid in the last record read, so that the next fetch will continue
-   beyond the current batch.  The value of cfmi_next_ci is not modified.
- */
-static int enum_container_fetch(struct c2_cobfid_map_iter *iter)
-{
-	return enum_fetch(iter);
-}
-
-/**
-   This subroutine returns true if the container_id of the current record
-   is different from the value of cfmi_next_ci (which remains invariant
-   for this query).
- */
-static bool enum_container_is_at_end(struct c2_cobfid_map_iter *iter,
-				     const unsigned int idx)
-{
-	struct cobfid_map_record *recs;
-
-	C2_PRE(cobfid_map_iter_invariant(iter));
-
-	recs = iter->cfmi_buffer;
-
-	if (iter->cfmi_end_of_table &&
-	    iter->cfmi_last_rec == iter->cfmi_rec_idx)
-		return true;
-
-	if (idx == CFM_ITER_THUNK - 1 &&
-	    recs[idx].cfr_key.cfk_ci == iter->cfmi_next_ci)
-		return false;
-
-	if (idx < CFM_ITER_THUNK - 1 &&
-	    recs[idx].cfr_key.cfk_ci == recs[idx + 1].cfr_key.cfk_ci)
-		return false;
-
-	return true;
-}
-
-/**
-   Reload from the position prior to the last record read.
- */
-static int enum_container_reload(struct c2_cobfid_map_iter *iter)
-{
-	return enum_reload(iter);
-}
-
-static const struct c2_cobfid_map_iter_ops enum_container_ops = {
-	.cfmio_fetch  = enum_container_fetch,
-	.cfmio_is_at_end = enum_container_is_at_end,
-	.cfmio_reload = enum_container_reload,
-};
-
-int c2_cobfid_map_container_enum(struct c2_cobfid_map *cfm,
-				 uint64_t container_id,
-				 struct c2_cobfid_map_iter *iter)
-{
-	int rc;
-
-	C2_PRE(cobfid_map_invariant(cfm));
-
-	rc = cobfid_map_iter_init(cfm, iter, &enum_container_ops,
-				  C2_COBFID_MAP_QT_ENUM_CONTAINER);
-	if (rc != 0) {
-		C2_ADDB_ADD(iter->cfmi_cfm->cfm_addb, &cfm_addb_loc,
-			    cfm_func_fail, "cobfid_map_iter_init", rc);
-		return rc;
-	}
-	iter->cfmi_next_ci = container_id;
-	/* Initialize the fid to 0, to start from first fid for a given
-	   container */
-	iter->cfmi_next_fid.f_container = 0;
-	iter->cfmi_next_fid.f_key = 0;
-	return rc;
-}
-
-/** @} cobfidmap */
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 79
- *  scroll-step: 1
- *  End:
- */
diff --git a/ioservice/cobfid_map.h b/ioservice/cobfid_map.h
deleted file mode 100644
index 4b987d4..0000000
--- a/ioservice/cobfid_map.h
+++ /dev/null
@@ -1,288 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Carl Braganza <Carl_Braganza@xyratex.com>
- *                  Anup Barve <Anup_Barve@xyratex.com>
- * Original creation date: 08/23/2011
- */
-
-#ifndef __COLIBRI_COBFID_MAP_H__
-#define __COLIBRI_COBFID_MAP_H__
-
-/**
-   @defgroup cobfidmap Cobfid Map
-   @brief A cobfid map is a persistent data structure that tracks the id of
-   cobs and their associated file fid contained within other containers. SNS
-   repair requires the ability to iterate over the cob_fids on a given device,
-   ordered by their associated file_fid.
-
-   The map is built over a c2_database file stored on disk.
-   All serialization around the use of these interfaces must be performed
-   by the invoker:
-   - Only one instance of a given cobfid map should be opened in the same
-   process.
-   - Any given cobfid map must be protected from concurrent use within the
-   process.
-   - Access to the same cobfid map from multiple processes is not supported.
-   - Multiple maps may be used concurrently within the same process.
-
-   @see <a href="https://docs.google.com/a/xyratex.com/document/d/1T6sWG32Fj1DOJgC5UcJDdfghse8r7loX-kdgx8a4fXM/edit?hl=en_US">HLD of Auxiliary Database for SNS Repair</a>
-   for background information.
-
-   Sample usage is shown below. Error handling is intentionally not shown
-   for brevity.  C++ style comments are only for illustration - they are not
-   valid in Colibri:
-@code
-struct c2_dbenv mydbenv;
-struct c2_addb_ctx myaddb_ctx;
-struct c2_cobfid_map mymap;
-struct c2_cobfid_map_iter myiter;
-
-uint64_t container_id;
-struct c2_fid file_fid;
-struct c2_uint128 cob_fid;
-
-// initialize mydbenv
-
-// create or open the map
-rc = c2_cobfid_map_init(&mymap, &mydbenv, &myaddb_ctx, "mycobfidmapname");
-
-// insert records
-rc = c2_cobfid_map_add(&mymap, container_id, file_fid, cob_fid, &mydbtx);
-...
-
-// enumerate
-rc = c2_cobfid_map_container_enum(&mymap, container_id, &myiter, &mydbtx);
-while ((rc = c2_cobfid_map_iter_next(&myiter,&container_id,&file_fid,&cob_fid,
-		&mydbtx)) == 0) {
-	// process record
-}
-// cleanup
-c2_cobfid_map_fini(&mymap);
-@endcode
-
-   @{
- */
-
-#include "addb/addb.h" /* struct c2_addb_ctx */
-#include "db/db.h"     /* struct c2_dbenv */
-#include "fid/fid.h"   /* struct c2_fid */
-#include "lib/time.h"  /* c2_time_t */
-#include "lib/types.h" /* struct c2_uint128 */
-
-struct c2_cobfid_map_iter_ops; /* forward reference */
-
-/**
-   This data structure tracks the persistent (on-disk) Cobfid map in-memory.
- */
-struct c2_cobfid_map {
-	uint64_t            cfm_magic;
-        struct c2_dbenv    *cfm_dbenv;    /**< Database environment pointer */
-        struct c2_addb_ctx *cfm_addb;     /**< ADDB context */
-	char		   *cfm_map_name; /**< Name of the map */
-	c2_time_t           cfm_last_mod; /**< Time last modified */
-	struct c2_table     cfm_table;    /**< Table corresponding to cfm */
-};
-
-/** enum indicating the query type */
-enum c2_cobfid_map_query_type {
-	/* zero not valid */
-	/** Enumerate all associations in the map */
-	C2_COBFID_MAP_QT_ENUM_MAP = 1,
-	/** Enumerate associations in a container */
-	C2_COBFID_MAP_QT_ENUM_CONTAINER = 2,
-	/* last */
-	C2_COBFID_MAP_QT_NR
-};
-
-/**
-   This data structure keeps state during enumeration of the associations
-   within the map. The same data structure is used to return the results
-   of different types of enumerations.
-
-   The data structure should be treated as opaque by the invoking application.
- */
-struct c2_cobfid_map_iter {
-	uint64_t              cfmi_magic;
-	struct c2_cobfid_map *cfmi_cfm;      /**< The map */
-	int                   cfmi_error;    /**< End or error indicator */
-	c2_time_t             cfmi_last_load;/**< Time last loaded */
-	uint64_t              cfmi_next_ci;  /**< Next container id */
-	struct c2_fid         cfmi_next_fid; /**< Next fid value */
-	uint64_t              cfmi_last_ci;  /**< Last container id returned */
-	struct c2_fid         cfmi_last_fid; /**< Last fid value returned */
-	void                 *cfmi_buffer;   /**< Private read-ahead buffer */
-	unsigned int          cfmi_num_recs; /**< # recs in the buffer */
-	unsigned int	      cfmi_last_rec; /**< index of last valid record */
-	unsigned int          cfmi_rec_idx;  /**< The next record to return */
-	bool		      cfmi_end_of_table; /**< Indicates end of table */
-	bool		      cfmi_reload; /**< Indicates iterator reload */
-	enum c2_cobfid_map_query_type cfmi_qt;   /**< The type of query */
-	const struct c2_cobfid_map_iter_ops *cfmi_ops; /**< Operations */
-};
-
-/** Iterator operations */
-struct c2_cobfid_map_iter_ops {
-	/**
-	   Loads the next batch of records into the iterator and updates the
-	   iterator state to correctly position for the next call.
-	 */
-	int (*cfmio_fetch)(struct c2_cobfid_map_iter *);
-	/**
-	   Determines if the record in the specified position will
-	   exhaust the iterator.
-	   @param idx Index of a buffered record in the iterator.
-	*/
-	bool (*cfmio_is_at_end)(struct c2_cobfid_map_iter *, unsigned int idx);
-	/**
-	   Reload the records from the current position, because the map
-	   may have been altered by an interveaning call to add or
-	   delete a record, as indicated by comparing cfm_last_mod with
-	   cfmi_last_load.
-	*/
-	int (*cfmio_reload)(struct c2_cobfid_map_iter *);
-};
-
-/**
-   Prepare to use a cobfid map, creating it if necessary. The database file
-   will be created in the standard location used for Colibri databases.
-   @param cfm      Pointer to the struct c2_cobfid_map to initialize.
-   @param db_env   C2 database environment pointer. The pointer must remain
-   valid until the map is finalized.
-   @param addb_ctx Pointer to the ADDB context to use. The context must not
-   be finalized until after the map is finalized.
-   @param map_name Name of the map. The string is not referenced after this
-   subroutine returns.
-   @retval 0 on success
-   @retval -errno on failure
-   @see c2_cobfid_map_add()
-   @see c2_cobfid_map_fini()
- */
-int c2_cobfid_map_init(struct c2_cobfid_map *cfm,
-		       struct c2_dbenv *db_env,
-		       struct c2_addb_ctx *addb_ctx,
-		       const char *map_name);
-
-/**
-   Finalize use of a cobfid map.
-   @param cfm Pointer to the struct c2_cobfid_map to finalize
- */
-void c2_cobfid_map_fini(struct c2_cobfid_map *cfm);
-
-/**
-   Finalize use of a cobfid map iterator.
-   @param iter Pointer to the struct c2_cobfid_map_iter to finalize
- */
-void c2_cobfid_map_iter_fini(struct  c2_cobfid_map_iter *iter);
-
-/**
-   Creates an association between the tuple of (container_id, file_fid)
-   and a cob_fid. Any previous cob_fid association is replaced.
-   @param cfm          Pointer to the struct c2_cobfid_map.
-   @param container_id Identifier of the container or device.
-   @param file_fid     Global file identifier.
-   @param cob_fid      COB identifier.
-   @retval 0 on success
-   @retval -errno on failure
-   @see c2_cobfid_map_del()
-   @see c2_cobfid_map_enum()
-   @see c2_cobfid_map_container_enum()
- */
-int c2_cobfid_map_add(struct c2_cobfid_map *cfm,
-		      const uint64_t container_id,
-		      const struct c2_fid file_fid,
-		      struct c2_uint128 cob_fid);
-
-/**
-   Delete the association of the tuple (container_id, file_fid) with a cob_fid.
-   @param cfm          Pointer to the struct c2_cobfid_map.
-   @param container_id Identifier of the container or device.
-   @param file_fid     Global file identifier.
-   @retval 0 on success
-   @retval -errno on failure
- */
-int c2_cobfid_map_del(struct c2_cobfid_map *cfm,
-		      const uint64_t container_id,
-		      const struct c2_fid file_fid);
-
-/**
-   Initializes an iterator to enumerate the associations within a container
-   in the cobfid map. The associations are traversed in global file fid
-   order.
-   @param cfm          Pointer to the struct c2_cobfid_map.
-   @param container_id Identifier of the container or device.
-   @param iter         Pointer to iterator data structure to be initialized.
-   The iterator is used to retrieve the results.
-   @see c2_cobfid_map_iter_next()
-   @retval 0  on success.
-   @retval -errno on error.
- */
-int c2_cobfid_map_container_enum(struct c2_cobfid_map *cfm,
-				 uint64_t container_id,
-				 struct c2_cobfid_map_iter *iter);
-
-/**
-   Initializes an iterator to enumerate all of the associations
-   in the cobfid map. The associations are traversed by container id
-   and global file fid order.
-   @param cfm  Pointer to the struct c2_cobfid_map.
-   @param iter Pointer to iterator data structure to be initialized.
-   The iterator is used to retrieve the results.
-   @see c2_cobfid_map_iter_next()
-   @retval 0  on success.
-   @retval -errno on error.
- */
-int c2_cobfid_map_enum(struct c2_cobfid_map *cfm,
-		       struct c2_cobfid_map_iter *iter);
-
-/**
-   Returns the next association in traversal order, pointed to by the
-   iterator. The iterator gets advanced.
-
-   Internally, the iterator will open a database transaction to read records
-   from the file. The iterator may optimize by reading multiple records in
-   a batch.
-
-   @note Insertions and deletions prior to the iterator position may not
-   be noticed, but any such changes after the current position will be
-   noticed.
-
-   @param iter           Iterator tracking the position in the enumeration.
-   @param container_id_p Returns the identifier of the container or device.
-   @param file_fid_p     Returns the global file identifier.
-   @param cob_fid_p      Returns the COB identifier.
-   @retval 0       on success
-   @retval -ENOENT when the iterator is exhausted
-   @retval -errno  on other errors
- */
-int c2_cobfid_map_iter_next(struct  c2_cobfid_map_iter *iter,
-			    uint64_t *container_id_p,
-			    struct c2_fid *file_fid_p,
-			    struct c2_uint128 *cob_fid_p);
-
-/** @} */
-
-#endif /* __COLIBRI_COBFID_MAP_H__ */
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 79
- *  scroll-step: 1
- *  End:
- */
diff --git a/ioservice/io_foms.c b/ioservice/io_foms.c
index e6b58d6..5e4b0fb 100644
--- a/ioservice/io_foms.c
+++ b/ioservice/io_foms.c
@@ -14,7 +14,6 @@
  * http://www.xyratex.com/contact
  *
  * Original author: Anand Vidwansa <Anand_Vidwansa@xyratex.com>
- *                  Anup Barve <Anup_Barve@xyratex.com>
  * Original creation date: 03/21/2011
  */
 
@@ -24,61 +23,88 @@
 
 #include "fid/fid.h"
 #include "fop/fop.h"
-#include "ioservice/io_foms.h"
-#include "ioservice/io_fops.h"
+#include "io_foms.h"
+#include "io_fops.h"
 #include "stob/stob.h"
 #include "lib/errno.h"
-#include "lib/memory.h"
 #include "net/net.h"
 #include "site/site.h"
 #include "iostore/iostore.h"
-#include "fid/fid.h"
-#include "reqh/reqh.h"
-#include "stob/linux.h"
 
 #ifdef __KERNEL__
-#include "ioservice/linux_kernel/io_fops_k.h"
+#include "io_fops_k.h"
 #else
-#include "ioservice/io_fops_u.h"
+#include "io_fops_u.h"
 #endif
 
+#include "fop/fop_format_def.h"
+#include "ioservice/io_fops.ff"
+
 /**
  * @addtogroup io_foms
  * @{
  */
 
-extern bool is_read(const struct c2_fop *fop);
-extern bool is_write(const struct c2_fop *fop);
-extern bool is_io(const struct c2_fop *fop);
-extern struct c2_fop_cob_rw *io_rw_get(struct c2_fop *fop);
-extern struct c2_fop_cob_rw_reply *io_rw_rep_get(struct c2_fop *fop);
-
-static int io_fom_cob_rwv_state(struct c2_fom *fom);
-static int io_fop_cob_rwv_fom_init(struct c2_fop *fop, struct c2_fom **m);
-static void io_fom_cob_rwv_fini(struct c2_fom *fom);
-static size_t io_fom_locality_get(const struct c2_fom *fom);
-
-static struct c2_fom_ops c2_io_fom_rwv_ops = {
-	.fo_fini = io_fom_cob_rwv_fini,
-	.fo_state = io_fom_cob_rwv_state,
-	.fo_home_locality = io_fom_locality_get,
+#ifndef __KERNEL__
+
+/** Generic ops object for c2_fop_cob_writev */
+static struct c2_fom_ops c2_io_fom_write_ops = {
+	.fo_fini  = c2_io_fom_cob_rwv_fini,
+	.fo_state = c2_io_fom_cob_rwv_state
 };
 
-static const struct c2_fom_type_ops c2_io_cob_rwv_type_ops = {
-	.fto_create = io_fop_cob_rwv_fom_init,
+/** Generic ops object for c2_fop_cob_readv */
+static struct c2_fom_ops c2_io_fom_read_ops = {
+	.fo_fini  = c2_io_fom_cob_rwv_fini,
+	.fo_state = c2_io_fom_cob_rwv_state
 };
 
-static struct c2_fom_type c2_io_cob_rwv_type = {
-	.ft_ops = &c2_io_cob_rwv_type_ops,
+/** Generic ops object for readv and writev reply FOPs */
+struct c2_fom_ops c2_io_fom_rwv_rep = {0,};
+
+/** FOM type specific functions for readv FOP. */
+static const struct c2_fom_type_ops c2_io_cob_readv_type_ops = {0,};
+
+/** FOM type specific functions for writev FOP. */
+static const struct c2_fom_type_ops c2_io_cob_writev_type_ops = {0,};
+
+/** Readv specific FOM type operations vector. */
+static struct c2_fom_type c2_io_fom_cob_readv_mopt = {
+	.ft_ops = &c2_io_cob_readv_type_ops,
+};
+
+/** Writev specific FOM type operations vector. */
+static struct c2_fom_type c2_io_fom_cob_writev_mopt = {
+	.ft_ops = &c2_io_cob_writev_type_ops,
 };
 
 /**
+ *  An array of c2_fom_type structs for all possible FOMs.
+ */
+static struct c2_fom_type *c2_io_fom_types[] = {
+	&c2_io_fom_cob_readv_mopt,
+	&c2_io_fom_cob_writev_mopt,
+};
+
+/**
+ * Find out the respective FOM type object (c2_fom_type)
+ * from the given opcode.
+ * This opcode is obtained from the FOP type (c2_fop_type->ft_code) 
+ */
+struct c2_fom_type *c2_io_fom_type_map(c2_fop_type_code_t code)
+{
+	C2_PRE(IS_IN_ARRAY((code - c2_io_service_readv_opcode), 
+			   c2_io_fom_types));
+	return c2_io_fom_types[code - c2_io_service_readv_opcode];
+}
+
+/**
  * Function to map given fid to corresponding Component object id(in turn,
  * storage object id).
- * Currently, this mapping is identity. But it is subject to
+ * Currently, this mapping is identity. But it is subject to 
  * change as per the future requirements.
  */
-static void io_fid2stob_map(const struct c2_fid *in, struct c2_stob_id *out)
+void c2_io_fid2stob_map(struct c2_fid *in, struct c2_stob_id *out)
 {
 	out->si_bits.u_hi = in->f_container;
 	out->si_bits.u_lo = in->f_key;
@@ -87,7 +113,7 @@ static void io_fid2stob_map(const struct c2_fid *in, struct c2_stob_id *out)
 /**
  * Function to map the on-wire FOP format to in-core FOP format.
  */
-static void io_fid_wire2mem(struct c2_fop_file_fid *in, struct c2_fid *out)
+static void c2_io_fid_wire2mem(struct c2_fop_file_fid *in, struct c2_fid *out)
 {
 	out->f_container = in->f_seq;
 	out->f_key = in->f_oid;
@@ -99,245 +125,294 @@ static void io_fid_wire2mem(struct c2_fop_file_fid *in, struct c2_fid *out)
  * Find the corresponding fom_type and associate it with c2_fom.
  * Associate fop with fom type.
  */
-static int io_fop_cob_rwv_fom_init(struct c2_fop *fop, struct c2_fom **m)
+int c2_io_fop_cob_rwv_fom_init(struct c2_fop *fop, struct c2_fop_ctx *ctx, 
+                               struct c2_fom **m)
 {
-	struct c2_io_fom_cob_rwv *fom_obj;
-	struct c2_fop		 *rep_fop;
+	struct c2_fom			*fom;
+	struct c2_io_fom_cob_rwv	*fom_obj;
+	struct c2_fom_type 		*fom_type;
 
 	C2_PRE(fop != NULL);
 	C2_PRE(m != NULL);
-	C2_PRE(is_io(fop));
 
-	C2_ALLOC_PTR(fom_obj);
+	fom_obj= c2_alloc(sizeof(struct c2_io_fom_cob_rwv));
 	if (fom_obj == NULL)
 		return -ENOMEM;
-
-	fop->f_type->ft_fom_type.ft_ops = &c2_io_cob_rwv_type_ops;
-	if (is_read(fop))
-		rep_fop = c2_fop_alloc(&c2_fop_cob_readv_rep_fopt, NULL);
-	else
-		rep_fop = c2_fop_alloc(&c2_fop_cob_writev_rep_fopt, NULL);
-
-	if (rep_fop == NULL) {
-		c2_free(fom_obj);
-		return -ENOMEM;
+	fom_type = c2_io_fom_type_map(fop->f_type->ft_code);
+	C2_ASSERT(fom_type != NULL);
+	fop->f_type->ft_fom_type = *fom_type;
+	fom = &fom_obj->fcrw_gen;
+	fom->fo_type = fom_type;
+        fom->fo_phase = FOPH_INIT;
+        fom->fo_fop_ctx = ctx;
+
+	if (fop->f_type->ft_code == c2_io_service_readv_opcode) {
+		fom->fo_ops = &c2_io_fom_read_ops;
+		fom_obj->fcrw_rep_fop = 
+			c2_fop_alloc(&c2_fop_cob_readv_rep_fopt, NULL);
+		if (fom_obj->fcrw_rep_fop == NULL) {
+			c2_free(fom_obj);
+			return -ENOMEM;
+		}
+	}
+	else if (fop->f_type->ft_code == c2_io_service_writev_opcode) {
+		fom->fo_ops = &c2_io_fom_write_ops;
+		fom_obj->fcrw_rep_fop = 
+			c2_fop_alloc(&c2_fop_cob_writev_rep_fopt, NULL);
+		if (fom_obj->fcrw_rep_fop == NULL) {
+			c2_free(fom_obj);
+			return -ENOMEM;
+		}
 	}
 
-	c2_fom_create(&fom_obj->fcrw_gen, &c2_io_cob_rwv_type,
-			&c2_io_fom_rwv_ops, fop, rep_fop);
-
+	fom_obj->fcrw_fop = fop;
 	fom_obj->fcrw_stob = NULL;
+	fom_obj->fcrw_st_io = NULL;
 	*m = &fom_obj->fcrw_gen;
 	return 0;
 }
 
-static int io_fom_rwv_io_launch(struct c2_fom *fom)
+/**
+ * <b> State Transition function for "read and write IO" operation
+ *     that executes on data server. </b>
+ *  - Submit the read/write IO request to the corresponding cob.
+ *  - Send reply FOP to client.
+ */
+int c2_io_fom_cob_rwv_state(struct c2_fom *fom)
 {
-	int				 rc;
-	void				*addr;
+        struct c2_site                  *site;
+        struct c2_fop_ctx               *ctx;
+	struct c2_fop_file_fid		*ffid;
+	struct c2_fid 			 fid;
+	struct c2_io_fom_cob_rwv 	*fom_obj;
+	struct c2_stob_id		 stobid;
 	uint32_t			 bshift;
 	uint64_t			 bmask;
+	int 				 result;
+	void				*addr;
 	c2_bcount_t			 count;
 	c2_bindex_t			 offset;
-	struct c2_fid			 fid;
-	struct c2_fop			*fop;
-	struct c2_bufvec		*bufvec;
-	struct c2_stob_id		 stobid;
-	struct c2_stob_io		*stio;
-	struct c2_indexvec		*ivec;
-	struct c2_fop_cob_rw		*iofop;
-	struct c2_fop_io_seg		*ioseg;
-	struct c2_stob_domain		*fom_stdom;
-	struct c2_fop_file_fid		*ffid;
-	struct c2_io_fom_cob_rwv	*fom_obj;
-	struct c2_fop_cob_readv_rep	*rrfop;
+	struct c2_clink			 clink;
+	int				 rc = 0;
+	struct c2_fop_cob_writev	*write_fop = NULL;
+	struct c2_fop_cob_readv		*read_fop = NULL;
+	struct c2_fop_cob_writev_rep	*wr_rep_fop = NULL;
+	struct c2_fop_cob_readv_rep	*rd_rep_fop = NULL;
 
 	C2_PRE(fom != NULL);
 
+	/*
+	 * Since a c2_fom object is passed down to every FOM 
+	 * state method, the context structure which is the 
+	 * parent structure of the FOM is type casted from c2_fom.
+	 */
 	fom_obj = container_of(fom, struct c2_io_fom_cob_rwv, fcrw_gen);
-	fop = fom->fo_fop;
 
-	iofop = io_rw_get(fop);
-	ffid = &iofop->crw_fid;
-	ioseg = iofop->crw_iovec.iv_segs;
-	stio = &fom_obj->fcrw_st_io;
-	fom->fo_phase = FOPH_COB_IO;
-
-	io_fid_wire2mem(ffid, &fid);
-	io_fid2stob_map(&fid, &stobid);
-	fom_stdom = fom->fo_loc->fl_dom->fd_reqh->rh_stdom;
-
-	rc = c2_stob_find(fom_stdom, &stobid, &fom_obj->fcrw_stob);
-	if (rc != 0)
-		goto cleanup;
-
-	rc = c2_stob_locate(fom_obj->fcrw_stob, &fom->fo_tx);
-	if (rc != 0)
-		goto cleanup_st;
-
-	c2_stob_io_init(stio);
+        ctx = fom->fo_fop_ctx;
+        C2_ASSERT(ctx != NULL);
+
+        site = ctx->fc_site;
+        C2_ASSERT(site != NULL);
+
+	/* 
+	 * Allocate and initialize stob io object 
+	 */
+	fom_obj->fcrw_st_io = c2_alloc(sizeof(struct c2_stob_io));
+	if (fom_obj->fcrw_st_io == NULL) {
+		result = -ENOMEM;
+		goto out;
+        }
+
+	/*
+	 * Retrieve the request and reply FOPs.
+	 * Extract the on-write FID from the FOPs.
+	 */
+	if (fom_obj->fcrw_fop->f_type->ft_code == c2_io_service_writev_opcode) {
+		write_fop = c2_fop_data(fom_obj->fcrw_fop);
+		wr_rep_fop = c2_fop_data(fom_obj->fcrw_rep_fop);
+		ffid = &write_fop->fwr_fid;
+		/*
+		 * Change the phase of FOM
+		 */
+		fom->fo_phase = FOPH_COB_WRITE;
+	}
+	else {
+		read_fop = c2_fop_data(fom_obj->fcrw_fop);
+		rd_rep_fop = c2_fop_data(fom_obj->fcrw_rep_fop);
+		ffid = &read_fop->frd_fid;
+		/*
+		 * Change the phase of FOM
+		 */
+		fom->fo_phase = FOPH_COB_READ;
+	}
 
-	/* Since the upper layer IO block size could differ with IO block size
-	   of storage object, the block alignment and mapping is necesary. */
+	/* Find out the in-core fid from on-wire fid. */
+	c2_io_fid_wire2mem(ffid, &fid);
+
+	/* 
+	 * Map the given fid to find out corresponding stob id.
+	 */
+	c2_io_fid2stob_map(&fid, &stobid);
+
+	/* 
+	 * This is a transaction IO and should be a separate phase 
+	 * with full fledged FOM. 
+	 */
+	 
+	/*
+	 * @todo: Use ctx->fc_tx prepared by reqh.
+	 */
+	result = site->s_iostore->ds_dom->sd_ops->sdo_tx_make(
+	        site->s_iostore->ds_dom, ctx->fc_tx);
+	C2_ASSERT(result == 0);
+
+	/*
+	 * Allocate and find out the c2_stob object from given domain. 
+	 */
+	result = c2_stob_find(site->s_iostore->ds_dom, 
+	        (const struct c2_stob_id*)&stobid, &fom_obj->fcrw_stob);
+	C2_ASSERT(result == 0);
+	result = c2_stob_locate(fom_obj->fcrw_stob, ctx->fc_tx);
+	C2_ASSERT(result == 0);
+
+	/*
+	 * Initialize the stob io routine.
+	 */
+	c2_stob_io_init(fom_obj->fcrw_st_io);
+
+	/*
+	 * Since the upper layer IO block size could differ
+	 * with IO block size of storage object, the block
+	 * alignment and mapping is necesary. 
+	 */
 	bshift = fom_obj->fcrw_stob->so_op->sop_block_shift(fom_obj->fcrw_stob);
 	bmask = (1 << bshift) - 1;
 
-	/* Find out buffer address, offset and count required for stob io.
-	   Due to existing limitations of kxdr wrapper over sunrpc, read reply
-	   fop can not contain a vector, only a segment. Ideally, all IO fops
-	   should carry an IO vector. */
-	/** @todo With introduction of new rpc layer, ioservice has to be
-	    changed to handle the whole vector, not just one segment. */
-	/* This condition exists since read and write replies are not similar
-	   at the moment due to sunrpc restrictions mentioned above! */
-	if (is_write(fop)) {
-		/* Make an FOL transaction record. */
-		rc = c2_fop_fol_rec_add(fop, fom->fo_fol, &fom->fo_tx.tx_dbtx);
-		if (rc != 0)
-			goto cleanup_st;
-		addr = c2_stob_addr_pack(ioseg->is_buf.ib_buf, bshift);
-		stio->si_opcode = SIO_WRITE;
-	} else {
-		rrfop = c2_fop_data(fom->fo_rep_fop);
-		C2_ALLOC_ARR(rrfop->c_iobuf.ib_buf,
-				ioseg->is_buf.ib_count);
-		if (rrfop->c_iobuf.ib_buf == NULL) {
-			rc = -ENOMEM;
-			goto cleanup_st;
-		}
-		addr = c2_stob_addr_pack(rrfop->c_iobuf.ib_buf, bshift);
-		stio->si_opcode = SIO_READ;
+	/* 
+	 * Find out the buffer address, offset and count
+	 * required for the stob io. 
+	 */
+	if (fom_obj->fcrw_fop->f_type->ft_code == c2_io_service_writev_opcode) {
+		C2_ASSERT((write_fop->fwr_iovec.iov_seg.f_offset & bmask) == 0);
+		C2_ASSERT((write_fop->fwr_iovec.iov_seg.f_buf.f_count & bmask) == 0);
+		addr = c2_stob_addr_pack(write_fop->fwr_iovec.
+					 iov_seg.f_buf.f_buf, bshift);
+		count = write_fop->fwr_iovec.iov_seg.f_buf.f_count;
+		offset = write_fop->fwr_iovec.iov_seg.f_offset;
+		fom_obj->fcrw_st_io->si_opcode = SIO_WRITE;
+	}
+	else {
+		C2_ASSERT((read_fop->frd_ioseg.f_offset & bmask) == 0);
+		C2_ASSERT((read_fop->frd_ioseg.f_count & bmask) == 0);
+
+		/* 
+		 * Allocate the read buffer. 
+		 */
+		C2_ALLOC_ARR(rd_rep_fop->frdr_buf.f_buf, read_fop->frd_ioseg.f_count);     
+		C2_ASSERT(rd_rep_fop->frdr_buf.f_buf != NULL);
+		addr = c2_stob_addr_pack(rd_rep_fop->frdr_buf.f_buf, 
+					 bshift);
+		count = read_fop->frd_ioseg.f_count;
+		offset = read_fop->frd_ioseg.f_offset; 
+		fom_obj->fcrw_st_io->si_opcode = SIO_READ;
 	}
-
-	count = ioseg->is_buf.ib_count;
-	offset = ioseg->is_offset;
-
-	C2_ASSERT((offset & bmask) == 0);
-	C2_ASSERT((count & bmask) == 0);
 
 	count = count >> bshift;
 	offset = offset >> bshift;
 
-	bufvec = &stio->si_user;
-	bufvec->ov_vec.v_count = &count;
-	bufvec->ov_buf = &addr;
-	bufvec->ov_vec.v_nr = 1;
-
-	ivec = &stio->si_stob;
-	ivec->iv_index = &offset;
-	ivec->iv_vec.v_count = &count;
-	ivec->iv_vec.v_nr = 1;
-	stio->si_flags = 0;
-
-	c2_fom_block_at(fom, &stio->si_wait);
-	rc = c2_stob_io_launch(stio, fom_obj->fcrw_stob, &fom->fo_tx, NULL);
-	if (rc == 0) {
-		fom->fo_rc = rc;
-		fom->fo_phase = FOPH_COB_IO_WAIT;
+	fom_obj->fcrw_st_io->si_user.div_vec.ov_vec.v_count = &count;
+	fom_obj->fcrw_st_io->si_user.div_vec.ov_buf = &addr;
+
+	fom_obj->fcrw_st_io->si_stob.iv_index = &offset;
+	fom_obj->fcrw_st_io->si_stob.iv_vec.v_count = &count;
+
+	/*
+	 * Total number of segments in IO vector 
+	 */
+	fom_obj->fcrw_st_io->si_user.div_vec.ov_vec.v_nr = 1;
+	fom_obj->fcrw_st_io->si_stob.iv_vec.v_nr = 1;
+	fom_obj->fcrw_st_io->si_flags = 0;
+
+	/* 
+	 * A new clink is used to wait on the channel 
+	 * from c2_stob_io.
+	 */
+	c2_clink_init(&clink, NULL);
+	c2_clink_add(&fom_obj->fcrw_st_io->si_wait, &clink);
+
+	/*
+	 * Launch IO and wait for status. 
+	 */
+	result = c2_stob_io_launch(fom_obj->fcrw_st_io, fom_obj->fcrw_stob, 
+	                           ctx->fc_tx, NULL);
+	if (result == 0)
+		c2_chan_wait(&clink);
+
+	/* 
+	 * Retrieve the status code and no of bytes read/written
+	 * and place it in respective reply FOP. 
+	 */
+	if (fom_obj->fcrw_fop->f_type->ft_code == c2_io_service_writev_opcode) {
+		wr_rep_fop->fwrr_rc = fom_obj->fcrw_st_io->si_rc;
+		wr_rep_fop->fwrr_count = fom_obj->fcrw_st_io->si_count << bshift;;
 	}
 	else {
-		if (is_read(fop))
-			c2_free(rrfop->c_iobuf.ib_buf);
-		goto cleanup_st;
+		rd_rep_fop->frdr_rc = fom_obj->fcrw_st_io->si_rc;
+		rd_rep_fop->frdr_buf.f_count = fom_obj->fcrw_st_io->si_count << bshift;
 	}
-	return FSO_WAIT;
 
-cleanup_st:
-	c2_stob_put(fom_obj->fcrw_stob);
-cleanup:
-	C2_ASSERT(rc != 0);
-	fom->fo_rc = rc;
-	fom->fo_phase = FOPH_FAILURE;
-	return FSO_AGAIN;
-}
+	c2_clink_del(&clink);
+	c2_clink_fini(&clink);
 
-static int io_fom_rwv_io_launch_wait(struct c2_fom *fom)
-{
-	uint32_t			 bshift;
-	struct c2_stob_io		*stio;
-	struct c2_io_fom_cob_rwv	*fom_obj;
-	struct c2_fop_cob_readv_rep	*rrfop;
-	struct c2_fop_cob_rw_reply	*rwrep;
-
-	C2_PRE(fom != NULL);
+	c2_stob_io_fini(fom_obj->fcrw_st_io);
+	c2_free(fom_obj->fcrw_st_io);
+	fom_obj->fcrw_st_io = NULL;
 
-	fom_obj = container_of(fom, struct c2_io_fom_cob_rwv, fcrw_gen);
-	bshift = fom_obj->fcrw_stob->so_op->sop_block_shift(fom_obj->fcrw_stob);
-	stio = &fom_obj->fcrw_st_io;
-	rwrep = io_rw_rep_get(fom->fo_rep_fop);
-
-	rwrep->rwr_rc = stio->si_rc;
-	rwrep->rwr_count = stio->si_count << bshift;
-
-	/* Retrieve the status code and no of bytes read/written and
-	   place it in respective reply FOP. This has to be handled
-	   differently for read and write since reply fops for read
-	   and write are not same at the moment due to kxdr limitation
-	   mentioned above. */
-	if (is_read(fom->fo_fop)) {
-		rrfop = c2_fop_data(fom->fo_rep_fop);
-		rrfop->c_iobuf.ib_count = stio->si_count << bshift;
-	}
-
-	c2_stob_io_fini(stio);
 	c2_stob_put(fom_obj->fcrw_stob);
 
-	fom->fo_rc = 0;
-	fom->fo_phase = FOPH_SUCCESS;
-	return FSO_AGAIN;
-}
-
-/**
- * State Transition function for read and write IO operation
- * that executes on data server.
- *  - Submit the read/write IO request to the corresponding cob.
- *  - Send reply FOP to client.
- */
-static int io_fom_cob_rwv_state(struct c2_fom *fom)
-{
-	int		 rc;
-
-	C2_PRE(fom != NULL);
-	C2_PRE(is_io(fom->fo_fop));
-
-	if (fom->fo_phase < FOPH_NR) {
-		rc = c2_fom_state_generic(fom);
-		return rc;
+	if (result != -EDEADLK)	{
+		rc = c2_db_tx_commit(&ctx->fc_tx->tx_dbtx);
+		C2_ASSERT(rc == 0);
+	} else {
+		rc = c2_db_tx_abort(&ctx->fc_tx->tx_dbtx);
+		C2_ASSERT(rc == 0);
+		/* This should go into FAILURE phase */
+		fom_obj->fcrw_gen.fo_phase = FOPH_FAILED;
+                c2_fop_free(fom_obj->fcrw_rep_fop);
+		return FSO_AGAIN;
 	}
 
-	switch (fom->fo_phase) {
-	case FOPH_COB_IO:
-		rc = io_fom_rwv_io_launch(fom);
-		break;
-	case FOPH_COB_IO_WAIT:
-		rc = io_fom_rwv_io_launch_wait(fom);
-		break;
-	default:
-		C2_IMPOSSIBLE("Invalid phase of rw fom.");
-	};
-
-	return rc;
+	/*
+	 * Send reply FOP
+	 */
+	c2_net_reply_post(fom->fo_fop_ctx->fc_service, fom_obj->fcrw_rep_fop, 
+			  fom->fo_fop_ctx->fc_cookie);
+
+out:
+        ctx->fc_retval = rc;
+        if (rc)
+                c2_fop_free(fom_obj->fcrw_rep_fop);
+	/* 
+	 * This goes into DONE phase if not a error 
+	 */
+	fom_obj->fcrw_gen.fo_phase = rc ? FOPH_FAILED : FOPH_DONE;
+	return FSO_AGAIN;
 }
 
-static void io_fom_cob_rwv_fini(struct c2_fom *fom)
+/** Fini of read FOM object */
+void c2_io_fom_cob_rwv_fini(struct c2_fom *fom)
 {
-	struct c2_io_fom_cob_rwv *fom_ctx;
+	struct c2_io_fom_cob_rwv *fom_obj;
 
-	fom_ctx = container_of(fom, struct c2_io_fom_cob_rwv, fcrw_gen);
-	c2_free(fom_ctx);
+	fom_obj = container_of(fom, struct c2_io_fom_cob_rwv, fcrw_gen);
+	c2_free(fom_obj);
 }
 
-static size_t io_fom_locality_get(const struct c2_fom *fom)
-{
-	C2_PRE(fom != NULL);
-	C2_PRE(fom->fo_fop != NULL);
-
-	return fom->fo_fop->f_type->ft_rpc_item_type.rit_opcode;
-}
+#endif
 
 /** @} end of io_foms */
 
-/*
+/* 
  *  Local variables:
  *  c-indentation-style: "K&R"
  *  c-basic-offset: 8
diff --git a/ioservice/io_foms.h b/ioservice/io_foms.h
index e4ad291..26d4479 100644
--- a/ioservice/io_foms.h
+++ b/ioservice/io_foms.h
@@ -15,7 +15,6 @@
  * http://www.xyratex.com/contact
  *
  * Original author: Anand Vidwansa <Anand_Vidwansa@xyratex.com>
- *                  Anup Barve <Anup_Barve@xyratex.com>
  * Original creation date: 03/21/2011
  */
 
@@ -25,31 +24,67 @@
 /**
  * @defgroup io_foms Fop State Machines for various FOPs
  *
- * Fop state machine for IO operations
+ * <b>Fop state machine for IO operations </b>
  * @see fom
- * @ref https://docs.google.com/a/xyratex.com/Doc?docid=0AQaCw6YRYSVSZGZmMzV6NzJfMTNkOGNjZmdnYg&hl=en
+ * @ref https://docs.google.com/a/xyratex.com/Doc?docid=0AQaCw6YRYSVSZGZmMzV6NzJfMTNkOGNjZmdnYg&hl=en  
  *
  * FOP state machines for various IO operations like
- * COB Readv
- * COB Writev
+ * @li COB Readv
+ * @li COB Writev
  *
  * All operation specific code will be executed in a single phase
  * for now. It will be decomposed into more granular phases
- * when FOM and reqh infrastructure is in place.
+ * when FOM and reqh infrastructure is in place. 
  *
- * @note Naming convention: For operation xyz, the fop is named
+ * <i> Note on naming convention: For operation xyz, the fop is named 
  * as c2_fop_xyz, its corresponding reply fop is named as c2_fop_xyz_rep
  * and fom is named as c2_fom_xyz. For each fom type, its corresponding
- * create, state and fini methods are named as c2_fom_xyz_create,
- * c2_fom_xyz_state, c2_fom_xyz_fini respectively.
+ * create, state and fini methods are named as c2_fom_xyz_create, 
+ * c2_fom_xyz_state, c2_fom_xyz_fini respectively </i>
  *
  *  @{
  */
 
 #include "fop/fop.h"
 #include "fop/fop_format.h"
-#include "ioservice/io_fops.h"
+#include "io_fops.h"
 #include "stob/stob.h"
+#ifndef __KERNEL__
+
+#include "io_fops_u.h"
+/**
+ * Function to map given fid to corresponding Component object id(in turn,
+ * storage object id).
+ * Currently, this mapping is identity. But it is subject to 
+ * change as per the future requirements.
+ */
+void c2_io_fid2stob_map(struct c2_fid *in, struct c2_stob_id *out);
+
+/**
+ * A dummy request handler API to handle incoming FOPs.
+ * Actual reqh will be used in future.
+ */
+int c2_io_dummy_req_handler(struct c2_service *s, struct c2_fop *fop,
+			 void *cookie, struct c2_fol *fol, 
+			 struct c2_stob_domain *dom);
+
+#endif
+
+/**
+ * Find out the respective FOM type object (c2_fom_type)
+ * from the given opcode.
+ * This opcode is obtained from the FOP type (c2_fop_type->ft_code) 
+ */
+struct c2_fom_type* c2_io_fom_type_map(c2_fop_type_code_t code);
+
+/** 
+ * The various phases for writev FOM. 
+ * Not used as of now. Will be used once the 
+ * complete FOM and reqh infrastructure is in place.
+ */
+enum c2_io_fom_cob_writev_phases{
+	FOPH_COB_WRITE
+};
 
 /**
  * Object encompassing FOM for cob write
@@ -58,26 +93,47 @@
 struct c2_io_fom_cob_rwv {
 	/** Generic c2_fom object. */
         struct c2_fom                    fcrw_gen;
+	/** FOP associated with this FOM. */
+        struct c2_fop			*fcrw_fop;
+	/** Reply FOP associated with request FOP above. */
+	struct c2_fop			*fcrw_rep_fop;
 	/** Stob object on which this FOM is acting. */
         struct c2_stob		        *fcrw_stob;
 	/** Stob IO packet for the operation. */
-        struct c2_stob_io		 fcrw_st_io;
+        struct c2_stob_io		*fcrw_st_io;
 };
 
 /**
- * The various phases for readv FOM.
- * Not used as of now. Will be used once the
+ * <b> State Transition function for "read and write IO" operation
+ *     that executes on data server. </b>
+ *  - Submit the read/write IO request to the corresponding cob.
+ *  - Send reply FOP to client.
+ */
+int c2_io_fom_cob_rwv_state(struct c2_fom *fom); 
+
+/**
+   Free memory in passed @fom.
+*/
+void c2_fom_cob_rwv_fini(struct c2_fom *fom);
+
+/** 
+ * The various phases for readv FOM. 
+ * Not used as of now. Will be used once the 
  * complete FOM and reqh infrastructure is in place.
  */
-enum c2_io_fom_cob_rwv_phases {
-	FOPH_COB_IO = FOPH_NR + 1,
-	FOPH_COB_IO_WAIT,
+enum c2_io_fom_cob_readv_phases {
+	FOPH_COB_READ
 };
 
-#endif
+/** Finish method of read FOM object */
+void c2_io_fom_cob_rwv_fini(struct c2_fom *fom);
 
 /** @} end of io_foms */
-/*
+
+/* __COLIBRI_IOSERVICE_IO_FOMS_H__ */
+#endif
+
+/* 
  *  Local variables:
  *  c-indentation-style: "K&R"
  *  c-basic-offset: 8
@@ -86,3 +142,4 @@ enum c2_io_fom_cob_rwv_phases {
  *  scroll-step: 1
  *  End:
  */
+
diff --git a/ioservice/io_fops.c b/ioservice/io_fops.c
index fd33726..d061bd2 100644
--- a/ioservice/io_fops.c
+++ b/ioservice/io_fops.c
@@ -1,4 +1,3 @@
-/* -*- C -*- */
 /*
  * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
  *
@@ -15,7 +14,6 @@
  * http://www.xyratex.com/contact
  *
  * Original author: Anand Vidwansa <Anand_Vidwansa@xyratex.com>
- *                  Anup Barve <Anup_Barve@xyratex.com>
  * Original creation date: 03/21/2011
  */
 
@@ -23,599 +21,71 @@
 #include <config.h>
 #endif
 
-#include "ioservice/io_fops.h"
-
-#ifdef __KERNEL__
-#include "ioservice/io_fops_k.h"
-#else
-#include "ioservice/io_fops_u.h"
-#endif
-
+#include "io_fops.h"
 #include "lib/errno.h"
-#include "lib/memory.h"
-#include "xcode/bufvec_xcode.h" /* c2_xcode_fop_size_get() */
-#include "fop/fop_format_def.h"
-#include "ioservice/io_fops.ff"
-#include "rpc/rpc_base.h"
-#include "lib/vec.h"	/* c2_0vec */
-#include "rpc/rpc_opcodes.h"
 
-extern const struct c2_rpc_item_ops      rpc_item_iov_ops;
-extern const struct c2_rpc_item_type_ops rpc_item_iov_type_ops;
+int c2_io_fop_cob_rwv_fom_init(struct c2_fop *fop, struct c2_fop_ctx *ctx, 
+                               struct c2_fom **m);
 
 /**
-   The IO fops code has been generalized to suit both read and write fops
-   as well as the kernel implementation.
-   The fop for read and write is same.
-   Most of the code deals with IO coalescing and fop type ops.
-   Ioservice also registers IO fops. This initialization should be done
-   explicitly while using code is user mode while kernel module takes care
-   of this initialization by itself.
-   Most of the IO coalescing is done from client side. RPC layer, typically
-   formation module invokes the IO coalescing code.
- */
-
-/**
-   A generic IO segment pointing either to read or write segments. This
-   is needed to have generic IO coalescing code. During coalescing, lot
-   of new io segments are created which need to be tracked using a list.
-   This is where the generic io segment is used.
+ * readv FOP operation vector.
  */
-struct c2_io_ioseg {
-	/** IO segment for read or write request fop. */
-	struct c2_fop_io_seg	*rw_seg;
-        /** Linkage to the list of such structures. */
-        struct c2_list_link	 io_linkage;
+struct c2_fop_type_ops c2_io_cob_readv_ops = {
+	.fto_fom_init = c2_io_fop_cob_rwv_fom_init,
 };
 
-bool is_read(const struct c2_fop *fop)
-{
-	C2_PRE(fop != NULL);
-	return fop->f_type == &c2_fop_cob_readv_fopt;
-}
-
-bool is_write(const struct c2_fop *fop)
-{
-	C2_PRE(fop != NULL);
-	return fop->f_type == &c2_fop_cob_writev_fopt;
-}
-
-bool is_io(const struct c2_fop *fop)
-{
-	return is_read(fop) || is_write(fop);
-}
-
-bool is_read_rep(const struct c2_fop *fop)
-{
-	C2_PRE(fop != NULL);
-	return fop->f_type == &c2_fop_cob_readv_rep_fopt;
-}
-
-bool is_write_rep(const struct c2_fop *fop)
-{
-	C2_PRE(fop != NULL);
-	return fop->f_type == &c2_fop_cob_writev_rep_fopt;
-}
-
-bool is_io_rep(const struct c2_fop *fop)
-{
-	return is_read_rep(fop) || is_write_rep(fop);
-}
-
-/**
-   Allocates the array of IO segments from IO vector.
-   @retval - 0 if succeeded, negative error code otherwise.
- */
-static int iosegs_alloc(struct c2_fop_io_vec *iovec, const uint32_t count)
-{
-	C2_PRE(iovec != NULL);
-	C2_PRE(count != 0);
-
-	C2_ALLOC_ARR(iovec->iv_segs, count);
-	return iovec->iv_segs == NULL ? 0 : -ENOMEM;
-}
-
-struct c2_fop_cob_rw *io_rw_get(struct c2_fop *fop)
-{
-	struct c2_fop_cob_readv  *rfop;
-	struct c2_fop_cob_writev *wfop;
-
-	C2_PRE(fop != NULL);
-	C2_PRE(is_io(fop));
-
-	if (is_read(fop)) {
-		rfop = c2_fop_data(fop);
-		return &rfop->c_rwv;
-	} else {
-		wfop = c2_fop_data(fop);
-		return &wfop->c_rwv;
-	}
-}
-
-struct c2_fop_cob_rw_reply *io_rw_rep_get(struct c2_fop *fop)
-{
-	struct c2_fop_cob_readv_rep	*rfop;
-	struct c2_fop_cob_writev_rep	*wfop;
-
-	C2_PRE(fop != NULL);
-	C2_PRE(is_io_rep(fop));
-
-	if (is_read_rep(fop)) {
-		rfop = c2_fop_data(fop);
-		return &rfop->c_rep;
-	} else {
-		wfop = c2_fop_data(fop);
-		return &wfop->c_rep;
-	}
-}
-
 /**
-   Returns IO vector from given IO fop.
- */
-static struct c2_fop_io_vec *iovec_get(struct c2_fop *fop)
-{
-	return &io_rw_get(fop)->crw_iovec;
-}
-
-/**
-   Deallocates and removes a generic IO segment from aggr_list.
- */
-static void ioseg_unlink_free(struct c2_io_ioseg *ioseg)
-{
-	C2_PRE(ioseg != NULL);
-
-	c2_list_del(&ioseg->io_linkage);
-	c2_free(ioseg);
-}
-
-/**
-   Returns if given 2 fops belong to same type.
- */
-static bool io_fop_type_equal(const struct c2_fop *fop1,
-		const struct c2_fop *fop2)
-{
-	C2_PRE(fop1 != NULL);
-	C2_PRE(fop2 != NULL);
-
-	return fop1->f_type == fop2->f_type;
-}
-
-/**
-   Returns the number of IO fragements (discontiguous buffers)
-   for a fop of type read or write.
+ * writev FOP operation vector.
  */
-static uint64_t io_fop_fragments_nr_get(struct c2_fop *fop)
-{
-	uint32_t	      i;
-	uint64_t	      frag_nr = 1;
-	struct c2_fop_io_vec *iovec;
-
-	C2_PRE(fop != NULL);
-	C2_PRE(is_io(fop));
-
-	iovec = iovec_get(fop);
-	for (i = 0; i < iovec->iv_count - 1; ++i)
-		if (iovec->iv_segs[i].is_offset +
-		    iovec->iv_segs[i].is_buf.ib_count !=
-		    iovec->iv_segs[i+1].is_offset)
-			frag_nr++;
-	return frag_nr;
-}
+struct c2_fop_type_ops c2_io_cob_writev_ops = {
+	.fto_fom_init = c2_io_fop_cob_rwv_fom_init,
+};
 
 /**
-   Allocates a new generic IO segment
+ * Init function to initialize readv and writev reply FOMs.
+ * Since there is no client side FOMs as of now, this is empty.
  */
-static int io_fop_seg_init(struct c2_io_ioseg **ns, struct c2_io_ioseg *cseg)
+static int c2_io_fop_cob_rwv_rep_fom_init(struct c2_fop *fop, 
+                                          struct c2_fop_ctx *ctx, 
+                                          struct c2_fom **m)
 {
-	struct c2_io_ioseg *new_seg;
-
-	C2_PRE(ns != NULL);
-
-	C2_ALLOC_PTR(new_seg);
-	if (new_seg == NULL)
-		return -ENOMEM;
-	C2_ALLOC_PTR(new_seg->rw_seg);
-	if (new_seg->rw_seg == NULL) {
-		c2_free(new_seg);
-		return -ENOMEM;
-	}
-	*ns = new_seg;
-	*new_seg = *cseg;
 	return 0;
 }
 
 /**
-   Adds a new IO segment to the aggr_list conditionally.
- */
-static int io_fop_seg_add_cond(struct c2_io_ioseg *cseg,
-		struct c2_io_ioseg *nseg)
-{
-	int			 rc;
-	struct c2_io_ioseg	*new_seg;
-
-	C2_PRE(cseg != NULL);
-	C2_PRE(nseg != NULL);
-
-	if (nseg->rw_seg->is_offset < cseg->rw_seg->is_offset) {
-		rc = io_fop_seg_init(&new_seg, nseg);
-		if (rc < 0)
-			return rc;
-
-		c2_list_add_before(&cseg->io_linkage, &new_seg->io_linkage);
-	} else
-		rc = -EINVAL;
-
-	return rc;
-}
-
-/**
-   Checks if input IO segment from IO vector can fit with existing set of
-   segments in aggr_list.
-   If yes, change corresponding segment from aggr_list accordingly.
-   The segment is added in a sorted manner of starting offset in aggr_list.
-   Else, add a new segment to the aggr_list.
-   @note This is a best-case effort or an optimization effort. That is why
-   return value is void. If something fails, everything is undone and function
-   returns.
-
-   @param aggr_list - list of write segments which gets built during
-    this operation.
- */
-static void io_fop_seg_coalesce(struct c2_io_ioseg *seg,
-		struct c2_list *aggr_list)
-{
-	int			 rc;
-	bool			 added = false;
-	struct c2_io_ioseg	*new_seg;
-	struct c2_io_ioseg	*ioseg;
-	struct c2_io_ioseg	*ioseg_next;
-
-	C2_PRE(seg != NULL);
-	C2_PRE(aggr_list != NULL);
-
-	c2_list_for_each_entry_safe(aggr_list, ioseg, ioseg_next,
-			struct c2_io_ioseg, io_linkage) {
-		/* If given segment fits before some other segment
-		   in increasing order of offsets, add it before
-		   current segments from aggr_list. */
-		rc = io_fop_seg_add_cond(ioseg, seg);
-		if (rc == -ENOMEM)
-			return;
-		if (rc == 0) {
-			added = true;
-			break;
-		}
-	}
-
-	/* Add a new IO segment unconditionally in aggr_list. */
-	if (!added) {
-		rc = io_fop_seg_init(&new_seg, seg);
-		if (rc < 0)
-			return;
-		c2_list_add_tail(aggr_list, &new_seg->io_linkage);
-	}
-}
-
-/**
-   Coalesces the IO segments from a number of IO fops to create a list
-   of IO segments containing merged segments.
-   @param aggr_list - list of IO segments which gets populated during
-   this operation.
-*/
-static int io_fop_segments_coalesce(struct c2_fop_io_vec *iovec,
-		struct c2_list *aggr_list)
-{
-	uint32_t		i;
-	int			rc = 0;
-	uint32_t		segs_nr;
-	struct c2_io_ioseg	ioseg;
-
-	C2_PRE(iovec != NULL);
-	C2_PRE(aggr_list != NULL);
-
-	/* For each segment from incoming IO vector, check if it can
-	   be merged with any of the existing segments from aggr_list.
-	   If yes, merge it else, add a new entry in aggr_list. */
-	segs_nr = iovec->iv_count;
-	for (i = 0; i < segs_nr; ++i) {
-		ioseg.rw_seg = &iovec->iv_segs[i];
-		io_fop_seg_coalesce(&ioseg, aggr_list);
-	}
-
-	return rc;
-}
-
-/**
-   Coalesces the IO vectors of a list of read/write fops into IO vector
-   of given resultant fop. At a time, all fops in the list are either
-   read fops or write fops. Both fop types can not be present simultaneously.
-
-   @param fop_list - list of fops. These structures contain either read or
-   write fops. Both fop types can not be present in the fop_list simultaneously.
-   @param res_fop - resultant fop with which the resulting IO vector is
-   associated.
-   @param bkpfop - A fop used to store the original IO vector of res_fop
-   whose IO vector is replaced by the coalesced IO vector.
-   from resultant fop and it is restored on receving the reply of this
-   coalesced IO request. @see io_fop_iovec_restore.
- */
-static int io_fop_coalesce(const struct c2_list *fop_list,
-		struct c2_fop *res_fop, struct c2_fop *bkp_fop)
-{
-	int			 res;
-	int			 i = 0;
-	uint64_t		 curr_segs;
-	struct c2_fop		*fop;
-	struct c2_list		 aggr_list;
-	struct c2_io_ioseg	*ioseg;
-	struct c2_io_ioseg	*ioseg_next;
-	struct c2_io_ioseg	 res_ioseg;
-	struct c2_fop_type	*fopt;
-	struct c2_fop_io_vec	*iovec;
-	struct c2_fop_io_vec	*bkp_vec;
-	struct c2_fop_io_vec	*res_iovec;
-
-	C2_PRE(fop_list != NULL);
-	C2_PRE(res_fop != NULL);
-
-	fopt = res_fop->f_type;
-	C2_PRE(is_io(res_fop));
-
-        /* Make a copy of original IO vector belonging to res_fop and place
-           it in input parameter vec which can be used while restoring the
-           IO vector. */
-	bkp_fop = c2_fop_alloc(fopt, NULL);
-	if (bkp_fop == NULL)
-		return -ENOMEM;
-
-	c2_list_init(&aggr_list);
-
-	/* Traverse the fop_list, get the IO vector from each fop,
-	   pass it to a coalescing routine and get result back
-	   in another list. */
-	c2_list_for_each_entry(fop_list, fop, struct c2_fop, f_link) {
-		iovec = iovec_get(fop);
-		res = io_fop_segments_coalesce(iovec, &aggr_list);
-	}
-
-	/* Allocate a new generic IO vector and copy all (merged) IO segments
-	   to the new vector and make changes to res_fop accordingly. */
-	C2_ALLOC_PTR(res_iovec);
-	if (res_iovec == NULL) {
-		res = -ENOMEM;
-		goto cleanup;
-	}
-
-	curr_segs = c2_list_length(&aggr_list);
-	res = iosegs_alloc(res_iovec, curr_segs);
-	if (res != 0)
-		goto cleanup;
-	res_iovec->iv_count = curr_segs;
-
-	c2_list_for_each_entry_safe(&aggr_list, ioseg, ioseg_next,
-			struct c2_io_ioseg, io_linkage) {
-		res_ioseg.rw_seg = &res_iovec->iv_segs[i];
-		*res_ioseg.rw_seg = *ioseg->rw_seg;
-		ioseg_unlink_free(ioseg);
-		i++;
-	}
-	c2_list_fini(&aggr_list);
-	res_iovec->iv_count = i;
-
-	iovec = iovec_get(res_fop);
-	bkp_vec = iovec_get(bkp_fop);
-	*bkp_vec = *iovec;
-	*iovec = *res_iovec;
-	return res;
-cleanup:
-	C2_ASSERT(res != 0);
-	if (res_iovec != NULL)
-		c2_free(res_iovec);
-	c2_list_for_each_entry_safe(&aggr_list, ioseg, ioseg_next,
-				    struct c2_io_ioseg, io_linkage)
-		ioseg_unlink_free(ioseg);
-	c2_list_fini(&aggr_list);
-	return res;
-}
-
-/**
-   Restores the original IO vector of parameter fop from the appropriate
-   IO vector from parameter bkpfop.
-   @param fop - Incoming fop. This fop is same as res_fop parameter from
-   the subroutine io_fop_coalesce. @see io_fop_coalesce.
-   @param bkpfop - Backup fop with which the original IO vector of
-   coalesced fop was stored.
- */
-static void io_fop_iovec_restore(struct c2_fop *fop, struct c2_fop *bkpfop)
-{
-	struct c2_fop_io_vec *vec;
-
-	C2_PRE(fop != NULL);
-	C2_PRE(bkpfop != NULL);
-
-	vec = iovec_get(fop);
-	c2_free(vec->iv_segs);
-	*vec = *(iovec_get(bkpfop));
-	c2_fop_free(bkpfop);
-}
-
-/**
-   Returns the fid of given IO fop.
-   @note This method only works for read and write IO fops.
-   @retval On-wire fid of given fop.
- */
-static struct c2_fop_file_fid *io_fop_fid_get(struct c2_fop *fop)
-{
-	return &(io_rw_get(fop))->crw_fid;
-}
-
-/**
-   Returns if given 2 fops refer to same fid. The fids mentioned here
-   are on-wire fids.
-   @retval true if both fops refer to same fid, false otherwise.
- */
-static bool io_fop_fid_equal(struct c2_fop *fop1, struct c2_fop *fop2)
-{
-	struct c2_fop_file_fid *ffid1;
-	struct c2_fop_file_fid *ffid2;
-
-	C2_PRE(fop1 != NULL);
-	C2_PRE(fop2 != NULL);
-
-	ffid1 = io_fop_fid_get(fop1);
-	ffid2 = io_fop_fid_get(fop2);
-
-	return (ffid1->f_seq == ffid2->f_seq && ffid1->f_oid == ffid2->f_oid);
-}
-
-/**
- * readv FOP operation vector.
- */
-const struct c2_fop_type_ops c2_io_cob_readv_ops = {
-	.fto_fop_replied = NULL,
-	.fto_size_get = c2_xcode_fop_size_get,
-	.fto_op_equal = io_fop_type_equal,
-	.fto_fid_equal = io_fop_fid_equal,
-	.fto_get_nfragments = io_fop_fragments_nr_get,
-	.fto_io_coalesce = io_fop_coalesce,
-	.fto_iovec_restore = io_fop_iovec_restore,
-};
-
-/**
- * writev FOP operation vector.
- */
-const struct c2_fop_type_ops c2_io_cob_writev_ops = {
-	.fto_fop_replied = NULL,
-	.fto_size_get = c2_xcode_fop_size_get,
-	.fto_op_equal = io_fop_type_equal,
-	.fto_fid_equal = io_fop_fid_equal,
-	.fto_get_nfragments = io_fop_fragments_nr_get,
-	.fto_io_coalesce = io_fop_coalesce,
-	.fto_iovec_restore = io_fop_iovec_restore,
-};
-
-/**
  * readv and writev reply FOP operation vector.
  */
-const struct c2_fop_type_ops c2_io_rwv_rep_ops = {
-	.fto_size_get = c2_xcode_fop_size_get
+struct c2_fop_type_ops c2_io_rwv_rep_ops = {
+	.fto_fom_init = c2_io_fop_cob_rwv_rep_fom_init,
 };
 
 /**
  * FOP definitions for readv and writev operations.
  */
-
-C2_FOP_TYPE_DECLARE_OPS(c2_fop_cob_readv, "Read request", &c2_io_cob_readv_ops,
-			C2_IOSERVICE_READV_OPCODE, C2_RPC_ITEM_TYPE_REQUEST,
-			&rpc_item_iov_type_ops);
-C2_FOP_TYPE_DECLARE_OPS(c2_fop_cob_writev, "Write request",
-			&c2_io_cob_writev_ops,
-			C2_IOSERVICE_WRITEV_OPCODE, C2_RPC_ITEM_TYPE_REQUEST,
-			&rpc_item_iov_type_ops);
-
+C2_FOP_TYPE_DECLARE(c2_fop_cob_readv, "Read request", 
+		    c2_io_service_readv_opcode, &c2_io_cob_readv_ops);
+C2_FOP_TYPE_DECLARE(c2_fop_cob_writev, "Write request", 
+		    c2_io_service_writev_opcode, &c2_io_cob_writev_ops);
 /**
  * FOP definitions of readv and writev reply FOPs.
  */
-C2_FOP_TYPE_DECLARE_OPS(c2_fop_cob_writev_rep, "Write reply",
-			&c2_io_rwv_rep_ops, C2_IOSERVICE_WRITEV_REP_OPCODE,
-			C2_RPC_ITEM_TYPE_REPLY, &rpc_item_iov_type_ops);
-C2_FOP_TYPE_DECLARE_OPS(c2_fop_cob_readv_rep, "Read reply",
-			&c2_io_rwv_rep_ops, C2_IOSERVICE_READV_REP_OPCODE,
-			C2_RPC_ITEM_TYPE_REPLY,  &rpc_item_iov_type_ops);
-
-static struct c2_fop_type_format *ioservice_fmts[] = {
-	&c2_fop_file_fid_tfmt,
-	&c2_fop_io_buf_tfmt,
-	&c2_fop_io_seg_tfmt,
-	&c2_fop_io_vec_tfmt,
-	&c2_fop_cob_rw_tfmt,
-	&c2_fop_cob_rw_reply_tfmt,
-};
+C2_FOP_TYPE_DECLARE(c2_fop_cob_writev_rep, "Write reply", 
+		    c2_io_service_writev_rep_opcode, &c2_io_rwv_rep_ops);
+C2_FOP_TYPE_DECLARE(c2_fop_cob_readv_rep, "Read reply", 
+		    c2_io_service_readv_rep_opcode, &c2_io_rwv_rep_ops);
 
-static struct c2_fop_type *ioservice_fops[] = {
-	&c2_fop_cob_readv_fopt,
-	&c2_fop_cob_writev_fopt,
-	&c2_fop_cob_readv_rep_fopt,
-	&c2_fop_cob_writev_rep_fopt,
-};
-
-int c2_ioservice_fops_nr(void)
-{
-	return ARRAY_SIZE(ioservice_fops);
-}
-
-void c2_ioservice_fop_fini(void)
-{
-	c2_fop_type_fini_nr(ioservice_fops, ARRAY_SIZE(ioservice_fops));
-	c2_fop_type_format_fini_nr(ioservice_fmts, ARRAY_SIZE(ioservice_fmts));
-}
-
-int c2_ioservice_fop_init(void)
-{
-	int rc;
-
-	rc = c2_fop_type_format_parse_nr(ioservice_fmts,
-			ARRAY_SIZE(ioservice_fmts));
-	if (rc == 0)
-		rc = c2_fop_type_build_nr(ioservice_fops,
-				ARRAY_SIZE(ioservice_fops));
-	if (rc != 0)
-		c2_ioservice_fop_fini();
-	return rc;
-}
-
-struct io_zeroseg *io_zeroseg_alloc(void)
-{
-	struct io_zeroseg *zseg;
-
-	C2_ALLOC_PTR(zseg);
-	if (zseg == NULL)
-		return NULL;
-
-	c2_list_link_init(&zseg->is_linkage);
-	return zseg;
-}
-
-void io_zeroseg_free(struct io_zeroseg *zseg)
-{
-	C2_PRE(zseg != NULL);
-
-	c2_list_link_fini(&zseg->is_linkage);
-	c2_free(zseg);
-}
-
-void io_zerovec_seg_get(const struct c2_0vec *zvec, uint32_t seg_index,
-			struct io_zeroseg *seg)
-{
-	C2_PRE(seg != NULL);
-	C2_PRE(seg_index < zvec->z_bvec.ov_vec.v_nr);
-
-	seg->is_off = zvec->z_index[seg_index];
-	seg->is_count = zvec->z_bvec.ov_vec.v_count[seg_index];
-	seg->is_buf = zvec->z_bvec.ov_buf[seg_index];
-}
+#ifdef __KERNEL__
 
-void io_zerovec_seg_set(struct c2_0vec *zvec, uint32_t seg_index,
-			const struct io_zeroseg *seg)
+/** Placeholder API for c2t1fs build. */
+int c2_io_fop_cob_rwv_fom_init(struct c2_fop *fop, struct c2_fop_ctx *ctx, 
+                               struct c2_fom **m)
 {
-	C2_PRE(seg != NULL);
-	C2_PRE(seg_index < zvec->z_bvec.ov_vec.v_nr);
-
-	zvec->z_bvec.ov_buf[seg_index] = seg->is_buf;
-	zvec->z_index[seg_index] = seg->is_off;
-	zvec->z_bvec.ov_vec.v_count[seg_index] = seg->is_count;
+	return 0;
 }
 
-int io_zerovec_segs_alloc(struct c2_0vec *zvec, uint32_t segs_nr)
-{
-	C2_PRE(zvec != NULL);
-	C2_PRE(segs_nr != 0);
-
-	C2_ALLOC_ARR(zvec->z_bvec.ov_buf, segs_nr);
-	return zvec->z_bvec.ov_buf == NULL ? -ENOMEM : 0;
-}
+#endif
 
-/*
+/* 
  *  Local variables:
  *  c-indentation-style: "K&R"
  *  c-basic-offset: 8
diff --git a/ioservice/io_fops.ff b/ioservice/io_fops.ff
index cb591bf..6e23f9f 100644
--- a/ioservice/io_fops.ff
+++ b/ioservice/io_fops.ff
@@ -1,39 +1,19 @@
 /* -*- C -*- */
 
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Anand Vidwansa <Anand_Vidwansa@xyratex.com>
- *                  Anup Barve <Anup_Barve@xyratex.com>
- * Original creation date: 03/21/2011
- */
-
 /**
- * @defgroup io_fops FOPs for Data Operations
- *
- * This component contains the File Operation Packets (FOP) definitions
+ * @defgroup io_fops FOPs for Data Operations 
+ * 
+ * This component contains the File Operation Packets(FOP) definitions 
  * for following operations
  * - readv
  * - writev
- *
+ * 
  * It describes the FOP formats along with brief description of the flow.
  *
- * Note: As authorization is carried on server, all request FOPs
+ * Note: As authorization is carried on server, all request FOPs 
  * contain uid and gid. For authentication, nid is included in every FOP.
  * This is to serve very primitive authentication for now.
- *
+ * 
  * @{
  */
 
@@ -47,109 +27,124 @@
  * @section IO FOP Definitions
  */
 DEF(c2_fop_file_fid, RECORD,
-	/** Sequence number for given fid. */
 	_(f_seq, U64),
-	/** Object Index for given fid. */
 	_(f_oid, U64));
-
+	
 /**
  * c2_fop_io_buf is a buffer with a count specifying its length.
  */
 DEF(c2_fop_io_buf, SEQUENCE,
-	/** Number of bytes in the buffer. */
-	_(ib_count, U64),
-	/** Starting address of buffer. */
-	_(ib_buf, BYTE));
+	_(f_count, U32),
+	_(f_buf, BYTE));
 
 /**
- * c2_fop_io_seg is a record containing details of an IO operation.
+ * Plain identifier for an IO segment.
+ * This does not include any buffer, just a skeleton.
  */
-DEF(c2_fop_io_seg, RECORD,
-	/** Offset within component object.*/
-	_(is_offset, U64),
-	/** Data buffer attached with IO segment. */
-	_(is_buf, c2_fop_io_buf));
+DEF(c2_fop_segment, RECORD,
+	_(f_offset, U64),
+	_(f_count, U64));
 
 /**
- * c2_fop_io_vec is a vector of c2_fop_io_seg with number of such segments.
+ * c2_fop_io_seg is a record containing details of an IO operation.
+ * <br> List of fields  
+ * @li offset : offset within component object.
+ * @li count : count in bytes.
+ * @li Data buffer
  */
-DEF(c2_fop_io_vec, SEQUENCE,
-	/** Number of IO segments. */
-	_(iv_count, U32),
-	/** Array of IO segments. */
-	_(iv_segs, c2_fop_io_seg));
+DEF(c2_fop_io_seg, RECORD,
+	_(f_offset, U64),
+	_(f_buf, c2_fop_io_buf));
 
 /**
- * A common sub structure to be referred by read and write reply fops.
+ * c2_fop_io_vec is a vector of c2_fop_io_seg with number of such segments.
+ * <br> List of fields  
+ * @li Array of IO segments.
+ * @li count: Number of segments in array.
  */
-DEF(c2_fop_cob_rw_reply, RECORD,
-	/** Status code of operation. */
-	_(rwr_rc, U32),
-	/** Number of bytes read or written. */
-	_(rwr_count, U64));
+DEF(c2_fop_io_vec, RECORD,
+	_(iov_count, U32),
+	_(iov_seg, c2_fop_io_seg));
 
 /**
  * Reply FOP for a readv request.
+ * <br> List of fields
+ * @li rc: status code
+ * @li buf: Buffer in which read data is returned.
  */
 DEF(c2_fop_cob_readv_rep, RECORD,
-	/** Common read/write reply. */
-	_(c_rep, c2_fop_cob_rw_reply),
-	/** At the moment, due to some constraints put up by kxdr wrapper
-	   around sunrpc, we can't have an IO vector here. It has to be
-	   a SEQUENCE of bytes. Eventually, this will be replaced by
-	   an IO vector or rather a net buffer descriptor. */
-	_(c_iobuf, c2_fop_io_buf));
+	_(frdr_rc, U32),
+	_(frdr_buf, c2_fop_io_buf));
 
 /**
- * Common structure for read and write request fops.
- */
-DEF(c2_fop_cob_rw, RECORD,
-	/** File identifier of read/write request. */
-	_(crw_fid, c2_fop_file_fid),
-	/** IO vector containing read/write data. */
-	_(crw_iovec, c2_fop_io_vec),
-	/** Miscellaneous flags. */
-	_(crw_flags, U64));
-
-/**
- * This fop is representation of a read component object request.
- * The c2_fop_cob_readv FOP is sent by client to the Data server.
+ * <b> c2_fop_cob_readv </b>
+ * is a representation of a read component object request.
+ * <p> The c2_fop_cob_readv FOP is sent by client to the Data server.
  * The FOP supplies the stob id on which the read has to be performed.
- * The IO vector signifies the region within Component Object on which IO
+ * The IO vector signifies the region within Component Object on which IO 
  * has to be performed.
- * On completion, the reply FOP (c2_fop_cob_readv_rep) is created
+ * On completion, the reply FOP (c2_fop_cob_io_rep) is created 
  * and sent to the client.
+ * <br> List of fields  
+ * @li storage object Identifier
+ * @li IO vector 
+ * @li miscellaneous flags
+ * @li uid, gid for authorization
  */
 DEF(c2_fop_cob_readv, RECORD,
-	/** Common definition of read/write fops. */
-	_(c_rwv, c2_fop_cob_rw));
+	_(frd_foprep, U64),
+	_(frd_fid, c2_fop_file_fid),
+	_(frd_ioseg, c2_fop_segment),
+	_(frd_uid, U64),
+	_(frd_gid, U64),
+	_(frd_nid, U64),
+	_(frd_flags, U64));
 
 /**
- * Reply FOP for writev FOPs.
- * The c2_fop_cob_writev_rep FOP is sent as a response by the
+ * <b> c2_fop_cob_writev_rep </b>
+ * This is reply FOP for writev FOPs
+ * <p> The c2_fop_cob_writev_rep FOP is sent as a response by the 
  * Data server to a client.
  * It contains the status code and number of bytes written.
+ * <br> List of fields  
+ * @li rc: status code. Non-zero value indicates error code.
+ * @li number of bytes written.
+ * rc = 0 indicates successful completion
+ * rc > 0 indicates error code.
  */
 DEF(c2_fop_cob_writev_rep, RECORD,
-	/** Common read/write reply structure. */
-	_(c_rep, c2_fop_cob_rw_reply));
+	_(fwrr_nid, U64),
+	_(fwrr_rc, U32),
+	_(fwrr_count, U64));	
 
 /**
- * The c2_fop_cob_writev FOP is used to send write requests by a
+ * <b> c2_fop_cob_writev </b>
+ * <p> The c2_fop_cob_writev FOP is used to send write requests by a 
  * client to a Data server.
  * The FOP supplies the stob id on which the write has to be performed.
- * The IO vector signifies the region within Component Object on which IO
+ * The IO vector signifies the region within Component Object on which IO 
  * has to be performed.
- * On completion, the reply FOP (c2_fop_cob_writev_rep) is created
+ * On completion, the reply FOP (c2_fop_cob_io_rep) is created 
  * and sent to the client.
+ * <br> List of fields  
+ * @li storage object Identifier
+ * @li IO vector 
+ * @li miscellaneous flags
+ * @li uid, gid for authorization
  */
 DEF(c2_fop_cob_writev, RECORD,
-	/** Common definition of read/write fops. */
-	_(c_rwv, c2_fop_cob_rw));
+	_(fwr_foprep, U64),
+	_(fwr_fid, c2_fop_file_fid),
+	_(fwr_iovec, c2_fop_io_vec),
+	_(fwr_uid, U64),
+	_(fwr_gid, U64),
+	_(fwr_nid, U64),
+	_(fwr_flags, U64));
+
 
 /** @} end of FOP_data_ops */
 
-/*
+/* 
  *  Local variables:
  *  c-indentation-style: "K&R"
  *  c-basic-offset: 8
diff --git a/ioservice/io_fops.h b/ioservice/io_fops.h
index 201278f..3497f64 100644
--- a/ioservice/io_fops.h
+++ b/ioservice/io_fops.h
@@ -15,136 +15,53 @@
  * http://www.xyratex.com/contact
  *
  * Original author: Anand Vidwansa <Anand_Vidwansa@xyratex.com>
- *                  Anup Barve <Anup_Barve@xyratex.com>
  * Original creation date: 03/21/2011
  */
 #ifndef __COLIBRI_IOSERVICE_IO_FOPS_H__
 #define __COLIBRI_IOSERVICE_IO_FOPS_H__
 
-#include "fop/fop_base.h"
-#include "fop/fop_format.h"
-#include "lib/list.h"
 #include "fop/fop.h"
+#include "fop/fop_format.h"
+#include "lib/memory.h"
 
-/**
-   @addtogroup io_fops
-   In-memory definition of generic io fop and generic io segment.
- */
-struct page;
-struct c2_io_ioseg;
-
-/**
-   Returns the number of fops registered by ioservice.
- */
-int c2_ioservice_fops_nr(void);
-
-/**
-   Init and fini of ioservice fops code.
- */
-int c2_ioservice_fop_init(void);
-void c2_ioservice_fop_fini(void);
-
-/**
-   This data structure is used to associate an io fop with its
-   rpc bulk data. It abstracts the c2_net_buffer and net layer APIs.
-   Client side implementations use this structure to represent
-   io fops and the associated rpc bulk structures.
-
-   @todo Not complete yet. Need to build ops around c2_io_fop.
- */
-struct c2_io_fop {
-	/** Inline fop for a generic IO fop. */
-	struct c2_fop		if_fop;
-	/** Bulk structure containing zero vector for io fop. */
-	struct c2_rpc_bulk	if_bulk;
-};
+struct c2_fom;
+struct c2_fom_type;
 
-/**
-   Generic io segment that represents a contiguous stream of bytes
-   along with io extent. This structure is typically used by io coalescing
-   code from ioservice.
+/** 
+ * The opcode from which IO service FOPS start.
  */
-struct io_zeroseg {
-	/* Offset of target object to start io from. */
-	c2_bindex_t		 is_off;
-	/* Number of bytes in io segment. */
-	c2_bcount_t		 is_count;
-	/* Starting address of buffer. */
-	void			*is_buf;
-	/* Linkage to have such zero segments in a list. */
-	struct c2_list_link	 is_linkage;
+enum c2_io_service_opcodes {
+	c2_io_service_readv_opcode = 15,
+	c2_io_service_writev_opcode,
+	c2_io_service_writev_rep_opcode = 25,
+	c2_io_service_readv_rep_opcode
 };
 
-/**
-   Allocate a zero segment.
-   @retval Valid io_zeroseg object if success, NULL otherwise.
- */
-struct io_zeroseg *io_zeroseg_alloc(void);
-
-/**
-   Deallocate a zero segment.
-   @param zseg - Zero segment to be deallocated.
+/** 
+ * Bunch of externs needed for stob/ut/io_fop_init.c code. 
  */
-void io_zeroseg_free(struct io_zeroseg *zseg);
+extern struct c2_fop_type_ops c2_io_cob_readv_ops;
+extern struct c2_fop_type_ops c2_io_cob_writev_ops;
+extern struct c2_fop_type_ops c2_io_rwv_rep_ops;
 
 /**
-   Get the io segment indexed by index in array of io segments in zerovec.
-   @note The incoming c2_0vec should be allocated and initialized.
-
-   @param zvec The c2_0vec io vector from which io segment will be retrieved.
-   @param index Index of io segments in array of io segments from zerovec.
-   @param seg Out parameter to return io segment.
- */
-void io_zerovec_seg_get(const struct c2_0vec *zvec, uint32_t index,
-			struct io_zeroseg *seg);
-
-/**
-   Set the io segment referred by index into array of io segments from
-   the zero vector.
-   @note There is no data copy here. Just buffer pointers are copied since
-   this API is supposed to be used in same address space.
-
-   @note The incoming c2_0vec should be allocated and initialized.
-   @param zvec The c2_0vec io vector whose io segment will be changed.
-   @param seg Target segment for set.
- */
-void io_zerovec_seg_set(struct c2_0vec *zvec, uint32_t index,
-			const struct io_zeroseg *seg);
-
-/**
-   Allocate the io segments for the given c2_0vec structure.
-   @note The incoming c2_0vec should be allocated and initialized.
-   @param zvec The c2_0vec structure.
-   @param segs_nr Number of io segments to be allocated.
- */
-int io_zerovec_segs_alloc(struct c2_0vec *zvec, uint32_t segs_nr);
-
-/**
- * FOP definitions and corresponding fop type formats
+ * FOP definitions and corresponding fop type formats 
  * exported by ioservice.
  */
 extern struct c2_fop_type_format c2_fop_cob_writev_tfmt;
 extern struct c2_fop_type_format c2_fop_cob_readv_tfmt;
 extern struct c2_fop_type_format c2_fop_cob_writev_rep_tfmt;
 extern struct c2_fop_type_format c2_fop_cob_readv_rep_tfmt;
-extern struct c2_fop_type_format c2_fop_file_fid_tfmt;
-extern struct c2_fop_type_format c2_fop_io_buf_tfmt;
-extern struct c2_fop_type_format c2_fop_io_seg_tfmt;
-extern struct c2_fop_type_format c2_fop_io_vec_tfmt;
-extern struct c2_fop_type_format c2_fop_cob_rw_tfmt;
-extern struct c2_fop_type_format c2_fop_cob_rw_reply_tfmt;
 
 extern struct c2_fop_type c2_fop_cob_readv_fopt;
 extern struct c2_fop_type c2_fop_cob_writev_fopt;
 extern struct c2_fop_type c2_fop_cob_readv_rep_fopt;
 extern struct c2_fop_type c2_fop_cob_writev_rep_fopt;
 
-/** @} end of io_fops group */
-
 /* __COLIBRI_IOSERVICE_IO_FOPS_H__ */
 #endif
 
-/*
+/* 
  *  Local variables:
  *  c-indentation-style: "K&R"
  *  c-basic-offset: 8
@@ -153,3 +70,4 @@ extern struct c2_fop_type c2_fop_cob_writev_rep_fopt;
  *  scroll-step: 1
  *  End:
  */
+
diff --git a/ioservice/ut/Makefile.am b/ioservice/ut/Makefile.am
deleted file mode 100644
index eadb71a..0000000
--- a/ioservice/ut/Makefile.am
+++ /dev/null
@@ -1,3 +0,0 @@
-noinst_LTLIBRARIES   = libcfm-ut.la
-libcfm_ut_la_SOURCES  = cobfid_map.c
-INCLUDES             = -I. -I$(top_srcdir) -I$(top_srcdir)/include
diff --git a/ioservice/ut/cobfid_map.c b/ioservice/ut/cobfid_map.c
deleted file mode 100644
index 045cf6c..0000000
--- a/ioservice/ut/cobfid_map.c
+++ /dev/null
@@ -1,689 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Anup Barve <Anup_Barve@xyratex.com>
- * Original creation date: 10/11/2011
- */
-
-#ifdef HAVE_CONFIG_H
-#  include <config.h>
-#endif
-
-#include "ioservice/cobfid_map.h"
-#include "lib/ut.h"
-#include "lib/memory.h"
-#include "lib/arith.h"
-
-/* Number of records to be enumerated */
-enum {
-	SINGLE_BUF_REC_NR = 16,
-	MULTIPLE_BUF_REC_NR = 351
-};
-
-/* Type of enumeration */
-enum {
-	ENUM_CONTAINER,
-	ENUM_MAP
-};
-
-/* DB paths for various databases */
-static const char single_buf_cont_enum_path[] = "./cfm_map_single_buf_ce";
-static const char multiple_buf_cont_enum_path[] = "./cfm_map_multiple_buf_ce";
-static const char single_buf_map_enum_path[] = "./cfm_map_single_buf_me";
-static const char multiple_buf_map_enum_path[] = "./cfm_map_multiple_buf_me";
-static const char iter_test_map[] = "./cfm_map_iter_test";
-static const char concurrency_test_map[] = "./cfm_map_concurrency_test";
-
-/*
-   Generic enumeration routine, used by all the tests.
-   The parameters are :
-   rec_total: Total number of records to be inserted and enumerated
-   map_path : Database path used for the addition and enumeration
-   etype    : Enumeration type (either map or container)
-   check_persistence : Flag to check the database persistence
- */
-static void enumerate_generic(const int rec_total, const char *map_path,
-			      const int etype, const bool check_persistence)
-{
-	int			 i;
-	int			 j;
-	int			 rc;
-	int			 rec_nr;
-	uint64_t		 container_id_in;
-	uint64_t		 container_id_out;
-	uint64_t		*cid_in;
-	uint64_t		*cid_out;
-	struct c2_fid		*fid_in;
-	struct c2_fid		*fid_out;
-	struct c2_uint128	*cob_fid_in;
-	struct c2_uint128	*cob_fid_out;
-	struct c2_dbenv		 cfm_dbenv;
-	struct c2_addb_ctx	 cfm_addb_ctx;
-	struct c2_cobfid_map	 cfm_map;
-	struct c2_cobfid_map_iter cfm_iter;
-
-	/* Reset any existing database */
-	rc = c2_ut_db_reset(map_path);
-	C2_UT_ASSERT(rc == 0);
-
-	/* Initialise the database with given path */
-        rc = c2_dbenv_init(&cfm_dbenv, map_path, 0);
-	C2_UT_ASSERT(rc == 0);
-
-	/* Initialize the map */
-	rc = c2_cobfid_map_init(&cfm_map, &cfm_dbenv, &cfm_addb_ctx,
-				"cfm_map_table");
-	C2_UT_ASSERT(rc == 0);
-
-	/* Allocate the input and output key-value arrays with total number
-	   of records.
-	   - Input arrays are populated during insertion operation.
-	   - Corresponding output key-value arrays are populated
-	     during enumeration operation.
-	   - Input and Output arrays are compared at the end for equality */
-	C2_ALLOC_ARR(fid_in, rec_total);
-	C2_UT_ASSERT(fid_in != NULL);
-
-	C2_ALLOC_ARR(cob_fid_in, rec_total);
-	C2_UT_ASSERT(cob_fid_in != NULL);
-
-	C2_ALLOC_ARR(fid_out, rec_total);
-	C2_UT_ASSERT(fid_out != NULL);
-
-	C2_ALLOC_ARR(cob_fid_out, rec_total);
-	C2_UT_ASSERT(cob_fid_out != NULL);
-
-	/* Allocate the container arrays only for map enumeration. Use constant
-	   container id for container enumeration*/
-	if (etype == ENUM_MAP) {
-		C2_ALLOC_ARR(cid_in, rec_total);
-		C2_UT_ASSERT(cid_in != NULL);
-
-		C2_ALLOC_ARR(cid_out, rec_total);
-		C2_UT_ASSERT(cid_out != NULL);
-	} else
-		container_id_in = 200;
-	j = rec_total - 1;
-
-	/* Fill in the database with varying fid values in
-	   decreasing order of fid key. This is done on purpose to test the
-	   ordering property where enumeration should be done in increasing
-	   order of the fid key.*/
-	for (i = 0; i < rec_total; i++) {
-		/* Populate some random data */
-		fid_in[i].f_container = 0;
-		fid_in[i].f_key = j;
-		cob_fid_in[i].u_hi = 333;
-		cob_fid_in[i].u_lo = j;
-
-
-		if (etype == ENUM_MAP) {
-			cid_in[i] = j;
-			rc = c2_cobfid_map_add(&cfm_map, cid_in[i],
-					       fid_in[i], cob_fid_in[i]);
-		} else
-			rc = c2_cobfid_map_add(&cfm_map, container_id_in,
-					       fid_in[i], cob_fid_in[i]);
-
-		C2_UT_ASSERT(rc == 0);
-		j--;
-	}
-
-	/* Finalise the DB environment, transaction and cobfid_map,
-	   and reinitialize to check database persistence */
-	if (check_persistence) {
-		c2_cobfid_map_fini(&cfm_map);
-		c2_dbenv_fini(&cfm_dbenv);
-
-		/* Initialise the database with given path */
-		rc = c2_dbenv_init(&cfm_dbenv, map_path, 0);
-		C2_UT_ASSERT(rc == 0);
-
-		/* Initialize the map */
-		rc = c2_cobfid_map_init(&cfm_map, &cfm_dbenv, &cfm_addb_ctx,
-					"cfm_map_table");
-		C2_UT_ASSERT(rc == 0);
-
-	}
-
-	rec_nr = 0;
-	/* Container enumeration */
-	if (etype == ENUM_CONTAINER) {
-		rc = c2_cobfid_map_container_enum(&cfm_map, container_id_in,
-						  &cfm_iter);
-		C2_UT_ASSERT(rc == 0);
-		while ((rc = c2_cobfid_map_iter_next(&cfm_iter,
-						&container_id_out,
-						&fid_out[rec_nr],
-						&cob_fid_out[rec_nr])) == 0) {
-			rec_nr++;
-		}
-		C2_UT_ASSERT(cfm_iter.cfmi_error == -ENOENT);
-		C2_UT_ASSERT(rc == -ENOENT);
-	} else if (etype == ENUM_MAP) { /* Map enumeration */
-		rc = c2_cobfid_map_enum(&cfm_map, &cfm_iter);
-		C2_UT_ASSERT(rc == 0);
-		while ((rc = c2_cobfid_map_iter_next(&cfm_iter,
-						&cid_out[rec_nr],
-						&fid_out[rec_nr],
-						&cob_fid_out[rec_nr])) == 0) {
-			rec_nr++;
-		}
-		C2_UT_ASSERT(cfm_iter.cfmi_error == -ENOENT);
-		C2_UT_ASSERT(rc == -ENOENT);
-	}
-
-	c2_cobfid_map_iter_fini(&cfm_iter);
-
-	/* Check if number of records enumerated is same as number of records
-	   inserted */
-	C2_UT_ASSERT(rec_nr == rec_total);
-
-	/* Check if the fid and cob input arrays are exact reverse of their
-	   corresponding out counterparts. Also check the cid array in case
-	   of map enumeration*/
-	for (i = 0; i < rec_total; i++) {
-		C2_UT_ASSERT(c2_fid_eq(&fid_in[i],
-				       &fid_out[rec_total - 1 - i]));
-		C2_UT_ASSERT(c2_uint128_eq(&cob_fid_in[i],
-					   &cob_fid_out[rec_total - 1 - i]));
-		if (etype == ENUM_MAP) {
-			C2_UT_ASSERT(C2_3WAY(cid_in[i],
-					     cid_out[rec_total - 1 - i] == 0));
-		}
-	}
-
-	c2_free(fid_in);
-	c2_free(cob_fid_in);
-	c2_free(fid_out);
-	c2_free(cob_fid_out);
-
-	if (etype == ENUM_MAP) {
-		c2_free(cid_in);
-		c2_free(cid_out);
-	}
-
-	c2_cobfid_map_fini(&cfm_map);
-	c2_dbenv_fini(&cfm_dbenv);
-
-	rc = c2_ut_db_reset(map_path);
-	C2_UT_ASSERT(rc == 0);
-}
-
-/* Container enumeration - single buffer fetch by iterator */
-static void ce_single_buf(void)
-{
-	/* Do not check database persistence */
-	enumerate_generic(SINGLE_BUF_REC_NR, single_buf_cont_enum_path,
-			  ENUM_CONTAINER, false);
-	/* Check database persistence */
-	enumerate_generic(SINGLE_BUF_REC_NR, single_buf_cont_enum_path,
-			  ENUM_CONTAINER, true);
-}
-
-/* Container enumeration - multiple buffer fetches by iterator */
-static void ce_multiple_buf(void)
-{
-	/* Do not check database persistence */
-	enumerate_generic(MULTIPLE_BUF_REC_NR, multiple_buf_cont_enum_path,
-			  ENUM_CONTAINER, false);
-	/* Check database persistence */
-	enumerate_generic(MULTIPLE_BUF_REC_NR, multiple_buf_cont_enum_path,
-			  ENUM_CONTAINER, true);
-}
-
-/* Map enumeration - single buffer fetch by iterator */
-static void me_single_buf(void)
-{
-	/* Do not check database persistence */
-	enumerate_generic(SINGLE_BUF_REC_NR, single_buf_map_enum_path,
-			  ENUM_MAP, false);
-	/* Check database persistence */
-	enumerate_generic(SINGLE_BUF_REC_NR, single_buf_map_enum_path,
-			  ENUM_MAP, true);
-}
-
-/* Map enumeration - multiple buffer fetches by iterator */
-static void me_multiple_buf(void)
-{
-	/* Do not check database persistence */
-	enumerate_generic(MULTIPLE_BUF_REC_NR, multiple_buf_map_enum_path,
-			  ENUM_MAP, false);
-	/* Check database persistence */
-	enumerate_generic(MULTIPLE_BUF_REC_NR, multiple_buf_map_enum_path,
-			  ENUM_MAP, true);
-}
-
-/* Iterator sensitivity - test to ensure that an iterator behaves correctly
-   when records are inserted during its use. */
-static void test_iter_sensitivity(void)
-{
-	int			 rc;
-	uint64_t		 container_id_in;
-	uint64_t		 container_id_out;
-	struct c2_fid		 fid_in;
-	struct c2_fid		 fid_out;
-	struct c2_uint128	 cob_fid_in;
-	struct c2_uint128	 cob_fid_out;
-	struct c2_dbenv		 cfm_dbenv;
-	struct c2_addb_ctx	 cfm_addb_ctx;
-	struct c2_cobfid_map	 cfm_map;
-	struct c2_cobfid_map_iter cfm_iter;
-
-	/* Reset any existing database */
-	rc = c2_ut_db_reset(iter_test_map);
-	C2_UT_ASSERT(rc == 0);
-
-	/* Initialise the database with given path */
-        rc = c2_dbenv_init(&cfm_dbenv, iter_test_map, 0);
-	C2_UT_ASSERT(rc == 0);
-
-	/* Initialize the map */
-	rc = c2_cobfid_map_init(&cfm_map, &cfm_dbenv, &cfm_addb_ctx,
-				"cfm_map_table");
-	C2_UT_ASSERT(rc == 0);
-
-	/* Populate initial key-values */
-	container_id_in = 300;
-	fid_in.f_container = 0;
-	fid_in.f_key = 31;
-	cob_fid_in.u_hi = 0;
-	cob_fid_in.u_lo = 31;
-
-	/* Add31 - add key with fid.f_key = 31 */
-	rc = c2_cobfid_map_add(&cfm_map, container_id_in, fid_in, cob_fid_in);
-	C2_UT_ASSERT(rc == 0);
-
-	fid_in.f_key = 52;
-	cob_fid_in.u_lo = 52;
-
-	/* Add52 - add key with fid.f_key = 52 */
-	rc = c2_cobfid_map_add(&cfm_map, container_id_in, fid_in, cob_fid_in);
-	C2_UT_ASSERT(rc == 0);
-
-	fid_in.f_key = 73;
-	cob_fid_in.u_lo = 73;
-
-	/* Add73 - add key with fid.f_key = 73 */
-	rc = c2_cobfid_map_add(&cfm_map, container_id_in, fid_in, cob_fid_in);
-	C2_UT_ASSERT(rc == 0);
-
-	/* Open the iterator */
-	rc = c2_cobfid_map_container_enum(&cfm_map, container_id_in, &cfm_iter);
-	C2_UT_ASSERT(rc == 0);
-
-	/* Get31 */
-	rc = c2_cobfid_map_iter_next(&cfm_iter, &container_id_out, &fid_out,
-				     &cob_fid_out);
-	C2_UT_ASSERT(rc == 0);
-	C2_UT_ASSERT(fid_out.f_key == 31);
-	C2_UT_ASSERT(cob_fid_out.u_lo == 31);
-
-	fid_in.f_key = 94;
-	cob_fid_in.u_lo = 94;
-
-	/* Add94 - add key with fid.f_key = 94 */
-	rc = c2_cobfid_map_add(&cfm_map, container_id_in, fid_in, cob_fid_in);
-	C2_UT_ASSERT(rc == 0);
-
-	/* Get52 */
-	rc = c2_cobfid_map_iter_next(&cfm_iter, &container_id_out, &fid_out,
-				     &cob_fid_out);
-	C2_UT_ASSERT(rc == 0);
-	C2_UT_ASSERT(fid_out.f_key == 52);
-	C2_UT_ASSERT(cob_fid_out.u_lo == 52);
-
-	fid_in.f_key = 20;
-	cob_fid_in.u_lo = 20;
-
-	/* Add20 - add key with fid.f_key = 20 */
-	rc = c2_cobfid_map_add(&cfm_map, container_id_in, fid_in, cob_fid_in);
-	C2_UT_ASSERT(rc == 0);
-
-	/* Get73 */
-	rc = c2_cobfid_map_iter_next(&cfm_iter, &container_id_out, &fid_out,
-				     &cob_fid_out);
-	C2_UT_ASSERT(rc == 0);
-	C2_UT_ASSERT(fid_out.f_key == 73);
-	C2_UT_ASSERT(cob_fid_out.u_lo == 73);
-
-	fid_in.f_key = 87;
-	cob_fid_in.u_lo = 87;
-
-	/* Add87 - add key with fid.f_key = 87 */
-	rc = c2_cobfid_map_add(&cfm_map, container_id_in, fid_in, cob_fid_in);
-	C2_UT_ASSERT(rc == 0);
-
-	/* Get87 */
-	rc = c2_cobfid_map_iter_next(&cfm_iter, &container_id_out, &fid_out,
-				     &cob_fid_out);
-	C2_UT_ASSERT(rc == 0);
-	C2_UT_ASSERT(fid_out.f_key == 87);
-	C2_UT_ASSERT(cob_fid_out.u_lo == 87);
-
-	/* Get94 */
-	rc = c2_cobfid_map_iter_next(&cfm_iter, &container_id_out, &fid_out,
-				     &cob_fid_out);
-	C2_UT_ASSERT(rc == 0);
-	C2_UT_ASSERT(fid_out.f_key == 94);
-	C2_UT_ASSERT(cob_fid_out.u_lo == 94);
-
-	/* Close iterator */
-	c2_cobfid_map_iter_fini(&cfm_iter);
-
-	/* Open iterator */
-	rc = c2_cobfid_map_container_enum(&cfm_map, container_id_in, &cfm_iter);
-	C2_UT_ASSERT(rc == 0);
-
-	/* Get20 */
-	rc = c2_cobfid_map_iter_next(&cfm_iter, &container_id_out, &fid_out,
-				     &cob_fid_out);
-	C2_UT_ASSERT(rc == 0);
-	C2_UT_ASSERT(fid_out.f_key == 20);
-	C2_UT_ASSERT(cob_fid_out.u_lo == 20);
-
-	/* Get31 */
-	rc = c2_cobfid_map_iter_next(&cfm_iter, &container_id_out, &fid_out,
-				     &cob_fid_out);
-	C2_UT_ASSERT(rc == 0);
-	C2_UT_ASSERT(fid_out.f_key == 31);
-	C2_UT_ASSERT(cob_fid_out.u_lo == 31);
-
-	/* Get52 */
-	rc = c2_cobfid_map_iter_next(&cfm_iter, &container_id_out, &fid_out,
-				     &cob_fid_out);
-	C2_UT_ASSERT(rc == 0);
-	C2_UT_ASSERT(fid_out.f_key == 52);
-	C2_UT_ASSERT(cob_fid_out.u_lo == 52);
-
-	/* Get73 */
-	rc = c2_cobfid_map_iter_next(&cfm_iter, &container_id_out, &fid_out,
-				     &cob_fid_out);
-	C2_UT_ASSERT(rc == 0);
-	C2_UT_ASSERT(fid_out.f_key == 73);
-	C2_UT_ASSERT(cob_fid_out.u_lo == 73);
-
-	/* Get87 */
-	rc = c2_cobfid_map_iter_next(&cfm_iter, &container_id_out, &fid_out,
-				     &cob_fid_out);
-	C2_UT_ASSERT(rc == 0);
-	C2_UT_ASSERT(fid_out.f_key == 87);
-	C2_UT_ASSERT(cob_fid_out.u_lo == 87);
-
-	/* Get94 */
-	rc = c2_cobfid_map_iter_next(&cfm_iter, &container_id_out, &fid_out,
-				     &cob_fid_out);
-	C2_UT_ASSERT(rc == 0);
-	C2_UT_ASSERT(fid_out.f_key == 94);
-	C2_UT_ASSERT(cob_fid_out.u_lo == 94);
-
-	/* Iterator Empty */
-	rc = c2_cobfid_map_iter_next(&cfm_iter, &container_id_out, &fid_out,
-				     &cob_fid_out);
-	C2_UT_ASSERT(rc == -ENOENT);
-	C2_UT_ASSERT(cfm_iter.cfmi_error == -ENOENT);
-
-	/* Close iterator */
-	c2_cobfid_map_iter_fini(&cfm_iter);
-
-	c2_cobfid_map_fini(&cfm_map);
-	c2_dbenv_fini(&cfm_dbenv);
-
-	rc = c2_ut_db_reset(iter_test_map);
-	C2_UT_ASSERT(rc == 0);
-
-}
-
-/* Number of threads that will concurrently access a cobfid_map */
-enum {
-	CFM_THREAD_NR = 41,
-};
-
-static struct c2_mutex	    cfm_global_mutex;
-static struct c2_dbenv	    cfm_global_dbenv;
-static struct c2_cobfid_map cfm_global_map;
-static struct c2_addb_ctx   cfm_global_addb_ctx;
-static struct c2_fid	   *fid_in[CFM_THREAD_NR];
-static struct c2_fid	   *fid_out[CFM_THREAD_NR];
-static struct c2_uint128   *cob_fid_in[CFM_THREAD_NR];
-static struct c2_uint128   *cob_fid_out[CFM_THREAD_NR];
-
-/* Container id is function of thread id, implemented for uniqueness */
-static uint64_t get_cid(const int tid)
-{
-	return 954 + tid;
-}
-
-/* Function to add and enumerate a container */
-static void cfm_op(const int tid)
-{
-	int			 i;
-	int			 j;
-	int			 rc;
-	int			 rec_nr;
-	int			 rec_total;
-        uint64_t                 container_id_in;
-        uint64_t                 container_id_out;
-        struct c2_cobfid_map_iter cfm_iter;
-
-	/* Use multiple fetches for iterator */
-	rec_total = MULTIPLE_BUF_REC_NR;
-
-	/* Allocate key-value input-output arrays only for this thread id */
-	C2_ALLOC_ARR(fid_in[tid], rec_total);
-        C2_UT_ASSERT(fid_in[tid] != NULL);
-
-        C2_ALLOC_ARR(cob_fid_in[tid], rec_total);
-        C2_UT_ASSERT(cob_fid_in[tid] != NULL);
-
-        C2_ALLOC_ARR(fid_out[tid], rec_total);
-        C2_UT_ASSERT(fid_out[tid] != NULL);
-
-        C2_ALLOC_ARR(cob_fid_out[tid], rec_total);
-        C2_UT_ASSERT(cob_fid_out[tid] != NULL);
-
-	/* Container id is function of thread id */
-	container_id_in = get_cid(tid);
-	j = rec_total - 1;
-
-        /* Fill in the database with varying fid values in
-           decreasing order of fid key. This is done on purpose to test the
-           ordering property where enumeration should be done in increasing
-           order of the fid key.*/
-        for (i = 0; i < rec_total; i++) {
-                /* Populate some random data */
-                fid_in[tid][i].f_container = 0;
-                fid_in[tid][i].f_key = j;
-                cob_fid_in[tid][i].u_hi = 3212;
-                cob_fid_in[tid][i].u_lo = j;
-
-		/* Add to map using serialization */
-		c2_mutex_lock(&cfm_global_mutex);
-
-		rc = c2_cobfid_map_add(&cfm_global_map, container_id_in,
-				       fid_in[tid][i], cob_fid_in[tid][i]);
-                C2_UT_ASSERT(rc == 0);
-
-		c2_mutex_unlock(&cfm_global_mutex);
-
-                j--;
-        }
-
-        rec_nr = 0;
-
-	/* Container enumeration for this thread */
-	c2_mutex_lock(&cfm_global_mutex);
-
-	rc = c2_cobfid_map_container_enum(&cfm_global_map, container_id_in,
-					  &cfm_iter);
-	C2_UT_ASSERT(rc == 0);
-
-	while ((rc = c2_cobfid_map_iter_next(&cfm_iter, &container_id_out,
-					     &fid_out[tid][rec_nr],
-					     &cob_fid_out[tid][rec_nr])) == 0) {
-		rec_nr++;
-	}
-
-	c2_cobfid_map_iter_fini(&cfm_iter);
-	c2_mutex_unlock(&cfm_global_mutex);
-
-	/* Check if number of records enumerated is same as number of records
-	   inserted */
-        C2_UT_ASSERT(rec_nr == rec_total);
-
-        /* Check if the fid and cob input arrays are exact reverse of their
-           corresponding out counterparts. */
-        for (i = 0; i < rec_total; i++) {
-                C2_UT_ASSERT(c2_fid_eq(&fid_in[tid][i],
-                                       &fid_out[tid][rec_total - 1 - i]));
-                C2_UT_ASSERT(c2_uint128_eq(&cob_fid_in[tid][i],
-                             &cob_fid_out[tid][rec_total - 1 - i]));
-        }
-
-	/* Free input arrays since they are not required henceforth.
-	   Output arrays are not freed as they are required for validation */
-        c2_free(fid_in[tid]);
-        c2_free(cob_fid_in[tid]);
-}
-
-/* Test concurrent operation across multiple threads for a cobfid_map */
-static void test_cfm_concurrency(void)
-{
-	int			  i;
-	int			  rc;
-	int			  rec_nr;
-	int			  tid;
-	int			  tid_rec_nr;
-	struct c2_thread	 *cfm_thread;
-	struct c2_cobfid_map_iter cfm_iter;
-	uint64_t		  cid;
-	struct c2_uint128         cob_fid;
-	struct c2_fid             fid;
-
-	/* Reset any existing database */
-	rc = c2_ut_db_reset(concurrency_test_map);
-	C2_UT_ASSERT(rc == 0);
-
-        /* Initialise the database with given path */
-        rc = c2_dbenv_init(&cfm_global_dbenv, concurrency_test_map, 0);
-        C2_UT_ASSERT(rc == 0);
-
-	/* Initialize the map */
-	rc = c2_cobfid_map_init(&cfm_global_map, &cfm_global_dbenv,
-				&cfm_global_addb_ctx, "cfm_map_table");
-	C2_UT_ASSERT(rc == 0);
-
-	c2_mutex_init(&cfm_global_mutex);
-
-	C2_ALLOC_ARR(cfm_thread, CFM_THREAD_NR);
-	C2_UT_ASSERT(cfm_thread != NULL);
-
-	/* Spawn threads with even thread id,
-	   which will independently add and enumerate */
-	for (i = 0; i < CFM_THREAD_NR; i = i + 2) {
-		rc = C2_THREAD_INIT(&cfm_thread[i], int, NULL, &cfm_op, i,
-				    "cfm_thread_%d", i);
-		C2_UT_ASSERT(rc == 0);
-	}
-
-	/* Spawn threads with odd thread id,
-	   which will independently add and enumerate */
-	for (i = 1; i < CFM_THREAD_NR; i = i + 2) {
-		rc = C2_THREAD_INIT(&cfm_thread[i], int, NULL, &cfm_op, i,
-				    "cfm_thread_%d", i);
-		C2_UT_ASSERT(rc == 0);
-	}
-
-	for (i = 0; i < CFM_THREAD_NR; ++i) {
-		c2_thread_join(&cfm_thread[i]);
-	}
-
-	c2_free(cfm_thread);
-	c2_mutex_fini(&cfm_global_mutex);
-
-	/* Map enumeration for records inserted by above threads */
-	rc = c2_cobfid_map_enum(&cfm_global_map, &cfm_iter);
-	C2_UT_ASSERT(rc == 0);
-
-	rec_nr = 0;
-	tid = 0;
-	tid_rec_nr = 0;
-
-	while ((rc = c2_cobfid_map_iter_next(&cfm_iter, &cid, &fid,
-					     &cob_fid)) == 0) {
-		/* Check the ordering of enumeration. The data from all the
-		   threads has to be in correct order. */
-                C2_UT_ASSERT(c2_fid_eq(&fid_out[tid][tid_rec_nr], &fid));
-                C2_UT_ASSERT(c2_uint128_eq(&cob_fid_out[tid][tid_rec_nr],
-					   &cob_fid));
-		C2_UT_ASSERT(C2_3WAY(cid, get_cid(tid) == 0));
-
-		rec_nr++;
-		tid_rec_nr++;
-
-		if (tid_rec_nr == MULTIPLE_BUF_REC_NR) {
-			/* Free output arrays as they are not required after
-			   this point */
-			c2_free(fid_out[tid]);
-			c2_free(cob_fid_out[tid]);
-
-			tid++;
-			tid_rec_nr = 0;
-		}
-	}
-
-	/* Check end of the iterator */
-	C2_UT_ASSERT(cfm_iter.cfmi_error == -ENOENT);
-	C2_UT_ASSERT(rc == -ENOENT);
-
-        c2_cobfid_map_iter_fini(&cfm_iter);
-
-        /* Check if number of records enumerated is same as number of records
-           inserted */
-        C2_UT_ASSERT(rec_nr == CFM_THREAD_NR * MULTIPLE_BUF_REC_NR);
-
-	/* Cleanup */
-	c2_cobfid_map_fini(&cfm_global_map);
-	c2_dbenv_fini(&cfm_global_dbenv);
-
-	rc = c2_ut_db_reset(concurrency_test_map);
-	C2_UT_ASSERT(rc == 0);
-}
-
-const struct c2_test_suite cfm_ut = {
-	.ts_name = "cfm-ut",
-	.ts_init = NULL,
-	.ts_fini = NULL,
-	.ts_tests = {
-		{ "cfm-container-enumerate-single-buffer", ce_single_buf },
-		{ "cfm-container-enumerate-multiple-buffers", ce_multiple_buf },
-		{ "cfm-map-enumerate-single-buffer", me_single_buf },
-		{ "cfm-map-enumerate-multiple-buffers", me_multiple_buf },
-		{ "cfm-iter-sensitivity", test_iter_sensitivity },
-		{ "cfm-concurrency", test_cfm_concurrency },
-		{ NULL, NULL }
-	}
-};
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
diff --git a/iostore/iostore.h b/iostore/iostore.h
index 700c4b2..4fcca9f 100644
--- a/iostore/iostore.h
+++ b/iostore/iostore.h
@@ -14,8 +14,8 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Yuriy Umanets <Yuriy_Umanets@xyratex.com>
- * Original creation date: 01/12/2010
+ * Original author: Yuriy Umanets <yuriy_umanets@xyratex.com>
+ * Original creation date: 04/21/2011
  */
 
 #ifndef __COLIBRI_IOSTORE_DATASTORE_H__
diff --git a/layout/Makefile.am b/layout/Makefile.am
index 8602152..989f584 100644
--- a/layout/Makefile.am
+++ b/layout/Makefile.am
@@ -1,4 +1,4 @@
-layoutdir                     = $(includedir)/colibri/layout
+layoutdir                     = $(includedir)/layout
 layout_HEADERS                = layout.h pdclust.h
 
 noinst_LTLIBRARIES            = libcolibri-layout.la
diff --git a/layout/pdclust.c b/layout/pdclust.c
index 1d248a2..26547f7 100644
--- a/layout/pdclust.c
+++ b/layout/pdclust.c
@@ -171,6 +171,7 @@ static bool c2_pdclust_layout_invariant(const struct c2_pdclust_layout *play)
 {
 	uint32_t i;
 	uint32_t P;
+	uint32_t sum;
 
 	const struct tile_cache *tc;
 
@@ -181,7 +182,7 @@ static bool c2_pdclust_layout_invariant(const struct c2_pdclust_layout *play)
 	 * tc->tc_permute[] and tc->tc_inverse[] are mutually inverse bijections
 	 * of {0, ..., P - 1}.
 	 */
-	for (i = 0; i < P; ++i) {
+	for (sum = 0, i = 0; i < P; ++i) {
 		if (tc->tc_lcode[i] + i >= P)
 			return false;
 		if (tc->tc_permute[i] >= P || tc->tc_inverse[i] >= P)
@@ -193,7 +194,7 @@ static bool c2_pdclust_layout_invariant(const struct c2_pdclust_layout *play)
 		/* existence of inverse guarantees that tc->tc_permute[] is a
 		   bijection. */
 	}
-	return
+	return 
 		play->pl_C * (play->pl_N + 2*play->pl_K) == play->pl_L * P;
 }
 
@@ -224,7 +225,7 @@ static uint64_t hash(uint64_t x)
    Returns column number that a column t has after a permutation for tile omega
    is applied.
  */
-static uint64_t permute_column(struct c2_pdclust_layout *play,
+static uint64_t permute_column(struct c2_pdclust_layout *play, 
 			       uint64_t omega, uint64_t t)
 {
 	struct tile_cache *tc;
@@ -243,7 +244,7 @@ static uint64_t permute_column(struct c2_pdclust_layout *play,
 			tc->tc_permute[i] = i;
 
 		/* initialize PRNG */
-		rstate  =
+		rstate  = 
 			hash(play->pl_seed.u_hi) ^
 			hash(play->pl_seed.u_lo + omega);
 
@@ -262,8 +263,8 @@ static uint64_t permute_column(struct c2_pdclust_layout *play,
 	return tc->tc_permute[t];
 }
 
-void c2_pdclust_layout_map(struct c2_pdclust_layout *play,
-			   const struct c2_pdclust_src_addr *src,
+void c2_pdclust_layout_map(struct c2_pdclust_layout *play, 
+			   const struct c2_pdclust_src_addr *src, 
 			   struct c2_pdclust_tgt_addr *tgt)
 {
 	uint32_t N;
@@ -300,6 +301,7 @@ void c2_pdclust_layout_map(struct c2_pdclust_layout *play,
 	/* and translate back from tile to target address. */
 	tgt->ta_frame = m_enc(L, omega, r);
 }
+C2_EXPORTED(c2_pdclust_layout_map);
 
 void c2_pdclust_layout_inv(struct c2_pdclust_layout *play,
 			   const struct c2_pdclust_tgt_addr *tgt,
@@ -337,6 +339,7 @@ void c2_pdclust_layout_inv(struct c2_pdclust_layout *play,
 	m_dec(N + 2*K, m_enc(P, r, t), &j, &src->sa_unit);
 	src->sa_group = m_enc(C, omega, j);
 }
+C2_EXPORTED(c2_pdclust_layout_inv);
 
 static bool pdclust_equal(const struct c2_layout *l0,
 			  const struct c2_layout *l1)
@@ -347,14 +350,14 @@ static bool pdclust_equal(const struct c2_layout *l0,
 	p0 = container_of(l0, struct c2_pdclust_layout, pl_layout);
 	p1 = container_of(l1, struct c2_pdclust_layout, pl_layout);
 
-	return
+	return 
 		c2_uint128_eq(&p0->pl_seed, &p1->pl_seed) &&
-		p0->pl_N == p1->pl_N &&
+		p0->pl_N == p1->pl_N && 
 		p0->pl_K == p1->pl_K &&
-		p0->pl_P == p1->pl_P &&
+		p0->pl_P == p1->pl_P && 
 		p0->pl_C == p1->pl_C &&
-		p0->pl_L == p1->pl_L &&
-		p0->pl_pool == p1->pl_pool;
+		p0->pl_L == p1->pl_L && 
+		p0->pl_pool == p1->pl_pool; 
 	/* XXX and check that target objects are the same */
 }
 
@@ -373,7 +376,7 @@ void c2_pdclust_fini(struct c2_pdclust_layout *pdl)
 		if (pdl->pl_tgt != NULL) {
 			for (i = 0; i < pdl->pl_P; ++i) {
 				if (c2_stob_id_is_set(&pdl->pl_tgt[i]))
-					c2_pool_put(pdl->pl_pool,
+					c2_pool_put(pdl->pl_pool, 
 						    &pdl->pl_tgt[i]);
 			}
 			c2_free(pdl->pl_tgt);
@@ -381,6 +384,7 @@ void c2_pdclust_fini(struct c2_pdclust_layout *pdl)
 		c2_free(pdl);
 	}
 }
+C2_EXPORTED(c2_pdclust_fini);
 
 int c2_pdclust_build(struct c2_pool *pool, struct c2_uint128 *id,
 		     uint32_t N, uint32_t K, const struct c2_uint128 *seed,
@@ -442,9 +446,10 @@ int c2_pdclust_build(struct c2_pool *pool, struct c2_uint128 *id,
 		c2_pdclust_fini(pdl);
 	return result;
 }
+C2_EXPORTED(c2_pdclust_build);
 
 enum c2_pdclust_unit_type
-c2_pdclust_unit_classify(const struct c2_pdclust_layout *play,
+c2_pdclust_unit_classify(const struct c2_pdclust_layout *play, 
 			 int unit)
 {
 	if (unit < play->pl_N)
@@ -454,6 +459,7 @@ c2_pdclust_unit_classify(const struct c2_pdclust_layout *play,
 	else
 		return PUT_SPARE;
 }
+C2_EXPORTED(c2_pdclust_unit_classify);
 
 const struct c2_layout_type c2_pdclust_layout_type = {
 	.lt_name  = "pdclust",
@@ -474,7 +480,7 @@ const struct c2_layout_formula c2_pdclust_NKP_formula = {
 
 /** @} end of group pdclust */
 
-/*
+/* 
  *  Local variables:
  *  c-indentation-style: "K&R"
  *  c-basic-offset: 8
diff --git a/lib/Makefile.am b/lib/Makefile.am
index f75cdc4..b55bbaa 100644
--- a/lib/Makefile.am
+++ b/lib/Makefile.am
@@ -1,130 +1,41 @@
 SUBDIRS              = user_space
 
-libc2dir             = $(includedir)/colibri/lib
-libc2_HEADERS        = \
-                       adt.h \
-                       arith.h \
-                       assert.h \
-                       atomic.h \
-                       bitmap.h \
-                       bob.h \
-                       cdefs.h \
-                       chan.h \
-                       cond.h \
-                       errno.h \
-                       ext.h \
-                       getopts.h \
-                       list.h \
-                       memory.h \
-                       misc.h \
-                       mutex.h \
-                       processor.h \
-                       queue.h \
-                       refs.h \
-                       rwlock.h \
-                       semaphore.h \
-                       thread.h \
-                       time.h \
-                       timer.h \
-                       tlist.h \
-                       trace.h \
-                       types.h \
-                       ub.h \
-                       ut.h \
-                       vec.h
+libc2dir             = $(includedir)/lib
+libc2_HEADERS        = adt.h atomic.h cond.h getopts.h misc.h refs.h trace.h \
+                       ut.h arith.h cdefs.h errno.h list.h mutex.h rwlock.h \
+                       types.h vec.h assert.h chan.h ext.h memory.h queue.h \
+                       thread.h time.h ub.h bitmap.h processor.h timer.h \
+                       semaphore.h
+
+if HAVE_CUNIT_SUPPORT
+UT_SOURCES           = ut.c ut.h ub.c ub.h 
+else
+UT_SOURCES           =
+endif
 
 noinst_LTLIBRARIES   = libc2.la
-libc2_la_SOURCES     = \
-                       adt.h \
-                       arith.h \
-                       assert.c \
-                       assert.h \
-                       atomic.h \
-                       bitmap.c \
-                       bitstring.c \
-                       bitstring.h \
-                       bob.c \
-                       bob.h \
-                       buf.c \
-                       buf.h \
-                       c2lib.c \
-                       cdefs.h \
-                       chan.c \
-                       chan.h \
-                       cond.c \
-                       cond.h \
-                       errno.h \
-                       ext.c \
-                       ext.h \
-                       getopts.c \
-                       getopts.h \
-                       list.c \
-                       list.h \
-                       memory.h \
-                       misc.c \
-                       misc.h \
-                       mutex.c \
-                       mutex.h \
-                       queue.c \
-                       queue.h \
-                       refs.c \
-                       refs.h \
-                       rwlock.h \
-                       semaphore.h \
-                       thread.c \
-                       thread.h \
-                       time.c \
-                       timer.c \
-                       tlist.c \
-                       tlist.h \
-                       trace.c \
-                       trace.h \
-                       types.h \
-                       ub.c \
-                       ub.h \
-                       user_space/assert.h \
-                       user_space/cdefs.h \
-                       user_space/memory.c \
-                       user_space/mutex.h \
-                       user_space/processor.c \
-                       user_space/rwlock.c \
-                       user_space/semaphore.c \
-                       user_space/semaphore.h \
-                       user_space/thread.h \
-                       user_space/timer.h \
-                       user_space/utrace.c \
-                       user_space/trace.h \
-                       user_space/types.h \
-                       user_space/user_x86_64_atomic.h \
-                       user_space/uthread.c \
-                       user_space/utime.c \
-                       ut.c \
-                       ut.h \
-                       vec.c \
-                       vec.h
+libc2_la_SOURCES     = libc2.c memory.c list.c refs.c \
+                       queue.c vec.c chan.c mutex.c cond.c buf.c \
+                       assert.c time.c timer.c thread.c bitmap.c \
+                       adt.h rwlock.h memory.h list.h \
+                       refs.h atomic.h queue.h arith.h thread.h buf.h \
+                       vec.h chan.h mutex.h cond.h types.h errno.h \
+                       user_space/user_x86_64_atomic.h assert.h cdefs.h \
+                       misc.c misc.h ext.c ext.h bitstring.h bitstring.c \
+                       $(UT_SOURCES) trace.h user_space/trace.c \
+                       getopts.c getopts.h user_space/assert.h \
+                       user_space/mutex.h user_space/cdefs.h \
+                       user_space/utime.c user_space/types.h \
+                       user_space/uthread.c user_space/thread.h \
+                       user_space/processor.c user_space/rwlock.c \
+                       user_space/timer.h semaphore.h \
+                       user_space/semaphore.c user_space/semaphore.h
 
-libc2_la_LDFLAGS       = @PTHREAD_LIBS@ -lrt
-EXTRA_DIST             = \
-                         linux_kernel/assert.h \
-                         linux_kernel/atomic64.h \
-                         linux_kernel/cdefs.h \
-                         linux_kernel/kthread.c \
-                         linux_kernel/ktrace.c \
-                         linux_kernel/ktime.c \
-                         linux_kernel/memory.c \
-                         linux_kernel/mutex.c \
-                         linux_kernel/mutex.h \
-                         linux_kernel/processor.c \
-                         linux_kernel/semaphore.c \
-                         linux_kernel/semaphore.h \
-                         linux_kernel/thread.h \
-                         linux_kernel/timer.c \
-                         linux_kernel/time.h \
-                         linux_kernel/timer.h \
-                         linux_kernel/vec.h \
-                         linux_kernel/kvec.c \
-                         linux_kernel/rwlock.c \
-                         linux_kernel/rwlock.h \
-                         linux_kernel/ut.c \
-                         linux_kernel/main.c \
-                         linux_kernel/types.h
+libc2_la_LDFLAGS       = @PTHREAD_LIBS@
+EXTRA_DIST             = linux_kernel/assert.h linux_kernel/cdefs.h \
+                         linux_kernel/memory.c linux_kernel/mutex.c \
+                         linux_kernel/mutex.h linux_kernel/ktime.c \
+                         linux_kernel/types.h linux_kernel/processor.c \
+                         linux_kernel/kthread.c linux_kernel/thread.h \
+                         linux_kernel/timer.h linux_kernel/timer.c \
+                         linux_kernel/semaphore.c linux_kernel/semaphore.h
diff --git a/lib/arith.h b/lib/arith.h
index 8ba558c..bd00aa0 100644
--- a/lib/arith.h
+++ b/lib/arith.h
@@ -96,12 +96,8 @@ static inline uint64_t max64u(uint64_t a, uint64_t b)
 	__a > __b ? __a : __b;			\
 })
 
-#ifndef min3
 #define min3(a, b, c) (min_check((a), min_check((b), (c))))
-#endif
-#ifndef max3
 #define max3(a, b, c) (max_check((a), max_check((b), (c))))
-#endif
 
 /**
    Compares two 64bit numbers "modulo overflow".
@@ -185,26 +181,12 @@ static inline uint64_t c2_align(uint64_t val, uint64_t alignment)
 	(v1) = (__tmp);					\
 })
 
-/** Decrements a counter checking for underflow. */
-#define C2_CNT_DEC(cnt)					\
-({							\
-        C2_ASSERT((cnt) > 0);				\
-        --cnt;						\
-})
-
-/** Increments a counter checking for overflow. */
-#define C2_CNT_INC(cnt)					\
-({							\
-        ++cnt;						\
-        C2_ASSERT((cnt) > 0);				\
-})
-
 /** @} end of arith group */
 
 /* __COLIBRI_LIB_ARITH_H__ */
 #endif
 
-/*
+/* 
  *  Local variables:
  *  c-indentation-style: "K&R"
  *  c-basic-offset: 8
diff --git a/lib/assert.c b/lib/assert.c
index cb53247..a8859ad 100644
--- a/lib/assert.c
+++ b/lib/assert.c
@@ -67,13 +67,17 @@ void c2_panic(const char *expr, const char *func, const char *file, int lineno)
 		backtrace_symbols_fd(trace, nr, 2);
 	}
 #endif
-	C2_LOG("panic: %s %s() (%s:%i)", expr, func, file, lineno);
+	C2_TRACE_POINT( { /* emit a trace point for panic */
+			const char *expr; 
+			const char *func;
+			const char *file;
+			int         lineno; }, expr, func, file, lineno);
 	abort();
 }
 
 /** @} end of assert group */
 
-/*
+/* 
  *  Local variables:
  *  c-indentation-style: "K&R"
  *  c-basic-offset: 8
diff --git a/lib/atomic.h b/lib/atomic.h
index 5b43626..4a15775 100644
--- a/lib/atomic.h
+++ b/lib/atomic.h
@@ -37,8 +37,6 @@
    Atomic operations on 64bit quantities.
 
    Implementation of these is platform-specific.
-
-   @{
  */
 
 /**
@@ -96,39 +94,11 @@ PREFIX bool c2_atomic64_inc_and_test(struct c2_atomic64 *a);
  */
 PREFIX bool c2_atomic64_dec_and_test(struct c2_atomic64 *a);
 
-/**
-   Atomic compare-and-swap: compares value stored in @loc with @old and, if
-   equal, replaces it with @new, all atomic w.r.t. concurrent accesses to @loc.
-
-   Returns true iff new value was installed.
- */
-PREFIX bool c2_atomic64_cas(int64_t *loc, int64_t old, int64_t new);
-
-/**
-   Atomic compare-and-swap for pointers.
-
-   @see c2_atomic64_cas().
- */
-static inline bool c2_atomic64_cas_ptr(void **loc, void *old, void *new)
-{
-	C2_CASSERT(sizeof loc == sizeof(int64_t *));
-	C2_CASSERT(sizeof old == sizeof(int64_t));
-
-	return c2_atomic64_cas((int64_t *)loc, (int64_t)old, (int64_t)new);
-}
-
-#define C2_ATOMIC64_CAS(loc, old, new)					\
-({									\
-	C2_CASSERT(__builtin_types_compatible_p(typeof(*(loc)), typeof(old))); \
-	C2_CASSERT(__builtin_types_compatible_p(typeof(old), typeof(new))); \
-	c2_atomic64_cas_ptr((void **)(loc), old, new);			\
-})
-
 /** @} end of atomic group */
 
 /* __COLIBRI_LIB_ATOMIC_H__ */
 #endif
-/*
+/* 
  *  Local variables:
  *  c-indentation-style: "K&R"
  *  c-basic-offset: 8
diff --git a/lib/bitmap.c b/lib/bitmap.c
index b287607..e137756 100644
--- a/lib/bitmap.c
+++ b/lib/bitmap.c
@@ -20,6 +20,7 @@
 
 #include "lib/bitmap.h"
 #include "lib/misc.h"   /* C2_SET0 */
+#include "lib/arith.h"  /* C2_IS_PO2 */
 #include "lib/assert.h"
 #include "lib/errno.h"
 #include "lib/memory.h"
@@ -118,18 +119,6 @@ void c2_bitmap_set(struct c2_bitmap *map, size_t idx, bool val)
 }
 C2_EXPORTED(c2_bitmap_set);
 
-void c2_bitmap_copy(struct c2_bitmap *dst, const struct c2_bitmap *src)
-{
-	int s = C2_BITMAP_WORDS(src->b_nr);
-	int d = C2_BITMAP_WORDS(dst->b_nr);
-
-	C2_PRE(dst->b_nr >= src->b_nr);
-
-	memcpy(dst->b_words, src->b_words, s * sizeof src->b_words[0]);
-	if (d > s)
-		memset(&dst->b_words[s], 0, (d - s) * sizeof dst->b_words[0]);
-}
-
 /** @} end of bitmap group */
 
 /*
diff --git a/lib/bitmap.h b/lib/bitmap.h
index 9fc9f40..2b3adb2 100644
--- a/lib/bitmap.h
+++ b/lib/bitmap.h
@@ -84,15 +84,6 @@ bool c2_bitmap_get(const struct c2_bitmap *map, size_t idx);
  */
 void c2_bitmap_set(struct c2_bitmap *map, size_t idx, bool val);
 
-/**
-   Copies the bit values from one bitmap to another.
-   @param dst destination bitmap, must already be initialised.  If dst
-   is larger than src, bits beyond src->b_nr are cleared in dst.
-   @param src source bitmap
-   @pre dst->b_nr >= src->b_nr
- */
-void c2_bitmap_copy(struct c2_bitmap *dst, const struct c2_bitmap *src);
-
 C2_BASSERT(8 == sizeof ((struct c2_bitmap *)0)->b_words[0]);
 
 /** @} end of bitmap group */
diff --git a/lib/bitstring.c b/lib/bitstring.c
index 06b8e45..d79545e 100644
--- a/lib/bitstring.c
+++ b/lib/bitstring.c
@@ -92,6 +92,7 @@ int c2_bitstring_cmp(const struct c2_bitstring *c1,
         return C2_3WAY(c1->b_len, c2->b_len);
 }
 
+
 /*
  *  Local variables:
  *  c-indentation-style: "K&R"
diff --git a/lib/bob.c b/lib/bob.c
deleted file mode 100644
index 656ab42..0000000
--- a/lib/bob.c
+++ /dev/null
@@ -1,76 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2012 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Nikita Danilov <nikita_danilov@xyratex.com>
- * Original creation date: 21-Jan-2012
- */
-
-#include "xcode/xcode.h"
-#include "lib/tlist.h"
-#include "lib/assert.h"
-#include "lib/bob.h"
-
-/**
- * @addtogroup bob
- *
- * @{
- */
-
-void c2_bob_type_tlist_init(struct c2_bob_type *bt, const struct c2_tl_descr *td)
-{
-	C2_PRE(td->td_link_magic != 0);
-
-	bt->bt_name         = td->td_name;
-	bt->bt_magix        = td->td_link_magic;
-	bt->bt_magix_offset = td->td_link_magic_offset;
-}
-
-/**
- * Returns the value of magic field.
- *
- * Macro is used instead of inline function so that constness of the result
- * depends on the constness of "bob" argument.
- */
-#define MAGIX(bt, bob) ((uint64_t *)(bob + bt->bt_magix_offset))
-
-void c2_bob_init(const struct c2_bob_type *bt, void *bob)
-{
-	*MAGIX(bt, bob) = bt->bt_magix;
-}
-
-void c2_bob_fini(const struct c2_bob_type *bt, void *bob)
-{
-	C2_ASSERT(c2_bob_check(bt, bob));
-	*MAGIX(bt, bob) = 0;
-}
-
-bool c2_bob_check(const struct c2_bob_type *bt, const void *bob)
-{
-	return *MAGIX(bt, bob) == bt->bt_magix &&
-		ergo(bt->bt_check != NULL, bt->bt_check(bob));
-}
-
-/** @} end of cond group */
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
diff --git a/lib/bob.h b/lib/bob.h
deleted file mode 100644
index 73ec30c..0000000
--- a/lib/bob.h
+++ /dev/null
@@ -1,138 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2012 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Nikita Danilov <nikita_danilov@xyratex.com>
- * Original creation date: 21-Jan-2012
- */
-
-#ifndef __COLIBRI_LIB_BOB_H__
-#define __COLIBRI_LIB_BOB_H__
-
-/**
- * @defgroup bob Branded objects
- *
- * Branded object (bob) module provides support for a simple run-time type
- * identification.
- *
- * A branded object is any memory structure containing magic field at a known
- * offset. A branded object type (c2_bob_type) specifies the offset and the
- * required magic value field, together with an optional check
- * function. c2_bob_check() function returns true iff the memory structure given
- * to it as a parameter has the required magic value and satisfies the optional
- * check.
- *
- * For flexibility branded objects are not represented by a special
- * data-type. Instead c2_bob_check() takes a void pointer.
- *
- * A couple of helper functions are provided to initialize c2_branded_type:
- *
- *     - c2_bob_type_tl_init(): used when branded object is used as a typed list
- *       link, @see lib/tlist.h.
- *
- *     - c2_xcode_bob_type_init(): used in case where branded object type has an
- *       xcode representation, @see xcode/xcode.h. This function is defined in
- *       xcode.h to avoid introducing dependencies.
- *
- * A user is explicitly allowed to initialize c2_bob_type instance manually and
- * to set up the optional check function (c2_bob_type::bt_check()) either before
- * or after using these helpers.
- *
- * @{
- */
-
-#include "lib/types.h"                  /* uint64_t */
-
-/* import */
-struct c2_tl_descr;
-
-/* export */
-struct c2_bob_type;
-
-/**
- * Branded object type specifies how run-time identification is made.
- */
-struct c2_bob_type {
-	/** Human-readable name used in error messages. */
-	const char *bt_name;
-	/** Offset to the magic field. */
-	int         bt_magix_offset;
-	/** Magic value. Must be non zero. */
-	uint64_t    bt_magix;
-	/**
-	 *  Optional check function. If provided, this function is called by
-	 *  c2_bob_check().
-	 */
-	bool      (*bt_check)(const void *bob);
-};
-
-/**
- * Partially initializes a branded object type from a typed list descriptor.
- */
-void c2_bob_type_tlist_init(struct c2_bob_type *bt,
-			    const struct c2_tl_descr *td);
-/**
- *  Initializes a branded object, by setting the magic field.
- */
-void c2_bob_init(const struct c2_bob_type *bt, void *bob);
-
-/**
- *  Finalizes a branded object, by re-setting the magic field to 0.
- */
-void c2_bob_fini(const struct c2_bob_type *bt, void *bob);
-
-/**
- * Returns true iff a branded object has the required magic value and check
- * function, if any, returns true.
- */
-bool c2_bob_check(const struct c2_bob_type *bt, const void *bob);
-
-/**
- * Produces a type-safe versions of c2_bob_init(), c2_bob_fini() and
- * c2_bob_check(), taking branded object of a given type.
- */
-#define C2_BOB_DEFINE(scope, bob_type, type)		\
-scope void type ## _bob_init(struct type *bob)		\
-{							\
-	c2_bob_init(bob_type, bob);			\
-}							\
-							\
-scope void type ## _bob_fini(struct type *bob)		\
-{							\
-	c2_bob_fini(bob_type, bob);			\
-}							\
-							\
-scope bool type ## _bob_check(const struct type *bob)	\
-{							\
-	return c2_bob_check(bob_type, bob);		\
-}							\
-							\
-struct __ ## type ## _semicolon_catcher
-
-
-/** @} end of bob group */
-
-/* __COLIBRI_LIB_BOB_H__ */
-#endif
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
diff --git a/lib/buf.c b/lib/buf.c
index 4e91885..c37556e 100644
--- a/lib/buf.c
+++ b/lib/buf.c
@@ -14,7 +14,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Anatoliy Bilenko <Anatoliy_Bilenko@xyratex.com>
+ * Original author: Anatoliy Bilenko
  * Original creation date: 12/02/2010
  */
 
@@ -31,6 +31,7 @@ void c2_buf_init(struct c2_buf *buf, void *data, uint32_t nob)
 	buf->b_addr = data;
 	buf->b_nob  = nob;
 }
+C2_EXPORTED(c2_buf_init);
 
 
 /** @} end of buf group */
diff --git a/lib/buf.h b/lib/buf.h
index a3e9bc9..e6c2f90 100644
--- a/lib/buf.h
+++ b/lib/buf.h
@@ -14,7 +14,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Anatoliy Bilenko <Anatoliy_Bilenko@xyratex.com>
+ * Original author: Anatoliy Bilenko
  * Original creation date: 12/02/2010
  */
 
diff --git a/lib/c2lib.c b/lib/c2lib.c
deleted file mode 100644
index 8929a84..0000000
--- a/lib/c2lib.c
+++ /dev/null
@@ -1,42 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Yuriy Umanets <Yuriy_Umanets@xyratex.com>
- * Original creation date: 01/23/2010
- */
-
-#ifdef HAVE_CONFIG_H
-#  include <config.h>
-#endif
-
-int libc2_init()
-{
-	return 0;
-}
-
-void libc2_fini()
-{
-}
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
diff --git a/lib/cdefs.h b/lib/cdefs.h
index 0c517a5..f01fd56 100644
--- a/lib/cdefs.h
+++ b/lib/cdefs.h
@@ -34,6 +34,7 @@
  * Unfortunately, name clashes are possible and c2_ prefix is too awkward. See
  * C2_BASSERT() checks in lib/misc.c
  */
+
 #ifndef ergo
 #define ergo(a, b) (!(a) || (b))
 #endif
@@ -45,8 +46,8 @@
 extern void __dummy_function(void);
 
 /**
- * A macro used with if-statements without `else' clause to assure proper
- * coverage analysis.
+   A macro used with if-statements without `else' clause to assure proper
+   coverage analysis.
  */
 #define AND_NOTHING_ELSE else __dummy_function();
 
@@ -60,46 +61,6 @@ extern void __dummy_function(void);
 	((unsigned long)(idx)) < ARRAY_SIZE(array);	\
 })
 
-/**
- * Produces an expression having the same type as a given field in a given
- * struct or union. Suitable to be used as an argument to sizeof() or typeof().
- */
-#define C2_FIELD_VALUE(type, field) (((type *)0)->field)
-
-/**
- * True if an expression has a given type.
- */
-#define C2_HAS_TYPE(expr, type) __builtin_types_compatible_p(typeof(expr), type)
-
-/**
- * Returns the number of parameters given to this variadic macro (up to 9
- * parameters are supported)
- */
-#define C2_COUNT_PARAMS(...) \
-	C2_COUNT_PARAMS2(__VA_ARGS__, 9,8,7,6,5,4,3,2,1,0)
-#define C2_COUNT_PARAMS2(_0,_1,_2,_3,_4,_5,_6,_7,_8,_9,_, ...) _
-
-/**
- * Concatenates two arguments to produce a single token.
- */
-#define C2_CAT(A, B) C2_CAT2(A, B)
-#define C2_CAT2(A, B) A ## B
-
-
-/**
- * Check printf format string against parameters.
- *
- * This function does nothing except checking that the format string matches the
- * rest of arguments and producing a compilation warning in case it doesn't. It
- * is handy in macros which accept printf-like parameters with a format string.
- *
- * For example usage, refer to C2_TRACE_POINT() macro
- */
-__attribute__ ((format (printf, 1, 2))) static inline void
-printf_check(const char *fmt, ...)
-{}
-
-
 /* __COLIBRI_LIB_CDEFS_H__ */
 #endif
 
diff --git a/lib/chan.c b/lib/chan.c
index a63046a..44b7998 100644
--- a/lib/chan.c
+++ b/lib/chan.c
@@ -20,6 +20,7 @@
 
 #include "lib/errno.h"
 #include "lib/chan.h"
+#include "lib/list.h"
 #include "lib/assert.h"
 
 /**
@@ -48,18 +49,6 @@
    @{
  */
 
-C2_TL_DESCR_DEFINE(clink,
-		   "chan clinks", static, struct c2_clink, cl_linkage,	cl_magic,
-		   0x6368616e636c696e /* "chanclin" */,
-		   0x4348414e57414954 /* "CHANWAIT" */);
-
-C2_TL_DEFINE(clink, static, struct c2_clink);
-
-static bool clink_is_head(const struct c2_clink *clink)
-{
-	return clink->cl_group == clink;
-}
-
 /**
    Channel invariant: all clinks on the list are clinks for this channel and
    number of waiters matches list length.
@@ -67,21 +56,15 @@ static bool clink_is_head(const struct c2_clink *clink)
 static bool c2_chan_invariant_locked(struct c2_chan *chan)
 {
 	struct c2_clink *scan;
-	struct c2_clink *group;
 
-	if (chan->ch_waiters != clink_tlist_length(&chan->ch_links))
+	if (chan->ch_waiters != c2_list_length(&chan->ch_links))
 		return false;
 
-	c2_tlist_for(&clink_tl, &chan->ch_links, scan) {
-		group = scan->cl_group;
-
+	c2_list_for_each_entry(&chan->ch_links, scan,
+			       struct c2_clink, cl_linkage) {
 		if (scan->cl_chan != chan)
 			return false;
-		if (group == NULL)
-			return false;
-		if (!clink_is_head(group))
-			return false;
-	} c2_tlist_endfor;
+	}
 	return true;
 }
 
@@ -97,11 +80,12 @@ static bool c2_chan_invariant(struct c2_chan *chan)
 
 void c2_chan_init(struct c2_chan *chan)
 {
-	clink_tlist_init(&chan->ch_links);
+	c2_list_init(&chan->ch_links);
 	c2_mutex_init(&chan->ch_guard);
 	chan->ch_waiters = 0;
 	C2_ASSERT(c2_chan_invariant(chan));
 }
+C2_EXPORTED(c2_chan_init);
 
 void c2_chan_fini(struct c2_chan *chan)
 {
@@ -116,24 +100,32 @@ void c2_chan_fini(struct c2_chan *chan)
 	c2_mutex_unlock(&chan->ch_guard);
 
 	c2_mutex_fini(&chan->ch_guard);
-	clink_tlist_fini(&chan->ch_links);
+	c2_list_fini(&chan->ch_links);
 }
+C2_EXPORTED(c2_chan_fini);
 
 static struct c2_clink *chan_head(struct c2_chan *chan)
 {
 	struct c2_clink *clink;
 
-	clink = clink_tlist_head(&chan->ch_links);
-	if (clink != NULL)
-		clink_tlist_move_tail(&chan->ch_links, clink);
+	if (!c2_list_is_empty(&chan->ch_links)) {
+		clink = container_of(chan->ch_links.l_head, struct c2_clink,
+				     cl_linkage);
+		c2_list_move_tail(&chan->ch_links, &clink->cl_linkage);
+	} else
+		clink = NULL;
 	C2_ASSERT((chan->ch_waiters > 0) == (clink != NULL));
 	return clink;
 }
 
 static void clink_signal(struct c2_clink *clink)
 {
-	if (clink->cl_cb == NULL || !clink->cl_cb(clink))
-		c2_semaphore_up(&clink->cl_group->cl_wait);
+	C2_ASSERT(clink->cl_chan != NULL);
+
+	if (clink->cl_cb != NULL)
+		clink->cl_cb(clink);
+	else
+		c2_semaphore_up(&clink->cl_wait);
 }
 
 static void chan_signal_nr(struct c2_chan *chan, uint32_t nr)
@@ -159,31 +151,26 @@ void c2_chan_signal(struct c2_chan *chan)
 {
 	chan_signal_nr(chan, 1);
 }
+C2_EXPORTED(c2_chan_signal);
 
 void c2_chan_broadcast(struct c2_chan *chan)
 {
 	chan_signal_nr(chan, chan->ch_waiters);
 }
+C2_EXPORTED(c2_chan_broadcast);
 
 bool c2_chan_has_waiters(struct c2_chan *chan)
 {
 	C2_ASSERT(c2_chan_invariant(chan));
 	return chan->ch_waiters > 0;
 }
-
-static void clink_init(struct c2_clink *link,
-		       struct c2_clink *group, c2_chan_cb_t cb)
-{
-	link->cl_group = group;
-	link->cl_chan  = NULL;
-	link->cl_cb    = cb;
-	clink_tlink_init(link);
-	C2_POST(clink_is_head(group));
-}
+C2_EXPORTED(c2_chan_has_waiters);
 
 void c2_clink_init(struct c2_clink *link, c2_chan_cb_t cb)
 {
-	clink_init(link, link, cb);
+	link->cl_chan = NULL;
+	link->cl_cb = cb;
+	c2_list_link_init(&link->cl_linkage);
 	/* do NOT initialise the semaphore here */
 }
 C2_EXPORTED(c2_clink_init);
@@ -191,18 +178,10 @@ C2_EXPORTED(c2_clink_init);
 void c2_clink_fini(struct c2_clink *link)
 {
 	/* do NOT finalise the semaphore here */
-	clink_tlink_fini(link);
+	c2_list_link_fini(&link->cl_linkage);
 }
 C2_EXPORTED(c2_clink_fini);
 
-void c2_clink_attach(struct c2_clink *link,
-		     struct c2_clink *group, c2_chan_cb_t cb)
-{
-	C2_PRE(clink_is_head(group));
-
-	clink_init(link, group, cb);
-}
-
 static void clink_lock(struct c2_clink *clink)
 {
 	c2_mutex_lock(&clink->cl_chan->ch_guard);
@@ -222,19 +201,14 @@ void c2_clink_add(struct c2_chan *chan, struct c2_clink *link)
 	int rc;
 
 	C2_PRE(!c2_clink_is_armed(link));
-	/* head is registered first */
-	C2_PRE(ergo(!clink_is_head(link), c2_clink_is_armed(link->cl_group)));
 
 	link->cl_chan = chan;
-	if (clink_is_head(link)) {
-		rc = c2_semaphore_init(&link->cl_wait, 0);
-		C2_ASSERT(rc == 0);
-	}
-
 	clink_lock(link);
 	C2_ASSERT(c2_chan_invariant_locked(chan));
 	chan->ch_waiters++;
-	clink_tlist_add_tail(&chan->ch_links, link);
+	c2_list_add_tail(&chan->ch_links, &link->cl_linkage);
+	rc = c2_semaphore_init(&link->cl_wait, 0);
+	C2_ASSERT(rc == 0);
 	C2_ASSERT(c2_chan_invariant_locked(chan));
 	clink_unlock(link);
 
@@ -251,21 +225,18 @@ void c2_clink_del(struct c2_clink *link)
 	struct c2_chan *chan;
 
 	C2_PRE(c2_clink_is_armed(link));
-	/* head is de-registered last */
-	C2_PRE(ergo(!clink_is_head(link), c2_clink_is_armed(link->cl_group)));
 
 	clink_lock(link);
 	chan = link->cl_chan;
 	C2_ASSERT(c2_chan_invariant_locked(chan));
 	C2_ASSERT(chan->ch_waiters > 0);
 	chan->ch_waiters--;
-	clink_tlist_del(link);
+	c2_list_del(&link->cl_linkage);
 	C2_ASSERT(c2_chan_invariant_locked(chan));
 	clink_unlock(link);
 
 	link->cl_chan = NULL;
-	if (clink_is_head(link))
-		c2_semaphore_fini(&link->cl_wait);
+	c2_semaphore_fini(&link->cl_wait);
 
 	C2_POST(!c2_clink_is_armed(link));
 }
@@ -275,26 +246,25 @@ bool c2_clink_is_armed(const struct c2_clink *link)
 {
 	return link->cl_chan != NULL;
 }
-
-void c2_clink_signal(struct c2_clink *clink)
-{
-	clink_signal(clink);
-}
+C2_EXPORTED(c2_clink_is_armed);
 
 bool c2_chan_trywait(struct c2_clink *link)
 {
 	bool result;
 
+	C2_ASSERT(link->cl_cb == NULL);
 	C2_ASSERT(c2_chan_invariant(link->cl_chan));
-	result = c2_semaphore_trydown(&link->cl_group->cl_wait);
+	result = c2_semaphore_trydown(&link->cl_wait);
 	C2_ASSERT(c2_chan_invariant(link->cl_chan));
 	return result;
 }
+C2_EXPORTED(c2_chan_trywait);
 
 void c2_chan_wait(struct c2_clink *link)
 {
 	C2_ASSERT(c2_chan_invariant(link->cl_chan));
-	c2_semaphore_down(&link->cl_group->cl_wait);
+	C2_ASSERT(link->cl_cb == NULL);
+	c2_semaphore_down(&link->cl_wait);
 	C2_ASSERT(c2_chan_invariant(link->cl_chan));
 }
 C2_EXPORTED(c2_chan_wait);
@@ -303,12 +273,14 @@ bool c2_chan_timedwait(struct c2_clink *link, const c2_time_t abs_timeout)
 {
 	bool result;
 
+	C2_ASSERT(link->cl_cb == NULL);
 	C2_ASSERT(c2_chan_invariant(link->cl_chan));
 
-	result = c2_semaphore_timeddown(&link->cl_group->cl_wait, abs_timeout);
+	result = c2_semaphore_timeddown(&link->cl_wait, abs_timeout);
 	C2_ASSERT(c2_chan_invariant(link->cl_chan));
 	return result;
 }
+C2_EXPORTED(c2_chan_timedwait);
 
 /** @} end of chan group */
 
diff --git a/lib/chan.h b/lib/chan.h
index 838f405..cc0e3a7 100644
--- a/lib/chan.h
+++ b/lib/chan.h
@@ -22,7 +22,7 @@
 #define __COLIBRI_LIB_CHAN_H__
 
 #include "lib/cdefs.h"
-#include "lib/tlist.h"
+#include "lib/list.h"
 #include "lib/mutex.h"
 #include "lib/time.h"
 #include "lib/semaphore.h"
@@ -36,17 +36,17 @@
    can wait or register a call-back for.
 
    A clink (c2_clink) is a record of interest in events on a particular
-   channel. A user adds a clink to a channel and appearance of new events in
-   the stream is recorded in the clink.
+   channel. A user adds a clink to a channel and appearance of new events in the
+   stream is recorded in the clink.
 
    There are two interfaces related to channels:
 
-       - producer interface. It consists of c2_chan_signal(), c2_clink_signal()
-         and c2_chan_broadcast() functions. These functions are called to
-         declare that new asynchronous event happened in the stream.
+   @li producer interface. It consists of c2_chan_signal() and
+   c2_chan_broadcast() functions. These functions are called to declare that new
+   asynchronous event happened in the stream.
 
-       - consumer interface. It consists of c2_clink_add(), c2_clink_del(),
-         c2_clink_wait() and c2_clink_trywait() functions.
+   @li consumer interface. It consists of c2_clink_add(), c2_clink_del(),
+   c2_clink_wait() and c2_clink_trywait() functions.
 
    When a producer declares an event on a channel, this event is delivered. If
    event is a broadcast (c2_chan_broadcast()) it is delivered to all clinks
@@ -54,123 +54,21 @@
    delivered to a single clink (if any) registered with the channel. Clinks for
    delivery of consecutive signals are selected in a round-robin manner.
 
-   A special c2_clink_signal() function is provided to signal a particular
-   clink. c2_clink_signal() delivers a signal to its argument clink. This
-   function does not take any locks and is designed to be used in "awkward"
-   contexts, like interrupt handler or timer call-backs, where blocking on a
-   lock is not allowed. Use sparingly.
-
    The method of delivery depends on the clink interface used (c2_clink). If
-   clink has a call-back, the delivery starts with calling this call-back. If a
-   clink has no call-back or the call-back returns false, the delivered event
-   becomes pending on the clink. Pending events can be consumed by calls to
-   c2_chan_wait(), c2_chan_timedwait() and c2_chan_trywait().
-
-   <b>Filtered wake-ups.</b>
-
-   By returning true from a call-back, it is possible to "filter" some events
-   out and avoid potentially expensive thread wake-up. A typical use case for
-   this is the following:
-
-   @code
-   struct wait_state {
-           struct c2_clink f_clink;
-	   ...
-   };
-
-   static bool callback(struct c2_clink *clink)
-   {
-           struct wait_state *f = container_of(clink, struct foo, f_clink);
-	   return !condition_is_right(f);
-   }
-
-   {
-           struct wait_state g;
-
-	   c2_clink_init(&g.f_clink, &callback);
-	   c2_clink_add(chan, &g.f_clink);
-	   ...
-	   while (!condition_is_right(g)) {
-	           c2_chan_wait(&g.f_clink);
-	   }
-   }
-   @endcode
-
-   The idea behind this idiom is that the call-back is called in the same
-   context where the event is declared and it is much cheaper to test whether a
-   condition is right than to wake up a waiting thread that would check this
-   and go back to sleep if it is not.
-
-   <b>Multiple channels.</b>
-
-   It is possible to wait for an event to be announced on a channel from a
-   set. To this end, first a clink is created as usual. Then, additional
-   (unintialised) clinks are attached to the first by a call to
-   c2_clink_attach(), forming a "clink group" consisting of the original clink
-   and all clinks attached. Clinks from the group can be registered with
-   multiple (or the same) channels. Events announced on any channel are
-   delivered to all clinks in the group.
-
-   Groups are used as following:
-
-       - initialise a "group head" clink;
-
-       - attach other clinks to the group, without initialising them;
-
-       - register the group clinks with their channels, starting with the head;
-
-       - to wait for an event on any channel, wait on the group head.
-
-       - call-backs can be used for event filtering on any channel as usual;
-
-       - if N clinks from the group are registered with the same channel, an
-         event in this channel will be delivered N times.
-
-       - de-register the clinks, head last.
-
-   @code
-   struct c2_clink cl0;
-   struct c2_clink cl1;
-
-   c2_clink_init(&cl0, call_back0);
-   c2_clink_attach(&cl1, &cl0, call_back1);
-
-   c2_clink_add(chan0, &cl0);
-   c2_clink_add(chan1, &cl1);
-
-   // wait for an event on chan0 or chan1
-   c2_chan_wait(&cl0);
-
-   // de-register clinks, head last
-   c2_clink_del(chan1, &cl1);
-   c2_clink_del(chan0, &cl0);
-
-   // finalise in any order
-   c2_clink_fini(chan0, &cl0);
-   c2_clink_fini(chan1, &cl1);
-   @endcode
+   clink has a call-back, the delivery consists in calling this call-back. If a
+   clink has no call-back, the delivered event becomes pending on the
+   clink. Pending events can be consumed by calls to c2_chan_wait() and
+   c2_chan_trywait().
 
    @note An interface similar to c2_chan was a part of historical UNIX kernel
    implementations. It is where "CHAN" field in ps(1) output comes from.
 
-   @todo The next scalability improvement is to allow c2_chan to use an
-   externally specified mutex instead of a built-in one. This would allow
-   larger state machines with multiple channels to operate under fewer locks,
-   reducing coherency bus traffic.
-
    @{
 */
 
 struct c2_chan;
 struct c2_clink;
-
-/**
-   Clink call-back called when event is delivered to the clink. The call-back
-   returns true iff the event has been "consumed". Otherwise, the event will
-   remain pending on the clink for future consumption by the waiting
-   interfaces.
- */
-typedef bool (*c2_chan_cb_t)(struct c2_clink *link);
+typedef void (*c2_chan_cb_t)(struct c2_clink *link);
 
 /**
    A stream of asynchronous events.
@@ -214,7 +112,7 @@ struct c2_chan {
 	/** Lock protecting other fields. */
 	struct c2_mutex ch_guard;
 	/** List of registered clinks. */
-	struct c2_tl    ch_links;
+	struct c2_list  ch_links;
 	/** Number of clinks in c2_chan::ch_links. This is used to speed up
 	    c2_chan_broadcast(). */
 	uint32_t        ch_waiters;
@@ -225,7 +123,7 @@ struct c2_chan {
 
    A clink records the appearance of events in the stream.
 
-   There are two ways to use a clink:
+   There are two mutually exclusive ways to use a clink:
 
    @li an asynchronous call-back can be specified as an argument to clink
    constructor c2_clink_init(). This call-back is called when an event happens
@@ -237,9 +135,6 @@ struct c2_chan {
    @li once a clink is registered with a channel, it is possible to wait until
    an event happens by calling c2_clink_wait().
 
-   See the "Filtered wake-ups" section in the top-level comment on how to
-   combine call-backs with waiting.
-
    <b>Concurrency control</b>
 
    A user must guarantee that at most one thread waits on a
@@ -259,19 +154,16 @@ struct c2_clink {
 	struct c2_chan     *cl_chan;
 	/** Call-back to be called when event is declared. */
 	c2_chan_cb_t        cl_cb;
-	/** The head of the clink group. */
-	struct c2_clink    *cl_group;
 	/** Linkage into c2_chan::ch_links */
-	struct c2_tlink     cl_linkage;
+	struct c2_list_link cl_linkage;
 	struct c2_semaphore cl_wait;
-	uint64_t            cl_magic;
 };
 
 void c2_chan_init(struct c2_chan *chan);
 void c2_chan_fini(struct c2_chan *chan);
 
 /**
-   Notifies a clink currently registered with the channel that a new event
+   Notify a clink currently registered with the channel that a new event
    happened.
 
    @see c2_chan_broadcast()
@@ -279,7 +171,7 @@ void c2_chan_fini(struct c2_chan *chan);
 void c2_chan_signal(struct c2_chan *chan);
 
 /**
-   Notifies all clinks currently registered with the channel that a new event
+   Notify all clinks currently registered with the channel that a new event
    happened.
 
    No guarantees about behaviour in the case when clinks are added or removed
@@ -294,19 +186,6 @@ void c2_chan_signal(struct c2_chan *chan);
 void c2_chan_broadcast(struct c2_chan *chan);
 
 /**
-   Notifies a given clink that a new event happened.
-
-   This function takes no locks.
-
-   c2_chan_signal() should be used instead, unless the event is announced in a
-   context where blocking is not allowed.
-
-   @see c2_chan_signal()
-   @see c2_chan_broadcast()
- */
-void c2_clink_signal(struct c2_clink *clink);
-
-/**
    True iff there are clinks registered with the chan.
 
    @note the return value of this function can, in general, be obsolete by the
@@ -319,13 +198,7 @@ void c2_clink_init(struct c2_clink *link, c2_chan_cb_t cb);
 void c2_clink_fini(struct c2_clink *link);
 
 /**
-   Attaches @link to a clink group. @group is the original clink in the group.
- */
-void c2_clink_attach(struct c2_clink *link,
-		     struct c2_clink *group, c2_chan_cb_t cb);
-
-/**
-   Registers the clink with the channel.
+   Register the clink with the channel.
 
    @pre !c2_clink_is_armed(link)
    @post c2_clink_is_armed(link)
@@ -333,7 +206,7 @@ void c2_clink_attach(struct c2_clink *link,
 void c2_clink_add     (struct c2_chan *chan, struct c2_clink *link);
 
 /**
-   Un-registers the clink from the channel.
+   Un-register the clink from the channel.
 
    @pre   c2_clink_is_armed(link)
    @post !c2_clink_is_armed(link)
diff --git a/lib/cond.c b/lib/cond.c
index 7564133..dc02fe0 100644
--- a/lib/cond.c
+++ b/lib/cond.c
@@ -39,13 +39,11 @@ void c2_cond_init(struct c2_cond *cond)
 {
 	c2_chan_init(&cond->c_chan);
 }
-C2_EXPORTED(c2_cond_init);
 
 void c2_cond_fini(struct c2_cond *cond)
 {
 	c2_chan_fini(&cond->c_chan);
 }
-C2_EXPORTED(c2_cond_fini);
 
 void c2_cond_wait(struct c2_cond *cond, struct c2_mutex *mutex)
 {
@@ -67,7 +65,6 @@ void c2_cond_wait(struct c2_cond *cond, struct c2_mutex *mutex)
 	c2_clink_del(&clink);
 	c2_clink_fini(&clink);
 }
-C2_EXPORTED(c2_cond_wait);
 
 bool c2_cond_timedwait(struct c2_cond *cond, struct c2_mutex *mutex,
 		       const c2_time_t abs_timeout)
@@ -88,12 +85,12 @@ bool c2_cond_timedwait(struct c2_cond *cond, struct c2_mutex *mutex,
 	return retval;
 }
 
+
 void c2_cond_signal(struct c2_cond *cond, struct c2_mutex *mutex)
 {
 	C2_PRE(c2_mutex_is_locked(mutex));
 	c2_chan_signal(&cond->c_chan);
 }
-C2_EXPORTED(c2_cond_signal);
 
 void c2_cond_broadcast(struct c2_cond *cond, struct c2_mutex *mutex)
 {
@@ -103,7 +100,7 @@ void c2_cond_broadcast(struct c2_cond *cond, struct c2_mutex *mutex)
 
 /** @} end of cond group */
 
-/*
+/* 
  *  Local variables:
  *  c-indentation-style: "K&R"
  *  c-basic-offset: 8
diff --git a/lib/cond.h b/lib/cond.h
index 8091f50..ffece2c 100644
--- a/lib/cond.h
+++ b/lib/cond.h
@@ -48,7 +48,7 @@ struct c2_mutex;
            // buffer is being returned to the pool...
            c2_mutex_lock(&buffer_pool_lock);
            // add the buffer to the free list
-           buf_tlist_add(&buffer_pool_free, buf);
+           c2_list_add(&buffer_pool_free, &buf->b_linkage);
            // and signal the condition variable
            c2_cond_signal(&buffer_pool_hasfree, &buffer_pool_lock);
            c2_mutex_unlock(&buffer_pool_lock);
@@ -63,10 +63,10 @@ struct c2_mutex;
            struct c2_buffer *buf;
 
            c2_mutex_lock(&buffer_pool_lock);
-           while (buf_tlist_is_empty(&buffer_pool_free))
+           while (c2_list_is_empty(&buffer_pool_free))
                    c2_cond_wait(&buffer_pool_hasfree, &buffer_pool_lock);
-           buf = buf_tlist_head(&buffer_pool_free);
-           buf_tlist_del(buf);
+           buf = c2_list_first(&buffer_pool_free);
+           c2_list_del(&buf->b_linkage);
            c2_mutex_unlock(&buffer_pool_lock);
            return buf;
    }
@@ -112,11 +112,6 @@ void c2_cond_wait(struct c2_cond *cond, struct c2_mutex *mutex);
    This is the same as c2_cond_wait, except that it has a timeout value. If the
    time expires before event is pending, this function will return false.
 
-   @note Unlike pthread_cond_timedwait, c2_cond_timedwait can succeed if the
-   event is immediately pending, even if the abs_timeout is in the past.  If
-   blocking occurs and abs_timeout is in the past, c2_cond_timedwait will return
-   false.  pthread_cond_timedwait always fails when abs_timeout is in the past.
-
    @param abs_timeout this is the time since Epoch (00:00:00, 1 January 1970).
    @return true if condition is signaled before timeout.
    @return false if condition variable is not signaled but timeout expires.
@@ -144,7 +139,7 @@ void c2_cond_broadcast(struct c2_cond *cond, struct c2_mutex *mutex);
 /* __COLIBRI_LIB_COND_H__ */
 #endif
 
-/*
+/* 
  *  Local variables:
  *  c-indentation-style: "K&R"
  *  c-basic-offset: 8
diff --git a/lib/getopts.c b/lib/getopts.c
index 3b8be56..f8c3de6 100644
--- a/lib/getopts.c
+++ b/lib/getopts.c
@@ -45,8 +45,8 @@ static void usage(const char *progname,
 {
 	int i;
 
-	fprintf(stderr, "Usage: %s options...\n\nwhere valid options are\n\n",
-			progname);
+	fprintf(stderr, "Unknown option '%c'\nUsage: %s options...\n\n"
+		"where valid options are\n\n", optopt, progname);
 
 	for (i = 0; i < nr; ++i) {
 		const struct c2_getopts_opt *o;
@@ -54,7 +54,6 @@ static void usage(const char *progname,
 		o = &opts[i];
 		fprintf(stderr, "\t -%c %6.6s: %s\n", o->go_opt,
 			o->go_type == GOT_VOID ? "" : 
-			o->go_type == GOT_HELP ? "" :
 			o->go_type == GOT_FLAG ? "" : 
 			o->go_type == GOT_FORMAT ? "arg" : 
 			o->go_type == GOT_NUMBER ? "number" : "string",
@@ -73,6 +72,7 @@ static int getnum(const char *arg, const char *desc, int64_t *out)
 		return -EINVAL;
 	} else
 		return 0;
+	
 }
 
 int c2_getopts(const char *progname, int argc, char * const *argv,
@@ -93,8 +93,7 @@ int c2_getopts(const char *progname, int argc, char * const *argv,
                     option escape. */
 		C2_ASSERT(opts[i].go_opt != 'W');
 		optstring[scan++] = opts[i].go_opt;
-		if (opts[i].go_type != GOT_VOID && opts[i].go_type != GOT_FLAG
-		    && opts[i].go_type != GOT_HELP)
+		if (opts[i].go_type != GOT_VOID && opts[i].go_type != GOT_FLAG)
 			optstring[scan++] = ':';
 		if (opts[i].go_type == GOT_FLAG)
 			*opts[i].go_u.got_flag = false;
@@ -147,10 +146,6 @@ int c2_getopts(const char *progname, int argc, char * const *argv,
 			case GOT_FLAG:
 				*u->got_flag = true;
 				break;
-			case GOT_HELP:
-				usage(progname, opts, nr);
-				exit(EXIT_FAILURE);
-				break;
 			default:
 				C2_IMPOSSIBLE("Wrong option type.");
 			}
@@ -158,7 +153,6 @@ int c2_getopts(const char *progname, int argc, char * const *argv,
 		}
 		if (i == nr)  {
 			C2_ASSERT(ch == '?');
-			fprintf(stderr, "Unknown option '%c'\n", optopt);
 			usage(progname, opts, nr);
 			result = -EINVAL;
 		}
diff --git a/lib/getopts.h b/lib/getopts.h
index 80f9caf..79da102 100644
--- a/lib/getopts.h
+++ b/lib/getopts.h
@@ -84,13 +84,7 @@ enum c2_getopts_opt_type {
 	   encountered, the flag is set to false. No call-back is invoked. The
 	   user is expected to inspect the flag after c2_getopts() returns.
 	 */
-	GOT_FLAG,
-	/** An option without an argument.
-
-	    When this option encountered, program usage is printed to STDERR and
-	    program terminates immediately with exit(3).
-	 */
-	GOT_HELP
+	GOT_FLAG
 };
 
 /**
@@ -212,16 +206,6 @@ int c2_getopts(const char *progname, int argc, char * const *argv,
 	.go_u    = { .got_flag = (ptr) }	\
 }
 
-/**
-   Defines a GOT_HELP option.
- */
-#define C2_HELPARG(ch) {			\
-	.go_type = GOT_HELP,			\
-	.go_opt  = (ch),			\
-	.go_desc = "display this help and exit",\
-	.go_u    = { .got_void = NULL }		\
-}
-
 
 /** @} end of getopts group */
 
diff --git a/lib/linux_kernel/atomic64.h b/lib/linux_kernel/atomic64.h
index 4b4ef97..d39a590 100644
--- a/lib/linux_kernel/atomic64.h
+++ b/lib/linux_kernel/atomic64.h
@@ -49,37 +49,74 @@ PREFIX void c2_atomic64_set(struct c2_atomic64 *a, int64_t num)
 	atomic64_set(&a->a_value, num);
 }
 
+/**
+   Returns value of an atomic counter.
+ */
 PREFIX int64_t c2_atomic64_get(const struct c2_atomic64 *a)
 {
 	return	atomic64_read(&a->a_value);
 }
 
+/**
+ atomically increment counter
+
+ @param a pointer to atomic counter
+
+ @return none
+ */
 PREFIX void c2_atomic64_inc(struct c2_atomic64 *a)
 {
 	atomic64_inc(&a->a_value);
 }
 
+/**
+ atomically decrement counter
+
+ @param a pointer to atomic counter
+
+ @return none
+ */
 PREFIX void c2_atomic64_dec(struct c2_atomic64 *a)
 {
 	atomic64_dec(&a->a_value);
 }
 
+/**
+   Atomically adds given amount to a counter
+ */
 PREFIX void c2_atomic64_add(struct c2_atomic64 *a, int64_t num)
 {
 	atomic64_add(num, &a->a_value);
 }
 
+/**
+   Atomically subtracts given amount from a counter
+ */
 PREFIX void c2_atomic64_sub(struct c2_atomic64 *a, int64_t num)
 {
 	atomic64_sub(num, &a->a_value);
 }
 
 
+/**
+ atomically increment counter and return result
+
+ @param a pointer to atomic counter
+
+ @return new value of atomic counter
+ */
 PREFIX int64_t c2_atomic64_add_return(struct c2_atomic64 *a, int64_t delta)
 {
 	return atomic64_add_return(delta, &a->a_value);
 }
 
+/**
+ atomically decrement counter and return result
+
+ @param a pointer to atomic counter
+
+ @return new value of atomic counter
+ */
 PREFIX int64_t c2_atomic64_sub_return(struct c2_atomic64 *a, int64_t delta)
 {
 	return atomic64_sub_return(delta, &a->a_value);
@@ -95,17 +132,12 @@ PREFIX bool c2_atomic64_dec_and_test(struct c2_atomic64 *a)
 	return atomic64_dec_and_test(&a->a_value);
 }
 
-PREFIX bool c2_atomic64_cas(int64_t *loc, int64_t old, int64_t new)
-{
-	return cmpxchg64(loc, old, new) == old;
-}
-
 /** @} end of atomic group */
 
 /* __COLIBRI_LIB_LINUX_KERNEL_ATOMIC64_H__ */
 #endif
 
-/*
+/* 
  *  Local variables:
  *  c-indentation-style: "K&R"
  *  c-basic-offset: 8
diff --git a/lib/linux_kernel/kthread.c b/lib/linux_kernel/kthread.c
index 6366a1e..d037bd1 100644
--- a/lib/linux_kernel/kthread.c
+++ b/lib/linux_kernel/kthread.c
@@ -25,8 +25,7 @@
 #include "lib/assert.h"
 
 /**
-   @addtogroup kthread Kernel Thread Implementation
-   @ingroup thread
+   @addtogroup thread Thread
 
    Implementation of c2_thread on top of struct task_struct and kthread API.
 
@@ -34,22 +33,15 @@
    threads start executing the same trampoline function kthread_trampoline()
    that performs some generic book-keeping.
 
-   The kernel c2_thread_confine() implementation comes with strict usage
-   restrictions.  It manipulates fields of the task_struct directly rather than
-   using set_cpus_allowed_ptr(), and it does not protect against concurrent task
-   termination.  set_cpus_allowed_ptr() is not used because of GPL restrictions.
-   The task is not protected from termination because that requires the use of
-   get_task_struct() and put_task_struct(), however put_task_struct() is inlined
-   and references __put_task_struct() and the latter is not exported.  An easy
-   way to ensure the task will not terminate is to call c2_thread_confine() from
-   the task to be confined.
-
-   @note Unless the thread being confined by c2_thread_confine() is the current
-   thread, the thread will not migrate to a CPU in the bitmap until the next
-   time it next blocks (unschedules) and subsequently resumes.  Task migration
-   is not an exported function of kernel/sched.c.  When the current thread is
-   confined, c2_thread_confine() causes the task to block and resume, so this
-   function must be used in a context where scheduling is allowed.
+   Presently, the kernel c2_thread_confine only succeeds when the thread
+   referenced is the current thread.  This is because the interfaces required
+   to safely reference other threads are not all exported, most notably,
+   the matched pair get_task_struct() and put_task_struct() are required to
+   ensure a task will not be deallocated while set_cpus_allowed_ptr() is called,
+   however, put_task_struct() references __put_task_struct() and the latter
+   is not exported.  By restricting to the current thread, we can ensure the
+   thread will not be deallocated during the call without using this pair of
+   reference counting functions.
 
    @{
  */
@@ -57,21 +49,17 @@
 static int kthread_trampoline(void *arg)
 {
 	struct c2_thread *t = arg;
+	c2_thread_trampoline(arg);
+
 	/* Required for correct c2_thread_join() behavior in kernel:
 	   kthread_stop() will not stop if the thread has been created but has
 	   not yet started executing.  So, c2_thread_join() blocks on the
-	   semaphore to ensure the thread can be stopped iff t_init != NULL
-	   (when t_init == NULL, blocking occurs in c2_thread_init).
-	   kthread_stop(), in turn, requires that the thread not exit until
-	   kthread_stop() is called, so we must loop on kthread_should_stop()
-	   to satisfy that API requirement.  The semaphore is signalled before
-	   calling the thread function so that other kernel code, such
-	   as SUNRPC service code, can still depend on kthread_should_stop().
+	   semaphore to ensure the thread can be stopped. kthread_stop(), in
+	   turn, requires that the thread not exit until kthread_stop() is
+	   called, so we must loop on kthread_should_stop() to satisfy that API
+	   requirement.
 	 */
-	if (t->t_init == NULL)
-		c2_semaphore_up(&t->t_wait);
-	c2_thread_trampoline(arg);
-
+	c2_semaphore_up(&t->t_wait);
 	set_current_state(TASK_INTERRUPTIBLE);
 	while (!kthread_should_stop()) {
 		schedule();
@@ -106,13 +94,12 @@ int c2_thread_join(struct c2_thread *q)
 	C2_PRE(q->t_h.h_t != current);
 
 	/* see comment in kthread_trampoline */
-	if (q->t_init == NULL)
-		c2_semaphore_down(&q->t_wait);
+	c2_semaphore_down(&q->t_wait);
 	/*
-	  c2_thread provides no wrappers for do_exit(), so this will block
-	  until the thread exits by returning from kthread_trampoline.
-	  kthread_trampoline() always returns 0, but kthread_stop() can return
-	  -errno on failure.
+	  c2_thread provides no wrappers for kthread_should_stop() or
+	  do_exit(), so this will block until the thread exits by returning
+	  from kthread_trampoline.  kthread_trampoline always returns 0,
+	  but kthread_stop can return -errno on failure.
 	 */
 	result = kthread_stop(q->t_h.h_t);
 	if (result == 0)
@@ -125,61 +112,69 @@ int c2_thread_signal(struct c2_thread *q, int sig)
 {
 	return -ENOSYS;
 }
+C2_EXPORTED(c2_thread_signal);
 
 int c2_thread_confine(struct c2_thread *q, const struct c2_bitmap *processors)
 {
-	int                 result = 0;
+#if 1
+	/*
+	  For now, not implemented because it needs to call GPL functions to
+	  succeed.  See also problems with put_task_struct mentioned below.
+	 */
+	return -ENOSYS;
+#else
+	int                 result;
 	size_t              idx;
 	size_t              nr_bits = min64u(processors->b_nr, nr_cpu_ids);
 	cpumask_var_t       cpuset;
-	struct task_struct *p = q->t_h.h_t;
-	int                 nr_allowed;
+	struct task_struct *p;
 
-	if (!zalloc_cpumask_var(&cpuset, GFP_KERNEL))
+	if (q->t_h.h_t != current) {
+		return -EINVAL;
+	}
+	p = q->t_h.h_t;
+
+	if (!alloc_cpumask_var(&cpuset, GFP_KERNEL)) {
 		return -ENOMEM;
+	}
+	cpumask_clear(cpuset);
 
-	for (idx = 0; idx < nr_bits; ++idx)
+	for (idx = 0; idx < nr_bits; ++idx) {
 		if (c2_bitmap_get(processors, idx))
 			cpumask_set_cpu(idx, cpuset);
-	nr_allowed = cpumask_weight(cpuset);
-
-	if (nr_allowed == 0) {
-		result = -EINVAL;
-	} else {
-		/*
-		  The following code would safely access the task_struct and
-		  ensure it would not disappear, however put_task_struct is an
-		  inline that references __put_task_struct, and the latter is
-		  not exported.  See the notes at the top of this file.
+	}
 
-		  get_task_struct(p);
+	/*
+	  The following code would safely find the task_struct and ensure it
+	  would not disappear, however, put_task_struct is an inline that
+	  references __put_task_struct, and the latter is not exported.
 
-		  ...
+	get_task_struct(p);
 
-		  put_task_struct(p);
-		*/
+	...
 
-		cpumask_copy(&p->cpus_allowed, cpuset);
-		p->rt.nr_cpus_allowed = nr_allowed;
+	put_task_struct(p);
+	*/
 
-		/* cause current task to migrate immediately by blocking */
-		if (p == current && !cpumask_test_cpu(task_cpu(p), cpuset))
-			schedule_timeout_uninterruptible(1);
-	}
+	result = set_cpus_allowed_ptr(p, cpuset);
 	free_cpumask_var(cpuset);
 	return result;
+#endif
 }
+C2_EXPORTED(c2_thread_confine);
 
 void c2_thread_self(struct c2_thread_handle *id)
 {
 	id->h_t = current;
 }
+C2_EXPORTED(c2_thread_self);
 
 bool c2_thread_handle_eq(struct c2_thread_handle *h1,
 			 struct c2_thread_handle *h2)
 {
 	return h1->h_t == h2->h_t;
 }
+C2_EXPORTED(c2_thread_handle_eq);
 
 /** @} end of thread group */
 
diff --git a/lib/linux_kernel/ktime.c b/lib/linux_kernel/ktime.c
index 51f807f..c2f1b31 100644
--- a/lib/linux_kernel/ktime.c
+++ b/lib/linux_kernel/ktime.c
@@ -35,15 +35,14 @@
    @{
 */
 
-c2_time_t c2_time_now(void)
+c2_time_t c2_time_now(c2_time_t *time)
 {
 	struct timespec ts;
-	c2_time_t	t;
 
+	C2_PRE(time != NULL);
 	ts = current_kernel_time();
-	c2_time_set(&t, ts.tv_sec,  ts.tv_nsec);
-
-	return t;
+	c2_time_set(time, ts.tv_sec,  ts.tv_nsec);
+	return *time;
 }
 C2_EXPORTED(c2_time_now);
 
diff --git a/lib/linux_kernel/ktrace.c b/lib/linux_kernel/ktrace.c
deleted file mode 100644
index 746be5a..0000000
--- a/lib/linux_kernel/ktrace.c
+++ /dev/null
@@ -1,72 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2012 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Andriy Tkachuk <Andriy_Tkachuk@xyratex.com>
- * Original creation date: 02/16/2012
- */
-
-#include <linux/slab.h>
-#include <linux/sched.h>
-
-#include "lib/errno.h"
-#include "lib/atomic.h"
-#include "lib/arith.h" /* c2_align */
-#include "lib/trace.h"
-
-/**
- * @addtogroup trace
- *
- * <b>Tracing facilities kernel specific stuff</b>
- *
- * @{
- */
-
-module_param(c2_trace_immediate_mask, ulong, 0644);
-MODULE_PARM_DESC(c2_trace_immediate_mask,
-		 "The bitmask of what should be printed immediately to console");
-
-int c2_arch_trace_init(void)
-{
-	c2_logbuf = kzalloc(c2_logbufsize, GFP_KERNEL);
-	if (c2_logbuf == NULL)
-		return -ENOMEM;
-
-	printk("Colibri trace buffer address: 0x%p\n", c2_logbuf);
-
-	return 0;
-}
-
-void c2_arch_trace_fini(void)
-{
-	kfree(c2_logbuf);
-}
-
-void c2_console_vprintf(const char *fmt, va_list args)
-{
-	vprintk(fmt, args);
-}
-
-/** @} end of trace group */
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
diff --git a/lib/linux_kernel/kvec.c b/lib/linux_kernel/kvec.c
deleted file mode 100644
index 330a76a..0000000
--- a/lib/linux_kernel/kvec.c
+++ /dev/null
@@ -1,47 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Anand Vidwansa <anand_vidwansa@xyratex.com>
- * Original creation date: 10/11/2011
- */
-
-#include "lib/types.h"
-#include "lib/assert.h"
-#include "lib/vec.h"
-#include "lib/cdefs.h"
-#include <linux/pagemap.h> /* PAGE_CACHE_SIZE */
-
-int c2_0vec_page_add(struct c2_0vec *zvec,
-		     struct page *pg,
-		     c2_bindex_t index)
-{
-	struct c2_buf	  buf;
-
-	buf.b_addr = page_address(pg);
-	buf.b_nob = PAGE_CACHE_SIZE;
-
-	return c2_0vec_cbuf_add(zvec, &buf, &index);
-}
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
diff --git a/lib/linux_kernel/main.c b/lib/linux_kernel/main.c
index 5dc523b..2193583 100644
--- a/lib/linux_kernel/main.c
+++ b/lib/linux_kernel/main.c
@@ -20,46 +20,15 @@
 #include <linux/kernel.h>
 #include <linux/init.h>
 
-#include "lib/ut.h"
-#include "lib/cdefs.h" /* for C2_EXPORTED */
+MODULE_AUTHOR("Xyratex International");
+MODULE_DESCRIPTION("Colibri Library");
+MODULE_LICENSE("proprietary");
 
-/* These unit tests are done in the kernel */
-extern void test_bitmap(void);
-extern void test_chan(void);
-extern void test_list(void);
-extern void test_tlist(void);
-extern void test_mutex(void);
-extern void test_queue(void);
-extern void test_refs(void);
-extern void test_rw(void);
-extern void test_thread(void);
-extern void test_time(void);
-extern void test_trace(void);
-extern void test_vec(void);
-extern void test_zerovec(void);
-extern void test_bob(void);
-
-const struct c2_test_suite c2_klibc2_ut = {
-	.ts_name = "klibc2-ut",
-	.ts_init = NULL,
-	.ts_fini = NULL,
-	.ts_tests = {
-		{ "bitmap",    test_bitmap    },
-		{ "bob",       test_bob       },
-		{ "chan",      test_chan      },
-		{ "list",      test_list      },
-		{ "tlist",     test_tlist     },
-		{ "mutex",     test_mutex     },
-		{ "queue",     test_queue     },
-		{ "refs",      test_refs      },
-		{ "rwlock",    test_rw        },
-		{ "thread",    test_thread    },
-		{ "time",      test_time      },
-		{ "trace",     test_trace     },
-		{ "vec",       test_vec       },
-		{ "zerovec",   test_zerovec   },
-		{ NULL,        NULL           }
-	}
-};
-C2_EXPORTED(c2_klibc2_ut);
+int init_module(void)
+{
+	return 0;
+}
 
+void cleanup_module(void)
+{
+}
diff --git a/lib/linux_kernel/memory.c b/lib/linux_kernel/memory.c
index b436dcd..d109a81 100644
--- a/lib/linux_kernel/memory.c
+++ b/lib/linux_kernel/memory.c
@@ -1,3 +1,4 @@
+#ifdef HAVE_CONFIG_H
 /*
  * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
  *
@@ -16,8 +17,6 @@
  * Original author: Nikita Danilov <nikita_danilov@xyratex.com>
  * Original creation date: 08/04/2010
  */
-
-#ifdef HAVE_CONFIG_H
 #  include <config.h>
 #endif
 
@@ -53,14 +52,9 @@ size_t c2_allocated(void)
 }
 C2_EXPORTED(c2_allocated);
 
-int c2_pagesize_get(void)
-{
-	return PAGE_SIZE;
-}
-
 /** @} end of memory group */
 
-/*
+/* 
  *  Local variables:
  *  c-indentation-style: "K&R"
  *  c-basic-offset: 8
diff --git a/lib/linux_kernel/mutex.c b/lib/linux_kernel/mutex.c
index 4564c81..c6be2b1 100644
--- a/lib/linux_kernel/mutex.c
+++ b/lib/linux_kernel/mutex.c
@@ -54,6 +54,7 @@ int c2_mutex_trylock(struct c2_mutex *mutex)
 {
 	return mutex_trylock(&mutex->m_mutex);
 }
+C2_EXPORTED(c2_mutex_trylock);
 
 void c2_mutex_unlock(struct c2_mutex *mutex)
 {
@@ -65,11 +66,13 @@ bool c2_mutex_is_locked(const struct c2_mutex *mutex)
 {
 	return true;
 }
+C2_EXPORTED(c2_mutex_is_locked);
 
 bool c2_mutex_is_not_locked(const struct c2_mutex *mutex)
 {
 	return true;
 }
+C2_EXPORTED(c2_mutex_is_not_locked);
 
 /** @} end of mutex group */
 
diff --git a/lib/linux_kernel/processor.c b/lib/linux_kernel/processor.c
index 05c14d9..cbb324b 100644
--- a/lib/linux_kernel/processor.c
+++ b/lib/linux_kernel/processor.c
@@ -855,6 +855,17 @@ c2_processor_nr_t c2_processor_getcpu(void)
 	return cpu;
 }
 
+/** Export interfaces */
+C2_EXPORTED(c2_processors_init);
+C2_EXPORTED(c2_processors_fini);
+C2_EXPORTED(c2_processor_is_initialized);
+C2_EXPORTED(c2_processor_nr_max);
+C2_EXPORTED(c2_processors_possible);
+C2_EXPORTED(c2_processors_available);
+C2_EXPORTED(c2_processors_online);
+C2_EXPORTED(c2_processor_describe);
+C2_EXPORTED(c2_processor_getcpu);
+
 
 /*
  *  Local variables:
diff --git a/lib/linux_kernel/rwlock.c b/lib/linux_kernel/rwlock.c
index fb06ab6..1cbdd3e 100644
--- a/lib/linux_kernel/rwlock.c
+++ b/lib/linux_kernel/rwlock.c
@@ -33,31 +33,37 @@ void c2_rwlock_init(struct c2_rwlock *lock)
 {
 	init_rwsem(&lock->rw_sem);
 }
+C2_EXPORTED(c2_rwlock_init);
 
 void c2_rwlock_fini(struct c2_rwlock *lock)
 {
 	C2_ASSERT(!rwsem_is_locked(&lock->rw_sem));
 }
+C2_EXPORTED(c2_rwlock_fini);
 
 void c2_rwlock_write_lock(struct c2_rwlock *lock)
 {
 	down_write(&lock->rw_sem);
 }
+C2_EXPORTED(c2_rwlock_write_lock);
 
 void c2_rwlock_write_unlock(struct c2_rwlock *lock)
 {
 	up_write(&lock->rw_sem);
 }
+C2_EXPORTED(c2_rwlock_write_unlock);
 
 void c2_rwlock_read_lock(struct c2_rwlock *lock)
 {
 	down_read(&lock->rw_sem);
 }
+C2_EXPORTED(c2_rwlock_read_lock);
 
 void c2_rwlock_read_unlock(struct c2_rwlock *lock)
 {
 	up_read(&lock->rw_sem);
 }
+C2_EXPORTED(c2_rwlock_read_unlock);
 
 /** @} end of rwlock group */
 
diff --git a/lib/linux_kernel/semaphore.c b/lib/linux_kernel/semaphore.c
index d149de5..6b8a120 100644
--- a/lib/linux_kernel/semaphore.c
+++ b/lib/linux_kernel/semaphore.c
@@ -38,51 +38,45 @@ int c2_semaphore_init(struct c2_semaphore *semaphore, unsigned value)
 	sema_init(&semaphore->s_sem, value);
 	return 0;
 }
+C2_EXPORTED(c2_semaphore_init);
 
 void c2_semaphore_fini(struct c2_semaphore *semaphore)
 {
 }
+C2_EXPORTED(c2_semaphore_fini);
 
 void c2_semaphore_down(struct c2_semaphore *semaphore)
 {
 	down(&semaphore->s_sem);
 }
+C2_EXPORTED(c2_semaphore_down);
 
 int c2_semaphore_trydown(struct c2_semaphore *semaphore)
 {
 	return !down_trylock(&semaphore->s_sem);
 }
+C2_EXPORTED(c2_semaphore_trydown);
 
 void c2_semaphore_up(struct c2_semaphore *semaphore)
 {
 	up(&semaphore->s_sem);
 }
+C2_EXPORTED(c2_semaphore_up);
 
 unsigned c2_semaphore_value(struct c2_semaphore *semaphore)
 {
 	return semaphore->s_sem.count;
 }
+C2_EXPORTED(c2_semaphore_value);
 
 bool c2_semaphore_timeddown(struct c2_semaphore *semaphore,
 			    const c2_time_t abs_timeout)
 {
-	c2_time_t nowtime;
-	c2_time_t reltime;
-	unsigned long reljiffies;
-	struct timespec ts;
-
-	nowtime = c2_time_now();
-	/* same semantics as user_space semaphore: allow abs_time < now */
-	if (c2_time_after(abs_timeout, nowtime))
-		reltime = c2_time_sub(abs_timeout, nowtime);
-	else
-		reltime = 0;
-	ts.tv_sec  = c2_time_seconds(reltime);
-	ts.tv_nsec = c2_time_nanoseconds(reltime);
-	reljiffies = timespec_to_jiffies(&ts);
-
-	return down_timeout(&semaphore->s_sem, reljiffies) == 0;
+	/* not implemented, until kernel lib/time.h supports a notion of current
+	   time. */
+	return -ENOSYS;
 }
+C2_EXPORTED(c2_semaphore_timeddown);
 
 /** @} end of semaphore group */
 
diff --git a/lib/linux_kernel/timer.c b/lib/linux_kernel/timer.c
index 2bbba95..024583a 100644
--- a/lib/linux_kernel/timer.c
+++ b/lib/linux_kernel/timer.c
@@ -15,12 +15,10 @@
  * http://www.xyratex.com/contact
  *
  * Original author: Huang Hua <hua_huang@xyratex.com>
- *                  Maxim Medved <Max_Medved@xyratex.com>
  * Original creation date: 03/04/2011
  */
 
 #include <linux/module.h>
-#include <linux/jiffies.h>
 
 #include "lib/cdefs.h"  /* C2_EXPORTED */
 #include "lib/time.h"
@@ -37,19 +35,32 @@
 
 void c2_timer_trampoline_callback(unsigned long data)
 {
-	struct c2_timer *timer = (struct c2_timer*)data;
+	struct c2_timer   *timer = (struct c2_timer*)data;
+	struct timer_list *tl = &timer->t_timer;
+	struct timespec    ts = {
+			.tv_sec  = c2_time_seconds(timer->t_interval),
+			.tv_nsec = c2_time_nanoseconds(timer->t_interval)
+		};
+
+	/* new expire */
+	tl->expires += timespec_to_jiffies(&ts);
 
 	/* call the user callback */
 	C2_ASSERT(timer->t_callback != NULL);
 	timer->t_callback(timer->t_data);
-	timer->t_running = false;
+
+	/* detect the left count, decrease and add timer again if needed */
+	if (timer->t_left > 0) {
+		timer->t_left --;
+		add_timer(tl);
+	}
 }
 
 /**
    Init the timer data structure.
  */
 int c2_timer_init(struct c2_timer *timer, enum c2_timer_type type,
-		  c2_time_t expire,
+		  c2_time_t interval, uint64_t repeat,
 		  c2_timer_callback_t callback, unsigned long data)
 {
 	struct timer_list *tl;
@@ -58,8 +69,9 @@ int c2_timer_init(struct c2_timer *timer, enum c2_timer_type type,
 	C2_PRE(type == C2_TIMER_SOFT || type == C2_TIMER_HARD);
 
 	timer->t_type     = type;
-	timer->t_expire   = expire;
-	timer->t_running  = false;
+	timer->t_interval = interval;
+	timer->t_repeat   = repeat;
+	timer->t_left     = 0;
 	timer->t_callback = callback;
 	timer->t_data     = data;
 
@@ -70,62 +82,58 @@ int c2_timer_init(struct c2_timer *timer, enum c2_timer_type type,
 	return 0;
 }
 
+C2_EXPORTED(c2_timer_init);
 
 /**
    Start a timer.
  */
 int c2_timer_start(struct c2_timer *timer)
 {
-	c2_time_t now = c2_time_now();
-	c2_time_t rem;
-	struct timespec ts;
-
-	if (timer->t_running)
+	struct timespec ts = {
+			.tv_sec  = c2_time_seconds(timer->t_interval),
+			.tv_nsec = c2_time_nanoseconds(timer->t_interval)
+		};
+	if (timer->t_left > 0) {
 		return -EBUSY;
+	}
 
 	C2_ASSERT(timer->t_callback != NULL);
 
-	if (c2_time_after(timer->t_expire, now))
-		rem = c2_time_sub(timer->t_expire, now);
-	else
-		c2_time_set(&rem, 0, 0);
-	ts.tv_sec  = c2_time_seconds(rem);
-	ts.tv_nsec = c2_time_nanoseconds(rem);
-	timer->t_timer.expires = jiffies + timespec_to_jiffies(&ts);
-
-	timer->t_running = true;
-	add_timer(&timer->t_timer);
+	timer->t_left = timer->t_repeat;
+	if (timer->t_left > 0) {
+		timer->t_timer.expires = jiffies +
+				 timespec_to_jiffies(&ts);
+		add_timer(&timer->t_timer);
+	}
 	return 0;
 }
+C2_EXPORTED(c2_timer_start);
+
 
 /**
    Stop a timer.
  */
 int c2_timer_stop(struct c2_timer *timer)
 {
-	int rc = del_timer_sync(&timer->t_timer);
-
-	timer->t_running = false;
-	return rc;
-}
-
-bool c2_timer_is_started(const struct c2_timer *timer)
-{
-	return timer->t_running;
+	timer->t_left = 0;
+	return del_timer_sync(&timer->t_timer);
 }
+C2_EXPORTED(c2_timer_stop);
 
 /**
    Destroy the timer.
  */
-int c2_timer_fini(struct c2_timer *timer)
+void c2_timer_fini(struct c2_timer *timer)
 {
-	timer->t_running = false;
+	timer->t_repeat = 0;
+	timer->t_left   = 0;
 	timer->t_callback = NULL;
 	timer->t_data = 0;
-	return 0;
+	return;
 }
+C2_EXPORTED(c2_timer_fini);
 
-/** @} end of timer group */
+/** @} end of mutex group */
 
 /*
  *  Local variables:
diff --git a/lib/linux_kernel/timer.h b/lib/linux_kernel/timer.h
index 993addc..0ac5ece 100644
--- a/lib/linux_kernel/timer.h
+++ b/lib/linux_kernel/timer.h
@@ -15,7 +15,6 @@
  * http://www.xyratex.com/contact
  *
  * Original author: Huang Hua <hua_huang@xyratex.com>
- *                  Maxim Medved <Max_Medved@xyratex.com>
  * Original creation date: 03/04/2011
  */
 
@@ -38,19 +37,32 @@ struct c2_timer {
 	enum c2_timer_type t_type;
 
 	/**
-	   The expiration time for timer.
+	   The interval to trigger the timer callback.
 	 */
-	c2_time_t t_expire;
+	c2_time_t t_interval;
 
 	/**
-	   Timer triggers this callback.
+	   the repeat count for this timer.
+
+	   Initial value of 0XFFFFFFFFFFFFFFFF means the timer will be triggered
+	   infinitely before wrapping.
 	 */
-	c2_timer_callback_t t_callback;
+	uint64_t       t_repeat;
+
+	/**
+	   the left count for this timer.
+
+	   This value will be decreased everytime a timeout happens.
+	   If this value reaches zero, time is stopped/unarmed.
+	   The initial value of @t_left is equal to @t_repeat.
+	 */
+	uint64_t       t_left;
+
 
 	/**
-	   Is timer running now?
+	   Timer triggers this callback.
 	 */
-	bool t_running;
+	c2_timer_callback_t t_callback;
 
 	/**
 	   User data.
diff --git a/lib/linux_kernel/types.h b/lib/linux_kernel/types.h
index 13bdb1d..2113958 100644
--- a/lib/linux_kernel/types.h
+++ b/lib/linux_kernel/types.h
@@ -25,7 +25,6 @@
 
 #define UINT32_MAX ((uint32_t)(~((uint32_t) 0)))  /* 0xFFFFFFFF */
 #define UINT64_MAX ((uint64_t)(~((uint64_t) 0)))  /* 0xFFFFFFFFFFFFFFFF */
-#define INT64_MAX ((int64_t)((~(uint64_t)0) >> 1))  /* 0x3FFFFFFFFFFFFFFF */
 
 /* __COLIBRI_LIB_LINUX_KERNEL_TYPES_H_ */
 #endif
diff --git a/lib/linux_kernel/ut.c b/lib/linux_kernel/ut.c
index 7f4eae2..d8bd4aa 100644
--- a/lib/linux_kernel/ut.c
+++ b/lib/linux_kernel/ut.c
@@ -89,7 +89,7 @@ static void uts_summary(void)
 	c2_time_t diff;
 	int64_t msec;
 
-	now = c2_time_now();
+	c2_time_now(&now);
 	diff = c2_time_sub(now, started);
 	msec = (c2_time_nanoseconds(diff) + ONE_MILLION / 2) / ONE_MILLION;
 
@@ -107,8 +107,11 @@ static void uts_summary(void)
 	       c2_time_seconds(diff), msec);
 }
 
-void c2_ut_run(void)
+void c2_ut_run(const char *log_file)
 {
+	/* maybe in the future we can use log_file as a /proc
+	   file or something. For now it is ignored.
+	*/
 	struct test_suite_elem *ts;
 	struct c2_list_link    *pos;
 	const struct c2_test   *t;
@@ -120,7 +123,7 @@ void c2_ut_run(void)
 	test_failed = 0;
 	passed = 0;
 	failed = 0;
-	started = c2_time_now();
+	c2_time_now(&started);
 
 	c2_list_for_each(&suites, pos) {
 		bool suite_ok = true;
diff --git a/lib/linux_kernel/vec.h b/lib/linux_kernel/vec.h
deleted file mode 100644
index d6dd8d9..0000000
--- a/lib/linux_kernel/vec.h
+++ /dev/null
@@ -1,60 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Anand Vidwansa <anand_vidwansa@xyratex.com>
- * Original creation date: 10/11/2011
- */
-
-#ifndef __COLIBRI_LIB_LINUX_KERNEL_VEC_H__
-#define __COLIBRI_LIB_LINUX_KERNEL_VEC_H__
-
-#include "lib/types.h"
-
-/**
-   @addtogroup vec
-   @{
-*/
-
-struct page;
-struct c2_0vec;
-
-/**
-   Add a struct page to contents of c2_0vec structure.
-   Struct page is kernel representation of a buffer.
-   @note The c2_0vec struct should be allocated by user.
-
-   @param zvec The c2_0vec struct to be initialized.
-   @param pages Array of kernel pages.
-   @param index The target object offset for page.
-   @post ++zvec->z_cursor.bc_vc.vc_seg
- */
-int c2_0vec_page_add(struct c2_0vec *zvec, struct page *pg,
-		     c2_bindex_t index);
-
-/** @} end of vec group */
-
-/* __COLIBRI_LIB_LINUX_KERNEL_VEC_H__ */
-#endif
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
diff --git a/lib/list.c b/lib/list.c
index 508c5c7..29acabe 100644
--- a/lib/list.c
+++ b/lib/list.c
@@ -14,8 +14,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Alexey Lyashkov <Alexey_Lyashkov@xyratex.com>,
- *                  Nikita Danilov <Nikita_Danilov@xyratex.com>
+ * Original author: Alexey Lyashkov, Nikita Danilov
  * Original creation date: 04/17/2010
  */
 #include "lib/assert.h"
@@ -55,11 +54,13 @@ bool c2_list_link_invariant(const struct c2_list_link *link)
 	}
 	return true;
 }
+C2_EXPORTED(c2_list_link_invariant);
 
 bool c2_list_invariant(const struct c2_list *head)
 {
 	return c2_list_link_invariant((void *)head);
 }
+C2_EXPORTED(c2_list_invariant);
 
 size_t c2_list_length(const struct c2_list *list)
 {
@@ -72,6 +73,7 @@ size_t c2_list_length(const struct c2_list *list)
 		length++;
 	return length;
 }
+C2_EXPORTED(c2_list_length);
 
 bool c2_list_contains(const struct c2_list *list,
 		      const struct c2_list_link *link)
@@ -84,6 +86,7 @@ bool c2_list_contains(const struct c2_list *list,
 			return true;
 	return false;
 }
+C2_EXPORTED(c2_list_contains);
 
 static inline void __c2_list_add(struct c2_list_link *next,
 				 struct c2_list_link *prev,
@@ -143,6 +146,7 @@ void c2_list_move(struct c2_list *head, struct c2_list_link *old)
 	c2_list_add(head, old);
 	C2_ASSERT(c2_list_invariant(head));
 }
+C2_EXPORTED(c2_list_move);
 
 void c2_list_move_tail(struct c2_list *head, struct c2_list_link *old)
 {
@@ -150,6 +154,7 @@ void c2_list_move_tail(struct c2_list *head, struct c2_list_link *old)
 	c2_list_add_tail(head, old);
 	C2_ASSERT(c2_list_invariant(head));
 }
+C2_EXPORTED(c2_list_move_tail);
 
 void c2_list_link_init(struct c2_list_link *link)
 {
@@ -162,17 +167,13 @@ void c2_list_link_fini(struct c2_list_link *link)
 {
 	C2_ASSERT(!c2_list_link_is_in(link));
 }
+C2_EXPORTED(c2_list_link_fini);
 
 bool c2_list_link_is_in(const struct c2_list_link *link)
 {
 	return link->ll_prev != link;
 }
-
-bool c2_list_link_is_last(const struct c2_list_link	*link,
-			  const struct c2_list		*head)
-{
-	return link->ll_next == (void *)head;
-}
+C2_EXPORTED(c2_list_link_is_in);
 
 /** @} end of list group */
 
diff --git a/lib/list.h b/lib/list.h
index 49995d0..dcbc76a 100644
--- a/lib/list.h
+++ b/lib/list.h
@@ -14,8 +14,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Alexey Lyashkov <Alexey_Lyashkov@xyratex.com>,
- *                  Nikita Danilov <Nikita_Danilov@xyratex.com>
+ * Original author: Alexey Lyashkov, Nikita Danilov
  * Original creation date: 04/17/2010
  */
 
@@ -199,9 +198,6 @@ static inline struct c2_list_link *c2_list_first(const struct c2_list *head)
 */
 bool c2_list_link_is_in(const struct c2_list_link *link);
 
-bool c2_list_link_is_last(const struct c2_list_link *link,
-			  const struct c2_list      *head);
-
 size_t c2_list_length(const struct c2_list *list);
 
 /**
diff --git a/lib/memory.h b/lib/memory.h
index ea43e1d..4ff8fe7 100644
--- a/lib/memory.h
+++ b/lib/memory.h
@@ -13,7 +13,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Nikita Danilov <Nikita_Danilov@xyratex.com>
+ * Original author: Nikita Danilov
  * Original creation date: 05/17/2010
  */
 
@@ -70,12 +70,6 @@ void c2_free(void *data);
  */
 size_t c2_allocated(void);
 
-/**
- * Same as system getpagesize(3).
- * Used in the code shared between user and kernel.
- */
-int c2_pagesize_get(void);
-
 /** @} end of memory group */
 
 #endif
diff --git a/lib/misc.c b/lib/misc.c
index 9d87b08..153777a 100644
--- a/lib/misc.c
+++ b/lib/misc.c
@@ -14,7 +14,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Nikita Danilov <Nikita_Danilov@xyratex.com>
+ * Original author: Nikita Danilov
  * Original creation date: 06/18/2010
  */
 
@@ -35,11 +35,13 @@ bool c2_uint128_eq(const struct c2_uint128 *u0, const struct c2_uint128 *u1)
 {
 	return c2_uint128_cmp(u0, u1) == 0;
 }
+C2_EXPORTED(c2_uint128_eq);
 
 int c2_uint128_cmp(const struct c2_uint128 *u0, const struct c2_uint128 *u1)
 {
 	return C2_3WAY(u0->u_hi, u1->u_hi) ?: C2_3WAY(u0->u_lo, u1->u_lo);
 }
+C2_EXPORTED(c2_uint128_cmp);
 
 #if 0
 uint64_t c2_rnd(uint64_t max, uint64_t *prev)
@@ -69,6 +71,7 @@ uint64_t c2_rnd(uint64_t max, uint64_t *prev)
         /*Take value from higher 48 bits */
         return (result >> 16) * max / ((~0UL) >> 16);
 }
+C2_EXPORTED(c2_rnd);
 
 uint64_t c2_gcd64(uint64_t p, uint64_t q)
 {
@@ -81,6 +84,7 @@ uint64_t c2_gcd64(uint64_t p, uint64_t q)
 	}
 	return p;
 }
+C2_EXPORTED(c2_gcd64);
 
 static uint64_t c2u64(const unsigned char *s)
 {
@@ -98,6 +102,7 @@ void c2_uint128_init(struct c2_uint128 *u128, const char *magic)
 	u128->u_hi = c2u64((const unsigned char *)magic);
 	u128->u_lo = c2u64((const unsigned char *)magic + 8);
 }
+C2_EXPORTED(c2_uint128_init);
 
 enum {
 	C2_MOD_SAFE_LIMIT = UINT64_MAX/32
diff --git a/lib/misc.h b/lib/misc.h
index 676277a..936371e 100644
--- a/lib/misc.h
+++ b/lib/misc.h
@@ -14,7 +14,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Nikita Danilov <Nikita_Danilov@xyratex.com>
+ * Original author: Nikita Danilov
  * Original creation date: 06/18/2010
  */
 
diff --git a/lib/mutex.c b/lib/mutex.c
index 9bf4a8f..07eb975 100644
--- a/lib/mutex.c
+++ b/lib/mutex.c
@@ -14,7 +14,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Nikita Danilov <Nikita_Danilov@xyratex.com>
+ * Original author: Nikita Danilov
  * Original creation date: 05/13/2010
  */
 
diff --git a/lib/mutex.h b/lib/mutex.h
index 62c2a81..80c6d36 100644
--- a/lib/mutex.h
+++ b/lib/mutex.h
@@ -14,7 +14,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Nikita Danilov <Nikita_Danilov@xyratex.com>
+ * Original author: Nikita Danilov
  * Original creation date: 05/13/2010
  */
 
diff --git a/lib/processor.h b/lib/processor.h
index b350210..0cd12cf 100644
--- a/lib/processor.h
+++ b/lib/processor.h
@@ -14,8 +14,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Rajesh Bhalerao <Rajesh_Bhalerao@xyratex.com>,
- *                  Nikita Danilov <Nikita_Danilov@xyratex.com>
+ * Original author: Rajesh Bhalerao, Nikita Danilov
  * Original creation date: 02/18/2011
  */
 
@@ -26,7 +25,7 @@
 #include "lib/types.h"
 
 /**
-   @defgroup Processor
+   @defgroup processor Processor
 
    Interfaces to learn the number and characteristics of "processors"
    for a given system/node.
diff --git a/lib/queue.c b/lib/queue.c
index 2f65c7c..dfb2a1f 100644
--- a/lib/queue.c
+++ b/lib/queue.c
@@ -14,7 +14,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Nikita Danilov <Nikita_Danilov@xyratex.com>
+ * Original author: Nikita Danilov
  * Original creation date: 05/07/2011
  */
 
diff --git a/lib/queue.h b/lib/queue.h
index 14bf0fc..de134fa 100644
--- a/lib/queue.h
+++ b/lib/queue.h
@@ -14,7 +14,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Nikita Danilov <Nikita_Danilov@xyratex.com>
+ * Original author: Nikita Danilov
  * Original creation date: 05/07/2011
  */
 
diff --git a/lib/refs.c b/lib/refs.c
index a7118c6..cc5a7fd 100644
--- a/lib/refs.c
+++ b/lib/refs.c
@@ -13,7 +13,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Alexey Lyashkov <Alexey_Lyashkov@xyratex.com>
+ * Original author: Alexey Lyashkov
  * Original creation date: 04/08/2010
  */
 
@@ -25,11 +25,13 @@ void c2_ref_init(struct c2_ref *ref, int init_num,
 	c2_atomic64_set(&ref->ref_cnt, init_num);
 	ref->release = release;
 }
+C2_EXPORTED(c2_ref_init);
 
 void c2_ref_get(struct c2_ref *ref)
 {
 	c2_atomic64_inc(&ref->ref_cnt);
 }
+C2_EXPORTED(c2_ref_get);
 
 void c2_ref_put(struct c2_ref *ref)
 {
@@ -37,4 +39,4 @@ void c2_ref_put(struct c2_ref *ref)
 		ref->release(ref);
 	}
 }
-
+C2_EXPORTED(c2_ref_put);
diff --git a/lib/refs.h b/lib/refs.h
index 67e33af..7bf7874 100644
--- a/lib/refs.h
+++ b/lib/refs.h
@@ -14,7 +14,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Alexey Lyashkov <Alexey_Lyashkov@xyratex.com>
+ * Original author: Alexey Lyashkov
  * Original creation date: 04/08/2010
  */
 
diff --git a/lib/rwlock.h b/lib/rwlock.h
index eb8432e..fe179ad 100644
--- a/lib/rwlock.h
+++ b/lib/rwlock.h
@@ -14,7 +14,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Nikita Danilov <Nikita_Danilov@xyratex.com>
+ * Original author: Nikita Danilov
  * Original creation date: 04/01/2010
  */
 
diff --git a/lib/semaphore.h b/lib/semaphore.h
index b60fcfe..b633553 100644
--- a/lib/semaphore.h
+++ b/lib/semaphore.h
@@ -14,7 +14,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Nikita Danilov <Nikita_Danilov@xyratex.com>
+ * Original author: Nikita Danilov
  * Original creation date: 03/11/2011
  */
 
diff --git a/lib/thread.c b/lib/thread.c
index 4d35fc8..61bdec8 100644
--- a/lib/thread.c
+++ b/lib/thread.c
@@ -14,8 +14,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Nikita Danilov <Nikita_Danilov@xyratex.com>,
- *                  Dave Cohrs <Dave_Cohrs@us.xyratex.com>
+ * Original author: Nikita Danilov, Dave Cohrs
  * Original creation date: 05/01/2010
  */
 
@@ -89,6 +88,7 @@ void c2_thread_fini(struct c2_thread *q)
 	c2_semaphore_fini(&q->t_wait);
 	C2_SET0(q);
 }
+C2_EXPORTED(c2_thread_fini);
 
 /** @} end of thread group */
 
diff --git a/lib/thread.h b/lib/thread.h
index 7f5b6dc..8284e4f 100644
--- a/lib/thread.h
+++ b/lib/thread.h
@@ -14,8 +14,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Nikita Danilov <Nikita_Danilov@xyratex.com>,
- *                  Dave Cohrs <Dave_Cohrs@us.xyratex.com>
+ * Original author: Nikita Danilov, Dave Cohrs
  * Original creation date: 05/01/2010
  */
 
@@ -150,14 +149,6 @@ struct c2_thread {
    the tcb thread must finish before the block where C2_THREAD_INIT() was called
    is left.
 
-   @note Be careful if using LAMBDA in kernel code, as the code could be
-   generated on the stack and would fault in the kernel as it is execution
-   protected in the kernel.  If someone figures out the secret allocation
-   sauce, update this note with the recipe; one observed problem was when a
-   reference was made to an automatic variable from a lambda function, and that
-   problem went away when the variable was made global.  Other lambda functions
-   that simply returned values caused no problems in the kernel.
-
    @see http://en.wikipedia.org/wiki/Lambda_calculus
  */
 #define LAMBDA(T, ...) ({ T __lambda __VA_ARGS__; &__lambda; })
@@ -242,12 +233,12 @@ struct c2_bitmap;
 /**
    Sets thread affinity to a given processor bitmap.
 
-   The user space implementation calls pthread_setaffinity_np and the kernel
-   implementation modifies fields of the task_struct directly.
+   The user space implementation calls pthread_setaffinity_np and the kernel implementation
+   calls set_cpus_allowed_ptr() directly.
 
    @see http://www.kernel.org/doc/man-pages/online/pages/man3/pthread_setaffinity_np.3.html
+   @see http://www.kernel.org/doc/man-pages/online/pages/man2/sched_setaffinity.2.html
    @see lib/processor.h
-   @see kthread
 
    @param q thread whose affinity is to be set (confined)
    @param processors bitmap of processors, true values are those on which the
diff --git a/lib/time.c b/lib/time.c
index db0c561..edd7c45 100644
--- a/lib/time.c
+++ b/lib/time.c
@@ -14,8 +14,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Nathan Rutman <Nathan_Rutman@us.xyratex.com>,
- *                  Huang Hua <Hua_Huang@xyratex.com>
+ * Original author: Nathan Rutman, Huang Hua
  * Original creation date: 12/10/2010
  */
 
@@ -31,6 +30,7 @@
    @{
 */
 
+
 /**
    Create a c2_time_t from seconds and ns
  */
@@ -80,6 +80,7 @@ c2_time_t c2_time_sub(const c2_time_t t1, const c2_time_t t2)
 	C2_POST(c2_time_after_eq(t1, res));
 	return res;
 }
+C2_EXPORTED(c2_time_sub);
 
 /**
    Is time a after time b?
@@ -88,6 +89,7 @@ bool c2_time_after(const c2_time_t a, const c2_time_t b)
 {
 	return a > b;
 }
+C2_EXPORTED(c2_time_after);
 
 /**
    Is time a after or equal to time b?
@@ -96,6 +98,7 @@ bool c2_time_after_eq(const c2_time_t a, const c2_time_t b)
 {
 	return a >= b;
 }
+C2_EXPORTED(c2_time_after_eq);
 
 /**
    Get "second" part from the time
@@ -120,17 +123,8 @@ uint64_t c2_time_nanoseconds(const c2_time_t time)
 }
 C2_EXPORTED(c2_time_nanoseconds);
 
-/**
-   Create a c2_time_t initialized with seconds + nanosecond in the future.
- */
-c2_time_t c2_time_from_now(uint64_t secs, long ns)
-{
-	return c2_time_now() + secs * C2_TIME_ONE_BILLION + ns;
-}
-
 
 const c2_time_t C2_TIME_NEVER = ~0ULL;
-C2_EXPORTED(C2_TIME_NEVER);
 
 /** @} end of time group */
 
diff --git a/lib/time.h b/lib/time.h
index c0cb68d..3c3430c 100644
--- a/lib/time.h
+++ b/lib/time.h
@@ -14,8 +14,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Nathan Rutman <Nathan_Rutman@us.xyratex.com>,
- *                  Huang Hua <Hua_Huang@xyratex.com>
+ * Original author: Nathan Rutman, Huang Hua
  * Original creation date: 12/10/2010
  */
 
@@ -46,19 +45,10 @@ enum {
 /**
    Get the current time.  This may or may not relate to wall time.
 
+   @param time [OUT] current time if pointer is non-NULL
    @retval current time
 */
-c2_time_t c2_time_now(void);
-
-/**
-   Create a c2_time_t initialized with seconds + nanosecond in the future.
-
-   @param secs seconds from now
-   @param ns nanoseconds from now
-
-   @retval the result time.
-*/
-c2_time_t c2_time_from_now(uint64_t secs, long ns);
+c2_time_t c2_time_now(c2_time_t *time);
 
 /**
    Create a c2_time_t from seconds and nanosecond
diff --git a/lib/timer.c b/lib/timer.c
index 814af76..162293c 100644
--- a/lib/timer.c
+++ b/lib/timer.c
@@ -14,574 +14,134 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Huang Hua <Hua_Huang@xyratex.com>
- *                  Maxim Medved <Max_Medved@xyratex.com>
+ * Original author: Huang Hua
  * Original creation date: 03/04/2011
  */
 
-#ifdef HAVE_CONFIG_H
-#  include <config.h>
-#endif
-
-/**
-   @todo hack, but without it timer_create(2) isn't declarated.
-   in Makefile should be -iquote instead of -I
- */
-#include </usr/include/time.h>	  /* timer_create */
-#include <unistd.h>	  /* syscall */
-#include <signal.h>	  /* timer_create */
-#include <sys/syscall.h>  /* syscall */
-
 #include "lib/misc.h"   /* C2_SET0 */
-#include "lib/mutex.h"  /* c2_mutex */
-#include "lib/thread.h" /* c2_thread */
-#include "lib/assert.h" /* C2_ASSERT */
-#include "lib/memory.h" /* C2_ALLOC_PTR */
-#include "lib/errno.h"	/* errno */
-#include "lib/time.h"	/* c2_time_t */
-#include "lib/semaphore.h"  /* c2_semaphore */
+#include "lib/mutex.h"
+#include "lib/cond.h"
+#include "lib/thread.h"
+#include "lib/assert.h"
+
 #include "lib/timer.h"
 
+#include <stdio.h>
 /**
    @addtogroup timer
 
    Implementation of c2_timer.
 
-   In userspace soft timer implementation, there is a timer thread running,
+   In userspace timer implementation, there is a timer thread running,
    which checks the expire time and trigger timer callback if needed.
    There is one timer thread for each timer.
- */
-
-#ifndef C2_TIMER_DEBUG
-#define C2_TIMER_DEBUG 1
-#endif
-
-/**
-   Hard timer implementation uses TIMER_SIGNO signal
-   for user-defined callback delivery.
- */
-#define TIMER_SIGNO	SIGRTMIN
-
-/**
-   Function enum for timer_state_change() checks.
- */
-enum timer_func {
-	TIMER_INIT = 0,
-	TIMER_FINI,
-	TIMER_START,
-	TIMER_STOP,
-	TIMER_ATTACH,
-	TIMER_FUNC_NR
-};
-
-static c2_time_t zero_time;
-
-/**
-   Typed list of c2_timer_tid structures.
- */
-C2_TL_DESCR_DEFINE(tid, "thread IDs", static, struct c2_timer_tid,
-		tt_linkage, tt_magic,
-		0x696c444954726d74,	/** ASCII "tmrTIDli" -
-					  timer thread ID list item */
-		0x686c444954726d74);	/** ASCII "tmrTIDlh" -
-					  timer thread ID list head */
-C2_TL_DEFINE(tid, static, struct c2_timer_tid);
-
-/**
-   gettid(2) implementation.
-   Thread-safe, async-signal-safe.
- */
-static pid_t gettid() {
-
-	return syscall(SYS_gettid);
-}
-
-void c2_timer_locality_init(struct c2_timer_locality *loc)
-{
-	C2_PRE(loc != NULL);
-
-	c2_mutex_init(&loc->tlo_lock);
-	tid_tlist_init(&loc->tlo_tids);
-	loc->tlo_rrtid = NULL;
-}
-
-void c2_timer_locality_fini(struct c2_timer_locality *loc)
-{
-	C2_PRE(loc != NULL);
-
-	c2_mutex_fini(&loc->tlo_lock);
-	tid_tlist_fini(&loc->tlo_tids);
-}
-
-static struct c2_timer_tid *locality_tid_find(struct c2_timer_locality *loc,
-		pid_t tid)
-{
-	struct c2_timer_tid *tt;
-	struct c2_timer_tid *result = NULL;
-
-	C2_PRE(loc != NULL);
-
-	c2_mutex_lock(&loc->tlo_lock);
-	c2_tlist_for(&tid_tl, &loc->tlo_tids, tt) {
-		if (tt->tt_tid == tid) {
-			result = tt;
-			break;
-		}
-	} c2_tlist_endfor;
-	c2_mutex_unlock(&loc->tlo_lock);
-
-	return result;
-}
-
-int c2_timer_thread_attach(struct c2_timer_locality *loc)
-{
-	pid_t tid;
-	struct c2_timer_tid *tt;
-
-	C2_PRE(loc != NULL);
-
-	tid = gettid();
-	C2_ASSERT(locality_tid_find(loc, tid) == NULL);
-
-	C2_ALLOC_PTR(tt);
-	if (tt == NULL)
-		return -ENOMEM;
-
-	tt->tt_tid = tid;
-
-	c2_mutex_lock(&loc->tlo_lock);
-	tid_tlink_init_at_tail(tt, &loc->tlo_tids);
-	c2_mutex_unlock(&loc->tlo_lock);
-
-	return 0;
-}
-
-void c2_timer_thread_detach(struct c2_timer_locality *loc)
-{
-	pid_t tid;
-	struct c2_timer_tid *tt;
-
-	C2_PRE(loc != NULL);
-
-	tid = gettid();
-	tt = locality_tid_find(loc, tid);
-	C2_ASSERT(tt != NULL);
-
-	c2_mutex_lock(&loc->tlo_lock);
-	if (loc->tlo_rrtid == tt)
-		loc->tlo_rrtid = NULL;
-	tid_tlink_del_fini(tt);
-	c2_mutex_unlock(&loc->tlo_lock);
-
-	c2_free(tt);
-}
-
-/**
-   Init POSIX timer, write it to timer->t_ptimer.
-   Timer notification is signal TIMER_SIGNO to
-   thread timer->t_tid.
- */
-static int timer_posix_init(struct c2_timer *timer)
-{
-	struct sigevent se;
-	timer_t ptimer;
-	int rc;
 
-	se.sigev_notify = SIGEV_THREAD_ID;
-	se.sigev_signo = TIMER_SIGNO;
-	se._sigev_un._tid = timer->t_tid;
-	se.sigev_value.sival_ptr = timer;
-	rc = timer_create(CLOCK_REALTIME, &se, &ptimer);
-	/* preserve timer->t_ptimer if timer_create() isn't succeeded */
-	if (rc == 0)
-		timer->t_ptimer = ptimer;
-	return rc;
-}
+   @{
+*/
 
-/**
-   Delete POSIX timer.
- */
-static void timer_posix_fini(timer_t posix_timer)
+void nothing(int unused)
 {
-	int rc;
-
-	rc = timer_delete(posix_timer);
-	/*
-	 * timer_delete() can fail iff timer->t_ptimer isn't valid timer ID.
-	 */
-	C2_ASSERT(rc == 0);
 }
 
-/**
-   Run timer_settime() with given expire time (absolute).
-   Return previous expiration time if old_expire != NULL.
- */
-static void timer_posix_set(struct c2_timer *timer,
-		c2_time_t expire, c2_time_t *old_expire)
-{
-	int		  rc;
-	struct itimerspec ts;
-	struct itimerspec ots;
-
-	C2_PRE(timer != NULL);
-
-	ts.it_interval.tv_sec = 0;
-	ts.it_interval.tv_nsec = 0;
-	ts.it_value.tv_sec = c2_time_seconds(expire);
-	ts.it_value.tv_nsec = c2_time_nanoseconds(expire);
 
-	rc = timer_settime(timer->t_ptimer, TIMER_ABSTIME, &ts, &ots);
-	/*
-	 * timer_settime() can only fail if timer->t_ptimer isn't valid
-	 * timer ID or ts has invalid fields.
-	 */
-	C2_ASSERT(rc == 0);
-	if (old_expire != NULL)
-		c2_time_set(old_expire, ots.it_value.tv_sec,
-				ots.it_value.tv_nsec);
-}
-
-/**
-   Set up signal handler sighandler for given signo.
- */
-static int timer_sigaction(int signo,
-		void (*sighandler)(int, siginfo_t*, void*))
-{
-	struct sigaction sa;
-
-	C2_SET0(&sa);
-	sa.sa_sigaction = sighandler;
-	sigemptyset(&sa.sa_mask);
-	sa.sa_flags = SA_SIGINFO;
-	if (sigaction(signo, &sa, NULL) != 0)
-		return errno;
-	return 0;
-}
-
-/**
-   Signal handler for all POSIX timers.
-   si->si_value.sival_ptr contains pointer to corresponding c2_timer structure.
- */
-static void timer_sighandler(int signo, siginfo_t *si, void *u_ctx)
-{
-	struct c2_timer *timer;
-
-	C2_PRE(si != NULL && si->si_value.sival_ptr != 0);
-	C2_PRE(si->si_code == SI_TIMER);
-	C2_PRE(signo == TIMER_SIGNO);
-
-	timer = si->si_value.sival_ptr;
-#ifdef C2_TIMER_DEBUG
-	C2_ASSERT(timer->t_tid == gettid());
-#endif
-	timer->t_callback(timer->t_data);
-	c2_semaphore_up(&timer->t_stop_sem);
-}
-
-/**
-   Soft timer working thread.
- */
 static void c2_timer_working_thread(struct c2_timer *timer)
 {
-	if (!c2_semaphore_timeddown(&timer->t_sleep_sem, timer->t_expire))
-		timer->t_callback(timer->t_data);
-}
-
-static bool timer_invariant(struct c2_timer *timer)
-{
-	C2_PRE(timer != NULL);
-
-	if (!(timer->t_type == C2_TIMER_HARD ||
-				timer->t_type == C2_TIMER_SOFT))
-		return false;
-	if (!(timer->t_state == TIMER_INITED ||
-				timer->t_state == TIMER_RUNNING ||
-				timer->t_state == TIMER_STOPPED ||
-				timer->t_state == TIMER_UNINIT))
-		return false;
-	return true;
-}
-
-/*
-   This function called on every c2_timer_init/fini/start/stop/attach.
-   It checks the possibility of transition from the current state
-   with a given function and if possible and changes timer state to a new state
-   if it needed.
-   @param dry_run if it is true, then timer state doesn't change.
-   @return true if state can be changed with the given func, false otherwise
- */
-static bool timer_state_change(struct c2_timer *timer, enum timer_func func,
-		bool dry_run)
-{
-	enum c2_timer_state new_state;
-	static enum c2_timer_state
-		transition[TIMER_STATE_NR][TIMER_FUNC_NR] = {
-			[TIMER_UNINIT] = {
-				[TIMER_INIT]   = TIMER_INITED,
-				[TIMER_FINI]   = TIMER_INVALID,
-				[TIMER_START]  = TIMER_INVALID,
-				[TIMER_STOP]   = TIMER_INVALID,
-				[TIMER_ATTACH] = TIMER_INVALID
-			},
-			[TIMER_INITED] = {
-				[TIMER_INIT]   = TIMER_INVALID,
-				[TIMER_FINI]   = TIMER_UNINIT,
-				[TIMER_START]  = TIMER_RUNNING,
-				[TIMER_STOP]   = TIMER_INVALID,
-				[TIMER_ATTACH] = TIMER_INITED
-			},
-			[TIMER_RUNNING] = {
-				[TIMER_INIT]   = TIMER_INVALID,
-				[TIMER_FINI]   = TIMER_INVALID,
-				[TIMER_START]  = TIMER_INVALID,
-				[TIMER_STOP]   = TIMER_STOPPED,
-				[TIMER_ATTACH] = TIMER_INVALID
-			},
-			[TIMER_STOPPED] = {
-				[TIMER_INIT]   = TIMER_INVALID,
-				[TIMER_FINI]   = TIMER_UNINIT,
-				[TIMER_START]  = TIMER_INVALID,
-				[TIMER_STOP]   = TIMER_INVALID,
-				[TIMER_ATTACH] = TIMER_INVALID
-			}
-		};
-
-	C2_PRE(timer_invariant(timer));
-
-	new_state = func == TIMER_INIT ? TIMER_INITED :
-		transition[timer->t_state][func];
-	if (!dry_run && new_state != TIMER_INVALID)
-		timer->t_state = new_state;
-	return func == TIMER_INIT || new_state != TIMER_INVALID;
-}
-
-/**
-   Create POSIX timer for the given c2_timer.
- */
-static int timer_hard_init(struct c2_timer *timer)
-{
-	int rc;
-
-	timer->t_tid = gettid();
-	rc = timer_posix_init(timer);
-	if (rc == 0) {
-		rc = c2_semaphore_init(&timer->t_stop_sem, 0);
-		if (rc != 0)
-			timer_posix_fini(timer->t_ptimer);
-	}
-	return rc;
-}
-
-/**
-   Delete POSIX timer for the given c2_timer.
- */
-static void timer_hard_fini(struct c2_timer *timer)
-{
-	c2_semaphore_fini(&timer->t_stop_sem);
-	timer_posix_fini(timer->t_ptimer);
-}
-
-/**
-   Start one-shot POSIX timer for the given c2_timer.
- */
-static void timer_hard_start(struct c2_timer *timer)
-{
-	timer_posix_set(timer, timer->t_expire, NULL);
-}
-
-/**
-   Stop POSIX timer for the given c2_timer and wait for termination
-   of user-defined timer callback.
- */
-static void timer_hard_stop(struct c2_timer *timer)
-{
-	c2_time_t expire;
-	timer_posix_set(timer, zero_time, &expire);
-	/* if timer was expired then wait until callback is finished */
-	if (expire == zero_time)
-		c2_semaphore_down(&timer->t_stop_sem);
-}
-
-static int timer_soft_init(struct c2_timer *timer)
-{
-	return c2_semaphore_init(&timer->t_sleep_sem, 0);
-}
-
-static void timer_soft_fini(struct c2_timer *timer)
-{
-	c2_semaphore_fini(&timer->t_sleep_sem);
-}
-
-/**
-   Start soft timer thread.
- */
-static int timer_soft_start(struct c2_timer *timer)
-{
-	return C2_THREAD_INIT(&timer->t_thread, struct c2_timer*, NULL,
-			    &c2_timer_working_thread,
-			    timer, "c2_timer_worker");
-}
-
-/**
-   Stop soft timer thread and wait for its termination.
- */
-static int timer_soft_stop(struct c2_timer *timer)
-{
+	c2_time_t next;
+	c2_time_t now;
+	c2_time_t rem;
 	int rc;
 
-	c2_semaphore_up(&timer->t_sleep_sem);
-	rc = c2_thread_join(&timer->t_thread);
-	if (rc == 0)
-		c2_thread_fini(&timer->t_thread);
-	return rc;
-}
-
-int c2_timer_attach(struct c2_timer *timer, struct c2_timer_locality *loc)
-{
-	struct c2_timer_tid *tt;
-	int rc;
-	timer_t ptimer;
-	pid_t old_tid;
+	c2_time_set(&rem, 0, 0);
+	/* capture this signal. It is used to wake this thread */
+	signal(SIGUSR1, nothing);
 
-	C2_PRE(loc != NULL);
-	C2_PRE(timer != NULL);
+	while (timer->t_left > 0) {
+		c2_time_now(&now);
+		if (c2_time_after(now, timer->t_expire))
+			timer->t_expire = c2_time_add(now, timer->t_interval);
 
-	if (timer->t_type == C2_TIMER_SOFT)
-		return 0;
-
-	if (!timer_state_change(timer, TIMER_ATTACH, true))
-		return -EINVAL;
-
-	old_tid = timer->t_tid;
-	c2_mutex_lock(&loc->tlo_lock);
-	if (!tid_tlist_is_empty(&loc->tlo_tids)) {
-		if (loc->tlo_rrtid == NULL)
-			loc->tlo_rrtid = tid_tlist_head(&loc->tlo_tids);
-		tt = loc->tlo_rrtid;
-		timer->t_tid = tt->tt_tid;
-		loc->tlo_rrtid = tid_tlist_next(&loc->tlo_tids, tt);
-	}
-	c2_mutex_unlock(&loc->tlo_lock);
-
-	if (timer->t_tid != old_tid) {
-		/*
-		 * don't delete old posix timer
-		 * until the new one can be created
-		 */
-		ptimer = timer->t_ptimer;
-		rc = timer_posix_init(timer);
-		if (rc == 0)
-			timer_posix_fini(ptimer);
-	} else {
-		rc = 0;
+		next = c2_time_sub(timer->t_expire, now);
+		while (timer->t_left > 0 && (rc = c2_nanosleep(next, &rem)) != 0) {
+			next = rem;
+		}
+		if (timer->t_left == 0)
+			break;
+		timer->t_expire = c2_time_add(timer->t_expire, timer->t_interval);
+		timer->t_callback(timer->t_data);
+		if (timer->t_left == 0 || --timer->t_left == 0)
+			break;
 	}
-
-	timer_state_change(timer, TIMER_ATTACH, rc != 0);
-	return rc;
 }
 
 /**
    Init the timer data structure.
+
+   TODO: Currently hard timer is the same as soft timer. We will implement hard
+   timer later.
  */
 int c2_timer_init(struct c2_timer *timer, enum c2_timer_type type,
-		  c2_time_t expire,
+		  c2_time_t interval, uint64_t repeat,
 		  c2_timer_callback_t callback, unsigned long data)
 {
-	int rc;
-
 	C2_PRE(callback != NULL);
 	C2_PRE(type == C2_TIMER_SOFT || type == C2_TIMER_HARD);
-	C2_PRE(timer != NULL);
 
 	C2_SET0(timer);
 	timer->t_type     = type;
-	timer->t_expire	  = expire;
+	timer->t_interval = interval;
+	timer->t_repeat   = repeat;
+	timer->t_left     = 0;
 	timer->t_callback = callback;
 	timer->t_data     = data;
+	c2_time_set(&timer->t_expire, 0, 0);
 
-	if (timer->t_type == C2_TIMER_HARD)
-		rc = timer_hard_init(timer);
-	else
-		rc = timer_soft_init(timer);
-
-	timer_state_change(timer, TIMER_INIT, rc != 0);
-
-	return rc;
-}
-
-/**
-   Destroy the timer.
- */
-int c2_timer_fini(struct c2_timer *timer)
-{
-	if (!timer_state_change(timer, TIMER_FINI, true))
-		return -EINVAL;
-
-	if (timer->t_type == C2_TIMER_HARD)
-		timer_hard_fini(timer);
-	else
-		timer_soft_fini(timer);
-
-	C2_SET0(timer);
 	return 0;
 }
+C2_EXPORTED(c2_timer_init);
 
 /**
    Start a timer.
  */
 int c2_timer_start(struct c2_timer *timer)
 {
-	int rc = 0;
-
-	if (!timer_state_change(timer, TIMER_START, true))
-		return -EINVAL;
+	c2_time_t now;
+	int rc;
 
-	if (timer->t_type == C2_TIMER_HARD)
-		timer_hard_start(timer);
-	else
-		rc = timer_soft_start(timer);
+	timer->t_expire = c2_time_add(c2_time_now(&now), timer->t_interval);
+	timer->t_left = timer->t_repeat;
 
-	timer_state_change(timer, TIMER_START, rc != 0);
+	rc = C2_THREAD_INIT(&timer->t_thread, struct c2_timer*, NULL,
+			    &c2_timer_working_thread, timer, "c2_timer_worker");
 	return rc;
 }
+C2_EXPORTED(c2_timer_start);
 
 /**
    Stop a timer.
  */
 int c2_timer_stop(struct c2_timer *timer)
 {
-	int rc = 0;
+	timer->t_left = 0;
+	c2_time_set(&timer->t_expire, 0, 0);
 
-	if (!timer_state_change(timer, TIMER_STOP, true))
-		return -EINVAL;
-
-	if (timer->t_type == C2_TIMER_HARD)
-		timer_hard_stop(timer);
-	else
-		rc = timer_soft_stop(timer);
-
-	timer_state_change(timer, TIMER_STOP, rc != 0);
-	return rc;
-}
-
-bool c2_timer_is_started(const struct c2_timer *timer)
-{
-	return timer->t_state == TIMER_RUNNING;
+        if (timer->t_thread.t_func != NULL) {
+		c2_thread_signal(&timer->t_thread, SIGUSR1);
+		c2_thread_join(&timer->t_thread);
+		c2_thread_fini(&timer->t_thread);
+        }
+	return 0;
 }
+C2_EXPORTED(c2_timer_stop);
 
 /**
-   Init data structures for hard timer
+   Destroy the timer.
  */
-int c2_timers_init()
-{
-	timer_sigaction(TIMER_SIGNO, timer_sighandler);
-	c2_time_set(&zero_time, 0, 0);
-	return 0;
-}
-
-void c2_timers_fini()
+void c2_timer_fini(struct c2_timer *timer)
 {
+	C2_SET0(timer);
+	return;
 }
+C2_EXPORTED(c2_timer_fini);
 
 /** @} end of timer group */
 
diff --git a/lib/timer.h b/lib/timer.h
index ade7041..bdcdb3e 100644
--- a/lib/timer.h
+++ b/lib/timer.h
@@ -14,8 +14,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Huang Hua <Hua_Huang@xyratex.com>
- *                  Maxim Medved <Max_Medved@xyratex.com>
+ * Original author: Huang Hua
  * Original creation date: 03/04/2011
  */
 
@@ -23,8 +22,6 @@
 #define __COLIBRI_LIB_TIMER_H__
 
 #include "lib/types.h"
-#include "lib/tlist.h"	   /* c2_tl */
-#include "lib/mutex.h"	   /* c2_mutex */
 
 /**
    @defgroup timer Generic timer manipulation
@@ -42,25 +39,25 @@
    implementation, all timers are hard timer. For userspace implemenation,
    soft timer and hard timer have different mechanism:
 
-   - Hard timer has better resolution and is driven by signal. The
-     user-defined callback should take short time, should never block
-     at any time. Also in user space it should be async-signal-safe
-     (see signal(7)), in kernel space it can only take _irq spin-locks.
-   - Soft timer creates separate thread to execute the user-defined
-     callback for each timer. So the overhead is bigger than hard timer.
-     The user-defined callback execution may take longer time and it will
-     not impact other timers.
+   @li Hard timer has better resolution and is driven by signal. The
+    user-defined callback should take short time and should never block
+    at any time.
+   @li Soft timer creates separate thread to execute the user-defined
+    callback for each timer. So the overhead is bigger than hard timer.
+    The user-defined callback execution may take longer time and it will
+    not impact other timers.
 
-   @note c2_timer_* functions should not be used in the timer callbacks.
+   @todo currently, in userspace implementation, hard timer is the same
+    as soft timer. Hard timer will be implemented later.
    @{
- */
+*/
 
 typedef	unsigned long (*c2_timer_callback_t)(unsigned long data);
 struct c2_timer;
 
 /**
    Timer type.
- */
+*/
 enum c2_timer_type {
 	C2_TIMER_SOFT,
 	C2_TIMER_HARD
@@ -72,58 +69,26 @@ enum c2_timer_type {
 #include "lib/linux_kernel/timer.h"
 #endif
 
-/**
-   Item of threads ID list in locality.
-   Used in the implementation of userspace hard timer.
- */
-struct c2_timer_tid {
-	pid_t		tt_tid;
-	struct c2_tlink tt_linkage;
-	uint64_t	tt_magic;
-};
-
-/**
-   Timer locality.
-   Used in userspace hard timers.
- */
-struct c2_timer_locality {
-	/**
-	   Lock for tlo_tids
-	 */
-	struct c2_mutex tlo_lock;
-	/**
-	   List of thread ID's, associated with this locality
-	 */
-	struct c2_tl tlo_tids;
-	/**
-	   ThreadID of next thread for round-robin timer thread selection
-	   in c2_timer_attach(). It is pointer to timer_tid structure.
-	 */
-	struct c2_timer_tid *tlo_rrtid;
-};
 
 /**
    Init the timer data structure.
 
-   @param timer c2_timer structure
-   @param type timer type (C2_TIMER_SOFT or C2_TIMER_HARD)
-   @param expire absolute expiration time for timer. If this time is already
-	  passed, then the timer callback will be executed immediatelly
-	  after c2_timer_start().
+   @param interval interval time from now.
+   @param repeat repeat count for this timer.
    @param callback this callback will be triggered whem timer alarms.
    @param data data for the callback.
-   @pre callback != NULL
-   @post timer is not running
+
+   @return 0 means success, other values mean error.
  */
 int c2_timer_init(struct c2_timer *timer, enum c2_timer_type type,
-		  c2_time_t expire,
+		  c2_time_t interval, uint64_t repeat,
 		  c2_timer_callback_t callback, unsigned long data);
 
 /**
    Start a timer.
 
    @pre c2_timer_init() successfully called.
-   @pre timer is not running
+   @return 0 means success, other values mean error.
  */
 int c2_timer_start(struct c2_timer *timer);
 
@@ -131,71 +96,16 @@ int c2_timer_start(struct c2_timer *timer);
    Stop a timer.
 
    @pre c2_timer_init() successfully called.
-   @pre timer is running
-   @post timer is not running
-   @post callback isn't running
+   @return 0 means success, other values mean error.
  */
 int c2_timer_stop(struct c2_timer *timer);
 
 /**
-   Returns true iff the timer is running.
- */
-bool c2_timer_is_started(const struct c2_timer *timer);
-
-/**
    Destroy the timer.
 
-   @pre c2_timer_init() for this timer was succesfully called.
-   @pre timer is not running.
- */
-int c2_timer_fini(struct c2_timer *timer);
-
-/**
-   Init timer locality.
- */
-void c2_timer_locality_init(struct c2_timer_locality *loc);
-
-/**
-   Fini timer locality.
-
-   @pre c2_timer_locality_init() succesfully called.
-   @pre locality is empty
- */
-void c2_timer_locality_fini(struct c2_timer_locality *loc);
-
-/**
-   Add current thread to the list of threads in locality.
-
-   @pre c2_timer_locality_init() successfully called.
-   @pre current thread is not attached to locality.
-   @post current thread is attached to locality.
- */
-int c2_timer_thread_attach(struct c2_timer_locality *loc);
-
-/**
-   Remove current thread from the list of threads in locality.
-   Current thread must be in this list.
-
-   @pre c2_timer_locality_init() successfully called.
-   @pre current thread is attached to locality.
-   @post current thread is not attached to locality.
- */
-void c2_timer_thread_detach(struct c2_timer_locality *loc);
-
-/**
-   Attach hard timer to the given locality.
-   This function will set timer signal number to signal number, associated
-   with given locality, and thread ID for timer callback - it will be chosen
-   from locality threads list in round-robin fashion.
-   Therefore internal POSIX timer will be recreated.
-
    @pre c2_timer_init() successfully called.
-   @pre c2_timer_locality_init() successfully called.
-   @pre locality has some threads attached.
-   @pre timer type is C2_TIMER_HARD
-   @pre timer is not running.
  */
-int c2_timer_attach(struct c2_timer *timer, struct c2_timer_locality *loc);
+void c2_timer_fini(struct c2_timer *timer);
 
 /** @} end of timer group */
 /* __COLIBRI_LIB_TIMER_H__ */
diff --git a/lib/tlist.c b/lib/tlist.c
deleted file mode 100644
index d02c98c..0000000
--- a/lib/tlist.c
+++ /dev/null
@@ -1,264 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Nikita Danilov <Nikita_Danilov@xyratex.com>
- * Original creation date: 08/26/2011
- */
-
-#include "lib/tlist.h"
-
-/**
-   @addtogroup tlist
-   @{
- */
-
-/**
-   Returns the address of a link embedded in an ambient object.
- */
-static struct c2_list_link *link(const struct c2_tl_descr *d, const void *obj);
-
-/**
-   Returns the value of the magic field in an ambient object
- */
-static uint64_t magic(const struct c2_tl_descr *d, const void *obj);
-
-/**
-   Casts a link to its ambient object.
- */
-static void *amb(const struct c2_tl_descr *d, struct c2_list_link *link);
-
-void c2_tlist_init(const struct c2_tl_descr *d, struct c2_tl *list)
-{
-	list->t_magic = d->td_head_magic;
-	c2_list_init(&list->t_head);
-	C2_POST(c2_tlist_invariant(d, list));
-}
-
-void c2_tlist_fini(const struct c2_tl_descr *d, struct c2_tl *list)
-{
-	C2_PRE(c2_tlist_invariant(d, list));
-	c2_list_fini(&list->t_head);
-}
-
-void c2_tlink_init(const struct c2_tl_descr *d, void *obj)
-{
-	c2_list_link_init(link(d, obj));
-	if (d->td_link_magic != 0)
-		*(uint64_t *)(obj + d->td_link_magic_offset) = d->td_link_magic;
-	C2_POST(c2_tlink_invariant(d, obj));
-}
-
-void c2_tlink_init_at(const struct c2_tl_descr *d, void *obj,
-		      struct c2_tl *list)
-{
-	c2_tlink_init(d, obj);
-	c2_tlist_add(d, list, obj);
-}
-
-void c2_tlink_init_at_tail(const struct c2_tl_descr *d, void *obj,
-			   struct c2_tl *list)
-{
-	c2_tlink_init(d, obj);
-	c2_tlist_add_tail(d, list, obj);
-}
-
-void c2_tlink_fini(const struct c2_tl_descr *d, void *obj)
-{
-	c2_list_link_fini(link(d, obj));
-}
-
-void c2_tlink_del_fini(const struct c2_tl_descr *d, void *obj)
-{
-	c2_tlist_del(d, obj);
-	c2_tlink_fini(d, obj);
-}
-
-bool c2_tlist_is_empty(const struct c2_tl_descr *d, const struct c2_tl *list)
-{
-	C2_PRE(c2_tlist_invariant(d, list));
-	return c2_list_is_empty(&list->t_head);
-}
-
-bool c2_tlink_is_in(const struct c2_tl_descr *d, const void *obj)
-{
-	C2_PRE(c2_tlink_invariant(d, obj));
-	return c2_list_link_is_in(link(d, obj));
-}
-
-bool c2_tlist_contains(const struct c2_tl_descr *d, const struct c2_tl *list,
-		       const void *obj)
-{
-	C2_PRE(c2_tlist_invariant(d, list));
-	C2_PRE(c2_tlink_invariant(d, obj));
-	return c2_list_contains(&list->t_head, link(d, obj));
-}
-
-size_t c2_tlist_length(const struct c2_tl_descr *d, const struct c2_tl *list)
-{
-	C2_PRE(c2_tlist_invariant(d, list));
-	return c2_list_length(&list->t_head);
-}
-
-void c2_tlist_add(const struct c2_tl_descr *d, struct c2_tl *list, void *obj)
-{
-	C2_PRE(c2_tlist_invariant(d, list));
-	C2_PRE(!c2_tlink_is_in(d, obj));
-	c2_list_add(&list->t_head, link(d, obj));
-}
-
-void c2_tlist_add_tail(const struct c2_tl_descr *d,
-		       struct c2_tl *list, void *obj)
-{
-	C2_PRE(c2_tlist_invariant(d, list));
-	C2_PRE(!c2_tlink_is_in(d, obj));
-	c2_list_add_tail(&list->t_head, link(d, obj));
-}
-
-void c2_tlist_add_after(const struct c2_tl_descr *d, void *obj, void *new)
-{
-	C2_PRE(c2_tlink_is_in(d, obj));
-	C2_PRE(!c2_tlink_is_in(d, new));
-	c2_list_add_after(link(d, obj), link(d, new));
-}
-
-void c2_tlist_add_before(const struct c2_tl_descr *d, void *obj, void *new)
-{
-	C2_PRE(c2_tlink_is_in(d, obj));
-	C2_PRE(!c2_tlink_is_in(d, new));
-	c2_list_add_before(link(d, obj), link(d, new));
-}
-
-void c2_tlist_del(const struct c2_tl_descr *d, void *obj)
-{
-	C2_PRE(c2_tlink_invariant(d, obj));
-	C2_PRE(c2_tlink_is_in(d, obj));
-	c2_list_del(link(d, obj));
-	C2_PRE(!c2_tlink_is_in(d, obj));
-}
-
-void c2_tlist_move(const struct c2_tl_descr *d, struct c2_tl *list, void *obj)
-{
-	C2_PRE(c2_tlist_invariant(d, list));
-	C2_PRE(c2_tlink_is_in(d, obj));
-
-	c2_list_move(&list->t_head, link(d, obj));
-}
-
-void c2_tlist_move_tail(const struct c2_tl_descr *d,
-			struct c2_tl *list, void *obj)
-{
-	C2_PRE(c2_tlist_invariant(d, list));
-	C2_PRE(c2_tlink_is_in(d, obj));
-
-	c2_list_move_tail(&list->t_head, link(d, obj));
-}
-
-void *c2_tlist_head(const struct c2_tl_descr *d, const struct c2_tl *list)
-{
-	const struct c2_list *head;
-
-	C2_PRE(c2_tlist_invariant(d, list));
-
-	head = &list->t_head;
-	return head->l_head != (void *)head ? amb(d, head->l_head) : NULL;
-}
-
-void *c2_tlist_tail(const struct c2_tl_descr *d, const struct c2_tl *list)
-{
-	const struct c2_list *head;
-
-	C2_PRE(c2_tlist_invariant(d, list));
-
-	head = &list->t_head;
-	return head->l_tail != (void *)head ? amb(d, head->l_tail) : NULL;
-}
-
-void *c2_tlist_next(const struct c2_tl_descr *d,
-		    const struct c2_tl *list, void *obj)
-{
-	struct c2_list_link *next;
-
-	C2_PRE(c2_tlist_contains(d, list, obj));
-
-	next = link(d, obj)->ll_next;
-	return (void *)next != &list->t_head ? amb(d, next) : NULL;
-}
-
-void *c2_tlist_prev(const struct c2_tl_descr *d,
-		    const struct c2_tl *list, void *obj)
-{
-	struct c2_list_link *prev;
-
-	C2_PRE(c2_tlist_contains(d, list, obj));
-
-	prev = link(d, obj)->ll_prev;
-	return (void *)prev != &list->t_head ? amb(d, prev) : NULL;
-}
-
-bool c2_tlist_invariant(const struct c2_tl_descr *d, const struct c2_tl *list)
-{
-	struct c2_list_link *head;
-	struct c2_list_link *scan;
-
-	head = (void *)&list->t_head;
-
-	if (list->t_magic != d->td_head_magic)
-		return false;
-	if ((head->ll_next == head) != (head->ll_prev == head))
-		return false;
-
-	for (scan = head->ll_next; scan != head; scan = scan->ll_next) {
-		if (scan->ll_next->ll_prev != scan ||
-		    scan->ll_prev->ll_next != scan)
-			return false;
-		if (!c2_tlink_invariant(d, amb(d, scan)))
-			return false;
-	}
-	return true;
-}
-
-bool c2_tlink_invariant(const struct c2_tl_descr *d, const void *obj)
-{
-	return d->td_link_magic == 0 || magic(d, obj) == d->td_link_magic;
-}
-
-static struct c2_list_link *link(const struct c2_tl_descr *d, const void *obj)
-{
-	return &((struct c2_tlink *)(obj + d->td_link_offset))->t_link;
-}
-
-static uint64_t magic(const struct c2_tl_descr *d, const void *obj)
-{
-	return *(uint64_t *)(obj + d->td_link_magic_offset);
-}
-
-static void *amb(const struct c2_tl_descr *d, struct c2_list_link *link)
-{
-	return (void *)container_of(link, struct c2_tlink,
-				    t_link) - d->td_link_offset;
-}
-
-/** @} end of tlist group */
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
diff --git a/lib/tlist.h b/lib/tlist.h
deleted file mode 100644
index 13ba9ae..0000000
--- a/lib/tlist.h
+++ /dev/null
@@ -1,613 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Nikita Danilov <Nikita_Danilov@xyratex.com>
- * Original creation date: 08/26/2011
- */
-
-#ifndef __COLIBRI_LIB_TLIST_H__
-#define __COLIBRI_LIB_TLIST_H__
-
-#include "lib/list.h"
-#include "lib/types.h"                    /* uint64_t */
-
-/**
-   @defgroup tlist Typed lists.
-
-   Typed list module provides a double-linked list implementation that
-   eliminates some chores and sources of errors typical for the "raw" c2_list
-   interface.
-
-   Typed list is implemented on top of c2_list and adds the following features:
-
-       - a "list descriptor" (c2_tl_descr) object holding information about this
-         list type, including its human readable name;
-
-       - "magic" numbers embedded in list header and list links and checked by
-         the code to catch corruptions;
-
-       - automatic conversion to and from list links and ambient objects they
-         are embedded to, obviating the need in container_of() and
-         c2_list_entry() calls. In fact, links (c2_tlink) are not mentioned in
-         tlist interface at all;
-
-       - gdb (7.0) pretty-printer for lists (not yet implemented).
-
-   tlist is a safe and more convenient alternative to c2_list. As a general
-   rule, c2_list should be used only when performance is critical or some
-   flexibility beyond what tlist provides (e.g., a cyclic list without a head
-   object) is necessary.
-
-   Similarly to c2_list, tlist is a purely algorithmic module: it deals with
-   neither concurrency nor liveness nor with any similar issues that its callers
-   are supposed to handle.
-
-   To describe a typical tlist usage pattern, suppose that one wants a list of
-   objects of type foo hanging off every object of type bar.
-
-   First, two things have to be done:
-
-   - "list link" has to be embedded in foo:
-
-     @code
-     struct foo {
-             ...
-	     // linkage into a list of foo-s hanging off bar::b_list
-	     struct c2_tlink f_linkage;
-	     ...
-     };
-     @endcode
-
-   - then, a "list head" has to be embedded in bar:
-
-     @code
-     struct bar {
-             ...
-	     // list of foo-s, linked through foo::f_linkage
-	     struct c2_tl b_list;
-	     ...
-     };
-     @endcode
-
-   - now, define a tlist type:
-
-     @code
-     static const struct c2_tl_descr foobar_list = {
-             .td_name        = "foo-s of bar",
-	     .td_link_offset = offsetof(struct foo, f_linkage),
-	     .td_head_magic  = 0x666f6f6261726865 // "foobarhe"
-     };
-     @endcode
-
-   This defines the simplest form of tlist without magic checking in list links
-   (the magic embedded in a list head is checked anyway). To add magic checking,
-   place a magic field in foo:
-
-   @code
-   struct foo {
-           ...
-	   uint64_t f_magic;
-	   ...
-   };
-
-   static const struct c2_tl_descr foobar_list = {
-           ...
-	   .td_link_magic_offset = offsetof(struct foo, f_magic),
-	   .td_link_magic        = 0x666f6f6261726c69 // "foobarli"
-   };
-   @endcode
-
-   Magic field can be shared by multiple tlist links embedded in the same object
-   and can be used for other sanity checking. An "outermost" finaliser function
-   must clear the magic as its last step to catch use-after-fini errors.
-
-   Now, one can populate and manipulate foo-bar lists:
-
-   @code
-   struct bar  B;
-   struct foo  F;
-   struct foo *scan;
-
-   c2_tlist_init(&B.b_list);
-   c2_tlink_init(&F.f_linkage);
-
-   c2_tlist_add(&foobar_list, &B.b_list, &F);
-   C2_ASSERT(c2_tl_contains(&foobar_list, &B.b_list, &F));
-
-   c2_tlist_for(&foobar_list, &B.b_list, scan)
-           C2_ASSERT(scan == &F);
-   c2_tlist_endfor;
-   @endcode
-
-   @note Differently from c2_list, tlist heads and links must be initialised
-   before use, even when first usage overwrites the entity completely. This
-   allows stronger checking in tlist manipulation functions.
-
-   <b>Type-safe macros.</b>
-
-   C2_TL_DESCR_DECLARE(), C2_TL_DECLARE(), C2_TL_DESCR_DEFINE() and
-   C2_TL_DEFINE() macros generate versions of tlist interface tailored for a
-   particular use case.
-
-   4 separate macros are necessary for flexibility. They should be used in
-   exactly one of the following ways for any given typed list:
-
-       - static tlist, used in a single module only: C2_TL_DEFINE() and
-         C2_TL_DESCR_DEFINE() with scope "static" in the module .c file;
-
-       - tlist exported from a module: C2_TL_DEFINE() and C2_TL_DESCR_DEFINE()
-         with scope "" in .c file and C2_TL_DESCR_DECLARE(), C2_TL_DECLARE()
-         with scope "extern" in .h file;
-
-       - tlist exported from a module as a collection of inline functions:
-         C2_TL_DESCR_DEFINE() in .c file and C2_TL_DESCR_DECLARE() with scope
-         "extern" followed by C2_TL_DEFINE() with scope "static inline" in .h
-         file.
-   @{
- */
-
-struct c2_tl_descr;
-struct c2_tl;
-struct c2_tlink;
-
-/**
-   An instance of this type must be defined for each "tlist type", specifically
-   for each link embedded in an ambient type.
-
-   @verbatim
-			      ambient object
-                          +  +-----------+  +
-     td_link_magic_offset |  |           |  |
-                          v  |           |  |
-                             |-----------|  |
-                             |link magic |  | td_link_offset
-                             |-----------|  |
-                             |           |  |
-        head                 |           |  |
-    +->+----------+          |           |  |
-    |  |head magic|          |           |  v
-    |  |----------|          |-----------|
-    |  |        +----------->|link     +------------> . . . ---+
-    |  +----------+          |-----------|                     |
-    |                        |           |                     |
-    |                        |           |                     |
-    |                        |           |                     |
-    |                        |           |                     |
-    |                        +-----------+                     |
-    |                                                          |
-    +----------------------------------------------------------+
-
-   @endverbatim
- */
-struct c2_tl_descr {
-	/** Human-readable list name, used for error messages. */
-	const char *td_name;
-	/** Offset of list link (c2_tlink) in the ambient object. */
-	int         td_link_offset;
-	/**
-	    Offset of magic field in the ambient object.
-	    This is used only when link magic checking is on.
-
-	    @see c2_tl_descr::td_link_magic
-	 */
-	int         td_link_magic_offset;
-	/**
-	    Magic stored in an ambient object.
-
-	    If this field is 0, link magic checking is disabled.
-	 */
-	uint64_t    td_link_magic;
-	/**
-	    Magic stored in c2_tl::t_magic and checked on all tlist
-	    operations.
-	 */
-	uint64_t    td_head_magic;
-};
-
-#define C2_TL_DESCR(name, ambient_type, link_field, link_magic_field,	\
-                    link_magic, head_magic)				\
-{									\
-	.td_name              = name,					\
-	.td_link_offset       = offsetof(ambient_type, link_field),	\
-	.td_link_magic_offset = offsetof(ambient_type, link_magic_field), \
-	.td_link_magic        = link_magic,				\
-	.td_head_magic        = head_magic				\
-};									\
-									\
-C2_BASSERT(C2_HAS_TYPE(C2_FIELD_VALUE(ambient_type, link_field),	\
-		       struct c2_tlink));				\
-C2_BASSERT(C2_HAS_TYPE(C2_FIELD_VALUE(ambient_type, link_magic_field),	\
-		       uint64_t))
-
-
-/**
-   tlist head.
- */
-struct c2_tl {
-	/**
-	   Head magic. This is set to c2_tl::td_head_magic and verified by the
-	   list invariant.
-	 */
-	uint64_t       t_magic;
-	/** Underlying c2_list. */
-	struct c2_list t_head;
-};
-
-/**
-   tlist link.
- */
-struct c2_tlink {
-	/** Underlying c2_list link. */
-	struct c2_list_link t_link;
-};
-
-void c2_tlist_init(const struct c2_tl_descr *d, struct c2_tl *list);
-void c2_tlist_fini(const struct c2_tl_descr *d, struct c2_tl *list);
-
-void c2_tlink_init(const struct c2_tl_descr *d, void *obj);
-void c2_tlink_fini(const struct c2_tl_descr *d, void *obj);
-void c2_tlink_init_at(const struct c2_tl_descr *d,
-		      void *obj, struct c2_tl *list);
-void c2_tlink_init_at_tail(const struct c2_tl_descr *d,
-			   void *obj, struct c2_tl *list);
-void c2_tlink_del_fini(const struct c2_tl_descr *d, void *obj);
-
-bool c2_tlist_invariant(const struct c2_tl_descr *d, const struct c2_tl *list);
-bool c2_tlink_invariant(const struct c2_tl_descr *d, const void *obj);
-
-bool   c2_tlist_is_empty(const struct c2_tl_descr *d, const struct c2_tl *list);
-bool   c2_tlink_is_in   (const struct c2_tl_descr *d, const void *obj);
-
-bool   c2_tlist_contains(const struct c2_tl_descr *d, const struct c2_tl *list,
-			 const void *obj);
-size_t c2_tlist_length(const struct c2_tl_descr *d, const struct c2_tl *list);
-
-/**
-   Adds an element to the beginning of a list.
-
-   @pre !c2_tlink_is_in(d, obj)
-   @post c2_tlink_is_in(d, obj)
- */
-void   c2_tlist_add(const struct c2_tl_descr *d, struct c2_tl *list, void *obj);
-
-/**
-   Adds an element to the end of a list.
-
-   @pre !c2_tlink_is_in(d, obj)
-   @post c2_tlink_is_in(d, obj)
- */
-void   c2_tlist_add_tail(const struct c2_tl_descr *d,
-			 struct c2_tl *list, void *obj);
-
-/**
-   Adds an element after another element of the list.
-
-   @pre !c2_tlink_is_in(d, new)
-   @post c2_tlink_is_in(d, new)
- */
-void   c2_tlist_add_after(const struct c2_tl_descr *d, void *obj, void *new);
-
-/**
-   Adds an element before another element of the list.
-
-   @pre !c2_tlink_is_in(d, new)
-   @post c2_tlink_is_in(d, new)
- */
-void   c2_tlist_add_before(const struct c2_tl_descr *d, void *obj, void *new);
-
-/**
-   Deletes an element from the list.
-
-   @pre   c2_tlink_is_in(d, obj)
-   @post !c2_tlink_is_in(d, obj)
- */
-void   c2_tlist_del(const struct c2_tl_descr *d, void *obj);
-
-/**
-   Moves an element from a list to the head of (possibly the same) list.
-
-   @pre  c2_tlink_is_in(d, obj)
-   @post c2_tlink_is_in(d, obj)
- */
-void   c2_tlist_move(const struct c2_tl_descr *d, struct c2_tl *list, void *obj);
-
-/**
-   Moves an element from a list to the tail of (possibly the same) list.
-
-   @pre  c2_tlink_is_in(d, obj)
-   @post c2_tlink_is_in(d, obj)
- */
-void   c2_tlist_move_tail(const struct c2_tl_descr *d,
-			  struct c2_tl *list, void *obj);
-/**
-   Returns the first element of a list or NULL if the list is empty.
- */
-void  *c2_tlist_head(const struct c2_tl_descr *d, const struct c2_tl *list);
-
-/**
-   Returns the last element of a list or NULL if the list is empty.
- */
-void  *c2_tlist_tail(const struct c2_tl_descr *d, const struct c2_tl *list);
-
-/**
-   Returns the next element of a list or NULL if @obj is the last element.
-
-   @pre c2_tlist_contains(d, list, obj)
- */
-void  *c2_tlist_next(const struct c2_tl_descr *d,
-		     const struct c2_tl *list, void *obj);
-
-/**
-   Returns the previous element of a list or NULL if @obj is the first element.
-
-   @pre c2_tlist_contains(d, list, obj)
- */
-void  *c2_tlist_prev(const struct c2_tl_descr *d,
-		     const struct c2_tl *list, void *obj);
-
-/**
-   Iterates over elements of list @head of type @descr, assigning them in order
-   (from head to tail) to @obj.
-
-   It is safe to delete the "current" object in the body of the loop or modify
-   the portion of the list preceding the current element. It is *not* safe to
-   modify the list after the current point.
-
-   @code
-   c2_tlist_for(&foobar_list, &B.b_list, foo)
-           sum += foo->f_value;
-   c2_tlist_endfor;
-
-   c2_tlist_for(&foobar_list, &B.b_list, foo) {
-           if (foo->f_value % sum == 0)
-	           c2_tlist_del(&foobar_list, foo);
-   } c2_tlist_endfor;
-   @endcode
-
-   c2_tlist_for() macro has a few points of technical interest:
-
-       - it introduces a scope to declare a temporary variable to hold the
-         pointer to a "next" list element. The undesirable result of this is
-         that the loop has to be terminated by the matching c2_tlist_endfor
-         macro, closing the hidden scope. An alternative would be to use C99
-         syntax for iterative statement, which allows a declaration in the
-         for-loop header. Unfortunately, even though C99 mode can be enforced
-         for compilation of linux kernel modules (by means of CFLAGS_MODULE),
-         the kernel doesn't compile correctly in this mode;
-
-       - "inventive" use of comma expression in the loop condition allows to
-         calculate next element only once and only when the current element is
-         not NULL.
-
-   @see c2_tlist_endfor
- */
-#define c2_tlist_for(descr, head, obj)					\
-do {									\
-	void *__tl;							\
-									\
-	for (obj = c2_tlist_head(descr, head);				\
-	     obj != NULL &&						\
-             ((void)(__tl = c2_tlist_next(descr, head, obj)), true);	\
-	     obj = __tl)
-
-/**
-   Terminates c2_tlist_for() loop.
- */
-#define c2_tlist_endfor ; (void)__tl; } while (0)
-
-#define C2_TL_DESCR_DECLARE(name, scope)	\
-scope const struct c2_tl_descr name ## _tl
-
-/**
-   Declares a version of tlist interface with definitions adjusted to take
-   parameters of a specified ambient type (rather than void) and to hide
-   c2_tl_descr from signatures.
-
-   @code
-   C2_TL_DECLARE(foo, static, struct foo);
-   @endcode
-
-   declares
-
-   @code
-   static void foo_tlist_init(struct c2_tl *head);
-   static void foo_tlink_init(struct foo *amb);
-   static void foo_tlist_move(struct c2_tl *list, struct foo *amb);
-   static struct foo *foo_tlist_head(const struct c2_tl *list);
-   @endcode
-
-   &c.
-
-   @see C2_TL_DEFINE()
-   @see C2_TL_DESCR_DEFINE()
- */
-#define C2_TL_DECLARE(name, scope, amb_type)				\
-									\
-scope void name ## _tlist_init(struct c2_tl *head);			\
-scope void name ## _tlist_fini(struct c2_tl *head);			\
-scope void name ## _tlink_init(amb_type *amb);				\
- scope void name ## _tlink_init_at(amb_type *amb, struct c2_tl *head);	\
- scope void name ## _tlink_init_at_tail(amb_type *amb, struct c2_tl *head);\
-scope void name ## _tlink_fini(amb_type *amb);				\
-scope void name ## _tlink_del_fini(amb_type *amb);			\
-scope bool   name ## _tlist_is_empty(const struct c2_tl *list);		\
-scope bool   name ## _tlink_is_in   (const amb_type *amb);		\
-scope bool   name ## _tlist_contains(const struct c2_tl *list,		\
-				     const amb_type *amb);		\
-scope size_t name ## _tlist_length(const struct c2_tl *list);		\
-scope void   name ## _tlist_add(struct c2_tl *list, amb_type *amb);	\
-scope void   name ## _tlist_add_tail(struct c2_tl *list, amb_type *amb); \
-scope void   name ## _tlist_add_after(amb_type *amb, amb_type *new);	\
-scope void   name ## _tlist_add_before(amb_type *amb, amb_type *new);	\
-scope void   name ## _tlist_del(amb_type *amb);				\
-scope void   name ## _tlist_move(struct c2_tl *list, amb_type *amb);	\
-scope void   name ## _tlist_move_tail(struct c2_tl *list, amb_type *amb); \
-scope amb_type *name ## _tlist_head(const struct c2_tl *list);		\
-scope amb_type *name ## _tlist_tail(const struct c2_tl *list);		\
-scope amb_type *name ## _tlist_next(const struct c2_tl *list, amb_type *amb);	\
-scope amb_type *name ## _tlist_prev(const struct c2_tl *list, amb_type *amb)
-
-#define __AUN __attribute__((unused))
-
-/**
-   Defines a tlist descriptor (c2_tl_descr) for a particular ambient type.
- */
-#define C2_TL_DESCR_DEFINE(name, hname, scope, amb_type, amb_link_field, \
-		     amb_magic_field, amb_magic, head_magic)		\
-scope const struct c2_tl_descr name ## _tl = C2_TL_DESCR(hname,		\
-							 amb_type,	\
-							 amb_link_field, \
-							 amb_magic_field, \
-							 amb_magic,	\
-							 head_magic)
-
-/**
-   Defines functions declared by C2_TL_DECLARE().
-
-   The definitions generated assume that tlist descriptor, defined by
-   C2_TL_DESC_DEFINED() is in scope.
- */
-#define C2_TL_DEFINE(name, scope, amb_type)				\
-									\
-scope __AUN void name ## _tlist_init(struct c2_tl *head)		\
-{									\
-	c2_tlist_init(&name ## _tl, head);				\
-}									\
-									\
-scope __AUN void name ## _tlist_fini(struct c2_tl *head)		\
-{									\
-	c2_tlist_fini(&name ## _tl, head);				\
-}									\
-									\
-scope __AUN void name ## _tlink_init(amb_type *amb)			\
-{									\
-	c2_tlink_init(&name ## _tl, amb);				\
-}									\
-									\
-scope __AUN void name ## _tlink_init_at(amb_type *amb, struct c2_tl *head) \
-{									\
-	c2_tlink_init_at(&name ## _tl, amb, head);			\
-}									\
-									\
-scope __AUN void name ## _tlink_init_at_tail(amb_type *amb, struct c2_tl *head) \
-{									\
-	c2_tlink_init_at_tail(&name ## _tl, amb, head);			\
-}									\
-									\
-scope __AUN void name ## _tlink_fini(amb_type *amb)			\
-{									\
-	c2_tlink_fini(&name ## _tl, amb);				\
-}									\
-									\
-scope __AUN void name ## _tlink_del_fini(amb_type *amb)			\
-{									\
-	c2_tlink_del_fini(&name ## _tl, amb);				\
-}									\
-									\
-scope __AUN bool   name ## _tlist_is_empty(const struct c2_tl *list)	\
-{									\
-	return c2_tlist_is_empty(&name ## _tl, list);			\
-}									\
-									\
-scope __AUN bool   name ## _tlink_is_in   (const amb_type *amb)		\
-{									\
-	return c2_tlink_is_in(&name ## _tl, amb);			\
-}									\
-									\
-scope __AUN bool   name ## _tlist_contains(const struct c2_tl *list,	\
-				     const amb_type *amb)		\
-{									\
-	return c2_tlist_contains(&name ## _tl, list, amb);		\
-}									\
-									\
-scope __AUN size_t name ## _tlist_length(const struct c2_tl *list)	\
-{									\
-	return c2_tlist_length(&name ## _tl, list);			\
-}									\
-									\
-scope __AUN void   name ## _tlist_add(struct c2_tl *list, amb_type *amb) \
-{									\
-	c2_tlist_add(&name ## _tl, list, amb);				\
-}									\
-									\
-scope __AUN void   name ## _tlist_add_tail(struct c2_tl *list, amb_type *amb) \
-{									\
-	c2_tlist_add_tail(&name ## _tl, list, amb);			\
-}									\
-									\
-scope __AUN void   name ## _tlist_add_after(amb_type *amb, amb_type *new) \
-{									\
-	c2_tlist_add_after(&name ## _tl, amb, new);			\
-}									\
-									\
-scope __AUN void   name ## _tlist_add_before(amb_type *amb, amb_type *new) \
-{									\
-	c2_tlist_add_before(&name ## _tl, amb, new);			\
-}									\
-									\
-scope __AUN void   name ## _tlist_del(amb_type *amb)			\
-{									\
-	c2_tlist_del(&name ## _tl, amb);				\
-}									\
-									\
-scope __AUN void   name ## _tlist_move(struct c2_tl *list, amb_type *amb) \
-{									\
-	c2_tlist_move(&name ## _tl, list, amb);				\
-}									\
-									\
-scope __AUN void   name ## _tlist_move_tail(struct c2_tl *list, amb_type *amb) \
-{									\
-	c2_tlist_move_tail(&name ## _tl, list, amb);			\
-}									\
-									\
-scope __AUN amb_type *name ## _tlist_head(const struct c2_tl *list)	\
-{									\
-	return c2_tlist_head(&name ## _tl, list);			\
-}									\
-									\
-scope __AUN amb_type *name ## _tlist_tail(const struct c2_tl *list)	\
-{									\
-	return c2_tlist_tail(&name ## _tl, list);			\
-}									\
-									\
-scope __AUN amb_type *name ## _tlist_next(const struct c2_tl *list,     \
-				     amb_type *amb)			\
-{									\
-	return c2_tlist_next(&name ## _tl, list, amb);			\
-}									\
-									\
-scope __AUN amb_type *name ## _tlist_prev(const struct c2_tl *list,     \
-				     amb_type *amb)                     \
-{									\
-	return c2_tlist_prev(&name ## _tl, list, amb);			\
-}									\
-									\
-struct __ ## name ## _terminate_me_with_a_semicolon { ; }
-
-/** @} end of tlist group */
-
-/* __COLIBRI_LIB_TLIST_H__ */
-#endif
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
diff --git a/lib/trace.c b/lib/trace.c
deleted file mode 100644
index 8ff92a9..0000000
--- a/lib/trace.c
+++ /dev/null
@@ -1,227 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Nikita Danilov <Nikita_Danilov@xyratex.com>
- * Original creation date: 08/12/2010
- */
-
-#include "lib/errno.h"
-#include "lib/atomic.h"
-#include "lib/arith.h" /* c2_align */
-#include "lib/misc.h"
-#include "lib/memory.h" /* c2_pagesize_get */
-#include "lib/trace.h"
-
-/**
- * @addtogroup trace
- *
- * <b>Tracing facilities implementation.</b>
- *
- * Trace entries are placed in a largish buffer backed up by a memory mapped
- * file. Buffer space allocation is controlled by a single atomic variable
- * (cur).
- *
- * Trace entries contain pointers from the process address space. To interpret
- * them, c2_trace_parse() must be called in the same binary. See utils/ut_main.c
- * for example.
- *
- * @note things like address space layout randomization might break this
- * implementation.
- *
- * @{
- */
-
-/* single buffer for now */
-
-/**
- * This buffer is used for early trace records issued before real buffer is
- * initialized by c2_trace_init().
- */
-static char bootbuf[4096];
-void      *c2_logbuf     = bootbuf;
-uint32_t   c2_logbufsize = sizeof bootbuf;
-
-unsigned long c2_trace_immediate_mask = 0;
-C2_BASSERT(sizeof(c2_trace_immediate_mask) == 8);
-
-static uint32_t           bufmask;
-static struct c2_atomic64 cur;
-
-extern int  c2_arch_trace_init(void);
-extern void c2_arch_trace_fini(void);
-
-int c2_trace_init(void)
-{
-	int psize;
-
-	c2_atomic64_set(&cur, 0);
-
-	C2_ASSERT(c2_is_po2(C2_TRACE_BUFSIZE));
-	c2_logbufsize = C2_TRACE_BUFSIZE;
-	bufmask = c2_logbufsize - 1;
-
-	psize = c2_pagesize_get();
-	C2_ASSERT((c2_logbufsize % psize) == 0);
-
-	return c2_arch_trace_init();
-}
-
-void c2_trace_fini(void)
-{
-	c2_arch_trace_fini();
-	c2_logbuf = NULL;
-}
-
-
-/*
- * XXX x86_64 version.
- */
-static inline uint64_t rdtsc(void)
-{
-	uint32_t count_hi;
-	uint32_t count_lo;
-
-	__asm__ __volatile__("rdtsc" : "=a"(count_lo), "=d"(count_hi));
-
-	return ((uint64_t)count_lo) | (((uint64_t)count_hi) << 32);
-}
-
-void c2_trace_allot(const struct c2_trace_descr *td, const void *body)
-{
-	uint32_t header_len;
-	uint32_t record_len;
-	uint32_t pos_in_buf;
-	uint32_t endpos_in_buf;
-	uint64_t pos;
-	uint64_t endpos;
-	struct c2_trace_rec_header *header;
-	register unsigned long sp asm ("sp"); /* stack pointer */
-
-	/*
-	 * Allocate space in trace buffer to store trace record header
-	 * (header_len bytes) and record payload (record_len bytes).
-	 *
-	 * Record and payload always start at 8-byte aligned address.
-	 *
-	 * First free byte in the trace buffer is at "cur" offset. Note, that
-	 * cur is not wrapped to 0 when the end of the buffer is reached (that
-	 * would require additional synchronization between contending threads).
-	 */
-
-	header_len = c2_align(sizeof *header, 8);
-	record_len = header_len + c2_align(td->td_size, 8);
-
-	while (1) {
-		endpos = c2_atomic64_add_return(&cur, record_len);
-		pos    = endpos - record_len;
-		pos_in_buf = pos & bufmask;
-		endpos_in_buf = endpos & bufmask;
-		/*
-		 * The record should not cross the buffer.
-		 */
-		if (pos_in_buf > endpos_in_buf && endpos_in_buf) {
-			memset(c2_logbuf + pos_in_buf, 0,
-			       c2_logbufsize - pos_in_buf);
-			memset(c2_logbuf, 0, endpos_in_buf);
-		} else
-			break;
-	}
-
-	header                = c2_logbuf + pos_in_buf;
-	header->trh_magic     = 0;
-	header->trh_no        = pos;
-	header->trh_sp        = sp;
-	header->trh_timestamp = rdtsc();
-	header->trh_descr     = td;
-	memcpy((void*)header + header_len, body, td->td_size);
-	/** @todo put memory barrier here before writing the magic */
-	header->trh_magic = C2_TRACE_MAGIC;
-	if (C2_TRACE_IMMEDIATE_DEBUG &&
-	    (td->td_subsys & c2_trace_immediate_mask))
-		c2_trace_record_print(header, body);
-}
-
-
-void
-c2_trace_record_print(const struct c2_trace_rec_header *trh, const void *buf)
-{
-	int i;
-	const struct c2_trace_descr *td = trh->trh_descr;
-	union {
-		uint8_t  v8;
-		uint16_t v16;
-		uint32_t v32;
-		uint64_t v64;
-	} v[C2_TRACE_ARGC_MAX];
-
-	c2_console_printf("%8.8llu %15.15llu %16.16llx %-20s "
-			  "%15s:%-3i %3.3i %3i\n\t",
-			  (unsigned long long)trh->trh_no,
-			  (unsigned long long)trh->trh_timestamp,
-			  (unsigned long long)trh->trh_sp,
-			  td->td_func, td->td_file, td->td_line, td->td_size,
-			  td->td_nr);
-
-	for (i = 0; i < td->td_nr; ++i) {
-		const char *addr;
-
-		addr = buf + td->td_offset[i];
-		switch (td->td_sizeof[i]) {
-		case 0:
-			break;
-		case 1:
-			v[i].v8 = *(uint8_t *)addr;
-			break;
-		case 2:
-			v[i].v16 = *(uint16_t *)addr;
-			break;
-		case 4:
-			v[i].v32 = *(uint32_t *)addr;
-			break;
-		case 8:
-			v[i].v64 = *(uint64_t *)addr;
-			break;
-		default:
-			C2_IMPOSSIBLE("sizeof");
-		}
-	}
-	c2_console_printf(td->td_fmt, v[0], v[1], v[2], v[3], v[4], v[5], v[6],
-			  v[7], v[8]);
-	c2_console_printf("\n");
-}
-
-
-void c2_console_printf(const char *fmt, ...)
-{
-	va_list ap;
-
-	va_start(ap, fmt);
-	c2_console_vprintf(fmt, ap);
-	va_end(ap);
-}
-
-
-/** @} end of trace group */
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
diff --git a/lib/trace.h b/lib/trace.h
index 49171be..4cd1f4e 100644
--- a/lib/trace.h
+++ b/lib/trace.h
@@ -14,408 +14,89 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Nikita Danilov <Nikita_Danilov@xyratex.com>
+ * Original author: Nikita Danilov
  * Original creation date: 08/12/2010
  */
 
 #ifndef __COLIBRI_LIB_TRACE_H__
 #define __COLIBRI_LIB_TRACE_H__
 
-#include <stdarg.h>
-
-#ifdef HAVE_CONFIG_H
-#  include <config.h> /* ENABLE_DEBUG */
-#endif
-
 #include "lib/types.h"
-#include "lib/arith.h"
-
-#ifndef __KERNEL__
-#include "lib/user_space/trace.h"
-#endif
 
 /**
-   @defgroup trace Tracing
+   @defgroup trace Tracing.
 
    See doc/logging-and-tracing.
 
-   <b>Fast and light-weight tracing facility</b>
-
-   The purpose of tracing module is to provide an interface usable for the
-   following purposes:
-
-       - temporary tracing to investigate and hunt down bugs and
-
-       - always-on tracing used to postmortem analysis of a Colibri
-         installation.
-
-   Always-on mode must be non-intrusive and light-weight, otherwise users would
-   tend to disable it. On the other hand, the interface should be convenient to
-   use (i.e., to place trace points and to analyze a trace) otherwise
-   programmers would tend to ignore it. These conflicting requirements lead to
-   a implementation subtler than one might expect.
-
-   Specifically, the tracing module should conform to the following
-   requirements:
-
-       - minimal synchronization between threads;
-
-       - minimal amount of data-copying and, more generally, minimal processor
-         cost of producing a trace record;
-
-       - minimal instruction cache foot-print of tracing calls;
-
-       - printf-like interface.
-
-   <b>Usage</b>
-
-   Users produce trace records by calling C2_LOG() macro like
-
-   @code
-   C2_LOG("Cached value found: %llx, attempt: %i", foo->f_val, i);
-   @endcode
-
-   These records are placed in a shared cyclic buffer. The buffer can be
-   "parsed", producing for each record formatted output together with additional
-   information:
-
-       - file, line and function (__FILE__, __LINE__ and __func__) for C2_LOG()
-         call,
-
-       - processor-dependent time-stamp.
-
-   Parsing occurs in the following situations:
-
-       - @todo synchronously when a record is produced, or
-
-       - @todo asynchronously by a background thread, or
-
-       - after the process (including a kernel) that generated records
-         crashed. To this end the cyclic buffer is backed up by a memory mapped
-         file.
-
-   <b>Implementation</b>
-
-   To minimize processor cost of tracing, the implementation avoids run-time
-   interpretation of format string. Instead a static (in C language sense)
-   record descriptor (c2_trace_descr) is created, which contains all the static
-   information about the trace point: file, line, function, format string. The
-   record, placed in the cyclic buffer, contains only time-stamp, arguments
-   (foo->f_val, i in the example above) and the pointer to the
-   descriptor. Substitution of arguments into the format string happens during
-   record parsing. This approach poses two problems:
-
-       - how to copy arguments (which are variable in number and size) to the
-         cyclic buffer and
-
-       - how to estimate the number of bytes that have to be allocated in the
-         buffer for this copying.
-
-   Both problems are solved by means of ugly preprocessor tricks and gcc
-   extensions. For a list of arguments A0, A1, ..., An, one of C2_LOG{n}()
-   macros defines a C type declaration
-@code
-       struct t_body { typeof(A0) v0; typeof(A1) v1; ... typeof(An) vn; };
-@endcode
-
-   This declaration is used to
-
-       - find how much space in the cyclic buffer is needed to store the
-         arguments: sizeof(struct t_body);
-
-       - to copy all the arguments into allocated space:
-@code
-        *(struct t_body *)space = (struct t_body){ A0, ..., An }
-@endcode
-         This uses C99 struct literal syntax.
-
-   In addition, C2_LOG{n}() macro produces 2 integer arrays:
-
-@code
-       { offsetof(struct t_body, v0), ..., offsetof(struct t_body, vn) };
-       { sizeof(a0), ..., sizeof(an) };
-@endcode
-
-   These arrays are used during parsing to extract the arguments from the
-   buffer.
+   Fast and light-weight tracing facility.
 
    @{
  */
 
-/**
-   C2_LOG(fmt, ...) is the main user interface for the tracing. It accepts
-   the arguments in printf(3) format for the numbers, but there are some
-   tricks for string arguments.
-
-   String arguments should be specified like this:
-
-   @code
-   C2_LOG("%s", (char *)"foo");
-   @endcode
-
-   i.e. explicitly typecast to the pointer. It is because typeof("foo")
-   is not the same as typeof((char*)"foo").
-
-   @note The number of arguments after fmt is limited to 9!
-
-   C2_LOG() counts the number of arguments and calls correspondent C2_LOGx().
- */
-#define C2_LOG(...) \
-	C2_CAT(C2_LOG, C2_COUNT_PARAMS(__VA_ARGS__))(__VA_ARGS__)
-
-#define C2_ENTRY(...) C2_LOG("> " __VA_ARGS__)
-#define C2_LEAVE(...) C2_LOG("< " __VA_ARGS__)
-
-int  c2_trace_init(void);
-void c2_trace_fini(void);
-
-/*
- * Below is the internal implementation stuff.
- */
-
-#ifdef ENABLE_DEBUG
-#  define C2_TRACE_IMMEDIATE_DEBUG (1)
-#else
-#  define C2_TRACE_IMMEDIATE_DEBUG (0)
-#endif
+struct c2_trace_rec_header;
+struct c2_trace_descr;
 
-/** Magic number to locate the record */
-enum {
-	C2_TRACE_MAGIC = 0xc0de1eafacc01adeULL,
-};
-
-/** Default buffer size, the real buffer size is at c2_logbufsize */
-enum {
-	C2_TRACE_BUFSIZE  = 1 << (10 + 12) /* 4MB */
-};
-
-extern void      *c2_logbuf;      /**< Trace buffer pointer */
-extern uint32_t   c2_logbufsize;  /**< The real buffer size */
-
-/** The bitmask of what should be printed immediately to console */
-extern unsigned long c2_trace_immediate_mask;
-/** The subsystem bitmask definitions */
-enum c2_trace_subsystem {
-	C2_TRACE_SUBSYS_OTHER  = (1 << 0),
-	C2_TRACE_SUBSYS_UT     = (1 << 1),
-	C2_TRACE_SUBSYS_MEMORY = (1 << 2)
-};
-
-/**
- * Record header structure
- *
- * - magic number to locate the record in buffer
- * - stack pointer - useful to distinguish between threads
- * - global record number
- * - timestamp
- * - pointer to record description in the program file
- */
 struct c2_trace_rec_header {
-	uint64_t                     trh_magic;
-	uint64_t                     trh_sp; /**< stack pointer */
-	uint64_t                     trh_no; /**< record # */
+	uint64_t                     thr_magic;
+	uint64_t                     thr_no;
 	uint64_t                     trh_timestamp;
 	const struct c2_trace_descr *trh_descr;
 };
 
 struct c2_trace_descr {
-	const char *td_fmt;
 	const char *td_func;
 	const char *td_file;
-	uint64_t    td_subsys;
 	int         td_line;
 	int         td_size;
-	int         td_nr;
-	const int  *td_offset;
-	const int  *td_sizeof;
+	const char *td_decl;
 };
 
-void c2_trace_allot(const struct c2_trace_descr *td, const void *data);
-void c2_trace_record_print(const struct c2_trace_rec_header *trh,
-			   const void *buf);
-
-__attribute__ ((format (printf, 1, 2)))
-void c2_console_printf(const char *fmt, ...);
-void c2_console_vprintf(const char *fmt, va_list ap);
-
-/*
- * The code below abuses C preprocessor badly. Looking at it might be damaging
- * to your eyes and sanity.
- */
+void *c2_trace_allot(const struct c2_trace_descr *td);
+int   c2_trace_parse(void);
 
 /**
- * This is a low-level entry point into tracing sub-system.
- *
- * Don't call this directly, use C2_LOG() macros instead.
- *
- * Add a fixed-size trace entry into the trace buffer.
- *
- * @param NR the number of arguments
- * @param DECL C definition of a trace entry format
- * @param OFFSET the set of offsets of each argument
- * @param SIZEOF the set of sizes of each argument
- * @param FMT the printf-like format string
- * @note The variadic arguments must match the number
- *       and types of fields in the format.
- */
-#define C2_TRACE_POINT(NR, DECL, OFFSET, SIZEOF, FMT, ...)		\
-({									\
-	struct t_body DECL;						\
-	static const int _offset[NR] = OFFSET;				\
-	static const int _sizeof[NR] = SIZEOF;				\
-	static const struct c2_trace_descr td = {			\
-                .td_fmt    = (FMT),					\
-		.td_func   = __func__,					\
-		.td_file   = __FILE__,					\
-		.td_line   = __LINE__,					\
-		.td_subsys = C2_TRACE_SUBSYSTEM,			\
-		.td_size   = sizeof(struct t_body),			\
-		.td_nr     = (NR),					\
-		.td_offset = _offset,					\
-		.td_sizeof = _sizeof					\
-	};								\
-	printf_check(FMT , ## __VA_ARGS__);				\
-	c2_trace_allot(&td, &(const struct t_body){ __VA_ARGS__ });	\
-})
+   Add a fixed-size trace entry into the trace buffer.
 
-#ifndef C2_TRACE_SUBSYSTEM
-#  define C2_TRACE_SUBSYSTEM C2_TRACE_SUBSYS_OTHER
-#endif
+   A typical examples of usage are
 
-enum {
-	C2_TRACE_ARGC_MAX = 9
-};
+   @code
+   C2_TRACE_POINT({ uint32_t nr_calls; }, calls++);
+   @endcode
 
-/*
- *  Helpers for C2_LOG{n}().
- */
-#define LOG_TYPEOF(a, v) typeof(a) v
-#define LOG_OFFSETOF(v) offsetof(struct t_body, v)
-#define LOG_SIZEOF(a) sizeof(a)
+   and
 
-#define LOG_CHECK(a)							\
-C2_CASSERT(!C2_HAS_TYPE(a, const char []) &&				\
-	   (sizeof(a) == 1 || sizeof(a) == 2 || sizeof(a) == 4 ||	\
-	    sizeof(a) == 8))
+   @code
+   C2_TRACE_POINT({ uint64_t fop_opcode; uint16_t got_lock; }, 
+                  fop->f_opcode, c2_mutex_is_locked(&queue_lock));
+   @endcode
 
-/**
- * LOG_GROUP() is used to pass { x0, ..., xn } as a single argument to
- * C2_TRACE_POINT().
+   The first argument, DECL is a C definition of a trace entry format. The
+   remaining arguments must match the number and types of fields in the format.
  */
-#define LOG_GROUP(...) __VA_ARGS__
-
-#define C2_LOG0(fmt)     C2_TRACE_POINT(0, { ; }, {}, {}, fmt)
-
-#define C2_LOG1(fmt, a0)						\
-({ C2_TRACE_POINT(1,							\
-   { LOG_TYPEOF(a0, v0); },						\
-   { LOG_OFFSETOF(v0) },						\
-   { LOG_SIZEOF(a0) },							\
-   fmt, a0);								\
-   LOG_CHECK(a0); })
-
-#define C2_LOG2(fmt, a0, a1)						\
-({ C2_TRACE_POINT(2,							\
-   { LOG_TYPEOF(a0, v0); LOG_TYPEOF(a1, v1); },				\
-   LOG_GROUP({ LOG_OFFSETOF(v0), LOG_OFFSETOF(v1) }),			\
-   LOG_GROUP({ LOG_SIZEOF(a0), LOG_SIZEOF(a1) }),			\
-   fmt, a0, a1);							\
-   LOG_CHECK(a0); LOG_CHECK(a1); })
-
-#define C2_LOG3(fmt, a0, a1, a2)					\
-({ C2_TRACE_POINT(3,							\
-   { LOG_TYPEOF(a0, v0); LOG_TYPEOF(a1, v1); LOG_TYPEOF(a2, v2); },	\
-   LOG_GROUP({ LOG_OFFSETOF(v0), LOG_OFFSETOF(v1), LOG_OFFSETOF(v2) }),	\
-   LOG_GROUP({ LOG_SIZEOF(a0), LOG_SIZEOF(a1), LOG_SIZEOF(a2) }),	\
-   fmt, a0, a1, a2);							\
-   LOG_CHECK(a0); LOG_CHECK(a1); LOG_CHECK(a2); })
-
-#define C2_LOG4(fmt, a0, a1, a2, a3)					\
-({ C2_TRACE_POINT(4,							\
-   { LOG_TYPEOF(a0, v0); LOG_TYPEOF(a1, v1); LOG_TYPEOF(a2, v2);	\
-     LOG_TYPEOF(a3, v3); },						\
-   LOG_GROUP({ LOG_OFFSETOF(v0), LOG_OFFSETOF(v1), LOG_OFFSETOF(v2),	\
-               LOG_OFFSETOF(v3) }),					\
-   LOG_GROUP({ LOG_SIZEOF(a0), LOG_SIZEOF(a1), LOG_SIZEOF(a2),		\
-               LOG_SIZEOF(a3) }),					\
-   fmt, a0, a1, a2, a3);						\
-   LOG_CHECK(a0); LOG_CHECK(a1); LOG_CHECK(a2); LOG_CHECK(a3); })
-
-#define C2_LOG5(fmt, a0, a1, a2, a3, a4)				\
-({ C2_TRACE_POINT(5,							\
-   { LOG_TYPEOF(a0, v0); LOG_TYPEOF(a1, v1); LOG_TYPEOF(a2, v2);	\
-     LOG_TYPEOF(a3, v3); LOG_TYPEOF(a4, v4); },				\
-   LOG_GROUP({ LOG_OFFSETOF(v0), LOG_OFFSETOF(v1), LOG_OFFSETOF(v2),	\
-               LOG_OFFSETOF(v3), LOG_OFFSETOF(v4) }),			\
-   LOG_GROUP({ LOG_SIZEOF(a0), LOG_SIZEOF(a1), LOG_SIZEOF(a2),		\
-               LOG_SIZEOF(a3), LOG_SIZEOF(a4) }),			\
-   fmt, a0, a1, a2, a3, a4);						\
-   LOG_CHECK(a0); LOG_CHECK(a1); LOG_CHECK(a2); LOG_CHECK(a3);		\
-   LOG_CHECK(a4); })
-
-#define C2_LOG6(fmt, a0, a1, a2, a3, a4, a5)				\
-({ C2_TRACE_POINT(6,							\
-   { LOG_TYPEOF(a0, v0); LOG_TYPEOF(a1, v1); LOG_TYPEOF(a2, v2);	\
-     LOG_TYPEOF(a3, v3); LOG_TYPEOF(a4, v4); LOG_TYPEOF(a5, v5); },	\
-   LOG_GROUP({ LOG_OFFSETOF(v0), LOG_OFFSETOF(v1), LOG_OFFSETOF(v2),	\
-               LOG_OFFSETOF(v3), LOG_OFFSETOF(v4), LOG_OFFSETOF(v5) }),	\
-   LOG_GROUP({ LOG_SIZEOF(a0), LOG_SIZEOF(a1), LOG_SIZEOF(a2),		\
-               LOG_SIZEOF(a3), LOG_SIZEOF(a4), LOG_SIZEOF(a5) }),	\
-   fmt, a0, a1, a2, a3, a4, a5);					\
-   LOG_CHECK(a0); LOG_CHECK(a1); LOG_CHECK(a2); LOG_CHECK(a3);		\
-   LOG_CHECK(a4); LOG_CHECK(a5); })
-
-#define C2_LOG7(fmt, a0, a1, a2, a3, a4, a5, a6)			\
-({ C2_TRACE_POINT(7,							\
-   { LOG_TYPEOF(a0, v0); LOG_TYPEOF(a1, v1); LOG_TYPEOF(a2, v2);	\
-     LOG_TYPEOF(a3, v3); LOG_TYPEOF(a4, v4); LOG_TYPEOF(a5, v5);	\
-     LOG_TYPEOF(a6, v6); },						\
-   LOG_GROUP({ LOG_OFFSETOF(v0), LOG_OFFSETOF(v1), LOG_OFFSETOF(v2),	\
-               LOG_OFFSETOF(v3), LOG_OFFSETOF(v4),			\
-               LOG_OFFSETOF(v5), LOG_OFFSETOF(v6) }),			\
-   LOG_GROUP({ LOG_SIZEOF(a0), LOG_SIZEOF(a1), LOG_SIZEOF(a2),		\
-               LOG_SIZEOF(a3), LOG_SIZEOF(a4),				\
-               LOG_SIZEOF(a5), LOG_SIZEOF(a6) }),			\
-   fmt, a0, a1, a2, a3, a4, a5, a6);					\
-   LOG_CHECK(a0); LOG_CHECK(a1); LOG_CHECK(a2); LOG_CHECK(a3);		\
-   LOG_CHECK(a4); LOG_CHECK(a5); LOG_CHECK(a6); })
-
-#define C2_LOG8(fmt, a0, a1, a2, a3, a4, a5, a6, a7)			\
-({ C2_TRACE_POINT(8,							\
-   { LOG_TYPEOF(a0, v0); LOG_TYPEOF(a1, v1); LOG_TYPEOF(a2, v2);	\
-     LOG_TYPEOF(a3, v3); LOG_TYPEOF(a4, v4); LOG_TYPEOF(a5, v5);	\
-     LOG_TYPEOF(a6, v6); LOG_TYPEOF(a7, v7); },				\
-   LOG_GROUP({ LOG_OFFSETOF(v0), LOG_OFFSETOF(v1), LOG_OFFSETOF(v2),	\
-               LOG_OFFSETOF(v3), LOG_OFFSETOF(v4), LOG_OFFSETOF(v5),	\
-               LOG_OFFSETOF(v6), LOG_OFFSETOF(v7) }),			\
-   LOG_GROUP({ LOG_SIZEOF(a0), LOG_SIZEOF(a1), LOG_SIZEOF(a2),		\
-               LOG_SIZEOF(a3), LOG_SIZEOF(a4), LOG_SIZEOF(a5),		\
-               LOG_SIZEOF(a6), LOG_SIZEOF(a7) }),			\
-   fmt, a0, a1, a2, a3, a4, a5, a6, a7);				\
-   LOG_CHECK(a0); LOG_CHECK(a1); LOG_CHECK(a2); LOG_CHECK(a3);		\
-   LOG_CHECK(a4); LOG_CHECK(a5); LOG_CHECK(a6); LOG_CHECK(a7); })
+#define C2_TRACE_POINT(DECL, ...)					\
+({									\
+	struct t_body DECL;						\
+									\
+	static const struct c2_trace_descr td  = {			\
+		.td_func = __func__,					\
+		.td_file = __FILE__,					\
+		.td_line = __LINE__,					\
+		.td_size = sizeof(struct t_body),			\
+		.td_decl = #DECL					\
+	};								\
+	*(struct t_body *)c2_trace_allot(&td) = 			\
+                                (const struct t_body){ __VA_ARGS__ };	\
+})
 
-#define C2_LOG9(fmt, a0, a1, a2, a3, a4, a5, a6, a7, a8)		\
-({ C2_TRACE_POINT(9,							\
-   { LOG_TYPEOF(a0, v0); LOG_TYPEOF(a1, v1); LOG_TYPEOF(a2, v2);	\
-     LOG_TYPEOF(a3, v3); LOG_TYPEOF(a4, v4); LOG_TYPEOF(a5, v5);	\
-     LOG_TYPEOF(a6, v6); LOG_TYPEOF(a7, v7); LOG_TYPEOF(a8, v8); },	\
-   LOG_GROUP({ LOG_OFFSETOF(v0), LOG_OFFSETOF(v1), LOG_OFFSETOF(v2),	\
-               LOG_OFFSETOF(v3), LOG_OFFSETOF(v4), LOG_OFFSETOF(v5),	\
-               LOG_OFFSETOF(v6), LOG_OFFSETOF(v7), LOG_OFFSETOF(v8) }),	\
-   LOG_GROUP({ LOG_SIZEOF(a0), LOG_SIZEOF(a1), LOG_SIZEOF(a2),		\
-               LOG_SIZEOF(a3), LOG_SIZEOF(a4), LOG_SIZEOF(a5),		\
-               LOG_SIZEOF(a6), LOG_SIZEOF(a7), LOG_SIZEOF(a8) }),	\
-   fmt, a0, a1, a2, a3, a4, a5, a6, a7, a8);				\
-   LOG_CHECK(a0); LOG_CHECK(a1); LOG_CHECK(a2); LOG_CHECK(a3);		\
-   LOG_CHECK(a4); LOG_CHECK(a5); LOG_CHECK(a6); LOG_CHECK(a7); LOG_CHECK(a8); })
+int  c2_trace_init(void);
+void c2_trace_fini(void);
 
 /** @} end of trace group */
 
 /* __COLIBRI_LIB_TRACE_H__ */
 #endif
 
-/*
+/* 
  *  Local variables:
  *  c-indentation-style: "K&R"
  *  c-basic-offset: 8
diff --git a/lib/types.h b/lib/types.h
index c08eeaf..a045a9f 100644
--- a/lib/types.h
+++ b/lib/types.h
@@ -14,7 +14,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Nikita Danilov <Nikita_Danilov@xyratex.com>
+ * Original author: Nikita Danilov
  * Original creation date: 08/14/2010
  */
 
diff --git a/lib/ub.c b/lib/ub.c
index 648a96e..67cafb1 100644
--- a/lib/ub.c
+++ b/lib/ub.c
@@ -14,7 +14,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Nikita Danilov <Nikita_Danilov@xyratex.com>
+ * Original author: Nikita Danilov
  * Original creation date: 07/20/2010
  */
 
diff --git a/lib/ub.h b/lib/ub.h
index 0ee3658..f3e115e 100644
--- a/lib/ub.h
+++ b/lib/ub.h
@@ -13,7 +13,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
 
- * Original author: Nikita Danilov <Nikita_Danilov@xyratex.com>
+ * Original author: Nikita Danilov
  * Original creation date: 07/20/2010
  */
 
diff --git a/lib/user_space/Makefile.am b/lib/user_space/Makefile.am
index 795705c..bf26876 100644
--- a/lib/user_space/Makefile.am
+++ b/lib/user_space/Makefile.am
@@ -1,4 +1,4 @@
-user_spacedir            = $(includedir)/colibri/lib/user_space
-user_space_HEADERS       = assert.h cdefs.h mutex.h rwlock.h time.h \
+user_spacedir            = $(includedir)/lib/user_space
+user_space_HEADERS       = assert.h cdefs.h chan.h mutex.h rwlock.h time.h \
                            types.h user_x86_64_atomic.h thread.h timer.h \
                            semaphore.h
diff --git a/lib/user_space/assert.h b/lib/user_space/assert.h
index 4c743a3..28bd760 100644
--- a/lib/user_space/assert.h
+++ b/lib/user_space/assert.h
@@ -14,7 +14,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Nikita Danilov <Nikita_Danilov@xyratex.com>
+ * Original author: Nikita Danilov
  * Original creation date: 08/04/2010
  */
 
diff --git a/lib/user_space/cdefs.h b/lib/user_space/cdefs.h
index bcf2c14..e3f33b3 100644
--- a/lib/user_space/cdefs.h
+++ b/lib/user_space/cdefs.h
@@ -14,7 +14,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Nikita Danilov <Nikita_Danilov@xyratex.com>
+ * Original author: Nikita Danilov
  * Original creation date: 08/04/2010
  */
 
diff --git a/lib/user_space/memory.c b/lib/user_space/memory.c
deleted file mode 100644
index 1be1789..0000000
--- a/lib/user_space/memory.c
+++ /dev/null
@@ -1,187 +0,0 @@
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Nikita Danilov <Nikita_Danilov@xyratex.com>
- * Original creation date: 05/17/2010
- */
-
-
-#ifdef HAVE_CONFIG_H
-#  include <config.h>
-#endif
-
-#include <stdlib.h>
-#include <string.h>
-#include <unistd.h>
-
-#include "lib/arith.h"   /* min_type, c2_is_po2 */
-#include "lib/assert.h"
-#include "lib/atomic.h"
-#include "lib/memory.h"
-
-#define C2_TRACE_SUBSYSTEM C2_TRACE_SUBSYS_MEMORY
-#include "lib/trace.h"
-
-/**
-   @addtogroup memory
-
-   <b>User level malloc(3) based implementation.</b>
-
-   The only interesting detail is implementation of c2_allocated(). No standard
-   function returns the amount of memory allocated in the arena.
-
-   GNU Libc defines mallinfo() function, returning the amount of allocated
-   memory among other things. In OS X (of all places) there is malloc_size()
-   function that, given a pointer to an allocated block of memory, returns its
-   size. On other platforms c2_allocates() is always 0.
-
-   @{
-*/
-
-static struct c2_atomic64 allocated;
-
-#ifdef HAVE_MALLINFO
-
-#include <malloc.h>
-static size_t __allocated(void)
-{
-	struct mallinfo mi;
-
-	mi = mallinfo();
-	return mi.uordblks;
-}
-#define __free free
-#define __malloc malloc
-
-/* HAVE_MALLINFO */
-#elif HAVE_MALLOC_SIZE
-
-#include <malloc/malloc.h>
-
-static void __free(void *ptr)
-{
-	c2_atomic64_sub(&allocated, malloc_size(ptr));
-	free(ptr);
-}
-
-void *__malloc(size_t size)
-{
-	void *area;
-
-	area = malloc(size);
-	c2_atomic64_add(&allocated, malloc_size(area));
-	return area;
-}
-
-static size_t __allocated(void)
-{
-	return c2_atomic64_get(&allocated);
-}
-
-/* HAVE_MALLOC_SIZE */
-#else
-
-static size_t __allocated(void)
-{
-	return 0;
-}
-
-#define __free free
-#define __malloc malloc
-
-#endif
-
-void *c2_alloc(size_t size)
-{
-	void *ret;
-
-	C2_ENTRY("%lu", size);
-	ret = __malloc(size);
-	if (ret)
-		memset(ret, 0, size);
-	C2_LEAVE("%lu %lx", size, (long unsigned)ret);
-	return ret;
-}
-
-void c2_free(void *data)
-{
-	C2_ENTRY("%lx", (long unsigned)data);
-	__free(data);
-	C2_LEAVE();
-}
-
-static size_t used0;
-
-size_t c2_allocated(void)
-{
-	size_t used;
-
-	used = __allocated();
-	if (used < used0)
-		used = used0;
-	return used - used0;
-}
-
-void *c2_alloc_aligned(size_t size, unsigned shift)
-{
-	void  *result;
-	int    rc;
-	size_t alignment;
-
-	/*
-	 * posix_memalign(3):
-	 *
-	 *         The requested alignment must be a power of 2 at least as
-	 *         large as sizeof(void *).
-	 */
-
-	alignment = max_type(size_t, 1 << shift, sizeof result);
-	C2_ASSERT(c2_is_po2(alignment));
-	rc = posix_memalign(&result, alignment, size);
-	if (rc == 0)
-		memset(result, 0, size);
-	else
-		result = NULL;
-	return result;
-}
-
-int c2_memory_init()
-{
-	c2_atomic64_set(&allocated, 0);
-	used0 = __allocated();
-	return 0;
-}
-
-void c2_memory_fini()
-{
-}
-
-int c2_pagesize_get()
-{
-	return getpagesize();
-}
-
-
-/** @} end of memory group */
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
diff --git a/lib/user_space/mutex.h b/lib/user_space/mutex.h
index ed76f0e..d919d8c 100644
--- a/lib/user_space/mutex.h
+++ b/lib/user_space/mutex.h
@@ -14,7 +14,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Nikita Danilov <Nikita_Danilov@xyratex.com>
+ * Original author: Nikita Danilov
  * Original creation date: 08/05/2010
  */
 
diff --git a/lib/user_space/processor.c b/lib/user_space/processor.c
index f89b55b..b866ba8 100644
--- a/lib/user_space/processor.c
+++ b/lib/user_space/processor.c
@@ -14,7 +14,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Rajesh Bhalerao <Rajesh_Bhalerao@xyratex.com>
+ * Original author: Rajesh Bhalerao
  * Original creation date: 03/11/2011
  */
 
@@ -111,7 +111,7 @@ enum map {
 
    @see lib/processor.h
  */
-struct processor_sys_summary {
+struct c2_processor_sys_summary {
 	/** Head of the list for processor info */
 	struct c2_list	pss_head;
 
@@ -146,8 +146,8 @@ struct c2_processor_node {
 /**
 	Global Variables.
  */
-static struct processor_sys_summary sys_cpus;
-static bool processor_init = false;
+static struct c2_processor_sys_summary sys_cpus;
+static bool c2_processor_init = false;
 
 /**
    This function converts a bitmap string into a bitmap of c2_bitmap type.
@@ -164,7 +164,7 @@ static bool processor_init = false;
    @see c2_processors_set_map_type()
 
  */
-static int processor_set_map(struct c2_bitmap *map, const char *mapstr)
+static int c2_processor_set_map(struct c2_bitmap *map, const char *mapstr)
 {
 	uint32_t from_id = 0;
 	uint32_t to_id = 0;
@@ -211,7 +211,7 @@ static int processor_set_map(struct c2_bitmap *map, const char *mapstr)
 		rangeset = strtok(NULL, C2_PROCESSORS_RANGE_SET_SEPARATOR);
 
 	}/* while - string is parsed */
-
+	
 	/*
 	 * Free memory allocated by strdup()
 	 */
@@ -229,10 +229,10 @@ static int processor_set_map(struct c2_bitmap *map, const char *mapstr)
               -1, upon failure.
    @pre Assumes the directory has been changed to approriate CPU
         info dir.
-   @see processor_set_map()
+   @see c2_processor_set_map()
 
  */
-static int processor_set_map_type(enum map map_type)
+static int c2_processor_set_map_type(enum map map_type)
 {
 	int	rc = -1;
 
@@ -293,7 +293,7 @@ static int processor_set_map_type(enum map map_type)
 
 	rc = c2_bitmap_init(pbitmap, sys_cpus.pss_max);
 	if (rc == 0) {
-		processor_set_map(pbitmap, buf);
+		c2_processor_set_map(pbitmap, buf);
 	}
 	return rc;
 }
@@ -306,7 +306,7 @@ static int processor_set_map_type(enum map map_type)
               C2_PROCESSORS_INVALID_ID, upon failure.
 
  */
-static uint32_t processor_read_number_from_file(const char *filename)
+static uint32_t c2_processor_read_number_from_file(const char *filename)
 {
 	uint32_t val = C2_PROCESSORS_INVALID_ID;
 	int	rc;
@@ -322,7 +322,6 @@ static uint32_t processor_read_number_from_file(const char *filename)
 		val = C2_PROCESSORS_INVALID_ID;
 	}
 
-	fclose(fp);
 	return val;
 }
 
@@ -332,14 +331,14 @@ static uint32_t processor_read_number_from_file(const char *filename)
 
    @pre Assumes the directory has been changed to approriate CPU
         info dir.
-   @see processor_set_map()
-   @see processor_set_map_type()
+   @see c2_processor_set_map()
+   @see c2_processor_set_map_type()
 
  */
-static void processor_get_maxsz()
+static void c2_processor_get_maxsz()
 {
 	sys_cpus.pss_max
-	= processor_read_number_from_file(C2_PROCESSORS_MAX_FILE);
+	= c2_processor_read_number_from_file(C2_PROCESSORS_MAX_FILE);
 }
 
 /**
@@ -353,7 +352,7 @@ static void processor_get_maxsz()
    @pre Assumes the directory has been changed to approriate CPU
         info dir.
  */
-static uint32_t processor_get_numanodeid(c2_processor_nr_t id)
+static uint32_t c2_processor_get_numanodeid(c2_processor_nr_t id)
 {
 	uint32_t numa_node_id = 0;
 	uint32_t gotid = 0;
@@ -435,14 +434,14 @@ static uint32_t processor_get_numanodeid(c2_processor_nr_t id)
    @retval "core" id for a given processor, on success.
            C2_PROCESSORS_INVALID_ID, on failure.
  */
-static uint32_t processor_get_coreid(c2_processor_nr_t id)
+static uint32_t c2_processor_get_coreid(c2_processor_nr_t id)
 {
 	uint32_t coreid;
 	char filebuf[PATH_MAX];
 
 	sprintf(filebuf, C2_PROCESSORS_CPU_DIR_PREFIX"%u/"
 			 C2_PROCESSORS_COREID_FILE, id);
-	coreid = processor_read_number_from_file(filebuf);
+	coreid = c2_processor_read_number_from_file(filebuf);
 
 	return coreid;
 }
@@ -458,14 +457,14 @@ static uint32_t processor_get_coreid(c2_processor_nr_t id)
    @retval "phys" id for a given processor, on success.
            C2_PROCESSORS_INVALID_ID, on failure.
  */
-static uint32_t processor_get_physid(c2_processor_nr_t id)
+static uint32_t c2_processor_get_physid(c2_processor_nr_t id)
 {
 	uint32_t physid;
 	char	filebuf[PATH_MAX];
 
 	sprintf(filebuf, C2_PROCESSORS_CPU_DIR_PREFIX"%u/"
 			 C2_PROCESSORS_PHYSID_FILE, id);
-	physid = processor_read_number_from_file(filebuf);
+	physid = c2_processor_read_number_from_file(filebuf);
 
 	return physid;
 }
@@ -478,7 +477,7 @@ static uint32_t processor_get_physid(c2_processor_nr_t id)
    @retval 1 if the processor shares the map
    @retval 0 if the processor does not the map
  */
-static int processor_is_cache_shared(const char *mapstr)
+static int c2_processor_is_cache_shared(const char *mapstr)
 {
 	char *ptr;
 	char *str;
@@ -545,7 +544,7 @@ static int processor_is_cache_shared(const char *mapstr)
    @pre Assumes the directory has been changed to approriate CPU
         info dir.
  */
-static size_t processor_get_l1_size(c2_processor_nr_t id)
+static size_t c2_processor_get_l1_size(c2_processor_nr_t id)
 {
 	uint32_t level;
 	uint32_t sz;
@@ -556,7 +555,7 @@ static size_t processor_get_l1_size(c2_processor_nr_t id)
 
 	sprintf(filename, "%s%u/%s", C2_PROCESSORS_CPU_DIR_PREFIX, id,
 				   C2_PROCESSORS_CACHE1_LEVEL_FILE);
-	level = processor_read_number_from_file(filename);
+	level = c2_processor_read_number_from_file(filename);
 	if (level == C2_PROCESSORS_INVALID_ID) {
 		return size;
 	}
@@ -598,10 +597,11 @@ static size_t processor_get_l1_size(c2_processor_nr_t id)
    @pre Assumes the directory has been changed to approriate CPU
         info dir.
  */
-static size_t processor_get_l2_size(c2_processor_nr_t id)
+static size_t c2_processor_get_l2_size(c2_processor_nr_t id)
 {
 	uint32_t level;
 	uint32_t sz;
+	uint32_t l3_cache_present;
 	int	rc;
 	size_t	size = (size_t)C2_PROCESSORS_INVALID_ID;
 	char	filename[PATH_MAX];
@@ -609,7 +609,7 @@ static size_t processor_get_l2_size(c2_processor_nr_t id)
 
 	sprintf(filename, "%s%u/%s", C2_PROCESSORS_CPU_DIR_PREFIX, id,
 				   C2_PROCESSORS_CACHE3_LEVEL_FILE);
-	level = processor_read_number_from_file(filename);
+	level = c2_processor_read_number_from_file(filename);
 	if (level == C2_PROCESSORS_INVALID_ID) {
 		return size;
 	}
@@ -617,12 +617,13 @@ static size_t processor_get_l2_size(c2_processor_nr_t id)
 	if (level != C2_PROCESSORS_L2) { /* If L2 level is not found */
 		sprintf(filename, "%s%u/%s", C2_PROCESSORS_CPU_DIR_PREFIX, id,
 					   C2_PROCESSORS_CACHE2_LEVEL_FILE);
-		level = processor_read_number_from_file(filename);
+		level = c2_processor_read_number_from_file(filename);
 		if (level == C2_PROCESSORS_INVALID_ID) {
 			return size;
 		}
 
 		C2_ASSERT(level == C2_PROCESSORS_L2);
+		l3_cache_present = 1;
 		/*
 		 * Set path to appropriate cache size file
 		 */
@@ -664,7 +665,7 @@ static size_t processor_get_l2_size(c2_processor_nr_t id)
    @pre Assumes the directory has been changed to approriate CPU
         info dir.
  */
-static uint32_t processor_get_l1_cacheid(c2_processor_nr_t id)
+static uint32_t c2_processor_get_l1_cacheid(c2_processor_nr_t id)
 {
 	uint32_t level;
 	uint32_t coreid;
@@ -681,7 +682,7 @@ static uint32_t processor_get_l1_cacheid(c2_processor_nr_t id)
 
 	sprintf(filename, "%s%u/%s", C2_PROCESSORS_CPU_DIR_PREFIX, id,
 				   C2_PROCESSORS_CACHE1_LEVEL_FILE);
-	level = processor_read_number_from_file(filename);
+	level = c2_processor_read_number_from_file(filename);
 	if (level == C2_PROCESSORS_INVALID_ID) {
 		return l1_id;
 	}
@@ -711,10 +712,10 @@ static uint32_t processor_get_l1_cacheid(c2_processor_nr_t id)
 	 * Scan the map string to find how many bits are set in the string
 	 * If more than one bit is set, then cache is shared.
 	 */
-	is_shared = processor_is_cache_shared(buf);
+	is_shared = c2_processor_is_cache_shared(buf);
 	if (is_shared > 0) { /* L1 cache is shared */
-		physid = processor_get_physid(id);
-		coreid = processor_get_coreid(id);
+		physid = c2_processor_get_physid(id);
+		coreid = c2_processor_get_coreid(id);	
 		l1_id = physid << 16 | coreid;
 	}
 
@@ -732,7 +733,7 @@ static uint32_t processor_get_l1_cacheid(c2_processor_nr_t id)
    @pre Assumes the directory has been changed to approriate CPU
         info dir.
  */
-static uint32_t processor_get_l2_cacheid(c2_processor_nr_t id)
+static uint32_t c2_processor_get_l2_cacheid(c2_processor_nr_t id)
 {
 	uint32_t level;
 	uint32_t l2_id = id;
@@ -750,7 +751,7 @@ static uint32_t processor_get_l2_cacheid(c2_processor_nr_t id)
 
 	sprintf(filename, "%s%u/%s", C2_PROCESSORS_CPU_DIR_PREFIX, id,
 				   C2_PROCESSORS_CACHE3_LEVEL_FILE);
-	level = processor_read_number_from_file(filename);
+	level = c2_processor_read_number_from_file(filename);
 	if (level == C2_PROCESSORS_INVALID_ID) {
 		return l2_id;
 	}
@@ -758,7 +759,7 @@ static uint32_t processor_get_l2_cacheid(c2_processor_nr_t id)
 	if (level != C2_PROCESSORS_L2) {
 		sprintf(filename, "%s%u/%s", C2_PROCESSORS_CPU_DIR_PREFIX, id,
 					   C2_PROCESSORS_CACHE2_LEVEL_FILE);
-		level = processor_read_number_from_file(filename);
+		level = c2_processor_read_number_from_file(filename);
 		if (level == C2_PROCESSORS_INVALID_ID) {
 			return l2_id;
 		}
@@ -795,12 +796,12 @@ static uint32_t processor_get_l2_cacheid(c2_processor_nr_t id)
 	/*
 	 * Scan the map string to find how many bits are set in the string
 	 */
-	is_shared = processor_is_cache_shared(buf);
+	is_shared = c2_processor_is_cache_shared(buf);
 	if (is_shared > 0 ) { /* L2 cache is shared */
-		physid = processor_get_physid(id);
+		physid = c2_processor_get_physid(id);
 
 		if (l3_cache_present == true) { /* L3 cache is present */
-			coreid = processor_get_coreid(id);
+			coreid = c2_processor_get_coreid(id);	
 			l2_id = physid << 16 | coreid;
 		} else {
 			l2_id = physid;
@@ -819,7 +820,7 @@ static uint32_t processor_get_l2_cacheid(c2_processor_nr_t id)
    @retval id of pipeline for the given processor.
 
  */
-static inline uint32_t processor_get_pipelineid(c2_processor_nr_t id)
+static inline uint32_t c2_processor_get_pipelineid(c2_processor_nr_t id)
 {
 	return id;
 }
@@ -829,7 +830,7 @@ static inline uint32_t processor_get_pipelineid(c2_processor_nr_t id)
    This function will scan,parse directories and files under "sysfs".
    This data is cached.
 
-   This function will be called from processors_getsummary().
+   This function will be called from c2_processors_getsummary().
 
    @param sysfs_dir -> Directory underwhich the information should be searched
    @param id -> id of the processor for which information is requested.
@@ -840,49 +841,49 @@ static inline uint32_t processor_get_pipelineid(c2_processor_nr_t id)
    @pre Memory to 'pn' must be allocated by the calling function
    @post pn structure will be filled with processor information
 
-   @see processors_getsummary()
+   @see c2_processors_getsummary()
  */
-static int processor_getinfo(c2_processor_nr_t id,
-			     struct c2_processor_node *pn)
+static int c2_processor_getinfo(c2_processor_nr_t id,
+                          	 struct c2_processor_node *pn)
 {
 	int rc = -1;
 
 	C2_ASSERT(pn != NULL);
 
-	pn->pn_info.pd_numa_node = processor_get_numanodeid(id);
+	pn->pn_info.pd_numa_node = c2_processor_get_numanodeid(id);
 	if ( pn->pn_info.pd_numa_node == C2_PROCESSORS_INVALID_ID) {
 		return rc;
 	}
 
-	pn->pn_info.pd_l1 = processor_get_l1_cacheid(id);
+	pn->pn_info.pd_l1 = c2_processor_get_l1_cacheid(id);
 	if ( pn->pn_info.pd_l1 == C2_PROCESSORS_INVALID_ID) {
 		return rc;
 	}
 
-	pn->pn_info.pd_l1_sz = processor_get_l1_size(id);
+	pn->pn_info.pd_l1_sz = c2_processor_get_l1_size(id);
 	if ( pn->pn_info.pd_l1_sz == C2_PROCESSORS_INVALID_ID) {
 		return rc;
 	}
 
-	pn->pn_info.pd_l2 = processor_get_l2_cacheid(id);
+	pn->pn_info.pd_l2 = c2_processor_get_l2_cacheid(id);
 	if ( pn->pn_info.pd_l2 == C2_PROCESSORS_INVALID_ID) {
 		return rc;
 	}
 
-	pn->pn_info.pd_l2_sz = processor_get_l2_size(id);
+	pn->pn_info.pd_l2_sz = c2_processor_get_l2_size(id);
 	if ( pn->pn_info.pd_l2_sz == C2_PROCESSORS_INVALID_ID) {
 		return rc;
 	}
 
 	pn->pn_info.pd_id = id;
-	pn->pn_info.pd_pipeline = processor_get_pipelineid(id);
+	pn->pn_info.pd_pipeline = c2_processor_get_pipelineid(id);
 
 	rc = 0;
 	return rc;
 }
 
 /**
-   Parse "sysfs" (/sys/devices/system) directory to fetch the summary of
+   Parse "sysfs" (/sys/devices/system) directory to fetch the summary of 
    processors on this system.
 
    To facilitate testing, this function will fetch the directory string from
@@ -891,15 +892,15 @@ static int processor_getinfo(c2_processor_nr_t id,
    Under normal operation, a default value of "sysfs" directory is used.
 
    @pre  C2_PROCESSORS_INFO_DIR/default directory must exist.
-   @post A global variable of type processor_sys_summary will be filled in
+   @post A global variable of type c2_processor_sys_summary will be filled in
 
    @retval -> 0, if successful
               -1, upon failure.
-   @see lib/processor.h
+   @see lib/processor.h 
    @see void c2_processors_init()
 
  */
-static int processors_getsummary()
+static int c2_processors_getsummary()
 {
 	int	rc = -1;
 
@@ -943,26 +944,26 @@ static int processors_getsummary()
 	 */
 	rc = -1;
 
-	processor_get_maxsz();
+	c2_processor_get_maxsz();
 	if ( sys_cpus.pss_max == C2_PROCESSORS_INVALID_ID) {
 		chdir(cwd);
 		return rc;
 	}
 
-	rc = processor_set_map_type(C2_PROCESSORS_POSS_MAP);
+	rc = c2_processor_set_map_type(C2_PROCESSORS_POSS_MAP);
 	if (rc != 0) {
 		chdir(cwd);
 		return rc;
 	}
 
-	rc = processor_set_map_type(C2_PROCESSORS_AVAIL_MAP);
+	rc = c2_processor_set_map_type(C2_PROCESSORS_AVAIL_MAP);
 	if (rc != 0) {
 		c2_bitmap_fini(&sys_cpus.pss_poss_map);
 		chdir(cwd);
 		return rc;
 	}
 
-	rc = processor_set_map_type(C2_PROCESSORS_ONLN_MAP);
+	rc = c2_processor_set_map_type(C2_PROCESSORS_ONLN_MAP);
 	if (rc != 0) {
 		c2_bitmap_fini(&sys_cpus.pss_poss_map);
 		c2_bitmap_fini(&sys_cpus.pss_avail_map);
@@ -981,7 +982,7 @@ static int processors_getsummary()
 		if (present == true) {
 			pinfo = (struct c2_processor_node *)
 				calloc (1, sizeof(struct c2_processor_node));
-			rc = processor_getinfo(cpuid, pinfo);
+			rc = c2_processor_getinfo(cpuid, pinfo);
 			if (rc != 0) {
 				free(pinfo);
 			} else {
@@ -1016,11 +1017,21 @@ static int processors_getsummary()
    @param src -> Source bitmap.
    @param dst -> Destination bitmap
  */
-static void processors_copy_c2bitmap(const struct c2_bitmap *src,
+static void c2_processors_copy_c2bitmap(const struct c2_bitmap *src,
 			       struct c2_bitmap *dst)
 {
+	size_t	i;
+	bool	val;
+
+	C2_ASSERT(dst->b_nr >= src->b_nr);
 	C2_ASSERT(dst->b_nr <= sys_cpus.pss_max);
-	c2_bitmap_copy(dst, src);
+
+	for (i = 0; i < src->b_nr; i++) {
+		val = c2_bitmap_get(src, i);
+		c2_bitmap_set(dst, i, val);
+
+	}/* for - scan the source bitmap */
+
 }
 
 /* ---- Processor Interface Implementation ---- */
@@ -1051,9 +1062,9 @@ int c2_processors_init()
 {
 	int rc;
 
-	rc = processors_getsummary();
+	rc = c2_processors_getsummary();
 	if (rc == 0) {
-		processor_init = true;
+		c2_processor_init = true;
 	}
 	return rc;
 }
@@ -1067,7 +1078,7 @@ int c2_processors_init()
 void c2_processors_fini()
 {
 	struct c2_list_link *node;
-	struct c2_processor_node *pinfo;
+	struct c2_processor_node *pinfo;	
 
 	c2_bitmap_fini(&sys_cpus.pss_poss_map);
 	c2_bitmap_fini(&sys_cpus.pss_avail_map);
@@ -1085,7 +1096,7 @@ void c2_processors_fini()
 		node = sys_cpus.pss_head.l_head;
 	}
 	c2_list_fini(&sys_cpus.pss_head);
-	processor_init = false;
+	c2_processor_init = false;
 }
 
 /**
@@ -1095,7 +1106,7 @@ void c2_processors_fini()
  */
 bool c2_processor_is_initialized(void)
 {
-	return processor_init;
+	return c2_processor_init;
 }
 
 /**
@@ -1104,7 +1115,7 @@ bool c2_processor_is_initialized(void)
  */
 c2_processor_nr_t c2_processor_nr_max(void)
 {
-	C2_ASSERT(c2_processor_is_initialized());
+	C2_ASSERT(c2_processor_is_initialized() == true);
 	return sys_cpus.pss_max;
 }
 
@@ -1118,9 +1129,9 @@ c2_processor_nr_t c2_processor_nr_max(void)
  */
 void c2_processors_possible(struct c2_bitmap *map)
 {
-	C2_ASSERT(c2_processor_is_initialized());
+	C2_ASSERT(c2_processor_is_initialized() == true);
 	C2_ASSERT(map != NULL);
-	processors_copy_c2bitmap(&sys_cpus.pss_poss_map, map);
+	c2_processors_copy_c2bitmap(&sys_cpus.pss_poss_map, map);
 }
 
 /**
@@ -1133,9 +1144,9 @@ void c2_processors_possible(struct c2_bitmap *map)
  */
 void c2_processors_available(struct c2_bitmap *map)
 {
-	C2_ASSERT(c2_processor_is_initialized());
+	C2_ASSERT(c2_processor_is_initialized() == true);
 	C2_ASSERT(map != NULL);
-	processors_copy_c2bitmap(&sys_cpus.pss_avail_map, map);
+	c2_processors_copy_c2bitmap(&sys_cpus.pss_avail_map, map);
 }
 
 /**
@@ -1149,9 +1160,9 @@ void c2_processors_available(struct c2_bitmap *map)
  */
 void c2_processors_online(struct c2_bitmap *map)
 {
-	C2_ASSERT(c2_processor_is_initialized());
+	C2_ASSERT(c2_processor_is_initialized() == true);
 	C2_ASSERT(map != NULL);
-	processors_copy_c2bitmap(&sys_cpus.pss_onln_map, map);
+	c2_processors_copy_c2bitmap(&sys_cpus.pss_onln_map, map);
 }
 
 /**
@@ -1179,7 +1190,7 @@ int c2_processor_describe(c2_processor_nr_t id,
 	struct c2_processor_node *pinfo;
 
 	C2_ASSERT(pd != NULL);
-	C2_ASSERT(c2_processor_is_initialized());
+	C2_ASSERT(c2_processor_is_initialized() == true);
 
 	c2_list_for_each_entry(&sys_cpus.pss_head, pinfo,
 			 struct c2_processor_node, pn_link) {
diff --git a/lib/user_space/rwlock.c b/lib/user_space/rwlock.c
index 434d847..a0d011a 100644
--- a/lib/user_space/rwlock.c
+++ b/lib/user_space/rwlock.c
@@ -14,7 +14,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Huang Hua <Hua_Huang@xyratex.com>
+ * Original author: Huang Hua
  * Original creation date: 12/02/2010
  */
 
diff --git a/lib/user_space/rwlock.h b/lib/user_space/rwlock.h
index 5d4e69c..d00cdc8 100644
--- a/lib/user_space/rwlock.h
+++ b/lib/user_space/rwlock.h
@@ -14,7 +14,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Huang Hua <Hua_Huang@xyratex.com>
+ * Original author: Huang Hua
  * Original creation date: 12/02/2010
  */
 
diff --git a/lib/user_space/semaphore.c b/lib/user_space/semaphore.c
index 7c469f7..4ce71c3 100644
--- a/lib/user_space/semaphore.c
+++ b/lib/user_space/semaphore.c
@@ -14,7 +14,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Nikita Danilov <Nikita_Danilov@xyratex.com>
+ * Original author: Nikita Danilov
  * Original creation date: 03/11/2011
  */
 
diff --git a/lib/user_space/semaphore.h b/lib/user_space/semaphore.h
index 4c6d4c4..99bbd26 100644
--- a/lib/user_space/semaphore.h
+++ b/lib/user_space/semaphore.h
@@ -14,7 +14,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Nikita Danilov <Nikita_Danilov@xyratex.com>
+ * Original author: Nikita Danilov
  * Original creation date: 03/11/2011
  */
 
diff --git a/lib/user_space/thread.h b/lib/user_space/thread.h
index 2cbbdd3..797de9f 100644
--- a/lib/user_space/thread.h
+++ b/lib/user_space/thread.h
@@ -14,7 +14,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Nikita Danilov <Nikita_Danilov@xyratex.com>
+ * Original author: Nikita Danilov
  * Original creation date: 02/18/2011
  */
 
diff --git a/lib/user_space/time.h b/lib/user_space/time.h
index 0f0d41b..6ffd4e7 100644
--- a/lib/user_space/time.h
+++ b/lib/user_space/time.h
@@ -14,7 +14,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Nathan Rutman <Nathan_Rutman@us.xyratex.com>
+ * Original author: Nathan Rutman
  * Original creation date: 12/08/2010
  */
 
diff --git a/lib/user_space/timer.h b/lib/user_space/timer.h
index 09952e6..e24ce56 100644
--- a/lib/user_space/timer.h
+++ b/lib/user_space/timer.h
@@ -14,43 +14,22 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Huang Hua <Hua_Huang@xyratex.com>
- *		    Maxim Medved <Max_Medved@xyratex.com>
+ * Original author: Huang Hua
  * Original creation date: 03/04/2011
  */
 
 #ifndef __COLIBRI_LIB_USER_SPACE_TIMER_H__
 #define __COLIBRI_LIB_USER_SPACE_TIMER_H__
 
-#include "lib/time.h"      /* c2_time_t */
-#include "lib/thread.h"    /* c2_thread */
-#include "lib/semaphore.h" /* c2_semaphore */
+#include "lib/time.h"
+#include "lib/thread.h"
 
 /**
    @addtogroup timer
 
    <b>User space timer.</b>
    @{
- */
-
-/**
-   Timer state.
-   @see timer_state_change()
- */
-enum c2_timer_state {
-	/** Not initialized. */
-	TIMER_UNINIT = 0,
-	/** Initialized. */
-	TIMER_INITED,
-	/** Timer is running. */
-	TIMER_RUNNING,
-	/** Timer is stopped */
-	TIMER_STOPPED,
-	/** Number of timer states */
-	TIMER_STATE_NR,
-	/** Invalid state */
-	TIMER_INVALID = TIMER_STATE_NR
-};
+*/
 
 struct c2_timer {
 	/**
@@ -59,65 +38,49 @@ struct c2_timer {
 	enum c2_timer_type t_type;
 
 	/**
-	   Timer triggers this callback.
+	   The interval to trigger the timer callback.
 	 */
-	c2_timer_callback_t t_callback;
+	c2_time_t t_interval;
 
 	/**
-	   User data.
-	 */
-	unsigned long t_data;
+	   the repeat count for this timer.
 
-	/**
-	   expire time in future of this timer.
+	   Initial value of 0XFFFFFFFFFFFFFFFF means the timer will be triggered
+	   infinitely before wrapping.
 	 */
-	c2_time_t t_expire;
+	uint64_t       t_repeat;
 
 	/**
-	   working thread for soft timer
-	 */
-	struct c2_thread t_thread;
+	   the left count for this timer.
 
-	/*
-	   semaphore for sleeping in c2_timer_working_thread().
+	   This value will be decreased everytime a timeout happens.
+	   If this value reaches zero, time is stopped/unarmed.
+	   The initial value of @t_left is equal to @t_repeat.
 	 */
-	struct c2_semaphore t_sleep_sem;
+	uint64_t       t_left;
 
 	/**
-	   Target thread ID for hard timer callback.
-	   Initially set in c2_timer_init() to callers TID.
-	   Can be changed by calling c2_timer_attach().
+	   Timer triggers this callback.
 	 */
-	pid_t t_tid;
+	c2_timer_callback_t t_callback;
 
 	/**
-	   Timer state.
-	   Used in state changes checking in hard timer.
-	   c2_timer_init() will set state to TIMER_INITED.
-	   c2_timer_fini()/start()/stop()/attach() will check current
-	   state using state transition matrix.
-	   If there is no transition from current state using given
-	   function, C2_ASSERT() will take `false' parameter.
+	   User data.
 	 */
-	enum c2_timer_state t_state;
+	unsigned long t_data;
 
 	/**
-	   Used in hard timer implementation.
-	   @see timer_hard_stop()
+	   expire time in future of this timer.
 	 */
-	struct c2_semaphore t_stop_sem;
+	c2_time_t t_expire;
 
 	/**
-	   POSIX timer ID, returned by timer_create().
-	   Used in hard timer implementation.
-	   POSIX timer is creating in c2_timer_init() and c2_timer_attach().
-	   POSIX timer is deleting in c2_timer_attach() and c2_timer_fini().
+	   working thread
 	 */
-	timer_t t_ptimer;
+	struct c2_thread t_thread;
 };
 
-int c2_timers_init();
-void c2_timers_fini();
+
 
 /** @} end of timer group */
 
diff --git a/lib/user_space/trace.h b/lib/user_space/trace.h
deleted file mode 100644
index 6869341..0000000
--- a/lib/user_space/trace.h
+++ /dev/null
@@ -1,46 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Andriy Tkachuk <Andriy_Tkachuk@xyratex.com>
- * Original creation date: 01/30/2012
- */
-
-#ifndef __COLIBRI_LIB_USERSP_TRACE_H__
-#define __COLIBRI_LIB_USERSP_TRACE_H__
-
-/**
-   @defgroup trace Tracing.
-
-   User-space specific declarations.
-
- */
-
-int  c2_trace_parse(void);
-
-/** @} end of trace group */
-
-/* __COLIBRI_LIB_USERSP_TRACE_H__ */
-#endif
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
diff --git a/lib/user_space/types.h b/lib/user_space/types.h
index ad19310..e8071ad 100644
--- a/lib/user_space/types.h
+++ b/lib/user_space/types.h
@@ -14,7 +14,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Nikita Danilov <Nikita_Danilov@xyratex.com>
+ * Original author: Nikita Danilov
  * Original creation date: 08/04/2010
  */
 
diff --git a/lib/user_space/user_x86_64_atomic.h b/lib/user_space/user_x86_64_atomic.h
index ea628d0..d58878d 100644
--- a/lib/user_space/user_x86_64_atomic.h
+++ b/lib/user_space/user_x86_64_atomic.h
@@ -14,7 +14,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Nikita Danilov <Nikita_Danilov@xyratex.com>
+ * Original author: Nikita Danilov
  * Original creation date: 08/04/2010
  */
 
@@ -157,25 +157,12 @@ PREFIX bool c2_atomic64_dec_and_test(struct c2_atomic64 *a)
 	return result != 0;
 }
 
-PREFIX bool c2_atomic64_cas(int64_t *loc, int64_t old, int64_t new)
-{
-	int64_t val;
-
-	C2_CASSERT(8 == sizeof old);
-
-	asm volatile("lock cmpxchgq %2,%1"
-		     : "=a" (val), "+m" (*(volatile long *)(loc))
-		     : "r" (new), "0" (old)
-		     : "memory");
-	return val == old;
-}
-
 /** @} end of atomic group */
 
 /* __COLIBRI_LIB_USER_X86_64_ATOMIC_H__ */
 #endif
 
-/*
+/* 
  *  Local variables:
  *  c-indentation-style: "K&R"
  *  c-basic-offset: 8
diff --git a/lib/user_space/uthread.c b/lib/user_space/uthread.c
index 7247caa..d02362b 100644
--- a/lib/user_space/uthread.c
+++ b/lib/user_space/uthread.c
@@ -14,8 +14,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Dave Cohrs <Dave_Cohrs@us.xyratex.com>,
- *                  Nikita Danilov <Nikita_Danilov@xyratex.com>
+ * Original author: Dave Cohrs, Nikita Danilov
  * Original creation date: 02/18/2011
  */
 
diff --git a/lib/user_space/utime.c b/lib/user_space/utime.c
index 246030a..93e2cd9 100644
--- a/lib/user_space/utime.c
+++ b/lib/user_space/utime.c
@@ -14,8 +14,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Nathan Rutman <Nathan_Rutman@us.xyratex.com>,
- *                  Huang Hua <Hua_Huang@xyratex.com>
+ * Original author: Nathan Rutman, Huang Hua
  * Original creation date: 01/27/2011
  */
 
@@ -34,17 +33,16 @@ extern int nanosleep(const struct timespec *req, struct timespec *rem);
    @{
 */
 
-c2_time_t c2_time_now(void)
+c2_time_t c2_time_now(c2_time_t *time)
 {
         struct timeval tv;
-	c2_time_t      t;
 
+        C2_PRE(time != NULL);
         /* We could use clock_gettime(CLOCK_REALTIME, time) for nanoseconds,
          but we would have to link librt... */
         gettimeofday(&tv, NULL);
-        c2_time_set(&t, tv.tv_sec, tv.tv_usec * 1000);
-
-        return t;
+        c2_time_set(time, tv.tv_sec, tv.tv_usec * 1000);
+	return *time;
 }
 C2_EXPORTED(c2_time_now);
 
diff --git a/lib/user_space/utrace.c b/lib/user_space/utrace.c
deleted file mode 100644
index dc56653..0000000
--- a/lib/user_space/utrace.c
+++ /dev/null
@@ -1,193 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Nikita Danilov <Nikita_Danilov@xyratex.com>
- * Original creation date: 08/12/2010
- */
-
-#include <string.h>   /* memset */
-#include <errno.h>
-#include <err.h>
-#include <stdio.h>
-#include <stdlib.h>   /* getenv, strtoul */
-#include <unistd.h>   /* getpagesize */
-#include <fcntl.h>    /* open, O_RDWR|O_CREAT|O_TRUNC */
-#include <sys/mman.h> /* mmap */
-
-#include "lib/arith.h"
-#include "lib/memory.h"
-#include "lib/trace.h"
-
-/**
-   @addtogroup trace
-
-   <b>User-space c2_trace_parse() implementation.</b>
-
-   @{
- */
-
-static int logfd;
-
-static const char sys_kern_randvspace_fname[] =
-	"/proc/sys/kernel/randomize_va_space";
-
-static int randvspace_check()
-{
-	int   val;
-	int   result;
-	FILE *f;
-
-	if ((f = fopen(sys_kern_randvspace_fname, "r")) == NULL) {
-		warn("open(\"%s\")", sys_kern_randvspace_fname);
-		result = -errno;
-	} else if (fscanf(f, "%d", &val) != 1) {
-		warnx("fscanf(\"%s\")", sys_kern_randvspace_fname);
-		result = -EINVAL;
-	} else if (val != 0) {
-		warnx("System configuration ERROR: "
-		      "kernel.randomize_va_space should be set to 0.");
-		result = -EINVAL;
-	} else
-		result = 0;
-
-	if (f != NULL)
-		fclose(f);
-
-	return result;
-}
-
-static int logbuf_map()
-{
-	char buf[80];
-
-	sprintf(buf, "c2.trace.%u", (unsigned)getpid());
-	if ((logfd = open(buf, O_RDWR|O_CREAT|O_TRUNC, 0700)) == -1)
-		warn("open(\"%s\")", buf);
-	else if ((errno = posix_fallocate(logfd, 0, c2_logbufsize)) != 0)
-		warn("fallocate(\"%s\", %u)", buf, c2_logbufsize);
-	else if ((c2_logbuf = mmap(NULL, c2_logbufsize, PROT_WRITE,
-                                   MAP_SHARED, logfd, 0)) == MAP_FAILED)
-		warn("mmap(\"%s\")", buf);
-	else
-		memset(c2_logbuf, 0, c2_logbufsize);
-
-	return -errno;
-}
-
-int c2_arch_trace_init()
-{
-	const char *mask;
-
-	mask = getenv("C2_TRACE_IMMEDIATE_MASK");
-	if (mask != NULL) {
-		char *endp;
-
-		c2_trace_immediate_mask = strtoul(mask, &endp, 0);
-		if (errno != 0 || *endp != 0) {
-			warn("strtoul(\"%s\"), setting mask to 0", mask);
-			c2_trace_immediate_mask = 0;
-		}
-	}
-	return randvspace_check() ?: logbuf_map();
-}
-
-void c2_arch_trace_fini(void)
-{
-	munmap(c2_logbuf, c2_logbufsize);
-	close(logfd);
-}
-
-
-static unsigned align(unsigned align, unsigned pos)
-{
-	C2_ASSERT(c2_is_po2(align));
-	while (!feof(stdin) && (pos & (align - 1))) {
-		getchar();
-		pos++;
-	}
-	return pos;
-}
-
-/**
- * Parse log buffer supplied at stdin.
- */
-int c2_trace_parse(void)
-{
-	struct c2_trace_rec_header   trh;
-	const struct c2_trace_descr *td;
-	unsigned                     pos = 0;
-	unsigned                     nr;
-	unsigned                     n2r;
-
-	printf("   no   |    tstamp     |   stack ptr    |"
-	       "        func        |        src        | sz|narg\n");
-	printf("------------------------------------------"
-	       "-------------------------------------------------\n");
-
-	while (!feof(stdin)) {
-		char *buf = NULL;
-
-		pos = align(8, pos); /* At the beginning of a record */
-
-		/* Find the complete record */
-		do {
-			nr = fread(&trh.trh_magic, 1, sizeof trh.trh_magic, stdin);
-			if (nr != sizeof trh.trh_magic) {
-				C2_ASSERT(feof(stdin));
-				return 0;
-			}
-			pos += nr;
-		} while (trh.trh_magic != C2_TRACE_MAGIC);
-
-		/* Now we might have complete record */
-		n2r = sizeof trh - sizeof trh.trh_magic;
-		nr = fread(&trh.trh_sp, 1, n2r, stdin);
-		C2_ASSERT(nr == n2r);
-		pos += nr;
-
-		td = trh.trh_descr;
-
-		buf = c2_alloc(td->td_size);
-		C2_ASSERT(buf != NULL);
-
-		nr = fread(buf, 1, td->td_size, stdin);
-		C2_ASSERT(nr == td->td_size);
-		pos += nr;
-
-		c2_trace_record_print(&trh, buf);
-
-		if (buf)
-			c2_free(buf);
-	}
-	return 0;
-}
-
-void c2_console_vprintf(const char *fmt, va_list args)
-{
-	vprintf(fmt, args);
-}
-
-/** @} end of trace group */
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
diff --git a/lib/ut.c b/lib/ut.c
index bac5121..9c2eb4f 100644
--- a/lib/ut.c
+++ b/lib/ut.c
@@ -13,23 +13,17 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Nikita Danilov <Nikita_Danilov@xyratex.com>
+ * Original author: Nikita Danilov
  * Original creation date: 07/09/2010
  */
 
 #include <CUnit/Basic.h>
 #include <CUnit/Automated.h>
-#include <CUnit/Console.h>
-#include <CUnit/TestDB.h>
-#include <CUnit/TestRun.h>
 
 #include <stdlib.h>                /* system */
 #include <stdio.h>                 /* asprintf */
-#include <unistd.h>                /* dup, dup2 */
 
-#include "lib/assert.h"            /* C2_ASSERT */
-#include "lib/thread.h"            /* LAMBDA */
-#include "lib/memory.h"            /* c2_allocated */
+#include "lib/assert.h"
 #include "lib/ut.h"
 
 /**
@@ -67,182 +61,19 @@ void c2_ut_add(const struct c2_test_suite *ts)
 	C2_ASSERT(ts->ts_tests[i].t_name == NULL);
 }
 
-typedef void (*ut_suite_action_t)(CU_pSuite);
-typedef void (*ut_test_action_t)(CU_pSuite, CU_pTest);
-
-static void ut_traverse_test_list(struct c2_list *list, ut_suite_action_t sa,
-				  ut_test_action_t ta)
-{
-	struct c2_test_suite_entry *te;
-
-	c2_list_for_each_entry(list, te, struct c2_test_suite_entry, tse_linkage) {
-		CU_pTestRegistry r;
-		CU_pSuite s;
-		CU_pTest t;
-
-		r = CU_get_registry();
-		s = CU_get_suite_by_name(te->tse_suite_name, r);
-
-		if (s == NULL) {
-			fprintf(stderr, "Error: test suite '%s' not found\n",
-					te->tse_suite_name);
-			exit(EXIT_FAILURE);
-		}
-
-		if (te->tse_test_name != NULL) {
-			t = CU_get_test_by_name(te->tse_test_name, s);
-			if (t == NULL) {
-				fprintf(stderr, "Error: test '%s:%s' not found\n",
-						te->tse_suite_name,
-						te->tse_test_name);
-				exit(EXIT_FAILURE);
-			}
-			ta(s, t);
-		} else {
-			sa(s);
-		}
-	}
-}
-
-static void ut_run_basic_mode(struct c2_list *test_list,
-	       struct c2_list *exclude_list)
+void c2_ut_run(const char *log_file)
 {
-	if (c2_list_is_empty(test_list)) {
-		/* run all tests, except those, which present in exclude_list */
-		if (!c2_list_is_empty(exclude_list)) {
-			ut_suite_action_t sa = LAMBDA(void, (CU_pSuite s) {
-							s->fActive = CU_FALSE;
-						});
-			ut_test_action_t ta = LAMBDA(void,
-						     (CU_pSuite s, CU_pTest t) {
-							t->fActive = CU_FALSE;
-						});
-			ut_traverse_test_list(exclude_list, sa, ta);
-		}
-		CU_basic_run_tests();
-	} else {
-		/*
-		 * run only selected tests, which present in test_list,
-		 * ignore exclude_list
-		 */
-		ut_suite_action_t sa = LAMBDA(void, (CU_pSuite s) {
-					CU_basic_run_suite(s);
-				});
-		ut_test_action_t ta = LAMBDA(void, (CU_pSuite s, CU_pTest t) {
-					CU_basic_run_test(s, t);
-				});
-		ut_traverse_test_list(test_list, sa, ta);
-	}
+	CU_set_output_filename(log_file);
 
+	/* run in make console output */
+	CU_basic_set_mode(CU_BRM_VERBOSE);
+	CU_basic_run_tests();
 	CU_basic_show_failures(CU_get_failure_list());
-}
-
-static size_t used_mem_before_suite;
-
-static void ut_suite_start_cbk(const CU_pSuite pSuite)
-{
-	used_mem_before_suite = c2_allocated();
-}
-
-static void ut_suite_stop_cbk(const CU_pSuite pSuite,
-			      const CU_pFailureRecord pFailure)
-{
-	size_t used_mem_after_suite = c2_allocated();
-	int    leaked_bytes = used_mem_after_suite - used_mem_before_suite;
-	float  leaked;
-	char   *units;
-	char   *notice = "";
-	int    sign = +1;
-
-	if (leaked_bytes < 0) {
-		leaked_bytes *= -1; /* make it positive */
-		sign = -1;
-		notice = "NOTICE: freed more memory than allocated!";
-	}
-
-	if (leaked_bytes / 1024 / 1024 ) { /* > 1 megabyte */
-		leaked = leaked_bytes / 1024.0 / 1024.0;
-		units = "MB";
-	} else if (leaked_bytes / 1024) {  /* > 1 kilobyte */
-		leaked = leaked_bytes / 1024.0;
-		units = "KB";
-	} else {
-		leaked = leaked_bytes;
-		units = "B";
-	}
-
-	printf("\n  Leaked: %.2f %s  %s", sign * leaked, units, notice);
-}
-
-static void ut_set_suite_start_stop_cbk(void)
-{
-	CU_set_suite_start_handler(ut_suite_start_cbk);
-	CU_set_suite_complete_handler(ut_suite_stop_cbk);
-}
-
-void c2_ut_run(struct c2_ut_run_cfg *c)
-{
-	ut_set_suite_start_stop_cbk();
 
-	if (c->urc_report_exec_time)
-		CU_basic_set_mode(CU_BRM_VERBOSE_TIME);
-	else
-		CU_basic_set_mode(CU_BRM_VERBOSE);
-
-	if (c->urc_abort_cu_assert)
-		CU_set_assert_mode(CUA_Abort);
-
-	if (c->urc_mode == C2_UT_AUTOMATED_MODE) {
-		/* run and save results to xml */
-
-		/*
-		 * CUnit uses the name we provide as a prefix for log files.
-		 * The actual log file names are PREFIX-Listing.xml and
-		 * PREFIX-Results.xml, where PREFIX is what we pass to
-		 * CU_set_output_filename().
-		 *
-		 * Because we run in the sandbox directory, which is removed by
-		 * default after test execution, we need to prepend '../' to the
-		 * filename, in order to store it outside of sandbox. */
-		CU_set_output_filename("../C2UT");
-
-		CU_list_tests_to_file();
-		CU_automated_run_tests();
-	} else {
-		/* run and make console output */
-		if (c->urc_mode == C2_UT_BASIC_MODE) {
-			ut_run_basic_mode(c->urc_test_list, c->urc_exclude_list);
-		} else if (c->urc_mode == C2_UT_ICONSOLE_MODE) {
-			CU_console_run_tests();
-		}
-	}
-}
-
-void c2_ut_list(bool with_tests)
-{
-	CU_pTestRegistry registry;
-	CU_pSuite        suite;
-	CU_pTest         test;
-
-	registry = CU_get_registry();
-	C2_ASSERT(registry != NULL);
-
-	if (registry->uiNumberOfSuites == 0) {
-		fprintf(stderr, "\n%s\n", "No test suites are registered.");
-		return;
-	}
-
-	printf("# YAML\n");
-	printf("---\n");
-
-	for (suite = registry->pSuite; suite != NULL; suite = suite->pNext)
-		if (with_tests && suite->uiNumberOfTests != 0) {
-			printf("%s:\n", suite->pName);
-			for (test = suite->pTest ; test != NULL; test = test->pNext)
-				printf("    - %s\n", test->pName);
-		} else {
-			printf("%s\n", suite->pName);
-		}
+#if 0
+	/* run and save results to xml */
+	CU_automated_run_tests();
+#endif
 }
 
 int c2_ut_db_reset(const char *db_name)
@@ -258,68 +89,6 @@ int c2_ut_db_reset(const char *db_name)
 	return rc;
 }
 
-void c2_stream_redirect(FILE *stream, const char *path,
-			struct c2_ut_redirect *redir)
-{
-	FILE *result;
-
-	/*
-	 * This solution is based on the method described in the comp.lang.c
-	 * FAQ list, Question 12.34: "Once I've used freopen, how can I get the
-	 * original stdout (or stdin) back?"
-	 *
-	 * http://c-faq.com/stdio/undofreopen.html
-	 * http://c-faq.com/stdio/rd.kirby.c
-	 *
-	 * It's not portable and will only work on systems which support dup(2)
-	 * and dup2(2) system calls (these are supported in Linux).
-	 */
-	redir->ur_stream = stream;
-	fflush(stream);
-	fgetpos(stream, &redir->ur_pos);
-	redir->ur_oldfd = fileno(stream);
-	redir->ur_fd = dup(redir->ur_oldfd);
-	C2_ASSERT(redir->ur_fd != -1);
-	result = freopen(path, "a+", stream);
-	C2_ASSERT(result != NULL);
-}
-
-void c2_stream_restore(const struct c2_ut_redirect *redir)
-{
-	int result;
-
-	/*
-	 * see comment in c2_stream_redirect() for detailed information
-	 * about how to redirect and restore standard streams
-	 */
-	fflush(redir->ur_stream);
-	result = dup2(redir->ur_fd, redir->ur_oldfd);
-	C2_ASSERT(result != -1);
-	close(redir->ur_fd);
-	clearerr(redir->ur_stream);
-	fsetpos(redir->ur_stream, &redir->ur_pos);
-}
-
-bool c2_error_mesg_match(FILE *fp, const char *mesg)
-{
-	enum {
-		MAXLINE = 1025,
-	};
-
-	char line[MAXLINE];
-
-	C2_PRE(fp != NULL);
-	C2_PRE(mesg != NULL);
-
-	fseek(fp, 0L, SEEK_SET);
-	memset(line, '\0', MAXLINE);
-	while (fgets(line, MAXLINE, fp) != NULL) {
-		if (strncmp(mesg, line, strlen(mesg)) == 0)
-			return true;
-	}
-	return false;
-}
-
 /** @} end of ut group. */
 
 /*
diff --git a/lib/ut.h b/lib/ut.h
index ba977ea..8fa0aa6 100644
--- a/lib/ut.h
+++ b/lib/ut.h
@@ -13,7 +13,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Nikita Danilov <Nikita_Danilov@xyratex.com>
+ * Original author: Nikita Danilov
  * Original creation date: 07/09/2010
  */
 
@@ -21,15 +21,11 @@
 #define __COLIBRI_LIB_UT_H_
 
 #ifndef __KERNEL__
-# include <stdbool.h>     /* bool */
-# include <stdio.h>       /* FILE, fpos_t */
 # include <CUnit/Basic.h>
 #else
 # include "lib/types.h"
 #endif
 
-#include "lib/list.h" /* c2_list_link, c2_list */
-
 /**
    @defgroup ut Unit testing.
 
@@ -69,18 +65,10 @@ struct c2_test_suite {
 	const char           *ts_name;
 	/**
 	   function to prepare tests in suite
-
-	   @warning it's not allowed to use any of CUnit assertion macros, like
-		    CU_ASSERT or C2_UT_ASSERT, in this function because it will
-		    lead to a crash; use C2_ASSERT instead if required.
 	 */
 	int                 (*ts_init)(void);
 	/**
 	   function to free resources after tests run
-
-	   @warning it's not allowed to use any of CUnit assertion macros, like
-		    CU_ASSERT or C2_UT_ASSERT, in this function because it will
-		    lead to a crash; use C2_ASSERT instead if required.
 	 */
 	int                 (*ts_fini)(void);
 	/**
@@ -89,12 +77,6 @@ struct c2_test_suite {
 	const struct c2_test  ts_tests[];
 };
 
-struct c2_test_suite_entry {
-	struct c2_list_link  tse_linkage;
-	const char           *tse_suite_name;
-	const char           *tse_test_name;
-};
-
 /**
    Global constructor for unit tests.
  */
@@ -115,52 +97,13 @@ void c2_uts_fini(void);
 void c2_ut_add(const struct c2_test_suite *ts);
 
 /**
-   CUnit user interfaces
- */
-enum c2_ut_run_mode {
-	C2_UT_KERNEL_MODE,    /** A stub for kernel version of c2_ut_run() */
-	C2_UT_BASIC_MODE,     /** Basic CUnit interface with console output */
-	C2_UT_ICONSOLE_MODE,  /** Interactive CUnit console interface */
-	C2_UT_AUTOMATED_MODE, /** Automated CUnit interface with xml output */
-};
-
-/**
-   Configuration parameters for c2_ut_run()
- */
-struct c2_ut_run_cfg {
-	/** CUnit interface mode */
-	enum c2_ut_run_mode  urc_mode;
-	/** if true, then set CUnit's assert mode to CUA_Abort */
-	bool                 urc_abort_cu_assert;
-	/** if true, then execution time is reported for each test */
-	bool                 urc_report_exec_time;
-	/**
-	 * list of tests/suites to run, it can be empty, which means to run
-	 * all the tests
-	 */
-	struct c2_list       *urc_test_list;
-	/** list of tests/suites to exclude from running, it also can be empty */
-	struct c2_list       *urc_exclude_list;
-};
+ run tests and write log into file
 
-#ifndef __KERNEL__
-/**
-   run tests
- */
-void c2_ut_run(struct c2_ut_run_cfg *c);
-#else
-void c2_ut_run(void);
-#endif
-
-/**
- print all available test suites in YAML format to STDOUT
-
- @param with_tests - if true, then all tests of each suite are printed in
-                     addition
+ @param log_file - name of file to a write testing log
 
  @return NONE
  */
-void c2_ut_list(bool with_tests);
+void c2_ut_run(const char *log_file);
 
 /**
  commonly used test database reset function
@@ -180,36 +123,6 @@ int c2_ut_db_reset(const char *db_name);
 bool c2_ut_assertimpl(bool c, int lno, const char *str_c, const char *file);
 #endif
 
-#ifndef __KERNEL__
-struct c2_ut_redirect {
-	FILE  *ur_stream;
-	int    ur_oldfd;
-	int    ur_fd;
-	fpos_t ur_pos;
-};
-
-/**
- * Associates one of the standard streams (stdin, stdout, stderr) with a file
- * pointed by 'path' argument.
- */
-void c2_stream_redirect(FILE *stream, const char *path,
-			struct c2_ut_redirect *redir);
-
-/**
- * Restores standard stream from file descriptor and stream position, which were
- * saved earlier by c2_stream_redirect().
- */
-void c2_stream_restore(const struct c2_ut_redirect *redir);
-
-/**
- * Checks if a text file contains the specified string.
- *
- * @param fp   - a file, which is searched for a string
- * @param mesg - a string to search for
- */
-bool c2_error_mesg_match(FILE *fp, const char *mesg);
-#endif
-
 /** @} end of ut group. */
 
 /* __COLIBRI_LIB_UT_H_ */
diff --git a/lib/ut/Makefile.am b/lib/ut/Makefile.am
index fc2f4d4..eea0e95 100644
--- a/lib/ut/Makefile.am
+++ b/lib/ut/Makefile.am
@@ -1,22 +1,5 @@
 noinst_LTLIBRARIES   = libc2-ut.la
-libc2_ut_la_SOURCES  = main.c \
-                       \
-                       atomic.c \
-                       bitmap.c \
-                       bob.c \
-                       chan.c \
-                       getopts.c \
-                       list.c \
-                       memory.c \
-                       mutex.c \
-                       processor.c \
-                       queue.c \
-                       refs.c \
-                       rwlock.c \
-                       thread.c \
-                       time.c \
-                       timer.c \
-                       tlist.c \
-                       trace.c \
-                       vec.c \
-                       zerovec.c
+libc2_ut_la_SOURCES  = main.c list.c memory.c refs.c queue.c \
+                       vec.c thread.c mutex.c chan.c atomic.c \
+                       trace.c getopts.c time.c timer.c bitmap.c \
+                       processor.c rwlock.c
diff --git a/lib/ut/atomic.c b/lib/ut/atomic.c
index 8a59592..a4d7ea9 100644
--- a/lib/ut/atomic.c
+++ b/lib/ut/atomic.c
@@ -14,7 +14,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Nikita Danilov <Nikita_Danilov@xyratex.com>
+ * Original author: Nikita Danilov
  * Original creation date: 05/23/2010
  */
 
@@ -35,7 +35,7 @@
 
 #ifdef HAVE_PTHREAD_BARRIER_T
 enum {
-	NR = 64
+	NR = 255
 };
 
 static struct c2_atomic64 atom;
@@ -62,7 +62,7 @@ static void worker(int id)
 		wait(&let[i]);
 		for (j = 0; j < 2; ++j) {
 			for (k = 0; k < NR; ++k) {
-				if ((id + i + j) % 2 == 0)
+				if ((id + i + j) % 2 == 0) 
 					c2_atomic64_sub(&atom, id);
 				else
 					c2_atomic64_add(&atom, id);
@@ -75,80 +75,16 @@ static void worker(int id)
 		C2_UT_ASSERT(c2_atomic64_get(&atom) == 0);
 	}
 }
-
-struct el {
-	struct el *next;
-	int        datum;
-};
-
-static struct el *list;
-
-static void cas_insert(struct el *e)
-{
-	do
-		e->next = list;
-	while (!C2_ATOMIC64_CAS(&list, e->next, e));
-}
-
-static void cas_delete(void)
-{
-	struct el *e;
-
-	do
-		e = list;
-	while (!C2_ATOMIC64_CAS(&list, e, e->next));
-}
-
-static void breset(pthread_barrier_t *b, int n)
-{
-	int result;
-
-	result = pthread_barrier_destroy(b);
-	C2_UT_ASSERT(result == 0);
-	result = pthread_barrier_init(b, NULL, n);
-	C2_UT_ASSERT(result == 0);
-}
-
-static void cas(int id)
-{
-	int i;
-	int j;
-
-	struct el e = {
-		.next  = NULL,
-		.datum = id
-	};
-	struct el d[NR];
-
-	wait(&bar[0]);
-	/* and all together now: non-blocking list insertion. */
-	for (i = 0; i < NR; ++i) {
-		cas_insert(&e);
-		wait(&bar[1]);
-		wait(&bar[2]);
-	}
-	for (i = 0; i < NR; ++i) {
-		for (j = 0; j < NR; ++j)
-			cas_insert(&d[j]);
-		for (j = 0; j < NR; ++j)
-			cas_delete();
-		wait(&bar[3]);
-		wait(&bar[4]);
-	}
-}
 #endif
 
 void test_atomic(void)
 {
 #ifdef HAVE_PTHREAD_BARRIER_T
-	int               i;
-	int               j;
-	int               result;
-	uint64_t          sum;
-	uint64_t          sum1;
-	bool              zero;
-	struct c2_thread  t[NR];
-	struct el        *e;
+	int              i;
+	int              result;
+	uint64_t         sum;
+	bool             zero;
+	struct c2_thread t[NR];
 
 	C2_SET_ARR0(t);
 	c2_atomic64_set(&atom, 0);
@@ -189,73 +125,18 @@ void test_atomic(void)
 		c2_thread_fini(&t[i]);
 	}
 
-	/*
-	 * c2_atomic64_cas() test.
-	 */
-
-	C2_CASSERT(ARRAY_SIZE(bar) > 5);
-
-	/* bar[0] is reached when all cas() threads are created. */
-	breset(&bar[0], NR);
-	/* bar[1] is reached when every cas() thread insert its element in the
-	   global lock-free linked list. */
-	breset(&bar[1], NR + 1);
-	/* bar[2] is reached when main thread checked that the list is correct
-	   after the previous concurrent step and reset the list to NULL. */
-	breset(&bar[2], NR + 1);
-	/* bar[3] is reached after every cas() step inserted NR elements in the
-	   global lock-free list and then removed NR entries from it. */
-	breset(&bar[3], NR + 1);
-	/* bar[4] is reached after main thread checked that the list is empty
-	   after the previous step. */
-	breset(&bar[4], NR + 1);
-
-	for (i = 0; i < ARRAY_SIZE(t); ++i) {
-		result = C2_THREAD_INIT(&t[i], int, NULL, &cas, i, "cas");
-		C2_UT_ASSERT(result == 0);
-	}
-
-	for (j = 0; j < NR; ++j) {
-		wait(&bar[1]);
-		breset(&bar[1], NR + 1);
-
-		/* all threads inserted their identifiers in the list, check. */
-		for (i = 0, sum1 = 0, e = list; i < NR; ++i, e = e->next) {
-			C2_UT_ASSERT(e != NULL);
-			C2_UT_ASSERT(0 <= e->datum && e->datum < NR);
-			sum1 += e->datum;
-		}
-		C2_UT_ASSERT(sum == sum1);
-		list = NULL;
-		wait(&bar[2]);
-		breset(&bar[2], NR + 1);
-	}
-	for (j = 0; j < NR; ++j) {
-		wait(&bar[3]);
-		breset(&bar[3], NR + 1);
-		C2_UT_ASSERT(list == NULL);
-		wait(&bar[4]);
-		breset(&bar[4], NR + 1);
-	}
-
 	for (i = 0; i < ARRAY_SIZE(bar); ++i) {
 		result = pthread_barrier_destroy(&bar[i]);
 		C2_UT_ASSERT(result == 0);
 		result = pthread_barrier_destroy(&let[i]);
 		C2_UT_ASSERT(result == 0);
 	}
-
-	for (i = 0; i < ARRAY_SIZE(t); ++i) {
-		c2_thread_join(&t[i]);
-		c2_thread_fini(&t[i]);
-	}
 #else
         C2_UT_ASSERT("pthread barriers are not supported!" == NULL);
 #endif
-
 }
 
-/*
+/* 
  *  Local variables:
  *  c-indentation-style: "K&R"
  *  c-basic-offset: 8
diff --git a/lib/ut/bitmap.c b/lib/ut/bitmap.c
index a6e0de5..45eeec2 100644
--- a/lib/ut/bitmap.c
+++ b/lib/ut/bitmap.c
@@ -14,7 +14,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Dave Cohrs <Dave_Cohrs@us.xyratex.com>
+ * Original author: Dave Cohrs
  * Original creation date: 02/28/2011
  */
 
@@ -27,36 +27,6 @@ enum {
 	UT_BITMAP_SIZE = 120
 };
 
-static void test_bitmap_copy(void)
-{
-	struct c2_bitmap src;
-	struct c2_bitmap dst;
-	size_t dst_nr;
-	size_t i;
-	int n;
-
-	C2_UT_ASSERT(c2_bitmap_init(&src, UT_BITMAP_SIZE) == 0);
-	for (i = 0; i < UT_BITMAP_SIZE; i += 3)
-		c2_bitmap_set(&src, i, true);
-
-	for (n = 1; n < 3; ++n) {
-		/* n == 1: equal sized, n == 2: dst size is bigger */
-		dst_nr = n * UT_BITMAP_SIZE;
-		C2_UT_ASSERT(c2_bitmap_init(&dst, dst_nr) == 0);
-		for (i = 1; i < dst_nr; i += 2)
-			c2_bitmap_set(&dst, i, true);
-
-		c2_bitmap_copy(&dst, &src);
-		for (i = 0; i < UT_BITMAP_SIZE; ++i)
-			C2_UT_ASSERT(c2_bitmap_get(&src, i) ==
-				     c2_bitmap_get(&dst, i));
-		for (; i < dst_nr; ++i)
-			C2_UT_ASSERT(!c2_bitmap_get(&dst, i));
-		c2_bitmap_fini(&dst);
-	}
-	c2_bitmap_fini(&src);
-}
-
 void test_bitmap(void)
 {
 	struct c2_bitmap bm;
@@ -110,8 +80,6 @@ void test_bitmap(void)
 	C2_UT_ASSERT(bm.b_nr == 0);
 	C2_UT_ASSERT(bm.b_words != NULL);
 	c2_bitmap_fini(&bm);
-
-	test_bitmap_copy();
 }
 
 enum {
diff --git a/lib/ut/bob.c b/lib/ut/bob.c
deleted file mode 100644
index f7d610a..0000000
--- a/lib/ut/bob.c
+++ /dev/null
@@ -1,135 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Nikita Danilov <Nikita_Danilov@xyratex.com>
- * Original creation date: 09/09/2010
- */
-
-#include "lib/ub.h"
-#include "lib/ut.h"
-#include "lib/tlist.h"
-#include "lib/bob.h"
-
-enum {
-	N = 256
-};
-
-struct foo {
-	void           *f_payload;
-	struct c2_tlink f_linkage;
-	char            f_x[7];
-	uint64_t        f_magix;
-};
-
-enum {
-	magix = 0xbeda551edcaca0ffULL
-};
-
-C2_TL_DESCR_DEFINE(foo, "foo-s", static, struct foo, f_linkage,
-		   f_magix, magix, 0);
-C2_TL_DEFINE(foo, static, struct foo);
-
-static struct c2_bob_type foo_bob;
-static struct foo F;
-static struct foo rank[N];
-
-C2_BOB_DEFINE(static, &foo_bob, foo);
-
-static void test_tlist_init(void)
-{
-	c2_bob_type_tlist_init(&foo_bob, &foo_tl);
-	C2_UT_ASSERT(!strcmp(foo_bob.bt_name, foo_tl.td_name));
-	C2_UT_ASSERT(foo_bob.bt_magix == magix);
-	C2_UT_ASSERT(foo_bob.bt_magix_offset == foo_tl.td_link_magic_offset);
-}
-
-static void test_bob_init(void)
-{
-	foo_bob_init(&F);
-	C2_UT_ASSERT(F.f_magix == magix);
-	C2_UT_ASSERT(foo_bob_check(&F));
-}
-
-static void test_bob_fini(void)
-{
-	foo_bob_fini(&F);
-	C2_UT_ASSERT(F.f_magix == 0);
-	C2_UT_ASSERT(!foo_bob_check(&F));
-}
-
-static void test_tlink_init(void)
-{
-	foo_tlink_init(&F);
-	C2_UT_ASSERT(foo_bob_check(&F));
-}
-
-static void test_tlink_fini(void)
-{
-	foo_tlink_fini(&F);
-	C2_UT_ASSERT(foo_bob_check(&F));
-	F.f_magix = 0;
-	C2_UT_ASSERT(!foo_bob_check(&F));
-}
-
-static bool foo_check(const void *bob)
-{
-	const struct foo *f = bob;
-
-	return f->f_payload == f + 1;
-}
-
-static void test_check(void)
-{
-	int i;
-
-	foo_bob.bt_check = &foo_check;
-
-	for (i = 0; i < N; ++i) {
-		foo_bob_init(&rank[i]);
-		rank[i].f_payload = rank + i + 1;
-	}
-
-	for (i = 0; i < N; ++i)
-		C2_UT_ASSERT(foo_bob_check(&rank[i]));
-
-	for (i = 0; i < N; ++i)
-		foo_bob_fini(&rank[i]);
-
-	for (i = 0; i < N; ++i)
-		C2_UT_ASSERT(!foo_bob_check(&rank[i]));
-
-}
-
-void test_bob(void)
-{
-	test_tlist_init();
-	test_bob_init();
-	test_bob_fini();
-	test_tlink_init();
-	test_tlink_fini();
-	test_check();
-}
-C2_EXPORTED(test_bob);
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
diff --git a/lib/ut/chan.c b/lib/ut/chan.c
index 4d09e8d..760cfe0 100644
--- a/lib/ut/chan.c
+++ b/lib/ut/chan.c
@@ -14,7 +14,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Nikita Danilov <Nikita_Danilov@xyratex.com>
+ * Original author: Nikita Danilov
  * Original creation date: 05/13/2010
  */
 
@@ -52,35 +52,20 @@ static void t0(int self)
 
 static int flag;
 
-static bool cb1(struct c2_clink *clink)
+static void cb1(struct c2_clink *clink)
 {
 	flag += 1;
-	return false;
 }
 
-static bool cb2(struct c2_clink *clink)
+static void cb2(struct c2_clink *clink)
 {
 	flag += 2;
-	return false;
-}
-
-static bool cb_filter(struct c2_clink *clink)
-{
-	return flag == 1;
-}
-
-static bool mfilter(struct c2_clink *clink)
-{
-	C2_UT_ASSERT(flag == 0);
-
-	flag = 1;
-	return false;
 }
 
 unsigned long signal_the_chan_in_timer(unsigned long data)
 {
-	struct c2_clink *clink = (struct c2_clink *)data;
-	c2_clink_signal(clink);
+	struct c2_chan *chan = (struct c2_chan *)data;
+	c2_chan_signal(chan);
 	return 0;
 }
 
@@ -89,12 +74,11 @@ void test_chan(void)
 	struct c2_chan  chan;
 	struct c2_clink clink1;
 	struct c2_clink clink2;
-	struct c2_clink clink3;
+	c2_time_t       now;
 	c2_time_t       delta;
 	c2_time_t       expire;
 	struct c2_timer timer;
 	int i;
-	int j;
 	bool got;
 
 	c2_chan_init(&chan);
@@ -147,35 +131,31 @@ void test_chan(void)
 	c2_chan_signal(&chan);
 	c2_chan_wait(&clink1);
 
-	/* wait will expire after 1/5 second */
-	c2_time_set(&delta, 0, C2_TIME_ONE_BILLION/5);
-	expire = c2_time_add(c2_time_now(), delta);
-	got = c2_chan_timedwait(&clink1, expire); /* wait 1/5 second */
+	/* wait will expire after 2 seconds */
+	c2_time_set(&delta, 2, 0);
+	expire = c2_time_add(c2_time_now(&now), delta);
+	got = c2_chan_timedwait(&clink1, expire); /* wait 2 seconds */
 	C2_UT_ASSERT(!got);
 
-	/* chan is signaled after 1/10 second. so the wait will return true */
-	c2_time_set(&delta, 0, C2_TIME_ONE_BILLION/10);
-	expire = c2_time_add(c2_time_now(), delta);
-	c2_timer_init(&timer, C2_TIMER_SOFT, expire,
-		      &signal_the_chan_in_timer, (unsigned long)&clink1);
+	/* chan is signaled after 1 second. so the wait will return true */
+	c2_time_set(&expire, 1, 0);
+	c2_timer_init(&timer, C2_TIMER_SOFT, expire, 1,
+		      &signal_the_chan_in_timer, (unsigned long)&chan);
 	c2_timer_start(&timer);
-	c2_time_set(&delta, 0, C2_TIME_ONE_BILLION/5);
-	expire = c2_time_add(c2_time_now(), delta);
-	got = c2_chan_timedwait(&clink1, expire); /* wait 1/5 seconds */
+	expire = c2_time_add(c2_time_now(&now), delta);
+	got = c2_chan_timedwait(&clink1, expire); /* wait 2 seconds */
 	C2_UT_ASSERT(got);
 	c2_timer_stop(&timer);
 	c2_timer_fini(&timer);
 
-	/* chan is signaled after 1/3 seconds. so the wait will timeout and
+	/* chan is signaled after 3 seconds. so the wait will timeout and
 	   return false. Another wait should work.*/
-	c2_time_set(&delta, 0, C2_TIME_ONE_BILLION/3);
-	expire = c2_time_add(c2_time_now(), delta);
-	c2_timer_init(&timer, C2_TIMER_SOFT, expire,
-		      &signal_the_chan_in_timer, (unsigned long)&clink1);
+	c2_time_set(&expire, 3, 0);
+	c2_timer_init(&timer, C2_TIMER_SOFT, expire, 1,
+		      &signal_the_chan_in_timer, (unsigned long)&chan);
 	c2_timer_start(&timer);
-	c2_time_set(&delta, 0, C2_TIME_ONE_BILLION/5);
-	expire = c2_time_add(c2_time_now(), delta);
-	got = c2_chan_timedwait(&clink1, expire); /* wait 1/5 seconds */
+	expire = c2_time_add(c2_time_now(&now), delta);
+	got = c2_chan_timedwait(&clink1, expire); /* wait 2 seconds */
 	C2_UT_ASSERT(!got);
 	c2_chan_wait(&clink1); /* another wait. Timer will signal in 1 second */
 	c2_timer_stop(&timer);
@@ -184,23 +164,6 @@ void test_chan(void)
 	c2_clink_del(&clink1);
 	c2_clink_fini(&clink1);
 
-	/* test filtered events. */
-	c2_clink_init(&clink3, &cb_filter);
-	c2_clink_add(&chan, &clink3);
-
-	flag = 1;
-	c2_chan_signal(&chan);
-	got = c2_chan_trywait(&clink3);
-	C2_UT_ASSERT(!got);
-
-	flag = 0;
-	c2_chan_signal(&chan);
-	got = c2_chan_trywait(&clink3);
-	C2_UT_ASSERT(got);
-
-	c2_clink_del(&clink3);
-	c2_clink_fini(&clink3);
-
 	c2_chan_fini(&chan);
 
 	/* multi-threaded test */
@@ -226,51 +189,6 @@ void test_chan(void)
 		c2_clink_fini(&l[i]);
 		c2_chan_fini(&c[i]);
 	}
-
-	/*
-	 * multi-channel test
-	 *
-	 * NR clinks are arranged in a group, with c[0] as a head. Each clink is
-	 * added to the corresponding channel.
-	 *
-	 * j-th channel is signalled and the signal is awaited for on the (j+1)
-	 * (in cyclic order) channel.
-	 *
-	 * mfilter() attached to j-th channel to check filtering for groups.
-	 */
-
-	for (j = 0; j < ARRAY_SIZE(c); ++j) {
-		for (i = 0; i < ARRAY_SIZE(c); ++i)
-			c2_chan_init(&c[i]);
-
-		c2_clink_init(&l[0], j == 0 ? mfilter : NULL);
-		for (i = 1; i < ARRAY_SIZE(c); ++i)
-			c2_clink_attach(&l[i], &l[0], j == i ? mfilter : NULL);
-
-		for (i = 0; i < ARRAY_SIZE(c); ++i)
-			c2_clink_add(&c[i], &l[i]);
-
-		c2_time_set(&delta, 0, C2_TIME_ONE_BILLION/100);
-		expire = c2_time_add(c2_time_now(), delta);
-
-		flag = 0;
-		c2_timer_init(&timer, C2_TIMER_SOFT, expire,
-			      &signal_the_chan_in_timer, (unsigned long)&l[j]);
-		c2_timer_start(&timer);
-
-		c2_chan_wait(&l[(j + 1) % ARRAY_SIZE(c)]);
-		C2_UT_ASSERT(flag == 1);
-
-		c2_timer_stop(&timer);
-		c2_timer_fini(&timer);
-
-		for (i = ARRAY_SIZE(c) - 1; i >= 0; --i) {
-			c2_clink_del(&l[i]);
-			c2_clink_fini(&l[i]);
-			c2_chan_fini(&c[i]);
-		}
-	}
-
 }
 C2_EXPORTED(test_chan);
 
diff --git a/lib/ut/getopts.c b/lib/ut/getopts.c
index 94dd37d..e64cdc9 100644
--- a/lib/ut/getopts.c
+++ b/lib/ut/getopts.c
@@ -14,7 +14,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Nikita Danilov <Nikita_Danilov@xyratex.com>
+ * Original author: Nikita Danilov
  * Original creation date: 10/04/2010
  */
 
@@ -36,29 +36,26 @@ void test_getopts(void)
 		"-n", "010",
 		NULL
 	};
-	struct c2_ut_redirect redir;
 
 	argc = ARRAY_SIZE(argv) - 1;
 
-	c2_stream_redirect(stderr, "/dev/null", &redir);
 	result = C2_GETOPTS("getopts-ut", argc, argv);
 	C2_UT_ASSERT(result == -EINVAL);
-	c2_stream_restore(&redir);
 
 	e = false;
-	result = C2_GETOPTS("getopts-ut", argc, argv,
+	result = C2_GETOPTS("getopts-ut", argc, argv, 
 			    C2_FORMATARG('n', "Num", "%i", &num),
 			    C2_FLAGARG('e', "E", &e));
 	C2_UT_ASSERT(result == 0);
 	C2_UT_ASSERT(e == true);
 	C2_UT_ASSERT(num == 8);
 
-	result = C2_GETOPTS("getopts-ut", argc, argv,
+	result = C2_GETOPTS("getopts-ut", argc, argv, 
 			    C2_FORMATARG('n', "Num", "%d", &num),
 			    C2_FLAGARG('e', "E", &e));
 	C2_UT_ASSERT(num == 10);
-	result = C2_GETOPTS("getopts-ut", argc, argv,
-			    C2_STRINGARG('n', "Num",
+	result = C2_GETOPTS("getopts-ut", argc, argv, 
+			    C2_STRINGARG('n', "Num", 
 			 LAMBDA(void, (const char *s){
 				 C2_UT_ASSERT(!strcmp(s, "010"));
 			 })),
@@ -68,10 +65,11 @@ void test_getopts(void)
 	argv[--argc] = NULL;
 
 	e = false;
-	result = C2_GETOPTS("getopts-ut", argc, argv,
+	result = C2_GETOPTS("getopts-ut", argc, argv, 
 			    C2_FLAGARG('e', "E", &e));
 	C2_UT_ASSERT(result == 0);
 	C2_UT_ASSERT(e == true);
+
 	argv[--argc] = NULL;
 
 	result = C2_GETOPTS("getopts-ut", argc, argv);
@@ -79,7 +77,7 @@ void test_getopts(void)
 
 }
 
-/*
+/* 
  *  Local variables:
  *  c-indentation-style: "K&R"
  *  c-basic-offset: 8
diff --git a/lib/ut/list.c b/lib/ut/list.c
index 5f0c80b..8abcdd4 100644
--- a/lib/ut/list.c
+++ b/lib/ut/list.c
@@ -14,13 +14,14 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Alexey Lyashkov <Alexey_Lyashkov@xyratex.com>,
- *                  Nikita Danilov <Nikita_Danilov@xyratex.com>
+ * Original author: Alexey Lyashkov, Nikita Danilov
  * Original creation date: 04/07/2010
  */
 
 #include "lib/ub.h"
 #include "lib/ut.h"
+#include "lib/cdefs.h"
+#include "lib/memory.h"
 #include "lib/list.h"
 
 struct test1 {
diff --git a/lib/ut/main.c b/lib/ut/main.c
index f4376d1..0d0904a 100644
--- a/lib/ut/main.c
+++ b/lib/ut/main.c
@@ -14,7 +14,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Nikita Danilov <Nikita_Danilov@xyratex.com>
+ * Original author: Nikita Danilov
  * Original creation date: 05/23/2010
  */
 
@@ -28,18 +28,15 @@ extern void test_getopts(void);
 extern void test_list(void);
 extern void test_memory(void);
 extern void test_mutex(void);
-extern void test_processor(void);
 extern void test_queue(void);
 extern void test_refs(void);
-extern void test_rw(void);
+extern void test_processor(void);
 extern void test_thread(void);
 extern void test_time(void);
 extern void test_timer(void);
-extern void test_tlist(void);
 extern void test_trace(void);
 extern void test_vec(void);
-extern void test_zerovec(void);
-extern void test_bob(void);
+extern void test_rw(void);
 
 const struct c2_test_suite libc2_ut = {
 	.ts_name = "libc2-ut",
@@ -48,23 +45,20 @@ const struct c2_test_suite libc2_ut = {
 	.ts_tests = {
 		{ "atomic",    test_atomic    },
 		{ "bitmap",    test_bitmap    },
-		{ "bob",       test_bob       },
 		{ "chan",      test_chan      },
 		{ "getopts",   test_getopts   },
 		{ "list",      test_list      },
 		{ "memory",    test_memory    },
 		{ "mutex",     test_mutex     },
 		{ "rwlock",    test_rw        },
-		{ "processor", test_processor },
 		{ "queue",     test_queue     },
 		{ "refs",      test_refs      },
+//		{ "processor", test_processor },
 		{ "thread",    test_thread    },
 		{ "time",      test_time      },
 		{ "timer",     test_timer     },
-		{ "tlist",     test_tlist     },
 		{ "trace",     test_trace     },
 		{ "vec",       test_vec       },
-		{ "zerovec",   test_zerovec   },
 		{ NULL,        NULL           }
 	}
 };
diff --git a/lib/ut/memory.c b/lib/ut/memory.c
index 3be2bf2..5926fde 100644
--- a/lib/ut/memory.c
+++ b/lib/ut/memory.c
@@ -14,7 +14,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Nikita Danilov <Nikita_Danilov@xyratex.com>
+ * Original author: Nikita Danilov
  * Original creation date: 05/07/2010
  */
 #include <stdlib.h>
diff --git a/lib/ut/mutex.c b/lib/ut/mutex.c
index c70340b..2e041d9 100644
--- a/lib/ut/mutex.c
+++ b/lib/ut/mutex.c
@@ -14,7 +14,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Nikita Danilov <Nikita_Danilov@xyratex.com>
+ * Original author: Nikita Danilov
  * Original creation date: 05/13/2010
  */
 
diff --git a/lib/ut/processor.c b/lib/ut/processor.c
index bf59c01..11c50a0 100644
--- a/lib/ut/processor.c
+++ b/lib/ut/processor.c
@@ -13,7 +13,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Rajesh Bhalerao <Rajesh_Bhalerao@xyratex.com>
+ * Original author: Rajesh Bhalerao
  * Original creation date: 03/17/2011
  */
 
@@ -257,7 +257,7 @@ static void ub_fini(void)
 
 static void ub_init1(int i)
 {
-	C2_UT_ASSERT(!c2_processor_is_initialized());
+	C2_UT_ASSERT(c2_processor_is_initialized() == false);
 }
 
 static void ub_init2(int i)
@@ -266,7 +266,7 @@ static void ub_init2(int i)
 
 	rc = c2_processors_init();
 	C2_UT_ASSERT(rc == 0);
-	C2_UT_ASSERT(c2_processor_is_initialized());
+	C2_UT_ASSERT(c2_processor_is_initialized() == true);
 	c2_processors_fini();
 }
 
@@ -277,7 +277,7 @@ static void ub_init3(int i)
 	rc = c2_processors_init();
 	C2_UT_ASSERT(rc == 0);
 	c2_processors_fini();
-	C2_UT_ASSERT(!c2_processor_is_initialized());
+	C2_UT_ASSERT(c2_processor_is_initialized() == false);
 }
 
 static uint32_t get_num_from_file(const char *file)
@@ -332,6 +332,7 @@ static void verify_getcpu()
 {
 	int	id;
 	int	rc;
+	bool	val;
 
 	struct c2_bitmap	map;
 	c2_processor_nr_t	num;
@@ -348,10 +349,9 @@ static void verify_getcpu()
 
 	id = c2_processor_getcpu();
 	if (id != -1) {
-		C2_UT_ASSERT(c2_bitmap_get(&map, id));
+		val = c2_bitmap_get(&map, id);
+		C2_UT_ASSERT(val == true);
 	}
-
-	c2_bitmap_fini(&map);
 	c2_processors_fini();
 }
 
@@ -402,9 +402,8 @@ static void verify_map(int mapid)
 	fclose(fp);
 
 	rc = strncmp(result, expect, strlen(expect));
-	C2_UT_ASSERT(rc == 0);
+	C2_UT_ASSERT( rc == 0);
 
-	c2_bitmap_fini(&map);
 	c2_processors_fini();
 }
 
@@ -451,6 +450,7 @@ static void verify_a_processor(c2_processor_nr_t id,
 	sprintf(filename, "%s/"NUMA_FILE1, processor_info_dirp,
 					   id, pd->pd_numa_node);
 	rc1 = stat(filename, &statbuf);
+	C2_UT_ASSERT(rc1 == 0);
 	if (rc1 != 0) {
 		sprintf(filename, "%s/"NUMA_FILE2, processor_info_dirp,
 						   pd->pd_numa_node, id);
@@ -469,6 +469,7 @@ static void verify_a_processor(c2_processor_nr_t id,
 	C2_UT_ASSERT(pd->pd_l1 == id || pd->pd_l1 == mixedid);
 	C2_UT_ASSERT(pd->pd_l2 == id || pd->pd_l2 == mixedid ||
 		     pd->pd_l2 == physid);
+	
 
 	sprintf(filename, "%s/"L1SZ_FILE, processor_info_dirp, id);
 	l1_sz = get_num_from_file(filename);
@@ -518,8 +519,6 @@ static void verify_processors()
 			}
 		}
 	}
-
-	c2_bitmap_fini(&onln_map);
 	c2_processors_fini();
 }
 
@@ -736,7 +735,7 @@ static void verify_init(void)
 
 	rc = c2_processors_init();
 	C2_UT_ASSERT(rc != 0);
-	C2_UT_ASSERT(!c2_processor_is_initialized());
+	C2_UT_ASSERT(c2_processor_is_initialized() == false);
 }
 
 static void verify_all_params()
@@ -801,7 +800,6 @@ void test_processor(void)
 	verify_all_params();
 	clean_test_dataset();
 
-	unsetenv("C2_PROCESSORS_INFO_DIR");
 }
 
 struct c2_ub_set c2_processor_ub = {
diff --git a/lib/ut/queue.c b/lib/ut/queue.c
index 7e98396..46ac35c 100644
--- a/lib/ut/queue.c
+++ b/lib/ut/queue.c
@@ -14,7 +14,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Nikita Danilov <Nikita_Danilov@xyratex.com>
+ * Original author: Nikita Danilov
  * Original creation date: 05/07/2010
  */
 
@@ -37,8 +37,8 @@ void test_queue(void)
 	int sum0;
 	int sum1;
 
-	struct c2_queue  q;
-	static struct qt t[NR]; /* static to reduce kernel stack consumption. */
+	struct c2_queue q;
+	struct qt       t[NR];
 
 	for (sum0 = i = 0; i < ARRAY_SIZE(t); ++i) {
 		t[i].t_val = i;
@@ -83,7 +83,7 @@ void test_queue(void)
 }
 
 
-/*
+/* 
  *  Local variables:
  *  c-indentation-style: "K&R"
  *  c-basic-offset: 8
diff --git a/lib/ut/refs.c b/lib/ut/refs.c
index 3d0b6de..5efc4a9 100644
--- a/lib/ut/refs.c
+++ b/lib/ut/refs.c
@@ -14,7 +14,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Alexey Lyashkov <Alexey_Lyashkov@xyratex.com>
+ * Original author: Alexey Lyashkov
  * Original creation date: 04/08/2010
  */
 
diff --git a/lib/ut/rwlock.c b/lib/ut/rwlock.c
index 0d2f369..7484521 100644
--- a/lib/ut/rwlock.c
+++ b/lib/ut/rwlock.c
@@ -14,7 +14,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Nikita Danilov <Nikita_Danilov@xyratex.com>
+ * Original author: Nikita Danilov
  * Original creation date: 05/30/2010
  */
 
diff --git a/lib/ut/thread.c b/lib/ut/thread.c
index b1199d6..b9d2471 100644
--- a/lib/ut/thread.c
+++ b/lib/ut/thread.c
@@ -14,7 +14,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Nikita Danilov <Nikita_Danilov@xyratex.com>
+ * Original author: Nikita Danilov
  * Original creation date: 05/30/2010
  */
 
@@ -61,7 +61,11 @@ static void t3(int n)
 	c2_bitmap_set(&t3bm, 0, true);
 
 	result = c2_thread_confine(&t[n], &t3bm);
+#ifndef __KERNEL__
 	C2_UT_ASSERT(result == 0);
+#else
+	C2_UT_ASSERT(result != 0);
+#endif
 
 	c2_bitmap_fini(&t3bm);
 
@@ -70,12 +74,11 @@ static void t3(int n)
 	C2_UT_ASSERT(c2_thread_handle_eq(&myhandle, &t[n].t_h));
 }
 
-static char t1place[100];
-
 void test_thread(void)
 {
 	int i;
 	int result;
+	char t1place[100];
 	struct c2_thread_handle thandle;
 	struct c2_thread_handle myhandle;
 
diff --git a/lib/ut/time.c b/lib/ut/time.c
index 4ed7af4..0188de9 100644
--- a/lib/ut/time.c
+++ b/lib/ut/time.c
@@ -14,8 +14,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Nathan Rutman <Nathan_Rutman@us.xyratex.com>,
- *                  Huang Hua <Hua_Huang@xyratex.com>
+ * Original author: Nathan Rutman, Huang Hua
  * Original creation date: 12/06/2010
  */
 
@@ -39,7 +38,7 @@ void test_time(void)
 	C2_UT_ASSERT(c2_time_after(C2_TIME_NEVER, t1));
 	C2_UT_ASSERT(!c2_time_after(t1, C2_TIME_NEVER));
 
-	t1 = c2_time_now();
+	c2_time_now(&t1);
 	t2 = t1;
 	C2_UT_ASSERT(t1 != 0);
 
@@ -59,7 +58,6 @@ void test_time(void)
 	t3 = c2_time_add(t1, t2);
 	C2_UT_ASSERT(t3 == 1236487654321);
 
-	c2_time_set(&t2, 0, C2_TIME_ONE_BILLION/100);
 	rc = c2_nanosleep(t2, &t1);
 	C2_UT_ASSERT(rc == 0);
 
diff --git a/lib/ut/timer.c b/lib/ut/timer.c
index cd1406b..75156a1 100644
--- a/lib/ut/timer.c
+++ b/lib/ut/timer.c
@@ -14,510 +14,161 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Huang Hua <Hua_Huang@xyratex.com>
- *		    Maxim Medved <Max_Medved@xyratex.com>
+ * Original author: Huang Hua
  * Original creation date: 03/04/2011
  */
 
-#include "lib/ut.h"		/* C2_UT_ASSERT */
-#include "lib/time.h"		/* c2_time_t */
-#include "lib/timer.h"		/* c2_timer */
-#include "lib/assert.h"		/* C2_ASSERT */
-#include "lib/thread.h"		/* C2_THREAD_INIT */
-#include "lib/semaphore.h"	/* c2_semaphore */
-#include "lib/memory.h"		/* C2_ALLOC_ARR */
-#include "lib/atomic.h"		/* c2_atomic64 */
-
-#include <stdlib.h>		/* rand */
-#include <unistd.h>		/* syscall */
-#include <sys/syscall.h>	/* syscall */
-
-enum {
-	NR_TIMERS     =  8,	/* number of timers in tests */
-	NR_TG	      =  8,	/* number of thread groups */
-	NR_THREADS_TG =  8,	/* number of slave threads per thread group */
-	NR_TIMERS_TG  = 50,	/* number of timers per thread group */
-};
-
-struct thread_group;
-
-struct tg_slave {
-	pid_t                tgs_tid;
-	struct c2_semaphore  tgs_sem_init;
-	struct c2_semaphore  tgs_sem_resume;
-	struct thread_group *tgs_group;
-};
-
-struct tg_timer {
-	struct c2_timer	     tgt_timer;
-	struct thread_group *tgt_group;
-	c2_time_t	     tgt_expire;
-	struct c2_semaphore  tgt_done;
-};
-
-struct thread_group {
-	struct c2_thread	 tg_master;
-	struct c2_thread	 tg_threads[NR_THREADS_TG];
-	struct tg_slave		 tg_slaves[NR_THREADS_TG];
-	struct c2_semaphore	 tg_sem_init;
-	struct c2_semaphore	 tg_sem_resume;
-	struct c2_semaphore	 tg_sem_done;
-	struct tg_timer		 tg_timers[NR_TIMERS_TG];
-	struct c2_timer_locality tg_loc;
-	unsigned int		 tg_seed;
-};
-
-static pid_t		   loc_default_tid;
-static struct c2_semaphore loc_default_lock;
-
-static pid_t		    test_locality_tid;
-static struct c2_semaphore *test_locality_lock;
-
-static struct c2_atomic64 callbacks_executed;
-
-static pid_t gettid()
-{
-	return syscall(SYS_gettid);
-}
+#include "lib/ut.h"
+#include "lib/time.h"
+#include "lib/timer.h"
+#include "lib/assert.h"
+#include "lib/thread.h"
 
-static c2_time_t make_time(int ms)
-{
-	c2_time_t t;
-
-	c2_time_set(&t, ms / 1000, (ms % 1000) * 1000000);
-	return t;
-}
+#include <stdio.h>
 
-static c2_time_t make_time_abs(int ms)
-{
-	return c2_time_add(c2_time_now(), make_time(ms));
-}
+static int count = 0;
+static int verbose = 0;
 
-static int time_rand_ms(int min_ms, int max_ms)
+unsigned long tick(unsigned long data)
 {
-	return min_ms + (rand() * 1. / RAND_MAX) * (max_ms - min_ms);
-}
+	c2_time_t now;
 
-static void sem_init_zero(struct c2_semaphore *sem)
-{
-	int rc = c2_semaphore_init(sem, 0);
-	C2_UT_ASSERT(rc == 0);
-}
+	c2_time_now(&now);
+	count ++;
+	if (verbose)
+		printf("%lu.%lu: timer1 tick = %d\n",
+		       c2_time_seconds(now), c2_time_nanoseconds(now), count);
 
-static unsigned long timer_callback(unsigned long data)
-{
-	c2_atomic64_inc(&callbacks_executed);
 	return 0;
 }
 
-/**
-   Test timers.
-
-   @param timer_type timer type
-   @param nr_timers number of timers in this test
-   @param interval_min_ms minimum value for timer interval
-   @param interval_max_ms maximum value for timer interval
-	  for every timer it will be chosen with rand()
-	  in range [interval_min_ms, interval_max_ms]
-   @param wait_time_ms function will wait this time and then c2_time_stop()
-	  for all timers
-   @param callbacks_min @see callbacks_max
-   @param callbacks_max number of executed callbacks should be
-	  in the interval [callbacks_min, callbacks_max]
-	  (this is checked with C2_UT_ASSERT())
- */
-static void test_timers(enum c2_timer_type timer_type, int nr_timers,
-		int interval_min_ms, int interval_max_ms,
-		int wait_time_ms, int callbacks_min, int callbacks_max)
+unsigned long tack(unsigned long data)
 {
-	struct c2_timer *timers;
-	int		 i;
-	int		 time;
-	int		 rc;
-	c2_time_t	 zero_time;
-	c2_time_t	 wait;
-	c2_time_t	 rem;
-
-	c2_atomic64_set(&callbacks_executed, 0);
-	srand(0);
-	C2_ALLOC_ARR(timers, nr_timers);
-	C2_UT_ASSERT(timers != NULL);
-	if (timers == NULL)
-		return;
-
-	/* c2_timer_init() */
-	for (i = 0; i < nr_timers; ++i) {
-		time = time_rand_ms(interval_min_ms, interval_max_ms);
-		rc = c2_timer_init(&timers[i], timer_type,
-				make_time_abs(time),
-				timer_callback,
-				i);
-		C2_UT_ASSERT(rc == 0);
-	}
-	/* c2_timer_start() */
-	for (i = 0; i < nr_timers; ++i) {
-		rc = c2_timer_start(&timers[i]);
-		C2_UT_ASSERT(rc == 0);
-	}
-	/* wait some time */
-	c2_time_set(&zero_time, 0, 0);
-	wait = make_time(wait_time_ms);
-	do
-		c2_nanosleep(wait, &rem);
-	while ((wait = rem) != zero_time);
-	/* c2_timer_stop() */
-	for (i = 0; i < nr_timers; ++i) {
-		rc = c2_timer_stop(&timers[i]);
-		C2_UT_ASSERT(rc == 0);
-	}
-	/* c2_timer_fini() */
-	for (i = 0; i < nr_timers; ++i) {
-		rc = c2_timer_fini(&timers[i]);
-		C2_UT_ASSERT(rc == 0);
-	}
-
-	C2_UT_ASSERT(c2_atomic64_get(&callbacks_executed) >= callbacks_min);
-	C2_UT_ASSERT(c2_atomic64_get(&callbacks_executed) <= callbacks_max);
-
-	c2_free(timers);
-}
+	static int tack;
+	c2_time_t  now;
+
+	c2_time_now(&now);
+	tack += data;
+	if (verbose)
+		printf("%lu.%lu:    timer2 tack = %d\n",
+			c2_time_seconds(now), c2_time_nanoseconds(now), tack);
 
-static unsigned long locality_default_callback(unsigned long data)
-{
-	C2_UT_ASSERT(gettid() == loc_default_tid);
-	c2_semaphore_up(&loc_default_lock);
 	return 0;
 }
 
-static void timer_locality_default_test()
+void test_2_timers()
 {
-	int		rc;
-	struct c2_timer timer;
+	struct c2_timer timer1;
+	struct c2_timer timer2;
+	c2_time_t       i1;
+	c2_time_t       i2;
+	c2_time_t       wait;
 
-	rc = c2_timer_init(&timer, C2_TIMER_HARD, make_time_abs(100),
-			&locality_default_callback, 0);
-	C2_UT_ASSERT(rc == 0);
+	c2_time_set(&i1, 1, 0);
+	c2_timer_init(&timer1, C2_TIMER_SOFT, i1, 5, tick, 0);
+	c2_timer_start(&timer1);
 
-	sem_init_zero(&loc_default_lock);
+	c2_time_set(&i2, 3, 0);
+	c2_timer_init(&timer2, C2_TIMER_SOFT, i2, 5, tack, 10000);
+	c2_timer_start(&timer2);
 
-	loc_default_tid = gettid();
-	rc = c2_timer_start(&timer);
-	C2_UT_ASSERT(rc == 0);
-	c2_semaphore_down(&loc_default_lock);
+	c2_time_set(&wait, 0, 500000000); /* 0.5 second */
+	/* let's do something, e.g. just waiting */
+	while (count < 5)
+		c2_nanosleep(wait, NULL);
+	c2_timer_stop(&timer1);
 
-	rc = c2_timer_stop(&timer);
-	C2_UT_ASSERT(rc == 0);
+	/* start timer1 again, and do something, e.g. just waiting */
+	c2_timer_start(&timer1);
+	while (count < 8)
+		c2_nanosleep(wait, NULL);
+	c2_timer_stop(&timer2);
+	c2_timer_fini(&timer2);
 
-	c2_semaphore_fini(&loc_default_lock);
-	rc = c2_timer_fini(&timer);
-	C2_UT_ASSERT(rc == 0);
-}
+	while (count < 10)
+		c2_nanosleep(wait, NULL);
 
-static unsigned long locality_test_callback(unsigned long data)
-{
-	C2_ASSERT(data >= 0);
-	C2_ASSERT(test_locality_tid == gettid());
-	c2_semaphore_up(&test_locality_lock[data]);
-	return 0;
+	c2_timer_stop(&timer1);
+	c2_timer_fini(&timer1);
 }
 
-static void timer_locality_test(int nr_timers,
-		int interval_min_ms, int interval_max_ms)
+void timer1_thread(int unused)
 {
-	int                      i;
-	int                      rc;
-	struct c2_timer		*timers;
-	struct c2_timer_locality loc;
-	int			 time;
-
-	C2_ALLOC_ARR(timers, nr_timers);
-	C2_UT_ASSERT(timers != NULL);
-	if (timers == NULL)
-		return;
-
-	C2_ALLOC_ARR(test_locality_lock, nr_timers);
-	C2_UT_ASSERT(test_locality_lock != NULL);
-	if (test_locality_lock == NULL)
-		goto free_timers;
-
-	test_locality_tid = gettid();
-	for (i = 0; i < nr_timers; ++i)
-		sem_init_zero(&test_locality_lock[i]);
-
-	c2_timer_locality_init(&loc);
-	rc = c2_timer_thread_attach(&loc);
-	C2_UT_ASSERT(rc == 0);
-
-	/* c2_timer_init() */
-	for (i = 0; i < nr_timers; ++i) {
-		time = time_rand_ms(interval_min_ms, interval_max_ms);
-		rc = c2_timer_init(&timers[i], C2_TIMER_HARD,
-				make_time_abs(time),
-				&locality_test_callback, i);
-		C2_UT_ASSERT(rc == 0);
-		rc = c2_timer_attach(&timers[i], &loc);
-		C2_UT_ASSERT(rc == 0);
-	}
-
-	/* c2_timer_start() */
-	for (i = 0; i < nr_timers; ++i) {
-		rc = c2_timer_start(&timers[i]);
-		C2_UT_ASSERT(rc == 0);
-	}
-
-	for (i = 0; i < nr_timers; ++i)
-		c2_semaphore_down(&test_locality_lock[i]);
-
-	/* c2_timer_stop(), c2_timer_fini() */
-	for (i = 0; i < nr_timers; ++i) {
-		rc = c2_timer_stop(&timers[i]);
-		C2_UT_ASSERT(rc == 0);
-		rc = c2_timer_fini(&timers[i]);
-		C2_UT_ASSERT(rc == 0);
-		c2_semaphore_fini(&test_locality_lock[i]);
-	}
-
-	c2_timer_thread_detach(&loc);
-	c2_timer_locality_fini(&loc);
-
-	c2_free(test_locality_lock);
-free_timers:
-	c2_free(timers);
-}
+	struct c2_timer timer1;
+	c2_time_t       i1;
+	c2_time_t       wait;
 
-/*
-   It isn't safe to use C2_UT_ASSERT() in signal handler code,
-   therefore instead of C2_UT_ASSERT() was used C2_ASSERT().
- */
-static unsigned long test_timer_callback_mt(unsigned long data)
-{
-	struct tg_timer *tgt = (struct tg_timer *)data;
-	bool		 found = false;
-	pid_t		 tid = gettid();
-	int		 i;
-
-	C2_ASSERT(tgt != NULL);
-	/* check thread ID */
-	for (i = 0; i < NR_THREADS_TG; ++i)
-		if (tgt->tgt_group->tg_slaves[i].tgs_tid == tid) {
-			found = true;
-			break;
-		}
-	C2_ASSERT(found);
-	/* callback is done */
-	c2_semaphore_up(&tgt->tgt_done);
-	return 0;
-}
+	c2_time_set(&i1, 1, 0);
+	c2_timer_init(&timer1, C2_TIMER_SOFT, i1, 5, tick, 0);
+	c2_timer_start(&timer1);
 
-static void test_timer_slave_mt(struct tg_slave *slave)
-{
-	int rc;
+	c2_time_set(&wait, 0, 500000000); /* 0.5 second */
+	/* let's do something, e.g. just waiting */
+	while (count < 5)
+		c2_nanosleep(wait, NULL);
 
-	slave->tgs_tid = gettid();
-	/* add slave thread to locality */
-	rc = c2_timer_thread_attach(&slave->tgs_group->tg_loc);
-	C2_UT_ASSERT(rc == 0);
-	/* signal to master thread about init */
-	c2_semaphore_up(&slave->tgs_sem_init);
+	/* stop and start timer1 again, and do something, e.g. just waiting */
+	c2_timer_stop(&timer1);
+	c2_timer_start(&timer1);
 
-	/* now c2_timer callback can be executed in this thread context */
+	while (count < 10)
+		c2_nanosleep(wait, NULL);
 
-	/* wait for master thread */
-	c2_semaphore_down(&slave->tgs_sem_resume);
-	/* remove current thread from thread group locality */
-	c2_timer_thread_detach(&slave->tgs_group->tg_loc);
+	c2_timer_stop(&timer1);
+	c2_timer_fini(&timer1);
+	if (verbose)
+		printf("timer1 thread exit\n");
 }
 
-static void test_timer_master_mt(struct thread_group *tg)
+void timer2_thread(int unused)
 {
-	int		 i;
-	int		 rc;
-	struct tg_timer *tgt;
-
-	/* init() all slave semaphores */
-	for (i = 0; i < NR_THREADS_TG; ++i) {
-		sem_init_zero(&tg->tg_slaves[i].tgs_sem_init);
-		sem_init_zero(&tg->tg_slaves[i].tgs_sem_resume);
-	}
-	/* init() timer locality */
-	c2_timer_locality_init(&tg->tg_loc);
-	/* init() and start all slave threads */
-	for (i = 0; i < NR_THREADS_TG; ++i) {
-		tg->tg_slaves[i].tgs_group = tg;
-		rc = C2_THREAD_INIT(&tg->tg_threads[i], struct tg_slave *,
-				NULL, &test_timer_slave_mt,
-				&tg->tg_slaves[i], "timer test slave");
-		C2_UT_ASSERT(rc == 0);
-	}
-	/* wait until all slaves initialized */
-	for (i = 0; i < NR_THREADS_TG; ++i)
-		c2_semaphore_down(&tg->tg_slaves[i].tgs_sem_init);
-	/* init() all timers */
-	for (i = 0; i < NR_TIMERS_TG; ++i) {
-		tgt = &tg->tg_timers[i];
-		tgt->tgt_group = tg;
-		/* expiration time is in [now + 1, now + 100] ms range */
-		c2_time_set(&tgt->tgt_expire, 0,
-				(1 + rand_r(&tg->tg_seed) % 100) * 1000000);
-		tgt->tgt_expire = c2_time_add(c2_time_now(), tgt->tgt_expire);
-		/* init timer semaphore */
-		sem_init_zero(&tgt->tgt_done);
-		/* `unsigned long' must have enough space to contain `void*' */
-		C2_CASSERT(sizeof(unsigned long) >= sizeof(void *));
-		/*
-		 * create timer.
-		 * parameter for callback is pointer to corresponding
-		 * `struct tg_timer'
-		 */
-		rc = c2_timer_init(&tg->tg_timers[i].tgt_timer, C2_TIMER_HARD,
-				tgt->tgt_expire,
-				test_timer_callback_mt, (unsigned long) tgt);
-		C2_UT_ASSERT(rc == 0);
-		/* attach timer to timer group locality */
-		rc = c2_timer_attach(&tg->tg_timers[i].tgt_timer, &tg->tg_loc);
-		C2_UT_ASSERT(rc == 0);
-	}
-	/* synchronize with all master threads */
-	c2_semaphore_up(&tg->tg_sem_init);
-	c2_semaphore_down(&tg->tg_sem_resume);
-	/* start() all timers */
-	for (i = 0; i < NR_TIMERS_TG; ++i) {
-		rc = c2_timer_start(&tg->tg_timers[i].tgt_timer);
-		C2_UT_ASSERT(rc == 0);
-	}
-	/* wait for all timers */
-	for (i = 0; i < NR_TIMERS_TG; ++i)
-		c2_semaphore_down(&tg->tg_timers[i].tgt_done);
-	/* stop() all timers */
-	for (i = 0; i < NR_TIMERS_TG; ++i) {
-		rc = c2_timer_stop(&tg->tg_timers[i].tgt_timer);
-		C2_UT_ASSERT(rc == 0);
-	}
-	/* fini() all timers */
-	for (i = 0; i < NR_TIMERS_TG; ++i) {
-		rc = c2_timer_fini(&tg->tg_timers[i].tgt_timer);
-		C2_UT_ASSERT(rc == 0);
-		c2_semaphore_fini(&tg->tg_timers[i].tgt_done);
-	}
-	/* resume all slaves */
-	for (i = 0; i < NR_THREADS_TG; ++i)
-		c2_semaphore_up(&tg->tg_slaves[i].tgs_sem_resume);
-	/* fini() all slave threads */
-	for (i = 0; i < NR_THREADS_TG; ++i) {
-		rc = c2_thread_join(&tg->tg_threads[i]);
-		C2_UT_ASSERT(rc == 0);
-		c2_thread_fini(&tg->tg_threads[i]);
-	}
-	/* fini() thread group locality */
-	c2_timer_locality_fini(&tg->tg_loc);
-	/* fini() all slave semaphores */
-	for (i = 0; i < NR_THREADS_TG; ++i) {
-		c2_semaphore_fini(&tg->tg_slaves[i].tgs_sem_init);
-		c2_semaphore_fini(&tg->tg_slaves[i].tgs_sem_resume);
-	}
-	/* signal to main thread */
-	c2_semaphore_up(&tg->tg_sem_done);
-}
+	struct c2_timer timer2;
+	c2_time_t       i2;
+	c2_time_t       wait;
 
-/**
-   @verbatim
-   this (main) thread		master threads		slave threads
-   start all masters
-   wait for masters init
-				init slaves
-				wait for all slaves
-							attach to locality
-				barrier with slaves	barrier with master
-				sync with main
-				wait for all masters
-   barrier with all masters	barrier with main
-				init all timers
-				run all timers
-				fini() all timers
-				barrier with slaves	barrier with master
-							detach from locality
-							exit from thread
-				wait for slaves
-					termination
-   barrier with all masters	barrier with main
-				exit from thread
-   wait for masters termination
-   @endverbatim
- */
-static void test_timer_many_timers_mt()
-{
-	int			   i;
-	int			   rc;
-	static struct thread_group tg[NR_TG];
-
-	/* init() all semaphores */
-	for (i = 0; i < NR_TG; ++i) {
-		sem_init_zero(&tg[i].tg_sem_init);
-		sem_init_zero(&tg[i].tg_sem_resume);
-		sem_init_zero(&tg[i].tg_sem_done);
-	}
-
-	/* init RNG seeds for thread groups */
-	for (i = 0; i < NR_TG; ++i)
-		tg[i].tg_seed = i;
-
-	/* start all masters from every thread group */
-	for (i = 0; i < NR_TG; ++i) {
-		rc = C2_THREAD_INIT(&tg[i].tg_master, struct thread_group *,
-				NULL, &test_timer_master_mt,
-				&tg[i], "timer test master");
-		C2_UT_ASSERT(rc == 0);
-	}
-
-	/* wait for masters initializing */
-	for (i = 0; i < NR_TG; ++i)
-		c2_semaphore_down(&tg[i].tg_sem_init);
-
-	/* resume all masters */
-	for (i = 0; i < NR_TG; ++i)
-		c2_semaphore_up(&tg[i].tg_sem_resume);
-
-	/* wait for finishing */
-	for (i = 0; i < NR_TG; ++i)
-		c2_semaphore_down(&tg[i].tg_sem_done);
-
-	/* fini() all semaphores and master threads */
-	for (i = 0; i < NR_TG; ++i) {
-		c2_semaphore_fini(&tg[i].tg_sem_init);
-		c2_semaphore_fini(&tg[i].tg_sem_resume);
-		c2_semaphore_fini(&tg[i].tg_sem_done);
-
-		rc = c2_thread_join(&tg[i].tg_master);
-		C2_UT_ASSERT(rc == 0);
-		c2_thread_fini(&tg[i].tg_master);
-	}
+	c2_time_set(&i2, 3, 0);
+	c2_timer_init(&timer2, C2_TIMER_SOFT, i2, 5, tack, 10000);
+	c2_timer_start(&timer2);
+
+	c2_time_set(&wait, 0, 500000000); /* 0.5 second */
+	while (count < 8)
+		c2_nanosleep(wait, NULL);
+	c2_timer_stop(&timer2);
+	c2_timer_fini(&timer2);
+	if (verbose)
+		printf("timer2 thread exit\n");
 }
 
 void test_timer(void)
 {
-	int		   i;
-	int		   j;
-	enum c2_timer_type timer_types[2] = {C2_TIMER_SOFT, C2_TIMER_HARD};
-
-	/* soft and hard timers tests */
-	for (j = 0; j < 2; ++j)
-		for (i = 1; i < NR_TIMERS; ++i) {
-			/* simple test */
-			test_timers(timer_types[j], i, 0, 10, 5, 0, i);
-			/* zero-time test */
-			test_timers(timer_types[j], i, 0, 0, 50, i, i);
-			/* cancel-timer-before-callback-executed test */
-			test_timers(timer_types[j], i, 10000, 10000, 50, 0, 0);
-		}
-	/* simple hard timer default locality test */
-	timer_locality_default_test();
-	/* test many hard timers in locality */
-	for (i = 1; i < NR_TIMERS; ++i)
-		timer_locality_test(i, 10, 30);
-	/* hard timer test in multithreaded environment */
-	test_timer_many_timers_mt();
+	struct c2_thread t1 = { 0 };
+	struct c2_thread t2 = { 0 };
+	int rc;
+
+	printf("start timer testing... this takes about 20 seconds\n");
+	test_2_timers();
+
+	if (verbose)
+		printf("==================\nstart 2 timers in 2 threads ...\n");
+
+	count = 0;
+
+	rc = C2_THREAD_INIT(&t1, int, NULL, &timer1_thread, 0, "timer1_thread");
+	C2_ASSERT(rc == 0);
+	rc = C2_THREAD_INIT(&t2, int, NULL, &timer2_thread, 0, "timer2_thread");
+	C2_ASSERT(rc == 0);
+
+	c2_thread_join(&t1);
+	c2_thread_fini(&t1);
+	c2_thread_join(&t2);
+	c2_thread_fini(&t2);
+
+	if (verbose)
+		printf("end timer testing...\n");
+	return;
 }
 
+
 /*
  *  Local variables:
  *  c-indentation-style: "K&R"
diff --git a/lib/ut/tlist.c b/lib/ut/tlist.c
deleted file mode 100644
index ae888ea..0000000
--- a/lib/ut/tlist.c
+++ /dev/null
@@ -1,347 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Nikita Danilov <Nikita_Danilov@xyratex.com>
- * Original creation date: 09/09/2010
- */
-
-#include "lib/ub.h"
-#include "lib/ut.h"
-#include "lib/types.h"                /* uint64_t */
-#include "lib/tlist.h"
-
-struct foo {
-	uint64_t        f_payload;
-	uint64_t        f_magic;
-	struct c2_tlink f_linkage0;
-	struct c2_tlink f_linkage1;
-	struct c2_tlink f_linkage2;
-};
-
-enum {
-	N  = 6,
-	NR = 128
-};
-
-static const struct c2_tl_descr fl0 = C2_TL_DESCR("foo-s of bar",
-						  struct foo,
-						  f_linkage0,
-						  f_magic,
-						  0xab5ce55edba1b0a0,
-						  0xba1dba11adba0bab);
-
-static const struct c2_tl_descr fl1 = C2_TL_DESCR("other foo-s of bar",
-						  struct foo,
-						  f_linkage1,
-						  f_magic,
-						  0xab5ce55edba1b0a0,
-						  0xbabe1b0ccacc1078);
-
-static const struct c2_tl_descr fl2 = C2_TL_DESCR("unchecked foo-s of bar",
-						  struct foo,
-						  f_linkage2,
-						  f_magic,
-						  0,
-						  0x0123456789abcdef);
-
-static struct c2_tl  head0[N];
-static struct c2_tl  head1[N];
-static struct c2_tl  head2[N];
-static struct foo    amb[NR];
-
-struct bar {
-	uint64_t        b_payload;
-	struct c2_tlink b_linkage;
-	uint64_t        b_magic;
-};
-
-C2_TL_DESCR_DEFINE(bar, "bar-s", static, struct bar, b_linkage,
-		   b_magic, 0xbeda551edcaca0ff, 0x7777777777777777);
-C2_TL_DEFINE(bar, static, struct bar);
-
-static struct c2_tl bhead;
-static struct bar   B[NR];
-
-void test_tlist(void)
-{
-	int           i;
-	struct foo   *obj;
-	struct c2_tl *head;
-	uint64_t      sum;
-	uint64_t      sumB;
-	uint64_t      sum1;
-	bool          done;
-	struct bar   *b;
-
-	C2_CASSERT(ARRAY_SIZE(head0) == ARRAY_SIZE(head1));
-	/* link magic must be the same as in fl0, because the same ambient
-	   object is shared. */
-	C2_ASSERT(fl0.td_link_magic == fl1.td_link_magic);
-
-	/* initialise */
-
-	sum = 0;
-	for (i = 0; i < ARRAY_SIZE(head0); ++i) {
-		c2_tlist_init(&fl0, &head0[i]);
-		c2_tlist_init(&fl1, &head1[i]);
-		c2_tlist_init(&fl2, &head2[i]);
-	}
-	for (i = 0, obj = amb; i < ARRAY_SIZE(amb); ++i, ++obj) {
-		c2_tlink_init(&fl0, obj);
-		c2_tlink_init(&fl1, obj);
-		c2_tlink_init(&fl2, obj);
-		obj->f_payload = i;
-		sum += i;
-	}
-
-	for (i = 0; i < ARRAY_SIZE(head0); ++i) {
-		C2_UT_ASSERT(c2_tlist_is_empty(&fl0, &head0[i]));
-		C2_UT_ASSERT(c2_tlist_length(&fl0, &head0[i]) == 0);
-
-		C2_UT_ASSERT(c2_tlist_is_empty(&fl1, &head1[i]));
-		C2_UT_ASSERT(c2_tlist_length(&fl1, &head1[i]) == 0);
-
-		C2_UT_ASSERT(c2_tlist_is_empty(&fl2, &head2[i]));
-		C2_UT_ASSERT(c2_tlist_length(&fl2, &head2[i]) == 0);
-	}
-
-	/* insert foo-s in the lists */
-
-	for (i = 0, obj = amb; i < ARRAY_SIZE(amb); ++i, ++obj) {
-		C2_UT_ASSERT(!c2_tlink_is_in(&fl0, obj));
-		C2_UT_ASSERT(!c2_tlink_is_in(&fl1, obj));
-		C2_UT_ASSERT(!c2_tlink_is_in(&fl2, obj));
-		c2_tlist_add(&fl0, &head0[0], obj);
-		C2_UT_ASSERT( c2_tlink_is_in(&fl0, obj));
-		C2_UT_ASSERT(!c2_tlink_is_in(&fl1, obj));
-		C2_UT_ASSERT(!c2_tlink_is_in(&fl2, obj));
-		c2_tlist_add_tail(&fl1, &head1[0], obj);
-		C2_UT_ASSERT(c2_tlink_is_in(&fl0, obj));
-		C2_UT_ASSERT(c2_tlink_is_in(&fl1, obj));
-		C2_UT_ASSERT(!c2_tlink_is_in(&fl2, obj));
-		c2_tlist_add_tail(&fl2, &head2[0], obj);
-		C2_UT_ASSERT(c2_tlink_is_in(&fl0, obj));
-		C2_UT_ASSERT(c2_tlink_is_in(&fl1, obj));
-		C2_UT_ASSERT(c2_tlink_is_in(&fl2, obj));
-
-		C2_UT_ASSERT(c2_tlist_contains(&fl0, &head0[0], obj));
-		C2_UT_ASSERT(c2_tlist_contains(&fl1, &head1[0], obj));
-	}
-	C2_UT_ASSERT(c2_tlist_length(&fl0, &head0[0]) == NR);
-	C2_UT_ASSERT(c2_tlist_length(&fl1, &head1[0]) == NR);
-	C2_UT_ASSERT(c2_tlist_length(&fl2, &head2[0]) == NR);
-
-	/* initialise bar-s */
-
-	bar_tlist_init(&bhead);
-	sumB = 0;
-	for (i = 0, b = B; i < ARRAY_SIZE(B); ++i, ++b) {
-		bar_tlink_init(b);
-		C2_UT_ASSERT(!bar_tlink_is_in(b));
-		bar_tlist_add(&bhead, b);
-		C2_UT_ASSERT(bar_tlink_is_in(b));
-		C2_UT_ASSERT(bar_tlist_contains(&bhead, b));
-		sumB += (b->b_payload = i*i);
-	}
-
-	C2_UT_ASSERT(bar_tlist_length(&bhead) == ARRAY_SIZE(B));
-
-	/* check that everything is in the lists */
-
-	sum1 = 0;
-	c2_tlist_for(&fl0, &head0[0], obj) {
-		sum1 += obj->f_payload;
-	} c2_tlist_endfor;
-
-	C2_UT_ASSERT(sum == sum1);
-
-	sum1 = 0;
-	c2_tlist_for(&fl1, &head1[0], obj)
-		sum1 += obj->f_payload;
-	c2_tlist_endfor;
-	C2_UT_ASSERT(sum == sum1);
-
-	/* bulldozer the foo-s to the last head */
-
-	for (head = head0, i = 0; i < N - 1; ++i, ++head) {
-		int j;
-
-		C2_UT_ASSERT(!c2_tlist_is_empty(&fl0, head));
-		for (j = 0; (obj = c2_tlist_head(&fl0, head)) != NULL; ++j)
-			c2_tlist_move_tail(&fl0, head + 1 + j % (N-i-1), obj);
-		C2_UT_ASSERT(c2_tlist_is_empty(&fl0, head));
-	}
-
-	/* check that everything is still here */
-
-	C2_UT_ASSERT(c2_tlist_length(&fl0, head) == NR);
-	sum1 = 0;
-	c2_tlist_for(&fl0, head, obj)
-		sum1 += obj->f_payload;
-	c2_tlist_endfor;
-	C2_UT_ASSERT(sum == sum1);
-
-	/* check that c2_tlist_for() works fine when the list is mutated */
-
-	c2_tlist_for(&fl1, &head1[0], obj) {
-		if (obj->f_payload % 2 == 0)
-			c2_tlist_move(&fl1, &head1[1], obj);
-	} c2_tlist_endfor;
-
-	c2_tlist_for(&fl1, &head1[0], obj) {
-		if (obj->f_payload % 2 != 0)
-			c2_tlist_move(&fl1, &head1[1], obj);
-	} c2_tlist_endfor;
-
-	C2_UT_ASSERT(c2_tlist_length(&fl1, &head1[0]) == 0);
-	C2_UT_ASSERT(c2_tlist_length(&fl1, &head1[1]) == NR);
-
-	head = &head1[1];
-
-	/* bubble sort the list */
-
-	do {
-		struct foo *prev;
-
-		done = true;
-
-		c2_tlist_for(&fl1, head, obj) {
-			prev = c2_tlist_prev(&fl1, head, obj);
-			if (prev != NULL && prev->f_payload > obj->f_payload) {
-				c2_tlist_del(&fl1, obj);
-				c2_tlist_add_before(&fl1, prev, obj);
-				done = false;
-			}
-		} c2_tlist_endfor;
-	} while (!done);
-
-	/* check that the list is sorted */
-
-	c2_tlist_for(&fl1, head, obj) {
-		struct foo *nxt = c2_tlist_next(&fl1, head, obj);
-		C2_UT_ASSERT(ergo(nxt != NULL,
-				  obj->f_payload <= nxt->f_payload));
-	} c2_tlist_endfor;
-
-	/* check that magic-less iteration works. */
-
-	sum1 = 0;
-	c2_tlist_for(&fl2, &head2[0], obj)
-		sum1 += obj->f_payload;
-	c2_tlist_endfor;
-	C2_UT_ASSERT(sum == sum1);
-
-	/* reverse bar-s */
-
-	c2_tlist_for(&bar_tl, &bhead, b) {
-		bar_tlist_move(&bhead, b);
-	} c2_tlist_endfor;
-
-	/* check that bar list is reversed */
-
-	for (i = 0, b = bar_tlist_head(&bhead); b != NULL;
-	     b = bar_tlist_next(&bhead, b), ++i) {
-		C2_UT_ASSERT(b->b_payload == i*i);
-	}
-
-	/* finalise */
-
-	for (i = 0, obj = amb; i < ARRAY_SIZE(amb); ++i, ++obj) {
-		c2_tlist_del(&fl2, obj);
-		c2_tlist_del(&fl1, obj);
-		c2_tlist_del(&fl0, obj);
-		c2_tlink_fini(&fl2, obj);
-		c2_tlink_fini(&fl1, obj);
-		c2_tlink_fini(&fl0, obj);
-		obj->f_magic = 0;
-	}
-
-	for (i = 0; i < ARRAY_SIZE(head0); ++i) {
-		c2_tlist_fini(&fl2, &head2[i]);
-		c2_tlist_fini(&fl1, &head1[i]);
-		c2_tlist_fini(&fl0, &head0[i]);
-	}
-
-	for (i = 0, b = B; i < ARRAY_SIZE(B); ++i, ++b) {
-		bar_tlist_del(b);
-		bar_tlink_fini(b);
-	}
-
-	bar_tlist_fini(&bhead);
-}
-
-enum {
-	UB_ITER = 100000
-};
-
-static struct foo    t[UB_ITER];
-static struct c2_tl  list;
-static struct foo   *obj;
-
-static void ub_init(void)
-{
-	int i;
-
-	for (i = 0, obj = t; i < ARRAY_SIZE(t); ++i, ++obj)
-		c2_tlink_init(&fl0, obj);
-	c2_tlist_init(&fl0, &list);
-}
-
-static void ub_fini(void)
-{
-	int i;
-
-	c2_tlist_fini(&fl0, &list);
-	for (i = 0, obj = t; i < ARRAY_SIZE(t); ++i, ++obj)
-		c2_tlink_fini(&fl0, obj);
-}
-
-static void ub_insert(int i)
-{
-	c2_tlist_add(&fl0, &list, &t[i]);
-}
-
-static void ub_delete(int i)
-{
-	c2_tlist_del(&fl0, &t[i]);
-}
-
-struct c2_ub_set c2_tlist_ub = {
-	.us_name = "tlist-ub",
-	.us_init = ub_init,
-	.us_fini = ub_fini,
-	.us_run  = {
-		{ .ut_name = "insert",
-		  .ut_iter = UB_ITER,
-		  .ut_round = ub_insert },
-
-		{ .ut_name = "delete",
-		  .ut_iter = UB_ITER,
-		  .ut_round = ub_delete },
-
-		{ .ut_name = NULL }
-	}
-};
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
diff --git a/lib/ut/trace.c b/lib/ut/trace.c
index 89ecea7..e8780f9 100644
--- a/lib/ut/trace.c
+++ b/lib/ut/trace.c
@@ -14,7 +14,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Nikita Danilov <Nikita_Danilov@xyratex.com>
+ * Original author: Nikita Danilov
  * Original creation date: 08/12/2010
  */
 
@@ -22,27 +22,24 @@
 #include "lib/ub.h"
 #include "lib/ut.h"
 #include "lib/thread.h"
-#include "lib/assert.h"
-#define C2_TRACE_SUBSYSTEM C2_TRACE_SUBSYS_UT
 #include "lib/trace.h"
+#include "lib/assert.h"
 
 enum {
 	NR       = 16,
 	NR_INNER = 100000
 };
 
-static struct c2_thread t[NR];
-
 void test_trace(void)
 {
 	int i;
 	int result;
-	uint64_t u64;
+	struct c2_thread t[NR];
 
-	C2_LOG("forty two: %i", 42);
-	C2_LOG("forty three and tree: %i %llu", 43, (unsigned long long)(u64 = 3));
+	C2_TRACE_POINT({ uint32_t a; }, 42);
+	C2_TRACE_POINT({ uint32_t b; }, 43);
 	for (i = 0; i < NR_INNER; ++i)
-		C2_LOG("c: %i, d: %i", i, i*i);
+		C2_TRACE_POINT({ uint32_t c; uint64_t d; }, i, i*i);
 
 	C2_SET_ARR0(t);
 	for (i = 0; i < NR; ++i) {
@@ -51,20 +48,14 @@ void test_trace(void)
 			int j;
 
 			for (j = 0; j < NR_INNER; ++j)
-				C2_LOG("d: %i, d*j: %i", d, d * j);
+				C2_TRACE_POINT({ uint32_t c; uint64_t d; }, 
+					       d, d * j); 
 						}), i, "test_trace_%i", i);
-		C2_ASSERT(result == 0);
 	}
 	for (i = 0; i < NR; ++i) {
 		c2_thread_join(&t[i]);
 		c2_thread_fini(&t[i]);
 	}
-	C2_LOG("X: %i and Y: %i", 43, result + 1);
-	C2_LOG("%llx char: %c %llx string: %s",
-		0x1234567887654321ULL,
-		'c',
-		0xfefefefefefefefeULL,
-		(char *)"foobar");
 }
 
 enum {
@@ -73,41 +64,47 @@ enum {
 
 static void ub_empty(int i)
 {
-	C2_LOG("msg");
+	C2_TRACE_POINT({},);
 }
 
 static void ub_8(int i)
 {
-	C2_LOG("%i", i);
+	C2_TRACE_POINT({ uint64_t x; }, i);
 }
 
 static void ub_64(int i)
 {
-	C2_LOG("%i %i %i %i %i %i %i %i",
-		i, i + 1, i + 2, i + 3, i + 4, i + 5,
+	C2_TRACE_POINT({ uint64_t x0;
+			uint64_t x1;
+			uint64_t x2;
+			uint64_t x3;
+			uint64_t x4;
+			uint64_t x5;
+			uint64_t x6;
+			uint64_t x7; }, i, i + 1, i + 2, i + 3, i + 4, i + 5, 
 		i + 6, i + 7);
 }
 
 struct c2_ub_set c2_trace_ub = {
 	.us_name = "trace-ub",
-	.us_run  = {
+	.us_run  = { 
 		{ .ut_name = "empty",
-		  .ut_iter = UB_ITER,
+		  .ut_iter = UB_ITER, 
 		  .ut_round = ub_empty },
 
 		{ .ut_name = "8",
-		  .ut_iter = UB_ITER,
+		  .ut_iter = UB_ITER, 
 		  .ut_round = ub_8 },
 
 		{ .ut_name = "64",
-		  .ut_iter = UB_ITER,
+		  .ut_iter = UB_ITER, 
 		  .ut_round = ub_64 },
 
 		{ .ut_name = NULL }
 	}
 };
 
-/*
+/* 
  *  Local variables:
  *  c-indentation-style: "K&R"
  *  c-basic-offset: 8
diff --git a/lib/ut/vec.c b/lib/ut/vec.c
index cbd8a27..38e9a97 100644
--- a/lib/ut/vec.c
+++ b/lib/ut/vec.c
@@ -14,7 +14,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Nikita Danilov <Nikita_Danilov@xyratex.com>
+ * Original author: Nikita Danilov
  * Original creation date: 05/12/2010
  */
 
@@ -207,7 +207,6 @@ static void test_bufvec_cursor(void)
 			}
 		}
 		C2_UT_ASSERT(len == buflen);
-		c2_bufvec_free(&buf);
 	}
 
 	/* bounded copy - source buffer smaller */
@@ -247,12 +246,7 @@ static void test_bufvec_cursor(void)
 				len++;
 			}
 		}
-		c2_bufvec_free(&buf);
 	}
-
-	/* free buffer pool */
-	for (i = 0; i < ARRAY_SIZE(bufs); ++i)
-		c2_bufvec_free(&bufs[i]);
 }
 
 /*
diff --git a/lib/ut/zerovec.c b/lib/ut/zerovec.c
deleted file mode 100644
index 634f71c..0000000
--- a/lib/ut/zerovec.c
+++ /dev/null
@@ -1,230 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Anand Vidwansa <Anand_Vidwansa@xyratex.com>
- * Original creation date: 09/27/2011
- */
-
-#include "lib/ut.h"
-#include "lib/vec.h"
-#include "lib/memory.h"
-#include "lib/arith.h"
-#include "lib/cdefs.h"
-
-#ifdef __KERNEL__
-#include <linux/pagemap.h> /* PAGE_CACHE_SIZE */
-#endif
-
-enum ZEROVEC_UT_VALUES {
-	ZEROVEC_UT_SEG_SIZE = C2_0VEC_ALIGN,
-	ZEROVEC_UT_SEGS_NR = 10,
-};
-
-static c2_bindex_t indices[ZEROVEC_UT_SEGS_NR];
-
-static void zerovec_init(struct c2_0vec *zvec, const c2_bcount_t seg_size)
-{
-	int rc;
-
-	rc = c2_0vec_init(zvec, ZEROVEC_UT_SEGS_NR);
-	C2_UT_ASSERT(rc == 0);
-}
-
-#ifndef __KERNEL__
-
-static c2_bcount_t counts[ZEROVEC_UT_SEGS_NR];
-
-static void zerovec_init_bvec(void)
-{
-	uint32_t		i;
-	struct c2_0vec		zvec;
-	struct c2_bufvec	bufvec;
-
-	zerovec_init(&zvec, ZEROVEC_UT_SEG_SIZE);
-
-	/* Have to manually allocate buffers for c2_bufvec that are
-	 aligned on 4k boundary. */
-	bufvec.ov_vec.v_nr = ZEROVEC_UT_SEGS_NR;
-	C2_ALLOC_ARR(bufvec.ov_vec.v_count, ZEROVEC_UT_SEGS_NR);
-	C2_UT_ASSERT(bufvec.ov_vec.v_count != NULL);
-	C2_ALLOC_ARR(bufvec.ov_buf, ZEROVEC_UT_SEGS_NR);
-	C2_UT_ASSERT(bufvec.ov_buf != NULL);
-
-	for (i = 0; i < bufvec.ov_vec.v_nr; ++i) {
-		bufvec.ov_buf[i] = c2_alloc_aligned(ZEROVEC_UT_SEG_SIZE,
-						    C2_0VEC_SHIFT);
-		C2_UT_ASSERT(bufvec.ov_buf[i] != NULL);
-		bufvec.ov_vec.v_count[i] = ZEROVEC_UT_SEG_SIZE;
-	}
-
-	for (i = 0; i < ZEROVEC_UT_SEGS_NR; ++i)
-		indices[i] = i;
-
-	c2_0vec_bvec_init(&zvec, &bufvec, indices);
-
-	/* Checks if buffer array, index array and segment count array
-	   are populated correctly. */
-	for (i = 0; i < ZEROVEC_UT_SEGS_NR; ++i) {
-		C2_UT_ASSERT(zvec.z_bvec.ov_buf[i] == bufvec.ov_buf[i]);
-		C2_UT_ASSERT(zvec.z_bvec.ov_vec.v_count[i] ==
-			     ZEROVEC_UT_SEG_SIZE);
-		C2_UT_ASSERT(zvec.z_index[i] == indices[i]);
-	}
-
-	c2_bufvec_free(&bufvec);
-	c2_0vec_fini(&zvec);
-}
-
-static void zerovec_init_bufs(void)
-{
-	char		**bufs;
-	uint32_t	  i;
-	uint64_t	  seed;
-	struct c2_0vec	  zvec;
-
-	seed = 0;
-	zerovec_init(&zvec, ZEROVEC_UT_SEG_SIZE);
-
-	C2_ALLOC_ARR(bufs, ZEROVEC_UT_SEGS_NR);
-	C2_UT_ASSERT(bufs != NULL);
-
-	for (i = 0; i < ZEROVEC_UT_SEGS_NR; ++i) {
-		bufs[i] = c2_alloc_aligned(ZEROVEC_UT_SEG_SIZE, C2_0VEC_SHIFT);
-		C2_UT_ASSERT(bufs[i] != NULL);
-		counts[i] = ZEROVEC_UT_SEG_SIZE;
-		indices[i] = c2_rnd(ZEROVEC_UT_SEGS_NR, &seed);
-	}
-
-	c2_0vec_bufs_init(&zvec, (void**)bufs, indices, counts,
-			  ZEROVEC_UT_SEGS_NR);
-
-	/* Checks if buffer array, index array and segment count array
-	   are populated correctly. */
-	for (i = 0; i < ZEROVEC_UT_SEGS_NR; ++i) {
-		C2_UT_ASSERT(zvec.z_index[i] == indices[i]);
-		C2_UT_ASSERT(zvec.z_bvec.ov_vec.v_count[i] == counts[i]);
-		C2_UT_ASSERT(zvec.z_bvec.ov_buf[i] == bufs[i]);
-	}
-	C2_UT_ASSERT(zvec.z_bvec.ov_vec.v_nr == ZEROVEC_UT_SEGS_NR);
-
-	for (i = 0; i < ZEROVEC_UT_SEGS_NR; ++i)
-		c2_free(bufs[i]);
-	c2_free(bufs);
-	c2_0vec_fini(&zvec);
-}
-
-static void zerovec_init_cbuf(void)
-{
-	int		i;
-	int		rc;
-	uint64_t	seed;
-	struct c2_buf	bufs[ZEROVEC_UT_SEGS_NR];
-	struct c2_0vec	zvec;
-
-	seed = 0;
-	zerovec_init(&zvec, ZEROVEC_UT_SEG_SIZE);
-
-	for (i = 0; i < ZEROVEC_UT_SEGS_NR; ++i) {
-		bufs[i].b_addr = c2_alloc_aligned(ZEROVEC_UT_SEG_SIZE,
-						  C2_0VEC_SHIFT);
-		C2_UT_ASSERT(bufs[i].b_addr != NULL);
-		bufs[i].b_nob = ZEROVEC_UT_SEG_SIZE;
-		indices[i] = c2_rnd(ZEROVEC_UT_SEGS_NR, &seed);
-
-		rc = c2_0vec_cbuf_add(&zvec, &bufs[i], &indices[i]);
-		C2_UT_ASSERT(rc == 0);
-	}
-
-	for (i = 0; i < ZEROVEC_UT_SEGS_NR; ++i) {
-		C2_UT_ASSERT(zvec.z_index[i] == indices[i]);
-		C2_UT_ASSERT(zvec.z_bvec.ov_buf[i] == bufs[i].b_addr);
-		C2_UT_ASSERT(zvec.z_bvec.ov_vec.v_count[i] == bufs[i].b_nob);
-	}
-
-	/* Tries to add more buffers beyond zerovec's capacity. Should fail. */
-	rc = c2_0vec_cbuf_add(&zvec, &bufs[0], &indices[0]);
-	C2_UT_ASSERT(rc == -EMSGSIZE);
-
-	C2_UT_ASSERT(zvec.z_bvec.ov_vec.v_nr == ZEROVEC_UT_SEGS_NR);
-
-	for (i = 0; i < ZEROVEC_UT_SEGS_NR; ++i)
-		c2_free(bufs[i].b_addr);
-	c2_0vec_fini(&zvec);
-}
-#else
-
-static void zerovec_init_pages(void)
-{
-	int		rc;
-	uint32_t	i;
-	uint64_t	seed;
-	struct page	**pages;
-	struct c2_0vec	zvec;
-
-	seed = 0;
-	zerovec_init(&zvec, PAGE_CACHE_SIZE);
-
-	C2_ALLOC_ARR(pages, ZEROVEC_UT_SEGS_NR);
-	C2_UT_ASSERT(pages != NULL);
-	for (i = 0; i < ZEROVEC_UT_SEGS_NR; ++i) {
-		pages[i] = alloc_page(GFP_KERNEL);
-		C2_UT_ASSERT(pages[i] != NULL);
-	}
-
-	for (i = 0; i < ZEROVEC_UT_SEGS_NR; ++i) {
-		indices[i] = c2_rnd(ZEROVEC_UT_SEGS_NR, &seed);
-		rc = c2_0vec_page_add(&zvec, pages[i], indices[i]);
-		C2_UT_ASSERT(rc == 0);
-	}
-
-	for (i = 0; i < ZEROVEC_UT_SEGS_NR; ++i) {
-		C2_UT_ASSERT(zvec.z_index[i] == indices[i]);
-		C2_UT_ASSERT(zvec.z_bvec.ov_buf[i] ==
-			     page_address(pages[i]));
-		C2_UT_ASSERT(zvec.z_bvec.ov_vec.v_count[i] == PAGE_CACHE_SIZE);
-	}
-
-	C2_UT_ASSERT(zvec.z_bvec.ov_vec.v_nr == ZEROVEC_UT_SEGS_NR);
-
-	/* Tries to add more pages beyond zerovec's capacity. Should fail. */
-	rc = c2_0vec_page_add(&zvec, pages[0], indices[0]);
-	C2_UT_ASSERT(rc == -EMSGSIZE);
-
-	for (i = 0; i < ZEROVEC_UT_SEGS_NR; ++i)
-		__free_page(pages[i]);
-	c2_free(pages);
-	c2_0vec_fini(&zvec);
-}
-#endif
-
-void test_zerovec(void)
-{
-#ifndef __KERNEL__
-	/* Populate the zero vector using a c2_bufvec structure. */
-	zerovec_init_bvec();
-
-	/* Populate the zero vector using array of buffers, indices
-	   and counts. */
-	zerovec_init_bufs();
-
-	/* Populate the zero vector using a c2_buf structure and
-	   array of indices. */
-	zerovec_init_cbuf();
-#else
-	/* Populate the zero vector using a page. */
-	zerovec_init_pages();
-#endif
-}
diff --git a/lib/vec.c b/lib/vec.c
index 7929a41..3411b68 100644
--- a/lib/vec.c
+++ b/lib/vec.c
@@ -14,7 +14,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Nikita Danilov <Nikita_Danilov@xyratex.com>
+ * Original author: Nikita Danilov
  * Original creation date: 05/12/2010
  */
 
@@ -133,7 +133,6 @@ fail:
 	c2_bufvec_free(bufvec);
 	return -ENOMEM;
 }
-C2_EXPORTED(c2_bufvec_alloc);
 
 void c2_bufvec_free(struct c2_bufvec *bufvec)
 {
@@ -149,7 +148,6 @@ void c2_bufvec_free(struct c2_bufvec *bufvec)
 		C2_SET0(bufvec);
 	}
 }
-C2_EXPORTED(c2_bufvec_free);
 
 void  c2_bufvec_cursor_init(struct c2_bufvec_cursor *cur,
 			    struct c2_bufvec *bvec)
@@ -160,21 +158,18 @@ void  c2_bufvec_cursor_init(struct c2_bufvec_cursor *cur,
 	       bvec->ov_buf != NULL);
 	c2_vec_cursor_init(&cur->bc_vc, &bvec->ov_vec);
 }
-C2_EXPORTED(c2_bufvec_cursor_init);
 
 bool c2_bufvec_cursor_move(struct c2_bufvec_cursor *cur, c2_bcount_t count)
 {
 	return c2_vec_cursor_move(&cur->bc_vc, count);
 }
-C2_EXPORTED(c2_bufvec_cursor_move);
 
 c2_bcount_t c2_bufvec_cursor_step(const struct c2_bufvec_cursor *cur)
 {
 	return c2_vec_cursor_step(&cur->bc_vc);
 }
-C2_EXPORTED(c2_bufvec_cursor_step);
 
-void *bufvec_cursor_addr(struct c2_bufvec_cursor *cur)
+static void *bufvec_cursor_addr(struct c2_bufvec_cursor *cur)
 {
 	struct c2_vec_cursor *vc = &cur->bc_vc;
 	struct c2_bufvec *bv = container_of(vc->vc_vec,struct c2_bufvec,ov_vec);
@@ -188,7 +183,6 @@ void *c2_bufvec_cursor_addr(struct c2_bufvec_cursor *cur)
 	C2_PRE(!c2_bufvec_cursor_move(cur, 0));
 	return bufvec_cursor_addr(cur);
 }
-C2_EXPORTED(c2_bufvec_cursor_addr);
 
 c2_bcount_t c2_bufvec_cursor_copy(struct c2_bufvec_cursor *dcur,
 				  struct c2_bufvec_cursor *scur,
@@ -213,151 +207,6 @@ c2_bcount_t c2_bufvec_cursor_copy(struct c2_bufvec_cursor *dcur,
 	}
 	return bytes_copied;
 }
-C2_EXPORTED(c2_bufvec_cursor_copy);
-
-void c2_0vec_fini(struct c2_0vec *zvec)
-{
-	if (zvec != NULL) {
-		c2_free(zvec->z_bvec.ov_vec.v_count);
-		c2_free(zvec->z_bvec.ov_buf);
-		c2_free(zvec->z_index);
-	}
-}
-
-static bool addr_is_4k_aligned(void *addr)
-{
-	return ((uint64_t)addr & C2_0VEC_MASK) == 0;
-}
-
-static bool c2_0vec_invariant(struct c2_0vec *zvec)
-{
-	uint32_t	  i;
-	struct c2_bufvec *bvec;
-
-	if (zvec == NULL || zvec->z_index == NULL)
-		return false;
-
-	bvec = &zvec->z_bvec;
-	if (bvec->ov_buf == NULL ||
-	    bvec->ov_vec.v_count == NULL ||
-	    bvec->ov_vec.v_nr == 0)
-		return false;
-
-	for (i = 0; i < bvec->ov_vec.v_nr; ++i)
-		/* Checks if all segments are aligned on 4k boundary
-		   and the sizes of all segments except the last one
-		   are positive multiples of 4k. */
-		if (!addr_is_4k_aligned(bvec->ov_buf[i]) ||
-		    (bvec->ov_vec.v_count[i] & C2_0VEC_MASK &&
-		     i < bvec->ov_vec.v_nr - 1))
-			return false;
-
-	return true;
-}
-
-int c2_0vec_init(struct c2_0vec *zvec, uint32_t segs_nr)
-{
-	C2_PRE(zvec != NULL);
-	C2_PRE(segs_nr != 0);
-
-	C2_SET0(zvec);
-	C2_ALLOC_ARR(zvec->z_index, segs_nr);
-	if (zvec->z_index == NULL)
-		return -ENOMEM;
-
-	C2_ALLOC_ARR(zvec->z_bvec.ov_vec.v_count, segs_nr);
-	if (zvec->z_bvec.ov_vec.v_count == NULL)
-		goto failure;
-
-	zvec->z_bvec.ov_vec.v_nr = segs_nr;
-
-	C2_ALLOC_ARR(zvec->z_bvec.ov_buf, segs_nr);
-	if (zvec->z_bvec.ov_buf == NULL)
-		goto failure;
-
-	return 0;
-failure:
-	c2_0vec_fini(zvec);
-	return -ENOMEM;
-}
-
-void c2_0vec_bvec_init(struct c2_0vec *zvec,
-		       const struct c2_bufvec *src,
-		       const c2_bindex_t *index)
-{
-	uint32_t	  i;
-	struct c2_bufvec *dst;
-
-	C2_PRE(zvec != NULL);
-	C2_PRE(src != NULL);
-	C2_PRE(index != NULL);
-	C2_PRE(src->ov_vec.v_nr <= zvec->z_bvec.ov_vec.v_nr);
-
-	dst = &zvec->z_bvec;
-	for (i = 0; i < src->ov_vec.v_nr; ++i) {
-		zvec->z_index[i] = index[i];
-		dst->ov_vec.v_count[i] = src->ov_vec.v_count[i];
-		C2_ASSERT(dst->ov_buf[i] == NULL);
-		dst->ov_buf[i] = src->ov_buf[i];
-	}
-
-	C2_POST(c2_0vec_invariant(zvec));
-}
-
-void c2_0vec_bufs_init(struct c2_0vec *zvec,
-		       void **bufs,
-		       const c2_bindex_t *index,
-		       const c2_bcount_t *counts,
-		       uint32_t segs_nr)
-{
-	uint32_t	  i;
-	struct c2_bufvec *bvec;
-
-	C2_PRE(zvec != NULL);
-	C2_PRE(bufs != NULL);
-	C2_PRE(index != NULL);
-	C2_PRE(counts != NULL);
-	C2_PRE(segs_nr != 0);
-	C2_PRE(segs_nr <= zvec->z_bvec.ov_vec.v_nr);
-
-	bvec = &zvec->z_bvec;
-
-	for (i = 0; i < segs_nr; ++i) {
-		zvec->z_index[i] = index[i];
-		bvec->ov_vec.v_count[i] = counts[i];
-		C2_ASSERT(bvec->ov_buf[i] == NULL);
-		bvec->ov_buf[i] = bufs[i];
-	}
-
-	C2_POST(c2_0vec_invariant(zvec));
-}
-
-int c2_0vec_cbuf_add(struct c2_0vec *zvec,
-		     const struct c2_buf *buf,
-		     const c2_bindex_t *index)
-{
-	uint32_t	  curr_seg;
-	struct c2_bufvec *bvec;
-
-	C2_PRE(zvec != NULL);
-	C2_PRE(buf != NULL);
-	C2_PRE(index != NULL);
-
-	bvec = &zvec->z_bvec;
-	for (curr_seg = 0; curr_seg < bvec->ov_vec.v_nr &&
-	     bvec->ov_buf[curr_seg] != NULL; ++curr_seg);
-
-	if (curr_seg == bvec->ov_vec.v_nr)
-		return -EMSGSIZE;
-
-	C2_ASSERT(bvec->ov_buf[curr_seg] == NULL);
-	bvec->ov_buf[curr_seg] = buf->b_addr;
-	bvec->ov_vec.v_count[curr_seg] = buf->b_nob;
-	zvec->z_index[curr_seg] = *index;
-
-	C2_POST(c2_0vec_invariant(zvec));
-	return 0;
-}
 
 /** @} end of vec group */
 
diff --git a/lib/vec.h b/lib/vec.h
index 7413241..b1e1702 100644
--- a/lib/vec.h
+++ b/lib/vec.h
@@ -14,7 +14,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Nikita Danilov <Nikita_Danilov@xyratex.com>
+ * Original author: Nikita Danilov
  * Original creation date: 05/12/2010
  */
 
@@ -22,11 +22,6 @@
 #define __COLIBRI_LIB_VEC_H__
 
 #include "lib/types.h"
-#include "lib/buf.h"
-
-#ifdef __KERNEL__
-#include "lib/linux_kernel/vec.h"
-#endif
 
 /**
    @defgroup vec Vectors
@@ -131,27 +126,6 @@ struct c2_bufvec {
 };
 
 /**
-   Initialize a c2_bufvec containing a single segment of the specified size.
-   The intended usage is as follows:
-
-   @code
-   void *addr;
-   c2_bcount_t buf_count;
-   struct c2_bufvec in = C2_BUFVEC_INIT_BUF(&addr, &buf_count);
-
-   buf_count = ...;
-   addr = ...;
-   @endcode
- */
-#define C2_BUFVEC_INIT_BUF(addr_ptr, count_ptr)	{	\
-	.ov_vec = {					\
-		.v_nr = 1,				\
-		.v_count = (count_ptr),			\
-	},						\
-	.ov_buf = (addr_ptr)				\
-}
-
-/**
    Allocates memory for a struct c2_bufvec.  All segments are of equal
    size.
    The internal struct c2_vec is also allocated by this routine.
@@ -237,99 +211,36 @@ c2_bcount_t c2_bufvec_cursor_copy(struct c2_bufvec_cursor *dcur,
 				  struct c2_bufvec_cursor *scur,
 				  c2_bcount_t num_bytes);
 
+struct c2_dio_cookie;
+struct c2_dio_engine;
+
 /**
-   Zero vector is a full fledged IO vector containing IO extents
-   as well as the IO buffers.
-   An invariant (c2_0vec_invariant) is maintained for c2_0vec. It
-   always checks sanity of zero vector and keeps a bound check on
-   array of IO buffers by checking buffer alignment and count check.
-
-   Zero vector is typically allocated by upper layer by following
-   the bounds of network layer (max buffer size, max segments,
-   max seg size) and adds buffers/pages later as and when needed.
+   Array of 4KB aligned areas, suitable for direct-IO.
+
+   @invariant size of every but last element of iovec is a multiple of 4KB.
  */
-struct c2_0vec {
-	/** Bufvec representing extent of IO vector and array of buffers. */
-	struct c2_bufvec	 z_bvec;
-	/** Array of indices of target object to start IO from. */
-	c2_bindex_t		*z_index;
+struct c2_diovec {
+	struct c2_bufvec      div_vec;
+	struct c2_dio_cookie *div_seg;
 };
 
 enum {
-	C2_0VEC_SHIFT = 12,
-	C2_0VEC_ALIGN = (1 << C2_0VEC_SHIFT),
-	C2_0VEC_MASK = C2_0VEC_ALIGN - 1,
+	C2_DIOVEC_SHIFT = 12,
+	C2_DIOVEC_ALIGN = (1 << C2_DIOVEC_SHIFT),
+	C2_DIOVEC_MASK  = ~(c2_bcount_t)(C2_DIOVEC_ALIGN - 1)
 };
 
-/**
-   Initialize a pre-allocated c2_0vec structure.
-   @pre zvec != NULL.
-   @param zvec The c2_0vec structure to be initialized.
-   @param segs_nr Number of segments in zero vector.
-   @post zvec->z_bvec.ov_buf != NULL &&
-   zvec->z_bvec.ov_vec.v_nr != 0 &&
-   zvec->z_bvec.ov_vec.v_count != NULL &&
-   zvec->z_index != NULL
- */
-int c2_0vec_init(struct c2_0vec *zvec, uint32_t segs_nr);
-
-/**
-   Finalize a c2_0vec structure.
-   @param The c2_0vec structure to be deallocated.
-   @see c2_0vec_init().
- */
-void c2_0vec_fini(struct c2_0vec *zvec);
-
-/**
-   Init the c2_0vec structure from given c2_bufvec structure and
-   array of indices.
-   This API does not copy data. Only pointers are copied.
-   @pre zvec != NULL && bufvec != NULL && indices != NULL.
-   @param zvec The c2_0vec structure to be initialized.
-   @param bufvec The c2_bufvec containing buffer starting addresses and
-   with number of buffers and their byte counts.
-   @param indices Target object indices to start the IO from.
-   @post c2_0vec_invariant(zvec).
- */
-void c2_0vec_bvec_init(struct c2_0vec *zvec,
-		       const struct c2_bufvec *bufvec,
-		       const c2_bindex_t *indices);
-
-/**
-   Init the c2_0vec structure from array of buffers with indices and counts.
-   This API does not copy data. Just pointers are copied.
-   @note The c2_0vec struct should be allocated by user.
-
-   @param zvec The c2_0vec structure to be initialized.
-   @param bufs Array of IO buffers.
-   @param indices Array of target object indices.
-   @param counts Array of buffer counts.
-   @param segs_nr Number of segments contained in the buf array.
-   @post c2_0vec_invariant(zvec).
- */
-void c2_0vec_bufs_init(struct c2_0vec *zvec, void **bufs,
-		       const c2_bindex_t *indices, const c2_bcount_t *counts,
-		       uint32_t segs_nr);
-
-/**
-   Add a c2_buf structure at given target index to c2_0vec structure.
-   @note The c2_0vec struct should be allocated by user.
-
-   @param zvec The c2_0vec structure to be initialized.
-   @param buf The c2_buf structure containing starting address of buffer
-   and number of bytes in buffer.
-   @param index Index of target object to start IO from.
-   @post c2_0vec_invariant(zvec).
- */
-int c2_0vec_cbuf_add(struct c2_0vec *zvec, const struct c2_buf *buf,
-		     const c2_bindex_t *index);
-
+int         c2_diovec_alloc   (struct c2_diovec *vec,
+			       void *start, c2_bcount_t nob);
+void        c2_diovec_free    (struct c2_diovec *vec);
+int         c2_diovec_register(struct c2_diovec *vec,
+			       struct c2_dio_engine *eng);
 /** @} end of vec group */
 
 /* __COLIBRI_LIB_VEC_H__ */
 #endif
 
-/*
+/* 
  *  Local variables:
  *  c-indentation-style: "K&R"
  *  c-basic-offset: 8
diff --git a/m4/xyratex.m4 b/m4/xyratex.m4
deleted file mode 100644
index f9b0308..0000000
--- a/m4/xyratex.m4
+++ /dev/null
@@ -1,40 +0,0 @@
-
-# Checking for CUnit
-AC_DEFUN([XY_CHECK_CUNIT],[
-  AH_TEMPLATE([HAVE_CUNIT], [Have cunit library])
-
-  OLD_CFLAGS=$CFLAGS
-  CFLAGS="$CFLAGS -I/usr/local/include -I/opt/local/include"
-  OLD_LIBS=$LIBS
-  LIBS="$LIBS -L/usr/local/lib -L/opt/local/lib"
-
-  CUNIT_LIBS=""
-  enable_cunit=yes
-  notfound="cannot be found!  See http://cunit.sf.net"
-
-  # Make sure that CUnit is found on Mac OS X where it is usually
-  # instalelled from ports to /opt/local
-  AC_CHECK_HEADERS([CUnit/CUnit.h CUnit/Basic.h CUnit/Automated.h], [], [
-    AC_MSG_NOTICE([CUnit headers $notfound])
-    enable_cunit=no
-    break
-  ])
-
-  if test x$enable_cunit = xyes; then
-    # Make sure that CUnit is found on Mac OS X where it is usually
-    # instalelled from ports to /opt/local
-    AC_SEARCH_LIBS([CU_basic_run_tests], [cunit], [], [
-      AC_MSG_NOTICE([CU_basic_run_tests() $notfound])
-      enable_cunit=no
-    ])
-    if test x$enable_cunit = xyes; then
-      CUNIT_LIBS=$LIBS
-      AC_DEFINE([HAVE_CUNIT], 1)
-    fi
-  fi
-
-  LIBS=$OLD_LIBS
-  CFLAGS=$OLD_CFLAGS
-  AC_SUBST([CUNIT_LIBS])
-  AM_CONDITIONAL([HAVE_CUNIT_SUPPORT], [test x$enable_cunit = xyes])
-])
diff --git a/mw/Makefile.am b/mw/Makefile.am
index 29ab5ee..ed6658d 100644
--- a/mw/Makefile.am
+++ b/mw/Makefile.am
@@ -1,4 +1,4 @@
-mwdir       = $(includedir)/colibri/mw
+mwdir       = $(includedir)/mw
 mw_HEADERS  = consensus.h
 
 EXTRA_DIST  = consensus.h
diff --git a/mw/consensus.h b/mw/consensus.h
index c04e292..7b0984d 100644
--- a/mw/consensus.h
+++ b/mw/consensus.h
@@ -14,7 +14,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Nikita Danilov <Nikita_Danilov@xyratex.com>
+ * Original author: Nikita Danilov
  * Original creation date: 04/20/2010
  */
 
diff --git a/net/.gitignore b/net/.gitignore
index 09558d1..f0c763d 100644
--- a/net/.gitignore
+++ b/net/.gitignore
@@ -1,2 +1,4 @@
-net_otw_types_k.[ch]
-net_otw_types_u.[ch]
+net_otw_types_k.c
+net_otw_types_k.h
+net_otw_types_u.c
+net_otw_types_u.h
diff --git a/net/Makefile.am b/net/Makefile.am
index db3c0b5..98579f1 100644
--- a/net/Makefile.am
+++ b/net/Makefile.am
@@ -1,30 +1,21 @@
-netdir                     = $(includedir)/colibri/net
-net_HEADERS                = net.h xdr.h net_internal.h
+netdir                     = $(includedir)/net
+net_HEADERS                = net.h net_otw_types_u.h net_otw_types_k.h xdr.h
 
 SUBDIRS                    = . usunrpc bulk_emulation
 
 noinst_LTLIBRARIES         = libcolibri-net.la
 libcolibri_net_la_SOURCES  = net.c net.h domain.c ep.c buf.c tm.c \
                              $(OTW_U_SOURCES) net_xdr.c xdr.h \
-                             net_utils.c net_cli.c net_srv.c connection.c \
-			     buffer_pool.c buffer_pool.h net_internal.h
+                             net_utils.c net_cli.c net_srv.c connection.c
 INCLUDES                   = -I. -I$(top_srcdir) -I$(top_srcdir)/include
 
 OTW_U_SOURCES              = net_otw_types_u.h net_otw_types_u.c
+#OTW_K_SOURCES              = net_otw_types_k.h net_otw_types_k.c
 MOSTLYCLEANFILES           = $(OTW_U_SOURCES) net_otw_types_k.h net_otw_types_k.c
 
-EXTRA_DIST                 = net_otw_types.ff \
-                             ksunrpc/ksunrpc.h \
-                             ksunrpc/client.c \
-                             ksunrpc/domain.c \
-                             ksunrpc/kxdr.c
-
 net.c domain.c ep.c net_utils.c net_cli.c net_srv.c connection.c: net.h
-net.h net_xdr.c: $(OTW_U_SOURCES)
-$(OTW_U_SOURCES): net_otw_types.ff \
-    $(top_builddir)/fop/rt/libc2rt.la $(top_builddir)/fop/fop2c
+net.h net_xdr.c: $(OTW_U_SOURCES) $(OTW_K_SOURCES)
+$(OTW_U_SOURCES) $(OTW_K_SOURCES): net_otw_types.ff \
+    $(top_builddir)/fop/libc2rt.la $(top_builddir)/fop/fop2c 
 	$(top_builddir)/fop/fop2c -uk $<
 
-dist-hook:
-	mkdir -p @top_builddir@/@PACKAGE@-@VERSION@/net/ksunrpc
-	cp @SRCDIR@/net/ksunrpc/ksunrpc.h @top_builddir@/@PACKAGE@-@VERSION@/net/ksunrpc
diff --git a/net/buf.c b/net/buf.c
index 7ce8dc0..b7e9e80 100644
--- a/net/buf.c
+++ b/net/buf.c
@@ -14,11 +14,10 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Carl Braganza <Carl_Braganza@us.xyratex.com>
+ * Original author: Carl Braganza
  * Original creation date: 04/05/2011
  */
 
-#include "lib/arith.h" /* max_check */
 #include "lib/assert.h"
 #include "lib/errno.h"
 #include "lib/time.h"
@@ -28,6 +27,7 @@
    @addtogroup net
    @{
  */
+
 bool c2_net__qtype_is_valid(enum c2_net_queue_type qt)
 {
 	return qt >= C2_NET_QT_MSG_RECV && qt < C2_NET_QT_NR;
@@ -76,7 +76,8 @@ bool c2_net__buffer_invariant(const struct c2_net_buffer *buf)
 		return false;
 
 	/* EXPENSIVE: on the right TM list */
-	if (!tm_tlist_contains(&buf->nb_tm->ntm_q[buf->nb_qtype], buf))
+	if (!c2_list_contains(&buf->nb_tm->ntm_q[buf->nb_qtype],
+			      &buf->nb_tm_linkage))
 		return false;
 	return true;
 }
@@ -98,9 +99,7 @@ int c2_net_buffer_register(struct c2_net_buffer *buf,
 
 	buf->nb_dom = dom;
 	buf->nb_xprt_private = NULL;
-	buf->nb_timeout = C2_TIME_NEVER;
 
-	buf->nb_magic = NET_BUFFER_LINK_MAGIC;
 	/* The transport will validate buffer size and number of
 	   segments, and optimize it for future use.
 	 */
@@ -110,16 +109,17 @@ int c2_net_buffer_register(struct c2_net_buffer *buf,
 		c2_list_add_tail(&dom->nd_registered_bufs,&buf->nb_dom_linkage);
 	}
 	C2_POST(ergo(rc == 0, c2_net__buffer_invariant(buf)));
-	C2_POST(ergo(rc == 0, buf->nb_timeout == C2_TIME_NEVER));
 
 	c2_mutex_unlock(&dom->nd_mutex);
 	return rc;
 }
 C2_EXPORTED(c2_net_buffer_register);
 
-void c2_net_buffer_deregister(struct c2_net_buffer *buf,
-			      struct c2_net_domain *dom)
+int c2_net_buffer_deregister(struct c2_net_buffer *buf,
+			     struct c2_net_domain *dom)
 {
+	int rc;
+
 	C2_PRE(dom != NULL);
 	C2_PRE(dom->nd_xprt != NULL);
 	c2_mutex_lock(&dom->nd_mutex);
@@ -128,14 +128,15 @@ void c2_net_buffer_deregister(struct c2_net_buffer *buf,
 	C2_PRE(buf->nb_flags == C2_NET_BUF_REGISTERED);
 	C2_PRE(c2_list_contains(&dom->nd_registered_bufs,&buf->nb_dom_linkage));
 
-	dom->nd_xprt->nx_ops->xo_buf_deregister(buf);
-	buf->nb_flags &= ~C2_NET_BUF_REGISTERED;
-	c2_list_del(&buf->nb_dom_linkage);
-	buf->nb_xprt_private = NULL;
-	buf->nb_magic = 0;
+	rc = dom->nd_xprt->nx_ops->xo_buf_deregister(buf);
+	if (rc == 0) {
+		buf->nb_flags &= ~C2_NET_BUF_REGISTERED;
+		c2_list_del(&buf->nb_dom_linkage);
+		buf->nb_xprt_private = NULL;
+	}
 
 	c2_mutex_unlock(&dom->nd_mutex);
-	return;
+	return rc;
 }
 C2_EXPORTED(c2_net_buffer_deregister);
 
@@ -143,7 +144,7 @@ int c2_net_buffer_add(struct c2_net_buffer *buf, struct c2_net_transfer_mc *tm)
 {
 	int rc;
 	struct c2_net_domain *dom;
-	struct c2_tl	     *ql;
+	struct c2_list *ql;
 	struct buf_add_checks {
 		bool check_length;
 		bool check_ep;
@@ -153,8 +154,8 @@ int c2_net_buffer_add(struct c2_net_buffer *buf, struct c2_net_transfer_mc *tm)
 	static const struct buf_add_checks checks[C2_NET_QT_NR] = {
 		[C2_NET_QT_MSG_RECV]          = { false, false, false, false },
 		[C2_NET_QT_MSG_SEND]          = { true,  true,  false, false },
-		[C2_NET_QT_PASSIVE_BULK_RECV] = { false, false, false, true  },
-		[C2_NET_QT_PASSIVE_BULK_SEND] = { true,  false, false, true  },
+		[C2_NET_QT_PASSIVE_BULK_RECV] = { false, true,  false, true  },
+		[C2_NET_QT_PASSIVE_BULK_SEND] = { true,  true,  false, true  },
 		[C2_NET_QT_ACTIVE_BULK_RECV]  = { false, false, true,  false },
 		[C2_NET_QT_ACTIVE_BULK_SEND]  = { true,  false, true,  false }
 	};
@@ -170,14 +171,9 @@ int c2_net_buffer_add(struct c2_net_buffer *buf, struct c2_net_transfer_mc *tm)
 	C2_PRE(dom->nd_xprt != NULL);
 
 	C2_PRE(!(buf->nb_flags &
-	       (C2_NET_BUF_QUEUED | C2_NET_BUF_IN_USE | C2_NET_BUF_CANCELLED |
-		C2_NET_BUF_TIMED_OUT | C2_NET_BUF_RETAIN)));
-	C2_PRE(ergo(buf->nb_qtype == C2_NET_QT_MSG_RECV,
-		    buf->nb_ep == NULL &&
-		    buf->nb_min_receive_size != 0 &&
-		    buf->nb_min_receive_size <=
-		                        c2_vec_count(&buf->nb_buffer.ov_vec) &&
-		    buf->nb_max_receive_msgs != 0));
+	       (C2_NET_BUF_QUEUED | C2_NET_BUF_IN_USE | C2_NET_BUF_CANCELLED)));
+
+	C2_PRE(buf->nb_qtype != C2_NET_QT_MSG_RECV || buf->nb_ep == NULL);
 	C2_PRE(tm->ntm_state == C2_NET_TM_STARTED);
 
 	/* determine what to do by queue type */
@@ -196,7 +192,7 @@ int c2_net_buffer_add(struct c2_net_buffer *buf, struct c2_net_transfer_mc *tm)
 	/* validate end point usage; increment ref count later */
 	C2_PRE(ergo(todo->check_ep,
 		    buf->nb_ep != NULL &&
-		    c2_net__ep_invariant(buf->nb_ep, tm, true)));
+		    c2_net__ep_invariant(buf->nb_ep, buf->nb_dom, false)));
 
 	/* validate that the descriptor is present */
 	if (todo->post_check_desc) {
@@ -207,27 +203,18 @@ int c2_net_buffer_add(struct c2_net_buffer *buf, struct c2_net_transfer_mc *tm)
 		    buf->nb_desc.nbd_len > 0 &&
 		    buf->nb_desc.nbd_data != NULL));
 
-	/* validate that a timeout, if set, is in the future */
-	if (buf->nb_timeout != C2_TIME_NEVER) {
-		/* Don't want to assert here as scheduling is unpredictable. */
-		if (c2_time_after_eq(c2_time_now(), buf->nb_timeout)) {
-			rc = -ETIME; /* not -ETIMEDOUT */
-			goto m_err_exit;
-		}
-	}
-
 	/* Optimistically add it to the queue's list before calling the xprt.
 	   Post will unlink on completion, or del on cancel.
 	 */
-	tm_tlink_init_at_tail(buf, ql);
+	c2_list_add_tail(ql, &buf->nb_tm_linkage);
 	buf->nb_flags |= C2_NET_BUF_QUEUED;
-	buf->nb_add_time = c2_time_now(); /* record time added */
+	(void)c2_time_now(&buf->nb_add_time); /* record time added */
 
 	/* call the transport */
 	buf->nb_tm = tm;
 	rc = dom->nd_xprt->nx_ops->xo_buf_add(buf);
 	if (rc != 0) {
-		tm_tlink_del_fini(buf);
+		c2_list_del(&buf->nb_tm_linkage);
 		buf->nb_flags &= ~C2_NET_BUF_QUEUED;
 		goto m_err_exit;
 	}
@@ -303,12 +290,6 @@ bool c2_net__buffer_event_invariant(const struct c2_net_buffer_event *ev)
 	if (!ergo(ev->nbe_buffer->nb_flags & C2_NET_BUF_CANCELLED,
 		  ev->nbe_status == -ECANCELED))
 		return false;
-	if (!ergo(ev->nbe_buffer->nb_flags & C2_NET_BUF_TIMED_OUT,
-		  ev->nbe_status == -ETIMEDOUT))
-		return false;
-	if (!ergo(ev->nbe_buffer->nb_flags & C2_NET_BUF_RETAIN,
-		  ev->nbe_status == 0))
-		return false;
 	return true;
 }
 
@@ -337,16 +318,12 @@ void c2_net_buffer_event_post(const struct c2_net_buffer_event *ev)
 	C2_PRE(c2_net__tm_invariant(tm));
 	C2_PRE(c2_net__buffer_invariant(buf));
 	C2_PRE(buf->nb_flags & C2_NET_BUF_QUEUED);
-
-	if (!(buf->nb_flags & C2_NET_BUF_RETAIN)) {
-		tm_tlist_del(buf);
-		buf->nb_flags &= ~(C2_NET_BUF_QUEUED | C2_NET_BUF_CANCELLED |
-				   C2_NET_BUF_IN_USE | C2_NET_BUF_TIMED_OUT);
-		buf->nb_timeout = C2_TIME_NEVER;
-	} else
-		buf->nb_flags &= ~C2_NET_BUF_RETAIN;
+	c2_list_del(&buf->nb_tm_linkage);
 
 	qtype = buf->nb_qtype;
+	buf->nb_flags &= ~(C2_NET_BUF_QUEUED | C2_NET_BUF_CANCELLED |
+			   C2_NET_BUF_IN_USE);
+
 	q = &tm->ntm_qstats[qtype];
 	if (ev->nbe_status < 0) {
 		q->nqs_num_f_events++;
@@ -365,6 +342,11 @@ void c2_net_buffer_event_post(const struct c2_net_buffer_event *ev)
 	q->nqs_total_bytes += len;
 	q->nqs_max_bytes = max_check(q->nqs_max_bytes, len);
 
+	cb = buf->nb_callbacks->nbc_cb[qtype];
+
+	tm->ntm_callback_counter++;
+	c2_mutex_unlock(&tm->ntm_mutex);
+
 	ep = NULL;
 	check_ep = false;
 	switch (qtype) {
@@ -375,6 +357,8 @@ void c2_net_buffer_event_post(const struct c2_net_buffer_event *ev)
 		}
 		break;
 	case C2_NET_QT_MSG_SEND:
+	case C2_NET_QT_PASSIVE_BULK_RECV:
+	case C2_NET_QT_PASSIVE_BULK_SEND:
 		/* must put() ep to match get in buffer_add() */
 		ep = buf->nb_ep;   /* from buffer */
 		break;
@@ -383,19 +367,16 @@ void c2_net_buffer_event_post(const struct c2_net_buffer_event *ev)
 	}
 
 	if (check_ep) {
-		C2_ASSERT(c2_net__ep_invariant(ep, tm, true));
+		C2_ASSERT(({
+			  bool eprc;
+			  c2_mutex_lock(&tm->ntm_dom->nd_mutex);
+			  eprc = c2_net__ep_invariant(ep, tm->ntm_dom, true);
+			  c2_mutex_unlock(&tm->ntm_dom->nd_mutex);
+			  eprc; }));
 	}
 
-	cb = buf->nb_callbacks->nbc_cb[qtype];
-	tm->ntm_callback_counter++;
-	c2_mutex_unlock(&tm->ntm_mutex);
-
 	cb(ev);
 
-	/* Decrement the reference to the ep */
-	if (ep != NULL)
-		c2_net_end_point_put(ep);
-
 	/* post callback, in mutex:
 	   decrement ref counts,
 	   signal waiters
@@ -405,8 +386,13 @@ void c2_net_buffer_event_post(const struct c2_net_buffer_event *ev)
 	c2_chan_broadcast(&tm->ntm_chan);
 	c2_mutex_unlock(&tm->ntm_mutex);
 
+	/* Decrement the reference to the ep */
+	if (ep != NULL)
+		c2_net_end_point_put(ep);
+
 	return;
 }
+C2_EXPORTED(c2_net_buffer_event_post);
 
 /** @} end of net group */
 
diff --git a/net/buffer_pool.c b/net/buffer_pool.c
deleted file mode 100644
index 4139c39..0000000
--- a/net/buffer_pool.c
+++ /dev/null
@@ -1,295 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Madhavrao Vemuri <madhav_vemuri@xyratex.com>
- * Original creation date: 10/12/2011
- */
-
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif
-#include "lib/memory.h"/* C2_ALLOC_PTR */
-#include "lib/errno.h" /* ENOMEM */
-#include "lib/arith.h" /* C2_CNT_INC, C2_CNT_DEC */
-#include "net/buffer_pool.h"
-
-/**
-   @addtogroup net_buffer_pool  Network Buffer Pool
-   @{
- */
-
-/** Descriptor for the tlist of buffers. */
-C2_TL_DESCR_DEFINE(pool, "net_buffer_pool", ,
-		   struct c2_net_buffer, nb_lru, nb_magic,
-		   NET_BUFFER_LINK_MAGIC, NET_BUFFER_HEAD_MAGIC);
-C2_TL_DEFINE(pool, , struct c2_net_buffer);
-
-static bool pool_colour_check(const struct c2_net_buffer_pool *pool);
-static bool pool_lru_buffer_check(const struct c2_net_buffer_pool *pool);
-
-bool c2_net_buffer_pool_invariant(const struct c2_net_buffer_pool *pool)
-{
-	return pool != NULL &&
-		/* domain must be set and initialized */
-		pool->nbp_ndom != NULL && pool->nbp_ndom->nd_xprt != NULL &&
-		/* must have the appropriate callback */
-		pool->nbp_ops != NULL &&
-		c2_net_buffer_pool_is_locked(pool) &&
-		pool->nbp_free <= pool->nbp_buf_nr &&
-		pool->nbp_free == pool_tlist_length(&pool->nbp_lru) &&
-		pool_colour_check(pool) &&
-		pool_lru_buffer_check(pool);
-}
-
-static bool pool_colour_check(const struct c2_net_buffer_pool *pool)
-{
-	int		      i;
-	struct c2_net_buffer *nb;
-
-	for (i = 0; i < pool->nbp_colours_nr; i++) {
-		c2_tlist_for(&tm_tl, &pool->nbp_colour[i], nb) {
-			if (!pool_tlink_is_in(nb))
-				return false;
-		} c2_tlist_endfor;
-	}
-	return true;
-}
-
-static bool pool_lru_buffer_check(const struct c2_net_buffer_pool *pool)
-{
-	struct c2_net_buffer *nb;
-	if (!pool_tlist_is_empty(&pool->nbp_lru)) {
-		c2_tlist_for(&pool_tl, &pool->nbp_lru, nb) {
-			if ((nb->nb_flags & C2_NET_BUF_QUEUED) ||
-			   !(nb->nb_flags & C2_NET_BUF_REGISTERED)) {
-				return false;
-			}
-		} c2_tlist_endfor;
-	}
-	return true;
-}
-
-void c2_net_buffer_pool_init(struct c2_net_buffer_pool *pool,
-			    struct c2_net_domain *ndom, uint32_t threshold,
-			    uint32_t seg_nr, c2_bcount_t seg_size,
-			    uint32_t colours)
-{
-	int i;
-
-	C2_PRE(pool != NULL);
-	C2_PRE(ndom != NULL);
-	C2_PRE((seg_nr * seg_size) <= c2_net_domain_get_max_buffer_size(ndom));
-	C2_PRE(seg_size <= c2_net_domain_get_max_buffer_segment_size(ndom));
-
-	pool->nbp_threshold  = threshold;
-	pool->nbp_ndom	     = ndom;
-	pool->nbp_free	     = 0;
-	pool->nbp_buf_nr     = 0;
-	pool->nbp_seg_nr     = seg_nr;
-	pool->nbp_seg_size   = seg_size;
-	pool->nbp_colours_nr = colours;
-
-	C2_ALLOC_ARR(pool->nbp_colour, colours);
-	c2_mutex_init(&pool->nbp_mutex);
-	pool_tlist_init(&pool->nbp_lru);
-	for (i = 0; i < colours; i++)
-		tm_tlist_init(&pool->nbp_colour[i]);
-}
-
-/**
-   Adds a buffer to the pool to increase the capacity.
-   @pre c2_net_buffer_pool_is_locked(pool)
- */
-bool net_buffer_pool_grow(struct c2_net_buffer_pool *pool);
-
-
-int c2_net_buffer_pool_provision(struct c2_net_buffer_pool *pool,
-				 uint32_t buf_nr)
-{
-	int buffers = 0;
-
-	C2_PRE(pool != NULL);
-	C2_PRE(c2_net_buffer_pool_invariant(pool));
-
-	while (buf_nr--) {
-		buffers++;
-		C2_CNT_INC(pool->nbp_buf_nr);
-		if (!net_buffer_pool_grow(pool))
-			return buffers;
-	}
-	C2_POST(c2_net_buffer_pool_invariant(pool));
-	return buffers;
-}
-
-/** It removes the given buffer from the pool */
-void buffer_remove(struct c2_net_buffer_pool *pool, struct c2_net_buffer *nb)
-{
-	pool_tlink_del_fini(nb);
-	if (tm_tlink_is_in(nb))
-		tm_tlist_del(nb);
-	tm_tlink_fini(nb);
-	c2_net_buffer_deregister(nb, pool->nbp_ndom);
-	c2_bufvec_free(&nb->nb_buffer);
-	c2_free(nb);
-	C2_CNT_DEC(pool->nbp_buf_nr);
-	C2_POST(c2_net_buffer_pool_invariant(pool));
-}
-
-void c2_net_buffer_pool_fini(struct c2_net_buffer_pool *pool)
-{
-	int		      i;
-	struct c2_net_buffer *nb;
-
-	C2_PRE(pool != NULL);
-	C2_PRE(c2_net_buffer_pool_invariant(pool));
-	C2_PRE(pool->nbp_free == pool->nbp_buf_nr);
-
-	c2_tlist_for(&pool_tl, &pool->nbp_lru, nb) {
-		C2_ASSERT(nb != NULL);
-		C2_CNT_DEC(pool->nbp_free);
-		buffer_remove(pool, nb);
-	} c2_tlist_endfor;
-	pool_tlist_fini(&pool->nbp_lru);
-	for (i = 0; i < pool->nbp_colours_nr; i++)
-		tm_tlist_fini(&pool->nbp_colour[i]);
-	c2_free(pool->nbp_colour);
-	c2_mutex_fini(&pool->nbp_mutex);
-}
-
-void c2_net_buffer_pool_lock(struct c2_net_buffer_pool *pool)
-{
-	c2_mutex_lock(&pool->nbp_mutex);
-}
-
-bool c2_net_buffer_pool_is_locked(const struct c2_net_buffer_pool *pool)
-{
-	return c2_mutex_is_locked(&pool->nbp_mutex);
-}
-
-void c2_net_buffer_pool_unlock(struct c2_net_buffer_pool *pool)
-{
-	c2_mutex_unlock(&pool->nbp_mutex);
-}
-
-struct c2_net_buffer *c2_net_buffer_pool_get(struct c2_net_buffer_pool *pool,
-					     uint32_t colour)
-{
-	struct c2_net_buffer *nb;
-
-	C2_PRE(pool != NULL);
-	C2_PRE(c2_net_buffer_pool_invariant(pool));
-	C2_PRE(colour == ~0 || colour < pool->nbp_colours_nr);
-
-	if (pool->nbp_free <= 0)
-		return NULL;
-	if (colour != ~0 && !tm_tlist_is_empty(&pool->nbp_colour[colour]))
-		nb = tm_tlist_head(&pool->nbp_colour[colour]);
-	else
-		nb = pool_tlist_head(&pool->nbp_lru);
-	C2_ASSERT(nb != NULL);
-	pool_tlist_del(nb);
-	if (tm_tlink_is_in(nb))
-		tm_tlist_del(nb);
-	C2_CNT_DEC(pool->nbp_free);
-	if (pool->nbp_free < pool->nbp_threshold)
-		pool->nbp_ops->nbpo_below_threshold(pool);
-
-	C2_POST(c2_net_buffer_pool_invariant(pool));
-	return nb;
-}
-
-void c2_net_buffer_pool_put(struct c2_net_buffer_pool *pool,
-			    struct c2_net_buffer *buf, uint32_t colour)
-{
-	C2_PRE(pool != NULL);
-	C2_PRE(buf != NULL);
-	C2_PRE(c2_net_buffer_pool_invariant(pool));
-	C2_PRE(colour == ~0 || colour < pool->nbp_colours_nr);
-	C2_PRE(!(buf->nb_flags & C2_NET_BUF_QUEUED));
-	C2_PRE(buf->nb_flags & C2_NET_BUF_REGISTERED);
-	C2_PRE(pool->nbp_ndom == buf->nb_dom);
-
-	C2_ASSERT(buf->nb_magic == NET_BUFFER_LINK_MAGIC);
-	C2_ASSERT(!pool_tlink_is_in(buf));
-	if (colour != ~0) {
-		C2_ASSERT(!tm_tlink_is_in(buf));
-		tm_tlist_add(&pool->nbp_colour[colour], buf);
-	}
-	pool_tlist_add_tail(&pool->nbp_lru, buf);
-	C2_CNT_INC(pool->nbp_free);
-	if (pool->nbp_free == 1)
-		pool->nbp_ops->nbpo_not_empty(pool);
-	C2_POST(c2_net_buffer_pool_invariant(pool));
-}
-
-bool net_buffer_pool_grow(struct c2_net_buffer_pool *pool)
-{
-	int		      rc;
-	struct c2_net_buffer *nb;
-
-	C2_PRE(c2_net_buffer_pool_invariant(pool));
-
-	C2_ALLOC_PTR(nb);
-	if (nb == NULL)
-		return false;
-	rc = c2_bufvec_alloc(&nb->nb_buffer, pool->nbp_seg_nr,
-			      pool->nbp_seg_size);
-	if (rc != 0)
-		goto clean;
-	rc = c2_net_buffer_register(nb, pool->nbp_ndom);
-	if (rc != 0)
-		goto clean;
-	pool_tlink_init(nb);
-	tm_tlink_init(nb);
-
-	c2_net_buffer_pool_put(pool, nb, ~0);
-	C2_POST(c2_net_buffer_pool_invariant(pool));
-	return true;
-clean:
-	if (rc != 0 && nb != NULL) {
-		c2_bufvec_free(&nb->nb_buffer);
-		c2_free(nb);
-	}
-	return false;
-}
-
-bool c2_net_buffer_pool_prune(struct c2_net_buffer_pool *pool)
-{
-	struct c2_net_buffer *nb;
-
-	C2_PRE(pool != NULL);
-	C2_PRE(c2_net_buffer_pool_invariant(pool));
-
-	if (pool->nbp_free <= pool->nbp_threshold)
-		return false;
-	C2_CNT_DEC(pool->nbp_free);
-	nb = pool_tlist_head(&pool->nbp_lru);
-	C2_ASSERT(nb != NULL);
-	buffer_remove(pool, nb);
-	return true;
-}
-
-/** @} end of net_buffer_pool */
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
diff --git a/net/buffer_pool.h b/net/buffer_pool.h
deleted file mode 100644
index 9ab6ac2..0000000
--- a/net/buffer_pool.h
+++ /dev/null
@@ -1,260 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Madhavrao Vemuri <madhav_vemuri@xyratex.com>
- * Original creation date: 10/12/2011
- */
-
-#ifndef __COLIBRI_BUFFER_POOL_H__
-#define __COLIBRI_BUFFER_POOL_H__
-
-#include "lib/types.h" /* uint64_t */
-#include "lib/mutex.h"
-#include "net/net.h"   /* c2_net_buffer, c2_net_domain */
-#include "lib/tlist.h"
-
-/**
-   @defgroup net_buffer_pool Network Buffer Pool
-
-   @brief Network buffer pool allocates and manages a pool of network buffers.
-	  Users request a buffer from the pool and after its usage is over
-	  gives back to the pool.
-
-	  It provides suppport for a pool of network buffers involving no higher
-	  level interfaces than the network module itself.
-	  It is associated with a single network domain.
-	  Non-blocking interfaces are available to get and put network buffers.
-	  Call-backs are provided to announce when the pool is non-empty or
-	  low on free buffers.
-
-	  Upon receiving the not_empty call back user can put back buffers which
-	  are not in use into the pool.
-
-	  The "coloured" variant of the get operation is done by returning the
-	  most recently used buffer that is associated with a specific colour
-	  (transfer machine), or if none such are found, the least recently
-	  used buffer from the pool, if any.
-
-	  Pool is protected by a lock, to get or put a buffer into the pool user
-	  must acquire the lock and release the lock once its usage is over.
-
-	  To finalize the pool all the buffers must be returned back to the pool
-	  (i.e number of free buffers must be equal to the total number of
-	   buffers).
-
- To describe a typical buffer pool usage pattern, suppose that one wants
- a buffer pool of 10, size of each segment is 1024, number of segments is
- 64 and threshold is 10.
-
-    First, user needs to provide c2_net_buffer_pool_ops:
-    @code
-	struct c2_net_buffer_pool_ops b_ops = {
-		.nbpo_not_empty	      = notempty,
-		.nbpo_below_threshold = low,
-	};
-    @endcode
-
-   - Then, buffer pool needs to be assigned to a network domain and initialized
-	with above values:
-    @code
-	struct c2_net_buffer_pool bp;
-	struct c2_net_xprt *xprt;
-	...
-	bp.nbp_ops = &b_ops;
-	c2_net_buffer_pool_init(&bp, bp.nbp_ndom, 10, 64, 4096, 10);
-	...
-    @endcode
-
-   - Now, to add buffers into the pool need to acquire the lock and then specify
-	the number of buffers to be added:
-    @code
-	c2_net_buffer_pool_lock(&bp);
-	c2_net_buffer_pool_provision(&bp, 10);
-	c2_net_buffer_pool_unlock(&bp);
-    @endcode
-
-    - To add a buffer in the pool:
-    @code
-	c2_net_buffer_pool_lock(&bp);
-	c2_net_buffer_pool_provision(&bp, 1);
-	c2_net_buffer_pool_unlock(&bp);
-    @endcode
-
-    - To get a buffer from the pool:
-	For any colour buffer variable colour should be ~0.
-    @code
-	c2_net_buffer_pool_lock(&bp);
-	nb = c2_net_buffer_pool_get(&bp, colour);
-	if (nb != NULL)
-		"Use the buffer"
-	else
-		"goto sleep until buffer is available"
-	c2_net_buffer_pool_unlock(&bp);
-    @endcode
-
-   - To put back the buffer in the pool:
-	For any colour buffer variable colour should be ~0.
-    @code
-	c2_net_buffer_pool_lock(&bp);
-	c2_net_buffer_pool_put(&bp, nb, colour);
-	c2_net_buffer_pool_unlock(&bp);
-    @endcode
-
-    - To remove a buffer from the pool:
-    @code
-	c2_net_buffer_pool_lock(&bp);
-	c2_net_buffer_pool_prune(&bp);
-	c2_net_buffer_pool_unlock(&bp);
-    @endcode
-
-    - To finalize the pool:
-    @code
-	c2_net_buffer_pool_lock(&bp);
-	c2_net_buffer_pool_fini(&bp);
-	c2_net_buffer_pool_unlock(&bp);
-    @endcode
-   @{
-  */
-
-struct c2_net_buffer_pool;
-
-/** Call backs that buffer pool can trigger on different memory conditions. */
-struct c2_net_buffer_pool_ops {
-	/** Buffer pool is not empty. */
-	void (*nbpo_not_empty)(struct c2_net_buffer_pool *);
-	/** Buffers in pool are lower than threshold. */
-	void (*nbpo_below_threshold)(struct c2_net_buffer_pool *);
-};
-
-/** Checks the buffer pool. */
-bool c2_net_buffer_pool_invariant(const struct c2_net_buffer_pool *pool);
-
-/**
-   Initializes fields of a buffer pool and tlist, which are used to populate
-   the pool using c2_net_buffer_pool_provision().
-   @pre ndom != NULL
-   @param threshold Number of buffer below which to notify the user.
-   @param seg_nr    Number of segments in each buffer.
-   @param colours   Number of colours in the pool.
-   @param seg_size  Size of each segment in a buffer.
-   @pre (seg_nr * seg_size) <= c2_net_domain_get_max_buffer_size(ndom) &&
-	seg_size <= c2_net_domain_get_max_buffer_segment_size(ndom)
-   @post c2_net_buffer_pool_invariant(pool)
- */
-void c2_net_buffer_pool_init(struct c2_net_buffer_pool *pool,
-			    struct c2_net_domain *ndom, uint32_t threshold,
-			    uint32_t seg_nr, c2_bcount_t seg_size,
-			    uint32_t colours);
-
-/**
-   It adds the buf_nr buffers in the buffer pool.
-   Suppose to add 10 items to the pool, c2_net_buffer_pool_provison(pool, 10)
-   can be used.
-   @pre c2_net_buffer_pool_is_locked(pool)
-   @pre seg_size > 0 && seg_nr > 0 && buf_nr > 0
-   @pre pool->nbp_ndom != NULL
-   @param buf_nr Number of buffers to be added in the pool.
-   @return result number of buffers it managed to allocate.
-*/
-int c2_net_buffer_pool_provision(struct c2_net_buffer_pool *pool,
-				 uint32_t buf_nr);
-/** Finalizes a buffer pool.
-   @pre c2_net_buffer_pool_is_locked(pool)
- */
-void c2_net_buffer_pool_fini(struct c2_net_buffer_pool *pool);
-
-/** Acquires the lock on buffer pool. */
-void c2_net_buffer_pool_lock(struct c2_net_buffer_pool *pool);
-
-/** Check whether buffer pool is locked or not. */
-bool c2_net_buffer_pool_is_locked(const struct c2_net_buffer_pool *pool);
-
-/** Releases the lock on buffer pool. */
-void c2_net_buffer_pool_unlock(struct c2_net_buffer_pool *pool);
-
-/**
-   Gets a buffer from the pool.
-   If the colour is specified (i.e non zero) and the corrsponding coloured
-   list is not empty then the buffer is taken from the head of this list.
-   Otherwise the buffer is taken from the head of the per buffer pool list.
-   @pre c2_net_buffer_pool_is_locked(pool)
-   @pre colour == ~0 || colour < pool->nbp_colours_nr
-   @post ergo(result != NULL, result->nb_flags & C2_NET_BUF_REGISTERED)
- */
-struct c2_net_buffer *c2_net_buffer_pool_get(struct c2_net_buffer_pool *pool,
-					     uint32_t colour);
-
-/**
-   Puts the buffer back to the pool.
-   If the colour is specfied then the buffer is put at the head of corresponding
-   coloured list and also put at the tail of the global list.
-   @pre c2_net_buffer_pool_is_locked(pool)
-   @pre colour == ~0 || colour < pool->nbp_colours_nr
-   @pre pool->nbp_ndom == buf->nb_dom
-   @pre (buf->nb_flags & C2_NET_BUF_REGISTERED) &&
-        !(buf->nb_flags & C2_NET_BUF_QUEUED)
- */
-void c2_net_buffer_pool_put(struct c2_net_buffer_pool *pool,
-			    struct c2_net_buffer *buf, uint32_t colour);
-
-/**
-   Removes a buffer from the pool to prune it.
-   @pre c2_net_buffer_pool_is_locked(pool)
- */
-bool c2_net_buffer_pool_prune(struct c2_net_buffer_pool *pool);
-
-/** Buffer pool. */
-struct c2_net_buffer_pool {
-	/** Number of free buffers in the pool. */
-	uint32_t			     nbp_free;
-	/** Number of buffer below which low memory condition occurs. */
-	uint32_t			     nbp_threshold;
-	/** Number of segments in each buffer of the pool. */
-	uint32_t			     nbp_seg_nr;
-	/** Number of buffers in the pool. */
-	uint32_t			     nbp_buf_nr;
-	/** Size of buffer segment of the pool. */
-	c2_bcount_t			     nbp_seg_size;
-	/** Buffer pool lock to protect and synchronize network buffer list.
-	    It needs to acquired to do any changes to the pool
-	 */
-	struct c2_mutex			     nbp_mutex;
-	/** Network domain to register the buffers. */
-	struct c2_net_domain		    *nbp_ndom;
-	/** Call back operations can be triggered by buffer pool. */
-	const struct c2_net_buffer_pool_ops *nbp_ops;
-	/** Number of colours in the pool. */
-	uint32_t			     nbp_colours_nr;
-	/** An array of nbp_colours_nr lists of buffers.
-	    Each list in the array contains buffers of a particular
-	    colour. Lists are maintained in LIFO order (i.e., they are stacks)
-	    to improve temporal locality of reference.
-	    Buffers are linked through c2_net_buffer::nb_tm_linkage to these
-	    lists.
-	*/
-	struct c2_tl			    *nbp_colour;
-	/**
-	   A list of all buffers in the pool.
-	   This list is maintained in LRU order. The head of this list (which is
-	   the buffer used longest time ago) is used when coloured array is
-	   empty.
-	   Buffers are linked through c2_net_buffer::nb_lru to this list.
-	 */
-	struct c2_tl			     nbp_lru;
-};
-
-/** @} end of net_buffer_pool */
-#endif
diff --git a/net/bulk_emulation/.gitignore b/net/bulk_emulation/.gitignore
index e8b74e8..ba35248 100644
--- a/net/bulk_emulation/.gitignore
+++ b/net/bulk_emulation/.gitignore
@@ -1,2 +1,4 @@
-sunrpc_io_k.[ch]
-sunrpc_io_u.[ch]
+sunrpc_io_k.c
+sunrpc_io_k.h
+sunrpc_io_u.c
+sunrpc_io_u.h
diff --git a/net/bulk_emulation/Makefile.am b/net/bulk_emulation/Makefile.am
index bda2ebd..50d1e0b 100644
--- a/net/bulk_emulation/Makefile.am
+++ b/net/bulk_emulation/Makefile.am
@@ -2,33 +2,30 @@ noinst_LTLIBRARIES                = libcolibri-net-bulkmem.la \
                                     libcolibri-net-bulksunrpc.la
 INCLUDES                          = -I. -I$(top_srcdir) -I$(top_srcdir)/include
 
-libcolibri_net_bulkmem_la_SOURCES = mem_xprt_xo.c ../bulk_mem.h mem_xprt.h
+libcolibri_net_bulkmem_la_SOURCES = mem_xprt_xo.c $(bulkmem_HEADERS)
+
+bulkmemdir                        = $(topdir)/net/bulk_emulation
+bulkmem_HEADERS                   = ../bulk_mem.h mem_xprt.h
 
 # depend on included .c files (do not add to _SOURCES) and pvt header
 mem_xprt_xo.c: mem_xprt_ep.c mem_xprt_tm.c mem_xprt_msg.c mem_xprt_bulk.c \
 		mem_xprt_pvt.h
 
 libcolibri_net_bulksunrpc_la_SOURCES = \
-   sunrpc_xprt_xo.c ../bulk_sunrpc.h sunrpc_xprt.h $(bulksunrpc_U_SOURCES)
+   sunrpc_xprt_xo.c $(bulksunrpc_HEADERS) $(bulksunrpc_U_SOURCES)
 
+bulksunrpcdir                     = $(topdir)/net/bulk_emulation
+bulksunrpc_HEADERS                = ../bulk_sunrpc.h sunrpc_xprt.h
 bulksunrpc_U_SOURCES              = sunrpc_io_u.h sunrpc_io_u.c
+bulksunrpc_K_sources              = sunrpc_io_k.h sunrpc_io_k.c
 
 # depend on included .c files (do not add to _SOURCES) and pvt header
 sunrpc_xprt_xo.c: sunrpc_xprt_bulk.c sunrpc_xprt_ep.c sunrpc_xprt_msg.c \
 		sunrpc_xprt_tm.c sunrpc_xprt_pvt.h
 
-EXTRA_DIST                 = sunrpc_xprt_bulk.c sunrpc_xprt_ep.c sunrpc_xprt_msg.c \
-                             sunrpc_xprt_tm.c sunrpc_xprt_pvt.h mem_xprt_ep.c \
-                             mem_xprt_bulk.c mem_xprt_msg.c mem_xprt_pvt.h \
-                             mem_xprt_tm.c ksunrpc_server.c sunrpc_io.ff
-
-MOSTLYCLEANFILES           = $(bulksunrpc_U_SOURCES)
+MOSTLYCLEANFILES           = $(bulksunrpc_U_SOURCES) $(bulksunrpc_K_sources)
 
 sunrpc_xprt_pvt.h: $(bulksunrpc_U_SOURCES)
-$(bulksunrpc_U_SOURCES): sunrpc_io.ff \
-    $(top_builddir)/fop/rt/libc2rt.la $(top_builddir)/fop/fop2c
+$(bulksunrpc_U_SOURCES) $(bulksunrpc_K_sources): sunrpc_io.ff \
+    $(top_builddir)/fop/libc2rt.la $(top_builddir)/fop/fop2c
 	$(top_builddir)/fop/fop2c -uk $<
-
-clean-local:
-	cd @SRCDIR@/net/bulk_emulation ; \
-	rm -fr sunrpc_io_[uk].[hc]
diff --git a/net/bulk_emulation/ksunrpc_server.c b/net/bulk_emulation/ksunrpc_server.c
deleted file mode 100644
index 7c226ac..0000000
--- a/net/bulk_emulation/ksunrpc_server.c
+++ /dev/null
@@ -1,509 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2012 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: David Cohrs <dave_cohrs@xyratex.com>
- * Original creation date: 06/06/2011
- */
-
-#ifdef HAVE_CONFIG_H
-#  include <config.h>
-#endif
-
-#include <linux/kernel.h>
-#include <linux/freezer.h>
-#include <linux/string.h>
-#include <linux/sunrpc/stats.h>
-#include <linux/sunrpc/svc.h>
-#include <linux/sunrpc/svcsock.h>
-#ifdef HAVE_STRUCT_NET
-#include <net/net_namespace.h>
-#endif
-
-#include "lib/assert.h"
-#include "lib/errno.h"
-#include "lib/memory.h"
-#include "lib/thread.h"
-#include "fop/fop.h"
-#include "addb/addb.h"
-
-#include "ksunrpc.h"
-#include "sunrpc_io_k.h"
-#include "net/bulk_emulation/sunrpc_xprt.h"
-#include "rpc/rpc_opcodes.h"
-
-/**
-   @addtogroup ksunrpc Sun RPC
-
-   Sunrpc server implementation.  Based on the design of user-level
-   sunrpc server implementation.  There is no scheduler thread in the kernel
-   implementation; the kernel sunrpc framework provides that functionality.
-
-   In addition, this implementation only provides support for bulk_emulation.
-   As such, since the message procedures supported are so small, only a single
-   worker thread is used.  This limited implementation also avoids the need to
-   extend fop2c to generate tables required by kernel sunrpc for the deprecated
-   sunrpc transport.
-
-   @{
- */
-
-enum {
-	KSUNRPC_XDRSIZE = 1024,
-	KSUNRPC_BUFSIZE = C2_NET_BULK_SUNRPC_MAX_BUFFER_SIZE + KSUNRPC_XDRSIZE,
-	KSUNRPC_MAXCONN = 1024,
-};
-
-static struct svc_program ksunrpc_program;
-
-/* dummy structures for RPC NULL procedure */
-struct sunrpc_null { int dummy; };
-struct sunrpc_null_resp { int dummy; };
-
-static const struct c2_addb_loc ksunrpc_addb_server = {
-	.al_name = "ksunrpc-server"
-};
-
-C2_ADDB_EV_DEFINE(ksunrpc_addb_req,       "req",
-		  C2_ADDB_EVENT_USUNRPC_REQ, C2_ADDB_STAMP);
-C2_ADDB_EV_DEFINE(ksunrpc_addb_opnotsupp, "EOPNOTSUPP",
-		  C2_ADDB_EVENT_USUNRPC_OPNOTSURPPORT, C2_ADDB_INVAL);
-
-#define ADDB_ADD(service, ev, ...) \
-C2_ADDB_ADD(&(service)->s_addb, &ksunrpc_addb_server, ev , ## __VA_ARGS__)
-
-#define ADDB_CALL(service, name, rc)				\
-C2_ADDB_ADD(&(service)->s_addb, &ksunrpc_addb_server,		\
-            c2_addb_func_fail, (name), (rc))
-
-static struct c2_list ksunrpc_svc_list;
-static struct c2_rwlock ksunrpc_lock;
-
-extern struct c2_fop_type sunrpc_get_resp_fopt;
-
-struct ksunrpc_service {
-	/**
-	   back-pointer to c2_service
-	 */
-	struct c2_service      *s_service;
-	/**
-	   SUNRPC service handle for this service
-	 */
-	struct svc_serv	       *s_serv;
-	/**
-	   SUNRPC request handle for this service
-	 */
-	struct svc_rqst	       *s_rqst;
-	/**
-	   Response fop to be freed after response is sent
-	 */
-	struct c2_fop          *s_resfop;
-	/**
-	   worker thread handle
-	 */
-	struct c2_thread	s_worker_thread;
-	/**
-	   The service is being shut down.
-	 */
-	bool			s_shutdown;
-	/**
-	   Service mutex, must be held across various sunrpc svc calls.
-	 */
-	struct c2_mutex		s_svc_mutex;
-	/**
-	   ksunrpc service link list
-	 */
-	struct c2_list_link     s_svc_link;
-};
-
-/**
-   Allow all access in this limited implementation.
- */
-static int ksunrpc_authenticate(struct svc_rqst *req)
-{
-	return SVC_OK;
-}
-
-/**
-   Process a single RPC request.
- */
-static void ksunrpc_proc(struct c2_service *service,
-			struct c2_fop *arg, struct c2_fop **ret)
-{
-        bool sleeping = false;
-	c2_net_domain_stats_collect(service->s_domain, NS_STATS_IN,
-				    arg->f_type->ft_top->fft_layout->fm_sizeof,
-				    &sleeping);
-	*ret = NULL;
-	service->s_handler(service, arg, ret);
-}
-
-/**
-   Release data allocated within a response fop. Kernel has no generic
-   xdr_free mechanism and even if it did, the pages pinned must also be
-   released.
- */
-static void ksunrpc_fop_release(struct c2_fop *fop)
-{
-	if (fop != NULL && fop->f_type == &sunrpc_get_resp_fopt) {
-		struct sunrpc_get_resp *ex = c2_fop_data(fop);
-		if (ex->sgr_buf.sb_buf != NULL)
-			sunrpc_buffer_fini(&ex->sgr_buf);
-	}
-}
-
-static int ksunrpc_op(struct c2_service *service,
-		      struct c2_fop_type *fopt, struct svc_rqst *req)
-{
-	struct ksunrpc_service *xs = service->s_xport_private;
-	struct c2_fop *arg;
-	struct c2_fop *ret;
-	int rc;
-
-	arg = c2_fop_alloc(fopt, NULL);
-	if (arg != NULL) {
-		struct kvec *argv = &req->rq_arg.head[0];
-		struct kvec *resv = &req->rq_res.head[0];
-
-		rc = c2_svc_rqst_dec(req, argv->iov_base, arg);
-		if (rc == 0) {
-			ksunrpc_proc(service, arg, &ret);
-			if (ret != NULL) {
-				rc = c2_svc_rqst_enc(req,
-					resv->iov_base + resv->iov_len, ret);
-				if (rc != 0)
-					ADDB_CALL(service, "rqst_enc", rc);
-				xs->s_resfop = ret; /* delay release */
-			} else {
-				ADDB_ADD(service, c2_addb_oom);
-				rc = -ENOMEM;
-			}
-		} else {
-			ADDB_CALL(service, "rqst_dec", rc);
-		}
-		c2_fop_free(arg);
-	} else {
-		ADDB_ADD(service, c2_addb_oom);
-		rc = -ENOMEM;
-	}
-	return rc;
-}
-
-static int ksunrpc_dispatch(struct svc_rqst *req, __be32 *statp)
-{
-	struct c2_net_op_table  *tab;
-	struct c2_fop_type      *fopt;
-	struct c2_service       *service = NULL;
-	struct ksunrpc_service  *xs;
-
-	c2_rwlock_read_lock(&ksunrpc_lock);
-	c2_list_for_each_entry(&ksunrpc_svc_list,
-			       xs, struct ksunrpc_service, s_svc_link) {
-		if (xs->s_rqst == req) {
-			service = xs->s_service;
-			break;
-		}
-	}
-	c2_rwlock_read_unlock(&ksunrpc_lock);
-	C2_ASSERT(service != NULL);
-
-	ADDB_ADD(service, ksunrpc_addb_req);
-	tab = &service->s_table;
-	if (tab->not_start <= req->rq_proc &&
-	    req->rq_proc < tab->not_start + tab->not_nr) {
-		int rc;
-		fopt = tab->not_fopt[req->rq_proc - tab->not_start];
-		C2_ASSERT(fopt != NULL);
-		rc = ksunrpc_op(service, fopt, req);
-		if (rc == 0)
-			*statp = rpc_success;
-		else
-			*statp = rpc_system_err;
-	} else if (req->rq_proc == 0) { /* NULLPROC */
-		*statp = rpc_success;
-	} else {
-		ADDB_ADD(service, ksunrpc_addb_opnotsupp, -EOPNOTSUPP);
-		*statp = rpc_proc_unavail;
-	}
-	/* 0 == dropit, non-zero means send response */
-	return 1;
-}
-
-static void ksunrpc_worker(struct c2_service *service)
-{
-	struct ksunrpc_service *xs = service->s_xport_private;
-
-	/* try_to_freeze() is called from svc_recv() */
-	set_freezable();
-
-	while (!xs->s_shutdown) {
-		int rc;
-		long timeout = msecs_to_jiffies(1000);
-
-		rc = svc_recv(xs->s_rqst, timeout);
-		if (rc == -EAGAIN || rc == -EINTR) {
-			continue;
-		} else if (rc < 0) {
-			ADDB_CALL(service, "svc_recv", rc);
-			schedule_timeout_interruptible(HZ);
-			continue;
-		}
-		svc_process(xs->s_rqst);
-		if (xs->s_resfop != NULL) {
-			ksunrpc_fop_release(xs->s_resfop);
-			c2_fop_free(xs->s_resfop);
-			xs->s_resfop = NULL;
-		}
-	}
-}
-
-static void ksunrpc_service_stop(struct ksunrpc_service *xs)
-{
-	xs->s_shutdown = true;
-
-	if (xs->s_worker_thread.t_func != NULL) {
-		c2_thread_join(&xs->s_worker_thread);
-		c2_thread_fini(&xs->s_worker_thread);
-	}
-
-	/* svc_* functions require protection by a mutex or BKL */
-	c2_mutex_lock(&xs->s_svc_mutex);
-	if (xs->s_rqst != NULL) {
-		svc_exit_thread(xs->s_rqst); /* calls svc_destroy */
-		xs->s_rqst = NULL;
-	}
-	xs->s_serv = NULL;
-	c2_mutex_unlock(&xs->s_svc_mutex);
-}
-
-static int ksunrpc_service_start(struct c2_service *service,
-				 struct ksunrpc_service_id *xid)
-{
-	struct ksunrpc_service *xs = service->s_xport_private;
-	struct svc_serv *serv;
-	struct svc_rqst *rqst;
-	int rc = 0;
-
-	C2_ASSERT(xs->s_serv == NULL);
-	C2_ASSERT(xid->ssi_ver == C2_DEF_RPC_VER);
-
-	/* svc_* functions require protection by a mutex or BKL */
-	c2_mutex_lock(&xs->s_svc_mutex);
-
-	serv = svc_create(&ksunrpc_program, KSUNRPC_BUFSIZE, NULL);
-	if (serv == NULL) {
-		rc = -ENOMEM;
-		ADDB_ADD(service, c2_addb_oom);
-		goto done;
-	}
-	xs->s_serv = serv;
-
-	/* create transport/socket */
-#ifdef HAVE_STRUCT_NET
-	rc = svc_create_xprt(serv, "tcp", &init_net, PF_INET, xid->ssi_port,
-			     SVC_SOCK_DEFAULTS);
-#else
-	rc = svc_create_xprt(serv, "tcp", PF_INET, xid->ssi_port,
-			     SVC_SOCK_DEFAULTS);
-#endif
-	if (rc < 0) {
-		ADDB_CALL(service, "svc_create_xprt", rc);
-		goto done;
-	}
-
-	/* set up for creating worker thread */
-	rqst = svc_prepare_thread(serv, &serv->sv_pools[0]);
-	if (IS_ERR(rqst)) {
-		rc = PTR_ERR(rqst);
-		ADDB_CALL(service, "svc_prepare_thread", rc);
-		goto done;
-	}
-	xs->s_rqst = rqst;
-	svc_sock_update_bufs(serv);
-	serv->sv_maxconn = KSUNRPC_MAXCONN;
-
-	/* create the worker thread */
-	rc = C2_THREAD_INIT(&xs->s_worker_thread, struct c2_service *, NULL,
-		            &ksunrpc_worker, service, "ksunrpc_worker");
-        if (rc != 0) {
-		ADDB_CALL(service, "ksunrpc_worker", rc);
-		goto done;
-	}
-done:
-	/* svc_destroy is a "put" and both svc_create and svc_prepare_thread
-	   act like "get", so must always call svc_destroy once here; this
-	   thread no longer uses the svc_serv.
-	 */
-	if (xs->s_serv != NULL)
-		svc_destroy(xs->s_serv);
-	c2_mutex_unlock(&xs->s_svc_mutex);
-
-	if (rc < 0)
-		ksunrpc_service_stop(xs);
-	return rc;
-}
-
-static void ksunrpc_service_fini(struct c2_service *service)
-{
-	struct ksunrpc_service *xs = service->s_xport_private;
-
-	ksunrpc_service_stop(xs);
-
-	C2_ASSERT(xs->s_serv == NULL);
-	c2_rwlock_write_lock(&ksunrpc_lock);
-	c2_list_del(&xs->s_svc_link);
-	c2_rwlock_write_unlock(&ksunrpc_lock);
-	c2_list_link_fini(&xs->s_svc_link);
-	c2_mutex_fini(&xs->s_svc_mutex);
-	c2_free(xs);
-}
-
-int ksunrpc_service_init(struct c2_service *service)
-{
-	struct ksunrpc_service    *xs;
-	struct ksunrpc_service_id *xid;
-	int                        result;
-
-	C2_ALLOC_PTR(xs);
-	if (xs != NULL) {
-		c2_mutex_init(&xs->s_svc_mutex);
-		c2_list_link_init(&xs->s_svc_link);
-		xs->s_service = service;
-		service->s_xport_private = xs;
-		service->s_ops = &ksunrpc_service_ops;
-		xid = service->s_id->si_xport_private;
-		C2_ASSERT(service->s_id->si_ops == &ksunrpc_service_id_ops);
-		result = ksunrpc_service_start(service, xid);
-		if (result == 0) {
-			c2_rwlock_write_lock(&ksunrpc_lock);
-			c2_list_add(&ksunrpc_svc_list, &xs->s_svc_link);
-			c2_rwlock_write_unlock(&ksunrpc_lock);
-		} else {
-			c2_free(xs);
-			service->s_xport_private = NULL;
-		}
-	} else {
-		ADDB_ADD(service, c2_addb_oom);
-		result = -ENOMEM;
-	}
-	return result;
-}
-
-/**
-   Implementation of c2_service_ops::sio_reply_post.
- */
-static void ksunrpc_reply_post(struct c2_service *service,
-			       struct c2_fop *fop, void *cookie)
-{
-	struct c2_fop **ret = cookie;
-
-	C2_ASSERT(*ret == NULL);
-	*ret = fop;
-}
-
-int ksunrpc_server_init(void)
-{
-	c2_rwlock_init(&ksunrpc_lock);
-	c2_list_init(&ksunrpc_svc_list);
-	return 0;
-}
-
-void ksunrpc_server_fini(void)
-{
-	c2_list_fini(&ksunrpc_svc_list);
-	c2_rwlock_fini(&ksunrpc_lock);
-}
-
-const struct c2_service_ops ksunrpc_service_ops = {
-	.so_fini       = ksunrpc_service_fini,
-	.so_reply_post = ksunrpc_reply_post
-};
-
-/*
-   Note: because a custom dispatch is used, none of the functions in the table
-   below are called by svc_process(), but the svc_process() internals still
-   require the pointers to be non-NULL, even though they are not called.
- */
-#define PROC(num, name, respsize)				\
- [num] = {							\
-   .pc_func	  = (svc_procfunc) ksunrpc_proc,		\
-   .pc_decode	  = (kxdrproc_t) c2_svc_rqst_dec,		\
-   .pc_encode	  = (kxdrproc_t) c2_svc_rqst_enc,		\
-   .pc_release    = NULL,					\
-   .pc_argsize	  = sizeof(struct sunrpc_##name),		\
-   .pc_ressize	  = sizeof(struct sunrpc_##name##_resp),	\
-   .pc_xdrressize = respsize,					\
- }
-
-/**
-   Kernel sunrpc procedure table.  This would be generated by fop2c, but sunrpc
-   is deprecated, so this table required by kernel sunrpc is hard-coded.
-   Only bulk emulation procedures are supported.
- */
-static struct svc_procedure ksunrpc_procedures[] = {
-	PROC(0,  null, 1),
-	PROC(C2_BULK_SUNRPC_MSG_OPCODE, msg, sizeof(struct sunrpc_msg_resp)),
-	PROC(C2_BULK_SUNRPC_GET_OPCODE, get, 0),
-	PROC(C2_BULK_SUNRPC_PUT_OPCODE, put, sizeof(struct sunrpc_put_resp))
-};
-
-/**
-   Service version.  In this limited implementation, only a single
-   version is supported.
- */
-static struct svc_version ksunrpc_version1 = {
-	.vs_vers	= C2_DEF_RPC_VER,
-	.vs_nproc	= ARRAY_SIZE(ksunrpc_procedures),
-	.vs_proc	= ksunrpc_procedures,
-	.vs_xdrsize	= KSUNRPC_XDRSIZE,
-	.vs_dispatch    = ksunrpc_dispatch
-};
-
-/**
-   Table of versions.
- */
-static struct svc_version *ksunrpc_versions[] = {
-	[C2_DEF_RPC_VER] = &ksunrpc_version1,
-};
-
-/**
-   Service statistics
- */
-static struct svc_stat ksunrpc_svc_stats;
-
-/**
-   Sunrpc service program information
- */
-static struct svc_program ksunrpc_program = {
-	.pg_prog		= C2_SESSION_PROGRAM,
-	.pg_nvers		= ARRAY_SIZE(ksunrpc_versions),
-	.pg_vers		= ksunrpc_versions,
-	.pg_name		= "c2_service",
-	.pg_class		= "c2_service",
-	.pg_stats		= &ksunrpc_svc_stats,
-	.pg_authenticate	= ksunrpc_authenticate
-};
-
-/** @} end of group ksunrpc */
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
diff --git a/net/bulk_emulation/mem_xprt.h b/net/bulk_emulation/mem_xprt.h
index 4e26c47..30dfca0 100644
--- a/net/bulk_emulation/mem_xprt.h
+++ b/net/bulk_emulation/mem_xprt.h
@@ -14,8 +14,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Carl Braganza <Carl_Braganza@us.xyratex.com>,
- *                  Dave Cohrs <Dave_Cohrs@us.xyratex.com>
+ * Original author: Carl Braganza, Dave Cohrs
  * Original creation date: 04/12/2011
  */
 #ifndef __COLIBRI_NET_BULK_MEM_XPRT_H__
@@ -23,21 +22,6 @@
 
 #include "lib/atomic.h"
 #include "lib/thread.h"
-
-#ifdef __KERNEL__
-#include <linux/in.h>
-#include <linux/inet.h>
-
-/* The kernel does not define these types */
-typedef __be32 in_addr_t;
-typedef __be16 in_port_t;
-
-#else
-#include <sys/socket.h>
-#include <netinet/in.h>
-#include <arpa/inet.h>
-#endif
-
 #include "net/bulk_mem.h"
 
 /**
@@ -169,7 +153,7 @@ struct c2_net_bulk_mem_work_item {
 	/** Length of buffer */
 	c2_bcount_t                         xwi_nbe_length;
 
-	/** End point in received buffers or in TM state change */
+	/** End point in received buffers */
 	struct c2_net_end_point            *xwi_nbe_ep;
 };
 
@@ -278,9 +262,9 @@ struct c2_net_bulk_mem_ops {
 	c2_net_bulk_mem_work_fn_t  bmo_work_fn[C2_NET_XOP_NR];
 
 	/** Subroutine to create an end point. */
-	int (*bmo_ep_create)(struct c2_net_end_point  **epp,
-			     struct c2_net_transfer_mc *tm,
-			     const struct sockaddr_in  *sa,
+	int (*bmo_ep_create)(struct c2_net_end_point **epp,
+			     struct c2_net_domain *dom,
+			     const struct sockaddr_in *sa,
 			     uint32_t id);
 
 	/** Subroutine to allocate memory for an end point */
@@ -294,12 +278,6 @@ struct c2_net_bulk_mem_ops {
 	 */
 	void (*bmo_ep_release)(struct c2_ref *ref);
 
-	/** Subroutine to obtain a persistent reference to an end point
-	    on the end point list.  This is to aid derived transports that
-	    cache end points.
-	*/
-	void (*bmo_ep_get)(struct c2_net_end_point *ep);
-
 	/** Subroutine to add a work item to the work list */
 	void (*bmo_wi_add)(struct c2_net_bulk_mem_work_item *wi,
 			   struct c2_net_bulk_mem_tm_pvt *tp);
@@ -309,6 +287,7 @@ struct c2_net_bulk_mem_ops {
 
 	/** Subroutine to create a buffer descriptor */
 	int  (*bmo_desc_create)(struct c2_net_buf_desc *desc,
+				struct c2_net_end_point *ep,
 				struct c2_net_transfer_mc *tm,
 				enum c2_net_queue_type qt,
 				c2_bcount_t buflen,
@@ -435,18 +414,6 @@ static inline uint32_t mem_ep_sid(struct c2_net_end_point *ep)
 	return mep->xep_service_id;
 }
 
-/**
-   Function to compare two struct sockaddr_in structures.
-   @param sa1 Pointer to first structure.
-   @param sa2 Pointer to second structure.
- */
-static inline bool mem_sa_eq(const struct sockaddr_in *sa1,
-			     const struct sockaddr_in *sa2)
-{
-	return sa1->sin_addr.s_addr == sa2->sin_addr.s_addr &&
-	       sa1->sin_port        == sa2->sin_port;
-}
-
 int c2_mem_xprt_init(void);
 void c2_mem_xprt_fini(void);
 
diff --git a/net/bulk_emulation/mem_xprt_bulk.c b/net/bulk_emulation/mem_xprt_bulk.c
index 5e1d2db..3c29087 100644
--- a/net/bulk_emulation/mem_xprt_bulk.c
+++ b/net/bulk_emulation/mem_xprt_bulk.c
@@ -14,8 +14,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Carl Braganza <Carl_Braganza@us.xyratex.com>,
- *                  Dave Cohrs <Dave_Cohrs@us.xyratex.com>
+ * Original author: Carl Braganza, Dave Cohrs
  * Original creation date: 04/12/2011
  */
 
@@ -100,15 +99,20 @@ static void mem_wf_active_bulk(struct c2_net_transfer_mc *tm,
 		if (rc != 0)
 			break;
 
+		if (!mem_ep_equals_addr(tm->ntm_ep, &md->md_active)) {
+			rc = -EACCES;   /* wrong destination */
+			break;
+		}
 		if (nb->nb_qtype != inverse_qt[md->md_qt]) {
 			rc = -EPERM;    /* wrong operation */
 			break;
 		}
 
 		/* Make a local end point matching the passive address.*/
-		c2_mutex_lock(&tm->ntm_mutex);
-		rc = mem_bmo_ep_create(&match_ep, tm, &md->md_passive, 0);
-		c2_mutex_unlock(&tm->ntm_mutex);
+		c2_mutex_lock(&tm->ntm_dom->nd_mutex);
+		rc = mem_bmo_ep_create(&match_ep, tm->ntm_dom, &md->md_passive,
+				       0);
+		c2_mutex_unlock(&tm->ntm_dom->nd_mutex);
 		if (rc != 0) {
 			match_ep = NULL;
 			break;
@@ -124,13 +128,14 @@ static void mem_wf_active_bulk(struct c2_net_transfer_mc *tm,
 		 */
 
 		/* locate the passive buffer */
-		c2_tlist_for(&tm_tl, &passive_tm->ntm_q[md->md_qt], inb) {
+		c2_list_for_each_entry(&passive_tm->ntm_q[md->md_qt], inb,
+				       struct c2_net_buffer,
+				       nb_tm_linkage) {
 			if(!mem_desc_equal(&inb->nb_desc, &nb->nb_desc))
 				continue;
-			if ((inb->nb_flags & C2_NET_BUF_CANCELLED) == 0)
-				passive_nb = inb;
+			passive_nb = inb;
 			break;
-		} c2_tlist_endfor;
+		}
 		if (passive_nb == NULL) {
 			rc = -ENOENT;
 			break;
diff --git a/net/bulk_emulation/mem_xprt_ep.c b/net/bulk_emulation/mem_xprt_ep.c
index e940b16..d95fb98 100644
--- a/net/bulk_emulation/mem_xprt_ep.c
+++ b/net/bulk_emulation/mem_xprt_ep.c
@@ -14,8 +14,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Carl Braganza <Carl_Braganza@us.xyratex.com>,
- *                  Dave Cohrs <Dave_Cohrs@us.xyratex.com>
+ * Original author: Carl Braganza, Dave Cohrs
  * Original creation date: 04/12/2011
  */
 
@@ -38,12 +37,12 @@ static void mem_xo_end_point_release(struct c2_ref *ref)
 	struct c2_net_bulk_mem_domain_pvt *dp;
 
 	ep = container_of(ref, struct c2_net_end_point, nep_ref);
-	C2_PRE(c2_mutex_is_locked(&ep->nep_tm->ntm_mutex));
+	C2_PRE(c2_mutex_is_locked(&ep->nep_dom->nd_mutex));
 	C2_PRE(mem_ep_invariant(ep));
 
-	dp = mem_dom_to_pvt(ep->nep_tm->ntm_dom);
-	c2_list_del(&ep->nep_tm_linkage);
-	ep->nep_tm = NULL;
+	dp = mem_dom_to_pvt(ep->nep_dom);
+	c2_list_del(&ep->nep_dom_linkage);
+	ep->nep_dom = NULL;
 	dp->xd_ops->bmo_ep_free(mem_ep_to_pvt(ep)); /* indirect free */
 }
 
@@ -93,41 +92,35 @@ static void mem_ep_free(struct c2_net_bulk_mem_end_point *mep)
 	c2_free(mep);
 }
 
-static void mem_ep_get(struct c2_net_end_point *ep)
-{
-	c2_net_end_point_get(ep);
-}
-
 /**
    Internal implementation of mem_xo_end_point_create().
  */
-static int mem_ep_create(struct c2_net_end_point  **epp,
-			 struct c2_net_transfer_mc *tm,
-			 const struct sockaddr_in  *sa,
+static int mem_ep_create(struct c2_net_end_point **epp,
+			 struct c2_net_domain *dom,
+			 const struct sockaddr_in *sa,
 			 uint32_t id)
 {
 	struct c2_net_end_point *ep;
 	struct c2_net_bulk_mem_end_point *mep;
 	struct c2_net_bulk_mem_domain_pvt *dp;
 
-	C2_PRE(c2_mutex_is_locked(&tm->ntm_mutex));
-	C2_PRE(mem_tm_invariant(tm));
-	dp = mem_dom_to_pvt(tm->ntm_dom);
+	C2_PRE(mem_dom_invariant(dom));
 
-	/* check if its already on the TM end point list */
-	c2_list_for_each_entry(&tm->ntm_end_points, ep,
+	/* check if its already on the domain list */
+	c2_list_for_each_entry(&dom->nd_end_points, ep,
 			       struct c2_net_end_point,
-			       nep_tm_linkage) {
+			       nep_dom_linkage) {
 		C2_ASSERT(mem_ep_invariant(ep));
 		mep = mem_ep_to_pvt(ep);
 		if (mem_sa_eq(&mep->xep_sa, sa) && mep->xep_service_id == id) {
-			dp->xd_ops->bmo_ep_get(ep);
+			c2_net_end_point_get(ep);
 			*epp = ep;
 			return 0;
 		}
 	}
 
 	/* allocate a new end point of appropriate size */
+	dp = mem_dom_to_pvt(dom);
 	mep = dp->xd_ops->bmo_ep_alloc(); /* indirect alloc */
 	if (mep == NULL)
 		return -ENOMEM;
@@ -138,8 +131,8 @@ static int mem_ep_create(struct c2_net_end_point  **epp,
 	mem_ep_printable(mep, sa, id);
 	ep = &mep->xep_ep;
 	c2_ref_init(&ep->nep_ref, 1, dp->xd_ops->bmo_ep_release);
-	ep->nep_tm = tm;
-	c2_list_add_tail(&tm->ntm_end_points, &ep->nep_tm_linkage);
+	ep->nep_dom = dom;
+	c2_list_add_tail(&dom->nd_end_points, &ep->nep_dom_linkage);
 	ep->nep_addr = &mep->xep_addr[0];
 	C2_ASSERT(mem_ep_to_pvt(ep) == mep);
 	C2_POST(mem_ep_invariant(ep));
@@ -200,6 +193,7 @@ static bool mem_eps_are_equal(const struct c2_net_end_point *ep1,
    @param desc Returns the descriptor
  */
 static int mem_desc_create(struct c2_net_buf_desc *desc,
+			   struct c2_net_end_point *ep,
 			   struct c2_net_transfer_mc *tm,
 			   enum c2_net_queue_type qt,
 			   c2_bcount_t buflen,
@@ -208,14 +202,20 @@ static int mem_desc_create(struct c2_net_buf_desc *desc,
 	struct mem_desc *md;
 	struct c2_net_bulk_mem_end_point *mep;
 
+	C2_PRE(mem_ep_invariant(ep));
+
 	desc->nbd_len = sizeof *md;
 	md = c2_alloc(desc->nbd_len);
-	desc->nbd_data = (typeof(desc->nbd_data)) md;
+	desc->nbd_data = (char *) md;
 	if (desc->nbd_data == NULL) {
 		desc->nbd_len = 0;
 		return -ENOMEM;
 	}
 
+	/* copy the active end point address */
+	mep = mem_ep_to_pvt(ep);
+	md->md_active = mep->xep_sa;
+
 	/* copy the passive end point address */
 	mep = mem_ep_to_pvt(tm->ntm_ep);
 	md->md_passive = mep->xep_sa;
@@ -262,6 +262,7 @@ static bool mem_desc_equal(struct c2_net_buf_desc *d1,
 	if (rc != 0)
 		return false;
 	if (md1->md_buf_id == md2->md_buf_id &&
+	    mem_sa_eq(&md1->md_active,  &md2->md_active) &&
 	    mem_sa_eq(&md1->md_passive, &md2->md_passive))
 		return true;
 	return false;
diff --git a/net/bulk_emulation/mem_xprt_msg.c b/net/bulk_emulation/mem_xprt_msg.c
index 3b67213..003bb07 100644
--- a/net/bulk_emulation/mem_xprt_msg.c
+++ b/net/bulk_emulation/mem_xprt_msg.c
@@ -14,8 +14,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Carl Braganza <Carl_Braganza@us.xyratex.com>,
- *                  Dave Cohrs <Dave_Cohrs@us.xyratex.com>
+ * Original author: Carl Braganza, Dave Cohrs
  * Original creation date: 04/12/2011
  */
 
@@ -108,14 +107,12 @@ static int mem_find_remote_tm(struct c2_net_transfer_mc  *tm,
 				if (p_dest_ep == NULL)
 					break;
 				/* We need to create an EP for the local TM
-				   address in the remote DOM.
-				   We don't need the domain lock (do need TM
-				   mutex) but the original logic required it so
-				   leave it that way...
+				   address in the remote DOM. Do this now,
+				   before giving up the DOM mutex.
 				*/
 				mep = mem_ep_to_pvt(tm->ntm_ep);
 				rc = mem_bmo_ep_create(&dest_ep,
-						       dest_tm,
+						       dest_tm->ntm_dom,
 						       &mep->xep_sa,
 						       mep->xep_service_id);
 			} while(0);
@@ -198,14 +195,15 @@ static void mem_wf_msg_send(struct c2_net_transfer_mc *tm,
 		*/
 
 		/* get the first available receive buffer */
-		c2_tlist_for(&tm_tl, &dest_tm->ntm_q[C2_NET_QT_MSG_RECV],
-			      dest_nb) {
+		c2_list_for_each_entry(&dest_tm->ntm_q[C2_NET_QT_MSG_RECV],
+				       dest_nb, struct c2_net_buffer,
+				       nb_tm_linkage) {
 			if ((dest_nb->nb_flags &
 			     (C2_NET_BUF_IN_USE | C2_NET_BUF_CANCELLED)) == 0) {
 				found_dest_nb = true;
 				break;
 			}
-		} c2_tlist_endfor;
+		}
 		if (!found_dest_nb) {
 			dest_tm->ntm_qstats[C2_NET_QT_MSG_RECV].nqs_num_f_events
 				++;
diff --git a/net/bulk_emulation/mem_xprt_pvt.h b/net/bulk_emulation/mem_xprt_pvt.h
index c38033b..d20e6c5 100644
--- a/net/bulk_emulation/mem_xprt_pvt.h
+++ b/net/bulk_emulation/mem_xprt_pvt.h
@@ -14,8 +14,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Carl Braganza <Carl_Braganza@us.xyratex.com>,
- *                  Dave Cohrs <Dave_Cohrs@us.xyratex.com>
+ * Original author: Carl Braganza, Dave Cohrs
  * Original creation date: 04/12/2011
  */
 #ifndef __COLIBRI_NET_BULK_MEM_XPRT_PVT_H__
@@ -41,6 +40,8 @@ enum {
    Content on the network descriptor.
  */
 struct mem_desc {
+	/** Address of the active end point */
+	struct sockaddr_in     md_active;
 	/** Address of the passive end point */
 	struct sockaddr_in     md_passive;
 	/** Queue type */
@@ -56,15 +57,16 @@ static bool mem_dom_invariant(const struct c2_net_domain *dom);
 static bool mem_ep_invariant(const struct c2_net_end_point *ep);
 static bool mem_buffer_invariant(const struct c2_net_buffer *nb);
 static bool mem_tm_invariant(const struct c2_net_transfer_mc *tm);
-static int mem_ep_create(struct c2_net_end_point  **epp,
-			 struct c2_net_transfer_mc *tm,
-			 const struct sockaddr_in  *sa,
+static int mem_ep_create(struct c2_net_end_point **epp,
+			 struct c2_net_domain *dom,
+			 const struct sockaddr_in *sa,
 			 uint32_t id);
 static bool mem_eps_are_equal(const struct c2_net_end_point *ep1,
 			      const struct c2_net_end_point *ep2);
 static bool mem_ep_equals_addr(const struct c2_net_end_point *ep,
 			       const struct sockaddr_in *sa);
 static int mem_desc_create(struct c2_net_buf_desc *desc,
+			   struct c2_net_end_point *ep,
 			   struct c2_net_transfer_mc *tm,
 			   enum c2_net_queue_type qt,
 			   c2_bcount_t buflen,
@@ -84,17 +86,29 @@ static void mem_post_error(struct c2_net_transfer_mc *tm, int status);
 static void mem_wi_post_buffer_event(struct c2_net_bulk_mem_work_item *wi);
 
 /**
+   Macro to compare two struct sockaddr_in structures.
+   @param sa1 Pointer to first structure.
+   @param sa2 Pointer to second structure.
+ */
+static inline bool mem_sa_eq(const struct sockaddr_in *sa1,
+			     const struct sockaddr_in *sa2)
+{
+	return sa1->sin_addr.s_addr == sa2->sin_addr.s_addr &&
+	       sa1->sin_port        == sa2->sin_port;
+}
+
+/**
    Function to indirectly invoke the mem_ep_create subroutine via the domain
    function pointer, to support derived transports.
    @see mem_ep_create()
  */
-static inline int mem_bmo_ep_create(struct c2_net_end_point  **epp,
-				    struct c2_net_transfer_mc *tm,
-				    const struct sockaddr_in  *sa,
+static inline int mem_bmo_ep_create(struct c2_net_end_point **epp,
+				    struct c2_net_domain *dom,
+				    const struct sockaddr_in *sa,
 				    uint32_t id)
 {
-	struct c2_net_bulk_mem_domain_pvt *dp = tm->ntm_dom->nd_xprt_private;
-	return dp->xd_ops->bmo_ep_create(epp, tm, sa, id);
+	struct c2_net_bulk_mem_domain_pvt *dp = dom->nd_xprt_private;
+	return dp->xd_ops->bmo_ep_create(epp, dom, sa, id);
 }
 
 /**
@@ -114,13 +128,14 @@ static inline bool mem_bmo_buffer_in_bounds(const struct c2_net_buffer *nb)
    @see mem_desc_create()
  */
 static int mem_bmo_desc_create(struct c2_net_buf_desc *desc,
+			       struct c2_net_end_point *ep,
 			       struct c2_net_transfer_mc *tm,
 			       enum c2_net_queue_type qt,
 			       c2_bcount_t buflen,
 			       int64_t buf_id)
 {
 	struct c2_net_bulk_mem_domain_pvt *dp = tm->ntm_dom->nd_xprt_private;
-	return dp->xd_ops->bmo_desc_create(desc, tm, qt, buflen, buf_id);
+	return dp->xd_ops->bmo_desc_create(desc, ep, tm, qt, buflen, buf_id);
 }
 
 /**
diff --git a/net/bulk_emulation/mem_xprt_tm.c b/net/bulk_emulation/mem_xprt_tm.c
index f85b0f0..1883125 100644
--- a/net/bulk_emulation/mem_xprt_tm.c
+++ b/net/bulk_emulation/mem_xprt_tm.c
@@ -14,8 +14,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Carl Braganza <Carl_Braganza@us.xyratex.com>,
- *                  Dave Cohrs <Dave_Cohrs@us.xyratex.com>
+ * Original author: Carl Braganza, Dave Cohrs
  * Original creation date: 04/12/2011
  */
 
@@ -58,27 +57,15 @@ static void mem_wf_state_change(struct c2_net_transfer_mc *tm,
 				tp->xtm_state = C2_NET_XTM_FAILED;
 				ev.nte_next_state = C2_NET_TM_FAILED;
 				ev.nte_status = wi->xwi_status;
-				if (wi->xwi_nbe_ep != NULL) {
-					/* must free ep before posting event */
-					c2_ref_put(&wi->xwi_nbe_ep->nep_ref);
-					wi->xwi_nbe_ep = NULL;
-				}
 			} else {
 				tp->xtm_state = next_state;
 				ev.nte_next_state = C2_NET_TM_STARTED;
-				ev.nte_ep = wi->xwi_nbe_ep;
-				wi->xwi_nbe_ep = NULL;
 			}
 			c2_mutex_unlock(&tm->ntm_mutex);
-			ev.nte_time = c2_time_now();
+			c2_time_now(&ev.nte_time);
 			c2_net_tm_event_post(&ev);
 			c2_mutex_lock(&tm->ntm_mutex);
 		}
-		if (wi->xwi_nbe_ep != NULL) {
-			/* free the end point if not consumed */
-			c2_ref_put(&wi->xwi_nbe_ep->nep_ref);
-			wi->xwi_nbe_ep = NULL;
-		}
 	} else { /* C2_NET_XTM_STOPPED, as per assert */
 		C2_ASSERT(tp->xtm_state == C2_NET_XTM_STOPPING);
 		tp->xtm_state = next_state;
@@ -91,7 +78,7 @@ static void mem_wf_state_change(struct c2_net_transfer_mc *tm,
 			c2_cond_wait(&tp->xtm_work_list_cv, &tm->ntm_mutex);
 
 		c2_mutex_unlock(&tm->ntm_mutex);
-		ev.nte_time = c2_time_now();
+		c2_time_now(&ev.nte_time);
 		c2_net_tm_event_post(&ev);
 		c2_mutex_lock(&tm->ntm_mutex);
 	}
@@ -111,11 +98,8 @@ static void mem_wf_cancel_cb(struct c2_net_transfer_mc *tm,
 	C2_PRE(c2_mutex_is_not_locked(&tm->ntm_mutex));
 	C2_PRE(nb->nb_flags & C2_NET_BUF_IN_USE);
 
-	/* post the completion callback (will clear operation flags) */
-	if ((nb->nb_flags & C2_NET_BUF_TIMED_OUT) != 0)
-		wi->xwi_status = -ETIMEDOUT;
-	else
-		wi->xwi_status = -ECANCELED;
+	/* post the completion callback (will clear C2_NET_BUF_IN_USE) */
+	wi->xwi_status = -ECANCELED;
 	mem_wi_post_buffer_event(wi);
 	return;
 }
@@ -136,7 +120,7 @@ static void mem_wf_error_cb(struct c2_net_transfer_mc *tm,
 
 	C2_PRE(wi->xwi_op == C2_NET_XOP_ERROR_CB);
 	C2_PRE(wi->xwi_status < 0);
-	ev.nte_time = c2_time_now();
+	c2_time_now(&ev.nte_time);
 	c2_net_tm_event_post(&ev);
 	c2_free(wi);
 }
diff --git a/net/bulk_emulation/mem_xprt_xo.c b/net/bulk_emulation/mem_xprt_xo.c
index 055c79b..6e5bfb4 100644
--- a/net/bulk_emulation/mem_xprt_xo.c
+++ b/net/bulk_emulation/mem_xprt_xo.c
@@ -14,8 +14,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Carl Braganza <Carl_Braganza@us.xyratex.com>,
- *                  Dave Cohrs <Dave_Cohrs@us.xyratex.com>
+ * Original author: Carl Braganza, Dave Cohrs
  * Original creation date: 04/12/2011
  */
 
@@ -23,6 +22,15 @@
 #include "lib/misc.h"
 #include "net/bulk_emulation/mem_xprt_pvt.h"
 
+#ifdef __KERNEL__
+#include <linux/in.h>
+#include <linux/inet.h>
+#else
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#endif
+
 /**
    @addtogroup bulkmem
    @{
@@ -61,10 +69,10 @@ void c2_mem_xprt_fini(void)
    Static functions should be declared in the private header file
    so that the order of their definition does not matter.
 */
-#include "net/bulk_emulation/mem_xprt_ep.c"
-#include "net/bulk_emulation/mem_xprt_tm.c"
-#include "net/bulk_emulation/mem_xprt_msg.c"
-#include "net/bulk_emulation/mem_xprt_bulk.c"
+#include "mem_xprt_ep.c"
+#include "mem_xprt_tm.c"
+#include "mem_xprt_msg.c"
+#include "mem_xprt_bulk.c"
 
 static c2_bcount_t mem_buffer_length(const struct c2_net_buffer *nb)
 {
@@ -139,6 +147,7 @@ static void mem_wi_add(struct c2_net_bulk_mem_work_item *wi,
 static void mem_wi_post_buffer_event(struct c2_net_bulk_mem_work_item *wi)
 {
 	struct c2_net_buffer *nb = mem_wi_to_buffer(wi);
+	C2_POST(wi->xwi_status <= 0);
 	struct c2_net_buffer_event ev = {
 		.nbe_buffer = nb,
 		.nbe_status = wi->xwi_status,
@@ -146,8 +155,7 @@ static void mem_wi_post_buffer_event(struct c2_net_bulk_mem_work_item *wi)
 		.nbe_length = wi->xwi_nbe_length,
 		.nbe_ep     = wi->xwi_nbe_ep
 	};
-	C2_PRE(wi->xwi_status <= 0);
-	ev.nbe_time = c2_time_now();
+	c2_time_now(&ev.nbe_time);
 	c2_net_buffer_event_post(&ev);
 	return;
 }
@@ -277,7 +285,7 @@ static int32_t mem_xo_get_max_buffer_segments(const struct c2_net_domain *dom)
    - "dottedIP:portNumber:serviceId" if 3-tuple addressing used.
  */
 static int mem_xo_end_point_create(struct c2_net_end_point **epp,
-				   struct c2_net_transfer_mc *tm,
+				   struct c2_net_domain *dom,
 				   const char *addr)
 {
 	char buf[C2_NET_BULK_MEM_XEP_ADDR_LEN];
@@ -287,7 +295,7 @@ static int mem_xo_end_point_create(struct c2_net_end_point **epp,
 	int pnum;
 	struct sockaddr_in sa;
 	uint32_t id = 0;
-	struct c2_net_bulk_mem_domain_pvt *dp = mem_dom_to_pvt(tm->ntm_dom);
+	struct c2_net_bulk_mem_domain_pvt *dp = mem_dom_to_pvt(dom);
 
 	C2_PRE(dp->xd_addr_tuples == 2 || dp->xd_addr_tuples == 3);
 
@@ -321,7 +329,7 @@ static int mem_xo_end_point_create(struct c2_net_end_point **epp,
 	if (inet_aton(dot_ip, &sa.sin_addr) == 0)
 		return -EINVAL;
 #endif
-	return mem_bmo_ep_create(epp, tm, &sa, id);
+	return mem_bmo_ep_create(epp, dom, &sa, id);
 }
 
 /**
@@ -368,7 +376,7 @@ static int mem_xo_buf_register(struct c2_net_buffer *nb)
    Derived transports should free the private data upon return from this
    subroutine.
  */
-static void mem_xo_buf_deregister(struct c2_net_buffer *nb)
+static int mem_xo_buf_deregister(struct c2_net_buffer *nb)
 {
 	struct c2_net_bulk_mem_domain_pvt *dp;
 	struct c2_net_bulk_mem_buffer_pvt *bp;
@@ -381,7 +389,7 @@ static void mem_xo_buf_deregister(struct c2_net_buffer *nb)
 		c2_free(bp);
 		nb->nb_xprt_private = NULL;
 	}
-	return;
+	return 0;
 }
 
 /**
@@ -426,7 +434,7 @@ static int mem_xo_buf_add(struct c2_net_buffer *nb)
 		nb->nb_length = 0;
 	case C2_NET_QT_PASSIVE_BULK_SEND:
 		bp->xb_buf_id = ++dp->xd_buf_id_counter;
-		rc = mem_bmo_desc_create(&nb->nb_desc, tm,
+		rc = mem_bmo_desc_create(&nb->nb_desc, nb->nb_ep, tm,
 					 nb->nb_qtype, nb->nb_length,
 					 bp->xb_buf_id);
 		if (rc != 0)
@@ -450,8 +458,7 @@ static int mem_xo_buf_add(struct c2_net_buffer *nb)
 }
 
 /**
-   Cancel ongoing buffer operations.  May also be invoked to time out a pending
-   buffer operation by first setting the C2_NET_BUF_TIMED_OUT flag.
+   Cancel ongoing buffer operations.
    @param nb Buffer pointer
  */
 static void mem_xo_buf_del(struct c2_net_buffer *nb)
@@ -474,8 +481,7 @@ static void mem_xo_buf_del(struct c2_net_buffer *nb)
 
 	wi = &bp->xb_wi;
 	wi->xwi_op = C2_NET_XOP_CANCEL_CB;
-	if (!(nb->nb_flags & C2_NET_BUF_TIMED_OUT))
-		nb->nb_flags |= C2_NET_BUF_CANCELLED;
+	nb->nb_flags |= C2_NET_BUF_CANCELLED;
 
 	switch (nb->nb_qtype) {
 	case C2_NET_QT_MSG_RECV:
@@ -596,11 +602,10 @@ size_t c2_net_bulk_mem_tm_get_num_threads(const struct c2_net_transfer_mc *tm) {
 	return tp->xtm_num_workers;
 }
 
-static int mem_xo_tm_start(struct c2_net_transfer_mc *tm, const char *addr)
+static int mem_xo_tm_start(struct c2_net_transfer_mc *tm)
 {
 	struct c2_net_bulk_mem_tm_pvt *tp;
 	struct c2_net_bulk_mem_work_item *wi_st_chg;
-	struct c2_net_xprt *xprt;
 	int rc = 0;
 	int i;
 
@@ -633,15 +638,6 @@ static int mem_xo_tm_start(struct c2_net_transfer_mc *tm, const char *addr)
 	wi_st_chg->xwi_next_state = C2_NET_XTM_STARTED;
 	wi_st_chg->xwi_status = 0;
 
-	/* create the end point (indirectly via the transport ops vector) */
-	xprt = tm->ntm_dom->nd_xprt;
-	rc = (*xprt->nx_ops->xo_end_point_create)(&wi_st_chg->xwi_nbe_ep,
-						  tm, addr);
-	if (rc != 0) {
-		c2_free(wi_st_chg);
-		return rc;
-	}
-
 	/* start worker threads */
 	for (i = 0; i < tp->xtm_num_workers && rc == 0; ++i)
 		rc = C2_THREAD_INIT(&tp->xtm_worker_threads[i],
@@ -686,11 +682,13 @@ static int mem_xo_tm_stop(struct c2_net_transfer_mc *tm, bool cancel)
 
 	/* walk through the queues and cancel every buffer */
 	for (qt = 0; qt < C2_NET_QT_NR; ++qt) {
-		c2_tlist_for(&tm_tl, &tm->ntm_q[qt], nb) {
+		c2_list_for_each_entry(&tm->ntm_q[qt], nb,
+				       struct c2_net_buffer,
+				       nb_tm_linkage) {
 			mem_xo_buf_del(nb);
 			/* bump the del stat count */
 			tm->ntm_qstats[qt].nqs_num_dels += 1;
-		} c2_tlist_endfor;
+		}
 	}
 
 	/* set transition state and add the state change work item */
@@ -711,11 +709,10 @@ static const struct c2_net_bulk_mem_ops mem_xprt_methods = {
 		[C2_NET_XOP_ACTIVE_BULK]     = mem_wf_active_bulk,
 		[C2_NET_XOP_ERROR_CB]        = mem_wf_error_cb,
 	},
-	.bmo_ep_create                       = mem_ep_create,
+ 	.bmo_ep_create                       = mem_ep_create,
 	.bmo_ep_alloc                        = mem_ep_alloc,
 	.bmo_ep_free                         = mem_ep_free,
 	.bmo_ep_release                      = mem_xo_end_point_release,
-	.bmo_ep_get                          = mem_ep_get,
 	.bmo_wi_add                          = mem_wi_add,
 	.bmo_buffer_in_bounds                = mem_buffer_in_bounds,
 	.bmo_desc_create                     = mem_desc_create,
diff --git a/net/bulk_emulation/st/Makefile.am b/net/bulk_emulation/st/Makefile.am
index 231f33d..1344e2d 100644
--- a/net/bulk_emulation/st/Makefile.am
+++ b/net/bulk_emulation/st/Makefile.am
@@ -2,9 +2,5 @@ INCLUDES             = -I. -I$(top_srcdir) -I$(top_srcdir)/include
 
 noinst_PROGRAMS      = bulkping
 
-bulkping_SOURCES     = main.c ping.c ping.h
-bulkping_LDADD       = $(top_builddir)/colibri/libcolibri.la \
-                       $(top_builddir)/ut/libcolibri-ut.la
-
-EXTRA_DIST           = linux_kernel/main.c \
-                       linux_kernel/test.sh
+bulkping_SOURCES     = main.c ping.c
+bulkping_LDADD       = $(top_builddir)/colibri/libcolibri.la
diff --git a/net/bulk_emulation/st/linux_kernel/.gitignore b/net/bulk_emulation/st/linux_kernel/.gitignore
deleted file mode 100644
index 031b072..0000000
--- a/net/bulk_emulation/st/linux_kernel/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-ping.c
diff --git a/net/bulk_emulation/st/linux_kernel/Makefile.in b/net/bulk_emulation/st/linux_kernel/Makefile.in
deleted file mode 100644
index ad1bbbe..0000000
--- a/net/bulk_emulation/st/linux_kernel/Makefile.in
+++ /dev/null
@@ -1,26 +0,0 @@
-KNST_SRCDIR    = @SRCDIR@/net/bulk_emulation/st/linux_kernel
-NST_MOD       := knetst
-
-local_src     := main.c
-st_src        := ping.c
-link_st       := $(st_src:%=../%)
-all_src       := $(local_src) $(st_src)
-all_obj       := $(all_src:.c=.o)
-
-obj-m         := $(NST_MOD).o
-$(NST_MOD)-y  := $(all_obj)
-
-dist_src      := Makefile.in $(local_src)
-
-EXTRA_CFLAGS = -DHAVE_CONFIG_H -I@SRCDIR@ -I@SRCDIR@/net/ksunrpc @KCFLAGS@
-
-prepare:
-	ln -fs $(link_st) .
-
-clean distclean:
-	$(RM) $(st_src)
-	$(RM) Module.markers Module.symvers modules.order
-	$(MAKE) -C @LINUX_OBJ@ M=`pwd` clean
-
-distdir:
-	cp $(dist_src) @top_builddir@/@PACKAGE@-@VERSION@/net/bulk_emulation/st/linux_kernel
diff --git a/net/bulk_emulation/st/linux_kernel/main.c b/net/bulk_emulation/st/linux_kernel/main.c
deleted file mode 100644
index 895de2d..0000000
--- a/net/bulk_emulation/st/linux_kernel/main.c
+++ /dev/null
@@ -1,245 +0,0 @@
-/* -*- C -*- */
-#ifdef HAVE_CONFIG_H
-#  include <config.h>
-#endif
-
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/inet.h> /* in_aton */
-
-#include "lib/memory.h"
-#include "lib/misc.h" /* C2_SET0 */
-#include "net/net.h"
-#include "net/bulk_sunrpc.h"
-#include "net/bulk_emulation/st/ping.h"
-
-/**
-   @addtogroup net_st Networking System Test
-
-  @{
- */
-
-enum {
-	DEF_BUFS = 20,
-
-	PING_SERVER_SEGMENTS = 4,
-	PING_SERVER_SEGMENT_SIZE = 16384,
-	/* leave some room for overhead */
-	MAX_PASSIVE_SIZE =
-		PING_SERVER_SEGMENTS * PING_SERVER_SEGMENT_SIZE - 1024,
-
-	ONE_MILLION = 1000000ULL,
-	SEC_PER_HR = 60 * 60,
-	SEC_PER_MIN = 60,
-};
-
-/* Module parameters */
-bool verbose = false;
-module_param(verbose, bool, S_IRUGO);
-MODULE_PARM_DESC(verbose, "enable verbose output to kernel log");
-char *hostaddr = "127.0.0.1";
-module_param(hostaddr, charp, S_IRUGO);
-MODULE_PARM_DESC(hostaddr, "address to register as the server endpoint");
-uint nr_bufs = DEF_BUFS;
-module_param(nr_bufs, uint, S_IRUGO);
-MODULE_PARM_DESC(nr_bufs, "total number of network buffers to allocate");
-uint passive_size = 0;
-module_param(passive_size, uint, S_IRUGO);
-MODULE_PARM_DESC(passive_size, "size to offer for passive recv message");
-int sunrpc_ep_delay = -1;
-module_param(sunrpc_ep_delay, int, S_IRUGO);
-MODULE_PARM_DESC(sunrpc_ep_delay,
-	"Control how long unused end points are cached before release");
-int active_bulk_delay = 0;
-module_param(active_bulk_delay, int, S_IRUGO);
-MODULE_PARM_DESC(active_bulk_delay, "Delay before sending active receive");
-uint sunrpc_skulker_period = 0;
-module_param(sunrpc_skulker_period, uint, S_IRUGO);
-MODULE_PARM_DESC(sunrpc_skulker_period,
-		 "Control the period of the skulker thread clock");
-
-int quiet_printk(const char *fmt, ...)
-{
-	return 0;
-}
-
-int verbose_printk(const char *fmt, ...)
-{
-	va_list varargs;
-	char *fmtbuf;
-	int rc;
-
-	va_start(varargs, fmt);
-	fmtbuf = c2_alloc(strlen(fmt) + sizeof KERN_INFO);
-	if (fmtbuf != NULL) {
-	    sprintf(fmtbuf, "%s%s", KERN_INFO, fmt);
-	    fmt = fmtbuf;
-	}
-	/* call vprintk(KERN_INFO ...) */
-	rc = vprintk(fmt, varargs);
-	va_end(varargs);
-	c2_free(fmtbuf);
-	return rc;
-}
-
-struct c2_mutex qstats_mutex;
-
-void print_qstats(struct ping_ctx *ctx, bool reset)
-{
-	int i;
-	int rc;
-	uint64_t hr;
-	uint64_t min;
-	uint64_t sec;
-	uint64_t msec;
-	struct c2_net_qstats qs[C2_NET_QT_NR];
-	struct c2_net_qstats *qp;
-	static const char *qnames[C2_NET_QT_NR] = {
-		"mRECV", "mSEND",
-		"pRECV", "pSEND",
-		"aRECV", "aSEND",
-	};
-	char tbuf[16];
-	const char *lfmt =
-"%5s %6llu %6llu %6llu %6llu %13s %14llu %13llu\n";
-	const char *hfmt1 =
-"Queue   #Add   #Del  #Succ  #Fail Time in Queue   Total Bytes   Max Buffer Sz\n";
-	const char *hfmt2 =
-"----- ------ ------ ------ ------ ------------- --------------- -------------\n";
-
-	if (ctx->pc_tm.ntm_state < C2_NET_TM_INITIALIZED)
-		return;
-	rc = c2_net_tm_stats_get(&ctx->pc_tm, C2_NET_QT_NR, qs, reset);
-	C2_ASSERT(rc == 0);
-	c2_mutex_lock(&qstats_mutex);
-	ctx->pc_ops->pf("%s statistics:\n", ctx->pc_ident);
-	ctx->pc_ops->pf("%s", hfmt1);
-	ctx->pc_ops->pf("%s", hfmt2);
-	for (i = 0; i < ARRAY_SIZE(qs); ++i) {
-		qp = &qs[i];
-		sec = c2_time_seconds(qp->nqs_time_in_queue);
-		hr = sec / SEC_PER_HR;
-		min = sec % SEC_PER_HR / SEC_PER_MIN;
-		sec %= SEC_PER_MIN;
-		msec = (c2_time_nanoseconds(qp->nqs_time_in_queue) +
-			ONE_MILLION / 2) / ONE_MILLION;
-		sprintf(tbuf, "%02llu:%02llu:%02llu.%03llu",
-			hr, min, sec, msec);
-		ctx->pc_ops->pf(lfmt,
-				qnames[i],
-				qp->nqs_num_adds, qp->nqs_num_dels,
-				qp->nqs_num_s_events, qp->nqs_num_f_events,
-				tbuf, qp->nqs_total_bytes, qp->nqs_max_bytes);
-	}
-	c2_mutex_unlock(&qstats_mutex);
-}
-
-struct ping_ops verbose_ops = {
-	.pf  = verbose_printk,
-	.pqs = print_qstats
-};
-
-struct ping_ops quiet_ops = {
-	.pf  = quiet_printk,
-	.pqs = print_qstats
-};
-
-struct ping_ctx sctx = {
-	.pc_tm = {
-		.ntm_state     = C2_NET_TM_UNDEFINED
-	}
-};
-
-struct c2_thread server_thread;
-
-static int __init c2_netst_init_k(void)
-{
-	int rc;
-
-	/* parse module options */
-	if (nr_bufs < DEF_BUFS) {
-		printk(KERN_WARNING "Minimum of %d buffers required\n",
-		       DEF_BUFS);
-		return -EINVAL;
-	}
-	if (passive_size < 0 || passive_size > MAX_PASSIVE_SIZE) {
-		/* need to leave room for encoding overhead */
-		printk(KERN_WARNING "Max supported passive data size: %d\n",
-		       MAX_PASSIVE_SIZE);
-		return -EINVAL;
-	}
-	if (in_aton(hostaddr) == 0) {
-		printk(KERN_WARNING
-		       "only dotted ipaddr is accepted: e.g. 1.2.3.4\n");
-		return -EINVAL;
-	}
-
-	/* set up sys fs entries? */
-
-	/* init main context */
-	rc = c2_net_xprt_init(&c2_net_bulk_sunrpc_xprt);
-	C2_ASSERT(rc == 0);
-	c2_mutex_init(&qstats_mutex);
-
-	/* set up server context */
-	c2_mutex_init(&sctx.pc_mutex);
-	c2_cond_init(&sctx.pc_cond);
-	if (verbose)
-	    sctx.pc_ops = &verbose_ops;
-	else
-	    sctx.pc_ops = &quiet_ops;
-	sctx.pc_hostname = hostaddr;
-	sctx.pc_xprt = &c2_net_bulk_sunrpc_xprt;
-	sctx.pc_port = PING_PORT1;
-	sctx.pc_id = PART3_SERVER_ID;
-
-	sctx.pc_nr_bufs = nr_bufs;
-	sctx.pc_segments = PING_SERVER_SEGMENTS;
-	sctx.pc_seg_size = PING_SERVER_SEGMENT_SIZE;
-	sctx.pc_passive_size = passive_size;
-	sctx.pc_sunrpc_ep_delay = sunrpc_ep_delay;
-	sctx.pc_server_bulk_delay = active_bulk_delay;
-	sctx.pc_sunrpc_skulker_period = sunrpc_skulker_period;
-
-	/* spawn server */
-	C2_SET0(&server_thread);
-	rc = C2_THREAD_INIT(&server_thread, struct ping_ctx *, NULL,
-			    &ping_server, &sctx, "ping_server");
-	C2_ASSERT(rc == 0);
-
-	printk(KERN_INFO "Colibri Kernel Messaging System Test initialized\n");
-	return 0;
-}
-
-static void __exit c2_netst_fini_k(void)
-{
-	if (sctx.pc_ops->pqs != NULL)
-		(*sctx.pc_ops->pqs)(&sctx, false);
-
-	ping_server_should_stop(&sctx);
-	c2_thread_join(&server_thread);
-	c2_cond_fini(&sctx.pc_cond);
-	c2_mutex_fini(&sctx.pc_mutex);
-
-	printk(KERN_INFO "Colibri Kernel Messaging System Test removed\n");
-}
-
-module_init(c2_netst_init_k)
-module_exit(c2_netst_fini_k)
-
-MODULE_AUTHOR("Xyratex");
-MODULE_DESCRIPTION("Colibri Kernel Messaging System Test");
-/* GPL license required as long as kernel sunrpc is used */
-MODULE_LICENSE("proprietary");
-
-/** @} end of group net */
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
diff --git a/net/bulk_emulation/st/linux_kernel/test.sh b/net/bulk_emulation/st/linux_kernel/test.sh
deleted file mode 100755
index 9f5a73b..0000000
--- a/net/bulk_emulation/st/linux_kernel/test.sh
+++ /dev/null
@@ -1,39 +0,0 @@
-#! /bin/sh
-
-# Small wrapper to run kernel bulkping sunrpc ST
-
-if [ "$(id -u)" -ne 0 ]; then
-    echo "Must be run as root"
-    exit 1
-fi
-
-d="`git rev-parse --show-cdup`"
-if [ -n "$d" ]; then
-    cd "$d"
-fi
-
-. c2t1fs/linux_kernel/st/common.sh
-
-MODLIST="build_kernel_modules/kcolibri.ko"
-
-log='/var/log/kern'
-if [ ! -e "$log" ]; then
-    log='/var/log/messages'
-fi
-tailseek=$(( $(stat -c %s "$log") + 1 ))
-
-modload_galois
-modload
-# insert ST module separately to pass parameters
-insmod net/bulk_emulation/st/linux_kernel/knetst.ko verbose passive_size=56000
-
-# use bulkping client here and run various tests
-net/bulk_emulation/st/bulkping -c -t bulk-sunrpc -v
-net/bulk_emulation/st/bulkping -c -t bulk-sunrpc -v -n 8 -d 56000
-
-rmmod knetst
-modunload
-modunload_galois
-
-sleep 1
-tail -c+$tailseek "$log" | grep ' kernel: '
diff --git a/net/bulk_emulation/st/main.c b/net/bulk_emulation/st/main.c
index d0c28b0..67b0013 100644
--- a/net/bulk_emulation/st/main.c
+++ b/net/bulk_emulation/st/main.c
@@ -14,8 +14,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Carl Braganza <Carl_Braganza@us.xyratex.com>,
- *                  Dave Cohrs <Dave_Cohrs@us.xyratex.com>
+ * Original author: Carl Braganza, Dave Cohrs
  * Original creation date: 04/12/2011
  */
 #ifdef HAVE_CONFIG_H
@@ -26,13 +25,6 @@
 #include <stdio.h>
 #include <string.h>
 
-#include <sys/socket.h>
-#ifdef HAVE_NETINET_IN_H
-#  include <netinet/in.h>
-#endif
-#include <arpa/inet.h>
-#include <netdb.h>
-
 #include "colibri/init.h"
 #include "lib/assert.h"
 #include "lib/errno.h"
@@ -43,7 +35,6 @@
 #include "net/net.h"
 #include "net/bulk_mem.h"
 #include "net/bulk_sunrpc.h"
-#include "ut/net.h" /* canon_host */
 #include "ping.h"
 
 enum {
@@ -53,10 +44,10 @@ enum {
 	DEF_LOOPS = 1,
 
 	PING_CLIENT_SEGMENTS = 8,
-	PING_CLIENT_SEGMENT_SIZE = 8192,
+	PING_CLIENT_SEGMENT_SIZE = 512,
 
 	PING_SERVER_SEGMENTS = 4,
-	PING_SERVER_SEGMENT_SIZE = 16384,
+	PING_SERVER_SEGMENT_SIZE = 1024,
 
 	MEM_CLIENT_BASE_PORT = PING_PORT2,
 	SUNRPC_CLIENT_BASE_PORT = PING_PORT1,
@@ -146,7 +137,7 @@ void print_qstats(struct ping_ctx *ctx, bool reset)
 	C2_ASSERT(rc == 0);
 	c2_mutex_lock(&qstats_mutex);
 	ctx->pc_ops->pf("%s statistics:\n", ctx->pc_ident);
-	ctx->pc_ops->pf("%s", hfmt);
+	ctx->pc_ops->pf(hfmt);
 	for (i = 0; i < ARRAY_SIZE(qs); ++i) {
 		qp = &qs[i];
 		sec = c2_time_seconds(qp->nqs_time_in_queue);
@@ -191,9 +182,6 @@ struct client_params {
 	int passive_size;
 	const char *local_host;
 	const char *remote_host;
-	int sunrpc_ep_delay;
-	int passive_bulk_timeout;
-	int sunrpc_skulker_period;
 };
 
 void client(struct client_params *params)
@@ -215,10 +203,7 @@ void client(struct client_params *params)
 		.pc_ident = ident,
 		.pc_tm = {
 			.ntm_state     = C2_NET_TM_UNDEFINED
-		},
-		.pc_sunrpc_ep_delay = params->sunrpc_ep_delay,
-		.pc_passive_bulk_timeout = params->passive_bulk_timeout,
-		.pc_sunrpc_skulker_period = params->sunrpc_skulker_period,
+		}
 	};
 
 	if (params->xprt->px_3part_addr) {
@@ -245,13 +230,13 @@ void client(struct client_params *params)
 	if (params->passive_size != 0) {
 		bp = c2_alloc(params->passive_size);
 		C2_ASSERT(bp != NULL);
-		for (i = 0; i < params->passive_size - 1; ++i)
+		for (i = 0; i < params->passive_size; ++i)
 			bp[i] = "abcdefghi"[i % 9];
 	}
 
 	for (i = 1; i <= params->loops; ++i) {
 		cctx.pc_ops->pf("%s: Loop %d\n", ident, i);
-		rc = ping_client_msg_send_recv(&cctx, server_ep, bp);
+		rc = ping_client_msg_send_recv(&cctx, server_ep, NULL);
 		C2_ASSERT(rc == 0);
 		rc = ping_client_passive_recv(&cctx, server_ep);
 		C2_ASSERT(rc == 0);
@@ -275,24 +260,17 @@ int main(int argc, char *argv[])
 	bool			 client_only = false;
 	bool			 server_only = false;
 	bool			 verbose = false;
-	const char              *local_name = "localhost";
-	const char              *remote_name = "localhost";
+	const char              *local_name = NULL;
+	const char              *remote_name = NULL;
 	const char		*xprt_name = c2_net_bulk_mem_xprt.nx_name;
 	int			 loops = DEF_LOOPS;
 	int			 base_port = 0;
 	int			 nr_clients = DEF_CLIENT_THREADS;
 	int			 nr_bufs = DEF_BUFS;
 	int			 passive_size = 0;
-	int                      sunrpc_ep_delay = -1;
-	int                      passive_bulk_timeout = 0;
-	int                      active_bulk_delay = 0;
-	int                      sunrpc_skulker_period = 0;
 
 	struct ping_xprt	*xprt;
 	struct c2_thread	 server_thread;
-	/* hostname buffers big enough for 255.255.255.255 */
-	char                     local_hostbuf[16];
-	char                     remote_hostbuf[16];
 
 	rc = c2_init();
 	C2_ASSERT(rc == 0);
@@ -317,14 +295,6 @@ int main(int argc, char *argv[])
 				     "list supported transports.",
 				     LAMBDA(void, (const char *str) {
 						     xprt_name = str; })),
-			C2_FORMATARG('E', "sunrpc endpoint release delay",
-				     "%i", &sunrpc_ep_delay),
-			C2_FORMATARG('P', "sunrpc passive bulk timeout",
-				     "%i", &passive_bulk_timeout),
-			C2_FORMATARG('D', "server active bulk delay",
-				     "%i", &active_bulk_delay),
-			C2_FORMATARG('S', "sunrpc skulker period",
-				     "%i", &sunrpc_skulker_period),
 			C2_FLAGARG('v', "verbose", &verbose));
 	if (rc != 0)
 		return rc;
@@ -369,10 +339,6 @@ int main(int argc, char *argv[])
 		if (client_only && base_port == PING_PORT1)
 			base_port = PING_PORT2;
 	}
-	if (canon_host(local_name, local_hostbuf, sizeof(local_hostbuf)) != 0)
-		return 1;
-	if (canon_host(remote_name, remote_hostbuf, sizeof(remote_hostbuf)) != 0)
-		return 1;
 
 	C2_ASSERT(c2_net_xprt_init(xprt->px_xprt) == 0);
 	c2_mutex_init(&qstats_mutex);
@@ -385,7 +351,7 @@ int main(int argc, char *argv[])
 			sctx.pc_ops = &verbose_ops;
 		else
 			sctx.pc_ops = &quiet_ops;
-		sctx.pc_hostname = local_hostbuf;
+		sctx.pc_hostname = local_name;
 		sctx.pc_xprt = xprt->px_xprt;
 		sctx.pc_port = PING_PORT1;
 		if (xprt->px_3part_addr)
@@ -396,9 +362,6 @@ int main(int argc, char *argv[])
 		sctx.pc_segments = PING_SERVER_SEGMENTS;
 		sctx.pc_seg_size = PING_SERVER_SEGMENT_SIZE;
 		sctx.pc_passive_size = passive_size;
-		sctx.pc_sunrpc_ep_delay = sunrpc_ep_delay;
-		sctx.pc_server_bulk_delay = active_bulk_delay;
-		sctx.pc_sunrpc_skulker_period = sunrpc_skulker_period;
 		C2_SET0(&server_thread);
 		rc = C2_THREAD_INIT(&server_thread, struct ping_ctx *, NULL,
 				    &ping_server, &sctx, "ping_server");
@@ -433,11 +396,8 @@ int main(int argc, char *argv[])
 			params[i].nr_bufs = nr_bufs;
 			params[i].client_id = i + 1;
 			params[i].passive_size = passive_size;
-			params[i].local_host = local_hostbuf;
-			params[i].remote_host = remote_hostbuf;
-			params[i].sunrpc_ep_delay = sunrpc_ep_delay;
-			params[i].passive_bulk_timeout = passive_bulk_timeout;
-			params[i].sunrpc_skulker_period = sunrpc_skulker_period;
+			params[i].local_host = local_name;
+			params[i].remote_host = remote_name;
 
 			rc = C2_THREAD_INIT(&client_thread[i],
 					    struct client_params *,
diff --git a/net/bulk_emulation/st/ping.c b/net/bulk_emulation/st/ping.c
index e0e14fd..9388dfd 100644
--- a/net/bulk_emulation/st/ping.c
+++ b/net/bulk_emulation/st/ping.c
@@ -14,14 +14,24 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Carl Braganza <Carl_Braganza@us.xyratex.com>,
- *                  Dave Cohrs <Dave_Cohrs@us.xyratex.com>
+ * Original author: Carl Braganza, Dave Cohrs
  * Original creation date: 04/12/2011
  */
 #ifdef HAVE_CONFIG_H
 #  include <config.h>
 #endif
 
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+
+#include <sys/socket.h>
+#ifdef HAVE_NETINET_IN_H
+#  include <netinet/in.h>
+#endif
+#include <arpa/inet.h>
+#include <netdb.h>
+
 #include "lib/assert.h"
 #include "lib/errno.h"
 #include "lib/memory.h"
@@ -30,11 +40,6 @@
 #include "net/bulk_sunrpc.h"
 #include "net/bulk_emulation/st/ping.h"
 
-#define DEF_RESPONSE "active pong"
-#define DEF_SEND "passive ping"
-#define SEND_RESP    " pong"
-/** Descriptor for the tlist of buffers. */
-
 enum {
 	SEND_RETRIES = 3,
 };
@@ -45,22 +50,6 @@ struct ping_work_item {
 	struct c2_list_link         pwi_link;
 };
 
-static void ping_sleep_secs(int secs)
-{
-	c2_time_t req, rem;
-	if (secs == 0)
-		return;
-	c2_time_set(&req, secs, 0);
-	c2_nanosleep(req, &rem);
-}
-
-static c2_time_t ping_c2_time_after_secs(int secs)
-{
-	c2_time_t dur;
-	c2_time_set(&dur, secs, 0);
-	return c2_time_add(c2_time_now(), dur);
-}
-
 int alloc_buffers(int num, uint32_t segs, c2_bcount_t segsize,
 		  struct c2_net_buffer **out)
 {
@@ -135,21 +124,31 @@ void ping_buf_put(struct ping_ctx *ctx, struct c2_net_buffer *nb)
 /** encode a string message into a net buffer, not zero-copy */
 int encode_msg(struct c2_net_buffer *nb, const char *str)
 {
-	char *bp;
-	c2_bcount_t len = strlen(str) + 1; /* include trailing nul */
-	c2_bcount_t copied;
-	struct c2_bufvec in = C2_BUFVEC_INIT_BUF((void **) &str, &len);
-	struct c2_bufvec_cursor incur;
 	struct c2_bufvec_cursor cur;
+	char *bp;
+	size_t len = strlen(str) + 1; /* include trailing nul */
+	c2_bcount_t step;
 
 	nb->nb_length = len + 1;
+
 	c2_bufvec_cursor_init(&cur, &nb->nb_buffer);
 	bp = c2_bufvec_cursor_addr(&cur);
 	*bp = 'm';
 	C2_ASSERT(!c2_bufvec_cursor_move(&cur, 1));
-	c2_bufvec_cursor_init(&incur, &in);
-	copied = c2_bufvec_cursor_copy(&cur, &incur, len);
-	C2_ASSERT(copied == len);
+	while (len > 0) {
+		bp = c2_bufvec_cursor_addr(&cur);
+		step = c2_bufvec_cursor_step(&cur);
+		if (len > step) {
+			memcpy(bp, str, step);
+			str += step;
+			len -= step;
+			C2_ASSERT(!c2_bufvec_cursor_move(&cur, step));
+			C2_ASSERT(cur.bc_vc.vc_offset == 0);
+		} else {
+			memcpy(bp, str, len);
+			len = 0;
+		}
+	}
 	return 0;
 }
 
@@ -207,16 +206,25 @@ int decode_msg(struct c2_net_buffer *nb, struct ping_msg *msg)
 	C2_ASSERT(*bp == 'm' || *bp == 's' || *bp == 'r');
 	C2_ASSERT(!c2_bufvec_cursor_move(&cur, 1));
 	if (*bp == 'm') {
-		c2_bcount_t len = nb->nb_length - 1;
-		void *str;
-		struct c2_bufvec out = C2_BUFVEC_INIT_BUF(&str, &len);
-		struct c2_bufvec_cursor outcur;
+		size_t len = nb->nb_length - 1;
+		char *str;
 
 		msg->pm_type = PM_MSG;
-		str = msg->pm_u.pm_str = c2_alloc(len + 1);
-		c2_bufvec_cursor_init(&outcur, &out);
-		step = c2_bufvec_cursor_copy(&outcur, &cur, len);
-		C2_ASSERT(step == len);
+		str = msg->pm_u.pm_str = c2_alloc(len);
+		while (len > 0) {
+			bp = c2_bufvec_cursor_addr(&cur);
+			step = c2_bufvec_cursor_step(&cur);
+			if (len > step) {
+				memcpy(str, bp, step);
+				str += step;
+				len -= step;
+				C2_ASSERT(!c2_bufvec_cursor_move(&cur, step));
+				C2_ASSERT(cur.bc_vc.vc_offset == 0);
+			} else {
+				memcpy(str, bp, len);
+				len = 0;
+			}
+		}
 	} else {
 		int len;
 		msg->pm_type = (*bp == 's') ? PM_SEND_DESC : PM_RECV_DESC;
@@ -254,7 +262,6 @@ void c_m_recv_cb(const struct c2_net_buffer_event *ev)
 {
 	struct ping_ctx *ctx = buffer_event_to_ping_ctx(ev);
 	int rc;
-	int len;
 	struct ping_work_item *wi;
 	struct ping_msg msg;
 
@@ -273,25 +280,20 @@ void c_m_recv_cb(const struct c2_net_buffer_event *ev)
 		rc = decode_msg(ev->nbe_buffer, &msg);
 		C2_ASSERT(rc == 0);
 
-		if (msg.pm_type != PM_MSG)
+		if (msg.pm_type != PM_MSG) {
 			C2_IMPOSSIBLE("Client: got desc\n");
-
-		len = strlen(msg.pm_u.pm_str);
-		if (strlen(msg.pm_u.pm_str) < 32)
+			/* TODO: implement this branch? */
+		} else {
 			ctx->pc_ops->pf("%s: got msg: %s\n",
 					ctx->pc_ident, msg.pm_u.pm_str);
-		else
-			ctx->pc_ops->pf("%s: got msg: %u bytes\n",
-					ctx->pc_ident, len + 1);
-
-		if (ctx->pc_compare_buf != NULL) {
-			int l = strlen(ctx->pc_compare_buf);
-			C2_ASSERT(strlen(msg.pm_u.pm_str) == l + 5);
-			C2_ASSERT(strncmp(ctx->pc_compare_buf,
-					  msg.pm_u.pm_str, l) == 0);
-			C2_ASSERT(strcmp(&msg.pm_u.pm_str[l], SEND_RESP) == 0);
-			ctx->pc_ops->pf("%s: msg bytes validated\n",
-					ctx->pc_ident);
+			if (ctx->pc_compare_buf != NULL) {
+				int l = strlen(ctx->pc_compare_buf);
+				C2_ASSERT(strlen(msg.pm_u.pm_str) == l + 5);
+				C2_ASSERT(strncmp(ctx->pc_compare_buf,
+						  msg.pm_u.pm_str, l) == 0);
+				C2_ASSERT(strcmp(&msg.pm_u.pm_str[l],
+						 " pong") == 0);
+			}
 		}
 		msg_free(&msg);
 	}
@@ -353,7 +355,6 @@ void c_p_recv_cb(const struct c2_net_buffer_event *ev)
 {
 	struct ping_ctx *ctx = buffer_event_to_ping_ctx(ev);
 	int rc;
-	int len;
 	struct ping_work_item *wi;
 	struct ping_msg msg;
 
@@ -374,30 +375,12 @@ void c_p_recv_cb(const struct c2_net_buffer_event *ev)
 
 		if (msg.pm_type != PM_MSG)
 			C2_IMPOSSIBLE("Client: got desc\n");
-		len = strlen(msg.pm_u.pm_str);
-		if (strlen(msg.pm_u.pm_str) < 32)
+		else if (strlen(msg.pm_u.pm_str) < 32)
 			ctx->pc_ops->pf("%s: got data: %s\n",
 					ctx->pc_ident, msg.pm_u.pm_str);
 		else
-			ctx->pc_ops->pf("%s: got data: %u bytes\n",
-					ctx->pc_ident, len + 1);
-		C2_ASSERT(ev->nbe_length == len + 2);
-		if (strcmp(msg.pm_u.pm_str, DEF_RESPONSE) != 0) {
-			int i;
-			for (i = 0; i < len - 1; ++i) {
-				if (msg.pm_u.pm_str[i] != "abcdefghi"[i % 9]) {
-					PING_ERR("%s: data diff @ offset %i: "
-						 "%c != %c\n",
-						 ctx->pc_ident, i,
-						 msg.pm_u.pm_str[i],
-						 "abcdefghi"[i % 9]);
-					break;
-				}
-			}
-			if (i == len - 1)
-				ctx->pc_ops->pf("%s: data bytes validated\n",
-						ctx->pc_ident);
-		}
+			ctx->pc_ops->pf("%s: got data: %lu bytes\n",
+					ctx->pc_ident, strlen(msg.pm_u.pm_str));
 		msg_free(&msg);
 	}
 
@@ -527,14 +510,13 @@ void s_m_recv_cb(const struct c2_net_buffer_event *ev)
 	struct ping_msg msg;
 	int64_t count;
 	char idbuf[64];
-	int bulk_delay = ctx->pc_server_bulk_delay;
-
 
 	C2_ASSERT(ev->nbe_buffer != NULL &&
 		  ev->nbe_buffer->nb_qtype == C2_NET_QT_MSG_RECV);
 	server_event_ident(idbuf, ctx->pc_ident, ev);
 	count = c2_atomic64_add_return(&s_msg_recv_counter, 1);
-	ctx->pc_ops->pf("%s: Msg Recv CB %" PRId64 "\n", idbuf, count);
+	ctx->pc_ops->pf("%s: Msg Recv CB %ld\n", idbuf, count);
+
 	if (ev->nbe_status < 0) {
 		if (ev->nbe_status == -ECANCELED && server_stop)
 			ctx->pc_ops->pf("%s: msg recv canceled on shutdown\n",
@@ -573,11 +555,6 @@ void s_m_recv_cb(const struct c2_net_buffer_event *ev)
 						 &nb->nb_desc);
 				nb->nb_ep = NULL; /* not needed */
 				C2_ASSERT(rc == 0);
-				if (bulk_delay != 0) {
-					ctx->pc_ops->pf("%s: delay %d secs\n",
-							idbuf, bulk_delay);
-					ping_sleep_secs(bulk_delay);
-				}
 			} else if (msg.pm_type == PM_RECV_DESC) {
 				ctx->pc_ops->pf("%s: got desc for "
 						"active send\n", idbuf);
@@ -588,46 +565,32 @@ void s_m_recv_cb(const struct c2_net_buffer_event *ev)
 				nb->nb_ep = NULL; /* not needed */
 				/* reuse encode_msg for convenience */
 				if (ctx->pc_passive_size == 0)
-					rc = encode_msg(nb, DEF_RESPONSE);
+					rc = encode_msg(nb, "active pong");
 				else {
 					char *bp;
 					int i;
 					bp = c2_alloc(ctx->pc_passive_size);
 					C2_ASSERT(bp != NULL);
 					for (i = 0;
-					     i < ctx->pc_passive_size - 1; ++i)
+					     i < ctx->pc_passive_size; ++i)
 						bp[i] = "abcdefghi"[i % 9];
-					ctx->pc_ops->pf("%s: sending data "
-							"%d bytes\n", idbuf,
-							ctx->pc_passive_size);
 					rc = encode_msg(nb, bp);
 					c2_free(bp);
 					C2_ASSERT(rc == 0);
 				}
 				C2_ASSERT(rc == 0);
-				if (bulk_delay != 0) {
-					ctx->pc_ops->pf("%s: delay %d secs\n",
-							idbuf, bulk_delay);
-					ping_sleep_secs(bulk_delay);
-				}
 			} else {
 				char *data;
-				int len = strlen(msg.pm_u.pm_str);
-				if (strlen(msg.pm_u.pm_str) < 32)
-					ctx->pc_ops->pf("%s: got msg: %s\n",
-							idbuf, msg.pm_u.pm_str);
-				else
-					ctx->pc_ops->pf("%s: got msg: "
-							"%u bytes\n",
-							idbuf, len + 1);
+				ctx->pc_ops->pf("%s: got msg: %s\n",
+						idbuf, msg.pm_u.pm_str);
 
 				/* queue wi to send back ping response */
-				data = c2_alloc(len + 6);
+				data = c2_alloc(strlen(msg.pm_u.pm_str) + 6);
 				c2_net_end_point_get(nb->nb_ep);
 				wi->pwi_type = C2_NET_QT_MSG_SEND;
 				nb->nb_qtype = C2_NET_QT_MSG_SEND;
 				strcpy(data, msg.pm_u.pm_str);
-				strcat(data, SEND_RESP);
+				strcat(data, " pong");
 				rc = encode_msg(nb, data);
 				c2_free(data);
 				C2_ASSERT(rc == 0);
@@ -690,7 +653,6 @@ void s_a_recv_cb(const struct c2_net_buffer_event *ev)
 {
 	struct ping_ctx *ctx = buffer_event_to_ping_ctx(ev);
 	int rc;
-	int len;
 	struct ping_msg msg;
 	char idbuf[64];
 
@@ -712,30 +674,12 @@ void s_a_recv_cb(const struct c2_net_buffer_event *ev)
 
 		if (msg.pm_type != PM_MSG)
 			C2_IMPOSSIBLE("Server: got desc\n");
-		len = strlen(msg.pm_u.pm_str);
-		if (len < 32)
+		else if (strlen(msg.pm_u.pm_str) < 32)
 			ctx->pc_ops->pf("%s: got data: %s\n",
 					idbuf, msg.pm_u.pm_str);
 		else
-			ctx->pc_ops->pf("%s: got data: %u bytes\n",
-					idbuf, len + 1);
-		C2_ASSERT(ev->nbe_length == len + 2);
-		if (strcmp(msg.pm_u.pm_str, DEF_SEND) != 0) {
-			int i;
-			for (i = 0; i < len - 1; ++i) {
-				if (msg.pm_u.pm_str[i] != "abcdefghi"[i % 9]) {
-					PING_ERR("%s: data diff @ offset %i: "
-						 "%c != %c\n", idbuf, i,
-						 msg.pm_u.pm_str[i],
-						 "abcdefghi"[i % 9]);
-					break;
-				}
-			}
-			if (i == len - 1)
-				ctx->pc_ops->pf("%s: data bytes validated\n",
-						idbuf);
-		}
-
+			ctx->pc_ops->pf("%s: got data: %lu bytes\n",
+					idbuf, strlen(msg.pm_u.pm_str));
 		msg_free(&msg);
 	}
 
@@ -783,6 +727,58 @@ struct c2_net_tm_callbacks stm_cb = {
 void ping_fini(struct ping_ctx *ctx);
 
 /**
+   Resolve hostname into a dotted quad.  The result is stored in buf.
+   @retval 0 success
+   @retval -errno failure
+ */
+int canon_host(const char *hostname, char *buf, size_t bufsiz)
+{
+	int                i;
+	int		   rc = 0;
+	struct in_addr     ipaddr;
+
+	/* c2_net_end_point_create requires string IPv4 address, not name */
+	if (inet_aton(hostname, &ipaddr) == 0) {
+		struct hostent he;
+		char he_buf[4096];
+		struct hostent *hp;
+		int herrno;
+
+		rc = gethostbyname_r(hostname, &he, he_buf, sizeof he_buf,
+				     &hp, &herrno);
+		if (rc != 0) {
+			fprintf(stderr, "Can't get address for %s\n",
+				hostname);
+			return -ENOENT;
+		}
+		for (i = 0; hp->h_addr_list[i] != NULL; ++i)
+			/* take 1st IPv4 address found */
+			if (hp->h_addrtype == AF_INET &&
+			    hp->h_length == sizeof(ipaddr))
+				break;
+		if (hp->h_addr_list[i] == NULL) {
+			fprintf(stderr, "No IPv4 address for %s\n",
+				hostname);
+			return -EPFNOSUPPORT;
+		}
+		if (inet_ntop(hp->h_addrtype, hp->h_addr, buf, bufsiz) ==
+		    NULL) {
+			fprintf(stderr, "Cannot parse network address for %s\n",
+				hostname);
+			rc = -errno;
+		}
+	} else {
+		if (strlen(hostname) >= bufsiz) {
+			fprintf(stderr, "Buffer size too small for %s\n",
+				hostname);
+			return -ENOSPC;
+		}
+		strcpy(buf, hostname);
+	}
+	return rc;
+}
+
+/**
    Initialise a ping client or server.
    Calls all the required c2_net APIs in the correct order, with
    cleanup on failure.
@@ -796,70 +792,64 @@ int ping_init(struct ping_ctx *ctx)
 {
 	int                i;
 	int                rc;
+	char               hostbuf[16]; /* big enough for 255.255.255.255 */
 	char               addr[C2_NET_BULK_MEM_XEP_ADDR_LEN];
 	struct c2_clink    tmwait;
 
 	c2_list_init(&ctx->pc_work_queue);
 
+	rc = canon_host(ctx->pc_hostname, hostbuf, sizeof(hostbuf));
+	if (rc != 0)
+		goto fail;
+
 	rc = c2_net_domain_init(&ctx->pc_dom, ctx->pc_xprt);
 	if (rc != 0) {
-		PING_ERR("domain init failed: %d\n", rc);
+		fprintf(stderr, "domain init failed: %d\n", rc);
 		goto fail;
 	}
 
-	if (ctx->pc_sunrpc_ep_delay >= 0 &&
-	    ctx->pc_dom.nd_xprt == &c2_net_bulk_sunrpc_xprt) {
-		ctx->pc_ops->pf("%s: setting EP release delay to %ds\n",
-				ctx->pc_ident, ctx->pc_sunrpc_ep_delay);
-		c2_net_bulk_sunrpc_dom_set_end_point_release_delay
-			(&ctx->pc_dom, ctx->pc_sunrpc_ep_delay);
-	}
-
-	if (ctx->pc_sunrpc_skulker_period > 0) {
-		ctx->pc_ops->pf("%s: setting skulker period to %ds\n",
-				ctx->pc_ident, ctx->pc_sunrpc_skulker_period);
-		c2_net_bulk_sunrpc_dom_set_skulker_period
-			(&ctx->pc_dom, ctx->pc_sunrpc_skulker_period);
-	}
-
 	rc = alloc_buffers(ctx->pc_nr_bufs, ctx->pc_segments, ctx->pc_seg_size,
 			   &ctx->pc_nbs);
 	if (rc != 0) {
-		PING_ERR("buffer allocation failed: %d\n", rc);
+		fprintf(stderr, "buffer allocation failed: %d\n", rc);
 		goto fail;
 	}
 	rc = c2_bitmap_init(&ctx->pc_nbbm, ctx->pc_nr_bufs);
 	if (rc != 0) {
-		PING_ERR("buffer bitmap allocation failed: %d\n", rc);
+		fprintf(stderr, "buffer bitmap allocation failed: %d\n", rc);
 		goto fail;
 	}
 	C2_ASSERT(ctx->pc_buf_callbacks != NULL);
 	for (i = 0; i < ctx->pc_nr_bufs; ++i) {
 		rc = c2_net_buffer_register(&ctx->pc_nbs[i], &ctx->pc_dom);
 		if (rc != 0) {
-			PING_ERR("buffer register failed: %d\n", rc);
+			fprintf(stderr, "buffer register failed: %d\n", rc);
 			goto fail;
 		}
 		ctx->pc_nbs[i].nb_callbacks = ctx->pc_buf_callbacks;
 	}
 
 	if (ctx->pc_id != 0)
-		sprintf(addr, "%s:%u:%u", ctx->pc_hostname, ctx->pc_port,
-			ctx->pc_id);
+		sprintf(addr, "%s:%u:%u", hostbuf, ctx->pc_port, ctx->pc_id);
 	else
-		sprintf(addr, "%s:%u", ctx->pc_hostname, ctx->pc_port);
+		sprintf(addr, "%s:%u", hostbuf, ctx->pc_port);
+	rc = c2_net_end_point_create(&ctx->pc_ep, &ctx->pc_dom, addr);
+	if (rc != 0) {
+		fprintf(stderr, "end point create failed: %d\n", rc);
+		goto fail;
+	}
 
 	rc = c2_net_tm_init(&ctx->pc_tm, &ctx->pc_dom);
 	if (rc != 0) {
-		PING_ERR("transfer machine init failed: %d\n", rc);
+		fprintf(stderr, "transfer machine init failed: %d\n", rc);
 		goto fail;
 	}
 
 	c2_clink_init(&tmwait, NULL);
 	c2_clink_add(&ctx->pc_tm.ntm_chan, &tmwait);
-	rc = c2_net_tm_start(&ctx->pc_tm, addr);
+	rc = c2_net_tm_start(&ctx->pc_tm, ctx->pc_ep);
 	if (rc != 0) {
-		PING_ERR("transfer machine start failed: %d\n", rc);
+		fprintf(stderr, "transfer machine start failed: %d\n", rc);
 		goto fail;
 	}
 
@@ -870,7 +860,7 @@ int ping_init(struct ping_ctx *ctx)
 		rc = ctx->pc_status;
 		if (rc == 0)
 			rc = -EINVAL;
-		PING_ERR("transfer machine start failed: %d\n", rc);
+		fprintf(stderr, "transfer machine start failed: %d\n", rc);
 		goto fail;
 	}
 
@@ -890,6 +880,7 @@ void ping_fini(struct ping_ctx *ctx)
 			struct c2_clink tmwait;
 			c2_clink_init(&tmwait, NULL);
 			c2_clink_add(&ctx->pc_tm.ntm_chan, &tmwait);
+
 			c2_net_tm_stop(&ctx->pc_tm, true);
 			while (ctx->pc_tm.ntm_state != C2_NET_TM_STOPPED)
 				c2_chan_wait(&tmwait); /* wait for it to stop */
@@ -899,8 +890,18 @@ void ping_fini(struct ping_ctx *ctx)
 		if (ctx->pc_ops->pqs != NULL)
 			(*ctx->pc_ops->pqs)(ctx, false);
 
+		while (1) {
+			c2_time_t delay;
+			if (ctx->pc_tm.ntm_state == C2_NET_TM_STOPPED ||
+			    ctx->pc_tm.ntm_state == C2_NET_TM_FAILED)
+				break;
+			c2_time_set(&delay, 0, 1000L);
+			c2_nanosleep(delay, NULL);
+		}
 		c2_net_tm_fini(&ctx->pc_tm);
 	}
+	if (ctx->pc_ep != NULL)
+		c2_net_end_point_put(ctx->pc_ep);
 	if (ctx->pc_nbs != NULL) {
 		int i;
 		for (i = 0; i < ctx->pc_nr_bufs; ++i) {
@@ -910,7 +911,6 @@ void ping_fini(struct ping_ctx *ctx)
 			c2_bufvec_free(&nb->nb_buffer);
 		}
 		c2_free(ctx->pc_nbs);
-		c2_bitmap_fini(&ctx->pc_nbbm);
 	}
 	if (ctx->pc_dom.nd_xprt != NULL)
 		c2_net_domain_fini(&ctx->pc_dom);
@@ -934,7 +934,7 @@ void ping_server(struct ping_ctx *ctx)
 	ctx->pc_tm.ntm_callbacks = &stm_cb;
 	ctx->pc_buf_callbacks = &sbuf_cb;
 	if (ctx->pc_hostname == NULL)
-		ctx->pc_hostname = "127.0.0.1";
+		ctx->pc_hostname = "localhost";
 	if (ctx->pc_port == 0)
 		ctx->pc_port = PING_PORT1;
 	ctx->pc_ident = "Server";
@@ -948,8 +948,6 @@ void ping_server(struct ping_ctx *ctx)
 		nb->nb_qtype = C2_NET_QT_MSG_RECV;
 		nb->nb_timeout = C2_TIME_NEVER;
 		nb->nb_ep = NULL;
-		nb->nb_min_receive_size = ctx->pc_segments * ctx->pc_seg_size;
-		nb->nb_max_receive_msgs = 1;
 		rc = c2_net_buffer_add(nb, &ctx->pc_tm);
 		c2_bitmap_set(&ctx->pc_nbbm, i, true);
 		C2_ASSERT(rc == 0);
@@ -996,7 +994,7 @@ void ping_server(struct ping_ctx *ctx)
 	/* wait for active buffers to flush */
 	c2_clink_add(&ctx->pc_tm.ntm_chan, &tmwait);
 	for (i = 0; i < C2_NET_QT_NR; ++i)
-		while (!tm_tlist_is_empty(&ctx->pc_tm.ntm_q[i])) {
+		while (!c2_list_is_empty(&ctx->pc_tm.ntm_q[i])) {
 			ctx->pc_ops->pf("waiting for queue %d to empty\n", i);
 			c2_chan_wait(&tmwait);
 		}
@@ -1046,8 +1044,6 @@ int ping_client_msg_send_recv(struct ping_ctx *ctx,
 	nb->nb_qtype = C2_NET_QT_MSG_RECV;
 	nb->nb_timeout = C2_TIME_NEVER;
 	nb->nb_ep = NULL;
-	nb->nb_min_receive_size = ctx->pc_segments * ctx->pc_seg_size;
-	nb->nb_max_receive_msgs = 1;
 	rc = c2_net_buffer_add(nb, &ctx->pc_tm);
 	C2_ASSERT(rc == 0);
 
@@ -1123,14 +1119,7 @@ int ping_client_passive_recv(struct ping_ctx *ctx,
 	C2_ASSERT(nb != NULL);
 	nb->nb_qtype = C2_NET_QT_PASSIVE_BULK_RECV;
 	nb->nb_ep = server_ep;
-	if (ctx->pc_passive_bulk_timeout > 0) {
-		ctx->pc_ops->pf("%s: setting nb_timeout to %ds\n",
-				ctx->pc_ident, ctx->pc_passive_bulk_timeout);
-		nb->nb_timeout =
-			ping_c2_time_after_secs(ctx->pc_passive_bulk_timeout);
-	} else {
-		nb->nb_timeout = C2_TIME_NEVER;
-	}
+	nb->nb_timeout = C2_TIME_NEVER;
 	rc = c2_net_buffer_add(nb, &ctx->pc_tm);
 	C2_ASSERT(rc == 0);
 	rc = c2_net_desc_copy(&nb->nb_desc, &nbd);
@@ -1213,14 +1202,7 @@ int ping_client_passive_send(struct ping_ctx *ctx,
 	rc = encode_msg(nb, data);
 	nb->nb_qtype = C2_NET_QT_PASSIVE_BULK_SEND;
 	nb->nb_ep = server_ep;
-	if (ctx->pc_passive_bulk_timeout > 0) {
-		ctx->pc_ops->pf("%s: setting nb_timeout to %ds\n",
-				ctx->pc_ident, ctx->pc_passive_bulk_timeout);
-		nb->nb_timeout =
-			ping_c2_time_after_secs(ctx->pc_passive_bulk_timeout);
-	} else {
-		nb->nb_timeout = C2_TIME_NEVER;
-	}
+	nb->nb_timeout = C2_TIME_NEVER;
 	rc = c2_net_buffer_add(nb, &ctx->pc_tm);
 	C2_ASSERT(rc == 0);
 	rc = c2_net_desc_copy(&nb->nb_desc, &nbd);
@@ -1284,14 +1266,15 @@ int ping_client_passive_send(struct ping_ctx *ctx,
 int ping_client_init(struct ping_ctx *ctx, struct c2_net_end_point **server_ep)
 {
 	int rc;
+	char hostbuf[16];
 	char addr[C2_NET_BULK_MEM_XEP_ADDR_LEN];
 
 	ctx->pc_tm.ntm_callbacks = &ctm_cb;
 	ctx->pc_buf_callbacks = &cbuf_cb;
 	if (ctx->pc_hostname == NULL)
-		ctx->pc_hostname = "127.0.0.1";
+		ctx->pc_hostname = "localhost";
 	if (ctx->pc_rhostname == NULL)
-		ctx->pc_rhostname = "127.0.0.1";
+		ctx->pc_rhostname = "localhost";
 	if (ctx->pc_port == 0)
 		ctx->pc_port = PING_PORT2;
 	if (ctx->pc_rport == 0)
@@ -1303,11 +1286,14 @@ int ping_client_init(struct ping_ctx *ctx, struct c2_net_end_point **server_ep)
 		return rc;
 
 	/* need end point for the server */
+	rc = canon_host(ctx->pc_rhostname, hostbuf, sizeof(hostbuf));
+	if (rc != 0)
+		return rc;
 	if (ctx->pc_rid != 0)
-		sprintf(addr, "%s:%u:%u", ctx->pc_rhostname, ctx->pc_rport, ctx->pc_rid);
+		sprintf(addr, "%s:%u:%u", hostbuf, ctx->pc_rport, ctx->pc_rid);
 	else
-		sprintf(addr, "%s:%u", ctx->pc_rhostname, ctx->pc_rport);
-	rc = c2_net_end_point_create(server_ep, &ctx->pc_tm, addr);
+		sprintf(addr, "%s:%u", hostbuf, ctx->pc_rport);
+	rc = c2_net_end_point_create(server_ep, &ctx->pc_dom, addr);
 	return rc;
 }
 
diff --git a/net/bulk_emulation/st/ping.h b/net/bulk_emulation/st/ping.h
index d9d42bb..c2abbd6 100644
--- a/net/bulk_emulation/st/ping.h
+++ b/net/bulk_emulation/st/ping.h
@@ -14,8 +14,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Carl Braganza <Carl_Braganza@us.xyratex.com>,
- *                  Dave Cohrs <Dave_Cohrs@us.xyratex.com>
+ * Original author: Carl Braganza, Dave Cohrs
  * Original creation date: 04/12/2011
  */
 #ifndef __COLIBRI_NET_BULK_MEM_PING_H__
@@ -35,11 +34,11 @@ struct ping_ctx {
 	const struct ping_ops		     *pc_ops;
 	struct c2_net_xprt		     *pc_xprt;
 	struct c2_net_domain		      pc_dom;
-	const char		             *pc_hostname; /* dotted decimal */
+	const char		             *pc_hostname;
 	short				      pc_port;
 	uint32_t			      pc_id;
 	int32_t				      pc_status;
-	const char			     *pc_rhostname; /* dotted decimal */
+	const char			     *pc_rhostname;
 	short				      pc_rport;
 	uint32_t			      pc_rid;
 	uint32_t		              pc_nr_bufs;
@@ -49,16 +48,13 @@ struct ping_ctx {
 	struct c2_net_buffer		     *pc_nbs;
 	const struct c2_net_buffer_callbacks *pc_buf_callbacks;
 	struct c2_bitmap		      pc_nbbm;
+	struct c2_net_end_point		     *pc_ep;
 	struct c2_net_transfer_mc	      pc_tm;
 	struct c2_mutex			      pc_mutex;
 	struct c2_cond			      pc_cond;
 	struct c2_list			      pc_work_queue;
 	const char		             *pc_ident;
 	const char		             *pc_compare_buf;
-	int                                   pc_sunrpc_ep_delay;
-	int                                   pc_passive_bulk_timeout;
-	int                                   pc_server_bulk_delay;
-	int                                   pc_sunrpc_skulker_period;
 };
 
 enum {
@@ -67,15 +63,6 @@ enum {
 	PART3_SERVER_ID = 141421,
 };
 
-/* Debug printf macro */
-#ifdef __KERNEL__
-#define PING_ERR(fmt, ...) printk(KERN_ERR fmt , ## __VA_ARGS__)
-#define PRId64 "lld" /* from <inttypes.h> */
-#else
-#include <stdio.h>
-#define PING_ERR(fmt, ...) fprintf(stderr, fmt , ## __VA_ARGS__)
-#endif
-
 void ping_server(struct ping_ctx *ctx);
 void ping_server_should_stop(struct ping_ctx *ctx);
 int ping_client_init(struct ping_ctx *ctx, struct c2_net_end_point **server_ep);
diff --git a/net/bulk_emulation/sunrpc_io.ff b/net/bulk_emulation/sunrpc_io.ff
index f54dd68..e867bb9 100644
--- a/net/bulk_emulation/sunrpc_io.ff
+++ b/net/bulk_emulation/sunrpc_io.ff
@@ -1,25 +1,5 @@
 /* -*- C -*- */
 
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Carl Braganza <Carl_Braganza@us.xyratex.com>,
- *                  Dave Cohrs <Dave_Cohrs@us.xyratex.com>
- * Original creation date: 04/12/2011
- */
-
 /**
    @addtogroup bulksunrpc
    @{
@@ -40,6 +20,7 @@ DEF(sunrpc_ep, RECORD,
 /* appropriate network buffer descriptor */
 DEF(sunrpc_buf_desc, RECORD,
     _(sbd_id,         U64),
+    _(sbd_active_ep,  sunrpc_ep),
     _(sbd_passive_ep, sunrpc_ep),
     _(sbd_qtype,      U32),
     _(sbd_total,      U32));
diff --git a/net/bulk_emulation/sunrpc_xprt.h b/net/bulk_emulation/sunrpc_xprt.h
index 1775935..56d6ec2 100644
--- a/net/bulk_emulation/sunrpc_xprt.h
+++ b/net/bulk_emulation/sunrpc_xprt.h
@@ -14,8 +14,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Carl Braganza <Carl_Braganza@us.xyratex.com>,
- *                  Dave Cohrs <Dave_Cohrs@us.xyratex.com>
+ * Original author: Carl Braganza, Dave Cohrs
  * Original creation date: 04/12/2011
  */
 #ifndef __COLIBRI_NET_BULK_SUNRPC_XPRT_H__
@@ -24,11 +23,11 @@
 #include "net/bulk_sunrpc.h"
 #include "net/bulk_emulation/mem_xprt.h"
 
+#include <arpa/inet.h>
 
 #ifdef __KERNEL__
 #include "net/bulk_emulation/sunrpc_io_k.h"
 #else
-#include <arpa/inet.h>
 #include "net/bulk_emulation/sunrpc_io_u.h"
 #endif
 
@@ -47,20 +46,13 @@ struct c2_net_bulk_sunrpc_domain_pvt;
 struct c2_net_bulk_sunrpc_tm_pvt;
 struct c2_net_bulk_sunrpc_end_point;
 struct c2_net_bulk_sunrpc_buffer_pvt;
-struct c2_net_bulk_sunrpc_conn;
 
 enum {
 	C2_NET_BULK_SUNRPC_XDP_MAGIC  = 0x53756e7270634450ULL,
 	C2_NET_BULK_SUNRPC_XTM_MAGIC  = 0x53756e727063544dULL,
 	C2_NET_BULK_SUNRPC_XEP_MAGIC  = 0x53756e7270634550ULL,
 	C2_NET_BULK_SUNRPC_XBP_MAGIC  = 0x53756e7270634250ULL,
-	C2_NET_BULK_SUNRPC_CONN_MAGIC = 0x53756e727063436fULL,
 	C2_NET_BULK_SUNRPC_TM_THREADS = 2,
-	C2_NET_BULK_SUNRPC_MAX_BUFFER_SIZE     = (1<<19),
-	C2_NET_BULK_SUNRPC_MAX_SEGMENT_SIZE    = (1<<19),
-	C2_NET_BULK_SUNRPC_MAX_BUFFER_SEGMENTS = 256,
-	C2_NET_BULK_SUNRPC_EP_DELAY_S = 20, /* in seconds */
-	C2_NET_BULK_SUNRPC_SKULKER_PERIOD_S  = 10, /* in seconds */
 };
 
 /** Domain private data. */
@@ -75,33 +67,6 @@ struct c2_net_bulk_sunrpc_domain_pvt {
 
 	/** The user or kernel space sunrpc domain */
         struct c2_net_domain              xd_rpc_dom;
-
-	/** The delay before releasing an EP */
-	c2_time_t                         xd_ep_release_delay;
-
-	/** The skulker thread */
-	struct c2_thread                  xd_skulker_thread;
-
-	/** Skulker CV */
-	struct c2_cond                    xd_skulker_cv;
-
-	/** Skulker control */
-	bool                              xd_skulker_run;
-
-	/** Skulker heart beat counter (for UT) */
-	uint32_t                          xd_skulker_hb;
-
-	/** Skulker clock period */
-	c2_time_t                         xd_skulker_period;
-
-	/** Skulker forced execution */
-	bool                              xd_skulker_force;
-
-	/** Connection cache of struct c2_net_bulk_sunrpc_conn objects */
-	struct c2_list                    xd_conn_cache;
-
-	/** Connection cache CV */
-	struct c2_cond                    xd_conn_cache_cv;
 };
 
 /**
@@ -114,6 +79,7 @@ sunrpc_dom_to_pvt(const struct c2_net_domain *dom)
 	return container_of(mdp, struct c2_net_bulk_sunrpc_domain_pvt, xd_base);
 }
 
+
 /** Buffer private data. */
 struct c2_net_bulk_sunrpc_buffer_pvt {
 	uint64_t                          xsb_magic;
@@ -169,6 +135,17 @@ struct c2_net_bulk_sunrpc_end_point {
 
 	/** The in-memory base end point */
 	struct c2_net_bulk_mem_end_point xep_base;
+
+	/** Indicator that xep_sid has been initialized */
+	bool                             xep_sid_valid;
+
+	/** Indicator that a connection has been created
+	    for the sid in the underlying transport.
+	 */
+	bool                             xep_conn_created;
+
+	/** Service id */
+	struct c2_service_id             xep_sid;
 };
 
 /**
@@ -181,87 +158,6 @@ sunrpc_ep_to_pvt(const struct c2_net_end_point *ep)
 	return container_of(mep, struct c2_net_bulk_sunrpc_end_point, xep_base);
 }
 
-/**
-   Connection cache entry maintained per domain.  It is used to
-   track open connections and delay their destruction.
- */
-struct c2_net_bulk_sunrpc_conn {
-	/** magic */
-	uint64_t                         xc_magic;
-
-	/** reference counter */
-	struct c2_ref                    xc_ref;
-
-	/** domain pointer */
-	struct c2_net_domain            *xc_dom;
-
-	/** domain private linkage */
-	struct c2_list_link              xc_dp_linkage;
-
-	/** IP address, port number */
-	struct sockaddr_in               xc_sa;
-
-	/** flag set when long operations are in progress */
-	bool                             xc_in_use;
-
-	/** sid created flag */
-	bool                             xc_sid_created;
-
-	/** Service id used to lookup the connection */
-	struct c2_service_id             xc_sid;
-
-	/** conn created flag */
-	bool                             xc_conn_created;
-
-	/** The time the internal sunrpc connection was last used.
-	    The field is used to control the duration of end point caching.
-	    A value of C2_TIME_NEVER implies that the connection encountered
-	    an error and hence the end point should not be cached.
-
-	    The value is maintained as an atomic variable to avoid
-	    the need to acquire the domain mutex when setting the value.
-	 */
-	struct c2_atomic64               xc_last_use;
-};
-
-/**
-   Recover the sunrpc conn pointer from a pointer to the embedded reference.
- */
-static inline struct c2_net_bulk_sunrpc_conn *
-sunrpc_ref_to_conn(struct c2_ref *ref)
-{
-	return container_of(ref, struct c2_net_bulk_sunrpc_conn, xc_ref);
-}
-
-/**
-   Populate a struct sunrpc_buffer given a buffer pointer and length.
-   @pre sb != NULL
-   @param sb buffer object to initialize
-   @param cur start of buffer to initialize the sunrpc_buffer, or NULL.
-   Cursor is moved by len bytes on success.
-   @param len size of buffer.  The sunrpc_buffer is created with a buffer of
-   this size.  If cur is non-NULL, its contents, up to len, are also copied
-   into the buffer.
-   @retval 0 (success)
-   @retval -errno (failure)
- */
-int sunrpc_buffer_init(struct sunrpc_buffer *sb,
-		       struct c2_bufvec_cursor *cur, c2_bcount_t len);
-
-/** release pages pinned and memory allocated by sunrpc_buffer_init */
-void sunrpc_buffer_fini(struct sunrpc_buffer *sb);
-
-/**
-   Copy the contents of a sunrpc_buffer out to a c2_bufvec using a cursor.
-   @pre sb != NULL && sb->sb_buf != NULL && sb->sb_pgoff < PAGE_CACHE_SIZE
-   @param dest destination buffer cursor
-   @param sb source sunrpc_buffer
-   @retval 0 (success)
-   @retval -errno (failure)
- */
-int sunrpc_buffer_copy_out(struct c2_bufvec_cursor *dest,
-			   const struct sunrpc_buffer *sb);
-
 int c2_sunrpc_fop_init(void);
 void c2_sunrpc_fop_fini(void);
 
diff --git a/net/bulk_emulation/sunrpc_xprt_bulk.c b/net/bulk_emulation/sunrpc_xprt_bulk.c
index cee85aa..38fc6fa 100644
--- a/net/bulk_emulation/sunrpc_xprt_bulk.c
+++ b/net/bulk_emulation/sunrpc_xprt_bulk.c
@@ -14,8 +14,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Carl Braganza <Carl_Braganza@us.xyratex.com>,
- *                  Dave Cohrs <Dave_Cohrs@us.xyratex.com>
+ * Original author: Carl Braganza, Dave Cohrs
  * Original creation date: 04/12/2011
  */
 
@@ -74,15 +73,15 @@ static int sunrpc_get_handler(struct c2_fop *fop, struct c2_fop_ctx *ctx)
 	}
 
 	/* locate the passive buffer */
-	c2_tlist_for(&tm_tl, &tm->ntm_q[in->sg_desc.sbd_qtype], inb) {
+	c2_list_for_each_entry(&tm->ntm_q[in->sg_desc.sbd_qtype], inb,
+			       struct c2_net_buffer,
+			       nb_tm_linkage) {
 		if (sunrpc_desc_equal(&inb->nb_desc, &in->sg_desc) &&
 		    inb->nb_length == in->sg_desc.sbd_total) {
-			if ((inb->nb_flags & (C2_NET_BUF_CANCELLED |
-					      C2_NET_BUF_TIMED_OUT)) == 0)
-				nb = inb;
+			nb = inb;
 			break;
 		}
-	} c2_tlist_endfor;
+	}
 	if (nb == NULL) {
 		rc = -ENOENT;
 		goto done;
@@ -90,7 +89,7 @@ static int sunrpc_get_handler(struct c2_fop *fop, struct c2_fop_ctx *ctx)
 
 	/* copy up to 1 segment from passive buffer into the reply,
 	   and set sgr_eof if end of net buffer is reached.
-	 */
+	*/
 	len = nb->nb_length;
 	c2_bufvec_cursor_init(&cur, &nb->nb_buffer);
 	eof = c2_bufvec_cursor_move(&cur, in->sg_offset);
@@ -98,13 +97,34 @@ static int sunrpc_get_handler(struct c2_fop *fop, struct c2_fop_ctx *ctx)
 	if (!eof && len > in->sg_offset) {
 		c2_bcount_t step;
 		len -= in->sg_offset;
-		step = min_check(c2_bufvec_cursor_step(&cur), len);
+		step = min32u(c2_bufvec_cursor_step(&cur), len);
 
-		rc = sunrpc_buffer_init(&ex->sgr_buf, &cur, step);
-		eof = c2_bufvec_cursor_move(&cur, 0);
+		ex->sgr_buf.sb_len = step;
+		C2_ALLOC_ARR(ex->sgr_buf.sb_buf, step);
+		if (ex->sgr_buf.sb_buf == NULL)
+			rc = -ENOMEM;
+		else {
+			struct c2_bufvec dtmp = {
+				.ov_vec = {
+					.v_nr = 1,
+					.v_count = &step
+				},
+				.ov_buf = (void**) &ex->sgr_buf.sb_buf
+			};
+			struct c2_bufvec_cursor dcur;
+			c2_bcount_t copied;
+
+			c2_bufvec_cursor_init(&dcur, &dtmp);
+			copied = c2_bufvec_cursor_copy(&dcur, &cur, step);
+			C2_ASSERT(copied == step);
+			eof = c2_bufvec_cursor_move(&cur, 0);
+		}
 	} else {
-		rc = sunrpc_buffer_init(&ex->sgr_buf, NULL, 0);
 		eof = true;
+		ex->sgr_buf.sb_len = 0;
+		C2_ALLOC_ARR(ex->sgr_buf.sb_buf, 1);
+		if (ex->sgr_buf.sb_buf == NULL)
+			rc = -ENOMEM;
 	}
 	ex->sgr_eof = eof;
 
@@ -128,6 +148,9 @@ static int sunrpc_put_handler(struct c2_fop *fop, struct c2_fop_ctx *ctx)
 	struct c2_net_buffer      *nb = NULL;
 	struct c2_net_buffer      *inb;
 	struct c2_bufvec_cursor    cur;
+	struct c2_bufvec_cursor    scur;
+	c2_bcount_t                len;
+	c2_bcount_t                copied;
 	int                        rc = 0;
 
 	reply = c2_fop_alloc(&sunrpc_put_resp_fopt, NULL);
@@ -142,14 +165,14 @@ static int sunrpc_put_handler(struct c2_fop *fop, struct c2_fop_ctx *ctx)
 	}
 
 	/* locate the passive buffer */
-	c2_tlist_for(&tm_tl, &tm->ntm_q[in->sp_desc.sbd_qtype], inb) {
+	c2_list_for_each_entry(&tm->ntm_q[in->sp_desc.sbd_qtype], inb,
+			       struct c2_net_buffer,
+			       nb_tm_linkage) {
 		if (sunrpc_desc_equal(&inb->nb_desc, &in->sp_desc)) {
-			if ((inb->nb_flags & (C2_NET_BUF_CANCELLED |
-					      C2_NET_BUF_TIMED_OUT)) == 0)
-				nb = inb;
+			nb = inb;
 			break;
 		}
-	} c2_tlist_endfor;
+	}
 	if (nb == NULL) {
 		rc = -ENOENT;
 		goto done;
@@ -159,12 +182,25 @@ static int sunrpc_put_handler(struct c2_fop *fop, struct c2_fop_ctx *ctx)
 	   starting at the specified offset.  Assumes the put operations
 	   are performed sequentially, so the passive callback can be
 	   made as soon as the final put operation is performed.
-	 */
+	*/
+	len = in->sp_buf.sb_len;
 	c2_bufvec_cursor_init(&cur, &nb->nb_buffer);
+
+	struct c2_bufvec stmp = {
+		.ov_vec = {
+			.v_nr = 1,
+			.v_count = &len
+		},
+		.ov_buf = (void**) &in->sp_buf.sb_buf
+	};
+
+	c2_bufvec_cursor_init(&scur, &stmp);
 	c2_bufvec_cursor_move(&cur, in->sp_offset);
-	rc = sunrpc_buffer_copy_out(&cur, &in->sp_buf);
-	if (rc < 0 ||
-	    in->sp_offset + in->sp_buf.sb_len == in->sp_desc.sbd_total) {
+	copied = c2_bufvec_cursor_copy(&cur, &scur, len);
+	if (copied < len) {
+		rc = -EFBIG;
+		sunrpc_queue_passive_cb(nb, rc, in->sp_desc.sbd_total);
+	} else if (in->sp_offset + in->sp_buf.sb_len == in->sp_desc.sbd_total) {
 		sunrpc_queue_passive_cb(nb, rc, in->sp_desc.sbd_total);
 	}
 
@@ -182,7 +218,6 @@ static int sunrpc_active_send(struct c2_net_buffer *nb,
 {
 	int                      rc = 0;
 	struct c2_net_conn      *conn = NULL;
-	struct c2_net_bulk_sunrpc_conn *sconn;
 	struct c2_fop           *f = NULL;
 	struct c2_fop           *r = NULL;
 	struct sunrpc_put       *fop;
@@ -193,7 +228,7 @@ static int sunrpc_active_send(struct c2_net_buffer *nb,
 	c2_bcount_t              step;
 
 	/* get a connection for this end point */
-	rc = sunrpc_ep_get_conn(ep, &conn, &sconn);
+	rc = sunrpc_ep_get_conn(ep, &conn);
 	if (rc != 0)
 		return rc;
 
@@ -205,33 +240,31 @@ static int sunrpc_active_send(struct c2_net_buffer *nb,
 	}
 	fop = c2_fop_data(f);
 
+	struct c2_net_call call = {
+		.ac_arg = f,
+		.ac_ret = r
+	};
+
 	/*
 	  Walk each buf in our bufvec, sending data
 	  to remote until complete bufvec is transferred.
-	 */
+	*/
 	fop->sp_desc = *sd;
 	fop->sp_desc.sbd_total = len;
 	c2_bufvec_cursor_init(&cur, &nb->nb_buffer);
 	while (len > 0 && rc == 0) {
-		struct c2_net_call call = {
-			.ac_arg = f,
-			.ac_ret = r
-		};
-
 		step = min32u(c2_bufvec_cursor_step(&cur), len);
 		fop->sp_offset = off;
-		rc = sunrpc_buffer_init(&fop->sp_buf, &cur, step);
-		if (rc == 0) {
-			rc = c2_net_cli_call(conn, &call);
-			sunrpc_buffer_fini(&fop->sp_buf);
-		}
+		fop->sp_buf.sb_len = step;
+		fop->sp_buf.sb_buf = c2_bufvec_cursor_addr(&cur);
+		rc = c2_net_cli_call(conn, &call);
 		if (rc == 0) {
 			rep = c2_fop_data(r);
 			rc = rep->spr_rc;
 		}
 		off += step;
 		len -= step;
-		C2_ASSERT(len == 0 || !c2_bufvec_cursor_move(&cur, 0));
+		C2_ASSERT(len == 0 || !c2_bufvec_cursor_move(&cur, step));
 	}
 
 done:
@@ -240,7 +273,7 @@ done:
 	if (f != NULL)
 		c2_fop_free(f);
 	if (conn != NULL)
-		sunrpc_ep_put_conn(sconn, conn, rc);
+		c2_net_conn_release(conn);
 
 	return rc;
 }
@@ -252,18 +285,18 @@ static int sunrpc_active_recv(struct c2_net_buffer *nb,
 {
 	int                      rc;
 	struct c2_net_conn      *conn = NULL;
-	struct c2_net_bulk_sunrpc_conn *sconn;
 	struct c2_fop           *f = NULL;
 	struct c2_fop           *r = NULL;
 	struct sunrpc_get       *fop;
-	struct sunrpc_get_resp  *rep = NULL;
+	struct sunrpc_get_resp  *rep;
 	struct c2_bufvec_cursor  cur;
 	c2_bcount_t              len;
 	size_t                   off = 0;
+	c2_bcount_t              copied;
 	bool                     eof = false;
 
 	/* get a connection for this end point */
-	rc = sunrpc_ep_get_conn(ep, &conn, &sconn);
+	rc = sunrpc_ep_get_conn(ep, &conn);
 	if (rc != 0)
 		return rc;
 
@@ -274,31 +307,25 @@ static int sunrpc_active_recv(struct c2_net_buffer *nb,
 		goto done;
 	}
 	fop = c2_fop_data(f);
-	rep = c2_fop_data(r);
-#ifdef __KERNEL__
-	/* ksunrpc requires pre-allocation of buffer for response */
-	rc = sunrpc_buffer_init(&rep->sgr_buf, NULL,
-				C2_NET_BULK_SUNRPC_MAX_SEGMENT_SIZE);
-	if (rc < 0)
-		goto done;
-#endif
+
+	struct c2_net_call call = {
+		.ac_arg = f,
+		.ac_ret = r
+	};
 
 	/*
 	  Receive data from remote and copy to our bufvec
 	  until complete bufvec is transferred.
-	 */
+	*/
 	fop->sg_desc = *sd;
 	c2_bufvec_cursor_init(&cur, &nb->nb_buffer);
 	*lengthp = sd->sbd_total;
 	while (!eof) {
-		struct c2_net_call call = {
-			.ac_arg = f,
-			.ac_ret = r
-		};
-
+		struct c2_bufvec_cursor scur;
 		fop->sg_offset = off;
 		rc = c2_net_cli_call(conn, &call);
 		if (rc == 0) {
+			rep = c2_fop_data(r);
 			rc = rep->sgr_rc;
 			eof = rep->sgr_eof;
 		}
@@ -306,22 +333,30 @@ static int sunrpc_active_recv(struct c2_net_buffer *nb,
 			break;
 
 		len = rep->sgr_buf.sb_len;
-		rc = sunrpc_buffer_copy_out(&cur, &rep->sgr_buf);
-		if (rc < 0)
+		struct c2_bufvec stmp = {
+			.ov_vec = {
+				.v_nr = 1,
+				.v_count = &len
+			},
+			.ov_buf = (void**) &rep->sgr_buf.sb_buf
+		};
+
+		c2_bufvec_cursor_init(&scur, &stmp);
+		copied = c2_bufvec_cursor_copy(&cur, &scur, len);
+		if (copied < len) {
+			rc = -EFBIG;
 			break;
+		}
 		off += len;
 	}
 
 done:
-	/* fini the buffer even in user-space, xdr decode init's it */
-	if (rep != NULL)
-		sunrpc_buffer_fini(&rep->sgr_buf);
 	if (r != NULL)
 		c2_fop_free(r);
 	if (f != NULL)
 		c2_fop_free(f);
 	if (conn != NULL)
-		sunrpc_ep_put_conn(sconn, conn, rc);
+		c2_net_conn_release(conn);
 
 	return rc;
 }
@@ -360,6 +395,10 @@ static void sunrpc_wf_active_bulk(struct c2_net_transfer_mc *tm,
 		rc = sunrpc_desc_decode(&nb->nb_desc, &sd);
 		if (rc != 0)
 			break;
+		if (!sunrpc_ep_equals_addr(tm->ntm_ep, &sd.sbd_active_ep)) {
+			rc = -EACCES;   /* wrong destination */
+			break;
+		}
 		if (nb->nb_qtype != inverse_qt[sd.sbd_qtype]) {
 			rc = -EPERM;    /* wrong operation */
 			break;
@@ -369,9 +408,9 @@ static void sunrpc_wf_active_bulk(struct c2_net_transfer_mc *tm,
 		si.sin_addr.s_addr = sd.sbd_passive_ep.sep_addr;
 		si.sin_port = sd.sbd_passive_ep.sep_port;
 		sid = sd.sbd_passive_ep.sep_id;
-		c2_mutex_lock(&tm->ntm_mutex);
-		rc = sunrpc_ep_create(&match_ep, tm, &si, sid);
-		c2_mutex_unlock(&tm->ntm_mutex);
+		c2_mutex_lock(&tm->ntm_dom->nd_mutex);
+		rc = sunrpc_ep_create(&match_ep, tm->ntm_dom, &si, sid);
+		c2_mutex_unlock(&tm->ntm_dom->nd_mutex);
 		if (rc != 0) {
 			match_ep = NULL;
 			break;
diff --git a/net/bulk_emulation/sunrpc_xprt_ep.c b/net/bulk_emulation/sunrpc_xprt_ep.c
index 674381f..cd48963 100644
--- a/net/bulk_emulation/sunrpc_xprt_ep.c
+++ b/net/bulk_emulation/sunrpc_xprt_ep.c
@@ -14,8 +14,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Carl Braganza <Carl_Braganza@us.xyratex.com>,
- *                  Dave Cohrs <Dave_Cohrs@us.xyratex.com>
+ * Original author: Carl Braganza, Dave Cohrs
  * Original creation date: 04/12/2011
  */
 
@@ -34,95 +33,6 @@
 static const char *c2_net_bulk_sunrpc_uuid_fmt = "BulkSunrpc-%d";
 
 /**
-   Subroutine to be invoked by the domain skulker thread to
-   age cached connections.
-   @param dom The domain pointer.  The domain mutex is held.
-   @param now The epoch time value, or C2_TIME_NEVER to force the aging.
- */
-static void sunrpc_skulker_process_conn_cache(struct c2_net_domain *dom,
-					      c2_time_t now)
-{
-	struct c2_net_bulk_sunrpc_domain_pvt *dp;
-	struct c2_net_bulk_sunrpc_conn *sc;
-	struct c2_net_bulk_sunrpc_conn *sc_next;
-
-	c2_time_t free_if_before;
-	c2_time_t t;
-
-	C2_PRE(c2_mutex_is_locked(&dom->nd_mutex));
-
-	dp = sunrpc_dom_to_pvt(dom);
-	if (dp->xd_ep_release_delay == 0)
-		now = C2_TIME_NEVER; /* switched off: force aging */
-	if (now != C2_TIME_NEVER) {
-		free_if_before = c2_time_sub(now, dp->xd_ep_release_delay);
-	} else {
-		free_if_before = C2_TIME_NEVER; /* force aging */
-	}
-	/* walk the connection cache, potentially deleting entries as we go */
-	c2_list_for_each_entry_safe(&dp->xd_conn_cache, sc, sc_next,
-			       struct c2_net_bulk_sunrpc_conn,
-			       xc_dp_linkage) {
-		t = c2_atomic64_get(&sc->xc_last_use);
-		if (c2_time_after(t, free_if_before))
-			continue;
-		c2_ref_get(&sc->xc_ref);
-		c2_atomic64_set(&sc->xc_last_use, 0);
-		/* Release the reference, potentially freeing the entry */
-		c2_ref_put(&sc->xc_ref);
-	}
-	return;
-}
-
-/**
-   Invariant
- */
-static bool sunrpc_conn_invariant(const struct c2_net_bulk_sunrpc_conn *sc)
-{
-	if (sc == NULL)
-		return false;
-	if (sc->xc_magic != C2_NET_BULK_SUNRPC_CONN_MAGIC)
-		return false;
-	return true;
-}
-
-/**
-   Sunrpc connection cache release subroutine.
- */
-static void sunrpc_conn_release(struct c2_ref *ref)
-{
-	struct c2_net_bulk_sunrpc_conn *sc = sunrpc_ref_to_conn(ref);
-	struct c2_net_bulk_sunrpc_domain_pvt *dp;
-
-	C2_ASSERT(sunrpc_conn_invariant(sc));
-	C2_ASSERT(c2_mutex_is_locked(&sc->xc_dom->nd_mutex));
-	dp = sunrpc_dom_to_pvt(sc->xc_dom);
-
-	/* If end point release delay is enabled, we delay the release if the
-	   connection last_use time is set.
-	   Note that this feature relies on logic in the underlying sunrpc
-	   transport to silently reset a stale CLIENT structure on ECONNRESET.
-	*/
-	if (dp->xd_ep_release_delay != 0 &&
-	    c2_atomic64_get(&sc->xc_last_use) > 0)
-		return;
-
-	/* free the conn and sid */
-	if (sc->xc_conn_created) {
-		struct c2_net_conn *conn = c2_net_conn_find(&sc->xc_sid);
-		if (conn != NULL) {
-			c2_net_conn_release(conn);
-			c2_net_conn_unlink(conn);
-		}
-	}
-	if (sc->xc_sid_created)
-		c2_service_id_fini(&sc->xc_sid);
-	sc->xc_magic = 0;
-	c2_list_del(&sc->xc_dp_linkage);
-	c2_free(sc);
-}
-
-/**
    End point release subroutine for sunrpc.
    It corresponds to the base transports mem_xo_end_point_release
    subroutine.
@@ -133,12 +43,24 @@ static void sunrpc_conn_release(struct c2_ref *ref)
 static void sunrpc_xo_end_point_release(struct c2_ref *ref)
 {
 	struct c2_net_end_point *ep;
+	struct c2_net_bulk_sunrpc_end_point *sep;
 	struct c2_net_bulk_sunrpc_domain_pvt *dp;
 
 	ep = container_of(ref, struct c2_net_end_point, nep_ref);
 	C2_PRE(sunrpc_ep_invariant(ep));
-	C2_PRE(c2_mutex_is_locked(&ep->nep_tm->ntm_mutex));
-	dp = sunrpc_dom_to_pvt(ep->nep_tm->ntm_dom);
+	C2_PRE(c2_mutex_is_locked(&ep->nep_dom->nd_mutex));
+	sep = sunrpc_ep_to_pvt(ep);
+	dp = sunrpc_dom_to_pvt(ep->nep_dom);
+
+	/* free the conn and sid */
+	if (sep->xep_conn_created) {
+		struct c2_net_conn *conn = c2_net_conn_find(&sep->xep_sid);
+		if (conn != NULL) {
+			c2_net_conn_release(conn);
+			c2_net_conn_unlink(conn);
+		}
+	}
+	c2_service_id_fini(&sep->xep_sid);
 
 	/* release the end point with the base method */
 	(*dp->xd_base_ops->bmo_ep_release)(ref);
@@ -201,14 +123,6 @@ static void sunrpc_ep_free(struct c2_net_bulk_mem_end_point *mep)
 	c2_free(sep);
 }
 
-static void sunrpc_ep_get(struct c2_net_end_point *ep)
-{
-	/* Directly obtain the ref count to avoid the non-zero ref count
-	   assertion in c2_net_end_point_get().
-	*/
-	c2_ref_get(&ep->nep_ref);
-}
-
 /**
    Internal subroutine to create an end point. It corresponds to and
    replaces the base mem_ep_create subroutine.
@@ -228,7 +142,7 @@ static void sunrpc_ep_get(struct c2_net_end_point *ep)
 
 */
 static int sunrpc_ep_create(struct c2_net_end_point **epp,
-			    struct c2_net_transfer_mc *tm,
+			    struct c2_net_domain *dom,
 			    const struct sockaddr_in *sa,
 			    uint32_t id)
 {
@@ -236,17 +150,29 @@ static int sunrpc_ep_create(struct c2_net_end_point **epp,
 	struct c2_net_bulk_sunrpc_end_point *sep;
 	struct c2_net_bulk_sunrpc_domain_pvt *dp;
 
-	C2_PRE(sunrpc_tm_invariant(tm));
-	dp = sunrpc_dom_to_pvt(tm->ntm_dom);
+	C2_PRE(sunrpc_dom_invariant(dom));
+	dp = sunrpc_dom_to_pvt(dom);
 	/* C2_PRE(id > 0);*/
 	/* create the base transport ep first - sunrpc_ep_alloc invoked */
-	rc = (*dp->xd_base_ops->bmo_ep_create)(epp, tm, sa, id);
+	rc = (*dp->xd_base_ops->bmo_ep_create)(epp, dom, sa, id);
 	if (rc != 0)
 		return rc;
 
 	sep = sunrpc_ep_to_pvt(*epp);
 	C2_ASSERT(sep->xep_magic == C2_NET_BULK_SUNRPC_XEP_MAGIC);
 
+	/* create the sid (first time only) */
+	if (!sep->xep_sid_valid) {
+		rc = sunrpc_ep_init_sid(&sep->xep_sid, &dp->xd_rpc_dom, *epp);
+		if (rc == 0) {
+			sep->xep_sid_valid = true;
+		} else {
+			/* directly release the ep (we're in the dom mutex) */
+			c2_ref_put(&(*epp)->nep_ref);
+			*epp = NULL;
+		}
+	}
+
 	C2_POST(ergo(rc == 0, sunrpc_ep_invariant(*epp)));
 	return rc;
 }
@@ -258,138 +184,63 @@ static int sunrpc_ep_create(struct c2_net_end_point **epp,
    transfer machine mutex.
 
    The caller is responsible for releasing the connection with the
-   sunrpc_ep_put_conn() subroutine.
+   c2_net_conn_release() subroutine.
 
    @param ep End point pointer
    @param conn Returns the connection.
-   @param scp Returns a bulk sunrpc cached connection object with tracking
-   data.
    @retval 0 Success
    @retval -errno Failure
    @post ergo(rc == 0, sep->xep_con_created)
  */
 static int sunrpc_ep_get_conn(struct c2_net_end_point *ep,
-			      struct c2_net_conn **conn_p,
-			      struct c2_net_bulk_sunrpc_conn **scp)
+			      struct c2_net_conn **conn_p)
 {
 	int rc;
-	struct c2_net_domain *dom = ep->nep_tm->ntm_dom;
-	struct c2_net_bulk_sunrpc_domain_pvt *dp;
 	struct c2_net_bulk_sunrpc_end_point *sep;
-	struct c2_net_bulk_sunrpc_conn *sc;
-	bool matched = false;
-
 	sep = sunrpc_ep_to_pvt(ep);
+
 	C2_PRE(sunrpc_ep_invariant(ep));
-	C2_PRE(conn_p != NULL);
-	C2_PRE(scp != NULL);
 
-	dp = sunrpc_dom_to_pvt(dom);
 	rc = 0;
-	c2_mutex_lock(&dom->nd_mutex);
-	c2_list_for_each_entry(&dp->xd_conn_cache, sc,
-			       struct c2_net_bulk_sunrpc_conn,
-			       xc_dp_linkage) {
-		if (mem_sa_eq(&sc->xc_sa, &sep->xep_base.xep_sa)) {
-			c2_ref_get(&sc->xc_ref);
-			matched = true;
-			break;
+	if (!sep->xep_conn_created) { /* already exists? */
+		/* create the connection in the mutex */
+		c2_mutex_lock(&ep->nep_dom->nd_mutex);
+		if (!sep->xep_conn_created) { /* racy, so check again */
+			rc = c2_net_conn_create(&sep->xep_sid);
+			if (rc == 0)
+				sep->xep_conn_created = true;
 		}
+		c2_mutex_unlock(&ep->nep_dom->nd_mutex);
 	}
-	if (!matched) {
-		C2_ALLOC_PTR(sc);
-		if (sc == NULL) {
-			rc = -ENOMEM;
-			goto done;
-		}
-		sc->xc_dom = dom;
-		c2_ref_init(&sc->xc_ref, 1, sunrpc_conn_release);
-		c2_atomic64_set(&sc->xc_last_use, 0);
-		sc->xc_sa = sep->xep_base.xep_sa;
-		sc->xc_magic = C2_NET_BULK_SUNRPC_CONN_MAGIC;
-		c2_list_add_tail(&dp->xd_conn_cache, &sc->xc_dp_linkage);
-		/* the skulker removes the entry */
-	}
-	C2_ASSERT(sunrpc_conn_invariant(sc));
-
-	if (!sc->xc_sid_created) {
-		rc = sunrpc_ep_init_sid(&sc->xc_sid, &dp->xd_rpc_dom, ep);
-		if (rc == 0)
-			sc->xc_sid_created = true;
-		else
-			goto done;
-	}
-
-	/* don't hold the mutex during connection creation - network involved */
-	if (!sc->xc_conn_created) {
-		while (sc->xc_in_use)
-			c2_cond_wait(&dp->xd_conn_cache_cv, &dom->nd_mutex);
-	}
-	if (!sc->xc_conn_created) {
-		sc->xc_in_use = true;
-		c2_mutex_unlock(&dom->nd_mutex);
-		rc = c2_net_conn_create(&sc->xc_sid);
-		c2_mutex_lock(&dom->nd_mutex);
-		sc->xc_in_use = false;
-		c2_cond_signal(&dp->xd_conn_cache_cv, &dom->nd_mutex);
-		if (rc == 0)
-			sc->xc_conn_created = true;
-		else
-			goto done;
-	}
-
- done:
-	c2_mutex_unlock(&dom->nd_mutex);
 	if (rc == 0) {
-		C2_ASSERT(sc != NULL);
-		*conn_p = c2_net_conn_find(&sc->xc_sid);
-		if (*conn_p != NULL)
-			*scp = sc;
-		else
+		*conn_p = c2_net_conn_find(&sep->xep_sid);
+		if (*conn_p == NULL) {
 			rc = -ECONNRESET;
+			sep->xep_conn_created = false;
+		}
 	}
-	if (rc != 0 && sc != NULL) {
-		/* get lock in case sunrpc_conn_release is called */
-		c2_mutex_lock(&dom->nd_mutex);
-		c2_ref_put(&sc->xc_ref);
-		c2_mutex_unlock(&dom->nd_mutex);
-	}
-	C2_POST(ergo(rc == 0, *conn_p != NULL && *scp != NULL));
+
+	C2_POST(ergo(rc == 0, sep->xep_conn_created));
 	return rc;
 }
 
 /**
-   Release the c2_net_conn structure returned by sunrpc_ep_get_conn()
-   and record the time the connection was released in the
-   associated connection cache entry.
-   The connection will be cached for a while after last use, unless the
-   error code is non-zero.
-   @param sc The connection cache pointer.
-   @param conn The connection.
-   @param rc  The error code encountered during use.
+   Compare an end point with a sunrpc_ep for equality.
+   @param ep End point
+   @param sep sunrpc_ep pointer
+   @param true Match
+   @param false Do not match
  */
-static void sunrpc_ep_put_conn(struct c2_net_bulk_sunrpc_conn *sc,
-			       struct c2_net_conn *conn,
-			       int rc)
+static bool sunrpc_ep_equals_addr(const struct c2_net_end_point *ep,
+				  const struct sunrpc_ep *sep)
 {
-	c2_time_t t;
-	struct c2_net_domain *dom;
-
-	C2_ASSERT(sunrpc_conn_invariant(sc));
-	dom = sc->xc_dom;
-	C2_ASSERT(c2_mutex_is_not_locked(&dom->nd_mutex));
-
-	c2_net_conn_release(conn);
-	if (rc == 0)
-		t = c2_time_now();
-	else
-		t = 0;
-	C2_CASSERT(sizeof t == sizeof sc->xc_last_use);
-	c2_atomic64_set(&sc->xc_last_use, t);
-	c2_mutex_lock(&dom->nd_mutex);
-	c2_ref_put(&sc->xc_ref);
-	c2_mutex_unlock(&dom->nd_mutex);
-	return;
+	struct c2_net_bulk_mem_end_point *mep;
+	C2_ASSERT(sunrpc_ep_invariant(ep));
+	mep = mem_ep_to_pvt(ep);
+
+	return (mep->xep_sa.sin_addr.s_addr == sep->sep_addr &&
+		mep->xep_sa.sin_port        == sep->sep_port &&
+		mep->xep_service_id         == sep->sep_id);
 }
 
 /**
@@ -406,6 +257,7 @@ static void sunrpc_ep_put_conn(struct c2_net_bulk_sunrpc_conn *sc,
    @retval -errno failure
  */
 static int sunrpc_desc_create(struct c2_net_buf_desc *desc,
+			      struct c2_net_end_point *ep,
 			      struct c2_net_transfer_mc *tm,
 			      enum c2_net_queue_type qt,
 			      c2_bcount_t buflen,
@@ -416,28 +268,25 @@ static int sunrpc_desc_create(struct c2_net_buf_desc *desc,
 	    .sbd_qtype               = qt,
 	    .sbd_total               = buflen,
 	    /* address and port numbers in network byte order */
+	    .sbd_active_ep.sep_addr  = mem_ep_addr(ep),
+	    .sbd_active_ep.sep_port  = mem_ep_port(ep),
+	    .sbd_active_ep.sep_id    = mem_ep_sid(ep),
 	    .sbd_passive_ep.sep_addr = mem_ep_addr(tm->ntm_ep),
 	    .sbd_passive_ep.sep_port = mem_ep_port(tm->ntm_ep),
 	    .sbd_passive_ep.sep_id   = mem_ep_sid(tm->ntm_ep),
 	};
-	int rc = 0;
-#ifndef __KERNEL__
 	XDR xdrs;
-#endif
+	int rc = 0;
 
-	desc->nbd_len = sunrpc_buf_desc_memlayout.fm_sizeof;
+	desc->nbd_len = sizeof(sd);
 	desc->nbd_data = c2_alloc(desc->nbd_len);
 	if (desc->nbd_data == NULL)
 	    return -ENOMEM;
 
-#ifdef __KERNEL__
-	rc = c2_fop_encode_buffer(&sunrpc_buf_desc_tfmt, desc->nbd_data, &sd);
-#else
 	xdrmem_create(&xdrs, desc->nbd_data, desc->nbd_len, XDR_ENCODE);
 	if (!sunrpc_buf_desc_memlayout.fm_uxdr(&xdrs, &sd))
 		rc = -EINVAL;
 	xdr_destroy(&xdrs);
-#endif
 	return rc;
 }
 
@@ -452,9 +301,6 @@ static int sunrpc_desc_create(struct c2_net_buf_desc *desc,
 static int sunrpc_desc_decode(const struct c2_net_buf_desc *desc,
 			      struct sunrpc_buf_desc *sd)
 {
-#ifdef __KERNEL__
-	return c2_fop_decode_buffer(&sunrpc_buf_desc_tfmt, desc->nbd_data, sd);
-#else
 	XDR xdrs;
 	int rc = 0;
 	xdrmem_create(&xdrs, desc->nbd_data, desc->nbd_len, XDR_DECODE);
@@ -462,7 +308,6 @@ static int sunrpc_desc_decode(const struct c2_net_buf_desc *desc,
 		rc = -EINVAL;
 	xdr_destroy(&xdrs);
 	return rc;
-#endif
 }
 
 /**
@@ -476,6 +321,9 @@ static bool sunrpc_desc_equal(const struct c2_net_buf_desc *d1,
 	if (sunrpc_desc_decode(d1, &sd1))
 		return false;
 	if (sd1.sbd_id == sd2->sbd_id &&
+	    sd1.sbd_active_ep.sep_addr == sd2->sbd_active_ep.sep_addr &&
+	    sd1.sbd_active_ep.sep_port == sd2->sbd_active_ep.sep_port &&
+	    sd1.sbd_active_ep.sep_id == sd2->sbd_active_ep.sep_id &&
 	    sd1.sbd_passive_ep.sep_addr == sd2->sbd_passive_ep.sep_addr &&
 	    sd1.sbd_passive_ep.sep_port == sd2->sbd_passive_ep.sep_port &&
 	    sd1.sbd_passive_ep.sep_id == sd2->sbd_passive_ep.sep_id)
diff --git a/net/bulk_emulation/sunrpc_xprt_msg.c b/net/bulk_emulation/sunrpc_xprt_msg.c
index d00cfa8..125f830 100644
--- a/net/bulk_emulation/sunrpc_xprt_msg.c
+++ b/net/bulk_emulation/sunrpc_xprt_msg.c
@@ -14,8 +14,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Carl Braganza <Carl_Braganza@us.xyratex.com>,
- *                  Dave Cohrs <Dave_Cohrs@us.xyratex.com>
+ * Original author: Carl Braganza, Dave Cohrs
  * Original creation date: 04/12/2011
  */
 
@@ -46,9 +45,7 @@ static void sunrpc_wf_msg_send(struct c2_net_transfer_mc *tm,
 	struct c2_net_buffer   *nb   = mem_wi_to_buffer(wi);
 	struct c2_fop          *f    = NULL;
 	struct c2_fop          *r    = NULL;
-	struct sunrpc_msg      *fop  = NULL;
 	struct c2_net_conn     *conn = NULL;
-	struct c2_net_bulk_sunrpc_conn *sconn;
 	int rc;
 	struct c2_net_bulk_sunrpc_domain_pvt *dp;
 
@@ -61,11 +58,12 @@ static void sunrpc_wf_msg_send(struct c2_net_transfer_mc *tm,
 
 	do {
 		struct c2_bufvec_cursor  cur;
+		struct sunrpc_msg       *fop;
 		struct sunrpc_msg_resp  *rep;
 		struct c2_net_end_point *tm_ep;
 
 		/* get a connection for this end point */
-		rc = sunrpc_ep_get_conn(nb->nb_ep, &conn, &sconn);
+		rc = sunrpc_ep_get_conn(nb->nb_ep, &conn);
 		if (rc != 0)
 			break;
 
@@ -87,32 +85,28 @@ static void sunrpc_wf_msg_send(struct c2_net_transfer_mc *tm,
 		fop->sm_receiver.sep_port = mem_ep_port(nb->nb_ep); /* NBO */
 		fop->sm_receiver.sep_id   = mem_ep_sid(nb->nb_ep);
 		c2_bufvec_cursor_init(&cur, &nb->nb_buffer);
-		rc = sunrpc_buffer_init(&fop->sm_buf, &cur, nb->nb_length);
-		if (rc != 0)
-			break;
+		C2_ASSERT(nb->nb_length <= c2_bufvec_cursor_step(&cur));
+		fop->sm_buf.sb_len = nb->nb_length;
+		fop->sm_buf.sb_buf = c2_bufvec_cursor_addr(&cur);
 
 		/* make the RPC call */
-		{
-			struct c2_net_call call = {
-				.ac_arg = f,
-				.ac_ret = r
-			};
-			rc = c2_net_cli_call(conn, &call);
-		}
+		struct c2_net_call call = {
+			.ac_arg = f,
+			.ac_ret = r
+		};
+		rc = c2_net_cli_call(conn, &call);
 		if (rc == 0) {
 			rep = c2_fop_data(r);
 			rc = rep->smr_rc;
 		}
 	} while (0);
 
-	if (fop != NULL)
-		sunrpc_buffer_fini(&fop->sm_buf);
 	if (f != NULL)
 		c2_fop_free(f);
 	if (r != NULL)
 		c2_fop_free(r);
 	if (conn != NULL)
-		sunrpc_ep_put_conn(sconn, conn, rc);
+		c2_net_conn_release(conn);
 
 	/* post the send completion callback (will clear C2_NET_BUF_IN_USE) */
 	wi->xwi_status = rc;
@@ -145,14 +139,14 @@ static int sunrpc_msg_handler(struct c2_fop *fop, struct c2_fop_ctx *ctx)
 	do {
 		/* get the first available receive buffer */
 		bool found_nb = false;
-		c2_tlist_for(&tm_tl, &tm->ntm_q[C2_NET_QT_MSG_RECV], nb) {
-			if ((nb->nb_flags &
-			     (C2_NET_BUF_IN_USE | C2_NET_BUF_CANCELLED |
-			      C2_NET_BUF_TIMED_OUT)) == 0) {
+		c2_list_for_each_entry(&tm->ntm_q[C2_NET_QT_MSG_RECV], nb,
+				       struct c2_net_buffer,
+				       nb_tm_linkage) {
+			if ((nb->nb_flags & C2_NET_BUF_IN_USE) == 0) {
 				found_nb = true;
 				break;
 			}
-		} c2_tlist_endfor;
+		}
 		if (!found_nb) {
 			tm->ntm_qstats[C2_NET_QT_MSG_RECV].nqs_num_f_events++;
 			rc = -ENOBUFS;
@@ -162,7 +156,7 @@ static int sunrpc_msg_handler(struct c2_fop *fop, struct c2_fop_ctx *ctx)
 		C2_ASSERT(sunrpc_buffer_invariant(nb));
 		nb->nb_flags |= C2_NET_BUF_IN_USE;
 		c2_bufvec_cursor_init(&cur, &nb->nb_buffer);
-		if (in->sm_buf.sb_len > c2_vec_count(&nb->nb_buffer.ov_vec)) {
+		if (in->sm_buf.sb_len > c2_bufvec_cursor_step(&cur)) {
 			struct c2_net_bulk_mem_work_item *wi =
 				mem_buffer_to_wi(nb);
 			struct c2_net_bulk_sunrpc_tm_pvt *tp =
@@ -183,6 +177,7 @@ static int sunrpc_msg_handler(struct c2_fop *fop, struct c2_fop_ctx *ctx)
 	if (rc == 0) {
 		/* got a buffer */
 		struct c2_net_bulk_mem_work_item *wi = mem_buffer_to_wi(nb);
+		struct c2_net_domain *dom = tm->ntm_dom;
 		struct c2_net_bulk_sunrpc_tm_pvt *tp =
 			sunrpc_tm_to_pvt(nb->nb_tm);
 		struct sockaddr_in sa = {
@@ -192,13 +187,14 @@ static int sunrpc_msg_handler(struct c2_fop *fop, struct c2_fop_ctx *ctx)
 		uint32_t sid = in->sm_sender.sep_id;
 
 		/* create an end point for the message sender */
-		c2_mutex_lock(&tm->ntm_mutex);
-		rc = sunrpc_ep_create(&wi->xwi_nbe_ep, tm, &sa, sid);
-		c2_mutex_unlock(&tm->ntm_mutex);
+		c2_mutex_lock(&dom->nd_mutex);
+		rc = sunrpc_ep_create(&wi->xwi_nbe_ep, dom, &sa, sid);
+		c2_mutex_unlock(&dom->nd_mutex);
 
 		if (rc == 0) {
 			/* copy the message to the buffer */
-			rc = sunrpc_buffer_copy_out(&cur, &in->sm_buf);
+			memcpy(c2_bufvec_cursor_addr(&cur), in->sm_buf.sb_buf,
+			       in->sm_buf.sb_len);
 			wi->xwi_nbe_length = in->sm_buf.sb_len;
 		}
 		wi->xwi_status = rc;
diff --git a/net/bulk_emulation/sunrpc_xprt_pvt.h b/net/bulk_emulation/sunrpc_xprt_pvt.h
index e96a744..95e3093 100644
--- a/net/bulk_emulation/sunrpc_xprt_pvt.h
+++ b/net/bulk_emulation/sunrpc_xprt_pvt.h
@@ -14,8 +14,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Carl Braganza <Carl_Braganza@us.xyratex.com>,
- *                  Dave Cohrs <Dave_Cohrs@us.xyratex.com>
+ * Original author: Carl Braganza, Dave Cohrs
  * Original creation date: 04/12/2011
  */
 #ifndef __COLIBRI_NET_BULK_SUNRPC_XPRT_PVT_H__
@@ -27,14 +26,20 @@
    @{
 */
 
-#include "lib/time.h"
 #include "net/bulk_emulation/sunrpc_xprt.h"
 
+enum {
+	C2_NET_BULK_SUNRPC_MAX_BUFFER_SIZE     = (1<<20),
+	C2_NET_BULK_SUNRPC_MAX_SEGMENT_SIZE    = (1<<20),
+	C2_NET_BULK_SUNRPC_MAX_BUFFER_SEGMENTS = 256,
+};
+
 /* forward references to other static functions */
 static int sunrpc_ep_init_sid(struct c2_service_id *sid,
 			      struct c2_net_domain *rpc_dom,
 			      struct c2_net_end_point *ep);
 static int sunrpc_desc_create(struct c2_net_buf_desc *desc,
+			      struct c2_net_end_point *ep,
 			      struct c2_net_transfer_mc *tm,
 			      enum c2_net_queue_type qt,
 			      c2_bcount_t buflen,
@@ -46,7 +51,6 @@ static void sunrpc_wi_add(struct c2_net_bulk_mem_work_item *wi,
 			  struct c2_net_bulk_mem_tm_pvt *tp);
 static bool sunrpc_buffer_in_bounds(const struct c2_net_buffer *nb);
 static struct c2_net_transfer_mc *sunrpc_find_tm(uint32_t sid);
-static void sunrpc_xo_buf_del(struct c2_net_buffer *nb);
 
 /**
    @}
diff --git a/net/bulk_emulation/sunrpc_xprt_tm.c b/net/bulk_emulation/sunrpc_xprt_tm.c
index 01a6bf6..4cee137 100644
--- a/net/bulk_emulation/sunrpc_xprt_tm.c
+++ b/net/bulk_emulation/sunrpc_xprt_tm.c
@@ -14,8 +14,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Carl Braganza <Carl_Braganza@us.xyratex.com>,
- *                  Dave Cohrs <Dave_Cohrs@us.xyratex.com>
+ * Original author: Carl Braganza, Dave Cohrs
  * Original creation date: 04/12/2011
  */
 
@@ -67,37 +66,25 @@ static int sunrpc_start_service(struct c2_net_end_point *ep)
 	do {
 		struct c2_net_domain *dom = &sunrpc_server_domain;
 		struct c2_service    *svc = &sunrpc_server_service;
-		struct c2_net_bulk_sunrpc_end_point *sep;
-		sep = sunrpc_ep_to_pvt(ep);
 		if (++sunrpc_server_active_tms > 1) {
 			/* previously started - match address */
-			if (!mem_sa_eq(&sunrpc_server_in,
-				       &sep->xep_base.xep_sa))
+			struct c2_net_bulk_sunrpc_end_point *sep;
+			sep = sunrpc_ep_to_pvt(ep);
+			if (strcmp(sunrpc_server_id.si_uuid,
+				   sep->xep_sid.si_uuid) != 0)
 				rc = -EADDRNOTAVAIL;
 			break;
 		}
 		/* initialize the domain */
 #ifdef __KERNEL__
-		rc = c2_net_domain_init(dom, &c2_net_ksunrpc_minimal_xprt);
+		rc = c2_net_domain_init(dom, &c2_net_ksunrpc_xprt);
 #else
-		/* disable SIGPIPE because sunrpc does not set MSG_NOSIGNAL
-		   when writing on socket, causing process to exit. */
-		{
-			struct sigaction new_action;
-			new_action.sa_handler = SIG_IGN;
-			sigemptyset(&new_action.sa_mask);
-			new_action.sa_flags = 0;
-			sigaction(SIGPIPE, &new_action, NULL);
-		}
 		rc = c2_net_domain_init(dom, &c2_net_usunrpc_minimal_xprt);
 #endif
 		if (rc != 0)
 			break;
 		dom_init = true;
 
-		/* remember the address */
-		sunrpc_server_in = sep->xep_base.xep_sa;
-
 		/* initialize the sid using supplied EP */
 		rc = sunrpc_ep_init_sid(&sunrpc_server_id, dom, ep);
 		if (rc != 0)
@@ -106,7 +93,7 @@ static int sunrpc_start_service(struct c2_net_end_point *ep)
 
 		/* initialize the service */
 		C2_SET0(svc);
-		svc->s_table.not_start = s_fops[0]->ft_rpc_item_type.rit_opcode;
+		svc->s_table.not_start = s_fops[0]->ft_code;
 		svc->s_table.not_nr    = ARRAY_SIZE(s_fops);
 		svc->s_table.not_fopt  = s_fops;
 		svc->s_handler         = &sunrpc_bulk_handler;
@@ -126,7 +113,7 @@ static int sunrpc_start_service(struct c2_net_end_point *ep)
 /**
    Stops the common service if necessary.
  */
-static void sunrpc_stop_service(void)
+static void sunrpc_stop_service()
 {
 	c2_mutex_lock(&sunrpc_server_mutex);
 	do {
@@ -157,6 +144,7 @@ static void sunrpc_wf_state_change(struct c2_net_transfer_mc *tm,
 	C2_PRE(c2_mutex_is_locked(&tm->ntm_mutex));
 	C2_ASSERT(wi->xwi_next_state == C2_NET_XTM_STARTED ||
 		  wi->xwi_next_state == C2_NET_XTM_STOPPED);
+	C2_ASSERT(sunrpc_ep_invariant(tm->ntm_ep));
 
 	if (wi->xwi_next_state == C2_NET_XTM_STARTED) {
 		/*
@@ -165,8 +153,7 @@ static void sunrpc_wf_state_change(struct c2_net_transfer_mc *tm,
 		  If that happens, ignore the C2_NET_XTM_STARTED item.
 		 */
 		if (tp->xtm_base.xtm_state < C2_NET_XTM_STOPPING) {
-			C2_ASSERT(sunrpc_ep_invariant(wi->xwi_nbe_ep));
-			rc = sunrpc_start_service(wi->xwi_nbe_ep);
+			rc = sunrpc_start_service(tm->ntm_ep);
 			if (rc != 0)
 				wi->xwi_status = rc; /* fail TM */
 		}
@@ -213,46 +200,6 @@ static void sunrpc_post_error(struct c2_net_transfer_mc *tm, int32_t status)
 }
 
 /**
-   Skulker method to time out TM buffers
-   @param dom Domain pointer (mutex is held)
-   @param now Current time
- */
-static void sunrpc_skulker_timeout_buffers(struct c2_net_domain *dom,
-					   c2_time_t now)
-{
-	struct c2_net_transfer_mc *tm;
-	enum c2_net_queue_type     qt;
-	struct c2_net_buffer      *nb;
-
-	C2_PRE(c2_mutex_is_locked(&dom->nd_mutex));
-
-	/* iterate over TM's in domain */
-	c2_list_for_each_entry(&dom->nd_tms, tm,
-			       struct c2_net_transfer_mc, ntm_dom_linkage) {
-		c2_mutex_lock(&tm->ntm_mutex);
-		/* iterate over buffers in each queue */
-		for (qt = C2_NET_QT_MSG_RECV; qt < C2_NET_QT_NR; ++qt) {
-			c2_tlist_for(&tm_tl, &tm->ntm_q[qt], nb) {
-				if (nb->nb_timeout == C2_TIME_NEVER)
-					continue;
-				if (c2_time_after(nb->nb_timeout, now))
-					continue;
-				/* mark as timed out */
-				nb->nb_flags |= C2_NET_BUF_TIMED_OUT;
-				/* Attempt to cancel - active calls
-				   may not always notice or honor this flag.
-				   The cancel wf supplies the proper error
-				   code.
-				*/
-				sunrpc_xo_buf_del(nb);
-			} c2_tlist_endfor;
-		}
-		c2_mutex_unlock(&tm->ntm_mutex);
-	}
-	return;
-}
-
-/**
    @} bulksunrpc
 */
 
diff --git a/net/bulk_emulation/sunrpc_xprt_xo.c b/net/bulk_emulation/sunrpc_xprt_xo.c
index 205b539..38084e5 100644
--- a/net/bulk_emulation/sunrpc_xprt_xo.c
+++ b/net/bulk_emulation/sunrpc_xprt_xo.c
@@ -14,8 +14,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Carl Braganza <Carl_Braganza@us.xyratex.com>,
- *                  Dave Cohrs <Dave_Cohrs@us.xyratex.com>
+ * Original author: Carl Braganza, Dave Cohrs
  * Original creation date: 04/12/2011
  */
 
@@ -27,16 +26,7 @@
 #include "lib/rwlock.h"
 #include "net/bulk_emulation/sunrpc_xprt_pvt.h"
 #include "net/net_internal.h"
-#include "fop/fop.h"
 #include "fop/fop_format_def.h"
-#include "rpc/rpc_base.h"
-#include "rpc/rpc_opcodes.h"
-
-#ifdef __KERNEL__
-#include <linux/highmem.h> /* kmap_atomic, kunmap_atomic */
-#include "net/ksunrpc/ksunrpc.h"
-#include <linux/pagemap.h> /* PAGE_CACHE_* macros */
-#endif
 
 /**
    @addtogroup bulksunrpc
@@ -57,25 +47,13 @@ static struct c2_fop_type_ops sunrpc_put_ops = {
 	.fto_execute = sunrpc_put_handler,
 };
 
-C2_FOP_TYPE_DECLARE(sunrpc_msg, "sunrpc_msg", &sunrpc_msg_ops,
-		    C2_BULK_SUNRPC_MSG_OPCODE,
-		    C2_RPC_ITEM_TYPE_REQUEST);
-C2_FOP_TYPE_DECLARE(sunrpc_get, "sunrpc_get", &sunrpc_get_ops,
-		    C2_BULK_SUNRPC_GET_OPCODE,
-		    C2_RPC_ITEM_TYPE_REQUEST);
-C2_FOP_TYPE_DECLARE(sunrpc_put, "sunrpc_put", &sunrpc_put_ops,
-		    C2_BULK_SUNRPC_PUT_OPCODE,
-		    C2_RPC_ITEM_TYPE_REQUEST);
-
-C2_FOP_TYPE_DECLARE(sunrpc_msg_resp, "sunrpc_msg_reply", NULL,
-		    C2_BULK_SUNRPC_MSG_REPLY_OPCODE,
-		    C2_RPC_ITEM_TYPE_REPLY);
-C2_FOP_TYPE_DECLARE(sunrpc_get_resp, "sunrpc_get_reply", NULL,
-		    C2_BULK_SUNRPC_GET_REPLY_OPCODE,
-		    C2_RPC_ITEM_TYPE_REPLY);
-C2_FOP_TYPE_DECLARE(sunrpc_put_resp, "sunrpc_put_reply", NULL,
-		    C2_BULK_SUNRPC_PUT_REPLY_OPCODE,
-		    C2_RPC_ITEM_TYPE_REPLY);
+C2_FOP_TYPE_DECLARE(sunrpc_msg,      "sunrpc_msg", 30, &sunrpc_msg_ops);
+C2_FOP_TYPE_DECLARE(sunrpc_get,      "sunrpc_get", 31, &sunrpc_get_ops);
+C2_FOP_TYPE_DECLARE(sunrpc_put,      "sunrpc_put", 32, &sunrpc_put_ops);
+
+C2_FOP_TYPE_DECLARE(sunrpc_msg_resp, "sunrpc_msg reply", 35, NULL);
+C2_FOP_TYPE_DECLARE(sunrpc_get_resp, "sunrpc_get reply", 36, NULL);
+C2_FOP_TYPE_DECLARE(sunrpc_put_resp, "sunrpc_put reply", 37, NULL);
 
 static struct c2_fop_type *fops[] = {
 	&sunrpc_msg_fopt,
@@ -97,7 +75,6 @@ static struct c2_rwlock      sunrpc_server_lock;
 static struct c2_mutex       sunrpc_server_mutex;
 static struct c2_list        sunrpc_server_tms;
 static struct c2_net_domain  sunrpc_server_domain;
-static struct sockaddr_in    sunrpc_server_in;
 static struct c2_service_id  sunrpc_server_id;
 static struct c2_service     sunrpc_server_service;
 static uint32_t              sunrpc_server_active_tms = 0;
@@ -113,6 +90,15 @@ static bool sunrpc_dom_invariant(const struct c2_net_domain *dom)
 		mem_dom_to_pvt(dom) == &dp->xd_base);
 }
 
+static bool sunrpc_ep_invariant(const struct c2_net_end_point *ep)
+{
+	const struct c2_net_bulk_sunrpc_end_point *sep = sunrpc_ep_to_pvt(ep);
+	return (sunrpc_dom_invariant(ep->nep_dom) &&
+		sep->xep_magic == C2_NET_BULK_SUNRPC_XEP_MAGIC &&
+		mem_ep_to_pvt(ep) == &sep->xep_base &&
+		sep->xep_sid_valid);
+}
+
 static bool sunrpc_tm_invariant(const struct c2_net_transfer_mc *tm)
 {
 	const struct c2_net_bulk_sunrpc_tm_pvt *tp = sunrpc_tm_to_pvt(tm);
@@ -121,14 +107,6 @@ static bool sunrpc_tm_invariant(const struct c2_net_transfer_mc *tm)
 		sunrpc_dom_invariant(tm->ntm_dom));
 }
 
-static bool sunrpc_ep_invariant(const struct c2_net_end_point *ep)
-{
-	const struct c2_net_bulk_sunrpc_end_point *sep = sunrpc_ep_to_pvt(ep);
-	return (sunrpc_tm_invariant(ep->nep_tm) &&
-		sep->xep_magic == C2_NET_BULK_SUNRPC_XEP_MAGIC &&
-		mem_ep_to_pvt(ep) == &sep->xep_base);
-}
-
 static bool sunrpc_buffer_invariant(const struct c2_net_buffer *nb)
 {
 	const struct c2_net_bulk_sunrpc_buffer_pvt *sbp =
@@ -146,10 +124,10 @@ static bool sunrpc_buffer_invariant(const struct c2_net_buffer *nb)
    Static functions should be declared in the private header file
    so that the order of their definition does not matter.
 */
-#include "net/bulk_emulation/sunrpc_xprt_ep.c"
-#include "net/bulk_emulation/sunrpc_xprt_tm.c"
-#include "net/bulk_emulation/sunrpc_xprt_bulk.c"
-#include "net/bulk_emulation/sunrpc_xprt_msg.c"
+#include "sunrpc_xprt_ep.c"
+#include "sunrpc_xprt_tm.c"
+#include "sunrpc_xprt_bulk.c"
+#include "sunrpc_xprt_msg.c"
 
 /**
    Transport finalization subroutine called from c2_fini().
@@ -163,6 +141,7 @@ void c2_sunrpc_fop_fini(void)
 	c2_fop_type_fini_nr(fops, ARRAY_SIZE(fops));
 	c2_fop_type_format_fini_nr(fmts, ARRAY_SIZE(fmts));
 }
+C2_EXPORTED(c2_sunrpc_fop_fini);
 
 /**
    Transport initialization subroutine called from c2_init().
@@ -183,6 +162,7 @@ int c2_sunrpc_fop_init(void)
 		c2_sunrpc_fop_fini();
 	return result;
 }
+C2_EXPORTED(c2_sunrpc_fop_init);
 
 /**
    Search the list of existing transfer machines for the one whose end point
@@ -251,95 +231,17 @@ static void sunrpc_wi_post_buffer_event(struct c2_net_bulk_mem_work_item *wi)
 	(*dp->xd_base_ops->bmo_wi_post_buffer_event)(wi);
 }
 
-/**
-   Domain skulker thread body.
- */
-static void sunrpc_skulker(struct c2_net_domain *dom)
-{
-	struct c2_net_bulk_sunrpc_domain_pvt *dp = sunrpc_dom_to_pvt(dom);
-	c2_time_t now;
-	c2_time_t wakeup;
-	c2_time_t next_conn = 0;
-	c2_time_t next_buf = 0;
-
-	c2_mutex_lock(&dom->nd_mutex);
-	now = c2_time_now();
-	while (dp->xd_skulker_run) {
-		dp->xd_skulker_hb++;
-
-		/* schedule future events */
-		if (dp->xd_ep_release_delay == 0)
-			next_conn = C2_TIME_NEVER;
-		else if (next_conn == 0)
-			next_conn = c2_time_add(now, dp->xd_ep_release_delay);
-		if (next_buf == 0)
-			next_buf = c2_time_add(now, dp->xd_skulker_period);
-
-		/* sleep a fixed interval */
-		wakeup = c2_time_add(now, dp->xd_skulker_period);
-		c2_cond_timedwait(&dp->xd_skulker_cv, &dom->nd_mutex, wakeup);
-		if (!dp->xd_skulker_run)
-			break;
-		now = c2_time_now();
-		if (dp->xd_skulker_force) {
-			/* force invocation of handlers */
-			next_conn = now;
-			next_buf = now;
-			dp->xd_skulker_force = false;
-		}
-
-		/* age cached connections */
-		if (c2_time_after_eq(now, next_conn)) {
-			sunrpc_skulker_process_conn_cache(dom, now);
-			next_conn = 0;
-		}
-
-		/* timeout buffers */
-		if (c2_time_after_eq(now, next_buf)) {
-			sunrpc_skulker_timeout_buffers(dom, now);
-			next_buf = 0;
-		}
-	}
-	sunrpc_skulker_process_conn_cache(dom, C2_TIME_NEVER);
-	dp->xd_skulker_hb = 0;
-	c2_mutex_unlock(&dom->nd_mutex);
-	return;
-}
-
-static void sunrpc_skulker_stop(struct c2_net_domain *dom)
-{
-	struct c2_net_bulk_sunrpc_domain_pvt *dp = sunrpc_dom_to_pvt(dom);
-
-	C2_PRE(c2_mutex_is_not_locked(&dom->nd_mutex));
-	c2_mutex_lock(&dom->nd_mutex);
-	if (!dp->xd_skulker_run) {
-		c2_mutex_unlock(&dom->nd_mutex);
-		return;
-	}
-
-	dp->xd_skulker_run = false;
-	c2_cond_signal(&dp->xd_skulker_cv, &dom->nd_mutex);
-	c2_mutex_unlock(&dom->nd_mutex);
-	c2_thread_join(&dp->xd_skulker_thread);
-	return;
-}
-
 static int sunrpc_xo_dom_init(struct c2_net_xprt *xprt,
 			      struct c2_net_domain *dom)
 {
 	struct c2_net_bulk_sunrpc_domain_pvt *dp;
 	struct c2_net_bulk_mem_domain_pvt *bdp;
 	int rc;
-	bool base_dom_init = false;
-	bool rpc_dom_init = false;
 
 	C2_PRE(dom->nd_xprt_private == NULL);
 	C2_ALLOC_PTR(dp);
 	if (dp == NULL)
 		return -ENOMEM;
-	c2_cond_init(&dp->xd_skulker_cv);
-	c2_list_init(&dp->xd_conn_cache);
-	c2_cond_init(&dp->xd_conn_cache_cv);
 	bdp = &dp->xd_base;
 	dom->nd_xprt_private = bdp; /* base pointer required */
 	rc = c2_net_bulk_mem_xprt.nx_ops->xo_dom_init(xprt, dom);
@@ -347,7 +249,6 @@ static int sunrpc_xo_dom_init(struct c2_net_xprt *xprt,
 		goto err_exit;
 	C2_ASSERT(mem_dom_to_pvt(dom) == bdp);
 	C2_ASSERT(sunrpc_dom_to_pvt(dom) == dp);
-	base_dom_init = true;
 
 	/* save the base internal subs */
 	dp->xd_base_ops = bdp->xd_ops;
@@ -355,47 +256,26 @@ static int sunrpc_xo_dom_init(struct c2_net_xprt *xprt,
 	/* Replace the base ops pointer to override some of the methods. */
 	bdp->xd_ops = &sunrpc_xprt_methods;
 
-	/* set/override tunable parameters */
+	/* override tunable parameters */
 	bdp->xd_addr_tuples       = 3;
 	bdp->xd_num_tm_threads    = C2_NET_BULK_SUNRPC_TM_THREADS;
-	c2_time_set(&dp->xd_ep_release_delay, C2_NET_BULK_SUNRPC_EP_DELAY_S, 0);
-	c2_time_set(&dp->xd_skulker_period,
-		    C2_NET_BULK_SUNRPC_SKULKER_PERIOD_S, 0);
 
 	/* create the rpc domain (use in-mutex version of domain init) */
 #ifdef __KERNEL__
-	rc = c2_net__domain_init(&dp->xd_rpc_dom, &c2_net_ksunrpc_minimal_xprt);
+	rc = c2_net__domain_init(&dp->xd_rpc_dom, &c2_net_ksunrpc_xprt);
 #else
 	rc = c2_net__domain_init(&dp->xd_rpc_dom, &c2_net_usunrpc_minimal_xprt);
 #endif
-	if (rc != 0)
-		goto err_exit;
-	rpc_dom_init = true;
-
-	dp->xd_magic = C2_NET_BULK_SUNRPC_XDP_MAGIC;
-	C2_POST(sunrpc_dom_invariant(dom));
-
-	dp->xd_skulker_run = true;
-	rc = C2_THREAD_INIT(&dp->xd_skulker_thread,
-			    struct c2_net_domain *, NULL,
-			    &sunrpc_skulker, dom, "sunrpc_skulker");
-	if (rc != 0) {
-		dp->xd_skulker_run = false;
-		goto err_exit;
+	if (rc == 0) {
+		dp->xd_magic = C2_NET_BULK_SUNRPC_XDP_MAGIC;
+		C2_POST(sunrpc_dom_invariant(dom));
+	} else {
+		/* got to fini the base */
+		c2_net_bulk_mem_xprt.nx_ops->xo_dom_fini(dom);
+		C2_POST(mem_dom_to_pvt(dom) == bdp);
 	}
-
  err_exit:
 	if (rc != 0 && dp != NULL) {
-		if (rpc_dom_init) {
-			c2_net__domain_fini(&dp->xd_rpc_dom);
-		}
-		if (base_dom_init) {
-			c2_net_bulk_mem_xprt.nx_ops->xo_dom_fini(dom);
-			C2_POST(mem_dom_to_pvt(dom) == bdp);
-		}
-		c2_list_fini(&dp->xd_conn_cache);
-		c2_cond_fini(&dp->xd_conn_cache_cv);
-		c2_cond_fini(&dp->xd_skulker_cv);
 		c2_free(dp);
 		dom->nd_xprt_private = NULL;
 	}
@@ -407,8 +287,6 @@ static void sunrpc_xo_dom_fini(struct c2_net_domain *dom)
 	struct c2_net_bulk_sunrpc_domain_pvt *dp = sunrpc_dom_to_pvt(dom);
 	C2_PRE(sunrpc_dom_invariant(dom));
 
-	sunrpc_skulker_stop(dom);
-
 	/* fini the RPC domain (use in-mutex version of domain fini) */
 	c2_net__domain_fini(&dp->xd_rpc_dom);
 
@@ -418,61 +296,10 @@ static void sunrpc_xo_dom_fini(struct c2_net_domain *dom)
 	/* free the pvt structure */
 	C2_ASSERT(mem_dom_to_pvt(dom) == &dp->xd_base);
 	dp->xd_magic = 0;
-	c2_list_fini(&dp->xd_conn_cache);
-	c2_cond_fini(&dp->xd_conn_cache_cv);
-	c2_cond_fini(&dp->xd_skulker_cv);
 	c2_free(dp);
 	dom->nd_xprt_private = NULL;
 }
 
-void
-c2_net_bulk_sunrpc_dom_set_skulker_period(struct c2_net_domain *dom,
-					  uint64_t secs)
-{
-	struct c2_net_bulk_sunrpc_domain_pvt *dp = sunrpc_dom_to_pvt(dom);
-	C2_PRE(sunrpc_dom_invariant(dom));
-	C2_PRE(secs > 0);
-	c2_mutex_lock(&dom->nd_mutex);
-	c2_time_set(&dp->xd_skulker_period, secs, 0);
-	c2_cond_signal(&dp->xd_skulker_cv, &dom->nd_mutex);
-	c2_mutex_unlock(&dom->nd_mutex);
-	return;
-}
-C2_EXPORTED(c2_net_bulk_sunrpc_dom_set_skulker_period);
-
-uint64_t
-c2_net_bulk_sunrpc_dom_get_skulker_period(struct c2_net_domain *dom)
-{
-	struct c2_net_bulk_sunrpc_domain_pvt *dp = sunrpc_dom_to_pvt(dom);
-	C2_PRE(sunrpc_dom_invariant(dom));
-	return c2_time_seconds(dp->xd_skulker_period);
-}
-
-void
-c2_net_bulk_sunrpc_dom_set_end_point_release_delay(struct c2_net_domain *dom,
-						   uint64_t secs)
-{
-	struct c2_net_bulk_sunrpc_domain_pvt *dp = sunrpc_dom_to_pvt(dom);
-	C2_PRE(sunrpc_dom_invariant(dom));
-	c2_mutex_lock(&dom->nd_mutex);
-	c2_time_set(&dp->xd_ep_release_delay, secs, 0);
-	if (secs == 0) /* flush cached eps now */
-		sunrpc_skulker_process_conn_cache(dom, C2_TIME_NEVER);
-	dp->xd_skulker_force = true;
-	c2_cond_signal(&dp->xd_skulker_cv, &dom->nd_mutex);
-	c2_mutex_unlock(&dom->nd_mutex);
-	return;
-}
-C2_EXPORTED(c2_net_bulk_sunrpc_dom_set_end_point_release_delay);
-
-uint64_t
-c2_net_bulk_sunrpc_dom_get_end_point_release_delay(struct c2_net_domain *dom)
-{
-	struct c2_net_bulk_sunrpc_domain_pvt *dp = sunrpc_dom_to_pvt(dom);
-	C2_PRE(sunrpc_dom_invariant(dom));
-	return c2_time_seconds(dp->xd_ep_release_delay);
-}
-
 static c2_bcount_t sunrpc_xo_get_max_buffer_size(
 					      const struct c2_net_domain *dom)
 {
@@ -492,11 +319,11 @@ static int32_t sunrpc_xo_get_max_buffer_segments(
 }
 
 static int sunrpc_xo_end_point_create(struct c2_net_end_point **epp,
-				      struct c2_net_transfer_mc *tm,
+				      struct c2_net_domain *dom,
 				      const char *addr)
 {
 	/* calls sunrpc_ep_create */
-	return c2_net_bulk_mem_xprt.nx_ops->xo_end_point_create(epp, tm, addr);
+	return c2_net_bulk_mem_xprt.nx_ops->xo_end_point_create(epp, dom, addr);
 }
 
 /**
@@ -544,17 +371,20 @@ static int sunrpc_xo_buf_register(struct c2_net_buffer *nb)
 	return rc;
 }
 
-static void sunrpc_xo_buf_deregister(struct c2_net_buffer *nb)
+static int sunrpc_xo_buf_deregister(struct c2_net_buffer *nb)
 {
+	int rc;
 	struct c2_net_bulk_sunrpc_buffer_pvt *sbp = sunrpc_buffer_to_pvt(nb);
 	C2_PRE(sunrpc_buffer_invariant(nb));
-	c2_net_bulk_mem_xprt.nx_ops->xo_buf_deregister(nb);
-	/* free the private data */
-	C2_ASSERT(mem_buffer_to_pvt(nb) == &sbp->xsb_base);
-	sbp->xsb_magic = 0;
-	c2_free(sbp);
-	nb->nb_xprt_private = NULL;
-	return;
+	rc = c2_net_bulk_mem_xprt.nx_ops->xo_buf_deregister(nb);
+	if (rc == 0) {
+		/* free the private data */
+		C2_ASSERT(mem_buffer_to_pvt(nb) == &sbp->xsb_base);
+		sbp->xsb_magic = 0;
+		c2_free(sbp);
+		nb->nb_xprt_private = NULL;
+	}
+	return rc;
 }
 
 static int sunrpc_xo_buf_add(struct c2_net_buffer *nb)
@@ -573,170 +403,6 @@ static void sunrpc_xo_buf_del(struct c2_net_buffer *nb)
 	return;
 }
 
-#ifdef __KERNEL__
-void sunrpc_buffer_fini(struct sunrpc_buffer *sb)
-{
-	int i;
-
-	if (sb != NULL) {
-		if (sb->sb_buf != NULL) {
-			for (i = 0; sb->sb_buf[i] != NULL; ++i)
-				put_page(sb->sb_buf[i]);
-			c2_free(sb->sb_buf);
-		}
-		C2_SET0(sb);
-	}
-}
-
-int sunrpc_buffer_init(struct sunrpc_buffer *sb,
-		       struct c2_bufvec_cursor *cur, c2_bcount_t len)
-{
-        struct page  **pages;
-        size_t         npages;
-	int            i;
-	void          *bp;
-	c2_bcount_t    pageused;
-	c2_bcount_t    copied;
-	struct c2_bufvec out = C2_BUFVEC_INIT_BUF(&bp, &pageused);
-	struct c2_bufvec_cursor outcur;
-
-	C2_PRE(sb != NULL);
-
-        npages = (len + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT;
-	if (npages == 0)
-		npages = 1;
-	C2_ALLOC_ARR(pages, npages + 1); /* null ptr terminate, see fini */
-        if (pages == NULL)
-                return -ENOMEM;
-
-	sb->sb_len = len;
-	sb->sb_pgoff = 0;
-	sb->sb_buf = pages;
-
-	for (i = 0; i < npages; ++i) {
-		/* cannot use c2_alloc here, must allocate 1 real page.
-		   kernel networking code requires each page to be allocated
-		   separately (it calls get_page/put_page on individual pages).
-		 */
-		pages[i] = alloc_page(GFP_KERNEL);
-		if (pages[i] == NULL) {
-			sunrpc_buffer_fini(sb);
-			return -ENOMEM;
-		}
-		if (cur != NULL && len > 0) {
-			bp = kmap_atomic(pages[i], KM_USER0);
-			pageused = min32u(PAGE_CACHE_SIZE, len);
-			c2_bufvec_cursor_init(&outcur, &out);
-			copied = c2_bufvec_cursor_copy(&outcur, cur, pageused);
-			kunmap_atomic(pages[i], KM_USER0);
-			C2_ASSERT(len > PAGE_CACHE_SIZE || i == npages - 1);
-			C2_ASSERT(copied == pageused);
-			len -= pageused;
-		}
-	}
-	return 0;
-}
-
-int sunrpc_buffer_copy_out(struct c2_bufvec_cursor *outcur,
-			   const struct sunrpc_buffer *sb)
-{
-	/* cannot assume pages are sequential, eg see how svc_init_buffer()
-	   allocates its page pool
-	 */
-	c2_bcount_t copylen;
-	size_t npages;
-	c2_bcount_t pageused;
-	char *addr;
-	struct c2_bufvec in = C2_BUFVEC_INIT_BUF((void**) &addr, &pageused);
-	struct c2_bufvec_cursor incur;
-	c2_bcount_t copied;
-	int i;
-	int rc = 0;
-
-	C2_PRE(sb != NULL && sb->sb_buf != NULL &&
-	       sb->sb_pgoff < PAGE_CACHE_SIZE);
-	copylen = sb->sb_len;
-	if (copylen == 0)
-		return rc;
-	npages =
-	    (sb->sb_pgoff + copylen + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT;
-	C2_ASSERT(npages > 0);
-
-	for (i = 0; i < npages; ++i) {
-		if (i == npages - 1) {
-			pageused = (sb->sb_pgoff + copylen) & ~PAGE_CACHE_MASK;
-			if (pageused == 0) /* last page is exactly 1 page */
-				pageused = PAGE_CACHE_SIZE;
-		} else {
-			pageused = PAGE_CACHE_SIZE;
-		}
-		addr = kmap_atomic(sb->sb_buf[i], KM_USER0);
-		if (i == 0) {
-			addr += sb->sb_pgoff;
-			pageused -= sb->sb_pgoff;
-		}
-		c2_bufvec_cursor_init(&incur, &in);
-		copied = c2_bufvec_cursor_copy(outcur, &incur, pageused);
-		kunmap_atomic(sb->sb_buf[i], KM_USER0);
-		if (copied != pageused) {
-			rc = -EFBIG;
-			break;
-		}
-	}
-	return rc;
-}
-#else
-void sunrpc_buffer_fini(struct sunrpc_buffer *sb)
-{
-	if (sb != NULL) {
-		c2_free(sb->sb_buf);
-		C2_SET0(sb);
-	}
-}
-
-int sunrpc_buffer_init(struct sunrpc_buffer *sb,
-		       struct c2_bufvec_cursor *cur, c2_bcount_t len)
-{
-	C2_PRE(sb != NULL);
-
-	sb->sb_len = len;
-	sb->sb_buf = c2_alloc(len == 0 ? 1 : len);
-	if (sb->sb_buf == NULL)
-		return -ENOMEM;
-	if (cur != NULL && len > 0) {
-		struct c2_bufvec out =
-		    C2_BUFVEC_INIT_BUF((void **) &sb->sb_buf, &len);
-		struct c2_bufvec_cursor outcur;
-		c2_bcount_t copied;
-
-		c2_bufvec_cursor_init(&outcur, &out);
-		copied = c2_bufvec_cursor_copy(&outcur, cur, len);
-		C2_ASSERT(copied == len);
-	}
-	return 0;
-}
-
-int sunrpc_buffer_copy_out(struct c2_bufvec_cursor *outcur,
-			   const struct sunrpc_buffer *sb)
-{
-	c2_bcount_t copylen;
-	c2_bcount_t copied;
-	void *addr;
-	struct c2_bufvec in = C2_BUFVEC_INIT_BUF(&addr, &copylen);
-	struct c2_bufvec_cursor incur;
-
-	C2_PRE(sb != NULL && sb->sb_buf != NULL);
-	copylen = sb->sb_len;
-	addr = sb->sb_buf;
-
-	c2_bufvec_cursor_init(&incur, &in);
-	copied = c2_bufvec_cursor_copy(outcur, &incur, copylen);
-	if (copied != copylen)
-		return -EFBIG;
-	return 0;
-}
-#endif /* __KERNEL__ */
-
 static int sunrpc_xo_tm_init(struct c2_net_transfer_mc *tm)
 {
 	struct c2_net_bulk_sunrpc_tm_pvt *tp;
@@ -793,10 +459,11 @@ size_t c2_net_bulk_sunrpc_tm_get_num_threads(const struct c2_net_transfer_mc
 	return c2_net_bulk_mem_tm_get_num_threads(tm);
 }
 
-static int sunrpc_xo_tm_start(struct c2_net_transfer_mc *tm, const char *addr)
+static int sunrpc_xo_tm_start(struct c2_net_transfer_mc *tm)
 {
 	int rc = 0;
-	struct c2_net_end_point *ep;
+	struct c2_net_end_point *ep = tm->ntm_ep;
+	const char *tm_addr = ep->nep_addr;
 	struct c2_net_bulk_sunrpc_tm_pvt *tp;
 
 	C2_PRE(sunrpc_tm_invariant(tm));
@@ -811,7 +478,7 @@ static int sunrpc_xo_tm_start(struct c2_net_transfer_mc *tm, const char *addr)
 		ep = ltm->ntm_ep;
 		if (ep == NULL)
 			continue; /* not yet started */
-		if (strcmp(addr, ep->nep_addr) == 0) {
+		if (strcmp(tm_addr, ep->nep_addr) == 0) {
 			rc = -EADDRINUSE;
 			break;
 		}
@@ -820,7 +487,7 @@ static int sunrpc_xo_tm_start(struct c2_net_transfer_mc *tm, const char *addr)
 	c2_mutex_unlock(&sunrpc_tm_start_mutex);
 	if (rc != 0)
 		return rc;
-	return c2_net_bulk_mem_xprt.nx_ops->xo_tm_start(tm, addr);
+	return c2_net_bulk_mem_xprt.nx_ops->xo_tm_start(tm);
 }
 
 static int sunrpc_xo_tm_stop(struct c2_net_transfer_mc *tm, bool cancel)
@@ -829,38 +496,6 @@ static int sunrpc_xo_tm_stop(struct c2_net_transfer_mc *tm, bool cancel)
 	return c2_net_bulk_mem_xprt.nx_ops->xo_tm_stop(tm, cancel);
 }
 
-static int sunrpc_xo_tm_confine(struct c2_net_transfer_mc *tm,
-				const struct c2_bitmap *processors)
-{
-	C2_PRE(sunrpc_tm_invariant(tm));
-	return 0; /* fake the support */
-}
-
-static int sunrpc_xo_bev_deliver_sync(struct c2_net_transfer_mc *tm)
-{
-	C2_PRE(sunrpc_tm_invariant(tm));
-	return 0; /* fake the support */
-}
-
-static void sunrpc_xo_bev_deliver_all(struct c2_net_transfer_mc *tm)
-{
-	C2_PRE(sunrpc_tm_invariant(tm));
-	return; /* NO-OP - all delivery is automatic */
-}
-
-static bool sunrpc_xo_bev_pending(struct c2_net_transfer_mc *tm)
-{
-	C2_PRE(sunrpc_tm_invariant(tm));
-	return false; /* NO-OP - never any pending bevs */
-}
-
-static void sunrpc_xo_bev_notify(struct c2_net_transfer_mc *tm,
-				 struct c2_chan *chan)
-{
-	C2_PRE(sunrpc_tm_invariant(tm));
-	return; /* NO-OP - no signal on channel ever */
-}
-
 /* Internal methods of this transport. */
 static const struct c2_net_bulk_mem_ops sunrpc_xprt_methods = {
 	.bmo_work_fn = {
@@ -876,7 +511,6 @@ static const struct c2_net_bulk_mem_ops sunrpc_xprt_methods = {
 	.bmo_ep_alloc                        = sunrpc_ep_alloc,
 	.bmo_ep_free                         = sunrpc_ep_free,
 	.bmo_ep_release                      = sunrpc_xo_end_point_release,
-	.bmo_ep_get                          = sunrpc_ep_get,
 	.bmo_wi_add                          = sunrpc_wi_add,
 	.bmo_buffer_in_bounds                = sunrpc_buffer_in_bounds,
 	.bmo_desc_create                     = sunrpc_desc_create,
@@ -900,18 +534,12 @@ static const struct c2_net_xprt_ops sunrpc_xo_xprt_ops = {
 	.xo_tm_fini                     = sunrpc_xo_tm_fini,
 	.xo_tm_start                    = sunrpc_xo_tm_start,
 	.xo_tm_stop                     = sunrpc_xo_tm_stop,
-	.xo_tm_confine                  = sunrpc_xo_tm_confine,
-	.xo_bev_deliver_sync            = sunrpc_xo_bev_deliver_sync,
-        .xo_bev_deliver_all             = sunrpc_xo_bev_deliver_all,
-	.xo_bev_pending                 = sunrpc_xo_bev_pending,
-	.xo_bev_notify                  = sunrpc_xo_bev_notify,
 };
 
 struct c2_net_xprt c2_net_bulk_sunrpc_xprt = {
 	.nx_name = "bulk-sunrpc",
 	.nx_ops  = &sunrpc_xo_xprt_ops
 };
-C2_EXPORTED(c2_net_bulk_sunrpc_xprt);
 
 /**
    @} bulksunrpc
diff --git a/net/bulk_emulation/ut/Makefile.am b/net/bulk_emulation/ut/Makefile.am
index 832de8f..2bed2f1 100644
--- a/net/bulk_emulation/ut/Makefile.am
+++ b/net/bulk_emulation/ut/Makefile.am
@@ -3,4 +3,4 @@ noinst_LTLIBRARIES           = libnet-bulkem-ut.la
 INCLUDES                     = -I. -I$(top_srcdir) -I$(top_srcdir)/include -I../
 
 libnet_bulkem_ut_la_SOURCES  = bulk_mem_ut.c bulk_sunrpc_ut.c
-EXTRA_DIST                   = ksunrpc_ut.c
+
diff --git a/net/bulk_emulation/ut/bulk_mem_ut.c b/net/bulk_emulation/ut/bulk_mem_ut.c
index 571df75..3550d7f 100644
--- a/net/bulk_emulation/ut/bulk_mem_ut.c
+++ b/net/bulk_emulation/ut/bulk_mem_ut.c
@@ -14,8 +14,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Carl Braganza <Carl_Braganza@us.xyratex.com>,
- *                  Dave Cohrs <Dave_Cohrs@us.xyratex.com>
+ * Original author: Carl Braganza, Dave Cohrs
  * Original creation date: 04/12/2011
  */
 
@@ -29,13 +28,12 @@
 #include "net/bulk_emulation/mem_xprt_xo.c"
 #include "net/bulk_emulation/st/ping.c"
 
-/* Create buffers with different shapes but same total size.
-   Also create identical buffers for exact shape testing.
-*/
-enum { NR_BUFS = 10 };
-
 static void test_buf_copy(void)
 {
+	/* Create buffers with different shapes but same total size.
+	   Also create identical buffers for exact shape testing.
+	 */
+	enum { NR_BUFS = 10 };
 	static struct {
 		uint32_t    num_segs;
 		c2_bcount_t seg_size;
@@ -54,7 +52,7 @@ static void test_buf_copy(void)
 	static const char *msg = "abcdefghijklmnopqrstuvwxyz0123456789"
 		"ABCDEFGHIJK";
 	size_t msglen = strlen(msg)+1;
-	static struct c2_net_buffer bufs[NR_BUFS];
+	struct c2_net_buffer bufs[NR_BUFS];
 	int i;
 	struct c2_net_buffer *nb;
 
@@ -85,57 +83,37 @@ static void test_buf_copy(void)
 		}
 
 	}
-	for (i = 0; i < NR_BUFS; ++i)
-		c2_bufvec_free(&bufs[i].nb_buffer);
 }
 
-void tf_tm_cb1(const struct c2_net_tm_event *ev);
 static void test_ep(void)
 {
 	/* dom1 */
-	static struct c2_net_domain dom1 = {
+	struct c2_net_domain dom1 = {
 		.nd_xprt = NULL
 	};
-	static struct c2_net_tm_callbacks tm_cbs1 = {
-		.ntc_event_cb = tf_tm_cb1
-	};
-	static struct c2_net_transfer_mc d1tm1 = {
-		.ntm_callbacks = &tm_cbs1,
-		.ntm_state = C2_NET_TM_UNDEFINED
-	};
-	struct c2_clink tmwait;
-	static struct c2_net_end_point *ep1;
-	static struct c2_net_end_point *ep2;
-	static struct c2_net_end_point *ep3;
+	struct c2_net_end_point *ep1;
+	struct c2_net_end_point *ep2;
+	struct c2_net_end_point *ep3;
 	const char *addr;
 
 	C2_UT_ASSERT(!c2_net_domain_init(&dom1, &c2_net_bulk_mem_xprt));
-	C2_UT_ASSERT(!c2_net_tm_init(&d1tm1, &dom1));
-
-	c2_clink_init(&tmwait, NULL);
-	c2_clink_add(&d1tm1.ntm_chan, &tmwait);
-	C2_UT_ASSERT(!c2_net_tm_start(&d1tm1, "255.255.255.255:54321"));
-	c2_chan_wait(&tmwait);
-	c2_clink_del(&tmwait);
-	C2_UT_ASSERT(d1tm1.ntm_ep != NULL);
-
 	addr = "255.255.255.255:65535:4294967295";
-	C2_UT_ASSERT(c2_net_end_point_create(&ep1, &d1tm1, addr) == -EINVAL);
+	C2_UT_ASSERT(c2_net_end_point_create(&ep1, &dom1, addr) == -EINVAL);
 	addr = "255.255.255.255:65535";
-	C2_UT_ASSERT(!c2_net_end_point_create(&ep1, &d1tm1, addr));
+	C2_UT_ASSERT(!c2_net_end_point_create(&ep1, &dom1, addr));
 	C2_UT_ASSERT(strcmp(ep1->nep_addr, addr) == 0);
 	C2_UT_ASSERT(c2_atomic64_get(&ep1->nep_ref.ref_cnt) == 1);
 	C2_UT_ASSERT(ep1->nep_addr != addr);
 
-	C2_UT_ASSERT(!c2_net_end_point_create(&ep2, &d1tm1, addr));
+	C2_UT_ASSERT(!c2_net_end_point_create(&ep2, &dom1, addr));
 	C2_UT_ASSERT(strcmp(ep2->nep_addr, addr) == 0);
 	C2_UT_ASSERT(ep2->nep_addr != addr);
 	C2_UT_ASSERT(c2_atomic64_get(&ep2->nep_ref.ref_cnt) == 2);
 	C2_UT_ASSERT(ep1 == ep2);
 
-	C2_UT_ASSERT(!c2_net_end_point_create(&ep3, &d1tm1, addr));
+	C2_UT_ASSERT(!c2_net_end_point_create(&ep3, &dom1, addr));
 
-	C2_UT_ASSERT(strcmp(ep3->nep_addr, "255.255.255.255:65535") == 0);
+	C2_UT_ASSERT(strcmp(ep3->nep_addr,"255.255.255.255:65535")==0);
 	C2_UT_ASSERT(strcmp(ep3->nep_addr, addr) == 0);
 	C2_UT_ASSERT(ep3->nep_addr != addr);
 	C2_UT_ASSERT(c2_atomic64_get(&ep3->nep_ref.ref_cnt) == 3);
@@ -145,12 +123,6 @@ static void test_ep(void)
 	C2_UT_ASSERT(!c2_net_end_point_put(ep2));
 	C2_UT_ASSERT(!c2_net_end_point_put(ep3));
 
-	c2_clink_add(&d1tm1.ntm_chan, &tmwait);
-	C2_UT_ASSERT(!c2_net_tm_stop(&d1tm1, false));
-	c2_chan_wait(&tmwait);
-	c2_clink_del(&tmwait);
-
-	c2_net_tm_fini(&d1tm1);
 	c2_net_domain_fini(&dom1);
 }
 
@@ -177,7 +149,7 @@ void tf_buf_cb1(const struct c2_net_buffer_event *ev)
 	cb_status1 = ev->nbe_status;
 }
 
-void tf_cbreset1(void)
+void tf_cbreset1()
 {
 	cb_evt1    = C2_NET_TEV_NR;
 	cb_nb1     = NULL;
@@ -209,7 +181,7 @@ void tf_buf_cb2(const struct c2_net_buffer_event *ev)
 	cb_status2 = ev->nbe_status;
 }
 
-void tf_cbreset2(void)
+void tf_cbreset2()
 {
 	cb_evt2    = C2_NET_TEV_NR;
 	cb_nb2     = NULL;
@@ -218,7 +190,7 @@ void tf_cbreset2(void)
 	cb_status2 = 9999999;
 }
 
-void tf_cbreset(void)
+void tf_cbreset()
 {
 	tf_cbreset1();
 	tf_cbreset2();
@@ -226,21 +198,18 @@ void tf_cbreset(void)
 
 static void test_failure(void)
 {
-	/* some variables below are static to reduce kernel stack
-	   consumption. */
-
 	/* dom1 */
-	static struct c2_net_domain dom1 = {
+	struct c2_net_domain dom1 = {
 		.nd_xprt = NULL
 	};
-	static struct c2_net_tm_callbacks tm_cbs1 = {
+	struct c2_net_tm_callbacks tm_cbs1 = {
 		.ntc_event_cb = tf_tm_cb1
 	};
-	static struct c2_net_transfer_mc d1tm1 = {
+	struct c2_net_transfer_mc d1tm1 = {
 		.ntm_callbacks = &tm_cbs1,
 		.ntm_state = C2_NET_TM_UNDEFINED
 	};
-	static struct c2_net_buffer_callbacks buf_cbs1 = {
+	struct c2_net_buffer_callbacks buf_cbs1 = {
 		.nbc_cb = {
 			[C2_NET_QT_MSG_RECV]          = tf_buf_cb1,
 			[C2_NET_QT_MSG_SEND]          = tf_buf_cb1,
@@ -250,26 +219,26 @@ static void test_failure(void)
 			[C2_NET_QT_ACTIVE_BULK_SEND]  = tf_buf_cb1,
 		},
 	};
-	static struct c2_net_buffer d1nb1;
-	static struct c2_net_buffer d1nb2;
-	static struct c2_clink tmwait1;
+	struct c2_net_buffer d1nb1;
+	struct c2_net_buffer d1nb2;
+	struct c2_clink tmwait1;
 
 	/* dom 2 */
-	static struct c2_net_domain dom2 = {
+ 	struct c2_net_domain dom2 = {
 		.nd_xprt = NULL
 	};
-	static const struct c2_net_tm_callbacks tm_cbs2 = {
+	struct c2_net_tm_callbacks tm_cbs2 = {
 		.ntc_event_cb = tf_tm_cb2
 	};
-	static struct c2_net_transfer_mc d2tm1 = {
+	struct c2_net_transfer_mc d2tm1 = {
 		.ntm_callbacks = &tm_cbs2,
 		.ntm_state = C2_NET_TM_UNDEFINED
 	};
-	static struct c2_net_transfer_mc d2tm2 = {
+	struct c2_net_transfer_mc d2tm2 = {
 		.ntm_callbacks = &tm_cbs2,
 		.ntm_state = C2_NET_TM_UNDEFINED
 	};
-	static const struct c2_net_buffer_callbacks buf_cbs2 = {
+	struct c2_net_buffer_callbacks buf_cbs2 = {
 		.nbc_cb = {
 			[C2_NET_QT_MSG_RECV]          = tf_buf_cb2,
 			[C2_NET_QT_MSG_SEND]          = tf_buf_cb2,
@@ -279,24 +248,25 @@ static void test_failure(void)
 			[C2_NET_QT_ACTIVE_BULK_SEND]  = tf_buf_cb2,
 		},
 	};
-	static struct c2_net_buffer d2nb1;
-	static struct c2_net_buffer d2nb2;
-	static c2_bcount_t d2nb2_len;
-	static struct c2_clink tmwait2;
+	struct c2_net_buffer d2nb1;
+	struct c2_net_buffer d2nb2;
+	struct c2_clink tmwait2;
 
-	static struct c2_net_end_point *ep;
-	static struct c2_net_qstats qs;
+	struct c2_net_end_point *ep;
+	struct c2_net_qstats qs;
 
 	/* setup the first dom */
 	C2_UT_ASSERT(!c2_net_domain_init(&dom1, &c2_net_bulk_mem_xprt));
+	C2_UT_ASSERT(!c2_net_end_point_create(&ep, &dom1, "127.0.0.1:10"));
+	C2_UT_ASSERT(strcmp(ep->nep_addr,"127.0.0.1:10")==0);
 	C2_UT_ASSERT(!c2_net_tm_init(&d1tm1, &dom1));
 	c2_clink_init(&tmwait1, NULL);
 	c2_clink_add(&d1tm1.ntm_chan, &tmwait1);
-	C2_UT_ASSERT(!c2_net_tm_start(&d1tm1, "127.0.0.1:10"));
+	C2_UT_ASSERT(!c2_net_tm_start(&d1tm1, ep));
+	C2_UT_ASSERT(!c2_net_end_point_put(ep));
 	c2_chan_wait(&tmwait1);
 	c2_clink_del(&tmwait1);
 	C2_UT_ASSERT(d1tm1.ntm_state == C2_NET_TM_STARTED);
-	C2_UT_ASSERT(strcmp(d1tm1.ntm_ep->nep_addr, "127.0.0.1:10") == 0);
 	C2_SET0(&d1nb1);
 	C2_UT_ASSERT(!c2_bufvec_alloc(&d1nb1.nb_buffer, 4, 10));
 	C2_UT_ASSERT(!c2_net_buffer_register(&d1nb1, &dom1));
@@ -313,11 +283,13 @@ static void test_failure(void)
 	C2_UT_ASSERT(!c2_net_tm_init(&d2tm2, &dom2));
 	c2_clink_init(&tmwait2, NULL);
 	c2_clink_add(&d2tm2.ntm_chan, &tmwait2);
-	C2_UT_ASSERT(!c2_net_tm_start(&d2tm2, "127.0.0.1:21"));
+	C2_UT_ASSERT(!c2_net_end_point_create(&ep, &dom2, "127.0.0.1:21"));
+	C2_UT_ASSERT(strcmp(ep->nep_addr,"127.0.0.1:21")==0);
+	C2_UT_ASSERT(!c2_net_tm_start(&d2tm2, ep));
+	C2_UT_ASSERT(!c2_net_end_point_put(ep));
 	c2_chan_wait(&tmwait2);
 	c2_clink_del(&tmwait2);
 	C2_UT_ASSERT(d2tm2.ntm_state == C2_NET_TM_STARTED);
-	C2_UT_ASSERT(strcmp(d2tm2.ntm_ep->nep_addr, "127.0.0.1:21") == 0);
 
 	C2_SET0(&d2nb1);
 	C2_UT_ASSERT(!c2_bufvec_alloc(&d2nb1.nb_buffer, 4, 10));
@@ -325,7 +297,6 @@ static void test_failure(void)
 	d2nb1.nb_callbacks = &buf_cbs2;
 	C2_SET0(&d2nb2);
 	C2_UT_ASSERT(!c2_bufvec_alloc(&d2nb2.nb_buffer, 1, 10));
-	d2nb2_len = 1 * 10;
 	C2_UT_ASSERT(!c2_net_buffer_register(&d2nb2, &dom2));
 	d2nb2.nb_callbacks = &buf_cbs2;
 
@@ -336,8 +307,8 @@ static void test_failure(void)
 	   the destination TM not started.
 	*/
 	tf_cbreset();
-	C2_UT_ASSERT(!c2_net_end_point_create(&ep, &d1tm1, "127.0.0.1:20"));
-	C2_UT_ASSERT(strcmp(ep->nep_addr, "127.0.0.1:20") == 0);
+	C2_UT_ASSERT(!c2_net_end_point_create(&ep, &dom1, "127.0.0.1:20"));
+	C2_UT_ASSERT(strcmp(ep->nep_addr,"127.0.0.1:20")==0);
 	d1nb1.nb_qtype = C2_NET_QT_MSG_SEND;
 	d1nb1.nb_ep = ep;
 	d1nb1.nb_length = 10; /* don't care */
@@ -354,11 +325,14 @@ static void test_failure(void)
 	/* start the TM on port 20 in the second dom */
 	c2_clink_init(&tmwait2, NULL);
 	c2_clink_add(&d2tm1.ntm_chan, &tmwait2);
-	C2_UT_ASSERT(!c2_net_tm_start(&d2tm1, "127.0.0.1:20"));
+	C2_UT_ASSERT(!c2_net_end_point_create(&ep, &dom2, "127.0.0.1:20"));
+	C2_UT_ASSERT(strcmp(ep->nep_addr,"127.0.0.1:20")==0);
+	C2_UT_ASSERT(!c2_net_tm_start(&d2tm1, ep));
+	C2_UT_ASSERT(!c2_net_end_point_put(ep));
 	c2_chan_wait(&tmwait2);
 	c2_clink_del(&tmwait2);
 	C2_UT_ASSERT(d2tm1.ntm_state == C2_NET_TM_STARTED);
-	C2_UT_ASSERT(strcmp(d2tm1.ntm_ep->nep_addr, "127.0.0.1:20") == 0);
+
 
 	/* TEST
 	   Send a message from d1tm1 to d2tm1 - should fail because
@@ -372,8 +346,8 @@ static void test_failure(void)
 	c2_clink_add(&d2tm1.ntm_chan, &tmwait2);
 
 	C2_UT_ASSERT(!c2_net_tm_stats_get(&d1tm1,C2_NET_QT_MSG_SEND,&qs,true));
-	C2_UT_ASSERT(!c2_net_end_point_create(&ep, &d1tm1, "127.0.0.1:20"));
-	C2_UT_ASSERT(strcmp(ep->nep_addr, "127.0.0.1:20") == 0);
+	C2_UT_ASSERT(!c2_net_end_point_create(&ep, &dom1, "127.0.0.1:20"));
+	C2_UT_ASSERT(strcmp(ep->nep_addr,"127.0.0.1:20")==0);
 	d1nb1.nb_qtype = C2_NET_QT_MSG_SEND;
 	d1nb1.nb_ep = ep;
 	d1nb1.nb_length = 10; /* don't care */
@@ -411,15 +385,13 @@ static void test_failure(void)
 	C2_UT_ASSERT(!c2_net_tm_stats_get(&d2tm1,C2_NET_QT_MSG_RECV,&qs,true));
 	d2nb2.nb_qtype = C2_NET_QT_MSG_RECV;
 	d2nb2.nb_ep = NULL;
-	d2nb2.nb_min_receive_size = d2nb2_len;
-	d2nb2.nb_max_receive_msgs = 1;
 	c2_clink_init(&tmwait2, NULL);
 	c2_clink_add(&d2tm1.ntm_chan, &tmwait2);
 	C2_UT_ASSERT(!c2_net_buffer_add(&d2nb2, &d2tm1));
 
 	C2_UT_ASSERT(!c2_net_tm_stats_get(&d1tm1,C2_NET_QT_MSG_SEND,&qs,true));
-	C2_UT_ASSERT(!c2_net_end_point_create(&ep, &d1tm1, "127.0.0.1:20"));
-	C2_UT_ASSERT(strcmp(ep->nep_addr, "127.0.0.1:20") == 0);
+	C2_UT_ASSERT(!c2_net_end_point_create(&ep, &dom1, "127.0.0.1:20"));
+	C2_UT_ASSERT(strcmp(ep->nep_addr,"127.0.0.1:20")==0);
 	d1nb1.nb_qtype = C2_NET_QT_MSG_SEND;
 	d1nb1.nb_ep = ep;
 	d1nb1.nb_length = 40;
@@ -451,13 +423,63 @@ static void test_failure(void)
 
 	/* TEST
 	   Set up a passive receive buffer in one dom, and
+	   try to actively send from an unauthorized dom
+	*/
+	tf_cbreset();
+	C2_UT_ASSERT(!c2_net_tm_stats_get(&d2tm1,C2_NET_QT_PASSIVE_BULK_RECV,
+					  &qs,true));
+	C2_UT_ASSERT(!c2_net_end_point_create(&ep, &dom2, "127.0.0.1:30"));
+	C2_UT_ASSERT(strcmp(ep->nep_addr,"127.0.0.1:30")==0);
+	d2nb1.nb_qtype = C2_NET_QT_PASSIVE_BULK_RECV;
+	d2nb1.nb_ep = ep;
+	c2_clink_init(&tmwait2, NULL);
+	c2_clink_add(&d2tm1.ntm_chan, &tmwait2);
+	C2_UT_ASSERT(!c2_net_buffer_add(&d2nb1, &d2tm1));
+	C2_UT_ASSERT(d2nb1.nb_desc.nbd_len != 0);
+	C2_UT_ASSERT(!c2_net_end_point_put(ep));
+
+	C2_UT_ASSERT(!c2_net_tm_stats_get(&d1tm1,C2_NET_QT_ACTIVE_BULK_SEND,
+					  &qs,true));
+	C2_UT_ASSERT(!c2_net_desc_copy(&d2nb1.nb_desc, &d1nb1.nb_desc));
+	d1nb1.nb_qtype = C2_NET_QT_ACTIVE_BULK_SEND;
+	d1nb1.nb_length = 10;
+	c2_clink_init(&tmwait1, NULL);
+	c2_clink_add(&d1tm1.ntm_chan, &tmwait1);
+	C2_UT_ASSERT(!c2_net_buffer_add(&d1nb1, &d1tm1));
+	c2_chan_wait(&tmwait1);
+	c2_clink_del(&tmwait1);
+	C2_UT_ASSERT(cb_qt1 == C2_NET_QT_ACTIVE_BULK_SEND);
+	C2_UT_ASSERT(cb_nb1 == &d1nb1);
+	C2_UT_ASSERT(cb_status1 == -EACCES);
+	C2_UT_ASSERT(!c2_net_tm_stats_get(&d1tm1,C2_NET_QT_ACTIVE_BULK_SEND,
+					  &qs,true));
+	C2_UT_ASSERT(qs.nqs_num_f_events == 1);
+	C2_UT_ASSERT(qs.nqs_num_s_events == 0);
+	C2_UT_ASSERT(qs.nqs_num_adds == 1);
+	C2_UT_ASSERT(qs.nqs_num_dels == 0);
+
+	c2_net_buffer_del(&d2nb1, &d2tm1);
+	c2_chan_wait(&tmwait2);
+	c2_clink_del(&tmwait2);
+	C2_UT_ASSERT(cb_qt2 == C2_NET_QT_PASSIVE_BULK_RECV);
+	C2_UT_ASSERT(cb_nb2 == &d2nb1);
+	C2_UT_ASSERT(cb_status2 == -ECANCELED);
+	C2_UT_ASSERT(!c2_net_tm_stats_get(&d2tm1,C2_NET_QT_PASSIVE_BULK_RECV,
+					  &qs,true));
+	C2_UT_ASSERT(qs.nqs_num_f_events == 1);
+	C2_UT_ASSERT(qs.nqs_num_s_events == 0);
+	C2_UT_ASSERT(qs.nqs_num_adds == 1);
+	C2_UT_ASSERT(qs.nqs_num_dels == 1);
+
+	/* TEST
+	   Set up a passive receive buffer in one dom, and
 	   try to actively receive from it.
 	*/
 	tf_cbreset();
 	C2_UT_ASSERT(!c2_net_tm_stats_get(&d2tm1,C2_NET_QT_PASSIVE_BULK_RECV,
 					  &qs,true));
-	C2_UT_ASSERT(!c2_net_end_point_create(&ep, &d2tm1, "127.0.0.1:10"));
-	C2_UT_ASSERT(strcmp(ep->nep_addr, "127.0.0.1:10") == 0);
+	C2_UT_ASSERT(!c2_net_end_point_create(&ep, &dom2, "127.0.0.1:10"));
+	C2_UT_ASSERT(strcmp(ep->nep_addr,"127.0.0.1:10")==0);
 	d2nb1.nb_qtype = C2_NET_QT_PASSIVE_BULK_RECV;
 	d2nb1.nb_ep = ep;
 	c2_clink_init(&tmwait2, NULL);
@@ -485,7 +507,6 @@ static void test_failure(void)
 	C2_UT_ASSERT(qs.nqs_num_s_events == 0);
 	C2_UT_ASSERT(qs.nqs_num_adds == 1);
 	C2_UT_ASSERT(qs.nqs_num_dels == 0);
-	c2_net_desc_free(&d1nb1.nb_desc);
 
 	c2_net_buffer_del(&d2nb1, &d2tm1);
 	c2_chan_wait(&tmwait2);
@@ -499,7 +520,6 @@ static void test_failure(void)
 	C2_UT_ASSERT(qs.nqs_num_s_events == 0);
 	C2_UT_ASSERT(qs.nqs_num_adds == 1);
 	C2_UT_ASSERT(qs.nqs_num_dels == 1);
-	c2_net_desc_free(&d2nb1.nb_desc);
 
 	/* TEST
 	   Set up a passive receive buffer in one dom, and
@@ -508,8 +528,8 @@ static void test_failure(void)
 	tf_cbreset();
 	C2_UT_ASSERT(!c2_net_tm_stats_get(&d2tm1,C2_NET_QT_PASSIVE_BULK_RECV,
 					  &qs,true));
-	C2_UT_ASSERT(!c2_net_end_point_create(&ep, &d2tm1, "127.0.0.1:10"));
-	C2_UT_ASSERT(strcmp(ep->nep_addr, "127.0.0.1:10") == 0);
+	C2_UT_ASSERT(!c2_net_end_point_create(&ep, &dom2, "127.0.0.1:10"));
+	C2_UT_ASSERT(strcmp(ep->nep_addr,"127.0.0.1:10")==0);
 	d2nb2.nb_qtype = C2_NET_QT_PASSIVE_BULK_RECV;
 	d2nb2.nb_ep = ep;
 	c2_clink_init(&tmwait2, NULL);
@@ -537,7 +557,6 @@ static void test_failure(void)
 	C2_UT_ASSERT(qs.nqs_num_s_events == 0);
 	C2_UT_ASSERT(qs.nqs_num_adds == 1);
 	C2_UT_ASSERT(qs.nqs_num_dels == 0);
-	c2_net_desc_free(&d1nb1.nb_desc);
 
 	c2_chan_wait(&tmwait2);
 	c2_clink_del(&tmwait2);
@@ -550,7 +569,6 @@ static void test_failure(void)
 	C2_UT_ASSERT(qs.nqs_num_s_events == 0);
 	C2_UT_ASSERT(qs.nqs_num_adds == 1);
 	C2_UT_ASSERT(qs.nqs_num_dels == 0);
-	c2_net_desc_free(&d2nb2.nb_desc);
 
 	/* TEST
 	   Setup a passive send buffer and add it. Save the descriptor in the
@@ -562,8 +580,8 @@ static void test_failure(void)
 	tf_cbreset();
 	C2_UT_ASSERT(!c2_net_tm_stats_get(&d2tm1,C2_NET_QT_PASSIVE_BULK_RECV,
 					  &qs,true));
-	C2_UT_ASSERT(!c2_net_end_point_create(&ep, &d2tm1, "127.0.0.1:10"));
-	C2_UT_ASSERT(strcmp(ep->nep_addr, "127.0.0.1:10") == 0);
+	C2_UT_ASSERT(!c2_net_end_point_create(&ep, &dom2, "127.0.0.1:10"));
+	C2_UT_ASSERT(strcmp(ep->nep_addr,"127.0.0.1:10")==0);
 	d2nb1.nb_qtype = C2_NET_QT_PASSIVE_BULK_RECV;
 	d2nb1.nb_ep = ep;
 	c2_clink_init(&tmwait2, NULL);
@@ -582,7 +600,6 @@ static void test_failure(void)
 	C2_UT_ASSERT(cb_qt2 == C2_NET_QT_PASSIVE_BULK_RECV);
 	C2_UT_ASSERT(cb_nb2 == &d2nb1);
 	C2_UT_ASSERT(cb_status2 == -ECANCELED);
-	c2_net_desc_free(&d2nb1.nb_desc);
 
 	/* resubmit */
 	tf_cbreset2();
@@ -619,7 +636,6 @@ static void test_failure(void)
 	C2_UT_ASSERT(qs.nqs_num_s_events == 0);
 	C2_UT_ASSERT(qs.nqs_num_adds == 1);
 	C2_UT_ASSERT(qs.nqs_num_dels == 0);
-	c2_net_desc_free(&d1nb1.nb_desc);
 
 	c2_net_buffer_del(&d2nb1, &d2tm1);
 	c2_chan_wait(&tmwait2);
@@ -633,17 +649,12 @@ static void test_failure(void)
 	C2_UT_ASSERT(qs.nqs_num_s_events == 0);
 	C2_UT_ASSERT(qs.nqs_num_adds == 2);
 	C2_UT_ASSERT(qs.nqs_num_dels == 2);
-	c2_net_desc_free(&d2nb1.nb_desc);
 
 	/* fini */
-	c2_net_buffer_deregister(&d1nb1, &dom1);
-	c2_bufvec_free(&d1nb1.nb_buffer);
-	c2_net_buffer_deregister(&d1nb2, &dom1);
-	c2_bufvec_free(&d1nb2.nb_buffer);
-	c2_net_buffer_deregister(&d2nb1, &dom2);
-	c2_bufvec_free(&d2nb1.nb_buffer);
-	c2_net_buffer_deregister(&d2nb2, &dom2);
-	c2_bufvec_free(&d2nb2.nb_buffer);
+	C2_UT_ASSERT(!c2_net_buffer_deregister(&d1nb1, &dom1));
+	C2_UT_ASSERT(!c2_net_buffer_deregister(&d1nb2, &dom1));
+	C2_UT_ASSERT(!c2_net_buffer_deregister(&d2nb1, &dom2));
+	C2_UT_ASSERT(!c2_net_buffer_deregister(&d2nb2, &dom2));
 
 	c2_clink_init(&tmwait1, NULL);
 	c2_clink_add(&d1tm1.ntm_chan, &tmwait1);
@@ -692,10 +703,7 @@ static struct ping_ops quiet_ops = {
 
 static void test_ping(void)
 {
-	/* some variables below are static to reduce kernel stack
-	   consumption. */
-
-	static struct ping_ctx cctx = {
+	struct ping_ctx cctx = {
 		.pc_ops = &quiet_ops,
 		.pc_xprt = &c2_net_bulk_mem_xprt,
 		.pc_nr_bufs = PING_NR_BUFS,
@@ -705,7 +713,7 @@ static void test_ping(void)
 			.ntm_state     = C2_NET_TM_UNDEFINED
 		}
 	};
-	static struct ping_ctx sctx = {
+	struct ping_ctx sctx = {
 		.pc_ops = &quiet_ops,
 		.pc_xprt = &c2_net_bulk_mem_xprt,
 		.pc_nr_bufs = PING_NR_BUFS,
@@ -765,15 +773,14 @@ static void test_ping(void)
 	c2_cond_fini(&sctx.pc_cond);
 	c2_mutex_fini(&sctx.pc_mutex);
 	c2_net_xprt_fini(&c2_net_bulk_mem_xprt);
-	c2_free(data);
 }
 
 static void test_tm(void)
 {
-	static struct c2_net_domain dom1 = {
+	struct c2_net_domain dom1 = {
 		.nd_xprt = NULL
 	};
-	const struct c2_net_tm_callbacks cbs1 = {
+	struct c2_net_tm_callbacks cbs1 = {
 		.ntc_event_cb = LAMBDA(void,(const struct c2_net_tm_event *ev) {
 				       }),
 	};
@@ -817,20 +824,19 @@ static void test_tm(void)
 	c2_net_domain_fini(&dom1);
 }
 
-const struct c2_test_suite c2_net_bulk_mem_ut = {
+const struct c2_test_suite net_bulk_mem_ut = {
         .ts_name = "net-bulk-mem",
         .ts_init = NULL,
         .ts_fini = NULL,
         .ts_tests = {
                 { "net_bulk_mem_buf_copy_test", test_buf_copy },
-		{ "net_bulk_mem_tm_test",       test_tm },
                 { "net_bulk_mem_ep",            test_ep },
                 { "net_bulk_mem_failure_tests", test_failure },
+		{ "net_bulk_mem_tm_test",       test_tm},
                 { "net_bulk_mem_ping_tests",    test_ping },
                 { NULL, NULL }
         }
 };
-C2_EXPORTED(c2_net_bulk_mem_ut);
 
 /*
  *  Local variables:
diff --git a/net/bulk_emulation/ut/bulk_sunrpc_ut.c b/net/bulk_emulation/ut/bulk_sunrpc_ut.c
index 745d17f..6c9bff3 100644
--- a/net/bulk_emulation/ut/bulk_sunrpc_ut.c
+++ b/net/bulk_emulation/ut/bulk_sunrpc_ut.c
@@ -14,30 +14,53 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Carl Braganza <Carl_Braganza@us.xyratex.com>,
- *                  Dave Cohrs <Dave_Cohrs@us.xyratex.com>
+ * Original author: Carl Braganza, Dave Cohrs
  * Original creation date: 04/12/2011
  */
 
 #include "lib/misc.h"
-#include "lib/time.h"
 #include "lib/ut.h"
 
 #include "net/bulk_emulation/sunrpc_xprt_xo.c"
 #include "net/bulk_emulation/st/ping.h"
 
-static void ut_sleep_secs(int secs)
+static void test_sunrpc_ep(void)
 {
-	c2_time_t req, rem;
-	c2_time_set(&req, secs, 0);
-	c2_nanosleep(req, &rem);
-}
+	/* dom1 */
+	struct c2_net_domain dom1 = {
+		.nd_xprt = NULL
+	};
+	struct c2_net_end_point *ep1;
+	struct c2_net_end_point *ep2;
+	struct c2_net_end_point *ep3;
+	const char *addr;
 
-static c2_time_t ut_timeout_after_secs(int secs)
-{
-	c2_time_t dur;
-	c2_time_set(&dur, secs, 0);
-	return c2_time_add(c2_time_now(), dur);
+	C2_UT_ASSERT(!c2_net_domain_init(&dom1, &c2_net_bulk_sunrpc_xprt));
+	addr = "255.255.255.255:65535";
+	C2_UT_ASSERT(c2_net_end_point_create(&ep1, &dom1, addr) == -EINVAL);
+	addr = "255.255.255.255:65535:4294967295";
+	C2_UT_ASSERT(!c2_net_end_point_create(&ep1, &dom1, addr));
+	C2_UT_ASSERT(strcmp(ep1->nep_addr, addr) == 0);
+	C2_UT_ASSERT(ep1->nep_addr != addr);
+	C2_UT_ASSERT(c2_atomic64_get(&ep1->nep_ref.ref_cnt) == 1);
+
+	C2_UT_ASSERT(!c2_net_end_point_create(&ep2, &dom1, addr));
+	C2_UT_ASSERT(strcmp(ep2->nep_addr, addr) == 0);
+	C2_UT_ASSERT(ep2->nep_addr != addr);
+	C2_UT_ASSERT(c2_atomic64_get(&ep2->nep_ref.ref_cnt) == 2);
+	C2_UT_ASSERT(ep1 == ep2);
+
+	C2_UT_ASSERT(!c2_net_end_point_create(&ep3, &dom1, addr));
+	C2_UT_ASSERT(strcmp(ep3->nep_addr, addr) == 0);
+	C2_UT_ASSERT(ep3->nep_addr != addr);
+	C2_UT_ASSERT(c2_atomic64_get(&ep3->nep_ref.ref_cnt) == 3);
+	C2_UT_ASSERT(ep1 == ep3);
+
+	C2_UT_ASSERT(!c2_net_end_point_put(ep1));
+	C2_UT_ASSERT(!c2_net_end_point_put(ep2));
+	C2_UT_ASSERT(!c2_net_end_point_put(ep3));
+
+	c2_net_domain_fini(&dom1);
 }
 
 static enum c2_net_tm_ev_type cb_evt1;
@@ -63,7 +86,7 @@ void sunrpc_buf_cb1(const struct c2_net_buffer_event *ev)
 	cb_status1 = ev->nbe_status;
 }
 
-void sunrpc_cbreset1(void)
+void sunrpc_cbreset1()
 {
 	cb_evt1    = C2_NET_TEV_NR;
 	cb_nb1     = NULL;
@@ -95,7 +118,7 @@ void sunrpc_buf_cb2(const struct c2_net_buffer_event *ev)
 	cb_status2 = ev->nbe_status;
 }
 
-void sunrpc_cbreset2(void)
+void sunrpc_cbreset2()
 {
 	cb_evt2    = C2_NET_TEV_NR;
 	cb_nb2     = NULL;
@@ -104,287 +127,47 @@ void sunrpc_cbreset2(void)
 	cb_status2 = 9999999;
 }
 
-void sunrpc_cbreset(void)
+void sunrpc_cbreset()
 {
 	sunrpc_cbreset1();
 	sunrpc_cbreset2();
 }
 
-static void test_sunrpc_ep(void)
-{
-	/* dom1 */
-	static struct c2_net_domain dom1 = {
-		.nd_xprt = NULL
-	};
-	static struct c2_net_tm_callbacks tm_cbs1 = {
-		.ntc_event_cb = sunrpc_tm_cb1
-	};
-	static struct c2_net_transfer_mc d1tm1 = {
-		.ntm_callbacks = &tm_cbs1,
-		.ntm_state = C2_NET_TM_UNDEFINED
-	};
-	struct c2_clink tmwait;
-	struct c2_net_end_point *ep1;
-	struct c2_net_end_point *ep2;
-	struct c2_net_end_point *ep3;
-	struct c2_net_end_point *ep4;
-	struct c2_net_end_point *ep5;
-	const char *addr;
-	struct c2_net_conn *conn;
-	struct c2_net_bulk_sunrpc_conn *sconn;
-	struct c2_net_bulk_sunrpc_conn *sconn2;
-	struct c2_net_bulk_sunrpc_domain_pvt *dp;
-	c2_time_t t1;
-	c2_time_t t2;
-	c2_time_t t3;
-	uint32_t hb;
-
-	/* TEST: Multiple create calls on the same address return the
-	   same object.
-	*/
-	C2_UT_ASSERT(!c2_net_domain_init(&dom1, &c2_net_bulk_sunrpc_xprt));
-	C2_UT_ASSERT(!c2_net_tm_init(&d1tm1, &dom1));
-
-	c2_clink_init(&tmwait, NULL);
-	c2_clink_add(&d1tm1.ntm_chan, &tmwait);
-	C2_UT_ASSERT(!c2_net_tm_start(&d1tm1, "127.0.0.1:31111:11"));
-	c2_chan_wait(&tmwait);
-	c2_clink_del(&tmwait);
-	C2_UT_ASSERT(d1tm1.ntm_ep != NULL);
-	C2_UT_ASSERT(d1tm1.ntm_state == C2_NET_TM_STARTED);
-	if (d1tm1.ntm_state == C2_NET_TM_FAILED) {
-		/* skip rest of this test, else C2_ASSERT will occur */
-		c2_net_tm_fini(&d1tm1);
-		c2_net_domain_fini(&dom1);
-		C2_UT_FAIL("aborting test case, port 31111 in-use?");
-		return;
-	}
-
-	C2_UT_ASSERT(c2_net_bulk_sunrpc_dom_get_end_point_release_delay(&dom1)
-		     == C2_NET_BULK_SUNRPC_EP_DELAY_S);
-	addr = "127.0.0.1:31111";
-	C2_UT_ASSERT(c2_net_end_point_create(&ep1, &d1tm1, addr) == -EINVAL);
-	addr = "127.0.0.1:31111:4294967295";
-	C2_UT_ASSERT(!c2_net_end_point_create(&ep1, &d1tm1, addr));
-	C2_UT_ASSERT(strcmp(ep1->nep_addr, addr) == 0);
-	C2_UT_ASSERT(ep1->nep_addr != addr);
-	C2_UT_ASSERT(c2_atomic64_get(&ep1->nep_ref.ref_cnt) == 1);
-
-	C2_UT_ASSERT(!c2_net_end_point_create(&ep2, &d1tm1, addr));
-	C2_UT_ASSERT(strcmp(ep2->nep_addr, addr) == 0);
-	C2_UT_ASSERT(ep2->nep_addr != addr);
-	C2_UT_ASSERT(c2_atomic64_get(&ep2->nep_ref.ref_cnt) == 2);
-	C2_UT_ASSERT(ep1 == ep2);
-
-	C2_UT_ASSERT(!c2_net_end_point_create(&ep3, &d1tm1, addr));
-	C2_UT_ASSERT(strcmp(ep3->nep_addr, addr) == 0);
-	C2_UT_ASSERT(ep3->nep_addr != addr);
-	C2_UT_ASSERT(c2_atomic64_get(&ep3->nep_ref.ref_cnt) == 3);
-	C2_UT_ASSERT(ep1 == ep3);
-
-	/* TEST: end points cached internally if connections were used */
-
-	/* fake a "touch" on the end point to induce caching */
-	C2_UT_ASSERT(sunrpc_ep_get_conn(ep1, &conn, &sconn) == 0);
-	sunrpc_ep_put_conn(sconn, conn, 0);
-
-	/* release the EP references */
-	C2_UT_ASSERT(!c2_net_end_point_put(ep1));
-	C2_UT_ASSERT(!c2_net_end_point_put(ep2));
-	C2_UT_ASSERT(!c2_net_end_point_put(ep3));
-
-	/* The conn (but not the EP) is still cached
-	   because the default delay is about 20 sec */
-	C2_UT_ASSERT(c2_list_length(&d1tm1.ntm_end_points) == 1);
-	dp = sunrpc_dom_to_pvt(&dom1);
-	C2_UT_ASSERT(c2_list_contains(&dp->xd_conn_cache,
-				      &sconn->xc_dp_linkage));
-	C2_UT_ASSERT(c2_atomic64_get(&sconn->xc_ref.ref_cnt) == 0);
-
-	/* should be able to get the same end point */
-	C2_UT_ASSERT(!c2_net_end_point_create(&ep4, &d1tm1, addr));
-	C2_UT_ASSERT(strcmp(ep4->nep_addr, addr) == 0);
-	C2_UT_ASSERT(ep4->nep_addr != addr);
-	C2_UT_ASSERT(c2_atomic64_get(&ep4->nep_ref.ref_cnt) == 1);
-
-	/* touch and release it */
-	C2_UT_ASSERT(sunrpc_ep_get_conn(ep4, &conn, &sconn2) == 0);
-	C2_UT_ASSERT(sconn2 == sconn); /* cached: same sconn */
-	sunrpc_ep_put_conn(sconn2, conn, 0);
-	C2_UT_ASSERT(!c2_net_end_point_put(ep4));
-	C2_UT_ASSERT(c2_list_length(&d1tm1.ntm_end_points) == 1);
-	C2_UT_ASSERT(c2_list_contains(&dp->xd_conn_cache,
-				      &sconn2->xc_dp_linkage));
-
-	/* TEST: caching only works if the last use is non zero */
-	addr = "127.0.0.1:31111:1234";
-	C2_UT_ASSERT(!c2_net_end_point_create(&ep5, &d1tm1, addr));
-	C2_UT_ASSERT(strcmp(ep5->nep_addr, addr) == 0);
-	C2_UT_ASSERT(ep5->nep_addr != addr);
-	C2_UT_ASSERT(c2_atomic64_get(&ep5->nep_ref.ref_cnt) == 1);
-	C2_UT_ASSERT(sunrpc_ep_get_conn(ep5, &conn, &sconn) == 0);
-	sunrpc_ep_put_conn(sconn, conn, 1);
-	C2_UT_ASSERT(!c2_net_end_point_put(ep5)); /* not cached */
-	C2_UT_ASSERT(c2_list_is_empty(&dp->xd_conn_cache));
-	C2_UT_ASSERT(c2_list_length(&d1tm1.ntm_end_points) == 1);
-	C2_UT_ASSERT(!c2_list_contains(&d1tm1.ntm_end_points,
-				       &ep5->nep_tm_linkage));
-
-	/* fini still works because the cache gets flushed */
-	c2_clink_add(&d1tm1.ntm_chan, &tmwait);
-	C2_UT_ASSERT(!c2_net_tm_stop(&d1tm1, false));
-	c2_chan_wait(&tmwait);
-	c2_clink_del(&tmwait);
-	C2_UT_ASSERT(d1tm1.ntm_state == C2_NET_TM_STOPPED);
-	c2_net_tm_fini(&d1tm1);
-	c2_net_domain_fini(&dom1);
-
-	/* TEST: End point caching can be disabled. The act of
-	   disabling flushes cached end points.
-	*/
-	C2_UT_ASSERT(!c2_net_domain_init(&dom1, &c2_net_bulk_sunrpc_xprt));
-	C2_UT_ASSERT(!c2_net_tm_init(&d1tm1, &dom1));
-	C2_UT_ASSERT(c2_net_bulk_sunrpc_dom_get_end_point_release_delay(&dom1)
-		     == C2_NET_BULK_SUNRPC_EP_DELAY_S);
-
-	c2_clink_init(&tmwait, NULL);
-	c2_clink_add(&d1tm1.ntm_chan, &tmwait);
-	C2_UT_ASSERT(!c2_net_tm_start(&d1tm1, "127.0.0.1:31111:11"));
-	c2_chan_wait(&tmwait);
-	c2_clink_del(&tmwait);
-	C2_UT_ASSERT(d1tm1.ntm_ep != NULL);
-
-	addr = "127.0.0.1:31111:3534";
-	C2_UT_ASSERT(!c2_net_end_point_create(&ep1, &d1tm1, addr));
-	C2_UT_ASSERT(strcmp(ep1->nep_addr, addr) == 0);
-	C2_UT_ASSERT(ep1->nep_addr != addr);
-	C2_UT_ASSERT(c2_atomic64_get(&ep1->nep_ref.ref_cnt) == 1);
-	C2_UT_ASSERT(sunrpc_ep_get_conn(ep1, &conn, &sconn) == 0);
-	sunrpc_ep_put_conn(sconn, conn, 0);
-	C2_UT_ASSERT(!c2_net_end_point_put(ep1));
-	C2_UT_ASSERT(c2_list_length(&d1tm1.ntm_end_points) == 1);
-	dp = sunrpc_dom_to_pvt(&dom1);
-	C2_UT_ASSERT(c2_list_contains(&dp->xd_conn_cache,
-				      &sconn->xc_dp_linkage));
-	C2_UT_ASSERT(c2_list_length(&dp->xd_conn_cache) == 1);
-
-	c2_net_bulk_sunrpc_dom_set_end_point_release_delay(&dom1, 0);
-	C2_UT_ASSERT(c2_net_bulk_sunrpc_dom_get_end_point_release_delay(&dom1)
-		     == 0);
-	C2_UT_ASSERT(c2_list_length(&d1tm1.ntm_end_points) == 1); /* flushed */
-	C2_UT_ASSERT(c2_list_is_empty(&dp->xd_conn_cache));
-
-	addr = "127.0.0.1:31111:3535";
-	C2_UT_ASSERT(!c2_net_end_point_create(&ep1, &d1tm1, addr));
-	C2_UT_ASSERT(strcmp(ep1->nep_addr, addr) == 0);
-	C2_UT_ASSERT(ep1->nep_addr != addr);
-	C2_UT_ASSERT(c2_atomic64_get(&ep1->nep_ref.ref_cnt) == 1);
-	C2_UT_ASSERT(sunrpc_ep_get_conn(ep1, &conn, &sconn) == 0);
-	sunrpc_ep_put_conn(sconn, conn, 0);
-	C2_UT_ASSERT(!c2_net_end_point_put(ep1));
-	C2_UT_ASSERT(c2_list_length(&d1tm1.ntm_end_points) == 1); /* !cached */
-
-	c2_clink_add(&d1tm1.ntm_chan, &tmwait);
-	C2_UT_ASSERT(!c2_net_tm_stop(&d1tm1, false));
-	c2_chan_wait(&tmwait);
-	c2_clink_del(&tmwait);
-	c2_net_tm_fini(&d1tm1);
-	c2_net_domain_fini(&dom1);
-
-	/* TEST: skulker thread cleans up the cache */
-	C2_UT_ASSERT(!c2_net_domain_init(&dom1, &c2_net_bulk_sunrpc_xprt));
-	C2_UT_ASSERT(!c2_net_tm_init(&d1tm1, &dom1));
-	C2_UT_ASSERT(c2_net_bulk_sunrpc_dom_get_end_point_release_delay(&dom1)
-		     == C2_NET_BULK_SUNRPC_EP_DELAY_S);
-	c2_net_bulk_sunrpc_dom_set_end_point_release_delay(&dom1, 1000);
-	C2_UT_ASSERT(c2_net_bulk_sunrpc_dom_get_end_point_release_delay(&dom1)
-		     == 1000);
-
-	c2_clink_init(&tmwait, NULL);
-	c2_clink_add(&d1tm1.ntm_chan, &tmwait);
-	C2_UT_ASSERT(!c2_net_tm_start(&d1tm1, "127.0.0.1:31111:11"));
-	c2_chan_wait(&tmwait);
-	c2_clink_del(&tmwait);
-	C2_UT_ASSERT(d1tm1.ntm_ep != NULL);
-
-	dp = sunrpc_dom_to_pvt(&dom1);
-	while (dp->xd_skulker_hb == 0)
-		ut_sleep_secs(1); /* wait until skulker thread starts */
-
-	addr = "127.0.0.1:31111:9876";
-	C2_UT_ASSERT(!c2_net_end_point_create(&ep1, &d1tm1, addr));
-	C2_UT_ASSERT(strcmp(ep1->nep_addr, addr) == 0);
-	C2_UT_ASSERT(ep1->nep_addr != addr);
-	C2_UT_ASSERT(c2_atomic64_get(&ep1->nep_ref.ref_cnt) == 1);
-	C2_UT_ASSERT(sunrpc_ep_get_conn(ep1, &conn, &sconn) == 0);
-	t1 = c2_time_now();
-	sunrpc_ep_put_conn(sconn, conn, 0);
-	C2_UT_ASSERT(!c2_net_end_point_put(ep1));
-	dp = sunrpc_dom_to_pvt(&dom1);
-	C2_UT_ASSERT(c2_list_contains(&dp->xd_conn_cache,
-				      &sconn->xc_dp_linkage));
-	C2_UT_ASSERT(c2_list_length(&dp->xd_conn_cache) == 1);
-	c2_time_set(&t2, 1001, 0);
-	t3 = c2_time_sub(t1, t2);  /* now - 1001 */
-	c2_atomic64_set(&sconn->xc_last_use, t3);
-
-	/* force the skulker thread to wakeup */
-	hb = dp->xd_skulker_hb;
-	c2_net_bulk_sunrpc_dom_set_end_point_release_delay(&dom1, 1000);
-	while (dp->xd_skulker_hb == hb)
-		ut_sleep_secs(1);/* wait for the skulker heartbeat to advance */
-	C2_UT_ASSERT(c2_list_is_empty(&dp->xd_conn_cache)); /* flushed */
-
-	c2_clink_add(&d1tm1.ntm_chan, &tmwait);
-	C2_UT_ASSERT(!c2_net_tm_stop(&d1tm1, false));
-	c2_chan_wait(&tmwait);
-	c2_clink_del(&tmwait);
-	c2_net_tm_fini(&d1tm1);
-	c2_net_domain_fini(&dom1);
-}
-
 static void test_sunrpc_desc(void)
 {
-	static struct c2_net_domain dom1 = {
+	struct c2_net_domain dom1 = {
 		.nd_xprt = NULL
 	};
-	struct c2_net_end_point *ep1;
+	struct c2_net_end_point *ep1, *ep2;
 
-	static const struct c2_net_tm_callbacks tm_cbs1 = {
+	struct c2_net_tm_callbacks tm_cbs1 = {
 		.ntc_event_cb = sunrpc_tm_cb1
 	};
-	static struct c2_net_transfer_mc d1tm1 = {
+	struct c2_net_transfer_mc d1tm1 = {
 		.ntm_callbacks = &tm_cbs1,
 		.ntm_state = C2_NET_TM_UNDEFINED
 	};
 	struct c2_clink tmwait;
-	static struct c2_net_buf_desc desc1;
-	static struct sunrpc_buf_desc sd;
+	struct c2_net_buf_desc desc1;
+	struct sunrpc_buf_desc sd;
 
 	C2_UT_ASSERT(!c2_net_domain_init(&dom1, &c2_net_bulk_sunrpc_xprt));
+	C2_UT_ASSERT(!c2_net_end_point_create(&ep1, &dom1,"127.0.0.1:31111:1"));
+	C2_UT_ASSERT(!c2_net_end_point_create(&ep2, &dom1,"127.0.0.1:31111:2"));
 	C2_UT_ASSERT(!c2_net_tm_init(&d1tm1, &dom1));
 
 	/* start tm and wait for tm to notify it has started */
 	c2_clink_init(&tmwait, NULL);
 	c2_clink_add(&d1tm1.ntm_chan, &tmwait);
-	C2_UT_ASSERT(!c2_net_tm_start(&d1tm1, "127.0.0.1:31111:1"));
+	C2_UT_ASSERT(!c2_net_tm_start(&d1tm1, ep1));
 	c2_chan_wait(&tmwait);
 	c2_clink_del(&tmwait);
 	C2_UT_ASSERT(d1tm1.ntm_state == C2_NET_TM_STARTED);
-	if (d1tm1.ntm_state == C2_NET_TM_FAILED) {
-		/* skip rest of this test, else C2_ASSERT will occur */
-		c2_net_tm_fini(&d1tm1);
-		c2_net_domain_fini(&dom1);
-		C2_UT_FAIL("aborting test case, port 31111 in-use?");
-		return;
-	}
 
 	C2_SET0(&desc1);
 	C2_SET0(&sd);
 
-	C2_UT_ASSERT(!c2_net_end_point_create(&ep1, &d1tm1,
-					      "127.0.0.1:31111:2"));
-	C2_UT_ASSERT(!sunrpc_desc_create(&desc1, &d1tm1,
+	C2_UT_ASSERT(!sunrpc_desc_create(&desc1, ep2, &d1tm1,
 					 C2_NET_QT_PASSIVE_BULK_RECV,
 					 2345, 34));
 	C2_UT_ASSERT(desc1.nbd_len == sizeof(struct sunrpc_buf_desc));
@@ -393,11 +176,13 @@ static void test_sunrpc_desc(void)
 	C2_UT_ASSERT(sd.sbd_id == 34);
 	C2_UT_ASSERT(sd.sbd_qtype == C2_NET_QT_PASSIVE_BULK_RECV);
 	C2_UT_ASSERT(sd.sbd_total == 2345);
+	C2_UT_ASSERT(sd.sbd_active_ep.sep_addr == htonl(0x7f000001));
+	C2_UT_ASSERT(sd.sbd_active_ep.sep_port == htons(31111));
+	C2_UT_ASSERT(sd.sbd_active_ep.sep_id == 2);
 	C2_UT_ASSERT(sd.sbd_passive_ep.sep_addr == htonl(0x7f000001));
 	C2_UT_ASSERT(sd.sbd_passive_ep.sep_port == htons(31111));
 	C2_UT_ASSERT(sd.sbd_passive_ep.sep_id == 1);
 	c2_net_desc_free(&desc1);
-	C2_UT_ASSERT(!c2_net_end_point_put(ep1));
 
 	c2_clink_add(&d1tm1.ntm_chan, &tmwait);
 	C2_UT_ASSERT(!c2_net_tm_stop(&d1tm1, false));
@@ -406,88 +191,19 @@ static void test_sunrpc_desc(void)
 	C2_UT_ASSERT(d1tm1.ntm_state == C2_NET_TM_STOPPED);
 	c2_net_tm_fini(&d1tm1);
 
-	c2_net_domain_fini(&dom1);
-}
-
-static void test_sunrpc_pa(void)
-{
-	static struct c2_net_domain dom1 = {
-		.nd_xprt = NULL
-	};
-
-	static const struct c2_net_tm_callbacks tm_cbs1 = {
-		.ntc_event_cb = sunrpc_tm_cb1
-	};
-	static struct c2_net_transfer_mc d1tm1 = {
-		.ntm_callbacks = &tm_cbs1,
-		.ntm_state = C2_NET_TM_UNDEFINED
-	};
-	struct c2_clink tmwait;
-	int rc;
-	bool brc;
-	struct c2_bitmap *procmask = (void *) -1; /* fake not null UT value */
-
-	C2_UT_ASSERT(!c2_net_domain_init(&dom1, &c2_net_bulk_sunrpc_xprt));
-	C2_UT_ASSERT(!c2_net_tm_init(&d1tm1, &dom1));
-
-	/* request thread confine */
-	rc = c2_net_tm_confine(&d1tm1, procmask);
-	C2_UT_ASSERT(rc == 0);
-
-	/* request synchronous delivery */
-	C2_UT_ASSERT(d1tm1.ntm_bev_auto_deliver);
-	rc = c2_net_buffer_event_deliver_synchronously(&d1tm1);
-	C2_UT_ASSERT(!d1tm1.ntm_bev_auto_deliver);
-	C2_UT_ASSERT(rc == 0);
-
-	/* start tm and wait for tm to notify it has started */
-	c2_clink_init(&tmwait, NULL);
-	c2_clink_add(&d1tm1.ntm_chan, &tmwait);
-	C2_UT_ASSERT(!c2_net_tm_start(&d1tm1, "127.0.0.1:31111:1"));
-	c2_chan_wait(&tmwait);
-	c2_clink_del(&tmwait);
-	C2_UT_ASSERT(d1tm1.ntm_state == C2_NET_TM_STARTED);
-	if (d1tm1.ntm_state == C2_NET_TM_FAILED) {
-		/* skip rest of this test, else C2_ASSERT will occur */
-		c2_net_tm_fini(&d1tm1);
-		c2_net_domain_fini(&dom1);
-		C2_UT_FAIL("aborting test case, port 31111 in-use?");
-		return;
-	}
-
-	/* test synchronous buffer event delivery APIs */
-	brc = c2_net_buffer_event_pending(&d1tm1);
-	C2_UT_ASSERT(!brc);
-	c2_net_buffer_event_notify(&d1tm1, &d1tm1.ntm_chan);
-	brc = c2_net_buffer_event_pending(&d1tm1);
-	C2_UT_ASSERT(!brc);
-	c2_net_buffer_event_deliver_all(&d1tm1);
-
-	c2_clink_add(&d1tm1.ntm_chan, &tmwait);
-	C2_UT_ASSERT(!c2_net_tm_stop(&d1tm1, false));
-	c2_chan_wait(&tmwait);
-	c2_clink_del(&tmwait);
-	C2_UT_ASSERT(d1tm1.ntm_state == C2_NET_TM_STOPPED);
-	c2_net_tm_fini(&d1tm1);
+	C2_UT_ASSERT(!c2_net_end_point_put(ep2));
+	C2_UT_ASSERT(!c2_net_end_point_put(ep1));
 
 	c2_net_domain_fini(&dom1);
 }
 
-
 enum {
 	PING_CLIENT_SEGMENTS = 8,
-	PING_CLIENT_SEGMENT_SIZE = 8192,
+	PING_CLIENT_SEGMENT_SIZE = 512,
 	PING_SERVER_SEGMENTS = 4,
-	PING_SERVER_SEGMENT_SIZE = 16384,
-	PING_BUFFER_2PAGE_SIZE = 6144,
+	PING_SERVER_SEGMENT_SIZE = 1024,
 	PING_NR_BUFS = 20
 };
-#ifdef __KERNEL__
-/* want a size that tests 2 page buffers */
-C2_BASSERT(PING_BUFFER_2PAGE_SIZE > PAGE_CACHE_SIZE &&
-	   PING_BUFFER_2PAGE_SIZE < 2 * PAGE_CACHE_SIZE);
-#endif
-
 static int quiet_printf(const char *fmt, ...)
 {
 	return 0;
@@ -499,10 +215,7 @@ static struct ping_ops quiet_ops = {
 
 static void test_sunrpc_ping(void)
 {
-	/* some variables below are static to reduce kernel stack
-	   consumption. */
-
-	static struct ping_ctx cctx = {
+	struct ping_ctx cctx = {
 		.pc_ops = &quiet_ops,
 		.pc_xprt = &c2_net_bulk_sunrpc_xprt,
 		.pc_port = PING_PORT1,
@@ -515,7 +228,7 @@ static void test_sunrpc_ping(void)
 			.ntm_state     = C2_NET_TM_UNDEFINED
 		}
 	};
-	static struct ping_ctx sctx = {
+	struct ping_ctx sctx = {
 		.pc_ops = &quiet_ops,
 		.pc_xprt = &c2_net_bulk_sunrpc_xprt,
 		.pc_port = PING_PORT1,
@@ -558,28 +271,13 @@ static void test_sunrpc_ping(void)
 	C2_UT_ASSERT(ping_client_passive_recv(&cctx, server_ep) == 0);
 	C2_UT_ASSERT(ping_client_passive_send(&cctx, server_ep, NULL) == 0);
 
-	/* test sending/receiving a bigger payload.  PING_BUFFER_2PAGE_SIZE
-	   is picked for kernel UT to test passing a 2 page buffer.
-	 */
+	/* test sending/receiving a bigger payload */
 	data = c2_alloc(PING_CLIENT_SEGMENTS * PING_CLIENT_SEGMENT_SIZE);
 	C2_UT_ASSERT(data != NULL);
-	len = PING_BUFFER_2PAGE_SIZE;
-	for (i = 0; i < len; ++i)
-		data[i] = "abcdefghi"[i % 9];
-	data[i] = 0;
-	C2_UT_ASSERT(ping_client_msg_send_recv(&cctx, server_ep, data) == 0);
-	C2_UT_ASSERT(ping_client_passive_send(&cctx, server_ep, data) == 0);
-
-	/* test sending/receiving even larger payload */
 	len = (PING_CLIENT_SEGMENTS-1) * PING_CLIENT_SEGMENT_SIZE + 1;
 	for (i = 0; i < len; ++i)
 		data[i] = "abcdefghi"[i % 9];
-	data[i] = 0;
-	C2_UT_ASSERT(ping_client_msg_send_recv(&cctx, server_ep, data) == 0);
-	sctx.pc_passive_size = len;
-	C2_UT_ASSERT(ping_client_passive_recv(&cctx, server_ep) == 0);
 	C2_UT_ASSERT(ping_client_passive_send(&cctx, server_ep, data) == 0);
-	c2_free(data);
 
 	C2_UT_ASSERT(ping_client_fini(&cctx, server_ep) == 0);
 
@@ -595,21 +293,18 @@ static void test_sunrpc_ping(void)
 
 static void test_sunrpc_failure(void)
 {
-	/* some variables below are static to reduce kernel stack
-	   consumption. */
-
 	/* dom1 */
-	static struct c2_net_domain dom1 = {
+	struct c2_net_domain dom1 = {
 		.nd_xprt = NULL
 	};
-	static const struct c2_net_tm_callbacks tm_cbs1 = {
+	struct c2_net_tm_callbacks tm_cbs1 = {
 		.ntc_event_cb = sunrpc_tm_cb1
 	};
-	static struct c2_net_transfer_mc d1tm1 = {
+	struct c2_net_transfer_mc d1tm1 = {
 		.ntm_callbacks = &tm_cbs1,
 		.ntm_state = C2_NET_TM_UNDEFINED
 	};
-	static const struct c2_net_buffer_callbacks buf_cbs1 = {
+	struct c2_net_buffer_callbacks buf_cbs1 = {
 		.nbc_cb = {
 			[C2_NET_QT_MSG_RECV]          = sunrpc_buf_cb1,
 			[C2_NET_QT_MSG_SEND]          = sunrpc_buf_cb1,
@@ -619,26 +314,26 @@ static void test_sunrpc_failure(void)
 			[C2_NET_QT_ACTIVE_BULK_SEND]  = sunrpc_buf_cb1,
 		},
 	};
-	static struct c2_net_buffer d1nb1;
-	static struct c2_net_buffer d1nb2;
+	struct c2_net_buffer d1nb1;
+	struct c2_net_buffer d1nb2;
 	struct c2_clink tmwait1;
 
 	/* dom 2 */
-	static struct c2_net_domain dom2 = {
+ 	struct c2_net_domain dom2 = {
 		.nd_xprt = NULL
 	};
-	static const struct c2_net_tm_callbacks tm_cbs2 = {
+	struct c2_net_tm_callbacks tm_cbs2 = {
 		.ntc_event_cb = sunrpc_tm_cb2
 	};
-	static struct c2_net_transfer_mc d2tm1 = {
+	struct c2_net_transfer_mc d2tm1 = {
 		.ntm_callbacks = &tm_cbs2,
 		.ntm_state = C2_NET_TM_UNDEFINED
 	};
-	static struct c2_net_transfer_mc d2tm2 = {
+	struct c2_net_transfer_mc d2tm2 = {
 		.ntm_callbacks = &tm_cbs2,
 		.ntm_state = C2_NET_TM_UNDEFINED
 	};
-	static const struct c2_net_buffer_callbacks buf_cbs2 = {
+	struct c2_net_buffer_callbacks buf_cbs2 = {
 		.nbc_cb = {
 			[C2_NET_QT_MSG_RECV]          = sunrpc_buf_cb2,
 			[C2_NET_QT_MSG_SEND]          = sunrpc_buf_cb2,
@@ -648,24 +343,25 @@ static void test_sunrpc_failure(void)
 			[C2_NET_QT_ACTIVE_BULK_SEND]  = sunrpc_buf_cb2,
 		},
 	};
-	static struct c2_net_buffer d2nb1;
-	static struct c2_net_buffer d2nb2;
-	static c2_bcount_t d2nb2_len;
+	struct c2_net_buffer d2nb1;
+	struct c2_net_buffer d2nb2;
 	struct c2_clink tmwait2;
 
 	struct c2_net_end_point *ep;
-	static struct c2_net_qstats qs;
+	struct c2_net_qstats qs;
 
 	/* setup the first dom - use non-reserved port numbers */
 	C2_UT_ASSERT(!c2_net_domain_init(&dom1, &c2_net_bulk_sunrpc_xprt));
+	C2_UT_ASSERT(!c2_net_end_point_create(&ep, &dom1,"127.0.0.1:10000:1"));
+	C2_UT_ASSERT(strcmp(ep->nep_addr,"127.0.0.1:10000:1")==0);
 	C2_UT_ASSERT(!c2_net_tm_init(&d1tm1, &dom1));
 	c2_clink_init(&tmwait1, NULL);
 	c2_clink_add(&d1tm1.ntm_chan, &tmwait1);
-	C2_UT_ASSERT(!c2_net_tm_start(&d1tm1, "127.0.0.1:10000:1"));
+	C2_UT_ASSERT(!c2_net_tm_start(&d1tm1, ep));
+	C2_UT_ASSERT(!c2_net_end_point_put(ep));
 	c2_chan_wait(&tmwait1);
 	c2_clink_del(&tmwait1);
 	C2_UT_ASSERT(d1tm1.ntm_state == C2_NET_TM_STARTED);
-	C2_UT_ASSERT(strcmp(d1tm1.ntm_ep->nep_addr, "127.0.0.1:10000:1") == 0);
 	C2_SET0(&d1nb1);
 	C2_UT_ASSERT(!c2_bufvec_alloc(&d1nb1.nb_buffer, 4, 10000));
 	C2_UT_ASSERT(!c2_net_buffer_register(&d1nb1, &dom1));
@@ -683,20 +379,22 @@ static void test_sunrpc_failure(void)
 	d2nb1.nb_callbacks = &buf_cbs2;
 	C2_SET0(&d2nb2);
 	C2_UT_ASSERT(!c2_bufvec_alloc(&d2nb2.nb_buffer, 1, 10));
-	d2nb2_len = 1 * 10;
 	C2_UT_ASSERT(!c2_net_buffer_register(&d2nb2, &dom2));
 	d2nb2.nb_callbacks = &buf_cbs2;
 
-	/* TEST
+ 	/* TEST
 	   Start a TM in the second domain using a different port number.
 	   Bulksunrpc requires a single port number for all TMs, per process,
 	   regardless of domain.
 	*/
 	sunrpc_cbreset();
 	C2_UT_ASSERT(!c2_net_tm_init(&d2tm2, &dom2));
+	C2_UT_ASSERT(!c2_net_end_point_create(&ep, &dom2,"127.0.0.1:21000:3"));
+	C2_UT_ASSERT(strcmp(ep->nep_addr,"127.0.0.1:21000:3")==0);
 	c2_clink_init(&tmwait2, NULL);
 	c2_clink_add(&d2tm2.ntm_chan, &tmwait2);
-	C2_UT_ASSERT(!c2_net_tm_start(&d2tm2, "127.0.0.1:21000:3"));
+	C2_UT_ASSERT(!c2_net_tm_start(&d2tm2, ep));
+	C2_UT_ASSERT(!c2_net_end_point_put(ep));
 	c2_chan_wait(&tmwait2);
 	c2_clink_del(&tmwait2);
 	C2_UT_ASSERT(cb_status2 == -EADDRNOTAVAIL);
@@ -704,16 +402,18 @@ static void test_sunrpc_failure(void)
 
 	/* start a TM with id 3 in the second domain */
 	C2_UT_ASSERT(!c2_net_tm_init(&d2tm1, &dom2));
+	C2_UT_ASSERT(!c2_net_end_point_create(&ep, &dom2,"127.0.0.1:10000:3"));
+	C2_UT_ASSERT(strcmp(ep->nep_addr,"127.0.0.1:10000:3")==0);
 	c2_clink_init(&tmwait2, NULL);
 	c2_clink_add(&d2tm1.ntm_chan, &tmwait2);
-	C2_UT_ASSERT(!c2_net_tm_start(&d2tm1, "127.0.0.1:10000:3"));
+	C2_UT_ASSERT(!c2_net_tm_start(&d2tm1, ep));
+	C2_UT_ASSERT(!c2_net_end_point_put(ep));
 	c2_chan_wait(&tmwait2);
 	c2_clink_del(&tmwait2);
 	C2_UT_ASSERT(cb_status2 == 0);
 	C2_UT_ASSERT(d2tm1.ntm_state == C2_NET_TM_STARTED);
-	C2_UT_ASSERT(strcmp(d2tm1.ntm_ep->nep_addr, "127.0.0.1:10000:3") == 0);
 
-	/* TEST
+ 	/* TEST
 	   Start a second TM in the second domain, using the same port
 	   number and the same service id.
 	*/
@@ -721,27 +421,33 @@ static void test_sunrpc_failure(void)
 	c2_net_tm_fini(&d2tm2);
 	d2tm2.ntm_state = C2_NET_TM_UNDEFINED;
 	C2_UT_ASSERT(!c2_net_tm_init(&d2tm2, &dom2));
-	C2_UT_ASSERT(c2_net_tm_start(&d2tm2, "127.0.0.1:10000:3") ==
-		     -EADDRINUSE);
+	C2_UT_ASSERT(!c2_net_end_point_create(&ep, &dom2,"127.0.0.1:10000:3"));
+	C2_UT_ASSERT(strcmp(ep->nep_addr,"127.0.0.1:10000:3")==0);
+	C2_UT_ASSERT(c2_net_tm_start(&d2tm2, ep) == -EADDRINUSE);
+	C2_UT_ASSERT(!c2_net_end_point_put(ep));
 
-	/* TEST
-	   Start a second TM in the second domain, using same port and
-	   service id as TM in first domain.
+ 	/* TEST
+	   Start a second TM in the second domain, using a different port
+	   number.
+	   Bulksunrpc requires a single port number for all TMs, per process,
+	   regardless of domain.
 	*/
 	sunrpc_cbreset();
 	c2_net_tm_fini(&d2tm2);
 	d2tm2.ntm_state = C2_NET_TM_UNDEFINED;
 	C2_UT_ASSERT(!c2_net_tm_init(&d2tm2, &dom2));
-	C2_UT_ASSERT(c2_net_tm_start(&d2tm2, "127.0.0.1:10000:1") ==
-		     -EADDRINUSE);
+	C2_UT_ASSERT(!c2_net_end_point_create(&ep, &dom2,"127.0.0.1:10000:1"));
+	C2_UT_ASSERT(strcmp(ep->nep_addr,"127.0.0.1:10000:1")==0);
+	C2_UT_ASSERT(c2_net_tm_start(&d2tm2, ep) == -EADDRINUSE);
+	C2_UT_ASSERT(!c2_net_end_point_put(ep));
 
 	/* TEST
 	   Send a message from d1tm1 to d2tm2 - should fail because
 	   the destination TM not started.
 	*/
 	sunrpc_cbreset();
-	C2_UT_ASSERT(!c2_net_end_point_create(&ep, &d1tm1,"127.0.0.1:10000:4"));
-	C2_UT_ASSERT(strcmp(ep->nep_addr, "127.0.0.1:10000:4") == 0);
+	C2_UT_ASSERT(!c2_net_end_point_create(&ep, &dom1,"127.0.0.1:10000:4"));
+	C2_UT_ASSERT(strcmp(ep->nep_addr,"127.0.0.1:10000:4")==0);
 	d1nb1.nb_qtype = C2_NET_QT_MSG_SEND;
 	d1nb1.nb_ep = ep;
 	d1nb1.nb_length = 10; /* don't care */
@@ -761,11 +467,13 @@ static void test_sunrpc_failure(void)
 	C2_UT_ASSERT(!c2_net_tm_init(&d2tm2, &dom2));
 	c2_clink_init(&tmwait2, NULL);
 	c2_clink_add(&d2tm2.ntm_chan, &tmwait2);
-	C2_UT_ASSERT(!c2_net_tm_start(&d2tm2, "127.0.0.1:10000:4"));
+	C2_UT_ASSERT(!c2_net_end_point_create(&ep, &dom2,"127.0.0.1:10000:4"));
+	C2_UT_ASSERT(strcmp(ep->nep_addr,"127.0.0.1:10000:4")==0);
+	C2_UT_ASSERT(!c2_net_tm_start(&d2tm2, ep));
+	C2_UT_ASSERT(!c2_net_end_point_put(ep));
 	c2_chan_wait(&tmwait2);
 	c2_clink_del(&tmwait2);
-	C2_UT_ASSERT(d2tm2.ntm_state == C2_NET_TM_STARTED);
-	C2_UT_ASSERT(strcmp(d2tm2.ntm_ep->nep_addr, "127.0.0.1:10000:4") == 0);
+	C2_UT_ASSERT(d2tm1.ntm_state == C2_NET_TM_STARTED);
 
 	/* TEST
 	   Send a message from d1tm1 to d2tm1 - should fail because
@@ -779,8 +487,8 @@ static void test_sunrpc_failure(void)
 	c2_clink_add(&d2tm1.ntm_chan, &tmwait2);
 
 	C2_UT_ASSERT(!c2_net_tm_stats_get(&d1tm1,C2_NET_QT_MSG_SEND,&qs,true));
-	C2_UT_ASSERT(!c2_net_end_point_create(&ep, &d1tm1,"127.0.0.1:10000:3"));
-	C2_UT_ASSERT(strcmp(ep->nep_addr, "127.0.0.1:10000:3") == 0);
+	C2_UT_ASSERT(!c2_net_end_point_create(&ep, &dom1,"127.0.0.1:10000:3"));
+	C2_UT_ASSERT(strcmp(ep->nep_addr,"127.0.0.1:10000:3")==0);
 	d1nb1.nb_qtype = C2_NET_QT_MSG_SEND;
 	d1nb1.nb_ep = ep;
 	d1nb1.nb_length = 10; /* don't care */
@@ -819,15 +527,13 @@ static void test_sunrpc_failure(void)
 	C2_UT_ASSERT(!c2_net_tm_stats_get(&d2tm1,C2_NET_QT_MSG_RECV,&qs,true));
 	d2nb2.nb_qtype = C2_NET_QT_MSG_RECV;
 	d2nb2.nb_ep = NULL;
-	d2nb2.nb_min_receive_size = d2nb2_len;
-	d2nb2.nb_max_receive_msgs = 1;
 	c2_clink_init(&tmwait2, NULL);
 	c2_clink_add(&d2tm1.ntm_chan, &tmwait2);
 	C2_UT_ASSERT(!c2_net_buffer_add(&d2nb2, &d2tm1));
 
 	C2_UT_ASSERT(!c2_net_tm_stats_get(&d1tm1,C2_NET_QT_MSG_SEND,&qs,true));
-	C2_UT_ASSERT(!c2_net_end_point_create(&ep, &d1tm1,"127.0.0.1:10000:3"));
-	C2_UT_ASSERT(strcmp(ep->nep_addr, "127.0.0.1:10000:3") == 0);
+	C2_UT_ASSERT(!c2_net_end_point_create(&ep, &dom1,"127.0.0.1:10000:3"));
+	C2_UT_ASSERT(strcmp(ep->nep_addr,"127.0.0.1:10000:3")==0);
 	d1nb1.nb_qtype = C2_NET_QT_MSG_SEND;
 	d1nb1.nb_ep = ep;
 	d1nb1.nb_length = 40;
@@ -859,13 +565,63 @@ static void test_sunrpc_failure(void)
 
 	/* TEST
 	   Set up a passive receive buffer in one dom, and
+	   try to actively send from an unauthorized dom
+	*/
+	sunrpc_cbreset();
+	C2_UT_ASSERT(!c2_net_tm_stats_get(&d2tm1,C2_NET_QT_PASSIVE_BULK_RECV,
+					  &qs,true));
+	C2_UT_ASSERT(!c2_net_end_point_create(&ep, &dom2,"127.0.0.1:10000:9"));
+	C2_UT_ASSERT(strcmp(ep->nep_addr,"127.0.0.1:10000:9")==0);
+	d2nb1.nb_qtype = C2_NET_QT_PASSIVE_BULK_RECV;
+	d2nb1.nb_ep = ep;
+	c2_clink_init(&tmwait2, NULL);
+	c2_clink_add(&d2tm1.ntm_chan, &tmwait2);
+	C2_UT_ASSERT(!c2_net_buffer_add(&d2nb1, &d2tm1));
+	C2_UT_ASSERT(d2nb1.nb_desc.nbd_len != 0);
+	C2_UT_ASSERT(!c2_net_end_point_put(ep));
+
+	C2_UT_ASSERT(!c2_net_tm_stats_get(&d1tm1,C2_NET_QT_ACTIVE_BULK_SEND,
+					  &qs,true));
+	C2_UT_ASSERT(!c2_net_desc_copy(&d2nb1.nb_desc, &d1nb1.nb_desc));
+	d1nb1.nb_qtype = C2_NET_QT_ACTIVE_BULK_SEND;
+	d1nb1.nb_length = 10;
+	c2_clink_init(&tmwait1, NULL);
+	c2_clink_add(&d1tm1.ntm_chan, &tmwait1);
+	C2_UT_ASSERT(!c2_net_buffer_add(&d1nb1, &d1tm1));
+	c2_chan_wait(&tmwait1);
+	c2_clink_del(&tmwait1);
+	C2_UT_ASSERT(cb_qt1 == C2_NET_QT_ACTIVE_BULK_SEND);
+	C2_UT_ASSERT(cb_nb1 == &d1nb1);
+	C2_UT_ASSERT(cb_status1 == -EACCES);
+	C2_UT_ASSERT(!c2_net_tm_stats_get(&d1tm1,C2_NET_QT_ACTIVE_BULK_SEND,
+					  &qs,true));
+	C2_UT_ASSERT(qs.nqs_num_f_events == 1);
+	C2_UT_ASSERT(qs.nqs_num_s_events == 0);
+	C2_UT_ASSERT(qs.nqs_num_adds == 1);
+	C2_UT_ASSERT(qs.nqs_num_dels == 0);
+
+	c2_net_buffer_del(&d2nb1, &d2tm1);
+	c2_chan_wait(&tmwait2);
+	c2_clink_del(&tmwait2);
+	C2_UT_ASSERT(cb_qt2 == C2_NET_QT_PASSIVE_BULK_RECV);
+	C2_UT_ASSERT(cb_nb2 == &d2nb1);
+	C2_UT_ASSERT(cb_status2 == -ECANCELED);
+	C2_UT_ASSERT(!c2_net_tm_stats_get(&d2tm1,C2_NET_QT_PASSIVE_BULK_RECV,
+					  &qs,true));
+	C2_UT_ASSERT(qs.nqs_num_f_events == 1);
+	C2_UT_ASSERT(qs.nqs_num_s_events == 0);
+	C2_UT_ASSERT(qs.nqs_num_adds == 1);
+	C2_UT_ASSERT(qs.nqs_num_dels == 1);
+
+	/* TEST
+	   Set up a passive receive buffer in one dom, and
 	   try to actively receive from it.
 	*/
 	sunrpc_cbreset();
 	C2_UT_ASSERT(!c2_net_tm_stats_get(&d2tm1,C2_NET_QT_PASSIVE_BULK_RECV,
 					  &qs,true));
-	C2_UT_ASSERT(!c2_net_end_point_create(&ep, &d2tm1,"127.0.0.1:10000:1"));
-	C2_UT_ASSERT(strcmp(ep->nep_addr, "127.0.0.1:10000:1") == 0);
+	C2_UT_ASSERT(!c2_net_end_point_create(&ep, &dom2,"127.0.0.1:10000:1"));
+	C2_UT_ASSERT(strcmp(ep->nep_addr,"127.0.0.1:10000:1")==0);
 	d2nb1.nb_qtype = C2_NET_QT_PASSIVE_BULK_RECV;
 	d2nb1.nb_ep = ep;
 	c2_clink_init(&tmwait2, NULL);
@@ -893,7 +649,6 @@ static void test_sunrpc_failure(void)
 	C2_UT_ASSERT(qs.nqs_num_s_events == 0);
 	C2_UT_ASSERT(qs.nqs_num_adds == 1);
 	C2_UT_ASSERT(qs.nqs_num_dels == 0);
-	c2_net_desc_free(&d1nb1.nb_desc);
 
 	c2_net_buffer_del(&d2nb1, &d2tm1);
 	c2_chan_wait(&tmwait2);
@@ -907,7 +662,6 @@ static void test_sunrpc_failure(void)
 	C2_UT_ASSERT(qs.nqs_num_s_events == 0);
 	C2_UT_ASSERT(qs.nqs_num_adds == 1);
 	C2_UT_ASSERT(qs.nqs_num_dels == 1);
-	c2_net_desc_free(&d2nb1.nb_desc);
 
 	/* TEST
 	   Set up a passive receive buffer in one dom, and
@@ -916,8 +670,8 @@ static void test_sunrpc_failure(void)
 	sunrpc_cbreset();
 	C2_UT_ASSERT(!c2_net_tm_stats_get(&d2tm1,C2_NET_QT_PASSIVE_BULK_RECV,
 					  &qs,true));
-	C2_UT_ASSERT(!c2_net_end_point_create(&ep, &d2tm1,"127.0.0.1:10000:1"));
-	C2_UT_ASSERT(strcmp(ep->nep_addr, "127.0.0.1:10000:1") == 0);
+	C2_UT_ASSERT(!c2_net_end_point_create(&ep, &dom2,"127.0.0.1:10000:1"));
+	C2_UT_ASSERT(strcmp(ep->nep_addr,"127.0.0.1:10000:1")==0);
 	d2nb2.nb_qtype = C2_NET_QT_PASSIVE_BULK_RECV;
 	d2nb2.nb_ep = ep;
 	c2_clink_init(&tmwait2, NULL);
@@ -945,7 +699,6 @@ static void test_sunrpc_failure(void)
 	C2_UT_ASSERT(qs.nqs_num_s_events == 0);
 	C2_UT_ASSERT(qs.nqs_num_adds == 1);
 	C2_UT_ASSERT(qs.nqs_num_dels == 0);
-	c2_net_desc_free(&d1nb1.nb_desc);
 
 	c2_chan_wait(&tmwait2);
 	c2_clink_del(&tmwait2);
@@ -958,7 +711,6 @@ static void test_sunrpc_failure(void)
 	C2_UT_ASSERT(qs.nqs_num_s_events == 0);
 	C2_UT_ASSERT(qs.nqs_num_adds == 1);
 	C2_UT_ASSERT(qs.nqs_num_dels == 0);
-	c2_net_desc_free(&d2nb2.nb_desc);
 
 	/* TEST
 	   Setup a passive send buffer and add it. Save the descriptor in the
@@ -970,8 +722,8 @@ static void test_sunrpc_failure(void)
 	sunrpc_cbreset();
 	C2_UT_ASSERT(!c2_net_tm_stats_get(&d2tm1,C2_NET_QT_PASSIVE_BULK_RECV,
 					  &qs,true));
-	C2_UT_ASSERT(!c2_net_end_point_create(&ep, &d2tm1,"127.0.0.1:10000:1"));
-	C2_UT_ASSERT(strcmp(ep->nep_addr, "127.0.0.1:10000:1") == 0);
+	C2_UT_ASSERT(!c2_net_end_point_create(&ep, &dom2,"127.0.0.1:10000:1"));
+	C2_UT_ASSERT(strcmp(ep->nep_addr,"127.0.0.1:10000:1")==0);
 	d2nb1.nb_qtype = C2_NET_QT_PASSIVE_BULK_RECV;
 	d2nb1.nb_ep = ep;
 	c2_clink_init(&tmwait2, NULL);
@@ -990,7 +742,6 @@ static void test_sunrpc_failure(void)
 	C2_UT_ASSERT(cb_qt2 == C2_NET_QT_PASSIVE_BULK_RECV);
 	C2_UT_ASSERT(cb_nb2 == &d2nb1);
 	C2_UT_ASSERT(cb_status2 == -ECANCELED);
-	c2_net_desc_free(&d2nb1.nb_desc);
 
 	/* resubmit */
 	sunrpc_cbreset2();
@@ -1027,7 +778,6 @@ static void test_sunrpc_failure(void)
 	C2_UT_ASSERT(qs.nqs_num_s_events == 0);
 	C2_UT_ASSERT(qs.nqs_num_adds == 1);
 	C2_UT_ASSERT(qs.nqs_num_dels == 0);
-	c2_net_desc_free(&d1nb1.nb_desc);
 
 	c2_net_buffer_del(&d2nb1, &d2tm1);
 	c2_chan_wait(&tmwait2);
@@ -1041,46 +791,12 @@ static void test_sunrpc_failure(void)
 	C2_UT_ASSERT(qs.nqs_num_s_events == 0);
 	C2_UT_ASSERT(qs.nqs_num_adds == 2);
 	C2_UT_ASSERT(qs.nqs_num_dels == 2);
-	c2_net_desc_free(&d2nb1.nb_desc);
-
-	/* Set up a message recv with a timeout, and set the skulker period
-	   to reasonably small value so that it times out fast. Check the
-	   error code.
-	 */
-	sunrpc_cbreset2();
-	C2_UT_ASSERT(c2_net_bulk_sunrpc_dom_get_skulker_period(&dom2) ==
-		     C2_NET_BULK_SUNRPC_SKULKER_PERIOD_S);
-	c2_net_bulk_sunrpc_dom_set_skulker_period(&dom2, 1);
-	C2_UT_ASSERT(!c2_net_tm_stats_get(&d2tm1,C2_NET_QT_MSG_RECV,&qs,true));
-	c2_clink_init(&tmwait2, NULL);
-	c2_clink_add(&d2tm1.ntm_chan, &tmwait2);
-	d2nb2.nb_qtype = C2_NET_QT_MSG_RECV;
-	d2nb2.nb_ep = NULL;
-	d2nb2.nb_min_receive_size = d2nb2_len;
-	d2nb2.nb_max_receive_msgs = 1;
-	d2nb2.nb_timeout = ut_timeout_after_secs(1);
-	C2_UT_ASSERT(!c2_net_buffer_add(&d2nb2, &d2tm1));
-	c2_chan_wait(&tmwait2);
-	c2_clink_del(&tmwait2);
-	C2_UT_ASSERT(!c2_net_tm_stats_get(&d2tm1,C2_NET_QT_MSG_RECV,&qs,true));
-	C2_UT_ASSERT(qs.nqs_num_f_events == 1);
-	C2_UT_ASSERT(qs.nqs_num_s_events == 0);
-	C2_UT_ASSERT(qs.nqs_num_adds == 1);
-	C2_UT_ASSERT(qs.nqs_num_dels == 0);
-	C2_UT_ASSERT(cb_nb2 == &d2nb2);
-	C2_UT_ASSERT(cb_qt2 == C2_NET_QT_MSG_RECV);
-	C2_UT_ASSERT(cb_tms2 == C2_NET_TM_UNDEFINED);
-	C2_UT_ASSERT(cb_status2 == -ETIMEDOUT);
 
 	/* fini */
-	c2_net_buffer_deregister(&d1nb1, &dom1);
-	c2_bufvec_free(&d1nb1.nb_buffer);
-	c2_net_buffer_deregister(&d1nb2, &dom1);
-	c2_bufvec_free(&d1nb2.nb_buffer);
-	c2_net_buffer_deregister(&d2nb1, &dom2);
-	c2_bufvec_free(&d2nb1.nb_buffer);
-	c2_net_buffer_deregister(&d2nb2, &dom2);
-	c2_bufvec_free(&d2nb2.nb_buffer);
+	C2_UT_ASSERT(!c2_net_buffer_deregister(&d1nb1, &dom1));
+	C2_UT_ASSERT(!c2_net_buffer_deregister(&d1nb2, &dom1));
+	C2_UT_ASSERT(!c2_net_buffer_deregister(&d2nb1, &dom2));
+	C2_UT_ASSERT(!c2_net_buffer_deregister(&d2nb2, &dom2));
 
 	c2_clink_init(&tmwait1, NULL);
 	c2_clink_add(&d1tm1.ntm_chan, &tmwait1);
@@ -1115,10 +831,10 @@ static void test_sunrpc_failure(void)
 
 static void test_sunrpc_tm(void)
 {
-	static struct c2_net_domain dom1 = {
+	struct c2_net_domain dom1 = {
 		.nd_xprt = NULL
 	};
-	const struct c2_net_tm_callbacks cbs1 = {
+	struct c2_net_tm_callbacks cbs1 = {
 		.ntc_event_cb = LAMBDA(void,(const struct c2_net_tm_event *ev) {
 				       }),
 	};
@@ -1159,21 +875,19 @@ static void test_sunrpc_tm(void)
 	c2_net_domain_fini(&dom1);
 }
 
-const struct c2_test_suite c2_net_bulk_sunrpc_ut = {
-	.ts_name = "net-bulk-sunrpc",
-	.ts_init = NULL,
-	.ts_fini = NULL,
-	.ts_tests = {
-		{ "net_bulk_sunrpc_tm_test",    test_sunrpc_tm },
-		{ "net_bulk_sunrpc_ep",         test_sunrpc_ep },
-		{ "net_bulk_sunrpc_desc",       test_sunrpc_desc },
-		{ "net_bulk_sunrpc_processor_affinity",  test_sunrpc_pa },
-		{ "net_bulk_sunrpc_failure",    test_sunrpc_failure },
-		{ "net_bulk_sunrpc_ping_tests", test_sunrpc_ping },
-		{ NULL, NULL }
-	}
+const struct c2_test_suite net_bulk_sunrpc_ut = {
+        .ts_name = "net-bulk-sunrpc",
+        .ts_init = NULL,
+        .ts_fini = NULL,
+        .ts_tests = {
+                { "net_bulk_sunrpc_ep",         test_sunrpc_ep },
+                { "net_bulk_sunrpc_desc",       test_sunrpc_desc },
+                { "net_bulk_sunrpc_failure",    test_sunrpc_failure },
+		{ "net_bulk_sunrpc_tm_test",    test_sunrpc_tm},
+                { "net_bulk_sunrpc_ping_tests", test_sunrpc_ping },
+                { NULL, NULL }
+        }
 };
-C2_EXPORTED(c2_net_bulk_sunrpc_ut);
 
 /*
  *  Local variables:
diff --git a/net/bulk_emulation/ut/ksunrpc_ut.c b/net/bulk_emulation/ut/ksunrpc_ut.c
deleted file mode 100644
index cf768fe..0000000
--- a/net/bulk_emulation/ut/ksunrpc_ut.c
+++ /dev/null
@@ -1,391 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Dave Cohrs <Dave_Cohrs@us.xyratex.com>
- * Original creation date: 06/14/2011
- */
-
-#include "lib/memory.h"
-#include "lib/misc.h"
-#include "lib/ut.h"
-#include "net/bulk_emulation/sunrpc_xprt.h"
-#include "net/ksunrpc/ksunrpc.h"
-#include "fop/fop.h"
-
-#include <linux/highmem.h> /* kmap, kunmap */
-#include <linux/pagemap.h> /* PAGE_CACHE_SIZE */
-
-enum {
-	NUM = 100,
-	IPADDR = 0x7f000001,	/* 127.0.0.1 */
-	PORT = 10001,
-	FAKEPORT = 10701,
-	S_EPID = 42,
-	C_EPID = 24
-};
-
-static int sunrpc_ut_get_handler(struct c2_fop *fop, struct c2_fop_ctx *ctx);
-static int sunrpc_ut_put_handler(struct c2_fop *fop, struct c2_fop_ctx *ctx);
-
-static struct c2_fop_type_ops sunrpc_get_ops = {
-	.fto_execute = sunrpc_ut_get_handler,
-};
-
-static struct c2_fop_type_ops sunrpc_put_ops = {
-	.fto_execute = sunrpc_ut_put_handler,
-};
-
-static struct c2_net_domain dom;
-
-extern struct c2_fop_type sunrpc_get_fopt; /* opcode = 31 */
-extern struct c2_fop_type sunrpc_put_fopt; /* opcode = 32 */
-
-extern struct c2_fop_type sunrpc_get_resp_fopt; /* opcode = 36 */
-extern struct c2_fop_type sunrpc_put_resp_fopt; /* opcode = 37 */
-
-static struct c2_fop_type *s_fops[] = {
-	&sunrpc_get_fopt,
-	&sunrpc_put_fopt,
-};
-
-static char *get_put_buf;
-
-static int sunrpc_ut_get_handler(struct c2_fop *fop, struct c2_fop_ctx *ctx)
-{
-	struct sunrpc_get         *in = c2_fop_data(fop);
-	struct sunrpc_get_resp    *ex;
-	struct c2_fop             *reply;
-	c2_bcount_t                i;
-	int                        rc;
-	struct c2_bufvec           inbuf =
-		C2_BUFVEC_INIT_BUF((void **)&get_put_buf, &i);
-	struct c2_bufvec_cursor    incur;
-
-	reply = c2_fop_alloc(&sunrpc_get_resp_fopt, NULL);
-	C2_UT_ASSERT(reply != NULL);
-	ex = c2_fop_data(reply);
-	i = in->sg_desc.sbd_id;
-
-	C2_UT_ASSERT(in->sg_offset == 0);
-	C2_UT_ASSERT(in->sg_desc.sbd_passive_ep.sep_addr == IPADDR);
-	C2_UT_ASSERT(in->sg_desc.sbd_passive_ep.sep_port == FAKEPORT);
-	C2_UT_ASSERT(in->sg_desc.sbd_passive_ep.sep_id == C_EPID);
-	C2_UT_ASSERT(in->sg_desc.sbd_qtype == C2_NET_QT_ACTIVE_BULK_SEND);
-	C2_UT_ASSERT(in->sg_desc.sbd_total == i);
-
-	ex->sgr_rc = i + 1;
-	ex->sgr_eof = 1;
-	c2_bufvec_cursor_init(&incur, &inbuf);
-	rc = sunrpc_buffer_init(&ex->sgr_buf, &incur, i);
-	C2_UT_ASSERT(rc == 0);
-	C2_UT_ASSERT(ex->sgr_buf.sb_buf != NULL);
-	C2_UT_ASSERT(ex->sgr_buf.sb_len == i);
-
-	c2_net_reply_post(ctx->ft_service, reply, ctx->fc_cookie);
-	return 0;
-}
-
-static int sunrpc_ut_put_handler(struct c2_fop *fop, struct c2_fop_ctx *ctx)
-{
-	struct sunrpc_put         *in = c2_fop_data(fop);
-	struct sunrpc_put_resp    *ex;
-	struct c2_fop             *reply;
-	int                        i;
-	const char                *buf;
-
-	reply = c2_fop_alloc(&sunrpc_put_resp_fopt, NULL);
-	C2_UT_ASSERT(reply != NULL);
-	ex = c2_fop_data(reply);
-	i = in->sp_desc.sbd_id;
-
-	C2_UT_ASSERT(in->sp_offset == 0);
-	C2_UT_ASSERT(in->sp_desc.sbd_passive_ep.sep_addr == IPADDR);
-	C2_UT_ASSERT(in->sp_desc.sbd_passive_ep.sep_port == FAKEPORT);
-	C2_UT_ASSERT(in->sp_desc.sbd_passive_ep.sep_id == C_EPID);
-	C2_UT_ASSERT(in->sp_desc.sbd_qtype == C2_NET_QT_ACTIVE_BULK_RECV);
-	C2_UT_ASSERT(in->sp_desc.sbd_total == i);
-	C2_UT_ASSERT(in->sp_buf.sb_len == i);
-
-	buf = kmap(in->sp_buf.sb_buf[0]);
-	buf += in->sp_buf.sb_pgoff;
-	C2_UT_ASSERT(memcmp(buf, get_put_buf, i) == 0);
-	kunmap(in->sp_buf.sb_buf[0]);
-
-	ex->spr_rc = i + 1;
-	c2_net_reply_post(ctx->ft_service, reply, ctx->fc_cookie);
-	return 0;
-}
-
-static int ksunrpc_service_handler(struct c2_service *service,
-				   struct c2_fop *fop,
-				   void *cookie)
-{
-        struct c2_fop_ctx ctx;
-
-        ctx.ft_service = service;
-        ctx.fc_cookie  = cookie;
-        return fop->f_type->ft_ops->fto_execute(fop, &ctx);
-}
-
-int get_call(struct c2_net_conn *conn, int i)
-{
-	int                      rc;
-	char                    *buf;
-	struct c2_fop           *f;
-	struct c2_fop           *r;
-	struct sunrpc_get       *fop;
-	struct sunrpc_get_resp  *rep;
-	struct sunrpc_buf_desc   fake_desc = {
-		.sbd_id = i,
-		.sbd_passive_ep.sep_addr = IPADDR,
-		.sbd_passive_ep.sep_port = FAKEPORT,
-		.sbd_passive_ep.sep_id = C_EPID,
-		.sbd_qtype = C2_NET_QT_ACTIVE_BULK_SEND,
-		.sbd_total = i
-	};
-
-	C2_UT_ASSERT(conn != NULL);
-	C2_UT_ASSERT(i >= 0);
-	f = c2_fop_alloc(&sunrpc_get_fopt, NULL);
-	r = c2_fop_alloc(&sunrpc_get_resp_fopt, NULL);
-	if (f == NULL || r == NULL) {
-		rc = -ENOMEM;
-		goto done;
-	}
-	fop = c2_fop_data(f);
-
-	fop->sg_desc = fake_desc;
-	fop->sg_offset = 0;
-
-	/* kxdr requires that caller pre-allocate buffers for sequences.
-	   This assumes client knows the max required.  When call returns,
-	   the actual length returned will be updated.
-	 */
-	rep = c2_fop_data(r);
-	rc = sunrpc_buffer_init(&rep->sgr_buf, NULL, i);
-	C2_UT_ASSERT(rc == 0);
-	{
-		struct c2_net_call call = {
-			.ac_arg = f,
-			.ac_ret = r
-		};
-
-		rc = c2_net_cli_call(conn, &call);
-		C2_UT_ASSERT(rc == 0);
-	}
-
-	C2_UT_ASSERT(c2_fop_data(r) == rep);
-	C2_UT_ASSERT(rep->sgr_rc == i + 1);
-	C2_UT_ASSERT(rep->sgr_eof == 1);
-	C2_UT_ASSERT(rep->sgr_buf.sb_len == i);
-	buf = kmap(rep->sgr_buf.sb_buf[0]);
-	C2_UT_ASSERT(memcmp(buf, get_put_buf, i) == 0);
-	kunmap(rep->sgr_buf.sb_buf[0]);
-	sunrpc_buffer_fini(&rep->sgr_buf);
-
-done:
-	if (r != NULL)
-		c2_fop_free(r);
-	if (f != NULL)
-		c2_fop_free(f);
-	return rc;
-}
-
-int put_call(struct c2_net_conn *conn, int i)
-{
-	int                      rc;
-	struct c2_fop           *f;
-	struct c2_fop           *r;
-	struct sunrpc_put       *fop;
-	struct sunrpc_put_resp  *rep;
-	struct sunrpc_buf_desc   fake_desc = {
-		.sbd_id = i,
-		.sbd_passive_ep.sep_addr = IPADDR,
-		.sbd_passive_ep.sep_port = FAKEPORT,
-		.sbd_passive_ep.sep_id = C_EPID,
-		.sbd_qtype = C2_NET_QT_ACTIVE_BULK_RECV,
-		.sbd_total = i
-	};
-	c2_bcount_t              inlen = i;
-	struct c2_bufvec         inbuf =
-		C2_BUFVEC_INIT_BUF((void **)&get_put_buf, &inlen);
-	struct c2_bufvec_cursor  incur;
-
-	C2_UT_ASSERT(conn != NULL);
-	C2_UT_ASSERT(i >= 0);
-	f = c2_fop_alloc(&sunrpc_put_fopt, NULL);
-	r = c2_fop_alloc(&sunrpc_put_resp_fopt, NULL);
-	if (f == NULL || r == NULL) {
-		rc = -ENOMEM;
-		goto done;
-	}
-	fop = c2_fop_data(f);
-
-	fop->sp_desc = fake_desc;
-	{
-		struct c2_net_call call = {
-			.ac_arg = f,
-			.ac_ret = r
-		};
-		fop->sp_offset = 0;
-		c2_bufvec_cursor_init(&incur, &inbuf);
-		rc = sunrpc_buffer_init(&fop->sp_buf, &incur, inlen);
-		C2_UT_ASSERT(rc == 0);
-		rc = c2_net_cli_call(conn, &call);
-		if (rc == 0) {
-			rep = c2_fop_data(r);
-			C2_UT_ASSERT(rep->spr_rc == i + 1);
-		}
-		C2_UT_ASSERT(rc == 0);
-		sunrpc_buffer_fini(&fop->sp_buf);
-	}
-
-done:
-	if (r != NULL)
-		c2_fop_free(r);
-	if (f != NULL)
-		c2_fop_free(f);
-	return rc;
-}
-
-void test_ksunrpc_buffer(void)
-{
-	char *buf;
-	char *bp;
-	c2_bcount_t len = PAGE_CACHE_SIZE * NUM;
-	int i;
-	struct sunrpc_buffer sb;
-	struct c2_bufvec inbuf = C2_BUFVEC_INIT_BUF((void **)&buf, &len);
-	struct c2_bufvec_cursor incur;
-	struct c2_bufvec outbuf = C2_BUFVEC_INIT_BUF((void **)&bp, &len);
-	struct c2_bufvec_cursor outcur;
-	int rc;
-
-	buf = c2_alloc(len);
-	C2_UT_ASSERT(buf != NULL);
-	for (i = 0; i < NUM; ++i)
-		buf[i * PAGE_CACHE_SIZE] = i;
-
-	c2_bufvec_cursor_init(&incur, &inbuf);
-	rc = sunrpc_buffer_init(&sb, &incur, len);
-	C2_UT_ASSERT(rc == 0);
-	for (i = 0; i < NUM; ++i) {
-		C2_UT_ASSERT(page_count(sb.sb_buf[i]) == 1);
-		bp = kmap(sb.sb_buf[i]);
-		C2_UT_ASSERT(*bp == buf[i * PAGE_CACHE_SIZE]);
-		kunmap(sb.sb_buf[i]);
-	}
-	bp = c2_alloc(len);
-	c2_bufvec_cursor_init(&outcur, &outbuf);
-	rc = sunrpc_buffer_copy_out(&outcur, &sb);
-	C2_UT_ASSERT(rc == 0);
-	C2_UT_ASSERT(memcmp(buf, bp, len) == 0);
-	sunrpc_buffer_fini(&sb);
-	c2_free(buf);
-	c2_free(bp);
-}
-
-void test_ksunrpc_server(void)
-{
-	int rc;
-	int i;
-
-	struct c2_service_id sid1 = { .si_uuid = "node-1" };
-	struct c2_net_conn *conn1;
-	struct c2_service s1;
-	c2_time_t t;
-
-	/* NB: fops used are parsed when knet2 module is loaded,
-	   override the ops vector for UT.
-	 */
-	C2_UT_ASSERT(sunrpc_get_fopt.ft_top != NULL);
-	C2_UT_ASSERT(sunrpc_put_fopt.ft_top != NULL);
-	sunrpc_get_fopt.ft_ops = &sunrpc_get_ops;
-	sunrpc_put_fopt.ft_ops = &sunrpc_put_ops;
-
-	C2_SET0(&s1);
-	s1.s_table.not_start = s_fops[0]->ft_rpc_item_type.rit_opcode;
-	s1.s_table.not_nr    = ARRAY_SIZE(s_fops);
-	s1.s_table.not_fopt  = s_fops;
-	s1.s_handler         = &ksunrpc_service_handler;
-
-	rc = c2_net_xprt_init(&c2_net_ksunrpc_minimal_xprt);
-	C2_UT_ASSERT(rc == 0);
-
-	rc = c2_net_domain_init(&dom, &c2_net_ksunrpc_minimal_xprt);
-	C2_UT_ASSERT(rc == 0);
-
-	rc = c2_service_id_init(&sid1, &dom, "127.0.0.1", PORT);
-	C2_UT_ASSERT(rc == 0);
-
-	rc = c2_service_start(&s1, &sid1);
-	C2_UT_ASSERT(rc >= 0);
-
-	c2_nanosleep(c2_time_set(&t, 1, 0), NULL);
-
-	rc = c2_net_conn_create(&sid1);
-	C2_UT_ASSERT(rc == 0);
-
-	conn1 = c2_net_conn_find(&sid1);
-	C2_UT_ASSERT(conn1 != NULL);
-
-	get_put_buf = c2_alloc(NUM + 1);
-	C2_UT_ASSERT(get_put_buf != NULL);
-	for (i = 0; i < NUM; ++i)
-		get_put_buf[i] = i+1;
-
-	/* call get API, tests receiving basic record and sequence */
-	for (i = 0; i <= NUM; ++i) {
-		rc = get_call(conn1, i);
-		C2_UT_ASSERT(rc == 0);
-	}
-
-	/* call put API, tests sending basic record and sequence */
-	for (i = 0; i <= NUM; ++i) {
-		rc = put_call(conn1, i);
-		C2_UT_ASSERT(rc == 0);
-	}
-
-	c2_free(get_put_buf);
-	c2_net_conn_unlink(conn1);
-	c2_net_conn_release(conn1);
-	c2_service_stop(&s1);
-	c2_service_id_fini(&sid1);
-	c2_net_domain_fini(&dom);
-	c2_net_xprt_fini(&c2_net_ksunrpc_minimal_xprt);
-}
-
-const struct c2_test_suite c2_net_ksunrpc_ut = {
-        .ts_name = "ksunrpc-ut",
-        .ts_init = NULL,
-        .ts_fini = NULL,
-        .ts_tests = {
-                { "ksunrpc_buffer", test_ksunrpc_buffer },
-                { "ksunrpc_server", test_ksunrpc_server },
-                { NULL, NULL }
-        }
-};
-C2_EXPORTED(c2_net_ksunrpc_ut);
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
diff --git a/net/bulk_mem.h b/net/bulk_mem.h
index f3483df..4c05a20 100644
--- a/net/bulk_mem.h
+++ b/net/bulk_mem.h
@@ -14,8 +14,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Carl Braganza <Carl_Braganza@us.xyratex.com>,
- *                  Dave Cohrs <Dave_Cohrs@us.xyratex.com>
+ * Original author: Carl Braganza, Dave Cohrs
  * Original creation date: 04/12/2011
  */
 #ifndef __COLIBRI_NET_BULK_MEM_H__
@@ -25,9 +24,8 @@
 
 /**
    @defgroup bulkmem In-Memory Messaging and Bulk Transfer Emulation Transport
-   @ingroup net
 
-   This module provides a network transport with messaging and bulk
+   @brief This module provides a network transport with messaging and bulk
    data transfer across domains within a single process.
 
    An end point address is a string with two tuples separated by a colon (:).
diff --git a/net/bulk_sunrpc.h b/net/bulk_sunrpc.h
index 62a3175..820cdc0 100644
--- a/net/bulk_sunrpc.h
+++ b/net/bulk_sunrpc.h
@@ -14,8 +14,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Carl Braganza <Carl_Braganza@us.xyratex.com>,
- *                  Dave Cohrs <Dave_Cohrs@us.xyratex.com>
+ * Original author: Carl Braganza, Dave Cohrs
  * Original creation date: 04/12/2011
  */
 
@@ -25,10 +24,9 @@
 #include "net/net.h"
 
 /**
-   @defgroup bulksunrpc Sunrpc Messaging and Bulk Transfer Emulation Transport
-   @ingroup net
+@defgroup bulksunrpc Sunrpc Messaging and Bulk Transfer Emulation Transport
 
-   This module provides a network transport with messaging and bulk
+   @brief This module provides a network transport with messaging and bulk
    transfer capabilites implemented over the legacy and now deprecated
    Sunrpc transport.  The bulk transfer support does not provide 0 copy
    semantics. 3-tuple addressing of (host, port, service-id) is used for
@@ -36,8 +34,6 @@
    the same process must use the same host and port, regardless of how many
    bulksunrpc domains are created.
 
-   The transport will fake support for synchronous network buffer delivery.
-
    @{
 **/
 
@@ -65,48 +61,6 @@ size_t c2_net_bulk_sunrpc_tm_get_num_threads(const struct c2_net_transfer_mc
 					     *tm);
 
 /**
-   Obtain the period of the skulker thread clock.
-   @retval secs Period in seconds.
- */
-uint64_t
-c2_net_bulk_sunrpc_dom_get_skulker_period(struct c2_net_domain *dom);
-
-/**
-   Control the period of the skulker thread clock.  This thread is used
-   to handle end point aging and buffer timeouts.
-   @param dom The domain pointer.
-   @param secs The clock period in seconds. Must be greater than 0.
- */
-void
-c2_net_bulk_sunrpc_dom_set_skulker_period(struct c2_net_domain *dom,
-					  uint64_t secs);
-
-/**
-   Control how long unused end points are cached before release.
-
-   The delay allows potential reuse of the underlying network connection at a
-   later time.  This avoids exhaustion of the local dynamic port space,
-   as a port normally goes into TIMED_WAIT when the socket closes and won't
-   be made available for reuse until much later.  It also has the added
-   benefit of reducing the number of TCP connections established.
-
-   @param dom The domain pointer.
-   @param secs The duration of the delay in seconds.  Specify 0 for no
-   delay.  The default is to delay.
- */
-void
-c2_net_bulk_sunrpc_dom_set_end_point_release_delay(struct c2_net_domain *dom,
-						   uint64_t secs);
-
-/**
-   Return the end point release delay value.
-   @param dom The domain pointer.
-   @retval secs Returns the seconds of delay, or 0 if delay is disabled.
-*/
-uint64_t
-c2_net_bulk_sunrpc_dom_get_end_point_release_delay(struct c2_net_domain *dom);
-
-/**
    @}
 */
 
diff --git a/net/connection.c b/net/connection.c
index 81a2ca2..0efeb7e 100644
--- a/net/connection.c
+++ b/net/connection.c
@@ -14,7 +14,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Nikita Danilov <Nikita_Danilov@xyratex.com>
+ * Original author: Nikita Danilov
  * Original creation date: 05/17/2010
  */
 
@@ -88,6 +88,7 @@ int c2_net_conn_create(struct c2_service_id *nid)
 	}
 	return result;
 }
+C2_EXPORTED(c2_net_conn_create);
 
 struct c2_net_conn *c2_net_conn_find(const struct c2_service_id *nid)
 {
@@ -111,11 +112,13 @@ struct c2_net_conn *c2_net_conn_find(const struct c2_service_id *nid)
 
 	return found ? conn : NULL;
 }
+C2_EXPORTED(c2_net_conn_find);
 
 void c2_net_conn_release(struct c2_net_conn *conn)
 {
 	c2_ref_put(&conn->nc_refs);
 }
+C2_EXPORTED(c2_net_conn_release);
 
 void c2_net_conn_unlink(struct c2_net_conn *conn)
 {
@@ -134,6 +137,7 @@ void c2_net_conn_unlink(struct c2_net_conn *conn)
 	if (need_put)
 		c2_ref_put(&conn->nc_refs);
 }
+C2_EXPORTED(c2_net_conn_unlink);
 
 /* @} */
 
diff --git a/net/domain.c b/net/domain.c
index f6f4edc..55eb840 100644
--- a/net/domain.c
+++ b/net/domain.c
@@ -14,7 +14,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Nikita Danilov <Nikita_Danilov@xyratex.com>
+ * Original author: Nikita Danilov
  * Original creation date: 05/17/2010
  */
 
@@ -63,6 +63,7 @@ int c2_net__domain_init(struct c2_net_domain *dom, struct c2_net_xprt *xprt)
 	/* end deprecated */
 
 	c2_mutex_init(&dom->nd_mutex);
+	c2_list_init(&dom->nd_end_points);
 	c2_list_init(&dom->nd_registered_bufs);
 	c2_list_init(&dom->nd_tms);
 
@@ -77,12 +78,14 @@ int c2_net__domain_init(struct c2_net_domain *dom, struct c2_net_xprt *xprt)
 	}
 	return rc;
 }
+C2_EXPORTED(c2_net__domain_init);
 
 void c2_net__domain_fini(struct c2_net_domain *dom)
 {
 	C2_PRE(c2_mutex_is_locked(&c2_net_mutex));
 	C2_ASSERT(c2_list_is_empty(&dom->nd_tms));
 	C2_ASSERT(c2_list_is_empty(&dom->nd_registered_bufs));
+	C2_ASSERT(c2_list_is_empty(&dom->nd_end_points));
 
 	if (dom->nd_xprt != NULL) {
 		dom->nd_xprt->nx_ops->xo_dom_fini(dom);
@@ -93,6 +96,7 @@ void c2_net__domain_fini(struct c2_net_domain *dom)
 
 	c2_list_fini(&dom->nd_tms);
 	c2_list_fini(&dom->nd_registered_bufs);
+	c2_list_fini(&dom->nd_end_points);
 
 	c2_mutex_fini(&dom->nd_mutex);
 
@@ -103,6 +107,7 @@ void c2_net__domain_fini(struct c2_net_domain *dom)
 	c2_list_fini(&dom->nd_conn);
 	/* end deprecated */
 }
+C2_EXPORTED(c2_net__domain_fini);
 
 #define DOM_GET_PARAM(Fn, Type)				\
 Type c2_net_domain_get_##Fn(struct c2_net_domain *dom)	\
@@ -114,7 +119,8 @@ Type c2_net_domain_get_##Fn(struct c2_net_domain *dom)	\
 	rc = dom->nd_xprt->nx_ops->xo_get_##Fn(dom);	\
 	c2_mutex_unlock(&dom->nd_mutex);		\
 	return rc;					\
-}
+}							\
+C2_EXPORTED(c2_net_domain_get_##Fn)
 
 DOM_GET_PARAM(max_buffer_size, c2_bcount_t);
 DOM_GET_PARAM(max_buffer_segment_size, c2_bcount_t);
diff --git a/net/ep.c b/net/ep.c
index 3f55a9b..24e0935 100644
--- a/net/ep.c
+++ b/net/ep.c
@@ -14,7 +14,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Carl Braganza <Carl_Braganza@us.xyratex.com>
+ * Original author: Carl Braganza
  * Original creation date: 04/04/2011
  */
 
@@ -27,9 +27,9 @@
  @{
 */
 
-bool c2_net__ep_invariant(struct c2_net_end_point   *ep,
-			  struct c2_net_transfer_mc *tm,
-			  bool                       under_tm_mutex)
+bool c2_net__ep_invariant(struct c2_net_end_point *ep,
+			  struct c2_net_domain    *dom,
+			  bool                     under_dom_mutex)
 {
 	if (ep == NULL)
 		return false;
@@ -37,41 +37,38 @@ bool c2_net__ep_invariant(struct c2_net_end_point   *ep,
 		return false;
 	if (ep->nep_ref.release == NULL)
 		return false;
-	if (ep->nep_tm != tm)
+	if (ep->nep_dom != dom)
 		return false;
 	if (ep->nep_addr == NULL)
 		return false;
-	if (under_tm_mutex &&
-	    !c2_list_contains(&tm->ntm_end_points, &ep->nep_tm_linkage))
+	if (under_dom_mutex &&
+	    !c2_list_contains(&dom->nd_end_points, &ep->nep_dom_linkage))
 		return false;
 	return true;
 }
 
-int c2_net_end_point_create(struct c2_net_end_point  **epp,
-			    struct c2_net_transfer_mc *tm,
-			    const char                *addr)
+int c2_net_end_point_create(struct c2_net_end_point **epp,
+			    struct c2_net_domain     *dom,
+			    const char               *addr)
 {
 	int rc;
-	struct c2_net_domain *dom;
 
-	C2_PRE(tm != NULL && tm->ntm_state == C2_NET_TM_STARTED);
+	C2_PRE(dom != NULL);
 	C2_PRE(epp != NULL);
 
-	dom = tm->ntm_dom;
 	C2_PRE(dom->nd_xprt != NULL);
-
-	c2_mutex_lock(&tm->ntm_mutex);
+	c2_mutex_lock(&dom->nd_mutex);
 
 	*epp = NULL;
 
-	rc = dom->nd_xprt->nx_ops->xo_end_point_create(epp, tm, addr);
+	rc = dom->nd_xprt->nx_ops->xo_end_point_create(epp, dom, addr);
 
 	/* either we failed or we got back a properly initialized end point
 	   with reference count of at least 1
 	*/
-	C2_POST(ergo(rc == 0, c2_net__ep_invariant(*epp, tm, true)));
+	C2_POST(ergo(rc == 0, c2_net__ep_invariant(*epp, dom, true)));
 
-	c2_mutex_unlock(&tm->ntm_mutex);
+	c2_mutex_unlock(&dom->nd_mutex);
 	return rc;
 }
 C2_EXPORTED(c2_net_end_point_create);
@@ -89,15 +86,16 @@ C2_EXPORTED(c2_net_end_point_get);
 int c2_net_end_point_put(struct c2_net_end_point *ep)
 {
 	struct c2_ref *ref = &ep->nep_ref;
-	struct c2_net_transfer_mc *tm;
+	struct c2_net_domain *dom;
 	C2_PRE(ep != NULL);
 	C2_PRE(c2_atomic64_get(&ref->ref_cnt) >= 1);
-	tm = ep->nep_tm;
-	C2_PRE(tm != NULL);
-	/* hold the transfer machine lock to synchronize release(), if called */
-	c2_mutex_lock(&tm->ntm_mutex);
+	dom = ep->nep_dom;
+	C2_PRE(dom != NULL );
+	C2_PRE(dom->nd_xprt != NULL);
+	/* hold the domain lock to synchronize release(), if called */
+	c2_mutex_lock(&dom->nd_mutex);
 	c2_ref_put(ref);
-	c2_mutex_unlock(&tm->ntm_mutex);
+	c2_mutex_unlock(&dom->nd_mutex);
 	return 0;
 }
 C2_EXPORTED(c2_net_end_point_put);
diff --git a/net/ksunrpc/client.c b/net/ksunrpc/client.c
index 99aabb5..07a54c3 100644
--- a/net/ksunrpc/client.c
+++ b/net/ksunrpc/client.c
@@ -1,6 +1,6 @@
 /* -*- C -*- */
 /*
- * COPYRIGHT 2012 XYRATEX TECHNOLOGY LIMITED
+ * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
  *
  * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
  * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
@@ -14,7 +14,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Huang Hua <Hua_Huang@xyratex.com>
+ * Original author: Huang Hua
  * Original creation date: 05/30/2010
  */
 
@@ -56,6 +56,8 @@
   @{
  */
 
+#define C2_DEF_RPC_VER  1
+#define C2_SESSION_PROGRAM 0x20000001
 #define UT_PROC_NAME "ksunrpc-ut"
 
 /*
@@ -140,9 +142,6 @@ static int ksunrpc_conn_init(struct c2_service_id *id, struct c2_net_conn *conn)
 	};
 
 	struct rpc_create_args args = {
-#ifdef HAVE_STRUCT_NET
-		.net		= &init_net,
-#endif
 		.protocol	= XPRT_TRANSPORT_TCP,
 		.address	= (struct sockaddr *)&ksid->ssi_sockaddr,
 		.addrsize	= ksid->ssi_addrlen,
@@ -194,7 +193,7 @@ static int ksunrpc_conn_call(struct c2_net_conn *conn, struct c2_net_call *call)
 
 
 	struct rpc_procinfo proc = {
-		.p_proc   = arg_fopt->ft_rpc_item_type.rit_opcode,
+		.p_proc   = arg_fopt->ft_code,
 		.p_encode = (kxdrproc_t) c2_kcall_enc,
 		.p_decode = (kxdrproc_t) c2_kcall_dec,
 		.p_arglen = arg_fopt->ft_top->fft_layout->fm_sizeof,
@@ -393,10 +392,18 @@ static void __exit remove_ut_proc_entry(void)
 		remove_proc_entry(UT_PROC_NAME, NULL);
 }
 
+#else
+
+static void __init create_ut_proc_entry(void) {}
+static void __exit remove_ut_proc_entry(void) {}
+
+#endif
+
 /*******************************************************************************
  *                       End of UT                                             *
  ******************************************************************************/
 
+
 static int __init kernel_sunrpc_init(void)
 {
 	printk(KERN_INFO "Colibri Kernel Client SUNRPC(http://www.clusterstor.com)\n");
@@ -413,10 +420,9 @@ static void __exit kernel_sunrpc_fini(void)
 module_init(kernel_sunrpc_init)
 module_exit(kernel_sunrpc_fini)
 
-MODULE_AUTHOR("Huang Hua <Hua_Huang@xyratex.com>");
+MODULE_AUTHOR("Huang Hua <hua.huang@clusterstor.com>");
 MODULE_DESCRIPTION("C2 Kernel Client RPC");
 MODULE_LICENSE("GPL");
-#endif
 
 /** @} end of group ksunrpc */
 
diff --git a/net/ksunrpc/domain.c b/net/ksunrpc/domain.c
index 40d25c1..a4a8534 100644
--- a/net/ksunrpc/domain.c
+++ b/net/ksunrpc/domain.c
@@ -14,7 +14,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Huang Hua <Hua_Huang@xyratex.com>
+ * Original author: Huang Hua
  * Original creation date: 05/30/2010
  */
 
@@ -54,13 +54,6 @@
  */
 
 /*
- * Maximum bulk IO size
- */
-enum {
-	KSUNRPC_MAX_BRW_SIZE = (4 << 20)
-};
-
-/*
  * Domain code.
  */
 
@@ -73,8 +66,8 @@ static void ksunrpc_dom_fini(struct c2_net_domain *dom)
 {
 	struct ksunrpc_dom *xdom;
 
-	C2_ASSERT(c2_list_is_empty(&dom->nd_conn));
-	C2_ASSERT(c2_list_is_empty(&dom->nd_service));
+	c2_list_fini(&dom->nd_conn);
+	c2_list_fini(&dom->nd_service);
 
 	xdom = dom->nd_xprt_private;
 	if (xdom != NULL) {
@@ -102,42 +95,18 @@ static int ksunrpc_dom_init(struct c2_net_xprt *xprt, struct c2_net_domain *dom)
 	return result;
 }
 
-static size_t ksunrpc_net_bulk_size(void)
-{
-	return KSUNRPC_MAX_BRW_SIZE;
-}
-
 static const struct c2_net_xprt_ops ksunrpc_xprt_ops = {
 	.xo_dom_init        = ksunrpc_dom_init,
 	.xo_dom_fini        = ksunrpc_dom_fini,
 	.xo_service_id_init = ksunrpc_service_id_init,
-	.xo_service_init    = ksunrpc_service_init,
-	.xo_net_bulk_size   = ksunrpc_net_bulk_size
+	.xo_service_init    = NULL
 };
 
 struct c2_net_xprt c2_net_ksunrpc_xprt = {
 	.nx_name = "sunrpc/linux_kernel",
 	.nx_ops  = &ksunrpc_xprt_ops
 };
-
-/**
-   Minimal version of the ksunrpc transport with a total of 4 threads
-   when run with a server.
- */
-struct c2_net_xprt c2_net_ksunrpc_minimal_xprt = {
-	.nx_name = "minimal-sunrpc/linux_kernel",
-	.nx_ops  = &ksunrpc_xprt_ops
-};
-
-int c2_ksunrpc_init(void)
-{
-	return ksunrpc_server_init();
-}
-
-void c2_ksunrpc_fini(void)
-{
-	ksunrpc_server_fini();
-}
+C2_EXPORTED(c2_net_ksunrpc_xprt);
 
 /** @} end of group usunrpc */
 
diff --git a/net/ksunrpc/ksunrpc.h b/net/ksunrpc/ksunrpc.h
index 8fa492a..2401a32 100644
--- a/net/ksunrpc/ksunrpc.h
+++ b/net/ksunrpc/ksunrpc.h
@@ -14,7 +14,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Huang Hua <Hua_Huang@xyratex.com>
+ * Original author: Huang Hua
  * Original creation date: 05/30/2010
  */
 
@@ -22,7 +22,7 @@
 #define __COLIBRI_NET_KSUNRPC_KSUNRPC_H__
 
 #include "lib/mutex.h"
-#include "net/net_internal.h"
+#include "net/net.h"
 
 #ifdef __KERNEL__
 #include <linux/in.h>
@@ -47,9 +47,6 @@ struct c2_fop;
 
 
 int ksunrpc_service_id_init(struct c2_service_id *sid, va_list varargs);
-int ksunrpc_service_init(struct c2_service *service);
-int ksunrpc_server_init(void);
-void ksunrpc_server_fini(void);
 
 extern const struct c2_service_id_ops ksunrpc_service_id_ops;
 extern const struct c2_net_conn_ops   ksunrpc_conn_ops;
@@ -70,15 +67,6 @@ struct ksunrpc_conn {
 
 int c2_kcall_enc(void *rqstp, __be32 *data, struct c2_net_call *call);
 int c2_kcall_dec(void *rqstp, __be32 *data, struct c2_net_call *call);
-
-int c2_svc_rqst_dec(void *rqstp, __be32 *data, struct c2_fop *arg);
-int c2_svc_rqst_enc(void *rqstp, __be32 *data, struct c2_fop *arg);
-
-int c2_fop_encode_buffer(const struct c2_fop_type_format *ftf,
-			 void *buffer, void *obj);
-int c2_fop_decode_buffer(const struct c2_fop_type_format *ftf,
-			 void *buffer, void *obj);
-
 /* #else __KERNEL__ */
 #else
 # include <netinet/in.h>
@@ -98,14 +86,6 @@ struct ksunrpc_service_id {
 	uint32_t              ssi_ver;      /**< server program version */
 };
 
-int c2_ksunrpc_init(void);
-void c2_ksunrpc_fini(void);
-
-extern const struct c2_service_id_ops ksunrpc_service_id_ops;
-extern const struct c2_net_conn_ops ksunrpc_conn_ops;
-extern const struct c2_service_ops ksunrpc_service_ops;
-extern struct c2_net_xprt c2_net_ksunrpc_minimal_xprt;
-
 /* __COLIBRI_NET_KSUNRPC_KSUNRPC_H__ */
 #endif
 /*
diff --git a/net/ksunrpc/kxdr.c b/net/ksunrpc/kxdr.c
index 12916d9..741e79d 100644
--- a/net/ksunrpc/kxdr.c
+++ b/net/ksunrpc/kxdr.c
@@ -1,6 +1,6 @@
 /* -*- C -*- */
 /*
- * COPYRIGHT 2012 XYRATEX TECHNOLOGY LIMITED
+ * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
  *
  * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
  * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
@@ -14,17 +14,11 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Nikita Danilov <Nikita_Danilov@xyratex.com>
+ * Original author: Nikita Danilov
  * Original creation date: 07/01/2010
  */
 
-#ifdef HAVE_CONFIG_H
-#  include <config.h>
-#endif
-
 #include <linux/sunrpc/clnt.h>
-#include <linux/sunrpc/svc.h>
-#include <linux/pagemap.h> /* PAGE_CACHE_SIZE */
 
 #include "lib/cdefs.h"
 #include "fop/fop.h"
@@ -40,16 +34,15 @@
    This file defines "universal" fop xdr functions for the Linux kernel.
 
    Main entry points c2_kcall_dec() and c2_kcall_enc() decode and encode rpc
-   calls respectively. The entry points c2_svc_rqst_dec() and c2_svc_rqst_enc()
-   decode and encode service requests respectively.  For each fop type there are
-   four xdr-related operations (see enum kxdr_what):
+   calls respectively. For each fop type there are three xdr-related operations
+   (see enum kxdr_what):
 
    @li encoding (KENC): serialize fop data to the rpc send buffer, according to
    fop type. This operation is called on c2_knet_call::ac_arg fop before rpc is
    sent;
 
-   @li client decoding (KDEC): read data from the rpc receive buffer and build
-   fop instance. This operation is called on c2_knet_call::ac_ret for after rpc
+   @li decoding (KDEC): read data from the rpc receive buffer and build fop
+   instance. This operation is called on c2_knet_call::ac_ret for after rpc
    reply was received;
 
    @li reply preparing (KREP): prepare for receipt a fop of this type as a
@@ -58,14 +51,7 @@
    stored. For example "read" type operations must attach data pages to the
    reply buffer, see kxdr_sequence_rep().
 
-   @li service decoding (KARG): read data from the rpc service arg buffer and
-   build fop instance. This operation is called on fop of appropriate
-   c2_net_op_table::top_fopt type after rpc request was received in server.
-   Internally, this is very similar to KDEC, except for sequence handling,
-   since there is no way to pre-allocate pages as is done in KREP.  Only
-   a single sequence is supported per service request.
-
-   All four xdr operations are implemented similarly, by recursively descending
+   All three xdr operations are implemented similarly, by recursively descending
    through the fop format tree.
 
    When handling a non-leaf (i.e., "aggregating") node of a fop format tree,
@@ -103,15 +89,13 @@ enum kxdr_what {
 	KENC,
 	KDEC,
 	KREP,
-	KARG,
 	KNR
 };
 
 struct kxdr_ctx {
 	const struct c2_fop_field_type *kc_type;
 	struct xdr_stream              *kc_xdr;
-	struct rpc_rqst                *kc_creq;
-	struct svc_rqst                *kc_sreq;
+	struct rpc_rqst                *kc_req;
 	enum kxdr_what                  kc_what;
 	uint32_t                       *kc_nob;
 };
@@ -275,14 +259,10 @@ static int kxdr_sequence_rep(struct kxdr_ctx *ctx, void *obj)
 
 		/* Believe or not this is how kernel rpc users are supposed to
 		   indicate size of a reply. */
-#ifdef HAVE_CRED_IN_REQ
-		auth = ctx->kc_creq->rq_cred->cr_auth;
-#else
-		auth = ctx->kc_creq->rq_task->tk_msg.rpc_cred->cr_auth;
-#endif
+		auth = ctx->kc_req->rq_task->tk_msg.rpc_cred->cr_auth;
 		offset = ((RPC_REPHDRSIZE + auth->au_rslack + 3) << 2) +
 			*ctx->kc_nob;
-		xdr_inline_pages(&ctx->kc_creq->rq_rcv_buf, offset,
+		xdr_inline_pages(&ctx->kc_req->rq_rcv_buf, offset,
 				 ps->ps_pages, ps->ps_pgoff, ps->ps_nr);
 		result = 0;
 	} else {
@@ -291,29 +271,6 @@ static int kxdr_sequence_rep(struct kxdr_ctx *ctx, void *obj)
 	return result;
 }
 
-static int kxdr_sequence_arg(struct kxdr_ctx *ctx, void *obj)
-{
-	int result;
-	struct page_sequence *ps = obj;
-
-	result = atom_kxdr[ctx->kc_what][FPF_U32](ctx->kc_xdr, obj);
-	if (result != 0)
-		return result;
-
-	if (kxdr_is_byte_array(ctx)) {
-		/* Only supports bulk service with a single sequence */
-		ps->ps_pgoff =
-		    (unsigned long) ctx->kc_xdr->p & (PAGE_CACHE_SIZE - 1);
-		ps->ps_pages = ctx->kc_sreq->rq_pages;
-	} else {
-		uint32_t i;
-
-		for (result = 0, i = 0; result == 0 && i < ps->ps_nr; ++i)
-			result = ftype_subxdr(ctx, obj, 1, i);
-	}
-	return result;
-}
-
 static int kxdr_typedef(struct kxdr_ctx *ctx, void *obj)
 {
 	return ftype_subxdr(ctx, obj, 0, 0);
@@ -331,12 +288,6 @@ static int (*atom_kxdr[KNR][FPF_NR])(struct xdr_stream *xdr, void *obj) = {
 		[FPF_BYTE] = NULL,
 		[FPF_U32]  = (void *)&c2_ku32_decode,
 		[FPF_U64]  = (void *)&c2_ku64_decode
-	},
-	[KARG] = {
-		[FPF_VOID] = (void *)&c2_kvoid_decode,
-		[FPF_BYTE] = NULL,
-		[FPF_U32]  = (void *)&c2_ku32_decode,
-		[FPF_U64]  = (void *)&c2_ku64_decode
 	}
 };
 
@@ -376,13 +327,6 @@ static const c2_kxdrproc_t kxdr_disp[KNR][FFA_NR] =
 		[FFA_SEQUENCE] = kxdr_sequence_rep,
 		[FFA_TYPEDEF]  = kxdr_typedef,
 		[FFA_ATOM]     = kxdr_atom_rep
-	},
-	[KARG] = {
-		[FFA_RECORD]   = kxdr_record,
-		[FFA_UNION]    = kxdr_union,
-		[FFA_SEQUENCE] = kxdr_sequence_arg,
-		[FFA_TYPEDEF]  = kxdr_typedef,
-		[FFA_ATOM]     = kxdr_atom
 	}
 };
 
@@ -395,7 +339,7 @@ static int c2_fop_type_encdec(const struct c2_fop_field_type *ftype,
 	struct kxdr_ctx   ctx = {
 		.kc_type = ftype,
 		.kc_xdr   = &xdr,
-		.kc_creq  = req,
+		.kc_req   = req,
 		.kc_what  = what,
 		.kc_nob   = &nob
 	};
@@ -409,84 +353,11 @@ static int c2_fop_type_encdec(const struct c2_fop_field_type *ftype,
 	case KDEC:
 		xdr_init_decode(&xdr, &req->rq_rcv_buf, data);
 	default:
-		C2_ASSERT(what != KARG);
 		break;
 	}
 	return kxdr_disp[what][ftype->fft_aggr](&ctx, obj);
 }
 
-static int c2_fop_encdec_buffer(const struct c2_fop_type_format *ftf,
-				void *buffer, void *obj, enum kxdr_what what)
-{
-	const struct c2_fop_field_type *ftype = ftf->ftf_out;
-	size_t len = ftf->ftf_layout->fm_sizeof;
-	/* see code in kernel net/sunrpc for XDR structure initialization */
-	struct xdr_buf xb = {
-		.head = {
-			[0] = {
-				.iov_base = buffer,
-				.iov_len  = len,
-			},
-		},
-		.buflen = len,
-	};
-	struct xdr_stream xdr = {
-		.buf = &xb,
-		.iov = xb.head,
-		.end = (__be32 *)((char *)buffer + len),
-		.p   = buffer,
-	};
-	int nob = 0;
-	struct kxdr_ctx   ctx = {
-		.kc_type = ftype,
-		.kc_xdr  = &xdr,
-		.kc_what = what,
-		.kc_nob  = &nob
-	};
-	int rc;
-
-	C2_ASSERT(ftype->fft_aggr < ARRAY_SIZE(kxdr_disp));
-
-	switch (what) {
-	case KENC:
-	case KDEC:
-		break;
-	default:
-		C2_IMPOSSIBLE("only KENC and KDEC supported");
-		break;
-	}
-	rc = kxdr_disp[what][ftype->fft_aggr](&ctx, obj);
-	C2_POST(ergo(what == KENC, xb.len <= len));
-	return rc;
-}
-
-/**
-   XDR encode a record or atomic FOP into a buffer.
-   Will not work for embedded sequences.
-   @param ftype  Pointer to FOP type format.
-   @param buffer Buffer pointer.  It is assumed that the buffer is of size
-   ftype->ftf_layout->fm_sizeof and is large enough to encode the FOP.
-   @param obj    Pointer to FOP object.
- */
-int c2_fop_encode_buffer(const struct c2_fop_type_format *ftf,
-			 void *buffer, void *obj)
-{
-	return c2_fop_encdec_buffer(ftf, buffer, obj, KENC);
-}
-
-/**
-   XDR decode a record or atomic FOP from a buffer previously encoded
-   with c2_fop_encode_buffer().
-   @param ftype  Pointer to FOP type format.
-   @param buffer Buffer pointer.
-   @param obj    Pointer to FOP object.
- */
-int c2_fop_decode_buffer(const struct c2_fop_type_format *ftf,
-			 void *buffer, void *obj)
-{
-	return c2_fop_encdec_buffer(ftf, buffer, obj, KDEC);
-}
-
 static int c2_fop_kenc(void *req, __be32 *data, struct c2_fop *fop)
 {
 	return c2_fop_type_encdec(fop->f_type->ft_top,
@@ -520,47 +391,6 @@ int c2_kcall_dec(void *req, __be32 *data, struct c2_net_call *kcall)
 	return c2_fop_kdec(req, data, kcall->ac_ret);
 }
 
-static int c2_svc_rqst_encdec(const struct c2_fop_field_type *ftype,
-			      struct svc_rqst *rqstp, __be32 *data, void *obj,
-			      enum kxdr_what what)
-{
-	int nob = 0;
-	struct xdr_stream xdr;
-	struct kxdr_ctx   ctx = {
-		.kc_type = ftype,
-		.kc_xdr   = &xdr,
-		.kc_sreq  = rqstp,
-		.kc_what  = what,
-		.kc_nob   = &nob
-	};
-
-	C2_ASSERT(ftype->fft_aggr < ARRAY_SIZE(kxdr_disp));
-	C2_ASSERT(what == KENC || what == KARG);
-
-	switch (what) {
-	case KENC:
-		xdr_init_encode(&xdr, &rqstp->rq_res, data);
-		break;
-	case KARG:
-		xdr_init_decode(&xdr, &rqstp->rq_arg, data);
-	default:
-		break;
-	}
-	return kxdr_disp[what][ftype->fft_aggr](&ctx, obj);
-}
-
-int c2_svc_rqst_dec(void *req, __be32 *data, struct c2_fop *fop)
-{
-	return c2_svc_rqst_encdec(fop->f_type->ft_top,
-				  req, data, c2_fop_data(fop), KARG);
-}
-
-int c2_svc_rqst_enc(void *req, __be32 *data, struct c2_fop *fop)
-{
-	return c2_svc_rqst_encdec(fop->f_type->ft_top,
-				  req, data, c2_fop_data(fop), KENC);
-}
-
 /** @} end of group ksunrpc */
 
 /*
diff --git a/net/lnet/bev_cqueue.c b/net/lnet/bev_cqueue.c
deleted file mode 100644
index 1b6e586..0000000
--- a/net/lnet/bev_cqueue.c
+++ /dev/null
@@ -1,696 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Carl Braganza <Carl_Braganza@us.xyratex.com>
- *                  Dave Cohrs <Dave_Cohrs@us.xyratex.com>
- * Original creation date: 11/10/2011
- */
-
-/**
-   @page LNetcqueueDLD LNet Buffer Event Circular Queue DLD
-
-   - @ref cqueueDLD-ovw
-   - @ref cqueueDLD-def
-   - @ref cqueueDLD-req
-   - @ref cqueueDLD-depends
-   - @ref cqueueDLD-highlights
-   - @subpage cqueueDLD-fspec "Functional Specification"
-      - @ref bevcqueue "External Interfaces"        <!-- int link -->
-   - @ref cqueueDLD-lspec
-      - @ref cqueueDLD-lspec-comps
-      - @ref cqueueDLD-lspec-q
-      - @ref cqueueDLD-lspec-state
-      - @ref cqueueDLD-lspec-thread
-      - @ref cqueueDLD-lspec-numa
-   - @ref cqueueDLD-conformance
-   - @ref cqueueDLD-ut
-   - @ref cqueueDLD-st
-   - @ref cqueueDLD-O
-   - @ref cqueueDLD-ref
-
-   <hr>
-   @section cqueueDLD-ovw Overview
-
-   The circular queue provides a data structure and interfaces to manage a
-   lock-free queue for a single producer and consumer.  The producer and
-   consumer can be in different address spaces with the queue in shared memory.
-   The circular queue is designed to specifically meet the needs of the
-   @ref KLNetCoreDLD "Core API". <!-- ./linux_kernel/klnet_core.c -->
-   In particular see the @ref KLNetCoreDLD-lspec-bevq "The Buffer Event Queue"
-   section.
-
-   The queue implementation does not address how the consumer gets notified that
-   queue elements have been produced. That functionality is provided separately
-   by the Core API nlx_core_buf_event_wait() subroutine.
-
-   <hr>
-   @section cqueueDLD-def Definitions
-
-   Refer to <a href="https://docs.google.com/a/xyratex.com/document/d/1TZG__XViil3ATbWICojZydvKzFNbL7-JJdjBbXTLgP4/edit?hl=en_US">HLD of Colibri LNet Transport</a>
-
-   <hr>
-   @section cqueueDLD-req Requirements
-
-   - @b r.c2.lib.atomic.interoperable-kernel-user-support The
-   implementation shall provide a queue that supports atomic,
-   interoperable sharing between kernel to user-space.
-   - @b r.net.xprt.lnet.growable-event-queue The implementation shall
-   support an event queue to which new elements can be added over time.
-
-   <hr>
-   @section cqueueDLD-depends Dependencies
-
-   - The @ref atomic <!-- lib/atomic.h --> API.
-
-   <hr>
-   @section cqueueDLD-highlights Design Highlights
-
-   - A data structure representing a circular queue.
-   - The circular queue efficiently delivers event notifications from the
-   LNet Transport Kernel Core layer to the LNet transport layer.
-   - Handles atomic access to elements in the queue for a single producer and
-   consumer.
-   - Handles dynamically adding new elements to the circular queue.
-
-   <hr>
-   @section cqueueDLD-lspec Logical Specification
-
-   - @ref cqueueDLD-lspec-comps
-   - @ref cqueueDLD-lspec-q
-   - @ref cqueueDLD-lspec-xlink
-   - @ref cqueueDLD-lspec-qalloc
-   - @ref cqueueDLD-lspec-state
-   - @ref cqueueDLD-lspec-thread
-   - @ref cqueueDLD-lspec-numa
-
-   @subsection cqueueDLD-lspec-comps Component Overview
-
-   The circular queue is a single component.
-
-   @subsection cqueueDLD-lspec-q Logic of the Circular Queue
-
-   The circular queue is a FIFO queue.  The implementation maintains pointers
-   for the consumer and producer, and operations for accessing these pointers
-   and for moving them around the circular queue elements.  The application
-   manages the memory containing the queue itself, and adds new elements to the
-   queue when the size of the queue needs to grow.  In this discussion of the
-   logic, the pointers are named @c consumer, @c producer and @c next for
-   brevity.
-
-   @dot
-   digraph {
-   {
-       rank=same;
-       node [shape=plaintext];
-       nlx_core_bev_cqueue;
-       node [shape=record];
-       struct1 [label="<f0> consumer|<f1> producer"];
-   }
-   {
-       rank=same;
-       ordering=out;
-       node [shape=plaintext];
-       "element list";
-       node [shape=record];
-       list1 [label="<f0> |<f1> y|<f2> x|<f3> x|<f4> x|<f5> x|<f6> |<f7> "];
-       "element list" -> list1 [style=invis];
-   }
-   {
-       rank=same;
-       x1 [shape=point width=0 height=0];
-       x2 [shape=point width=0 height=0];
-       x1 -> x2 [dir=none];
-   }
-   nlx_core_bev_cqueue -> "element list" [style=invis];
-   struct1:f0 -> list1:f1;
-   struct1:f1 -> list1:f6;
-   list1:f7 -> x2 [dir=none];
-   list1:f0 -> x1 [dir=back];
-   }
-   @enddot
-
-   The elements starting after @c consumer up to but not including @c producer
-   contain data to be consumed (those elements marked with "x" in the diagram).
-   So, @c consumer follows @c producer around the circular queue.  When
-   @c consumer->next is the same as @c producer, the queue is empty
-   (requiring that the queue be initialized with at least 2 elements).  The
-   element pointed to by @c consumer (element "y" in the diagram) is the
-   element most recently consumed by the consumer.  The producer cannot use this
-   element, because if it did, producing that element would result in moving
-   @c producer so that it would pass @c consumer.
-
-   In the context of the LNet Buffer Event Queue, the transport should add
-   enough elements to the queue strictly before it enqueues buffer operations
-   requiring subsequent completion notifications.  The number required is the
-   total number of possible events generated by queued buffers, plus one extra
-   element for the most recently consumed event notification.  The circular
-   queue does not enforce this requirement, but does provide APIs that the
-   transport can use to determine the current number of elements in the queue
-   and to add new elements.
-
-   The element denoted by @c producer is returned by bev_cqueue_pnext() as
-   long as the queue is not full.  This allows the producer to determine the
-   next available element and populate it with the data to be produced.  Once
-   the element contains the data, the producer then calls bev_cqueue_put()
-   to make that element available to the consumer.  This call also moves the
-   @c producer pointer to the next element.
-
-   The consumer uses bev_cqueue_get() to get the next available element
-   containing data in FIFO order.  Consuming an element causes @c consumer to
-   be pointed at the next element in the queue.  After this call returns, the
-   consumer "owns" the element returned, element "y" in the diagram.  The
-   consumer owns this element until it calls bev_cqueue_get() again, at which
-   time ownership reverts to the queue and can be reused by the producer.
-
-   @subsection cqueueDLD-lspec-xlink Cross Address Space Linkage Support
-
-   The pointers themselves are more complex than the description above suggests.
-   The @c consumer pointer refers to the element just consumed in the consumer's
-   (the transport) address space.  The @c producer pointer refers to the element
-   in the producer's (the kernel) address space.
-
-   A queue link element (the @c next pointer in the preceeding discussion) is
-   represented by the nlx_core_bev_link data structure:
-   @code
-   struct nlx_core_bev_link {
-            // Self pointer in the transport address space.
-            nlx_core_opaque_ptr_t cbl_c_self;
-            // Self pointer in the kernel address space.
-            nlx_core_opaque_ptr_t cbl_p_self;
-            // Pointer to the next element in the consumer address space.
-            nlx_core_opaque_ptr_t cbl_c_next;
-            // Pointer to the next element in the producer address space.
-            nlx_core_opaque_ptr_t cbl_p_next;
-   };
-   @endcode
-   The data structure maintains separate "opaque" pointer fields for the
-   producer and consumer address spaces.  Elements in the queue are linked
-   through both flavors of their @c next field.  The initialization of this data
-   structure will be described in @ref cqueueDLD-lspec-qalloc.  The opaque
-   pointer type is derived from ::c2_atomic64.
-
-   When the producer performs a bev_cqueue_put() call, internally, this call
-   uses nlx_core_bev_link::cbl_p_next to refer to the next element.
-   Similarly, when the consumer performs a bev_cqueue_get() call, internally,
-   this call uses nlx_core_bev_link::cbl_c_next.  Note that only
-   allocation, discussed below, modifies any of these pointers.  Steady-state
-   operations on the queue only modify the @c consumer and @c producer pointers.
-
-   The data structure also contains "self" pointers for each address
-   space. These pointers permit comparison against the queue head's @c
-   consumer and @c producer pointer values from the producer and consumer
-   address spaces respectively. For example, the abstract check
-
-   @code
-       q->producer != q->consumer
-   @endcode
-
-   performed in producer space is actually implemented as
-
-   @code
-       pq->cbcq_producer->cbl_c_self != pq->cbcq_consumer
-   @endcode
-
-   Here, the @c pq pointer itself is the pointer to the shared
-   nlx_core_bev_cqueue object in the producer address space.  This pointer is
-   made known to the producer when the queue is created (e.g. when the transport
-   allocates the queue, it passes the transport space pointer to the object to
-   the producer which maps that memory into the producer address space).  Note
-   that this check is safe in producer space because only the producer changes
-   the value of the @c producer pointer and the @c pq pointer is never changed
-   after the queue object is allocated.  The equivalent safe call in consumer
-   space would be:
-
-   @code
-       cq->cbcq_consumer->cbl_p_self != cq->cbcq_producer
-   @endcode
-
-   In this case, the @c cq pointer refers to the same queue object in shared
-   memory, but this pointer is in the consumer's address space.
-
-   @subsection cqueueDLD-lspec-qalloc Circular Queue Allocation
-
-   The circular queue must contain at least 2 elements, as discussed above.
-   Additional elements can be added to maintain the requirement that the number
-   of elements in the queue equals or exceeds the number of pending buffer
-   operations, plus one element for the most recently consumed operation.
-
-   The initial condition is shown below.  In this diagram, the queue is empty
-   (see the state discussion, below).  There is room in the queue for one
-   pending buffer event and one completed/consumed event.
-
-   @dot
-   digraph {
-   {
-       rank=same;
-       node [shape=plaintext];
-       nlx_core_bev_cqueue;
-       node [shape=record];
-       struct1 [label="<f0> consumer|<f1> producer"];
-   }
-   {
-       rank=same;
-       ordering=out;
-       node [shape=plaintext];
-       "element list";
-       node1 [shape=box];
-       node2 [shape=box];
-       "element list" -> node1 [style=invis];
-       node1 -> node2 [label=next];
-       node2 -> node1 [label=next];
-   }
-   nlx_core_bev_cqueue -> "element list" [style=invis];
-   struct1:f0 -> node1;
-   struct1:f1 -> node2;
-   }
-   @enddot
-
-   Before adding additional elements, the following are true:
-   - The number of elements in the queue, N, equals the number of pending
-   operations plus one for the most recently consumed operation completion
-   event.
-   - The producer produces one event per pending operation.
-   - The producer will never catch up with the consumer.  Given the required
-   number of elements, the producer will run out of work to do when it has
-   generated one event for each buffer operation, resulting in a state where
-   <tt> producer == consumer </tt>.
-
-   This means the queue can @b safely be expanded at the location of the @c
-   consumer pointer (i.e. in the consumer address space), without
-   affecting the producer.  Elements are added as follows:
-
-   -# Allocate and initialize a new queue element (referred to as @c newnode)
-      which sets @c newnode->c_self and @c newnode->p_self.
-   -# Set <tt>  newnode->next = consumer->next </tt>
-   -# Set <tt> consumer->next = newnode        </tt>
-   -# set <tt>       consumer = newnode        </tt>
-
-   Steps 2-4 are performed in bev_cqueue_add().  Because several pointers need
-   to be updated, simple atomic operations are insufficient.  Thus, the
-   transport layer must synchronize calls to bev_cqueue_add() and
-   bev_cqueue_get(), because both calls affect the consumer.  Given that
-   bev_cqueue_add() completes its three operations before returning, and
-   bev_cqueue_add() is called before the new buffer is added to the queue,
-   there is no way the producer will try to generate an event and move its
-   pointer forward until bev_cqueue_add() completes.  This allows the transport
-   layer and core layer to continue interact only using atomic operations.
-
-   A diagrammatic view of these steps is shown below.  The dotted arrows signify
-   the pointers before the new node is added.  The Step numbers correspond to
-   steps 2-4 above.
-   @dot
-   digraph {
-   {
-       rank=same;
-       node [shape=plaintext];
-       nlx_core_bev_cqueue;
-       node [shape=record];
-       struct1 [label="<f0> consumer|<f1> producer"];
-   }
-   newnode [shape=box];
-   struct1:f0 -> newnode [label="(4)"];
-   node1 -> newnode [label="next (3)"]
-   newnode -> node2 [label="next (2)"]
-   {
-       rank=same;
-       ordering=out;
-       "element list" [shape=plaintext];
-       node1 [shape=box];
-       node2 [shape=box];
-       node1 -> node2 [style=dotted];
-       node2 -> node1 [label=next];
-   }
-   nlx_core_bev_cqueue -> "element list" [style=invis];
-   struct1:f0 -> node1 [style=dotted];
-   struct1:f1 -> node2;
-   }
-   @enddot
-
-   Once again, updating the @c next pointer is less straight forward than the
-   diagram suggests.  In step 1, the node is allocated by the transport layer.
-   Once allocated, initialization includes the transport layer setting the
-   nlx_core_bev_link::cbl_c_self pointer to point at the node and having
-   the kernel core layer "bless" the node by setting the
-   nlx_core_bev_link::cbl_p_self link.  After the self pointers are set,
-   the next pointers can be set by using these self pointers.  Since allocation
-   occurs in the transport address space, the allocation logic uses the
-   nlx_core_bev_link::cbl_c_next pointers of the existing nodes for
-   navigation, and sets both the @c cbl_c_next and
-   nlx_core_bev_link::cbl_p_next pointers.  The @c cbl_p_next pointer
-   is set by using the @c cbl_c_next->cbl_p_self value, which is treated
-   opaquely by the transport layer.  So, steps 2 and 3 update both pairs of
-   pointers.  Allocation has no affect on the @c producer pointer itself, only
-   the @c consumer pointer.
-
-   The resultant 3 element queue looks like this:
-   @dot
-   digraph {
-   {
-       rank=same;
-       node [shape=plaintext];
-       nlx_core_bev_cqueue;
-       node [shape=record];
-       struct1 [label="<f0> consumer|<f1> producer"];
-   }
-   {
-       rank=same;
-       ordering=out;
-       node [shape=plaintext];
-       "element list";
-       node2 [shape=box];
-       newnode [shape=box];
-       node1 [shape=box];
-       "element list" -> newnode [style=invis];
-       newnode -> node2 [label=next];
-       node2 -> node1 [label=next];
-       node1 -> newnode [label=next];
-   }
-   nlx_core_bev_cqueue -> "element list" [style=invis];
-   struct1:f0 -> newnode;
-   struct1:f1 -> node2;
-   }
-   @enddot
-
-
-   @subsection cqueueDLD-lspec-state State Specification
-
-   The circular queue can be in one of 3 states:
-   - empty: This is the initial state and the queue returns to this state
-   whenever @code consumer->next == producer @endcode
-   - full: The queue contains elements and has no room for more. In this state,
-   the producer should not attempt to put any more elements into the queue.
-   This state can be expressed as @code producer == consumer @endcode
-   - partial: In this state, the queue contains elements to be consumed and
-   still has room for additional element production. This can be expressed as
-   @code consumer->next != producer && consumer != producer @endcode
-
-   As discussed @ref cqueueDLD-lspec-xlink "above", implementing these
-   comparisons requires the use of the appropriate opaque pointers in the
-   nlx_core_bev_link data structure.  The implementation of tests for these
-   states varies depending on if the producer or the consumer is making the
-   test.  Note also that there is no direct way for the producer to detect the
-   empty state, because the @c consumer pointer is meaningful only in the
-   consumer (transport) space.
-
-   @subsection cqueueDLD-lspec-thread Threading and Concurrency Model
-
-   A single producer and consumer are supported.  Atomic variables,
-   @c consumer and @c producer, represent the range of elements in the queue
-   containing data.  Because these pointers are atomic, no locking is needed
-   to access them by a single producer and consumer.  Furthermore, because these
-   pointers are used only for simple set or get operations, not compound
-   operations (e.g. increment or compare and set) a simple scalar data type can
-   be used.  Multiple producers and/or consumers must synchronize externally.
-
-   The transport layer acts both as the consumer and the allocator, and both
-   operations use and modify the @c consumer variable and related pointers.  As
-   such, calls to bev_cqueue_add() and bev_cqueue_get() must be synchronized.
-   The transport layer holds the transfer machine c2_net_transfer_mc::ntm_mutex
-   when it calls bev_cqueue_add().  The transport layer will also hold this
-   mutex when it calls bev_cqueue_get().
-
-   @subsection cqueueDLD-lspec-numa NUMA optimizations
-
-   None.
-
-   <hr>
-   @section cqueueDLD-conformance Conformance
-
-   - @b i.c2.lib.atomic.interoperable-kernel-user-support The
-   nlx_core_bev_link data structure allows for tracking the pointers to the
-   link in both address spaces.  The atomic operations allow the FIFO to be
-   produced and consumed simultaneously in both spaces without synchronization
-   or context switches.
-
-   - @b i.net.xprt.lnet.growable-event-queue The implementation supports
-   an event queue to which new elements can be added over time.
-
-   <hr>
-   @section cqueueDLD-ut Unit Tests
-
-   The following cases will be tested by unit tests:
-
-   @test Initializing a queue of minimum size 2
-
-   @test Successfully producing an element
-
-   @test Successfully consuming an element
-
-   @test Failing to consume an element because the queue is empty
-
-   @test Initializing a queue of larger size
-
-   @test Repeating the producing and consuming tests
-
-   @test Concurrently producing and consuming elements
-
-   <hr>
-   @section cqueueDLD-st System Tests
-
-   System testing will include tests where the producer and consumer are
-   in separate address spaces.
-
-   <hr>
-   @section cqueueDLD-O Analysis
-
-   The circular queue (the struct nlx_core_bev_cqueue) consumes fixed size
-   memory, independent of the size of the elements contains the queue's data.
-   The number of elements can grow over time, where the number of elements is
-   proportional to the number of current and outstanding buffer operations.
-   This number of elements will reach some maximum based on the peak activity in
-   the application layer.  Operations on the queue are O(1) complexity.
-
-   <hr>
-   @section cqueueDLD-ref References
-
-   - <a href="https://docs.google.com/a/xyratex.com/document/d/1TZG__XViil3ATbWICojZydvKzFNbL7-JJdjBbXTLgP4/edit?hl=en_US">HLD of Colibri LNet Transport</a>
-   - <a href="http://drdobbs.com/high-performance-computing/210604448">Writing Lock-Free Code: A Corrected Queue, Herb Sutter, in Dr Dobbs Journal, 2008</a>
-
- */
-
-/**
-   @page cqueueDLD-fspec LNet Buffer Event Queue Functional Specification
-
-   - @ref cqueueDLD-fspec-ds
-   - @ref cqueueDLD-fspec-sub
-   - @ref cqueueDLD-fspec-usecases
-   - @ref bevcqueue "Detailed Functional Specification" <!-- below -->
-
-   @section cqueueDLD-fspec-ds Data Structures
-
-   The circular queue is defined by the nlx_core_bev_cqueue data
-   structure.
-
-   @section cqueueDLD-fspec-sub Subroutines
-
-   Subroutines are provided to:
-   - initialize and finalize the nlx_core_bev_cqueue
-   - produce and consume elements in the queue
-
-   @see @ref bevcqueue "Detailed Functional Specification"
-
-   @section cqueueDLD-fspec-usecases Recipes
-
-   The nlx_core_bev_cqueue provides atomic access to the producer and
-   consumer elements in the circular queue.
-
-   In addition, semaphores or other synchronization mechanisms can be used to
-   notify the producer or consumer when the queue changes, eg. when it becomes
-   not empty.
-
-   @subsection cq-init Initialization
-
-   The circular queue is initialized as follows:
-
-   @code
-   struct nlx_core_buffer_event *e1;
-   struct nlx_core_buffer_event *e2;
-   struct nlx_core_bev_cqueue myqueue;
-
-   C2_ALLOC_PTR(e1);
-   C2_ALLOC_PTR(e2);
-   bev_cqueue_init(&myqueue, &e1->cbe_tm_link, &e2->cbe_tm_link);
-   @endcode
-
-   @subsection cq-allocator Allocator
-
-   The event queue can be expanded to make room for additional buffer events.
-   This should be performed before buffers are queued.  One element should exist
-   on the event queue for each expected buffer operation, plus one additional
-   element for the "current" buffer operation.
-
-   @code
-   size_t needed;
-   struct nlx_core_buffer_event *el;
-
-   ... ; // acquire the lock shared with the consumer
-   while (needed > bev_cqueue_size(&myqueue)) {
-       C2_ALLOC_PTR(el);
-       ... ; // initialize the new element for both address spaces
-       bev_cqueue_add(&myqueue, el);
-   }
-   ... ; // release the lock shared with the consumer
-   @endcode
-
-   @subsection cq-producer Producer
-
-   The (single) producer works in a loop, putting event notifications in the
-   queue:
-
-   @code
-   bool done;
-   struct nlx_core_bev_link *ql;
-   struct nlx_core_buffer_event *el;
-
-   while (!done) {
-       ql = bev_cqueue_pnext(&myqueue);
-       el = container_of(ql, struct nlx_core_buffer_event, cbe_tm_link);
-       ... ; // initialize the element
-       bev_cqueue_put(&myqueue);
-       ... ; // notify blocked consumer that data is available
-   }
-   @endcode
-
-   @subsection cq-consumer Consumer
-
-   The (single) consumer works in a loop, consuming data from the queue:
-
-   @code
-   bool done;
-   struct nlx_core_bev_link *ql;
-   struct nlx_core_buffer_event *el;
-
-   while (!done) {
-       ... ; // acquire the lock shared with the allocator
-       ql = bev_cqueue_get(&myqueue);
-       if (ql == NULL) {
-           ... ; // unlock a lock shared with the allocator
-           ... ; // block until data is available
-           continue;
-       }
-
-       el = container_of(ql, struct nlx_core_buffer_event, cbe_tm_link);
-       ... ; // operate on the current element
-       ... ; // release the lock shared with the allocator
-   }
-   @endcode
-
-   @see @ref bevcqueue "Detailed Functional Specification" <!-- below -->
- */
-
-/**
-   @defgroup bevcqueue LNet Buffer Event Queue Interface
-   @ingroup LNetDFS
-
-   The buffer event FIFO circular queue, used between the LNet Kernel Core
-   and LNet transport.
-
-   Unlike the standard c2_queue, this queue supports a producer and consumer in
-   different address spaces sharing the queue via shared memory.  No locking is
-   required by this single producer or consumer.
-
-   @{
- */
-
-/**
-   Buffer event queue invariant.
- */
-static bool bev_cqueue_invariant(const struct nlx_core_bev_cqueue *q);
-
-/**
-   Initialises the buffer event queue. Should be lnvoked in the consumer address
-   space only.
-   @param q buffer event queue to initialise
-   @param ql1 the first element in the new queue
-   @param ql2 the second element in the new queue
-   @pre q != NULL && ql1 != NULL && ql2 != NULL
-   @post bev_cqueue_invariant(q)
-*/
-static void bev_cqueue_init(struct nlx_core_bev_cqueue *q,
-			    struct nlx_core_bev_link *ql1,
-			    struct nlx_core_bev_link *ql2);
-
-/**
-   Adds a new element to the circular buffer queue.
-   @param q the queue
-   @param ql the element to add
- */
-static void bev_cqueue_add(struct nlx_core_bev_cqueue *q,
-			   struct nlx_core_bev_link *ql);
-/**
-   Finalise the buffer event queue.
- */
-static void bev_cqueue_fini(struct nlx_core_bev_cqueue *q);
-
-/**
-   Tests if the buffer event queue is empty.
-   @note This operation is to be used only by the consumer.  The data structures
-   do not provide a pointer to the consumer element from the producer's
-   perspective.
- */
-static bool bev_cqueue_is_empty(const struct nlx_core_bev_cqueue *q);
-
-/**
-   Returns total size of the event queue, including in-use and free elements.
- */
-static size_t bev_cqueue_size(const struct nlx_core_bev_cqueue *q);
-
-/**
-   Gets the oldest element in the FIFO circular queue, advancing the divider.
-   @param q the queue
-   @returns the link to the element in the consumer context,
-   NULL when the queue is empty
- */
-static struct nlx_core_bev_link *bev_cqueue_get(struct nlx_core_bev_cqueue *q);
-
-/**
-   Determines the next element in the queue that can be used by the producer.
-   @param q the queue
-   @returns a pointer to the next available element in the producer context
-   @pre q->cbcq_producer->cbl_c_self != q->cbcq_consumer
- */
-static struct nlx_core_bev_link* bev_cqueue_pnext(
-				      const struct nlx_core_bev_cqueue *q);
-
-/**
-   Puts (produces) an element so it can be consumed.  The caller must first
-   call bev_cqueue_pnext() to ensure such an element exists.
-   @param q the queue
-   @pre q->cbcq_producer->cbl_c_self != q->cbcq_consumer
- */
-static void bev_cqueue_put(struct nlx_core_bev_cqueue *q);
-
-/**
-   Blesses the nlx_core_bev_link of a nlx_core_bev_cqueue element, assigning
-   the producer self value.
-   @param ql the link to bless, the caller must have already mapped the element
-   into the producer address space.
- */
-static void bev_link_bless(struct nlx_core_bev_link *ql);
-
-/**
-   @}
-*/
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
diff --git a/net/lnet/linux_kernel/klnet_core.c b/net/lnet/linux_kernel/klnet_core.c
deleted file mode 100644
index baf79a6..0000000
--- a/net/lnet/linux_kernel/klnet_core.c
+++ /dev/null
@@ -1,736 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Carl Braganza <Carl_Braganza@us.xyratex.com>
- *                  Dave Cohrs <Dave_Cohrs@us.xyratex.com>
- * Original creation date: 11/01/2011
- */
-
-/**
-   @page KLNetCoreDLD LNet Transport Kernel Core DLD
-
-   - @ref KLNetCoreDLD-ovw
-   - @ref KLNetCoreDLD-def
-   - @ref KLNetCoreDLD-req
-   - @ref KLNetCoreDLD-depends
-   - @ref KLNetCoreDLD-highlights
-   - @subpage LNetCoreDLD-fspec "Functional Specification" <!--
-                                                             ./klnet_core.h -->
-        - @ref LNetCore "LNet Transport Core Interface" <!-- ../lnet_core.h -->
-        - @ref KLNetCore "Core Kernel Interface"        <!-- ./klnet_core.h -->
-        - @ref ULNetCore "Core User Space Interface"   <!-- ../ulnet_core.h -->
-   - @ref KLNetCoreDLD-lspec
-      - @ref KLNetCoreDLD-lspec-comps
-      - @ref KLNetCoreDLD-lspec-userspace
-      - @ref KLNetCoreDLD-lspec-match-bits
-      - @ref KLNetCoreDLD-lspec-tm-list
-      - @ref KLNetCoreDLD-lspec-bevq
-      - @ref KLNetCoreDLD-lspec-lnet-init
-      - @ref KLNetCoreDLD-lspec-reg
-      - @ref KLNetCoreDLD-lspec-tm-res
-      - @ref KLNetCoreDLD-lspec-buf-res
-      - @ref KLNetCoreDLD-lspec-ev
-      - @ref KLNetCoreDLD-lspec-recv
-      - @ref KLNetCoreDLD-lspec-send
-      - @ref KLNetCoreDLD-lspec-passive
-      - @ref KLNetCoreDLD-lspec-active
-      - @ref KLNetCoreDLD-lspec-lnet-cancel
-      - @ref KLNetCoreDLD-lspec-state
-      - @ref KLNetCoreDLD-lspec-thread
-      - @ref KLNetCoreDLD-lspec-numa
-   - @ref KLNetCoreDLD-conformance
-   - @ref KLNetCoreDLD-ut
-   - @ref KLNetCoreDLD-st
-   - @ref KLNetCoreDLD-O
-   - @ref KLNetCoreDLD-ref
-
-   <hr>
-   @section KLNetCoreDLD-ovw Overview
-   The LNet Transport is built over an address space agnostic "core" I/O
-   interface.  This document describes the kernel implementation of this
-   interface, which directly interacts with the Lustre LNet kernel module.
-
-   <hr>
-   @section KLNetCoreDLD-def Definitions
-   Refer to <a href="https://docs.google.com/a/xyratex.com/document/d/1TZG__XViil3ATbWICojZydvKzFNbL7-JJdjBbXTLgP4/edit?hl=en_US">HLD of Colibri LNet Transport</a>
-
-   <hr>
-   @section KLNetCoreDLD-req Requirements
-   - @b r.c2.net.lnet.buffer-registration Provide support for
-     hardware optimization through buffer pre-registration.
-
-   - @b r.c2.net.xprt.lnet.end-point-address The implementation
-     should support the mapping of end point address to LNet address
-     as described in the Refinement section of the HLD.
-
-   - @b r.c2.net.xprt.lnet.multiple-messages-in-buffer Provide
-     support for this feature as described in the HLD.
-
-   - @b r.c2.net.xprt.lnet.dynamic-address-assignment Provide
-     support for dynamic address assignment as described in the HLD.
-
-   - @b r.c2.net.xprt.lnet.user-space The implementation must
-     accommodate the needs of the user space LNet transport.
-
-   - @b r.c2.net.xprt.lnet.user.no-gpl The implementation must not expose
-     the user space transport to GPL interfaces.
-
-
-   <hr>
-   @section KLNetCoreDLD-depends Dependencies
-   - <b>LNet API</b> headers are required to build the module.
-   The Xyratex Lustre source package must be installed on the build
-   machine (RPM @c lustre-source version 2.0 or greater).
-   - <b>Xyratex Lustre run time</b>
-   - @b r.c2.lib.atomic.interoperable-kernel-user-support The @ref LNetcqueueDLD
-   "Buffer Event Circular Queue" <!-- ../bev_cqueue.c -->
-   provides a shared data structure for efficiently passing event notifications
-   from the Core layer to the LNet transport layer.
-   - @b r.net.xprt.lnet.growable-event-queue The @ref LNetcqueueDLD
-   "Buffer Event Circular Queue" <!-- ../bev_cqueue.c -->
-   provides a way to expand the event queue as new buffers are queued with a
-   transfer machine, ensuring no events are lost.
-
-   <hr>
-   @section KLNetCoreDLD-highlights Design Highlights
-   - The Core API is an address space agnostic I/O interface intended for use
-     by the Colibri Networking LNet transport operation layer in either user
-     space or kernel space.
-
-   - Efficient support for the user space transports is provided by use of
-     cross-address space tolerant data structures in shared memory.
-
-   - The Core API does not expose any LNet symbols.
-
-   - Each transfer machine is internally assigned one LNet event queue for all
-     its LNet buffer operations.
-
-   - Pre-allocation of buffer event space to guarantee that buffer operation
-     results can be returned.
-
-   - The notification of the completion of a buffer operation to the transport
-     layer is decoupled from the LNet callback that provided this notification
-     to the core module.
-
-   - The number of messages that can be delivered into a single receive buffer
-     is bounded to support pre-allocation of memory to hold the buffer event
-     payload.
-
-   - Buffer completion event notification is provided via a semaphore.  The
-     design guarantees delivery of events in the order received from LNet.  In
-     particular, the multiple possible events delivered for a single receive
-     buffer will be ordered.
-
-   <hr>
-   @section KLNetCoreDLD-lspec Logical Specification
-
-   - @ref KLNetCoreDLD-lspec-comps
-   - @ref KLNetCoreDLD-lspec-userspace
-   - @ref KLNetCoreDLD-lspec-match-bits
-   - @ref KLNetCoreDLD-lspec-tm-list
-   - @ref KLNetCoreDLD-lspec-bevq
-   - @ref KLNetCoreDLD-lspec-lnet-init
-   - @ref KLNetCoreDLD-lspec-reg
-   - @ref KLNetCoreDLD-lspec-tm-res
-   - @ref KLNetCoreDLD-lspec-buf-res
-   - @ref KLNetCoreDLD-lspec-ev
-   - @ref KLNetCoreDLD-lspec-recv
-   - @ref KLNetCoreDLD-lspec-send
-   - @ref KLNetCoreDLD-lspec-passive
-   - @ref KLNetCoreDLD-lspec-active
-   - @ref KLNetCoreDLD-lspec-lnet-cancel
-   - @ref KLNetCoreDLD-lspec-state
-   - @ref KLNetCoreDLD-lspec-thread
-   - @ref KLNetCoreDLD-lspec-numa
-
-   @subsection KLNetCoreDLD-lspec-comps Component Overview
-   The relationship between the various objects in the components of the LNet
-   transport and the networking layer is illustrated in the following UML
-   diagram.  @image html "../../net/lnet/lnet_xo.png" "LNet Transport Objects"
-
-   The Core layer in the kernel has no sub-components but interfaces directly
-   with the Lustre LNet module in the kernel.
-
-
-   @subsection KLNetCoreDLD-lspec-userspace Support for User Space Transports
-
-   The kernel Core module is designed to support user space transports with the
-   use of shared memory.  It does not directly provide a mechanism to
-   communicate with the user space transport, but expects that the user space
-   Core module will provide a device driver to communicate between user and
-   kernel space, manage the sharing of core data structures, and interface
-   between the kernel and user space implementations of the Core API.
-
-   The common Core data structures are designed to support such communication
-   efficiently:
-
-   - The core data structures are organized with a distinction between the
-     common directly shareable portions, and private areas for kernel and user
-     space data.  This allows each address space to place pointer values of its
-     address space in private regions associated with the shared data
-     structures.
-
-   - An address space opaque pointer type is provided to safely save pointer
-     values in shared memory locations where necessary.
-
-   - The single producer, single consumer circular buffer event queue shared
-     between the transport and the core layer in the kernel is designed to work
-     with the producer and consumer potentially in different address spaces.
-     This is described in further detail in @ref KLNetCoreDLD-lspec-bevq.
-
-
-   @subsection KLNetCoreDLD-lspec-match-bits Match Bits for Buffer Identification
-
-   The kernel Core module will maintain a unsigned integer counter per transfer
-   machine, to generate unique match bits for passive bulk buffers associated
-   with that transfer machine.  The upper 12 match bits are reserved by the HLD
-   to represent the transfer machine identifier. Therefore the counter is
-   (64-12)=52 bits wide. The value of 0 is reserved for unsolicited
-   receive messages, so the counter range is [1,0xfffffffffffff]. It is
-   initialized to 1 and will wrap back to 1 when it reaches its upper bound.
-
-   The transport uses the nlx_core_buf_passive_recv() or the
-   nlx_core_buf_passive_send() subroutines to stage passive buffers.  Prior
-   to initiating these operations, the transport should use the
-   nlx_core_buf_match_bits_set() subroutine to generate new match bits for
-   the passive buffer.  The match bit counter will repeat over time, though
-   after a very long while.  It is the transport's responsibility to ensure
-   that all of the passive buffers associated with a given transfer machine
-   have unique match bits.  The match bits should be encoded into the network
-   buffer descriptor associated with the passive buffer.
-
-
-   @subsection KLNetCoreDLD-lspec-tm-list Transfer Machine Uniqueness
-
-   The kernel Core module must ensure that all transfer machines on the host
-   have unique transfer machine identifiers, regardless of the transport
-   instance or network domain context in which these transfer machines are
-   created.  To support this, the ::nlx_kcore_tms list threads through all the
-   kernel Core's per-TM private data structures. This list is private to the
-   kernel Core, and is protected by the ::nlx_kcore_mutex.
-
-   The same list helps in assigning dynamic transfer machine identifiers.  The
-   highest available value at the upper bound of the transfer machine
-   identifier space is assigned dynamically.  The logic takes into account the
-   NID, PID and portal number of the new transfer machine when looking for an
-   available transfer machine identifier.  A single pass over the list is
-   required to search for an available transfer machine identifier.
-
-
-   @subsection KLNetCoreDLD-lspec-bevq The Buffer Event Queue
-
-   The kernel Core receives notification of the completion of a buffer
-   operation through an LNet callback.  The completion status is not directly
-   conveyed to the transport, because the transport layer may have processor
-   affinity constraints that are not met by the LNet callback thread; indeed,
-   LNet does not even state if this callback is in a schedulable context.
-
-   Instead, the kernel Core module decouples the delivery of buffer operation
-   completion to the transport from the LNet callback context by copying the
-   result to an intermediate buffer event queue.  The Core API provides the
-   nlx_core_buf_event_wait() subroutine that the transport can use to poll for
-   the presence of buffer events, and the nlx_core_buf_event_get() subroutine
-   to recover the payload of the next available buffer event. See @ref
-   KLNetCoreDLD-lspec-ev for further details on these subroutines.
-
-   There is another advantage to this indirect delivery: to address the
-   requirement to efficiently support a user space transport, the Core module
-   keeps this queue in memory shared between the transport and the Core,
-   eliminating the need for a user space transport to make an @c ioctl call to
-   fetch the buffer event payload.  The only @c ioctl call needed for a user
-   space transport is to block waiting for buffer events to appear in the
-   shared memory queue.
-
-   It is critical for proper operation, that there be an available buffer event
-   structure when the LNet callback is invoked, or else the event cannot be
-   delivered and will be lost.  As the event queue is in shared memory, it is
-   not possible, let alone desirable, to allocate a new buffer event structure
-   in the callback context.
-
-   The Core API guarantees the delivery of buffer operation completion status
-   by maintaining a "pool" of free buffer event structures for this purpose.
-   It does so by keeping count of the total number of buffer event structures
-   required to satisfy all outstanding operations, and adding additional such
-   structures to the "pool" if necessary, when a new buffer operation is
-   initiated.  Likewise, the count is decremented for each buffer event
-   delivered to the transport.  Most buffers operations only need a single
-   buffer event structure in which to return their operation result, but
-   receive buffers may need more, depending on the individually
-   configurable maximum number of messages that could be received in each
-   receive buffer.
-
-   The pool and queue potentially span the kernel and user address spaces.
-   There are two cases around the use of these data structures:
-
-   - Normal queue operation involves a single @a producer, in the kernel Core
-     callback subroutine, and a single @a consumer, in the Core API
-     nlx_core_buf_event_get() subroutine, which may be invoked either in
-     the kernel or in user space.
-
-   - The allocation of new buffer event structures to the "pool" is always done
-     by the Core API buffer operation initiation subroutines invoked by the
-     transport.  The user space implementation of the Core API would have to
-     arrange for these new structures to get mapped into the kernel at this
-     time.
-
-   The kernel Core module combines both the free "pool" and the result queue
-   into a single data structure: a circular, single producer, single consumer
-   buffer event queue.  Details on this event queue are covered in the
-   @ref LNetcqueueDLD "LNet Buffer Event Circular Queue DLD."
-
-   The design makes a critical simplifying assumption, in that the transport
-   will use exactly one thread to process events.  This assumption implicitly
-   serializes the delivery of the events associated with any given receive
-   buffer, thus the last event which unlinks the buffer is guaranteed to be
-   delivered after other events associated with that same buffer operation.
-
-
-   @subsection KLNetCoreDLD-lspec-lnet-init LNet Initialization and Finalization
-
-   No initialization and finalization logic is required for LNet in the kernel
-   for the following reasons:
-
-   - Use of the LNet kernel module is reference counted by the kernel.
-   - The LNetInit() subroutine is automatically called when then LNet kernel
-     module is loaded, and cannot be called multiple times.
-
-
-   @subsection KLNetCoreDLD-lspec-reg LNet Buffer Registration
-
-   No hardware optimization support is defined in the LNet API at this time but
-   the nlx_core_buf_register() subroutine serves as a placeholder where any
-   such optimizations could be made in the future.  The
-   nlx_core_buf_deregister() subroutine would be used to release any allocated
-   resources.
-
-   During buffer registration, the kernel Core API will translate the
-   c2_net_bufvec into the nlx_kcore_buffer::kb_kiov field of the buffer private
-   data.
-
-   @subsection KLNetCoreDLD-lspec-tm-res LNet Transfer Machine Resources
-
-   A transfer machine is associated with the following LNet resources:
-   - An Event Queue (EQ).  This is represented by the
-     nlx_kcore_transfer_mc::ktm_eqh handle.
-   - A Match Entry (ME) list. This is represented by the
-     nlx_kcore_transfer_mc::ktm_meh handle.
-
-   The nlx_core_tm_start() subroutine creates these resources, and the
-   nlx_core_tm_stop() subroutine releases them.
-
-   @subsection KLNetCoreDLD-lspec-buf-res LNet Buffer Resources
-
-   A network buffer is associated with a Match Descriptor (MD).  This is
-   represented by the nlx_kcore_buffer::kb_mdh handle.  There may be a Match
-   Entry (ME) associated with this MD for some operations, but when created, it
-   is set up to unlink automatically when the MD is unlinked so it is not
-   explicitly tracked.
-
-   All the buffer operation initiation subroutines of the kernel Core API
-   create this MD.  The MD is set up to explicitly unlink upon completion, but
-   the value is saved in case an operation needs to be cancelled.
-
-   @subsection KLNetCoreDLD-lspec-ev LNet Event Callback Processing
-
-   LNet event queues are used with an event callback subroutine to avoid event
-   loss.  The callback subroutine overhead is fairly minimal, as it only copies
-   out the event payload and arranges for subsequent asynchronous delivery.
-   This, coupled with the fact that the circular buffer used works optimally
-   with a single producer and single consumer resulted in the decision to use
-   just one LNet EQ per transfer machine (nlx_kcore_transfer_mc::ktm_eqh).
-   This EQ is created in the call to the nlx_core_tm_start() subroutine, and is
-   freed in the call to the nlx_core_tm_stop() subroutine.
-
-   LNet requires that the callback subroutine be re-entrant and
-   non-blocking. Given that the circular queue assumes a single producer and
-   single consumer, a spin lock is used to serialize access to the queue.
-
-   The event callback requires that the MD @c user_ptr field be set up to point
-   to the nlx_core_buffer data structure.  The callback subroutine does the
-   following:
-
-   -# It will ignore @c LNET_EVENT_SEND events.
-   -# It will assert that an @c LNET_EVENT_ACK events is not received. This is
-      controllable in the LNetPut() call.
-   -# It obtains the nlx_kcore_transfer_mc::ktm_bevq_lock spin lock.
-   -# The bev_cqueue_pnext() subroutine is then used to locate the next buffer
-      event structure in the circular buffer event queue which will be used to
-      return the result.
-   -# It copies the event payload from the LNet event to the buffer event
-      structure.  This includes the value of the @c unlinked field of the
-      event, which must be copied to the nlx_core_buffer_event::cbe_unlinked
-      field.  For @c LNET_EVENT_UNLINK events, a @c -ECANCELLED value is
-      written to the nlx_core_buffer_event::cbe_status field and the
-      nlx_core_buffer_event::cbe_unlinked field set to true.
-   -# It invokes the bev_cqueue_put() subroutine to "produce" the event in the
-      circular queue.
-   -# It releases the nlx_kcore_transfer_mc::ktm_bevq_lock spin lock.
-   -# It signals the nlx_kcore_transfer_mc::ktm_sem semaphore with the
-      c2_semaphore_up() subroutine.
-
-   The (single) transport layer event handler thread blocks on the Core
-   transfer machine semaphore in the Core API nlx_core_buf_event_wait()
-   subroutine which uses the c2_semaphore_timeddown() subroutine internally to
-   wait on the semaphore.  When the Core API subroutine returns with an
-   indication of the presence of events, the event handler thread consumes all
-   the pending events with multiple calls to the Core API
-   nlx_core_buf_event_get() subroutine, which uses the bev_cqueue_get()
-   subroutine internally to get the next buffer event.  Then the event handler
-   thread repeats the call to the nlx_core_buf_event_wait() subroutine to once
-   again block for additional events.
-
-   In the case of the user space transport, the blocking on the semaphore is
-   done indirectly by the user space Core API's device driver in the kernel.
-   It is required by the HLD that as many events as possible be consumed before
-   the next context switch to the kernel must be made.  To support this, the
-   kernel Core nlx_core_buf_event_wait() subroutine takes a few additional
-   steps to minimize the chance of returning when the queue is empty.  After it
-   obtains the semaphore with the c2_semaphore_timeddown() subroutine (i.e. the
-   @em P operation succeeds), it attempts to clear the semaphore count by
-   repeatedly calling the c2_semaphore_trydown() subroutine until it fails.  It
-   then checks the circular queue, and only if not empty will it return.  This
-   is illustrated with the following pseudo-code:
-   @code
-       do {
-          rc = c2_semaphore_timeddown(&sem, &timeout);
-          if (rc < 0)
-              break; // timed out
-          while (c2_semaphore_trydown(&sem))
-              ; // exhaust the semaphore
-       } while (bev_cqueue_is_empty(&q)); // loop if empty
-   @endcode
-   (The C++ style comments are used because of doxygen only - they are not
-   permitted by the Colibri style guide.)
-
-   @subsection KLNetCoreDLD-lspec-recv LNet Receiving Unsolicited Messages
-
-   -# Create an ME with @c LNetMEAttach() for the transfer machine and specify
-      the portal, match and ignore bits. All receive buffers for a given TM
-      will use a match bit value equal to the TM identifier in the higher order
-      bits and zeros for the other bits.  No ignore bits are set. The ME should
-      @b not be set up to unlink automatically as it will be used for all
-      receive buffers of this transfer machine.  Save the ME handle in the
-      nlx_kcore_transfer_mc::ktm_meh field.
-   -# Create and attach an MD to the ME using @c LNetMDAttach().
-      The MD is set up to unlink automatically.
-      Save the MD handle in the nlx_kcore_buffer::kb_mdh field.
-      Set up the fields of the @c lnet_md_t argument as follows:
-      - Set the @c eq_handle to identify the EQ associated with the transfer
-        machine (nlx_kcore_transfer_mc::ktm_eqh).
-      - Set the kernel logical address of the nlx_kcore_buffer in the
-        @c user_ptr field.
-      - Pass in the KIOV from the nlx_kcore_buffer::kb_kiov.
-      - Set the @c threshold value to the nlx_kcore_buffer::kb_max_recv_msgs
-        value.
-      - Set the @c max_size value to the nlx_kcore_buffer::kb_min_recv_size
-        value.
-      - Set the @c LNET_MD_OP_PUT, @c LNET_MD_MAX_SIZE and @c LNET_MD_KIOV
-        flags in the @c options field.
-   -# When a message arrives, an @c LNET_EVENT_PUT event will be delivered to
-      the event queue, and will be processed as described in
-      @ref KLNetCoreDLD-lspec-ev.
-
-
-   @subsection KLNetCoreDLD-lspec-send LNet Sending Messages
-
-   -# Create an MD using @c LNetMDBind() each invocation of the
-      nlx_core_buf_msg_recv() subroutine.
-      The MD is set up to unlink automatically.
-      Save the MD handle in the nlx_kcore_buffer::kb_mdh field.
-      Set up the fields of the @c lnet_md_t argument as follows:
-      - Set the @c eq_handle to identify the EQ associated with the transfer
-        machine (nlx_kcore_transfer_mc::ktm_eqh).
-      - Set the kernel logical address of the nlx_kcore_buffer in the
-        @c user_ptr field.
-      - Pass in the KIOV from the nlx_kcore_buffer::kb_kiov.
-      - Set the @c LNET_MD_KIOV flag in the @c options field.
-   -# Use the @c LNetPut() subroutine to send the MD to the destination.  The
-      match bits must set to the destination TM identifier in the higher order
-      bits and zeros for the other bits. No acknowledgment should be
-      requested.
-   -# When the message is sent, an @c LNET_EVENT_SEND event will be delivered
-      to the event queue, and processed as described in
-      @ref KLNetCoreDLD-lspec-ev.
-
-
-   @subsection KLNetCoreDLD-lspec-passive LNet Staging Passive Bulk Buffers
-
-   -# Prior to invoking the nlx_core_buf_passive_recv() or the
-      nlx_core_buf_passive_send() subroutines, the transport should use the
-      nlx_core_buf_match_bits_set() subroutine to assign unique match bits to
-      the passive buffer. See @ref KLNetCoreDLD-lspec-match-bits for details.
-      The match bits should be encoded into the network buffer descriptor and
-      independently conveyed to the remote active transport.
-   -# Create an ME using @c LNetMEAttach(). Specify the portal and match_id
-      fields as appropriate for the transfer machine.  The buffer's match bits
-      are obtained from the nlx_core_buffer::cb_match_bits field.  No ignore
-      bits are set. The ME should be set up to unlink automatically, so there
-      is no need to save the handle for later use.
-   -# Create and attach an MD to the ME using @c LNetMDAttach() with each
-      invocation of the nlx_core_buf_passive_recv() or the
-      nlx_core_buf_passive_send() subroutines.
-      The MD is set up to unlink automatically.
-      Save the MD handle in the nlx_kcore_buffer::kb_mdh field.
-      Set up the fields of the @c lnet_md_t argument as follows:
-      - Set the @c eq_handle to identify the EQ associated with the transfer
-        machine (nlx_kcore_transfer_mc::ktm_eqh).
-      - Set the kernel logical address of the nlx_kcore_buffer in the
-        @c user_ptr field.
-      - Pass in the KIOV from the nlx_kcore_buffer::kb_kiov.
-      - Set the @c LNET_MD_KIOV flag in the @c options field, along with either
-        the @c LNET_MD_OP_PUT or the @c LNET_MD_OP_GET flag according to the
-	direction of data transfer.
-   -# When the bulk data transfer completes, either an @c LNET_EVENT_PUT or an
-      @c LNET_EVENT_GET event will be delivered to the event queue, and will be
-      processed as described in @ref KLNetCoreDLD-lspec-ev.
-
-
-   @subsection KLNetCoreDLD-lspec-active LNet Active Bulk Read or Write
-
-   -# Prior to invoking the nlx_core_buf_active_recv() or
-      nlx_core_buf_active_send() subroutines, the
-      transport should put the match bits of the remote passive buffer into the
-      nlx_core_buffer::cb_match_bits field. The destination address of the
-      remote transfer machine with the passive buffer should be set in the
-      nlx_core_buffer::cb_passive_addr field.
-   -# Create an MD using @c LNetMDBind() with each invocation of the
-      nlx_core_buf_active_recv() or nlx_core_buf_active_send() subroutines.
-      The MD is set up to unlink automatically.
-      Save the MD handle in the nlx_kcore_buffer::kb_mdh field.
-      Set up the fields of the @c lnet_md_t argument as follows:
-      - Set the @c eq_handle to identify the EQ associated with the transfer
-        machine (nlx_kcore_transfer_mc::ktm_eqh).
-      - Set the kernel logical address of the nlx_kcore_buffer in the
-        @c user_ptr field.
-      - Pass in the KIOV from the nlx_kcore_buffer::kb_kiov.
-      - Set the @c LNET_MD_KIOV flag in the @c options field.
-   -# Use the @c LNetGet() subroutine to initiate the active read or the @c
-      LNetPut() subroutine to initiate the active write. No acknowledgment
-      should be requested.
-   -# When a response to the @c LNetGet() or @c LNetPut() call completes, an @c
-      LNET_EVENT_SEND event will be delivered to the event queue and should be
-      ignored.  See @ref KLNetCoreDLD-lspec-ev for details.
-   -# When the bulk data transfer completes, an @c LNET_EVENT_REPLY event will
-      be delivered to the event queue, and will be processed as described in
-      @ref KLNetCoreDLD-lspec-ev.
-
-
-   @subsection KLNetCoreDLD-lspec-lnet-cancel LNet Canceling Operations
-
-   The kernel Core module provides no timeout capability.  The transport may
-   initiate a cancel operation using the nlx_core_buf_del() subroutine.
-
-   This will result in an @c LNetMDUnlink() subroutine call being issued for
-   the buffer MD saved in the nlx_kcore_buffer::kb_mdh field.
-   Cancellation may or may not take place - it depends upon whether the
-   operation has started, and there is a race condition in making this call and
-   concurrent delivery of an event associated with the MD.
-
-   Assuming success, the next event delivered for the buffer concerned will
-   either be a @c LNET_EVENT_UNLINK event or the @c unlinked field will be set
-   in the next completion event for the buffer.  The events will be processed
-   as described in @ref KLNetCoreDLD-lspec-ev.
-
-   LNet properly handles the race condition between the automatic unlink of the
-   MD and a call to LNetMDUnlink().
-
-
-   @subsection KLNetCoreDLD-lspec-state State Specification
-   - The kernel Core module relies on the networking data structures to maintain
-   the linkage between the data structures used by the Core module. It
-   maintains no lists through data structures itself.  As such, these lists can
-   only be navigated by the Core API subroutines invoked by the transport (the
-   "upper" layer) and not by the Core module's LNet callback subroutine (the
-   "lower" layer).
-
-   - The kernel Core API maintains a count of the total number of buffer event
-   structures needed.  This should be tested by the Core API's transfer machine
-   invariant subroutine before returning from any buffer operation initiation
-   call, and before returning from the nlx_core_buf_event_get() subroutine.
-
-   - The kernel Core layer module depends on the LNet module in the kernel at
-   run time. This dependency is captured by the Linux kernel module support that
-   reference counts the usage of dependent modules.
-
-
-   @subsection KLNetCoreDLD-lspec-thread Threading and Concurrency Model
-   -# Generally speaking, API calls within the transport address space
-      are protected by the serialization of the Colibri Networking layer,
-      typically the transfer machine mutex or the domain mutex.
-      The nlx_core_buf_match_bits_set() subroutine, for example, is fully
-      protected by the transfer machine mutex held across the
-      c2_net_buffer_add() subroutine call, so implicitly protects the match bit
-      counter in the kernel Core's per TM private data.
-   -# The Colibri Networking layer serialization does not always suffice, as
-      the kernel Core module has to support concurrent multiple transport
-      instances in kernel and user space.  Fortunately, the LNet API
-      intrinsically provides considerable serialization support to the Core, as
-      transfer machines are defined by the HLD to have disjoint addresses.
-   -# Enforcement of the disjoint address semantics are protected by the
-      kernel Core's ::nlx_kcore_mutex lock.  The nlx_core_tm_start() and
-      nlx_core_tm_stop() subroutines use this mutex internally for serialization
-      and operation on the ::nlx_kcore_tms list threaded through the kernel
-      Core's per-TM private data.
-   -# The kernel Core module registers a single callback subroutine with the
-      LNet EQ defined per transfer machine. LNet requires that this subroutine
-      be reentrant and non-blocking.  The circular buffer event queue accessed
-      from the callback requires a single producer, so the
-      nlx_kcore_transfer_mc::ktm_bevq_lock spin lock is used to serialize its
-      use across possible concurrent invocations.  The time spent in the lock
-      is minimal.
-   -# The Core API does not support callbacks to indicate completion of an
-      asynchronous buffer operation.  Instead, the transport application must
-      invoke the nlx_core_buf_event_wait() subroutine to block waiting for
-      buffer events.  Internally this call waits on the
-      nlx_kcore_transfer_mc::ktm_sem semaphore.  The semaphore is
-      incremented each time an event is added to the buffer even437t queue.
-   -# The event payload is actually delivered via a per transfer machine
-      single producer, single consumer, lock-free circular buffer event queue.
-      The only requirement for failure free operation is to ensure that there
-      are sufficient event structures pre-allocated to the queue, plus one more
-      to support the circular semantics.  Multiple events may be dequeued
-      between each call to the nlx_core_buf_event_wait() subroutine.  Each such
-      event is fetched by a call to the nlx_core_buf_event_get() subroutine,
-      until the queue is exhausted.  Note that the queue exists in memory
-      shared between the transport and the kernel Core; the transport could be
-      in the kernel or in user space.
-   -# The API assumes that only a single transport thread will handle event
-      processing.  This is a critical assumption in the support for multiple
-      messages in a single receive buffer, as it implicitly serializes the
-      delivery of the events associated with any given receive buffer, thus the
-      last event which unlinks the buffer is guaranteed to be delivered last.
-   -# LNet properly handles the race condition between the automatic unlink
-      of the MD and a call to LNetMDUnlink().
-
-   @subsection KLNetCoreDLD-lspec-numa NUMA optimizations
-   The LNet transport will initiate calls to the API on threads that may have
-   specific process affinity assigned.
-
-   LNet offers no direct NUMA optimizations.  In particular, event callbacks
-   cannot be constrained to have any specific processor affinity.  The API
-   compensates for this lack of support by providing a level of indirection in
-   event delivery: its callback handler simply copies the LNet event payload to
-   an event delivery queue and notifies a transport event processing thread of
-   the presence of the event. (See @ref KLNetCoreDLD-lspec-bevq above). The
-   transport event processing threads can be constrained to have any desired
-   processor affinity.
-
-   <hr>
-   @section KLNetCoreDLD-conformance Conformance
-   - @b i.c2.net.lnet.buffer-registration See @ref KLNetCoreDLD-lspec-reg.
-
-   - @b i.c2.net.xprt.lnet.end-point-address The nlx_core_ep_addr_encode()
-     and nlx_core_ep_addr_decode() provide this functionality.
-
-   - @b i.c2.net.xprt.lnet.multiple-messages-in-buffer See @ref
-     KLNetCoreDLD-lspec-recv.
-
-   - @b i.c2.net.xprt.lnet.dynamic-address-assignment See @ref
-     KLNetCoreDLD-lspec-tm-list.
-
-   - @b i.c2.net.xprt.lnet.user-space See @ref KLNetCoreDLD-lspec-userspace.
-
-   - @b i.c2.net.xprt.lnet.user.no-gpl See the @ref LNetCoreDLD-fspec
-     "Functional Specification"; no LNet headers are exposed by the Core API.
-
-   <hr>
-   @section KLNetCoreDLD-ut Unit Tests
-   The testing strategy is 2 pronged:
-   - Tests with a fake LNet API.  These tests will intercept the LNet
-     subroutine calls.  The real LNet data structures will be used by the Core
-     API.
-   - Tests with the real LNet API using the TCP loop back address.  These tests
-     will use the TCP loop back address.  LNet on the test machine must be
-     configured with the @c "tcp" network.
-
-   @test The correct sequence of LNet operations are issued for each type
-         of buffer operation with a fake LNet API.
-
-   @test The callback subroutine properly delivers events to the buffer
-         event queue, including single and multiple events for receive buffers
-         with a fake LNet API.
-
-   @test The dynamic assignment of transfer machine identifiers with a fake LNet
-         API.
-
-   @test Test the parsing of LNet addresses with the real LNet API.
-
-   @test Test each type of buffer operation, including single and multiple
-         events for receive buffers with the real LNet API.
-
-   <hr>
-   @section KLNetCoreDLD-st System Tests
-   System testing will be performed as part of the transport operation system
-   test.
-
-   <hr>
-   @section KLNetCoreDLD-O Analysis
-   - Dynamic transfer machine identifier assignment is proportional to the
-   number of transfer machines defined on the server, including kernel and all
-   process space LNet transport instances.
-   - The time taken to process an LNet event callback is in constant time.
-   - The time taken for the transport to dequeue a pending buffer event
-   depends upon the operating system scheduler.  The algorithmic
-   processing involved is in constant time.
-   - The time taken to register a buffer is in constant time.
-   - The time taken to process outbound buffer operations is unpredictable,
-   and depends, at the minimum, on current system load, other LNet users,
-   and on the network load.
-
-   <hr>
-   @section KLNetCoreDLD-ref References
-   - <a href="https://docs.google.com/a/xyratex.com/document/d/1TZG__XViil3ATbWICojZydvKzFNbL7-JJdjBbXTLgP4/edit?hl=en_US">HLD of Colibri LNet Transport</a>
-   - The LNet API.
-
-*/
-
-/*
- ******************************************************************************
- End of DLD
- ******************************************************************************
- */
-
-#include "lib/mutex.h"
-#include "net/lnet/linux_kernel/klnet_core.h"
-
-/**
-   @addtogroup KLNetCore
-   @{
-*/
-
-/**
-   Kernel core lock.
-   Provides serialization across the nlx_kcore_tms list.
- */
-static c2_mutex nlx_kcore_mutex;
-
-/** List of all transfer machines. Protected by nlx_kcore_mutex. */
-static struct c2_tl nlx_kcore_tms;
-
-
-/**
-   @}
-*/
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 79
- *  scroll-step: 1
- *  End:
- */
diff --git a/net/lnet/linux_kernel/klnet_core.h b/net/lnet/linux_kernel/klnet_core.h
deleted file mode 100644
index 281d6c2..0000000
--- a/net/lnet/linux_kernel/klnet_core.h
+++ /dev/null
@@ -1,126 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Carl Braganza <Carl_Braganza@us.xyratex.com>
- *                  Dave Cohrs <Dave_Cohrs@us.xyratex.com>
- * Original creation date: 11/01/2011
- *
- */
-#ifndef __COLIBRI_NET_KLNET_CORE_H__
-#define __COLIBRI_NET_KLNET_CORE_H__
-
-/**
-   @defgroup KLNetCore LNet Transport Core Kernel Private Interface
-   @ingroup LNetCore
-
-   @{
-*/
-
-#include "lib/semaphore.h"
-#include "lib/tlist.h"
-#include "lnet/include/lnet/types.h"
-#include "net/lnet/lnet_core.h"
-
-#include <linux/spinlock.h>
-
-enum {
-	C2_NET_LNET_KCORE_TM_MAGIC  = 0x4b436f7265544dULL,   /* KCoreTM */
-	C2_NET_LNET_KCORE_BUF_MAGIC = 0x4b436f7265427566ULL, /* KCoreBuf */
-};
-
-/**
-   Kernel transfer machine private data.
-   This structure is pointed to by c2_lnet_core_transfer_mc::lctm_kpvt.
-*/
-struct nlx_kcore_transfer_mc {
-	uint64_t                         ktm_magic;
-
-	/**
-	   Kernel pointer to the shared memory TM structure.
-	 */
-	struct c2_lnet_core_transfer_mc *ktm_tm;
-
-	/** Transfer machine linkage */
-	struct c2_tlink                  ktm_tm_linkage;
-
-	/**
-	   Match bit counter. Range [1,C2_NET_LNET_MATCH_BIT_MAX].
-	 */
-	uint64_t                         ktm_mb_counter;
-
-	/**
-	   Spin lock to serialize access to the buffer event queue
-	   from the LNet callback subroutine.
-	 */
-	spinlock_t                       ktm_bevq_lock;
-
-	/**
-	   This semaphore increments with each LNet event added.
-
-	*/
-	struct c2_semaphore              ktm_sem;
-
-	/** Handle of the LNet EQ associated with this transfer machine */
-	lnet_handle_eq_t                 ktm_eqh;
-
-	/** ME handle associated with the receive buffer queue */
-	lnet_handle_me_t                 ktm_meh;
-
-};
-
-
-/**
-   Kernel buffer private data.
-   This structure is pointed to by c2_lnet_core_buffer::lcb_kpvt.
-*/
-struct nlx_kcore_buffer {
-	uint64_t                      kb_magic;
-
-	/** Mimumum space remaining for re-use of the receive buffer.
-	    The value is set from c2_net_buffer::nb_min_receive_size.
-	 */
-	c2_bcount_t                   kb_min_recv_size;
-
-	/** Maximum number of messages that may be received in the buffer.
-	    The value is set from c2_net_buffer::nb_max_receive_msgs.
-	 */
-	uint32_t                      kb_max_recv_msgs;
-
-	/** Pointer to kernel core TM data. */
-	struct nlx_kcore_transfer_mc *kb_ktm;
-
-	/** The I/O vector. */
-	struct lnet_kiov_t            kb_kiov;
-
-	/** MD handle */
-	lnet_handle_md_t              kb_mdh;
-};
-
-/**
-   @}
-*/
-
-#endif /* __COLIBRI_NET_KLNET_CORE_H__ */
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 79
- *  scroll-step: 1
- *  End:
- */
diff --git a/net/lnet/lnet.h b/net/lnet/lnet.h
deleted file mode 100644
index ac71155..0000000
--- a/net/lnet/lnet.h
+++ /dev/null
@@ -1,100 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Carl Braganza <Carl_Braganza@us.xyratex.com>
- *                  Dave Cohrs <Dave_Cohrs@us.xyratex.com>
- * Original creation date: 11/01/2011
- */
-#ifndef __COLIBRI_NET_LNET_H__
-#define __COLIBRI_NET_LNET_H__
-
-/**
-   @page LNetDLD-fspec LNet Transport Functional Specification
-
-   - @ref LNetDLD-fspec-ds
-   - @ref LNetDLD-fspec-sub
-
-   @section LNetDLD-fspec-ds Data Structures
-   The module implements a network transport protocol using the data structures
-   defined by @ref net/net.h.
-
-   The LNet transport is defined by the ::c2_net_lnet_xprt data structure.
-   The address of this variable should be provided to the c2_net_domain_init()
-   subroutine.
-
-
-   @section LNetDLD-fspec-sub Subroutines
-   New subroutine provided:
-   - c2_net_lnet_ep_addr_net_cmp()
-     Compare the network portion of two LNet transport end point addresses.
-     It is intended for use by the Request Handler setup logic.
-
-   The use of this subroutine is not mandatory.
-
-   @see @ref net "Networking"                     <!-- net/net.h -->
-   @see @ref LNetDLD "LNet Transport DLD"         <!-- net/lnet/lnet_main.c -->
-   @see @ref LNetDFS "LNet Transport"   <!-- below -->
-
- */
-
-/**
-   @defgroup LNetDFS LNet Transport
-   @ingroup net
-
-   The external interfaces of the LNet transport are obtained by
-   including the file @ref net/lnet/lnet.h.
-
-   @see @ref LNetDLD "LNet Transport DLD"
-
-   @{
-*/
-#include "net/net.h"
-
-/**
-   The LNet transport is used by specifying this data structure to the
-   c2_net_domain_init() subroutine.
- */
-extern struct c2_net_xprt c2_net_lnet_xprt;
-
-enum {
-	/** Max LNet ep addr length
-	    @todo Determine exact value for a 4-tuple LNet EP addr
-	*/
-	C2_NET_LNET_XEP_ADDR_LEN = 80,
-};
-
-/**
-   Subroutine compares the network portions of two LNet end point address
-   strings.
-   @retval int Return value like strcmp().
- */
-int c2_net_lnet_ep_addr_net_cmp(const char *addr1, const char *addr2);
-
-/**
-   @} LNetDFS end group
-*/
-
-#endif /* __COLIBRI_NET_LNET_H__ */
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 79
- *  scroll-step: 1
- *  End:
- */
diff --git a/net/lnet/lnet_core.h b/net/lnet/lnet_core.h
deleted file mode 100644
index 44ba06c..0000000
--- a/net/lnet/lnet_core.h
+++ /dev/null
@@ -1,640 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Carl Braganza <Carl_Braganza@us.xyratex.com>
- *                  Dave Cohrs <Dave_Cohrs@us.xyratex.com>
- * Original creation date: 11/01/2011
- *
- */
-#ifndef __COLIBRI_NET_LNET_CORE_H__
-#define __COLIBRI_NET_LNET_CORE_H__
-
-/**
-   @page LNetCoreDLD-fspec LNet Transport Core Functional Specfication
-
-   - @ref LNetCoreDLD-fspec-ovw
-   - @ref LNetCoreDLD-fspec-ds
-   - @ref LNetCoreDLD-fspec-subs
-   - @ref LNetCore "LNet Transport Core Interface"
-
-   @section LNetCoreDLD-fspec-ovw API Overview
-   The LNet Transport Core presents an address space agnostic API to the LNet
-   Transport layer.  These interfaces are declared in the file
-   @ref net/lnet/lnet_core.h.
-
-   The interface is implemented differently in the kernel and in user space.
-   The kernel interface interacts directly with LNet; the user space interface
-   uses a device driver to communicate with its kernel counterpart and
-   uses shared memory to avoid event data copy.
-
-   The Core API offers no callback mechanism.  Instead, the transport must
-   poll for events.  Typically this is done on one or more dedicated threads,
-   which exhibit the desired processor affiliation required by the higher
-   software layers.
-
-   The following sequence diagram illustrates the typical operational flow:
-   @msc
-   A [label="Application"],
-   N [label="Network"],
-   x [label="XO Method"],
-   t [label="XO Event\nThread"],
-   o [label="Core\nOps"],
-   e [label="Core\nEvent Queue"],
-   L [label="LNet\nOps"],
-   l [label="LNet\nCallback"];
-
-   t=>e  [label="Wait"];
-   ...;
-   A=>N  [label="c2_net_buffer_add()"];
-   N=>x  [label="xo_buf_add()"];
-   x=>o  [label="nlx_core_buf_op()"];
-   o=>L  [label="MD Operation"];
-   L>>o;
-   o>>x;
-   x>>N;
-   N>>A;
-   ...;
-   l=>>e [label="EQ callback"];
-   e>>t  [label="Events present"];
-   t=>e  [label="Get Event"];
-   e>>t  [label="event"];
-   N<<=t [label="c2_net_buffer_event_post()"];
-   N=>>A [label="callback"];
-   t=>e  [label="Get Event"];
-   e>>t  [label="empty"];
-   t=>e  [label="Wait"];
-   ...;
-   @endmsc
-
-   @section LNetCoreDLD-fspec-ds API Data Structures
-   The API requires that the transport application maintain API defined shared
-   data for various network related objects:
-   - nlx_core_domain
-   - nlx_core_transfer_mc
-   - nlx_core_buffer
-
-   The sharing takes place between the transport layer and the core layer.
-   This will span the kernel and user address space boundary when using the
-   user space transport.
-
-   These shared data structures should be embedded in the transport
-   application's own private data.  This requirement results in an
-   initialization call pattern that takes a pointer to the standard network
-   layer data structure concerned and a pointer to the API's data structure.
-
-   Subsequent calls to the API only pass the API data structure pointer.  The
-   API data structure must be eventually finalized.
-
-   @section LNetCoreDLD-fspec-subs Subroutines
-   The API subroutines are categorized as follows:
-
-   - Initialization, finalization, cancellation and query subroutines:
-     - nlx_core_buf_deregister()
-     - nlx_core_buf_register()
-     - nlx_core_dom_fini()
-     - nlx_core_dom_init()
-     - nlx_core_get_max_buffer_segment_size()
-     - nlx_core_get_max_buffer_size()
-     - nlx_core_tm_start()
-     - nlx_core_tm_stop()
-     .
-     These interfaces have names roughly similar to the associated
-     c2_net_xprt_ops method from which they are intended to be directly or
-     indirectly invoked.  Note that there are no equivalents for the @c
-     xo_tm_init(), @c xo_tm_fini() and @c xo_tm_confine() calls.
-
-   - End point address parsing subroutines:
-     - nlx_core_ep_addr_decode()
-     - nlx_core_ep_addr_encode()
-
-   - Buffer operation related subroutines:
-     - nlx_core_buf_active_recv()
-     - nlx_core_buf_active_send()
-     - nlx_core_buf_del()
-     - nlx_core_buf_msg_recv()
-     - nlx_core_buf_msg_send()
-     - nlx_core_buf_passive_recv()
-     - nlx_core_buf_passive_send()
-     - nlx_core_buf_match_bits_set()
-     .
-     The buffer operation initiation calls are all invoked in the context of
-     the c2_net_buffer_add() subroutine.  All operations are immediately
-     initiated in the Lustre LNet kernel module, though results will be
-     returned asynchronously through buffer events.
-
-   - Event processing calls:
-     - nlx_core_buf_event_wait()
-     - nlx_core_buf_event_get()
-     .
-     The API assumes that only a single transport thread will be used to
-     process events.
-
-   Invocation of the buffer operation initiation subroutines and the
-   nlx_core_buf_event_get() subroutine should be serialized.
-
-   @see @ref KLNetCoreDLD "LNet Transport Kernel Core DLD"
-   @see @ref ULNetCoreDLD "LNet Transport User Space Core DLD"
-
- */
-
-/**
-   @defgroup LNetCore LNet Transport Core Interface
-   @ingroup LNetDFS
-
-   The internal, address space agnostic I/O API used by the LNet transport.
-
-   @see @ref LNetCoreDLD-fspec "LNet Transport Core Functional Specification"
-
-   @{
- */
-
-#include "net/lnet/lnet.h"
-
-/* forward references */
-struct nlx_core_bev_link;
-struct nlx_core_bev_cqueue;
-struct nlx_core_buffer;
-struct nlx_core_buffer_event;
-struct nlx_core_domain;
-struct nlx_core_ep_addr;
-struct nlx_core_transfer_mc;
-
-/**
-   Opaque type wide enough to represent an address in any address space.
- */
-typedef uint64_t nlx_core_opaque_ptr_t;
-C2_BASSERT(sizeof(nlx_core_opaque_ptr_t) >= sizeof(void *));
-
-/**
-   This structure defines the fields in an LNet transport end point address.
- */
-struct nlx_core_ep_addr {
-	uint64_t cepa_nid;   /**< The LNet Network Identifier */
-	uint32_t cepa_pid;   /**< The LNet Process Identifier */
-	uint32_t cepa_portal;/**< The LNet Portal Number */
-	uint32_t cepa_tmid;  /**< The Transfer Machine Identifier */
-};
-
-/* Match bit related definitions */
-enum {
-	/** Number of bits used for TM identifier */
-	C2_NET_LNET_TMID_BITS      = 12,
-	/** Shift to the TMID position (52) */
-	C2_NET_LNET_TMID_SHIFT     = 64 - C2_NET_LNET_TMID_BITS,
-	/** Max TM identifier is 2^12-1 (4095) */
-	C2_NET_LNET_TMID_MAX       = (1 << C2_NET_LNET_TMID_BITS) - 1,
-	/** Invalid value used for dynamic addressing */
-	C2_NET_LNET_TMID_INVALID   = C2_NET_LNET_TMID_MAX+1,
-	/** Number of bits used for buffer identification (52) */
-	C2_NET_LNET_BUFFER_ID_BITS = 64 - C2_NET_LNET_TMID_BITS,
-	/** Minimum buffer match bit counter value */
-	C2_NET_LNET_BUFFER_ID_MIN  = 1,
-	/** Maximum buffer match bit counter value: 2^52-1 (0xfffffffffffff) */
-	C2_NET_LNET_BUFFER_ID_MAX  = (1ULL << C2_NET_LNET_BUFFER_ID_BITS) - 1,
-};
-C2_BASSERT(C2_NET_LNET_TMID_BITS + C2_NET_LNET_BUFFER_ID_BITS <= 64);
-
-/**
-   Buffer events are linked in the buffer queue using this structure. It is
-   designed to be operated upon from either kernel or user space with a single
-   producer and single consumer.
- */
-struct nlx_core_bev_link {
-	/**
-	   Self pointer in the consumer (transport) address space.
-	 */
-	nlx_core_opaque_ptr_t cbl_c_self;
-
-	/**
-	   Self pointer in the producer (kernel) address space.
-	 */
-	nlx_core_opaque_ptr_t cbl_p_self;
-
-	/**
-	   Pointer to the next element in the consumer address space.
-	 */
-	nlx_core_opaque_ptr_t cbl_c_next;
-
-	/**
-	   Pointer to the next element in the producer address space.
-	 */
-	nlx_core_opaque_ptr_t cbl_p_next;
-};
-
-/**
-   Buffer event queue, operable from either kernel and user space
-   with a single producer and single consumer.
- */
-struct nlx_core_bev_cqueue {
-	/**
-	   Number of elements currently in the queue.
-	 */
-	size_t                 cbcq_nr;
-
-	/**
-	   The producer adds links to this anchor.
-	   The producer pointer value is in the address space of the
-	   producer (kernel).
-	 */
-	nlx_core_opaque_ptr_t cbcq_producer;
-
-	/**
-	   The consumer removes elements from this anchor.
-	   The consumer pointer value is in the address space of the
-	   consumer (transport).
-	 */
-	nlx_core_opaque_ptr_t cbcq_consumer;
-};
-
-/**
-   This structure describes a buffer event. It is very similar to
-   struct c2_net_buffer_event.
- */
-struct nlx_core_buffer_event {
-	/** Linkage in one of the TM buffer event queues */
-	struct nlx_core_bev_link     cbe_tm_link;
-
-	/**
-	    This value is set by the kernel Core module's LNet event handler,
-	    and is copied from the nlx_core_buffer::cb_buffer_id
-	    field. The value is a pointer to the core buffer data in the
-	    transport address space, and is provided to enable the transport
-	    to navigate back to its outer buffer private data and from there
-	    back to the c2_net_buffer.
-	 */
-	nlx_core_opaque_ptr_t        cbe_core_buf;
-
-	/** Event timestamp */
-	c2_time_t                    cbe_time;
-
-	/** Status code (-errno). 0 is success */
-	int32_t                      cbe_status;
-
-	/** Length of data in the buffer */
-	c2_bcount_t                  cbe_length;
-
-	/** Offset of start of the data in the buffer. (Receive only) */
-	c2_bcount_t                  cbe_offset;
-
-	/** Address of the other end point */
-	struct nlx_core_ep_addr      cbe_sender;
-
-	/** True if the buffer is no longer in use */
-        bool                         cbe_unlinked;
-};
-
-/**
-   Core domain data.  The transport layer should embed this in its private data.
-*/
-struct nlx_core_domain {
-
-	void *cd_upvt; /**< Core user space private */
-	void *cd_kpvt; /**< Core kernel space private */
-
-};
-
-/**
-   Core transfer machine data.  The transport layer should embed this in its
-   private data.
-*/
-struct nlx_core_transfer_mc {
-	/** The transfer machine address */
-	struct c2_lnet_ep_addr     ctm_addr;
-
-	/** Boolean indicating if the transport is running in user space. */
-	bool                       ctm_user_space_xo;
-
-	/**
-	   List of available buffer event structures.  The queue is shared
-	   between the transport address space and the kernel.
-
-	   The transport is responsible for ensuring that there are sufficient
-	   free entries to return the results of all pending operations.
-	 */
-	struct nlx_core_bev_cqueue ctm_free_bevq;
-
-	/**
-	   Buffer completion event queue.  The queue is shared between the
-	   transport address space and the kernel.
-	 */
-	struct nlx_core_bev_cqueue ctm_bevq;
-
-	void                      *ctm_upvt; /**< Core user space private */
-	void                      *ctm_kpvt; /**< Core kernel space private */
-};
-
-/**
-   Core buffer data.  The transport layer should embed this in its private data.
-*/
-struct nlx_core_buffer {
-	/**
-	   The address of the c2_net_buffer structure in the transport address
-	   space. The value is set by the nlx_core_buffer_register()
-	   subroutine.
-	 */
-	nlx_core_opaque_ptr_t   cb_buffer_id;
-
-	/**
-	   The buffer queue type - copied from c2_net_buffer::nb_qtype
-	   when the buffer operation is initiated.
-	 */
-        enum c2_net_queue_type  cb_qtype;
-
-	/**
-	   The match bits for a passive bulk buffer, including the TMID field.
-	   They should be set using the nlx_core_buf_match_bits_set()
-	   subroutine.
-
-	   The file is also used in an active buffer to describe the match
-	   bits of the remote passive buffer.
-	 */
-	uint64_t                cb_match_bits;
-
-	/**
-	   The address of the destination transfer machine is set in this field
-	   for buffers on the C2_NET_QT_MSG_SEND queue.
-
-	   The address of the remote passive transfer machine is set in this
-	   field for buffers on the C2_NET_QT_ACTIVE_BULK_SEND or
-	   C2_NET_QT_ACTIVE_BULK_RECV queues.
-	 */
-	struct nlx_core_ep_addr cb_addr;
-
-	void                   *cb_upvt; /**< Core user space private */
-	void                   *cb_kpvt; /**< Core kernel space private */
-};
-
-
-/**
-   Allocates and initializes the network domain's private field for use by LNet.
-   @param dom The network domain pointer.
-   @param lcdom The private data pointer for the domain to be initialized.
- */
-static int nlx_core_dom_init(struct c2_net_domain *dom,
-			     struct nlx_core_domain *lcdom);
-
-/**
-   Releases LNet transport resources related to the domain.
- */
-static int nlx_core_dom_fini(struct nlx_core_domain *lcdom);
-
-/**
-   Gets the maximum buffer size (counting all segments).
- */
-static c2_bcount_t nlx_core_get_max_buffer_size(struct nlx_core_domain *lcdom);
-
-/**
-   Gets the maximum size of a buffer segment.
- */
-static c2_bcount_t nlx_core_get_max_buffer_segment_size(struct
-							nlx_core_domain *lcdom);
-
-/**
-   Gets the maximum number of buffer segments.
- */
-static int32_t nlx_core_get_max_buffer_segments(struct nlx_core_domain *lcdom);
-
-/**
-   Registers a network buffer.  In user space this results in the buffer memory
-   getting pinned.
-   The subroutine allocates private data to associate with the network buffer.
-   @param lcdom The domain private data to be initialized.
-   @param buf The network buffer pointer with its nb_dom field set.
-   @param lcbuf The core private data pointer for the buffer.
-   @pre buf->nb_dom != NULL
- */
-static int nlx_core_buf_register(struct nlx_core_domain *lcdom,
-				 struct c2_net_buffer *buf,
-				 struct nlx_core_buffer *lcbuf);
-
-/**
-   Deregisters the buffer.
-   @param lcdom The domain private data to be initialized.
-   @param lcbuf The buffer private data.
- */
-static int nlx_core_buf_deregister(struct nlx_core_domain *lcdom,
-				   struct nlx_core_buffer *lcbuf);
-
-/**
-   Enqueues a buffer for message reception. Multiple messages may be received
-   into the buffer, space permitting, up to the configured maximum.
-
-   The invoker should ensure that the subroutine is not invoked concurrently
-   with any of the other buffer operation initiation subroutines or the
-   nlx_core_buf_event_get() subroutine.
-
-   @param lctm  Transfer machine private data.
-   @param lcbuf Buffer private data.
- */
-static int nlx_core_buf_msg_recv(struct nlx_core_transfer_mc *lctm,
-				 struct nlx_core_buffer *lcbuf);
-
-/**
-   Enqueues a buffer for message transmission.
-
-   The invoker should ensure that the subroutine is not invoked concurrently
-   with any of the other buffer operation initiation subroutines or the
-   nlx_core_buf_event_get() subroutine.
-
-   @param lctm  Transfer machine private data.
-   @param lcbuf Buffer private data.
-   @pre lcbuf->cb_addr is valid
- */
-static int nlx_core_buf_msg_send(struct nlx_core_transfer_mc *lctm,
-				 struct nlx_core_buffer *lcbuf);
-
-/**
-   Enqueues a buffer for active bulk receive.
-   The cb_match_bits field should be set to the value of the match bits of the
-   remote passive buffer.
-   The cb_addr field should be set with the end point address of the
-   transfer machine with the passive buffer.
-
-   The invoker should ensure that the subroutine is not invoked concurrently
-   with any of the other buffer operation initiation subroutines or the
-   nlx_core_buf_event_get() subroutine.
-
-   @param lctm  Transfer machine private data.
-   @param lcbuf Buffer private data.
-   @pre The buffer is queued on the specified transfer machine.
-   @pre lcbuf->cb_match_bits != 0
-   @pre lcbuf->cb_addr is valid
- */
-static int nlx_core_buf_active_recv(struct nlx_core_transfer_mc *lctm,
-				    struct nlx_core_buffer *lcbuf);
-
-/**
-   Enqueues a buffer for active bulk send.
-   See nlx_core_buf_active_recv() for how the buffer is to be initialized.
-
-   The invoker should ensure that the subroutine is not invoked concurrently
-   with any of the other buffer operation initiation subroutines or the
-   nlx_core_buf_event_get() subroutine.
-
-   @param lctm  Transfer machine private data.
-   @param lcbuf Buffer private data.
-   @pre The buffer is queued on the specified transfer machine.
-   @pre lcbuf->cb_match_bits != 0
-   @pre lcbuf->cb_addr is valid
- */
-static int nlx_core_buf_active_send(struct nlx_core_transfer_mc *lctm,
-				    struct nlx_core_buffer *lcbuf);
-
-/**
-   This subroutine generates new match bits for the given buffer's
-   cb_match_bits field.
-
-   It is intended to be used by the transport prior to invoking passive buffer
-   operations.  The reason it is not combined with the passive operation
-   subroutines is that the core API does not guarantee unique match bits.  The
-   match bit counter will wrap over time, though, being a very large counter,
-   it would take considerable time before it does wrap.
-
-   @param lctm  Transfer machine private data.
-   @param lcbuf The buffer private data.
-   @pre The buffer is queued on the specified transfer machine.
- */
-static void nlx_core_buf_match_bits_set(struct nlx_core_transfer_mc *lctm,
-					struct nlx_core_buffer *lcbuf);
-
-/**
-   Enqueues a buffer for passive bulk receive.
-   The match bits for the passive buffer should be set in the buffer with the
-   nlx_core_buf_match_bits_set() subroutine before this call.
-   It is guaranteed that the buffer can be remotely accessed when the
-   subroutine returns.
-
-   The invoker should ensure that the subroutine is not invoked concurrently
-   with any of the other buffer operation initiation subroutines or the
-   nlx_core_buf_event_get() subroutine.
-
-   @param lctm  Transfer machine private data.
-   @param lcbuf Buffer private data.
-   @pre The buffer is queued on the specified transfer machine.
-   @pre lcbuf->cb_match_bits != 0
- */
-static int nlx_core_buf_passive_recv(struct nlx_core_transfer_mc *lctm,
-				     struct nlx_core_buffer *lcbuf);
-
-/**
-   Enqueues a buffer for passive bulk send.
-   See nlx_core_buf_passive_recv() for how the buffer is to be initialized.
-   It is guaranteed that the buffer can be remotely accessed when the
-   subroutine returns.
-
-   The invoker should ensure that the subroutine is not invoked concurrently
-   with any of the other buffer operation initiation subroutines or the
-   nlx_core_buf_event_get() subroutine.
-
-   @param lctm  Transfer machine private data.
-   @param lcbuf Buffer private data.
-   @pre The buffer is queued on the specified transfer machine.
-   @pre lcbuf->cb_match_bits != 0
- */
-static int nlx_core_buf_passive_send(struct nlx_core_transfer_mc *lctm,
-				     struct nlx_core_buffer *lcbuf);
-
-/**
-   Cancels a buffer operation if possible.
-   @param lctm  Transfer machine private data.
-   @param lcbuf Buffer private data.
-   @pre The buffer is queued on the specified transfer machine.
- */
-static int nlx_core_buf_del(struct nlx_core_transfer_mc *lctm,
-			    struct nlx_core_buffer *lcbuf);
-
-/**
-   Waits for buffer events, or the timeout.
-   @param lctm Transfer machine private data.
-   @param timeout Absolute time at which to stop waiting.  A value of 0
-   indicates that the subroutine should not wait.
-   @retval 0 Events present.
-   @retval -ETIMEDOUT Timed out before events arrived.
- */
-static int nlx_core_buf_event_wait(struct nlx_core_transfer_mc *lctm,
-				   c2_time_t timeout);
-
-/**
-   Fetches the next event from the circular buffer event queue.
-
-   The invoker should ensure that the subroutine is not invoked concurrently
-   with any of the buffer operation initiation subroutines, or another
-   invocation of itself.
-
-   @param lctm Transfer machine private data.
-   @param lcbe The next buffer event is returned here.
-   @retval true Event returned.
-   @retval false No events on the queue.
- */
-static bool nlx_core_buf_event_get(struct nlx_core_transfer_mc *lctm,
-				   struct nlx_core_buffer_event *lcbe);
-
-/**
-   Parses an end point address string and convert to internal form.
-   A "*" value for the transfer machine identifier results in a value of
-   C2_NET_LNET_TMID_INVALID being set.
- */
-static int nlx_core_ep_addr_decode(struct nlx_core_domain *lcdom,
-				   const char *ep_addr,
-				   struct nlx_core_ep_addr *cepa);
-
-/**
-   Constructs the external address string from its internal form.
-   A value of C2_NET_LNET_TMID_INVALID for the cepa_tmid field results in
-   a "*" being set for that field.
- */
-static void nlx_core_ep_addr_encode(struct nlx_core_domain *lcdom,
-				    struct nlx_core_ep_addr *cepa,
-				    char buf[C2_NET_LNET_XEP_ADDR_LEN]);
-
-/**
-   Starts a transfer machine. Internally this results in
-   the creation of the LNet EQ associated with the transfer machine.
-   @param tm The transfer machine pointer.
-   @param lctm The transfer machine private data to be initialized.
-   @param cepa The end point address of this transfer machine. If the
-   lcpea_tmid field value is C2_NET_LNET_TMID_INVALID then a transfer machine
-   identifier is dynamically assigned to the transfer machine and returned
-   in this structure itself.
-   @note There is no equivalent of the xo_tm_init() subroutine.
- */
-static int nlx_core_tm_start(struct c2_net_transfer_mc *tm,
-			     struct nlx_core_transfer_mc *lctm,
-			     struct nlx_core_ep_addr *cepa);
-
-/**
-   Stops the transfer machine and release associated resources.  All operations
-   must be finalized prior to this call.
-   @param lctm The transfer machine private data.
-   @note There is no equivalent of the xo_tm_fini() subroutine.
- */
-static void nlx_core_tm_stop(struct nlx_core_transfer_mc *lctm);
-
-/**
-   @}
-*/
-
-#endif /* __COLIBRI_NET_LNET_CORE_H__ */
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 79
- *  scroll-step: 1
- *  End:
- */
diff --git a/net/lnet/lnet_main.c b/net/lnet/lnet_main.c
deleted file mode 100644
index 11addff..0000000
--- a/net/lnet/lnet_main.c
+++ /dev/null
@@ -1,764 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Carl Braganza <Carl_Braganza@us.xyratex.com>
- *                  Dave Cohrs <Dave_Cohrs@us.xyratex.com>
- * Original creation date: 11/01/2011
- */
-
-/**
-   @page LNetDLD LNet Transport DLD
-
-   - @ref LNetDLD-ovw
-   - @ref LNetDLD-def
-   - @ref LNetDLD-req
-   - @ref LNetDLD-depends
-   - @ref LNetDLD-highlights
-   - @subpage LNetDLD-fspec "Functional Specification" <!-- ./lnet_core.h" -->
-      - @ref LNetDFS "LNet Transport"                  <!-- net/lnet/lnet.h -->
-      - @ref LNetXODFS "XO Interface"                  <!-- ./lnet_xo.h -->
-   - @ref LNetDLD-lspec
-      - @ref LNetDLD-lspec-comps
-      - @ref LNetDLD-lspec-ep
-      - @ref LNetDLD-lspec-tm-start
-      - @ref LNetDLD-lspec-tm-stop
-      - @ref LNetDLD-lspec-bev-sync
-      - @ref LNetDLD-lspec-tm-thread
-      - @ref LNetDLD-lspec-buf-nbd
-      - @ref LNetDLD-lspec-buf-op
-      - @ref LNetDLD-lspec-state
-      - @ref LNetDLD-lspec-thread
-      - @ref LNetDLD-lspec-numa
-   - @ref LNetDLD-conformance
-   - @ref LNetDLD-ut
-   - @ref LNetDLD-st
-   - @ref LNetDLD-O
-   - @ref LNetDLD-ref
-
-   <hr>
-   @section LNetDLD-ovw Overview
-   This document describes the Colibri Network transport for LNet. The
-   transport is composed of multiple layers.  The document describes the
-   layering and then focuses mainly on the transport operations layer.
-
-   The design of the other layers can be found here:
-   - @ref LNetcqueueDLD "LNet Buffer Event Circular Queue DLD"
-     <!-- ./bev_cqueue.c -->
-   - @ref KLNetCoreDLD "LNet Transport Kernel Core DLD"
-     <!-- ./linux_kernel/klnet_core.c -->
-   - @ref ULNetCoreDLD "LNet Transport User Space Core DLD"
-
-   <hr>
-   @section LNetDLD-def Definitions
-   Refer to <a href="https://docs.google.com/a/xyratex.com/document/d/1TZG__XViil3ATbWICojZydvKzFNbL7-JJdjBbXTLgP4/edit?hl=en_US">HLD of Colibri LNet Transport</a>
-
-   <hr>
-   @section LNetDLD-req Requirements
-   - @b r.c2.net.xprt.lnet.transport-variable The implementation
-     shall name the transport variable as specified in the HLD.
-
-   - @b r.c2.net.lnet.buffer-registration Provide support for
-     hardware optimization through buffer pre-registration.
-
-   - @b r.c2.net.xprt.lnet.end-point-address The implementation
-     should support the mapping of end point address to LNet address
-     as described in the Refinement section of the HLD.
-
-   - @b r.c2.net.xprt.lnet.multiple-messages-in-buffer Provide
-     support for this feature as described in the HLD.
-
-   - @b r.c2.net.xprt.lnet.dynamic-address-assignment Provide
-     support for dynamic address assignment as described in the HLD.
-
-   - @b r.c2.net.xprt.lnet.processor-affinity The implementation
-     must support processor affinity as described in the HLD.
-
-   - @b r.c2.net.xprt.lnet.user-space The implementation must
-     accommodate the needs of the user space LNet transport.
-
-   - @b r.c2.net.synchronous-buffer-event-delivery The implementation must
-     provide support for this feature as described in the HLD.
-
-   <hr>
-   @section LNetDLD-depends Dependencies
-   <ul>
-
-   <li>@ref LNetCore "LNet Transport Core Interface" <!-- ./lnet_core.h -->
-   </li>
-
-   <li>The @ref net "Networking Module". <!-- net/net.h -->
-   Some modifications are required:
-
-     The design adds two additional fields to the c2_net_buffer structure:
-     @code
-     struct c2_net_buffer {
-        ...
-	c2_bcount_t   nb_min_receive_size;
-	uint32_t      nb_max_receive_msgs;
-     };
-     @endcode
-     These fields are required to be set to non-zero values in receive buffers,
-     and control the reception of multiple messages into a single receive buffer.
-
-     Additionally, the semantics of the @c nb_ep field is modified to not
-     require the end point of the active transfer machine when enqueuing a
-     passive buffer.  This effectively says that there will be no constraint on
-     which transfer machine performs the active operation, and the application
-     with the passive buffer is not required to know the address of this active
-     transfer machine in advance. This enables the conveyance of the network
-     buffer descriptor to the active transfer machine through intermediate
-     proxies, and the use of load balancing algorithms to spread the I/O
-     traffic across multiple servers.
-
-     The c2_net_tm_confine() subroutine is added to set the processor
-     affinity for transfer machine thread if desired.  This results in an
-     additional operation being added to the c2_net_xprt_ops structure:
-
-     @code
-     struct c2_net_xprt_ops {
-        ...
-        int  (*xo_tm_confine)(struct c2_net_transfer_mc *tm,
-	                      const struct c2_bitmap *processors);
-     };
-     @endcode
-
-     The behavior of the c2_net_buffer_event_post() subroutine is modified
-     slightly to allow for multiple buffer events to be delivered for a single
-     receive buffer, without removing it from a transfer machine queue.
-     This is indicated by the ::C2_NET_BUF_RETAIN flag.
-
-     The design adds the following fields to the c2_net_transfer_mc structure
-     to support the synchronous delivery of network buffer events:
-     @code
-     struct c2_net_transfer_mc {
-        ...
-	bool                        ntm_bev_auto_deliver;
-     };
-     @endcode
-     By default, @c ntm_bev_auto_deliver is set to @c true.  In addition
-     the following subroutines are defined:
-     - c2_net_tm_buffer_event_deliver_all()
-     - c2_net_tm_buffer_event_deliver_synchronously()
-     - c2_net_tm_buffer_event_pending()
-     - c2_net_tm_buffer_event_notify()
-     .
-     This results in corresponding operations being added to the
-     c2_net_xprt_ops structure:
-     @code
-     struct c2_net_xprt_ops {
-        ...
-        void (*xo_bev_deliver_all)(struct c2_net_transfer_mc *tm);
-        int  (*xo_bev_deliver_sync)(struct c2_net_transfer_mc *tm);
-	bool (*xo_bev_pending)(struct c2_net_transfer_mc *tm);
-	void (*xo_bev_notify)(struct c2_net_transfer_mc *tm,
-                              struct c2_chan *chan);
-     };
-     @endcode
-
-   </li> <!-- end net module changes -->
-
-   <li>The @ref bitmap "Bitmap Module". <!-- lib/bitmap.h -->
-   New subroutines to copy a bitmap and to compare bitmaps are required. The
-   copy subroutine should be refactored out of the processors_copy_c2bitmap()
-   subroutine. </li>
-
-   <li>The @ref Processor <!-- lib/processor.h -->
-   API for the application to determine processor bitmaps with which to specify
-   thread affinity.</li>
-
-   <li>The @ref thread "Thread Module". <!-- lib/thread.h -->
-   Modifications are required in c2_thread_init() subroutine or a variant
-   should be provided to support thread creation with processor affinity set.
-   This is essential for the kernel implementation where processor affinity can
-   only be set during thread creation.</li>
-
-   </ul>
-
-   <hr>
-   @section LNetDLD-highlights Design Highlights
-   - Common user and kernel space implementation over an underlying "Core" I/O
-     layer that communicates with the kernel LNet module.
-   - Supports the reception of multiple messages in a single receive buffer.
-   - Provides processor affinity.
-   - Support for hardware optimizations in buffer access.
-   - Support for dynamic transfer machine identifier assignment.
-   - Efficient communication between user and kernel address spaces in the user
-     space transport through the use of shared memory.  This includes the
-     efficient conveyance of buffer operation completion event data through the
-     use of a circular queue in shared memory, and the minimal use of system
-     calls to block for events.
-
-   <hr>
-   @section LNetDLD-lspec Logical Specification
-   - @ref LNetDLD-lspec-comps
-   - @ref LNetDLD-lspec-ep
-   - @ref LNetDLD-lspec-tm-start
-   - @ref LNetDLD-lspec-tm-stop
-   - @ref LNetDLD-lspec-bev-sync
-   - @ref LNetDLD-lspec-tm-thread
-   - @ref LNetDLD-lspec-buf-nbd
-   - @ref LNetDLD-lspec-buf-op
-   - @ref LNetDLD-lspec-state
-   - @ref LNetDLD-lspec-thread
-   - @ref LNetDLD-lspec-numa
-
-   @subsection LNetDLD-lspec-comps Component Overview
-   The focus of the LNet transport is the implementation of the asynchronous
-   semantics required by the Colibri Networking layer.  I/O is performed by an
-   underlying "core" layer, which does the actual interaction with the Lustre
-   LNet kernel module.  The core layer permits the LNet transport code to be
-   written in an address space agnostic fashion, as it offers the same
-   interface in both user and kernel space.
-
-   The relationship between the various components of the LNet transport and
-   the networking layer is illustrated in the following UML diagram.
-   @image html "../../net/lnet/lnet_xo.png" "LNet Transport Objects"
-   <!-- PNG image width is 800 -->
-
-   @subsection LNetDLD-lspec-ep End Point Support
-   The transport defines the following structure for the internal
-   representation of a struct c2_net_end_point.
-   @code
-   struct nlx_xo_ep {
-       struct c2_net_end_point xe_ep;
-       struct nlx_core_ep_addr xe_core;
-       char                    xe_addr[1];
-   };
-   @endcode
-   The length of the structure depends on the length of the string
-   representation of the address, which must be saved in the @c xe_addr array.
-   The address of the @c xe_ep field is returned as the external representation.
-
-   The end point data structure is not associated internally with any LNet
-   kernel resources.
-
-   The transport does not support dynamic addressing: i.e. the @c addr
-   parameter can never be NULL in the c2_net_end_point_create() subroutine.
-   However, it supports the dynamic assignment of transfer machine identifiers
-   as described in the HLD, but only for the @c addr parameter of the
-   c2_net_tm_start() subroutine.
-
-   A linked list of all end point objects created for a transfer machine is
-   maintained in the c2_net_transfer_mc::ntm_end_points list.  Objects are
-   added to this list as a result of the application invoking the
-   c2_net_end_point_create() subroutine, or as a side effect of receiving a
-   message.  Access to this list is protected by the transfer machine mutex.
-
-
-   @subsection LNetDLD-lspec-tm-start Transfer Machine Start
-   The c2_net_tm_start() subroutine is used to start a transfer machine, which
-   results in a call to nlx_xo_tm_start().  The subroutine decodes the end
-   point address using the nlx_core_ep_addr_decode() subroutine. It then starts
-   the background event processing thread with the desired processor
-   affinity. The thread will complete the transfer machine start up and deliver
-   its state change event.
-
-   The event processing thread will call the nlx_core_tm_start() subroutine to
-   create the internal LNet EQ associated with the transfer machine.  This call
-   also validates the transfer machine's address, and assigns a dynamic
-   transfer machine identifier if needed.  It will then post a state change
-   callback to transition the transfer machine to its normal operational state,
-   or fail it if any error is encountered.
-
-
-   @subsection LNetDLD-lspec-tm-stop Transfer Machine Termination
-   Termination of a transfer machine is requested through the c2_net_tm_stop()
-   subroutine, which results in a call to nlx_xo_tm_stop(). The latter ensures
-   that the transfer machine's thread wakes up by signalling on the
-   nlx_xo_transfer_mc::xtm_ev_cond condition variable.
-
-   When terminating a transfer machine the application has a choice of draining
-   current operations or aborting such activity.  If the latter choice is made,
-   then the transport must first cancel all operations.
-
-   Regardless, the transfer machine's event processing thread completes the
-   termination process.  It waits until all buffer queues are empty and any
-   ongoing synchronous network buffer delivery has completed, then invokes the
-   nlx_core_tm_stop() subroutine to free the LNet EQ and other resources
-   associated with the transfer machine.  It then posts the transfer machine
-   state change event and terminates itself.  See @ref LNetDLD-lspec-tm-thread
-   for further detail.
-
-   @subsection LNetDLD-lspec-bev-sync Synchronous Network Buffer Event Delivery
-
-   The transport supports the optional synchronous network buffer event
-   delivery as required by the HLD.  The default asynchronous delivery of
-   buffer events is done by the @ref LNetDLD-lspec-tm-thread.  Synchronous
-   delivery must be enabled before the transfer machine is started, and is
-   indicated by the value of the c2_net_transfer_mc::ntm_bev_auto_deliver
-   value being @c false.
-
-   The nlx_xo_bev_deliver_sync() transport operation is invoked to disable the
-   automatic delivery of buffer events. The subroutine simply returns without
-   error, and the invoking c2_net_tm_buffer_event_deliver_synchronously()
-   subroutine will then set the value of
-   c2_net_transfer_mc::ntm_bev_auto_deliver value to @c false.
-
-   The nlx_xo_bev_pending() transport operation is invoked from the
-   c2_net_tm_buffer_event_pending() subroutine to determine if there are pending
-   network buffer events.  It invokes the nlx_core_buf_event_wait() subroutine
-   with a timeout of 0 and uses the returned status value to determine if
-   events are present or not.
-
-   The nlx_xo_bev_notify() transport operation is invoked from the
-   c2_net_tm_buffer_event_notify() subroutine.  It sets the
-   nlx_xo_transfer_mc::xtm_ev_chan value to the specified wait channel, and
-   signals on the nlx_xo_transfer_mc::xtm_ev_cond condition variable to wake up
-   the event processing thread.
-
-   The nlx_xo_bev_deliver_all() transport operation is invoked from the
-   c2_net_tm_buffer_event_deliver_all() subroutine.  It attempts to deliver all
-   pending events.  The transfer machine lock is held across the call to the
-   nlx_core_buf_event_get() subroutine to serialize "consumers" of the
-   circualar buffer event queue, but is released during event delivery.  The
-   nlx_xo_transfer_mc::xtm_busy counter is incremented across the call to
-   prevent premature termination when operating outside of the protection of
-   the transfer machine mutex.  This is illustrated in the following
-   pseduo-code for nlx_xo_bev_deliver_all():
-   @code
-   int rc;
-   C2_PRE(c2_mutex_is_locked(&tm->ntm_mutex));
-   lctm->xtm_busy++;
-   do { // consume all pending events
-        struct nlx_core_buffer_event lcbe;
-	struct c2_net_buffer_event nbev;
-	rc = nlx_core_buf_event_get(lctm, &lcbe);
-	if (rc == 0) {
-	  // create end point objects as needed
-        }
-	c2_mutex_unlock(&tm->ntm_mutex); // release lock
-	if (rc == 0) {
-	     nbe = ... // convert the event
-	     c2_net_buffer_event_post(&nbev);
-        }
-	c2_mutex_lock(&tm->ntm_mutex); // re-acquire lock
-   } while (rc == 0);
-   lctm->xtm_busy--;
-   @endcode
-
-   @subsection LNetDLD-lspec-tm-thread Transfer Machine Event Processing Thread
-   The default behavior of a transfer machine is to automatically deliver
-   buffer events from the Core API's event queue to the application.  The Core
-   API guarantees that LNet operation completion events will result in buffer
-   events being enqueued in the order the API receives them, and, in
-   particular, that multiple buffer events for any given receive buffer will be
-   ordered.  This is very important for the transport, because it has to ensure
-   that a receive buffer operation is not prematurely flagged as dequeued.
-
-   The transport uses exactly one event processing thread to process buffer
-   events from the Core API.  This has the following advantages:
-   - The implementation is simple.
-   - It implicitly race-free with respect to receive buffer events.
-
-   Applications are not expected to spend much time in the event callback, so
-   this simple approach is acceptable.
-
-   The application can establish specific processor affiliation for the event
-   processing thread with the c2_net_tm_confine() subroutine @em prior to
-   starting the transfer machine. This results in a call to the
-   nlx_xo_tm_confine() subroutine, which makes a copy of the desired processor
-   affinity bitmask in nlx_xo_transfer_mc::xtm_processors.
-
-   In addition to automatic buffer event delivery, the event processing thread
-   performs the following functions:
-   - Notify the presence of buffer events when synchronous buffer event
-     delivery is enabled
-   - Transfer machine state change event posting
-   - Buffer operation timeout processing
-   - Logging of statistical data
-
-   The functionality of the event processing thread is best illustrated by
-   the following pseudo-code:
-   @code
-   // start the transfer machine in the Core
-   rc = nlx_core_tm_start(&tm, lctm, &cepa);
-   // deliver a C2_NET_TEV_STATE_CHANGE event to transition the TM to
-   // the C2_NET_TM_STARTED or C2_NET_TM_FAILED states
-   // Set the transfer machine's end point on success
-   c2_net_tm_event_post(&tmev);
-   if (rc != 0)
-       return; // failure
-   // loop forever
-   while (1) {
-      timeout = ...; // compute next timeout (short if automatic or stopping)
-      if (tm->ntm_bev_auto_deliver) {      // automatic delivery
-	  rc = nlx_core_buf_event_wait(lctm, timeout);
-	  // buffer event processing
-	  if (rc == 0) { // did not time out - events pending
-	     c2_mutex_lock(&tm->ntm_mutex);
-	     nlx_xo_bev_deliver_all(tm);
-	     c2_mutex_unlock(&tm->ntm_mutex);
-	  }
-      } else {                             // application initiated delivery
-	     c2_mutex_lock(&tm->ntm_mutex);
-	     if (lctm.xtm_ev_chan == NULL)
-	        c2_cond_timedwait(lctm->xtm_ev_cond, &tm->ntm_mutex, timeout);
-	     if (lctm.xtm_ev_chan != NULL) {
-	        rc = nlx_core_buf_event_wait(lctm, timeout);
-	        if (rc == 0) {
-		    c2_chan_signal(lctm->xtm_chan);
-		    lctm.xtm_chan = NULL;
-		}
-             }
-	     c2_mutex_unlock(&tm->ntm_mutex);
-      }
-      // do buffer operation timeout processing periodically
-      ...
-      // termination processing
-      if (tm->ntm_state == C2_NET_TM_STOPPING) {
-            bool must_stop = false;
-            c2_mutex_lock(&tm->ntm_mutex);
-            if (all_tm_queues_are_empty(tm) && lctm->xtm_busy == 0) {
-	       nlx_core_tm_stop(lctm);
-	       must_stop = true;
-            }
-            c2_mutex_unlock(&tm->ntm_mutex);
-            if (must_stop) {
-	       struct c2_net_tm_event tmev;
-               // construct a C2_NET_TEV_STATE_CHANGE event to transition
-	       // to the C2_NET_TM_STOPPED state.
-	       c2_net_tm_event_post(&tmev);
-               break;
-            }
-      }
-      // Log statistical data periodically using ADDB
-      ...
-   }
-   @endcode
-   (The C++ style comments above are used only because the example is
-   embedded in a Doxygen C comment.  C++ comments are not permitted by the
-   Colibri coding style.)
-
-   A few points to note on the above pseudo-code:
-   - The thread blocks in the nlx_core_buf_event_wait() if the default
-     automatic buffer event delivery mode is set, or on the
-     nlx_xo_transfer_mc::xtm_ev_cond condition variable otherwise. In the
-     latter case, it may also block in the nlx_core_buf_event_wait() subroutine
-     if the condition variable is signalled by the nlx_xo_bev_notify()
-     subroutine.
-   - The transfer machine mutex is obtained across the call to dequeue buffer
-     events to serialize with the "other" consumer of the buffer event queue,
-     the nlx_xo_buf_add() subroutine that invokes the Core API buffer operation
-     initiation subroutines.  This is because these subroutines may allocate
-     additional buffer event structures to the queue.
-   - The nlx_xo_bev_deliver_all() subroutine processes as many events as it can
-     each time around the loop.  The call to the nlx_core_buf_event_wait()
-     subroutine in the user space transport is expensive as it makes a device
-     driver @c ioctl call internally.
-   - The thread is responsible for terminating the transfer machine and
-     delivering its termination event.  Termination serializes with concurrent
-     invocation of the nlx_xo_bev_deliver_all() subroutine in the case of
-     synchronous buffer event delivery.
-   - The timeout value can vary depending on the mode of operation. Synchronous
-     network delivery is best served by a long timeout value (in the order of a
-     minute), at least up to the time that the transfer machine is stopped.
-     Automatic buffer event delivery is better served by a short timeout value
-     (in the order of a second).  This is because in the user space transport
-     the thread would be blocked in an ioctl call in the kernel, and would not
-     respond in a lively manner to a shutdown request.  The timeout value is
-     also dependent on whether the transfer machine is stopping, the buffer
-     operation timeout check period and the statistical recording period.
-
-   @subsection LNetDLD-lspec-buf-nbd Network Buffer Descriptor
-   The transport has to define the format of the opaque network buffer
-   descriptor returned to the application, to encode the identity of the
-   passive buffers.
-
-   The following internal format is used:
-   @code
-   struct nlx_xo_buf_desc {
-        uint64_t                 xbd_match_bits;
-        struct nlx_core_ep_addr  xbd_passive_ep;
-        enum c2_net_queue_type   xbd_qtype;
-        c2_bcount_t              xbd_size;
-   };
-   @endcode
-
-   All the fields are integer fields and the structure is of fixed length.  It
-   is encoded and decoded into its opaque over-the-wire struct c2_net_buf_desc
-   format with dedicated encoding routines.
-
-
-   @subsection LNetDLD-lspec-buf-op Buffer operations
-   Buffer operations are initiated through the c2_net_xprt_ops::xo_buf_add()
-   operation which points to the nlx_xo_buf_add() subroutine. The subroutine
-   will invoke the appropriate Core API buffer initiation operations.
-
-   In passive buffer operations, the transport must first obtain suitable match
-   bits for the buffer using the nlx_core_buf_match_bits_set() subroutine.  The
-   transport is responsible for ensuring that the assigned match bits are not
-   in use currently; however this step can be ignored with relative safety as
-   the match bit space is very large and the match bit counter will only wrap
-   around after a very long while.  These match bits should also be encoded in
-   the network buffer descriptor that the transport must return.
-
-   In active buffer operations, the size of the active buffer should be
-   validated against the size of the passive buffer as given in its network
-   buffer descriptor.
-
-
-   @subsection LNetDLD-lspec-state State Specification
-   The transport does not introduce its own state model but operates within the
-   framework defined by the Colibri Networking Module. In general, resources
-   are allocated to objects of this module by the underlying Core API, and they
-   have to be recovered upon object finalization, and in the particular case of
-   the user space transport, upon process termination if the termination was
-   not orderly.
-
-   The resources allocated to the following objects are particularly called
-   out:
-
-   - c2_net_buffer
-   - c2_net_transfer_mc
-   - c2_net_domain
-   - c2_net_end_point
-
-   Network buffers enqueued with a transfer machine represent operations in
-   progress.  Until they get dequeued, the buffers are associated internally
-   with LNet kernel module resources (MDs and MEs) allocated on their behalf by
-   the Core API.
-
-   The transfer machine is associated with an LNet event queue (EQ).  The EQ
-   must be created when the transfer machine is started, and destroyed when the
-   transfer machine stops.  The transfer machine operates by default in an
-   asynchronous network buffer delivery mode, but can also provide synchronous
-   network buffer delivery for locality sensitive applications like the Colibri
-   request handler.
-
-   Buffers registered with a domain object are potentially associated with LNet
-   kernel module resources and, if the transport is in user space, additional
-   kernel memory resources as the buffer vector is pinned in
-   memory. De-registration of the buffers releases these resources.  The domain
-   object of a user space transport is also associated with an open file
-   descriptor to the device driver used to communicate with the kernel Core
-   API.
-
-   End point structures are exposed externally as struct c2_net_end_point, but
-   are allocated and managed internally by the transport with struct nlx_xo_ep.
-   They do not use LNet resources, but just transport address space
-   memory. Their creation and finalization is protected by the transfer machine
-   mutex. They are reference counted, and the application must release all
-   references before attempting to finalize a transfer machine.
-
-
-   @subsection LNetDLD-lspec-thread Threading and Concurrency Model
-   The transport inherits the concurrency model of the Colibri Networking
-   Module. All transport operations are protected by some lock or object state,
-   as described in the <a href="https://docs.google.com/a/xyratex.com/document/d/1tm_IfkSsW6zfOxQlPMHeZ5gjF1Xd0FAUHeGOaNpUcHA/view">RPC Bulk Transfer Task Plan</a>.  The Core API is designed to work with this same locking model.
-   The locking order figure is repeated here for convenience:
-   @dot
-   digraph {
-      node [shape=plaintext];
-      subgraph cluster_m1 { // represents mutex scope
-         // sorted R-L so put mutex name last to align on the left
-         rank = same;
-	 n1_2 [label="dom_fini()"];  // procedure using mutex
-	 n1_1 [label="dom_init()"];
-         n1_0 [label="c2_net_mutex"];// mutex name
-      }
-      subgraph cluster_m2 {
-         rank = same;
-	 n2_2 [label="tm_fini()"];
-         n2_1 [label="tm_init()"];
-         n2_4 [label="buf_deregister()"];
-	 n2_3 [label="buf_register()"];
-         n2_0 [label="nd_mutex"];
-      }
-      subgraph cluster_m3 {
-         rank = same;
-	 n3_2 [label="tm_stop()"];
-         n3_1 [label="tm_start()"];
-	 n3_6 [label="ep_put()"];
-	 n3_5 [label="ep_create()"];
-	 n3_4 [label="buf_del()"];
-	 n3_3 [label="buf_add()"];
-         n3_0 [label="ntm_mutex"];
-      }
-      label="Mutex usage and locking order in the Network Layer";
-      n1_0 -> n2_0;  // locking order
-      n2_0 -> n3_0;
-   }
-   @enddot
-
-   The transport only has one thread, its event processing thread.  This thread
-   uses the transfer machine lock when serialization is required by the Core
-   API, and also when creating or looking up end point objects when processing
-   receive buffer events.  Termination of the transfer machine is serialized
-   with concurrent invocation of the nlx_xo_bev_deliver_all() subroutine in the
-   case of synchronous buffer event delivery by means of the
-   nlx_xo_transfer_mc::xtm_busy counter.
-   See @ref LNetDLD-lspec-bev-sync and @ref LNetDLD-lspec-tm-thread for
-   details.
-
-   @subsection LNetDLD-lspec-numa NUMA optimizations
-   The application can establish specific processor affiliation for the event
-   processing thread with the c2_net_tm_confine() subroutine prior to starting
-   the transfer machine.  Buffer completion events and transfer machine state
-   change events will be delivered through callbacks made from this thread.
-
-   Even greater locality of reference is obtained with synchronous network
-   buffer event delivery.  The application is able to co-ordinate references to
-   network objects and other objects beyond the scope of the network module.
-
-   <hr>
-   @section LNetDLD-conformance Conformance
-   - @b i.c2.net.xprt.lnet.transport-variable The transport variable
-   @c c2_net_lnet_xprt is provided.
-
-   - @b i.c2.net.lnet.buffer-registration Buffer registration is required
-   in the network API and results in the corresponding nlx_xo_buf_register()
-   subroutine call at the LNet transport layer.  This is where hardware
-   optimization can be performed, once LNet provides such APIs.
-
-   - @b i.c2.net.xprt.lnet.end-point-address Mapping of LNet end point
-   address is handled in the Core API as described in the @ref
-   LNetCoreDLD-fspec "LNet Transport Core Functional Specification".
-
-   - @b i.c2.net.xprt.lnet.multiple-messages-in-buffer Fields are provided
-   in the c2_net_buffer to support multiple message delivery, and the event
-   delivery model includes the delivery of buffer events for receive buffers
-   that do not always dequeue the buffer.
-
-   - @b i.c2.net.xprt.lnet.dynamic-address-assignment Dynamic transfer
-     machine identifier assignment is provided by nlx_core_tm_start().
-
-   - @b i.c2.net.xprt.lnet.processor-affinity The c2_net_tm_confine() API
-   is provided and the LNet transport provides the corresponding
-   nlx_xo_tm_confine() function.
-
-   - @b i.c2.net.xprt.lnet.user-space The user space implementation of the
-   Core API utilizes shared memory and reduces context switches required for
-   user-space event processing through the use of a circular queue maintained
-   in shared memory and operated upon with atomic operations.
-
-   - @b i.c2.net.synchronous-buffer-event-delivery See @ref
-   LNetDLD-lspec-bev-sync and @ref LNetDLD-lspec-tm-thread for details.
-
-   <hr>
-   @section LNetDLD-ut Unit Tests
-   To control symbol exposure, the transport code is compiled using a single C
-   file that includes other C files with static symbols.  Unit testing will
-   take advantage of this setup and use conditional renaming of symbols to
-   intercept specific internal interfaces.
-
-   The following tests will be performed for the transport operation (xo) layer
-   with a fake Core API.  Tests involving the fake Core API ensure that the
-   transport operation layer makes the correct calls to the Core API.
-
-   @test Multiple domain creation will be tested.
-
-   @test Buffer registration and deregistration will be tested.
-
-   @test Multiple transfer machine creation will be tested.
-
-   @test Test that the processor affinity bitmask is set in the TM.
-
-   @test The transfer machine state change functionality.
-
-   @test Initiation of buffer operations will be tested.
-
-   @test Delivery of synthetic buffer events will be tested, including multiple
-         receive buffer events for a single receive buffer. Both asynchronous
-         and synchronous styles of buffer delivery will be tested.
-
-   @test Management of the reference counted end point objects; the addresses
-         themselves don't have to valid for these tests.
-
-   @test Encoding and Decoding of the network buffer descriptor will be tested.
-
-   @test Orderly finalization will be tested.
-
-   <hr>
-   @section LNetDLD-st System Tests
-   @test The @c bulkping system test program will be updated to include support
-   for the LNet transport.  This program will be used to test communication
-   between end points on the same system and between remote systems.  The
-   program will offer the ability to dynamically allocate a transfer machine
-   identifier when operating in client mode.
-
-   <hr>
-   @section LNetDLD-O Analysis
-   In general, the transport operational layer simply routes data too and from
-   the Core API; this behavior is analyzed in
-   @ref KLNetCoreDLD "LNet Transport Kernel Core DLD".
-   <!-- ./linux_kernel/klnet_core.c -->
-
-   An area of concern specific to the transport operations layer is the
-   management of end point objects.  In particular, the time taken to search
-   the list of end point objects is of O(N) - i.e. a linear search through the
-   list, which is proportional to the number of list items.  This search may
-   become expensive if the list grows large - items on the list are reference
-   counted and it is up to the application to release them, not the transport.
-
-   The internal end point address fields are all numeric and easily lend
-   themselves to a hash based strategy (the NID value is the best candidate
-   key).  The tricky part of any hashing scheme would be to determine what hash
-   function would result in a reasonably even distribution over a set of hash
-   buckets; this is not as bad as it sounds, because even in the worst case, it
-   would degenerate to the linear search we have at present.
-
-   Ultimately, the choice of whether to use hashing or not depends on what the
-   behavior of a Colibri server will be like in steady state: if end points are
-   released fairly rapidly, the linked list implementation will suffice.  Note
-   that since no LNet kernel resources are associated with end point objects,
-   this issue is simply related to search performance.
-
-
-   <hr>
-   @section LNetDLD-ref References
-   - <a href="https://docs.google.com/a/xyratex.com/document/d/1TZG__XViil3ATbWICojZydvKzFNbL7-JJdjBbXTLgP4/edit?hl=en_US">HLD of Colibri LNet Transport</a>
-   - <a href="https://docs.google.com/a/xyratex.com/document/d/1tm_IfkSsW6zfOxQlPMHeZ5gjF1Xd0FAUHeGOaNpUcHA/view">RPC Bulk Transfer Task Plan</a>
-   - @subpage LNetcqueueDLD "LNet Buffer Event Circular Queue DLD" <!--
-                                                               ./bev_cqueue.c -->
-   - @subpage KLNetCoreDLD "LNet Transport Kernel Core DLD" <!--
-                                                  ./linux_kernel/klnet_core.c -->
-   - @subpage ULNetCoreDLD "LNet Transport User Space Core DLD"
-
- */
-
-/*
- ******************************************************************************
- End of DLD
- ******************************************************************************
- */
-
-#include "net/lnet/lnet_core.h"
-
-/* To reduce global symbols, yet make the code readable, we
-   include other .c files with static symbols into this file.
-   Dependency information must be captured in Makefile.am.
-
-   Static functions should be declared in the private header file
-   so that the order of their definition does not matter.
-*/
-#include "net/lnet/bev_cqueue.c"
-#ifdef __KERNEL__
-#include "net/lnet/linux_kernel/klnet_core.c"
-#else
-#include "net/lnet/ulnet_core.c"
-#endif
-#include "net/lnet/lnet_xo.c"
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 79
- *  scroll-step: 1
- *  End:
- */
-
diff --git a/net/lnet/lnet_xo.c b/net/lnet/lnet_xo.c
deleted file mode 100644
index 345ac96..0000000
--- a/net/lnet/lnet_xo.c
+++ /dev/null
@@ -1,153 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Carl Braganza <Carl_Braganza@us.xyratex.com>
- *                  Dave Cohrs <Dave_Cohrs@us.xyratex.com>
- * Original creation date: 11/16/2011
- */
-
-/**
-   @addtogroup LNetXODFS
-   @{
-*/
-
-static int nlx_xo_dom_init(struct c2_net_xprt *xprt, struct c2_net_domain *dom)
-{
-}
-
-static void nlx_xo_dom_fini(struct c2_net_domain *dom)
-{
-}
-
-static c2_bcount_t nlx_xo_get_max_buffer_size(const struct c2_net_domain *dom)
-{
-}
-
-static c2_bcount_t nlx_xo_get_max_buffer_segment_size(const struct
-						       c2_net_domain *dom)
-{
-}
-
-static int32_t nlx_xo_get_max_buffer_segments(const struct c2_net_domain *dom)
-{
-}
-
-static int nlx_xo_end_point_create(struct c2_net_end_point **epp,
-				   struct c2_net_transfer_mc *tm,
-				   const char *addr)
-{
-}
-
-static int nlx_xo_buf_register(struct c2_net_buffer *nb)
-{
-}
-
-static void nlx_xo_buf_deregister(struct c2_net_buffer *nb)
-{
-}
-
-static int nlx_xo_buf_add(struct c2_net_buffer *nb)
-{
-}
-
-static void nlx_xo_buf_del(struct c2_net_buffer *nb)
-{
-}
-
-static int nlx_xo_tm_init(struct c2_net_transfer_mc *tm)
-{
-}
-
-static void nlx_xo_tm_fini(struct c2_net_transfer_mc *tm)
-{
-}
-
-static int nlx_xo_tm_start(struct c2_net_transfer_mc *tm, const char *addr)
-{
-}
-
-static int nlx_xo_tm_stop(struct c2_net_transfer_mc *tm, bool cancel)
-{
-}
-
-static int nlx_xo_tm_confine(struct c2_net_transfer_mc *tm,
-			     const struct c2_bitmap *processors)
-{
-}
-
-static void nlx_xo_bev_deliver_all(struct c2_net_transfer_mc *tm)
-{
-}
-
-static int nlx_xo_bev_deliver_sync(struct c2_net_transfer_mc *tm)
-{
-}
-
-static bool nlx_xo_bev_pending(struct c2_net_transfer_mc *tm)
-{
-}
-
-static void nlx_xo_bev_notify(struct c2_net_transfer_mc *tm,
-			      struct c2_chan *chan)
-{
-}
-
-static const struct c2_net_xprt_ops nlx_xo_xprt_ops = {
-	.xo_dom_init                    = nlx_xo_dom_init,
-	.xo_dom_fini                    = nlx_xo_dom_fini,
-	.xo_get_max_buffer_size         = nlx_xo_get_max_buffer_size,
-	.xo_get_max_buffer_segment_size = nlx_xo_get_max_buffer_segment_size,
-	.xo_get_max_buffer_segments     = nlx_xo_get_max_buffer_segments,
-	.xo_end_point_create            = nlx_xo_end_point_create,
-	.xo_buf_register                = nlx_xo_buf_register,
-	.xo_buf_deregister              = nlx_xo_buf_deregister,
-	.xo_buf_add                     = nlx_xo_buf_add,
-	.xo_buf_del                     = nlx_xo_buf_del,
-	.xo_tm_init                     = nlx_xo_tm_init,
-	.xo_tm_fini                     = nlx_xo_tm_fini,
-	.xo_tm_start                    = nlx_xo_tm_start,
-	.xo_tm_stop                     = nlx_xo_tm_stop,
-	.xo_tm_confine                  = nlx_xo_tm_confine,
-	.xo_bev_deliver_all             = nlx_xo_bev_deliver_all,
-	.xo_bev_deliver_sync            = nlx_xo_bev_deliver_sync,
-	.xo_bev_pending                 = nlx_xo_bev_pending,
-	.xo_bev_notify                  = nlx_xo_bev_notify,
-};
-
-/**
-   @} LNetXODFS
-*/
-
-struct c2_net_xprt c2_net_lnet_xprt = {
-	.nx_name = "lnet",
-	.nx_ops  = &nlx_xo_xprt_ops
-};
-
-int c2_net_lnet_ep_addr_net_cmp(const char *addr1, const char *addr2)
-{
-	return false;
-}
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 79
- *  scroll-step: 1
- *  End:
- */
-
diff --git a/net/lnet/lnet_xo.h b/net/lnet/lnet_xo.h
deleted file mode 100644
index 68e4bf2..0000000
--- a/net/lnet/lnet_xo.h
+++ /dev/null
@@ -1,139 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Carl Braganza <Carl_Braganza@us.xyratex.com>
- *                  Dave Cohrs <Dave_Cohrs@us.xyratex.com>
- * Original creation date: 11/10/2011
- *
- */
-#ifndef __COLIBRI_NET_LNET_XO_H__
-#define __COLIBRI_NET_LNET_XO_H__
-
-#include "net/lnet/lnet_core.h"
-#include "lib/thread.h"
-
-/**
-   @defgroup LNetXODFS LNet Transport XO Interface
-   @ingroup LNetDFS
-   @{
-*/
-
-struct nlx_xo_buf_desc;
-struct nlx_xo_buffer;
-struct nlx_xo_domain;
-struct nlx_xo_ep;
-struct nlx_xo_transfer_mc;
-
-/**
-   LNet transport's internal end point structure.
- */
-struct nlx_xo_ep {
-	/** embedded network end point structure. */
-	struct c2_net_end_point xe_ep;
-
-	/** LNet transport address */
-	struct nlx_core_ep_addr xe_core;
-
-	/** Memory for the string representation of the end point.
-	    The @c xe_ep.nep_addr field points to @c xe_addr.
-	*/
-	char                    xe_addr[C2_NET_LNET_XEP_ADDR_LEN];
-};
-
-/**
-   Internal form of the LNet transport's Network Buffer Descriptor.
-   The external form is the opaque c2_net_buf_desc.
- */
-struct nlx_xo_buf_desc {
-	/** Match bits of the passive buffer */
-        uint64_t                 xbd_match_bits;
-
-	/** Passive TM's end point */
-        struct nlx_core_ep_addr  xbd_passive_ep;
-
-	/** Passive buffer queue type */
-        enum c2_net_queue_type   xbd_qtype;
-
-	/** Passive buffer size */
-        c2_bcount_t              xbd_size;
-};
-
-/**
-   Private data pointed to by c2_net_domain::nd_xprt_private.
- */
-struct nlx_xo_domain {
-	/** Pointer back to the network dom */
-	struct c2_net_domain   *xd_dom;
-
-	/** LNet Core transfer domain data (shared memory) */
-	struct nlx_core_domain  xd_core;
-};
-
-/**
-   Private data pointed to by c2_net_transfer_mc::ntm_xprt_private.
- */
-struct nlx_xo_transfer_mc {
-	/** Pointer back to the network tm */
-	struct c2_net_transfer_mc   *xtm_tm;
-
-	/** Transfer machine thread processor affinity */
-	struct c2_bitmap             xtm_processors;
-
-	/** Event thread */
-	struct c2_thread             xtm_ev_thread;
-
-	/** Condition variable used by the event thread for synchronous buffer
-	    event notification.
-	 */
-	struct c2_cond               xtm_ev_cond;
-
-	/** Channel used for synchronous buffer event notification */
-	struct c2_chan              *xtm_ev_chan;
-
-	/** Count of activities in progress out of the TM mutex */
-	int                          xtm_busy;
-
-	/** LNet Core transfer machine data (shared memory) */
-	struct nlx_core_transfer_mc  xtm_core;
-};
-
-/**
-   Private data pointed to by c2_net_buffer::nb_xprt_private.
- */
-struct nlx_xo_buffer {
-	/** Pointer back to the network buffer */
-	struct c2_net_buffer   *xb_nb;
-
-	/** LNet Core buffer data (shared memory) */
-	struct nlx_core_buffer  xb_core;
-};
-
-
-/**
-   @} LNetXODFS
-*/
-
-#endif /* __COLIBRI_NET_LNET_XO_H__ */
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 79
- *  scroll-step: 1
- *  End:
- */
diff --git a/net/lnet/ulnet_core.h b/net/lnet/ulnet_core.h
deleted file mode 100644
index 1f40a5e..0000000
--- a/net/lnet/ulnet_core.h
+++ /dev/null
@@ -1,73 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Carl Braganza <Carl_Braganza@us.xyratex.com>
- *                  Dave Cohrs <Dave_Cohrs@us.xyratex.com>
- * Original creation date: 11/01/2011
- *
- */
-#ifndef __COLIBRI_NET_ULNET_CORE_H__
-#define __COLIBRI_NET_ULNET_CORE_H__
-
-/**
-   @defgroup ULNetCore LNet Transport Core Userspace Private Interface
-   @ingroup LNetCore
-
-   @todo This section will be filled in by the (net, lnet-user, DLD) task.
-
-   @{
-*/
-
-/**
-   Userspace domain private data.
-   This structure is pointed to by nlx_core_domain::lcd_upvt.
- */
-struct nlx_ucore_domain {
-	/** File descriptor to the kernel device */
-	int      ucd_fd;
-};
-
-/**
-   Userspace transfer machine private data.
-   This structure is pointed to by nlx_core_transfer_mc::lctm_upvt.
-*/
-struct nlx_ucore_transfer_mc {
-
-};
-
-/**
-   Userspace buffer private data.
-   This structure is pointed to by nlx_core_buffer::lcb_upvt.
-*/
-struct nlx_ucore_buffer {
-
-};
-
-/**
-   @}
-*/
-
-#endif /* __COLIBRI_NET_ULNET_CORE_H__ */
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 79
- *  scroll-step: 1
- *  End:
- */
diff --git a/net/net.c b/net/net.c
index 4209830..d1d6805 100644
--- a/net/net.c
+++ b/net/net.c
@@ -14,7 +14,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Nikita Danilov <Nikita_Danilov@xyratex.com>
+ * Original author: Nikita Danilov
  * Original creation date: 07/01/2010
  */
 
diff --git a/net/net.h b/net/net.h
index de38b7f..be6e1e2 100644
--- a/net/net.h
+++ b/net/net.h
@@ -14,9 +14,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Alexey Lyashkov <Alexey_Lyashkov@xyratex.com>,
- *                  Nikita Danilov <Nikita_Danilov@xyratex.com>,
- *                  Carl Braganza <Carl_Braganza@us.xyratex.com>
+ * Original author: Alexey Lyashkov, Nikita Danilov, Carl Braganza
  * Original creation date: 04/01/2010
  */
 
@@ -28,7 +26,6 @@
 #include "lib/cdefs.h"
 #include "lib/rwlock.h"
 #include "lib/list.h"
-#include "lib/tlist.h"
 #include "lib/queue.h"
 #include "lib/refs.h"
 #include "lib/chan.h"
@@ -67,9 +64,6 @@
    transport, then the document is the reference for the internal threading and
    serialization model.
 
-   See <a href="https://docs.google.com/a/xyratex.com/document/d/1TZG__XViil3ATbWICojZydvKzFNbL7-JJdjBbXTLgP4/edit?hl=en_US">HLD of Colibri LNet Transport</a>
-   for additional details on the design and use of this API.
-
    See @ref netDep for the older interfaces.
 
    @{
@@ -78,7 +72,6 @@
 
 /*import */
 struct c2_fop; /* deprecated */
-struct c2_bitmap;
 
 /* export */
 struct c2_net_xprt;
@@ -113,11 +106,6 @@ int c2_net_init(void);
  */
 void c2_net_fini(void);
 
-enum {
-	/* Hex value for "netmagic" */
-	C2_NET_MAGIC = 0x6E65746D61676963
-};
-
 /** Network transport (e.g., lnet or sunrpc) */
 struct c2_net_xprt {
 	const char                   *nx_name;
@@ -130,20 +118,20 @@ struct c2_net_xprt {
  */
 struct c2_net_xprt_ops {
 	/**
-	   Initialises transport specific part of a domain (e.g., start threads,
+	   Initialise transport specific part of a domain (e.g., start threads,
 	   initialise portals).
 	   Only the c2_net_mutex is held across this call.
 	 */
 	int  (*xo_dom_init)(struct c2_net_xprt *xprt,
 			    struct c2_net_domain *dom);
 	/**
-	   Finalises transport resources in a domain.
+	   Finalise transport resources in a domain.
 	   Only the c2_net_mutex is held across this call.
 	 */
 	void (*xo_dom_fini)(struct c2_net_domain *dom);
 
 	/**
-	   Performs transport level initialization of the transfer machine.
+	   Perform transport level initialization of the transfer machine.
 	   @param tm   Transfer machine pointer.
              All fields will be initialized at this time, specifically:
              @li ntm_dom
@@ -156,37 +144,23 @@ struct c2_net_xprt_ops {
 	int (*xo_tm_init)(struct c2_net_transfer_mc *tm);
 
 	/**
-	   Optional method to set the processor affinity for the threads of
-	   a transfer machine.
-	   The transfer machine must be initialized but not yet started.
-	   @param tm Transfer machine pointer.
-	   @param processors Processor bitmap.
-	   @retval 0 (success)
-	   @retval -ENOSYS  No affinity support available. Implied by a
-	   missing method.
-	 */
-	int (*xo_tm_confine)(struct c2_net_transfer_mc *tm,
-			     const struct c2_bitmap *processors);
-
-	/**
-	   Initiates the startup of the (initialized) transfer machine.
+	   Initiate the startup of the (initialized) transfer machine.
 	   A completion event should be posted when started, using a different
 	   thread.
 	   <b>Serialized using the transfer machine mutex.</b>
 	   @param tm   Transfer machine pointer.
              The following fields are of special interest to this method:
              @li ntm_dom
+	     @li ntm_ep - End point associated with the transfer machine.
 	     @li ntm_xprt_private
-	   @param addr  Address of the transfer machine.
-	   The method should not reference this string after it returns.
            @retval 0 (success)
 	   @retval -errno (failure)
 	   @see c2_net_tm_start()
 	 */
-	int (*xo_tm_start)(struct c2_net_transfer_mc *tm, const char *addr);
+	int (*xo_tm_start)(struct c2_net_transfer_mc *tm);
 
 	/**
-	   Initiates the shutdown of a transfer machine, cancelling any
+	   Initiate the shutdown of a transfer machine, cancelling any
 	   pending startup.
 	   No incoming messages should be accepted.  Pending operations should
 	   drain or be cancelled if requested.
@@ -203,7 +177,7 @@ struct c2_net_xprt_ops {
 	int (*xo_tm_stop)(struct c2_net_transfer_mc *tm, bool cancel);
 
 	/**
-	   Releases resources associated with a transfer machine.
+	   Release resources associated with a transfer machine.
 	   The transfer machine will be in the stopped state.
 	   @param tm   Transfer machine pointer.
              The following fields are of special interest to this method:
@@ -215,22 +189,21 @@ struct c2_net_xprt_ops {
 	void (*xo_tm_fini)(struct c2_net_transfer_mc *tm);
 
 	/**
-	   Creates an end point with a specific address.
+	   Create an end point with a specific address.
 	   @param epp     Returned end point data structure.
-	   @param tm      Specify the transfer machine pointer.
+	   @param dom     Specify the domain pointer.
 	   @param addr    Address string.  Could be NULL to
 	                  indicate dynamic addressing.
-			  Do not reference the string after return.
            @retval 0 (success)
 	   @retval -errno (failure)
 	   @see c2_net_end_point_create()
 	 */
 	int (*xo_end_point_create)(struct c2_net_end_point **epp,
-				   struct c2_net_transfer_mc *tm,
+				   struct c2_net_domain *dom,
 				   const char *addr);
 
 	/**
-	   Registers the buffer for use with a transfer machine in
+	   Register the buffer for use with a transfer machine in
 	   the manner indicated by the c2_net_buffer.nb_qtype value.
 	   @param nb  Buffer pointer with c2_net_buffer.nb_dom set.
            @retval 0 (success)
@@ -240,14 +213,16 @@ struct c2_net_xprt_ops {
 	int (*xo_buf_register)(struct c2_net_buffer *nb);
 
 	/**
-	   Deregisters the buffer from the transfer machine.
+	   Deregister the buffer from the transfer machine.
 	   @param nb  Buffer pointer with c2_net_buffer.nb_tm set.
+           @retval 0 (success)
+	   @retval -errno (failure)
 	   @see c2_net_buffer_deregister()
 	 */
-	void (*xo_buf_deregister)(struct c2_net_buffer *nb);
+	int (*xo_buf_deregister)(struct c2_net_buffer *nb);
 
 	/**
-	   Initiates an operation on a buffer on the transfer machine's
+	   Initiate an operation on a buffer on the transfer machine's
 	   queues.
 
 	   In the case of buffers added to the C2_NET_QT_ACTIVE_BULK_RECV
@@ -277,7 +252,7 @@ struct c2_net_xprt_ops {
 	int (*xo_buf_add)(struct c2_net_buffer *nb);
 
 	/**
-	   Cancels an operation involving a buffer.
+	   Cancel an operation involving a buffer.
 	   The method should cancel the operation involving use of the
 	   buffer, as described by the value of the c2_net_buffer.nb_qtype
 	   field.
@@ -292,43 +267,7 @@ struct c2_net_xprt_ops {
 	void (*xo_buf_del)(struct c2_net_buffer *nb);
 
 	/**
-	   Invoked by the c2_net_buffer_event_deliver_synchronously()
-	   subroutine to request the transport to disable automatic delivery
-	   of buffer events.  The method is optional and need not be specified
-	   if this support is not available.
-	   If supported, then the xo_bev_deliver_all() and the xo_bev_pending()
-	   operations must be provided.
-	   @see c2_net_buffer_event_deliver_synchronously()
-	 */
-	int  (*xo_bev_deliver_sync)(struct c2_net_transfer_mc *tm);
-
-	/**
-	   Invoked by the c2_net_buffer_event_deliver_all() subroutine.
-	   Optional if the synchronous buffer event delivery feature is not
-	   supported.
-	   As buffer event delivery takes place without holding the transfer
-	   machine mutex, the transport should protect the invocation of this
-	   subroutine from synchronous termination of the transfer machine.
-	 */
-	void (*xo_bev_deliver_all)(struct c2_net_transfer_mc *tm);
-
-	/**
-	   Invoked by the c2_net_buffer_event_pending() subroutine.
-	   Optional if the synchronous buffer event delivery feature is not
-	   supported.
-	 */
-	bool (*xo_bev_pending)(struct c2_net_transfer_mc *tm);
-
-	/**
-	   Invoked by the c2_net_buffer_event_notify() subroutine.
-	   Optional if the synchronous buffer event delivery feature is not
-	   supported.
-	 */
-	void (*xo_bev_notify)(struct c2_net_transfer_mc *tm,
-			      struct c2_chan *chan);
-
-	/**
-	   Retrieves the maximum buffer size (includes all segments).
+	   Retrieve the maximum buffer size (includes all segments).
 	   @param dom     Domain pointer.
 	   @retval size    Returns the maximum buffer size.
 	   @see c2_net_domain_get_max_buffer_size()
@@ -336,7 +275,7 @@ struct c2_net_xprt_ops {
 	c2_bcount_t (*xo_get_max_buffer_size)(const struct c2_net_domain *dom);
 
 	/**
-	   Retrieves the maximum buffer segment size.
+	   Retrieve the maximum buffer segment size.
 	   @param dom     Domain pointer.
 	   @retval size    Returns the maximum segment size.
 	   @see c2_net_domain_get_max_buffer_segment_size()
@@ -345,7 +284,7 @@ struct c2_net_xprt_ops {
 						      *dom);
 
 	/**
-	   Retrieves the maximum number of buffer segments.
+	   Retrieve the maximum number of buffer segments.
 	   @param dom      Domain pointer.
 	   @retval num_segs Returns the maximum segment size.
 	   @see c2_net_domain_get_max_buffer_segment_size()
@@ -376,7 +315,7 @@ struct c2_net_xprt_ops {
 };
 
 /**
- Initializes the transport software.
+ Initialize the transport software.
  A network domain must be initialized to use the transport.
  @param xprt Tranport pointer.
  @retval 0 (success)
@@ -385,7 +324,7 @@ struct c2_net_xprt_ops {
 int  c2_net_xprt_init(struct c2_net_xprt *xprt);
 
 /**
- Shuts down the transport software.
+ Shutdown the transport software.
  All associated network domains should be cleaned up at this point.
  @pre Network domains should have been finalized.
  @param xprt Tranport pointer.
@@ -444,6 +383,11 @@ struct c2_net_domain {
 	struct c2_mutex     nd_mutex;
 
 	/**
+	   List of c2_net_end_point structures. Managed by the transport.
+	 */
+	struct c2_list      nd_end_points;
+
+	/**
 	   List of c2_net_buffer structures registered with the domain.
 	 */
 	struct c2_list      nd_registered_bufs;
@@ -469,21 +413,14 @@ struct c2_net_domain {
 
         /** <b>Deprecated.</b> Domain network stats */
         struct c2_net_stats nd_stats[NS_STATS_NR];
-
 	/**
 	   ADDB context for events related to this domain
 	 */
 	struct c2_addb_ctx  nd_addb;
-
-        /** Linkage for invoking application */
-        struct c2_tlink     nd_app_linkage;
-
-	/** Network magic */
-	uint64_t            nd_magic;
 };
 
 /**
-   Initializes a domain.
+   Initialize a domain.
  @param dom Domain pointer.
  @param xprt Tranport pointer.
  @pre dom->nd_xprt == NULL
@@ -493,7 +430,7 @@ struct c2_net_domain {
 int c2_net_domain_init(struct c2_net_domain *dom, struct c2_net_xprt *xprt);
 
 /**
-   Releases resources related to a domain.
+   Release resources related to a domain.
    @pre All end points, registered buffers and transfer machines released.
    @param dom Domain pointer.
  */
@@ -525,8 +462,7 @@ int32_t c2_net_domain_get_max_buffer_segments(struct c2_net_domain *dom);
 
 /**
    This represents an addressable network end point. Memory for this data
-   structure is managed by the network transport component and is associated
-   with the transfer machine that created the structure.
+   structure is managed by the network transport component.
 
    Multiple entities may reference and use the data structure at the same time,
    so a reference count is maintained within it to determine when it is safe to
@@ -534,35 +470,32 @@ int32_t c2_net_domain_get_max_buffer_segments(struct c2_net_domain *dom);
 
    Transports should embed this data structure in their private end point
    structures, and provide the release() method required to free them.
-   The release() method, which is called with the transfer machine mutex
-   locked, should remove the data structure from the transfer machine
-   ntm_end_points list.
+   The release() method should grab the network domain mutex and dequeue the
+   data structure from the domain.
  */
 struct c2_net_end_point {
 	/** Keeps track of usage */
-	struct c2_ref              nep_ref;
-	/** Pointer to transfer machine */
-	struct c2_net_transfer_mc *nep_tm;
-	/** Linkage in the transfer machine list */
-	struct c2_list_link        nep_tm_linkage;
+	struct c2_ref          nep_ref;
+	/** Pointer to the network domain */
+	struct c2_net_domain  *nep_dom;
+	/** Linkage in the domain list */
+	struct c2_list_link    nep_dom_linkage;
 	/** Transport specific printable representation of the
 	    end point address.
 	 */
-	const char                *nep_addr;
+	const char            *nep_addr;
 };
 
 /**
    Allocates an end point data structure representing the desired
    end point and sets its reference count to 1,
    or increments the reference count of an existing matching data structure.
-   The data structure is linked to the transfer machine.
    The invoker should call the c2_net_end_point_put() when the
    data structure is no longer needed.
    @param epp Pointer to a pointer to the data structure which will be
    set upon return.  The reference count of the returned data structure
    will be at least 1.
-   @param tm  Transfer machine pointer.  The transfer machine must be in
-   the started state.
+   @param dom Network domain pointer.
    @param addr String describing the end point address in a transport specific
    manner.  The format of this address string is the same as the printable
    representation form stored in the end point nep_addr field.  It is optional,
@@ -571,18 +504,16 @@ struct c2_net_end_point {
    The address string, if specified, is not referenced again after return from
    this subroutine.
    @see c2_net_end_point_get(), c2_net_end_point_put()
-   @pre tm->ntm_state == C2_NET_TM_STARTED
-   @post (*epp)->nep_ref->ref_cnt >= 1 && (*epp)->nep_addr != NULL &&
-   (*epp)->nep_tm == tm
+   @post (*epp)->nep_ref->ref_cnt >= 1 && (*epp)->nep_addr != NULL
    @retval 0 on success
    @retval -errno on failure
  */
-int c2_net_end_point_create(struct c2_net_end_point  **epp,
-			    struct c2_net_transfer_mc *tm,
-			    const char                *addr);
+int c2_net_end_point_create(struct c2_net_end_point **epp,
+			    struct c2_net_domain     *dom,
+			    const char               *addr);
 
 /**
-   Increments the reference count of an end point data structure.
+   Increment the reference count of an end point data structure.
    This is used to safely point to the structure in a different context -
    when done, the reference count should be decremented by a call to
    c2_net_end_point_put().
@@ -593,13 +524,13 @@ int c2_net_end_point_create(struct c2_net_end_point  **epp,
 void c2_net_end_point_get(struct c2_net_end_point *ep);
 
 /**
-   Decrements the reference count of an end point data structure.
+   Decrement the reference count of an end point data structure.
    The structure will be released when the count goes to 0.
    @param ep End point data structure pointer.
    Do not dereference this pointer after this call.
    @pre ep->nep_ref->ref_cnt >= 1
-   @note The transfer machine mutex will be obtained internally to synchronize
-   the transport provided release() method in case the end point gets released.
+   @note The domain lock will be obtained internally to synchronize the
+   transport provided release() method in case the end point gets released.
    @retval 0 (success)
    @retval -errno (failure)
  */
@@ -717,8 +648,7 @@ enum c2_net_tm_ev_type {
      state change.
      The nte_next_state field describes the destination state.
      Refer to the nte_status field to determine if the operation succeeded.
-     The nte_ep field is set if the next state is C2_NET_TM_STARTED; the
-     value is used to set the ntm_ep field of the transfer machine.
+     Refer to the nte_status field to determine if the operation succeeded.
    - C2_NET_TEV_DIAGNOSTIC provides diagnostic information.
      The nte_payload field may point to transport specific data.
      The API does not require nor specify how a transport produces
@@ -772,12 +702,6 @@ struct c2_net_tm_event {
 	enum c2_net_tm_state       nte_next_state;
 
 	/**
-	   End point pointer to be used to set the value of the ntm_ep
-	   field when the state changes to C2_NET_TM_STARTED.
-	*/
-	struct c2_net_end_point   *nte_ep;
-
-	/**
 	   Valid only if the nte_type is C2_NET_TEV_STATE_DIAGNOSTIC.
 
 	   Transports may use this to point to internal data; they
@@ -889,19 +813,13 @@ struct c2_net_transfer_mc {
 	struct c2_net_domain       *ntm_dom;
 
 	/**
-	   List of c2_net_end_point structures. Managed by the transport.
-	 */
-	struct c2_list              ntm_end_points;
-
-	/**
 	   End point associated with this transfer machine.
 	   Messages sent from this
 	   transfer machine appear to have originated from this end point.
-
-	   It is created internally with the address provided in the
-	   call to c2_net_tm_start().  The field is set only upon
-	   successful start of the transfer machine.
-	   The field is cleared durinng fini.
+	   It is provided by the application during the
+	   call to c2_net_tm_start().
+	   @note The assumption here is that the transport can maintain
+	   separate receive message buffer pools for each transfer machine.
 	 */
         struct c2_net_end_point    *ntm_ep;
 
@@ -914,7 +832,7 @@ struct c2_net_transfer_mc {
 	/**
 	   Lists of c2_net_buffer structures by queue type.
 	 */
-	struct c2_tl		    ntm_q[C2_NET_QT_NR];
+	struct c2_list              ntm_q[C2_NET_QT_NR];
 
 	/** Statistics maintained per logical queue */
 	struct c2_net_qstats        ntm_qstats[C2_NET_QT_NR];
@@ -924,13 +842,10 @@ struct c2_net_transfer_mc {
 
 	/** Transport private data */
         void                       *ntm_xprt_private;
-
-	/** Indicates if automatic delivery of buffer events will take place. */
-	bool                        ntm_bev_auto_deliver;
 };
 
 /**
-   Initializes a transfer machine.
+   Initialize a transfer machine.
    @param tm  Pointer to transfer machine data structure to be initialized.
 
    Prior to invocation the following fields should be set:
@@ -943,48 +858,23 @@ struct c2_net_transfer_mc {
    appropriate initial values.
    @note An initialized TM cannot be fini'd without first starting it.
    @param dom Network domain pointer.
-   @post tm->ntm_bev_auto_deliver is set.
    @retval 0 (success)
    @retval -errno (failure)
  */
 int c2_net_tm_init(struct c2_net_transfer_mc *tm, struct c2_net_domain *dom);
 
 /**
-   Finalizes a transfer machine, releasing any associated
+   Finalize a transfer machine, releasing any associated
    transport specific resources.
-
-   All application references to end points associated with this transfer
-   machine should be released prior to this call.
-   @pre
-   (tm->ntm_state == C2_NET_TM_STOPPED ||
-    tm->ntm_state == C2_NET_TM_FAILED  ||
-    tm->ntm_state == C2_NET_TM_INITIALIZED) &&
-   ((c2_list_is_empty(&tm->ntm_end_points) && tm->ntm_ep == NULL) ||
-    (c2_list_length(&tm->ntm_end_points) == 1 &&
-     c2_list_contains(&tm->ntm_end_points, tm->ntm_ep) &&
-     c2_atomic64_get(tm->ntm_ep->nep_ref.ref_cnt) == 1))
+   @pre tm->ntm_state == C2_NET_TM_STOPPED ||
+        tm->ntm_state == C2_NET_TM_FAILED ||
+	tm->ntm_state == C2_NET_TM_INITIALIZED
    @param tm Transfer machine pointer.
  */
 void c2_net_tm_fini(struct c2_net_transfer_mc *tm);
 
 /**
-   Sets the processor affinity of the threads of a transfer machine.
-   The transfer machine must be initialized but not yet started.
-
-   Support for this operation is transport specific.
-   @pre tm->ntm_state == C2_NET_TM_INITIALIZED
-   @param tm Transfer machine pointer.
-   @param processors Processor bitmap.  The bit map is not referenced
-   internally after the subroutine returns.
-   @retval -ENOSYS  No affinity support available in the transport.
-   @see @ref Processor "Processor API"
-   @see @ref bitmap "Bitmap API"
- */
-int c2_net_tm_confine(struct c2_net_transfer_mc *tm,
-		      const struct c2_bitmap *processors);
-
-/**
-   Starts a transfer machine.
+   Start a transfer machine.
 
    The subroutine does not block the invoker. Instead the state is
    immediately changed to C2_NET_TM_STARTING, and an event will be
@@ -997,24 +887,17 @@ int c2_net_tm_confine(struct c2_net_transfer_mc *tm,
 
    @pre tm->ntm_state == C2_NET_TM_INITIALIZED
    @param tm  Transfer machine pointer.
-   @param addr End point address to associate with the transfer machine.
-   May be null if dynamic addressing is supported by the transport.
-   The end point is created internally and made visible by the ntm_ep field
-   only if the start operation succeeds.
+   @param ep  End point to associate with the transfer machine.
    @retval 0 (success)
    @retval -errno (failure)
-   @see c2_net_end_point_create()
  */
-int c2_net_tm_start(struct c2_net_transfer_mc *tm, const char *addr);
+int c2_net_tm_start(struct c2_net_transfer_mc *tm,
+		    struct c2_net_end_point *ep);
 
 /**
-   Initiates the shutdown of a transfer machine.  New messages will
-   not be accepted and new end points cannot be created.
-   Pending operations will be completed or aborted as desired.
-
-   All end point references must be released by the application prior
-   to invocation.  The only end point reference that may exist is that of
-   this transfer machine itself, and that will be released during fini.
+   Initiate the shutdown of a transfer machine.  New messages will
+   not be accepted.  Pending operations will be completed or
+   aborted as desired.
 
    The subroutine does not block the invoker.  Instead the state is
    immediately changed to C2_NET_TM_STOPPING, and an event will be
@@ -1038,7 +921,7 @@ int c2_net_tm_start(struct c2_net_transfer_mc *tm, const char *addr);
 int c2_net_tm_stop(struct c2_net_transfer_mc *tm, bool abort);
 
 /**
-   Retrieves transfer machine statistics for all or for a single logical queue,
+   Retrieve transfer machine statistics for all or for a single logical queue,
    optionally resetting the data.  The operation is performed atomically
    with respect to on-going transfer machine activity.
    @pre tm->ntm_state >= C2_NET_TM_INITIALIZED
@@ -1102,15 +985,9 @@ struct c2_net_buffer_event {
 	   error number is used to indicate the reasons for failure.
 
 	   The following errors are well defined:
-		- <b>-ECANCELED</b> This is used in buffer release events to
+	   	- <b>-ECANCELED</b> This is used in buffer release events to
 		indicate that the associated buffer operation was
 		cancelled by a call to c2_net_buffer_del().
-		- <b>-ETIMEDOUT</b> This is used in buffer release events to
-		indicate that the associated buffer operation did not complete
-		before the current time exceeded the nb_timeout value.
-		The support for this feature is transport specific.
-		The nb_timeout value is always reset to C2_TIME_NEVER by the
-		time the buffer callback is invoked.
 	 */
 	int32_t                    nbe_status;
 
@@ -1129,8 +1006,9 @@ struct c2_net_buffer_event {
 	   C2_NET_QT_ACTIVE_BULK_RECV queues.
 
 	   Provided for future support of multi-delivery buffer transports.
-	   Applications should take it into consideration when determining the
-	   starting location of the event data in the buffer.
+	   The value will be set to 0 for now, but applications should
+	   take it into consideration when determining the starting location
+	   of the event data in the buffer.
 	 */
 	c2_bcount_t                nbe_offset;
 
@@ -1181,12 +1059,6 @@ enum c2_net_buf_flags {
 	C2_NET_BUF_IN_USE      = 1<<2,
 	/** Indicates that the buffer operation has been cancelled */
 	C2_NET_BUF_CANCELLED   = 1<<3,
-	/** Indicates that the buffer operation has timed out */
-	C2_NET_BUF_TIMED_OUT   = 1<<4,
-	/** Set by the transport to indicate that a buffer should not be
-	    dequeued in a c2_net_buffer_event_post() call.
-	 */
-	C2_NET_BUF_RETAIN      = 1<<5,
 };
 
 /**
@@ -1275,14 +1147,7 @@ struct c2_net_buffer {
 	   buffer to a transfer machine logical queue.
 
 	   <b>Support for this is transport specific.</b>
-	   A value of C2_TIME_NEVER disables the timeout.
-	   The value is forced to C2_TIME_NEVER during buffer registration,
-	   and reset to the same prior to the invocation of the buffer
-	   callback so applications need not bother with this field unless
-	   they intend to set a timeout value.
-
-	   Adding a buffer to a logical queue will fail with a -ETIME
-	   error code if the specified nb_timeout value is in the past.
+	   Set the value to C2_TIME_NEVER to disable the timeout.
 	 */
 	c2_time_t                  nb_timeout;
 
@@ -1314,14 +1179,22 @@ struct c2_net_buffer {
 	struct c2_net_buf_desc     nb_desc;
 
 	/**
-	   This field identifies an end point in the associated transfer
-	   machine.
+	   This field identifies an end point. Its usage varies by context:
 
-	   When sending messages the application should specify the end point
-	   of the destination before adding the buffer to the
-	   C2_NET_QT_MSG_SEND queue.
+	   - In received messages (C2_NET_QT_MSG_RECV queue) the transport
+	   will set the end point to identify the sender of the message
+	   before invoking the completion callback on the buffer.
+	   The end point will be released when the callback returns.
 
-	   The field is not used for the bulk cases nor for received messages.
+	   - When sending messages
+	   the application should specify the end point of the destination
+	   before adding the buffer to the C2_NET_QT_MSG_SEND queue.
+	   - When adding a buffer to the C2_NET_QT_PASSIVE_BULK_RECV or
+	   C2_NET_PASSIVE_BULK_SEND queues, the application must set this
+	   field to identify the end point that will initiate the bulk data
+	   transfer.
+
+	   The field is not used for the active bulk cases.
 	 */
 	struct c2_net_end_point   *nb_ep;
 
@@ -1333,13 +1206,7 @@ struct c2_net_buffer {
 
 	   The application should not modify this field.
 	 */
-	struct c2_tlink		   nb_tm_linkage;
-
-	/** Linkage into a network buffer pool. */
-	struct c2_tlink		   nb_lru;
-
-	/** Magic for network buffer list. */
-	uint64_t		   nb_magic;
+	struct c2_list_link        nb_tm_linkage;
 
 	/**
 	   Linkage into one of the domain list that tracks registered buffers.
@@ -1367,35 +1234,20 @@ struct c2_net_buffer {
 	   after de-registration.
 	 */
 	uint64_t                   nb_flags;
-
-	/**
-	   Minimum remaining size in a receive buffer to allow reuse
-	   for multiple messages.
-	   The value may not be 0 for buffers in the C2_NET_QT_MSG_RECV queue.
-	 */
-	c2_bcount_t                nb_min_receive_size;
-
-	/**
-	   Maximum number of messages that may be received in the buffer.
-	   The value may not be 0 for buffers in the C2_NET_QT_MSG_RECV queue.
-	 */
-	uint32_t                   nb_max_receive_msgs;
 };
 
 /**
-   Registers a buffer with the domain. The domain could perform some
+   Register a buffer with the domain. The domain could perform some
    optimizations under the covers.
    @pre
 (buf->nb_flags == 0) &&
 (buf->nb_buffer.ov_buf != NULL) &&
 c2_vec_count(&buf->nb_buffer.ov_vec) > 0
    @post ergo(result == 0, buf->nb_flags & C2_NET_BUF_REGISTERED)
-   @post ergo(result == 0, buf->nb_timeout == C2_TIME_NEVER)
    @param buf Pointer to a buffer. The buffer should have the following fields
    initialized:
    - c2_net_buffer.nb_buffer should be initialized to point to the buffer
    memory regions.
-   The buffer's timeout value is initialized to C2_TIME_NEVER upon return.
    @param dom Pointer to the domain.
    @retval 0 (success)
    @retval -errno (failure)
@@ -1404,7 +1256,7 @@ int c2_net_buffer_register(struct c2_net_buffer *buf,
 			   struct c2_net_domain *dom);
 
 /**
-   Deregisters a previously registered buffer and releases any transport
+   Deregister a previously registered buffer and releases any transport
    specific resources associated with it.
    The buffer should not be in use, nor should this subroutine be
    invoked from a callback.
@@ -1413,12 +1265,14 @@ int c2_net_buffer_register(struct c2_net_buffer *buf,
 (buf->nb_dom == dom)
    @param buf Specify the buffer pointer.
    @param dom Specify the domain pointer.
+   @retval 0 (success)
+   @retval -errno (failure)
  */
-void c2_net_buffer_deregister(struct c2_net_buffer *buf,
-			      struct c2_net_domain *dom);
+int c2_net_buffer_deregister(struct c2_net_buffer *buf,
+			     struct c2_net_domain *dom);
 
 /**
-   Adds a registered buffer to a transfer machine's logical queue specified
+   Add a registered buffer to a transfer machine's logical queue specified
    by the c2_net_buffer.nb_qtype value.
    - Buffers added to the C2_NET_QT_MSG_RECV queue are used to receive
    messages.
@@ -1451,29 +1305,21 @@ void c2_net_buffer_deregister(struct c2_net_buffer *buf,
 (buf->nb_dom == tm->ntm_dom) &&
 (tm->ntm_state == C2_NET_TM_STARTED) &&
 c2_net__qtype_is_valid(buf->nb_qtype) &&
-buf->nb_flags == C2_NET_BUF_REGISTERED &&
+(buf->nb_flags & C2_NET_BUF_REGISTERED) &&
+!(buf->nb_flags &
+  (C2_NET_BUF_QUEUED | C2_NET_BUF_IN_USE | C2_NET_BUF_CANCELLED)) &&
 buf->nb_callbacks->nbc_cb[buf->nb_qtype] != NULL &&
-ergo(buf->nb_qtype == C2_NET_QT_MSG_RECV,
-     buf->nb_min_receive_size != 0 && buf->nb_max_receive_msgs != 0) &&
-ergo(buf->nb_qtype == C2_NET_QT_MSG_SEND, buf->nb_ep != NULL) &&
-ergo(buf->nb_qtype == C2_NET_QT_ACTIVE_BULK_RECV ||
-     buf->nb_qtype == C2_NET_QT_ACTIVE_BULK_SEND, buf->nb_desc.nbd_len != 0) &&
-ergo(buf->nb_qtype == C2_NET_QT_MSG_SEND ||
-     buf->nb_qtype == C2_NET_QT_PASSIVE_BULK_SEND ||
-     buf->nb_qtype == C2_NET_QT_ACTIVE_BULK_SEND, buf->nb_length > 0)
+(buf->nb_qtype != C2_NET_QT_MSG_RECV || buf->nb_ep == NULL)
    @param buf Specify the buffer pointer.
    @param tm  Specify the transfer machine pointer
    @retval 0 (success)
    @retval -errno (failure)
-   @retval -ETIME nb_timeout is set to other than C2_TIME_NEVER, and occurs in
-   the past.
-   Note that this differs from them buffer timeout error code of -ETIMEDOUT.
  */
 int c2_net_buffer_add(struct c2_net_buffer *buf,
 		      struct c2_net_transfer_mc *tm);
 
 /**
-   Removes a registered buffer from a logical queue, if possible,
+   Remove a registered buffer from a logical queue, if possible,
    cancelling any operation in progress.
 
    <b>Cancellation support is provided by the underlying transport.</b> It is
@@ -1506,29 +1352,16 @@ void c2_net_buffer_del(struct c2_net_buffer *buf,
    elsewhere after this subroutine returns, so may be allocated on the
    stack of the calling thread.
 
-   Multiple concurrent events may be delivered for a given buffer, depending
-   upon the transport.
-
-   The subroutine will remove a buffer from its queue if the
-   C2_NET_BUF_RETAIN flag is @em not set.  It will clear the C2_NET_BUF_QUEUED
-   and C2_NET_BUF_IN_USE flags and set the nb_timeout field to C2_TIME_NEVER if
-   the buffer is dequeued.  It will always clear the C2_NET_BUF_RETAIN,
-   C2_NET_BUF_CANCELLED and C2_NET_BUF_TIMED_OUT flags prior to invoking the
-   callback. The C2_NET_BUF_RETAIN flag must not be set if the status indicates
-   error.
+   Multiple concurrent events may be delivered for a given buffer.
 
-   If the C2_NET_BUF_CANCELLED flag was set, then the status must be
-   -ECANCELED.
-
-   If the C2_NET_BUF_TIMED_OUT flag was set, then the status must be
-   -ETIMEDOUT.
+   The subroutine will remove the buffer from its queue, and clear its
+   C2_NET_BUF_QUEUED, C2_NET_BUF_IN_USE and C2_NET_BUF_CANCELLED flags
+   prior to invoking the callback.  If the C2_NET_BUF_CANCELLED flag was
+   set, then the status is forced to -ECANCELED.
 
    The subroutine will perform a c2_end_point_put() on the nbe_ep field
    in the event structure, if the queue type is C2_NET_QT_MSG_RECV and
-   the nbe_status value is 0, and for the C2_NET_QT_MSG_SEND queue to
-   match the c2_end_point_get() made in the c2_net_buffer_add() call.
-   Care should be taken by the transport to accomodate these adjustments
-   when invoking the subroutine with the C2_NET_BUF_RETAIN flag set.
+   the nbe_status value is 0.
 
    The subroutine will also signal to all waiters on the
    c2_net_transfer_mc.ntm_chan field after delivery of the callback.
@@ -1544,66 +1377,7 @@ void c2_net_buffer_del(struct c2_net_buffer *buf,
 void c2_net_buffer_event_post(const struct c2_net_buffer_event *ev);
 
 /**
-   Deliver all pending network buffer events.  Should be called periodically
-   by the application if synchronous network buffer event processing is
-   enabled.
-   @param tm Pointer to a transfer machine which has been set up for
-   synchronous network buffer event processing.
-   @see c2_net_buffer_event_deliver_synchronously(),
-   c2_net_buffer_event_pending(), c2_net_buffer_event_notify()
-   @pre tm->ntm_bev_auto_deliver is not set.
- */
-void c2_net_buffer_event_deliver_all(struct c2_net_transfer_mc *tm);
-
-/**
-   This subroutine disables the automatic delivery of network buffer events.
-   Instead, the application should use the c2_net_buffer_event_pending()
-   subroutine to check for the presence of events, and the
-   c2_net_buffer_event_deliver_all() subroutine to cause pending events to
-   be delivered.  The c2_net_buffer_event_notify() subroutine can be used
-   to get notified on a wait channel when buffer events arrive.
-
-   Support for this mode of operation is transport specific.
-
-   The subroutine must be invoked before the transfer machine is started.
-
-   @param tm Pointer to an initialized but not started transfer machine.
-   @pre tm->ntm_bev_auto_deliver is set.
-   @post tm->ntm_bev_auto_deliver is not set.
-   @see c2_net_buffer_event_pending(), c2_net_buffer_event_deliver_all(),
-   c2_net_buffer_event_notify()
- */
-int c2_net_buffer_event_deliver_synchronously(struct c2_net_transfer_mc *tm);
-
-/**
-   This subroutine determines if there are pending network buffer events that
-   can be delivered with the c2_net_buffer_event_deliver_all() subroutine.
-   @param tm Pointer to a transfer machine which has been set up for
-   synchronous network buffer event processing.
-   @see c2_net_buffer_event_deliver_synchronously()
-   @pre tm->ntm_bev_auto_deliver is not set.
- */
-bool c2_net_buffer_event_pending(struct c2_net_transfer_mc *tm);
-
-/**
-   This subroutine arranges for notification of the arrival of the next network
-   buffer event to be signalled on the specified channel.  Typically, this
-   subroutine is called only when the the c2_net_buffer_event_pending()
-   subroutine indicates that there are no events pending.
-   The subroutine does not block the invoker.
-   @note The subroutine exhibits "monoshot" behavior - it only signals once
-   on the specified wait channel.
-   @param tm Pointer to a transfer machine which has been set up for
-   synchronous network buffer event processing.
-   @param chan The wait channel on which to send the signal.
-   @see c2_net_buffer_event_deliver_synchronously()
-   @pre tm->ntm_bev_auto_deliver is not set.
- */
-void c2_net_buffer_event_notify(struct c2_net_transfer_mc *tm,
-				   struct c2_chan *chan);
-
-/**
-   Copies a network buffer descriptor.
+   Copy a network buffer descriptor.
    @param from_desc Specifies the source descriptor data structure.
    @param to_desc Specifies the destination descriptor data structure.
    @retval 0 (success)
@@ -1613,7 +1387,7 @@ int c2_net_desc_copy(const struct c2_net_buf_desc *from_desc,
 		     struct c2_net_buf_desc *to_desc);
 
 /**
-   Frees a network buffer descriptor.
+   Free a network buffer descriptor.
    @param desc Specify the network buffer descriptor. Its fields will be
    cleared after this operation.
  */
@@ -1629,15 +1403,15 @@ void c2_net_domain_stats_init(struct c2_net_domain *dom);
 void c2_net_domain_stats_fini(struct c2_net_domain *dom);
 
 /**
-   Collects values for stats.
+ Collect values for stats.
  */
 void c2_net_domain_stats_collect(struct c2_net_domain *dom,
                                  enum c2_net_stats_direction dir,
                                  uint64_t bytes,
                                  bool *sleeping);
 /**
-   Reports the network loading rate for a direction (in/out).
-   @retval rate, in percent * 100 of maximum seen rate (e.g. 1234 = 12.34%)
+ Report the network loading rate for a direction (in/out).
+ @retval rate, in percent * 100 of maximum seen rate (e.g. 1234 = 12.34%)
  */
 int c2_net_domain_stats_get(struct c2_net_domain *dom,
                             enum c2_net_stats_direction dir);
@@ -1680,7 +1454,7 @@ int  c2_service_id_init(struct c2_service_id *id, struct c2_net_domain *d, ...);
 void c2_service_id_fini(struct c2_service_id *id);
 
 /**
-   Compares node identifiers for equality.
+   Compare node identifiers for equality.
  */
 bool c2_services_are_same(const struct c2_service_id *c1,
 			  const struct c2_service_id *c2);
@@ -1780,7 +1554,7 @@ struct c2_net_conn_ops {
 };
 
 /**
-   Creates a network connection to a given service.
+   Create a network connection to a given service.
 
    Allocates resources and connects transport connection to some logical
    connection.  Logical connection is used to send rpc in the context of one or
@@ -1794,7 +1568,7 @@ struct c2_net_conn_ops {
 int c2_net_conn_create(struct c2_service_id *nid);
 
 /**
-   Finds a connection to a specified service.
+   Find a connection to a specified service.
 
    Scans the list of connections to find a logical connection associated with a
    given nid.
@@ -1807,7 +1581,7 @@ int c2_net_conn_create(struct c2_service_id *nid);
 struct c2_net_conn *c2_net_conn_find(const struct c2_service_id *nid);
 
 /**
-   Releases a connection.
+   Release a connection.
 
    Releases a reference on network connection. Reference to transport connection
    is released when the last reference to network connection has been released.
@@ -1815,7 +1589,7 @@ struct c2_net_conn *c2_net_conn_find(const struct c2_service_id *nid);
 void c2_net_conn_release(struct c2_net_conn *conn);
 
 /**
-   Unlinks connection from connection list.
+   Unlink connection from connection list.
 
    Transport connection(s) are released when the last reference on logical
    connection is released.
@@ -1888,20 +1662,6 @@ void c2_net_reply_post(struct c2_service *service, struct c2_fop *fop,
 extern struct c2_net_xprt c2_net_usunrpc_xprt;
 extern struct c2_net_xprt c2_net_ksunrpc_xprt;
 
-enum {
-	/* Hex ASCII value of "nb_lru" */
-	NET_BUFFER_LINK_MAGIC	 = 0x6e625f6c7275,
-	/* Hex ASCII value of "nb_tm_linkage" */
-	NET_BUFFER_TM_LINK_MAGIC = 0x6e625f746d5f6c,
-	/* Hex ASCII value of "nb_head" */
-	NET_BUFFER_HEAD_MAGIC	 = 0x6e625f68656164,
-};
-
-/** Descriptor for the tlist of buffers. */
-C2_TL_DESCR_DECLARE(pool, extern);
-C2_TL_DESCR_DECLARE(tm, extern);
-C2_TL_DECLARE(pool, extern, struct c2_net_buffer);
-C2_TL_DECLARE(tm, extern, struct c2_net_buffer);
 /** @} end of deprecated net group */
 
 #endif
diff --git a/net/net_cli.c b/net/net_cli.c
index ded4220..617edb9 100644
--- a/net/net_cli.c
+++ b/net/net_cli.c
@@ -13,8 +13,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Alexey Lyashkov <Alexey_Lyashkov@xyratex.com>,
- *                  Nikita Danilov <Nikita_Danilov@xyratex.com>
+ * Original author: Alexey Lyashkov, Nikita Danilov
  * Original creation date: 04/01/2010
  */
 
@@ -48,6 +47,7 @@ int c2_net_cli_call(struct c2_net_conn *conn, struct c2_net_call *call)
 	ADDB_ADD(conn, net_addb_conn_call);
 	return conn->nc_ops->sio_call(conn, call);
 }
+C2_EXPORTED(c2_net_cli_call);
 
 /**
    Send the request to connection asynchronously and don't wait for reply.
@@ -57,6 +57,7 @@ int c2_net_cli_send(struct c2_net_conn *conn, struct c2_net_call *call)
 	ADDB_ADD(conn, net_addb_conn_send);
 	return conn->nc_ops->sio_send(conn, call);
 }
+C2_EXPORTED(c2_net_cli_send);
 
 int c2_service_id_init(struct c2_service_id *id, struct c2_net_domain *dom, ...)
 {
@@ -69,6 +70,7 @@ int c2_service_id_init(struct c2_service_id *id, struct c2_net_domain *dom, ...)
 	va_end(varargs);
 	return result;
 }
+C2_EXPORTED(c2_service_id_init);
 
 void c2_service_id_fini(struct c2_service_id *id)
 {
diff --git a/net/net_internal.h b/net/net_internal.h
index e55a961..1db2597 100644
--- a/net/net_internal.h
+++ b/net/net_internal.h
@@ -14,8 +14,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Dave Cohrs <Dave_Cohrs@us.xyratex.com>,
- *                  Carl Braganza <Carl_Braganza@us.xyratex.com>
+ * Original author: Dave Cohrs, Carl Braganza
  * Original creation date: 04/04/2011
  */
 
@@ -79,11 +78,10 @@ bool c2_net__buffer_invariant(const struct c2_net_buffer *buf);
 
 /*
   Invariant checks for an end point. No mutex necessary.
-  Extra checks if under_tm_mutex set to true.
 */
-bool c2_net__ep_invariant(struct c2_net_end_point   *ep,
-			  struct c2_net_transfer_mc *tm,
-			  bool                       under_tm_mutex);
+bool c2_net__ep_invariant(struct c2_net_end_point *ep,
+			  struct c2_net_domain    *dom,
+			  bool                     under_dom_mutex);
 
 /*
   Validates tm state.
@@ -94,14 +92,6 @@ bool c2_net__tm_invariant(const struct c2_net_transfer_mc *tm);
 /* this shouldn't really be here but it parallels the extern in net/net.h */
 extern struct c2_net_xprt c2_net_usunrpc_minimal_xprt;
 
-/*
-  Shared constants used by (deprecated) usunrpc and ksunrpc transports.
- */
-enum {
-	C2_SESSION_PROGRAM = 0x20000001,
-	C2_DEF_RPC_VER = 1
-};
-
 #endif /* __COLIBRI_NET_NET_INTERNAL_H__ */
 
 /*
diff --git a/net/net_otw_types.ff b/net/net_otw_types.ff
index 6e53fb1..287c9d2 100644
--- a/net/net_otw_types.ff
+++ b/net/net_otw_types.ff
@@ -1,25 +1,5 @@
 /* -*- C -*- */
 
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Carl Braganza <Carl_Braganza@us.xyratex.com>,
- * Original creation date: 03/23/2011
- */
-
-
 /**
  @addtogroup net
  @{
diff --git a/net/net_srv.c b/net/net_srv.c
index ae0f89e..f195efd 100644
--- a/net/net_srv.c
+++ b/net/net_srv.c
@@ -13,12 +13,25 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Alexey Lyashkov <Alexey_Lyashkov@xyratex.com>,
- *                  Nikita Danilov <Nikita_Danilov@xyratex.com>,
- *                  Huang Hua <Hua_Huang@xyratex.com>
+ * Original author: Alexey Lyashkov, Nikita Danilov, Huang Hua
  * Original creation date: 04/11/2010
  */
 
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <memory.h>
+#include <time.h>
+#include <sys/time.h>
+#include <unistd.h>
+#include <pthread.h>
+#include <signal.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+
+#include <rpc/rpc.h>
+
 #include "lib/errno.h"
 #include "lib/assert.h"
 #include "lib/cdefs.h"
@@ -26,7 +39,7 @@
 #include "lib/memory.h"
 #include "fop/fop.h"
 
-#include "net/net.h"
+#include "net.h"
 
 /**
    @addtogroup netDep Networking (Deprecated Interfaces)
@@ -48,9 +61,8 @@ int c2_service_start(struct c2_service *service, struct c2_service_id *sid)
 	C2_ASSERT(service->s_table.not_nr > 0);
 
 	for (i = 0; i < service->s_table.not_nr; ++i) {
-		C2_ASSERT(
-		service->s_table.not_fopt[i]->ft_rpc_item_type.rit_opcode ==
-		service->s_table.not_start + i);
+		C2_ASSERT(service->s_table.not_fopt[i]->ft_code ==
+			  service->s_table.not_start + i);
 	}
 
 	dom = sid->si_domain;
diff --git a/net/net_utils.c b/net/net_utils.c
index d9967da..32d1a7c 100644
--- a/net/net_utils.c
+++ b/net/net_utils.c
@@ -14,8 +14,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Nathan Rutman <Nathan_Rutman@us.xyratex.com>,
- *                  Nikita Danilov <Nikita_Danilov@xyratex.com>
+ * Original author: Nathan Rutman, Nikita Danilov
  * Original creation date: 06/15/2010
  */
 
@@ -49,7 +48,7 @@ void c2_net_domain_stats_init(struct c2_net_domain *dom)
 
         C2_SET0(&dom->nd_stats);
 
-        now = c2_time_now();
+        c2_time_now(&now);
         for (i = 0; i < ARRAY_SIZE(dom->nd_stats); i++) {
                 c2_rwlock_init(&dom->nd_stats[i].ns_lock);
                 dom->nd_stats[i].ns_time = now;
@@ -114,7 +113,7 @@ int c2_net_domain_stats_get(struct c2_net_domain *dom,
         c2_time_t interval;
         int rv;
 
-        now = c2_time_now();
+        c2_time_now(&now);
 
         /* We lock here against other callers only -- stats are still being
            collected while we are here. We reset stats only after we calculate
diff --git a/net/net_xdr.c b/net/net_xdr.c
index f290fe2..f8dc29e 100644
--- a/net/net_xdr.c
+++ b/net/net_xdr.c
@@ -13,8 +13,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Alexey Lyashkov <Alexey_Lyashkov@xyratex.com>,
- *                  Nikita Danilov <Nikita_Danilov@xyratex.com>
+ * Original author: Alexey Lyashkov, Nikita Danilov
  * Original creation date: 04/11/2010
  */
 
diff --git a/net/st/Makefile.am b/net/st/Makefile.am
index cef82ae..e80394f 100644
--- a/net/st/Makefile.am
+++ b/net/st/Makefile.am
@@ -1,6 +1,9 @@
 INCLUDES             = -I. -I$(top_srcdir) -I$(top_srcdir)/include
 
-noinst_PROGRAMS      = kclient
+noinst_PROGRAMS      = connection kclient
+
+connection_SOURCES   = connection.c
+connection_LDADD     = $(top_builddir)/colibri/libcolibri.la
 
 kclient_SOURCES      = kclient.c
 kclient_LDADD        =
diff --git a/net/st/kclient.c b/net/st/kclient.c
index 9eb206f..5ffdb60 100644
--- a/net/st/kclient.c
+++ b/net/st/kclient.c
@@ -13,7 +13,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Huang Hua <hua_huang@xyratex.com>
+ * Original author: Hua Huang
  * Original creation date: 05/26/2010
  */
 
diff --git a/net/tm.c b/net/tm.c
index ffb9949..6b79972 100644
--- a/net/tm.c
+++ b/net/tm.c
@@ -14,8 +14,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Dave Cohrs <Dave_Cohrs@us.xyratex.com>,
- *                  Carl Braganza <Carl_Braganza@us.xyratex.com>
+ * Original author: Dave Cohrs, Carl Braganza
  * Original creation date: 04/07/2011
  */
 
@@ -29,12 +28,6 @@
    @addtogroup net Networking.
    @{
  */
-C2_TL_DESCR_DEFINE(tm, "tm list", ,
-		   struct c2_net_buffer, nb_tm_linkage, nb_magic,
-		   NET_BUFFER_LINK_MAGIC, NET_BUFFER_HEAD_MAGIC);
-C2_TL_DEFINE(tm, , struct c2_net_buffer);
-C2_EXPORTED(tm_tlist_is_empty);
-
 bool c2_net__tm_state_is_valid(enum c2_net_tm_state ts)
 {
 	return ts >= C2_NET_TM_UNDEFINED && ts <= C2_NET_TM_FAILED;
@@ -55,10 +48,6 @@ bool c2_net__tm_event_invariant(const struct c2_net_tm_event *ev)
 	if (ev->nte_type == C2_NET_TEV_STATE_CHANGE &&
 	    !c2_net__tm_state_is_valid(ev->nte_next_state))
 		return false;
-	if (ev->nte_type == C2_NET_TEV_STATE_CHANGE &&
-	    ev->nte_next_state == C2_NET_TM_STARTED &&
-	    !c2_net__ep_invariant(ev->nte_ep, ev->nte_tm, true))
-		return false;
 	return true;
 }
 
@@ -71,14 +60,15 @@ bool c2_net__tm_invariant(const struct c2_net_transfer_mc *tm)
 	if (tm->ntm_state < C2_NET_TM_INITIALIZED ||
 	    tm->ntm_state > C2_NET_TM_FAILED)
 		return false;
-	if (tm->ntm_state == C2_NET_TM_STARTED &&
+	if ((tm->ntm_state == C2_NET_TM_STARTING ||
+	     tm->ntm_state == C2_NET_TM_STARTED) &&
 	    tm->ntm_ep == NULL)
 		return false;
 	if (tm->ntm_state != C2_NET_TM_STARTED &&
 	    tm->ntm_state != C2_NET_TM_STOPPING) {
 		int i;
 		for (i = 0; i < ARRAY_SIZE(tm->ntm_q); ++i)
-			if (!tm_tlist_is_empty(&tm->ntm_q[i]))
+			if (!c2_list_is_empty(&tm->ntm_q[i]))
 				return false;
 	}
 	return true;
@@ -99,8 +89,6 @@ void c2_net_tm_event_post(const struct c2_net_tm_event *ev)
 
 	if (ev->nte_type == C2_NET_TEV_STATE_CHANGE) {
 		tm->ntm_state = ev->nte_next_state;
-		if (tm->ntm_state == C2_NET_TM_STARTED)
-			tm->ntm_ep = ev->nte_ep; /* ep now visible */
 	}
 
 	tm->ntm_callback_counter++;
@@ -119,6 +107,7 @@ void c2_net_tm_event_post(const struct c2_net_tm_event *ev)
 
 	return;
 }
+C2_EXPORTED(c2_net_tm_event_post);
 
 static void c2_net__tm_cleanup(struct c2_net_transfer_mc *tm)
 {
@@ -127,7 +116,7 @@ static void c2_net__tm_cleanup(struct c2_net_transfer_mc *tm)
 	tm->ntm_dom = NULL;
 	c2_chan_fini(&tm->ntm_chan);
 	for (i = 0; i < ARRAY_SIZE(tm->ntm_q); ++i) {
-		tm_tlist_fini(&tm->ntm_q[i]);
+		c2_list_fini(&tm->ntm_q[i]);
 	}
 	tm->ntm_xprt_private = NULL;
 	return;
@@ -148,14 +137,12 @@ int c2_net_tm_init(struct c2_net_transfer_mc *tm, struct c2_net_domain *dom)
 	tm->ntm_callback_counter = 0;
 	tm->ntm_dom = dom;
 	tm->ntm_ep = NULL;
-	c2_list_init(&tm->ntm_end_points);
 	c2_chan_init(&tm->ntm_chan);
 	for (i = 0; i < ARRAY_SIZE(tm->ntm_q); ++i) {
-		tm_tlist_init(&tm->ntm_q[i]);
+		c2_list_init(&tm->ntm_q[i]);
 	}
 	C2_SET_ARR0(tm->ntm_qstats);
 	tm->ntm_xprt_private = NULL;
-	tm->ntm_bev_auto_deliver = true;
 
 	result = dom->nd_xprt->nx_ops->xo_tm_init(tm);
 	if (result >= 0) {
@@ -174,45 +161,22 @@ void c2_net_tm_fini(struct c2_net_transfer_mc *tm)
 	struct c2_net_domain *dom = tm->ntm_dom;
 	int i;
 
-	/* wait for ongoing event processing to drain without holding lock:
-	   events modify state and end point refcounts */
-	if (tm->ntm_callback_counter > 0) {
-		struct c2_clink tmwait;
-		c2_clink_init(&tmwait, NULL);
-		c2_clink_add(&tm->ntm_chan, &tmwait);
-		while (tm->ntm_callback_counter > 0)
-			c2_chan_wait(&tmwait);
-		c2_clink_del(&tmwait);
-	}
-
 	c2_mutex_lock(&dom->nd_mutex);
 	C2_PRE(tm->ntm_state == C2_NET_TM_STOPPED ||
 	       tm->ntm_state == C2_NET_TM_FAILED ||
 	       tm->ntm_state == C2_NET_TM_INITIALIZED);
 
 	for (i = 0; i < ARRAY_SIZE(tm->ntm_q); ++i) {
-		C2_PRE(tm_tlist_is_empty(&tm->ntm_q[i]));
+		C2_PRE(c2_list_is_empty(&tm->ntm_q[i]));
 	}
-	C2_PRE((c2_list_is_empty(&tm->ntm_end_points) && tm->ntm_ep == NULL) ||
-	       (c2_list_length(&tm->ntm_end_points) == 1 &&
-		tm->ntm_ep != NULL &&
-		c2_list_contains(&tm->ntm_end_points,
-				 &tm->ntm_ep->nep_tm_linkage) &&
-		c2_atomic64_get(&tm->ntm_ep->nep_ref.ref_cnt) == 1));
-
-	/* release method requires TM mutex to be locked */
-	c2_mutex_lock(&tm->ntm_mutex);
+	C2_PRE(tm->ntm_callback_counter == 0);
+
+	dom->nd_xprt->nx_ops->xo_tm_fini(tm);
+
 	if (tm->ntm_ep != NULL) {
 		c2_ref_put(&tm->ntm_ep->nep_ref);
 		tm->ntm_ep = NULL;
 	}
-	c2_mutex_unlock(&tm->ntm_mutex);
-
-	dom->nd_xprt->nx_ops->xo_tm_fini(tm);
-
-	C2_ASSERT(c2_list_is_empty(&tm->ntm_end_points));
-	c2_list_fini(&tm->ntm_end_points);
-
 	c2_list_del(&tm->ntm_dom_linkage);
 	tm->ntm_state = C2_NET_TM_UNDEFINED;
 	c2_net__tm_cleanup(tm);
@@ -223,22 +187,26 @@ void c2_net_tm_fini(struct c2_net_transfer_mc *tm)
 }
 C2_EXPORTED(c2_net_tm_fini);
 
-int c2_net_tm_start(struct c2_net_transfer_mc *tm, const char *addr)
+int c2_net_tm_start(struct c2_net_transfer_mc *tm,
+		    struct c2_net_end_point *ep)
 {
 	int result;
 
-	C2_ASSERT(addr != NULL);
+	C2_ASSERT(ep != NULL);
 	C2_PRE(tm != NULL);
 	c2_mutex_lock(&tm->ntm_mutex);
 	C2_PRE(c2_net__tm_invariant(tm));
 	C2_PRE(tm->ntm_state == C2_NET_TM_INITIALIZED);
 
+	c2_net_end_point_get(ep);
+	tm->ntm_ep = ep;
 	tm->ntm_state = C2_NET_TM_STARTING;
-	result = tm->ntm_dom->nd_xprt->nx_ops->xo_tm_start(tm, addr);
+	result = tm->ntm_dom->nd_xprt->nx_ops->xo_tm_start(tm);
 	if (result < 0) {
 		/* xprt did not start, no retry supported */
 		tm->ntm_state = C2_NET_TM_FAILED;
-		C2_ASSERT(tm->ntm_ep == NULL);
+		tm->ntm_ep = NULL;
+		c2_ref_put(&ep->nep_ref);
 	}
 	C2_POST(c2_net__tm_invariant(tm));
 	c2_mutex_unlock(&tm->ntm_mutex);
@@ -297,82 +265,6 @@ int c2_net_tm_stats_get(struct c2_net_transfer_mc *tm,
 }
 C2_EXPORTED(c2_net_tm_stats_get);
 
-int c2_net_tm_confine(struct c2_net_transfer_mc *tm,
-		      const struct c2_bitmap *processors)
-{
-	int result;
-	c2_mutex_lock(&tm->ntm_mutex);
-	C2_PRE(c2_net__tm_invariant(tm));
-	C2_PRE(tm->ntm_state == C2_NET_TM_INITIALIZED);
-	C2_PRE(processors != NULL);
-	if (tm->ntm_dom->nd_xprt->nx_ops->xo_tm_confine != NULL) {
-		result = tm->ntm_dom->nd_xprt->nx_ops->xo_tm_confine(tm,
-								     processors);
-	} else
-		result = -ENOSYS;
-	C2_POST(c2_net__tm_invariant(tm));
-	C2_POST(tm->ntm_state == C2_NET_TM_INITIALIZED);
-	c2_mutex_unlock(&tm->ntm_mutex);
-	return result;
-}
-
-int c2_net_buffer_event_deliver_synchronously(struct c2_net_transfer_mc *tm)
-{
-	int result;
-	c2_mutex_lock(&tm->ntm_mutex);
-	C2_PRE(c2_net__tm_invariant(tm));
-	C2_PRE(tm->ntm_state == C2_NET_TM_INITIALIZED);
-	C2_PRE(tm->ntm_bev_auto_deliver);
-	if (tm->ntm_dom->nd_xprt->nx_ops->xo_bev_deliver_sync != NULL) {
-		result = tm->ntm_dom->nd_xprt->nx_ops->xo_bev_deliver_sync(tm);
-		if (result == 0)
-			tm->ntm_bev_auto_deliver = false;
-	} else
-		result = -ENOSYS;
-	C2_POST(ergo(result == 0, !tm->ntm_bev_auto_deliver));
-	C2_POST(c2_net__tm_invariant(tm));
-	c2_mutex_unlock(&tm->ntm_mutex);
-	return result;
-}
-
-void c2_net_buffer_event_deliver_all(struct c2_net_transfer_mc *tm)
-{
-	c2_mutex_lock(&tm->ntm_mutex);
-	C2_PRE(c2_net__tm_invariant(tm));
-	C2_PRE(tm->ntm_state == C2_NET_TM_STARTED);
-	C2_PRE(!tm->ntm_bev_auto_deliver);
-	tm->ntm_dom->nd_xprt->nx_ops->xo_bev_deliver_all(tm);
-	C2_POST(c2_net__tm_invariant(tm));
-	c2_mutex_unlock(&tm->ntm_mutex);
-	return;
-}
-
-bool c2_net_buffer_event_pending(struct c2_net_transfer_mc *tm)
-{
-	bool result;
-	c2_mutex_lock(&tm->ntm_mutex);
-	C2_PRE(c2_net__tm_invariant(tm));
-	C2_PRE(tm->ntm_state == C2_NET_TM_STARTED);
-	C2_PRE(!tm->ntm_bev_auto_deliver);
-	result = tm->ntm_dom->nd_xprt->nx_ops->xo_bev_pending(tm);
-	C2_POST(c2_net__tm_invariant(tm));
-	c2_mutex_unlock(&tm->ntm_mutex);
-	return result;
-}
-
-void c2_net_buffer_event_notify(struct c2_net_transfer_mc *tm,
-				struct c2_chan *chan)
-{
-	c2_mutex_lock(&tm->ntm_mutex);
-	C2_PRE(c2_net__tm_invariant(tm));
-	C2_PRE(tm->ntm_state == C2_NET_TM_STARTED);
-	C2_PRE(!tm->ntm_bev_auto_deliver);
-	tm->ntm_dom->nd_xprt->nx_ops->xo_bev_notify(tm, chan);
-	C2_POST(c2_net__tm_invariant(tm));
-	c2_mutex_unlock(&tm->ntm_mutex);
-	return;
-}
-
 /** @} end of net group */
 
 /*
diff --git a/net/usunrpc/Makefile.am b/net/usunrpc/Makefile.am
index 6459044..afb2d66 100644
--- a/net/usunrpc/Makefile.am
+++ b/net/usunrpc/Makefile.am
@@ -1,4 +1,4 @@
-usunrpcdir                         = $(includedir)/colibri/net/usunrpc
+usunrpcdir                         = $(includedir)/net/usunrpc
 usunrpc_HEADERS                    = usunrpc.h usunrpc_internal.h
 
 noinst_LTLIBRARIES                 = libcolibri-net-usunrpc.la
diff --git a/net/usunrpc/client.c b/net/usunrpc/client.c
index a004b90..40dceaf 100644
--- a/net/usunrpc/client.c
+++ b/net/usunrpc/client.c
@@ -14,7 +14,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Nikita Danilov <Nikita_Danilov@xyratex.com>
+ * Original author: Nikita Danilov
  * Original creation date: 06/15/2010
  */
 
@@ -44,7 +44,7 @@
 #include "lib/queue.h"
 #include "lib/thread.h"
 #include "lib/cond.h"
-#include "net/net_internal.h"
+#include "net/net.h"
 #include "fop/fop.h"
 
 #include "usunrpc.h"
@@ -59,6 +59,18 @@
  * Client code.
  */
 
+/**
+   XXX make version for all sun rpc calls to be const
+ */
+static const int C2_DEF_RPC_VER = 1;
+
+/**
+   services unique identifier
+ */
+enum c2_rpc_service_id {
+	C2_SESSION_PROGRAM = 0x20000001
+};
+
 struct usunrpc_xprt {
 	CLIENT              *nsx_client;
 	int                  nsx_fd;
@@ -99,10 +111,6 @@ C2_ADDB_ADD(&(conn)->nc_addb, &usunrpc_addb_client, ev , ## __VA_ARGS__)
 C2_ADDB_ADD(&(conn)->nc_addb, &usunrpc_addb_client,                     \
             c2_addb_func_fail, (name), (rc))
 
-enum {
-	MINIMAL_XPRT_MAX_BUFFER_SIZE = (1<<19) + 1024,
-};
-
 static void usunrpc_conn_fini_internal(struct usunrpc_conn *xconn)
 {
 	size_t i;
@@ -153,25 +161,16 @@ static int usunrpc_conn_init_one(struct usunrpc_service_id *id,
 	}
 
 	sock = -1;
-	if (conn->nc_domain->nd_xprt == &c2_net_usunrpc_minimal_xprt)
-		/* Kernel does not support message fragmentation.
-		   Use max message sizes of sunrpc bulk emulation.
-		 */
-		xprt->nsx_client = clnttcp_create(&addr, id->ssi_prog,
-						  id->ssi_ver, &sock,
-						  MINIMAL_XPRT_MAX_BUFFER_SIZE,
-						  MINIMAL_XPRT_MAX_BUFFER_SIZE);
-	else
-		xprt->nsx_client = clnttcp_create(&addr, id->ssi_prog,
-						  id->ssi_ver, &sock, 0, 0);
+	xprt->nsx_client = clnttcp_create(&addr, id->ssi_prog,
+					  id->ssi_ver, &sock, 0, 0);
 	if (xprt->nsx_client != NULL) {
 		xprt->nsx_fd = sock;
+		c2_queue_put(&xconn->nsc_idle, &xprt->nsx_linkage);
 		result = 0;
 	} else {
 		clnt_pcreateerror(id->ssi_host);
 		ADDB_CALL(conn, "clnttcp_create", -errno);
 		result = -errno;
-		xprt->nsx_fd = 0;
 	}
 	return result;
 }
@@ -210,8 +209,6 @@ static int usunrpc_conn_init(struct c2_service_id *id, struct c2_net_conn *conn)
 					 &xconn->nsc_pool[i]);
 				if (result != 0)
 					break;
-				c2_queue_put(&xconn->nsc_idle,
-					     &xconn->nsc_pool[i].nsx_linkage);
 			}
 		}
 	} else
@@ -257,30 +254,12 @@ static int usunrpc_call(struct usunrpc_xprt *xprt, struct c2_net_call *call)
 {
 	struct c2_fop *arg;
 	struct c2_fop *ret;
-	int rc;
 
 	arg = call->ac_arg;
 	ret = call->ac_ret;
-	if (xprt->nsx_fd == 0) {
-		/* This could be due to a previous failure during reset in
-		   usunrpc_conn_call below.
-		 */
-		return -ECONNABORTED;
-	}
-	rc = -clnt_call(xprt->nsx_client,
-			arg->f_type->ft_rpc_item_type.rit_opcode,
-			(xdrproc_t)&c2_fop_uxdrproc, (caddr_t)arg,
-			(xdrproc_t)&c2_fop_uxdrproc, (caddr_t)ret, TIMEOUT);
-	if (rc != 0) {
-		struct rpc_err re;
-		clnt_geterr(xprt->nsx_client, &re);
-		if (re.re_status == RPC_CANTSEND ||
-		    re.re_status == RPC_CANTRECV) {
-			/* clnt_call returns EINTR - recover the real error */
-			rc = -re.re_errno;
-		}
-	}
-	return rc;
+	return -clnt_call(xprt->nsx_client, arg->f_type->ft_code,
+			  (xdrproc_t)&c2_fop_uxdrproc, (caddr_t)arg,
+			  (xdrproc_t)&c2_fop_uxdrproc, (caddr_t)ret, TIMEOUT);
 }
 
 static int usunrpc_conn_call(struct c2_net_conn *conn, struct c2_net_call *call)
@@ -294,21 +273,6 @@ static int usunrpc_conn_call(struct c2_net_conn *conn, struct c2_net_call *call)
 	xconn  = conn->nc_xprt_private;
 	xprt   = conn_xprt_get(xconn);
 	result = usunrpc_call(xprt, call);
-	if ((result == -ECONNRESET || result == -EPIPE) &&
-	    conn->nc_domain->nd_xprt == &c2_net_usunrpc_minimal_xprt) {
-		/* Potentially an error due to caching of end points.
-		   Reinitialize the xprt and retry once.
-		*/
-		int rc;
-		C2_ASSERT(xprt->nsx_fd != 0);
-		clnt_destroy(xprt->nsx_client);
-		rc = usunrpc_conn_init_one(conn->nc_id->si_xport_private,
-					   conn, xconn, xprt);
-		if (rc == 0)
-			result = usunrpc_call(xprt, call);
-		else
-			C2_ASSERT(xprt->nsx_fd == 0);
-	}
 	conn_xprt_put(xconn, xprt);
 	return result;
 }
diff --git a/net/usunrpc/domain.c b/net/usunrpc/domain.c
index 0c5f697..bea6594 100644
--- a/net/usunrpc/domain.c
+++ b/net/usunrpc/domain.c
@@ -14,7 +14,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Nikita Danilov <Nikita_Danilov@xyratex.com>
+ * Original author: Nikita Danilov
  * Original creation date: 06/15/2010
  */
 
@@ -86,8 +86,12 @@ static void usunrpc_dom_fini(struct c2_net_domain *dom)
 		c2_cond_broadcast(&xdom->sd_gotwork, &xdom->sd_guard);
 		c2_mutex_unlock(&xdom->sd_guard);
 		for (i = 0; i < xdom->sd_nr_workers; ++i) {
-			if (xdom->sd_workers[i].t_func != NULL)
-				c2_thread_join(&xdom->sd_workers[i]);
+			if (xdom->sd_workers[i].t_func != NULL) {
+				int rc;
+
+				rc = c2_thread_join(&xdom->sd_workers[i]);
+				/* XXX handle error... */
+			}
 		}
 		c2_mutex_fini(&xdom->sd_guard);
 		c2_queue_fini(&xdom->sd_queue);
diff --git a/net/usunrpc/server.c b/net/usunrpc/server.c
index e98e613..2849639 100644
--- a/net/usunrpc/server.c
+++ b/net/usunrpc/server.c
@@ -14,7 +14,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Nikita Danilov <Nikita_Danilov@xyratex.com>
+ * Original author: Nikita Danilov
  * Original creation date: 06/15/2010
  */
 #ifdef HAVE_CONFIG_H
@@ -240,7 +240,6 @@ static void usunrpc_service_worker(struct c2_service *service)
 	struct work_item        *wi;
 	struct c2_queue_link    *ql;
 	struct c2_fop           *ret;
-	c2_time_t                rdelay;
         bool                     sleeping = false;
 
 	xs = service->s_xport_private;
@@ -263,15 +262,6 @@ static void usunrpc_service_worker(struct c2_service *service)
 		ret = NULL;
 		service->s_handler(service, wi->wi_arg, &ret);
 
-		/*
-		 * Currently reqh uses sunrpc, which expects a synchronous
-		 * reply, so this loop is to support async reply by reqh.
-		 */
-		if (service->s_domain->nd_xprt != &c2_net_usunrpc_minimal_xprt)
-			while (ret == NULL)
-				c2_nanosleep(c2_time_set(&rdelay, 0, 1000000),
-					     NULL);
-
 		c2_rwlock_read_lock(&xs->s_guard);
 		if (ret != NULL && !svc_sendreply(wi->wi_transp,
 					     (xdrproc_t)c2_fop_uxdrproc,
@@ -389,11 +379,13 @@ static void usunrpc_dispatch(struct svc_req *req, SVCXPRT *transp)
 static int usunrpc_scheduler_init(struct c2_service *service)
 {
 	struct usunrpc_service    *xservice;
+	struct usunrpc_service_id *xid;
 	SVCXPRT                   *transp;
 	int                        result;
 
 	usunrpc_service_set(service);
 	xservice = service->s_xport_private;
+	xid = service->s_id->si_xport_private;
 
 	C2_ASSERT(xservice->s_socket >= 0);
 
@@ -422,14 +414,15 @@ static int usunrpc_scheduler_init(struct c2_service *service)
 static void usunrpc_scheduler(struct c2_service *service)
 {
 	struct usunrpc_service *xservice;
-	static fd_set           listen_local;
-	int                     ret;
-	struct timeval          tv;
 
 	usunrpc_service_set(service);
 	xservice = service->s_xport_private;
 
 	while (1) {
+		static fd_set  listen_local;
+		int            ret;
+		struct timeval tv;
+
 		tv.tv_sec  = 1;
 		tv.tv_usec = 0;
 
@@ -449,32 +442,8 @@ static void usunrpc_scheduler(struct c2_service *service)
 	}
 
 	if (xservice->s_transp != NULL) {
-		bool shut_any = false;
-		int i;
-
 		svc_destroy(xservice->s_transp);
 		xservice->s_transp = NULL;
-
-		/* Ensure all transports created internally to svc_tcp for
-		   accepted connections are also destroyed.  svc_destroy() on
-		   primary transport does not do this, unfortunately.  The
-		   shutdown() on the remaining sockets causes the transports to
-		   be cleaned up when svc_getreqset() is called.  svc_exit()
-		   cleans up remaining interal sunrpc svc resources.
-		 */
-		listen_local = svc_fdset;
-		for (i = 0; i < FD_SETSIZE; ++i) {
-			if (FD_ISSET(i, &listen_local)) {
-				ret = shutdown(i, SHUT_RD);
-				if (ret == 0)
-					shut_any = true;
-			}
-		}
-		c2_rwlock_write_lock(&xservice->s_guard);
-		if (shut_any)
-			svc_getreqset(&listen_local);
-		c2_rwlock_write_unlock(&xservice->s_guard);
-		svc_exit();
 	}
 }
 
@@ -565,8 +534,7 @@ static int usunrpc_service_start(struct c2_service *service,
 	}
 
         C2_SET0(&addr);
-	addr.sin_family = AF_INET;
-        addr.sin_port   = htons(xid->ssi_port);
+        addr.sin_port = htons(xid->ssi_port);
         if (bind(xservice->s_socket,
 		 (struct sockaddr *)&addr, sizeof addr) == -1) {
 		ADDB_CALL(service, "bind", errno);
diff --git a/net/usunrpc/usunrpc.h b/net/usunrpc/usunrpc.h
index ec376d2..3495313 100644
--- a/net/usunrpc/usunrpc.h
+++ b/net/usunrpc/usunrpc.h
@@ -14,7 +14,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Nikita Danilov <Nikita_Danilov@xyratex.com>
+ * Original author: Nikita Danilov
  * Original creation date: 06/15/2010
  */
 
diff --git a/net/usunrpc/usunrpc_internal.h b/net/usunrpc/usunrpc_internal.h
index b7ebe83..23ee0a9 100644
--- a/net/usunrpc/usunrpc_internal.h
+++ b/net/usunrpc/usunrpc_internal.h
@@ -14,7 +14,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Nikita Danilov <Nikita_Danilov@xyratex.com>
+ * Original author: Nikita Danilov
  * Original creation date: 06/15/2010
  */
 
@@ -109,7 +109,6 @@ int  usunrpc_service_init(struct c2_service *service);
 extern const struct c2_service_id_ops usunrpc_service_id_ops;
 extern const struct c2_net_conn_ops usunrpc_conn_ops;
 extern const struct c2_service_ops usunrpc_service_ops;
-extern struct c2_net_xprt c2_net_usunrpc_minimal_xprt;
 
 /** @} end of group usunrpc */
 
diff --git a/net/usunrpc/uxdr.c b/net/usunrpc/uxdr.c
index 34351b4..1e84037 100644
--- a/net/usunrpc/uxdr.c
+++ b/net/usunrpc/uxdr.c
@@ -14,7 +14,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Nikita Danilov <Nikita_Danilov@xyratex.com>
+ * Original author: Nikita Danilov
  * Original creation date: 06/29/2010
  */
 
diff --git a/net/ut/.gitignore b/net/ut/.gitignore
index f387665..6b89cac 100644
--- a/net/ut/.gitignore
+++ b/net/ut/.gitignore
@@ -3,5 +3,7 @@ client
 kclient
 rclient
 rserver
+net_k.c
+net_k.h
 net_u.c
 net_u.h
diff --git a/net/ut/Makefile.am b/net/ut/Makefile.am
index b27e110..e2e11d1 100644
--- a/net/ut/Makefile.am
+++ b/net/ut/Makefile.am
@@ -1,18 +1,19 @@
+UT_SRCDIR               = @SRCDIR@/net/ut
+
 noinst_LTLIBRARIES   	= libnet-ut.la
-INCLUDES        	= -I. -I$(top_srcdir) -I$(top_srcdir)/include -I$(top_srcdir)/net
+INCLUDES        	= -I. -I$(top_srcdir) -I$(top_srcdir)/include -I../
 
 net_u.h net_u.c: net.ff \
-                  $(top_builddir)/fop/rt/libc2rt.la \
-                  $(top_builddir)/fop/fop2c
-	$(top_builddir)/fop/fop2c -u $<
+                  $(top_builddir)/fop/libc2rt.la \
+                  $(top_builddir)/fop/fop2c 
+	$(top_builddir)/fop/fop2c -uk $<
 
 libnet_ut_la_SOURCES	= bulk_if.c \
-                          net_u.h net_u.c net_fop_init.c net_fop.h \
-                          buffer_pool_ut.c
-libnet_ut_la_LIBADD     = $(top_builddir)/colibri/libcolibri.la
+                          net_u.h net_u.c client.c net_fop_init.c net_fop.h
+libnet_ut_la_LIBADD 	= $(top_builddir)/colibri/libcolibri.la
 
 EXTRA_DIST              = net.ff
 
 clean-local:
-	cd @SRCDIR@/net/ut ; \
+	cd $(UT_SRCDIR) ; \
 	rm -fr net_[uk].[hc]
diff --git a/net/ut/buffer_pool_ut.c b/net/ut/buffer_pool_ut.c
deleted file mode 100644
index 822436e..0000000
--- a/net/ut/buffer_pool_ut.c
+++ /dev/null
@@ -1,224 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Madhavrao Vemuri <madhav_vemuri@xyratex.com>
- * Original creation date: 10/12/2011
- */
-
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif
-#include "lib/ut.h"
-#include "lib/memory.h"/* C2_ALLOC_PTR */
-#include "lib/misc.h"  /* C2_SET0 */
-#include "lib/thread.h"/* C2_THREAD_INIT */
-#include "lib/time.h"  /* c2_nanosleep */
-#include "net/bulk_sunrpc.h"
-#include "net/buffer_pool.h"
-
-static void notempty(struct c2_net_buffer_pool *bp);
-static void low(struct c2_net_buffer_pool *bp);
-static void buffers_get_put(int rc);
-
-struct c2_net_buffer_pool  bp;
-static struct c2_chan	   buf_chan;
-static struct c2_net_xprt *xprt = &c2_net_bulk_sunrpc_xprt;
-
-const struct c2_net_buffer_pool_ops b_ops = {
-	.nbpo_not_empty	      = notempty,
-	.nbpo_below_threshold = low,
-};
-
-/**
-   Initialization of buffer pool.
- */
-static void test_init(void)
-{
-	int rc;
-	c2_chan_init(&buf_chan);
-	c2_net_xprt_init(xprt);
-	C2_ALLOC_PTR(bp.nbp_ndom);
-	C2_UT_ASSERT(bp.nbp_ndom != NULL);
-	rc = c2_net_domain_init(bp.nbp_ndom, xprt);
-	C2_ASSERT(rc == 0);
-	bp.nbp_ops = &b_ops;
-	c2_net_buffer_pool_init(&bp, bp.nbp_ndom, 2, 64, 4096, 10);
-	c2_net_buffer_pool_lock(&bp);
-	rc = c2_net_buffer_pool_provision(&bp, 10);
-	c2_net_buffer_pool_unlock(&bp);
-	C2_UT_ASSERT(rc == 10);
-}
-
-static void test_get_put(void)
-{
-	struct c2_net_buffer *nb;
-	uint32_t	      free = bp.nbp_free;
-	c2_net_buffer_pool_lock(&bp);
-	nb = c2_net_buffer_pool_get(&bp, ~0);
-	C2_UT_ASSERT(nb != NULL);
-	C2_UT_ASSERT(--free == bp.nbp_free);
-	C2_UT_ASSERT(c2_net_buffer_pool_invariant(&bp));
-	c2_net_buffer_pool_put(&bp, nb, ~0);
-	C2_UT_ASSERT(++free == bp.nbp_free);
-	C2_UT_ASSERT(c2_net_buffer_pool_invariant(&bp));
-	c2_net_buffer_pool_unlock(&bp);
-}
-
-static void test_get_put_colour(void)
-{
-	struct c2_net_buffer *nb;
-	uint32_t	      free = bp.nbp_free;
-	c2_net_buffer_pool_lock(&bp);
-	nb = c2_net_buffer_pool_get(&bp, ~0);
-	C2_UT_ASSERT(nb != NULL);
-	C2_UT_ASSERT(--free == bp.nbp_free);
-	c2_net_buffer_pool_put(&bp, nb, 1);
-	C2_UT_ASSERT(++free == bp.nbp_free);
-	C2_UT_ASSERT(c2_net_buffer_pool_invariant(&bp));
-	nb = c2_net_buffer_pool_get(&bp, 1);
-	C2_UT_ASSERT(nb != NULL);
-	C2_UT_ASSERT(--free == bp.nbp_free);
-	C2_UT_ASSERT(c2_net_buffer_pool_invariant(&bp));
-	c2_net_buffer_pool_put(&bp, nb, ~0);
-	C2_UT_ASSERT(++free == bp.nbp_free);
-	c2_net_buffer_pool_unlock(&bp);
-}
-
-static void test_grow(void)
-{
-	uint32_t buf_nr = bp.nbp_buf_nr;
-	c2_net_buffer_pool_lock(&bp);
-	/* Buffer pool grow by one */
-	C2_UT_ASSERT(c2_net_buffer_pool_provision(&bp, 1) == 1);
-	C2_UT_ASSERT(++buf_nr == bp.nbp_buf_nr);
-	C2_UT_ASSERT(c2_net_buffer_pool_invariant(&bp));
-	c2_net_buffer_pool_unlock(&bp);
-}
-
-static void test_prune(void)
-{
-	uint32_t buf_nr = bp.nbp_buf_nr;
-	c2_net_buffer_pool_lock(&bp);
-	C2_UT_ASSERT(c2_net_buffer_pool_prune(&bp));
-	C2_UT_ASSERT(--buf_nr == bp.nbp_buf_nr);
-	C2_UT_ASSERT(c2_net_buffer_pool_invariant(&bp));
-	c2_net_buffer_pool_unlock(&bp);
-}
-
-static void test_get_put_multiple(void)
-{
-	int		  i;
-	int		  rc;
-	const int	  nr_client_threads = 10;
-	struct c2_thread *client_thread;
-
-	C2_ALLOC_ARR(client_thread, nr_client_threads);
-	C2_UT_ASSERT(client_thread != NULL);
-	for (i = 0; i < nr_client_threads; i++) {
-		C2_SET0(&client_thread[i]);
-		rc = C2_THREAD_INIT(&client_thread[i], int,
-				     NULL, &buffers_get_put,
-					~0, "client_%d", i);
-		C2_ASSERT(rc == 0);
-		C2_SET0(&client_thread[++i]);
-		/* value of integer 'i' is used to put ot get the
-		   buffer in coloured list */
-		rc = C2_THREAD_INIT(&client_thread[i], int,
-				     NULL, &buffers_get_put,
-					i, "client_%d", i);
-		C2_ASSERT(rc == 0);
-	}
-	for (i = 0; i < nr_client_threads; i++) {
-		c2_thread_join(&client_thread[i]);
-	}
-	c2_free(client_thread);
-	c2_net_buffer_pool_lock(&bp);
-	C2_UT_ASSERT(c2_net_buffer_pool_invariant(&bp));
-	c2_net_buffer_pool_unlock(&bp);
-}
-
-static void test_fini(void)
-{
-	c2_net_buffer_pool_lock(&bp);
-	C2_UT_ASSERT(c2_net_buffer_pool_invariant(&bp));
-	c2_net_buffer_pool_fini(&bp);
-	c2_net_domain_fini(bp.nbp_ndom);
-	c2_free(bp.nbp_ndom);
-	c2_net_xprt_fini(xprt);
-	c2_chan_fini(&buf_chan);
-
-}
-
-static void buffers_get_put(int rc)
-{
-	struct c2_net_buffer *nb;
-	struct c2_clink buf_link;
-	c2_time_t t;
-	c2_clink_init(&buf_link, NULL);
-	c2_clink_add(&buf_chan, &buf_link);
-	do {
-		c2_net_buffer_pool_lock(&bp);
-		nb = c2_net_buffer_pool_get(&bp, rc);
-		c2_net_buffer_pool_unlock(&bp);
-		if (nb == NULL)
-			c2_chan_wait(&buf_link);
-	} while (nb == NULL);
-	c2_nanosleep(c2_time_set(&t, 0, 100), NULL);
-	c2_net_buffer_pool_lock(&bp);
-	if (nb != NULL)
-		c2_net_buffer_pool_put(&bp, nb, rc);
-	c2_net_buffer_pool_unlock(&bp);
-	c2_clink_del(&buf_link);
-	c2_clink_fini(&buf_link);
-}
-
-static void notempty(struct c2_net_buffer_pool *bp)
-{
-	c2_chan_signal(&buf_chan);
-}
-
-static void low(struct c2_net_buffer_pool *bp)
-{
-	/* Buffer pool is LOW */
-}
-
-const struct c2_test_suite buffer_pool_ut = {
-	.ts_name = "buffer_pool_ut",
-	.ts_init = NULL,
-	.ts_fini = NULL,
-	.ts_tests = {
-		{ "buffer_pool_init",              test_init },
-		{ "buffer_pool_get_put",           test_get_put },
-		{ "buffer_pool_get_put_colour",    test_get_put_colour },
-		{ "buffer_pool_grow",              test_grow },
-		{ "buffer_pool_prune",             test_prune },
-		{ "buffer_pool_get_put_multiple",  test_get_put_multiple },
-		{ "buffer_pool_fini",              test_fini },
-		{ NULL,                            NULL }
-	}
-};
-C2_EXPORTED(buffer_pool_ut);
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
-
diff --git a/net/ut/bulk_if.c b/net/ut/bulk_if.c
index 67b9517..bac9e21 100644
--- a/net/ut/bulk_if.c
+++ b/net/ut/bulk_if.c
@@ -14,8 +14,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Carl Braganza <Carl_Braganza@us.xyratex.com>,
- *                  Dave Cohrs <Dave_Cohrs@us.xyratex.com>
+ * Original author: Carl Braganza, Dave Cohrs
  * Original creation date: 04/06/2010
  */
 
@@ -33,21 +32,7 @@
 static struct c2_net_domain utdom;
 static struct c2_net_transfer_mc ut_tm;
 
-static void make_desc(struct c2_net_buf_desc *desc);
-
-#if 0
-#define KPRN(fmt,...) printk(KERN_ERR fmt, ## __VA_ARGS__)
-#define PRId64 "lld" /* from <inttypes.h> */
-#else
-#define KPRN(fmt,...)
-#endif
-
-#define DELAY_MS(ms)				\
-{       c2_time_t rem;				\
-	c2_time_t del;				\
-        c2_time_set(&del, 0, ms * 1000000ULL);	\
-        c2_nanosleep(del, &rem);		\
-}
+void make_desc(struct c2_net_buf_desc *desc);
 
 /*
  *****************************************************
@@ -69,7 +54,7 @@ static int ut_dom_init(struct c2_net_xprt *xprt,
 	return 0;
 }
 
-static bool ut_dom_fini_called = false;
+static bool ut_dom_fini_called=false;
 static void ut_dom_fini(struct c2_net_domain *dom)
 {
 	C2_ASSERT(c2_mutex_is_locked(&c2_net_mutex));
@@ -79,9 +64,9 @@ static void ut_dom_fini(struct c2_net_domain *dom)
 
 /* params */
 enum {
-	UT_MAX_BUF_SIZE = 4096,
-	UT_MAX_BUF_SEGMENT_SIZE = 2048,
-	UT_MAX_BUF_SEGMENTS = 4,
+	UT_MAX_BUF_SIZE=4096,
+	UT_MAX_BUF_SEGMENT_SIZE=2048,
+	UT_MAX_BUF_SEGMENTS=4,
 };
 static bool ut_get_max_buffer_size_called = false;
 static c2_bcount_t ut_get_max_buffer_size(const struct c2_net_domain *dom)
@@ -113,27 +98,27 @@ static void ut_end_point_release(struct c2_ref *ref)
 {
 	struct c2_net_end_point *ep;
 	struct ut_ep *utep;
-	struct c2_net_transfer_mc *tm;
+	struct c2_net_domain *dom;
 	ut_end_point_release_called = true;
 	ep = container_of(ref, struct c2_net_end_point, nep_ref);
 	ut_last_ep_released = ep;
-	tm = ep->nep_tm;
-	C2_ASSERT(c2_mutex_is_locked(&tm->ntm_mutex));
-	c2_list_del(&ep->nep_tm_linkage);
-	ep->nep_tm = NULL;
+	dom = ep->nep_dom;
+	C2_ASSERT(c2_mutex_is_locked(&dom->nd_mutex));
+	c2_list_del(&ep->nep_dom_linkage);
+	ep->nep_dom = NULL;
 	utep = container_of(ep, struct ut_ep, uep);
 	c2_free(utep);
 }
 static bool ut_end_point_create_called = false;
 static int ut_end_point_create(struct c2_net_end_point **epp,
-			       struct c2_net_transfer_mc *tm,
+			       struct c2_net_domain *dom,
 			       const char *addr)
 {
 	char *ap;
 	struct ut_ep *utep;
 	struct c2_net_end_point *ep;
 
-	C2_ASSERT(c2_mutex_is_locked(&tm->ntm_mutex));
+	C2_ASSERT(c2_mutex_is_locked(&dom->nd_mutex));
 	ut_end_point_create_called = true;
 	if (addr == NULL) {
 		/* don't support dynamic */
@@ -141,9 +126,9 @@ static int ut_end_point_create(struct c2_net_end_point **epp,
 	}
 	ap = (char *)addr;  /* avoid strdup; this is a ut! */
 	/* check if its already on the domain list */
-	c2_list_for_each_entry(&tm->ntm_end_points, ep,
+	c2_list_for_each_entry(&dom->nd_end_points, ep,
 			       struct c2_net_end_point,
-			       nep_tm_linkage) {
+			       nep_dom_linkage) {
 		utep = container_of(ep, struct ut_ep, uep);
 		if (strcmp(utep->addr, ap) == 0) {
 			c2_ref_get(&ep->nep_ref); /* refcnt++ */
@@ -156,8 +141,9 @@ static int ut_end_point_create(struct c2_net_end_point **epp,
 	utep->addr = ap;
 	utep->uep.nep_addr = ap;
 	c2_ref_init(&utep->uep.nep_ref, 1, ut_end_point_release);
-	utep->uep.nep_tm = tm;
-	c2_list_add_tail(&tm->ntm_end_points, &utep->uep.nep_tm_linkage);
+	utep->uep.nep_dom = dom;
+	c2_list_link_init(&utep->uep.nep_dom_linkage);
+	c2_list_add_tail(&dom->nd_end_points, &utep->uep.nep_dom_linkage);
 	*epp = &utep->uep;
 	return 0;
 }
@@ -171,11 +157,11 @@ static int ut_buf_register(struct c2_net_buffer *nb)
 }
 
 static bool ut_buf_deregister_called = false;
-static void ut_buf_deregister(struct c2_net_buffer *nb)
+static int ut_buf_deregister(struct c2_net_buffer *nb)
 {
 	C2_ASSERT(c2_mutex_is_locked(&nb->nb_dom->nd_mutex));
 	ut_buf_deregister_called = true;
-	return;
+	return 0;
 }
 
 static bool ut_buf_add_called = false;
@@ -205,8 +191,7 @@ static void ut_post_del_thread(struct c2_net_buffer *nb)
 	};
 	if (nb->nb_flags & C2_NET_BUF_CANCELLED)
 		ev.nbe_status = -ECANCELED; /* required behavior */
-	DELAY_MS(1);
-	ev.nbe_time = c2_time_now();
+	c2_time_now(&ev.nbe_time);
 
 	/* post requested event */
 	c2_net_buffer_event_post(&ev);
@@ -254,21 +239,6 @@ static void ut_tm_fini(struct c2_net_transfer_mc *tm)
 }
 
 struct c2_thread ut_tm_thread;
-static void ut_post_tm_started_ev_thread(struct c2_net_end_point *ep)
-{
-	struct c2_net_tm_event ev = {
-		.nte_type = C2_NET_TEV_STATE_CHANGE,
-		.nte_tm = &ut_tm,
-		.nte_ep = ep,
-		.nte_status = 0,
-		.nte_next_state = C2_NET_TM_STARTED
-	};
-	DELAY_MS(1);
-	ev.nte_time = c2_time_now();
-
-	/* post state change event */
-	c2_net_tm_event_post(&ev);
-}
 static void ut_post_state_change_ev_thread(int n)
 {
 	struct c2_net_tm_event ev = {
@@ -277,34 +247,24 @@ static void ut_post_state_change_ev_thread(int n)
 		.nte_status = 0,
 		.nte_next_state = (enum c2_net_tm_state) n
 	};
-	DELAY_MS(1);
-	ev.nte_time = c2_time_now();
+	c2_time_now(&ev.nte_time);
 
 	/* post state change event */
 	c2_net_tm_event_post(&ev);
 }
 
 static bool ut_tm_start_called = false;
-static int ut_tm_start(struct c2_net_transfer_mc *tm, const char *addr)
+static int ut_tm_start(struct c2_net_transfer_mc *tm)
 {
 	int rc;
-	struct c2_net_xprt *xprt;
-	struct c2_net_end_point *ep;
 
 	C2_UT_ASSERT(c2_mutex_is_locked(&tm->ntm_mutex));
 	ut_tm_start_called = true;
-
-	/* create the end point (indirectly via the transport ops vector) */
-	xprt = tm->ntm_dom->nd_xprt;
-	rc = (*xprt->nx_ops->xo_end_point_create)(&ep, tm, addr);
-	if (rc != 0)
-		return rc;
-
 	/* create bg thread to post start state change event.
-	   cannot do it here: we are in tm lock, post would assert.
+	   cannot do it here: we are in dom lock, post would assert.
 	 */
-	rc = C2_THREAD_INIT(&ut_tm_thread, struct c2_net_end_point *, NULL,
-			    &ut_post_tm_started_ev_thread, ep,
+	rc = C2_THREAD_INIT(&ut_tm_thread, int, NULL,
+			    &ut_post_state_change_ev_thread, C2_NET_TM_STARTED,
 			    "state_change%d", C2_NET_TM_STARTED);
 	C2_UT_ASSERT(rc == 0);
 	return rc;
@@ -324,53 +284,7 @@ static int ut_tm_stop(struct c2_net_transfer_mc *tm, bool cancel)
 	return rc;
 }
 
-static bool ut_tm_confine_called = false;
-static const struct c2_bitmap *ut_tm_confine_bm;
-static int ut_tm_confine(struct c2_net_transfer_mc *tm,
-			 const struct c2_bitmap *processors)
-{
-	C2_UT_ASSERT(c2_mutex_is_locked(&tm->ntm_mutex));
-	ut_tm_confine_called = true;
-	ut_tm_confine_bm = processors;
-	return 0;
-}
-
-static bool ut_bev_deliver_sync_called = false;
-static int ut_bev_deliver_sync(struct c2_net_transfer_mc *tm)
-{
-	C2_UT_ASSERT(c2_mutex_is_locked(&tm->ntm_mutex));
-	ut_bev_deliver_sync_called = true;
-	return 0;
-}
-
-static bool ut_bev_deliver_all_called = false;
-static void ut_bev_deliver_all(struct c2_net_transfer_mc *tm)
-{
-	C2_UT_ASSERT(c2_mutex_is_locked(&tm->ntm_mutex));
-	ut_bev_deliver_all_called = true;
-	return;
-}
-
-static bool ut_bev_pending_called = false;
-static int ut_bev_pending_last = 1;
-static bool ut_bev_pending(struct c2_net_transfer_mc *tm)
-{
-	C2_UT_ASSERT(c2_mutex_is_locked(&tm->ntm_mutex));
-	ut_bev_pending_called = true;
-	ut_bev_pending_last = 1 - ut_bev_pending_last;
-	return (bool)ut_bev_pending_last;
-}
-
-static bool ut_bev_notify_called = false;
-static void ut_bev_notify(struct c2_net_transfer_mc *tm, struct c2_chan *chan)
-{
-	C2_UT_ASSERT(c2_mutex_is_locked(&tm->ntm_mutex));
-	C2_UT_ASSERT(chan == &tm->ntm_chan);
-	ut_bev_notify_called = true;
-	return;
-}
-
-static struct c2_net_xprt_ops ut_xprt_ops = {
+static const struct c2_net_xprt_ops ut_xprt_ops = {
 	.xo_dom_init                    = ut_dom_init,
 	.xo_dom_fini                    = ut_dom_fini,
 	.xo_get_max_buffer_size         = ut_get_max_buffer_size,
@@ -385,11 +299,6 @@ static struct c2_net_xprt_ops ut_xprt_ops = {
 	.xo_tm_fini                     = ut_tm_fini,
 	.xo_tm_start                    = ut_tm_start,
 	.xo_tm_stop                     = ut_tm_stop,
-	// define at runtime .xo_tm_confine
-	// define at runtime .xo_bev_deliver_sync
-        .xo_bev_deliver_all             = ut_bev_deliver_all,
-	.xo_bev_pending                 = ut_bev_pending,
-	.xo_bev_notify                  = ut_bev_notify
 };
 
 static struct c2_net_xprt ut_xprt = {
@@ -414,12 +323,17 @@ allocate_buffers(c2_bcount_t buf_size,
 	for (i = 0; i < C2_NET_QT_NR; ++i) {
 		nb = &nbs[i];
 		C2_SET0(nb);
-		nr = buf_segs;
-		if ((buf_size / buf_segs) > buf_seg_size) {
-			sz = buf_seg_size;
-			C2_ASSERT((sz * nr) <= buf_size);
+		if (i == C2_NET_QT_MSG_RECV) {
+			sz = min64(256, buf_seg_size);
+			nr = 1;
 		} else {
-			sz = buf_size/buf_segs;
+			nr = buf_segs;
+			if ((buf_size / buf_segs) > buf_seg_size) {
+				sz = buf_seg_size;
+				C2_ASSERT((sz * nr) <= buf_size);
+			} else {
+				sz = buf_size/buf_segs;
+			}
 		}
 		rc = c2_bufvec_alloc(&nb->nb_buffer, nr, sz);
 		C2_UT_ASSERT(rc == 0);
@@ -430,32 +344,29 @@ allocate_buffers(c2_bcount_t buf_size,
 	return nbs;
 }
 
-static void make_desc(struct c2_net_buf_desc *desc)
+void make_desc(struct c2_net_buf_desc *desc)
 {
 	static const char *p = "descriptor";
 	size_t len = strlen(p)+1;
 	desc->nbd_data = c2_alloc(len);
 	desc->nbd_len = len;
-	strcpy((char *)desc->nbd_data, p);
+	strcpy(desc->nbd_data, p);
 }
 
 /* callback subs */
 static int ut_cb_calls[C2_NET_QT_NR];
-static uint64_t num_adds[C2_NET_QT_NR];
-static uint64_t num_dels[C2_NET_QT_NR];
+static int num_adds[C2_NET_QT_NR];
+static int num_dels[C2_NET_QT_NR];
 static c2_bcount_t total_bytes[C2_NET_QT_NR];
 static c2_bcount_t max_bytes[C2_NET_QT_NR];
 
-static void ut_buffer_event_callback(const struct c2_net_buffer_event *ev,
-				     enum c2_net_queue_type qt,
-				     bool queue_check)
+void ut_buffer_event_callback(const struct c2_net_buffer_event *ev,
+			      enum c2_net_queue_type qt)
 {
 	c2_bcount_t len = 0;
 	C2_UT_ASSERT(ev->nbe_buffer != NULL);
 	C2_UT_ASSERT(ev->nbe_buffer->nb_qtype == qt);
 	ut_cb_calls[qt]++;
-	if (queue_check)
-		C2_UT_ASSERT(!(ev->nbe_buffer->nb_flags & C2_NET_BUF_QUEUED));
 	/* Collect stats to test the q stats.
 	   Length counted only on success.
 	   Receive buffer lengths are in the event.
@@ -475,63 +386,41 @@ static void ut_buffer_event_callback(const struct c2_net_buffer_event *ev,
 			len = ev->nbe_buffer->nb_length;
 		}
 	}
-	if (qt == C2_NET_QT_MSG_RECV || qt == C2_NET_QT_MSG_SEND) {
-		C2_UT_ASSERT(ev->nbe_buffer->nb_desc.nbd_len == 0);
-	} else if (ev->nbe_status == 0 &&
-		   !(ev->nbe_buffer->nb_flags & C2_NET_BUF_QUEUED)) {
-		C2_UT_ASSERT(ev->nbe_buffer->nb_desc.nbd_len > 0);
-		c2_net_desc_free(&ev->nbe_buffer->nb_desc);
-	}
-
 	total_bytes[qt] += len;
 	max_bytes[qt] = max64u(ev->nbe_buffer->nb_length,max_bytes[qt]);
 }
 
-#define UT_CB_CALL(_qt) ut_buffer_event_callback(ev, _qt, true)
-static void ut_msg_recv_cb(const struct c2_net_buffer_event *ev)
+#define UT_CB_CALL(_qt) ut_buffer_event_callback(ev, _qt)
+void ut_msg_recv_cb(const struct c2_net_buffer_event *ev)
 {
 	UT_CB_CALL(C2_NET_QT_MSG_RECV);
 }
 
-static void ut_msg_send_cb(const struct c2_net_buffer_event *ev)
+void ut_msg_send_cb(const struct c2_net_buffer_event *ev)
 {
 	UT_CB_CALL(C2_NET_QT_MSG_SEND);
 }
 
-static void ut_passive_bulk_recv_cb(const struct c2_net_buffer_event *ev)
+void ut_passive_bulk_recv_cb(const struct c2_net_buffer_event *ev)
 {
 	UT_CB_CALL(C2_NET_QT_PASSIVE_BULK_RECV);
 }
 
-static void ut_passive_bulk_send_cb(const struct c2_net_buffer_event *ev)
+void ut_passive_bulk_send_cb(const struct c2_net_buffer_event *ev)
 {
 	UT_CB_CALL(C2_NET_QT_PASSIVE_BULK_SEND);
 }
 
-static void ut_active_bulk_recv_cb(const struct c2_net_buffer_event *ev)
+void ut_active_bulk_recv_cb(const struct c2_net_buffer_event *ev)
 {
 	UT_CB_CALL(C2_NET_QT_ACTIVE_BULK_RECV);
 }
 
-static void ut_active_bulk_send_cb(const struct c2_net_buffer_event *ev)
+void ut_active_bulk_send_cb(const struct c2_net_buffer_event *ev)
 {
 	UT_CB_CALL(C2_NET_QT_ACTIVE_BULK_SEND);
 }
 
-static bool ut_multi_use_expect_queued;
-static struct c2_net_buffer *ut_multi_use_got_buf;
-static void ut_multi_use_cb(const struct c2_net_buffer_event *ev)
-{
-	C2_UT_ASSERT(ev->nbe_buffer != NULL);
-	if (ut_multi_use_expect_queued) {
-		C2_UT_ASSERT(ev->nbe_buffer->nb_flags & C2_NET_BUF_QUEUED);
-	} else {
-		C2_UT_ASSERT(!(ev->nbe_buffer->nb_flags & C2_NET_BUF_QUEUED));
-	}
-	ut_multi_use_got_buf = ev->nbe_buffer;
-	ut_buffer_event_callback(ev, ev->nbe_buffer->nb_qtype, false);
-}
-
 static int ut_tm_event_cb_calls = 0;
 void ut_tm_event_cb(const struct c2_net_tm_event *ev)
 {
@@ -554,17 +443,6 @@ struct c2_net_buffer_callbacks ut_buf_cb = {
 	},
 };
 
-struct c2_net_buffer_callbacks ut_buf_multi_use_cb = {
-	.nbc_cb = {
-		[C2_NET_QT_MSG_RECV]          = ut_multi_use_cb,
-		[C2_NET_QT_MSG_SEND]          = ut_multi_use_cb,
-		[C2_NET_QT_PASSIVE_BULK_RECV] = ut_multi_use_cb,
-		[C2_NET_QT_PASSIVE_BULK_SEND] = ut_multi_use_cb,
-		[C2_NET_QT_ACTIVE_BULK_RECV]  = ut_multi_use_cb,
-		[C2_NET_QT_ACTIVE_BULK_SEND]  = ut_multi_use_cb,
-	},
-};
-
 static struct c2_net_transfer_mc ut_tm = {
 	.ntm_callbacks = &ut_tm_cb,
 	.ntm_state = C2_NET_TM_UNDEFINED
@@ -573,10 +451,9 @@ static struct c2_net_transfer_mc ut_tm = {
 /*
   Unit test starts
  */
-static void test_net_bulk_if(void)
+void test_net_bulk_if(void)
 {
-	int rc, i, reuse_cnt;
-	bool brc;
+	int rc, i;
 	c2_bcount_t buf_size, buf_seg_size;
 	int32_t   buf_segs;
 	struct c2_net_domain *dom = &utdom;
@@ -587,9 +464,6 @@ static void test_net_bulk_if(void)
 	struct c2_net_buf_desc d1, d2;
 	struct c2_clink tmwait;
 	struct c2_net_qstats qs[C2_NET_QT_NR];
-	c2_time_t c2tt_to_period;
-	struct c2_bitmap *procmask = (void *) -1; /* fake not null UT value */
-	enum { NUM_REUSES = 2 };
 
 	C2_SET0(&d1);
 	C2_SET0(&d2);
@@ -606,7 +480,6 @@ static void test_net_bulk_if(void)
 	c2_net_desc_free(&d2);
 	C2_UT_ASSERT(d2.nbd_data == NULL);
 	C2_UT_ASSERT(d2.nbd_len == 0);
-	c2_net_desc_free(&d1);
 
 	/* initialize the domain */
 	C2_UT_ASSERT(ut_dom_init_called == false);
@@ -641,6 +514,55 @@ static void test_net_bulk_if(void)
 	C2_ASSERT(c2_mutex_is_not_locked(&dom->nd_mutex));
 	C2_UT_ASSERT(buf_segs == UT_MAX_BUF_SEGMENTS);
 
+	/* Test desired end point behavior
+	   A real transport isn't actually forced to maintain
+	   reference counts this way, but ought to do so.
+	 */
+	C2_UT_ASSERT(ut_end_point_create_called == false);
+	rc = c2_net_end_point_create(&ep1, dom, NULL);
+	C2_UT_ASSERT(rc != 0); /* no dynamic */
+	C2_UT_ASSERT(ut_end_point_create_called);
+	C2_ASSERT(c2_mutex_is_not_locked(&dom->nd_mutex));
+	C2_ASSERT(c2_list_is_empty(&dom->nd_end_points));
+
+	ut_end_point_create_called = false;
+	rc = c2_net_end_point_create(&ep1, dom, "addr1");
+	C2_UT_ASSERT(rc == 0);
+	C2_UT_ASSERT(ut_end_point_create_called);
+	C2_ASSERT(c2_mutex_is_not_locked(&dom->nd_mutex));
+	C2_ASSERT(!c2_list_is_empty(&dom->nd_end_points));
+	C2_UT_ASSERT(c2_atomic64_get(&ep1->nep_ref.ref_cnt) == 1);
+
+	rc = c2_net_end_point_create(&ep2, dom, "addr2");
+	C2_UT_ASSERT(rc == 0);
+	C2_UT_ASSERT(ep2 != ep1);
+
+	rc = c2_net_end_point_create(&ep, dom, "addr1");
+	C2_UT_ASSERT(rc == 0);
+	C2_UT_ASSERT(ep == ep1);
+	C2_UT_ASSERT(c2_atomic64_get(&ep->nep_ref.ref_cnt) == 2);
+
+	C2_UT_ASSERT(ut_end_point_release_called == false);
+	c2_net_end_point_get(ep); /* refcnt=3 */
+	C2_UT_ASSERT(c2_atomic64_get(&ep->nep_ref.ref_cnt) == 3);
+
+	C2_UT_ASSERT(ut_end_point_release_called == false);
+	rc = c2_net_end_point_put(ep); /* refcnt=2 */
+	C2_UT_ASSERT(rc == 0);
+	C2_UT_ASSERT(ut_end_point_release_called == false);
+	C2_UT_ASSERT(c2_atomic64_get(&ep->nep_ref.ref_cnt) == 2);
+
+	rc = c2_net_end_point_put(ep); /* refcnt=1 */
+	C2_UT_ASSERT(rc == 0);
+	C2_UT_ASSERT(ut_end_point_release_called == false);
+	C2_UT_ASSERT(c2_atomic64_get(&ep->nep_ref.ref_cnt) == 1);
+
+	rc = c2_net_end_point_put(ep); /* refcnt=0 */
+	C2_UT_ASSERT(rc == 0);
+	C2_UT_ASSERT(ut_end_point_release_called);
+	C2_UT_ASSERT(ut_last_ep_released == ep);
+	ep1 = NULL; /* not valid! */
+
 	/* allocate buffers for testing */
 	nbs = allocate_buffers(buf_size, buf_seg_size, buf_segs);
 
@@ -648,18 +570,15 @@ static void test_net_bulk_if(void)
 	for (i = 0; i < C2_NET_QT_NR; ++i) {
 		nb = &nbs[i];
 		nb->nb_flags = 0;
-		nb->nb_timeout = 0;
 		ut_buf_register_called = false;
 		rc = c2_net_buffer_register(nb, dom);
 		C2_UT_ASSERT(rc == 0);
 		C2_UT_ASSERT(ut_buf_register_called);
 		C2_UT_ASSERT(nb->nb_flags & C2_NET_BUF_REGISTERED);
-		C2_UT_ASSERT(nb->nb_timeout == C2_TIME_NEVER);
 		num_adds[i] = 0;
 		num_dels[i] = 0;
 		total_bytes[i] = 0;
 	}
-	c2_time_set(&c2tt_to_period, 120, 0); /* 2 min */
 
 	/* TM init with callbacks */
 	rc = c2_net_tm_init(tm, dom);
@@ -683,109 +602,29 @@ static void test_net_bulk_if(void)
 	C2_UT_ASSERT(tm->ntm_state == C2_NET_TM_INITIALIZED);
 	C2_UT_ASSERT(c2_list_contains(&dom->nd_tms, &tm->ntm_dom_linkage));
 
-	/* check the confine API */
-	C2_UT_ASSERT(dom->nd_xprt->nx_ops->xo_tm_confine == NULL);
-	rc = c2_net_tm_confine(tm, procmask);
-	C2_UT_ASSERT(rc == -ENOSYS); /* optional support */
-	C2_UT_ASSERT(!ut_tm_confine_called);
-	ut_xprt_ops.xo_tm_confine = ut_tm_confine; /* provide the operation */
-	C2_UT_ASSERT(dom->nd_xprt->nx_ops->xo_tm_confine != NULL);
-	rc = c2_net_tm_confine(tm, procmask);
-	C2_UT_ASSERT(rc == 0);
-	C2_UT_ASSERT(ut_tm_confine_called);
-	C2_UT_ASSERT(ut_tm_confine_bm == procmask);
-
 	/* TM start */
 	c2_clink_init(&tmwait, NULL);
 	c2_clink_add(&tm->ntm_chan, &tmwait);
 
-	C2_UT_ASSERT(ut_end_point_create_called == false);
-	rc = c2_net_tm_start(tm, "addr2");
+	rc = c2_net_tm_start(tm, ep2);
 	C2_UT_ASSERT(rc == 0);
 	C2_UT_ASSERT(ut_tm_start_called);
+	C2_UT_ASSERT(tm->ntm_ep == ep2);
 	C2_UT_ASSERT(tm->ntm_state == C2_NET_TM_STARTING ||
 		     tm->ntm_state == C2_NET_TM_STARTED);
+	C2_UT_ASSERT(c2_atomic64_get(&ep2->nep_ref.ref_cnt) == 2);
 
 	/* wait on channel for started */
 	c2_chan_wait(&tmwait);
 	c2_clink_del(&tmwait);
 	C2_UT_ASSERT(ut_tm_event_cb_calls == 1);
 	C2_UT_ASSERT(tm->ntm_state == C2_NET_TM_STARTED);
-	C2_UT_ASSERT(ut_end_point_create_called);
-
-	C2_UT_ASSERT(tm->ntm_ep != NULL);
-	C2_UT_ASSERT(c2_atomic64_get(&tm->ntm_ep->nep_ref.ref_cnt) == 1);
-
-	/* Test desired end point behavior
-	   A real transport isn't actually forced to maintain
-	   reference counts this way, but ought to do so.
-	 */
-	ut_end_point_create_called = false;
-	rc = c2_net_end_point_create(&ep1, tm, NULL);
-	C2_UT_ASSERT(rc != 0); /* no dynamic */
-	C2_UT_ASSERT(ut_end_point_create_called);
-	C2_ASSERT(c2_mutex_is_not_locked(&tm->ntm_mutex));
-	C2_ASSERT(c2_list_length(&tm->ntm_end_points) == 1);
-
-	ut_end_point_create_called = false;
-	rc = c2_net_end_point_create(&ep1, tm, "addr1");
-	C2_UT_ASSERT(rc == 0);
-	C2_UT_ASSERT(ut_end_point_create_called);
-	C2_ASSERT(c2_mutex_is_not_locked(&tm->ntm_mutex));
-	C2_ASSERT(!c2_list_is_empty(&tm->ntm_end_points));
-	C2_UT_ASSERT(c2_atomic64_get(&ep1->nep_ref.ref_cnt) == 1);
-
-	rc = c2_net_end_point_create(&ep2, tm, "addr2");
-	C2_UT_ASSERT(rc == 0);
-	C2_UT_ASSERT(ep2 != ep1);
-	C2_UT_ASSERT(ep2 == tm->ntm_ep);
-	C2_UT_ASSERT(c2_atomic64_get(&ep2->nep_ref.ref_cnt) == 2);
-
-	rc = c2_net_end_point_create(&ep, tm, "addr1");
-	C2_UT_ASSERT(rc == 0);
-	C2_UT_ASSERT(ep == ep1);
-	C2_UT_ASSERT(c2_atomic64_get(&ep->nep_ref.ref_cnt) == 2);
-
-	C2_UT_ASSERT(ut_end_point_release_called == false);
-	c2_net_end_point_get(ep); /* refcnt=3 */
-	C2_UT_ASSERT(c2_atomic64_get(&ep->nep_ref.ref_cnt) == 3);
-
-	C2_UT_ASSERT(ut_end_point_release_called == false);
-	rc = c2_net_end_point_put(ep); /* refcnt=2 */
-	C2_UT_ASSERT(rc == 0);
-	C2_UT_ASSERT(ut_end_point_release_called == false);
-	C2_UT_ASSERT(c2_atomic64_get(&ep->nep_ref.ref_cnt) == 2);
-
-	rc = c2_net_end_point_put(ep); /* refcnt=1 */
-	C2_UT_ASSERT(rc == 0);
-	C2_UT_ASSERT(ut_end_point_release_called == false);
-	C2_UT_ASSERT(c2_atomic64_get(&ep->nep_ref.ref_cnt) == 1);
-
-	rc = c2_net_end_point_put(ep); /* refcnt=0 */
-	C2_UT_ASSERT(rc == 0);
-	C2_UT_ASSERT(ut_end_point_release_called);
-	C2_UT_ASSERT(ut_last_ep_released == ep);
-	ep1 = NULL; /* not valid! */
-
-	/* add MSG_RECV buf with a timeout in the past - should fail */
-	nb = &nbs[C2_NET_QT_MSG_RECV];
-	nb->nb_callbacks = &ut_buf_cb;
-	C2_UT_ASSERT(!(nb->nb_flags & C2_NET_BUF_QUEUED));
-	nb->nb_qtype = C2_NET_QT_MSG_RECV;
-	nb->nb_timeout = c2_time_sub(c2_time_now(), c2tt_to_period);
-	nb->nb_min_receive_size = buf_size;
-	nb->nb_max_receive_msgs = 1;
-	rc = c2_net_buffer_add(nb, tm);
-	C2_UT_ASSERT(rc == -ETIME);
 
 	/* add MSG_RECV buf - should succeeded as now started */
 	nb = &nbs[C2_NET_QT_MSG_RECV];
 	nb->nb_callbacks = &ut_buf_cb;
 	C2_UT_ASSERT(!(nb->nb_flags & C2_NET_BUF_QUEUED));
 	nb->nb_qtype = C2_NET_QT_MSG_RECV;
-	nb->nb_timeout = c2_time_add(c2_time_now(), c2tt_to_period);
-	nb->nb_min_receive_size = buf_size;
-	nb->nb_max_receive_msgs = 1;
 	rc = c2_net_buffer_add(nb, tm);
 	C2_UT_ASSERT(rc == 0);
 	C2_UT_ASSERT(ut_buf_add_called);
@@ -830,8 +669,6 @@ static void test_net_bulk_if(void)
 			make_desc(&nb->nb_desc);
 			break;
 		}
-		nb->nb_timeout = c2_time_add(c2_time_now(),
-					     c2tt_to_period);
 		rc = c2_net_buffer_add(nb, tm);
 		C2_UT_ASSERT(rc == 0);
 		C2_UT_ASSERT(nb->nb_flags & C2_NET_BUF_QUEUED);
@@ -840,19 +677,18 @@ static void test_net_bulk_if(void)
 		max_bytes[nb->nb_qtype] = max64u(buf_size,
 						 max_bytes[nb->nb_qtype]);
 	}
-	C2_UT_ASSERT(c2_atomic64_get(&ep2->nep_ref.ref_cnt) == 3);
+	C2_UT_ASSERT(c2_atomic64_get(&ep2->nep_ref.ref_cnt) == 5);
 
 	/* fake each type of buffer "post" response.
 	   xprt normally does this
 	 */
 	for (i = C2_NET_QT_MSG_RECV; i < C2_NET_QT_NR; ++i) {
+		nb = &nbs[i];
 		struct c2_net_buffer_event ev = {
-			.nbe_buffer = &nbs[i],
+			.nbe_buffer = nb,
 			.nbe_status = 0,
 		};
-		DELAY_MS(1);
-		ev.nbe_time = c2_time_now();
-		nb = &nbs[i];
+		c2_time_now(&ev.nbe_time);
 
 		if (i == C2_NET_QT_MSG_RECV) {
 			/* simulate transport ep in recv msg */
@@ -871,7 +707,6 @@ static void test_net_bulk_if(void)
 		c2_net_buffer_event_post(&ev);
 		C2_UT_ASSERT(ut_cb_calls[i] == 1);
 		C2_UT_ASSERT(!(nb->nb_flags & C2_NET_BUF_IN_USE));
-		C2_UT_ASSERT(nb->nb_timeout == C2_TIME_NEVER);
 	}
 	C2_UT_ASSERT(c2_atomic64_get(&ep2->nep_ref.ref_cnt) == 2);
 
@@ -879,7 +714,6 @@ static void test_net_bulk_if(void)
 	nb = &nbs[C2_NET_QT_PASSIVE_BULK_SEND];
 	C2_UT_ASSERT(!(nb->nb_flags & C2_NET_BUF_QUEUED));
 	nb->nb_qtype = C2_NET_QT_PASSIVE_BULK_SEND;
-	c2_net_desc_free(&nb->nb_desc);
 	rc = c2_net_buffer_add(nb, tm);
 	C2_UT_ASSERT(rc == 0);
 	num_adds[nb->nb_qtype]++;
@@ -890,123 +724,11 @@ static void test_net_bulk_if(void)
 	c2_clink_add(&tm->ntm_chan, &tmwait);
 	c2_net_buffer_del(nb, tm);
 	C2_UT_ASSERT(ut_buf_del_called);
-	c2_net_desc_free(&nb->nb_desc);
 	num_dels[nb->nb_qtype]++;
 
-	/* wait on channel for post (and consume UT thread) */
+	/* wait on channel for post */
 	c2_chan_wait(&tmwait);
 	c2_clink_del(&tmwait);
-	rc = c2_thread_join(&ut_del_thread);
-	C2_UT_ASSERT(rc == 0);
-
-	/* Initialize and add buffers for multi-use.
-	   Note: the net API does not restrict multi-use to the recv queue.
-	 */
-	C2_UT_ASSERT(c2_atomic64_get(&ep2->nep_ref.ref_cnt) == 2);
-	for (i = C2_NET_QT_MSG_RECV; i < C2_NET_QT_NR; ++i) {
-		nb = &nbs[i];
-		C2_UT_ASSERT(!(nb->nb_flags & C2_NET_BUF_QUEUED));
-		nb->nb_qtype = i;
-		nb->nb_callbacks = &ut_buf_multi_use_cb;
-		nb->nb_length = 0;
-		/* NB: real code sets nb_ep to server ep */
-		switch (i) {
-		case C2_NET_QT_MSG_RECV:
-			nb->nb_min_receive_size = buf_size;
-			nb->nb_max_receive_msgs = 2;
-			break;
-		case C2_NET_QT_MSG_SEND:
-			nb->nb_ep = ep2;
-			nb->nb_length = buf_size;
-			break;
-		case C2_NET_QT_PASSIVE_BULK_RECV:
-			nb->nb_ep = ep2;
-			break;
-		case C2_NET_QT_PASSIVE_BULK_SEND:
-			nb->nb_ep = ep2;
-			nb->nb_length = buf_size;
-			break;
-		case C2_NET_QT_ACTIVE_BULK_RECV:
-			make_desc(&nb->nb_desc);
-			break;
-		case C2_NET_QT_ACTIVE_BULK_SEND:
-			nb->nb_length = buf_size;
-			make_desc(&nb->nb_desc);
-			break;
-		}
-		nb->nb_timeout = c2_time_add(c2_time_now(),
-					     c2tt_to_period);
-		nb->nb_tm = NULL;
-		rc = c2_net_buffer_add(nb, tm);
-		C2_UT_ASSERT(rc == 0);
-		C2_UT_ASSERT(nb->nb_flags & C2_NET_BUF_QUEUED);
-		C2_UT_ASSERT(nb->nb_tm == tm);
-		num_adds[nb->nb_qtype]++;
-		max_bytes[nb->nb_qtype] = max64u(buf_size,
-						 max_bytes[nb->nb_qtype]);
-	}
-	C2_UT_ASSERT(c2_atomic64_get(&ep2->nep_ref.ref_cnt) == 3);
-
-	/* Issue multiple fake buffer "post" with the RETAIN flag. */
-	for (reuse_cnt = 0; reuse_cnt < NUM_REUSES; ++reuse_cnt) {
-		bool retain = true;
-		if (reuse_cnt == NUM_REUSES - 1)
-			retain = false;
-		for (i = C2_NET_QT_MSG_RECV; i < C2_NET_QT_NR; ++i) {
-			c2_time_t to_before;
-			struct c2_net_buffer_event ev = {
-				.nbe_buffer = &nbs[i],
-				.nbe_status = 0,
-			};
-			DELAY_MS(1);
-			ev.nbe_time = c2_time_now();
-			nb = &nbs[i];
-
-			if (i == C2_NET_QT_MSG_RECV) {
-				/* simulate transport ep in recv msg */
-				ev.nbe_ep = ep2;
-				c2_net_end_point_get(ep2);
-			}
-
-			if (i == C2_NET_QT_MSG_RECV ||
-			    i == C2_NET_QT_PASSIVE_BULK_RECV ||
-			    i == C2_NET_QT_ACTIVE_BULK_RECV) {
-				/* fake the length in the event */
-				ev.nbe_length = buf_size;
-				nb->nb_length = 0; /* the tests expect this */
-			}
-
-			nb->nb_flags |= C2_NET_BUF_IN_USE;
-			if (retain) {
-				nb->nb_flags |= C2_NET_BUF_RETAIN;
-				to_before = nb->nb_timeout;
-				ut_multi_use_expect_queued = true;
-				if (i == C2_NET_QT_MSG_SEND)
-					c2_net_end_point_get(ep2); /* adjust */
-			} else {
-				ut_multi_use_expect_queued = false;
-			}
-			c2_net_buffer_event_post(&ev);
-			C2_UT_ASSERT(ut_multi_use_got_buf == nb);
-			C2_UT_ASSERT(!(nb->nb_flags & C2_NET_BUF_RETAIN));
-			if (retain) {
-				C2_UT_ASSERT(to_before == nb->nb_timeout);
-				C2_UT_ASSERT(nb->nb_flags & C2_NET_BUF_QUEUED);
-				C2_UT_ASSERT(nb->nb_flags & C2_NET_BUF_IN_USE);
-			} else {
-				C2_UT_ASSERT(nb->nb_timeout == C2_TIME_NEVER);
-				C2_UT_ASSERT(!(nb->nb_flags &
-					       C2_NET_BUF_QUEUED));
-				C2_UT_ASSERT(!(nb->nb_flags &
-					       C2_NET_BUF_IN_USE));
-			}
-		}
-	}
-
-	/* free end point */
-	C2_UT_ASSERT(c2_atomic64_get(&ep2->nep_ref.ref_cnt) == 2);
-	rc = c2_net_end_point_put(ep2);
-	C2_UT_ASSERT(rc == 0);
 
 	/* TM stop */
 	c2_clink_add(&tm->ntm_chan, &tmwait);
@@ -1027,7 +749,7 @@ static void test_net_bulk_if(void)
 	/* de-register channel waiter */
 	c2_clink_fini(&tmwait);
 
-	/* get stats (specific queue, then all queues) */
+	/* get stats */
 	i = C2_NET_QT_PASSIVE_BULK_SEND;
 	rc = c2_net_tm_stats_get(tm, i, &qs[0], false);
 	C2_UT_ASSERT(rc == 0);
@@ -1036,30 +758,20 @@ static void test_net_bulk_if(void)
 	C2_UT_ASSERT(qs[0].nqs_total_bytes == total_bytes[i]);
 	C2_UT_ASSERT(qs[0].nqs_max_bytes == max_bytes[i]);
 	C2_UT_ASSERT((qs[0].nqs_num_f_events + qs[0].nqs_num_s_events)
-		     == num_adds[i] + reuse_cnt - 1);
+		     == num_adds[i]);
 	C2_UT_ASSERT(qs[0].nqs_num_f_events + qs[0].nqs_num_s_events > 0 &&
 		     qs[0].nqs_time_in_queue > 0);
 
 	rc = c2_net_tm_stats_get(tm, C2_NET_QT_NR, qs, true);
 	C2_UT_ASSERT(rc == 0);
 	for (i = 0; i < C2_NET_QT_NR; i++) {
-		KPRN("i=%d\n", i);
-#define QS(x)  KPRN("\t" #x "=%"PRId64"\n", qs[i].nqs_##x)
-#define QS2(x) KPRN("\t" #x "=%"PRId64" [%"PRId64"]\n", qs[i].nqs_##x, x[i])
-		QS2(num_adds);
-		QS2(num_dels);
-		QS2(total_bytes);
-		QS(max_bytes);
-		QS(num_f_events);
-		QS(num_s_events);
-		QS(time_in_queue);
 		C2_UT_ASSERT(qs[i].nqs_num_adds == num_adds[i]);
 		C2_UT_ASSERT(qs[i].nqs_num_dels == num_dels[i]);
 		C2_UT_ASSERT(qs[i].nqs_total_bytes == total_bytes[i]);
 		C2_UT_ASSERT(qs[i].nqs_total_bytes >= qs[i].nqs_max_bytes);
 		C2_UT_ASSERT(qs[i].nqs_max_bytes == max_bytes[i]);
 		C2_UT_ASSERT((qs[i].nqs_num_f_events + qs[i].nqs_num_s_events)
-			     == num_adds[i] + reuse_cnt - 1);
+			     == num_adds[i]);
 		C2_UT_ASSERT(qs[i].nqs_num_f_events +
 			     qs[i].nqs_num_s_events > 0 &&
 			     qs[i].nqs_time_in_queue > 0);
@@ -1082,86 +794,21 @@ static void test_net_bulk_if(void)
 	c2_net_tm_fini(tm);
 	C2_UT_ASSERT(ut_tm_fini_called);
 
-	/* TM fini releases final end point */
-	C2_UT_ASSERT(ut_last_ep_released == ep2);
-
-	/*
-	 * Test APIs for synchronous buffer event delivery
-	 */
-
-	/* restart the TM */
-	ut_tm_init_called = false;
-	ut_tm_fini_called = false;
-	rc = c2_net_tm_init(tm, dom);
-	C2_UT_ASSERT(rc == 0);
-	C2_UT_ASSERT(ut_tm_init_called);
-	C2_UT_ASSERT(tm->ntm_state == C2_NET_TM_INITIALIZED);
-	C2_UT_ASSERT(c2_list_contains(&dom->nd_tms, &tm->ntm_dom_linkage));
-	C2_UT_ASSERT(tm->ntm_bev_auto_deliver);
-
-	/* request synchronous buffer event delivery */
-	C2_UT_ASSERT(dom->nd_xprt->nx_ops->xo_bev_deliver_sync == NULL);
-	rc = c2_net_buffer_event_deliver_synchronously(tm);
-	C2_UT_ASSERT(rc == -ENOSYS); /* optional support */
-	C2_UT_ASSERT(tm->ntm_bev_auto_deliver);
-	C2_UT_ASSERT(!ut_bev_deliver_sync_called);
-	ut_xprt_ops.xo_bev_deliver_sync = ut_bev_deliver_sync; /* set op */
-	C2_UT_ASSERT(dom->nd_xprt->nx_ops->xo_bev_deliver_sync != NULL);
-	rc = c2_net_buffer_event_deliver_synchronously(tm);
-	C2_UT_ASSERT(ut_bev_deliver_sync_called);
+	/* free end points */
+	C2_UT_ASSERT(c2_atomic64_get(&ep2->nep_ref.ref_cnt) == 1);
+	rc = c2_net_end_point_put(ep2);
 	C2_UT_ASSERT(rc == 0);
-	C2_UT_ASSERT(!tm->ntm_bev_auto_deliver);
-
-	/* start the TM */
-	c2_clink_init(&tmwait, NULL);
-	c2_clink_add(&tm->ntm_chan, &tmwait);
-	rc = c2_net_tm_start(tm, "addr3");
-	c2_chan_wait(&tmwait);
-	c2_clink_del(&tmwait);
-	C2_UT_ASSERT(tm->ntm_state == C2_NET_TM_STARTED);
-	c2_thread_join(&ut_tm_thread); /* cleanup thread */
-	c2_thread_fini(&ut_tm_thread);
-
-	/* test the synchronous buffer event delivery APIs */
-	C2_UT_ASSERT(!ut_bev_pending_called);
-	brc = c2_net_buffer_event_pending(tm);
-	C2_UT_ASSERT(ut_bev_pending_called);
-	C2_UT_ASSERT(!brc);
-
-	C2_UT_ASSERT(!ut_bev_notify_called);
-	c2_net_buffer_event_notify(tm, &tm->ntm_chan);
-	C2_UT_ASSERT(ut_bev_notify_called);
-
-	ut_bev_pending_called = false;
-	brc = c2_net_buffer_event_pending(tm);
-	C2_UT_ASSERT(ut_bev_pending_called);
-	C2_UT_ASSERT(brc);
-
-	C2_UT_ASSERT(!ut_bev_deliver_all_called);
-	c2_net_buffer_event_deliver_all(tm);
-	C2_UT_ASSERT(ut_bev_deliver_all_called);
-
-	/* TM stop and fini */
-	c2_clink_add(&tm->ntm_chan, &tmwait);
-	rc = c2_net_tm_stop(tm, false);
-	c2_chan_wait(&tmwait);
-	c2_clink_del(&tmwait);
-	c2_thread_join(&ut_tm_thread); /* cleanup thread */
-	c2_thread_fini(&ut_tm_thread);
-	c2_clink_fini(&tmwait);
-	c2_net_tm_fini(tm);
+	C2_UT_ASSERT(ut_last_ep_released == ep2);
 
-	/* de-register and free buffers */
+	/* de-register buffers */
 	for (i = 0; i < C2_NET_QT_NR; ++i) {
 		nb = &nbs[i];
 		ut_buf_deregister_called = false;
-		c2_net_desc_free(&nb->nb_desc);
-		c2_net_buffer_deregister(nb, dom);
+		rc = c2_net_buffer_deregister(nb, dom);
+		C2_UT_ASSERT(rc == 0);
 		C2_UT_ASSERT(ut_buf_deregister_called);
 		C2_UT_ASSERT(!(nb->nb_flags & C2_NET_BUF_REGISTERED));
-		c2_bufvec_free(&nb->nb_buffer);
 	}
-	c2_free(nbs);
 
 	/* fini the domain */
 	C2_UT_ASSERT(ut_dom_fini_called == false);
@@ -1169,7 +816,7 @@ static void test_net_bulk_if(void)
 	C2_UT_ASSERT(ut_dom_fini_called);
 }
 
-const struct c2_test_suite c2_net_bulk_if_ut = {
+const struct c2_test_suite net_bulk_if_ut = {
         .ts_name = "net-bulk-if",
         .ts_init = NULL,
         .ts_fini = NULL,
@@ -1178,7 +825,6 @@ const struct c2_test_suite c2_net_bulk_if_ut = {
                 { NULL, NULL }
         }
 };
-C2_EXPORTED(c2_net_bulk_if_ut);
 
 /*
  *  Local variables:
diff --git a/net/ut/net.ff b/net/ut/net.ff
index b65d5e9..241fe36 100644
--- a/net/ut/net.ff
+++ b/net/ut/net.ff
@@ -1,24 +1,5 @@
 /* -*- C -*- */
 
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Anatoliy Bilenko <Anatoliy_Bilenko@xyratex.com>
- * Original creation date: 12/05/2010
- */
-
 DEF(c2_nettest, RECORD,
     _(siq_rc, U32));
 
diff --git a/net/ut/net_fop.h b/net/ut/net_fop.h
index 98af6de..e947eb1 100644
--- a/net/ut/net_fop.h
+++ b/net/ut/net_fop.h
@@ -13,7 +13,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Anatoliy Bilenko <Anatoliy_Bilenko@xyratex.com>
+ * Original author: Anatoliy Bilenko
  * Original creation date: 12/05/2010
  */
 
diff --git a/net/ut/net_fop_init.c b/net/ut/net_fop_init.c
index 1c470c4..4b823c6 100644
--- a/net/ut/net_fop_init.c
+++ b/net/ut/net_fop_init.c
@@ -13,7 +13,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Anatoliy Bilenko <Anatoliy_Bilenko@xyratex.com>
+ * Original author: Anatoliy Bilenko
  * Original creation date: 12/05/2010
  */
 
@@ -24,7 +24,6 @@
 #include "lib/cdefs.h"
 #include "fop/fop.h"
 #include "fop/fop_format_def.h"
-#include "rpc/rpc_opcodes.h"
 
 #include "net_u.h"
 #include "net_fop.h"
@@ -36,7 +35,7 @@ static struct c2_fop_type_ops nettest_ops = {
 	.fto_execute = nettest_handler,
 };
 
-C2_FOP_TYPE_DECLARE(c2_nettest, "nettest", &nettest_ops, C2_NET_TEST_OPCODE, 0);
+C2_FOP_TYPE_DECLARE(c2_nettest, "nettest", 13, &nettest_ops);
 
 
 static struct c2_fop_type *net_ut_fops[] = {
@@ -69,7 +68,7 @@ int nettest_fop_init(void)
 	return result;
 }
 
-/*
+/* 
  *  Local variables:
  *  c-indentation-style: "K&R"
  *  c-basic-offset: 8
diff --git a/net/ut/utils.c b/net/ut/utils.c
index a0af1c2..6c7e5dd 100644
--- a/net/ut/utils.c
+++ b/net/ut/utils.c
@@ -13,7 +13,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Alexey Lyashkov <Alexey_Lyashkov@xyratex.com>
+ * Original author: Alexey Lyashkov
  * Original creation date: 05/07/2010
  */
 
diff --git a/net/xdr.h b/net/xdr.h
index 7110f33..6fa8cbc 100644
--- a/net/xdr.h
+++ b/net/xdr.h
@@ -14,8 +14,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Alexey Lyashkov <Alexey_Lyashkov@xyratex.com>,
- *                  Nikita Danilov <Nikita_Danilov@xyratex.com>
+ * Original author: Alexey Lyashkov, Nikita Danilov
  * Original creation date: 04/21/2010
  */
 
diff --git a/nrs/Makefile.am b/nrs/Makefile.am
index 7c2fa72..3c23739 100644
--- a/nrs/Makefile.am
+++ b/nrs/Makefile.am
@@ -1,4 +1,4 @@
-nrsdir                     = $(includedir)/colibri/nrs
+nrsdir                     = $(includedir)/nrs
 nrs_HEADERS                = nrs.h
 
 noinst_LTLIBRARIES         = libcolibri-nrs.la
diff --git a/nrs/nrs.c b/nrs/nrs.c
index 30bdd51..d51528a 100644
--- a/nrs/nrs.c
+++ b/nrs/nrs.c
@@ -14,7 +14,8 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Nikita Danilov <Nikita_Danilov@xyratex.com>
+ * Original author: Nikita Danilov <nikita_danilov@xyratex.com>
+ *                  Yuriy Umanets  <yuriy_umanets@xyratex.com>
  * Original creation date: 07/31/2010
  */
 
@@ -28,11 +29,9 @@
 #include "lib/cond.h"
 #include "lib/misc.h"
 #include "addb/addb.h"
-#include "fop/fop.h"
-#include "fop/fom.h"
 #include "reqh/reqh.h"
+#include "fop/fop.h"
 #include "nrs/nrs.h"
-#include "rpc/rpc2.h"
 
 /**
    @addtogroup nrs
@@ -47,8 +46,6 @@ static const struct c2_addb_loc nrs_addb = {
 	.al_name = "nrs"
 };
 
-C2_ADDB_EV_DEFINE(nrs_addb_enqueue, "enqueue", 0x10, C2_ADDB_STAMP);
-
 int c2_nrs_init(struct c2_nrs *nrs, struct c2_nrs_policy *pol, 
                 c2_nrs_fhcb_t fhcb, struct c2_reqh *reqh)
 {
@@ -91,7 +88,8 @@ void c2_nrs_fini(struct c2_nrs *nrs)
 void c2_nrs_enqueue(struct c2_nrs *nrs, struct c2_fop *fop, void *cookie)
 {
 	if (fop != NULL)
-	        C2_ADDB_ADD(&fop->f_addb, &nrs_addb, nrs_addb_enqueue);
+                C2_ADDB_ADD(&fop->f_addb, &nrs_addb, 
+                            c2_addb_func_fail, "nrs_enqueue", 0);
 	nrs->s_pol->sp_enqueue(nrs, fop, cookie);
 }
 
@@ -102,7 +100,7 @@ void c2_nrs_flush(struct c2_nrs *nrs, void *cookie)
 
 /** @} end of nrs group */
 
-/*
+/* 
  *  Local variables:
  *  c-indentation-style: "K&R"
  *  c-basic-offset: 8
diff --git a/nrs/nrs.h b/nrs/nrs.h
index f7175d0..45b93dc 100644
--- a/nrs/nrs.h
+++ b/nrs/nrs.h
@@ -14,7 +14,8 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Nikita Danilov <Nikita_Danilov@xyratex.com>
+ * Original author: Nikita Danilov <nikita_danilov@xyratex.com>
+ *                  Yuriy Umanets  <yuriy_umanets@xyratex.com>
  * Original creation date: 07/31/2010
  */
 
diff --git a/pool/Makefile.am b/pool/Makefile.am
index ea2476d..ecefef9 100644
--- a/pool/Makefile.am
+++ b/pool/Makefile.am
@@ -1,4 +1,4 @@
-pooldir                     = $(includedir)/colibri/pool
+pooldir                     = $(includedir)/pool
 pool_HEADERS                = pool.h
 
 noinst_LTLIBRARIES          = libcolibri-pool.la
diff --git a/pool/pool.c b/pool/pool.c
index b466fa5..a5368a7 100644
--- a/pool/pool.c
+++ b/pool/pool.c
@@ -13,7 +13,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Nikita Danilov <Nikita_Danilov@xyratex.com>
+ * Original author: Nikita Danilov
  * Original creation date: 07/15/2010
  */
 
@@ -36,10 +36,12 @@ int c2_pool_init(struct c2_pool *pool, uint32_t width)
 	pool->po_width = width;
 	return 0;
 }
+C2_EXPORTED(c2_pool_init);
 
 void c2_pool_fini(struct c2_pool *lay)
 {
 }
+C2_EXPORTED(c2_pool_fini);
 
 int c2_pool_alloc(struct c2_pool *pool, struct c2_stob_id *id)
 {
@@ -50,11 +52,13 @@ int c2_pool_alloc(struct c2_pool *pool, struct c2_stob_id *id)
 	C2_POST(c2_stob_id_is_set(id));
 	return 0;
 }
+C2_EXPORTED(c2_pool_alloc);
 
 void c2_pool_put(struct c2_pool *pool, struct c2_stob_id *id)
 {
 	C2_PRE(c2_stob_id_is_set(id));
 }
+C2_EXPORTED(c2_pool_put);
 
 int c2_pools_init(void)
 {
diff --git a/pool/pool.h b/pool/pool.h
index 54af6ee..73b5f4e 100644
--- a/pool/pool.h
+++ b/pool/pool.h
@@ -14,7 +14,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Nikita Danilov <Nikita_Danilov@xyratex.com>
+ * Original author: Nikita Danilov
  * Original creation date: 07/15/2010
  */
 
diff --git a/reqh/.gitignore b/reqh/.gitignore
deleted file mode 100644
index 090515c..0000000
--- a/reqh/.gitignore
+++ /dev/null
@@ -1,2 +0,0 @@
-reqh_fops_u.c
-reqh_fops_u.h
diff --git a/reqh/Makefile.am b/reqh/Makefile.am
index 12917dc..cb3a5dd 100644
--- a/reqh/Makefile.am
+++ b/reqh/Makefile.am
@@ -1,22 +1,6 @@
-reqhdir                     = $(includedir)/colibri/reqh
+reqhdir                     = $(includedir)/reqh
 reqh_HEADERS                = reqh.h
 
 noinst_LTLIBRARIES          = libcolibri-reqh.la
-
-reqh_fops_u.h reqh_fops_u.c : reqh_fops.ff \
-                        $(top_builddir)/fop/rt/libc2rt.la \
-                        $(top_builddir)/fop/fop2c
-		$(top_builddir)/fop/fop2c -u $<
-
-libcolibri_reqh_la_SOURCES  = reqh_fops_u.c reqh_fops_u.h \
-				reqh_fops.ff reqh.c reqh.h reqh_fops.c \
-				reqh_generic.c reqh_service.c \
-				reqh_service.h
-
+libcolibri_reqh_la_SOURCES  = reqh.c reqh.h
 INCLUDES                    = -I. -I$(top_srcdir) -I$(top_srcdir)/include
-
-EXTRA_DIST = reqh_fops.ff
-
-clean-local:
-	cd @SRCDIR@/reqh ; \
-	rm -fr reqh_fops_[uk].[ch]
diff --git a/reqh/reqh.c b/reqh/reqh.c
index e36fe26..36f073b 100644
--- a/reqh/reqh.c
+++ b/reqh/reqh.c
@@ -1,4 +1,3 @@
-/* -*- C -*- */
 /*
  * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
  *
@@ -14,29 +13,24 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Nikita Danilov <nikita_danilov@xyratex.com>,
- *			Mandar Sawant <Mandar_Sawant@xyratex.com>
+ * Original author: Nikita Danilov <nikita_danilov@xyratex.com>
+ *                  Yuriy Umanets  <yuriy_umanets@xyratex.com>
  * Original creation date: 05/19/2010
  */
 
 #ifdef HAVE_CONFIG_H
-#include <config.h>
+#  include <config.h>
 #endif
 
-#include "lib/errno.h"
+#include <errno.h>
+
 #include "lib/assert.h"
-#include "lib/memory.h"
 #include "lib/misc.h"
-#include "lib/atomic.h"
-
-#include "stob/stob.h"
-#include "net/net.h"
+#include "lib/bitstring.h"
+#include "db/db.h"
 #include "fop/fop.h"
-#include "fop/fom.h"
-#include "fop/fop_iterator.h"
-#include "dtm/dtm.h"
-#include "fop/fop_format_def.h"
-#include "reqh/reqh_service.h"
+#include "stob/stob.h"
+#include "cob/cob.h"
 #include "mdstore/mdstore.h"
 #include "iostore/iostore.h"
 #include "site/site.h"
@@ -48,157 +42,95 @@
    @{
  */
 
-/**
- * Reqh addb event location identifier object.
- */
-const struct c2_addb_loc c2_reqh_addb_loc = {
-	.al_name = "reqh"
-};
-
-/**
- * Reqh state of addb context.
- */
-const struct c2_addb_ctx_type c2_reqh_addb_ctx_type = {
-	.act_name = "reqh"
-};
-
-/**
-   Tlist descriptor for reqh services.
- */
-const struct c2_tl_descr c2_rh_sl_descr = C2_TL_DESCR("reqh service",
-                                                 struct c2_reqh_service,
-                                                 rs_linkage,
-                                                 rs_magic,
-                                                 C2_REQH_MAGIC,
-                                                 C2_RHS_MAGIC);
-
-/**
-   Tlist descriptor for rpc machines.
- */
-const struct c2_tl_descr c2_rh_rpml_descr = C2_TL_DESCR("rpc machines",
-                                                      struct c2_rpcmachine,
-                                                      cr_rh_linkage,
-                                                      cr_magic,
-                                                      C2_REQH_MAGIC,
-                                                      C2_RPC_MAGIC);
-
-/**
- * Reqh addb context.
- */
-struct c2_addb_ctx c2_reqh_addb_ctx;
-
-#define REQH_ADDB_ADD(addb_ctx, name, rc)  \
-C2_ADDB_ADD(&(addb_ctx), &c2_reqh_addb_loc, c2_addb_func_fail, (name), (rc))
-
-extern int c2_reqh_fop_init(void);
-extern void c2_reqh_fop_fini(void);
-
-bool c2_reqh_invariant(const struct c2_reqh *reqh)
-{
-	return reqh != NULL && reqh->rh_stdom != NULL &&
-		reqh->rh_dbenv != NULL && reqh->rh_cob_domain != NULL &&
-		reqh->rh_fol != NULL &&
-		c2_fom_domain_invariant(&reqh->rh_fom_dom);
-}
-
 int  c2_reqh_init(struct c2_reqh *reqh, struct c2_dtm *dtm,
-                struct c2_stob_domain *stdom, struct c2_dbenv *db,
-                struct c2_cob_domain *cdom, struct c2_fol *fol,
-                struct c2_site *site)
+		  struct c2_fol *fol, struct c2_site *site,
+		  struct c2_service *svc)
 {
-	int result;
-
-	C2_PRE(reqh != NULL);
-
-	result = c2_fom_domain_init(&reqh->rh_fom_dom);
-	if (result == 0) {
-		C2_ASSERT(c2_fom_domain_invariant(&reqh->rh_fom_dom));
-                reqh->rh_dtm = dtm;
-                reqh->rh_stdom = stdom;
-                reqh->rh_dbenv = db;
-                reqh->rh_cob_domain = cdom;
-                reqg->rh_site = site;
-                reqh->rh_fol = fol;
-		reqh->rh_shutdown = false;
-                reqh->rh_fom_dom.fd_reqh = reqh;
-                c2_tlist_init(&c2_rh_sl_descr, &reqh->rh_services);
-                c2_tlist_init(&c2_rh_rpml_descr, &reqh->rh_rpcmachines);
-		c2_mutex_init(&reqh->rh_lock);
-
-	} else
-		REQH_ADDB_ADD(c2_reqh_addb_ctx, "c2_reqh_init", result);
-
-	return result;
+	reqh->rh_fol = fol;
+	reqh->rh_dtm = dtm;
+	reqh->rh_svc = svc;
+	reqh->rh_site = site;
+	return 0;
 }
 
 void c2_reqh_fini(struct c2_reqh *reqh)
 {
-        C2_PRE(reqh != NULL);
-        c2_fom_domain_fini(&reqh->rh_fom_dom);
-        c2_tlist_fini(&c2_rh_sl_descr, &reqh->rh_services);
-        c2_tlist_fini(&c2_rh_rpml_descr, &reqh->rh_rpcmachines);
-	c2_mutex_fini(&reqh->rh_lock);
 }
 
-void c2_reqhs_fini(void)
+int c2_reqh_fop_handle(struct c2_reqh *reqh, struct c2_fop *fop, void *cookie)
 {
-	c2_addb_ctx_fini(&c2_reqh_addb_ctx);
-	c2_reqh_service_types_fini();
-	c2_reqh_fop_fini();
+	struct c2_fop_ctx    ctx;
+        struct c2_fop_env    env;
+        struct c2_dtx        tx;
+	struct c2_fom	    *fom;
+	int                  result;
+
+restart:
+        fom = NULL;
+        C2_SET0(&ctx);
+        C2_SET0(&env);
+
+        result = c2_db_tx_init(&tx.tx_dbtx, 
+                               reqh->rh_site->s_mdstore->md_dom.cd_dbenv, 0);
+        if (result != 0)
+                return result;
+
+        ctx.fc_site = reqh->rh_site;
+        ctx.fc_fol  = reqh->rh_fol;
+        ctx.fc_service = reqh->rh_svc;
+        ctx.fc_cookie  = cookie;
+        ctx.fc_env = &env;
+        ctx.fc_tx = &tx;
+
+        /*
+         * Init fom for the fop start handling it.
+         */
+        result = fop->f_type->ft_ops->fto_fom_init(fop, &ctx, &fom);
+        if (result)
+                goto out;
+	        
+        C2_ASSERT(fom != NULL);
+
+        if (fom->fo_ops->fo_sanity) {
+                result = fom->fo_ops->fo_sanity(fom);
+                if (result)
+                        goto out_fini;
+        }
+
+        /*
+         * Add this fop to the fol.
+         */
+        result = c2_fop_fol_rec_add(fop, ctx.fc_fol, &tx.tx_dbtx);
+        if (result)
+                goto out_fini;
+
+        /* 
+         * Start the FOM. Return value from ->fo_state() is something
+         * from FSO_* which will be used here for making decision on
+         * how to act in various cases. What we return to caller is
+         * retval from fop handling code.
+         */
+        fom->fo_ops->fo_state(fom);
+        result = ctx.fc_retval;
+out_fini:
+        if (fom->fo_ops->fo_fini)
+                fom->fo_ops->fo_fini(fom);
+out:
+        if (result < 0) {
+                c2_db_tx_abort(&tx.tx_dbtx);
+                if (result == -EDEADLK)
+                        goto restart;
+        } else {
+                c2_db_tx_commit(&tx.tx_dbtx);
+//                c2_dbenv_sync(reqh->rh_site->s_mdstore->md_dom.cd_dbenv);
+        }
+        
+        return result;
 }
 
-int c2_reqhs_init(void)
+void c2_reqh_fop_sortkey_get(struct c2_reqh *reqh, struct c2_fop *fop,
+			     struct c2_fop_sortkey *key)
 {
-	c2_addb_ctx_init(&c2_reqh_addb_ctx, &c2_reqh_addb_ctx_type,
-					&c2_addb_global_ctx);
-	c2_reqh_service_types_init();
-	return c2_reqh_fop_init();
-}
-
-void c2_reqh_fop_handle(struct c2_reqh *reqh, struct c2_fop *fop, void *cookie)
-{
-	struct c2_fom	       *fom;
-	struct c2_fom_domain   *dom;
-	int			result;
-	size_t			loc_idx;
-	bool                    rsd;
-
-	C2_PRE(reqh != NULL);
-	C2_PRE(fop != NULL);
-
-	c2_mutex_lock(&reqh->rh_lock);
-	rsd = reqh->rh_shutdown;
-	c2_mutex_unlock(&reqh->rh_lock);
-	if (rsd) {
-		REQH_ADDB_ADD(c2_reqh_addb_ctx, "c2_reqh_fop_handle",
-								ESHUTDOWN);
-		return;
-	}
-
-	C2_ASSERT(fop->f_type != NULL);
-	C2_ASSERT(fop->f_type->ft_fom_type.ft_ops != NULL);
-	C2_ASSERT(fop->f_type->ft_fom_type.ft_ops->fto_create != NULL);
-
-	result = fop->f_type->ft_fom_type.ft_ops->fto_create(fop, &fom);
-
-	if (result == 0) {
-		C2_ASSERT(fom != NULL);
-		fom->fo_fol = reqh->rh_fol;
-		dom = &reqh->rh_fom_dom;
-
-		loc_idx = fom->fo_ops->fo_home_locality(fom) % dom->fd_localities_nr;
-		C2_ASSERT(loc_idx >= 0 && loc_idx < dom->fd_localities_nr);
-		fom->fo_loc = &reqh->rh_fom_dom.fd_localities[loc_idx];
-		c2_fom_queue(fom);
-	} else
-		REQH_ADDB_ADD(c2_reqh_addb_ctx, "c2_reqh_fop_handle", result);
-}
-
-bool c2_reqh_can_shutdown(const struct c2_reqh *reqh)
-{
-	C2_PRE(reqh != NULL);
-
-	return c2_atomic64_get(&reqh->rh_fom_dom.fd_foms_nr) == 0;
 }
 
 /** @} endgroup reqh */
diff --git a/reqh/reqh.h b/reqh/reqh.h
index 2763b3f..9aeef8e 100644
--- a/reqh/reqh.h
+++ b/reqh/reqh.h
@@ -14,8 +14,8 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Nikita Danilov <nikita_danilov@xyratex.com>,
- *			Mandar Sawant <Mandar_Sawant@xyratex.com>
+ * Original author: Nikita Danilov <nikita_danilov@xyratex.com>
+ *                  Yuriy Umanets  <yuriy_umanets@xyratex.com>
  * Original creation date: 05/19/2010
  */
 
@@ -24,151 +24,75 @@
 
 #include <sm/sm.h>
 
-#include "fol/fol.h"
-#include "fop/fop.h"
-#include "fop/fom.h"
-#include "lib/tlist.h"
-
+/* import */
+struct c2_fop;
+struct c2_fom;
 struct c2_stob_domain;
 struct c2_site;
 
 /**
    @defgroup reqh Request handler
 
-   Request handler provides non-blocking infrastructure for fop execution.
-   There typically is a single request handler instance per address space, once
-   the request handler is initialised and ready to serve requests, it accepts
-   a fop (file operation packet), iterpretes it by interacting with other sub
-   systems and executes the desired file system operation.
-
-   For every incoming fop, request handler creates a corresponding fom
-   (file operation state machine), fop is executed in this fom context.
-   For every fom, request handler performs some standard operations such as
-   authentication, locating resources for its execution, authorisation of file
-   operation by the user, &tc. Once all the standard phases are completed, the
-   fop specific operation is executed.
-
-   @see https://docs.google.com/a/xyratex.com/Doc?docid=0ATg1HFjUZcaZZGNkNXg4cXpfMjA2Zmc0N3I3Z2Y&hl=en_US
    @{
  */
 
-/**
-   Magic for reqh.
- */
-enum {
-        /* Hex value for "reqhsvc" */
-        C2_REQH_MAGIC = 0x7265716873766373
-};
+struct c2_reqh;
+struct c2_fop_sortkey;
 
 /**
    Request handler instance.
  */
 struct c2_reqh {
-	struct c2_dtm		*rh_dtm;
+	struct c2_dtm         *rh_dtm;
 	/**
-	   @todo for now simply use storage object domain. In the future, this
-	   will be replaced with "stores".
-	 */
-	struct c2_stob_domain	*rh_stdom;
-
-	/** Database environment for this request handler. */
-	struct c2_dbenv         *rh_dbenv;
-
+	   File operations log for this request handler.
+	*/
+	struct c2_fol         *rh_fol;
 	/**
 	   Site on which reqh is working.
 	*/
 	struct c2_site        *rh_site;
-
-	/** Cob domain for this request handler. */
-	struct c2_cob_domain    *rh_cob_domain;
-
-	/** Fol pointer for this request handler. */
-	struct c2_fol		*rh_fol;
-
-	/** Fom domain for this request handler. */
-	struct c2_fom_domain	 rh_fom_dom;
-
-        /**
-	    Services registered with this request handler.
-
-	    @see c2_reqh_service::rs_linkage
-	 */
-        struct c2_tl             rh_services;
-
-        /**
-	    RPC machines running in this request handler
-	    There is one rpc machine per request handler
-	    end point.
-
-	    @see c2_rpcmachine::cr_rh_linkage
-	 */
-        struct c2_tl             rh_rpcmachines;
-
 	/**
-	    True if request handler received a shutdown signal.
-	    Request handler should not process any further requests
-	    if this flag is set.
-	 */
-	bool                     rh_shutdown;
-
-	/** Provides protected access to c2_reqh members. */
-	struct c2_mutex          rh_lock;
-
-	/** Request handler magic. */
-	uint64_t                 rh_magic;
+	   Service that uses this reqh.
+	*/
+        struct c2_service     *rh_svc;
 };
 
-/**
-   Initialises request handler instance provided by the caller.
-
-   @param reqh Request handler instance to be initialised
-   @param stdom Storage object domain used for file io
-   @param db Database environment for this request handler
-   @param cdom Cob domain for this request handler
-   @param fol File operation log to record fop execution
-
-   @todo use iostores instead of c2_stob_domain and endpoints
-	or c2_rpc_machine instead of c2_service
-
-   @see c2_reqh
-
-   @pre reqh != NULL && stdom != NULL && db != NULL &&
-	cdom != NULL && fol != NULL
-
-   @retval 0, if request handler is succesfully initilaised,
-		-errno, in case of failure
- */
-int  c2_reqh_init(struct c2_reqh *reqh, struct c2_dtm *dtm,
-		  struct c2_stob_domain *stdom, struct c2_dbenv *db,
-                  struct c2_cob_domain *cdom, struct c2_fol *fol,
-                  struct c2_site *site);
-
-bool c2_reqh_invariant(const struct c2_reqh *reqh);
+int  c2_reqh_init(struct c2_reqh *reqh, 
+                  struct c2_dtm *dtm,
+		  struct c2_fol *fol, 
+		  struct c2_site *site,
+		  struct c2_service *svc);
+		  
+void c2_reqh_fini(struct c2_reqh *reqh);
 
 /**
-   Destructor for request handler, no fop will be further executed
-   in the address space belonging to this request handler.
+   Sort-key determining global fop processing order.
 
-   @param reqh, request handler to be finalised
-
-   @pre reqh != NULL
+   A sort-key is assigned to a fop when it enters NRS (Network Request
+   Scheduler) incoming queue. NRS processes fops in sort-key order.
  */
-void c2_reqh_fini(struct c2_reqh *reqh);
+struct c2_fop_sortkey {
+};
 
 /**
    Submit fop for request handler processing.
-   Request handler intialises fom corresponding to this fop, finds appropriate
-   locality to execute this fom, and enqueues the fom into its runq.
-   Fop processing results are reported by other means (ADDB, reply fops, error
+
+   fop processing results are reported by other means (ADDB, reply fops, error
    messages, etc.) so this function returns nothing.
+ */
+int c2_reqh_fop_handle(struct c2_reqh *reqh, 
+                       struct c2_fop *fop, 
+                       void *cookie);
 
-   @param reqh, request handler processing the fop
-   @param fop, fop to be executed
+/**
+   Assign a sort-key to a fop.
 
-   @pre reqh != null
-   @pre fop != null
+   This function is called by NRS to order fops in its incoming queue.
  */
-void c2_reqh_fop_handle(struct c2_reqh *reqh,  struct c2_fop *fop, void *cookie);
+void c2_reqh_fop_sortkey_get(struct c2_reqh *reqh, 
+                             struct c2_fop *fop,
+			     struct c2_fop_sortkey *key);
 
 /**
    Standard fom state transition function.
@@ -213,97 +137,9 @@ void c2_reqh_fop_handle(struct c2_reqh *reqh,  struct c2_fop *fop, void *cookie)
    Once the standard actions are performed successfully, request handler
    delegates the rest of operation execution to the fom type specific state
    transition function.
-
-   Fom execution proceeds as follows:
-
-   @verbatim
-
-	fop
-	 |
-	 v                fom->fo_state = FOS_READY
-     c2_reqh_fop_handle()-------------->FOM
-					 | fom->fo_state = FOS_RUNNING
-					 v
-				     FOPH_INIT
-					 |
-			failed		 v         fom->fo_state = FOS_WAITING
-		     +<-----------FOPH_AUTHETICATE------------->+
-		     |			 |           FOPH_AUTHENTICATE_WAIT
-		     |			 v<---------------------+
-		     +<----------FOPH_RESOURCE_LOCAL----------->+
-		     |			 |           FOPH_RESOURCE_LOCAL_WAIT
-		     |			 v<---------------------+
-		     +<-------FOPH_RESOURCE_DISTRIBUTED-------->+
-		     |			 |	  FOPH_RESOURCE_DISTRIBUTED_WAIT
-		     |			 v<---------------------+
-		     +<---------FOPH_OBJECT_CHECK-------------->+
-		     |                   |              FOPH_OBJECT_CHECK
-		     |		         v<---------------------+
-		     +<---------FOPH_AUTHORISATION------------->+
-		     |			 |            FOPH_AUTHORISATION
-	             |	                 v<---------------------+
-		     +<---------FOPH_TXN_CONTEXT--------------->+
-		     |			 |            FOPH_TXN_CONTEXT_WAIT
-		     |			 v<---------------------+
-		     +<-------------FOPH_NR_+_1---------------->+
-		     |			 |            FOPH_NR_+_1_WAIT
-		     v			 v<---------------------+
-		 FOPH_FAILED        FOPH_SUCCESS
-		     |			 |
-		     v			 v
-	  +-----FOPH_TXN_ABORT    FOPH_TXN_COMMIT-------------->+
-	  |	     |			 |            FOPH_TXN_COMMIT_WAIT
-	  |	     |	    send reply	 v<---------------------+
-	  |	     +----------->FOPH_QUEUE_REPLY------------->+
-          |	     ^			 |            FOPH_QUEUE_REPLY_WAIT
-	  v	     |			 v<---------------------+
-   FOPH_TXN_ABORT_WAIT		     FOPH_FINISH ---> c2_fom_fini()
-
-   @endverbatim
-
-   If a generic phase handler function fails while executing a fom, then it
-   just sets the c2_fom::fo_rc to the result of the operation and returns FSO_WAIT.
-   c2_fom_state_generic() then sets the c2_fom::fo_phase to FOPH_FAILED, logs an
-   ADDB event, and returns, later the fom eecution proceeds as mentioned in above
-   diagram.
-   If fom fails while executing fop specific operation, the c2_fom::fo_phase is set
-   to FOPH_FAILED already by the fop specific operation handler, and the c2_fom::fo_rc
-   set to the result of the operation.
-
-   @see c2_fom_phase
-   @see c2_fom_state_outcome
-
-   @param fom, fom under execution
-
-   @retval FSO_AGAIN, if fom operation is successful, transition to next phase,
-	FSO_WAIT, if fom execution blocks and fom goes into corresponding wait
-		phase, or if fom execution is complete, i.e success or failure
-
-   @todo standard fom phases implementation, depends on the support routines for
-	handling various standard operations on fop as mentioned above
  */
 int c2_fom_state_generic(struct c2_fom *fom);
 
-/**
-   Waits for execution of all foms in the request handler's
-   fom domain to complete, i.e. until c2_fom_domain::fd_foms_nr
-   reaches 0 count.
-
-   @param reqh Request handler to be shutdown
- */
-bool c2_reqh_can_shutdown(const struct c2_reqh *reqh);
-
-/**
-    Initializes global reqh objects like reqh fops and addb context,
-    invoked from c2_init().
- */
-int c2_reqhs_init(void);
-
-/**
-   Finalises global reqh objects, invoked from c2_fini().
-*/
-void c2_reqhs_fini(void);
-
 /** @} endgroup reqh */
 
 /* __COLIBRI_REQH_REQH_H__ */
diff --git a/reqh/reqh_fops.c b/reqh/reqh_fops.c
deleted file mode 100644
index 3220832..0000000
--- a/reqh/reqh_fops.c
+++ /dev/null
@@ -1,82 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Mandar Sawant <Mandar_Sawant@xyratex.com>
- * Original creation date: 06/21/2011
- */
-
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif
-
-#include "fop/fop.h"
-#include "fop/fop_iterator.h"
-#include "fop/fop_format_def.h"
-
-#ifdef __KERNEL__
-#include "reqh_fops_k.h"
-#else
-
-#include "reqh_fops_u.h"
-#endif
-
-#include "reqh_fops.ff"
-#include "rpc/rpc_base.h"
-#include "rpc/rpc_opcodes.h"
-
-/**
-   @addtogroup reqh
-   @{
- */
-
-static struct c2_fop_type_ops reqh_err_fop_ops = {
-	.fto_execute = NULL,
-};
-
-
-C2_FOP_TYPE_DECLARE(c2_reqh_error_rep, "reqh error reply", &reqh_err_fop_ops,
-		    C2_REQH_ERROR_REPLY_OPCODE, C2_RPC_ITEM_TYPE_REPLY);
-
-static struct c2_fop_type *reqh_fops[] = {
-	&c2_reqh_error_rep_fopt,
-};
-
-void c2_reqh_fop_fini(void)
-{
-	c2_fop_type_fini_nr(reqh_fops, ARRAY_SIZE(reqh_fops));
-}
-
-int c2_reqh_fop_init(void)
-{
-	int result;
-	result = c2_fop_type_build_nr(reqh_fops, ARRAY_SIZE(reqh_fops));
-	if (result != 0)
-		c2_reqh_fop_fini();
-	return result;
-}
-
-/** @} endgroup reqh */
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
-
diff --git a/reqh/reqh_fops.ff b/reqh/reqh_fops.ff
deleted file mode 100644
index 385b7b7..0000000
--- a/reqh/reqh_fops.ff
+++ /dev/null
@@ -1,45 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Mandar Sawant <Mandar_Sawant@xyratex.com>
- * Original creation date: 06/21/2011
- */
-
-/**
-   @addtogroup reqh
-   @{
- */
-
-/**
- * @file reqh_fops.ff
- *
- * <b>Reqh generic error reply</b>
- */
-
-DEF(c2_reqh_error_rep, RECORD,
-	_(rerr_rc, U32));
-
-/** @} end of reqh group */
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
diff --git a/reqh/reqh_generic.c b/reqh/reqh_generic.c
deleted file mode 100644
index a73fef6..0000000
--- a/reqh/reqh_generic.c
+++ /dev/null
@@ -1,517 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Mandar Sawant <Mandar_Sawant@xyratex.com>
- * Original creation date: 07/19/2010
- */
-
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif
-
-#include "lib/errno.h"
-#include "lib/assert.h"
-#include "lib/memory.h"
-#include "lib/misc.h"
-#include "stob/stob.h"
-#include "net/net.h"
-#include "fop/fop.h"
-#include "fop/fom.h"
-#include "fop/fop_iterator.h"
-#include "dtm/dtm.h"
-#include "fop/fop_format_def.h"
-
-#ifdef __KERNEL__
-#include "reqh_fops_k.h"
-#else
-
-#include "reqh_fops_u.h"
-#endif
-
-#include "reqh.h"
-
-/**
-   @addtogroup reqh
-   @{
- */
-
-extern const struct c2_addb_loc c2_reqh_addb_loc;
-
-extern const struct c2_addb_ctx_type c2_reqh_addb_ctx_type;
-
-extern struct c2_addb_ctx c2_reqh_addb_ctx;
-
-#define REQH_GEN_ADDB_ADD(addb_ctx, name, rc)  \
-C2_ADDB_ADD(&(addb_ctx), &c2_reqh_addb_loc, c2_addb_func_fail, (name), (rc))
-
-/**
- * Reqh generic error fop type.
- */
-extern struct c2_fop_type c2_reqh_error_rep_fopt;
-
-/**
- * Fom phase operations structure, helps to transition fom
- * through its standard phases
- */
-struct fom_phase_ops {
-        /**
-	   Perfoms actions corresponding to a particular standard fom
-	   phase, as defined.
-
-	   @retval returns FSO_AGAIN, this transitions fom to its next phase
-
-	   @see c2_fom_state_generic()
-	 */
-        int (*fpo_action) (struct c2_fom *fom);
-        /**
-	   Next phase the fom should transition into, after successfully
-	   completing the current phase execution.
-	 */
-        int		   fpo_nextphase;
-	/**
-	   Fom phase name in user readable format.
-	 */
-	const char	  *fpo_name;
-	/**
-	   Bitmap representation of the fom phase.
-	   This is used in pre condition checks before executing
-	   fom phase action.
-
-	   @see c2_fom_state_generic()
-	 */
-	uint64_t	   fpo_pre_phase;
-};
-
-/**
- * Begins fom execution, transitions fom to its first
- * standard phase.
- *
- * @see c2_fom_state_generic()
- *
- * @retval FSO_AGAIN, to execute next fom phase
- */
-static int fom_phase_init(struct c2_fom *fom)
-{
-	return FSO_AGAIN;
-}
-
-/**
- * Performs authenticity checks on fop,
- * executed by the fom.
- */
-static int fom_authen(struct c2_fom *fom)
-{
-	return FSO_AGAIN;
-}
-
-/**
- * Resumes fom execution after completing a blocking operation
- * in FOPH_AUTHENTICATE phase.
- */
-static int fom_authen_wait(struct c2_fom *fom)
-{
-	return FSO_AGAIN;
-}
-
-/**
- * Identifies local resources required for fom
- * execution.
- */
-static int fom_loc_resource(struct c2_fom *fom)
-{
-	return FSO_AGAIN;
-}
-
-/**
- * Resumes fom execution after completing a blocking operation
- * in FOPH_RESOURCE_LOCAL phase.
- */
-static int fom_loc_resource_wait(struct c2_fom *fom)
-{
-	return FSO_AGAIN;
-}
-
-/**
- * Identifies distributed resources required for fom execution.
- */
-static int fom_dist_resource(struct c2_fom *fom)
-{
-	return FSO_AGAIN;
-}
-
-/**
- * Resumes fom execution after completing blocking operation
- * in FOPH_RESOURCE_DISTRIBUTED_PHASE.
- */
-static int fom_dist_resource_wait(struct c2_fom *fom)
-{
-	return FSO_AGAIN;
-}
-
-/**
- * Locates and loads filesystem objects affected by
- * fop executed by this fom.
- */
-static int fom_obj_check(struct c2_fom *fom)
-{
-	return FSO_AGAIN;
-}
-
-/**
- * Resumes fom execution after completing blocking operation
- * in FOPH_OBJECT_CHECK.
- */
-static int fom_obj_check_wait(struct c2_fom *fom)
-{
-	return FSO_AGAIN;
-}
-
-/**
- * Performs authorisation checks on behalf of the user,
- * accessing the file system objects affected by
- * the fop.
- */
-static int fom_auth(struct c2_fom *fom)
-{
-	return FSO_AGAIN;
-}
-
-/**
- * Resumes fom execution after completing a blocking operation
- * FOPH_AUTHORISATION phase.
- */
-static int fom_auth_wait(struct c2_fom *fom)
-{
-	return FSO_AGAIN;
-}
-
-/**
- * Creates fom local transactional context, the fom operations
- * are executed in this context.
- * If fom execution is completed successfully, the transaction is commited,
- * else it is aborted.
- */
-static int create_loc_ctx(struct c2_fom *fom)
-{
-	int		rc;
-	struct c2_reqh *reqh; 
-
-	reqh = fom->fo_loc->fl_dom->fd_reqh;
-	rc = c2_db_tx_init(&fom->fo_tx.tx_dbtx, reqh->rh_dbenv, 0);
-	if (rc != 0)
-		fom->fo_rc = rc;
-
-	return FSO_AGAIN;
-}
-
-/**
- * Resumes fom execution after completing a blocking operation,
- * FOPH_TXN_CONTEXT phase.
- */
-static int create_loc_ctx_wait(struct c2_fom *fom)
-{
-	return FSO_AGAIN;
-}
-
-/**
- * Allocates generic reqh error reply fop and sets the same
- * into fom->fo_rep_fop.
- */
-static int set_gen_err_reply(struct c2_fom *fom)
-{
-	struct c2_fop			*rfop;
-	struct c2_reqh_error_rep	*out_fop;
-
-	C2_PRE(fom != NULL);
-
-	rfop = c2_fop_alloc(&c2_reqh_error_rep_fopt, NULL);
-	if (rfop == NULL)
-		return -ENOMEM;
-	out_fop = c2_fop_data(rfop);
-	out_fop->rerr_rc = fom->fo_rc;
-	fom->fo_rep_fop = rfop;
-
-	return 0;
-}
-
-/**
- * Handles fom execution failure, if fom fails in one of
- * the standard phases, then we contruct a generic error
- * reply fop and assign it to c2_fom::fo_rep_fop, else if
- * fom fails in fop specific operation, then fom should
- * already contain a fop specific error reply provided by
- * fop specific operation.
- */
-static int fom_failure(struct c2_fom *fom)
-{
-
-	if (fom->fo_rc != 0 && fom->fo_rep_fop == NULL)
-		set_gen_err_reply(fom);
-
-	return FSO_AGAIN;
-}
-
-/**
- * Fom execution is successfull.
- */
-static int fom_success(struct c2_fom *fom)
-{
-	return FSO_AGAIN;
-}
-
-/**
- * Commits local fom transactional context if fom
- * execution is successful.
- */
-static int fom_txn_commit(struct c2_fom *fom)
-{
-	int rc;
-
-	rc = c2_db_tx_commit(&fom->fo_tx.tx_dbtx);
-
-	if (rc != 0) {
-		fom->fo_rc = rc;
-		set_gen_err_reply(fom);
-	}
-
-	return FSO_AGAIN;
-}
-
-/**
- * Resumes fom execution after completing a blocking operation
- * in FOPH_TXN_COMMIT phase.
- */
-static int fom_txn_commit_wait(struct c2_fom *fom)
-{
-	return FSO_AGAIN;
-}
-
-/**
- * Checks if transaction context is valid.
- * We check if c2_db_tx::dt_env is initialised or not.
- *
- * @retval bool -> return true, if transaction is initialised
- *		return false, if transaction is uninitialised
- */
-static bool is_tx_initialised(const struct c2_db_tx *tx)
-{
-	return tx->dt_env != 0;
-}
-
-/**
- * Aborts db transaction, if fom execution failed.
- * If fom executions fails before even the transaction
- * is initialised, we don't need to abort any transaction.
- */
-static int fom_txn_abort(struct c2_fom *fom)
-{
-	int rc;
-
-	if (is_tx_initialised(&fom->fo_tx.tx_dbtx)) {
-		rc = c2_db_tx_abort(&fom->fo_tx.tx_dbtx);
-		if (rc != 0)
-			fom->fo_rc = rc;
-	}
-
-	return FSO_AGAIN;
-}
-
-/**
- * Resumes fom execution after completing a blocking operation
- * in FOPH_TXN_ABORT phase.
- */
-static int fom_txn_abort_wait(struct c2_fom *fom)
-{
-	return FSO_AGAIN;
-}
-
-/**
- * Posts reply fop, if the fom execution was done locally,
- * reply fop is cached until the changes are integrated
- * with the server.
- *
- * @pre fom->fo_rep_fop != NULL
- *
- * @todo Implement write back cache, during which we may
- *	perform updations on local objects and re integrate
- *	with the server later, in that case we may block while,
-	we caching fop, this requires more additions to the routine.
- */
-static int fom_queue_reply(struct c2_fom *fom)
-{
-	struct c2_rpc_item *item;
-
-	C2_PRE(fom->fo_rep_fop != NULL);
-
-        item = c2_fop_to_rpc_item(fom->fo_rep_fop);
-        c2_rpc_reply_post(&fom->fo_fop->f_item, item);
-
-	return FSO_AGAIN;
-}
-
-/**
- * Resumes fom execution after completing a blocking operation
- * in FOPH_QUEUE_REPLY phase.
- */
-static int fom_queue_reply_wait(struct c2_fom *fom)
-{
-	return FSO_AGAIN;
-}
-
-static int fom_timeout(struct c2_fom *fom)
-{
-	return FSO_AGAIN;
-}
-
-/**
- * Fom phase operations table, this defines a fom_phase_ops object
- * for every generic phase of the fom, containing a function pointer
- * to the phase handler, the next phase fom should transition into
- * and a phase name in user visible format inorder to log addb event.
- *
- * @see struct fom_phase_ops
- */
-static const struct fom_phase_ops fpo_table[] = {
-	[FOPH_INIT] =			   { &fom_phase_init,
-					      FOPH_AUTHENTICATE,
-					     "fom_init",
-					      1 << FOPH_INIT },
-	[FOPH_AUTHENTICATE] =		   { &fom_authen,
-					      FOPH_RESOURCE_LOCAL,
-					     "fom_authen",
-				              1 << FOPH_AUTHENTICATE },
-	[FOPH_AUTHENTICATE_WAIT] =         { &fom_authen_wait,
-				              FOPH_RESOURCE_LOCAL,
-					     "fom_authen_wait",
-					     1 << FOPH_AUTHENTICATE_WAIT},
-	[FOPH_RESOURCE_LOCAL] =		   { &fom_loc_resource,
-					      FOPH_RESOURCE_DISTRIBUTED,
-					     "fom_loc_resource",
-					      1 << FOPH_RESOURCE_LOCAL },
-	[FOPH_RESOURCE_LOCAL_WAIT] =	   { &fom_loc_resource_wait,
-					      FOPH_RESOURCE_DISTRIBUTED,
-					     "fom_loc_resource_wait",
-				              1 << FOPH_RESOURCE_LOCAL_WAIT },
-	[FOPH_RESOURCE_DISTRIBUTED] =	   { &fom_dist_resource,
-					      FOPH_OBJECT_CHECK,
-					     "fom_dist_resource",
-					      1 << FOPH_RESOURCE_DISTRIBUTED },
-	[FOPH_RESOURCE_DISTRIBUTED_WAIT] = { &fom_dist_resource_wait,
-					      FOPH_OBJECT_CHECK,
-					     "fom_dist_resource_wait",
-					      1 << FOPH_RESOURCE_DISTRIBUTED_WAIT },
-	[FOPH_OBJECT_CHECK] =		   { &fom_obj_check,
-					      FOPH_AUTHORISATION,
-					     "fom_obj_check",
-					      1 << FOPH_OBJECT_CHECK },
-	[FOPH_OBJECT_CHECK_WAIT] =	   { &fom_obj_check_wait,
-					      FOPH_AUTHORISATION,
-					     "fom_obj_check_wait",
-					      1 << FOPH_OBJECT_CHECK_WAIT },
-	[FOPH_AUTHORISATION] =		   { &fom_auth,
-					      FOPH_TXN_CONTEXT,
-					     "fom_auth",
-					      1 << FOPH_AUTHORISATION },
-	[FOPH_AUTHORISATION_WAIT] =	   { &fom_auth_wait,
-					      FOPH_TXN_CONTEXT,
-					     "fom_auth_wait",
-					      1 << FOPH_AUTHORISATION_WAIT },
-	[FOPH_TXN_CONTEXT] =		   { &create_loc_ctx,
-					      FOPH_NR+1,
-					     "create_loc_ctx",
-					      1 << FOPH_TXN_CONTEXT },
-	[FOPH_TXN_CONTEXT_WAIT] =	   { &create_loc_ctx_wait,
-					      FOPH_NR+1,
-					     "create_loc_ctx_wait",
-					      1 << FOPH_TXN_CONTEXT_WAIT },
-	[FOPH_SUCCESS] =		   { &fom_success,
-					      FOPH_TXN_COMMIT,
-					     "fom_success",
-					      1 << FOPH_SUCCESS },
-	[FOPH_TXN_COMMIT] =		   { &fom_txn_commit,
-					      FOPH_QUEUE_REPLY,
-					     "fom_txn_commit",
-					      1 << FOPH_TXN_COMMIT },
-	[FOPH_TXN_COMMIT_WAIT] =	   { &fom_txn_commit_wait,
-					      FOPH_QUEUE_REPLY,
-					     "fom_txn_commit_wait",
-					      1 << FOPH_TXN_COMMIT_WAIT },
-	[FOPH_TIMEOUT] =		   { &fom_timeout,
-					      FOPH_FAILURE,
-					     "fom_timeout",
-					      1 << FOPH_TIMEOUT },
-	[FOPH_FAILURE] =		   { &fom_failure,
-					      FOPH_TXN_ABORT,
-					     "fom_failure",
-					      1 << FOPH_FAILURE },
-	[FOPH_TXN_ABORT] =		   { &fom_txn_abort,
-					      FOPH_QUEUE_REPLY,
-					     "fom_txn_abort",
-					      1 << FOPH_TXN_ABORT },
-	[FOPH_TXN_ABORT_WAIT] =		   { &fom_txn_abort_wait,
-					      FOPH_QUEUE_REPLY,
-					     "fom_txn_abort_wait",
-					      1 << FOPH_TXN_ABORT_WAIT },
-	[FOPH_QUEUE_REPLY] =		   { &fom_queue_reply,
-					      FOPH_FINISH,
-					     "fom_queue_reply",
-					      1 << FOPH_QUEUE_REPLY },
-	[FOPH_QUEUE_REPLY_WAIT] =	   { &fom_queue_reply_wait,
-					      FOPH_FINISH,
-					     "fom_queue_reply_wait",
-					      1 << FOPH_QUEUE_REPLY_WAIT }
-};
-
-int c2_fom_state_generic(struct c2_fom *fom)
-{
-	int			    rc;
-	const struct fom_phase_ops *fpo_phase;
-
-	C2_PRE(IS_IN_ARRAY(fom->fo_phase, fpo_table));
-
-	fpo_phase = &fpo_table[fom->fo_phase];
-
-	C2_ASSERT(fpo_phase->fpo_pre_phase == 0 ||
-			(fpo_phase->fpo_pre_phase & (1 << fom->fo_phase)));
-
-	rc = fpo_phase->fpo_action(fom);
-
-	if (rc == FSO_AGAIN) {
-		if (fom->fo_rc != 0 && fom->fo_phase < FOPH_FAILURE) {
-			fom->fo_phase = FOPH_FAILURE;
-			REQH_GEN_ADDB_ADD(c2_reqh_addb_ctx,
-					fpo_phase->fpo_name, fom->fo_rc);
-		} else
-			fom->fo_phase = fpo_phase->fpo_nextphase;
-	}
-
-	if (fom->fo_phase == FOPH_FINISH)
-		rc = FSO_WAIT;
-
-	return rc;
-}
-
-/** @} endgroup reqh */
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
diff --git a/reqh/reqh_service.c b/reqh/reqh_service.c
deleted file mode 100644
index 0494495..0000000
--- a/reqh/reqh_service.c
+++ /dev/null
@@ -1,221 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Mandar Sawant <mandar_sawant@xyratex.com>
- * Original creation date: 05/08/2011
- */
-
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif
-
-#include "lib/mutex.h"
-#include "lib/errno.h"
-#include "lib/memory.h"
-#include "lib/time.h"
-#include "lib/misc.h" /* C2_SET_ARR0 */
-
-#include "reqh/reqh.h"
-#include "reqh/reqh_service.h"
-
-/**
-   @addtogroup reqh
-   @{
- */
-
-/**
-   Global list of service types.
-   Holds struct c2_reqh_service_type instances linked via
-   c2_reqh_service_type::rst_linkage.
-
-   @see struct c2_reqh_service_type
- */
-struct c2_tl c2_rstypes;
-
-/** Protects access to list c2_rstypes. */
-struct c2_mutex c2_rstypes_mutex;
-
-const struct c2_tl_descr c2_rstypes_descr = C2_TL_DESCR("reqh service types",
-                                                         struct c2_reqh_service_type,
-                                                         rst_linkage,
-                                                         rst_magic,
-                                                         C2_RHS_MAGIC,
-                                                         C2_RHS_MAGIC);
-
-extern const struct c2_tl_descr c2_rh_sl_descr;
-extern const struct c2_tl_descr c2_rh_rpml_descr;
-
-bool c2_reqh_service_invariant(const struct c2_reqh_service *service)
-{
-	if (service == NULL)
-		return false;
-
-	switch (service->rs_phase) {
-	case C2_RSPH_INITIALISING:
-		return service->rs_type != NULL && service->rs_ops != NULL &&
-                       service->rs_state == C2_RSS_UNDEFINED;
-	case C2_RSPH_INITIALISED:
-		return service->rs_type != NULL && service->rs_ops != NULL &&
-                       service->rs_uuid[0] != 0 && service->rs_reqh != NULL &&
-                       service->rs_magic == C2_RHS_MAGIC &&
-                       service->rs_state == C2_RSS_READY;
-	case C2_RSPH_STARTING:
-		return service->rs_type != NULL && service->rs_ops != NULL &&
-                       service->rs_uuid[0] != 0 && service->rs_reqh != NULL &&
-                       service->rs_state == C2_RSS_READY &&
-                       service->rs_magic == C2_RHS_MAGIC;
-	case C2_RSPH_STARTED:
-		return service->rs_ops != NULL && service->rs_type != NULL &&
-                       service->rs_uuid[0] != 0 && service->rs_reqh != NULL &&
-                       service->rs_state == C2_RSS_RUNNING &&
-                       service->rs_magic == C2_RHS_MAGIC &&
-                       c2_tlist_contains(&c2_rh_sl_descr,
-                                         &service->rs_reqh->rh_services,
-                                                                service);
-	case C2_RSPH_STOPPING:
-		return service->rs_ops != NULL && service->rs_type != NULL &&
-                       service->rs_uuid[0] != 0 && service->rs_reqh != NULL &&
-                       service->rs_state == C2_RSS_RUNNING &&
-                       service->rs_magic == C2_RHS_MAGIC &&
-                       c2_tlist_contains(&c2_rh_sl_descr,
-                                         &service->rs_reqh->rh_services,
-                                                                service);
-	default:
-		return false;
-	}
-}
-
-struct c2_reqh_service_type *c2_reqh_service_type_find(const char *sname)
-{
-	struct c2_reqh_service_type *stype;
-
-	C2_PRE(sname != NULL);
-
-        c2_tlist_for(&c2_rstypes_descr, &c2_rstypes, stype) {
-                if (strcmp(stype->rst_name, sname) == 0)
-                        return stype;
-        } c2_tlist_endfor;
-
-        return NULL;
-}
-
-int c2_reqh_service_start(struct c2_reqh_service *service)
-{
-
-	C2_PRE(service != NULL);
-
-	C2_ASSERT(c2_reqh_service_invariant(service));
-
-	/* Adds service to reqh's service list */
-        c2_tlist_add_tail(&c2_rh_sl_descr, &service->rs_reqh->rh_services,
-								service);
-	service->rs_phase = C2_RSPH_STARTED;
-	service->rs_state = C2_RSS_RUNNING;
-	C2_POST(c2_reqh_service_invariant(service));
-
-	return 0;
-}
-
-void c2_reqh_service_stop(struct c2_reqh_service *service)
-{
-	C2_ASSERT(c2_reqh_service_invariant(service));
-
-	c2_tlist_del(&c2_rh_sl_descr, service);
-	service->rs_phase = C2_RSPH_STOPPED;
-	service->rs_state = C2_RSS_STOPPED;
-}
-
-int c2_reqh_service_init(struct c2_reqh_service *service, struct c2_reqh *reqh)
-{
-	const char *sname;
-
-	C2_PRE(service != NULL && reqh != NULL &&
-		service->rs_state == C2_RSS_UNDEFINED &&
-		service->rs_phase == C2_RSPH_INITIALISING);
-
-	/*
-	   Generating service uuid with service name and timestamp.
-	 */
-	C2_SET_ARR0(service->rs_uuid);
-	sname = service->rs_type->rst_name;
-	snprintf(service->rs_uuid, C2_REQH_SERVICE_UUID_SIZE, "%s:%lu", sname,
-								c2_time_now());
-
-	service->rs_magic = C2_RHS_MAGIC;
-	service->rs_phase = C2_RSPH_INITIALISED;
-	service->rs_state = C2_RSS_READY;
-	service->rs_reqh  = reqh;
-	c2_tlink_init(&c2_rh_sl_descr, service);
-	c2_mutex_init(&service->rs_mutex);
-	C2_POST(c2_reqh_service_invariant(service));
-
-	return 0;
-}
-
-void c2_reqh_service_fini(struct c2_reqh_service *service)
-{
-	C2_PRE(service != NULL && (service->rs_phase == C2_RSPH_STOPPED ||
-				service->rs_phase == C2_RSPH_FAILED));
-
-	c2_tlink_fini(&c2_rh_sl_descr, service);
-}
-
-int c2_reqh_service_type_register(struct c2_reqh_service_type *rstype)
-{
-        C2_PRE(rstype != NULL && rstype->rst_magic == C2_RHS_MAGIC);
-
-        c2_tlink_init(&c2_rstypes_descr, rstype);
-        c2_mutex_lock(&c2_rstypes_mutex);
-        c2_tlist_add_tail(&c2_rstypes_descr, &c2_rstypes, rstype);
-        c2_mutex_unlock(&c2_rstypes_mutex);
-
-	return 0;
-}
-
-void c2_reqh_service_type_unregister(struct c2_reqh_service_type *rstype)
-{
-	C2_PRE(rstype != NULL);
-
-	c2_tlist_del(&c2_rstypes_descr, rstype);
-	c2_tlink_fini(&c2_rstypes_descr, rstype);
-}
-
-int c2_reqh_service_types_init(void)
-{
-	c2_tlist_init(&c2_rstypes_descr, &c2_rstypes);
-	c2_mutex_init(&c2_rstypes_mutex);
-
-	return 0;
-}
-
-void c2_reqh_service_types_fini(void)
-{
-	c2_tlist_fini(&c2_rstypes_descr, &c2_rstypes);
-	c2_mutex_fini(&c2_rstypes_mutex);
-}
-
-/** @} endgroup reqh */
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
-
diff --git a/reqh/reqh_service.h b/reqh/reqh_service.h
deleted file mode 100644
index b9b5d5c..0000000
--- a/reqh/reqh_service.h
+++ /dev/null
@@ -1,515 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Mandar Sawant <mandar_sawant@xyratex.com>
- * Original creation date: 05/08/2011
- */
-
-#ifndef __COLIBRI_REQH_REQH_SERVICE_H__
-#define __COLIBRI_REQH_REQH_SERVICE_H__
-
-#include "lib/list.h"
-#include "net/net.h"
-#include "rpc/rpc2.h"
-
-/**
-   @addtogroup reqh
-
-   A colibri service is described to a request handler using a struct
-   c2_reqh_service_type data structure.
-   Every service should register its corresponding c2_reqh_service_type
-   instance containing service specific initialisation method, service
-   name. A c2_reqh_service_type instance can be declared using
-   C2_REQH_SERVICE_TYPE_DECLARE macro. Once the service type is declared
-   it should be registered using c2_reqh_service_type_register() and
-   unregister using c2_reqh_service_type_unregister().
-   During service type registration, the service type is added to the global
-   list of the service types maintained by the request handler module.
-   The request handler creates and initialises a service by invoking the
-   constructor method of its service type, and obtains struct c2_reqh_service
-   instance.The constructor should perform only internal house keeping tasks.
-   Next, the service start method is invoked, it should properly initialise the
-   internal state of the service, e.g. service fops. &tc.
-
-   Request handler creates an rpcmachine for each specified end point per
-   network domain. There could be multiple rpc machines running within a single
-   request handler, resulting in the associated services being reachable through
-   all of these end points.
-
-   Services need to be registered before they can be started. Service
-   registration can be done as below,
-
-   First, we have to define service type operations,
-   @code
-   static const struct c2_reqh_service_type_ops dummy_service_type_ops = {
-        .rsto_service_alloc_and_init = dummy_service_alloc_init
-   };
-   @endcode
-
-   - then define service operations,
-   @code
-   const struct c2_reqh_service_ops dummy_service_ops = {
-        .rso_start = dummy_service_start,
-        .rso_stop = dummy_service_stop,
-        .rso_fini = dummy_service_fini
-   };
-   @endcode
-
-   Typical service specific start and stop operations may look like below,
-   @code
-   static int dummy_service_start(struct c2_reqh_service *service)
-   {
-        ...
-        rc = dummy_fops_init();
-	...
-   }
-
-   static int dummy_service_stop(struct c2_reqh_service *service)
-   {
-	...
-        dummy_fops_fini();
-	...
-   }
-   @endcode
-
-   - declare service type using C2_REQH_SERVICE_TYPE_DECLARE macro,
-   @code
-   C2_REQH_SERVICE_TYPE_DECLARE(dummy_service_type, &dummy_service_type_ops,
-                                                                     "dummy");
-   @endcode
-
-   - now, the above service type can be registered as below,
-   @code
-   c2_reqh_service_type_register(&dummy_service_type);
-   @endcode
-
-   - unregister service using c2_reqh_service_type_unregister().
-
-   A typical service transitions through its phases as below,
-   @verbatim
-
-     cs_service_init()
-          |
-          v                 allocated
-     rsto_service_alloc_and_init()+---->C2_RSPH_INITIALISING
-                                            |rs_state = C2_RSS_UNDEFINED
-                                            | c2_reqh_service_init()
-                                            v
-                                        C2_RSPH_INITIALISED
-                                            | rs_state = C2_RSS_READY
-                                            | rso_start()
-                    start up failed         v
-        +------------------------------+C2_RSPH_STARTING
-        |              rc != 0              |
-	|                                   | c2_reqh_service_start()
-        v                                   v
-   C2_RSPH_FAILED                          C2_RSPH_STARTED
-        |                                   | rs_state = C2_RSS_RUNNING
-        v                                   | rso_stop()
-    rso_fini()                              v
-        ^                               C2_RSPH_STOPPING
-        |                                   |
-        |                                   | c2_reqh_service_stop()
-        |     c2_reqh_service_fini()        v rs_state = C2_RSS_STOPPED
-	+------------------------------+C2_RSPH_STOPPED
-
-   @endverbatim
-
-   @{
- */
-
-enum {
-	C2_REQH_SERVICE_UUID_SIZE = 64,
-};
-
-/**
-   Magic for reqh service
- */
-enum {
-	/** Hex value for "reqhsvcs" */
-	C2_RHS_MAGIC = 0x7265716873766373
-};
-
-/**
-   Phases through which a service typically passes.
- */
-enum c2_reqh_service_phase {
-	/**
-	   A service is in C2_RSPH_INITIALISING state when it is allocated
-	   in service specific start routine, once the service specific
-	   initialisation is complete, generic c2_reqh_service_init() is invoked.
-	 */
-	C2_RSPH_INITIALISING,
-	/**
-	   A service transitions to C2_RSPH_INITIALISED state, once it is
-	   successfully initialised by the generic service c2_reqh_service_init()
-	   routine.
-
-	   @see c2_reqh_service_type_ops
-	 */
-	C2_RSPH_INITIALISED,
-	/**
-	   A service transitions to C2_RSPH_STARTING phase before service
-	   specific start routine is invoked from cs_service_init() while
-	   configuring a service during colibri setup.
-
-	   @see struct c2_reqh_service_ops
-	 */
-	C2_RSPH_STARTING,
-	/**
-	   A service transitions to C2_RSPH_STARTED phase after completing
-	   generic part of service start up operations by c2_reqh_service_start().
-	   once service specific start up operations are completed, generic
-	   service start routine c2_reqh_service_start() is invoked.
-
-	   @see c2_reqh_service_start()
-	 */
-	C2_RSPH_STARTED,
-	/**
-	   A service transitions to C2_RSPH_STOPPING phase before service
-	   specific stop routine is invoked from cs_service_fini().
-	   A service should be in C2_RSS_RUNNING state to proceed for
-	   finalisation.
-
-	   @see c2_reqh_service_state
-	   @see c2_reqh_service_stop()
-	 */
-	C2_RSPH_STOPPING,
-	/**
-	   A service is transitions to C2_RSPH_STOPPED phase once the
-	   generic service c2_reqh_service_stop() routine completes successfully.
-	 */
-	C2_RSPH_STOPPED,
-	/**
-	   A service transitions to C2_RSPH_FAILED phase if the service start up
-	   fails.
-	 */
-	C2_RSPH_FAILED
-};
-
-/**
-   States a service can be throughout its lifecycle.
- */
-enum c2_reqh_service_state {
-	/**
-	   A service is in C2_RSS_UNDEFINED state after its allocation and before
-	   it is initialised.
-	 */
-	C2_RSS_UNDEFINED,
-	/**
-	   A service is in C2_RSS_READY state once it is successfully initialised.
-	 */
-	C2_RSS_READY,
-	/**
-	   A service is in C2_RSS_RUNNING state once it is successfully started.
-	 */
-	C2_RSS_RUNNING,
-	/**
-	   A service is in C2_RSS_STOPPED state once it is successfully stopped.
-	 */
-	C2_RSS_STOPPED
-};
-
-/**
-   Represents a service on node.
-   Multiple services in a colibri address space share the same request handler.
-   There exist a list of services in struct c2_reqh, c2_reqh::rh_services,
-   sharing the same request handler.
-
- */
-struct c2_reqh_service {
-	/**
-	   Service id that should be unique throughout the cluster.
-	   Currently generating service uuid using the service name and local
-	   time stamp.
-	 */
-	char                              rs_uuid[C2_REQH_SERVICE_UUID_SIZE];
-
-	/**
-	   Service type specific structure to hold service specific
-	   implementations of its operations.
-	   This can be used to initialise service specific objects such as fops.
-	 */
-	struct c2_reqh_service_type      *rs_type;
-
-	/**
-	   Current phase of a service.
-
-	   @see c2_reqh_service_phase
-	 */
-	enum c2_reqh_service_phase        rs_phase;
-
-	/**
-	   Current state of a service.
-
-	   @see c2_reqh_service_state
-	 */
-	enum c2_reqh_service_state        rs_state;
-
-	/**
-	   Protects service state transitions.
-	 */
-	struct c2_mutex                   rs_mutex;
-
-	/**
-	   Service specific operations vector.
-	 */
-	const struct c2_reqh_service_ops *rs_ops;
-
-	/**
-	   Request handler this service belongs to.
-	 */
-	struct c2_reqh                   *rs_reqh;
-
-	/**
-	   Linkage into list of services in request handler.
-
-	   @see c2_reqh::rh_services
-	 */
-	struct c2_tlink                   rs_linkage;
-
-	/**
-	   Service magic to check consistency of service instance.
-	 */
-	uint64_t                          rs_magic;
-};
-
-/**
-   Service specific operations vector.
- */
-struct c2_reqh_service_ops {
-	/**
-	   Performs service specific startup operations.
-	   Once started, incoming requests related to this service are ready
-	   to be processed by the corresponding request handler.
-	   Service startup can involve operations like initialising service
-	   specific fops, &tc which may fail due to whichever reason, in that
-	   case the service is finalised and appropriate error is returned.
-	   Once the service specific startup operations are performed, the
-	   service is added to the request handler's list of services by
-	   the generic c2_reqh_service_start() routine invoked after this
-	   routine returns successfully.
-
-	   @param service Service to be started
-
-	   @see c2_reqh_service_start()
-	 */
-	int (*rso_start)(struct c2_reqh_service *service);
-
-	/**
-	   Performs services specific finalisation of objects.
-	   Once stopped, no incoming request related to this service
-	   on a node will be processed further.
-	   Stopping a service can involve operations like finalising
-	   service specific fops, &tc.
-	   Once the service specific objects are finalised, generic
-	   c2_reqh_service_stop() routine is invoked after this routine
-	   returns successfully, this removes the service from request
-	   handler's list of services.
-
-	   @param service Service to be started
-
-	   @see c2_reqh_service_stop()
-	 */
-	void (*rso_stop)(struct c2_reqh_service *service);
-
-	/**
-	   Destroys a particular service.
-	   Firstly a generic c2_reqh_service_fini() is invoked, from
-	   colibri_setup service finalisation routine, which performs
-	   generic part of service finalisation and then follows the
-	   service specific finalisation.
-
-	   @param service Service to be finalised
-
-	   @see cs_service_fini()
-	   @see c2_reqh_service_fini()
-	 */
-	void (*rso_fini)(struct c2_reqh_service *service);
-};
-
-/**
-   Service type operations vector.
- */
-struct c2_reqh_service_type_ops {
-	/**
-	   Contructs a particular service.
-	   Allocates and initialises a service with the given service type and
-	   corresponding service operations vector. This is invoked during
-	   colibri startup to configure a particular service. Once the service
-	   specific initialisation is done, generic c2_reqh_service_init()
-	   routine is invoked after this routine returns successfully.
-
-	   @param service Service to be allocated and initialised
-	   @param stype Type of service to be initialised
-
-	   @see c2_reqh_service_init()
-	 */
-	int (*rsto_service_alloc_and_init)(struct c2_reqh_service_type *stype,
-					struct c2_reqh_service **service);
-};
-
-/**
-   Represents a particular service type.
-   A c2_reqh_service_type instance is initialised and registered into a global
-   list of service types as a part of corresponding module initiasation process.
-
-   @see c2_reqh_service_type_init()
- */
-struct c2_reqh_service_type {
-	const char		              *rst_name;
-
-	/** Service type operations.*/
-	const struct c2_reqh_service_type_ops *rst_ops;
-
-	/**
-	    Linkage into global service types list.
-
-	    @see c2_rstypes
-	 */
-	struct c2_tlink                        rst_linkage;
-	uint64_t                               rst_magic;
-};
-
-/**
-   Locates a particular type of service by traversing global list of service
-   types maintained by request handler module.
-
-   @param sname, name of the service to be searched in global list
-
-   @pre sname != NULL
-
-   @see c2_reqh_service_init()
-
- */
-struct c2_reqh_service_type *c2_reqh_service_type_find(const char *sname);
-
-/**
-   Starts a particular service.
-   Registers a service with the request handler and transitions the service
-   into C2_RSPH_STARTED phase and changes service state to C2_RSS_RUNNING.
-   This is invoked after service specific start routine returns successfully.
-
-   @param service Service to be started
-
-   @pre service != NULL
-
-   @see struct c2_reqh_service_ops
-   @see c2_service_init()
-
-   @post c2_reqh_service_invariant(service)
- */
-int c2_reqh_service_start(struct c2_reqh_service *service);
-
-/**
-   Stops a particular service.
-   Unregisters a service from the request handler and transitions service to
-   C2_RSPH_STOPPED phase and state is changed to C2_RSS_STOPPED.
-   This is invoked after service specific stop routine returns successfully.
-
-   @param service Service to be stopped
-
-   @pre service != NULL
-
-   @see struct c2_reqh_service_ops
-   @see cs_service_fini()
- */
-void c2_reqh_service_stop(struct c2_reqh_service *service);
-
-/**
-   Performs generic part of service initialisation.
-   Transitions service into C2_RSPH_INITIALISED phase and changes service state to
-   C2_RSS_READY.
-   This is invoked after the service specific init routine returns successfully.
-
-   @param service service to be initialised
-
-   @pre service != NULL && reqh != NULL && service->rs_state == C2_RSS_UNDEFINED &&
-	service->rs_phase == C2_RSPH_INITIALISING
-
-   @see struct c2_reqh_service_type_ops
-   @see cs_service_init()
- */
-int c2_reqh_service_init(struct c2_reqh_service *service, struct c2_reqh *reqh);
-
-/**
-   Performs generic part of service finalisation.
-   This is invoked before service specific finalisation routine.
-
-   @param service Service to be finalised
-
-   @pre service != NULL && service->rs_phase == C2_RSPH_STOPPED &&
-        service->rs_state == C2_RSS_STOPPED
-
-   @see struct c2_reqh_service_ops
-   @see cs_service_fini()
- */
-void c2_reqh_service_fini(struct c2_reqh_service *service);
-
-#define C2_REQH_SERVICE_TYPE_DECLARE(stype, ops, name) \
-struct c2_reqh_service_type stype = {                  \
-        .rst_name  = (name),	                       \
-	.rst_ops   = (ops),                            \
-	.rst_magic = (C2_RHS_MAGIC)                    \
-}                                                     \
-
-/**
-   Registers a service type in a global service types list,
-   i.e. rstypes.
-
-   @pre rstype != NULL && rstype->rst_magic == C2_RHS_MAGIC
- */
-int c2_reqh_service_type_register(struct c2_reqh_service_type *rstype);
-
-/**
-   Unregisters a service type from a global service types list, i.e. rstypes.
-
-   @pre rstype != NULL
- */
-void c2_reqh_service_type_unregister(struct c2_reqh_service_type *rstype);
-
-/**
-   Initialises global list of service types.
-   This is invoked from c2_reqhs_init().
- */
-int c2_reqh_service_types_init();
-
-/**
-   Finalises global list of service types.
-   This is invoked from c2_reqhs_fini();
- */
-void c2_reqh_service_types_fini();
-
-/**
-   Checks consistency of a particular service.
- */
-bool c2_reqh_service_invariant(const struct c2_reqh_service *service);
-
-/** @} endgroup reqh */
-
-/* __COLIBRI_REQH_REQH_SERVICE_H__ */
-
-#endif
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
diff --git a/reqh/ut/.gitignore b/reqh/ut/.gitignore
deleted file mode 100644
index 9e2d572..0000000
--- a/reqh/ut/.gitignore
+++ /dev/null
@@ -1,2 +0,0 @@
-fom_io_u.c
-fom_io_u.h
diff --git a/reqh/ut/Makefile.am b/reqh/ut/Makefile.am
deleted file mode 100644
index 5dd0f97..0000000
--- a/reqh/ut/Makefile.am
+++ /dev/null
@@ -1,5 +0,0 @@
-noinst_LTLIBRARIES      = libreqh-ut.la
-libreqh_ut_la_SOURCES   = reqh_fom_ut.c
-
-INCLUDES                = -I. -I$(top_srcdir)/include -I$(top_srcdir)
-
diff --git a/reqh/ut/reqh_fom_ut.c b/reqh/ut/reqh_fom_ut.c
deleted file mode 100644
index ce96145..0000000
--- a/reqh/ut/reqh_fom_ut.c
+++ /dev/null
@@ -1,458 +0,0 @@
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Mandar Sawant <Mandar_Sawant@xyratex.com>
- * Original creation date: 05/04/2011
- */
-
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <sys/stat.h>	/* mkdir */
-#include <sys/types.h>	/* mkdir */
-#include <err.h>
-
-#include "lib/ut.h"
-#include "lib/misc.h"
-#include "lib/errno.h"
-#include "lib/assert.h"
-#include "lib/memory.h"
-#include "lib/chan.h"
-#include "lib/processor.h"
-#include "lib/list.h"
-
-#include "colibri/init.h"
-#include "net/net.h"
-#include "fop/fop.h"
-#include "reqh/reqh.h"
-#include "fop/fom.h"
-#include "fop/fop_iterator.h"
-#include "stob/stob.h"
-#include "stob/ad.h"
-#include "stob/linux.h"
-#include "net/bulk_sunrpc.h"
-#include "rpc/rpc2.h"
-#include "fop/fop_item_type.h"
-#include "rpc/rpc_base.h"
-#include "xcode/bufvec_xcode.h"
-
-#include "fop/fop_format_def.h"
-
-#ifdef __KERNEL__
-#include "reqh/reqh_fops_k.h"
-#include "stob/io_fop_k.h"
-#else
-#include "reqh/reqh_fops_u.h"
-#include "stob/io_fop_u.h"
-#endif
-
-#include "stob/io_fop.h"
-#include "reqh/reqh_fops.ff"
-#include "rpc/rpc_opcodes.h"
-#include "rpc/rpclib.h"
-#include "ut/rpc.h"
-#include "balloc/balloc.h"
-
-/**
-   @addtogroup reqh
-   @{
- */
-
-/**
- *  Server side structures and objects
- */
-
-#define CLIENT_ENDPOINT_ADDR	"127.0.0.1:21435:1"
-#define SERVER_ENDPOINT_ADDR	"127.0.0.1:21435:2"
-#define CLIENT_DB_NAME		"reqh_ut_stob/cdb"
-#define SERVER_DB_NAME		"reqh_ut_stob/sdb"
-
-enum {
-	CLIENT_COB_DOM_ID	= 101,
-	SESSION_SLOTS		= 5,
-	MAX_RPCS_IN_FLIGHT	= 32,
-	CONNECT_TIMEOUT		= 5,
-};
-
-static struct c2_stob_domain   *sdom;
-static struct c2_cob_domain    srv_cob_domain;
-static struct c2_cob_domain_id srv_cob_dom_id;
-static struct c2_rpcmachine    srv_rpc_mach;
-static struct c2_dbenv         srv_db;
-static struct c2_fol           srv_fol;
-
-/**
- * Global reqh object
- */
-static struct c2_reqh  reqh;
-
-/**
- * Helper structures and functions for ad stob.
- * These are used while performing a stob operation.
- */
-struct reqh_ut_balloc {
-	struct c2_mutex  rb_lock;
-	c2_bindex_t      rb_next;
-	struct ad_balloc rb_ballroom;
-};
-
-static struct reqh_ut_balloc *getballoc(struct ad_balloc *ballroom)
-{
-	return container_of(ballroom, struct reqh_ut_balloc, rb_ballroom);
-}
-
-static int reqh_ut_balloc_init(struct ad_balloc *ballroom, struct c2_dbenv *db,
-			       uint32_t bshift, c2_bindex_t container_size,
-			       c2_bcount_t groupsize, c2_bcount_t res_groups)
-{
-	struct reqh_ut_balloc *rb = getballoc(ballroom);
-
-	c2_mutex_init(&rb->rb_lock);
-	return 0;
-}
-
-static void reqh_ut_balloc_fini(struct ad_balloc *ballroom)
-{
-	struct reqh_ut_balloc *rb = getballoc(ballroom);
-
-	c2_mutex_fini(&rb->rb_lock);
-}
-
-static int reqh_ut_balloc_alloc(struct ad_balloc *ballroom, struct c2_dtx *tx,
-                             c2_bcount_t count, struct c2_ext *out)
-{
-	struct reqh_ut_balloc	*rb = getballoc(ballroom);
-
-	c2_mutex_lock(&rb->rb_lock);
-	out->e_start = rb->rb_next;
-	out->e_end   = rb->rb_next + count;
-	rb->rb_next += count;
-	c2_mutex_unlock(&rb->rb_lock);
-	return 0;
-}
-
-static int reqh_ut_balloc_free(struct ad_balloc *ballroom, struct c2_dtx *tx,
-                            struct c2_ext *ext)
-{
-	return 0;
-}
-
-static const struct ad_balloc_ops reqh_ut_balloc_ops = {
-	.bo_init  = reqh_ut_balloc_init,
-	.bo_fini  = reqh_ut_balloc_fini,
-	.bo_alloc = reqh_ut_balloc_alloc,
-	.bo_free  = reqh_ut_balloc_free,
-};
-
-static struct reqh_ut_balloc rb = {
-	.rb_next = 0,
-	.rb_ballroom = {
-		.ab_ops = &reqh_ut_balloc_ops
-	}
-};
-
-static int server_init(const char *stob_path, const char *srv_db_name,
-			struct c2_net_domain *net_dom, struct c2_stob_id *backid,
-			struct c2_stob_domain **bdom, struct c2_stob **bstore,
-			struct c2_stob **reqh_addb_stob,
-			struct c2_stob_id *rh_addb_stob_id)
-{
-        int                        rc;
-	struct c2_net_transfer_mc *srv_tm;
-
-        srv_cob_dom_id.id = 102;
-
-        /* Init the db */
-        rc = c2_dbenv_init(&srv_db, srv_db_name, 0);
-	C2_UT_ASSERT(rc == 0);
-
-	rc = c2_fol_init(&srv_fol, &srv_db);
-	C2_UT_ASSERT(rc == 0);
-
-	/*
-	 * Locate and create (if necessary) the backing store object.
-	 */
-
-	rc = linux_stob_type.st_op->sto_domain_locate(&linux_stob_type,
-							  stob_path, bdom);
-	C2_UT_ASSERT(rc == 0);
-
-	rc = (*bdom)->sd_ops->sdo_stob_find(*bdom, backid, bstore);
-	C2_UT_ASSERT(rc == 0);
-	C2_UT_ASSERT((*bstore)->so_state == CSS_UNKNOWN);
-
-	rc = c2_stob_create(*bstore, NULL);
-	C2_UT_ASSERT(rc == 0);
-	C2_UT_ASSERT((*bstore)->so_state == CSS_EXISTS);
-
-	/*
-	 * Create AD domain over backing store object.
-	 */
-	rc = ad_stob_type.st_op->sto_domain_locate(&ad_stob_type, "", &sdom);
-	C2_UT_ASSERT(rc == 0);
-
-	rc = c2_ad_stob_setup(sdom, &srv_db, *bstore, &rb.rb_ballroom,
-			      BALLOC_DEF_CONTAINER_SIZE, BALLOC_DEF_BLOCK_SHIFT,
-			      BALLOC_DEF_BLOCKS_PER_GROUP,
-			      BALLOC_DEF_RESERVED_GROUPS);
-	C2_UT_ASSERT(rc == 0);
-
-	c2_stob_put(*bstore);
-
-	/* Create or open a stob into which to store the record. */
-	rc = (*bdom)->sd_ops->sdo_stob_find(*bdom, rh_addb_stob_id, reqh_addb_stob);
-	C2_UT_ASSERT(rc == 0);
-	C2_UT_ASSERT((*reqh_addb_stob)->so_state == CSS_UNKNOWN);
-
-	rc = c2_stob_create(*reqh_addb_stob, NULL);
-	C2_UT_ASSERT(rc == 0);
-	C2_UT_ASSERT((*reqh_addb_stob)->so_state == CSS_EXISTS);
-
-	/* Write addb record into stob */
-	c2_addb_choose_store_media(C2_ADDB_REC_STORE_STOB, c2_addb_stob_add,
-					  *reqh_addb_stob, NULL);
-
-        /* Init the cob domain */
-        rc = c2_cob_domain_init(&srv_cob_domain, &srv_db,
-                        &srv_cob_dom_id);
-        C2_UT_ASSERT(rc == 0);
-
-	/* Initialising request handler */
-	rc =  c2_reqh_init(&reqh, NULL, sdom, &srv_db, &srv_cob_domain, &srv_fol);
-	C2_UT_ASSERT(rc == 0);
-
-        /* Init the rpcmachine */
-        rc = c2_rpcmachine_init(&srv_rpc_mach, &srv_cob_domain, net_dom,
-				SERVER_ENDPOINT_ADDR, &reqh);
-        C2_UT_ASSERT(rc == 0);
-
-        /* Find first c2_rpc_chan from the chan's list
-           and use its corresponding tm to create target end_point */
-        srv_tm = &srv_rpc_mach.cr_tm;
-	C2_UT_ASSERT(srv_tm != NULL);
-
-	return rc;
-}
-
-/* Fini the server */
-static void server_fini(struct c2_stob_domain *bdom,
-		struct c2_stob *reqh_addb_stob)
-{
-        /* Fini the rpcmachine */
-        c2_rpcmachine_fini(&srv_rpc_mach);
-
-        /* Fini the cob domain */
-        c2_cob_domain_fini(&srv_cob_domain);
-
-	c2_addb_choose_store_media(C2_ADDB_REC_STORE_NONE);
-	c2_stob_put(reqh_addb_stob);
-
-	c2_reqh_fini(&reqh);
-	C2_UT_ASSERT(sdom != NULL);
-	sdom->sd_ops->sdo_fini(sdom);
-	bdom->sd_ops->sdo_fini(bdom);
-	c2_fol_fini(&srv_fol);
-	c2_dbenv_fini(&srv_db);
-}
-
-/**
- * Sends create fop request.
- */
-static void create_send(struct c2_rpc_session *session)
-{
-	int                      rc;
-	uint32_t                 i;
-	struct c2_fop            *fop;
-	struct c2_stob_io_create *rh_io_fop;
-
-	for (i = 0; i < 10; ++i) {
-		fop = c2_fop_alloc(&c2_stob_io_create_fopt, NULL);
-		rh_io_fop = c2_fop_data(fop);
-		rh_io_fop->fic_object.f_seq = i;
-		rh_io_fop->fic_object.f_oid = i;
-
-		rc = c2_rpc_client_call(fop, session, &c2_fop_default_item_ops,
-						CONNECT_TIMEOUT);
-		C2_UT_ASSERT(rc == 0);
-		C2_UT_ASSERT(fop->f_item.ri_error == 0);
-		C2_UT_ASSERT(fop->f_item.ri_reply != 0);
-	}
-}
-
-/**
- * Sends read fop request.
- */
-static void read_send(struct c2_rpc_session *session)
-{
-	int                     rc;
-	uint32_t                i;
-	struct c2_fop           *fop;
-	struct c2_stob_io_read  *rh_io_fop;
-
-	for (i = 0; i < 10; ++i) {
-		fop = c2_fop_alloc(&c2_stob_io_read_fopt, NULL);
-		rh_io_fop = c2_fop_data(fop);
-		rh_io_fop->fir_object.f_seq = i;
-		rh_io_fop->fir_object.f_oid = i;
-
-		rc = c2_rpc_client_call(fop, session, &c2_fop_default_item_ops,
-						CONNECT_TIMEOUT);
-		C2_UT_ASSERT(rc == 0);
-		C2_UT_ASSERT(fop->f_item.ri_error == 0);
-		C2_UT_ASSERT(fop->f_item.ri_reply != 0);
-	}
-}
-
-/**
- * Sends write fop request.
- */
-static void write_send(struct c2_rpc_session *session)
-{
-	int                      rc;
-	uint32_t                 i;
-	struct c2_fop            *fop;
-	struct c2_stob_io_write  *rh_io_fop;
-
-	for (i = 0; i < 10; ++i) {
-		fop = c2_fop_alloc(&c2_stob_io_write_fopt, NULL);
-		rh_io_fop = c2_fop_data(fop);
-		rh_io_fop->fiw_object.f_seq = i;
-		rh_io_fop->fiw_object.f_oid = i;
-
-		rc = c2_rpc_client_call(fop, session, &c2_fop_default_item_ops,
-						CONNECT_TIMEOUT);
-		C2_UT_ASSERT(rc == 0);
-		C2_UT_ASSERT(fop->f_item.ri_error == 0);
-		C2_UT_ASSERT(fop->f_item.ri_reply != 0);
-	}
-}
-
-/**
- * Test function for reqh ut
- */
-void test_reqh(void)
-{
-	int                    result;
-	char                   opath[64];
-	const char             *path;
-	struct c2_net_xprt     *xprt = &c2_net_bulk_sunrpc_xprt;
-	struct c2_net_domain   net_dom = { };
-	struct c2_dbenv        client_dbenv;
-	struct c2_cob_domain   client_cob_dom;
-	struct c2_stob_domain  *bdom;
-	struct c2_stob_id      backid;
-	struct c2_stob         *bstore;
-	struct c2_stob         *reqh_addb_stob;
-
-	struct c2_stob_id      reqh_addb_stob_id = {
-					.si_bits = {
-						.u_hi = 1,
-						.u_lo = 2
-					}
-				};
-
-	struct c2_rpc_client_ctx cctx = {
-		.rcx_net_dom            = &net_dom,
-		.rcx_local_addr         = CLIENT_ENDPOINT_ADDR,
-		.rcx_remote_addr        = SERVER_ENDPOINT_ADDR,
-		.rcx_db_name            = CLIENT_DB_NAME,
-		.rcx_dbenv              = &client_dbenv,
-		.rcx_cob_dom_id         = CLIENT_COB_DOM_ID,
-		.rcx_cob_dom            = &client_cob_dom,
-		.rcx_nr_slots           = SESSION_SLOTS,
-		.rcx_timeout_s          = CONNECT_TIMEOUT,
-		.rcx_max_rpcs_in_flight = MAX_RPCS_IN_FLIGHT,
-	};
-
-	backid.si_bits.u_hi = 0x0;
-	backid.si_bits.u_lo = 0xdf11e;
-
-	setbuf(stdout, NULL);
-	setbuf(stderr, NULL);
-
-	path = "reqh_ut_stob";
-
-	/* Initialize processors */
-	if (!c2_processor_is_initialized()) {
-		result = c2_processors_init();
-		C2_UT_ASSERT(result == 0);
-	}
-
-	result = c2_stob_io_fop_init();
-	C2_UT_ASSERT(result == 0);
-
-	C2_UT_ASSERT(strlen(path) < ARRAY_SIZE(opath) - 8);
-
-	result = mkdir(path, 0700);
-	C2_UT_ASSERT(result == 0 || (result == -1 && errno == EEXIST));
-	sprintf(opath, "%s/o", path);
-
-	result = mkdir(opath, 0700);
-	C2_UT_ASSERT(result == 0 || (result == -1 && errno == EEXIST));
-
-	result = c2_net_xprt_init(xprt);
-	C2_UT_ASSERT(result == 0);
-
-	result = c2_net_domain_init(&net_dom, xprt);
-	C2_UT_ASSERT(result == 0);
-
-	server_init(path, SERVER_DB_NAME, &net_dom, &backid, &bdom, &bstore,
-			&reqh_addb_stob, &reqh_addb_stob_id);
-
-	result = c2_rpc_client_init(&cctx);
-	C2_UT_ASSERT(result == 0);
-
-	/* send fops */
-	create_send(&cctx.rcx_session);
-	write_send(&cctx.rcx_session);
-	read_send(&cctx.rcx_session);
-
-	result = c2_rpc_client_fini(&cctx);
-	C2_UT_ASSERT(result == 0);
-
-	server_fini(bdom, reqh_addb_stob);
-
-	c2_net_domain_fini(&net_dom);
-	c2_net_xprt_fini(xprt);
-	c2_stob_io_fop_fini();
-
-	if (c2_processor_is_initialized())
-		c2_processors_fini();
-}
-
-const struct c2_test_suite reqh_ut = {
-	.ts_name = "reqh-ut",
-	.ts_init = NULL,
-	.ts_fini = NULL,
-	.ts_tests = {
-		{ "reqh", test_reqh },
-		{ NULL, NULL }
-	}
-};
-
-/** @} end group reqh */
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
diff --git a/rpc/.gitignore b/rpc/.gitignore
deleted file mode 100644
index 1bbb1d8..0000000
--- a/rpc/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-session_[ku].[ch]
diff --git a/rpc/Makefile.am b/rpc/Makefile.am
index 6e5c22f..c06ee95 100644
--- a/rpc/Makefile.am
+++ b/rpc/Makefile.am
@@ -1,27 +1,7 @@
-rpcdir			= $(includedir)/colibri/rpc
-rpc_HEADERS		= session.h session_fops.h session_foms.h session_internal.h rpc_opcodes.h
+noinst_LTLIBRARIES         = libcolibri-rpc.la
+libcolibri_rpc_la_SOURCES  = pcache.c pcache.h rpclib.c rpclib.h session_svc.c session_svc.h \
+                             xdr/common.c xdr/common.h xdr/session.c xdr/session.h
 
-session_u.h session_u.c session_k.h session_k.c: session.ff \
-				$(top_builddir)/fop/rt/libc2rt.la \
-				$(top_builddir)/fop/fop2c
-				$(top_builddir)/fop/fop2c -ku $<
-
-noinst_LTLIBRARIES	= libcolibri-rpc.la
-libcolibri_rpc_la_SOURCES  = session_u.h session_u.c session.c session.h \
-				session_internal.h slot.c conn.c \
-				session_utils.c \
-				session_fops.c session_fops.h \
-				session_foms.c session_foms.h \
-				rpc2.c rpc2.h rpcdbg.h \
-				rpc_base.c rpc_base.h \
-				formation.h formation.c \
-				rpc_onwire.c rpc_onwire.h \
-				rpclib.c rpclib.h rpc_opcodes.h
-
-
-INCLUDES		= -I. -I$(top_srcdir) -I$(top_srcdir)/include -I/usr/include
-EXTRA_DIST              = session.ff
-
-clean-local:
-	cd @SRCDIR@/rpc ; \
-	rm -fr session_[uk].[ch]
+EXTRA_DIST                 = compound.c compound_cli.h compound_srv.h compound_types.h rpc_ops.h \
+                             rpc_types.h session.h session_cli.c session_cli.h session_srv.c \
+                             session_srv.h session_svc.c session_svc.h session_types.h slot.h
diff --git a/rpc/compound_srv.h b/rpc/compound_srv.h
index 44bf934..42facf6 100644
--- a/rpc/compound_srv.h
+++ b/rpc/compound_srv.h
@@ -14,7 +14,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Alexey Lyashkov <Alexey_Lyashkov@xyratex.com>
+ * Original author: Alexey Lyashkov
  * Original creation date: 05/12/2010
  */
 
diff --git a/rpc/conn.c b/rpc/conn.c
deleted file mode 100644
index 6fd857d..0000000
--- a/rpc/conn.c
+++ /dev/null
@@ -1,1198 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Rohan Puri <Rohan_Puri@xyratex.com>
- *                  Amit Jambure <Amit_Jambure@xyratex.com>
- * Original creation date: 08/24/2011
- */
-
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif
-
-#include "lib/errno.h"
-#include "lib/memory.h"
-#include "lib/misc.h"
-#include "rpc/session.h"
-#include "lib/bitstring.h"
-#include "cob/cob.h"
-#include "fop/fop.h"
-#include "fop/fop_format_def.h"
-#include "lib/arith.h"
-
-#ifdef __KERNEL__
-#include "rpc/session_k.h"
-#else
-#include "rpc/session_u.h"
-#endif
-
-#include "rpc/session_internal.h"
-#include "db/db.h"
-#include "rpc/session_fops.h"
-#include "rpc/rpc2.h"
-#include "rpc/formation.h"
-
-/**
-   @addtogroup rpc_session
-
-   @{
-
-   This file implements functions related to c2_rpc_conn.
- */
-
-static const char conn_cob_name_fmt[] = "SENDER_%lu";
-
-extern struct c2_rpc_chan *rpc_chan_get(struct c2_rpcmachine *machine,
-					struct c2_net_end_point *dest_ep,
-					uint64_t max_rpcs_in_flight);
-extern void rpc_chan_put(struct c2_rpc_chan *chan);
-
-/**
-   Attaches session 0 object to conn object.
- */
-static int session_zero_attach(struct c2_rpc_conn *conn);
-
-/**
-   Detaches session 0 from conn
- */
-static void session_zero_detach(struct c2_rpc_conn *conn);
-
-/**
-   Creates "/SESSIONS/SENDER_$sender_id/SESSION_ID_0/SLOT_0:0" in cob namespace.
-   Returns corresponding references to cobs in out parameters.
- */
-static int conn_persistent_state_create(struct c2_cob_domain  *dom,
-					uint64_t              sender_id,
-					struct c2_cob       **conn_cob_out,
-					struct c2_cob       **session0_cob_out,
-					struct c2_cob       **slot0_cob_out,
-					struct c2_db_tx      *tx);
-
-/**
-   Delegates persistent state creation to conn_persistent_state_create().
-   And associates returned cobs to conn->c_cob, session0->s_cob and
-   slot0->sl_cob
- */
-static int conn_persistent_state_attach(struct c2_rpc_conn *conn,
-					uint64_t            sender_id,
-					struct c2_db_tx    *tx);
-
-/*
- * This is sender side item_ops of conn_establish fop.
- * Receiver side conn_establish fop has different item_ops
- * rcv_conn_establish_item_ops defined in rpc/session_fops.c
- */
-static const struct c2_rpc_item_ops conn_establish_item_ops = {
-	.rio_replied = c2_rpc_conn_establish_reply_received,
-	.rio_free    = c2_fop_item_free,
-};
-
-static const struct c2_rpc_item_ops conn_terminate_item_ops = {
-	.rio_replied = c2_rpc_conn_terminate_reply_received,
-	.rio_free    = c2_fop_item_free,
-};
-
-/**
-   Checks connection object invariant.
-
-   Function is also called from session_foms.c, hence cannot be static.
- */
-bool c2_rpc_conn_invariant(const struct c2_rpc_conn *conn)
-{
-	struct c2_rpc_session *session0;
-	struct c2_rpc_session *session;
-	struct c2_list        *conn_list;
-	bool                   sender_end;
-	bool                   recv_end;
-	bool                   ret;
-
-	if (conn == NULL)
-		return false;
-
-	sender_end = c2_rpc_conn_is_snd(conn);
-	recv_end = c2_rpc_conn_is_rcv(conn);
-
-	/*
-	 * conditions that should be true irrespective of conn state
-	 */
-	ret = sender_end != recv_end && c2_list_invariant(&conn->c_sessions) &&
-		conn->c_rpcmachine != NULL &&
-		c2_list_length(&conn->c_sessions) == conn->c_nr_sessions + 1;
-
-	if (!ret)
-		return ret;
-
-        /*
-         * Exactly one state bit must be set.
-         */
-        if (!c2_is_po2(conn->c_state))
-                return false;
-
-	/*
-	 * Each connection has one session with id SESSION_ID_0.
-	 * From c2_rpc_conn_init() to c2_rpc_conn_fini(), this session0 is
-	 * either in IDLE state or BUSY state.
-	 */
-	session0 = NULL;
-	c2_rpc_for_each_session(conn, session) {
-		if (session->s_session_id == SESSION_ID_0) {
-			session0 = session;
-			break;
-		}
-	}
-	if (session == NULL)
-		return false;
-
-	if (session0->s_state != C2_RPC_SESSION_IDLE &&
-	    session0->s_state != C2_RPC_SESSION_BUSY) {
-		return false;
-	}
-
-	/*
-	 * conditions that are common to CONNECTING, ACTIVE and TERMINATING
-	 * state
-	 */
-	switch (conn->c_state) {
-	case C2_RPC_CONN_CONNECTING:
-	case C2_RPC_CONN_ACTIVE:
-	case C2_RPC_CONN_TERMINATING:
-		conn_list = sender_end ?
-				&conn->c_rpcmachine->cr_outgoing_conns :
-				&conn->c_rpcmachine->cr_incoming_conns;
-		ret = c2_list_contains(conn_list, &conn->c_link) &&
-			conn->c_rc == 0;
-		if (!ret)
-			return ret;
-		break;
-	default:
-		; /* Do nothing. Just to avoid compiler warnings. */
-	}
-
-	switch (conn->c_state) {
-	case C2_RPC_CONN_INITIALISED:
-		return conn->c_sender_id == SENDER_ID_INVALID &&
-			!c2_list_link_is_in(&conn->c_link) &&
-			conn->c_nr_sessions == 0;
-
-	case C2_RPC_CONN_CONNECTING:
-		return conn->c_sender_id == SENDER_ID_INVALID &&
-			conn->c_nr_sessions == 0;
-
-	case C2_RPC_CONN_ACTIVE:
-		return conn->c_sender_id != SENDER_ID_INVALID &&
-			ergo(recv_end, conn->c_cob != NULL) &&
-			c2_rpc_session_invariant(c2_rpc_conn_session0(conn));
-
-	case C2_RPC_CONN_TERMINATING:
-		return conn->c_nr_sessions == 0 &&
-			conn->c_sender_id != SENDER_ID_INVALID;
-
-	case C2_RPC_CONN_TERMINATED:
-		return !c2_list_link_is_in(&conn->c_link) &&
-			conn->c_nr_sessions == 0 &&
-			conn->c_cob == NULL &&
-			conn->c_rc == 0;
-
-	case C2_RPC_CONN_FAILED:
-		return conn->c_rc != 0 &&
-			!c2_list_link_is_in(&conn->c_link);
-
-	default:
-		return false;
-	}
-	/* Should never reach here */
-	C2_ASSERT(0);
-}
-
-/**
-   Common code in c2_rpc_conn_fini() and init failed case in __conn_init()
- */
-static void __conn_fini(struct c2_rpc_conn *conn)
-{
-	C2_ASSERT(conn != NULL);
-
-	/* Release the reference on c2_rpc_chan structure being used. */
-	rpc_chan_put(conn->c_rpcchan);
-
-	c2_list_fini(&conn->c_sessions);
-	c2_cond_fini(&conn->c_state_changed);
-	c2_list_link_fini(&conn->c_link);
-	c2_mutex_fini(&conn->c_mutex);
-}
-
-static int __conn_init(struct c2_rpc_conn      *conn,
-		       struct c2_net_end_point *ep,
-		       struct c2_rpcmachine    *machine,
-		       uint64_t			max_rpcs_in_flight)
-{
-	int rc;
-
-	C2_PRE(conn != NULL && ep != NULL && machine != NULL &&
-		c2_rpc_conn_is_snd(conn) != c2_rpc_conn_is_rcv(conn));
-
-	conn->c_rpcchan = rpc_chan_get(machine, ep, max_rpcs_in_flight);
-	if (conn->c_rpcchan == NULL) {
-		C2_SET0(conn);
-		return -ENOMEM;
-	}
-	conn->c_sender_id = SENDER_ID_INVALID;
-	conn->c_cob = NULL;
-	c2_list_init(&conn->c_sessions);
-	conn->c_nr_sessions = 0;
-	c2_cond_init(&conn->c_state_changed);
-	c2_mutex_init(&conn->c_mutex);
-	c2_list_link_init(&conn->c_link);
-	conn->c_rpcmachine = machine;
-	conn->c_rc = 0;
-
-	rc = session_zero_attach(conn);
-	if (rc == 0) {
-		conn->c_state = C2_RPC_CONN_INITIALISED;
-	} else {
-		__conn_fini(conn);
-		C2_SET0(conn);
-	}
-	return rc;
-}
-
-
-int c2_rpc_conn_init(struct c2_rpc_conn      *conn,
-		     struct c2_net_end_point *ep,
-		     struct c2_rpcmachine    *machine,
-		     uint64_t		      max_rpcs_in_flight)
-{
-	int rc;
-
-	C2_ASSERT(conn != NULL && machine != NULL && ep != NULL);
-
-	C2_SET0(conn);
-	conn->c_flags = RCF_SENDER_END;
-	c2_rpc_sender_uuid_generate(&conn->c_uuid);
-	rc = __conn_init(conn, ep, machine, max_rpcs_in_flight);
-
-	C2_POST(ergo(rc == 0, c2_rpc_conn_invariant(conn) &&
-				conn->c_state == C2_RPC_CONN_INITIALISED &&
-				c2_rpc_conn_is_snd(conn)));
-
-	return rc;
-}
-C2_EXPORTED(c2_rpc_conn_init);
-
-int c2_rpc_rcv_conn_init(struct c2_rpc_conn              *conn,
-		         struct c2_net_end_point         *ep,
-		         struct c2_rpcmachine            *machine,
-			 const struct c2_rpc_sender_uuid *uuid)
-{
-	int rc;
-
-	C2_ASSERT(conn != NULL && machine != NULL && ep != NULL);
-
-	C2_SET0(conn);
-	conn->c_flags = RCF_RECV_END;
-	conn->c_uuid = *uuid;
-	rc = __conn_init(conn, ep, machine, 0);
-	C2_POST(ergo(rc == 0, c2_rpc_conn_invariant(conn) &&
-				conn->c_state == C2_RPC_CONN_INITIALISED &&
-				c2_rpc_conn_is_rcv(conn)));
-
-	return rc;
-}
-
-void c2_rpc_conn_fini(struct c2_rpc_conn *conn)
-{
-	C2_PRE(conn != NULL);
-	C2_ASSERT(c2_rpc_conn_invariant(conn));
-	C2_PRE(conn->c_state == C2_RPC_CONN_TERMINATED ||
-	       conn->c_state == C2_RPC_CONN_FAILED ||
-	       conn->c_state == C2_RPC_CONN_INITIALISED);
-
-	session_zero_detach(conn);
-	__conn_fini(conn);
-	C2_SET0(conn);
-}
-C2_EXPORTED(c2_rpc_conn_fini);
-
-bool c2_rpc_conn_timedwait(struct c2_rpc_conn *conn,
-			   uint64_t            state_flags,
-			   const c2_time_t     abs_timeout)
-{
-	bool got_event = true;
-	bool result;
-
-	c2_mutex_lock(&conn->c_mutex);
-	while ((conn->c_state & state_flags) == 0 && got_event) {
-		got_event = c2_cond_timedwait(&conn->c_state_changed,
-					&conn->c_mutex, abs_timeout);
-		/*
-		 * If got_event == false then TIME_OUT has occured.
-		 * break the loop
-		 */
-		C2_ASSERT(c2_rpc_conn_invariant(conn));
-	}
-	result = ((conn->c_state & state_flags) != 0);
-	c2_mutex_unlock(&conn->c_mutex);
-
-	return result;
-}
-C2_EXPORTED(c2_rpc_conn_timedwait);
-
-struct c2_rpc_session *
-c2_rpc_session_search(const struct c2_rpc_conn *conn,
-		      uint64_t                  session_id)
-{
-	struct c2_rpc_session *session;
-
-	/*
-	 * Caller is expected to decide whether conn->c_mutex should be held
-	 * or not. There are situations where it is safe to call this
-	 * routine without holding conn->c_mutex.
-	 * e.g. c2_rpc_conn_fini() => session_zero_detach() =>
-	 *         c2_rpc_conn_session0() => c2_rpc_session_search()
-	 * Safety from concurrency is ensured in this case because caller of
-	 * c2_rpc_conn_fini() takes care that the caller is the only user of
-	 * conn
-	 */
-	C2_ASSERT(conn != NULL);
-
-	c2_rpc_for_each_session(conn, session) {
-		if (session->s_session_id == session_id)
-			return session;
-	}
-	return NULL;
-}
-
-/**
-   Searches and returns session with session id 0.
-   Note: Every rpc connection always has exactly one active session with
-   session id 0.
- */
-struct c2_rpc_session *c2_rpc_conn_session0(const struct c2_rpc_conn *conn)
-{
-	struct c2_rpc_session *session0;
-
-	session0 = c2_rpc_session_search(conn, SESSION_ID_0);
-
-	C2_ASSERT(session0 != NULL);
-	return session0;
-}
-
-/**
-   Returns true iff @conn is sender end of rpc connection.
- */
-bool c2_rpc_conn_is_snd(const struct c2_rpc_conn *conn)
-{
-	return (conn->c_flags & RCF_SENDER_END) == RCF_SENDER_END;
-}
-
-/**
-   Returns true iff @conn is receiver end of rpc connection.
- */
-bool c2_rpc_conn_is_rcv(const struct c2_rpc_conn *conn)
-{
-	return (conn->c_flags & RCF_RECV_END) == RCF_RECV_END;
-}
-
-/**
-   Allocates and returns new sender_id
- */
-static uint64_t sender_id_allocate(void)
-{
-	static struct c2_atomic64 cnt;
-	uint64_t                  sender_id;
-	uint64_t                  sec;
-
-	do {
-		c2_atomic64_inc(&cnt);
-		sec = c2_time_nanoseconds(c2_time_now()) * 1000000;
-
-		sender_id = (sec << 10) | (c2_atomic64_get(&cnt) & 0x3FF);
-
-	} while (sender_id == SENDER_ID_INVALID || sender_id == 0);
-
-	return sender_id;
-}
-
-/**
-   Moves @conn to C2_RPC_CONN_FAILED state, setting error code to @error.
- */
-static void conn_failed(struct c2_rpc_conn *conn, int32_t error)
-{
-	struct c2_rpc_session *session0;
-
-	C2_ASSERT(c2_mutex_is_locked(&conn->c_mutex));
-	C2_ASSERT(conn->c_state == C2_RPC_CONN_CONNECTING ||
-		  conn->c_state == C2_RPC_CONN_ACTIVE ||
-		  conn->c_state == C2_RPC_CONN_TERMINATING);
-
-	conn->c_state = C2_RPC_CONN_FAILED;
-	conn->c_rc = error;
-	/*
-	 * Remove conn from conn->c_rpcmachine->cr_outgoing_conns or
-	 * conn->c_rpcmachine->cr_incoming_conns list
-	 */
-	c2_mutex_lock(&conn->c_rpcmachine->cr_session_mutex);
-	c2_list_del(&conn->c_link);
-	c2_mutex_unlock(&conn->c_rpcmachine->cr_session_mutex);
-
-	session0 = c2_rpc_conn_session0(conn);
-	c2_rpc_session_del_slots_from_ready_list(session0);
-
-	C2_ASSERT(c2_rpc_conn_invariant(conn));
-}
-
-int c2_rpc_conn_establish(struct c2_rpc_conn *conn)
-{
-	struct c2_fop                    *fop;
-	struct c2_rpc_session            *session_0;
-	struct c2_rpcmachine             *machine;
-	int                               rc;
-
-	C2_PRE(conn != NULL);
-
-	fop = c2_fop_alloc(&c2_rpc_fop_conn_establish_fopt, NULL);
-	if (fop == NULL) {
-		rc = -ENOMEM;
-		/*
-		 * No need to hold conn->c_mutex here.
-		 */
-		conn->c_state = C2_RPC_CONN_FAILED;
-		conn->c_rc = rc;
-		C2_ASSERT(c2_rpc_conn_invariant(conn));
-		goto out;
-	}
-
-	c2_mutex_lock(&conn->c_mutex);
-	C2_ASSERT(c2_rpc_conn_invariant(conn));
-	C2_ASSERT(conn->c_state == C2_RPC_CONN_INITIALISED &&
-	          c2_rpc_conn_is_snd(conn));
-
-	/*
-	 * Get a source endpoint and in turn a transfer machine
-	 *  to associate with this c2_rpc_conn.
-	 */
-	machine = conn->c_rpcmachine;
-
-	conn->c_state = C2_RPC_CONN_CONNECTING;
-
-	c2_mutex_lock(&machine->cr_session_mutex);
-	c2_list_add(&machine->cr_outgoing_conns, &conn->c_link);
-	c2_mutex_unlock(&machine->cr_session_mutex);
-
-	C2_ASSERT(c2_rpc_conn_invariant(conn));
-
-	/*
-	 * c2_rpc_fop_conn_establish FOP doesn't contain any data.
-	 */
-
-	session_0 = c2_rpc_conn_session0(conn);
-
-	rc = c2_rpc__fop_post(fop, session_0, &conn_establish_item_ops);
-	if (rc != 0) {
-		conn_failed(conn, rc);
-		c2_fop_free(fop);
-	}
-
-	C2_ASSERT(c2_rpc_conn_invariant(conn));
-	C2_POST(ergo(rc != 0, conn->c_state == C2_RPC_CONN_FAILED));
-	c2_cond_broadcast(&conn->c_state_changed, &conn->c_mutex);
-	c2_mutex_unlock(&conn->c_mutex);
-
-out:
-	return rc;
-}
-C2_EXPORTED(c2_rpc_conn_establish);
-
-void c2_rpc_conn_establish_reply_received(struct c2_rpc_item *req)
-{
-	struct c2_rpc_fop_conn_establish_rep *fop_cer;
-	struct c2_fop                        *fop;
-	struct c2_rpc_conn                   *conn;
-	struct c2_rpc_item                   *reply = req->ri_reply;
-	int32_t                               rc    = req->ri_error;
-
-	C2_PRE(req != NULL && req->ri_session != NULL &&
-		req->ri_session->s_session_id == SESSION_ID_0);
-	C2_PRE(ergo(rc == 0, reply != NULL &&
-			req->ri_session == reply->ri_session));
-
-	conn = req->ri_session->s_conn;
-	C2_ASSERT(conn != NULL);
-
-	c2_mutex_lock(&conn->c_mutex);
-	C2_ASSERT(c2_rpc_conn_invariant(conn));
-	C2_ASSERT(conn->c_state == C2_RPC_CONN_CONNECTING);
-
-	if (rc != 0) {
-		conn_failed(conn, rc);
-		goto out;
-	}
-
-	fop = c2_rpc_item_to_fop(reply);
-	fop_cer = c2_fop_data(fop);
-
-	if (fop_cer->rcer_rc != 0) {
-		/*
-		 * Receiver has reported conn create failure
-		 */
-		conn_failed(conn, fop_cer->rcer_rc);
-		/*
-		 * end-user is expected to call c2_rpc_conn_fini() on
-		 * this object, to free any memory allocated by conn for
-		 * its internal structures (session0, slots etc.).
-		 * Then the end-user can free the object.
-		 */
-	} else {
-		if (fop_cer->rcer_sender_id == SENDER_ID_INVALID) {
-			/*
-			 * Return code (fop_cer->rcer_rc) says that conn
-			 * establish is successful. In that case, sender_id
-			 * in the reply fop MUST not be SENDER_ID_INVALID.
-			 * We do not assert, for inconsistent data received from
-			 * network/disk.
-			 * move conn to FAILED state and XXX generate ADDB
-			 * record.
-			 */
-			conn_failed(conn, -EPROTO);
-			goto out;
-		}
-		conn->c_sender_id = fop_cer->rcer_sender_id;
-		conn->c_state = C2_RPC_CONN_ACTIVE;
-	}
-
-out:
-	C2_ASSERT(c2_rpc_conn_invariant(conn));
-	C2_ASSERT(conn->c_state == C2_RPC_CONN_FAILED ||
-		  conn->c_state == C2_RPC_CONN_ACTIVE);
-	c2_cond_broadcast(&conn->c_state_changed, &conn->c_mutex);
-	c2_mutex_unlock(&conn->c_mutex);
-}
-
-int c2_rpc_conn_establish_sync(struct c2_rpc_conn *conn, uint32_t timeout_sec)
-{
-	int rc;
-	bool state_reached;
-
-	rc = c2_rpc_conn_establish(conn);
-	if (rc != 0)
-		return rc;
-
-	state_reached = c2_rpc_conn_timedwait(conn, C2_RPC_CONN_ACTIVE |
-					      C2_RPC_CONN_FAILED,
-					      c2_time_from_now(timeout_sec, 0));
-	if (!state_reached)
-		return -ETIMEDOUT;
-
-	switch (conn->c_state) {
-	case C2_RPC_CONN_ACTIVE:
-		rc = 0;
-		break;
-	case C2_RPC_CONN_FAILED:
-		rc = conn->c_rc;
-		break;
-	default:
-		C2_ASSERT("internal logic error in c2_rpc_conn_timedwait()" == 0);
-	}
-
-	return rc;
-}
-C2_EXPORTED(c2_rpc_conn_establish_sync);
-
-int c2_rpc_conn_create(struct c2_rpc_conn      *conn,
-		       struct c2_net_end_point *ep,
-		       struct c2_rpcmachine    *rpc_machine,
-		       uint64_t			max_rpcs_in_flight,
-		       uint32_t			timeout_sec)
-{
-	int rc;
-
-	rc = c2_rpc_conn_init(conn, ep, rpc_machine, max_rpcs_in_flight);
-	if (rc != 0)
-		return rc;
-
-	rc = c2_rpc_conn_establish_sync(conn, timeout_sec);
-	if (rc != 0)
-		c2_rpc_conn_fini(conn);
-
-	return rc;
-}
-
-static int session_zero_attach(struct c2_rpc_conn *conn)
-{
-	struct c2_rpc_slot    *slot;
-	struct c2_rpc_session *session;
-	int                    rc;
-
-	C2_ASSERT(conn != NULL);
-
-	C2_ALLOC_PTR(session);
-	if (session == NULL)
-		return -ENOMEM;
-
-	rc = c2_rpc_session_init(session, conn, 1);   /* 1 => number of slots */
-	if (rc != 0) {
-		c2_free(session);
-		return rc;
-	}
-
-	session->s_session_id = SESSION_ID_0;
-	session->s_state = C2_RPC_SESSION_IDLE;
-
-	c2_list_add(&conn->c_sessions, &session->s_link);
-	slot = session->s_slot_table[0];
-	C2_ASSERT(slot != NULL &&
-		  slot->sl_ops != NULL &&
-		  slot->sl_ops->so_slot_idle != NULL);
-	slot->sl_ops->so_slot_idle(slot);
-	C2_ASSERT(c2_rpc_session_invariant(session));
-	return 0;
-}
-
-static void session_zero_detach(struct c2_rpc_conn *conn)
-{
-	struct c2_rpc_session *session;
-
-	C2_PRE(conn != NULL);
-
-	session = c2_rpc_conn_session0(conn);
-	session->s_state = C2_RPC_SESSION_TERMINATED;
-	c2_list_del(&session->s_link);
-
-	c2_rpc_session_del_slots_from_ready_list(session);
-	c2_rpc_session_fini(session);
-	c2_free(session);
-}
-
-int c2_rpc_conn_terminate(struct c2_rpc_conn *conn)
-{
-	struct c2_fop                    *fop;
-	struct c2_rpc_fop_conn_terminate *fop_ct;
-	struct c2_rpc_session            *session_0;
-	int                               rc;
-
-	C2_PRE(conn != NULL);
-
-	fop = c2_fop_alloc(&c2_rpc_fop_conn_terminate_fopt, NULL);
-	if (fop == NULL) {
-		rc = -ENOMEM;
-
-		/*
-		 * There are two choices here:
-		 *
-		 * 1. leave conn in TERMNATING state FOREVER.
-		 *    Then when to fini/cleanup conn.
-		 *
-		 * 2. Move conn to FAILED state.
-		 *    For this conn the receiver side state will still
-		 *    continue to exist. And receiver can send unsolicited
-		 *    items, that will be received on sender i.e. current node.
-		 *    Current code will drop such items. When/how to fini and
-		 *    cleanup receiver side state? XXX
-		 *
-		 * For now, later is chosen. This can be changed in future
-		 * to alternative 1, iff required.
-		 */
-
-		c2_mutex_lock(&conn->c_mutex);
-		C2_ASSERT(c2_rpc_conn_invariant(conn));
-
-		if (conn->c_state == C2_RPC_CONN_TERMINATING) {
-			rc = 0;
-			goto out_unlock;
-		}
-
-		conn_failed(conn, rc);
-
-		C2_ASSERT(c2_rpc_conn_invariant(conn));
-		goto out_unlock;
-	}
-
-	c2_mutex_lock(&conn->c_mutex);
-
-	/*
-	 * If rpc connection is already in TERMINATING state then
-	 * c2_rpc_conn_terminate() is a no-op.
-	 */
-	if (conn->c_state == C2_RPC_CONN_TERMINATING) {
-		rc = 0;
-		c2_fop_free(fop);
-		goto out_unlock;
-	}
-
-	C2_ASSERT(c2_rpc_conn_invariant(conn));
-	C2_ASSERT(conn->c_state == C2_RPC_CONN_ACTIVE &&
-			conn->c_nr_sessions == 0);
-
-	conn->c_state = C2_RPC_CONN_TERMINATING;
-
-	fop_ct = c2_fop_data(fop);
-	C2_ASSERT(fop_ct != NULL);
-
-	fop_ct->ct_sender_id = conn->c_sender_id;
-
-	session_0 = c2_rpc_conn_session0(conn);
-	rc = c2_rpc__fop_post(fop, session_0, &conn_terminate_item_ops);
-	if (rc != 0) {
-		conn_failed(conn, rc);
-		c2_fop_free(fop);
-	}
-	C2_ASSERT(c2_rpc_conn_invariant(conn));
-	C2_POST(ergo(rc != 0, conn->c_state == C2_RPC_CONN_FAILED));
-	C2_POST(ergo(rc == 0, conn->c_state == C2_RPC_CONN_TERMINATING));
-	c2_cond_broadcast(&conn->c_state_changed, &conn->c_mutex);
-
-out_unlock:
-	c2_mutex_unlock(&conn->c_mutex);
-	return rc;
-}
-C2_EXPORTED(c2_rpc_conn_terminate);
-
-void c2_rpc_conn_terminate_reply_received(struct c2_rpc_item *req)
-{
-	struct c2_rpc_fop_conn_terminate_rep *fop_ctr;
-	struct c2_fop                        *fop;
-	struct c2_rpc_conn                   *conn;
-	struct c2_rpc_item                   *reply = req->ri_reply;
-	int32_t                               rc    = req->ri_error;
-	uint64_t                              sender_id;
-
-	C2_PRE(req != NULL && req->ri_session != NULL &&
-		req->ri_session->s_session_id == SESSION_ID_0);
-	C2_PRE(ergo(rc == 0, reply != NULL &&
-			req->ri_session == reply->ri_session));
-
-	conn = req->ri_session->s_conn;
-	C2_ASSERT(conn != NULL);
-
-	c2_mutex_lock(&conn->c_mutex);
-	C2_ASSERT(c2_rpc_conn_invariant(conn));
-	C2_ASSERT(conn->c_state == C2_RPC_CONN_TERMINATING);
-
-	/* Remove conn from rpcmachine::cr_outgoing_conns list */
-	c2_mutex_lock(&conn->c_rpcmachine->cr_session_mutex);
-	c2_list_del(&conn->c_link);
-	c2_mutex_unlock(&conn->c_rpcmachine->cr_session_mutex);
-
-	if (rc != 0) {
-		conn->c_state = C2_RPC_CONN_FAILED;
-		conn->c_rc = rc;
-		goto out;
-	}
-
-	fop = c2_rpc_item_to_fop(reply);
-	fop_ctr = c2_fop_data(fop);
-
-	/*
-	 * c2_rpc_conn_terminate() sends sender_id in the conn_terminate
-	 * request fop. Receiver simply copies it back in reply. Make sure it
-	 * matches with connection being terminated.
-	 * No assert on data received from network/disk.
-	 * XXX generate ADDB record here.
-	 */
-	sender_id = fop_ctr->ctr_sender_id;
-	if (conn->c_sender_id != sender_id) {
-		conn->c_state = C2_RPC_CONN_FAILED;
-		conn->c_rc = -EPROTO;
-		goto out;
-	}
-
-	/*
-	 * Update conn state depending on rc reported in reply fop.
-	 * session 0 will be cleaned up in c2_rpc_conn_fini().
-	 */
-	if (fop_ctr->ctr_rc == 0) {
-		conn->c_state = C2_RPC_CONN_TERMINATED;
-		conn->c_sender_id = SENDER_ID_INVALID;
-	} else {
-		/*
-		 * Connection termination failed
-		 */
-		conn->c_state = C2_RPC_CONN_FAILED;
-		conn->c_rc = fop_ctr->ctr_rc;
-	}
-
-out:
-	C2_POST(c2_rpc_conn_invariant(conn));
-	C2_POST(conn->c_state == C2_RPC_CONN_TERMINATED ||
-		conn->c_state == C2_RPC_CONN_FAILED);
-	c2_cond_broadcast(&conn->c_state_changed, &conn->c_mutex);
-	c2_mutex_unlock(&conn->c_mutex);
-}
-
-int c2_rpc_conn_terminate_sync(struct c2_rpc_conn *conn, uint32_t timeout_sec)
-{
-	int rc;
-	bool state_reached;
-
-	rc = c2_rpc_conn_terminate(conn);
-	if (rc != 0)
-		return rc;
-
-	state_reached = c2_rpc_conn_timedwait(conn, C2_RPC_CONN_TERMINATED |
-					      C2_RPC_CONN_FAILED,
-					      c2_time_from_now(timeout_sec, 0));
-	if (!state_reached)
-		return -ETIMEDOUT;
-
-	switch (conn->c_state) {
-	case C2_RPC_CONN_TERMINATED:
-		rc = 0;
-		break;
-	case C2_RPC_CONN_FAILED:
-		rc = conn->c_rc;
-		break;
-	default:
-		C2_ASSERT("internal logic error in c2_rpc_conn_timedwait()" == 0);
-	}
-
-	return rc;
-}
-C2_EXPORTED(c2_rpc_conn_terminate_sync);
-
-int c2_rpc_conn_destroy(struct c2_rpc_conn *conn, uint32_t timeout_sec)
-{
-	int rc;
-
-	rc = c2_rpc_conn_terminate_sync(conn, timeout_sec);
-	if (rc != 0)
-		return rc;
-
-	c2_rpc_conn_fini(conn);
-
-	return rc;
-}
-C2_EXPORTED(c2_rpc_conn_destroy);
-
-int c2_rpc_conn_cob_lookup(struct c2_cob_domain *dom,
-			   uint64_t              sender_id,
-			   struct c2_cob       **out,
-			   struct c2_db_tx      *tx)
-{
-	struct c2_cob *root_session_cob;
-	char           name[SESSION_COB_MAX_NAME_LEN];
-	int            rc;
-
-	C2_PRE(sender_id != SENDER_ID_INVALID);
-
-	rc = c2_rpc_root_session_cob_get(dom, &root_session_cob, tx);
-	if (rc != 0)
-		return rc;
-
-	sprintf(name, conn_cob_name_fmt, (unsigned long)sender_id);
-
-	rc = c2_rpc_cob_lookup_helper(dom, root_session_cob, name, out, tx);
-	c2_cob_put(root_session_cob);
-
-	return rc;
-}
-
-int c2_rpc_conn_cob_create(struct c2_cob_domain *dom,
-			   uint64_t              sender_id,
-			   struct c2_cob       **out,
-			   struct c2_db_tx      *tx)
-{
-	struct c2_cob *conn_cob;
-	struct c2_cob *root_session_cob;
-	char           name[SESSION_COB_MAX_NAME_LEN];
-	int            rc;
-
-	C2_PRE(dom != NULL && out != NULL);
-	C2_PRE(sender_id != SENDER_ID_INVALID);
-
-	sprintf(name, conn_cob_name_fmt, (unsigned long)sender_id);
-	*out = NULL;
-
-	rc = c2_rpc_cob_lookup_helper(dom, NULL, root_session_cob_name,
-					&root_session_cob, tx);
-	if (rc != 0) {
-		C2_ASSERT(rc != -EEXIST);
-		return rc;
-	}
-	rc = c2_rpc_cob_create_helper(dom, root_session_cob, name, &conn_cob,
-					tx);
-	if (rc == 0)
-		*out = conn_cob;
-	c2_cob_put(root_session_cob);
-	return rc;
-}
-
-static int conn_persistent_state_create(struct c2_cob_domain *dom,
-					uint64_t              sender_id,
-					struct c2_cob       **conn_cob_out,
-					struct c2_cob       **session0_cob_out,
-					struct c2_cob       **slot0_cob_out,
-					struct c2_db_tx      *tx)
-{
-	struct c2_cob *conn_cob;
-	struct c2_cob *session0_cob;
-	struct c2_cob *slot0_cob;
-	int            rc;
-
-	*conn_cob_out = *session0_cob_out = *slot0_cob_out = NULL;
-
-	rc = c2_rpc_conn_cob_create(dom, sender_id, &conn_cob, tx);
-	if (rc != 0)
-		goto errout;
-
-	rc = c2_rpc_session_cob_create(conn_cob, SESSION_ID_0, &session0_cob,
-					tx);
-	if (rc != 0) {
-		c2_cob_put(conn_cob);
-		goto errout;
-	}
-
-	rc = c2_rpc_slot_cob_create(session0_cob,
-					0,      /* Slot id */
-					0,      /* slot generation */
-					&slot0_cob, tx);
-	if (rc != 0) {
-		c2_cob_put(session0_cob);
-		c2_cob_put(conn_cob);
-		goto errout;
-	}
-
-	*conn_cob_out = conn_cob;
-	*session0_cob_out = session0_cob;
-	*slot0_cob_out = slot0_cob;
-	return 0;
-
-errout:
-	*conn_cob_out = NULL;
-	*session0_cob_out = NULL;
-	*slot0_cob_out = NULL;
-	return rc;
-}
-
-static int conn_persistent_state_attach(struct c2_rpc_conn *conn,
-				        uint64_t            sender_id,
-				        struct c2_db_tx    *tx)
-{
-	struct c2_rpc_session *session0;
-	struct c2_rpc_slot    *slot0;
-	struct c2_cob         *conn_cob;
-	struct c2_cob         *session0_cob;
-	struct c2_cob         *slot0_cob;
-	struct c2_cob_domain  *dom;
-	int                    rc;
-
-	C2_PRE(conn != NULL && c2_rpc_conn_invariant(conn) &&
-			conn->c_state == C2_RPC_CONN_INITIALISED);
-
-	dom = conn->c_rpcmachine->cr_dom;
-	rc = conn_persistent_state_create(dom, sender_id,
-					  &conn_cob, &session0_cob, &slot0_cob,
-					  tx);
-	if (rc != 0)
-		return rc;
-
-	C2_ASSERT(conn_cob != NULL && session0_cob != NULL &&
-			slot0_cob != NULL);
-	conn->c_cob = conn_cob;
-
-	session0 = c2_rpc_conn_session0(conn);
-	session0->s_cob = session0_cob;
-
-	slot0 = session0->s_slot_table[0];
-	C2_ASSERT(slot0 != NULL);
-	slot0->sl_cob = slot0_cob;
-
-	return 0;
-}
-
-int c2_rpc_rcv_conn_establish(struct c2_rpc_conn *conn)
-{
-	struct c2_rpcmachine *machine;
-	struct c2_db_tx       tx;
-	uint64_t              sender_id;
-	int                   rc;
-
-	C2_PRE(conn != NULL);
-
-	c2_mutex_lock(&conn->c_mutex);
-
-	C2_ASSERT(c2_rpc_conn_invariant(conn));
-	C2_ASSERT(conn->c_state == C2_RPC_CONN_INITIALISED &&
-			c2_rpc_conn_is_rcv(conn));
-
-	machine = conn->c_rpcmachine;
-	C2_ASSERT(machine != NULL && machine->cr_dom != NULL);
-
-	rc = c2_db_tx_init(&tx, machine->cr_dom->cd_dbenv, 0);
-	if (rc != 0)
-		goto out;
-
-	sender_id = sender_id_allocate();
-	rc = conn_persistent_state_attach(conn, sender_id,
-					  &tx);
-	if (rc != 0) {
-		/*
-		 * Regardless of return value of c2_db_tx_abort(), the conn
-		 * will be moved to FAILED state.
-		 */
-		c2_db_tx_abort(&tx);
-		goto out;
-	}
-
-	rc = c2_db_tx_commit(&tx);
-	if (rc != 0)
-		goto out;
-
-	conn->c_sender_id = sender_id;
-	conn->c_state = C2_RPC_CONN_ACTIVE;
-	c2_mutex_lock(&machine->cr_session_mutex);
-	c2_list_add(&machine->cr_incoming_conns, &conn->c_link);
-	c2_mutex_unlock(&machine->cr_session_mutex);
-	/* Fall through */
-out:
-	conn->c_state = (rc == 0) ? C2_RPC_CONN_ACTIVE : C2_RPC_CONN_FAILED;
-	conn->c_rc = rc;
-	C2_ASSERT(c2_rpc_conn_invariant(conn));
-	c2_mutex_unlock(&conn->c_mutex);
-	return rc;
-}
-
-static int conn_persistent_state_destroy(struct c2_rpc_conn *conn,
-					 struct c2_db_tx    *tx)
-{
-	struct c2_rpc_session *session0;
-	struct c2_rpc_slot    *slot0;
-
-	session0 = c2_rpc_conn_session0(conn);
-	slot0 = session0->s_slot_table[0];
-	C2_ASSERT(slot0 != NULL && c2_rpc_slot_invariant(slot0));
-
-	C2_ASSERT(conn->c_cob != NULL && session0->s_cob != NULL &&
-			slot0->sl_cob != NULL);
-	c2_cob_delete(conn->c_cob, tx);
-	c2_cob_delete(session0->s_cob, tx);
-	c2_cob_delete(slot0->sl_cob, tx);
-
-	conn->c_cob = session0->s_cob = slot0->sl_cob = NULL;
-	return 0;
-}
-
-int c2_rpc_rcv_conn_terminate(struct c2_rpc_conn *conn)
-{
-	struct c2_db_tx tx;
-	int             rc;
-
-	C2_PRE(conn != NULL);
-
-	c2_mutex_lock(&conn->c_mutex);
-
-	C2_ASSERT(c2_rpc_conn_invariant(conn));
-	C2_ASSERT(conn->c_state == C2_RPC_CONN_ACTIVE);
-	C2_ASSERT(c2_rpc_conn_is_rcv(conn));
-
-	if (conn->c_nr_sessions > 0) {
-		c2_mutex_unlock(&conn->c_mutex);
-		return -EBUSY;
-	}
-
-	conn->c_state = C2_RPC_CONN_TERMINATING;
-
-	rc = c2_db_tx_init(&tx, conn->c_cob->co_dom->cd_dbenv, 0);
-	if (rc != 0)
-		goto out;
-
-	rc = conn_persistent_state_destroy(conn, &tx);
-	if (rc == 0)
-		rc = c2_db_tx_commit(&tx);
-	else
-		c2_db_tx_abort(&tx);
-out:
-	if (rc != 0)
-		conn_failed(conn, rc);
-
-	/*
-	 * Note: conn is not moved to TERMINATED state even if operation is
-	 * successful. This is required to be able to send successful conn
-	 * terminate reply.
-	 */
-	C2_ASSERT(c2_rpc_conn_invariant(conn));
-	/* In-core state will be cleaned up by
-	   c2_rpc_conn_terminate_reply_sent() */
-	c2_mutex_unlock(&conn->c_mutex);
-	return rc;
-}
-
-void c2_rpc_conn_terminate_reply_sent(struct c2_rpc_conn *conn)
-{
-	C2_ASSERT(conn != NULL);
-
-	c2_mutex_lock(&conn->c_mutex);
-
-	C2_ASSERT(c2_rpc_conn_invariant(conn));
-	C2_ASSERT(conn->c_state == C2_RPC_CONN_TERMINATING);
-
-	c2_mutex_lock(&conn->c_rpcmachine->cr_session_mutex);
-	c2_list_del(&conn->c_link);
-	c2_mutex_unlock(&conn->c_rpcmachine->cr_session_mutex);
-
-	conn->c_state = C2_RPC_CONN_TERMINATED;
-	conn->c_sender_id = SENDER_ID_INVALID;
-	conn->c_rc = 0;
-	C2_ASSERT(c2_rpc_conn_invariant(conn));
-	c2_mutex_unlock(&conn->c_mutex);
-
-	c2_rpc_conn_fini(conn);
-	c2_free(conn);
-}
-
-bool c2_rpc_item_is_conn_establish(const struct c2_rpc_item *item)
-{
-	return item->ri_type->rit_opcode == C2_RPC_CONN_ESTABLISH_OPCODE;
-}
-
-bool c2_rpc_item_is_conn_terminate(const struct c2_rpc_item *item)
-{
-	return item->ri_type->rit_opcode == C2_RPC_CONN_TERMINATE_OPCODE;
-}
-
-#ifndef __KERNEL__
-/**
-   Just for debugging purpose. Useful in gdb.
-
-   dir = 1, to print incoming conn list
-   dir = 0, to print outgoing conn list
- */
-int c2_rpcmachine_conn_list_print(struct c2_rpcmachine *machine, int dir)
-{
-	struct c2_list     *list;
-	struct c2_rpc_conn *conn;
-
-	list = dir ? &machine->cr_incoming_conns : &machine->cr_outgoing_conns;
-
-	c2_list_for_each_entry(list, conn, struct c2_rpc_conn, c_link) {
-		printf("CONN: %p id %llu state %x\n", conn,
-				(unsigned long long)conn->c_sender_id,
-				conn->c_state);
-	}
-	return 0;
-}
-
-int c2_rpc_conn_session_list_print(const struct c2_rpc_conn *conn)
-{
-	struct c2_rpc_session *session;
-
-	c2_list_for_each_entry(&conn->c_sessions, session,
-				struct c2_rpc_session, s_link) {
-		printf("session %p id %llu state %x\n", session,
-			(unsigned long long)session->s_session_id,
-			session->s_state);
-	}
-	return 0;
-}
-#endif
diff --git a/rpc/formation.c b/rpc/formation.c
deleted file mode 100644
index 202165e..0000000
--- a/rpc/formation.c
+++ /dev/null
@@ -1,1413 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Anand Vidwansa <Anand_Vidwansa@xyratex.com>
- *                  Anup Barve <Anup_Barve@xyratex.com>
- * Original creation date: 04/28/2011
- */
-
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif
-
-#include "rpc/rpc2.h"
-#include "lib/errno.h"
-#include "lib/memory.h"
-#include "lib/cdefs.h"
-#include "lib/trace.h"
-
-#include "rpc/rpc_onwire.h"
-
-/* ADDB Instrumentation for rpc formation. */
-static const struct c2_addb_ctx_type frm_addb_ctx_type = {
-        .act_name = "rpc-formation"
-};
-
-static const struct c2_addb_loc frm_addb_loc = {
-        .al_name = "rpc-formation"
-};
-
-C2_ADDB_EV_DEFINE(formation_func_fail, "formation_func_fail",
-		C2_ADDB_EVENT_FUNC_FAIL, C2_ADDB_FUNC_CALL);
-
-void rpc_item_replied(struct c2_rpc_item *item, struct c2_rpc_item *reply,
-		      uint32_t rc);
-
-extern void item_exit_stats_set(struct c2_rpc_item *item,
-				enum c2_rpc_item_path path);
-
-extern void rpcobj_exit_stats_set(const struct c2_rpc *rpcobj,
-				struct c2_rpcmachine *mach,
-		                const enum c2_rpc_item_path path);
-
-extern void send_buffer_deallocate(struct c2_net_buffer *nb,
-				   struct c2_net_domain *net_dom);
-
-extern int send_buffer_allocate(struct c2_net_domain *net_dom,
-		struct c2_net_buffer **nb, uint64_t rpc_size);
-
-extern int item_io_coalesce(struct c2_rpc_frm_item_coalesced *c_item,
-		struct c2_rpc_item *b_item);
-
-/* Forward declarations of local static functions. */
-static void frm_item_remove(struct c2_rpc_frm_sm *frm_sm,
-		struct c2_rpc_item *item);
-
-static void frm_item_add(struct c2_rpc_frm_sm *frm_sm,
-			 struct c2_rpc_item *item);
-
-static void frm_send_onwire(struct c2_rpc_frm_sm *frm_sm);
-
-static void coalesced_item_fini(struct c2_rpc_frm_item_coalesced *c_item);
-
-static void coalesced_item_reply_post(struct c2_rpc_frm_item_coalesced *cs,
-				      struct c2_rpc_item *reply);
-
-static void sm_updating_state(struct c2_rpc_frm_sm *frm_sm,
-			     struct c2_rpc_item *item);
-
-static void sm_forming_state(struct c2_rpc_frm_sm *frm_sm,
-			    struct c2_rpc_item *item);
-
-static void frm_item_rpc_stats_set(struct c2_rpc *rpc)
-{
-	struct c2_rpc_item *item;
-	struct c2_rpc_item *first_item;
-
-	C2_PRE(rpc != NULL);
-
-	if (c2_list_is_empty(&rpc->r_items))
-		return;
-	first_item = c2_list_entry((c2_list_first(&rpc->r_items)),
-				struct c2_rpc_item, ri_rpcobject_linkage);
-	rpcobj_exit_stats_set(rpc,
-			first_item->ri_session->s_conn->c_rpcmachine,
-			C2_RPC_PATH_OUTGOING);
-
-	c2_list_for_each_entry(&rpc->r_items, item,
-			struct c2_rpc_item, ri_rpcobject_linkage)
-		item_exit_stats_set(item, C2_RPC_PATH_OUTGOING);
-}
-
-/* Changes the state of each rpc item in rpc object to RPC_ITEM_SENT. */
-static void frm_item_state_set(const struct c2_rpc *rpc, const enum
-		c2_rpc_item_state state)
-{
-	struct c2_rpc_item *item;
-
-	C2_PRE(rpc != NULL);
-
-	c2_list_for_each_entry(&rpc->r_items, item,
-			struct c2_rpc_item, ri_rpcobject_linkage) {
-		C2_ASSERT(item->ri_state == RPC_ITEM_ADDED);
-		item->ri_state = state;
-	}
-}
-
-void c2_rpcobj_init(struct c2_rpc *rpc)
-{
-	C2_PRE(rpc != NULL);
-
-	c2_list_link_init(&rpc->r_linkage);
-	c2_list_init(&rpc->r_items);
-	rpc->r_session = NULL;
-	rpc->r_fbuf.fb_magic = C2_RPC_FRM_BUFFER_MAGIC;
-}
-
-/* Invariant subroutine for struct c2_rpc_frm_buffer. */
-static bool frm_buf_invariant(const struct c2_rpc_frm_buffer *fbuf)
-{
-	return fbuf != NULL && fbuf->fb_frm_sm != NULL &&
-			fbuf->fb_magic == C2_RPC_FRM_BUFFER_MAGIC;
-}
-
-int c2_rpcobj_fbuf_init(struct c2_rpc_frm_buffer *fb,
-		struct c2_rpc_frm_sm *frm_sm, struct c2_net_domain *net_dom,
-		uint64_t rpc_size)
-{
-	int			 rc;
-	struct c2_net_buffer	*nb;
-
-	C2_PRE(fb != NULL);
-	C2_PRE(frm_sm != NULL);
-	C2_PRE(net_dom != NULL);
-	C2_PRE(rpc_size != 0);
-
-	fb->fb_frm_sm = frm_sm;
-	nb = &fb->fb_buffer;
-	rc = send_buffer_allocate(net_dom, &nb, rpc_size);
-	if (rc != 0)
-		return rc;
-	C2_POST(frm_buf_invariant(fb));
-	return rc;
-}
-
-static void c2_rpcobj_fbuf_fini(struct c2_rpc_frm_buffer *fb)
-{
-	C2_PRE(fb != NULL);
-	C2_PRE(frm_buf_invariant(fb));
-
-	/* Currently, the policy is to release the buffer on completion. */
-	send_buffer_deallocate(&fb->fb_buffer, fb->fb_buffer.nb_dom);
-}
-
-void frm_sm_fini(struct c2_rpc_frm_sm *frm_sm)
-{
-	int cnt;
-
-	C2_PRE(frm_sm != NULL);
-	C2_PRE(frm_sm->fs_state == C2_RPC_FRM_STATE_WAITING);
-
-	c2_list_fini(&frm_sm->fs_groups);
-	c2_list_fini(&frm_sm->fs_coalesced_items);
-	c2_list_fini(&frm_sm->fs_rpcs);
-	for (cnt = 0; cnt < ARRAY_SIZE(frm_sm->fs_unformed); ++cnt)
-		c2_list_fini(&frm_sm->fs_unformed[cnt].pl_unformed_items);
-	c2_mutex_fini(&frm_sm->fs_lock);
-	c2_addb_ctx_fini(&frm_sm->fs_rpc_form_addb);
-}
-
-static bool frm_sm_invariant(const struct c2_rpc_frm_sm *frm_sm)
-{
-	int			 cnt;
-	bool			 item_present = false;
-	struct c2_rpc_chan	*chan;
-
-	if (frm_sm == NULL)
-		return false;
-
-	chan = container_of(frm_sm, struct c2_rpc_chan, rc_frmsm);
-	if (chan == NULL)
-		return false;
-
-	/* Formation state machine should be in a valid state. */
-	if (frm_sm->fs_state < C2_RPC_FRM_STATE_WAITING ||
-	    frm_sm->fs_state > C2_RPC_FRM_STATE_FORMING)
-		return false;
-
-	/* The transfer machine associated with this formation state machine
-	   should have been started already. */
-	if (chan->rc_rpcmachine->cr_tm.ntm_state != C2_NET_TM_STARTED)
-		return false;
-
-	/* Number of rpcs in flight should always be less than max limit. */
-	if (frm_sm->fs_curr_rpcs_in_flight > frm_sm->fs_max_rpcs_in_flight)
-		return false;
-
-	/* The invariant data in formation state machine according to different
-	   states of state machine. */
-	switch (frm_sm->fs_state) {
-	case C2_RPC_FRM_STATE_WAITING:
-		break;
-	case C2_RPC_FRM_STATE_UPDATING:
-		/* If any of these lists contain items, then item sizes
-		   should be accounted in frm_sm->fs_cumulative_size. */
-		for (cnt = 0; cnt < C2_RPC_ITEM_PRIO_NR; ++cnt)
-			if (!c2_list_is_empty(&frm_sm->fs_unformed[cnt].
-					      pl_unformed_items))
-				item_present = true;
-		if (item_present && frm_sm->fs_cumulative_size == 0)
-			return false;
-
-		/* If there is at least one complete rpc group present
-		   in state machine, then frm_sm->fs_groups list should
-		   not be empty. */
-		if (frm_sm->fs_complete_groups_nr > 0 &&
-		    c2_list_is_empty(&frm_sm->fs_groups))
-			return false;
-		break;
-	case C2_RPC_FRM_STATE_FORMING:
-		/* If list of coalesced items is not empty, there should
-		   be an rpc made in forming state. */
-		if (!c2_list_is_empty(&frm_sm->fs_coalesced_items) &&
-		    c2_list_is_empty(&frm_sm->fs_rpcs))
-			return false;
-		break;
-	default:
-		C2_IMPOSSIBLE("Invalid state of formation state machine.");
-	};
-	return true;
-}
-
-static struct c2_rpc_frm_sm *item_to_frm_sm(const struct c2_rpc_item *item)
-{
-	struct c2_rpc_frm_sm *frm_sm;
-
-	C2_PRE(item != NULL);
-	frm_sm = &item->ri_session->s_conn->c_rpcchan->rc_frmsm;
-	C2_POST(frm_sm != NULL);
-	return frm_sm;
-}
-
-void frm_sm_init(struct c2_rpc_frm_sm *frm_sm, uint64_t max_rpcs_in_flight)
-{
-	uint64_t		 cnt;
-	struct c2_rpc_chan	*chan;
-	struct c2_net_domain	*netdom;
-
-	C2_PRE(frm_sm != NULL);
-
-	chan = container_of(frm_sm, struct c2_rpc_chan, rc_frmsm);
-	netdom = chan->rc_rpcmachine->cr_tm.ntm_dom;
-        c2_addb_ctx_init(&frm_sm->fs_rpc_form_addb,
-			&frm_addb_ctx_type, &c2_addb_global_ctx);
-	frm_sm->fs_sender_side = false;
-	c2_mutex_init(&frm_sm->fs_lock);
-	c2_list_init(&frm_sm->fs_groups);
-	c2_list_init(&frm_sm->fs_coalesced_items);
-	c2_list_init(&frm_sm->fs_rpcs);
-	frm_sm->fs_state = C2_RPC_FRM_STATE_WAITING;
-	frm_sm->fs_curr_rpcs_in_flight = 0;
-	for (cnt = 0; cnt < ARRAY_SIZE(frm_sm->fs_unformed); ++cnt) {
-		frm_sm->fs_unformed[cnt].pl_prio = C2_RPC_ITEM_PRIO_NR -
-			(cnt + 1);
-		c2_list_init(&frm_sm->fs_unformed[cnt].pl_unformed_items);
-	}
-	frm_sm->fs_cumulative_size = 0;
-	frm_sm->fs_urgent_nogrp_items_nr = 0;
-	frm_sm->fs_complete_groups_nr = 0;
-	frm_sm->fs_timedout_items_nr = 0;
-	frm_sm->fs_items_left = 0;
-
-	frm_sm->fs_max_msg_size = c2_net_domain_get_max_buffer_size(netdom);
-	frm_sm->fs_max_frags = c2_net_domain_get_max_buffer_segments(netdom);
-	frm_sm->fs_max_rpcs_in_flight = max_rpcs_in_flight;
-}
-
-/* Callback function for addition of a bound rpc item. */
-void frm_item_ready(struct c2_rpc_item *item)
-{
-	struct c2_rpc_slot		*slot;
-	struct c2_rpcmachine		*rpcmachine;
-	struct c2_rpc_frm_sm		*frm_sm;
-
-	C2_PRE(item != NULL);
-
-	/* Add the item to ready list of its slot. */
-	slot = item->ri_slot_refs[0].sr_slot;
-	C2_ASSERT(slot != NULL);
-	C2_PRE(c2_mutex_is_locked(&slot->sl_mutex));
-	c2_list_add(&slot->sl_ready_list, &item->ri_slot_refs[0].sr_ready_link);
-
-	/* Add the slot to list of ready slots in rpcmachine. */
-	rpcmachine = slot->sl_session->s_conn->c_rpcmachine;
-	C2_ASSERT(rpcmachine != NULL);
-	c2_mutex_lock(&rpcmachine->cr_ready_slots_mutex);
-
-	/* Add the slot to ready list of slots in rpcmachine, if
-	   it is not in that list already. */
-	if (!c2_list_link_is_in(&slot->sl_link))
-		c2_list_add(&rpcmachine->cr_ready_slots, &slot->sl_link);
-	c2_mutex_unlock(&rpcmachine->cr_ready_slots_mutex);
-
-	frm_sm = item_to_frm_sm(item);
-	sm_updating_state(frm_sm, item);
-}
-
-/* Callback function for slot becoming idle. */
-void frm_slot_idle(struct c2_rpc_slot *slot)
-{
-	struct c2_rpcmachine *rpcmachine;
-
-	C2_PRE(slot != NULL);
-	C2_PRE(slot->sl_session != NULL);
-	C2_PRE(slot->sl_in_flight == 0);
-
-	/* Add the slot to list of ready slots in its rpcmachine. */
-	rpcmachine = slot->sl_session->s_conn->c_rpcmachine;
-	C2_ASSERT(rpcmachine != NULL);
-	c2_mutex_lock(&rpcmachine->cr_ready_slots_mutex);
-	C2_ASSERT(!c2_list_link_is_in(&slot->sl_link));
-	c2_list_add(&rpcmachine->cr_ready_slots, &slot->sl_link);
-	c2_mutex_unlock(&rpcmachine->cr_ready_slots_mutex);
-}
-
-/* Callback function for addition of unbounded/unsolicited item. */
-void frm_ubitem_added(struct c2_rpc_item *item)
-{
-	struct c2_rpc_frm_sm *frm_sm;
-
-	C2_PRE(item != NULL);
-	C2_PRE(!c2_rpc_item_is_bound(item));
-
-	frm_sm = item_to_frm_sm(item);
-	sm_updating_state(frm_sm, item);
-}
-
-/* Callback function for <struct c2_net_buffer> which indicates that
-  message has been sent out from the buffer. */
-void frm_net_buffer_sent(const struct c2_net_buffer_event *ev)
-{
-	struct c2_rpc			*rpc;
-	struct c2_net_buffer		*nb;
-	struct c2_rpc_frm_buffer	*fb;
-	struct c2_rpc_item		*item;
-	struct c2_rpc_item		*item_next;
-	struct c2_rpc_frm_sm		*frm_sm;
-
-	C2_PRE(ev != NULL && ev->nbe_buffer != NULL &&
-		ev->nbe_buffer->nb_qtype == C2_NET_QT_MSG_SEND);
-
-	nb = ev->nbe_buffer;
-	fb = container_of(nb, struct c2_rpc_frm_buffer, fb_buffer);
-	rpc = container_of(fb, struct c2_rpc, r_fbuf);
-	frm_sm = fb->fb_frm_sm;
-	C2_PRE(frm_buf_invariant(fb));
-	C2_PRE(frm_sm != NULL);
-
-	/* The buffer should have been dequeued by now. */
-	C2_ASSERT((nb->nb_flags & C2_NET_BUF_QUEUED) == 0);
-
-	/* Formation state machine lock is needed to serialize
-	   access to rpc object. */
-	c2_mutex_lock(&frm_sm->fs_lock);
-	if (ev->nbe_status == 0) {
-		frm_item_rpc_stats_set(rpc);
-		frm_item_state_set(rpc, RPC_ITEM_SENT);
-	} else {
-		C2_ADDB_ADD(&fb->fb_frm_sm->fs_rpc_form_addb,
-			    &frm_addb_loc, formation_func_fail,
-			    "net buf send failed", ev->nbe_status);
-		frm_item_state_set(rpc, RPC_ITEM_SEND_FAILED);
-	}
-	/* Detach all rpc items from this object */
-	c2_list_for_each_entry_safe(&rpc->r_items, item, item_next,
-			struct c2_rpc_item, ri_rpcobject_linkage) {
-		c2_list_del(&item->ri_rpcobject_linkage);
-	}
-
-	c2_rpcobj_fbuf_fini(fb);
-	c2_rpcobj_fini(rpc);
-	c2_free(rpc);
-	c2_mutex_unlock(&frm_sm->fs_lock);
-}
-
-/* Callback function for deletion of an rpc item from the formation lists. */
-int c2_rpc_frm_item_delete(struct c2_rpc_item *item)
-{
-	struct c2_rpc_frm_sm *frm_sm;
-
-	C2_PRE(item != NULL);
-
-	frm_sm = item_to_frm_sm(item);
-	c2_mutex_lock(&frm_sm->fs_lock);
-	frm_item_remove(frm_sm, item);
-	c2_mutex_unlock(&frm_sm->fs_lock);
-	return 0;
-}
-
-/* Callback function for setting priority of rpc item after it is
-   submitted to rpc layer. */
-void c2_rpc_frm_item_priority_set(struct c2_rpc_item *item,
-		enum c2_rpc_item_priority prio)
-{
-	struct c2_rpc_frm_sm *frm_sm;
-
-	C2_PRE(item != NULL);
-	C2_PRE(prio < C2_RPC_ITEM_PRIO_NR);
-
-	frm_sm = item_to_frm_sm(item);
-
-	c2_mutex_lock(&frm_sm->fs_lock);
-	frm_item_remove(frm_sm, item);
-	item->ri_prio = prio;
-	frm_item_add(frm_sm, item);
-	c2_mutex_unlock(&frm_sm->fs_lock);
-}
-
-/* Callback function for setting deadline of rpc item after it is
-   submitted to rpc layer. */
-void c2_rpc_frm_item_deadline_set(struct c2_rpc_item *item, c2_time_t deadline)
-{
-	struct c2_rpc_frm_sm *frm_sm;
-
-	C2_PRE(item != NULL);
-
-	frm_sm = item_to_frm_sm(item);
-
-	c2_mutex_lock(&frm_sm->fs_lock);
-	frm_item_remove(frm_sm, item);
-	item->ri_deadline = deadline;
-	frm_item_add(frm_sm, item);
-	c2_mutex_unlock(&frm_sm->fs_lock);
-}
-
-/* Callback function for changing group of rpc item after it is
-   submitted to rpc layer. */
-void c2_rpc_frm_item_group_set(struct c2_rpc_item *item,
-			       struct c2_rpc_group *group)
-{
-	struct c2_rpc_frm_sm *frm_sm;
-
-	C2_PRE(item != NULL);
-
-	frm_sm = item_to_frm_sm(item);
-
-	c2_mutex_lock(&frm_sm->fs_lock);
-	frm_item_remove(frm_sm, item);
-	item->ri_group = group;
-	frm_item_add(frm_sm, item);
-	c2_mutex_unlock(&frm_sm->fs_lock);
-}
-
-static void frm_reply_received(struct c2_rpc_frm_sm *frm_sm,
-			       struct c2_rpc_item *item,
-			       struct c2_rpc_item *reply)
-{
-	struct c2_rpc_frm_item_coalesced *c_item;
-	struct c2_rpc_frm_item_coalesced *c_item_next;
-
-	C2_PRE(frm_sm != NULL);
-	C2_PRE(c2_mutex_is_locked(&frm_sm->fs_lock));
-	C2_PRE(item != NULL);
-
-	c2_list_for_each_entry_safe(&frm_sm->fs_coalesced_items,
-			c_item, c_item_next, struct c2_rpc_frm_item_coalesced,
-			ic_linkage) {
-		if (c_item->ic_resultant_item == item)
-			coalesced_item_reply_post(c_item, reply);
-	}
-}
-
-/* Callback function for reply received of an rpc item. */
-void frm_item_reply_received(struct c2_rpc_item *reply_item,
-			     struct c2_rpc_item *req_item)
-{
-	struct c2_rpc_frm_sm		*frm_sm;
-
-	C2_PRE(req_item != NULL);
-
-	frm_sm = item_to_frm_sm(req_item);
-
-	c2_mutex_lock(&frm_sm->fs_lock);
-	frm_reply_received(frm_sm, req_item, reply_item);
-	c2_mutex_unlock(&frm_sm->fs_lock);
-	sm_forming_state(frm_sm, req_item);
-}
-
-static void item_deadline_handle(struct c2_rpc_frm_sm *frm_sm,
-				struct c2_rpc_item *item)
-{
-	struct c2_list		*list;
-	struct c2_rpc_session	*session;
-
-	C2_PRE(frm_sm != NULL);
-	C2_PRE(item != NULL);
-	C2_PRE(item->ri_state == RPC_ITEM_SUBMITTED);
-	C2_PRE(c2_mutex_is_locked(&frm_sm->fs_lock));
-
-	/* Move the rpc item to first list in unformed item data structure
-	   so that it is bundled first in the rpc being formed. */
-	if (c2_rpc_item_is_bound(item)) {
-		c2_list_del(&item->ri_unformed_linkage);
-		list = &frm_sm->fs_unformed[C2_RPC_ITEM_PRIO_NR -
-			(item->ri_prio + 1)].pl_unformed_items;
-		c2_list_add(list, &item->ri_unformed_linkage);
-	} else {
-		session = item->ri_session;
-		c2_mutex_lock(&session->s_mutex);
-		c2_list_move(&session->s_unbound_items, &item->ri_unbound_link);
-		c2_mutex_unlock(&session->s_mutex);
-	}
-	++frm_sm->fs_timedout_items_nr;
-}
-
-/* Callback function for deadline expiry of an rpc item. */
-void frm_item_deadline(struct c2_rpc_item *item)
-{
-	struct c2_rpc_frm_sm	*frm_sm;
-
-	C2_PRE(item != NULL);
-
-	frm_sm = item_to_frm_sm(item);
-	c2_mutex_lock(&frm_sm->fs_lock);
-	item_deadline_handle(frm_sm, item);
-	c2_mutex_unlock(&frm_sm->fs_lock);
-	sm_forming_state(frm_sm, item);
-}
-
-static void coalesced_item_reply_post(struct c2_rpc_frm_item_coalesced *cs,
-				      struct c2_rpc_item *reply)
-{
-	struct c2_rpc_item *item;
-	struct c2_rpc_item *item_next;
-
-	C2_PRE(cs != NULL);
-
-	/* For all member items of coalesced_item struct, call
-	   their completion callbacks. */
-	c2_list_for_each_entry_safe(&cs->ic_member_list, item, item_next,
-			struct c2_rpc_item, ri_coalesced_linkage) {
-		c2_list_del(&item->ri_coalesced_linkage);
-		rpc_item_replied(item, reply, 0);
-	}
-	item = cs->ic_resultant_item;
-	item->ri_type->rit_ops->rito_iovec_restore(item, cs->ic_bkpfop);
-	coalesced_item_fini(cs);
-}
-
-/* Callback for timer expiry of an rpc item. */
-static unsigned long item_timer_callback(unsigned long data)
-{
-	struct c2_rpc_item *item;
-
-	item = (struct c2_rpc_item*)data;
-
-	if (item->ri_state == RPC_ITEM_SUBMITTED)
-		frm_item_deadline(item);
-	/* Returning 0 since timer routine ignores return values. */
-	return 0;
-}
-
-static struct c2_rpc_frm_group *frm_rpcgroup_locate(
-		const struct c2_rpc_frm_sm *frm_sm,
-		const struct c2_rpc_item *item)
-{
-	struct c2_rpc_frm_group *rg;
-
-	C2_PRE(frm_sm != NULL);
-	C2_PRE(c2_mutex_is_locked(&frm_sm->fs_lock));
-	C2_PRE(item != NULL);
-	C2_PRE(item->ri_group != NULL);
-
-	c2_list_for_each_entry(&frm_sm->fs_groups, rg,
-			struct c2_rpc_frm_group, frg_linkage) {
-		if (rg->frg_group == item->ri_group)
-			return rg;
-	}
-	return NULL;
-}
-
-static struct c2_rpc_frm_group *frm_rpcgroup_init(
-		struct c2_rpc_frm_sm *frm_sm, const struct c2_rpc_item *item)
-{
-	struct c2_rpc_frm_group	*rg;
-
-	C2_PRE(frm_sm != NULL);
-	C2_PRE(c2_mutex_is_locked(&frm_sm->fs_lock));
-	C2_PRE(item != NULL);
-	C2_PRE(item->ri_group != NULL);
-
-	C2_ALLOC_PTR_ADDB(rg, &frm_sm->fs_rpc_form_addb, &frm_addb_loc);
-	if (rg == NULL)
-		return NULL;
-	c2_list_link_init(&rg->frg_linkage);
-	c2_list_add(&frm_sm->fs_groups, &rg->frg_linkage);
-	rg->frg_group = item->ri_group;
-	return rg;
-}
-
-static void frm_rpcgroup_fini(struct c2_rpc_frm_group *rg)
-{
-	C2_PRE(rg != NULL);
-	c2_list_del(&rg->frg_linkage);
-	c2_free(rg);
-}
-
-/* Remove data of rpc item embedded within the formation state machine. */
-static void frm_item_remove(struct c2_rpc_frm_sm *frm_sm,
-			    struct c2_rpc_item *item)
-{
-	size_t			 item_size;
-	struct c2_rpc_frm_group	*rg;
-
-	C2_PRE(item != NULL);
-	C2_PRE(frm_sm != NULL);
-	C2_PRE(c2_mutex_is_locked(&frm_sm->fs_lock));
-	C2_PRE(item->ri_state == RPC_ITEM_SUBMITTED);
-
-	/* Reduce the cumulative size of rpc items from formation
-	   state machine. */
-	item_size = item->ri_type->rit_ops->rito_item_size(item);
-	frm_sm->fs_cumulative_size -= item_size;
-	C2_ASSERT(frm_sm->fs_items_left > 0);
-	--frm_sm->fs_items_left;
-
-	/* If timer of rpc item is still running, change the deadline in
-	   rpc item as per remaining time and stop and fini the timer. */
-	if (item->ri_deadline != 0) {
-		item->ri_deadline = 0;
-		c2_timer_stop(&item->ri_timer);
-		c2_timer_fini(&item->ri_timer);
-	} else {
-		C2_ASSERT(frm_sm->fs_timedout_items_nr > 0);
-		--frm_sm->fs_timedout_items_nr;
-		if (item->ri_group == NULL)
-			frm_sm->fs_urgent_nogrp_items_nr--;
-	}
-
-	/* If item is bound, remove it from formation state machine data. */
-	if (c2_rpc_item_is_bound(item))
-		c2_list_del(&item->ri_unformed_linkage);
-
-	if (item->ri_group == NULL)
-		return;
-
-	rg = frm_rpcgroup_locate(frm_sm, item);
-	if (rg == NULL)
-		return;
-
-	/* If the referred rpc group was complete earlier, then afer
-	   removing this rpc item, the rpc group will be incomplete,
-	   hence decrement the counter of complete groups. */
-	if (rg->frg_items_nr == rg->frg_expected_items_nr)
-		frm_sm->fs_complete_groups_nr--;
-
-	/* Remove the data entered by this item in this rpc group.*/
-	if (--rg->frg_items_nr == 0)
-		frm_rpcgroup_fini(rg);
-}
-
-/* Update formation state machine data on addition of an rpc item. */
-static void frm_item_add(struct c2_rpc_frm_sm *frm_sm, struct c2_rpc_item *item)
-{
-	int				 rc;
-	bool				 item_inserted = false;
-	size_t				 item_size;
-	struct c2_list			*list;
-	struct c2_rpc_item		*rpc_item;
-	struct c2_rpc_item		*rpc_item_next;
-	struct c2_rpc_session		*session;
-	struct c2_rpc_frm_group		*rg;
-
-	C2_PRE(item != NULL);
-	C2_PRE(frm_sm != NULL);
-	C2_PRE(c2_mutex_is_locked(&frm_sm->fs_lock));
-
-	if (item->ri_state != RPC_ITEM_SUBMITTED)
-		return;
-
-	item_size = item->ri_type->rit_ops->rito_item_size(item);
-	frm_sm->fs_cumulative_size += item_size;
-	++frm_sm->fs_items_left;
-
-	/* Initialize the timer only when the deadline value is non-zero
-	   i.e. dont initialize the timer for URGENT items */
-	if (item->ri_deadline != 0) {
-		/* C2_TIMER_SOFT creates a different thread to handle the
-		   callback. */
-		c2_timer_init(&item->ri_timer, C2_TIMER_SOFT, item->ri_deadline,
-				item_timer_callback, (unsigned long)item);
-		rc = c2_timer_start(&item->ri_timer);
-		if (rc != 0) {
-			C2_ADDB_ADD(&frm_sm->fs_rpc_form_addb,
-				&frm_addb_loc, formation_func_fail,
-				"frm_item_add", rc);
-			return;
-		}
-	} else {
-		++frm_sm->fs_timedout_items_nr;
-		if (item->ri_group == NULL)
-			++frm_sm->fs_urgent_nogrp_items_nr;
-	}
-
-	/* If item is unbound or unsolicited, don't add it to list
-	   of formation state machine. */
-	if (!c2_rpc_item_is_bound(item)) {
-		/* Add the item to list of unbound items in its session. */
-		session = item->ri_session;
-		C2_ASSERT(session != NULL);
-
-		c2_mutex_lock(&session->s_mutex);
-
-		C2_ASSERT(c2_rpc_session_invariant(session));
-		C2_ASSERT(session->s_state == C2_RPC_SESSION_IDLE ||
-			  session->s_state == C2_RPC_SESSION_BUSY);
-
-		c2_list_add(&session->s_unbound_items, &item->ri_unbound_link);
-		session->s_state = C2_RPC_SESSION_BUSY;
-
-		C2_ASSERT(c2_rpc_session_invariant(session));
-
-		c2_mutex_unlock(&session->s_mutex);
-		return;
-	}
-
-	/* Index into the array to find out correct list as per
-	   priority of current rpc item. */
-	C2_ASSERT(item->ri_prio < C2_RPC_ITEM_PRIO_NR);
-	list = &frm_sm->fs_unformed[C2_RPC_ITEM_PRIO_NR -
-	       (item->ri_prio + 1)].pl_unformed_items;
-
-	/* Insert the item into unformed list sorted according to deadline. */
-	c2_list_for_each_entry_safe(list, rpc_item, rpc_item_next,
-			struct c2_rpc_item, ri_unformed_linkage) {
-		if (item->ri_deadline <= rpc_item->ri_deadline) {
-			c2_list_add_before(&rpc_item->ri_unformed_linkage,
-					&item->ri_unformed_linkage);
-			item_inserted = true;
-			break;
-		}
-	}
-	if (!item_inserted)
-		c2_list_add_after(&rpc_item->ri_unformed_linkage,
-				&item->ri_unformed_linkage);
-
-	/* If item does not belong to any rpc group, no rpc group
-	   processing will be done for this item. */
-	if (item->ri_group == NULL)
-		return;
-
-	/* Search for the group of rpc item in list of rpc groups in frm_sm. */
-	rg = frm_rpcgroup_locate(frm_sm, item);
-	if (rg == NULL)
-		rg = frm_rpcgroup_init(frm_sm, item);
-
-	rg->frg_expected_items_nr = item->ri_group->rg_expected;
-	rg->frg_items_nr++;
-
-	/* If number of items from this rpc group match the expected
-	   items number, all items from this group are present with
-	   current formation state machine, so the complete groups
-	   counter is incremented. */
-	if (rg->frg_items_nr == rg->frg_expected_items_nr)
-		frm_sm->fs_complete_groups_nr++;
-}
-
-/* Decides if an optimal rpc can be prepared from the items submitted
-   to this formation state machine. */
-static bool frm_size_is_violated(struct c2_rpc_frm_sm *frm_sm,
-				 uint64_t rpcobj_size, size_t item_size)
-{
-	C2_PRE(frm_sm != NULL);
-
-	if (rpcobj_size + item_size >= frm_sm->fs_max_msg_size)
-		return true;
-
-	return false;
-}
-
-/* Policy function to dictate if an rpc should be formed or not. */
-static bool frm_check_policies(struct c2_rpc_frm_sm *frm_sm)
-{
-	return
-		/* If there are any rpc items whose deadline is expired,
-		   trigger formation. */
-		frm_sm->fs_timedout_items_nr > 0 ||
-		/* Number of urgent items which do not belong to any rpc group
-		   added to this state machine so far.
-		   Any number > 0 will trigger formation. */
-		frm_sm->fs_urgent_nogrp_items_nr > 0 ||
-		/* Number of complete groups in the sense that this state
-		   machine contains all rpc items from such rpc groups.
-		   Any number > 0 will trigger formation. */
-		frm_sm->fs_complete_groups_nr > 0;
-}
-
-/* Checks whether the items gathered so far in formation state machine
-   are good enough to form an rpc object and proceed to forming state. */
-static bool formation_qualify(const struct c2_rpc_frm_sm *frm_sm)
-{
-	C2_PRE(frm_sm != NULL);
-
-	return
-		/* If current rpcs in flight for this formation state machine
-		   has reached the max rpcs limit, don't send any more rpcs
-		   unless this number drops. */
-		(!frm_sm->fs_sender_side ||
-		 frm_sm->fs_curr_rpcs_in_flight <
-		 frm_sm->fs_max_rpcs_in_flight) &&
-		(frm_sm->fs_urgent_nogrp_items_nr > 0 ||
-		 frm_sm->fs_cumulative_size >= frm_sm->fs_max_msg_size);
-}
-
-/* State function for UPDATING state. Formation state machine is updated
-   with contents of incoming rpc item. */
-static void sm_updating_state(struct c2_rpc_frm_sm *frm_sm,
-			      struct c2_rpc_item *item)
-{
-	bool qualify;
-
-	C2_PRE(item != NULL);
-	c2_mutex_lock(&frm_sm->fs_lock);
-	C2_PRE(frm_sm_invariant(frm_sm));
-
-	frm_sm->fs_state = C2_RPC_FRM_STATE_UPDATING;
-
-	/* If incoming item is conn establish, this is sender side of
-	   a rpc connection, so current rpcs in flight have a threshold
-	   of max_rpcs_in_flight. */
-	if (c2_rpc_item_is_conn_establish(item))
-		frm_sm->fs_sender_side = true;
-
-	/* Add the item to frm_sm and subsequently to corresponding
-	   priority list. */
-	frm_item_add(frm_sm, item);
-
-	/* Move the thread to the checking state only if an optimal rpc
-	   can be formed. */
-	C2_POST(frm_sm_invariant(frm_sm));
-	qualify = formation_qualify(frm_sm);
-	c2_mutex_unlock(&frm_sm->fs_lock);
-	if (qualify)
-		sm_forming_state(frm_sm, item);
-}
-
-/* Checks if addition of current fragment count and number of fragments
-   from current rpc item fit within max_fragments count from formation
-   state machine. Returns TRUE if current count of fragments fit within
-   max value, FALSE otherwise. */
-static bool frm_fragment_policy_in_bounds(const struct c2_rpc_frm_sm *frm_sm,
-		struct c2_rpc_item *item, uint64_t *frag_nr)
-{
-	uint64_t curr_fragments;
-
-	C2_PRE(frm_sm != NULL);
-	C2_PRE(item != NULL);
-	C2_PRE(frag_nr != NULL);
-
-	if (item->ri_type->rit_ops->rito_get_io_fragment_count) {
-		curr_fragments = item->ri_type->rit_ops->
-			rito_get_io_fragment_count(item);
-		if ((*frag_nr + curr_fragments) > frm_sm->fs_max_frags)
-			return false;
-	}
-	return true;
-}
-
-/* Add an rpc item to the formed list of an rpc object. */
-static void frm_add_to_rpc(struct c2_rpc_frm_sm *frm_sm,
-		struct c2_rpc *rpc, struct c2_rpc_item *item,
-		uint64_t *rpcobj_size, uint64_t *frag_nr)
-{
-	struct c2_rpc_slot *slot;
-
-	C2_PRE(frm_sm != NULL);
-	C2_PRE(item != NULL);
-	C2_PRE(rpcobj_size != NULL);
-	C2_PRE(frag_nr != NULL);
-	C2_PRE(item->ri_state != RPC_ITEM_ADDED);
-
-	/* Update size of rpc object and current count of fragments. */
-	c2_list_add(&rpc->r_items, &item->ri_rpcobject_linkage);
-	*rpcobj_size += item->ri_type->rit_ops->rito_item_size(item);
-	if (item->ri_type->rit_ops->rito_get_io_fragment_count != NULL)
-		*frag_nr += item->ri_type->rit_ops->
-			rito_get_io_fragment_count(item);
-
-	/* Remove the item data from c2_rpc_frm_sm structure. */
-	frm_item_remove(frm_sm, item);
-	item->ri_state = RPC_ITEM_ADDED;
-
-	/* Remove item from slot->ready_items list AND if slot->ready_items
-	   list is empty, remove slot from rpcmachine->ready_slots list.*/
-	slot = item->ri_slot_refs[0].sr_slot;
-	C2_ASSERT(slot != NULL);
-	c2_list_del(&item->ri_slot_refs[0].sr_ready_link);
-	if (c2_list_link_is_in(&slot->sl_link))
-		c2_list_del(&slot->sl_link);
-}
-
-/* Create a new c2_rpc_frm_item_coalesced structure and populate it. */
-static struct c2_rpc_frm_item_coalesced *coalesced_item_init(
-		struct c2_rpc_frm_sm *frm_sm)
-{
-	struct c2_rpc_frm_item_coalesced *c_item;
-
-	C2_PRE(frm_sm != NULL);
-
-	C2_ALLOC_PTR_ADDB(c_item, &frm_sm->fs_rpc_form_addb, &frm_addb_loc);
-	if (c_item == NULL)
-		return NULL;
-	c2_list_link_init(&c_item->ic_linkage);
-	c_item->ic_resultant_item = NULL;
-	c_item->ic_bkpfop = NULL;
-	c2_list_init(&c_item->ic_member_list);
-	/* Add newly created coalesced_item into list of fs_coalesced_items
-	   in formation state machine. */
-	c2_list_add(&frm_sm->fs_coalesced_items, &c_item->ic_linkage);
-
-	return c_item;
-}
-
-static void coalesced_item_fini(struct c2_rpc_frm_item_coalesced *c_item)
-{
-	C2_PRE(c_item != NULL);
-
-	c2_list_fini(&c_item->ic_member_list);
-	c2_list_del(&c_item->ic_linkage);
-	c2_free(c_item);
-}
-
-static void frm_coalesced_item_populate(struct c2_rpc_item *b_item,
-		struct c2_rpc_frm_item_coalesced *c_item)
-{
-	bool			 item_equal;
-	bool			 fid_equal;
-	struct c2_rpc_item	*ub_item;
-	struct c2_rpc_session	*session;
-
-	C2_PRE(b_item != NULL);
-	C2_PRE(c_item != NULL);
-
-	session = b_item->ri_session;
-	C2_ASSERT(session != NULL);
-	C2_PRE(c2_mutex_is_locked(&session->s_mutex));
-
-	/* If fid and intent(read/write) of any unbound rpc item
-	   are same as that of bound rpc item, add the given
-	   unbound item as a member of current coalesced item structure. */
-	c2_list_for_each_entry(&session->s_unbound_items, ub_item,
-			struct c2_rpc_item, ri_unbound_link) {
-		if (!ub_item->ri_type->rit_ops->rito_io_coalesce)
-			continue;
-
-		fid_equal = ub_item->ri_type->rit_ops->rito_fid_equal
-			    (b_item, ub_item);
-		item_equal = b_item->ri_type->rit_ops->rito_items_equal
-			    (b_item, ub_item);
-		if (fid_equal && item_equal)
-			c2_list_add(&c_item->ic_member_list,
-					&ub_item->ri_coalesced_linkage);
-	}
-}
-
-/* Try to coalesce rpc items from the session->free list. */
-static int coalesce_try(struct c2_rpc_frm_sm *frm_sm, struct c2_rpc_item *item,
-			uint64_t *rpcobj_size)
-{
-	int					 rc;
-	uint64_t				 old_size;
-	struct c2_rpc_item			*ub_item;
-	struct c2_rpc_session			*session;
-	struct c2_rpc_frm_item_coalesced	*c_item;
-
-	C2_PRE(item != NULL);
-	C2_PRE(frm_sm != NULL);
-
-	session = item->ri_session;
-	C2_ASSERT(session != NULL);
-	C2_PRE(c2_mutex_is_locked(&session->s_mutex));
-
-	/* If there are no unbound items to coalesce, return right away. */
-	if (c2_list_is_empty(&session->s_unbound_items))
-		return -EINVAL;
-
-	/* Similarly, if given rpc item is not part of an IO request,
-	   return right away. */
-	if (!item->ri_type->rit_ops->rito_io_coalesce)
-		return -EINVAL;
-
-	old_size = item->ri_type->rit_ops->rito_item_size(item);
-
-	c_item = coalesced_item_init(frm_sm);
-	if (c_item == NULL) {
-		C2_ADDB_ADD(&frm_sm->fs_rpc_form_addb,
-				&frm_addb_loc, c2_addb_oom);
-		return -ENOMEM;
-	}
-
-	frm_coalesced_item_populate(item, c_item);
-	if (c2_list_is_empty(&c_item->ic_member_list)) {
-		coalesced_item_fini(c_item);
-		return -EINVAL;
-	}
-
-	/* Add the bound rpc item to member list so that it's IO segments
-	   will also be coalesced. */
-	c2_list_add(&c_item->ic_member_list,
-			&item->ri_coalesced_linkage);
-
-	/* Try to coalesce IO segments of all member items. */
-	rc = item->ri_type->rit_ops->rito_io_coalesce(c_item, item);
-
-	/* Remove the bound item from list of member elements
-	   from a coalesced_item struct.*/
-	c2_list_del(&item->ri_coalesced_linkage);
-
-	if (rc == 0) {
-		*rpcobj_size -= old_size;
-		*rpcobj_size += item->ri_type->rit_ops->rito_item_size(item);
-		/* Delete all member items for which coalescing was
-		   successful from session->unbound list. */
-		c2_list_for_each_entry(&c_item->ic_member_list, ub_item,
-				struct c2_rpc_item, ri_coalesced_linkage)
-			c2_list_del(&ub_item->ri_unbound_link);
-	}
-
-	return rc;
-}
-
-/* Add bound items to rpc object. Rpc items are added until size gets
-   optimal or any other policy of formation module has met. */
-static void bound_items_add_to_rpc(struct c2_rpc_frm_sm *frm_sm,
-				   struct c2_rpc *rpcobj, uint64_t *rpcobj_size,
-				   uint64_t *frag_nr)
-{
-	int			 cnt;
-	int			 rc;
-	bool			 sz_policy_violated = false;
-	bool			 frags_policy_ok = false;
-	uint64_t		 rpc_size;
-	struct c2_list		*list;
-	struct c2_rpc_item	*rpc_item;
-	struct c2_rpc_item	*rpc_item_next;
-	struct c2_rpcmachine	*rpcmachine;
-	struct c2_rpc_session	*session;
-
-	C2_PRE(frm_sm != NULL);
-	C2_PRE(c2_mutex_is_locked(&frm_sm->fs_lock));
-	C2_PRE(rpcobj_size != NULL);
-	C2_PRE(frag_nr != NULL);
-	C2_PRE(rpcobj != NULL);
-
-	/* Iterate over the priority bands and add items arranged in
-	   increasing order of deadlines till rpc is optimal.
-	   Algorithm skips the rpc items for which policies other than
-	   size policy are not satisfied */
-	for (cnt = 0; cnt < ARRAY_SIZE(frm_sm->fs_unformed) &&
-			!sz_policy_violated; ++cnt) {
-		list = &frm_sm->fs_unformed[cnt].pl_unformed_items;
-		c2_list_for_each_entry_safe(list, rpc_item, rpc_item_next,
-				struct c2_rpc_item, ri_unformed_linkage) {
-			rpc_size = *rpcobj_size;
-			sz_policy_violated = frm_size_is_violated(frm_sm,
-					rpc_size, rpc_item->ri_type->rit_ops->
-					rito_item_size(rpc_item));
-			rpcmachine = rpc_item->ri_session->s_conn->c_rpcmachine;
-
-			/* If size threshold is not reached or other formation
-			   policies are met, add item to rpc object. */
-			if (!sz_policy_violated) {
-				frags_policy_ok = frm_fragment_policy_in_bounds(
-						  frm_sm, rpc_item, frag_nr);
-				if (frags_policy_ok) {
-					c2_mutex_lock(&rpcmachine->
-							cr_ready_slots_mutex);
-					frm_add_to_rpc(frm_sm, rpcobj,
-							rpc_item, rpcobj_size,
-							frag_nr);
-					c2_mutex_unlock(&rpcmachine->
-							cr_ready_slots_mutex);
-					/* Try to coalesce current bound
-					   item with list of unbound items
-					   in its rpc session. */
-					session = rpc_item->ri_session;
-					c2_mutex_lock(&session->s_mutex);
-					rc = coalesce_try(frm_sm, rpc_item,
-							rpcobj_size);
-					c2_mutex_unlock(&session->s_mutex);
-					if (rc != 0) {
-						/* Handle error... */
-					}
-				}
-			} else
-				break;
-		}
-	}
-	rpc_size = *rpcobj_size;
-	C2_POST(!frm_size_is_violated(frm_sm, rpc_size, 0));
-}
-
-/* Make an unbound item (which is not unsolicited) bound by calling
-   item_add_internal(). Also change item type flags accordingly. */
-static void frm_item_make_bound(struct c2_rpc_slot *slot,
-				struct c2_rpc_item *item)
-{
-	C2_PRE(slot != NULL);
-	C2_PRE(item != NULL);
-	C2_PRE(!c2_rpc_item_is_bound(item));
-
-	if (!c2_rpc_item_is_unsolicited(item)) {
-		c2_rpc_slot_item_add_internal(slot, item);
-		c2_list_add(&slot->sl_ready_list,
-				&item->ri_slot_refs[0].sr_ready_link);
-	}
-}
-
-/* Make unbound items bound first and then add items to rpc object
-   until rpc becomes optimal size or other formation policies are met. */
-static void unbound_items_add_to_rpc(struct c2_rpc_frm_sm *frm_sm,
-				     struct c2_rpc *rpcobj,
-				     uint64_t *rpcobj_size, uint64_t *frag_nr)
-{
-	int			 rc;
-	bool			 sz_policy_violated = false;
-	bool			 frags_policy_ok = false;
-	uint64_t		 rpc_size;
-	struct c2_rpc_item	*item;
-	struct c2_rpc_item	*item_next;
-	struct c2_rpc_slot	*slot;
-	struct c2_rpc_slot	*slot_next;
-	struct c2_rpc_chan	*chan;
-	struct c2_rpcmachine	*rpcmachine;
-	struct c2_rpc_session	*session;
-
-	C2_PRE(frm_sm != NULL);
-	C2_PRE(rpcobj != NULL);
-	C2_PRE(frag_nr != NULL);
-	C2_PRE(rpcobj_size != NULL);
-	C2_PRE(c2_mutex_is_locked(&frm_sm->fs_lock));
-
-	/* Get slot and verno info from sessions component for
-	   any unbound items in session->free list. */
-	chan = container_of(frm_sm, struct c2_rpc_chan, rc_frmsm);
-	C2_ASSERT(chan != NULL);
-	rpcmachine = chan->rc_rpcmachine;
-	C2_ASSERT(rpcmachine != NULL);
-	c2_mutex_lock(&rpcmachine->cr_ready_slots_mutex);
-
-	/* Iterate ready slots list from rpcmachine and try to find an
-	   item for each ready slot. */
-	c2_list_for_each_entry_safe(&rpcmachine->cr_ready_slots, slot,
-			slot_next, struct c2_rpc_slot, sl_link) {
-		if (!c2_list_is_empty(&slot->sl_ready_list) ||
-		    (slot->sl_session->s_conn->c_rpcchan != chan))
-			continue;
-
-		c2_mutex_lock(&slot->sl_mutex);
-		session = slot->sl_session;
-		c2_mutex_lock(&session->s_mutex);
-		c2_list_for_each_entry_safe(&session->s_unbound_items,
-				item, item_next, struct c2_rpc_item,
-				ri_unbound_link) {
-			/* This is the way slot is supposed to be handled
-			   by sessions code. */
-			if (!c2_rpc_slot_can_item_add_internal(slot))
-				break;
-			/* Check if this item has been submitted to
-			   formation module. If not, skip the item. */
-			rpc_size = *rpcobj_size;
-			sz_policy_violated = frm_size_is_violated(frm_sm,
-					rpc_size, item->ri_type->rit_ops->
-					rito_item_size(item));
-			if (!sz_policy_violated) {
-				frags_policy_ok = frm_fragment_policy_in_bounds(
-						  frm_sm, item, frag_nr);
-				if (frags_policy_ok) {
-					frm_item_make_bound(slot, item);
-					frm_add_to_rpc(frm_sm, rpcobj, item,
-						       rpcobj_size, frag_nr);
-					c2_list_del(&item->ri_unbound_link);
-					rc = coalesce_try(frm_sm, item,
-							  rpcobj_size);
-					if (rc != 0) {
-						/* Handle error... */
-					}
-				}
-			} else
-				break;
-		}
-		c2_mutex_unlock(&session->s_mutex);
-		c2_mutex_unlock(&slot->sl_mutex);
-		/* Algorithm skips the rpc items for which policies other than
-		   size policy are not satisfied. */
-		if (sz_policy_violated)
-			break;
-	}
-	c2_mutex_unlock(&rpcmachine->cr_ready_slots_mutex);
-	rpc_size = *rpcobj_size;
-	C2_POST(!frm_size_is_violated(frm_sm, rpc_size, 0));
-}
-
-/* State function for FORMING state. Core of formation algorithm.
-   It scans the lists of rpc items to form an RPC object by cooperation
-   of multiple policies. Formation algorithm takes hints from rpc groups
-   and will try to form rpc objects by keeping all group member rpc items
-   together. Forming state will take care of coalescing of items.
-   Coalescing Policy:
-   A stream of unbound items will be coalesced together in a bound item
-   if they happen to share the fid and intent of a read/write operation.
-   The bound item will be formed into an rpc and the member unbound items
-   will be hanging off the coalesced item data structure.
-   *** Formation Algorithm ***
-   1. Check all formation policies to see if an rpc can be formed.
-   2. If rpc can be formed, go through all bound items and add them to rpc.
-   3. If space permits, add unbound items to rpc. All unbound items are
-      made bound before they are included in rpc.
-   4. Step 2 and 3 include IO coalescing which happens between a bound
-      item and a stream of unbound items. On successful coalescing, the
-      resultant IO vector is associated with the bound item and it is
-      included in the rpc while the unbound items are hanging off the
-      coalesced bound item.
-   5. Send the prepared rpc on wire. The rpc is encoded here and the
-      resulting network buffer is sent to destination using a network
-      transfer machine. */
-static void sm_forming_state(struct c2_rpc_frm_sm *frm_sm,
-			     struct c2_rpc_item *item)
-{
-	bool		 size_optimal;
-	bool		 frm_policy;
-	uint64_t	 frag_nr = 0;
-	uint64_t	 rpcobj_size = 0;
-	struct c2_rpc	*rpcobj;
-
-	C2_PRE(item != NULL);
-
-	c2_mutex_lock(&frm_sm->fs_lock);
-	C2_PRE(frm_sm_invariant(frm_sm));
-	frm_sm->fs_state = C2_RPC_FRM_STATE_FORMING;
-
-	/* If fs_rpcs list is non-empty, send the already formed rpcs
-	   first. Appropriate ADDB messages are posted in frm_send_onwire(). */
-	if (!c2_list_is_empty(&frm_sm->fs_rpcs))
-		frm_send_onwire(frm_sm);
-
-	/* If optimal rpc can not be formed, or other formation policies
-	   do not satisfy, return failure. */
-	size_optimal = frm_size_is_violated(frm_sm, frm_sm->fs_cumulative_size,
-					    0);
-	frm_policy = frm_check_policies(frm_sm);
-
-	if (!(frm_policy || size_optimal)) {
-		C2_ADDB_ADD(&frm_sm->fs_rpc_form_addb,
-			    &frm_addb_loc, formation_func_fail,
-			    "Optimal rpc can not be formed.",
-			    -EINVAL);
-		goto cleanup;
-	}
-
-	/* Create an rpc object in frm_sm->isu_rpcobj_list. */
-	C2_ALLOC_PTR_ADDB(rpcobj, &frm_sm->fs_rpc_form_addb, &frm_addb_loc);
-	if (rpcobj == NULL) {
-		C2_ADDB_ADD(&frm_sm->fs_rpc_form_addb,
-			    &frm_addb_loc, c2_addb_oom);
-		goto cleanup;
-	}
-	c2_rpcobj_init(rpcobj);
-
-	/* Try to include bound rpc items in rpc. This routine also includes
-	   IO coalescing amongst a bound item and a stream of unbound items. */
-	bound_items_add_to_rpc(frm_sm, rpcobj, &rpcobj_size, &frag_nr);
-
-	/* Try to include unbound rpc items in rpc. Unbound items are made
-	   bound once they are included in rpc. */
-	unbound_items_add_to_rpc(frm_sm, rpcobj, &rpcobj_size, &frag_nr);
-
-	if (c2_list_is_empty(&rpcobj->r_items)) {
-		c2_rpcobj_fini(rpcobj);
-		c2_free(rpcobj);
-		goto cleanup;
-	}
-
-	c2_list_add(&frm_sm->fs_rpcs, &rpcobj->r_linkage);
-
-	/* Send the prepared rpc on wire to destination. */
-	frm_send_onwire(frm_sm);
-	C2_POST(frm_sm_invariant(frm_sm));
-cleanup:
-	frm_sm->fs_state = C2_RPC_FRM_STATE_WAITING;
-	c2_mutex_unlock(&frm_sm->fs_lock);
-}
-
-uint64_t rpc_size_get(const struct c2_rpc *rpc)
-{
-	uint64_t		 rpc_size = 0;
-	struct c2_rpc_item	*item;
-
-	C2_PRE(rpc != NULL);
-
-	c2_list_for_each_entry(&rpc->r_items, item,
-			struct c2_rpc_item, ri_rpcobject_linkage)
-		rpc_size += item->ri_type->rit_ops->rito_item_size(item);
-
-	return rpc_size;
-}
-
-static void frm_send_onwire(struct c2_rpc_frm_sm *frm_sm)
-{
-	int				 rc;
-	uint64_t			 rpc_size;
-	struct c2_rpc			*rpc_obj;
-	struct c2_rpc			*rpc_obj_next;
-	struct c2_net_domain		*dom;
-	struct c2_rpc_frm_buffer	*fb;
-	struct c2_net_transfer_mc	*tm;
-	struct c2_rpc_chan		*chan;
-
-	C2_PRE(frm_sm != NULL);
-	C2_PRE(c2_mutex_is_locked(&frm_sm->fs_lock));
-
-	chan = container_of(frm_sm, struct c2_rpc_chan, rc_frmsm);
-	/* Iterate over the rpc object list and send all rpc objects on wire. */
-	c2_list_for_each_entry_safe(&frm_sm->fs_rpcs, rpc_obj,
-			rpc_obj_next, struct c2_rpc, r_linkage) {
-		if (frm_sm->fs_sender_side &&
-				frm_sm->fs_curr_rpcs_in_flight >=
-				frm_sm->fs_max_rpcs_in_flight) {
-			rc = -EBUSY;
-			C2_ADDB_ADD(&frm_sm->fs_rpc_form_addb,
-					&frm_addb_loc, formation_func_fail,
-					"max in flight reached", rc);
-			break;
-		}
-		tm = &chan->rc_rpcmachine->cr_tm;
-		dom = tm->ntm_dom;
-		rpc_size = rpc_size_get(rpc_obj);
-		fb = &rpc_obj->r_fbuf;
-
-		rc = c2_rpcobj_fbuf_init(fb, frm_sm, dom, rpc_size);
-		if (rc < 0)
-			continue;
-
-		fb->fb_buffer.nb_ep = chan->rc_destep;
-		fb->fb_buffer.nb_length = rpc_size;
-
-		/** @todo Allocate bulk i/o buffers before encoding. */
-		/** @todo rpc_encode will encode the bulk i/o
-		   buffer descriptors. */
-		rc = c2_rpc_encode(rpc_obj, &fb->fb_buffer);
-		if (rc < 0) {
-			C2_ADDB_ADD(&frm_sm->fs_rpc_form_addb,
-					&frm_addb_loc, formation_func_fail,
-					"c2_rpc_encode failed.", rc);
-			continue;
-		}
-
-		/* Add the buffer to transfer machine.*/
-		rc = c2_net_buffer_add(&fb->fb_buffer, tm);
-		if (rc < 0) {
-			C2_ADDB_ADD(&frm_sm->fs_rpc_form_addb,
-					&frm_addb_loc, formation_func_fail,
-					"c2_net_buffer_add failed", rc);
-			continue;
-		}
-
-		C2_ASSERT(fb->fb_buffer.nb_tm->ntm_dom == tm->ntm_dom);
-		C2_ADDB_ADD(&frm_sm->fs_rpc_form_addb,
-			    &frm_addb_loc, formation_func_fail,
-			    "Rpc sent on wire.", 0);
-		if (frm_sm->fs_sender_side)
-			frm_sm->fs_curr_rpcs_in_flight++;
-		c2_list_del(&rpc_obj->r_linkage);
-	}
-}
-
-/* Decrement the current number of rpcs in flight from given rpc item. */
-void frm_rpcs_inflight_dec(struct c2_rpc_frm_sm *frm_sm)
-{
-	C2_PRE(frm_sm != NULL);
-
-	c2_mutex_lock(&frm_sm->fs_lock);
-
-	if (frm_sm->fs_sender_side) {
-		if (frm_sm->fs_curr_rpcs_in_flight > 0) {
-			frm_sm->fs_curr_rpcs_in_flight--;
-		}
-	}
-
-	c2_mutex_unlock(&frm_sm->fs_lock);
-}
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
diff --git a/rpc/formation.h b/rpc/formation.h
deleted file mode 100644
index a6b200f..0000000
--- a/rpc/formation.h
+++ /dev/null
@@ -1,325 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Anand Vidwansa <Anand_Vidwansa@xyratex.com>
- *                  Anup Barve <Anup_Barve@xyratex.com>
- * Original creation date: 04/25/2011
- */
-
-#ifndef __C2_RPC_FORMATION_H__
-#define __C2_RPC_FORMATION_H__
-
-#include "lib/list.h"
-#include "lib/mutex.h"
-#include "lib/rwlock.h"
-#include "addb/addb.h"
-
-struct c2_fop;
-
-/**
-   @defgroup rpc_formation Formation sub component from RPC layer.
-   @{
-
-   Formation component runs as a state machine driven by external events.
-   The state machine runs per network endpoint and it maintains state and its
-   internal data per endpoint.
-   There are no internal threads belonging to formation component.
-   Formation component uses the "RPC Items cache" as input and sends out
-   RPC objects which are containers of rpc items as soon as they are ready.
-   The grouping component populates the rpc items cache which is then
-   used by formation component to form them into rpc objects.
-   The rpc items cache is grouped into several lists, either in the list
-   of unbound items in some slot or list of ready items on a slot.
-   Each list contains rpc items destined for given endpoint.
-   These lists are sorted by deadlines. So the items with least deadline 
-   will be at the HEAD of list.
-   Refer to the HLD of RPC Formation -
-   https://docs.google.com/a/xyratex.com/Doc?docid=0AXXBPOl-5oGtZGRzMzZ2NXdfMGQ0ZjNweGdz&hl=en
-
-   Formation is done on basis of various criterion
-   - deadline, including URGENT items (deadline = 0)
-   - priority
-   - rpc group
-   - max_message_size (max permissible size of RPC object)
-   - max_rpcs_in_flight (max number of RPCs that could be in flight)
-   - max_message_fragments (max number of disjoint memory buffers)
-
-   The Formation component will use a data structure (c2_rpc_frm_sm) that gives
-   summary of data in the input list. This data structure will help in
-   making quick decisions so as to select best candidates for rpc formation
-   and can prevent multiple scans of the rpc items list.
-   There are a multitude of external events that can come to formation and
-   it handles them and moves the state machine to appropriate states as
-   a result.
-
-   The external events are
-   - addition of an rpc item to the slot ready list.
-   - deletion of rpc item.
-   - change of parameter for an rpc item.
-   - reply received.
-   - deadline expired of an rpc item.
-   - slot becomes idle.
-   - unbounded item is added to the sessions list.
-   - c2_net_buffer sent to destination, hence free it.
-
-   Also, there are a number of states through which the formation state
-   machine transitions.
-   - WAITING (waiting for an event to trigger)
-   - UPDATING (updates the formation state machine)
-   - FORMING (core of formation algorithm)
-
-   The formation component maintains its current state in a state variable
-   which is protected by a lock. At any time, the state machine can only be
-   in one state.
-
-   RPC formation state machine:
-   @verbatim
-
-                              UNINITIALIZED
-                                   | frm_sm_init()
-                                   |
-                                   |
-                                   |
-                 a,b,c	           V         d,e
-           +------------------- WAITING -----------------+
-           |                    ^    ^                   |
-           |          	        |    |                   |
-           |      +-------------+    +-------------+     |
-           |      |                                |     |
-           V      |              d,e               |     v
-           UPDATING -----------------------------> FORMING
-           | ^  ^                                  |   | ^
-           | |  |                a,b,c             |   | |
-     a,b,c | |  +----------------------------------+   | | d,e
-           +-+                                         +-+
-
-    @endverbatim
-
-    External Events :
-	- a. Item ready (bound item)
-	- b. Unbound item added
-	- c. Unsolicited item added
-	- d. Item reply received
-	- e. Item deadline expired
-
-   The lifecycle of any thread executing the formation state machine is
-   something like this
-	- execute a state function as a result of triggering of some event.
-	- acquire the state lock.
-	- change the state of state machine.
-	- lock the internal data structure.
-	- operate on the internal data structure.
-	- release the internal data structure lock.
-	- release the state lock.
-	- pass through the subsequent states as states succeed and exit
-
-   @todo A lot of data structures here, use a c2_list. Instead a
-   hash function can be used wherever applicable to enhance the performance.
-
-   There are no retries in the state machine. Any failure event will
-   take the executing thread out of this state machine.
- */
-
-/**
-   Enumeration of all possible states.
- */
-enum c2_rpc_frm_state {
-	/** An uninitialized state to formation state machine. */
-	C2_RPC_FRM_STATE_UNINITIALIZED = 0,
-	/** WAITING state for state machine, where it waits for
-	    any event to trigger. */
-	C2_RPC_FRM_STATE_WAITING,
-	/** UPDATING state for state machine, where it updates
-	    internal data structure (struct c2_rpc_frm_sm) */
-	C2_RPC_FRM_STATE_UPDATING,
-	/** FORMING state for state machine, which employs formation
-	    algorithm. */
-	C2_RPC_FRM_STATE_FORMING,
-	/** MAX States of state machine. */
-	C2_RPC_FRM_STATES_NR
-};
-
-/**
-   Structure containing a priority and list of all items belonging to
-   given priority.
- */
-struct c2_rpc_frm_prio_list {
-	/** Priority band for this list. */
-	enum c2_rpc_item_priority pl_prio;
-	/** List of unformed items sharing the pl_prio priority linked
-	    through c2_rpc_item::ri_unformed_linkage. */
-	struct c2_list		  pl_unformed_items;
-};
-
-/**
-   This structure represents the summary data for a formation state machine.
-   It contains a list containing the summary data for each rpc group
-   and a list of files involved in any IO operations destined for
-   the given network endpoint.
-   There is a state maintained per state machine.
-   This will help to ensure that requests belonging to different
-   network endpoints can proceed in their own state machines. Only the
-   requests belonging to same network endpoint will contest for the
-   same state machine.
- */
-struct c2_rpc_frm_sm {
-	/** Flag denoting if current side is sender or receiver. */
-	bool				 fs_sender_side;
-	/** ADDB context for all formation state machines. */
-	struct c2_addb_ctx		 fs_rpc_form_addb;
-	/** Mutex protecting the state machine from concurrent access. */
-	struct c2_mutex			 fs_lock;
-	enum c2_rpc_frm_state		 fs_state;
-	/** List of structures containing data for each group linked
-	    through c2_rpc_frm_group::frg_linkage. */
-	struct c2_list			 fs_groups;
-	/** List of coalesced rpc items linked through
-	    c2_rpc_frm_item_coalesced::ic_linkage. */
-	struct c2_list			 fs_coalesced_items;
-	/** List of formed RPC objects kept with formation linked
-	    through c2_rpc::r_linkage. */
-	struct c2_list			 fs_rpcs;
-	/** Array of lists (one per priority band) containing unformed
-	    rpc items sorted according to increasing order of deadline. */
-	struct c2_rpc_frm_prio_list	 fs_unformed[C2_RPC_ITEM_PRIO_NR];
-	/** Network layer attributes for buffer transfer. */
-	uint64_t			 fs_max_msg_size;
-	uint64_t			 fs_max_frags;
-	/** Statistics data. Currently stationed with formation but
-	    later will be moved to Output sub component from rpc. */
-	uint64_t			 fs_max_rpcs_in_flight;
-	/** Number of rpcs in flight sent by this state machine. */
-	uint64_t			 fs_curr_rpcs_in_flight;
-	/** Cumulative size of items added to this state machine so far.
-	    Will help to determine if an optimal rpc can be formed.*/
-	uint64_t			 fs_cumulative_size;
-	/** Number of urgent items which do not belong to any rpc group
-	    added to this state machine so far.
-	    Any number > 0 will trigger formation. */
-	uint64_t			 fs_urgent_nogrp_items_nr;
-	/** Number of complete groups in the sense that this state
-	    machine contains all rpc items from such rpc groups.
-	    Any number > 0 will trigger formation. */
-	uint64_t			 fs_complete_groups_nr;
-	/** Number of timed out rpc items. If this number is greater
-	    than zero, formation algorithm will be invoked. */
-	uint64_t			 fs_timedout_items_nr;
-	/** Number of items still to be formed. */
-	uint64_t			 fs_items_left;
-};
-
-/**
-   A magic constant to varify the sanity of c2_rpc_frm_buffer.
- */
-enum {
-	C2_RPC_FRM_BUFFER_MAGIC = 0x8135797531975313ULL,
-};
-
-/**
-   Formation attributes for an rpc.
- */
-struct c2_rpc_frm_buffer {
-	/** A magic constant to verify sanity of buffer. */
-	uint64_t		 fb_magic;
-	/** The c2_net_buffer on which callback will trigger. */
-	struct c2_net_buffer	 fb_buffer;
-	/** The associated fromation state machine. */
-	struct c2_rpc_frm_sm	*fb_frm_sm;
-};
-
-/**
-   c2_rpc is a container of c2_rpc_items.
- */
-struct c2_rpc {
-	/** Linkage into list of rpc objects just formed or into the list
-	    of rpc objects which are ready to be sent on wire. */
-	struct c2_list_link		 r_linkage;
-	/** List of member rpc items. */
-	struct c2_list			 r_items;
-	/** Items in this rpc are sent via this session. */
-	struct c2_rpc_session		*r_session;
-	/** Formation attributes (buffer, magic) for the rpc. */
-	struct c2_rpc_frm_buffer	 r_fbuf;
-};
-
-void c2_rpcobj_init(struct c2_rpc *rpc);
-
-void c2_rpcobj_fini(struct c2_rpc *rpc);
-
-/**
-   Connects resultant rpc item with its coalesced constituent rpc items.
-   When a reply is received for a coalesced rpc item, it will find out
-   the requesting coalesced rpc item and using this data structure,
-   it will find out the constituent rpc items and invoke their
-   completion callbacks accordingly.
- */
-struct c2_rpc_frm_item_coalesced {
-	/** Linkage to list of coalesced items anchored at
-	    c2_rpc_formation::fs_coalesced_items. */
-	struct c2_list_link		 ic_linkage;
-	/** Resultant coalesced rpc item */
-	struct c2_rpc_item		*ic_resultant_item;
-	/** List of constituent rpc items for this coalesced item linked
-	    through c2_rpc_item::ri_coalesced_linkage. */
-	struct c2_list			 ic_member_list;
-	/** Fop used to backup the original IO vector of resultant item
-	    which is replaced during coalescing. */
-	struct c2_fop			*ic_bkpfop;
-};
-
-/**
-   This structure represents the summary data for a given rpc group
-   destined for a given state machine.
-   Formation tries to send all rpc items belonging to same rpc group
-   together. This is a best-case effort. So when one item belonging
-   to an rpc group arrives at formation, it is not immediately formed
-   since more items from same group are expected to arrive shortly.
- */
-struct c2_rpc_frm_group {
-	/** Linkage into the list of groups belonging to same state machine
-	    anchored at c2_rpc_frm_sm::fs_groups. */
-	struct c2_list_link		 frg_linkage;
-	/** The rpc group, this data belongs to. */
-	struct c2_rpc_group		*frg_group;
-	/** Number of items from this group found so far. */
-	uint64_t			 frg_items_nr;
-	/** Number of expected items from this group. */
-	uint64_t			 frg_expected_items_nr;
-};
-
-/**
-   Callback function for deletion of an rpc item from the rpc items cache.
-   Call the default handler function passing the rpc item and
-   the corresponding event enum.
- */
-int c2_rpc_frm_item_delete(struct c2_rpc_item *item);
-
-/**
-   Interfaces to change attributes of rpc items that have been already
-   submitted to rpc layer.
- */
-void c2_rpc_frm_item_priority_set(struct c2_rpc_item *item,
-				  enum c2_rpc_item_priority prio);
-
-void c2_rpc_frm_item_deadline_set(struct c2_rpc_item *item,
-				  c2_time_t deadline);
-
-void c2_rpc_frm_item_group_set(struct c2_rpc_item *item,
-			       struct c2_rpc_group *group);
-
-/** @} endgroup of rpc_formation */
-
-#endif /* __C2_RPC_FORMATION_H__ */
diff --git a/rpc/it/.gitignore b/rpc/it/.gitignore
deleted file mode 100644
index 513307a..0000000
--- a/rpc/it/.gitignore
+++ /dev/null
@@ -1,2 +0,0 @@
-ping_fop_[ku].[ch]
-rpcping
diff --git a/rpc/it/Makefile.am b/rpc/it/Makefile.am
deleted file mode 100644
index 2126866..0000000
--- a/rpc/it/Makefile.am
+++ /dev/null
@@ -1,22 +0,0 @@
-INCLUDES             = -I. -I$(top_srcdir) -I$(top_srcdir)/include -I/usr/include
-
-ping_fop_u.h ping_fop_u.c ping_fop_k.h ping_fop_k.c: ping_fop.ff \
-		$(top_builddir)/fop/rt/libc2rt.la \
-		$(top_builddir)/fop/fop2c
-		$(top_builddir)/fop/fop2c -ku $<
-
-noinst_PROGRAMS     = rpcping
-
-rpcping_SOURCES     = ping_fop_u.h ping_fop_u.c ping_fop.h ping_fop.c \
-		      ping_fom.h ping_fom.c rpc_ping.c
-
-rpcping_LDADD       = $(top_builddir)/colibri/libcolibri.la \
-		      $(top_builddir)/ut/libcolibri-ut.la
-
-EXTRA_DIST          = ping_fop.ff linux_kernel/rpc_ping.h \
-                      linux_kernel/rpcping_kernel.c \
-                      linux_kernel/rpcload.sh
-
-clean-local:
-	cd @SRCDIR@/rpc/it ; \
-	rm -fr ping_fop_[uk].[ch]
diff --git a/rpc/it/linux_kernel/.gitignore b/rpc/it/linux_kernel/.gitignore
deleted file mode 100644
index 7efbf01..0000000
--- a/rpc/it/linux_kernel/.gitignore
+++ /dev/null
@@ -1,4 +0,0 @@
-ping_fop.c
-ping_fom.c
-ping_fop_[ku].[ch]
-rpc_ping.c
diff --git a/rpc/it/linux_kernel/Makefile.in b/rpc/it/linux_kernel/Makefile.in
deleted file mode 100644
index cd6cf47..0000000
--- a/rpc/it/linux_kernel/Makefile.in
+++ /dev/null
@@ -1,26 +0,0 @@
-PING_SRCDIR = @SRCDIR@/rpc/it/linux_kernel
-PINGDIR = @SRCDIR@/rpc/it
-FOPDIR = @SRCDIR@/fop
-
-obj-m       := krpcping.o
-shared_src  := rpc_ping.c ping_fop.c ping_fop_k.c ping_fom.c
-kernel_src  := rpcping_kernel.c
-krpcping-y  := $(shared_src:.c=.o) $(kernel_src:.c=.o)
-orig        := $(shared_src:%=../%)
-
-EXTRA_CFLAGS = -DHAVE_CONFIG_H -I@SRCDIR@ @KCFLAGS@
-
-prepare: ping_fop_k.h ping_fop_k.c
-	ln -fs $(orig) .
-
-ping_fop_k.h ping_fop_k.c: $(PINGDIR)/ping_fop.ff
-	$(FOPDIR)/fop2c -ku $(PINGDIR)/ping_fop.ff
-
-clean distclean:
-	$(RM) ping_fop_[ku].[ch]
-	$(RM) $(shared_src) Module.markers Module.symvers modules.order
-	$(MAKE) -C @LINUX_OBJ@ M=`pwd` clean
-
-distdir:
-	cp $(PING_SRCDIR)/Makefile.in  $(PING_SRCDIR)/rpcping_kernel.c $(PING_SRCDIR)/rpc_ping.h\
-           @top_builddir@/@PACKAGE@-@VERSION@/rpc/it/linux_kernel
diff --git a/rpc/it/linux_kernel/load.sh b/rpc/it/linux_kernel/load.sh
deleted file mode 100644
index a64195e..0000000
--- a/rpc/it/linux_kernel/load.sh
+++ /dev/null
@@ -1,4 +0,0 @@
-. rpcload.sh
-cd ../../../
-modload
-cd rpc/it/linux_kernel
diff --git a/rpc/it/linux_kernel/rpc_ping.h b/rpc/it/linux_kernel/rpc_ping.h
deleted file mode 100644
index cbd080a..0000000
--- a/rpc/it/linux_kernel/rpc_ping.h
+++ /dev/null
@@ -1,22 +0,0 @@
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original Author: Madhavrao Vemuri <Madhav_Vemuri@xyratex.com>
- * Original creation date: 07/09/2011
- */
-
-int c2_rpc_ping_init(void);
-void c2_rpc_ping_fini(void);
-
diff --git a/rpc/it/linux_kernel/rpcload.sh b/rpc/it/linux_kernel/rpcload.sh
deleted file mode 100755
index c72b143..0000000
--- a/rpc/it/linux_kernel/rpcload.sh
+++ /dev/null
@@ -1,27 +0,0 @@
-#! /bin/sh
-
-MODLIST="build_kernel_modules/kcolibri.ko"
-
-abort()
-{
-    msg="$1"
-    echo "$1 Aborting."
-    exit 1
-}
-
-modload()
-{
-    for m in $MODLIST ;do
-	insmod $m                   || abort "Error loading $m."
-    done
-}
-
-modunload()
-{
-    for m in $MODLIST ;do
-	echo $m
-    done | tac | while read ;do
-	rmmod $REPLY                || echo "Error unloading $m."
-    done
-}
-
diff --git a/rpc/it/linux_kernel/rpcping_kernel.c b/rpc/it/linux_kernel/rpcping_kernel.c
deleted file mode 100644
index 87230b9..0000000
--- a/rpc/it/linux_kernel/rpcping_kernel.c
+++ /dev/null
@@ -1,46 +0,0 @@
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original Author: Madhavrao Vemuri <Madhav_Vemuri@xyratex.com>
- * Original creation date: 07/09/2011
- */
-
-#include <linux/module.h>
-
-#include "rpc_ping.h"
-
-int init_module(void)
-{
-	return c2_rpc_ping_init();
-}
-
-void cleanup_module(void)
-{
-	c2_rpc_ping_fini();
-}
-
-MODULE_AUTHOR("Xyratex");
-MODULE_DESCRIPTION("Colibri Kernel rpc ping Module");
-MODULE_LICENSE("proprietary");
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
diff --git a/rpc/it/linux_kernel/unload.sh b/rpc/it/linux_kernel/unload.sh
deleted file mode 100644
index 3f97fe8..0000000
--- a/rpc/it/linux_kernel/unload.sh
+++ /dev/null
@@ -1,4 +0,0 @@
-. rpcload.sh
-cd ../../../
-modunload
-cd rpc/it/linux_kernel
diff --git a/rpc/it/ping_fom.c b/rpc/it/ping_fom.c
deleted file mode 100644
index 1055339..0000000
--- a/rpc/it/ping_fom.c
+++ /dev/null
@@ -1,137 +0,0 @@
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Anup Barve <Anup_Barve@xyratex.com>
- * Original creation date: 07/07/2011
- */
-
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif
-
-#include "fop/fop.h"
-#include "fop/fop_format_def.h"
-#include "fop/fop_format.h"
-#include "rpc/it/ping_fom.h"
-#include "rpc/it/ping_fop.h"
-#ifdef __KERNEL__
-#include "ping_fop_k.h"
-#else
-#include "ping_fop_u.h"
-#endif
-
-#include "lib/errno.h"
-#include "lib/memory.h"
-#include "rpc/rpc2.h"
-
-static int ping_fop_fom_create(struct c2_fop *fop, struct c2_fom **m);
-
-/** Generic ops object for ping */
-struct c2_fom_ops c2_fom_ping_ops = {
-	.fo_fini = c2_fop_ping_fom_fini,
-	.fo_state = c2_fom_ping_state,
-	.fo_home_locality = c2_fom_ping_home_locality
-};
-
-/** FOM type specific functions for ping FOP. */
-static const struct c2_fom_type_ops c2_fom_ping_type_ops = {
-	.fto_create = ping_fop_fom_create
-};
-
-/** Ping specific FOM type operations vector. */
-struct c2_fom_type c2_fom_ping_mopt = {
-        .ft_ops = &c2_fom_ping_type_ops,
-};
-
-size_t c2_fom_ping_home_locality(const struct c2_fom *fom)
-{
-	C2_PRE(fom != NULL);
-
-	return fom->fo_fop->f_type->ft_rpc_item_type.rit_opcode;
-}
-
-/**
- * State function for ping request
- */
-int c2_fom_ping_state(struct c2_fom *fom)
-{
-	struct c2_fop			*fop;
-        struct c2_fop_ping_rep		*ping_fop_rep;
-        struct c2_rpc_item              *item;
-        struct c2_fom_ping		*fom_obj;
-
-	fom_obj = container_of(fom, struct c2_fom_ping, fp_gen);
-        fop = c2_fop_alloc(&c2_fop_ping_rep_fopt, NULL);
-        C2_ASSERT(fop != NULL);
-        ping_fop_rep = c2_fop_data(fop);
-        ping_fop_rep->fpr_rc = true;
-	item = c2_fop_to_rpc_item(fop);
-	item->ri_group = NULL;
-        c2_rpc_reply_post(&fom_obj->fp_fop->f_item, item);
-	fom->fo_phase = FOPH_FINISH;
-
-	return 0;
-}
-
-
-/* Init for ping */
-static int ping_fop_fom_create(struct c2_fop *fop, struct c2_fom **m)
-{
-        struct c2_fom                   *fom;
-        struct c2_fom_ping		*fom_obj;
-        struct c2_fom_type              *fom_type;
-
-        C2_PRE(fop != NULL);
-        C2_PRE(m != NULL);
-
-        fom_obj= c2_alloc(sizeof(struct c2_fom_ping));
-        if (fom_obj == NULL)
-                return -ENOMEM;
-        fom_type = &c2_fom_ping_mopt;
-        C2_ASSERT(fom_type != NULL);
-        fop->f_type->ft_fom_type = *fom_type;
-	fom = &fom_obj->fp_gen;
-	c2_fom_init(fom);
-	fom->fo_type = fom_type;
-	fom->fo_ops = &c2_fom_ping_ops;
-	fom->fo_fop = fop;
-	fom_obj->fp_fop = fop;
-	*m = fom;
-	return 0;
-}
-
-void c2_fop_ping_fom_fini(struct c2_fom *fom)
-{
-	struct c2_fom_ping *fom_obj;
-
-	fom_obj = container_of(fom, struct c2_fom_ping, fp_gen);
-	c2_fom_fini(fom);
-	c2_free(fom_obj);
-
-	return;
-}
-
-/** @} end of io_foms */
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
-
diff --git a/rpc/it/ping_fom.h b/rpc/it/ping_fom.h
deleted file mode 100644
index 525ee79..0000000
--- a/rpc/it/ping_fom.h
+++ /dev/null
@@ -1,58 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Anup Barve <Anup_Barve@xyratex.com>
- * Original creation date: 07/07/2011
- */
-
-#ifndef __COLIBRI_PING_FOM_H__
-#define __COLIBRI_PING_FOM_H__
-
-#include "ping_fop.h"
-
-/**
- * Object encompassing FOM for ping
- * operation and necessary context data
- */
-struct c2_fom_ping {
-	/** Generic c2_fom object. */
-        struct c2_fom                    fp_gen;
-	/** FOP associated with this FOM. */
-        struct c2_fop			*fp_fop;
-};
-
-/**
- * <b> State Transition function for "ping" operation
- *     that executes on data server. </b>
- *  - Send reply FOP to client.
- */
-int c2_fom_ping_state(struct c2_fom *fom);
-size_t c2_fom_ping_home_locality(const struct c2_fom *fom);
-void c2_fop_ping_fom_fini(struct c2_fom *fom);
-
-/* __COLIBRI_PING_FOM_H__ */
-#endif
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
-
diff --git a/rpc/it/ping_fop.c b/rpc/it/ping_fop.c
deleted file mode 100644
index 83d3685..0000000
--- a/rpc/it/ping_fop.c
+++ /dev/null
@@ -1,103 +0,0 @@
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Anup Barve <Anup_Barve@xyratex.com>
- * Original creation date: 07/07/2011
- */
-
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif
-
-#include "lib/errno.h"
-#include "lib/memory.h"
-#include "fop/fom.h"
-#include "fop/fop.h"
-#include "fop/fop_format_def.h"
-#ifdef __KERNEL__
-#include "ping_fop_k.h"
-#else
-#include "ping_fop_u.h"
-#endif
-#include "fop/fop_iterator.h"
-#include "rpc/it/ping_fop.h"
-#include "rpc/it/ping_fom.h"
-#include "rpc/it/ping_fop.ff"
-#include "lib/errno.h"
-#include "rpc/rpc2.h"
-#include "fop/fop_item_type.h"
-#include "xcode/bufvec_xcode.h"
-
-/* Ops vector for ping request. */
-const struct c2_fop_type_ops c2_fop_ping_ops = {
-	.fto_fop_replied = NULL,
-	.fto_size_get = c2_xcode_fop_size_get,
-	.fto_op_equal = NULL,
-	.fto_get_nfragments = NULL,
-	.fto_io_coalesce = NULL,
-};
-
-/* Ops vector for ping reply. */
-const struct c2_fop_type_ops c2_fop_ping_rep_ops = {
-        .fto_fop_replied = NULL,
-        .fto_size_get = c2_xcode_fop_size_get,
-        .fto_op_equal = NULL,
-        .fto_get_nfragments = NULL,
-        .fto_io_coalesce = NULL,
-};
-
-/* Ping fop assignment */
-C2_FOP_TYPE_DECLARE(c2_fop_ping, "ping fop", &c2_fop_ping_ops,
-		    C2_RPC_PING_OPCODE,
-		    C2_RPC_ITEM_TYPE_REQUEST | C2_RPC_ITEM_TYPE_MUTABO);
-
-C2_FOP_TYPE_DECLARE(c2_fop_ping_rep, "ping fop reply", &c2_fop_ping_rep_ops,
-		    C2_RPC_PING_REPLY_OPCODE, C2_RPC_ITEM_TYPE_REPLY);
-
-static struct c2_fop_type_format *fmts[] = {
-        &c2_fop_ping_arr_tfmt,
-};
-
-
-static struct c2_fop_type *fops[] = {
-        &c2_fop_ping_fopt,
-        &c2_fop_ping_rep_fopt,
-};
-
-void c2_ping_fop_fini(void)
-{
-        c2_fop_type_fini_nr(fops, ARRAY_SIZE(fops));
-}
-
-extern struct c2_fom_type c2_fom_ping_mopt;
-
-int c2_ping_fop_init(void)
-{
-        int result;
-	result = c2_fop_type_format_parse_nr(fmts, ARRAY_SIZE(fmts));
-        result = c2_fop_type_build_nr(fops, ARRAY_SIZE(fops));
-	c2_fop_ping_fopt.ft_fom_type = c2_fom_ping_mopt;
-        return result;
-}
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
diff --git a/rpc/it/ping_fop.ff b/rpc/it/ping_fop.ff
deleted file mode 100644
index 6bc68eb..0000000
--- a/rpc/it/ping_fop.ff
+++ /dev/null
@@ -1,40 +0,0 @@
-/* -*- C -*- */
-
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Anup Barve <Anup_Barve@xyratex.com>
- * Original creation date: 07/07/2011
- */
-
-DEF(c2_fop_ping_arr, SEQUENCE,
-	_(f_count, U32),
-	_(f_data, U64));
-
-DEF(c2_fop_ping, RECORD,
-	_(fp_arr, c2_fop_ping_arr));
-
-DEF(c2_fop_ping_rep, RECORD,
-	_(fpr_rc, U32));
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
diff --git a/rpc/it/ping_fop.h b/rpc/it/ping_fop.h
deleted file mode 100644
index f02cac4..0000000
--- a/rpc/it/ping_fop.h
+++ /dev/null
@@ -1,56 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Anup Barve <Anup_Barve@xyratex.com>
- * Original creation date: 07/07/2011
- */
-#ifndef __COLIBRI_PING_FOP_H__
-#define __COLIBRI_PING_FOP_H__
-
-#include "fop/fop.h"
-#include "rpc/rpc_opcodes.h"
-
-int c2_ping_fop_init(void);
-void c2_ping_fop_fini(void);
-
-/**
- * FOP definitions and corresponding fop type formats
- */
-extern struct c2_fop_type_format c2_fop_ping_tfmt;
-extern struct c2_fop_type_format c2_fop_ping_rep_tfmt;
-
-extern struct c2_fop_type c2_fop_ping_fopt;
-extern struct c2_fop_type c2_fop_ping_rep_fopt;
-
-extern const struct c2_fop_type_ops c2_fop_ping_ops;
-extern const struct c2_fop_type_ops c2_fop_ping_rep_ops;
-
-extern const struct c2_rpc_item_type c2_rpc_item_type_ping;
-extern const struct c2_rpc_item_type c2_rpc_item_type_ping_rep;
-
-/* __COLIBRI_PING_FOP_H__ */
-#endif
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
-
diff --git a/rpc/it/rpc_ping.c b/rpc/it/rpc_ping.c
deleted file mode 100644
index bdf4d5b..0000000
--- a/rpc/it/rpc_ping.c
+++ /dev/null
@@ -1,577 +0,0 @@
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Anup Barve <Anup_Barve@xyratex.com>
- *		    Madhavrao Vemuri <madhav_vemuri@xyratex.com>
- * Original creation date: 06/27/2011
- */
-
-
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif
-
-#include "colibri/init.h"
-#include "lib/assert.h"
-#include "lib/errno.h"
-#include "lib/getopts.h"
-#include "lib/memory.h"
-#include "lib/misc.h" /* C2_SET0 */
-#include "lib/thread.h"
-#include "lib/processor.h"
-#include "net/net.h"
-#include "net/bulk_sunrpc.h"
-#include "rpc/rpc2.h"
-#include "rpc/it/ping_fop.h"
-#include "rpc/it/ping_fom.h"
-#include "ut/net.h"     /* canon_host */
-#include "rpc/rpclib.h" /* c2_rpc_server_start */
-#include "ut/rpc.h"     /* c2_rpc_client_init */
-#include "fop/fop.h"    /* c2_fop_default_item_ops */
-
-#ifdef __KERNEL__
-#include <linux/kernel.h>
-#include "ping_fop_k.h"
-#include "rpc_ping.h"
-#define printf printk
-#else
-#include "ping_fop_u.h"
-#include <stdlib.h>
-#include <stdio.h>
-#include <string.h>
-#endif
-
-#ifndef __KERNEL__
-#ifdef HAVE_NETINET_IN_H
-#include <netinet/in.h>
-#endif
-#include <arpa/inet.h>
-#include <netdb.h>
-#endif
-
-
-#define TRANSPORT_NAME		"bulk-sunrpc"
-
-#define CLIENT_DB_FILE_NAME	"rpcping_client.db"
-
-#define SERVER_DB_FILE_NAME	"rpcping_server.db"
-#define SERVER_STOB_FILE_NAME	"rpcping_server.stob"
-#define SERVER_LOG_FILE_NAME	"rpcping_server.log"
-
-enum ep_type {
-	EP_SERVER,
-	EP_CLIENT,
-};
-
-enum {
-	BUF_LEN = 128,
-	RID = 1,
-	MAX_RPCS_IN_FLIGHT = 32,
-	CLIENT_COB_DOM_ID = 13,
-	CONNECT_TIMEOUT = 5,
-};
-
-#ifndef __KERNEL__
-static bool server_mode       = false;
-#endif
-static bool verbose           = false;
-static char *server_hostname  = "127.0.0.1";
-static char *client_hostname  = "127.0.0.1";
-static int  server_port       = 12321;
-static int  client_port       = 32123;
-static int  nr_client_threads = 1;
-static int  nr_slots          = 1;
-static int  nr_ping_bytes     = 8;
-static int  nr_ping_item      = 1;
-
-static char client_endpoint[BUF_LEN];
-static char server_endpoint[BUF_LEN];
-
-static struct c2_net_xprt *xprt = &c2_net_bulk_sunrpc_xprt;
-
-#ifdef __KERNEL__
-/* Module parameters */
-module_param(verbose, bool, S_IRUGO);
-MODULE_PARM_DESC(verbose, "enable verbose output to kernel log");
-
-module_param(client_hostname, charp, S_IRUGO);
-MODULE_PARM_DESC(client_hostname, "client address");
-
-module_param(server_hostname, charp, S_IRUGO);
-MODULE_PARM_DESC(server_hostname, "server address");
-
-module_param(server_port, int, S_IRUGO);
-MODULE_PARM_DESC(server_port, "remote port number");
-
-module_param(client_port, int, S_IRUGO);
-MODULE_PARM_DESC(client_port, "local port number");
-
-module_param(nr_client_threads, int, S_IRUGO);
-MODULE_PARM_DESC(nr_client_threads, "number of client threads");
-
-module_param(nr_slots, int, S_IRUGO);
-MODULE_PARM_DESC(nr_slots, "number of slots");
-
-module_param(nr_ping_bytes, int, S_IRUGO);
-MODULE_PARM_DESC(nr_ping_bytes, "number of ping fop bytes");
-
-module_param(nr_ping_item, int, S_IRUGO);
-MODULE_PARM_DESC(nr_ping_item, "number of ping fop items");
-#endif
-
-static int build_endpoint_addr(enum ep_type type, char *out_buf, size_t buf_size)
-{
-#ifndef __KERNEL__
-	int  rc;
-#endif
-	char *ep_name;
-	char *hostname;
-	int  port;
-
-	/*
-	 * Declare this internal buffer as static, to avoid on-stack allocation
-	 * of big structures. This is important for kernel-space, where stack
-	 * size is very small.
-	 */
-	static char hostbuf[BUF_LEN];
-
-	switch (type) {
-	case EP_SERVER:
-		hostname = server_hostname;
-		ep_name = "server";
-		port = server_port;
-		break;
-	case EP_CLIENT:
-		hostname = client_hostname;
-		ep_name = "client";
-		port = client_port;
-		break;
-	default:
-		return -1;
-	}
-
-	/* Resolve hostname into IP address */
-#ifndef __KERNEL__
-	rc = canon_host(hostname, hostbuf, sizeof(hostbuf));
-	if(rc != 0) {
-		fprintf(stderr, "Failed to resolve canon host for %s\n", ep_name);
-		return rc;
-	}
-#else
-	/*
-	 * For kernel-space we cannot use canon_host to resolve hostname, so
-	 * assume that hostname already contains an IP address
-	 */
-	strcpy(hostbuf, hostname);
-#endif
-
-	snprintf(out_buf, buf_size, "%s:%u:%u", hostbuf, port, RID);
-	if (verbose)
-		printf("%s endpoint: %s\n", ep_name, out_buf);
-
-	return 0;
-}
-
-static void print_rpc_stats(struct c2_rpc_stats *stats)
-{
-	uint64_t nsec;
-#ifdef __KERNEL__
-	uint64_t sec = 0;
-	uint64_t usec = 0;
-	uint64_t thruput;
-	uint64_t packing_density;
-#else
-	double   sec = 0;
-	double   msec = 0;
-	double   thruput;
-	double   packing_density;
-#endif
-
-	printf("                rpcs:   %llu\n",
-			(unsigned long long) stats->rs_rpcs_nr);
-	printf("                items:  %llu\n",
-			(unsigned long long) stats->rs_items_nr);
-	printf("                bytes:  %llu\n",
-			(unsigned long long) stats->rs_bytes_nr);
-#ifndef __KERNEL__
-	packing_density = (double) stats->rs_items_nr /
-			  (double) stats->rs_rpcs_nr;
-	printf("                packing_density: %lf\n", packing_density);
-#else
-	packing_density = (uint64_t) stats->rs_items_nr / stats->rs_rpcs_nr;
-	printf("                packing_density: %llu\n", packing_density);
-#endif
-	sec = 0;
-	sec = c2_time_seconds(stats->rs_min_lat);
-	nsec = c2_time_nanoseconds(stats->rs_min_lat);
-#ifdef __KERNEL__
-	usec = (uint64_t) nsec / 1000;
-	usec += (uint64_t) (sec * 1000000);
-	printf("                min_latency: %llu # usec\n", usec);
-	if (usec != 0) {
-		thruput = (uint64_t)stats->rs_bytes_nr/usec;
-		printf("                max_throughput: %llu # MB/s\n",
-					thruput);
-	}
-#else
-	sec += (double) nsec/1000000000;
-	msec = (double) sec * 1000;
-	printf("                min_latency:\t %lf # msec\n", msec);
-
-	thruput = (double)stats->rs_bytes_nr/(sec*1000000);
-	printf("                max_throughput:\t %lf # MB/s\n", thruput);
-#endif
-
-	sec = 0;
-	sec = c2_time_seconds(stats->rs_max_lat);
-	nsec = c2_time_nanoseconds(stats->rs_max_lat);
-#ifdef __KERNEL__
-	usec = (uint64_t) nsec / 1000;
-	usec += (uint64_t) (sec * 1000000);
-	printf("                max_latency: %llu # usec\n", usec);
-	if (usec != 0) {
-		thruput = (uint64_t)stats->rs_bytes_nr/usec;
-		printf("                min_throughput: %llu # MB/s\n",
-					thruput);
-	}
-#else
-	sec += (double) nsec/1000000000;
-	msec = (double) sec * 1000;
-	printf("                max_latency:\t %lf # msec\n", msec);
-
-	thruput = (double)stats->rs_bytes_nr/(sec*1000000);
-	printf("                min_throughput:\t %lf # MB/s\n", thruput);
-#endif
-}
-
-/* Get stats from rpcmachine and print them */
-static void print_stats(struct c2_rpcmachine *rpc_mach)
-{
-	printf("stats:\n");
-
-	printf("        in:\n");
-	print_rpc_stats(&rpc_mach->cr_rpc_stats[C2_RPC_PATH_INCOMING]);
-
-	printf("        out:\n");
-	print_rpc_stats(&rpc_mach->cr_rpc_stats[C2_RPC_PATH_OUTGOING]);
-}
-
-/* Create a ping fop and post it to rpc layer */
-static void send_ping_fop(struct c2_rpc_session *session)
-{
-	int                rc;
-	int                i;
-	struct c2_fop      *fop;
-	struct c2_fop_ping *ping_fop;
-	uint32_t           nr_arr_member;
-
-	if (nr_ping_bytes % 8 == 0)
-		nr_arr_member = nr_ping_bytes / 8;
-	else
-		nr_arr_member = nr_ping_bytes / 8 + 1;
-
-	fop = c2_fop_alloc(&c2_fop_ping_fopt, NULL);
-	if (fop == NULL) {
-		rc = -ENOMEM;
-		goto out;
-	}
-
-	ping_fop = c2_fop_data(fop);
-	ping_fop->fp_arr.f_count = nr_arr_member;
-
-	C2_ALLOC_ARR(ping_fop->fp_arr.f_data, nr_arr_member);
-	if (ping_fop->fp_arr.f_data == NULL) {
-		rc = -ENOMEM;
-		goto free_fop;
-	}
-
-	for (i = 0; i < nr_arr_member; i++) {
-		ping_fop->fp_arr.f_data[i] = i+100;
-	}
-
-	rc = c2_rpc_client_call(fop, session, &c2_fop_default_item_ops,
-				CONNECT_TIMEOUT);
-	C2_ASSERT(rc == 0);
-	C2_ASSERT(fop->f_item.ri_error == 0);
-	C2_ASSERT(fop->f_item.ri_reply != 0);
-
-	c2_free(ping_fop->fp_arr.f_data);
-free_fop:
-	/* FIXME: freeing fop here will lead to endless loop in
-	 * nr_active_items_count(), which is called from
-	 * c2_rpc_session_terminate() */
-	/*c2_fop_free(fop);*/
-out:
-	return;
-}
-
-/*
- * An rpcping-specific implementation of client fini function, which is used
- * instead of c2_rpc_client_fini(). It's required in order to get a correct
- * statistics from rpc machine, which is possible only when all connections,
- * associated with rpc machine, are terminated, but rpc machine itself is not
- * finalized yet.
- */
-static int client_fini(struct c2_rpc_client_ctx *cctx)
-{
-	int rc;
-
-	rc = c2_rpc_session_destroy(&cctx->rcx_session, cctx->rcx_timeout_s);
-	if (rc != 0)
-		return rc;
-
-	rc = c2_rpc_conn_destroy(&cctx->rcx_connection, cctx->rcx_timeout_s);
-	if (rc != 0)
-		return rc;
-
-	c2_net_end_point_put(cctx->rcx_remote_ep);
-
-	if (verbose)
-		print_stats(&cctx->rcx_rpc_machine);
-
-	c2_rpcmachine_fini(&cctx->rcx_rpc_machine);
-	c2_cob_domain_fini(cctx->rcx_cob_dom);
-	c2_dbenv_fini(cctx->rcx_dbenv);
-
-	return rc;
-}
-
-static int run_client(void)
-{
-	int  rc;
-	int  i;
-
-	struct c2_thread *client_thread;
-
-	/*
-	 * Declare these variables as static, to avoid on-stack allocation
-	 * of big structures. This is important for kernel-space, where stack
-	 * size is very small.
-	 */
-	static struct c2_net_domain     client_net_dom;
-	static struct c2_dbenv          client_dbenv;
-	static struct c2_cob_domain     client_cob_dom;
-	static struct c2_rpc_client_ctx cctx;
-
-
-	cctx.rcx_net_dom            = &client_net_dom,
-	cctx.rcx_local_addr         = client_endpoint,
-	cctx.rcx_remote_addr        = server_endpoint,
-	cctx.rcx_db_name            = CLIENT_DB_FILE_NAME,
-	cctx.rcx_dbenv              = &client_dbenv,
-	cctx.rcx_cob_dom_id         = CLIENT_COB_DOM_ID,
-	cctx.rcx_cob_dom            = &client_cob_dom,
-	cctx.rcx_nr_slots           = nr_slots,
-	cctx.rcx_timeout_s          = CONNECT_TIMEOUT,
-	cctx.rcx_max_rpcs_in_flight = MAX_RPCS_IN_FLIGHT,
-
-	rc = build_endpoint_addr(EP_SERVER, server_endpoint,
-					sizeof(server_endpoint));
-	if (rc != 0)
-		return rc;
-
-	rc = build_endpoint_addr(EP_CLIENT, client_endpoint,
-					sizeof(client_endpoint));
-	if (rc != 0)
-		return rc;
-
-#ifndef __KERNEL__
-	rc = c2_init();
-	if (rc != 0)
-		return rc;
-
-	rc = c2_processors_init();
-	if (rc != 0)
-		goto c2_fini;
-#endif
-	rc = c2_ping_fop_init();
-	if (rc != 0)
-		goto proc_fini;
-
-	rc = c2_net_xprt_init(xprt);
-	if (rc != 0)
-		goto fop_fini;
-
-	rc = c2_net_domain_init(&client_net_dom, xprt);
-	if (rc != 0)
-		goto xprt_fini;
-
-	rc = c2_rpc_client_init(&cctx);
-	if (rc != 0)
-		goto net_dom_fini;
-
-	C2_ALLOC_ARR(client_thread, nr_client_threads);
-
-	for (i = 0; i < nr_client_threads; i++) {
-		C2_SET0(&client_thread[i]);
-		rc = C2_THREAD_INIT(&client_thread[i], struct c2_rpc_session*,
-				NULL, &send_ping_fop,
-				&cctx.rcx_session, "client_%d", i);
-		C2_ASSERT(rc == 0);
-	}
-
-	for (i = 0; i < nr_client_threads; i++) {
-		c2_thread_join(&client_thread[i]);
-	}
-
-	/*
-	 * NOTE: don't use c2_rpc_client_fini() here, see the comment above
-	 * client_fini() for explanation.
-	 */
-	rc = client_fini(&cctx);
-
-net_dom_fini:
-	c2_net_domain_fini(&client_net_dom);
-xprt_fini:
-	c2_net_xprt_fini(xprt);
-fop_fini:
-	c2_ping_fop_fini();
-proc_fini:
-#ifndef __KERNEL__
-	c2_processors_fini();
-c2_fini:
-	c2_fini();
-#endif
-	return rc;
-}
-
-#ifndef __KERNEL__
-static void quit_dialog(void)
-{
-	char cli_buf[BUF_LEN];
-
-	printf("\n########################################\n");
-	printf("\n\nType \"quit\" or ^D to terminate\n\n");
-	printf("\n########################################\n");
-	while (fgets(cli_buf, BUF_LEN, stdin)) {
-		if (strcmp(cli_buf, "quit\n") == 0)
-			break;
-		else {
-			printf("\n########################################\n");
-			printf("\n\nType \"quit\" or ^D to terminate\n\n");
-			printf("\n########################################\n");
-		}
-	}
-}
-
-static int run_server(void)
-{
-	int rc;
-
-	char *server_argv[] = {
-		"rpclib_ut", "-r", "-T", "AD", "-D", SERVER_DB_FILE_NAME,
-		"-S", SERVER_STOB_FILE_NAME, "-e", server_endpoint,
-		"-s", "ds1", "-s", "ds2"
-	};
-
-	C2_RPC_SERVER_CTX_DECLARE(sctx, &xprt, 1, server_argv,
-				  ARRAY_SIZE(server_argv), SERVER_LOG_FILE_NAME);
-
-	rc = c2_init();
-	if (rc != 0)
-		return rc;
-
-	rc = c2_ping_fop_init();
-	if (rc != 0)
-		goto c2_fini;
-
-	/*
-	 * Prepend transport name to the beginning of endpoint,
-	 * as required by colibri-setup.
-	 */
-	strcpy(server_endpoint, TRANSPORT_NAME ":");
-
-	rc = build_endpoint_addr(
-			EP_SERVER, server_endpoint + strlen(server_endpoint),
-			sizeof(server_endpoint) - strlen(server_endpoint));
-	if (rc != 0)
-		return rc;
-
-	rc = c2_rpc_server_start(&sctx);
-	if (rc != 0)
-		goto fop_fini;
-
-	quit_dialog();
-
-	if (verbose) {
-		struct c2_rpcmachine *rpcmach;
-
-		rpcmach = c2_cs_rpcmach_get(&sctx.rsx_colibri_ctx, xprt, "ds1");
-		if (rpcmach != NULL) {
-			printf("########### Server DS1 statS ###########\n");
-			print_stats(rpcmach);
-		}
-
-		rpcmach = c2_cs_rpcmach_get(&sctx.rsx_colibri_ctx, xprt, "ds2");
-		if (rpcmach != NULL) {
-			printf("\n");
-			printf("########### Server DS2 statS ###########\n");
-			print_stats(rpcmach);
-		}
-	}
-
-	c2_rpc_server_stop(&sctx);
-fop_fini:
-	c2_ping_fop_fini();
-c2_fini:
-	c2_fini();
-	return rc;
-}
-#endif
-
-#ifdef __KERNEL__
-int c2_rpc_ping_init()
-#else
-/* Main function for rpc ping */
-int main(int argc, char *argv[])
-#endif
-{
-	int rc;
-
-	c2_addb_choose_default_level(AEL_WARN);
-
-#ifndef __KERNEL__
-	rc = C2_GETOPTS("rpcping", argc, argv,
-		C2_FLAGARG('s', "run server", &server_mode),
-		C2_STRINGARG('C', "client hostname",
-			LAMBDA(void, (const char *str) { client_hostname =
-								(char*)str; })),
-		C2_FORMATARG('p', "client port", "%i", &client_port),
-		C2_STRINGARG('S', "server hostname",
-			LAMBDA(void, (const char *str) { server_hostname =
-								(char*)str; })),
-		C2_FORMATARG('P', "server port", "%i", &server_port),
-		C2_FORMATARG('b', "size in bytes", "%i", &nr_ping_bytes),
-		C2_FORMATARG('t', "number of client threads", "%i",
-						&nr_client_threads),
-		C2_FORMATARG('l', "number of slots", "%i", &nr_slots),
-		C2_FORMATARG('n', "number of ping items", "%i", &nr_ping_item),
-		C2_FLAGARG('v', "verbose", &verbose)
-		);
-	if (rc != 0)
-		return rc;
-
-	if (server_mode)
-		rc = run_server();
-	else
-#endif
-		rc = run_client();
-
-	return rc;
-}
-
-void c2_rpc_ping_fini(void)
-{
-}
diff --git a/rpc/linux_kernel/rpc_kernel.h b/rpc/linux_kernel/rpc_kernel.h
deleted file mode 100644
index fedd402..0000000
--- a/rpc/linux_kernel/rpc_kernel.h
+++ /dev/null
@@ -1,37 +0,0 @@
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original Author: Anand Vidwansa <Anand_Vidwansa@xyratex.com>
- * Original creation date: 08/14/2011
- */
-#ifndef __COLIBRI_RPC_RPC_KERNEL_H__
-#define __COLIBRI_RPC_RPC_KERNEL_H__
-
-#include <linux/module.h>
-
-size_t c2_fop_item_type_default_onwire_size(struct c2_rpc_item *item);
-
-/* __COLIBRI_RPC_RPC_KERNEL_H__ */
-#endif
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
diff --git a/rpc/rpc2.c b/rpc/rpc2.c
deleted file mode 100644
index 298034f..0000000
--- a/rpc/rpc2.c
+++ /dev/null
@@ -1,1309 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Nikita Danilov <Nikita_Danilov@xyratex.com>
- *		    Anand Vidwansa <Anand_Vidwansa@xyratex.com>
- *                  Anup Barve <Anup_Barve@xyratex.com>
- * Original creation date: 04/28/2011
- */
-
-#include "cob/cob.h"
-#include "rpc/rpc2.h"
-#include "ioservice/io_fops.h"
-#include "rpc/rpcdbg.h"
-#include "lib/memory.h"
-#include "lib/errno.h"
-#include "lib/misc.h"
-#include "lib/types.h"
-#include "lib/trace.h"
-#include "rpc/session.h"
-#include "rpc/session_internal.h"
-#include "fop/fop.h"
-#include "rpc/formation.h"
-#include "fid/fid.h"
-#include "reqh/reqh.h"
-#include "rpc/rpc_onwire.h"
-#include "fop/fop_item_type.h"
-#include "lib/arith.h"
-#include "lib/vec.h"
-
-/* Forward declarations. */
-static int recv_buffer_allocate_nr(struct c2_net_domain *net_dom,
-				   struct c2_rpcmachine *machine);
-static void recv_buffer_deallocate_nr(struct c2_rpcmachine *machine,
-				      bool tm_active, uint32_t nr);
-static void rpc_net_buf_received(const struct c2_net_buffer_event *ev);
-static void rpc_tm_cleanup(struct c2_rpcmachine *machine);
-
-
-extern void frm_rpcs_inflight_dec(struct c2_rpc_frm_sm *frm_sm);
-extern void frm_sm_init(struct c2_rpc_frm_sm *frm_sm,
-			uint64_t max_rpcs_in_flight);
-extern void frm_sm_fini(struct c2_rpc_frm_sm *frm_sm);
-extern int frm_ubitem_added(struct c2_rpc_item *item);
-extern void frm_net_buffer_sent(const struct c2_net_buffer_event *ev);
-extern void rpcobj_exit_stats_set(const struct c2_rpc *rpcobj,
-		struct c2_rpcmachine *mach, enum c2_rpc_item_path path);
-
-/* Number of default receive c2_net_buffers to be used with
-   each transfer machine.*/
-enum {
-	C2_RPC_TM_RECV_BUFFERS_NR = 128,
-};
-
-/* ADDB Instrumentation for rpccore. */
-static const struct c2_addb_ctx_type rpc_machine_addb_ctx_type = {
-	        .act_name = "rpc-machine"
-};
-
-static const struct c2_addb_loc rpc_machine_addb_loc = {
-	        .al_name = "rpc-machine"
-};
-
-C2_ADDB_EV_DEFINE(rpc_machine_func_fail, "rpc_machine_func_fail",
-		                C2_ADDB_EVENT_FUNC_FAIL, C2_ADDB_FUNC_CALL);
-
-/**
-   Buffer callback for buffers added by rpc layer for receiving messages.
- */
-const struct c2_net_buffer_callbacks c2_rpc_rcv_buf_callbacks = {
-	.nbc_cb = {
-		[C2_NET_QT_MSG_RECV] = rpc_net_buf_received,
-	}
-};
-
-/**
-   Callback for net buffer used in posting
- */
-const struct c2_net_buffer_callbacks c2_rpc_send_buf_callbacks = {
-	.nbc_cb = {
-		[C2_NET_QT_MSG_SEND] = frm_net_buffer_sent,
-	}
-};
-
-static void rpc_tm_event_cb(const struct c2_net_tm_event *ev)
-{
-}
-
-/**
-    Transfer machine callback vector for transfer machines created by
-    rpc layer.
- */
-static struct c2_net_tm_callbacks c2_rpc_tm_callbacks = {
-	       .ntc_event_cb = rpc_tm_event_cb
-};
-
-static const struct c2_update_stream_ops update_stream_ops;
-
-static int update_stream_init(struct c2_update_stream *us,
-			       struct c2_rpcmachine *mach)
-{
-	us->us_session_id = ~0;
-	us->us_slot_id    = ~0;
-
-	us->us_ops   = &update_stream_ops;
-	us->us_mach  = mach;
-	us->us_state = UPDATE_STREAM_UNINITIALIZED;
-
-	c2_mutex_init(&us->us_guard);
-	return 0;
-}
-
-static void update_stream_fini(struct c2_update_stream *us)
-{
-	c2_mutex_fini(&us->us_guard);
-}
-
-void c2_rpcobj_fini(struct c2_rpc *rpc)
-{
-	rpc->r_session = NULL;
-	c2_list_fini(&rpc->r_items);
-	c2_list_link_fini(&rpc->r_linkage);
-}
-
-void c2_rpc_item_init(struct c2_rpc_item *item)
-{
-	struct c2_rpc_slot_ref	*sref;
-
-	C2_SET0(item);
-	c2_chan_init(&item->ri_chan);
-
-	sref = &item->ri_slot_refs[0];
-	sref->sr_slot_id = SLOT_ID_INVALID;
-	c2_list_link_init(&sref->sr_link);
-	c2_list_link_init(&sref->sr_ready_link);
-
-        c2_list_link_init(&item->ri_unbound_link);
-	item->ri_slot_refs[0].sr_sender_id = SENDER_ID_INVALID;
-	item->ri_slot_refs[0].sr_session_id = SESSION_ID_INVALID;
-
-        c2_list_link_init(&item->ri_rpcobject_linkage);
-	c2_list_link_init(&item->ri_unformed_linkage);
-        c2_list_link_init(&item->ri_group_linkage);
-	item->ri_state = RPC_ITEM_UNINITIALIZED;
-}
-
-void c2_rpc_item_fini(struct c2_rpc_item *item)
-{
-	struct c2_rpc_slot_ref	*sref;
-
-	c2_chan_fini(&item->ri_chan);
-
-	sref = &item->ri_slot_refs[0];
-	sref->sr_slot_id = SLOT_ID_INVALID;
-	c2_list_link_fini(&sref->sr_link);
-	c2_list_link_fini(&sref->sr_ready_link);
-
-	sref->sr_sender_id = SENDER_ID_INVALID;
-	sref->sr_session_id = SESSION_ID_INVALID;
-
-        c2_list_link_fini(&item->ri_unbound_link);
-
-        c2_list_link_fini(&item->ri_rpcobject_linkage);
-	c2_list_link_fini(&item->ri_unformed_linkage);
-        c2_list_link_fini(&item->ri_group_linkage);
-	item->ri_state = RPC_ITEM_FINALIZED;
-}
-
-int c2_rpc_post(struct c2_rpc_item *item)
-{
-	struct c2_rpc_session *session;
-
-	C2_ASSERT(item != NULL && item->ri_type != NULL);
-
-	/*
-	 * It is mandatory to specify item_ops, because rpc layer needs
-	 * implementation of c2_rpc_item_ops::rio_free() in order to free the
-	 * item. Consumer can use c2_fop_default_item_ops if, it is not
-	 * interested in implementing other (excluding ->rio_free())
-	 * interfaces of c2_rpc_item_ops. See also c2_fop_item_free().
-	 */
-	C2_ASSERT(item->ri_ops != NULL && item->ri_ops->rio_free != NULL);
-
-	session = item->ri_session;
-	C2_ASSERT(session != NULL);
-	C2_ASSERT(session->s_state == C2_RPC_SESSION_IDLE ||
-		  session->s_state == C2_RPC_SESSION_BUSY);
-
-	item->ri_rpc_time = c2_time_now();
-
-	item->ri_state = RPC_ITEM_SUBMITTED;
-	frm_ubitem_added(item);
-	return 0;
-}
-C2_EXPORTED(c2_rpc_post);
-
-int c2_rpc_reply_post(struct c2_rpc_item	*request,
-		      struct c2_rpc_item	*reply)
-{
-	struct c2_rpc_slot_ref	*sref;
-	struct c2_rpc_item	*tmp;
-	struct c2_rpc_slot	*slot;
-
-	C2_PRE(request != NULL && reply != NULL);
-	C2_PRE(request->ri_stage == RPC_ITEM_STAGE_IN_PROGRESS);
-	C2_PRE(request->ri_session != NULL);
-	C2_PRE(reply->ri_type != NULL);
-	C2_PRE(reply->ri_ops != NULL && reply->ri_ops->rio_free != NULL);
-
-	reply->ri_rpc_time = c2_time_now();
-
-	reply->ri_session = request->ri_session;
-
-	sref = &reply->ri_slot_refs[0];
-	*sref = request->ri_slot_refs[0];
-	sref->sr_item = reply;
-	/* don't need values of sr_link and sr_ready_link of request item */
-	c2_list_link_init(&sref->sr_link);
-	c2_list_link_init(&sref->sr_ready_link);
-
-	reply->ri_prio = request->ri_prio;
-	reply->ri_deadline = request->ri_deadline;
-	reply->ri_error = 0;
-	reply->ri_state = RPC_ITEM_SUBMITTED;
-
-	slot = sref->sr_slot;
-	c2_mutex_lock(&slot->sl_mutex);
-	c2_rpc_slot_reply_received(slot, reply, &tmp);
-	C2_ASSERT(tmp == request);
-	c2_mutex_unlock(&slot->sl_mutex);
-	return 0;
-}
-C2_EXPORTED(c2_rpc_reply_post);
-
-bool c2_rpc_item_is_update(const struct c2_rpc_item *item)
-{
-	return (item->ri_type->rit_flags & C2_RPC_ITEM_TYPE_MUTABO) != 0;
-}
-
-bool c2_rpc_item_is_request(const struct c2_rpc_item *item)
-{
-	C2_PRE(item != NULL && item->ri_type != NULL);
-
-	return (item->ri_type->rit_flags & C2_RPC_ITEM_TYPE_REQUEST) != 0;
-}
-
-bool c2_rpc_item_is_reply(const struct c2_rpc_item *item)
-{
-	C2_PRE(item != NULL && item->ri_type != NULL);
-
-	return (item->ri_type->rit_flags & C2_RPC_ITEM_TYPE_REPLY) != 0;
-}
-
-bool c2_rpc_item_is_unsolicited(const struct c2_rpc_item *item)
-{
-	C2_PRE(item != NULL);
-	C2_PRE(item->ri_type != NULL);
-
-	return (item->ri_type->rit_flags & C2_RPC_ITEM_TYPE_UNSOLICITED) != 0;
-}
-
-bool c2_rpc_item_is_bound(const struct c2_rpc_item *item)
-{
-	C2_PRE(item != NULL);
-
-	return item->ri_slot_refs[0].sr_slot != NULL;
-}
-
-bool c2_rpc_item_is_unbound(const struct c2_rpc_item *item)
-{
-	return !c2_rpc_item_is_bound(item) && !c2_rpc_item_is_unsolicited(item);
-}
-
-int c2_rpc_unsolicited_item_post(const struct c2_rpc_conn *conn,
-		struct c2_rpc_item *item)
-{
-	struct c2_rpc_session	*session_zero;
-
-	C2_PRE(conn != NULL);
-	C2_PRE(item != NULL);
-
-	session_zero = c2_rpc_conn_session0(conn);
-
-	item->ri_session = session_zero;
-	item->ri_state = RPC_ITEM_SUBMITTED;
-
-	item->ri_rpc_time = c2_time_now();
-	frm_ubitem_added(item);
-	return 0;
-}
-
-int c2_rpc_core_init(void)
-{
-	int	rc;
-
-	rc = c2_rpc_base_init();
-	if (rc != 0)
-		return rc;
-
-	return c2_rpc_session_module_init();
-}
-
-void c2_rpc_core_fini(void)
-{
-	c2_rpc_session_module_fini();
-	c2_rpc_base_fini();
-}
-
-static void rpc_chan_ref_release(struct c2_ref *ref)
-{
-	struct c2_rpc_chan *chan;
-
-	C2_PRE(ref != NULL);
-
-	chan = container_of(ref, struct c2_rpc_chan, rc_ref);
-	C2_ASSERT(chan != NULL);
-	C2_PRE(c2_mutex_is_locked(&chan->rc_rpcmachine->cr_chan_mutex));
-
-	/* Destroy the chan structure. */
-	c2_list_del(&chan->rc_linkage);
-	frm_sm_fini(&chan->rc_frmsm);
-	c2_free(chan);
-}
-
-static int rpc_chan_create(struct c2_rpc_chan **chan,
-			   struct c2_rpcmachine *machine,
-			   struct c2_net_end_point *dest_ep,
-			   uint64_t max_rpcs_in_flight)
-{
-	struct c2_rpc_chan *ch;
-
-	C2_PRE(chan != NULL);
-	C2_PRE(dest_ep != NULL);
-	C2_PRE(machine != NULL);
-
-	C2_ALLOC_PTR_ADDB(ch, &machine->cr_rpc_machine_addb,
-			       &rpc_machine_addb_loc);
-	if (ch == NULL) {
-		*chan = NULL;
-		return -ENOMEM;
-	}
-
-	ch->rc_rpcmachine = machine;
-	ch->rc_destep = dest_ep;
-	c2_ref_init(&ch->rc_ref, 1, rpc_chan_ref_release);
-	c2_net_end_point_get(dest_ep);
-	frm_sm_init(&ch->rc_frmsm, max_rpcs_in_flight);
-	c2_mutex_lock(&machine->cr_chan_mutex);
-	c2_list_add(&machine->cr_chans, &ch->rc_linkage);
-	c2_mutex_unlock(&machine->cr_chan_mutex);
-	*chan = ch;
-	return 0;
-}
-
-static int rpc_tm_setup(struct c2_rpcmachine *machine,
-			struct c2_net_domain *net_dom, const char *ep_addr)
-{
-	int		rc;
-	struct c2_clink tmwait;
-
-	C2_PRE(machine != NULL);
-	C2_PRE(net_dom != NULL);
-	C2_PRE(ep_addr != NULL);
-
-	/* Allocate space for pointers of recv net buffers. */
-	C2_ALLOC_ARR(machine->cr_rcv_buffers, C2_RPC_TM_RECV_BUFFERS_NR);
-	if (machine->cr_rcv_buffers == NULL) {
-		C2_ADDB_ADD(&machine->cr_rpc_machine_addb,
-				&rpc_machine_addb_loc, c2_addb_oom);
-		return -ENOMEM;
-	}
-
-	machine->cr_tm.ntm_state = C2_NET_TM_UNDEFINED;
-	machine->cr_tm.ntm_callbacks = &c2_rpc_tm_callbacks;
-
-	/* Initialize the net transfer machine. */
-	rc = c2_net_tm_init(&machine->cr_tm, net_dom);
-	if (rc < 0) {
-		c2_free(machine->cr_rcv_buffers);
-		return rc;
-	}
-
-	/* Start the transfer machine so that users of this rpcmachine
-	   can send/receive messages. */
-	c2_clink_init(&tmwait, NULL);
-	c2_clink_add(&machine->cr_tm.ntm_chan, &tmwait);
-
-	rc = c2_net_tm_start(&machine->cr_tm, ep_addr);
-	if (rc < 0)
-		goto cleanup;
-
-	/* Wait on transfer machine channel till transfer machine is
-	   actually started. */
-	while (machine->cr_tm.ntm_state != C2_NET_TM_STARTED)
-		c2_chan_wait(&tmwait);
-
-	c2_clink_del(&tmwait);
-	c2_clink_fini(&tmwait);
-
-	/* Add buffers for receiving messages to this transfer machine. */
-	rc = recv_buffer_allocate_nr(net_dom, machine);
-	if (rc < 0) {
-		rpc_tm_cleanup(machine);
-		return rc;
-	}
-
-	return rc;
-cleanup:
-	c2_clink_del(&tmwait);
-	c2_clink_fini(&tmwait);
-	c2_free(machine->cr_rcv_buffers);
-	if (machine->cr_tm.ntm_state <= C2_NET_TM_FAILED)
-		c2_net_tm_fini(&machine->cr_tm);
-	return rc;
-}
-
-static struct c2_rpc_chan *rpc_chan_locate(struct c2_rpcmachine *machine,
-					   struct c2_net_end_point *dest_ep)
-{
-	bool			 found = false;
-	struct c2_rpc_chan	*chan;
-
-	C2_PRE(machine != NULL);
-	C2_PRE(dest_ep != NULL);
-
-	/* Locate the chan from rpcmachine->chans list. */
-	c2_mutex_lock(&machine->cr_chan_mutex);
-	c2_list_for_each_entry(&machine->cr_chans, chan, struct c2_rpc_chan,
-			       rc_linkage) {
-		C2_ASSERT(chan->rc_destep->nep_tm->ntm_dom ==
-			  dest_ep->nep_tm->ntm_dom);
-		if (chan->rc_destep == dest_ep) {
-			found = true;
-			break;
-		}
-	}
-
-	if (found) {
-		c2_ref_get(&chan->rc_ref);
-		c2_net_end_point_get(chan->rc_destep);
-	} else
-		chan = NULL;
-	c2_mutex_unlock(&machine->cr_chan_mutex);
-	return chan;
-}
-
-struct c2_rpc_chan *rpc_chan_get(struct c2_rpcmachine *machine,
-				 struct c2_net_end_point *dest_ep,
-				 uint64_t max_rpcs_in_flight)
-{
-	struct c2_rpc_chan	*chan;
-
-	C2_PRE(machine != NULL);
-	C2_PRE(dest_ep != NULL);
-
-
-	chan = rpc_chan_locate(machine, dest_ep);
-	if (chan == NULL)
-		rpc_chan_create(&chan, machine, dest_ep, max_rpcs_in_flight);
-	return chan;
-}
-
-void rpc_chan_put(struct c2_rpc_chan *chan)
-{
-	struct c2_rpcmachine *machine;
-
-	C2_PRE(chan != NULL);
-
-	machine = chan->rc_rpcmachine;
-	C2_PRE(machine != NULL);
-
-	c2_mutex_lock(&machine->cr_chan_mutex);
-	c2_net_end_point_put(chan->rc_destep);
-	c2_ref_put(&chan->rc_ref);
-	c2_mutex_unlock(&machine->cr_chan_mutex);
-}
-
-static void rpc_tm_cleanup(struct c2_rpcmachine *machine)
-{
-	int		cnt;
-	int		rc;
-	struct c2_clink	tmwait;
-
-	C2_PRE(machine != NULL);
-
-	c2_clink_init(&tmwait, NULL);
-	c2_clink_add(&machine->cr_tm.ntm_chan, &tmwait);
-
-	rc = c2_net_tm_stop(&machine->cr_tm, false);
-	if (rc < 0) {
-		c2_clink_del(&tmwait);
-		c2_clink_fini(&tmwait);
-		C2_ADDB_ADD(&machine->cr_rpc_machine_addb,
-			    &rpc_machine_addb_loc, rpc_machine_func_fail,
-			    "c2_net_tm_stop", 0);
-		return;
-	}
-
-	/* Wait for transfer machine to stop. */
-	while (machine->cr_tm.ntm_state != C2_NET_TM_STOPPED)
-		c2_chan_wait(&tmwait);
-	c2_clink_del(&tmwait);
-	c2_clink_fini(&tmwait);
-
-	/* Delete all the buffers from net domain. */
-	recv_buffer_deallocate_nr(machine, false, C2_RPC_TM_RECV_BUFFERS_NR);
-
-	/* Fini the transfer machine here and deallocate the chan. */
-	c2_net_tm_fini(&machine->cr_tm);
-	for (cnt = 0; cnt < C2_RPC_TM_RECV_BUFFERS_NR; ++cnt)
-		C2_ASSERT(machine->cr_rcv_buffers[cnt] == NULL);
-
-	c2_free(machine->cr_rcv_buffers);
-}
-
-int c2_rpc_reply_timedwait(struct c2_clink *clink, const c2_time_t timeout)
-{
-	bool	rc;
-
-	C2_PRE(clink != NULL);
-	C2_PRE(c2_clink_is_armed(clink));
-
-	rc = c2_chan_timedwait(clink, timeout);
-
-	return rc ? 0 : -ETIMEDOUT;
-}
-C2_EXPORTED(c2_rpc_reply_timedwait);
-
-int c2_rpc_group_timedwait(struct c2_rpc_group *group, const c2_time_t *timeout)
-{
-	return 0;
-}
-
-int c2_rpc_update_stream_get(struct c2_rpcmachine *machine,
-			     struct c2_service_id *srvid,
-			     enum c2_update_stream_flags flag,
-			     const struct c2_update_stream_ops *ops,
-			     struct c2_update_stream **out)
-{
-	int rc = -ENOMEM;
-
-	C2_ALLOC_PTR(*out);
-	if (*out == NULL)
-		return rc;
-
-	rc = update_stream_init(*out, machine);
-	if (rc < 0)
-		c2_free(*out);
-
-	if (ops != NULL) {
-		(*out)->us_ops = ops;
-	}
-
-	return rc;
-}
-
-void c2_rpc_update_stream_put(struct c2_update_stream *us)
-{
-	update_stream_fini(us);
-	c2_free(us);
-}
-
-/**
-   The callback routine to be called once the transfer machine
-   receives a buffer. This subroutine later invokes decoding of
-   net buffer and then notifies sessions component about every
-   incoming rpc item.
- */
-static void rpc_net_buf_received(const struct c2_net_buffer_event *ev)
-{
-	int			 rc;
-	c2_time_t		 now;
-	struct c2_rpc		 rpc;
-	struct c2_rpc_item	*item;
-	struct c2_rpc_item	*next_item;
-	struct c2_net_buffer	*nb;
-	struct c2_rpc_chan	*chan;
-	struct c2_rpcmachine	*machine;
-
-	C2_PRE(ev != NULL && ev->nbe_buffer != NULL);
-
-	/* Decode the buffer, get an RPC from it, traverse the
-	   list of rpc items from that rpc and post reply callbacks
-	   for each rpc item. */
-	nb = ev->nbe_buffer;
-
-	if (ev->nbe_status != 0)
-		goto last;
-
-	nb->nb_length = ev->nbe_length;
-	nb->nb_ep = ev->nbe_ep;
-
-	machine = container_of(nb->nb_tm, struct c2_rpcmachine, cr_tm);
-	chan = rpc_chan_locate(machine, nb->nb_ep);
-	if (chan != NULL) {
-		frm_rpcs_inflight_dec(&chan->rc_frmsm);
-		rpc_chan_put(chan);
-	}
-
-	c2_rpcobj_init(&rpc);
-	rc = c2_rpc_decode(&rpc, nb);
-	if (rc < 0)
-		goto last;
-
-	rpcobj_exit_stats_set(&rpc, machine, C2_RPC_PATH_INCOMING);
-	now = c2_time_now();
-	c2_list_for_each_entry_safe(&rpc.r_items, item, next_item,
-				    struct c2_rpc_item, ri_rpcobject_linkage) {
-
-		c2_list_del(&item->ri_rpcobject_linkage);
-
-		if (c2_rpc_item_is_conn_establish(item))
-			c2_rpc_fop_conn_establish_ctx_init(item, nb->nb_ep,
-							   machine);
-
-		item->ri_rpc_time = now;
-		rc = c2_rpc_item_received(item, machine);
-		/*
-		 * If 'item' is conn terminate reply then, do not
-		 * access item, after this point. In which case the
-		 * item might have already been freed.
-		 */
-	}
-
-	/* Add the c2_net_buffer back to the queue of
-	   transfer machine. */
-last:
-	nb->nb_qtype = C2_NET_QT_MSG_RECV;
-	nb->nb_ep = NULL;
-	nb->nb_callbacks = &c2_rpc_rcv_buf_callbacks;
-	if (nb->nb_tm->ntm_state == C2_NET_TM_STARTED)
-		rc = c2_net_buffer_add(nb, nb->nb_tm);
-}
-
-static int rpc_net_buffer_allocate(struct c2_net_domain *net_dom,
-		struct c2_net_buffer **nbuf, enum c2_net_queue_type qtype,
-		uint64_t rpc_size)
-{
-	int			 rc;
-	int32_t			 segs_nr;
-	c2_bcount_t		 seg_size;
-	c2_bcount_t		 buf_size;
-	c2_bcount_t		 nrsegs;
-	struct c2_net_buffer	*nb;
-
-	C2_PRE(net_dom != NULL);
-	C2_PRE((qtype == C2_NET_QT_MSG_RECV) || (qtype == C2_NET_QT_MSG_SEND));
-
-	/* As of now, we keep net_buffers as inline objects in c2_rpc_frm_buffer
-	   for sending part. Hence we need not allocate buffers in such case.
-	   This will change once we have a pool of buffers at sending side. */
-	if (qtype == C2_NET_QT_MSG_RECV) {
-		C2_ALLOC_PTR(nb);
-		if (nb == NULL)
-			return -ENOMEM;
-	} else
-		nb = *nbuf;
-
-	buf_size = c2_net_domain_get_max_buffer_size(net_dom);
-	segs_nr = c2_net_domain_get_max_buffer_segments(net_dom);
-	seg_size = c2_net_domain_get_max_buffer_segment_size(net_dom);
-	if (rpc_size != 0)
-		buf_size = rpc_size;
-
-	/* Allocate the bufvec of size = min((buf_size), (segs_nr * seg_size)).
-	   We keep the segment size constant. So mostly the number of segments
-	   is changed here. */
-	if (buf_size > (segs_nr * seg_size))
-		nrsegs = segs_nr;
-	else
-		nrsegs = buf_size / seg_size;
-	if (nrsegs == 0)
-		++nrsegs;
-
-	rc = c2_bufvec_alloc(&nb->nb_buffer, nrsegs, seg_size);
-	if (rc < 0) {
-		if (qtype == C2_NET_QT_MSG_RECV) {
-			c2_free(nb);
-			*nbuf = NULL;
-		}
-		return rc;
-	}
-
-	nb->nb_flags = 0;
-	nb->nb_qtype = qtype;
-	if (qtype == C2_NET_QT_MSG_RECV) {
-		nb->nb_callbacks = &c2_rpc_rcv_buf_callbacks;
-		nb->nb_min_receive_size = nrsegs * seg_size;
-		nb->nb_max_receive_msgs = 1;
-	} else
-		nb->nb_callbacks = &c2_rpc_send_buf_callbacks;
-
-	/* Register the buffer with given net domain. */
-	rc = c2_net_buffer_register(nb, net_dom);
-	if (rc < 0) {
-		c2_bufvec_free(&nb->nb_buffer);
-		if (qtype == C2_NET_QT_MSG_RECV) {
-			c2_free(nb);
-			nb = NULL;
-		}
-	}
-	*nbuf = nb;
-	return rc;
-}
-
-static int recv_buffer_allocate(struct c2_net_domain *net_dom,
-		struct c2_net_buffer **nb)
-{
-	C2_PRE(net_dom != NULL);
-	C2_PRE(nb != NULL);
-
-	return rpc_net_buffer_allocate(net_dom, nb, C2_NET_QT_MSG_RECV, 0);
-}
-
-int send_buffer_allocate(struct c2_net_domain *net_dom,
-		struct c2_net_buffer **nb, uint64_t rpc_size)
-{
-	C2_PRE(net_dom != NULL);
-	C2_PRE(nb != NULL);
-
-	return rpc_net_buffer_allocate(net_dom, nb, C2_NET_QT_MSG_SEND,
-			rpc_size);
-}
-
-static int recv_buffer_allocate_nr(struct c2_net_domain *net_dom,
-				   struct c2_rpcmachine *machine)
-{
-	int			 rc;
-	uint32_t		 cnt;
-	struct c2_net_buffer	*nb;
-
-	C2_PRE(net_dom != NULL);
-	C2_PRE(machine != NULL);
-
-	for (cnt = 0; cnt < C2_RPC_TM_RECV_BUFFERS_NR; ++cnt) {
-		rc = recv_buffer_allocate(net_dom, &nb);
-		if (rc != 0)
-			break;
-		machine->cr_rcv_buffers[cnt] = nb;
-		rc = c2_net_buffer_add(nb, &machine->cr_tm);
-		if (rc < 0)
-			break;
-	}
-	if (rc < 0)
-		recv_buffer_deallocate_nr(machine, true, cnt);
-
-	return rc;
-}
-
-void recv_buffer_deallocate(struct c2_net_buffer *nb,
-			    struct c2_rpcmachine *machine, bool tm_active)
-{
-	struct c2_clink			 tmwait;
-	struct c2_net_transfer_mc	*tm;
-	struct c2_net_domain		*net_dom;
-
-	C2_PRE(nb != NULL);
-	C2_PRE(machine != NULL);
-
-	tm = &machine->cr_tm;
-	net_dom = tm->ntm_dom;
-
-	/* Add to a clink to transfer machine's channel to wait for
-	   deletion of buffers from transfer machine. */
-	if (tm_active) {
-		c2_clink_init(&tmwait, NULL);
-		c2_clink_add(&tm->ntm_chan, &tmwait);
-
-		c2_net_buffer_del(nb, tm);
-		while ((nb->nb_flags & C2_NET_BUF_QUEUED) != 0)
-			c2_chan_wait(&tmwait);
-		c2_clink_del(&tmwait);
-		c2_clink_fini(&tmwait);
-	}
-
-	c2_net_buffer_deregister(nb, net_dom);
-	c2_bufvec_free(&nb->nb_buffer);
-	c2_free(nb);
-}
-
-void send_buffer_deallocate(struct c2_net_buffer *nb,
-		struct c2_net_domain *net_dom)
-{
-	C2_PRE(nb != NULL);
-	C2_PRE(net_dom != NULL);
-	C2_PRE((nb->nb_flags & C2_NET_BUF_QUEUED) == 0);
-
-	c2_net_buffer_deregister(nb, net_dom);
-	c2_bufvec_free(&nb->nb_buffer);
-}
-
-static void recv_buffer_deallocate_nr(struct c2_rpcmachine *machine,
-				      bool tm_active, uint32_t nr)
-{
-	int			 cnt;
-	struct c2_net_buffer	*nb;
-
-	C2_PRE(machine != NULL);
-	C2_PRE(nr <= C2_RPC_TM_RECV_BUFFERS_NR);
-
-	for (cnt = 0; cnt < nr; ++cnt) {
-		nb = machine->cr_rcv_buffers[cnt];
-		recv_buffer_deallocate(nb, machine, tm_active);
-		machine->cr_rcv_buffers[cnt] = NULL;
-	}
-}
-
-int c2_rpcmachine_init(struct c2_rpcmachine *machine, struct c2_cob_domain *dom,
-		       struct c2_net_domain *net_dom, const char *ep_addr,
-			struct c2_reqh *reqh)
-{
-	int		rc;
-	struct c2_db_tx tx;
-
-	C2_PRE(dom != NULL);
-	C2_PRE(machine != NULL);
-	C2_PRE(ep_addr != NULL);
-	C2_PRE(net_dom != NULL);
-
-	c2_db_tx_init(&tx, dom->cd_dbenv, 0);
-#ifndef __KERNEL__
-	rc = c2_rpc_root_session_cob_create(dom, &tx);
-	if (rc != 0) {
-		c2_db_tx_abort(&tx);
-		return rc;
-	}
-#endif
-
-	c2_mutex_init(&machine->cr_chan_mutex);
-	c2_list_init(&machine->cr_chans);
-	rc = rpc_tm_setup(machine, net_dom, ep_addr);
-	if (rc < 0)
-		goto cleanup;
-
-	c2_mutex_init(&machine->cr_stats_mutex);
-	c2_list_init(&machine->cr_incoming_conns);
-	c2_list_init(&machine->cr_outgoing_conns);
-	c2_mutex_init(&machine->cr_session_mutex);
-	c2_list_init(&machine->cr_ready_slots);
-	c2_mutex_init(&machine->cr_ready_slots_mutex);
-	c2_addb_ctx_init(&machine->cr_rpc_machine_addb,
-			&rpc_machine_addb_ctx_type, &c2_addb_global_ctx);
-	C2_SET_ARR0(machine->cr_rpc_stats);
-	machine->cr_dom = dom;
-	c2_db_tx_commit(&tx);
-	machine->cr_reqh = reqh;
-	return rc;
-
-cleanup:
-	c2_db_tx_abort(&tx);
-	c2_mutex_fini(&machine->cr_chan_mutex);
-	c2_list_fini(&machine->cr_chans);
-	return rc;
-}
-C2_EXPORTED(c2_rpcmachine_init);
-
-/**
-   XXX Temporary. This routine will be discarded, once rpc-core starts
-   providing c2_rpc_item::ri_ops::rio_sent() callback.
-
-   In-memory state of conn should be cleaned up when reply to CONN_TERMINATE
-   has been sent. As of now, rpc-core does not provide this callback. So this
-   is a temporary routine, that cleans up all terminated connections from
-   rpc connection list maintained in rpcmachine.
- */
-static void conn_list_fini(struct c2_list *list)
-{
-        struct c2_rpc_conn *conn;
-        struct c2_rpc_conn *conn_next;
-
-        C2_PRE(list != NULL);
-
-        c2_list_for_each_entry_safe(list, conn, conn_next, struct c2_rpc_conn,
-                        c_link) {
-
-                c2_rpc_conn_terminate_reply_sent(conn);
-
-        }
-}
-
-void c2_rpcmachine_fini(struct c2_rpcmachine *machine)
-{
-	C2_PRE(machine != NULL);
-
-	conn_list_fini(&machine->cr_incoming_conns);
-	c2_list_fini(&machine->cr_ready_slots);
-	c2_mutex_fini(&machine->cr_session_mutex);
-
-	rpc_tm_cleanup(machine);
-	c2_mutex_fini(&machine->cr_chan_mutex);
-	c2_list_fini(&machine->cr_chans);
-	c2_mutex_fini(&machine->cr_stats_mutex);
-	c2_addb_ctx_fini(&machine->cr_rpc_machine_addb);
-}
-C2_EXPORTED(c2_rpcmachine_fini);
-
-/** simple vector of update stream operations */
-void us_timeout(struct c2_update_stream *us)
-{
-	//DBG("us: ssid: %lu, slotid: %lu, TIMEOUT\n", us->us_session_id, us->us_slot_id);
-}
-
-void us_recovery_complete(struct c2_update_stream *us)
-{
-	//DBG("us: ssid: %lu, slotid: %lu, RECOVERED\n", us->us_session_id, us->us_slot_id);
-}
-
-static void fop_item_replied(struct c2_rpc_item *item)
-{
-	struct c2_fop *fop;
-
-	C2_PRE(item != NULL);
-
-	fop = c2_rpc_item_to_fop(item);
-	if (fop->f_type->ft_ops->fto_fop_replied != NULL)
-		fop->f_type->ft_ops->fto_fop_replied(fop);
-}
-
-/**
-   Find if given 2 rpc items belong to same type or not.
- */
-static bool item_equal(struct c2_rpc_item *item1, struct c2_rpc_item *item2)
-{
-	struct c2_fop *fop1;
-	struct c2_fop *fop2;
-
-	C2_PRE(item1 != NULL);
-	C2_PRE(item2 != NULL);
-
-	fop1 = c2_rpc_item_to_fop(item1);
-	fop2 = c2_rpc_item_to_fop(item2);
-
-	return fop1->f_type->ft_ops->fto_op_equal(fop1, fop2);
-}
-
-static bool item_fid_equal(struct c2_rpc_item *item1, struct c2_rpc_item *item2)
-{
-	struct c2_fop *fop1;
-	struct c2_fop *fop2;
-
-	C2_PRE(item1 != NULL);
-	C2_PRE(item2 != NULL);
-
-	fop1 = c2_rpc_item_to_fop(item1);
-	fop2 = c2_rpc_item_to_fop(item2);
-
-	return fop1->f_type->ft_ops->fto_fid_equal(fop1, fop2);
-}
-
-/**
-   RPC item ops function
-   Function to find out number of fragmented buffers in IO request
- */
-static uint64_t item_fragment_count_get(struct c2_rpc_item *item)
-{
-	struct c2_fop *fop;
-
-	C2_PRE(item != NULL);
-
-	fop = c2_rpc_item_to_fop(item);
-
-	return fop->f_type->ft_ops->fto_get_nfragments(fop);
-}
-
-static const struct c2_update_stream_ops update_stream_ops = {
-	.uso_timeout           = us_timeout,
-	.uso_recovery_complete = us_recovery_complete
-};
-
-static void item_vec_restore(struct c2_rpc_item *b_item, struct c2_fop *bkpfop)
-{
-	struct c2_fop *fop;
-
-	C2_PRE(b_item != NULL);
-	C2_PRE(bkpfop == NULL);
-
-	fop = c2_rpc_item_to_fop(b_item);
-	fop->f_type->ft_ops->fto_iovec_restore(fop, bkpfop);
-}
-
-/**
-   Coalesce rpc items that share same fid and intent(read/write)
-   @param c_item - c2_rpc_frm_item_coalesced structure.
-   @param b_item - Given bound rpc item.
-   @retval - 0 if routine succeeds, -ve number(errno) otherwise.
- */
-int item_io_coalesce(struct c2_rpc_frm_item_coalesced *c_item,
-		struct c2_rpc_item *b_item)
-{
-	int			 rc;
-	struct c2_fop		*fop;
-	struct c2_fop		*fop_next;
-	struct c2_fop		*b_fop;
-	struct c2_list		 fop_list;
-	struct c2_rpc_item	*item;
-
-	C2_PRE(b_item != NULL);
-	C2_PRE(c_item != NULL);
-
-	c2_list_init(&fop_list);
-	c2_list_for_each_entry(&c_item->ic_member_list, item,
-			struct c2_rpc_item, ri_coalesced_linkage) {
-		fop = c2_rpc_item_to_fop(item);
-		c2_list_add(&fop_list, &fop->f_link);
-	}
-	b_fop = container_of(b_item, struct c2_fop, f_item);
-
-	rc = fop->f_type->ft_ops->fto_io_coalesce(&fop_list, b_fop,
-			c_item->ic_bkpfop);
-
-	c2_list_for_each_entry_safe(&fop_list, fop, fop_next,
-			struct c2_fop, f_link)
-		c2_list_del(&fop->f_link);
-
-	c2_list_fini(&fop_list);
-	if (rc == 0)
-		c_item->ic_resultant_item = b_item;
-	return rc;
-}
-
-const struct c2_rpc_item_ops rpc_item_iov_ops = {
-	.rio_replied = fop_item_replied
-};
-
-const struct c2_rpc_item_type_ops rpc_item_iov_type_ops = {
-	.rito_iovec_restore = item_vec_restore,
-	.rito_item_size = c2_fop_item_type_default_onwire_size,
-	.rito_items_equal = item_equal,
-	.rito_fid_equal = item_fid_equal,
-	.rito_get_io_fragment_count = item_fragment_count_get,
-	.rito_io_coalesce = item_io_coalesce,
-        .rito_encode = c2_fop_item_type_default_encode,
-        .rito_decode = c2_fop_item_type_default_decode
-};
-
-/**
-  Set the stats for outgoing rpc object
-  @param rpcobj - incoming or outgoing rpc object
-  @param mach - rpcmachine for which the rpc object belongs to
-  @param path - enum distinguishing whether the item is incoming or outgoing
- */
-void rpcobj_exit_stats_set(const struct c2_rpc *rpcobj,
-		struct c2_rpcmachine *mach, const enum c2_rpc_item_path path)
-{
-	C2_PRE(rpcobj != NULL);
-	C2_PRE(mach != NULL);
-
-	c2_mutex_lock(&mach->cr_stats_mutex);
-	mach->cr_rpc_stats[path].rs_rpcs_nr++;
-	c2_mutex_unlock(&mach->cr_stats_mutex);
-}
-
-/**
-  Set the stats for outgoing rpc item
-  @param item - incoming or outgoing rpc item
-  @param path - enum distinguishing whether the item is incoming or outgoing
- */
-void item_exit_stats_set(struct c2_rpc_item *item,
-			 enum c2_rpc_item_path path)
-{
-	struct c2_rpcmachine *machine;
-	struct c2_rpc_stats  *st;
-
-	C2_PRE(item != NULL && item->ri_session != NULL);
-
-	machine = item->ri_session->s_conn->c_rpcmachine;
-	C2_ASSERT(machine != NULL);
-
-	C2_PRE(IS_IN_ARRAY(path, machine->cr_rpc_stats));
-
-	item->ri_rpc_time = c2_time_sub(c2_time_now(), item->ri_rpc_time);
-
-	st = &machine->cr_rpc_stats[path];
-	c2_mutex_lock(&machine->cr_stats_mutex);
-        st->rs_cumu_lat += item->ri_rpc_time;
-	st->rs_min_lat = st->rs_min_lat ? : item->ri_rpc_time;
-	st->rs_min_lat = min64u(st->rs_min_lat, item->ri_rpc_time);
-	st->rs_max_lat = st->rs_max_lat ? : item->ri_rpc_time;
-	st->rs_max_lat = max64u(st->rs_max_lat, item->ri_rpc_time);
-
-        st->rs_items_nr++;
-        st->rs_bytes_nr += c2_fop_item_type_default_onwire_size(item);
-
-	c2_mutex_unlock(&machine->cr_stats_mutex);
-}
-
-size_t c2_rpc_bytes_per_sec(struct c2_rpcmachine *machine,
-			    const enum c2_rpc_item_path path)
-{
-	struct c2_rpc_stats *stats;
-
-	C2_PRE(machine != NULL);
-	C2_PRE(IS_IN_ARRAY(path, machine->cr_rpc_stats));
-
-	stats = &machine->cr_rpc_stats[path];
-	return stats->rs_bytes_nr / stats->rs_cumu_lat;
-}
-
-c2_time_t c2_rpc_avg_item_time(struct c2_rpcmachine *machine,
-			       const enum c2_rpc_item_path path)
-{
-	struct c2_rpc_stats *stats;
-
-	C2_PRE(machine != NULL);
-	C2_PRE(IS_IN_ARRAY(path, machine->cr_rpc_stats));
-
-	stats = &machine->cr_rpc_stats[path];
-	return stats->rs_cumu_lat / stats->rs_items_nr;
-}
-
-static bool rpc_bulk_invariant(const struct c2_rpc_bulk *rbulk)
-{
-	if (rbulk == NULL || rbulk->rb_magic != C2_RPC_BULK_MAGIC)
-		return false;
-
-	return true;
-}
-
-static void rpc_bulk_buf_cb(const struct c2_net_buffer_event *evt)
-{
-	struct c2_rpc_bulk	*rbulk;
-	struct c2_net_buffer	*nb;
-
-	C2_PRE(evt != NULL && evt->nbe_buffer != NULL);
-
-	nb = evt->nbe_buffer;
-	rbulk = container_of(nb, struct c2_rpc_bulk, rb_nbuf);
-
-	C2_ASSERT(rpc_bulk_invariant(rbulk));
-	C2_ASSERT(c2_chan_has_waiters(&rbulk->rb_chan));
-
-	if (nb->nb_qtype == C2_NET_QT_PASSIVE_BULK_RECV ||
-	    nb->nb_qtype == C2_NET_QT_ACTIVE_BULK_RECV)
-		nb->nb_length = evt->nbe_length;
-
-	if (evt->nbe_status != 0)
-		rbulk->rb_rc = evt->nbe_status;
-
-	c2_chan_signal(&rbulk->rb_chan);
-}
-
-const struct c2_net_buffer_callbacks rpc_bulk_sender_cb  = {
-	.nbc_cb = {
-		[C2_NET_QT_PASSIVE_BULK_SEND] = rpc_bulk_buf_cb,
-		[C2_NET_QT_PASSIVE_BULK_RECV] = rpc_bulk_buf_cb,
-	}
-};
-
-const struct c2_net_buffer_callbacks rpc_bulk_receiver_cb = {
-	.nbc_cb = {
-		[C2_NET_QT_ACTIVE_BULK_RECV] = rpc_bulk_buf_cb,
-		[C2_NET_QT_ACTIVE_BULK_SEND] = rpc_bulk_buf_cb,
-	}
-};
-
-int c2_rpc_bulk_init(struct c2_rpc_bulk *rbulk,
-		     const uint32_t segs_nr,
-		     const c2_bcount_t seg_size,
-		     struct c2_net_domain *netdom)
-{
-	C2_PRE(rbulk != NULL);
-	C2_PRE(segs_nr != 0);
-	C2_PRE(seg_size != 0);
-	C2_PRE(netdom != NULL);
-
-	if (seg_size > c2_net_domain_get_max_buffer_segment_size(netdom) ||
-	    segs_nr > c2_net_domain_get_max_buffer_segments(netdom) ||
-	    segs_nr * seg_size > c2_net_domain_get_max_buffer_size(netdom))
-		return -EMSGSIZE;
-
-	c2_chan_init(&rbulk->rb_chan);
-	rbulk->rb_magic = C2_RPC_BULK_MAGIC;
-	rbulk->rb_rc = 0;
-	return c2_0vec_init(&rbulk->rb_zerovec, segs_nr);
-}
-
-void c2_rpc_bulk_fini(struct c2_rpc_bulk *rbulk)
-{
-	C2_PRE(rbulk != NULL);
-	C2_PRE(rpc_bulk_invariant(rbulk));
-
-	c2_chan_fini(&rbulk->rb_chan);
-	c2_0vec_fini(&rbulk->rb_zerovec);
-}
-
-#ifdef __KERNEL__
-int c2_rpc_bulk_page_add(struct c2_rpc_bulk *rbulk,
-			 struct page *pg,
-			 const c2_bindex_t index)
-{
-	int rc;
-
-	C2_PRE(rbulk != NULL);
-	C2_PRE(pg != NULL);
-	C2_PRE(rpc_bulk_invariant(rbulk));
-
-	rc = c2_0vec_page_add(&rbulk->rb_zerovec, pg, index);
-
-	if (rc == 0)
-		rbulk->rb_nbuf.nb_buffer = rbulk->rb_zerovec.z_bvec;
-
-	C2_POST(rpc_bulk_invariant(rbulk));
-	return rc;
-}
-#endif
-
-int c2_rpc_bulk_buf_add(struct c2_rpc_bulk *rbulk,
-			void *buf,
-			const c2_bcount_t count,
-			const c2_bindex_t index)
-{
-	int		rc;
-	struct c2_buf	cbuf;
-
-	C2_PRE(rbulk != NULL);
-	C2_PRE(buf != NULL);
-	C2_PRE(count != 0);
-	C2_PRE(rpc_bulk_invariant(rbulk));
-
-	cbuf.b_addr = buf;
-	cbuf.b_nob = count;
-	rc = c2_0vec_cbuf_add(&rbulk->rb_zerovec, &cbuf, &index);
-	if (rc == 0)
-		rbulk->rb_nbuf.nb_buffer = rbulk->rb_zerovec.z_bvec;
-
-	C2_POST(rpc_bulk_invariant(rbulk));
-	return rc;
-}
-
-int c2_rpc_bulk_store(struct c2_rpc_bulk *rbulk, struct c2_rpc_item *item,
-		      struct c2_net_buf_desc *to_desc)
-{
-	int				 rc;
-	struct c2_net_transfer_mc	*tm;
-
-	C2_PRE(rbulk != NULL);
-	C2_PRE(rbulk->rb_nbuf.nb_flags & C2_NET_BUF_REGISTERED);
-	C2_PRE(rbulk->rb_nbuf.nb_length == c2_vec_count(
-	       &rbulk->rb_zerovec.z_bvec.ov_vec));
-	C2_PRE(rbulk->rb_nbuf.nb_ep != NULL);
-	C2_PRE(rbulk->rb_nbuf.nb_qtype == C2_NET_QT_PASSIVE_BULK_RECV ||
-	       rbulk->rb_nbuf.nb_qtype == C2_NET_QT_PASSIVE_BULK_SEND);
-	C2_PRE(rpc_bulk_invariant(rbulk));
-	C2_PRE(item != NULL);
-	C2_PRE(to_desc != NULL);
-
-	tm = &item->ri_session->s_conn->c_rpcmachine->cr_tm;
-	C2_ASSERT(rbulk->rb_nbuf.nb_dom == tm->ntm_dom);
-
-	rc = c2_net_buffer_add(&rbulk->rb_nbuf, tm);
-	if (rc != 0)
-		return rc;
-
-	rc = c2_net_desc_copy(&rbulk->rb_nbuf.nb_desc, to_desc);
-	if (rc != 0)
-		c2_net_buffer_del(&rbulk->rb_nbuf, tm);
-
-	C2_POST(rpc_bulk_invariant(rbulk));
-	return rc;
-}
-
-int c2_rpc_bulk_load(struct c2_rpc_bulk *rbulk, struct c2_rpc_item *item)
-{
-	int				 rc;
-	struct c2_net_buf_desc		 from_desc;
-	struct c2_net_transfer_mc	*tm;
-
-	C2_PRE(rbulk != NULL);
-	C2_PRE(rbulk->rb_nbuf.nb_flags & C2_NET_BUF_REGISTERED);
-	C2_PRE(rbulk->rb_nbuf.nb_qtype == C2_NET_QT_ACTIVE_BULK_RECV ||
-	       rbulk->rb_nbuf.nb_qtype == C2_NET_QT_ACTIVE_BULK_SEND);
-	C2_PRE(rpc_bulk_invariant(rbulk));
-
-	tm = &item->ri_session->s_conn->c_rpcmachine->cr_tm;
-	C2_ASSERT(rbulk->rb_nbuf.nb_dom == tm->ntm_dom);
-
-	/* Get the net buf descriptor from io fop. */
-	item->ri_type->rit_ops->rito_io_desc_get(item, &from_desc);
-	rc = c2_net_desc_copy(&from_desc, &rbulk->rb_nbuf.nb_desc);
-	if (rc != 0)
-		return rc;
-
-	rc = c2_net_buffer_add(&rbulk->rb_nbuf, tm);
-
-	C2_POST(rpc_bulk_invariant(rbulk));
-	return rc;
-}
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
diff --git a/rpc/rpc2.h b/rpc/rpc2.h
deleted file mode 100644
index 3f224eb..0000000
--- a/rpc/rpc2.h
+++ /dev/null
@@ -1,1000 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Nikita_Danilov <Nikita_Danilov@xyratex.com>
- *		    Anand Vidwansa <Anand_Vidwansa@xyratex.com>
- *                  Anup Barve <Anup_Barve@xyratex.com>
- * Original creation date: 04/28/2011
- */
-
-/**
-   @defgroup rpc_layer_core RPC layer core
-   @page rpc-layer-core-dld RPC layer core DLD
-   @section Overview
-   RPC layer core is used to transmitt rpc items and groups of them.
-
-   @section rpc-layer-core-logic Logical specification.
-   Typical scenario in terms of current interfaces looks like the following:
-   User sends (a) FOPs one by one, or (b)group of FOPs and waits for
-   reply from endpoint. Such interactions can be expressed in terms of
-   provided interfaces:
-
-   @code
-   static void us_callback(struct c2_update_stream *us,
-                           struct c2_rpc_item *item)             { ... }
-   static const struct c2_update_stream_ops us_ops { .uso_event_cb = us_callback };
-   //...
-   int ret;
-   int i;
-   struct c2_rpcmachine mach;
-   uint64_t session_id;
-   struct c2_update_stream *update_stream;
-   struct c2_rpc_item item[] = {DUMMY_INITIALIZER, DUMMY_INITIALIZER, ...};
-   struct c2_rpc_group *group;
-   struct c2_rpc_item_type_ops item_ops = { .rito_item_cb = item_callback };
-   struct c2_time timeout = DUMMY_TIMEOUT;
-   // initialising fop operations vectors:
-   static struct c2_rpc_item_type_ops fop_item_type_ops;
-   static struct c2_rpc_item_type fop_item_type;
-   fop_item_type.rit_ops = &fop_item_type_ops;
-
-   // INITIALISATION:
-   //
-   // initialise rpc layer core internal data structures.
-   // c2_rpc_core_init() should be called in core/colibri/init.c
-   // and executed as a part of c2_init().
-
-   // create rpc machine.
-   ret = c2_rpcmachine_init(&mach, cob_domain, net_domain, ep_addr);
-   // create/get update stream used for interaction between endpoints
-   ret = c2_rpc_update_stream_get(&mach, &srvid,
-	C2_UPDATE_STREAM_SHARED_SLOT, &us_ops, &update_stream);
-
-   // USAGE (a):
-   // sending rpc_items
-   item.ri_type = &fop_item_type;
-   ret = c2_rpc_submit(&srvid, &update_stream, &item,
-	C2_RPC_ITEM_PRIO_MIN, C2_RPC_CACHING_TYPE);
-   // waiting for reply:
-   ret = c2_rpc_reply_timedwait(&clink, &timeout);
-
-   // USAGE (b):
-   // open and generate new group, used in formation.
-   ret = c2_rpc_group_open(&mach, &group);
-
-   // send group of items
-   for (i = 0; i < ARRAY_SIZE(item); ++i) {
-      item[i].ri_type = &fop_item_type;
-      ret = c2_rpc_group_submit(&mach, group, &item[i], &srvid, &update_stream,
-	C2_RPC_ITEM_PRIO_MIN, C2_RPC_CACHING_TYPE);
-   }
-
-   ret = c2_rpc_group_close(&mach, group);
-
-   @endcode
-
-   @section rpc-layer-core-func Functional specification.
-   Internally, the RPC layer core should do the following:
-   @li put items into sub-caches, associated with specified services;
-   @li monitor the occupancy of the sub-caches;
-   @li when there is enough pages in a sub-cache to form an optimal rpc---form it and send.
-
-   For simple implementation one update stream may be maped onto one slot.
-   Several update streams may be mapped onto one slot for more complex cases.
-
-   Update stream state machine:
-   @verbatim
-      UNINITIALIZED
-           | update_stream_init()
-           |
-           |                     next_item()
-           |                  +-----+
-           V    next_item()   V     |    timeout
-          IDLE------------->SENDING-+------------>TIMEDOUT---+
-           | ^                ^next_item()                   |
-           | |  revovery done |               retry          |
-           | +--------------RECOVERY<------------------------+
-           |
-           | update_stream_fini()
-           V
-       FINALIZED
-    @endverbatim
-
-   RPC-item state machine:
-    @verbatim
-      UNINITIALIZED
-           | rpc_item_init()
-           V
-         IN USE
-           |
-           | c2_rpc_item_submit()
-           |
-           V   added to RPC    sent over nw      got reply over nw
-         SUBMITTED------>ADDED------------->SENT----------------> REPLIED--+
-           |               |                                               |
-  c2_rpc_item_cancel()     | c2_rpc_item_cancel()                          |
-           |               V                           rpc_item_fini()     |
-           +----------->FINALIZED<-----------------------------------------+
-
-      @endverbatim
-
-   @see https://docs.google.com/a/xyratex.com/Doc?docid=0AQaCw6YRYSVSZGZmMzV6NzJfMTljbTZ3anhjbg&hl=en
-
-   @{
-*/
-
-#ifndef __COLIBRI_RPC_RPCCORE_H__
-#define __COLIBRI_RPC_RPCCORE_H__
-
-#include "lib/cdefs.h"
-#include "lib/mutex.h"
-#include "lib/list.h"
-#include "lib/tlist.h"
-#include "lib/time.h"
-#include "lib/refs.h"
-#include "lib/chan.h"
-#include "net/net.h"
-#include "dtm/verno.h"		/* for c2_verno */
-#include "lib/time.h"
-#include "lib/timer.h"
-
-#include "cob/cob.h"
-#include "rpc/session_internal.h"
-#include "rpc/session.h"
-#include "addb/addb.h"
-#include "rpc/rpc_base.h"
-
-enum c2_rpc_item_priority {
-	C2_RPC_ITEM_PRIO_MIN,
-	C2_RPC_ITEM_PRIO_MID,
-	C2_RPC_ITEM_PRIO_MAX,
-	C2_RPC_ITEM_PRIO_NR
-};
-
-#include "rpc/formation.h"
-
-struct page;
-struct c2_rpc;
-struct c2_rpc_item;
-struct c2_addb_rec;
-struct c2_rpc_formation;
-struct c2_rpc_conn;
-struct c2_fop_type;
-struct c2_fop_io_vec;
-struct c2_rpc_group;
-struct c2_rpcmachine;
-struct c2_update_stream;
-struct c2_update_stream_ops;
-struct c2_rpc_frm_item_coalesced;
-
-/** TBD in sessions header */
-enum c2_update_stream_flags {
-	/* one slot per one update stream */
-	C2_UPDATE_STREAM_DEDICATED_SLOT = 0,
-	/* several update streams share the same slot */
-	C2_UPDATE_STREAM_SHARED_SLOT    = (1 << 0)
-};
-
-enum {
-	/* Hex value for "rpcmagic" */
-	C2_RPC_MAGIC = 0x7270636d61676963
-};
-
-struct c2_rpc_item_ops {
-	/**
-	   Called when given item's sent.
-	   @param item reference to an RPC-item sent
-	   @note ri_added() has been called before invoking this function.
-	 */
-	void (*rio_sent)(struct c2_rpc_item *item);
-	/**
-	   Called when item's added to an RPC
-	   @param rpc reference to an RPC where item's added
-	   @param item reference to an item added to rpc
-	 */
-	void (*rio_added)(struct c2_rpc *rpc, struct c2_rpc_item *item);
-
-	/**
-	   Called when given item's replied.
-	   @param item reference to an RPC-item on which reply FOP was received.
-
-	   @note ri_added() and ri_sent() have been called before invoking this
-	   function.
-
-	   c2_rpc_item::ri_error and c2_rpc_item::ri_reply are already set by
-	   the time this method is called.
-	 */
-	void (*rio_replied)(struct c2_rpc_item *item);
-
-	/**
-	   Finalise and free item.
-	   @see c2_fop_default_item_ops
-	   @see c2_fop_item_free(), can be used with fops that are not embedded
-	   in any other object.
-	 */
-	void (*rio_free)(struct c2_rpc_item *item);
-};
-
-struct c2_update_stream_ops {
-	/** Called when update stream enters UPDATE_STREAM_TIMEDOUT state */
-	void (*uso_timeout)(struct c2_update_stream *us);
-	/** Called when update stream exits UPDATE_STREAM_RECOVERY state */
-	void (*uso_recovery_complete)(struct c2_update_stream *us);
-};
-
-enum c2_update_stream_state {
-	/** Newly allocated object is in uninitialized state */
-	UPDATE_STREAM_UNINITIALIZED = 0,
-	/** Enters when update stream is initialized */
-	UPDATE_STREAM_IDLE      = (1 << 0),
-	/** Enters when items are being sent with update stream */
-	UPDATE_STREAM_SENDING   = (1 << 1),
-	/** Enters when sending operation is timed out */
-	UPDATE_STREAM_TIMEDOUT  = (1 << 2),
-	/** Enters when update stream recovers "lost" items */
-	UPDATE_STREAM_RECOVERY  = (1 << 3),
-	/** Enters when update stream is finalized */
-	UPDATE_STREAM_FINALIZED = (1 << 4)
-};
-
-/**
-   Update streams is an abstraction that serves the following goals:
-   @li Hides the sessions and slots abstractions;
-   @li Multiplexes several update streams which the the only one session;
-   @li Signal about events (state transitions, etc.) happened in sessions layer.
- */
-struct c2_update_stream {
-	/* linkage to c2_rpcmachine::c2_rpc_processing::crp_us_list */
-	struct c2_list_link		   us_linkage;
-
-	uint64_t			   us_session_id;
-	uint64_t		           us_slot_id;
-	const struct c2_update_stream_ops *us_ops;
-	struct c2_rpcmachine		  *us_mach;
-	enum c2_update_stream_state        us_state;
-        struct c2_mutex			   us_guard;
-};
-
-/**
-   Possible values for flags from c2_rpc_item_type.
- */
-#if 0
-enum c2_rpc_item_type_flag {
-	/** Item with valid session, slot and version number. */
-	//C2_RPC_ITEM_BOUND = (1 << 0),
-	/** Item with a session but no slot nor version number. */
-	//C2_RPC_ITEM_UNBOUND = (1 << 1),
-	/** Item similar to unbound item except it is always sent as
-	    unbound item and it does not expect any reply. */
-	//C2_RPC_ITEM_UNSOLICITED = (1 << 2),
-};
-#endif
-
-#define C2_RPC_ITEM_TYPE_DEF(itype, opcode, flags, ops)  \
-struct c2_rpc_item_type (itype) = {                      \
-	.rit_opcode = (opcode),                          \
-	.rit_flags = (flags),                            \
-	.rit_ops = (ops)                                 \
-};
-
-int c2_rpc_unsolicited_item_post(const struct c2_rpc_conn *conn,
-				 struct c2_rpc_item *item);
-
-bool c2_rpc_item_is_bound(const struct c2_rpc_item *item);
-
-bool c2_rpc_item_is_unbound(const struct c2_rpc_item *item);
-
-bool c2_rpc_item_is_unsolicited(const struct c2_rpc_item *item);
-
-enum c2_rpc_item_state {
-	/** Newly allocated object is in uninitialized state */
-	RPC_ITEM_UNINITIALIZED = 0,
-	/** After successful initialization item enters to "in use" state */
-	RPC_ITEM_IN_USE = (1 << 0),
-	/** After item's added to the formation cache */
-	RPC_ITEM_SUBMITTED = (1 << 1),
-	/** After item's added to an RPC it enters added state */
-	RPC_ITEM_ADDED = (1 << 2),
-	/** After item's sent  it enters sent state */
-	RPC_ITEM_SENT = (1 << 3),
-	/** After item's sent is failed, it enters send failed state */
-	RPC_ITEM_SEND_FAILED = (1 << 4),
-	/** After item's replied  it enters replied state */
-	RPC_ITEM_REPLIED = (1 << 5),
-	/** After finalization item enters finalized state*/
-	RPC_ITEM_FINALIZED = (1 << 6)
-};
-/** Stages of item in slot */
-enum c2_rpc_item_stage {
-	/** the reply for the item was received and the receiver confirmed
-	    that the item is persistent */
-	RPC_ITEM_STAGE_PAST_COMMITTED = 1,
-	/** the reply was received, but persistence confirmation wasn't */
-	RPC_ITEM_STAGE_PAST_VOLATILE,
-	/** the item was sent (i.e., placed into an rpc) and no reply is
-	    received */
-	RPC_ITEM_STAGE_IN_PROGRESS,
-	/** the item is not sent */
-	RPC_ITEM_STAGE_FUTURE,
-};
-
-enum {
-	/** Maximum number of slots to which an rpc item can be associated */
-	MAX_SLOT_REF = 1
-};
-
-/**
-   A single RPC item, such as a FOP or ADDB Record.  This structure should be
-   included in every item being sent via RPC layer core to emulate relationship
-   similar to inheritance and to allow extening the set of rpc_items without
-   modifying core rpc headers.
-   @see c2_fop.
- */
-struct c2_rpc_item {
-	struct c2_chan			 ri_chan;
-	enum c2_rpc_item_priority	 ri_prio;
-	c2_time_t			 ri_deadline;
-	struct c2_rpc_group		*ri_group;
-
-	enum c2_rpc_item_state		 ri_state;
-	enum c2_rpc_item_stage		 ri_stage;
-	uint64_t			 ri_flags;
-	struct c2_rpc_session		*ri_session;
-	struct c2_rpc_slot_ref		 ri_slot_refs[MAX_SLOT_REF];
-	/** Anchor to put item on c2_rpc_session::s_unbound_items list */
-	struct c2_list_link		 ri_unbound_link;
-	int32_t				 ri_error;
-	/** Pointer to the type object for this item */
-	struct c2_rpc_item_type		*ri_type;
-	/** Linkage to the forming list, needed for formation */
-	struct c2_list_link		 ri_rpcobject_linkage;
-	/** Linkage to the unformed rpc items list, needed for formation */
-	struct c2_list_link		 ri_unformed_linkage;
-	/** Linkage to the group c2_rpc_group, needed for grouping */
-	struct c2_list_link		 ri_group_linkage;
-	/** Linkage to list of items which are coalesced, anchored
-	    at c2_rpc_frm_item_coalesced::ic_member_list. */
-	struct c2_list_link		 ri_coalesced_linkage;
-	/** Timer associated with this rpc item.*/
-	struct c2_timer			 ri_timer;
-	/** reply item */
-	struct c2_rpc_item		*ri_reply;
-	/** item operations */
-	const struct c2_rpc_item_ops	*ri_ops;
-	/** Dummy queue linkage to dummy reqh */
-	struct c2_queue_link		 ri_dummy_qlinkage;
-	/** Time spent in rpc layer. */
-	c2_time_t			 ri_rpc_time;
-};
-
-/** Enum to distinguish if the path is incoming or outgoing */
-enum c2_rpc_item_path {
-	C2_RPC_PATH_INCOMING = 0,
-	C2_RPC_PATH_OUTGOING,
-	C2_RPC_PATH_NR
-};
-
-/**
-  Statistical data maintained for each item in the rpcmachine.
-  It is upto the higher level layers to retrieve and process this data
- */
-struct c2_rpc_stats {
-	/** Number of items processed */
-	uint64_t	rs_items_nr;
-	/** Number of bytes processed */
-	uint64_t	rs_bytes_nr;
-	/** Cumulative latency. */
-	c2_time_t	rs_cumu_lat;
-	/** Min Latency */
-	c2_time_t	rs_min_lat;
-	/** Max Latency */
-	c2_time_t	rs_max_lat;
-	/** Number of rpc objects (used to calculate packing density) */
-	uint64_t	rs_rpcs_nr;
-};
-
-/**
-   Associate an rpc with its corresponding rpc_item_type.
-   Since rpc_item_type by itself can not be uniquely identified,
-   rather it is tightly bound to its fop_type, the fop_type_code
-   is passed, based on which the rpc_item is associated with its
-   rpc_item_type.
- */
-void c2_rpc_item_type_attach(struct c2_fop_type *fopt);
-
-void c2_rpc_item_init(struct c2_rpc_item *item);
-
-void c2_rpc_item_fini(struct c2_rpc_item *item);
-
-void c2_rpc_item_fini(struct c2_rpc_item *item);
-
-/**
-   Returns true if item modifies file system state, false otherwise
- */
-bool c2_rpc_item_is_update(const struct c2_rpc_item *item);
-
-/**
-   Returns true if item is request item. False if it is a reply item
- */
-bool c2_rpc_item_is_request(const struct c2_rpc_item *item);
-
-struct c2_rpc_group {
-	struct c2_rpcmachine	*rg_mach;
-	/** List of rpc items linked through c2_rpc_item:ri_group_linkage. */
-	struct c2_list		 rg_items;
-	/** expected number of items in the group */
-	uint64_t		 rg_expected;
-        /** lock protecting fields of the struct */
-        struct c2_mutex		 rg_guard;
-	/** signalled when a reply is received or an error happens
-	     (usually a timeout). */
-	struct c2_chan		 rg_chan;
-};
-
-/**
-   Struct c2_rpc_chan provides information about a target network endpoint.
-   An rpc machine (struct c2_rpcmachine) contains list of c2_rpc_chan structures
-   targeting different net endpoints.
-   Rationale A physical node can have multiple endpoints associated with it.
-   And multiple services can share endpoints for transport.
-   The rule of thumb is to use one transfer machine per endpoint.
-   So to make sure that services using same endpoint,
-   use the same transfer machine, this structure has been introduced.
-   Struct c2_rpc_conn is used for a particular service and now it
-   points to a struct c2_rpc_chan to identify the transfer machine
-   it is working with.
- */
-struct c2_rpc_chan {
-	/** Linkage to the list maintained by c2_rpcmachine.*/
-	struct c2_list_link		  rc_linkage;
-	/** Number of c2_rpc_conn structures using this transfer machine.*/
-	struct c2_ref			  rc_ref;
-	/** Formation state machine associated with chan. */
-	struct c2_rpc_frm_sm		  rc_frmsm;
-	/** Destination end point to which rpcs will be sent. */
-	struct c2_net_end_point		 *rc_destep;
-	/** The rpcmachine, this chan structure is associated with.*/
-	struct c2_rpcmachine		 *rc_rpcmachine;
-};
-
-/**
-   RPC machine is an instance of RPC item (FOP/ADDB) processing context.
-   Several such contexts might be existing simultaneously.
- */
-struct c2_rpcmachine {
-	/** Mutex protecting list of c2_rpc_chan structures. */
-	struct c2_mutex			  cr_chan_mutex;
-	/** List of c2_rpc_chan structures. */
-	struct c2_list			  cr_chans;
-	/** Transfer machine associated with this endpoint.*/
-	struct c2_net_transfer_mc	  cr_tm;
-	/** Pool of receive buffers associated with this transfer machine. */
-	struct c2_net_buffer		**cr_rcv_buffers;
-	/** Cob domain in which cobs related to session will be stored */
-	struct c2_cob_domain		 *cr_dom;
-	/** List of rpc connections
-	    conn is in list if conn->c_state is not in {CONN_UNINITIALIZED,
-	    CONN_FAILED, CONN_TERMINATED} */
-	struct c2_list			  cr_incoming_conns;
-	struct c2_list			  cr_outgoing_conns;
-	/** mutex that protects [incoming|outgoing]_conns. Better name??? */
-	struct c2_mutex			  cr_session_mutex;
-	/** Mutex to protect list of ready slots. */
-	struct c2_mutex			  cr_ready_slots_mutex;
-	/** list of ready slots. */
-	struct c2_list			  cr_ready_slots;
-	/** ADDB context for this rpcmachine */
-	struct c2_addb_ctx		  cr_rpc_machine_addb;
-	/** Statistics for both incoming and outgoing paths */
-	struct c2_rpc_stats		  cr_rpc_stats[C2_RPC_PATH_NR];
-	/** Mutex to protect stats */
-	struct c2_mutex			  cr_stats_mutex;
-	/**
-	    Request handler this rpcmachine belongs to.
-	    @todo There needs to be  generic mechanism to register a
-		request handler (or any other handler for future use)
-		with the rpc machine and a ops vector specifying a
-		method to be invoked for futher processing,
-		e.g. c2_reqh_fop_handle(), in case of reqh.
-	*/
-	struct c2_reqh                   *cr_reqh;
-
-        /**
-	    Linkage into request handler's list of rpc machines.
-	    c2_reqh::rh_rpcmachines
-	 */
-        struct c2_tlink                   cr_rh_linkage;
-
-	uint64_t                          cr_magic;
-};
-
-/**
-   Construct rpc core layer
-   @return 0 success
-   @return -ENOMEM failure
-*/
-int  c2_rpc_core_init(void);
-/** Destruct rpc core layer */
-void c2_rpc_core_fini(void);
-
-/**
-   Rpc machine is a running instance of rpc layer. A number of rpc machine
-   structures can co-exist in rpc layer. With every rpc machine, a sessions
-   module, a formation module, sending/receiving logic and statistics
-   components are associated.
-
-   @param machine Input rpcmachine object.
-   @param dom cob domain that contains cobs representing slots
-   @param net_dom Network domain, this rpcmachine is associated with.
-   @param ep_addr Source end point address to associate with the transfer mc.
-   @pre c2_rpc_core_init().
- */
-int  c2_rpcmachine_init(struct c2_rpcmachine	*machine,
-			struct c2_cob_domain	*dom,
-			struct c2_net_domain	*net_dom,
-			const char		*ep_addr,
-			struct c2_reqh          *reqh);
-
-/**
-   Destruct rpcmachine
-   @param machine rpcmachine operation applied to.
- */
-void c2_rpcmachine_fini(struct c2_rpcmachine *machine);
-
-/**
-  Posts an unbound item to the rpc layer.
-
-  The item will be sent through one of item->ri_session slots.
-
-  The rpc layer will try to send the item out not later than
-  item->ri_deadline and with priority of item->ri_priority.
-
-  If this call returns without errors, the item's reply call-back is
-  guaranteed to be called eventually.
-
-  After successful call to c2_rpc_post(), user should not free the item.
-  Rpc-layer will internally free the item when rpc-layer is sure that the item
-  will not take part in recovery.
-
-  Rpc layer does not provide any API, to "wait until reply is received".
-  Upon receiving reply to item, item->ri_chan is signaled.
-  If item->ri_ops->rio_replied() callback is set, then it will be called.
-  Pointer to reply item can be retrieved from item->ri_reply.
-  If any error occured, item->ri_error is set to non-zero value.
-
-  Note: setting item->ri_ops and adding clink to item->ri_chan MUST be done
-  before calling c2_rpc_post(), because reply to the item can arrive even
-  before c2_rpc_post() returns.
-
-  @pre item->ri_session != NULL
-  @pre item->ri_priority is sane.
-*/
-int c2_rpc_post(struct c2_rpc_item *item);
-
-#if 0
-/**
-  Posts an item bound to the update stream.
-*/
-int c2_rpc_update_stream_post(struct c2_update_stream *str,
-                 struct c2_rpc_item *item);
-#endif
-
-/**
-  Posts reply item on the same session on which the request item is received.
-
-  After successful call to c2_rpc_reply_post(), user should not free the reply
-  item. Rpc-layer will internally free the item when rpc-layer is sure that
-  the corresponding request item will not take part in recovery.
- */
-int c2_rpc_reply_post(struct c2_rpc_item *request,
-		      struct c2_rpc_item *reply);
-
-/**
-   Generate group used to treat rpc items as a group.
-
-   @param machine rpcmachine operation applied to.
-   @param group returned from the function
-
-   @pre c2_rpc_core_init()
-   @pre c2_rpcmachine_init()
-   @return 0 success
-   @return -ENOMEM failure
- */
-int c2_rpc_group_open(struct c2_rpcmachine *machine,
-		      struct c2_rpc_group **group);
-
-/**
-   Tell RPC layer core that group is closed
-   and it can be processed by RPC core processing
-
-   @param machine rpcmachine operation applied to.
-   @param group return value from the function
-
-   @pre c2_rpc_core_init()
-   @pre c2_rpcmachine_init()
-   @return 0  success
-   @return <0 failure
- */
-int c2_rpc_group_close(struct c2_rpc_group *group);
-
-/**
-   Submit rpc item group into processing engine.
-   or change parameters (priority, caching policy
-   and group membership) of an already submitted item.
-
-   @param group used treat rpc items as a group.
-   @param item rpc item being sent
-   @param us update stream used to send the group
-   @param prio priority of processing of this item
-   @param deadline maximum processing time of this item
-
-   @pre c2_rpc_core_init()
-   @pre c2_rpcmachine_init()
-   @return 0  success
-   @return <0 failure
- */
-int c2_rpc_group_submit(struct c2_rpc_group		*group,
-			struct c2_rpc_item		*item,
-			struct c2_update_stream		*us,
-			enum c2_rpc_item_priority	 prio,
-			const c2_time_t			*deadline);
-
-/**
-   Wait for the reply on item being sent.
-
-   @param The clink on which caller is waiting for item reply.
-   @param timeout time to wait for item being sent
-   @note c2_rpc_core_init() and c2_rpcmachine_init() have been called before
-   invoking this function
-   @return 0 success
-   @return ETIMEDOUT The wait timed out wihout being sent
- */
-int c2_rpc_reply_timedwait(struct c2_clink *clink, const c2_time_t timeout);
-
-/**
-   Wait for the reply on group of items being sent.
-
-   @param group used treat rpc items as a group.
-   @param timeout time to wait for item being sent
-   @pre c2_rpc_core_init()
-   @pre c2_rpcmachine_init()
-   @return 0 success
-   @return ETIMEDOUT The wait timed out wihout being sent
- */
-int c2_rpc_group_timedwait(struct c2_rpc_group *group, const c2_time_t *timeout);
-
-/**
-   Retrurns update stream associated with given service id.
-   @param machine rpcmachine operation applied to.
-   @param session_id session id for which update stream is being retrieved.
-   @param flag specifies features of update stream, @see c2_update_stream_flags
-   @param ops operations associated with the update stream
-   @param out update associated with given session
-
-   @note c2_rpc_core_init() and c2_rpcmachine_init() have been called before
-   invoking this function
-   @return 0  success
-   @return <0 failure
- */
-int c2_rpc_update_stream_get(struct c2_rpcmachine *machine,
-			     struct c2_service_id *srvid,
-			     enum c2_update_stream_flags flag,
-			     const struct c2_update_stream_ops *ops,
-			     struct c2_update_stream **out);
-
-/**
-   Releases given update stream.
-   @param us update stream to be released
-   @note c2_rpc_core_init() and c2_rpcmachine_init() have been called before
-
-*/
-void c2_rpc_update_stream_put(struct c2_update_stream *us);
-
-/**
-   @name stat_ifs STATISTICS IFs
-   Iterfaces, returning different properties of rpcmachine.
-   @{
- */
-
-/**
-   Returns average time spent in the cache for one RPC-item
-   @note c2_rpc_core_init() and c2_rpcmachine_init() have been called before
-   @param machine rpcmachine operation applied to.
-   @param path Incoming or outgoing path of rpc item.
- */
-c2_time_t c2_rpc_avg_item_time(struct c2_rpcmachine *machine,
-			       const enum c2_rpc_item_path path);
-
-/**
-   Returns transmission speed in bytes per second.
-   @note c2_rpc_core_init() and c2_rpcmachine_init() have been called before
-   @param machine rpcmachine operation applied to.
-   @param path Incoming or outgoing path of rpc item.
- */
-size_t c2_rpc_bytes_per_sec(struct c2_rpcmachine *machine,
-			    const enum c2_rpc_item_path path);
-
-/** @} end name stat_ifs */
-
-/**
-   @defgroup rpc_bulk Bulk IO support for RPC layer.
-   @{
-
-   Detailed Level Design for bulk IO interface from rpc layer.
-   Colibri rpc layer, network layer and the underlying transport are
-   supposed to constitute a zero-copy path for data IO.
-   In order to do this, rpc layer needs to provide support for
-   bulk interface exported by network layer which gives the capability
-   to bundle IO buffers together and send/receive these buffer descriptors
-   on demand. The underlying transport should have the capabilities
-   to provide zero-copy path (e.g. RDMA).
-   There are 2 major use cases here - read IO and write IO in which
-   bulk interface is needed.
-   The bulk IO interface from network layer provides abstractions like
-   - c2_net_buffer (a generic buffer identified at network layer) and
-   - c2_net_buf_desc (an identifier to point to a c2_net_buffer).
-
-   Whenever data buffers are encountered in rpc layer, rpc layer
-   (especially formation sub-component) is supposed to take care of
-   segregating these rpc items and register c2_net_buffers where
-   data buffers are encountered (during write request and read reply)
-   and buffer descriptors are copied into rpc items after registering
-   net buffers.
-   These descriptors are sent to the other side which asks for
-   buffers identified by the supplied buffer descriptors.
-   Please find below, 2 particular use cases of using bulk interface.
-   @verbatim
-
-   Sequence of events in case of write IO call for rpc layer.
-   Assumptions
-   - Write request call has IO buffers associated with it.
-   - Underlying transport supports zero-copy.
-
-			Client			Server
-
-- Init rpc machine.	  |			| - Init rpc machine.
-			  |			|
-- Init Transfer Mc.	  |			| - Init Transfer Mc.
-			  |			|
-- Start Transfer Mc.	  |			| - Start Transfer Mc.
-			  |			|
-- Add recv buffers.	  |			| - Add recv buffers.
-			  |   Net buffer sent	|
-- Incoming write req.	  |	     +--------->| - Net buffer received.
-			  |	     |		|
-- Rpc formation finds	  |	     |		| - Decode and retrieve rpc
-  given item is write	  |	     |		|   items.
-  IO request.		  |	     |		|
-			  |	     |		|
-- Remove data buffers	  |	     |		| - Call an rpc_item_type_op
-  from rpc item & copy	  |	     |		|   which will act if item
-  net_buf_desc which	  |	     |		|   is write IO and it contains
-  are bundled with	  |	     |		|   c2_net_buf_desc. Buf desc
-  given rpc item.	  |	     |		|   are decoded and are copied
-  Net buffers are added	  |	     |		|   into recv buffers.
-  for these data buffs	  |	     |		|   @see
-  in C2_NET_QT_PASSIVE	  |	     |		|   c2_rpc_bulkio_desc_received
-  BULK_SEND		  |	     |		|
-  queue of TM. Buffer	  |	     |		|
-  descriptors are	  |	     |		|
-  encoded and packed	  |	     |		|
-  with rpc.		  |	     |		|
-  @see			  |	     |		|
-c2_rpc_bulkio_desc_send   |	     |		|
-			  |	     |		|
-- Free the net_buf_desc	  |	     |		| - If item is write request,
-  after bundling	  |	     |		|   allocate c2_net_buffer/s,
-  with rpc item.	  |	     |		|   add it to TM in C2_NET_QT
-			  |	     |		|   _ACTIVE_BULK_RECV queue.
-			  |	     |		|
-- Send rpc over wire.	  |--------->+		| - So server calls c2_rpc_
-			  |		0-copy	|   zero_copy_init(active_buffs
-			  |		 init	|   , passive_descs, bufs_nr)
-			  |	    +<----------|   which should
-			  |	    |		|   initiate zero copy operation
-			  |	    |		|   at the transport level.
-			  |	    |		|
-- Transport zero copies	  |	    |		| - Proceed with the write FOM
-  the IO buffers	  |	    |	 +----->|   and complete write IO
-  identified by		  |<--------+	 |	|   request.
-  passive_descs		  |		 |	|
-  to active buffers	  |	    +----+	|
-  on server.		  |	    |  0-copy	|
-			  |-------->+ Complete	|
-			  |			|
-			  |			|
-- Free net buffers used	  |	    +<----------| - Write IO complete. Send
-  for write IO.		  |	    |  Net buf	|   write reply to rpc layer.
-			  |	    |	sent	|
-- Receive net buffer.	  |<--------+		|
-			  |			|
-- Send reply to write	  |			| - Free net buffers used
-  FOM.			  |			|   for zero copy.
-			  |			|
-
-   Sequence of events in case of read IO call for rpc layer.
-   Assumptions
-   - Read request fop has IO buffers associated with it. These buffers are
-     actually empty, they contain no user data. These buffers are replaced
-     by c2_net_buf_desc and packed with rpc.
-   - And read reply fop consists of number of bytes read.
-   - Underlying transport supports zero-copy.
-
-			Client			Server
-
-- Init rpc machine.	  |			| - Init rpc machine.
-			  |			|
-- Init Transfer Mc.	  |			| - Init Transfer Mc.
-			  |			|
-- Start Transfer Mc.	  |			| - Start Transfer Mc.
-			  |			|
-- Add recv buffers.	  |			| - Add recv buffers.
-			  |   Net buffer sent	|
-- Incoming read req.	  |	      +-------->| - Net buffer received.
-			  |	      |		|
-- Remove data buffers	  |	      |		| - Decode and retrieve rpc
-  from fop and replace	  |	      |		|   items.
-  it by c2_net_buf_desc	  |	      |		|
-  The net buffers are	  |	      |		|
-  added to C2_NET_QT_	  |	      |		|
-  PASSIVE_BULK_RECV	  |	      |		|
-  queue of TM and rpc	  |	      |		|
-  is sent over wire.	  |---------->+		|
-			  |			|
-- Transport zero copies	  |<----------+		| - Dispatch rpc item for
-  the data into		  |	      |		|   execution and read FOM.
-  destination net	  |	      |		|   starts.
-  identified by source	  |	      |		|
-  net buf descriptors.	  |---->+     |		|
-			  |	|     |		|
-- Net buffer received	  |<-+	|     |  0-copy	| - Read FOM allocates net
-			  |  |	|     |	  init	|   buffers and registers them
-			  |  |	|     |		|   with the net domain. This
-			  |  |	|     |		|   makes sure that data path
-			  |  |	|     |		|   complies with zero-copy.
-			  |  |	|     |		|
-- Rpc checks if rcvd	  |  |	|     +<--------| - Server initiates zero_copy
-  item belongs to read	  |  |	|		|   by supplying the just
-  request & deallocates	  |  |	+-----+		|   allocated net buffers and
-  net buffers used for	  |  |	      |		|   source net buf descriptors.
-  copying data.		  |  |	      |		|   The net buffers are added
-			  |  |	      |		|   C2_NET_QT_ACTIVE_BULK_SEND
-			  |  |	      |	0-copy	|   queue of TM.
-			  |  |	      | complete|   The transport layer from
-			  |  |	      |		|   client and server zero
-			  |  |	      |		|   copies the read data from
-			  |  |	      +-------->|   server to client buffers.
-			  |  |			|
- - Send reply to read	  |  |			| - Read reply is posted to rpc
-   FOM.			  |  +<-----------------|   & RPC is sent over wire.
-			  |	  Net buffer	|
-			  |	    sent	|
-   @endverbatim
-
- */
-
-/**
-   A magic constant for sanity of struct c2_rpc_bulk.
- */
-enum {
-	C2_RPC_BULK_MAGIC = 0xfedcba0123456789ULL,
-};
-
-/**
-   An abstract data structure that avails bulk transport for io operations.
-   End users will register the io vectors using this structure and bulk
-   transfer apis will take care of doing the data transfer in zero-copy
-   fashion.
- */
-struct c2_rpc_bulk {
-	/** Magic to verify sanity of struct c2_rpc_bulk. */
-	uint64_t		 rb_magic;
-	/** Net buffer that will contain the io data. */
-	struct c2_net_buffer	 rb_nbuf;
-	/** Zero vector representing io data. */
-	struct c2_0vec		 rb_zerovec;
-	/** Channel to wait on rpc bulk to complete the io. */
-	struct c2_chan		 rb_chan;
-	/** Return value of results like addition of buffers to transfer
-	    machine and zero-copy operation. This field is updated by
-	    net buffer send/receive callbacks. */
-	int32_t			 rb_rc;
-};
-
-/**
-   Initialize a rpc bulk structure.
-   @param rbulk rpc bulk structure to be initialized.
-   @param segs_nr Number of segments to be contained by zero vector.
-   @param seg_size Size of each segment contained by zero vector.
-   @param netdom Net domain to which the zero vector belongs.
-   @pre rbulk != NULL
-   @post rpc_bulk_invariant(rbulk) = true.
- */
-int c2_rpc_bulk_init(struct c2_rpc_bulk *rbulk,
-		     uint32_t segs_nr,
-		     c2_bcount_t seg_size,
-		     struct c2_net_domain *netdom);
-
-/**
-   Finalize the rpc bulk structure.
-   @pre rbulk != NULL
- */
-void c2_rpc_bulk_fini(struct c2_rpc_bulk *rbulk);
-
-/**
-   Add a buffer/page to the zero vector referred by rpc bulk structure.
-   @param rbulk rpc bulk structure to which a page/buffer will be added.
-   @param pg Buffer referring to user data.
-   @param index Index of target object to which io is targeted.
-   @pre rbulk != NULL
-   @pre pg != NULL
-   @post rpc_bulk_invariant(rbulk) = true.
- */
-int c2_rpc_bulk_page_add(struct c2_rpc_bulk *rbulk, struct page *pg,
-			 c2_bindex_t index);
-
-/**
-   Add a user space buffer to zero vector referred to by rpc bulk structure.
-   @param rbulk rpc bulk structure to which user space buffer will be added.
-   @param buf User space buffer starting address.
-   @param count Number of bytes in user space buffer.
-   @param index Index of target object to which io is targeted.
-   @post rpc_bulk_invariant(rbulk) = true.
- */
-int c2_rpc_bulk_buf_add(struct c2_rpc_bulk *rbulk,
-			void *buf,
-			c2_bcount_t count,
-			c2_bindex_t index);
-
-/**
-   Stores the c2_net_buf_desc for the net buffer pointed to by c2_rpc_bulk
-   structure in the provided buffer descriptor. This API is typically invoked
-   from the sender side.
-   @param rbulk Rpc bulk structure whose net buf descriptor is to be stored.
-   @param item Rpc item belonging to fop whose net buf descriptor will
-   be populated.
-   @param to_desc Net buf descriptor from fop which will be populated.
-   @post rpc_bulk_invariant(rbulk) = true.
- */
-int c2_rpc_bulk_store(struct c2_rpc_bulk *rbulk, struct c2_rpc_item *item,
-		      struct c2_net_buf_desc *to_desc);
-
-/**
-   Loads the c2_net_buf_desc pointing to the net buffer contained by
-   c2_rpc_bulk structure and starts RDMA transfer of buffers.
-   This API is typically used by receiver side.
-   @param rbulk Rpc bulk structure whose net buffer is to be transferred.
-   @param item Rpc item which contains the c2_net_buf_desc which is the
-   key for zero copy of buffers.
-   @post rpc_bulk_invariant(rbulk) = true.
- */
-int c2_rpc_bulk_load(struct c2_rpc_bulk *rbulk, struct c2_rpc_item *item);
-
-/** @} endgroup of rpc_bulk */
-
-/** @} end group rpc_layer_core */
-/* __COLIBRI_RPC_RPCCORE_H__  */
-#endif
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
diff --git a/rpc/rpc_base.c b/rpc/rpc_base.c
deleted file mode 100644
index 8ae7079..0000000
--- a/rpc/rpc_base.c
+++ /dev/null
@@ -1,125 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Subhash Arya <Subhash_Arya@xyratex.com>
- * Original creation date: 09/28/2011
- */
-
-#include "lib/tlist.h"
-#include "rpc/rpc_base.h"
-#include "lib/rwlock.h"
-
-enum {
-	/* Hex ASCII value of "rit_link" */
-	RPC_ITEM_TYPE_LINK_MAGIC = 0x7269745f6c696e6b,
-	/* Hex ASCII value of "rit_head" */
-	RPC_ITEM_TYPE_HEAD_MAGIC = 0x7269745f68656164,
-};
-
-C2_TL_DESCR_DEFINE(rit, "rpc_item_type_descr", static, struct c2_rpc_item_type,
-		   rit_linkage,	rit_magic, RPC_ITEM_TYPE_LINK_MAGIC,
-		   RPC_ITEM_TYPE_HEAD_MAGIC);
-
-C2_TL_DEFINE(rit, static, struct c2_rpc_item_type);
-
-/** Global rpc item types list. */
-static struct c2_tl        rpc_item_types_list;
-static struct c2_rwlock    rpc_item_types_lock;
-
-/**
-  Checks if the supplied opcode has already been registered.
-  @param opcode RPC item type opcode.
-  @retval true if opcode is a duplicate(already registered)
-  @retval false if opcode has not been registered yet.
-*/
-bool opcode_is_dup(uint32_t opcode)
-{
-	C2_PRE(opcode > 0);
-
-	return c2_rpc_item_type_lookup(opcode) != NULL;
-}
-
-int c2_rpc_base_init(void)
-{
-	c2_rwlock_init(&rpc_item_types_lock);
-	rit_tlist_init(&rpc_item_types_list);
-	return 0;
-}
-
-void c2_rpc_base_fini(void)
-{
-	struct c2_rpc_item_type		*item_type;
-
-	c2_rwlock_write_lock(&rpc_item_types_lock);
-	c2_tlist_for(&rit_tl, &rpc_item_types_list, item_type) {
-		rit_tlink_del_fini(item_type);
-	} c2_tlist_endfor;
-	rit_tlist_fini(&rpc_item_types_list);
-	c2_rwlock_write_unlock(&rpc_item_types_lock);
-	c2_rwlock_fini(&rpc_item_types_lock);
-}
-
-int c2_rpc_item_type_register(struct c2_rpc_item_type *item_type)
-{
-
-	C2_PRE(item_type != NULL);
-	C2_PRE(!opcode_is_dup(item_type->rit_opcode));
-
-	c2_rwlock_write_lock(&rpc_item_types_lock);
-	rit_tlink_init_at(item_type, &rpc_item_types_list);
-	c2_rwlock_write_unlock(&rpc_item_types_lock);
-
-	return 0;
-}
-
-void c2_rpc_item_type_deregister(struct c2_rpc_item_type *item_type)
-{
-	C2_PRE(item_type != NULL);
-
-	c2_rwlock_write_lock(&rpc_item_types_lock);
-	rit_tlink_del_fini(item_type);
-	item_type->rit_magic = 0;
-	c2_rwlock_write_unlock(&rpc_item_types_lock);
-}
-
-struct c2_rpc_item_type *c2_rpc_item_type_lookup(uint32_t opcode)
-{
-	struct c2_rpc_item_type         *item_type = NULL;
-	bool                             found = false;
-
-	c2_rwlock_read_lock(&rpc_item_types_lock);
-	c2_tlist_for(&rit_tl, &rpc_item_types_list, item_type) {
-		if (item_type->rit_opcode == opcode) {
-			found = true;
-			break;
-		}
-	} c2_tlist_endfor;
-	c2_rwlock_read_unlock(&rpc_item_types_lock);
-	if (found)
-		return item_type;
-
-	return NULL;
-}
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
-
diff --git a/rpc/rpc_base.h b/rpc/rpc_base.h
deleted file mode 100644
index 1e3eb2d..0000000
--- a/rpc/rpc_base.h
+++ /dev/null
@@ -1,194 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Subhash Arya <subhash_arya@xyratex.com>
- * Original creation date: 09/27/2011
- */
-
-#ifndef __COLIBRI_RPC_RPCBASE_H__
-#define __COLIBRI_RPC_RPCBASE_H__
-
-/**
-   @addtogroup rpc_layer_core
-
-   This file contains rpc item type definitions. These were part of
-   rpccore.h. The reason for this split is to break circular dependencies
-   that otherwise forms due to embedding rpc item type into a fop type.
-
-   @{
- */
-
-/* Import */
-struct c2_rpc_item;
-struct c2_rpc;
-struct c2_fop;
-struct c2_bufvec_cursor;
-struct c2_rpc_frm_item_coalesced;
-struct c2_net_buf_desc;
-
-/* Export */
-struct c2_rpc_item_type_ops;
-struct c2_rpc_item_type;
-
-/* TBD: different callbacks called on events occured while processing
-   in update stream */
-struct c2_rpc_item_type_ops {
-	/**
-	   Restore original IO vector of rpc item.
-	 */
-	void (*rito_iovec_restore)(struct c2_rpc_item *b_item,
-			struct c2_fop *bkpfop);
-	/**
-	   Find out the size of rpc item.
-	 */
-	size_t (*rito_item_size)(const struct c2_rpc_item *item);
-
-	/**
-	   Find out if given rpc items belong to same type or not.
-	 */
-	bool (*rito_items_equal)(struct c2_rpc_item *item1, struct
-			c2_rpc_item *item2);
-	/**
-	   Find out if given rpc items refer to same c2_fid struct or not.
-	 */
-	bool (*rito_fid_equal)(struct c2_rpc_item *item1,
-			       struct c2_rpc_item *item2);
-	/**
-	  Return true iff item1 and item2 are equal.
-	 */
-	bool (*rito_eq)(const struct c2_rpc_item *i1,
-			const struct c2_rpc_item *i2);
-	/**
-	   Find out the count of fragmented buffers.
-	 */
-	uint64_t (*rito_get_io_fragment_count)(struct c2_rpc_item *item);
-	/**
-	   Coalesce rpc items that share same fid and intent(read/write).
-	 */
-	int (*rito_io_coalesce)(struct c2_rpc_frm_item_coalesced *coalesced_item,
-			struct c2_rpc_item *item);
-	/**
-	   Serialise @item on provided xdr stream @xdrs
-	 */
-	int (*rito_encode)(struct c2_rpc_item_type *item_type,
-		           struct c2_rpc_item *item,
-	                   struct c2_bufvec_cursor *cur);
-	/**
-	   Create in memory item from serialised representation of item
-	 */
-	int (*rito_decode)(struct c2_rpc_item_type *item_type,
-			   struct c2_rpc_item **item,
-			   struct c2_bufvec_cursor *cur);
-	/**
-	   Return the c2_net_buf_desc from io fop.
-	 */
-	void (*rito_io_desc_get)(struct c2_rpc_item *item,
-				 struct c2_net_buf_desc *desc);
-	/**
-	   Store the c2_net_buf_desc into io fop from its net buffer.
-	 */
-	int (*rito_io_desc_store)(struct c2_rpc_item *item,
-				  struct c2_net_buf_desc *desc);
-};
-
-/**
-   Possible values for c2_rpc_item_type::rit_flags.
-   Flags C2_RPC_ITEM_TYPE_REQUEST, C2_RPC_ITEM_TYPE_REPLY and
-   C2_RPC_ITEM_TYPE_UNSOLICITED are mutually exclusive.
- */
-enum c2_rpc_item_type_flags {
-	/** Receiver of item is expected to send reply to item of this type */
-	C2_RPC_ITEM_TYPE_REQUEST = 1,
-	/**
-	  Item of this type is reply to some item of C2_RPC_ITEM_TYPE_REQUEST
-	  type.
-	*/
-	C2_RPC_ITEM_TYPE_REPLY = (1 << 1),
-	/**
-	  This is a one-way item. There is no reply for this type of
-	  item
-	*/
-	C2_RPC_ITEM_TYPE_UNSOLICITED = (1 << 2),
-	/**
-	  Item of this type can modify file-system state on receiver.
-	*/
-	C2_RPC_ITEM_TYPE_MUTABO = (1 << 3)
-};
-
-/**
-   Type of an RPC item.
-   There is an instance of c2_rpc_item_type for each value of rit_opcode.
- */
-struct c2_rpc_item_type {
-	/** Unique operation code. */
-	uint32_t			   rit_opcode;
-	/** Operations that can be performed on the type */
-	const struct c2_rpc_item_type_ops *rit_ops;
-	/** see @c2_rpc_item_type_flags */
-	uint64_t			   rit_flags;
-	/** Linkage into rpc item types list (c2_rpc_item_types_list) */
-	struct c2_tlink			   rit_linkage;
-	/** Magic no for the item type struct */
-	uint64_t			   rit_magic;
-};
-
-/** Initialises the rpc item types list and lock */
-int c2_rpc_base_init(void);
-
-/**
-  Finalizes and destroys the rpc item type list by traversing the list and
-  deleting and finalizing each element.
-*/
-void c2_rpc_base_fini(void);
-
-/**
-  Registers a new rpc item type by adding an entry to the rpc item types list.
-  Asserts when an entry for that opcode already exists in the item types
-  list.
-
-  @param item_type The rpc item type to be registered.
-  @retval 0 on success
-  @retval -errno on failure.
-*/
-int c2_rpc_item_type_register(struct c2_rpc_item_type *item_type);
-
-/** De-registers an rpc item type by deleting the corresponding entry in the
-    rpc item types list.
-
-    @param item_type The rpc item type to be deregistered.
-*/
-void c2_rpc_item_type_deregister(struct c2_rpc_item_type *item_type);
-
-/** Returns a pointer to rpc item type registered for an opcode
-
-  @param opcode Unique operation code for the rpc item type to be looked up.
-  @retval Pointer to the rpc item type for that opcode.
-  @retval NULL if the item type is not registered.
-*/
-struct c2_rpc_item_type *c2_rpc_item_type_lookup(uint32_t opcode);
-
-/** @} endgroup rpc_layer_core */
-#endif
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
diff --git a/rpc/rpc_onwire.c b/rpc/rpc_onwire.c
deleted file mode 100644
index 6ef2264..0000000
--- a/rpc/rpc_onwire.c
+++ /dev/null
@@ -1,336 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Subhash Arya <subhash_arya@xyratex.com>
- * Original creation date: 06/25/2011
- */
-
-#include "lib/errno.h"
-#include "lib/memory.h"
-#include "lib/arith.h"
-#include "lib/trace.h"
-#include "fop/fop.h"
-#include "fop/fop_format.h"
-#include "rpc/session_internal.h"
-#include "rpc/rpc_onwire.h"
-#include "xcode/bufvec_xcode.h"
-
-
-/* XXX : Return correct RPC version. */
-static uint32_t rpc_ver_get(void)
-{
-	return C2_RPC_VERSION_1;
-}
-
-/**
-    Serialize the rpc object header into a network buffer. The header consists
-    of a rpc version no and count of rpc items present in the rpc object
-    @param cur Current cursor position in the buffer vector.
-    @param rpc_obj Object to be serialized.
-    @retval 0 (success).
-    @retvak -errno (failure).
-*/
-static int rpc_header_encode(struct c2_bufvec_cursor *cur,
-			     struct c2_rpc *rpc_obj)
-{
-	uint32_t	item_count;
-	uint32_t	ver;
-	int		rc ;
-
-	C2_PRE(cur != NULL);
-	C2_PRE(rpc_obj != NULL);
-
-	ver = rpc_ver_get();
-	rc = c2_bufvec_uint32(cur, &ver, C2_BUFVEC_ENCODE);
-	if (rc != 0)
-		return rc;
-	item_count = c2_list_length(&rpc_obj->r_items);
-	C2_ASSERT(item_count != 0);
-	rc = c2_bufvec_uint32(cur, &item_count, C2_BUFVEC_ENCODE);
-	return rc;
-}
-
-/**
-    Deserialize the rpc object header from a network buffer. The header consists
-    of a rpc version no and count of rpc items present.
-    @param cur Current cursor position in the buffer.
-    @param  item_count Pointer to no of items in an rpc object.
-    @param ver Pointer to deserialized value of rpc ver.
-    @retval 0 On success.
-    @retval -errno On failure.
-*/
-static int rpc_header_decode(struct c2_bufvec_cursor *cur, uint32_t *item_count,
-			    uint32_t *ver)
-{
-	int	rc;
-
-	C2_PRE(item_count != NULL);
-	C2_PRE(cur != NULL);
-	C2_PRE(ver != NULL);
-
-	rc = c2_bufvec_uint32(cur, ver, C2_BUFVEC_DECODE);
-	if (rc != 0)
-		return rc;
-	rc =  c2_bufvec_uint32(cur, item_count, C2_BUFVEC_DECODE);
-	return rc;
-}
-
-/** Helper functions to serialize uuid and slot references in rpc item header
-    see rpc/rpc2.h */
-
-static int sender_uuid_encdec(struct c2_bufvec_cursor *cur,
-			      struct c2_rpc_sender_uuid *uuid,
-			      enum c2_bufvec_what what)
-{
-	return c2_bufvec_uint64(cur, &uuid->su_uuid, what);
-}
-
-static int slot_ref_encdec(struct c2_bufvec_cursor *cur,
-			   struct c2_rpc_slot_ref *slot_ref,
-			   enum c2_bufvec_what what)
-{
-	struct c2_rpc_slot_ref    *sref;
-	int			   rc;
-	int			   slot_ref_cnt;
-	int			   i;
-
-	C2_PRE(slot_ref != NULL);
-	C2_PRE(cur != NULL);
-
-	/* Currently MAX slot references in sessions is 1. */
-	slot_ref_cnt = 1;
-	for (i = 0; i < slot_ref_cnt; ++i) {
-		sref = &slot_ref[i];
-		rc = c2_bufvec_uint64(cur, &sref->sr_verno.vn_lsn, what) ?:
-		c2_bufvec_uint64(cur, &sref->sr_sender_id, what) ?:
-		c2_bufvec_uint64(cur, &sref->sr_session_id, what) ?:
-		c2_bufvec_uint64(cur, &sref->sr_verno.vn_vc, what) ?:
-		sender_uuid_encdec(cur, &sref->sr_uuid, what) ?:
-		c2_bufvec_uint64(cur, &sref->sr_last_persistent_verno.vn_lsn,
-				 what) ?:
-		c2_bufvec_uint64(cur,&sref->sr_last_persistent_verno.vn_vc,
-				 what) ?:
-		c2_bufvec_uint64(cur, &sref->sr_last_seen_verno.vn_lsn, what) ?:
-		c2_bufvec_uint64(cur, &sref->sr_last_seen_verno.vn_vc, what) ?:
-		c2_bufvec_uint32(cur, &sref->sr_slot_id, what) ?:
-		c2_bufvec_uint64(cur, &sref->sr_xid, what) ?:
-		c2_bufvec_uint64(cur, &sref->sr_slot_gen, what);
-		if (rc != 0)
-			return -EFAULT;
-	}
-	return rc;
-}
-
-/**
-    Encodes/decodes the rpc item header into a bufvec
-    @param cur Current bufvec cursor position
-    @param item RPC item for which the header is to be encoded/decoded
-    @param what Denotes type of operation (Encode or Decode)
-    @retval 0 (success)
-    @retval -errno  (failure)
-*/
-static int item_header_encdec(struct c2_bufvec_cursor *cur,
-			     struct c2_rpc_item *item,
-			     enum c2_bufvec_what what)
-{
-	uint64_t		 len;
-	int			 rc;
-	struct c2_rpc_item_type *item_type;
-
-	C2_PRE(cur != NULL);
-	C2_PRE(item != NULL);
-
-	item_type = item->ri_type;
-	if (what == C2_BUFVEC_ENCODE) {
-		C2_ASSERT(item_type->rit_ops != NULL);
-		C2_ASSERT(item_type->rit_ops->rito_item_size != NULL);
-		len = item_type->rit_ops->rito_item_size(item);
-	}
-	rc = c2_bufvec_uint64(cur, &len, what) ?:
-	slot_ref_encdec(cur, item->ri_slot_refs, what);
-	return rc;
-}
-
-/**
-   Helper function used by encode/decode ops of each item type (rito_encode,
-   rito_decode) for decoding an rpc item into/from a bufvec
-*/
-int item_encdec(struct c2_bufvec_cursor *cur, struct c2_rpc_item *item,
-		       enum c2_bufvec_what what)
-{
-	int		 rc;
-	struct	c2_fop	*fop;
-
-	C2_PRE(item != NULL);
-	C2_PRE(cur != NULL);
-
-	fop = c2_rpc_item_to_fop(item);
-	C2_ASSERT(fop != NULL);
-
-	rc = item_header_encdec(cur, item, what);
-	if(rc != 0)
-		return rc;
-	rc = c2_xcode_bufvec_fop(cur, fop, what);
-	return rc;
-}
-
-
-/**
-  Checks if the supplied bufvec has buffers with sizes multiple of 8 bytes.
-  @param buf bufvec for which we want to check the size alignment.
-  @retval true if the size of the bufvec is multiple of align_val.
-  @retval false if the size of the bufvec is not a multiple of align_val.
-*/
-static bool each_bufsize_is_8aligned(struct c2_bufvec *buf)
-{
-	int		i;
-
-	C2_PRE(buf != NULL);
-	/* Check if each buffer segment has sizes multiple of 8 bytes*/
-	for (i = 0; i < buf->ov_vec.v_nr; ++i) {
-		if (!C2_IS_8ALIGNED(buf->ov_vec.v_count[i]))
-			return false;
-	}
-	return true;
-}
-
-int c2_rpc_encode(struct c2_rpc *rpc_obj, struct c2_net_buffer *nb )
-{
-	struct c2_rpc_item		*item;
-	struct c2_bufvec_cursor		 cur;
-	size_t				 len;
-	size_t				 offset = 0;
-	c2_bcount_t			 bufvec_size;
-	int				 rc;
-	struct c2_rpc_item_type		*item_type;
-	void				*cur_addr;
-
-	C2_PRE(rpc_obj != NULL);
-	C2_PRE(nb != NULL);
-
-	bufvec_size = c2_vec_count(&nb->nb_buffer.ov_vec);
-	/*
-	  XXX : Alignment Checks
-	  Check if bufvecs are 8-byte aligned buffers with sizes multiple of
-	  8 bytes.
-	*/
-	C2_ASSERT(C2_IS_8ALIGNED(bufvec_size));
-	C2_ASSERT(each_bufsize_is_8aligned(&nb->nb_buffer));
-	c2_bufvec_cursor_init(&cur, &nb->nb_buffer);
-	cur_addr = c2_bufvec_cursor_addr(&cur);
-	C2_ASSERT(C2_IS_8ALIGNED(cur_addr));
-
-	/* Serialize RPC object header into the buffer */
-	rc = rpc_header_encode(&cur, rpc_obj);
-	if (rc != 0)
-		goto end;
-
-        len = RPC_ONWIRE_HEADER_SIZE;
-	/* Iterate through the RPC items list in the RPC object
-           and for each object serialize item and the payload */
-        c2_list_for_each_entry(&rpc_obj->r_items, item,
-				struct c2_rpc_item, ri_rpcobject_linkage) {
-		item_type = item->ri_type;
-		C2_ASSERT(item_type->rit_ops != NULL);
-		C2_ASSERT(item_type->rit_ops->rito_encode != NULL);
-		C2_ASSERT(item_type->rit_ops->rito_item_size != NULL);
-		offset = len + item_type->rit_ops->rito_item_size(item);
-		C2_ASSERT(offset < bufvec_size);
-		len = offset;
-		/* Call the associated encode function for the that item type */
-		rc = item_type->rit_ops->rito_encode(item_type, item, &cur);
-		if (rc != 0)
-			goto end;
-	}
-	C2_ASSERT(bufvec_size >= len);
-	nb->nb_length = len;
-end:
-	return rc;
-}
-
-int c2_rpc_decode(struct c2_rpc *rpc_obj, struct c2_net_buffer *nb)
-{
-	int			  i;
-	int			  rc;
-	struct c2_rpc_item	 *item;
-	struct c2_rpc_item_type  *item_type;
-	size_t			  offset;
-	size_t			  len;
-	size_t			  bufvec_size;
-	uint32_t		  item_count;
-	uint32_t		  opcode;
-	uint32_t		  ver;
-	struct c2_bufvec_cursor   cur;
-	void			 *cur_addr;
-
-	C2_PRE(nb != NULL);
-	C2_PRE(rpc_obj != NULL);
-
-	len = nb->nb_length;
-	C2_ASSERT(len != 0);
-	bufvec_size = c2_vec_count(&nb->nb_buffer.ov_vec);
-	C2_ASSERT(len <= bufvec_size);
-	/*
-	  Check if bufvecs are 8-byte aligned buffers with sizes multiple
-	  of 8 bytes.
-	*/
-	C2_ASSERT(C2_IS_8ALIGNED(bufvec_size));
-	C2_ASSERT(each_bufsize_is_8aligned(&nb->nb_buffer));
-	c2_bufvec_cursor_init(&cur, &nb->nb_buffer);
-        cur_addr = c2_bufvec_cursor_addr(&cur);
-	C2_ASSERT(C2_IS_8ALIGNED(cur_addr));
-
-	/* Decode the rpc object header and get the count of items & rpc ver */
-	rc = rpc_header_decode(&cur, &item_count, &ver);
-	if (rc != 0)
-		return -EFAULT;
-	offset = RPC_ONWIRE_HEADER_SIZE;
-	C2_ASSERT(offset < len);
-	/*
-	   - Iterate through the each rpc item and for each rpc item.
-	   - Deserialize the opcode and get corrosponding item_type by
-             iterating through the item_types_list to find it.
-	   - Call the corrosponding item decode function for that item type.
-         */
-	for (i = 0; i < item_count; ++i) {
-		rc = c2_bufvec_uint32(&cur, &opcode, C2_BUFVEC_DECODE);
-		if (rc != 0)
-			return -EFAULT;
-		item_type = c2_rpc_item_type_lookup(opcode);
-		C2_ASSERT(item_type != NULL);
-		C2_ASSERT(item_type->rit_ops != NULL);
-		C2_ASSERT(item_type->rit_ops->rito_decode != NULL);
-		C2_ASSERT(item_type->rit_ops->rito_item_size != NULL);
-		rc = item_type->rit_ops->rito_decode(item_type, &item, &cur);
-		if (rc != 0)
-			return rc;
-		offset += item_type->rit_ops->rito_item_size(item);
-		if (offset > len)
-			return -EMSGSIZE;
-		c2_list_add(&rpc_obj->r_items, &item->ri_rpcobject_linkage);
-	}
-	return rc;
-}
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 79
- *  scroll-step: 1
- *  End:
- */
diff --git a/rpc/rpc_onwire.h b/rpc/rpc_onwire.h
deleted file mode 100644
index 75c96ab..0000000
--- a/rpc/rpc_onwire.h
+++ /dev/null
@@ -1,143 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Subhash Arya <subhash_arya@xyratex.com>
- * Original creation date: 06/25/2011
- */
-
-#ifndef C2_RPC_ONWIRE_H_
-#define C2_RPC_ONWIRE_H_
-
-/**
-   @defgroup rpc_onwire RPC wire format types and interfaces
-
-   A C2 RPC is a container for items, FOPs and ADDB records.  The wire
-   format of an RPC consists of a header and a sequence of encoded
-   RPC items.
-
-   The header consists of, in order
-    - version, a uint32_t, currently only C2_RPC_VERSION_1 is supported
-    - the number of RPC items in the RPC
-
-   Each item is encoded as
-    - opcode value which denotes a unique operation code for an rpc item type &
-    is encoded as a uint32_t
-    - length number of bytes in the item payload, encoded as a uint32_t
-    - Various fields related to internal processing of an rpc item.
-    - item payload ( the serialized data for each item )
-
-    Each RPC item is directly serialized/deserialized into a network buffer.
-    using the various bufvec encode/decode functions for atomic types.
-    (see xcode/bufvec_xcode.h).
-
-    XXX : Currently we assume (and check) that the the c2_bufvec-s, supplied to
-    transcode functions have 8-byte aligned buffers with sizes multiple of
-    8 bytes.
-
-    XXX : Current implementation of onwire formats is only for RPC items
-	  which are containers for FOPs.
-   @{
-*/
-
-#include "rpc/rpc2.h"
-#include "xcode/bufvec_xcode.h"
-
-enum {
-	C2_RPC_VERSION_1 = 1,
-};
-
-/** Header information present in an RPC object */
-struct c2_rpc_header {
-	/** RPC version, currently 1 */
-	uint32_t rh_ver;
-	/** No of items present in the RPC object */
-	uint32_t rh_item_count;
-};
-
-/**
-   Header information per rpc item in an rpc object. The detailed description
-   of the various fields is present in struct c2_rpc_item /rpc/rpc2.h.
-*/
-struct c2_rpc_item_header {
-	uint32_t			rih_opcode;
-	uint64_t			rih_item_size;
-	uint64_t			rih_sender_id;
-	uint64_t			rih_session_id;
-	uint32_t			rih_slot_id;
-	struct c2_rpc_sender_uuid	rih_uuid;
-	struct c2_verno			rih_verno;
-	struct c2_verno			rih_last_persistent_ver_no;
-	struct c2_verno			rih_last_seen_ver_no;
-	uint64_t			rih_xid;
-	uint64_t			rih_slot_gen;
-};
-
-/**
-   XXX: Temporary way to find the size of the onwire rpc object header
-   and item header in bytes. The RPC_HEADER_FIELDS and ITEM_HEADER_FIELDS
-   denote no of fields present in each onwire rpc object header and rpc item
-   header respectively ( see struct c2_rpc_item and struct c2_rpc_item_header).
-*/
-enum {
-	/** Count of fields in RPC object header (see struct c2_rpc_header) */
-	RPC_HEADER_FIELDS = 2,
-	/** Count of fields in item header (see struct c2_rpc_item_header) */
-	ITEM_HEADER_FIELDS = 14,
-	/** Onwire header size = RPC_HEADER_FIELDS * BYTES_PER_XCODE_UNIT */
-	RPC_ONWIRE_HEADER_SIZE = 16,
-	/** Onwire item header size = ITEM_HEADER_FIELDS * BYTES_PER_XCODE_UNIT */
-	ITEM_ONWIRE_HEADER_SIZE = 112,
-};
-
-/**
-   This function encodes an c2_rpc object into the supplied network buffer. Each
-   rpc object contains a header and count of rpc items present in that rpc
-   object. These items are serialized directly onto the bufvec present in the
-   network buffer using the various bufvec encode/decode funtions for atomic
-   types.
-   The supplied network buffer is allocated and managed by the caller.
-   @param rpc_obj  pointer to the rpc object which will be serialized
-   into a network buffer
-   @param nb pointer to network buffer on which the rpc object is to be
-   serialized
-   @retval 0 on  success.
-   @retval -errno on failure.
-*/
-int c2_rpc_encode(struct c2_rpc *rpc_obj, struct c2_net_buffer *nb);
-
-/**
-   Decodes an onwire rpc object in the network buffer into an incore rpc object.
-   The rpc object in the network buffer is deserialized using the bufvec
-   encode/decode funtions to extract the header. The header contains the count
-   of items present in the rpc object. For each rpc item we :-
-   - Deserialize the opcode and lookup the  corresponding item_type.
-   - Call the corresponding item decode function for that item type and
-     deserialize the item payload.
-   - Add the deserialized item to the r_items list of the rpc_obj.
-   @param rpc_obj The RPC object on which the onwire items would be
-   deserialized.
-   @param nb  The network buffer containing the onwire RPC object.
-   @retval 0 on success.
-   @retval -errno on failure.
-*/
-int c2_rpc_decode( struct c2_rpc *rpc_obj, struct c2_net_buffer *nb );
-
-int item_encdec(struct c2_bufvec_cursor *cur, struct c2_rpc_item *item,
-			enum c2_bufvec_what what);
-
-/** @}  End of rpc_onwire group */
-
-#endif
diff --git a/rpc/rpc_opcodes.h b/rpc/rpc_opcodes.h
deleted file mode 100644
index 35e2033..0000000
--- a/rpc/rpc_opcodes.h
+++ /dev/null
@@ -1,120 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Subhash Arya <subhash_arya@xyratex.com>,
- * Original creation date: 11/4/2011
- */
-/**
-   @addtogroup rpc_layer_core
-
-   This file is a centralized (temporary) location for opcodes.
-   An opcode is an rpc item type attribute which uniquely identifies an rpc
-   item type.
-   @see rpc/rpccore.h
-   @see rpc/rpc_base.h
-
-   @{
- */
-
-enum C2_RPC_OPCODES {
-
-	C2_ADDB_REPLY_OPCODE = 1,
-
-	/** Bulk emulation rpc opcodes */
-	C2_BULK_SUNRPC_MSG_OPCODE = 2,
-	C2_BULK_SUNRPC_GET_OPCODE = 3,
-	C2_BULK_SUNRPC_PUT_OPCODE= 4,
-	C2_BULK_SUNRPC_MSG_REPLY_OPCODE = 5,
-	C2_BULK_SUNRPC_GET_REPLY_OPCODE = 6,
-	C2_BULK_SUNRPC_PUT_REPLY_OPCODE= 7,
-
-	/** Colibri set up rpc opcodes */
-	C2_CS_DS1_REQ_OPCODE = 8,
-        C2_CS_DS1_REP_OPCODE = 9,
-        C2_CS_DS2_REQ_OPCODE = 10,
-        C2_CS_DS2_REP_OPCODE = 11,
-
-	/** Console rpc opcodes */
-	C2_CONS_FOP_DEVICE_OPCODE = 12,
-	C2_CONS_FOP_REPLY_OPCODE = 13,
-	C2_CONS_TEST = 14,
-
-	/** Fol rpc opcodes */
-	C2_FOL_ANCHOR_TYPE_OPCODE = 15,
-	C2_FOL_UT_OPCODE = 16,
-
-	/** Fop iterator rpc opcodes */
-	C2_FOP_ITERATOR_TEST_OPCODE = 17,
-
-
-	/** Request handler rpc opcodes */
-	C2_REQH_ERROR_REPLY_OPCODE  = 18,
-
-
-	/** Stob IO rpc opcodes */
-	C2_STOB_IO_CREATE_REQ_OPCODE = 19,
-	C2_STOB_IO_WRITE_REQ_OPCODE = 20,
-	C2_STOB_IO_READ_REQ_OPCODE = 21,
-	C2_STOB_IO_CREATE_REPLY_OPCODE = 22,
-	C2_STOB_IO_WRITE_REPLY_OPCODE = 23,
-	C2_STOB_IO_READ_REPLY_OPCODE = 24,
-
-	/** RPC module opcodes */
-	C2_RPC_PING_OPCODE = 25,
-	C2_RPC_PING_REPLY_OPCODE = 26,
-	C2_RPC_CONN_ESTABLISH_OPCODE = 27,
-        C2_RPC_CONN_TERMINATE_OPCODE = 28,
-        C2_RPC_SESSION_ESTABLISH_OPCODE = 29,
-        C2_RPC_SESSION_TERMINATE_OPCODE = 30,
-        C2_RPC_CONN_ESTABLISH_REP_OPCODE = 31,
-        C2_RPC_CONN_TERMINATE_REP_OPCODE = 32,
-        C2_RPC_SESSION_ESTABLISH_REP_OPCODE = 33,
-        C2_RPC_SESSION_TERMINATE_REP_OPCODE = 34,
-        C2_RPC_NOOP_OPCODE = 35,
-	C2_RPC_ONWIRE_UT_OPCODE = 36,
-
-	/** Network rpc opcodes */
-	C2_NET_TEST_OPCODE = 37,
-	C2_ADDB_RECORD_REQUEST_OPCODE = 38,
-
-	/** I/O service and stob rpc opcodes */
-	C2_STOB_UT_WRITE_OPCODE = 39,
-	C2_STOB_UT_READ_OPCODE = 40,
-	C2_STOB_UT_CREATE_OPCODE = 41,
-	C2_STOB_UT_QUIT_OPCODE = 42,
-	C2_IOSERVICE_READV_OPCODE = 43,
-	C2_IOSERVICE_WRITEV_OPCODE = 44,
-	C2_IOSERVICE_READV_REP_OPCODE = 45,
-	C2_IOSERVICE_WRITEV_REP_OPCODE = 46,
-	C2_STOB_UT_WRITE_REPLY_OPCODE = 47,
-	C2_STOB_UT_READ_REPLY_OPCODE = 48,
-	C2_STOB_UT_CREATE_REPLY_OPCODE = 49,
-
-	/** Xcode rpc opcodes */
-	C2_XCODE_UT_OPCODE = 50,
-};
-/** @} endgroup rpc_layer_core */
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
-
diff --git a/rpc/rpcdbg.h b/rpc/rpcdbg.h
deleted file mode 100644
index d7233e3..0000000
--- a/rpc/rpcdbg.h
+++ /dev/null
@@ -1,24 +0,0 @@
-/**
-   Why these small macros are not in lib-c2???
-   XXX: just for now.
- */
-#ifndef __COLIBRI_RPC_RPCDBG_H__
-# define __COLIBRI_RPC_RPCDBG_H__
-# ifdef __KERNEL__
-#   define DBG(fmt, args...) printk("%s:%d " fmt, __FUNCTION__, __LINE__, ##args)
-# else
-#   include <stdio.h>
-#   include <stdlib.h>
-#   define DBG(fmt, args...) printf("%s:%d " fmt, __FUNCTION__, __LINE__, ##args)
-# endif
-#endif /* __COLIBRI_RPC_RPCDBG_H__  */
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
diff --git a/rpc/rpclib.c b/rpc/rpclib.c
index fef3134..6fded56 100644
--- a/rpc/rpclib.c
+++ b/rpc/rpclib.c
@@ -14,202 +14,199 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Dmitriy Chumak <dmitriy_chumak@xyratex.com>
- * Original creation date: 09/28/2011
+ * Original author: Alexey Lyashkov
+ * Original creation date: 04/09/2010
  */
 
+#include <string.h>
 
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif
+#include <lib/list.h>
+#include <lib/rwlock.h>
+#include <lib/memory.h>
 
-#ifndef __KERNEL__
-#include <errno.h> /* errno */
-#include <stdio.h> /* fopen(), fclose() */
-#endif
+#include <lib/refs.h>
 
-#include "lib/cdefs.h"
-#include "lib/types.h"
-#include "lib/memory.h"
-#include "lib/assert.h"
-#include "rpc/rpc2.h"
-#include "net/net.h"
-#include "fop/fop.h"
-#include "rpc/rpclib.h"
+#include <net/net.h>
+#include <rpc/rpclib.h>
+#include <rpc/rpc_ops.h>
 
-#ifndef __KERNEL__
-#include "reqh/reqh.h"
-#include "reqh/reqh_service.h"
-#include "colibri/colibri_setup.h"
-#endif
+bool c2_session_is_same(const struct c2_session_id *s1, const struct c2_session_id *s2)
+{
+	return memcmp(s1, s2, sizeof *s1) == 0;
+}
 
+/**
+ rpc server group
+ */
+struct c2_rwlock servers_list_lock;
+static struct c2_list servers_list;
 
-#ifndef __KERNEL__
-int c2_rpc_server_start(struct c2_rpc_server_ctx *sctx)
+static void c2_rpc_server_free(struct c2_ref *ref)
 {
-	int  i;
-	int  rc;
+	struct c2_rpc_server *srv;
 
-	C2_PRE(sctx->rsx_argv != NULL && sctx->rsx_argc > 0);
+	srv = container_of(ref, struct c2_rpc_server, rs_ref);
 
-	/* Open error log file */
-	sctx->rsx_log_file = fopen(sctx->rsx_log_file_name, "w+");
-	if (sctx->rsx_log_file == NULL)
-		return errno;
+	c2_free(srv);
+}
+
+struct c2_rpc_server *c2_rpc_server_create(const struct c2_service_id *srv_id)
+{
+	struct c2_rpc_server *srv;
+
+	C2_ALLOC_PTR(srv);
+	if (!srv)
+		return NULL;
+
+	c2_list_link_init(&srv->rs_link);
+	c2_ref_init(&srv->rs_ref, 1, c2_rpc_server_free);
+
+	srv->rs_id = *srv_id;
+
+	return srv;
+}
 
-	/* Register service types */
-	for (i = 0; i < sctx->rsx_service_types_nr; ++i) {
-		rc = c2_reqh_service_type_register(sctx->rsx_service_types[i]);
-		if (rc != 0)
-			goto fclose;
+void c2_rpc_server_register(struct c2_rpc_server *srv)
+{
+	c2_ref_get(&srv->rs_ref);
+
+	c2_rwlock_write_lock(&servers_list_lock);
+	c2_list_add(&servers_list, &srv->rs_link);
+	c2_rwlock_write_unlock(&servers_list_lock);
+}
+
+void c2_rpc_server_unregister(struct c2_rpc_server *srv)
+{
+	bool need_put = false;
+
+	c2_rwlock_write_lock(&servers_list_lock);
+	if (c2_list_link_is_in(&srv->rs_link)) {
+		c2_list_del(&srv->rs_link);
+		need_put = true;
 	}
+	c2_rwlock_write_unlock(&servers_list_lock);
 
-	/* Start rpc server */
-	rc = c2_cs_init(&sctx->rsx_colibri_ctx, sctx->rsx_xprts,
-			sctx->rsx_xprts_nr, sctx->rsx_log_file);
-	if (rc != 0)
-		goto service_unreg;
-
-	rc = c2_cs_setup_env(&sctx->rsx_colibri_ctx, sctx->rsx_argc,
-			     sctx->rsx_argv);
-	if (rc != 0)
-		goto cs_fini;
-
-	rc = c2_cs_start(&sctx->rsx_colibri_ctx);
-
-	return rc;
-
-cs_fini:
-	c2_cs_fini(&sctx->rsx_colibri_ctx);
-service_unreg:
-	for (i = 0; i < sctx->rsx_service_types_nr; ++i)
-		c2_reqh_service_type_unregister(sctx->rsx_service_types[i]);
-fclose:
-	fclose(sctx->rsx_log_file);
-	return rc;
+	if (need_put)
+		c2_ref_put(&srv->rs_ref);
 }
 
-void c2_rpc_server_stop(struct c2_rpc_server_ctx *sctx)
+
+struct c2_rpc_server *c2_rpc_server_find(const struct c2_service_id *srv_id)
 {
-	int i;
+	struct c2_rpc_server *srv = NULL;
+	bool found = false;
+
+	c2_rwlock_read_lock(&servers_list_lock);
+	c2_list_for_each_entry(&servers_list, srv,
+			       struct c2_rpc_server, rs_link) {
+		if (c2_services_are_same(&srv->rs_id, srv_id)) {
+			c2_ref_get(&srv->rs_ref);
+			found = true;
+			break;
+		}
+	}
+	c2_rwlock_read_unlock(&servers_list_lock);
 
-	c2_cs_fini(&sctx->rsx_colibri_ctx);
+	return found ? srv : NULL;
+}
 
-	for (i = 0; i < sctx->rsx_service_types_nr; ++i)
-		c2_reqh_service_type_unregister(sctx->rsx_service_types[i]);
+/**
+ rpc client group
+ */
+struct c2_rwlock clients_list_lock;
+static struct c2_list clients_list;
 
-	fclose(sctx->rsx_log_file);
+static void rpc_client_free(struct c2_ref *ref)
+{
+	struct c2_rpc_client *cli;
+
+	cli = container_of(ref, struct c2_rpc_client, rc_ref);
+
+	c2_rwlock_fini(&cli->rc_sessions_lock);
+	c2_list_fini(&cli->rc_sessions);
+	c2_net_conn_release(cli->rc_netlink);
 
-	return;
+	c2_free(cli);
 }
-#endif
 
-int c2_rpc_client_start(struct c2_rpc_client_ctx *cctx)
+struct c2_rpc_client *c2_rpc_client_create(const struct c2_service_id *id)
 {
-	int rc;
-	struct c2_net_transfer_mc *tm;
-
-	rc = c2_rpcmachine_init(&cctx->rcx_rpc_machine, cctx->rcx_cob_dom,
-				cctx->rcx_net_dom, cctx->rcx_local_addr, NULL);
-	if (rc != 0)
-		return rc;
-
-	tm = &cctx->rcx_rpc_machine.cr_tm;
-
-	rc = c2_net_end_point_create(&cctx->rcx_remote_ep, tm, cctx->rcx_remote_addr);
-	if (rc != 0)
-		goto rpcmach_fini;
-
-	rc = c2_rpc_conn_create(&cctx->rcx_connection, cctx->rcx_remote_ep,
-				&cctx->rcx_rpc_machine,
-				cctx->rcx_max_rpcs_in_flight,
-				cctx->rcx_timeout_s);
-	if (rc != 0)
-		goto ep_put;
-
-	rc = c2_rpc_session_create(&cctx->rcx_session, &cctx->rcx_connection,
-				   cctx->rcx_nr_slots, cctx->rcx_timeout_s);
-	if (rc != 0)
-		goto conn_destroy;
-
-	return rc;
-
-conn_destroy:
-	c2_rpc_conn_destroy(&cctx->rcx_connection, cctx->rcx_timeout_s);
-ep_put:
-	c2_net_end_point_put(cctx->rcx_remote_ep);
-rpcmach_fini:
-	c2_rpcmachine_fini(&cctx->rcx_rpc_machine);
-	C2_ASSERT(rc != 0);
-	return rc;
+	struct c2_rpc_client *cli;
+
+	C2_ALLOC_PTR(cli);
+	if(cli == NULL)
+		return NULL;
+
+	cli->rc_id = *id;
+	c2_ref_init(&cli->rc_ref, 1, rpc_client_free);
+	c2_rwlock_init(&cli->rc_sessions_lock);
+	c2_list_init(&cli->rc_sessions);
+
+	cli->rc_netlink = c2_net_conn_find(id);
+	if (cli->rc_netlink == NULL){
+		c2_ref_put(&cli->rc_ref);
+		return NULL;
+	}
+
+	c2_rwlock_write_lock(&clients_list_lock);
+	c2_list_add(&clients_list, &cli->rc_link);
+	c2_rwlock_write_unlock(&clients_list_lock);
+
+	return cli;
 }
 
-int c2_rpc_client_call(struct c2_fop *fop, struct c2_rpc_session *session,
-		       const struct c2_rpc_item_ops *ri_ops, uint32_t timeout_s)
+void c2_rpc_client_unlink(struct c2_rpc_client *cli)
 {
-	int                 rc;
-	c2_time_t           timeout;
-	struct c2_clink     clink;
-	struct c2_rpc_item  *item;
-
-	C2_PRE(fop != NULL);
-	C2_PRE(session != NULL);
-	/*
-	 * It is mandatory to specify item_ops, because rpc layer needs
-	 * implementation of c2_rpc_item_ops::rio_free() in order to free the
-	 * item. Consumer can use c2_fop_default_item_ops if, it is not
-	 * interested in implementing other (excluding ->rio_free())
-	 * interfaces of c2_rpc_item_ops. See also c2_fop_item_free().
-	 */
-	C2_PRE(ri_ops != NULL);
-
-	item             = &fop->f_item;
-	item->ri_ops     = ri_ops;
-	item->ri_session = session;
-	item->ri_prio    = C2_RPC_ITEM_PRIO_MAX;
-
-	c2_clink_init(&clink, NULL);
-	c2_clink_add(&item->ri_chan, &clink);
-	c2_time_set(&timeout, timeout_s, 0);
-	timeout = c2_time_add(c2_time_now(), timeout);
-
-	rc = c2_rpc_post(item);
-	if (rc != 0)
-		goto clean;
-
-	rc = c2_rpc_reply_timedwait(&clink, timeout);
-clean:
-	c2_clink_del(&clink);
-	c2_clink_fini(&clink);
-
-	return rc;
+	bool need_put = false;
+
+	c2_rwlock_write_lock(&clients_list_lock);
+	if (c2_list_link_is_in(&cli->rc_link)) {
+		c2_list_del(&cli->rc_link);
+		need_put = true;
+	}
+	c2_rwlock_write_unlock(&clients_list_lock);
+
+	if (need_put)
+		c2_ref_put(&cli->rc_ref);
 }
-C2_EXPORTED(c2_rpc_client_call);
 
-int c2_rpc_client_stop(struct c2_rpc_client_ctx *cctx)
+struct c2_rpc_client *c2_rpc_client_find(const struct c2_service_id *id)
 {
-	int rc;
+	struct c2_rpc_client *cli = NULL;
+	bool found = false;
+
+	c2_rwlock_read_lock(&clients_list_lock);
+	c2_list_for_each_entry(&clients_list, cli,
+			       struct c2_rpc_client, rc_link) {
+		if (c2_services_are_same(&cli->rc_id, id)) {
+			c2_ref_get(&cli->rc_ref);
+			found = true;
+			break;
+		}
+	}
+	c2_rwlock_read_unlock(&clients_list_lock);
 
-	rc = c2_rpc_session_destroy(&cctx->rcx_session, cctx->rcx_timeout_s);
-	if (rc != 0)
-		return rc;
+	return found ? cli : NULL;
+}
 
-	rc = c2_rpc_conn_destroy(&cctx->rcx_connection, cctx->rcx_timeout_s);
-	if (rc != 0)
-		return rc;
+int c2_rpclib_init()
+{
+	c2_list_init(&servers_list);
+	c2_rwlock_init(&servers_list_lock);
 
-	c2_net_end_point_put(cctx->rcx_remote_ep);
-	c2_rpcmachine_fini(&cctx->rcx_rpc_machine);
+	c2_list_init(&clients_list);
+	c2_rwlock_init(&clients_list_lock);
 
-	return rc;
+	/** XXX */
+//	c2_session_register_ops(rpc_ops);
+	return 0;
 }
 
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
+void c2_rpclib_fini()
+{
+	c2_list_fini(&servers_list);
+	c2_rwlock_fini(&servers_list_lock);
+
+	c2_list_fini(&clients_list);
+	c2_rwlock_fini(&clients_list_lock);
+}
diff --git a/rpc/rpclib.h b/rpc/rpclib.h
index c24be94..c9d0a69 100644
--- a/rpc/rpclib.h
+++ b/rpc/rpclib.h
@@ -14,187 +14,183 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Dmitriy Chumak <dmitriy_chumak@xyratex.com>
- * Original creation date: 09/28/2011
+ * Original author: Alexey Lyashkov
+ * Original creation date: 04/09/2010
  */
 
 #ifndef __COLIBRI_RPC_RPCLIB_H__
-#define __COLIBRI_RPC_RPCLIB_H__
-
-#ifndef __KERNEL__
-#include <stdio.h> /* FILE */
-#endif
 
-#include "rpc/rpc2.h"    /* struct c2_rpcmachine, c2_rpc_item */
-#include "rpc/session.h" /* struct c2_rpc_conn, c2_rpc_session */
-#include "db/db.h"       /* struct c2_dbenv */
-#include "cob/cob.h"     /* struct c2_cob_domain */
-#include "net/net.h"     /* struct c2_net_end_point */
+#define __COLIBRI_RPC_RPCLIB_H__
 
-#ifndef __KERNEL__
-#include "colibri/colibri_setup.h" /* struct c2_colibri */
-#endif
+#include <lib/cdefs.h>
+#include <lib/refs.h>
+#include <lib/list.h>
+#include <lib/rwlock.h>
+#include <lib/cache.h>
 
+#include <net/net.h>
+#include <rpc/rpc_types.h>
 
-#ifndef __KERNEL__
-struct c2_reqh_service_type;
+/**
+ @page rpc-lib
+*/
 
 /**
- * RPC server context structure.
- *
- * Contains all required data to initialize an RPC server,
- * using colibri-setup API.
+ rpc client structure.
+
+ structure describe rpc client.
+ 
+ one structure is describe one service on server side, 
+ structure is created when user application want to send
+ operations from client side to server.
+ structure have reference counter protection and will freed
+ after upper layers will call c2_rpc_client function and all rpc's
+ are finished and release own sessions.
  */
-struct c2_rpc_server_ctx {
-
-	/** a pointer to array of transports, which can be used by server */
-	struct c2_net_xprt          **rsx_xprts;
-	/** number of transports in array */
-	int                         rsx_xprts_nr;
-
+struct c2_rpc_client {
+	/**
+	 global client list linkage
+	*/
+	struct c2_list_link	rc_link;
 	/**
-	 * ARGV-like array of CLI options to configure colibri-setup, which is
-	 * passed to c2_cs_setup_env()
+	 remote service identifier
 	 */
-	char                        **rsx_argv;
-	/** number of elements in rsx_argv array */
-	int                         rsx_argc;
-
-	/** a pointer to array of service types, which can be used by server */
-	struct c2_reqh_service_type **rsx_service_types;
-	/** number of service types in array */
-	int                         rsx_service_types_nr;
-
-	const char                  *rsx_log_file_name;
-
-	/** an embedded colibri context structure */
-	struct c2_colibri           rsx_colibri_ctx;
-
+	struct c2_service_id	rc_id;
+	/**
+	 reference counter
+	 */
+	struct c2_ref		rc_ref;
 	/**
-	 * this is an internal variable, which is used by c2_rpc_server_stop()
-	 * to close log file; it should not be initialized by a caller
+	 protect concurrency access to session list
 	 */
-	FILE                        *rsx_log_file;
+	struct c2_rwlock	rc_sessions_lock;
+	/**
+	 sessions list
+	 */
+	struct c2_list		rc_sessions;
+	/**
+	 network logical connection assigned to a client
+	 */
+	struct c2_net_conn	*rc_netlink;
 };
 
 /**
-  Starts server's rpc machine.
+ create rpc client instance and add into system list
 
-  @param sctx  Initialized rpc context structure.
+ @param id remote service identifier
 
-  @pre sctx->rcx_dbenv and rctx->rcx_cob_dom are initialized
-*/
-int c2_rpc_server_start(struct c2_rpc_server_ctx *sctx);
+ @return pointer to allocated rpc structure or NULL if not have enough memory
+ */
+struct c2_rpc_client *c2_rpc_client_init(const struct c2_service_id *id);
+struct c2_rpc_client *c2_rpc_client_create(const struct c2_service_id *id);
 
 /**
-  Stops RPC server.
-
-  @param sctx  Initialized rpc context structure.
-*/
-void c2_rpc_server_stop(struct c2_rpc_server_ctx *sctx);
-#endif
+ unlink rpc client from system list. structure will
+ freed after release last reference
 
-struct c2_net_xprt;
-struct c2_net_domain;
+ @param cli pointer to rpc client instance
 
-/**
- * RPC client context structure.
- *
- * Contains all required data to initialize an RPC client and connect to server.
+ @return none
  */
-struct c2_rpc_client_ctx {
+void c2_rpc_client_unlink(struct c2_rpc_client *cli);
 
-	/**
-	 * Input parameters.
-	 *
-	 * They are initialized and filled in by a caller of
-	 * c2_rpc_server_start() and c2_rpc_client_stop().
-	 */
 
-	/**
-	 * A pointer to net domain struct which will be initialized and used by
-	 * c2_rpc_client_start()
-	 */
-	struct c2_net_domain    *rcx_net_dom;
+/**
+ find rpc client instance in system list.
 
-	/** Transport specific local address (client's address) */
-	const char              *rcx_local_addr;
+ @param id pointer to client identifier
 
-	/** Transport specific remote address (server's address) */
-	const char              *rcx_remote_addr;
+ @return pointer to rpc client instance of NULL if rpc client not found
+*/
+struct c2_rpc_client *c2_rpc_client_find(const struct c2_service_id *id);
 
-	/** Name of database used by the RPC machine */
-	const char              *rcx_db_name;
 
+/**
+ RPC server structure (need store in memory pool db)
+ 
+ structure is describe one service on server side.
+ service have responsible to process incoming requests.
+ 
+ structure created by request of configure options and
+ and live until service shutdown will called.
+ to prevent to an early freed - structure has reference counter
+ protection. 
+ */
+struct c2_rpc_server {
 	/**
-	 * A pointer to dbenv struct which will be initialized and used by
-	 * c2_rpc_client_start()
+	 linkage to global server list
 	 */
-	struct c2_dbenv         *rcx_dbenv;
-
-	/** Identity of cob used by the RPC machine */
-	uint32_t                rcx_cob_dom_id;
-
+	struct c2_list_link	rs_link;
 	/**
-	 * A pointer to cob domain struct which will be initialized and used by
-	 * c2_rpc_client_start()
+	 unique server identifier
 	 */
-	struct c2_cob_domain    *rcx_cob_dom;
-
-	/** Number of session slots */
-	uint32_t                rcx_nr_slots;
-
-	uint64_t                rcx_max_rpcs_in_flight;
-
+	struct c2_service_id	rs_id;
 	/**
-	 * Time in seconds after which connection/session
-	 * establishment is aborted.
+	 reference counter
 	 */
-	uint32_t                rcx_timeout_s;
-
+	struct c2_ref		rs_ref;
 	/**
-	 * Output parameters.
-	 *
-	 * They are initialized and filled in by c2_rpc_server_init() and
-	 * c2_rpc_client_start().
+	 DB environment with transaction support
+	*/
+	DB_ENV			*rs_env;
+	/**
+	 DB transaction used to execute sequence of operation
+	*/
+	/**
+	 persistent session cache
 	 */
-
-	struct c2_rpcmachine    rcx_rpc_machine;
-	struct c2_net_end_point *rcx_remote_ep;
-	struct c2_rpc_conn      rcx_connection;
-	struct c2_rpc_session   rcx_session;
+	struct c2_cache		rs_sessions;
+	/**
+	 persistent reply cache
+	 */
+	struct c2_cache		rs_cache;
 };
 
 /**
-  Starts client's rpc machine. Creates a connection to a server and establishes
-  an rpc session on top of it.  Created session object can be set in an rpc item
-  and used in c2_rpc_post().
+ create instance of rpc server object
 
-  @param cctx  Initialized rpc context structure.
+ @param srv_id server identifier
 
-  @pre cctx->rcx_dbenv and rctx->rcx_cob_dom are initialized
-*/
-int c2_rpc_client_start(struct c2_rpc_client_ctx *cctx);
+ @return pointer to rpc server object, or NULL if don't possible to create
+ */
+struct c2_rpc_server *c2_rpc_server_create(const struct c2_service_id *srv_id);
 
 /**
-  Make an RPC call to a server, blocking for a reply if desired.
+ register rpc server object in system, notify transport layer about ability
+ to accept requests.
 
-  @param item        The rpc item to send.  Presumably ri_reply will hold the
-                     reply upon successful return.
-  @param rpc_session The session to be used for the client call.
-  @param ri_ops      Pointer to RPC item ops structure.
-  @param timeout_s   Timeout in seconds.  0 implies don't wait for a reply.
-*/
-int c2_rpc_client_call(struct c2_fop *fop, struct c2_rpc_session *session,
-		       const struct c2_rpc_item_ops *ri_ops, uint32_t timeout_s);
+ @param srv rpc server object pointer
+
+ @return none
+ */
+void c2_rpc_server_register(struct c2_rpc_server *srv);
 
 /**
-  Terminates RPC session and connection with server and finalize client's RPC
-  machine.
+ unregister rpc server object in system
 
-  @param cctx  Initialized rpc context structure.
-*/
-int c2_rpc_client_stop(struct c2_rpc_client_ctx *cctx);
+ @param srv rpc server object pointer
+
+ @return none
+ */
+void c2_rpc_server_unregister(struct c2_rpc_server *srv);
+
+
+/**
+ find registered rpc server object in system
 
-#endif /* __COLIBRI_RPC_RPCLIB_H__ */
+ @param srv rpc server object pointer
 
+ @return rpc server object pointer, or NULL if not found
+ */
+struct c2_rpc_server *c2_rpc_server_find(const struct c2_service_id *srv_id);
+
+/**
+ constructor for rpc library
+ */
+int c2_rpclib_init(void);
+
+/**
+ destructor for rpc library
+ */
+void c2_rpclib_fini(void);
+#endif
diff --git a/rpc/session.c b/rpc/session.c
deleted file mode 100644
index 0c264c6..0000000
--- a/rpc/session.c
+++ /dev/null
@@ -1,1241 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Rohan Puri <Rohan_Puri@xyratex.com>
- *                  Amit Jambure <Amit_Jambure@xyratex.com>
- * Original creation date: 03/17/2011
- */
-
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif
-
-#include "lib/errno.h"
-#include "lib/memory.h"
-#include "lib/misc.h"
-#include "rpc/session.h"
-#include "lib/bitstring.h"
-#include "cob/cob.h"
-#include "fop/fop.h"
-#include "fop/fop_format_def.h"
-#include "lib/arith.h"
-
-#ifdef __KERNEL__
-#include "rpc/session_k.h"
-#else
-#include "rpc/session_u.h"
-#endif
-
-#include "rpc/session_internal.h"
-#include "db/db.h"
-#include "dtm/verno.h"
-#include "rpc/session_fops.h"
-#include "rpc/rpc2.h"
-
-/**
-   @addtogroup rpc_session
-
-   @{
-
-   This file defines functions related to c2_rpc_session.
- */
-
-static void snd_slot_idle(struct c2_rpc_slot *slot);
-
-static void snd_item_consume(struct c2_rpc_item *item);
-
-static void snd_reply_consume(struct c2_rpc_item *req,
-				 struct c2_rpc_item *reply);
-
-static void rcv_slot_idle(struct c2_rpc_slot *slot);
-
-static void rcv_item_consume(struct c2_rpc_item *item);
-
-static void rcv_reply_consume(struct c2_rpc_item *req,
-			      struct c2_rpc_item *reply);
-
-/**
-   Creates cob hierarchy that represents persistent state of @session.
- */
-static int session_persistent_state_attach(struct c2_rpc_session *session,
-					   uint64_t               session_id,
-					   struct c2_db_tx       *tx);
-
-/**
-  Deletes all the cobs associated with the session and slots belonging to
-  the session
- */
-static int session_persistent_state_destroy(struct c2_rpc_session *session,
-					    struct c2_db_tx       *tx);
-
-static int nr_active_items_count(const struct c2_rpc_session *session);
-
-static const struct c2_rpc_slot_ops snd_slot_ops = {
-	.so_slot_idle = snd_slot_idle,
-	.so_item_consume = snd_item_consume,
-	.so_reply_consume = snd_reply_consume
-};
-
-static const struct c2_rpc_slot_ops rcv_slot_ops = {
-	.so_slot_idle = rcv_slot_idle,
-	.so_item_consume = rcv_item_consume,
-	.so_reply_consume = rcv_reply_consume
-};
-
-/**
-   Container of session_establish fop.
-
-   Required only on sender to obtain pointer to session being established,
-   when reply to session_establish is received.
- */
-struct fop_session_establish_ctx
-{
-	/** A fop instance of type c2_rpc_fop_conn_establish_fopt */
-	struct c2_fop          sec_fop;
-
-	/** sender side session object */
-	struct c2_rpc_session *sec_session;
-};
-
-static void fop_session_establish_item_free(struct c2_rpc_item *item);
-
-static const struct c2_rpc_item_ops session_establish_item_ops = {
-	.rio_replied = c2_rpc_session_establish_reply_received,
-	.rio_free    = fop_session_establish_item_free,
-};
-
-static const struct c2_rpc_item_ops session_terminate_item_ops = {
-	.rio_replied = c2_rpc_session_terminate_reply_received,
-	.rio_free    = c2_fop_item_free,
-};
-
-extern void frm_item_ready(struct c2_rpc_item *item);
-extern void frm_slot_idle(struct c2_rpc_slot *slot);
-
-/**
-   The routine is also called from session_foms.c, hence can't be static
- */
-bool c2_rpc_session_invariant(const struct c2_rpc_session *session)
-{
-	bool result;
-	int  i;
-
-	/*
-	 * Invariants that are common for session in state
-	 * {IDLE, BUSY, TERMINATING}
-	 */
-	bool session_alive_invariants(void)
-	{
-		return session->s_session_id <= SESSION_ID_MAX &&
-		       ergo(session->s_session_id != SESSION_ID_0,
-			    session->s_conn->c_state == C2_RPC_CONN_ACTIVE &&
-			    session->s_conn->c_nr_sessions > 0) &&
-		       session->s_nr_slots >= 0 &&
-		       c2_list_contains(&session->s_conn->c_sessions,
-				&session->s_link);
-	}
-
-	bool no_slot_in_ready_slots_list(void)
-	{
-		struct c2_rpc_slot *slot;
-		int                 i;
-
-		for (i = 0 ; i < session->s_nr_slots; i++) {
-
-			slot = session->s_slot_table[i];
-			if (c2_list_link_is_in(&slot->sl_link))
-				return false;
-
-		}
-		return true;
-	}
-
-	if (session == NULL)
-		return false;
-
-	C2_ASSERT(ergo(session->s_state != C2_RPC_SESSION_INITIALISED &&
-			session->s_state != C2_RPC_SESSION_TERMINATED &&
-			session->s_state != C2_RPC_SESSION_FAILED &&
-			session->s_session_id != SESSION_ID_0,
-			c2_mutex_is_locked(&session->s_mutex)));
-
-	/*
-	 * invariants that are independent on session state
-	 */
-	result = session->s_conn != NULL &&
-		 nr_active_items_count(session) == session->s_nr_active_items;
-	if (!result)
-		return result;
-
-	for (i = 0; i < session->s_nr_slots; i++) {
-		if (session->s_slot_table[i] == NULL)
-			return false;
-	}
-
-	/*
-	 * Exactly one state bit must be set.
-	 */
-	if (!c2_is_po2(session->s_state))
-		return false;
-
-	if (session->s_state != C2_RPC_SESSION_IDLE &&
-	    session->s_state != C2_RPC_SESSION_BUSY) {
-		result = no_slot_in_ready_slots_list();
-		if (!result)
-			return result;
-	}
-	switch (session->s_state) {
-	case C2_RPC_SESSION_INITIALISED:
-		return session->s_session_id == SESSION_ID_INVALID &&
-			session->s_nr_active_items == 0;
-
-	case C2_RPC_SESSION_ESTABLISHING:
-		return session->s_session_id == SESSION_ID_INVALID &&
-			c2_list_contains(&session->s_conn->c_sessions,
-				&session->s_link) &&
-			session->s_nr_active_items == 0;
-
-	case C2_RPC_SESSION_TERMINATED:
-		return  !c2_list_link_is_in(&session->s_link) &&
-			session->s_cob == NULL &&
-			c2_list_is_empty(&session->s_unbound_items) &&
-			session->s_nr_active_items == 0;
-
-	case C2_RPC_SESSION_IDLE:
-	case C2_RPC_SESSION_TERMINATING:
-		return session->s_nr_active_items == 0 &&
-			 c2_list_is_empty(&session->s_unbound_items) &&
-			 session_alive_invariants();
-
-	case C2_RPC_SESSION_BUSY:
-		return (session->s_nr_active_items > 0 ||
-		       !c2_list_is_empty(&session->s_unbound_items)) &&
-		       session_alive_invariants();
-
-	case C2_RPC_SESSION_FAILED:
-		return session->s_rc != 0 &&
-			!c2_list_link_is_in(&session->s_link);
-
-	default:
-		return false;
-	}
-	/* Should never reach here */
-	C2_ASSERT(0);
-}
-
-
-static int nr_active_items_count(const struct c2_rpc_session *session)
-{
-	struct c2_rpc_slot *slot;
-	struct c2_rpc_item *item;
-	int                 i;
-	int                 count = 0;
-
-	for (i = 0; i < session->s_nr_slots; i++) {
-		slot = session->s_slot_table[i];
-
-		c2_list_for_each_entry(&slot->sl_item_list, item,
-				       struct c2_rpc_item,
-				       ri_slot_refs[0].sr_link) {
-
-			if (item->ri_stage == RPC_ITEM_STAGE_IN_PROGRESS ||
-			    item->ri_stage == RPC_ITEM_STAGE_FUTURE) {
-				count++;
-			}
-
-		}
-	}
-	return count;
-}
-
-/**
-   Finalises session.
-   Used by
-    c2_rpc_session_init(), when initialisation fails.
-    c2_rpc_session_fini() for cleanup
- */
-static void __session_fini(struct c2_rpc_session *session)
-{
-	struct c2_rpc_slot *slot;
-	int                 i;
-
-	if (session->s_slot_table != NULL) {
-		for (i = 0; i < session->s_nr_slots; i++) {
-			slot = session->s_slot_table[i];
-			if (slot != NULL) {
-				c2_rpc_slot_fini(slot);
-				c2_free(slot);
-			}
-			session->s_slot_table[i] = NULL;
-		}
-		session->s_nr_slots = 0;
-		session->s_slot_table_capacity = 0;
-		c2_free(session->s_slot_table);
-		session->s_slot_table = NULL;
-	}
-	c2_list_link_fini(&session->s_link);
-	c2_cond_fini(&session->s_state_changed);
-	c2_mutex_fini(&session->s_mutex);
-	c2_list_fini(&session->s_unbound_items);
-}
-
-int c2_rpc_session_init(struct c2_rpc_session *session,
-			struct c2_rpc_conn    *conn,
-			uint32_t               nr_slots)
-{
-	const struct c2_rpc_slot_ops *slot_ops;
-	struct c2_rpc_slot           *slot;
-	int                           i;
-	int                           rc;
-
-	C2_PRE(session != NULL && conn != NULL && nr_slots >= 1);
-
-	C2_SET0(session);
-	c2_list_link_init(&session->s_link);
-	session->s_session_id = SESSION_ID_INVALID;
-	session->s_conn = conn;
-	c2_cond_init(&session->s_state_changed);
-	c2_mutex_init(&session->s_mutex);
-	session->s_nr_slots = nr_slots;
-	session->s_slot_table_capacity = nr_slots;
-	c2_list_init(&session->s_unbound_items);
-	session->s_cob = NULL;
-
-	C2_ALLOC_ARR(session->s_slot_table, nr_slots);
-	if (session->s_slot_table == NULL) {
-		rc = -ENOMEM;
-		goto out_err;
-	}
-
-	if (c2_rpc_conn_is_snd(conn)) {
-		slot_ops = &snd_slot_ops;
-	} else {
-		C2_ASSERT(c2_rpc_conn_is_rcv(conn));
-		slot_ops = &rcv_slot_ops;
-	}
-	for (i = 0; i < nr_slots; i++) {
-		C2_ALLOC_PTR(slot);
-		if (slot == NULL) {
-			rc = -ENOMEM;
-			goto out_err;
-		}
-
-		rc = c2_rpc_slot_init(slot, slot_ops);
-		if (rc != 0) {
-			c2_free(slot);
-			goto out_err;
-		}
-
-		slot->sl_session = session;
-		slot->sl_slot_id = i;
-
-		session->s_slot_table[i] = slot;
-	}
-	session->s_state = C2_RPC_SESSION_INITIALISED;
-	C2_ASSERT(c2_rpc_session_invariant(session));
-	return 0;
-
-out_err:
-	C2_ASSERT(rc != 0);
-	__session_fini(session);
-	return rc;
-}
-C2_EXPORTED(c2_rpc_session_init);
-
-void c2_rpc_session_fini(struct c2_rpc_session *session)
-{
-
-	C2_PRE(session != NULL);
-	C2_ASSERT(c2_rpc_session_invariant(session));
-	C2_PRE(session->s_state == C2_RPC_SESSION_TERMINATED ||
-			session->s_state == C2_RPC_SESSION_INITIALISED ||
-			session->s_state == C2_RPC_SESSION_FAILED);
-
-
-	__session_fini(session);
-	session->s_session_id = SESSION_ID_INVALID;
-}
-C2_EXPORTED(c2_rpc_session_fini);
-
-bool c2_rpc_session_timedwait(struct c2_rpc_session *session,
-			      uint64_t               state_flags,
-			      const c2_time_t        abs_timeout)
-{
-	bool got_event = true;
-	bool result;
-
-	c2_mutex_lock(&session->s_mutex);
-	while ((session->s_state & state_flags) == 0 && got_event) {
-		got_event = c2_cond_timedwait(&session->s_state_changed,
-						&session->s_mutex, abs_timeout);
-		/*
-		 * If got_event == false then TIME_OUT has occured.
-		 * break the loop
-		 */
-		C2_ASSERT(c2_rpc_session_invariant(session));
-	}
-	result = ((session->s_state & state_flags) != 0);
-	c2_mutex_unlock(&session->s_mutex);
-
-	return result;
-}
-C2_EXPORTED(c2_rpc_session_timedwait);
-
-int c2_rpc_session_establish(struct c2_rpc_session *session)
-{
-	struct c2_rpc_conn                  *conn;
-	struct c2_fop                       *fop;
-	struct c2_rpc_fop_session_establish *fop_se;
-	struct fop_session_establish_ctx    *ctx;
-	struct c2_rpc_session               *session_0;
-	int                                  rc;
-
-	C2_PRE(session != NULL &&
-		session->s_state == C2_RPC_SESSION_INITIALISED);
-
-	C2_ALLOC_PTR(ctx);
-	if (ctx == NULL) {
-		rc = -ENOMEM;
-	} else {
-		ctx->sec_session = session;
-
-		rc = c2_fop_init(&ctx->sec_fop,
-			         &c2_rpc_fop_session_establish_fopt, NULL);
-		if (rc != 0)
-			c2_free(ctx);
-
-	}
-	if (rc != 0) {
-		/*
-		 * It is okay to update session state without holding
-		 * session->s_mutex here.
-		 */
-		session->s_state = C2_RPC_SESSION_FAILED;
-		session->s_rc = rc;
-		C2_ASSERT(c2_rpc_session_invariant(session));
-		goto out;
-	}
-
-	fop = &ctx->sec_fop;
-
-	c2_mutex_lock(&session->s_mutex);
-	C2_ASSERT(c2_rpc_session_invariant(session));
-
-	conn = session->s_conn;
-
-	c2_mutex_lock(&conn->c_mutex);
-	C2_ASSERT(c2_rpc_conn_invariant(conn));
-	C2_ASSERT(conn->c_state == C2_RPC_CONN_ACTIVE);
-
-	fop_se = c2_fop_data(fop);
-	C2_ASSERT(fop_se != NULL);
-
-	fop_se->rse_sender_id = conn->c_sender_id;
-	fop_se->rse_slot_cnt = session->s_nr_slots;
-
-	session_0 = c2_rpc_conn_session0(conn);
-	rc = c2_rpc__fop_post(fop, session_0,
-				&session_establish_item_ops);
-	if (rc == 0) {
-		/*
-		 * conn->c_mutex protects from a race, if reply comes before
-		 * adding session to conn->c_sessions list.
-		 */
-		session->s_state = C2_RPC_SESSION_ESTABLISHING;
-		c2_list_add(&conn->c_sessions, &session->s_link);
-		conn->c_nr_sessions++;
-	} else {
-		session->s_state = C2_RPC_SESSION_FAILED;
-		session->s_rc = rc;
-		c2_fop_fini(fop);
-		c2_free(ctx);
-	}
-
-	C2_POST(ergo(rc != 0, session->s_state == C2_RPC_SESSION_FAILED));
-	C2_POST(c2_rpc_session_invariant(session));
-	C2_POST(c2_rpc_conn_invariant(conn));
-
-	c2_cond_broadcast(&session->s_state_changed,
-			  &session->s_mutex);
-	c2_mutex_unlock(&conn->c_mutex);
-	c2_mutex_unlock(&session->s_mutex);
-
-out:
-	return rc;
-}
-C2_EXPORTED(c2_rpc_session_establish);
-
-int c2_rpc_session_establish_sync(struct c2_rpc_session *session,
-				  uint32_t timeout_sec)
-{
-	int rc;
-	bool state_reached;
-
-	rc = c2_rpc_session_establish(session);
-	if (rc != 0)
-		return rc;
-
-	/* Wait for session to become idle */
-	state_reached = c2_rpc_session_timedwait(session, C2_RPC_SESSION_IDLE |
-						 C2_RPC_SESSION_FAILED,
-						 c2_time_from_now(timeout_sec, 0));
-	if (!state_reached)
-		return -ETIMEDOUT;
-
-	switch (session->s_state) {
-	case C2_RPC_SESSION_IDLE:
-		rc = 0;
-		break;
-	case C2_RPC_SESSION_FAILED:
-		rc = session->s_rc;
-		break;
-	default:
-		C2_ASSERT("internal logic error in "
-			  "c2_rpc_session_timedwait()" == 0);
-	}
-
-	return rc;
-}
-C2_EXPORTED(c2_rpc_session_establish_sync);
-
-int c2_rpc_session_create(struct c2_rpc_session *session,
-			  struct c2_rpc_conn    *conn,
-			  uint32_t               nr_slots,
-			  uint32_t               timeout_sec)
-{
-	int rc;
-
-	rc = c2_rpc_session_init(session, conn, nr_slots);
-	if (rc != 0)
-		return rc;
-
-	rc = c2_rpc_session_establish_sync(session, timeout_sec);
-	if (rc != 0)
-		c2_rpc_session_fini(session);
-
-	return rc;
-}
-
-/**
-   Moves session to FAILED state and take it out of conn->c_sessions list.
-   Caller is expected to broadcast of session->s_state_changed CV.
-
-   @pre c2_mutex_is_locked(&session->s_mutex) && (
-		 (session->s_state == C2_RPC_SESSION_ESTABLISHING ||
-                  session->s_state == C2_RPC_SESSION_IDLE ||
-                  session->s_state == C2_RPC_SESSION_BUSY ||
-                  session->s_state == C2_RPC_SESSION_TERMINATING)
- */
-static void session_failed(struct c2_rpc_session *session, int32_t error)
-{
-	struct c2_rpc_conn *conn;
-
-	C2_PRE(c2_mutex_is_locked(&session->s_mutex));
-	C2_ASSERT(c2_rpc_session_invariant(session));
-	C2_PRE(session->s_state == C2_RPC_SESSION_ESTABLISHING ||
-		  session->s_state == C2_RPC_SESSION_IDLE ||
-		  session->s_state == C2_RPC_SESSION_BUSY ||
-		  session->s_state == C2_RPC_SESSION_TERMINATING);
-
-	session->s_state = C2_RPC_SESSION_FAILED;
-	session->s_rc = error;
-	/*
-	 * Remove session from conn->c_sessions list
-	 */
-	conn = session->s_conn;
-	c2_mutex_lock(&conn->c_mutex);
-	c2_list_del(&session->s_link);
-	conn->c_nr_sessions--;
-	C2_ASSERT(c2_rpc_conn_invariant(conn));
-	c2_mutex_unlock(&conn->c_mutex);
-
-	C2_ASSERT(c2_rpc_session_invariant(session));
-}
-
-void c2_rpc_session_establish_reply_received(struct c2_rpc_item *req)
-{
-	struct c2_rpc_fop_session_establish_rep *fop_ser;
-	struct fop_session_establish_ctx        *ctx;
-	struct c2_rpc_item                      *reply = req->ri_reply;
-	struct c2_fop                           *fop;
-	struct c2_rpc_session                   *session;
-	struct c2_rpc_slot                      *slot;
-	uint64_t                                 sender_id;
-	uint64_t                                 session_id;
-	int32_t                                  rc    = req->ri_error;
-	int                                      i;
-
-	C2_PRE(req != NULL && req->ri_session != NULL &&
-		req->ri_session->s_session_id == SESSION_ID_0);
-	C2_PRE(ergo(rc == 0, reply != NULL &&
-			req->ri_session == reply->ri_session));
-
-	fop = c2_rpc_item_to_fop(req);
-	ctx = container_of(fop, struct fop_session_establish_ctx, sec_fop);
-	session = ctx->sec_session;
-	C2_ASSERT(session != NULL);
-
-	c2_mutex_lock(&session->s_mutex);
-	C2_ASSERT(c2_rpc_session_invariant(session));
-	C2_ASSERT(session->s_state == C2_RPC_SESSION_ESTABLISHING);
-
-	if (rc != 0) {
-		session_failed(session, rc);
-		goto out;
-	}
-
-	fop_ser = c2_fop_data(c2_rpc_item_to_fop(reply));
-
-	sender_id = fop_ser->rser_sender_id;
-	session_id = fop_ser->rser_session_id;
-
-	if (fop_ser->rser_rc != 0) {
-		session_failed(session, fop_ser->rser_rc);
-	} else {
-		if (session_id < SESSION_ID_MIN ||
-		    session_id > SESSION_ID_MAX ||
-		    sender_id == SENDER_ID_INVALID) {
-			/*
-			 * error_code (rser_rc) in reply fop says session
-			 * establish is successful. But either session_id is
-			 * out of valid range or sender_id is invalid. This
-			 * should not happen.
-			 * Move session to FAILED state and XXX generate ADDB
-			 * record.
-			 * No assert on data received from network/disk.
-			 */
-			session_failed(session, -EPROTO);
-			goto out;
-		}
-		session->s_session_id = session_id;
-		session->s_state = C2_RPC_SESSION_IDLE;
-		for (i = 0; i < session->s_nr_slots; i++) {
-			slot = session->s_slot_table[i];
-			C2_ASSERT(slot != NULL && c2_rpc_slot_invariant(slot));
-			slot->sl_ops->so_slot_idle(slot);
-		}
-	}
-
-out:
-	C2_ASSERT(c2_rpc_session_invariant(session));
-	C2_ASSERT(session->s_state == C2_RPC_SESSION_IDLE ||
-		  session->s_state == C2_RPC_SESSION_FAILED);
-	c2_cond_broadcast(&session->s_state_changed, &session->s_mutex);
-	c2_mutex_unlock(&session->s_mutex);
-}
-
-static void fop_session_establish_item_free(struct c2_rpc_item *item)
-{
-	struct fop_session_establish_ctx *ctx;
-	struct c2_fop                    *fop;
-
-	fop = c2_rpc_item_to_fop(item);
-	ctx = container_of(fop, struct fop_session_establish_ctx, sec_fop);
-	c2_free(ctx);
-}
-
-int c2_rpc_session_terminate(struct c2_rpc_session *session)
-{
-	struct c2_fop                       *fop;
-	struct c2_rpc_fop_session_terminate *fop_st;
-	struct c2_rpc_session               *session_0;
-	struct c2_rpc_conn                  *conn;
-	int                                  rc;
-
-	C2_PRE(session != NULL && session->s_conn != NULL);
-
-	c2_rpc_session_del_slots_from_ready_list(session);
-	c2_mutex_lock(&session->s_mutex);
-
-	C2_ASSERT(c2_rpc_session_invariant(session));
-	C2_ASSERT(session->s_state == C2_RPC_SESSION_IDLE ||
-		  session->s_state == C2_RPC_SESSION_TERMINATING);
-
-	/*
-	 * c2_rpc_session_terminate() is a no-op if session is already
-	 * in TERMINATING state
-	 */
-	if (session->s_state == C2_RPC_SESSION_TERMINATING) {
-		rc = 0;
-		goto out_unlock;
-	}
-
-	session->s_state = C2_RPC_SESSION_TERMINATING;
-
-	/*
-	 * Attempt to move this fop allocation before taking session->s_mutex
-	 * resulted in lots of code duplication. So this memory allocation
-	 * while holding a mutex is intentional.
-	 */
-	fop = c2_fop_alloc(&c2_rpc_fop_session_terminate_fopt, NULL);
-	if (fop == NULL) {
-		rc = -ENOMEM;
-		/*
-		 * There are two choices here:
-		 *
-		 * 1. leave session in TERMNATING state FOREVER.
-		 *    Then when to fini/cleanup session.
-		 *    This will not allow finialising of session, in turn conn,
-		 *    and rpcmachine can't be finalised.
-		 *
-		 * 2. Move session to FAILED state.
-		 *    For this session the receiver side state will still
-		 *    continue to exist. And receiver can send unsolicited
-		 *    items, that will be received on sender i.e. current node.
-		 *    Current code will drop such items. When/how to fini and
-		 *    cleanup receiver side state? XXX
-		 *
-		 * For now, later is chosen. This can be changed in future
-		 * to alternative 1, iff required.
-		 */
-		session_failed(session, rc);
-		goto out;
-	}
-
-	conn = session->s_conn;
-
-	fop_st = c2_fop_data(fop);
-	fop_st->rst_sender_id = conn->c_sender_id;
-	fop_st->rst_session_id = session->s_session_id;
-
-	c2_mutex_lock(&conn->c_mutex);
-	session_0 = c2_rpc_conn_session0(conn);
-	c2_mutex_unlock(&conn->c_mutex);
-
-	c2_mutex_unlock(&session->s_mutex);
-
-	rc = c2_rpc__fop_post(fop, session_0,
-				&session_terminate_item_ops);
-
-	c2_mutex_lock(&session->s_mutex);
-
-	if (rc != 0) {
-		session_failed(session, rc);
-		c2_fop_free(fop);
-	}
-
-out_unlock:
-	C2_ASSERT(c2_rpc_session_invariant(session));
-	C2_POST(ergo(rc != 0, session->s_state == C2_RPC_SESSION_FAILED));
-	c2_cond_broadcast(&session->s_state_changed, &session->s_mutex);
-	c2_mutex_unlock(&session->s_mutex);
-
-out:
-	return rc;
-}
-C2_EXPORTED(c2_rpc_session_terminate);
-
-int c2_rpc_session_terminate_sync(struct c2_rpc_session *session,
-				  uint32_t timeout_sec)
-{
-	int rc;
-	bool state_reached;
-
-	/* Wait for session to become IDLE */
-	c2_rpc_session_timedwait(session, C2_RPC_SESSION_IDLE,
-				 c2_time_from_now(timeout_sec, 0));
-
-	/* Terminate session */
-	rc = c2_rpc_session_terminate(session);
-	if (rc != 0)
-		return rc;
-
-	/* Wait for session to become TERMINATED */
-	state_reached = c2_rpc_session_timedwait(session,
-				C2_RPC_SESSION_TERMINATED | C2_RPC_SESSION_FAILED,
-				c2_time_from_now(timeout_sec, 0));
-	if (!state_reached)
-		return -ETIMEDOUT;
-
-	switch (session->s_state) {
-	case C2_RPC_SESSION_TERMINATED:
-		rc = 0;
-		break;
-	case C2_RPC_SESSION_FAILED:
-		rc = session->s_rc;
-		break;
-	default:
-		C2_ASSERT("internal logic error in "
-			  "c2_rpc_session_timedwait()" == 0);
-	}
-
-	return rc;
-}
-C2_EXPORTED(c2_rpc_session_terminate_sync);
-
-int c2_rpc_session_destroy(struct c2_rpc_session *session, uint32_t timeout_sec)
-{
-	int rc;
-
-	rc = c2_rpc_session_terminate_sync(session, timeout_sec);
-	if (rc != 0)
-		return rc;
-
-	c2_rpc_session_fini(session);
-
-	return rc;
-}
-C2_EXPORTED(c2_rpc_session_destroy);
-
-void c2_rpc_session_terminate_reply_received(struct c2_rpc_item *req)
-{
-	struct c2_rpc_fop_session_terminate_rep *fop_str;
-	struct c2_rpc_fop_session_terminate     *fop_st;
-	struct c2_rpc_item                      *reply = req->ri_reply;
-	struct c2_fop                           *fop;
-	struct c2_rpc_conn                      *conn;
-	struct c2_rpc_session                   *session;
-	uint64_t                                 sender_id;
-	uint64_t                                 session_id;
-	int32_t                                  rc    = req->ri_error;
-
-	C2_PRE(req != NULL && req->ri_session != NULL &&
-		req->ri_session->s_session_id == SESSION_ID_0);
-	C2_PRE(ergo(rc == 0, reply != NULL &&
-			req->ri_session == reply->ri_session));
-
-	/*
-	 * Extract sender_id and session_id from SESSION_TERMINATE
-	 * _request_ fop.
-	 */
-	fop = c2_rpc_item_to_fop(req);
-	fop_st = c2_fop_data(fop);
-
-	sender_id = fop_st->rst_sender_id;
-	session_id = fop_st->rst_session_id;
-
-	if (session_id == SESSION_ID_0) {
-		/*
-		 * There is no explicit SESSION_TERMINATE request from sender
-		 * to terminate session 0.
-		 * Session 0 is terminated along with the c2_rpc_conn object
-		 * to which the session 0 belongs. So control should never
-		 * reach here. But because of possible corruption on network
-		 * or bug in receiver side code, session_id can be
-		 * SESSION_ID_0. We cannot put assert here, this needs to be
-		 * handled. XXX generate ADDB record here.
-		 */
-		C2_ASSERT(0);  /* For testing purpose */
-		return;
-	}
-
-	/*
-	 * Search session being terminated <sender_id, session_id>
-	 */
-	conn = req->ri_session->s_conn;
-	C2_ASSERT(conn != NULL);
-
-	c2_mutex_lock(&conn->c_mutex);
-
-	C2_ASSERT(c2_rpc_conn_invariant(conn));
-	C2_ASSERT(conn->c_state == C2_RPC_CONN_ACTIVE);
-
-	session = c2_rpc_session_search(conn, session_id);
-	C2_ASSERT(session != NULL);
-
-	c2_mutex_unlock(&conn->c_mutex);
-
-	/* Locking order: session => conn */
-	c2_mutex_lock(&session->s_mutex);
-	C2_ASSERT(c2_rpc_session_invariant(session) &&
-			session->s_state == C2_RPC_SESSION_TERMINATING);
-
-	c2_mutex_lock(&conn->c_mutex);
-	/*
-	 * Remove session from conn->c_sessions list
-	 */
-	c2_list_del(&session->s_link);
-	C2_ASSERT(conn->c_nr_sessions > 0);
-	conn->c_nr_sessions--;
-	C2_ASSERT(c2_rpc_conn_invariant(conn));
-	c2_mutex_unlock(&conn->c_mutex);
-
-	if (rc != 0) {
-		session->s_state = C2_RPC_SESSION_FAILED;
-		session->s_rc = rc;
-		goto out;
-	}
-
-	fop = c2_rpc_item_to_fop(reply);
-	fop_str = c2_fop_data(fop);
-
-	if (sender_id != fop_str->rstr_sender_id ||
-			session_id != fop_str->rstr_session_id) {
-		/*
-		 * Contents of conn terminate reply are not as per expectations.
-		 * Move session to FAILED state. XXX And generate ADDB record.
-		 * No asserts on data received from network/disk.
-		 */
-		session->s_state = C2_RPC_SESSION_FAILED;
-		session->s_rc = -EPROTO;
-		goto out;
-	}
-
-	if (fop_str->rstr_rc == 0) {
-		session->s_state = C2_RPC_SESSION_TERMINATED;
-	} else {
-		session->s_state = C2_RPC_SESSION_FAILED;
-		session->s_rc = fop_str->rstr_rc;
-	}
-
-out:
-	C2_ASSERT(c2_rpc_session_invariant(session));
-	C2_ASSERT(session->s_state == C2_RPC_SESSION_TERMINATED ||
-			session->s_state == C2_RPC_SESSION_FAILED);
-	c2_cond_broadcast(&session->s_state_changed, &session->s_mutex);
-	c2_mutex_unlock(&session->s_mutex);
-}
-
-int c2_rpc_session_cob_lookup(struct c2_cob   *conn_cob,
-			      uint64_t         session_id,
-			      struct c2_cob  **session_cob,
-			      struct c2_db_tx *tx)
-{
-	struct c2_cob *cob;
-	char           name[SESSION_COB_MAX_NAME_LEN];
-	int            rc;
-
-	C2_PRE(conn_cob != NULL && session_id <= SESSION_ID_MAX &&
-			session_cob != NULL);
-
-	*session_cob = NULL;
-	sprintf(name, "SESSION_%lu", (unsigned long)session_id);
-
-	rc = c2_rpc_cob_lookup_helper(conn_cob->co_dom, conn_cob, name,
-					&cob, tx);
-	C2_ASSERT(ergo(rc != 0, cob == NULL));
-	*session_cob = cob;
-	return rc;
-}
-
-int c2_rpc_session_cob_create(struct c2_cob   *conn_cob,
-			      uint64_t         session_id,
-			      struct c2_cob  **session_cob,
-			      struct c2_db_tx *tx)
-{
-	struct c2_cob *cob;
-	char           name[SESSION_COB_MAX_NAME_LEN];
-	int            rc;
-
-	C2_PRE(conn_cob != NULL && session_id != SESSION_ID_INVALID &&
-			session_cob != NULL);
-
-	*session_cob = NULL;
-	sprintf(name, "SESSION_%lu", (unsigned long)session_id);
-
-	rc = c2_rpc_cob_create_helper(conn_cob->co_dom, conn_cob, name,
-					&cob, tx);
-	C2_ASSERT(ergo(rc != 0, cob == NULL));
-	*session_cob = cob;
-	return rc;
-}
-
-/**
-   Allocates and returns new session_id
- */
-uint64_t session_id_allocate(void)
-{
-	static struct c2_atomic64 cnt;
-	uint64_t                  session_id;
-	uint64_t                  sec;
-
-	do {
-		c2_atomic64_inc(&cnt);
-		sec = c2_time_nanoseconds(c2_time_now()) * 1000000;
-
-		session_id = (sec << 10) | (c2_atomic64_get(&cnt) & 0x3FF);
-
-	} while (session_id < SESSION_ID_MIN ||
-			session_id > SESSION_ID_MAX);
-
-	return session_id;
-}
-
-static void snd_slot_idle(struct c2_rpc_slot *slot)
-{
-	C2_ASSERT(slot->sl_in_flight == 0);
-	frm_slot_idle(slot);
-}
-
-static void snd_item_consume(struct c2_rpc_item *item)
-{
-	frm_item_ready(item);
-}
-
-static void snd_reply_consume(struct c2_rpc_item *req,
-			      struct c2_rpc_item *reply)
-{
-	/* Don't do anything on sender to consume reply */
-}
-
-static void rcv_slot_idle(struct c2_rpc_slot *slot)
-{
-	C2_ASSERT(slot->sl_in_flight == 0);
-	/*
-	 * On receiver side, no slot is placed on ready_slots list.
-	 * All consumed reply items, will be treated as bound items by
-	 * formation, and will find these items in its own lists.
-	 */
-}
-
-static void rcv_item_consume(struct c2_rpc_item *item)
-{
-	c2_rpc_item_dispatch(item);
-}
-
-static void rcv_reply_consume(struct c2_rpc_item *req,
-			      struct c2_rpc_item *reply)
-{
-	frm_item_ready(reply);
-}
-
-int c2_rpc_rcv_session_establish(struct c2_rpc_session *session)
-{
-	struct c2_db_tx tx;
-	uint64_t        session_id;
-	int             rc;
-
-	C2_PRE(session != NULL);
-
-	c2_mutex_lock(&session->s_mutex);
-
-	C2_ASSERT(c2_rpc_session_invariant(session));
-	C2_ASSERT(session->s_state == C2_RPC_SESSION_INITIALISED);
-
-	rc = c2_db_tx_init(&tx, session->s_conn->c_cob->co_dom->cd_dbenv, 0);
-	if (rc != 0)
-		goto out;
-
-	session_id = session_id_allocate();
-	rc = session_persistent_state_attach(session, session_id, &tx);
-	if (rc != 0) {
-		/*
-		 * Regardless of return value of c2_db_tx_abort() session
-		 * will be moved to FAILED state.
-		 */
-		c2_db_tx_abort(&tx);
-		goto out;
-	}
-	rc = c2_db_tx_commit(&tx);
-	if (rc != 0)
-		goto out;
-
-	session->s_session_id = session_id;
-
-	c2_mutex_lock(&session->s_conn->c_mutex);
-	C2_ASSERT(c2_rpc_conn_invariant(session->s_conn));
-
-	c2_list_add(&session->s_conn->c_sessions, &session->s_link);
-	session->s_conn->c_nr_sessions++;
-
-	C2_ASSERT(c2_rpc_conn_invariant(session->s_conn));
-	c2_mutex_unlock(&session->s_conn->c_mutex);
-
-out:
-	session->s_state = (rc == 0) ? C2_RPC_SESSION_IDLE :
-				       C2_RPC_SESSION_FAILED;
-	session->s_rc = rc;
-	C2_ASSERT(c2_rpc_session_invariant(session));
-	c2_mutex_unlock(&session->s_mutex);
-	return rc;
-}
-
-static int session_persistent_state_attach(struct c2_rpc_session *session,
-					   uint64_t               session_id,
-					   struct c2_db_tx       *tx)
-{
-	struct c2_cob  *cob;
-	int             rc;
-	int             i;
-
-	C2_PRE(session != NULL &&
-	       c2_rpc_session_invariant(session) &&
-	       session->s_state == C2_RPC_SESSION_INITIALISED &&
-	       session->s_cob == NULL);
-
-	session->s_cob = NULL;
-	rc = c2_rpc_session_cob_create(session->s_conn->c_cob,
-					session_id, &cob, tx);
-	if (rc != 0)
-		goto errout;
-
-	C2_ASSERT(cob != NULL);
-	session->s_cob = cob;
-
-	for (i = 0; i < session->s_nr_slots; i++) {
-		C2_ASSERT(session->s_slot_table[i]->sl_cob == NULL);
-		rc = c2_rpc_slot_cob_create(session->s_cob, i, 0,
-							&cob, tx);
-		if (rc != 0)
-			goto errout;
-
-		C2_ASSERT(cob != NULL);
-		session->s_slot_table[i]->sl_cob = cob;
-	}
-	return rc;
-
-errout:
-	C2_ASSERT(rc != 0);
-
-	for (i = 0; i < session->s_nr_slots; i++) {
-		cob = session->s_slot_table[i]->sl_cob;
-		if (cob != NULL)
-			c2_cob_put(cob);
-		session->s_slot_table[i]->sl_cob = NULL;
-	}
-	if (session->s_cob != NULL) {
-		c2_cob_put(session->s_cob);
-		session->s_cob = NULL;
-	}
-	return rc;
-}
-
-static int session_persistent_state_destroy(struct c2_rpc_session *session,
-					    struct c2_db_tx       *tx)
-{
-	struct c2_rpc_slot *slot;
-	int                 i;
-
-	C2_ASSERT(session != NULL);
-
-	for (i = 0; i < session->s_nr_slots; i++) {
-		slot = session->s_slot_table[i];
-		if (slot != NULL && slot->sl_cob != NULL) {
-			/*
-			 * c2_cob_delete() "puts" the cob even if cob delete
-			 * fails. Irrespective of success/failure of
-			 * c2_cob_delete(), the c2_cob becomes unusable. So
-			 * no need to handle the error
-			 */
-			c2_cob_delete(slot->sl_cob, tx);
-			slot->sl_cob = NULL;
-		}
-	}
-	if (session->s_cob != NULL) {
-		c2_cob_delete(session->s_cob, tx);
-		session->s_cob = NULL;
-	}
-
-	return 0;
-}
-
-int c2_rpc_rcv_session_terminate(struct c2_rpc_session *session)
-{
-	struct c2_rpc_conn *conn;
-	struct c2_db_tx     tx;
-	int                 rc;
-
-	C2_PRE(session != NULL);
-
-	c2_mutex_lock(&session->s_mutex);
-	C2_ASSERT(c2_rpc_session_invariant(session));
-
-	if (session->s_state != C2_RPC_SESSION_IDLE) {
-		/*
-		 * Should catch this situation while testing. This can be
-		 * because of some bug.
-		 */
-		C2_ASSERT(0);
-		/*
-		 * XXX Generate ADDB record here.
-		 */
-		c2_mutex_unlock(&session->s_mutex);
-		return -EPROTO;
-	}
-
-	/* For receiver side session, no slots are on ready_slots list
-	   since all reply items are bound items. */
-
-	/*
-	 * remove session from list of sessions maintained in c2_rpc_conn.
-	 */
-	conn = session->s_conn;
-	c2_mutex_lock(&conn->c_mutex);
-
-	c2_list_del(&session->s_link);
-	conn->c_nr_sessions--;
-
-	C2_ASSERT(c2_rpc_conn_invariant(conn));
-	c2_mutex_unlock(&conn->c_mutex);
-
-	/*
-	 * Remove persistent state of session.
-	 */
-	rc = c2_db_tx_init(&tx, session->s_cob->co_dom->cd_dbenv, 0);
-	if (rc != 0)
-		goto out;
-
-	rc = session_persistent_state_destroy(session, &tx);
-	if (rc == 0) {
-		rc = c2_db_tx_commit(&tx);
-	} else {
-		/*
-		 * Even if abort fails, we will move session to FAILEd state.
-		 */
-		c2_db_tx_abort(&tx);
-	}
-
-out:
-	session->s_state = (rc == 0) ? C2_RPC_SESSION_TERMINATED :
-				C2_RPC_SESSION_FAILED;
-	session->s_rc = rc;
-	C2_ASSERT(c2_rpc_session_invariant(session));
-	c2_mutex_unlock(&session->s_mutex);
-	return rc;
-}
-
-/**
-   For all slots belonging to @session,
-     if slot is in c2_rpcmachine::cr_ready_slots list,
-     then remove it from the list.
- */
-void c2_rpc_session_del_slots_from_ready_list(struct c2_rpc_session *session)
-{
-	struct c2_rpc_slot   *slot;
-	struct c2_rpcmachine *machine;
-	int                   i;
-
-	machine = session->s_conn->c_rpcmachine;
-
-	/*
-	 * XXX lock and unlock of cr_ready_slots_mutex is commented, until
-	 * formation adds a fix for correct lock ordering.
-	 */
-	c2_mutex_lock(&machine->cr_ready_slots_mutex);
-
-	for (i = 0; i < session->s_nr_slots; i++) {
-		slot = session->s_slot_table[i];
-
-		C2_ASSERT(slot != NULL);
-
-		if (c2_list_link_is_in(&slot->sl_link))
-			c2_list_del(&slot->sl_link);
-	}
-
-	c2_mutex_unlock(&machine->cr_ready_slots_mutex);
-}
-
-/** @} end of session group */
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
diff --git a/rpc/session.ff b/rpc/session.ff
deleted file mode 100644
index b57ca7e..0000000
--- a/rpc/session.ff
+++ /dev/null
@@ -1,153 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Rohan Puri <Rohan_Puri@xyratex.com>,
- *		    Amit Jambure <Amit_Jambure@xyratex.com>
- * Original creation date: 03/11/2011
- */
-
-/**
-   @addtogroup rpc_session
-
-   @{
- */
-
-/**
-   FOP sent from sender to receiver to establish a new rpc connection.
- */
-DEF(c2_rpc_fop_conn_establish, RECORD,
-   _(rce_unused, U64));
-
-/**
-   FOP sent by receiver back to sender as a reply to c2_rpc_fop_conn_establish
-   FOP.
- */
-DEF(c2_rpc_fop_conn_establish_rep, RECORD,
-   /**
-      sender_id assigned by receiver to the established rpc-connection.
-      Has value SENDER_ID_INVALID if CONN_ESTABLISH operation fails.
-    */
-   _(rcer_sender_id, U64),
-   /**
-      Contains 0 if CONN_ESTABLISH operation is successful, error code
-      otherwise.
-    */
-   _(rcer_rc, U32));
-
-/**
-   Request FOP to terminate rpc-connection. Sent from sender to receiver.
- */
-DEF(c2_rpc_fop_conn_terminate, RECORD,
-    /**
-       sender_id of rpc-connection being terminated.
-     */
-    _(ct_sender_id, U64));
-
-/**
-   Reply FOP to c2_rpc_conn_terminate. Sent from receiver to sender.
- */
-DEF(c2_rpc_fop_conn_terminate_rep, RECORD,
-   /**
-      sender_id of rpc-connection being terminated.
-    */
-   _(ctr_sender_id, U64),
-   /**
-      Contains 0 if CONN_TERMINATE operation is successful, error code
-      otherwise.
-    */
-   _(ctr_rc, U32));
-
-/**
-   Request FOP to establish a new session. Sent from sender to receiver.
- */
-DEF(c2_rpc_fop_session_establish, RECORD,
-   /**
-      sender_id of rpc-connection in which a new session is to be created.
-    */
-   _(rse_sender_id, U64),
-   /**
-      Number of slots the new session should have.
-    */
-   _(rse_slot_cnt, U32));
-
-/**
-   Reply of c2_rpc_fop_session_establish. Sent from receiver to
-   sender.
- */
-DEF(c2_rpc_fop_session_establish_rep, RECORD,
-   /**
-      session_id assigned by receiver to the newly created session.
-      Has value SESSION_ID_INVALID if SESSION_ESTABLISH operation fails.
-    */
-   _(rser_session_id, U64),
-   /**
-      sender_id copied from c2_rpc_fop_session_establish.
-    */
-   _(rser_sender_id, U64),
-   /**
-      Contains 0 if SESSION_ESTABLISH operation is successful, error code
-      otherwise.
-    */
-   _(rser_rc, U32));
-
-/**
-   Request FOP to terminate a session. Sent from sender to receiver.
- */
-DEF(c2_rpc_fop_session_terminate, RECORD,
-   /**
-      sender_id of rpc-connection to which the session being terminated
-      belongs.
-    */
-   _(rst_sender_id, U64),
-   /**
-      session_id of session being termianted.
-    */
-   _(rst_session_id, U64));
-
-/**
-   Reply FOP to c2_rpc_fop_session_terminate. Sent from receiver to sender.
- */
-DEF(c2_rpc_fop_session_terminate_rep, RECORD,
-   /**
-      session_id of the session being terminated.
-    */
-   _(rstr_session_id, U64),
-   /**
-      sender_id of rpc-connection to which the session being terminated
-      belongs.
-    */
-   _(rstr_sender_id, U64),
-   /**
-      Contains 0 if SESSION_TERMINATE operation is successful, error code
-      otherwise.
-    */
-   _(rstr_rc, U32));
-
-DEF(c2_rpc_fop_noop, RECORD,
-   _(n_unused, U64));
-
-/** @} end of rpc_session group */
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
-
diff --git a/rpc/session.h b/rpc/session.h
index cf005d6..953055a 100644
--- a/rpc/session.h
+++ b/rpc/session.h
@@ -1,4 +1,3 @@
-/* -*- C -*- */
 /*
  * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
  *
@@ -14,9 +13,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Alexey Lyashkov <Alexey_Lyashkov@xyratex.com>
- *                  Rohan Puri <Rohan_Puri@xyratex.com>
- *                  Amit Jambure <Amit_Jambure@xyratex.com>
+ * Original author: Alexey Lyashkov
  * Original creation date: 04/09/2010
  */
 
@@ -24,1185 +21,52 @@
 #define __COLIBRI_RPC_SESSION_H__
 
 /**
+@page rpc-session rpc session implementation
 
-@defgroup rpc_session RPC Sessions
+@section def Definition
 
-@{
+	A session is a dynamically created, long-lived server object created and
+destroyed by a client requests. It function is to maintain the server's state
+relative to the connection(s) belonging to a client instance.
 
-@section Overview
+	Slot is dynamically created server object. Slot created by a client request and
+attached to active client session. It function is to maintain the order of
+requests execution. A slot contains a sequence ID and the cached
+reply corresponding to the request sent with that sequence ID.
 
-Session module of rpc layer has two objectives:
+	Slots incorporates into slot table.
 
-- If some rpc-items need to be delivered to receiver in same sequence in
-  which sender has submitted them, then it is the session module which
-  ensures that the items are delivered in FIFO sequence.
+	Slot ID is index in slot table.
 
-- To provide exactly once semantics.
-  see http://www.cs.unc.edu/~dewan/242/s06/notes/ipc/node30.html
+@section sessionfunct Functional specification
 
-Aproach taken by session module to achive these two objectives, is similar
-to session-slot implementation in NFSv4.1
 
-See section 2.10.6 of rfc 5661 NFSv4.1
-http://tools.ietf.org/html/rfc5661#section-2.10.6
+session module createated to flow description from RFC XXXX.
+and have a two parts.
 
-Session module defines following types of objects:
-- rpc connection @see c2_rpc_conn
-- rpc session @see c2_rpc_session
-- slot @see c2_rpc_slot
-- slot ref @see c2_rpc_slot_ref.
+\li client part - responsible to make a stimulus to create and destroy sessions,
+send (or resend) request to replier.
+@ref rpc-session-cli
 
-Out of these, c2_rpc_conn and c2_rpc_session are visible to user.
-c2_rpc_slot and c2_rpc_slot_ref are internal to rpc layer and not visible to
-users outside rpc layer.
+\li server part - responsible to handle incoming request, create or destroy
+session bases on client requests.
+@ref rpc-session-srv
 
-Session module uses following types of objects defined by rpc-core:
-- rpc machine @see c2_rpcmachine
-- rpc item @see c2_rpc_item.
+Communication between these parts a processed via RPC messages. Format of messages
+is described in rpc types document. @ref rpc-types
 
-<B> Relationships among objects: </B>
-rpcmachine has two lists of rpc connections.
-- Outgoing connections: Contains c2_rpc_conn objects for which this node is
-sender.
-- Incoming connections: Contains c2_rpc_conn objects for which this node is
-receiver.
+To reduce count of RPC's and protect order of excecution number of operations merged in
+single compound RPC.
+@ref rpc-compound
 
-Rpc connection has a list of rpc sessions, which are created on this
-connection. A rpc connection cannot be terminated until all the sessions
-created on the connection are terminated.
 
-A session contains one or more slots. Number of slots in the session can
-vary over the lifetime of session (In current implementation state, the number
-of slots do not vary. The slot count is fixed for entire lifetime of session.
-Slot count is specified at the time of session initialisation).
+@section sessionlogspec Logical specification
 
-Each object of type [c2_rpc_conn|c2_rpc_session|c2_rpc_slot] on sender
-has counterpart object of same type on receiver. (Note: same structure
-definitions are used on both sender and receiver side)
 
-<B> Bound and Unbound rpc items: </B>
+@section flow State flow
 
-Rpc layer can send an rpc item on network only if it is associated with some
-slot within the session. User of rpc layer can indirectly specify the slot (via
-"update stream") on which the item needs to be sent. Or the user can just
-specify session and leave the task of choosing any available slot to
-rpc layer.
+@ref rpc-lib
 
-With respect to session and slots, an rpc item is said to be "bound" if
-the item is associated with slot. An item is called as "unbound"/"freestanding"
-if it is not associated with any particular slot yet. An unbound item will be
-eventually associated with slot, and hence become bound item.
-
-<b> Reply cache: </b>
-
-Reply cache caches replies of update operations. Reply of read-only
-operation is not cached. When a duplicate update item is received which is
-already executed on receiver, then instead of again processing the item,
-its reply is retrieved from reply cache and returned to the sender.
-By preventing multiple executions of same item (or FOP), reply cache provides
-"exactly once" semantics. If reply cache is persistent, then EOS can be
-guaranteed even in the face of receiver restart. Colibri implements Reply
-Cache via FOL (File Operation Log). See section "Slot as a cob" for more
-details on this.
-
-<B> Slot as a "cob": </B>
-Session module implements a slot as a "special file". This allows to reuse
-persistent data structure and code of cob infrastructure.
-
-For each slot, session module will create a cob named $SLOT_ID:$GEN inside
-directory /sessions/$SENDER_ID/$SESSION_ID/.
-Where $SENDER_ID, $SESSION_ID, $SLOT_ID and $GEN are place-holders for actual
-identifier values.
-
-Version number of slot is same as version number of cob that represents
-the slot. Each item also contains a version number. If an item is received,
-whose version number matches with version number of slot, then the item is
-accepted as valid item in the sequence and sent for execution. If item is an
-"update operation" (i.e. it modifies file-system state) then the version
-number of slot is advanced.
-
-FOL (File Operation Log) contains record for each update operation executed.
-The FOL record contains all the information required to undo or redo that
-specific operation. If along with the operation details, reply of operation
-is also stored in the FOL record, the FOL itself acts as a "Reply Cache".
-Given fid of cob that represents the slot and version number of item, it is
-possible to determine whether the item is duplicate or not. If it is duplicate
-item then version number within the item will be less than version number of
-slot. And there will be a record already present in the FOL representing the
-same operation. Then the reply can be extracted from the FOL record and resent
-back to sender.
-
-<B>Ensuring FIFO when slot.max_in_flight > 1 </B>
-
- XXX Current implementation does not have way to define dependancies.
-     Hence no more than 1 items are allowed to be in-flight for a particular
-     slot.
-
- First, let's clarify that xid is used to uniquely identify items sent through
- a particular slot, whereas verno is used to identify the state of target
- objects (including slots) when the operation is applicable.
-
- We want to achieve the following goals:
-
-   - sequence of operations sent through a slot can be exactly reproduced
-     after the receiver or the network failed. "Reproduced" here means that
-     after the operations are re-applied the same observable system state
-     results.
-
-   - Network level concurrency (multiple items in flight).
-
-   - Server level concurrency (multiple operations executed on the receiver
-     concurrently, where possible).
-
-   - Operations might have dependencies.
-
- Let's put the following data into each item:
- @code
- struct c2_rpc_item {
-       struct c2_verno     verno;
-       uint64_t            xid;
-       struct c2_rpc_item *dep;
- };
- @endcode
-
- ->verno and ->xid are used as usual. ->dep identifies an item, sent to
-  the same receiver, which this item "depends on". item can be executed only
-  after item->dep has been executed. If an item does not depend on any other
-  item, then item->dep == NULL.
-
- When an item is submitted to the rpc layer, its ->dep is
-
-   - either set by the caller (the rpc checks that the receiver is the same
-     in a pre-condition);
-
-   - set to NULL to indicate that there are no dependencies;
-
-   - set to a special LAST constant value, to indicate that the item depends
-     on the last item sent through the same slot. In this case, the rpc code
-     assigns ->dep to the appropriate item:
-
-     @code
-       if (item->flags & MUTABO)
-               item->dep = latest item on the slot list;
-       else
-               item->dep = latest MUTABO item on the slot list;
-     @endcode
-
-     For a freestanding item, this assignment is done lately, when the
-     freestanding item is assigned a slot and xid.
-
- item->dep->xid is sent to the receiver along with other item attributes. On
- the receiver, the item is submitted to the request handler only when
-
-   - item->dep item has been received and executed and
-
-   - item->verno matches the slot verno (as usual).
-
- Typical scenarios are as following:
-
-   - update operations are submitted, all with LAST dep, they are sent
-     over the network concurrently (up to slot->max_in_flight) and executed
-     serially by the receiver;
-
-   - an update item I0 is submitted, then a set of read-only items is submitted,
-     all with ->dep set to LAST. Read-only operations are sent concurrently and
-     executed concurrently after I0 has been executed.
-
- Note that LAST can be nicely generalized (we don't need this now): instead of
- distinguishing MUTABO and !MUTABO items, we split items into "commutative"
- groups such that items in a group can be executed in any order.
-
- <B> Using two identifiers for session and conn </B>
- @todo
- currently, receiver assigns identifiers to connections and sessions and
- these identifiers are used by both parties. What we can do, is to allow
- sender to assign identifiers to sessions (this identifier is sent in
- SESSION_ESTABLISH). Then, whenever receiver uses the session to send a
- reply, it uses this identifier (instead of receiver assigned session-id).
- The advantage of this, is that sender can use an identifier that allows
- quick lookup (e.g., an index in some session array or simply a pointer).
- Similarly for connections (i.e., another sender generated identifier in
- addition to uuid, that is not guaranteed to be globally unique)
-
-    @todo
-	- stats
-	- Generate ADDB data points for important session events
-	- UUID generation
-	- store replies in FOL
-	- Support more than one items in flight for a slot
-	- Optimization: Cache misordered items at receiver, rather than
-	  discarding them.
-	- How to get unique stob_id for session and slot cobs?
-	- slot table resize needs to be implemented.
-	- Design protocol to dynamically adjust number of slots.
-	- Session level timeout
-	- session can be terminated only if all items are pruned from all
-		slot->sl_item_list
-
- */
-
-#include "lib/list.h"
-#include "lib/chan.h"
-#include "lib/cond.h"
-#include "lib/mutex.h"
-#include "dtm/verno.h"
-
-/* Imports */
-struct c2_rpc_item;
-struct c2_rpcmachine;
-struct c2_rpc_chan;
-struct c2_net_end_point;
-
-/* Exports */
-struct c2_rpc_session;
-struct c2_rpc_conn;
-
-enum {
-	/** [conn|session]_[create|terminate] items go on session 0 */
-	SESSION_ID_0 = 0,
-	SESSION_ID_INVALID = UINT64_MAX,
-	/** Range of valid session ids */
-	SESSION_ID_MIN = SESSION_ID_0 + 1,
-	SESSION_ID_MAX = SESSION_ID_INVALID - 1,
-	SENDER_ID_INVALID = UINT64_MAX,
-	SLOT_ID_INVALID = UINT32_MAX,
-};
-
-/**
-   Requirements:
-   * UUID must change whenever a storage-less client re-boots.
-   * for a client with persistent state (e.g., a disk) uuid
-     must survive reboots.
- */
-struct c2_rpc_sender_uuid {
-	/** XXX Temporary */
-	uint64_t su_uuid;
-};
-
-/**
-   Possible rpc connection states.
-
-   Value of each state constant is taken to be a power of two so that it is
-   possible to specify multiple states (by ORing them) to
-   c2_rpc_conn_timedwait(), to wait until conn reaches in any one of the
-   specified states.
- */
-enum c2_rpc_conn_state {
-	/**
-	  All the fields of conn are initialised locally. But the connection
-	  is not yet established.
-	 */
-	C2_RPC_CONN_INITIALISED = (1 << 0),
-
-	/**
-	   When sender is waiting for receiver reply to get its sender ID it is
-	   in CONNECTING state.
-	 */
-	C2_RPC_CONN_CONNECTING = (1 << 1),
-
-	/**
-	   When initialization is successfull connection enters in ACTIVE state.
-	   It stays in this state for until termination.
-	 */
-	C2_RPC_CONN_ACTIVE = (1 << 2),
-
-	/**
-	   If conn init or terminate fails or time-outs connection enters in
-	   FAILED state. c2_rpc_conn::c_rc gives reason for failure.
-	*/
-	C2_RPC_CONN_FAILED = (1 << 3),
-
-	/**
-	   When sender calls c2_rpc_conn_terminate() on c2_rpc_conn object
-	   a FOP is sent to the receiver side to terminate the rpc connection.
-	   Until reply is received, c2_rpc_conn object stays in TERMINATING
-	   state
-	 */
-	C2_RPC_CONN_TERMINATING = (1 << 4),
-
-	/**
-	   When sender receives reply for conn_terminate FOP and reply FOP
-	   specifies the conn_terminate operation is successful then
-	   the object of c2_rpc_conn enters in TERMINATED state
-	 */
-	C2_RPC_CONN_TERMINATED = (1 << 5),
-};
-
-/**
-   RPC Connection flags
- */
-enum c2_rpc_conn_flags {
-	RCF_SENDER_END = 1 << 0,
-	RCF_RECV_END = 1 << 1
-};
-
-/**
-   A rpc connection identfies a sender to the receiver. It acts as a parent
-   object within which sessions are created. rpc connection has two
-   identifiers.
-
-   - UUID: Uniquely Identifies of the rpc connection globally within the
-           cluster. UUID is generated by sender.
-
-   - SenderID: A sender id is assigned by receiver. Sender Id uniquely
-               identifies a rpc connection on receiver side.
-               Same sender has different sender_id to communicate with
-               different receiver.
-
-   UUID being larger in size compared to SenderID, it is efficient to use
-   sender id to locate rpc connection object.
-
-   c2_rpcmachine maintains two lists of c2_rpc_conn
-   - cr_outgoing_conns: list of c2_rpc_conn objects for which this node is
-     sender
-   - cr_incoming_conns: list of c2_rpc_conn object for which this node is
-     receiver
-
-   Instance of c2_rpc_conn stores a list of all sessions currently active with
-   the service.
-
-   At the time of creation of a c2_rpc_conn, a "special" session with
-   SESSION_ID_0 is also created. It is special in the sense that it is
-   "hand-made" and there is no need to communicate to receiver in order to
-   create this session. Receiver assumes that there always exists a session 0
-   for each rpc connection.
-   Session 0 always have exactly 1 slot within it.
-   Receiver creates session 0 while creating the rpc connection itself.
-   Session 0 is required to send special fops like
-   - conn_establish or conn_terminate FOP
-   - session_establish or session_terminate FOP.
-
-   <B> State transition diagram: </B>
-
-   Note: There is no state named as "UNINITIALISED", it is in the state
-   diagram to specify "before initialisation" and "after finalisation" state,
-   and the contents of object are irrelevant and "unknown".
-
-   @verbatim
-   +-------------------------> UNINITIALISED
-         allocated               ^  |
-               c2_rpc_conn_fini()|  |  c2_rpc_conn_init()
-   c2_rpc_conn_establish() != 0  |  V
-         +---------------------INITIALISED
-         |                          |
-         |                          |  c2_rpc_conn_establish()
-         |                          |
-         |                          V
-         +---------------------- CONNECTING
-         | time-out ||              |
-         |     reply.rc != 0        | c2_rpc_conn_establish_reply_received() &&
-         |                          |    reply.rc == 0
-         V                          |
-       FAILED                       |
-         |  ^                       V
-         |  |                    ACTIVE
-         |  |                       |
-         |  |                       | c2_rpc_conn_terminate()
-         |  | failed || timeout     |
-         |  |                       V
-         |  +-------------------TERMINATING
-	 |                          |
-         |                          | c2_rpc_conn_terminate_reply_received() &&
-         |                          |              rc== 0
-	 |                          V
-	 |                      TERMINATED
-	 |                          |
-	 |                          |  c2_rpc_conn_fini()
-	 | c2_rpc_conn_fini()       V
-	 +--------------------> UNINITIALISED
-
-  @endverbatim
-
-  <B> Liveness and Concurrency: </B>
-  - Sender side allocation and deallocation of c2_rpc_conn object is
-    entirely handled by user (c2_rpc_conn object is not reference counted).
-  - On receiver side, user is not expected to allocate or deallocate
-    c2_rpc_conn objects explicitly.
-  - Receiver side c2_rpc_conn object will be instantiated in response to
-    rpc connection establish request and is deallocated while terminating the
-    rpc connection.
-  - User is not expected to take lock on c2_rpc_conn object. Session module
-    will internally synchronise access to c2_rpc_conn.
-  - c2_rpc_conn::c_mutex protects all but c_link fields of c2_rpc_conn.
-  - Locking order:
-    - slot->sl_mutex
-    - session->s_mutex
-    - conn->c_mutex
-    - rpcmachine->cr_session_mutex, rpcmachine->cr_ready_slots_mutex (As of
-      now, there is no case where these two mutex are held together. If such
-      need arises then ordering of these two mutex should be decided.)
-
-  <B> Typical sequence of API execution </B>
-  Note: error checking is omitted.
-
-  @code
-  // ALLOCATE CONN
-  struct c2_rpc_conn *conn;
-  C2_ALLOC_PTR(conn);
-
-  // INITIALISE CONN
-  rc = c2_rpc_conn_init(conn, tgt_end_point, rpcmachine);
-  C2_ASSERT(ergo(rc == 0, conn->c_state == C2_RPC_CONN_INITIALISED));
-
-  // ESTABLISH RPC CONNECTION
-  rc = c2_rpc_conn_establish(conn);
-
-  if (rc != 0) {
-	// some error occured. Cannot establish connection.
-        // handle the situation and return
-  }
-  // WAIT UNTIL CONNECTION IS ESTABLISHED
-  flag = c2_rpc_conn_timedwait(conn, C2_RPC_CONN_ACTIVE | C2_RPC_CONN_FAILED,
-				absolute_timeout);
-  if (flag) {
-	if (conn->c_state == C2_RPC_CONN_ACTIVE)
-		// connection is established and is ready to be used
-	ele
-		// connection establishing failed
-  } else {
-	// timeout
-  }
-  // Assuming connection is established.
-  // Create one or more sessions using this connection. @see c2_rpc_session
-
-  // TERMINATING CONNECTION
-  // Make sure that all the sessions that were created on this connection are
-  // terminated
-  C2_ASSERT(conn->c_nr_sessions == 0);
-
-  rc = c2_rpc_conn_terminate(conn);
-
-  // WAIT UNTIL CONNECTION IS TERMINATED
-  flag = c2_rpc_conn_timedwait(conn, C2_RPC_CONN_TERMINATED |
-				C2_RPC_CONN_FAILED, absolute_timeout);
-  if (flag) {
-	if (conn->c_state == C2_RPC_CONN_TERMINATED)
-		// conn is successfully terminated
-	else
-		// conn terminate has failed
-  } else {
-	// timeout
-  }
-  // assuming conn is terminated
-  c2_rpc_conn_fini(conn);
-  c2_free(conn);
-
-  @endcode
-
-  On receiver side, user is not expected to call any of these APIs.
-  Receiver side rpc-layer will internally allocate/deallocate and manage
-  all the state transitions of conn internally.
- */
-struct c2_rpc_conn {
-	/** Sender ID unique on receiver */
-	uint64_t                  c_sender_id;
-
-	/** Globally unique ID of rpc connection */
-	struct c2_rpc_sender_uuid c_uuid;
-
-	/** Current state of rpc connection */
-	enum c2_rpc_conn_state    c_state;
-
-	/** @see c2_rpc_conn_flags for list of flags */
-	uint64_t                  c_flags;
-
-	/** rpcmachine with which this conn is associated */
-	struct c2_rpcmachine     *c_rpcmachine;
-
-	/** list_link to put c2_rpc_conn in either
-	    c2_rpcmachine::cr_incoming_conns or
-	    c2_rpcmachine::cr_outgoing_conns
-	 */
-	struct c2_list_link       c_link;
-
-	/** Counts number of sessions (excluding session 0) */
-	uint64_t                  c_nr_sessions;
-
-	/** List of all the sessions created under this rpc connection.
-	    c2_rpc_session objects are placed in this list using
-	    c2_rpc_session::s_link
-	 */
-	struct c2_list            c_sessions;
-
-	/** if c_state == C2_RPC_CONN_FAILED then c_rc contains error code */
-	int32_t                   c_rc;
-
-	/** A c2_rpc_chan structure that will point to the transfer
-	    machine used by this c2_rpc_conn.
-	 */
-	struct c2_rpc_chan       *c_rpcchan;
-
-	/** cob representing the connection */
-	struct c2_cob            *c_cob;
-
-	/** Conditional variable on which "connection state changed" signal
-	    is broadcast
-	 */
-	struct c2_cond            c_state_changed;
-
-	struct c2_mutex           c_mutex;
-};
-
-/**
-   Initialises @conn object and associates it with @machine.
-   No network communication is involved.
-
-   Note: c2_rpc_conn_init() can fail with -ENOMEM, -EINVAL.
-	 if c2_rpc_conn_init() fails, conn is left in undefined state.
-
-   @pre conn != NULL && ep != NULL && machine != NULL
-   @post ergo(rc == 0, conn->c_state == C2_RPC_CONN_INITIALISED &&
-			conn->c_machine == machine &&
-			conn->c_sender_id == SENDER_ID_INVALID &&
-			(conn->c_flags & RCF_SENDER_END) != 0)
- */
-int c2_rpc_conn_init(struct c2_rpc_conn      *conn,
-		     struct c2_net_end_point *ep,
-		     struct c2_rpcmachine    *machine,
-		     uint64_t max_rpcs_in_flight);
-
-/**
-    Sends handshake CONN_ESTABLISH fop to the remote end.
-    When reply to CONN_ESTABLISH is received,
-    c2_rpc_conn_establish_reply_received() is called.
-
-    @pre conn->c_state == C2_RPC_CONN_INITIALISED
-    @post ergo(result != 0, conn->c_state == C2_RPC_CONN_FAILED)
- */
-int c2_rpc_conn_establish(struct c2_rpc_conn *conn);
-
-/**
- * Same as c2_rpc_conn_establish(), but in addition uses c2_rpc_conn_timedwait()
- * to ensure that connection is in active state after c2_rpc_conn_establish()
- * call.
- *
- * @param conn        A connection object to operate on.
- * @param timeout_sec How much time in seconds to wait for connection
- *                    to become active.
- *
- * @pre  conn->c_state == C2_RPC_CONN_INITIALISED
- * @post conn->c_state == C2_RPC_CONN_ACTIVE
- */
-int c2_rpc_conn_establish_sync(struct c2_rpc_conn *conn, uint32_t timeout_sec);
-
-/**
- * A combination of c2_rpc_conn_init() and c2_rpc_conn_establish_sync() in a
- * single routine - initialize connection object, establish a connection and
- * wait until it become active.
- */
-int c2_rpc_conn_create(struct c2_rpc_conn      *conn,
-		       struct c2_net_end_point *ep,
-		       struct c2_rpcmachine    *rpc_machine,
-		       uint64_t			max_rpcs_in_flight,
-		       uint32_t			timeout_sec);
-
-/**
-   Sends "conn_terminate" FOP to receiver.
-   c2_rpc_conn_terminate() is a no-op if @conn is already in TERMINATING
-   state.
-   c2_rpc_conn_terminate_reply_received() is called when reply to
-   CONN_TERMINATE is received.
-
-   @pre (conn->c_state == C2_RPC_CONN_ACTIVE && conn->c_nr_sessions == 0) ||
-		conn->c_state == C2_RPC_CONN_TERMINATING
-   @post ergo(rc != 0, conn->c_state == C2_RPC_CONN_FAILED)
- */
-int c2_rpc_conn_terminate(struct c2_rpc_conn *conn);
-
-/**
- * Same as c2_rpc_conn_terminate(), but in addition uses c2_rpc_conn_timedwait()
- * to ensure that connection is in terminated state after c2_rpc_conn_terminate()
- * call.
- *
- * @param conn        A connection object to operate on.
- * @param timeout_sec How much time in seconds to wait for connection
- *                    to become terminated.
- *
- * @pre (conn->c_state == C2_RPC_CONN_ACTIVE && conn->c_nr_sessions == 0) ||
- *       conn->c_state == C2_RPC_CONN_TERMINATING
- * @post conn->c_state == C2_RPC_CONN_TERMINATED
- */
-int c2_rpc_conn_terminate_sync(struct c2_rpc_conn *conn, uint32_t timeout_sec);
-
-/**
-   Finalises c2_rpc_conn.
-   No network communication involved.
-   @pre conn->c_state == C2_RPC_CONN_FAILED ||
-	conn->c_state == C2_RPC_CONN_INITIALISED ||
-	conn->c_state == C2_RPC_CONN_TERMINATED
- */
-void c2_rpc_conn_fini(struct c2_rpc_conn *conn);
-
-/**
- * A combination of c2_rpc_conn_terminate_sync() and c2_rpc_conn_fini() in a
- * single routine - terminate the connection, wait until it switched to
- * terminated state and finalize connection object.
- */
-int c2_rpc_conn_destroy(struct c2_rpc_conn *conn, uint32_t timeout_sec);
-
-/**
-    Waits until @conn reaches in any one of states specified by @state_flags.
-    @param state_flags can specify multiple states by ORing
-
-    @param abs_timeout should not sleep past abs_timeout waiting for conn
-		to reach in desired state.
-    @return true if @conn reaches in one of the state(s) specified by
-                @state_flags
-    @return false if time out has occured before @conn reaches in desired
-                state.
- */
-bool c2_rpc_conn_timedwait(struct c2_rpc_conn *conn,
-			   uint64_t            state_flags,
-			   const c2_time_t     abs_timeout);
-
-/**
-   checks internal consistency of @conn.
- */
-bool c2_rpc_conn_invariant(const struct c2_rpc_conn *conn);
-
-/**
-   Possible states of a session object
-
-   Value of each state constant is taken to be a power of 2 so that it is
-   possible to specify multiple states (by ORing them) to
-   c2_rpc_session_timedwait(), to wait until session reaches in any one of the
-   specified states.
- */
-enum c2_rpc_session_state {
-	/**
-	   all lists, mutex and channels of session are initialised.
-	   No actual session is established with any end point
-	 */
-	C2_RPC_SESSION_INITIALISED = (1 << 0),
-	/**
-	   When sender sends a SESSION_ESTABLISH FOP to reciever it
-	   is in CREATING state
-	 */
-	C2_RPC_SESSION_ESTABLISHING = (1 << 1),
-	/**
-	   A session is IDLE if both of following is true
-		- for each slot S in session
-			for each item I in S->item_list
-				// I has got reply
-				I->state is in {PAST_COMMITTED, PAST_VOLATILE}
-		- session->unbound_items list is empty
-	   A session can be terminated only if it is IDLE.
-	 */
-	C2_RPC_SESSION_IDLE = (1 << 2),
-	/**
-	   A session is busy if any of following is true
-		- Any of slots has item to be sent (FUTURE items)
-		- Any of slots has item for which reply is not received
-			(IN_PROGRESS items)
-		- unbound_items list is not empty
-	 */
-	C2_RPC_SESSION_BUSY = (1 << 3),
-	/**
-	   Creation/termination of session failed
-	 */
-	C2_RPC_SESSION_FAILED = (1 << 4),
-	/**
-	   When sender sends SESSION_TERMINATE fop to receiver and is waiting
-	   for reply, then it is in state TERMINATING.
-	*/
-	C2_RPC_SESSION_TERMINATING = (1 << 5),
-	/**
-	   When sender gets reply to session_terminate fop and reply informs
-	   the session termination is successful then the session enters in
-	   TERMINATED state
-	 */
-	C2_RPC_SESSION_TERMINATED = (1 << 6)
-};
-
-/**
-   Rpc connection can be shared by multiple entities (e.g. users) by
-   creating their own "session" on the connection.
-   A session can be used to maintain authentication information or QoS
-   parameters. But currently it is just a container for slots.
-
-   <B> Liveness: </B>
-
-   On sender side, allocation and deallocation of c2_rpc_session is entirely
-   managed by user except for SESSION 0. SESSION 0 is allocated and deallocated
-   by rpc-layer internally along with c2_rpc_conn.
-   @see c2_rpc_conn for more information on creation and use of SESSION 0.
-
-   On receiver side, c2_rpc_session object will be allocated and deallocated
-   by rpc-layer internally, in response to session create and session terminate
-   requests respectively.
-
-   <B> Concurrency:</B>
-
-   Users of rpc-layer are never expected to take lock on session. Rpc layer
-   will internally synchronise access to c2_rpc_session.
-
-   c2_rpc_session::s_mutex protects all fields except s_link. s_link is
-   protected by session->s_conn->c_mutex.
-
-   There is no need to take session->s_mutex while posting item on the session.`
-   When session is in one of UNINITIALISED, INITIALISED, TERMINATED and
-   FAILED state, user is expected to serialise access to the session object.
-   (It is assumed that session in one of {UNINITIALISED, INITIALISED,
-   TERMINATED, FAILED} state, very likely does not have concurrent users).
-
-   Locking order:
-    - slot->sl_mutex
-    - session->s_mutex
-    - conn->c_mutex
-    - rpcmachine->cr_session_mutex, rpcmachine->cr_ready_slots_mutex (As of
-      now, there is no case where these two mutex are held together. If such
-      need arises then ordering of these two mutex should be decided.)
-
-   @verbatim
-
-            +------------------> UNINITIALISED
-                 allocated         ^   |
-                            fini() |   |  c2_rpc_session_init()
-  c2_rpc_session_establish() != 0  |   V
-          +----------------------INITIALISED
-          |                           |
-          |                           | c2_rpc_session_establish()
-          |                           |
-          |     timed-out             V
-          +-----------------------ESTABLISHING
-	  |   create_failed           | create successful/n = 0
-	  V                           |
-	FAILED <------+               |   n == 0 && list_empty(unbound_items)
-	  |           |               +-----------------+
-	  |           |               |                 | +-----+
-	  |           |failed         |                 | |     | item add/n++
-	  |           |               V  item add/n++   | V     | reply rcvd/n--
-	  |           +-------------IDLE--------------->BUSY----+
-	  |           |               |
-	  | fini()    |               | c2_rpc_session_terminate()
-	  |           |               V
-	  |           +----------TERMINATING
-	  |                           |
-	  |                           |
-	  |                           |
-	  |                           |session_terminated
-	  |                           V
-	  |                       TERMINATED
-	  |                           |
-	  |                           | fini()
-	  |                           V
-	  +----------------------> UNINITIALISED
-
-   @endverbatim
-
-   Typical sequence of execution of APIs on sender side. Error checking is
-   omitted.
-
-   @code
-
-   // ALLOCATE SESSION
-
-   struct c2_rpc_session *session;
-   C2_ALLOC_PTR(session);
-
-   // INITIALISE SESSION
-
-   nr_slots = 4;
-   rc = c2_rpc_session_init(session, conn, nr_slots);
-   C2_ASSERT(ergo(rc == 0, session->s_state == C2_RPC_SESSION_INITIALISED));
-
-   // ESTABLISH SESSION
-
-   rc = c2_rpc_session_establish(session);
-
-   flag = c2_rpc_session_timedwait(session, C2_RPC_SESSION_IDLE |
-					C2_RPC_SESSION_FAILED, timeout);
-
-   if (flag && session->s_state == C2_RPC_SESSION_IDLE) {
-	// Session is successfully established
-   } else {
-	// timeout has happend or session establish failed
-   }
-
-   // Assuming session is successfully established.
-   // post unbound items using c2_rpc_post(item)
-
-   item->ri_session = session;
-   item->ri_prio = C2_RPC_ITEM_PRIO_MAX;
-   item->ri_deadline = absolute_time;
-   item->ri_ops = item_ops;   // item_ops contains ->replied() callback which
-			      // will be called when reply to this item is
-			      // received. DO NOT FREE THIS ITEM.
-
-   // TERMINATING SESSION
-   // Wait until all the items that were posted on this session, are sent and
-   // for all those items either reply is received or reply_timeout has
-   // triggered.
-   flag = c2_rpc_session_timedwait(session, C2_RPC_SESSION_IDLE, timeout);
-   if (flag) {
-	C2_ASSERT(session->s_state == C2_RPC_SESSION_IDLE);
-	rc = c2_rpc_session_terminate(session);
-
-	// Wait until session is terminated.
-	flag1 = c2_rpc_session_timedwait(session, C2_RPC_SESSION_TERMINATED |
-					C2_RPC_SESSION_FAILED, timeout);
-	C2_ASSERT(ergo(flag1, session->s_state == C2_RPC_SESSION_TERMINATED ||
-			session->s_state == C2_RPC_SESSION_FAILED));
-   }
-
-   // FINALISE SESSION
-
-   c2_rpc_session_fini(session);
-   c2_free(session);
-   @endcode
-
-   Receiver is not expected to call any of these APIs. Receiver side session
-   structures will be set-up while handling fops \
-   c2_rpc_fop_[conn|session]_[establish|terminate].
-
-   When receiver needs to post reply, it uses c2_rpc_reply_post().
-
-   @code
-   c2_rpc_reply_post(request_item, reply_item);
-   @endcode
-
-   c2_rpc_reply_post() will copy all the session related information from
-   request item to reply item and process reply item.
-
-   Note: rpc connection is a two-way communication channel. There are requests
-   and corresponding reply items, on the same connection. Receiver NEED NOT
-   have to establish other separate connection with sender, to be able to
-   send replies.
- */
-struct c2_rpc_session {
-	/** identifies a particular session. Unique in all sessions belonging
-	    to same c2_rpc_conn
-	 */
-	uint64_t                  s_session_id;
-
-	/** Current state of session */
-	enum c2_rpc_session_state s_state;
-
-	/** rpc connection on which this session is created */
-	struct c2_rpc_conn       *s_conn;
-
-	/** linkage into list of all sessions within a c2_rpc_conn */
-	struct c2_list_link       s_link;
-
-	/** Cob representing this session in persistent state */
-	struct c2_cob            *s_cob;
-
-	/** Number of items that needs to be sent or their reply is
-	    not yet received. i.e. count of items in {FUTURE, IN_PROGRESS}
-	    state in all slots belonging to this session.
-	 */
-	int32_t                   s_nr_active_items;
-
-	/** list of items that can be sent through any available slot.
-	    items are placed using c2_rpc_item::ri_unbound_link
-	 */
-	struct c2_list            s_unbound_items;
-
-	/** Capacity of slot table */
-	uint32_t                  s_slot_table_capacity;
-
-	/** Only [0, s_nr_slots) slots from the s_slot_table can be used to
-            bind items. s_nr_slots <= s_slot_table_capacity
-	 */
-	uint32_t                  s_nr_slots;
-
-	/** Array of pointers to slots */
-	struct c2_rpc_slot      **s_slot_table;
-
-	/** if s_state == C2_RPC_SESSION_FAILED then s_rc contains error code
-		denoting cause of failure
-	 */
-	int32_t                   s_rc;
-
-	/** lock protecting this session and slot table */
-	struct c2_mutex           s_mutex;
-
-	/** A condition variable on which broadcast is sent whenever state of
-	    session is changed. Associated with s_mutex
-	 */
-	struct c2_cond            s_state_changed;
-};
-
-/**
-   Initialises all fields of session. Allocates and initialises
-   nr_slots number of slots.
-   No network communication is involved.
-
-   @param session session being initialised
-   @param conn rpc connection with which this session is associated
-   @param nr_slots number of slots in the session
-
-   @post ergo(rc == 0, session->s_state == C2_RPC_SESSION_INITIALISED &&
-		       session->s_conn == conn &&
-		       session->s_session_id == SESSION_ID_INVALID)
- */
-int c2_rpc_session_init(struct c2_rpc_session *session,
-			struct c2_rpc_conn    *conn,
-			uint32_t               nr_slots);
-
-/**
-    Sends a SESSION_ESTABLISH fop across pre-defined session-0 in
-    session->s_conn.
-    c2_rpc_session_establish_reply_received() is called when reply to
-    SESSION_ESTABLISH fop is received.
-
-    @pre session->s_state == C2_RPC_SESSION_INITIALISED
-    @pre session->s_conn->c_state == C2_RPC_CONN_ACTIVE
-    @post ergo(result != 0, session->s_state == C2_RPC_SESSION_FAILED)
- */
-int c2_rpc_session_establish(struct c2_rpc_session *session);
-
-/**
- * Same as c2_rpc_session_establish(), but in addition uses
- * c2_rpc_session_timedwait() to ensure that session is in idle state after
- * c2_rpc_session_establish() call.
- *
- * @param session     A session object to operate on.
- * @param timeout_sec How much time in seconds to wait for session to become idle.
- *
- * @pre  session->s_state == C2_RPC_SESSION_INITIALISED
- * @pre  session->s_conn->c_state == C2_RPC_CONN_ACTIVE
- * @post session->s_state == C2_RPC_SESSION_IDLE
- */
-int c2_rpc_session_establish_sync(struct c2_rpc_session *session,
-				  uint32_t timeout_sec);
-
-/**
- * A combination of c2_rpc_session_init() and c2_rpc_session_establish_sync() in
- * a single routine - initialize session object, establish a session and wait
- * until it become idle.
- */
-int c2_rpc_session_create(struct c2_rpc_session *session,
-			  struct c2_rpc_conn    *conn,
-			  uint32_t               nr_slots,
-			  uint32_t               timeout_sec);
-
-/**
-   Sends terminate session fop to receiver.
-   Acts as no-op if session is already in TERMINATING state.
-   c2_rpc_session_terminate_reply_received() is called when reply to
-   CONN_TERMINATE fop is received.
-
-   @pre session->s_state == C2_RPC_SESSION_IDLE ||
-	session->s_state == C2_RPC_SESSION_TERMINATING
-   @post ergo(rc != 0, session->s_state == C2_RPC_SESSION_FAILED)
- */
-int c2_rpc_session_terminate(struct c2_rpc_session *session);
-
-/**
- * Same as c2_rpc_session_terminate(), but in addition uses
- * c2_rpc_session_timedwait() to ensure that session is in terminated state
- * after c2_rpc_session_terminate() call.
- *
- * @param session     A session object to operate on.
- * @param timeout_sec How much time in seconds to wait for session to become
- *                    terminated.
- *
- * @pre (session->s_state == C2_RPC_SESSION_IDLE ||
- *       session->s_state == C2_RPC_SESSION_TERMINATING)
- * @post session->s_state == C2_RPC_SESSION_TERMINATED
- */
-int c2_rpc_session_terminate_sync(struct c2_rpc_session *session,
-				  uint32_t timeout_sec);
-
-/**
-    Waits until @session object reaches in one of states given by @state_flags.
-
-    @param state_flags can specify multiple states by ORing
-    @param abs_timeout thread does not sleep past abs_timeout waiting for conn
-		to reach in desired state.
-    @return true if session reaches in one of the state(s) specified by
-		@state_flags
-    @return false if time out has occured before session reaches in desired
-		state.
- */
-bool c2_rpc_session_timedwait(struct c2_rpc_session *session,
-			      uint64_t               state_flags,
-			      const c2_time_t        abs_timeout);
-
-/**
-   Finalises session object
-
-   @pre session->s_state == C2_RPC_SESSION_TERMINATED ||
-	session->s_state == C2_RPC_SESSION_FAILED ||
-	session->s_state == C2_RPC_SESSION_INITIALISED
- */
-void c2_rpc_session_fini(struct c2_rpc_session *session);
-
-/**
- * A combination of c2_rpc_session_terminate_sync() and c2_rpc_session_fini() in
- * a single routine - terminate the session, wait until it switched to
- * terminated state and finalize session object.
- */
-int c2_rpc_session_destroy(struct c2_rpc_session *session, uint32_t timeout_sec);
-
-/**
-   Returns the number of rpc items that can be bound to this slot
-   staying within SLOT_DEFAULT_MAX_IN_FLIGHT limit.
-   @param slot - Input c2_rpc_slot
-   @retval - Number of items that can be bound to this slot.
-   XXX Need a better name.
- */
-uint32_t c2_rpc_slot_items_possible_inflight(struct c2_rpc_slot *slot);
-
-/**
-  In memory slot object.
-
-  A slot provides the FIFO and exactly once semantics for item delivery.
-  c2_rpc_slot and its corresponding methods are equally valid on sender and
-  receiver side.
-
-  One can think of a slot as a pipe. On sender side, application/formation is
-  placing items at one end of this pipe. The item appears on the other end
-  of pipe. And formation takes the item, packs in some RPC, and sends it.
-
-  On receiver side, when an item is received it is placed in one end of the
-  pipe. When the item appears on other end of pipe it is sent for execution.
-
-  With a slot a list of items, ordered by verno is associated. An item on
-  the list is in one of the following states:
-
-  - past committed: the reply for the item was received and the receiver
-    confirmed that the item is persistent. Items can linger for some time
-    in this state, because distributed transaction recovery requires keeping
-    items in memory after they become persistent on the receiver;
-
-  - past volatile: the reply was received, but persistence confirmation wasn't;
-
-  - unreplied: the item was sent (i.e., placed into an rpc) and no reply is
-    received. We are usually talking about a situations where there is at
-    most a single item in this state, but it is not, strictly speaking,
-    necessary. More than a single item can be in flight per-slot.;
-
-  - future: the item wasn't sent.
-
-  An item can be linked into multiple slots (similar to c2_fol_obj_ref).
-  For each slot the item has a separate verno and separate linkage into
-  the slot's item list. Item state is common for all slots;
-
-  An item, has a MUTABO flag, which is set when the item is an update
-  (i.e., changes the file system state). When the item is an update then
-  (for each slot the item is in) its verno is greater than the verno of
-  the previous item on the slot's item list. Multiple consecutive non-MUTABO
-  items (i.e., read-only queries) can have the same verno;
-
-  With each item a (pointer to) reply is associated. This pointer is set
-  once the reply is received for the item;
-
-  A slot has a number of pointers into this list and other fields,
-  described below:
-
-  - last_sent
-  pointer usually points to the latest unreplied request. When the
-  receiver fails and restarts, the last_sent pointer is shifted back to the
-  item from which the recovery must continue.
-  Note that last_sent might be moved all the way back to the oldest item;
-
-  - last_persistent
-  last_persistent item points to item whose effects have reached to persistent
-  storage.
-
-  A slot state machine reacts to the following events:
-  [ITEM ADD]: a new item is added to the future list;
-  [REPLY RECEIVED]: a reply is received for an item;
-  [PERSISTENCE]: the receiver notified the sender about the change in the
-  last persistent item;
-  [RESET]: last_sent is reset back due to the receiver restart.
-
-  Note that slot.in_flight not necessary equals the number of unreplied items:
-  during recovery items from the past parts of the list are replayed.
-
-  Also note, that the item list might be empty. To avoid special cases with
-  last_sent pointer, let's prepend a special dummy item with an impossibly
-  low verno to the list.
-
-  For each slot, a configuration parameter slot.max_in_flight is defined.
-  This parameter is set to 1 to obtain a "standard" slot behaviour, where no
-  more than single item is in flight.
-
-  When an update item (one that modifies file-system state) is added to the
-  slot, it advances version number of slot.
-  The verno.vn_vc is set to 0 at the time of slot creation on both ends.
-
-  <B> Liveness and concurreny </B>
-  Slots are allocated at the time of session initialisation and freed at the
-  time of session finalisation.
-  c2_rpc_slot::sl_mutex protects all fields of slot except sl_link.
-  sl_link is protected by c2_rpcmachine::cr_ready_slots_mutex.
-
-  Locking order:
-    - slot->sl_mutex
-    - session->s_mutex
-    - conn->c_mutex
-    - rpcmachine->cr_session_mutex, rpcmachine->cr_ready_slots_mutex (As of
-      now, there is no case where these two mutex are held together. If such
-      need arises then ordering of these two mutex should be decided.)
- */
-struct c2_rpc_slot {
-	/** Session to which this slot belongs */
-	struct c2_rpc_session        *sl_session;
-
-	/** identifier of slot, unique within the session */
-	uint32_t                      sl_slot_id;
-
-	/** Cob representing this slot in persistent state */
-	struct c2_cob                *sl_cob;
-
-	/** list anchor to put in c2_rpcmachine::cr_ready_slots */
-	struct c2_list_link           sl_link;
-
-	/** Current version number of slot */
-	struct c2_verno               sl_verno;
-
-	/** slot generation */
-	uint64_t                      sl_slot_gen;
-
-	/** A monotonically increasing sequence counter, assigned to an item
-	    when it is bound to the slot
-	 */
-	uint64_t                      sl_xid;
-
-	/** List of items, starting from oldest. Items are placed using
-	    c2_rpc_item::ri_slot_refs[0].sr_link
-	 */
-	struct c2_list                sl_item_list;
-
-	/** earliest item that the receiver possibly have seen */
-	struct c2_rpc_item           *sl_last_sent;
-
-	/** item that is most recently persistent on receiver */
-	struct c2_rpc_item           *sl_last_persistent;
-
-	/** On sender: Number of items in flight
-	    On receiver: Number of items submitted for execution but whose
-	    reply is not yet received.
-	 */
-	uint32_t                      sl_in_flight;
-
-	/** Maximum number of items that can be in flight on this slot.
-	    @see SLOT_DEFAULT_MAX_IN_FLIGHT */
-	uint32_t                      sl_max_in_flight;
-
-	/** List of items ready to put in rpc. Items are placed in this
-	    list using c2_rpc_item::ri_slot_refs[0].sr_ready_link
-	 */
-	struct c2_list                sl_ready_list;
-
-	const struct c2_rpc_slot_ops *sl_ops;
-
-	struct c2_mutex               sl_mutex;
-};
-
-/** @} end of session group */
+*/
 
 #endif
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
diff --git a/rpc/session_foms.c b/rpc/session_foms.c
deleted file mode 100644
index 027bd32..0000000
--- a/rpc/session_foms.c
+++ /dev/null
@@ -1,556 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Rohan Puri <Rohan_Puri@xyratex.com>,
- *                  Amit Jambure <Amit_Jambure@xyratex.com>
- * Original creation date: 04/15/2011
- */
-
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif
-
-#include "fop/fop.h"
-#include "rpc/session_foms.h"
-#include "rpc/session_fops.h"
-#include "stob/stob.h"
-#include "lib/errno.h"
-#include "lib/memory.h"
-#include "lib/misc.h"
-#include "net/net.h"
-
-#ifdef __KERNEL__
-#include "rpc/session_k.h"
-#else
-#include "rpc/session_u.h"
-#endif
-
-#include "fop/fop_format_def.h"
-#include "rpc/session_internal.h"
-
-/**
-   @addtogroup rpc_session
-
-   @{
-
-   Definitions of foms that execute conn establish, conn terminate, session
-   establish and session terminate fops.
- */
-
-extern void item_exit_stats_set(struct c2_rpc_item   *item,
-				enum c2_rpc_item_path path);
-
-/**
-   Common implementation of c2_fom::fo_ops::fo_fini() for conn establish,
-   conn terminate, session establish and session terminate foms
-
-   @see session_gen_fom_create
- */
-static void session_gen_fom_fini(struct c2_fom *fom)
-{
-	c2_fom_fini(fom);
-	c2_free(fom);
-}
-
-/**
-   implementation of fop->f_type->ft_fom_type.ft_ops->fto_create for
-   conn establish, conn terminate, session establish,
-   session terminate fop types.
- */
-static int session_gen_fom_create(struct c2_fop *fop, struct c2_fom **m)
-{
-	const struct c2_fom_ops *fom_ops;
-	struct c2_fom           *fom;
-	struct c2_fop_type      *reply_fopt;
-	struct c2_fop           *reply_fop;
-	int                      rc;
-
-	C2_ALLOC_PTR(fom);
-	if (fom == NULL)
-		return -ENOMEM;
-
-	if (fop->f_type == &c2_rpc_fop_conn_establish_fopt) {
-
-		reply_fopt = &c2_rpc_fop_conn_establish_rep_fopt;
-		fom_ops = &c2_rpc_fom_conn_establish_ops;
-
-	} else if (fop->f_type == &c2_rpc_fop_conn_terminate_fopt) {
-
-		reply_fopt = &c2_rpc_fop_conn_terminate_rep_fopt;
-		fom_ops = &c2_rpc_fom_conn_terminate_ops;
-
-	} else if (fop->f_type == &c2_rpc_fop_session_establish_fopt) {
-
-		reply_fopt = &c2_rpc_fop_session_establish_rep_fopt;
-		fom_ops = &c2_rpc_fom_session_establish_ops;
-
-	} else if (fop->f_type == &c2_rpc_fop_session_terminate_fopt) {
-
-		reply_fopt = &c2_rpc_fop_session_terminate_rep_fopt;
-		fom_ops = &c2_rpc_fom_session_terminate_ops;
-
-	} else {
-		reply_fopt = NULL;
-		fom_ops = NULL;
-	}
-
-	if (reply_fopt == NULL || fom_ops == NULL) {
-		rc = -EINVAL;
-		goto out;
-	}
-
-	reply_fop = c2_fop_alloc(reply_fopt, NULL);
-	if (reply_fop == NULL) {
-		rc = -ENOMEM;
-		goto out;
-	}
-
-	c2_fom_create(fom, &fop->f_type->ft_fom_type, fom_ops, fop, reply_fop);
-	*m = fom;
-	rc = 0;
-
-out:
-	if (rc != 0) {
-		c2_free(fom);
-		*m = NULL;
-	}
-	return rc;
-}
-
-const struct c2_fom_ops c2_rpc_fom_conn_establish_ops = {
-	.fo_fini = session_gen_fom_fini,
-	.fo_state = c2_rpc_fom_conn_establish_state,
-	.fo_home_locality = c2_rpc_session_default_home_locality
-};
-
-static struct c2_fom_type_ops c2_rpc_fom_conn_establish_type_ops = {
-	.fto_create = session_gen_fom_create
-};
-
-struct c2_fom_type c2_rpc_fom_conn_establish_type = {
-	.ft_ops = &c2_rpc_fom_conn_establish_type_ops
-};
-
-size_t c2_rpc_session_default_home_locality(const struct c2_fom *fom)
-{
-	C2_PRE(fom != NULL);
-
-	return fom->fo_fop->f_type->ft_rpc_item_type.rit_opcode;
-}
-
-int c2_rpc_fom_conn_establish_state(struct c2_fom *fom)
-{
-	struct c2_rpc_fop_conn_establish_rep *reply;
-	struct c2_rpc_fop_conn_establish_ctx *ctx;
-	struct c2_rpc_fop_conn_establish     *request;
-	struct c2_fop                        *fop;
-	struct c2_fop                        *fop_rep;
-	struct c2_rpc_item                   *item;
-	struct c2_rpc_session                *session0;
-	struct c2_rpc_conn                   *conn;
-	struct c2_rpc_slot                   *slot;
-	int                                   rc;
-
-	C2_PRE(fom != NULL);
-	C2_PRE(fom->fo_fop != NULL && fom->fo_rep_fop != NULL);
-
-	/* Request fop */
-	fop = fom->fo_fop;
-	request = c2_fop_data(fop);
-	C2_ASSERT(request != NULL);
-
-	/* reply fop */
-	fop_rep = fom->fo_rep_fop;
-	reply = c2_fop_data(fop_rep);
-	C2_ASSERT(reply != NULL);
-
-	item = &fop->f_item;
-
-	/*
-	 * On receiver side CONN_ESTABLISH fop is wrapped in
-	 * c2_rpc_fop_conn_etablish_ctx object.
-	 * See conn_establish_item_decode()
-	 */
-	ctx = container_of(fop, struct c2_rpc_fop_conn_establish_ctx, cec_fop);
-	C2_ASSERT(ctx != NULL && ctx->cec_sender_ep != NULL &&
-				 ctx->cec_rpcmachine != NULL);
-
-	C2_ALLOC_PTR(conn);
-	if (conn == NULL) {
-		rc = -ENOMEM;
-		goto out;
-	}
-
-	rc = c2_rpc_rcv_conn_init(conn, ctx->cec_sender_ep,
-				  ctx->cec_rpcmachine,
-				  &item->ri_slot_refs[0].sr_uuid);
-	/* we won't need ctx->cec_sender_ep after this point */
-	c2_net_end_point_put(ctx->cec_sender_ep);
-	if (rc != 0)
-		goto out_free;
-
-	rc = c2_rpc_rcv_conn_establish(conn);
-	if (rc != 0) {
-		C2_ASSERT(conn->c_state == C2_RPC_CONN_FAILED);
-		goto out_fini;
-	}
-
-	/*
-	 * As CONN_ESTABLISH request is directly submitted for execution.
-	 * Add the item explicitly to the slot0. This makes the slot
-	 * symmetric to corresponding sender side slot.
-	 */
-	c2_mutex_lock(&conn->c_mutex);
-	session0 = c2_rpc_conn_session0(conn);
-	c2_mutex_unlock(&conn->c_mutex);
-
-	item->ri_session = session0;
-	slot = session0->s_slot_table[0];
-	C2_ASSERT(slot != NULL);
-
-	c2_mutex_lock(&slot->sl_mutex);
-	c2_mutex_lock(&session0->s_mutex);
-
-	c2_rpc_slot_item_add_internal(slot, item);
-
-	c2_mutex_unlock(&session0->s_mutex);
-	c2_mutex_unlock(&slot->sl_mutex);
-
-	/*
-	 * IMPORTANT
-	 * Following line is required. Request item has SENDER_ID_INVALID.
-	 * slot_item_add_internal() overwrites it with conn->c_sender_id.
-	 * But we want reply to have sender_id SENDER_ID_INVALID.
-	 * c2_rpc_reply_post() simply copies sender id from req item to
-	 * reply item as it is. So set sender id of request item
-	 * to SENDER_ID_INVALID
-	 */
-	item->ri_slot_refs[0].sr_sender_id = SENDER_ID_INVALID;
-
-	/*
-	 * CONN_ESTABLISH item is directly submitted for execution. Update
-	 * rpc-layer stats on INCOMING path here.
-	 */
-	item_exit_stats_set(item, C2_RPC_PATH_INCOMING);
-
-	C2_ASSERT(conn->c_state == C2_RPC_CONN_ACTIVE);
-	reply->rcer_sender_id = conn->c_sender_id;
-	reply->rcer_rc = 0;      /* successful */
-	fom->fo_phase = FOPH_FINISH;
-
-	c2_rpc_reply_post(&fop->f_item, &fop_rep->f_item);
-	return FSO_WAIT;
-
-out_fini:
-	C2_ASSERT(conn != NULL && rc != 0);
-	c2_rpc_conn_fini(conn);
-
-out_free:
-	C2_ASSERT(conn != NULL);
-	c2_free(conn);
-
-out:
-	c2_fop_fini(&ctx->cec_fop); /* CONN_ESTABLISH fop */
-	c2_free(ctx);
-
-	/*
-	 * IMPORTANT: No reply is sent if conn establishing is failed.
-	 *
-	 * ACTIVE session is required to send reply. In case of, successful
-	 * conn establish operation, there is ACTIVE SESSION_0 and slot 0
-	 * (in the newly established ACTIVE conn) to send reply.
-	 *
-	 * But there is no SESSION_0 (in fact here is no conn object) if
-	 * conn establish operation is failed. Hence reply cannot be sent.
-	 *
-	 * In this case, sender will time-out and mark sender side conn
-	 * as FAILED.
-	 */
-	fom->fo_phase = FOPH_FINISH;
-	return FSO_WAIT;
-}
-
-/*
- * FOM session create
- */
-
-const struct c2_fom_ops c2_rpc_fom_session_establish_ops = {
-	.fo_fini = session_gen_fom_fini,
-	.fo_state = c2_rpc_fom_session_establish_state,
-	.fo_home_locality = c2_rpc_session_default_home_locality
-};
-
-static struct c2_fom_type_ops c2_rpc_fom_session_establish_type_ops = {
-	.fto_create = session_gen_fom_create
-};
-
-struct c2_fom_type c2_rpc_fom_session_establish_type = {
-	.ft_ops = &c2_rpc_fom_session_establish_type_ops
-};
-
-int c2_rpc_fom_session_establish_state(struct c2_fom *fom)
-{
-	struct c2_rpc_fop_session_establish_rep *reply;
-	struct c2_rpc_fop_session_establish     *request;
-	struct c2_rpc_item                      *item;
-	struct c2_fop                           *fop;
-	struct c2_fop                           *fop_rep;
-	struct c2_rpc_session                   *session;
-	struct c2_rpc_conn                      *conn;
-	uint32_t                                 slot_cnt;
-	int                                      rc;
-
-	C2_PRE(fom != NULL);
-	C2_PRE(fom->fo_fop != NULL && fom->fo_rep_fop != NULL);
-
-	fop = fom->fo_fop;
-	request = c2_fop_data(fop);
-	C2_ASSERT(request != NULL);
-
-	fop_rep = fom->fo_rep_fop;
-	reply = c2_fop_data(fop_rep);
-	C2_ASSERT(reply != NULL);
-
-	reply->rser_sender_id = request->rse_sender_id;
-	slot_cnt = request->rse_slot_cnt;
-
-	if (slot_cnt == 0) { /* There should be some upper limit to slot_cnt */
-		rc = -EINVAL;
-		goto errout;
-	}
-
-	C2_ALLOC_PTR(session);
-	if (session == NULL) {
-		rc = -ENOMEM;
-		goto errout;
-	}
-
-	item = &fop->f_item;
-	C2_ASSERT(item->ri_session != NULL);
-
-	conn = item->ri_session->s_conn;
-	C2_ASSERT(conn != NULL);
-
-	rc = c2_rpc_session_init(session, conn, slot_cnt);
-	if (rc != 0)
-		goto out_free;
-
-	rc = c2_rpc_rcv_session_establish(session);
-	if (rc != 0)
-		goto out_fini;
-
-	C2_ASSERT(session->s_state == C2_RPC_SESSION_IDLE);
-
-	reply->rser_rc = 0;    /* success */
-	reply->rser_session_id = session->s_session_id;
-	c2_rpc_reply_post(&fop->f_item, &fop_rep->f_item);
-	fom->fo_phase = FOPH_FINISH;
-	return FSO_WAIT;
-
-out_fini:
-	C2_ASSERT(session != NULL &&
-		  c2_rpc_session_invariant(session) &&
-		  session->s_state == C2_RPC_SESSION_FAILED);
-	c2_rpc_session_fini(session);
-
-out_free:
-	C2_ASSERT(session != NULL);
-	c2_free(session);
-	session = NULL;
-
-errout:
-	C2_ASSERT(rc != 0);
-
-	reply->rser_rc = rc;
-	reply->rser_session_id = SESSION_ID_INVALID;
-	fom->fo_phase = FOPH_FINISH;
-	c2_rpc_reply_post(&fop->f_item, &fop_rep->f_item);
-	return FSO_WAIT;
-}
-
-/*
- * FOM session terminate
- */
-
-const struct c2_fom_ops c2_rpc_fom_session_terminate_ops = {
-	.fo_fini = session_gen_fom_fini,
-	.fo_state = c2_rpc_fom_session_terminate_state,
-	.fo_home_locality = c2_rpc_session_default_home_locality
-};
-
-static struct c2_fom_type_ops c2_rpc_fom_session_terminate_type_ops = {
-	.fto_create = session_gen_fom_create
-};
-
-struct c2_fom_type c2_rpc_fom_session_terminate_type = {
-	.ft_ops = &c2_rpc_fom_session_terminate_type_ops
-};
-
-int c2_rpc_fom_session_terminate_state(struct c2_fom *fom)
-{
-	struct c2_rpc_fop_session_terminate_rep *reply;
-	struct c2_rpc_fop_session_terminate     *request;
-	struct c2_rpc_item                      *item;
-	struct c2_rpc_session                   *session;
-	struct c2_rpc_conn                      *conn;
-	uint64_t                                 session_id;
-	int                                      rc;
-
-	C2_PRE(fom != NULL);
-	C2_PRE(fom->fo_fop != NULL && fom->fo_rep_fop != NULL);
-
-	request = c2_fop_data(fom->fo_fop);
-	C2_ASSERT(request != NULL);
-
-	reply = c2_fop_data(fom->fo_rep_fop);
-	C2_ASSERT(reply != NULL);
-
-	/*
-	 * Copy the same sender and session id to reply fop
-	 */
-	reply->rstr_sender_id = request->rst_sender_id;
-	reply->rstr_session_id = session_id = request->rst_session_id;
-
-	item = &fom->fo_fop->f_item;
-	C2_ASSERT(item->ri_session != NULL);
-
-	conn = item->ri_session->s_conn;
-	C2_ASSERT(conn != NULL);
-
-	c2_mutex_lock(&conn->c_mutex);
-	C2_ASSERT(c2_rpc_conn_invariant(conn));
-	C2_ASSERT(conn->c_state == C2_RPC_CONN_ACTIVE);
-
-	session = c2_rpc_session_search(conn, session_id);
-	if (session == NULL) {
-		rc = -ENOENT;
-		c2_mutex_unlock(&conn->c_mutex);
-		goto errout;
-	}
-	c2_mutex_unlock(&conn->c_mutex);
-
-	rc = c2_rpc_rcv_session_terminate(session);
-	if (rc == -EPROTO) {
-		/*
-		 * session could not be terminated because session is not in
-		 * IDLE state.
-		 */
-		goto errout;
-	}
-	C2_ASSERT(ergo(rc != 0, session->s_state == C2_RPC_SESSION_FAILED));
-	C2_ASSERT(ergo(rc == 0, session->s_state == C2_RPC_SESSION_TERMINATED));
-
-	c2_rpc_session_fini(session);
-	c2_free(session);
-	/* fall through */
-errout:
-	reply->rstr_rc = rc;
-	fom->fo_phase = (rc == 0) ? FOPH_SUCCESS: FOPH_FAILURE;
-	/*
-	 * Note: request is received on SESSION_0, which is different from
-	 * current session being terminated. Reply will also go on SESSION_0.
-	 */
-	fom->fo_phase = FOPH_FINISH;
-	c2_rpc_reply_post(&fom->fo_fop->f_item, &fom->fo_rep_fop->f_item);
-
-	return FSO_WAIT;
-}
-
-/*
- * FOM RPC connection terminate
- */
-const struct c2_fom_ops c2_rpc_fom_conn_terminate_ops = {
-	.fo_fini = session_gen_fom_fini,
-	.fo_state = c2_rpc_fom_conn_terminate_state,
-	.fo_home_locality = c2_rpc_session_default_home_locality
-};
-
-static struct c2_fom_type_ops c2_rpc_fom_conn_terminate_type_ops = {
-	.fto_create = session_gen_fom_create
-};
-
-struct c2_fom_type c2_rpc_fom_conn_terminate_type = {
-	.ft_ops = &c2_rpc_fom_conn_terminate_type_ops
-};
-
-int c2_rpc_fom_conn_terminate_state(struct c2_fom *fom)
-{
-	struct c2_rpc_fop_conn_terminate_rep *reply;
-	struct c2_rpc_fop_conn_terminate     *request;
-	struct c2_rpc_item                   *item;
-	struct c2_fop                        *fop;
-	struct c2_fop                        *fop_rep;
-	struct c2_rpc_conn                   *conn;
-	int                                   rc;
-
-	C2_PRE(fom != NULL);
-	C2_PRE(fom->fo_fop != NULL && fom->fo_rep_fop != NULL);
-
-	fop = fom->fo_fop;
-	request = c2_fop_data(fop);
-	C2_ASSERT(request != NULL);
-
-	fop_rep = fom->fo_rep_fop;
-	reply = c2_fop_data(fop_rep);
-	C2_ASSERT(reply != NULL);
-
-	reply->ctr_sender_id = request->ct_sender_id;
-
-	item = &fop->f_item;
-	C2_ASSERT(item->ri_session != NULL);
-
-	conn = item->ri_session->s_conn;
-	C2_ASSERT(conn != NULL);
-	rc = c2_rpc_rcv_conn_terminate(conn);
-
-	if (conn->c_state != C2_RPC_CONN_FAILED) {
-		C2_ASSERT(conn->c_state == C2_RPC_CONN_ACTIVE ||
-			  conn->c_state == C2_RPC_CONN_TERMINATING);
-		/*
-		 * In memory state of conn is not cleaned up, at this point.
-		 * conn will be finalised and freed in the ->rio_sent()
-		 * callback of &fop_rep->f_item item.
-		 */
-		reply->ctr_rc = rc; /* rc can be -EBUSY */
-		fom->fo_phase = FOPH_FINISH;
-		c2_rpc_reply_post(&fop->f_item, &fop_rep->f_item);
-		return FSO_WAIT;
-	} else {
-		/*
-		 * conn has been moved to FAILED state. fini() and free() it.
-		 * Cannot send reply back to sender. Sender will time-out and
-		 * set sender side conn to FAILED state.
-		 * XXX generate ADDB record here.
-		 */
-		c2_rpc_conn_fini(conn);
-		c2_free(conn);
-		fom->fo_phase = FOPH_FINISH;
-		return FSO_WAIT;
-	}
-}
-
-/** @} End of rpc_session group */
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
-
diff --git a/rpc/session_foms.h b/rpc/session_foms.h
deleted file mode 100644
index 4281a08..0000000
--- a/rpc/session_foms.h
+++ /dev/null
@@ -1,113 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Rohan Puri <Rohan_Puri@xyratex.com>,
- *                  Amit Jambure <Amit_Jambure@xyratex.com>
- * Original creation date: 04/15/2011
- */
-
-#ifndef _C2_RPC_SESSION_FOM_H
-#define _C2_RPC_SESSION_FOM_H
-
-#include "fop/fop.h"
-#include "fop/fop_format.h"
-
-#include "rpc/session_fops.h"
-#ifdef __KERNEL__
-#include "rpc/session_k.h"
-#else
-#include "rpc/session_u.h"
-#endif
-
-#include "fop/fom.h"
-/**
-   @addtogroup rpc_session
-
-   @{
-
-   This file contains, fom declarations for
-   [conn|session]_[establish|terminate].
- */
-
-/*
- * FOM to execute "RPC connection create" request
- */
-
-enum c2_rpc_fom_conn_establish_phase {
-	FOPH_CONN_ESTABLISHING = FOPH_NR + 1
-};
-
-extern struct c2_fom_type c2_rpc_fom_conn_establish_type;
-extern const struct c2_fom_ops c2_rpc_fom_conn_establish_ops;
-
-size_t c2_rpc_session_default_home_locality(const struct c2_fom *fom);
-int c2_rpc_fom_conn_establish_state(struct c2_fom *fom);
-void c2_rpc_fom_conn_establish_fini(struct c2_fom *fom);
-/*
- * FOM to execute "Session Create" request
- */
-
-enum c2_rpc_fom_session_establish_phase {
-	FOPH_SESSION_ESTABLISHING = FOPH_NR + 1
-};
-
-extern struct c2_fom_type c2_rpc_fom_session_establish_type;
-extern const struct c2_fom_ops c2_rpc_fom_session_establish_ops;
-
-int c2_rpc_fom_session_establish_state(struct c2_fom *fom);
-void c2_rpc_fom_session_establish_fini(struct c2_fom *fom);
-
-/*
- * FOM to execute session terminate request
- */
-
-enum c2_rpc_fom_session_terminate_phase {
-	FOPH_SESSION_TERMINATING = FOPH_NR + 1
-};
-
-extern struct c2_fom_type c2_rpc_fom_session_terminate_type;
-extern const struct c2_fom_ops c2_rpc_fom_session_terminate_ops;
-
-int c2_rpc_fom_session_terminate_state(struct c2_fom *fom);
-void c2_rpc_fom_session_terminate_fini(struct c2_fom *fom);
-
-/*
- * FOM to execute RPC connection terminate request
- */
-
-enum c2_rpc_fom_conn_terminate_phase {
-	FOPH_CONN_TERMINATING = FOPH_NR + 1
-};
-
-extern struct c2_fom_type c2_rpc_fom_conn_terminate_type;
-extern const struct c2_fom_ops c2_rpc_fom_conn_terminate_ops;
-
-int c2_rpc_fom_conn_terminate_state(struct c2_fom *fom);
-void c2_rpc_fom_conn_terminate_fini(struct c2_fom *fom);
-
-#endif
-
-/** @} end of rpc_session group */
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
-
diff --git a/rpc/session_fops.c b/rpc/session_fops.c
deleted file mode 100644
index e2fd2f7..0000000
--- a/rpc/session_fops.c
+++ /dev/null
@@ -1,256 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Rohan Puri <Rohan_Puri@xyratex.com>,
- *                  Amit Jambure <Amit_Jambure@xyratex.com>
- * Original creation date: 04/15/2011
- */
-
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif
-
-#include "lib/errno.h"
-#include "lib/memory.h"
-#include "fop/fom.h"
-#include "fop/fop.h"
-#include "fop/fop_format_def.h"
-
-#ifdef __KERNEL__
-#include "rpc/session_k.h"
-#else
-#include "rpc/session_u.h"
-#endif
-#include "fop/fop_item_type.h"
-
-#include "fop/fop_iterator.h"
-#include "rpc/session_fops.h"
-#include "rpc/session_foms.h"
-#include "rpc/session.ff"
-#include "rpc/session_internal.h"
-#include "rpc/rpc_onwire.h" /* item_encdec() */
-
-/**
-   @addtogroup rpc_session
-
-   @{
-
-   This file contains definitions of fop types and rpc item types, of fops
-   belonging to rpc-session module
- */
-
-int c2_rpc_fop_noop_execute(struct c2_fop     *fop,
-			    struct c2_fop_ctx *ctx)
-{
-	/* Do nothing */
-	return 0;
-}
-
-static void conn_establish_item_free(struct c2_rpc_item *item)
-{
-	struct c2_rpc_fop_conn_establish_ctx *ctx;
-	struct c2_fop                        *fop;
-
-	fop = c2_rpc_item_to_fop(item);
-	ctx = container_of(fop, struct c2_rpc_fop_conn_establish_ctx, cec_fop);
-	c2_free(ctx);
-}
-
-static const struct c2_rpc_item_ops rcv_conn_establish_item_ops = {
-	.rio_free = conn_establish_item_free,
-};
-
-static int conn_establish_item_decode(struct c2_rpc_item_type *item_type,
-				      struct c2_rpc_item     **item,
-				      struct c2_bufvec_cursor *cur)
-{
-	struct c2_rpc_fop_conn_establish_ctx *ctx;
-	struct c2_fop                        *fop;
-	int                                   rc;
-
-	C2_PRE(item_type != NULL && item != NULL && cur != NULL);
-	C2_PRE(item_type->rit_opcode == C2_RPC_CONN_ESTABLISH_OPCODE);
-
-	*item = NULL;
-
-	C2_ALLOC_PTR(ctx);
-	if (ctx == NULL)
-		return -ENOMEM;
-
-	ctx->cec_sender_ep = NULL;
-	fop = &ctx->cec_fop;
-
-	rc = c2_fop_init(fop, &c2_rpc_fop_conn_establish_fopt, NULL);
-	if (rc != 0)
-		goto out;
-
-	rc = item_encdec(cur, &fop->f_item, C2_BUFVEC_DECODE);
-	if (rc != 0)
-		goto out;
-
-	*item           = &fop->f_item;
-	(*item)->ri_ops = &rcv_conn_establish_item_ops;
-
-	return 0;
-out:
-	c2_free(ctx);
-	return rc;
-}
-
-static const struct c2_fop_type_ops default_fop_type_ops = {
-	.fto_size_get = c2_xcode_fop_size_get,
-};
-
-static const struct c2_fop_type_ops default_reply_fop_type_ops = {
-	.fto_size_get = c2_xcode_fop_size_get,
-};
-
-const struct c2_fop_type_ops c2_rpc_fop_noop_ops = {
-	.fto_size_get = c2_xcode_fop_size_get,
-	.fto_execute = c2_rpc_fop_noop_execute
-};
-
-
-static struct c2_rpc_item_type_ops conn_establish_item_type_ops = {
-	.rito_encode = c2_fop_item_type_default_encode,
-	.rito_decode = conn_establish_item_decode,
-        .rito_item_size = c2_fop_item_type_default_onwire_size,
-};
-
-/*
- *  REQUEST fops
- */
-
-C2_FOP_TYPE_DECLARE_OPS(c2_rpc_fop_conn_establish, "rpc_conn_establish",
-			&default_fop_type_ops,
-			C2_RPC_CONN_ESTABLISH_OPCODE,
-			C2_RPC_ITEM_TYPE_REQUEST | C2_RPC_ITEM_TYPE_MUTABO,
-			&conn_establish_item_type_ops);
-
-C2_FOP_TYPE_DECLARE(c2_rpc_fop_conn_terminate, "rpc_conn_terminate",
-		    &default_fop_type_ops,
-		    C2_RPC_CONN_TERMINATE_OPCODE,
-		    C2_RPC_ITEM_TYPE_REQUEST | C2_RPC_ITEM_TYPE_MUTABO);
-
-C2_FOP_TYPE_DECLARE(c2_rpc_fop_session_establish, "rpc_session_establish",
-		    &default_fop_type_ops,
-		    C2_RPC_SESSION_ESTABLISH_OPCODE,
-		    C2_RPC_ITEM_TYPE_REQUEST | C2_RPC_ITEM_TYPE_MUTABO);
-
-C2_FOP_TYPE_DECLARE(c2_rpc_fop_session_terminate, "rpc_session_terminate",
-		    &default_fop_type_ops,
-		    C2_RPC_SESSION_TERMINATE_OPCODE,
-		    C2_RPC_ITEM_TYPE_REQUEST | C2_RPC_ITEM_TYPE_MUTABO);
-
-/*
- *  REPLY fops
- */
-
-C2_FOP_TYPE_DECLARE(c2_rpc_fop_conn_establish_rep, "rpc_conn_establish_reply",
-		    &default_reply_fop_type_ops,
-		    C2_RPC_CONN_ESTABLISH_REP_OPCODE,
-		    C2_RPC_ITEM_TYPE_REPLY);
-
-C2_FOP_TYPE_DECLARE(c2_rpc_fop_conn_terminate_rep, "rpc_conn_terminate_reply",
-		    &default_reply_fop_type_ops,
-		    C2_RPC_CONN_TERMINATE_REP_OPCODE,
-		    C2_RPC_ITEM_TYPE_REPLY);
-
-C2_FOP_TYPE_DECLARE(c2_rpc_fop_session_establish_rep,
-		    "rpc_session_establish_reply",
-		    &default_reply_fop_type_ops,
-		    C2_RPC_SESSION_ESTABLISH_REP_OPCODE,
-		    C2_RPC_ITEM_TYPE_REPLY);
-
-C2_FOP_TYPE_DECLARE(c2_rpc_fop_session_terminate_rep,
-		    "rpc_session_terminate_reply",
-		    &default_reply_fop_type_ops,
-		    C2_RPC_SESSION_TERMINATE_REP_OPCODE,
-		    C2_RPC_ITEM_TYPE_REPLY);
-
-C2_FOP_TYPE_DECLARE(c2_rpc_fop_noop, "NOOP",
-		    &c2_rpc_fop_noop_ops,
-		    C2_RPC_NOOP_OPCODE,
-		    C2_RPC_ITEM_TYPE_REQUEST);
-
-static struct c2_fop_type *fop_types[] = {
-	&c2_rpc_fop_conn_establish_fopt,
-	&c2_rpc_fop_conn_terminate_fopt,
-	&c2_rpc_fop_session_establish_fopt,
-	&c2_rpc_fop_session_terminate_fopt,
-	&c2_rpc_fop_conn_establish_rep_fopt,
-	&c2_rpc_fop_conn_terminate_rep_fopt,
-	&c2_rpc_fop_session_establish_rep_fopt,
-	&c2_rpc_fop_session_terminate_rep_fopt,
-	&c2_rpc_fop_noop_fopt,
-};
-
-void c2_rpc_session_fop_fini(void)
-{
-	c2_fop_type_fini_nr(fop_types, ARRAY_SIZE(fop_types));
-}
-
-int c2_rpc_session_fop_init(void)
-{
-	int result;
-
-	result = c2_fop_type_build_nr(fop_types, ARRAY_SIZE(fop_types));
-	if (result != 0)
-		c2_rpc_session_fop_fini();
-
-	c2_rpc_fop_conn_establish_fopt.ft_fom_type =
-		c2_rpc_fom_conn_establish_type;
-
-	c2_rpc_fop_conn_terminate_fopt.ft_fom_type =
-		c2_rpc_fom_conn_terminate_type;
-
-	c2_rpc_fop_session_establish_fopt.ft_fom_type =
-		c2_rpc_fom_session_establish_type;
-
-	c2_rpc_fop_session_terminate_fopt.ft_fom_type =
-		c2_rpc_fom_session_terminate_type;
-
-	return result;
-}
-
-void c2_rpc_fop_conn_establish_ctx_init(struct c2_rpc_item      *item,
-					struct c2_net_end_point *ep,
-					struct c2_rpcmachine    *machine)
-{
-	struct c2_rpc_fop_conn_establish_ctx *ctx;
-
-	C2_PRE(item != NULL && ep != NULL && machine != NULL);
-
-	ctx = container_of(item, struct c2_rpc_fop_conn_establish_ctx,
-				cec_fop.f_item);
-	C2_ASSERT(ctx != NULL);
-
-	c2_net_end_point_get(ep);
-	ctx->cec_sender_ep = ep;
-	ctx->cec_rpcmachine = machine;
-}
-
-/** @} End of rpc_session group */
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
-
diff --git a/rpc/session_fops.h b/rpc/session_fops.h
deleted file mode 100644
index ada1bec..0000000
--- a/rpc/session_fops.h
+++ /dev/null
@@ -1,107 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Rohan Puri <Rohan_Puri@xyratex.com>,
- *                  Amit Jambure <Amit_Jambure@xyratex.com>
- * Original creation date: 04/15/2011
- */
-
-#ifndef __COLIBRI_RPC_SESSION_FOPS_H__
-#define __COLIBRI_RPC_SESSION_FOPS_H__
-
-#include "fop/fop.h"
-#include "fop/fom.h"
-#include "rpc/rpc_opcodes.h"
-
-/**
-   @addtogroup rpc_session
-
-   @{
-
-   Declarations of all the fops belonging to rpc-session module along with
-   associated item types.
- */
-
-extern const struct c2_fop_type_ops c2_rpc_fop_conn_establish_ops;
-extern const struct c2_fop_type_ops c2_rpc_fop_conn_terminate_ops;
-extern const struct c2_fop_type_ops c2_rpc_fop_session_establish_ops;
-extern const struct c2_fop_type_ops c2_rpc_fop_session_terminate_ops;
-extern const struct c2_fop_type_ops c2_rpc_fop_noop_ops;
-
-extern struct c2_fop_type_format c2_rpc_fop_conn_establish_tfmt;
-extern struct c2_fop_type_format c2_rpc_fop_conn_establish_rep_tfmt;
-extern struct c2_fop_type_format c2_rpc_fop_conn_terminate_tfmt;
-extern struct c2_fop_type_format c2_rpc_fop_conn_terminate_rep_tfmt;
-extern struct c2_fop_type_format c2_rpc_fop_session_establish_tfmt;
-extern struct c2_fop_type_format c2_rpc_fop_session_establish_rep_tfmt;
-extern struct c2_fop_type_format c2_rpc_fop_session_terminate_tfmt;
-extern struct c2_fop_type_format c2_rpc_fop_session_terminate_rep_tfmt;
-extern struct c2_fop_type_format c2_rpc_fop_noop_tfmt;
-
-extern struct c2_fop_type c2_rpc_fop_conn_establish_fopt;
-extern struct c2_fop_type c2_rpc_fop_conn_establish_rep_fopt;
-extern struct c2_fop_type c2_rpc_fop_conn_terminate_fopt;
-extern struct c2_fop_type c2_rpc_fop_conn_terminate_rep_fopt;
-extern struct c2_fop_type c2_rpc_fop_session_establish_fopt;
-extern struct c2_fop_type c2_rpc_fop_session_establish_rep_fopt;
-extern struct c2_fop_type c2_rpc_fop_session_terminate_fopt;
-extern struct c2_fop_type c2_rpc_fop_session_terminate_rep_fopt;
-extern struct c2_fop_type c2_rpc_fop_noop_fopt;
-
-int c2_rpc_fop_noop_execute(struct c2_fop     *fop,
-			    struct c2_fop_ctx *ctx);
-
-int c2_rpc_session_fop_init(void);
-
-void c2_rpc_session_fop_fini(void);
-
-/**
-   Container for CONN_ESTABLISH fop.
-
-   This is required only on receiver side so that,
-   c2_rpc_fom_conn_establish_state() can find out sender's endpoint, while
-   initialising receiver side c2_rpc_conn object.
-
-   Just before calling c2_rpc_item_received(), rpc_net_buf_received(), sets
-   cec_sender_ep, by using c2_net_buffer::nb_ep attribute.
- */
-struct c2_rpc_fop_conn_establish_ctx
-{
-	/** fop instance of type c2_rpc_fop_conn_establish_fopt */
-	struct c2_fop            cec_fop;
-
-	/** end point of sender, who has sent the conn_establish request fop */
-	struct c2_net_end_point *cec_sender_ep;
-
-	/** New rpc connection needs to be established in context of this
-	    rpcmachine */
-	struct c2_rpcmachine    *cec_rpcmachine;
-};
-
-/* __COLIBRI_RPC_SESSION_FOPS_H__ */
-
-/** @}  End of rpc_session group */
-#endif
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
-
diff --git a/rpc/session_internal.h b/rpc/session_internal.h
deleted file mode 100644
index 3e9c410..0000000
--- a/rpc/session_internal.h
+++ /dev/null
@@ -1,531 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Amit_Jambure <Amit_Jambure@xyratex.com>
- * Original creation date: 05/02/2011
- */
-
-/* Declarations of functions that are private to rpc-layer */
-
-#ifndef _COLIBRI_RPC_SESSION_INT_H
-#define _COLIBRI_RPC_SESSION_INT_H
-
-#include "cob/cob.h"
-#include "rpc/session.h"
-#include "dtm/verno.h"
-
-/**
-   @addtogroup rpc_session
-
-   @{
- */
-
-struct c2_rpc_item_ops;
-
-/**
-   Initialises all the session related fop types
- */
-int c2_rpc_session_module_init(void);
-
-/**
-   Finalises all session realted fop types
- */
-void c2_rpc_session_module_fini(void);
-
-enum {
-	SESSION_COB_MAX_NAME_LEN = 40
-};
-
-/**
-   checks internal consistency of session
- */
-bool c2_rpc_session_invariant(const struct c2_rpc_session *session);
-
-/**
-   Searches in conn->c_sessions list, a session object whose session id
-   matches with given @session_id.
-
-   Caller is expected to decide whether conn will be locked or not
-   The function is also called from session_foms.c, that's why is not static.
-
-   @return pointer to session if found, NULL otherwise
-   @post ergo(result != NULL, result->s_session_id == session_id)
- */
-struct c2_rpc_session *c2_rpc_session_search(const struct c2_rpc_conn *conn,
-					     uint64_t session_id);
-
-/**
-   Searches and returns session with session_id 0.
-   Each rpc connection always has exactly one instance of session with
-   SESSION_ID_0 in its c_sessions list.
-
-   @post result != NULL && result->s_session_id == SESSION_ID_0
- */
-struct c2_rpc_session *c2_rpc_conn_session0(const struct c2_rpc_conn *conn);
-
-/**
-   Generates UUID
- */
-void c2_rpc_sender_uuid_generate(struct c2_rpc_sender_uuid *u);
-
-/**
-   3WAY comparison function for UUID
- */
-int c2_rpc_sender_uuid_cmp(const struct c2_rpc_sender_uuid *u1,
-			   const struct c2_rpc_sender_uuid *u2);
-
-/**
-   Initialises in memory slot.
-
-   @post ergo(result == 0, slot->sl_verno.vn_vc == 0 &&
-			   slot->sl_xid == 1 &&
-			   !c2_list_is_empty(slot->sl_item_list) &&
-			   slot->sl_ops == ops)
- */
-int c2_rpc_slot_init(struct c2_rpc_slot           *slot,
-		     const struct c2_rpc_slot_ops *ops);
-
-/**
-   If verno of item matches with verno of slot, then adds the item
-   to the slot->sl_item_list. If item is update opeation, verno of
-   slot is advanced. if item is already present in slot->sl_item_list
-   its reply is immediately consumed.
- */
-int c2_rpc_slot_item_apply(struct c2_rpc_slot *slot,
-			   struct c2_rpc_item *item);
-
-/**
-   Called when a reply item is received for an item which was sent on this slot.
-
-   Searches request item for which @reply is received. Marks the request item
-   to be in state PAST_VOLATILE and calls slot->sl_ops->so_reply_consume()
-   callback.
-   req_out will contain pointer to original item for which this is reply.
-   Takes care of duplicate replies. Sets *req_out to NULL if @reply is
-   duplicate or unexpected.
- */
-void c2_rpc_slot_reply_received(struct c2_rpc_slot  *slot,
-				struct c2_rpc_item  *reply,
-				struct c2_rpc_item **req_out);
-
-/**
-   Reports slot that effects of item with verno <= @last_pesistent, are
-   persistent on receiver.
-
-   @post c2_verno_cmp(&slot->sl_last_persistent->ri_slot_refs[0].sr_verno,
-		      &last_persistent) >= 0
- */
-void c2_rpc_slot_persistence(struct c2_rpc_slot *slot,
-			     struct c2_verno     last_persistent);
-
-int c2_rpc_slot_misordered_item_received(struct c2_rpc_slot *slot,
-                                         struct c2_rpc_item *item);
-
-/**
-   Resets version number of slot to @last_seen
-   @post c2_verno_cmp(&slot->sl_last_sent->ri_slot_refs[0].sr_verno,
-		      &last_seen) == 0
- */
-void c2_rpc_slot_reset(struct c2_rpc_slot *slot,
-		       struct c2_verno     last_seen);
-
-/**
-   Finalises slot
- */
-void c2_rpc_slot_fini(struct c2_rpc_slot *slot);
-
-bool c2_rpc_slot_invariant(const struct c2_rpc_slot *slot);
-
-/**
-   Name of a cob which is root of hierarchy of cobs that represent
-   persistent state maintained by session module.
- */
-static const char root_session_cob_name[] = "SESSIONS";
-
-/**
-   Helper to create cob
-
-   @param dom cob domain in which cob should be created.
-   @param pcob parent cob in which new cob is to be created
-   @param name name of cob
-   @param out newly created cob
-   @param tx transaction context
-
-   @return 0 on success. *out != NULL
- */
-
-int c2_rpc_cob_create_helper(struct c2_cob_domain *dom,
-			     struct c2_cob        *pcob,
-			     const char           *name,
-			     struct c2_cob       **out,
-			     struct c2_db_tx      *tx);
-
-#define COB_GET_PFID_HI(cob)    (cob)->co_nsrec.cnr_stobid.si_bits.u_hi
-#define COB_GET_PFID_LO(cob)    (cob)->co_nsrec.cnr_stobid.si_bits.u_lo
-
-/**
-   Lookup a cob named 'name' in parent cob @pcob. If found store reference
-   in @out. If not found set *out to NULL. To lookup root cob, pcob can be
-   set to NULL
- */
-int c2_rpc_cob_lookup_helper(struct c2_cob_domain *dom,
-			     struct c2_cob        *pcob,
-			     const char           *name,
-			     struct c2_cob       **out,
-			     struct c2_db_tx      *tx);
-
-/**
-  Lookup /SESSIONS entry in cob namespace
- */
-int c2_rpc_root_session_cob_get(struct c2_cob_domain *dom,
-				 struct c2_cob      **out,
-				 struct c2_db_tx     *tx);
-
-/**
-  Creates /SESSIONS entry in cob namespace
- */
-int c2_rpc_root_session_cob_create(struct c2_cob_domain *dom,
-				   struct c2_db_tx      *tx);
-
-/**
-   Lookup for a cob that represents rpc connection with given @sender_id.
-
-   Searches for /SESSIONS/SENDER_$sender_id
- */
-int c2_rpc_conn_cob_lookup(struct c2_cob_domain *dom,
-			   uint64_t              sender_id,
-			   struct c2_cob       **out,
-			   struct c2_db_tx      *tx);
-
-/**
-   Creates a cob that represents rpc connection with given @sender_id
-
-   Creates a cob /SESSIONS/SENDER_$sender_id
- */
-int c2_rpc_conn_cob_create(struct c2_cob_domain *dom,
-			   uint64_t              sender_id,
-			   struct c2_cob       **out,
-			   struct c2_db_tx      *tx);
-
-/**
-   Lookup for a cob named "SESSION_$session_id" that represents rpc session
-   within a given @conn_cob (cob that identifies rpc connection)
- */
-int c2_rpc_session_cob_lookup(struct c2_cob   *conn_cob,
-			      uint64_t         session_id,
-			      struct c2_cob  **session_cob,
-			      struct c2_db_tx *tx);
-
-/**
-   Creates a cob named "SESSION_$session_id" that represents rpc session
-   within a given @conn_cob (cob that identifies rpc connection)
- */
-int c2_rpc_session_cob_create(struct c2_cob   *conn_cob,
-			      uint64_t         session_id,
-			      struct c2_cob  **session_cob,
-			      struct c2_db_tx *tx);
-
-/**
-   Lookup for a cob named "SLOT_$slot_id:$slot_generation" in @session_cob
- */
-int c2_rpc_slot_cob_lookup(struct c2_cob   *session_cob,
-			   uint32_t         slot_id,
-			   uint64_t         slot_generation,
-			   struct c2_cob  **slot_cob,
-			   struct c2_db_tx *tx);
-
-/**
-   Creates a cob named "SLOT_$slot_id:$slot_generation" in @session_cob
- */
-int c2_rpc_slot_cob_create(struct c2_cob   *session_cob,
-			   uint32_t         slot_id,
-			   uint64_t         slot_generation,
-			   struct c2_cob  **slot_cob,
-			   struct c2_db_tx *tx);
-
-/**
-   Initalises receiver end of conn object.
-
-   @post ergo(result == 0, conn->c_state == C2_RPC_CONN_INITIALISED &&
-			   conn->c_rpcmachine == machine &&
-			   conn->c_sender_id == SENDER_ID_INVALID &&
-			   (conn->c_flags & RCF_RECV_END) != 0)
- */
-int c2_rpc_rcv_conn_init(struct c2_rpc_conn              *conn,
-			 struct c2_net_end_point         *ep,
-			 struct c2_rpcmachine            *machine,
-			 const struct c2_rpc_sender_uuid *uuid);
-/**
-   Creates a receiver end of conn.
-
-   @pre conn->c_state == C2_RPC_CONN_INITIALISED
-   @post ergo(result == 0, conn->c_state == C2_RPC_CONN_ACTIVE &&
-			   conn->c_sender_id != SENDER_ID_INVALID &&
-			   c2_list_contains(&machine->cr_incoming_conns,
-					    &conn->c_link)
-   @post ergo(result != 0, conn->c_state == C2_RPC_CONN_FAILED)
-   @post ergo(result == 0, conn->c_state == C2_RPC_CONN_ACTIVE)
- */
-int c2_rpc_rcv_conn_establish(struct c2_rpc_conn *conn);
-
-/**
-   Creates receiver end of session object.
-
-   @pre session->s_state == C2_RPC_SESSION_INITIALISED &&
-	session->s_conn != NULL
-   @post ergo(result == 0, session->s_state == C2_RPC_SESSION_ALIVE)
-   @post ergo(result != 0, session->s_state == C2_RPC_SESSION_FAILED)
- */
-int c2_rpc_rcv_session_establish(struct c2_rpc_session *session);
-
-/**
-   Terminates receiver end of session.
-
-   @pre session->s_state == C2_RPC_SESSION_IDLE
-   @post ergo(result == 0, session->s_state == C2_RPC_SESSION_TERMINATED)
-   @post ergo(result != 0 && session->s_rc != 0, session->s_state ==
-	      C2_RPC_SESSION_FAILED)
- */
-int c2_rpc_rcv_session_terminate(struct c2_rpc_session *session);
-
-/**
-   Terminates receiver end of rpc connection.
-
-   @pre conn->c_state == C2_RPC_CONN_ACTIVE && conn->c_nr_sessions == 0
-   @post ergo(result == 0, conn->c_state == C2_RPC_CONN_TERMINATING)
-   @post ergo(result != 0 && result != -EBUSY,
-		conn->c_state == C2_RPC_CONN_FAILED)
- */
-int c2_rpc_rcv_conn_terminate(struct c2_rpc_conn *conn);
-
-/**
-   Cleans up in memory state of rpc connection.
-
-   XXX Right now this function is not called from anywhere. There
-   should be ->item_sent() callback in item->ri_ops, where this
-   function can be hooked.
-
-   The conn_terminate FOM cannot free in-memory state of rpc connection.
-   Because it needs to send conn_terminate_reply fop, by using session-0 and
-   slot-0 of the rpc connection being terminated. Hence we cleanup in memory
-   state of the conn when conn_terminate_reply has been sent.
-
-   @pre conn->c_state == C2_RPC_CONN_TERMINATING
- */
-void conn_terminate_reply_sent(struct c2_rpc_conn *conn);
-
-/**
-   slot_ref object establishes association between c2_rpc_item and
-   c2_rpc_slot. Upto MAX_SLOT_REF number of c2_rpc_slot_ref objects are
-   embeded with c2_rpc_item.
-   At the time item is associated with a slot, values of few slot fields are
-   copied into slot_ref.
- */
-struct c2_rpc_slot_ref {
-	/** sr_slot and sr_item identify two ends of association */
-	struct c2_rpc_slot        *sr_slot;
-
-	struct c2_rpc_item        *sr_item;
-
-	struct c2_rpc_sender_uuid  sr_uuid;
-
-	uint64_t                   sr_sender_id;
-
-	uint64_t                   sr_session_id;
-
-	/** Numeric id of slot. Used when encoding and decoding rpc item to
-	    and from wire-format
-	 */
-	uint32_t                   sr_slot_id;
-
-	/** If slot has verno matching sr_verno, then only the item can be
-	    APPLIED to the slot
-	 */
-	struct c2_verno            sr_verno;
-
-	/** In each reply item, receiver reports to sender, verno of item
-	    whose effects have reached persistent storage, using this field
-	 */
-	struct c2_verno            sr_last_persistent_verno;
-
-	/** Inform the sender about current slot version */
-	struct c2_verno            sr_last_seen_verno;
-
-	/** An identifier that uniquely identifies item within
-	    slot->item_list.
-        */
-	uint64_t                   sr_xid;
-
-	/** Generation number of slot */
-	uint64_t                   sr_slot_gen;
-
-	/** Anchor to put item on c2_rpc_slot::sl_item_list */
-	struct c2_list_link        sr_link;
-
-	/** Anchor to put item on c2_rpc_slot::sl_ready_list */
-	struct c2_list_link        sr_ready_link;
-};
-
-/**
-   Called for each received item.
-   If item is request then
-	APPLY the item to proper slot
-   else
-	report REPLY_RECEIVED to appropriate slot
- */
-int c2_rpc_item_received(struct c2_rpc_item   *item,
-			 struct c2_rpcmachine *machine);
-
-/**
-   Adds an item to slot->sl_item_list, without triggering
-   any slot related events i.e. slot->ops->consume_item()
- */
-void c2_rpc_slot_item_add_internal(struct c2_rpc_slot *slot,
-				   struct c2_rpc_item *item);
-
-/**
-   Callback routine called through item->ri_ops->rio_replied().
-
-   The routine is executed when reply to conn create fop is received
- */
-void c2_rpc_conn_establish_reply_received(struct c2_rpc_item *req);
-
-/**
-   Callback routine called through item->ri_ops->rio_replied().
-
-   The routine is executed when reply to conn terminate fop is received
- */
-void c2_rpc_conn_terminate_reply_received(struct c2_rpc_item *req);
-
-/**
-   Callback routine called through item->ri_ops->rio_replied().
-
-   The routine is executed when reply to session create fop is received
- */
-void c2_rpc_session_establish_reply_received(struct c2_rpc_item *req);
-
-/**
-   Callback routine called through item->ri_ops->rio_replied().
-
-   The routine is executed when reply to session terminate fop is received
- */
-void c2_rpc_session_terminate_reply_received(struct c2_rpc_item *req);
-/**
-  A callback called when conn terminate reply has been put on network.
-  Finalizes and frees conn.
-
-  @pre conn->c_state == C2_RPC_CONN_TERMINATING
- */
-void c2_rpc_conn_terminate_reply_sent(struct c2_rpc_conn *conn);
-
-/**
-   Iterates over all the sessions in rpc connection
- */
-#define c2_rpc_for_each_session(conn, session)  \
-	c2_list_for_each_entry(&(conn)->c_sessions, (session),  \
-		struct c2_rpc_session, s_link)
-
-enum {
-	/**
-	   window size for a sliding-window of slot
-	 */
-	SLOT_DEFAULT_MAX_IN_FLIGHT = 1
-};
-
-/**
-   Call-backs for events that a slot can trigger.
- */
-struct c2_rpc_slot_ops {
-	/** Item i is ready to be consumed */
-	void (*so_item_consume)(struct c2_rpc_item *i);
-	/** A @reply for a request item @req is received and is
-	    ready to be consumed */
-	void (*so_reply_consume)(struct c2_rpc_item *req,
-				 struct c2_rpc_item *reply);
-	/** Slot has no items to send and hence is idle. Formation
-	    can use such slot to send unbound items. */
-	void (*so_slot_idle)(struct c2_rpc_slot *slot);
-};
-
-/**
-   Returns true iff given rpc item is conn_establish.
- */
-bool c2_rpc_item_is_conn_establish(const struct c2_rpc_item *item);
-
-/**
-   Returns true iff given rpc item is conn_terminate.
- */
-bool c2_rpc_item_is_conn_terminate(const struct c2_rpc_item *item);
-
-/**
-   @see c2_rpc_fop_conn_establish_ctx for more information.
- */
-void c2_rpc_fop_conn_establish_ctx_init(struct c2_rpc_item      *item,
-					struct c2_net_end_point *ep,
-					struct c2_rpcmachine    *machine);
-
-/**
-   Helper routine, internal to rpc module.
-   Sets up and posts rpc-item representing @fop.
- */
-int c2_rpc__fop_post(struct c2_fop                *fop,
-		     struct c2_rpc_session        *session,
-		     const struct c2_rpc_item_ops *ops);
-
-/**
-   Return true iff @conn is sender side object of rpc-connection.
- */
-bool c2_rpc_conn_is_snd(const struct c2_rpc_conn *conn);
-
-/**
-   Return true iff @conn is receiver side object of rpc-connection.
- */
-bool c2_rpc_conn_is_rcv(const struct c2_rpc_conn *conn);
-
-/**
-   Temporary routine to place fop in a global queue, from where it can be
-   selected for execution.
- */
-void c2_rpc_item_dispatch(struct c2_rpc_item *item);
-
-/**
-   Returns true iff, it is okay to add item internally (i.e.
-   c2_rpc_item_add_internal()). This is required, so that formation can add
-   unbound items to the slot until slot->sl_max_in_flight limit is reached.
-
-   @pre c2_mutex_is_locked(&slot->sl_mutex)
- */
-bool c2_rpc_slot_can_item_add_internal(const struct c2_rpc_slot *slot);
-
-/**
-   For all slots belonging to @session,
-     if slot is in c2_rpcmachine::cr_ready_slots list,
-     then remove it from the list.
- */
-void c2_rpc_session_del_slots_from_ready_list(struct c2_rpc_session *session);
-
-/** @}  End of rpc_session group */
-#endif
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
diff --git a/rpc/session_utils.c b/rpc/session_utils.c
deleted file mode 100644
index 7d085d0..0000000
--- a/rpc/session_utils.c
+++ /dev/null
@@ -1,241 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Rohan Puri <Rohan_Puri@xyratex.com>
- *                  Amit Jambure <Amit_Jambure@xyratex.com>
- * Original creation date: 08/24/2011
- */
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif
-
-#include "lib/errno.h"
-#include "lib/memory.h"
-#include "lib/misc.h"
-#include "lib/arith.h"
-#include "rpc/session.h"
-#include "lib/bitstring.h"
-#include "cob/cob.h"
-#include "fop/fop.h"
-#include "fop/fop_format_def.h"
-#include "reqh/reqh.h"
-
-#ifdef __KERNEL__
-#include "rpc/session_k.h"
-#else
-#include "rpc/session_u.h"
-#endif
-
-#include "rpc/session_fops.h"
-#include "rpc/session_internal.h"
-#include "db/db.h"
-
-/**
-   @addtogroup rpc_session
-
-   @{
- */
-
-int c2_rpc_session_module_init(void)
-{
-        return c2_rpc_session_fop_init();
-}
-
-void c2_rpc_session_module_fini(void)
-{
-        c2_rpc_session_fop_fini();
-}
-
-void c2_rpc_sender_uuid_generate(struct c2_rpc_sender_uuid *u)
-{
-	/* XXX temporary */
-	uint64_t  rnd;
-
-	rnd = c2_time_nanoseconds(c2_time_now()) * 1000;
-	u->su_uuid = c2_rnd(~0ULL >> 16, &rnd);
-}
-
-int c2_rpc_sender_uuid_cmp(const struct c2_rpc_sender_uuid *u1,
-			   const struct c2_rpc_sender_uuid *u2)
-{
-	return C2_3WAY(u1->su_uuid, u2->su_uuid);
-}
-
-/**
-   Initialises rpc item and posts it to rpc-layer
- */
-int c2_rpc__fop_post(struct c2_fop                *fop,
-		     struct c2_rpc_session        *session,
-		     const struct c2_rpc_item_ops *ops)
-{
-	struct c2_rpc_item *item;
-
-	item = &fop->f_item;
-	item->ri_session = session;
-	item->ri_prio = C2_RPC_ITEM_PRIO_MAX;
-	item->ri_deadline = 0;
-	item->ri_ops = ops;
-
-	return c2_rpc_post(item);
-}
-
-static struct c2_uint128 stob_id_alloc(void)
-{
-        static struct c2_atomic64 cnt;
-	struct c2_uint128         id;
-        uint64_t                  millisec;
-
-	/*
-	 * TEMPORARY implementation to allocate unique stob id
-	 */
-	millisec = c2_time_nanoseconds(c2_time_now()) * 1000000;
-	c2_atomic64_inc(&cnt);
-
-	id.u_hi = (0xFFFFULL << 48); /* MSB 16 bit set */
-	id.u_lo = (millisec << 20) | (c2_atomic64_get(&cnt) & 0xFFFFF);
-        return id;
-}
-
-int c2_rpc_cob_create_helper(struct c2_cob_domain *dom,
-			     struct c2_cob        *pcob,
-			     const char           *name,
-			     struct c2_cob       **out,
-			     struct c2_db_tx      *tx)
-{
-	struct c2_cob_nskey  *key;
-	struct c2_cob_nsrec   nsrec;
-	struct c2_cob_fabrec  fabrec;
-	struct c2_cob        *cob;
-	uint64_t              pfid_hi;
-	uint64_t              pfid_lo;
-	int                   rc;
-
-	C2_PRE(dom != NULL && name != NULL && out != NULL);
-
-	*out = NULL;
-
-	if (pcob == NULL) {
-		pfid_hi = pfid_lo = 1;
-	} else {
-		pfid_hi = COB_GET_PFID_HI(pcob);
-		pfid_lo = COB_GET_PFID_LO(pcob);
-	}
-
-	c2_cob_nskey_make(&key, pfid_hi, pfid_lo, name);
-	if (key == NULL)
-		return -ENOMEM;
-
-	nsrec.cnr_stobid.si_bits = stob_id_alloc();
-	nsrec.cnr_nlink = 1;
-
-	/*
-	 * Temporary assignment for lsn
-	 */
-	fabrec.cfb_version.vn_lsn = C2_LSN_RESERVED_NR + 2;
-	fabrec.cfb_version.vn_vc = 0;
-
-	rc = c2_cob_create(dom, key, &nsrec, &fabrec, CA_NSKEY_FREE | CA_FABREC,
-				&cob, tx);
-	if (rc == 0)
-		*out = cob;
-
-	return rc;
-}
-
-int c2_rpc_cob_lookup_helper(struct c2_cob_domain *dom,
-			     struct c2_cob        *pcob,
-			     const char           *name,
-			     struct c2_cob       **out,
-			     struct c2_db_tx      *tx)
-{
-	struct c2_cob_nskey *key = NULL;
-	uint64_t             pfid_hi;
-	uint64_t             pfid_lo;
-	int                  rc;
-
-	C2_PRE(dom != NULL && name != NULL && out != NULL);
-
-	*out = NULL;
-	if (pcob == NULL) {
-		pfid_hi = pfid_lo = 1;
-	} else {
-		pfid_hi = COB_GET_PFID_HI(pcob);
-		pfid_lo = COB_GET_PFID_LO(pcob);
-	}
-
-	c2_cob_nskey_make(&key, pfid_hi, pfid_lo, name);
-	if (key == NULL)
-		return -ENOMEM;
-	rc = c2_cob_lookup(dom, key, CA_NSKEY_FREE | CA_FABREC, out, tx);
-
-	C2_POST(ergo(rc == 0, *out != NULL));
-	return rc;
-}
-
-int c2_rpc_root_session_cob_get(struct c2_cob_domain *dom,
-				struct c2_cob       **out,
-				struct c2_db_tx      *tx)
-{
-	return c2_rpc_cob_lookup_helper(dom, NULL, root_session_cob_name,
-						out, tx);
-}
-
-int c2_rpc_root_session_cob_create(struct c2_cob_domain *dom,
-				   struct c2_db_tx      *tx)
-{
-	struct c2_cob *out = NULL;
-	int            rc;
-
-	rc = c2_rpc_cob_create_helper(dom, NULL, root_session_cob_name,
-						&out, tx);
-	if (rc == 0)
-		c2_cob_put(out);
-
-	if (rc == -EEXIST)
-		rc = 0;
-
-	return rc;
-}
-
-/**
-  XXX temporary routine that submits the fop inside item for execution.
- */
-void c2_rpc_item_dispatch(struct c2_rpc_item *item)
-{
-	struct c2_fop                        *fop;
-	struct c2_reqh                       *reqh;
-        struct c2_rpc_fop_conn_establish_ctx *ctx;
-	struct c2_rpcmachine                 *rpcmach;
-
-	 if (c2_rpc_item_is_conn_establish(item)) {
-
-		ctx = container_of(item, struct c2_rpc_fop_conn_establish_ctx,
-					cec_fop.f_item);
-		C2_ASSERT(ctx != NULL);
-		rpcmach = ctx->cec_rpcmachine;
-	} else
-		rpcmach = item->ri_session->s_conn->c_rpcmachine;
-
-	C2_ASSERT(rpcmach != NULL);
-
-	reqh = rpcmach->cr_reqh;
-	C2_ASSERT(reqh != NULL);
-
-	fop = c2_rpc_item_to_fop(item);
-#ifndef __KERNEL__
-	c2_reqh_fop_handle(reqh, fop); 
-#endif
-}
diff --git a/rpc/slot.c b/rpc/slot.c
deleted file mode 100644
index 2be0acf..0000000
--- a/rpc/slot.c
+++ /dev/null
@@ -1,982 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Rohan Puri <Rohan_Puri@xyratex.com>
- *                  Amit Jambure <Amit_Jambure@xyratex.com>
- * Original creation date: 08/24/2011
- */
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif
-
-#include "lib/errno.h"
-#include "lib/memory.h"
-#include "lib/misc.h"
-#include "rpc/session.h"
-#include "lib/bitstring.h"
-#include "cob/cob.h"
-#include "fop/fop.h"
-#include "fop/fop_format_def.h"
-#include "lib/arith.h"
-
-#ifdef __KERNEL__
-#include "rpc/session_k.h"
-#else
-#include "rpc/session_u.h"
-#endif
-
-#include "rpc/session_internal.h"
-#include "db/db.h"
-#include "dtm/verno.h"
-#include "rpc/session_fops.h"
-#include "rpc/rpc2.h"
-#include "rpc/formation.h"
-
-/**
-   @addtogroup rpc_session
-
-   @{
-
-   This file contains implementation of rpc slots.
-
- */
-
-void item_exit_stats_set(struct c2_rpc_item    *item,
-			 enum c2_rpc_item_path  path);
-
-void frm_item_reply_received(struct c2_rpc_item *reply_item,
-			     struct c2_rpc_item *req_item);
-
-void rpc_item_replied(struct c2_rpc_item *item, struct c2_rpc_item *reply,
-                      uint32_t rc);
-
-bool c2_rpc_slot_invariant(const struct c2_rpc_slot *slot)
-{
-	struct c2_rpc_item *item1 = NULL;  /* init to NULL, required */
-	struct c2_rpc_item *item2;
-	struct c2_verno    *v1;
-	struct c2_verno    *v2;
-	bool                ret = true;   /* init to true, required */
-
-	if (slot == NULL ||
-	      slot->sl_in_flight > slot->sl_max_in_flight ||
-	      !c2_list_invariant(&slot->sl_item_list))
-		return false;
-
-	/*
-	 * Traverse slot->sl_item_list using item2 ptr
-	 * item1 will be previous item of item2 i.e.
-	 * next(item1) == item2
-	 */
-	c2_list_for_each_entry(&slot->sl_item_list, item2, struct c2_rpc_item,
-				ri_slot_refs[0].sr_link) {
-
-		if (item1 == NULL) {
-			/*
-			 * First element is dummy item. So no need to check.
-			 */
-			item1 = item2;
-			continue;
-		}
-		ret = ergo(item2->ri_stage == RPC_ITEM_STAGE_PAST_VOLATILE ||
-			   item2->ri_stage == RPC_ITEM_STAGE_PAST_COMMITTED,
-			   item2->ri_reply != NULL);
-		if (!ret)
-			break;
-
-		ret = (item1->ri_stage <= item2->ri_stage);
-		if (!ret)
-			break;
-
-		v1 = &item1->ri_slot_refs[0].sr_verno;
-		v2 = &item2->ri_slot_refs[0].sr_verno;
-
-		/*
-		 * AFTER an "update" item is applied on a slot
-		 * the version number of slot is advanced
-		 */
-		ret = c2_rpc_item_is_update(item1) ?
-			v1->vn_vc + 1 == v2->vn_vc :
-			v1->vn_vc == v2->vn_vc;
-		if (!ret)
-			break;
-
-		ret = (item1->ri_slot_refs[0].sr_xid + 1 ==
-			item2->ri_slot_refs[0].sr_xid);
-		if (!ret)
-			break;
-
-		item1 = item2;
-	}
-	return ret;
-}
-
-int c2_rpc_slot_init(struct c2_rpc_slot           *slot,
-		     const struct c2_rpc_slot_ops *ops)
-{
-	struct c2_fop          *fop;
-	struct c2_rpc_item     *dummy_item;
-	struct c2_rpc_slot_ref *sref;
-
-	/*
-	 * Allocate dummy item.
-	 * The dummy item is used to avoid special cases
-	 * i.e. last_sent == NULL, last_persistent == NULL
-	 */
-	fop = c2_fop_alloc(&c2_rpc_fop_noop_fopt, NULL);
-	if (fop == NULL)
-		return -ENOMEM;
-
-	c2_list_link_init(&slot->sl_link);
-	/*
-	 * XXX temporary value for lsn. This will be set to some proper value
-	 * when sessions will be integrated with FOL
-	 */
-	slot->sl_verno.vn_lsn  = C2_LSN_RESERVED_NR + 2;
-	slot->sl_verno.vn_vc   = 0;
-	slot->sl_slot_gen      = 0;
-	slot->sl_xid           = 1; /* xid 0 will be taken by dummy item */
-	slot->sl_in_flight     = 0;
-	slot->sl_max_in_flight = SLOT_DEFAULT_MAX_IN_FLIGHT;
-	slot->sl_cob           = NULL;
-	slot->sl_ops           = ops;
-
-	c2_list_init(&slot->sl_item_list);
-	c2_list_init(&slot->sl_ready_list);
-	c2_mutex_init(&slot->sl_mutex);
-
-	/*
-	 * Add a dummy item with very low verno in item_list
-	 */
-
-	dummy_item = &fop->f_item;
-
-	dummy_item->ri_stage     = RPC_ITEM_STAGE_PAST_COMMITTED;
-	/* set ri_reply to some value. Doesn't matter what */
-	dummy_item->ri_reply     = dummy_item;
-	slot->sl_last_sent       = dummy_item;
-	slot->sl_last_persistent = dummy_item;
-
-	sref                  = &dummy_item->ri_slot_refs[0];
-	sref->sr_slot         = slot;
-	sref->sr_item         = dummy_item;
-	sref->sr_xid          = 0;
-	/*
-	 * XXX lsn will be assigned to some proper value once sessions code
-	 * will be integrated with FOL
-	 */
-	sref->sr_verno.vn_lsn = C2_LSN_DUMMY_ITEM;
-	sref->sr_verno.vn_vc  = 0;
-	sref->sr_slot_gen     = slot->sl_slot_gen;
-
-	c2_list_link_init(&sref->sr_link);
-	c2_list_add(&slot->sl_item_list, &sref->sr_link);
-	return 0;
-}
-
-/**
-  Frees all the items from slot->sl_item_list except dummy_item.
-
-  XXX This is temporary. This routine will be scraped entirely.
-  When slots will be integrated with FOL, there will be some pruning mechanism
-  that will evict items from slot's item_list. But for now, we need to be able
-  to fini() slot for testing purpose. That's why freeing the items explicitly.
- */
-static void slot_item_list_prune(struct c2_rpc_slot *slot)
-{
-	struct c2_rpc_item  *item;
-	struct c2_rpc_item  *reply;
-	struct c2_rpc_item  *next;
-	struct c2_rpc_item  *dummy_item;
-	struct c2_list_link *link;
-	int                  count = 0;
-	bool                 first_item = true;
-
-	/*
-	 * XXX See comments above function prototype
-	 */
-	C2_ASSERT(slot != NULL);
-
-	c2_list_for_each_entry_safe(&slot->sl_item_list, item, next,
-			struct c2_rpc_item, ri_slot_refs[0].sr_link) {
-
-		if (first_item) {
-			/*
-			 * Don't delete dummy item
-			 */
-			first_item = false;
-			continue;
-		}
-		reply = item->ri_reply;
-		if (reply != NULL) {
-			C2_ASSERT(reply->ri_ops != NULL &&
-					reply->ri_ops->rio_free != NULL);
-			reply->ri_ops->rio_free(reply);
-		}
-		item->ri_reply = NULL;
-
-		c2_list_del(&item->ri_slot_refs[0].sr_link);
-
-		C2_ASSERT(item->ri_ops != NULL &&
-				item->ri_ops->rio_free != NULL);
-		item->ri_ops->rio_free(item);
-		count++;
-	}
-        C2_ASSERT(c2_list_length(&slot->sl_item_list) == 1);
-
-        link = c2_list_first(&slot->sl_item_list);
-        C2_ASSERT(link != NULL);
-
-        dummy_item = c2_list_entry(link, struct c2_rpc_item,
-                                   ri_slot_refs[0].sr_link);
-        C2_ASSERT(c2_list_link_is_in(&dummy_item->ri_slot_refs[0].sr_link));
-
-	slot->sl_last_sent = dummy_item;
-	slot->sl_last_persistent = dummy_item;
-}
-
-void c2_rpc_slot_fini(struct c2_rpc_slot *slot)
-{
-	struct c2_rpc_item  *dummy_item;
-	struct c2_fop       *fop;
-	struct c2_list_link *link;
-
-	slot_item_list_prune(slot);
-	c2_list_link_fini(&slot->sl_link);
-	c2_list_fini(&slot->sl_ready_list);
-
-	/*
-	 * Remove the dummy item from the list
-	 */
-	C2_ASSERT(c2_list_length(&slot->sl_item_list) == 1);
-
-	link = c2_list_first(&slot->sl_item_list);
-	C2_ASSERT(link != NULL);
-
-	dummy_item = c2_list_entry(link, struct c2_rpc_item,
-				ri_slot_refs[0].sr_link);
-	C2_ASSERT(c2_list_link_is_in(&dummy_item->ri_slot_refs[0].sr_link));
-
-	c2_list_del(&dummy_item->ri_slot_refs[0].sr_link);
-	C2_ASSERT(dummy_item->ri_slot_refs[0].sr_xid == 0);
-
-	fop = c2_rpc_item_to_fop(dummy_item);
-	c2_fop_free(fop);
-
-	c2_list_fini(&slot->sl_item_list);
-	if (slot->sl_cob != NULL) {
-		c2_cob_put(slot->sl_cob);
-	}
-	C2_SET0(slot);
-}
-
-/**
-   Searches slot->sl_item_list to find item with matching @xid.
-   @return item if found, NULL otherwise.
- */
-static struct c2_rpc_item* item_find(const struct c2_rpc_slot *slot,
-				     uint64_t                  xid)
-{
-	struct c2_rpc_item *item;
-
-	C2_PRE(slot != NULL && c2_mutex_is_locked(&slot->sl_mutex));
-	c2_list_for_each_entry(&slot->sl_item_list, item, struct c2_rpc_item,
-				ri_slot_refs[0].sr_link) {
-
-		if (item->ri_slot_refs[0].sr_xid == xid)
-			return item;
-	}
-	return NULL;
-}
-
-uint32_t c2_rpc_slot_items_possible_inflight(struct c2_rpc_slot *slot)
-{
-	C2_PRE(slot != NULL);
-
-	return slot->sl_max_in_flight - slot->sl_in_flight;
-}
-
-/**
-   If slot->sl_item_list has item(s) in state FUTURE then
-	call slot->sl_ops->so_item_consume() for upto slot->sl_max_in_flight
-	  number of (FUTURE)items. (On sender, each "consumed" item will be
-	  given to formation for transmission. On receiver, "consumed" item is
-	  "dispatched" to request handler for execution)
-   else
-	Notify that the slot is idle (i.e. call slot->sl_ops->so_slot_idle()
-
-   if allow_events is false then items are not consumed.
-   This is required when formation wants to add item to slot->sl_item_list
-   but do not want item to be consumed.
- */
-static void __slot_balance(struct c2_rpc_slot *slot,
-			   bool                allow_events)
-{
-	struct c2_rpc_item  *item;
-	struct c2_list_link *link;
-
-	C2_PRE(slot != NULL);
-	C2_PRE(c2_mutex_is_locked(&slot->sl_mutex));
-	C2_PRE(c2_rpc_slot_invariant(slot));
-
-	while (slot->sl_in_flight < slot->sl_max_in_flight) {
-		/* Is slot->item_list is empty? */
-		link = &slot->sl_last_sent->ri_slot_refs[0].sr_link;
-		if (c2_list_link_is_last(link, &slot->sl_item_list)) {
-			if (allow_events)
-				slot->sl_ops->so_slot_idle(slot);
-			break;
-		}
-		/* Take slot->last_sent->next item for sending */
-		item = c2_list_entry(link->ll_next, struct c2_rpc_item,
-				     ri_slot_refs[0].sr_link);
-
-		if (item->ri_stage == RPC_ITEM_STAGE_FUTURE)
-			item->ri_stage = RPC_ITEM_STAGE_IN_PROGRESS;
-
-		if (item->ri_reply != NULL && !c2_rpc_item_is_update(item)) {
-			/*
-			 * Don't send read only queries for which answer is
-			 * already known
-			 */
-			continue;
-		}
-		slot->sl_last_sent = item;
-		slot->sl_in_flight++;
-		/*
-		 * Tell formation module that an item is ready to be put in rpc
-		 */
-		if (allow_events)
-			slot->sl_ops->so_item_consume(item);
-	}
-	C2_POST(c2_rpc_slot_invariant(slot));
-}
-
-/**
-   For more information see __slot_balance()
-   @see __slot_balance()
- */
-static void slot_balance(struct c2_rpc_slot *slot)
-{
-	__slot_balance(slot, true);
-}
-
-/**
-   @see c2_rpc_slot_item_add_internal()
- */
-static void __slot_item_add(struct c2_rpc_slot *slot,
-			    struct c2_rpc_item *item,
-			    bool                allow_events)
-{
-	struct c2_rpc_slot_ref *sref;
-	struct c2_rpc_session  *session;
-
-	C2_PRE(slot != NULL && item != NULL && slot->sl_session != NULL);
-	C2_PRE(c2_mutex_is_locked(&slot->sl_mutex));
-	C2_PRE(c2_mutex_is_locked(&slot->sl_session->s_mutex));
-	C2_PRE(slot->sl_session == item->ri_session);
-	C2_PRE(c2_rpc_slot_invariant(slot));
-
-	session = slot->sl_session;
-
-	sref                = &item->ri_slot_refs[0];
-	item->ri_stage      = RPC_ITEM_STAGE_FUTURE;
-	sref->sr_session_id = session->s_session_id;
-	sref->sr_sender_id  = session->s_conn->c_sender_id;
-	sref->sr_uuid       = session->s_conn->c_uuid;
-
-	/*
-	 * c2_rpc_slot_item_apply() will provide an item
-	 * which already has verno initialised. Yet, following
-	 * assignment should not be any problem because slot_item_apply()
-	 * will call this routine only if verno of slot and item
-	 * matches
-	 */
-	sref->sr_slot_id    = slot->sl_slot_id;
-	sref->sr_verno      = slot->sl_verno;
-	sref->sr_xid        = slot->sl_xid;
-
-	slot->sl_xid++;
-	if (c2_rpc_item_is_update(item)) {
-		/*
-		 * When integrated with lsn,
-		 * use c2_fol_lsn_allocate() to allocate new lsn and
-		 * use c2_verno_inc() to advance vn_vc.
-		 */
-		slot->sl_verno.vn_lsn++;
-		slot->sl_verno.vn_vc++;
-	}
-
-	sref->sr_slot_gen = slot->sl_slot_gen;
-	sref->sr_slot     = slot;
-	sref->sr_item     = item;
-	c2_list_link_init(&sref->sr_link);
-	c2_list_add_tail(&slot->sl_item_list, &sref->sr_link);
-	if (session != NULL) {
-		/*
-		 * we're already under the cover of session->s_mutex
-		 */
-		session->s_nr_active_items++;
-		if (session->s_state == C2_RPC_SESSION_IDLE) {
-			/*
-			 * XXX When formation adds an item to
-			 * c2_rpc_session::s_unbound_items it should
-			 * set session->s_state as BUSY
-			 */
-			session->s_state = C2_RPC_SESSION_BUSY;
-			c2_cond_broadcast(&session->s_state_changed,
-					  &session->s_mutex);
-		}
-	}
-
-	__slot_balance(slot, allow_events);
-}
-
-void c2_rpc_slot_item_add_internal(struct c2_rpc_slot *slot,
-				   struct c2_rpc_item *item)
-{
-	C2_PRE(slot != NULL && item != NULL);
-	C2_PRE(c2_mutex_is_locked(&slot->sl_mutex));
-	C2_PRE(c2_mutex_is_locked(&slot->sl_session->s_mutex));
-	C2_PRE(slot->sl_session == item->ri_session);
-
-	__slot_item_add(slot, item,
-			false);  /* slot is not allowed to trigger events */
-}
-
-int c2_rpc_slot_misordered_item_received(struct c2_rpc_slot *slot,
-					 struct c2_rpc_item *item)
-{
-	struct c2_rpc_item *reply;
-	struct c2_fop      *fop;
-
-	/*
-	 * Send a dummy NOOP fop as reply to report misordered item
-	 * XXX We should've a special fop type to report session error
-	 */
-	fop = c2_fop_alloc(&c2_rpc_fop_noop_fopt, NULL);
-	if (fop == NULL)
-		return -ENOMEM;
-
-	reply = &fop->f_item;
-
-	reply->ri_session = item->ri_session;
-	reply->ri_error = -EBADR;
-
-	reply->ri_slot_refs[0] = item->ri_slot_refs[0];
-	c2_list_link_init(&reply->ri_slot_refs[0].sr_link);
-	c2_list_link_init(&reply->ri_slot_refs[0].sr_ready_link);
-
-	slot->sl_ops->so_reply_consume(item, reply);
-	return 0;
-}
-
-int c2_rpc_slot_item_apply(struct c2_rpc_slot *slot,
-			   struct c2_rpc_item *item)
-{
-	struct c2_rpc_item *req;
-	int                 redoable;
-	int                 rc = 0;   /* init to 0, required */
-
-	C2_ASSERT(slot != NULL && item != NULL);
-	C2_ASSERT(c2_mutex_is_locked(&slot->sl_mutex));
-	C2_ASSERT(c2_mutex_is_locked(&slot->sl_session->s_mutex));
-	C2_ASSERT(c2_rpc_slot_invariant(slot));
-
-	redoable = c2_verno_is_redoable(&slot->sl_verno,
-					&item->ri_slot_refs[0].sr_verno,
-					false);
-	switch (redoable) {
-	case 0:
-		__slot_item_add(slot, item, true);
-		break;
-	case -EALREADY:
-		req = item_find(slot, item->ri_slot_refs[0].sr_xid);
-		if (req == NULL) {
-			rc = c2_rpc_slot_misordered_item_received(slot,
-								 item);
-			break;
-		}
-		/*
-		 * XXX At this point req->ri_slot_refs[0].sr_verno and
-		 * item->ri_slot_refs[0].sr_verno MUST be same. If they are
-		 * not same then generate ADDB record.
-		 * For now, assert this condition for testing purpose.
-		 */
-		C2_ASSERT(c2_verno_cmp(&req->ri_slot_refs[0].sr_verno,
-				&item->ri_slot_refs[0].sr_verno) == 0);
-
-		switch (req->ri_stage) {
-		case RPC_ITEM_STAGE_PAST_VOLATILE:
-		case RPC_ITEM_STAGE_PAST_COMMITTED:
-			/*
-			 * @item is duplicate and corresponding original is
-			 * already consumed (i.e. executed if item is FOP).
-			 * Consume cached reply. (on receiver, this means
-			 * resend cached reply)
-			 */
-			C2_ASSERT(req->ri_reply != NULL);
-			slot->sl_ops->so_reply_consume(req,
-						req->ri_reply);
-			break;
-		case RPC_ITEM_STAGE_IN_PROGRESS:
-		case RPC_ITEM_STAGE_FUTURE:
-			/* item is already present but is not
-			   processed yet. Ignore it*/
-			/* do nothing */;
-		}
-		break;
-	case -EAGAIN:
-		rc = c2_rpc_slot_misordered_item_received(slot, item);
-		break;
-	}
-	C2_ASSERT(c2_rpc_slot_invariant(slot));
-	return rc;
-}
-
-void c2_rpc_slot_reply_received(struct c2_rpc_slot  *slot,
-				struct c2_rpc_item  *reply,
-				struct c2_rpc_item **req_out)
-{
-	struct c2_rpc_item     *req;
-	struct c2_rpc_slot_ref *sref;
-	struct c2_rpc_session  *session;
-
-	C2_PRE(slot != NULL && reply != NULL && req_out != NULL);
-	C2_PRE(c2_mutex_is_locked(&slot->sl_mutex));
-
-	*req_out = NULL;
-
-	sref = &reply->ri_slot_refs[0];
-	C2_ASSERT(slot == sref->sr_slot);
-
-	req = item_find(slot, reply->ri_slot_refs[0].sr_xid);
-	if (req == NULL) {
-		/*
-		 * Either it is a duplicate reply and its corresponding request
-		 * item is pruned from the item list, or it is a corrupted
-		 * reply
-		 */
-		return;
-	}
-	/*
-	 * XXX At this point req->ri_slot_refs[0].sr_verno and
-	 * reply->ri_slot_refs[0].sr_verno MUST be same. If they are not,
-	 * then generate ADDB record.
-	 * For now, assert this condition for testing purpose.
-	 */
-	C2_ASSERT(c2_verno_cmp(&req->ri_slot_refs[0].sr_verno,
-			&reply->ri_slot_refs[0].sr_verno) == 0);
-
-	if (c2_verno_cmp(&req->ri_slot_refs[0].sr_verno,
-		&slot->sl_last_sent->ri_slot_refs[0].sr_verno) > 0) {
-		/*
-		 * Received a reply to an item that wasn't sent. This is
-		 * possible if the receiver failed and forget about some
-		 * items. The sender moved last_seen to the past, but then a
-		 * late reply to one of items unreplied before the failure
-		 * arrived.
-		 *
-		 * Such reply must be ignored
-		 */
-		;
-	} else if (req->ri_stage == RPC_ITEM_STAGE_PAST_COMMITTED ||
-			req->ri_stage == RPC_ITEM_STAGE_PAST_VOLATILE) {
-		/*
-		 * Got a reply to an item for which the reply was already
-		 * received in the past. Compare with the original reply.
-		 * XXX find out how to compare two rpc items to be same
-		 */
-	} else {
-		/*
-		 * This is valid reply case.
-		 */
-		C2_ASSERT(req->ri_stage == RPC_ITEM_STAGE_IN_PROGRESS);
-		C2_ASSERT(slot->sl_in_flight > 0);
-
-		session = slot->sl_session;
-		C2_ASSERT(session != NULL);
-
-		c2_mutex_lock(&session->s_mutex);
-		C2_ASSERT(c2_rpc_session_invariant(session));
-		C2_ASSERT(session->s_state == C2_RPC_SESSION_BUSY);
-		C2_ASSERT(session->s_nr_active_items > 0);
-
-		req->ri_stage = RPC_ITEM_STAGE_PAST_VOLATILE;
-		req->ri_reply = reply;
-		*req_out = req;
-		slot->sl_in_flight--;
-
-		session->s_nr_active_items--;
-		/*
-		 * Setting of req->ri_stage to PAST_VOLATILE and reducing
-		 * session->s_nr_active_items must be in same critical
-		 * region protected by session->s_mutex.
-		 */
-		if (session->s_nr_active_items == 0 &&
-			c2_list_is_empty(&session->s_unbound_items)) {
-			session->s_state = C2_RPC_SESSION_IDLE;
-			/*
-			 * ->s_state_change is broadcast after slot_balance()
-			 * call in this function.
-			 * Cannot broadcast on session->s_state_changed here.
-			 * Doing so introduces a race condition:
-			 *
-			 * - User thread might be waiting for session to be
-			 *   IDLE, so that it can call
-			 *   c2_rpc_session_terminate().
-			 * - current thread broadcasts on s_state_changed
-			 * - the user thread will come out of wait, and issue
-			 *   c2_rpc_session_terminate(), which removes all
-			 *   slots of the IDLE session, from ready_slots list.
-			 * - current thread continues execution and calls
-			 *   slot_balance(), which will trigger
-			 *   slot->sl_ops->so_slot_idle() event, resulting in
-			 *   slot placed again on ready_slots list.
-			 *   A TERMINATING session must not have any of its
-			 *   slots on ready_slots list.
-			 * - session invariant catches this, in
-			 *   c2_rpc_session_terminate_reply_received()
-			 */
-		}
-		C2_ASSERT(c2_rpc_session_invariant(session));
-		c2_mutex_unlock(&session->s_mutex);
-
-		slot_balance(slot);
-
-		c2_mutex_lock(&session->s_mutex);
-		C2_ASSERT(c2_rpc_session_invariant(session));
-
-		if (session->s_state == C2_RPC_SESSION_IDLE) {
-			c2_cond_broadcast(&session->s_state_changed,
-					&session->s_mutex);
-		}
-		c2_mutex_unlock(&session->s_mutex);
-
-		/*
-		 * On receiver, ->so_reply_consume(req, reply) will hand over
-		 * @reply to formation, to send it back to sender.
-		 * see: rcv_reply_consume(), snd_reply_consume()
-		 */
-		slot->sl_ops->so_reply_consume(req, reply);
-		/*
-		 * XXX On receiver, there is a potential race, from this point
-		 * to slot mutex unlock in c2_rpc_reply_post().
-		 * - Context switch happens at this point. slot->sl_mutex is
-		 *   yet to be unlocked.
-		 * - @reply reaches back to sender. This might make sender side
-		 *   session IDLE.
-		 * - sender sends SESSION_TERMINATE.
-		 * - SESSION_TERMINATE fop gets submitted to reqh and completes
-		 *    its execution. As part of session termination it frees all
-		 *    session and slot objects.
-		 * - execution of this thread resumes from this point.
-		 * - control returns to c2_rpc_reply_post() which tries to
-		 *   unlock the mutex, but the mutex is embeded in slot and
-		 *   slot is already freed during session termination. BOOM!!!
-		 * - Holding session mutex across c2_rpc_slot_reply_received()
-		 *   might sound obvious solution, but formation tries to
-		 *   aquire same session mutex while processing reply item,
-		 *   leading to self deadlock.
-		 */
-	}
-}
-
-void c2_rpc_slot_persistence(struct c2_rpc_slot *slot,
-			     struct c2_verno     last_persistent)
-{
-	struct c2_rpc_item     *item;
-	struct c2_list_link    *link;
-
-	C2_PRE(slot != NULL && c2_mutex_is_locked(&slot->sl_mutex));
-
-	/*
-	 * From last persistent item to end of slot->item_list,
-	 *    if item->verno <= @last_persistent
-	 *       Mark item as PAST_COMMITTED
-	 *    else
-	 *       break
-	 */
-	link = &slot->sl_last_persistent->ri_slot_refs[0].sr_link;
-	for (; link != (void *)&slot->sl_item_list; link = link->ll_next) {
-
-		item = c2_list_entry(link, struct c2_rpc_item,
-					ri_slot_refs[0].sr_link);
-
-		if (c2_verno_cmp(&item->ri_slot_refs[0].sr_verno,
-				&last_persistent) <= 0) {
-
-			C2_ASSERT(
-			   item->ri_stage == RPC_ITEM_STAGE_PAST_COMMITTED ||
-			   item->ri_stage == RPC_ITEM_STAGE_PAST_VOLATILE);
-
-			item->ri_stage = RPC_ITEM_STAGE_PAST_COMMITTED;
-			slot->sl_last_persistent = item;
-		} else {
-			break;
-		}
-	}
-	C2_POST(
-	   c2_verno_cmp(&slot->sl_last_persistent->ri_slot_refs[0].sr_verno,
-			&last_persistent) >= 0);
-}
-
-void c2_rpc_slot_reset(struct c2_rpc_slot *slot,
-		       struct c2_verno     last_seen)
-{
-	struct c2_rpc_item     *item;
-	struct c2_rpc_slot_ref *sref;
-
-	C2_PRE(slot != NULL && c2_mutex_is_locked(&slot->sl_mutex));
-	C2_PRE(c2_verno_cmp(&slot->sl_verno, &last_seen) >= 0);
-
-	c2_list_for_each_entry(&slot->sl_item_list, item, struct c2_rpc_item,
-				ri_slot_refs[0].sr_link) {
-
-		sref = &item->ri_slot_refs[0];
-		if (c2_verno_cmp(&sref->sr_verno, &last_seen) == 0) {
-			C2_ASSERT(item->ri_stage != RPC_ITEM_STAGE_FUTURE);
-			slot->sl_last_sent = item;
-			break;
-		}
-
-	}
-	C2_ASSERT(c2_verno_cmp(&slot->sl_last_sent->ri_slot_refs[0].sr_verno,
-				&last_seen) == 0);
-	slot_balance(slot);
-}
-
-static int associate_session_and_slot(struct c2_rpc_item   *item,
-				      struct c2_rpcmachine *machine)
-{
-	struct c2_list         *conn_list;
-	struct c2_rpc_conn     *conn;
-	struct c2_rpc_session  *session;
-	struct c2_rpc_slot     *slot;
-	struct c2_rpc_slot_ref *sref;
-	bool                    found;
-	bool                    use_uuid;
-
-	sref = &item->ri_slot_refs[0];
-	if (sref->sr_session_id > SESSION_ID_MAX)
-		return -EINVAL;
-
-	conn_list = c2_rpc_item_is_request(item) ?
-			&machine->cr_incoming_conns :
-			&machine->cr_outgoing_conns;
-
-	use_uuid = (sref->sr_sender_id == SENDER_ID_INVALID);
-
-	c2_mutex_lock(&machine->cr_session_mutex);
-	found = false;
-	c2_list_for_each_entry(conn_list, conn, struct c2_rpc_conn, c_link) {
-
-		found = use_uuid ?
-		   c2_rpc_sender_uuid_cmp(&conn->c_uuid, &sref->sr_uuid) == 0 :
-		   conn->c_sender_id == sref->sr_sender_id;
-		if (found)
-			break;
-
-	}
-	c2_mutex_unlock(&machine->cr_session_mutex);
-	if (!found)
-		return -ENOENT;
-
-	c2_mutex_lock(&conn->c_mutex);
-	session = c2_rpc_session_search(conn, sref->sr_session_id);
-	c2_mutex_unlock(&conn->c_mutex);
-	if (session == NULL)
-		return -ENOENT;
-
-	c2_mutex_lock(&session->s_mutex);
-	if (sref->sr_slot_id >= session->s_nr_slots) {
-		c2_mutex_unlock(&session->s_mutex);
-		return -ENOENT;
-	}
-	slot = session->s_slot_table[sref->sr_slot_id];
-	/* XXX Check generation of slot */
-	C2_ASSERT(slot != NULL);
-	sref->sr_slot = slot;
-	item->ri_session = session;
-	C2_POST(item->ri_session != NULL &&
-		item->ri_slot_refs[0].sr_slot != NULL);
-	c2_mutex_unlock(&session->s_mutex);
-
-	return 0;
-}
-
-int c2_rpc_item_received(struct c2_rpc_item   *item,
-			 struct c2_rpcmachine *machine)
-{
-	struct c2_rpc_item *req;
-	struct c2_rpc_slot *slot;
-	int                 rc;
-
-	C2_ASSERT(item != NULL && machine != NULL);
-
-	rc = associate_session_and_slot(item, machine);
-	if (rc != 0) {
-		/*
-		 * stats for conn establish item are updated in its
-		 * fom's state() method.
-		 */
-		if (c2_rpc_item_is_conn_establish(item)) {
-			c2_rpc_item_dispatch(item);
-			return 0;
-		}
-		/*
-		 * If we cannot associate the item with its slot
-		 * then there is nothing that we can do with this
-		 * item except to discard it.
-		 * XXX generate ADDB record
-		 */
-		return rc;
-	}
-	C2_ASSERT(item->ri_session != NULL &&
-		  item->ri_slot_refs[0].sr_slot != NULL);
-
-	item_exit_stats_set(item, C2_RPC_PATH_INCOMING);
-
-	slot = item->ri_slot_refs[0].sr_slot;
-	if (c2_rpc_item_is_request(item)) {
-		c2_mutex_lock(&slot->sl_mutex);
-		c2_mutex_lock(&slot->sl_session->s_mutex);
-
-		c2_rpc_slot_item_apply(slot, item);
-
-		c2_mutex_unlock(&slot->sl_session->s_mutex);
-		c2_mutex_unlock(&slot->sl_mutex);
-	} else {
-		c2_mutex_lock(&slot->sl_mutex);
-		c2_rpc_slot_reply_received(slot, item, &req);
-		c2_mutex_unlock(&slot->sl_mutex);
-
-		/*
-		 * In case the reply is duplicate/unwanted then
-		 * c2_rpc_slot_reply_received() sets req to NULL.
-		 */
-		if (req != NULL) {
-			/* Send reply received event to formation component.*/
-			frm_item_reply_received(item, req);
-			/*
-			 * informing upper layer that reply is received should
-			 * be the done after all the reply processing has been
-			 * done by rpc-layer.
-			 */
-			rpc_item_replied(req, item, 0);
-		}
-	}
-	return 0;
-}
-
-void rpc_item_replied(struct c2_rpc_item *item, struct c2_rpc_item *reply,
-                      uint32_t rc)
-{
-	bool broadcast = true;
-
-	item->ri_error = rc;
-	item->ri_reply = reply;
-
-	if (c2_rpc_item_is_conn_terminate(item))
-		broadcast = false;
-
-	if (item->ri_ops != NULL && item->ri_ops->rio_replied != NULL)
-		item->ri_ops->rio_replied(item);
-
-	/*
-	 * If item is of type conn terminate reply,
-	 * then req and item (including any of its associated
-	 * rpc layer structures e.g. session, frm_sm etc.)
-	 * should not be accessed from this point onwards.
-	 */
-	if (broadcast)
-		c2_chan_broadcast(&item->ri_chan);
-}
-
-int c2_rpc_slot_cob_lookup(struct c2_cob   *session_cob,
-			   uint32_t         slot_id,
-			   uint64_t         slot_generation,
-			   struct c2_cob  **slot_cob,
-			   struct c2_db_tx *tx)
-{
-	struct c2_cob *cob;
-	char           name[SESSION_COB_MAX_NAME_LEN];
-	int            rc;
-
-	C2_PRE(session_cob != NULL && slot_cob != NULL);
-
-	*slot_cob = NULL;
-	sprintf(name, "SLOT_%u:%lu", slot_id, (unsigned long)slot_generation);
-
-	rc = c2_rpc_cob_lookup_helper(session_cob->co_dom, session_cob, name,
-					&cob, tx);
-	C2_ASSERT(ergo(rc != 0, cob == NULL));
-	*slot_cob = cob;
-	return rc;
-}
-
-int c2_rpc_slot_cob_create(struct c2_cob   *session_cob,
-			   uint32_t         slot_id,
-			   uint64_t         slot_generation,
-			   struct c2_cob  **slot_cob,
-			   struct c2_db_tx *tx)
-{
-	struct c2_cob *cob;
-	char           name[SESSION_COB_MAX_NAME_LEN];
-	int            rc;
-
-	C2_PRE(session_cob != NULL && slot_cob != NULL);
-
-	*slot_cob = NULL;
-	sprintf(name, "SLOT_%u:%lu", slot_id, (unsigned long)slot_generation);
-
-	rc = c2_rpc_cob_create_helper(session_cob->co_dom, session_cob, name,
-					&cob, tx);
-	C2_ASSERT(ergo(rc != 0, cob == NULL));
-	*slot_cob = cob;
-	return rc;
-}
-
-/**
-   Just for debugging purpose.
- */
-#ifndef __KERNEL__
-void c2_rpc_slot_item_list_print(struct c2_rpc_slot *slot)
-{
-	struct c2_rpc_item *item;
-	char                str_stage[][20] = {
-				"INVALID",
-				"PAST_COMMITTED",
-				"PAST_VOLATILE",
-				"IN_PROGRESS",
-				"FUTURE"
-			     };
-
-	c2_list_for_each_entry(&slot->sl_item_list, item,
-				struct c2_rpc_item,
-				ri_slot_refs[0].sr_link) {
-		printf("item %p xid %lu state %s\n", item,
-				item->ri_slot_refs[0].sr_xid,
-				str_stage[item->ri_stage]);
-	}
-}
-#endif
-bool c2_rpc_slot_can_item_add_internal(const struct c2_rpc_slot *slot)
-{
-	C2_PRE(c2_mutex_is_locked(&slot->sl_mutex));
-
-	return slot->sl_in_flight < slot->sl_max_in_flight;
-}
diff --git a/rpc/slot.h b/rpc/slot.h
index 25d0147..4a7326b 100644
--- a/rpc/slot.h
+++ b/rpc/slot.h
@@ -14,7 +14,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Alexey Lyashkov <Alexey_Lyashkov@xyratex.com>
+ * Original author: Alexey Lyashkov
  * Original creation date: 05/12/2010
  */
 
diff --git a/rpc/ut/.gitignore b/rpc/ut/.gitignore
index 05e029f..7f10207 100644
--- a/rpc/ut/.gitignore
+++ b/rpc/ut/.gitignore
@@ -1,4 +1,2 @@
 rclient
 rserver
-onwire_ut
-test_u.[ch]
diff --git a/rpc/ut/Makefile.am b/rpc/ut/Makefile.am
index de7150d..ae2bd46 100644
--- a/rpc/ut/Makefile.am
+++ b/rpc/ut/Makefile.am
@@ -1,33 +1,11 @@
-INCLUDES          = -I. -I$(top_srcdir) -I$(top_srcdir)/include -I../
+noinst_PROGRAMS   = rclient rserver
 
-#noinst_PROGRAMS   = rclient rserver
-# noinst_PROGRAMS   = onwire_ut
+rclient_SOURCES   = rpc-client.c
+rclient_LDFLAGS   = -pthread
+rclient_LDADD     = $(top_builddir)/colibri/libcolibri.la
 
-#noinst_LTLIBRARIES = librpccore-ut.la
-noinst_LTLIBRARIES = librpclib-ut.la libonwire-ut.la
+rserver_SOURCES   = rpc-server.c
+rserver_LDFLAGS   = -pthread
+rserver_LDADD     = $(top_builddir)/colibri/libcolibri.la
 
-#rclient_SOURCES   = rpc-client.c
-#rclient_LDFLAGS   = -pthread
-#rclient_LDADD     = $(top_builddir)/colibri/libcolibri.la
 
-#rserver_SOURCES   = rpc-server.c
-#rserver_LDFLAGS   = -pthread
-#rserver_LDADD     = $(top_builddir)/colibri/libcolibri.la
-
-librpclib_ut_la_SOURCES = rpclib_ut.c ../it/ping_fop.c ../it/ping_fop_u.c ../it/ping_fom.c
-
-librpclib_ut_la_LIBADD = $(top_builddir)/colibri/libcolibri.la
-
-#noinst_LTLIBRARIES = libonwire-ut.la
-test_u.h test_u.c : test.ff \
-	$(top_builddir)/fop/rt/libc2rt.la \
-	$(top_builddir)/fop/fop2c
-	$(top_builddir)/fop/fop2c -u $<
-
-libonwire_ut_la_SOURCES     = test_u.h test_u.c onwire_ut.c
-
-EXTRA_DIST = test.ff
-
-clean-local:
-	cd @SRCDIR@/rpc/ut ; \
-	rm -fr test_[uk].[ch]
diff --git a/rpc/ut/onwire_ut.c b/rpc/ut/onwire_ut.c
deleted file mode 100644
index 218223d..0000000
--- a/rpc/ut/onwire_ut.c
+++ /dev/null
@@ -1,197 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Subhash Arya <subhash_arya@xyratex.com>
- * Original creation date: 06/25/2011
- */
-#include <stdio.h>
-#include "lib/errno.h"
-#include "colibri/init.h"
-#include "lib/memory.h"
-#include "lib/bitstring.h"
-#include "lib/misc.h"
-#include "lib/trace.h"
-#include "fop/fop.h"
-#include "fop/fop_format_def.h"
-#include "fop/fop_format.h"
-#include "rpc/ut/test_u.h"
-#include "rpc/ut/test.ff"
-#include "rpc/rpc2.h"
-#include "fop/fop_base.h"
-#include "fop/fop_item_type.h"
-#include "rpc/rpc_onwire.h"
-#include "xcode/bufvec_xcode.h"
-#include "lib/vec.h"
-#include "rpc/session_internal.h"
-#include "rpc/rpc_base.h"
-#include "lib/ut.h"
-#include "rpc/rpc_opcodes.h"
-
-extern struct c2_fop_type_format c2_fop_onwire_test_tfmt;
-extern struct c2_fop_type_format c2_fop_onwire_test_arr_tfmt;
-
-static struct c2_rpc rpc_obj;
-
-struct c2_fop_type_ops onwire_test_ops = {
-	.fto_size_get = c2_xcode_fop_size_get,
-};
-
-
-size_t test_item_size_get(const struct c2_rpc_item *item)
-{
-	uint64_t	len = 0;
-	struct c2_fop	*fop;
-
-	C2_PRE(item != NULL);
-
-	fop = c2_rpc_item_to_fop(item);
-	if(fop != NULL)	{
-		len = fop->f_type->ft_ops->fto_size_get(fop);
-		len += ITEM_ONWIRE_HEADER_SIZE;
-	}
-		return (size_t)len;
-}
-
-C2_FOP_TYPE_DECLARE(c2_fop_onwire_test, "onwire test", &onwire_test_ops,
-		    C2_RPC_ONWIRE_UT_OPCODE, C2_RPC_ITEM_TYPE_REQUEST);
-
-static struct c2_verno verno = {
-	.vn_lsn = 1111,
-	.vn_vc = 2222,
-};
-
-static struct c2_verno p_no = {
-	.vn_lsn = 3333,
-	.vn_vc = 4444
-};
-
-static struct c2_verno ls_no = {
-	.vn_lsn = 55555,
-	.vn_vc = 6666
-};
-
-void populate_item(struct c2_rpc_item *item)
-{
-	struct c2_rpc_slot_ref	slot_ref;
-
-	item->ri_slot_refs[0].sr_sender_id = 0xdead;
-	item->ri_slot_refs[0].sr_session_id = 0xbeef;
-	item->ri_slot_refs[0].sr_uuid.su_uuid = 0xeaeaeaea;
-	slot_ref.sr_xid  = 0x11111111;
-	slot_ref.sr_slot_gen = 0x22222222;
-	slot_ref.sr_slot_id = 0x666;
-	slot_ref.sr_verno = verno;
-	slot_ref.sr_last_persistent_verno = p_no;
-	slot_ref.sr_last_seen_verno = ls_no;
-	item->ri_slot_refs[0] = slot_ref;
-}
-
-void populate_rpc_obj(struct c2_rpc *rpc, struct c2_rpc_item *item)
-{
-
-	c2_list_add(&rpc->r_items, &item->ri_rpcobject_linkage);
-}
-
-static void rpc_encdec_test(void)
-{
-	struct c2_fop			*f1, *f2, *f3;
-	struct c2_fop_onwire_test		*ccf1, *ccf2, *ccf3;
-	int				rc;
-	struct c2_rpc_item		*item1, *item2, *item3;
-	struct c2_rpc			*obj, obj2;
-	struct c2_net_buffer		*nb;
-	struct c2_bufvec_cursor		cur;
-	void				*cur_addr;
-
-	/* Onwire tests */
-	C2_ALLOC_PTR(item1);
-	C2_ALLOC_PTR(item2);
-	C2_ALLOC_PTR(item3);
-
-	rc = c2_fop_type_format_parse(&c2_fop_onwire_test_arr_tfmt);;
-	rc = c2_fop_type_build(&c2_fop_onwire_test_fopt);
-	C2_UT_ASSERT(rc == 0);
-	f1 = c2_fop_alloc(&c2_fop_onwire_test_fopt, NULL);
-	C2_UT_ASSERT(f1 != NULL);
-	f2 = c2_fop_alloc(&c2_fop_onwire_test_fopt, NULL);
-	C2_UT_ASSERT(f2 != NULL);
-	f3 = c2_fop_alloc(&c2_fop_onwire_test_fopt, NULL);
-	C2_UT_ASSERT(f3 != NULL);
-
-	ccf1 = c2_fop_data(f1);
-	C2_UT_ASSERT(ccf1 != NULL);
-	ccf1->t_arr.t_count = 4;
-	C2_ALLOC_ARR(ccf1->t_arr.t_data, 4);
-	ccf1->t_arr.t_data[0] = 0xa;
-	ccf1->t_arr.t_data[1] = 0xb;
-	ccf1->t_arr.t_data[2] = 0xc;
-	ccf1->t_arr.t_data[3] = 0xd;
-
-	ccf2 = c2_fop_data(f2);
-	C2_UT_ASSERT(ccf2 != NULL);
-	ccf2->t_arr.t_count = 4;
-	C2_ALLOC_ARR(ccf2->t_arr.t_data, 4);
-	ccf2->t_arr.t_data[0] = 0xa;
-	ccf2->t_arr.t_data[1] = 0xb;
-	ccf2->t_arr.t_data[2] = 0xc;
-	ccf2->t_arr.t_data[3] = 0xd;
-
-	ccf3 = c2_fop_data(f3);
-	C2_UT_ASSERT(ccf3 != NULL);
-	ccf3->t_arr.t_count = 4;
-	C2_ALLOC_ARR(ccf3->t_arr.t_data, 4);
-	ccf3->t_arr.t_data[0] = 0xa;
-	ccf3->t_arr.t_data[1] = 0xb;
-	ccf3->t_arr.t_data[2] = 0xc;
-	ccf3->t_arr.t_data[3] = 0xd;
-
-	item1 = &f1->f_item;
-	item2 = &f2->f_item;
-	item3 = &f3->f_item;
-	populate_item(item1);
-	populate_item(item2);
-	populate_item(item3);
-
-	obj = &rpc_obj;
-	c2_list_init(&obj->r_items);
-
-	populate_rpc_obj(obj, item1);
-	populate_rpc_obj(obj, item2);
-	populate_rpc_obj(obj, item3);
-
-	C2_ALLOC_PTR(nb);
-	c2_bufvec_alloc(&nb->nb_buffer, 13, 72);
-	c2_bufvec_cursor_init(&cur, &nb->nb_buffer);
-	cur_addr = c2_bufvec_cursor_addr(&cur);
-	C2_UT_ASSERT(C2_IS_8ALIGNED(cur_addr));
-	rc =  c2_rpc_encode(obj, nb);
-	C2_UT_ASSERT(rc == 0);
-	c2_list_init(&obj2.r_items);
-	rc = c2_rpc_decode(&obj2, nb);
-	C2_UT_ASSERT(rc == 0);
-	c2_fop_type_fini(&c2_fop_onwire_test_fopt);
-}
-
-const struct c2_test_suite rpc_onwire_ut = {
-        .ts_name = "onwire-ut",
-        .ts_init = NULL,
-        .ts_fini = NULL,
-        .ts_tests = {
-                { "onwire enc/decode", rpc_encdec_test },
-                { NULL, NULL }
-        }
-};
-
diff --git a/rpc/ut/rpclib_ut.c b/rpc/ut/rpclib_ut.c
deleted file mode 100644
index 284b14c..0000000
--- a/rpc/ut/rpclib_ut.c
+++ /dev/null
@@ -1,190 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Dmitriy Chumak <dmitriy_chumak@xyratex.com>
- * Original creation date: 09/28/2011
- */
-
-#include "lib/ut.h"
-#include "lib/memory.h"
-#include "lib/processor.h"
-#include "lib/trace.h"
-#include "addb/addb.h"
-#include "fop/fop.h"
-#include "reqh/reqh.h"
-
-#include "rpc/session.h"
-#include "rpc/it/ping_fop.h"
-#ifdef __KERNEL__
-#include "rpc/it/ping_fop_k.h"
-#else
-#include "rpc/it/ping_fop_u.h"
-#endif
-#include "rpc/rpclib.h"
-
-#include "ut/rpc.h"
-#include "ut/cs_service.h"
-#include "ut/cs_fop_foms.h"
-#include "ut/cs_test_fops_u.h"
-
-
-#define CLIENT_ENDPOINT_ADDR	"127.0.0.1:12345:2"
-#define CLIENT_DB_NAME		"rpclib_ut_client.db"
-
-#define SERVER_ENDPOINT_ADDR	"127.0.0.1:12345:1"
-#define SERVER_ENDPOINT		"bulk-sunrpc:" SERVER_ENDPOINT_ADDR
-#define SERVER_DB_FILE_NAME	"rpclib_ut_server.db"
-#define SERVER_STOB_FILE_NAME	"rpclib_ut_server.stob"
-#define SERVER_LOG_FILE_NAME	"rpclib_ut_server.log"
-
-enum {
-	CLIENT_COB_DOM_ID	= 16,
-	SESSION_SLOTS		= 1,
-	MAX_RPCS_IN_FLIGHT	= 1,
-	CONNECT_TIMEOUT		= 5,
-};
-
-extern struct c2_net_xprt c2_net_bulk_sunrpc_xprt;
-
-
-static int send_fop(struct c2_rpc_session *session)
-{
-	int                   rc;
-	struct c2_fop         *fop;
-	struct cs_ds2_req_fop *cs_ds2_fop;
-
-	fop = c2_fop_alloc(&cs_ds2_req_fop_fopt, NULL);
-	C2_UT_ASSERT(fop != NULL);
-	if (fop == NULL) {
-		rc = -ENOMEM;
-		goto out;
-	}
-
-	cs_ds2_fop = c2_fop_data(fop);
-	cs_ds2_fop->csr_value = 0xaaf5;
-
-	rc = c2_rpc_client_call(fop, session, &cs_ds_req_fop_rpc_item_ops,
-				CONNECT_TIMEOUT);
-	C2_UT_ASSERT(rc == 0);
-	C2_UT_ASSERT(fop->f_item.ri_error == 0);
-	C2_UT_ASSERT(fop->f_item.ri_reply != 0);
-
-	/* FIXME: freeing fop here will lead to endless loop in
-	 * nr_active_items_count(), which is called from
-	 * c2_rpc_session_terminate() */
-	/*c2_fop_free(fop);*/
-out:
-	return rc;
-}
-
-static void test_rpclib(void)
-{
-	int rc;
-	struct c2_net_xprt    *xprt = &c2_net_bulk_sunrpc_xprt;
-	struct c2_net_domain  client_net_dom = { };
-	struct c2_dbenv       client_dbenv;
-	struct c2_cob_domain  client_cob_dom;
-
-	char *server_argv[] = {
-		"rpclib_ut", "-r", "-T", "AD", "-D", SERVER_DB_FILE_NAME,
-		"-S", SERVER_STOB_FILE_NAME, "-e", SERVER_ENDPOINT,
-		"-s", "ds1", "-s", "ds2"
-	};
-
-	C2_RPC_SERVER_CTX_DECLARE_SIMPLE(sctx, xprt, server_argv,
-				  SERVER_LOG_FILE_NAME);
-
-	struct c2_rpc_client_ctx cctx = {
-		.rcx_net_dom            = &client_net_dom,
-		.rcx_local_addr         = CLIENT_ENDPOINT_ADDR,
-		.rcx_remote_addr        = SERVER_ENDPOINT_ADDR,
-		.rcx_db_name            = CLIENT_DB_NAME,
-		.rcx_dbenv              = &client_dbenv,
-		.rcx_cob_dom_id         = CLIENT_COB_DOM_ID,
-		.rcx_cob_dom            = &client_cob_dom,
-		.rcx_nr_slots           = SESSION_SLOTS,
-		.rcx_timeout_s          = CONNECT_TIMEOUT,
-		.rcx_max_rpcs_in_flight = MAX_RPCS_IN_FLIGHT,
-	};
-
-	/*
-	 * There is no need to initialize xprt explicitly if client and server
-	 * run withing a single process, because in this case transport is
-	 * initialized by c2_rpc_server_start().
-	 */
-
-	rc = c2_net_domain_init(&client_net_dom, xprt);
-	C2_UT_ASSERT(rc == 0);
-	if (rc != 0)
-		goto out;
-
-	rc = c2_rpc_server_start(&sctx);
-	C2_UT_ASSERT(rc == 0);
-	if (rc != 0)
-		goto net_dom_fini;
-
-	rc = c2_rpc_client_init(&cctx);
-	C2_UT_ASSERT(rc == 0);
-	if (rc != 0)
-		goto server_fini;
-
-	rc = send_fop(&cctx.rcx_session);
-	C2_UT_ASSERT(rc == 0);
-
-	rc = c2_rpc_client_fini(&cctx);
-	C2_UT_ASSERT(rc == 0);
-
-server_fini:
-	c2_rpc_server_stop(&sctx);
-net_dom_fini:
-	c2_net_domain_fini(&client_net_dom);
-out:
-	return;
-}
-
-static int test_rpclib_init(void)
-{
-	/* set ADDB leve to AEL_WARN to see ADDB messages on STDOUT */
-	/*c2_addb_choose_default_level(AEL_WARN);*/
-
-	return 0;
-}
-
-static int test_rpclib_fini(void)
-{
-	return 0;
-}
-
-const struct c2_test_suite rpclib_ut = {
-	.ts_name = "rpclib-ut",
-	.ts_init = test_rpclib_init,
-	.ts_fini = test_rpclib_fini,
-	.ts_tests = {
-		{ "rpclib", test_rpclib },
-		{ NULL, NULL }
-	}
-};
-
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
diff --git a/rpc/ut/test.ff b/rpc/ut/test.ff
deleted file mode 100644
index e2d24ea..0000000
--- a/rpc/ut/test.ff
+++ /dev/null
@@ -1,8 +0,0 @@
-
-DEF(c2_fop_onwire_test_arr, SEQUENCE,
-   _(t_count, U64),
-   _(t_data, U32));
-
-DEF(c2_fop_onwire_test, RECORD,
-  _(t_arr, c2_fop_onwire_test_arr));
-
diff --git a/rpc/xdr/common.c b/rpc/xdr/common.c
index 39496cb..dad148a 100644
--- a/rpc/xdr/common.c
+++ b/rpc/xdr/common.c
@@ -14,7 +14,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Alexey Lyashkov <Alexey_Lyashkov@xyratex.com>
+ * Original author: Alexey Lyashkov
  * Original creation date: 05/18/2010
  */
 
diff --git a/rpc/xdr/common.h b/rpc/xdr/common.h
index 0330673..8e0d0e1 100644
--- a/rpc/xdr/common.h
+++ b/rpc/xdr/common.h
@@ -13,7 +13,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Alexey Lyashkov <Alexey_Lyashkov@xyratex.com>
+ * Original author: Alexey Lyashkov
  * Original creation date: 05/18/2010
  */
 
diff --git a/rpc/xdr/session.c b/rpc/xdr/session.c
index bf361c3..71fe1be 100644
--- a/rpc/xdr/session.c
+++ b/rpc/xdr/session.c
@@ -14,7 +14,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Alexey Lyashkov <Alexey_Lyashkov@xyratex.com>
+ * Original author: Alexey Lyashkov
  * Original creation date: 05/18/2010
  */
 
diff --git a/rpc/xdr/session.h b/rpc/xdr/session.h
index 86646db..b5edd1c 100644
--- a/rpc/xdr/session.h
+++ b/rpc/xdr/session.h
@@ -13,7 +13,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Alexey Lyashkov <Alexey_Lyashkov@xyratex.com>
+ * Original author: Alexey Lyashkov
  * Original creation date: 05/18/2010
  */
 
diff --git a/sm/Makefile.am b/sm/Makefile.am
index 68b5ffe..d829e9e 100644
--- a/sm/Makefile.am
+++ b/sm/Makefile.am
@@ -1,4 +1,4 @@
-smdir                     = $(includedir)/colibri/sm
+smdir                     = $(includedir)/sm
 sm_HEADERS                = sm.h
 
 noinst_LTLIBRARIES        = libcolibri-sm.la
diff --git a/sm/sm.c b/sm/sm.c
index dd31955..4ce4e57 100644
--- a/sm/sm.c
+++ b/sm/sm.c
@@ -14,347 +14,90 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Nikita Danilov <Nikita_Danilov@xyratex.com>
+ * Original author: Nikita Danilov
  * Original creation date: 04/01/2010
  */
 
-#include "lib/errno.h"              /* ESRCH */
-#include "lib/misc.h"               /* C2_SET0 */
-#include "lib/cdefs.h"              /* C2_EXPORTED */
-#include "lib/mutex.h"
-#include "lib/arith.h"              /* c2_is_po2 */
-#include "addb/addb.h"
-#include "sm/sm.h"
+#include "sm.h"
 
 /**
    @addtogroup sm
    @{
 */
 
-void c2_sm_group_init(struct c2_sm_group *grp)
+int c2_sm_init(struct c2_sm *mach)
 {
-	C2_SET0(grp);
-	c2_mutex_init(&grp->s_lock);
-	/* add grp->s_clink to otherwise unused grp->s_chan, because c2_chan
-	   code assumes that a clink is always associated with a channel. */
-	c2_chan_init(&grp->s_chan);
-	c2_clink_init(&grp->s_clink, NULL);
-	c2_clink_add(&grp->s_chan, &grp->s_clink);
-}
-
-void c2_sm_group_fini(struct c2_sm_group *grp)
-{
-	c2_clink_del(&grp->s_clink);
-	c2_clink_fini(&grp->s_clink);
-	c2_chan_fini(&grp->s_chan);
-	c2_mutex_fini(&grp->s_lock);
-}
-
-void c2_sm_group_lock(struct c2_sm_group *grp)
-{
-	c2_mutex_lock(&grp->s_lock);
-	c2_sm_asts_run(grp);
-}
-
-void c2_sm_group_unlock(struct c2_sm_group *grp)
-{
-	c2_sm_asts_run(grp);
-	c2_mutex_unlock(&grp->s_lock);
-}
-
-static bool grp_is_locked(const struct c2_sm_group *grp)
-{
-	return c2_mutex_is_locked(&grp->s_lock);
-}
-
-void c2_sm_ast_post(struct c2_sm_group *grp, struct c2_sm_ast *ast)
-{
-	C2_PRE(ast->sa_cb != NULL);
-
-	do
-		ast->sa_next = grp->s_forkq;
-	while (!C2_ATOMIC64_CAS(&grp->s_forkq, ast->sa_next, ast));
-	c2_clink_signal(&grp->s_clink);
-}
-
-void c2_sm_asts_run(struct c2_sm_group *grp)
-{
-	struct c2_sm_ast *ast;
-
-	C2_PRE(grp_is_locked(grp));
-
-	while (1) {
-		do
-			ast = grp->s_forkq;
-		while (ast != NULL &&
-		       !C2_ATOMIC64_CAS(&grp->s_forkq, ast, ast->sa_next));
-
-		if (ast == NULL)
-			break;
-
-		ast->sa_cb(grp, ast);
-	}
-}
-
-static void sm_lock(struct c2_sm *mach)
-{
-	c2_sm_group_lock(mach->sm_grp);
-}
-
-static void sm_unlock(struct c2_sm *mach)
-{
-	c2_sm_group_unlock(mach->sm_grp);
-}
-
-static bool sm_is_locked(const struct c2_sm *mach)
-{
-	return grp_is_locked(mach->sm_grp);
-}
-
-static bool state_is_valid(const struct c2_sm_conf *conf, uint32_t state)
-{
-	return
-		state < conf->scf_nr_states &&
-		conf->scf_state[state].sd_name != NULL;
-}
-
-static const struct c2_sm_state_descr *state_get(const struct c2_sm *mach,
-					   uint32_t state)
-{
-	C2_PRE(state_is_valid(mach->sm_conf, state));
-	return &mach->sm_conf->scf_state[state];
+	return 0;
 }
 
-static const struct c2_sm_state_descr *sm_state(const struct c2_sm *mach)
+void c2_sm_fini(struct c2_sm *mach)
 {
-	return state_get(mach, mach->sm_state);
 }
 
-bool c2_sm_invariant(const struct c2_sm *mach)
+c2_sm_state_t c2_sm_state_get  (struct c2_sm *mach)
 {
-	const struct c2_sm_state_descr *sd = sm_state(mach);
-
-	return
-		sm_is_locked(mach) &&
-		ergo(sd->sd_invariant != NULL, sd->sd_invariant(mach));
+	return 0;
 }
 
-static bool conf_invariant(const struct c2_sm_conf *conf)
+int c2_sm_state_set  (struct c2_sm *mach, c2_sm_state_t state)
 {
-	uint32_t i;
-	uint64_t mask;
-
-	if (conf->scf_nr_states >= sizeof(conf->scf_state[0].sd_allowed) * 8)
-		return false;
-
-	for (i = 0, mask = 0; i < conf->scf_nr_states; ++i) {
-		if (state_is_valid(conf, i))
-			mask |= (1 << i);
-	}
-
-	for (i = 0; i < conf->scf_nr_states; ++i) {
-		if (mask & (1 << i)) {
-			const struct c2_sm_state_descr *sd;
-
-			sd = &conf->scf_state[i];
-			if (sd->sd_flags & ~(C2_SDF_INITIAL|
-					     C2_SDF_FAILURE|C2_SDF_TERMINAL))
-				return false;
-			if ((sd->sd_flags & C2_SDF_TERMINAL) &&
-			    sd->sd_allowed != 0)
-				return false;
-			if (sd->sd_allowed & ~mask)
-				return false;
-		}
-	}
-	return true;
+	return 0;
 }
 
-void c2_sm_init(struct c2_sm *mach, const struct c2_sm_conf *conf,
-		uint32_t state, struct c2_sm_group *grp,
-		struct c2_addb_ctx *ctx)
+int c2_sm_state_wait (struct c2_sm *mach)
 {
-	C2_PRE(conf_invariant(conf));
-	C2_PRE(conf->scf_state[state].sd_flags & C2_SDF_INITIAL);
-
-	mach->sm_state = state;
-	mach->sm_conf  = conf;
-	mach->sm_grp   = grp;
-	mach->sm_addb  = ctx;
-	mach->sm_rc    = 0;
-	c2_chan_init(&mach->sm_chan);
-	C2_POST(c2_sm_invariant(mach));
+	return 0;
 }
 
-void c2_sm_fini(struct c2_sm *mach)
+int c2_sm_state_until(struct c2_sm *mach, c2_sm_state_t state)
 {
-	C2_ASSERT(c2_sm_invariant(mach));
-	C2_PRE(sm_state(mach)->sd_flags & C2_SDF_TERMINAL);
-	c2_chan_fini(&mach->sm_chan);
+	return 0;
 }
 
-int c2_sm_timedwait(struct c2_sm *mach, uint64_t states, c2_time_t deadline)
+int c2_sm_event_init(struct c2_sm_event *ev, struct c2_sm *mach)
 {
-	struct c2_clink waiter;
-	int             result;
-
-	C2_ASSERT(c2_sm_invariant(mach));
-
-	result = 0;
-	c2_clink_init(&waiter, NULL);
-
-	c2_clink_add(&mach->sm_chan, &waiter);
-	while (result == 0 && ((1 << mach->sm_state) & states) == 0) {
-		C2_ASSERT(c2_sm_invariant(mach));
-		if (sm_state(mach)->sd_flags & C2_SDF_TERMINAL)
-			result = -ESRCH;
-		else {
-			sm_unlock(mach);
-			if (!c2_chan_timedwait(&waiter, deadline))
-				result = -ETIMEDOUT;
-			sm_lock(mach);
-		}
-	}
-	c2_clink_del(&waiter);
-	c2_clink_fini(&waiter);
-	C2_ASSERT(c2_sm_invariant(mach));
-	return result;
+	return 0;
 }
 
-void c2_sm_fail(struct c2_sm *mach, int fail_state, int32_t rc)
+void c2_sm_event_fini(struct c2_sm_event *ev)
 {
-	C2_PRE(rc != 0);
-	C2_PRE(c2_sm_invariant(mach));
-	C2_PRE(mach->sm_rc == 0);
-	C2_PRE(state_get(mach, fail_state)->sd_flags & C2_SDF_FAILURE);
-
-	c2_sm_state_set(mach, fail_state);
-	mach->sm_rc = rc;
 }
 
-void c2_sm_state_set(struct c2_sm *mach, int state)
+enum c2_sm_res c2_sm_event_try(struct c2_sm_event *sm)
 {
-	const struct c2_sm_state_descr *sd;
-
-	C2_PRE(c2_sm_invariant(mach));
-
-	sd = sm_state(mach);
-	C2_PRE(sd->sd_allowed & (1 << state));
-
-	if (sd->sd_ex != NULL)
-		sd->sd_ex(mach);
-	mach->sm_state = state;
-	sd = sm_state(mach);
-	if (sd->sd_in != NULL)
-		sd->sd_in(mach);
-	c2_chan_broadcast(&mach->sm_chan);
-	C2_POST(c2_sm_invariant(mach));
+	return SR_DONE;
 }
 
-/**
-    AST call-back for a timeout.
-
-    @see c2_sm_timeout().
-*/
-static void sm_timeout_bottom(struct c2_sm_group *grp, struct c2_sm_ast *ast)
+int c2_sm_event_wait (struct c2_sm_event *sm)
 {
-	struct c2_sm_timeout *to   = container_of(ast,
-						  struct c2_sm_timeout, st_ast);
-	struct c2_sm         *mach = ast->sa_mach;
-
-	C2_ASSERT(c2_sm_invariant(mach));
-
-	if (to->st_active) {
-		to->st_active = false;
-		c2_sm_state_set(mach, to->st_state);
-	}
+	return 0;
 }
 
-/**
-    Timer call-back for a timeout.
-
-    @see c2_sm_timeout().
-*/
-static unsigned long sm_timeout_top(unsigned long data)
+int c2_sm_event_apply(struct c2_sm_event *sm)
 {
-	struct c2_sm_timeout *to = (void *)data;
-
-	c2_sm_ast_post(to->st_ast.sa_mach->sm_grp, &to->st_ast);
 	return 0;
 }
 
-/**
-   Cancels a timeout, if necessary.
-
-   This is called if a state transition happened before the timeout expired.
 
-   @see c2_sm_timeout().
- */
-static bool sm_timeout_cancel(struct c2_clink *link)
+int c2_sm_event_queue(struct c2_sm_event *sm)
 {
-	struct c2_sm_timeout *to = container_of(link, struct c2_sm_timeout,
-						st_clink);
-
-	C2_ASSERT(c2_sm_invariant(to->st_ast.sa_mach));
-
-	to->st_active = false;
-	c2_timer_stop(&to->st_timer);
-	return true;
+	return 0;
 }
 
-int c2_sm_timeout(struct c2_sm *mach, struct c2_sm_timeout *to,
-		  c2_time_t timeout, int state)
+int c2_persistent_sm_register(struct c2_persistent_sm *pmach,
+			      struct c2_dtm *dtm, 
+			      const struct c2_persistent_sm_ops *ops)
 {
-	int              result;
-	struct c2_timer *tm = &to->st_timer;
-
-	C2_PRE(c2_sm_invariant(mach));
-	C2_PRE(!(sm_state(mach)->sd_flags & C2_SDF_TERMINAL));
-	C2_PRE(sm_state(mach)->sd_allowed & (1 << state));
-	C2_PRE(!(state_get(mach, state)->sd_flags & C2_SDF_TERMINAL));
-
-	/*
-	  This is how timeout is implemented:
-
-	      - a timer is armed (with sm_timeout_top() call-back);
-
-	      - when the timer fires off, an AST (with sm_timeout_bottom()
-                call-back) is posted from the timer call-back;
-
-	      - when the AST is executed, it performs the state transition.
-	 */
-
-	C2_SET0(to);
-	to->st_active      = true;
-	to->st_state       = state;
-	to->st_ast.sa_cb   = sm_timeout_bottom;
-	to->st_ast.sa_mach = mach;
-	c2_clink_init(&to->st_clink, sm_timeout_cancel);
-	c2_clink_add(&mach->sm_chan, &to->st_clink);
-	c2_timer_init(tm, C2_TIMER_SOFT,
-		      timeout, sm_timeout_top,
-		      (unsigned long)to);
-	result = c2_timer_start(tm);
-	if (result != 0)
-		c2_sm_timeout_fini(to);
-	return result;
+	return 0;
 }
 
-void c2_sm_timeout_fini(struct c2_sm_timeout *to)
+void c2_persistent_sm_unregister(struct c2_persistent_sm *pmach)
 {
-	C2_PRE(to->st_ast.sa_next == NULL);
-
-	if (c2_timer_is_started(&to->st_timer))
-		c2_timer_stop(&to->st_timer);
-	c2_timer_fini(&to->st_timer);
-	if (c2_clink_is_armed(&to->st_clink))
-		c2_clink_del(&to->st_clink);
-	c2_clink_fini(&to->st_clink);
 }
 
 /** @} end of sm group */
 
-/*
+/* 
  *  Local variables:
  *  c-indentation-style: "K&R"
  *  c-basic-offset: 8
diff --git a/sm/sm.h b/sm/sm.h
index 68dc959..a36e634 100644
--- a/sm/sm.h
+++ b/sm/sm.h
@@ -14,520 +14,99 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Nikita Danilov <Nikita_Danilov@xyratex.com>
+ * Original author: Nikita Danilov
  * Original creation date: 04/01/2010
  */
 
-#ifndef __COLIBRI_SM_SM_H__
-#define __COLIBRI_SM_SM_H__
+#ifndef __COLIBRI_SM_H__
+#define __COLIBRI_SM_H__
 
-#include "lib/types.h"               /* int32_t, uint64_t */
-#include "lib/atomic.h"
-#include "lib/time.h"                /* c2_time_t */
-#include "lib/timer.h"
-#include "lib/semaphore.h"
-#include "lib/chan.h"
-#include "lib/mutex.h"
-#include "lib/tlist.h"
+#include "lib/list.h"
+#include "lib/queue.h"
+#include "dtm/dtm.h"
 
 /**
    @defgroup sm State machine
-
-   This modules defines interfaces to functionality common to typical
-   non-blocking state machines extensively used by Colibri.
-
-   The main difference between "state machine" (non-blocking) code and
-   "threaded" (blocking) code is that the latter blocks waiting for some events
-   while having some computational state stored in the "native" C language stack
-   (in the form of automatic variables allocated across the call-chain). Because
-   of this the thread must remain dedicated to the same threaded activity not
-   only during actual "computation", when processor is actively used, but also
-   for the duration of wait. In many circumstances this is too expensive,
-   because threads are heavy objects.
-
-   Non-blocking code, on the other hand, packs all its state into a special
-   data-structures before some potential blocking points and unpacks it after
-   the event of interest occurs. This allows the same thread to be re-used for
-   multiple non-blocking computations.
-
-   Which blocking points deserve packing-unpacking depends on
-   circumstances. Long-term waits for network or storage communication are prime
-   candidates for non-blocking handling. Memory accesses, which can incur
-   blocking page faults in a user space process are probably too ubiquitous for
-   this. Memory allocations and data-structure locks fall into an intermediate
-   group.
-
-   This module defines data-structures and interfaces to handle common
-   non-blocking state-machine functionality:
-
-       - state tracking and state transitions;
-
-       - concurrency;
-
-       - interaction between a state machine and external world (both
-         non-blocking and threaded);
-
-       - accounting and statistics collection.
-
-   <b>State and transitions.</b>
-
-   State machine state is recorded in c2_sm::sm_state. This is supposed to be a
-   relatively coarse-grained high level state, broadly determining state machine
-   behaviour. An instance of c2_sm will typically be embedded into a larger
-   structure containing fields fully determining state machine behaviour. Each
-   state comes with a description. All descriptions for a particular state
-   machine are packed into a c2_sm_conf::scf_state[] array.
-
-   State machine transferred from one state to another by a call to
-   c2_sm_state_set() (or its variant c2_sm_fail()).
-
-   <b>Concurrency.</b>
-
-   State machine is a part of a state machine group (c2_sm_group). All state
-   machines in a group use group's mutex to serialise their state
-   transitions. One possible scenario is to have a group for all state machines
-   associated with a given locality (c2_fom_locality). Alternatively a
-   group-per-machine can be used.
-
-   <b>Interaction.</b>
-
-   The only "output" event that a state machine communicates to the external
-   world is (from this module's point of view) its state transition. State
-   transitions are announces on a per-machine channel (c2_sm::sm_chan). This
-   mechanism works both for threaded and non-blocking event consumers. The
-   formers use c2_sm_timedwait() to wait until the state machine reaches
-   desirable state, the latter register a clink with c2_sm::sm_chan.
-
-   "Input" events cause state transitions. Typical examples of such events are:
-   completion of a network of storage communication, timeout or a state
-   transition in a different state machine. Such events often happen in
-   "awkward" context: signal and interrupt handlers, timer call-backs and
-   similar. Acquiring the group's mutex, necessary for state transition in such
-   places is undesirable for multiple reasons:
-
-       - to avoid self-deadlock in a case where an interrupt of signal is
-         services by a thread that already holds the mutex, the latter must be
-         made "async-safe", which is quite expensive;
-
-       - implementation of a module that provides a call-back must take into
-         account the possibility of the call-back blocking waiting for a
-         mutex. This is also quite expensive;
-
-       - locking order dependencies arise between otherwise unrelated
-         components;
-
-       - all these issues are exasperated in a situation where state transition
-         must take additional locks, which it often does.
-
-   The solution to these problems comes from operating system kernels design,
-   see the AST section below.
-
-   <b>Accounting and statistics.</b>
-
-   This module accumulates statistics about state transitions and time spent in
-   particular states. For additional flexibility these data are reported through
-   an addb context supplied during state machine initialisation so that the same
-   context can be used for other purposes too.
-
-   @todo accounting and statistics is not currently implemented.
-
-   <b>AST.</b>
-
-   Asynchronous System Trap (AST) is a mechanism that allows a code running in
-   an "awkward context" (see above) to post a call-back to be executed at the
-   "base level" under a group mutex. UNIX kernels traditionally used a similar
-   mechanism, where an interrupt handler does little more than setting a flag
-   and returning. This flag is checked when the kernel is just about to return
-   to the user space. If the flag is set, the rest of interrupt processing
-   happens. In Linux a similar mechanism is called a "top-half" and
-   "bottom-half" of interrupt processing. In Windows it is a DPC
-   (http://en.wikipedia.org/wiki/Deferred_Procedure_Call) mechanism, in older
-   DEC kernels it was called a "fork queue".
-
-   c2_sm_ast structure represents a call-back to be invoked under group
-   mutex. An ast is "posted" to a state machine group by a call to
-   c2_sm_ast_post(), which can be done in any context, in the sense that it
-   doesn't take any locks. Posted asts are executed
-
-       - just after group mutex is taken;
-
-       - just before group mutex is released;
-
-       - whenever c2_sm_asts_run() is called.
-
-   Ast mechanism solves the problems with input events mentioned above at the
-   expense of
-
-       - an increased latency: the call-back is not executed immediately;
-
-       - an additional burden of ast-related book-keeping: it is up to the ast
-         user to free ast structure when it is safe to do so (i.e., after the
-         ast completed execution).
-
-   To deal with the latency problem, a user must arrange c2_sm_asts_run() to be
-   called during long state transitions (typically within loops).
-
-   There are a few ways to deal with the ast book-keeping problem:
-
-       - majority of asts will be embedded in some longer living data-structures
-         like foms and won't need separate allocation of freeing;
-
-       - some ast users might allocate asts dynamically;
-
-       - the users which have neither a long-living data-structure to embed ast
-         in nor can call dynamic allocator, have to pre-allocate a pool of asts
-         and to guarantee somehow that it is never exhausted.
-
-   If an ast is posted a c2_sm_group::s_clink clink is signalled. A user
-   managing a state machine group might arrange a special "ast" thread (or a
-   group of threads) to wait on this channel and to call c2_sm_asts_run() when
-   the channel is signalled:
-
-   @code
-   while (1) {
-           c2_chan_wait(&G->s_clink);
-           c2_sm_group_lock(G);
-	   c2_sm_asts_run(G);
-           c2_sm_group_unlock(G);
-   }
-   @endcode
-
-   A special "ast" thread is not needed if there is an always running "worker"
-   thread or pool of threads associated with the state machine group. In the
-   latter case, the worker thread can wait on c2_sm_group::s_clink in addition
-   to other channels it waits on (see c2_clink_attach()).
-
-   c2_sm_group_init() initialises c2_sm_group::s_clink with a NULL call-back. If
-   a user wants to re-initialise it with a different call-back or to attach it
-   to a clink group, it should call c2_clink_fini() followed by c2_clink_init()
-   or c2_link_attach() before any state machine is created in the group.
-
    @{
 */
 
-/* export */
-struct c2_sm;
-struct c2_sm_state_descr;
-struct c2_sm_conf;
-struct c2_sm_group;
-struct c2_sm_ast;
-
-/* import */
-struct c2_addb_ctx;
-struct c2_timer;
-struct c2_mutex;
-
-/**
-   state machine.
-
-   Abstract state machine. Possibly persistent, possibly replicated.
-
-   An instance of c2_sm is embedded in a concrete state machine (e.g., a
-   per-endpoint rpc layer formation state machine, a resource owner state
-   machine (c2_rm_owner), &c.).
-
-   c2_sm stores state machine current state in c2_sm::sm_state. The semantics of
-   state are not defined by this module except for classifying states into a few
-   broad classes, see c2_sm_state_descr_flags. The only restriction on states is
-   that maximal state (as a number) should not be too large, because all states
-   are enumerated in a c2_sm::sm_conf::scf_state[] array.
-
-   @invariant c2_sm_invariant() (under mach->sm_grp->s_lock).
- */
-struct c2_sm {
-	/**
-	   Current state.
-
-	   @invariant mach->sm_state < mach->sm_conf->scf_nr_states
-	 */
-	uint32_t                 sm_state;
-	/**
-	   State machine configuration.
-
-	   The configuration enumerates valid state machine states and
-	   associates with every state some attributes that are used by c2_sm
-	   code to check state transition correctness and to do some generic
-	   book-keeping, including addb-based accounting.
-	 */
-	const struct c2_sm_conf *sm_conf;
-	struct c2_sm_group      *sm_grp;
-	/**
-	   addb context in which state machine related events and statistics are
-	   reported. This is included by reference for flexibility.
-	 */
-	struct c2_addb_ctx      *sm_addb;
-	/**
-	   Channel on which state transitions are announced.
-	 */
-	struct c2_chan           sm_chan;
-	/**
-	   State machine "return code". This is set to a non-zero value when
-	   state machine transitions to an C2_SDF_FAILURE state.
-	 */
-	int32_t                  sm_rc;
-};
-
-/**
-   Configuration describes state machine type.
-
-   c2_sm_conf enumerates possible state machine states.
-
-   @invariant c2_sm_desc_invariant()
- */
-struct c2_sm_conf {
-	const char                     *scf_name;
-	/** Number of states in this state machine. */
-	uint32_t                        scf_nr_states;
-	/** Array of state descriptions. */
-	const struct c2_sm_state_descr *scf_state;
-};
-
-/**
-   Description of some state machine state.
- */
-struct c2_sm_state_descr {
-	/**
-	    Flags, broadly classifying the state, taken from
-	    c2_sm_state_descr_flags.
-	 */
-	uint32_t    sd_flags;
-	/**
-	    Human readable state name for debugging. This field is NULL for
-	    "invalid" states, which state machine may never enter.
-	 */
-	const char *sd_name;
-	/**
-	   This function (if non-NULL) is called by c2_sm_state_set() when the
-	   state is entered.
-	 */
-	void      (*sd_in)(struct c2_sm *mach);
-	/**
-	   This function (if non-NULL) is called by c2_sm_state_set() when the
-	   state is left.
-	 */
-	void      (*sd_ex)(struct c2_sm *mach);
-	/**
-	   Invariant that must hold while in this state. Specifically, this
-	   invariant is checked under the state machine lock once transition to
-	   this state completed, checked under the same lock just before a
-	   transition out of the state is about to happen and is checked (under
-	   the lock) whenever a c2_sm call finds the target state machine in
-	   this state.
-
-	   If this field is NULL, no invariant checks are done.
-	 */
-	bool      (*sd_invariant)(const struct c2_sm *mach);
-	/**
-	   A bitmap of states to which transitions from this state are allowed.
+/** Macroscopic state machine state. */
+typedef uint64_t c2_sm_state_t;
 
-	   @note this limits the number of states to 64, which should be more
-	   than enough. Should a need in extra complicated machines arise, this
-	   can be replaced with c2_bitmap, as the expense of making static
-	   c2_sm_state_descr more complicated.
-	 */
-	uint64_t    sd_allowed;
+enum c2_sm_res {
+	SR_DONE,
+	SR_AGAIN,
+	SR_WAIT
 };
 
-/**
-   Flags for state classification, used in c2_sm_state_descr::sd_flags.
- */
-enum c2_sm_state_descr_flags {
-	/**
-	    An initial state.
-
-	    State machine, must starts execution in a state marked with this
-	    flag. Multiple states can be marked with this flag, for example, to
-	    share a code between similar state machines, that only differ in
-	    initial conditions.
-
-	    @see c2_sm_init()
-	 */
-	C2_SDF_INITIAL  = 1 << 0,
-	/**
-	   A state marked with this flag is a failure state. c2_sm::sm_rc is set
-	   to a non-zero value on entering this state.
-
-	   In a such state, state machine is supposed to handle or report the
-	   error indicated by c2_sm::sm_rc. Typically (but not necessary), the
-	   state machine will transit into am C2_SDF_TERMINAL state immediately
-	   after a failure state.
-
-	   @see c2_sm_fail()
-	 */
-	C2_SDF_FAILURE  = 1 << 1,
-	/**
-	   A state marked with this flag is a terminal state. No transitions out
-	   of this state are allowed (checked by c2_sm_conf_invariant()) and an
-	   attempt to wait for a state transition, while the state machine is in
-	   a terminal state, immediately returns -ESRCH.
+struct c2_sm;
+struct c2_sm_event;
 
-	   @see c2_sm_timedwait()
-	 */
-	C2_SDF_TERMINAL = 1 << 2
+struct c2_sm_ops {
+	c2_sm_state_t  (*so_state_get)(struct c2_sm *sm);
+	enum c2_sm_res (*so_event_try)(struct c2_sm *sm, 
+				       struct c2_sm_event *ev);
 };
 
 /**
-   Asynchronous system trap.
-
-   A request to execute a call-back under group mutex. An ast can be posted by a
-   call to c2_sm_ast_post() in any context.
+   state machine
 
-   It will be executed later, see AST section of the comment at the top of this
-   file.
-
-   Only c2_sm_ast::sa_cb and c2_sm_ast::sa_datum fields are public. The rest of
-   this structure is for internal use by sm code.
- */
-struct c2_sm_ast {
-	/** Call-back to be executed. */
-	void              (*sa_cb)(struct c2_sm_group *grp, struct c2_sm_ast *);
-	/** This field is reserved for the user and not used by the sm code. */
-	void               *sa_datum;
-	struct c2_sm_ast   *sa_next;
-	struct c2_sm       *sa_mach;
-};
-
-struct c2_sm_group {
-	struct c2_mutex   s_lock;
-	struct c2_clink   s_clink;
-	struct c2_sm_ast *s_forkq;
-	struct c2_tl      s_ast_free;
-	struct c2_chan    s_chan;
+   Abstract state machine. Possibly persistent, possibly replicated.
+*/
+struct c2_sm {
+	struct c2_queue sm_incoming;
 };
 
-/**
-   Initialises a state machine.
-
-   @pre conf->scf_state[state].sd_flags & C2_SDF_INITIAL
- */
-void c2_sm_init(struct c2_sm *mach, const struct c2_sm_conf *conf,
-		uint32_t state, struct c2_sm_group *grp,
-		struct c2_addb_ctx *ctx);
-/**
-   Finalises a state machine.
-
-   @pre conf->scf_state[state].sd_flags & C2_SDF_TERMINAL
- */
+int  c2_sm_init(struct c2_sm *mach);
 void c2_sm_fini(struct c2_sm *mach);
 
-void c2_sm_group_init(struct c2_sm_group *grp);
-void c2_sm_group_fini(struct c2_sm_group *grp);
-
-void c2_sm_group_lock(struct c2_sm_group *grp);
-void c2_sm_group_unlock(struct c2_sm_group *grp);
-
-/**
-   Waits until a given state machine enters any of states enumerated by a given
-   bit-mask.
-
-   @retval 0          - one of the states reached
-
-   @retval -ESRCH     - terminal state reached,
-                        see c2_sm_state_descr_flags::C2_SDF_TERMINAL
-
-   @retval -ETIMEDOUT - deadline passed
-
-   In case where multiple wait termination conditions hold simultaneously (e.g.,
-   @states includes a terminal state), the result is implementation dependent.
-
-   @note this interface assumes that states are numbered by numbers less than
-   64.
- */
-int c2_sm_timedwait(struct c2_sm *mach, uint64_t states, c2_time_t deadline);
-
-/**
-   Moves a state machine into fail_state state atomically with setting rc code.
-
-   @pre rc != 0
-   @pre c2_mutex_is_locked(&mach->sm_grp->s_lock)
-   @pre mach->sm_rc == 0
-   @pre mach->sm_conf->scf_state[fail_state].sd_flags & C2_SDF_FAILURE
-   @post mach->sm_rc == rc
-   @post mach->sm_state == fail_state
-   @post c2_mutex_is_locked(&mach->sm_grp->s_lock)
- */
-void c2_sm_fail(struct c2_sm *mach, int fail_state, int32_t rc);
-
-/**
-   Transits a state machine into the indicated state.
-
-   Calls ex- and in- methods of the corresponding states (even if the state
-   doesn't change after all).
-
-   @pre c2_mutex_is_locked(&mach->sm_grp->s_lock)
-   @post mach->sm_state == state
-   @post c2_mutex_is_locked(&mach->sm_grp->s_lock)
- */
-void c2_sm_state_set(struct c2_sm *mach, int state);
+c2_sm_state_t c2_sm_state_get  (struct c2_sm *mach);
+int           c2_sm_state_set  (struct c2_sm *mach, c2_sm_state_t state);
+int           c2_sm_state_wait (struct c2_sm *mach);
+int           c2_sm_state_until(struct c2_sm *mach, c2_sm_state_t state);
 
 /**
-   Structure used by c2_sm_timeout() to record timeout state.
-
-   This structure is owned by the sm code, user should not access it. The user
-   provides uninitialised instance c2_sm_timeout to c2_sm_timeout(). The
-   instance can be freed after the next state transition for the state machine
-   completes, see c2_sm_timeout() for details.
- */
-struct c2_sm_timeout {
-	/** Timer used to implement delayed state transition. */
-	struct c2_timer  st_timer;
-	/** Clink to watch for state transitions that might cancel the
-	    timeout. */
-	struct c2_clink  st_clink;
-	/** AST invoked when timer fires off. */
-	struct c2_sm_ast st_ast;
-	/** Target state. */
-	int              st_state;
-	/** True if this timeout neither expired nor cancelled. */
-	bool             st_active;
+   an event causing state transition.
+*/
+struct c2_sm_event {
+	struct c2_sm        *se_mach;
+	/*struct c2_chan_link  se_wait;*/
+	struct c2_list_link  se_wait;
+	struct c2_queue_link se_linkage;
 };
 
-/**
-   Arms a timer to move a machine into a given state after a given timeout.
-
-   If a state transition happens before the timeout expires, the timeout is
-   cancelled.
-
-   It is possible to arms multiple timeouts against the same state machine. The
-   first one to expire will cancel the rest.
+int  c2_sm_event_init(struct c2_sm_event *ev, struct c2_sm *mach);
+void c2_sm_event_fini(struct c2_sm_event *ev);
 
-   The c2_sm_timeout instance, supplied to this call can be freed after timeout
-   expires or is cancelled.
+enum c2_sm_res c2_sm_event_try  (struct c2_sm_event *sm);
+int            c2_sm_event_wait (struct c2_sm_event *sm);
+int            c2_sm_event_apply(struct c2_sm_event *sm);
+int            c2_sm_event_queue(struct c2_sm_event *sm);
 
-   @param timeout absolute time at which the state transition will take place
-   @param state the state to which the state machine will transition after the
-   timeout.
-
-   @pre c2_mutex_is_locked(&mach->sm_grp->s_lock)
-   @pre state transition from current state to the target state is allowed.
-   @post c2_mutex_is_locked(&mach->sm_grp->s_lock)
- */
-int c2_sm_timeout(struct c2_sm *mach, struct c2_sm_timeout *to,
-		  c2_time_t timeout, int state);
-/**
-   Finaliser that must be called before @to can be freed.
- */
-void c2_sm_timeout_fini(struct c2_sm_timeout *to);
+struct c2_persistent_sm_ops;
 
-/**
-   Posts an AST to a group.
- */
-void c2_sm_ast_post(struct c2_sm_group *grp, struct c2_sm_ast *ast);
+/** persistent state machine */
+struct c2_persistent_sm {
+	struct c2_sm                       ps_sm;
+	const struct c2_persistent_sm_ops *ps_ops;
+	struct c2_dtm                     *ps_dtm;
+};
 
-/**
-   Runs posted, but not yet executed ASTs.
+struct c2_persistent_sm_ops {
+	int (*pso_recover)(struct c2_persistent_sm *pmach);
+};
 
-   @pre c2_mutex_is_locked(&grp->s_lock)
-   @post c2_mutex_is_locked(&grp->s_lock)
- */
-void c2_sm_asts_run(struct c2_sm_group *grp);
+int  c2_persistent_sm_register  (struct c2_persistent_sm *pmach,
+				 struct c2_dtm *dtm, 
+				 const struct c2_persistent_sm_ops *ops);
+void c2_persistent_sm_unregister(struct c2_persistent_sm *pmach);
 
 /** @} end of sm group */
 
-/* __COLIBRI_SM_SM_H__ */
+/* __COLIBRI_SM_H__ */
 #endif
 
-/*
+/* 
  *  Local variables:
  *  c-indentation-style: "K&R"
  *  c-basic-offset: 8
diff --git a/sm/ut/Makefile.am b/sm/ut/Makefile.am
deleted file mode 100644
index 4169a57..0000000
--- a/sm/ut/Makefile.am
+++ /dev/null
@@ -1,4 +0,0 @@
-INCLUDES        	= -I. -I$(top_srcdir) -I$(top_srcdir)/include -I../
-noinst_LTLIBRARIES      = libsm-ut.la
-libsm_ut_la_SOURCES     = sm.c
-libsm_ut_la_LIBADD 	= $(top_builddir)/colibri/libcolibri.la
diff --git a/sm/ut/sm.c b/sm/ut/sm.c
deleted file mode 100644
index a9d50a7..0000000
--- a/sm/ut/sm.c
+++ /dev/null
@@ -1,372 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Nikita Danilov <Nikita_Danilov@xyratex.com>
- * Original creation date: 28-Oct-2011
- */
-
-
-#ifdef HAVE_CONFIG_H
-#  include <config.h>
-#endif
-
-#include "lib/ut.h"
-#include "lib/ub.h"
-#include "lib/time.h"
-#include "lib/thread.h"
-
-#include "addb/addb.h"
-#include "sm/sm.h"
-
-static struct c2_sm_group G;
-static struct c2_addb_ctx actx;
-static struct c2_sm       m;
-static struct c2_sm_ast   ast;
-static bool               more = true;
-static struct c2_thread   ath;
-
-static void ast_thread(int __d)
-{
-   while (more) {
-           c2_chan_wait(&G.s_clink);
-           c2_sm_group_lock(&G);
-	   c2_sm_asts_run(&G);
-           c2_sm_group_unlock(&G);
-   }
-}
-
-static int init(void) {
-	c2_sm_group_init(&G);
-	return C2_THREAD_INIT(&ath, int, NULL, &ast_thread, 0, "ast_thread");
-}
-
-static int fini(void) {
-	more = false;
-	c2_clink_signal(&G.s_clink);
-	c2_thread_join(&ath);
-	c2_sm_group_fini(&G);
-	return 0;
-}
-
-/**
-   Unit test for c2_sm_state_set().
-
-   Performs a state transition for a very simple state machine:
-   @dot
-   digraph M {
-           S_INITIAL -> S_TERMINAL
-   }
-   @enddot
- */
-static void transition(void)
-{
-	enum { S_INITIAL, S_TERMINAL, S_NR };
-	const struct c2_sm_state_descr states[S_NR] = {
-		[S_INITIAL] = {
-			.sd_flags     = C2_SDF_INITIAL,
-			.sd_name      = "initial",
-			.sd_in        = NULL,
-			.sd_ex        = NULL,
-			.sd_invariant = NULL,
-			.sd_allowed   = (1 << S_TERMINAL)
-		},
-		[S_TERMINAL] = {
-			.sd_flags     = C2_SDF_TERMINAL,
-			.sd_name      = "terminal",
-			.sd_in        = NULL,
-			.sd_ex        = NULL,
-			.sd_invariant = NULL,
-			.sd_allowed   = 0
-		}
-	};
-	const struct c2_sm_conf        conf = {
-		.scf_name      = "test drive: transition",
-		.scf_nr_states = S_NR,
-		.scf_state     = states
-	};
-
-	c2_sm_group_lock(&G);
-	c2_sm_init(&m, &conf, S_INITIAL, &G, &actx);
-	C2_UT_ASSERT(m.sm_state == S_INITIAL);
-
-	c2_sm_state_set(&m, S_TERMINAL);
-	C2_UT_ASSERT(m.sm_state == S_TERMINAL);
-
-	c2_sm_fini(&m);
-	c2_sm_group_unlock(&G);
-}
-
-static bool x;
-
-static void ast_cb(struct c2_sm_group *g, struct c2_sm_ast *a)
-{
-	C2_UT_ASSERT(g == &G);
-	C2_UT_ASSERT(a == &ast);
-	C2_UT_ASSERT(a->sa_datum == &ast_cb);
-	x = true;
-}
-
-/**
-   Unit test for c2_sm_ast_post().
- */
-static void ast_test(void)
-{
-
-	x = false;
-	ast.sa_cb = &ast_cb;
-	ast.sa_datum = &ast_cb;
-	c2_sm_ast_post(&G, &ast);
-	C2_UT_ASSERT(!x);
-	c2_sm_group_lock(&G);
-	C2_UT_ASSERT(x);
-	c2_sm_group_unlock(&G);
-}
-
-/**
-   Unit test for c2_sm_timeout().
-
-   @dot
-   digraph M {
-           S_INITIAL -> S_0 [label="timeout t0"]
-           S_0 -> S_1 [label="timeout t1"]
-           S_0 -> S_2
-           S_1 -> S_TERMINAL
-           S_2 -> S_TERMINAL
-   }
-   @enddot
- */
-static void timeout(void)
-{
-	enum { S_INITIAL, S_0, S_1, S_2, S_TERMINAL, S_NR };
-	const struct c2_sm_state_descr states[S_NR] = {
-		[S_INITIAL] = {
-			.sd_flags     = C2_SDF_INITIAL,
-			.sd_name      = "initial",
-			.sd_in        = NULL,
-			.sd_ex        = NULL,
-			.sd_invariant = NULL,
-			.sd_allowed   = (1 << S_0)
-		},
-		[S_0] = {
-			.sd_flags     = 0,
-			.sd_name      = "0",
-			.sd_in        = NULL,
-			.sd_ex        = NULL,
-			.sd_invariant = NULL,
-			.sd_allowed   = (1 << S_1)|(1 << S_2)
-		},
-		[S_1] = {
-			.sd_flags     = 0,
-			.sd_name      = "0",
-			.sd_in        = NULL,
-			.sd_ex        = NULL,
-			.sd_invariant = NULL,
-			.sd_allowed   = 1 << S_TERMINAL
-		},
-		[S_2] = {
-			.sd_flags     = 0,
-			.sd_name      = "0",
-			.sd_in        = NULL,
-			.sd_ex        = NULL,
-			.sd_invariant = NULL,
-			.sd_allowed   = 1 << S_TERMINAL
-		},
-		[S_TERMINAL] = {
-			.sd_flags     = C2_SDF_TERMINAL,
-			.sd_name      = "terminal",
-			.sd_in        = NULL,
-			.sd_ex        = NULL,
-			.sd_invariant = NULL,
-			.sd_allowed   = 0
-		}
-	};
-	const struct c2_sm_conf        conf = {
-		.scf_name      = "test drive: timeout",
-		.scf_nr_states = S_NR,
-		.scf_state     = states
-	};
-	struct c2_sm_timeout t0;
-	struct c2_sm_timeout t1;
-	c2_time_t            delta;
-	int                  result;
-
-	c2_time_set(&delta, 0, C2_TIME_ONE_BILLION/100);
-
-	c2_sm_group_lock(&G);
-	c2_sm_init(&m, &conf, S_INITIAL, &G, &actx);
-
-	/* check that timeout works */
-	result = c2_sm_timeout(&m, &t0, c2_time_add(c2_time_now(), delta), S_0);
-	C2_UT_ASSERT(result == 0);
-	C2_UT_ASSERT(t0.st_active);
-
-	result = c2_sm_timedwait(&m, ~(1 << S_INITIAL), C2_TIME_NEVER);
-	C2_UT_ASSERT(result == 0);
-	C2_UT_ASSERT(m.sm_state == S_0);
-	C2_UT_ASSERT(!t0.st_active);
-
-	c2_sm_timeout_fini(&t0);
-
-	/* check that state transition cancels the timeout */
-	result = c2_sm_timeout(&m, &t1, c2_time_add(c2_time_now(), delta), S_1);
-	C2_UT_ASSERT(result == 0);
-	C2_UT_ASSERT(t1.st_active);
-
-	c2_sm_state_set(&m, S_2);
-	C2_UT_ASSERT(m.sm_state == S_2);
-	C2_UT_ASSERT(!t1.st_active);
-
-	result = c2_sm_timedwait(&m, ~(1 << S_2),
-				 c2_time_add(c2_time_now(),
-					     c2_time_add(delta, delta)));
-	C2_UT_ASSERT(result == -ETIMEDOUT);
-	C2_UT_ASSERT(m.sm_state == S_2);
-
-	c2_sm_timeout_fini(&t1);
-
-	c2_sm_state_set(&m, S_TERMINAL);
-	C2_UT_ASSERT(m.sm_state == S_TERMINAL);
-
-	c2_sm_fini(&m);
-	c2_sm_group_unlock(&G);
-}
-
-struct story {
-	struct c2_sm cain;
-	struct c2_sm abel;
-};
-
-enum { S_INITIAL, S_ITERATE, S_FRATRICIDE, S_TERMINAL, S_NR };
-
-static void genesis_4_8(struct c2_sm *mach)
-{
-	struct story *s;
-
-	s = container_of(mach, struct story, cain);
-	c2_sm_fail(&s->abel, S_TERMINAL, -EINTR);
-}
-
-/**
-   Unit test for multiple machines in the group.
-
-   @dot
-   digraph M {
-           S_INITIAL -> S_ITERATE
-           S_ITERATE -> S_ITERATE
-           S_INITIAL -> S_FRATRICIDE [label="timeout"]
-           S_ITERATE -> S_TERMINAL
-           S_FRATRICIDE -> S_TERMINAL
-   }
-   @enddot
- */
-static void group(void)
-{
-	const struct c2_sm_state_descr states[S_NR] = {
-		[S_INITIAL] = {
-			.sd_flags     = C2_SDF_INITIAL,
-			.sd_name      = "initial",
-			.sd_in        = NULL,
-			.sd_ex        = NULL,
-			.sd_invariant = NULL,
-			.sd_allowed   = (1 << S_ITERATE)|(1 << S_FRATRICIDE)
-		},
-		[S_ITERATE] = {
-			.sd_flags     = 0,
-			.sd_name      = "loop here",
-			.sd_in        = NULL,
-			.sd_ex        = NULL,
-			.sd_invariant = NULL,
-			.sd_allowed   = (1 << S_ITERATE)|(1 << S_TERMINAL)
-		},
-		[S_FRATRICIDE] = {
-			.sd_flags     = 0,
-			.sd_name      = "Let's go out to the field",
-			.sd_in        = &genesis_4_8,
-			.sd_ex        = NULL,
-			.sd_invariant = NULL,
-			.sd_allowed   = 1 << S_TERMINAL
-		},
-		[S_TERMINAL] = {
-			.sd_flags     = C2_SDF_TERMINAL|C2_SDF_FAILURE,
-			.sd_name      = "terminal",
-			.sd_in        = NULL,
-			.sd_ex        = NULL,
-			.sd_invariant = NULL,
-			.sd_allowed   = 0
-		}
-	};
-	const struct c2_sm_conf        conf = {
-		.scf_name      = "test drive: group",
-		.scf_nr_states = S_NR,
-		.scf_state     = states
-	};
-
-	struct story         s;
-	struct c2_sm_timeout to;
-	c2_time_t            delta;
-	int                  result;
-
-	c2_time_set(&delta, 0, C2_TIME_ONE_BILLION/100);
-
-	c2_sm_group_lock(&G);
-	c2_sm_init(&s.cain, &conf, S_INITIAL, &G, &actx);
-	c2_sm_init(&s.abel, &conf, S_INITIAL, &G, &actx);
-
-	/* check that timeout works */
-	result = c2_sm_timeout(&s.cain, &to,
-			       c2_time_add(c2_time_now(), delta), S_FRATRICIDE);
-	C2_UT_ASSERT(result == 0);
-
-	while (s.abel.sm_rc == 0) {
-		/* live, while you can */
-		c2_sm_state_set(&s.abel, S_ITERATE);
-		/* give providence a chance to run */
-		c2_sm_asts_run(&G);
-	}
-	C2_UT_ASSERT(s.abel.sm_state == S_TERMINAL);
-	C2_UT_ASSERT(s.cain.sm_state == S_FRATRICIDE);
-
-	c2_sm_state_set(&s.cain, S_TERMINAL);
-
-	c2_sm_timeout_fini(&to);
-
-	c2_sm_fini(&s.abel);
-	c2_sm_fini(&s.cain);
-	c2_sm_group_unlock(&G);
-}
-
-const struct c2_test_suite sm_ut = {
-	.ts_name = "sm-ut",
-	.ts_init = init,
-	.ts_fini = fini,
-	.ts_tests = {
-		{ "transition", transition },
-		{ "ast",        ast_test },
-		{ "timeout",    timeout },
-		{ "group",      group },
-		{ NULL, NULL }
-	}
-};
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
diff --git a/sns/Makefile.am b/sns/Makefile.am
index 1902468..0fbfab1 100644
--- a/sns/Makefile.am
+++ b/sns/Makefile.am
@@ -1,4 +1,4 @@
-snsdir                          = $(includedir)/colibri/sns
+snsdir                          = $(includedir)/sns
 sns_HEADERS                     = ls_solve.h matvec.h parity_math.h \
                                   parity_ops.h repair.h sns.h
 
diff --git a/sns/ls_solve.c b/sns/ls_solve.c
index b4fc903..9ea8eba 100644
--- a/sns/ls_solve.c
+++ b/sns/ls_solve.c
@@ -13,7 +13,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Anatoliy Bilenko <Anatoliy_Bilenko@xyratex.com>
+ * Original author: Anatoliy Bilenko
  * Original creation date: 10/19/2010
  */
 
diff --git a/sns/ls_solve.h b/sns/ls_solve.h
index 74263bb..bd0fc46 100644
--- a/sns/ls_solve.h
+++ b/sns/ls_solve.h
@@ -14,7 +14,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Anatoliy Bilenko <Anatoliy_Bilenko@xyratex.com>
+ * Original author: Anatoliy Bilenko
  * Original creation date: 10/19/2010
  */
 
diff --git a/sns/matvec.c b/sns/matvec.c
index 4d5058f..080ec2c 100644
--- a/sns/matvec.c
+++ b/sns/matvec.c
@@ -13,7 +13,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Anatoliy Bilenko <Anatoliy_Bilenko@xyratex.com>
+ * Original author: Anatoliy Bilenko
  * Original creation date: 10/19/2010
  */
 
diff --git a/sns/matvec.h b/sns/matvec.h
index 6a5bcb2..f691f4e 100644
--- a/sns/matvec.h
+++ b/sns/matvec.h
@@ -14,7 +14,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Anatoliy Bilenko <Anatoliy_Bilenko@xyratex.com>
+ * Original author: Anatoliy Bilenko
  * Original creation date: 10/19/2010
  */
 
diff --git a/sns/parity_math.c b/sns/parity_math.c
index 4715a84..2f45450 100644
--- a/sns/parity_math.c
+++ b/sns/parity_math.c
@@ -13,7 +13,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Anatoliy Bilenko <Anatoliy_Bilenko@xyratex.com>
+ * Original author: Anatoliy Bilenko
  * Original creation date: 10/19/2010
  */
 
@@ -142,6 +142,7 @@ void c2_parity_math_fini(struct c2_parity_math *math)
 
 	c2_parity_fini();
 }
+C2_EXPORTED(c2_parity_math_fini);
 
 int  c2_parity_math_init(struct c2_parity_math *math,
 			 uint32_t data_count, uint32_t parity_count)
@@ -200,6 +201,7 @@ int  c2_parity_math_init(struct c2_parity_math *math,
 	c2_parity_math_fini(math);
 	return ret;
 }
+C2_EXPORTED(c2_parity_math_init);
 
 void c2_parity_math_calculate(struct c2_parity_math *math,
 			      struct c2_buf *data,
@@ -225,6 +227,7 @@ void c2_parity_math_calculate(struct c2_parity_math *math,
 			((uint8_t*)parity[ui].b_addr)[ei] = *c2_vector_elem_get(&math->pmi_parity, ui);
 	}
 }
+C2_EXPORTED(c2_parity_math_calculate);
 
 void c2_parity_math_refine(struct c2_parity_math *math,
 			   struct c2_buf *data,
@@ -338,6 +341,7 @@ void c2_parity_math_recover(struct c2_parity_math *math,
 	/* recalculate parity */
 	c2_parity_math_calculate(math, data, parity);
 }
+C2_EXPORTED(c2_parity_math_recover);
 
 /*
  *  Local variables:
diff --git a/sns/parity_math.h b/sns/parity_math.h
index 7057ba3..18fe897 100644
--- a/sns/parity_math.h
+++ b/sns/parity_math.h
@@ -13,7 +13,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Anatoliy Bilenko <Anatoliy_Bilenko@xyratex.com>
+ * Original author: Anatoliy Bilenko
  * Original creation date: 10/19/2010
  */
 
diff --git a/sns/parity_ops.c b/sns/parity_ops.c
index fb48016..e045c9e 100644
--- a/sns/parity_ops.c
+++ b/sns/parity_ops.c
@@ -14,7 +14,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Anatoliy Bilenko <Anatoliy_Bilenko@xyratex.com>
+ * Original author: Anatoliy Bilenko
  * Original creation date: 10/19/2010
  */
 
@@ -25,12 +25,14 @@ void c2_parity_fini(void)
 {
 	galois_calc_tables_release();
 }
+C2_EXPORTED(c2_parity_fini);
 
 void c2_parity_init(void)
 {
 	int ret = galois_create_mult_tables(C2_PARITY_GALOIS_W);
 	C2_ASSERT(ret == 0);
 }
+C2_EXPORTED(c2_parity_init);
 
 /*
  *  Local variables:
diff --git a/sns/parity_ops.h b/sns/parity_ops.h
index abe82b7..ecb43c8 100644
--- a/sns/parity_ops.h
+++ b/sns/parity_ops.h
@@ -14,14 +14,14 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Anatoliy Bilenko <Anatoliy_Bilenko@xyratex.com>
+ * Original author: Anatoliy Bilenko
  * Original creation date: 10/19/2010
  */
 
 #ifndef __COLIBRI_SNS_PARITY_OPS_H__
 #define __COLIBRI_SNS_PARITY_OPS_H__
 
-#include "galois/galois.h"
+#include "galois.h"
 #include "lib/assert.h"
 
 #define C2_PARITY_ZERO (0)
diff --git a/sns/poolmach.c b/sns/poolmach.c
index 9e11bc3..40a84a3 100644
--- a/sns/poolmach.c
+++ b/sns/poolmach.c
@@ -1,3 +1,4 @@
+#ifdef HAVE_CONFIG_H
 /*
  * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
  *
@@ -8,16 +9,14 @@
  * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
  * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
  * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
+
  * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
- *
- * Original author: Nikita Danilov <Nikita_Danilov@xyratex.com>
- * Original creation date: 04/28/2010
- */
 
-#ifdef HAVE_CONFIG_H
+ * Original author: $NAME
+ * Original creation date: MM/DD/YYYY
+ */
 #  include <config.h>
 #endif
 
diff --git a/sns/repair.c b/sns/repair.c
index a3e8af3..bc69407 100644
--- a/sns/repair.c
+++ b/sns/repair.c
@@ -13,8 +13,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Nikita Danilov <Nikita_Danilov@xyratex.com>,
- *                  Huang Hua <Hua_Huang@xyratex.com>
+ * Original author: Nikita Danilov, Huang Hua
  * Original creation date: 03/30/2010
  */
 
diff --git a/sns/repair.h b/sns/repair.h
index 02ca25c..f267cce 100644
--- a/sns/repair.h
+++ b/sns/repair.h
@@ -14,8 +14,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Nikita Danilov <Nikita_Danilov@xyratex.com>,
- *                  Huang Hua <Hua_Huang@xyratex.com>
+ * Original author: Nikita Danilov, Huang Hua
  * Original creation date: 03/30/2010
  */
 
@@ -29,8 +28,6 @@
 
 struct c2_io_req;
 struct c2_fop;
-struct c2_dtm;
-struct c2_dtx;
 
 /**
    @page snsrepair SNS repair detailed level design specification.
@@ -215,7 +212,7 @@ struct c2_poolmach_state {
    write mode.
 */
 struct c2_poolmach {
-	/* struct c2_persistent_sm  pm_mach; */
+	struct c2_persistent_sm  pm_mach;
 	struct c2_poolmach_state pm_state;
 	struct c2_rwlock         pm_lock;
 };
@@ -237,7 +234,7 @@ int  c2_poolmach_node_leave(struct c2_poolmach *pm, struct c2_poolnode *node);
    @{
 */
 
-/**
+/** 
    resource limit
 
    Data structure to describe the fraction of resource usage limitation:
@@ -252,7 +249,7 @@ struct c2_rlimit {
        int rl_network_throughput;
 };
 
-/**
+/** 
    pool server
 
    Pool server represents a pool node plus its state machines, lives locally on
@@ -262,7 +259,7 @@ struct c2_rlimit {
 */
 struct c2_poolserver {
 	struct c2_poolnode      ps_node;
-	/* struct c2_persistent_sm ps_mach; */
+	struct c2_persistent_sm ps_mach;
 	struct c2_rlimit	ps_rl_usage; /**< the current resource usage */
 };
 
@@ -272,9 +269,9 @@ int  c2_poolserver_reset(struct c2_poolserver *srv);
 int  c2_poolserver_on(struct c2_poolserver *srv);
 int  c2_poolserver_off(struct c2_poolserver *srv);
 int  c2_poolserver_io_req(struct c2_poolserver *srv, struct c2_io_req *req);
-int  c2_poolserver_device_join(struct c2_poolserver *srv,
+int  c2_poolserver_device_join(struct c2_poolserver *srv, 
 			       struct c2_pooldev *dev);
-int  c2_poolserver_device_leave(struct c2_poolserver *srv,
+int  c2_poolserver_device_leave(struct c2_poolserver *srv, 
 				struct c2_pooldev *dev);
 
 /** @} end of servermachine group */
@@ -308,7 +305,7 @@ int  c2_cm_oset_init(struct c2_cm_oset *oset);
 void c2_cm_oset_fini(struct c2_cm_oset *oset);
 
 struct c2_cm_copy_packet;
-/**
+/** 
    copy machine operations
 
    A copy machine has a handler which handles FOP requests. A copy machine is
@@ -388,7 +385,7 @@ struct c2_cm_aggrg_group {
 	struct c2_cm_copy_packet *cag_buffer;
 
 	/**
-	  XXX TODO How to represent all the containers/devices in this
+	  XXX TODO How to represent all the containers/devices in this 
 	  aggregation group? Some are on remote nodes, and some are local.
 	*/
 	struct c2_device        **cag_devices;
@@ -429,7 +426,7 @@ struct c2_cm_xform {
 		      struct c2_cm_copy_packet *cp);
 };
 
-/**
+/** 
    copy packet
 
    Copy packet is the data structure used to describe the packet flowing between
@@ -453,7 +450,7 @@ struct c2_cm_copy_packet {
 
 /** copy machine */
 struct c2_cm {
-	/* struct c2_persistent_sm cm_mach; */          /**< persistent state machine */
+	struct c2_persistent_sm cm_mach;          /**< persistent state machine */
 	struct c2_cm_stats	cm_stats;         /**< stats */
 	struct c2_rlimit  	cm_rlimit;        /**< resource limitation */
 	struct c2_cm_iset	cm_iset;          /**< input set description */
@@ -465,7 +462,7 @@ struct c2_cm {
 struct c2_cm_agent;
 struct c2_cm_agent_config { /* TODO */ };
 
-/**
+/** 
    copy machine agent operations
 
    A copy machine has a handler which handles FOP requests. A copy machine is
@@ -501,7 +498,7 @@ enum c2_cm_agent_type {
    should go onto persistent storage.
 */
 struct c2_cm_agent {
-	/* struct c2_persistent_sm       ag_mach; */
+	struct c2_persistent_sm       ag_mach;
 	struct c2_cm		     *ag_parent; /**< pointer to parent cm */
 	enum c2_cm_agent_type	      ag_type;   /**< agent type */
 
@@ -511,7 +508,7 @@ struct c2_cm_agent {
 
 	/** copy packet in flight of this agent */
 	struct c2_list	      	      ag_cp_in_flight; /**< list of all cp */
-
+	
 	bool			      ag_quit:1; /** flag to quit */
 };
 
@@ -588,7 +585,7 @@ int c2_cm_cp_refdel(struct c2_cm_copy_packet *cp);
 /* __COLIBRI_SNS_REPAIR_H__ */
 #endif
 
-/*
+/* 
  *  Local variables:
  *  c-indentation-style: "K&R"
  *  c-basic-offset: 8
diff --git a/sns/sns.c b/sns/sns.c
index d9277ee..407a8ea 100644
--- a/sns/sns.c
+++ b/sns/sns.c
@@ -13,7 +13,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
 
- * Original author: Nikita Danilov <Nikita_Danilov@xyratex.com>
+ * Original author: Nikita Danilov
  * Original creation date: 03/30/2010
  */
 
diff --git a/sns/sns.h b/sns/sns.h
index 19e31de..6d8f783 100644
--- a/sns/sns.h
+++ b/sns/sns.h
@@ -14,7 +14,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Nikita Danilov <Nikita_Danilov@xyratex.com>
+ * Original author: Nikita Danilov
  * Original creation date: 03/30/2010
  */
 
diff --git a/sns/ut/parity_math_mt_ub.c b/sns/ut/parity_math_mt_ub.c
index cadc1e9..8869220 100644
--- a/sns/ut/parity_math_mt_ub.c
+++ b/sns/ut/parity_math_mt_ub.c
@@ -13,7 +13,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Anatoliy Bilenko <Anatoliy_Bilenko@xyratex.com>
+ * Original author: Anatoliy Bilenko
  * Original creation date: 10/19/2010
  */
 
diff --git a/sns/ut/parity_math_ut.c b/sns/ut/parity_math_ut.c
index 9b46189..0fd38b0 100644
--- a/sns/ut/parity_math_ut.c
+++ b/sns/ut/parity_math_ut.c
@@ -13,7 +13,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Anatoliy Bilenko <Anatoliy_Bilenko@xyratex.com>
+ * Original author: Anatoliy Bilenko
  * Original creation date: 10/19/2010
  */
 
@@ -76,7 +76,7 @@ extern bool expected_cmp(uint32_t data_count, uint32_t buff_size)
 				/* printf("expected_cmp data[%d][%d]\n", i, j); */
 				return false;
 			}
-
+	
 	return true;
 }
 
@@ -107,7 +107,7 @@ static bool config_generate(uint32_t *data_count,
 			expected[i][j] = data[i][j];
 		}
 	}
-
+	
 	/* printf("f: "); */
 	j = 0;
 	for (i = 0; i < fuc; ++i)
@@ -120,7 +120,7 @@ static bool config_generate(uint32_t *data_count,
 		if (fail[i])
 			++j;
 	}
-
+	
 	if (!j) { /* at least one fail */
 		fail[fuc/2] = 1;
 	}
@@ -134,7 +134,7 @@ static bool config_generate(uint32_t *data_count,
 	*data_count = duc;
 	*parity_count = puc;
 	*buff_size = UNIT_BUFF_SIZE;
-
+	
 	fuc-=3;
 	return true;
 }
@@ -175,11 +175,11 @@ void test_parity_math(void)
 		c2_buf_init(&fail_buf, fail, buff_size);
 
 		c2_parity_math_calculate(&math, data_buf, parity_buf);
-
+	
 		unit_spoil(buff_size, fail_count, data_count);
 
 		c2_parity_math_recover(&math, data_buf, parity_buf, &fail_buf);
-
+	
 		c2_parity_math_fini(&math);
 
 		if (!expected_cmp(data_count, buff_size)) {
@@ -207,7 +207,6 @@ void parity_math_tb(void)
 
 		/* printf("0) d:%d, p:%d, b: %d\n", data_count, parity_count, buff_size); */
 		ret = c2_parity_math_init(&math, data_count, parity_count);
-		C2_ASSERT(ret == 0);
 		/* printf("1) %d\n", ret); */
 
 		for (i = 0; i < data_count; ++i) {
@@ -218,7 +217,7 @@ void parity_math_tb(void)
 		c2_buf_init(&fail_buf, fail, buff_size);
 
 		c2_parity_math_calculate(&math, data_buf, parity_buf);
-
+	
 		unit_spoil(buff_size, fail_count, data_count);
 
 		c2_parity_math_recover(&math, data_buf, parity_buf, &fail_buf);
diff --git a/stob/.gitignore b/stob/.gitignore
index 7ea1eca..13cd1fa 100644
--- a/stob/.gitignore
+++ b/stob/.gitignore
@@ -1,2 +1 @@
-server
-io_fop_u.[hc]
+server
\ No newline at end of file
diff --git a/stob/Makefile.am b/stob/Makefile.am
index de71533..9dbf697 100644
--- a/stob/Makefile.am
+++ b/stob/Makefile.am
@@ -1,18 +1,9 @@
-stobdir                     = $(includedir)/colibri/stob
+stobdir                     = $(includedir)/stob
 stob_HEADERS                = ad.h linux_getevents.h linux.h \
                               linux_internal.h stob.h
 
-io_fop_u.h io_fop_u.c : io_fop.ff \
-                        $(top_builddir)/fop/rt/libc2rt.la \
-                        $(top_builddir)/fop/fop2c
-	$(top_builddir)/fop/fop2c -u $<
-
-EXTRA_DIST = io_fop.ff
-
 libcolibri_stob_la_SOURCES  = stob.c stob.h linux.c linux.h \
                               linux_adieu.c linux_internal.h \
-                              linux_getevents.h ad.c ad.h \
-			      io_fop_u.h io_fop_u.c io_fop.c \
-			      io_fop.h
+                              linux_getevents.h ad.c ad.h
 
 noinst_LTLIBRARIES          = libcolibri-stob.la
diff --git a/stob/ad.c b/stob/ad.c
index 5da1637..b8ca516 100644
--- a/stob/ad.c
+++ b/stob/ad.c
@@ -13,7 +13,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Nikita Danilov <Nikita_Danilov@xyratex.com>
+ * Original author: Nikita Danilov
  * Original creation date: 08/24/2010
  */
 
@@ -24,12 +24,9 @@
 #include <errno.h>
 #include <string.h>                 /* memset */
 
-#include "dtm/dtm.h"                /* c2_dtx */
 #include "lib/thread.h"             /* LAMBDA */
 #include "lib/memory.h"
 #include "lib/arith.h"              /* min_type, min3 */
-#include "lib/tlist.h"
-
 #include "stob/ad.h"
 
 /**
@@ -95,8 +92,6 @@ C2_ADDB_ADD(&(obj)->so_addb, &ad_stob_addb_loc, c2_addb_func_fail, (name), (rc))
 struct ad_domain {
 	struct c2_stob_domain      ad_base;
 
-	char			   ad_path[MAXPATHLEN];
-
 	struct c2_dbenv           *ad_dbenv;
 	/**
 	   Extent map storing mapping from logical to physical offsets.
@@ -104,8 +99,8 @@ struct ad_domain {
 	struct c2_emap             ad_adata;
 
 	/**
-	   Set to true in c2_ad_stob_setup(). Used in pre-conditions to
-	   guarantee that the domain is fully initialized.
+	   Set to true in ad_setup(). Used in pre-conditions to guarantee that
+	   the domain is fully initialized.
 	 */
 	bool                       ad_setup;
 	/**
@@ -114,7 +109,7 @@ struct ad_domain {
 	 */
 	struct c2_stob            *ad_bstore;
 	/** List of all existing c2_stob's. */
-	struct c2_tl               ad_object;
+	struct c2_list             ad_object;
 	struct ad_balloc          *ad_ballroom;
 
 };
@@ -126,16 +121,9 @@ struct ad_domain {
  */
 struct ad_stob {
 	struct c2_stob      as_stob;
-	struct c2_tlink     as_linkage;
-	uint64_t            as_magix;
+	struct c2_list_link as_linkage;
 };
 
-C2_TL_DESCR_DEFINE(ad, "ad stobs", static, struct ad_stob, as_linkage, as_magix,
-		   0xc01101da1fe11c1a /* colloidal felicia */,
-		   0x1dea112ed5ea51de /* idealized seaside */);
-
-C2_TL_DEFINE(ad, static, struct ad_stob);
-
 static inline struct ad_stob *stob2ad(struct c2_stob *stob)
 {
 	return container_of(stob, struct ad_stob, as_stob);
@@ -202,7 +190,6 @@ static void ad_domain_fini(struct c2_stob_domain *self)
 		c2_emap_fini(&adom->ad_adata);
 		c2_stob_put(adom->ad_bstore);
 	}
-	ad_tlist_fini(&adom->ad_object);
 	c2_stob_domain_fini(self);
 	c2_free(adom);
 }
@@ -210,8 +197,8 @@ static void ad_domain_fini(struct c2_stob_domain *self)
 /**
    Implementation of c2_stob_type_op::sto_domain_locate().
 
-   @note the domain returned is not immediately ready for
-   use. c2_ad_stob_setup() has to be called against it first.
+   @note the domain returned is not immediately ready for use. ad_setup() has to
+   be called against it first.
  */
 static int ad_stob_type_domain_locate(struct c2_stob_type *type,
 				      const char *domain_name,
@@ -221,18 +208,13 @@ static int ad_stob_type_domain_locate(struct c2_stob_type *type,
 	struct c2_stob_domain *dom;
 	int                    result;
 
-	C2_ASSERT(domain_name != NULL);
-	C2_ASSERT(strlen(domain_name) < ARRAY_SIZE(adom->ad_path));
-
 	C2_ALLOC_PTR(adom);
 	if (adom != NULL) {
 		adom->ad_setup = false;
-		ad_tlist_init(&adom->ad_object);
+		c2_list_init(&adom->ad_object);
 		dom = &adom->ad_base;
 		dom->sd_ops = &ad_stob_domain_op;
 		c2_stob_domain_init(dom, type);
-		strcpy(adom->ad_path, domain_name);
-		dom->sd_name = adom->ad_path;
 		*out = dom;
 		result = 0;
 	} else {
@@ -242,15 +224,11 @@ static int ad_stob_type_domain_locate(struct c2_stob_type *type,
 	return result;
 }
 
-int c2_ad_stob_setup(struct c2_stob_domain *dom, struct c2_dbenv *dbenv,
-		     struct c2_stob *bstore, struct ad_balloc *ballroom,
-		     c2_bcount_t container_size, c2_bcount_t bshift,
-		     c2_bcount_t blocks_per_group, c2_bcount_t res_groups)
+int ad_setup(struct c2_stob_domain *dom, struct c2_dbenv *dbenv,
+	     struct c2_stob *bstore, struct ad_balloc *ballroom)
 {
-	int			 result;
-	c2_bcount_t		 groupsize;
-	c2_bcount_t		 blocksize;
-	struct ad_domain	*adom;
+	int result;
+	struct ad_domain *adom;
 
 	adom = domain2ad(dom);
 
@@ -258,15 +236,8 @@ int c2_ad_stob_setup(struct c2_stob_domain *dom, struct c2_dbenv *dbenv,
 	C2_PRE(!adom->ad_setup);
 	C2_PRE(bstore->so_state == CSS_EXISTS);
 
-	blocksize = 1 << bshift;
-	groupsize = blocks_per_group * blocksize;
-
-	C2_PRE(groupsize > blocksize);
-	C2_PRE(container_size > groupsize);
-	C2_PRE(container_size / groupsize > res_groups);
-
 	result = ballroom->ab_ops->bo_init
-		(ballroom, dbenv, bshift, container_size, blocks_per_group, res_groups);
+		(ballroom, dbenv, bstore->so_op->sop_block_shift(bstore));
 	if (result == 0) {
 		adom->ad_dbenv    = dbenv;
 		adom->ad_bstore   = bstore;
@@ -293,13 +264,14 @@ static struct ad_stob *ad_domain_lookup(struct ad_domain *adom,
 	C2_PRE(adom->ad_setup);
 
 	found = false;
-	c2_tlist_for(&ad_tl, &adom->ad_object, obj) {
+	c2_list_for_each_entry(&adom->ad_object, obj,
+			       struct ad_stob, as_linkage) {
 		if (c2_stob_id_eq(id, &obj->as_stob.so_id)) {
 			c2_stob_get(&obj->as_stob);
 			found = true;
 			break;
 		}
-	} c2_tlist_endfor;
+	}
 	return found ? obj : NULL;
 }
 
@@ -336,7 +308,8 @@ static int ad_domain_stob_find(struct c2_stob_domain *dom,
 				stob = &astob->as_stob;
 				stob->so_op = &ad_stob_op;
 				c2_stob_init(stob, id, dom);
-				ad_tlink_init_at(astob, &adom->ad_object);
+				c2_list_add(&adom->ad_object,
+					    &astob->as_linkage);
 			} else {
 				c2_free(astob);
 				astob = ghost;
@@ -376,7 +349,7 @@ static void ad_stob_fini(struct c2_stob *stob)
 	struct ad_stob *astob;
 
 	astob = stob2ad(stob);
-	ad_tlink_del_fini(astob);
+	c2_list_del(&astob->as_linkage);
 	c2_stob_fini(&astob->as_stob);
 	c2_free(astob);
 }
@@ -520,7 +493,7 @@ struct ad_stob_io {
 	struct c2_clink    ai_clink;
 };
 
-static bool ad_endio(struct c2_clink *link);
+static void ad_endio(struct c2_clink *link);
 
 /**
    Helper function to allocate a given number of blocks in the underlying
@@ -577,7 +550,7 @@ int ad_stob_io_init(struct c2_stob *stob, struct c2_stob_io *io)
    Releases vectors allocated for back IO.
 
    @note that back->si_stob.ov_vec.v_count is _not_ freed separately, as it is
-   aliased to back->si_user.z_bvec.ov_vec.v_count.
+   aliased to back->si_user.div_vec.ov_vec.v_count.
 
    @see ad_vec_alloc()
  */
@@ -586,14 +559,14 @@ static void ad_stob_io_release(struct ad_stob_io *aio)
 	struct c2_stob_io *back = &aio->ai_back;
 
 	C2_ASSERT(back->si_stob.iv_vec.v_count ==
-		  back->si_user.ov_vec.v_count);
+		  back->si_user.div_vec.ov_vec.v_count);
 
-	c2_free(back->si_user.ov_vec.v_count);
-	back->si_user.ov_vec.v_count = NULL;
+	c2_free(back->si_user.div_vec.ov_vec.v_count);
+	back->si_user.div_vec.ov_vec.v_count = NULL;
 	back->si_stob.iv_vec.v_count = NULL;
 
-	c2_free(back->si_user.ov_buf);
-	back->si_user.ov_buf = NULL;
+	c2_free(back->si_user.div_vec.ov_buf);
+	back->si_user.div_vec.ov_buf = NULL;
 
 	c2_free(back->si_stob.iv_index);
 	back->si_stob.iv_index = NULL;
@@ -628,7 +601,7 @@ static int ad_cursors_init(struct c2_stob_io *io, struct ad_domain *adom,
 	result = ad_cursor(adom, io->si_obj, io->si_stob.iv_index[0],
 			   io->si_tx, it);
 	if (result == 0) {
-		c2_vec_cursor_init(src, &io->si_user.ov_vec);
+		c2_vec_cursor_init(src, &io->si_user.div_vec.ov_vec);
 		c2_vec_cursor_init(dst, &io->si_stob.iv_vec);
 		c2_emap_caret_init(map, it, io->si_stob.iv_index[0]);
 	}
@@ -658,20 +631,20 @@ static int ad_vec_alloc(struct c2_stob *obj,
 	c2_bcount_t *counts;
 	int          result;
 
-	C2_ASSERT(back->si_user.ov_vec.v_count == NULL);
+	C2_ASSERT(back->si_user.div_vec.ov_vec.v_count == NULL);
 
 	result = 0;
 	if (frags > 0) {
 		C2_ALLOC_ARR(counts, frags);
-		back->si_user.ov_vec.v_count = counts;
+		back->si_user.div_vec.ov_vec.v_count = counts;
 		back->si_stob.iv_vec.v_count = counts;
-		C2_ALLOC_ARR(back->si_user.ov_buf, frags);
+		C2_ALLOC_ARR(back->si_user.div_vec.ov_buf, frags);
 		C2_ALLOC_ARR(back->si_stob.iv_index, frags);
 
-		back->si_user.ov_vec.v_nr = frags;
+		back->si_user.div_vec.ov_vec.v_nr = frags;
 		back->si_stob.iv_vec.v_nr = frags;
 
-		if (counts == NULL || back->si_user.ov_buf == NULL ||
+		if (counts == NULL || back->si_user.div_vec.ov_buf == NULL ||
 		    back->si_stob.iv_index == NULL) {
 			ADDB_ADD(obj, c2_addb_oom);
 			result = -ENOMEM;
@@ -808,7 +781,7 @@ static int ad_read_launch(struct c2_stob_io *io, struct ad_domain *adom,
 		void        *buf;
 		c2_bindex_t  off;
 
-		buf = io->si_user.ov_buf[src->vc_seg] + src->vc_offset;
+		buf = io->si_user.div_vec.ov_buf[src->vc_seg] + src->vc_offset;
 		off = io->si_stob.iv_index[dst->vc_seg] + dst->vc_offset;
 
 		C2_ASSERT(off >= map->ct_index);
@@ -835,8 +808,8 @@ static int ad_read_launch(struct c2_stob_io *io, struct ad_domain *adom,
 		} else {
 			C2_ASSERT(seg->ee_val < AET_MIN);
 
-			back->si_user.ov_vec.v_count[idx] = frag_size;
-			back->si_user.ov_buf[idx] = buf;
+			back->si_user.div_vec.ov_vec.v_count[idx] = frag_size;
+			back->si_user.div_vec.ov_buf[idx] = buf;
 
 			back->si_stob.iv_index[idx] = seg->ee_val +
 				(off - seg->ee_ext.e_start);
@@ -955,10 +928,10 @@ static void ad_write_back_fill(struct c2_stob_io *io, struct c2_stob_io *back,
 		frag_size = min_check(c2_vec_cursor_step(src),
 				      ad_wext_cursor_step(wc));
 
-		buf = io->si_user.ov_buf[src->vc_seg] + src->vc_offset;
+		buf = io->si_user.div_vec.ov_buf[src->vc_seg] + src->vc_offset;
 
-		back->si_user.ov_vec.v_count[idx] = frag_size;
-		back->si_user.ov_buf[idx] = buf;
+		back->si_user.div_vec.ov_vec.v_count[idx] = frag_size;
+		back->si_user.div_vec.ov_buf[idx] = buf;
 
 		back->si_stob.iv_index[idx] =
 			wc->wc_wext->we_ext.e_start + wc->wc_done;
@@ -1088,9 +1061,9 @@ static int ad_write_map(struct c2_stob_io *io, struct ad_domain *adom,
 
 		todo.e_start = wc->wc_wext->we_ext.e_start + wc->wc_done;
 		todo.e_end   = todo.e_start + frag_size;
-
+		
 		result = ad_write_map_ext(io, adom, offset, map->ct_it, &todo);
-
+		
 		if (result != 0)
 			break;
 
@@ -1143,7 +1116,7 @@ static int ad_write_launch(struct c2_stob_io *io, struct ad_domain *adom,
 
 	C2_PRE(io->si_opcode == SIO_WRITE);
 
-	todo = c2_vec_count(&io->si_user.ov_vec);
+	todo = c2_vec_count(&io->si_user.div_vec.ov_vec);
 	back = &aio->ai_back;
 	wext = &head;
 	wext->we_next = NULL;
@@ -1176,13 +1149,13 @@ static int ad_write_launch(struct c2_stob_io *io, struct ad_domain *adom,
 
 		result = ad_vec_alloc(io->si_obj, back, frags);
 		if (result == 0) {
-			c2_vec_cursor_init(src, &io->si_user.ov_vec);
+			c2_vec_cursor_init(src, &io->si_user.div_vec.ov_vec);
 			c2_vec_cursor_init(dst, &io->si_stob.iv_vec);
 			ad_wext_cursor_init(&wc, &head);
 
 			ad_write_back_fill(io, back, src, &wc);
 
-			c2_vec_cursor_init(src, &io->si_user.ov_vec);
+			c2_vec_cursor_init(src, &io->si_user.div_vec.ov_vec);
 			c2_vec_cursor_init(dst, &io->si_stob.iv_vec);
 			ad_wext_cursor_init(&wc, &head);
 
@@ -1215,7 +1188,7 @@ static int ad_stob_io_launch(struct c2_stob_io *io)
 	C2_PRE(adom->ad_setup);
 	C2_PRE(io->si_obj->so_domain->sd_type == &ad_stob_type);
 	C2_PRE(io->si_stob.iv_vec.v_nr > 0);
-	C2_PRE(c2_vec_count(&io->si_user.ov_vec) > 0);
+	C2_PRE(c2_vec_count(&io->si_user.div_vec.ov_vec) > 0);
 
 	/* prefix fragments execution mode is not yet supported */
 	C2_ASSERT((io->si_flags & SIF_PREFIX) == 0);
@@ -1292,7 +1265,7 @@ static uint32_t ad_stob_block_shift(const struct c2_stob *stob)
 	return ad_bshift(domain2ad(stob->so_domain));
 }
 
-static bool ad_endio(struct c2_clink *link)
+static void ad_endio(struct c2_clink *link)
 {
 	struct ad_stob_io *aio;
 	struct c2_stob_io *io;
@@ -1308,7 +1281,6 @@ static bool ad_endio(struct c2_clink *link)
 	io->si_state  = SIS_IDLE;
 	ad_stob_io_release(aio);
 	c2_chan_broadcast(&io->si_wait);
-	return true;
 }
 
 static const struct c2_stob_io_op ad_stob_io_op = {
@@ -1349,14 +1321,14 @@ const struct c2_addb_ctx_type ad_stob_ctx_type = {
 	.act_name = "adstob"
 };
 
-int c2_ad_stobs_init(void)
+int ad_stobs_init(void)
 {
 	c2_addb_ctx_init(&ad_stob_ctx, &ad_stob_ctx_type,
 			 &c2_addb_global_ctx);
 	return ad_stob_type.st_op->sto_init(&ad_stob_type);
 }
 
-void c2_ad_stobs_fini(void)
+void ad_stobs_fini(void)
 {
 	ad_stob_type.st_op->sto_fini(&ad_stob_type);
 	c2_addb_ctx_fini(&ad_stob_ctx);
diff --git a/stob/ad.h b/stob/ad.h
index 9f82f27..24971f9 100644
--- a/stob/ad.h
+++ b/stob/ad.h
@@ -14,7 +14,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Nikita Danilov <Nikita_Danilov@xyratex.com>
+ * Original author: Nikita Danilov
  * Original creation date: 08/24/2010
  */
 
@@ -29,9 +29,9 @@
 
    AD storage object type (ad_stob_type) manages collections of storage objects
    with in an underlying storage object. The underlying storage object is
-   specified per-domain by a call to c2_ad_stob_setup() function.
+   specified per-domain by a call to ad_setup() function.
 
-   ad_stob_type uses data-base (also specified as a parameter to c2_ad_stob_setup()) to
+   ad_stob_type uses data-base (also specified as a parameter to ad_setup()) to
    store extent map (c2_emap) which keeps track of mapping between logical
    offsets in AD stobs and physical offsets within underlying stob.
 
@@ -60,17 +60,13 @@ struct ad_balloc {
 
 struct ad_balloc_ops {
 	/** Initializes this balloc instance, creating its persistent state, if
-	    necessary.
+	    necessary. 
 
 	    @param block size shift in bytes, similarly to
 	    c2_stob_op::sop_block_shift().
-	    @param container_size Total size of the container in bytes
-	    @param  blocks_per_group # of blocks per group
-	    @param res_groups # of reserved groups
 	 */
 	int  (*bo_init)(struct ad_balloc *ballroom, struct c2_dbenv *db,
-			uint32_t bshift, c2_bcount_t container_size,
-			c2_bcount_t blocks_per_group, c2_bcount_t res_groups);
+			uint32_t bshift);
 	void (*bo_fini)(struct ad_balloc *ballroom);
 	/** Allocates count of blocks. On success, allocated extent, also
 	    measured in blocks, is returned in out parameter. */
@@ -93,20 +89,18 @@ struct ad_balloc_ops {
 
    @param ballroom - a byte allocator.
  */
-int  c2_ad_stob_setup(struct c2_stob_domain *adom, struct c2_dbenv *dbenv,
-		      struct c2_stob *bstore, struct ad_balloc *ballroom,
-		      c2_bindex_t container_size, c2_bcount_t bshift,
-		      c2_bcount_t blocks_per_group, c2_bcount_t res_groups);
+int  ad_setup(struct c2_stob_domain *adom, struct c2_dbenv *dbenv,
+	      struct c2_stob *bstore, struct ad_balloc *ballroom);
 
-int  c2_ad_stobs_init(void);
-void c2_ad_stobs_fini(void);
+int  ad_stobs_init(void);
+void ad_stobs_fini(void);
 
 /** @} end group stobad */
 
 /* __COLIBRI_STOB_AD_INTERNAL_H__ */
 #endif
 
-/*
+/* 
  *  Local variables:
  *  c-indentation-style: "K&R"
  *  c-basic-offset: 8
diff --git a/stob/io_fop.c b/stob/io_fop.c
deleted file mode 100644
index 8154227..0000000
--- a/stob/io_fop.c
+++ /dev/null
@@ -1,678 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Mandar Sawant <Mandar_Sawant@xyratex.com>
- * Original creation date: 05/04/2011
- */
-
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif
-
-#include "lib/misc.h"
-#include "lib/errno.h"
-#include "lib/assert.h"
-#include "lib/memory.h"
-#include "lib/chan.h"
-#include "lib/list.h"
-
-#include "net/net.h"
-#include "fop/fop.h"
-#include "reqh/reqh.h"
-#include "fop/fom.h"
-#include "fop/fop_iterator.h"
-#include "stob/stob.h"
-#include "stob/ad.h"
-#include "stob/linux.h"
-#include "net/bulk_sunrpc.h"
-#include "rpc/rpc2.h"
-#include "rpc/rpc_onwire.h"
-#include "rpc/rpc_opcodes.h"
-#include "fop/fop_item_type.h"
-#include "xcode/bufvec_xcode.h"
-
-#include "fop/fop_format_def.h"
-
-#ifdef __KERNEL__
-#include "stob/io_fop_k.h"
-#else
-#include "stob/io_fop_u.h"
-#endif
-
-#include "stob/io_fop.ff"
-
-/**
-   @defgroup stobio
-   @{
- */
-
-/**
- * Read fop specific fom execution phases
- */
-enum stob_read_fom_phase {
-	FOPH_READ_STOB_IO = FOPH_NR + 1,
-	FOPH_READ_STOB_IO_WAIT
-};
-
-/**
- * Write fop specific fom execution phases
- */
-enum stob_write_fom_phase {
-	FOPH_WRITE_STOB_IO = FOPH_NR + 1,
-	FOPH_WRITE_STOB_IO_WAIT
-};
-
-/**
- * RPC item operations structures
- */
-/**
- * Fop operation structures for corresponding fops.
- */
-static const struct c2_fop_type_ops default_fop_ops = {
-        .fto_size_get = c2_xcode_fop_size_get,
-};
-
-static const struct c2_fop_type_ops default_rep_fop_ops = {
-        .fto_size_get = c2_xcode_fop_size_get,
-};
-
-/**
- * Fop type declarations for corresponding fops
- */
-C2_FOP_TYPE_DECLARE(c2_stob_io_create, "stob_create", &default_fop_ops,
-		    C2_STOB_IO_CREATE_REQ_OPCODE,
-		    C2_RPC_ITEM_TYPE_REQUEST | C2_RPC_ITEM_TYPE_MUTABO);
-C2_FOP_TYPE_DECLARE(c2_stob_io_read, "stob_read", &default_fop_ops,
-		    C2_STOB_IO_READ_REQ_OPCODE,
-		    C2_RPC_ITEM_TYPE_REQUEST | C2_RPC_ITEM_TYPE_MUTABO);
-C2_FOP_TYPE_DECLARE(c2_stob_io_write, "stob_write", &default_fop_ops,
-		    C2_STOB_IO_WRITE_REQ_OPCODE,
-		    C2_RPC_ITEM_TYPE_REQUEST | C2_RPC_ITEM_TYPE_MUTABO);
-
-C2_FOP_TYPE_DECLARE(c2_stob_io_create_rep, "stob_create reply",
-		    &default_rep_fop_ops,
-		    C2_STOB_IO_CREATE_REPLY_OPCODE,
-		    C2_RPC_ITEM_TYPE_REPLY);
-C2_FOP_TYPE_DECLARE(c2_stob_io_read_rep, "stob_read reply",
-		    &default_rep_fop_ops,
-		    C2_STOB_IO_READ_REPLY_OPCODE,
-		    C2_RPC_ITEM_TYPE_REPLY);
-C2_FOP_TYPE_DECLARE(c2_stob_io_write_rep, "stob_write reply",
-		    &default_rep_fop_ops,
-		    C2_STOB_IO_WRITE_REPLY_OPCODE,
-		    C2_RPC_ITEM_TYPE_REPLY);
-
-/**
- * Fop type structures required for initialising corresponding fops.
- */
-static struct c2_fop_type *stob_fops[] = {
-	&c2_stob_io_create_fopt,
-	&c2_stob_io_write_fopt,
-	&c2_stob_io_read_fopt,
-
-	&c2_stob_io_create_rep_fopt,
-	&c2_stob_io_write_rep_fopt,
-	&c2_stob_io_read_rep_fopt,
-};
-
-static struct c2_fop_type_format *stob_fmts[] = {
-        &stob_io_fop_fid_tfmt,
-};
-
-/**
- * A generic fom structure to hold fom, reply fop, storage object
- * and storage io object, used for fop execution.
- */
-struct c2_stob_io_fom {
-	/** Generic c2_fom object. */
-	struct c2_fom			 sif_fom;
-	/** Reply FOP associated with request FOP above. */
-	struct c2_fop			*sif_rep_fop;
-	/** Stob object on which this FOM is acting. */
-	struct c2_stob			*sif_stobj;
-	/** Stob IO packet for the operation. */
-	struct c2_stob_io		 sif_stio;
-};
-
-static int stob_create_fom_create(struct c2_fop *fop, struct c2_fom **out);
-static int stob_read_fom_create(struct c2_fop *fop, struct c2_fom **out);
-static int stob_write_fom_create(struct c2_fop *fop, struct c2_fom **out);
-
-static int stob_create_fom_state(struct c2_fom *fom);
-static int stob_read_fom_state(struct c2_fom *fom);
-static int stob_write_fom_state(struct c2_fom *fom);
-
-static void stob_io_fom_fini(struct c2_fom *fom);
-static size_t stob_find_fom_home_locality(const struct c2_fom *fom);
-
-/**
- * Operation structures for respective foms
- */
-static struct c2_fom_ops stob_create_fom_ops = {
-	.fo_fini = stob_io_fom_fini,
-	.fo_state = stob_create_fom_state,
-	.fo_home_locality = stob_find_fom_home_locality,
-};
-
-static struct c2_fom_ops stob_write_fom_ops = {
-	.fo_fini = stob_io_fom_fini,
-	.fo_state = stob_write_fom_state,
-	.fo_home_locality = stob_find_fom_home_locality,
-};
-
-static struct c2_fom_ops stob_read_fom_ops = {
-	.fo_fini = stob_io_fom_fini,
-	.fo_state = stob_read_fom_state,
-	.fo_home_locality = stob_find_fom_home_locality,
-};
-
-/**
- * Fom type operations structures for corresponding foms.
- */
-static const struct c2_fom_type_ops stob_create_fom_type_ops = {
-	.fto_create = stob_create_fom_create,
-};
-
-static const struct c2_fom_type_ops stob_read_fom_type_ops = {
-	.fto_create = stob_read_fom_create,
-};
-
-static const struct c2_fom_type_ops stob_write_fom_type_ops = {
-	.fto_create = stob_write_fom_create,
-};
-
-static struct c2_fom_type stob_create_fom_mopt = {
-	.ft_ops = &stob_create_fom_type_ops,
-};
-
-static struct c2_fom_type stob_read_fom_mopt = {
-	.ft_ops = &stob_read_fom_type_ops,
-};
-
-static struct c2_fom_type stob_write_fom_mopt = {
-	.ft_ops = &stob_write_fom_type_ops,
-};
-
-static struct c2_fom_type *stob_fom_types[] = {
-	&stob_create_fom_mopt,
-	&stob_write_fom_mopt,
-	&stob_read_fom_mopt,
-};
-
-/**
- * Function to map a fop to its corresponding fom
- */
-static struct c2_fom_type *stob_fom_type_map(c2_fop_type_code_t code)
-{
-	C2_ASSERT(IS_IN_ARRAY((code - C2_STOB_IO_CREATE_REQ_OPCODE),
-			      stob_fom_types));
-
-	return stob_fom_types[code - C2_STOB_IO_CREATE_REQ_OPCODE];
-}
-
-/**
- * Function to locate a storage object.
- */
-static struct c2_stob *stob_object_find(const struct stob_io_fop_fid *fid,
-                                   struct c2_dtx *tx, struct c2_fom *fom)
-{
-	struct c2_stob_id	 id;
-	struct c2_stob		*obj;
-	int			 result;
-	struct c2_stob_domain	*fom_stdom;
-
-	id.si_bits.u_hi = fid->f_seq;
-	id.si_bits.u_lo = fid->f_oid;
-	fom_stdom = fom->fo_loc->fl_dom->fd_reqh->rh_stdom;
-	result = fom_stdom->sd_ops->sdo_stob_find(fom_stdom, &id, &obj);
-	C2_ASSERT(result == 0);
-	result = c2_stob_locate(obj, tx);
-	return obj;
-}
-
-/**
- * Fom initialization function, invoked from reqh_fop_handle.
- * Invokes c2_fom_create()
- */
-static int stob_io_fop_fom_create_helper(struct c2_fop *fop,
-		struct c2_fom_ops *fom_ops, struct c2_fop_type *fop_type,
-		struct c2_fom **out)
-{
-	struct c2_stob_io_fom *fom_obj;
-
-	C2_PRE(fop != NULL);
-	C2_PRE(fom_ops != NULL);
-	C2_PRE(fop_type != NULL);
-	C2_PRE(out != NULL);
-
-	fom_obj= c2_alloc(sizeof *fom_obj);
-	if (fom_obj == NULL)
-		return -ENOMEM;
-	fom_obj->sif_rep_fop = c2_fop_alloc(fop_type, NULL);
-	if (fom_obj->sif_rep_fop == NULL) {
-		c2_free(fom_obj);
-		return -ENOMEM;
-	}
-	fom_obj->sif_stobj = NULL;
-
-	c2_fom_create(&fom_obj->sif_fom, &fop->f_type->ft_fom_type, fom_ops, fop,
-			fom_obj->sif_rep_fop);
-
-	*out = &fom_obj->sif_fom;
-	return 0;
-}
-
-/**
- * Creates a fom for create fop.
- */
-static int stob_create_fom_create(struct c2_fop *fop, struct c2_fom **out)
-{
-	return stob_io_fop_fom_create_helper(fop, &stob_create_fom_ops,
-				      &c2_stob_io_create_rep_fopt, out);
-}
-
-/**
- * Creates a fom for write fop.
- */
-static int stob_write_fom_create(struct c2_fop *fop, struct c2_fom **out)
-{
-	return stob_io_fop_fom_create_helper(fop, &stob_write_fom_ops,
-				      &c2_stob_io_write_rep_fopt, out);
-}
-
-/**
- * Creates a fom for read fop.
- */
-static int stob_read_fom_create(struct c2_fop *fop, struct c2_fom **out)
-{
-	return stob_io_fop_fom_create_helper(fop, &stob_read_fom_ops,
-				      &c2_stob_io_read_rep_fopt, out);
-}
-
-/**
- * Finds home locality for this type of fom.
- * This function, using a basic hashing method
- * locates a home locality for a particular type
- * of fome, inorder to have same locality of
- * execution for a certain type of fom.
- */
-static size_t stob_find_fom_home_locality(const struct c2_fom *fom)
-{
-	size_t iloc;
-
-	if (fom == NULL)
-		return -EINVAL;
-
-	switch (fom->fo_fop->f_type->ft_rpc_item_type.rit_opcode) {
-	case C2_STOB_IO_CREATE_REQ_OPCODE: {
-		struct c2_stob_io_create *fop;
-		uint64_t oid;
-		fop = c2_fop_data(fom->fo_fop);
-		oid = fop->fic_object.f_oid;
-		iloc = oid;
-		break;
-	}
-	case C2_STOB_IO_WRITE_REQ_OPCODE: {
-		struct c2_stob_io_read *fop;
-		uint64_t oid;
-		fop = c2_fop_data(fom->fo_fop);
-		oid = fop->fir_object.f_oid;
-		iloc = oid;
-		break;
-	}
-	case C2_STOB_IO_READ_REQ_OPCODE: {
-		struct c2_stob_io_write *fop;
-		uint64_t oid;
-		fop = c2_fop_data(fom->fo_fop);
-		oid = fop->fiw_object.f_oid;
-		iloc = oid;
-		break;
-	}
-	default:
-		return -EINVAL;
-	}
-	return iloc;
-}
-
-/**
- * A simple non blocking create fop specific fom
- * state method implemention.
- */
-static int stob_create_fom_state(struct c2_fom *fom)
-{
-	struct c2_stob_io_create	*in_fop;
-	struct c2_stob_io_create_rep	*out_fop;
-	struct c2_stob_io_fom		*fom_obj;
-	struct c2_rpc_item              *item;
-	struct c2_fop                   *fop;
-	int                             result;
-
-	C2_PRE(fom->fo_fop->f_type->ft_rpc_item_type.rit_opcode ==
-			C2_STOB_IO_CREATE_REQ_OPCODE);
-
-	fom_obj = container_of(fom, struct c2_stob_io_fom, sif_fom);
-	if (fom->fo_phase < FOPH_NR) {
-		result = c2_fom_state_generic(fom);
-	} else {
-		in_fop = c2_fop_data(fom->fo_fop);
-		out_fop = c2_fop_data(fom_obj->sif_rep_fop);
-
-		fom_obj->sif_stobj = stob_object_find(&in_fop->fic_object, &fom->fo_tx, fom);
-
-		result = c2_stob_create(fom_obj->sif_stobj, &fom->fo_tx);
-		out_fop->ficr_rc = result;
-		fop = fom_obj->sif_rep_fop;
-		item = c2_fop_to_rpc_item(fop);
-		item->ri_type = &fop->f_type->ft_rpc_item_type;
-		item->ri_group = NULL;
-		fom->fo_rep_fop = fom_obj->sif_rep_fop;
-		fom->fo_rc = result;
-		if (result != 0)
-			fom->fo_phase = FOPH_FAILURE;
-		 else
-			fom->fo_phase = FOPH_SUCCESS;
-
-		result = c2_fop_fol_rec_add(fom->fo_fop, fom->fo_fol, &fom->fo_tx.tx_dbtx);
-		C2_ASSERT(result == 0);
-		result = FSO_AGAIN;
-	}
-
-	if (fom->fo_phase == FOPH_FINISH && fom->fo_rc == 0)
-		c2_stob_put(fom_obj->sif_stobj);
-
-	return result;
-}
-
-/**
- * A simple non blocking read fop specific fom
- * state method implemention.
- */
-static int stob_read_fom_state(struct c2_fom *fom)
-{
-        struct c2_stob_io_read      *in_fop;
-        struct c2_stob_io_read_rep  *out_fop;
-        struct c2_stob_io_fom           *fom_obj;
-        struct c2_stob_io               *stio;
-        struct c2_stob                  *stobj;
-	struct c2_rpc_item              *item;
-	struct c2_fop                   *fop;
-        void                            *addr;
-        c2_bcount_t                      count;
-        c2_bcount_t                      offset;
-        uint32_t                         bshift;
-        int                              result;
-
-        C2_PRE(fom->fo_fop->f_type->ft_rpc_item_type.rit_opcode ==
-			C2_STOB_IO_READ_REQ_OPCODE);
-
-        fom_obj = container_of(fom, struct c2_stob_io_fom, sif_fom);
-        stio = &fom_obj->sif_stio;
-        if (fom->fo_phase < FOPH_NR) {
-                result = c2_fom_state_generic(fom);
-        } else {
-                out_fop = c2_fop_data(fom_obj->sif_rep_fop);
-                C2_ASSERT(out_fop != NULL);
-
-                if (fom->fo_phase == FOPH_READ_STOB_IO) {
-
-                        in_fop = c2_fop_data(fom->fo_fop);
-                        C2_ASSERT(in_fop != NULL);
-                        fom_obj->sif_stobj = stob_object_find(&in_fop->fir_object,
-                                                                &fom->fo_tx, fom);
-
-                        stobj =  fom_obj->sif_stobj;
-                        bshift = stobj->so_op->sop_block_shift(stobj);
-
-                        addr = c2_stob_addr_pack(&out_fop->firr_value, bshift);
-                        count = 1 >> bshift;
-                        offset = 0;
-
-                        c2_stob_io_init(stio);
-
-                        stio->si_user = (struct c2_bufvec)C2_BUFVEC_INIT_BUF(&addr,
-                                                                                &count);
-
-                        stio->si_stob.iv_vec.v_nr    = 1;
-                        stio->si_stob.iv_vec.v_count = &count;
-                        stio->si_stob.iv_index       = &offset;
-
-                        stio->si_opcode = SIO_READ;
-                        stio->si_flags  = 0;
-
-                        c2_fom_block_enter(fom);
-                        c2_fom_block_at(fom, &stio->si_wait);
-                        result = c2_stob_io_launch(stio, stobj, &fom->fo_tx, NULL);
-
-                        if (result != 0) {
-                                fom->fo_rc = result;
-                                fom->fo_phase = FOPH_FAILURE;
-                        } else {
-                                fom->fo_phase = FOPH_READ_STOB_IO_WAIT;
-                                result = FSO_WAIT;
-                        }
-                } else if (fom->fo_phase == FOPH_READ_STOB_IO_WAIT) {
-                        fom->fo_rc = stio->si_rc;
-                        stobj = fom_obj->sif_stobj;
-                        if (fom->fo_rc != 0)
-                                fom->fo_phase = FOPH_FAILURE;
-                        else {
-                                bshift = stobj->so_op->sop_block_shift(stobj);
-                                out_fop->firr_count = stio->si_count << bshift;
-                                fom->fo_phase = FOPH_SUCCESS;
-                        }
-
-                }
-
-                if (fom->fo_phase == FOPH_FAILURE || fom->fo_phase == FOPH_SUCCESS) {
-                        c2_fom_block_leave(fom);
-                        out_fop->firr_rc = fom->fo_rc;
-			fop = fom_obj->sif_rep_fop;
-			item = c2_fop_to_rpc_item(fop);
-			item->ri_type = &fop->f_type->ft_rpc_item_type;
-                        item->ri_group = NULL;
-                        fom->fo_rep_fop = fom_obj->sif_rep_fop;
-                        result = c2_fop_fol_rec_add(fom->fo_fop, fom->fo_fol,
-                                                        &fom->fo_tx.tx_dbtx);
-                        C2_ASSERT(result == 0);
-                        result = FSO_AGAIN;
-                }
-
-        }
-
-        if (fom->fo_phase == FOPH_FINISH) {
-                /*
-                   If we fail in any of the generic phase, stob io
-                   is uninitialised, so no need to fini.
-                 */
-                if (stio->si_state != SIS_ZERO) {
-                        c2_stob_io_fini(stio);
-                        c2_stob_put(fom_obj->sif_stobj);
-                }
-        }
-
-        return result;
-}
-
-/**
- * A simple non blocking write fop specific fom
- * state method implemention.
- */
-static int stob_write_fom_state(struct c2_fom *fom)
-{
-        struct c2_stob_io_write     *in_fop;
-        struct c2_stob_io_write_rep *out_fop;
-        struct c2_stob_io_fom           *fom_obj;
-        struct c2_stob_io               *stio;
-        struct c2_stob                  *stobj;
-	struct c2_rpc_item              *item;
-	struct c2_fop                   *fop;
-        void                            *addr;
-        c2_bcount_t                      count;
-        c2_bindex_t                      offset;
-        uint32_t                         bshift;
-        int                              result;
-
-        C2_PRE(fom->fo_fop->f_type->ft_rpc_item_type.rit_opcode ==
-			C2_STOB_IO_WRITE_REQ_OPCODE);
-
-        fom_obj = container_of(fom, struct c2_stob_io_fom, sif_fom);
-        stio = &fom_obj->sif_stio;
-
-        if (fom->fo_phase < FOPH_NR) {
-                result = c2_fom_state_generic(fom);
-        } else {
-                out_fop = c2_fop_data(fom_obj->sif_rep_fop);
-                C2_ASSERT(out_fop != NULL);
-
-                if (fom->fo_phase == FOPH_WRITE_STOB_IO) {
-                        in_fop = c2_fop_data(fom->fo_fop);
-                        C2_ASSERT(in_fop != NULL);
-
-                        fom_obj->sif_stobj = stob_object_find(&in_fop->fiw_object, &fom->fo_tx, fom);
-
-                        stobj = fom_obj->sif_stobj;
-                        bshift = stobj->so_op->sop_block_shift(stobj);
-
-                        addr = c2_stob_addr_pack(&in_fop->fiw_value, bshift);
-                        count = 1 >> bshift;
-                        offset = 0;
-
-                        c2_stob_io_init(stio);
-
-                        stio->si_user = (struct c2_bufvec)C2_BUFVEC_INIT_BUF(&addr, &count);
-
-                        stio->si_stob.iv_vec.v_nr    = 1;
-                        stio->si_stob.iv_vec.v_count = &count;
-                        stio->si_stob.iv_index       = &offset;
-                        stio->si_opcode = SIO_WRITE;
-                        stio->si_flags  = 0;
-
-                        c2_fom_block_enter(fom);
-                        c2_fom_block_at(fom, &stio->si_wait);
-                        result = c2_stob_io_launch(stio, stobj, &fom->fo_tx, NULL);
-
-                        if (result != 0) {
-                                fom->fo_rc = result;
-                                fom->fo_phase = FOPH_FAILURE;
-                        } else {
-                                fom->fo_phase = FOPH_WRITE_STOB_IO_WAIT;
-                                result = FSO_WAIT;
-                        }
-                } else if (fom->fo_phase == FOPH_WRITE_STOB_IO_WAIT) {
-                        c2_fom_block_leave(fom);
-                        fom->fo_rc = stio->si_rc;
-                        stobj = fom_obj->sif_stobj;
-                        if (fom->fo_rc != 0)
-                                fom->fo_phase = FOPH_FAILURE;
-                        else {
-                                bshift = stobj->so_op->sop_block_shift(stobj);
-                                out_fop->fiwr_count = stio->si_count << bshift;
-                                fom->fo_phase = FOPH_SUCCESS;
-                        }
-
-                }
-
-                if (fom->fo_phase == FOPH_FAILURE || fom->fo_phase == FOPH_SUCCESS) {
-                        out_fop->fiwr_rc = fom->fo_rc;
-			fop = fom_obj->sif_rep_fop;
-			item = c2_fop_to_rpc_item(fop);
-			item->ri_type = &fop->f_type->ft_rpc_item_type;
-			item->ri_group = NULL;
-                        fom->fo_rep_fop = fom_obj->sif_rep_fop;
-                        result = c2_fop_fol_rec_add(fom->fo_fop, fom->fo_fol,
-                                                        &fom->fo_tx.tx_dbtx);
-                        C2_ASSERT(result == 0);
-                        result = FSO_AGAIN;
-                }
-        }
-
-        if (fom->fo_phase == FOPH_FINISH) {
-                /*
-                   If we fail in any of the generic phase, stob io
-                   is uninitialised, so no need to fini.
-                 */
-                if (stio->si_state != SIS_ZERO) {
-                        c2_stob_io_fini(stio);
-                        c2_stob_put(fom_obj->sif_stobj);
-                }
-        }
-        return result;
-}
-
-/**
- * Fom specific clean up function, invokes c2_fom_fini()
- */
-static void stob_io_fom_fini(struct c2_fom *fom)
-{
-	struct c2_stob_io_fom *fom_obj;
-
-	fom_obj = container_of(fom, struct c2_stob_io_fom, sif_fom);
-	c2_fom_fini(fom);
-	c2_free(fom_obj);
-}
-
-void c2_stob_io_fop_fini(void);
-
-/**
- * Function to intialise stob io fops.
- */
-int c2_stob_io_fop_init(void)
-{
-	int		    result;
-	int		    i;
-	c2_fop_type_code_t  code;
-	struct c2_fom_type *fom_type;
-	struct c2_fop_type *fop_type;
-
-	result = c2_fop_type_format_parse_nr(stob_fmts, ARRAY_SIZE(stob_fmts));
-	if (result == 0)
-		result = c2_fop_type_build_nr(stob_fops, ARRAY_SIZE(stob_fops));
-	if (result == 0) {
-		c2_fop_object_init(&stob_io_fop_fid_tfmt);
-		for (i = 0; i < ARRAY_SIZE(stob_fops); ++i) {
-			fop_type = stob_fops[i];
-			if ((fop_type->ft_rpc_item_type.rit_flags &
-						C2_RPC_ITEM_TYPE_REQUEST) == 0)
-				continue;
-			code = fop_type->ft_rpc_item_type.rit_opcode;
-			fom_type = stob_fom_type_map(code);
-			C2_ASSERT(fom_type != NULL);
-			fop_type->ft_fom_type = *fom_type;
-		}
-	}
-	if (result != 0)
-		c2_stob_io_fop_fini();
-	return result;
-}
-
-/**
- * Function to clean stob io fops
- */
-void c2_stob_io_fop_fini(void)
-{
-	c2_fop_object_fini();
-	c2_fop_type_fini_nr(stob_fops, ARRAY_SIZE(stob_fops));
-}
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
diff --git a/stob/io_fop.ff b/stob/io_fop.ff
deleted file mode 100644
index f361445..0000000
--- a/stob/io_fop.ff
+++ /dev/null
@@ -1,69 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Mandar Sawant <Mandar_Sawant@xyratex.com>
- * Original creation date: 05/04/2011
- */
-
-/**
-   @addtogroup reqh
-   @{
- */
-
-/** @file fom_io.ff
- *
- * <b>Simplistic IO fop formats</b>
- *
- */
-
-DEF(stob_io_fop_fid, RECORD,
-	_(f_seq, U64),
-	_(f_oid, U64));
-
-DEF(c2_stob_io_write, RECORD,
-	_(fiw_object, stob_io_fop_fid),
-	_(fiw_value, BYTE));
-
-DEF(c2_stob_io_write_rep, RECORD,
-	_(fiwr_rc, U32),
-	_(fiwr_count, U32));
-
-DEF(c2_stob_io_read, RECORD,
-	_(fir_object, stob_io_fop_fid));
-
-DEF(c2_stob_io_read_rep, RECORD,
-	_(firr_rc, U32),
-	_(firr_count, U32),
-	_(firr_value, BYTE));
-
-
-DEF(c2_stob_io_create, RECORD,
-	_(fic_object, stob_io_fop_fid));
-
-DEF(c2_stob_io_create_rep, RECORD,
-	_(ficr_rc, U32));
-
-/** @} end of reqh group */
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
diff --git a/stob/io_fop.h b/stob/io_fop.h
deleted file mode 100644
index 0ef88b5..0000000
--- a/stob/io_fop.h
+++ /dev/null
@@ -1,55 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Dmitriy Chumak <dmitriy_chumak@xyratex.com>
- * Original creation date: 10/29/2011
- */
-
-#ifndef __COLIBRI_STOB_IO_FOP_H__
-#define __COLIBRI_STOB_IO_FOP_H__
-
-#include "fop/fop.h"
-
-extern struct c2_fop_type c2_stob_io_create_fopt;
-extern struct c2_fop_type c2_stob_io_read_fopt;
-extern struct c2_fop_type c2_stob_io_write_fopt;
-
-extern struct c2_fop_type c2_stob_io_create_rep_fopt;
-extern struct c2_fop_type c2_stob_io_read_rep_fopt;
-extern struct c2_fop_type c2_stob_io_write_rep_fopt;
-
-extern struct c2_rpc_item_type c2_stob_create_rpc_item_type;
-extern struct c2_rpc_item_type c2_stob_read_rpc_item_type;
-extern struct c2_rpc_item_type c2_stob_write_rpc_item_type;
-
-extern struct c2_rpc_item_type c2_stob_create_rep_rpc_item_type;
-extern struct c2_rpc_item_type c2_stob_read_rep_rpc_item_type;
-extern struct c2_rpc_item_type c2_stob_write_rep_rpc_item_type;
-
-int c2_stob_io_fop_init(void);
-void c2_stob_io_fop_fini(void);
-
-#endif /* !__COLIBRI_STOB_IO_FOP_H__ */
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
diff --git a/stob/linux.c b/stob/linux.c
index d6d86e6..2702ecf 100644
--- a/stob/linux.c
+++ b/stob/linux.c
@@ -13,7 +13,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Nikita Danilov <Nikita_Danilov@xyratex.com>
+ * Original author: Nikita Danilov
  * Original creation date: 04/28/2010
  */
 
@@ -22,7 +22,6 @@
 #endif
 
 #include <stdio.h>
-#include <unistd.h>                    /* close */
 #include <stdlib.h>
 #include <string.h>
 #include <sys/stat.h>
@@ -63,7 +62,7 @@
    Storage objects are kept on a list linux_domain::sdl_object list that is
    consulted by linux_domain_lookup().
 
-   @todo object caching
+   @todo object caching 
 
    @todo a per-domain limit on number of open file descriptors with LRU based
    cleanup.
@@ -84,13 +83,6 @@ static const struct c2_addb_loc c2_linux_stob_addb_loc = {
 	.al_name = "linux-stob"
 };
 
-C2_TL_DESCR_DEFINE(ls, "linux stobs", static, struct linux_stob,
-		   sl_linkage, sl_magix,
-		   0xb1b11ca15cab105a /* biblical scabiosa */,
-		   0x11fe1e55cab00d1e /* lifeless caboodle */);
-
-C2_TL_DEFINE(ls, static, struct linux_stob);
-
 /**
    Implementation of c2_stob_type_op::sto_init().
  */
@@ -116,16 +108,19 @@ static void linux_stob_type_fini(struct c2_stob_type *stype)
 static void linux_domain_fini(struct c2_stob_domain *self)
 {
 	struct linux_domain *ldom;
-	struct linux_stob   *lstob;
 
 	ldom = domain2linux(self);
 	linux_domain_io_fini(self);
 	c2_rwlock_write_lock(&self->sd_guard);
-	c2_tlist_for(&ls_tl, &ldom->sdl_object, lstob) {
+	while (!c2_list_is_empty(&ldom->sdl_object)) {
+		struct linux_stob *lstob;
+
+		lstob = container_of(ldom->sdl_object.l_head,
+				     struct linux_stob, sl_linkage);
 		linux_stob_fini(&lstob->sl_stob);
-	} c2_tlist_endfor;
+	}
 	c2_rwlock_write_unlock(&self->sd_guard);
-	ls_tlist_fini(&ldom->sdl_object);
+	c2_list_fini(&ldom->sdl_object);
 	c2_stob_domain_fini(self);
 	c2_free(ldom);
 }
@@ -134,12 +129,8 @@ static void linux_domain_fini(struct c2_stob_domain *self)
    Implementation of c2_stob_type_op::sto_domain_locate().
 
    Initialises adieu sub-system for the domain.
-
-   @note the domain returned is ready for use, but c2_linux_stob_setup() can be
-   called against it in order to customize some configuration options (currently
-   there is only one such option: "use_directio" flag).
  */
-static int linux_stob_type_domain_locate(struct c2_stob_type *type,
+static int linux_stob_type_domain_locate(struct c2_stob_type *type, 
 					 const char *domain_name,
 					 struct c2_stob_domain **out)
 {
@@ -147,12 +138,11 @@ static int linux_stob_type_domain_locate(struct c2_stob_type *type,
 	struct c2_stob_domain *dom;
 	int                    result;
 
-	C2_ASSERT(domain_name != NULL);
 	C2_ASSERT(strlen(domain_name) < ARRAY_SIZE(ldom->sdl_path));
 
 	C2_ALLOC_PTR(ldom);
 	if (ldom != NULL) {
-		ls_tlist_init(&ldom->sdl_object);
+		c2_list_init(&ldom->sdl_object);
 		strcpy(ldom->sdl_path, domain_name);
 		dom = &ldom->sdl_base;
 		dom->sd_ops = &linux_stob_domain_op;
@@ -162,28 +152,14 @@ static int linux_stob_type_domain_locate(struct c2_stob_type *type,
 			*out = dom;
 		else
 			linux_domain_fini(dom);
-		ldom->use_directio = false;
-		dom->sd_name = ldom->sdl_path;
 	} else {
-		C2_ADDB_ADD(&type->st_addb,
+		C2_ADDB_ADD(&type->st_addb, 
 			    &c2_linux_stob_addb_loc, c2_addb_oom);
 		result = -ENOMEM;
 	}
 	return result;
 }
 
-int c2_linux_stob_setup(struct c2_stob_domain *dom, bool use_directio)
-{
-	struct linux_domain *ldom;
-
-	ldom = domain2linux(dom);
-
-	ldom->linux_setup = true;
-	ldom->use_directio = use_directio;
-
-	return 0;
-}
-
 static bool linux_stob_invariant(const struct linux_stob *lstob)
 {
 	const struct c2_stob *stob;
@@ -204,15 +180,19 @@ static struct linux_stob *linux_domain_lookup(struct linux_domain *ldom,
 					      const struct c2_stob_id *id)
 {
 	struct linux_stob *obj;
+	bool               found;
 
-	c2_tlist_for(&ls_tl, &ldom->sdl_object, obj) {
+	found = false;
+	c2_list_for_each_entry(&ldom->sdl_object, obj, 
+			       struct linux_stob, sl_linkage) {
 		C2_ASSERT(linux_stob_invariant(obj));
 		if (c2_stob_id_eq(id, &obj->sl_stob.so_id)) {
 			c2_stob_get(&obj->sl_stob);
+			found = true;
 			break;
 		}
-	} c2_tlist_endfor;
-	return obj;
+	}
+	return found ? obj : NULL;
 }
 
 /**
@@ -220,8 +200,8 @@ static struct linux_stob *linux_domain_lookup(struct linux_domain *ldom,
 
    Returns an in-memory representation of the object with a given identifier.
  */
-static int linux_domain_stob_find(struct c2_stob_domain *dom,
-				  const struct c2_stob_id *id,
+static int linux_domain_stob_find(struct c2_stob_domain *dom, 
+				  const struct c2_stob_id *id, 
 				  struct c2_stob **out)
 {
 	struct linux_domain *ldom;
@@ -247,7 +227,8 @@ static int linux_domain_stob_find(struct c2_stob_domain *dom,
 				stob->so_op = &linux_stob_op;
 				lstob->sl_fd = -1;
 				c2_stob_init(stob, id, dom);
-				ls_tlink_init_at(lstob, &ldom->sdl_object);
+				c2_list_add(&ldom->sdl_object, 
+					    &lstob->sl_linkage);
 			} else {
 				c2_free(lstob);
 				lstob = ghost;
@@ -286,8 +267,8 @@ static int linux_stob_path(const struct linux_stob *lstob, int nr, char *path)
 	C2_ASSERT(linux_stob_invariant(lstob));
 
 	ldom  = domain2linux(lstob->sl_stob.so_domain);
-	nob = snprintf(path, nr, "%s/o/%016lx.%016lx", ldom->sdl_path,
-		       lstob->sl_stob.so_id.si_bits.u_hi,
+	nob = snprintf(path, nr, "%s/o/%016lx.%016lx", ldom->sdl_path, 
+		       lstob->sl_stob.so_id.si_bits.u_hi, 
 		       lstob->sl_stob.so_id.si_bits.u_lo);
 	return nob < nr ? 0 : -EOVERFLOW;
 }
@@ -296,8 +277,6 @@ static int linux_stob_path(const struct linux_stob *lstob, int nr, char *path)
    Implementation of c2_stob_op::sop_fini().
 
    Closes the object's file descriptor.
-
-   @see c2_linux_stob_link()
  */
 static void linux_stob_fini(struct c2_stob *stob)
 {
@@ -312,7 +291,7 @@ static void linux_stob_fini(struct c2_stob *stob)
 		close(lstob->sl_fd);
 		lstob->sl_fd = -1;
 	}
-	ls_tlink_del_fini(lstob);
+	c2_list_del(&lstob->sl_linkage);
 	c2_stob_fini(&lstob->sl_stob);
 	c2_free(lstob);
 }
@@ -322,9 +301,11 @@ static void linux_stob_fini(struct c2_stob *stob)
  */
 static int linux_stob_open(struct linux_stob *lstob, int oflag)
 {
+	struct linux_domain *ldom;
 	char                 pathname[64];
 	int                  result;
-	struct stat          statbuf;
+
+	ldom  = domain2linux(lstob->sl_stob.so_domain);
 
 	C2_ASSERT(linux_stob_invariant(lstob));
 	C2_ASSERT(lstob->sl_fd == -1);
@@ -334,13 +315,6 @@ static int linux_stob_open(struct linux_stob *lstob, int oflag)
 		lstob->sl_fd = open(pathname, oflag, 0700);
 		if (lstob->sl_fd == -1)
 			result = -errno;
-		else {
-			result = fstat(lstob->sl_fd, &statbuf);
-			if (result == 0)
-				lstob->sl_mode = statbuf.st_mode;
-			else
-				result = -errno;
-		}
 	}
 	return result;
 }
@@ -350,14 +324,10 @@ static int linux_stob_open(struct linux_stob *lstob, int oflag)
  */
 static int linux_stob_create(struct c2_stob *obj, struct c2_dtx *tx)
 {
-	int oflags = O_RDWR|O_CREAT;
 	struct linux_domain *ldom;
 
 	ldom  = domain2linux(obj->so_domain);
-	if (ldom->use_directio)
-		oflags |= O_DIRECT;
-
-	return linux_stob_open(stob2linux(obj), oflags);
+	return linux_stob_open(stob2linux(obj), O_RDWR|O_CREAT);
 }
 
 /**
@@ -365,14 +335,7 @@ static int linux_stob_create(struct c2_stob *obj, struct c2_dtx *tx)
  */
 static int linux_stob_locate(struct c2_stob *obj, struct c2_dtx *tx)
 {
-	int oflags = O_RDWR;
-	struct linux_domain *ldom;
-
-	ldom  = domain2linux(obj->so_domain);
-	if (ldom->use_directio)
-		oflags |= O_DIRECT;
-
-	return linux_stob_open(stob2linux(obj), oflags);
+	return linux_stob_open(stob2linux(obj), O_RDWR);
 }
 
 static const struct c2_stob_type_op linux_stob_type_op = {
@@ -410,48 +373,14 @@ const struct c2_addb_ctx_type adieu_addb_ctx_type = {
 
 struct c2_addb_ctx adieu_addb_ctx;
 
-/**
-   This function is called to link a path of an existing file to a stob id,
-   for a given Linux stob. This path will be typically a block device path.
-
-   @pre obj != NULL
-   @pre path != NULL
-
-   @param dom -> storage domain
-   @param obj -> stob object embedded inside Linux stob object
-   @param path -> Path to other file (typically block device)
-   @param tx -> transaction context
-
-   @see c2_linux_stob_open()
- */
-int c2_linux_stob_link(struct c2_stob_domain *dom, struct c2_stob *obj,
-		       const char *path, struct c2_dtx *tx)
+int linux_stobs_init(void)
 {
-	int                result;
-	char               symlinkname[64];
-	struct linux_stob *lstob;
-
-	C2_PRE(obj != NULL);
-	C2_PRE(path != NULL);
-
-	lstob = stob2linux(obj);
-
-	result = linux_stob_path(lstob, ARRAY_SIZE(symlinkname), symlinkname);
-	if (result == 0) {
-		result = symlink(path, symlinkname) < 0  ? -errno : 0;
-	}
-
-	return result;
-}
-
-int c2_linux_stobs_init(void)
-{
-	c2_addb_ctx_init(&adieu_addb_ctx, &adieu_addb_ctx_type,
+	c2_addb_ctx_init(&adieu_addb_ctx, &adieu_addb_ctx_type, 
 			 &c2_addb_global_ctx);
 	return linux_stob_type.st_op->sto_init(&linux_stob_type);
 }
 
-void c2_linux_stobs_fini(void)
+void linux_stobs_fini(void)
 {
 	linux_stob_type.st_op->sto_fini(&linux_stob_type);
 	c2_addb_ctx_fini(&adieu_addb_ctx);
@@ -459,7 +388,7 @@ void c2_linux_stobs_fini(void)
 
 /** @} end group stoblinux */
 
-/*
+/* 
  *  Local variables:
  *  c-indentation-style: "K&R"
  *  c-basic-offset: 8
diff --git a/stob/linux.h b/stob/linux.h
index 618e295..b7104d8 100644
--- a/stob/linux.h
+++ b/stob/linux.h
@@ -14,7 +14,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Nikita Danilov <Nikita_Danilov@xyratex.com>
+ * Original author: Nikita Danilov
  * Original creation date: 04/28/2010
  */
 
@@ -23,7 +23,7 @@
 
 /**
    @defgroup stoblinux Storage object based on Linux specific file system
-   and block device interfaces.
+   interfaces.
 
    @see stob
    @{
@@ -31,14 +31,8 @@
 
 extern struct c2_stob_type linux_stob_type;
 
-int  c2_linux_stobs_init(void);
-void c2_linux_stobs_fini(void);
-
-struct c2_stob_domain;
-
-int c2_linux_stob_setup(struct c2_stob_domain *dom, bool use_directio);
-int c2_linux_stob_link(struct c2_stob_domain *dom, struct c2_stob *obj,
-			const char *path, struct c2_dtx *tx);
+int  linux_stobs_init(void);
+void linux_stobs_fini(void);
 
 /** @} end group stoblinux */
 
diff --git a/stob/linux_adieu.c b/stob/linux_adieu.c
index e170d3c..76c7275 100644
--- a/stob/linux_adieu.c
+++ b/stob/linux_adieu.c
@@ -13,7 +13,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Nikita Danilov <Nikita_Danilov@xyratex.com>
+ * Original author: Nikita Danilov
  * Original creation date: 05/21/2010
  */
 
@@ -119,7 +119,7 @@ struct linux_stob_io {
 };
 
 static struct ioq_qev *ioq_queue_get   (struct linux_domain *ldom);
-static void            ioq_queue_put   (struct linux_domain *ldom,
+static void            ioq_queue_put   (struct linux_domain *ldom, 
 					struct ioq_qev *qev);
 static void            ioq_queue_submit(struct linux_domain *ldom);
 static void            ioq_queue_lock  (struct linux_domain *ldom);
@@ -133,35 +133,21 @@ static const struct c2_addb_loc adieu_addb_loc = {
 
 enum {
 	/*
-	 * Alignment for direct-IO.
+	 * Require 4K alignment sufficient for direct-IO.
 	 *
-	 * According to open(2) manpage: "Under Linux 2.6, alignment to
-	 * 512-byte boundaries suffices".
+	 * In fact, 512 is sufficient.
 	 *
-	 * Don't use these constants directly, use LINUX_DOM_XXX macros
-	 * instead (see below), because they take into account
-	 * linux_domain.use_directio flag which is set in runtime.
+	 * @todo Here lies a problem: server uses standard ONC XDR library for
+	 *       message decoding. This library uses standard malloc(3) to
+	 *       allocate all the memory, including buffers. This means that
+	 *       server-side buffers are not aligned. Disable alignment (and
+	 *       direct-IO) until this is fixed.
 	 */
-	LINUX_BSHIFT = 12, /* pow(2, 12) == 4096 */
+	LINUX_BSHIFT = 0, /* 12, */
 	LINUX_BSIZE  = 1 << LINUX_BSHIFT,
 	LINUX_BMASK  = LINUX_BSIZE - 1
 };
 
-#define LINUX_DOM_BSHIFT(ldom) ({				\
-	struct linux_domain *_ldom = (ldom);			\
-	_ldom->use_directio ? LINUX_BSHIFT : 0 ;		\
-})
-
-#define LINUX_DOM_BSIZE(ldom) ({				\
-	struct linux_domain *_ldom = (ldom);			\
-	_ldom->use_directio ? LINUX_BSIZE : 0 ;			\
-})
-
-#define LINUX_DOM_BMASK(ldom) ({				\
-	struct linux_domain *_ldom = (ldom);			\
-	_ldom->use_directio ? LINUX_BMASK : 0 ;		\
-})
-
 #define ADDB_GLOBAL_ADD(name, rc)					\
 C2_ADDB_ADD(&adieu_addb_ctx, &adieu_addb_loc, c2_addb_func_fail, (name), (rc))
 
@@ -233,9 +219,9 @@ static int linux_stob_io_launch(struct c2_stob_io *io)
 
 	/* prefix fragments execution mode is not yet supported */
 	C2_ASSERT((io->si_flags & SIF_PREFIX) == 0);
-	C2_PRE(c2_vec_count(&io->si_user.ov_vec) > 0);
+	C2_PRE(c2_vec_count(&io->si_user.div_vec.ov_vec) > 0);
 
-	c2_vec_cursor_init(&src, &io->si_user.ov_vec);
+	c2_vec_cursor_init(&src, &io->si_user.div_vec.ov_vec);
 	c2_vec_cursor_init(&dst, &io->si_stob.iv_vec);
 
 	frags = 0;
@@ -249,7 +235,7 @@ static int linux_stob_io_launch(struct c2_stob_io *io)
 		C2_ASSERT(eosrc == eodst);
 	} while (!eosrc);
 
-	c2_vec_cursor_init(&src, &io->si_user.ov_vec);
+	c2_vec_cursor_init(&src, &io->si_user.div_vec.ov_vec);
 	c2_vec_cursor_init(&dst, &io->si_stob.iv_vec);
 
 	lio->si_nr   = frags;
@@ -265,13 +251,13 @@ static int linux_stob_io_launch(struct c2_stob_io *io)
 			frag_size = min_check(c2_vec_cursor_step(&src),
 					      c2_vec_cursor_step(&dst));
 			if (frag_size > (size_t)~0ULL) {
-				ADDB_CALL(io->si_obj, "frag_overflow",
+				ADDB_CALL(io->si_obj, "frag_overflow", 
 					  frag_size);
 				result = -EOVERFLOW;
 				break;
 			}
 
-			buf = io->si_user.ov_buf[src.vc_seg] +
+			buf = io->si_user.div_vec.ov_buf[src.vc_seg] + 
 				src.vc_offset;
 			off = io->si_stob.iv_index[dst.vc_seg] + dst.vc_offset;
 
@@ -279,10 +265,9 @@ static int linux_stob_io_launch(struct c2_stob_io *io)
 			C2_SET0(iocb);
 
 			iocb->aio_fildes = lstob->sl_fd;
-			iocb->u.c.buf    = c2_stob_addr_open(buf,
-						LINUX_DOM_BSHIFT(ldom));
-			iocb->u.c.nbytes = frag_size << LINUX_DOM_BSHIFT(ldom);
-			iocb->u.c.offset = off       << LINUX_DOM_BSHIFT(ldom);
+			iocb->u.c.buf    = c2_stob_addr_open(buf, LINUX_BSHIFT);
+			iocb->u.c.nbytes = frag_size << LINUX_BSHIFT;
+			iocb->u.c.offset = off       << LINUX_BSHIFT;
 
 			switch (io->si_opcode) {
 			case SIO_READ:
@@ -349,10 +334,7 @@ bool linux_stob_io_is_locked(const struct c2_stob *stob)
  */
 uint32_t linux_stob_block_shift(const struct c2_stob *stob)
 {
-	struct linux_domain *ldom;
-
-	ldom  = domain2linux(stob->so_domain);
-	return LINUX_DOM_BSHIFT(ldom);
+	return LINUX_BSHIFT;
 }
 
 /**
@@ -372,9 +354,9 @@ static struct ioq_qev *ioq_queue_get(struct linux_domain *ldom)
 }
 
 /**
-   Adds an element to the admission queue.
+   Adds an element to the admission queue. 
  */
-static void ioq_queue_put(struct linux_domain *ldom,
+static void ioq_queue_put(struct linux_domain *ldom, 
 			  struct ioq_qev *qev)
 {
 	C2_ASSERT(!c2_queue_link_is_in(&qev->iq_linkage));
@@ -411,7 +393,7 @@ static void ioq_queue_submit(struct linux_domain *ldom)
 
 	do {
 		ioq_queue_lock(ldom);
-		got = min32(ldom->ioq_queued,
+		got = min32(ldom->ioq_queued, 
 			    min32(ldom->ioq_avail, ARRAY_SIZE(evin)));
 		for (i = 0; i < got; ++i) {
 			qev[i] = ioq_queue_get(ldom);
@@ -448,26 +430,28 @@ static void ioq_complete(struct linux_domain *ldom, struct ioq_qev *qev,
 {
 	struct c2_stob_io    *io;
 	struct linux_stob_io *lio;
+	struct linux_stob    *lstob;
 	bool done;
 	int  i;
 
 	C2_ASSERT(!c2_queue_link_is_in(&qev->iq_linkage));
 	C2_ASSERT(qev->iq_io->si_obj->so_domain == &ldom->sdl_base);
 
-	io  = qev->iq_io;
-	lio = io->si_stob_private;
+	io    = qev->iq_io;
+	lio   = io->si_stob_private;
+	lstob = stob2linux(io->si_obj);
 
 	C2_ASSERT(io->si_state == SIS_BUSY);
 
 	c2_mutex_lock(&lio->si_endlock);
 	C2_ASSERT(lio->si_done < lio->si_nr);
 	if (res > 0) {
-		if ((res & LINUX_DOM_BMASK(ldom)) != 0) {
+		if ((res & LINUX_BMASK) != 0) {
 			ADDB_CALL(io->si_obj, "partial transfer", res);
 			res = -EIO;
 		} else
-			qev->iq_io->si_count += res >> LINUX_DOM_BSHIFT(ldom);
-	}
+			qev->iq_io->si_count += res >> LINUX_BSHIFT;
+	} 
 
 	if (res < 0 && qev->iq_io->si_rc == 0)
 		qev->iq_io->si_rc = res;
diff --git a/stob/linux_getevents.h b/stob/linux_getevents.h
index 09434df..fac9cd4 100644
--- a/stob/linux_getevents.h
+++ b/stob/linux_getevents.h
@@ -14,7 +14,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Nikita Danilov <Nikita_Danilov@xyratex.com>
+ * Original author: Nikita Danilov
  * Original creation date: 06/18/2010
  */
 
diff --git a/stob/linux_internal.h b/stob/linux_internal.h
index d50ae49..6384892 100644
--- a/stob/linux_internal.h
+++ b/stob/linux_internal.h
@@ -14,7 +14,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Nikita Danilov <Nikita_Danilov@xyratex.com>
+ * Original author: Nikita Danilov
  * Original creation date: 05/21/2010
  */
 
@@ -31,11 +31,13 @@
 
 #include <libaio.h>
 
-#include "lib/queue.h"
-#include "lib/tlist.h"
 #include "lib/thread.h"
 #include "stob/stob.h"
 
+#ifndef MAXPATHLEN
+#define MAXPATHLEN 1024
+#endif
+
 enum {
 	/** Default number of threads to create in a storage object domain. */
 	IOQ_NR_THREADS     = 8,
@@ -53,19 +55,6 @@ enum {
    Stob domain for Linux type.
  */
 struct linux_domain {
-	/**
-	   Set to true in linux_setup(). May be used in pre-conditions to
-	   guarantee that the domain is fully initialized.
-	 */
-	bool linux_setup;
-
-	/**
-	 *  Controls whether to use O_DIRECT flag for open(2).
-	 *  Can be set with c2_linux_stob_setup().
-	 *  Initial value is set to 'false' in linux_stob_type_domain_locate().
-	 */
-	bool use_directio;
-
 	struct c2_stob_domain sdl_base;
 	/**
 	   parent directory to hold the objects.
@@ -73,16 +62,16 @@ struct linux_domain {
 	char             sdl_path[MAXPATHLEN];
 
 	/** List of all existing c2_stob's. */
-	struct c2_tl     sdl_object;
+	struct c2_list   sdl_object;
 
 	/** @name ioq Linux adieu fields. @{ */
 
 	/** Set up when domain is being shut down. adieu worker threads
 	    (ioq_thread()) check this field on each iteration. */
 	bool             ioq_shutdown;
-	/**
+	/** 
 	    Ring buffer shared between adieu and the kernel.
-
+	    
 	    It contains adieu request fragments currently being executed by the
 	    kernel. The kernel delivers AIO completion events through this
 	    buffer. */
@@ -105,18 +94,14 @@ struct linux_domain {
 };
 
 /**
-   stob based on Linux file system and block devices
+   stob based on Linux file system
  */
 struct linux_stob {
-	struct c2_stob		sl_stob;
+	struct c2_stob      sl_stob;
 
 	/** fd from returned open(2) */
-	int			sl_fd;
-	/** File mode as returned by stat(2) */
-	mode_t			sl_mode;
-
-	struct c2_tlink		sl_linkage;
-	uint64_t		sl_magix;
+	int                 sl_fd;
+	struct c2_list_link sl_linkage;
 };
 
 static inline struct linux_stob *stob2linux(struct c2_stob *stob)
@@ -144,7 +129,7 @@ extern struct c2_addb_ctx adieu_addb_ctx;
 /* __COLIBRI_STOB_LINUX_INTERNAL_H__ */
 #endif
 
-/*
+/* 
  *  Local variables:
  *  c-indentation-style: "K&R"
  *  c-basic-offset: 8
diff --git a/stob/stob.c b/stob/stob.c
index 021db56..925d042 100644
--- a/stob/stob.c
+++ b/stob/stob.c
@@ -13,7 +13,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Nikita Danilov <Nikita_Danilov@xyratex.com>
+ * Original author: Nikita Danilov
  * Original creation date: 04/28/2010
  */
 
@@ -28,7 +28,7 @@
 #include "lib/assert.h"
 #include "lib/memory.h"
 
-#include "stob/stob.h"
+#include "stob.h"
 
 /**
    @addtogroup stob
@@ -47,15 +47,10 @@ static const struct c2_addb_ctx_type c2_stob_addb = {
 	.act_name = "stob-domain"
 };
 
-C2_TL_DESCR_DEFINE(dom, "stob domains", static, struct c2_stob_domain,
-		   sd_domain_linkage, sd_magic, 0xABD1CAB1EAB5CE55,
-		   0xACCE551B1EEFFACE);
-C2_TL_DEFINE(dom, static, struct c2_stob_domain);
-
 int c2_stob_type_init(struct c2_stob_type *kind)
 {
-	dom_tlist_init(&kind->st_domains);
-	c2_addb_ctx_init(&kind->st_addb, &c2_stob_type_addb,
+	c2_list_init(&kind->st_domains);
+	c2_addb_ctx_init(&kind->st_addb, &c2_stob_type_addb, 
 			 &c2_addb_global_ctx);
 	return 0;
 }
@@ -63,14 +58,14 @@ int c2_stob_type_init(struct c2_stob_type *kind)
 void c2_stob_type_fini(struct c2_stob_type *kind)
 {
 	c2_addb_ctx_fini(&kind->st_addb);
-	dom_tlist_fini(&kind->st_domains);
+	c2_list_fini(&kind->st_domains);
 }
 
 void c2_stob_domain_init(struct c2_stob_domain *dom, struct c2_stob_type *t)
 {
 	c2_rwlock_init(&dom->sd_guard);
 	dom->sd_type = t;
-	dom_tlink_init_at_tail(dom, &t->st_domains);
+	c2_list_add_tail(&t->st_domains, &dom->sd_domain_linkage);
 	c2_addb_ctx_init(&dom->sd_addb, &c2_stob_domain_addb, &t->st_addb);
 }
 
@@ -78,8 +73,7 @@ void c2_stob_domain_fini(struct c2_stob_domain *dom)
 {
 	c2_addb_ctx_fini(&dom->sd_addb);
 	c2_rwlock_fini(&dom->sd_guard);
-	dom_tlink_del_fini(dom);
-	dom->sd_magic = 0;
+	c2_list_del(&dom->sd_domain_linkage);
 }
 
 int c2_stob_find(struct c2_stob_domain *dom, const struct c2_stob_id *id,
@@ -218,6 +212,7 @@ void c2_stob_io_init(struct c2_stob_io *io)
 	io->si_opcode = SIO_INVALID;
 	io->si_state  = SIS_IDLE;
 	c2_chan_init(&io->si_wait);
+	c2_sm_init(&io->si_mach);
 
 	C2_POST(io->si_state == SIS_IDLE);
 }
@@ -226,11 +221,12 @@ void c2_stob_io_fini(struct c2_stob_io *io)
 {
 	C2_PRE(io->si_state == SIS_IDLE);
 
+	c2_sm_fini(&io->si_mach);
 	c2_chan_fini(&io->si_wait);
 	c2_stob_io_private_fini(io);
 }
 
-int c2_stob_io_launch(struct c2_stob_io *io, struct c2_stob *obj,
+int c2_stob_io_launch(struct c2_stob_io *io, struct c2_stob *obj, 
 		      struct c2_dtx *tx, struct c2_io_scope *scope)
 {
 	int result;
@@ -240,7 +236,7 @@ int c2_stob_io_launch(struct c2_stob_io *io, struct c2_stob *obj,
 	C2_PRE(io->si_obj == NULL);
 	C2_PRE(io->si_state == SIS_IDLE);
 	C2_PRE(io->si_opcode != SIO_INVALID);
-	C2_PRE(c2_vec_count(&io->si_user.ov_vec) == 
+	C2_PRE(c2_vec_count(&io->si_user.div_vec.ov_vec) == 
 	       c2_vec_count(&io->si_stob.iv_vec));
 	C2_PRE(c2_stob_io_user_is_valid(&io->si_user));
 	C2_PRE(c2_stob_io_stob_is_valid(&io->si_stob));
@@ -269,7 +265,7 @@ int c2_stob_io_launch(struct c2_stob_io *io, struct c2_stob *obj,
 	return result;
 }
 
-bool c2_stob_io_user_is_valid(const struct c2_bufvec *user)
+bool c2_stob_io_user_is_valid(const struct c2_diovec *user)
 {
 	return true;
 }
@@ -305,7 +301,7 @@ void *c2_stob_addr_open(const void *buf, uint32_t shift)
 
 /** @} end group stob */
 
-/*
+/* 
  *  Local variables:
  *  c-indentation-style: "K&R"
  *  c-basic-offset: 8
diff --git a/stob/stob.h b/stob/stob.h
index 2618c60..0984a34 100644
--- a/stob/stob.h
+++ b/stob/stob.h
@@ -14,7 +14,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Nikita Danilov <Nikita_Danilov@xyratex.com>
+ * Original author: Nikita Danilov
  * Original creation date: 04/28/2010
  */
 
@@ -27,21 +27,20 @@
 #include "lib/vec.h"
 #include "lib/chan.h"
 #include "lib/rwlock.h"
-#include "lib/tlist.h"
 #include "addb/addb.h"
 #include "sm/sm.h"
-#include "stob/stob_id.h"
-
-#ifndef MAXPATHLEN
-#define MAXPATHLEN 1024
-#endif
 
 /* import */
+struct c2_sm;
 struct c2_dtx;
 struct c2_chan;
+struct c2_diovec;
 struct c2_indexvec;
 struct c2_io_scope;
 
+struct c2_list;
+struct c2_list_link;
+
 struct c2_db_tx;
 
 /**
@@ -61,6 +60,7 @@ struct c2_db_tx;
  */
 
 struct c2_stob;
+struct c2_stob_id;
 struct c2_stob_op;
 struct c2_stob_io;
 struct c2_stob_type;
@@ -72,7 +72,7 @@ struct c2_stob_type {
 	const struct c2_stob_type_op *st_op;
 	const char                   *st_name;
 	const uint32_t                st_magic;
-	struct c2_tl		      st_domains; /**< list of domains */
+	struct c2_list		      st_domains; /**< list of domains */
 	struct c2_addb_ctx            st_addb;
 };
 
@@ -85,7 +85,7 @@ struct c2_stob_type_op {
 
 	   @return 0 success, any other value means error.
 	*/
-	int (*sto_domain_locate)(struct c2_stob_type *type,
+	int (*sto_domain_locate)(struct c2_stob_type *type, 
 				 const char *domain_name,
 				 struct c2_stob_domain **dom);
 };
@@ -108,11 +108,10 @@ void c2_stob_type_fini(struct c2_stob_type *kind);
 struct c2_stob_domain {
 	const char 		       *sd_name;
 	const struct c2_stob_domain_op *sd_ops;
-	struct c2_stob_type            *sd_type;
-	struct c2_tlink                 sd_domain_linkage;
+	struct c2_stob_type 	       *sd_type;
+	struct c2_list_link	        sd_domain_linkage;
 	struct c2_rwlock                sd_guard;
 	struct c2_addb_ctx              sd_addb;
-	uint64_t                        sd_magic;
 };
 
 /**
@@ -167,6 +166,19 @@ enum c2_stob_state {
 };
 
 /**
+   Unique storage object identifier.
+
+   A storage object in a cluster is identified by identifier of this type.
+ */
+struct c2_stob_id {
+	struct c2_uint128 si_bits;
+};
+
+bool c2_stob_id_eq (const struct c2_stob_id *id0, const struct c2_stob_id *id1);
+int  c2_stob_id_cmp(const struct c2_stob_id *id0, const struct c2_stob_id *id1);
+bool c2_stob_id_is_set(const struct c2_stob_id *id);
+
+/**
    In-memory representation of a storage object.
 
    c2_stob is created by a call to one of the c2_stob_create(), c2_stob_locate()
@@ -342,7 +354,7 @@ int  c2_stob_create(struct c2_stob *obj, struct c2_dtx *tx);
 void c2_stob_get(struct c2_stob *obj);
 
 /**
-   Releases a reference on the object.
+   Releases a reference on the object. 
 
    When the last reference is released, the object can either return to the
    cache or can be immediately destroyed at the storage object type
@@ -491,7 +503,7 @@ void c2_stob_put(struct c2_stob *obj);
                        |  |
      c2_stob_io_init() |  | c2_stob_io_fini()
                        |  |
-                       V  |
+                       V  |    
                      SIS_IDLE
                        |  ^
                        |  |
@@ -537,7 +549,7 @@ enum c2_stob_io_opcode {
 enum c2_stob_io_state {
 	/** State used to detect un-initialised c2_stob_io. */
 	SIS_ZERO = 0,
-	/**
+	/** 
 	    User owns c2_stob_io and data pages. No IO is ongoing.
 	 */
 	SIS_IDLE,
@@ -580,13 +592,13 @@ struct c2_stob_io {
 	/**
 	   Where data are located in the user address space.
 
-	   @note buffer sizes in c2_stob_io::si_user.ov_vec.v_count[]
+	   @note buffer sizes in c2_stob_io::si_user.div_vec.ov_vec.v_count[]
 	   are in block size units (as determined by
 	   c2_stob_op::sop_block_shift). Buffer addresses in
-	   c2_stob_io::si_user.ov_buf[] must be shifted block-shift bits
+	   c2_stob_io::si_user.div_vec.ov_buf[] must be shifted block-shift bits
 	   to the left.
 	 */
-	struct c2_bufvec	    si_user;
+	struct c2_diovec            si_user;
 	/**
 	   Where data are located in the storage object name-space.
 
@@ -643,7 +655,7 @@ struct c2_stob_io {
 	struct c2_io_scope         *si_scope;
 	/**
 	   Pointer to implementation private data associated with the IO
-	   operation.
+	   operation. 
 
 	   This pointer is initialized when c2_stob_io is queued for the first
 	   time. When IO completes, the memory allocated by implementation is
@@ -672,6 +684,10 @@ struct c2_stob_io {
 	   of time.
 	 */
 	uint32_t                    si_stob_magic;
+	/**
+	   IO operation is a state machine, see State diagram for adieu.
+	 */
+	struct c2_sm                si_mach;
 };
 
 struct c2_stob_io_op {
@@ -712,7 +728,7 @@ void c2_stob_io_fini  (struct c2_stob_io *io);
    @pre c2_chan_has_waiters(&io->si_wait)
    @pre io->si_state == SIS_IDLE
    @pre io->si_opcode != SIO_INVALID
-   @pre c2_vec_count(&io->si_user.ov_vec) == c2_vec_count(&io->si_stob.ov_vec)
+   @pre c2_vec_count(&io->si_user.div_vec.ov_vec) == c2_vec_count(&io->si_stob.ov_vec)
    @pre c2_stob_io_user_is_valid(&io->si_user)
    @pre c2_stob_io_stob_is_valid(&io->si_stob)
 
@@ -722,13 +738,13 @@ void c2_stob_io_fini  (struct c2_stob_io *io);
    finishes. Because of this no post-conditions for io->si_state are imposed in
    the successful return case.
  */
-int  c2_stob_io_launch (struct c2_stob_io *io, struct c2_stob *obj,
+int  c2_stob_io_launch (struct c2_stob_io *io, struct c2_stob *obj, 
 			struct c2_dtx *tx, struct c2_io_scope *scope);
 
 /**
    Returns true if user is a valid vector of user IO buffers.
  */
-bool c2_stob_io_user_is_valid(const struct c2_bufvec *user);
+bool c2_stob_io_user_is_valid(const struct c2_diovec *user);
 /**
    Returns true if stob is a valid vector of target IO extents.
  */
diff --git a/stob/stob_id.c b/stob/stob_id.c
index 26349f8..7d6051e 100644
--- a/stob/stob_id.c
+++ b/stob/stob_id.c
@@ -13,7 +13,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Nikita Danilov <Nikita_Danilov@xyratex.com>
+ * Original author: Nikita Danilov
  * Original creation date: 04/28/2010
  */
 
@@ -22,11 +22,13 @@ bool c2_stob_id_eq(const struct c2_stob_id *id0, const struct c2_stob_id *id1)
 {
 	return c2_uint128_eq(&id0->si_bits, &id1->si_bits);
 }
+C2_EXPORTED(c2_stob_id_eq);
 
 int c2_stob_id_cmp(const struct c2_stob_id *id0, const struct c2_stob_id *id1)
 {
 	return c2_uint128_cmp(&id0->si_bits, &id1->si_bits);
 }
+C2_EXPORTED(c2_stob_id_cmp);
 
 bool c2_stob_id_is_set(const struct c2_stob_id *id)
 {
@@ -38,3 +40,4 @@ bool c2_stob_id_is_set(const struct c2_stob_id *id)
 	};
 	return !c2_stob_id_eq(id, &zero);
 }
+C2_EXPORTED(c2_stob_id_is_set);
diff --git a/stob/stob_id.h b/stob/stob_id.h
index a6408af..fee4918 100644
--- a/stob/stob_id.h
+++ b/stob/stob_id.h
@@ -13,7 +13,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Nikita Danilov <Nikita_Danilov@xyratex.com>
+ * Original author: Nikita Danilov
  * Original creation date: 04/28/2010
  */
 
diff --git a/stob/ut/Makefile.am b/stob/ut/Makefile.am
index 25ddac3..480ac93 100644
--- a/stob/ut/Makefile.am
+++ b/stob/ut/Makefile.am
@@ -1,22 +1,25 @@
-io_u.h io_u.c: io.ff \
-                  $(top_builddir)/fop/fop2c
-	$(top_builddir)/fop/fop2c -uk $<
+UT_SRCDIR=@SRCDIR@/stob/ut
 
 noinst_LTLIBRARIES    = libstob-ut.la
-libstob_ut_la_SOURCES = io_u.h io_u.c adieu.c ad.c stobio.c
+libstob_ut_la_SOURCES = adieu.c ad.c stobio.c
 
 noinst_PROGRAMS       = server client
 
-server_SOURCES   = server.c io_fop.h
+io_u.h io_u.c: io.ff \
+                  $(top_builddir)/fop/libc2rt.la \
+                  $(top_builddir)/fop/fop2c 
+	$(top_builddir)/fop/fop2c -uk $<
+
+server_SOURCES   = io_u.h io_u.c server.c io_fop_init.c io_fop.h
 server_LDFLAGS   = -pthread
 server_LDADD     = $(top_builddir)/colibri/libcolibri.la
 
-client_SOURCES   = client.c io_fop.h
+client_SOURCES   = client.c io_fop_init.c io_fop.h io_u.h io_u.c
 client_LDFLAGS   = -pthread
 client_LDADD     = $(top_builddir)/colibri/libcolibri.la
 
-EXTRA_DIST	 = io.ff io_fop_init.c
+EXTRA_DIST       = io.ff
 
 clean-local:
-	cd @SRCDIR@/stob/ut ; \
+	cd $(UT_SRCDIR) ; \
 	rm -fr io_[uk].[hc]
diff --git a/stob/ut/ad.c b/stob/ut/ad.c
index 4662db7..c442d96 100644
--- a/stob/ut/ad.c
+++ b/stob/ut/ad.c
@@ -13,7 +13,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Nikita Danilov <Nikita_Danilov@xyratex.com>
+ * Original author: Nikita Danilov
  * Original creation date: 08/24/2010
  */
 
@@ -27,7 +27,6 @@
 #include <sys/stat.h>  /* mkdir */
 #include <sys/types.h> /* mkdir */
 
-#include "dtm/dtm.h"     /* c2_dtx */
 #include "lib/arith.h"   /* min64u */
 #include "lib/misc.h"    /* C2_SET0 */
 #include "lib/memory.h"
@@ -48,8 +47,8 @@
 
 enum {
 	NR    = 3,
-	MIN_BUF_SIZE = 4096,
-	MIN_BUF_SIZE_IN_BLOCKS = 4,
+	SHIFT = 0, /* 12, */
+	COUNT = (1 << SHIFT)*1024
 };
 
 static struct c2_stob_domain *dom_back;
@@ -84,8 +83,6 @@ static c2_bindex_t stob_vec[NR];
 static struct c2_clink clink;
 static struct c2_dtx tx;
 static struct c2_dbenv db;
-static uint32_t block_shift;
-static uint32_t buf_size;
 
 struct mock_balloc {
 	c2_bindex_t      mb_next;
@@ -98,8 +95,7 @@ static struct mock_balloc *b2mock(struct ad_balloc *ballroom)
 }
 
 static int mock_balloc_init(struct ad_balloc *ballroom, struct c2_dbenv *db,
-			    uint32_t bshift, c2_bindex_t container_size,
-			    c2_bcount_t groupsize, c2_bcount_t res_groups)
+			    uint32_t bshift)
 {
 	return 0;
 }
@@ -151,6 +147,16 @@ static int test_ad_init(void)
 	int i;
 	int result;
 
+	for (i = 0; i < ARRAY_SIZE(user_buf); ++i) {
+		user_buf[i] = c2_alloc_aligned(COUNT, SHIFT);
+		C2_ASSERT(user_buf[i] != NULL);
+	}
+
+	for (i = 0; i < ARRAY_SIZE(read_buf); ++i) {
+		read_buf[i] = c2_alloc_aligned(COUNT, SHIFT);
+		C2_ASSERT(read_buf[i] != NULL);
+	}
+
 	result = system("rm -fr ./__s");
 	C2_ASSERT(result == 0);
 
@@ -179,11 +185,8 @@ static int test_ad_init(void)
 						       &dom_fore);
 	C2_ASSERT(result == 0);
 
-	result = c2_ad_stob_setup(dom_fore, &db, obj_back, &mb.mb_ballroom,
-				  BALLOC_DEF_CONTAINER_SIZE,
-				  BALLOC_DEF_BLOCK_SHIFT,
-				  BALLOC_DEF_BLOCKS_PER_GROUP,
-				  BALLOC_DEF_RESERVED_GROUPS);
+	result = ad_setup(dom_fore, &db, obj_back, &mb.mb_ballroom);
+	//result = ad_setup(dom_fore, &db, obj_back, &colibri_balloc.cb_ballroom);
 	C2_ASSERT(result == 0);
 
 	c2_stob_put(obj_back);
@@ -202,29 +205,14 @@ static int test_ad_init(void)
 		C2_ASSERT(result == 0);
 	}
 	C2_ASSERT(obj_fore->so_state == CSS_EXISTS);
-
-	block_shift = obj_fore->so_op->sop_block_shift(obj_fore);
-	/* buf_size is chosen so it would be at least MIN_BUF_SIZE in bytes
-	 * or it would consist of at least MIN_BUF_SIZE_IN_BLOCKS blocks */
-	buf_size = max_check(MIN_BUF_SIZE
-			, (1 << block_shift) * MIN_BUF_SIZE_IN_BLOCKS);
-
-	for (i = 0; i < ARRAY_SIZE(user_buf); ++i) {
-		user_buf[i] = c2_alloc_aligned(buf_size, block_shift);
-		C2_ASSERT(user_buf[i] != NULL);
-	}
-
-	for (i = 0; i < ARRAY_SIZE(read_buf); ++i) {
-		read_buf[i] = c2_alloc_aligned(buf_size, block_shift);
-		C2_ASSERT(read_buf[i] != NULL);
-	}
+	C2_ASSERT(obj_fore->so_op->sop_block_shift(obj_fore) == SHIFT);
 
 	for (i = 0; i < NR; ++i) {
-		user_bufs[i] = c2_stob_addr_pack(user_buf[i], block_shift);
-		read_bufs[i] = c2_stob_addr_pack(read_buf[i], block_shift);
-		user_vec[i] = buf_size >> block_shift;
-		stob_vec[i] = (buf_size * (2 * i + 1)) >> block_shift;
-		memset(user_buf[i], ('a' + i)|1, buf_size);
+		user_bufs[i] = c2_stob_addr_pack(user_buf[i], SHIFT);
+		read_bufs[i] = c2_stob_addr_pack(read_buf[i], SHIFT);
+		user_vec[i] = COUNT >> SHIFT;
+		stob_vec[i] = (COUNT * (2 * i + 1)) >> SHIFT;
+		memset(user_buf[i], ('a' + i)|1, COUNT);
 	}
 	return result;
 }
@@ -257,9 +245,9 @@ static void test_write(int i)
 
 	io.si_opcode = SIO_WRITE;
 	io.si_flags  = 0;
-	io.si_user.ov_vec.v_nr = i;
-	io.si_user.ov_vec.v_count = user_vec;
-	io.si_user.ov_buf = (void **)user_bufs;
+	io.si_user.div_vec.ov_vec.v_nr = i;
+	io.si_user.div_vec.ov_vec.v_count = user_vec;
+	io.si_user.div_vec.ov_buf = (void **)user_bufs;
 
 	io.si_stob.iv_vec.v_nr = i;
 	io.si_stob.iv_vec.v_count = user_vec;
@@ -274,7 +262,7 @@ static void test_write(int i)
 	c2_chan_wait(&clink);
 
 	C2_ASSERT(io.si_rc == 0);
-	C2_ASSERT(io.si_count == (buf_size * i) >> block_shift);
+	C2_ASSERT(io.si_count == (COUNT * i) >> SHIFT);
 
 	c2_clink_del(&clink);
 	c2_clink_fini(&clink);
@@ -289,9 +277,9 @@ static void test_read(int i)
 
 	io.si_opcode = SIO_READ;
 	io.si_flags  = 0;
-	io.si_user.ov_vec.v_nr = i;
-	io.si_user.ov_vec.v_count = user_vec;
-	io.si_user.ov_buf = (void **)read_bufs;
+	io.si_user.div_vec.ov_vec.v_nr = i;
+	io.si_user.div_vec.ov_vec.v_count = user_vec;
+	io.si_user.div_vec.ov_buf = (void **)read_bufs;
 
 	io.si_stob.iv_vec.v_nr = i;
 	io.si_stob.iv_vec.v_count = user_vec;
@@ -306,7 +294,7 @@ static void test_read(int i)
 	c2_chan_wait(&clink);
 
 	C2_ASSERT(io.si_rc == 0);
-	C2_ASSERT(io.si_count == (buf_size * i) >> block_shift);
+	C2_ASSERT(io.si_count == (COUNT * i) >> SHIFT);
 
 	c2_clink_del(&clink);
 	c2_clink_fini(&clink);
@@ -328,7 +316,7 @@ static void test_ad(void)
 		int j;
 		test_read(i);
 		for (j = 0; j < i; ++j)
-			C2_ASSERT(memcmp(user_buf[j], read_buf[j], buf_size) == 0);
+			C2_ASSERT(memcmp(user_buf[j], read_buf[j], COUNT) == 0);
 	}
 }
 
diff --git a/stob/ut/adieu.c b/stob/ut/adieu.c
index 736ba39..8b55f8f 100644
--- a/stob/ut/adieu.c
+++ b/stob/ut/adieu.c
@@ -13,7 +13,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Nikita Danilov <Nikita_Danilov@xyratex.com>
+ * Original author: Nikita Danilov
  * Original creation date: 08/24/2010
  */
 
@@ -33,7 +33,6 @@
 #include "lib/ub.h"
 #include "lib/ut.h"
 #include "lib/assert.h"
-#include "lib/arith.h"
 
 #include "stob/stob.h"
 #include "stob/linux.h"
@@ -45,8 +44,8 @@
 
 enum {
 	NR    = 3,
-	MIN_BUF_SIZE = 4096,
-	MIN_BUF_SIZE_IN_BLOCKS = 4,
+	SHIFT = 0, /* 12, */
+	COUNT = (1 << SHIFT)*1024
 };
 
 static struct c2_stob_domain *dom;
@@ -68,14 +67,22 @@ static char *read_bufs[NR];
 static c2_bindex_t stob_vec[NR];
 static struct c2_clink clink;
 static FILE *f;
-static uint32_t block_shift;
-static uint32_t buf_size;
 
 static int test_adieu_init(void)
 {
 	int i;
 	int result;
 
+	for (i = 0; i < ARRAY_SIZE(user_buf); ++i) {
+		user_buf[i] = c2_alloc_aligned(COUNT, SHIFT);
+		C2_ASSERT(user_buf[i] != NULL);
+	}
+
+	for (i = 0; i < ARRAY_SIZE(read_buf); ++i) {
+		read_buf[i] = c2_alloc_aligned(COUNT, SHIFT);
+		C2_ASSERT(read_buf[i] != NULL);
+	}
+
 	result = system("rm -fr ./__s");
 	C2_ASSERT(result == 0);
 
@@ -85,7 +92,7 @@ static int test_adieu_init(void)
 	result = mkdir("./__s/o", 0700);
 	C2_ASSERT(result == 0 || (result == -1 && errno == EEXIST));
 
-	result = linux_stob_type.st_op->sto_domain_locate(&linux_stob_type,
+	result = linux_stob_type.st_op->sto_domain_locate(&linux_stob_type, 
 							  "./__s", &dom);
 	C2_ASSERT(result == 0);
 
@@ -120,29 +127,14 @@ static int test_adieu_init(void)
 	result = c2_stob_locate(obj, NULL);
 	C2_ASSERT(result == 0);
 	C2_ASSERT(obj->so_state == CSS_EXISTS);
-
-	block_shift = obj->so_op->sop_block_shift(obj);
-	/* buf_size is chosen so it would be at least MIN_BUF_SIZE in bytes
-	 * or it would consist of at least MIN_BUF_SIZE_IN_BLOCKS blocks */
-	buf_size = max_check(MIN_BUF_SIZE
-			, (1 << block_shift) * MIN_BUF_SIZE_IN_BLOCKS);
-
-	for (i = 0; i < ARRAY_SIZE(user_buf); ++i) {
-		user_buf[i] = c2_alloc_aligned(buf_size, block_shift);
-		C2_ASSERT(user_buf[i] != NULL);
-	}
-
-	for (i = 0; i < ARRAY_SIZE(read_buf); ++i) {
-		read_buf[i] = c2_alloc_aligned(buf_size, block_shift);
-		C2_ASSERT(read_buf[i] != NULL);
-	}
+	C2_ASSERT(obj->so_op->sop_block_shift(obj) == SHIFT);
 
 	for (i = 0; i < NR; ++i) {
-		user_bufs[i] = c2_stob_addr_pack(user_buf[i], block_shift);
-		read_bufs[i] = c2_stob_addr_pack(read_buf[i], block_shift);
-		user_vec[i] = buf_size >> block_shift;
-		stob_vec[i] = (buf_size * (2 * i + 1)) >> block_shift;
-		memset(user_buf[i], ('a' + i)|1, buf_size);
+		user_bufs[i] = c2_stob_addr_pack(user_buf[i], SHIFT);
+		read_bufs[i] = c2_stob_addr_pack(read_buf[i], SHIFT);
+		user_vec[i] = COUNT >> SHIFT;
+		stob_vec[i] = (COUNT * (2 * i + 1)) >> SHIFT;
+		memset(user_buf[i], ('a' + i)|1, COUNT);
 	}
 	return result;
 }
@@ -169,9 +161,9 @@ static void test_write(int i)
 
 	io.si_opcode = SIO_WRITE;
 	io.si_flags  = 0;
-	io.si_user.ov_vec.v_nr = i;
-	io.si_user.ov_vec.v_count = user_vec;
-	io.si_user.ov_buf = (void **)user_bufs;
+	io.si_user.div_vec.ov_vec.v_nr = i;
+	io.si_user.div_vec.ov_vec.v_count = user_vec;
+	io.si_user.div_vec.ov_buf = (void **)user_bufs;
 
 	io.si_stob.iv_vec.v_nr = i;
 	io.si_stob.iv_vec.v_count = user_vec;
@@ -186,7 +178,7 @@ static void test_write(int i)
 	c2_chan_wait(&clink);
 
 	C2_ASSERT(io.si_rc == 0);
-	C2_ASSERT(io.si_count == (buf_size * i) >> block_shift);
+	C2_ASSERT(io.si_count == (COUNT * i) >> SHIFT);
 
 	c2_clink_del(&clink);
 	c2_clink_fini(&clink);
@@ -201,9 +193,9 @@ static void test_read(int i)
 
 	io.si_opcode = SIO_READ;
 	io.si_flags  = 0;
-	io.si_user.ov_vec.v_nr = i;
-	io.si_user.ov_vec.v_count = user_vec;
-	io.si_user.ov_buf = (void **)read_bufs;
+	io.si_user.div_vec.ov_vec.v_nr = i;
+	io.si_user.div_vec.ov_vec.v_count = user_vec;
+	io.si_user.div_vec.ov_buf = (void **)read_bufs;
 
 	io.si_stob.iv_vec.v_nr = i;
 	io.si_stob.iv_vec.v_count = user_vec;
@@ -218,7 +210,7 @@ static void test_read(int i)
 	c2_chan_wait(&clink);
 
 	C2_ASSERT(io.si_rc == 0);
-	C2_ASSERT(io.si_count == (buf_size * i) >> block_shift);
+	C2_ASSERT(io.si_count == (COUNT * i) >> SHIFT);
 
 	c2_clink_del(&clink);
 	c2_clink_fini(&clink);
@@ -242,12 +234,12 @@ static void test_adieu(void)
 		for (j = 0; j < i; ++j) {
 			int k;
 
-			for (k = 0; k < buf_size; ++k) {
+			for (k = 0; k < COUNT; ++k) {
 				ch = fgetc(f);
 				C2_ASSERT(ch == '\0');
 				C2_ASSERT(!feof(f));
 			}
-			for (k = 0; k < buf_size; ++k) {
+			for (k = 0; k < COUNT; ++k) {
 				ch = fgetc(f);
 				C2_ASSERT(ch != '\0');
 				C2_ASSERT(!feof(f));
@@ -260,7 +252,7 @@ static void test_adieu(void)
 
 	for (i = 1; i < NR; ++i) {
 		test_read(i);
-		C2_ASSERT(memcmp(user_buf[i - 1], read_buf[i - 1], buf_size) == 0);
+		C2_ASSERT(memcmp(user_buf[i - 1], read_buf[i - 1], COUNT) == 0);
 	}
 }
 
diff --git a/stob/ut/client.c b/stob/ut/client.c
index 614d591..ab63b53 100644
--- a/stob/ut/client.c
+++ b/stob/ut/client.c
@@ -13,7 +13,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Nikita Danilov <Nikita_Danilov@xyratex.com>
+ * Original author: Nikita Danilov
  * Original creation date: 08/24/2010
  */
 
@@ -33,106 +33,133 @@
 #include "addb/addb.h"
 #include "net/net.h"
 #include "net/usunrpc/usunrpc.h"
-#include "rpc/rpclib.h"
-#include "lib/processor.h"
 
 #include "stob/stob.h"
 #include "stob/linux.h"
-#include "stob/io_fop.h"
 #include "colibri/init.h"
-#include "ut/rpc.h"
 
-#include "stob/io_fop_u.h"
+#include "io_u.h"
+#include "io_fop.h"
 
 /**
    @addtogroup stob
    @{
  */
 
-#define SERVER_ENDPOINT_ADDR	"127.0.0.1:12346:1"
-#define CLIENT_ENDPOINT_ADDR	"127.0.0.1:12347:1"
-#define CLIENT_DB_NAME		"stob_ut_client.db"
-
-enum {
-	CLIENT_COB_DOM_ID	= 18,
-	SESSION_SLOTS		= 1,
-	MAX_RPCS_IN_FLIGHT	= 1,
-	CONNECT_TIMEOUT		= 5,
-};
-
-extern struct c2_net_xprt c2_net_bulk_sunrpc_xprt;
-
 int got_quit = 0;
 
+static int netcall(struct c2_net_conn *conn, struct c2_fop *arg, 
+		   struct c2_fop *ret)
+{
+	struct c2_net_call call = {
+		.ac_arg = arg,
+		.ac_ret = ret
+	};
+	return c2_net_cli_call(conn, &call);
+}
+
+static void create_send(struct c2_net_conn *conn, const struct c2_fop_fid *fid)
+{
+	int result;
+	struct c2_fop                    *f;
+	struct c2_fop                    *r;
+	struct c2_io_create     *fop;
+	struct c2_io_create_rep *rep;
+
+	f = c2_fop_alloc(&c2_io_create_fopt, NULL);
+	fop = c2_fop_data(f);
+	r = c2_fop_alloc(&c2_io_create_rep_fopt, NULL);
+	rep = c2_fop_data(r);
+	fop->sic_object = *fid;
+
+	result = netcall(conn, f, r);
+	printf("GOT: %i %i\n", result, rep->sicr_rc);
+}
 
-static void create_send(struct c2_rpc_session *session, const struct stob_io_fop_fid *fid)
+static void read_send(struct c2_net_conn *conn, const struct c2_fop_fid *fid)
 {
-	int rc;
-	struct c2_fop                   *fop;
-	struct c2_fop                   *rep;
-	struct c2_stob_io_create	*fop_data;
-	struct c2_stob_io_create_rep	*rep_data;
-
-	fop = c2_fop_alloc(&c2_stob_io_create_fopt, NULL);
-	fop_data = c2_fop_data(fop);
-	fop_data->fic_object = *fid;
-	rc = c2_rpc_client_call(fop, session, &c2_fop_default_item_ops,
-					CONNECT_TIMEOUT);
-	C2_ASSERT(rc == 0);
-	C2_ASSERT(fop->f_item.ri_error == 0);
-	C2_ASSERT(fop->f_item.ri_reply != 0);
-	rep = container_of(fop->f_item.ri_reply, struct c2_fop, f_item);
-	rep_data = c2_fop_data(rep);
-	printf("GOT: %d %d\n", rc, rep_data->ficr_rc);
+	int result;
+	struct c2_fop                    *f;
+	struct c2_fop                    *r;
+	struct c2_io_read       *fop;
+	struct c2_io_read_rep   *rep;
+	int i;
+
+	f = c2_fop_alloc(&c2_io_read_fopt, NULL);
+	fop = c2_fop_data(f);
+	r = c2_fop_alloc(&c2_io_read_rep_fopt, NULL);
+	rep = c2_fop_data(r);
+
+	fop->sir_object = *fid;
+	if (scanf("%i", &i) != 1)
+		err(1, "wrong count conversion");
+	C2_ASSERT(i == 1);
+	if (scanf("%llu %llu", 
+		  (unsigned long long *)&fop->sir_seg.f_offset, 
+		  (unsigned long long *)&fop->sir_seg.f_count) != 2) {
+		err(1, "wrong offset conversion");
+	}
+	result = netcall(conn, f, r);
+	C2_ASSERT(result == 0);
+	printf("GOT: %i %i\n", rep->sirr_rc, rep->sirr_buf.cib_count);
+	printf("\t[");
+	for (i = 0; i < rep->sirr_buf.cib_count; ++i)
+		printf("%02x", rep->sirr_buf.cib_value[i]);
+	printf("]\n");
 }
 
-static void read_send(struct c2_rpc_session *session, const struct stob_io_fop_fid *fid)
+static void write_send(struct c2_net_conn *conn, const struct c2_fop_fid *fid)
 {
-	int rc;
-	struct c2_fop                   *fop;
-	struct c2_fop                   *rep;
-	struct c2_stob_io_read		*fop_data;
-	struct c2_stob_io_read_rep	*rep_data;
-
-	fop = c2_fop_alloc(&c2_stob_io_read_fopt, NULL);
-	fop_data = c2_fop_data(fop);
-	fop_data->fir_object = *fid;
-
-	rc = c2_rpc_client_call(fop, session, &c2_fop_default_item_ops,
-					CONNECT_TIMEOUT);
-	C2_ASSERT(rc == 0);
-	C2_ASSERT(fop->f_item.ri_error == 0);
-	C2_ASSERT(fop->f_item.ri_reply != 0);
-
-	rep = container_of(fop->f_item.ri_reply, struct c2_fop, f_item);
-	rep_data = c2_fop_data(rep);
-	printf("GOT: %d %d %u %c\n", rc, rep_data->firr_rc,
-			rep_data->firr_count, rep_data->firr_value);
+	int result;
+	struct c2_fop                    *f;
+	struct c2_fop                    *r;
+	struct c2_io_write      *fop;
+	struct c2_io_write_rep  *rep;
+	char filler;
+
+	f = c2_fop_alloc(&c2_io_write_fopt, NULL);
+	fop = c2_fop_data(f);
+	r = c2_fop_alloc(&c2_io_write_rep_fopt, NULL);
+	rep = c2_fop_data(r);
+
+	C2_SET0(&rep);
+	fop->siw_object = *fid;
+	if (scanf("%i", &result) != 1)
+		err(1, "wrong count conversion");
+	C2_ASSERT(result == 1);
+	if (scanf("%llu %u %c", 
+		  (unsigned long long *)&fop->siw_offset, 
+		  &fop->siw_buf.cib_count, &filler) != 3)
+		err(1, "wrong offset conversion");
+	fop->siw_buf.cib_value = c2_alloc(fop->siw_buf.cib_count);
+	C2_ASSERT(fop->siw_buf.cib_value != NULL);
+	memset(fop->siw_buf.cib_value, filler, fop->siw_buf.cib_count);
+
+	result = netcall(conn, f, r);
+	C2_ASSERT(result == 0);
+	rep = c2_fop_data(r);
+
+	printf("GOT: %i %i %i\n", result, rep->siwr_rc, rep->siwr_count);
 }
 
-static void write_send(struct c2_rpc_session *session, const struct stob_io_fop_fid *fid)
+static void quit_send(struct c2_net_conn *conn)
 {
-	int rc;
-	struct c2_fop                   *fop;
-	struct c2_fop                   *rep;
-	struct c2_stob_io_write		*fop_data;
-	struct c2_stob_io_write_rep	*rep_data;
-
-	fop = c2_fop_alloc(&c2_stob_io_write_fopt, NULL);
-	fop_data = c2_fop_data(fop);
-	fop_data->fiw_object = *fid;
-	fop_data->fiw_value = 'x';
-
-	rc = c2_rpc_client_call(fop, session, &c2_fop_default_item_ops,
-					CONNECT_TIMEOUT);
-	C2_ASSERT(rc == 0);
-	C2_ASSERT(fop->f_item.ri_error == 0);
-	C2_ASSERT(fop->f_item.ri_reply != 0);
-
-	rep = container_of(fop->f_item.ri_reply, struct c2_fop, f_item);
-	rep_data = c2_fop_data(rep);
-	printf("GOT: %d %d %u\n", rc, rep_data->fiwr_rc,
-			rep_data->fiwr_count);
+	struct c2_fop              *f;
+	struct c2_fop              *r;
+	struct c2_io_quit *fop;
+	struct c2_io_quit *rep;
+	int result;
+
+	f = c2_fop_alloc(&c2_io_quit_fopt, NULL);
+	fop = c2_fop_data(f);
+	r = c2_fop_alloc(&c2_io_quit_fopt, NULL);
+	rep = c2_fop_data(r);
+
+	result = netcall(conn, f, r);
+	C2_ASSERT(result == 0);
+	rep = c2_fop_data(r);
+	printf("GOT: %i %i\n", result, rep->siq_rc);
+	got_quit = 1;
 }
 
 /**
@@ -140,7 +167,7 @@ static void write_send(struct c2_rpc_session *session, const struct stob_io_fop_
 
    Synopsis:
 
-     client [ip_addr:port:id]
+     client host port
 
    After connecting to the server, the client reads commands from the standard
    input. The following commands are supported:
@@ -149,119 +176,131 @@ static void write_send(struct c2_rpc_session *session, const struct stob_io_fop_
 
            Create an object with the fid (D1:D2)
 
-       w <D1> <D2>
+       w <D1> <D2> <N> <OFF0> <COUNT0> <FILLER0> <OFF1> <COUNT1> <FILLER1> ...
 
-           Write into an object with the fid (D1:D2).
+           Write into an object with the fid (D1:D2) N buffers described by
+           (offset, count, filler) triples that follow. Offset is the staring
+           offset in the file, count is buffer size in bytes and filler is a
+           character with which the buffer is filled.
 
-       r <D1> <D2>
+       r <D1> <D2> <N> <OFF0> <COUNT0> <OFF1> <COUNT1> ...
 
-           Read from an object with the fid (D1:D2).
+           Read from an object with the fid (D1:D2) N buffers with given offsets
+           and sizes.
+
+       q <D1> <D2>
+
+           Shutdown the server.
  */
 int main(int argc, char **argv)
 {
-	int rc;
-	struct c2_net_xprt    *xprt = &c2_net_bulk_sunrpc_xprt;
-	struct c2_net_domain  net_dom = { };
-	struct c2_dbenv       dbenv;
-	struct c2_cob_domain  cob_dom;
-
-	struct c2_rpc_client_ctx cctx = {
-		.rcx_net_dom            = &net_dom,
-		.rcx_local_addr         = CLIENT_ENDPOINT_ADDR,
-		.rcx_remote_addr        = SERVER_ENDPOINT_ADDR,
-		.rcx_dbenv              = &dbenv,
-		.rcx_db_name            = CLIENT_DB_NAME,
-		.rcx_cob_dom            = &cob_dom,
-		.rcx_cob_dom_id         = CLIENT_COB_DOM_ID,
-		.rcx_nr_slots           = SESSION_SLOTS,
-		.rcx_timeout_s          = CONNECT_TIMEOUT,
-		.rcx_max_rpcs_in_flight = MAX_RPCS_IN_FLIGHT,
+	int result;
+
+	struct c2_service_id    sid = { .si_uuid = "UUURHG" };
+	struct c2_net_domain    ndom = {
+		.nd_xprt = NULL
 	};
+	struct c2_net_conn     *conn;
 
 	setbuf(stdout, NULL);
 	setbuf(stderr, NULL);
 
-	if (argc > 1)
-		cctx.rcx_remote_addr = argv[1];
+	if (argc != 3) {
+		fprintf(stderr, "%s host port\n", argv[0]);
+		return -1;
+	}
+
+	result = c2_init();
+	C2_ASSERT(result == 0);
 
-	rc = c2_init();
-	C2_ASSERT(rc == 0);
+	result = io_fop_init();
+	C2_ASSERT(result == 0);
 
-	rc = c2_processors_init();
-	C2_ASSERT(rc == 0);
+	result = c2_net_xprt_init(&c2_net_usunrpc_xprt);
+	C2_ASSERT(result == 0);
 
-	rc = c2_stob_io_fop_init();
-	C2_ASSERT(rc == 0);
+	result = c2_net_domain_init(&ndom, &c2_net_usunrpc_xprt);
+	C2_ASSERT(result == 0);
 
-	rc = c2_net_xprt_init(xprt);
-	C2_ASSERT(rc == 0);
+	result = c2_service_id_init(&sid, &ndom, argv[1], atoi(argv[2]));
+	C2_ASSERT(result == 0);
 
-	rc = c2_net_domain_init(&net_dom, xprt);
-	C2_ASSERT(rc == 0);
+	result = c2_net_conn_create(&sid);
+	C2_ASSERT(result == 0);
 
-	rc = c2_rpc_client_init(&cctx);
-	C2_ASSERT(rc == 0);
+	conn = c2_net_conn_find(&sid);
+	C2_ASSERT(conn != NULL);
 
-	printf("cmd> ");
+	/* write addb record onto network */
+	c2_addb_choose_store_media(C2_ADDB_REC_STORE_NETWORK, c2_addb_net_add, conn);
 
 	while (!feof(stdin)) {
-		struct stob_io_fop_fid fid;
-		char                   cmd;
-		char                   *line = NULL;
-		size_t                 n = 0;
-
-		rc = getline(&line, &n, stdin);
-		if (rc == -1) {
-			if (feof(stdin))
-				return EXIT_SUCCESS;
-			else
-				err(EXIT_FAILURE, "failed to read line from STDIN");
-		}
+		struct c2_fop_fid fid;
+		char cmd;
+		int n;
 
-		n = sscanf(line, "%c %lu %lu\n", &cmd, (unsigned long *)&fid.f_seq,
+		n = scanf("%c %lu %lu", &cmd, (unsigned long *)&fid.f_seq, 
 			  (unsigned long *)&fid.f_oid);
 		if (n != 3)
-			err(1, "wrong conversion: %zd", n);
-
-		free(line);
-
+			err(1, "wrong conversion: %i", n);
 		switch (cmd) {
 		case 'c':
-			create_send(&cctx.rcx_session, &fid);
+			create_send(conn, &fid);
 			break;
 		case 'r':
-			read_send(&cctx.rcx_session, &fid);
+			read_send(conn, &fid);
 			break;
 		case 'w':
-			write_send(&cctx.rcx_session, &fid);
+			write_send(conn, &fid);
 			break;
 		case 'q':
-			got_quit = 1;
+			quit_send(conn);
 			break;
 		default:
 			err(1, "Unknown command '%c'", cmd);
 		}
-
 		if (got_quit)
 			break;
-
-		printf("cmd> ");
+		n = scanf(" \n");
 	}
 
-	rc = c2_rpc_client_fini(&cctx);
-	C2_ASSERT(rc == 0);
+	c2_addb_choose_store_media(C2_ADDB_REC_STORE_NONE);
+	c2_net_conn_unlink(conn);
+	c2_net_conn_release(conn);
 
-	c2_net_domain_fini(&net_dom);
-	c2_net_xprt_fini(xprt);
-	c2_stob_io_fop_fini();
+	c2_service_id_fini(&sid);
+	c2_net_domain_fini(&ndom);
+	c2_net_xprt_fini(&c2_net_usunrpc_xprt);
+	io_fop_fini();
 	c2_fini();
 
 	return 0;
 }
 
+int create_handler(struct c2_fop *fop, struct c2_fop_ctx *ctx)
+{
+	return 0;
+}
+
+int read_handler(struct c2_fop *fop, struct c2_fop_ctx *ctx)
+{
+	return 0;
+}
+
+int write_handler(struct c2_fop *fop, struct c2_fop_ctx *ctx)
+{
+	return 0;
+}
+
+int quit_handler(struct c2_fop *fop, struct c2_fop_ctx *ctx)
+{
+	return 0;
+}
+
+
 /** @} end group stob */
 
-/*
+/* 
  *  Local variables:
  *  c-indentation-style: "K&R"
  *  c-basic-offset: 8
diff --git a/stob/ut/io.ff b/stob/ut/io.ff
index 5804ea0..8ff180e 100644
--- a/stob/ut/io.ff
+++ b/stob/ut/io.ff
@@ -1,24 +1,5 @@
 /* -*- C -*- */
 
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Nikita Danilov <Nikita_Danilov@xyratex.com>
- * Original creation date: 05/24/2010
- */
-
 /**
    @addtogroup stob
    @{
diff --git a/stob/ut/io_fop.h b/stob/ut/io_fop.h
index 385d508..c542b44 100644
--- a/stob/ut/io_fop.h
+++ b/stob/ut/io_fop.h
@@ -13,7 +13,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Nikita Danilov <Nikita_Danilov@xyratex.com>
+ * Original author: Nikita Danilov
  * Original creation date: 05/24/2010
  */
 
@@ -29,8 +29,18 @@ extern struct c2_fop_type c2_io_quit_fopt;
 extern struct c2_fop_type c2_io_write_rep_fopt;
 extern struct c2_fop_type c2_io_read_rep_fopt;
 extern struct c2_fop_type c2_io_create_rep_fopt;
-extern struct c2_fop_type c2_fop_file_create_fopt;
-extern struct c2_fop_type c2_fop_file_create_rep_fopt;
+//extern struct c2_fop_type c2_fop_cob_readv_fopt;
+//extern struct c2_fop_type c2_fop_cob_writev_fopt;
+
+extern struct c2_fop_type_format c2_fop_file_fid_tfmt;
+extern struct c2_fop_type_format c2_fop_io_buf_tfmt;
+extern struct c2_fop_type_format c2_fop_io_seg_tfmt;
+extern struct c2_fop_type_format c2_fop_io_vec_tfmt;
+extern struct c2_fop_type_format c2_fop_cob_readv_tfmt;
+extern struct c2_fop_type_format c2_fop_cob_writev_tfmt;
+extern struct c2_fop_type_format c2_fop_segment_tfmt;
+extern struct c2_fop_type_format c2_fop_cob_writev_rep_tfmt;
+extern struct c2_fop_type_format c2_fop_cob_readv_rep_tfmt;
 
 int io_fop_init(void);
 void io_fop_fini(void);
diff --git a/stob/ut/io_fop_init.c b/stob/ut/io_fop_init.c
index a3a362a..b29213e 100644
--- a/stob/ut/io_fop_init.c
+++ b/stob/ut/io_fop_init.c
@@ -13,7 +13,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Nikita Danilov <Nikita_Danilov@xyratex.com>
+ * Original author: Nikita Danilov
  * Original creation date: 06/29/2010
  */
 
@@ -25,14 +25,16 @@
 #include "fop/fop.h"
 #include "fop/fom.h"
 #include "fop/fop_iterator.h"
+#include "ioservice/io_foms.h"
 
 #include "stob/ut/io_fop.h"
 #include "fop/fop_format_def.h"
-#include "rpc/rpc_opcodes.h"
+#include "ioservice/io_fops.h"
 
 #ifdef __KERNEL__
 # include "io_k.h"
-# include "addb/addb_k.h"
+# include "io_fops_k.h"
+# include "addb/linux_kernel/addb_k.h"
 # define write_handler NULL
 # define read_handler NULL
 # define create_handler NULL
@@ -40,20 +42,18 @@
 
 #else
 
-# define write_handler NULL
-# define read_handler NULL
-# define create_handler NULL
-# define quit_handler NULL
-/*int create_handler(struct c2_fop *fop, struct c2_fop_ctx *ctx);
+int create_handler(struct c2_fop *fop, struct c2_fop_ctx *ctx);
 int read_handler(struct c2_fop *fop, struct c2_fop_ctx *ctx);
 int write_handler(struct c2_fop *fop, struct c2_fop_ctx *ctx);
-int quit_handler(struct c2_fop *fop, struct c2_fop_ctx *ctx);*/
+int quit_handler(struct c2_fop *fop, struct c2_fop_ctx *ctx);
 
-#include "io_u.h"
+# include "io_u.h"
+# include "ioservice/io_fops_u.h"
 # include "addb/addb_u.h"
 #endif
 
 #include "stob/ut/io.ff"
+#include "addb/addb.ff"
 
 /**
    @addtogroup stob
@@ -76,31 +76,45 @@ static struct c2_fop_type_ops quit_ops = {
 	.fto_execute = quit_handler,
 };
 
-C2_FOP_TYPE_DECLARE(c2_io_write, "write",  &write_ops,
-		    C2_STOB_UT_WRITE_OPCODE, C2_RPC_ITEM_TYPE_REQUEST);
-C2_FOP_TYPE_DECLARE(c2_io_read, "read", &read_ops,
-		    C2_STOB_UT_READ_OPCODE, C2_RPC_ITEM_TYPE_REQUEST);
-C2_FOP_TYPE_DECLARE(c2_io_create, "create", &create_ops,
-		    C2_STOB_UT_CREATE_OPCODE, C2_RPC_ITEM_TYPE_REQUEST);
-C2_FOP_TYPE_DECLARE(c2_io_quit, "quit", &quit_ops,
-		    C2_STOB_UT_QUIT_OPCODE, C2_RPC_ITEM_TYPE_REQUEST);
-
-C2_FOP_TYPE_DECLARE(c2_io_write_rep,  "write reply",  NULL,
-		    C2_STOB_UT_WRITE_REPLY_OPCODE, C2_RPC_ITEM_TYPE_REPLY);
-C2_FOP_TYPE_DECLARE(c2_io_read_rep,   "read reply", NULL,
-		    C2_STOB_UT_READ_REPLY_OPCODE, C2_RPC_ITEM_TYPE_REPLY);
-C2_FOP_TYPE_DECLARE(c2_io_create_rep, "create reply", NULL,
-		    C2_STOB_UT_CREATE_REPLY_OPCODE, C2_RPC_ITEM_TYPE_REPLY);
+C2_FOP_TYPE_DECLARE(c2_io_write,      "write",  10, &write_ops);
+C2_FOP_TYPE_DECLARE(c2_io_read,       "read",   11, &read_ops);
+C2_FOP_TYPE_DECLARE(c2_io_create,     "create", 12, &create_ops);
+C2_FOP_TYPE_DECLARE(c2_io_quit,       "quit",   13, &quit_ops);
+
+C2_FOP_TYPE_DECLARE(c2_io_write_rep,  "write reply",  21, NULL);
+C2_FOP_TYPE_DECLARE(c2_io_read_rep,   "read reply",   22, NULL);
+C2_FOP_TYPE_DECLARE(c2_io_create_rep, "create reply", 23, NULL);
+
+struct c2_fop_type c2_addb_record_fopt = {
+	.ft_code = (14),
+	.ft_name = "addb",
+	.ft_fmt  = &c2_addb_record_header_tfmt,
+	.ft_ops  = NULL
+};
+
+struct c2_fop_type c2_addb_reply_fopt = {
+	.ft_code = (24),
+	.ft_name = "addb reply",
+	.ft_fmt  = &c2_addb_reply_tfmt,
+	.ft_ops  = NULL
+};
 
 static struct c2_fop_type *fops[] = {
 	&c2_io_write_fopt,
 	&c2_io_read_fopt,
 	&c2_io_create_fopt,
 	&c2_io_quit_fopt,
+	&c2_addb_record_fopt,
 
 	&c2_io_write_rep_fopt,
 	&c2_io_read_rep_fopt,
 	&c2_io_create_rep_fopt,
+	&c2_addb_reply_fopt,
+
+	&c2_fop_cob_readv_fopt,
+	&c2_fop_cob_writev_fopt,
+	&c2_fop_cob_writev_rep_fopt,
+	&c2_fop_cob_readv_rep_fopt,
 };
 
 static struct c2_fop_type_format *fmts[] = {
@@ -111,6 +125,11 @@ static struct c2_fop_type_format *fmts[] = {
 
 	&c2_mem_buf_tfmt,
 
+	&c2_fop_file_fid_tfmt,
+	&c2_fop_io_buf_tfmt,
+	&c2_fop_io_seg_tfmt,
+	&c2_fop_io_vec_tfmt,
+	&c2_fop_segment_tfmt,
 };
 
 void io_fop_fini(void)
diff --git a/stob/ut/io_fop_xdr.c b/stob/ut/io_fop_xdr.c
index 7bc4d2f..830e332 100644
--- a/stob/ut/io_fop_xdr.c
+++ b/stob/ut/io_fop_xdr.c
@@ -14,7 +14,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Nikita Danilov <Nikita_Danilov@xyratex.com>
+ * Original author: Nikita Danilov
  * Original creation date: 05/24/2010
  */
 
diff --git a/stob/ut/server.c b/stob/ut/server.c
index 81170ba..a06b87c 100644
--- a/stob/ut/server.c
+++ b/stob/ut/server.c
@@ -13,7 +13,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Nikita Danilov <Nikita_Danilov@xyratex.com>
+ * Original author: Nikita Danilov
  * Original creation date: 05/21/2010
  */
 
@@ -21,17 +21,33 @@
 #  include <config.h>
 #endif
 
-#include <stdio.h>     /* printf, perror */
+#include <stdio.h>
+#include <stdlib.h>
+#include <sys/stat.h>  /* mkdir */
+#include <sys/types.h> /* mkdir */
 #include <unistd.h>    /* sleep */
-#include <signal.h>    /* sigaction */
-
-#include "colibri/init.h" /* c2_init */
-#include "rpc/rpclib.h"   /* c2_rpc_server_start */
-#include "ut/rpc.h"       /* C2_RPC_SERVER_CTX_DECLARE */
-
-#include "stob/io_fop.h"  /* c2_stob_io_fop_init */
-#include "stob/io_fop_u.h"
 
+#include "lib/misc.h"   /* C2_SET0 */
+#include "lib/getopts.h"
+#include "lib/arith.h"  /* min64u */
+#include "lib/trace.h"
+#include "lib/errno.h"
+#include "lib/assert.h"
+#include "lib/memory.h"
+#include "fop/fop.h"
+#include "fop/fom.h"
+#include "net/net.h"
+#include "net/usunrpc/usunrpc.h"
+
+#include "stob/stob.h"
+#include "stob/linux.h"
+#include "stob/ad.h"
+#include "colibri/init.h"
+
+#include "io_fop.h"
+#include "io_u.h"
+#include "ioservice/io_foms.h"
+#include "ioservice/io_fops.h"
 
 #include "reqh/reqh.h"
 #include "iostore/iostore.h"
@@ -42,90 +58,613 @@
    @{
  */
 
-#define SERVER_ENDPOINT_ADDR	"127.0.0.1:12346:1"
-#define SERVER_ENDPOINT		"bulk-sunrpc:" SERVER_ENDPOINT_ADDR
-#define SERVER_DB_FILE_NAME	"stob_ut_server.db"
-#define SERVER_STOB_FILE_NAME	"stob_ut_server.stob"
-#define SERVER_LOG_FILE_NAME	"stob_ut_server.log"
+static struct c2_addb_ctx server_addb_ctx;
+
+static const struct c2_addb_loc server_addb_loc = {
+	.al_name = "server"
+};
+
+const struct c2_addb_ctx_type server_addb_ctx_type = {
+	.act_name = "t1-server",
+};
+
+#define SERVER_ADDB_ADD(name, rc)                                       \
+C2_ADDB_ADD(&server_addb_ctx, &server_addb_loc, c2_addb_func_fail, (name), (rc))
+
+static struct c2_stob_domain *dom;
+static struct c2_fol          fol;
+static struct c2_reqh         reqh;
+static struct c2_site         site;
+static struct c2_io_store   iostore;
+
+static struct c2_stob *object_find(const struct c2_fop_fid *fid,
+				   struct c2_dtx *tx)
+{
+	struct c2_stob_id  id;
+	struct c2_stob    *obj;
+	int result;
+
+	id.si_bits.u_hi = fid->f_seq;
+	id.si_bits.u_lo = fid->f_oid;
+	result = dom->sd_ops->sdo_stob_find(dom, &id, &obj);
+	C2_ASSERT(result == 0);
+	result = c2_stob_locate(obj, tx);
+	return obj;
+}
+
+int create_handler(struct c2_fop *fop, struct c2_fop_ctx *ctx)
+{
+	struct c2_io_create     *in = c2_fop_data(fop);
+	struct c2_io_create_rep *ex;
+	struct c2_fop           *reply;
+	struct c2_stob          *obj;
+	struct c2_dtx            tx;
+	int                      result;
+
+	reply = c2_fop_alloc(&c2_io_create_rep_fopt, NULL);
+	C2_ASSERT(reply != NULL);
+	ex = c2_fop_data(reply);
+
+	result = dom->sd_ops->sdo_tx_make(dom, &tx);
+	C2_ASSERT(result == 0);
+
+	obj = object_find(&in->sic_object, &tx);
+
+	result = c2_stob_create(obj, &tx);
+	C2_ASSERT(result == 0);
+	ex->sicr_rc = 0;
+	c2_net_reply_post(ctx->fc_service, reply, ctx->fc_cookie);
+
+	c2_stob_put(obj);
+
+	result = c2_fop_fol_rec_add(fop, &fol, &tx.tx_dbtx);
+	C2_ASSERT(result == 0);
+
+	result = c2_db_tx_commit(&tx.tx_dbtx);
+	C2_ASSERT(result == 0);
+
+	return 1;
+}
+
+int read_handler(struct c2_fop *fop, struct c2_fop_ctx *ctx)
+{
+	struct c2_io_read     *in = c2_fop_data(fop);
+	struct c2_io_read_rep *ex;
+	struct c2_fop         *reply;
+	struct c2_stob        *obj;
+	struct c2_stob_io      io;
+	struct c2_clink        clink;
+	struct c2_dtx          tx;
+	void                  *addr;
+	uint32_t               bshift;
+	uint64_t               bmask;
+	int                    result;
+	int                    rc;
+
+	reply = c2_fop_alloc(&c2_io_read_rep_fopt, NULL);
+	C2_ASSERT(reply != NULL);
+	ex = c2_fop_data(reply);
+
+	while (1) {
+		result = dom->sd_ops->sdo_tx_make(dom, &tx);
+		C2_ASSERT(result == 0);
+
+		obj = object_find(&in->sir_object, &tx);
+
+		bshift = obj->so_op->sop_block_shift(obj);
+		bmask  = (1 << bshift) - 1;
+
+		C2_ASSERT((in->sir_seg.f_count & bmask) == 0);
+		C2_ASSERT((in->sir_seg.f_offset & bmask) == 0);
+
+		C2_ALLOC_ARR(ex->sirr_buf.cib_value, in->sir_seg.f_count);
+		C2_ASSERT(ex->sirr_buf.cib_value != NULL);
+
+		in->sir_seg.f_count >>= bshift;
+		in->sir_seg.f_offset >>= bshift;
+
+		addr = c2_stob_addr_pack(ex->sirr_buf.cib_value, bshift);
+
+		c2_stob_io_init(&io);
+
+		io.si_user.div_vec.ov_vec.v_nr    = 1;
+		io.si_user.div_vec.ov_vec.v_count = &in->sir_seg.f_count;
+		io.si_user.div_vec.ov_buf = &addr;
+
+		io.si_stob.iv_vec.v_nr    = 1;
+		io.si_stob.iv_vec.v_count = &in->sir_seg.f_count;
+		io.si_stob.iv_index       = &in->sir_seg.f_offset;
+
+		io.si_opcode = SIO_READ;
+		io.si_flags  = 0;
+
+		c2_clink_init(&clink, NULL);
+		c2_clink_add(&io.si_wait, &clink);
+
+		result = c2_stob_io_launch(&io, obj, &tx, NULL);
+		C2_ASSERT(result == 0);
+
+		c2_chan_wait(&clink);
+
+		ex->sirr_rc            = io.si_rc;
+		ex->sirr_buf.cib_count = io.si_count << bshift;
+
+		c2_clink_del(&clink);
+		c2_clink_fini(&clink);
+
+		c2_stob_io_fini(&io);
+
+		c2_stob_put(obj);
+
+		if (result != -EDEADLK) {
+			rc = c2_db_tx_commit(&tx.tx_dbtx);
+			C2_ASSERT(rc == 0);
+			break;
+		} else {
+			fprintf(stderr, "Deadlock, aborting read.\n");
+			rc = c2_db_tx_abort(&tx.tx_dbtx);
+			C2_ASSERT(rc == 0);
+		}
+	}
+	c2_net_reply_post(ctx->fc_service, reply, ctx->fc_cookie);
+
+	return 1;
+}
+
+int write_handler(struct c2_fop *fop, struct c2_fop_ctx *ctx)
+{
+	struct c2_io_write     *in = c2_fop_data(fop);
+	struct c2_io_write_rep *ex;
+	struct c2_fop          *reply;
+	struct c2_stob         *obj;
+	struct c2_stob_io       io;
+	struct c2_dtx           tx;
+	void                   *addr;
+	c2_bcount_t             count;
+	c2_bindex_t             offset;
+	struct c2_clink         clink;
+	uint32_t                bshift;
+	uint64_t                bmask;
+	int                     result;
+	int                     rc;
+
+	reply = c2_fop_alloc(&c2_io_write_rep_fopt, NULL);
+	C2_ASSERT(reply != NULL);
+	ex = c2_fop_data(reply);
+
+	while (1) {
+		result = dom->sd_ops->sdo_tx_make(dom, &tx);
+		C2_ASSERT(result == 0);
+
+		obj = object_find(&in->siw_object, &tx);
+
+		bshift = obj->so_op->sop_block_shift(obj);
+		bmask  = (1 << bshift) - 1;
+
+		C2_ASSERT((in->siw_buf.cib_count & bmask) == 0);
+		C2_ASSERT((in->siw_offset & bmask) == 0);
+
+		addr = c2_stob_addr_pack(in->siw_buf.cib_value, bshift);
+		count = in->siw_buf.cib_count >> bshift;
+		offset = in->siw_offset >> bshift;
+
+		c2_stob_io_init(&io);
+
+		io.si_user.div_vec.ov_vec.v_nr    = 1;
+		io.si_user.div_vec.ov_vec.v_count = &count;
+		io.si_user.div_vec.ov_buf = &addr;
+
+		io.si_stob.iv_vec.v_nr    = 1;
+		io.si_stob.iv_vec.v_count = &count;
+		io.si_stob.iv_index       = &offset;
+
+		io.si_opcode = SIO_WRITE;
+		io.si_flags  = 0;
+
+		c2_clink_init(&clink, NULL);
+		c2_clink_add(&io.si_wait, &clink);
+
+		result = c2_stob_io_launch(&io, obj, &tx, NULL);
+
+		if (result == 0)
+			c2_chan_wait(&clink);
+
+		ex->siwr_rc    = io.si_rc;
+		ex->siwr_count = io.si_count << bshift;
+
+		c2_clink_del(&clink);
+		c2_clink_fini(&clink);
+
+		c2_stob_io_fini(&io);
+
+		c2_stob_put(obj);
+
+		if (result != -EDEADLK) {
+			result = c2_fop_fol_rec_add(fop, &fol, &tx.tx_dbtx);
+			C2_ASSERT(result == 0);
+
+			rc = c2_db_tx_commit(&tx.tx_dbtx);
+			C2_ASSERT(rc == 0);
+			break;
+		} else {
+			fprintf(stderr, "Deadlock, aborting write.\n");
+			rc = c2_db_tx_abort(&tx.tx_dbtx);
+			C2_ASSERT(rc == 0);
+		}
+	}
+	c2_net_reply_post(ctx->fc_service, reply, ctx->fc_cookie);
+
+	return 1;
+}
 
 static bool stop = false;
 
-static void sigint_handler(int signum)
+int quit_handler(struct c2_fop *fop, struct c2_fop_ctx *ctx)
 {
+	struct c2_fop     *reply;
+        struct c2_io_quit *ex;
+
+	reply = c2_fop_alloc(&c2_io_quit_fopt, NULL);
+	C2_ASSERT(reply != NULL);
+	ex = c2_fop_data(reply);
+
+	ex->siq_rc = 42;
 	stop = true;
+
+	c2_net_reply_post(ctx->fc_service, reply, ctx->fc_cookie);
+	return 1;
+}
+
+static int io_handler(struct c2_service *service, struct c2_fop *fop,
+		      void *cookie)
+{
+	struct c2_fop_ctx  ctx;
+	int                result;
+
+	/* 
+	 * FOMs are implemented only for read and write operations 
+	 */
+	if ((fop->f_type->ft_code >= c2_io_service_readv_opcode)) {
+	        result = c2_reqh_fop_handle(&reqh, fop, cookie);
+		return result;
+	} else {
+	        ctx.fc_service = service;
+	        ctx.fc_cookie  = cookie;
+	        result = fop->f_type->ft_ops->fto_execute(fop, &ctx);
+	}
+	SERVER_ADDB_ADD("io_handler", result);
+	return result;
+}
+
+extern struct c2_fop_type c2_addb_record_fopt; /* opcode = 14 */
+
+static struct c2_fop_type *fopt[] = {
+	&c2_io_write_fopt,
+	&c2_io_read_fopt,
+	&c2_io_create_fopt,
+	&c2_io_quit_fopt,
+
+	&c2_addb_record_fopt,
+
+	&c2_fop_cob_readv_fopt,
+	&c2_fop_cob_writev_fopt,
+	&c2_fop_cob_writev_rep_fopt,
+	&c2_fop_cob_readv_rep_fopt,
+};
+
+struct mock_balloc {
+	struct c2_mutex  mb_lock;
+	c2_bindex_t      mb_next;
+	struct ad_balloc mb_ballroom;
+};
+
+static struct mock_balloc *b2mock(struct ad_balloc *ballroom)
+{
+	return container_of(ballroom, struct mock_balloc, mb_ballroom);
 }
 
-extern struct c2_net_xprt c2_net_bulk_sunrpc_xprt;
+static int mock_balloc_init(struct ad_balloc *ballroom, struct c2_dbenv *db,
+			    uint32_t bshift)
+{
+	struct mock_balloc *mb = b2mock(ballroom);
+
+	c2_mutex_init(&mb->mb_lock);
+	return 0;
+}
+
+static void mock_balloc_fini(struct ad_balloc *ballroom)
+{
+	struct mock_balloc *mb = b2mock(ballroom);
+
+	c2_mutex_fini(&mb->mb_lock);
+}
+
+static int mock_balloc_alloc(struct ad_balloc *ballroom, struct c2_dtx *tx,
+			     c2_bcount_t count, struct c2_ext *out)
+{
+	struct mock_balloc *mb = b2mock(ballroom);
+	c2_bcount_t giveout;
+
+	c2_mutex_lock(&mb->mb_lock);
+	giveout = min64u(count, 500000);
+	out->e_start = mb->mb_next;
+	out->e_end   = mb->mb_next + giveout;
+	mb->mb_next += giveout + 1;
+	/*
+	printf("allocated %8lx/%8lx bytes: [%8lx .. %8lx)\n", giveout, count,
+	       out->e_start, out->e_end); */
+	c2_mutex_unlock(&mb->mb_lock);
+	return 0;
+}
+
+static int mock_balloc_free(struct ad_balloc *ballroom, struct c2_dtx *tx,
+			    struct c2_ext *ext)
+{
+	printf("freed     %8lx bytes: [%8lx .. %8lx)\n", c2_ext_length(ext),
+	       ext->e_start, ext->e_end);
+	return 0;
+}
+
+static const struct ad_balloc_ops mock_balloc_ops = {
+	.bo_init  = mock_balloc_init,
+	.bo_fini  = mock_balloc_fini,
+	.bo_alloc = mock_balloc_alloc,
+	.bo_free  = mock_balloc_free,
+};
+
+static struct mock_balloc mb = {
+	.mb_next = 0,
+	.mb_ballroom = {
+		.ab_ops = &mock_balloc_ops
+	}
+};
+
+static const struct c2_table_ops c2_addb_record_ops = {
+	.to = {
+		[TO_KEY] = { .max_size = sizeof (uint64_t) },
+		[TO_REC] = { .max_size = 4096 }
+	},
+	.key_cmp = NULL
+};
 
 /**
    Simple server for unit-test purposes.
 
    Synopsis:
 
-       server [options]
+       server path port
 
-       Options can be any valid colibri_setup option. Please, see cs_help() in
-       colibri/colibri_setup.c for reference.
+   "path" is a path to a directory that the server will create if necessary that
+   would contain objects (a path to a storage object domain, c2_stob_domain,
+   technically).
+
+   "port" is a port the server listens to.
+
+   Server supports create, read and write commands.
  */
+extern c2_bindex_t addb_stob_offset;
+extern uint64_t c2_addb_db_seq;
 int main(int argc, char **argv)
 {
-	int rc;
-	struct c2_net_xprt *xprt = &c2_net_bulk_sunrpc_xprt;
-
-	struct sigaction sigint_action = {
-		.sa_handler = sigint_handler,
+	int         result;
+	const char *path;
+	char        opath[64];
+	char        dpath[64];
+	int         port;
+	int         i = 0;
+
+	struct c2_stob_domain  *bdom;
+	struct c2_stob_id       backid;
+	struct c2_stob         *bstore;
+	struct c2_service_id    sid = { .si_uuid = "UUURHG" };
+	struct c2_service       service;
+	struct c2_net_domain    ndom = {
+		.nd_xprt = NULL
 	};
+	struct c2_dbenv         db;
+	struct c2_stob_id       addb_stob_id = {
+					.si_bits = {
+						.u_hi = 0xADDBADDBADDBADDB,
+						.u_lo = 0x210B210B210B210B
+					}
+				};
+	struct c2_stob	       *addb_stob;
+
+	struct c2_table	        addb_table;
+
+	setbuf(stdout, NULL);
+	setbuf(stderr, NULL);
+
+	backid.si_bits.u_hi = 0x8;
+	backid.si_bits.u_lo = 0xf00baf11e;
+	/* port above 1024 is for normal use access permission */
+	port = 1201;
+	path = "__s";
+
+	result = C2_GETOPTS("server", argc, argv,
+			    C2_VOIDARG('T', "parse trace log produced earlier",
+				       LAMBDA(void, (void) {
+					       c2_trace_parse();
+					       exit(0);
+					       })),
+			    C2_STRINGARG('d', "path to object store",
+				       LAMBDA(void, (const char *string) {
+					       path = string; })),
+			    C2_FORMATARG('o', "back store object id", "%lu",
+					 &backid.si_bits.u_lo),
+			    C2_FORMATARG('p', "port to listen at", "%i", &port));
+	if (result != 0)
+		return result;
+
+	printf("path=%s, back store object=%llx.%llx, tcp port=%d\n",
+		path, (unsigned long long)backid.si_bits.u_hi,
+		(unsigned long long)backid.si_bits.u_lo, port);
+
+	result = c2_init();
+	C2_ASSERT(result == 0);
+
+	c2_addb_ctx_init(&server_addb_ctx, &server_addb_ctx_type,
+			 &c2_addb_global_ctx);
+
+	result = io_fop_init();
+	C2_ASSERT(result == 0);
+
+	C2_ASSERT(strlen(path) < ARRAY_SIZE(opath) - 8);
+
+	result = mkdir(path, 0700);
+	C2_ASSERT(result == 0 || (result == -1 && errno == EEXIST));
+	sprintf(opath, "%s/o", path);
+	result = mkdir(opath, 0700);
+	C2_ASSERT(result == 0 || (result == -1 && errno == EEXIST));
+
+	sprintf(dpath, "%s/d", path);
 
-	char *default_server_argv[] = {
-		argv[0], "-r", "-T", "AD", "-D", SERVER_DB_FILE_NAME,
-		"-S", SERVER_STOB_FILE_NAME, "-e", SERVER_ENDPOINT,
-		"-s", "ds1", "-s", "ds2"
-	};
+	/*
+	 * Initialize the data-base and fol.
+	 */
+	result = c2_dbenv_init(&db, dpath, 0);
+	C2_ASSERT(result == 0);
 
-	C2_RPC_SERVER_CTX_DECLARE_SIMPLE(sctx, xprt, default_server_argv,
-				  SERVER_LOG_FILE_NAME);
+	result = c2_fol_init(&fol, &db);
+	C2_ASSERT(result == 0);
 
 	/*
-	 * If there are some CLI options, use them as input parameters for
-	 * c2_cs_setup_env(), otherwise use default_server_argv options.
+	 * Locate and create (if necessary) the backing store object.
 	 */
-	if (argc > 1) {
-		sctx.rsx_argc = argc;
-		sctx.rsx_argv = argv;
-	}
 
-	rc = sigaction(SIGINT, &sigint_action, NULL);
-	if (rc != 0) {
-		perror("Failed to set signal handler for SIGINT\n");
-		return rc;
-	}
+	result = linux_stob_type.st_op->sto_domain_locate(&linux_stob_type,
+							  path, &bdom);
+	C2_ASSERT(result == 0);
+
+	result = bdom->sd_ops->sdo_stob_find(bdom, &backid, &bstore);
+	C2_ASSERT(result == 0);
+	C2_ASSERT(bstore->so_state == CSS_UNKNOWN);
 
-	printf("Starting server...");
+	result = c2_stob_create(bstore, NULL);
+	C2_ASSERT(result == 0);
+	C2_ASSERT(bstore->so_state == CSS_EXISTS);
 
-	rc = c2_init();
-	C2_ASSERT(rc == 0);
+	/*
+	 * Create AD domain over backing store object.
+	 */
+	result = ad_stob_type.st_op->sto_domain_locate(&ad_stob_type, "", &dom);
+	C2_ASSERT(result == 0);
+
+	result = ad_setup(dom, &db, bstore, &mb.mb_ballroom);
+	C2_ASSERT(result == 0);
 
-	rc = c2_stob_io_fop_init();
-	C2_ASSERT(rc == 0);
+	c2_stob_put(bstore);
 
-	rc = c2_rpc_server_start(&sctx);
-	C2_ASSERT(rc == 0);
+	/* create or open a stob into which to store the record. */
+	result = bdom->sd_ops->sdo_stob_find(bdom, &addb_stob_id, &addb_stob);
+	C2_ASSERT(result == 0);
+	C2_ASSERT(addb_stob->so_state == CSS_UNKNOWN);
 
-	printf(" done\n");
-	printf("Press ^C to quit\n");
+	result = c2_stob_create(addb_stob, NULL);
+	C2_ASSERT(result == 0);
+	C2_ASSERT(addb_stob->so_state == CSS_EXISTS);
+	/* XXX The stob tail postion should be maintained & initialized */
+
+	/* write addb record into stob */
+	/*
+	 * TODO
+	 * Init the stob appending file offset position.
+	 * This should be stored somewhere transactionally.
+	 */
+	/*
+	addb_stob_offset = 0;
+	c2_addb_choose_store_media(C2_ADDB_REC_STORE_STOB, c2_addb_stob_add,
+				   addb_stob, NULL);
+	*/
+
+	result = c2_table_init(&addb_table, &db,
+			       "addb_record", 0,
+			       &c2_addb_record_ops);
+	C2_ASSERT(result == 0);
+	/*
+	 * TODO
+	 * The db addb seqno should be loaded and initialized.
+	 */
+
+	c2_addb_db_seq = 0;
+	c2_addb_choose_store_media(C2_ADDB_REC_STORE_DB, c2_addb_db_add,
+				   &addb_table, &db);
+	/*
+	 * Set up the service.
+	 */
+	C2_SET0(&service);
+
+	service.s_table.not_start = fopt[0]->ft_code;
+	service.s_table.not_nr    = ARRAY_SIZE(fopt);
+	service.s_table.not_fopt  = fopt;
+	service.s_handler         = &io_handler;
+
+	result = c2_net_xprt_init(&c2_net_usunrpc_xprt);
+	C2_ASSERT(result == 0);
+
+	result = c2_net_domain_init(&ndom, &c2_net_usunrpc_xprt);
+	C2_ASSERT(result == 0);
+
+	result = c2_service_id_init(&sid, &ndom, "127.0.0.1", port);
+	C2_ASSERT(result == 0);
+
+        /*
+         * Set up data store to be used.
+         */
+        result = c2_io_store_init(&iostore, bdom);
+        C2_ASSERT(result == 0);
+
+        /*
+         * Set up site.
+         */
+        result = c2_site_init(&site, NULL, &iostore);
+        C2_ASSERT(result == 0);
+
+        /*
+         * Set up reqh.
+         */
+        result = c2_reqh_init(&reqh, NULL, &fol, &site, &service);
+        C2_ASSERT(result == 0);
+
+	result = c2_service_start(&service, &sid);
+	C2_ASSERT(result >= 0);
 
 	while (!stop) {
 		sleep(1);
+                //printf("allocated: %li\n", c2_allocated());
+                if (i++ % 5 == 0)
+                        printf("busy: in=%5.2f out=%5.2f\n",
+                               (float)c2_net_domain_stats_get(&ndom, NS_STATS_IN) / 100,
+                               (float)c2_net_domain_stats_get(&ndom, NS_STATS_OUT) / 100);
         }
 
-	printf("\nStopping server...");
+	c2_service_stop(&service);
+	c2_service_id_fini(&sid);
+	c2_reqh_fini(&reqh);
+	c2_site_fini(&site);
+	c2_io_store_fini(&iostore);
+	c2_net_domain_fini(&ndom);
+	c2_net_xprt_fini(&c2_net_usunrpc_xprt);
 
-	c2_rpc_server_stop(&sctx);
-	c2_stob_io_fop_fini();
-	c2_fini();
+	/*
+	 * TODO
+	 * the stob file offset or db seqno should be updated and
+	 * stored somewhere, e.g. in global configuration db.
+	 */
+	c2_addb_choose_store_media(C2_ADDB_REC_STORE_NONE);
+
+	c2_table_fini(&addb_table);
 
-	printf(" done\n");
+	c2_stob_put(addb_stob);
 
+	dom->sd_ops->sdo_fini(dom);
+	bdom->sd_ops->sdo_fini(bdom);
+	io_fop_fini();
+	c2_fol_fini(&fol);
+	c2_dbenv_fini(&db);
+	c2_addb_ctx_fini(&server_addb_ctx);
+
+	c2_fini();
 	return 0;
 }
 
diff --git a/stob/ut/stobio.c b/stob/ut/stobio.c
index 91db2f9..11bf57a 100644
--- a/stob/ut/stobio.c
+++ b/stob/ut/stobio.c
@@ -13,7 +13,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
 
- * Original author: Nikita Danilov <Nikita_Danilov@xyratex.com>
+ * Original author: Nikita Danilov
  * Original creation date: 05/21/2010
  */
 
@@ -21,7 +21,6 @@
 #include <stdio.h>     /* fopen, fgetc, ... */
 #include <sys/stat.h>  /* mkdir */
 #include <sys/types.h> /* mkdir */
-#include <linux/limits.h>
 
 #include "lib/misc.h"    /* C2_SET0 */
 #include "lib/memory.h"
@@ -29,11 +28,9 @@
 #include "lib/assert.h"
 #include "lib/ut.h"
 #include "lib/mutex.h"
-#include "lib/arith.h"
 
 #include "stob/stob.h"
 #include "stob/linux.h"
-#include "stob/linux_internal.h"
 #include "stob/ad.h"
 #include "balloc/balloc.h"
 #include "colibri/init.h"
@@ -47,131 +44,44 @@
 
 enum {
 	RW_BUFF_NR    = 10,
-	MIN_BUFF_SIZE = 4096,
-	MIN_BUFF_SIZE_IN_BLOCKS = 4,
-	TEST_NR = 10
+	RW_BUFF_COUNT = 1024,
+	TEST_NR = 5
 };
 
 struct stobio_test {
 	/* ctrl part */
 	struct c2_stob	        *st_obj;
 	const struct c2_stob_id  st_id;
-	/* Real block device, if any */
-	char			*st_dev_path;
 
 	struct c2_stob_domain   *st_dom;
 	struct c2_stob_io	 st_io;
 
-	/* this flag controls whether to use direct IO */
-	bool st_directio;
-
-	size_t   st_rw_buf_size;
-	size_t   st_rw_buf_size_in_blocks;
-	uint32_t st_block_shift;
-	size_t   st_block_size;
-
 	/* read/write buffers */
 	char *st_rdbuf[RW_BUFF_NR];
-	char *st_rdbuf_packed[RW_BUFF_NR];
 	char *st_wrbuf[RW_BUFF_NR];
-	char *st_wrbuf_packed[RW_BUFF_NR];
 
 	/* read/write vectors */
 	c2_bcount_t st_rdvec[RW_BUFF_NR];
 	c2_bcount_t st_wrvec[RW_BUFF_NR];
 };
 
-/* Test block device */
-static const char test_blkdev[] = "/dev/loop0";
-
 /* sync object for init/fini */
 static struct c2_mutex lock;
 static struct c2_thread thread[TEST_NR];
 struct stobio_test test[TEST_NR] = {
-	/* buffered IO tests */
-	[0] = { .st_id = { .si_bits = { .u_hi = 1, .u_lo = 2 } },
-		.st_directio = false },
-	[1] = { .st_id = { .si_bits = { .u_hi = 3, .u_lo = 4 } },
-		.st_directio = false },
-	[2] = { .st_id = { .si_bits = { .u_hi = 5, .u_lo = 6 } },
-		.st_directio = false },
-	[3] = { .st_id = { .si_bits = { .u_hi = 7, .u_lo = 8 } },
-		.st_directio = false },
-	[4] = { .st_id = { .si_bits = { .u_hi = 9, .u_lo = 0 } },
-		.st_directio = false },
-
-	/* direct IO tests */
-	[5] = { .st_id = { .si_bits = { .u_hi = 1, .u_lo = 2 } },
-		.st_directio = true },
-	[6] = { .st_id = { .si_bits = { .u_hi = 3, .u_lo = 4 } },
-		.st_directio = true },
-	[7] = { .st_id = { .si_bits = { .u_hi = 5, .u_lo = 6 } },
-		.st_directio = true },
-	[8] = { .st_id = { .si_bits = { .u_hi = 7, .u_lo = 8 } },
-		.st_directio = true },
-	[9] = { .st_id = { .si_bits = { .u_hi = 10, .u_lo = 0 } },
-		.st_directio = true, .st_dev_path="/dev/loop0"  },
+	[0] = { .st_id = { .si_bits = { .u_hi = 1, .u_lo = 2 } } },
+	[1] = { .st_id = { .si_bits = { .u_hi = 3, .u_lo = 4 } } },
+	[2] = { .st_id = { .si_bits = { .u_hi = 5, .u_lo = 6 } } },
+	[3] = { .st_id = { .si_bits = { .u_hi = 7, .u_lo = 8 } } },
+	[4] = { .st_id = { .si_bits = { .u_hi = 9, .u_lo = 0 } } }
 };
 
-/*
- * Assumes that we are dealing with loop-back device /dev/loop0
- * We don't deal with real device in UT.
- */
-static void stob_dev_init(const struct stobio_test *test)
-{
-	struct stat statbuf;
-	int	    result;
-	c2_bcount_t dev_sz;
-	char	    sysbuf[PATH_MAX];
-	char	    backingfile[PATH_MAX];
-
-	result = stat(test->st_dev_path, &statbuf);
-	C2_UT_ASSERT(result == 0);
-
-	if(strcmp(test->st_dev_path, test_blkdev))
-		return;
-
-	/* Device size in KB */
-	dev_sz = MIN_BUFF_SIZE/1024 * MIN_BUFF_SIZE_IN_BLOCKS * RW_BUFF_NR * \
-		 TEST_NR * TEST_NR;
-
-	/* Device size in MB */
-	dev_sz = dev_sz/1024 + 1;
-
-	sprintf(backingfile, "%s/%lu", test->st_dom->sd_name,
-				       test->st_id.si_bits.u_hi);
-	sprintf(sysbuf, "dd if=/dev/zero of=%s bs=1M count=%lu",
-			backingfile, (unsigned long)dev_sz);
-	result = system(sysbuf);
-	C2_UT_ASSERT(result == 0);
-
-	sprintf(sysbuf, "losetup %s %s", test->st_dev_path, backingfile);
-	result = system(sysbuf);
-	C2_UT_ASSERT(result == 0);
-}
-
-static void stob_dev_fini(const struct stobio_test *test)
-{
-	int	    result;
-	char	    sysbuf[PATH_MAX];
-
-	if(test->st_dev_path == NULL)
-		return;
-
-	if(strcmp(test->st_dev_path, test_blkdev))
-		return;
-
-	sprintf(sysbuf, "losetup -d %s", test->st_dev_path);
-	result = system(sysbuf);
-	C2_UT_ASSERT(result == 0);
-}
-
 static void stobio_io_prepare(struct stobio_test *test,
 			      struct c2_stob_io *io)
 {
 	io->si_flags  = 0;
-	io->si_user.ov_vec.v_nr = RW_BUFF_NR;
-	io->si_user.ov_vec.v_count = test->st_wrvec;
+	io->si_user.div_vec.ov_vec.v_nr = RW_BUFF_NR;
+	io->si_user.div_vec.ov_vec.v_count = test->st_wrvec;
 
 	io->si_stob.iv_vec.v_nr = RW_BUFF_NR;
 	io->si_stob.iv_vec.v_count = test->st_wrvec;
@@ -182,7 +92,7 @@ static void stobio_write_prepare(struct stobio_test *test,
 				 struct c2_stob_io *io)
 {
 	io->si_opcode = SIO_WRITE;
-	io->si_user.ov_buf = (void **) test->st_wrbuf_packed;
+	io->si_user.div_vec.ov_buf = (void **) test->st_wrbuf;
 	stobio_io_prepare(test, io);
 }
 
@@ -190,7 +100,7 @@ static void stobio_read_prepare(struct stobio_test *test,
 				struct c2_stob_io *io)
 {
 	io->si_opcode = SIO_READ;
-	io->si_user.ov_buf = (void **) test->st_rdbuf_packed;
+	io->si_user.div_vec.ov_buf = (void **) test->st_rdbuf;
 	stobio_io_prepare(test, io);
 }
 
@@ -213,7 +123,7 @@ static void stobio_write(struct stobio_test *test)
 	c2_chan_wait(&clink);
 
 	C2_UT_ASSERT(io.si_rc == 0);
-	C2_UT_ASSERT(io.si_count == test->st_rw_buf_size_in_blocks * RW_BUFF_NR);
+	C2_UT_ASSERT(io.si_count == (RW_BUFF_COUNT * RW_BUFF_NR));
 
 	c2_clink_del(&clink);
 	c2_clink_fini(&clink);
@@ -239,7 +149,7 @@ static void stobio_read(struct stobio_test *test)
 	c2_chan_wait(&clink);
 
 	C2_UT_ASSERT(io.si_rc == 0);
-	C2_UT_ASSERT(io.si_count == test->st_rw_buf_size_in_blocks * RW_BUFF_NR);
+	C2_UT_ASSERT(io.si_count == (RW_BUFF_COUNT * RW_BUFF_NR));
 
 	c2_clink_del(&clink);
 	c2_clink_fini(&clink);
@@ -252,18 +162,12 @@ static void stobio_rw_buffs_init(struct stobio_test *test)
 	int i;
 
 	for (i = 0; i < ARRAY_SIZE(test->st_rdbuf); ++i) {
-		test->st_rdbuf[i] = c2_alloc_aligned(test->st_rw_buf_size,
-					test->st_block_shift);
-		test->st_rdbuf_packed[i] = c2_stob_addr_pack(test->st_rdbuf[i]
-					, test->st_block_shift);
+		test->st_rdbuf[i] = c2_alloc_aligned(RW_BUFF_COUNT, 0);
 		C2_UT_ASSERT(test->st_rdbuf[i] != NULL);
 	}
 
 	for (i = 0; i < ARRAY_SIZE(test->st_wrbuf); ++i) {
-		test->st_wrbuf[i] = c2_alloc_aligned(test->st_rw_buf_size,
-					test->st_block_shift);
-		test->st_wrbuf_packed[i] = c2_stob_addr_pack(test->st_wrbuf[i],
-					test->st_block_shift);
+		test->st_wrbuf[i] = c2_alloc_aligned(RW_BUFF_COUNT, 0);
 		C2_UT_ASSERT(test->st_wrbuf[i] != NULL);
 	}
 }
@@ -272,15 +176,11 @@ static void stobio_rw_buffs_fini(struct stobio_test *test)
 {
 	int i;
 
-	for (i = 0; i < ARRAY_SIZE(test->st_rdbuf); ++i) {
+	for (i = 0; i < ARRAY_SIZE(test->st_rdbuf); ++i)
 		c2_free(test->st_rdbuf[i]);
-		test->st_rdbuf_packed[i] = 0;
-	}
 
-	for (i = 0; i < ARRAY_SIZE(test->st_wrbuf); ++i) {
+	for (i = 0; i < ARRAY_SIZE(test->st_wrbuf); ++i)
 		c2_free(test->st_wrbuf[i]);
-		test->st_wrbuf_packed[i] = 0;
-	}
 }
 
 static int stobio_storage_init(void)
@@ -302,6 +202,7 @@ static int stobio_storage_init(void)
 static void stobio_storage_fini(void)
 {
 	int result;
+
 	result = system("rm -fr ./__s");
 	C2_UT_ASSERT(result == 0);
 }
@@ -309,64 +210,47 @@ static void stobio_storage_fini(void)
 static int stobio_init(struct stobio_test *test)
 {
 	int result;
-	struct linux_stob *lstob;
+
+	stobio_rw_buffs_init(test);
+
+	/* result = stobio_storage_init(); */
+	/* C2_UT_ASSERT(result == 0); */
 
 	result = linux_stob_type.st_op->
 		sto_domain_locate(&linux_stob_type, "./__s", &test->st_dom);
 	C2_UT_ASSERT(result == 0);
 
-	result = c2_linux_stob_setup(test->st_dom, test->st_directio);
-	C2_UT_ASSERT(result == 0);
-
 	result = test->st_dom->sd_ops->
 		sdo_stob_find(test->st_dom, &test->st_id, &test->st_obj);
 	C2_UT_ASSERT(result == 0);
 	C2_UT_ASSERT(test->st_obj->so_state == CSS_UNKNOWN);
 
-	if(test->st_dev_path != NULL) {
-		stob_dev_init(test);
-		result = c2_linux_stob_link(test->st_dom, test->st_obj,
-					    test->st_dev_path, NULL);
-		C2_UT_ASSERT(result == 0);
-
-	}
-
 	result = c2_stob_create(test->st_obj, NULL);
 	C2_UT_ASSERT(result == 0);
 	C2_UT_ASSERT(test->st_obj->so_state == CSS_EXISTS);
-	lstob = stob2linux(test->st_obj);
-	C2_UT_ASSERT(S_ISREG(lstob->sl_mode) || S_ISBLK(lstob->sl_mode));
 
-	test->st_block_shift = test->st_obj->so_op->sop_block_shift(test->st_obj);
-	test->st_block_size = 1 << test->st_block_shift;
-	/* buf_size is chosen so it would be at least MIN_BUFF_SIZE in bytes
-	 * or it would consist of at least MIN_BUFF_SIZE_IN_BLOCKS blocks */
-	test->st_rw_buf_size = max_check(MIN_BUFF_SIZE,
-			(1 << test->st_block_shift) * MIN_BUFF_SIZE_IN_BLOCKS);
-	test->st_rw_buf_size_in_blocks = test->st_rw_buf_size / test->st_block_size;
-
-	stobio_rw_buffs_init(test);
+	/* c2_stob_put(test->st_obj); */
+	/* c2_stob_get(test->st_obj); */
 
 	return 0;
 }
 
 static void stobio_fini(struct stobio_test *test)
 {
+	/* c2_stob_get(test->st_obj); */
 	c2_stob_put(test->st_obj);
 	test->st_dom->sd_ops->sdo_fini(test->st_dom);
+	/* stobio_storage_fini(); */
 	stobio_rw_buffs_fini(test);
-	stob_dev_fini(test);
-
 }
 
 static void stobio_rwsegs_prepare(struct stobio_test *test, int starts_from)
 {
 	int i;
 	for (i = 0; i < RW_BUFF_NR; ++i) {
-		test->st_wrvec[i] = test->st_rw_buf_size_in_blocks;
-		test->st_rdvec[i] = test->st_rw_buf_size_in_blocks
-					* (2 * i + 1 + starts_from);
-		memset(test->st_wrbuf[i], ('a' + i) | 1, test->st_rw_buf_size);
+		test->st_wrvec[i] = RW_BUFF_COUNT;
+		test->st_rdvec[i] = RW_BUFF_COUNT * (2 * i + 1 + starts_from);
+		memset(test->st_wrbuf[i], ('a' + i) | 1, RW_BUFF_COUNT);
 	}
 }
 
@@ -374,10 +258,9 @@ static void stobio_rwsegs_overlapped_prepare(struct stobio_test *test, int start
 {
 	int i;
 	for (i = 0; i < RW_BUFF_NR; ++i) {
-		test->st_wrvec[i] = test->st_rw_buf_size_in_blocks;
-		test->st_rdvec[i] = test->st_rw_buf_size_in_blocks
-					* (i + 1 + starts_from);
-		memset(test->st_wrbuf[i], ('A' + i) | 1, test->st_rw_buf_size);
+		test->st_wrvec[i] = RW_BUFF_COUNT;
+		test->st_rdvec[i] = RW_BUFF_COUNT * (i + 1 + starts_from);
+		memset(test->st_wrbuf[i], ('A' + i) | 1, RW_BUFF_COUNT);
 	}
 }
 
@@ -419,6 +302,8 @@ void test_stobio(void)
 	int result;
 
 	c2_mutex_init(&lock);
+	/* result = c2_init(); */
+	/* C2_UT_ASSERT(result == 0); */
 
 	result = stobio_storage_init();
 	C2_UT_ASSERT(result == 0);
@@ -440,6 +325,7 @@ void test_stobio(void)
 	stobio_storage_fini();
 
 	c2_mutex_fini(&lock);
+	/* return 0; */
 }
 
 const struct c2_test_suite stobio_ut = {
diff --git a/udb/Makefile.am b/udb/Makefile.am
index 9c7f157..330fda4 100644
--- a/udb/Makefile.am
+++ b/udb/Makefile.am
@@ -1,4 +1,4 @@
-udbdir                        = $(includedir)/colibri/udb
+udbdir                        = $(includedir)/udb
 udb_HEADERS                   = udb.h
 
 noinst_LTLIBRARIES            = libcolibri-udb.la
diff --git a/udb/udb.c b/udb/udb.c
index 4f10b98..fc72a7b 100644
--- a/udb/udb.c
+++ b/udb/udb.c
@@ -13,7 +13,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Huang Hua <Hua_Huang@xyratex.com>
+ * Original author: Huang Hua
  * Original creation date: 01/04/2011
  */
 
diff --git a/udb/udb.h b/udb/udb.h
index bc702fd..e095e31 100644
--- a/udb/udb.h
+++ b/udb/udb.h
@@ -14,7 +14,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Huang Hua <Hua_Huang@xyratex.com>
+ * Original author: Huang Hua
  * Original creation date: 01/04/2011
  */
 
diff --git a/udb/ut/udb_ut.c b/udb/ut/udb_ut.c
index 92af8ef..e701ab2 100644
--- a/udb/ut/udb_ut.c
+++ b/udb/ut/udb_ut.c
@@ -13,7 +13,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Anatoliy Bilenko <Anatoliy_Bilenko@xyratex.com>
+ * Original author: Anatoliy Bilenko
  * Original creation date: 01/24/2011
  */
 
diff --git a/ut/.gitignore b/ut/.gitignore
deleted file mode 100644
index db8f779..0000000
--- a/ut/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-cs_test_fops_u.[hc]
diff --git a/ut/Makefile.am b/ut/Makefile.am
deleted file mode 100644
index 1d3fc65..0000000
--- a/ut/Makefile.am
+++ /dev/null
@@ -1,21 +0,0 @@
-noinst_LTLIBRARIES       = libcolibri-ut.la
-
-INCLUDES                 = -I. -I$(top_srcdir) -I$(top_srcdir)/include
-
-cs_test_fops_u.h cs_test_fops_u.c : cs_test_fops.ff \
-				$(top_builddir)/fop/rt/libc2rt.la \
-				$(top_builddir)/fop/fop2c
-		$(top_builddir)/fop/fop2c -u $<
-
-EXTRA_DIST = cs_test_fops.ff
-
-# libcolibri_ut_la_CFLAGS  = -save-temps
-libcolibri_ut_la_SOURCES = ut.h rpc.h rpc.c \
-			   cs_test_fops_u.h cs_test_fops_u.c \
-			   cs_service.c cs_service.h \
-			   cs_fop_foms.h cs_fop_foms.c \
-			   net.h net.c
-
-clean-local:
-	cd @SRCDIR@/ut ; \
-	rm -f cs_test_fops_u.[ch]
diff --git a/ut/README b/ut/README
deleted file mode 100644
index 7115eb2..0000000
--- a/ut/README
+++ /dev/null
@@ -1,10 +0,0 @@
-The intent of this library is to include all code, which could be potentially
-useful for several UTs and thus can be shared, avoiding duplication of
-similar code.
-
-*** NOTE ***  This library is linked as colibri module and not as colibri -ut
-              library. This allows to use it in both - UTs and in standalone
-              programs which don't use CUnit (and in kernel space as well).
-              That's why it's important to avoid usage of CUnit constructs like
-              C2_UT_ASSERT in this lib.
-
diff --git a/ut/cs_fop_foms.c b/ut/cs_fop_foms.c
deleted file mode 100644
index 33e4de5..0000000
--- a/ut/cs_fop_foms.c
+++ /dev/null
@@ -1,371 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Mandar Sawant <mandar_sawant@xyratex.com>
- * Original creation date: 12/10/2011
- */
-
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif
-
-#include "lib/errno.h"
-#include "lib/assert.h"
-#include "lib/memory.h"
-#include "lib/chan.h"
-
-#include "fop/fop.h"
-#include "reqh/reqh.h"
-#include "fop/fom.h"
-#include "fop/fop_iterator.h"
-
-#include "rpc/rpc2.h"
-#include "rpc/rpclib.h"
-#include "fop/fop_item_type.h"
-#include "xcode/bufvec_xcode.h"
-
-#include "fop/fop_format_def.h"
-
-#include "cs_fop_foms.h"
-#include "cs_test_fops_u.h"
-#include "cs_test_fops.ff"
-#include "rpc/rpc_opcodes.h"
-
-static void cs_ut_rpc_item_reply_cb(struct c2_rpc_item *item);
-
-/*
-  RPC item operations structures.
- */
-const struct c2_rpc_item_ops cs_ds_req_fop_rpc_item_ops = {
-        .rio_replied = cs_ut_rpc_item_reply_cb,
-	.rio_free    = c2_fop_item_free,
-};
-
-/* DS1 service fop type operations.*/
-static const struct c2_fop_type_ops cs_ds1_req_fop_type_ops = {
-        .fto_fop_replied = NULL,
-        .fto_size_get = c2_xcode_fop_size_get,
-        .fto_op_equal = NULL,
-        .fto_get_nfragments = NULL,
-        .fto_io_coalesce = NULL,
-};
-
-static const struct c2_fop_type_ops cs_ds1_rep_fop_type_ops = {
-        .fto_fop_replied = NULL,
-        .fto_size_get = c2_xcode_fop_size_get,
-        .fto_op_equal = NULL,
-        .fto_get_nfragments = NULL,
-        .fto_io_coalesce = NULL,
-};
-
-/* DS2 service fop type operations */
-static const struct c2_fop_type_ops cs_ds2_req_fop_type_ops = {
-        .fto_fop_replied = NULL,
-        .fto_size_get = c2_xcode_fop_size_get,
-        .fto_op_equal = NULL,
-        .fto_get_nfragments = NULL,
-        .fto_io_coalesce = NULL,
-};
-
-static const struct c2_fop_type_ops cs_ds2_rep_fop_type_ops = {
-        .fto_fop_replied = NULL,
-        .fto_size_get = c2_xcode_fop_size_get,
-        .fto_op_equal = NULL,
-        .fto_get_nfragments = NULL,
-        .fto_io_coalesce = NULL,
-};
-
-C2_FOP_TYPE_DECLARE(cs_ds1_req_fop, "ds1 request", &cs_ds1_req_fop_type_ops,
-		    C2_CS_DS1_REQ_OPCODE,
-		    C2_RPC_ITEM_TYPE_REQUEST | C2_RPC_ITEM_TYPE_MUTABO)
-C2_FOP_TYPE_DECLARE(cs_ds1_rep_fop, "ds1 reply", &cs_ds1_rep_fop_type_ops,
-		    C2_CS_DS1_REP_OPCODE, C2_RPC_ITEM_TYPE_REPLY);
-
-C2_FOP_TYPE_DECLARE(cs_ds2_req_fop, "ds2 request", &cs_ds2_req_fop_type_ops,
-		    C2_CS_DS2_REQ_OPCODE,
-		    C2_RPC_ITEM_TYPE_REQUEST | C2_RPC_ITEM_TYPE_MUTABO)
-C2_FOP_TYPE_DECLARE(cs_ds2_rep_fop, "ds2 reply", &cs_ds2_rep_fop_type_ops,
-		    C2_CS_DS2_REP_OPCODE, C2_RPC_ITEM_TYPE_REPLY);
-
-/*
-  Defines ds1 service fop types array.
- */
-static struct c2_fop_type *cs_ds1_fopts[] = {
-        &cs_ds1_req_fop_fopt,
-        &cs_ds1_rep_fop_fopt
-};
-
-/*
-  Defines ds2 service fop types array.
- */
-static struct c2_fop_type *cs_ds2_fopts[] = {
-        &cs_ds2_req_fop_fopt,
-        &cs_ds2_rep_fop_fopt
-};
-
-/*
-  Fom specific routines for corresponding fops.
- */
-static int cs_req_fop_fom_state(struct c2_fom *fom);
-static int cs_ds1_req_fop_fom_create(struct c2_fop *fop, struct c2_fom **out);
-static int cs_ds2_req_fop_fom_create(struct c2_fop *fop, struct c2_fom **out);
-static void cs_ut_fom_fini(struct c2_fom *fom);
-static size_t cs_ut_find_fom_home_locality(const struct c2_fom *fom);
-
-/*
-  Operation structures for ds1 service foms.
- */
-static const struct c2_fom_ops cs_ds1_req_fop_fom_ops = {
-        .fo_fini = cs_ut_fom_fini,
-        .fo_state = cs_req_fop_fom_state,
-        .fo_home_locality = cs_ut_find_fom_home_locality,
-};
-
-/*
-  Operation structures for ds2 service foms.
- */
-static const struct c2_fom_ops cs_ds2_req_fop_fom_ops = {
-        .fo_fini = cs_ut_fom_fini,
-        .fo_state = cs_req_fop_fom_state,
-        .fo_home_locality = cs_ut_find_fom_home_locality,
-};
-
-/*
-  Fom type operations for ds1 service foms.
- */
-static const struct c2_fom_type_ops cs_ds1_req_fop_fom_type_ops = {
-        .fto_create = cs_ds1_req_fop_fom_create,
-};
-
-static struct c2_fom_type cs_ds1_req_fop_fom_mopt = {
-	.ft_ops = &cs_ds1_req_fop_fom_type_ops,
-};
-
-/*
-  Fom type operations for ds2 service foms.
- */
-static const struct c2_fom_type_ops cs_ds2_req_fop_fom_type_ops = {
-        .fto_create = cs_ds2_req_fop_fom_create,
-};
-
-static struct c2_fom_type cs_ds2_req_fop_fom_mopt = {
-	.ft_ops = &cs_ds2_req_fop_fom_type_ops,
-};
-
-static void cs_ut_rpc_item_reply_cb(struct c2_rpc_item *item)
-{
-	struct c2_fop *req_fop;
-	struct c2_fop *rep_fop;
-
-        C2_PRE(item != NULL);
-	C2_PRE(c2_chan_has_waiters(&item->ri_chan));
-
-	req_fop = c2_rpc_item_to_fop(item);
-	rep_fop = c2_rpc_item_to_fop(item->ri_reply);
-
-	C2_ASSERT(req_fop->f_type->ft_rpc_item_type.rit_opcode ==
-		    C2_CS_DS1_REQ_OPCODE ||
-		    req_fop->f_type->ft_rpc_item_type.rit_opcode ==
-		    C2_CS_DS2_REQ_OPCODE);
-
-	C2_ASSERT(rep_fop->f_type->ft_rpc_item_type.rit_opcode ==
-		     C2_CS_DS1_REP_OPCODE ||
-		     rep_fop->f_type->ft_rpc_item_type.rit_opcode ==
-		     C2_CS_DS2_REP_OPCODE);
-}
-
-void c2_cs_ut_ds1_fop_fini(void)
-{
-	int i;
-
-        c2_fop_type_fini_nr(cs_ds1_fopts, ARRAY_SIZE(cs_ds1_fopts));
-
-	for (i = 0; i < ARRAY_SIZE(cs_ds1_fopts); ++i)
-		cs_ds1_fopts[i]->ft_top = NULL;
-}
-
-int c2_cs_ut_ds1_fop_init(void)
-{
-        int result;
-
-        /*
-           As we are finalising and initialising fop types multiple times
-           per service for various colibri_setup commands, So reinitialise
-           fop_type_format for each corresponding service fop types.
-         */
-	cs_ds1_fopts[0]->ft_fmt = &cs_ds1_req_fop_tfmt;
-	cs_ds1_fopts[1]->ft_fmt = &cs_ds1_rep_fop_tfmt;
-	cs_ds1_fopts[0]->ft_fom_type = cs_ds1_req_fop_fom_mopt;
-	cs_ds1_fopts[1]->ft_fom_type = cs_ds1_req_fop_fom_mopt;
-
-        result = c2_fop_type_build_nr(cs_ds1_fopts, ARRAY_SIZE(cs_ds1_fopts));
-        if (result != 0)
-                c2_cs_ut_ds1_fop_fini();
-        return result;
-}
-
-void c2_cs_ut_ds2_fop_fini(void)
-{
-	int i;
-
-        c2_fop_type_fini_nr(cs_ds2_fopts, ARRAY_SIZE(cs_ds2_fopts));
-	for (i = 0; i < ARRAY_SIZE(cs_ds2_fopts); ++i)
-		cs_ds2_fopts[i]->ft_top = NULL;
-}
-
-int c2_cs_ut_ds2_fop_init(void)
-{
-        int result;
-
-	/*
-	   As we are finalising and initialising fop types multiple times
-	   per service for various colibri_setup commands, So reinitialise
-	   fop_type_format for each corresponding service fop types.
-	 */
-	cs_ds2_fopts[0]->ft_fmt = &cs_ds2_req_fop_tfmt;
-	cs_ds2_fopts[1]->ft_fmt = &cs_ds2_rep_fop_tfmt;
-	cs_ds2_fopts[0]->ft_fom_type = cs_ds2_req_fop_fom_mopt;
-	cs_ds2_fopts[1]->ft_fom_type = cs_ds2_req_fop_fom_mopt;
-
-        result = c2_fop_type_build_nr(cs_ds2_fopts, ARRAY_SIZE(cs_ds2_fopts));
-        if (result != 0)
-                c2_cs_ut_ds2_fop_fini();
-        return result;
-}
-
-/*
-  Allocates and initialises a fom.
- */
-static int cs_ds_req_fop_fom_create(struct c2_fop *fop,
-		const struct c2_fom_ops *ops, struct c2_fom **out)
-{
-        struct c2_fom *fom;
-
-	C2_PRE(fop != NULL);
-	C2_PRE(ops != NULL);
-        C2_PRE(out != NULL);
-
-        C2_ALLOC_PTR(fom);
-        if (fom == NULL)
-                return -ENOMEM;
-
-	c2_fom_create(fom, &fop->f_type->ft_fom_type, ops, fop, NULL);
-
-        *out = fom;
-        return 0;
-}
-
-static int cs_ds1_req_fop_fom_create(struct c2_fop *fop, struct c2_fom **out)
-{
-	return cs_ds_req_fop_fom_create(fop, &cs_ds1_req_fop_fom_ops, out);
-}
-
-static int cs_ds2_req_fop_fom_create(struct c2_fop *fop, struct c2_fom **out)
-{
-	return cs_ds_req_fop_fom_create(fop, &cs_ds2_req_fop_fom_ops, out);
-}
-
-/*
-  Finalises a fom.
- */
-static void cs_ut_fom_fini(struct c2_fom *fom)
-{
-	C2_PRE(fom != NULL);
-
-        c2_fom_fini(fom);
-        c2_free(fom);
-}
-
-/*
-  Returns an index value base on fom parameters to locate fom's
-  home locality to execute a fom.
- */
-static size_t cs_ut_find_fom_home_locality(const struct c2_fom *fom)
-{
-	C2_PRE(fom != NULL);
-
-	return fom->fo_fop->f_type->ft_rpc_item_type.rit_opcode;
-}
-
-/*
-  Transitions fom through its generic phases and also
-  performs corresponding fop specific execution.
- */
-static int cs_req_fop_fom_state(struct c2_fom *fom)
-{
-	int                    rc;
-	struct c2_fop         *rfop;
-	struct cs_ds1_req_fop *ds1_reqfop;
-	struct cs_ds1_rep_fop *ds1_repfop;
-	struct cs_ds2_req_fop *ds2_reqfop;
-	struct cs_ds2_rep_fop *ds2_repfop;
-	uint64_t               opcode;
-
-	C2_PRE(fom->fo_fop->f_type->ft_rpc_item_type.rit_opcode ==
-	       C2_CS_DS1_REQ_OPCODE ||
-	       fom->fo_fop->f_type->ft_rpc_item_type.rit_opcode ==
-	       C2_CS_DS2_REQ_OPCODE);
-
-	if (fom->fo_phase < FOPH_NR) {
-		rc = c2_fom_state_generic(fom);
-	} else {
-		opcode = fom->fo_fop->f_type->ft_rpc_item_type.rit_opcode;
-		switch (opcode) {
-		case C2_CS_DS1_REQ_OPCODE:
-			rfop = c2_fop_alloc(&cs_ds1_rep_fop_fopt, NULL);
-			if (rfop == NULL) {
-				fom->fo_phase = FOPH_FINISH;
-				return FSO_WAIT;
-			}
-			ds1_reqfop = c2_fop_data(fom->fo_fop);
-			ds1_repfop = c2_fop_data(rfop);
-			ds1_repfop->csr_rc = ds1_reqfop->csr_value;
-			fom->fo_rep_fop = rfop;
-			fom->fo_rc = 0;
-			fom->fo_phase = FOPH_SUCCESS;
-			rc = FSO_AGAIN;
-			break;
-		case C2_CS_DS2_REQ_OPCODE:
-			rfop = c2_fop_alloc(&cs_ds2_rep_fop_fopt, NULL);
-			if (rfop == NULL) {
-				fom->fo_phase = FOPH_FINISH;
-				return FSO_WAIT;
-			}
-			ds2_reqfop = c2_fop_data(fom->fo_fop);
-			ds2_repfop = c2_fop_data(rfop);
-			ds2_repfop->csr_rc = ds2_reqfop->csr_value;
-			fom->fo_rep_fop = rfop;
-			fom->fo_rc = 0;
-			fom->fo_phase = FOPH_SUCCESS;
-			rc = FSO_AGAIN;
-			break;
-		default:
-			 C2_ASSERT("Invalid fop" == 0);
-		}
-	}
-
-	return rc;
-}
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
diff --git a/ut/cs_fop_foms.h b/ut/cs_fop_foms.h
deleted file mode 100644
index 7481584..0000000
--- a/ut/cs_fop_foms.h
+++ /dev/null
@@ -1,74 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Mandar Sawant <mandar_sawant@xyratex.com>
- * Original creation date: 25/10/2011
- */
-
-#ifndef __COLIBRI_COLIBRI_UT_CS_UT_FOP_FOMS_H__
-#define __COLIBRI_COLIBRI_UT_CS_UT_FOP_FOMS_H__
-
-extern struct c2_fop_type cs_ds1_req_fop_fopt;
-extern struct c2_fop_type cs_ds1_rep_fop_fopt;
-extern struct c2_fop_type cs_ds2_req_fop_fopt;
-extern struct c2_fop_type cs_ds2_rep_fop_fopt;
-
-extern const struct c2_rpc_item_ops cs_ds_req_fop_rpc_item_ops;
-
-/*
-  Supported service types.
- */
-enum {
-        CS_UT_SERVICE1 = 1,
-        CS_UT_SERVICE2,
-};
-
-/*
-  Builds ds1 service fop types.
-  Invoked from service specific stop function.
- */
-int c2_cs_ut_ds1_fop_init(void);
-
-/*
-  Finalises ds1 service fop types.
-  Invoked from service specific startup function.
- */
-void c2_cs_ut_ds1_fop_fini(void);
-
-/*
-  Builds ds1 service fop types.
-  Invoked from service specific stop function.
- */
-int c2_cs_ut_ds2_fop_init(void);
-
-/*
-  Finalises ds1 service fop types.
-  Invoked from service specific startup function.
- */
-void c2_cs_ut_ds2_fop_fini(void);
-
-/* __COLIBRI_COLIBRI_UT_CS_UT_FOP_FOMS_H__ */
-#endif
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
diff --git a/ut/cs_service.c b/ut/cs_service.c
deleted file mode 100644
index ed7fe33..0000000
--- a/ut/cs_service.c
+++ /dev/null
@@ -1,167 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Mandar Sawant <mandar_sawant@xyratex.com>
- * Original creation date: 12/10/2011
- */
-
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif
-
-#include "lib/errno.h"
-#include "lib/memory.h"
-
-#include "reqh/reqh_service.h"
-#include "colibri/colibri_setup.h"
-
-#include "ut/cs_fop_foms.h"
-
-static int ds1_service_start(struct c2_reqh_service *service);
-static int ds2_service_start(struct c2_reqh_service *service);
-static void ds1_service_stop(struct c2_reqh_service *service);
-static void ds2_service_stop(struct c2_reqh_service *service);
-static int ds1_service_alloc_init(struct c2_reqh_service_type *stype,
-                                     struct c2_reqh_service **service);
-static int ds2_service_alloc_init(struct c2_reqh_service_type *stype,
-                                     struct c2_reqh_service **service);
-static void ds_service_fini(struct c2_reqh_service *service);
-
-static const struct c2_reqh_service_type_ops ds1_service_type_ops = {
-        .rsto_service_alloc_and_init = ds1_service_alloc_init
-};
-
-static const struct c2_reqh_service_type_ops ds2_service_type_ops = {
-        .rsto_service_alloc_and_init = ds2_service_alloc_init
-};
-
-static const struct c2_reqh_service_ops ds1_service_ops = {
-        .rso_start = ds1_service_start,
-        .rso_stop = ds1_service_stop,
-        .rso_fini = ds_service_fini
-};
-
-static const struct c2_reqh_service_ops ds2_service_ops = {
-        .rso_start = ds2_service_start,
-        .rso_stop = ds2_service_stop,
-        .rso_fini = ds_service_fini
-};
-
-C2_REQH_SERVICE_TYPE_DECLARE(ds1_service_type, &ds1_service_type_ops, "ds1");
-C2_REQH_SERVICE_TYPE_DECLARE(ds2_service_type, &ds2_service_type_ops, "ds2");
-
-struct c2_reqh_service_type *cs_default_stypes[] = {
-	&ds1_service_type,
-	&ds2_service_type,
-};
-size_t cs_default_stypes_nr = ARRAY_SIZE(cs_default_stypes);
-
-static int ds1_service_alloc_init(struct c2_reqh_service_type *stype,
-                                     struct c2_reqh_service **service)
-{
-        struct c2_reqh_service      *serv;
-
-        C2_PRE(stype != NULL && service != NULL);
-
-        C2_ALLOC_PTR(serv);
-        if (serv == NULL)
-                return -ENOMEM;
-
-        serv->rs_type = stype;
-        serv->rs_ops = &ds1_service_ops;
-	*service = serv;
-
-        return 0;
-}
-
-static int ds2_service_alloc_init(struct c2_reqh_service_type *stype,
-                                     struct c2_reqh_service **service)
-{
-        struct c2_reqh_service      *serv;
-
-        C2_PRE(stype != NULL && service != NULL);
-
-        C2_ALLOC_PTR(serv);
-        if (serv == NULL)
-                return -ENOMEM;
-
-        serv->rs_type = stype;
-        serv->rs_ops = &ds2_service_ops;
-        *service = serv;
-
-        return 0;
-}
-
-static int ds1_service_start(struct c2_reqh_service *service)
-{
-	int rc;
-
-        C2_PRE(service != NULL);
-
-        /*Initialise service fops.*/
-	rc = c2_cs_ut_ds1_fop_init();
-	C2_ASSERT(rc == 0);
-
-        return rc;
-}
-
-static int ds2_service_start(struct c2_reqh_service *service)
-{
-        int rc;
-
-        C2_PRE(service != NULL);
-
-        /*Initialise service fops.*/
-        rc = c2_cs_ut_ds2_fop_init();
-	C2_ASSERT(rc == 0);
-
-        return rc;
-}
-
-static void ds1_service_stop(struct c2_reqh_service *service)
-{
-
-        C2_PRE(service != NULL);
-
-	/* Finalise service fops */
-	c2_cs_ut_ds1_fop_fini();
-}
-
-static void ds2_service_stop(struct c2_reqh_service *service)
-{
-
-        C2_PRE(service != NULL);
-
-        /* Finalise service fops */
-        c2_cs_ut_ds2_fop_fini();
-}
-
-static void ds_service_fini(struct c2_reqh_service *service)
-{
-	C2_PRE(service != NULL);
-
-        c2_free(service);
-}
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
diff --git a/ut/cs_service.h b/ut/cs_service.h
deleted file mode 100644
index 73885c1..0000000
--- a/ut/cs_service.h
+++ /dev/null
@@ -1,30 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Dmitriy Chumak <dmitriy_chumak@xyratex.com>
- * Original creation date: 12/06/2011
- */
-
-#ifndef __COLIBRI_UT_CS_SERVICE_H__
-#define __COLIBRI_UT_CS_SERVICE_H__
-
-extern struct c2_reqh_service_type ds1_service_type;
-extern struct c2_reqh_service_type ds2_service_type;
-
-extern struct c2_reqh_service_type *cs_default_stypes[];
-extern size_t cs_default_stypes_nr;
-
-#endif /* __COLIBRI_UT_CS_SERVICE_H__ */
diff --git a/ut/cs_test_fops.ff b/ut/cs_test_fops.ff
deleted file mode 100644
index faf22da..0000000
--- a/ut/cs_test_fops.ff
+++ /dev/null
@@ -1,45 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Mandar Sawant <Mandar_Sawant@xyratex.com>
- * Original creation date: 13/10/2011
- */
-
-/*
-  Dummy fops to test colibri setup
- */
-
-DEF(cs_ds1_req_fop, RECORD,
-        _(csr_value, U32));
-
-DEF(cs_ds1_rep_fop, RECORD,
-        _(csr_rc, U32));
-
-DEF(cs_ds2_req_fop, RECORD,
-        _(csr_value, U32));
-
-DEF(cs_ds2_rep_fop, RECORD,
-        _(csr_rc, U32));
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
diff --git a/ut/linux_kernel/.gitignore b/ut/linux_kernel/.gitignore
deleted file mode 100644
index a388d37..0000000
--- a/ut/linux_kernel/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-rpc.c
diff --git a/ut/linux_kernel/Makefile.in b/ut/linux_kernel/Makefile.in
deleted file mode 100644
index 0dfb389..0000000
--- a/ut/linux_kernel/Makefile.in
+++ /dev/null
@@ -1,22 +0,0 @@
-UT_SRCDIR = @SRCDIR@/ut/linux_kernel
-
-GCOV_PROFILE := @K_ENABLE_COVERAGE@
-
-obj-y		:= kut.o
-shared_src	:= rpc.c
-kernel_src	:=
-kut-y		:= $(shared_src:.c=.o) $(kernel_src:.c=.o)
-orig		:= $(shared_src:%=../%)
-
-EXTRA_CFLAGS = -DHAVE_CONFIG_H -I@SRCDIR@ @KCFLAGS@
-
-prepare:
-	ln -fs $(orig) .
-
-clean distclean:
-	$(RM) $(shared_src) Module.markers Module.symvers modules.order
-	$(MAKE) -C @LINUX_OBJ@ M=`pwd` clean
-
-distdir:
-	cp $(UT_SRCDIR)/Makefile.in $(UT_SRCDIR)/cob_kernel.c \
-	    @top_builddir@/@PACKAGE@-@VERSION@/ut/linux_kernel
diff --git a/ut/net.c b/ut/net.c
deleted file mode 100644
index 1a2d5e0..0000000
--- a/ut/net.c
+++ /dev/null
@@ -1,87 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Carl Braganza <Carl_Braganza@us.xyratex.com>,
- *                  Dave Cohrs <Dave_Cohrs@us.xyratex.com>
- * Original creation date: 04/12/2011
- */
-
-#include <errno.h>      /* ENOENT */
-#include <sys/socket.h>
-#include <netinet/in.h>
-#include <arpa/inet.h>  /* inet_aton */
-#include <netdb.h>      /* gethostbyname_r */
-#include <stdio.h>      /* fprintf */
-#include <string.h>     /* strlen */
-
-#include "ut/net.h"
-
-int canon_host(const char *hostname, char *buf, size_t bufsiz)
-{
-	int                i;
-	int		   rc = 0;
-	struct in_addr     ipaddr;
-
-	/* c2_net_end_point_create requires string IPv4 address, not name */
-	if (inet_aton(hostname, &ipaddr) == 0) {
-		struct hostent he;
-		char he_buf[4096];
-		struct hostent *hp;
-		int herrno;
-
-		rc = gethostbyname_r(hostname, &he, he_buf, sizeof he_buf,
-				     &hp, &herrno);
-		if (rc != 0) {
-			fprintf(stderr, "Can't get address for %s\n",
-				hostname);
-			return -ENOENT;
-		}
-		for (i = 0; hp->h_addr_list[i] != NULL; ++i)
-			/* take 1st IPv4 address found */
-			if (hp->h_addrtype == AF_INET &&
-			    hp->h_length == sizeof(ipaddr))
-				break;
-		if (hp->h_addr_list[i] == NULL) {
-			fprintf(stderr, "No IPv4 address for %s\n",
-				hostname);
-			return -EPFNOSUPPORT;
-		}
-		if (inet_ntop(hp->h_addrtype, hp->h_addr, buf, bufsiz) ==
-		    NULL) {
-			fprintf(stderr, "Cannot parse network address for %s\n",
-				hostname);
-			rc = -errno;
-		}
-	} else {
-		if (strlen(hostname) >= bufsiz) {
-			fprintf(stderr, "Buffer size too small for %s\n",
-				hostname);
-			return -ENOSPC;
-		}
-		strcpy(buf, hostname);
-	}
-	return rc;
-}
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
diff --git a/ut/net.h b/ut/net.h
deleted file mode 100644
index 3094073..0000000
--- a/ut/net.h
+++ /dev/null
@@ -1,30 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Dmitriy Chumak <dmitriy_chumak@xyratex.com>
- * Original creation date: 12/22/2011
- */
-
-#ifndef __COLIBRI_UT_NET_H__
-#define __COLIBRI_UT_NET_H__
-
-/**
-   Resolve hostname into a dotted quad.  The result is stored in buf.
- */
-int canon_host(const char *hostname, char *buf, size_t bufsiz);
-
-#endif /* __COLIBRI_UT_NET_H__ */
-
diff --git a/ut/rpc.c b/ut/rpc.c
deleted file mode 100644
index 2e20cd5..0000000
--- a/ut/rpc.c
+++ /dev/null
@@ -1,108 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Dmitriy Chumak <dmitriy_chumak@xyratex.com>
- * Original creation date: 11/23/2011
- */
-
-
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif
-
-#include "lib/cdefs.h"
-#include "lib/types.h"
-#include "lib/memory.h"
-#include "lib/assert.h"
-#include "rpc/rpc2.h"
-#include "net/net.h"
-#include "fop/fop.h"
-#include "reqh/reqh.h"
-
-#include "rpc/rpclib.h"
-
-
-static int init_cob(struct c2_rpc_client_ctx *cctx)
-{
-	int rc;
-	struct c2_cob_domain_id   cob_dom_id = { .id = cctx->rcx_cob_dom_id };
-
-	rc = c2_dbenv_init(cctx->rcx_dbenv, cctx->rcx_db_name, 0);
-	if (rc != 0)
-		return rc;
-
-	rc = c2_cob_domain_init(cctx->rcx_cob_dom, cctx->rcx_dbenv, &cob_dom_id);
-	if (rc != 0)
-		goto dbenv_fini;
-
-	return rc;
-
-dbenv_fini:
-	c2_dbenv_fini(cctx->rcx_dbenv);
-	C2_ASSERT(rc != 0);
-	return rc;
-}
-
-static void fini_cob(struct c2_rpc_client_ctx *cctx)
-{
-	c2_cob_domain_fini(cctx->rcx_cob_dom);
-	c2_dbenv_fini(cctx->rcx_dbenv);
-
-	return;
-}
-
-int c2_rpc_client_init(struct c2_rpc_client_ctx *cctx)
-{
-	int rc;
-
-	rc = init_cob(cctx);
-	if (rc != 0)
-		goto fini_cob;
-
-	rc = c2_rpc_client_start(cctx);
-
-	return rc;
-
-fini_cob:
-	fini_cob(cctx);
-	C2_ASSERT(rc != 0);
-	return rc;
-}
-C2_EXPORTED(c2_rpc_client_init);
-
-int c2_rpc_client_fini(struct c2_rpc_client_ctx *cctx)
-{
-	int rc;
-
-	rc = c2_rpc_client_stop(cctx);
-	if (rc != 0)
-		return rc;
-
-	fini_cob(cctx);
-
-	return rc;
-}
-C2_EXPORTED(c2_rpc_client_fini);
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
diff --git a/ut/rpc.h b/ut/rpc.h
deleted file mode 100644
index 45cc1fa..0000000
--- a/ut/rpc.h
+++ /dev/null
@@ -1,65 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Dmitriy Chumak <dmitriy_chumak@xyratex.com>
- * Original creation date: 11/23/2011
- */
-
-#ifndef __COLIBRI_UT_RPC_H__
-#define __COLIBRI_UT_RPC_H__
-
-#include "ut/cs_service.h" /* cs_default_stypes */
-#include "rpc/rpclib.h"    /* c2_rpc_server_ctx */
-
-#ifndef __KERNEL__
-#define C2_RPC_SERVER_CTX_DECLARE(name, xprts, xprts_nr, server_argv,		\
-				  server_argc, log_file_name)			\
-	struct c2_rpc_server_ctx (name) = {					\
-		.rsx_xprts            = (xprts),				\
-		.rsx_xprts_nr         = (xprts_nr),				\
-		.rsx_argv             = (server_argv),				\
-		.rsx_argc             = (server_argc),				\
-		.rsx_service_types    = cs_default_stypes,			\
-		.rsx_service_types_nr = cs_default_stypes_nr,			\
-		.rsx_log_file_name    = (log_file_name),			\
-	};
-
-#define C2_RPC_SERVER_CTX_DECLARE_SIMPLE(name, xprt_ptr, server_argv,		\
-					 log_file_name)				\
-	C2_RPC_SERVER_CTX_DECLARE((name), &(xprt_ptr), 1, (server_argv),	\
-				  ARRAY_SIZE((server_argv)), (log_file_name))
-#endif
-
-struct c2_rpc_client_ctx;
-
-/**
-  A wrapper around c2_rpc_client_start(). It initializes dbenv and cob_domain
-  withing c2_rpc_client_ctx structure, and then calls c2_rpc_client_start().
-
-  @param rctx  Initialized rpc context structure.
-*/
-int c2_rpc_client_init(struct c2_rpc_client_ctx *ctx);
-
-/**
-  A wrapper around c2_rpc_client_stop(). It finalizes dbenv and cob_domain
-  withing c2_rpc_client_ctx structure, and then calls c2_rpc_client_stop().
-
-  @param rctx  Initialized rpc context structure.
-*/
-int c2_rpc_client_fini(struct c2_rpc_client_ctx *ctx);
-
-#endif /* __COLIBRI_UT_RPC_H__ */
-
diff --git a/ut/ut.h b/ut/ut.h
deleted file mode 100644
index 577442b..0000000
--- a/ut/ut.h
+++ /dev/null
@@ -1,51 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Dmitriy Chumak <dmitriy_chumak@xyratex.com>
- * Original creation date: 11/23/2011
- */
-
-#ifndef __COLIBRI_UT_UT_H__
-#define __COLIBRI_UT_UT_H__
-
-/**
-   @defgroup colibri-ut Colibri UT library
-   @brief Common unit test library
-
-   The intent of this library is to include all code, which could be potentially
-   useful for several UTs and thus can be shared, avoiding duplication of
-   similar code.
-
-   This library is linked as colibri module and not as colibri -ut library. This
-   allows to use it in both - UTs and in standalone programs which don't use CUnit.
-
-   Purpose of this header file is to include all other headers under ut/
-
-   @{
-*/
-
-#include "ut/rpc.h"
-#include "ut/net.h"
-#include "ut/cs_fop_foms.h"
-#include "ut/cs_service.h"
-#include "ut/cs_test_fops_u.h"
-
-/**
-   @} colibri-ut end group
-*/
-
-#endif /* __COLIBRI_UT_UT_H__ */
-
diff --git a/utils/Makefile.am b/utils/Makefile.am
index 07c8afe..aab27ea 100644
--- a/utils/Makefile.am
+++ b/utils/Makefile.am
@@ -1,22 +1,24 @@
 SUBDIRS      = ploss
 
+if HAVE_CUNIT_SUPPORT
+libstob_ut   = $(top_builddir)/stob/ut/libstob-ut.la
+noinst_PROGRAMS = ut ub
+else
+noinst_PROGRAMS =
+endif
+
 sbin_PROGRAMS   = mkfs.colibri
 
 mkfs_colibri_SOURCES   = mkfs.colibri.c
 mkfs_colibri_LDFLAGS   = -pthread
 mkfs_colibri_LDADD     = $(top_builddir)/colibri/libcolibri.la
 
-noinst_PROGRAMS = ut ub
-
-libstob_ut   = $(top_builddir)/stob/ut/libstob-ut.la
-
 ut_SOURCES   = ut_main.c common.c common.h
 ut_LDFLAGS   = -pthread
 ut_LDADD     = $(top_builddir)/colibri/libcolibri.la \
                $(top_builddir)/lib/ut/libc2-ut.la $(libstob_ut) \
                $(top_builddir)/cob/ut/libcob-ut.la     \
                $(top_builddir)/db/ut/libdb-ut.la     \
-               $(top_builddir)/console/ut/libconsole-ut.la     \
                $(top_builddir)/fol/ut/libfol-ut.la   \
                $(top_builddir)/fop/ut/libfop-ut.la   \
                $(top_builddir)/sns/ut/libparity-ut.la \
@@ -24,23 +26,17 @@ ut_LDADD     = $(top_builddir)/colibri/libcolibri.la \
                $(top_builddir)/net/bulk_emulation/ut/libnet-bulkem-ut.la \
                $(top_builddir)/udb/ut/libudb-ut.la \
                $(top_builddir)/capa/ut/libcapa-ut.la \
-               $(top_builddir)/sm/ut/libsm-ut.la \
-               $(top_builddir)/xcode/ut/libxcode-ut.la \
-               $(top_builddir)/reqh/ut/libreqh-ut.la \
-               $(top_builddir)/rpc/ut/libonwire-ut.la \
-               $(top_builddir)/colibri/ut/libcs-ut.la \
-               $(top_builddir)/rpc/ut/librpclib-ut.la \
-               $(top_builddir)/ioservice/ut/libcfm-ut.la \
-               $(top_builddir)/yaml2db/ut/libyaml2db-ut.la \
-	       $(top_builddir)/balloc/ut/libballoc-ut.la
+               $(top_builddir)/mdstore/ut/libmdstore-ut.la \
+	       $(top_builddir)/xdr/ut/libxdr-ut.la
 
-ub_SOURCES   = ub_main.c common.c common.h
+
+ub_SOURCES   = ub_main.c common.c common.h 
 ub_LDFLAGS   = -pthread
 ub_LDADD     = $(top_builddir)/colibri/libcolibri.la \
                $(top_builddir)/lib/ut/libc2-ut.la $(libstob_ut) \
                $(top_builddir)/db/ut/libdb-ut.la     \
                $(top_builddir)/cob/ut/libcob-ut.la     \
                $(top_builddir)/fol/ut/libfol-ut.la   \
-               $(top_builddir)/sns/ut/libparity-ut.la
+               $(top_builddir)/sns/ut/libparity-ut.la \
+	       $(top_builddir)/xdr/ut/libxdr-ut.la
 
-EXTRA_DIST   = linux_kernel/main.c linux_kernel/ut.sh
diff --git a/utils/branchmeter.sh b/utils/branchmeter.sh
deleted file mode 100755
index ecbff1e..0000000
--- a/utils/branchmeter.sh
+++ /dev/null
@@ -1,88 +0,0 @@
-#!/bin/bash
-#
-# Print information about the branch
-#
-usage()
-{
-	echo "Usage: $(basename $0) [options]"
-	echo "Options:"
-	echo "    -h|--help       -- print this help message"
-	echo "    -c|--current    -- show information for current branch only"
-}
-
-print_branch_skew()
-{
-	#
-	# Get the last component in the path
-	#
-	name=`basename $1`
-
-	#
-	# Determine how ahead is master
-	#
-	commit_lag=`git rev-list ${1}..origin/master | wc -l`
-
-	#
-	# Check last merge date to/from master
-	#
-	last_merge=`git log -1 --merges --grep='Merge.*master' --pretty=short --format="%H %ai" origin/master..${1} |  awk '{print $2}'`
-
-	comment=''
-
-	if [ "$last_merge" == "" ]; then
-		#
-		# If there are no merges, check the date of the first commit in branch which is not included in master
-		#
-		last_merge=`git log --pretty=short --format="%H %ai" origin/master..${1} | tail -1 | awk '{ print $2}'`
-
-		if [ "$last_merge" == "" ]; then
-			#
-			# It means that branch doesn't have any specific commits and fully merged into master
-			#
-			last_merge=`git log -1 --pretty=short --format="%H %ai" ${1} | awk '{ print $2}'`
-			comment="(in master)"
-		fi
-	fi
-
-	#
-	# Print branch information.
-	#
-	printf "%-30s\t%6d\t\t%s %s\n" $name $commit_lag $last_merge "$comment"
-}
-
-
-###########
-# Main
-###########
-
-current_branch_only=false
-
-case $1 in
-	-h|--help) usage; exit 1 ;;
-	-c|--current) current_branch_only=true ;;
-esac
-
-#
-# Check if the CWD is a work dir for a git repository.
-#
-if ! git rev-parse --git-dir &> /dev/null ; then
-	echo "This is not a working dir for git repository"
-	exit 1
-fi
-
-#
-# Get list of branches
-#
-if $current_branch_only; then
-	branch_list=`git name-rev --name-only HEAD`
-else
-	branch_list=`git branch -r | grep -v master`
-fi
-printf "Branch Name \t Commits behind master \t    Last merge (or branch) date\n"
-
-#
-# Print required information for each branch
-#
-for branch in $branch_list; do
-	print_branch_skew $branch
-done
diff --git a/utils/common.c b/utils/common.c
index d66a4f1..d8cf98c 100644
--- a/utils/common.c
+++ b/utils/common.c
@@ -14,7 +14,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Nikita Danilov <Nikita_Danilov@xyratex.com>
+ * Original author: Nikita Danilov
  * Original creation date: 08/19/2010
  */
 
@@ -23,7 +23,6 @@
 #include <sys/stat.h> /* mkdir */
 #include <unistd.h>   /* chdir */
 #include <errno.h>
-#include <stdbool.h>  /* bool */
 
 #include "colibri/init.h"
 #include "lib/assert.h"
@@ -69,7 +68,7 @@ int unit_start(const char *sandbox)
 	return result;
 }
 
-void unit_end(const char *sandbox, bool keep_sandbox)
+void unit_end(const char *sandbox)
 {
 	int rc;
 
@@ -78,8 +77,7 @@ void unit_end(const char *sandbox, bool keep_sandbox)
 	rc = chdir("..");
 	C2_ASSERT(rc == 0);
 
-        if (!keep_sandbox)
-                reset_sandbox(sandbox);
+	reset_sandbox(sandbox);
 }
 
 /*
diff --git a/utils/common.h b/utils/common.h
index ea2c9e0..ecf292e 100644
--- a/utils/common.h
+++ b/utils/common.h
@@ -14,7 +14,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Nikita Danilov <Nikita_Danilov@xyratex.com>
+ * Original author: Nikita Danilov
  * Original creation date: 08/19/2010
  */
 
@@ -22,7 +22,7 @@
 #define __COLIBRI_UTILS_COMMON_H__
 
 int  unit_start(const char *sandbox);
-void unit_end(const char *sandbox, bool keep_sandbox);
+void unit_end  (const char *sandbox);
 
 /* __COLIBRI_UTILS_COMMON_H__ */
 #endif
diff --git a/utils/gcov_stats_genhtml.sh b/utils/gcov_stats_genhtml.sh
deleted file mode 100755
index 7327413..0000000
--- a/utils/gcov_stats_genhtml.sh
+++ /dev/null
@@ -1,131 +0,0 @@
-#!/bin/bash
-
-#
-# When colibri is configured with --enable-coverage option, it
-# builds colibri (both user and kernel space) with gcov profiling
-# options enabled.
-#
-# When such binaries are executed or kernel modules are exercised,
-# trace data is recorded in .gcda files.
-#
-# This script, collects gcda files from location dependent on user or
-# kernel mode, and runs lcov on it. As output, lcov will create
-# HTML file hierarchy in <output_dir>
-#
-
-if [ $# -ne 3 ]
-then
-	echo "Usage: gcov_stats_genhtml.sh [user|kernel] <src_dir> <output_dir>"
-	echo "       <src_dir>:    path of colibri/core directory"
-	echo "       <output_dir>: path where output of lcov will be stored"
-	exit 1
-fi
-
-mode=$1
-src=$2
-outdir=$3
-
-if [ x$mode != xuser -a x$mode != xkernel ]
-then
-	echo "Error: First arg must be either \"user\" or \"kernel\""
-	exit 1
-fi
-
-if [ ! -d $src ]
-then
-	echo "Error: Either $src does not exists or is not a directory"
-	exit 1
-fi
-
-if [ `basename $src` != "core" ]
-then
-	echo "Error: baseame of <src_dir> must be \"core\""
-	exit 1
-fi
-
-if [ ! -d $outdir ]
-then
-	echo "Creating $outdir..."
-	mkdir -p $outdir
-fi
-#
-# Following line must be commented in /usr/bin/geninfo
-#
-# push(@gcov_options, "-a") if ($gcov_caps->{'all-blocks'});
-#
-# This line from /usr/bin/geninfo causes gcov to hang while
-# processing some .gcda files.
-# http://gcc.gnu.org/bugzilla/show_bug.cgi?id=48361
-#
-# Make sure that it is really commented
-#
-line=`cat /usr/bin/geninfo | grep "all-blocks"`
-if [ $? -eq 0 ]   # Found a line that contains string "all-blocks"
-then
-	echo $line | egrep "^\s*#" > /dev/null
-	if [ $? -ne 0 ] # $line does not start with '#'
-	then
-		echo "Error: Comment following line from /usr/bin/geninfo and retry"
-		cat << EOF
-		push(@gcov_options, "-a") if ($gcov_caps->{'all-blocks'});
-EOF
-		exit 1
-	fi
-fi
-saved_pwd=`pwd`
-cd $outdir
-
-if [ $mode = "user" ]
-then
-	gcda_cnt=`find $src -name "*.gcda" | wc -l`
-	if [ $gcda_cnt -eq 0 ]
-	then
-		echo "No *.gcda file is present in $src and its subdirectoris"
-		exit 1
-	fi
-	echo "Collecting user mode stats"
-	lcov --directory $src --capture --output-file app.info
-	if [ -e app.info ]
-	then
-		genhtml app.info
-	fi
-else
-	mount | grep "/sys/kernel/debug" > /dev/null
-	if [ $? -ne 0 ]
-	then
-		echo "Error: debugfs is not mounted on /sys/kernel/debug"
-		echo "       Use 'mount -t debugfs none /sys/kernel/debug' to mount debugfs"
-		exit 1
-	fi
-
-	GCDA=/sys/kernel/debug/gcov
-	if [ ! -d $GCDA ]
-	then
-		echo "Error: running kernel is not compiled with CONFIG_GCOV_KERNEL=y option"
-		exit 1
-	fi
-
-	TEMPDIR=$(mktemp -d)
-	find $GCDA -type d -exec mkdir -p $TEMPDIR/\{\} \;
-	find $GCDA -name '*.gcda' -exec sh -c 'cat < $0 > '$TEMPDIR'/$0' {} \;
-	find $GCDA -name '*.gcno' -exec sh -c 'cp -d $0 '$TEMPDIR'/$0' {} \;
-
-	gcda_cnt=`find $TEMPDIR -name "*.gcda" | wc -l`
-	if [ $gcda_cnt -eq 0 ]
-	then
-		echo "No *.gcda file is present in /sys/kernel/debug/gcov and its subdirectoris"
-		rm -rf $TEMPDIR
-		exit 1
-	fi
-
-	echo "Collecting kernel mode stats"
-	lcov --directory $TEMPDIR --capture --output-file app.info
-	lcov --remove app.info "*.h" -o app1.info
-	genhtml app1.info
-	if [ $? -eq 0 ]
-	then
-		echo "lcov output saved at $outdir"
-	fi
-	rm -rf $TEMPDIR
-fi
-cd $saved_pwd
diff --git a/utils/linux_kernel/Makefile.in b/utils/linux_kernel/Makefile.in
index fd0fb77..e046125 100644
--- a/utils/linux_kernel/Makefile.in
+++ b/utils/linux_kernel/Makefile.in
@@ -1,11 +1,21 @@
 KUTC2_SRCDIR = @SRCDIR@/utils/linux_kernel
 
 obj-m       := kutc2.o
-kutc2-y     := main.o
+orig_ut     := ../../lib/ut/bitmap.c ../../lib/ut/chan.c \
+               ../../lib/ut/rwlock.c ../../lib/ut/thread.c
+shared_ut   := $(notdir $(orig_ut))
+kutc2-y     := main.o $(shared_ut:.c=.o)
 
 EXTRA_CFLAGS = -DHAVE_CONFIG_H -I@SRCDIR@ @KCFLAGS@
 
 prepare:
+	ln -fs $(orig_ut) .
+
+install modules_install:
+	$(MAKE) INSTALL_MOD_DIR=kernel/fs/utc2 -C @LINUX_OBJ@ M=`pwd` modules_install
+
+uninstall:
+	rm -fr @LINUX_MOD@/kernel/fs/utc2
 
 distclean clean:
 	$(RM) $(shared_ut) Module.markers Module.symvers modules.order
diff --git a/utils/linux_kernel/main.c b/utils/linux_kernel/main.c
index 4cb951f..b879aa8 100644
--- a/utils/linux_kernel/main.c
+++ b/utils/linux_kernel/main.c
@@ -13,7 +13,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Dave Cohrs <Dave_Cohrs@us.xyratex.com>
+ * Original author: Dave Cohrs
  * Original creation date: 04/12/2011
  */
 
@@ -22,59 +22,55 @@
 #include <linux/init.h>
 
 #include "lib/assert.h"
-#include "lib/thread.h"
+#include "lib/bitmap.h"
+#include "lib/rwlock.h"
+#include "lib/memory.h"
 #include "lib/ut.h"
 
 MODULE_AUTHOR("Xyratex International");
 MODULE_DESCRIPTION("Colibri Unit Test Module");
 MODULE_LICENSE("proprietary");
 
-/* UT suites */
-extern const struct c2_test_suite c2_klibc2_ut;
-extern const struct c2_test_suite c2_net_bulk_if_ut;
-extern const struct c2_test_suite c2_net_bulk_mem_ut;
-extern const struct c2_test_suite c2_net_bulk_sunrpc_ut;
-extern const struct c2_test_suite c2_net_ksunrpc_ut;
-extern const struct c2_test_suite buffer_pool_ut;
-extern const struct c2_test_suite xcode_ut;
+/* lib/ut */
+extern void test_bitmap(void);
+extern void test_chan(void);
+extern void test_rw(void);
+extern void test_thread(void);
 
-static struct c2_thread ut_thread;
+static const struct c2_test_suite klibc2_ut = {
+	.ts_name = "klibc2-ut",
+	.ts_init = NULL,
+	.ts_fini = NULL,
+	.ts_tests = {
+		{ "bitmap",    test_bitmap    },
+		{ "chan",      test_chan      },
+		{ "rwlock",    test_rw        },
+		{ "thread",    test_thread    },
+		{ NULL,        NULL           }
+	}
+};
 
-static void run_kernel_ut(int ignored)
+static void run_kernel_ut(void)
 {
-        printk(KERN_INFO "Colibri Kernel Unit Test\n");
-
 	c2_uts_init();
-	c2_ut_add(&c2_klibc2_ut);
-	c2_ut_add(&c2_net_bulk_if_ut);
-	c2_ut_add(&c2_net_bulk_mem_ut);
-	c2_ut_add(&c2_net_bulk_sunrpc_ut);
-	c2_ut_add(&c2_net_ksunrpc_ut);
-	c2_ut_add(&buffer_pool_ut);
-	c2_ut_add(&xcode_ut);
-	c2_ut_run();
+	c2_ut_add(&klibc2_ut);
+	c2_ut_run(NULL);
 	c2_uts_fini();
 }
 
-static int __init c2_ut_module_init(void)
+int init_module(void)
 {
-	int rc;
+        printk(KERN_INFO "Colibri Kernel Unit Test\n");
 
-	rc = C2_THREAD_INIT(&ut_thread, int, NULL,
-		            &run_kernel_ut, 0, "run_kernel_ut");
-	C2_ASSERT(rc == 0);
+	run_kernel_ut();
 
-	return rc;
+	return 0;
 }
 
-static void __exit c2_ut_module_fini(void)
+void cleanup_module(void)
 {
-	c2_thread_join(&ut_thread);
 }
 
-module_init(c2_ut_module_init)
-module_exit(c2_ut_module_fini)
-
 /*
  *  Local variables:
  *  c-indentation-style: "K&R"
diff --git a/utils/linux_kernel/ut.sh b/utils/linux_kernel/ut.sh
deleted file mode 100755
index f4ea98c..0000000
--- a/utils/linux_kernel/ut.sh
+++ /dev/null
@@ -1,32 +0,0 @@
-#! /bin/sh
-
-# Small wrapper to run kernel UT
-
-if [ "$(id -u)" -ne 0 ]; then
-    echo "Must be run as root"
-    exit 1
-fi
-
-d="`git rev-parse --show-cdup`"
-if [ -n "$d" ]; then
-    cd "$d"
-fi
-
-. c2t1fs/linux_kernel/st/common.sh
-
-MODLIST="build_kernel_modules/kcolibri.ko \
-         utils/linux_kernel/kutc2.ko"
-
-log='/var/log/kern'
-if [ ! -e "$log" ]; then
-    log='/var/log/messages'
-fi
-tailseek=$(( $(stat -c %s "$log") + 1 ))
-
-# currently, kernel UT runs as part of loading kutc2 module
-modload_galois
-modload
-modunload
-modunload_galois
-
-tail -c+$tailseek "$log" | grep ' kernel: '
diff --git a/utils/ploss/Makefile.am b/utils/ploss/Makefile.am
index 92e0a72..6d6c611 100644
--- a/utils/ploss/Makefile.am
+++ b/utils/ploss/Makefile.am
@@ -1,4 +1,4 @@
-sbin_PROGRAMS           = ploss_server ploss_client
+bin_PROGRAMS            = ploss_server ploss_client
 
 ploss_server_SOURCES    = pl_svc.c pl_server.c pl_xdr.c helper.c helper.h pl.h
 ploss_server_CFLAGS     = -D_REENTRANT
diff --git a/utils/ploss/pl.h b/utils/ploss/pl.h
index c6033f2..eef3576 100644
--- a/utils/ploss/pl.h
+++ b/utils/ploss/pl.h
@@ -8,11 +8,13 @@
  * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
  * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
  * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
+
  * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
- *
+
+ * Original author: $NAME
+ * Original creation date: MM/DD/YYYY
  */
 /*
  * Packet loss testing tool.
diff --git a/utils/ploss/pl_svc.c b/utils/ploss/pl_svc.c
index 23c79fd..d634ef7 100644
--- a/utils/ploss/pl_svc.c
+++ b/utils/ploss/pl_svc.c
@@ -8,11 +8,13 @@
  * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
  * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
  * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
+
  * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
- *
+
+ * Original author: $NAME
+ * Original creation date: MM/DD/YYYY
  */
 /*
  * Packet loss testing tool.
diff --git a/utils/process_lcov.sh b/utils/process_lcov.sh
deleted file mode 100755
index 49a3ff7..0000000
--- a/utils/process_lcov.sh
+++ /dev/null
@@ -1,128 +0,0 @@
-#!/bin/bash
-
-# This script parses index.html file generated by lcov and
-# generates simple tabular data, which can be imported in
-# some spreadsheet
-
-usage()
-{
-    echo "Script for processing coverage data"
-    echo "usage: process_lcov -i index.html [-b] [-c] [-f] [-l]"
-    echo "	Where,"
-    echo "		-i <path> Path to index.html"
-    echo "		-b Show branch coverage data"
-    echo "		-c Show coverage data in csv format"
-    echo "		-f Show function coverage data"
-    echo "		-l Show line coverage data"
-    echo "	If none of the -b,-f,-l options are specified then by default -l"
-    echo "option is assumed."
-}
-
-BRANCH_COV=0
-FUNCTION_COV=0
-LINE_COV=0
-CSV_FORMAT=0
-INDEX_FILE=""
-
-OUTPUT_BANNER="Module ln_cov ln_hit ln_tot fn_cov fn_hit fn_tot br_cov br_hit \
-br_tot"
-
-if [ $# -eq 0 ]; then
-    usage
-    exit 1
-fi
-
-while getopts "bcfi:l" OPTION; do
-    case "$OPTION" in
-	b)
-	    BRANCH_COV=1
-	    ;;
-	c)
-	    CSV_FORMAT=1
-	    ;;
-	f)
-	    FUNCTION_COV=1
-	    ;;
-	i)
-	    INDEX_FILE="$OPTARG"
-	    ;;
-	l)
-	    LINE_COV=1
-	    ;;
-	*)
-	    usage
-	    exit 1
-	    ;;
-    esac
-done
-
-if [ "x$INDEX_FILE" = "x" ]; then
-    echo "index.html not specified"
-    usage
-    exit 1
-fi
-
-if [ $LINE_COV -eq 0 -a $FUNCTION_COV -eq 0 -a $BRANCH_COV -eq 0 ]; then
-    LINE_COV=1
-fi
-
-# read file | find interesting lines | remove all HTML tags | \
-#     remove all "&nbsp;" | remove all leading spaces | remove all "/ " \
-#     convert from one datum per line to tabular format | \
-#     squeeze consecutive spaces | remove % after number | remove data for UT |\
-#     remove data for include/ | remove data for st/ | sort according to \
-#     line coverage in descending order | print the fields to screen
-
-
-tempfile=`mktemp` > /dev/null
-
-cat $INDEX_FILE | egrep "coverFile|coverPer|coverNum" | sed 's/<[/]*[^>]*>//g'| \
- sed 's/&nbsp;//g;' | sed 's/^[ \t]*//' | sed 's/\/ //g' | \
- awk '/[a-zA-Z]/  { printf "\n"} {printf "%s\t", $0}' | \
- tr -s " " | tr '%' ' ' | grep -v "/ut" | grep -v "/include" | grep -v "/st" | \
- sort -b -g -k2 -r | \
- awk '{printf "%-20s %6s %6s %6s %6s %6s %6s %6s %6s %6s\n",\
-$1,$2,$3,$4,$5,$6,$7,$8,$9,$10}' |\
-    grep -v "^[ \t]*$" > $tempfile
-
-if [ $CSV_FORMAT -eq 1 ]; then
-    FORMAT_STRING1="%s,"
-    FORMAT_STRING2="%s,%s,%s,"
-else
-    FORMAT_STRING1="%-20s | "
-    FORMAT_STRING2="%6s %6s %6s | "
-fi
-
-tempscript=`mktemp`
-
-cat > $tempscript <<EOF
-BEGIN {
-	lc = $LINE_COV;
-	bc = $BRANCH_COV;
-	fc = $FUNCTION_COV;
-}
-{
-	printf "$FORMAT_STRING1", \$1;
-}
-lc == 1 {
-	printf "$FORMAT_STRING2", \$2, \$3, \$4;
-}
-bc == 1 {
-	printf "$FORMAT_STRING2", \$5, \$6, \$7;
-}
-fc == 1 {
-	printf "$FORMAT_STRING2", \$8, \$9, \$10;
-}
-{
-	printf "\n"
-}
-EOF
-
-echo $OUTPUT_BANNER | awk -f $tempscript
-
-echo
-
-cat $tempfile | awk -f $tempscript
-
-rm $tempfile
-rm $tempscript
diff --git a/utils/run_tests.sh b/utils/run_tests.sh
deleted file mode 100755
index aac212a..0000000
--- a/utils/run_tests.sh
+++ /dev/null
@@ -1,536 +0,0 @@
-#!/bin/bash
-#
-# COPYRIGHT 2012 XYRATEX TECHNOLOGY LIMITED
-#
-# THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
-# HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
-# LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
-# THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
-# BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
-# USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
-# EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
-#
-# YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
-# THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
-# http://www.xyratex.com/contact
-#
-# Original author: Manish Honap <manish_honap@xyratex.com>
-# Original creation date: 02/03/2012
-#
-
-# Script for
-#       * Clone colibri source
-#       * build source
-#       * Run UT's and UB's
-#       * Generate coverage data
-
-# NOTES:
-#       Currently kernel UT Part is not implemented
-#       The Script must be run as root
-
-usage()
-{
-    echo "Test automation script for colibri"
-    echo "run_tests.sh -r <path> -b [all | i=a,b,... | e=a,b,... | current]"
-    echo "            [-d <path>] [-h] [-m <e-mail-id>] [-s suffix]"
-
-    echo ""
-    echo "Where:"
-    echo "-b <branches>  Branches to operate on"
-    echo "                      all      - All branches"
-    echo "                      i=<list> - Include branches from <list>"
-    echo "                      e=<list> - Exclude branches from <list>"
-    echo "                      current  - Current branch"
-    echo "-d <path>      Directory from where Colibri source is to be used"
-    echo "                 (If this is not given UB will not be run)"
-    echo "-h             Print this help"
-    echo "-m <e-mail-id> Send mail to this email address in case of error or success."
-    echo "-r <path>      Test root directory (Mandatory)."
-    echo "-s <suffix>    Suffix to be appended to top level directory name in "
-    echo "                 case user wants to differentiate between test directories."
-}
-
-OPTIONS_STRING="b:d:hm:r:s:"
-
-# Directory structure:
-# The utility will create the following directory structure on invocation,
-
-# $TESTROOT/
-# └── $DIRTIME/
-#     ├── run_tests.log
-#     ├── branches.txt
-#     ├── <Branch Name>/ [ For each branch ]
-#     │   ├── core-dumps/
-#     │   ├── coverage-data/
-#     │   │   ├── html/
-#     │   │   └── coverage-data.txt
-#     │   └── logs/
-#     │       ├── autogen.sh.log
-#     │       ├── configure.log
-#     │       ├── cov.log
-#     │       ├── git.log
-#     │       ├── make.log
-#     │       ├── make-clean.log
-#     │       ├── ut.log
-#     │       └── ub.log
-#     └── src-YYYY-MM-DD_HH-MM-SS/ [ If colibri repository is given on command
-#                                    line then src is a link to the
-#                                    colibri repository otherwise it is a
-#                                    cloned colibri repository ]
-
-# The messages will be printed in following format;
-# DATE:TIME:CODE:BRANCH:PHASE:$rc:MESSAGE
-# Where ( * represents Optional ):
-#       DATE    - date in $yyyy-$mm-$dd format
-#       TIME    - time in $hh-$mm-ss format
-#       CODE    - can be any of the [ INFO | ERR ]
-#       BRANCH  - current branch (*)
-#       PHASE   - can be any of the following,
-#                 [ autogen | configure | make | UT | UB | Coverage ] (*)
-#       $rc     - Error code (*)
-#       MESSAGE - Detailed message
-# Messages with code `ERR' contain $rc as error code.
-
-
-# NOTE(S):
-# For sending mail it is assumed that mail command is configured
-
-#-------------------------------------------------------------------------------
-
-# Directories to be created if not present
-DIRS="logs core-dumps coverage-data coverage-data/html"
-
-# GIT Variables
-# REMOTE_GIT_CMD="git clone ssh://gitosis@git.clusterstor.com/colibri.git"
-GIT_USER=${GIT_USER:-gitosis}
-GIT_WEB_ADDRESS=${GIT_WEB_ADDRESS:-git.clusterstor.com}
-GIT_PROTOCOL=${GIT_PROTOCOL:-ssh}
-GIT_REPOSITORY=${GIT_REPOSITORY:-colibri.git}
-
-UB_ROUNDS=${UB_ROUNDS:-0}
-
-# For setting any of the above variables do,
-# UB_ROUNDS=NUM ./run_tests.sh [OPTIONS ...]
-
-MAIL_TEXT_FILE=$(mktemp /tmp/build-auto-mail-log.XXXXXX) > /dev/null
-
-COLIBRI_CORE_PATH=""
-
-#-------------------------------------------------------------------------------
-
-# print_msg arg1 arg2
-# arg1 - Echo the message to console
-# arg2 - If arg2 == 1 then put arg1 in e-mail also
-
-print_msg()
-{
-    mail_text=$(echo $(date +"%Y-%m-%d:%H-%M-%S")":$1")
-    echo $mail_text >> $TESTROOT/$DIRTIME/run_tests.log
-
-    if [ "$2" = "1" ]; then
-        echo $mail_text >> $MAIL_TEXT_FILE
-    fi
-}
-
-# create_dir arg1
-# arg1 - Directory to be created
-create_dir()
-{
-    rc=0
-    if [ ! -d "$1" ]; then
-        mkdir "$1"
-        rc=$?
-        if [ $rc -ne 0 ]; then
-            print_msg "ERR:::$rc:Creating $1 failed"
-        fi
-    fi
-    return $rc
-}
-
-#run_command DIR CMD ARG CORE_DUMP_FLAG
-# Run the command `CMD' in `DIR' with argument `ARG'
-# If CORE_DUMP_FLAG=1 then invoke copy_core_dump
-
-run_command()
-{
-    DIR=$1
-    CMD=$2
-    ARG=$3
-    CORE_DUMP_FLAG=$4
-
-    CMD_LOG=$(echo $CMD| awk '{ print $2 }')
-    if [ "$CMD_LOG" = "" ]; then
-        CMD_LOG="$CMD"
-    fi
-
-    cur_branch_dir="$TESTROOT/$DIRTIME/$current_branch"
-    pushd $DIR > /dev/null
-
-    print_msg "INFO:$current_branch:$CMD_LOG:Start"
-
-    $CMD $ARG >> "$cur_branch_dir/logs/$CMD_LOG.log" 2>&1
-    rc=$?
-    if [ "$rc" != "0" ]; then
-        print_msg "ERR:$current_branch:$rc:$CMD_LOG failed" 1
-    fi
-    if [ "$CORE_DUMP_FLAG" = "1" ]; then
-        copy_core_dump
-    fi
-
-    print_msg "INFO:$current_branch:$CMD_LOG:End"
-
-    popd > /dev/null
-    return $rc
-}
-
-copy_core_dump()
-{
-    cur_branch_dir="$TESTROOT/$DIRTIME/$current_branch"
-
-    if [ -f $COLIBRI_CORE_PATH/utils/ut-sandbox/core.* ]; then
-        cp $COLIBRI_CORE_PATH/utils/ut-sandbox/core.* $cur_branch_dir/core-dumps/
-        cp $COLIBRI_CORE_PATH/utils/.libs/lt-ut $cur_branch_dir/core-dumps/
-        print_msg "INFO:::A core is copied at $cur_branch_dir/core-dumps/" 1
-    fi
-}
-
-gather_coverage()
-{
-    cur_branch_dir="$TESTROOT/$DIRTIME/$current_branch"
-    pushd  $COLIBRI_CORE_PATH/utils > /dev/null
-
-    if [ -f gcov_stats_genhtml.sh ]; then
-        print_msg "INFO:$current_branch:Coverage:Start"
-        ./gcov_stats_genhtml.sh user $COLIBRI_CORE_PATH \
-            $cur_branch_dir/coverage-data/html >>       \
-            $cur_branch_dir/logs/cov.log 2>&1
-        rc=$?
-        if [ $rc -ne 0 ]; then
-            print_msg "ERR:$current_branch:Coverage:$rc:Gathering coverage \
-                data failed" 1
-        else
-            if [ -f process_lcov.sh ]; then
-                ./process_lcov.sh \
-		    -i $cur_branch_dir/coverage-data/html/index.html -b -l -f \
-                    > $cur_branch_dir/coverage-data/coverage-data.txt 2>&1
-                rc=$?
-                if [ $rc -ne 0 ]; then
-                    print_msg "ERR:$current_branch:Coverage:$rc:Gathering \
-                        coverage data failed" 1
-                fi
-            fi
-        fi
-    else
-        print_msg "ERR:$current_branch:Coverage:$rc:gcov_stats_genhtml.sh \
-                not found" 1
-        rc=2
-    fi
-    print_msg "INFO:$current_branch:Coverage:End"
-    popd > /dev/null
-    return $rc
-}
-
-run_test_automate()
-{
-    for line in $(cat $TESTROOT/$DIRTIME/branches.txt); do
-        current_branch=$(basename $line)
-        BRANCH_NAMES="$current_branch"", $BRANCH_NAMES"
-        create_dir $TESTROOT/$DIRTIME/$current_branch
-        rc=$?
-        if [ $rc -ne 0 ]; then
-            return $rc
-        fi
-
-        for directory in $DIRS; do
-            create_dir $TESTROOT/$DIRTIME/$current_branch/$directory
-            rc=$?
-            if [ $rc -ne 0 ]; then
-                return $rc
-            fi
-        done
-
-        git checkout $current_branch >> \
-                $TESTROOT/$DIRTIME/$current_branch/logs/git.log 2>&1
-
-        if run_command "$COLIBRI_SOURCE/core" 'sh autogen.sh'                    && \
-           run_command "$COLIBRI_SOURCE/core" './configure' '--enable-coverage'  && \
-           run_command "$COLIBRI_SOURCE/core" 'make'; then
-
-            run_command "$COLIBRI_SOURCE/core/utils" './ut' '' 1
-
-            if [ $UB_ROUNDS -ne 0 ]; then
-                run_command "$COLIBRI_SOURCE/core/utils" './ub' $UB_ROUNDS
-            fi
-
-            gather_coverage
-        fi
-
-        print_msg "INFO:$current_branch:Cleanup:Start"
-        cd $COLIBRI_CORE_PATH
-        make distclean >> \
-                $TESTROOT/$DIRTIME/$current_branch/logs/make-clean.log 2>&1
-        print_msg "INFO:$current_branch:Cleanup:End"
-    done
-
-    return 0
-}
-
-parse_branches()
-{
-    tempfile=$(mktemp)
-
-    case $BRANCHES in
-        all)
-            return 0
-            ;;
-
-        current)
-            pushd $COLIBRI_SOURCE/core > /dev/null
-            git branch | grep \* | awk '{print $2}' > \
-                $TESTROOT/$DIRTIME/branches.txt
-            popd > /dev/null
-            return 0
-            ;;
-
-        i=*)
-            tempbranches=$(mktemp)
-            echo $BRANCHES | sed 's/i=//' | awk ' BEGIN { RS="," } {print} ' |\
-                 grep -v "^$" > \
-                $tempfile
-            cp $TESTROOT/$DIRTIME/branches.txt $tempbranches
-            cat /dev/null > $TESTROOT/$DIRTIME/branches.txt > /dev/null
-            for line in $(cat $tempfile); do
-                cat $tempbranches | grep $line > /dev/null
-                rc=$?
-                if [ $rc -ne 0 ]; then
-                    print_msg "ERR:::$rc:Branch $line not found"
-                else
-                    echo $line >> $TESTROOT/$DIRTIME/branches.txt
-                fi
-            done
-            rm $tempbranches > /dev/null
-            ;;
-
-        e=*)
-            NEW_BRANCHES=$(echo $BRANCHES | sed 's/i=//' | awk ' BEGIN \
-                { RS="," } {ORS=" "} {print}')
-
-            while read line; do
-                for branch in $NEW_BRANCHES; do
-                    if [ $(basename $line) !=  "$branch" ]; then
-                        echo $line >> $tempfile
-                    fi
-                done
-            done < $TESTROOT/$DIRTIME/branches.txt
-            mv $tempfile $TESTROOT/$DIRTIME/branches.txt
-            ;;
-
-        *)
-           return 1;
-           ;;
-
-    esac
-    return 0;
-}
-
-init_dirs()
-{
-    if [ "$suffix" = "" ]; then
-        DIRTIME=$(date +"%Y-%b-%d_%H-%M-%S")
-    else
-        DIRTIME=$(date +"%Y-%b-%d_%H-%M-%S")"-$suffix"
-    fi
-
-    COLIBRI_SOURCE=$TESTROOT/$DIRTIME/src"-$DIRTIME"
-
-    create_dir $TESTROOT/$DIRTIME
-    rc=$?
-    if [ $rc -ne 0 ]; then
-        return $rc
-    fi
-
-    if [ "$src_dir" = "" ]; then
-        create_dir $COLIBRI_SOURCE
-        rc=$?
-        if [ $rc -ne 0 ]; then
-            return $rc
-        fi
-
-        print_msg "INFO:Cloning Colibri source please wait..."
-
-        # Clone the Colibri source
-        git clone $GIT_PROTOCOL://$GIT_USER@$GIT_WEB_ADDRESS/$GIT_REPOSITORY \
-                $COLIBRI_SOURCE >> $TESTROOT/$DIRTIME/run_tests.log 2>&1
-        rc=$?
-        if [ $rc -ne 0 ]; then
-            print_msg "ERR:::$rc:Cloning the Colibri source failed" 1
-            return $rc
-        fi
-
-        if [ -f $COLIBRI_SOURCE/checkout ]; then
-            cd $COLIBRI_SOURCE
-            ./checkout >> $TESTROOT/$DIRTIME/run_tests.log 2>&1
-            rc=$?
-            if [ $? -ne 0 ]; then
-                print_msg "ERR:::$rc:Cloning the Colibri source failed" 1
-                return $rc
-            fi
-        else
-            print_msg "ERR:::$rc:No checkout script found in source" 1
-            return 1
-        fi
-    else # [ "$src_dir" != "" ]
-        ln -s $src_dir $COLIBRI_SOURCE
-    fi
-
-    pushd $COLIBRI_SOURCE/core > /dev/null
-
-    git branch -a | grep origin/ | grep -v HEAD > \
-        $TESTROOT/$DIRTIME/branches.txt
-
-    parse_branches
-    rc=$?
-    if [ $? -ne 0 ]; then
-        print_msg "ERR:::$rc:Branch parsing failed" 1
-        return $rc
-    fi
-
-    COLIBRI_CORE_PATH=$COLIBRI_SOURCE/core
-
-    popd > /dev/null
-}
-
-check_and_setup_environ()
-{
-    which lcov > /dev/null 2>&1
-    if [ $? -ne 0 ]; then
-        print_msg "ERR:::$rc:lcov not present" 1
-        return 2
-    fi
-
-    ulimit -c unlimited > /dev/null 2>&1
-
-    echo "" > $MAIL_TEXT_FILE
-
-    return 0
-}
-
-send_email()
-{
-    if [ "$MAIL_ADDRESS" != "" ]; then
-        if [ $1 -eq 0 ]; then
-            curr_hostname=$(hostname)
-            SUCCESS_MSG="Following branches were successfully tested - \
-                $BRANCH_NAMES. The results can be found at $TESTROOT/$DIRTIME/"
-
-            echo $SUCCESS_MSG | mail -s "Colibri build automation script ran \
-                successfully on $curr_hostname" $MAIL_ADDRESS
-        else
-            echo $MAIL_TEXT_FILE | mail -s "Error in Colibri build automation \
-                script on $curr_hostname" $MAIL_ADDRESS
-        fi
-    fi
-    mv $MAIL_TEXT_FILE $TESTROOT/$DIRTIME/mail.log
-}
-
-main()
-{
-    check_and_setup_environ
-    rc=$?
-    if [ $rc -ne 0 ]; then
-        exit $rc
-    fi
-
-    init_dirs
-    rc=$?
-    if [ $rc -ne 0 ]; then
-        exit $rc
-    fi
-
-    run_test_automate
-
-    send_email $?
-
-    return 0
-}
-
-if [ "$(id -u)" != "0" ]; then
-   echo "This script must be run as root" 1>&2
-   exit 1
-fi
-
-if [ $# -lt 2 ]; then
-    usage
-    exit 1;
-fi
-
-while getopts "$OPTIONS_STRING" OPTION; do
-    case "$OPTION" in
-        b)
-            BRANCHES="$OPTARG"
-            ;;
-
-        d)
-            src_dir="$OPTARG"
-            ;;
-
-        h)
-            usage
-            exit 0
-            ;;
-
-        m)
-            MAIL_ADDRESS="$OPTARG"
-            ;;
-
-        r)
-            TESTROOT="$OPTARG"
-            ;;
-
-        s)
-            suffix="$OPTARG"
-            ;;
-
-        *)
-            usage
-            exit 1
-            ;;
-
-    esac
-done
-
-if [ "$TESTROOT" = "" ]; then
-    print_msg "TESTROOT not specified"
-    usage
-    exit 1
-else
-    if ! [ -d $TESTROOT ]; then
-        print_msg "ERR:::2:Directory not found" 1
-        exit 2
-    fi
-fi
-
-if [ "$BRANCHES" = "" ]; then
-    print_msg "BRANCHES not specified"
-    usage
-    exit 1
-fi
-
-letter1=$(expr substr $BRANCHES 1 1)
-letter2=$(expr substr $BRANCHES 2 1)
-
-if [ "$letter1" = "i" ] || [ "$letter1" = "e" ]; then
-    if [ "$letter2" != "=" ]; then
-        echo "Syntax error in specifying branches for -b option"
-        usage
-        exit 1
-    fi
-else
-    if [ "$BRANCHES" != "all" ] && [ "$BRANCHES" != "current" ]; then
-        echo "Syntax error in specifying branches for -b option"
-        usage
-        exit 1
-    fi
-fi
-
-main
diff --git a/utils/ub_main.c b/utils/ub_main.c
index f80237c..149cffe 100644
--- a/utils/ub_main.c
+++ b/utils/ub_main.c
@@ -14,7 +14,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Nikita Danilov <Nikita_Danilov@xyratex.com>
+ * Original author: Nikita Danilov
  * Original creation date: 07/19/2010
  */
 
@@ -24,7 +24,6 @@
 #include "utils/common.h"
 
 extern struct c2_ub_set c2_list_ub;
-extern struct c2_ub_set c2_tlist_ub;
 extern struct c2_ub_set c2_bitmap_ub;
 extern struct c2_ub_set c2_thread_ub;
 extern struct c2_ub_set c2_memory_ub;
@@ -36,6 +35,7 @@ extern struct c2_ub_set c2_db_ub;
 extern struct c2_ub_set c2_emap_ub;
 extern struct c2_ub_set c2_fol_ub;
 extern struct c2_ub_set c2_parity_math_ub;
+extern struct c2_ub_set c2_xdr_ub;
 
 #define UB_SANDBOX "./ub-sandbox"
 
@@ -58,15 +58,15 @@ int main(int argc, char *argv[])
                 c2_ub_set_add(&c2_cob_ub);
                 c2_ub_set_add(&c2_emap_ub);
                 c2_ub_set_add(&c2_fol_ub);
-                c2_ub_set_add(&c2_tlist_ub);
                 c2_ub_set_add(&c2_list_ub);
                 c2_ub_set_add(&c2_bitmap_ub);
                 c2_ub_set_add(&c2_parity_math_ub);
 		c2_ub_set_add(&c2_thread_ub);
 		c2_ub_set_add(&c2_trace_ub);
+		c2_ub_set_add(&c2_xdr_ub);
 		c2_ub_run(rounds);
 
-		unit_end(UB_SANDBOX, false);
+		unit_end(UB_SANDBOX);
 	}
 
 	return 0;
diff --git a/utils/ut.valgrind b/utils/ut.valgrind
deleted file mode 100755
index ab7d546..0000000
--- a/utils/ut.valgrind
+++ /dev/null
@@ -1,15 +0,0 @@
-#! /bin/sh
-
-valgrind \
-    --tool=memcheck \
-    --trace-children=yes --track-fds=yes \
-    --leak-check=full --track-origins=yes \
-    ./utils/.libs/lt-ut
-
-valgrind --tool=cachegrind              ./utils/.libs/lt-ut
-valgrind --tool=callgrind               ./utils/.libs/lt-ut
-valgrind --tool=hellgrind               ./utils/.libs/lt-ut
-#valgrind --tool=drd --free-is-write=yes ./utils/.libs/lt-ut
-valgrind --tool=massif                  ./utils/.libs/lt-ut
-#valgrind --tool=ptrcheck                ./utils/.libs/lt-ut
-
diff --git a/utils/ut_main.c b/utils/ut_main.c
index 62fb8e3..dfc66a8 100644
--- a/utils/ut_main.c
+++ b/utils/ut_main.c
@@ -14,7 +14,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Nikita Danilov <Nikita_Danilov@xyratex.com>
+ * Original author: Nikita Danilov
  * Original creation date: 07/19/2010
  */
 
@@ -26,7 +26,6 @@
 #include "lib/trace.h"
 #include "lib/thread.h"    /* LAMBDA */
 #include "lib/getopts.h"
-#include "lib/memory.h"
 #include "utils/common.h"
 
 /* sort test suites in alphabetic order */
@@ -35,229 +34,66 @@ extern const struct c2_test_suite adieu_ut;
 extern const struct c2_test_suite ad_ut;
 extern const struct c2_test_suite capa_ut;
 extern const struct c2_test_suite cob_ut;
-extern const struct c2_test_suite console_ut;
 extern const struct c2_test_suite db_ut;
 extern const struct c2_test_suite emap_ut;
 extern const struct c2_test_suite fit_ut;
 extern const struct c2_test_suite fol_ut;
 extern const struct c2_test_suite fop_ut;
-extern const struct c2_test_suite c2_net_bulk_if_ut;
-extern const struct c2_test_suite c2_net_bulk_mem_ut;
-extern const struct c2_test_suite c2_net_bulk_sunrpc_ut;
+extern const struct c2_test_suite net_client_ut; /* deprecated */
+extern const struct c2_test_suite net_bulk_if_ut;
+extern const struct c2_test_suite net_bulk_mem_ut;
+extern const struct c2_test_suite net_bulk_sunrpc_ut;
 extern const struct c2_test_suite parity_math_ut;
-extern const struct c2_test_suite sm_ut;
 extern const struct c2_test_suite stobio_ut;
 extern const struct c2_test_suite udb_ut;
 extern const struct c2_test_suite mdstore_ut;
-extern const struct c2_test_suite xcode_bufvec_fop_ut;
-extern const struct c2_test_suite xcode_bufvec_ut;
-extern const struct c2_test_suite xcode_ff2c_ut;
-extern const struct c2_test_suite xcode_ut;
-extern const struct c2_test_suite reqh_ut;
-extern const struct c2_test_suite rpc_onwire_ut;
-extern const struct c2_test_suite colibri_setup_ut;
-extern const struct c2_test_suite rpclib_ut;
-extern const struct c2_test_suite cfm_ut;
-extern const struct c2_test_suite yaml2db_ut;
-extern const struct c2_test_suite buffer_pool_ut;
-extern const struct c2_test_suite balloc_ut;
+extern const struct c2_test_suite xdr_ut;
 
 #define UT_SANDBOX "./ut-sandbox"
 
-void add_uts(void)
-{
-	/* sort test suites in alphabetic order */
-	c2_ut_add(&libc2_ut);
-	c2_ut_add(&ad_ut);
-	c2_ut_add(&adieu_ut);
-	c2_ut_add(&balloc_ut);
-	c2_ut_add(&buffer_pool_ut);
-	c2_ut_add(&capa_ut);
-	c2_ut_add(&cfm_ut);
-	c2_ut_add(&cob_ut);
-        c2_ut_add(&mdstore_ut);
-	c2_ut_add(&colibri_setup_ut);
-	c2_ut_add(&console_ut);
-	c2_ut_add(&db_ut);
-	c2_ut_add(&emap_ut);
-	c2_ut_add(&fit_ut);
-	c2_ut_add(&fol_ut);
-	c2_ut_add(&fop_ut);
-	c2_ut_add(&c2_net_bulk_if_ut);
-	c2_ut_add(&c2_net_bulk_mem_ut);
-	c2_ut_add(&c2_net_bulk_sunrpc_ut);
-	c2_ut_add(&parity_math_ut);
-	c2_ut_add(&reqh_ut);
-	c2_ut_add(&rpclib_ut);
-	c2_ut_add(&rpc_onwire_ut);
-	c2_ut_add(&sm_ut);
-	c2_ut_add(&stobio_ut);
-	c2_ut_add(&udb_ut);
-	c2_ut_add(&xcode_bufvec_fop_ut);
-	c2_ut_add(&xcode_bufvec_ut);
-	c2_ut_add(&xcode_ut);
-	c2_ut_add(&xcode_ff2c_ut);
-	c2_ut_add(&yaml2db_ut);
-}
-
-int parse_test_list(char *str, struct c2_list *list)
-{
-	char *token;
-	char *subtoken;
-	char *saveptr = NULL;
-	struct c2_test_suite_entry *ts_entry;
-
-	while (true) {
-		token = strtok_r(str, ",", &saveptr);
-		if (token == NULL)
-			break;
-
-		subtoken = strchr(token, ':');
-		if (subtoken != NULL)
-			*subtoken++ = '\0';
-
-		C2_ALLOC_PTR(ts_entry);
-		if (ts_entry == NULL)
-			return -ENOMEM;
-
-		ts_entry->tse_suite_name = token;
-		/* subtoken can be NULL if no test was specified */
-		ts_entry->tse_test_name = subtoken;
-
-		c2_list_link_init(&ts_entry->tse_linkage);
-		c2_list_add_tail(list, &ts_entry->tse_linkage);
-
-		/* str should be NULL for subsequent strtok_r(3) calls */
-		str = NULL;
-	}
-
-	return 0;
-}
-
-void free_test_list(struct c2_list *list)
-{
-	struct c2_test_suite_entry *entry;
-	struct c2_test_suite_entry *n;
-	c2_list_for_each_entry_safe(list, entry, n,
-			struct c2_test_suite_entry, tse_linkage)
-	{
-		c2_list_del(&entry->tse_linkage);
-		c2_free(entry);
-	}
-}
-
 int main(int argc, char *argv[])
 {
-	int  result              = EXIT_SUCCESS;
-	bool list_ut             = false;
-	bool with_tests          = false;
-	bool keep_sandbox        = false;
-	char *test_list_str      = NULL;
-	char *exclude_list_str   = NULL;
-	struct c2_list test_list;
-	struct c2_list exclude_list;
-
-	struct c2_ut_run_cfg cfg = {
-		.urc_mode              = C2_UT_BASIC_MODE,
-		.urc_abort_cu_assert   = true,
-		.urc_report_exec_time  = true,
-		.urc_test_list         = &test_list,
-		.urc_exclude_list      = &exclude_list,
-	};
-
-	result = unit_start(UT_SANDBOX);
-	if (result != 0)
-		return result;
+	int  result;
+	bool keep   = false;
 
 	result = C2_GETOPTS("ut", argc, argv,
-		    C2_HELPARG('h'),
-		    C2_VOIDARG('T', "parse trace log produced earlier",
-				LAMBDA(void, (void) {
-						exit(c2_trace_parse());
-				})),
-		    C2_FLAGARG('k', "keep the sandbox directory",
-				&keep_sandbox),
-		    C2_VOIDARG('i', "CUnit interactive console",
-				LAMBDA(void, (void) {
-					cfg.urc_mode = C2_UT_ICONSOLE_MODE;
-				})),
-		    C2_VOIDARG('a', "automated CUnit with xml output",
-				LAMBDA(void, (void) {
-					cfg.urc_mode = C2_UT_AUTOMATED_MODE;
-				})),
-		    C2_FLAGARG('l', "list available test suites",
-				&list_ut),
-		    C2_VOIDARG('L', "list available test suites with"
-				    " their tests",
-				LAMBDA(void, (void) {
-						list_ut = true;
-						with_tests = true;
-				})),
-		    C2_STRINGARG('t', "test list 'suite[:test][,suite"
-				      "[:test]]'",
-				      LAMBDA(void, (const char *str) {
-					    test_list_str = strdup(str);
-				      })
-				),
-		    C2_STRINGARG('x', "exclude list 'suite[:test][,suite"
-				      "[:test]]'",
-				      LAMBDA(void, (const char *str) {
-					 exclude_list_str = strdup(str);
-				      })
-				),
-		    C2_VOIDARG('A', "don't abort program on CU_ASSERT"
-				    " failure",
-				LAMBDA(void, (void) {
-					cfg.urc_abort_cu_assert = false;
-				})),
-		    C2_VOIDARG('P', "don't report test execution time",
-				LAMBDA(void, (void) {
-					cfg.urc_report_exec_time = false;
-				})),
-		    );
+			    C2_VOIDARG('T', "parse trace log produced earlier",
+				       LAMBDA(void, (void) {
+						       c2_trace_parse();
+						       exit(0);
+					       })),
+			    C2_FLAGARG('k', "keep the sandbox directory",
+				       &keep));
 	if (result != 0)
-		goto out;
+		return result;
 
-	/* check conflicting options */
-	if ((cfg.urc_mode != C2_UT_BASIC_MODE && (list_ut ||
-	     test_list_str != NULL || exclude_list_str != NULL)) ||
-	     (list_ut && (test_list_str != NULL || exclude_list_str != NULL)))
-	{
-		fprintf(stderr, "Error: conflicting options: only one of the"
-				" -i -I -a -l -L -t -x option can be used at"
-				" the same time\n");
-		result = EXIT_FAILURE;
-		goto out;
+	if (unit_start(UT_SANDBOX) == 0) {
+		/* sort test suites in alphabetic order */
+		c2_ut_add(&libc2_ut);
+		c2_ut_add(&adieu_ut);
+		c2_ut_add(&ad_ut);
+		c2_ut_add(&capa_ut);
+		c2_ut_add(&cob_ut);
+		c2_ut_add(&mdstore_ut);
+		c2_ut_add(&db_ut);
+		c2_ut_add(&emap_ut);
+		c2_ut_add(&fit_ut);
+		c2_ut_add(&fol_ut);
+		c2_ut_add(&fop_ut);
+		c2_ut_add(&net_bulk_if_ut);
+		c2_ut_add(&net_bulk_mem_ut);
+		c2_ut_add(&net_bulk_sunrpc_ut);
+		c2_ut_add(&net_client_ut);
+		c2_ut_add(&parity_math_ut);
+		c2_ut_add(&stobio_ut);
+		c2_ut_add(&udb_ut);
+		c2_ut_add(&xdr_ut);
+		c2_ut_run("c2ut.log");
+		if (!keep)
+			unit_end(UT_SANDBOX);
 	}
 
-	c2_list_init(&test_list);
-	c2_list_init(&exclude_list);
-
-	if (test_list_str != NULL)
-		parse_test_list(test_list_str, &test_list);
-	if (exclude_list_str != NULL)
-		parse_test_list(exclude_list_str, &exclude_list);
-
-	add_uts();
-
-	if (list_ut)
-		c2_ut_list(with_tests);
-	else
-		c2_ut_run(&cfg);
-
-	if (test_list_str != NULL)
-		free(test_list_str);
-	if (exclude_list_str != NULL)
-		free(exclude_list_str);
-
-	free_test_list(&test_list);
-	free_test_list(&exclude_list);
-
-	c2_list_fini(&test_list);
-	c2_list_fini(&exclude_list);
-out:
-	unit_end(UT_SANDBOX, keep_sandbox);
-	return result;
+	return 0;
 }
 
 /*
diff --git a/xcode/Makefile.am b/xcode/Makefile.am
deleted file mode 100644
index ce20cff..0000000
--- a/xcode/Makefile.am
+++ /dev/null
@@ -1,12 +0,0 @@
-xcodedir                     = $(includedir)/colibri/xcode
-xcode_HEADERS                = bufvec_xcode.h xcode.h
-
-noinst_LTLIBRARIES           = libcolibri-xcode.la
-libcolibri_xcode_la_SOURCES  = bufvec_xcode.c bufvec_xcode_fop.c \
-			       bufvec_xcode_size.c bufvec_xcode.h \
-			       xcode.c xcode.h
-
-EXTRA_DIST                   = cursor.c
-
-INCLUDES                     = -I. -I$(top_srcdir) -I$(top_srcdir)/include
-
diff --git a/xcode/bufvec_xcode.c b/xcode/bufvec_xcode.c
deleted file mode 100644
index 5752c74..0000000
--- a/xcode/bufvec_xcode.c
+++ /dev/null
@@ -1,373 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Subhash Arya <subhash_arya@xyratex.com>
- * Original creation date: 06/25/2011
- */
-#include "lib/types.h"
-#include "lib/vec.h"
-#include "lib/assert.h"
-#include "fop/fop.h"
-#include "fop/fop_base.h"
-#include "lib/errno.h"
-#include "xcode/bufvec_xcode.h"
-
-/** Initializes a c2_bufvec containing a single element of specified size */
-static void data_to_bufvec(struct c2_bufvec *src_buf, void **data,
-			 size_t *len)
-{
-	C2_PRE(src_buf != NULL);
-	C2_PRE(len != 0);
-	C2_PRE(data != NULL);
-
-	src_buf->ov_vec.v_nr = 1;
-	src_buf->ov_vec.v_count = (c2_bcount_t *)len;
-	src_buf->ov_buf = data;
-}
-
-/** Helper functions to copy opaque data with specified size to and from a
-   c2_bufvec */
-static int data_to_bufvec_copy(struct c2_bufvec_cursor *cur, void *data,
-			size_t len)
-{
-	c2_bcount_t		 count;
-	struct c2_bufvec_cursor  src_cur;
-	struct c2_bufvec	 src_buf;
-
-	C2_PRE(cur != NULL);
-	C2_PRE(data != NULL);
-	C2_PRE(len != 0);
-
-	data_to_bufvec(&src_buf, &data, &len);
-	c2_bufvec_cursor_init(&src_cur, &src_buf);
-	count = c2_bufvec_cursor_copy(cur, &src_cur, len);
-	if (count != len)
-		return -EFAULT;
-	return 0;
-}
-
-static int bufvec_to_data_copy(struct c2_bufvec_cursor *cur, void *data,
-			size_t len)
-{
-	c2_bcount_t		 count;
-	struct c2_bufvec_cursor  dcur;
-	struct c2_bufvec	 dest_buf;
-
-	C2_PRE(cur != NULL);
-	C2_PRE(data != NULL);
-	C2_PRE(len != 0);
-
-	data_to_bufvec(&dest_buf, &data, &len);
-	c2_bufvec_cursor_init(&dcur, &dest_buf);
-	count = c2_bufvec_cursor_copy(&dcur, cur, len);
-	if (count != len)
-		return -EFAULT;
-	return 0;
-}
-/**
-   Returns no of padding bytes that would be needed to keep a cursor aligned
-   at 8 byte boundary.
-   @pre size > 0
-*/
-static int pad_bytes_get(size_t size)
-{
-	uint64_t	result;
-
-	C2_PRE(size > 0);
-
-	if (size <= BYTES_PER_XCODE_UNIT)
-		return BYTES_PER_XCODE_UNIT - size;
-	result = size & (BYTES_PER_XCODE_UNIT - 1);
-	return result == 0 ? result : BYTES_PER_XCODE_UNIT - result;
-}
-
-/**
-  Adds padding bytes to the c2_bufvec_cursor to keep it aligned at 8 byte
-  boundaries.
-*/
-static int zero_padding_add(struct c2_bufvec_cursor *cur, uint64_t pad_bytes)
-{
-	void		*pad_p;
-	uint64_t	 pad = 0;
-
-	C2_PRE(cur != NULL);
-	C2_PRE(pad_bytes < BYTES_PER_XCODE_UNIT);
-
-	pad_p = &pad;
-	return(data_to_bufvec_copy(cur, pad_p, pad_bytes));
-}
-
-static int bufvec_uint64_encode(struct c2_bufvec_cursor *cur, uint64_t *val)
-{
-	C2_PRE(cur != NULL);
-	C2_PRE(val != NULL);
-
-	return data_to_bufvec_copy(cur, val, sizeof *val);
-}
-
-static int bufvec_uint64_decode(struct c2_bufvec_cursor *cur, uint64_t *val)
-{
-	C2_PRE(cur != NULL);
-	C2_PRE(val != NULL);
-
-	return bufvec_to_data_copy(cur, val, sizeof *val);
-
-}
-
-static int bufvec_uint32_encode(struct c2_bufvec_cursor *cur, uint32_t *val)
-{
-	uint64_t	l_val;
-
-	C2_PRE(cur != NULL);
-	C2_PRE(val != NULL);
-
-	l_val = (uint64_t)*val;
-	return bufvec_uint64_encode(cur, &l_val);
-}
-
-static int bufvec_uint32_decode(struct c2_bufvec_cursor *cur, uint32_t *val)
-{
-	uint64_t	l_val;
-	int		rc;
-
-	C2_PRE(cur != NULL);
-	C2_PRE(val != NULL);
-
-	rc = bufvec_uint64_decode(cur, &l_val);
-	*val = (uint32_t)l_val;
-	return rc;
-}
-
-static int bufvec_uint16_encode(struct c2_bufvec_cursor *cur, uint16_t *val)
-{
-	uint64_t	l_val;
-
-	C2_PRE(cur != NULL);
-	C2_PRE(val != NULL);
-
-	l_val = (uint64_t)*val;
-	return bufvec_uint64_encode(cur, &l_val);
-}
-
-static int bufvec_uint16_decode(struct c2_bufvec_cursor *cur, uint16_t *val)
-{
-	int		rc;
-	uint64_t	l_val;
-
-	C2_PRE(cur != NULL);
-	C2_PRE(val != NULL);
-
-	rc = bufvec_uint64_decode(cur, &l_val);
-	*val = (uint16_t)l_val;
-	return rc;
-}
-
-static int bufvec_byte_encode(struct c2_bufvec_cursor *cur, uint8_t *val)
-{
-	uint64_t	l_val;
-
-	C2_PRE(cur != NULL);
-	C2_PRE(val != NULL);
-
-	l_val = (uint64_t)*val;
-	return bufvec_uint64_encode(cur, &l_val);
-}
-
-static int bufvec_byte_decode(struct c2_bufvec_cursor *cur, uint8_t *val)
-{
-	int		rc;
-	uint64_t	l_val;
-
-	C2_PRE(cur != NULL);
-	C2_PRE(val != NULL);
-
-	rc = bufvec_uint64_decode(cur, &l_val);
-	*val = (uint8_t)l_val;
-	return rc;
-}
-
-int c2_bufvec_byte(struct c2_bufvec_cursor *vc, uint8_t *val,
-		     enum c2_bufvec_what what)
-{
-	int rc;
-
-	C2_PRE(vc != NULL);
-	C2_PRE(val != NULL);
-
-	if (what == C2_BUFVEC_ENCODE)
-		rc = bufvec_byte_encode(vc, val);
-	else if (what == C2_BUFVEC_DECODE)
-		rc = bufvec_byte_decode(vc, val);
-	else
-	    rc = -ENOSYS;
-
-	return rc;
-}
-
-int c2_bufvec_uint16(struct c2_bufvec_cursor *vc, uint16_t *val,
-		     enum c2_bufvec_what what)
-{
-	int rc;
-
-	C2_PRE(vc != NULL);
-	C2_PRE(val != NULL);
-
-	if (what == C2_BUFVEC_ENCODE)
-		rc = bufvec_uint16_encode(vc, val);
-	else if( what == C2_BUFVEC_DECODE)
-		rc = bufvec_uint16_decode(vc, val);
-	else
-	    rc = -ENOSYS;
-
-	return rc;
-}
-
-int c2_bufvec_uint32(struct c2_bufvec_cursor *vc, uint32_t *val,
-		     enum c2_bufvec_what what)
-{
-	int rc;
-
-	C2_PRE(vc != NULL);
-	C2_PRE(val != NULL);
-
-	if (what == C2_BUFVEC_ENCODE)
-		rc = bufvec_uint32_encode(vc, val);
-	else if (what == C2_BUFVEC_DECODE)
-		rc = bufvec_uint32_decode(vc, val);
-	else
-	    rc = -ENOSYS;
-
-	return rc;
-}
-
-int c2_bufvec_uint64(struct c2_bufvec_cursor *vc, uint64_t *val,
-		     enum c2_bufvec_what what)
-{
-	int rc;
-
-	C2_PRE(vc != NULL);
-	C2_PRE(val != NULL);
-
-	if(what == C2_BUFVEC_ENCODE)
-		rc = bufvec_uint64_encode(vc, val);
-	else if(what == C2_BUFVEC_DECODE)
-		rc = bufvec_uint64_decode(vc, val);
-	else
-		rc = -ENOSYS;
-	return rc;
-}
-
-int c2_bufvec_array(struct c2_bufvec_cursor *vc, void *p_arr, uint64_t el_no,
-		    size_t max_size, size_t el_size, c2_bufvec_xcode_t el_proc,
-		    enum c2_bufvec_what what)
-{
-	int		 rc;
-	int		 i;
-	void		*bp;
-
-	C2_PRE(vc != NULL);
-	C2_PRE(p_arr != NULL);
-	C2_PRE(el_no != 0 || el_size * el_no <= max_size);
-	C2_PRE(el_proc != NULL);
-
-	bp = p_arr;
-	rc = c2_bufvec_uint64(vc, &el_no, what);
-	if (rc != 0)
-		return rc;
-
-	for (i = 0; i < el_no; ++i) {
-		rc = (*el_proc)(vc, bp, what);
-		if (rc != 0)
-			return rc;
-		bp += el_size;
-	}
-	return rc;
-}
-
-int c2_bufvec_bytes(struct c2_bufvec_cursor *vc, char **cpp, size_t size,
-		    size_t max_size, enum c2_bufvec_what what)
-{
-	int		 rc;
-	uint64_t	 pad_bytes;
-	char		*bp;
-	bool		 eob;
-
-	C2_PRE(vc != NULL);
-	C2_PRE(cpp != NULL);
-	C2_PRE(size != 0 || size <= max_size);
-
-	bp = *cpp;
-	C2_ASSERT(bp != NULL);
-	if (what == C2_BUFVEC_ENCODE) {
-		/* Encode the data + pad bytes into the bufvec */
-		rc = data_to_bufvec_copy(vc, bp, size);
-		if (rc != 0)
-			return rc;
-		pad_bytes = pad_bytes_get(size);
-		if (pad_bytes > 0)
-			rc = zero_padding_add(vc, pad_bytes);
-	} else if (what == C2_BUFVEC_DECODE) {
-		/*
-		   Decode the data in the bufvec and advance the cursor by
-		   pad_bytes to keep the bufvec cursor aligned.
-		*/
-		rc = bufvec_to_data_copy(vc, bp, size);
-		if (rc != 0)
-			return rc;
-		pad_bytes = pad_bytes_get(size);
-		if (pad_bytes > 0) {
-			eob = c2_bufvec_cursor_move(vc, pad_bytes);
-			C2_ASSERT(!eob);
-		}
-	} else
-		rc = -ENOSYS;
-
-	return rc;
-}
-/*
-int c2_bufvec_fop(struct c2_bufvec_cursor *vc, struct c2_fop *fop,
-		  enum c2_bufvec_what what)
-{
-	int			 rc;
-	struct c2_fop_type	*ftype;
-
-	C2_PRE(fop != NULL);
-	C2_PRE(vc != NULL);
-
-	ftype = fop->f_type;
-	C2_ASSERT(ftype->ft_ops != NULL);
-
-	if (what == C2_BUFVEC_ENCODE)
-		rc = ftype->ft_ops->fto_bufvec_encode(fop, vc);
-
-	else if (what == C2_BUFVEC_DECODE)
-		rc = ftype->ft_ops->fto_bufvec_decode(fop, vc);
-	else
-		rc = -EFAULT;
-
-	return rc;
-}
-*/
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
-
diff --git a/xcode/bufvec_xcode.h b/xcode/bufvec_xcode.h
deleted file mode 100644
index ad9f09e..0000000
--- a/xcode/bufvec_xcode.h
+++ /dev/null
@@ -1,198 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Subhash Arya <subhash_arya@xyratex.com>
- * Original creation date: 06/25/2011
- */
-
-#include "lib/vec.h"
-#include "fop/fop.h"
-
-#ifndef C2_BUFVEC_XCODE_H_
-#define C2_BUFVEC_XCODE_H_
-/**
-   @defgroup bufvec_xcode Generic Buffer Vector Encode/Decode routines.
-
-   Encode/Decode functions for encoding/decoding various atomic types into
-   buffer vectors. The functionality is very similar to the XDR functions.
-   These routines can be used to implement a type encode/decode routine for
-   each FOP, ADDB records etc.
-
-   XXX:
-   - We don't care about endianness currently. However, for this to work
-   across different platforms and architectures, correct endianness conversion
-   needs to be implemented. This will be taken up in the future.
-   - Currently, we assume that the bufvecs supplied to the transcode routines
-   have 8 byte aligned buffers with sizes multiple of 8 bytes.
-*/
-/** This is the  number of bytes per unit of external data */
-enum {
-	MAX_PAD_BYTES = 7,
-	BYTES_PER_XCODE_UNIT = 8,
-	XCODE_UNIT_ALIGNED_MASK = ~(MAX_PAD_BYTES)
-};
-
-/**
-  These are the operations that can be performed by the xcode routines on the
-  bufvecs. BUFVEC_ENCODE causes the type to be encoded into the bufvec.
-  BUFVEC_DECODE causes the type to be extracted from the bufvec.
-*/
-enum c2_bufvec_what {
-	C2_BUFVEC_ENCODE = 0,
-	C2_BUFVEC_DECODE = 1,
-};
-
-/** Enums used by generic fop encode-decode interfaces */
-enum {
-	FOP_FIELD_ZERO = 0,
-	ELEMENT_ZERO   = 0,
-	FOP_FIELD_ONE  = 1,
-};
-
-/** Format of fop sequence data */
-struct   c2_fop_sequence {
-	uint32_t         fs_count;
-	void		*fs_data;
-};
-
-/**
-  Encode/Decode the various C builtin atomic types into c2_bufvecs. Each of
-  these routines provide a single procedure for both encode and decode for each
-  data type. This helps to keep the encode and decode procedures for a data
-  type consistent.
-
-  @param vc Current bufvec cursor position. For 8 byte aligned buffers, which
-  is the case currently, the address at this cursor position would be 8-byte
-  aligned.
-  @param val Value which is to be encoded/decoded from the bufvec. Currently,
-  fix width datatypes are supported(uint8_t, uint16_t, uint32_t, uint64_t).
-  @param what The type of operation that is to be performed on the data -
-   encode OR decode.
-  @retval 0 On Success.
-  @retval -errno On Failure.
-*/
-
-int c2_bufvec_uint64(struct c2_bufvec_cursor *vc, uint64_t *val,
-		     enum c2_bufvec_what what);
-
-/**
-  Encode/Decode a 32 bit unsigned value into c2_bufvecs.
-  @see c2_bufvec_uint64()
-*/
-int c2_bufvec_uint32(struct c2_bufvec_cursor *vc, uint32_t *val,
-		     enum c2_bufvec_what what);
-/**
-  Encode/Decode a 16 bit unsigned value into c2_bufvecs.
-  @see c2_bufvec_uint64()
-*/
-int c2_bufvec_uint16(struct c2_bufvec_cursor *vc, uint16_t *val,
-		     enum c2_bufvec_what what);
-
-/**
-  Encode/Decode a 8  bit unsigned value into c2_bufvecs.
-  @see c2_bufvec_uint64()
-*/
-int c2_bufvec_byte(struct c2_bufvec_cursor *vc, uint8_t *val,
-		     enum c2_bufvec_what what);
-
-/**
- Generic procedure for each data type for encode / decode. This can be used
- for creating bufvec encode/decode for user defined data types. This can also
- be passed as a callback function for xcoding each element when xcoding
- an array (see c2_bufvec_array).
- */
-typedef int (*c2_bufvec_xcode_t)(struct c2_bufvec_cursor *vc, void *val, ...);
-
-/**
-  Encode/Decode an array of arbitary elements into a bufvec.
-  @param vc current position of the bufvec cursor
-  @param p_arr pointer to the array.
-  @param el_no number of elements.
-  @param max_size max number of elements.
-  @param el_size size in bytes of each element.
-  @param el_proc The bufvec xcode procedure to handle the encode/decode of each
-  element of the array.
-  @param what The type of operation to be performed on the array-encode or
-  decode.
-  @retval 0 on success.
-  @retval -errno on failure.
-*/
-int c2_bufvec_array(struct c2_bufvec_cursor *vc, void *p_arr, uint64_t el_no,
-		    size_t max_size, size_t el_size, c2_bufvec_xcode_t el_proc,
-		    enum c2_bufvec_what what);
-
-/**
-  Encode/Decode a sequence of bytes into a bufvec. For proper alignment,
-  padding bytes are added at the end of the sequence if the size is not a
-  multiple of 8 bytes during encode. This ensures that the bufvec cursor
-  always has an 8 byte aligned address.
-  @param vc current position of the bufvec cursor.
-  @param cpp pointer to the byte array.
-  @param size  count of bytes to be encoded/decoded.
-  @param max_size max no of bytes that can be encoded/decoded.
-  @param what The type of operation to be performed - encode or decode.
-  @retval 0 on success.
-  @retval -errno on failure.
-*/
-int c2_bufvec_bytes(struct c2_bufvec_cursor *vc, char **cpp, size_t size,
-		    size_t max_size, enum c2_bufvec_what what);
-
-/**
-  Encode/Decode a fop data into a bufvec. This function internally calls
-  the type specific encode/decode functions for a fop.
-  @param vc current position of the bufvec cursor.
-  @param fop The data for this fop is to be encoded/decoded.
-  @param what The type of operation to be performed - encode or decode.
-  @retval 0 On success.
-  @retval -errno on failure.
-*/
-int c2_xcode_bufvec_fop(struct c2_bufvec_cursor *vc, struct c2_fop *fop,
-		  enum c2_bufvec_what what);
-
-/** @} end of bufvec group */
-
-/**
-  Calculates the onwire size of fop data. This function internally calls
-  the fop field type specific functions to calculate the size
-
-  @param fop The data for this fop is to be encoded/decoded.
-
-  @retval Onwire size of the fop in bytes.
-*/
-size_t c2_xcode_fop_size_get(struct c2_fop *fop);
-
-/**
-  Returns true if the current fop field type is a byte array
-
-  @param fftype the fop field type.
-
-  @retval true if field type is a byte array.
-  @retval false if field type is not a byte array.
-*/
-bool c2_xcode_is_byte_array(const struct c2_fop_field_type *fftype);
-
-#endif
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 79
- *  scroll-step: 1
- *  End:
- */
-
-
diff --git a/xcode/bufvec_xcode_fop.c b/xcode/bufvec_xcode_fop.c
deleted file mode 100644
index 947157f..0000000
--- a/xcode/bufvec_xcode_fop.c
+++ /dev/null
@@ -1,400 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Subhash Arya <subhash_arya@xyratex.com>
- * Original creation date: 08/21/2011
- */
-
-#include "lib/cdefs.h"
-#include "fop/fop.h"
-#include "xcode/bufvec_xcode.h"
-#include "lib/errno.h"
-#include "lib/memory.h"
-
-/**
-   @addtogroup xcode
-
-   <b>Fop xcode</b>
-
-   See head comments in fop_format.h for overview of fop formats.
-
-   This file defines "universal" fop-to-bufvec encode/decode functions.
-   Main entry point is c2_bufvec_fop() which encodes/decodes fop data into/from
-   a bufvec. Encode/Decode operations are implemented by recursively descending
-   through the fop format tree. The implementation logic is the same that has
-   been used in net/ksunrpc/kxdr.c.
-
-   When handling a non-leaf (i.e., "aggregating") node of a fop format tree,
-   control branches though the xcode_type_disp[] function pointer array, using
-   aggregation type as an index. When a leaf (i.e., "atomic") node is reached,
-   control branches through the xcode_atom_disp[] function pointer array, using
-   atomic type as an index.
-
-   @{
- */
-
-/* Generic xcode function prototype for fop field types */
-typedef int (*c2_xcode_foptype_t)(struct c2_fop_field_type *ftype,
-				  struct c2_bufvec_cursor *cur, void *fop_data,
-				  enum c2_bufvec_what what);
-
-/** Array of xcode function pointers for each supported fop field type */
-static	c2_xcode_foptype_t xcode_type_disp[FFA_NR];
-
-/** Array of xcode function pointers for atomic fop field types */
-static int (*xcode_atom_disp[FPF_NR])(struct c2_bufvec_cursor *cur,
-	    void *fop_data, enum c2_bufvec_what);
-
-/**
-  Dispatcher array of xcode funtions for atomic field types.
-*/
-static int (*xcode_atom_disp[FPF_NR])(struct c2_bufvec_cursor *cur,
-	    void *fop_data,enum c2_bufvec_what what) = {
-	[FPF_VOID]  =  NULL,
-	[FPF_BYTE]  =  (void *)&c2_bufvec_byte,
-	[FPF_U32]   =  (void *)&c2_bufvec_uint32,
-	[FPF_U64]   =  (void *)&c2_bufvec_uint64
-};
-
-/**
-   Local xcode function declarations for various fop field types.See individual
-   headers for more details.
-*/
-static int xcode_bufvec_record(struct c2_fop_field_type *fftype,
-                               struct c2_bufvec_cursor *cur,
-			       void *fop_data, enum c2_bufvec_what what);
-
-static int xcode_bufvec_union(struct c2_fop_field_type *fftype,
-			      struct c2_bufvec_cursor *cur, void *fop_data,
-		              enum c2_bufvec_what what);
-
-static int xcode_bufvec_typedef(struct c2_fop_field_type *fftype,
-				struct c2_bufvec_cursor *cur, void *fop_data,
-				enum c2_bufvec_what what);
-
-static int xcode_bufvec_atom(struct c2_fop_field_type *fftype,
-		             struct c2_bufvec_cursor *cur, void *fop_data,
-		             enum c2_bufvec_what what);
-
-static int xcode_bufvec_sequence(struct c2_fop_field_type *fftype,
-				 struct c2_bufvec_cursor *cur, void *fop_data,
-				 enum c2_bufvec_what what);
-
-/** Dispatcher array of xcode function pointers for various fop field types */
-static c2_xcode_foptype_t xcode_type_disp[FFA_NR] = {
-	[FFA_RECORD]   = &xcode_bufvec_record,
-	[FFA_UNION]    = &xcode_bufvec_union,
-	[FFA_SEQUENCE] = &xcode_bufvec_sequence,
-	[FFA_TYPEDEF]  = &xcode_bufvec_typedef,
-	[FFA_ATOM]     = &xcode_bufvec_atom
-};
-
-/**
-   Helper function for handling non-leaf node of a fop format tree. Internally
-   calls dispatch function for specific aggregation type using it as index.
-   @see xcode_type_disp
-
-   @param fftype field type for the fop is to be encoded/decoded.
-   @param cur current position of bufvec cursor.
-   @param fop_data pointer to fop data to be encode/decoded.
-   @param fieldno The fop field no.
-   @param elno The element no to be encoded/decoded, usually non-zero for
-    sequence type fop fields.
-   @param what The type of operation to be performed - encode or decode.
-
-   @retval 0 On success.
-   @retval -errno on failure.
-*/
-static int xcode_fop_subtype(struct c2_fop_field_type *fftype,
-			     struct c2_bufvec_cursor *cur, void *fop_data,
-			     uint32_t fieldno, uint32_t elno,
-			     enum c2_bufvec_what what)
-{
-	struct c2_fop_field_type        *ff_subtype;
-	uint32_t			 fop_field_aggr_type;
-	void				*obj_field_addr;
-
-	C2_PRE(fftype != NULL);
-	C2_PRE(cur != NULL);
-	C2_PRE(fop_data != NULL);
-	C2_PRE(fieldno < fftype->fft_nr);
-
-	obj_field_addr = c2_fop_type_field_addr(fftype, fop_data, fieldno,
-						elno);
-	ff_subtype = fftype->fft_child[fieldno]->ff_type;
-	fop_field_aggr_type = ff_subtype->fft_aggr;
-	return xcode_type_disp[fop_field_aggr_type]
-			      (ff_subtype, cur, obj_field_addr, what);
-}
-
-/**
-   Encode/Decode a record fop field type into a bufvec. We traverse each field
-   of the record recursively, till a atomic field is reached and xcode it into
-   the bufvec.
-
-   @param fftype field type for the fop is to be encoded/decoded.
-   @param cur current position of bufvec cursor.
-   @param fop_data pointer to fop data to be encode/decoded.
-   @param what The type of operation to be performed - encode or decode.
-
-   @retval 0 On success.
-   @retval -errno on failure.
-*/
-static int xcode_bufvec_record(struct c2_fop_field_type *fftype,
-			       struct c2_bufvec_cursor *cur,
-			       void *fop_data, enum c2_bufvec_what what)
-{
-	size_t fft_cnt;
-	int    rc;
-
-	for (rc = 0, fft_cnt = 0; rc == 0 && fft_cnt < fftype->fft_nr;
-	     ++fft_cnt)
-		rc = xcode_fop_subtype(fftype, cur, fop_data, fft_cnt,
-				       ELEMENT_ZERO, what);
-	return rc;
-}
-
-/**
-  Returns true if the current fop field type is a byte array
-
-  @param fftype the fop field type.
-
-  @retval true if field type is a byte array.
-  @retval false if field type is not a byte array.
-*/
-bool c2_xcode_is_byte_array(const struct c2_fop_field_type *fftype)
-{
-	C2_ASSERT(fftype->fft_aggr == FFA_SEQUENCE);
-	return fftype->fft_child[1]->ff_type == &C2_FOP_TYPE_BYTE;
-}
-
-/**
-   Encode/Decode a byte array into a bufvec. While decoding from a bufvec,
-   memory required by the array is calculated and allocated. Freeing
-   this memory is the responsibility of upper layers.
-
-   @param fftype field type for the fop is to be encoded/decoded.
-   @param cur current position of bufvec cursor.
-   @param fop_data pointer to fop data to be encode/decoded.
-   @param what The type of operation to be performed - encode or decode.
-
-   @retval 0 On success.
-   @retval -errno on failure.
-*/
-static int xcode_bufvec_byte_seq(struct c2_bufvec_cursor *cur, char **b_seq,
-				  uint32_t nr, enum c2_bufvec_what what)
-{
-	C2_PRE(cur != NULL);
-	C2_PRE(b_seq != NULL);
-
-	if(what == C2_BUFVEC_DECODE) {
-		C2_ALLOC_ARR(*b_seq, nr);
-                if (*b_seq == NULL)
-			return -ENOMEM;
-		}
-	return c2_bufvec_bytes(cur, b_seq, (size_t)nr, ~0, what);
-}
-
-/**
-  Encodes/Decodes fop data which belongs to a sequence type fop field into a
-  bufvec. If the sequence is a plain byte array, it calls corresponding function
-  to encode/decode bytes into/from a bufvec. If not, it traverses the fop field
-  tree and calls the corresponding xcode function for that field type.
-  While decode, the memory required by the sequence data  is calculated and
-  allocated. Freeing this memory is the responsibility of upper layers.
-
-  @param fftype field type for the fop is to be encoded/decoded.
-  @param cur current position of bufvec cursor.
-  @param fop_data pointer to fop sequence data to be encode/decoded.
-  @param what The type of operation to be performed - encode or decode.
-
-  @retval 0 On success.
-  @retval -errno on failure.
-*/
-static int xcode_bufvec_sequence(struct c2_fop_field_type *fftype,
-				 struct c2_bufvec_cursor *cur, void *fop_data,
-				 enum c2_bufvec_what what)
-{
-
-	struct c2_fop_sequence  *fseq;
-	int                      rc;
-	uint32_t                 nr;
-	int		         cnt;
-	void		        *s_data;
-	size_t			 elsize;
-	struct c2_fop_memlayout *ellay;
-
-	C2_PRE(fftype != NULL);
-	C2_PRE(cur != NULL);
-	C2_PRE(fop_data != NULL);
-
-	fseq = fop_data;
-	if (what == C2_BUFVEC_ENCODE) {
-		nr = fseq->fs_count;
-		/* First encode the "count" field into the bufvec */
-		rc = xcode_atom_disp[FPF_U32](cur, &nr, C2_BUFVEC_ENCODE);
-		if (rc != 0)
-			return rc;
-		/*
-		 * Check if its a byte array and call the byte array encode
-		 *  function.
-		 */
-		if (c2_xcode_is_byte_array(fftype))
-			return xcode_bufvec_byte_seq(cur,
-				(char **)&fseq->fs_data, nr, what);
-	} else if (what  == C2_BUFVEC_DECODE) {
-		rc = xcode_atom_disp[FPF_U32](cur, &nr, C2_BUFVEC_DECODE);
-			if(rc != 0)
-				return rc;
-		fseq->fs_count = nr;
-		/* Detect if it's byte sequence */
-		if(c2_xcode_is_byte_array(fftype)) {
-			return xcode_bufvec_byte_seq(cur,
-				(char **)&fseq->fs_data, nr, what);
-		}
-		/*
-		 * This is an sequence of atomic types or aggr types(record,
-		 * sequence etc). During decode, calculate and allocate memory
-		 * for the sequence based on its in-memory layout.
-		 */
-		ellay = fftype->fft_child[1]->ff_type->fft_layout;
-		elsize = ellay->fm_sizeof;
-		s_data = c2_alloc(elsize * nr);
-		if(s_data == NULL)
-			return -ENOMEM;
-		fseq->fs_data = s_data;
-	}
-	for (rc = 0, cnt = 0; rc == 0 && cnt < nr; ++cnt)
-		rc = xcode_fop_subtype(fftype, cur, fseq, FOP_FIELD_ONE,
-		                       cnt, what);
-
-	return rc;
-}
-
-/**
-  Enc/Decodes a typedef fop field into/from a bufvec.
-
-  @param fftype field type for the fop is to be encoded/decoded.
-  @param cur current position of bufvec cursor.
-  @param fop_data pointer to fop typedef data to be encode/decoded.
-  @param what The type of operation to be performed - encode or decode.
-
-  @retval 0 On success.
-  @retval -errno on failure.
-*/
-static int xcode_bufvec_typedef(struct c2_fop_field_type *fftype,
-				struct c2_bufvec_cursor *cur, void *fop_data,
-				enum c2_bufvec_what what )
-{
-	C2_PRE(fftype != NULL);
-	C2_PRE(cur != NULL);
-	C2_PRE(fop_data != NULL);
-
-	return xcode_fop_subtype(fftype, cur, fop_data, FOP_FIELD_ZERO,
-				 ELEMENT_ZERO, what);
-}
-
-/** XXX: Currently unions are not supported. */
-int xcode_bufvec_union(struct c2_fop_field_type *fftype,
-		       struct c2_bufvec_cursor *cur, void *fop_data,
-		       enum c2_bufvec_what what)
-{
-	return -EIO;
-}
-
-/**
-  Helper function to dispatch the xcode functions for atomic fop field types
-
-  @param fftype field type for the fop is to be encoded/decoded.
-  @param cur current position of bufvec cursor.
-  @param fop_data pointer to fop atomic data to be encode/decoded.
-  @param what The type of operation to be performed - encode or decode.
-
-  @retval 0 On success.
-  @retval -errno on failure.
-*/
-static int xcode_bufvec_atom(struct c2_fop_field_type *fftype,
-		             struct c2_bufvec_cursor *cur, void *fop_data,
-		             enum c2_bufvec_what what)
-{
-	C2_PRE(fftype != NULL);
-	C2_PRE(cur != NULL);
-	C2_PRE(fop_data != NULL);
-	C2_PRE(fftype->fft_u.u_atom.a_type < ARRAY_SIZE(xcode_atom_disp));
-
-	return xcode_atom_disp[fftype->fft_u.u_atom.a_type](cur, fop_data, what);
-}
-
-
-/**
-  Calls correspoding xcode function based on the fop top level field type.
-
-  @param cur current position of the bufvec cursor.
-  @param fftype Top level field type for the fop is to be encoded/decoded.
-  @param data  Pointer to the data to be encoded/decoded.
-  @param what The type of operation to be performed - encode or decode.
-
-  @pre cur != NULL;
-  @pre fftype != NULL;
-  @pre data != NULL;
-  @pre fftype->fft_aggr < ARRAY_SIZE(xcode_type_disp);
-
-  @retval 0 On success.
-  @retval -errno on failure.
-*/
-int c2_xcode_bufvec_fop_type(struct c2_bufvec_cursor *cur,
-		       struct c2_fop_field_type *fftype, void *data,
-		       enum c2_bufvec_what what)
-{
-	C2_PRE(cur != NULL);
-	C2_PRE(fftype != NULL);
-	C2_PRE(data != NULL);
-	C2_PRE(fftype->fft_aggr < ARRAY_SIZE(xcode_type_disp));
-
-	return xcode_type_disp[fftype->fft_aggr](fftype, cur, data, what);
-}
-
-/**
-  Encode/Decode a fop data into a bufvec. This function internally calls
-  the type specific encode/decode functions for a fop.
-
-  @param vc current position of the bufvec cursor.
-  @param fop The data for this fop is to be encoded/decoded.
-  @param what The type of operation to be performed - encode or decode.
-
-  @retval 0 On success.
-  @retval -errno on failure.
-*/
-int c2_xcode_bufvec_fop(struct c2_bufvec_cursor *cur, struct c2_fop *fop,
-		  enum c2_bufvec_what what)
-{
-	C2_PRE(cur != NULL);
-	C2_PRE(fop != NULL);
-
-	return c2_xcode_bufvec_fop_type(cur, fop->f_type->ft_top,
-	                                c2_fop_data(fop), what);
-}
-/** @} */
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
diff --git a/xcode/bufvec_xcode_size.c b/xcode/bufvec_xcode_size.c
deleted file mode 100644
index 309a68d..0000000
--- a/xcode/bufvec_xcode_size.c
+++ /dev/null
@@ -1,329 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Subhash Arya <subhash_arya@xyratex.com>
- * Original creation date: 08/21/2011
- */
-
-#include "lib/cdefs.h"
-#include "fop/fop.h"
-#include "xcode/bufvec_xcode.h"
-#include "lib/errno.h"
-#include "lib/memory.h"
-
-/**
-   @addtogroup xcode
-
-   <b>Fop xcode</b>
-
-   See head comments in fop_format.h for overview of fop formats.
-
-   This file defines generic functions to calculate the onwire fop size.
-   Main entry point is c2_xcode_fop_size_get() which calculates the onwire
-   size (in bytes) of the fop data that would be encode/decoded into/from
-   a bufvec. The size is calculated by recursively descending through the fop
-   format tree. The implementation logic is the same that has been used in
-   net/ksunrpc/kxdr.c.
-
-   When handling a non-leaf (i.e., "aggregating") node of a fop format tree,
-   control branches though the xcode_size_disp[] function pointer array, using
-   aggregation type as an index.
-
-   @{
- */
-
-
-/* Generic function prototype for calculating the size of fop field types */
-typedef void (*c2_xcode_foptype_sizeget_t)(size_t *size,
-	     struct c2_fop_field_type *ftype, void *fop_data);
-
-/**
-   Array of function pointers to calcluate onwire size for each supported
-   fop field type
-*/
-static	c2_xcode_foptype_sizeget_t xcode_size_disp[FFA_NR];
-
-
-/**
-   Local function declarations for various fop field types.See individual
-   headers for more details.
-*/
-static void xcode_record_size_get(size_t *size,
-            struct c2_fop_field_type *fftype, void *fop_data);
-
-static void xcode_union_size_get(size_t *size, struct c2_fop_field_type *fftype,
-				void *fop_data);
-
-static void xcode_typedef_size_get(size_t *size,
-	    struct c2_fop_field_type *fftype, void *fop_data);
-
-static void xcode_atom_size_get(size_t *size, struct c2_fop_field_type *fftype,
-			       void *fop_data);
-
-static void xcode_sequence_size_get(size_t *size,
-	    struct c2_fop_field_type *fftype, void *fop_data);
-
-/** Dispatcher array of "size_get" vectors for various fop field types */
-static c2_xcode_foptype_sizeget_t xcode_size_disp[FFA_NR] = {
-	[FFA_RECORD]   = xcode_record_size_get,
-	[FFA_UNION]    = xcode_union_size_get,
-	[FFA_SEQUENCE] = xcode_sequence_size_get,
-	[FFA_TYPEDEF]  = xcode_typedef_size_get,
-	[FFA_ATOM]     = xcode_atom_size_get
-};
-
-/** Calculates the onwire size of the atomic field type. Currently, each
-    xcode unit uses 8 bytes to satisfy the alignment requirements.
-    @see xcode/bufvec_xcode.h
-
-    @param size Pointer to calculated onwire size value for the fop.
-    @param fftype Field type for the fop for which the size is to be calculated.
-    @param fop_data pointer to fop data.
-
-*/
-static void xcode_atom_size_get(size_t *size, struct c2_fop_field_type *fftype,
-				  void *fop_data)
-{
-	C2_PRE(size != NULL);
-
-	*size += BYTES_PER_XCODE_UNIT;
-}
-
-/**
-   Helper function for handling non-leaf node of a fop format tree. Internally
-   calls dispatch function for specific aggregation type using it as index.
-   @see xcode_size_disp
-
-   @param size Pointer to calculated onwire size value for the fop.
-   @param fftype Field type for the fop for which the size is to be calculated.
-   @param fieldno The fop field no.
-   @param elno The element number for which the size is to be calculated,
-    usually non-zero for sequence type fop fields.
-
-*/
-static void xcode_subtype_size(size_t *size, struct c2_fop_field_type *fftype,
-			      void *fop_data, uint32_t fieldno, uint32_t elno)
-{
-	struct c2_fop_field_type        *ff_subtype;
-	uint32_t			 fop_field_aggr_type;
-	void				*obj_field_addr;
-
-	C2_PRE(fftype != NULL);
-	C2_PRE(fop_data != NULL);
-	C2_PRE(fieldno < fftype->fft_nr);
-	C2_PRE(size != NULL);
-
-	obj_field_addr = c2_fop_type_field_addr(fftype, fop_data, fieldno,
-						elno);
-	ff_subtype = fftype->fft_child[fieldno]->ff_type;
-	fop_field_aggr_type = ff_subtype->fft_aggr;
-	return xcode_size_disp[fop_field_aggr_type]
-	      (size, ff_subtype, obj_field_addr);
-}
-
-/**
-   Calculates the size of record onwire fop field type into a bufvec. We
-   traverse each field of the record recursively, till a atomic field is
-   reached, calculate its size and add it to overall size.
-
-    @param size Pointer to calculated onwire size value for the fop.
-    @param fftype Field type for the fop for which the size is to be calculated.
-    @param fop_data pointer to fop data.
-
-*/
-static void xcode_record_size_get(size_t *size,
-				  struct c2_fop_field_type *fftype,
-				  void *fop_data)
-{
-	size_t fft_cnt;
-	size_t rec_size = 0;
-
-	C2_PRE(size != NULL);
-	C2_PRE(fftype != NULL);
-	C2_PRE(fop_data != NULL);
-
-	for (fft_cnt = 0; fft_cnt < fftype->fft_nr;
-	     ++fft_cnt) {
-		 /* A fop record based field cannot contain more than 1 element
-		   unlike a sequence based field. We pass this(ELEMENT_ZERO) as
-		   a parameter to xcode_subtype_size */
-		 xcode_subtype_size(&rec_size, fftype, fop_data, fft_cnt,
-				     ELEMENT_ZERO);
-	}
-	C2_ASSERT(rec_size != 0);
-	*size += rec_size;
-}
-
-
-/**
-   Calculates the size of an onwire byte array. The onwire size of the byte
-   array is calculated to be the sum of "count" + "pad_bytes" (if any). The
-   pad bytes are required to keep the byte array 8 byte aligned.
-
-    @param count No of bytes in the byte array.
-
-    @retval The onwire size of the byte array (sum of count and pad_bytes).
-*/
-static size_t xcode_byte_seq_size_get(uint32_t count)
-{
-	size_t		size;
-
-	C2_PRE(count != 0);
-
-        size  = (count + MAX_PAD_BYTES) & XCODE_UNIT_ALIGNED_MASK;
-	return size;
-}
-
-/**
-  Calculates the onwire size of fop data which belongs to a sequence type fop
-  field . If the sequence is a plain byte array, it calls corresponding function
-  to calculate onwire size of  byte-array. If not, it traverses the fop field
-  tree and calls the corresponding function to calculate size for that field
-  type.
-
-   @param size Pointer to calculated onwire size value for the fop.
-   @param fftype Field type for the fop for which the size is to be calculated.
-   @param fop_data pointer to fop data.
-
-*/
-static void xcode_sequence_size_get(size_t *size,
-	    struct c2_fop_field_type *fftype, void *fop_data)
-{
-
-	struct c2_fop_sequence   *fseq;
-	uint32_t                 nr;
-	int		         cnt;
-	size_t			 seq_size = 0;
-
-	C2_PRE(fftype != NULL);
-	C2_PRE(fop_data != NULL);
-	C2_PRE(size != NULL);
-
-	fseq = fop_data;
-	nr = fseq->fs_count;
-	xcode_atom_size_get(size, fftype, fop_data);
-	/*
-	 * Check if its a byte array and call function to calc byte array size.
-	 */
-	if (c2_xcode_is_byte_array(fftype))
-		seq_size = xcode_byte_seq_size_get(nr);
-	else {
-		/*
-		 * This is an sequence of atomic types or aggr types(record,
-		 * sequence etc). Traverse through each subtype and calculate
-		 * size.
-		 */
-		for (cnt = 0; cnt < nr; ++cnt) {
-			/*
-			 * A fop sequence's "zeroth" field contains the count
-			 * and "first" field contains the actual data. We pass
-			 * this as an argument to xcode_subtype_size
-			 */
-			xcode_subtype_size(&seq_size, fftype, fseq,
-					   FOP_FIELD_ONE, cnt);
-		}
-	}
-	*size += seq_size;
-}
-
-/**
-   Calculates the onwire size of typedef fop field.
-
-   @param size Pointer to calculated onwire size value for the fop.
-   @param fftype Field type for the fop for which the size is to be calculated.
-   @param fop_data pointer to fop data.
-
-   @retval 0 On success.
-   @retval -errno on failure.
-*/
-static void xcode_typedef_size_get(size_t *size,
-	    struct c2_fop_field_type *fftype, void *fop_data)
-{
-	C2_PRE(fftype != NULL);
-	C2_PRE(fop_data != NULL);
-
-	/* A fop typedef field contains just one field and one element. These
-	 * are passed as arguments to xcode_subtype_size (FOP_FIELD_ZERO,
-	 * ELEMENT_ZERO.
-	 */
-	return xcode_subtype_size(size, fftype, fop_data, FOP_FIELD_ZERO,
-				  ELEMENT_ZERO);
-}
-
-/** XXX: Currently unions are not supported. */
-static void xcode_union_size_get(size_t *size, struct c2_fop_field_type *fftype,
-				 void *fop_data)
-{
-	return;
-}
-
-/**
-  Calls correspoding function to calculate onwire size based on the fop top
-  level field type.
-
-   @param size Pointer to calculated onwire size value for the fop.
-   @param fftype Field type for the fop for which the size is to be calculated.
-   @param fop_data pointer to fop data.
-
-   @pre fftype != NULL;
-   @pre data != NULL;
-   @pre fftype->fft_aggr < ARRAY_SIZE(xcode_size_disp);
-
-   @retval 0 On success.
-   @retval -errno on failure.
-*/
-void c2_xcode_fop_type_size_get(size_t *size,
-		                struct c2_fop_field_type *fftype, void *data)
-{
-	C2_PRE(fftype != NULL);
-	C2_PRE(data != NULL);
-	C2_PRE(fftype->fft_aggr < ARRAY_SIZE(xcode_size_disp));
-
-	return xcode_size_disp[fftype->fft_aggr](size, fftype, data);
-}
-
-/**
-  Calculates the onwire size of fop data. This function internally calls
-  the fop field type specific functions to calculate the size
-
-  @param fop The data for this fop is to be encoded/decoded.
-
-  @retval Onwire size of the fop in bytes.
-*/
-
-size_t c2_xcode_fop_size_get(struct c2_fop *fop)
-{
-	size_t		size = 0;
-
-	C2_PRE(fop != NULL);
-
-	c2_xcode_fop_type_size_get(&size, fop->f_type->ft_top,
-				   c2_fop_data(fop));
-	return size;
-}
-C2_EXPORTED(c2_xcode_fop_size_get);
-
-/** @} */
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
diff --git a/xcode/cursor.c b/xcode/cursor.c
deleted file mode 100644
index 9c2a099..0000000
--- a/xcode/cursor.c
+++ /dev/null
@@ -1,136 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Nikita Danilov <nikita_danilov@xyratex.com>
- * Original creation date: 28-Dec-2011
- */
-
-#include "lib/assert.h"
-
-#include "xcode/xcode.h"
-
-/**
-   @addtogroup xcode
-
-   @{
- */
-
-struct c2_xcode_cursor_frame *c2_xcode_cursor_top(struct c2_xcode_cursor *it)
-{
-	C2_PRE(IS_IN_ARRAY(it->xcu_depth, it->xcu_stack));
-	return &it->xcu_stack[it->xcu_depth];
-}
-
-int c2_xcode_next(struct c2_xcode_cursor *it)
-{
-	struct c2_xcode_cursor_frame *top;
-	struct c2_xcode_cursor_frame *next;
-	const struct c2_xcode_type   *xt;
-	int                           nr;
-
-	C2_PRE(it->xcu_depth >= 0);
-
-	top = c2_xcode_cursor_top(it);
-	xt  = top->s_obj.xo_type;
-	nr  = xt->xct_nr;
-
-	C2_ASSERT(c2_xcode_type_invariant(xt));
-
-	switch (top->s_flag) {
-	case C2_XCODE_CURSOR_NONE:
-		top->s_flag = C2_XCODE_CURSOR_PRE;
-		break;
-	case C2_XCODE_CURSOR_IN:
-		switch (xt->xct_aggr) {
-		case C2_XA_RECORD:
-		case C2_XA_TYPEDEF:
-			++top->s_fieldno;
-			break;
-		case C2_XA_SEQUENCE:
-			if (top->s_fieldno == 1 &&
-			    ++top->s_elno < c2_xcode_tag(&top->s_obj))
-				; /* nothing */
-			else {
-				top->s_elno = 0;
-				++top->s_fieldno;
-			}
-			break;
-		case C2_XA_UNION:
-			if (top->s_fieldno != 0) {
-				top->s_fieldno = nr;
-				break;
-			}
-			for (; top->s_fieldno < nr; ++top->s_fieldno) {
-				if (c2_xcode_tag(&top->s_obj) ==
-				    xt->xct_child[top->s_fieldno].xf_tag)
-					break;
-			}
-			break;
-		case C2_XA_OPAQUE:
-		default:
-			C2_IMPOSSIBLE("wrong aggregation type");
-		}
-		/* fall through */
-	case C2_XCODE_CURSOR_PRE:
-		if (top->s_fieldno < nr) {
-			top->s_flag = C2_XCODE_CURSOR_IN;
-			if (xt->xct_aggr != C2_XA_ATOM) {
-				int result;
-
-				++it->xcu_depth;
-				next = c2_xcode_cursor_top(it);
-				result = c2_xcode_subobj(&next->s_obj,
-							 &top->s_obj,
-							 top->s_fieldno,
-							 top->s_elno);
-				if (result != 0)
-					return result;
-				next->s_fieldno = 0;
-				next->s_elno    = 0;
-				next->s_flag    = C2_XCODE_CURSOR_PRE;
-			}
-		} else
-			top->s_flag = C2_XCODE_CURSOR_POST;
-		break;
-	case C2_XCODE_CURSOR_POST:
-		if (--it->xcu_depth < 0)
-			return 0;
-		top = c2_xcode_cursor_top(it);
-		C2_ASSERT(top->s_flag < C2_XCODE_CURSOR_POST);
-		top->s_flag = C2_XCODE_CURSOR_IN;
-		break;
-	default:
-		C2_IMPOSSIBLE("wrong order");
-	}
-	return +1;
-}
-
-void c2_xcode_skip(struct c2_xcode_cursor *it)
-{
-	c2_xcode_cursor_top(it)->s_flag = C2_XCODE_CURSOR_POST;
-}
-
-/** @} end of xcode group */
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
diff --git a/xcode/ff2c/.gitignore b/xcode/ff2c/.gitignore
deleted file mode 100644
index 44ac511..0000000
--- a/xcode/ff2c/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-ff2c
\ No newline at end of file
diff --git a/xcode/ff2c/Makefile.am b/xcode/ff2c/Makefile.am
deleted file mode 100644
index 87b6605..0000000
--- a/xcode/ff2c/Makefile.am
+++ /dev/null
@@ -1,9 +0,0 @@
-noinst_LTLIBRARIES                = libcolibri-xcode-ff2c.la
-libcolibri_xcode_ff2c_la_SOURCES  = lex.c lex.h parser.c parser.h sem.h sem.c gen.h gen.c
-
-noinst_PROGRAMS                   = ff2c
-ff2c_SOURCES                      = ff2c.c
-ff2c_LDADD                        = $(top_builddir)/xcode/ff2c/libcolibri-xcode-ff2c.la
-
-INCLUDES                          = -I. -I$(top_srcdir) -I$(top_srcdir)/include
-
diff --git a/xcode/ff2c/bnf b/xcode/ff2c/bnf
deleted file mode 100644
index 365e24d..0000000
--- a/xcode/ff2c/bnf
+++ /dev/null
@@ -1,33 +0,0 @@
-ff             ::= statement-list
-statement-list ::= statement | statement ";" statement-list
-statement      ::= require | declaration
-require        ::= "require" pathname
-declaration    ::= type identifier
-type           ::= atomic | compound | typename
-atomic         ::= "void" | "u8" | "u32" | "u64" | "opaque"
-compound       ::= kind "{" field-list "}"
-kind           ::= "record" | "union" | "sequence"
-field-list     ::= field | field ";" field-list
-field          ::= declaration tag escape
-tag            ::= empty | ":" expression
-escape         ::= empty | "[" identifier "]"
-
-tokens:
-
-identifier
-require
-string
-void
-u8
-u32
-u64
-opaque
-record
-union
-sequence
-typedef
-open (brace)
-close (brace)
-semicolon
-tag
-escape
diff --git a/xcode/ff2c/ff2c.c b/xcode/ff2c/ff2c.c
deleted file mode 100644
index 6bd0f6f..0000000
--- a/xcode/ff2c/ff2c.c
+++ /dev/null
@@ -1,204 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Nikita Danilov <nikita_danilov@xyratex.com>
- * Original creation date: 02-Jan-2012
- */
-
-/**
-   @addtogroup xcode
-
-   <b>ff2c</b>
-
-   ff2c is a simple translator, taking as an input a set of descriptions of
-   desired serialized representations and producing a set of C declarations of
-   types having given serialized representations. In addition, definitions of
-   xcode data (c2_xcode_type and c2_xcode_field) for generated types is
-   produced.
-
-   Serialized representation descriptions are given in a language with the
-   following grammar:
-
-   @verbatim
-ff             ::= statement-list
-statement-list ::= statement | statement ';' statement-list
-statement      ::= require | declaration
-require        ::= 'require' '"' pathname '"'
-declaration    ::= type identifier
-type           ::= atomic | compound | opaque | identifier
-atomic         ::= 'void' | 'u8' | 'u32' | 'u64'
-compound       ::= kind '{' field-list '}'
-opaque         ::= '*' identifier
-kind           ::= 'record' | 'union' | 'sequence'
-field-list     ::= field | field ';' field-list
-field          ::= declaration tag escape
-tag            ::= empty | ':' expression
-escape         ::= empty | '[' identifier ']'
-   @endverbatim
-
-The language is case-sensitive. Tokens are separated by whitespace and C-style
-comments.
-
-The meaning of language constructs is explained in the following example:
-@verbinclude "./sample.ff"
-
-  The translator is structured as a sequence of 4 passes:
-
-      - lexical analysis (lex.c): takes a buffer as an input and produces a
-        stream of tokens;
-
-      - parser (parser.h): builds a parse tree out of stream of tokens. Every
-        node in the tree have the same structure: it contains a token and a list
-        of child nodes;
-
-      - semantical pass (sem.h): traverses parse tree and builds a tree of
-        semantical nodes, corresponding to types and fields. Semantical nodes
-        are "higher level" than syntax nodes are more closely aligned with the
-        requirements of the following generation pass;
-
-      - generation (gen.h): take semantic tree and produce corresponding C
-        declarations and definitions.
-   @{
- */
-
-#include <err.h>
-#include <unistd.h>                           /* getopt, close, open */
-#include <sys/mman.h>                         /* mmap, munmap */
-#include <sys/types.h>
-#include <sys/stat.h>                         /* stat */
-#include <fcntl.h>                            /* O_RDONLY */
-#include <libgen.h>                           /* dirname */
-#include <string.h>                           /* basename, strdup, strlen */
-#include <stdlib.h>                           /* malloc, free */
-#include <ctype.h>                            /* toupper */
-#include <stdio.h>                            /* fopen, fclose */
-
-#include "xcode/ff2c/lex.h"
-#include "xcode/ff2c/parser.h"
-#include "xcode/ff2c/sem.h"
-#include "xcode/ff2c/gen.h"
-
-int main(int argc, char **argv)
-{
-	int          fd;
-	int          optch;
-	int          result;
-	const char  *path;
-	void        *addr;
-	struct stat  buf;
-	char        *scratch;
-	char        *ch;
-	char        *bname;
-	char        *gname;
-	char        *out_h;
-	char        *out_c;
-	size_t       len;
-	FILE        *c;
-	FILE        *h;
-
-	struct ff2c_context   ctx;
-	struct ff2c_term     *t;
-	struct ff2c_ff        ff;
-	struct ff2c_gen_opt   opt;
-
-	while ((optch = getopt(argc, argv, "")) != -1) {
-	}
-
-	path = argv[optind];
-	fd = open(path, O_RDONLY);
-	if (fd == -1)
-		err(1, "cannot open \"%s\"", path);
-	result = fstat(fd, &buf);
-	if (result == -1)
-		err(1, "cannot fstat \"%s\"", path);
-	addr = mmap(NULL, buf.st_size, PROT_READ, MAP_SHARED, fd, 0);
-	if (addr == MAP_FAILED)
-		err(1, "cannot mmap \"%s\"", path);
-
-	scratch = fmt("%s", path);
-	len = strlen(scratch);
-	if (len > 3 && strcmp(scratch + len - 3, ".ff") == 0)
-		*(scratch + len - 3) = 0;
-
-	out_h = fmt("%s.h", scratch);
-	out_c = fmt("%s.c", scratch);
-
-	bname = basename(scratch);
-	gname = fmt("__COLIBRI_%s_%s_H__", basename(dirname(scratch)), bname);
-
-	for (ch = gname; *ch != 0; ch++) {
-		*ch = toupper(*ch);
-		if (strchr("ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_", *ch) == NULL)
- 			*ch = '_';
-	}
-
-	opt.go_basename  = bname;
-	opt.go_guardname = gname;
-
-	c = fopen(out_c, "w");
-	if (c == NULL)
-		err(1, "cannot open \"%s\" for writing", out_c);
-
-	h = fopen(out_h, "w");
-	if (h == NULL)
-		err(1, "cannot open \"%s\" for writing", out_h);
-
-	memset(&ctx, 0, sizeof ctx);
-	memset(&ff, 0, sizeof ff);
-
-	ff2c_context_init(&ctx, addr, buf.st_size);
-	result = ff2c_parse(&ctx, &t);
-	if (result != 0)
-		err(2, "cannot parse");
-
-	ff2c_sem_init(&ff, t);
-
-	opt.go_out = h;
-	ff2c_h_gen(&ff, &opt);
-	opt.go_out = c;
-	ff2c_c_gen(&ff, &opt);
-
-	ff2c_sem_fini(&ff);
-	ff2c_term_fini(t);
-	ff2c_context_fini(&ctx);
-
-	fclose(h);
-	fclose(c);
-
-	free(out_c);
-	free(out_h);
-	free(gname);
-	free(scratch);
-	result = munmap(addr, buf.st_size);
-	if (result == -1)
-		warn("cannot munmap");
-	result = close(fd);
-	if (result == -1)
-		warn("cannot close");
-	return EXIT_SUCCESS;
-}
-
-/** @} end of xcode group */
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
diff --git a/xcode/ff2c/gen.c b/xcode/ff2c/gen.c
deleted file mode 100644
index 4fea597..0000000
--- a/xcode/ff2c/gen.c
+++ /dev/null
@@ -1,250 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Nikita Danilov <nikita_danilov@xyratex.com>
- * Original creation date: 30-Dec-2011
- */
-
-/**
-   @addtogroup xcode
-
-   @{
- */
-
-#include <stdbool.h>
-#include <stdio.h>
-#include <assert.h>
-#include <string.h>                         /* strcpy, strcat, strrchr */
-
-#include "xcode/ff2c/lex.h"
-#include "xcode/ff2c/parser.h"
-#include "xcode/ff2c/sem.h"
-#include "xcode/ff2c/gen.h"
-
-FILE *thefile;
-
-#define out(...) fprintf(thefile, __VA_ARGS__)
-
-static void indent(int depth)
-{
-	static const char ruler[] = "\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t";
-
-	out("%*.*s", depth, depth, ruler);
-}
-
-#define TOK(tok) (int)(tok)->ft_len, (int)(tok)->ft_len, (tok)->ft_val
-#define T(term) TOK(&(term)->fn_tok)
-
-static void type_h(const struct ff2c_type *t, int depth);
-
-static void field_h(const struct ff2c_field *f, int depth)
-{
-	if (f->f_decl != NULL) {
-		indent(depth);
-		out("%s", f->f_decl);
-	} else {
-		type_h(f->f_type, depth);
-		out(" %s", f->f_name);
-	}
-	out(";\n");
-}
-
-static void type_h(const struct ff2c_type *t, int depth)
-{
-	const struct ff2c_field *f = t->t_field.l_head;
-
-	indent(depth);
-	out("%s {\n", t->t_c_name);
-	if (t->t_union) {
-		field_h(f, depth + 1);
-		f = f->f_next;
-		indent(depth + 1);
-		out("union {\n");
-		depth++;
-	}
-	for (; f != NULL; f = f->f_next)
-		field_h(f, depth + 1);
-	if (t->t_union) {
-		indent(depth);
-		out("} u;\n");
-		depth--;
-	}
-	indent(depth);
-	out("}");
-}
-
-int ff2c_h_gen(const struct ff2c_ff *ff, const struct ff2c_gen_opt *opt)
-{
-	const struct ff2c_require *r;
-	const struct ff2c_type    *t;
-
-	thefile = opt->go_out;
-
-	out("/* This file is automatically generated from %s.ff */\n\n",
-	    opt->go_basename);
-	out("#ifndef %s\n"
-	    "#define %s\n\n", opt->go_guardname, opt->go_guardname);
-	out("#include <sys/types.h>\n\n");
-	out("#include \"xcode/xcode.h\"\n\n");
-
-	for (r = ff->ff_require.l_head; r != NULL; r = r->r_next)
-		out("#include %s\n", r->r_path);
-	out("\n");
-	for (t = ff->ff_type.l_head; t != NULL; t = t->t_next) {
-		if (t->t_public) {
-			type_h(t, 0);
-			out(";\n\n");
-		}
-	}
-	out("\n");
-	for (t = ff->ff_type.l_head; t != NULL; t = t->t_next) {
-		if (t->t_public)
-			out("extern struct c2_xcode_type *%s;\n", t->t_xc_name);
-	}
-	out("\n"
-	    "void c2_xc_%s_init(void);\n"
-	    "void c2_xc_%s_fini(void);\n\n", opt->go_basename, opt->go_basename);
-	out("/* %s */\n"
-	    "#endif\n\n", opt->go_guardname);
-	return 0;
-}
-
-static void field_def(const struct ff2c_type *t,
-		      const struct ff2c_field *f, int i)
-{
-	out("\t_%s._child[%i] = (struct c2_xcode_field) {\n"
-	    "\t\t.xf_name   = \"%s\",\n"
-	    "\t\t.xf_type   = %s,\n"
-	    "\t\t.xf_tag    = %s,\n"
-	    "\t\t.xf_opaque = %s,\n"
-	    "\t\t.xf_offset = offsetof(%s, %s)\n"
-	    "\t};\n",
-	    t->t_name, i, f->f_name, f->f_xc_type,
-	    f->f_tag ?: "0",
-	    f->f_escape ?: "NULL",
-	    t->t_c_name, f->f_c_name);
-}
-
-static void type_fields(const struct ff2c_type *t)
-{
-	const struct ff2c_field *f;
-	int                      i;
-
-	for (i = 0, f = t->t_field.l_head; f != NULL; f = f->f_next, i++)
-		field_def(t, f, i);
-}
-
-static void type_decl(const struct ff2c_type *t)
-{
-	out("%sstruct c2_xcode_type *%s",
-	    t->t_public ? "" : "static ", t->t_xc_name);
-}
-
-static void type_def(const struct ff2c_type *t)
-{
-	static const char *caggr[] = {
-		[FTT_VOID]     = "C2_XA_ATOM",
-		[FTT_U8]       = "C2_XA_ATOM",
-		[FTT_U32]      = "C2_XA_ATOM",
-		[FTT_U64]      = "C2_XA_ATOM",
-		[FTT_OPAQUE]   = "C2_XA_OPAQUE",
-		[FTT_RECORD]   = "C2_XA_RECORD",
-		[FTT_UNION]    = "C2_XA_UNION",
-		[FTT_SEQUENCE] = "C2_XA_SEQUENCE"
-	};
-	out("static struct _%s_s {\n"
-	    "\tstruct c2_xcode_type _type;\n"
-	    "\tstruct c2_xcode_field _child[%i];\n"
-	    "} _%s = {\n"
-	    "\t._type = {\n"
-	    "\t\t.xct_aggr   = %s,\n"
-	    "\t\t.xct_name   = \"%s\",\n"
-	    "\t\t.xct_sizeof = sizeof (%s),\n"
-	    "\t\t.xct_nr     = %i\n"
-	    "\t}\n"
-	    "};\n\n",
-	    t->t_name, t->t_nr, t->t_name,
-	    caggr[t->t_term->fn_head->fn_tok.ft_type],
-	    t->t_name, t->t_c_name, t->t_nr);
-	type_decl(t);
-	out(" = &_%s._type;\n"
-	    "C2_BASSERT(offsetof(struct _%s_s, _child[0]) ==\n"
-	    "\toffsetof(struct c2_xcode_type, xct_child[0]));\n\n",
-	    t->t_name, t->t_name);
-}
-
-int ff2c_c_gen(const struct ff2c_ff *ff, const struct ff2c_gen_opt *opt)
-{
-	const struct ff2c_type   *t;
-	const struct ff2c_escape *e;
-
-	thefile = opt->go_out;
-
-	out("/* This file is automatically generated from %s.ff */\n\n",
-	    opt->go_basename);
-
-	out("#include \"lib/cdefs.h\"                       /* offsetof */\n");
-	out("#include \"lib/assert.h\"\n");
-	out("#include \"xcode/xcode.h\"\n\n");
-	out("#include \"%s.h\"\n\n", opt->go_basename);
-
-	for (t = ff->ff_type.l_head; t != NULL; t = t->t_next) {
-		if (t->t_public) {
-			type_decl(t);
-			out(";\n");
-		}
-	}
-	out("\n");
-	for (t = ff->ff_type.l_head; t != NULL; t = t->t_next) {
-		if (!t->t_public) {
-			type_decl(t);
-			out(";\n");
-		}
-	}
-	out("\n");
-	for (e = ff->ff_escape.l_head; e != NULL; e = e->e_next) {
-		out("int %s(const struct c2_xcode_obj *par,\n"
-		    "\t\tconst struct c2_xcode_type **out);\n", e->e_escape);
-	}
-	out("\n");
-	for (t = ff->ff_type.l_head; t != NULL; t = t->t_next)
-		type_def(t);
-
-	out("\n\n"
-	    "void c2_xc_%s_init(void)\n"
-	    "{\n", opt->go_basename);
-
-	for (t = ff->ff_type.l_head; t != NULL; t = t->t_next) {
-		type_fields(t);
-		out("\n");
-	}
-	out("}\n"
-	    "void c2_xc_%s_fini(void)\n{}\n", opt->go_basename);
-
-	return 0;
-}
-
-/** @} end of xcode group */
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
diff --git a/xcode/ff2c/gen.h b/xcode/ff2c/gen.h
deleted file mode 100644
index 118ed0f..0000000
--- a/xcode/ff2c/gen.h
+++ /dev/null
@@ -1,56 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Nikita Danilov <nikita_danilov@xyratex.com>
- * Original creation date: 30-Dec-2011
- */
-
-#ifndef __COLIBRI_XCODE_FF2C_GEN_H__
-#define __COLIBRI_XCODE_FF2C_GEN_H__
-
-/**
-   @addtogroup xcode
- */
-/** @{ */
-
-#include <stdio.h>                              /* FILE */
-
-/* import */
-struct ff2c_ff;
-
-struct ff2c_gen_opt {
-	const char *go_basename;
-	const char *go_guardname;
-	FILE       *go_out;
-};
-
-int ff2c_h_gen(const struct ff2c_ff *ff, const struct ff2c_gen_opt *opt);
-int ff2c_c_gen(const struct ff2c_ff *ff, const struct ff2c_gen_opt *opt);
-
-/** @} end of xcode group */
-
-/* __COLIBRI_XCODE_FF2C_GEN_H__ */
-#endif
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
diff --git a/xcode/ff2c/lex.c b/xcode/ff2c/lex.c
deleted file mode 100644
index 2539336..0000000
--- a/xcode/ff2c/lex.c
+++ /dev/null
@@ -1,267 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Nikita Danilov <nikita_danilov@xyratex.com>
- * Original creation date: 30-Dec-2011
- */
-
-/**
-   @addtogroup xcode
-
-   @{
- */
-
-#include <string.h>                   /* strchr, strlen */
-#include <stdbool.h>                  /* bool */
-#include <stdio.h>                    /* snprintf */
-#include <errno.h>
-#include <assert.h>
-#include <err.h>
-
-#include "xcode/ff2c/lex.h"
-
-static const struct keyword {
-	const char           *k_name;
-	enum ff2c_token_type  k_type;
-} keywords[] = {
-	{ "void",     FTT_VOID },
-	{ "require",  FTT_REQUIRE },
-	{ "u8",       FTT_U8 },
-	{ "u32",      FTT_U32 },
-	{ "u64",      FTT_U64 },
-	{ "record",   FTT_RECORD },
-	{ "union",    FTT_UNION },
-	{ "sequence", FTT_SEQUENCE },
-	{ "{",        FTT_OPEN },
-	{ "}",        FTT_CLOSE },
-	{ ";",        FTT_SEMICOLON },
-	{ NULL,       0 }
-};
-
-static void ctx_move(struct ff2c_context *ctx, size_t nob)
-{
-	assert(nob <= ctx->fc_remain);
-
-	for (; nob > 0; --nob, --ctx->fc_remain, ++ctx->fc_pt) {
-		if (*ctx->fc_pt == '\n') {
-			ctx->fc_line++;
-			ctx->fc_col = 0;
-		} else
-			ctx->fc_col++;
-	}
-}
-
-static void ctx_step(struct ff2c_context *ctx)
-{
-	ctx_move(ctx, 1);
-}
-
-#define SAFE(ctx, cond) ((ctx)->fc_remain > 0 && (cond))
-
-static bool at(struct ff2c_context *ctx, char c)
-{
-	return SAFE(ctx, *ctx->fc_pt == c);
-}
-
-static bool at_string(struct ff2c_context *ctx, const char *s, size_t n)
-{
-	return ctx->fc_remain >= n && memcmp(ctx->fc_pt, s, n) == 0;
-}
-
-static bool is_start(char c)
-{
-	return ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z') || c == '_';
-}
-
-static bool is_middle(char c)
-{
-	return ('0' <= c && c <= '9') || is_start(c);
-}
-
-static void tok_end(struct ff2c_context *ctx, struct ff2c_token *tok)
-{
-	tok->ft_len = ctx->fc_pt - tok->ft_val;
-}
-
-static void skip_space(struct ff2c_context *ctx)
-{
-	static const char space[] = " \t\v\n\r";
-	const char       *start;
-
-	do {
-		start = ctx->fc_pt;
-		while (SAFE(ctx, strchr(space, *ctx->fc_pt)))
-			ctx_step(ctx);
-		if (at_string(ctx, "/*", 2)) {
-			ctx_step(ctx);
-			do {
-				ctx_step(ctx);
-				if (ctx->fc_remain < 2)
-					errx(2, "Unterminated comment");
-			} while (!at_string(ctx, "*/", 2));
-			ctx_move(ctx, 2);
-		}
-	} while (start != ctx->fc_pt);
-}
-
-static bool get_literal(struct ff2c_context *ctx, struct ff2c_token *tok)
-{
-	ctx_step(ctx);
-	skip_space(ctx);
-	tok->ft_val = ctx->fc_pt;
-	while (SAFE(ctx, is_middle(*ctx->fc_pt)))
-		ctx_step(ctx);
-	tok_end(ctx, tok);
-	return tok->ft_len > 0;
-}
-
-int ff2c_token_get(struct ff2c_context *ctx, struct ff2c_token *tok)
-{
-	const struct keyword *kw;
-
-	/*
-	 * Majority of token types are constant keywords, detected by iterating
-	 * over keywords[] array.
-	 *
-	 * Others are (not entirely coincidentally) identifiable by their first
-	 * character, which makes analyzing very simple.
-	 */
-
-	if (ctx->fc_depth > 0) {
-		*tok = ctx->fc_stack[--ctx->fc_depth];
-		return +1;
-	}
-
-	skip_space(ctx);
-	if (ctx->fc_remain == 0)
-		return 0;
-	for (kw = &keywords[0]; kw->k_name != NULL; ++kw) {
-		size_t      len = strlen(kw->k_name);
-		const char *pt = ctx->fc_pt;
-
-		if (ctx->fc_remain >= len && !memcmp(pt, kw->k_name, len)) {
-			tok->ft_type = kw->k_type;
-			tok->ft_val  = pt;
-			tok->ft_len  = len;
-			ctx_move(ctx, len);
-			return +1;
-		}
-	}
-
-	if (at(ctx, ':')) {
-		if (get_literal(ctx, tok)) {
-			tok->ft_type = FTT_TAG;
-			return +1;
-		} else {
-			warnx("\":\" must be followed by a tag");
-			return -EINVAL;
-		}
-	} else if (at(ctx, '[')) {
-		if (get_literal(ctx, tok)) {
-			skip_space(ctx);
-			if (at(ctx, ']')) {
-				ctx_step(ctx);
-				tok->ft_type = FTT_ESCAPE;
-				return +1;
-			}
-		}
-		warnx("\"[\" must be followed by an escape and \"]\"");
-		return -EINVAL;
-	} else if (at(ctx, '*')) {
-		if (get_literal(ctx, tok)) {
-			tok->ft_type = FTT_OPAQUE;
-			return +1;
-		} else {
-			warnx("\"*\" must be followed by a type name");
-			return -EINVAL;
-		}
-	} else if (at(ctx, '"')) {
-		tok->ft_val  = ctx->fc_pt;
-		tok->ft_type = FTT_STRING;
-		do
-			ctx_step(ctx);
-		while (SAFE(ctx, *ctx->fc_pt != '"'));
-		if (at(ctx, '"')) {
-			ctx_step(ctx);
-			tok_end(ctx, tok);
-			return +1;
-		}
-	} else if (SAFE(ctx, is_start(*ctx->fc_pt))) {
-		tok->ft_val  = ctx->fc_pt;
-		tok->ft_type = FTT_IDENTIFIER;
-		do
-			ctx_step(ctx);
-		while (SAFE(ctx, is_middle(*ctx->fc_pt)));
-		tok_end(ctx, tok);
-		return +1;
-	}
-	return -ENOENT;
-}
-
-void ff2c_token_put(struct ff2c_context *ctx, struct ff2c_token *tok)
-{
-	assert(ctx->fc_depth < FF2C_CTX_STACK_MAX);
-
-	ctx->fc_stack[ctx->fc_depth++] = *tok;
-}
-
-void ff2c_context_init(struct ff2c_context *ctx, const char *buf, size_t size)
-{
-	ctx->fc_remain = ctx->fc_size = size;
-	ctx->fc_origin = ctx->fc_pt   = buf;
-}
-
-void ff2c_context_fini(struct ff2c_context *ctx)
-{
-}
-
-int ff2c_context_loc(struct ff2c_context *ctx, int nr, char *buf)
-{
-	return snprintf(buf, nr, "[%i:%i] %zu/%zu: '%c'",
-			ctx->fc_line, ctx->fc_col, ctx->fc_pt - ctx->fc_origin,
-			ctx->fc_size, *ctx->fc_pt);
-}
-
-const char *ff2c_token_type_name[] = {
-	[FTT_IDENTIFIER] = "IDENTIFIER",
-	[FTT_REQUIRE]    = "REQUIRE",
-	[FTT_STRING]     = "STRING",
-	[FTT_VOID]       = "VOID",
-	[FTT_U8]         = "U8",
-	[FTT_U32]        = "U32",
-	[FTT_U64]        = "U64",
-	[FTT_OPAQUE]     = "OPAQUE",
-	[FTT_RECORD]     = "RECORD",
-	[FTT_UNION]      = "UNION",
-	[FTT_SEQUENCE]   = "SEQUENCE",
-	[FTT_OPEN]       = "OPEN",
-	[FTT_CLOSE]      = "CLOSE",
-	[FTT_SEMICOLON]  = "SEMICOLON",
-	[FTT_TAG]        = "TAG",
-	[FTT_ESCAPE]     = "ESCAPE"
-};
-
-/** @} end of xcode group */
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
diff --git a/xcode/ff2c/lex.h b/xcode/ff2c/lex.h
deleted file mode 100644
index d262103..0000000
--- a/xcode/ff2c/lex.h
+++ /dev/null
@@ -1,159 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Nikita Danilov <nikita_danilov@xyratex.com>
- * Original creation date: 30-Dec-2011
- */
-
-#ifndef __COLIBRI_XCODE_FF2C_LEX_H__
-#define __COLIBRI_XCODE_FF2C_LEX_H__
-
-/**
-   @addtogroup xcode
-
-   <b>ff2c. Lexical analysis.</b>
-
-   Very simple hand-crafted lexer.
-
-   Input is a contiguous memory buffer (buffer vector can be supported easily).
-
-   ff2c_context data-structure tracks current input position. To make meaningful
-   error reporting possible (line, column) coordinates are also tracked.
-
-   Next input token is returned by ff2c_token_get(). Returned token points
-   (ff2c_token::ft_val) directly into the input buffer. Specifically, token
-   value is not NUL terminated.
- */
-/** @{ */
-
-#include <sys/types.h>                  /* size_t */
-/* export */
-struct ff2c_context;
-struct ff2c_token;
-
-/** Token types. For each value, a regular expression, matching the tokens of
-    this type is provided. CONT means "[a-zA-Z_0-9]*" */
-enum ff2c_token_type {
-	/** "[a-zA-Z_]CONT" */
-	FTT_IDENTIFIER = 1,
-	/** "require" */
-	FTT_REQUIRE,
-	/** "\"[^\"]*\"" */
-	FTT_STRING,
-	/** "void" */
-	FTT_VOID,
-	/** "u8" */
-	FTT_U8,
-	/** "u32" */
-	FTT_U32,
-	/** "u64" */
-	FTT_U64,
-	/** "\*CONT" */
-	FTT_OPAQUE,
-	/** "record" */
-	FTT_RECORD,
-	/** "union" */
-	FTT_UNION,
-	/** "sequence" */
-	FTT_SEQUENCE,
-	/** "{" */
-	FTT_OPEN,
-	/** "}" */
-	FTT_CLOSE,
-	/** ";" */
-	FTT_SEMICOLON,
-	/** ":CONT" */
-	FTT_TAG,
-	/** "\[CONT\]" */
-	FTT_ESCAPE
-};
-
-/** Human-readable names of values in ff2c_token_type */
-extern const char *ff2c_token_type_name[];
-
-/** Token */
-struct ff2c_token {
-	enum ff2c_token_type  ft_type;
-	/** Pointer into input buffer, where token starts. */
-	const char           *ft_val;
-	/** Length of token's value in bytes. */
-	size_t                ft_len;
-};
-
-/**
-   Returns the next token.
-
-   @retval +ve: success. "tok" is filled with the new token
-   @retval   0: end of the input buffer reached
-   @retval -ve: malformed input, error code is returned.
- */
-int  ff2c_token_get(struct ff2c_context *ctx, struct ff2c_token *tok);
-/**
-   Put token back.
-
-   The next call to ff2c_token_get() will return this token.
-
-   When multiple tokens are put back, they are returned in LIFO order. Up to
-   FF2C_CTX_STACK_MAX tokens can be returned.
- */
-void ff2c_token_put(struct ff2c_context *ctx, struct ff2c_token *tok);
-
-enum { FF2C_CTX_STACK_MAX = 32 };
-
-/** Lexer context. */
-struct ff2c_context {
-	/** Input buffer. */
-	const char        *fc_origin;
-	/** Size of input buffer. */
-	size_t             fc_size;
-	/** Current position in the input buffer ("point"). */
-	const char        *fc_pt;
-	/** Number of characters remaining in the input buffer. */
-	size_t             fc_remain;
-	/** Stack of returned tokens. */
-	struct ff2c_token  fc_stack[FF2C_CTX_STACK_MAX];
-	/** Current stack depth. 0 means the stack is empty. */
-	int                fc_depth;
-	/** Current line, defined as the number of \n symbols before the
-	    point. */
-	int                fc_line;
-	/** Current column, defined as the number of characters between the
-	    point and previous \n or beginning of the input buffer, whichever is
-	    less. */
-	int                fc_col;
-};
-
-void ff2c_context_init(struct ff2c_context *ctx, const char *buf, size_t size);
-void ff2c_context_fini(struct ff2c_context *ctx);
-/**
-   Print human-readable description of the current input position in "buf".
- */
-int  ff2c_context_loc(struct ff2c_context *ctx, int nr, char *buf);
-
-/** @} end of xcode group */
-
-/* __COLIBRI_XCODE_FF2C_LEX_H__ */
-#endif
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
diff --git a/xcode/ff2c/parser.c b/xcode/ff2c/parser.c
deleted file mode 100644
index 60bc817..0000000
--- a/xcode/ff2c/parser.c
+++ /dev/null
@@ -1,252 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Nikita Danilov <nikita_danilov@xyratex.com>
- * Original creation date: 30-Dec-2011
- */
-
-/**
-   @addtogroup xcode
-
-   @{
- */
-
-#include <errno.h>
-#include <err.h>
-#include <stdlib.h>                        /* malloc, NULL */
-#include <string.h>                        /* memset */
-
-#include "xcode/ff2c/parser.h"
-
-static struct ff2c_term *alloc(void)
-{
-	struct ff2c_term *term;
-
-	term = malloc(sizeof *term);
-	if (term == NULL)
-		err(2, "Cannot allocate term (%zu bytes)", sizeof *term);
-	memset(term, 0, sizeof *term);
-	return term;
-}
-
-static void error(struct ff2c_context *ctx, const char *msg)
-{
-	char buf[100];
-
-	ff2c_context_loc(ctx, sizeof buf, buf);
-	errx(2, "%s: %s", buf, msg);
-}
-
-static struct ff2c_term *add(struct ff2c_term *term)
-{
-	struct ff2c_term *new;
-
-	new = alloc();
-	new->fn_parent = term;
-	return term->fn_tail = *(term->fn_head == NULL ?
-				 &term->fn_head : &term->fn_tail->fn_next) = new;
-}
-
-static void token(struct ff2c_context *ctx, struct ff2c_term *term,
-		  struct ff2c_token *tok)
-{
-	switch (tok->ft_type) {
-	case FTT_TAG:
-		term->fn_type = FNT_TAG;
-		break;
-	case FTT_ESCAPE:
-		term->fn_type = FNT_ESCAPE;
-		break;
-	default:
-		err(3, "impossible token");
-	}
-	term->fn_tok = *tok;
-}
-
-static int declaration(struct ff2c_context *ctx, struct ff2c_term *term);
-
-static int field(struct ff2c_context *ctx, struct ff2c_term *term)
-{
-	int result;
-
-	result = declaration(ctx, term);
-	if (result == 0) {
-		struct ff2c_token tok;
-
-		while (1) {
-			result = ff2c_token_get(ctx, &tok);
-			if (result > 0) {
-				result = 0;
-				if (tok.ft_type == FTT_TAG ||
-				    tok.ft_type == FTT_ESCAPE)
-					token(ctx, add(term), &tok);
-				else {
-					ff2c_token_put(ctx, &tok);
-					break;
-				}
-			} else
-				error(ctx, "unterminated field");
-		}
-	}
-	return result;
-}
-
-static int field_list(struct ff2c_context *ctx, struct ff2c_term *term)
-{
-	int result;
-	struct ff2c_token tok;
-
-	result = ff2c_token_get(ctx, &tok);
-	if (result > 0 && tok.ft_type == FTT_OPEN) {
-		do
-			result = field(ctx, add(term));
-		while (result == 0 && (result = ff2c_token_get(ctx, &tok) > 0) &&
-		       tok.ft_type == FTT_SEMICOLON);
-		if (result > 0) {
-			if (tok.ft_type == FTT_CLOSE)
-				return 0;
-			else
-				error(ctx, "\"}\" or \";\"expected");
-		} else if (result == 0)
-			error(ctx, "unterminated field list");
-	} else
-		error(ctx, "\"{\" expected");
-	return -EINVAL;
-}
-
-static int type(struct ff2c_context *ctx, struct ff2c_term *term)
-{
-	int result;
-
-	result = ff2c_token_get(ctx, &term->fn_tok);
-	if (result > 0) {
-		switch (term->fn_tok.ft_type) {
-		case FTT_VOID:
-		case FTT_U8:
-		case FTT_U32:
-		case FTT_U64:
-		case FTT_OPAQUE:
-			term->fn_type = FNT_ATOMIC;
-			return 0;
-		case FTT_RECORD:
-		case FTT_UNION:
-		case FTT_SEQUENCE:
-			term->fn_type = FNT_COMPOUND;
-			return field_list(ctx, term);
-		case FTT_IDENTIFIER:
-			term->fn_type = FNT_TYPENAME;
-			return 0;
-		default:
-			break;
-		}
-	}
-	error(ctx, "type expected");
-	return -EINVAL;
-}
-
-static int declaration(struct ff2c_context *ctx, struct ff2c_term *term)
-{
-	int result;
-
-	term->fn_type = FNT_DECLARATION;
-	result = type(ctx, add(term));
-	if (result == 0) {
-		result = ff2c_token_get(ctx, &term->fn_tok);
-		if (result > 0 && term->fn_tok.ft_type == FTT_IDENTIFIER)
-			return 0;
-		else
-			error(ctx, "declaration must be terminated "
-			      "with an identifier");
-	}
-	return -EINVAL;
-}
-
-static int require(struct ff2c_context *ctx, struct ff2c_term *term)
-{
-	int result;
-
-	term->fn_type = FNT_REQUIRE;
-	result = ff2c_token_get(ctx, &term->fn_tok);
-	if (result > 0 && term->fn_tok.ft_type == FTT_STRING)
-		return 0;
-	else {
-		error(ctx, "\"require\" must be followed by a pathname");
-		return -EINVAL;
-	}
-}
-
-static int statement(struct ff2c_context *ctx, struct ff2c_term *term)
-{
-	int result;
-	struct ff2c_token tok;
-
-	result = ff2c_token_get(ctx, &tok);
-	if (result > 0) {
-		if (tok.ft_type == FTT_REQUIRE)
-			result = require(ctx, term);
-		else {
-			ff2c_token_put(ctx, &tok);
-			result = declaration(ctx, term);
-		}
-	}
-	return result;
-}
-
-static int ff(struct ff2c_context *ctx, struct ff2c_term *term)
-{
-	int               result;
-	struct ff2c_token tok;
-
-	term->fn_type = FNT_FF;
-	do
-		result = statement(ctx, add(term));
-	while (result == 0 && (result = ff2c_token_get(ctx, &tok) > 0) &&
-	       tok.ft_type == FTT_SEMICOLON);
-	return result;
-}
-
-int ff2c_parse(struct ff2c_context *ctx, struct ff2c_term **out)
-{
-	*out = alloc();
-	return ff(ctx, *out);
-}
-
-void ff2c_term_fini(struct ff2c_term *term)
-{
-}
-
-const char *ff2c_term_type_name[] = {
-	[FNT_FF]          = "FF",
-	[FNT_REQUIRE]     = "REQUIRE",
-	[FNT_DECLARATION] = "DECLARATION",
-	[FNT_ATOMIC]      = "ATOMIC",
-	[FNT_COMPOUND]    = "COMPOUND",
-	[FNT_TYPENAME]    = "TYPENAME",
-	[FNT_TAG]         = "TAG",
-	[FNT_ESCAPE]      = "ESCAPE",
-};
-
-/** @} end of xcode group */
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
diff --git a/xcode/ff2c/parser.h b/xcode/ff2c/parser.h
deleted file mode 100644
index d2500d8..0000000
--- a/xcode/ff2c/parser.h
+++ /dev/null
@@ -1,77 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Nikita Danilov <nikita_danilov@xyratex.com>
- * Original creation date: 30-Dec-2011
- */
-
-#ifndef __COLIBRI_XCODE_FF2C_PARSER_H__
-#define __COLIBRI_XCODE_FF2C_PARSER_H__
-
-/**
-   @addtogroup xcode
-
-   <b>ff2c. Parser.</b>
-
-   Recursive-descent parser.
- */
-/** @{ */
-
-#include "xcode/ff2c/lex.h"
-
-/* export */
-struct ff2c_term;
-
-enum ff2c_term_type {
-	FNT_FF = 1,
-	FNT_REQUIRE,
-	FNT_DECLARATION,
-	FNT_ATOMIC,
-	FNT_COMPOUND,
-	FNT_TYPENAME,
-	FNT_TAG,
-	FNT_ESCAPE,
-	FNT_NR
-};
-extern const char *ff2c_term_type_name[];
-
-struct ff2c_term {
-	enum ff2c_term_type  fn_type;
-	struct ff2c_term    *fn_parent;
-	struct ff2c_term    *fn_head;
-	struct ff2c_term    *fn_tail;
-	struct ff2c_term    *fn_next;
-	struct ff2c_token    fn_tok;
-};
-
-int ff2c_parse(struct ff2c_context *ctx, struct ff2c_term **out);
-void ff2c_term_fini(struct ff2c_term *term);
-
-
-/** @} end of xcode group */
-
-/* __COLIBRI_XCODE_FF2C_PARSER_H__ */
-#endif
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
diff --git a/xcode/ff2c/sample.ff b/xcode/ff2c/sample.ff
deleted file mode 100644
index 57faf52..0000000
--- a/xcode/ff2c/sample.ff
+++ /dev/null
@@ -1,147 +0,0 @@
-/* ff2c input file. */
-
-/*
- * The following command generates ./xcode/ff2c/sample.{c,h}
- *
- * $ ./xcode/ff2c/ff2c ./xcode/ff2c/sample.ff
- *
- */
-
-/*
- * C-style comments are used, white-spaces between tokens are ignored.
- *
- * Semicolon is used as a _separator_, not a _terminator_. That is, various
- * lists (fields, declarations) have a form E0 ; E1 ; ... ; EN.
- */
-
-/*
- * "require" statement introduces a dependency on other source file. For each
- * "require", an #include directive is produced, which includes corresponding
- * header file, "lib/vec.h" in this case
- */
-require "lib/vec";
-require "fop/fop";
-
-/*
- * Following in this file are type declaration statements, which all have form
- * "type-declaration type-name".
- */
-
-/* define "fid" as a RECORD type, having two U64 fields. */
-record {
-        u64 f_container;
-        u64 f_offset
-} fid;
-/*
- * Produced C declaration is:
- *                            struct fid {
- *                                    uint64_t f_container;
- *                                    uint64_t f_offset;
- *                            };
- */
-
-/*
- * Define "optfid" as a UNION containing a byte discriminator field (o_flag),
- * followed either by a fid (provided o_flag's value is 1) or a U32 value
- * o_short (provided o_flag's value is 3).
- */
-union {
-        u8  o_flag;
-        fid o_fid   :1;
-        u32 o_short :3
-} optfid;
-/*
- * Produced C declaration is:
- *
- *                            struct optfid {
- *                                    uint8_t o_flag;
- *                                    union {
- *                                            struct fid o_fid;
- *                                            uint32_t o_short;
- *                                    } u;
- *                            };
- */
-
-/* define optfidarray as a counted array of optfid instances. */
-sequence {
-        u64    ofa_nr;
-        optfid ofa_data
-} optfidarray;
-/*
- * Produced C declaration is:
- *
- *                            struct optfidarray {
- *                                    uint64_t ofa_nr;
- *                                    struct optfid *ofa_data;
- *                            };
- */
-
-/*
- * define fixarray as a fixed-size array of optfids. Array size is NR, which
- * must be defined in one of "require"-d files.
- */
-sequence {
-        void   fa_none :NR;
-        optfid fa_data
-} fixarray;
-/*
- * Produced C declaration is:
- *
- *                            struct fixarray {
- *                                    c2_void_t fa_none;
- *                                    struct optfid *fa_data;
- *                            };
- */
-
-/* demonstrate declaration of a more complex structure. */
-record {
-        fid      p_fid;
-
-        /*
-	 * "p_cred" is opaque field. It is represented as a pointer to struct
-         * c2_cred. The actual type of pointed object is returned by
-         * c2_package_cred_get() function.
-	 */
-       *c2_cred  p_cred [c2_package_cred_get];
-
-        /*
-	 * field's type can be defined in-place. ff2c generates a name of the
-         * form "parent_type"_"field_name" for such anonymous type.
-	 */
-        sequence {
-                u32 s_nr;
-                record {
-                        u8       e_flag;
-                        fixarray e_payload;
-                        record {
-                                u64 d_0;
-                                u64 d_1
-                        } e_datum
-                } s_el
-        } p_name
-} package
-/*
- * Produced C declaration is:
- *
- *                            struct package {
- *                                    struct fid p_fid;
- *                                    struct c2_cred *p_cred;
- *                                    struct package_p_name {
- *                                            uint32_t s_nr;
- *                                            struct p_name_s_el {
- *                                                    uint8_t e_flag;
- *                                                    struct fixarray e_payload;
- *                                                    struct s_el_e_datum {
- *                                                            uint64_t d_0;
- *                                                            uint64_t d_1;
- *                                                    } e_datum;
- *                                            } s_el;
- *                                    } p_name;
- *                            };
- *
- * And (in sample.c):
- *
- * int c2_package_cred_get(const struct c2_xcode_obj *par,
- *                         const struct c2_xcode_type **out);
- *
- */
diff --git a/xcode/ff2c/sem.c b/xcode/ff2c/sem.c
deleted file mode 100644
index 3ab2764..0000000
--- a/xcode/ff2c/sem.c
+++ /dev/null
@@ -1,275 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Nikita Danilov <nikita_danilov@xyratex.com>
- * Original creation date: 01-Jan-2012
- */
-
-/**
-   @addtogroup xcode
-
-   @{
- */
-
-#include <err.h>
-#include <stdio.h>                        /* asprintf */
-#include <stdarg.h>
-#include <assert.h>
-#include <stdlib.h>                       /* malloc */
-#include <string.h>                       /* memset, strrchr */
-
-#include "xcode/ff2c/parser.h"
-#include "xcode/ff2c/sem.h"
-
-static void *alloc(size_t nr)
-{
-	void *data;
-
-	data = malloc(nr);
-	if (data == NULL)
-		err(1, "cannot allocate %zu bytes.", nr);
-	memset(data, 0, nr);
-	return data;
-}
-
-__attribute__((format(printf, 1, 2)))
-char *fmt(const char *format, ...)
-{
-	va_list  args;
-	char    *out;
-
-	va_start(args, format);
-	if (vasprintf(&out, format, args) == -1)
-		err(1, "cannot allocate string.");
-	va_end(args);
-	return out;
-}
-
-static void *add(struct ff2c_list *list, void *obj)
-{
-	return list->l_tail = *(list->l_head == NULL ?
-				&list->l_head : (void **)list->l_tail) = obj;
-}
-
-static void *add_new(struct ff2c_list *list, size_t size)
-{
-	return add(list, alloc(size));
-}
-
-#define TOK(tok) (int)(tok)->ft_len, (int)(tok)->ft_len, (tok)->ft_val
-#define T(term) TOK(&(term)->fn_tok)
-
-void require_init(struct ff2c_ff *ff,
-		  struct ff2c_require *r, const struct ff2c_term *term)
-{
-	char *buf = fmt("%*.*s    ", T(term));
-
-	*strrchr(buf, '"') = 0;
-	r->r_path = fmt("%s.h\"", buf);
-	free(buf);
-}
-
-void type_init(struct ff2c_ff *ff, struct ff2c_type *t,
-	       const struct ff2c_term *term);
-
-static const char *name[][3] = {
-	[FTT_VOID]   = { "void", "&C2_XT_VOID",   "c2_void_t" },
-	[FTT_U8]     = { "u8",   "&C2_XT_U8",     "uint8_t"   },
-	[FTT_U32]    = { "u32",  "&C2_XT_U32",    "uint32_t"  },
-	[FTT_U64]    = { "u64",  "&C2_XT_U64",    "uint64_t"  },
-	[FTT_OPAQUE] = { NULL,   "&C2_XT_OPAQUE", NULL        }
-};
-
-void field_init(struct ff2c_ff *ff,
-		struct ff2c_type *t, struct ff2c_field *f, int i,
-		const struct ff2c_term *term)
-{
-	const struct ff2c_term  *inner;
-	const struct ff2c_term  *sub;
-	const struct ff2c_token *tok;
-	struct ff2c_type        *comp;
-	const char              *ptr;
-
-	inner = term->fn_head;
-	assert(inner != NULL);
-	tok = &inner->fn_tok;
-
-	ptr = t->t_sequence && i > 0 ? "*" : "";
-	t->t_nr++;
-	f->f_parent = t;
-	f->f_name   = fmt("%*.*s", T(term));
-	f->f_c_name = fmt("%s%*.*s", t->t_union && i > 0 ? "u." : "", T(term));
-	for (sub = term->fn_head; sub != NULL; sub = sub->fn_next) {
-		if (sub->fn_type == FNT_TAG) {
-			assert(f->f_tag == NULL);
-			f->f_tag = fmt("%*.*s", T(sub));
-		} else if (sub->fn_type == FNT_ESCAPE) {
-			struct ff2c_escape *esc;
-
-			assert(f->f_escape == NULL);
-			f->f_escape = fmt("%*.*s", T(sub));
-			esc = alloc(sizeof *esc);
-			esc->e_escape = f->f_escape;
-			add(&ff->ff_escape, esc);
-		}
-	}
-	switch (inner->fn_type) {
-	case FNT_ATOMIC:
-		if (tok->ft_type == FTT_OPAQUE) {
-			assert(f->f_escape != NULL);
-			f->f_decl = fmt("struct %*.*s *%s%s",
-					T(inner), ptr, f->f_name);
-		} else {
-			f->f_decl = fmt("%s %s%s",
-					name[tok->ft_type][2], ptr, f->f_name);
-		}
-		break;
-	case FNT_TYPENAME:
-		f->f_decl = fmt("struct %*.*s %s%s", T(inner), ptr, f->f_name);
-		break;
-	case FNT_COMPOUND:
-		for (comp = ff->ff_type.l_head;
-		     comp != NULL; comp = comp->t_next) {
-			if (comp->t_term == term) {
-				f->f_type = comp;
-				break;
-			}
-		}
-		assert(f->f_type != NULL);
-		break;
-	default:
-		assert("impossible" == NULL);
-	}
-	if (inner->fn_type == FNT_ATOMIC)
-		f->f_xc_type = fmt("%s", name[tok->ft_type][1]);
-	else if (inner->fn_type == FNT_COMPOUND)
-		f->f_xc_type = fmt("%s", f->f_type->t_xc_name);
-	else
-		f->f_xc_type = fmt("%*.*s_xc", T(inner));
-}
-
-void type_init(struct ff2c_ff *ff, struct ff2c_type *t,
-	       const struct ff2c_term *term)
-{
-	const struct ff2c_term *inner;
-	const struct ff2c_term *grand;
-	enum ff2c_token_type    itype;
-
-	t->t_term = term;
-
-	inner = term->fn_head;
-	assert(term->fn_parent != NULL);
-	assert(inner != NULL);
-	itype = inner->fn_tok.ft_type;
-
-	if (inner->fn_type == FNT_ATOMIC) {
-		if (itype == FTT_OPAQUE) {
-			t->t_name    = fmt("[@MUST NOT HAPPEN@]");
-			t->t_xc_name = fmt("[@MUST NOT HAPPEN@]");
-			t->t_c_name  = fmt("%*.*s", T(inner));
-			t->t_opaque  = true;
-		} else {
-			t->t_name    = fmt("%s", name[itype][0]);
-			t->t_xc_name = fmt("%s", name[itype][1]);
-			t->t_c_name  = fmt("%s", name[itype][2]);
-			t->t_atomic  = true;
-		}
-	} else {
-		grand = term->fn_parent->fn_parent;
-		t->t_public = grand == NULL;
-		if (inner->fn_type == FNT_COMPOUND && grand != NULL)
-			t->t_name = fmt("%*.*s_%*.*s", T(grand), T(term));
-		else
-			t->t_name = fmt("%*.*s", T(term));
-		t->t_xc_name  = fmt("%s_xc", t->t_name);
-		t->t_c_name   = fmt("struct %s", t->t_name);
-		t->t_compound = true;
-		switch (itype) {
-		case FTT_SEQUENCE:
-			t->t_sequence = true;
-			break;
-		case FTT_UNION:
-			t->t_union = true;
-			break;
-		case FTT_RECORD:
-			t->t_record = true;
-			break;
-		case FTT_IDENTIFIER:
-			break;
-		default:
-			assert("impossible" == NULL);
-		}
-	}
-}
-
-void tree_walk(struct ff2c_ff *ff, const struct ff2c_term *top)
-{
-	const struct ff2c_term *child;
-
-	switch (top->fn_type) {
-	case FNT_REQUIRE:
-		require_init(ff, add_new(&ff->ff_require,
-					 sizeof(struct ff2c_require)), top);
-		break;
-	case FNT_DECLARATION:
-		if (top->fn_head->fn_type == FNT_COMPOUND) {
-			type_init(ff, add_new(&ff->ff_type,
-					      sizeof(struct ff2c_type)),
-				  top);
-		}
-		break;
-	default:
-		break;
-	}
-	for (child = top->fn_head; child != NULL; child = child->fn_next)
-		tree_walk(ff, child);
-}
-
-void ff2c_sem_init(struct ff2c_ff *ff, struct ff2c_term *top)
-{
-	struct ff2c_type *t;
-
-	tree_walk(ff, top);
-
-	for (t = ff->ff_type.l_head; t != NULL; t = t->t_next) {
-		const struct ff2c_term *inner;
-		const struct ff2c_term *f;
-		int                     i;
-
-		inner = t->t_term->fn_head;
-		for(i = 0, f = inner->fn_head; f != NULL; f = f->fn_next, ++i) {
-			field_init(ff, t, add_new(&t->t_field,
-						  sizeof(struct ff2c_field)),
-				   i, f);
-		}
-	}
-}
-
-void ff2c_sem_fini(struct ff2c_ff *ff)
-{
-}
-
-/** @} end of xcode group */
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
diff --git a/xcode/ff2c/sem.h b/xcode/ff2c/sem.h
deleted file mode 100644
index b7ea506..0000000
--- a/xcode/ff2c/sem.h
+++ /dev/null
@@ -1,109 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Nikita Danilov <nikita_danilov@xyratex.com>
- * Original creation date: 01-Jan-2012
- */
-
-#ifndef __COLIBRI_XCODE_FF2C_SEM_H__
-#define __COLIBRI_XCODE_FF2C_SEM_H__
-
-/**
-   @addtogroup xcode
- */
-/** @{ */
-
-#include <stdbool.h>
-
-/* import */
-struct ff2c_term;
-
-/* export */
-struct ff2c_require;
-struct ff2c_type;
-struct ff2c_field;
-struct ff2c_escape;
-struct ff2c_list;
-
-struct ff2c_list {
-	void *l_head;
-	void *l_tail;
-};
-
-struct ff2c_require {
-	struct ff2c_require *r_next;
-	const char          *r_path;
-};
-
-struct ff2c_type {
-	struct ff2c_type       *t_next;
-	const struct ff2c_term *t_term;
-	const char             *t_name;
-	const char             *t_xc_name;
-	const char             *t_c_name;
-	bool                    t_compound;
-	bool                    t_atomic;
-	bool                    t_opaque;
-	bool                    t_sequence;
-	bool                    t_union;
-	bool                    t_record;
-	bool                    t_public;
-	int                     t_nr;
-	struct ff2c_list        t_field;
-};
-
-struct ff2c_field {
-	struct ff2c_field *f_next;
-	struct ff2c_type  *f_parent;
-	struct ff2c_type  *f_type;
-	const char        *f_name;
-	const char        *f_c_name;
-	const char        *f_decl;
-	const char        *f_xc_type;
-	const char        *f_tag;
-	const char        *f_escape;
-};
-
-struct ff2c_escape {
-	struct ff2c_escape *e_next;
-	const char         *e_escape;
-};
-
-struct ff2c_ff {
-	struct ff2c_list ff_require;
-	struct ff2c_list ff_type;
-	struct ff2c_list ff_escape;
-};
-
-void ff2c_sem_init(struct ff2c_ff *ff, struct ff2c_term *top);
-void ff2c_sem_fini(struct ff2c_ff *ff);
-
-char *fmt(const char *format, ...) __attribute__((format(printf, 1, 2)));
-
-/** @} end of xcode group */
-
-/* __COLIBRI_XCODE_FF2C_SEM_H__ */
-#endif
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
diff --git a/xcode/ut/.gitignore b/xcode/ut/.gitignore
deleted file mode 100644
index 62ea0d5..0000000
--- a/xcode/ut/.gitignore
+++ /dev/null
@@ -1,2 +0,0 @@
-test_u.[ch]
-xcode_test
diff --git a/xcode/ut/Makefile.am b/xcode/ut/Makefile.am
deleted file mode 100644
index 4e6dcb4..0000000
--- a/xcode/ut/Makefile.am
+++ /dev/null
@@ -1,18 +0,0 @@
-xcodeutdir        = $(includedir)/xcode/ut
-noinst_LTLIBRARIES   = libxcode-ut.la
-
-#xcode_ut_LDADD = $(top_builddir)/colibri/libcolibri.la
-
-libxcode_ut_la_SOURCES  = test_u.h test_u.c xcode_fop_test.c xcode_test.c \
-			xcode.c ff2c.c
-
-test_u.h test_u.c : test.ff \
-	$(top_builddir)/fop/rt/libc2rt.la
-	$(top_builddir)/fop/fop2c
-	$(top_builddir)/fop/fop2c -u $<
-
-EXTRA_DIST = test.ff
-
-clean-local:
-	cd @SRCDIR@/xcode/ut ; \
-	rm -fr test_[uk].[ch]
diff --git a/xcode/ut/ff2c.c b/xcode/ut/ff2c.c
deleted file mode 100644
index 0f6dc6a..0000000
--- a/xcode/ut/ff2c.c
+++ /dev/null
@@ -1,227 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Nikita Danilov <nikita_danilov@xyratex.com>
- * Original creation date: 30-Dec-2011
- */
-
-#include <stdio.h>                          /* printf, stdout */
-
-#include "lib/misc.h"                       /* C2_SET0 */
-#include "lib/ut.h"
-
-#include "xcode/ff2c/lex.h"
-#include "xcode/ff2c/parser.h"
-#include "xcode/ff2c/sem.h"
-#include "xcode/ff2c/gen.h"
-
-static const char sample[] =
-"/* comment. */					\n"
-"require \"lib/vec.ff\";				\n"
-"						\n"
-"record {					\n"
-"	u64 f_container;			\n"
-"	u64 f_offset				\n"
-"} fid;						\n"
-"						\n"
-"union {						\n"
-"	u8  o_flag;				\n"
-"	fid o_fid   :1;				\n"
-"	u32 o_short :3				\n"
-"} optfid;					\n"
-"						\n"
-"sequence {					\n"
-"	u64    ofa_nr;				\n"
-"	optfid ofa_data				\n"
-"} optfidarray;					\n"
-"						\n"
-"sequence {					\n"
-"	void   fa_none :NR;			\n"
-"	optfid fa_data				\n"
-"} fixarray;					\n"
-"						\n"
-"/*void nothing;					\n"
-"u8   byte;					\n"
-"u32  quad;					\n"
-"u64  hyper;					\n"
-"optfid t_alias;*/				\n"
-"						\n"
-"record {				\n"
-"	fid      p_fid;				\n"
-"	c2_vec   p_vec;				\n"
-"	*c2_cred p_cred [c2_package_cred_get];	\n"
-"	sequence {				\n"
-"		u32 s_nr;			\n"
-"		u8  s_data			\n"
-"	} p_name				\n"
-"} package					\n"
-"						\n";
-
-__attribute__((unused)) static void token_print(const struct ff2c_token *tok)
-{
-	if (tok->ft_type != 0)
-		printf("[%s: %*.*s]", ff2c_token_type_name[tok->ft_type],
-		       (int)tok->ft_len, (int)tok->ft_len, tok->ft_val);
-	else
-		printf("[no token]");
-}
-
-static void ff2c_lex_test(void)
-{
-	struct ff2c_context ctx;
-	/* struct ff2c_token   tok; */
-
-	C2_SET0(&ctx);
-	ff2c_context_init(&ctx, sample, strlen(sample));
-
-	/* while (ff2c_token_get(&ctx, &tok) > 0)
-		token_print(&tok); */
-	ff2c_context_fini(&ctx);
-}
-
-__attribute__((unused)) static void parser_print(struct ff2c_term *t, int depth)
-{
-	const char ruler[] = "\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t";
-	printf("%*.*s %11.11s: ", depth, depth, ruler,
-	       ff2c_term_type_name[t->fn_type]);
-	token_print(&t->fn_tok);
-	printf("\n");
-	for (t = t->fn_head; t != NULL; t = t->fn_next)
-		parser_print(t, depth + 1);
-}
-
-static void ff2c_parser_test(void)
-{
-	struct ff2c_context ctx;
-	struct ff2c_term   *t;
-	int result;
-
-	C2_SET0(&ctx);
-	ff2c_context_init(&ctx, sample, strlen(sample));
-	result = ff2c_parse(&ctx, &t);
-	C2_UT_ASSERT(result == 0);
-	/*
-	printf("\n");
-	parser_print(t, 0);
-	*/
-	ff2c_term_fini(t);
-	ff2c_context_fini(&ctx);
-}
-
-static void ff2c_sem_test(void)
-{
-	int                  result;
-	struct ff2c_context  ctx;
-	struct ff2c_term    *term;
-	struct ff2c_ff       ff;
-/*	struct ff2c_require *r;
-	struct ff2c_type    *t;
-	struct ff2c_field   *f; */
-
-	C2_SET0(&ctx);
-	C2_SET0(&ff);
-
-	ff2c_context_init(&ctx, sample, strlen(sample));
-	result = ff2c_parse(&ctx, &term);
-	C2_UT_ASSERT(result == 0);
-
-	ff2c_sem_init(&ff, term);
-/*
-	for (r = ff.ff_require.l_head; r != NULL; r = r->r_next)
-		printf("require %s\n", r->r_path);
-
-	for (t = ff.ff_type.l_head; t != NULL; t = t->t_next) {
-		printf("type %p name: %s xc: %s c: %s\n"
-		       "\t%s %s %s %s %s %s %i\n", t,
-		       t->t_name, t->t_xc_name, t->t_c_name,
-		       t->t_compound ? "comp" : "",
-		       t->t_atomic   ? "atom" : "",
-		       t->t_opaque   ? "opaq" : "",
-		       t->t_sequence ? "seq" : "",
-		       t->t_union    ? "unio" : "",
-		       t->t_record   ? "rec" : "",
-		       t->t_nr);
-		for (f = t->t_field.l_head; f != NULL; f = f->f_next) {
-			printf("\tfield: %p name: %s c: %s tag: %s escape: %s\n"
-			       "\t\tdecl: %s\n",
-			       f->f_type, f->f_name, f->f_c_name,
-			       f->f_tag ?: "", f->f_escape ?: "",
-			       f->f_decl ?: "");
-		}
-		printf("\n");
-	}
-*/
-
-	ff2c_sem_fini(&ff);
-
-	ff2c_term_fini(term);
-	ff2c_context_fini(&ctx);
-}
-
-static void ff2c_gen_test(void)
-{
-	struct ff2c_context ctx;
-	struct ff2c_term   *t;
-	struct ff2c_ff      ff;
-	const struct ff2c_gen_opt opt ={
-		.go_basename  = "basename",
-		.go_guardname = "__GUARD__",
-		.go_out       = fopen("/dev/null", "w") /* stdout */
-	};
-
-	int result;
-
-	C2_SET0(&ctx);
-	C2_SET0(&ff);
-
-	ff2c_context_init(&ctx, sample, strlen(sample));
-	result = ff2c_parse(&ctx, &t);
-	C2_UT_ASSERT(result == 0);
-
-	ff2c_sem_init(&ff, t);
-
-	ff2c_h_gen(&ff, &opt);
-	ff2c_c_gen(&ff, &opt);
-
-	ff2c_sem_fini(&ff);
-	ff2c_term_fini(t);
-	ff2c_context_fini(&ctx);
-}
-
-const struct c2_test_suite xcode_ff2c_ut = {
-        .ts_name = "ff2c-ut",
-        .ts_init = NULL,
-        .ts_fini = NULL,
-        .ts_tests = {
-                { "xcode-lex",    ff2c_lex_test },
-                { "xcode-parser", ff2c_parser_test },
-                { "xcode-sem",    ff2c_sem_test },
-                { "xcode-gen",    ff2c_gen_test },
-                { NULL, NULL }
-        }
-};
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 79
- *  scroll-step: 1
- *  End:
- */
-
-
diff --git a/xcode/ut/test.ff b/xcode/ut/test.ff
deleted file mode 100644
index 55b6768..0000000
--- a/xcode/ut/test.ff
+++ /dev/null
@@ -1,28 +0,0 @@
-DEF(c2_test_buf, SEQUENCE,
-  _(tb_cnt, U32),
-  _(tb_buf, BYTE));
-
-DEF(c2_test_key, RECORD,
-  _(tk_index, U32),
-  _(tk_val, U64),
-  _(tk_flag, BYTE));
-
-DEF(c2_pair, RECORD,
-  _(p_offset, U64),
-  _(p_cnt, U32),
-  _(p_key, c2_test_key),
-  _(p_buf, c2_test_buf));
-
-DEF(c2_desc_arr, SEQUENCE,
-   _(da_cnt, U32),
-   _(da_pair, c2_pair));
-
-DEF(c2_fop_test_arr, SEQUENCE,
-   _(fta_cnt, U32),
-   _(fta_data, c2_desc_arr));
-
-DEF(c2_fop_test, RECORD,
-   _(ft_cnt, U32),
-   _(ft_offset,U64),
-  _(ft_arr, c2_fop_test_arr));
-
diff --git a/xcode/ut/xcode.c b/xcode/ut/xcode.c
deleted file mode 100644
index 282b5ce..0000000
--- a/xcode/ut/xcode.c
+++ /dev/null
@@ -1,554 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Nikita Danilov <nikita_danilov@xyratex.com>
- * Original creation date: 28-Dec-2011
- */
-
-#ifndef __KERNEL__
-#include <stdio.h>                          /* printf */
-#endif
-
-#include "lib/memory.h"
-#include "lib/vec.h"                        /* c2_bufvec */
-#include "lib/misc.h"                       /* C2_SET0 */
-#include "lib/ut.h"
-
-#include "xcode/xcode.h"
-
-struct foo {
-	uint64_t f_x;
-	uint64_t f_y;
-};
-
-typedef uint32_t tdef;
-
-struct un {
-	uint32_t u_tag;
-	union {
-		uint64_t u_x;
-		char     u_y;
-	} u;
-};
-
-struct top {
-	struct foo t_foo;
-	uint32_t   t_flag;
-	struct v {
-		uint32_t  v_nr;
-		char     *v_data;
-	} t_v;
-	tdef              t_def;
-	struct un         t_un;
-	union {
-		uint32_t *o_32;
-		uint64_t *o_64;
-	} t_opaq;
-};
-
-enum { CHILDREN_MAX = 16 };
-
-struct static_xt {
-	struct c2_xcode_type  xt;
-	struct c2_xcode_field field[CHILDREN_MAX];
-};
-
-static struct static_xt xut_un = {
-	.xt = {
-		.xct_aggr   = C2_XA_UNION,
-		.xct_name   = "un",
-		.xct_sizeof = sizeof (struct un),
-		.xct_nr     = 3
-	}
-};
-
-static struct static_xt xut_tdef = {
-	.xt = {
-		.xct_aggr   = C2_XA_TYPEDEF,
-		.xct_name   = "tdef",
-		.xct_sizeof = sizeof (tdef),
-		.xct_nr     = 1
-	}
-};
-
-static struct static_xt xut_v = {
-	.xt = {
-		.xct_aggr   = C2_XA_SEQUENCE,
-		.xct_name   = "v",
-		.xct_sizeof = sizeof (struct v),
-		.xct_nr     = 2
-	}
-};
-
-static struct static_xt xut_foo = {
-	.xt = {
-		.xct_aggr   = C2_XA_RECORD,
-		.xct_name   = "foo",
-		.xct_sizeof = sizeof (struct foo),
-		.xct_nr     = 2
-	}
-};
-
-static struct static_xt xut_top = {
-	.xt = {
-		.xct_aggr   = C2_XA_RECORD,
-		.xct_name   = "top",
-		.xct_sizeof = sizeof (struct top),
-		.xct_nr     = 6
-	}
-};
-
-static char data[] = "Hello, world!\n";
-
-static struct top T = {
-	.t_foo  = {
-		.f_x = 7,
-		.f_y = 8
-	},
-	.t_flag = 0xF,
-	.t_v    = {
-		.v_nr   = sizeof data,
-		.v_data = data
-	},
-	.t_un   = {
-		.u_tag = 4
-	},
-	.t_opaq = {
-		.o_32 = &T.t_v.v_nr
-	}
-};
-
-static char                 ebuf[100];
-static c2_bcount_t          count = ARRAY_SIZE(ebuf);
-static void                *vec = ebuf;
-static struct c2_bufvec     bvec  = C2_BUFVEC_INIT_BUF(&vec, &count);
-static struct c2_xcode_ctx  ctx;
-
-static struct tdata {
-	struct _foo {
-		uint64_t f_x;
-		uint64_t f_y;
-	} __attribute__((packed)) t_foo;
-	uint32_t __attribute__((packed)) t_flag;
-	struct _v {
-		uint32_t v_nr;
-		char     v_data[sizeof data];
-	} __attribute__((packed)) t_v;
-	uint32_t __attribute__((packed)) t_def;
-	struct t_un {
-		uint32_t u_tag;
-		char     u_y;
-	} __attribute__((packed)) t_un;
-	uint32_t __attribute__((packed)) t_opaq;
-} __attribute__((packed)) TD;
-
-C2_BASSERT(sizeof TD < sizeof ebuf);
-
-static int failure;
-
-static int opaq_type(const struct c2_xcode_obj *par,
-		     const struct c2_xcode_type **out)
-{
-	struct top *t = par->xo_ptr;
-
-	C2_UT_ASSERT(par->xo_type == &xut_top.xt);
-
-	if (!failure) {
-		*out = t->t_flag == 0xf ? &C2_XT_U32 : &C2_XT_U64;
-		return 0;
-	} else
-		return -ENOENT;
-}
-
-static int xcode_init(void)
-{
-	xut_v.xt.xct_child[0] = (struct c2_xcode_field){
-		.xf_name   = "v_nr",
-		.xf_type   = &C2_XT_U32,
-		.xf_offset = offsetof(struct v, v_nr)
-	};
-	xut_v.xt.xct_child[1] = (struct c2_xcode_field){
-		.xf_name   = "v_data",
-		.xf_type   = &C2_XT_U8,
-		.xf_offset = offsetof(struct v, v_data)
-	};
-
-	xut_foo.xt.xct_child[0] = (struct c2_xcode_field){
-		.xf_name   = "f_x",
-		.xf_type   = &C2_XT_U64,
-		.xf_offset = offsetof(struct foo, f_x)
-	};
-	xut_foo.xt.xct_child[1] = (struct c2_xcode_field){
-		.xf_name   = "f_y",
-		.xf_type   = &C2_XT_U64,
-		.xf_offset = offsetof(struct foo, f_y)
-	};
-
-	xut_top.xt.xct_child[0] = (struct c2_xcode_field){
-		.xf_name   = "t_foo",
-		.xf_type   = &xut_foo.xt,
-		.xf_offset = offsetof(struct top, t_foo)
-	};
-	xut_top.xt.xct_child[1] = (struct c2_xcode_field){
-		.xf_name   = "t_flag",
-		.xf_type   = &C2_XT_U32,
-		.xf_offset = offsetof(struct top, t_flag)
-	};
-	xut_top.xt.xct_child[2] = (struct c2_xcode_field){
-		.xf_name   = "t_v",
-		.xf_type   = &xut_v.xt,
-		.xf_offset = offsetof(struct top, t_v)
-	};
-	xut_top.xt.xct_child[3] = (struct c2_xcode_field){
-		.xf_name   = "t_def",
-		.xf_type   = &xut_tdef.xt,
-		.xf_offset = offsetof(struct top, t_def)
-	};
-	xut_top.xt.xct_child[4] = (struct c2_xcode_field){
-		.xf_name   = "t_un",
-		.xf_type   = &xut_un.xt,
-		.xf_offset = offsetof(struct top, t_un)
-	};
-	xut_top.xt.xct_child[5] = (struct c2_xcode_field){
-		.xf_name   = "t_opaq",
-		.xf_type   = &C2_XT_OPAQUE,
-		.xf_opaque = opaq_type,
-		.xf_offset = offsetof(struct top, t_opaq)
-	};
-
-	xut_tdef.xt.xct_child[0] = (struct c2_xcode_field){
-		.xf_name   = "def",
-		.xf_type   = &C2_XT_U32,
-		.xf_offset = 0
-	};
-
-	xut_un.xt.xct_child[0] = (struct c2_xcode_field){
-		.xf_name   = "u_tag",
-		.xf_type   = &C2_XT_U32,
-		.xf_offset = offsetof(struct un, u_tag)
-	};
-	xut_un.xt.xct_child[1] = (struct c2_xcode_field){
-		.xf_name   = "u_x",
-		.xf_type   = &C2_XT_U64,
-		.xf_tag    = 1,
-		.xf_offset = offsetof(struct un, u.u_x)
-	};
-	xut_un.xt.xct_child[2] = (struct c2_xcode_field){
-		.xf_name   = "u_y",
-		.xf_type   = &C2_XT_U8,
-		.xf_tag    = 4,
-		.xf_offset = offsetof(struct un, u.u_y)
-	};
-
-	TD.t_foo.f_x  =  T.t_foo.f_x;
-	TD.t_foo.f_y  =  T.t_foo.f_y;
-	TD.t_flag     =  T.t_flag;
-	TD.t_v.v_nr   =  T.t_v.v_nr;
-	C2_ASSERT(T.t_v.v_nr == ARRAY_SIZE(TD.t_v.v_data));
-	memcpy(TD.t_v.v_data, T.t_v.v_data, T.t_v.v_nr);
-	TD.t_def      =  T.t_def;
-	TD.t_un.u_tag =  T.t_un.u_tag;
-	TD.t_un.u_y   =  T.t_un.u.u_y;
-	TD.t_opaq     = *T.t_opaq.o_32;
-
-	return 0;
-}
-
-#ifndef __KERNEL__
-__attribute__((unused)) static void it_print(const struct c2_xcode_cursor *it)
-{
-	int i;
-	const struct c2_xcode_cursor_frame *f;
-
-	for (i = 0, f = &it->xcu_stack[0]; i < it->xcu_depth; ++i, ++f) {
-		printf(".%s[%lu]",
-		       f->s_obj.xo_type->xct_child[f->s_fieldno].xf_name,
-		       f->s_elno);
-	}
-	printf(":%s ", c2_xcode_aggr_name[f->s_obj.xo_type->xct_aggr]);
-	if (f->s_obj.xo_type->xct_aggr == C2_XA_ATOM) {
-		switch (f->s_obj.xo_type->xct_atype) {
-		case C2_XAT_VOID:
-			printf("void");
-			break;
-		case C2_XAT_U8:
-			printf("%c", *(char *)f->s_obj.xo_ptr);
-			break;
-		case C2_XAT_U32:
-			printf("%x", *(uint32_t *)f->s_obj.xo_ptr);
-			break;
-		case C2_XAT_U64:
-			printf("%x", (unsigned)*(uint64_t *)f->s_obj.xo_ptr);
-			break;
-		default:
-			C2_IMPOSSIBLE("atom");
-		}
-	}
-	printf("\n");
-}
-#endif
-
-static void chk(struct c2_xcode_cursor *it, int depth,
-		const struct c2_xcode_type *xt,
-		void *addr, int fieldno, int elno,
-		enum c2_xcode_cursor_flag flag)
-{
-	int                           rc;
-	struct c2_xcode_obj          *obj;
-	struct c2_xcode_cursor_frame *f;
-
-	rc = c2_xcode_next(it);
-	C2_UT_ASSERT(rc > 0);
-
-	C2_UT_ASSERT(it->xcu_depth == depth);
-	C2_UT_ASSERT(IS_IN_ARRAY(depth, it->xcu_stack));
-
-	f   = c2_xcode_cursor_top(it);
-	obj = &f->s_obj;
-
-	C2_UT_ASSERT(obj->xo_type == xt);
-	C2_UT_ASSERT(obj->xo_ptr  == addr);
-	C2_UT_ASSERT(f->s_fieldno == fieldno);
-	C2_UT_ASSERT(f->s_elno    == elno);
-	C2_UT_ASSERT(f->s_flag    == flag);
-}
-
-static void xcode_cursor_test(void)
-{
-	int                    i;
-	struct c2_xcode_cursor it;
-
-	C2_SET0(&it);
-
-	it.xcu_stack[0].s_obj.xo_type = &xut_top.xt;
-	it.xcu_stack[0].s_obj.xo_ptr  = &T;
-
-	chk(&it, 0, &xut_top.xt, &T, 0, 0, C2_XCODE_CURSOR_PRE);
-	chk(&it, 1, &xut_foo.xt, &T.t_foo, 0, 0, C2_XCODE_CURSOR_PRE);
-	chk(&it, 2, &C2_XT_U64, &T.t_foo.f_x, 0, 0, C2_XCODE_CURSOR_PRE);
-	chk(&it, 2, &C2_XT_U64, &T.t_foo.f_x, 0, 0, C2_XCODE_CURSOR_POST);
-	chk(&it, 1, &xut_foo.xt, &T.t_foo, 0, 0, C2_XCODE_CURSOR_IN);
-	chk(&it, 2, &C2_XT_U64, &T.t_foo.f_y, 0, 0, C2_XCODE_CURSOR_PRE);
-	chk(&it, 2, &C2_XT_U64, &T.t_foo.f_y, 0, 0, C2_XCODE_CURSOR_POST);
-	chk(&it, 1, &xut_foo.xt, &T.t_foo, 1, 0, C2_XCODE_CURSOR_IN);
-	chk(&it, 1, &xut_foo.xt, &T.t_foo, 2, 0, C2_XCODE_CURSOR_POST);
-	chk(&it, 0, &xut_top.xt, &T, 0, 0, C2_XCODE_CURSOR_IN);
-	chk(&it, 1, &C2_XT_U32, &T.t_flag, 0, 0, C2_XCODE_CURSOR_PRE);
-	chk(&it, 1, &C2_XT_U32, &T.t_flag, 0, 0, C2_XCODE_CURSOR_POST);
-	chk(&it, 0, &xut_top.xt, &T, 1, 0, C2_XCODE_CURSOR_IN);
-	chk(&it, 1, &xut_v.xt, &T.t_v, 0, 0, C2_XCODE_CURSOR_PRE);
-	chk(&it, 2, &C2_XT_U32, &T.t_v.v_nr, 0, 0, C2_XCODE_CURSOR_PRE);
-	chk(&it, 2, &C2_XT_U32, &T.t_v.v_nr, 0, 0, C2_XCODE_CURSOR_POST);
-	chk(&it, 1, &xut_v.xt, &T.t_v, 0, 0, C2_XCODE_CURSOR_IN);
-	for (i = 0; i < ARRAY_SIZE(data); ++i) {
-		chk(&it, 2, &C2_XT_U8,
-		    &T.t_v.v_data[i], 0, 0, C2_XCODE_CURSOR_PRE);
-		chk(&it, 2, &C2_XT_U8,
-		    &T.t_v.v_data[i], 0, 0, C2_XCODE_CURSOR_POST);
-		C2_UT_ASSERT(*(char *)it.xcu_stack[2].s_obj.xo_ptr == data[i]);
-		chk(&it, 1, &xut_v.xt, &T.t_v, 1, i, C2_XCODE_CURSOR_IN);
-	}
-	chk(&it, 1, &xut_v.xt, &T.t_v, 2, 0, C2_XCODE_CURSOR_POST);
-	chk(&it, 0, &xut_top.xt, &T, 2, 0, C2_XCODE_CURSOR_IN);
-	chk(&it, 1, &xut_tdef.xt, &T.t_def, 0, 0, C2_XCODE_CURSOR_PRE);
-	chk(&it, 2, &C2_XT_U32, &T.t_def, 0, 0, C2_XCODE_CURSOR_PRE);
-	chk(&it, 2, &C2_XT_U32, &T.t_def, 0, 0, C2_XCODE_CURSOR_POST);
-	chk(&it, 1, &xut_tdef.xt, &T.t_def, 0, 0, C2_XCODE_CURSOR_IN);
-	chk(&it, 1, &xut_tdef.xt, &T.t_def, 1, 0, C2_XCODE_CURSOR_POST);
-	chk(&it, 0, &xut_top.xt, &T, 3, 0, C2_XCODE_CURSOR_IN);
-	chk(&it, 1, &xut_un.xt, &T.t_un, 0, 0, C2_XCODE_CURSOR_PRE);
-	chk(&it, 2, &C2_XT_U32, &T.t_un.u_tag, 0, 0, C2_XCODE_CURSOR_PRE);
-	chk(&it, 2, &C2_XT_U32, &T.t_un.u_tag, 0, 0, C2_XCODE_CURSOR_POST);
-	chk(&it, 1, &xut_un.xt, &T.t_un, 0, 0, C2_XCODE_CURSOR_IN);
-	chk(&it, 2, &C2_XT_U8, &T.t_un.u.u_y, 0, 0, C2_XCODE_CURSOR_PRE);
-	chk(&it, 2, &C2_XT_U8, &T.t_un.u.u_y, 0, 0, C2_XCODE_CURSOR_POST);
-	chk(&it, 1, &xut_un.xt, &T.t_un, 2, 0, C2_XCODE_CURSOR_IN);
-	chk(&it, 1, &xut_un.xt, &T.t_un, 3, 0, C2_XCODE_CURSOR_POST);
-	chk(&it, 0, &xut_top.xt, &T, 4, 0, C2_XCODE_CURSOR_IN);
-	chk(&it, 1, &C2_XT_U32, T.t_opaq.o_32, 0, 0, C2_XCODE_CURSOR_PRE);
-	chk(&it, 1, &C2_XT_U32, T.t_opaq.o_32, 0, 0, C2_XCODE_CURSOR_POST);
-	chk(&it, 0, &xut_top.xt, &T, 5, 0, C2_XCODE_CURSOR_IN);
-	chk(&it, 0, &xut_top.xt, &T, 6, 0, C2_XCODE_CURSOR_POST);
-
-	C2_UT_ASSERT(c2_xcode_next(&it) == 0);
-}
-
-static void *ut_alloc(struct c2_xcode_ctx *ctx, size_t nob)
-{
-	return c2_alloc(nob);
-}
-
-static void xcode_length_test(void)
-{
-	int result;
-
-	c2_xcode_ctx_init(&ctx, &(struct c2_xcode_obj){ &xut_top.xt, &T });
-	result = c2_xcode_length(&ctx);
-	C2_UT_ASSERT(result == sizeof TD);
-}
-
-static void xcode_encode_test(void)
-{
-	int result;
-
-	c2_xcode_ctx_init(&ctx, &(struct c2_xcode_obj){ &xut_top.xt, &T });
-	c2_bufvec_cursor_init(&ctx.xcx_buf, &bvec);
-	result = c2_xcode_encode(&ctx);
-	C2_UT_ASSERT(result == 0);
-
-	C2_UT_ASSERT(memcmp(&TD, ebuf, sizeof TD) == 0);
-}
-
-static void xcode_opaque_test(void)
-{
-	int result;
-
-	failure = 1;
-	c2_xcode_ctx_init(&ctx, &(struct c2_xcode_obj){ &xut_top.xt, &T });
-	result = c2_xcode_length(&ctx);
-	C2_UT_ASSERT(result == -ENOENT);
-	failure = 0;
-}
-
-static void xcode_decode_test(void)
-{
-	int result;
-	struct top *TT;
-
-	c2_xcode_ctx_init(&ctx, &(struct c2_xcode_obj){ &xut_top.xt, NULL });
-	ctx.xcx_alloc = ut_alloc;
-	c2_bufvec_cursor_init(&ctx.xcx_buf, &bvec);
-
-	result = c2_xcode_decode(&ctx);
-	C2_UT_ASSERT(result == 0);
-
-	TT = ctx.xcx_it.xcu_stack[0].s_obj.xo_ptr;
-	C2_UT_ASSERT( TT != NULL);
-	C2_UT_ASSERT( TT->t_foo.f_x    ==  T.t_foo.f_x);
-	C2_UT_ASSERT( TT->t_foo.f_y    ==  T.t_foo.f_y);
-	C2_UT_ASSERT( TT->t_flag       ==  T.t_flag);
-	C2_UT_ASSERT( TT->t_v.v_nr     ==  T.t_v.v_nr);
-	C2_UT_ASSERT(memcmp(TT->t_v.v_data, T.t_v.v_data, T.t_v.v_nr) == 0);
-	C2_UT_ASSERT( TT->t_def        ==  T.t_def);
-	C2_UT_ASSERT( TT->t_un.u_tag   ==  T.t_un.u_tag);
-	C2_UT_ASSERT( TT->t_un.u.u_y   ==  T.t_un.u.u_y);
-	C2_UT_ASSERT(*TT->t_opaq.o_32  == *T.t_opaq.o_32);
-
-	c2_free(TT->t_opaq.o_32);
-	c2_free(TT->t_v.v_data);
-	c2_free(TT);
-}
-
-enum {
-	FSIZE = sizeof(uint64_t) + sizeof(uint64_t)
-};
-
-static char             foo_buf[FSIZE];
-static void            *foo_addr  = foo_buf;
-static c2_bcount_t      foo_count = ARRAY_SIZE(foo_buf);
-static struct c2_bufvec foo_bvec  = C2_BUFVEC_INIT_BUF(&foo_addr, &foo_count);
-
-static int foo_length(struct c2_xcode_ctx *ctx, const void *obj)
-{
-	return ARRAY_SIZE(foo_buf);
-}
-
-static void foo_xor(char *buf)
-{
-	int i;
-
-	for (i = 0; i < ARRAY_SIZE(foo_buf); ++i)
-		buf[i] ^= 42;
-}
-
-static int foo_encode(struct c2_xcode_ctx *ctx, const void *obj)
-{
-	struct c2_bufvec_cursor cur;
-
-	c2_bufvec_cursor_init(&cur, &foo_bvec);
-	memcpy(foo_buf, obj, sizeof(struct foo));
-	foo_xor(foo_buf);
-	return c2_bufvec_cursor_copy(&ctx->xcx_buf, &cur, FSIZE) != FSIZE ?
-		-EPROTO : 0;
-}
-
-static int foo_decode(struct c2_xcode_ctx *ctx, void *obj)
-{
-	struct c2_bufvec_cursor cur;
-
-	c2_bufvec_cursor_init(&cur, &foo_bvec);
-	if (c2_bufvec_cursor_copy(&cur, &ctx->xcx_buf, FSIZE) == FSIZE) {
-		foo_xor(foo_buf);
-		memcpy(obj, foo_buf, sizeof(struct foo));
-		return 0;
-	} else
-		return -EPROTO;
-}
-
-static const struct c2_xcode_type_ops foo_ops = {
-	.xto_length = foo_length,
-	.xto_encode = foo_encode,
-	.xto_decode = foo_decode
-};
-
-static void xcode_nonstandard_test(void)
-{
-	int result;
-
-	xut_foo.xt.xct_ops = &foo_ops;
-
-	c2_xcode_ctx_init(&ctx, &(struct c2_xcode_obj){ &xut_top.xt, &T });
-	result = c2_xcode_length(&ctx);
-	C2_UT_ASSERT(result == sizeof TD);
-
-	c2_xcode_ctx_init(&ctx, &(struct c2_xcode_obj){ &xut_top.xt, &T });
-	c2_bufvec_cursor_init(&ctx.xcx_buf, &bvec);
-	result = c2_xcode_encode(&ctx);
-	C2_UT_ASSERT(result == 0);
-
-	foo_xor(ebuf);
-	C2_UT_ASSERT(memcmp(&TD, ebuf, sizeof TD) == 0);
-	foo_xor(ebuf);
-	xcode_decode_test();
-}
-
-const struct c2_test_suite xcode_ut = {
-        .ts_name = "xcode-ut",
-        .ts_init = xcode_init,
-        .ts_fini = NULL,
-        .ts_tests = {
-                { "xcode-cursor", xcode_cursor_test },
-                { "xcode-length", xcode_length_test },
-                { "xcode-encode", xcode_encode_test },
-                { "xcode-opaque", xcode_opaque_test },
-                { "xcode-decode", xcode_decode_test },
-                { "xcode-nonstandard", xcode_nonstandard_test },
-                { NULL, NULL }
-        }
-};
-C2_EXPORTED(xcode_ut);
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 79
- *  scroll-step: 1
- *  End:
- */
-
-
diff --git a/xcode/ut/xcode_fop_test.c b/xcode/ut/xcode_fop_test.c
deleted file mode 100644
index 3796ab5..0000000
--- a/xcode/ut/xcode_fop_test.c
+++ /dev/null
@@ -1,275 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Subhash Arya <subhash_arya@xyratex.com>
- * Original creation date: 06/25/2011
- */
-
-#include <stdio.h>
-#include "lib/errno.h"
-#include "colibri/init.h"
-#include "lib/memory.h"
-#include "lib/bitstring.h"
-#include "lib/misc.h"
-#include "fop/fop.h"
-#include "lib/ut.h"
-#include "fop/fop_format_def.h"
-#include "fop/fop_format.h"
-#include "fop/fop_base.h"
-#include "xcode/bufvec_xcode.h"
-#include "xcode/ut/test_u.h"
-#include "xcode/ut/test.ff"
-#include "lib/vec.h"
-#include "rpc/rpc_opcodes.h"
-
-/** Random test values */
-enum {
-	ARR_COUNT_1 = 10,
-	ARR_COUNT_2 = 11,
-	TEST_OFFSET = 0xABCDEF,
-	TEST_COUNT  = 0x123456,
-	TEST_INDEX  = 0xDEAD,
-	TEST_VAL    = 0x1111,
-	TEST_CNT_1  = 0x1234,
-	TEST_FLAG   = 0x1,
-	TEST_BUF_SIZE = 33,
-	NO_OF_BUFFERS = 85,
-	BUFVEC_SEG_SIZE = 256
-};
-
-static char *fop_test_buf = "test fop encode/decode";
-
-extern struct c2_fop_type_format c2_fop_test_tfmt;
-
-int test_handler(struct c2_fop *fop, struct c2_fop_ctx *ctx)
-{
-	return 0;
-}
-
-struct c2_fop_type_ops test_ops = {
-        .fto_execute = test_handler,
-};
-
-C2_FOP_TYPE_DECLARE(c2_fop_test, "test", &test_ops, C2_XCODE_UT_OPCODE, 0);
-
-static void fop_verify( struct c2_fop *fop)
-{
-	void		      *fdata;
-	struct c2_fop_test    *ftest;
-	int		       i, j;
-
-	fdata = c2_fop_data(fop);
-	ftest = (struct c2_fop_test *)fdata;
-	C2_UT_ASSERT(ftest->ft_cnt == TEST_COUNT);
-	C2_UT_ASSERT(ftest->ft_offset == TEST_OFFSET);
-	C2_UT_ASSERT(ftest->ft_arr.fta_cnt == ARR_COUNT_1);
-	C2_UT_ASSERT(ftest->ft_arr.fta_data->da_cnt == ARR_COUNT_2);
-	for(i = 0; i < ftest->ft_arr.fta_cnt; ++i) {
-                int index = TEST_INDEX;
-                uint32_t test_cnt = TEST_CNT_1;
-		int test_val = TEST_VAL;
-		for (j = 0; j < ftest->ft_arr.fta_data->da_cnt; ++j) {
-                        int  cnt;
-			uint64_t temp;
-			char *c;
-
-			temp = ftest->ft_arr.fta_data[i].da_pair[j].p_offset;
-			C2_UT_ASSERT(temp == test_val);
-			test_val++;
-			temp = ftest->ft_arr.fta_data[i].da_pair[j].p_cnt;
-			C2_UT_ASSERT(temp == test_cnt);
-			test_cnt++;
-			temp =
-			ftest->ft_arr.fta_data[i].da_pair[j].p_key.tk_index;
-			C2_UT_ASSERT(temp == index);
-			index++;
-			temp =
-			ftest->ft_arr.fta_data[i].da_pair[j].p_key.tk_val;
-			C2_UT_ASSERT(temp == index);
-			index++;
-			temp =
-			ftest->ft_arr.fta_data[i].da_pair[j].p_key.tk_flag;
-			C2_UT_ASSERT(temp == TEST_FLAG);
-			cnt = ftest->ft_arr.fta_data[i].da_pair[j].p_buf.tb_cnt;
-			C2_UT_ASSERT(cnt == TEST_BUF_SIZE);
-			c = ftest->ft_arr.fta_data[i].da_pair[j].p_buf.tb_buf;
-			temp = strcmp(c, fop_test_buf);
-			C2_UT_ASSERT(temp == 0);
-		}
-	}
-}
-
-/** Clean up allocated fop structures */
-static void fop_free(struct c2_fop *fop)
-{
-	struct c2_fop_test	*ccf1;
-	int			 i;
-	int			 j;
-
-	ccf1 = c2_fop_data(fop);
-	for(i = 0; i < ccf1->ft_arr.fta_cnt; ++i) {
-		for (j = 0; j < ccf1->ft_arr.fta_data->da_cnt; ++j) {
-			char *test_buf;
-			test_buf =
-			ccf1->ft_arr.fta_data[i].da_pair[j].p_buf.tb_buf;
-			c2_free(test_buf);
-		}
-	}
-        for(i = 0; i < ccf1->ft_arr.fta_cnt; ++i)
-		c2_free(ccf1->ft_arr.fta_data[i].da_pair);
-
-	c2_free(ccf1->ft_arr.fta_data);
-	c2_fop_free(fop);
-}
-
-/** Test function to check generic fop encode decode */
-static void test_fop_encdec(void)
-{
-	int				 rc;
-	struct c2_bufvec_cursor		 cur;
-	void				*cur_addr;
-	int				 i;
-	int				 j;
-	struct c2_fop			*f1, *fd1;
-	struct c2_net_buffer		*nb;
-	struct c2_fop_test		*ccf1;
-	size_t				 fop_size;
-	size_t				 act_fop_size;
-
-	rc = c2_fop_type_format_parse(&c2_test_buf_tfmt);
-	C2_UT_ASSERT(rc == 0);
-	rc = c2_fop_type_format_parse(&c2_test_key_tfmt);
-	C2_UT_ASSERT(rc == 0);
-	rc = c2_fop_type_format_parse(&c2_pair_tfmt);
-	C2_UT_ASSERT(rc == 0);
-	rc = c2_fop_type_format_parse(&c2_desc_arr_tfmt);
-	C2_UT_ASSERT(rc == 0);
-	rc = c2_fop_type_format_parse(&c2_fop_test_arr_tfmt);
-	C2_UT_ASSERT(rc == 0);
-	rc = c2_fop_type_build(&c2_fop_test_fopt);
-	C2_UT_ASSERT(rc == 0);
-
-	/* Allocate a fop and populate its fields with test values */
-	f1 = c2_fop_alloc(&c2_fop_test_fopt, NULL);
-	C2_UT_ASSERT(f1 != NULL);
-
-	ccf1 = c2_fop_data(f1);
-	C2_ASSERT(ccf1 != NULL);
-	ccf1->ft_arr.fta_cnt = ARR_COUNT_1;
-	ccf1->ft_cnt = TEST_COUNT;
-	ccf1->ft_offset = TEST_OFFSET;
-	C2_ALLOC_ARR(ccf1->ft_arr.fta_data, ccf1->ft_arr.fta_cnt);
-	C2_UT_ASSERT(ccf1->ft_arr.fta_data != NULL);
-
-        for(i = 0; i < ccf1->ft_arr.fta_cnt; ++i) {
-		ccf1->ft_arr.fta_data[i].da_cnt=ARR_COUNT_2;
-		C2_ALLOC_ARR(ccf1->ft_arr.fta_data[i].da_pair,
-		     ccf1->ft_arr.fta_data[i].da_cnt);
-		C2_UT_ASSERT(ccf1->ft_arr.fta_data[i].da_pair != NULL);
-	}
-
-	for(i = 0; i < ccf1->ft_arr.fta_cnt; ++i) {
-		uint64_t ival = TEST_VAL;
-		int index = TEST_INDEX;
-		char flag = TEST_FLAG;
-		uint32_t cnt = TEST_CNT_1;
-		for (j = 0; j < ccf1->ft_arr.fta_data->da_cnt; ++j) {
-			char *test_buf;
-			ccf1->ft_arr.fta_data[i].da_pair[j].p_offset = ival++;
-			ccf1->ft_arr.fta_data[i].da_pair[j].p_cnt = cnt++;
-			ccf1->ft_arr.fta_data[i].da_pair[j].p_key.tk_index
-			= index++;
-			ccf1->ft_arr.fta_data[i].da_pair[j].p_key.tk_val
-			= index++;
-			ccf1->ft_arr.fta_data[i].da_pair[j].p_key.tk_flag
-			= flag;
-			C2_ALLOC_ARR(test_buf, TEST_BUF_SIZE);
-			C2_UT_ASSERT(test_buf != NULL);
-			ccf1->ft_arr.fta_data[i].da_pair[j].p_buf.tb_buf =
-			test_buf;
-			ccf1->ft_arr.fta_data[i].da_pair[j].p_buf.tb_cnt =
-			TEST_BUF_SIZE;
-			memcpy(ccf1->ft_arr.fta_data[i].da_pair[j].p_buf.tb_buf,
-			fop_test_buf, strlen(fop_test_buf));
-		}
-	}
-
-	/* Manually calculate the size of the fop based on the .ff file.
-	  For the current "test_fop" defined in fop.ff, we can calculate
-	  the size of the fop using the formula given below */
-	act_fop_size = 24 + ARR_COUNT_1 * (8 + ARR_COUNT_2 * 88);
-
-	/*Check the size of the fop using the interfaces*/
-	fop_size = c2_xcode_fop_size_get(f1);
-	C2_UT_ASSERT(fop_size == act_fop_size);
-
-	/* Allocate a netbuf and a bufvec, check alignments*/
-	C2_ALLOC_PTR(nb);
-        c2_bufvec_alloc(&nb->nb_buffer, NO_OF_BUFFERS, BUFVEC_SEG_SIZE);
-        c2_bufvec_cursor_init(&cur, &nb->nb_buffer);
-        cur_addr = c2_bufvec_cursor_addr(&cur);
-	C2_UT_ASSERT(C2_IS_8ALIGNED(cur_addr));
-
-	/* Encode the fop into the bufvec */
-	rc = c2_xcode_bufvec_fop(&cur, f1, C2_BUFVEC_ENCODE);
-	C2_UT_ASSERT(rc == 0);
-	cur_addr = c2_bufvec_cursor_addr(&cur);
-	C2_UT_ASSERT(C2_IS_8ALIGNED(cur_addr));
-
-	/* Allocate a fop for decode. The payload from the bufvec will be
-	   decoded into this fop */
-	fd1 = c2_fop_alloc(&c2_fop_test_fopt, NULL);
-	C2_UT_ASSERT(fd1 != NULL);
-	c2_bufvec_cursor_init(&cur, &nb->nb_buffer);
-	cur_addr = c2_bufvec_cursor_addr(&cur);
-	C2_UT_ASSERT(C2_IS_8ALIGNED(cur_addr));
-
-	/* Decode the payload from bufvec into the fop */
-	rc = c2_xcode_bufvec_fop(&cur, fd1, C2_BUFVEC_DECODE);
-	C2_UT_ASSERT(rc == 0);
-	cur_addr = c2_bufvec_cursor_addr(&cur);
-	C2_UT_ASSERT(C2_IS_8ALIGNED(cur_addr));
-
-	/* Verify the fop data */
-	fop_verify(fd1);
-
-	/* Clean up all the allocations */
-	c2_bufvec_free(&nb->nb_buffer);
-	c2_free(nb);
-	fop_free(f1);
-	fop_free(fd1);
-	c2_fop_type_fini(&c2_fop_test_fopt);
-}
-
-const struct c2_test_suite xcode_bufvec_fop_ut = {
-	.ts_name = "xcode_bufvec_fop-ut",
-	.ts_init = NULL,
-	.ts_fini = NULL,
-	.ts_tests = {
-		{ "xcode_bufvec_fop", test_fop_encdec },
-		{ NULL, NULL }
-	}
-};
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
diff --git a/xcode/ut/xcode_test.c b/xcode/ut/xcode_test.c
deleted file mode 100644
index a8d0df4..0000000
--- a/xcode/ut/xcode_test.c
+++ /dev/null
@@ -1,271 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Subhash Arya <subhash_arya@xyratex.com>
- * Original creation date: 08/5/2011
- */
-#include <limits.h>
-#include "lib/vec.h"
-#include "lib/arith.h"
-#include "lib/memory.h"
-#include "xcode/bufvec_xcode.h"
-#include "lib/ut.h"
-
-enum {
-	NO_OF_ELEMENTS = 50,
-};
-
-static struct c2_bufvec		vec;
-static struct c2_bufvec_cursor	cur;
-static uint32_t                 test_arr[NO_OF_ELEMENTS];
-static char                     *byte_arr = "bufvec encode/decode tests";
-
-static void test_arr_encode()
-{
-	int		rc, i;
-	size_t		el_size;
-	void		*cur_addr;
-
-	for ( i = 0; i < NO_OF_ELEMENTS; ++i)
-		test_arr[i] = i;
-
-	el_size = sizeof test_arr[0];
-	rc = c2_bufvec_array(&cur, test_arr, NO_OF_ELEMENTS, ~0, el_size,
-			    (c2_bufvec_xcode_t)c2_bufvec_uint32, C2_BUFVEC_ENCODE);
-	C2_UT_ASSERT(rc == 0);
-	cur_addr = c2_bufvec_cursor_addr(&cur);
-	C2_UT_ASSERT(C2_IS_8ALIGNED(cur_addr));
-}
-
-static void test_arr_decode()
-{
-	int		rc;
-	size_t		el_size;
-	uint32_t	dec_arr[NO_OF_ELEMENTS];
-	void		*cur_addr;
-
-	el_size = sizeof dec_arr[0];
-	rc = c2_bufvec_array(&cur, dec_arr, NO_OF_ELEMENTS, ~0, el_size,
-			    (c2_bufvec_xcode_t)c2_bufvec_uint32,
-			    C2_BUFVEC_DECODE);
-	C2_UT_ASSERT(rc == 0);
-	cur_addr = c2_bufvec_cursor_addr(&cur);
-	C2_UT_ASSERT(C2_IS_8ALIGNED(cur_addr));
-
-	rc = memcmp(test_arr, dec_arr, sizeof test_arr);
-	C2_UT_ASSERT(rc == 0);
-}
-
-static void test_byte_arr_encode()
-{
-	int	rc;
-	void    *cur_addr;
-
-	rc = c2_bufvec_bytes(&cur, &byte_arr, strlen(byte_arr), ~0,
-			     C2_BUFVEC_ENCODE);
-	C2_UT_ASSERT(rc == 0);
-	cur_addr = c2_bufvec_cursor_addr(&cur);
-	C2_UT_ASSERT(C2_IS_8ALIGNED(cur_addr));
-}
-
-static void test_byte_arr_decode()
-{
-	int		 rc;
-	void		*cur_addr;
-	char		*byte_arr_decode;
-	size_t		 arr_size;
-
-	arr_size = strlen(byte_arr);
-	C2_ALLOC_ARR(byte_arr_decode, arr_size);
-	rc = c2_bufvec_bytes(&cur, &byte_arr_decode, arr_size, ~0,
-			     C2_BUFVEC_DECODE);
-	C2_UT_ASSERT(rc == 0);
-	cur_addr = c2_bufvec_cursor_addr(&cur);
-	C2_UT_ASSERT(C2_IS_8ALIGNED(cur_addr));
-
-}
-static void test_uint32_encode()
-{
-	int	 rc;
-	void    *cur_addr;
-	uint32_t enc_val;
-
-	enc_val = UINT_MAX;
-	rc = c2_bufvec_uint32(&cur, &enc_val, C2_BUFVEC_ENCODE);
-	C2_UT_ASSERT(rc == 0);
-	cur_addr = c2_bufvec_cursor_addr(&cur);
-	enc_val = INT_MIN;
-	rc = c2_bufvec_uint32(&cur, &enc_val, C2_BUFVEC_ENCODE);
-	C2_UT_ASSERT(rc == 0);
-	cur_addr = c2_bufvec_cursor_addr(&cur);
-	C2_UT_ASSERT(C2_IS_8ALIGNED(cur_addr));
-}
-
-static void test_uint32_decode()
-{
-	int		 rc;
-	uint32_t	 dec_val;
-	void		*cur_addr;
-
-	rc = c2_bufvec_uint32(&cur, &dec_val, C2_BUFVEC_DECODE);
-	C2_UT_ASSERT(rc == 0 && dec_val == UINT_MAX);
-
-	rc = c2_bufvec_uint32(&cur, &dec_val, C2_BUFVEC_DECODE);
-	C2_UT_ASSERT(rc == 0 && (int)dec_val == INT_MIN);
-	cur_addr = c2_bufvec_cursor_addr(&cur);
-	C2_UT_ASSERT(C2_IS_8ALIGNED(cur_addr));
-}
-
-static void test_uint64_encode()
-{
-	int	 rc;
-	void    *cur_addr;
-	uint64_t enc_val;
-
-	enc_val = ULLONG_MAX ;
-	cur_addr = c2_bufvec_cursor_addr(&cur);
-	rc = c2_bufvec_uint64(&cur, &enc_val, C2_BUFVEC_ENCODE);
-	C2_UT_ASSERT(rc == 0);
-	enc_val = LLONG_MIN;
-	cur_addr = c2_bufvec_cursor_addr(&cur);
-	rc = c2_bufvec_uint64(&cur, &enc_val, C2_BUFVEC_ENCODE);
-	C2_UT_ASSERT(rc == 0);
-	cur_addr = c2_bufvec_cursor_addr(&cur);
-	C2_UT_ASSERT(C2_IS_8ALIGNED(cur_addr));
-}
-
-static void test_uint16_encode()
-{
-	int	 rc;
-	void    *cur_addr;
-	uint16_t enc_val;
-
-	enc_val = USHRT_MAX;
-	rc = c2_bufvec_uint16(&cur, &enc_val, C2_BUFVEC_ENCODE);
-	C2_UT_ASSERT(rc == 0);
-	enc_val = SHRT_MIN;
-	rc = c2_bufvec_uint16(&cur, &enc_val, C2_BUFVEC_ENCODE);
-	C2_UT_ASSERT(rc == 0);
-	cur_addr = c2_bufvec_cursor_addr(&cur);
-	C2_UT_ASSERT(C2_IS_8ALIGNED(cur_addr));
-}
-
-static void test_byte_encode()
-{
-	int	 rc;
-	void    *cur_addr;
-	uint8_t  enc_val;
-
-	enc_val = UCHAR_MAX;
-	rc = c2_bufvec_byte(&cur, &enc_val, C2_BUFVEC_ENCODE);
-	C2_UT_ASSERT(rc == 0);
-	enc_val = SCHAR_MIN;;
-	rc = c2_bufvec_byte(&cur, &enc_val, C2_BUFVEC_ENCODE);
-	C2_UT_ASSERT(rc == 0);
-	cur_addr = c2_bufvec_cursor_addr(&cur);
-	C2_UT_ASSERT(C2_IS_8ALIGNED(cur_addr));
-}
-
-static void test_uint64_decode()
-{
-	int		rc;
-	uint64_t	dec_val;
-	void	       *cur_addr;
-
-	rc = c2_bufvec_uint64(&cur, &dec_val, C2_BUFVEC_DECODE);
-	C2_UT_ASSERT(rc == 0 && dec_val == ULLONG_MAX);
-
-	rc = c2_bufvec_uint64(&cur, &dec_val, C2_BUFVEC_DECODE);
-	C2_UT_ASSERT(rc == 0 && (long)dec_val == LLONG_MIN);
-	cur_addr = c2_bufvec_cursor_addr(&cur);
-	C2_UT_ASSERT(C2_IS_8ALIGNED(cur_addr));
-}
-
-static void test_uint16_decode()
-{
-	int		 rc;
-	uint16_t	 dec_val;
-	void		*cur_addr;
-
-	rc = c2_bufvec_uint16(&cur, &dec_val, C2_BUFVEC_DECODE);
-	C2_UT_ASSERT(rc == 0 && dec_val == USHRT_MAX);
-
-	rc = c2_bufvec_uint16(&cur, &dec_val, C2_BUFVEC_DECODE);
-	C2_UT_ASSERT(rc == 0 && (short)dec_val == SHRT_MIN);
-	cur_addr = c2_bufvec_cursor_addr(&cur);
-	C2_UT_ASSERT(C2_IS_8ALIGNED(cur_addr));
-}
-
-static void test_byte_decode()
-{
-	int		 rc;
-	uint8_t		 dec_val;
-	void		*cur_addr;
-
-	rc = c2_bufvec_byte(&cur, &dec_val, C2_BUFVEC_DECODE);
-	C2_UT_ASSERT(rc == 0 && dec_val == UCHAR_MAX);
-
-	rc = c2_bufvec_byte(&cur, &dec_val, C2_BUFVEC_DECODE);
-	C2_UT_ASSERT(rc == 0 && (char)dec_val == SCHAR_MIN);
-	cur_addr = c2_bufvec_cursor_addr(&cur);
-	C2_UT_ASSERT(C2_IS_8ALIGNED(cur_addr));
-}
-static void xcode_bufvec_test(void)
-{
-	void	*cur_addr;
-
-	c2_bufvec_alloc(&vec, 40, 40);
-	c2_bufvec_cursor_init(&cur, &vec);
-	cur_addr = c2_bufvec_cursor_addr(&cur);
-	C2_UT_ASSERT(C2_IS_8ALIGNED(cur_addr));
-	/* Encode tests */
-	test_uint32_encode();
-	test_uint64_encode();
-	test_uint16_encode();
-	test_byte_encode();
-	test_arr_encode();
-	test_byte_arr_encode();
-	c2_bufvec_cursor_init(&cur, &vec);
-	/* Decode tests */
-	test_uint32_decode();
-	test_uint64_decode();
-	test_uint16_decode();
-	test_byte_decode();
-	test_arr_decode();
-	test_byte_arr_decode();
-}
-
-const struct c2_test_suite xcode_bufvec_ut = {
-        .ts_name = "xcode_bufvec-ut",
-        .ts_init = NULL,
-        .ts_fini = NULL,
-        .ts_tests = {
-                { "xcode-bufvec", xcode_bufvec_test },
-                { NULL, NULL }
-        }
-};
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 79
- *  scroll-step: 1
- *  End:
- */
-
-
diff --git a/xcode/xcode.c b/xcode/xcode.c
deleted file mode 100644
index 6706dd3..0000000
--- a/xcode/xcode.c
+++ /dev/null
@@ -1,472 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Nikita Danilov <nikita_danilov@xyratex.com>
- * Original creation date: 25-Dec-2011
- */
-
-#include "lib/bob.h"
-#include "lib/misc.h"                           /* C2_SET0 */
-#include "lib/errno.h"
-#include "lib/assert.h"
-
-#include "xcode/xcode.h"
-
-/**
-   @addtogroup xcode
-
-   @{
- */
-
-static bool field_invariant(const struct c2_xcode_type *xt,
-			    const struct c2_xcode_field *field)
-{
-	return
-		field->xf_name != NULL && field->xf_type != NULL &&
-		ergo(xt == &C2_XT_OPAQUE, field->xf_opaque != NULL) &&
-		field->xf_offset + field->xf_type->xct_sizeof <= xt->xct_sizeof;
-}
-
-bool c2_xcode_type_invariant(const struct c2_xcode_type *xt)
-{
-	size_t   i;
-	uint32_t offset;
-
-	static const size_t min[C2_XA_NR] = {
-		[C2_XA_RECORD]   = 0,
-		[C2_XA_UNION]    = 2,
-		[C2_XA_SEQUENCE] = 2,
-		[C2_XA_TYPEDEF]  = 1,
-		[C2_XA_OPAQUE]   = 0,
-		[C2_XA_ATOM]     = 0
-	};
-
-	static const size_t max[C2_XA_NR] = {
-		[C2_XA_RECORD]   = ~0ULL,
-		[C2_XA_UNION]    = ~0ULL,
-		[C2_XA_SEQUENCE] = 2,
-		[C2_XA_TYPEDEF]  = 1,
-		[C2_XA_OPAQUE]   = 0,
-		[C2_XA_ATOM]     = 0
-	};
-
-	if (!(0 <= xt->xct_aggr && xt->xct_aggr < C2_XA_NR))
-		return false;
-
-	if (xt->xct_nr < min[xt->xct_aggr] || xt->xct_nr > max[xt->xct_aggr])
-		return false;
-
-	for (i = 0; i < xt->xct_nr; ++i) {
-		const struct c2_xcode_field *f;
-
-		f = &xt->xct_child[i];
-		if (!field_invariant(xt, f))
-			return false;
-		/* field doesn't overlap with the previous one */
-		if (i > 0 && offset +
-		    xt->xct_child[i - 1].xf_type->xct_sizeof > f->xf_offset)
-			return false;
-		/* update the previous field offset: for UNION all branches
-		   follow the first field. */
-		if (i == 0 || xt->xct_aggr != C2_XA_UNION)
-			offset = f->xf_offset;
-	}
-	switch (xt->xct_aggr) {
-	case C2_XA_RECORD:
-	case C2_XA_TYPEDEF:
-		break;
-	case C2_XA_UNION:
-	case C2_XA_SEQUENCE:
-		if (xt->xct_child[0].xf_type->xct_aggr != C2_XA_ATOM)
-			return false;
-		break;
-	case C2_XA_OPAQUE:
-		if (xt != &C2_XT_OPAQUE)
-			return false;
-		if (xt->xct_sizeof != sizeof (void *))
-			return false;
-		break;
-	case C2_XA_ATOM:
-		if (!(0 <= xt->xct_atype && xt->xct_atype < C2_XAT_NR))
-			return false;
-		break;
-	default:
-		return false;
-	}
-	return true;
-}
-
-#include "xcode/cursor.c"
-
-enum xcode_op {
-	XO_ENC,
-	XO_DEC,
-	XO_LEN,
-	XO_NR
-};
-
-/**
-   Handles memory allocation during decoding.
-
-   This function takes an xcode iteration cursor and, if necessary, allocates
-   memory where currently decided object will reside.
-
-   The pointer to the allocated memory is returned in c2_xcode_obj::xo_ptr. In
-   addition, this pointer is stored at the appropriate offset in the parent
-   object.
- */
-static ssize_t xcode_alloc(struct c2_xcode_ctx *ctx)
-{
-	const struct c2_xcode_cursor_frame *prev;
-	const struct c2_xcode_obj          *par;
-	const struct c2_xcode_type         *xt;
-	const struct c2_xcode_type         *pt;
-	struct c2_xcode_cursor_frame       *top;
-	struct c2_xcode_obj                *obj;
-	size_t                              nob;
-	size_t                              size;
-	void                              **slot;
-
-	/*
-	 * New memory has to be allocated in 3 cases:
-	 *
-	 * - to decode topmost object (this is different from sunrpc XDR
-	 *   interfaces, where topmost object is pre-allocated by the caller);
-	 *
-	 * - to store an array: a SEQUENCE object has the following in-memory
-	 *   structure:
-	 *
-	 *       struct  {
-	 *               scalar_t     count;
-	 *               struct elem *data;
-	 *
-	 *       };
-	 *
-	 *   This function allocates count * sizeof(struct elem) bytes to hold
-	 *   "data";
-	 *
-	 * - to store an object pointed to by an opaque pointer.
-	 *
-	 */
-
-	nob  = 0;
-	top  = c2_xcode_cursor_top(&ctx->xcx_it);
-	prev = top - 1;
-	obj  = &top->s_obj;  /* an object being decoded */
-	par  = &prev->s_obj; /* obj's parent object */
-	xt   = obj->xo_type;
-	pt   = par->xo_type;
-	size = xt->xct_sizeof;
-
-	if (ctx->xcx_it.xcu_depth == 0) {
-		/* allocate top-most object */
-		nob = size;
-		slot = &obj->xo_ptr;
-	} else {
-		if (pt->xct_aggr == C2_XA_SEQUENCE &&
-		    prev->s_fieldno == 1 && prev->s_elno == 0)
-			/* allocate array */
-			nob = c2_xcode_tag(par) * size;
-		else if (pt->xct_child[prev->s_fieldno].xf_type == &C2_XT_OPAQUE)
-			/*
-			 * allocate the object referenced by an opaque
-			 * pointer. At this moment "xt" is the type of the
-			 * pointed object.
-			 */
-			nob = size;
-		slot = c2_xcode_addr(par, prev->s_fieldno, ~0ULL);
-	}
-
-	if (nob != 0) {
-		C2_ASSERT(obj->xo_ptr == NULL);
-
-		obj->xo_ptr = *slot = ctx->xcx_alloc(ctx, nob);
-		if (obj->xo_ptr == NULL)
-			return -ENOMEM;
-	}
-	return 0;
-}
-
-/**
-   Common xcoding function, implementing encoding, decoding and sizing.
- */
-static int ctx_walk(struct c2_xcode_ctx *ctx, enum xcode_op op)
-{
-	void                   *ptr;
-	c2_bcount_t             size;
-	int                     length = 0;
-	int                     result;
-	struct c2_bufvec        area   = C2_BUFVEC_INIT_BUF(&ptr, &size);
-	struct c2_bufvec_cursor mem;
-	struct c2_xcode_cursor *it     = &ctx->xcx_it;
-
-	while ((result = c2_xcode_next(it)) > 0) {
-		const struct c2_xcode_type     *xt;
-		const struct c2_xcode_type_ops *ops;
-		struct c2_xcode_obj            *cur;
-		struct c2_xcode_cursor_frame   *top;
-
-		top = c2_xcode_cursor_top(it);
-
-		if (top->s_flag != C2_XCODE_CURSOR_PRE)
-			continue;
-
-		cur = &top->s_obj;
-
-		if (op == XO_DEC) {
-			result = xcode_alloc(ctx);
-			if (result != 0)
-				return result;
-		}
-
-		xt  = cur->xo_type;
-		ptr = cur->xo_ptr;
-		ops = xt->xct_ops;
-
-		if (ops != NULL) {
-			switch (op) {
-			case XO_ENC:
-				if (ops->xto_encode != NULL)
-					result = ops->xto_encode(ctx, ptr);
-				break;
-			case XO_DEC:
-				if (ops->xto_decode != NULL)
-					result = ops->xto_decode(ctx, ptr);
-				break;
-			case XO_LEN:
-				if (ops->xto_length != NULL)
-					length += ops->xto_length(ctx, ptr);
-				break;
-			default:
-				C2_IMPOSSIBLE("op");
-			}
-			c2_xcode_skip(it);
-		} else if (xt->xct_aggr == C2_XA_ATOM) {
-			size = xt->xct_sizeof;
-
-			if (op == XO_LEN)
-				length += size;
-			else {
-				struct c2_bufvec_cursor *src;
-				struct c2_bufvec_cursor *dst;
-
-				c2_bufvec_cursor_init(&mem, &area);
-				/* XXX endianness and sharing */
-				switch (op) {
-				case XO_ENC:
-					src = &mem;
-					dst = &ctx->xcx_buf;
-					break;
-				case XO_DEC:
-					dst = &mem;
-					src = &ctx->xcx_buf;
-					break;
-				default:
-					C2_IMPOSSIBLE("op");
-				}
-				if (c2_bufvec_cursor_copy(dst,
-							  src, size) != size)
-					result = -EPROTO;
-			}
-		}
-		if (result < 0)
-			break;
-	}
-	if (result > 0)
-		result = 0;
-	if (op == XO_LEN)
-		result = result ?: length;
-	return result;
-}
-
-void c2_xcode_ctx_init(struct c2_xcode_ctx *ctx, const struct c2_xcode_obj *obj)
-{
-	C2_SET0(ctx);
-	c2_xcode_cursor_top(&ctx->xcx_it)->s_obj = *obj;
-}
-
-int c2_xcode_decode(struct c2_xcode_ctx *ctx)
-{
-	return ctx_walk(ctx, XO_DEC);
-}
-
-int c2_xcode_encode(struct c2_xcode_ctx *ctx)
-{
-	return ctx_walk(ctx, XO_ENC);
-}
-
-int c2_xcode_length(struct c2_xcode_ctx *ctx)
-{
-	return ctx_walk(ctx, XO_LEN);
-}
-
-void *c2_xcode_addr(const struct c2_xcode_obj *obj, int fileno, uint64_t elno)
-{
-	char                        *addr = (char *)obj->xo_ptr;
-	const struct c2_xcode_type  *xt   = obj->xo_type;
-	const struct c2_xcode_field *f    = &xt->xct_child[fileno];
-	const struct c2_xcode_type  *ct   = f->xf_type;
-
-	C2_ASSERT(fileno < xt->xct_nr);
-	addr += f->xf_offset;
-	if (xt->xct_aggr == C2_XA_SEQUENCE && fileno == 1 && elno != ~0ULL)
-		addr = *((char **)addr) + elno * ct->xct_sizeof;
-	else if (ct == &C2_XT_OPAQUE && elno != ~0ULL)
-		addr = *((char **)addr);
-	return addr;
-}
-
-int c2_xcode_subobj(struct c2_xcode_obj *subobj, const struct c2_xcode_obj *obj,
-		    int fieldno, uint64_t elno)
-{
-	const struct c2_xcode_field *f;
-	int                          result;
-
-	C2_PRE(0 <= fieldno && fieldno < obj->xo_type->xct_nr);
-
-	f = &obj->xo_type->xct_child[fieldno];
-
-	subobj->xo_ptr = c2_xcode_addr(obj, fieldno, elno);
-	if (f->xf_type == &C2_XT_OPAQUE) {
-		result = f->xf_opaque(obj, &subobj->xo_type);
-	} else {
-		subobj->xo_type = f->xf_type;
-		result = 0;
-	}
-	return result;
-}
-
-uint64_t c2_xcode_tag(const struct c2_xcode_obj *obj)
-{
-	const struct c2_xcode_type  *xt = obj->xo_type;
-	const struct c2_xcode_field *f  = &xt->xct_child[0];
-	uint64_t                     tag;
-
-	C2_PRE(xt->xct_aggr == C2_XA_SEQUENCE || xt->xct_aggr == C2_XA_UNION);
-	C2_PRE(f->xf_type->xct_aggr == C2_XA_ATOM);
-
-	switch (f->xf_type->xct_atype) {
-	case C2_XAT_VOID:
-		tag = f->xf_tag;
-		break;
-	case C2_XAT_U8:
-		tag = *C2_XCODE_VAL(obj, 0, 0, uint8_t);
-		break;
-	case C2_XAT_U32:
-		tag = *C2_XCODE_VAL(obj, 0, 0, uint32_t);
-		break;
-	case C2_XAT_U64:
-		tag = *C2_XCODE_VAL(obj, 0, 0, uint64_t);
-		break;
-	default:
-		C2_IMPOSSIBLE("atype");
-	}
-	return tag;
-}
-
-void c2_xcode_bob_type_init(struct c2_bob_type *bt,
-			    const struct c2_xcode_type *xt,
-			    size_t magix_field, uint64_t magix)
-{
-	const struct c2_xcode_field *mf = &xt->xct_child[magix_field];
-
-	C2_PRE(magix_field < xt->xct_nr);
-	C2_PRE(xt->xct_aggr == C2_XA_RECORD);
-	C2_PRE(mf->xf_type == &C2_XT_U64);
-
-	bt->bt_name         = xt->xct_name;
-	bt->bt_magix        = magix;
-	bt->bt_magix_offset = mf->xf_offset;
-}
-
-const struct c2_xcode_type C2_XT_VOID = {
-	.xct_aggr   = C2_XA_ATOM,
-	.xct_name   = "void",
-	.xct_atype  = C2_XAT_VOID,
-	.xct_sizeof = sizeof(void),
-	.xct_nr     = 0
-};
-
-const struct c2_xcode_type C2_XT_U8 = {
-	.xct_aggr   = C2_XA_ATOM,
-	.xct_name   = "u8",
-	.xct_atype  = C2_XAT_U8,
-	.xct_sizeof = sizeof(uint8_t),
-	.xct_nr     = 0
-};
-
-const struct c2_xcode_type C2_XT_U32 = {
-	.xct_aggr   = C2_XA_ATOM,
-	.xct_name   = "u32",
-	.xct_atype  = C2_XAT_U32,
-	.xct_sizeof = sizeof(uint32_t),
-	.xct_nr     = 0
-};
-
-const struct c2_xcode_type C2_XT_U64 = {
-	.xct_aggr   = C2_XA_ATOM,
-	.xct_name   = "u64",
-	.xct_atype  = C2_XAT_U64,
-	.xct_sizeof = sizeof(uint64_t),
-	.xct_nr     = 0
-};
-
-const struct c2_xcode_type C2_XT_OPAQUE = {
-	.xct_aggr   = C2_XA_OPAQUE,
-	.xct_name   = "opaque",
-	.xct_sizeof = sizeof (void *),
-	.xct_nr     = 0
-};
-
-const char *c2_xcode_aggr_name[C2_XA_NR] = {
-	[C2_XA_RECORD]   = "record",
-	[C2_XA_UNION]    = "union",
-	[C2_XA_SEQUENCE] = "sequence",
-	[C2_XA_TYPEDEF]  = "typedef",
-	[C2_XA_OPAQUE]   = "opaque",
-	[C2_XA_ATOM]     = "atom"
-};
-
-const char *c2_xcode_atom_type_name[C2_XAT_NR] = {
-	[C2_XAT_VOID] = "void",
-	[C2_XAT_U8]   = "u8",
-	[C2_XAT_U32]  = "u32",
-	[C2_XAT_U64]  = "u64",
-};
-
-const char *c2_xcode_endianness_name[C2_XEND_NR] = {
-	[C2_XEND_LE] = "le",
-	[C2_XEND_BE] = "be"
-};
-
-const char *c2_xcode_cursor_flag_name[C2_XCODE_CURSOR_NR] = {
-	[C2_XCODE_CURSOR_NONE] = "none",
-	[C2_XCODE_CURSOR_PRE]  = "pre",
-	[C2_XCODE_CURSOR_IN]   = "in",
-	[C2_XCODE_CURSOR_POST] = "post"
-};
-
-/** @} end of xcode group */
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
diff --git a/xcode/xcode.h b/xcode/xcode.h
deleted file mode 100644
index 0cd676f..0000000
--- a/xcode/xcode.h
+++ /dev/null
@@ -1,652 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Nikita Danilov <nikita_danilov@xyratex.com>
- * Original creation date: 25-Dec-2011
- */
-
-#ifndef __COLIBRI_XCODE_XCODE_H__
-#define __COLIBRI_XCODE_XCODE_H__
-
-#include "lib/vec.h"                /* c2_bufvec_cursor */
-#include "lib/types.h"              /* c2_bcount_t */
-
-/**
-   @defgroup xcode
-
-   xcode module implements a modest set of introspection facilities. A user
-   defines a structure (c2_xcode_type) which describes the in memory layout of a
-   C data-type. xcode provides interfaces to iterate over hierarchy of such
-   descriptors and to associate user defined state with types and fields.
-
-   A motivating example of xcode usage is universal encoding and decoding
-   interface (c2_xcode_decode(), c2_xcode_encode(), c2_xcode_length()) which
-   converts between an in-memory object and its serialized representation.
-
-   Other usages of xcoding interfaces are:
-
-       - pretty-printing,
-
-       - pointer swizzling and adjustment when loading RVM segments into memory,
-
-       - consistency checking: traversing data-structures in memory validating
-         check-sums and invariants.
-
-   Not every C data-structure can be represented by xcode. The set of
-   representable data-structures is defined inductively according to the
-   "aggregation type" of data-structure:
-
-       - ATOM aggregation type: scalar data-types void, uint8_t, uint32_t and
-         uint64_t are representable,
-
-       - RECORD aggregation type: a struct type, whose members are all
-         representable is representable,
-
-       - UNION aggregation type: a "discriminated union" structure of the form
-
-         @code
-         struct {
-                 scalar_t discriminator;
-	         union {
-	                 ...
-	         } u;
-         };
-         @endcode
-
-         where scalar_t is one of the scalar data-types mentioned above and all
-         union fields are representable is representable,
-
-       - SEQUENCE aggregation type: a "counted array" structure of the form
-
-         @code
-         struct {
-                 scalar_t  nr;
-		 el_t     *el;
-         };
-         @endcode
-
-         where scalar_t is one of the scalar data-types mentioned above and el_t
-         is representable is representable,
-
-       - OPAQUE aggregation type: pointer type is representable when it is used
-         as the type of a field in a representable type and a special function
-         (c2_xcode_field::xf_opaque()) is assigned to the field, which returns
-         the representation of the type of an object the pointer points to.
-
-         The usage of function allows representation of pointer structures where
-         the actual type of the object pointed to depends on the contents of its
-         parent structure.
-
-   A representable type is described by an instance of struct c2_xcode_type,
-   which describes type attributes and also contains an array
-   (c2_xcode_type::xct_child[]) of "fields". A field is represented by struct
-   c2_xcode_field and describes a sub-object. The field points to a
-   c2_xcode_type instance, describing the type of sub-object. This way a
-   hierarchy (forest of trees) of types is organized. Its leaves are atomic
-   types.
-
-   Sub-objects are located contiguously in memory, except for SEQUENCE elements
-   and OPAQUE fields.
-
-   xcode description of a data-type can be provided either by
-
-       - manually creating an instance of c2_xcode_type structure, describing
-         properties of the data-type or
-
-       - by creating a description of the desired serialized format of a
-         data-type and using ff2c translator (xcode/ff2c/ff2c.c) to produce C
-         files (.c and .h) containing the matching data-type definitions and
-         xcode descriptors.
-
-   The first method is suitable for memory-only structures. The second method is
-   for structures designed to be transmitted over network of stored on
-   persistent storage (fops, db records, &c.).
- */
-/** @{ */
-
-/* import */
-struct c2_bufvec_cursor;
-
-/* export */
-struct c2_xcode;
-struct c2_xcode_type;
-struct c2_xcode_type_ops;
-struct c2_xcode_ctx;
-struct c2_xcode_obj;
-struct c2_xcode_field;
-struct c2_xcode_cursor;
-
-/**
-   Type of aggregation for a data-type.
-
-   A value of this enum, stored in c2_code_type::xct_aggr determines how fields
-   of the type are interpreted.
- */
-enum c2_xcode_aggr {
-	/**
-	   RECORD corresponds to C struct. Fields of RECORD type are located one
-	   after another in memory.
-	 */
-	C2_XA_RECORD,
-	/**
-	   UNION corresponds to discriminated union. Its first field is referred
-	   to as a "discriminator" and has an atomic type. Other fields of union
-	   are tagged (c2_xcode_field::xf_tag) and the value of the
-	   discriminator field determines which of the following fields is
-	   actually used.
-
-	   @note that, similarly to C2_XA_SEQUENCE, the discriminator field can
-	   have C2_XAT_VOID type. In this case its tag is used instead of its
-	   value (use cases are not clear).
-	 */
-	C2_XA_UNION,
-	/**
-	   SEQUENCE corresponds to counted array. Sequence always has two
-	   fields: a scalar "counter" field and a field denoting the element of
-	   the array.
-
-	   @note if counter has type C2_XAT_VOID, its tag used as a
-	   counter. This is used to represent fixed size arrays without an
-	   explicit counter field.
-	 */
-	C2_XA_SEQUENCE,
-	/**
-	   TYPEDEF is an alias for another type. It always has a single field.
-	 */
-	C2_XA_TYPEDEF,
-	/**
-	   OPAQUE represents a pointer.
-
-	   A field of OPAQUE type must have c2_xcode_field::xf_opaque() function
-	   pointer set to a function which determines the actual type of the
-	   object pointed to.
-	 */
-	C2_XA_OPAQUE,
-	/**
-	   ATOM represents "atomic" data-types having no internal
-	   structure. c2_xcode_type-s with c2_xcode_type::xct_aggr set to
-	   C2_XA_ATOM have c2_xcode_type::xct_nr == 0 and no fields.
-
-	   Atomic types are enumerated in c2_xode_atom_type.
-	 */
-	C2_XA_ATOM,
-	C2_XA_NR
-};
-
-/**
-   Human-readable names of c2_xcode_aggr values.
- */
-extern const char *c2_xcode_aggr_name[C2_XA_NR];
-
-/**
-    Atomic types.
-
-    To each value of this enumeration, except for C2_XAT_NR, a separate
-    c2_xcode_type (C2_XT_VOID, C2_XT_U8, &c.).
- */
-enum c2_xode_atom_type {
-	C2_XAT_VOID,
-	C2_XAT_U8,
-	C2_XAT_U32,
-	C2_XAT_U64,
-
-	C2_XAT_NR
-};
-
-/** Human-readable names of elements of c2_xcode_atom_type */
-extern const char *c2_xcode_atom_type_name[C2_XAT_NR];
-
-enum { C2_XCODE_DECOR_MAX = 10 };
-
-/** Field of data-type. */
-struct c2_xcode_field {
-	/** Field name. */
-	const char                 *xf_name;
-	/** Field type. */
-	const struct c2_xcode_type *xf_type;
-	/** Tag, associated with this field.
-
-	    Tag is used in the following ways:
-
-	        - if first field of a SEQUENCE type has type VOID, its tag is
-                  used as a count of element in the sequence;
-
-		- tag of non-first field of a UNION type is used to determine
-                  when the field is actually present in the object: the field is
-                  present iff its tag equals the discriminator of the union.
-
-		  The discriminator is the value of the first field of the
-		  union.
-	 */
-	uint64_t                    xf_tag;
-	/**
-	   Fields with c2_xcode_type::xf_type == &C2_XT_OPAQUE are "opaque"
-	   fields. An opaque field corresponds to a
-	   pointer. c2_xcode_type::xf_opaque() is called by the xcode to follow
-	   the pointer. This function returns (in its "out" parameter) a type of
-	   the object pointed to. "par" parameter refers to the parent object to
-	   which the field belongs.
-	 */
-	int                       (*xf_opaque)(const struct c2_xcode_obj   *par,
-					       const struct c2_xcode_type **out);
-	/**
-	   Byte offset of this field from the beginning of the object.
-	 */
-	uint32_t                    xf_offset;
-	/**
-	   "Decorations" are used by xcode users to associate additional
-	   information with introspection elements.
-
-	   @see c2_xcode_decor_register()
-	   @see c2_xcode_type::xct_decor[]
-	 */
-	void                       *xf_decor[C2_XCODE_DECOR_MAX];
-};
-
-/**
-   This struct represents a data-type.
- */
-struct c2_xcode_type {
-	/** What sub-objects instances of this type have and how they are
-	    organized? */
-	enum c2_xcode_aggr              xct_aggr;
-	/** Type name. */
-	const char                     *xct_name;
-	/** Custom operations. */
-	const struct c2_xcode_type_ops *xct_ops;
-	/**
-	    Which atomic type this is?
-
-	    This field is valid only when xt->xct_aggr == C2_XA_ATOM.
-	 */
-	enum c2_xode_atom_type          xct_atype;
-	/**
-	   "Decorations" are used by xcode users to associate additional
-	   information with introspection elements.
-
-	   @see c2_xcode_decor_register()
-	   @see c2_xcode_field::xf_decor[]
-	 */
-	void                           *xct_decor[C2_XCODE_DECOR_MAX];
-	/** Size in bytes of in-memory instances of this type. */
-	size_t                          xct_sizeof;
-	/** Number of fields. */
-	size_t                          xct_nr;
-	/** Array of fields. */
-	struct c2_xcode_field           xct_child[0];
-};
-
-/** "Typed" xcode object. */
-struct c2_xcode_obj {
-	/** Object's type. */
-	const struct c2_xcode_type *xo_type;
-	/** Pointer to object in memory. */
-	void                       *xo_ptr;
-};
-
-/**
-   Custom xcoding functions.
-
-   User provides these functions (which are all optional) to use non-standard
-   xcoding.
-
-   @see c2_xcode_decode()
- */
-struct c2_xcode_type_ops {
-	int (*xto_length)(struct c2_xcode_ctx *ctx, const void *obj);
-	int (*xto_encode)(struct c2_xcode_ctx *ctx, const void *obj);
-	int (*xto_decode)(struct c2_xcode_ctx *ctx, void *obj);
-};
-
-enum { C2_XCODE_DEPTH_MAX = 10 };
-
-/**
-   @name iteration
-
-   xcode provides an iteration interface to walk through the hierarchy of types
-   and fields.
-
-   This interface consists of two functions: c2_xcode_next(), c2_xcode_skip()
-   and a c2_xcode_cursor data-type.
-
-   c2_xcode_next() takes a starting type (c2_xcode_type) and walks the tree of
-   its fields, their types, their fields &c., all the way down to the atomic
-   types.
-
-   c2_xcode_next() can be used to walk the tree in any "standard" order:
-   preorder, inorder and postorder traversals are supported. To this end,
-   c2_xcode_next() visits each tree node multiple times, setting the flag
-   c2_xcode_cursor::xcu_stack[]::s_flag according to the order.
- */
-/** @{ */
-
-/**
-    Traversal order.
- */
-enum c2_xcode_cursor_flag {
-	/** This value is never returned by c2_xcode_next(). It is set by the
-	    user to indicate the beginning of iteration. */
-	C2_XCODE_CURSOR_NONE,
-	/** Tree element is visited for the first time. */
-	C2_XCODE_CURSOR_PRE,
-	/** The sub-tree, rooted at an element's field has been processed
-	    fully. */
-	C2_XCODE_CURSOR_IN,
-	/** All fields have been processed fully, this is the last time the
-	    element is visited. */
-	C2_XCODE_CURSOR_POST,
-	C2_XCODE_CURSOR_NR
-};
-
-/** Human-readable names of values in c2_xcode_cursor_flag */
-extern const char *c2_xcode_cursor_flag_name[C2_XCODE_CURSOR_NR];
-
-/**
-    Cursor that captures the state of iteration.
-
-    The cursor contains a stack of "frames". A frame describes the iteration at
-    a particular level.
- */
-struct c2_xcode_cursor {
-	/** Depth of the iteration. */
-	int xcu_depth;
-	struct c2_xcode_cursor_frame {
-		/** An object that the iteration is currently in. */
-		struct c2_xcode_obj       s_obj;
-		/** A field within the object that the iteration is currently
-		    at. */
-		int                       s_fieldno;
-		/** A sequence element within the field that the iteration is
-		    currently at.
-
-		    This is valid iff ->s_obj->xo_type->xcf_aggr ==
-		    C2_XA_SEQUENCE.
-		 */
-		uint64_t                  s_elno;
-		/** Flag, indicating visiting order. */
-		enum c2_xcode_cursor_flag s_flag;
-	} xcu_stack[C2_XCODE_DEPTH_MAX];
-};
-
-/**
-   Iterates over tree of xcode types.
-
-   To start the iteration, call this with the cursor where
-   c2_xcode_cursor_frame::s_obj field of the 0th stack frame is set to the
-   desired object and the rest of the cursor is zeroed (see
-   c2_xcode_ctx_init()).
-
-   c2_xcode_next() returns a positive value when iteration can be continued, 0
-   when the iteration is complete and negative error code on error. The intended
-   usage pattern is
-
-   @code
-   while ((result = c2_xcode_next(it)) > 0) {
-           ... process next tree node ...
-   }
-   @endcode
-
-   On each return, c2_xcode_next() sets the cursor to point to the next element
-   reached in iteration. The information about the element is stored in the
-   topmost element of the cursor's stack and can be extracted with
-   c2_xcode_cursor_top().
-
-   An element with N children is reached 1 + N + 1 times: once in preorder, once
-   in inorder after each child is processed and once in postorder. Here N equals
-
-       - number of fields in a RECORD object;
-
-       - 1 or 2 in a UNION object: one for discriminator and one for an actually
-         present field, if any;
-
-       - 1 + (number of elements in array) in a SEQUENCE object. Additional 1 is
-         for count field;
-
-       - 0 for an ATOMIC object.
-
-   For example, to traverse the tree in preorder, one does something like
-
-   @code
-   while ((result = c2_xcode_next(it)) > 0) {
-           if (c2_xcode_cursor_top(it)->s_flag == C2_XCODE_CURSOR_PRE) {
-	           ... process the element ...
-           }
-   }
-   @endcode
- */
-int  c2_xcode_next(struct c2_xcode_cursor *it);
-
-/**
-   Abandons the iteration at the current level and returns one level up.
- */
-void c2_xcode_skip(struct c2_xcode_cursor *it);
-
-/** Returns the topmost frame in the cursor's stack. */
-struct c2_xcode_cursor_frame *c2_xcode_cursor_top(struct c2_xcode_cursor *it);
-
-/** @} iteration. */
-
-/**
-   @name xcoding.
-
-   Encoding-decoding (collectively xcoding) support is implemented on top of
-   introspection facilities provided by the xcode module. xcoding provides 3
-   operations:
-
-       - sizing (c2_xcode_length()): returns the size of a buffer sufficient to
-         hold serialized object representation;
-
-       - encoding (c2_xcode_encode()): constructs a serialized object
-         representation in a given buffer;
-
-       - decoding (c2_xcode_decode()): constructs an in-memory object, given its
-         serialized representation.
-
-   xcoding traverses the tree of sub-objects, starting from the topmost object
-   to be xcoded. For each visited object, if a method, corresponding to the
-   xcoding operation (encode, decode, length) is not NULL in object's type
-   c2_xcode_type_ops vector, this method is called and no further processing of
-   this object is done. Otherwise, "standard xcoding" takes place.
-
-   Standard xcoding is non-trivial only for leaves in the sub-object tree (i.e.,
-   for objects of ATOM aggregation type):
-
-       - for encoding, place object's value into the buffer, convert it to
-         desired endianness and advance buffer position;
-
-       - for decoding, extract value from the buffer, convert it, store in the
-         in-memory object and advance buffer position;
-
-       - for sizing, increment required buffer size by the size of atomic type.
-
-   In addition, decoding allocates memory as necessary.
- */
-/** @{ xcoding */
-
-/** Endianness (http://en.wikipedia.org/wiki/Endianness) */
-enum c2_xcode_endianness {
-	/** Little-endian. */
-	C2_XEND_LE,
-	/** Big-endian. */
-	C2_XEND_BE,
-	C2_XEND_NR
-};
-
-/** Human-readable names of values in c2_xcode_endianness */
-extern const char *c2_xcode_endianness_name[C2_XEND_NR];
-
-/** xcoding context.
-
-    The context contains information about attributes of xcoding operation and
-    its progress.
- */
-struct c2_xcode_ctx {
-	/** Endianness of serialized representation. */
-	enum c2_xcode_endianness xcx_end;
-	/**
-	    Current point in the buffer vector.
-
-	    The cursor points to the where encoding will write the next byte and
-	    from where decoding will read the next byte.
-	 */
-	struct c2_bufvec_cursor  xcx_buf;
-	/**
-	   State of the iteration through object tree.
-	 */
-	struct c2_xcode_cursor   xcx_it;
-	/**
-	   Allocation function used by decoding to allocate the topmost object
-	   and all its non-inline sub-objects (arrays and opaque sub-objects).
-	 */
-	void                  *(*xcx_alloc)(struct c2_xcode_ctx *ctx, size_t n);
-};
-
-/**
-   Sets up the context to start xcoding of a given object.
- */
-void c2_xcode_ctx_init(struct c2_xcode_ctx *ctx, const struct c2_xcode_obj *obj);
-
-int c2_xcode_decode(struct c2_xcode_ctx *ctx);
-int c2_xcode_encode(struct c2_xcode_ctx *ctx);
-
-/** Calculates the length of serialized representation. */
-int c2_xcode_length(struct c2_xcode_ctx *ctx);
-
-/** @} xcoding. */
-
-
-/**
-   Returns the address of a sub-object within an object.
-
-   @param obj    - typed object
-   @param fileno - ordinal number of field
-   @param elno   - for a SEQUENCE field, index of the element to
-                   return the address of.
-
-   The behaviour of this function for SEQUENCE objects depends on "elno"
-   value. SEQUENCE objects have the following structure:
-
-   @code
-   struct x_seq {
-           scalar_t  xs_nr;
-           struct y *xs_body;
-   };
-   @endcode
-
-   where xs_nr stores a number of elements in the sequence and xs_body points to
-   an array of the elements.
-
-   With fileno == 1, c2_xcode_addr() returns
-
-       - &xseq->xs_body when (elno == ~0ULL) and
-
-       - &xseq->xs_body[elno] otherwise.
- */
-void *c2_xcode_addr(const struct c2_xcode_obj *obj, int fieldno, uint64_t elno);
-
-/**
-   Helper macro to return field value cast to a given type.
- */
-#define C2_XCODE_VAL(obj, fieldno, elno, __type) \
-        ((__type *)c2_xcode_addr(obj, fieldno, elno))
-
-/**
-   Constructs a c2_xcode_obj instance representing a sub-object of a given
-   object.
-
-   Address of sub-object (subobj->xo_ptr) is obtained by calling
-   c2_xcode_addr().
-
-   Type of sub-object (subobj->xo_type) is usually the type stored in the parent
-   object's field (c2_xcode_field::xf_type), but for opaque fields it is
-   obtained by calling c2_xcode_field::xf_opaque().
- */
-int c2_xcode_subobj(struct c2_xcode_obj *subobj, const struct c2_xcode_obj *obj,
-		    int fieldno, uint64_t elno);
-
-/**
-   Returns the value of first field in a given object, assuming this field is
-   atomic.
-
-   This function is suitable to return discriminator of a UNION object or
-   element count of a SEQUENCE object.
-
-   @note when the first field has C2_XT_VOID type, the tag
-   (c2_xcode_field::xf_tag) of this field is returned.
- */
-uint64_t c2_xcode_tag(const struct c2_xcode_obj *obj);
-
-bool c2_xcode_type_invariant(const struct c2_xcode_type *xt);
-
-extern const struct c2_xcode_type C2_XT_VOID;
-extern const struct c2_xcode_type C2_XT_U8;
-extern const struct c2_xcode_type C2_XT_U32;
-extern const struct c2_xcode_type C2_XT_U64;
-
-extern const struct c2_xcode_type C2_XT_OPAQUE;
-
-/**
-   Void type used by ff2c in places where C syntax requires a type name.
- */
-typedef struct {;} c2_void_t;
-
-/**
-   Returns a previously unused "decoration number", which can be used as an
-   index in c2_xcode_field::xf_decor[] and c2_xcode_type::xct_decor[] arrays.
-
-   This number can be used to associate additional state with xcode
-   introspection elements:
-
-   @code
-   // in module foo
-   foo_decor_num = c2_xcode_decor_register();
-
-   ...
-
-   struct c2_xcode_type  *xt;
-   struct c2_xcode_field *f;
-
-   xt->xct_decor[foo_decor_num] = c2_alloc(sizeof(struct foo_type_decor));
-   f->xf_decor[foo_decor_num] = c2_alloc(sizeof(struct foo_field_decor));
-   @endcode
- */
-int c2_xcode_decor_register(void);
-
-struct c2_bob_type;
-
-/**
- * Partially initializes a branded object type from a xcode type descriptor.
- *
- * @see bob.h
- */
-void c2_xcode_bob_type_init(struct c2_bob_type *bt,
-			    const struct c2_xcode_type *xt,
-			    size_t magix_field, uint64_t magix);
-
-/** @} end of xcode group */
-
-/* __COLIBRI_XCODE_XCODE_H__ */
-#endif
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
diff --git a/yaml2db/Makefile.am b/yaml2db/Makefile.am
deleted file mode 100644
index 31dabaa..0000000
--- a/yaml2db/Makefile.am
+++ /dev/null
@@ -1,9 +0,0 @@
-yaml2dbdir             = $(includedir)/colibri/yaml2db
-yaml2db_HEADERS        = yaml2db.h
-
-noinst_LTLIBRARIES     = libcolibri-yaml2db.la
-
-libcolibri_yaml2db_la_SOURCES  = yaml2db.c
-libcolibri_yaml2db_la_LIBADD   =  @YAML_LIBS@
-
-INCLUDES = -I. -I$(top_srcdir) -I$(top_srcdir)/include -I/usr/include
diff --git a/yaml2db/st/.gitignore b/yaml2db/st/.gitignore
deleted file mode 100644
index 849ac8f..0000000
--- a/yaml2db/st/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-yaml2db
diff --git a/yaml2db/st/Makefile.am b/yaml2db/st/Makefile.am
deleted file mode 100644
index 42fa536..0000000
--- a/yaml2db/st/Makefile.am
+++ /dev/null
@@ -1,6 +0,0 @@
-YAML2DBUT_SRCDIR = @SRCDIR@/yaml2db/ut
-
-noinst_PROGRAMS = yaml2db
-
-yaml2db_SOURCES = main.c
-yaml2db_LDADD   = $(top_builddir)/colibri/libcolibri.la
diff --git a/yaml2db/st/main.c b/yaml2db/st/main.c
deleted file mode 100644
index a5fdbd2..0000000
--- a/yaml2db/st/main.c
+++ /dev/null
@@ -1,265 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Anup Barve <Anup_Barve@xyratex.com>
- * Original creation date: 08/13/2011
- */
-
-#ifdef HAVE_CONFIG_H
-#  include <config.h>
-#endif
-
-#include "colibri/init.h"
-#include "lib/errno.h"
-#include "lib/getopts.h"
-#include "lib/misc.h"
-#include "yaml2db/yaml2db.h"
-#include "cfg/cfg.h"
-
-/* Constant names and paths */
-static const char *D_PATH = "./__config_db";
-static const char *dev_str = "devices";
-
-/* Static declaration of device section keys array */
-static struct c2_yaml2db_section_key dev_section_keys[] = {
-	[0] = {"label", true},
-	[1] = {"interface", true},
-	[2] = {"media", true},
-	[3] = {"size", true},
-	[4] = {"state", true},
-	[5] = {"flags", true},
-	[6] = {"filename", true},
-	[7] = {"nodename", true},
-};
-
-/* Static declaration of device section table */
-static struct c2_yaml2db_section dev_section = {
-	.ys_table_name = "dev_table",
-	.ys_table_ops = &c2_cfg_storage_device_table_ops,
-	.ys_section_type = C2_YAML_TYPE_MAPPING,
-	.ys_num_keys = ARRAY_SIZE(dev_section_keys),
-	.ys_valid_keys = dev_section_keys,
-	.ys_key_str = "label",
-	.ys_ops = &c2_yaml2db_dev_section_ops,
-};
-
-static const char *interface_fields[] = {
-	"ATA",
-	"SATA",
-	"SCSI",
-	"SATA2",
-	"SCSI2",
-	"SAS",
-	"SAS2"
-};
-
-static const char *media_fields[] = {
-	"DISK",
-	"SSD",
-	"TAPE",
-	"ROM",
-};
-
-/* Default number of records to be generated */
-enum {
-	REC_NR = 1,
-};
-
-/* Max string size */
-enum {
-	STR_SIZE_NR = 40,
-};
-
-/* Generate a configuration file */
-static int generate_conf_file(const char *c_name, int rec_nr)
-{
-	FILE	*fp;
-	int	 cnt;
-	int	 index;
-	char	 str[STR_SIZE_NR];
-
-	C2_PRE(c_name != NULL);
-
-	fp = fopen(c_name, "a");
-	if (fp == NULL) {
-		fprintf(stderr, "Failed to create configuration file\n");
-		return -errno;
-	}
-
-	fprintf(fp,"%s:\n",dev_str);
-	if (rec_nr == 0)
-		rec_nr = REC_NR;
-
-	for (cnt = 0; cnt < rec_nr; ++cnt) {
-		fprintf(fp,"  -");
-
-		/* Set label */
-		sprintf(str, "LABEL%05d", cnt);
-		fprintf(fp," %s : %s\n", dev_section_keys[0].ysk_key,str);
-
-		/* Set interface */
-		index = rand() % ARRAY_SIZE(interface_fields);
-		strcpy(str, interface_fields[index]);
-		fprintf(fp,"    %s : %s\n", dev_section_keys[1].ysk_key,str);
-
-		/* Set media */
-		index = rand() % ARRAY_SIZE(media_fields);
-		strcpy(str, media_fields[index]);
-		fprintf(fp,"    %s : %s\n", dev_section_keys[2].ysk_key,str);
-
-		/* Set random size */
-		fprintf(fp,"    %s : %d\n", dev_section_keys[3].ysk_key,
-			rand() % 10000);
-
-		/* Set random state */
-		fprintf(fp,"    %s : %d\n", dev_section_keys[4].ysk_key,
-			rand() % 2);
-
-		/* Set random flags */
-		fprintf(fp,"    %s : %d\n", dev_section_keys[5].ysk_key,
-			rand() % 3);
-
-		/* Set filename */
-		sprintf(str, "/dev/sda%d", cnt);
-		fprintf(fp,"    %s : %s\n", dev_section_keys[6].ysk_key,str);
-
-		/* Set nodename */
-		sprintf(str, "n%d", cnt);
-		fprintf(fp,"    %s : %s\n", dev_section_keys[7].ysk_key,str);
-	}
-	fclose(fp);
-
-	return 0;
-}
-
-/**
-  Main function for yaml2db
-*/
-int main(int argc, char *argv[])
-{
-	int			 rc = 0;
-	int			 rec_nr = 0;
-	bool			 emitter = false;
-	bool			 dump = false;
-	bool			 generate = false;
-	const char		*c_name = NULL;
-	const char		*dump_fname = NULL;
-	const char		*d_path = NULL;
-	struct c2_yaml2db_ctx	 yctx;
-
-	/* Global c2_init */
-	rc = c2_init();
-	if (rc != 0)
-		return rc;
-
-	C2_SET0(&yctx);
-
-	/* Parse command line options */
-	rc = C2_GETOPTS("yaml2db", argc, argv,
-		C2_STRINGARG('b', "path of database directory",
-			LAMBDA(void, (const char *str) {d_path = str; })),
-		C2_STRINGARG('c', "config file in yaml format",
-			LAMBDA(void, (const char *str) {c_name = str; })),
-		C2_FLAGARG('d', "dump the key value contents", &dump),
-		C2_STRINGARG('f', "dump file name",
-			LAMBDA(void, (const char *str) {dump_fname = str; })),
-		C2_FLAGARG('g', "generate yaml config file", &generate),
-		C2_FORMATARG('n', "no. of records to be create", "%i", &rec_nr),
-		C2_FLAGARG('e', "emitter mode", &emitter));
-
-	if (rc != 0)
-		goto cleanup;
-
-	/* Config file has to be specified as a command line option */
-	if (!emitter && c_name == NULL) {
-		fprintf(stderr, "Error: Config file path not specified\n");
-		rc = -EINVAL;
-		goto cleanup;
-	}
-	yctx.yc_cname = c_name;
-
-	/* If generate flag is set, generate a yaml config file that can be
-	   used for testing */
-	if (generate) {
-	       generate_conf_file(c_name, rec_nr);
-	       return 0;
-	}
-
-	/* If database path not specified, set the default path */
-	if (d_path != NULL)
-		yctx.yc_dpath = d_path;
-	else
-		yctx.yc_dpath = D_PATH;
-
-	/* Based on the emitter flag, enable the yaml2db context type
-	   default is parser type */
-	if (emitter)
-		yctx.yc_type = C2_YAML2DB_CTX_EMITTER;
-	else
-		yctx.yc_type = C2_YAML2DB_CTX_PARSER;
-
-	if (dump) {
-		yctx.yc_dump_kv = true;
-		yctx.yc_dump_fname = dump_fname;
-	}
-
-	/* Initialize the parser and database environment */
-	rc = c2_yaml2db_init(&yctx);
-	if (rc != 0) {
-		fprintf(stderr, "Error: yaml2db initialization failed \n");
-		goto cleanup;
-	}
-
-	if (!emitter) {
-		/* Load the information from yaml file to yaml_document,
-		   and check for parsing errors internally */
-		rc = c2_yaml2db_doc_load(&yctx);
-		if (rc != 0) {
-			fprintf(stderr, "Error: document loading failed \n");
-			goto cleanup_parser_db;
-		}
-
-		/* Parse the dev configuration that is loaded in the context */
-		rc = c2_yaml2db_conf_load(&yctx, &dev_section, dev_str);
-		if (rc != 0)
-			fprintf(stderr, "Error: config loading failed \n");
-
-	} else {
-		rc = c2_yaml2db_conf_emit(&yctx, &dev_section, dev_str);
-		if (rc != 0)
-			fprintf(stderr, "Error: config emitting failed \n");
-	}
-
-cleanup_parser_db:
-	c2_yaml2db_fini(&yctx);
-
-cleanup:
-	c2_fini();
-
-	return rc;
-}
-
-/** @} end of yaml2db group */
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
diff --git a/yaml2db/st/test.sh b/yaml2db/st/test.sh
deleted file mode 100644
index 5d8d696..0000000
--- a/yaml2db/st/test.sh
+++ /dev/null
@@ -1,50 +0,0 @@
-#!/bin/bash
-
-set -x
-
-# Executable name
-EXEC="./yaml2db"
-
-# Input configuration file name
-INPUT_FILE="conf.yaml"
-
-# Database path
-DB_PATH="./__test_db"
-
-# Parse dump file
-PARSE_FILE="parse.txt"
-
-#Emit dump file
-EMIT_FILE="emit.txt"
-
-# Number of records to be generated in the configuration file
-REC_NR=141
-
-# Display options of the executable
-$EXEC -h
-
-# Generate the configuration file with given records
-$EXEC -c $INPUT_FILE -g -n $REC_NR
-
-# Parse the configuration file, store its contents in database
-# and dump the key-value pairs in a parse file
-$EXEC -c $INPUT_FILE -b $DB_PATH -d -f $PARSE_FILE
-
-# Scan the database and emit the key-value pairs in an emit file
-$EXEC -e -b $DB_PATH -d -f $EMIT_FILE
-
-# take diff of the dump files for parsing and emitting
-diff $PARSE_FILE $EMIT_FILE
-
-if [ $? == 0 ]
-then
-	echo "test passed."
-else
-	echo "test failed."
-fi
-
-rm -rf $PARSE_FILE $EMIT_FILE $INPUT_FILE
-
-sleep 30
-
-rm -rf $DB_PATH*
diff --git a/yaml2db/ut/Makefile.am b/yaml2db/ut/Makefile.am
deleted file mode 100644
index e8e5685..0000000
--- a/yaml2db/ut/Makefile.am
+++ /dev/null
@@ -1,3 +0,0 @@
-noinst_LTLIBRARIES   = libyaml2db-ut.la
-libyaml2db_ut_la_SOURCES  = yaml2db.c
-INCLUDES             = -I. -I$(top_srcdir) -I$(top_srcdir)/include
diff --git a/yaml2db/ut/yaml2db.c b/yaml2db/ut/yaml2db.c
deleted file mode 100644
index 73ee47b..0000000
--- a/yaml2db/ut/yaml2db.c
+++ /dev/null
@@ -1,460 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Anup Barve <Anup_Barve@xyratex.com>
- * Original creation date: 08/13/2011
- */
-
-#ifdef HAVE_CONFIG_H
-#  include <config.h>
-#endif
-
-#include "lib/misc.h"
-#include "lib/ut.h"
-#include "cfg/cfg.h"
-#include "yaml2db/yaml2db.h"
-
-/* Constant names and paths */
-static const char f_path[] = "./__conf_db_failure";
-static const char f_name[] = "conf_failure.yaml";
-static const char f_err_fname[] = "conf_failure_error";
-static const char mp_path[] = "./__conf_db_success_mp";
-static const char mp_name[] = "conf_success_mp.yaml";
-static const char ma_path[] = "./__conf_db_success_ma";
-static const char ma_name[] = "conf_success_ma.yaml";
-static const char s_path[] = "./__conf_db_dirty_scanner_error";
-static const char s_name[] = "conf_dirty_scanner_error.yaml";
-static const char s_err_fname[] = "conf_dirty_scanner_error";
-static const char p_path[] = "./__conf_db_dirty_parser_error";
-static const char p_name[] = "conf_dirty_parser_error.yaml";
-static const char p_err_fname[] = "conf_dirty_parser_error";
-static const char dev_str[] = "devices";
-static const char parse_dump_fname[] = "parse.txt";
-static const char emit_dump_fname[] = "emit.txt";
-
-/* Global yaml2db context */
-static struct c2_yaml2db_ctx yctx;
-
-/* Static declaration of device section keys array */
-static struct c2_yaml2db_section_key dev_section_keys[] = {
-	/* Mandatory keys */
-        [0] = {"label", true},
-        [1] = {"interface", true},
-        [2] = {"media", true},
-        [3] = {"size", true},
-        [4] = {"state", true},
-	/* Non-mandatory keys */
-        [5] = {"flags", false},
-        [6] = {"filename", false},
-        [7] = {"nodename", false},
-};
-
-/* Static declaration of device section table */
-static struct c2_yaml2db_section dev_section = {
-        .ys_table_name = "dev_table",
-        .ys_table_ops = &c2_cfg_storage_device_table_ops,
-        .ys_section_type = C2_YAML_TYPE_MAPPING,
-        .ys_num_keys = ARRAY_SIZE(dev_section_keys),
-        .ys_valid_keys = dev_section_keys,
-        .ys_key_str = "label",
-        .ys_ops = &c2_yaml2db_dev_section_ops,
-};
-
-static const char *interface_fields[] = {
-        "ATA",
-        "SATA",
-        "SCSI",
-        "SATA2",
-        "SCSI2",
-        "SAS",
-        "SAS2"
-};
-
-static const char *media_fields[] = {
-        "DISK",
-        "SSD",
-        "TAPE",
-        "ROM",
-};
-
-/* Default number of records to be generated */
-enum {
-	REC_NR = 63,
-};
-
-/* Max string size */
-enum {
-        STR_SIZE_NR = 40,
-};
-
-/*
-   Generate a configuration file
-   Parameters:
-   c_name - name of the file in which data has to be written
-   rec_nr - number of device records to be generated
-   skip_mandatory - true if mandatory fields should not be generated
-   skip_optional - true if optional fields should not to generated
- */
-static int generate_conf_file(const char *c_name, int rec_nr,
-			      const bool skip_mandatory,
-			      const bool skip_optional)
-{
-        FILE    *fp;
-        int      cnt;
-        int      index;
-        char     str[STR_SIZE_NR];
-
-        C2_PRE(c_name != NULL);
-
-        fp = fopen(c_name, "a");
-        if (fp == NULL) {
-                fprintf(stderr, "Failed to create configuration file\n");
-                return -errno;
-        }
-
-        fprintf(fp,"%s:\n",dev_str);
-        if (rec_nr == 0)
-                rec_nr = REC_NR;
-
-        for (cnt = 0; cnt < rec_nr; ++cnt) {
-                fprintf(fp,"  -");
-		/* set label (mandatory) */
-                sprintf(str, "LABEL%05d", cnt);
-                fprintf(fp," %s : %s\n", dev_section_keys[0].ysk_key,str);
-
-                if (!skip_mandatory) {
-			/* set interface (mandatory) */
-			index = rand() % ARRAY_SIZE(interface_fields);
-			strcpy(str, interface_fields[index]);
-			fprintf(fp,"    %s : %s\n", dev_section_keys[1].ysk_key,
-				str);
-
-			/* set media (mandatory) */
-			index = rand() % ARRAY_SIZE(media_fields);
-			strcpy(str, media_fields[index]);
-			fprintf(fp,"    %s : %s\n", dev_section_keys[2].ysk_key,
-				str);
-
-			/* set size (mandatory) */
-			fprintf(fp,"    %s : %d\n", dev_section_keys[3].ysk_key,
-				rand() % 10000);
-
-			/* set state (mandatory) */
-			fprintf(fp,"    %s : %d\n", dev_section_keys[4].ysk_key,
-				rand() % 2);
-		}
-
-		if (!skip_optional) {
-			/* set flags (optional) */
-			fprintf(fp,"    %s : %d\n", dev_section_keys[5].ysk_key,
-				rand() % 3);
-
-			/* set filename (optional) */
-			sprintf(str, "/dev/sda%d", cnt);
-			fprintf(fp,"    %s : %s\n", dev_section_keys[6].ysk_key,
-				str);
-
-			/* set nodename (optional) */
-			sprintf(str, "n%d", cnt);
-			fprintf(fp,"    %s : %s\n", dev_section_keys[7].ysk_key,
-				str);
-		}
-        }
-        fclose(fp);
-
-        return 0;
-}
-
-/*
-   Do not generate mandatory fields in the yaml file and try to load that file.
-   This should fail giving error message and each error message should also
-   state which of the mandatory fields are missing
- */
-static void mandatory_fields_absent(void)
-{
-	int                   rc;
-        char                  str[STR_SIZE_NR];
-	struct c2_ut_redirect redir;
-
-	c2_stream_redirect(stderr, f_err_fname, &redir);
-
-	/* Do not skip optional fields.
-	   Skip mandatory fields and expect error */
-	rc = generate_conf_file(f_name, REC_NR, true, false);
-	C2_UT_ASSERT(rc == 0);
-
-	C2_SET0(&yctx);
-
-	yctx.yc_cname = f_name;
-	yctx.yc_dpath = f_path;
-	yctx.yc_type = C2_YAML2DB_CTX_PARSER;
-
-	/* Reset any existing database */
-	rc = c2_ut_db_reset(f_path);
-	C2_UT_ASSERT(rc == 0);
-
-	rc = c2_yaml2db_init(&yctx);
-	C2_UT_ASSERT(rc == 0);
-
-	rc = c2_yaml2db_doc_load(&yctx);
-	C2_UT_ASSERT(rc == 0);
-
-	rc = c2_yaml2db_conf_load(&yctx, &dev_section, dev_str);
-	C2_UT_ASSERT(rc == -EINVAL);
-
-	rewind(stderr);
-	C2_UT_ASSERT(fgets(str, STR_SIZE_NR, stderr) != NULL);
-	C2_UT_ASSERT(strstr(str, "Error: Mandatory key not present") != NULL);
-
-	c2_stream_restore(&redir);
-
-	c2_yaml2db_fini(&yctx);
-}
-
-/*
-   Do not generate optional fields. Parsing and loading should succeed.
- */
-static void optional_fields_absent(void)
-{
-        int     rc;
-
-	/* Do not skip mandatory fields. Skip optional fields */
-        rc = generate_conf_file(ma_name, REC_NR, false, true);
-        C2_UT_ASSERT(rc == 0);
-
-	C2_SET0(&yctx);
-
-        yctx.yc_cname = ma_name;
-        yctx.yc_dpath = ma_path;
-	yctx.yc_type = C2_YAML2DB_CTX_PARSER;
-
-	/* Reset any existing database */
-	rc = c2_ut_db_reset(ma_path);
-	C2_UT_ASSERT(rc == 0);
-
-        rc = c2_yaml2db_init(&yctx);
-        C2_UT_ASSERT(rc == 0);
-
-        rc = c2_yaml2db_doc_load(&yctx);
-        C2_UT_ASSERT(rc == 0);
-
-        rc = c2_yaml2db_conf_load(&yctx, &dev_section, dev_str);
-        C2_UT_ASSERT(rc == 0);
-
-        c2_yaml2db_fini(&yctx);
-}
-
-/*
-   Generate all mandatory as well as optional fields. Parsing and loading
-   should succeed.
- */
-static void optional_fields_present(void)
-{
-        int     rc;
-
-	/* Do not skip mandatory as well as optional fields */
-	rc = generate_conf_file(mp_name, REC_NR, false, false);
-        C2_UT_ASSERT(rc == 0);
-
-	C2_SET0(&yctx);
-
-        yctx.yc_cname = mp_name;
-        yctx.yc_dpath = mp_path;
-	yctx.yc_dump_kv = true;
-	yctx.yc_dump_fname = parse_dump_fname;
-	yctx.yc_type = C2_YAML2DB_CTX_PARSER;
-
-	/* Reset any existing database */
-	rc = c2_ut_db_reset(mp_path);
-	C2_UT_ASSERT(rc == 0);
-
-        rc = c2_yaml2db_init(&yctx);
-        C2_UT_ASSERT(rc == 0);
-
-        rc = c2_yaml2db_doc_load(&yctx);
-        C2_UT_ASSERT(rc == 0);
-
-        rc = c2_yaml2db_conf_load(&yctx, &dev_section, dev_str);
-        C2_UT_ASSERT(rc == 0);
-
-        c2_yaml2db_fini(&yctx);
-}
-
-/*
-   Emit the already existing database entries created in
-   optional_fields_present(). Check it against the
-   parsed version. Both of them should match.
- */
-static void emit_verify(void)
-{
-	int  rc;
-        char str[STR_SIZE_NR];
-
-	C2_SET0(&yctx);
-
-	yctx.yc_dpath = mp_path;
-	yctx.yc_dump_kv = true;
-	yctx.yc_dump_fname = emit_dump_fname;
-	yctx.yc_type = C2_YAML2DB_CTX_EMITTER;
-
-	rc = c2_yaml2db_init(&yctx);
-	C2_UT_ASSERT(rc == 0);
-
-	rc = c2_yaml2db_conf_emit(&yctx, &dev_section, dev_str);
-	C2_UT_ASSERT(rc == 0);
-
-	c2_yaml2db_fini(&yctx);
-
-	/* Take diff of the dumps generated from parsing and emitting ops */
-	sprintf(str, "diff %s %s", parse_dump_fname, emit_dump_fname);
-	rc = system (str);
-	C2_UT_ASSERT(rc == 0);
-}
-
-/* Parser error types */
-enum error_type {
-	SCANNER_ERROR = 0,
-	PARSER_ERROR,
-	READER_ERROR
-};
-
-static int generate_dirty_conf_file(const char *c_name,
-				    const enum error_type etype)
-{
-	FILE *fp;
-	char  p = '%';
-
-	C2_PRE(c_name != NULL);
-
-	fp = fopen(c_name, "a");
-	C2_UT_ASSERT(fp != NULL);
-
-	switch(etype) {
-	case(SCANNER_ERROR):
-		fprintf(fp,"&&&  ----");
-		break;
-	case(PARSER_ERROR):
-		fprintf(fp,"%cYAML 1.2\n",p);
-		fprintf(fp,"%cYAML 1.2\n",p);
-		break;
-	/* It is difficult to reproduce reader error, hence not used */
-	case(READER_ERROR):
-		break;
-	default:
-		C2_IMPOSSIBLE("Invalid error type");
-	}
-
-	fclose(fp);
-
-	return 0;
-}
-
-/* Introduce a scanner error and check if the corresponding error is displayed
-   by the code */
-static void scanner_error_detect(void)
-{
-	int                   rc;
-	char	              str[STR_SIZE_NR];
-	struct c2_ut_redirect redir;
-
-	c2_stream_redirect(stderr, s_err_fname, &redir);
-
-	rc = generate_dirty_conf_file(s_name, SCANNER_ERROR);
-	C2_UT_ASSERT(rc == 0);
-
-	yctx.yc_cname = s_name;
-	yctx.yc_dpath = s_path;
-
-	/* Reset any existing database */
-	rc = c2_ut_db_reset(s_path);
-	C2_UT_ASSERT(rc == 0);
-
-	rc = c2_yaml2db_init(&yctx);
-	C2_UT_ASSERT(rc == 0);
-
-	rc = c2_yaml2db_doc_load(&yctx);
-	C2_UT_ASSERT(rc != 0);
-
-	rewind(stderr);
-	C2_UT_ASSERT(fgets(str, STR_SIZE_NR, stderr) != NULL);
-	C2_UT_ASSERT(strstr(str, "Scanner error") != NULL);
-
-	c2_stream_restore(&redir);
-
-	c2_yaml2db_fini(&yctx);
-}
-
-/* Introduce a parser error and check if the corresponding error is displayed
-   by the code */
-static void parser_error_detect(void)
-{
-	int                   rc;
-	char	              str[STR_SIZE_NR];
-	struct c2_ut_redirect redir;
-
-	c2_stream_redirect(stderr, p_err_fname, &redir);
-
-	rc = generate_dirty_conf_file(p_name, PARSER_ERROR);
-	C2_UT_ASSERT(rc == 0);
-
-	yctx.yc_cname = p_name;
-	yctx.yc_dpath = p_path;
-
-	/* Reset any existing database */
-	rc = c2_ut_db_reset(p_path);
-	C2_UT_ASSERT(rc == 0);
-
-	rc = c2_yaml2db_init(&yctx);
-	C2_UT_ASSERT(rc == 0);
-
-	rc = c2_yaml2db_doc_load(&yctx);
-	C2_UT_ASSERT(rc != 0);
-
-	rewind(stderr);
-	C2_UT_ASSERT(fgets(str, STR_SIZE_NR, stderr) != NULL);
-	C2_UT_ASSERT(strstr(str, "Parser error") != NULL);
-
-	c2_stream_restore(&redir);
-
-	c2_yaml2db_fini(&yctx);
-}
-
-const struct c2_test_suite yaml2db_ut = {
-	.ts_name = "yaml2db-ut",
-	.ts_init = NULL,
-	.ts_fini = NULL,
-	.ts_tests = {
-		{ "detect-scanner-error", scanner_error_detect },
-		{ "detect-parser-error", parser_error_detect },
-		{ "mandatory-fields-absent", mandatory_fields_absent },
-		{ "optional-fields-absent", optional_fields_absent },
-		{ "optional-fields-present", optional_fields_present },
-		{ "emit-and-verify", emit_verify },
-		{ NULL, NULL }
-	}
-};
-
-/** @} end of yaml2db group */
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
diff --git a/yaml2db/yaml2db.c b/yaml2db/yaml2db.c
deleted file mode 100644
index aa77a17..0000000
--- a/yaml2db/yaml2db.c
+++ /dev/null
@@ -1,762 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Anup Barve <Anup_Barve@xyratex.com>
- * Original creation date: 08/13/2011
- */
-
-#ifdef HAVE_CONFIG_H
-#  include <config.h>
-#endif
-
-#include <sys/stat.h>
-#include "lib/errno.h"
-#include "lib/memory.h"
-#include "lib/misc.h"
-#include "cfg/cfg.h"
-#include "yaml2db/yaml2db.h"
-
-/**
-  @addtogroup yaml2db
-  @{
- */
-
-/* ADDB Instrumentation yaml2db */
-static const struct c2_addb_ctx_type yaml2db_ctx_type = {
-        .act_name = "yaml2db"
-};
-
-static const struct c2_addb_loc yaml2db_addb_loc = {
-        .al_name = "yaml2db"
-};
-
-C2_ADDB_EV_DEFINE(yaml2db_func_fail, "yaml2db_func_fail",
-		  C2_ADDB_EVENT_FUNC_FAIL, C2_ADDB_FUNC_CALL);
-
-/* Forward declaration */
-static bool yaml2db_context_invariant(const struct c2_yaml2db_ctx *yctx);
-
-/**
-  Init function, which initializes the parser and sets input file
-  @param yctx - yaml2db context
-  @retval 0 if success, -errno otherwise
- */
-int c2_yaml2db_init(struct c2_yaml2db_ctx *yctx)
-{
-	int rc;
-
-	C2_PRE(yctx != NULL);
-	C2_PRE(yctx->yc_type != C2_YAML2DB_CTX_PARSER ||
-	       yctx->yc_type != C2_YAML2DB_CTX_EMITTER);
-
-	/* Initialize the ADDB context */
-        c2_addb_ctx_init(&yctx->yc_addb, &yaml2db_ctx_type,
-			 &c2_addb_global_ctx);
-
-	yctx->yc_db_init = false;
-
-	if (yctx->yc_type == C2_YAML2DB_CTX_PARSER) {
-
-		/* Initialize the parser. According to yaml documentation,
-		   parser_initialize command returns 1 in case of success */
-		rc = yaml_parser_initialize(&yctx->yc_parser);
-		if(rc != 1) {
-			C2_ADDB_ADD(&yctx->yc_addb, &yaml2db_addb_loc,
-				    yaml2db_func_fail,
-				    "yaml_parser_initialize", 0);
-			rc = -EINVAL;
-			goto cleanup;
-		}
-
-		/* Open the config file in read mode */
-		yctx->yc_fp = fopen(yctx->yc_cname, "r");
-		if (yctx->yc_fp == NULL) {
-			C2_ADDB_ADD(&yctx->yc_addb, &yaml2db_addb_loc,
-					yaml2db_func_fail, "fopen", 0);
-			yaml_parser_delete(&yctx->yc_parser);
-			rc = -errno;
-			goto cleanup;
-		}
-
-		/* Set the input file to the parser. */
-		yaml_parser_set_input_file(&yctx->yc_parser, yctx->yc_fp);
-
-	} else
-		yctx->yc_fp = NULL;
-
-
-	rc = c2_dbenv_init(&yctx->yc_db, yctx->yc_dpath, 0);
-
-	if (rc != 0) {
-                C2_ADDB_ADD(&yctx->yc_addb, &yaml2db_addb_loc,
-			    yaml2db_func_fail, "c2_dbenv_init", 0);
-		goto cleanup;
-	}
-
-	yctx->yc_db_init = true;
-
-	if (&yctx->yc_dump_kv && yctx->yc_dump_fname != NULL) {
-		yctx->yc_dp = fopen(yctx->yc_dump_fname, "w");
-		if (yctx->yc_dp == NULL) {
-			rc = -errno;
-			goto cleanup;
-		}
-	}
-
-	return 0;
-
-cleanup:
-        c2_addb_ctx_fini(&yctx->yc_addb);
-	if (yctx->yc_fp != NULL)
-		fclose(yctx->yc_fp);
-	yaml_document_delete(&yctx->yc_document);
-	if (yctx->yc_type == C2_YAML2DB_CTX_PARSER)
-		yaml_parser_delete(&yctx->yc_parser);
-	return rc;
-}
-
-/**
-  Fini function, which finalizes the parser and finies the db
-  @param yctx - yaml2db context
- */
-void c2_yaml2db_fini(struct c2_yaml2db_ctx *yctx)
-{
-	C2_PRE(yctx != NULL);
-
-	if (&yctx->yc_document != NULL)
-		yaml_document_delete(&yctx->yc_document);
-	if (&yctx->yc_parser != NULL)
-		yaml_parser_delete(&yctx->yc_parser);
-	if (yctx->yc_fp != NULL)
-		fclose(yctx->yc_fp);
-	if (yctx->yc_dp != NULL)
-		fclose(yctx->yc_dp);
-	if (&yctx->yc_db_init)
-		c2_dbenv_fini(&yctx->yc_db);
-        c2_addb_ctx_fini(&yctx->yc_addb);
-}
-
-/**
-  Function to detect and print parsing errors
-  @param parser - yaml_parser structure
- */
-static void yaml_parser_error_detect(const yaml_parser_t *parser)
-{
-	C2_PRE(parser != NULL);
-
-	switch (parser->error) {
-	case YAML_MEMORY_ERROR:
-	    fprintf(stderr, "Memory error: Not enough memory for parsing\n");
-	    break;
-	case YAML_READER_ERROR:
-	    if (parser->problem_value != -1)
-		fprintf(stderr, "Reader error: %s: #%X at %lu\n",
-			parser->problem, parser->problem_value,
-			parser->problem_offset);
-	    else
-		fprintf(stderr, "Reader error: %s at %lu\n",
-		        parser->problem, parser->problem_offset);
-		break;
-	case YAML_SCANNER_ERROR:
-	    if (parser->context)
-		fprintf(stderr, "Scanner error: %s at line %lu, column %lu"
-			" %s at line %lu, column %lu\n",
-			parser->context, parser->context_mark.line+1,
-			parser->context_mark.column+1, parser->problem,
-			parser->problem_mark.line+1,
-			parser->problem_mark.column+1);
-	    else
-		fprintf(stderr, "Scanner error: %s at line %lu, column %lu\n",
-			parser->problem, parser->problem_mark.line+1,
-			parser->problem_mark.column+1);
-	    break;
-	case YAML_PARSER_ERROR:
-	    if (parser->context)
-		fprintf(stderr, "Parser error: %s at line %lu, column %lu"
-			" %s at line %lu, column %lu\n",
-			parser->context, parser->context_mark.line+1,
-			parser->context_mark.column+1,parser->problem,
-			parser->problem_mark.line+1,
-			parser->problem_mark.column+1);
-	    else
-		fprintf(stderr, "Parser error: %s at line %lu, column %lu\n",
-			parser->problem, parser->problem_mark.line+1,
-			parser->problem_mark.column+1);
-		break;
-	default:
-		C2_IMPOSSIBLE("Invalid error");
-	}
-}
-
-/**
-  Function to load the yaml document
-  @param yctx - yaml2db context
-  @retval 0 if successful, -errno otherwise
- */
-int c2_yaml2db_doc_load(struct c2_yaml2db_ctx *yctx)
-{
-	int	     rc;
-	yaml_node_t *root_node;
-
-	C2_PRE(yctx != NULL);
-
-	rc = yaml_parser_load(&yctx->yc_parser, &yctx->yc_document);
-	if (rc != 1) {
-                C2_ADDB_ADD(&yctx->yc_addb, &yaml2db_addb_loc,
-			    yaml2db_func_fail, "yaml_parser_load", 0);
-		goto parser_error;
-	}
-
-	root_node = yaml_document_get_root_node(&yctx->yc_document);
-	if (root_node == NULL) {
-                C2_ADDB_ADD(&yctx->yc_addb, &yaml2db_addb_loc,
-			    yaml2db_func_fail,
-			    "yaml2db_document_get_root_node", 0);
-                yaml_document_delete(&yctx->yc_document);
-		return -EINVAL;
-	}
-	yctx->yc_root_node = *root_node;
-	return 0;
-
-parser_error:
-	yaml_parser_error_detect(&yctx->yc_parser);
-	return -EINVAL;
-}
-
-/**
-  Function to return the yaml_node as an anchor, given a scalar value
-  @param yctx - yaml2db context
-  @param value - scalar value to be checked in the document
-  @retval yaml_node_t pointer if successful, NULL otherwise
- */
-static yaml_node_t *yaml2db_scalar_locate(struct c2_yaml2db_ctx *yctx,
-					  const char *value)
-{
-	bool	     scalar_found = false;
-	yaml_node_t *node;
-
-	C2_PRE(yaml2db_context_invariant(yctx));
-	C2_PRE(value != NULL);
-
-	for (node = yctx->yc_document.nodes.start;
-	     node < yctx->yc_document.nodes.top; node++) {
-		if(node->type == YAML_SCALAR_NODE) {
-			if (strcmp((char *)node->data.scalar.value,
-				   (char *) value) == 0){
-				scalar_found = true;
-				break;
-			}
-		}
-	}
-
-	if (scalar_found)
-		return node;
-	else
-		return NULL;
-}
-
-/**
-  Check if the section structure is containing appropriate data
-  @param ysec - section structure to be checked
-  @retval true if necessary conditions satisfy, false otherwise
- */
-static bool yaml2db_section_invariant(const struct c2_yaml2db_section *ysec)
-{
-	if (ysec == NULL)
-		return false;
-
-	if (ysec->ys_table_name == NULL)
-		return false;
-
-	if (ysec->ys_table_ops == NULL)
-		return false;
-
-	if (ysec->ys_section_type >= C2_YAML_TYPE_NR)
-		return false;
-
-	if (ysec->ys_num_keys <= 0)
-		return false;
-
-	return true;
-}
-
-/**
-  Check if the context structure is containing appropriate data
-  @param yctx - context structure to be checked
-  @retval true if necessary conditions satisfy, false otherwise
- */
-static bool yaml2db_context_invariant(const struct c2_yaml2db_ctx *yctx)
-{
-	if (yctx == NULL)
-		return false;
-
-	if (yctx->yc_type == C2_YAML2DB_CTX_PARSER &&
-			&yctx->yc_parser == NULL)
-		return false;
-
-	if (yctx->yc_type == C2_YAML2DB_CTX_PARSER) {
-		if (yctx->yc_fp == NULL)
-			return false;
-	} else {
-		if (yctx->yc_fp != NULL)
-			return false;
-	}
-
-	if (&yctx->yc_document == NULL)
-		return false;
-
-	if (&yctx->yc_root_node == NULL)
-		return false;
-
-	if (&yctx->yc_db == NULL)
-		return false;
-
-	if (&yctx->yc_addb == NULL)
-		return false;
-
-	return true;
-}
-
-/**
-  Check if the key is a valid key for a given section
-  @param key - key to be validated
-  @param ysec - section structure against which the key needs to be validated
-  @retval index of key in section table for valid key, -EINVAL otherwise
- */
-static int validate_key_from_section(const yaml_char_t *key,
-				     const struct c2_yaml2db_section *ysec)
-{
-	int cnt = 0;
-
-        C2_PRE(yaml2db_section_invariant(ysec));
-	C2_PRE(key != NULL);
-
-	for (cnt = 0; cnt < ysec->ys_num_keys; cnt++)
-		if (strcmp((char *)key,
-			   (char *)ysec->ys_valid_keys[cnt].ysk_key) == 0)
-		       return cnt;
-	return -EINVAL;
-}
-
-/**
-  Check if all the mandatory keys have been supplied
-  @param ysec - pointer to section structure against which the key status
-  needs to be validated
-  @param valid_key_status - pointer to array of key status
-  @retval true if all mandatory keys are supplied, false otherwise
- */
-static bool validate_mandatory_keys(const struct c2_yaml2db_section *ysec,
-				    const bool *valid_key_status)
-{
-	int  cnt = 0;
-	bool rc = true;
-
-        C2_PRE(yaml2db_section_invariant(ysec));
-	C2_PRE(valid_key_status != NULL);
-
-	for (cnt = 0; cnt < ysec->ys_num_keys; cnt++) {
-		if (ysec->ys_valid_keys[cnt].ysk_mandatory &&
-				!valid_key_status[cnt]) {
-			rc = false;
-			fprintf(stderr,"Error: Mandatory key not present: %s\n",
-					(char *)ysec->ys_valid_keys[cnt].
-					ysk_key);
-		}
-	}
-	return rc;
-}
-
-/**
-  Function to the locate the key for a given yaml sequence
-  @param yctx - yaml2db context
-  @param node - yaml node pointer from which the sequence starts
-  @param yaml_str - yaml string that corresponds to the db record key
-  @retval yaml_node_t pointer if successful, NULL otherwise
- */
-static char *yaml2db_key_locate(struct c2_yaml2db_ctx *yctx,
-				const yaml_node_t *node,
-				const char *yaml_str)
-{
-	yaml_node_t		*k_node;
-	yaml_node_t		*v_node;
-	yaml_node_pair_t	*pair;
-	bool			 key_found = false;
-
-	C2_PRE(yaml2db_context_invariant(yctx));
-	C2_PRE(node != NULL);
-	C2_PRE(yaml_str != NULL);
-
-	c2_yaml2db_mapping_for_each (yctx, node, pair, k_node, v_node) {
-		if (strcmp((char *)k_node->data.scalar.value,
-					(char *) yaml_str) == 0){
-			key_found = true;
-			break;
-		}
-	}
-
-	if (key_found)
-		return (char *)v_node->data.scalar.value;
-	else
-		return NULL;
-}
-
-/**
-  Function to parse the yaml document
-  @param yctx - yaml2db context
-  @param ysec - section context corrsponding to the given parameter
-  @param conf_param - parameter for which configuration has to be loaded
-  @retval 0 if successful, -errno otherwise
- */
-int c2_yaml2db_conf_load(struct c2_yaml2db_ctx *yctx,
-			 struct c2_yaml2db_section *ysec,
-			 const char *conf_param)
-{
-        int                      rc;
-	/* gcc extension */
-	bool			 valid_key_status[ysec->ys_num_keys];
-	bool			 mandatory_keys_present;
-	size_t			 section_index;
-	char			*str;
-        struct c2_table		 table;
-        struct c2_db_tx		 tx;
-        struct c2_db_pair	 db_pair;
-	yaml_node_t		*node;
-	yaml_node_t		*s_node;
-	yaml_node_t		*k_node;
-	yaml_node_t		*v_node;
-	yaml_node_item_t	*item;
-	yaml_node_pair_t	*pair;
-	struct c2_cfg_storage_device__key  key;
-	struct c2_cfg_storage_device__val  val;
-
-        C2_PRE(yaml2db_context_invariant(yctx));
-        C2_PRE(yaml2db_section_invariant(ysec));
-
-        /* Initialize the table */
-        rc = c2_table_init(&table, &yctx->yc_db, ysec->ys_table_name,
-			   0, ysec->ys_table_ops);
-        if (rc != 0) {
-                C2_ADDB_ADD(&yctx->yc_addb, &yaml2db_addb_loc,
-			    yaml2db_func_fail, "c2_table_init", 0);
-                return rc;
-	}
-
-        /* Initialize the database transaction */
-        rc = c2_db_tx_init(&tx, &yctx->yc_db, 0);
-        if (rc != 0) {
-                C2_ADDB_ADD(&yctx->yc_addb, &yaml2db_addb_loc,
-			    yaml2db_func_fail, "c2_db_tx_init", 0);
-                c2_table_fini(&table);
-                return rc;
-        }
-
-	node = yaml2db_scalar_locate(yctx, conf_param);
-	if (node == NULL) {
-                C2_ADDB_ADD(&yctx->yc_addb, &yaml2db_addb_loc,
-			    yaml2db_func_fail, "yaml2db_scalar_locate", 0);
-                c2_table_fini(&table);
-		c2_db_tx_abort(&tx);
-		return -EINVAL;
-	}
-
-	node++;
-
-	c2_yaml2db_sequence_for_each(yctx, node, item, s_node) {
-		str = yaml2db_key_locate(yctx, s_node, ysec->ys_key_str);
-		if (str == NULL) {
-			fprintf(stderr, "Error: key for record not found\n");
-			continue;
-		}
-
-		C2_SET_ARR0(valid_key_status);
-		mandatory_keys_present = false;
-
-		ysec->ys_ops->so_key_populate((void *) &key, str);
-		c2_yaml2db_mapping_for_each (yctx, s_node, pair,
-					     k_node, v_node) {
-			section_index = validate_key_from_section(k_node->data.
-						scalar.value, ysec);
-			if (section_index == -EINVAL) {
-				fprintf(stderr, "Error: invalid key: %s\n",
-					k_node->data.scalar.value);
-				continue;
-			}
-			valid_key_status[section_index] = true;
-			rc = ysec->ys_ops->so_val_populate(ysec, (void *) &val,
-					(char *)k_node->data.scalar.value,
-					(char *)v_node->data.scalar.value);
-			if (rc != 0) {
-				C2_ADDB_ADD(&yctx->yc_addb, &yaml2db_addb_loc,
-						yaml2db_func_fail,
-						"section_value_populate", 0);
-				c2_table_fini(&table);
-				c2_db_tx_abort(&tx);
-				return rc;
-			}
-		}
-		c2_db_pair_setup(&db_pair, &table, &key, sizeof key,
-				&val, sizeof val);
-
-		rc = c2_table_update(&tx, &db_pair);
-		if (rc != 0) {
-			C2_ADDB_ADD(&yctx->yc_addb, &yaml2db_addb_loc,
-					yaml2db_func_fail,
-					"c2_table_insert", 0);
-			c2_db_pair_release(&db_pair);
-			c2_db_pair_fini(&db_pair);
-			c2_table_fini(&table);
-			c2_db_tx_abort(&tx);
-			return rc;
-		}
-		if (&yctx->yc_dump_kv && yctx->yc_dump_fname != NULL)
-			/* Ignore the return value as it does not
-			   matter if dump is done or not */
-			ysec->ys_ops->so_key_val_dump(yctx->yc_dp,
-						      (void *)&key,
-						      (void *)&val);
-		c2_db_pair_release(&db_pair);
-		c2_db_pair_fini(&db_pair);
-		mandatory_keys_present = validate_mandatory_keys(ysec,
-							valid_key_status);
-		if (!mandatory_keys_present) {
-			C2_ADDB_ADD(&yctx->yc_addb, &yaml2db_addb_loc,
-					yaml2db_func_fail,
-					"validate_mandatory_keys", 0);
-			c2_table_fini(&table);
-			c2_db_tx_abort(&tx);
-			return -EINVAL;
-		}
-	}
-	c2_db_tx_commit(&tx);
-	c2_table_fini(&table);
-	return rc;
-}
-
-/**
-  Function to emit the yaml document
-  @param yctx - yaml2db context
-  @param ysec - section context corrsponding to the given parameter
-  @param conf_param - parameter for which configuration has to be emitted
-  @retval 0 if successful, -errno otherwise
- */
-int c2_yaml2db_conf_emit(struct c2_yaml2db_ctx *yctx,
-                      const struct c2_yaml2db_section *ysec,
-		      const char *conf_param)
-{
-	int			 rc;
-        struct c2_table          table;
-        struct c2_db_tx          tx;
-        struct c2_db_pair        db_pair;
-        struct c2_db_cursor      db_cursor;
-	struct c2_cfg_storage_device__key  key;
-	struct c2_cfg_storage_device__val  val;
-	struct c2_cfg_storage_device__key  last_key;
-
-        C2_PRE(yaml2db_context_invariant(yctx));
-        C2_PRE(yaml2db_section_invariant(ysec));
-
-        /* Initialize the table */
-        rc = c2_table_init(&table, &yctx->yc_db, ysec->ys_table_name,
-			   0, ysec->ys_table_ops);
-        if (rc != 0) {
-                C2_ADDB_ADD(&yctx->yc_addb, &yaml2db_addb_loc,
-			    yaml2db_func_fail, "c2_table_init", rc);
-                return rc;
-        }
-
-       /* Initialize the database transaction */
-        rc = c2_db_tx_init(&tx, &yctx->yc_db, 0);
-        if (rc != 0) {
-                C2_ADDB_ADD(&yctx->yc_addb, &yaml2db_addb_loc,
-                                yaml2db_func_fail, "c2_db_tx_init", rc);
-                c2_table_fini(&table);
-                return rc;
-        }
-
-	rc = c2_db_cursor_init(&db_cursor, &table, &tx);
-        if (rc != 0) {
-                C2_ADDB_ADD(&yctx->yc_addb, &yaml2db_addb_loc,
-                                yaml2db_func_fail, "c2_db_cursor_init", rc);
-                c2_table_fini(&table);
-		c2_db_tx_abort(&tx);
-                return rc;
-        }
-
-	c2_db_pair_setup(&db_pair, &table, &last_key, sizeof last_key, NULL, 0);
-
-	/* Store the last key so that records can be iterated till
-	   the last key is found */
-	rc = c2_db_cursor_last(&db_cursor, &db_pair);
-        if (rc != 0) {
-                C2_ADDB_ADD(&yctx->yc_addb, &yaml2db_addb_loc,
-                                yaml2db_func_fail, "c2_db_cursor_last", rc);
-		goto cleanup;
-        }
-
-	/* Move the cursor to the start of the table */
-	c2_db_pair_setup(&db_pair, &table, &key, sizeof key, &val, sizeof val);
-	rc = c2_db_cursor_first(&db_cursor, &db_pair);
-        if (rc != 0) {
-                C2_ADDB_ADD(&yctx->yc_addb, &yaml2db_addb_loc,
-                                yaml2db_func_fail, "c2_db_cursor_first", rc);
-		goto cleanup;
-        }
-
-	/* Iterate the table */
-	while (1) {
-		if (&yctx->yc_dump_kv && yctx->yc_dump_fname != NULL)
-			/* Ignore the return value as it does not
-			   matter if dump is done or not */
-			ysec->ys_ops->so_key_val_dump(yctx->yc_dp, (void *)&key,
-						      (void *)&val);
-		if (memcmp(&key, &last_key, sizeof key) == 0)
-			break;
-
-		rc = c2_db_cursor_next(&db_cursor, &db_pair);
-		if (rc != 0) {
-			C2_ADDB_ADD(&yctx->yc_addb, &yaml2db_addb_loc,
-				    yaml2db_func_fail,
-				    "c2_db_cursor_next", rc);
-			goto cleanup;
-		}
-	}
-cleanup:
-	c2_db_pair_release(&db_pair);
-	c2_db_pair_fini(&db_pair);
-	c2_db_cursor_fini(&db_cursor);
-	if (rc == 0)
-		c2_db_tx_commit(&tx);
-	else
-		c2_db_tx_abort(&tx);
-        c2_table_fini(&table);
-        return rc;
-}
-
-/* Section op to populate the device key */
-static void device_key_populate(void *key, const char *val_str)
-{
-        struct c2_cfg_storage_device__key *dev_key = key;
-
-        strcpy (dev_key->csd_uuid.cu_uuid, val_str);
-}
-
-#define DEV_ENUM_CHECK_INTERFACE(interface, val_str, dev_val) \
-	if (strcmp(val_str, #interface) == 0) \
-		dev_val->csd_type = C2_CFG_DEVICE_INTERFACE_ ## interface;
-
-#define DEV_ENUM_CHECK_MEDIA(media, val_str, dev_val) \
-	if (strcmp(val_str, #media) == 0)  \
-		dev_val->csd_media = C2_CFG_DEVICE_MEDIA_ ## media;
-
-
-/* Section op to populate the device value*/
-static int device_val_populate (struct c2_yaml2db_section *ysec, void *val,
-				const char *key_str, const char *val_str)
-{
-        struct c2_cfg_storage_device__val *dev_val = val;
-
-	C2_PRE(yaml2db_section_invariant(ysec));
-	C2_PRE(val != NULL);
-	C2_PRE(key_str != NULL);
-	C2_PRE(val_str != NULL);
-
-        if (strcmp(key_str,"interface") == 0){
-		DEV_ENUM_CHECK_INTERFACE(ATA, val_str, dev_val);
-		DEV_ENUM_CHECK_INTERFACE(SATA, val_str, dev_val);
-		DEV_ENUM_CHECK_INTERFACE(SCSI, val_str, dev_val);
-		DEV_ENUM_CHECK_INTERFACE(SATA2, val_str, dev_val);
-		DEV_ENUM_CHECK_INTERFACE(SCSI2, val_str, dev_val);
-		DEV_ENUM_CHECK_INTERFACE(SAS, val_str, dev_val);
-		DEV_ENUM_CHECK_INTERFACE(SAS2, val_str, dev_val);
-		if (dev_val->csd_type == 0) {
-			return -EINVAL;
-		}
-                goto success;
-        }
-        if (strcmp(key_str,"media") == 0){
-		DEV_ENUM_CHECK_MEDIA(DISK, val_str, dev_val);
-		DEV_ENUM_CHECK_MEDIA(SSD, val_str, dev_val);
-		DEV_ENUM_CHECK_MEDIA(TAPE, val_str, dev_val);
-		DEV_ENUM_CHECK_MEDIA(ROM, val_str, dev_val);
-		if (dev_val->csd_media == 0)
-			return -EINVAL;
-                goto success;
-        }
-        if (strcmp(key_str,"size") == 0){
-                sscanf(val_str, "%lu", &dev_val->csd_size);
-                goto success;
-        }
-        if (strcmp(key_str,"state") == 0){
-                sscanf(val_str, "%lu", &dev_val->csd_last_state);
-		if (dev_val->csd_last_state > 3)
-			return -EINVAL;
-                goto success;
-        }
-        if (strcmp(key_str,"flags") == 0){
-                sscanf(val_str, "%lu", &dev_val->csd_flags);
-		if (dev_val->csd_flags > 7)
-			return -EINVAL;
-                goto success;
-        }
-        if (strcmp(key_str,"filename") == 0){
-                sscanf(val_str, "%s", dev_val->csd_filename);
-                goto success;
-        }
-        if (strcmp(key_str,"nodename") == 0){
-                sscanf(val_str, "%s", dev_val->csd_nodename);
-                goto success;
-        }
-success:
-	return 0;
-}
-
-/* yaml2db section op to dump the key-value data to a file */
-static void device_key_val_dump(FILE *fp, void *key, void *val)
-{
-        struct c2_cfg_storage_device__key *dev_key = key;
-        struct c2_cfg_storage_device__val *dev_val = val;
-
-        C2_PRE(fp != NULL);
-        C2_PRE(key != NULL);
-        C2_PRE(val != NULL);
-
-        fprintf(fp, "%s \t %u:%u:%lu:%lu:%lu:%s:%s\n",
-                dev_key->csd_uuid.cu_uuid,
-                dev_val->csd_type, dev_val->csd_media, dev_val->csd_size,
-                dev_val->csd_last_state, dev_val->csd_flags,
-                dev_val->csd_filename, dev_val->csd_nodename);
-}
-
-/* Section ops */
-const struct c2_yaml2db_section_ops c2_yaml2db_dev_section_ops = {
-        .so_key_populate = device_key_populate,
-        .so_val_populate = device_val_populate,
-        .so_key_val_dump = device_key_val_dump,
-};
-
-
-
-/** @} end of yaml2db group */
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
diff --git a/yaml2db/yaml2db.h b/yaml2db/yaml2db.h
deleted file mode 100644
index 444d24f..0000000
--- a/yaml2db/yaml2db.h
+++ /dev/null
@@ -1,316 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Anup Barve <Anup_Barve@xyratex.com>
- * Original creation date: 08/13/2011
- */
-
-#ifndef __COLIBRI_YAML2DB_H__
-#define __COLIBRI_YAML2DB_H__
-
-#include "db/db.h"
-#include "yaml.h"
-
-/**
-   @defgroup yaml2db YAML to Database Parser
-
-   @brief The yaml2db utility carries out following operations:
-   - parsing the configuration file in yaml format on management server
-   - storing the parsed information in database
-
-
-   See <a href="https://docs.google.com/a/xyratex.com/document/d/1Y2FccWZFA9yWXJiC-kld0XUrexoindOpMiHEGkqc3Rc/edit?hl=en_US">DLD of Configuration (dev_enum) </a>
-   for details on the design.
-
-   A typical yaml conf file will look like the following.
-   (The combinations of entries are only for illustration, covering all
-    possible values. They may or may not be valid in reality.
-    @see c2_cfg_storage_device__val)
-   @verbatim
-    devices:
-      - label     : LABEL1
-        interface : ATA
-	media     : DISK
-	size      : 77631820
-	state     : 1
-	flags     : 0
-	filename  : /dev/sda
-	nodename  : n0
-      - label     : LABEL2
-        interface : SATA
-	media     : SSD
-	size      : 281910680
-	state     : 0
-	flags     : 1
-	filename  : /dev/sda1
-	nodename  : n10
-      - label     : LABEL3
-        interface : SCSI
-	media     : TAPE
-	size      : 124321
-	state     : 0
-	flags     : 2
-	filename  : /dev/pt0
-	nodename  : n100
-      - label     : LABEL4
-        interface : SATA2
-	media     : ROM
-	size      : 98124321
-	state     : 0
-	flags     : 2
-	filename  : /dev/pcd0
-	nodename  : n200
-      - label     : LABEL5
-        interface : SCSI2
-	media     : DISK
-	size      : 9860772073
-	state     : 1
-	flags     : 1
-	filename  : /dev/sda2
-	nodename  : n200
-      - label     : LABEL6
-        interface : SAS
-	media     : DISK
-	size      : 68926892
-	state     : 0
-	flags     : 1
-	filename  : /dev/sda3
-	nodename  : n200
-      - label     : LABEL7
-        interface : SAS2
-	media     : DISK
-	size      : 27232723
-	state     : 1
-	flags     : 0
-	filename  : /dev/sdb
-	nodename  : n100
-   @endverbatim
-
-   @{
-
- */
-
-/**
-  Enumeration of yaml2db context type
- */
-enum c2_yaml2db_ctx_type {
-	/** Parser */
-	C2_YAML2DB_CTX_PARSER = 0,
-	/** Emitter */
-	C2_YAML2DB_CTX_EMITTER,
-	/** Maximum number of context types */
-	C2_YAML2DB_CTX_NR
-};
-
-/**
-  yaml2db structure
- */
-struct c2_yaml2db_ctx {
-	/** YAML parser struct */
-	yaml_parser_t			 yc_parser;
-	/** Enumeration to decide whether the context belongs
-	   to parser or emitter */
-	enum c2_yaml2db_ctx_type	 yc_type;
-	/** YAML document structure */
-	yaml_document_t			 yc_document;
-	/** Root node of the yaml_document */
-	yaml_node_t			 yc_root_node;
-	/** Config file name */
-	const char			*yc_cname;
-	/** Database path */
-	const char			*yc_dpath;
-	/** Database environment */
-	struct c2_dbenv			 yc_db;
-	/** Flag indicating if the database environment has been established */
-	bool				 yc_db_init;
-	/** ADDB context for the context */
-	struct c2_addb_ctx		 yc_addb;
-	/** File pointer for YAML file */
-	FILE				*yc_fp;
-	/** Flag indicating whether to dump the key-value pair to a file */
-	bool				 yc_dump_kv;
-	/** Dump file name */
-	const char			*yc_dump_fname;
-	/** File pointer for dump file */
-	FILE				*yc_dp;
-};
-
-/**
-  Enumeration of section types
- */
-enum c2_yaml2db_sec_type {
-	/** YAML sequence */
-	C2_YAML_TYPE_SEQUENCE = 0,
-	/** YAML mapping */
-	C2_YAML_TYPE_MAPPING,
-	/** Max section types */
-	C2_YAML_TYPE_NR
-};
-
-/**
-  Key structure for determining valid keys in a yaml2db section
- */
-struct c2_yaml2db_section_key {
-	/** Section key */
-	const char	*ysk_key;
-	/** Flag to determine if a key is mandatory or optional */
-	bool		 ysk_mandatory;
-};
-
-/**
-  yaml2db section
- */
-struct c2_yaml2db_section {
-	/** Name of the table in which this section is supposed to be stored */
-	const char			 *ys_table_name;
-	/** Table ops */
-	const struct c2_table_ops	 *ys_table_ops;
-	/** Type of section */
-	enum c2_yaml2db_sec_type	  ys_section_type;
-	/** Array of valid key structures */
-	struct c2_yaml2db_section_key	 *ys_valid_keys;
-	/** Number of keys in the array */
-	size_t				  ys_num_keys;
-	/** String representing the key for the record in yaml file */
-	const char			 *ys_key_str;
-	/** section ops */
-	const struct c2_yaml2db_section_ops    *ys_ops;
-};
-
-/**
-  Section ops
- */
-struct c2_yaml2db_section_ops {
-	/**
-	  Populate the key for the section.
-	  @param key - pointer to the in memory record key. Section specific
-	  routine should appropriately cast the key and set it.
-	  @param val_str - value string that has been parsed from the yaml file,
-	  to be used to populate the key structure entry
-	 */
-	void (*so_key_populate) (void *key, const char *val_str);
-	/**
-	  Populate the value for the section.
-	  @param ysec - pointer to yaml2db section
-	  @param key - pointer to the in memory record value
-	  @param key_str - key string that has been parsed from the yaml file,
-	  to be mapped against corresponding entry in the value structure.
-	  @param val_str - value string that has been parsed from the yaml file,
-	  to be used to populate the value structure entry
-	  @retval - 0 for success, -errno otherwise
-	 */
-	int (*so_val_populate) (struct c2_yaml2db_section *ysec, void *val,
-				const char *key_str, const char *val_str);
-	/**
-	  Dump the key and value for a record to the file having file
-	  descriptor fp.
-	  @param fp - FILE pointer to file in which data has to be dumped
-	  @param key - pointer to the key structure. Section specific dump
-	  routine should appropriately cast the key and then use it.
-	  @param val- pointer to the value structure. Section specific dump
-	  routine should appropriately cast the value and then use it.
-	 */
-	void (*so_key_val_dump) (FILE *fp, void *key, void *val);
-};
-
-extern const struct c2_yaml2db_section_ops c2_yaml2db_dev_section_ops;
-
-/**
-  Iterates over a yaml sequence
-  @param ctx - yaml2db context
-  @param node - starting node of the sequence
-  @param item - yaml_node_item_t pointer
-  @param s_node - sequence node at index pointed by item
- */
-#define c2_yaml2db_sequence_for_each(ctx, node, item, s_node) \
-	for (item = (node)->data.sequence.items.start; \
-	     item < (node)->data.sequence.items.top && \
-	     (s_node = yaml_document_get_node(&(ctx)->yc_document, *item)); \
-	     item++)
-
-/**
-  Iterates over a yaml mapping
-  @param ctx - yaml2db context
-  @param node - starting node of the sequence
-  @param pair - yaml_node_pair_t pointer
-  @param k_node - mapping node at index pointed by mapping pair key
-  @param v_node - mapping node at index pointed by mapping pair value
- */
-#define c2_yaml2db_mapping_for_each(ctx, node, pair, k_node, v_node) \
-	for (pair = (node)->data.mapping.pairs.start; \
-	     pair < (node)->data.mapping.pairs.top && \
-	     (k_node = yaml_document_get_node(&(ctx)->yc_document, \
-		     pair->key)) &&\
-	     (v_node = yaml_document_get_node(&(ctx)->yc_document, \
-		     pair->value)); \
-	     pair++)
-
-/**
-  Init function, which initializes the parser and sets input file
-  @param yctx - yaml2db context
-  @retval 0 if success, -errno otherwise
- */
-int c2_yaml2db_init(struct c2_yaml2db_ctx *yctx);
-
-/**
-  Fini function, which finalizes the parser and finies the db
-  @param yctx - yaml2db context
- */
-void c2_yaml2db_fini(struct c2_yaml2db_ctx *yctx);
-
-/**
-  Function to load the yaml document
-  @param yctx - yaml2db context
-  @retval 0 if successful, -errno otherwise
- */
-int c2_yaml2db_doc_load(struct c2_yaml2db_ctx *yctx);
-
-/**
-  Function to parse the yaml document and load its corresponding entries
-  into the database. Any existing entries are replaced.
-  @param yctx - yaml2db context
-  @param ysec - section context corrsponding to the given parameter
-  @param conf_param - parameter for which configuration has to be loaded
-  @retval 0 if successful, -errno otherwise
- */
-int c2_yaml2db_conf_load(struct c2_yaml2db_ctx *yctx,
-			 struct c2_yaml2db_section *ysec,
-			 const char *conf_param);
-
-/**
-  Function to emit the yaml document
-  @param yctx - yaml2db context
-  @param ysec - section context corrsponding to the given parameter
-  @param conf_param - parameter for which configuration has to be emitted
-  @retval 0 if successful, -errno otherwise
- */
-int c2_yaml2db_conf_emit(struct c2_yaml2db_ctx *yctx,
-			 const struct c2_yaml2db_section *ysec,
-			 const char *conf_param);
-
-/** @} end of yaml2db group */
-
-#endif /* __COLIBRI_YAML2DB_H__ */
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 79
- *  scroll-step: 1
- *  End:
- */
-- 
1.8.3.2

