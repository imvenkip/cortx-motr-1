From 8a013077852c917f100faed64a484823aca20d05 Mon Sep 17 00:00:00 2001
From: Nachiket Sahasrabuddhe <nachiket_sahasrabuddhe@xyratex.com>
Date: Tue, 19 Nov 2013 14:26:25 +0530
Subject: [PATCH 49/61] bigmemalloc.ut -UT runs but requires some refactoring.

---
 lib/ut/varr.c | 180 ++++++++++++++++------------------------------------------
 lib/varr.c    |   4 +-
 lib/varr.h    |   2 +-
 3 files changed, 53 insertions(+), 133 deletions(-)

diff --git a/lib/ut/varr.c b/lib/ut/varr.c
index d97a85a..324ed77 100644
--- a/lib/ut/varr.c
+++ b/lib/ut/varr.c
@@ -27,6 +27,7 @@
 #ifndef __KERNEL__
 #include <limits.h>		/* CHAR_BIT */
 #include <stdio.h>
+#include <math.h>
 #else
 #include <linux/limits.h>
 #endif
@@ -37,6 +38,13 @@ enum data_types {
 	DT_NON_POWTWO,
 };
 
+enum misc_params {
+	BUFF_SIZE     = 32,
+	BUFF_SHIFT    = 5,
+	OBJ_SHIFT     = 4,
+};
+
+M0_BASSERT(BUFF_SIZE == M0_BITS(BUFF_SHIFT));
 /* sizeof struct po2 is an integer power of two. */
 struct po2 {
 	uint64_t p_x;
@@ -59,26 +67,19 @@ struct non_po2 {
 	 __num operator __shift;					     \
 	 })
 
-static void test_init(void);
 static size_t size_get(enum data_types dt);
-static void test_size(void);
+static void test_obj_size(void);
 static void test_count(const struct m0_varr *varr);
 static void test_depth(void);
 static void test_iterate(void);
-
 void test_varr(void)
 {
-	test_init();
-	test_iterate();
-}
-
-static void test_init(void)
-{
-	test_size();
+	test_obj_size();
 	test_depth();
+	test_iterate();
 }
 
-static void test_size(void)
+static void test_obj_size(void)
 {
 	struct m0_varr  varr;
 	int		rc;
@@ -134,16 +135,29 @@ static void test_depth(void)
 	uint64_t     nr;
 	int          rc;
 	uint32_t     depth = 2;
-	uint64_t     bn;
+#ifndef __KERNEL__
+	uint32_t     max_depth;
+#endif
+	uint64_t     buff_nr;
 
 	M0_SET0(&varr);
 
-	for (bn = M0_VA_TNODE_NR; depth <= 10;
-	     bn *= (32/M0_VA_TNODEPTR_SIZE), ++depth) {
-		nr = bn * (safe_bitshift((uint64_t)1,  5 - 4, <<));
+#ifndef __KERNEL__
+	max_depth = log((uint64_t)(3072*1024*1024ULL *1ULL*
+			(BUFF_SIZE - M0_VA_TNODEPTR_SIZE)/
+			(BUFF_SIZE * M0_VA_TNODEPTR_SIZE*M0_VA_TNODE_NR) + 1))/
+		log (BUFF_SIZE/M0_VA_TNODEPTR_SIZE) + 1;
+	printf("\nmax depth = %d", max_depth);
+#endif
+
+	for (buff_nr = M0_VA_TNODE_NR; depth <= 11;
+	     buff_nr *= (BUFF_SIZE/M0_VA_TNODEPTR_SIZE), ++depth) {
+		nr = buff_nr * (safe_bitshift((uint64_t)1,
+					      BUFF_SHIFT - OBJ_SHIFT,
+					      <<));
 		M0_SET0(&varr);
 		rc = m0_varr_init(&varr, nr,
-				  size_get(DT_POWTWO), 32);
+				  size_get(DT_POWTWO), BUFF_SIZE);
 		M0_UT_ASSERT(rc == 0);
 		M0_UT_ASSERT(depth == varr.va_depth);
 		test_count(&varr);
@@ -156,16 +170,18 @@ static void test_iterate(void)
 	struct m0_varr varr;
 	uint64_t       nr;
 	int	       rc;
-	uint64_t       bn;
+	uint64_t       buff_nr;
 	uint32_t       depth = 2;
+	uint64_t       step;
 	struct po2    *arr_ele;
 
-	for (bn = M0_VA_TNODE_NR; depth <= 10;
-	     bn *= (32/M0_VA_TNODEPTR_SIZE), ++depth) {
-		nr = bn * (safe_bitshift((uint64_t)1,  5 - 4, <<));
+	for (buff_nr = M0_VA_TNODE_NR;
+	     depth <= 8; buff_nr *= (BUFF_SIZE/M0_VA_TNODEPTR_SIZE),
+	     ++depth) {
+		nr = buff_nr * (safe_bitshift((uint64_t)1,  BUFF_SHIFT -
+				     OBJ_SHIFT, <<));
 		M0_SET0(&varr);
-		rc = m0_varr_init(&varr, nr,
-				  size_get(DT_POWTWO), 32);
+		rc = m0_varr_init(&varr, nr, size_get(DT_POWTWO), BUFF_SIZE);
 		M0_UT_ASSERT(rc == 0);
 		M0_UT_ASSERT(depth == varr.va_depth);
 		test_count(&varr);
@@ -173,118 +189,22 @@ static void test_iterate(void)
 			obj->p_x = i;
 			obj->p_y = i;
 		} m0_varr_end_iter;
-		m0_varr_iter(&varr, struct po2, i, obj, 0, varr.va_nr, 1) {
+		m0_varr_iter(&varr, struct po2, i, obj, 0, varr.va_nr, 13) {
 			arr_ele = m0_varr_ele_get(&varr, i);
 			M0_UT_ASSERT(arr_ele == obj);
 			M0_UT_ASSERT(obj->p_x == obj->p_y && obj->p_x == i);
 		} m0_varr_end_iter;
-
+		if (depth == 8) {
+			for (step = 2; step <= 26000; ++step) {
+				m0_varr_iter(&varr, struct po2, i, obj, 0,
+					     varr.va_nr, step) {
+					arr_ele = m0_varr_ele_get(&varr, i);
+					M0_UT_ASSERT(arr_ele == obj);
+					M0_UT_ASSERT(obj->p_x == obj->p_y &&
+						     obj->p_x == i);
+				} m0_varr_end_iter;
+			}
+		}
 		m0_varr_fini(&varr);
 	}
 }
-#if 0
-static unsigned long ELEMENT_NR = 1234567;
-static unsigned long struct_nr  = 123456;
-static uint64_t FOO_MAGIC = 0x1234567890abcde;
-
-struct bar {
-	uint64_t b_8b;
-	uint64_t b_81b;
-	uint64_t b_82b;
-};
-
-/* 64 bytes long. */
-struct foo {
-	uint64_t       f_8b;
-	uint64_t       f_81b;
-	uint64_t       f_magic;
-	char          *f_ptr;
-	unsigned long *f_lptr;
-	struct bar     f_bar;
-};
-
-static struct foo **address_tracker;
-
-static void foo_init(struct foo *f, unsigned long id)
-{
-	f->f_8b   = (uint64_t)id;
-	f->f_81b  = (uint64_t)id;
-	f->f_magic = FOO_MAGIC;
-	f->f_ptr  = (char *)id;
-	f->f_lptr = (unsigned long *)id;
-	f->f_bar.b_8b  = (uint64_t)id;
-	f->f_bar.b_81b = (uint64_t)id;
-	f->f_bar.b_82b = (uint64_t)id;
-}
-
-static bool foo_check(struct foo *f, unsigned long id)
-{
-	return
-		f->f_8b  == (uint64_t)id &&
-		f->f_81b == (uint64_t)id &&
-		f->f_magic == FOO_MAGIC &&
-		f->f_ptr == (char *)id &&
-		f->f_lptr == (unsigned long *)id &&
-		f->f_bar.b_8b == (uint64_t)id &&
-		f->f_bar.b_81b == (uint64_t)id &&
-		f->f_bar.b_82b == (uint64_t)id;
-}
-
-void test_varr(void)
-{
-	int                  rc;
-	unsigned long        id;
-	unsigned long        ele_nr_in_buff;
-	unsigned long       *val;
-	unsigned long        cnt;
-	struct foo          *f;
-	struct m0_varr       arr;
-
-	/* varr used to store ELEMENT_NR, 8 byte long objects. */
-	rc = m0_varr_init(&arr, ELEMENT_NR, sizeof(unsigned long),
-			  M0_0VEC_ALIGN);
-
-	M0_UT_ASSERT(rc == 0);
-	M0_UT_ASSERT(arr.va_magic  == M0_LIB_GENARRAY_MAGIC);
-	M0_UT_ASSERT(arr.va_nr     == ELEMENT_NR);
-	M0_UT_ASSERT(arr.va_sizeof == sizeof(unsigned long));
-
-	ele_nr_in_buff = M0_0VEC_ALIGN / sizeof(unsigned long);
-
-	for (id = 0; id < ELEMENT_NR; ++id) {
-		val = m0_varr_ele_get(&arr, unsigned long, id);
-		*val = id;
-	}
-
-	for (id = ELEMENT_NR - 1; id != 0; --id) {
-		val = m0_varr_ele_get(&arr, unsigned long, id);
-		M0_UT_ASSERT(*val == id);
-	}
-
-	m0_varr_fini(&arr);
-
-	/* Genarray used to store array of structures. */
-	rc = m0_varr_init(&arr, struct_nr, sizeof *f, M0_0VEC_ALIGN);
-
-	M0_ALLOC_ARR(address_tracker, struct_nr);
-	M0_UT_ASSERT(address_tracker != NULL);
-
-	for (cnt = 0, id = 0; id < struct_nr; ++id, ++cnt) {
-		M0_UT_ASSERT(cnt == id);
-		f = m0_varr_ele_get(&arr, struct foo, id);
-		foo_init(f, id);
-		address_tracker[id] = f;
-	}
-
-	for (id = 0; id < struct_nr; ++id)
-		M0_UT_ASSERT(address_tracker[id]->f_magic == FOO_MAGIC);
-
-	for (id = struct_nr - 1; id != 0; --id) {
-		f = m0_varr_ele_get(&arr, struct foo, id);
-		M0_UT_ASSERT(f == address_tracker[id]);
-		M0_UT_ASSERT(foo_check(f, id));
-	}
-	m0_free(address_tracker);
-	m0_varr_fini(&arr);
-}
-#endif
diff --git a/lib/varr.c b/lib/varr.c
index 7a201ee..377915f 100644
--- a/lib/varr.c
+++ b/lib/varr.c
@@ -85,9 +85,9 @@ M0_INTERNAL uint64_t total_leaf_buffers(unsigned long nr,
 M0_INTERNAL uint64_t max_idx_within_level(const struct m0_varr_cursor *cursor,
 					  uint32_t depth);
 M0_INTERNAL uint32_t inc_to_idx_xlate(const struct m0_varr_cursor *cursor,
-					uint64_t carry, uint32_t depth);
+				      uint64_t carry, uint32_t depth);
 M0_INTERNAL uint64_t inc_for_next_level(const struct m0_varr_cursor *cursor,
-					  uint64_t carry, uint32_t depth);
+					uint64_t carry, uint32_t depth);
 
 M0_INTERNAL uint8_t log_radix(const struct m0_varr *arr, uint32_t level);
 /** Returns the ceiling of logarithm to the base two. */
diff --git a/lib/varr.h b/lib/varr.h
index 42d9a7d..cc1c7fb 100644
--- a/lib/varr.h
+++ b/lib/varr.h
@@ -92,7 +92,7 @@ enum m0_varr_tree_char {
 	/** Maximum allowable depth of a tree. */
 	M0_VA_DEPTH_MAX	     = 16,
 };
-M0_BASSERT(M0_VA_TNODE_NR == 1 << M0_VA_TNODE_NR_SHIFT);
+M0_BASSERT(M0_VA_TNODE_NR == M0_BITS(M0_VA_TNODE_NR_SHIFT));
 
 /**
  * An object that holds address of a node, and its index within a buffer of
-- 
1.8.3.2

