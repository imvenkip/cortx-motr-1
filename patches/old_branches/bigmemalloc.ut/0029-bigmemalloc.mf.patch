From 0246162f2601857a57b68d4706c7a30e4eed01e2 Mon Sep 17 00:00:00 2001
From: Nachiket Sahasrabuddhe <nachiket_sahasrabuddhe@xyratex.com>
Date: Wed, 25 Sep 2013 11:11:15 +0530
Subject: [PATCH 29/61] bigmemalloc.mf

-Separate initializations for ITERATE, PRE_ORDER, and POST_ORDER.
---
 lib/varr.c | 151 +++++++++++++++++++++++++++++++++++++++++++++++++++----------
 1 file changed, 127 insertions(+), 24 deletions(-)

diff --git a/lib/varr.c b/lib/varr.c
index 88b6c6b..73d451e 100644
--- a/lib/varr.c
+++ b/lib/varr.c
@@ -67,6 +67,7 @@ enum m0_varr_cursor_trav {
 
 struct m0_varr_path_element {
 	uint32_t  vp_index;
+	uint32_t  vp_width;
 	void	 *vp_buf;
 };
 
@@ -77,6 +78,12 @@ struct m0_varr_cursor {
 	enum m0_varr_cursor_trav     vc_trav;
 };
 
+M0_INTERNAL bool within_tree_width(const struct m0_varr_cursor *cursor,
+				   uint32_t depth, uint32_t index)
+{
+	return index < cursor->vc_path[depth - 1].vp_width;
+}
+
 M0_INTERNAL int m0_varr_cursor_init(struct m0_varr_cursor *cursor,
 				    const struct m0_varr *arr, uint32_t depth,
 				    enum m0_varr_cursor_trav traversal)
@@ -91,61 +98,157 @@ M0_INTERNAL int m0_varr_cursor_init(struct m0_varr_cursor *cursor,
 
 	pe		 = &cursor->vc_path[0];
 	cursor->vc_arr   = arr;
-	cursor->vc_depth = depth;
 	cursor->vc_trav  = traversal;
-	pe->vp_index	 = 0;
+	pe->vp_idx	 = 0;
 	pe->vp_buf	 = arr->va_tree;
 
-	if (traversal == BREADTH_FIRST) {
+	switch (traversal) {
+	case PRE_ORDER:
+		buf	   = pe->vp_buf;
+		++pe;
+		pe->vp_buf = (unsigned long *)*buf;
+		pe->vp_idx = 0;
+		cursor->vc_depth = 1;
+		break;
+	case ITERATE:
+		cursor->vc_depth = depth;
 		while (d < depth) {
 			buf = pe->vp_buf;
 			++pe;
-			pe->vp_index = 0;
+			pe->vp_idx = 0;
 			if (buf != NULL)
 				pe->vp_buf = (unsigned long *)*buf;
 			else
 				return -ENOMEM;
 			++d;
 		}
+		break;
+	case POST_ORDER:
+		while (d < arr->va_depth - 1) {
+			buf = pe->vp_buf;
+			++pe;
+			pe->vp_idx = 0;
+			if (buf != NULL)
+				pe->vp_buf = (unsigned long *)*buf;
+			else
+				return -ENOMEM;
+			++d;
+		}
+		break;
 	}
 	return 0;
 }
 
+M0_INTERNAL void* m0_varr_cursor_get(const struct m0_varr_cursor *cursor)
+{
+	return cursor->vc_path[cursor->vc_depth].vp_buf;
+}
 M0_INTERNAL int m0_varr_cursor_next(struct m0_varr_cursor *cursor)
 {
 
-	struct m0_varr_path_element *pe = cursor->vc_path[cursor->vc_depth - 1];
-	uint32_t		     d  = cursor->vc_depth;
+	struct m0_varr_path_element *pe
+	uint32_t		     d = cursor->vc_depth;
 
 	M0_PRE(cursor != NULL);
+	M0_PRE(d < M0_VARR_DEPTH_MAX);
+
+	pe = cursor->vc_path[d];
 
 	switch (cursor->vc_trav) {
-	case BREADTH_FIRST:
-		for (;d > 1 && !within_tree_width(cursor->vc_arr,
+	case ITERATE:
+		for (;d > 0 && !within_tree_width(cursor, d,
 						  pe->vp_index + 1);
 		     --pe, --d)
 			;
-		++pe->vp_index;
-		++pe->vp_buf;
-		while (d < cursor->vc_depth) {
-			buf = pe->vp_buf;
-			++pe;
-			if (buf == NULL)
-				return -ENOMEM;
-			pe->buf = (unsigned long*)*buf;
-			pe->idx = 0;
-			++d;
-		}
-		return 0;
+		if (d > 0) {
+			++pe->vp_index;
+			++pe->vp_buf;
+			while (d < cursor->vc_depth) {
+				buf = pe->vp_buf;
+				++pe;
+				pe->buf = (unsigned long*)*buf;
+				pe->idx = 0;
+				++d;
+			}
+			return 1;
+		} else
+			return 0;
 		break;
-	case DEPTH_FIRST:
-		if (cursor->vc_depth < arr->va_depth) {
-			
-		}
+	case PRE_ORDER:
+		for (;d > 0 && !within_tree_width(cursor, d,
+						  pe->vp_idx + 1)
+		     --pe, --d)
+			;
+		if (d > 0) {
+			if (d == cursor->vc_depth &&
+			    d != cursor->vc_arr->va_depth - 1) {
+				buf = pe->vp_buf;
+				++pe;
+				pe->buf = (unsigned long *)*buf;
+				pe->idx = 0;
+				++cursor->vc_depth;
+			} else {
+				++pe->vp_idx;
+				++pe->vp_buf;
+			}
+			return 1;
+		} else
+			return 0;
 
 		break;
+	case POST_ORDER:
+		if (within_tree_width(cursor, d,
+				      pe->vp_idx + 1)) {
+			++pe->vp_idx;
+			++pe->vp_buf;
+		} else {
+			--pe;
+			--d;
+		}
+		if (d > 0)
+			return 1;
+		else
+			return 0;
+		break;
 	}
+}
+
+M0_INTERNAL int varr_buffers_alloc(struct m0_varr *arr, uint64_t buf_nr)
+{
+	struct m0_varr_cursor cursor;
+	int		      rc;
+	unsigned long	      holder;
 
+	rc = m0_varr_cursor_init(&cursor, arr, 0, PRE_ORDER);
+	if (rc != 0)
+		goto end;
+	do {
+		holder = (unsigned long)m0_varr_buf_alloc(arr->va_bufsize);
+		if ((unsigned long *)holder == NULL) {
+			rc = -ENOMEM;
+			goto end;
+		}
+		m0_varr_cursor_get(&cursor) = (unsigned long*)holder;
+	} while (m0_varr_cursor_next(&cursor));
+end:
+	if (rc != 0)
+		varr_buffers_dealloc(arr, buf_nr);
+	return rc;
+}
+
+M0_INTERNAL void varr_buffers_dealloc(struct m0_varr *arr, uint64_t buf_nr)
+{
+	struct m0_varr_cursor cursor;
+	int		      rc;
+	unsigned long	      holder;
+
+	rc = m0_varr_cursor_init(&cursor, arr, arr->va_depth - 1, POST_ORDER);
+	M0_ASSERT(rc == 0);
+
+	while (m0_varr_cursor_next(&cursor)) {
+		holder = m0_varr_cursor_get(&cursor);
+		m0_varr_buf_free(holder, arr->va_bufsize);
+	}
 }
 /* A record in a stack holding address, and index associated with that address
  * within a buffer */
-- 
1.8.3.2

