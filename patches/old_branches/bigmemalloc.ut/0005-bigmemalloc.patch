From 789ae5b02e4e5d4263014808de99187aa02711da Mon Sep 17 00:00:00 2001
From: "anand.vidwansa" <anand_vidwansa@xyratex.com>
Date: Fri, 5 Jul 2013 02:32:19 -0700
Subject: [PATCH 05/61] bigmemalloc: - Rearranged functions and added forward
 declarations.

---
 lib/linux_kernel/genarray.c | 250 ++++++++++++++++++++++++--------------------
 1 file changed, 134 insertions(+), 116 deletions(-)

diff --git a/lib/linux_kernel/genarray.c b/lib/linux_kernel/genarray.c
index cccaba5..0a00ff6 100644
--- a/lib/linux_kernel/genarray.c
+++ b/lib/linux_kernel/genarray.c
@@ -37,13 +37,35 @@ static const struct m0_bob_type genarray_bobtype = {
 	.bt_check        = NULL,
 };
 
+M0_INTERNAL int level_find(unsigned long pg);
 static bool genarray_invariant(const struct genarray *arr);
-
-M0_INTERNAL int genarray_init(struct genarray *arr,
-		              uint64_t         len,
-			      size_t           typwidth);
-
+static int genarray_ln_alloc(struct genarray *arr,
+			     unsigned long    nr,
+			     int              level);
+static int genarray_l0_alloc(struct genarray *arr,
+			     unsigned long   *addr);
+static int genarray_l1_alloc(struct genarray *arr,
+			     unsigned long   *addr,
+			     unsigned long    nr);
+static int genarray_l2_alloc(struct genarray *arr,
+			     unsigned long   *addr,
+			     unsigned long    nr);
+static void genarray_ln_free(struct genarray *arr,
+			     unsigned long   *addr,
+			     int              level);
+static unsigned long page_nr_in_ln(const struct genarray *arr,
+				   int                    level);
+static void genarray_l0_free(struct genarray *arr,
+			     unsigned long   *addr);
+static void genarray_l1_free(struct genarray *arr,
+			     unsigned long   *addr);
+static void genarray_l2_free(struct genarray *arr,
+			     unsigned long   *addr);
 M0_INTERNAL void genarray_fini(struct genarray *arr);
+M0_INTERNAL unsigned long page_index_in_level_n(unsigned long pg,
+						int           level);
+static unsigned long page_nr_left_after_level_n(unsigned long pg,
+						int           level);
 
 M0_INTERNAL unsigned long genarray_obj_nr_in_page(const struct genarray *arr)
 {
@@ -53,6 +75,113 @@ M0_INTERNAL unsigned long genarray_obj_nr_in_page(const struct genarray *arr)
 	return PAGE_CACHE_SIZE / arr->ga_typwidth;
 }
 
+static bool genarray_invariant(const struct genarray *arr)
+{
+	return
+		genarray_bob_check(arr) &&
+		arr->ga_len > 0 &&
+		arr->ga_alloc > 0 &&
+		arr->ga_typwidth > 0 &&
+		M0_0VEC_ALIGN % arr->ga_typwidth == 0 &&
+		m0_forall(i, level_find(cont_nr_for_objs(arr->ga_len,
+			  genarray_obj_nr_in_page(arr))),
+			  (unsigned long *)arr->ga_levels[i] != NULL);
+}
+
+M0_INTERNAL int genarray_init(struct genarray *arr,
+			      uint64_t         len,
+			      size_t           typwidth)
+{
+	int            rc = 0;
+	int            level;
+	unsigned long  page_nr;
+	int            level_nr;
+
+	M0_PRE(arr != NULL);
+	M0_PRE(len  > 0);
+	M0_PRE(typwidth > 0);
+	M0_PRE(PAGE_CACHE_SIZE % typwidth == 0);
+
+	/*
+	 * Since two successive pages are not guaranteed to be contiguous,
+	 * structures bigger than page size can't fit in such array since
+	 * any attempt to dereference structure members can go over a
+	 * page size and can fault the program.
+	 */
+	if (len > (M0_0VEC_ALIGN / typwidth * PAGE_NR_TILL_LEVEL2) ||
+	    typwidth > M0_0VEC_ALIGN)
+		return -EINVAL;
+
+	arr->ga_len      = len;
+	arr->ga_alloc    = arr->ga_dealloc = 0;
+	arr->ga_typwidth = typwidth;
+	arr->ga_levels[GA_LEVEL0] = arr->ga_levels[GA_LEVEL1] =
+		arr->ga_levels[GA_LEVEL2] = 0;
+	genarray_bob_init(arr);
+
+	page_nr  = cont_nr_for_objs(len, genarray_obj_nr_in_page(arr));
+	level_nr = level_find(page_nr);
+
+	for (level = GA_LEVEL0; level <= level_nr; ++level) {
+		rc = genarray_ln_alloc(arr, page_nr_in_ln(arr, level), level);
+		if (rc != 0)
+			break;
+	}
+
+	if (rc != 0)
+		genarray_fini(arr);
+	else
+		M0_POST_EX(genarray_invariant(arr));
+	return rc;
+}
+
+M0_INTERNAL void genarray_fini(struct genarray *arr)
+{
+	int l;
+	int level;
+
+	M0_PRE(arr != NULL);
+	M0_PRE_EX(genarray_invariant(arr));
+
+	level = level_find(arr->ga_len / genarray_obj_nr_in_page(arr));
+	for (l = 0; l <= level; ++l)
+		genarray_ln_free(arr, &arr->ga_levels[l], l);
+
+	M0_POST(arr->ga_alloc == arr->ga_dealloc);
+	genarray_bob_fini(arr);
+	arr->ga_len = 0;
+	arr->ga_typwidth = 0;
+	arr->ga_alloc = arr->ga_dealloc = 0;
+}
+
+M0_INTERNAL unsigned long *genarray_page(const struct genarray *arr,
+					 unsigned long          id)
+{
+	int            level;
+	unsigned long  pg;
+	unsigned long *pgptr;
+
+	M0_PRE(arr != NULL);
+	M0_PRE(id  <  arr->ga_len);
+
+	pg    = id / genarray_obj_nr_in_page(arr);
+	level = level_find(pg);
+	pgptr = (unsigned long *)arr->ga_levels[level];
+
+	if (level == GA_LEVEL0)
+		return pgptr;
+
+	for (; level > 0; --level) {
+		pgptr += page_index_in_level_n(pg, level);
+		pg     = page_nr_left_after_level_n(pg, level);
+		/* Dereferences the page pointer at given offset. */
+		pgptr  = (unsigned long *)*pgptr;
+	}
+
+	M0_POST_EX(genarray_invariant(arr));
+	return pgptr;
+}
+
 static void genarray_l0_free(struct genarray *arr,
 			     unsigned long   *addr)
 {
@@ -63,10 +192,6 @@ static void genarray_l0_free(struct genarray *arr,
 	}
 }
 
-/*
- * Deallocates pages with first level of indirection.
- * If whole first level is occupied, 2M of memory is deallocated.
- */
 static void genarray_l1_free(struct genarray *arr,
 			     unsigned long   *addr)
 {
@@ -202,25 +327,6 @@ static int genarray_ln_alloc(struct genarray *arr,
 		genarray_l2_alloc(arr, &arr->ga_levels[GA_LEVEL2], nr);
 }
 
-M0_INTERNAL void genarray_fini(struct genarray *arr)
-{
-	int l;
-	int level;
-
-	M0_PRE(arr != NULL);
-	M0_PRE_EX(genarray_invariant(arr));
-
-	level = level_find(arr->ga_len / genarray_obj_nr_in_page(arr));
-	for (l = 0; l <= level; ++l)
-		genarray_ln_free(arr, &arr->ga_levels[l], l);
-
-	M0_POST(arr->ga_alloc == arr->ga_dealloc);
-	genarray_bob_fini(arr);
-	arr->ga_len = 0;
-	arr->ga_typwidth = 0;
-	arr->ga_alloc = arr->ga_dealloc = 0;
-}
-
 static uint64_t genarray_obj_nr_in_l0(const struct genarray *arr)
 {
 	return min64u(arr->ga_len, genarray_obj_nr_in_page(arr));
@@ -299,91 +405,3 @@ M0_INTERNAL int level_find(unsigned long pg)
 	       pg < PAGE_NR_IN_LEVEL0 ? GA_LEVEL0 :
 	       pg < PAGE_NR_TILL_LEVEL1 ? GA_LEVEL1 : GA_LEVEL2;
 }
-
-M0_INTERNAL unsigned long *genarray_page(const struct genarray *arr,
-					 unsigned long          id)
-{
-	int            level;
-	unsigned long  pg;
-	unsigned long *pgptr;
-
-	M0_PRE(arr != NULL);
-	M0_PRE(id  <  arr->ga_len);
-
-	pg    = id / genarray_obj_nr_in_page(arr);
-	level = level_find(pg);
-	pgptr = (unsigned long *)arr->ga_levels[level];
-
-	if (level == GA_LEVEL0)
-		return pgptr;
-
-	for (; level > 0; --level) {
-		pgptr += page_index_in_level_n(pg, level);
-		pg     = page_nr_left_after_level_n(pg, level);
-		/* Dereferences the page pointer at given offset. */
-		pgptr  = (unsigned long *)*pgptr;
-	}
-
-	M0_POST_EX(genarray_invariant(arr));
-	return pgptr;
-}
-
-static bool genarray_invariant(const struct genarray *arr)
-{
-	return
-		genarray_bob_check(arr) &&
-		arr->ga_len > 0 &&
-		arr->ga_alloc > 0 &&
-		arr->ga_typwidth > 0 &&
-		M0_0VEC_ALIGN % arr->ga_typwidth == 0 &&
-		m0_forall(i, level_find(cont_nr_for_objs(arr->ga_len,
-			  genarray_obj_nr_in_page(arr))),
-			  (unsigned long *)arr->ga_levels[i] != NULL);
-}
-
-M0_INTERNAL int genarray_init(struct genarray *arr,
-			      uint64_t         len,
-			      size_t           typwidth)
-{
-	int            rc = 0;
-	int            level;
-	unsigned long  page_nr;
-	int            level_nr;
-
-	M0_PRE(arr != NULL);
-	M0_PRE(len  > 0);
-	M0_PRE(typwidth > 0);
-	M0_PRE(PAGE_CACHE_SIZE % typwidth == 0);
-
-	/*
-	 * Since two successive pages are not guaranteed to be contiguous,
-	 * structures bigger than page size can't fit in such array since
-	 * any attempt to dereference structure members can go over a
-	 * page size and can fault the program.
-	 */
-	if (len > (M0_0VEC_ALIGN / typwidth * PAGE_NR_TILL_LEVEL2) ||
-	    typwidth > M0_0VEC_ALIGN)
-		return -EINVAL;
-
-	arr->ga_len      = len;
-	arr->ga_alloc    = arr->ga_dealloc = 0;
-	arr->ga_typwidth = typwidth;
-	arr->ga_levels[GA_LEVEL0] = arr->ga_levels[GA_LEVEL1] =
-		arr->ga_levels[GA_LEVEL2] = 0;
-	genarray_bob_init(arr);
-
-	page_nr  = cont_nr_for_objs(len, genarray_obj_nr_in_page(arr));
-	level_nr = level_find(page_nr);
-
-	for (level = GA_LEVEL0; level <= level_nr; ++level) {
-		rc = genarray_ln_alloc(arr, page_nr_in_ln(arr, level), level);
-		if (rc != 0)
-			break;
-	}
-
-	if (rc != 0)
-		genarray_fini(arr);
-	else
-		M0_POST_EX(genarray_invariant(arr));
-	return rc;
-}
-- 
1.8.3.2

