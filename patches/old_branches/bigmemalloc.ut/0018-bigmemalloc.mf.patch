From f1e67b655a85352eea37208d3129888a3446c199 Mon Sep 17 00:00:00 2001
From: Nachiket Sahasrabuddhe <nachiket_sahasrabuddhe@xyratex.com>
Date: Wed, 28 Aug 2013 17:29:50 +0530
Subject: [PATCH 18/61] bigmemalloc.mf

-Alloc and dealloc have been separated.
-Efficient usage of stack in dealloc case.
---
 lib/varr.c | 169 +++++++++++++++++++++++++++++++++++++++----------------------
 1 file changed, 109 insertions(+), 60 deletions(-)

diff --git a/lib/varr.c b/lib/varr.c
index de4ffde..764b773 100644
--- a/lib/varr.c
+++ b/lib/varr.c
@@ -78,6 +78,10 @@ enum buffer_action {
 	BA_NR
 };
 
+int push(struct m0_varr *arr, void *addr, uint64_t index)
+{
+	
+}
 M0_INTERNAL unsigned long varr_obj_nr_in_buff(const struct m0_varr *arr)
 {
 	M0_PRE(arr != NULL);
@@ -185,8 +189,8 @@ M0_INTERNAL int m0_varr_init(struct m0_varr *arr,
 	arr->va_depth   = level_find(arr, buff_nr);
 
 	/* Allocates the stack only if it is needed. */
-	if (arr->va_depth - 1 > 0) {
-		M0_ALLOC_ARR(arr->va_stack, arr->va_depth - 1);
+	if (arr->va_depth > 0) {
+		M0_ALLOC_ARR(arr->va_stack, arr->va_depth);
 		if (arr->va_stack == NULL)
 			rc = -ENOMEM;
 	}
@@ -282,10 +286,72 @@ static int buffers_helper(struct m0_varr     *arr,
 	return i == nr ? 0 : -ENOMEM;
 }
 
+/*
+ * While deallocating buffers, the leaf node buffers are deallocated first
+ * since during indexing these pages account for initial members of
+ * virtual array.
+ * The approach is centered towards maintaining a LIFO stack per iteration 
+ * which will store parent of a given level while traversing from top down.
+ * The whole approach is taken in order to implement tree traversal in an
+ * iterative manner rather than using recursive functions.
+ * This approach is a bit similar to inorder traversal of a tree but
+ * not exactly the same.
+ */
+static void varr_buffers_dealloc(struct m0_varr *arr,
+				 uint64_t buff_nr)
+{
+	int            rc;
+	int            node;
+	int            level;
+	uint64_t       nr;
+	uint64_t       done;
+	uint64_t       buff_nr_pn;
+	unsigned long *holder;
+	unsigned long *child;
+
+	M0_PRE(arr     != NULL);
+	M0_PRE(buff_nr  > 0);
+
+	for (done = 0, done_pt = 0, node = 0, child_id = 0; node < VA_TNODE_NR
+	     && done < buff_nr; ++node, done_pt = 0, level = 1) {
+		holder = arr->va_tree[node];
+		buff_nr_pn = min64u(max_buff_nr_till_lev_n_pn(arr, 1),
+				    buff_nr - done);
+		while (level > -1) {
+			while (child_id < arr->va_bufptr_nr &&
+			       *holder != NULL) {
+				nr = min64u(level != arr->va_depth ? 1 :
+						arr->va_bufptr_nr,
+						buff_nr_pn - done_pt);
+				if (level == arr->va_depth) {
+					rc = buffers_helper(arr, holder, nr,
+							    BA_DEALLOC);
+					M0_ASSERT(rc == 0);
+					done_pt += nr;
+					break;
+				}
+				else {
+					push(arr->va_stack, holder, child_id);
+					holder = (unsigned long *)*holder;
+					++level;
+					child_id = 0;
+				}
+			}
+			rc = pop(arr->va_stack, &holder, &child_id);
+			M0_ASSERT(rc == 0);
+			rc = buffers_helper(arr, holder, 1, BA_DEALLOC);
+			M0_ASSERT(rc == 0);
+			--level;
+			++holder;
+			++child_id;
+		}
+		done += done_pt;
+	}
+}
+
 /* Allocates buffers for given virtual array from level 0 to varr::va_depth. */
-static int varr_buffers_manage(struct m0_varr    *arr,
-		uint64_t           buff_nr,
-		enum buffer_action op)
+static int varr_buffers_alloc(struct m0_varr *arr,
+			      uint64_t        buff_nr)
 {
 	int            rc;
 	int            node;
@@ -302,8 +368,6 @@ static int varr_buffers_manage(struct m0_varr    *arr,
 	 * of some meta-buffer.
 	 */
 	unsigned long *holder;
-	unsigned long  ptr_inc;
-	unsigned long  last_ptr_inc;
 
 	M0_PRE(arr     != NULL);
 	M0_PRE(buff_nr  > 0);
@@ -321,17 +385,15 @@ static int varr_buffers_manage(struct m0_varr    *arr,
 	 * a pointer on each level, except for the last level.
 	 */
 	for (done = 0, node = 0, done_pt = 0; node < VA_TNODE_NR && done < buff_nr;
-			++node, done_pt = 0) {
-		if (op == BA_ALLOC) {
-			if (arr->va_tree[node] == NULL) {
-				rc = buffers_helper(arr, arr->va_tree[node],
-						1, op);
-				if (rc != 0)
-					goto end;
-			}
+	     ++node, done_pt = 0) {
+		if (arr->va_tree[node] == NULL) {
+			rc = buffers_helper(arr, arr->va_tree[node],
+					    1, BA_ALLOC);
+			if (rc != 0)
+				goto end;
 		}
 		buff_nr_pn = min64u(max_buff_nr_till_lev_n_pn(arr, 1),
-				buff_nr - done);
+				    buff_nr - done);
 		while (done_pt < buff_nr_pn) {
 			holder = arr->va_tree[node];
 			for (level = 1; level <= arr->va_depth &&
@@ -345,61 +407,48 @@ static int varr_buffers_manage(struct m0_varr    *arr,
 				 * multiple buffers.
 				 */
 				nr = min64u(level != arr->va_depth ? 1 :
-						arr->va_bufptr_nr,
-						buff_nr_pn - done_pt);
+					    arr->va_bufptr_nr,
+					    buff_nr_pn - done_pt);
 
 				/*
 				 * For last level, the holding address is
 				 * fixed and need not be computed.
 				 */
-				ptr_inc = index_in_level_n_pn(arr,
-						done_pt, level);
-
+					holder += index_in_level_n_pn(arr,
+							done_pt, level);
 
-				switch (op) {
-				case BA_ALLOC:
-					holder += ptr_inc;
-					if ((uint64_t *)*holder == NULL)
-						rc = buffers_helper(arr, holder, nr,
-								op);
-					break;
-				case BA_DEALLOC:
-					if (ptr_inc > 0 && (uint64_t *)*(holder + ptr_inc -1)!= NULL ) {
-						if (level != arr->va_depth) {
-							last_child = (unsigned long *)*(holder + ptr_inc - 1);
-							last_child += last_ptr_inc;
-							rc = buffers_helper(arr, last_child, last_nr, op);
-						}
-						rc = buffers_helper(arr, holder + ptr_inc - 1, nr,
-								    op);
-					}
-					holder += ptr_inc;
-					break;
+				/*
+				 * The loop travels same trail multiple times
+				 * until all buffers which fall in this trail
+				 * are allocated.
+				 * Meta-buffers in this trail could be already
+				 * allocated and no allocation is needed on
+				 * that level.
+				 */
+				if ((unsigned long *)*holder == NULL) {
+					rc = buffers_helper(arr, holder, nr,
+							    BA_ALLOC);
+					if (rc != 0)
+						goto end;
+					/*
+					 * Input buff_nr number is number of
+					 * _data_ buffers.
+					 */
+					if (level == arr->va_depth)
+						done_pt += nr;
 				}
-				if (rc != 0)
-					goto end;
-			}
-			if (level == arr->va_depth)
-				done_pt += nr;
-			/* We respect your privacy! */
-			if (level != arr->va_depth)
-				holder = (unsigned long *)*holder;
-			if (last_level > level)
-				last_ptr_inc = ptr_inc;
-		}
+				M0_ASSERT((unsigned long *)*holder != NULL);
 
-		if (op == BA_DEALLOC) {
-			rc = buffers_helper(arr, arr->va_tree[node],
-					1, op);
-			if (rc != 0)
-				goto end;
+				/* We respect your privacy! */
+				if (level != arr->va_depth)
+					holder = (unsigned long *)*holder;
+			}
 		}
+		done += buff_nr_pn;
 	}
-	done += buff_nr_pn;
-}
 end:
-M0_POST(ergo(rc == 0, done == buff_nr));
-return rc;
+	M0_POST(ergo(rc == 0, done == buff_nr));
+	return rc;
 }
 
 /*
-- 
1.8.3.2

