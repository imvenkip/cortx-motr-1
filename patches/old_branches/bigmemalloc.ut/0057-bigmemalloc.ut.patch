From b422504eb2cea8fe6aae7c5e7314e854dbfa9c44 Mon Sep 17 00:00:00 2001
From: Nachiket Sahasrabuddhe <nachiket_sahasrabuddhe@xyratex.com>
Date: Thu, 28 Nov 2013 11:37:07 +0530
Subject: [PATCH 57/61] bigmemalloc.ut

-UT runs successfully.
-Last commit had a bug, in the macro test_iterate().
-This bug has been fixed.
---
 lib/ut/varr.c | 35 ++++++++++++++++++-----------------
 1 file changed, 18 insertions(+), 17 deletions(-)

diff --git a/lib/ut/varr.c b/lib/ut/varr.c
index d075bd3..4a55808 100644
--- a/lib/ut/varr.c
+++ b/lib/ut/varr.c
@@ -46,9 +46,11 @@ enum misc_params {
 	BUFF_SIZE       = 32,
 	BUFF_SHIFT      = 5,
 	DT_POWTWO_SHIFT = 4,
+	DT_NON_POWTWO_SHIFT = BUFF_SHIFT,
 	DT_ATOMIC_SHIFT = 3,
 	MAX_OBJ_NR      = 26000,
 	MAX_DEPTH	= 11,
+	MAX_TEST_DEPTH  = 8,
 	//MAX_BUFFERS	= 22369536, 
 	MAX_BUFFERS	= 4096, 
 };
@@ -94,7 +96,7 @@ M0_BASSERT(sizeof (struct non_po2) < BUFF_SIZE &&
 	 uint64_t	 __step;					      \
 									      \
 	 M0_UT_ASSERT(size_get(dt) == sizeof __ele);			      \
-	 for (__buff_nr = M0_VA_TNODE_NR;				      \
+	 for (__buff_nr = M0_VA_TNODE_NR, __d = 2;			      \
 	      __d <= __depth; __buff_nr *= (BUFF_SIZE/M0_VA_TNODEPTR_SIZE),   \
 	      ++__d) {							      \
 		__nr = array_len_compute(__buff_nr, dt);		      \
@@ -109,7 +111,7 @@ M0_BASSERT(sizeof (struct non_po2) < BUFF_SIZE &&
 		m0_varr_for (__varr_, typeof(__ele), i, obj) {		      \
 			obj_sanity_check(obj, i, dt);			      \
 		} m0_varr_end_for;					      \
-		for (__step = 2; __step <= MAX_OBJ_NR; ++__step) {	      \
+		for (__step = 2; __step <= MAX_OBJ_NR && __d == __depth; ++__step) {	      \
 			m0_varr_iter(__varr_, typeof(__ele), i, obj, 0,	      \
 				     m0_varr_size(__varr_), __step) {	      \
 				obj_sanity_check((void *)obj, i, dt);	      \
@@ -124,7 +126,7 @@ static size_t size_get(enum data_types dt);
 static void test_init(void);
 static void test_size(void);
 static void test_tree_sanity(const struct m0_varr *varr, uint32_t depth);
-static void test_depth(void);
+static void test_depth(uint32_t max_depth);
 static void test_cache(void);
 static void test_iterations(void);
 static uint16_t int_summation(uint8_t n);
@@ -135,7 +137,7 @@ void test_varr(void)
 {
 	test_init();
 	test_size();
-	test_depth();
+	test_depth(MAX_TEST_DEPTH);
 	test_cache();
 	test_iterations();
 }
@@ -217,7 +219,7 @@ static void test_tree_sanity(const struct m0_varr *varr, uint32_t depth)
 	M0_UT_ASSERT(varr->va_depth == depth);
 }
 
-static void test_depth(void)
+static void test_depth(uint32_t max_depth)
 {
 	struct       m0_varr varr;
 	uint64_t     nr;
@@ -226,7 +228,7 @@ static void test_depth(void)
 	uint64_t     buff_nr;
 
 	M0_SET0(&varr);
-
+	M0_UT_ASSERT(max_depth > 1);
 /*
  * Following expression has been used to compute the maximum allowable tree
  * depth under given constraints. The expression can easily be derived by
@@ -237,7 +239,7 @@ static void test_depth(void)
 		log (BUFF_SIZE/M0_VA_TNODEPTR_SIZE) + 1;
 */
 
-	for (buff_nr = M0_VA_TNODE_NR; depth <= MAX_DEPTH;
+	for (buff_nr = M0_VA_TNODE_NR; depth <= max_depth;
 	     buff_nr *= (BUFF_SIZE/M0_VA_TNODEPTR_SIZE), ++depth) {
 		nr = buff_nr * (safe_bitshift((uint64_t)1,
 					      BUFF_SHIFT - DT_POWTWO_SHIFT,
@@ -278,8 +280,8 @@ static void test_iterations(void)
 	struct po2     obj_po2;
 	struct non_po2 obj_non_po2;
 
-	test_iterate(&varr, obj_po2, DT_POWTWO, 8);
-	test_iterate(&varr, obj_non_po2, DT_NON_POWTWO, 8);
+	test_iterate(&varr, obj_po2, DT_POWTWO, MAX_TEST_DEPTH);
+	test_iterate(&varr, obj_non_po2, DT_NON_POWTWO, MAX_TEST_DEPTH);
 }
 
 static uint16_t int_summation(uint8_t n)
@@ -308,9 +310,9 @@ uint32_t shift_get(enum data_types dt)
 	case DT_ATOMIC:
 		return DT_ATOMIC_SHIFT;
 	case DT_POWTWO:
-		return DT_POWTWO;
+		return DT_POWTWO_SHIFT;
 	case DT_NON_POWTWO:
-		return DT_NON_POWTWO;
+		return DT_NON_POWTWO_SHIFT;
 	}
 	return 0;
 }
@@ -321,7 +323,6 @@ static void obj_init(void *obj, uint64_t data, enum data_types dt)
 	struct po2     *obj_po2;
 	struct non_po2 *obj_non_po2;
 
-	M0_UT_ASSERT(data != 0);
 	switch (dt) {
 	case DT_ATOMIC:
 		*(uint64_t *)obj = data;
@@ -333,10 +334,11 @@ static void obj_init(void *obj, uint64_t data, enum data_types dt)
 		break;
 	case DT_NON_POWTWO:
 		obj_non_po2 = (struct non_po2 *)obj;
-		for (i = 0; i < ARRAY_SIZE(((struct non_po2 *)obj)->np_arr);
+		obj_non_po2->np_chksum = 0;
+		for (i = 0; i < ARRAY_SIZE(obj_non_po2->np_arr);
 		     ++i) {
-			obj_non_po2->np_arr[i]  = data * i;
-			obj_non_po2->np_chksum += data * i;
+			obj_non_po2->np_arr[i]  = (data % UINT8_MAX) * i;
+			obj_non_po2->np_chksum += (data % UINT8_MAX) * i;
 		}
 		break;
 	}
@@ -358,8 +360,7 @@ static void obj_sanity_check(void *obj, uint64_t data, enum data_types dt)
 		break;
 	case DT_NON_POWTWO:
 		obj_non_po2 = *(struct non_po2 *)obj;
-		M0_UT_ASSERT(obj_non_po2.np_chksum ==
-			     data *
+		M0_UT_ASSERT(obj_non_po2.np_chksum == (data % UINT8_MAX)*
 			     int_summation(ARRAY_SIZE(obj_non_po2.np_arr) -
 						      1));
 	}
-- 
1.8.3.2

