From 3b8baaf1ee327c02e8bca4fb81e2d9b27e82021a Mon Sep 17 00:00:00 2001
From: Nachiket Sahasrabuddhe <nachiket_sahasrabuddhe@xyratex.com>
Date: Mon, 25 Nov 2013 16:11:17 +0530
Subject: [PATCH 55/61] bigmemalloc.ut

-The function max_idx_within_level() has been fixed.
-Added an element m0_varr::va_failure_depth to hold depth at which
 allocation fails, in case of its failure.
-UT now includes fault injection for the case above.
-UT runs successfully.
---
 lib/ut/varr.c | 24 +++++++++++++++---------
 lib/varr.c    | 35 ++++++++++++++++++-----------------
 lib/varr.h    | 14 +++++++++-----
 3 files changed, 42 insertions(+), 31 deletions(-)

diff --git a/lib/ut/varr.c b/lib/ut/varr.c
index fffcb59..6e719b3 100644
--- a/lib/ut/varr.c
+++ b/lib/ut/varr.c
@@ -89,33 +89,37 @@ static void test_iterate(void);
 static uint16_t int_summation(uint8_t n);
 void test_varr(void)
 {
+	test_init();
 	test_obj_size();
 	test_depth();
 	test_cache();
 	test_iterate();
-	test_init();
 }
 
 static void test_init(void)
 {
 	struct m0_varr varr;
 	int	       rc;
-	uint64_t       n;
+	uint64_t       n = 1;
 	m0_time_t      seed;
 
 	M0_SET0(&varr);
 	rc = m0_varr_init(&varr, M0_VA_TNODE_NR, size_get(DT_POWTWO),
-			  M0_0VEC_ALIGN);
+			  BUFF_SIZE);
 	M0_UT_ASSERT(rc == 0);
 	m0_varr_fini(&varr);
 
 	/* Test error injection. */
 	seed = m0_time_now();
-	n = m0_rnd(MAX_BUFFERS, &seed);
-	m0_fi_enable_each_nth_time("varr_buffers_alloc", "varr_alloc", n);
+	while (!!(n % 2))
+		n = m0_rnd(MAX_BUFFERS, &seed);
+#ifndef __KERNEL__
+	printf("\nn = %lu", n);
+#endif
+	m0_fi_enable_off_n_on_m("varr_buffers_alloc", "varr_alloc", n, 2);
 	M0_SET0(&varr);
 	rc = m0_varr_init(&varr, MAX_OBJ_NR, size_get(DT_POWTWO),
-			  M0_0VEC_ALIGN);
+			  BUFF_SIZE);
 	if (rc == 0)
 		m0_varr_fini(&varr);
 	m0_fi_disable("varr_buffers_alloc", "varr_alloc");
@@ -161,9 +165,10 @@ static void test_tree_sanity(const struct m0_varr *varr, uint32_t depth)
 	buff_nr = safe_bitshift((uint64_t)1, varr->va_bufptr_nr_shift *
 				(varr->va_depth - 2), <<);
 	buff_nr *= num_trees;
+	M0_UT_ASSERT(varr->va_buff_nr <= buff_nr);
 	num_accomodated = safe_bitshift((uint64_t)1, varr->va_buf_shift -
 					varr->va_obj_shift, <<);
-	num_accomodated *= buff_nr;
+	num_accomodated *= varr->va_buff_nr;
 	M0_UT_ASSERT(num_accomodated >= varr->va_nr);
 	M0_UT_ASSERT(num_accomodated - varr->va_nr <
 			safe_bitshift((uint64_t)1, varr->va_buf_shift -
@@ -201,9 +206,9 @@ static void test_depth(void)
 		m0_varr_fini(&varr);
 	}
 }
+
 static void test_cache(void)
 {
-#if 1
 	struct m0_varr varr;
 	uint32_t       i;
 	uint32_t       obj_per_buff;
@@ -213,6 +218,7 @@ static void test_cache(void)
 	M0_SET0(&varr);
 	rc = m0_varr_init(&varr, MAX_OBJ_NR, size_get(DT_POWTWO), BUFF_SIZE);
 	M0_UT_ASSERT(rc == 0);
+	test_tree_sanity(&varr, 6);
 	obj_per_buff = varr.va_bufsize/ varr.va_obj_size;
 	for (i = 0; i < m0_varr_size(&varr); ++i) {
 		arr_ele = m0_varr_ele_get(&varr, i);
@@ -220,8 +226,8 @@ static void test_cache(void)
 			     (i % obj_per_buff) * varr.va_obj_size);
 	}
 	m0_varr_fini(&varr);
-#endif
 }
+
 static void test_iterate(void)
 {
 	struct m0_varr varr;
diff --git a/lib/varr.c b/lib/varr.c
index 56dc7ff..02b2d6c 100644
--- a/lib/varr.c
+++ b/lib/varr.c
@@ -134,10 +134,16 @@ M0_INTERNAL int m0_varr_init(struct m0_varr *arr, uint64_t nr, size_t size,
 	arr->va_bufptr_nr       = safe_bitshift((uint64_t) 1,
 						arr->va_bufptr_nr_shift, <<);
 	m0_varr_bob_init(arr);
+	arr->va_failure_depth   = 0;
 	M0_ALLOC_PTR(arr->va_cache);
-	if (arr->va_cache != NULL)
+	if (arr->va_cache != NULL) {
+		arr->va_buff_nr = total_leaf_buffers(arr->va_nr,
+						     varr_obj_nr_in_buff(arr),
+						     arr->va_buf_shift -
+						     arr->va_obj_shift);
+		arr->va_depth = depth_find(arr, arr->va_buff_nr);
 		rc = varr_buffers_alloc(arr);
-	else
+	} else
 		rc = -ENOMEM;
 	if (rc != 0)
 		m0_varr_fini(arr);
@@ -231,24 +237,17 @@ M0_INTERNAL int varr_buffers_alloc(struct m0_varr *arr)
 	int		      rc;
 	void		     *holder;
 	uint32_t	      i;
-	uint64_t	      buff_nr;
-	bool		      fi_flag;
-
-	buff_nr = total_leaf_buffers(arr->va_nr, varr_obj_nr_in_buff(arr),
-				     arr->va_buf_shift - arr->va_obj_shift);
-	arr->va_depth = depth_find(arr, buff_nr);
 
 	for (i = 1; i < arr->va_depth; ++i) {
 		rc = m0_varr_cursor_init(&cursor, arr, i);
 		if (rc != 0)
 			goto end;
 		do {
-			fi_flag = M0_FI_ENABLED("varr_alloc");
-			if (!fi_flag);
+			if (!M0_FI_ENABLED("varr_alloc"))
 				holder = m0_varr_buf_alloc(arr->va_bufsize);
-			if (holder == NULL || fi_flag) {
+			if (holder == NULL || M0_FI_ENABLED("varr_alloc")) {
 				rc = -ENOMEM;
-				arr->va_depth = cursor.vc_done == 0 ?
+				arr->va_failure_depth = cursor.vc_done == 0 ?
 				 cursor.vc_depth : cursor.vc_depth + 1;
 				goto end;
 			}
@@ -256,8 +255,6 @@ M0_INTERNAL int varr_buffers_alloc(struct m0_varr *arr)
 		} while (m0_varr_cursor_next(&cursor));
 	}
 end:
-	if (M0_FI_ENABLED("varr_alloc"))
-	    m0_fi_disable("varr_buffers_alloc", "varr_alloc_fails");
 	return rc;
 }
 
@@ -341,7 +338,7 @@ M0_INTERNAL int m0_varr_cursor_move(struct m0_varr_cursor *cursor,
 	pe = &cursor->vc_path[d];
 	max_idx_in_level = max_idx_within_level(cursor, d);
 	target_idx = cursor->vc_done + inc;
-	if (target_idx >= max_idx_in_level)
+	if (target_idx > max_idx_in_level)
 		goto end;
 	else if (target_idx == cursor->vc_done)
 		goto next;
@@ -383,7 +380,7 @@ M0_INTERNAL uint64_t max_idx_within_level(const struct m0_varr_cursor *cursor,
 		cursor->vc_arr->va_buf_shift - cursor->vc_arr->va_obj_shift +
 		(cursor->vc_arr->va_depth - depth - 1) *
 		cursor->vc_arr->va_bufptr_nr_shift;
-	return safe_bitshift(cursor->vc_arr->va_nr, shift, >>);
+	return safe_bitshift(cursor->vc_arr->va_nr - 1, shift, >>);
 }
 
 M0_INTERNAL uint32_t inc_to_idx_xlate(const struct m0_varr_cursor *cursor,
@@ -463,8 +460,12 @@ M0_INTERNAL void varr_buffers_dealloc(struct m0_varr *arr)
 	int		      rc;
 	void		     *holder;
 	uint32_t	      i;
+	uint32_t	      depth;
+
+	depth = arr->va_failure_depth == 0 ? arr->va_depth :
+		arr->va_failure_depth;
 
-	for (i = arr->va_depth - 1; i > 0; --i) {
+	for (i = depth - 1; i > 0; --i) {
 		rc = m0_varr_cursor_init(&cursor, arr, i);
 		M0_ASSERT(rc == 0);
 		do {
diff --git a/lib/varr.h b/lib/varr.h
index e842f07..f4bca3d 100644
--- a/lib/varr.h
+++ b/lib/varr.h
@@ -120,6 +120,8 @@ struct m0_varr_cursor {
 struct m0_varr {
 	/** Number of elements in array. */
 	uint64_t           va_nr;
+	/** Number of leaf buffers. */
+	uint64_t	   va_buff_nr;
 	size_t		   va_obj_size;
 	/** Log of object-size to the base two. */
 	uint8_t            va_obj_shift;
@@ -129,10 +131,10 @@ struct m0_varr {
 	 */
 	size_t		   va_bufsize;
 	/** Log of va_bufsize to the base two. */
-	uint8_t            va_buf_shift;
+	uint8_t		   va_buf_shift;
 
 	/** Depth of tree proportional to number of objects stored. */
-	uint32_t           va_depth;
+	uint32_t	   va_depth;
 
 	/**
 	 * Number of pointers that can be accommodated in one
@@ -143,7 +145,7 @@ struct m0_varr {
 	 * easily avoided by maintaining it as a member.
 	 */
 	uint64_t	   va_bufptr_nr;
-	uint8_t            va_bufptr_nr_shift;
+	uint8_t		   va_bufptr_nr_shift;
 
 	/**
 	 * Array of radix tree nodes, each of which represents an abstraction
@@ -151,11 +153,13 @@ struct m0_varr {
 	 * The arrangement is such that there could be n levels within any
 	 * tree node before a leaf node is reached.
 	 */
-	void              *va_tree[M0_VA_TNODE_NR];
+	void		  *va_tree[M0_VA_TNODE_NR];
 	/** Holds address of a buffer holding recently accessed object. */
 	struct varr_cache *va_cache;
+	/** Holds the cursor depth in case of a failure. */
+	uint32_t	   va_failure_depth;
 	/** Magic field to cross check sanity of structure. */
-	uint64_t           va_magic;
+	uint64_t	   va_magic;
 };
 
 /**
-- 
1.8.3.2

