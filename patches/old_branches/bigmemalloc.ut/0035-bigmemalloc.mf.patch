From 7930e84eeba992e32fd58c44679551ebcc3650c5 Mon Sep 17 00:00:00 2001
From: Nachiket Sahasrabuddhe <nachiket_sahasrabuddhe@xyratex.com>
Date: Wed, 9 Oct 2013 16:50:39 +0530
Subject: [PATCH 35/61] bigmemalloc.mf

-code for iterations is modified after locating few bugs. code is
 pretty ugly.
---
 lib/varr.c | 92 ++++++++++++++++++++++++++++++++++++++++++++------------------
 lib/varr.h |  3 +-
 2 files changed, 67 insertions(+), 28 deletions(-)

diff --git a/lib/varr.c b/lib/varr.c
index dbad89a..afee4e4 100644
--- a/lib/varr.c
+++ b/lib/varr.c
@@ -86,18 +86,20 @@ M0_INTERNAL bool within_tree_width(const struct m0_varr_cursor *cursor,
 M0_INTERNAL uint8_t nearest_power_of_two(size_t size);
 /* Returns a 64-bit number whose last 'n' bits are set, and rest are zero. */
 M0_INTERNAL uint64_t last_nbits_set(uint8_t n);
+/* Increments buffer based upon its level in a tree */
+M0_INTERNAL void * buff_incr(struct m0_varr *arr, uint32_t depth,
+			     void *buff, uint32_t incr);
 
 /* Shifts a given number to left/right by taking into account sizeof(number) */
 #define safe_bitshift(num, shift, operator)				     \
 	({								     \
 	 uint8_t        __shift = (shift);				     \
 	 typeof(num)    __num   = (num);				     \
-	 M0_ASSERT(!strcmp(#operator, "<<") || !strcmp(#operator, ">>"));   \
+	 M0_ASSERT(!strcmp(#operator, "<<") || !strcmp(#operator, ">>"));    \
 	 M0_ASSERT(__shift < CHAR_BIT * sizeof __num);			     \
 	 __num operator __shift;					     \
 	 })
 
-
 M0_INTERNAL int m0_varr_init(struct m0_varr *arr, uint64_t nr, size_t size,
 			     size_t bufsize)
 {
@@ -113,6 +115,8 @@ M0_INTERNAL int m0_varr_init(struct m0_varr *arr, uint64_t nr, size_t size,
 	/* Can result into padding if object and buffer sizes are not integer
 	 * powers of two. */
 	arr->va_obj_shift       = nearest_power_of_two(size);
+	arr->va_obj_size	= safe_bitshift((size_t)1, arr->va_obj_shift,
+						<<);
 	arr->va_buf_shift       = nearest_power_of_two(bufsize);
 	arr->va_bufsize		= safe_bitshift((size_t)1, arr->va_buf_shift,
 						<<);
@@ -307,56 +311,78 @@ M0_INTERNAL int m0_varr_cursor_move(struct m0_varr_cursor *cursor,
 	struct m0_varr_path_element *pe;
 	uint32_t		     d = cursor->vc_depth;
 	uint32_t		     leaves_beneath_shift;
+	uint32_t		     next_idx;
 
 	M0_PRE(cursor != NULL);
 	M0_PRE(d < VA_DEPTH_MAX);
 	M0_PRE(ergo(cursor->vc_trav != ITERATE, inc == 1));
 
 	pe = &cursor->vc_path[d];
-
+	next_idx = pe->vp_idx + inc;
+	idx_new  &= (pe->vp_width - 1);
 	switch (cursor->vc_trav) {
 	case ITERATE:
 		leaves_beneath_shift = 0;
 		while (d > 0 &&
-		       !within_tree_width(cursor->arr, pe->vp_idx +
-					  safe_bitshift(inc,
-						        leaves_beneath_shift,
-							>>))) {
+		       !within_tree_width(cursor->arr,
+					  pe->vp_idx + inc)) {
 			leaves_beneath_shift += log_radix(cursor->arr, d);
-			/*TODO*/
 			if (d == cursor->vc_depth)
-				completed_leaves_update(cursor, inc);
+				completed_leaves_update(cursor, d,
+							pe->vp_width -
+							pe->vp_idx);
+			else
+				completed_leaves_update(cursor, d,
+							pe->vp_width -
+							pe->vp_idx - 1);
+			inc = safe_bitshift(next_idx, leaves_beneath_shift,
+					    >>);
 			--d;
 			--pe;
 		}
+
 		if (d > 0) {
-			while (d <= cursor->vc_depth && inc > 0) {
-				inc = safe_bitshift(inc, leaves_beneath_shift,
-						    >>);
+			if (d != cursor->vc_depth) {
+				pe->vp_buf = buff_incr(cursor->arr, d,
+						       pe->vp_buf, inc);
+				pe->vp_idx += inc;
+				next_idx &= varr_obj_nr_in_buff(cursor->vc_arr) *
+					 max_buff_nr_till_lev_n_pn(cursor->vc_arr,
+								  cursor->vc_arr->va_depth - 1) - 1;
+			}
+			do {
+				inc     = safe_bitshift(next_idx,
+							leaves_beneath_shift,
+							>>);
+				pe->vp_buf = buff_incr(cursor->arr, d,
+						       pe->vp_buf, inc);
 				pe->vp_idx += inc;
-				pe->vp_buf += inc;
 				if (d == cursor->vc_depth)
-					completed_leaves_update(cursor,
-								inc);
+					completed_leaves_update(cursor, d, inc);
 				else {
-					++d;
+					if (inc > 0)
+						completed_leaves_update(cursor, d,
+									inc - 1);
 					buf = (unsigned long *)pe->vp_buf;
+					++pe;
 					pe->vp_buf = (void *)(*buf);
 					pe->vp_idx = 0;
-					if (d == curso->vc_depth)
-						break;
+					leaves_beneath_shift -=
+						log_radix(cursor->arr, d);
 				}
-			}
+				++d;
+			} while (d < cursor->vc_done);
 			goto next;
 		} else
 			goto end;
 		break;
+
 	case PRE_ORDER:
 		for (;d > 0 && !within_tree_width(cursor, d,
 						  pe->vp_idx + 1);
 		     --pe, --d) {
 			if (d == cursor->vc_arr->va_depth - 1)
-				completed_leaves_update(cursor, 1);
+				completed_leaves_update(cursor, d, 1);
 		}
 
 		if (d > 0) {
@@ -373,13 +399,13 @@ M0_INTERNAL int m0_varr_cursor_move(struct m0_varr_cursor *cursor,
 				++pe->vp_buf;
 				cursor->vc_depth = d;
 				if (d == cursor->vc_arr->va_depth - 1)
-					completed_leaves_update(cursor,
-								    1);
+					completed_leaves_update(cursor, d, 1);
 			}
 			goto next;
 		} else
 			goto end;
 		break;
+
 	case POST_ORDER:
 		if (d == cursor->vc_arr->va_depth)
 			++cursor->vc_done;
@@ -413,11 +439,11 @@ M0_INTERNAL bool within_tree_width(const struct m0_varr_cursor *cursor,
 }
 
 M0_INTERNAL void completed_leaves_update(struct m0_varr_cursor *cursor,
-					     uint32_t inc)
+					 uint32_t depth, uint32_t inc)
 {
 	M0_PRE(cursor != NULL);
 	cursor->vc_done += inc * max_buff_nr_till_lev_n_pn(cursor->vc_arr,
-							   cursor->vc_depth);
+							   depth);
 }
 
 /*
@@ -439,6 +465,20 @@ M0_INTERNAL uint64_t max_buff_nr_till_lev_n_pn(const struct m0_varr *arr,
 			     <<);
 }
 
+M0_INTERNAL void *buff_incr(struct m0_varr *arr, uint32_t depth,
+			    void *buff, uint32_t incr)
+{
+	uint32_t obj_size;
+
+	M0_PRE(arr != NULL && buff != NULL);
+
+	if (depth == arr->va_depth)
+		buff += arr->obj_size;
+	else
+		++buff;
+	return buff;
+}
+
 M0_INTERNAL void varr_buffers_dealloc(struct m0_varr *arr, uint64_t buf_nr)
 {
 	struct m0_varr_cursor cursor;
@@ -512,8 +552,8 @@ M0_INTERNAL void *m0_varr_ele_get(struct m0_varr *arr, uint64_t index)
 	cache_update(arr, holder, index & (~obj_mask));
 	M0_POST_EX(varr_invariant(arr));
 end:
-	/* Adds to holder the value of last arr->va_obj_shift bits
-	 * from index. */
+	/* TODO*/
+	/* Adds to holder the index of required object within a buffer */
 	return holder + (index & (varr_obj_nr_in_buff(arr) - 1));
 }
 
diff --git a/lib/varr.h b/lib/varr.h
index 14001f1..417e022 100644
--- a/lib/varr.h
+++ b/lib/varr.h
@@ -94,7 +94,7 @@ struct m0_varr {
 
 	/** Log of object-size to the base two. */
 	uint8_t               va_obj_shift;
-
+	size_t		      va_obj_size;
 	/** Size of buffer which is used to store objects from array. */
 	size_t		      va_bufsize;
 	/** Log of va_bufsize to the base 2. */
@@ -124,7 +124,6 @@ struct m0_varr {
 	 * up the lookups.
 	 */
 	void                 *va_tree[VA_TNODE_NR];
-	
 	/**
 	 * Holds address of buffer holding recently accessed object.
 	 */
-- 
1.8.3.2

