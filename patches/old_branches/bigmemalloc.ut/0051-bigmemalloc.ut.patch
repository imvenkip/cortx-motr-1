From b4cfadb89ce2693036016abc43ad951334fc82a8 Mon Sep 17 00:00:00 2001
From: Nachiket Sahasrabuddhe <nachiket_sahasrabuddhe@xyratex.com>
Date: Fri, 22 Nov 2013 13:30:00 +0530
Subject: [PATCH 51/61] bigmemalloc.ut

-Modifications are under progress.
-UT runs successfully.
---
 lib/ut/varr.c | 135 +++++++++++-----------------------------------------------
 lib/varr.c    |  27 +++---------
 lib/varr.h    |  11 ++---
 3 files changed, 34 insertions(+), 139 deletions(-)

diff --git a/lib/ut/varr.c b/lib/ut/varr.c
index dace2c2..594cffa 100644
--- a/lib/ut/varr.c
+++ b/lib/ut/varr.c
@@ -23,9 +23,7 @@
 #include "lib/misc.h"		/* M0SET0() */
 #include "ut/ut.h"
 #include "lib/varr.h"
-#include "lib/varr_private.h"   /* varr_cache */
 #include "lib/misc.h"		/* M0_BITS() */
-#include "lib/finject.h"	/* m0_fi_enable_random() */
 #ifndef __KERNEL__
 #include <limits.h>		/* CHAR_BIT */
 #include <stdio.h>
@@ -38,81 +36,51 @@ enum data_types {
 	DT_ATOMIC,
 	DT_POWTWO,
 	DT_NON_POWTWO,
-	DT_BUFSIZED_OBJ,
 };
 
-enum sizes {
-	DT_ATOMIC_SHIFT = 3,
-	BUFF_SIZE	= 32,
-	BUFF_SHIFT	= 5,
+enum misc_params {
+	BUFF_SIZE       = 32,
+	BUFF_SHIFT      = 5,
 	DT_POWTWO_SHIFT = 4,
-	MAX_OBJ_NR	= 26000,
 };
 
 M0_BASSERT(BUFF_SIZE == M0_BITS(BUFF_SHIFT));
 /* sizeof struct po2 is an integer power of two. */
 struct po2 {
-	uint64_t  p_x;
-	uint64_t  p_y;
+	uint64_t p_x;
+	uint64_t p_y;
 };
 
 M0_BASSERT(sizeof (struct po2) == M0_BITS(DT_POWTWO_SHIFT));
 /* sizeof struct non_po2 is not an integer power of two. */
 struct non_po2 {
-	uint16_t np_chksum;
-	uint8_t  np_arr[15];
+	uint32_t   n_flag;
+	struct po2 n_po2;
 };
 
-M0_BASSERT(M0_BITS(BUFF_SHIFT - 1) < sizeof (struct non_po2) &&
-	   sizeof (struct non_po2) < M0_BITS(BUFF_SHIFT));
 /* Shifts a given number to left/right by taking into account sizeof(number) */
 #define safe_bitshift(num, shift, operator)				     \
-({								     \
+	({								     \
 	 uint8_t        __shift = (shift);				     \
 	 typeof(num)    __num   = (num);				     \
 	 M0_ASSERT(!strcmp(#operator, "<<") || !strcmp(#operator, ">>"));    \
 	 M0_ASSERT(__shift < CHAR_BIT * sizeof __num);			     \
 	 __num operator __shift;					     \
-})
-#define varr_test_iter()						     \
-({
+	 })
 
 static size_t size_get(enum data_types dt);
-//static void test_init(void);
-static void test_size(void);
+static void test_obj_size(void);
 static void test_tree_sanity(const struct m0_varr *varr, uint32_t depth);
 static void test_depth(void);
-static void test_cache(void);
 static void test_iterate(void);
-uint16_t inline int_summation(uint8_t n);
-
 void test_varr(void)
 {
-//	test_init();
-	test_size();
+	test_obj_size();
 	test_depth();
-	test_cache();
 	test_iterate();
 }
 
-/* The number '4' below is selected randomly. This is used in function
- * test_size() when size of buffer is not power of two. */
-M0_BASSERT(M0_0VEC_ALIGN > 4 && sizeof (struct po2) < M0_0VEC_ALIGN - 4 &&
-	   sizeof (struct non_po2) < M0_0VEC_ALIGN - 4);
-#if 0
-static void test_init(void)
-{
-	struct m0_varr varr;
-	int	       rc;
-
-	M0_SET0(&varr);
-	m0_fi_enable_random("varr_buffers_alloc", "varr_alloc_fails", 50);
-	rc = m0_varr_init(&varr, MAX_OBJ_NR, size_get(DT_POWTWO), BUFF_SIZE);
-	M0_UT_ASSERT(rc == -ENOMEM);
-	m0_fi_disable("varr_buffers_alloc", "varr_alloc_fails");
-}
-#endif
-static void test_size(void)
+static void test_obj_size(void)
 {
 	struct m0_varr  varr;
 	int		rc;
@@ -126,11 +94,10 @@ static void test_size(void)
 		M0_SET0(&varr);
 		rc = m0_varr_init(&varr, 10, obj_size, M0_0VEC_ALIGN - 4);
 		M0_UT_ASSERT(rc == 0);
-		test_tree_sanity(&varr, 2);
 		M0_UT_ASSERT(!(varr.va_obj_size & (varr.va_obj_size - 1)) &&
 			     obj_size <= varr.va_obj_size	          &&
 			     2 * obj_size > varr.va_obj_size);
-		M0_UT_ASSERT(varr.va_bufsize == M0_0VEC_ALIGN);
+		test_tree_sanity(&varr, 2);
 		m0_varr_fini(&varr);
 	}
 }
@@ -156,6 +123,7 @@ static void test_tree_sanity(const struct m0_varr *varr, uint32_t depth)
 	num_accomodated = safe_bitshift((uint64_t)1, varr->va_buf_shift -
 					varr->va_obj_shift, <<);
 	num_accomodated *= buff_nr;
+	M0_UT_ASSERT(num_accomodated >= varr->va_nr);
 	M0_UT_ASSERT(num_accomodated - varr->va_nr <
 			safe_bitshift((uint64_t)1, varr->va_buf_shift -
 				      varr->va_obj_shift, <<));
@@ -172,14 +140,12 @@ static void test_depth(void)
 
 	M0_SET0(&varr);
 
-/* Maximum possible depth of tree is constrained by system memory. This can
- * be calculated using following formula.
-	max_depth = log((uint64_t)(SYSTEM_MEMORY *
+/*
+	max_depth = log(SYSTEM_MEMORY *
 			(BUFF_SIZE - M0_VA_TNODEPTR_SIZE)/
-			(BUFF_SIZE * M0_VA_TNODEPTR_SIZE *
-			 M0_VA_TNODE_NR) + 1))/
+			(BUFF_SIZE * M0_VA_TNODEPTR_SIZE*M0_VA_TNODE_NR) + 1))/
 		log (BUFF_SIZE/M0_VA_TNODEPTR_SIZE) + 1;
- */
+*/
 
 	for (buff_nr = M0_VA_TNODE_NR; depth <= 11;
 	     buff_nr *= (BUFF_SIZE/M0_VA_TNODEPTR_SIZE), ++depth) {
@@ -195,42 +161,22 @@ static void test_depth(void)
 	}
 }
 
-static void test_cache(void)
-{
-	struct m0_varr varr;
-	uint32_t       i;
-	uint32_t       obj_per_buff;
-	int	       rc;
-	void	      *arr_ele;
-
-	rc = m0_varr_init(&varr, MAX_OBJ_NR, size_get(DT_POWTWO), BUFF_SIZE);
-	M0_UT_ASSERT(rc == 0);
-	obj_per_buff = varr.va_bufsize/ varr.va_obj_size;
-	for (i = 0; i < m0_varr_size(&varr); ++i) {
-		arr_ele = m0_varr_ele_get(&varr, i);
-		M0_UT_ASSERT(arr_ele == (void *)varr.va_cache->vc_buff +
-			     (i % obj_per_buff) * varr.va_obj_size);
-	}
-	m0_varr_fini(&varr);
-}
-
 static void test_iterate(void)
 {
 	struct m0_varr varr;
 	uint64_t       nr;
 	int	       rc;
-	int	       j;
 	uint64_t       buff_nr;
 	uint32_t       depth = 2;
 	uint64_t       step;
-	void	      *arr_ele;
+	struct po2    *arr_ele;
 
 	for (buff_nr = M0_VA_TNODE_NR;
-	     depth <= 8; buff_nr *= (BUFF_SIZE/M0_VA_TNODEPTR_SIZE), ++depth) {
+	     depth <= 8; buff_nr *= (BUFF_SIZE/M0_VA_TNODEPTR_SIZE),
+	     ++depth) {
 		nr = buff_nr * (safe_bitshift((uint64_t)1,  BUFF_SHIFT -
-				DT_POWTWO_SHIFT, <<));
+				     DT_POWTWO_SHIFT, <<));
 		M0_SET0(&varr);
-		/* Case 1: size of an object is power of two. */
 		rc = m0_varr_init(&varr, nr, size_get(DT_POWTWO), BUFF_SIZE);
 		M0_UT_ASSERT(rc == 0);
 		test_tree_sanity(&varr, depth);
@@ -238,13 +184,13 @@ static void test_iterate(void)
 			obj->p_x = i;
 			obj->p_y = i;
 		} m0_varr_end_iter;
-		m0_varr_for (&varr, struct po2, i, obj) {
+		m0_varr_iter(&varr, struct po2, i, obj, 0, varr.va_nr, 13) {
 			arr_ele = m0_varr_ele_get(&varr, i);
 			M0_UT_ASSERT(arr_ele == obj);
 			M0_UT_ASSERT(obj->p_x == obj->p_y && obj->p_x == i);
-		} m0_varr_end_for;
+		} m0_varr_end_iter;
 		if (depth == 8) {
-			for (step = 2; step <= 40; ++step) {
+			for (step = 2; step <= 26000; ++step) {
 				m0_varr_iter(&varr, struct po2, i, obj, 0,
 					     varr.va_nr, step) {
 					arr_ele = m0_varr_ele_get(&varr, i);
@@ -255,36 +201,5 @@ static void test_iterate(void)
 			}
 		}
 		m0_varr_fini(&varr);
-		/* Case 2: This case encompasses two use cases:
-		 *	   a) size of an object is not power of two.
-		 *	   b) BUFF_SIZE = ceil (log (sizeof obj)). Thus a
-		 *	      buffer can accomodate only a single object.
-		 */
-		M0_SET0(&varr);
-		nr = buff_nr;
-		rc = m0_varr_init(&varr, nr, size_get(DT_NON_POWTWO),
-				  BUFF_SIZE);
-		M0_UT_ASSERT(rc == 0);
-		test_tree_sanity(&varr, depth);
-		m0_varr_iter(&varr, struct non_po2, i, obj, 0,
-			     m0_varr_size(&varr), 1) {
-			for ( j = 0; j < ARRAY_SIZE(obj->np_arr); ++j) {
-				obj->np_arr[j] = j;
-				obj->np_chksum += obj->np_arr[j];
-			}
-		} m0_varr_end_iter;
-		m0_varr_for (&varr, struct non_po2, i, obj) {
-			arr_ele = m0_varr_ele_get(&varr, i);
-			M0_UT_ASSERT(arr_ele == obj);
-			M0_UT_ASSERT(obj->np_chksum ==
-				     int_summation(ARRAY_SIZE(obj->np_arr) -
-						   1));
-		} m0_varr_end_for;
-		m0_varr_fini(&varr);
 	}
 }
-
-uint16_t inline int_summation(uint8_t n)
-{
-	return (n * (n + 1)) / 2;
-}
diff --git a/lib/varr.c b/lib/varr.c
index 1561a58..377915f 100644
--- a/lib/varr.c
+++ b/lib/varr.c
@@ -27,7 +27,6 @@
 #include "lib/string.h"		/* strcmp() */
 #include "lib/varr.h"		/* m0_varr */
 #include "lib/varr_private.h"	/* m0_varr_buf_alloc(), m0_varr_buf_free */
-#include "lib/finject.h"	/* M0_FI_ENABLED() */
 #ifndef __KERNEL__
 #include <limits.h>		/* CHAR_BIT */
 #else
@@ -235,37 +234,21 @@ M0_INTERNAL int varr_buffers_alloc(struct m0_varr *arr)
 	int		       rc;
 	void		      *holder;
 	uint32_t	       i;
-	uint64_t	       child_id;
 
-	for (i = 1; i < arr->va_depth; ++i, child_id = 0) {
+	for (i = 1; i < arr->va_depth; ++i) {
 		rc = m0_varr_cursor_init(&cursor, arr, i);
 		if (rc != 0)
 			goto end;
 		do {
-			//if (M0_FI_ENABLED("varr_alloc_fails")) {
-			//	rc = -ENOMEM;
-			//	goto end;
-			//}
 			holder = m0_varr_buf_alloc(arr->va_bufsize);
 			if (holder == NULL) {
 				rc = -ENOMEM;
 				goto end;
 			}
 			*(void **)m0_varr_cursor_get(&cursor) = holder;
-			++child_id;
 		} while (m0_varr_cursor_next(&cursor));
 	}
 end:
-	/* In case of non-availability of memory, the current depth of a tree
-	 * is stored in an array. Following such a case, a call to
-	 * m0_varr_fini() is expected which would dealloc the partial tree
-	 * allocated so far, starting from the depth stored in the array. */
-	if (rc == -ENOMEM) {
-		if (child_id == 0)
-			arr->va_depth = i;
-		else
-			arr->va_depth = i + 1;
-	}
 	return rc;
 }
 
@@ -477,11 +460,11 @@ M0_INTERNAL void varr_buffers_dealloc(struct m0_varr *arr)
 		M0_ASSERT(rc == 0);
 		do {
 			holder = *(void **)m0_varr_cursor_get(&cursor);
-			/* This condition reflects the case of
-			 * varr_buffers_alloc() getting terminated
-			 * intermittently. */
-			if (holder != NULL)
+			/* This condition will fail when varr_buffers_alloc()
+			 * has got terminated intermittently. */
+			if ((void *)holder != NULL) {
 				m0_varr_buf_free(holder, arr->va_bufsize);
+			}
 		} while (m0_varr_cursor_next(&cursor));
 	}
 }
diff --git a/lib/varr.h b/lib/varr.h
index 7268fc9..cc1c7fb 100644
--- a/lib/varr.h
+++ b/lib/varr.h
@@ -237,8 +237,7 @@ M0_INTERNAL int m0_varr_cursor_move(struct m0_varr_cursor *cursor,
 	struct m0_varr_cursor __cursor;				       \
 								       \
 	M0_PRE(idx < __arr->va_nr && __end <= __arr->va_nr);	       \
-	M0_PRE(sizeof *obj > M0_BITS(__arr->va_obj_shift - 1) &&       \
-	       sizeof *obj <= M0_BITS(__arr->va_obj_shift));	       \
+	M0_PRE(sizeof *obj == M0_BITS(__arr->va_obj_shift));	       \
 								       \
         __rc = m0_varr_cursor_init(&__cursor, __arr, __arr->va_depth); \
 	M0_ASSERT(__rc == 0);					       \
@@ -250,12 +249,10 @@ M0_INTERNAL int m0_varr_cursor_move(struct m0_varr_cursor *cursor,
 #define m0_varr_end_iter } } )
 
 /** Iterates over whole virtual array. */
-#define m0_varr_for(arr, type, idx, obj)			       \
-({								       \
-	struct m0_varr *__arr_ = (arr);				       \
-	m0_varr_iter(__arr_, type, idx, obj, 0, m0_varr_size(__arr_), 1)
+#define m0_varr_for(arr, type, idx, obj)		    \
+	m0_varr_iter(arr, type, idx, obj, 0, arr->va_nr, 1)
 
-#define m0_varr_end_for m0_varr_end_iter; })
+#define m0_varr_end_for m0_varr_end_iter
 
 /** @} end of varr group */
 #endif /* __MERO_LIB_VIRTUAL_ARRAY_H__ */
-- 
1.8.3.2

