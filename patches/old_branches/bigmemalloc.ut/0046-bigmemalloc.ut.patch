From 3b6ed6ce43ede2fb5642d0192d559744f1f89419 Mon Sep 17 00:00:00 2001
From: Nachiket Sahasrabuddhe <nachiket_sahasrabuddhe@xyratex.com>
Date: Tue, 29 Oct 2013 14:41:16 +0530
Subject: [PATCH 46/61] bigmemalloc.ut -UT for checking tree internals and
 iterations has been added. -UT runs successfully. -UT needs to be made more
 generic.

---
 lib/Makefile.sub    |   1 +
 lib/ut/Makefile.sub |   1 +
 lib/ut/main.c       |   2 +
 lib/ut/varr.c       | 159 +++++++++++++++++++++++++++++++++++++++++++++++++++-
 4 files changed, 162 insertions(+), 1 deletion(-)

diff --git a/lib/Makefile.sub b/lib/Makefile.sub
index ca808f1..90ce02e 100644
--- a/lib/Makefile.sub
+++ b/lib/Makefile.sub
@@ -138,6 +138,7 @@ EXTRA_DIST += lib/linux_kernel/atomic64.h \
               lib/linux_kernel/timer.c \
               lib/linux_kernel/timer.h \
               lib/linux_kernel/types.h \
+              lib/linux_kernel/varr.c \
               lib/linux_kernel/vec.h \
               lib/linux_kernel/ut/main.c
 
diff --git a/lib/ut/Makefile.sub b/lib/ut/Makefile.sub
index 383ca69..b3406f2 100644
--- a/lib/ut/Makefile.sub
+++ b/lib/ut/Makefile.sub
@@ -22,5 +22,6 @@ ut_libmero_ut_la_SOURCES += lib/ut/main.c \
                                lib/ut/tlist.c \
                                lib/ut/trace.c \
                                lib/ut/uuid.c \
+			       lib/ut/varr.c \
                                lib/ut/vec.c \
                                lib/ut/zerovec.c
diff --git a/lib/ut/main.c b/lib/ut/main.c
index 963c7e1..0652f85 100644
--- a/lib/ut/main.c
+++ b/lib/ut/main.c
@@ -46,6 +46,7 @@ extern void test_timer(void);
 extern void test_tlist(void);
 extern void test_trace(void);
 extern void test_vec(void);
+extern void test_varr(void);
 extern void test_zerovec(void);
 
 const struct m0_test_suite libm0_ut = {
@@ -79,6 +80,7 @@ const struct m0_test_suite libm0_ut = {
 		{ "tlist",            test_tlist         },
 		{ "trace",            test_trace         },
 		{ "uuid",             m0_test_lib_uuid   },
+		{ "varr",             test_varr		 },
 		{ "vec",              test_vec           },
 		{ "zerovec",          test_zerovec       },
 		{ NULL,               NULL               }
diff --git a/lib/ut/varr.c b/lib/ut/varr.c
index 77dfe01..d55b03d 100644
--- a/lib/ut/varr.c
+++ b/lib/ut/varr.c
@@ -18,11 +18,167 @@
  * Original creation date: 01/07/2013
  */
 
-#include "lib/varr.h"
 #include "lib/vec.h"
 #include "lib/memory.h"
+#include "lib/misc.h"		/* M0SET0() */
 #include "ut/ut.h"
+#include "lib/varr.h"
+#ifndef __KERNEL__
+#include <limits.h>		/* CHAR_BIT */
+#include <stdio.h>
+#else
+#include <linux/limits.h>
+#endif
+
+enum data_types {
+	DT_ATOMIC,
+	DT_POWTWO,
+	DT_NON_POWTWO,
+};
+
+/* sizeof struct po2 is an integer power of two. */
+struct po2 {
+	uint64_t p_x;
+	uint64_t p_y;
+};
+
+/* sizeof struct non_po2 is not an integer power of two. */
+struct non_po2 {
+	uint32_t   n_flag;
+	struct po2 n_po2;
+};
+
+/* Shifts a given number to left/right by taking into account sizeof(number) */
+#define safe_bitshift(num, shift, operator)				     \
+	({								     \
+	 uint8_t        __shift = (shift);				     \
+	 typeof(num)    __num   = (num);				     \
+	 M0_ASSERT(!strcmp(#operator, "<<") || !strcmp(#operator, ">>"));    \
+	 M0_ASSERT(__shift < CHAR_BIT * sizeof __num);			     \
+	 __num operator __shift;					     \
+	 })
+
+static void test_init(void);
+static size_t size_get(enum data_types dt);
+static void test_size(void);
+static void test_count(const struct m0_varr *varr);
+static void test_depth(void);
+static void test_iterate(void);
+
+void test_varr(void)
+{
+	test_init();
+	test_iterate();
+}
+
+static void test_init(void)
+{
+	test_size();
+	test_depth();
+}
+
+static void test_size(void)
+{
+	struct m0_varr  varr;
+	int		rc;
+	enum data_types dt;
+	size_t		obj_size;
+
+	M0_SET0(&varr);
+
+	for (dt = DT_ATOMIC; dt <= DT_NON_POWTWO; ++dt) {
+		obj_size = size_get(dt);
+		rc = m0_varr_init(&varr, 10, obj_size, M0_0VEC_ALIGN);
+		M0_UT_ASSERT(rc == 0);
+		M0_UT_ASSERT(varr.va_depth == 2);
+		M0_UT_ASSERT(!(varr.va_obj_size & (varr.va_obj_size - 1)) &&
+			     obj_size <= varr.va_obj_size	          &&
+			     2 * obj_size > varr.va_obj_size);
+		test_count(&varr);
+		m0_varr_fini(&varr);
+	}
+}
+
+static size_t size_get(enum data_types dt)
+{
+	return dt == DT_ATOMIC ? sizeof (uint64_t) : dt == DT_POWTWO ?
+		sizeof (struct po2) : sizeof (struct non_po2);
+}
 
+static void test_count(const struct m0_varr *varr)
+{
+	uint32_t num_trees;
+	uint64_t buff_nr;
+	uint64_t num_accomodated;
+
+	for (num_trees = 0; num_trees < M0_VA_TNODE_NR &&
+		varr->va_tree[num_trees] != NULL; ++num_trees);
+
+	buff_nr = safe_bitshift((uint64_t)1, varr->va_bufptr_nr_shift *
+				(varr->va_depth - 2), <<);
+	buff_nr *= num_trees;
+	num_accomodated = safe_bitshift((uint64_t)1, varr->va_buf_shift -
+					varr->va_obj_shift, <<);
+	num_accomodated *= buff_nr;
+	M0_UT_ASSERT(num_accomodated >= varr->va_nr);
+	M0_UT_ASSERT(num_accomodated - varr->va_nr <
+			safe_bitshift((uint64_t)1, varr->va_buf_shift -
+				      varr->va_obj_shift, <<));
+}
+
+static void test_depth(void)
+{
+	struct       m0_varr varr;
+	uint64_t     nr;
+	int          rc;
+	uint32_t     depth = 2;
+	uint64_t     bn;
+
+	M0_SET0(&varr);
+
+	for (bn = M0_VA_TNODE_NR; depth <= 10;
+	     bn *= (32/M0_VA_TNODEPTR_SIZE), ++depth) {
+		nr = bn * (safe_bitshift((uint64_t)1,  5 - 4, <<));
+		rc = m0_varr_init(&varr, nr,
+				  size_get(DT_POWTWO), 32);
+		M0_UT_ASSERT(rc == 0);
+		M0_UT_ASSERT(depth == varr.va_depth);
+		test_count(&varr);
+		m0_varr_fini(&varr);
+	}
+}
+
+static void test_iterate(void)
+{
+	struct m0_varr varr;
+	uint64_t       nr;
+	int	       rc;
+	uint64_t       bn;
+	uint32_t       depth = 2;
+	struct po2    *arr_ele;
+
+	for (bn = M0_VA_TNODE_NR; depth <= 10;
+	     bn *= (32/M0_VA_TNODEPTR_SIZE), ++depth) {
+		nr = bn * (safe_bitshift((uint64_t)1,  5 - 4, <<)) - 1;
+		rc = m0_varr_init(&varr, nr,
+				  size_get(DT_POWTWO), 32);
+		M0_UT_ASSERT(rc == 0);
+		M0_UT_ASSERT(depth == varr.va_depth);
+		test_count(&varr);
+		m0_varr_iter(&varr, struct po2, i, obj, 0, varr.va_nr, 1) {
+			obj->p_x = i;
+			obj->p_y = i;
+		} m0_varr_end_iter;
+		m0_varr_iter(&varr, struct po2, i, obj, 0, varr.va_nr, 1) {
+			arr_ele = m0_varr_ele_get(&varr, i);
+			M0_UT_ASSERT(arr_ele == obj);
+			M0_UT_ASSERT(obj->p_x == obj->p_y && obj->p_x == i);
+		} m0_varr_end_iter;
+
+		m0_varr_fini(&varr);
+	}
+}
+#if 0
 static unsigned long ELEMENT_NR = 1234567;
 static unsigned long struct_nr  = 123456;
 static uint64_t FOO_MAGIC = 0x1234567890abcde;
@@ -127,3 +283,4 @@ void test_varr(void)
 	m0_free(address_tracker);
 	m0_varr_fini(&arr);
 }
+#endif
-- 
1.8.3.2

