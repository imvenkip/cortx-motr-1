From 72fa89d047c57acc4c2bf86c97f84c6b03fff8f8 Mon Sep 17 00:00:00 2001
From: Nachiket Sahasrabuddhe <nachiket_sahasrabuddhe@xyratex.com>
Date: Fri, 29 Nov 2013 19:17:30 +0530
Subject: [PATCH 60/61] bigmemalloc.ut -The macro test_iterate() now takes 'nr'
 as input instead of 'depth'. -UT runs successfully without leaks.

---
 lib/ut/varr.c | 122 ++++++++++++++++++++++------------------------------------
 lib/varr.h    |   8 ++--
 2 files changed, 51 insertions(+), 79 deletions(-)

diff --git a/lib/ut/varr.c b/lib/ut/varr.c
index ea29963..4e5168e 100644
--- a/lib/ut/varr.c
+++ b/lib/ut/varr.c
@@ -83,53 +83,34 @@ struct non_po2 {
 M0_BASSERT(sizeof (struct non_po2) < BUFF_SIZE &&
 	   sizeof (struct non_po2) > M0_BITS(BUFF_SHIFT - 1));
 
-/* Shifts a given number to left/right by taking into account sizeof(number) */
-#define safe_bitshift(num, shift, operator)				     \
-	({								     \
-	 uint8_t        __shift = (shift);				     \
-	 typeof(num)    __num   = (num);				     \
-	 M0_ASSERT(!strcmp(#operator, "<<") || !strcmp(#operator, ">>"));    \
-	 M0_ASSERT(__shift < CHAR_BIT * sizeof __num);			     \
-	 __num operator __shift;					     \
-	 })
 /* Iterates over arrays with various sizes of objects of type 'dt'. Max
  * possible number of elements from array get decided by depth. */
-#define test_iterate(varr, ele, dt, depth)				      \
-({									      \
-	 struct m0_varr *__varr_ = (varr);				      \
-	 typeof(ele)     __ele;						      \
-	 uint32_t	 __depth = (depth);				      \
-	 uint64_t	 __buff_nr;					      \
-	 uint64_t	 __nr;						      \
-	 uint32_t	 __d;						      \
-	 int		 __rc;						      \
-	 uint64_t	 __step;					      \
-									      \
+#define test_iterate(varr, ele, dt, nr)				      \
+({								      \
+	 struct m0_varr *__varr_ = (varr);			      \
+	 typeof(ele)     __ele;					      \
+	 uint64_t	 __nr    = (nr);			      \
+	 int		 __rc;					      \
+	 uint64_t	 __step;				      \
+								      \
 	 M0_ASSERT(size_get(dt) == sizeof __ele);		      \
-	 for (__buff_nr = M0_VA_TNODE_NR, __d = 2;			      \
-	      __d <= __depth; __buff_nr *= (BUFF_SIZE/M0_VA_TNODEPTR_SIZE),   \
-	      ++__d) {							      \
-		__nr = array_len_compute(__buff_nr, dt);		      \
-		M0_SET0(__varr_);					      \
-		__rc = m0_varr_init(__varr_, __nr, size_get(dt), BUFF_SIZE);  \
-		M0_ASSERT(__rc == 0);			      \
-		test_tree_sanity(__varr_, __d);			              \
-		m0_varr_iter(__varr_, typeof(__ele), i, obj, 0,	              \
-		 m0_varr_size(__varr_), 1) {			              \
-			obj_init((void*)obj, i, dt);			      \
-		} m0_varr_end_iter;					      \
-		m0_varr_for (__varr_, typeof(__ele), i, obj) {		      \
-			obj_sanity_check(obj, i, dt);			      \
-		} m0_varr_end_for;					      \
-		for (__step = 2; __step <= MAX_OBJ_NR && __d == __depth;      \
-		     ++__step) {					      \
-			m0_varr_iter(__varr_, typeof(__ele), i, obj, 0,	      \
-				     m0_varr_size(__varr_), __step) {	      \
-				obj_sanity_check((void *)obj, i, dt);	      \
-			 } m0_varr_end_iter;				      \
-		 }							      \
-		 m0_varr_fini(__varr_);					      \
-	 }								      \
+	 M0_SET0(__varr_);					      \
+	 __rc = m0_varr_init(__varr_, __nr, size_get(dt), BUFF_SIZE); \
+	 M0_ASSERT(__rc == 0);					      \
+	 m0_varr_iter(__varr_, typeof(__ele), i, obj, 0,	      \
+		      m0_varr_size(__varr_), 1) {		      \
+		obj_init((void*)obj, i, dt);			      \
+	 } m0_varr_enditer;					      \
+	 m0_varr_for (__varr_, typeof(__ele), i, obj) {		      \
+		obj_sanity_check(obj, i, dt);			      \
+	 } m0_varr_endfor;					      \
+	 for (__step = 2; __step <= nr;	++__step) {		      \
+		 m0_varr_iter(__varr_, typeof(__ele), i, obj, 0,      \
+			      m0_varr_size(__varr_), __step) {        \
+			 obj_sanity_check((void *)obj, i, dt);	      \
+		 } m0_varr_enditer;				      \
+	 }							      \
+	 m0_varr_fini(__varr_);				      \
 })
 static void obj_init(void *obj, uint64_t data, enum data_types dt);
 static void obj_sanity_check(void *obj, uint64_t data, enum data_types dt);
@@ -189,6 +170,7 @@ static void test_size(void)
 	for (dt = DT_ATOMIC_8; dt <= DT_NON_POWTWO; ++dt) {
 		obj_size = size_get(dt);
 		M0_SET0(&varr);
+		/* Test non-power of two buffer-size */
 		rc = m0_varr_init(&varr, M0_VA_TNODE_NR, obj_size,
 				  M0_0VEC_ALIGN - 1);
 		M0_UT_ASSERT(rc == 0);
@@ -226,18 +208,15 @@ static void test_tree_sanity(const struct m0_varr *varr, uint32_t depth)
 	for (num_trees = 0; num_trees < M0_VA_TNODE_NR &&
 		varr->va_tree[num_trees] != NULL; ++num_trees);
 
-	buff_nr = safe_bitshift((uint64_t)1, varr->va_bufptr_nr_shift *
-				(varr->va_depth - 2), <<);
+	buff_nr = M0_BITS(varr->va_bufptr_nr_shift * (varr->va_depth - 2));
 	buff_nr *= num_trees;
-	M0_ASSERT(varr->va_buff_nr <= buff_nr);
-	num_accomodated = safe_bitshift((uint64_t)1, varr->va_buf_shift -
-					varr->va_obj_shift, <<);
+	M0_UT_ASSERT(varr->va_buff_nr <= buff_nr);
+	num_accomodated = M0_BITS(varr->va_buf_shift - varr->va_obj_shift);
 	num_accomodated *= varr->va_buff_nr;
-	M0_ASSERT(num_accomodated >= varr->va_nr);
-	M0_ASSERT(num_accomodated - varr->va_nr <
-			safe_bitshift((uint64_t)1, varr->va_buf_shift -
-				      varr->va_obj_shift, <<));
-	M0_ASSERT(varr->va_depth == depth);
+	M0_UT_ASSERT(num_accomodated >= varr->va_nr);
+	M0_UT_ASSERT(num_accomodated - varr->va_nr <
+			M0_BITS(varr->va_buf_shift - varr->va_obj_shift));
+	M0_UT_ASSERT(varr->va_depth == depth);
 }
 
 static void test_depth(uint32_t max_depth)
@@ -254,9 +233,7 @@ static void test_depth(uint32_t max_depth)
 
 	for (buff_nr = M0_VA_TNODE_NR; depth <= max_depth;
 	     buff_nr *= (BUFF_SIZE/M0_VA_TNODEPTR_SIZE), ++depth) {
-		nr = buff_nr * (safe_bitshift((uint64_t)1,
-					      BUFF_SHIFT - DT_POWTWO_SHIFT,
-					      <<));
+		nr = buff_nr * (M0_BITS( BUFF_SHIFT - DT_POWTWO_SHIFT));
 		M0_SET0(&varr);
 		rc = m0_varr_init(&varr, nr,
 				  size_get(DT_POWTWO), BUFF_SIZE);
@@ -287,40 +264,35 @@ static void test_cache(void)
 	m0_varr_fini(&varr);
 }
 
-static void test_ut_iterate(void)
-{
-	struct m0_varr varr;
-	struct po2     obj_po2;
-	struct non_po2 obj_non_po2;
-
-	test_iterate(&varr, obj_po2, DT_POWTWO, MAX_TEST_DEPTH);
-	test_iterate(&varr, obj_non_po2, DT_NON_POWTWO, MAX_TEST_DEPTH);
-}
-
 static uint16_t int_summation(uint8_t n)
 {
 	return n * (n + 1) / 2;
 }
 
-void  test_ub_iterate(void)
+void  test_ut_iterate(void)
 {
 	struct po2     obj_po2;
 	struct non_po2 obj_non_po2;
 	uint8_t        atomic8_obj;
 	uint64_t       atomic64_obj;
+	m0_time_t      seed;
+	uint64_t       nr;
 	struct m0_varr varr;
 
-	test_iterate(&varr, obj_po2, DT_POWTWO, MAX_DEPTH);
-	test_iterate(&varr, obj_non_po2, DT_NON_POWTWO, MAX_DEPTH);
-	test_iterate(&varr, atomic8_obj, DT_ATOMIC_8, MAX_TEST_DEPTH);
-	test_iterate(&varr, atomic64_obj, DT_ATOMIC_64, MAX_TEST_DEPTH);
+	seed = m0_time_now();
+	nr = m0_rnd(MAX_OBJ_NR, &seed);
+
+	test_iterate(&varr, obj_po2, DT_POWTWO, nr);
+	test_iterate(&varr, obj_non_po2, DT_NON_POWTWO, nr);
+	test_iterate(&varr, atomic8_obj, DT_ATOMIC_8, nr);
+	test_iterate(&varr, atomic64_obj, DT_ATOMIC_64, nr);
 }
 
 uint64_t array_len_compute(uint64_t buff_nr, enum data_types dt)
 {
 	uint32_t shift = shift_get(dt);
 
-	return buff_nr * safe_bitshift((uint64_t)1, BUFF_SHIFT - shift, <<);
+	return buff_nr * M0_BITS(BUFF_SHIFT - shift);
 }
 
 uint32_t shift_get(enum data_types dt)
@@ -393,12 +365,12 @@ static void obj_sanity_check(void *obj, uint64_t data, enum data_types dt)
 	}
 }
 enum {
-	UB_ITER = 1,
+	UB_ITER = 1000,
 };
 
 static void varr_ub(int i)
 {
-	test_ub_iterate();
+	test_ut_iterate();
 }
 
 struct m0_ub_set m0_varr_ub = {
diff --git a/lib/varr.h b/lib/varr.h
index b2bcfdb..6fa6881 100644
--- a/lib/varr.h
+++ b/lib/varr.h
@@ -69,12 +69,12 @@
  *
  * m0_varr_iter(&varr, unsigned long, id, obj, 0, m0_varr_size(&varr), 1) {
  *	*obj = id;
- * }
+ * } m0_varr_enditer;
  *
  * m0_varr_iter(&varr, unsigned long, id, obj, 0, m0_varr_size(&varr), 1) {
  *         ptr = m0_varr_ele_get(&varr, id);
  *         M0_ASSERT(*ptr == *obj);
- * }
+ * } m0_varr_enditer;
  *
  * m0_varr_fini(&varr);
  *
@@ -252,7 +252,7 @@ M0_INTERNAL int m0_varr_cursor_move(struct m0_varr_cursor *cursor,
 		idx += __inc, m0_varr_cursor_move(&__cursor, __inc),   \
 		obj = m0_varr_cursor_get(&__cursor)) {		       \
 
-#define m0_varr_end_iter } } )
+#define m0_varr_enditer } } )
 
 /** Iterates over whole virtual array. */
 #define m0_varr_for(arr, type, idx, obj)				    \
@@ -260,7 +260,7 @@ M0_INTERNAL int m0_varr_cursor_move(struct m0_varr_cursor *cursor,
 	struct m0_varr *__arr__ = (arr);				    \
 	m0_varr_iter(__arr__, type, idx, obj, 0, m0_varr_size(__arr__), 1)
 
-#define m0_varr_end_for m0_varr_end_iter; })
+#define m0_varr_endfor m0_varr_enditer; })
 
 /** @} end of varr group */
 #endif /* __MERO_LIB_VIRTUAL_ARRAY_H__ */
-- 
1.8.3.2

