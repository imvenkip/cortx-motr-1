From add5474db6a0f46656c85a820a97761f31eaa34c Mon Sep 17 00:00:00 2001
From: Rohan Puri <rohan_puri@xyratex.com>
Date: Wed, 26 Jun 2013 16:10:05 +0530
Subject: [PATCH 10/10] Changes summary : -

1. ADDB monitoring infrastructure.
2. Stats service.
3. Stats utility.
4. Two addb monitors : -
        - total io size (read, write) per client.
        - fops executed per sec for each m0d.

Reviews included : -

http://reviewboard.clusterstor.com/r/1467/
http://reviewboard.clusterstor.com/r/1496/
http://reviewboard.clusterstor.com/r/1540/
http://reviewboard.clusterstor.com/r/1544/
http://reviewboard.clusterstor.com/r/1571/
---
 Kbuild.in                                   |   1 +
 addb/Makefile.sub                           |  26 +-
 addb/addb.c                                 |  12 +-
 addb/addb.h                                 |  12 +-
 addb/addb_evmgr.c                           |   1 +
 addb/addb_mc.c                              |   2 +
 addb/addb_monitor.c                         | 581 ++++++++++++++++++++++++++++
 addb/addb_monitor.h                         | 419 ++++++++++++++++++++
 addb/addb_monitor_wire.h                    |  60 +++
 addb/addb_pfom.c                            | 416 ++++++++++++++++++++
 addb/addb_rec.c                             |  36 +-
 addb/addb_rpcsink.c                         |   6 +
 addb/addb_svc.c                             | 231 +++++++++++
 addb/addb_svc.h                             | 112 ++++++
 addb/stats_srv.c                            | 186 ---------
 addb/stats_srv.h                            | 102 -----
 addb/user_space/addb_pfom.c                 | 403 -------------------
 addb/user_space/addb_stobsink.c             |   6 +
 addb/user_space/addb_svc.c                  | 231 -----------
 addb/user_space/addb_svc.h                  | 107 -----
 addb/ut/addb_ut.c                           |   5 +-
 addb/ut/addb_ut_fom.c                       |   2 +-
 addb/ut/addb_ut_mon_infra.c                 | 457 ++++++++++++++++++++++
 addb/ut/addb_ut_rpcsink.c                   |  10 +-
 addb/ut/addb_ut_stobsink.c                  |  11 +-
 addb/ut/addb_ut_svc.c                       |   2 +-
 conf/objs/service.c                         |   3 +-
 conf/schema.h                               |   1 +
 doc/addb-ids                                |   1 +
 doc/dld-index.c                             |   1 +
 extra-libs/galois                           |   2 +-
 fop/fom.c                                   | 184 ++++++++-
 fop/fom.h                                   |  10 +
 fop/fop.c                                   |   3 +
 fop/fop_addb.h                              |  21 +-
 m0t1fs/linux_kernel/file.c                  |   2 +-
 m0t1fs/linux_kernel/file_internal.h         |   6 -
 m0t1fs/linux_kernel/m0t1fs.c                | 135 ++++++-
 m0t1fs/linux_kernel/m0t1fs.h                |  35 +-
 m0t1fs/linux_kernel/st/m0t1fs_common_inc.sh |   1 +
 m0t1fs/linux_kernel/st/m0t1fs_server_inc.sh |   2 +-
 m0t1fs/linux_kernel/super.c                 |  36 +-
 m0t1fs/m0t1fs_addb.h                        |  37 +-
 mero/conf.c                                 |   3 +-
 mero/init.c                                 |   4 +-
 mero/magic.h                                |   9 +
 mero/setup.c                                |  51 ++-
 mero/setup.h                                |   3 +
 reqh/reqh.c                                 |  38 +-
 reqh/reqh.h                                 |  54 +--
 rpc/rpclib.c                                |  10 +-
 scripts/m0mount.sh                          |  11 +-
 stats/Kbuild.sub                            |   2 +
 stats/stats_addb.h                          |  40 +-
 stats/stats_fops.c                          |   4 +
 stats/stats_fops.h                          |   3 +-
 stats/stats_srv.c                           | 101 +----
 stats/stats_srv.h                           |   2 +
 stats/ut/stats_ut_svc.c                     |  14 +-
 stats/util/stats_util.c                     | 113 +++---
 60 files changed, 3040 insertions(+), 1339 deletions(-)
 create mode 100644 addb/addb_monitor.c
 create mode 100644 addb/addb_monitor.h
 create mode 100644 addb/addb_monitor_wire.h
 create mode 100644 addb/addb_pfom.c
 create mode 100644 addb/addb_svc.c
 create mode 100644 addb/addb_svc.h
 delete mode 100644 addb/stats_srv.c
 delete mode 100644 addb/stats_srv.h
 delete mode 100644 addb/user_space/addb_pfom.c
 delete mode 100644 addb/user_space/addb_svc.c
 delete mode 100644 addb/user_space/addb_svc.h
 create mode 100644 addb/ut/addb_ut_mon_infra.c
 create mode 100644 stats/Kbuild.sub

diff --git a/Kbuild.in b/Kbuild.in
index 29eeb07..2fdc562 100644
--- a/Kbuild.in
+++ b/Kbuild.in
@@ -80,6 +80,7 @@ include $(src)/rm/Kbuild.sub
 include $(src)/rpc/Kbuild.sub
 include $(src)/sm/Kbuild.sub
 include $(src)/sns/Kbuild.sub
+include $(src)/stats/Kbuild.sub
 include $(src)/stob/Kbuild.sub
 include $(src)/xcode/Kbuild.sub
 include $(src)/be/Kbuild.sub
diff --git a/addb/Makefile.sub b/addb/Makefile.sub
index 51d9a6d..c059894 100644
--- a/addb/Makefile.sub
+++ b/addb/Makefile.sub
@@ -2,17 +2,21 @@ nobase_mero_include_HEADERS += addb/addb.h \
                                addb/addb_fops.h \
                                addb/addb_fops_xc.h \
                                addb/addb_macros.h \
+			       addb/addb_monitor.h \
+			       addb/addb_monitor_wire.h \
+			       addb/addb_monitor_wire_xc.h \
                                addb/addb_pvt.h \
                                addb/addb_wire.h \
                                addb/addb_wire_xc.h \
-                               addb/user_space/addb_svc.h \
+                               addb/addb_svc.h \
                                addb/user_space/uctx.h
 
 mero_libmero_la_SOURCES  += addb/addb.c \
                             addb/addb_wire_xc.c
 
 XC_FILES   += addb/addb_wire_xc.h \
-	      addb/addb_fops_xc.h
+	      addb/addb_monitor_wire_xc.h \
+              addb/addb_fops_xc.h
 
 EXTRA_DIST += addb/addb_counter.c \
               addb/addb_ct.c \
@@ -21,6 +25,8 @@ EXTRA_DIST += addb/addb_counter.c \
               addb/addb_fops.c \
               addb/addb_fops_xc.c \
               addb/addb_mc.c \
+	      addb/addb_monitor.c \
+	      addb/addb_monitor_wire_xc.c \
               addb/addbmc.dia \
               addb/addbmc.png \
               addb/addb_rec.c \
@@ -29,11 +35,21 @@ EXTRA_DIST += addb/addb_counter.c \
 	      addb/addb_ts.c \
               addb/linux_kernel/kctx.c \
               addb/user_space/addb_fom.c \
-              addb/user_space/addb_pfom.c \
+              addb/addb_pfom.c \
               addb/user_space/addb_retrieval.c \
               addb/user_space/addb_stobsink.c \
-              addb/user_space/addb_svc.c \
+              addb/addb_svc.c \
               addb/user_space/uctx.c
 
-addb/addb.c: addb/addb_fops_xc.h \
+CLEANFILES += addb/addb_fops_xc.c \
+	      addb/addb_fops_xc.h \
+	      addb/addb_fops.gccxml \
+	      addb/addb_monitor_wire_xc.c \
+	      addb/addb_monitor_wire_xc.h \
+              addb/addb_wire_xc.c \
+              addb/addb_wire_xc.h \
+              addb/addb_wire.gccxml
+
+addb/addb.c: addb/addb_monitor_wire_xc.h \
+	     addb/addb_fops_xc.h \
              addb/addb_wire_xc.h
diff --git a/addb/addb.c b/addb/addb.c
index e403d4b..d19e483 100644
--- a/addb/addb.c
+++ b/addb/addb.c
@@ -699,15 +699,14 @@ Plan</a> for details.
 #include "lib/misc.h"
 #include "lib/rwlock.h"
 #include "lib/time.h"
-#ifndef __KERNEL__
 #include "fop/fom_generic.h"
-#endif
 #define M0_TRACE_SUBSYSTEM M0_TRACE_SUBSYS_ADDB
 #include "lib/trace.h"  /* M0_LOG() */
 
 #include "addb/addb_wire_xc.h"
 #include "addb/addb_fops_xc.h"
-
+#include "addb/addb_monitor.h"
+#include "addb/addb_monitor_wire_xc.h"
 struct m0_uint128 m0_node_uuid; /* globally visible uuid */
 
 /**
@@ -768,17 +767,18 @@ static int addb_node_uuid_init(void)
 #include "addb/addb_counter.c"
 #include "addb/addb_ts.c"
 #include "addb/addb_rpcsink.c"
+#include "addb/addb_svc.c"
+#include "addb/addb_pfom.c"
 #ifdef __KERNEL__
 #include "addb/linux_kernel/kctx.c"
 #else
-#include "addb/user_space/addb_svc.c"
 #include "addb/user_space/addb_fom.c"
-#include "addb/user_space/addb_pfom.c"
 #include "addb/user_space/uctx.c"
 #include "addb/user_space/addb_stobsink.c"
 #include "addb/user_space/addb_retrieval.c"
 #endif
 #include "addb/addb_fops.c"
+#include "addb/addb_monitor.c"
 
 #ifndef __KERNEL__
 static void addb_register_kernel_ctx_and_rec_types(void)
@@ -795,6 +795,8 @@ static void addb_register_kernel_ctx_and_rec_types(void)
 	m0_addb_rec_type_register(&m0_addb_rt_m0t1fs_iow_sizes);
 	m0_addb_rec_type_register(&m0_addb_rt_m0t1fs_ior_times);
 	m0_addb_rec_type_register(&m0_addb_rt_m0t1fs_iow_times);
+	M0_ADDB_MONITOR_STATS_TYPE_REGISTER(&m0_addb_rt_m0t1fs_mon_io_size,
+					    "io_size");
 }
 #endif
 
diff --git a/addb/addb.h b/addb/addb.h
index ea3a0cb..0e66318 100644
--- a/addb/addb.h
+++ b/addb/addb.h
@@ -74,6 +74,8 @@ struct m0_sm_conf;
    @{
 */
 
+#define M0_ADDB_SVC_NAME  "addb"
+
 /**
    ADDB module initializer.
  */
@@ -820,6 +822,7 @@ struct m0_addb_mc {
 	uint64_t                   am_magic;
 	struct m0_addb_mc_evmgr   *am_evmgr;  /* required */
 	struct m0_addb_mc_recsink *am_sink;   /* optional */
+	struct m0_reqh            *am_reqh;   /* required */
 };
 
 /**
@@ -954,6 +957,7 @@ enum {
  */
 M0_INTERNAL int m0_addb_mc_configure_rpc_sink(struct m0_addb_mc     *mc,
 					      struct m0_rpc_machine *rm,
+					      struct m0_reqh        *reqh,
 					      uint32_t               npgs_init,
 					      uint32_t               npgs_max,
 					      m0_bcount_t            pg_size);
@@ -996,6 +1000,7 @@ M0_INTERNAL void m0_addb_mc_rpc_sink_source_del(struct m0_rpc_item_source *src);
    @pre segment_size > 0 && max_stob_size >= segment_size && rel_timeout > 0
  */
 M0_INTERNAL int m0_addb_mc_configure_stob_sink(struct m0_addb_mc *mc,
+					       struct m0_reqh    *reqh,
 					       struct m0_stob    *stob,
 					       m0_bcount_t        segment_size,
 					       m0_bcount_t        max_stob_size,
@@ -1587,18 +1592,15 @@ M0_INTERNAL uint32_t m0_addb_rec_rid_to_id(uint64_t rid);
    @{
  */
 
-#ifndef __KERNEL__
 /**
    ADDB service module initializer
  */
-M0_INTERNAL int m0_addb_svc_mod_init();
+M0_INTERNAL int m0_addb_svc_mod_init(void);
 
 /**
    ADDB service module finalizer
  */
-M0_INTERNAL void m0_addb_svc_mod_fini();
-
-#endif /* __KERNEL__ */
+M0_INTERNAL void m0_addb_svc_mod_fini(void);
 
 /** @} end of addb_svc group */
 
diff --git a/addb/addb_evmgr.c b/addb/addb_evmgr.c
index 04d3ae5..4a8cd98 100644
--- a/addb/addb_evmgr.c
+++ b/addb/addb_evmgr.c
@@ -488,6 +488,7 @@ M0_INTERNAL void m0__addb_post(struct m0_addb_mc *mc,
 	switch (pd->apd_rt->art_base_type) {
 	case M0_ADDB_BRT_EX:
 	case M0_ADDB_BRT_DP:
+	case M0_ADDB_BRT_STATS:
 		fields_nr = pd->apd_rt->art_rf_nr;
 		fields = pd->u.apd_args;
 		break;
diff --git a/addb/addb_mc.c b/addb/addb_mc.c
index cdec415..4389079 100644
--- a/addb/addb_mc.c
+++ b/addb/addb_mc.c
@@ -53,6 +53,7 @@ M0_INTERNAL void m0_addb_mc_init(struct m0_addb_mc *mc)
 {
 	mc->am_evmgr = NULL;
 	mc->am_sink  = NULL;
+	mc->am_reqh  = NULL;
 	mc->am_magic = M0_ADDB_MC_MAGIC;
 }
 
@@ -83,6 +84,7 @@ M0_INTERNAL void m0_addb_mc_fini(struct m0_addb_mc *mc)
 {
 	m0_addb_mc_unconfigure(mc);
 	mc->am_magic = 0;
+	mc->am_reqh = NULL;
 	M0_POST(!m0_addb_mc_is_initialized(mc));
 }
 
diff --git a/addb/addb_monitor.c b/addb/addb_monitor.c
new file mode 100644
index 0000000..32aac0b
--- /dev/null
+++ b/addb/addb_monitor.c
@@ -0,0 +1,581 @@
+/* -*- C -*- */
+/*
+ * COPYRIGHT 2012 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: Rohan Puri <rohan_puri@xyratex.com>
+ * Original creation: 06/14/2013
+ */
+
+/**
+   <!-- 06/13/2013 -->
+   @page ADDB-MON-INFRA-DLD ADDB monitoring infrastructure  Detailed Design
+
+   Refer to the @ref ADDB-DLD "ADDB Detailed Design"
+   for the ADDB design requirements.
+
+   - @ref ADDB-MON-INFRA-DLD-ovw
+   - @ref ADDB-MON-INFRA-DLD-def
+   - @ref ADDB-MON-INFRA-DLD-req
+   - @ref ADDB-MON-INFRA-DLD-highlights
+   - @subpage ADDB-MON-INFRA-DLD-fspec "Functional Specification" <!-- Note @subpage -->
+   - @ref ADDB-MON-INFRA-DLD-lspec
+      - @ref ADDB-MON-INFRA-DLD-lspec-comps
+      - @ref ADDB-MON-INFRA-DLD-lspec-thread
+      - @ref ADDB-MON-INFRA-DLD-lspec-state
+      - @ref ADDB-MON-INFRA-DLD-lspec-numa
+   - @ref ADDB-MON-INFRA-ut
+   - @ref ADDB-MON-INFRA-it
+   - @ref ADDB-MON-INFRA-st
+   - @ref ADDB-MON-INFRA-O
+   - @ref ADDB-MON-INFRA-ref
+
+   <hr>
+   @section ADDB-MON-INFRA-DLD-ovw Overview
+   This design describes the ADDB monitoring infrastructure along with posting
+   of addb summary records to stats service.
+
+   <hr>
+   @section ADDB-MON-INFRA-DLD-def Definitions
+   - <b> Summary ADDB records</b> These are summary records that are generated
+   by ADDB monitor for a particular statistic metric.
+   - <b> ADDB monitor</b> These are objects present on every node in the cluster
+   (client or server), they generate summary records.
+
+   <hr>
+   @section ADDB-MON-INFRA-DLD-req Requirments
+
+   The following requirements are fully described in
+   - @b r.addb.monitor.remove.runtime
+   - @b r.addb.monitor.summary.post-stats-records
+   - @b r.addb.monitor.summary.post-stats-addb-records
+   - @b @todo r.addb.monitor.summary.post-exception-records
+   - @b r.addb.monitor.nesting
+
+   <hr>
+   @section ADDB-MON-INFRA-DLD-highlights Design Highlights
+
+   <hr>
+   @section ADDB-MON-INFRA-DLD-lspec Logical Specification
+   - @ref ADDB-MON-INFRA-DLD-lspec-comps
+   - @ref ADDB-DLD-CNTR-lspec-thread
+   - @ref ADDB-DLD-CNTR-lspec-state
+   - @ref ADDB-DLD-CNTR-lspec-numa
+
+   @subsection ADDB-MON-INFRA-DLD-lspec-comps ADDB Monitor infrastructure Overview
+
+   ADDB monitors are filters which monitor the type/s of addb records they are
+   interested in. They generate & maintain summary data from this monitoring.
+   This summary data structure is monitor specific and is stored using request
+   handlers locker data structure.
+   This summary data is sent periodically to the stats service through a fop &
+   also as addb records to the addb service if present on client or to the addb
+   stob if present on server. This is done through enhancing the
+   functionality of addb pfom @ref ADDB-DLD-SVC-pstats on both the server as
+   well as the client.
+
+   @verbatim
+		Global ADDB monitors list
+             ____    ____    ____          ____
+	    |mon1|->|mon2|->|mon3|-... -> |monn|
+	    |____|  |____|  |____|        |____|
+
+
+	addb_rec_1
+	addb_rec_2 monitor stream    ____
+	addb_rec_3----------------->|monx|->Generate/Update ADDB summary record
+	    .      of addb recs     |____|
+	    .
+	    .
+	addb_rec_n
+
+   @endverbatim
+
+	Periodically running fom will send all the addb summary records for
+	all the monitors to the stats service & post the summary data as addb
+	summary records on the globally available addb machine.
+
+   @subsection ADDB-MON-INFRA-DLD-lspec-thread Threading and Concurrency Model
+
+   ADDB monitors update addb summary data by processing the addb records. Also,
+   ADDB stats posting fom periodically reads this addb summary data for
+   each monitor and sends this data to stats service. Hence,
+   need to synchronize amongst these two accesses of addb summary data. This
+   is achieved by adding m0_mutex to m0_addb_sum_rec structure.
+
+   @subsection ADDB-MON-INFRA-DLD-lspec-state FOM states for sending stats fop
+
+   On the mero server (m0d), addb pfom's ADDB_PFOM_PHASE_POST state does this.
+   For the mero client (m0t1fs), there would be a simple fom that would do this.
+
+   @subsection ADDB-MON-INFRA-DLD-lspec-numa NUMA optimizations
+   These foms that post stats summary records are executed in the same locality.
+
+
+   @section ADDB-MON-INFRA-ut Unit Tests
+   -# Test init, add, delete a particular monitor in user-space
+           & verify the summary data.
+   -# Test init, add, delete a particular monitor in kernel-space
+           & verify the summary data.
+
+   @section ADDB-MON-INFRA-it Integration Tests
+   Verify the summary records sent to stats service from a node.
+
+   @section ADDB-MON-INFRA-st
+   Add real monitor for fom rate, check the fom rate by querying
+   the stats service and verify the data.
+
+   @section ADDB-MON-INFRA-O Analysis
+   Monitor related information (list of monitors, their specific data)
+   are all kept in memory. Monitor implementors are advised to take
+   locks on monitor specific data viz. m0_addb_sum_rec:asr_mutex
+   only when they require data consistency.
+
+   @section ADDB-MON-INFRA-ref
+   - <a href="https://docs.google.com/a/xyratex.com/document/d/
+14uPeE0mNkRu3oF32Ys_EnpvSZtGWbf8hviPHTBTOXso/edit">
+   HLD of ADDB Monitoring</a>
+
+*/
+
+#undef M0_ADDB_CT_CREATE_DEFINITION
+#define M0_ADDB_CT_CREATE_DEFINITION
+#undef M0_ADDB_RT_CREATE_DEFINITION
+#define M0_ADDB_RT_CREATE_DEFINITION
+#include "stats/stats_addb.h"
+
+#include "addb/addb_monitor.h"
+#include "rpc/rpclib.h"
+#ifndef __KERNEL__
+#include "mero/setup.h"
+#endif
+
+M0_TL_DESCR_DEFINE(addb_mon, "addb monitors list", M0_INTERNAL,
+		   struct m0_addb_monitor, am_linkage, am_magic,
+		   M0_ADDB_MONITOR_LIST_LINK_MAGIC,
+		   M0_ADDB_MONITOR_LIST_HEAD_MAGIC);
+
+M0_TL_DEFINE(addb_mon, M0_INTERNAL, struct m0_addb_monitor);
+
+struct m0_addb_ctx m0_addb_monitors_mod_ctx;
+
+#ifndef __KERNEL__
+static int addb_mon_rpc_client_connect(struct m0_rpc_conn    *conn,
+				       struct m0_rpc_machine *rpc_mach,
+				       const char            *remote_addr,
+				       uint64_t               max_rpcs_in_flight)
+{
+	struct m0_net_end_point *ep;
+	int                      rc;
+
+	rc = m0_net_end_point_create(&ep, &rpc_mach->rm_tm, remote_addr);
+	if (rc != 0)
+		M0_RETURN(rc);
+	rc = m0_rpc_conn_create(conn, ep, rpc_mach, max_rpcs_in_flight,
+				M0_TIME_NEVER);
+	m0_net_end_point_put(ep);
+
+	M0_RETURN(rc);
+}
+
+M0_INTERNAL int m0_addb_monitor_stats_svc_conn_init(struct m0_reqh *reqh)
+{
+	int                           rc = 0;
+	const char                    *stats_svc_ep;
+	struct m0_mero                *mero;
+	struct m0_rpc_machine         *rmach;
+	struct m0_addb_monitoring_ctx *mon_ctx;
+
+	M0_PRE(reqh != NULL);
+
+	mon_ctx = &reqh->rh_addb_monitoring_ctx;
+
+	mero = m0_cs_ctx_get(reqh);
+	rmach = m0_reqh_rpc_mach_tlist_head(&reqh->rh_rpc_machines);
+	M0_ASSERT(mero != NULL);
+	M0_ASSERT(rmach != NULL);
+
+	stats_svc_ep = mero->cc_stats_svc_epx.ex_endpoint;
+
+	STATS_ALLOC_PTR(mon_ctx->amc_stats_conn, &m0_addb_monitors_mod_ctx,
+			SVC_CONN_ESTABLISH_1);
+	if (mon_ctx->amc_stats_conn == NULL)
+		M0_RETURN(-ENOMEM);
+	rc = addb_mon_rpc_client_connect(mon_ctx->amc_stats_conn,
+					 rmach,
+					 stats_svc_ep,
+					 ADDB_STATS_MAX_RPCS_IN_FLIGHT);
+
+	if (rc != 0) {
+		STATS_ADDB_FUNCFAIL(rc, SVC_CONN_ESTABLISH_2,
+				    &m0_addb_monitors_mod_ctx);
+		m0_free(mon_ctx->amc_stats_conn);
+		M0_RETURN(rc);
+	}
+	mon_ctx->amc_stats_ep = stats_svc_ep;
+	return rc;
+}
+#endif
+
+M0_INTERNAL void m0_addb_monitor_setup(struct m0_reqh     *reqh,
+				       struct m0_rpc_conn *conn,
+				       const char         *ep)
+{
+	struct m0_addb_monitoring_ctx *mon_ctx;
+
+	M0_PRE(reqh != NULL && conn != NULL && ep != NULL);
+
+	mon_ctx = &reqh->rh_addb_monitoring_ctx;
+
+	/** Only assign stats ep for the first mentioned conf object */
+	if (mon_ctx->amc_stats_ep == NULL) {
+		mon_ctx->amc_stats_ep      = ep;
+		mon_ctx->amc_stats_conn    = conn;
+	}
+}
+
+M0_INTERNAL int m0_addb_monitors_init(struct m0_reqh *reqh)
+{
+	int                            rc = 0;
+	struct m0_addb_monitoring_ctx *mon_ctx;
+	const struct m0_addb_ctx_type *act;
+
+	M0_PRE(reqh != NULL);
+
+	mon_ctx = &reqh->rh_addb_monitoring_ctx;
+
+	addb_mon_tlist_init(&mon_ctx->amc_list);
+	m0_mutex_init(&mon_ctx->amc_mutex);
+	act = m0_addb_ctx_type_lookup(M0_ADDB_CTXID_MONITORS_MOD);
+	if (act == NULL) {
+		m0_addb_ctx_type_register(&m0_addb_ct_monitors_mod);
+		M0_ADDB_CTX_INIT(&m0_addb_gmc, &m0_addb_monitors_mod_ctx,
+				 &m0_addb_ct_monitors_mod, &m0_addb_proc_ctx);
+	}
+
+	mon_ctx->amc_magic = M0_ADDB_MONITOR_CTX_MAGIC;
+
+	return rc;
+}
+
+M0_INTERNAL bool m0_addb_monitor_invariant(struct m0_addb_monitor *mon)
+{
+	return mon != NULL && mon->am_ops != NULL;
+}
+
+M0_INTERNAL bool m0_addb_mon_ctx_invariant(struct m0_addb_monitoring_ctx *ctx)
+{
+	return ctx->amc_magic == M0_ADDB_MONITOR_CTX_MAGIC;
+}
+
+M0_INTERNAL void m0_addb_monitor_init(struct m0_addb_monitor           *monitor,
+				      const struct m0_addb_monitor_ops *mon_ops)
+{
+	M0_PRE(monitor != NULL);
+	M0_PRE(mon_ops != NULL);
+
+	monitor->am_ops = mon_ops;
+	addb_mon_tlink_init(monitor);
+}
+
+M0_INTERNAL void m0_addb_monitor_sum_rec_init(struct m0_addb_sum_rec        *rec,
+					      const struct m0_addb_rec_type *rt,
+					      uint64_t                      *md,
+					      size_t                         nr)
+{
+	M0_PRE(rec != NULL && rt != NULL && md != NULL &&
+	       nr > 0);
+
+	m0_mutex_init(&rec->asr_mutex);
+	rec->asr_rec.ss_id              = rt->art_id;
+	rec->asr_rec.ss_data.au64s_nr   = nr;
+	rec->asr_rec.ss_data.au64s_data = md;
+}
+
+M0_INTERNAL void m0_addb_monitor_sum_rec_fini(struct m0_addb_sum_rec *sum_rec)
+{
+	M0_PRE(sum_rec != NULL);
+
+	sum_rec->asr_rec.ss_id              = M0_STATS_ID_UNDEFINED;
+	sum_rec->asr_rec.ss_data.au64s_nr   = 0;
+	sum_rec->asr_rec.ss_data.au64s_data = NULL;
+
+	m0_mutex_fini(&sum_rec->asr_mutex);
+}
+
+M0_INTERNAL void m0_addb_monitor_fini(struct m0_addb_monitor *monitor)
+{
+	M0_PRE(m0_addb_monitor_invariant(monitor));
+
+	monitor->am_ops = NULL;
+	addb_mon_tlink_fini(monitor);
+}
+
+M0_INTERNAL void m0_addb_monitor_add(struct m0_reqh               *reqh,
+				     struct m0_addb_monitor       *monitor)
+{
+	M0_PRE(reqh != NULL);
+	M0_PRE(m0_addb_monitor_invariant(monitor));
+
+	m0_mutex_lock(&reqh->rh_addb_monitoring_ctx.amc_mutex);
+	addb_mon_tlist_add_tail(&reqh->rh_addb_monitoring_ctx.amc_list, monitor);
+	m0_mutex_unlock(&reqh->rh_addb_monitoring_ctx.amc_mutex);
+}
+
+M0_INTERNAL void m0_addb_monitor_del(struct m0_reqh         *reqh,
+				     struct m0_addb_monitor *monitor)
+{
+	struct m0_reqh_service *svc;
+	struct addb_svc        *addb_svc;
+
+	M0_PRE(m0_addb_monitor_invariant(monitor));
+
+	svc = m0_reqh_service_find(&m0_addb_svc_type, reqh);
+	if (svc != NULL) {
+		addb_svc = bob_of(svc, struct addb_svc, as_reqhs,
+				  &addb_svc_bob);
+
+		m0_mutex_lock(&reqh->rh_addb_monitoring_ctx.amc_mutex);
+		if (addb_svc->as_pfom.pf_mon == monitor) {
+			addb_svc->as_pfom.pf_mon = NULL;
+		}
+		m0_mutex_unlock(&reqh->rh_addb_monitoring_ctx.amc_mutex);
+	}
+	m0_mutex_lock(&reqh->rh_addb_monitoring_ctx.amc_mutex);
+	addb_mon_tlist_del(monitor);
+	m0_mutex_unlock(&reqh->rh_addb_monitoring_ctx.amc_mutex);
+}
+
+#ifndef __KERNEL__
+M0_INTERNAL void m0_addb_monitor_stats_svc_conn_fini(struct m0_reqh *reqh)
+{
+	int                            rc;
+	struct m0_addb_monitoring_ctx *mon_ctx;
+
+	M0_PRE(reqh != NULL);
+
+	mon_ctx = &reqh->rh_addb_monitoring_ctx;
+	rc = m0_rpc_conn_destroy(mon_ctx->amc_stats_conn, M0_TIME_NEVER);
+	if (rc != 0)
+		STATS_ADDB_FUNCFAIL(rc, SVC_CONN_FINI_2,
+				    &m0_addb_monitors_mod_ctx);
+	mon_ctx->amc_stats_conn = NULL;
+	mon_ctx->amc_stats_ep   = NULL;
+}
+#endif
+
+M0_INTERNAL void m0_addb_monitors_fini(struct m0_reqh *reqh)
+{
+	struct m0_addb_monitor *mon;
+
+	m0_tl_for(addb_mon, &reqh->rh_addb_monitoring_ctx.amc_list, mon) {
+		m0_addb_monitor_del(reqh, mon);
+		m0_addb_monitor_fini(mon);
+	} m0_tl_endfor;
+
+	addb_mon_tlist_fini(&reqh->rh_addb_monitoring_ctx.amc_list);
+	m0_mutex_fini(&reqh->rh_addb_monitoring_ctx.amc_mutex);
+	reqh->rh_addb_monitoring_ctx.amc_magic = 0;
+}
+
+#define SUM_SIZE(sum) (sum->asr_rec.ss_data.au64s_nr * sizeof(uint64_t))
+
+enum {
+	/**
+	 * Maximal number of records (dirty or clean) scanned in one
+	 * invocation of m0_addb_monitor_summaries_post(). This limits
+	 * processor consumption.
+	 */
+	SCANNED_LIMIT = 16 * 1024,
+	/**
+	 * Maximal number of fops that can be sent in one invocation of
+	 * m0_addb_monitor_summaries_post().
+	 */
+	SENT_LIMIT = 3
+};
+
+/**
+ * How many records to send in one fop
+ */
+static unsigned stats_batch = 1024;
+
+static void addb_mon_fop_free(struct m0_stats_update_fop *fop_data,
+			      uint32_t                    stats_nr)
+{
+	struct m0_stats_recs *stats;
+
+	M0_PRE(fop_data != NULL);
+	stats = &fop_data->suf_stats;
+	if (fop_data->suf_stats.sf_stats != NULL) {
+		int i;
+
+		for (i = 0; i < stats_nr; ++i)
+			m0_free(stats->sf_stats[i].ss_data.au64s_data);
+		m0_free(stats->sf_stats);
+	}
+	m0_free(fop_data);
+}
+
+static void addb_monitor_stats_fop_release(struct m0_ref *ref)
+{
+	struct m0_fop *fop = container_of(ref, struct m0_fop, f_ref);
+
+	m0_fop_fini(fop);
+	m0_free(fop);
+}
+
+static int addb_monitor_stats_fop_send(struct m0_stats_update_fop *fop_data,
+				       struct m0_rpc_conn         *conn)
+{
+	struct m0_fop      *stats_update_fop;
+	struct m0_rpc_item *item;
+	int                 rc;
+
+	M0_ALLOC_PTR(stats_update_fop);
+	if (stats_update_fop == NULL)
+		M0_RETERR(-ENOMEM, "stats update fop");
+
+	m0_fop_init(stats_update_fop, &m0_fop_stats_update_fopt,
+		    (void *) fop_data, addb_monitor_stats_fop_release);
+
+	item             = &stats_update_fop->f_item;
+	item->ri_prio    = M0_RPC_ITEM_PRIO_MIN;
+	/**
+	 * @todo: Need to check what should be optimal value for
+	 * item deadline. Should be done during performance optimization.
+	 */
+	item->ri_deadline = 0;
+
+	rc = m0_rpc_oneway_item_post(conn, item);
+	M0_ASSERT(item->ri_rmachine);
+	m0_sm_group_lock(&item->ri_rmachine->rm_sm_grp);
+	m0_fop_put(stats_update_fop);
+	m0_sm_group_unlock(&item->ri_rmachine->rm_sm_grp);
+
+	return rc;
+}
+
+M0_INTERNAL int m0_addb_monitor_summaries_post(struct m0_reqh       *reqh,
+					       struct addb_post_fom *fom)
+{
+	struct m0_tl                  *mon_list;
+	struct m0_addb_monitoring_ctx *mon_ctx;
+	/* Continue scanning from the place we left last time */
+	struct m0_addb_monitor        *mon       = fom->pf_mon;
+	struct m0_stats_update_fop    *fop_data  = NULL;
+	uint32_t                       stats_nr  = 0;
+	uint32_t                       used      = 0;
+	uint32_t                       scanned   = 0;
+	uint32_t                       sent      = 0;
+	uint32_t                       result    = 0;
+	struct m0_addb_ctx            *cv[]      = {&m0_addb_monitors_mod_ctx,
+						    NULL};
+
+	M0_PRE(reqh != NULL);
+
+	mon_ctx = &reqh->rh_addb_monitoring_ctx;
+	M0_ASSERT(mon_ctx->amc_stats_conn != NULL);
+	mon_list = &mon_ctx->amc_list;
+
+	while (scanned < SCANNED_LIMIT && sent < SENT_LIMIT) {
+		struct m0_addb_sum_rec *sum;
+		struct m0_stats_sum    *rec;
+		void                   *data;
+
+		/* end of list reached, wrap around or the list is empty */
+		if (mon == NULL) {
+			m0_mutex_lock(&mon_ctx->amc_mutex);
+			mon = addb_mon_tlist_head(mon_list);
+			m0_mutex_unlock(&mon_ctx->amc_mutex);
+			if (mon == NULL ||
+			/* if the entire list was scanned and not a single
+			 * dirty record found, stop. */
+			    (scanned > 0 && fop_data == NULL))
+				break;
+		}
+		++scanned;
+		sum = mon->am_ops->amo_sum_rec(mon, reqh);
+		m0_mutex_lock(&mon_ctx->amc_mutex);
+		mon = addb_mon_tlist_next(mon_list, mon);
+		m0_mutex_unlock(&mon_ctx->amc_mutex);
+		if (sum == NULL || !sum->asr_dirty)
+			continue;
+		++stats_nr;
+		if (fop_data == NULL) {
+			M0_ALLOC_PTR(fop_data);
+			if (fop_data != NULL)
+				M0_ALLOC_ARR(fop_data->suf_stats.sf_stats,
+					     stats_batch);
+		}
+		if (M0_FI_ENABLED("mem_err")) {
+			data = NULL;
+			goto err1_injected;
+		}
+		data = m0_alloc(SUM_SIZE(sum));
+err1_injected:
+		if (fop_data == NULL || fop_data->suf_stats.sf_stats == NULL ||
+		    data == NULL) {
+			result = -ENOMEM;
+			addb_mon_fop_free(fop_data, stats_nr);
+			fop_data = NULL;
+			break;
+		}
+		rec = &fop_data->suf_stats.sf_stats[used++];
+		rec->ss_id = sum->asr_rec.ss_id;
+		rec->ss_data.au64s_nr = sum->asr_rec.ss_data.au64s_nr;
+		rec->ss_data.au64s_data = data;
+		m0_mutex_lock(&sum->asr_mutex);
+		memcpy(rec->ss_data.au64s_data,
+		       sum->asr_rec.ss_data.au64s_data, SUM_SIZE(sum));
+		sum->asr_dirty = false;
+		m0_mutex_unlock(&sum->asr_mutex);
+		/**
+		 * Post summary record on global machine too.
+		 */
+		M0_ADDB_MONITOR_STATS_POST(&m0_addb_gmc,
+					   m0_addb_rec_type_lookup(rec->ss_id),
+					   cv, rec);
+		if (used == stats_batch) {
+			fop_data->suf_stats.sf_nr = stats_batch;
+			result =
+			addb_monitor_stats_fop_send(fop_data,
+					            mon_ctx->amc_stats_conn);
+			if (result != 0)
+				goto out;
+			used     = 0;
+			fop_data = NULL;
+			stats_nr = 0;
+			++sent;
+		}
+	}
+	if (fop_data != NULL) {
+		fop_data->suf_stats.sf_nr = stats_nr;
+		result = addb_monitor_stats_fop_send(fop_data,
+					             mon_ctx->amc_stats_conn);
+		if (result != 0)
+			goto out;
+	}
+	fom->pf_mon = mon;
+out:
+	return result;
+}
+/*
+ *  Local variables:
+ *  c-indentation-style: "K&R"
+ *  c-basic-offset: 8
+ *  tab-width: 8
+ *  fill-column: 80
+ *  scroll-step: 1
+ *  End:
+ */
diff --git a/addb/addb_monitor.h b/addb/addb_monitor.h
new file mode 100644
index 0000000..be699d9
--- /dev/null
+++ b/addb/addb_monitor.h
@@ -0,0 +1,419 @@
+/* -*- C -*- */
+/*
+ * COPYRIGHT 2013 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: Rohan Puri <rohan_puri@xyratex.com>
+ * Original creation date: 06/14/2013
+ */
+
+#pragma once
+
+#ifndef __MERO_ADDB_ADDB_MONITOR_H__
+#define __MERO_ADDB_ADDB_MONITOR_H__
+
+#include "addb/addb.h"
+#include "lib/vec.h"
+#include "lib/bitmap.h"
+#include "rpc/session.h"
+
+/**
+   @page ADDB-MON-INFRA-DLD-fspec Functional Specification
+   - @ref ADDB-MON-INFRA-DLD-fspec-ds
+   - @ref ADDB-MON-INFRA-DLD-fspec-sub
+   - @ref ADDB-MON-INFRA-DLD-fspec-cli
+   - @ref ADDB-MON-INFRA-DLD-fspec-usecases
+     - @ref ADDB-MON-INFRA-DLD-fspec-uc-IAAM
+   - Detailed functional specifications:
+     - @ref addb "Analysis and Diagnostics Data-Base API"
+     - @ref addb_pvt "ADDB Internal Interfaces"
+
+   <hr>
+   @section ADDB-DLD-fspec-ds Data Structures
+
+   The following data structures are involved in an ADDB monitoring
+   infrastructure:
+   - m0_addb_monitoring_ctx
+   - m0_addb_monitor
+   - m0_addb_sum_rec
+
+   <hr>
+   @section ADDB-DLD-fspec-sub Subroutines and Macros
+
+   Interfaces needed for ADDB monitoring infrastructure
+   - m0_addb_monitors_init()
+   - m0_addb_monitor_add()
+   - m0_addb_monitor_del()
+   - m0_addb_monitors_fini()
+   - m0_addb_monitor_summaries_post()
+
+   <hr>
+   @section ADDB-DLD-fspec-usecases Recipes
+   - @ref ADDB-DLD-fspec-uc-IAAM
+
+   @subsection ADDB-DLD-fspec-uc-IAAM Init & Add monitor
+
+   This shows the series of steps that needs to be taken
+   for creating, initializing & adding the monitor into mero system.
+
+   @code
+	   1. Add monitor to the structure that is to be monitored
+	      or dynamically allocate them as mentioned in step 7.
+	      Define key field to locate m0_addb_sum_rec for this monitor.
+	struct m0_xyz_module_struct {
+		.
+		.
+		.
+		struct m0_addb_monitor xms_mon;
+		uint32_t               xms_key;
+	};
+
+	Lets consider we have a variable available to access an instance
+	of struct m0_xyz_module_struct, viz. xyz_module_var.
+
+	   2. Define the ADDB summary record type.
+	M0_ADDB_RT_DP(m0_addb_xyz, M0_ADDB_XYZ, "xyz_parm");
+
+	   3. Define a new monitor specific stats data
+	   NOTE: The fields should be only uint64_t
+	struct xyz {
+		uint64_t x_parm;
+	};
+	Its upto the monitor implementer where to define a global variable for
+	this xyz or to embed it any top level structure. If dynamic
+	allocation is needed, it should be done as mentioned in step 7.
+
+	For this eq. lets consider it part of struct m0_xyz_module_struct
+	mentioned in step 1.
+	struct m0_xyz_module_struct {
+		.
+		.
+		.
+		struct xyz xms_xyz;
+	};
+	NOTE: fields of this struct should match in total number as well as
+	the meaning to the ADDB summary record type defined in 2 (serial order
+	should be maintained while defining the structure).
+
+	   4. Define monitor operation amo_sum_rec
+	struct m0_addb_sum_rec *xyz_amo_sum_rec(const struct m0_addb_monitor *m,
+					       struct m0_reqh             *rqh)
+	{
+		struct m0_addb_sum_rec *sum_rec;
+
+		m0_rwlock_read_lock(&reqh->rh_rwlock);
+		sum_rec = m0_reqh_lockers_get(reqh, xyz_key);
+		m0_rwlock_read_unlock(&reqh->rh_rwlock);
+
+		M0_POST(sum_rec != NULL);
+
+		return sum_rec;
+	}
+
+	   5. Define monitor operations amo_watch()
+	void xyz_amo_watch(struct m0_addb_monitor *monitor,
+			   struct m0_addb_rec *rec, struct m0_reqh *reqh)
+	{
+		// for addb rec of type X
+		struct m0_addb_sum_rec *xyz;
+
+		m0_rwlock_read_lock(&reqh->rh_rwlock);
+		xyz = reqh_lockers_get(reqh, xyz_key);
+		m0_rwlock_read_unlock(&reqh->rh_rwlock);
+
+		// NOTE: Locking is optional, use only when monitor implementor
+		// specifically wants to synchronize access to summary data.
+		m0_mutex_lock(&xyz->asr_mutex);
+		// update data
+		xyz->asr_dirty = true;
+		m0_mutex_unlock(&xyz->asr_mutex);
+	}
+
+	   6. Define monitor ops struct and set these operations as initializers
+	const struct m0_addb_monitor_ops mon_ops = {
+		.amo_watch = xyz_amo_watch,
+		.amo_sum_rec = xyz_amo_sum_rec
+	};
+
+	   7. Define monitor entry's init function
+	int xyz_ame_init(void)
+	{
+		1. Define monitor.(as part of some module structure or
+		   global variable)
+		2. Define monitor specific data, in example defined as
+		   'struct xyz' & key for it. (as part of some module
+		   structure or global variable)
+		3. Dynamically allocate instance of struct m0_addb_sum_rec.
+		4. Initialize monitor.
+		5. Initialize summary record (m0_addb_sum_rec) with monitor
+		   specific data.
+		6. Initialize monitor specific data's key.
+		7. Store (lockers_set) this monitor specific data in reqh's
+		   locker data structure.
+		8. Add monitor to reqh's list of monitors for this node.
+
+		struct m0_addb_sum_rec *rec;
+		M0_ALLOC_PTR(rec);
+
+		m0_addb_monitor_init(&xyz_module_var.xms_mon, mon_ops);
+		m0_addb_monitor_sum_rec_init(rec, &m0_addb_xyz,
+					     &xyz_module_var.xms_xyz,
+					     sizeof(xyz_module_var.xms_xyz));
+		xyz_module.xms_key = m0_reqh_lockers_allot();
+		m0_reqh_lockers_set(reqh, &xyz_module.xms_key, rec);
+
+		m0_addb_monitor_add(&xyz_module_var.xms_mon);
+	}
+
+	   8. Define monitor entry's fini function
+	void xyz_ame_fini(void)
+	{
+		1. Delete monitor from reqh's list of monitors for this node.
+		2. Remove (lockers_clear)  monitor specific data from reqh's
+		   locker data structure (obviously do lockers_get before this
+		   to get the pointer to m0_addb_sum_rec structure for
+		   following steps, NOTE: shown in below code snippet).
+		3. Finalize summary record (m0_addb_sum_rec).
+		4. Free summary record (m0_addb_sum_rec).
+		5. Finalize monitor.
+		6. Free monitor specific data, key or monitor iff any of them
+		   was dynamically allocated.
+
+		struct m0_addb_sum_rec *rec =
+			&xyz_module_var.xms_mon->am_ops->amo_sum_rec(reqh,
+							xyz_module_var.xms_mon);
+		M0_PRE(rec != NULL);
+
+		m0_addb_monitor_del(&xyz_module_var.xms_mon);
+		m0_reqh_lockers_clear(reqh, &xyz_module_var.xms_key);
+		m0_addb_monitor_sum_rec_fini(rec);
+		m0_free(rec);
+		m0_addb_monitor_fini(&xyz_module_var.xms_mon);
+	}
+
+   @endcode
+*/
+
+#include "stats/stats_fops.h"
+#include "rpc/conn.h"
+
+struct m0_reqh;
+struct m0_addb_monitor;
+struct addb_post_fom;
+
+enum {
+	ADDB_STATS_MAX_RPCS_IN_FLIGHT = 1,
+	ADDB_STATS_MAX_RPC_SLOTS_NR   = 1
+};
+
+M0_TL_DESCR_DECLARE(addb_mon, M0_EXTERN);
+
+#define M0_ADDB_MONITOR_STATS_TYPE_REGISTER(stats_type, name)		\
+do {									\
+	(stats_type)->art_name = name;					\
+	m0_addb_rec_type_register(stats_type);				\
+} while(0)
+
+struct m0_addb_sum_rec {
+	/**
+	 * This flag is true iff the record contains data still
+	 * not sent to the stats service.
+	 */
+	bool                 asr_dirty;
+	/** This lock seriailizes access to this structure */
+	struct m0_mutex      asr_mutex;
+	/**
+	 * ADDB in-memory summary record
+	 * m0_stats_sum:ss_data::au64s_data is monitor
+	 * specific data
+	 */
+	struct m0_stats_sum  asr_rec;
+};
+
+struct m0_addb_monitor_ops {
+	/**
+	 * This method is called on each addb record.
+	 */
+	void                    (*amo_watch) (const struct m0_addb_monitor *mon,
+					      const struct m0_addb_rec     *rec,
+					      struct m0_reqh               *r);
+	/** Returns m0_addb_sum_rec, if any for this monitor. */
+	struct m0_addb_sum_rec *(*amo_sum_rec) (const struct m0_addb_monitor *m,
+					        struct m0_reqh               *r);
+};
+
+struct m0_addb_monitor {
+	/**
+	 * Linkage to monitors list per reqh
+	 * reqh::m0_addb_monitoring_ctx::amc_list
+	 */
+	struct m0_tlink                   am_linkage;
+	/** ADDB monitor operations vector */
+	const struct m0_addb_monitor_ops *am_ops;
+	/* Magic needed for monitor's tlist */
+	uint64_t                          am_magic;
+};
+
+/**
+ * Monitor invariant
+ */
+M0_INTERNAL bool m0_addb_monitor_invariant(struct m0_addb_monitor *mon);
+
+/**
+ * Monitoring sub-system collective information
+ * object.
+ */
+struct m0_addb_monitoring_ctx {
+	uint64_t               amc_magic;
+	/* List of active monitors */
+	struct m0_tl           amc_list;
+	/* Mutex to protect amc_list */
+	struct m0_mutex        amc_mutex;
+	/* Stats service endpoint */
+	const char            *amc_stats_ep;
+	struct m0_rpc_conn    *amc_stats_conn;
+};
+
+/**
+ * Monitor context invariant.
+ */
+M0_INTERNAL bool m0_addb_mon_ctx_invariant(struct m0_addb_monitoring_ctx *ctx);
+
+/**
+ * Initialize ADDB monitoring sub-system
+ * @param mach RPC machine
+ * @param endpoint endpoint where stats service runs
+ * @pre reqh != NULL
+ * @post reqh::rh_addb_monitoring_ctx:amg_list initialized
+ */
+M0_INTERNAL int m0_addb_monitors_init(struct m0_reqh *reqh);
+
+/**
+ * Initialize ADDB monitor
+ * @param monitor ADDB monitor object
+ * @pre monitor != NULL
+ * @pre (*am_watch) () != NULL
+ * @pre rtype != NULL && m0_addb_rec_type_lookup(rtype->art_id) != NULL
+ * @post *monitor != NULL
+ */
+M0_INTERNAL void m0_addb_monitor_init(struct m0_addb_monitor           *monitor,
+				      const struct m0_addb_monitor_ops *mon_ops);
+
+/**
+ * Init m0_addb_sum_rec (Generic summary record structure)
+ * @param rec ADDB summary record to init
+ * @param rt  ADDB record type that this monitor would produce
+ * @param md  uint64_t array of monitor specific data
+ * @param nr  No of uint64_t words.
+ */
+M0_INTERNAL void m0_addb_monitor_sum_rec_init(struct m0_addb_sum_rec        *rec,
+					      const struct m0_addb_rec_type *rt,
+					      uint64_t                      *md,
+					      size_t                         nr);
+
+/**
+ * Fini m0_addb_sum_rec (Generic summary record structure)
+ * @param sum_rec ADDB summary record to fini
+ */
+M0_INTERNAL void m0_addb_monitor_sum_rec_fini(struct m0_addb_sum_rec *sum_rec);
+
+/**
+ * Add a particular monitor with the ADDB monitoring sub-system
+ * @param reqh Request handler
+ * @param monitor ADDB monitor to register
+ */
+M0_INTERNAL void m0_addb_monitor_add(struct m0_reqh *reqh,
+				     struct m0_addb_monitor *monitor);
+
+/**
+ * Delete a particular monitor from the ADDB monitoring sub-system
+ * @param reqh Request handler
+ * @param monitor ADDB monitor to unregister
+ */
+M0_INTERNAL void m0_addb_monitor_del(struct m0_reqh *reqh,
+		                     struct m0_addb_monitor *monitor);
+
+/**
+ * Finalize monitor
+ * @param  monitor ADDB monitor to finalize
+ */
+M0_INTERNAL void m0_addb_monitor_fini(struct m0_addb_monitor *monitor);
+
+/**
+ * Cleanup the ADDB monitoring sub-system
+ */
+M0_INTERNAL void m0_addb_monitors_fini(struct m0_reqh *reqh);
+
+/**
+ * This sends all the dirtied addb summary records for the added monitors
+ * to the stats service as a fop.
+ */
+M0_INTERNAL int m0_addb_monitor_summaries_post(struct m0_reqh       *reqh,
+					       struct addb_post_fom *fom);
+
+/**
+ * Setup addb monitoring ctx within request handler with stats service
+ * connection details
+ * @param reqh request handler
+ * @param conn rpc connection object of stats service
+ * @param ep stats service endpoint
+ */
+M0_INTERNAL void m0_addb_monitor_setup(struct m0_reqh     *reqh,
+				       struct m0_rpc_conn *conn,
+				       const char         *ep);
+
+/**
+ * Macro to post ADDB monitor stats summary records as ADDB records
+ * on given addb machine.
+ * @param mc    Specify the addb machine.
+ * @param rt    Specify the pointer to the ADDB record type.
+ * @param cv    Specify the context vector.
+ * @param stats Specify the m0_stats_sum structure, this represents
+ *              the stats summary record that needs to be posted.
+ */
+#define M0_ADDB_MONITOR_STATS_POST(mc, rt, cv, stats)                   \
+do {                                                                    \
+	struct m0_addb_post_data pd;                                    \
+	M0_ASSERT(mc != NULL && rt != NULL && cv != NULL &&             \
+		  stats != NULL);                                       \
+	pd.apd_rt = rt;                                                 \
+	pd.apd_cv = cv;                                                 \
+	M0_ASSERT((rt)->art_id == stats->ss_id);                        \
+	M0__ADDB_POST(pd.apd_rt, stats->ss_data.au64s_nr,               \
+		      stats->ss_data.au64s_data);                       \
+	m0__addb_post(mc, &pd);                                         \
+} while (0)
+
+/**
+ * Establish rpc connection & session with stats service endpoint.
+ * @parm reqh Initialized request handler.
+ */
+M0_INTERNAL int m0_addb_monitor_stats_svc_conn_init(struct m0_reqh *reqh);
+
+/**
+ * Close rpc connection & session with stats service endpoint.
+ * @param reqh Initialized request handler.
+ */
+M0_INTERNAL void m0_addb_monitor_stats_svc_conn_fini(struct m0_reqh *reqh);
+
+#endif /* __MERO_ADDB_ADDB_MONITOR_H__ */
+/*
+ *  Local variables:
+ *  c-indentation-style: "K&R"
+ *  c-basic-offset: 8
+ *  tab-width: 8
+ *  fill-column: 80
+ *  scroll-step: 1
+ *  End:
+ */
diff --git a/addb/addb_monitor_wire.h b/addb/addb_monitor_wire.h
new file mode 100644
index 0000000..3beec48
--- /dev/null
+++ b/addb/addb_monitor_wire.h
@@ -0,0 +1,60 @@
+/* -*- C -*- */
+/*
+ * COPYRIGHT 2012 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: Rohan Puri <rohan_puri@xyratex.com>
+ * Original creation date: 07/09/2013
+ */
+
+#pragma once
+
+#ifndef __MERO_ADDB_ADDB_MONITOR_WIRE_H__
+#define __MERO_ADDB_ADDB_MONITOR_WIRE_H__
+
+#include "lib/types.h"
+#include "xcode/xcode_attr.h"
+#include "addb/addb_wire.h"
+
+/**
+    ADDB Monitor Serializable Data Types
+
+   These data types are serializable for network and stob use.
+   They are all tagged with the @ref xcode attributes that automate the
+   generation of the serialization code.
+   @{
+ */
+struct m0_addb_sum_rec_wire {
+	/** This is addb_rec_type:art_id for this ADDB summary record */
+	uint32_t                   asrw_id;
+	/* ADDB summary record data encoded in sequence form */
+	struct m0_addb_uint64_seq asrw_rec;
+} M0_XCA_RECORD;
+
+struct m0_addb_sum_rec_fop {
+	uint32_t                     asrf_nr;
+	struct m0_addb_sum_rec_wire *asrf_recs;
+} M0_XCA_SEQUENCE;
+
+#endif /* __MERO_ADDB_ADDB_MONITOR_WIRE_H__ */
+
+/*
+ *  Local variables:
+ *  c-indentation-style: "K&R"
+ *  c-basic-offset: 8
+ *  tab-width: 8
+ *  fill-column: 80
+ *  scroll-step: 1
+ *  End:
+ */
diff --git a/addb/addb_pfom.c b/addb/addb_pfom.c
new file mode 100644
index 0000000..ac18c5d
--- /dev/null
+++ b/addb/addb_pfom.c
@@ -0,0 +1,416 @@
+/* -*- C -*- */
+/*
+ * COPYRIGHT 2013 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: Carl Braganza <carl_braganza@xyratex.com>
+ * Original creation date: 12/09/2012
+ */
+
+/**
+   @page ADDB-DLD-SVC-pstats Periodic Posting of Statistics
+   Periodic posting of statistics is done by means of a dedicated @ref fom "FOM"
+   represented by the ::addb_post_fom structure.
+   The FOM is created by the addb_pfom_start() subroutine invoked by the
+   addb_service_start() service operation.
+
+   The FOM transitions through the following phases:
+   @dot
+   digraph pstats {
+       S0 [label="Init"]
+       S1 [label="ComputeTimeout"]
+       S2 [label="Sleep"]
+       S3 [label="Post" ]
+       S4 [label="Fini" ]
+       S0 -> S1 [label="*"];
+       S1 -> S2 [label="*"];
+       S2 -> S2 [label="NotReady"];
+       S2 -> S3 [label="Ready"];
+       S2 -> S4 [label="Stopped"];
+       S3 -> S1 [label="*"];
+   }
+   @enddot
+   - The FOM starts in the Init phase then transitions to the ComputeTimeout
+   phase.  It forces the next phase to compute the next posting epoch based
+   on the current time.
+   - In the ComputeTimeout phase the FOM calculates the absolute time of the
+   next posting epoch.  The next epoch is computed relative to the previous
+   epoch so as to reduce the impact of the actual time it takes to post the
+   statistics.  However, if the current time has already advanced significantly
+   toward the next epoch, then it will compute the next epoch against current
+   time.  The latter computation is forced on the first iteration, but could
+   conceivably happen at run time because a ready FOM is subject to scheduling
+   delays.  The FOM transitions to the Sleep phase next.
+   - In the Sleep phase, it checks to see if the FOM has been shutdown, and
+   if so, will transition to the Fini phase.  If not shutdown, it checks to
+   see if the current time exceeds the next posting epoch, and if so will
+   transition to the Post phase.  Otherwise it will block the FOM until
+   the next posting epoch.
+   - The Post phase will invoke m0_reqh_stats_post_addb() to post pending
+   statistics.  It will then transition to the ComputeTimeout phase to repeat
+   the cycle.
+
+   The period of the posting fom is set on creation from the value of
+   the ::addb_pfom_period global variable.
+
+   The posting fom is launched only if the ::addb_svc_start_pfom global
+   permits.  This control is provided for unit testing.
+
+   The FOM is terminated by invoking addb_pfom_stop().  The subroutine
+   posts an AST to cancel its timer and force it to stop itself.
+ */
+
+/* This file is designed to be included by addb/addb.c */
+
+/**
+   @ingroup addb_svc_pvt
+   @{
+ */
+
+static const struct m0_bob_type addb_pfom_bob = {
+	.bt_name = "addb pfom",
+	.bt_magix_offset = M0_MAGIX_OFFSET(struct addb_post_fom, pf_magic),
+	.bt_magix = M0_ADDB_PFOM_MAGIC,
+	.bt_check = NULL
+};
+
+M0_BOB_DEFINE(static, &addb_pfom_bob, addb_post_fom);
+
+/*
+ ******************************************************************************
+ * ADDB Statistics Posting FOM Type
+ ******************************************************************************
+ */
+enum addb_pfom_phase {
+	ADDB_PFOM_PHASE_INIT  = M0_FOM_PHASE_INIT,
+	ADDB_PFOM_PHASE_FINI  = M0_FOM_PHASE_FINISH,
+	ADDB_PFOM_PHASE_CTO   = M0_FOM_PHASE_NR,
+	ADDB_PFOM_PHASE_SLEEP,
+	ADDB_PFOM_PHASE_POST,
+};
+
+static struct m0_sm_state_descr addb_pfom_state_descr[] = {
+        [ADDB_PFOM_PHASE_INIT] = {
+                .sd_flags       = M0_SDF_INITIAL,
+                .sd_name        = "Init",
+                .sd_allowed     = M0_BITS(ADDB_PFOM_PHASE_CTO)
+        },
+        [ADDB_PFOM_PHASE_CTO] = {
+                .sd_flags       = 0,
+                .sd_name        = "ComputeTimeOut",
+                .sd_allowed     = M0_BITS(ADDB_PFOM_PHASE_SLEEP)
+        },
+        [ADDB_PFOM_PHASE_SLEEP] = {
+                .sd_flags       = 0,
+                .sd_name        = "Sleep",
+                .sd_allowed     = M0_BITS(ADDB_PFOM_PHASE_POST,
+					  ADDB_PFOM_PHASE_SLEEP,
+					  ADDB_PFOM_PHASE_FINI)
+        },
+        [ADDB_PFOM_PHASE_POST] = {
+                .sd_flags       = 0,
+                .sd_name        = "Post",
+                .sd_allowed     = M0_BITS(ADDB_PFOM_PHASE_CTO)
+        },
+        [ADDB_PFOM_PHASE_FINI] = {
+                .sd_flags       = M0_SDF_TERMINAL,
+                .sd_name        = "Fini",
+                .sd_allowed     = 0
+        },
+};
+
+static struct m0_sm_conf addb_pfom_sm_conf = {
+	.scf_name = "addb-pfom-sm",
+	.scf_nr_states = ARRAY_SIZE(addb_pfom_state_descr),
+	.scf_state = addb_pfom_state_descr
+};
+
+static const struct m0_fom_type_ops addb_pfom_type_ops = {
+        .fto_create = NULL
+};
+
+static struct m0_fom_type addb_pfom_type;
+
+/*
+ ******************************************************************************
+ * ADDB Statistics Posting FOM
+ ******************************************************************************
+ */
+
+/** UT hook to track a singleton FOM */
+static bool the_addb_pfom_started;
+
+enum {
+	/**
+	   Tolerance on the posting epoch when re-computing the next epoch.
+	   The number is expressed as a fraction of the posting period.  The
+	   greater the number the narrower the tolerance.
+	 */
+	M0_ADDB_PFOM_PERIOD_FRAC_TOLERANCE = 10,
+};
+
+static bool addb_pfom_invariant(const struct addb_post_fom *pfom)
+{
+	return addb_post_fom_bob_check(pfom);
+}
+
+static void addb_pfom_fo_fini(struct m0_fom *fom)
+{
+        struct addb_post_fom   *pfom = bob_of(fom, struct addb_post_fom, pf_fom,
+					      &addb_pfom_bob);
+	struct addb_svc        *svc = container_of(pfom, struct addb_svc,
+						   as_pfom);
+	struct m0_reqh_service *rsvc = &svc->as_reqhs;
+
+	M0_ENTRY();
+
+	m0_fom_fini(fom);
+	m0_fom_timeout_fini(&pfom->pf_timeout);
+	addb_post_fom_bob_fini(pfom);
+
+	/*
+	 * Mustn't free as the fom is embedded in the service object, but
+	 * notify UT waiters.
+	 */
+	m0_mutex_lock(&rsvc->rs_mutex);
+	pfom->pf_running = false;
+	m0_cond_broadcast(&svc->as_cond);
+	the_addb_pfom_started = false;
+	M0_LOG(M0_DEBUG, "done");
+	m0_mutex_unlock(&rsvc->rs_mutex);
+}
+
+static size_t addb_pfom_fo_locality(const struct m0_fom *fom)
+{
+	return 1; // well, why not?
+}
+
+static int addb_pfom_fo_tick(struct m0_fom *fom)
+{
+        struct addb_post_fom   *pfom = bob_of(fom, struct addb_post_fom, pf_fom,
+					      &addb_pfom_bob);
+	struct addb_svc        *svc = container_of(pfom, struct addb_svc,
+						   as_pfom);
+	struct m0_reqh         *reqh = svc->as_reqhs.rs_reqh;
+	struct m0_reqh_service *rsvc = &svc->as_reqhs;
+	int                     rc = M0_FSO_AGAIN;
+	m0_time_t               now;
+	int                     err = 0;
+	M0_ENTRY();
+
+	switch (m0_fom_phase(fom)) {
+	case ADDB_PFOM_PHASE_INIT:
+		M0_LOG(M0_DEBUG, "init");
+		m0_mutex_lock(&rsvc->rs_mutex);
+		the_addb_pfom_started = true;
+		m0_cond_broadcast(&svc->as_cond); /* for UT */
+		m0_mutex_unlock(&rsvc->rs_mutex);
+		m0_fom_phase_set(fom, ADDB_PFOM_PHASE_CTO);
+		break;
+	case ADDB_PFOM_PHASE_CTO:
+		M0_LOG(M0_DEBUG, "cto");
+		now = m0_time_now();
+		if (now < pfom->pf_next_post + pfom->pf_tolerance)
+			pfom->pf_next_post += pfom->pf_period;
+		else
+			pfom->pf_next_post = now + pfom->pf_period;
+		m0_fom_phase_set(fom, ADDB_PFOM_PHASE_SLEEP);
+		break;
+	case ADDB_PFOM_PHASE_SLEEP:
+		if (pfom->pf_shutdown) {
+			M0_LOG(M0_DEBUG, "fini");
+			m0_fom_phase_set(fom, ADDB_PFOM_PHASE_FINI);
+			rc = M0_FSO_WAIT;
+			break;
+		}
+		now = m0_time_now();
+		if (now >= pfom->pf_next_post) {
+			m0_fom_phase_set(fom, ADDB_PFOM_PHASE_POST);
+			break;
+		}
+		m0_fom_timeout_fini(&pfom->pf_timeout);
+		m0_fom_timeout_init(&pfom->pf_timeout);
+		m0_fom_timeout_wait_on(&pfom->pf_timeout, &pfom->pf_fom,
+				       pfom->pf_next_post);
+		M0_LOG(M0_DEBUG, "wait");
+		rc = M0_FSO_WAIT;
+		break;
+	case ADDB_PFOM_PHASE_POST:
+		M0_LOG(M0_DEBUG, "post");
+		m0_reqh_stats_post_addb(reqh);
+
+		if (reqh->rh_addb_monitoring_ctx.amc_stats_conn != NULL)
+			err = m0_addb_monitor_summaries_post(reqh, pfom);
+		/**
+		 * In case of summaries posting failure, just log error.
+		 * We do not terminate the fom.
+		 */
+		if (err != 0)
+			M0_LOG(M0_ERROR, "addb summary posting failed");
+
+/** Only needed for stobsink, so should not be called in kernel */
+#ifndef __KERNEL__
+		if (reqh->rh_addb_mc.am_sink->rs_skulk != NULL)
+			(*reqh->rh_addb_mc.am_sink->rs_skulk)
+				(&reqh->rh_addb_mc);
+#endif
+		m0_fom_phase_set(fom, ADDB_PFOM_PHASE_CTO);
+		break;
+	default:
+		M0_IMPOSSIBLE("Phasors were not on stun!");
+	}
+
+	M0_RETURN(rc);
+}
+
+static void addb_pfom_fo_addb_init(struct m0_fom *fom, struct m0_addb_mc *mc)
+{
+        struct addb_post_fom *pfom = bob_of(fom, struct addb_post_fom, pf_fom,
+					    &addb_pfom_bob);
+	struct addb_svc      *svc = container_of(pfom, struct addb_svc,
+						 as_pfom);
+
+	M0_ADDB_CTX_INIT(mc, &fom->fo_addb_ctx, &m0_addb_ct_addb_pfom,
+			 &svc->as_reqhs.rs_addb_ctx);
+}
+
+static const struct m0_fom_ops addb_pfom_ops = {
+        .fo_fini          = addb_pfom_fo_fini,
+        .fo_tick          = addb_pfom_fo_tick,
+        .fo_home_locality = addb_pfom_fo_locality,
+	.fo_addb_init     = addb_pfom_fo_addb_init
+};
+
+/*
+ ******************************************************************************
+ * Interfaces
+ ******************************************************************************
+ */
+
+/**
+   The periodicity set at creation.
+   Mainly for UT usage but could eventually be set via config parameters.
+ */
+static m0_time_t addb_pfom_period = M0_MKTIME(M0_ADDB_DEF_STAT_PERIOD_S, 0);
+
+/**
+   Starts the statistics posting FOM.
+   @param svc The ADDB service structure. The embedded as_pfom field is the FOM.
+ */
+static void addb_pfom_start(struct addb_svc *svc)
+{
+	struct addb_post_fom *pfom = &svc->as_pfom;
+	struct m0_fom        *fom = &pfom->pf_fom;
+	struct m0_reqh       *reqh = svc->as_reqhs.rs_reqh;
+
+	M0_ENTRY();
+	M0_PRE(addb_svc_invariant(svc));
+
+	m0_rwlock_read_lock(&reqh->rh_rwlock);
+
+	addb_post_fom_bob_init(pfom);
+	M0_POST(addb_pfom_invariant(pfom));
+
+	m0_fom_init(fom, &addb_pfom_type, &addb_pfom_ops, NULL, NULL,
+		    reqh, svc->as_reqhs.rs_type);
+	m0_fom_timeout_init(&pfom->pf_timeout);
+	pfom->pf_period = addb_pfom_period;
+	pfom->pf_tolerance = pfom->pf_period
+		/ M0_ADDB_PFOM_PERIOD_FRAC_TOLERANCE;
+	pfom->pf_next_post = 0; /* force the first timeout calculation */
+	pfom->pf_running = true;
+
+        M0_PRE(m0_fom_phase(fom) == ADDB_PFOM_PHASE_INIT);
+	m0_fom_queue(fom, reqh);
+
+	m0_rwlock_read_unlock(&reqh->rh_rwlock);
+}
+
+/**
+   AST callback to safely stop the FOM.
+ */
+static void addb_pfom_stop_cb(struct m0_sm_group *grp, struct m0_sm_ast *ast)
+{
+        struct addb_post_fom *pfom = bob_of(ast, struct addb_post_fom,
+					    pf_ast, &addb_pfom_bob);
+
+	M0_LOG(M0_DEBUG, "pfom_stop_cb: %d\n", (int)pfom->pf_running);
+	if (pfom->pf_running) {
+		if (pfom->pf_timeout.to_cb.fc_fom != NULL)
+			m0_fom_timeout_cancel(&pfom->pf_timeout);
+		if (m0_fom_is_waiting(&pfom->pf_fom))
+			m0_fom_ready(&pfom->pf_fom);
+		pfom->pf_shutdown = true;
+	}
+}
+
+/**
+   Initiates the termination of the statistics posting FOM.
+   Uses the service mutex internally.
+   Blocks until the FOM terminates.
+ */
+static void addb_pfom_stop(struct addb_svc *svc)
+{
+        struct addb_post_fom   *pfom = &svc->as_pfom;
+	struct m0_fom          *fom  = &pfom->pf_fom;
+	struct m0_reqh_service *rsvc = &svc->as_reqhs;
+
+	M0_ENTRY();
+
+	M0_PRE(addb_svc_invariant(svc));
+	M0_PRE(m0_mutex_is_not_locked(&rsvc->rs_mutex));
+
+	m0_mutex_lock(&rsvc->rs_mutex);
+	if (pfom->pf_running) {
+		M0_ASSERT(addb_pfom_invariant(pfom));
+
+		M0_LOG(M0_DEBUG, "posting pfom stop ast");
+		pfom->pf_ast.sa_cb = addb_pfom_stop_cb;
+		m0_sm_ast_post(&fom->fo_loc->fl_group, &pfom->pf_ast);
+
+		M0_LOG(M0_DEBUG, "waiting for pfom to stop");
+		while (pfom->pf_running)
+			m0_cond_wait(&svc->as_cond);
+	}
+	m0_mutex_unlock(&rsvc->rs_mutex);
+}
+
+/**
+   Initializes the statistics posting FOM module.
+ */
+M0_INTERNAL int addb_pfom_mod_init(void)
+{
+	m0_fom_type_init(&addb_pfom_type, &addb_pfom_type_ops, NULL,
+			 &addb_pfom_sm_conf);
+	return 0;
+}
+
+/**
+   Finalizes the statistics posting FOM module.
+ */
+static void addb_pfom_mod_fini(void)
+{
+}
+
+/** @} end group addb_pvt */
+
+/*
+ *  Local variables:
+ *  c-indentation-style: "K&R"
+ *  c-basic-offset: 8
+ *  tab-width: 8
+ *  fill-column: 80
+ *  scroll-step: 1
+ *  End:
+ */
diff --git a/addb/addb_rec.c b/addb/addb_rec.c
index 98d8d9e..10fdbea 100644
--- a/addb/addb_rec.c
+++ b/addb/addb_rec.c
@@ -21,12 +21,15 @@
 /* This file is designed to be included by addb/addb.c */
 
 #include "rpc/rpc_helpers.h" /* m0_xcode_what */
+#include "reqh/reqh.h"
 
 /**
    @addtogroup addb_pvt
    @{
  */
 
+extern struct m0_addb_monitor_global_ctx monitor_global_ctx;
+
 struct addb_rec_post_ut_data {
 	struct m0_addb_ctx       **cv;
 	size_t                     cv_nr;
@@ -65,13 +68,14 @@ static void addb_rec_post(struct m0_addb_mc *mc,
 			  uint64_t *fields,
 			  size_t fields_nr)
 {
-	struct m0_addb_rec *rec;
-	size_t              len;
-	size_t              ctxid_seq_data_size;
-	size_t              bytes_nr;
-	int                 i;
-	uint64_t           *dp;
-	char               *p;
+	struct m0_addb_monitor *mon;
+	struct m0_addb_rec     *rec;
+	size_t                  len;
+	size_t                  ctxid_seq_data_size;
+	size_t                  bytes_nr;
+	int                     i;
+	uint64_t               *dp;
+	char                   *p;
 
 	M0_PRE(m0_addb_mc_has_evmgr(mc));
 
@@ -147,6 +151,24 @@ static void addb_rec_post(struct m0_addb_mc *mc,
 	 * the thread.
 	 */
 	mc->am_evmgr->evm_post(mc, rec);
+
+	/**
+	 * This conditional traversing is required, since for many UTs
+	 * we do not have reqh and so we do not want to traverse.
+	 * @todo: Find a way to remove this condition and instead assert
+	 * on not NULL.
+	 */
+	if (mc->am_reqh != NULL &&
+	    m0_addb_mon_ctx_invariant(&mc->am_reqh->rh_addb_monitoring_ctx)) {
+		/* Invoke all the monitor's filters */
+		m0_mutex_lock(&mc->am_reqh->rh_addb_monitoring_ctx.amc_mutex);
+		m0_tl_for(addb_mon,
+			  &mc->am_reqh->rh_addb_monitoring_ctx.amc_list, mon) {
+			M0_ASSERT(m0_addb_monitor_invariant(mon));
+			mon->am_ops->amo_watch(mon, rec, mc->am_reqh);
+		} m0_tl_endfor;
+		m0_mutex_unlock(&mc->am_reqh->rh_addb_monitoring_ctx.amc_mutex);
+	}
 }
 
 #ifndef __KERNEL__
diff --git a/addb/addb_rpcsink.c b/addb/addb_rpcsink.c
index 410e9bc..659bae4 100644
--- a/addb/addb_rpcsink.c
+++ b/addb/addb_rpcsink.c
@@ -818,6 +818,7 @@ static const struct m0_addb_mc_recsink rpcsink_ops = {
 M0_INTERNAL int
 m0_addb_mc_configure_rpc_sink(struct m0_addb_mc     *mc,
 			      struct m0_rpc_machine *rm,
+			      struct m0_reqh        *reqh,
 			      uint32_t               npgs_init,
 			      uint32_t		     npgs_max,
 			      m0_bcount_t	     pg_size)
@@ -829,6 +830,10 @@ m0_addb_mc_configure_rpc_sink(struct m0_addb_mc     *mc,
 	M0_PRE(m0_addb_mc_is_initialized(mc));
 	M0_PRE(!m0_addb_mc_has_recsink(mc));
 	M0_PRE(rm != NULL);
+	/**
+	 * @todo: Uncomment this statement
+	M0_PRE(reqh != NULL);
+	*/
 
 	if (M0_FI_ENABLED("rsink_allocation_failed"))
 		{ rsink = NULL; goto rsink_allocation_failed; }
@@ -856,6 +861,7 @@ addb_ts_init_failed:
 	rsink->rs_mc   = mc;
 	rsink->rs_sink = rpcsink_ops;
 	mc->am_sink    = &rsink->rs_sink;
+	mc->am_reqh    = reqh;
 
 	/*
 	 * Register rpcsink item source to all outgoing
diff --git a/addb/addb_svc.c b/addb/addb_svc.c
new file mode 100644
index 0000000..9c4af4b
--- /dev/null
+++ b/addb/addb_svc.c
@@ -0,0 +1,231 @@
+/* -*- C -*- */
+/*
+ * COPYRIGHT 2013 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: Carl Braganza <carl_braganza@xyratex.com>
+ * Original creation date: 12/09/2012
+ */
+
+/**
+   @page ADDB-DLD-SVC Service
+
+   This design relates to the ADDB service. The ADDB service provides the
+   following functionality:
+   - Periodic posting of request handler related statistical data
+   - Receipt of remote ADDB data (FUTURE)
+
+   - @ref ADDB-DLD-SVC-fspec
+   - @ref ADDB-DLD-SVC-lspec
+     - @ref ADDB-DLD-SVC-pstats "Periodic Posting of Statistics"
+
+   <hr>
+   @section ADDB-DLD-SVC-fspec Functional Specification
+   The primary data structures involved are:
+   - addb_svc
+   - addb_post_fom
+
+   The interfaces involved are:
+   - addb_pfom_mod_fini()
+   - addb_pfom_mod_init()
+   - addb_pfom_start()
+   - addb_pfom_stop()
+   - m0_addb_svc_mod_fini()
+   - m0_addb_svc_mod_init()
+
+   <hr>
+   @section ADDB-DLD-SVC-lspec Logical Specification
+   The following subsections are present:
+   - @subpage ADDB-DLD-SVC-pstats "Periodic Posting of Statistics"
+
+ */
+
+/* This file is designed to be included by addb/addb.c */
+
+#include "addb/addb_svc.h"
+
+/**
+   @ingroup addb_svc_pvt
+   @{
+ */
+
+static const struct m0_bob_type addb_svc_bob = {
+	.bt_name = "addb svc",
+	.bt_magix_offset = M0_MAGIX_OFFSET(struct addb_svc, as_magic),
+	.bt_magix = M0_ADDB_SVC_MAGIC,
+	.bt_check = NULL
+};
+
+M0_BOB_DEFINE(static, &addb_svc_bob, addb_svc);
+
+/**
+   Hook to control the launch of the statistics posting thread.
+   Mainly for UT usage but could eventually be set via config parameters.
+ */
+static bool addb_svc_start_pfom = true;
+
+/**
+   UT handle to a started singleton service.  Every instance started will
+   overwrite this without serialization.
+ */
+static struct addb_svc *the_addb_svc;
+
+/*
+ ******************************************************************************
+ * ADDB service
+ ******************************************************************************
+ */
+static bool addb_svc_invariant(const struct addb_svc *svc)
+{
+	return addb_svc_bob_check(svc);
+}
+
+/**
+   The rso_start method to start the ADDB service and launch startup time
+   FOMs.
+ */
+static int addb_svc_rso_start(struct m0_reqh_service *service)
+{
+	struct addb_svc *svc;
+
+	M0_LOG(M0_DEBUG, "starting");
+	M0_PRE(m0_reqh_service_state_get(service) == M0_RST_STARTING);
+
+	svc = bob_of(service, struct addb_svc, as_reqhs, &addb_svc_bob);
+	if (addb_svc_start_pfom)
+		addb_pfom_start(svc);
+	the_addb_svc = svc;
+	return 0;
+}
+
+/**
+   The rso_prepare_to_stop method terminates the persistent FOMs.
+ */
+static void addb_svc_rso_prepare_to_stop(struct m0_reqh_service *service)
+{
+	struct addb_svc *svc;
+
+	M0_LOG(M0_DEBUG, "preparing to stop");
+	M0_PRE(m0_reqh_service_state_get(service) == M0_RST_STOPPING);
+	svc = bob_of(service, struct addb_svc, as_reqhs, &addb_svc_bob);
+	if (addb_svc_start_pfom)
+		addb_pfom_stop(svc);
+}
+
+/**
+   The rso_stop method to stop the ADDB service.
+ */
+static void addb_svc_rso_stop(struct m0_reqh_service *service)
+{
+	M0_LOG(M0_DEBUG, "stopping");
+	M0_PRE(m0_reqh_service_state_get(service) == M0_RST_STOPPED);
+}
+
+/**
+   The rso_fini method to finalize the ADDB service.
+ */
+static void addb_svc_rso_fini(struct m0_reqh_service *service)
+{
+	struct addb_svc *svc;
+
+	M0_LOG(M0_DEBUG, "done");
+	M0_PRE(M0_IN(m0_reqh_service_state_get(service), (M0_RST_STOPPED,
+	                                                  M0_RST_FAILED)));
+	svc = bob_of(service, struct addb_svc, as_reqhs, &addb_svc_bob);
+	m0_cond_fini(&svc->as_cond);
+	addb_svc_bob_fini(svc);
+	the_addb_svc = NULL;
+	m0_free(svc);
+}
+
+static const struct m0_reqh_service_ops addb_service_ops = {
+	.rso_start           = addb_svc_rso_start,
+	.rso_prepare_to_stop = addb_svc_rso_prepare_to_stop,
+	.rso_stop            = addb_svc_rso_stop,
+	.rso_fini            = addb_svc_rso_fini
+};
+
+/*
+ ******************************************************************************
+ * ADDB service type
+ ******************************************************************************
+ */
+
+/**
+   The rsto_service_allocate method to allocate an ADDB service instance.
+ */
+static int addb_svc_rsto_service_allocate(struct m0_reqh_service **service,
+					  struct m0_reqh_service_type *stype,
+					  struct m0_reqh_context *rctx)
+{
+	struct addb_svc *svc;
+
+	M0_ALLOC_PTR(svc);
+	if (svc == NULL) {
+		M0_LOG(M0_ERROR, "Unable to allocate memory for ADDB service");
+		return -ENOMEM;
+	}
+	*service = &svc->as_reqhs;
+	(*service)->rs_type = stype;
+	(*service)->rs_ops = &addb_service_ops;
+	m0_cond_init(&svc->as_cond, &(*service)->rs_mutex);
+	addb_svc_bob_init(svc);
+
+	M0_POST(addb_svc_invariant(svc));
+
+	return 0;
+}
+
+static struct m0_reqh_service_type_ops addb_service_type_ops = {
+	.rsto_service_allocate = addb_svc_rsto_service_allocate,
+};
+
+M0_REQH_SERVICE_TYPE_DEFINE(m0_addb_svc_type, &addb_service_type_ops,
+                            M0_ADDB_SVC_NAME, &m0_addb_ct_addb_service);
+
+/** @} end group addb_svc_pvt */
+
+/*
+ ******************************************************************************
+ * Public interfaces
+ ******************************************************************************
+ */
+
+M0_INTERNAL int m0_addb_svc_mod_init(void)
+{
+	int rc;
+	rc = m0_reqh_service_type_register(&m0_addb_svc_type);
+	if (rc == 0) {
+		rc = addb_pfom_mod_init();
+		if (rc != 0)
+			m0_reqh_service_type_unregister(&m0_addb_svc_type);
+	}
+	return rc;
+}
+
+M0_INTERNAL void m0_addb_svc_mod_fini(void)
+{
+	addb_pfom_mod_fini();
+        m0_reqh_service_type_unregister(&m0_addb_svc_type);
+}
+
+/*
+ *  Local variables:
+ *  c-indentation-style: "K&R"
+ *  c-basic-offset: 8
+ *  tab-width: 8
+ *  fill-column: 80
+ *  scroll-step: 1
+ *  End:
+ */
diff --git a/addb/addb_svc.h b/addb/addb_svc.h
new file mode 100644
index 0000000..5465b77
--- /dev/null
+++ b/addb/addb_svc.h
@@ -0,0 +1,112 @@
+/* -*- C -*- */
+/*
+ * COPYRIGHT 2013 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: Carl Braganza <carl_braganza@xyratex.com>
+ * Original creation date: 12/09/2012
+ */
+
+#pragma once
+
+#ifndef __MERO_ADDB_ADDB_SVC_H__
+#define __MERO_ADDB_ADDB_SVC_H__
+
+#include "reqh/reqh.h"
+#include "reqh/reqh_service.h"
+#ifndef __KERNEL__
+#include "mero/setup.h"
+#endif
+/**
+   @defgroup addb_svc_pvt ADDB Service Internal Interfaces
+   @ingroup addb_svc
+   @{
+ */
+
+extern struct m0_reqh_service_type m0_addb_svc_type;
+
+/**
+   ADDB statistics posting FOM
+ */
+struct addb_post_fom {
+	uint64_t                pf_magic;
+	/** Periodicity of the statistics post. */
+	m0_time_t               pf_period;
+	/** Tolerance limit in epoch calculation */
+	m0_time_t               pf_tolerance;
+	/** Next post time. */
+	m0_time_t               pf_next_post;
+	/** Shutdown request flag. */
+	bool                    pf_shutdown;
+	/** Running flag.  Used to synchronize termination. */
+	bool                    pf_running;
+	/** trap used to get into the locality to interact with the fom */
+	struct m0_sm_ast        pf_ast;
+	/** The FOM timer */
+	struct m0_fom_timeout   pf_timeout;
+	/** Last scanned monitor from the reqh mon list */
+	struct m0_addb_monitor *pf_mon;
+	/** Number of unprocessed monitors for single invocation of
+	 *  m0_addb_monitor_summaries_post().
+	 */
+	uint32_t                pf_mon_unprocessed_nr;
+	/** Embedded FOM object. */
+	struct m0_fom           pf_fom;
+};
+
+/**
+ * ADDB fom created for ADDB fop
+ */
+struct addb_fom {
+	uint64_t       af_magic;
+	struct m0_fom  af_fom;
+};
+
+/**
+   ADDB request handler service
+ */
+struct addb_svc {
+	uint64_t               as_magic;
+	/**
+	   The statistics posting FOM.
+	 */
+        struct addb_post_fom   as_pfom;
+	/**
+	   Service condition variable
+	 */
+	struct m0_cond         as_cond;
+	/**
+	   Embedded request handler service object.
+	 */
+	struct m0_reqh_service as_reqhs;
+};
+
+static void addb_pfom_mod_fini(void);
+static int  addb_pfom_mod_init(void);
+static void addb_pfom_start(struct addb_svc *svc);
+static void addb_pfom_stop(struct addb_svc *svc);
+
+/** @} end group addb_svc_pvt */
+
+#endif /* __MERO_ADDB_ADDB_SVC_H__ */
+
+/*
+ *  Local variables:
+ *  c-indentation-style: "K&R"
+ *  c-basic-offset: 8
+ *  tab-width: 8
+ *  fill-column: 80
+ *  scroll-step: 1
+ *  End:
+ */
diff --git a/addb/stats_srv.c b/addb/stats_srv.c
deleted file mode 100644
index 9179a1c..0000000
--- a/addb/stats_srv.c
+++ /dev/null
@@ -1,186 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2013 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Rajanikant Chirmade <rajanikant_chirmade@xyratex.com>
- * Original creation date: 06/14/2013
- */
-
-/**
-   @page DLD-stats-svc  Stats Service
-
-   - @ref DLD-stats-svc-ovw
-   - @ref DLD-stats-svc-def
-   - @ref DLD-stats-svc-req
-   - @ref DLD-stats-svc-fspecs
-   - @ref DLD-stats-svc-lspecs
-      - @ref DLD-stats-svc-lspec-state
-      - @ref DLD-stats-svc-lspec-thread
-      - @ref DLD-stats-svc-lspec-service-registration
-      - @ref DLD-stats-svc-lspec-numa
-      - @ref DLD-stats-svc-lspec-depends
-      - @ref DLD-stats-svc-lspec-conformance
-   - @ref DLD-stats-svc-ut
-   - @ref DLD-stats-svc-it
-   - @ref DLD-stats-svc-st
-   - @ref DLD-stats-svc-O
-   - @ref DLD-stats-svc-ref
-
-   <hr>
-   @section DLD-stats-svc-ovw Overview
-   This design relates to stats service. Stats service provides the follwoing
-   functionality:
-   - Updates of in-memory stats objects on requests from mero nodes
-   - Provides stats information from in-memroy stats objects to cluster
-     administrations utilities/console on their query.
-
-   <hr>
-   @section DLD-stats-svc-def Definitions
-   - <b>Stats Service</b> Stats service which processes mero statistics
-     update/query requests.
-   - <b>Stats Object</b> Stats in-memory object which represents a statitics
-     matrix.
-   - <b>Stats Update<b> Stats update request which updates Stats object values.
-   - <b>Stats Query<b> Stats query request which returns latest updated
-     stats objects values.
-
-   <hr>
-   @section DLD-stats-svc-req Requirements
-   - <b>r.stats-service.in-memory-objects</b> Maintains in-memory statistic
-     objects up to date from stats update got from mero nodes.
-   - <b>r.stats-service.update</b> It updates Stats Objects values.
-   - <b>r.stats-service.query</b> It returns Stats Object values to mero
-      monitoring console, utilities etc.
-
-   <hr>
-   @section DLD-stats-svc-lspecs Logical Specification
-   @subsection DLD-stats-svc-lspec-state State Transitions
-
-   @subsection DLD-stats-svc-lspec-thread Threading and Concurrency Model
-
-   @subsection DLD-stats-svc-lspec-service-registration Service Registration
-
-   @subsection DLD-stats-svc-lspec-numa NUMA optimizations
-
-   @subsection DLD-stats-svc-lspec-depends Dependencies
-
-   @subsection DLD-stats-svc-lspec-conformance Conformance
-
-   <hr>
-   @section DLD-stats-svc-ut Unit Tests
-
-   <hr>
-   @section DLD-stats-svc-it Integration Test
-
-   <hr>
-   @section DLD-stats-svc-st System Test
-
-   <hr>
-   @section DLD-stats-svc-O Analysis
-
-   <hr>
-   @section DLD-stats-svc-ref References
- */
-
-M0_TL_DESCR_DEFINE(stats, "statistic objects", M0_INTERNAL, struct m0_stats,
-		   s_linkage, s_magic, M0_STATS_MAGIC, M0_STATS_HEAD_MAGIC);
-M0_TL_DEFINE(stats, M0_INTERNAL, struct m0_stats);
-
-static const struct m0_bob_type stats_svc_bob = {
-	.bt_name         = "stats svc",
-	.bt_magix_offset = M0_MAGIX_OFFSET(struct stats_svc, ss_magic),
-	.bt_magix        = M0_STATS_SVC_MAGIC,
-	.bt_check        = NULL
-};
-
-M0_BOB_DEFINE(static, &stats_svc_bob, stats_svc);
-
-/*
- * Stats Service
- */
-
-/**
- * The rso_start methos to start Stats service.
- */
-static int stats_svc_rso_start(struct m0_reqh_service *service)
-{
-}
-
-/**
- * The rso_stop method to stop Stats service.
- */
-static int stats_svc_rso_stop(struct m0_reqh_service *service)
-{
-}
-
-/**
- * The rso_fini method to finalize the Stats service.
- */
-static void stats_svc_rso_fini(struct m0_reqh_service)
-{
-}
-
-static const struct m0_reqh_service_ops stats_svc_ops = {
-	.rso_start = stats_svc_rso_start,
-	.rso_stop  = stats_svc_rso_stop,
-	.rso_fini  = stats_svc_rso_stop
-};
-
-/*
- * Stats Service Type
- */
-
-static int stats_svc_rsto_service_allocate(struct m0_reqh_service      **srv,
-					   struct m0_reqh_service_type   stype,
-					   struct m0_reqh_context       *rctx)
-{
-}
-
-static struct m0_reqh_service_type_ops stats_service_type_ops = {
-	.rsto_service_allocate = stats_svc_rsto_service_allocate,
-};
-
-M0_REQH_SERVICE_TYPE_DEFINE(m0_stats_svc_type, &stats_service_type_ops,
-			    M0_STATS_SVC_NAME, &m0_addb_ct_stats_svc);
-
-/*
- * Public interfaces
- */
-
-/**
- * It register Stats service.
- */
-M0_INTERNAL int m0_stats_svc_register(void)
-{
-	return m0_reqh_service_type_register(&m0_stats_svc_type);
-}
-
-/**
- * Deregister Stats service
- */
-M0_INTERNAL int m0_stats_svc_unregister(void)
-{
-	return m0_reqh_service_type_unregister(&m0_stats_svc_type);
-}
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
diff --git a/addb/stats_srv.h b/addb/stats_srv.h
deleted file mode 100644
index c11ceb8..0000000
--- a/addb/stats_srv.h
+++ /dev/null
@@ -1,102 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2013 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Rajanikant Chirmade <rajanikant_chirmade@xyratex.com>
- * Original creation date: 06/14/2013
- */
-
-#pragma once
-
-#ifndef __MERO_ADDB_STATS_SVC_H__
-#define __MERO_ADDB_STATS_SVC_H__
-#ifndef __KERNEL__
-
-#include "reqh/reqh.h"
-#include "reqh/reqh_service.h"
-
-/**
-   @defgtoup stats_svc Stats Service Internal Interfaces
-   @{
-
-   @section DLD-stats-svc-fspecs Functioanl Specification
-   The primari data structures involved are:
-   - m0_mon_stats
-   - stats_svc
-   - stats_update_fom
-   - stats_query_fom
-
-   The interfaces involved are:
-*/
-
-#define M0_STATS_SVC_NAME "stats"
-extern struct m0_reqh_service_type m0_stats_svc_type;
-
-/**
- * In-memory representation of Statistic information
- * @todo This should goto mon.h
- */
-struct m0_stats {
-	uint64_t            s_magic;
-	char		   *s_name;
-	/** Linkage to global stats objects */
-	struct m0_tlink    *s_linkage;
-	/** ADDB records which represent statitics */
-	struct m0_addb_rec *s_data;
-};
-
-/**
- * Stats request handler service.
- */
-struct stats_svc {
-	uint64_t	       ss_magic;
-	/** List of m0_stats in-momory objects */
-	struct m0_tl           ss_stats;
-	/** Embedded request handler service object. */
-	struct m0_reqh_service ss_reqhs;
-};
-
-/**
- * Stats update request FOM
- */
-struct stats_update_fom {
-	uint64_t      suf_magic;
-	struct m0_fom suf_fom;
-};
-
-/**
- * Stats query FOM
- */
-struct stats_query_fom {
-	uint64_t      sqf_magic;
-	struct m0_fom sqf_fom;
-};
-
-M0_INTERNAL int m0_stats_svc_register(void);
-M0_INTERNAL int m0_stats_svc_unregister(void);
-
-/** @} end group stats_service */
-
-#endif /* __KERNEL__ */
-#endif /* __MERO_ADDB_STATS_SVC_H_ */
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
diff --git a/addb/user_space/addb_pfom.c b/addb/user_space/addb_pfom.c
deleted file mode 100644
index eeeb902..0000000
--- a/addb/user_space/addb_pfom.c
+++ /dev/null
@@ -1,403 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2013 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Carl Braganza <carl_braganza@xyratex.com>
- * Original creation date: 12/09/2012
- */
-
-/**
-   @page ADDB-DLD-SVC-pstats Periodic Posting of Statistics
-   Periodic posting of statistics is done by means of a dedicated @ref fom "FOM"
-   represented by the ::addb_post_fom structure.
-   The FOM is created by the addb_pfom_start() subroutine invoked by the
-   addb_service_start() service operation.
-
-   The FOM transitions through the following phases:
-   @dot
-   digraph pstats {
-       S0 [label="Init"]
-       S1 [label="ComputeTimeout"]
-       S2 [label="Sleep"]
-       S3 [label="Post" ]
-       S4 [label="Fini" ]
-       S0 -> S1 [label="*"];
-       S1 -> S2 [label="*"];
-       S2 -> S2 [label="NotReady"];
-       S2 -> S3 [label="Ready"];
-       S2 -> S4 [label="Stopped"];
-       S3 -> S1 [label="*"];
-   }
-   @enddot
-   - The FOM starts in the Init phase then transitions to the ComputeTimeout
-   phase.  It forces the next phase to compute the next posting epoch based
-   on the current time.
-   - In the ComputeTimeout phase the FOM calculates the absolute time of the
-   next posting epoch.  The next epoch is computed relative to the previous
-   epoch so as to reduce the impact of the actual time it takes to post the
-   statistics.  However, if the current time has already advanced significantly
-   toward the next epoch, then it will compute the next epoch against current
-   time.  The latter computation is forced on the first iteration, but could
-   conceivably happen at run time because a ready FOM is subject to scheduling
-   delays.  The FOM transitions to the Sleep phase next.
-   - In the Sleep phase, it checks to see if the FOM has been shutdown, and
-   if so, will transition to the Fini phase.  If not shutdown, it checks to
-   see if the current time exceeds the next posting epoch, and if so will
-   transition to the Post phase.  Otherwise it will block the FOM until
-   the next posting epoch.
-   - The Post phase will invoke m0_reqh_stats_post_addb() to post pending
-   statistics.  It will then transition to the ComputeTimeout phase to repeat
-   the cycle.
-
-   The period of the posting fom is set on creation from the value of
-   the ::addb_pfom_period global variable.
-
-   The posting fom is launched only if the ::addb_svc_start_pfom global
-   permits.  This control is provided for unit testing.
-
-   The FOM is terminated by invoking addb_pfom_stop().  The subroutine
-   posts an AST to cancel its timer and force it to stop itself.
- */
-
-/* This file is designed to be included by addb/addb.c */
-
-/**
-   @ingroup addb_svc_pvt
-   @{
- */
-
-static const struct m0_bob_type addb_pfom_bob = {
-	.bt_name = "addb pfom",
-	.bt_magix_offset = M0_MAGIX_OFFSET(struct addb_post_fom, pf_magic),
-	.bt_magix = M0_ADDB_PFOM_MAGIC,
-	.bt_check = NULL
-};
-
-M0_BOB_DEFINE(static, &addb_pfom_bob, addb_post_fom);
-
-/*
- ******************************************************************************
- * ADDB Statistics Posting FOM Type
- ******************************************************************************
- */
-enum addb_pfom_phase {
-	ADDB_PFOM_PHASE_INIT  = M0_FOM_PHASE_INIT,
-	ADDB_PFOM_PHASE_FINI  = M0_FOM_PHASE_FINISH,
-	ADDB_PFOM_PHASE_CTO   = M0_FOM_PHASE_NR,
-	ADDB_PFOM_PHASE_SLEEP,
-	ADDB_PFOM_PHASE_POST,
-};
-
-static struct m0_sm_state_descr addb_pfom_state_descr[] = {
-        [ADDB_PFOM_PHASE_INIT] = {
-                .sd_flags       = M0_SDF_INITIAL,
-                .sd_name        = "Init",
-                .sd_allowed     = M0_BITS(ADDB_PFOM_PHASE_CTO)
-        },
-        [ADDB_PFOM_PHASE_CTO] = {
-                .sd_flags       = 0,
-                .sd_name        = "ComputeTimeOut",
-                .sd_allowed     = M0_BITS(ADDB_PFOM_PHASE_SLEEP)
-        },
-        [ADDB_PFOM_PHASE_SLEEP] = {
-                .sd_flags       = 0,
-                .sd_name        = "Sleep",
-                .sd_allowed     = M0_BITS(ADDB_PFOM_PHASE_POST,
-					  ADDB_PFOM_PHASE_SLEEP,
-					  ADDB_PFOM_PHASE_FINI)
-        },
-        [ADDB_PFOM_PHASE_POST] = {
-                .sd_flags       = 0,
-                .sd_name        = "Post",
-                .sd_allowed     = M0_BITS(ADDB_PFOM_PHASE_CTO)
-        },
-        [ADDB_PFOM_PHASE_FINI] = {
-                .sd_flags       = M0_SDF_TERMINAL,
-                .sd_name        = "Fini",
-                .sd_allowed     = 0
-        },
-};
-
-static struct m0_sm_conf addb_pfom_sm_conf = {
-	.scf_name = "addb-pfom-sm",
-	.scf_nr_states = ARRAY_SIZE(addb_pfom_state_descr),
-	.scf_state = addb_pfom_state_descr
-};
-
-static const struct m0_fom_type_ops addb_pfom_type_ops = {
-        .fto_create = NULL
-};
-
-static struct m0_fom_type addb_pfom_type;
-
-/*
- ******************************************************************************
- * ADDB Statistics Posting FOM
- ******************************************************************************
- */
-
-/** UT hook to track a singleton FOM */
-static bool the_addb_pfom_started;
-
-enum {
-	/**
-	   Tolerance on the posting epoch when re-computing the next epoch.
-	   The number is expressed as a fraction of the posting period.  The
-	   greater the number the narrower the tolerance.
-	 */
-	M0_ADDB_PFOM_PERIOD_FRAC_TOLERANCE = 10,
-};
-
-static bool addb_pfom_invariant(const struct addb_post_fom *pfom)
-{
-	return addb_post_fom_bob_check(pfom);
-}
-
-static void addb_pfom_fo_fini(struct m0_fom *fom)
-{
-        struct addb_post_fom   *pfom = bob_of(fom, struct addb_post_fom, pf_fom,
-					      &addb_pfom_bob);
-	struct addb_svc        *svc = container_of(pfom, struct addb_svc,
-						   as_pfom);
-	struct m0_reqh_service *rsvc = &svc->as_reqhs;
-
-	M0_ENTRY();
-
-	m0_fom_fini(fom);
-	m0_fom_timeout_fini(&pfom->pf_timeout);
-	addb_post_fom_bob_fini(pfom);
-
-	/*
-	 * Mustn't free as the fom is embedded in the service object, but
-	 * notify UT waiters.
-	 */
-	m0_mutex_lock(&rsvc->rs_mutex);
-	pfom->pf_running = false;
-	m0_cond_broadcast(&svc->as_cond);
-	the_addb_pfom_started = false;
-	M0_LOG(M0_DEBUG, "done");
-	m0_mutex_unlock(&rsvc->rs_mutex);
-}
-
-static size_t addb_pfom_fo_locality(const struct m0_fom *fom)
-{
-	return 1; // well, why not?
-}
-
-static int addb_pfom_fo_tick(struct m0_fom *fom)
-{
-        struct addb_post_fom   *pfom = bob_of(fom, struct addb_post_fom, pf_fom,
-					      &addb_pfom_bob);
-	struct addb_svc        *svc = container_of(pfom, struct addb_svc,
-						   as_pfom);
-	struct m0_reqh         *reqh = svc->as_reqhs.rs_reqh;
-	struct m0_reqh_service *rsvc = &svc->as_reqhs;
-	int                     rc = M0_FSO_AGAIN;
-	m0_time_t               now;
-
-	M0_ENTRY();
-
-	switch (m0_fom_phase(fom)) {
-	case ADDB_PFOM_PHASE_INIT:
-		M0_LOG(M0_DEBUG, "init");
-		m0_mutex_lock(&rsvc->rs_mutex);
-		the_addb_pfom_started = true;
-		m0_cond_broadcast(&svc->as_cond); /* for UT */
-		m0_mutex_unlock(&rsvc->rs_mutex);
-		m0_fom_phase_set(fom, ADDB_PFOM_PHASE_CTO);
-		break;
-	case ADDB_PFOM_PHASE_CTO:
-		M0_LOG(M0_DEBUG, "cto");
-		now = m0_time_now();
-		if (now < pfom->pf_next_post + pfom->pf_tolerance)
-			pfom->pf_next_post += pfom->pf_period;
-		else
-			pfom->pf_next_post = now + pfom->pf_period;
-		m0_fom_phase_set(fom, ADDB_PFOM_PHASE_SLEEP);
-		break;
-	case ADDB_PFOM_PHASE_SLEEP:
-		if (pfom->pf_shutdown) {
-			M0_LOG(M0_DEBUG, "fini");
-			m0_fom_phase_set(fom, ADDB_PFOM_PHASE_FINI);
-			rc = M0_FSO_WAIT;
-			break;
-		}
-		now = m0_time_now();
-		if (now >= pfom->pf_next_post) {
-			m0_fom_phase_set(fom, ADDB_PFOM_PHASE_POST);
-			break;
-		}
-		m0_fom_timeout_fini(&pfom->pf_timeout);
-		m0_fom_timeout_init(&pfom->pf_timeout);
-		m0_fom_timeout_wait_on(&pfom->pf_timeout, &pfom->pf_fom,
-				       pfom->pf_next_post);
-		M0_LOG(M0_DEBUG, "wait");
-		rc = M0_FSO_WAIT;
-		break;
-	case ADDB_PFOM_PHASE_POST:
-		M0_LOG(M0_DEBUG, "post");
-		m0_reqh_stats_post_addb(reqh);
-		if (reqh->rh_addb_mc.am_sink->rs_skulk != NULL)
-			(*reqh->rh_addb_mc.am_sink->rs_skulk)
-				(&reqh->rh_addb_mc);
-		m0_fom_phase_set(fom, ADDB_PFOM_PHASE_CTO);
-		break;
-	default:
-		M0_IMPOSSIBLE("Phasors were not on stun!");
-	}
-
-	M0_RETURN(rc);
-}
-
-static void addb_pfom_fo_addb_init(struct m0_fom *fom, struct m0_addb_mc *mc)
-{
-        struct addb_post_fom *pfom = bob_of(fom, struct addb_post_fom, pf_fom,
-					    &addb_pfom_bob);
-	struct addb_svc      *svc = container_of(pfom, struct addb_svc,
-						 as_pfom);
-
-	M0_ADDB_CTX_INIT(mc, &fom->fo_addb_ctx, &m0_addb_ct_addb_pfom,
-			 &svc->as_reqhs.rs_addb_ctx);
-}
-
-static const struct m0_fom_ops addb_pfom_ops = {
-        .fo_fini          = addb_pfom_fo_fini,
-        .fo_tick          = addb_pfom_fo_tick,
-        .fo_home_locality = addb_pfom_fo_locality,
-	.fo_addb_init     = addb_pfom_fo_addb_init
-};
-
-/*
- ******************************************************************************
- * Interfaces
- ******************************************************************************
- */
-
-/**
-   The periodicity set at creation.
-   Mainly for UT usage but could eventually be set via config parameters.
- */
-static m0_time_t addb_pfom_period = M0_MKTIME(M0_ADDB_DEF_STAT_PERIOD_S, 0);
-
-/**
-   Starts the statistics posting FOM.
-   @param svc The ADDB service structure. The embedded as_pfom field is the FOM.
- */
-static void addb_pfom_start(struct addb_svc *svc)
-{
-	struct addb_post_fom *pfom = &svc->as_pfom;
-	struct m0_fom        *fom = &pfom->pf_fom;
-	struct m0_reqh       *reqh = svc->as_reqhs.rs_reqh;
-
-	M0_ENTRY();
-	M0_PRE(addb_svc_invariant(svc));
-
-	m0_rwlock_read_lock(&reqh->rh_rwlock);
-
-	addb_post_fom_bob_init(pfom);
-	M0_POST(addb_pfom_invariant(pfom));
-
-	m0_fom_init(fom, &addb_pfom_type, &addb_pfom_ops, NULL, NULL,
-		    reqh, svc->as_reqhs.rs_type);
-	m0_fom_timeout_init(&pfom->pf_timeout);
-	pfom->pf_period = addb_pfom_period;
-	pfom->pf_tolerance = pfom->pf_period
-		/ M0_ADDB_PFOM_PERIOD_FRAC_TOLERANCE;
-	pfom->pf_next_post = 0; /* force the first timeout calculation */
-	pfom->pf_running = true;
-
-        M0_PRE(m0_fom_phase(fom) == ADDB_PFOM_PHASE_INIT);
-	m0_fom_queue(fom, reqh);
-
-	m0_rwlock_read_unlock(&reqh->rh_rwlock);
-}
-
-/**
-   AST callback to safely stop the FOM.
- */
-static void addb_pfom_stop_cb(struct m0_sm_group *grp, struct m0_sm_ast *ast)
-{
-        struct addb_post_fom *pfom = bob_of(ast, struct addb_post_fom,
-					    pf_ast, &addb_pfom_bob);
-
-	M0_LOG(M0_DEBUG, "pfom_stop_cb: %d\n", (int)pfom->pf_running);
-	if (pfom->pf_running) {
-		if (pfom->pf_timeout.to_cb.fc_fom != NULL)
-			m0_fom_timeout_cancel(&pfom->pf_timeout);
-		if (m0_fom_is_waiting(&pfom->pf_fom))
-			m0_fom_ready(&pfom->pf_fom);
-		pfom->pf_shutdown = true;
-	}
-}
-
-/**
-   Initiates the termination of the statistics posting FOM.
-   Uses the service mutex internally.
-   Blocks until the FOM terminates.
- */
-static void addb_pfom_stop(struct addb_svc *svc)
-{
-        struct addb_post_fom   *pfom = &svc->as_pfom;
-	struct m0_fom          *fom  = &pfom->pf_fom;
-	struct m0_reqh_service *rsvc = &svc->as_reqhs;
-
-	M0_ENTRY();
-
-	M0_PRE(addb_svc_invariant(svc));
-	M0_PRE(m0_mutex_is_not_locked(&rsvc->rs_mutex));
-
-	m0_mutex_lock(&rsvc->rs_mutex);
-	if (pfom->pf_running) {
-		M0_ASSERT(addb_pfom_invariant(pfom));
-
-		M0_LOG(M0_DEBUG, "posting pfom stop ast");
-		pfom->pf_ast.sa_cb = addb_pfom_stop_cb;
-		m0_sm_ast_post(&fom->fo_loc->fl_group, &pfom->pf_ast);
-
-		M0_LOG(M0_DEBUG, "waiting for pfom to stop");
-		while (pfom->pf_running)
-			m0_cond_wait(&svc->as_cond);
-	}
-	m0_mutex_unlock(&rsvc->rs_mutex);
-}
-
-/**
-   Initializes the statistics posting FOM module.
- */
-M0_INTERNAL int addb_pfom_mod_init(void)
-{
-	m0_fom_type_init(&addb_pfom_type, &addb_pfom_type_ops, NULL,
-			 &addb_pfom_sm_conf);
-	return 0;
-}
-
-/**
-   Finalizes the statistics posting FOM module.
- */
-static void addb_pfom_mod_fini(void)
-{
-}
-
-/** @} end group addb_pvt */
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
diff --git a/addb/user_space/addb_stobsink.c b/addb/user_space/addb_stobsink.c
index 77e55d8..fb36ef2 100644
--- a/addb/user_space/addb_stobsink.c
+++ b/addb/user_space/addb_stobsink.c
@@ -1138,6 +1138,7 @@ static const struct m0_addb_mc_recsink stobsink_ops = {
 
 /* public interface */
 M0_INTERNAL int m0_addb_mc_configure_stob_sink(struct m0_addb_mc *mc,
+					       struct m0_reqh    *reqh,
 					       struct m0_stob    *stob,
 					       m0_bcount_t        segment_size,
 					       m0_bcount_t        stob_size,
@@ -1152,6 +1153,10 @@ M0_INTERNAL int m0_addb_mc_configure_stob_sink(struct m0_addb_mc *mc,
 	M0_PRE(stob != NULL && segment_size > 0 && stob_size >= segment_size);
 	M0_PRE(segment_size < INT32_MAX);
 	M0_PRE(timeout > 0);
+	/**
+	 * @todo: Uncomment this statement
+	M0_PRE(reqh != NULL);
+	*/
 
 	M0_ALLOC_PTR(sink);
 	if (sink == NULL)
@@ -1191,6 +1196,7 @@ M0_INTERNAL int m0_addb_mc_configure_stob_sink(struct m0_addb_mc *mc,
 	m0_stob_get(stob);
 	sink->ss_sync = false;
 	mc->am_sink = &sink->ss_sink;
+	mc->am_reqh = reqh;
 	M0_POST(stobsink_invariant(sink));
 	return 0;
 fail:
diff --git a/addb/user_space/addb_svc.c b/addb/user_space/addb_svc.c
deleted file mode 100644
index e288ca0..0000000
--- a/addb/user_space/addb_svc.c
+++ /dev/null
@@ -1,231 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2013 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Carl Braganza <carl_braganza@xyratex.com>
- * Original creation date: 12/09/2012
- */
-
-/**
-   @page ADDB-DLD-SVC Service
-
-   This design relates to the ADDB service. The ADDB service provides the
-   following functionality:
-   - Periodic posting of request handler related statistical data
-   - Receipt of remote ADDB data (FUTURE)
-
-   - @ref ADDB-DLD-SVC-fspec
-   - @ref ADDB-DLD-SVC-lspec
-     - @ref ADDB-DLD-SVC-pstats "Periodic Posting of Statistics"
-
-   <hr>
-   @section ADDB-DLD-SVC-fspec Functional Specification
-   The primary data structures involved are:
-   - addb_svc
-   - addb_post_fom
-
-   The interfaces involved are:
-   - addb_pfom_mod_fini()
-   - addb_pfom_mod_init()
-   - addb_pfom_start()
-   - addb_pfom_stop()
-   - m0_addb_svc_mod_fini()
-   - m0_addb_svc_mod_init()
-
-   <hr>
-   @section ADDB-DLD-SVC-lspec Logical Specification
-   The following subsections are present:
-   - @subpage ADDB-DLD-SVC-pstats "Periodic Posting of Statistics"
-
- */
-
-
-/* This file is designed to be included by addb/addb.c */
-
-#include "addb/user_space/addb_svc.h"
-
-/**
-   @ingroup addb_svc_pvt
-   @{
- */
-
-static const struct m0_bob_type addb_svc_bob = {
-	.bt_name = "addb svc",
-	.bt_magix_offset = M0_MAGIX_OFFSET(struct addb_svc, as_magic),
-	.bt_magix = M0_ADDB_SVC_MAGIC,
-	.bt_check = NULL
-};
-
-M0_BOB_DEFINE(static, &addb_svc_bob, addb_svc);
-
-/**
-   Hook to control the launch of the statistics posting thread.
-   Mainly for UT usage but could eventually be set via config parameters.
- */
-static bool addb_svc_start_pfom = true;
-
-/**
-   UT handle to a started singleton service.  Every instance started will
-   overwrite this without serialization.
- */
-static struct addb_svc *the_addb_svc;
-
-/*
- ******************************************************************************
- * ADDB service
- ******************************************************************************
- */
-static bool addb_svc_invariant(const struct addb_svc *svc)
-{
-	return addb_svc_bob_check(svc);
-}
-
-/**
-   The rso_start method to start the ADDB service and launch startup time
-   FOMs.
- */
-static int addb_svc_rso_start(struct m0_reqh_service *service)
-{
-	struct addb_svc *svc;
-
-	M0_LOG(M0_DEBUG, "starting");
-	M0_PRE(m0_reqh_service_state_get(service) == M0_RST_STARTING);
-	svc = bob_of(service, struct addb_svc, as_reqhs, &addb_svc_bob);
-	if (addb_svc_start_pfom)
-		addb_pfom_start(svc);
-	the_addb_svc = svc;
-	return 0;
-}
-
-/**
-   The rso_prepare_to_stop method terminates the persistent FOMs.
- */
-static void addb_svc_rso_prepare_to_stop(struct m0_reqh_service *service)
-{
-	struct addb_svc *svc;
-
-	M0_LOG(M0_DEBUG, "preparing to stop");
-	M0_PRE(m0_reqh_service_state_get(service) == M0_RST_STOPPING);
-	svc = bob_of(service, struct addb_svc, as_reqhs, &addb_svc_bob);
-	if (addb_svc_start_pfom)
-		addb_pfom_stop(svc);
-}
-
-/**
-   The rso_stop method to stop the ADDB service.
- */
-static void addb_svc_rso_stop(struct m0_reqh_service *service)
-{
-	M0_LOG(M0_DEBUG, "stopping");
-	M0_PRE(m0_reqh_service_state_get(service) == M0_RST_STOPPED);
-}
-
-/**
-   The rso_fini method to finalize the ADDB service.
- */
-static void addb_svc_rso_fini(struct m0_reqh_service *service)
-{
-	struct addb_svc *svc;
-
-	M0_LOG(M0_DEBUG, "done");
-	M0_PRE(M0_IN(m0_reqh_service_state_get(service), (M0_RST_STOPPED,
-	                                                  M0_RST_FAILED)));
-	svc = bob_of(service, struct addb_svc, as_reqhs, &addb_svc_bob);
-	m0_cond_fini(&svc->as_cond);
-	addb_svc_bob_fini(svc);
-	the_addb_svc = NULL;
-	m0_free(svc);
-}
-
-static const struct m0_reqh_service_ops addb_service_ops = {
-	.rso_start           = addb_svc_rso_start,
-	.rso_prepare_to_stop = addb_svc_rso_prepare_to_stop,
-	.rso_stop            = addb_svc_rso_stop,
-	.rso_fini            = addb_svc_rso_fini
-};
-
-/*
- ******************************************************************************
- * ADDB service type
- ******************************************************************************
- */
-
-/**
-   The rsto_service_allocate method to allocate an ADDB service instance.
- */
-static int addb_svc_rsto_service_allocate(struct m0_reqh_service **service,
-					  struct m0_reqh_service_type *stype,
-					  struct m0_reqh_context *rctx)
-{
-	struct addb_svc *svc;
-
-	M0_ALLOC_PTR(svc);
-	if (svc == NULL) {
-		M0_LOG(M0_ERROR, "Unable to allocate memory for ADDB service");
-		return -ENOMEM;
-	}
-	*service = &svc->as_reqhs;
-	(*service)->rs_type = stype;
-	(*service)->rs_ops = &addb_service_ops;
-	m0_cond_init(&svc->as_cond, &(*service)->rs_mutex);
-	addb_svc_bob_init(svc);
-
-	M0_POST(addb_svc_invariant(svc));
-
-	return 0;
-}
-
-static struct m0_reqh_service_type_ops addb_service_type_ops = {
-	.rsto_service_allocate = addb_svc_rsto_service_allocate,
-};
-
-M0_REQH_SERVICE_TYPE_DEFINE(m0_addb_svc_type, &addb_service_type_ops,
-                            M0_ADDB_SVC_NAME, &m0_addb_ct_addb_service);
-
-/** @} end group addb_svc_pvt */
-
-/*
- ******************************************************************************
- * Public interfaces
- ******************************************************************************
- */
-
-M0_INTERNAL int m0_addb_svc_mod_init()
-{
-	int rc;
-	rc = m0_reqh_service_type_register(&m0_addb_svc_type);
-	if (rc == 0) {
-		rc = addb_pfom_mod_init();
-		if (rc != 0)
-			m0_reqh_service_type_unregister(&m0_addb_svc_type);
-	}
-	return rc;
-}
-
-M0_INTERNAL void m0_addb_svc_mod_fini()
-{
-	addb_pfom_mod_fini();
-        m0_reqh_service_type_unregister(&m0_addb_svc_type);
-}
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
diff --git a/addb/user_space/addb_svc.h b/addb/user_space/addb_svc.h
deleted file mode 100644
index 63af08b..0000000
--- a/addb/user_space/addb_svc.h
+++ /dev/null
@@ -1,107 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2013 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Carl Braganza <carl_braganza@xyratex.com>
- * Original creation date: 12/09/2012
- */
-
-#pragma once
-
-#ifndef __MERO_ADDB_ADDB_SVC_H__
-#define __MERO_ADDB_ADDB_SVC_H__
-#ifndef __KERNEL__
-
-#include "reqh/reqh.h"
-#include "reqh/reqh_service.h"
-
-/**
-   @defgroup addb_svc_pvt ADDB Service Internal Interfaces
-   @ingroup addb_svc
-   @{
- */
-
-#define M0_ADDB_SVC_NAME  "addb"
-extern struct m0_reqh_service_type m0_addb_svc_type;
-
-/**
-   ADDB statistics posting FOM
- */
-struct addb_post_fom {
-	uint64_t              pf_magic;
-	/** Periodicity of the statistics post. */
-	m0_time_t             pf_period;
-	/** Tolerance limit in epoch calculation */
-	m0_time_t             pf_tolerance;
-	/** Next post time. */
-	m0_time_t             pf_next_post;
-	/** Shutdown request flag. */
-	bool                  pf_shutdown;
-	/** Running flag.  Used to synchronize termination. */
-	bool                  pf_running;
-	/** trap used to get into the locality to interact with the fom */
-	struct m0_sm_ast      pf_ast;
-	/** The FOM timer */
-	struct m0_fom_timeout pf_timeout;
-	/** Embedded FOM object. */
-	struct m0_fom         pf_fom;
-};
-
-/**
- * ADDB fom created for ADDB fop
- */
-struct addb_fom {
-	uint64_t       af_magic;
-	struct m0_fom  af_fom;
-};
-
-/**
-   ADDB request handler service
- */
-struct addb_svc {
-	uint64_t               as_magic;
-	/**
-	   The statistics posting FOM.
-	 */
-        struct addb_post_fom   as_pfom;
-	/**
-	   Service condition variable
-	 */
-	struct m0_cond         as_cond;
-	/**
-	   Embedded request handler service object.
-	 */
-	struct m0_reqh_service as_reqhs;
-};
-
-static void addb_pfom_mod_fini(void);
-static int  addb_pfom_mod_init(void);
-static void addb_pfom_start(struct addb_svc *svc);
-static void addb_pfom_stop(struct addb_svc *svc);
-
-/** @} end group addb_svc_pvt */
-
-#endif /* __KERNEL__ */
-#endif /* __MERO_ADDB_ADDB_SVC_H__ */
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
diff --git a/addb/ut/addb_ut.c b/addb/ut/addb_ut.c
index 15c9e3a..be8da44 100644
--- a/addb/ut/addb_ut.c
+++ b/addb/ut/addb_ut.c
@@ -29,6 +29,7 @@
 #include "lib/semaphore.h"
 #include "lib/thread.h"
 #include "ut/ut.h"
+#include "reqh/reqh.h"
 
 /* control symbol exposure by including .c files */
 #include "addb/addb.c" /* directly pick up internal static symbols */
@@ -44,6 +45,7 @@
 #include "addb/ut/addb_ut_stobsink.c"
 #include "addb/ut/addb_ut_svc.c"
 #include "addb/ut/addb_ut_fom.c"
+#include "addb/ut/addb_ut_mon_infra.c"
 #endif
 
 /*
@@ -109,11 +111,12 @@ const struct m0_test_suite m0_addb_ut = {
 		{ "addb-rpc-sink",	     addb_ut_rpcsink_test },
 		{ "addb-smcntr",             addb_ut_smcntr_test },
 #ifndef __KERNEL__
+		{ "addb-fom",                addb_ut_fom_test },
+		{ "addb-mon-infra",          addb_ut_mon_infra_test },
 		{ "addb-rpc-sink-shutdown",  addb_ut_rpcsink_shutdown_test },
 		{ "addb-stobsink-search",    addb_ut_stobsink_search },
 		{ "addb-stob-post-retrieve", addb_ut_stob },
 		{ "addb-svc",                addb_ut_svc_test },
-		{ "addb-fom",                addb_ut_fom_test },
 #endif
 		{ NULL, NULL }
         }
diff --git a/addb/ut/addb_ut_fom.c b/addb/ut/addb_ut_fom.c
index 5cd7dce..614eb36 100644
--- a/addb/ut/addb_ut_fom.c
+++ b/addb/ut/addb_ut_fom.c
@@ -146,7 +146,7 @@ static void addb_ut_fom_test(void)
 	start_rpc_client_and_server();
 	m0_addb_mc_init(&mc);
 
-	rc = m0_addb_mc_configure_rpc_sink(&mc, &cctx.rcx_rpc_machine,
+	rc = m0_addb_mc_configure_rpc_sink(&mc, &cctx.rcx_rpc_machine, NULL,
 					   UT_ADDB_FOM_TS_INIT_PAGES,
 					   UT_ADDB_FOM_TS_MAX_PAGES,
 					   UT_ADDB_FOM_TS_PAGE_SIZE);
diff --git a/addb/ut/addb_ut_mon_infra.c b/addb/ut/addb_ut_mon_infra.c
new file mode 100644
index 0000000..05b06d6
--- /dev/null
+++ b/addb/ut/addb_ut_mon_infra.c
@@ -0,0 +1,457 @@
+/*-*- C -*- */
+/*
+ * COPYRIGHT 2013 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: Rohan Puri <rohan_puri@xyratex.com>
+ * Original creation date: 09/30/2013
+ */
+
+#include "stats/stats_srv.h"
+
+enum {
+	UT_ADDB_MON_TS_INIT_PAGES  = 16,
+	UT_ADDB_MON_TS_MAX_PAGES   = 36,
+	UT_ADDB_MON_TS_PAGE_SIZE   = 4096, /* bytes */
+	UT_ADDB_MONS_NR            = 10,
+};
+
+static char *addb_mon_infra_server_argv[] = {
+	"addb_mon_infra_ut", "-r", "-p", "-T", "linux", "-D", SERVER_DB_NAME,
+	"-S", SERVER_STOB_NAME, "-A", SERVER_ADDB_STOB_NAME,
+	"-e", SERVER_ENDPOINT, "-R", SERVER_ENDPOINT, "-s", "addb",
+	"-s", "stats", "-w", "10"
+};
+
+struct m0_addb_monitor  ut_mon[UT_ADDB_MONS_NR];
+uint32_t                ut_mon_data_key[UT_ADDB_MONS_NR];
+struct m0_reqh         *ut_srv_reqh;
+uint32_t                stats_id[UT_ADDB_MONS_NR];
+struct m0_addb_ctx     *cv[4] = { NULL, &m0_addb_proc_ctx,
+				     &m0_addb_node_ctx, NULL };
+struct stats_svc       *stats_srv;
+
+struct ut_monitor_sum_data1 {
+	uint64_t umsd_field1;
+}ut_mon_sum_data1;
+
+struct ut_monitor_sum_data2 {
+	uint64_t umsd_field1;
+	uint64_t umsd_field2;
+}ut_mon_sum_data2;
+
+struct ut_monitor_sum_data3 {
+	uint64_t umsd_field1;
+	uint64_t umsd_field2;
+	uint64_t umsd_field3;
+}ut_mon_sum_data3;
+
+struct ut_monitor_sum_data4 {
+	uint64_t umsd_field1;
+	uint64_t umsd_field2;
+	uint64_t umsd_field3;
+	uint64_t umsd_field4;
+}ut_mon_sum_data4;
+
+struct ut_monitor_sum_data5 {
+	uint64_t umsd_field1;
+	uint64_t umsd_field2;
+	uint64_t umsd_field3;
+	uint64_t umsd_field4;
+	uint64_t umsd_field5;
+}ut_mon_sum_data5;
+
+struct ut_monitor_sum_data6 {
+	uint64_t umsd_field1;
+	uint64_t umsd_field2;
+	uint64_t umsd_field3;
+	uint64_t umsd_field4;
+	uint64_t umsd_field5;
+	uint64_t umsd_field6;
+}ut_mon_sum_data6;
+
+struct ut_monitor_sum_data7 {
+	uint64_t umsd_field1;
+	uint64_t umsd_field2;
+	uint64_t umsd_field3;
+	uint64_t umsd_field4;
+	uint64_t umsd_field5;
+	uint64_t umsd_field6;
+	uint64_t umsd_field7;
+}ut_mon_sum_data7;
+
+struct ut_monitor_sum_data8 {
+	uint64_t umsd_field1;
+	uint64_t umsd_field2;
+	uint64_t umsd_field3;
+	uint64_t umsd_field4;
+	uint64_t umsd_field5;
+	uint64_t umsd_field6;
+	uint64_t umsd_field7;
+	uint64_t umsd_field8;
+}ut_mon_sum_data8;
+
+struct ut_monitor_sum_data9 {
+	uint64_t umsd_field1;
+	uint64_t umsd_field2;
+	uint64_t umsd_field3;
+	uint64_t umsd_field4;
+	uint64_t umsd_field5;
+	uint64_t umsd_field6;
+	uint64_t umsd_field7;
+	uint64_t umsd_field8;
+	uint64_t umsd_field9;
+}ut_mon_sum_data9;
+
+
+void *mon_sum_data_arrp[] = { NULL,
+			    &ut_mon_sum_data1,
+			    &ut_mon_sum_data2,
+			    &ut_mon_sum_data3,
+			    &ut_mon_sum_data4,
+			    &ut_mon_sum_data5,
+			    &ut_mon_sum_data6,
+			    &ut_mon_sum_data7,
+			    &ut_mon_sum_data8,
+			    &ut_mon_sum_data9
+			  };
+#undef MON_DATA
+#define MON_DATA(n) mon_sum_data_arrp[n]
+
+void *dprt_arrp[] = { NULL,
+		      &m0__addb_ut_rt_dp1,
+		      &m0__addb_ut_rt_dp2,
+		      &m0__addb_ut_rt_dp3,
+		      &m0__addb_ut_rt_dp4,
+		      &m0__addb_ut_rt_dp5,
+		      &m0__addb_ut_rt_dp6,
+		      &m0__addb_ut_rt_dp7,
+		      &m0__addb_ut_rt_dp8,
+		      &m0__addb_ut_rt_dp9,
+		    };
+#undef DPRT_P
+#define DPRT_P(n) dprt_arrp[n]
+
+#undef DPRTP
+#define DPRTP(n) &m0__addb_ut_rt_dp ## n
+
+static struct m0_addb_sum_rec *ut_mon_sum_rec(const struct m0_addb_monitor *mon,
+				              struct m0_reqh               *reqh)
+{
+	struct m0_addb_sum_rec *sum_rec;
+	int                     idx;
+
+	for (idx = 1; idx < UT_ADDB_MONS_NR; ++idx) {
+		if (mon == &ut_mon[idx])
+			break;
+	}
+	sum_rec = m0_reqh_lockers_get(reqh, ut_mon_data_key[idx]);
+	M0_ASSERT(sum_rec != NULL);
+
+	return sum_rec;
+}
+
+void ut_mon_watch(const struct m0_addb_monitor *monitor,
+		  const struct m0_addb_rec     *rec,
+		  struct m0_reqh               *reqh)
+{
+	struct m0_addb_sum_rec *sum_rec;
+	int                     idx;
+
+	/* Get the index */
+	for (idx = 1; idx < UT_ADDB_MONS_NR; ++idx) {
+		if (monitor == &ut_mon[idx])
+			break;
+	}
+	M0_UT_ASSERT(idx < 10);
+
+	if (m0_addb_rec_rid_to_id(rec->ar_rid) == stats_id[idx]) {
+		m0_rwlock_read_lock(&reqh->rh_rwlock);
+		sum_rec = m0_reqh_lockers_get(reqh, ut_mon_data_key[idx]);
+		m0_rwlock_read_unlock(&reqh->rh_rwlock);
+		M0_ASSERT(sum_rec != NULL);
+		if (((struct ut_monitor_sum_data1 *)MON_DATA(idx))->umsd_field1
+		    == 0) {
+			m0_mutex_lock(&sum_rec->asr_mutex);
+			memcpy(MON_DATA(idx), rec->ar_data.au64s_data,
+			       idx * sizeof(uint64_t));
+			sum_rec->asr_dirty = true;
+			m0_mutex_unlock(&sum_rec->asr_mutex);
+		}
+	}
+}
+
+const struct m0_addb_monitor_ops ut_mon_ops = {
+	.amo_watch   = ut_mon_watch,
+	.amo_sum_rec = ut_mon_sum_rec
+};
+
+enum {
+	MON_TEST_1 = 1,
+	MON_TEST_2 = 2,
+	MON_TEST_3 = 3,
+};
+
+static void addb_ut_mon_init(struct m0_addb_rec_type *rtype, int idx,
+			     int test_no)
+{
+	struct m0_addb_sum_rec *sum_rec;
+
+	M0_ALLOC_PTR(sum_rec);
+	M0_ASSERT(ut_srv_reqh != NULL);
+
+	M0_ASSERT(sum_rec != NULL);
+	m0_addb_monitor_init(&ut_mon[idx], &ut_mon_ops);
+	m0_addb_monitor_sum_rec_init(sum_rec, rtype,
+				     (uint64_t *)MON_DATA(idx), idx);
+	if (test_no == MON_TEST_1)
+		ut_mon_data_key[idx] = m0_reqh_lockers_allot();
+	m0_rwlock_write_lock(&ut_srv_reqh->rh_rwlock);
+	m0_reqh_lockers_set(ut_srv_reqh, ut_mon_data_key[idx], sum_rec);
+	m0_rwlock_write_unlock(&ut_srv_reqh->rh_rwlock);
+	m0_addb_monitor_add(ut_srv_reqh, &ut_mon[idx]);
+}
+
+static void addb_ut_mon_fini(int idx)
+{
+	struct m0_addb_sum_rec *sum_rec;
+
+	M0_ASSERT(ut_srv_reqh != NULL);
+	sum_rec = ut_mon[idx].am_ops->amo_sum_rec(&ut_mon[idx], ut_srv_reqh);
+	M0_ASSERT(sum_rec != NULL);
+
+	m0_addb_monitor_del(ut_srv_reqh, &ut_mon[idx]);
+	m0_rwlock_write_lock(&ut_srv_reqh->rh_rwlock);
+	m0_reqh_lockers_clear(ut_srv_reqh, ut_mon_data_key[idx]);
+	m0_rwlock_write_unlock(&ut_srv_reqh->rh_rwlock);
+	m0_addb_monitor_sum_rec_fini(sum_rec);
+	m0_free(sum_rec);
+	m0_addb_monitor_fini(&ut_mon[idx]);
+}
+
+static void addb_post_record(struct m0_addb_mc *mc, int idx,
+			     struct m0_addb_ctx *cv[])
+{
+	switch (idx) {
+	case 1:
+		M0_ADDB_POST(&ut_srv_reqh->rh_addb_mc, DPRTP(1), cv, 10);
+		break;
+	case 2:
+		M0_ADDB_POST(&ut_srv_reqh->rh_addb_mc, DPRTP(2), cv, 10, 20);
+		break;
+	case 3:
+		M0_ADDB_POST(&ut_srv_reqh->rh_addb_mc, DPRTP(3), cv, 10, 20,
+			     30);
+		break;
+	case 4:
+		M0_ADDB_POST(&ut_srv_reqh->rh_addb_mc, DPRTP(4), cv, 10, 20, 30,
+			     40);
+		break;
+	case 5:
+		M0_ADDB_POST(&ut_srv_reqh->rh_addb_mc, DPRTP(5), cv, 10, 20, 30,
+			     40, 50);
+		break;
+	case 6:
+		M0_ADDB_POST(&ut_srv_reqh->rh_addb_mc, DPRTP(6), cv, 10, 20, 30,
+			     40, 50, 60);
+		break;
+	case 7:
+		M0_ADDB_POST(&ut_srv_reqh->rh_addb_mc, DPRTP(7), cv, 10, 20, 30,
+			     40, 50, 60, 70);
+		break;
+	case 8:
+		M0_ADDB_POST(&ut_srv_reqh->rh_addb_mc, DPRTP(8), cv, 10, 20, 30,
+			     40, 50, 60, 70, 80);
+		break;
+	case 9:
+		M0_ADDB_POST(&ut_srv_reqh->rh_addb_mc, DPRTP(9), cv, 10, 20, 30,
+			     40, 50, 60, 70, 80, 90);
+		break;
+	default:
+		M0_UT_ASSERT(0);
+	}
+}
+
+static void addb_ut_mon_verify_stats_data(struct stats_svc *stats_srv, int idx,
+					  int test_no)
+{
+	struct m0_stats *stats;
+	int              i;
+
+	stats = m0_stats_get(&stats_srv->ss_stats, stats_id[idx]);
+	M0_UT_ASSERT(stats != NULL);
+	for (i = 0; i < idx; ++i) {
+		if (test_no == MON_TEST_3)
+		M0_UT_ASSERT(stats->s_sum.ss_data.au64s_data[i] == 0);
+		else
+		M0_UT_ASSERT(stats->s_sum.ss_data.au64s_data[i]
+			     == ((i + 1) * 10));
+	}
+}
+
+static void clear_stats(struct stats_svc *stats_srv, int idx)
+{
+	struct m0_stats *stats;
+	int              i;
+
+	stats = m0_stats_get(&stats_srv->ss_stats, stats_id[idx]);
+	M0_UT_ASSERT(stats != NULL);
+	for (i = 0; i < idx; ++i)
+		stats->s_sum.ss_data.au64s_data[i] = 0;
+}
+
+static void mon_test(int test_no)
+{
+	int i;
+
+	for (i = 1; i < UT_ADDB_MONS_NR; ++i)
+		addb_post_record(&ut_srv_reqh->rh_addb_mc, i, cv);
+	m0_nanosleep(m0_time(0, 4 * 1000 * 1000 * 100), NULL);
+	for (i = 1; i < UT_ADDB_MONS_NR; ++i) {
+		addb_ut_mon_verify_stats_data(stats_srv, i, test_no);
+		addb_ut_mon_fini(i);
+	}
+}
+
+static void mon_test_1(void)
+{
+	struct m0_addb_rec_type   *dp;
+	int                        i;
+
+	/* Register addb record types & initialize addb monitors for them */
+	for (i = 1; i < UT_ADDB_MONS_NR; ++i) {
+		dp = DPRT_P(i);
+		dp->art_magic = 0;
+		stats_id[i] = dp->art_id = addb_rt_max_id + i;
+
+		/* Register ADDB summary record type */
+		m0_addb_rec_type_register(dp);
+		addb_ut_mon_init(DPRT_P(i), i, MON_TEST_1);
+	}
+	mon_test(MON_TEST_1);
+}
+
+static void mon_test_2(void)
+{
+	int i;
+
+	for (i = 1; i < UT_ADDB_MONS_NR; ++i) {
+		addb_ut_mon_init(DPRT_P(i), i, MON_TEST_2);
+	}
+	mon_test(MON_TEST_2);
+}
+
+static void mon_test_3(void)
+{
+	int i;
+
+	for (i = 1; i < UT_ADDB_MONS_NR; ++i) {
+		addb_ut_mon_init(DPRT_P(i), i, MON_TEST_3);
+	}
+	mon_test(MON_TEST_3);
+}
+
+static void addb_ut_mon_infra_test(void)
+{
+	struct m0_reqh_service    *reqh_srv;
+	m0_time_t                  temp_time;
+	int                        i;
+	int                        default_batch = stats_batch;
+
+	/* Do not need to collect any data */
+	addb_rec_post_ut_data_enabled = false;
+	temp_time = addb_pfom_period;
+	addb_pfom_period = M0_MKTIME(0, 1 * 1000 * 1000 * 100);
+	sctx.rsx_argv = addb_mon_infra_server_argv;
+	start_rpc_client_and_server();
+	ut_srv_reqh = m0_cs_reqh_get(&sctx.rsx_mero_ctx, "stats");
+
+	reqh_srv = m0_reqh_service_find(&m0_stats_svc_type, ut_srv_reqh);
+	M0_UT_ASSERT(reqh_srv != NULL);
+	stats_srv = container_of(reqh_srv, struct stats_svc, ss_reqhs);
+
+	m0__addb_ut_ct0.act_magic = 0;
+	m0__addb_ut_ct0.act_id = addb_ct_max_id + 1;
+	m0_addb_ctx_type_register(&m0__addb_ut_ct0);
+
+	M0_ADDB_CTX_INIT(&ut_srv_reqh->rh_addb_mc, &ctx, &m0__addb_ut_ct0,
+			 &m0_addb_proc_ctx);
+	cv[0] = &ctx;
+
+	/**
+	 * End to End test :-
+	 * Create 9 different addb monitors add them to the system, post
+	 * 9 different addb records where each one is monitored by its
+	 * corresponding added monitor, generate summary records, verify
+	 * that they are communicated to stats service by traversing stats list
+	 * on stats service ep.
+	 * This test sends only one fop.
+	 */
+	mon_test_1();
+	for (i = 1; i < UT_ADDB_MONS_NR; ++i) {
+		((struct ut_monitor_sum_data1 *)MON_DATA(i))->umsd_field1 = 0;
+		clear_stats(stats_srv, i);
+	}
+
+	m0_mutex_lock(&ut_srv_reqh->rh_addb_monitoring_ctx.amc_mutex);
+	stats_batch = 5;
+	m0_mutex_unlock(&ut_srv_reqh->rh_addb_monitoring_ctx.amc_mutex);
+
+	/**
+	 * Add/remove monitors dynamically.
+	 * This test sends 2 fops covering both fop sending cases of
+	 * m0_addb_monitor_summaries_post()
+	 */
+	mon_test_2();
+	for (i = 1; i < UT_ADDB_MONS_NR; ++i) {
+		((struct ut_monitor_sum_data1 *)MON_DATA(i))->umsd_field1 = 0;
+		clear_stats(stats_srv, i);
+	}
+	m0_fi_enable("m0_addb_monitor_summaries_post", "mem_err");
+
+	/**
+	 * This test checks for memory failure case, where no fop
+	 * gets sent.
+	 */
+	mon_test_3();
+
+	/* Reset to default */
+	m0_mutex_lock(&ut_srv_reqh->rh_addb_monitoring_ctx.amc_mutex);
+	stats_batch = default_batch;
+	m0_mutex_unlock(&ut_srv_reqh->rh_addb_monitoring_ctx.amc_mutex);
+
+	stop_rpc_client_and_server();
+
+	/* Reset to default */
+	addb_pfom_period = temp_time;
+
+	addb_ct_tlist_del(&m0__addb_ut_ct0);
+	m0__addb_ut_ct0.act_magic = 0;
+	for (i = 1; i < UT_ADDB_MONS_NR; ++i) {
+		addb_rt_tlist_del((struct m0_addb_rec_type *)DPRT_P(i));
+		((struct m0_addb_rec_type *)DPRT_P(i))->art_magic = 0;
+	}
+}
+#undef DPRTP
+#undef MON_DATA
+
+/*
+ *  Local variables:
+ *  c-indentation-style: "K&R"
+ *  c-basic-offset: 8
+ *  tab-width: 8
+ *  fill-column: 80
+ *  scroll-step: 1
+ *  End:
+ */
diff --git a/addb/ut/addb_ut_rpcsink.c b/addb/ut/addb_ut_rpcsink.c
index ee20d8b..d763672 100644
--- a/addb/ut/addb_ut_rpcsink.c
+++ b/addb/ut/addb_ut_rpcsink.c
@@ -104,7 +104,7 @@ static void addb_ut_rpcsink_test(void)
 	 */
 	m0_fi_enable_once("m0_addb_mc_configure_rpc_sink",
 			  "rsink_allocation_failed");
-	rc = m0_addb_mc_configure_rpc_sink(&mc, &rm,
+	rc = m0_addb_mc_configure_rpc_sink(&mc, &rm, NULL,
 					   ADDB_UT_RPCSINK_TS_INIT_PAGES,
 					   ADDB_UT_RPCSINK_TS_MAX_PAGES,
 					   ADDB_UT_RPCSINK_TS_PAGE_SIZE);
@@ -117,7 +117,7 @@ static void addb_ut_rpcsink_test(void)
 	 */
 	m0_fi_enable_once("m0_addb_mc_configure_rpc_sink",
 			  "addb_ts_init_failed");
-	rc = m0_addb_mc_configure_rpc_sink(&mc, &rm,
+	rc = m0_addb_mc_configure_rpc_sink(&mc, &rm, NULL,
 					   ADDB_UT_RPCSINK_TS_INIT_PAGES,
 					   ADDB_UT_RPCSINK_TS_MAX_PAGES,
 					   ADDB_UT_RPCSINK_TS_PAGE_SIZE);
@@ -130,7 +130,7 @@ static void addb_ut_rpcsink_test(void)
 	 */
 	m0_fi_enable_once("m0_addb_mc_configure_rpc_sink",
 			  "item_source_registration_failed");
-	rc = m0_addb_mc_configure_rpc_sink(&mc, &rm,
+	rc = m0_addb_mc_configure_rpc_sink(&mc, &rm, NULL,
 					   ADDB_UT_RPCSINK_TS_INIT_PAGES,
 					   ADDB_UT_RPCSINK_TS_MAX_PAGES,
 					   ADDB_UT_RPCSINK_TS_PAGE_SIZE);
@@ -143,7 +143,7 @@ static void addb_ut_rpcsink_test(void)
 	 */
 	m0_fi_enable_once("m0_addb_mc_configure_rpc_sink",
 			  "skip_item_source_registration");
-	rc = m0_addb_mc_configure_rpc_sink(&mc, &rm,
+	rc = m0_addb_mc_configure_rpc_sink(&mc, &rm, NULL,
 					   ADDB_UT_RPCSINK_TS_INIT_PAGES,
 					   ADDB_UT_RPCSINK_TS_MAX_PAGES,
 					   ADDB_UT_RPCSINK_TS_PAGE_SIZE);
@@ -375,7 +375,7 @@ static void addb_ut_rpcsink_shutdown_test(void)
 	start_rpc_client_and_server();
 	m0_addb_mc_init(&mc);
 
-	rc = m0_addb_mc_configure_rpc_sink(&mc, &cctx.rcx_rpc_machine,
+	rc = m0_addb_mc_configure_rpc_sink(&mc, &cctx.rcx_rpc_machine, NULL,
 					   ADDB_UT_RPCSINK_TS_INIT_PAGES,
 					   ADDB_UT_RPCSINK_TS_MAX_PAGES,
 					   ADDB_UT_RPCSINK_TS_PAGE_SIZE);
diff --git a/addb/ut/addb_ut_stobsink.c b/addb/ut/addb_ut_stobsink.c
index beefa25..940bfd5 100644
--- a/addb/ut/addb_ut_stobsink.c
+++ b/addb/ut/addb_ut_stobsink.c
@@ -319,7 +319,7 @@ static void addb_ut_stobsink_search(void)
 	stobsink_search_idx = 0;
 	stobsink_seg_nr = sz;
 	stob_size = STOBSINK_SEGMENT_SIZE * sz + 1; /* +1: check seg rounding */
-	rc = m0_addb_mc_configure_stob_sink(&mc, stob, STOBSINK_SEGMENT_SIZE,
+	rc = m0_addb_mc_configure_stob_sink(&mc, NULL, stob, STOBSINK_SEGMENT_SIZE,
 					    stob_size, timeout);
 	M0_UT_ASSERT(rc == 0);
 	sink = stobsink_from_mc(&mc);
@@ -771,7 +771,8 @@ static void addb_ut_stob(void)
 
 	m0_addb_mc_init(&mc);
 	stob_size = STOBSINK_SEGMENT_SIZE * STOBSINK_SMALL_SEG_NR;
-	rc = m0_addb_mc_configure_stob_sink(&mc, stob, STOBSINK_SEGMENT_SIZE,
+	rc = m0_addb_mc_configure_stob_sink(&mc, NULL, stob,
+					    STOBSINK_SEGMENT_SIZE,
 					    stob_size, timeout);
 	M0_UT_ASSERT(rc == 0);
 	sink = stobsink_from_mc(&mc);
@@ -803,7 +804,8 @@ static void addb_ut_stob(void)
 
 	/* Test: re-open stob, detects 1 segment, sets seq and offset */
 	m0_addb_mc_init(&mc);
-	rc = m0_addb_mc_configure_stob_sink(&mc, stob, STOBSINK_SEGMENT_SIZE,
+	rc = m0_addb_mc_configure_stob_sink(&mc, NULL, stob,
+					    STOBSINK_SEGMENT_SIZE,
 					    stob_size, timeout);
 	M0_UT_ASSERT(rc == 0);
 	sink = stobsink_from_mc(&mc);
@@ -963,7 +965,8 @@ static void addb_ut_stob(void)
 	m0_addb_mc_fini(&mc);
 	M0_UT_ASSERT(m0_atomic64_get(&stob->so_ref) == 2);
 	m0_addb_mc_init(&mc);
-	rc = m0_addb_mc_configure_stob_sink(&mc, stob, STOBSINK_SEGMENT_SIZE,
+	rc = m0_addb_mc_configure_stob_sink(&mc, NULL, stob,
+					    STOBSINK_SEGMENT_SIZE,
 					    stob_size, timeout);
 	M0_UT_ASSERT(rc == 0);
 	sink = stobsink_from_mc(&mc);
diff --git a/addb/ut/addb_ut_svc.c b/addb/ut/addb_ut_svc.c
index 03d0645..a7edb0c 100644
--- a/addb/ut/addb_ut_svc.c
+++ b/addb/ut/addb_ut_svc.c
@@ -22,7 +22,7 @@
 
 /* This file is designed to be included by addb/ut/addb_ut.c */
 
-#include "addb/user_space/addb_svc.h"
+#include "addb/addb_svc.h"
 
 #include "mero/setup.h"
 #include "net/lnet/lnet.h"
diff --git a/conf/objs/service.c b/conf/objs/service.c
index 5b8e4a0..d9cbab5 100644
--- a/conf/objs/service.c
+++ b/conf/objs/service.c
@@ -30,7 +30,8 @@ static bool service_check(const void *bob)
 
 	return ergo(self_obj->co_status == M0_CS_READY,
 		    M0_IN(self->cs_type,
-			  (M0_CST_MDS, M0_CST_IOS, M0_CST_MGS, M0_CST_DLM))) &&
+			  (M0_CST_MDS, M0_CST_IOS, M0_CST_MGS, M0_CST_DLM,
+			   M0_CST_SS))) &&
 		ergo(self_obj->co_mounted, /* check relations */
 		     parent_check(self_obj) &&
 		     child_check(self_obj, MEMBER_PTR(self->cs_node, cn_obj),
diff --git a/conf/schema.h b/conf/schema.h
index 0b480d0..0eef513 100644
--- a/conf/schema.h
+++ b/conf/schema.h
@@ -32,6 +32,7 @@ enum m0_conf_service_type {
 	M0_CST_IOS,     /*< IO/data service. */
 	M0_CST_MGS,     /*< Management service (confd?). */
 	M0_CST_DLM,     /*< DLM service. */
+	M0_CST_SS       /*< Stats service */
 };
 
 #endif /* __MERO_CONF_SCHEMA_H__ */
diff --git a/doc/addb-ids b/doc/addb-ids
index 471f97f..2cea18f 100644
--- a/doc/addb-ids
+++ b/doc/addb-ids
@@ -147,6 +147,7 @@ value            enum                 variable name         file
    508 M0T1FS_ADDB_RECID_DGIOW_SIZES     m0_addb_rt_m0t1fs_dgiow_sizes
    509 M0T1FS_ADDB_RECID_DGIOR_TIMES     m0_addb_rt_m0t1fs_dgior_times
    510 M0T1FS_ADDB_RECID_DGIOW_TIMES     m0_addb_rt_m0t1fs_dgiow_times
+   511 M0T1FS_ADDB_RECID_MON_IO_SIZE     m0_addb_rt_m0t1fs_mon_io_size
 600-699                                                            layout/layout_addb.h
 800-899                                                            mdstore/mdstore_addb.h
 900-999                                                            cm/cm_addb.h
diff --git a/doc/dld-index.c b/doc/dld-index.c
index be73d7d..ebf542f 100644
--- a/doc/dld-index.c
+++ b/doc/dld-index.c
@@ -7,6 +7,7 @@
 Detailed designs, ordered alphabetically by title:
 
 - @subpage ADDB-DLD "ADDB detailed design specification"  <!-- addb/addb.c -->
+- @subpage ADDB-MON-INFRA-DLD "ADDB monitoring infrastructure  Detailed Design" <!-- addb/addb_monitor.c -->
 - @subpage NetRQProvDLD "Auto-Provisioning of Receive Message Queue Buffers DLD" <!-- net/tm_provision.c -->
 - @subpage CMDLD "Copy Machine DLD" <!-- cm/cm.c -->
 - @subpage CPDLD "Copy Packet DLD"  <!-- cm/cp.c -->
diff --git a/extra-libs/galois b/extra-libs/galois
index 3230956..10ccbd0 160000
--- a/extra-libs/galois
+++ b/extra-libs/galois
@@ -1 +1 @@
-Subproject commit 32309568c1977a934d9aab96552392417ca9dd21
+Subproject commit 10ccbd0ca55db92909fda817ee1065d914736440
diff --git a/fop/fom.c b/fop/fom.c
index 121d9af..22bfc98 100644
--- a/fop/fom.c
+++ b/fop/fom.c
@@ -27,6 +27,8 @@
 #include "lib/time.h"
 #include "lib/timer.h"
 #include "lib/arith.h"
+#define M0_TRACE_SUBSYSTEM M0_TRACE_SUBSYS_FOP
+#include "lib/trace.h"
 #include "db/db_common.h"
 #include "addb/addb.h"
 #include "mero/magic.h"
@@ -36,6 +38,7 @@
 #include "sm/sm.h"
 #include "fop/fop_addb.h"
 #include "rpc/rpc_machine.h"
+#include "addb/addb_monitor.h"
 
 /**
  * @addtogroup fom
@@ -153,6 +156,8 @@ struct m0_loc_thread {
 	uint64_t                lt_magix;
 };
 
+static m0_time_t fop_rate_interval = M0_MKTIME(1, 0);
+
 M0_TL_DESCR_DEFINE(thr, "fom thread", static, struct m0_loc_thread, lt_linkage,
 		   lt_magix, M0_FOM_THREAD_MAGIC, M0_FOM_THREAD_HEAD_MAGIC);
 M0_TL_DEFINE(thr, static, struct m0_loc_thread);
@@ -168,15 +173,132 @@ M0_TL_DEFINE(wail, static, struct m0_fom);
 static bool fom_wait_time_is_out(const struct m0_fom_domain *dom,
                                  const struct m0_fom *fom);
 static int loc_thr_create(struct m0_fom_locality *loc);
+static void __fom_domain_fini(struct m0_fom_domain *dom);
 
 /**
  * Fom domain operations.
  * @todo Support fom timeout functionality.
  */
+#undef FOM_RATE_KEY
+#define FOM_RATE_KEY(reqh)	(reqh->rh_fom_dom.fd_fop_rate_monitor_key)
+
 static struct m0_fom_domain_ops m0_fom_dom_ops = {
 	.fdo_time_is_out = fom_wait_time_is_out
 };
 
+static struct fop_rate_stats_sum_rec {
+	uint64_t ssr_fop_rate;
+} fop_rate_stats_sum;
+
+static struct m0_addb_sum_rec *
+fop_rate_monitor_sum_rec(const struct m0_addb_monitor *mon,
+		         struct m0_reqh               *reqh)
+{
+	struct m0_addb_sum_rec *sum_rec;
+
+	M0_PRE(reqh != NULL);
+
+	m0_rwlock_read_lock(&reqh->rh_rwlock);
+	sum_rec = m0_reqh_lockers_get(reqh, FOM_RATE_KEY(reqh));
+	m0_rwlock_read_unlock(&reqh->rh_rwlock);
+
+	M0_ASSERT(sum_rec != NULL);
+
+	return sum_rec;
+}
+
+static void fop_rate_monitor_watch(const struct m0_addb_monitor *monitor,
+				   const struct m0_addb_rec     *rec,
+				   struct m0_reqh               *reqh)
+{
+#undef FOP_RATE
+#define FOP_RATE(sum_rec)					\
+	(struct fop_rate_stats_sum_rec *)sum_rec->asr_rec.ss_data.au64s_data
+
+	struct m0_addb_sum_rec        *sum_rec;
+	struct fop_rate_stats_sum_rec *f_rate;
+
+	M0_PRE(reqh != NULL);
+
+	if (m0_addb_rec_rid_make(M0_ADDB_BRT_CNTR,
+			         M0_ADDB_RECID_FOP_RATE_CNTR) == rec->ar_rid) {
+
+		sum_rec = monitor->am_ops->amo_sum_rec(monitor, reqh);
+		M0_ASSERT(sum_rec != NULL);
+
+		m0_mutex_lock(&sum_rec->asr_mutex);
+		M0_ASSERT(sum_rec->asr_rec.ss_id ==
+			  M0_ADDB_RECID_FOP_RATE);
+		f_rate = FOP_RATE(sum_rec);
+		M0_ASSERT(f_rate != NULL);
+		/*
+		 * fop_rate is ADDB counter.
+		 * rec->ar_data.au64s_data[1] is number of samples
+		 * rec->ar_data.au64s_data[2] is sum_samples
+		 */
+		f_rate->ssr_fop_rate =
+		rec->ar_data.au64s_data[2] / rec->ar_data.au64s_data[1];
+		sum_rec->asr_dirty = true;
+		m0_mutex_unlock(&sum_rec->asr_mutex);
+	}
+#undef FOP_RATE
+}
+
+const struct m0_addb_monitor_ops fop_rate_monitor_ops = {
+	.amo_watch = fop_rate_monitor_watch,
+	.amo_sum_rec = fop_rate_monitor_sum_rec
+};
+
+static int fop_rate_monitor_init(struct m0_reqh         *reqh,
+				 struct m0_addb_monitor *monitor,
+				 uint32_t               *fop_rate_monitor_key)
+{
+#undef FOP_RATE_STATS_NR
+#define FOP_RATE_STATS_NR (sizeof(fop_rate_stats_sum) / sizeof(uint64_t))
+
+	struct m0_addb_sum_rec *sum_rec;
+
+	M0_PRE(monitor != NULL && reqh != NULL);
+
+	FOP_ALLOC_PTR(sum_rec, FOM_RATE_MON_INIT, &m0_fop_addb_ctx);
+	if (sum_rec == NULL)
+		M0_RETURN(-ENOMEM);
+
+	m0_addb_monitor_init(monitor, &fop_rate_monitor_ops);
+	m0_addb_monitor_sum_rec_init(sum_rec, &m0_addb_rt_fop_rate,
+				     (uint64_t *)&fop_rate_stats_sum,
+				     FOP_RATE_STATS_NR);
+
+	*fop_rate_monitor_key = m0_reqh_lockers_allot();
+
+	m0_rwlock_write_lock(&reqh->rh_rwlock);
+	m0_reqh_lockers_set(reqh, *fop_rate_monitor_key, sum_rec);
+	m0_rwlock_write_unlock(&reqh->rh_rwlock);
+
+	m0_addb_monitor_add(reqh, monitor);
+	return 0;
+}
+
+static void fop_rate_monitor_fini(struct m0_reqh         *reqh,
+				  struct m0_addb_monitor *monitor,
+				  uint32_t                fop_rate_monitor_key)
+{
+	struct m0_addb_sum_rec *sum_rec;
+
+	M0_PRE(monitor != NULL && reqh != NULL);
+
+	sum_rec = monitor->am_ops->amo_sum_rec(monitor, reqh);
+	m0_addb_monitor_del(reqh, monitor);
+
+	m0_rwlock_write_lock(&reqh->rh_rwlock);
+	m0_reqh_lockers_clear(reqh, fop_rate_monitor_key);
+	m0_rwlock_write_unlock(&reqh->rh_rwlock);
+
+	m0_addb_monitor_sum_rec_fini(sum_rec);
+	m0_free(sum_rec);
+
+	m0_addb_monitor_fini(monitor);
+}
 static void group_lock(struct m0_fom_locality *loc)
 {
 	m0_sm_group_lock(&loc->fl_group);
@@ -536,6 +658,8 @@ static void fom_exec(struct m0_fom *fom)
 				exec_time >> 10); /* ~usec */
 
 	if (m0_fom_phase(fom) == M0_FOM_PHASE_FINISH) {
+		m0_time_t        now = m0_time_now();
+
                 /*
                  * Finish fom itself.
                  */
@@ -543,6 +667,14 @@ static void fom_exec(struct m0_fom *fom)
 		/*
 		 * Don't touch the fom after this point.
 		 */
+		++loc->fl_fop_rate_count;
+		if (now >= loc->fl_fop_rate_next_update) {
+			m0_addb_counter_update(&loc->fl_stat_fop_rate,
+					       loc->fl_fop_rate_count);
+			loc->fl_fop_rate_next_update =
+				m0_time_add(now, fop_rate_interval);
+			loc->fl_fop_rate_count = 0;
+		}
 	} else {
 		struct m0_fom_callback *cb;
 
@@ -758,6 +890,7 @@ static void loc_fini(struct m0_fom_locality *loc)
 
 	m0_addb_counter_fini(&loc->fl_stat_sched_wait_times);
 	m0_addb_counter_fini(&loc->fl_stat_run_times);
+	m0_addb_counter_fini(&loc->fl_stat_fop_rate);
 	m0_addb_ctx_fini(&loc->fl_addb_ctx);
 }
 
@@ -795,17 +928,19 @@ static int loc_init(struct m0_fom_locality *loc, size_t cpu, size_t cpu_max)
 
 	result = m0_addb_counter_init(&loc->fl_stat_run_times,
 				      &m0_addb_rt_fl_run_times);
-	if (result != 0) {
-		m0_addb_ctx_fini(&loc->fl_addb_ctx);
-		return result;
-	}
+	if (result != 0)
+		goto err3;
+
 	result = m0_addb_counter_init(&loc->fl_stat_sched_wait_times,
 				      &m0_addb_rt_fl_sched_wait_times);
-	if (result != 0) {
-		m0_addb_counter_fini(&loc->fl_stat_run_times);
-		m0_addb_ctx_fini(&loc->fl_addb_ctx);
-		return result;
-	}
+	if (result != 0)
+		goto err2;
+
+	loc->fl_fop_rate_next_update = 0;
+	result = m0_addb_counter_init(&loc->fl_stat_fop_rate,
+				      &m0_addb_rt_fop_rate_cntr);
+	if (result != 0)
+		goto err1;
 
 	runq_tlist_init(&loc->fl_runq);
 	loc->fl_runq_nr = 0;
@@ -840,6 +975,14 @@ static int loc_init(struct m0_fom_locality *loc, size_t cpu, size_t cpu_max)
 		loc_fini(loc);
 
 	return result;
+
+err1:
+	m0_addb_counter_fini(&loc->fl_stat_sched_wait_times);
+err2:
+	m0_addb_counter_fini(&loc->fl_stat_run_times);
+err3:
+	m0_addb_ctx_fini(&loc->fl_addb_ctx);
+	return result;
 }
 
 static void loc_ast_post_stats(struct m0_sm_group *grp, struct m0_sm_ast *ast)
@@ -854,6 +997,9 @@ static void loc_ast_post_stats(struct m0_sm_group *grp, struct m0_sm_ast *ast)
 	if (m0_addb_counter_nr(&loc->fl_stat_sched_wait_times) > 0)
 		M0_ADDB_POST_CNTR(&loc->fl_dom->fd_reqh->rh_addb_mc, cv,
 				  &loc->fl_stat_sched_wait_times);
+	if (m0_addb_counter_nr(&loc->fl_stat_fop_rate) > 0)
+		M0_ADDB_POST_CNTR(&loc->fl_dom->fd_reqh->rh_addb_mc, cv,
+				  &loc->fl_stat_fop_rate);
 	M0_ADDB_POST(&loc->fl_dom->fd_reqh->rh_addb_mc, &m0_addb_rt_fl_runq_nr,
 		     cv, loc->fl_runq_nr);
 	M0_ADDB_POST(&loc->fl_dom->fd_reqh->rh_addb_mc, &m0_addb_rt_fl_wail_nr,
@@ -903,7 +1049,7 @@ M0_INTERNAL int m0_fom_domain_init(struct m0_fom_domain *dom)
 		loc->fl_dom = dom;
 		result = loc_init(loc, cpu, cpu_max);
 		if (result != 0) {
-			m0_fom_domain_fini(dom);
+			__fom_domain_fini(dom);
 			break;
 		}
 		m0_locality_set(cpu, &(struct m0_locality){
@@ -912,12 +1058,15 @@ M0_INTERNAL int m0_fom_domain_init(struct m0_fom_domain *dom)
 				.lo_idx  = dom->fd_localities_nr });
 		M0_CNT_INC(dom->fd_localities_nr);
 	}
-	m0_bitmap_fini(&onln_cpu_map);
 
-	return result;
+	m0_bitmap_fini(&onln_cpu_map);
+	dom->fd_fop_rate_monitor_key = 0;
+	return fop_rate_monitor_init(dom->fd_reqh,
+				     &dom->fd_fop_rate_monitor,
+				     &dom->fd_fop_rate_monitor_key);
 }
 
-M0_INTERNAL void m0_fom_domain_fini(struct m0_fom_domain *dom)
+static void __fom_domain_fini(struct m0_fom_domain *dom)
 {
 	int fd_loc_nr;
 
@@ -932,6 +1081,14 @@ M0_INTERNAL void m0_fom_domain_fini(struct m0_fom_domain *dom)
 	m0_free(dom->fd_localities);
 }
 
+M0_INTERNAL void m0_fom_domain_fini(struct m0_fom_domain *dom)
+{
+	__fom_domain_fini(dom);
+	fop_rate_monitor_fini(dom->fd_reqh,
+			      &dom->fd_fop_rate_monitor,
+			      dom->fd_fop_rate_monitor_key);
+}
+
 M0_INTERNAL bool m0_fom_domain_is_idle(const struct m0_fom_domain *dom)
 {
 	return m0_forall(i, dom->fd_localities_nr,
@@ -1397,6 +1554,7 @@ M0_INTERNAL int m0_fom_fol_rec_add(struct m0_fom *fom)
 }
 
 /** @} endgroup fom */
+#undef FOM_RATE_KEY
 /*
  *  Local variables:
  *  c-indentation-style: "K&R"
diff --git a/fop/fom.h b/fop/fom.h
index 4bd5fc9..a422ee3 100644
--- a/fop/fom.h
+++ b/fop/fom.h
@@ -210,6 +210,7 @@ Doc?docid=0AQaCw6YRYSVSZGZmMzV6NzJfMTNkOGNjZmdnYg
 #include "dtm/dtm.h"           /* m0_dtx */
 #include "stob/stob.h"
 #include "reqh/reqh_service.h"
+#include "addb/addb_monitor.h"
 
 /* export */
 struct m0_fom_domain;
@@ -296,6 +297,11 @@ struct m0_fom_locality {
 	 */
 	struct m0_addb_counter       fl_stat_sched_wait_times;
 
+	/** FOP rate counter. It is fop executed per sec. */
+	uint64_t                     fl_fop_rate_count;
+	m0_time_t		     fl_fop_rate_next_update;
+	struct m0_addb_counter       fl_stat_fop_rate;
+
 	/** AST which triggers the posting of statistics */
 	struct m0_sm_ast             fl_post_stats_ast;
 
@@ -334,6 +340,10 @@ struct m0_fom_domain {
 	struct m0_reqh			*fd_reqh;
 	/** Addb context for fom */
 	struct m0_addb_ctx               fd_addb_ctx;
+	/** fop rate monitor key */
+	uint32_t			 fd_fop_rate_monitor_key;
+	/** fop rate monitor */
+	struct m0_addb_monitor           fd_fop_rate_monitor;
 };
 
 /** Operations vector attached to a domain. */
diff --git a/fop/fop.c b/fop/fop.c
index b830ed5..ac9cc41 100644
--- a/fop/fop.c
+++ b/fop/fop.c
@@ -34,6 +34,7 @@
 #include "fop/fop.h"
 #include "fop/fop_xc.h"
 #include "fop/fom_long_lock.h" /* m0_fom_ll_global_init */
+#include "addb/addb_monitor.h" /* stats register */
 
 /**
    @addtogroup fop
@@ -256,6 +257,8 @@ M0_INTERNAL int m0_fops_init(void)
 	m0_addb_rec_type_register(&m0_addb_rt_fl_sched_wait_times);
 	m0_addb_rec_type_register(&m0_addb_rt_fl_runq_nr);
 	m0_addb_rec_type_register(&m0_addb_rt_fl_wail_nr);
+	m0_addb_rec_type_register(&m0_addb_rt_fop_rate_cntr);
+        M0_ADDB_MONITOR_STATS_TYPE_REGISTER(&m0_addb_rt_fop_rate, "fop_rate");
 	M0_ADDB_CTX_INIT(&m0_addb_gmc, &m0_fop_addb_ctx, &m0_addb_ct_fop_mod,
 			 &m0_addb_proc_ctx);
 	ft_tlist_init(&fop_types_list);
diff --git a/fop/fop_addb.h b/fop/fop_addb.h
index c1b5a19..c0028ce 100644
--- a/fop/fop_addb.h
+++ b/fop/fop_addb.h
@@ -68,7 +68,8 @@ M0_ALLOC_ARR_ADDB(ptr, nr, &m0_addb_gmc, M0_FOP_ADDB_LOC_##loc, ctx)
  */
 enum {
 	M0_FOP_ADDB_LOC_LOC_THR_CREATE    = 10,
-	M0_FOP_ADDB_LOC_FOM_DOMAIN_INIT   = 20
+	M0_FOP_ADDB_LOC_FOM_DOMAIN_INIT   = 20,
+	M0_FOP_ADDB_LOC_FOM_RATE_MON_INIT = 30,
 };
 
 extern struct m0_addb_ctx m0_fop_addb_ctx;
@@ -85,13 +86,15 @@ extern struct m0_addb_ctx m0_fop_addb_ctx;
  * Do not change the numbering.
  */
 enum {
-	M0_ADDB_RECID_FOM_INIT = 60,
-	M0_ADDB_RECID_FOM_FINI = 61,
-	M0_ADDB_RECID_FOM_STATE_STATS = 62,
-	M0_ADDB_RECID_FL_RUN_TIMES = 65,
+	M0_ADDB_RECID_FOM_INIT            = 60,
+	M0_ADDB_RECID_FOM_FINI            = 61,
+	M0_ADDB_RECID_FOM_STATE_STATS     = 62,
+	M0_ADDB_RECID_FL_RUN_TIMES        = 65,
 	M0_ADDB_RECID_FL_SCHED_WAIT_TIMES = 66,
-	M0_ADDB_RECID_FL_RUNQ_NR = 67,
-	M0_ADDB_RECID_FL_WAIL_NR = 68,
+	M0_ADDB_RECID_FL_RUNQ_NR          = 67,
+	M0_ADDB_RECID_FL_WAIL_NR          = 68,
+	M0_ADDB_RECID_FOP_RATE_CNTR       = 69,
+	M0_ADDB_RECID_FOP_RATE            = 70,
 };
 
 /**
@@ -132,11 +135,15 @@ M0_ADDB_RT_CNTR(m0_addb_rt_fl_run_times, M0_ADDB_RECID_FL_RUN_TIMES);
 /** Accumulated scheduling overhead of all locality foms (in binary usec). */
 M0_ADDB_RT_CNTR(m0_addb_rt_fl_sched_wait_times,
 		M0_ADDB_RECID_FL_SCHED_WAIT_TIMES);
+/** FOP rate (number of fop executed per sec) **/
+M0_ADDB_RT_CNTR(m0_addb_rt_fop_rate_cntr, M0_ADDB_RECID_FOP_RATE_CNTR);
 
 /** Locality run queue length */
 M0_ADDB_RT_DP(m0_addb_rt_fl_runq_nr, M0_ADDB_RECID_FL_RUNQ_NR, "runq_nr");
 /** Locality wait queue (list) length */
 M0_ADDB_RT_DP(m0_addb_rt_fl_wail_nr, M0_ADDB_RECID_FL_WAIL_NR, "wail_nr");
+/** ADDB summary record for fop rate stats */
+M0_ADDB_RT_STATS(m0_addb_rt_fop_rate, M0_ADDB_RECID_FOP_RATE, "fop_rate");
 
 /** @} end of fom group */
 
diff --git a/m0t1fs/linux_kernel/file.c b/m0t1fs/linux_kernel/file.c
index 060a323..69789bd 100644
--- a/m0t1fs/linux_kernel/file.c
+++ b/m0t1fs/linux_kernel/file.c
@@ -4239,7 +4239,7 @@ last:
 			       1000); /* uS */
 	m0_addb_counter_update(&stats->ais_sizes_cntr, (uint64_t) count);
 	M0_ADDB_POST(&m0_addb_gmc, &m0_addb_rt_m0t1fs_io_finish,
-		     M0_ADDB_CTX_VEC(&m0t1fs_addb_ctx), count, time_io);
+		     M0_ADDB_CTX_VEC(&m0t1fs_addb_ctx), rw, count, time_io);
 	m0t1fs_addb_stat_post_counters(csb);
 
 	M0_LEAVE();
diff --git a/m0t1fs/linux_kernel/file_internal.h b/m0t1fs/linux_kernel/file_internal.h
index 26ce0a0..f37313f 100644
--- a/m0t1fs/linux_kernel/file_internal.h
+++ b/m0t1fs/linux_kernel/file_internal.h
@@ -1229,12 +1229,6 @@ enum io_req_state {
 	IRS_FAILED,
 };
 
-/** Represents type of IO request. */
-enum io_req_type {
-        IRT_READ,
-        IRT_WRITE,
-        IRT_TYPE_NR,
-};
 
 /** Operation vector for struct io_request. */
 struct io_request_ops {
diff --git a/m0t1fs/linux_kernel/m0t1fs.c b/m0t1fs/linux_kernel/m0t1fs.c
index 48f2c09..75f0ea7 100644
--- a/m0t1fs/linux_kernel/m0t1fs.c
+++ b/m0t1fs/linux_kernel/m0t1fs.c
@@ -58,6 +58,9 @@ static void m0t1fs_net_fini(void);
 static int  m0t1fs_rpc_init(void);
 static void m0t1fs_rpc_fini(void);
 
+static int  m0t1fs_addb_mon_total_io_size_init(void);
+static void m0t1fs_addb_mon_total_io_size_fini(void);
+
 static int  m0t1fs_layout_init(void);
 static void m0t1fs_layout_fini(void);
 
@@ -113,6 +116,9 @@ M0_INTERNAL int m0t1fs_init(void)
 	RT_REG(dgiow_times);
 #undef RT_REG
 
+	M0_ADDB_MONITOR_STATS_TYPE_REGISTER(&m0_addb_rt_m0t1fs_mon_io_size,
+					    "io_size");
+
 	m0t1fs_globals.g_laddr = local_addr;
 
         rc = m0_fid_init();
@@ -139,10 +145,14 @@ M0_INTERNAL int m0t1fs_init(void)
 	if (rc != 0)
 		goto net_fini;
 
-	rc = m0t1fs_layout_init();
+	rc = m0t1fs_addb_mon_total_io_size_init();
 	if (rc != 0)
 		goto rpc_fini;
 
+	rc = m0t1fs_layout_init();
+	if (rc != 0)
+		goto addb_mon_fini;
+
 	rc = register_filesystem(&m0t1fs_fs_type);
 	if (rc != 0)
 		goto layout_fini;
@@ -152,7 +162,8 @@ M0_INTERNAL int m0t1fs_init(void)
 
 layout_fini:
 	m0t1fs_layout_fini();
-
+addb_mon_fini:
+	m0t1fs_addb_mon_total_io_size_fini();
 rpc_fini:
 	m0t1fs_rpc_fini();
 net_fini:
@@ -256,11 +267,11 @@ static int m0t1fs_rpc_init(void)
 		goto pool_fini;
 
 	rc = M0_REQH_INIT(reqh,
-			  .rhia_dtm       = (void*)1,
-			  .rhia_db        = NULL,
-			  .rhia_mdstore   = (void*)1,
-			  .rhia_fol       = fol,
-			  .rhia_svc       = (void*)1);
+			  .rhia_dtm          = (void*)1,
+			  .rhia_db           = NULL,
+			  .rhia_mdstore      = (void*)1,
+			  .rhia_fol          = fol,
+			  .rhia_svc          = (void*)1);
 	if (rc != 0)
 		goto dbenv_fini;
 	rc = m0_rpc_machine_init(rpc_machine, ndom, laddr, reqh,
@@ -280,7 +291,6 @@ static int m0t1fs_rpc_init(void)
 	rc = m0t1fs_reqh_services_start();
 	if (rc != 0)
 		goto reqh_fini;
-
 	M0_RETURN(0);
 
 reqh_fini:
@@ -294,6 +304,102 @@ pool_fini:
 	return rc;
 }
 
+static void m0t1fs_mon_rw_io_watch(const struct m0_addb_monitor *mon,
+				   const struct m0_addb_rec     *rec,
+				   struct m0_reqh               *reqh)
+{
+	struct m0_addb_sum_rec                  *sum_rec;
+	struct m0t1fs_addb_mon_sum_data_io_size *sum_data =
+				&m0t1fs_globals.g_addb_mon_sum_data_rw_io_size;
+
+	if (m0_addb_rec_rid_make(M0_ADDB_BRT_DP, M0T1FS_ADDB_RECID_IO_FINISH)
+	    == rec->ar_rid) {
+		sum_rec = mon->am_ops->amo_sum_rec(mon, reqh);
+		M0_ASSERT(sum_rec != NULL);
+
+		m0_mutex_lock(&sum_rec->asr_mutex);
+		if (rec->ar_data.au64s_data[0] == IRT_READ) {
+			sum_data->sd_rio += rec->ar_data.au64s_data[1];
+			sum_rec->asr_dirty = true;
+		} else if (rec->ar_data.au64s_data[0] == IRT_WRITE) {
+			sum_data->sd_wio += rec->ar_data.au64s_data[1];
+			sum_rec->asr_dirty = true;
+		}
+		else
+			M0_IMPOSSIBLE("Invalid IO state");
+		m0_mutex_unlock(&sum_rec->asr_mutex);
+
+	}
+}
+
+static struct m0_addb_sum_rec *
+m0t1fs_mon_rw_io_sum_rec(const struct m0_addb_monitor *mon,
+		         struct m0_reqh               *reqh)
+{
+	struct m0_addb_sum_rec *sum_rec;
+
+	m0_rwlock_read_lock(&reqh->rh_rwlock);
+	sum_rec = m0_reqh_lockers_get(reqh,
+			m0t1fs_globals.g_addb_mon_rw_io_size_key);
+	m0_rwlock_read_unlock(&reqh->rh_rwlock);
+
+	return sum_rec;
+}
+
+const struct m0_addb_monitor_ops m0t1fs_addb_mon_rw_io_ops = {
+	.amo_watch   = m0t1fs_mon_rw_io_watch,
+	.amo_sum_rec = m0t1fs_mon_rw_io_sum_rec
+};
+
+static int m0t1fs_addb_mon_total_io_size_init(void)
+{
+	struct m0_addb_sum_rec *sum_rec;
+	struct m0_reqh         *reqh = &m0t1fs_globals.g_reqh;
+	uint32_t               *key = &m0t1fs_globals.g_addb_mon_rw_io_size_key;
+	uint64_t               *sum_data =
+		     (uint64_t *)&m0t1fs_globals.g_addb_mon_sum_data_rw_io_size;
+	uint32_t                sum_rec_nr =
+		     sizeof (m0t1fs_globals.g_addb_mon_sum_data_rw_io_size) /
+					     sizeof (uint64_t);
+	M0_ALLOC_PTR(sum_rec);
+	if (sum_rec == NULL)
+		M0_RETURN(-ENOMEM);
+
+	m0_addb_monitor_init(&m0t1fs_globals.g_addb_mon_rw_io_size,
+			     &m0t1fs_addb_mon_rw_io_ops);
+
+	m0_addb_monitor_sum_rec_init(sum_rec, &m0_addb_rt_m0t1fs_mon_io_size,
+				     sum_data, sum_rec_nr);
+
+	*key = m0_reqh_lockers_allot();
+
+	m0_rwlock_write_lock(&reqh->rh_rwlock);
+	m0_reqh_lockers_set(reqh, *key, sum_rec);
+	m0_rwlock_write_unlock(&reqh->rh_rwlock);
+
+	m0_addb_monitor_add(reqh, &m0t1fs_globals.g_addb_mon_rw_io_size);
+
+	return 0;
+}
+
+static void m0t1fs_addb_mon_total_io_size_fini(void)
+{
+	struct m0_addb_sum_rec *sum_rec;
+	struct m0_addb_monitor *mon = &m0t1fs_globals.g_addb_mon_rw_io_size;
+	struct m0_reqh         *reqh = &m0t1fs_globals.g_reqh;
+
+	sum_rec = mon->am_ops->amo_sum_rec(mon, &m0t1fs_globals.g_reqh);
+
+	m0_addb_monitor_del(reqh, mon);
+
+	m0_rwlock_write_lock(&reqh->rh_rwlock);
+	m0_reqh_lockers_clear(reqh, m0t1fs_globals.g_addb_mon_rw_io_size_key);
+	m0_rwlock_write_unlock(&reqh->rh_rwlock);
+	m0_addb_monitor_sum_rec_fini(sum_rec);
+	m0_free(sum_rec);
+	m0_addb_monitor_fini(mon);
+}
+
 static void m0t1fs_rpc_fini(void)
 {
 	M0_ENTRY();
@@ -359,7 +465,18 @@ static int m0t1fs_service_start(const char *sname)
 
 static int m0t1fs_reqh_services_start(void)
 {
-	return m0t1fs_service_start("rmservice");
+	int rc;
+
+	rc = m0t1fs_service_start(M0_ADDB_SVC_NAME);
+	if (rc)
+		goto err;
+	rc = m0t1fs_service_start("rmservice");
+	if (rc)
+		goto err;
+	M0_RETURN(rc);
+err:
+	m0t1fs_reqh_services_stop();
+	M0_RETURN(rc);
 }
 
 static void m0t1fs_reqh_services_stop(void)
diff --git a/m0t1fs/linux_kernel/m0t1fs.h b/m0t1fs/linux_kernel/m0t1fs.h
index 4a93a47..cdbfeb5 100644
--- a/m0t1fs/linux_kernel/m0t1fs.h
+++ b/m0t1fs/linux_kernel/m0t1fs.h
@@ -408,20 +408,35 @@ enum {
 	M0T1FS_COB_ID_STRLEN            = 34,
 };
 
+struct m0t1fs_addb_mon_sum_data_io_size {
+	uint64_t sd_rio;
+	uint64_t sd_wio;
+};
+
+/** Represents type of IO request. */
+enum io_req_type {
+        IRT_READ,
+        IRT_WRITE,
+        IRT_TYPE_NR,
+};
+
 /** Anything that is global to m0t1fs module goes in this singleton structure.
     There is only one, global, instance of this type. */
 struct m0t1fs_globals {
-	struct m0_net_xprt       *g_xprt;
+	struct m0_net_xprt                     *g_xprt;
 	/** local endpoint address module parameter */
-	const char               *g_laddr;
-	char                     *g_db_name;
-	struct m0_net_domain      g_ndom;
-	struct m0_rpc_machine     g_rpc_machine;
-	struct m0_reqh            g_reqh;
-	struct m0_dbenv           g_dbenv;
-	struct m0_fol             g_fol;
-	struct m0_net_buffer_pool g_buffer_pool;
-	struct m0_layout_domain   g_layout_dom;
+	const char                             *g_laddr;
+	char                                   *g_db_name;
+	struct m0_net_domain                    g_ndom;
+	struct m0_rpc_machine                   g_rpc_machine;
+	struct m0_reqh                          g_reqh;
+	struct m0_dbenv                         g_dbenv;
+	struct m0_fol                           g_fol;
+	struct m0_net_buffer_pool               g_buffer_pool;
+	struct m0_layout_domain                 g_layout_dom;
+	struct m0_addb_monitor                  g_addb_mon_rw_io_size;
+	uint32_t                                g_addb_mon_rw_io_size_key;
+	struct m0t1fs_addb_mon_sum_data_io_size g_addb_mon_sum_data_rw_io_size;
 };
 
 extern struct m0t1fs_globals m0t1fs_globals;
diff --git a/m0t1fs/linux_kernel/st/m0t1fs_common_inc.sh b/m0t1fs/linux_kernel/st/m0t1fs_common_inc.sh
index a68070a..f15acb3 100644
--- a/m0t1fs/linux_kernel/st/m0t1fs_common_inc.sh
+++ b/m0t1fs/linux_kernel/st/m0t1fs_common_inc.sh
@@ -38,6 +38,7 @@ MERO_IOSERVICE_NAME=ioservice
 MERO_MDSERVICE_NAME=mdservice
 MERO_SNSREPAIRSERVICE_NAME=sns_repair
 MERO_SNSREBALANCESERVICE_NAME=sns_rebalance
+MERO_STATSSERVICE_NAME=stats
 MERO_RMSERVICE_NAME=rmservice
 MERO_STOB_DOMAIN=linux
 
diff --git a/m0t1fs/linux_kernel/st/m0t1fs_server_inc.sh b/m0t1fs/linux_kernel/st/m0t1fs_server_inc.sh
index 9d8f1be..6e177b1 100644
--- a/m0t1fs/linux_kernel/st/m0t1fs_server_inc.sh
+++ b/m0t1fs/linux_kernel/st/m0t1fs_server_inc.sh
@@ -25,7 +25,7 @@ mero_service()
 		for ((i=0; i < ${#EP[*]}; i++)) ; do
 			SNAME="-s $MERO_ADDBSERVICE_NAME"
 			if ((i == 0)); then
-				SNAME="-s $MERO_MDSERVICE_NAME -s $MERO_RMSERVICE_NAME $SNAME"
+				SNAME="-s $MERO_MDSERVICE_NAME -s $MERO_RMSERVICE_NAME $SNAME -s $MERO_STATSSERVICE_NAME"
 			else
 				SNAME="-s $MERO_IOSERVICE_NAME -s $MERO_SNSREPAIRSERVICE_NAME \
 				      -s $MERO_SNSREBALANCESERVICE_NAME $SNAME"
diff --git a/m0t1fs/linux_kernel/super.c b/m0t1fs/linux_kernel/super.c
index 581f087..cf016ca 100644
--- a/m0t1fs/linux_kernel/super.c
+++ b/m0t1fs/linux_kernel/super.c
@@ -36,6 +36,7 @@
 #include "conf/confc.h"    /* m0_confc */
 #include "rpc/rpclib.h"    /* m0_rcp_client_connect */
 #include "addb/addb.h"
+#include "rpc/rpc_internal.h"
 
 static int m0t1fs_layout_build(const uint64_t         layout_id,
 			       const uint32_t         N,
@@ -550,8 +551,8 @@ static int connect_to_services(struct m0t1fs_sb *csb, struct m0_conf_obj *fs,
 	struct m0_conf_obj *entry;
 	const char        **pstr;
 	int                 rc;
-	bool                mds_is_provided = false;
-	bool                dlm_is_provided = false;
+	bool                mds_is_provided       = false;
+	bool                dlm_is_provided       = false;
 
 	M0_ENTRY();
 	M0_PRE(svc_ctx_tlist_is_empty(&csb->csb_service_contexts));
@@ -603,6 +604,7 @@ static int configure_addb_rpc_sink(struct m0_addb_mc *addb_mc)
 	if (!m0_addb_mc_has_rpc_sink(addb_mc)) {
 		int rc = m0_addb_mc_configure_rpc_sink(addb_mc,
 						&m0t1fs_globals.g_rpc_machine,
+						&m0t1fs_globals.g_reqh,
 						M0_ADDB_RPCSINK_TS_INIT_PAGES,
 						M0_ADDB_RPCSINK_TS_MAX_PAGES,
 						M0_ADDB_RPCSINK_TS_PAGE_SIZE);
@@ -780,6 +782,9 @@ static int cl_map_build(struct m0t1fs_sb *csb, uint32_t nr_ios,
 		case M0_CST_MGS:
 			break;
 
+		case M0_CST_SS:
+			break;
+
 		case M0_CST_DLM:
 			map->clm_map[csb->csb_nr_containers] = ctx;
 			break;
@@ -946,11 +951,15 @@ static void m0t1fs_sb_layout_fini(struct m0t1fs_sb *csb)
 
 static int m0t1fs_setup(struct m0t1fs_sb *csb, const struct mount_opts *mops)
 {
-	struct m0_confc     confc;
-	struct m0_conf_obj *fs;
-	uint32_t            nr_ios;
-	int                 rc;
-	struct fs_params    fs_params = {0};
+	struct m0t1fs_service_context *ctx;
+	struct m0_confc                confc;
+	struct m0_conf_obj            *fs;
+	struct m0_reqh                *reqh = &m0t1fs_globals.g_reqh;
+	const char                    *ep_addr;
+	uint32_t                       nr_ios = 0;
+	int                            rc;
+	struct fs_params               fs_params = {0};
+	bool                           stats_svc_is_provided = false;
 
 	M0_ENTRY();
 	M0_PRE(csb->csb_astthread.t_state == TS_RUNNING);
@@ -971,6 +980,19 @@ static int m0t1fs_setup(struct m0t1fs_sb *csb, const struct mount_opts *mops)
 	rc = fs_params_parse(&fs_params,
 			     M0_CONF_CAST(fs, m0_conf_filesystem)->cf_params) ?:
 		connect_to_services(csb, fs, &nr_ios);
+
+	m0_tl_for(svc_ctx, &csb->csb_service_contexts, ctx) {
+		if (ctx->sc_type == M0_CST_SS) {
+			stats_svc_is_provided = true;
+			break;
+		}
+	} m0_tlist_endfor;
+	if (stats_svc_is_provided) {
+		ep_addr = ctx->sc_conn.c_rpcchan->rc_destep->nep_addr;
+		m0_addb_monitor_setup(reqh, &ctx->sc_conn, ep_addr);
+		M0_LOG(M0_DEBUG, "Stats service connected");
+	} else
+		M0_LOG(M0_WARN, "Stats service not connected");
 	m0_confc_close(fs);
 	if (rc != 0)
 		goto end;
diff --git a/m0t1fs/m0t1fs_addb.h b/m0t1fs/m0t1fs_addb.h
index 5afc877..66e9a1f 100644
--- a/m0t1fs/m0t1fs_addb.h
+++ b/m0t1fs/m0t1fs_addb.h
@@ -23,6 +23,11 @@
 #define __MERO_M0T1FS_M0T1FS_ADDB_H__
 
 #include "addb/addb.h"
+#include "addb/addb_monitor.h"
+#ifdef __KERNEL__
+#include "fop/fom_simple.h"
+#endif
+
 /*
  ******************************************************************************
  * Kernel client ADDB context types.
@@ -99,17 +104,22 @@ enum {
 	M0T1FS_ADDB_RECID_DGIOW_SIZES           = 508,
 	M0T1FS_ADDB_RECID_DGIOR_TIMES           = 509,
 	M0T1FS_ADDB_RECID_DGIOW_TIMES           = 510,
+	M0T1FS_ADDB_RECID_MON_IO_SIZE           = 511,
 };
 
 /* Total time required and size for IO */
 M0_ADDB_RT_DP(m0_addb_rt_m0t1fs_io_finish, M0T1FS_ADDB_RECID_IO_FINISH,
-	      "io_size" /* in bytes */, "time_ns");
+	      "rw", "io_size" /* in bytes */, "time_ns");
 
 /* Time required and io size for each COB FID */
 M0_ADDB_RT_DP(m0_addb_rt_m0t1fs_cob_io_finish, M0T1FS_ADDB_RECID_COB_IO_FINISH,
 	      "cob_container", "cob_key",
 	      "io_size" /* in bytes (data + parity) */, "time_ns");
 
+/* Number of bytes read, written from this client instance (m0t1fs) */
+M0_ADDB_RT_STATS(m0_addb_rt_m0t1fs_mon_io_size, M0T1FS_ADDB_RECID_MON_IO_SIZE,
+	      "total_rio_size", "total_wio_size");
+
 /* m0t1fs root cob */
 M0_ADDB_RT_DP(m0_addb_rt_m0t1fs_root_cob, M0T1FS_ADDB_RECID_ROOT_COB,
 	      "cob_container", "cob_key");
@@ -147,6 +157,31 @@ M0_ADDB_RT_CNTR(m0_addb_rt_m0t1fs_dgiow_times,  M0T1FS_ADDB_RECID_DGIOW_TIMES,
 		uS(250), uS(500), uS(750), mS(1), mS(10), mS(50),
 		mS(100), mS(250), mS(500));
 
+#ifdef __KERNEL__
+struct m0t1fs_addb_monitor_pfom {
+	/** Periodicity of the ADDB summary stats post */
+	m0_time_t             pf_period;
+	/** Next post time */
+	m0_time_t             pf_next_post;
+	/** Shutdown/unmount request flag */
+	bool                  pf_shutdown;
+	/** The FOM timer */
+	struct m0_fom_timeout pf_timeout;
+	/** Simple FOM */
+	struct m0_fom_simple  pf_fom;
+};
+
+enum m0t1fs_addb_monitor_pfom_phase {
+	M0T1FS_PFOM_PHASE_CTO = M0_FOM_PHASE_NR,
+	M0T1FS_PFOM_PHASE_SLEEP,
+	M0T1FS_PFOM_PHASE_POST,
+};
+
+enum {
+	M0T1FS_PFOM_RET_SHUTDOWN = -1,
+};
+#endif /* __KERNEL__ */
+
 #endif /* __MERO_M0T1FS_M0T1FS_ADDB_H__ */
 
 /*
diff --git a/mero/conf.c b/mero/conf.c
index 6332d49..cf0d1dd 100644
--- a/mero/conf.c
+++ b/mero/conf.c
@@ -61,7 +61,8 @@ static const char *service_name[] = {
 	[M0_CST_MDS] = "mdservice",  /* Meta-data service. */
 	[M0_CST_IOS] = "ioservice",  /* IO/data service. */
 	[M0_CST_MGS] = "confd",      /* Management service (confd). */
-	[M0_CST_DLM] = "dlm"         /* DLM service. */
+	[M0_CST_DLM] = "dlm",        /* DLM service. */
+	[M0_CST_SS]  = "stats"       /* Stats service */
 };
 
 static char *service_name_dup(const struct m0_conf_service *svc)
diff --git a/mero/init.c b/mero/init.c
index 010d1e5..a33919b 100644
--- a/mero/init.c
+++ b/mero/init.c
@@ -73,6 +73,7 @@
 #include "sns/parity_ops.h"
 #include "cm/cm.h"
 #include "addb/addb_fops.h"
+#include "stats/stats_fops.h"
 #include "mgmt/mgmt.h"
 #include "ha/epoch.h"
 
@@ -142,11 +143,12 @@ struct init_fini_call subsystem[] = {
 	{ &m0_linux_stobs_init, &m0_linux_stobs_fini, "linux-stob" },
 	{ &m0_ad_stobs_init,    &m0_ad_stobs_fini,    "ad-stob" },
 	{ &sim_global_init,     &sim_global_fini,     "desim" },
-	{ &m0_addb_svc_mod_init, &m0_addb_svc_mod_fini, "addbsvc" },
 #endif
+	{ &m0_addb_svc_mod_init, &m0_addb_svc_mod_fini, "addbsvc" },
 	{ &m0_confx_types_init, &m0_confx_types_fini, "conf-xtypes" },
 	{ &m0_conf_fops_init,   &m0_conf_fops_fini,   "conf-fops" },
 	{ &m0_addb_service_fop_init, &m0_addb_service_fop_fini, "addb_fops" },
+	{ &m0_stats_fops_init,  &m0_stats_fops_fini,   "stats_fops"},
 	{ &m0_rms_register,     &m0_rms_unregister,   "rmservice"},
 #ifdef __KERNEL__
 	{ &m0t1fs_init,         &m0t1fs_fini,         "m0t1fs" },
diff --git a/mero/magic.h b/mero/magic.h
index 0790272..dfc8621 100644
--- a/mero/magic.h
+++ b/mero/magic.h
@@ -114,6 +114,15 @@ enum m0_magic_satchel {
 	/* rpcsink item source list head (addb safe sloe) */
 	M0_ADDB_RPCSINK_IS_HEAD_MAGIC =0x33addb5afe510e77,
 
+	/* ADDB monitor list's head (addb hellhole) */
+	M0_ADDB_MONITOR_LIST_HEAD_MAGIC = 0x33addb3704773477,
+
+	/* ADDB monitor (addb shoebill) */
+	M0_ADDB_MONITOR_LIST_LINK_MAGIC = 0x33addb7719304577,
+
+	/* m0_addb_monitoring_ctx::amc_magic (basils basils) */
+	M0_ADDB_MONITOR_CTX_MAGIC = 0x33ba5115ba511577,
+
 /* balloc */
 	/* m0_balloc_super_block::bsb_magic (blessed baloc) */
 	M0_BALLOC_SB_MAGIC = 0x33b1e55edba10c77,
diff --git a/mero/setup.c b/mero/setup.c
index bfe5088..7f20ed9 100644
--- a/mero/setup.c
+++ b/mero/setup.c
@@ -49,6 +49,7 @@
 #include "mero/version.h"
 #include "rpc/rpclib.h"
 #include "rpc/rpc_internal.h"
+#include "addb/addb_monitor.h"
 
 /**
    @addtogroup m0d
@@ -589,6 +590,25 @@ static int cs_rpc_machines_init(struct m0_mero *cctx)
 	return rc;
 }
 
+static void cs_addb_monitor_stats_svc_conn_init(struct m0_mero *cctx)
+{
+	int                          rc = 0;
+	struct m0_reqh_context      *rctx;
+
+	M0_PRE(cctx != NULL);
+
+	m0_tl_for(rhctx, &cctx->cc_reqh_ctxs, rctx) {
+		M0_ASSERT(m0_reqh_context_invariant(rctx));
+		rc = m0_addb_monitor_stats_svc_conn_init(&rctx->rc_reqh);
+		if (rc != 0) {
+			/* @todo: LOG ADDB msg */
+			rc = 0;
+			break;
+		}
+
+	} m0_tl_endfor;
+}
+
 /**
    Finalises all the rpc machines from the list of rpc machines present in
    m0_reqh.
@@ -611,8 +631,8 @@ static void cs_rpc_machines_fini(struct m0_reqh *reqh)
 	} m0_tl_endfor;
 }
 
-static uint32_t cs_domain_tms_nr(struct m0_mero *cctx,
-				struct m0_net_domain *dom)
+static uint32_t cs_domain_tms_nr(struct m0_mero       *cctx,
+				 struct m0_net_domain *dom)
 {
 	struct m0_reqh_context      *rctx;
 	struct cs_endpoint_and_xprt *ep;
@@ -1334,8 +1354,6 @@ static int cs_request_handler_start(struct m0_reqh_context *rctx)
 {
 	int rc;
 
-	M0_ENTRY();
-
 	/** @todo Pass in a parent ADDB context for the db. Ideally should
 	    be same parent as that of the reqh.
 	    But, we'd also want the db to use the same addb m/c as the reqh.
@@ -1481,6 +1499,9 @@ static void cs_request_handler_stop(struct m0_reqh_context *rctx)
 
 	M0_ENTRY();
 
+	if (reqh->rh_addb_monitoring_ctx.amc_stats_conn != NULL)
+		m0_addb_monitor_stats_svc_conn_fini(reqh);
+
 	if (m0_reqh_state_get(reqh) == M0_REQH_ST_NORMAL)
 		m0_reqh_shutdown(reqh);
 	m0_reqh_fom_domain_idle_wait(reqh);
@@ -1678,6 +1699,7 @@ static void cs_help(FILE *out)
 "  -f path  Path to genders file, defaults to /etc/mero/genders.\n"
 "  -g       Bootstrap configuration using genders.\n"
 "  -Z       Run as a daemon.\n"
+"  -R addr  Stats service endpoint address \n"
 "\n"
 "Request handler options:\n"
 "  -r   Start new set of request handler options.\n"
@@ -1949,6 +1971,13 @@ static int _args_parse(struct m0_mero *cctx, int argc, char **argv,
 								    cc_mds_epx,
 								    s);
 				})),
+			M0_STRINGARG('R', "stats service endpoint address",
+				LAMBDA(void, (const char *s)
+				{
+					rc = m0_ep_and_xprt_extract(&cctx->
+								 cc_stats_svc_epx,
+								 s);
+				})),
 			M0_STRINGARG('i', "ioservice endpoints list",
 				LAMBDA(void, (const char *s)
 				{
@@ -2164,9 +2193,21 @@ int m0_cs_setup_env(struct m0_mero *cctx, int argc, char **argv)
 
 int m0_cs_start(struct m0_mero *cctx)
 {
+	int rc;
+
 	M0_ENTRY();
 	M0_PRE(cctx != NULL);
-	M0_RETURN(cs_services_init(cctx));
+	rc = cs_services_init(cctx);
+	/**
+	 * @todo: stats connection initialization should be done
+	 * in addb pfom, currently not being done due to some initialization
+	 * ordering issues.
+	 * RB link :- http://reviewboard.clusterstor.com/r/1544
+	 */
+	if (cctx->cc_stats_svc_epx.ex_endpoint != NULL)
+		cs_addb_monitor_stats_svc_conn_init(cctx);
+
+	return rc;
 }
 
 int m0_cs_init(struct m0_mero *cctx, struct m0_net_xprt **xprts,
diff --git a/mero/setup.h b/mero/setup.h
index 691b660..d91129a 100644
--- a/mero/setup.h
+++ b/mero/setup.h
@@ -254,6 +254,9 @@ struct m0_mero {
 	/** mdservice endpoint */
 	struct cs_endpoint_and_xprt cc_mds_epx;
 
+	/** stats service endpoint */
+	struct cs_endpoint_and_xprt cc_stats_svc_epx;
+
 	/** list of ioservice end points */
 	struct m0_tl                cc_ios_eps;
 
diff --git a/reqh/reqh.c b/reqh/reqh.c
index 47ce7ce..52a6217 100644
--- a/reqh/reqh.c
+++ b/reqh/reqh.c
@@ -72,6 +72,8 @@ M0_TL_DEFINE(m0_reqh_rpc_mach, , struct m0_rpc_machine);
 
 M0_LOCKERS_DEFINE(M0_INTERNAL, m0_reqh, rh_lockers);
 
+static void __reqh_fini(struct m0_reqh *reqh);
+
 /**
    Request handler state machine description
  */
@@ -160,24 +162,41 @@ m0_reqh_init(struct m0_reqh *reqh, const struct m0_reqh_init_args *reqh_args)
 	M0_ADDB_CTX_INIT(&m0_addb_gmc, &reqh->rh_addb_ctx,
 			 &m0_addb_ct_reqh_mod, &m0_addb_proc_ctx);
 
+	m0_rwlock_init(&reqh->rh_rwlock);
+	m0_reqh_lockers_init(reqh);
+
+	rc = m0_addb_monitors_init(reqh);
+	if (rc != 0)
+		goto monitors_init_failed;
+
 	reqh->rh_fom_dom.fd_reqh = reqh;
 	rc = m0_fom_domain_init(&reqh->rh_fom_dom);
 	if (rc != 0)
-		return rc;
+		goto fom_domain_init_failed;
 
 	m0_reqh_svc_tlist_init(&reqh->rh_services);
 	m0_reqh_rpc_mach_tlist_init(&reqh->rh_rpc_machines);
 	m0_sm_group_init(&reqh->rh_sm_grp);
 	m0_mutex_init(&reqh->rh_mutex); /* deprecated */
 	m0_chan_init(&reqh->rh_sd_signal, &reqh->rh_mutex); /* deprecated */
-	m0_rwlock_init(&reqh->rh_rwlock);
 	m0_sm_init(&reqh->rh_sm, &m0_reqh_sm_conf, M0_REQH_ST_INIT,
 		   &reqh->rh_sm_grp);
-	m0_reqh_lockers_init(reqh);
 
-	if (reqh->rh_beseg != NULL)
+	if (reqh->rh_beseg != NULL) {
 		rc = m0_reqh_dbenv_init(reqh, reqh->rh_beseg);
+		if (rc != 0)
+			__reqh_fini(reqh);
+	}
+	return rc;
 
+fom_domain_init_failed:
+	m0_addb_monitors_fini(reqh);
+monitors_init_failed:
+	m0_rwlock_fini(&reqh->rh_rwlock);
+	m0_reqh_lockers_fini(reqh);
+	m0_addb_ctx_fini(&reqh->rh_addb_ctx);
+	m0_addb_mc_fini(&reqh->rh_addb_mc);
+	m0_ha_domain_fini(&reqh->rh_hadom);
 	return rc;
 }
 
@@ -350,9 +369,8 @@ M0_INTERNAL void m0_reqh_dbenv_fini(struct m0_reqh *reqh)
 	m0_addb_mc_unconfigure(&reqh->rh_addb_mc);
 }
 
-M0_INTERNAL void m0_reqh_fini(struct m0_reqh *reqh)
+static void __reqh_fini(struct m0_reqh *reqh)
 {
-	m0_reqh_dbenv_fini(reqh);
 	m0_sm_group_lock(&reqh->rh_sm_grp);
 	m0_sm_fini(&reqh->rh_sm);
 	m0_sm_group_unlock(&reqh->rh_sm_grp);
@@ -360,6 +378,7 @@ M0_INTERNAL void m0_reqh_fini(struct m0_reqh *reqh)
 	m0_addb_ctx_fini(&reqh->rh_addb_ctx);
 	m0_addb_mc_fini(&reqh->rh_addb_mc);
         m0_fom_domain_fini(&reqh->rh_fom_dom);
+	m0_addb_monitors_fini(reqh);
         m0_reqh_svc_tlist_fini(&reqh->rh_services);
         m0_reqh_rpc_mach_tlist_fini(&reqh->rh_rpc_machines);
 	m0_reqh_lockers_fini(reqh);
@@ -369,6 +388,12 @@ M0_INTERNAL void m0_reqh_fini(struct m0_reqh *reqh)
 	m0_ha_domain_fini(&reqh->rh_hadom);
 }
 
+M0_INTERNAL void m0_reqh_fini(struct m0_reqh *reqh)
+{
+	m0_reqh_dbenv_fini(reqh);
+	__reqh_fini(reqh);
+}
+
 M0_INTERNAL void m0_reqhs_fini(void)
 {
 	m0_reqh_service_types_fini();
@@ -399,6 +424,7 @@ m0_reqh_addb_mc_config(struct m0_reqh *reqh, struct m0_stob *stob)
 	M0_ENTRY();
 
 	rc = m0_addb_mc_configure_stob_sink(&reqh->rh_addb_mc,
+					    reqh,
 					    stob,
 					    addb_stob_seg_size,
 					    addb_stob_size,
diff --git a/reqh/reqh.h b/reqh/reqh.h
index 2890e59..106a8b3 100644
--- a/reqh/reqh.h
+++ b/reqh/reqh.h
@@ -32,6 +32,7 @@
 #include "fop/fom.h"
 #include "layout/layout.h"
 #include "ha/epoch.h"
+#include "addb/addb_monitor.h"
 
 /**
    @defgroup reqh Request handler
@@ -61,7 +62,7 @@ struct m0_net_xprt;
 struct m0_rpc_machine;
 struct m0_local_service_ops;
 
-M0_LOCKERS_DECLARE(M0_EXTERN, m0_reqh, 32);
+M0_LOCKERS_DECLARE(M0_EXTERN, m0_reqh, 256);
 
 /** Local reply consumer service (testing or replicator) */
 struct m0_local_service {
@@ -95,10 +96,10 @@ enum m0_reqh_states {
  */
 struct m0_reqh {
 	/** Request handler magic. */
-	uint64_t                 rh_magic;
+	uint64_t                      rh_magic;
 
 	/** State machine. */
-	struct m0_sm             rh_sm;
+	struct m0_sm                  rh_sm;
 
 	/**
 	   State machine group.
@@ -107,32 +108,32 @@ struct m0_reqh {
 	   waiters of significant events.
 	   @todo Replace rh_mutex and rh_sd_signal
 	 */
-	struct m0_sm_group       rh_sm_grp;
+	struct m0_sm_group            rh_sm_grp;
 
-	struct m0_dtm		*rh_dtm;
+	struct m0_dtm		     *rh_dtm;
 
 	/** Database environment for this request handler. */
-	struct m0_dbenv         *rh_dbenv;
-	struct m0_be_seg        *rh_beseg;
+	struct m0_dbenv              *rh_dbenv;
+	struct m0_be_seg             *rh_beseg;
 
 	/** Mdstore for this request handler. */
-	struct m0_mdstore       *rh_mdstore;
+	struct m0_mdstore            *rh_mdstore;
 
 	/** Fol pointer for this request handler. */
-	struct m0_fol		*rh_fol;
+	struct m0_fol		     *rh_fol;
 
 	/** Fom domain for this request handler. */
-	struct m0_fom_domain	 rh_fom_dom;
+	struct m0_fom_domain	      rh_fom_dom;
 
         /**
 	    Services registered with this request handler.
 
 	    @see m0_reqh_service::rs_linkage
 	 */
-        struct m0_tl             rh_services;
+        struct m0_tl                  rh_services;
 
 	/** Pointer to the management service */
-	struct m0_reqh_service  *rh_mgmt_svc;
+	struct m0_reqh_service       *rh_mgmt_svc;
 
         /**
 	    RPC machines running in this request handler.
@@ -141,42 +142,47 @@ struct m0_reqh {
 
 	    @see m0_rpc_machine::rm_rh_linkage
 	 */
-        struct m0_tl             rh_rpc_machines;
+        struct m0_tl                  rh_rpc_machines;
 
 	/** provides protected access to reqh members. */
-	struct m0_rwlock         rh_rwlock;
+	struct m0_rwlock              rh_rwlock;
 
 	/**
 	   Private, fully configured, ADDB machine for the request handler.
 	   The first such machine created is used to configure the global
 	   machine, ::m0_addb_gmc.
 	 */
-	struct m0_addb_mc        rh_addb_mc;
+	struct m0_addb_mc             rh_addb_mc;
 
-	struct m0_addb_ctx       rh_addb_ctx;
+	struct m0_addb_ctx            rh_addb_ctx;
+
+	/**
+	 * ADDB monitoring context maintained per request handler.
+	 */
+	struct m0_addb_monitoring_ctx rh_addb_monitoring_ctx;
 
 	/**
 	    Channel to wait on for reqh shutdown or FOM termination.
 	    @deprecated Replace with rh_sm_grp
 	 */
-	struct m0_chan           rh_sd_signal;
-	struct m0_mutex          rh_mutex; /**< protect rh_sd_signal chan */
+	struct m0_chan                rh_sd_signal;
+	struct m0_mutex               rh_mutex; /**< protect rh_sd_signal chan */
 
 	/** Local service consuming reply. */
-	struct m0_local_service *rh_svc;
+	struct m0_local_service      *rh_svc;
 
 	/**
 	 * Layout domain for this request handler.
 	 */
-	struct m0_layout_domain  rh_ldom;
+	struct m0_layout_domain       rh_ldom;
 
 	/** HA domain which stores the epoch. */
-	struct m0_ha_domain      rh_hadom;
+	struct m0_ha_domain           rh_hadom;
 
 	/**
 	 * Lockers to store private data
 	 */
-	struct m0_reqh_lockers   rh_lockers;
+	struct m0_reqh_lockers        rh_lockers;
 };
 
 /**
@@ -190,6 +196,10 @@ struct m0_reqh_init_args {
 	/** fol File operation log to record fop execution */
 	struct m0_fol           *rhia_fol;
 	struct m0_local_service *rhia_svc;
+	/** Hard-coded stob to store ADDB records
+	    @see cs_addb_storage_init()
+	  */
+	struct m0_stob          *rhia_addb_stob;
 };
 
 /**
diff --git a/rpc/rpclib.c b/rpc/rpclib.c
index d4cdaa4..1faaa9f 100644
--- a/rpc/rpclib.c
+++ b/rpc/rpclib.c
@@ -146,11 +146,11 @@ int m0_rpc_client_start(struct m0_rpc_client_ctx *cctx)
 
 	M0_SET0(&cctx->rcx_reqh);
 	rc = M0_REQH_INIT(&cctx->rcx_reqh,
-			  .rhia_dtm       = (void*)1,
-			  .rhia_db        = NULL,
-			  .rhia_mdstore   = (void*)1,
-			  .rhia_fol       = &cctx->rcx_fol,
-			  .rhia_svc       = (void*)1);
+			  .rhia_dtm          = (void*)1,
+			  .rhia_db           = NULL,
+			  .rhia_mdstore      = (void*)1,
+			  .rhia_fol          = &cctx->rcx_fol,
+			  .rhia_svc          = (void*)1);
 	if (rc != 0)
 		goto err;
 	m0_reqh_start(&cctx->rcx_reqh);
diff --git a/scripts/m0mount.sh b/scripts/m0mount.sh
index 5534c3f..9f4203d 100755
--- a/scripts/m0mount.sh
+++ b/scripts/m0mount.sh
@@ -430,7 +430,7 @@ function start_server () {
 
 	local SNAME="-s addb -s ioservice -s sns_repair -s sns_rebalance"
 	if [ $I -eq 0 ]; then
-		SNAME="-s mdservice -s rmservice $SNAME"
+		SNAME="-s mdservice -s rmservice -s stats $SNAME"
 	fi
 
 	$RUN "cd $DDIR && \
@@ -439,7 +439,7 @@ M0_TRACE_LEVEL=$M0_TRACE_LEVEL \
 M0_TRACE_PRINT_CONTEXT=$M0_TRACE_PRINT_CONTEXT \
 $BROOT/mero/m0d -r -p \
 $STOB_PARAMS -D $DDIR/db -S $DDIR/stobs -A $DDIR/stobs \
--w $POOL_WIDTH -G $XPT:$MDS_EP
+-w $POOL_WIDTH -G $XPT:$MDS_EP -R $XPT:$STATS_EP
 -e $XPT:$EP $IOS_EPs $SNAME $XPT_SETUP" > ${SLOG}$I.log &
 	if [ $? -ne 0 ]; then
 		echo ERROR: Failed to start remote server on $H
@@ -461,6 +461,7 @@ function start_servers () {
 	fi
 
 	MDS_EP=${SERVICES[1]}
+	STATS_EP=${SERVICES[1]}
 	IOS_EPs=" -i $XPT:$MDS_EP"
 	for i in `seq 3 2 ${#SERVICES[*]}`; do
 		IOS_EPs="$IOS_EPs -i $XPT:${SERVICES[$i]}"
@@ -621,6 +622,7 @@ main()
 	# prepare configuration data
 	MDS_ENDPOINT="\"${SERVICES[1]}\""
 	RMS_ENDPOINT="\"${SERVICES[1]}\""
+	STATS_ENDPOINT="\"${SERVICES[1]}\""
 	IOS_NAMES='"ios1"'
 	IOS_OBJS="($IOS_NAMES, {3| (2, [1: $MDS_ENDPOINT], \"_\")})"
 	for i in `seq 3 2 ${#SERVICES[*]}`; do
@@ -631,16 +633,17 @@ main()
 	done
 
 	CONF="`cat <<EOF
-[$((SERVICES_NR + 4)):
+[$((SERVICES_NR + 5)):
   ("prof", {1| ("fs")}),
   ("fs", {2| ((11, 22),
               [4: "pool_width=$POOL_WIDTH",
                   "nr_data_units=$NR_DATA",
 		  "nr_parity_units=$NR_PARITY",
                   "unit_size=$UNIT_SIZE"],
-              [$((SERVICES_NR + 2)): "mds", "dlm", $IOS_NAMES])}),
+              [$((SERVICES_NR + 3)): "mds", "dlm", "stats", $IOS_NAMES])}),
   ("mds", {3| (1, [1: $MDS_ENDPOINT], "_")}),
   ("dlm", {3| (4, [1: $RMS_ENDPOINT], "_")}),
+  ("stats", {3| (5, [1: $STATS_ENDPOINT], "_")}),
   $IOS_OBJS]
 EOF`"
 
diff --git a/stats/Kbuild.sub b/stats/Kbuild.sub
new file mode 100644
index 0000000..67f8777
--- /dev/null
+++ b/stats/Kbuild.sub
@@ -0,0 +1,2 @@
+m0mero_objects += stats/stats_fops.o \
+		  stats/stats_fops_xc.o
diff --git a/stats/stats_addb.h b/stats/stats_addb.h
index 16d2006..aad1f7a 100644
--- a/stats/stats_addb.h
+++ b/stats/stats_addb.h
@@ -34,15 +34,18 @@
  * Stats ADDB context types.
  */
 enum {
-	M0_ADDB_CTXID_STATS_SVC		= 1700,
-	M0_ADDB_CTXID_STATS_UPDATE_FOM	= 1701,
-	M0_ADDB_CTXID_STATS_QUERY_FOM	= 1702,
+	M0_ADDB_CTXID_STATS_SVC		   = 1700,
+	M0_ADDB_CTXID_STATS_UPDATE_FOM	   = 1701,
+	M0_ADDB_CTXID_STATS_QUERY_FOM	   = 1702,
+	M0_ADDB_CTXID_MONITORS_MOD         = 1703,
 };
 
 M0_ADDB_CT(m0_addb_ct_stats_svc, M0_ADDB_CTXID_STATS_SVC, "hi", "low");
 M0_ADDB_CT(m0_addb_ct_stats_update_fom, M0_ADDB_CTXID_STATS_UPDATE_FOM);
 M0_ADDB_CT(m0_addb_ct_stats_query_fom, M0_ADDB_CTXID_STATS_QUERY_FOM);
 
+M0_ADDB_CT(m0_addb_ct_monitors_mod, M0_ADDB_CTXID_MONITORS_MOD);
+
 /*
  * Stats ADDB posting locations.
  */
@@ -51,27 +54,24 @@ enum {
 	M0_STATS_SVC_ADDB_LOC_SERVICE_ALLOC = 1,
 };
 
-/**
- *  @todo stuff These are stuffs and need to remove when actual stats defined.
- *              These are added just to test stats utility.
- *              This should be removed when actual Monitoring infra and
- *              some monitors code come in.
+#define STATS_ADDB_FUNCFAIL(rc, loc, ctx)		             \
+M0_ADDB_FUNC_FAIL(&m0_addb_gmc, M0_STATS_ADDB_LOC_##loc, rc, ctx)
+
+#define STATS_ALLOC_PTR(ptr, ctx, loc)			             \
+M0_ALLOC_PTR_ADDB(ptr, &m0_addb_gmc, M0_STATS_ADDB_LOC_##loc, ctx)
+
+/*
+ ******************************************************************************
+ * Stats ADDB posting locations
+ ******************************************************************************
  */
 enum {
-	M0_ADDB_RECID_STATS_FOP_RATE = 9900,
-	M0_ADDB_RECID_STATS_READ_SIZE,
-	M0_ADDB_RECID_STATS_DISK_STATS
+	M0_STATS_ADDB_LOC_SVC_CONN_ESTABLISH_1 = 10,
+	M0_STATS_ADDB_LOC_SVC_CONN_ESTABLISH_2 = 11,
+	M0_STATS_ADDB_LOC_SVC_CONN_FINI_1      = 20,
+	M0_STATS_ADDB_LOC_SVC_CONN_FINI_2      = 21,
 };
 
-M0_ADDB_RT_STATS(m0_addb_rt_stats_fop_rate, M0_ADDB_RECID_STATS_FOP_RATE,
-	         "rate", "avg_turnaround_time_ns");
-M0_ADDB_RT_STATS(m0_addb_rt_stats_read_size, M0_ADDB_RECID_STATS_READ_SIZE,
-	         "avg_size");
-M0_ADDB_RT_STATS(m0_addb_rt_stats_disk_stats, M0_ADDB_RECID_STATS_DISK_STATS,
-	         "total", "free", "used");
-
-/** end stuff */
-
 /** @} */ /* end of stats */
 
 #endif /* __MERO_STATS_ADDB_H_ */
diff --git a/stats/stats_fops.c b/stats/stats_fops.c
index f6d05ad..de77f88 100644
--- a/stats/stats_fops.c
+++ b/stats/stats_fops.c
@@ -64,9 +64,11 @@ M0_INTERNAL int m0_stats_fops_init(void)
 				 .xt	    = m0_stats_update_fop_xc,
 				 .rpc_flags = M0_RPC_ITEM_TYPE_ONEWAY,
 				 .fop_ops   = &stats_update_fop_ops,
+#ifndef __KERNEL__
 				 .fom_ops   = &stats_update_fom_type_ops,
 				 .sm	    = &stats_update_fom_sm_conf,
 				 .svc_type  = &m0_stats_svc_type,
+#endif
 				 .rpc_ops   = &stats_update_item_type_ops) ?:
 		M0_FOP_TYPE_INIT(&m0_fop_stats_query_fopt,
                                  .name      = "Stats query fop",
@@ -74,9 +76,11 @@ M0_INTERNAL int m0_stats_fops_init(void)
 				 .xt	    = m0_stats_query_fop_xc,
 				 .rpc_flags = M0_RPC_ITEM_TYPE_REQUEST,
 				 .fop_ops   = &stats_query_fop_ops,
+#ifndef __KERNEL__
 				 .fom_ops   = &stats_query_fom_type_ops,
 				 .sm	    = &stats_query_fom_sm_conf,
 				 .svc_type  = &m0_stats_svc_type,
+#endif
 				 .rpc_ops   = &stats_query_item_type_ops) ?:
 		M0_FOP_TYPE_INIT(&m0_fop_stats_query_rep_fopt,
                                  .name      = "Stats query rep fop",
diff --git a/stats/stats_fops.h b/stats/stats_fops.h
index 303db74..9c0839e 100644
--- a/stats/stats_fops.h
+++ b/stats/stats_fops.h
@@ -28,6 +28,7 @@
 #include "addb/addb.h"
 #include "addb/addb_wire.h"
 #include "addb/addb_wire_xc.h"
+
 /**
  * @defgroup stats_fop Stats FOP
  * @{
@@ -54,7 +55,7 @@ extern struct m0_fop_type m0_fop_stats_query_rep_fopt;
  */
 struct m0_stats_sum {
 	/** Stats id, this is corresponding addb rec type id. */
-	uint64_t		  ss_id;
+	uint32_t		  ss_id;
 	/** Stats summary data */
 	struct m0_addb_uint64_seq ss_data;
 } M0_XCA_RECORD;
diff --git a/stats/stats_srv.c b/stats/stats_srv.c
index 806ce58..527d876 100644
--- a/stats/stats_srv.c
+++ b/stats/stats_srv.c
@@ -170,10 +170,7 @@
 1lBgPht18RYX7s9XL-FcfUBKZ0zvo6JzqAEsXpTWs_4Q/edit">
    Mero Stats Service</a>
  */
-#undef M0_ADDB_CT_CREATE_DEFINITION
-#define M0_ADDB_CT_CREATE_DEFINITION
-#undef M0_ADDB_RT_CREATE_DEFINITION
-#define M0_ADDB_RT_CREATE_DEFINITION
+
 #include "stats/stats_addb.h"
 
 #define M0_TRACE_SUBSYSTEM M0_TRACE_SUBSYS_STATS
@@ -213,63 +210,7 @@ struct m0_sm_conf stats_query_fom_sm_conf;
 
 static int stats_add(struct m0_tl *stats_list, struct m0_stats_sum *sum);
 
-/**
- * @todo stuff These are stuffs and need to remove when actual stats defined.
- *             These are added just to test stats utility.
- *             This should be removed when actual Monitoring infra and
- *             some monitors code come in.
- *
- */
-static void define_stats()
-{
-	/** No provision to pass seperate name for rec type to M0_ADDB_RT_DP */
-	m0_addb_rt_stats_fop_rate.art_name = "fop_rate";
-	m0_addb_rec_type_register(&m0_addb_rt_stats_fop_rate);
-	m0_addb_rt_stats_read_size.art_name = "read_size";
-	m0_addb_rec_type_register(&m0_addb_rt_stats_read_size);
-	m0_addb_rt_stats_disk_stats.art_name = "disk_stats";
-	m0_addb_rec_type_register(&m0_addb_rt_stats_disk_stats);
-}
-
-static void add_dummy_stats(struct m0_tl *stats_list)
-{
-	struct m0_stats_sum stats_sum;
-	static struct fop_rate {
-		uint64_t fr_rate;
-		uint64_t fr_avg_turnaround_time_ns;
-	} f_rate;
-	static struct read_size {
-		uint64_t rs_avg_size;
-	} r_size;
-	static struct disk_stats {
-		uint64_t ds_total;
-		uint64_t ds_free;
-		uint64_t ds_used;
-	} d_stats;
-
-        f_rate.fr_rate = 3000;
-        f_rate.fr_avg_turnaround_time_ns = 98765;
-        stats_sum.ss_id = M0_ADDB_RECID_STATS_FOP_RATE;
-        stats_sum.ss_data.au64s_nr = 2;
-        stats_sum.ss_data.au64s_data = (uint64_t *)&f_rate;
-	stats_add(stats_list, &stats_sum);
-
-        r_size.rs_avg_size = 8196;
-        stats_sum.ss_id = M0_ADDB_RECID_STATS_READ_SIZE;
-        stats_sum.ss_data.au64s_nr = 1;
-        stats_sum.ss_data.au64s_data = (uint64_t *)&r_size;
-	stats_add(stats_list, &stats_sum);
-
-        d_stats.ds_free  = 2678901234;
-        d_stats.ds_used  = 3578901234;
-        d_stats.ds_total = 6257802468;
-        stats_sum.ss_id = M0_ADDB_RECID_STATS_DISK_STATS;
-        stats_sum.ss_data.au64s_nr = 3;
-        stats_sum.ss_data.au64s_data = (uint64_t *)&d_stats;
-	stats_add(stats_list, &stats_sum);
-}
-/** end stuff */
-
+#define SUM_DATA_SIZE(sum_data) (sum_data->ss_data.au64s_nr * sizeof(uint64_t))
 
 /*
  * Stats Service
@@ -348,9 +289,6 @@ static int stats_svc_rsto_service_allocate(struct m0_reqh_service      **srv,
 
 	M0_POST(stats_svc_invariant(svc));
 
-	// stuff. check @todo stuff
-	add_dummy_stats(&svc->ss_stats);
-
 	return 0;
 }
 
@@ -366,30 +304,17 @@ M0_REQH_SERVICE_TYPE_DEFINE(m0_stats_svc_type, &stats_service_type_ops,
  */
 M0_INTERNAL int m0_stats_svc_init(void)
 {
-	int rc;
-
 	m0_addb_ctx_type_register(&m0_addb_ct_stats_svc);
 	m0_addb_ctx_type_register(&m0_addb_ct_stats_update_fom);
 	m0_addb_ctx_type_register(&m0_addb_ct_stats_query_fom);
 
-	rc = m0_reqh_service_type_register(&m0_stats_svc_type);
-	if (rc != 0)
-		return rc;
-
-	rc = m0_stats_fops_init();
-	if (rc != 0)
-		m0_reqh_service_type_unregister(&m0_stats_svc_type);
-
-	// stuff. check @todo stuff
-	define_stats();
+	return m0_reqh_service_type_register(&m0_stats_svc_type);
 
-	return rc;
 }
 
 M0_INTERNAL void m0_stats_svc_fini(void)
 {
 	m0_reqh_service_type_unregister(&m0_stats_svc_type);
-	m0_stats_fops_fini();
 }
 
 /*
@@ -448,12 +373,7 @@ static bool stats_invariant(const struct m0_stats *stats)
 	return stats->s_magic == M0_STATS_MAGIC;
 }
 
-/**
- * @todo This def may come in monitor infra. Need to take care while merging.
- */
-#define SUM_SIZE(sum_data) (sum_data->ss_data.au64s_nr * sizeof(uint64_t))
-
-static struct m0_stats *stats_get(struct m0_tl *stats_list, uint64_t id)
+M0_INTERNAL struct m0_stats *m0_stats_get(struct m0_tl *stats_list, uint64_t id)
 {
 	struct m0_stats *stats_obj = NULL;
 
@@ -479,7 +399,7 @@ static int stats_sum_copy(struct m0_stats_sum *s, struct m0_stats_sum *d)
 
 	d->ss_id = s->ss_id;
 	d->ss_data.au64s_nr = s->ss_data.au64s_nr;
-	memcpy(d->ss_data.au64s_data, s->ss_data.au64s_data, SUM_SIZE(d));
+	memcpy(d->ss_data.au64s_data, s->ss_data.au64s_data, SUM_DATA_SIZE(d));
 	return 0;
 }
 
@@ -529,8 +449,8 @@ static int stats_update(struct m0_fom *fom)
 
 	for (i = 0; i < ufop->suf_stats.sf_nr; ++i) {
 		struct m0_stats_sum *sum = &(ufop->suf_stats.sf_stats[i]);
-		struct m0_stats     *stats_obj = stats_get(&svc->ss_stats,
-							   sum->ss_id);
+		struct m0_stats     *stats_obj = m0_stats_get(&svc->ss_stats,
+							      sum->ss_id);
 
 		if (stats_obj != NULL) {
 			stats_sum_copy(sum, &stats_obj->s_sum);
@@ -580,7 +500,7 @@ static int stats_update_fom_tick(struct m0_fom *fom)
 
 	M0_PRE(fom != NULL);
 
-	switch(m0_fom_phase(fom)) {
+	switch (m0_fom_phase(fom)) {
 	case STATS_UPDATE_FOM_INIT:
 		m0_fom_phase_set(fom, STATS_UPDATE_FOM_UPDATE_OBJECT);
 		rc = M0_FSO_AGAIN;
@@ -691,7 +611,8 @@ static int read_stats(struct m0_fom *fom)
 	for (i = 0; i < qfop->sqf_ids.au64s_nr; ++i) {
 		struct m0_addb_uint64_seq *sum_data;
 		struct m0_stats           *stats_obj =
-			stats_get(&svc->ss_stats, qfop->sqf_ids.au64s_data[i]);
+			m0_stats_get(&svc->ss_stats,
+				     qfop->sqf_ids.au64s_data[i]);
 
 		/* Continue getting stats for next id */
 		if (stats_obj == NULL) {
@@ -801,7 +722,7 @@ static int stats_query_fom_tick(struct m0_fom *fom)
 	if (m0_fom_phase(fom) < M0_FOPH_NR)
 		return m0_fom_tick_generic(fom);
 
-	switch(m0_fom_phase(fom)) {
+	switch (m0_fom_phase(fom)) {
 	case STATS_QUERY_FOM_READ_OBJECT:
 		rc = read_stats(fom);
 		fom->fo_sm_phase.sm_rc = rc;
diff --git a/stats/stats_srv.h b/stats/stats_srv.h
index 136e00e..0e347a0 100644
--- a/stats/stats_srv.h
+++ b/stats/stats_srv.h
@@ -138,6 +138,8 @@ M0_INTERNAL int m0_stats_svc_init(void);
  */
 M0_INTERNAL void m0_stats_svc_fini(void);
 
+M0_INTERNAL struct m0_stats *m0_stats_get(struct m0_tl *stats_list, uint64_t id);
+
 #define STATS_SVC_ALLOC_PTR(ptr, loc, ctx)				      \
 	M0_ALLOC_PTR_ADDB(ptr, &m0_addb_gmc, M0_STATS_SVC_ADDB_LOC_##loc, ctx)
 
diff --git a/stats/ut/stats_ut_svc.c b/stats/ut/stats_ut_svc.c
index b310b32..9b0ffc4 100644
--- a/stats/ut/stats_ut_svc.c
+++ b/stats/ut/stats_ut_svc.c
@@ -112,7 +112,7 @@ void check_stats(struct m0_tl *stats_list, int count)
 	int id;
 
 	for (i = 0, id = 1; i < count; ++i, ++id) {
-		struct m0_stats *stats = stats_get(stats_list, id);
+		struct m0_stats *stats = m0_stats_get(stats_list, id);
 		M0_UT_ASSERT(stats != NULL);
 
 		check_summary_data(&stats_sum[i].ss_data,
@@ -189,15 +189,15 @@ static const struct m0_fom_ops ut_stats_update_fom_ops = {
 static struct m0_fop *get_fake_stats_fop(uint32_t nsum, enum fop_type type)
 {
 	struct m0_fop                   *fop;
-	struct m0_stats_update_fop *ufop;
-	struct m0_stats_query_fop  *qfop;
+	struct m0_stats_update_fop      *ufop;
+	struct m0_stats_query_fop       *qfop;
 
 
 	M0_ALLOC_PTR(fop);
 	M0_UT_ASSERT(fop != NULL);
 
-	switch(type) {
-	case UPDATE_FOP :
+	switch (type) {
+	case UPDATE_FOP:
 		M0_ALLOC_PTR(ufop);
 		M0_UT_ASSERT(ufop != NULL);
 
@@ -207,7 +207,7 @@ static struct m0_fop *get_fake_stats_fop(uint32_t nsum, enum fop_type type)
 		m0_fop_init(fop, &m0_fop_stats_update_fopt, (void *)ufop,
 			    fop_release);
 		break;
-	case QUERY_FOP :
+	case QUERY_FOP:
 		M0_ALLOC_PTR(qfop);
 		M0_UT_ASSERT(qfop != NULL);
 
@@ -224,7 +224,7 @@ static void update_fom_test(struct stats_svc *srv, struct m0_reqh *reqh,
 {
 	struct m0_fop			*fop;
 	struct m0_fom			*fom;
-	struct m0_stats_update_fop *ufop;
+	struct m0_stats_update_fop      *ufop;
 	int				 i;
 	int				 rc;
 
diff --git a/stats/util/stats_util.c b/stats/util/stats_util.c
index bae1ee9..93d1f83 100644
--- a/stats/util/stats_util.c
+++ b/stats/util/stats_util.c
@@ -47,14 +47,12 @@ enum {
 	STATS_MAX_NAME_SIZE = 32,
 	STATS_DEFAULT_COUNT = 1,
 	STATS_DEFAULT_DELAY = 5,
-	STATS_EP_PID	    = 12345,
-	STATS_EP_PORTAL     = 41,
-        STATS_EP_TM         = 1,
-	STATS_VALUE_WIDTH  = 16,
+	STATS_VALUE_WIDTH   = 16,
 };
 
 static struct m0_net_xprt        *xprt           = &m0_net_lnet_xprt;
 static struct m0_net_domain       client_net_dom = { };
+static bool signaled = false;
 
 static struct m0_rpc_client_ctx cctx = {
 	.rcx_net_dom               = &client_net_dom,
@@ -69,7 +67,8 @@ static void m0stats_help()
 	fprintf(stderr,
 "Usage: m0stats \n"
 "\n"
-"-e EndPoint    Specify the raw transport end point address.\n"
+"-e EndPoint    Specify the raw transport local end point address.\n"
+"-R EndPoint    Specify the raw transport stats service end point address.\n"
 "-s StatsNames  Specify one or more comma separated stats names.\n"
 "-o FileName    Specify output file name.\n"
 "-l             Lists defined statistics names.\n"
@@ -180,23 +179,32 @@ static void stats_print_header(FILE *out, struct m0_addb_uint64_seq *stats_ids)
 	fprintf(out, "\n");
 }
 
-static void stats_print_values(FILE *out,
+static void stats_print_values(FILE *out, struct m0_addb_uint64_seq *stats_ids,
 			       const struct m0_stats_recs *stats_recs)
 {
+#undef STATS_FIELD_VALUE
+#define STATS_FIELD_VALUE(stats_sum, j)			\
+	(stats_sum.ss_data.au64s_nr != rt->art_rf_nr ?	\
+	(uint64_t)0 : stats_sum.ss_data.au64s_data[j])
+
 	int i;
 	int j;
 
-	for (i = 0; i < stats_recs->sf_nr; ++i) {
+	for (i = 0; i < stats_ids->au64s_nr; ++i) {
 		const struct m0_addb_rec_type *rt =
-			m0_addb_rec_type_lookup(stats_recs->sf_stats[i].ss_id);
-		M0_ASSERT(stats_recs->sf_stats[i].ss_data.au64s_nr ==
-			  rt->art_rf_nr);
-		for (j = 0; j < stats_recs->sf_stats[i].ss_data.au64s_nr; ++j)
+			m0_addb_rec_type_lookup(stats_ids->au64s_data[i]);
+		if (rt == NULL) {
+			fprintf(out, "Failed to retrived stats info.\n");
+			break;
+		}
+
+		for (j = 0; j < rt->art_rf_nr; ++j)
 			fprintf(out, "%*lu",
 				stats_field_width(rt->art_rf[j].arfu_name),
-				stats_recs->sf_stats[i].ss_data.au64s_data[j]);
+				STATS_FIELD_VALUE(stats_recs->sf_stats[i], j));
 	}
 	fprintf(out, "\n");
+#undef STATS_FIELD_VALUE
 }
 
 static int stats_print_list()
@@ -215,28 +223,7 @@ static int stats_print_list()
 
 static void sig_handler(int signum)
 {
-}
-
-static int stats_local_ep(char *ep)
-{
-	int  rc;
-	char hostname[M0_CFG_NAME_LEN];
-	char addr[M0_CFG_NAME_LEN];
-
-	M0_PRE(ep != NULL);
-
-	rc = gethostname(hostname, sizeof hostname);
-	if (rc != 0)
-		return rc;
-
-	rc = m0_host_resolve(hostname, addr, sizeof addr);
-	if (rc != 0)
-		return rc;
-
-	sprintf(ep, "%s@tcp:%d:%d:%d", addr, STATS_EP_PID, STATS_EP_PORTAL,
-		STATS_EP_TM);
-
-	return 0;
+	signaled = true;
 }
 
 int main(int argc, char *argv[])
@@ -245,6 +232,7 @@ int main(int argc, char *argv[])
 	int                         rc = 0;
 	int                         r2;
 	struct sigaction            sa;
+	const char                 *local_addr = NULL;
 	const char                 *remote_addr = NULL;
 	const char                 *outfile     = NULL;
 	const char                 *stats_list  = NULL;
@@ -255,10 +243,9 @@ int main(int argc, char *argv[])
 	struct m0_addb_uint64_seq  *stats_ids  = NULL;
 	struct cs_endpoint_and_xprt epx;
 	FILE			   *fout;
-	char                        local_ep[M0_CFG_NAME_LEN];
 
 	r2 = M0_GETOPTS("m0stats", argc, argv,
-			M0_STRINGARG('e', "Stats service endpoint",
+			M0_STRINGARG('R', "Stats service endpoint",
 				LAMBDA(void, (const char *str)
 				{
 					if (remote_addr != NULL)
@@ -266,6 +253,14 @@ int main(int argc, char *argv[])
 					else
 						remote_addr = str;
 				})),
+			M0_STRINGARG('e', "Local endpoint",
+				LAMBDA(void, (const char *str)
+				{
+					if (local_addr != NULL)
+						rc = -EINVAL;
+					else
+						local_addr = str;
+				})),
 			M0_STRINGARG('s', "Stats list",
 				LAMBDA(void, (const char *str)
 				{
@@ -299,7 +294,8 @@ int main(int argc, char *argv[])
 	}
 
 	if (!ergo(list_names,
-		 remote_addr == NULL && stats_list == NULL && outfile == NULL)){
+		 local_addr == NULL && remote_addr == NULL &&
+		 stats_list == NULL && outfile == NULL)){
 		m0stats_help();
 		return 1;
 	}
@@ -316,15 +312,20 @@ int main(int argc, char *argv[])
         sigaction(SIGQUIT, &sa, NULL);
         sigaction(SIGPIPE, &sa, NULL);
 
-	rc = stats_local_ep(local_ep);
+	rc = m0_init();
 	if (rc != 0) {
-		fprintf(stderr, "Failed to get local address. rc = %d\n", rc);
+		fprintf(stderr, "Failed to initialize library. rc = %d\n", rc);
 		return rc;
 	}
 
-	if (remote_addr == NULL || stats_list == NULL) {
+	if (list_names) {
+		stats_print_list();
+		goto mero_fini;
+	}
+
+	if (local_addr == NULL || remote_addr == NULL || stats_list == NULL) {
 		m0stats_help();
-		return 1;
+		goto mero_fini;
 	}
 
 	if (outfile != NULL) {
@@ -337,26 +338,22 @@ int main(int argc, char *argv[])
 	} else
 		fout = stdout;
 
-	rc = m0_ep_and_xprt_extract(&epx, remote_addr);
+	rc = m0_ep_and_xprt_extract(&epx, local_addr);
 	if (rc != 0) {
                 fprintf(stderr,
 			"m0stats:Failed to extract endpoint. rc = %d\n", rc);
 		goto mero_fini_fclose;
 	}
+	cctx.rcx_local_addr = epx.ex_endpoint;
 
-	cctx.rcx_remote_addr = epx.ex_endpoint;
-	cctx.rcx_local_addr  = strdup(local_ep);
-
-	rc = m0_init();
+	rc = m0_ep_and_xprt_extract(&epx, remote_addr);
 	if (rc != 0) {
-		fprintf(stderr, "Failed to initialize library. rc = %d\n", rc);
-		return rc;
+                fprintf(stderr,
+			"m0stats:Failed to extract endpoint. rc = %d\n", rc);
+		goto mero_fini_fclose;
 	}
+	cctx.rcx_remote_addr  = epx.ex_endpoint;
 
-	if (list_names) {
-		stats_print_list();
-		goto mero_fini;
-	}
 
         rc = m0_net_xprt_init(xprt);
         if (rc != 0) {
@@ -382,7 +379,7 @@ int main(int argc, char *argv[])
 		goto disconnect;
 
 	stats_print_header(fout, stats_ids);
-	for (i = 0; i < count; ++i) {
+	for (i = 0; i < count && !signaled; ++i) {
 		rc = m0_stats_query(&cctx.rcx_session, stats_ids, &stats_recs);
 		if (rc != 0) {
 			fprintf(stderr,"m0stats:m0_stats_query failed."
@@ -390,8 +387,10 @@ int main(int argc, char *argv[])
 			rc = EX_UNAVAILABLE;
 		}
 
-		stats_print_values(fout, stats_recs);
-		m0_stats_free(stats_recs);
+		if (stats_recs != NULL) {
+			stats_print_values(fout, stats_ids, stats_recs);
+			m0_stats_free(stats_recs);
+		}
 		m0_nanosleep(delay * 1000 * 1000 * 1000, NULL);
 	}
 
@@ -401,10 +400,10 @@ disconnect:
 
 domain_fini:
 	m0_net_domain_fini(&client_net_dom);
-mero_fini:
-	m0_fini();
 mero_fini_fclose:
 	fclose(fout);
+mero_fini:
+	m0_fini();
 	return rc;
 }
 
-- 
1.8.3.2

