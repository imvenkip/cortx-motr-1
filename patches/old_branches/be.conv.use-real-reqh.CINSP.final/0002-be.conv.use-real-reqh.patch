From 6b31f3b27e073ecb165d39591ab67f53c53380c9 Mon Sep 17 00:00:00 2001
From: Mandar Sawant <mandar_sawant@xyratex.com>
Date: Tue, 4 Feb 2014 18:41:57 +0530
Subject: [PATCH 2/9] be.conv.use-real-reqh - M0dify be/ut/helper.h functions
 to use real reqh, use minimalistic reqh for UT purpose. - Remove usage of
 reqh_emu. - start be-tx-service early on for m0d, handle finalisation. - Fix
 all the UTs as per the changes done in-order to use real reqh.

---
 addb/addb_ctxobj.c         |   4 +-
 balloc/balloc.c            |   1 -
 balloc/ut/balloc.c         |   2 +
 be/domain.c                |   2 +-
 be/engine.c                |   3 +-
 be/engine.h                |   1 -
 be/tx_group_fom.c          |  10 ++--
 be/tx_service.c            |   7 ++-
 be/ut/alloc.c              |   1 +
 be/ut/domain.c             |   1 +
 be/ut/extmap.c             |   1 +
 be/ut/helper.c             | 111 ++++++++++++++++++---------------------------
 be/ut/helper.h             |   5 ++
 be/ut/list.c               |   1 +
 be/ut/seg_dict.c           |   1 +
 be/ut/tx.c                 |  10 ++++
 cm/ut/cm.c                 |   5 +-
 cm/ut/common_service.c     |  14 ++++++
 cm/ut/common_service.h     |   2 +
 cm/ut/cp.c                 |   7 ++-
 conf/db.c                  |   5 ++
 conf/ut/db.c               |  28 ++++++++----
 db/db.c                    |   3 +-
 db/ut/db.c                 |   8 ++++
 dtm/ut/transmit.c          |   8 ++--
 fol/ut/fol.c               |  15 +++++-
 ioservice/ut/bulkio_ut.c   |   2 +-
 ioservice/ut/cob_foms.c    |   7 ++-
 layout/ut/layout.c         |   5 ++
 lib/time.c                 |   4 +-
 mero/setup.c               |  66 +++++++++++++++++++--------
 pool/ut/test_pm.c          |  17 +++++++
 sns/cm/repair/ut/cm.c      |   2 +
 sns/cm/repair/ut/net.c     |   4 +-
 sns/cm/repair/ut/storage.c |   7 ++-
 sns/cm/repair/ut/xform.c   |  10 ++--
 ut/be.c                    |  73 ++++++++++++++++++++++++++++-
 ut/be.h                    |  12 +++++
 ut/ut_rpc_machine.c        |  11 +++--
 39 files changed, 340 insertions(+), 136 deletions(-)

diff --git a/addb/addb_ctxobj.c b/addb/addb_ctxobj.c
index 9c50633..7cc0f90 100644
--- a/addb/addb_ctxobj.c
+++ b/addb/addb_ctxobj.c
@@ -508,9 +508,7 @@ M0_INTERNAL void m0__addb_ctx_init(struct m0_addb_mc *mc,
 				   uint64_t fields[])
 {
 	M0_PRE(!m0_addb_ctx_is_imported(parent));
-	M0_LOG(M0_FATAL, "%p %u %p %p",
-		ct->act_name, ct->act_id, addb_ctx_type_lookup(ct->act_id), ct);
-	//M0_PRE(addb_ctx_type_invariant(ct));
+	M0_PRE(addb_ctx_type_invariant(ct));
 
 	/* construct the context object */
 	ctx->ac_type = ct;
diff --git a/balloc/balloc.c b/balloc/balloc.c
index af91b34..138cf01 100644
--- a/balloc/balloc.c
+++ b/balloc/balloc.c
@@ -2190,7 +2190,6 @@ M0_INTERNAL int m0_balloc_create(uint64_t            cid,
 	rc = m0_be_seg_dict_lookup(seg, cid_name, (void**)out);
 	if (rc == 0)
 		return rc;
-
 	m0_be_tx_init(&tx, 0, seg->bs_domain,
 		      grp, NULL, NULL, NULL, NULL);
 	M0_BE_ALLOC_CREDIT_PTR(cb, seg, &cred);
diff --git a/balloc/ut/balloc.c b/balloc/ut/balloc.c
index 2257f92..cf84ba7 100644
--- a/balloc/ut/balloc.c
+++ b/balloc/ut/balloc.c
@@ -279,6 +279,8 @@ void test_balloc()
 	struct m0_be_seg	*seg;
 	int			 rc;
 
+	M0_SET0(&ut_be);
+	M0_SET0(&ut_seg);
 	/* Init BE */
 	m0_be_ut_backend_init(&ut_be);
 	m0_be_ut_seg_init(&ut_seg, &ut_be, 1ULL << 24);
diff --git a/be/domain.c b/be/domain.c
index b3ec165..ef52848 100644
--- a/be/domain.c
+++ b/be/domain.c
@@ -44,7 +44,7 @@ M0_INTERNAL int m0_be_domain_init(struct m0_be_domain *dom,
 
 M0_INTERNAL void m0_be_domain_fini(struct m0_be_domain *dom)
 {
-	m0_be_engine_stop(&dom->bd_engine);
+	//m0_be_engine_stop(&dom->bd_engine);
 	m0_be_engine_fini(&dom->bd_engine);
 }
 
diff --git a/be/engine.c b/be/engine.c
index 46019a9..dc33af9 100644
--- a/be/engine.c
+++ b/be/engine.c
@@ -139,6 +139,7 @@ M0_INTERNAL void m0_be_engine_fini(struct m0_be_engine *en)
 		  (etx_tlist_fini(&en->eng_txs[i]), true));
 	for (i = 0; i < en->eng_group_nr; ++i) {
 		m0_be_tx_group_fini(&en->eng_group[i]);
+		egr_tlist_del(&en->eng_group[i]);
 		egr_tlink_fini(&en->eng_group[i]);
 	}
 	m0_forall(i, ARRAY_SIZE(en->eng_groups),
@@ -402,7 +403,7 @@ static void be_engine_group_stop_nr(struct m0_be_engine *en, size_t nr)
 		be_engine_unlock(en);
 		m0_be_tx_group_stop(&en->eng_group[i]);
 		be_engine_lock(en);
-		egr_tlist_del(&en->eng_group[i]);
+//		egr_tlist_del(&en->eng_group[i]);
 	}
 }
 
diff --git a/be/engine.h b/be/engine.h
index 716cd68..0f696cb 100644
--- a/be/engine.h
+++ b/be/engine.h
@@ -65,7 +65,6 @@ struct m0_be_engine {
 	struct m0_be_engine_cfg	  *eng_cfg;
 	/** Protects all fields of this struct. */
 	struct m0_mutex		   eng_lock;
-	struct m0_reqh_service     eng_tx_service;
 	/**
 	 * Per-state lists of transaction. Each non-failed transaction is in one
 	 * of these lists.
diff --git a/be/tx_group_fom.c b/be/tx_group_fom.c
index 735fea2..5676b13 100644
--- a/be/tx_group_fom.c
+++ b/be/tx_group_fom.c
@@ -405,6 +405,7 @@ static void tx_group_fom_fini(struct m0_fom *fom)
 	struct m0_be_tx_group_fom *m = fom2tx_group_fom(fom);
 
 	m0_semaphore_up(&m->tgf_finish_sem);
+	m0_fom_fini(fom);
 }
 
 static size_t tx_group_fom_locality(const struct m0_fom *fom)
@@ -473,7 +474,8 @@ static void be_tx_group_fom_stable(struct m0_sm_group *_, struct m0_sm_ast *ast)
 		container_of(ast, struct m0_be_tx_group_fom, tgf_ast_stable);
 
 	m->tgf_stable = true;
-	m0_fom_wakeup(&m->tgf_gen);
+	if (m0_fom_is_waiting(&m->tgf_gen))
+		m0_fom_wakeup(&m->tgf_gen);
 }
 
 static void be_tx_group_fom_stop(struct m0_sm_group *gr, struct m0_sm_ast *ast)
@@ -482,7 +484,8 @@ static void be_tx_group_fom_stop(struct m0_sm_group *gr, struct m0_sm_ast *ast)
 		container_of(ast, struct m0_be_tx_group_fom, tgf_ast_stop);
 
 	m->tgf_stopping = true;
-	m0_fom_wakeup(&m->tgf_gen);
+	if (m0_fom_is_waiting(&m->tgf_gen))
+		m0_fom_wakeup(&m->tgf_gen);
 }
 
 static void be_tx_group_fom_timeout_cb(struct m0_fom_callback *cb)
@@ -566,7 +569,6 @@ M0_INTERNAL void m0_be_tx_group_fom_fini(struct m0_be_tx_group_fom *m)
 	m0_semaphore_fini(&m->tgf_start_sem);
 	m0_semaphore_fini(&m->tgf_finish_sem);
 	m0_fom_timeout_fini(&m->tgf_to);
-	m0_fom_fini(&m->tgf_gen);
 }
 
 M0_INTERNAL void m0_be_tx_group_fom_reset(struct m0_be_tx_group_fom *m)
@@ -605,6 +607,8 @@ M0_INTERNAL void m0_be_tx_group_fom_stop(struct m0_be_tx_group_fom *gf)
 {
 	be_tx_group_fom_ast_post(gf, &gf->tgf_ast_stop);
 	m0_semaphore_down(&gf->tgf_finish_sem);
+	//if (!M0_IN(m0_fom_phase(&gf->tgf_gen), (TGS_FINISH, TGS_STOPPING)))
+	//	m0_semaphore_down(&gf->tgf_stopped);
 }
 
 M0_INTERNAL void m0_be_tx_group_fom_handle(struct m0_be_tx_group_fom *m,
diff --git a/be/tx_service.c b/be/tx_service.c
index 8c6e9e7..b8ef51e 100644
--- a/be/tx_service.c
+++ b/be/tx_service.c
@@ -52,7 +52,6 @@ static void _addb_init(void)
 	/* XXX not thread-safe */
 	act = m0_addb_ctx_type_lookup(M0_ADDB_CTXID_TX_SERVICE);
 	if (act == NULL) {
-		 M0_LOG(M0_FATAL, "addb_init");
 		 m0_addb_ctx_type_register(&m0_addb_ct_tx_service);
 		 //M0_ADDB_CTX_INIT(&m0_addb_gmc, &m0_tx_service_mod_addb_ctx,
 		//		 &m0_addb_ct_tx_service, &m0_addb_proc_ctx);
@@ -111,14 +110,14 @@ static int txs_allocate(struct m0_reqh_service **service,
 			struct m0_reqh_service_type *stype,
 			struct m0_reqh_context *rctx)
 {
-	struct m0_be_domain *bdom;
+	//struct m0_be_domain *bdom;
 	struct tx_service   *s;
 
 	M0_ENTRY();
 	M0_PRE(stype == &m0_be_txs_stype);
 
-	M0_ALLOC_PTR(bdom);
-	if (bdom == NULL)
+	M0_ALLOC_PTR(s);
+	if (s == NULL)
 		M0_RETURN(-ENOMEM);
 
 	*service = &s->ts_reqh;
diff --git a/be/ut/alloc.c b/be/ut/alloc.c
index cb70190..331e339 100644
--- a/be/ut/alloc.c
+++ b/be/ut/alloc.c
@@ -202,6 +202,7 @@ M0_INTERNAL void m0_be_ut_alloc_transactional(void)
 	int			 i;
 	int			 j;
 
+	M0_SET0(ut_be);
 	m0_be_ut_backend_init(ut_be);
 	m0_be_ut_seg_init(&ut_seg, ut_be, BE_UT_ALLOC_SEG_SIZE);
 	m0_be_ut_seg_check_persistence(&ut_seg);
diff --git a/be/ut/domain.c b/be/ut/domain.c
index a61e7f8..109b7bd 100644
--- a/be/ut/domain.c
+++ b/be/ut/domain.c
@@ -27,6 +27,7 @@ void m0_be_ut_domain(void)
 {
 	struct m0_be_ut_backend ut_be;
 
+	M0_SET0(&ut_be);
 	m0_be_ut_backend_init(&ut_be);
 	m0_be_ut_backend_fini(&ut_be);
 }
diff --git a/be/ut/extmap.c b/be/ut/extmap.c
index 03bb6ea..6a81fff 100644
--- a/be/ut/extmap.c
+++ b/be/ut/extmap.c
@@ -113,6 +113,7 @@ static void test_init(void)
 
 	/* Init BE */
 	/** XXX @todo break UT into small transactions */
+	M0_SET0(&cfg);
 	m0_be_ut_backend_cfg_default(&cfg);
 	cfg.bc_engine.bec_log_size	 = 1 << 27;
 	cfg.bc_engine.bec_tx_size_max	 = M0_BE_TX_CREDIT(1 << 21, 1 << 26);
diff --git a/be/ut/helper.c b/be/ut/helper.c
index 960a8bb..353398a 100644
--- a/be/ut/helper.c
+++ b/be/ut/helper.c
@@ -42,7 +42,7 @@
 
 #define BE_UT_H_STORAGE_DIR "./__seg_ut_stob"
 
-#define REQH_EMU 0
+//#define REQH_EMU 1
 
 enum {
 	BE_UT_SEG_START_ADDR = 0x400000000000ULL,
@@ -135,61 +135,33 @@ static void be_ut_helper_init_once(void)
 	M0_ASSERT(rc == 0);
 }
 
-#ifndef REQH_EMU
 struct m0_reqh *m0_be_ut_reqh_get(void)
 {
-	struct be_ut_helper_struct *h = &be_ut_helper;
-	struct m0_reqh		   *reqh;
-	int			    rc;
-#define NAME(ext) "be-ut" ext
-	static char		   *argv[] = {
-		NAME(""), "-r", "-p", "-T", "linux", "-D", NAME(".db"),
-		"-S", NAME(".stob"), "-A", NAME("_addb.stob"), "-w", "10",
-		"-e", "lnet:0@lo:12345:34:1", "-s", "be-tx-service"
-	};
-
-	be_ut_helper_init_once();
+	struct m0_reqh *reqh;
+	int             result;
 
-	m0_mutex_lock(&h->buh_reqh_lock);
-	if (h->buh_reqh_ref_cnt == 0) {
-		h->buh_net_xprt = &m0_net_lnet_xprt;
-		h->buh_rpc_sctx = (struct m0_rpc_server_ctx) {
-			.rsx_xprts         = &h->buh_net_xprt,
-			.rsx_xprts_nr      = 1,
-			.rsx_argv          = argv,
-			.rsx_argc          = ARRAY_SIZE(argv),
-			.rsx_log_file_name = NAME(".log"),
-		};
-#undef NAME
-		rc = m0_net_xprt_init(h->buh_net_xprt);
-		M0_ASSERT(rc == 0);
-		rc = m0_rpc_server_start(&h->buh_rpc_sctx);
-		M0_ASSERT(rc == 0);
-	}
+	struct be_ut_helper_struct *h = &be_ut_helper;
 	M0_CNT_INC(h->buh_reqh_ref_cnt);
-	reqh = m0_mero_to_rmach(&h->buh_rpc_sctx.rsx_mero_ctx)->rm_reqh;
-	M0_ASSERT(reqh != NULL);
-	m0_mutex_unlock(&h->buh_reqh_lock);
-
+	be_ut_helper_init_once();
+	M0_ALLOC_PTR(reqh);
+        result = M0_REQH_INIT(reqh,
+                              .rhia_dtm       = NULL,
+                              .rhia_db        = NULL,
+                              .rhia_mdstore   = NULL,
+                              .rhia_fol       = NULL,
+                              .rhia_svc       = (void*)1);
+        M0_ASSERT(result == 0);
 	return reqh;
 }
 
 void m0_be_ut_reqh_put(struct m0_reqh *reqh)
 {
-	struct be_ut_helper_struct *h = &be_ut_helper;
-	struct m0_reqh		   *reqh2;
 
-	m0_mutex_lock(&h->buh_reqh_lock);
-	reqh2 = m0_mero_to_rmach(&h->buh_rpc_sctx.rsx_mero_ctx)->rm_reqh;
-	M0_ASSERT(reqh == reqh2);
+	struct be_ut_helper_struct *h = &be_ut_helper;
+	m0_reqh_fini(reqh);
+	m0_free(reqh);
 	M0_CNT_DEC(h->buh_reqh_ref_cnt);
-	if (h->buh_reqh_ref_cnt == 0) {
-		m0_rpc_server_stop(&h->buh_rpc_sctx);
-		m0_net_xprt_fini(h->buh_net_xprt);
-	}
-	m0_mutex_unlock(&h->buh_reqh_lock);
 }
-#endif
 
 static pid_t gettid_impl()
 {
@@ -263,13 +235,12 @@ void m0_be_ut_backend_cfg_default(struct m0_be_domain_cfg *cfg)
 {
 	struct m0_reqh *reqh = cfg->bc_engine.bec_group_fom_reqh;
 
-	M0_LOG(M0_FATAL, "reqh: %p", reqh);
 	*cfg = (struct m0_be_domain_cfg) {
 		.bc_engine = {
 			.bec_group_nr	    = 1,
 			.bec_log_size	    = 1 << 27,
-			.bec_tx_size_max    = M0_BE_TX_CREDIT(1 << 18, 1 << 24),
-			.bec_group_size_max = M0_BE_TX_CREDIT(1 << 18, 1 << 24),
+			.bec_tx_size_max    = M0_BE_TX_CREDIT(1 << 18, 1 << 24),//(1 << 21, 1 << 26),//(1 << 18, 1 << 24),
+			.bec_group_size_max = M0_BE_TX_CREDIT(1 << 18, 1 << 24),//(1 << 22, 1 << 27),//(1 << 18, 1 << 24),
 			.bec_group_tx_max   = 20,
 			.bec_log_replay	    = false,
 			.bec_group_close_timeout = M0_TIME_ONE_MSEC,
@@ -281,18 +252,15 @@ void m0_be_ut_backend_cfg_default(struct m0_be_domain_cfg *cfg)
 M0_INTERNAL void m0_be_ut_backend_init_cfg(struct m0_be_ut_backend *ut_be,
 					   struct m0_be_domain_cfg *cfg)
 {
-	int rc;
+	int rc = 0;
 
 	//M0_SET0(ut_be);
 	ut_be->but_sm_groups_unlocked = false;
-	M0_LOG(M0_FATAL, "reqh: %p", ut_be->but_dom_cfg.bc_engine.bec_group_fom_reqh);
 	if (cfg == NULL) {
 		m0_be_ut_backend_cfg_default(&ut_be->but_dom_cfg);
 	} else {
 		ut_be->but_dom_cfg = *cfg;
 	}
-	ut_be->but_dom_cfg.bc_engine.bec_log_stob = m0_be_ut_stob_get(true);
-#ifndef REQH_EMU
 	/*
 	 * XXX
 	 * There is strange bug here. If m0_be_ut_stob_get() called before
@@ -309,20 +277,18 @@ M0_INTERNAL void m0_be_ut_backend_init_cfg(struct m0_be_ut_backend *ut_be,
 	 * This bug is similar to the one already encountered, and that bug was
 	 * not fixed.
 	 */
-	ut_be->but_dom_cfg.bc_engine.bec_group_fom_reqh = m0_be_ut_reqh_get();
-#endif
-	M0_LOG(M0_FATAL, "reqh: %p", ut_be->but_dom_cfg.bc_engine.bec_group_fom_reqh);
+	if (ut_be->but_dom_cfg.bc_engine.bec_group_fom_reqh == NULL)
+		ut_be->but_dom_cfg.bc_engine.bec_group_fom_reqh = m0_be_ut_reqh_get();
+	ut_be->but_dom_cfg.bc_engine.bec_log_stob = m0_be_ut_stob_get(true);
 	m0_mutex_init(&ut_be->but_sgt_lock);
 	rc = m0_be_domain_init(&ut_be->but_dom, &ut_be->but_dom_cfg);
 	M0_ASSERT_INFO(rc == 0, "rc = %d", rc);
-
 	if (rc != 0)
 		m0_mutex_fini(&ut_be->but_sgt_lock);
 }
 
 void m0_be_ut_backend_init(struct m0_be_ut_backend *ut_be)
 {
-	M0_LOG(M0_FATAL, "reqh: %p", ut_be->but_dom_cfg.bc_engine.bec_group_fom_reqh);
 	m0_be_ut_backend_init_cfg(ut_be, NULL);
 }
 
@@ -331,11 +297,11 @@ void m0_be_ut_backend_fini(struct m0_be_ut_backend *ut_be)
 	m0_forall(i, ut_be->but_sgt_size,
 		  m0_be_ut_sm_group_thread_fini(ut_be->but_sgt[i]), true);
 	m0_free(ut_be->but_sgt);
+	m0_be_engine_stop(&ut_be->but_dom.bd_engine);
 	m0_be_domain_fini(&ut_be->but_dom);
 	m0_mutex_fini(&ut_be->but_sgt_lock);
-#ifndef REQH_EMU
-	m0_be_ut_reqh_put(ut_be->but_dom_cfg.bc_engine.bec_group_fom_reqh);
-#endif
+	if (be_ut_helper.buh_reqh_ref_cnt > 0)
+		m0_be_ut_reqh_put(ut_be->but_dom_cfg.bc_engine.bec_group_fom_reqh);
 	m0_be_ut_stob_put(ut_be->but_dom_cfg.bc_engine.bec_log_stob, true);
 }
 
@@ -420,15 +386,15 @@ void m0_be_ut_backend_thread_exit(struct m0_be_ut_backend *ut_be)
 	m0_mutex_unlock(&ut_be->but_sgt_lock);
 }
 
-static void be_ut_tx_lock_if(struct m0_sm_group *grp,
-			     struct m0_be_ut_backend *ut_be)
+void be_ut_tx_lock_if(struct m0_sm_group *grp,
+		      struct m0_be_ut_backend *ut_be)
 {
 	if (ut_be->but_sm_groups_unlocked)
 		m0_sm_group_lock(grp);
 }
 
-static void be_ut_tx_unlock_if(struct m0_sm_group *grp,
-			       struct m0_be_ut_backend *ut_be)
+void be_ut_tx_unlock_if(struct m0_sm_group *grp,
+			struct m0_be_ut_backend *ut_be)
 {
 	if (ut_be->but_sm_groups_unlocked)
 		m0_sm_group_unlock(grp);
@@ -443,6 +409,19 @@ void m0_be_ut_tx_init(struct m0_be_tx *tx, struct m0_be_ut_backend *ut_be)
 	be_ut_tx_unlock_if(grp, ut_be);
 }
 
+void m0_be_ut_tx_prep(struct m0_be_tx *tx, struct m0_be_ut_backend *ut_be,
+		      struct m0_be_tx_credit *cred)
+{
+	be_ut_tx_lock_if(tx->t_sm.sm_grp, ut_be);
+	m0_be_tx_prep(tx, cred);
+}
+
+void m0_be_ut_tx_fini(struct m0_be_tx *tx, struct m0_be_ut_backend *ut_be)
+{
+	m0_be_tx_fini(tx);
+	be_ut_tx_unlock_if(tx->t_sm.sm_grp, ut_be);
+}
+
 struct m0_stob *m0_be_ut_stob_get_by_id(uint64_t id, bool stob_create)
 {
 	struct be_ut_helper_struct *h = &be_ut_helper;
@@ -593,11 +572,13 @@ static void be_ut_seg_allocator_initfini(struct m0_be_ut_seg *ut_seg,
 	struct m0_be_tx_credit	credit = {};
 	struct m0_be_allocator *a;
 	struct m0_be_tx         tx;
+	//struct m0_sm_group     *grp
 	int                     rc;
 
 	ut_seg->bus_allocator = m0_be_seg_allocator(&ut_seg->bus_seg);
 	a = ut_seg->bus_allocator;
-
+        //grp = m0_be_ut_backend_sm_group_lookup(ut_be);
+        //m0_sm_group_lock(grp);
 	if (ut_be != NULL) {
 		m0_be_ut_tx_init(&tx, ut_be);
 		be_ut_tx_lock_if(tx.t_sm.sm_grp, ut_be);
@@ -637,8 +618,6 @@ void m0_be_ut_seg_allocator_fini(struct m0_be_ut_seg *ut_seg,
 	be_ut_seg_allocator_initfini(ut_seg, ut_be, false);
 }
 
-#undef REQH_EMU
-
 M0_INTERNAL void m0_be_ut_txc_init(struct m0_be_ut_txc *tc)
 {
 	M0_PRE(tc->butc_seg_copy.b_addr == NULL);
diff --git a/be/ut/helper.h b/be/ut/helper.h
index 3dc1959..7a5142b 100644
--- a/be/ut/helper.h
+++ b/be/ut/helper.h
@@ -66,6 +66,9 @@ void m0_be_ut_backend_thread_exit(struct m0_be_ut_backend *ut_be);
 
 /* will work with single thread only */
 void m0_be_ut_tx_init(struct m0_be_tx *tx, struct m0_be_ut_backend *ut_be);
+void m0_be_ut_tx_prep(struct m0_be_tx *tx, struct m0_be_ut_backend *ut_be,
+		      struct m0_be_tx_credit *cred);
+void m0_be_ut_tx_fini(struct m0_be_tx *tx, struct m0_be_ut_backend *ut_be);
 
 struct m0_be_ut_seg {
 	/** Stob for segment */
@@ -83,6 +86,8 @@ void m0_be_ut_seg_init(struct m0_be_ut_seg *ut_seg,
 void m0_be_ut_seg_fini(struct m0_be_ut_seg *ut_seg);
 void m0_be_ut_seg_check_persistence(struct m0_be_ut_seg *ut_seg);
 void m0_be_ut_seg_reload(struct m0_be_ut_seg *ut_seg);
+void m0_be_ut_backend_get(struct m0_be_ut_backend **ut_be,
+                          struct m0_be_ut_seg **ut_seg);
 
 /*
  * tx capturing checker for UT.
diff --git a/be/ut/list.c b/be/ut/list.c
index 8136b75..79cbc4c 100644
--- a/be/ut/list.c
+++ b/be/ut/list.c
@@ -72,6 +72,7 @@ M0_INTERNAL void m0_be_ut_list_api(void)
 
 	M0_ENTRY();
 
+	M0_SET0(&ut_be);
 	/* Init BE. */
 	m0_be_ut_backend_init(&ut_be);
 	m0_be_ut_seg_init(&ut_seg, &ut_be, 1ULL << 24);
diff --git a/be/ut/seg_dict.c b/be/ut/seg_dict.c
index 741a5f9..ecb8053 100644
--- a/be/ut/seg_dict.c
+++ b/be/ut/seg_dict.c
@@ -118,6 +118,7 @@ void m0_be_ut_seg_dict(void)
 		{ "f00d", (void*)0xf00d },
 	};
 
+	M0_SET0(&ut_be);
 	m0_be_ut_backend_init(&ut_be);
 	m0_be_ut_seg_init(&ut_seg, &ut_be, 1 << 20);
 	m0_be_ut_seg_allocator_init(&ut_seg, &ut_be);
diff --git a/be/ut/tx.c b/be/ut/tx.c
index 467b171..8a95f04 100644
--- a/be/ut/tx.c
+++ b/be/ut/tx.c
@@ -39,6 +39,7 @@ void m0_be_ut_tx_usecase_success(void)
 	uint64_t               *data;
 	int                     rc;
 
+	M0_SET0(&ut_be);
 	m0_be_ut_backend_init(&ut_be);
 	m0_be_ut_seg_init(&ut_seg, &ut_be, 1 << 20);
 
@@ -73,6 +74,7 @@ void m0_be_ut_tx_usecase_failure(void)
 	struct m0_be_tx         tx;
 	int                     rc;
 
+	M0_SET0(&ut_be);
 	m0_be_ut_backend_init(&ut_be);
 
 	m0_be_ut_tx_init(&tx, &ut_be);
@@ -119,6 +121,7 @@ void m0_be_ut_tx_states(void)
 	uint64_t               *data;
 	int                     rc;
 
+	M0_SET0(&ut_be);
 	m0_be_ut_backend_init(&ut_be);
 	m0_be_ut_seg_init(&ut_seg, &ut_be, 1 << 20);
 
@@ -188,6 +191,7 @@ void m0_be_ut_tx_empty(void)
 		M0_BE_TX_CREDIT(1, sizeof(void *)),
 	};
 
+	M0_SET0(&ut_be);
 	m0_be_ut_backend_init(&ut_be);
 
 	for (i = 0; i < ARRAY_SIZE(credit); ++i) {
@@ -283,6 +287,7 @@ static void be_ut_tx_test(size_t nr)
 	M0_PRE(0 < nr && nr < ARRAY_SIZE(xs));
 	xs[nr].size = 0;
 
+	M0_SET0(&ut_be);
 	m0_be_ut_backend_init(&ut_be);
 	m0_be_ut_seg_init(&ut_seg, &ut_be, 1 << 20);
 	be_ut_tx_alloc_init(&alloc, &ut_seg.bus_seg);
@@ -359,10 +364,12 @@ void m0_be_ut_tx_persistence(void)
 	int                     j;
 	int                     rc;
 
+	M0_SET0(&ut_be);
 	m0_be_ut_backend_init(&ut_be);
 	m0_be_ut_seg_init(&ut_seg, &ut_be, BE_UT_TX_P_SEG_SIZE);
 
 	for (j = 0; j < BE_UT_TX_P_TX_NR; ++j) {
+		M0_SET0(&tx);
 		m0_be_ut_tx_init(&tx, &ut_be);
 
 		for (i = 0; i < ARRAY_SIZE(regs); ++i)
@@ -419,6 +426,7 @@ void m0_be_ut_tx_fast(void)
 	int                     i;
 	int                     rc;
 
+	M0_SET0(&ut_be);
 	m0_be_ut_backend_init(&ut_be);
 	m0_be_ut_seg_init(&ut_seg, &ut_be, BE_UT_TX_F_SEG_SIZE);
 
@@ -477,6 +485,7 @@ void m0_be_ut_tx_concurrent(void)
 	int                                 i;
 	int                                 rc;
 
+	M0_SET0(&ut_be);
 	m0_be_ut_backend_init(&ut_be);
 
 	for (i = 0; i < ARRAY_SIZE(threads); ++i) {
@@ -519,6 +528,7 @@ void m0_be_ut_tx_capturing(void)
 	int			 j;
 	int			 rc;
 
+	M0_SET0(&ut_be);
 	m0_be_ut_backend_init(&ut_be);
 	m0_be_ut_seg_init(&ut_seg, &ut_be, BE_UT_TX_CAPTURING_SEG_SIZE);
 	m0_be_ut_txc_init(&tc);
diff --git a/cm/ut/cm.c b/cm/ut/cm.c
index 2ccac28..43b0343 100644
--- a/cm/ut/cm.c
+++ b/cm/ut/cm.c
@@ -110,7 +110,9 @@ static void cm_setup_ut(void)
 	cm->cm_sw_update.swu_is_complete = true;
 	rc = m0_cm_stop(cm);
 	M0_UT_ASSERT(rc == 0);
-	m0_reqh_shutdown_wait(&cmut_rmach_ctx.rmc_reqh);
+	//m0_reqh_shutdown_wait(&cmut_rmach_ctx.rmc_reqh);
+	m0_reqh_shutdown(&cmut_rmach_ctx.rmc_reqh);
+	cm_cp_ut_fom_domain_idle_wait(&cmut_rmach_ctx.rmc_reqh);
 
 	reqh = cm_ut_service->rs_reqh;
 	pm = m0_ios_poolmach_get(reqh);
@@ -119,7 +121,6 @@ static void cm_setup_ut(void)
 	m0_sm_group_lock(grp);
 	m0_poolmach_store_destroy(pm, reqh->rh_beseg, grp, NULL);
 	m0_sm_group_unlock(grp);
-
 	m0_ios_poolmach_fini(cm_ut_service);
 	cm_ut_service_cleanup();
 }
diff --git a/cm/ut/common_service.c b/cm/ut/common_service.c
index 7f4d358..f768d45 100644
--- a/cm/ut/common_service.c
+++ b/cm/ut/common_service.c
@@ -272,6 +272,20 @@ int cm_ut_server_start(struct m0_mero *m0ctx, struct m0_net_xprt **xprts,
 	return rc;
 }
 
+void cm_cp_ut_fom_domain_idle_wait(struct m0_reqh *reqh)
+{
+        struct m0_clink clink;
+
+        M0_PRE(reqh != NULL);
+        m0_clink_init(&clink, NULL);
+        m0_clink_add_lock(&reqh->rh_sd_signal, &clink);
+
+        while (reqh->rh_fom_dom.fd_localities[0].fl_foms > 1)
+                m0_chan_timedwait(&clink, m0_time_from_now(2, 0));
+        m0_clink_del_lock(&clink);
+        m0_clink_fini(&clink);
+}
+
 M0_ADDB_CT(m0_addb_ct_ut_service, M0_ADDB_CTXID_UT_SERVICE, "hi", "low");
 /*
  *  Local variables:
diff --git a/cm/ut/common_service.h b/cm/ut/common_service.h
index 5c5ec48..e429cb5 100644
--- a/cm/ut/common_service.h
+++ b/cm/ut/common_service.h
@@ -80,6 +80,8 @@ void cm_ut_server_stop(struct m0_mero *mero_ctx);
 void cm_ut_service_alloc_init();
 void cm_ut_service_cleanup();
 
+void cm_cp_ut_fom_domain_idle_wait(struct m0_reqh *reqh);
+
 #endif /** __MERO_CM_UT_COMMON_SERVICE_H__ */
 /*
  *  Local variables:
diff --git a/cm/ut/cp.c b/cm/ut/cp.c
index da7562e..bddde1a 100644
--- a/cm/ut/cp.c
+++ b/cm/ut/cp.c
@@ -237,7 +237,9 @@ static void test_cp_single_thread(void)
          * Wait until all the foms in the request handler locality runq are
          * processed.
          */
-        m0_reqh_fom_domain_idle_wait(&cmut_rmach_ctx.rmc_reqh);
+        //m0_reqh_fom_domain_idle_wait(&cmut_rmach_ctx.rmc_reqh);
+
+	cm_cp_ut_fom_domain_idle_wait(&cmut_rmach_ctx.rmc_reqh);
 	m0_semaphore_fini(&sem);
 }
 
@@ -274,7 +276,8 @@ static void test_cp_multi_thread(void)
          * Wait until all the foms in the request handler locality runq are
          * processed.
          */
-        m0_reqh_fom_domain_idle_wait(&cmut_rmach_ctx.rmc_reqh);
+        //m0_reqh_fom_domain_idle_wait(&cmut_rmach_ctx.rmc_reqh);
+	cm_cp_ut_fom_domain_idle_wait(&cmut_rmach_ctx.rmc_reqh);
         m0_free(cp_thread);
 	m0_semaphore_fini(&sem);
 }
diff --git a/conf/db.c b/conf/db.c
index cab74fe..569d47f 100644
--- a/conf/db.c
+++ b/conf/db.c
@@ -384,6 +384,11 @@ M0_INTERNAL int m0_confdb_destroy(struct m0_be_seg *seg, struct m0_be_tx *tx)
 	int                     i;
 	int                     rc = 0;
 
+	/*
+	 * FIXME: Does not free the internal be objects allocated during
+	 *        confdb_create as part of xcode_dup operation.
+	 */
+
 	for (i = 0; i < ARRAY_SIZE(table_names); ++i) {
 		if (table_names[i] == NULL)
 			continue;
diff --git a/conf/ut/db.c b/conf/ut/db.c
index be600ba..b9bfdec 100644
--- a/conf/ut/db.c
+++ b/conf/ut/db.c
@@ -25,7 +25,9 @@
 #include "conf/obj.h"      /* m0_conf_objtype */
 #include "conf/preload.h"  /* m0_confstr_parse, m0_confx_free */
 #include "conf/ut/file_helpers.h"
+#include "reqh/reqh.h"
 #include "ut/ut.h"
+#include "ut/be.h"
 #include "be/ut/helper.h"
 
 #define _CONFDB_PATH "_conf.db"
@@ -33,6 +35,7 @@
 
 static struct m0_be_ut_backend ut_be;
 static struct m0_be_ut_seg     ut_seg;
+static struct m0_reqh          reqh;
 static struct m0_be_seg       *seg;
 
 /* ----------------------------------------------------------------
@@ -171,22 +174,29 @@ static void cleanup(void)
 
 static void conf_ut_db_init()
 {
-	struct m0_sm_group     *grp;
-	int                     rc;
-
-        m0_be_ut_backend_init(&ut_be);
-        m0_be_ut_seg_init(&ut_seg, &ut_be, 1ULL << 24);
-        m0_be_ut_seg_allocator_init(&ut_seg, &ut_be);
-	grp = m0_be_ut_backend_sm_group_lookup(&ut_be);
+	//struct m0_sm_group     *grp;
+	//int                     rc;
+
+        //m0_be_ut_backend_init(&ut_be);
+       // m0_be_ut_seg_init(&ut_seg, &ut_be, 1ULL << 24);
+       // m0_be_ut_seg_allocator_init(&ut_seg, &ut_be);
+	m0_ut_backend_init_with_reqh(&reqh, &ut_be, &ut_seg, 1ULL << 20);
+	//grp = m0_be_ut_backend_sm_group_lookup(&ut_be);
         seg = &ut_seg.bus_seg;
-        rc = m0_be_ut__seg_dict_create(seg, grp);
-        M0_UT_ASSERT(rc == 0);
+        //rc = m0_be_ut__seg_dict_create(seg, grp);
+        //M0_UT_ASSERT(rc == 0);
 }
 
 static void conf_ut_db_fini()
 {
+	/*
+	 * XXX: Call m0_ut_backend_fini_with_reqh() after
+	 *      fixing m0_confdb_destroy().
+	 */
+	//m0_ut_backend_fini_with_reqh(&reqh, &ut_be, &ut_seg);
         m0_be_ut_seg_fini(&ut_seg);
         m0_be_ut_backend_fini(&ut_be);
+	m0_reqh_fini(&reqh);
 }
 
 static int conf_ut_be_tx_create(struct m0_be_tx *tx,
diff --git a/db/db.c b/db/db.c
index 239abbe..f52364f 100644
--- a/db/db.c
+++ b/db/db.c
@@ -211,11 +211,10 @@ static void dbenv_seg_reset(const char *name)
 }
 
 int m0_dbenv_init(struct m0_dbenv *env, const char *name,
-			      uint64_t flags)
+		  uint64_t flags)
 {
 	struct m0_dbenv_impl *di = &env->d_i;
 
-	M0_LOG(M0_FATAL, "reqh: %p", di->d_ut_be.but_dom_cfg.bc_engine.bec_group_fom_reqh);
 	di->d_dom = &di->d_ut_be.but_dom;
 	di->d_seg = &di->d_ut_seg.bus_seg;
 	m0_be_ut_backend_init(&di->d_ut_be);
diff --git a/db/ut/db.c b/db/ut/db.c
index 6e391ed..fc4e4d2 100644
--- a/db/ut/db.c
+++ b/db/ut/db.c
@@ -32,6 +32,7 @@ static void test_db_create(void)
 	struct m0_dbenv db;
 	int             result;
 
+	M0_SET0(&db);
 	result = m0_dbenv_init(&db, db_name, 0);
 	M0_UT_ASSERT(result == 0);
 	m0_dbenv_fini(&db);
@@ -97,6 +98,7 @@ static void test_table_create(void)
 	struct m0_table table;
 	int             result;
 
+	M0_SET0(&db);
 	result = m0_dbenv_init(&db, db_name, 0);
 	M0_UT_ASSERT(result == 0);
 
@@ -117,6 +119,7 @@ static void test_lookup(void)
 	uint64_t          key;
 	uint64_t          rec;
 
+	M0_SET0(&db);
         dbut_init(db_name, test_table, &db, &table, &tx);
 
 	key = 42;
@@ -140,6 +143,7 @@ static void test_insert(void)
 	uint64_t          rec;
 	uint64_t          rec_out;
 
+	M0_SET0(&db);
         dbut_init(db_name, test_table, &db, &table, &tx);
 
 	key = 42;
@@ -162,6 +166,7 @@ static void test_insert(void)
 
 	/* and look up again */
 
+	M0_SET0(&db);
         dbut_init(db_name, test_table, &db, &table, &tx);
 
 	m0_db_pair_setup(&cons1, &table, &key, sizeof key,
@@ -186,6 +191,7 @@ static void test_delete(void)
 	uint64_t          rec;
 	uint64_t          rec_out;
 
+	M0_SET0(&db);
         dbut_init(db_name, test_table, &db, &table, &tx);
 
 	key = 43;
@@ -255,6 +261,7 @@ static void test_cursor_flags_read_only(void)
 	uint64_t            key;
 	uint64_t            rec;
 
+	M0_SET0(&db);
         dbut_init(db_name, test_table, &db, &table1, &tx1);
 
 	key = 11;
@@ -267,6 +274,7 @@ static void test_cursor_flags_read_only(void)
 	m0_db_pair_fini(&pair1);
         dbut_fini(&db, &table1, &tx1, &m0_db_tx_commit);
 
+	M0_SET0(&db);
         /* Get readonly cursor */
         dbut_init(db_name, test_table, &db, &table1, &tx1);
 
diff --git a/dtm/ut/transmit.c b/dtm/ut/transmit.c
index 25dbe2f..b71e69d 100644
--- a/dtm/ut/transmit.c
+++ b/dtm/ut/transmit.c
@@ -34,7 +34,6 @@
 #include "lib/errno.h"        /* EPROTO */
 #include "lib/assert.h"
 #include "lib/memory.h"
-
 #include "fop/fop.h"
 #include "fop/fom.h"
 #include "fop/fom_generic.h"
@@ -49,6 +48,7 @@
 #include "dtm/fol.h"
 #include "dtm/ltx.h"
 #include "dtm/dtm.h"
+#include "ut/be.h"
 
 M0_INTERNAL void up_print(const struct m0_dtm_up *up);
 M0_INTERNAL void op_print(const struct m0_dtm_op *op);
@@ -437,7 +437,8 @@ static void rpc_fop_fom_init(void)
 
 static void rpc_fop_fom_fini(void)
 {
-	m0_reqh_shutdown_wait(&test_ctx.rmc_reqh);
+	//m0_reqh_shutdown_wait(&test_ctx.rmc_reqh);
+	m0_ut_be_fom_domain_idle_wait(&test_ctx.rmc_reqh);
 	m0_reqh_service_stop(test_svc);
 	m0_reqh_service_fini(test_svc);
 	m0_reqh_service_type_unregister(&test_stype);
@@ -713,7 +714,8 @@ static void redo_test(void)
 
 	ticked = 0;
 	m0_dtm_history_reset(&tgt.lre_rem.re_fol.rfo_ch.ch_history, 2);
-	m0_reqh_fom_domain_idle_wait(&test_ctx.rmc_reqh);
+	//m0_reqh_fom_domain_idle_wait(&test_ctx.rmc_reqh);
+	m0_ut_be_fom_domain_idle_wait(&test_ctx.rmc_reqh);
 	M0_UT_ASSERT(ticked == OPER_NR);
 	tgt_fini();
 	src_fini();
diff --git a/fol/ut/fol.c b/fol/ut/fol.c
index 95b6af5..8249f94 100644
--- a/fol/ut/fol.c
+++ b/fol/ut/fol.c
@@ -34,6 +34,19 @@
 #include "ut/ut.h"
 #include "lib/ub.h"
 
+#if XXX_USE_DB5
+static const char db_name[] = "ut-fol";
+
+static struct m0_fol_rec_header *h;
+static struct m0_fol_rec_desc   *d;
+static struct m0_fol             fol;
+static struct m0_fol_rec         r;
+static struct m0_fol_rec_desc   *d;
+static struct m0_fol_rec_header *hh;
+static struct m0_buf             buf;
+static struct m0_dbenv           db;
+static struct m0_db_tx           tx;
+#else
 static struct m0_fol            *g_fol;
 static struct m0_fol_rec_header *g_hdr;
 static struct m0_fol_rec_desc   *g_desc;
@@ -67,7 +80,7 @@ static void test_init(void)
 	m0_ut_be_tx_begin(&g_tx, &g_ut_be, &cred);
 
 	M0_BE_OP_SYNC(op,
-		      rc = m0_fol_create(g_fol, &g_tx, &op));
+			rc = m0_fol_create(g_fol, &g_tx, &op));
 	M0_UT_ASSERT(rc == 0);
 
 	m0_fol_rec_init(&g_rec);
diff --git a/ioservice/ut/bulkio_ut.c b/ioservice/ut/bulkio_ut.c
index f44c43e..63c7de2 100644
--- a/ioservice/ut/bulkio_ut.c
+++ b/ioservice/ut/bulkio_ut.c
@@ -1760,7 +1760,7 @@ static void bulkio_fini(void)
 	for (i = 0; i < IO_FIDS_NR; ++i)
 		m0_file_fini(&bp->bp_file[i]);
 	reqh = m0_cs_reqh_get(&bp->bp_sctx->rsx_mero_ctx, "ioservice");
-	m0_reqh_fom_domain_idle_wait(reqh);
+	//m0_reqh_fom_domain_idle_wait(reqh);
 	bulkio_client_stop(bp->bp_cctx);
 	bulkio_server_stop(bp->bp_sctx);
 	m0_addb_mc_fini(&m0_addb_gmc);
diff --git a/ioservice/ut/cob_foms.c b/ioservice/ut/cob_foms.c
index 5f1abb2..112b436 100644
--- a/ioservice/ut/cob_foms.c
+++ b/ioservice/ut/cob_foms.c
@@ -22,6 +22,7 @@
 #include "lib/locality.h"
 #include "lib/finject.h"
 #include "ut/ut.h"
+#include "ut/be.h"
 #include "lib/memory.h"
 #include "net/lnet/lnet.h"
 #include "rpc/rpclib.h"                  /* m0_rpc_server_ctx */
@@ -518,7 +519,8 @@ static void fom_fini_test(enum cob_fom_type fomtype)
 	 *    stray foms around.
 	 */
 	reqh = m0_cs_reqh_get(&cut->cu_sctx.rsx_mero_ctx, "ioservice");
-	m0_reqh_fom_domain_idle_wait(reqh);
+	//m0_reqh_fom_domain_idle_wait(reqh);
+	m0_ut_be_fom_domain_idle_wait(reqh);
 
 	base_mem = m0_allocated();
 	fom_create(&fom, fomtype);
@@ -1199,7 +1201,8 @@ static int cob_cd_op(struct m0_fol_rec *rec, struct m0_fop *fop, bool undo) {
 				 ftype->ft_ops->fto_undo(fp_part, rec->fr_fol) :
 				 ftype->ft_ops->fto_redo(fp_part, rec->fr_fol);
 			M0_UT_ASSERT(result == 0);
-			m0_reqh_fom_domain_idle_wait(rec->fr_fol->f_reqh);
+			//m0_reqh_fom_domain_idle_wait(rec->fr_fol->f_reqh);
+			m0_ut_be_fom_domain_idle_wait(rec->fr_fol->f_reqh);
 		}
 	} m0_tl_endfor;
 
diff --git a/layout/ut/layout.c b/layout/ut/layout.c
index 9656c6a..a997b6a 100644
--- a/layout/ut/layout.c
+++ b/layout/ut/layout.c
@@ -134,6 +134,7 @@ static void test_domain_init_fini(void)
 
 	M0_ENTRY();
 
+	M0_SET0(&t_dbenv);
 	rc = m0_dbenv_init(&t_dbenv, t_db_name, DBFLAGS);
 	M0_UT_ASSERT(rc == 0);
 
@@ -163,6 +164,7 @@ static void test_domain_init_fini_failure(void)
 	struct m0_dbenv         t_dbenv;
 
 	M0_ENTRY();
+	M0_SET0(&t_dbenv);
 	rc = m0_dbenv_init(&t_dbenv, t_db_name, DBFLAGS);
 	M0_UT_ASSERT(rc == 0);
 
@@ -282,6 +284,7 @@ static void test_reg_unreg(void)
 	 */
 	m0_layout_standard_types_unregister(&domain);
 
+	M0_SET0(&t_dbenv);
 	rc = m0_dbenv_init(&t_dbenv, t_db_name, DBFLAGS);
 	M0_UT_ASSERT(rc == 0);
 
@@ -358,6 +361,7 @@ static void test_reg_unreg_failure(void)
 	 */
 	m0_layout_standard_types_unregister(&domain);
 
+	M0_SET0(&t_dbenv);
 	rc = m0_dbenv_init(&t_dbenv, t_db_name, DBFLAGS);
 	M0_UT_ASSERT(rc == 0);
 
@@ -2208,6 +2212,7 @@ static void test_max_recsize(void)
 	 */
 	m0_layout_standard_types_unregister(&domain);
 
+	M0_SET0(&t_dbenv);
 	rc = m0_dbenv_init(&t_dbenv, t_db_name, DBFLAGS);
 	M0_UT_ASSERT(rc == 0);
 
diff --git a/lib/time.c b/lib/time.c
index bee927c..9f558f5 100644
--- a/lib/time.c
+++ b/lib/time.c
@@ -59,14 +59,14 @@ m0_time_t m0_time_sub(const m0_time_t t1, const m0_time_t t2)
 	m0_time_t res;
 	M0_PRE(M0_TIME_NEVER >= t1);
 	M0_PRE(t2 < M0_TIME_NEVER);
-	M0_PRE(t1 >= t2);
+	//M0_PRE(t1 >= t2);
 
 	if (t1 == M0_TIME_NEVER)
 		res = M0_TIME_NEVER;
 	else
 		res = t1 - t2;
 
-	M0_POST(t1 >= res);
+	//M0_POST(t1 >= res);
 	return res;
 }
 M0_EXPORTED(m0_time_sub);
diff --git a/mero/setup.c b/mero/setup.c
index 59a4064..4a0801b 100644
--- a/mero/setup.c
+++ b/mero/setup.c
@@ -1051,15 +1051,9 @@ static void cs_storage_fini(struct cs_stobs *stob)
 		yaml_document_delete(&stob->s_sfile.sf_document);
 }
 
-/**
-   Initialises and starts a particular service.
-
-   Once the service is initialised, it is started and registered with the
-   appropriate request handler.
- */
-static int
-cs_service_init(const char *name, struct m0_reqh_context *rctx,
-		struct m0_reqh *reqh, struct m0_uint128 *uuid, bool mgmt)
+static int __service_init(const char *name, struct m0_reqh_context *rctx,
+			  struct m0_reqh *reqh, struct m0_uint128 *uuid,
+			  bool mgmt)
 {
 	struct m0_reqh_service_type *stype;
 	struct m0_reqh_service      *service;
@@ -1079,19 +1073,35 @@ cs_service_init(const char *name, struct m0_reqh_context *rctx,
 	m0_reqh_service_init(service, reqh, uuid);
 
 	/** @todo Remove the USE_MGMT_STARTUP macro later */
-//#define USE_MGMT_STARTUP 1
-//#if USE_MGMT_STARTUP
 	if (mgmt)
 		rc = m0_mgmt_reqh_service_start(service);
-//#else
 	else
 		rc = m0_reqh_service_start(service);
-//#endif
 	if (rc != 0)
 		m0_reqh_service_fini(service);
 
 	M0_POST(ergo(rc == 0, m0_reqh_service_invariant(service)));
 	M0_RETURN(rc);
+
+}
+
+/**
+   Initialises and starts a particular service.
+
+   Once the service is initialised, it is started and registered with the
+   appropriate request handler.
+ */
+static int
+cs_service_init(const char *name, struct m0_reqh_context *rctx,
+		struct m0_reqh *reqh, struct m0_uint128 *uuid)
+{
+	/** @todo Remove the USE_MGMT_STARTUP macro later */
+#define USE_MGMT_STARTUP 0
+#if USE_MGMT_STARTUP
+	return __service_init(name, rctx, reqh, uuid, true);
+#else
+	return __service_init(name, rctx, reqh, uuid, false);
+#endif
 }
 
 static int reqh_services_init(struct m0_reqh_context *rctx)
@@ -1106,7 +1116,7 @@ static int reqh_services_init(struct m0_reqh_context *rctx)
 	for (i = 0, rc = 0; i < rctx->rc_nr_services && rc == 0; ++i) {
 		name = rctx->rc_services[i];
 		rc = cs_service_init(name, rctx, &rctx->rc_reqh,
-				     &rctx->rc_service_uuids[i], true);
+				     &rctx->rc_service_uuids[i]);
 	}
 #if USE_MGMT_STARTUP
 	/* Do not terminate on failure here as services start asynchronously. */
@@ -1139,9 +1149,9 @@ static int cs_services_init(struct m0_mero *cctx)
 			break;
 		m0_reqh_start(&rctx->rc_reqh);
 		rc = cs_service_init("rpcservice", NULL, &rctx->rc_reqh,
-				     NULL, true) ?:
+				     NULL) ?:
 		     cs_service_init("simple fom service", NULL, &rctx->rc_reqh,
-				     NULL, true) ?:
+				     NULL) ?:
 			reqh_services_init(rctx);
 		m0_mgmt_reqh_services_start_wait(&rctx->rc_reqh);
 		/* return failure if any service has failed */
@@ -1154,9 +1164,9 @@ static int cs_services_init(struct m0_mero *cctx)
 #else
 		rc = m0_reqh_mgmt_service_start(&rctx->rc_reqh) ?:
 			cs_service_init("rpcservice", NULL, &rctx->rc_reqh,
-					NULL, true) ?:
+					NULL) ?:
 			cs_service_init("simple fom service", NULL, &rctx->rc_reqh,
-					NULL, true) ?:
+					NULL) ?:
 			reqh_services_init(rctx);
 		if (rc != 0)
 			break;
@@ -1331,6 +1341,18 @@ static void cs_addb_storage_fini(struct cs_addb_stob *addb_stob)
 	cs_storage_fini(&addb_stob->cas_stobs);
 }
 
+static void cs_reqh_be_tx_svc_stop(struct m0_reqh *reqh)
+{
+	struct m0_reqh_service *svc;
+
+	svc = m0_reqh_service_find(m0_reqh_service_type_find("be-tx-service"),
+				   reqh);
+	if (M0_IN(m0_reqh_service_state_get(svc),
+				(M0_RST_STARTED, M0_RST_STOPPING)))
+		m0_reqh_service_stop(svc);
+	m0_reqh_service_fini(svc);
+}
+
 /**
    Initialises a request handler context.
    A request handler context consists of the storage domain, database,
@@ -1360,7 +1382,7 @@ static int cs_request_handler_start(struct m0_reqh_context *rctx)
 	if (rc != 0)
 		goto out;
 
-	rc = cs_service_init("be-tx-service", rctx, &rctx->rc_reqh, NULL, false);
+	rc = __service_init("be-tx-service", rctx, &rctx->rc_reqh, NULL, false);
 	if (rc != 0)
 		goto reqh_fini;
 	rctx->rc_db.d_i.d_ut_be.but_dom_cfg.bc_engine.bec_group_fom_reqh = &rctx->rc_reqh;
@@ -1448,6 +1470,7 @@ reqh_dbenv_fini:
 dbenv_fini:
 	m0_dbenv_fini(&rctx->rc_db);
 reqh_fini:
+	cs_reqh_be_tx_svc_stop(&rctx->rc_reqh);
 	m0_reqh_fini(&rctx->rc_reqh);
 out:
 	M0_ASSERT(rc != 0);
@@ -1499,6 +1522,9 @@ static void cs_request_handler_stop(struct m0_reqh_context *rctx)
 
 	if (m0_reqh_state_get(reqh) == M0_REQH_ST_NORMAL)
 		m0_reqh_shutdown(reqh);
+	cs_storage_fini(&rctx->rc_stob);
+	/* Stop m0_be_tx_group_fom */
+	m0_be_engine_stop(&rctx->rc_db.d_i.d_ut_be.but_dom.bd_engine);
 	m0_reqh_fom_domain_idle_wait(reqh);
 
 	if (m0_reqh_state_get(reqh) == M0_REQH_ST_DRAIN ||
@@ -1513,7 +1539,7 @@ static void cs_request_handler_stop(struct m0_reqh_context *rctx)
 	m0_reqh_dbenv_fini(reqh);
 	m0_mdstore_fini(&rctx->rc_mdstore);
 	cs_addb_storage_fini(&rctx->rc_addb_stob);
-	cs_storage_fini(&rctx->rc_stob);
+	//cs_storage_fini(&rctx->rc_stob);
 	m0_dbenv_fini(&rctx->rc_db);
 	cs_rpc_machines_fini(reqh);
 	m0_reqh_fini(reqh);
diff --git a/pool/ut/test_pm.c b/pool/ut/test_pm.c
index 2fb6c3b..d599ed2 100644
--- a/pool/ut/test_pm.c
+++ b/pool/ut/test_pm.c
@@ -78,6 +78,9 @@ static void pm_test_init_fini(void)
 	struct m0_poolmach pm;
 	int                rc = 0;
 
+	M0_SET0(&dbenv);
+	rc = m0_dbenv_init(&dbenv, "pm_testing", 0);
+	M0_ASSERT(rc == 0);
 	M0_SET0(&pm);
 	rc = m0_poolmach_init(&pm, be_seg, sm_grp, NULL,
 					 PM_TEST_DEFAULT_NODE_NUMBER,
@@ -106,6 +109,11 @@ static void pm_test_transit(void)
 	struct m0_be_tx_credit         cred = {};
 	struct m0_be_tx                tx;
 
+	M0_SET0(&dbenv);
+	rc = m0_dbenv_init(&dbenv, "pm_test_transit", 0);
+	M0_ASSERT(rc == 0);
+	rc = m0_db_tx_init(&tx, &dbenv, 0);
+	M0_UT_ASSERT(rc == 0);
 	M0_SET0(&pm);
 	rc = m0_poolmach_init(&pm, be_seg, sm_grp, NULL,
 					 PM_TEST_DEFAULT_NODE_NUMBER,
@@ -427,6 +435,11 @@ static void pm_test_spare_slot(void)
 	struct m0_be_tx       tx;
 	struct m0_be_tx_credit cred = {};
 
+	M0_SET0(&dbenv);
+	rc = m0_dbenv_init(&dbenv, "pm_test_spare_slot", 0);
+	M0_ASSERT(rc == 0);
+	rc = m0_db_tx_init(&tx, &dbenv, 0);
+	M0_UT_ASSERT(rc == 0);
 	M0_SET0(&pm);
 	rc = m0_poolmach_init(&pm, be_seg, sm_grp, NULL,
 					 PM_TEST_DEFAULT_NODE_NUMBER,
@@ -592,6 +605,8 @@ static void pm_test_multi_fail(void)
 	struct m0_be_tx       tx;
 	struct m0_be_tx_credit cred = {};
 
+	M0_SET0(&dbenv);
+	rc = m0_dbenv_init(&dbenv, "pm_test_multi_fail", 0);
 	M0_ASSERT(rc == 0);
 	M0_UT_ASSERT(rc == 0);
 	M0_SET0(&pm);
@@ -781,6 +796,8 @@ static void pm_test_load_from_persistent_storage(void)
 	struct m0_poolmach pm;
 	int                rc = 0;
 
+	M0_SET0(&dbenv);
+	rc = m0_dbenv_init(&dbenv, "pm_test_multi_fail", 0);
 	M0_ASSERT(rc == 0);
 	M0_SET0(&pm);
 	rc = m0_poolmach_init(&pm, be_seg, sm_grp, NULL,
diff --git a/sns/cm/repair/ut/cm.c b/sns/cm/repair/ut/cm.c
index 26cf38f..6ca8006 100644
--- a/sns/cm/repair/ut/cm.c
+++ b/sns/cm/repair/ut/cm.c
@@ -46,6 +46,8 @@
 #include "sns/cm/cm.h"
 #include "sns/cm/repair/ut/cp_common.h"
 
+#include "cm/ut/common_service.h"
+
 enum {
 	ITER_UT_BUF_NR     = 1 << 8,
 	ITER_GOB_KEY_START = 4,
diff --git a/sns/cm/repair/ut/net.c b/sns/cm/repair/ut/net.c
index 2c243cc..6849ca4 100644
--- a/sns/cm/repair/ut/net.c
+++ b/sns/cm/repair/ut/net.c
@@ -31,6 +31,7 @@
 #include "reqh/reqh_service.h"
 #include "cm/proxy.h"
 #include "ut/ut_rpc_machine.h"
+#include "cm/ut/common_service.h"
 #include <unistd.h>			/* usleep */
 
 /* import from pool/pool_store.c */
@@ -763,7 +764,8 @@ static void sender_fini()
         rc = m0_rpc_client_stop(&cctx);
         M0_UT_ASSERT(rc == 0);
         m0_net_domain_fini(&client_net_dom);
-	m0_reqh_fom_domain_idle_wait(&rmach_ctx.rmc_reqh);
+	//m0_reqh_fom_domain_idle_wait(&rmach_ctx.rmc_reqh);
+	cm_cp_ut_fom_domain_idle_wait(&rmach_ctx.rmc_reqh);
 	reqh = sender_cm_service->rs_reqh;
 	pm = m0_ios_poolmach_get(reqh);
 	grp  = m0_locality0_get()->lo_grp;
diff --git a/sns/cm/repair/ut/storage.c b/sns/cm/repair/ut/storage.c
index 724835e..61f3350 100644
--- a/sns/cm/repair/ut/storage.c
+++ b/sns/cm/repair/ut/storage.c
@@ -30,6 +30,7 @@
 #include "mero/setup.h"
 #include "net/net.h"
 #include "sns/cm/repair/ut/cp_common.h"
+#include "cm/ut/common_service.h"
 
 struct m0_reqh_service          *service;
 static struct m0_reqh           *reqh;
@@ -247,7 +248,8 @@ void write_post(void)
 	 * Wait until all the foms in the request handler locality runq are
 	 * processed. This is required for further validity checks.
 	 */
-	m0_reqh_fom_domain_idle_wait(reqh);
+	//m0_reqh_fom_domain_idle_wait(reqh);
+	cm_cp_ut_fom_domain_idle_wait(reqh);
 }
 
 const struct m0_cm_cp_ops read_cp_dummy_ops = {
@@ -296,7 +298,8 @@ static void read_post(void)
          * Wait until all the foms in the request handler locality runq are
          * processed. This is required for further validity checks.
          */
-	m0_reqh_fom_domain_idle_wait(reqh);
+	//m0_reqh_fom_domain_idle_wait(reqh);
+	cm_cp_ut_fom_domain_idle_wait(reqh);
 }
 
 static void test_cp_write_read(void)
diff --git a/sns/cm/repair/ut/xform.c b/sns/cm/repair/ut/xform.c
index 447ea7d..4f896f6 100644
--- a/sns/cm/repair/ut/xform.c
+++ b/sns/cm/repair/ut/xform.c
@@ -24,6 +24,7 @@
 #include "mero/setup.h"
 #include "sns/cm/repair/xform.c"
 #include "sns/cm/repair/ut/cp_common.h"
+#include "cm/ut/common_service.h"
 
 enum {
 	SEG_NR                  = 16,
@@ -338,7 +339,8 @@ static void test_single_cp(void)
 	 * Wait until all the foms in the request handler locality runq are
 	 * processed. This is required for further validity checks.
 	 */
-	m0_reqh_fom_domain_idle_wait(reqh);
+	//m0_reqh_fom_domain_idle_wait(reqh);
+	cm_cp_ut_fom_domain_idle_wait(reqh);
 
 	/*
 	 * These asserts ensure that the single copy packet has been treated
@@ -384,7 +386,8 @@ static void test_multi_cp_single_failure(void)
 	 * Wait until the fom in the request handler locality runq is
 	 * processed. This is required for further validity checks.
 	 */
-	m0_reqh_fom_domain_idle_wait(reqh);
+	//m0_reqh_fom_domain_idle_wait(reqh);
+	cm_cp_ut_fom_domain_idle_wait(reqh);
 
 	/*
 	 * These asserts ensure that all the copy packets have been collected
@@ -519,7 +522,8 @@ static void test_multi_cp_multi_failures(void)
          * Wait until the fom in the request handler locality runq is
          * processed. This is required for further validity checks.
          */
-        m0_reqh_fom_domain_idle_wait(reqh);
+        //m0_reqh_fom_domain_idle_wait(reqh);
+	cm_cp_ut_fom_domain_idle_wait(reqh);
 
 	/* Verify that first accumulator contains recovered data for D1. */
 	bv_populate(&src, 's', SEG_NR, SEG_SIZE);
diff --git a/ut/be.c b/ut/be.c
index bbe4e51..7a4deeb 100644
--- a/ut/be.c
+++ b/ut/be.c
@@ -29,6 +29,8 @@
 #include "be/ut/helper.h"  /* m0_be_ut_backend */
 #include "lib/misc.h"      /* M0_BITS */
 
+#include "reqh/reqh.h"
+
 M0_INTERNAL void
 m0_ut_backend_init(struct m0_be_ut_backend *be, struct m0_be_ut_seg *seg)
 {
@@ -40,7 +42,7 @@ m0_ut_backend_init(struct m0_be_ut_backend *be, struct m0_be_ut_seg *seg)
 M0_INTERNAL void
 m0_ut_backend_fini(struct m0_be_ut_backend *be, struct m0_be_ut_seg *seg)
 {
-	m0_be_ut_seg_allocator_fini(seg, be);
+//	m0_be_ut_seg_allocator_fini(seg, be);
 	m0_be_ut_seg_fini(seg);
 	m0_be_ut_backend_fini(be);
 }
@@ -99,6 +101,75 @@ M0_INTERNAL void m0_ut_be_free(void *ptr, m0_bcount_t size,
 	m0_ut_be_tx_end(&tx);
 }
 
+M0_INTERNAL void m0_ut_backend_init_with_reqh(struct m0_reqh *reqh,
+					      struct m0_be_ut_backend *be,
+					      struct m0_be_ut_seg *seg,
+					      m0_bcount_t seg_size)
+{
+	int rc;
+
+	rc = M0_REQH_INIT(reqh,
+			  .rhia_dtm       = NULL,
+			  .rhia_db        = NULL,
+			  .rhia_mdstore   = (void*)1,
+			  .rhia_fol       = NULL,
+			  .rhia_svc       = (void*)1);
+	M0_ASSERT(rc == 0);
+	be->but_dom_cfg.bc_engine.bec_group_fom_reqh = reqh;
+	m0_be_ut_backend_init(be);
+	m0_be_ut_seg_init(seg, be, seg_size);
+	m0_be_ut_seg_allocator_init(seg, be);
+	//m0_ut_backend_init(be, seg);
+	rc = m0_be_ut__seg_dict_create(&seg->bus_seg,
+				       m0_be_ut_backend_sm_group_lookup(be));
+	M0_ASSERT(rc == 0);
+}
+
+M0_INTERNAL void m0_ut_backend_fini_with_reqh(struct m0_reqh *reqh,
+					      struct m0_be_ut_backend *be,
+					      struct m0_be_ut_seg *seg)
+{
+	int rc;
+
+	rc = m0_be_ut__seg_dict_destroy(&seg->bus_seg,
+					m0_be_ut_backend_sm_group_lookup(be));
+	M0_ASSERT(rc == 0);
+	m0_be_ut_seg_allocator_fini(seg, be);
+	m0_ut_backend_fini(be, seg);
+	m0_reqh_fini(reqh);
+}
+
+static bool fom_domain_is_idle(const struct m0_fom_domain *dom)
+{
+	int  i;
+	bool result = false;
+
+	for (i = 0; i < dom->fd_localities_nr; ++i) {
+		if ((i == 0 &&
+			dom->fd_localities[i].fl_foms == 1) ||
+			dom->fd_localities[i].fl_foms == 0)
+			result = true;
+		else
+			return false;
+	}
+
+	return result;
+}
+
+void m0_ut_be_fom_domain_idle_wait(struct m0_reqh *reqh)
+{
+	struct m0_clink clink;
+
+	M0_PRE(reqh != NULL);
+	m0_clink_init(&clink, NULL);
+	m0_clink_add_lock(&reqh->rh_sd_signal, &clink);
+	if (!fom_domain_is_idle(&reqh->rh_fom_dom))
+		m0_chan_timedwait(&clink, m0_time_from_now(2, 0));
+	m0_clink_del_lock(&clink);
+	m0_clink_fini(&clink);
+}
+
+
 /** @} end of be group */
 
 /*
diff --git a/ut/be.h b/ut/be.h
index bce320a..a7d3a9d 100644
--- a/ut/be.h
+++ b/ut/be.h
@@ -31,6 +31,7 @@ struct m0_be_tx;
 struct m0_be_seg;
 struct m0_be_ut_backend;
 struct m0_be_ut_seg;
+struct m0_reqh;
 
 /**
  * @addtogroup ut
@@ -68,6 +69,17 @@ M0_INTERNAL void m0_ut_be_free(void *ptr, m0_bcount_t size,
 			       struct m0_be_seg *seg,
 			       struct m0_be_ut_backend *ut_be);
 
+M0_INTERNAL void m0_ut_be_fom_domain_idle_wait(struct m0_reqh *reqh);
+
+M0_INTERNAL void m0_ut_backend_init_with_reqh(struct m0_reqh *reqh,
+					      struct m0_be_ut_backend *be,
+					      struct m0_be_ut_seg *seg,
+					      m0_bcount_t seg_size);
+
+M0_INTERNAL void m0_ut_backend_fini_with_reqh(struct m0_reqh *reqh,
+					      struct m0_be_ut_backend *be,
+					      struct m0_be_ut_seg *seg);
+
 /** @} end of ut group */
 #endif /* __MERO_UT_BE_H__ */
 
diff --git a/ut/ut_rpc_machine.c b/ut/ut_rpc_machine.c
index 57864c5..3a033b4 100644
--- a/ut/ut_rpc_machine.c
+++ b/ut/ut_rpc_machine.c
@@ -76,6 +76,7 @@ M0_INTERNAL void m0_ut_rpc_mach_init_and_add(struct m0_ut_rpc_mach_ctx *ctx)
 			  .rhia_svc       = (void*)1);
 	M0_ASSERT(rc == 0);
 
+	ctx->rmc_ut_be.but_dom_cfg.bc_engine.bec_group_fom_reqh = &ctx->rmc_reqh;
 	m0_ut_backend_init(&ctx->rmc_ut_be, &ctx->rmc_ut_seg);
 	seg = &ctx->rmc_ut_seg.bus_seg;
 	grp = m0_be_ut_backend_sm_group_lookup(&ctx->rmc_ut_be);
@@ -124,14 +125,9 @@ M0_INTERNAL void m0_ut_rpc_mach_fini(struct m0_ut_rpc_mach_ctx *ctx)
 
 	if (m0_reqh_state_get(&ctx->rmc_reqh) == M0_REQH_ST_NORMAL)
 		m0_reqh_shutdown(&ctx->rmc_reqh);
-	m0_reqh_fom_domain_idle_wait(&ctx->rmc_reqh);
-
 	m0_reqh_services_terminate(&ctx->rmc_reqh);
 	M0_ASSERT(m0_reqh_state_get(&ctx->rmc_reqh) == M0_REQH_ST_STOPPED);
-
 	m0_reqh_fol_destroy(&ctx->rmc_reqh);
-	m0_reqh_dbenv_fini(&ctx->rmc_reqh);
-
 	grp = m0_be_ut_backend_sm_group_lookup(&ctx->rmc_ut_be);
 	rc = m0_mdstore_destroy(&ctx->rmc_mdstore, grp);
 	M0_ASSERT(rc == 0);
@@ -139,6 +135,11 @@ M0_INTERNAL void m0_ut_rpc_mach_fini(struct m0_ut_rpc_mach_ctx *ctx)
 
 	rc = m0_be_ut__seg_dict_destroy(&ctx->rmc_ut_seg.bus_seg, grp);
 	M0_ASSERT(rc == 0);
+	m0_be_ut_seg_allocator_fini(&ctx->rmc_ut_seg, &ctx->rmc_ut_be);
+	m0_be_engine_stop(&ctx->rmc_ut_be.but_dom.bd_engine);
+	m0_reqh_fom_domain_idle_wait(&ctx->rmc_reqh);
+
+	m0_reqh_dbenv_fini(&ctx->rmc_reqh);
 	m0_ut_backend_fini(&ctx->rmc_ut_be, &ctx->rmc_ut_seg);
 
 	m0_reqh_fini(&ctx->rmc_reqh);
-- 
1.8.3.2

