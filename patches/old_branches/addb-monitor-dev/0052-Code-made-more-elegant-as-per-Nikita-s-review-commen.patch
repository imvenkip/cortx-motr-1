From ab85667536e03aa159aa760d5fe5d54c973f26db Mon Sep 17 00:00:00 2001
From: Rohan Puri <rohan_puri@xyratex.com>
Date: Mon, 2 Sep 2013 18:36:25 +0530
Subject: [PATCH 052/125] Code made more elegant as per Nikita's review
 comments.

---
 addb/addb_monitor.c | 204 +++++++++++++++++++++++-----------------------------
 addb/addb_monitor.h |   4 +-
 addb/addb_pfom.c    |   3 +-
 addb/addb_svc.h     |  24 ++++---
 4 files changed, 110 insertions(+), 125 deletions(-)

diff --git a/addb/addb_monitor.c b/addb/addb_monitor.c
index f72dbb2..cf72238 100644
--- a/addb/addb_monitor.c
+++ b/addb/addb_monitor.c
@@ -236,140 +236,116 @@ M0_INTERNAL void m0_addb_monitors_fini(struct m0_reqh *reqh)
 #define SUM_SIZE(sum) (sum->asr_rec.asrw_rec.au64s_nr * sizeof(uint64_t))
 
 enum {
-	START = 1,
-	BATCH = 1024
+	/**
+	 * How many records to send in one fop
+	 */
+	BATCH = 1024,
+	/**
+	 * Maximal number of records (dirty or clean) scanned in one
+	 * invocation of m0_addb_monitor_summaries_post(). This limits
+	 * processor consumption.
+	 */
+	SCANNED_LIMIT = 16 * 1024,
+	/**
+	 * Maximal number of fops that can be sent in one invocation of
+	 * m0_addb_monitor_summaries_post().
+	 */
+	SENT_LIMIT = 3
 };
 
-static uint32_t mon_list_get_dirtied_count(struct m0_reqh *reqh,
-				           struct m0_tl *mon_list,
-					   uint32_t where)
-{
-	struct m0_addb_monitor *mon;
-	struct m0_addb_sum_rec *sum_rec =  NULL;
-	int                     i = 0;
-	uint32_t                dirtied_count = 0;
-
-	M0_PRE(where <addb_mon_tlist_length(mon_list));
-
-	m0_tl_for(addb_mon, mon_list, mon) {
-		++i;
-		if (i < where)
-			continue;
-		sum_rec = mon->am_ops->amo_sum_rec(mon, reqh);
-		if (sum_rec && sum_rec->asr_dirty)
-			++dirtied_count;
-	}m0_tl_endfor;
-
-	M0_RETURN(dirtied_count);
-}
-
-M0_INTERNAL int m0_addb_monitor_summaries_post(struct m0_reqh *reqh)
+M0_INTERNAL int m0_addb_monitor_summaries_post(struct m0_reqh *reqh,
+					      struct addb_post_fom *fom)
 {
-	struct m0_addb_monitor       *mon;
-	struct m0_addb_sum_rec_fop   *sum_recs_fop;
-	uint32_t		      dirtied_mon_cnt;
-	uint32_t                      fop_mon_cnt = 0;
-	uint32_t                      dirtied_scanned = 0;
-	uint32_t                      scanned = 0;
-	struct m0_tl                 *mon_list;
-	int                           i = 0;
-	int                           idx = 0;
-	int                           rc = 0;
+	struct m0_tl           *mon_list;
+	/* Continue scanning from the place we left last time */
+	struct m0_addb_monitor *mon    = fom->pf_mon;
+	uint32_t                mon_unprocessed_nr = fom->pf_mon_unprocessed_nr;
+	uint32_t                fop_nr = 0;
+	uint32_t                used    = 0;
+	uint32_t                scanned = 0;
+	uint32_t                sent    = 0;
+	uint32_t                result  = 0;
+	int                     i;
 
 	M0_PRE(reqh != NULL);
 
 	mon_list = &reqh->rh_addb_monitoring_ctx.amc_list;
-	dirtied_mon_cnt = mon_list_get_dirtied_count(reqh, mon_list, START);
-	if (dirtied_mon_cnt == 0)
-		M0_RETURN(rc);
-
-	M0_ALLOC_PTR(sum_recs_fop);
-	if (sum_recs_fop == NULL) {
-		rc = -ENOMEM;
-		M0_RETURN(rc);
-	}
-	fop_mon_cnt = min32u(dirtied_mon_cnt, BATCH);
-	M0_ALLOC_ARR(sum_recs_fop->asrf_recs, fop_mon_cnt);
-	if (sum_recs_fop->asrf_recs == NULL) {
-		rc = -ENOMEM;
-		m0_free(sum_recs_fop);
-		M0_RETURN(rc);
-	}
-
-	m0_tl_for(addb_mon, &reqh->rh_addb_monitoring_ctx.amc_list,
-			mon) {
-		struct m0_addb_sum_rec_wire  *sum_rec;
-		struct m0_addb_sum_rec       *sum =
-					mon->am_ops->amo_sum_rec(mon, reqh);
-
+	while (scanned < SCANNED_LIMIT && sent < SENT_LIMIT) {
+		struct m0_addb_sum_rec      *sum;
+		struct m0_addb_sum_rec_fop  *fop;
+		struct m0_addb_sum_rec_wire *rec;
+		void                        *data;
+
+		if (scanned == 0)
+			fop = NULL;
+		/* end of list reached, wrap around or the list is empty */
+		if (mon == NULL) {
+			mon = addb_mon_tlist_head(mon_list);
+			/* Reset the unprocessed mon count to list length */
+			fom->pf_mon_unprocessed_nr =
+				addb_mon_tlist_length(mon_list);
+			if (mon == NULL ||
+			    (scanned > 0 && fop == NULL))
+				break;
+		}
 		++scanned;
+		sum = mon->am_ops->amo_sum_rec(mon, reqh);
+		mon = addb_mon_tlist_next(mon_list, mon);
 		if (sum == NULL || !sum->asr_dirty)
 			continue;
-		if (dirtied_scanned == fop_mon_cnt) {
-			sum_recs_fop->asrf_nr = fop_mon_cnt;
+		if (fop == NULL) {
+			fop_nr = min32u(mon_unprocessed_nr, BATCH);
+			M0_ALLOC_PTR(fop);
+			if (fop != NULL)
+				M0_ALLOC_ARR(fop->asrf_recs, fop_nr);
+		}
+		data = m0_alloc(SUM_SIZE(sum));
+		if (fop == NULL || fop->asrf_recs == NULL || data == NULL) {
+			result = -ENOMEM;
+			if (data == NULL) {
+				i = scanned % fop_nr;
+				while (--i >= 0)
+					m0_free(fop->asrf_recs[i].asrw_rec.au64s_data);
+			}
+			m0_free(fop->asrf_recs);
+			m0_free(fop);
 			/**
-			 * @todo: Create & Send fop to stats service.
+			 * During next run of posting summaries
+			 * scan through the monitor whose
+			 * summary record couldnt be sent.
 			 */
-
-			/* Cleanup */
-			for (i = 0; i < fop_mon_cnt; ++i)
-				m0_free(sum_recs_fop->asrf_recs[i].asrw_rec.au64s_data);
-			m0_free(sum_recs_fop->asrf_recs);
-			dirtied_scanned = 0;
-			dirtied_mon_cnt = mon_list_get_dirtied_count(reqh,
-								     mon_list,
-								     scanned);
-			if (dirtied_mon_cnt == 0)
-				break;
-
-			/* Recalculate data for remaining records */
-			fop_mon_cnt = min32u(dirtied_mon_cnt, BATCH);
-			M0_ALLOC_ARR(sum_recs_fop->asrf_recs, fop_mon_cnt);
-			if (sum_recs_fop->asrf_recs == NULL) {
-				rc = -ENOMEM;
-				break;
-			}
-			idx = 0;
-			continue;
+			mon = addb_mon_tlist_prev(mon_list, mon);
+			break;
 		}
-		++dirtied_scanned;
+		rec = &fop->asrf_recs[used++];
+		rec->asrw_id = sum->asr_rec.asrw_id;
+		rec->asrw_rec.au64s_nr = sum->asr_rec.asrw_rec.au64s_nr;
+		rec->asrw_rec.au64s_data = data;
 		m0_mutex_lock(&sum->asr_mutex);
-		sum_rec = &sum_recs_fop->asrf_recs[idx++];
-		sum_rec->asrw_rec.au64s_data =
-			m0_alloc(SUM_SIZE(sum));
-
-		if (sum_rec->asrw_rec.au64s_data == NULL) {
-			/** Restore idx's correct value */
-			--idx;
-			/**
-			 * Reduce the fop_mon_cnt by one, since
-			 * we will not be able to send this sum_rec
-			 * due to memory allocation failure.
-			 */
-			--fop_mon_cnt;
-			--dirtied_scanned;
-			m0_mutex_unlock(&sum->asr_mutex);
+		memcpy(rec->asrw_rec.au64s_data,
+		       sum->asr_rec.asrw_rec.au64s_data, SUM_SIZE(sum));
+		sum->asr_dirty = false;
+		m0_mutex_unlock(&sum->asr_mutex);
+		if (used == fop_nr) {
 			/**
-			 * Continue to process other elements of the list.
+			 * @todo: Implement send_fop(fop).
+			 * @todo: Finalize the fop after its sent through
+			 * the network.
 			 */
-			continue;
+			used = 0;
+			fop  = NULL;
+			fom->pf_mon_unprocessed_nr =
+				       addb_mon_tlist_length(mon_list) - fop_nr;
+			M0_ASSERT(fom->pf_mon_unprocessed_nr >= 0);
+			fop_nr = 0;
+			++sent;
 		}
-		sum_rec->asrw_id = sum->asr_rec.asrw_id;
-		sum_rec->asrw_rec.au64s_nr =
-			sum->asr_rec.asrw_rec.au64s_nr;
-		memcpy(sum_rec->asrw_rec.au64s_data,
-				sum->asr_rec.asrw_rec.au64s_data,
-				SUM_SIZE(sum));
-		sum->asr_dirty = false;
-		m0_mutex_unlock(&sum->asr_mutex);
-	}m0_tl_endfor;
-
-
+	}
+	fom->pf_mon = mon;
 	/**
 	 * @todo: Post on global machine too.
 	 */
-	m0_free(sum_recs_fop);
-	M0_RETURN(rc);
+	return result;
 }
 
 /*
diff --git a/addb/addb_monitor.h b/addb/addb_monitor.h
index 1c73ec8..e1e59cc 100644
--- a/addb/addb_monitor.h
+++ b/addb/addb_monitor.h
@@ -178,6 +178,7 @@
 
 struct m0_reqh;
 struct m0_addb_monitor;
+struct addb_post_fom;
 
 M0_TL_DESCR_DECLARE(addb_mon, M0_EXTERN);
 
@@ -300,7 +301,8 @@ M0_INTERNAL void m0_addb_monitors_fini(struct m0_reqh *reqh);
  * This sends all the dirtied addb summary records for the added monitors
  * to the stats service as a fop.
  */
-M0_INTERNAL int m0_addb_monitor_summaries_post(struct m0_reqh *reqh);
+M0_INTERNAL int m0_addb_monitor_summaries_post(struct m0_reqh       *reqh,
+					       struct addb_post_fom *fom);
 
 #endif /* __MERO_ADDB_ADDB_MONITOR_H__ */
 
diff --git a/addb/addb_pfom.c b/addb/addb_pfom.c
index 60c50a2..b8d80d4 100644
--- a/addb/addb_pfom.c
+++ b/addb/addb_pfom.c
@@ -250,7 +250,8 @@ static int addb_pfom_fo_tick(struct m0_fom *fom)
 		M0_LOG(M0_DEBUG, "post");
 		m0_reqh_stats_post_addb(reqh);
 
-		err = m0_addb_monitor_summaries_post(svc->as_reqhs.rs_reqh);
+		err = m0_addb_monitor_summaries_post(svc->as_reqhs.rs_reqh,
+						     pfom);
 
 		/**
 		 * In case of summaries posting failure, just log error.
diff --git a/addb/addb_svc.h b/addb/addb_svc.h
index 11acb9e..5465b77 100644
--- a/addb/addb_svc.h
+++ b/addb/addb_svc.h
@@ -40,23 +40,29 @@ extern struct m0_reqh_service_type m0_addb_svc_type;
    ADDB statistics posting FOM
  */
 struct addb_post_fom {
-	uint64_t              pf_magic;
+	uint64_t                pf_magic;
 	/** Periodicity of the statistics post. */
-	m0_time_t             pf_period;
+	m0_time_t               pf_period;
 	/** Tolerance limit in epoch calculation */
-	m0_time_t             pf_tolerance;
+	m0_time_t               pf_tolerance;
 	/** Next post time. */
-	m0_time_t             pf_next_post;
+	m0_time_t               pf_next_post;
 	/** Shutdown request flag. */
-	bool                  pf_shutdown;
+	bool                    pf_shutdown;
 	/** Running flag.  Used to synchronize termination. */
-	bool                  pf_running;
+	bool                    pf_running;
 	/** trap used to get into the locality to interact with the fom */
-	struct m0_sm_ast      pf_ast;
+	struct m0_sm_ast        pf_ast;
 	/** The FOM timer */
-	struct m0_fom_timeout pf_timeout;
+	struct m0_fom_timeout   pf_timeout;
+	/** Last scanned monitor from the reqh mon list */
+	struct m0_addb_monitor *pf_mon;
+	/** Number of unprocessed monitors for single invocation of
+	 *  m0_addb_monitor_summaries_post().
+	 */
+	uint32_t                pf_mon_unprocessed_nr;
 	/** Embedded FOM object. */
-	struct m0_fom         pf_fom;
+	struct m0_fom           pf_fom;
 };
 
 /**
-- 
1.8.3.2

