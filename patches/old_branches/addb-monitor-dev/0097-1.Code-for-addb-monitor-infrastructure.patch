From 91889d75e6837756cf22eb07ab157f41e9a6810b Mon Sep 17 00:00:00 2001
From: Rohan Puri <rohan_puri@xyratex.com>
Date: Mon, 23 Sep 2013 19:57:43 +0530
Subject: [PATCH 097/125] 1.Code for addb monitor infrastructure. 2. Making
 available stats fops in kernel also. 3. Some style fixes in stats service. 4.
 Stats service endpoint extraction in m0t1fs & m0d, also starting    service
 in m0d.

---
 Kbuild.in                   |   1 +
 addb/addb_monitor.c         | 250 ++++++++++++++++++++++++++++++++++++--------
 addb/addb_monitor.h         |  62 +++++++++--
 conf/schema.h               |   1 +
 m0t1fs/linux_kernel/super.c |  34 ++++--
 mero/conf.c                 |   3 +-
 mero/init.c                 |   2 +
 mero/setup.c                |   7 ++
 stats/stats_addb.h          |   4 +
 stats/stats_fops.c          |   4 +
 stats/stats_fops.h          |   2 +-
 stats/stats_srv.c           |   9 +-
 stats/ut/stats_ut_svc.c     |  12 +--
 13 files changed, 317 insertions(+), 74 deletions(-)

diff --git a/Kbuild.in b/Kbuild.in
index 29eeb07..2fdc562 100644
--- a/Kbuild.in
+++ b/Kbuild.in
@@ -80,6 +80,7 @@ include $(src)/rm/Kbuild.sub
 include $(src)/rpc/Kbuild.sub
 include $(src)/sm/Kbuild.sub
 include $(src)/sns/Kbuild.sub
+include $(src)/stats/Kbuild.sub
 include $(src)/stob/Kbuild.sub
 include $(src)/xcode/Kbuild.sub
 include $(src)/be/Kbuild.sub
diff --git a/addb/addb_monitor.c b/addb/addb_monitor.c
index 4cb49a7..1714bba 100644
--- a/addb/addb_monitor.c
+++ b/addb/addb_monitor.c
@@ -149,7 +149,15 @@
 
 */
 
+#undef M0_ADDB_CT_CREATE_DEFINITION
+#define M0_ADDB_CT_CREATE_DEFINITION
+#include "stats/stats_addb.h"
+
 #include "addb/addb_monitor.h"
+#include "rpc/rpclib.h"
+#ifndef __KERNEL__
+#include "mero/setup.h"
+#endif
 
 M0_TL_DESCR_DEFINE(addb_mon, "addb monitors list", M0_INTERNAL,
 		   struct m0_addb_monitor, am_linkage, am_magic,
@@ -158,19 +166,112 @@ M0_TL_DESCR_DEFINE(addb_mon, "addb monitors list", M0_INTERNAL,
 
 M0_TL_DEFINE(addb_mon, M0_INTERNAL, struct m0_addb_monitor);
 
+#ifndef __KERNEL__
+static int stats_svc_conn_establish(struct m0_reqh *reqh)
+{
+	int                           rc = 0;
+	const char                    *stats_svc_ep;
+	struct m0_mero                *mero;
+	struct m0_rpc_machine         *rmach;
+	struct m0_addb_monitoring_ctx *mon_ctx;
+
+	M0_PRE(reqh != NULL);
+
+	mon_ctx = &reqh->rh_addb_monitoring_ctx;
+
+	mero = m0_cs_ctx_get(reqh);
+	rmach = m0_reqh_rpc_mach_tlist_head(&reqh->rh_rpc_machines);
+	M0_ASSERT(mero != NULL);
+	M0_ASSERT(rmach != NULL);
+
+	stats_svc_ep = mero->cc_stats_svc_epx.ex_endpoint;
+
+	if (stats_svc_ep == NULL) {
+		M0_LOG(M0_WARN, "Stats svc ep not provided");
+		M0_RETURN(0);
+	}
+
+	m0_mutex_lock(&mon_ctx->amc_mutex);
+	M0_ALLOC_PTR(mon_ctx->amc_stats_conn);
+	if (mon_ctx->amc_stats_conn == NULL) {
+		/* @todo: Use ADDB recs */
+		M0_LOG(M0_WARN, "Memory allocation failed for stats conn"
+		       "object");
+		m0_mutex_unlock(&mon_ctx->amc_mutex);
+		M0_RETURN(0);
+	}
+	M0_ALLOC_PTR(mon_ctx->amc_stats_session);
+	if (mon_ctx->amc_stats_session == NULL) {
+		/* @todo: Use ADDB recs */
+		M0_LOG(M0_WARN, "Memory allocation failed for stats session"
+		       "object");
+		m0_free(mon_ctx->amc_stats_conn);
+		m0_mutex_unlock(&mon_ctx->amc_mutex);
+		M0_RETURN(0);
+	}
+	rc = m0_rpc_client_connect(mon_ctx->amc_stats_conn,
+				   mon_ctx->amc_stats_session, rmach,
+				   stats_svc_ep,
+				   ADDB_STATS_MAX_RPCS_IN_FLIGHT,
+				   ADDB_STATS_MAX_RPC_SLOTS_NR);
+	if (rc != 0) {
+		/* @todo: Use ADDB recs */
+		M0_LOG(M0_WARN, "stats svc connection failed");
+		m0_free(mon_ctx->amc_stats_session);
+		m0_free(mon_ctx->amc_stats_conn);
+		m0_mutex_unlock(&mon_ctx->amc_mutex);
+		M0_RETURN(0);
+	}
+	mon_ctx->amc_stats_ep = stats_svc_ep;
+	m0_mutex_unlock(&mon_ctx->amc_mutex);
+	return rc;
+}
+#endif
+
+M0_INTERNAL void m0_addb_conf_process(struct m0_reqh *reqh,
+				      struct m0_rpc_conn *conn,
+				      struct m0_rpc_session *session,
+				      const char *ep)
+{
+	struct m0_addb_monitoring_ctx *mon_ctx;
+
+	M0_PRE(reqh != NULL && conn != NULL && session != NULL && ep != NULL);
+
+	mon_ctx = &reqh->rh_addb_monitoring_ctx;
+
+	m0_mutex_lock(&mon_ctx->amc_mutex);
+	if (mon_ctx->amc_stats_ep != NULL)
+		goto out;
+	else {
+		mon_ctx->amc_stats_ep      = ep;
+		mon_ctx->amc_stats_conn    = conn;
+		mon_ctx->amc_stats_session = session;
+	}
+out:
+	m0_mutex_unlock(&mon_ctx->amc_mutex);
+}
+
 M0_INTERNAL int m0_addb_monitors_init(struct m0_reqh *reqh,
 				      const char     *endpoint)
 {
 	int rc = 0;
+	struct m0_addb_monitoring_ctx *mon_ctx;
 
 	M0_PRE(reqh != NULL);
 	M0_PRE(endpoint != NULL);
 
-	addb_mon_tlist_init(&reqh->rh_addb_monitoring_ctx.amc_list);
-	m0_mutex_init(&reqh->rh_addb_monitoring_ctx.amc_mutex);
-	/*
-	 * @todo: Establish connection with stats service
-	 */
+	mon_ctx = &reqh->rh_addb_monitoring_ctx;
+
+	addb_mon_tlist_init(&mon_ctx->amc_list);
+	m0_mutex_init(&mon_ctx->amc_mutex);
+
+#ifndef __KERNEL__
+	rc = stats_svc_conn_establish(reqh);
+	if (rc != 0)
+		M0_RETERR(rc, "Stats service connection estalish failed\n");
+#endif
+	m0_addb_ctx_type_register(&m0_addb_ct_stats_rec);
+
 	return rc;
 }
 
@@ -251,7 +352,7 @@ M0_INTERNAL void m0_addb_monitors_fini(struct m0_reqh *reqh)
 	/** @todo: Close connection with stats service and do related cleanup */
 }
 
-#define SUM_SIZE(sum) (sum->asr_rec.asrw_rec.au64s_nr * sizeof(uint64_t))
+#define SUM_SIZE(sum) (sum->asr_rec.ss_data.au64s_nr * sizeof(uint64_t))
 
 enum {
 	/**
@@ -271,40 +372,97 @@ enum {
 	SENT_LIMIT = 3
 };
 
-static void addb_mon_fop_free(struct m0_addb_sum_rec_fop *fop, uint32_t fop_nr)
+static void addb_mon_fop_free(struct m0_stats_update_fop *fop_data,
+			      uint32_t fop_nr)
 {
-	M0_PRE(fop != NULL);
+	M0_PRE(fop_data != NULL);
 
-	if (fop->asrf_recs != NULL) {
+	if (fop_data->suf_stats.sf_stats != NULL) {
 		int i;
 
 		for (i = 0; i < fop_nr; ++i)
-			m0_free(fop->asrf_recs[i].asrw_rec.au64s_data);
-		m0_free(fop->asrf_recs);
+			m0_free(fop_data->suf_stats.sf_stats[i].ss_data.au64s_data);
+		m0_free(fop_data->suf_stats.sf_stats);
 	}
+	m0_free(fop_data);
+	fop_data = NULL;
+}
+
+static void addb_monitor_stats_fop_release(struct m0_ref *ref)
+{
+	struct m0_fop              *fop = container_of(ref, struct m0_fop, f_ref);
+	struct m0_stats_update_fop *fop_data = m0_fop_data(fop);
+
+	addb_mon_fop_free(fop_data, fop_data->suf_stats.sf_nr);
+	m0_fop_fini(fop);
 	m0_free(fop);
 }
 
-M0_INTERNAL int m0_addb_monitor_summaries_post(struct m0_reqh *reqh,
-					      struct addb_post_fom *fom)
+static void stats_item_sent(struct m0_rpc_item *item)
+{
+	struct m0_fop *fop;
+
+	fop = container_of(item, struct m0_fop, f_item);
+	m0_fop_put(fop);
+}
+
+const struct m0_rpc_item_ops addb_monitor_stats_rpc_item_ops = {
+	.rio_sent = stats_item_sent
+};
+
+static int addb_monitor_stats_fop_send(struct m0_stats_update_fop *fop_data,
+				       struct m0_rpc_session      *session)
+{
+	struct m0_fop      *stats_update_fop;
+	struct m0_rpc_item *item;
+	int                 rc;
+
+	M0_ALLOC_PTR(stats_update_fop);
+	if (stats_update_fop == NULL)
+		M0_RETERR(-ENOMEM, "stats update fop");
+
+	m0_fop_init(stats_update_fop, &m0_fop_stats_update_fopt,
+		    (void *) fop_data, addb_monitor_stats_fop_release);
+
+	stats_update_fop->f_item.ri_ops = &addb_monitor_stats_rpc_item_ops;
+
+	item                     = &stats_update_fop->f_item;
+	item->ri_session         = session;
+	item->ri_prio            = M0_RPC_ITEM_PRIO_MIN;
+	item->ri_deadline        = 0;
+	item->ri_resend_interval = M0_TIME_NEVER;
+
+	rc = m0_rpc_post(item);
+	m0_fop_put(stats_update_fop);
+
+	return rc;
+}
+
+M0_INTERNAL int m0_addb_monitor_summaries_post(struct m0_reqh       *reqh,
+					       struct addb_post_fom *fom)
 {
-	struct m0_tl                *mon_list;
+	struct m0_tl                  *mon_list;
+	struct m0_addb_monitoring_ctx *mon_ctx;
 	/* Continue scanning from the place we left last time */
-	struct m0_addb_monitor      *mon    = fom->pf_mon;
-	struct m0_addb_sum_rec_fop  *fop =  NULL;
-	uint32_t                     fop_nr =  0;
-	uint32_t                     used    = 0;
-	uint32_t                     scanned = 0;
-	uint32_t                     sent    = 0;
-	uint32_t                     result  = 0;
+	struct m0_addb_monitor        *mon     = fom->pf_mon;
+	struct m0_stats_update_fop    *fop     =  NULL;
+	uint32_t                       fop_nr  =  0;
+	uint32_t                       used    = 0;
+	uint32_t                       scanned = 0;
+	uint32_t                       sent    = 0;
+	uint32_t                       result  = 0;
+	struct m0_addb_ctx            *cv[] = {/*&m0_addb_ct_stats_rec,*/ NULL};
 
 	M0_PRE(reqh != NULL);
 
-	mon_list = &reqh->rh_addb_monitoring_ctx.amc_list;
+	mon_ctx = &reqh->rh_addb_monitoring_ctx;
+	M0_ASSERT(mon_ctx->amc_stats_session != NULL);
+	mon_list = &mon_ctx->amc_list;
+
 	m0_mutex_lock(&reqh->rh_addb_monitoring_ctx.amc_mutex);
 	while (scanned < SCANNED_LIMIT && sent < SENT_LIMIT) {
 		struct m0_addb_sum_rec      *sum;
-		struct m0_addb_sum_rec_wire *rec;
+		struct m0_stats_sum         *rec;
 		void                        *data;
 
 		/* end of list reached, wrap around or the list is empty */
@@ -325,30 +483,36 @@ M0_INTERNAL int m0_addb_monitor_summaries_post(struct m0_reqh *reqh,
 		if (fop == NULL) {
 			M0_ALLOC_PTR(fop);
 			if (fop != NULL)
-				M0_ALLOC_ARR(fop->asrf_recs, BATCH);
+				M0_ALLOC_ARR(fop->suf_stats.sf_stats, BATCH);
 		}
 		data = m0_alloc(SUM_SIZE(sum));
-		if (fop == NULL || fop->asrf_recs == NULL || data == NULL) {
+		if (fop == NULL || fop->suf_stats.sf_stats == NULL ||
+		    data == NULL) {
 			result = -ENOMEM;
 			addb_mon_fop_free(fop, fop_nr);
 			break;
 		}
-		rec = &fop->asrf_recs[used++];
-		rec->asrw_id = sum->asr_rec.asrw_id;
-		rec->asrw_rec.au64s_nr = sum->asr_rec.asrw_rec.au64s_nr;
-		rec->asrw_rec.au64s_data = data;
+		rec = &fop->suf_stats.sf_stats[used++];
+		rec->ss_id = sum->asr_rec.ss_id;
+		rec->ss_data.au64s_nr = sum->asr_rec.ss_data.au64s_nr;
+		rec->ss_data.au64s_data = data;
 		m0_mutex_lock(&sum->asr_mutex);
-		memcpy(rec->asrw_rec.au64s_data,
-		       sum->asr_rec.asrw_rec.au64s_data, SUM_SIZE(sum));
+		memcpy(rec->ss_data.au64s_data,
+		       sum->asr_rec.ss_data.au64s_data, SUM_SIZE(sum));
 		sum->asr_dirty = false;
+		/**
+		 * Post summary record on global machine too.
+		 */
+		M0_ADDB_MONITOR_STATS_POST(&m0_addb_gmc,
+					   m0_addb_rec_type_lookup(rec->ss_id),
+					   cv, rec);
 		m0_mutex_unlock(&sum->asr_mutex);
 		if (used == BATCH) {
-			fop->asrf_nr = BATCH;
-			/**
-			 * @todo: Implement send_fop(fop).
-			 * @todo: Finalize the fop after its sent through
-			 * the network.
-			 */
+			fop->suf_stats.sf_nr = BATCH;
+			result = addb_monitor_stats_fop_send(fop,
+						             mon_ctx->amc_stats_session);
+			if (result != 0)
+				goto out;
 			used   = 0;
 			fop    = NULL;
 			fop_nr = 0;
@@ -356,13 +520,15 @@ M0_INTERNAL int m0_addb_monitor_summaries_post(struct m0_reqh *reqh,
 		}
 	}
 	if (fop != NULL) {
-		/** @todo: Send fop. */
+		result = addb_monitor_stats_fop_send(fop,
+					             mon_ctx->amc_stats_session);
+		if (result != 0)
+			goto out;
 	}
-	m0_mutex_unlock(&reqh->rh_addb_monitoring_ctx.amc_mutex);
 	fom->pf_mon = mon;
-	/**
-	 * @todo: Post on global machine too.
-	 */
+out:
+	m0_mutex_unlock(&reqh->rh_addb_monitoring_ctx.amc_mutex);
+
 	return result;
 }
 /*
diff --git a/addb/addb_monitor.h b/addb/addb_monitor.h
index 4cdba70..9e992f4 100644
--- a/addb/addb_monitor.h
+++ b/addb/addb_monitor.h
@@ -173,13 +173,18 @@
    @endcode
 */
 
-#include "addb/addb_monitor_wire.h"
+#include "stats/stats_fops.h"
 #include "rpc/conn.h"
 
 struct m0_reqh;
 struct m0_addb_monitor;
 struct addb_post_fom;
 
+enum {
+	ADDB_STATS_MAX_RPCS_IN_FLIGHT = 1,
+	ADDB_STATS_MAX_RPC_SLOTS_NR = 1
+};
+
 M0_TL_DESCR_DECLARE(addb_mon, M0_EXTERN);
 
 struct m0_addb_sum_rec {
@@ -187,15 +192,15 @@ struct m0_addb_sum_rec {
 	 * This flag is true iff the record contains data still
 	 * not sent to the stats service.
 	 */
-	bool                         asr_dirty;
-	/** This lock serializes access to this structure */
-	struct m0_mutex              asr_mutex;
+	bool                 asr_dirty;
+	/** This lock seriailizes access to this structure */
+	struct m0_mutex      asr_mutex;
 	/**
 	 * ADDB in-memory summary record
-	 * m0_addb_sum_rec_wire::asrw_rec::au64s_data is monitor
+	 * m0_stats_sum:ss_data::au64s_data is monitor
 	 * specific data
 	 */
-	struct m0_addb_sum_rec_wire  asr_rec;
+	struct m0_stats_sum  asr_rec;
 };
 
 struct m0_addb_monitor_ops {
@@ -233,13 +238,13 @@ M0_INTERNAL bool m0_addb_monitor_invariant(struct m0_addb_monitor *mon);
  */
 struct m0_addb_monitoring_ctx {
 	/* List of active monitors */
-	struct m0_tl                       amc_list;
+	struct m0_tl           amc_list;
 	/* Mutex to protect amc_list */
-	struct m0_mutex                    amc_mutex;
+	struct m0_mutex        amc_mutex;
 	/* Stats service endpoint */
-	struct cs_endpoint_and_xprt       *amc_ex;
-	struct m0_rpc_conn                 amc_stats_conn;
-	struct m0_rpc_session              amc_stats_session;
+	const char            *amc_stats_ep;
+	struct m0_rpc_conn    *amc_stats_conn;
+	struct m0_rpc_session *amc_stats_session;
 };
 
 /**
@@ -309,6 +314,41 @@ M0_INTERNAL void m0_addb_monitors_fini(struct m0_reqh *reqh);
 M0_INTERNAL int m0_addb_monitor_summaries_post(struct m0_reqh       *reqh,
 					       struct addb_post_fom *fom);
 
+/**
+ * Setup addb monitoring ctx within request handler with stats service
+ * connection details
+ * @param reqh request handler
+ * @param conn rpc connection object of stats service
+ * @param session rpc session object of stats service
+ * @param ep stats service endpoint
+ */
+M0_INTERNAL void m0_addb_conf_process(struct m0_reqh *reqh,
+				      struct m0_rpc_conn *conn,
+				      struct m0_rpc_session *session,
+				      const char *ep);
+
+/**
+ * Macro to post ADDB monitor stats summary records as ADDB records
+ * on given addb machine.
+ * @param mc    Specify the addb machine.
+ * @param rt    Specify the pointer to the ADDB record type.
+ * @param cv    Specify the context vector.
+ * @param stats Specify the m0_stats_sum structure, this represents
+ *              the stats summary record that needs to be posted.
+ */
+#define M0_ADDB_MONITOR_STATS_POST(mc, rt, cv, stats)                   \
+do {                                                                    \
+	struct m0_addb_post_data pd;                                    \
+	M0_ASSERT(mc != NULL && rt != NULL && cv != NULL &&             \
+		  stats != NULL);                                       \
+	pd.apd_rt = rt;                                                 \
+	pd.apd_cv = cv;                                                 \
+	M0_ASSERT((rt)->art_id == stats->ss_id);                        \
+	M0__ADDB_POST(pd.apd_rt, stats->ss_data.au64s_nr,               \
+		      stats->ss_data.au64s_data);                       \
+	m0__addb_post(mc, &pd);                                         \
+} while (0)
+
 #endif /* __MERO_ADDB_ADDB_MONITOR_H__ */
 /*
  *  Local variables:
diff --git a/conf/schema.h b/conf/schema.h
index 0b480d0..0eef513 100644
--- a/conf/schema.h
+++ b/conf/schema.h
@@ -32,6 +32,7 @@ enum m0_conf_service_type {
 	M0_CST_IOS,     /*< IO/data service. */
 	M0_CST_MGS,     /*< Management service (confd?). */
 	M0_CST_DLM,     /*< DLM service. */
+	M0_CST_SS       /*< Stats service */
 };
 
 #endif /* __MERO_CONF_SCHEMA_H__ */
diff --git a/m0t1fs/linux_kernel/super.c b/m0t1fs/linux_kernel/super.c
index 15fda4b..5ae68b2 100644
--- a/m0t1fs/linux_kernel/super.c
+++ b/m0t1fs/linux_kernel/super.c
@@ -506,6 +506,10 @@ static int connect_to_service(const char *addr, enum m0_conf_service_type type,
 				   M0T1FS_MAX_NR_RPC_IN_FLIGHT,
 				   M0T1FS_NR_SLOTS_PER_SESSION);
 	if (rc == 0) {
+		if (type == M0_CST_SS)
+			m0_addb_conf_process(&m0t1fs_globals.g_reqh,
+					     &ctx->sc_conn, &ctx->sc_session,
+					     addr);
 		svc_ctx_tlist_add_tail(&csb->csb_service_contexts, ctx);
 		M0_CNT_INC(csb->csb_nr_active_contexts);
 		M0_LOG(M0_INFO, "Connected to service `%s'. %d active contexts",
@@ -550,8 +554,9 @@ static int connect_to_services(struct m0t1fs_sb *csb, struct m0_conf_obj *fs,
 	struct m0_conf_obj *entry;
 	const char        **pstr;
 	int                 rc;
-	bool                mds_is_provided = false;
-	bool                dlm_is_provided = false;
+	bool                mds_is_provided       = false;
+	bool                dlm_is_provided       = false;
+	bool                stats_svc_is_provided = false;
 
 	M0_ENTRY();
 	M0_PRE(svc_ctx_tlist_is_empty(&csb->csb_service_contexts));
@@ -573,21 +578,38 @@ static int connect_to_services(struct m0t1fs_sb *csb, struct m0_conf_obj *fs,
 			dlm_is_provided = true;
 		else if (svc->cs_type == M0_CST_IOS)
 			++*nr_ios;
+		else if (svc->cs_type == M0_CST_SS)
+			stats_svc_is_provided = true;
 
 		for (pstr = svc->cs_endpoints; *pstr != NULL; ++pstr) {
 			M0_LOG(M0_DEBUG, "svc type=%d, ep=%s",
 			       svc->cs_type, *pstr);
 			rc = connect_to_service(*pstr, svc->cs_type, csb);
-			if (rc != 0)
-				goto out;
+			if (rc != 0) {
+				if (svc->cs_type == M0_CST_SS) {
+					/** @todo: User ADDB here */
+					M0_LOG(M0_WARN,
+					       "Stats service conn failed");
+					/**
+					 * If stats service is the last entry,
+					 * then we want to return success & log
+					 * the error
+					 */
+					rc = 0;
+					continue;
+				}
+				else
+					goto out;
+			}
 		}
 	}
 out:
 	m0_confc_close(entry);
 	m0_confc_close(dir);
 
-	if (rc == 0 && mds_is_provided && dlm_is_provided && *nr_ios > 0)
-		M0_LOG(M0_DEBUG, "Connected to IOS, MDS and RMS");
+	if (rc == 0 && mds_is_provided && dlm_is_provided &&
+	    stats_svc_is_provided && *nr_ios > 0)
+		M0_LOG(M0_DEBUG, "Connected to SS, IOS, MDS and RMS");
 	else {
 		M0_LOG(M0_FATAL, "Error connecting to the services. "
 		       "(Please check whether IOS, MDS and RMS are provided)");
diff --git a/mero/conf.c b/mero/conf.c
index 6332d49..8bd0734 100644
--- a/mero/conf.c
+++ b/mero/conf.c
@@ -61,7 +61,8 @@ static const char *service_name[] = {
 	[M0_CST_MDS] = "mdservice",  /* Meta-data service. */
 	[M0_CST_IOS] = "ioservice",  /* IO/data service. */
 	[M0_CST_MGS] = "confd",      /* Management service (confd). */
-	[M0_CST_DLM] = "dlm"         /* DLM service. */
+	[M0_CST_DLM] = "dlm",        /* DLM service. */
+	[M0_CST_SS]  = "stats"       /* @todo replace with symbolic const used by stats service */
 };
 
 static char *service_name_dup(const struct m0_conf_service *svc)
diff --git a/mero/init.c b/mero/init.c
index cba07c2..8e3e524 100644
--- a/mero/init.c
+++ b/mero/init.c
@@ -73,6 +73,7 @@
 #include "sns/parity_ops.h"
 #include "cm/cm.h"
 #include "addb/addb_fops.h"
+#include "stats/stats_fops.h"
 #include "mgmt/mgmt.h"
 #include "ha/epoch.h"
 
@@ -146,6 +147,7 @@ struct init_fini_call subsystem[] = {
 	{ &m0_confx_types_init, &m0_confx_types_fini, "conf-xtypes" },
 	{ &m0_conf_fops_init,   &m0_conf_fops_fini,   "conf-fops" },
 	{ &m0_addb_service_fop_init, &m0_addb_service_fop_fini, "addb_fops" },
+	{ &m0_stats_fops_init,  &m0_stats_fops_fini,   "stats_fops"},
 	{ &m0_rms_register,     &m0_rms_unregister,   "rmservice"},
 #ifdef __KERNEL__
 	{ &m0t1fs_init,         &m0t1fs_fini,         "m0t1fs" },
diff --git a/mero/setup.c b/mero/setup.c
index 2fdcbea..46ad487 100644
--- a/mero/setup.c
+++ b/mero/setup.c
@@ -1964,6 +1964,13 @@ static int _args_parse(struct m0_mero *cctx, int argc, char **argv,
 								    cc_mds_epx,
 								    s);
 				})),
+			M0_STRINGARG('Z', "stats service endpoint address",
+				LAMBDA(void, (const char *s)
+				{
+					rc = ep_and_xprt_extract(&cctx->
+								 cc_stats_svc_epx,
+								 s);
+				})),
 			M0_STRINGARG('i', "ioservice endpoints list",
 				LAMBDA(void, (const char *s)
 				{
diff --git a/stats/stats_addb.h b/stats/stats_addb.h
index 16d2006..f7a4efb 100644
--- a/stats/stats_addb.h
+++ b/stats/stats_addb.h
@@ -37,12 +37,16 @@ enum {
 	M0_ADDB_CTXID_STATS_SVC		= 1700,
 	M0_ADDB_CTXID_STATS_UPDATE_FOM	= 1701,
 	M0_ADDB_CTXID_STATS_QUERY_FOM	= 1702,
+	M0_ADDB_CTXID_STATS_REC         = 1703,
 };
 
 M0_ADDB_CT(m0_addb_ct_stats_svc, M0_ADDB_CTXID_STATS_SVC, "hi", "low");
 M0_ADDB_CT(m0_addb_ct_stats_update_fom, M0_ADDB_CTXID_STATS_UPDATE_FOM);
 M0_ADDB_CT(m0_addb_ct_stats_query_fom, M0_ADDB_CTXID_STATS_QUERY_FOM);
 
+
+M0_ADDB_CT(m0_addb_ct_stats_rec, M0_ADDB_CTXID_STATS_REC);
+
 /*
  * Stats ADDB posting locations.
  */
diff --git a/stats/stats_fops.c b/stats/stats_fops.c
index f6d05ad..de77f88 100644
--- a/stats/stats_fops.c
+++ b/stats/stats_fops.c
@@ -64,9 +64,11 @@ M0_INTERNAL int m0_stats_fops_init(void)
 				 .xt	    = m0_stats_update_fop_xc,
 				 .rpc_flags = M0_RPC_ITEM_TYPE_ONEWAY,
 				 .fop_ops   = &stats_update_fop_ops,
+#ifndef __KERNEL__
 				 .fom_ops   = &stats_update_fom_type_ops,
 				 .sm	    = &stats_update_fom_sm_conf,
 				 .svc_type  = &m0_stats_svc_type,
+#endif
 				 .rpc_ops   = &stats_update_item_type_ops) ?:
 		M0_FOP_TYPE_INIT(&m0_fop_stats_query_fopt,
                                  .name      = "Stats query fop",
@@ -74,9 +76,11 @@ M0_INTERNAL int m0_stats_fops_init(void)
 				 .xt	    = m0_stats_query_fop_xc,
 				 .rpc_flags = M0_RPC_ITEM_TYPE_REQUEST,
 				 .fop_ops   = &stats_query_fop_ops,
+#ifndef __KERNEL__
 				 .fom_ops   = &stats_query_fom_type_ops,
 				 .sm	    = &stats_query_fom_sm_conf,
 				 .svc_type  = &m0_stats_svc_type,
+#endif
 				 .rpc_ops   = &stats_query_item_type_ops) ?:
 		M0_FOP_TYPE_INIT(&m0_fop_stats_query_rep_fopt,
                                  .name      = "Stats query rep fop",
diff --git a/stats/stats_fops.h b/stats/stats_fops.h
index 3888798..9c0839e 100644
--- a/stats/stats_fops.h
+++ b/stats/stats_fops.h
@@ -55,7 +55,7 @@ extern struct m0_fop_type m0_fop_stats_query_rep_fopt;
  */
 struct m0_stats_sum {
 	/** Stats id, this is corresponding addb rec type id. */
-	uint64_t		  ss_id;
+	uint32_t		  ss_id;
 	/** Stats summary data */
 	struct m0_addb_uint64_seq ss_data;
 } M0_XCA_RECORD;
diff --git a/stats/stats_srv.c b/stats/stats_srv.c
index a97c784..9aa3486 100644
--- a/stats/stats_srv.c
+++ b/stats/stats_srv.c
@@ -170,10 +170,8 @@
 1lBgPht18RYX7s9XL-FcfUBKZ0zvo6JzqAEsXpTWs_4Q/edit">
    Mero Stats Service</a>
  */
-#undef M0_ADDB_CT_CREATE_DEFINITION
-#define M0_ADDB_CT_CREATE_DEFINITION
-#include "stats/stats_addb.h"
 
+#include "stats/stats_addb.h"
 #define M0_TRACE_SUBSYSTEM M0_TRACE_SUBSYS_STATS
 #include "lib/trace.h"
 #include "lib/tlist.h"
@@ -311,9 +309,7 @@ M0_INTERNAL int m0_stats_svc_init(void)
 	if (rc != 0)
 		return rc;
 
-	rc = m0_stats_fops_init();
-	if (rc != 0)
-		m0_reqh_service_type_unregister(&m0_stats_svc_type);
+	m0_reqh_service_type_unregister(&m0_stats_svc_type);
 
 	return rc;
 }
@@ -321,7 +317,6 @@ M0_INTERNAL int m0_stats_svc_init(void)
 M0_INTERNAL void m0_stats_svc_fini(void)
 {
 	m0_reqh_service_type_unregister(&m0_stats_svc_type);
-	m0_stats_fops_fini();
 }
 
 /*
diff --git a/stats/ut/stats_ut_svc.c b/stats/ut/stats_ut_svc.c
index b310b32..3dcd885 100644
--- a/stats/ut/stats_ut_svc.c
+++ b/stats/ut/stats_ut_svc.c
@@ -189,15 +189,15 @@ static const struct m0_fom_ops ut_stats_update_fom_ops = {
 static struct m0_fop *get_fake_stats_fop(uint32_t nsum, enum fop_type type)
 {
 	struct m0_fop                   *fop;
-	struct m0_stats_update_fop *ufop;
-	struct m0_stats_query_fop  *qfop;
+	struct m0_stats_update_fop      *ufop;
+	struct m0_stats_query_fop       *qfop;
 
 
 	M0_ALLOC_PTR(fop);
 	M0_UT_ASSERT(fop != NULL);
 
-	switch(type) {
-	case UPDATE_FOP :
+	switch (type) {
+	case UPDATE_FOP:
 		M0_ALLOC_PTR(ufop);
 		M0_UT_ASSERT(ufop != NULL);
 
@@ -207,7 +207,7 @@ static struct m0_fop *get_fake_stats_fop(uint32_t nsum, enum fop_type type)
 		m0_fop_init(fop, &m0_fop_stats_update_fopt, (void *)ufop,
 			    fop_release);
 		break;
-	case QUERY_FOP :
+	case QUERY_FOP:
 		M0_ALLOC_PTR(qfop);
 		M0_UT_ASSERT(qfop != NULL);
 
@@ -224,7 +224,7 @@ static void update_fom_test(struct stats_svc *srv, struct m0_reqh *reqh,
 {
 	struct m0_fop			*fop;
 	struct m0_fom			*fom;
-	struct m0_stats_update_fop *ufop;
+	struct m0_stats_update_fop      *ufop;
 	int				 i;
 	int				 rc;
 
-- 
1.8.3.2

