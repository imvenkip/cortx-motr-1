From db8a44043325744d9c2a727ae5d45fc0dafcf4f0 Mon Sep 17 00:00:00 2001
From: Rajanikant Chirmade <rajanikant_chirmade@xyratex.com>
Date: Tue, 19 Nov 2013 00:19:16 +0530
Subject: [PATCH 124/125] 	Fop rate statistics 	- Implementation of
 Fop rate statistic using ADDB monitoring infrastructre, 	- Some fix for
 stats utility (m0stats), 	- MACRO to register STATISTIC TYPES with Mero

	Reviewed on : http://reviewboard.clusterstor.com/r/1571/
	Reviewed by : Rohan Puri <rohan_puri@xyratex.com>
---
 addb/addb.c                                 |   2 +-
 addb/addb_monitor.c                         |  10 ++
 addb/addb_monitor.h                         |  16 ++-
 addb/addb_rec.c                             |   3 +-
 extra-libs/galois                           |   2 +-
 fop/fom.c                                   | 184 ++++++++++++++++++++++++++--
 fop/fom.h                                   |  10 ++
 fop/fop.c                                   |   3 +
 fop/fop_addb.h                              |  21 ++--
 m0t1fs/linux_kernel/m0t1fs.c                |   2 +-
 m0t1fs/linux_kernel/st/m0t1fs_common_inc.sh |   1 +
 m0t1fs/linux_kernel/st/m0t1fs_server_inc.sh |   2 +-
 mero/magic.h                                |   3 +
 reqh/reqh.c                                 |  36 ++++--
 reqh/reqh.h                                 |   2 +-
 scripts/m0mount.sh                          |   3 +-
 stats/util/stats_util.c                     | 102 +++++++--------
 17 files changed, 307 insertions(+), 95 deletions(-)

diff --git a/addb/addb.c b/addb/addb.c
index 82ed65a..d19e483 100644
--- a/addb/addb.c
+++ b/addb/addb.c
@@ -795,7 +795,7 @@ static void addb_register_kernel_ctx_and_rec_types(void)
 	m0_addb_rec_type_register(&m0_addb_rt_m0t1fs_iow_sizes);
 	m0_addb_rec_type_register(&m0_addb_rt_m0t1fs_ior_times);
 	m0_addb_rec_type_register(&m0_addb_rt_m0t1fs_iow_times);
-	M0_ADDB_MONITOR_STATS_TYPE_REGISTER(m0_addb_rt_m0t1fs_mon_io_size,
+	M0_ADDB_MONITOR_STATS_TYPE_REGISTER(&m0_addb_rt_m0t1fs_mon_io_size,
 					    "io_size");
 }
 #endif
diff --git a/addb/addb_monitor.c b/addb/addb_monitor.c
index 2342f5f..32aac0b 100644
--- a/addb/addb_monitor.c
+++ b/addb/addb_monitor.c
@@ -264,6 +264,8 @@ M0_INTERNAL int m0_addb_monitors_init(struct m0_reqh *reqh)
 				 &m0_addb_ct_monitors_mod, &m0_addb_proc_ctx);
 	}
 
+	mon_ctx->amc_magic = M0_ADDB_MONITOR_CTX_MAGIC;
+
 	return rc;
 }
 
@@ -272,6 +274,11 @@ M0_INTERNAL bool m0_addb_monitor_invariant(struct m0_addb_monitor *mon)
 	return mon != NULL && mon->am_ops != NULL;
 }
 
+M0_INTERNAL bool m0_addb_mon_ctx_invariant(struct m0_addb_monitoring_ctx *ctx)
+{
+	return ctx->amc_magic == M0_ADDB_MONITOR_CTX_MAGIC;
+}
+
 M0_INTERNAL void m0_addb_monitor_init(struct m0_addb_monitor           *monitor,
 				      const struct m0_addb_monitor_ops *mon_ops)
 {
@@ -339,9 +346,11 @@ M0_INTERNAL void m0_addb_monitor_del(struct m0_reqh         *reqh,
 		addb_svc = bob_of(svc, struct addb_svc, as_reqhs,
 				  &addb_svc_bob);
 
+		m0_mutex_lock(&reqh->rh_addb_monitoring_ctx.amc_mutex);
 		if (addb_svc->as_pfom.pf_mon == monitor) {
 			addb_svc->as_pfom.pf_mon = NULL;
 		}
+		m0_mutex_unlock(&reqh->rh_addb_monitoring_ctx.amc_mutex);
 	}
 	m0_mutex_lock(&reqh->rh_addb_monitoring_ctx.amc_mutex);
 	addb_mon_tlist_del(monitor);
@@ -377,6 +386,7 @@ M0_INTERNAL void m0_addb_monitors_fini(struct m0_reqh *reqh)
 
 	addb_mon_tlist_fini(&reqh->rh_addb_monitoring_ctx.amc_list);
 	m0_mutex_fini(&reqh->rh_addb_monitoring_ctx.amc_mutex);
+	reqh->rh_addb_monitoring_ctx.amc_magic = 0;
 }
 
 #define SUM_SIZE(sum) (sum->asr_rec.ss_data.au64s_nr * sizeof(uint64_t))
diff --git a/addb/addb_monitor.h b/addb/addb_monitor.h
index e849300..be699d9 100644
--- a/addb/addb_monitor.h
+++ b/addb/addb_monitor.h
@@ -219,11 +219,11 @@ enum {
 
 M0_TL_DESCR_DECLARE(addb_mon, M0_EXTERN);
 
-#define M0_ADDB_MONITOR_STATS_TYPE_REGISTER(stats_type, name) \
-do {                                                          \
-	stats_type.art_name = name;                           \
-	m0_addb_rec_type_register(&stats_type);               \
-} while (0)
+#define M0_ADDB_MONITOR_STATS_TYPE_REGISTER(stats_type, name)		\
+do {									\
+	(stats_type)->art_name = name;					\
+	m0_addb_rec_type_register(stats_type);				\
+} while(0)
 
 struct m0_addb_sum_rec {
 	/**
@@ -275,6 +275,7 @@ M0_INTERNAL bool m0_addb_monitor_invariant(struct m0_addb_monitor *mon);
  * object.
  */
 struct m0_addb_monitoring_ctx {
+	uint64_t               amc_magic;
 	/* List of active monitors */
 	struct m0_tl           amc_list;
 	/* Mutex to protect amc_list */
@@ -285,6 +286,11 @@ struct m0_addb_monitoring_ctx {
 };
 
 /**
+ * Monitor context invariant.
+ */
+M0_INTERNAL bool m0_addb_mon_ctx_invariant(struct m0_addb_monitoring_ctx *ctx);
+
+/**
  * Initialize ADDB monitoring sub-system
  * @param mach RPC machine
  * @param endpoint endpoint where stats service runs
diff --git a/addb/addb_rec.c b/addb/addb_rec.c
index 82cce73..10fdbea 100644
--- a/addb/addb_rec.c
+++ b/addb/addb_rec.c
@@ -158,7 +158,8 @@ static void addb_rec_post(struct m0_addb_mc *mc,
 	 * @todo: Find a way to remove this condition and instead assert
 	 * on not NULL.
 	 */
-	if (mc->am_reqh != NULL) {
+	if (mc->am_reqh != NULL &&
+	    m0_addb_mon_ctx_invariant(&mc->am_reqh->rh_addb_monitoring_ctx)) {
 		/* Invoke all the monitor's filters */
 		m0_mutex_lock(&mc->am_reqh->rh_addb_monitoring_ctx.amc_mutex);
 		m0_tl_for(addb_mon,
diff --git a/extra-libs/galois b/extra-libs/galois
index 3230956..10ccbd0 160000
--- a/extra-libs/galois
+++ b/extra-libs/galois
@@ -1 +1 @@
-Subproject commit 32309568c1977a934d9aab96552392417ca9dd21
+Subproject commit 10ccbd0ca55db92909fda817ee1065d914736440
diff --git a/fop/fom.c b/fop/fom.c
index 121d9af..22bfc98 100644
--- a/fop/fom.c
+++ b/fop/fom.c
@@ -27,6 +27,8 @@
 #include "lib/time.h"
 #include "lib/timer.h"
 #include "lib/arith.h"
+#define M0_TRACE_SUBSYSTEM M0_TRACE_SUBSYS_FOP
+#include "lib/trace.h"
 #include "db/db_common.h"
 #include "addb/addb.h"
 #include "mero/magic.h"
@@ -36,6 +38,7 @@
 #include "sm/sm.h"
 #include "fop/fop_addb.h"
 #include "rpc/rpc_machine.h"
+#include "addb/addb_monitor.h"
 
 /**
  * @addtogroup fom
@@ -153,6 +156,8 @@ struct m0_loc_thread {
 	uint64_t                lt_magix;
 };
 
+static m0_time_t fop_rate_interval = M0_MKTIME(1, 0);
+
 M0_TL_DESCR_DEFINE(thr, "fom thread", static, struct m0_loc_thread, lt_linkage,
 		   lt_magix, M0_FOM_THREAD_MAGIC, M0_FOM_THREAD_HEAD_MAGIC);
 M0_TL_DEFINE(thr, static, struct m0_loc_thread);
@@ -168,15 +173,132 @@ M0_TL_DEFINE(wail, static, struct m0_fom);
 static bool fom_wait_time_is_out(const struct m0_fom_domain *dom,
                                  const struct m0_fom *fom);
 static int loc_thr_create(struct m0_fom_locality *loc);
+static void __fom_domain_fini(struct m0_fom_domain *dom);
 
 /**
  * Fom domain operations.
  * @todo Support fom timeout functionality.
  */
+#undef FOM_RATE_KEY
+#define FOM_RATE_KEY(reqh)	(reqh->rh_fom_dom.fd_fop_rate_monitor_key)
+
 static struct m0_fom_domain_ops m0_fom_dom_ops = {
 	.fdo_time_is_out = fom_wait_time_is_out
 };
 
+static struct fop_rate_stats_sum_rec {
+	uint64_t ssr_fop_rate;
+} fop_rate_stats_sum;
+
+static struct m0_addb_sum_rec *
+fop_rate_monitor_sum_rec(const struct m0_addb_monitor *mon,
+		         struct m0_reqh               *reqh)
+{
+	struct m0_addb_sum_rec *sum_rec;
+
+	M0_PRE(reqh != NULL);
+
+	m0_rwlock_read_lock(&reqh->rh_rwlock);
+	sum_rec = m0_reqh_lockers_get(reqh, FOM_RATE_KEY(reqh));
+	m0_rwlock_read_unlock(&reqh->rh_rwlock);
+
+	M0_ASSERT(sum_rec != NULL);
+
+	return sum_rec;
+}
+
+static void fop_rate_monitor_watch(const struct m0_addb_monitor *monitor,
+				   const struct m0_addb_rec     *rec,
+				   struct m0_reqh               *reqh)
+{
+#undef FOP_RATE
+#define FOP_RATE(sum_rec)					\
+	(struct fop_rate_stats_sum_rec *)sum_rec->asr_rec.ss_data.au64s_data
+
+	struct m0_addb_sum_rec        *sum_rec;
+	struct fop_rate_stats_sum_rec *f_rate;
+
+	M0_PRE(reqh != NULL);
+
+	if (m0_addb_rec_rid_make(M0_ADDB_BRT_CNTR,
+			         M0_ADDB_RECID_FOP_RATE_CNTR) == rec->ar_rid) {
+
+		sum_rec = monitor->am_ops->amo_sum_rec(monitor, reqh);
+		M0_ASSERT(sum_rec != NULL);
+
+		m0_mutex_lock(&sum_rec->asr_mutex);
+		M0_ASSERT(sum_rec->asr_rec.ss_id ==
+			  M0_ADDB_RECID_FOP_RATE);
+		f_rate = FOP_RATE(sum_rec);
+		M0_ASSERT(f_rate != NULL);
+		/*
+		 * fop_rate is ADDB counter.
+		 * rec->ar_data.au64s_data[1] is number of samples
+		 * rec->ar_data.au64s_data[2] is sum_samples
+		 */
+		f_rate->ssr_fop_rate =
+		rec->ar_data.au64s_data[2] / rec->ar_data.au64s_data[1];
+		sum_rec->asr_dirty = true;
+		m0_mutex_unlock(&sum_rec->asr_mutex);
+	}
+#undef FOP_RATE
+}
+
+const struct m0_addb_monitor_ops fop_rate_monitor_ops = {
+	.amo_watch = fop_rate_monitor_watch,
+	.amo_sum_rec = fop_rate_monitor_sum_rec
+};
+
+static int fop_rate_monitor_init(struct m0_reqh         *reqh,
+				 struct m0_addb_monitor *monitor,
+				 uint32_t               *fop_rate_monitor_key)
+{
+#undef FOP_RATE_STATS_NR
+#define FOP_RATE_STATS_NR (sizeof(fop_rate_stats_sum) / sizeof(uint64_t))
+
+	struct m0_addb_sum_rec *sum_rec;
+
+	M0_PRE(monitor != NULL && reqh != NULL);
+
+	FOP_ALLOC_PTR(sum_rec, FOM_RATE_MON_INIT, &m0_fop_addb_ctx);
+	if (sum_rec == NULL)
+		M0_RETURN(-ENOMEM);
+
+	m0_addb_monitor_init(monitor, &fop_rate_monitor_ops);
+	m0_addb_monitor_sum_rec_init(sum_rec, &m0_addb_rt_fop_rate,
+				     (uint64_t *)&fop_rate_stats_sum,
+				     FOP_RATE_STATS_NR);
+
+	*fop_rate_monitor_key = m0_reqh_lockers_allot();
+
+	m0_rwlock_write_lock(&reqh->rh_rwlock);
+	m0_reqh_lockers_set(reqh, *fop_rate_monitor_key, sum_rec);
+	m0_rwlock_write_unlock(&reqh->rh_rwlock);
+
+	m0_addb_monitor_add(reqh, monitor);
+	return 0;
+}
+
+static void fop_rate_monitor_fini(struct m0_reqh         *reqh,
+				  struct m0_addb_monitor *monitor,
+				  uint32_t                fop_rate_monitor_key)
+{
+	struct m0_addb_sum_rec *sum_rec;
+
+	M0_PRE(monitor != NULL && reqh != NULL);
+
+	sum_rec = monitor->am_ops->amo_sum_rec(monitor, reqh);
+	m0_addb_monitor_del(reqh, monitor);
+
+	m0_rwlock_write_lock(&reqh->rh_rwlock);
+	m0_reqh_lockers_clear(reqh, fop_rate_monitor_key);
+	m0_rwlock_write_unlock(&reqh->rh_rwlock);
+
+	m0_addb_monitor_sum_rec_fini(sum_rec);
+	m0_free(sum_rec);
+
+	m0_addb_monitor_fini(monitor);
+}
 static void group_lock(struct m0_fom_locality *loc)
 {
 	m0_sm_group_lock(&loc->fl_group);
@@ -536,6 +658,8 @@ static void fom_exec(struct m0_fom *fom)
 				exec_time >> 10); /* ~usec */
 
 	if (m0_fom_phase(fom) == M0_FOM_PHASE_FINISH) {
+		m0_time_t        now = m0_time_now();
+
                 /*
                  * Finish fom itself.
                  */
@@ -543,6 +667,14 @@ static void fom_exec(struct m0_fom *fom)
 		/*
 		 * Don't touch the fom after this point.
 		 */
+		++loc->fl_fop_rate_count;
+		if (now >= loc->fl_fop_rate_next_update) {
+			m0_addb_counter_update(&loc->fl_stat_fop_rate,
+					       loc->fl_fop_rate_count);
+			loc->fl_fop_rate_next_update =
+				m0_time_add(now, fop_rate_interval);
+			loc->fl_fop_rate_count = 0;
+		}
 	} else {
 		struct m0_fom_callback *cb;
 
@@ -758,6 +890,7 @@ static void loc_fini(struct m0_fom_locality *loc)
 
 	m0_addb_counter_fini(&loc->fl_stat_sched_wait_times);
 	m0_addb_counter_fini(&loc->fl_stat_run_times);
+	m0_addb_counter_fini(&loc->fl_stat_fop_rate);
 	m0_addb_ctx_fini(&loc->fl_addb_ctx);
 }
 
@@ -795,17 +928,19 @@ static int loc_init(struct m0_fom_locality *loc, size_t cpu, size_t cpu_max)
 
 	result = m0_addb_counter_init(&loc->fl_stat_run_times,
 				      &m0_addb_rt_fl_run_times);
-	if (result != 0) {
-		m0_addb_ctx_fini(&loc->fl_addb_ctx);
-		return result;
-	}
+	if (result != 0)
+		goto err3;
+
 	result = m0_addb_counter_init(&loc->fl_stat_sched_wait_times,
 				      &m0_addb_rt_fl_sched_wait_times);
-	if (result != 0) {
-		m0_addb_counter_fini(&loc->fl_stat_run_times);
-		m0_addb_ctx_fini(&loc->fl_addb_ctx);
-		return result;
-	}
+	if (result != 0)
+		goto err2;
+
+	loc->fl_fop_rate_next_update = 0;
+	result = m0_addb_counter_init(&loc->fl_stat_fop_rate,
+				      &m0_addb_rt_fop_rate_cntr);
+	if (result != 0)
+		goto err1;
 
 	runq_tlist_init(&loc->fl_runq);
 	loc->fl_runq_nr = 0;
@@ -840,6 +975,14 @@ static int loc_init(struct m0_fom_locality *loc, size_t cpu, size_t cpu_max)
 		loc_fini(loc);
 
 	return result;
+
+err1:
+	m0_addb_counter_fini(&loc->fl_stat_sched_wait_times);
+err2:
+	m0_addb_counter_fini(&loc->fl_stat_run_times);
+err3:
+	m0_addb_ctx_fini(&loc->fl_addb_ctx);
+	return result;
 }
 
 static void loc_ast_post_stats(struct m0_sm_group *grp, struct m0_sm_ast *ast)
@@ -854,6 +997,9 @@ static void loc_ast_post_stats(struct m0_sm_group *grp, struct m0_sm_ast *ast)
 	if (m0_addb_counter_nr(&loc->fl_stat_sched_wait_times) > 0)
 		M0_ADDB_POST_CNTR(&loc->fl_dom->fd_reqh->rh_addb_mc, cv,
 				  &loc->fl_stat_sched_wait_times);
+	if (m0_addb_counter_nr(&loc->fl_stat_fop_rate) > 0)
+		M0_ADDB_POST_CNTR(&loc->fl_dom->fd_reqh->rh_addb_mc, cv,
+				  &loc->fl_stat_fop_rate);
 	M0_ADDB_POST(&loc->fl_dom->fd_reqh->rh_addb_mc, &m0_addb_rt_fl_runq_nr,
 		     cv, loc->fl_runq_nr);
 	M0_ADDB_POST(&loc->fl_dom->fd_reqh->rh_addb_mc, &m0_addb_rt_fl_wail_nr,
@@ -903,7 +1049,7 @@ M0_INTERNAL int m0_fom_domain_init(struct m0_fom_domain *dom)
 		loc->fl_dom = dom;
 		result = loc_init(loc, cpu, cpu_max);
 		if (result != 0) {
-			m0_fom_domain_fini(dom);
+			__fom_domain_fini(dom);
 			break;
 		}
 		m0_locality_set(cpu, &(struct m0_locality){
@@ -912,12 +1058,15 @@ M0_INTERNAL int m0_fom_domain_init(struct m0_fom_domain *dom)
 				.lo_idx  = dom->fd_localities_nr });
 		M0_CNT_INC(dom->fd_localities_nr);
 	}
-	m0_bitmap_fini(&onln_cpu_map);
 
-	return result;
+	m0_bitmap_fini(&onln_cpu_map);
+	dom->fd_fop_rate_monitor_key = 0;
+	return fop_rate_monitor_init(dom->fd_reqh,
+				     &dom->fd_fop_rate_monitor,
+				     &dom->fd_fop_rate_monitor_key);
 }
 
-M0_INTERNAL void m0_fom_domain_fini(struct m0_fom_domain *dom)
+static void __fom_domain_fini(struct m0_fom_domain *dom)
 {
 	int fd_loc_nr;
 
@@ -932,6 +1081,14 @@ M0_INTERNAL void m0_fom_domain_fini(struct m0_fom_domain *dom)
 	m0_free(dom->fd_localities);
 }
 
+M0_INTERNAL void m0_fom_domain_fini(struct m0_fom_domain *dom)
+{
+	__fom_domain_fini(dom);
+	fop_rate_monitor_fini(dom->fd_reqh,
+			      &dom->fd_fop_rate_monitor,
+			      dom->fd_fop_rate_monitor_key);
+}
+
 M0_INTERNAL bool m0_fom_domain_is_idle(const struct m0_fom_domain *dom)
 {
 	return m0_forall(i, dom->fd_localities_nr,
@@ -1397,6 +1554,7 @@ M0_INTERNAL int m0_fom_fol_rec_add(struct m0_fom *fom)
 }
 
 /** @} endgroup fom */
+#undef FOM_RATE_KEY
 /*
  *  Local variables:
  *  c-indentation-style: "K&R"
diff --git a/fop/fom.h b/fop/fom.h
index 4bd5fc9..a422ee3 100644
--- a/fop/fom.h
+++ b/fop/fom.h
@@ -210,6 +210,7 @@ Doc?docid=0AQaCw6YRYSVSZGZmMzV6NzJfMTNkOGNjZmdnYg
 #include "dtm/dtm.h"           /* m0_dtx */
 #include "stob/stob.h"
 #include "reqh/reqh_service.h"
+#include "addb/addb_monitor.h"
 
 /* export */
 struct m0_fom_domain;
@@ -296,6 +297,11 @@ struct m0_fom_locality {
 	 */
 	struct m0_addb_counter       fl_stat_sched_wait_times;
 
+	/** FOP rate counter. It is fop executed per sec. */
+	uint64_t                     fl_fop_rate_count;
+	m0_time_t		     fl_fop_rate_next_update;
+	struct m0_addb_counter       fl_stat_fop_rate;
+
 	/** AST which triggers the posting of statistics */
 	struct m0_sm_ast             fl_post_stats_ast;
 
@@ -334,6 +340,10 @@ struct m0_fom_domain {
 	struct m0_reqh			*fd_reqh;
 	/** Addb context for fom */
 	struct m0_addb_ctx               fd_addb_ctx;
+	/** fop rate monitor key */
+	uint32_t			 fd_fop_rate_monitor_key;
+	/** fop rate monitor */
+	struct m0_addb_monitor           fd_fop_rate_monitor;
 };
 
 /** Operations vector attached to a domain. */
diff --git a/fop/fop.c b/fop/fop.c
index b830ed5..ac9cc41 100644
--- a/fop/fop.c
+++ b/fop/fop.c
@@ -34,6 +34,7 @@
 #include "fop/fop.h"
 #include "fop/fop_xc.h"
 #include "fop/fom_long_lock.h" /* m0_fom_ll_global_init */
+#include "addb/addb_monitor.h" /* stats register */
 
 /**
    @addtogroup fop
@@ -256,6 +257,8 @@ M0_INTERNAL int m0_fops_init(void)
 	m0_addb_rec_type_register(&m0_addb_rt_fl_sched_wait_times);
 	m0_addb_rec_type_register(&m0_addb_rt_fl_runq_nr);
 	m0_addb_rec_type_register(&m0_addb_rt_fl_wail_nr);
+	m0_addb_rec_type_register(&m0_addb_rt_fop_rate_cntr);
+        M0_ADDB_MONITOR_STATS_TYPE_REGISTER(&m0_addb_rt_fop_rate, "fop_rate");
 	M0_ADDB_CTX_INIT(&m0_addb_gmc, &m0_fop_addb_ctx, &m0_addb_ct_fop_mod,
 			 &m0_addb_proc_ctx);
 	ft_tlist_init(&fop_types_list);
diff --git a/fop/fop_addb.h b/fop/fop_addb.h
index c1b5a19..c0028ce 100644
--- a/fop/fop_addb.h
+++ b/fop/fop_addb.h
@@ -68,7 +68,8 @@ M0_ALLOC_ARR_ADDB(ptr, nr, &m0_addb_gmc, M0_FOP_ADDB_LOC_##loc, ctx)
  */
 enum {
 	M0_FOP_ADDB_LOC_LOC_THR_CREATE    = 10,
-	M0_FOP_ADDB_LOC_FOM_DOMAIN_INIT   = 20
+	M0_FOP_ADDB_LOC_FOM_DOMAIN_INIT   = 20,
+	M0_FOP_ADDB_LOC_FOM_RATE_MON_INIT = 30,
 };
 
 extern struct m0_addb_ctx m0_fop_addb_ctx;
@@ -85,13 +86,15 @@ extern struct m0_addb_ctx m0_fop_addb_ctx;
  * Do not change the numbering.
  */
 enum {
-	M0_ADDB_RECID_FOM_INIT = 60,
-	M0_ADDB_RECID_FOM_FINI = 61,
-	M0_ADDB_RECID_FOM_STATE_STATS = 62,
-	M0_ADDB_RECID_FL_RUN_TIMES = 65,
+	M0_ADDB_RECID_FOM_INIT            = 60,
+	M0_ADDB_RECID_FOM_FINI            = 61,
+	M0_ADDB_RECID_FOM_STATE_STATS     = 62,
+	M0_ADDB_RECID_FL_RUN_TIMES        = 65,
 	M0_ADDB_RECID_FL_SCHED_WAIT_TIMES = 66,
-	M0_ADDB_RECID_FL_RUNQ_NR = 67,
-	M0_ADDB_RECID_FL_WAIL_NR = 68,
+	M0_ADDB_RECID_FL_RUNQ_NR          = 67,
+	M0_ADDB_RECID_FL_WAIL_NR          = 68,
+	M0_ADDB_RECID_FOP_RATE_CNTR       = 69,
+	M0_ADDB_RECID_FOP_RATE            = 70,
 };
 
 /**
@@ -132,11 +135,15 @@ M0_ADDB_RT_CNTR(m0_addb_rt_fl_run_times, M0_ADDB_RECID_FL_RUN_TIMES);
 /** Accumulated scheduling overhead of all locality foms (in binary usec). */
 M0_ADDB_RT_CNTR(m0_addb_rt_fl_sched_wait_times,
 		M0_ADDB_RECID_FL_SCHED_WAIT_TIMES);
+/** FOP rate (number of fop executed per sec) **/
+M0_ADDB_RT_CNTR(m0_addb_rt_fop_rate_cntr, M0_ADDB_RECID_FOP_RATE_CNTR);
 
 /** Locality run queue length */
 M0_ADDB_RT_DP(m0_addb_rt_fl_runq_nr, M0_ADDB_RECID_FL_RUNQ_NR, "runq_nr");
 /** Locality wait queue (list) length */
 M0_ADDB_RT_DP(m0_addb_rt_fl_wail_nr, M0_ADDB_RECID_FL_WAIL_NR, "wail_nr");
+/** ADDB summary record for fop rate stats */
+M0_ADDB_RT_STATS(m0_addb_rt_fop_rate, M0_ADDB_RECID_FOP_RATE, "fop_rate");
 
 /** @} end of fom group */
 
diff --git a/m0t1fs/linux_kernel/m0t1fs.c b/m0t1fs/linux_kernel/m0t1fs.c
index a216236..75f0ea7 100644
--- a/m0t1fs/linux_kernel/m0t1fs.c
+++ b/m0t1fs/linux_kernel/m0t1fs.c
@@ -116,7 +116,7 @@ M0_INTERNAL int m0t1fs_init(void)
 	RT_REG(dgiow_times);
 #undef RT_REG
 
-	M0_ADDB_MONITOR_STATS_TYPE_REGISTER(m0_addb_rt_m0t1fs_mon_io_size,
+	M0_ADDB_MONITOR_STATS_TYPE_REGISTER(&m0_addb_rt_m0t1fs_mon_io_size,
 					    "io_size");
 
 	m0t1fs_globals.g_laddr = local_addr;
diff --git a/m0t1fs/linux_kernel/st/m0t1fs_common_inc.sh b/m0t1fs/linux_kernel/st/m0t1fs_common_inc.sh
index a68070a..f15acb3 100644
--- a/m0t1fs/linux_kernel/st/m0t1fs_common_inc.sh
+++ b/m0t1fs/linux_kernel/st/m0t1fs_common_inc.sh
@@ -38,6 +38,7 @@ MERO_IOSERVICE_NAME=ioservice
 MERO_MDSERVICE_NAME=mdservice
 MERO_SNSREPAIRSERVICE_NAME=sns_repair
 MERO_SNSREBALANCESERVICE_NAME=sns_rebalance
+MERO_STATSSERVICE_NAME=stats
 MERO_RMSERVICE_NAME=rmservice
 MERO_STOB_DOMAIN=linux
 
diff --git a/m0t1fs/linux_kernel/st/m0t1fs_server_inc.sh b/m0t1fs/linux_kernel/st/m0t1fs_server_inc.sh
index 9d8f1be..6e177b1 100644
--- a/m0t1fs/linux_kernel/st/m0t1fs_server_inc.sh
+++ b/m0t1fs/linux_kernel/st/m0t1fs_server_inc.sh
@@ -25,7 +25,7 @@ mero_service()
 		for ((i=0; i < ${#EP[*]}; i++)) ; do
 			SNAME="-s $MERO_ADDBSERVICE_NAME"
 			if ((i == 0)); then
-				SNAME="-s $MERO_MDSERVICE_NAME -s $MERO_RMSERVICE_NAME $SNAME"
+				SNAME="-s $MERO_MDSERVICE_NAME -s $MERO_RMSERVICE_NAME $SNAME -s $MERO_STATSSERVICE_NAME"
 			else
 				SNAME="-s $MERO_IOSERVICE_NAME -s $MERO_SNSREPAIRSERVICE_NAME \
 				      -s $MERO_SNSREBALANCESERVICE_NAME $SNAME"
diff --git a/mero/magic.h b/mero/magic.h
index 74a6481..dfc8621 100644
--- a/mero/magic.h
+++ b/mero/magic.h
@@ -120,6 +120,9 @@ enum m0_magic_satchel {
 	/* ADDB monitor (addb shoebill) */
 	M0_ADDB_MONITOR_LIST_LINK_MAGIC = 0x33addb7719304577,
 
+	/* m0_addb_monitoring_ctx::amc_magic (basils basils) */
+	M0_ADDB_MONITOR_CTX_MAGIC = 0x33ba5115ba511577,
+
 /* balloc */
 	/* m0_balloc_super_block::bsb_magic (blessed baloc) */
 	M0_BALLOC_SB_MAGIC = 0x33b1e55edba10c77,
diff --git a/reqh/reqh.c b/reqh/reqh.c
index 6f7e824..52a6217 100644
--- a/reqh/reqh.c
+++ b/reqh/reqh.c
@@ -72,6 +72,8 @@ M0_TL_DEFINE(m0_reqh_rpc_mach, , struct m0_rpc_machine);
 
 M0_LOCKERS_DEFINE(M0_INTERNAL, m0_reqh, rh_lockers);
 
+static void __reqh_fini(struct m0_reqh *reqh);
+
 /**
    Request handler state machine description
  */
@@ -160,28 +162,41 @@ m0_reqh_init(struct m0_reqh *reqh, const struct m0_reqh_init_args *reqh_args)
 	M0_ADDB_CTX_INIT(&m0_addb_gmc, &reqh->rh_addb_ctx,
 			 &m0_addb_ct_reqh_mod, &m0_addb_proc_ctx);
 
+	m0_rwlock_init(&reqh->rh_rwlock);
+	m0_reqh_lockers_init(reqh);
+
 	rc = m0_addb_monitors_init(reqh);
 	if (rc != 0)
-		return rc;
+		goto monitors_init_failed;
 
 	reqh->rh_fom_dom.fd_reqh = reqh;
 	rc = m0_fom_domain_init(&reqh->rh_fom_dom);
 	if (rc != 0)
-		return rc;
+		goto fom_domain_init_failed;
 
 	m0_reqh_svc_tlist_init(&reqh->rh_services);
 	m0_reqh_rpc_mach_tlist_init(&reqh->rh_rpc_machines);
 	m0_sm_group_init(&reqh->rh_sm_grp);
 	m0_mutex_init(&reqh->rh_mutex); /* deprecated */
 	m0_chan_init(&reqh->rh_sd_signal, &reqh->rh_mutex); /* deprecated */
-	m0_rwlock_init(&reqh->rh_rwlock);
 	m0_sm_init(&reqh->rh_sm, &m0_reqh_sm_conf, M0_REQH_ST_INIT,
 		   &reqh->rh_sm_grp);
-	m0_reqh_lockers_init(reqh);
 
-	if (reqh->rh_beseg != NULL)
+	if (reqh->rh_beseg != NULL) {
 		rc = m0_reqh_dbenv_init(reqh, reqh->rh_beseg);
+		if (rc != 0)
+			__reqh_fini(reqh);
+	}
+	return rc;
 
+fom_domain_init_failed:
+	m0_addb_monitors_fini(reqh);
+monitors_init_failed:
+	m0_rwlock_fini(&reqh->rh_rwlock);
+	m0_reqh_lockers_fini(reqh);
+	m0_addb_ctx_fini(&reqh->rh_addb_ctx);
+	m0_addb_mc_fini(&reqh->rh_addb_mc);
+	m0_ha_domain_fini(&reqh->rh_hadom);
 	return rc;
 }
 
@@ -354,17 +369,16 @@ M0_INTERNAL void m0_reqh_dbenv_fini(struct m0_reqh *reqh)
 	m0_addb_mc_unconfigure(&reqh->rh_addb_mc);
 }
 
-M0_INTERNAL void m0_reqh_fini(struct m0_reqh *reqh)
+static void __reqh_fini(struct m0_reqh *reqh)
 {
-	m0_reqh_dbenv_fini(reqh);
 	m0_sm_group_lock(&reqh->rh_sm_grp);
 	m0_sm_fini(&reqh->rh_sm);
 	m0_sm_group_unlock(&reqh->rh_sm_grp);
 	m0_sm_group_fini(&reqh->rh_sm_grp);
 	m0_addb_ctx_fini(&reqh->rh_addb_ctx);
-	m0_addb_monitors_fini(reqh);
 	m0_addb_mc_fini(&reqh->rh_addb_mc);
         m0_fom_domain_fini(&reqh->rh_fom_dom);
+	m0_addb_monitors_fini(reqh);
         m0_reqh_svc_tlist_fini(&reqh->rh_services);
         m0_reqh_rpc_mach_tlist_fini(&reqh->rh_rpc_machines);
 	m0_reqh_lockers_fini(reqh);
@@ -374,6 +388,12 @@ M0_INTERNAL void m0_reqh_fini(struct m0_reqh *reqh)
 	m0_ha_domain_fini(&reqh->rh_hadom);
 }
 
+M0_INTERNAL void m0_reqh_fini(struct m0_reqh *reqh)
+{
+	m0_reqh_dbenv_fini(reqh);
+	__reqh_fini(reqh);
+}
+
 M0_INTERNAL void m0_reqhs_fini(void)
 {
 	m0_reqh_service_types_fini();
diff --git a/reqh/reqh.h b/reqh/reqh.h
index 7ded85e..106a8b3 100644
--- a/reqh/reqh.h
+++ b/reqh/reqh.h
@@ -62,7 +62,7 @@ struct m0_net_xprt;
 struct m0_rpc_machine;
 struct m0_local_service_ops;
 
-M0_LOCKERS_DECLARE(M0_EXTERN, m0_reqh, 64);
+M0_LOCKERS_DECLARE(M0_EXTERN, m0_reqh, 256);
 
 /** Local reply consumer service (testing or replicator) */
 struct m0_local_service {
diff --git a/scripts/m0mount.sh b/scripts/m0mount.sh
index 918fc0a..9f4203d 100755
--- a/scripts/m0mount.sh
+++ b/scripts/m0mount.sh
@@ -439,7 +439,7 @@ M0_TRACE_LEVEL=$M0_TRACE_LEVEL \
 M0_TRACE_PRINT_CONTEXT=$M0_TRACE_PRINT_CONTEXT \
 $BROOT/mero/m0d -r -p \
 $STOB_PARAMS -D $DDIR/db -S $DDIR/stobs -A $DDIR/stobs \
--w $POOL_WIDTH -G $XPT:$MDS_EP
+-w $POOL_WIDTH -G $XPT:$MDS_EP -R $XPT:$STATS_EP
 -e $XPT:$EP $IOS_EPs $SNAME $XPT_SETUP" > ${SLOG}$I.log &
 	if [ $? -ne 0 ]; then
 		echo ERROR: Failed to start remote server on $H
@@ -461,6 +461,7 @@ function start_servers () {
 	fi
 
 	MDS_EP=${SERVICES[1]}
+	STATS_EP=${SERVICES[1]}
 	IOS_EPs=" -i $XPT:$MDS_EP"
 	for i in `seq 3 2 ${#SERVICES[*]}`; do
 		IOS_EPs="$IOS_EPs -i $XPT:${SERVICES[$i]}"
diff --git a/stats/util/stats_util.c b/stats/util/stats_util.c
index 299949c..895fb2c 100644
--- a/stats/util/stats_util.c
+++ b/stats/util/stats_util.c
@@ -47,14 +47,12 @@ enum {
 	STATS_MAX_NAME_SIZE = 32,
 	STATS_DEFAULT_COUNT = 1,
 	STATS_DEFAULT_DELAY = 5,
-	STATS_EP_PID	    = 12345,
-	STATS_EP_PORTAL     = 41,
-        STATS_EP_TM         = 1,
-	STATS_VALUE_WIDTH  = 16,
+	STATS_VALUE_WIDTH   = 16,
 };
 
 static struct m0_net_xprt        *xprt           = &m0_net_lnet_xprt;
 static struct m0_net_domain       client_net_dom = { };
+static bool signaled = false;
 
 static struct m0_rpc_client_ctx cctx = {
 	.rcx_net_dom               = &client_net_dom,
@@ -69,7 +67,8 @@ static void m0stats_help()
 	fprintf(stderr,
 "Usage: m0stats \n"
 "\n"
-"-e EndPoint    Specify the raw transport end point address.\n"
+"-e EndPoint    Specify the raw transport local end point address.\n"
+"-R EndPoint    Specify the raw transport stats service end point address.\n"
 "-s StatsNames  Specify one or more comma separated stats names.\n"
 "-o FileName    Specify output file name.\n"
 "-l             Lists defined statistics names.\n"
@@ -180,25 +179,32 @@ static void stats_print_header(FILE *out, struct m0_addb_uint64_seq *stats_ids)
 	fprintf(out, "\n");
 }
 
-static void stats_print_values(FILE *out,
+static void stats_print_values(FILE *out, struct m0_addb_uint64_seq *stats_ids,
 			       const struct m0_stats_recs *stats_recs)
 {
+#undef STATS_FIELD_VALUE
+#define STATS_FIELD_VALUE(stats_sum, j)			\
+	(stats_sum.ss_data.au64s_nr != rt->art_rf_nr ?	\
+	(uint64_t)0 : stats_sum.ss_data.au64s_data[j])
+
 	int i;
 	int j;
 
-	for (i = 0; i < stats_recs->sf_nr; ++i) {
+	for (i = 0; i < stats_ids->au64s_nr; ++i) {
 		const struct m0_addb_rec_type *rt =
-			m0_addb_rec_type_lookup(stats_recs->sf_stats[i].ss_id);
-		if (rt == NULL)
-			continue;
-		if (stats_recs->sf_stats[i].ss_data.au64s_nr != rt->art_rf_nr)
-			continue;
-		for (j = 0; j < stats_recs->sf_stats[i].ss_data.au64s_nr; ++j)
+			m0_addb_rec_type_lookup(stats_ids->au64s_data[i]);
+		if (rt == NULL) {
+			fprintf(out, "Failed to retrived stats info.\n");
+			break;
+		}
+
+		for (j = 0; j < rt->art_rf_nr; ++j)
 			fprintf(out, "%*lu",
 				stats_field_width(rt->art_rf[j].arfu_name),
-				stats_recs->sf_stats[i].ss_data.au64s_data[j]);
+				STATS_FIELD_VALUE(stats_recs->sf_stats[i], j));
 	}
 	fprintf(out, "\n");
+#undef STATS_FIELD_VALUE
 }
 
 static int stats_print_list()
@@ -217,28 +223,7 @@ static int stats_print_list()
 
 static void sig_handler(int signum)
 {
-}
-
-static int stats_local_ep(char *ep)
-{
-	int  rc;
-	char hostname[M0_CFG_NAME_LEN];
-	char addr[M0_CFG_NAME_LEN];
-
-	M0_PRE(ep != NULL);
-
-	rc = gethostname(hostname, sizeof hostname);
-	if (rc != 0)
-		return rc;
-
-	rc = m0_host_resolve(hostname, addr, sizeof addr);
-	if (rc != 0)
-		return rc;
-
-	sprintf(ep, "%s@tcp:%d:%d:%d", addr, STATS_EP_PID, STATS_EP_PORTAL,
-		STATS_EP_TM);
-
-	return 0;
+	signaled = true;
 }
 
 int main(int argc, char *argv[])
@@ -247,6 +232,7 @@ int main(int argc, char *argv[])
 	int                         rc = 0;
 	int                         r2;
 	struct sigaction            sa;
+	const char                 *local_addr = NULL;
 	const char                 *remote_addr = NULL;
 	const char                 *outfile     = NULL;
 	const char                 *stats_list  = NULL;
@@ -257,10 +243,9 @@ int main(int argc, char *argv[])
 	struct m0_addb_uint64_seq  *stats_ids  = NULL;
 	struct cs_endpoint_and_xprt epx;
 	FILE			   *fout;
-	char                        local_ep[M0_CFG_NAME_LEN];
 
 	r2 = M0_GETOPTS("m0stats", argc, argv,
-			M0_STRINGARG('e', "Stats service endpoint",
+			M0_STRINGARG('R', "Stats service endpoint",
 				LAMBDA(void, (const char *str)
 				{
 					if (remote_addr != NULL)
@@ -268,6 +253,14 @@ int main(int argc, char *argv[])
 					else
 						remote_addr = str;
 				})),
+			M0_STRINGARG('e', "Local endpoint",
+				LAMBDA(void, (const char *str)
+				{
+					if (local_addr != NULL)
+						rc = -EINVAL;
+					else
+						local_addr = str;
+				})),
 			M0_STRINGARG('s', "Stats list",
 				LAMBDA(void, (const char *str)
 				{
@@ -301,7 +294,8 @@ int main(int argc, char *argv[])
 	}
 
 	if (!ergo(list_names,
-		 remote_addr == NULL && stats_list == NULL && outfile == NULL)){
+		 local_addr == NULL && remote_addr == NULL &&
+		 stats_list == NULL && outfile == NULL)){
 		m0stats_help();
 		return 1;
 	}
@@ -328,16 +322,6 @@ int main(int argc, char *argv[])
 		stats_print_list();
 		goto mero_fini;
 	}
-	rc = stats_local_ep(local_ep);
-	if (rc != 0) {
-		fprintf(stderr, "Failed to get local address. rc = %d\n", rc);
-		goto mero_fini;
-	}
-
-	if (remote_addr == NULL || stats_list == NULL) {
-		m0stats_help();
-		return 1;
-	}
 
 	if (outfile != NULL) {
 		fout = fopen(outfile, "w");
@@ -349,15 +333,21 @@ int main(int argc, char *argv[])
 	} else
 		fout = stdout;
 
-	rc = m0_ep_and_xprt_extract(&epx, remote_addr);
+	rc = m0_ep_and_xprt_extract(&epx, local_addr);
 	if (rc != 0) {
                 fprintf(stderr,
 			"m0stats:Failed to extract endpoint. rc = %d\n", rc);
 		goto mero_fini_fclose;
 	}
+	cctx.rcx_local_addr = epx.ex_endpoint;
 
-	cctx.rcx_remote_addr = epx.ex_endpoint;
-	cctx.rcx_local_addr  = strdup(local_ep);
+	rc = m0_ep_and_xprt_extract(&epx, remote_addr);
+	if (rc != 0) {
+                fprintf(stderr,
+			"m0stats:Failed to extract endpoint. rc = %d\n", rc);
+		goto mero_fini_fclose;
+	}
+	cctx.rcx_remote_addr  = epx.ex_endpoint;
 
 
         rc = m0_net_xprt_init(xprt);
@@ -384,7 +374,7 @@ int main(int argc, char *argv[])
 		goto disconnect;
 
 	stats_print_header(fout, stats_ids);
-	for (i = 0; i < count; ++i) {
+	for (i = 0; i < count && !signaled; ++i) {
 		rc = m0_stats_query(&cctx.rcx_session, stats_ids, &stats_recs);
 		if (rc != 0) {
 			fprintf(stderr,"m0stats:m0_stats_query failed."
@@ -392,8 +382,10 @@ int main(int argc, char *argv[])
 			rc = EX_UNAVAILABLE;
 		}
 
-		stats_print_values(fout, stats_recs);
-		m0_stats_free(stats_recs);
+		if (stats_recs != NULL) {
+			stats_print_values(fout, stats_ids, stats_recs);
+			m0_stats_free(stats_recs);
+		}
 		m0_nanosleep(delay * 1000 * 1000 * 1000, NULL);
 	}
 
-- 
1.8.3.2

