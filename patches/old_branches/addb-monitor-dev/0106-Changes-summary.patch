From 8df0dfa3e52d259bf9942dfff1488598de3f1345 Mon Sep 17 00:00:00 2001
From: Rohan Puri <rohan_puri@xyratex.com>
Date: Wed, 23 Oct 2013 18:40:39 +0530
Subject: [PATCH 106/125] Changes summary : - 1. Add two new cases for UT of
 addb monitor infrastructure. 	- Case 1: Check posting summaries for both the
 cases where we                   send fop.         - Case 2: Dynamically
 add/remove addb monitors. 2. For these above case, made BATCH as configurable
 global variable instead    of existing enum. 3. Few style fixes.

These changes are part of round 1 review of addb-monitoring-infrastructure
at link http://reviewboard.clusterstor.com/r/1544/
---
 addb/addb_monitor.c         |  20 +++++----
 addb/ut/addb_ut_mon_infra.c | 104 +++++++++++++++++++++++++++++++++-----------
 2 files changed, 90 insertions(+), 34 deletions(-)

diff --git a/addb/addb_monitor.c b/addb/addb_monitor.c
index af01083..c04beb2 100644
--- a/addb/addb_monitor.c
+++ b/addb/addb_monitor.c
@@ -405,10 +405,6 @@ M0_INTERNAL void m0_addb_monitors_fini(struct m0_reqh *reqh)
 
 enum {
 	/**
-	 * How many records to send in one fop
-	 */
-	BATCH = 1024,
-	/**
 	 * Maximal number of records (dirty or clean) scanned in one
 	 * invocation of m0_addb_monitor_summaries_post(). This limits
 	 * processor consumption.
@@ -421,6 +417,11 @@ enum {
 	SENT_LIMIT = 3
 };
 
+/**
+ * How many records to send in one fop
+ */
+static unsigned stats_batch = 1024;
+
 static void addb_mon_fop_free(struct m0_stats_update_fop *fop_data,
 			      uint32_t                    stats_nr)
 {
@@ -478,8 +479,8 @@ M0_INTERNAL int m0_addb_monitor_summaries_post(struct m0_reqh       *reqh,
 	struct m0_addb_monitoring_ctx *mon_ctx;
 	/* Continue scanning from the place we left last time */
 	struct m0_addb_monitor        *mon       = fom->pf_mon;
-	struct m0_stats_update_fop    *fop       =  NULL;
-	uint32_t                       stats_nr  =  0;
+	struct m0_stats_update_fop    *fop       = NULL;
+	uint32_t                       stats_nr  = 0;
 	uint32_t                       used      = 0;
 	uint32_t                       scanned   = 0;
 	uint32_t                       sent      = 0;
@@ -517,7 +518,8 @@ M0_INTERNAL int m0_addb_monitor_summaries_post(struct m0_reqh       *reqh,
 		if (fop == NULL) {
 			M0_ALLOC_PTR(fop);
 			if (fop != NULL)
-				M0_ALLOC_ARR(fop->suf_stats.sf_stats, BATCH);
+				M0_ALLOC_ARR(fop->suf_stats.sf_stats,
+					     stats_batch);
 		}
 		data = m0_alloc(SUM_SIZE(sum));
 		if (fop == NULL || fop->suf_stats.sf_stats == NULL ||
@@ -543,8 +545,8 @@ M0_INTERNAL int m0_addb_monitor_summaries_post(struct m0_reqh       *reqh,
 					   m0_addb_rec_type_lookup(rec->ss_id),
 					   cv, rec);
 		m0_mutex_lock(&reqh->rh_addb_monitoring_ctx.amc_mutex);
-		if (used == BATCH) {
-			fop->suf_stats.sf_nr = BATCH;
+		if (used == stats_batch) {
+			fop->suf_stats.sf_nr = stats_batch;
 			result =
 			addb_monitor_stats_fop_send(fop,
 					            mon_ctx->amc_stats_conn);
diff --git a/addb/ut/addb_ut_mon_infra.c b/addb/ut/addb_ut_mon_infra.c
index b9cfaeb..2070338 100644
--- a/addb/ut/addb_ut_mon_infra.c
+++ b/addb/ut/addb_ut_mon_infra.c
@@ -23,7 +23,7 @@
 enum {
 	UT_ADDB_MON_TS_INIT_PAGES  = 16,
 	UT_ADDB_MON_TS_MAX_PAGES   = 36,
-	UT_ADDB_MON_TS_PAGE_SIZE  = 4096, /* bytes */
+	UT_ADDB_MON_TS_PAGE_SIZE   = 4096, /* bytes */
 	UT_ADDB_MONS_NR            = 10,
 };
 
@@ -38,12 +38,14 @@ struct m0_addb_monitor  ut_mon[UT_ADDB_MONS_NR];
 uint32_t                ut_mon_data_key[UT_ADDB_MONS_NR];
 struct m0_reqh         *ut_srv_reqh;
 uint32_t                stats_id[UT_ADDB_MONS_NR];
+struct m0_addb_ctx        *cv[4] = { NULL, &m0_addb_proc_ctx,
+				     &m0_addb_node_ctx, NULL };
+struct stats_svc          *stats_srv;
 
 struct ut_monitor_sum_data1 {
 	uint64_t umsd_field1;
 }ut_mon_sum_data1;
 
-
 struct ut_monitor_sum_data2 {
 	uint64_t umsd_field1;
 	uint64_t umsd_field2;
@@ -195,7 +197,13 @@ const struct m0_addb_monitor_ops ut_mon_ops = {
 	.amo_sum_rec = ut_mon_sum_rec
 };
 
-static void addb_ut_mon_init(struct m0_addb_rec_type *rtype, int idx)
+enum {
+	MON_TEST_1 = 1,
+	MON_TEST_2 = 2,
+};
+
+static void addb_ut_mon_init(struct m0_addb_rec_type *rtype, int idx,
+			     int test_no)
 {
 	struct m0_addb_sum_rec *sum_rec;
 
@@ -206,7 +214,8 @@ static void addb_ut_mon_init(struct m0_addb_rec_type *rtype, int idx)
 	m0_addb_monitor_init(&ut_mon[idx], &ut_mon_ops);
 	m0_addb_monitor_sum_rec_init(sum_rec, rtype,
 				     (uint64_t *)MON_DATA(idx), idx);
-	ut_mon_data_key[idx] = m0_reqh_lockers_allot();
+	if (test_no == MON_TEST_1)
+		ut_mon_data_key[idx] = m0_reqh_lockers_allot();
 	m0_rwlock_write_lock(&ut_srv_reqh->rh_rwlock);
 	m0_reqh_lockers_set(ut_srv_reqh, ut_mon_data_key[idx], sum_rec);
 	m0_rwlock_write_unlock(&ut_srv_reqh->rh_rwlock);
@@ -273,7 +282,7 @@ static void addb_post_record(struct m0_addb_mc *mc, int idx,
 	}
 }
 
-static void addb_ut_mon_verify_stats_data(struct stats_svc * stats_srv, int idx)
+static void addb_ut_mon_verify_stats_data(struct stats_svc *stats_srv, int idx)
 {
 	struct m0_stats *stats;
 	int              i;
@@ -285,13 +294,70 @@ static void addb_ut_mon_verify_stats_data(struct stats_svc * stats_srv, int idx)
 			     == ((i + 1) * 10));
 }
 
-static void addb_ut_mon_infra_test(void)
+static void clear_stats(struct stats_svc *stats_srv, int idx)
+{
+	struct m0_stats *stats;
+	int              i;
+
+	stats = m0_stats_get(&stats_srv->ss_stats, stats_id[idx]);
+	M0_UT_ASSERT(stats != NULL);
+	for (i = 0; i < idx; ++i)
+		stats->s_sum.ss_data.au64s_data[i] = 0;
+}
+
+static void mon_test_1(void)
 {
 	struct m0_addb_rec_type   *dp;
-	struct m0_addb_ctx        *cv[4] = { NULL, &m0_addb_proc_ctx,
-					     &m0_addb_node_ctx, NULL };
+	int                        i;
+
+	/* Register addb record types & initialize addb monitors for them */
+	for (i = 1; i < UT_ADDB_MONS_NR; ++i) {
+		dp = DPRT_P(i);
+		dp->art_magic = 0;
+		stats_id[i] = dp->art_id = addb_rt_max_id + i;
+
+		/* Register ADDB summary record type */
+		m0_addb_rec_type_register(dp);
+		addb_ut_mon_init(DPRT_P(i), i, MON_TEST_1);
+	}
+
+	for (i = 1; i < UT_ADDB_MONS_NR; ++i)
+		addb_post_record(&ut_srv_reqh->rh_addb_mc, i, cv);
+	m0_nanosleep(m0_time(0, 2 * 1000 * 1000 * 100), NULL);
+	for (i = 1; i < UT_ADDB_MONS_NR; ++i) {
+		addb_ut_mon_verify_stats_data(stats_srv, i);
+		addb_ut_mon_fini(i);
+	}
+}
+
+static void mon_test_2(void)
+{
+	int i;
+	int default_batch = stats_batch;
+
+	m0_mutex_lock(&ut_srv_reqh->rh_addb_monitoring_ctx.amc_mutex);
+	stats_batch = 5;
+	m0_mutex_unlock(&ut_srv_reqh->rh_addb_monitoring_ctx.amc_mutex);
+
+	for (i = 1; i < UT_ADDB_MONS_NR; ++i) {
+		addb_ut_mon_init(DPRT_P(i), i, MON_TEST_2);
+	}
+	for (i = 1; i < UT_ADDB_MONS_NR; ++i)
+		addb_post_record(&ut_srv_reqh->rh_addb_mc, i, cv);
+	m0_nanosleep(m0_time(0, 4 * 1000 * 1000 * 100), NULL);
+	for (i = 1; i < UT_ADDB_MONS_NR; ++i) {
+		addb_ut_mon_verify_stats_data(stats_srv, i);
+		addb_ut_mon_fini(i);
+	}
+	/* Reset to default */
+	m0_mutex_lock(&ut_srv_reqh->rh_addb_monitoring_ctx.amc_mutex);
+	stats_batch = default_batch;
+	m0_mutex_unlock(&ut_srv_reqh->rh_addb_monitoring_ctx.amc_mutex);
+}
+
+static void addb_ut_mon_infra_test(void)
+{
 	struct m0_reqh_service    *reqh_srv;
-	struct stats_svc          *stats_srv;
 	struct rpcsink            *rsink;
 	m0_time_t                  temp_time;
 	uint32_t		   rec_count;
@@ -336,24 +402,12 @@ static void addb_ut_mon_infra_test(void)
 	M0_ADDB_CTX_INIT(&mc, &ctx, &m0__addb_ut_ct0, &m0_addb_proc_ctx);
 	cv[0] = &ctx;
 
-	/* Register addb record types & initialize addb monitors for them */
-	for (i = 1; i < 10; ++i) {
-		dp = DPRT_P(i);
-		dp->art_magic = 0;
-		stats_id[i] = dp->art_id = addb_rt_max_id + i;
-
-		/* Register ADDB summary record type */
-		m0_addb_rec_type_register(dp);
-		(void) addb_ut_mon_init(DPRT_P(i), i);
-	}
-
-	for (i = 1; i < UT_ADDB_MONS_NR; ++i)
-		addb_post_record(&ut_srv_reqh->rh_addb_mc, i, cv);
-	m0_nanosleep(m0_time(0, 2 * 1000 * 1000 * 100), NULL);
+	mon_test_1();
 	for (i = 1; i < UT_ADDB_MONS_NR; ++i) {
-		addb_ut_mon_verify_stats_data(stats_srv, i);
-		addb_ut_mon_fini(i);
+		((struct ut_monitor_sum_data1 *)MON_DATA(i))->umsd_field1 = 0;
+		clear_stats(stats_srv, i);
 	}
+	mon_test_2();
 
 	m0_addb_mc_fini(&mc);
 	stop_rpc_client_and_server();
-- 
1.8.3.2

