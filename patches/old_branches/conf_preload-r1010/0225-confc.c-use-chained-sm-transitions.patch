From baf2d25634fa110eae63b58d9233fd8e38949b26 Mon Sep 17 00:00:00 2001
From: "Valery V. Vorotyntsev" <valery_vorotyntsev@xyratex.com>
Date: Thu, 5 Jul 2012 13:54:18 +0300
Subject: [PATCH 225/311] confc.c: use "chained sm transitions"

Rewrite ->sd_in() callbacks to use recently introduced
"chained sm transitions" (see http://reviewboard.clusterstor.com/r/891/).

RB: r/865/diff/2/?file=23425#file23425line635
---
 conf/confc.c | 39 +++++++++++++++++++++++----------------
 1 file changed, 23 insertions(+), 16 deletions(-)

diff --git a/conf/confc.c b/conf/confc.c
index ade4d0f..a2fb7a3 100644
--- a/conf/confc.c
+++ b/conf/confc.c
@@ -624,7 +624,7 @@ static int
 cache_grow(struct c2_conf_map *cache, const struct c2_conf_fetch_resp *resp);
 
 /** Actions to perform on entering S_CHECK state. */
-static void check_st_in(struct c2_sm *mach)
+static int check_st_in(struct c2_sm *mach)
 {
 	static const int next_state[] = {
 		[C2_CS_MISSING] = S_WAIT_REPLY,
@@ -635,16 +635,17 @@ static void check_st_in(struct c2_sm *mach)
 	struct c2_confc_ctx *ctx = mach_to_ctx(mach);
 
 	rc = path_walk(ctx);
-	if (rc < 0)
-		c2_sm_fail(mach, S_FAILURE, rc);
-	else if (IS_IN_ARRAY(rc, next_state))
-		c2_sm_state_set(mach, next_state[rc]);
-	else
-		C2_IMPOSSIBLE("path_walk: invalid result");
+	if (rc < 0) {
+		mach->sm_rc = rc;
+		return S_FAILURE;
+	}
+
+	C2_ASSERT(IS_IN_ARRAY(rc, next_state));
+	return next_state[rc];
 }
 
 /** Actions to perform on entering S_WAIT_REPLY state. */
-static void wait_reply_st_in(struct c2_sm *mach)
+static int wait_reply_st_in(struct c2_sm *mach)
 {
 	int rc;
 	struct c2_confc_ctx *ctx = mach_to_ctx(mach);
@@ -652,12 +653,15 @@ static void wait_reply_st_in(struct c2_sm *mach)
 	C2_PRE(request_is_valid(ctx->fc_req));
 
 	rc = c2_rpc_post(&ctx->fc_fop.f_item);
-	if (rc != 0)
-		c2_sm_fail(mach, S_FAILURE, rc);
+	if (rc == 0)
+		return -1;
+
+	mach->sm_rc = rc;
+	return S_FAILURE;
 }
 
 /** Actions to perform on entering S_GROW_CACHE state. */
-static void grow_cache_st_in(struct c2_sm *mach)
+static int grow_cache_st_in(struct c2_sm *mach)
 {
 	/*
 	 * int                        rc;
@@ -675,10 +679,12 @@ static void grow_cache_st_in(struct c2_sm *mach)
 	 * // Let rpc layer free the memory allocated for response.
 	 * c2_rpc_item_put(item->ri_reply); // XXX
 	 *
-	 * if (rc == 0)
-	 *         c2_sm_state_set(mach, S_CHECK);
-	 * else
-	 *         c2_sm_fail(mach, S_FAILURE, rc);
+	 * if (rc == 0) {
+	 *         return S_CHECK;
+	 * } else {
+	 *         mach->sm_rc = rc;
+	 *         return S_FAILURE;
+	 * }
 	 */
 	XXX;
 }
@@ -712,9 +718,10 @@ static bool on_object_updated(struct c2_clink *link)
 }
 
 /** Action to perform on entering S_TERMINAL or S_FAILURE state. */
-static void completion_announce(struct c2_sm *mach)
+static int completion_announce(struct c2_sm *mach)
 {
 	c2_chan_broadcast(&mach_to_ctx(mach)->fc_complete);
+	return -1;
 }
 
 static bool check_st_invariant(const struct c2_sm *mach)
-- 
1.8.3.2

