From 926088a07205674e01305cbb91ec73673049a73b Mon Sep 17 00:00:00 2001
From: Anatoliy Bilenko <anatoliy_bilenko@xyratex.com>
Date: Thu, 24 May 2012 17:39:02 +0300
Subject: [PATCH 191/311] Updated accroding to HLD of Confd review. RB-765, rev
 #5.  - Updated state machines in logical spec sections.  - Added a section
 about locking primitive used in confd.  - Updated confd structures.

---
 conf/confd.c | 403 ++++++++++++++++++++++++++++++++++++++---------------------
 conf/confd.h |  89 +++++++------
 2 files changed, 306 insertions(+), 186 deletions(-)

diff --git a/conf/confd.c b/conf/confd.c
index 969b89b..eba04a3 100644
--- a/conf/confd.c
+++ b/conf/confd.c
@@ -29,6 +29,7 @@
  * - @ref confd-highlights
  * - @ref confd-lspec
  *	- @ref confd-lspec-state
+ *      - @ref confd-lspec-long-lock
  *	- @ref confd-lspec-thread
  *	- @ref confd-lspec-numa
  * - @ref confd-ut
@@ -45,8 +46,10 @@
  * - @ref fop <!-- fop/fop.h -->
  * - @ref reqh <!-- reqh/reqh.h -->
  * - @ref colibri_setup <!-- colibri/colibri_setup.h -->
- * - @ref c2_reqh_service_type_{register/unregister}() <!-- reqh/reqh_service.h -->
+ * - @ref c2_reqh_service_type_{register/unregister}()
+ *        <!--reqh/reqh_service.h -->
  * - @ref c2_addb_ctx_{init/fini}() <!-- addb/addb.h -->
+ * - @ref c2_long_{read,write}_{un,}lock() <!-- @todo -->
  *
  * Most reasonable functions, confd depends on, are listed above:
  * - RPC layer:
@@ -100,7 +103,8 @@
  * @code
  * struct init_fini_call subsystem[] = {
  *      ...
- *	{ &c2_confd_service_register, &c2_confd_service_unregister, "confd_service" },
+ *	{ &c2_confd_service_register, &c2_confd_service_unregister,
+ *	  "confd_service" },
  *      ...
  * };
  * @endcode
@@ -178,7 +182,7 @@
  * - check_request() - checks incoming request and validates requested
  *     path of configuration objects.
  *
- * - next_state() - transits confd states depending on the current
+ * - {fetch,update}_next_state() - transits FOM states depending on the current
  *   state and on the state of configuration objects.
  *
  * - obj_serialize() - serializes given object to FOP.
@@ -204,122 +208,212 @@
  *  digraph confd_serialize_states {
  *      node [fontsize=9];
  *      edge [fontsize=9];
- *      STATUS_INITIAL [style=filled, fillcolor=lightgrey];
- *      STATUS_SERIALIZE;
- *      STATUS_WAIT;
- *      STATUS_TERMINATE [style=filled, fillcolor=lightgrey];
- *      STATUS_FAILURE [style=filled, fillcolor=lightgrey];
- *
- *      STATUS_INITIAL -> STATUS_SERIALIZE [label="c2_conf_fetch-FOP is arrived \n, next_state() == STATUS_SERIALIZE"];
- *      STATUS_SERIALIZE -> STATUS_WAIT [label="tryrdlock(c2_confd::c_cache::ca_rwlock) != 0 || \n c2_confd::c_cache::ca_writers > 0, \n next_state() == STATUS_WAIT"];
- *      STATUS_SERIALIZE -> STATUS_TERMINATE [label="serialization is done"];
- *      STATUS_SERIALIZE -> STATUS_FAILURE [label="failed to lookup object \n in cache or (next_state() < 0)"];
- *      STATUS_WAIT -> STATUS_SERIALIZE [label="tryrdlock(c2_confd::c_cache::ca_rwlock) == 0 && \n c2_confd::c_cache::ca_writers == 0, \n next_state()==STATUS_SERIALIZE"];
+ *      FETCH_INITIAL [style=filled, fillcolor=lightgrey];
+ *      FETCH_SERIALIZE;
+ *      FETCH_WAIT_RDLK;
+ *      FETCH_TERMINATE [style=filled, fillcolor=lightgrey];
+ *      FETCH_FAILURE [style=filled, fillcolor=lightgrey];
+ *
+ *      FETCH_INITIAL -> FETCH_WAIT_RDLK [label=
+ *      "c2_conf_fetch-FOP is arrived \n, fetch_next_state() == FETCH_WAIT_RDLK"];
+ *
+ *      FETCH_WAIT_RDLK -> FETCH_WAIT_RDLK [label=
+ *      "c2_long_read_lock(c2_confd::c_cache::ca_rwlock) != 0 || \n c2_confd::c_cache::ca_writers > 0, \n fetch_next_state() == FETCH_WAIT_RDLK"];
+ *
+ *      FETCH_WAIT_RDLK -> FETCH_SERIALIZE [label=
+ *      "c2_long_read_lock(c2_confd::c_cache::ca_rwlock) == 0 && \n c2_confd::c_cache::ca_writers == 0, \n fetch_next_state()== FETCH_SERIALIZE"];
+ *
+ *      FETCH_SERIALIZE -> FETCH_TERMINATE [label=
+ *      "serialization is done \n c2_long_read_unlock(c2_confd::c_cache::ca_rwlock)"];
+ *
+ *      FETCH_SERIALIZE -> FETCH_FAILURE [label=
+ *      "failed to lookup object \n in cache or (fetch_next_state() < 0) \n c2_long_read_unlock(c2_confd::c_cache::ca_rwlock)"];
  *  }
  * @enddot
  *
- * - C2_CONFD_STATUS_INITIAL:
- *   In this state, statistics values are being updated in c2_confd::c_stat.
- *   Then next_state() is called and FOM is transited into C2_CONFD_STATUS_SERIALIZE.
- *   FOM state handler should return FSO_WAIT.
+ * - C2_CONFD_FETCH_INITIAL
+ *   In this state, statistics values are being updated in
+ *   c2_confd::c_stat.  Then fetch_next_state() is called and FOM is
+ *   transited into C2_CONFD_FETCH_WAIT_RDLK.
+ *
+ * - C2_CONFD_FETCH_WAIT_RDLK:
+ *   In this state, c2_confd::c_cache::ca_rwlock is being obtained as
+ *   a read lock. If it's obtained and there's no pending update
+ *   requests in the system (c2_confd::c_cache::ca_writers == 0) than
+ *   fetch_next_state() transits FOM back into C2_CONFD_FETCH_SERIALIZE.
+ *   Otherwise FOM remains in the same state until lock is obtained.
  *
- * - C2_CONFD_STATUS_SERIALIZE:
+ * - C2_CONFD_UPDATE_SERIALIZE:
  *   Current design assumes that data is pre-loaded into configuration
- *   cache. In current state, c2_confd::c_cache::ca_rwlock lock is
- *   being obtained as a read lock. c2_confd::c_cache::ca_writers
- *   corresponds to the number of update requests pending in the
- *   system and if this variable is greater than zero or it's
- *   impossible to obtain read lock on c2_confd::c_cache::ca_rwlock,
- *   c2_conf_fetch FOM is being transited into C2_CONFD_STATUS_WAIT
- *   with next_state() call.
- *
- *   Otherwise c2_conf_fetch_resp FOP is being prepared for sending by
- *   locking c2_confd::c_cache::ca_rwlock, looking up requested path
- *   in configuration cache and unlocking c2_confd::c_cache::ca_rwlock.
- *   After that, c2_conf_fetch_resp FOP is sent with c2_rpc_reply_post().
- *   next_state() transits FOM into C2_CONFD_STATUS_TERMINATE.
- *
+ *   cache. In current state, c2_confd::c_cache::ca_rwlock lock has
+ *   been already obtained as a read lock.
+ *   c2_conf_fetch_resp FOP is being prepared for sending by looking
+ *   up requested path in configuration cache and unlocking
+ *   c2_confd::c_cache::ca_rwlock.  After that, c2_conf_fetch_resp FOP
+ *   is sent with c2_rpc_reply_post().  fetch_next_state() transits FOM into
+ *   C2_CONFD_UPDATE_TERMINATE.
  *   If incoming request consists of a path which is not in
- *   configuration cache than c2_conf_fetch FOM is transited into
- *   C2_CONFD_STATUS_FAILURE.
+ *   configuration cache than c2_confd::c_cache::ca_rwlock has to be
+ *   unlocked, c2_conf_fetch FOM is transited into
+ *   C2_CONFD_FETCH_FAILURE.
  *
- *   FOM state handler should return FSO_WAIT.
- *
- * - C2_CONFD_STATUS_WAIT:
- *   In this state, c2_confd::c_cache::ca_rwlock is trying to be
- *   obtained as a read lock. If it's obtained and there's no pending
- *   update requests in the system (c2_confd::c_cache::ca_writers == 0) than
- *   next_state() transits FOM back into C2_CONFD_STATUS_SERIALIZE. In this case
- *   FOM state handler should return FSO_WAIT to perform the transition.
- *   Otherwise FOM is being remained in current state, by returning FSO_AGAIN.
- *
- * - C2_CONFD_STATUS_TERMINATE:
- *   In this state, statistics values are being updated in c2_confd::c_stat.
- *   FOM state handler should return FSO_WAIT.
+ * - C2_CONFD_UPDATE_TERMINATE:
+ *   In this state, statistics values are being updated in
+ *   c2_confd::c_stat.
  *
- * - C2_CONFD_STATUS_FAILURE:
+ * - C2_CONFD_UPDATE_FAILURE:
  *   In this state, statistics values are being updated in
  *   c2_confd::c_stat, ADDB records are being added.
  *   c2_conf_fetch_resp FOP with an empty configuration objects
  *   sequence and negative error code is sent with c2_rpc_reply_post().
- *   FOM state handler should return FSO_WAIT.
  *
  *  c2_conf_update FOM state transition diagram:
  * @dot
- *  digraph confd_udpate_states {
+ *  digraph confd_serialize_states {
  *      node [fontsize=9];
  *      edge [fontsize=9];
- *      STATUS_INITIAL [style=filled, fillcolor=lightgrey];
- *      STATUS_UPDATE;
- *      STATUS_WAIT;
- *      STATUS_TERMINATE [style=filled, fillcolor=lightgrey];
- *      STATUS_FAILURE [style=filled, fillcolor=lightgrey];
- *
- *      STATUS_INITIAL -> STATUS_UPDATE [label="c2_conf_update-FOP is arrived \n, next_state() == STATUS_UPDATE"];
- *      STATUS_UPDATE -> STATUS_WAIT [label="trywrlock(c2_confd::c_cache::ca_rwlock) != 0, \n next_state() == STATUS_WAIT, \n c2_atomic64_inc(c2_confd::c_cache::ca_writers)"];
- *      STATUS_UPDATE -> STATUS_TERMINATE [label="update is done"];
- *      STATUS_UPDATE -> STATUS_FAILURE [label="failed to update object \n in cache or (next_state() < 0)"];
- *      STATUS_WAIT -> STATUS_UPDATE [label="trywrlock(c2_confd::c_cache::ca_rwlock) == 0, \n next_state()==STATUS_UPDATE, \n c2_atomic64_dec(c2_confd::c_cache::ca_writers)"];
+ *      UPDATE_INITIAL [style=filled, fillcolor=lightgrey];
+ *      UPDATE_UPDATE;
+ *      UPDATE_WAIT_WRLK;
+ *      UPDATE_TERMINATE [style=filled, fillcolor=lightgrey];
+ *      UPDATE_FAILURE [style=filled, fillcolor=lightgrey];
+ *
+ *      UPDATE_INITIAL -> UPDATE_WAIT_WRLK [label=
+ *      "c2_long_write_lock(c2_confd::c_cache::ca_rwlock) != 0, \n update_next_state() == UPDATE_WAIT_WRLK, \n ++c2_confd::c_cache::ca_writers"];
+ *
+ *      UPDATE_WAIT_WRLK -> UPDATE_WAIT_WRLK [label=
+ *      "c2_long_write_lock(c2_confd::c_cache::ca_rwlock) != 0, \n update_next_state() == UPDATE_WAIT_WRLK"];
+ *
+ *      UPDATE_WAIT_WRLK -> UPDATE_UPDATE [label=
+ *      "c2_long_write_lock(c2_confd::c_cache::ca_rwlock) == 0, \n update_next_state()== UPDATE_UPDATE, \n --c2_confd::c_cache::ca_writers"];
+ *
+ *      UPDATE_UPDATE -> UPDATE_TERMINATE [label=
+ *      "serialization is done \n c2_long_write_unlock(c2_confd::c_cache::ca_rwlock), \n --c2_confd::c_cache::ca_writers"];
+ *
+ *      UPDATE_UPDATE -> UPDATE_FAILURE [label=
+ *      "failed to lookup object \n in cache or (update_next_state() < 0) \n c2_write_read_unlock(c2_confd::c_cache::ca_rwlock), \n --c2_confd::c_cache::ca_writers"];
  *  }
  * @enddot
  *
- * - C2_CONFD_STATUS_INITIAL:
- *   In this state, statistics values are being updated in c2_confd::c_stat.
- *   Then next_state() is called and FOM is transited into C2_CONFD_STATUS_UPDATE.
- *   FOM state handler should return FSO_WAIT.
+ * - C2_CONFD_UPDATE_INITIAL
+ *   In this state, statistics values are being updated in
+ *   c2_confd::c_stat.  Then update_next_state() is called and FOM is
+ *   transited into C2_CONFD_UPDATE_WAIT_WRLK.
+ *
+ * - C2_CONFD_UPDATE_WAIT_WRLK:
+ *   In current state, c2_confd::c_cache::ca_rwlock lock is being obtained
+ *   as a write lock. If it's already locked, pending update requests count
+ *   c2_confd::c_cache::ca_writers should be incremented. In this case,
+ *   update_next_state() is called and FOM is transited into C2_CONFD_UPDATE_WAIT_WRLK
+ *   state.  Otherwise configuration c2_confd::c_cache::ca_rwlock is being
+ *   locked as a write lock and transited into C2_CONFD_UPDATE_UPDATE.
+ *
+ * - C2_CONFD_UPDATE_UPDATE:
+ *   In current state, c2_confd::c_cache::ca_rwlock lock has been
+ *   already obtained as a write lock. Then, configuration cache has
+ *   to be updated and c2_confd::c_cache::ca_rwlock lock should be
+ *   unlocked.  After that, c2_conf_update_resp FOP is sent with
+ *   c2_rpc_reply_post(). update_next_state() transits FOM into
+ *   C2_CONFD_UPDATE_TERMINATE.  If incoming request consists of a
+ *   path which is not in configuration cache than
+ *   c2_confd::c_cache::ca_rwlock has to be unlocked, c2_conf_update
+ *   FOM is transited into C2_CONFD_UPDATE_FAILURE.
+ *
+ * - C2_CONFD_UPDATE_TERMINATE:
+ *   In this state, statistics values are being updated in
+ *   c2_confd::c_stat.
  *
- * - C2_CONFD_STATUS_UPDATE:
-
- *   In current state, c2_confd::c_cache::ca_rwlock lock is being
- *   obtained as a write lock. If it's already locked, pending update
- *   requests count c2_confd::c_cache::ca_writers should be
- *   incremented. In this case, next_state() is called and FOM is
- *   transited into C2_CONFD_STATUS_WAIT state.
- *
- *   Otherwise configuration c2_confd::c_cache::ca_rwlock is being
- *   locked as a write lock, cache is being updated with new
- *   configuration values from c2_conf_update FOP and ca_rwlock is
- *   being unlocked.  After that, c2_conf_update_resp FOP is sent with
- *   c2_rpc_reply_post().  next_state() transits FOM into
- *   C2_CONFD_STATUS_TERMINATE.
- *   FOM state handler should return FSO_WAIT.
- *
- * - C2_CONFD_STATUS_WAIT:
- *   c2_confd_update FOM remains in current state until
- *   c2_confd::c_cache::ca_rwlock is obtained for writing.
- *   FOM state handler should return FSO_WAIT if lock is obtained and
- *   FSO_AGAIN otherwise.
- *
- * - C2_CONFD_STATUS_TERMINATE:
- *   In this state, statistics values are being updated in c2_confd::c_stat.
- *   FOM state handler should return FSO_WAIT.
- *
- * - C2_CONFD_STATUS_FAILURE:
+ * - C2_CONFD_UPDATE_FAILURE:
  *   In this state, statistics values are being updated in
  *   c2_confd::c_stat, ADDB records are being added.
  *   c2_conf_update_resp FOP with an empty configuration objects
  *   sequence and negative error code is sent with c2_rpc_reply_post().
- *   FOM state handler should return FSO_WAIT.
+ *
+ * <hr> <!------------------------------------------------------------>
+ * @section confd-lspec-long-lock Locking model
+ *
+ * Confd relies on a locking primitive integrated with FOM signaling
+ * mechanism. The following interfaces are used:
+ *
+ * @code
+ * bool c2_long_{read,write}_lock(struct c2_longlock *lock,
+ *             struct c2_fom *fom, struct c2_fom_callback *cb);
+ * void c2_long_{read,write}_unlock(struct c2_longlock *lock);
+ * @endcode
+ *
+ * c2_long_{read,write}_lock returns true iff the lock is taken. Arms
+ * the callback that will wake this FOM when the lock should be
+ * re-tried and returns false otherwise.
+ *
+ * Each object encompassing FOM associated with this FOM contains a
+ * struct c2_fom_callback instance and it's armed, when corresponding
+ * struct c2_longlock instance becomes unlocked.
+ *
+ * The following code example shows the initialization procedure of
+ * FOM with struct c2_longlock:
+ * @code
+ * static void wait_lock_complete_cb(struct c2_fom_callback *cb);
+ *
+ * struct c2_fetch_fom_obj {
+ *       struct c2_fom          ffo_gen;
+ *       struct c2_chan         ffo_wait;
+ *       struct c2_fom_callback ffo_cb;
+ * };
+ *
+ * int fetch_fop_fom_create(struct c2_fop *fop, struct c2_fom **out)
+ * {
+ *	struct c2_fetch_fom_obj fom_obj;
+ *	1) allocate fom_obj;
+ *	2) initialize generic fom: fom_obj->ffo_gen;
+ *	3) initialize fom_obj callback: fom_obj->ffo_cb = wait_lock_complete_cb;
+ * }
+ * @endcode
+ *
+ * When struct c2_longlock instance has been already locked,
+ * c2_long_{read,write}_lock() returns false and arms a callback. This
+ * callback is fired, when lock changes it's state. The following code shows
+ * how to perform a transition from C2_CONFD_FETCH_WAIT_RDLK to
+ * C2_CONFD_FETCH_SERIALIZE and to obtain a lock:
+ *
+ * @code
+ * static int fom_fetch_state(struct c2_fom *fom)
+ * {
+ *	//...
+ *	if (fom->state == C2_CONFD_FETCH_WAIT_RDLK) {
+ *		// try to obtain a lock
+ *		bool held = c2_long_read_lock(confd->c_cache->ca_rwlock,
+ *					      fom, fom->fcrw_cb);
+ *		if (!held) {
+ *			// wait until awaken
+ *			c2_fom_block_at(fom, &bpdesc->rios_bp_wait);
+ *		} else {
+ *			// perform transition
+ *			fom->state = C2_CONFD_FETCH_SERIALIZE;
+ *		}
+ *
+ *		return C2_FSO_WAIT;
+ *	}
+ *	//...
+ * }
+ *
+ * // callback, called when lock has been unlocked.
+ * static void wait_lock_complete_cb(struct c2_fom_callback *cb)
+ * {
+ *	struct c2_fom *fom = (retreive FOM from cb);
+ *      struct c2_fetch_fom_obj *fom_obj =
+ *            container_of(fom, struct c2_fetch_fom_obj, ffo_gen);
+ *
+ *	C2_ASSERT(fom->state == C2_CONFD_FETCH_WAIT_RDLK);
+ *      // try to obtain a lock
+ *	bool held = c2_long_rw_lock(confd->c_cache->ca_rwlock, fom,
+ *				    fom_obj->ffo_cb);
+ *	if (held) {
+ *              // perform transition and wake FOM up.
+ *		fom->state = C2_CONFD_FETCH_SERIALIZE;
+ *		c2_chan_signal(fom_obj->ffo_chan);
+ *	}
+ * }
+ * @endcode
  *
  * <hr> <!------------------------------------------------------------>
  * @section confd-lspec-thread Threading and Concurrency Model
@@ -341,9 +435,9 @@
  * should be called prior to c2_chan_wait().
  *
  * Multiple concurrently executing FOMs share the same configuration
- * cache and db environment of confd, so access to them should be
- * synchronized. Assuming that access to db and cache, while adding
- * configuration values to cache, is done at the same time and
+ * cache and db environment of confd, so access to them is
+ * synchronized with read/write lock. An access to db and cache, while
+ * adding configuration values to cache, is done at the same time and
  * workload of confd is predominantly read-only, so simplistic
  * synchronization is enough (c2_confd::c_cache::ca_lock).
  *
@@ -351,17 +445,19 @@
  * @subsection confd-lspec-numa NUMA Optimizations
  *
  * In cases, when there are multiple request handlers, for example,
- * for different networks, several confd instances should be created
- * --- one per each request handler.
+ * for different networks, several confd instances should be created,
+ * one per each request handler.
  *
- * However, for optimizations reasons, the same configuration cache is
- * shared between confd instances running in different localities.
+ * Since that the number of fetch requests is orders of magnitude
+ * greater than the number of update requests the same configuration
+ * cache is shared between confd instances running in different
+ * localities.
  *
  * <hr> <!------------------------------------------------------------->
  * @section confd-ut Unit Tests
  *
  * @test obj_serialize() will be tested.
- * @test next_state() will be tested.
+ * @test {fetch,update}_next_state() will be tested.
  *
  * @test Load predefined configuration object from configuration db.
  * Check its predefined value.
@@ -378,25 +474,25 @@
  * match with predefined configuration values.
  *
  * @test
- * 1. Prepare configuration DB with yaml2db and given yaml file.
- * 2. Run confd, configure it to use newly generated DB.
- * 3. Run multiple confcs in parallel, requesting the same configuration object.
- * 4. Every confc should dump configuration object to file with name=("%d.dump", PID).
- * 5. Compare dumped objects with dumped predefined values.
- * 6. If values match, test considered to be succeeded, otherwise --- failed.
+ * -# Prepare configuration DB with yaml2db and given yaml file.
+ * -# Run confd, configure it to use newly generated DB.
+ * -# Run multiple confcs in parallel, requesting the same configuration object.
+ * -# Every confc should dump configuration object to file with
+ *    name=("%d.dump", PID).
+ * -# Compare dumped objects with dumped predefined values.
+ * -# If values match, test considered to be succeeded, otherwise --- failed.
  *
  * <hr> <!------------------------------------------------------------->
  * @section confd-O Analysis
  *
- * Minimum size of configuration cache, can be evaluated according to
- * a number of configuration objects of an average size and to the
- * length of the longest path of configuration objects, passed to
- * confd with a configuration request FOP, c2_conf_fetch.
+ * Size of configuration cache, can be evaluated according to a number
+ * of configuration objects in configuration db and is proportional to
+ * the size of the database file
  *
- * The operating value of configuration cache size can be selected
- * according either to empirical considerations or to the requests
- * intencity of confc and distribution of c2_conf_fetch FOP processing
- * time in confd. Queuing theory can be used in the second case.
+ * Configuration request FOP (c2_conf_fetch) is executed in
+ * approximately constant time (measured in disk I/O) because the
+ * entire configuration db is cached in-memory and rarely would be
+ * blocked by an update.
  *
  * <hr> <!------------------------------------------------------------->
  * @section confd-ref References
@@ -419,16 +515,26 @@
  */
 
 /**
- * Configuration service states.
+ * c2_conf_fetch FOM states.
  */
-enum c2_confd_status {
-	C2_CONFD_STATUS_INITIAL = FOPH_NR + 1,
-	C2_CONFD_STATUS_SERIALIZE,
-	C2_CONFD_STATUS_UPDATE,
-	C2_CONFD_STATUS_LOAD,
-	C2_CONFD_STATUS_WAIT,
-	C2_CONFD_STATUS_TERMINATE,
-	C2_CONFD_STATUS_FAILURE
+enum c2_confd_fetch_status {
+	C2_CONFD_FETCH_INITIAL = FOPH_NR + 1,
+	C2_CONFD_FETCH_SERIALIZE,
+	C2_CONFD_FETCH_WAIT_RDLK,
+	C2_CONFD_FETCH_TERMINATE,
+	C2_CONFD_FETCH_FAILURE
+};
+
+/**
+ * c2_conf_update FOM states.
+ */
+enum c2_confd_update_status {
+	C2_CONFD_UPDATE_INITIAL = FOPH_NR + 1,
+	C2_CONFD_UPDATE_UPDATE,
+	C2_CONFD_UPDATE_WAIT_WRLK,
+	C2_CONFD_UPDATE_WORK,
+	C2_CONFD_UPDATE_TERMINATE,
+	C2_CONFD_UPDATE_FAILURE
 };
 
 
@@ -445,25 +551,30 @@ enum {
 	C2_ADDB_EVENT_CONFD_ERR
 };
 
-C2_ADDB_EV_DEFINE(addb_confd, "addb-confd-info", C2_ADDB_EVENT_CONFD_INFO, C2_ADDB_INVAL);
-C2_ADDB_EV_DEFINE(addb_confd, "addb-confd-warn", C2_ADDB_EVENT_CONFD_WARN, C2_ADDB_INVAL);
-C2_ADDB_EV_DEFINE(addb_confd, "addb-confd-err", C2_ADDB_EVENT_CONFD_ERR, C2_ADDB_INVAL);
+C2_ADDB_EV_DEFINE(addb_confd, "addb-confd-info", C2_ADDB_EVENT_CONFD_INFO,
+		  C2_ADDB_INVAL);
+
+C2_ADDB_EV_DEFINE(addb_confd, "addb-confd-warn", C2_ADDB_EVENT_CONFD_WARN,
+		  C2_ADDB_INVAL);
+
+C2_ADDB_EV_DEFINE(addb_confd, "addb-confd-err", C2_ADDB_EVENT_CONFD_ERR,
+		  C2_ADDB_INVAL);
 
 
 /**
  * Confd service type operations.
  */
 static const struct c2_reqh_service_type_ops c2_confd_service_type_ops = {
-        .rsto_service_locate = c2_confd_service_locate
+        .rsto_service_locate = confd_service_locate
 };
 
 /**
  * Confd service operations.
  */
 static const struct c2_reqh_service_ops c2_confd_service_ops = {
-        .rso_start = c2_confd_service_start,
-        .rso_stop  = c2_confd_service_stop,
-        .rso_fini  = c2_confd_service_fini
+        .rso_start = confd_service_start,
+        .rso_stop  = confd_service_stop,
+        .rso_fini  = confd_service_fini
 };
 
 /**
@@ -474,8 +585,8 @@ static const struct c2_reqh_service_ops c2_confd_service_ops = {
  *
  * @pre stype != NULL && service != NULL
  */
-static int c2_confd_service_locate(struct c2_reqh_service_type *stype,
-				   struct c2_reqh_service **service)
+static int confd_service_locate(struct c2_reqh_service_type *stype,
+				struct c2_reqh_service **service)
 {
 	return 0;
 }
@@ -487,7 +598,7 @@ static int c2_confd_service_locate(struct c2_reqh_service_type *stype,
  *
  * @pre service != NULL
  */
-static void c2_confd_service_fini(struct c2_reqh_service *service)
+static void confd_service_fini(struct c2_reqh_service *service)
 {
 }
 
@@ -501,7 +612,7 @@ static void c2_confd_service_fini(struct c2_reqh_service *service)
  *
  * @pre service != NULL
  */
-static int c2_confd_service_start(struct c2_reqh_service *service)
+static int confd_service_start(struct c2_reqh_service *service)
 {
         return 0;
 }
@@ -515,14 +626,14 @@ static int c2_confd_service_start(struct c2_reqh_service *service)
  *
  * @pre service != NULL
  */
-static void c2_confd_service_stop(struct c2_reqh_service *service)
+static void confd_service_stop(struct c2_reqh_service *service)
 {
 }
 
 C2_REQH_SERVICE_TYPE_DECLARE(c2_confd_service_type, &c2_confd_service_type_ops,
                              "confd_service");
 
-static void c2_confd_service_fop_fini(void)
+static void confd_service_fop_fini(void)
 {
 }
 
@@ -532,7 +643,7 @@ static void c2_confd_service_fop_fini(void)
  *  - c2_conf_fetch_resp;
  *  - c2_conf_update.
  */
-static int c2_confd_service_fop_init(void)
+static int confd_service_fop_init(void)
 {
 	return 0;
 }
@@ -573,12 +684,22 @@ static int obj_serialize(struct c2_confd *confd,
 }
 
 /**
- * Transits confd into the next state.
+ * Transits fetch FOM into the next state.
+ *
+ * @param confd	configuration service instance.
+ * @param st current state of incoming FOP-request processing.
+ */
+static int fetch_next_state(struct c2_confd *confd, int st)
+{
+}
+
+/**
+ * Transits update FOM into the next state.
  *
  * @param confd	configuration service instance.
  * @param st current state of incoming FOP-request processing.
  */
-static int next_state(struct c2_confd *confd, enum c2_confd_status st)
+static int update_next_state(struct c2_confd *confd, int st)
 {
 }
 
diff --git a/conf/confd.h b/conf/confd.h
index fa1e34e..51b6721 100644
--- a/conf/confd.h
+++ b/conf/confd.h
@@ -52,7 +52,6 @@
  *
  * <hr> <!------------------------------------------------------------>
  * @section confd-fspec-data Data Structures
- *
  * - c2_reqh_confd_service --- represents configuration service instance
  *   registered in request handler.
  *
@@ -73,8 +72,7 @@
  * configuration requests and replies requires the use of the RPC
  * layer as a transport. Services have to register c2_fop_types for
  * each FOP they support.
- *
- * The following FOPs are defined for confd (see conf/onwire.ff):
+ * The following FOPs are defined for confd (onwire.ff):
  * - c2_conf_fetch --- configuration request;
  * - c2_conf_fetch_resp --- Confd's response to c2_conf_fetch;
  * - c2_conf_update --- Update request;
@@ -82,61 +80,66 @@
  * - c2_conf_stat --- Statistics request;
  * - c2_conf_stat_resp --- Confd's response to c2_conf_stat.
  *
- * FOP format, FOP operation vector, FOP type, and RPC item type have
- * to be defined for each FOP.  The following structures are defined
- * for c2_conf_fetch FOP:
+ * For each FOP, FOP format, FOP operation vector, FOP types, RPC item
+ * types have to be defined. The following structures have to be
+ * defined for c2_conf_fetch FOP:
  * - struct c2_fop_type_format c2_conf_fetch_tfmt --- defines format
- *   registered in *.ff used in confd;
+ *   registed in *.ff used in confd;
  * - struct c2_fop_type c2_conf_fetch_fopt --- defines FOP type;
  * - struct c2_fop_type_ops c2_conf_fetch_ops --- defines FOP
  *   operation vector;
  * - struct c2_rpc_item_type c2_rpc_item_type_fetch --- defines RPC
- *   item type.
+ *   item type for given fop.
  *
- * FOPs used in configuration service are defined in @ref confd_fop_dfspec.
+ * FOPs used in configuration service are defined in @ref confd_fop_dfspec .
  *
  * <hr> <!------------------------------------------------------------>
  * @section confd-fspec-sub Subroutines
  *
  * - c2_confd_service_register()  - registers confd service in the system.
- * - c2_confd_service_unregister() - unregisters confd service.
+ * - c2_confd_service_unregister() - unregisters confd service in the system.
  *
  * <!------------------------------------------------------------------>
  * @subsection confd-fspec-sub-setup Initialization and termination
  *
- * To parameterize confd, user should provide the following arguments:
- *  - path to configuration db, where configuration values are stored;
- *  - name of configuration service instance.
+ * To parametrize confd, user should provide the following arguments:
+ * through environment variables.  See @ref confd-fspec-cli.
  *
  * Confd is initiated and put into operation by request handler logic,
  * after colibri is started. Confd service should be registered in
  * request handler with c2_confd_service_register() call, where it has
  * to initialize own data structures and FOPs used for communication.
  *
- * Initial configuration database is created with @ref yaml2db
- * utility. Confd assumes that:
- *  - configuration db is created before confd is started;
- *  - confd uses configuration caching schema, described in <a href="https://docs.google.com/a/xyratex.com/document/d/1JmsVBV8B4R-FrrYyJC_kX2ibzC1F-yTHEdrm3-FLQYk/view">HLD of Colibri’s configuration database schema</a>;
- *  - format of configuration db, represented in YAML, can be found in @ref yaml2db.
+ * Initial configuration database is manually created prior to startup
+ * with @ref yaml2db utility. Confd assumes that:
+ *  - Configuration db is created before confd started;
+ *  - Confd uses configuration caching schema, described in
+ *    <a href=https://docs.google.com/a/xyratex.com/document/d/1JmsVBV8B4R-FrrYyJC_kX2ibzC1F-yTHEdrm3-FLQYk/view>
+ *    "High level design of Colibri’s configuration database schema"</a>
+ *    document.
+ *
+ *  - Format of configuration db, represented in yaml can be found in @ref yaml2db.
  *
  * The following errors may occur while using the configuration db:
- * - db is empty or is in an unrecognized format;
- * - db layout does not conform to <a href="https://docs.google.com/a/xyratex.com/document/d/1JmsVBV8B4R-FrrYyJC_kX2ibzC1F-yTHEdrm3-FLQYk/view">HLD of Colibri’s configuration database schema</a>;
- * - key is not found.
+ * @li Db is empty or is in an unrecognized format.
+ * @li Db layout is different from that mentioned in
+ *     <a href=https://docs.google.com/a/xyratex.com/document/d/1JmsVBV8B4R-FrrYyJC_kX2ibzC1F-yTHEdrm3-FLQYk/view>
+ *     "High level design of Colibri’s configuration database schema"</a>
  *
- * During initialization, confd opens configuration db and fills
- * internal cache of configuration objects with their configuration
- * values. This process is called pre-loading. The entire
- * configuration db is loaded into memory.  Pre-loading details can be
- * found in @ref confd-lspec.
+ * @li Key is not found.
  *
- * Initialized confd may be terminated by
- * c2_confd_service_unregister() in which confd has to deinitialize
- * own data structures and FOPs.
+ * While initialization process, confd has open configuration db and
+ * fill internal cache of configuration objects with their
+ * configuration values. Such process is called pre-loading. It load
+ * entire configuration db into memory-based structures. Pre-loading
+ * details can be found in @ref confd-lspec.
  *
- * After confd instance is started, it manages configuration database,
- * its own internal cache structures, and handles incoming confc
- * requests.
+ * Initialized confd may be eventually terminated by c2_confd_service_unregister()
+ * in which confd has to deinitialize own data structures and FOPs.
+ *
+ * After a confd instance is started it manages configuration
+ * database, its own internal cache structures and incoming
+ * FOP-requests.
  *
  * <!------------------------------------------------------------------>
  * @section confd-fspec-cli Command Usage
@@ -145,8 +148,8 @@
  * @ref colibri_setup in cs_help() function are used.
  *
  * To extend standard options, environment variables are used:
- * - `C2_CONFD_NAME[0-9]{1,3}'    specifies confd name.
- * - `C2_CONFD_DB_NAME[0-9]{1,3}' specifies configuration db path.
+ * - `C2_CONFD_DB_NAME' specifies configuration db path, currently,
+ *    only one configuration db is supported.
  *
  * <hr> <!------------------------------------------------------------->
  * @section confd-fspec-recipes  Recipes
@@ -182,12 +185,12 @@ struct c2_confd_cache {
 	/** Keeps track of c2_confd_cache usage */
 	struct c2_ref		ca_ref;
 	/** Tracks number of threads which are going to update ca_cache */
-	struct c2_atomic64      ca_writers;
+	uint32_t		ca_writers;
 	/** Protects this structure while processing of c2_conf_fetch
 	 * and c2_conf_update FOPs */
-	struct c2_rwlock	ca_rwlock;
+	struct c2_longlock	ca_rwlock;
 	/** Protects this structure from concurrent access */
-	struct c2_mutex		ca_lock;
+	struct c2_mutex	cs_lock;
 };
 
 /** Configuration service statistics */
@@ -198,14 +201,10 @@ struct c2_confd_stat {
 	uint32_t cs_req_cnt;
 	/** Processed update requests count of configuration service. */
 	uint32_t cs_upd_cnt;
-	/** Processed configuration requests per second. */
-	uint32_t cs_req_per_sec;
-	/** Processed update requests per second. */
-	uint32_t cs_upd_per_sec;
-	/** Maximum time, update request waits to be applied */
-	uint32_t cs_waiter_max;
-	/** An average time, update request waits to be applied */
-	uint32_t cs_waiter_avg;
+	/** Time elapsed on configuration requests processing. */
+	c2_time_t cs_req_time;
+	/** Time elapsed on update requests processing. */
+	c2_time_t cs_upd_time;
 
 	/** Protects this structure from concurrent access */
 	struct c2_mutex	cs_lock;
-- 
1.8.3.2

