From ef19f33856898c7a048264e3c1e017bc6020b03a Mon Sep 17 00:00:00 2001
From: Anatoliy Bilenko <anatoliy_bilenko@xyratex.com>
Date: Wed, 13 Jun 2012 17:59:10 +0300
Subject: [PATCH 197/311] Updated DLD of `Configuration server Confd':

 - Updated conf{d,c} system test;
 - Clarified {U,F}_INITIAL state description.
---
 conf/confd.c | 46 ++++++++++++++++++++++++++--------------------
 conf/obj.c   | 18 +++++++++++-------
 2 files changed, 37 insertions(+), 27 deletions(-)

diff --git a/conf/confd.c b/conf/confd.c
index f41ec05..b728fcf 100644
--- a/conf/confd.c
+++ b/conf/confd.c
@@ -228,9 +228,10 @@
  * @enddot
  *
  * - F_INITIAL
- *   In this state, statistics values are being updated in
- *   c2_confd::c_stat.  Then fetch_next_state() is called and FOM is
- *   transited into F_WAIT_RDLK.
+ *   In this state, incoming FOM/FOP-related structures are being
+ *   initialized and FOP-processing preconditions are being
+ *   checked. Then fetch_next_state() is called and FOM is transited
+ *   into F_WAIT_RDLK.
  *
  * - F_WAIT_RDLK:
  *   In this state, an attempt is made to obtain a read lock
@@ -246,11 +247,9 @@
  *   up requested path in configuration cache and unlocking
  *   c2_confd::c_cache::ca_rwlock.  After that, c2_conf_fetch_resp FOP
  *   is sent with c2_rpc_reply_post().  fetch_next_state() transits FOM into
- *   F_TERMINATE.
- *   If incoming request consists of a path which is not in
- *   configuration cache than c2_confd::c_cache::ca_rwlock has to be
- *   unlocked, c2_conf_fetch FOM is transited into
- *   F_FAILURE.
+ *   F_TERMINATE. If incoming request consists of a path which is not
+ *   in configuration cache, then the c2_conf_fetch FOM is
+ *   transitioned to the F_FAILURE state.
  *
  * - F_TERMINATE:
  *   In this state, statistics values are being updated in
@@ -264,6 +263,9 @@
  *   sequence and negative error code is sent with c2_rpc_reply_post().
  *   c2_confd::c_cache::ca_rwlock has to be unlocked.
  *
+ *  @note c2_conf_stat FOM has a similar state diagram as
+ *  c2_conf_fetch FOM does and hence is not illustrated here.
+ *
  *  c2_conf_update FOM state transition diagram:
  * @dot
  *  digraph confd_serialize_states {
@@ -290,12 +292,13 @@
  * @enddot
  *
  * - U_INITIAL
- *   In this state, statistics values are being updated in
- *   c2_confd::c_stat.  Then update_next_state() is called and FOM is
- *   transited into U_WAIT_WRLK.
+ *   In this state, incoming FOM/FOP-related structures are being
+ *   initialized and FOP-processing preconditions are being
+ *   checked. Then fetch_next_state() is called and FOM is transited
+ *   into F_WAIT_WRLK.
  *
  * - U_WAIT_WRLK:
- *   In current state, an attempt is made to obtain a read lock
+ *   In current state, an attempt is made to obtain a write lock
  *   c2_confd::c_cache::ca_rwlock. In this case, update_next_state()
  *   is called and FOM is transited into U_WAIT_WRLK state.  Otherwise
  *   configuration c2_confd::c_cache::ca_rwlock is being locked as a
@@ -307,10 +310,9 @@
  *   to be updated and c2_confd::c_cache::ca_rwlock lock should be
  *   unlocked.  After that, c2_conf_update_resp FOP is sent with
  *   c2_rpc_reply_post(). update_next_state() transits FOM into
- *   U_TERMINATE.  If incoming request consists of a
- *   path which is not in configuration cache than
- *   c2_confd::c_cache::ca_rwlock has to be unlocked, c2_conf_update
- *   FOM is transited into U_FAILURE.
+ *   U_TERMINATE.  If incoming request consists of a path which is not
+ *   in configuration cache than the c2_conf_fetch FOM is transitioned
+ *   to the U_FAILURE state
  *
  * - U_TERMINATE:
  *   In this state, statistics values are being updated in
@@ -338,10 +340,14 @@
  * @endcode
  *
  * c2_long_{read,write}_lock() returns true iff the lock is
- * taken. Internally this arms the callback that will wake this FOM
- * when the lock should be re-tried and returns false otherwise.
- *
- * c2_long_is_{read,write}_locked() returns true iff the lock has taken.
+ * obtained. If the lock is not obtained (i.e. the return value is
+ * false), the subroutine would have arranged to awaken the FOM at the
+ * appropriate time to retry the acquisition of the lock.  It is
+ * expected that the invoker will return C2_FSO_AGAIN from the state
+ * function in this case.
+ *
+ * c2_long_is_{read,write}_locked() returns true iff the lock has been
+ * obtained.
  *
  * The following code example shows how to perform a transition from
  * F_WAIT_RDLK to F_SERIALIZE and obtain a lock:
diff --git a/conf/obj.c b/conf/obj.c
index dc5ae48..39d0974 100644
--- a/conf/obj.c
+++ b/conf/obj.c
@@ -303,13 +303,17 @@
  * Actual output is compared with expected at `Compare' step.
  *
  * @test
- * -# Prepare configuration DB with yaml2db and given yaml file.
- * -# Run confd, configure it to use newly generated DB.
- * -# Run multiple confcs in parallel, requesting the same configuration object.
- * -# Every confc should dump configuration object to file with
- *    name=("%d.dump", PID).
- * -# Compare dumped objects with dumped predefined values.
- * -# If values match, test considered to be succeeded, otherwise -- failed.
+ * -# Generate configuration DB with yaml2db and given yaml file.
+ * -# Run confd, making it use newly generated DB.
+ * -# Run multiple confcs on different threads, requesting the same
+      set of configuration objects.
+ * -# In user-space, every confc should dump configuration objects to
+ *    file with name `confc-%d-%d.dump' where the first number is the
+ *    process id, and the second the thread id.
+ *    In kernel-space, the output of confcs will be sent to the
+ *    console for the test script to recover and parse. Test script
+ *    should generate dump-files like in user-space.
+ * -# Compare contents of "dump" files with expected values.
  *
  * @subsection conf-st-conf Configuration data
  *
-- 
1.8.3.2

