From 386712f5898360f6cfcab2ad9f78bf3346bb8442 Mon Sep 17 00:00:00 2001
From: "Valery V. Vorotyntsev" <valery_vorotyntsev@xyratex.com>
Date: Wed, 28 Mar 2012 17:12:44 +0300
Subject: [PATCH 098/311] extend description of path_walk() and states

The process of describing logical specification in prose appears to be
fruitful.  Thus it has revealed the fact that c2_confc_ctx::fc_clink alone
is not sufficient: when we are waiting for several objects to finish
loading we need as many c2_clinks as there are c2_chans (objects).

TODO:
  - path_walk() is too complicated. It should be refactored.
  - Devise a mechanism for c2_confc_ctx to support several clinks.
---
 conf/confc.c | 82 +++++++++++++++++++++++++++++++++++++++++++++++++-----------
 conf/confc.h |  4 ++-
 conf/obj.h   |  6 ++---
 3 files changed, 72 insertions(+), 20 deletions(-)

diff --git a/conf/confc.c b/conf/confc.c
index 6eafaa7..01be233 100644
--- a/conf/confc.c
+++ b/conf/confc.c
@@ -195,11 +195,11 @@
  *
  * When the AST, posted by c2_confc_open(), is run, it moves the state
  * machine (c2_confc_ctx::fc_mach) to S_CHECK state.  When S_CHECK
- * state is entered, check_st_in() (c2_sm_state_descr::sd_in hook) is
- * invoked. This function calls path_walk() and, depending on the
- * value returned by the latter, switches the state machine to
- * S_TERMINAL, S_WAIT_REPLY, S_WAIT_STATUS, or S_FAILURE state. No AST
- * is needed as the group is already locked.
+ * state is entered, check_st_in() callback is invoked. This function
+ * calls path_walk() and, depending on the value returned by the
+ * latter, switches the state machine to S_TERMINAL, S_WAIT_REPLY,
+ * S_WAIT_STATUS, or S_FAILURE state. No AST is needed as the group is
+ * already locked.
  *
  * <!------------------------------------------------------------------>
  * @subsection confc-dld-lspec-walk Walking the DAG
@@ -218,6 +218,8 @@
  *       C2_ASSERT()ing availability of the requested object/directory
  *       in the configuration cache.
  *
+ * - Stub ahead
+ *
  * A stub object lying on a path makes further progress impossible,
  * because relations of a stub are not trustworthy.  If a stub is
  * C2_CS_LOADING, path_walk() registers c2_confc_ctx::fc_clink with
@@ -226,22 +228,70 @@
  * (c2_confc_ctx::fc_req) by calling request_fill(), and returns
  * C2_CS_MISSING.
  *
- * If path target is a C2_CS_READY object, path_walk() returns
- * C2_CS_READY.  If path target is a directory, path_walk() checks
- * whether all of the configuration objects in this directory are
- * C2_CS_READY. If they are, path_walk() returns C2_CS_READY.  If at
- * least one of the objects is C2_CS_MISSING, path_walk() sets the
- * statuses of missing objects to C2_CS_LOADING and returns
- * C2_CS_MISSING.  Otherwise the function registers
- * c2_confc_ctx::fc_clink with the channel(s) of loading object(s) and
- * returns C2_CS_LOADING.
+ * - Wrong key
  *
  * If one of path components is a key and the key is wrong, then
- * path_walk() will return -ENOENT.
+ * path_walk() returns -ENOENT.
+ *
+ * - Target is an object
+ *
+ * If path target is a C2_CS_READY object, path_walk() increments its
+ * reference counter (c2_conf_obj::co_nrefs) and returns C2_CS_READY.
+ *
+ * - Target is a directory
+ *
+ * If path target is a directory, path_walk() checks whether all of
+ * the configuration objects in this directory are C2_CS_READY. If
+ * they are, path_walk() increments reference counter of the object
+ * the directory originates from, and returns C2_CS_READY.  If at
+ * least one of the objects is C2_CS_MISSING, path_walk() sets
+ * statuses of missing objects to C2_CS_LOADING and returns
+ * C2_CS_MISSING.
+ *
+ * - Target is a directory, C2_CS_LOADING case
+ *
+ * There is one more case, in which the target directory has no
+ * C2_CS_MISSING objects, and yet not all of its objects are
+ * C2_CS_READY --- one or more of the objects in this directory are
+ * C2_CS_LOADING.  If there is only one such object, path_walk()
+ * registers c2_confc_ctx::fc_clink with object's channel
+ * (c2_conf_obj::co_chan) and returns C2_CS_LOADING.
+ *
+ * If there are N + 1 objects (N > 0) with C2_CS_LOADING status, then
+ * path_walk() dynamically allocates an array of N clinks
+ * (c2_confc_ctx::fc_extra), attaches them (c2_clink_attach()) to
+ * c2_confc_ctx::fc_clink, and registers N + 1 clinks with the
+ * channels of C2_CS_LOADING objects (see `Multiple channels' section
+ * in @ref chan).  Finally, path_walk() returns C2_CS_LOADING.
  *
  * <!------------------------------------------------------------------>
  * @subsection confc-dld-lspec-state State Specification
  *
+ * - S_CHECK
+ *
+ * See @ref confc-dld-lspec-open for the description of actions
+ * performed by a confc state machine on entering S_CHECK state.
+ *
+ * - S_WAIT_REPLY
+ *
+ * When a state machine is about to enter S_WAIT_REPLY state,
+ * wait_reply_st_in() callback is executed. This callback sends
+ * configuration request (c2_confc_ctx::fc_req) to the confd, using
+ * c2_rpc_post().  (Not now; see @ref confc-offline.)
+ *
+ * A state machine remains in S_WAIT_REPLY state until reply from
+ * confd arrives. This event triggers on_replied() callback.  If the
+ * error code contained in confd's reply (c2_conf_fetch_resp) is
+ * non-zero, on_replied() posts an AST that will eventually move the
+ * state machine to S_FAILURE state.  If the error code is zero,
+ * on_replied() uses c2_rpc_item_get() to "claim" the rpc item and
+ * schedules transition to S_GROW_CACHE state.
+ *
+ * - S_WAIT_STATUS
+ *
+ * Before returning C2_CS_LOADING, path_walk() registers
+ * c2_confc_ctx::fc_clink with the channel(s) of loading object(s) XXX
+ *
  * @dot
  * digraph confd_states {
  *     node [fontsize=11];
@@ -791,6 +841,8 @@ static void wait_reply_st_in(struct c2_sm *mach)
 	struct c2_confc_ctx *ctx = mach_to_ctx(mach);
 
 	C2_PRE(ctx_invariant(ctx));
+	C2_PRE(request_is_valid(ctx->fc_req));
+
 	rc = c2_rpc_post(&ctx->fc_fop.f_item);
 	C2_ASSERT(rc == 0); /* c2_rpc_post() always returns 0, but hey */
 }
diff --git a/conf/confc.h b/conf/confc.h
index 927de53..26a34f5 100644
--- a/conf/confc.h
+++ b/conf/confc.h
@@ -387,7 +387,9 @@ struct c2_confc_ctx {
 	/** Request fop. */
 	struct c2_fop            fc_fop;
 	/**
-	 * Record of interest in "object unpinned" events.
+	 * Record of interest in "object loading completed" or
+	 * "object unpinned" events.
+	 *
 	 * This clink gets added to c2_conf_obj::co_chan channel.
 	 */
 	struct c2_clink          fc_clink;
diff --git a/conf/obj.h b/conf/obj.h
index 8ae83ab..f5d11ac 100644
--- a/conf/obj.h
+++ b/conf/obj.h
@@ -63,17 +63,15 @@ struct c2_conf_obj {
 	enum c2_conf_objtype co_type;
 	struct c2_conf_buf   co_key;
 	enum c2_conf_status  co_status;
-
 	/**
 	 * Reference counter.
 	 *
 	 * The object is "pinned" if this value is non-zero.
 	 */
 	uint64_t co_nrefs;
-
 	/**
-	 * Channel on which "status updated" and "object unpinned"
-	 * events are announced.
+	 * Channel on which "object loading completed" and "object
+	 * unpinned" events are announced.
 	 */
 	struct c2_chan co_chan;
 };
-- 
1.8.3.2

