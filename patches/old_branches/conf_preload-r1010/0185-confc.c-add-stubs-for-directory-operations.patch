From 20c3ede8a37f104c47fc772efbac933b35ac5b22 Mon Sep 17 00:00:00 2001
From: "Valery V. Vorotyntsev" <valery_vorotyntsev@xyratex.com>
Date: Wed, 16 May 2012 22:59:32 +0300
Subject: [PATCH 185/311] confc.c: add stubs for directory operations

+ Describe the logic of c2_confc_dir{next,close}().
+ Rename c2_confc_dir::d_current to ->d_cursor and fix documentation
  of this member.
+ Introduce _open(), which generalizes c2__confc_{,dir}open().
+ Fix implementation of c2_confc_close() so that NULL pointers
  are accepted.

LogD: #1330
RB: r/714
---
 conf/confc.c | 103 +++++++++++++++++++++++++++++++++++++++++++++++++----------
 conf/confc.h |   3 +-
 2 files changed, 89 insertions(+), 17 deletions(-)

diff --git a/conf/confc.c b/conf/confc.c
index 7d9f784..e92e11f 100644
--- a/conf/confc.c
+++ b/conf/confc.c
@@ -666,8 +666,8 @@ void c2_confc_fini(struct c2_confc *client)
 	XXX;
 }
 
-int c2__confc_open(struct c2_confc_ctx *ctx, struct c2_conf_obj *origin,
-		   const struct c2_conf_pathcomp *path)
+int _open(struct c2_confc_ctx *ctx, struct c2_conf_obj *origin,
+	  const struct c2_conf_pathcomp *path, bool target_is_dir)
 {
 	bool isdir;
 
@@ -678,8 +678,8 @@ int c2__confc_open(struct c2_confc_ctx *ctx, struct c2_conf_obj *origin,
 		origin = ctx->fc_client->cc_root;
 	C2_ASSERT(c2_conf_path_is_valid(origin, path, &isdir));
 
-	if (isdir)
-		return -EISDIR;
+	if (isdir != target_is_dir)
+		return target_is_dir ? -ENOTDIR : -EISDIR;
 
 	ctx->fc_path = c2_conf_pathcomp_dup(path);
 	if (ctx->fc_path == NULL)
@@ -690,6 +690,12 @@ int c2__confc_open(struct c2_confc_ctx *ctx, struct c2_conf_obj *origin,
 	return 0;
 }
 
+int c2__confc_open(struct c2_confc_ctx *ctx, struct c2_conf_obj *origin,
+		   const struct c2_conf_pathcomp *path)
+{
+	return _open(ctx, origin, path, false);
+}
+
 int c2__confc_open_sync(void **obj, struct c2_confc *client,
 			struct c2_conf_obj *origin,
 			const struct c2_conf_pathcomp *path)
@@ -720,31 +726,96 @@ int c2__confc_open_sync(void **obj, struct c2_confc *client,
 
 void c2_confc_close(void *obj, struct c2_confc *client)
 {
-	struct c2_conf_obj *x = obj;
-
-	c2_mutex_lock(client->cc_lock);
-	C2_CNT_DEC(x->co_nrefs);
-	if (x->co_nrefs == 0)
-		c2_chan_broadcast(&x->co_chan);
-	c2_mutex_unlock(client->cc_lock);
+	if (obj != NULL) {
+		struct c2_conf_obj *x = obj;
+
+		c2_mutex_lock(client->cc_lock);
+		C2_CNT_DEC(x->co_nrefs);
+		if (x->co_nrefs == 0)
+			c2_chan_broadcast(&x->co_chan);
+		c2_mutex_unlock(client->cc_lock);
+	}
 }
 
+/* ------------------------------------------------------------------
+ * Directory operations.
+ * ------------------------------------------------------------------ */
+
 /** Collection of configuration objects. */
 struct c2_confc_dir {
-	/** Parent object this collection belongs to. */
+	/** The object owning this collection. */
 	struct c2_conf_obj       *d_parent;
 	/**
-	 * Currently opened (and pinned) element of this collection.
-	 *
-	 * The value is updated by c2_confc_dirnext().
+	 * Pointer to the object that will be returned by
+	 * c2_confc_dirnext().
 	 */
-	struct c2_conf_obj       *d_current;
+	struct c2_conf_obj       *d_cursor;
 	/** List descriptor. */
 	const struct c2_tl_descr *d_descr;
 	/** The confc instance this collection relates to. */
 	struct c2_confc          *d_client;
 };
 
+static int confc_dir_invariant(const struct c2_confc_dir *dir)
+{
+	XXX;
+}
+
+int c2__confc_diropen(struct c2_confc_ctx *ctx, struct c2_conf_obj *origin,
+		      const struct c2_conf_pathcomp *path)
+{
+	return _open(ctx, origin, path, true);
+}
+
+int c2__confc_diropen_sync(struct c2_confc_dir **dir, struct c2_confc *client,
+			   struct c2_conf_obj *origin,
+			   const struct c2_conf_pathcomp *path)
+{
+	XXX;
+}
+
+/**
+ * Pointer to the "previously opened" object.
+ *
+ * Returns the pointer returned by the most recent
+ * c2_confc_dirnext(dir) call.
+ */
+static void * dir_prev_obj(const struct c2_confc_dir *dir)
+{
+	/*
+	 * Result is deduced dynamically from dir->d_descr and
+	 * dir->d_cursor.
+	 */
+	XXX;
+}
+
+const void * c2_confc_dirnext(struct c2_confc_dir *dir)
+{
+	/*
+	 * c2_confc_close() previously opened object.
+	 *
+	 * Return NULL if dir->d_cursor points to end-of-sequence.
+	 *
+	 * Otherwise, increment reference counter
+	 * (c2_conf_obj::co_nrefs) of the object pointed to by
+	 * dir->d_cursor, anvance the cursor, and return the object,
+	 * whose reference counter has been incremented.
+	 */
+	XXX;
+}
+
+void c2_confc_dirclose(struct c2_confc_dir *dir, struct c2_confc *client)
+{
+	/*
+	 * if (dir != NULL) {
+	 *     C2_PRE(dir->d_parent->co_nrefs > 0);
+	 *     c2_confc_close() previously opened object;
+	 *     c2_confc_close(dir->d_parent, client);
+	 * }
+	 */
+	XXX;
+}
+
 /* ------------------------------------------------------------------
  * Request-related functions.
  * ------------------------------------------------------------------ */
diff --git a/conf/confc.h b/conf/confc.h
index 0858b54..d8810be 100644
--- a/conf/confc.h
+++ b/conf/confc.h
@@ -550,7 +550,8 @@ int c2__confc_diropen_sync(struct c2_confc_dir **dir, struct c2_confc *client,
  * Returns NULL if at the end of collection.
  *
  * Closes the object returned by previous c2_confc_dirnext() called
- * with the same argument.
+ * with the same argument.  Increments reference counter
+ * (c2_conf_obj::co_nrefs) of the returned object.
  *
  * c2_confc_dirnext() is used to iterate a collection of configuration
  * objects.  Example:
-- 
1.8.3.2

