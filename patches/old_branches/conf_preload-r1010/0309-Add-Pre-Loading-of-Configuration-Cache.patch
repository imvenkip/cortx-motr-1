From 0f7da76fbe6cd5b66ee72bad41ba9588bb1b5109 Mon Sep 17 00:00:00 2001
From: Anatoliy Bilenko <anatoliy_bilenko@xyratex.com>
Date: Mon, 3 Sep 2012 17:02:35 +0300
Subject: [PATCH 309/311] Add Pre-Loading of Configuration Cache.

---
 Makefile.am              |   1 +
 colibri/Makefile.am      |   1 +
 conf/Makefile.am         |   9 +
 conf/obj.h               | 275 +++------------
 conf/onwire.h            | 200 +++++++++++
 conf/preload.c           | 857 +++++++++++++++++++++++++++++++++++++++++++++++
 conf/preload.h           |  17 +-
 conf/ut/Makefile.am      |   6 +
 conf/ut/confx.txt        |  19 ++
 conf/ut/prepar.c         | 244 ++++++++++++++
 configure.ac             |   1 +
 lib/Makefile.am          |   2 +
 lib/linux_kernel/kmisc.c |  44 +++
 lib/misc.h               |   6 +
 lib/user_space/umisc.c   |  42 +++
 15 files changed, 1482 insertions(+), 242 deletions(-)
 create mode 100644 conf/Makefile.am
 create mode 100644 conf/onwire.h
 create mode 100644 conf/preload.c
 create mode 100644 conf/ut/confx.txt
 create mode 100644 conf/ut/prepar.c
 create mode 100644 lib/linux_kernel/kmisc.c
 create mode 100644 lib/user_space/umisc.c

diff --git a/Makefile.am b/Makefile.am
index a7c4dad..55193c2 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -23,6 +23,7 @@ SUBDIRS_LIBS =                     \
                capa                \
                cfg                 \
                cob                 \
+               conf                \
                console             \
                db                  \
                desim               \
diff --git a/colibri/Makefile.am b/colibri/Makefile.am
index a85a9f3..86dfb38 100644
--- a/colibri/Makefile.am
+++ b/colibri/Makefile.am
@@ -22,6 +22,7 @@ libcolibri_la_LIBADD      = @AIO_LIBS@ @PTHREAD_LIBS@ @DB_LIBS@ @GALOIS_LIBS@ @Y
 			    $(top_builddir)/capa/libcolibri-capa.la \
                             $(top_builddir)/cfg/libcolibri-cfg.la \
                             $(top_builddir)/cob/libcolibri-cob.la \
+                            $(top_builddir)/conf/libcolibri-conf.la \
                             $(top_builddir)/console/libcolibri-console.la \
                             $(top_builddir)/db/libcolibri-db.la \
                             $(top_builddir)/desim/libcolibri-desim.la \
diff --git a/conf/Makefile.am b/conf/Makefile.am
new file mode 100644
index 0000000..20d4038
--- /dev/null
+++ b/conf/Makefile.am
@@ -0,0 +1,9 @@
+include $(top_srcdir)/Makefile.xc
+
+noinst_LTLIBRARIES = libcolibri-conf.la
+libcolibri_conf_la_SOURCES = onwire.h preload.h preload.c
+
+INCLUDES = -iquote . -iquote $(top_srcdir) -iquote $(top_srcdir)/include \
+           -iquote /usr/include
+
+clean-local: clean-xc
diff --git a/conf/obj.h b/conf/obj.h
index 7409464..555a6a8 100644
--- a/conf/obj.h
+++ b/conf/obj.h
@@ -17,23 +17,22 @@
  * Original author: Valery V. Vorotyntsev <valery_vorotyntsev@xyratex.com>
  * Original creation date: 30-Jan-2012
  */
+#pragma once
 #ifndef __COLIBRI_CONF_OBJ_H__
 #define __COLIBRI_CONF_OBJ_H__
 
-#ifdef __KERNEL__
-#  include "conf/onwire_k.h"
-#else
-#  include "conf/onwire_u.h" /* c2_conf_buf */
-#endif
-
 /* XXX @todo Move definitions from cfg/cfg.h to conf/schema.ff */
 #include "cfg/cfg.h"   /* c2_cfg_service_type */
 
+#include "lib/buf.h"   /* c2_buf */
 #include "lib/chan.h"  /* c2_chan */
 #include "fid/fid.h"   /* c2_fid */
 #include "lib/tlist.h" /* c2_tl, c2_tlink */
-#include "lib/types.h"
 #include "lib/bob.h"   /* c2_bob_type */
+#include "lib/types.h"
+
+struct c2_conf_obj_ops;
+struct c2_confc;
 
 /**
  * @page conf-fspec-obj Configuration Objects
@@ -41,7 +40,6 @@
  * - @ref conf-fspec-obj-data
  * - @ref conf-fspec-obj-enum
  *   - @ref conf-fspec-obj-enum-status
- * - @ref conf-fspec-obj-sub
  * - @ref conf-fspec-obj-pinned
  * - @ref conf-fspec-obj-private
  *
@@ -65,8 +63,6 @@
  * Such common attributes are put together into c2_conf_obj structure,
  * which is embedded into concrete configuration objects.
  *
- * c2_conf_obj_ops is configuration object operations vector.
- *
  * <hr> <!------------------------------------------------------------>
  * @section conf-fspec-obj-enum Enumerations
  *
@@ -102,21 +98,6 @@
  * @enddot
  *
  * <hr> <!------------------------------------------------------------>
- * @section conf-fspec-obj-sub Subroutines
- *
- * c2_conf__obj_invariant() checks validity of a configuration object.
- *
- * c2_conf__obj_get() and c2_conf__obj_put() are used by confc and
- * confd implementations to manipulate reference counter of a
- * configuration object.
- *
- * c2_conf__readdir_pre() and c2_conf__readdir_post() are pre- and
- * postconditions for c2_conf_obj_ops::coo_readdir().
- *
- * The c2_conf__*() functions mentioned above are not supposed to be
- * used by the application (aka configuration consumer).
- *
- * <hr> <!------------------------------------------------------------>
  * @section conf-fspec-obj-pinned Pinned Objects
  *
  * If object's reference counter -- c2_conf_obj::co_nrefs -- is
@@ -145,16 +126,6 @@
  * @{
  */
 
-/**
- * Status of configuration object.
- * Configuration object is a stub unless its status is C2_CS_READY.
- */
-enum c2_conf_status {
-	C2_CS_MISSING, /*< Configuration is absent; no retrieval in progress. */
-	C2_CS_LOADING, /*< Retrieval of configuration is in progress. */
-	C2_CS_READY    /*< Configuration is available. */
-};
-
 /** Type of configuration object. */
 enum c2_conf_objtype {
 	C2_CO_DIR,        /* 0 */
@@ -168,8 +139,15 @@ enum c2_conf_objtype {
 	C2_CO_NR
 };
 
-struct c2_conf_obj_ops;
-struct c2_confc; /* defined in "conf/confc.h" */
+/**
+ * Status of configuration object.
+ * Configuration object is a stub unless its status is C2_CS_READY.
+ */
+enum c2_conf_status {
+	C2_CS_MISSING, /*< Configuration is absent; no retrieval in progress. */
+	C2_CS_LOADING, /*< Retrieval of configuration is in progress. */
+	C2_CS_READY    /*< Configuration is available. */
+};
 
 /**
  * Generic configuration object.
@@ -185,7 +163,7 @@ struct c2_conf_obj {
 	 * Object identifier.
 	 * This value is unique among the object of given ->co_type.
 	 */
-	struct c2_conf_buf            co_id;
+	struct c2_buf                 co_id;
 	enum c2_conf_status           co_status;
 	const struct c2_conf_obj_ops *co_ops;
 	/**
@@ -199,7 +177,7 @@ struct c2_conf_obj {
 	 * Reference counter.
 	 * The object is "pinned" if this value is non-zero.
 	 *
-	 * @see c2_conf__obj_get(), c2_conf__obj_put()
+	 * @see c2_conf_obj_get(), c2_conf_obj_put()
 	 */
 	uint64_t                      co_nrefs;
 	/**
@@ -236,43 +214,6 @@ struct c2_conf_obj {
 	 */
 	uint64_t                      co_con_magic;
 };
-
-/**
- * Checks validity of given configuration object.
- *
- * @note  c2_conf__obj_invariant() is used by confc and confd
- *        implementations and is not supposed to be used by the
- *        application (aka configuration consumer).
- *
- * @see  c2_conf_obj_ops::coo_invariant()
- */
-bool c2_conf__obj_invariant(const struct c2_conf_obj *obj);
-
-/**
- * Increments reference counter of given configuration object.
- *
- * @pre   obj->co_status == C2_CS_READY
- * @post  obj->co_nrefs > 0
- *
- * @note  c2_conf__obj_get() is used by confc and confd
- *        implementations and is not supposed to be used by the
- *        application (aka configuration consumer).
- */
-void c2_conf__obj_get(struct c2_conf_obj *obj);
-
-/**
- * Decrements reference counter of given configuration object.
- *
- * Broadcasts obj->co_chan if the object becomes unpinned (i.e., if
- * the decremented counter reaches 0).
- *
- * @pre  obj->co_nrefs > 0 && obj->co_status == C2_CS_READY
- *
- * @note  c2_conf__obj_put() is used by confc and confd
- *        implementations and is not supposed to be used by the
- *        application (aka configuration consumer).
- */
-void c2_conf__obj_put(struct c2_conf_obj *obj);
 
 /* ------------------------------------------------------------------
  * Concrete configuration objects
@@ -286,10 +227,9 @@ struct c2_conf_dir {
 	/**
 	 * Type of items.
 	 *
-	 * This field lets c2_conf_dir know which "relation" it
-	 * represents.
+	 * This field lets c2_conf_dir know which "relation" it represents.
 	 */
-	enum c2_conf_objtype cd_items_t;
+	enum c2_conf_objtype cd_item_type;
 };
 
 struct c2_conf_profile {
@@ -311,25 +251,20 @@ struct c2_conf_filesystem {
 	 * NULL terminated array of C strings.
 	 * XXX @todo Make it an array of name-value pairs (attributes).
 	 */
-	const char         *cf_params;
+	const char        **cf_params;
 };
 
 struct c2_conf_service {
 	struct c2_conf_obj       cs_obj;
 	/** The node this service is hosted at. */
 	struct c2_conf_node     *cs_node;
-	/**
-	 * Linkage to ->cd_items of the c2_conf_dir hanging from
-	 * c2_conf_filesystem::cf_services.
-	 */
-	struct c2_tlink          cs_filesystem_linkage;
 /* configuration data (for the application) */
 	enum c2_cfg_service_type cs_type;
 	/**
 	 * Service end points.
 	 * NULL terminated array of C strings.
 	 */
-	const char              *cs_endpoints;
+	const char             **cs_endpoints;
 };
 
 struct c2_conf_node {
@@ -351,11 +286,6 @@ struct c2_conf_node {
 /** Network interface controller. */
 struct c2_conf_nic {
 	struct c2_conf_obj ni_obj;
-	/**
-	 * Linkage to ->cd_items of the c2_conf_dir hanging from
-	 * c2_conf_node::cn_nics.
-	 */
-	struct c2_tlink    ni_linkage;
 /* configuration data (for the application) */
 	uint32_t           ni_iface;
 	uint32_t           ni_mtu;
@@ -368,11 +298,6 @@ struct c2_conf_nic {
 struct c2_conf_sdev {
 	struct c2_conf_obj  sd_obj;
 	struct c2_conf_dir *sd_partitions;
-	/**
-	 * Linkage to ->cd_items of the c2_conf_dir hanging from
-	 * c2_conf_node::cn_sdevs.
-	 */
-	struct c2_tlink     sd_linkage;
 /* configuration data (for the application) */
 	uint32_t            sd_iface;
 	uint32_t            sd_media;
@@ -385,11 +310,6 @@ struct c2_conf_sdev {
 /** Storage device partition. */
 struct c2_conf_partition {
 	struct c2_conf_obj pa_obj;
-	/**
-	 * Linkage to ->cd_items of the c2_conf_dir hanging from
-	 * c2_conf_sdev::sd_partitions.
-	 */
-	struct c2_tlink    pa_linkage;
 /* configuration data (for the application) */
 	uint64_t           pa_start;
 	uint64_t           pa_size;
@@ -402,33 +322,11 @@ struct c2_conf_partition {
  * Cast
  * ------------------------------------------------------------------ */
 
-#define _DECLARE(type) \
-struct type;           \
-extern struct c2_bob_type type ## _bob
-_DECLARE(c2_conf_dir);
-_DECLARE(c2_conf_profile);
-_DECLARE(c2_conf_filesystem);
-_DECLARE(c2_conf_service);
-_DECLARE(c2_conf_node);
-_DECLARE(c2_conf_nic);
-_DECLARE(c2_conf_sdev);
-_DECLARE(c2_conf_partition);
-#undef _DECLARE
-
-#define c2_conf_dir_cast_field        cd_obj
-#define c2_conf_profile_cast_field    cp_obj
-#define c2_conf_filesystem_cast_field cf_obj
-#define c2_conf_service_cast_field    cs_obj
-#define c2_conf_node_cast_field       cn_obj
-#define c2_conf_nic_cast_field        ni_obj
-#define c2_conf_sdev_cast_field       sd_obj
-#define c2_conf_partition_cast_field  pa_obj
-
 /**
  * Casts c2_conf_obj to the ambient concrete configuration object.
  *
- * @param ptr    Pointer to c2_conf_obj member.
- * @param type   Type of concrete configuration object (without `struct').
+ * @param ptr   Pointer to c2_conf_obj member.
+ * @param type  Type of concrete configuration object (without `struct').
  *
  * Example:
  * @code
@@ -437,119 +335,24 @@ _DECLARE(c2_conf_partition);
  */
 #define C2_CONF_CAST(ptr, type) \
 	bob_of(ptr, struct type, type ## _cast_field, &type ## _bob)
-
-/* ------------------------------------------------------------------
- * Object operations vector
- * ------------------------------------------------------------------ */
-
-/** Symbolic names for c2_conf_obj_ops::coo_readdir() return values. */
-enum c2_conf_dirval {
-	/** End of directory is reached. */
-	C2_CONF_DIREND = 0,
-	/** The next directory entry is available immediately. */
-	C2_CONF_DIRNEXT,
-	/**
-	 * The next directory entry is missing from configuration
-	 * cache or is a stub.
-	 */
-	C2_CONF_DIRMISS
-};
-
-/** Configuration object operations. */
-struct c2_conf_obj_ops {
-	/**
-	 * Finds a child of given object.
-	 *
-	 * @param parent  The object being searched.
-	 * @param name    Name of the relation leading to a child object.
-	 *                Identifier of the child object, if parent is
-	 *                a directory.
-	 * @param out     If the function succeeds, *out will point to the
-	 *                sought-for object.
-	 *
-	 * @pre  parent->co_status == C2_CS_READY
-	 */
-	int (*coo_lookup)(struct c2_conf_obj *parent,
-			  const struct c2_conf_buf *name,
-			  struct c2_conf_obj **out);
-	/**
-	 * Gets next directory entry.
-	 *
-	 * @param      dir   Directory.
-	 * @param[in]  pptr  "Current" entry.
-	 * @param[out] pptr  "Next" entry.
-	 *
-	 * @retval C2_CONF_DIRMISS  The next directory entry is missing from
-	 *                          configuration cache or is a stub.
-	 * @retval C2_CONF_DIRNEXT  *pptr now points to the next entry.
-	 * @retval C2_CONF_DIREND   End of directory is reached.
-	 * @retval -Exxx            Error.
-	 *
-	 * ->coo_readdir() puts (c2_conf__obj_put()) configuration
-	 * object referred to via `pptr' input parameter.
-	 *
-	 * ->coo_readdir() pins (c2_conf__obj_get()) the resulting
-	 * object in case of C2_CONF_DIRNEXT.
-	 *
-	 * @pre   c2_conf__readdir_pre(dir, *pptr)
-	 * @post  c2_conf__readdir_post(retval, dir, *pptr)
-	 */
-	int (*coo_readdir)(struct c2_conf_obj *dir, struct c2_conf_obj **pptr);
-	/**
-	 * Checks validity of given concrete object.
-	 *
-	 * ->coo_invariant() should only validate concrete fields of
-	 * an object. Generic ones (i.e., the fields of c2_conf_obj)
-	 * are validated by c2_conf__obj_invariant().
-	 *
-	 * ->coo_invariant() can be NULL; in this case only generic
-	 * fields will be validated by c2_conf__obj_invariant().
-	 *
-	 * @see c2_conf__obj_invariant()
-	 */
-	bool (*coo_invariant)(const struct c2_conf_obj *obj);
-	/**
-	 * Destructor of configuration object.
-	 *
-	 * The intended usage of ->coo_fini() is to free the allocated
-	 * concrete object (i.e., the ambient object that `obj' is
-	 * embedded in).
-	 */
-	void (*coo_fini)(struct c2_conf_obj *obj);
-};
 
-/**
- * Precondition for c2_conf_obj_ops::coo_readdir().
- *
- * @param dir     The 1st argument of ->coo_readdir().
- * @param entry   The 2nd argument of ->coo_readdir(), dereferenced
- *                before the function is called (*pptr).
- *
- * @note  c2_conf__readdir_pre() is used by confc and confd
- *        implementations and is not supposed to be used by the
- *        application (aka configuration consumer).
- *
- * @see c2_conf_obj_ops::coo_readdir()
- */
-bool c2_conf__readdir_pre(const struct c2_conf_obj *dir,
-			  const struct c2_conf_obj *entry);
+#define c2_conf_dir_cast_field        cd_obj
+#define c2_conf_profile_cast_field    cp_obj
+#define c2_conf_filesystem_cast_field cf_obj
+#define c2_conf_service_cast_field    cs_obj
+#define c2_conf_node_cast_field       cn_obj
+#define c2_conf_nic_cast_field        ni_obj
+#define c2_conf_sdev_cast_field       sd_obj
+#define c2_conf_partition_cast_field  pa_obj
 
-/**
- * Postcondition for c2_conf_obj_ops::coo_readdir().
- *
- * @param retval  The value returned by ->coo_readdir().
- * @param dir     The 1st argument of ->coo_readdir().
- * @param entry   The 2nd argument of ->coo_readdir(), dereferenced
- *                after the function is called (*pptr).
- *
- * @note  c2_conf__readdir_pre() is used by confc and confd
- *        implementations and is not supposed to be used by the
- *        application (aka configuration consumer).
- *
- * @see c2_conf_obj_ops::coo_readdir()
- */
-bool c2_conf__readdir_post(int retval, const struct c2_conf_obj *dir,
-			   const struct c2_conf_obj *entry);
+extern const struct c2_bob_type c2_conf_dir_bob;
+extern const struct c2_bob_type c2_conf_profile_bob;
+extern const struct c2_bob_type c2_conf_filesystem_bob;
+extern const struct c2_bob_type c2_conf_service_bob;
+extern const struct c2_bob_type c2_conf_node_bob;
+extern const struct c2_bob_type c2_conf_nic_bob;
+extern const struct c2_bob_type c2_conf_sdev_bob;
+extern const struct c2_bob_type c2_conf_partition_bob;
 
 /** @} conf_dfspec_obj */
 #endif /* __COLIBRI_CONF_OBJ_H__ */
diff --git a/conf/onwire.h b/conf/onwire.h
new file mode 100644
index 0000000..23bf106
--- /dev/null
+++ b/conf/onwire.h
@@ -0,0 +1,200 @@
+/* -*- c -*- */
+/*
+ * COPYRIGHT 2012 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original authors: Valery V. Vorotyntsev <valery_vorotyntsev@xyratex.com>,
+ *		     Anatoliy Bilenko <anatoliy_bilenko@xyratex.com>
+ * Original creation date: 20-Aug-2012
+ */
+#pragma once
+#ifndef __COLIBRI_CONF_ONWIRE_H__
+#define __COLIBRI_CONF_ONWIRE_H__
+
+#include "xcode/xcode.h"
+
+/* export */
+struct c2_conf_fetch;
+struct c2_conf_fetch_resp;
+struct c2_conf_update;
+struct c2_conf_update_resp;
+
+/** XXX @todo Use c2_buf instead of arr_buf. */
+struct arr_buf {
+	uint32_t       ab_count;
+	struct c2_buf *ab_elems;
+} C2_XCA_SEQUENCE;
+
+/** XXX @todo s/objid/objiden/ ? */
+struct objid {
+	uint32_t      oi_type; /* see c2_conf_objtype for values */
+	struct c2_buf oi_id;
+} C2_XCA_RECORD;
+
+/** XXX @todo Use c2_fid? */
+struct fid {
+	uint64_t f_container;
+	uint64_t f_key;
+} C2_XCA_RECORD;
+
+/* ------------------------------------------------------------------
+ * Configuration objects
+ * ------------------------------------------------------------------ */
+struct confx_profile {
+	/* Name of profile's filesystem. */
+	struct c2_buf xp_filesystem;
+} C2_XCA_RECORD;
+
+struct confx_filesystem {
+	/* Rood fid. */
+	struct fid     xf_rootfid;
+	/* Filesystem parameters. */
+	struct arr_buf xf_params;
+	/* Services of this filesystem. */
+	struct arr_buf xf_services;
+} C2_XCA_RECORD;
+
+struct confx_service {
+	/* Service type.  See c2_cfg_service_type. */
+	uint32_t       xs_type;
+	/* End-points from which this service is reachable. */
+	struct arr_buf xs_endpoints;
+	/* Hosting node. */
+	struct c2_buf  xs_node;
+} C2_XCA_RECORD;
+
+struct confx_node {
+	/* Memory size in MB. */
+	uint32_t       xn_memsize;
+	/* Number of processors. */
+	uint32_t       xn_nr_cpu;
+	/* Last known state.  See c2_cfg_state_bit. */
+	uint64_t       xn_last_state;
+	/* Property flags.  See c2_cfg_flag_bit. */
+	uint64_t       xn_flags;
+	/* Pool id. */
+	uint64_t       xn_pool_id;
+	/* Network interfaces. */
+	struct arr_buf xn_nics;
+	/* Storage devices. */
+	struct arr_buf xn_sdevs;
+} C2_XCA_RECORD;
+
+struct confx_nic {
+	/* Type of network interface.  See c2_cfg_nic_type. */
+	uint32_t      xi_iface;
+	/* Maximum transmission unit. */
+	uint32_t      xi_mtu;
+	/* Speed in Mb/sec. */
+	uint64_t      xi_speed;
+	/* Filename in host OS. */
+	struct c2_buf xi_filename;
+	/* Last known state.  See c2_cfg_state_bit. */
+	uint64_t      xi_last_state;
+} C2_XCA_RECORD;
+
+struct confx_sdev {
+	/* Interface type.  See c2_cfg_storage_device_interface_type. */
+	uint32_t       xd_iface;
+	/* Media type.  See c2_cfg_storage_device_media_type. */
+	uint32_t       xd_media;
+	/* Size in bytes. */
+	uint64_t       xd_size;
+	/* Last known state.  See c2_cfg_state_bit. */
+	uint64_t       xd_last_state;
+	/* Property flags.  See c2_cfg_flag_bit. */
+	uint64_t       xd_flags;
+	/* Filename in host OS. */
+	struct c2_buf  xd_filename;
+	/* Partitions of this storage device. */
+	struct arr_buf xd_partitions;
+} C2_XCA_RECORD;
+
+struct confx_partition {
+	/* Start offset in bytes. */
+	uint64_t      xa_start;
+	/* Size in bytes. */
+	uint64_t      xa_size;
+	/* Partition index. */
+	uint32_t      xa_index;
+	/* Partition type.  See c2_cfg_storage_device_partition_type. */
+	uint32_t      xa_type;
+	/* Filename in host OS. */
+	struct c2_buf xa_file;
+} C2_XCA_RECORD;
+
+struct confx_u {
+	uint32_t u_type; /* see c2_conf_objtype for values */
+	union {
+		/*
+		 * Note that there is no such thing as `confx_dir'.
+		 * One-to-many relations are represented by a list of
+		 * identifiers --- `arr_buf'.
+		 */
+		struct confx_profile    u_profile;
+		struct confx_filesystem u_filesystem;
+		struct confx_service    u_service;
+		struct confx_node       u_node;
+		struct confx_nic        u_nic;
+		struct confx_sdev       u_sdev;
+		struct confx_partition  u_partition;
+	} u;
+} C2_XCA_UNION;
+
+/** Configuration object descriptor. */
+struct confx_object {
+	struct c2_buf  o_id;   /*< Object identifier. */
+	struct confx_u o_conf; /*< Configuration data. */
+} C2_XCA_RECORD;
+
+struct enconf {
+	uint32_t             ec_nr;
+	struct confx_object *ec_objs;
+} C2_XCA_SEQUENCE;
+
+/* ------------------------------------------------------------------
+ * Configuration fops
+ * ------------------------------------------------------------------ */
+
+/** Configuration request. */
+struct c2_conf_fetch {
+	/** Configuration object the path originates from. */
+	struct objid   f_origin;
+	/** Path components. */
+	struct arr_buf f_path;
+} C2_XCA_RECORD;
+
+/** Confd's response to c2_conf_fetch. */
+struct c2_conf_fetch_resp {
+	/** Result of configuration retrieval (-Exxx = failure, 0 = success). */
+	uint32_t      fr_rc;
+	/** A sequence of configuration object descriptors. */
+	struct enconf fr_data;
+} C2_XCA_RECORD;
+
+/** Update request. */
+struct c2_conf_update {
+	/** Configuration object the path originates from. */
+	struct objid  f_origin;
+	/** A sequence of configuration object descriptors. */
+	struct enconf fr_data;
+} C2_XCA_RECORD;
+
+/** Confd's response to c2_conf_update. */
+struct c2_conf_update_resp {
+	/** Result of update request (-Exxx = failure, 0 = success). */
+	uint32_t fr_rc;
+} C2_XCA_RECORD;
+
+#endif /* __COLIBRI_CONF_ONWIRE_H__ */
diff --git a/conf/preload.c b/conf/preload.c
new file mode 100644
index 0000000..dd0296e
--- /dev/null
+++ b/conf/preload.c
@@ -0,0 +1,857 @@
+/* -*- c -*- */
+/*
+ * COPYRIGHT 2012 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: Valery V. Vorotyntsev <valery_vorotyntsev@xyratex.com>
+ *                  Anatoliy Bilenko <Anatoliy_Bilenko@xyratex.com>
+ * Original creation date: 29-Aug-2012
+ */
+
+#include "conf/preload.h"
+#include "conf/onwire.h"
+#include "conf/obj.h"
+
+#include "lib/assert.h"
+#include "lib/memory.h"
+#include "lib/errno.h"
+#include "lib/misc.h"
+#include <ctype.h>		/* isspace */
+
+/* #define HUNK_DBG */
+#ifdef HUNK_DBG
+#include <stdio.h>
+#endif
+
+
+/* ------------------------------------------------------------------
+ * Simple character stack, used by preload parser library
+ * ------------------------------------------------------------------ */
+
+struct stack {
+	char  *stack;
+	size_t size;
+	size_t end; /* top + 1 */
+};
+
+#define STACK_INIT(s) { .stack = s, .size = ARRAY_SIZE(s), .end = 0 }
+
+static bool stack_is_empty(const struct stack *stack)
+{
+	return stack->end == 0;
+}
+
+static int stack_pop(struct stack *stack)
+{
+	if (stack_is_empty(stack))
+		return -EINVAL; /* underflow! */
+
+	stack->end--;
+	return 0;
+}
+
+static int stack_push(struct stack *stack, char c)
+{
+	if (stack->end >= stack->size)
+		return -ENOMEM; /* overflow! */
+
+	stack->stack[stack->end++] = c;
+	return 0;
+}
+
+static char stack_top(const struct stack *stack)
+{
+	C2_PRE(stack->end > 0 && stack->end <= stack->size);
+
+	return stack->stack[stack->end - 1];
+}
+
+
+/* -----------------------------------------------------------------------------
+  Preload parser minilibrary is used to parse sequences of characters, separated
+  by ',', ':',... w.r.t. other separators like braces, quotes, etc. It provides
+  non-destructive input data capability and introduces the following
+  abstractions:
+
+        # Hunk is like an area of interest in given sequence of characters. It
+          has begin and end to specify the bounds of it. Library provides some
+          minimalistic functions to operate hunks, like validating, copying,
+          comparing with built-in types, getting length.
+
+	# Unit is something that parser treats to be atomic and does not parse
+          into. From the beginning it was called an `atom'. Units are in some
+          sense 'context dependent' hunks. For example, the following can be a
+          unit:
+
+           [ { "type":"profile", ... , "id":"test-2" },...,{    ...    } ], ...
+           | | |<---unit_00-->|        |<-unit_0n->| |     |           | |
+           | |<----------------unit_10-------------->|     |<-unit_1n->| |
+           |<------------------------unit_30---------------------------->|
+
+          Library may perform simple manipulations over units, like trimming
+          whitespaces, unquote quoted units. The most interesting part is
+          parsing unit in the beginning of a `stream' and moving to the next
+          separated unit in the stream (unit_parse(), unit_next()). It's also
+          possible to look into an 'atomic'-hunk and to find out that it's not.
+          For example, advancing into unit_10, 'may find something in
+          undividable' (unit_advance()).
+
+        # Sequence iterator is a wrapper over unit_parse() and unit_next() which
+          provides an iterator-like iterface. Unit, state of the input stream
+          (buffer) and the type of used separator is a context of the iterator.
+
+  Usage:
+          struct hunk stream = HUNK_INITS("[parsed, seq], [of, bytes]");
+          struct hunk unit = HUNK_INITIAL;
+          size_t ui; // unit index
+          int    rc;
+
+          for (; (rc = seq_iterate(&unit, &stream, ',')) == 0; ui++) {
+                C2_ASSERT(hunk_str_eq(&stream, "[parsed, seq], [of, bytes]"));
+                C2_ASSERT(ergo(ui == 0, hunk_str_eq(&unit, "[parsed, seq]")));
+                C2_ASSERT(ergo(ui == 1, hunk_str_eq(&unit, "[of, bytes]")));
+          }
+
+          C2_ASSERT(rc == -ENOENT);
+ ---------------------------------------------------------------------------- */
+
+
+struct hunk {
+	const char *begin;
+	const char *end;
+};
+
+#define HUNK_CP(p)    { .begin = p->begin, .end = p->end }
+#define HUNK_INITIAL  { NULL, NULL }
+#define HUNK_INITS(s) { .begin = s, .end = &s[strlen(s) - 1] }
+
+static bool hunk_is_initial(const struct hunk *p)
+{
+	return p->begin == NULL && p->end == NULL;
+}
+
+static bool hunk_invariant(const struct hunk *p)
+{
+	C2_PRE(!hunk_is_initial(p));
+	return p->end >= p->begin;
+}
+
+static void hunk_pr(const char *prefix, const struct hunk *p) {
+#ifdef HUNK_DBG
+	char  buf[4096];
+	const char *c;
+
+	C2_PRE(hunk_invariant(p));
+
+	for (c = p->begin; c <= p->end; ++c)
+		C2_PRE(isprint(*c));
+
+	memset(buf, 0, 4096);
+	memcpy(buf, p->begin, p->end - p->begin + 1);
+	printf("%s: ~%s~\n", prefix, buf);
+#endif
+}
+
+static void hunk_cp(struct hunk *dest, const struct hunk *source) {
+	*dest = *source;
+}
+
+static size_t hunk_len(const struct hunk *hunk)
+{
+	C2_PRE(hunk_invariant(hunk));
+
+	return hunk->end - hunk->begin + 1;
+}
+
+static bool hunk_str_eq(const struct hunk *hunk, const char *string)
+{
+	int len;
+
+	len = strlen(string);
+
+	return len == hunk_len(hunk) &&
+		memcmp(hunk->begin, string, len) == 0;
+}
+
+
+/* ------------------------------------------------------------------
+ * Units of preload parser
+ * ------------------------------------------------------------------ */
+
+static int unit_trim(struct hunk *p)
+{
+	C2_PRE(hunk_invariant(p));
+
+	while (isspace(*p->begin)) {
+		p->begin++;
+		if (p->begin > p->end)
+			return -ENOENT;
+	}
+
+	while (isspace(*p->end)) {
+		p->end--;
+		if (p->begin > p->end)
+			return -ENOENT;
+	}
+
+	return hunk_invariant(p) ? 0 : -EINVAL;
+}
+
+static int unit_advance(struct hunk *unit, char open, char close)
+{
+	C2_PRE(hunk_invariant(unit));
+
+	if (!(*unit->begin == open && *unit->end == close))
+		return -EINVAL;
+
+	unit->begin++;
+	unit->end--;
+
+	return hunk_invariant(unit) ? 0 : -ENOENT;
+}
+
+static int unit_quoted_unquote(struct hunk *unit)
+{
+	int rc = unit_advance(unit, '\"', '\"');
+
+	return (rc == -EINVAL)
+		? 0  /* -EINVAL means that hunk is not in quotes */
+		: rc;
+}
+
+static int braces_match(struct stack* stack, char brace)
+{
+	/* skipping everything except braces */
+	if (!C2_IN(brace, ('[','{','}',']')))
+		return 0;
+
+	if (C2_IN(brace, ('[','{')))
+		return stack_push(stack, brace);
+
+	/* replace on matching brace for comparison */
+	if (brace == ']') brace = '[';
+	if (brace == '}') brace = '{';
+
+	return (stack_top(stack) == brace) ? stack_pop(stack) : -EINVAL;
+}
+
+static bool is_in_braces(const struct stack *stack)
+{
+	return !stack_is_empty(stack);
+}
+
+static int unit_parse(struct hunk *unit, char ss)
+{
+	int  rc;
+	const char *p;
+	bool quoted = false;
+	char brace_stack[32]; /* Only 32 folds are supported*/
+	struct stack braces = STACK_INIT(brace_stack);
+
+	C2_PRE(C2_IN(ss, (',', ':')));
+
+	if ((rc = unit_trim(unit)) != 0)
+		return rc;
+
+	for (p = unit->begin; p <= unit->end; ++p) {
+		if (*p == '\"')
+			quoted = !quoted;
+
+		if (quoted)
+			continue;
+
+		if ((rc = braces_match(&braces, *p)) != 0)
+			return rc;
+
+		if (is_in_braces(&braces))
+			continue;
+
+		if (*p == ss) {
+			if (p == unit->begin)   /* unit starts from ',': e.g. */
+				return -EINVAL; /* ",42"; treated as an error */
+
+			unit->end = --p;
+			break;
+		}
+	}
+
+	return unit_trim(unit); /* @todo: if quoted, then what to do? */
+}
+
+static int unit_next(struct hunk *unit, const struct hunk *buffer, char ss)
+{
+	int  rc;
+
+	C2_PRE(hunk_invariant(unit));
+
+	unit->begin = unit->end;
+	unit->end = buffer->end;
+
+	unit->begin++;
+	if (!hunk_invariant(unit))
+		return -ENOENT;
+
+	if ((rc = unit_trim(unit)) != 0)
+		return rc;
+
+	C2_ASSERT(*unit->begin == ss);
+	unit->begin++;
+
+	return hunk_invariant(unit) ? 0 : -EINVAL;
+}
+
+
+/* ------------------------------------------------------------------
+ * Sequences of preload parser
+ * ------------------------------------------------------------------ */
+
+/**
+ * Iterates elements of a given sequence of characters.
+ *
+ * @param unit[inout]	parsed element of a sequence
+ * @param buffer[in]    sequence of characters, represented by a hunk
+ * @param ss[in]	sequence separator
+ *
+ * @return       0 when unit was successfully parsed,
+ *	   -ENOENT when the end of sequence reached,
+ *              <0 if any other error.
+ *
+ * @pre hunk_invariant(unit)
+ * @pre C2_IN(ss, (',', ':'))
+ */
+static int seq_iterate(struct hunk *unit, const struct hunk *buffer, char ss)
+{
+	int  rc;
+
+	C2_PRE(C2_IN(ss, (',', ':')));
+
+	if (hunk_is_initial(unit))
+		hunk_cp(unit, buffer);
+	else {
+		rc = unit_next(unit, buffer, ss);
+		if (rc != 0)
+			return rc;
+	}
+
+	return unit_parse(unit, ss);
+}
+
+/**
+ * Calculates the number of elements in a given sequence of characters.
+ *
+ * @param unit[in] sequence of characters, represented by a hunk
+ * @param ss[in]   sequence separator
+ *
+ * @pre hunk_invariant(unit)
+ * @pre C2_IN(ss, (',', ':'))
+ */
+static int seq_length(const struct hunk *unit, char ss)
+{
+	int length = 0;
+	struct hunk contents = HUNK_INITIAL;
+
+	while (seq_iterate(&contents, unit, ss) == 0)
+		length++;
+
+	return length;
+}
+
+
+/* ------------------------------------------------------------------
+ * Preload parser helpers
+ * ------------------------------------------------------------------ */
+
+static int block_parse(struct hunk *unit, const struct hunk *buffer)
+{
+	return seq_iterate(unit, buffer, ',');
+}
+
+static int record_parse(struct hunk *unit, const struct hunk *buffer)
+{
+	struct hunk contents = HUNK_CP(buffer);
+
+	return unit_advance(&contents, '[', ']') ?:
+		seq_iterate(unit, &contents, ',');
+}
+
+static int entry_parse(struct hunk *unit, const struct hunk *buffer)
+{
+	struct hunk contents = HUNK_CP(buffer);
+
+	return unit_advance(&contents, '{', '}') ?:
+		seq_iterate(unit, &contents, ',');
+}
+
+
+/* ------------------------------------------------------------------
+ * Confx object parsers
+ * ------------------------------------------------------------------ */
+
+enum { C2_CO_INVALID_TYPE = C2_CO_NR };
+
+static bool kv_invariant(const struct hunk *key, const struct hunk *val)
+{
+	return hunk_invariant(key) && hunk_invariant(val);
+}
+
+static int rootfid_parse(struct fid *fid, const struct hunk *val)
+{
+	int rc;
+	struct hunk aval = HUNK_CP(val);
+	struct hunk rfid = HUNK_INITIAL;
+
+	C2_PRE(hunk_invariant(val));
+
+	rc = unit_advance(&aval, '[', ']');
+	if (rc != 0)
+		return rc;
+
+	rc = seq_iterate(&rfid, &aval, ',');
+	if (rc != 0)
+		return rc;
+	fid->f_container = c2_strtou64(rfid.begin, NULL, 0);
+
+	rc = seq_iterate(&rfid, &aval, ',');
+	if (rc != 0)
+		return rc;
+	fid->f_key = c2_strtou64(rfid.begin, NULL, 0);
+
+	rc = seq_iterate(&rfid, &aval, ',');
+
+	return rc == -ENOENT ? 0 : -EINVAL;
+}
+
+static int arrbuf_parse(struct arr_buf *buf, const struct hunk *val)
+{
+	/* parse: ~["addr1","addr2","addr3"]~ */
+	int i;
+	int rc;
+	struct hunk aval = HUNK_CP(val);
+	struct hunk qent = HUNK_INITIAL; /* quoted entry */
+	struct hunk uent = HUNK_INITIAL; /* unquoted entry */
+
+	C2_PRE(hunk_invariant(val));
+
+	rc = unit_advance(&aval, '[', ']');
+	if (rc != 0)
+		return rc;
+
+	buf->ab_count = seq_length(&aval, ',');
+	C2_ALLOC_ARR(buf->ab_elems, buf->ab_count);
+	if (buf->ab_elems == NULL)
+		return -ENOMEM;
+
+	for (i = 0; i < buf->ab_count; ++i) {
+		rc = seq_iterate(&qent, &aval, ',');
+		if (rc != 0)
+			return rc;
+
+		hunk_cp(&uent, &qent);
+		rc = unit_quoted_unquote(&uent);
+		if (rc != 0)
+			return rc;
+
+		c2_buf_init(&buf->ab_elems[i], (void *)uent.begin,
+			    hunk_len(&uent));
+	}
+
+	return 0;
+}
+
+static int profile_parse(const struct hunk *key, const struct hunk *val,
+			 struct confx_object *out)
+{
+	C2_PRE(kv_invariant(key, val));
+	hunk_pr(__FUNCTION__, key);
+	hunk_pr(__FUNCTION__, val);
+
+	if (hunk_str_eq(key, "id"))
+		c2_buf_init(&out->o_id, (void *)val->begin, hunk_len(val));
+
+	else if (hunk_str_eq(key, "filesystem"))
+		c2_buf_init(&out->o_conf.u.u_profile.xp_filesystem,
+			    (void *)val->begin, hunk_len(val));
+
+	else
+		return -EINVAL;
+
+	return 0;
+}
+
+static int filesystem_parse(const struct hunk *key, const struct hunk *val,
+			    struct confx_object *out)
+{
+	C2_PRE(kv_invariant(key, val));
+	hunk_pr(__FUNCTION__, key);
+	hunk_pr(__FUNCTION__, val);
+
+	if (hunk_str_eq(key, "id"))
+		c2_buf_init(&out->o_id, (void *)val->begin, hunk_len(val));
+
+	else if (hunk_str_eq(key, "rootfid"))
+		return rootfid_parse(&out->o_conf.u.u_filesystem.xf_rootfid,
+				     val);
+
+	else if (hunk_str_eq(key, "params"))
+		return arrbuf_parse(&out->o_conf.u.u_filesystem.xf_params, val);
+
+	else if (hunk_str_eq(key, "services"))
+		return arrbuf_parse(&out->o_conf.u.u_filesystem.xf_services,
+				    val);
+
+	else
+		return -EINVAL;
+
+	return 0;
+}
+
+static int service_parse(const struct hunk *key, const struct hunk *val,
+			 struct confx_object *out)
+{
+	C2_PRE(kv_invariant(key, val));
+	hunk_pr(__FUNCTION__, key);
+	hunk_pr(__FUNCTION__, val);
+
+	if (hunk_str_eq(key, "id"))
+		c2_buf_init(&out->o_id, (void *)val->begin, hunk_len(val));
+
+	else if (hunk_str_eq(key, "svc_type"))
+		out->o_conf.u.u_service.xs_type =
+			c2_strtou32(val->begin, NULL, 0);
+
+	else if (hunk_str_eq(key, "endpoints"))
+		return arrbuf_parse(&out->o_conf.u.u_service.xs_endpoints, val);
+
+	else if (hunk_str_eq(key, "node"))
+		c2_buf_init(&out->o_conf.u.u_service.xs_node,
+			    (void *)val->begin, hunk_len(val));
+
+	else
+		return -EINVAL;
+
+
+	return 0;
+}
+
+static int node_parse(const struct hunk *key, const struct hunk *val,
+		      struct confx_object *out)
+{
+	C2_PRE(kv_invariant(key, val));
+	hunk_pr(__FUNCTION__, key);
+	hunk_pr(__FUNCTION__, val);
+
+	if (hunk_str_eq(key, "id"))
+		c2_buf_init(&out->o_id, (void *)val->begin, hunk_len(val));
+
+	else if (hunk_str_eq(key, "memsize"))
+		out->o_conf.u.u_node.xn_memsize =
+			c2_strtou32(val->begin, NULL, 0);
+
+	else if (hunk_str_eq(key, "nr_cpu"))
+		out->o_conf.u.u_node.xn_nr_cpu =
+			c2_strtou32(val->begin, NULL, 0);
+
+	else if (hunk_str_eq(key, "last_state"))
+		out->o_conf.u.u_node.xn_last_state =
+			c2_strtou64(val->begin, NULL, 0);
+
+	else if (hunk_str_eq(key, "flags"))
+		out->o_conf.u.u_node.xn_flags =
+			c2_strtou64(val->begin, NULL, 0);
+
+	else if (hunk_str_eq(key, "pool_id"))
+		out->o_conf.u.u_node.xn_pool_id =
+			c2_strtou64(val->begin, NULL, 0);
+
+	else if (hunk_str_eq(key, "nics"))
+		return arrbuf_parse(&out->o_conf.u.u_node.xn_nics, val);
+
+	else if (hunk_str_eq(key, "sdevs"))
+		return arrbuf_parse(&out->o_conf.u.u_node.xn_sdevs, val);
+
+	else
+		return -EINVAL;
+
+	return 0;
+}
+
+static int nic_parse(const struct hunk *key, const struct hunk *val,
+		     struct confx_object *out)
+{
+	C2_PRE(kv_invariant(key, val));
+	hunk_pr(__FUNCTION__, key);
+	hunk_pr(__FUNCTION__, val);
+
+	if (hunk_str_eq(key, "id"))
+		c2_buf_init(&out->o_id, (void *)val->begin, hunk_len(val));
+
+	else if (hunk_str_eq(key, "iface_type"))
+		out->o_conf.u.u_nic.xi_iface =
+			c2_strtou32(val->begin, NULL, 0);
+
+	else if (hunk_str_eq(key, "mtu"))
+		out->o_conf.u.u_nic.xi_mtu =
+			c2_strtou32(val->begin, NULL, 0);
+
+	else if (hunk_str_eq(key, "speed"))
+		out->o_conf.u.u_nic.xi_speed =
+			c2_strtou64(val->begin, NULL, 0);
+
+	else if (hunk_str_eq(key, "filename"))
+		c2_buf_init(&out->o_conf.u.u_nic.xi_filename,
+			    (void *)val->begin, hunk_len(val));
+
+	else if (hunk_str_eq(key, "last_state"))
+		out->o_conf.u.u_nic.xi_last_state =
+			c2_strtou64(val->begin, NULL, 0);
+
+	else
+		return -EINVAL;
+
+	return 0;
+}
+
+static int sdev_parse(const struct hunk *key, const struct hunk *val,
+		      struct confx_object *out)
+{
+	C2_PRE(kv_invariant(key, val));
+	hunk_pr(__FUNCTION__, key);
+	hunk_pr(__FUNCTION__, val);
+
+	if (hunk_str_eq(key, "id"))
+		c2_buf_init(&out->o_id, (void *)val->begin, hunk_len(val));
+
+	else if (hunk_str_eq(key, "iface"))
+		out->o_conf.u.u_sdev.xd_iface =
+			c2_strtou32(val->begin, NULL, 0);
+
+	else if (hunk_str_eq(key, "media"))
+		out->o_conf.u.u_sdev.xd_media =
+			c2_strtou32(val->begin, NULL, 0);
+
+	else if (hunk_str_eq(key, "size"))
+		out->o_conf.u.u_sdev.xd_size =
+			c2_strtou64(val->begin, NULL, 0);
+
+	else if (hunk_str_eq(key, "last_state"))
+		out->o_conf.u.u_sdev.xd_last_state =
+			c2_strtou64(val->begin, NULL, 0);
+
+	else if (hunk_str_eq(key, "flags"))
+		out->o_conf.u.u_sdev.xd_flags =
+			c2_strtou64(val->begin, NULL, 0);
+
+	else if (hunk_str_eq(key, "filename"))
+		c2_buf_init(&out->o_conf.u.u_sdev.xd_filename,
+			    (void *)val->begin, hunk_len(val));
+
+	else if (hunk_str_eq(key, "partitions"))
+		return arrbuf_parse(&out->o_conf.u.u_sdev.xd_partitions, val);
+
+	else
+		return -EINVAL;
+
+	return 0;
+}
+
+static int partition_parse(const struct hunk *key, const struct hunk *val,
+			   struct confx_object *out)
+{
+	C2_PRE(kv_invariant(key, val));
+	hunk_pr(__FUNCTION__, key);
+	hunk_pr(__FUNCTION__, val);
+
+	if (hunk_str_eq(key, "id"))
+		out->o_id = (const struct c2_buf)
+			C2_BUF_INIT(hunk_len(val), (void *)val->begin);
+
+	else if (hunk_str_eq(key, "start"))
+		out->o_conf.u.u_partition.xa_start =
+			c2_strtou64(val->begin, NULL, 0);
+
+	else if (hunk_str_eq(key, "size"))
+		out->o_conf.u.u_partition.xa_size =
+			c2_strtou64(val->begin, NULL, 0);
+
+	else if (hunk_str_eq(key, "index"))
+		out->o_conf.u.u_partition.xa_index =
+			c2_strtou32(val->begin, NULL, 0);
+
+	else if (hunk_str_eq(key, "pa_type"))
+		out->o_conf.u.u_partition.xa_type =
+			c2_strtou32(val->begin, NULL, 0);
+
+	else if (hunk_str_eq(key, "filename"))
+		out->o_conf.u.u_partition.xa_file = (const struct c2_buf)
+			C2_BUF_INIT(hunk_len(val), (void *)val->begin);
+
+	else
+		return -EINVAL;
+
+	return 0;
+}
+
+
+/* ------------------------------------------------------------------
+ * Bindings: here generic parser is being bound to concrete
+ * ------------------------------------------------------------------ */
+
+static int unused_parse(const struct hunk *key, const struct hunk *val,
+			struct confx_object *out)
+{
+	C2_IMPOSSIBLE("Wrong parser handler called");
+	return -1;
+}
+
+static const struct x_parsers {
+	const char *r_name;
+	int (*r_parse)(const struct hunk *key, const struct hunk *val,
+		       struct confx_object *out);
+} xstr[C2_CO_NR] = {
+	[C2_CO_DIR]	   = { "unused"     , unused_parse     },
+	[C2_CO_PROFILE]	   = { "profile"    , profile_parse    },
+	[C2_CO_FILESYSTEM] = { "filesystem" , filesystem_parse },
+	[C2_CO_SERVICE]	   = { "service"    , service_parse    },
+	[C2_CO_NODE]	   = { "node"	    , node_parse       },
+	[C2_CO_NIC]	   = { "nic"	    , nic_parse        },
+	[C2_CO_SDEV]	   = { "sdev"	    , sdev_parse       },
+	[C2_CO_PARTITION]  = { "partition"  , partition_parse  }
+};
+
+static size_t str_to_x(const struct hunk *key)
+{
+	size_t i;
+
+	for (i = 0; i < ARRAY_SIZE(xstr); ++i)
+		if (hunk_str_eq(key, xstr[i].r_name))
+			return i;
+
+	/* Wrong configuration string type given! */
+	return C2_CO_INVALID_TYPE;
+}
+
+static int x_parser_call(const struct hunk *str, struct confx_object *out)
+{
+	int rc;
+	struct hunk ent = HUNK_INITIAL;
+	struct hunk key = HUNK_INITIAL;
+	struct hunk val = HUNK_INITIAL;
+
+	rc = seq_iterate(&ent, str, ':');
+	if (rc != 0)
+		return rc;
+	hunk_cp(&key, &ent);
+
+	rc = seq_iterate(&ent, str, ':');
+	if (rc != 0)
+		return rc;
+	hunk_cp(&val, &ent);
+
+	rc = seq_iterate(&ent, str, ':');
+	if (rc != -ENOENT)
+		return -EINVAL;
+
+	rc = unit_advance(&key, '\"', '\"');
+	if (rc != 0)
+		return rc;
+
+	if (hunk_str_eq(&key, "type")) {
+		C2_ASSERT(out->o_conf.u_type == C2_CO_INVALID_TYPE);
+
+		rc = unit_advance(&val, '\"', '\"');
+		if (rc != 0)
+			return rc;
+
+		out->o_conf.u_type = str_to_x(&val);
+		return 0;
+	}
+
+	rc = unit_quoted_unquote(&val);
+	if (rc != 0)
+		return rc;
+
+	return (out->o_conf.u_type == C2_CO_INVALID_TYPE) ? -EINVAL :
+		xstr[out->o_conf.u_type].r_parse(&key, &val, out);
+}
+
+
+/* ------------------------------------------------------------------
+ * Toplevel parser
+ * ------------------------------------------------------------------ */
+
+int c2_conf_parse(const char *src, struct confx_object *dest, size_t n)
+{
+	int rc;
+	size_t conf_index = 0;
+	struct hunk str = HUNK_INITS(src);
+	struct hunk blk = HUNK_INITIAL;
+
+	while ((rc = block_parse(&blk, &str)) == 0) {
+		struct hunk rec = HUNK_INITIAL;
+
+		while ((rc = record_parse(&rec, &blk)) == 0) {
+			struct hunk ent = HUNK_INITIAL;
+
+			dest[conf_index].o_conf.u_type = C2_CO_INVALID_TYPE;
+
+			while ((rc = entry_parse(&ent, &rec)) == 0) {
+				rc = x_parser_call(&ent, &dest[conf_index]);
+				if (rc != 0)
+					return rc;
+			}
+
+			if (rc != -ENOENT)
+				return rc;
+
+			++conf_index;
+			if (conf_index >= n)
+				return -ENOMEM;
+		}
+
+		if (rc != -ENOENT)
+			return rc;
+	}
+
+	return (rc != -ENOENT) ? rc : conf_index;
+}
+
+void c2_confx_fini(struct confx_object *dest, size_t n)
+{
+	int i;
+	struct confx_object     *conf;
+	struct confx_filesystem *xfs;
+	struct confx_service    *xsrv;
+	struct confx_node       *xnode;
+	struct confx_sdev       *xsd;
+
+	for (i = 0; i < n; ++i) {
+		conf = &dest[i];
+
+		if (conf->o_conf.u_type == C2_CO_FILESYSTEM) {
+			xfs = &conf->o_conf.u.u_filesystem;
+			c2_free(xfs->xf_params.ab_elems);
+			c2_free(xfs->xf_services.ab_elems);
+		} else if (conf->o_conf.u_type == C2_CO_SERVICE) {
+			xsrv = &conf->o_conf.u.u_service;
+			c2_free(xsrv->xs_endpoints.ab_elems);
+		} else if (conf->o_conf.u_type == C2_CO_NODE) {
+			xnode = &conf->o_conf.u.u_node;
+			c2_free(xnode->xn_nics.ab_elems);
+			c2_free(xnode->xn_sdevs.ab_elems);
+		} else if (conf->o_conf.u_type == C2_CO_SDEV) {
+			xsd = &conf->o_conf.u.u_sdev;
+			c2_free(xsd->xd_partitions.ab_elems);
+		}
+	}
+}
diff --git a/conf/preload.h b/conf/preload.h
index d4898ae..b61c7ad 100644
--- a/conf/preload.h
+++ b/conf/preload.h
@@ -17,9 +17,14 @@
  * Original author: Valery V. Vorotyntsev <valery_vorotyntsev@xyratex.com>
  * Original creation date: 16-Mar-2012
  */
+#pragma once
 #ifndef __COLIBRI_CONF_PRELOAD_H__
 #define __COLIBRI_CONF_PRELOAD_H__
 
+#include "lib/types.h" /* size_t */
+
+struct confx_object;
+
 /**
  * @page conf-fspec-preload Pre-Loading of Configuration Cache
  *
@@ -72,16 +77,16 @@
  *
  * @code
  * struct confx_object a = {
- *     .o_id = C2_CONF_BUF_INITS("test"),
+ *     .o_id = C2_BUF_INITS("test"),
  *     .o_conf = {
  *         .u_type = C2_CO_PROFILE,
  *         .u.u_profile = {
- *             .xp_filesystem = C2_CONF_BUF_INITS("c2t1fs")
+ *             .xp_filesystem = C2_BUF_INITS("c2t1fs")
  *         }
  *     }
  * };
  * struct confx_object b = {
- *     .o_id = C2_CONF_BUF_INITS("c2t1fs"),
+ *     .o_id = C2_BUF_INITS("c2t1fs"),
  *     .o_conf = {
  *         .u_type = C2_CO_FILESYSTEM,
  *         .u.u_filesystem = {
@@ -127,8 +132,6 @@
  * @{
  */
 
-struct confx_object;
-
 /**
  * Fills the array of confx_objects with configuration data, obtained
  * from string.
@@ -143,7 +146,9 @@ struct confx_object;
  * @pre   src does not start with "local-conf:"
  * @post  retval <= n
  */
-static int c2_conf_parse(const char *src, struct confx_object dest[], size_t n);
+int c2_conf_parse(const char *src, struct confx_object *dest, size_t n);
+
+void c2_confx_fini(struct confx_object *dest, size_t n);
 
 /** @} conf_dfspec_preload */
 #endif /* __COLIBRI_CONF_PRELOAD_H__ */
diff --git a/conf/ut/Makefile.am b/conf/ut/Makefile.am
index e1b96b2..c5f1931 100644
--- a/conf/ut/Makefile.am
+++ b/conf/ut/Makefile.am
@@ -1,2 +1,8 @@
 noinst_LTLIBRARIES    = libconf-ut.la
 libconf_ut_la_SOURCES = reg.c
+libconf_ut_la_LIBADD  = $(top_builddir)/colibri/libcolibri.la
+
+# Preload parser (temporary target)
+noinst_PROGRAMS = prepar
+prepar_SOURCES  = prepar.c
+prepar_LDADD    = $(top_builddir)/colibri/libcolibri.la
diff --git a/conf/ut/confx.txt b/conf/ut/confx.txt
new file mode 100644
index 0000000..e097666
--- /dev/null
+++ b/conf/ut/confx.txt
@@ -0,0 +1,19 @@
+
+[ { "type":"profile", "id":"test-2", "filesystem":"c2t1fs" }
+, { "type":"filesystem", "id":"c2t1fs", "rootfid":[11, 22],
+    "params":["50","60","70"],   "services":["mds", "io"] }
+, { "type":"service", "id":"mds", "svc_type":1,
+    "endpoints":["addr0"], "node":"N" }
+, { "type":"service", "id":"io", "svc_type":2,
+    "endpoints":["addr1","addr2","addr3"], "node":"N" }
+, { "type":"node", "id":"N", "memsize":8000,
+    "nr_cpu":2, "last_state":3, "flags":2, "pool_id":0, "nics":["nic0"],
+    "sdevs":["sdev0"] }
+, { "type":"nic", "id":"nic0", "iface_type":5, "mtu":8192, "speed":10000,
+    "filename":"ib0", "last_state":3 }
+, { "type":"sdev", "id":"sdev0", "iface":4, "media":1, "size":596000000000,
+    "last_state":3, "flags":4, "partitions":["part0"], "filename":"/dev/sdev0" }
+, { "type":"partition", "id":"part0", "start":0, "size":596000000000, "index":0,
+    "pa_type":7, "filename":"sda1" } ]
+
+
diff --git a/conf/ut/prepar.c b/conf/ut/prepar.c
new file mode 100644
index 0000000..0acb537
--- /dev/null
+++ b/conf/ut/prepar.c
@@ -0,0 +1,244 @@
+#include "conf/preload.h"
+#include "conf/onwire.h"
+#include "conf/obj.h"
+#include "lib/assert.h"
+#include "lib/errno.h"
+#include "lib/misc.h"
+#include "lib/buf.h"
+#include <stdio.h>
+
+
+static void profile_check(const struct confx_object *conf)
+{
+	/* parse_profile: ~id~ ~test-2~ */
+	/* parse_profile: ~filesystem~ ~c2t1fs~ */
+
+	const struct c2_buf id = C2_BUF_INITS("test-2");
+	const struct c2_buf fs = C2_BUF_INITS("c2t1fs");
+
+	C2_ASSERT(c2_buf_eq(&conf->o_id, &id));
+
+	C2_ASSERT(conf->o_conf.u_type == C2_CO_PROFILE);
+	C2_ASSERT(c2_buf_eq(&conf->o_conf.u.u_profile.xp_filesystem, &fs));
+}
+
+static void filesystem_check(const struct confx_object *conf)
+{
+	/* parse_filesystem: ~id~ ~c2t1fs~ */
+	/* parse_filesystem: ~rootfid~ ~[11, 22]~ */
+	/* parse_filesystem: ~params~ ~["50","60","70"]~ */
+	/* parse_filesystem: ~services~ ~["mds", "io"]~ */
+
+	const struct c2_buf id = C2_BUF_INITS("c2t1fs");
+	const struct confx_filesystem *xfs = &conf->o_conf.u.u_filesystem;
+
+	C2_ASSERT(c2_buf_eq(&conf->o_id, &id));
+
+	C2_ASSERT(conf->o_conf.u_type == C2_CO_FILESYSTEM);
+	C2_ASSERT(xfs->xf_rootfid.f_container == 11);
+	C2_ASSERT(xfs->xf_rootfid.f_key == 22);
+
+	C2_ASSERT(xfs->xf_params.ab_count == 3);
+	C2_ASSERT(c2_buf_eq(&xfs->xf_params.ab_elems[0],
+			    &(const struct c2_buf) C2_BUF_INITS("50")));
+	C2_ASSERT(c2_buf_eq(&xfs->xf_params.ab_elems[1],
+			    &(const struct c2_buf) C2_BUF_INITS("60")));
+	C2_ASSERT(c2_buf_eq(&xfs->xf_params.ab_elems[2],
+			    &(const struct c2_buf) C2_BUF_INITS("70")));
+
+	C2_ASSERT(xfs->xf_services.ab_count == 2);
+	C2_ASSERT(c2_buf_eq(&xfs->xf_services.ab_elems[0],
+			    &(const struct c2_buf) C2_BUF_INITS("mds")));
+	C2_ASSERT(c2_buf_eq(&xfs->xf_services.ab_elems[1],
+			    &(const struct c2_buf) C2_BUF_INITS("io")));
+}
+
+static void service_check1(const struct confx_object *conf)
+{
+	/* parse_service: ~id~ ~mds~ */
+	/* parse_service: ~svc_type~ ~1~ */
+	/* parse_service: ~endpoints~ ~["addr0"]~ */
+	/* parse_service: ~node~ ~N~ */
+
+	const struct c2_buf id = C2_BUF_INITS("mds");
+	const struct c2_buf node = C2_BUF_INITS("N");
+	const struct confx_service *xsrv = &conf->o_conf.u.u_service;
+
+	C2_ASSERT(c2_buf_eq(&conf->o_id, &id));
+
+	C2_ASSERT(conf->o_conf.u_type == C2_CO_SERVICE);
+	C2_ASSERT(xsrv->xs_type == 1);
+
+	C2_ASSERT(xsrv->xs_endpoints.ab_count == 1);
+	C2_ASSERT(c2_buf_eq(&xsrv->xs_endpoints.ab_elems[0],
+			    &(const struct c2_buf) C2_BUF_INITS("addr0")));
+
+	C2_ASSERT(c2_buf_eq(&xsrv->xs_node, &node));
+}
+
+static void service_check2(const struct confx_object *conf)
+{
+	/* parse_service: ~id~ ~io~ */
+	/* parse_service: ~svc_type~ ~2~ */
+	/* parse_service: ~endpoints~ ~["addr1","addr2","addr3"]~ */
+	/* parse_service: ~node~ ~N~ */
+
+	const struct c2_buf id = C2_BUF_INITS("io");
+	const struct c2_buf node = C2_BUF_INITS("N");
+	const struct confx_service *xsrv = &conf->o_conf.u.u_service;
+
+	C2_ASSERT(c2_buf_eq(&conf->o_id, &id));
+
+	C2_ASSERT(conf->o_conf.u_type == C2_CO_SERVICE);
+	C2_ASSERT(xsrv->xs_type == 2);
+
+	C2_ASSERT(xsrv->xs_endpoints.ab_count == 3);
+	C2_ASSERT(c2_buf_eq(&xsrv->xs_endpoints.ab_elems[0],
+			    &(const struct c2_buf) C2_BUF_INITS("addr1")));
+	C2_ASSERT(c2_buf_eq(&xsrv->xs_endpoints.ab_elems[1],
+			    &(const struct c2_buf) C2_BUF_INITS("addr2")));
+	C2_ASSERT(c2_buf_eq(&xsrv->xs_endpoints.ab_elems[2],
+			    &(const struct c2_buf) C2_BUF_INITS("addr3")));
+
+	C2_ASSERT(c2_buf_eq(&xsrv->xs_node, &node));
+}
+
+static void node_check(const struct confx_object *conf)
+{
+	/* parse_node: ~id~ ~N~ */
+	/* parse_node: ~memsize~ ~8000~ */
+	/* parse_node: ~nr_cpu~ ~2~ */
+	/* parse_node: ~last_state~ ~3~ */
+	/* parse_node: ~flags~ ~2~ */
+	/* parse_node: ~pool_id~ ~0~ */
+	/* parse_node: ~nics~ ~["nic0"]~ */
+	/* parse_node: ~sdevs~ ~["sdev0"]~ */
+
+	const struct c2_buf id = C2_BUF_INITS("N");
+	const struct confx_node *xnode = &conf->o_conf.u.u_node;
+
+	C2_ASSERT(c2_buf_eq(&conf->o_id, &id));
+
+	C2_ASSERT(conf->o_conf.u_type == C2_CO_NODE);
+	C2_ASSERT(xnode->xn_memsize == 8000);
+	C2_ASSERT(xnode->xn_nr_cpu == 2);
+	C2_ASSERT(xnode->xn_last_state == 3);
+	C2_ASSERT(xnode->xn_flags == 2);
+	C2_ASSERT(xnode->xn_pool_id == 0);
+
+	C2_ASSERT(xnode->xn_nics.ab_count == 1);
+	C2_ASSERT(c2_buf_eq(&xnode->xn_nics.ab_elems[0],
+			    &(const struct c2_buf) C2_BUF_INITS("nic0")));
+
+	C2_ASSERT(xnode->xn_sdevs.ab_count == 1);
+	C2_ASSERT(c2_buf_eq(&xnode->xn_sdevs.ab_elems[0],
+			    &(const struct c2_buf) C2_BUF_INITS("sdev0")));
+
+}
+
+static void nic_check(const struct confx_object *conf)
+{
+	/* parse_nic: ~id~ ~nic0~ */
+	/* parse_nic: ~iface_type~ ~5~ */
+	/* parse_nic: ~mtu~ ~8192~ */
+	/* parse_nic: ~speed~ ~10000~ */
+	/* parse_nic: ~filename~ ~ib0~ */
+	/* parse_nic: ~last_state~ ~3~ */
+
+	const struct c2_buf id = C2_BUF_INITS("nic0");
+	const struct c2_buf fn = C2_BUF_INITS("ib0");
+
+	C2_ASSERT(c2_buf_eq(&conf->o_id, &id));
+
+	C2_ASSERT(conf->o_conf.u_type == C2_CO_NIC);
+
+	C2_ASSERT(conf->o_conf.u.u_nic.xi_iface == 5);
+	C2_ASSERT(conf->o_conf.u.u_nic.xi_mtu == 8192);
+	C2_ASSERT(conf->o_conf.u.u_nic.xi_speed == 10000);
+	C2_ASSERT(c2_buf_eq(&conf->o_conf.u.u_nic.xi_filename, &fn));
+	C2_ASSERT(conf->o_conf.u.u_nic.xi_last_state == 3);
+}
+
+
+static void sdev_check(const struct confx_object *conf)
+{
+	/* parse_sdev: ~id~ ~sdev0~ */
+	/* parse_sdev: ~iface~ ~4~ */
+	/* parse_sdev: ~media~ ~1~ */
+	/* parse_sdev: ~size~ ~596000000000~ */
+	/* parse_sdev: ~last_state~ ~3~ */
+	/* parse_sdev: ~flags~ ~4~ */
+	/* parse_sdev: ~partitions~ ~["part0"]~ */
+	/* parse_sdev: ~filename~ ~/dev/sdev0~ */
+
+	const struct c2_buf id = C2_BUF_INITS("sdev0");
+	const struct c2_buf fn = C2_BUF_INITS("/dev/sdev0");
+	const struct confx_sdev *xsd = &conf->o_conf.u.u_sdev;
+
+	C2_ASSERT(c2_buf_eq(&conf->o_id, &id));
+
+	C2_ASSERT(conf->o_conf.u_type == C2_CO_SDEV);
+	C2_ASSERT(xsd->xd_iface == 4);
+	C2_ASSERT(xsd->xd_media == 1);
+	C2_ASSERT(xsd->xd_size == 596000000000);
+	C2_ASSERT(xsd->xd_last_state == 3);
+	C2_ASSERT(xsd->xd_flags == 4);
+	C2_ASSERT(c2_buf_eq(&xsd->xd_filename, &fn));
+
+	C2_ASSERT(xsd->xd_partitions.ab_count == 1);
+	C2_ASSERT(c2_buf_eq(&xsd->xd_partitions.ab_elems[0],
+			    &(const struct c2_buf) C2_BUF_INITS("part0")));
+
+}
+
+static void partition_check(const struct confx_object *conf)
+{
+	/* parse_partition: ~id~ ~part0~ */
+	/* parse_partition: ~start~ ~0~ */
+	/* parse_partition: ~size~ ~596000000000~ */
+	/* parse_partition: ~index~ ~0~ */
+	/* parse_partition: ~pa_type~ ~7~ */
+	/* parse_partition: ~filename~ ~sda1~ */
+
+	const struct c2_buf id = C2_BUF_INITS("part0");
+	const struct c2_buf fn = C2_BUF_INITS("sda1");
+
+	C2_ASSERT(c2_buf_eq(&conf->o_id, &id));
+
+	C2_ASSERT(conf->o_conf.u_type == C2_CO_PARTITION);
+	C2_ASSERT(conf->o_conf.u.u_partition.xa_start == 0);
+	C2_ASSERT(conf->o_conf.u.u_partition.xa_size == 596000000000);
+	C2_ASSERT(conf->o_conf.u.u_partition.xa_index == 0);
+	C2_ASSERT(conf->o_conf.u.u_partition.xa_type == 7);
+	C2_ASSERT(c2_buf_eq(&conf->o_conf.u.u_partition.xa_file, &fn));
+}
+
+int main(void)
+{
+	enum { KB = 1 << 10 };
+	char                buf[32*KB] = {0};
+	int                 n;
+	struct confx_object conf[100];
+
+	n = fread(buf, 1, sizeof buf, stdin);
+	if (n <= 0)
+		return 1;
+	buf[n] = '\0';
+
+	n = c2_conf_parse(buf, conf, ARRAY_SIZE(conf));
+	printf("entries: %d\n", n);
+
+	C2_ASSERT(n == 8);
+	profile_check(&conf[0]);
+	filesystem_check(&conf[1]);
+	service_check1(&conf[2]);
+	service_check2(&conf[3]);
+	node_check(&conf[4]);
+	nic_check(&conf[5]);
+	sdev_check(&conf[6]);
+	partition_check(&conf[7]);
+
+	c2_confx_fini(conf, n);
+
+	return 0;
+}
diff --git a/configure.ac b/configure.ac
index 5dd56eb..0ed0d0c 100644
--- a/configure.ac
+++ b/configure.ac
@@ -671,6 +671,7 @@ AC_CONFIG_FILES([
                  cob/ut/Makefile
                  colibri/Makefile
                  colibri/ut/Makefile
+                 conf/Makefile
                  conf/ut/Makefile
                  console/Makefile
                  console/bin/Makefile
diff --git a/lib/Makefile.am b/lib/Makefile.am
index 49edae6..96acbff 100644
--- a/lib/Makefile.am
+++ b/lib/Makefile.am
@@ -98,6 +98,7 @@ libc2_la_SOURCES     = \
                        user_space/cdefs.h \
                        user_space/finject_init.c \
                        user_space/memory.c \
+                       user_space/umisc.c \
                        user_space/mutex.h \
                        user_space/processor.c \
                        user_space/rwlock.c \
@@ -127,6 +128,7 @@ EXTRA_DIST             = \
                          linux_kernel/cdefs.h \
                          linux_kernel/finject_init.c \
                          linux_kernel/kcookie.c \
+                         linux_kernel/kmisc.c \
                          linux_kernel/kthread.c \
                          linux_kernel/ktrace.c \
                          linux_kernel/ktime.c \
diff --git a/lib/linux_kernel/kmisc.c b/lib/linux_kernel/kmisc.c
new file mode 100644
index 0000000..84180f5
--- /dev/null
+++ b/lib/linux_kernel/kmisc.c
@@ -0,0 +1,44 @@
+/* -*- C -*- */
+/*
+ * COPYRIGHT 2012 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: Anatoliy Bilenko <Anatoliy_Bilenko@xyratex.com>
+ * Original creation date: 03/09/2012
+ */
+
+#include "lib/misc.h"
+#include <linux/cpu.h> /* simple_strtoull, simple_strtoul */
+
+uint64_t c2_strtou64(const char *str, char **endptr, int base)
+{
+	return simple_strtoull(str, endptr, base);
+}
+C2_EXPORTED(c2_strtou64);
+
+uint32_t c2_strtou32(const char *str, char **endptr, int base)
+{
+	return simple_strtoul(str, endptr, base);
+}
+C2_EXPORTED(c2_strtou32);
+
+/*
+ *  Local variables:
+ *  c-indentation-style: "K&R"
+ *  c-basic-offset: 8
+ *  tab-width: 8
+ *  fill-column: 80
+ *  scroll-step: 1
+ *  End:
+ */
diff --git a/lib/misc.h b/lib/misc.h
index 29b240f..1a95397 100644
--- a/lib/misc.h
+++ b/lib/misc.h
@@ -116,6 +116,12 @@ uint64_t c2_round_down(uint64_t val, uint64_t size);
 
 const char *c2_bool_to_str(bool b);
 
+/* strtoull for user- and kernel-space */
+uint64_t c2_strtou64(const char *str, char **endptr, int base);
+
+/* strtoul for user- and kernel-space */
+uint32_t c2_strtou32(const char *str, char **endptr, int base);
+
 /* __COLIBRI_LIB_MISC_H__ */
 #endif
 
diff --git a/lib/user_space/umisc.c b/lib/user_space/umisc.c
new file mode 100644
index 0000000..ca1b0c9
--- /dev/null
+++ b/lib/user_space/umisc.c
@@ -0,0 +1,42 @@
+/* -*- C -*- */
+/*
+ * COPYRIGHT 2012 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: Anatoliy Bilenko <Anatoliy_Bilenko@xyratex.com>
+ * Original creation date: 03/09/2012
+ */
+
+#include "lib/misc.h"
+#include <stdlib.h>		/* strtoull, strtoul */
+
+uint64_t c2_strtou64(const char *str, char **endptr, int base)
+{
+	return strtoull(str, endptr, base);
+}
+
+uint32_t c2_strtou32(const char *str, char **endptr, int base)
+{
+	return strtoul(str, endptr, base);
+}
+
+/*
+ *  Local variables:
+ *  c-indentation-style: "K&R"
+ *  c-basic-offset: 8
+ *  tab-width: 8
+ *  fill-column: 80
+ *  scroll-step: 1
+ *  End:
+ */
-- 
1.8.3.2

