From 99817a778e95568e60dd50691da90276eb986422 Mon Sep 17 00:00:00 2001
From: "Valery V. Vorotyntsev" <valery_vorotyntsev@xyratex.com>
Date: Mon, 14 May 2012 16:12:41 +0300
Subject: [PATCH 176/311] protect c2_confc_{init,fini}() with an "existential"
 lock

It is invalid to finalize the ->cc_lock mutex, because another thread
might be still using it.

- Add c2_mutex argument to c2_confc_init().
- Change c2_confc::cc_lock to be a pointer.
- confc.c: Add confc_invariant().
- confc.c: Rename cache_lock() to confc_lock().

LogD: #1194
RB: r/714
---
 conf/confc.c   | 70 +++++++++++++++++++++++++++++++---------------------------
 conf/confc.h   | 31 +++++++++++++++++---------
 conf/obj_ops.h |  4 ++--
 3 files changed, 60 insertions(+), 45 deletions(-)

diff --git a/conf/confc.c b/conf/confc.c
index 9c431e7..f227909 100644
--- a/conf/confc.c
+++ b/conf/confc.c
@@ -173,9 +173,9 @@
  * <hr> <!------------------------------------------------------------>
  * @section confc-lspec-walk Walking the DAG
  *
- * path_walk() begins with locking the cache (c2_confc::cc_lock) and
- * unlocks the cache before returning.  The function does two things,
- * represented by subroutines:
+ * path_walk() begins with locking the confc cache (c2_confc::cc_lock);
+ * it unlocks the cache before returning.  The function does two
+ * things, represented by subroutines:
  *   -#
  *      walk() "moves" along the DAG of cached configuration
  *      objects. It starts at the configuration object the path
@@ -244,11 +244,11 @@
  * running at any given time.  Such synchronization of state
  * transitions is achieved by using c2_sm_group (c2_confc::cc_group).
  *
- * A function modifying the cache (adding new object, enriching
- * existing one, or changing object's reference counter) must hold
- * cache lock (c2_confc::cc_lock).
+ * Modifications to c2_confc instance and confc cache are protected by
+ * a confc lock --- c2_mutex pointed to by c2_confc::cc_lock. The
+ * mutex is owned by an external entity (e.g., the application).
  *
- * If a function needs both locks -- group lock and cache lock -- for
+ * If a function needs both locks -- group lock and confc lock -- for
  * its operation, group lock must be acquired first. (Note, that the
  * "function" here cannot be something invoked from an AST callback,
  * because otherwise it would deadlock on the group mutex.)
@@ -273,10 +273,10 @@ static inline struct c2_mutex * group_lock(struct c2_confc_ctx *ctx)
 	return &ctx->fc_client->cc_group->s_lock;
 }
 
-static inline struct c2_mutex * cache_lock(struct c2_confc_ctx *ctx)
+static inline struct c2_mutex * confc_lock(struct c2_confc_ctx *ctx)
 {
 	C2_PRE(ctx_invariant(ctx));
-	return &ctx->fc_client->cc_lock;
+	return ctx->fc_client->cc_lock;
 }
 
 static struct c2_confc_ctx * mach_to_ctx(struct c2_sm *mach)
@@ -487,7 +487,7 @@ static int act(struct c2_confc_ctx *cx, const struct walk_ctx *wx,
 	C2_PRE(ctx_invariant(cx));
 	C2_PRE(walk_ctx_invariant(wx));
 	C2_PRE(c2_mutex_is_locked(group_lock(cx)));
-	C2_PRE(c2_mutex_is_locked(cache_lock(cx)));
+	C2_PRE(c2_mutex_is_locked(confc_lock(cx)));
 
 	switch (status) {
 	case C2_CS_READY:
@@ -532,7 +532,7 @@ static int act(struct c2_confc_ctx *cx, const struct walk_ctx *wx,
 		C2_IMPOSSIBLE("invalid object status");
 	}
 
-	C2_POST(c2_mutex_is_locked(cache_lock(cx)));
+	C2_POST(c2_mutex_is_locked(confc_lock(cx)));
 	C2_POST(c2_mutex_is_locked(group_lock(cx)));
 	return status;
 }
@@ -575,7 +575,7 @@ static int path_walk(struct c2_confc_ctx *ctx)
 	wx.w_obj  = ctx->fc_origin;
 	wx.w_path = ctx->fc_path;
 
-	c2_mutex_lock(cache_lock(ctx));
+	c2_mutex_lock(confc_lock(ctx));
 	ret = walk(&wx);
 	/*
 	 * XXX `confc offline' workaround: all the needed
@@ -585,34 +585,41 @@ static int path_walk(struct c2_confc_ctx *ctx)
 	if (ret >= 0)
 		ret = act(ctx, &wx, ret);
 
-	c2_mutex_unlock(cache_lock(ctx));
+	c2_mutex_unlock(confc_lock(ctx));
 	C2_POST(c2_mutex_is_locked(group_lock(ctx)));
 	return ret;
 }
 
+static bool confc_invariant(const struct c2_confc *client)
+{
+	/* XXX add more checks */
+	return equi(client->cc_root == NULL, client->cc_group == NULL) &&
+		equi(client->cc_root == NULL, client->cc_lock == NULL);
+}
+
 static bool confc_is_initialized(const struct c2_confc *client)
 {
-	C2_PRE(equi(client->cc_root != NULL, client->cc_group));
+	C2_PRE(confc_invariant(client));
 	return client->cc_root != NULL;
 }
 
 int c2_confc_init(struct c2_confc *client, const char *confd_addr,
-		  const char *profile, struct c2_sm_group *sm_group)
+		  const char *profile, struct c2_sm_group *sm_group,
+		  struct c2_mutex *lock)
 {
 	/*
 	 * int rc;
 	 * struct c2_conf_obj *root;
 	 *
+	 * C2_PRE(c2_mutex_is_locked(lock));
 	 * C2_PRE(!confc_is_initialized(client));
 	 * C2_PRE(confd_addr != NULL && *confd_addr != 0);
 	 * C2_PRE(profile != NULL && *profile != 0);
 	 * C2_PRE(sm_group != NULL);
 	 *
 	 * c2_mutex_lock(&sm_group->s_lock);
-	 * c2_mutex_init(&client->cc_lock);
-	 * c2_mutex_lock(&client->cc_lock);
-	 *
 	 * client->cc_group = sm_group;
+	 * client->cc_lock = lock;
 	 *
 	 * c2_conf_map_init(&client->cc_registry);
 	 * root = c2_conf_obj_new(C2_CO_PROFILE, &(const struct c2_conf_buf)
@@ -622,9 +629,9 @@ int c2_confc_init(struct c2_confc *client, const char *confd_addr,
 	 *
 	 * cache_preload(client, confd_addr);
 	 *
-	 * C2_POST(equi(rc == 0, confc_is_initialized(client)));
-	 * c2_mutex_unlock(&client->cc_lock);
 	 * c2_mutex_unlock(&sm_group->s_lock);
+	 * C2_POST(equi(rc == 0, confc_is_initialized(client) &&
+	 *              client->cc_lock == lock));
 	 * return rc;
 	 */
 	XXX;
@@ -633,10 +640,10 @@ int c2_confc_init(struct c2_confc *client, const char *confd_addr,
 void c2_confc_fini(struct c2_confc *client)
 {
 	/*
+	 * C2_PRE(c2_mutex_is_locked(client->cc_lock));
 	 * C2_PRE(confc_is_initialized(client));
 	 *
 	 * c2_mutex_lock(&client->cc_group->s_lock);
-	 * c2_mutex_lock(&client->cc_lock);
 	 *
 	 * for (obj in client->cc_registry) {
 	 *     C2_ASSERT(obj->co_nrefs == 0 &&
@@ -646,10 +653,9 @@ void c2_confc_fini(struct c2_confc *client)
 	 * c2_confc_map_fini(&client->cc_registry);
 	 * client->cc_root = NULL;
 	 *
-	 * c2_mutex_unlock(&client->cc_lock);
-	 * c2_mutex_fini(&client->cc_lock);
 	 * c2_mutex_unlock(&client->cc_group->s_lock);
 	 * client->cc_group = NULL;
+	 * client->cc_lock = NULL;
 	 *
 	 * C2_POST(!confc_is_initialized(client));
 	 */
@@ -712,11 +718,11 @@ void c2_confc_close(void *obj, struct c2_confc *client)
 {
 	struct c2_conf_obj *x = obj;
 
-	c2_mutex_lock(&client->cc_lock);
+	c2_mutex_lock(client->cc_lock);
 	C2_CNT_DEC(x->co_nrefs);
 	if (x->co_nrefs == 0)
 		c2_chan_broadcast(&x->co_chan);
-	c2_mutex_unlock(&client->cc_lock);
+	c2_mutex_unlock(client->cc_lock);
 }
 
 /** Collection of configuration objects. */
@@ -756,7 +762,7 @@ request_fill(struct c2_conf_ctx *ctx, const struct c2_conf_obj *origin,
 
 	C2_PRE(ctx_invariant(ctx));
 	C2_PRE(c2_mutex_is_locked(group_lock(ctx)));
-	C2_PRE(c2_mutex_is_locked(cache_lock(ctx)));
+	C2_PRE(c2_mutex_is_locked(confc_lock(ctx)));
 
 	req->f_origin.oi_objtype = origin->co_type;
 	req->f_origin.oi_objkey = origin->co_key;
@@ -917,7 +923,7 @@ static bool on_object_updated(struct c2_clink *link)
 		container_of(link->cl_group, struct c2_confc_ctx, fc_clink);
 
 	C2_PRE(ctx_invariant(ctx));
-	C2_PRE(c2_mutex_is_locked(cache_lock(ctx)));
+	C2_PRE(c2_mutex_is_locked(confc_lock(ctx)));
 
 	for (i = 0; i < ctx->fc_nr_extra; ++i)
 		c2_clink_del(ctx->fc_extra + i);
@@ -1011,7 +1017,7 @@ static int cache_add(struct c2_conf_map *cache, const struct confx_object *src)
 	 * struct c2_conf_obj *obj;
 	 * int                 ret;
 	 *
-	 * C2_PRE(c2_mutex_is_locked(&registry_to_client(cache)->cc_lock));
+	 * C2_PRE(c2_mutex_is_locked(registry_to_client(cache)->cc_lock));
 	 *
 	 * obj = c2_conf_obj_new(src->o_val.ov_type, &src->o_key);
 	 * if (obj == NULL)
@@ -1035,7 +1041,7 @@ static int object_enrich(struct c2_conf_obj *dest,
 	 * int ret;
 	 *
 	 * C2_PRE(dest->co_type == src->fo_val.v_type);
-	 * C2_PRE(c2_mutex_is_locked(&registry_to_client(cache)->cc_lock));
+	 * C2_PRE(c2_mutex_is_locked(registry_to_client(cache)->cc_lock));
 	 *
 	 * if (c2_conf_obj_mismatch(dest, src)) {
 	 *     C2_ADDB_ADD(report inconsistency);
@@ -1071,7 +1077,7 @@ cache_grow(struct c2_conf_map *cache, const struct c2_conf_fetch_resp *resp)
 	 * C2_PRE(resp->fr_rc == 0);
 	 * C2_PRE(c2_mutex_is_locked(&cli->cc_group->s_lock));
 	 *
-	 * c2_mutex_lock(&cli->cc_lock);
+	 * c2_mutex_lock(cli->cc_lock);
 	 *
 	 * for (fetched in resp->fr_data) {
 	 *     if (fetched->o_key.cb_size == 0 ||
@@ -1092,7 +1098,7 @@ cache_grow(struct c2_conf_map *cache, const struct c2_conf_fetch_resp *resp)
 	 *         break;
 	 * }
 	 *
-	 * c2_mutex_unlock(&cli->cc_lock);
+	 * c2_mutex_unlock(cli->cc_lock);
 	 * return ret;
 	 */
 	XXX;
@@ -1106,7 +1112,7 @@ static int cache_preload(struct c2_confc *client, const char *conf_str)
 	 * int rc;
 	 * int i;
 	 *
-	 * C2_PRE(c2_mutex_is_locked(&client->cc_lock));
+	 * C2_PRE(c2_mutex_is_locked(client->cc_lock));
 	 *
 	 * rc = c2_conf_parse(conf_str, objs, ARRAY_SIZE(objs));
 	 * for (i = rc - 1; i >= 0; --i) {
diff --git a/conf/confc.h b/conf/confc.h
index a3d39b0..b05513c 100644
--- a/conf/confc.h
+++ b/conf/confc.h
@@ -110,17 +110,23 @@
  * #include "conf/confc.h"
  *
  * struct c2_sm_group *group = ...;
- * struct c2_confc confc;
+ * struct c2_mutex    *confc_lock = ...;
+ * struct c2_confc     confc;
  *
  * startup(...) {
- *     rc = c2_confc_init(&confc, "profile-name", "confd-endpoint", group);
+ *     c2_mutex_lock(confc_lock);
+ *     rc = c2_confc_init(&confc, "profile-name", "confd-endpoint", group,
+ *                        confc_lock);
+ *     c2_mutex_unlock(confc_lock);
  *     ...
  * }
  *
  * ... Access configuration objects using confc interfaces. ...
  *
  * shutdown(...) {
+ *     c2_mutex_lock(confc_lock);
  *     c2_confc_fini(confc);
+ *     c2_mutex_unlock(confc_lock);
  * }
  * @endcode
  *
@@ -319,12 +325,13 @@ struct c2_confc {
 	/** Serializes confc state machines. */
 	struct c2_sm_group *cc_group;
 	/**
-	 * Cache lock.
+	 * Confc lock (aka cache lock).
 	 *
 	 * Protects this structure and the DAG of cached configuration
-	 * objects from concurrent writes.
+	 * objects from concurrent modifications.  The mutex itself is
+	 * owned by an external entity (e.g., the application).
 	 */
-	struct c2_mutex     cc_lock;
+	struct c2_mutex    *cc_lock;
 };
 
 /**
@@ -336,16 +343,19 @@ struct c2_confc {
  * @param profile     Name of profile used by this confc.
  * @param sm_group    State machine group to be associated with confc
  *                    configuration cache.
+ * @param lock        A mutex that will protect this c2_confc instance and
+ *                    its configuration cache from concurrent modifications.
  *
  * @note  Until confd service is implemented, `confd_addr' is a string
  *        with configuration data (see @ref conf-fspec-preload). This
  *        string is used to pre-load confc cache.
  *
- * @pre   confc cache is not initiated
- * @post  equi(retval == 0, confc cache is initiated)
+ * @pre   c2_mutex_is_locked(lock) && client->cc_lock == NULL
+ * @post  equi(retval == 0, client->cc_lock == lock)
  */
 int c2_confc_init(struct c2_confc *client, const char *confd_addr,
-		  const char *profile, struct c2_sm_group *sm_group);
+		  const char *profile, struct c2_sm_group *sm_group,
+		  struct c2_mutex *lock);
 
 /**
  * Finalises configuration client. Destroys configuration cache,
@@ -358,9 +368,8 @@ int c2_confc_init(struct c2_confc *client, const char *confd_addr,
  *       c2_confc_ctx has been passed to c2_confc_{,dir}open() and its
  *       ->fc_complete channel has not been signaled yet.
  *
- * @pre   confc cache is initiated
- * @pre   There are no opened (pinned) configuration objects.
- * @post  confc cache is not initiated
+ * @pre  There are no opened (pinned) configuration objects.
+ * @pre  c2_mutex_is_locked(client->cc_lock)
  */
 void c2_confc_fini(struct c2_confc *client);
 
diff --git a/conf/obj_ops.h b/conf/obj_ops.h
index 851b2ef..474e801 100644
--- a/conf/obj_ops.h
+++ b/conf/obj_ops.h
@@ -59,12 +59,12 @@ bool c2_conf_obj_mismatch(const struct c2_conf_obj *cached,
  * @param src    Object to read the data from.
  * @param cache  Registry of cached configuration objects.
  *
- * @pre   c2_mutex_is_locked(&c2_conf_map_to_cache(registry)->cc_lock)
+ * @pre   c2_mutex_is_locked(c2_conf_map_to_cache(registry)->cc_lock)
  * @pre   dest->co_status != C2_CS_READY
  * @pre   dest->co_type == src->o_val.ov_type
  * @pre   c2_conf_buf_eq(dest->co_key, src->o_key)
  * @post  dest->co_status != C2_CS_READY  // the status is set by the caller
- * @post  c2_mutex_is_locked(&c2_conf_map_to_cache(registry)->cc_lock)
+ * @post  c2_mutex_is_locked(c2_conf_map_to_cache(registry)->cc_lock)
  */
 int c2_conf_obj_fill(struct c2_conf_obj *dest, const struct confx_object *src,
 		     struct c2_conf_map *cache);
-- 
1.8.3.2

