From d0ad7179c8e36a436dfa24ee6fd5ea504d2186ea Mon Sep 17 00:00:00 2001
From: "Valery V. Vorotyntsev" <valery_vorotyntsev@xyratex.com>
Date: Fri, 30 Mar 2012 15:25:10 +0300
Subject: [PATCH 105/311] add forgotten c2_clink_attach() calls

+ walk(), act(): add some useful assertions
+ act() seems to be more readable with `switch' statement
+ extra_clinks_create(): new function
+ rename on_object_update() to on_object_updated()
---
 conf/confc.c | 57 +++++++++++++++++++++++++++++++++++++++++++--------------
 1 file changed, 43 insertions(+), 14 deletions(-)

diff --git a/conf/confc.c b/conf/confc.c
index b244b18..dfef829 100644
--- a/conf/confc.c
+++ b/conf/confc.c
@@ -330,7 +330,7 @@
  *   All this function does is c2_rpc_post()ing c2_confc_ctx::fc_fop.
  *
  * - A state machine in S_WAIT_STATUS state waits for
- *   c2_confc_ctx::fc_clink to be signaled.  on_object_update()
+ *   c2_confc_ctx::fc_clink to be signaled.  on_object_updated()
  *   callback, associated with the clink, posts an AST that will move
  *   the state machine to S_CHECK state.
  *
@@ -545,6 +545,21 @@ static int walk(struct walk_ctx *wx)
 	}
 
 	C2_POST(walk_ctx_invariant(wx));
+	C2_POST(ergo(wx->w_atdir && ret == C2_CS_LOADING, wx->w_nload > 0));
+	return ret;
+}
+
+/** Allocate `n' clinks and attach them to the `group'. */
+static struct c2_clink *
+extra_clinks_create(struct c2_clink *group, uint32_t n)
+{
+	struct c2_clink *ret;
+	uint32_t         i;
+	C2_PRE(n > 0);
+	C2_ALLOC_ARR(ret, n);
+	if (ret != NULL)
+		for (i = 0; i < n; ++i)
+			c2_clink_attach(ret + i, group, on_object_updated);
 	return ret;
 }
 
@@ -555,32 +570,46 @@ static int act(struct c2_confc_ctx *cx, const struct walk_ctx *wx,
 	C2_PRE(c2_mutex_is_locked(cache_lock(cx)));
 	C2_PRE(walk_ctx_invariant(wx));
 
-	if (status == C2_CS_READY) {
-		cx->fc_result = wx->w_atdir ? XXX_dir_allocate() : wx->w_obj;
-		if (cx->fc_result == NULL)
-			return -ENOMEM;
-		C2_CNT_INC(parent->co_nrefs);
-	} else if (status == C2_CS_MISSING) {
+	switch (status) {
+	case C2_CS_READY:
+		if (wx->w_atdir) {
+			C2_ASSERT(wx->w_nload == 0);
+			cx->fc_result = XXX_dir_allocate();
+			if (cx->fc_result == NULL)
+				return -ENOMEM;
+		} else {
+			cx->fc_result = wx->w_obj;
+		}
+		C2_CNT_INC(wx->w_obj->co_nrefs);
+		break;
+	case C2_CS_MISSING:
 		request_fill(&cx->fc_req, wx->w_obj, wx->w_path);
-		if (wx->w_atdir)
+		if (wx->w_atdir) {
+			/* ensure list_status() did its job properly */
 			C2_ASSERT(XXX /* directory has 0 C2_CS_MISSING objects
 				       * and > 0 C2_CS_LOADING objects */);
-		else
+		} else {
+			C2_ASSERT(wx->w_obj->co_status == C2_CS_MISSING);
 			wx->w_obj->co_status = C2_CS_LOADING;
-	} else if (status == C2_CS_LOADING) {
+		}
+		break;
+	case C2_CS_LOADING:
 		if (wx->w_atdir) {
 			C2_ASSERT(wx->w_nload > 0);
 			if (wx->w_nload > 1) {
-				C2_ALLOC_ARR(cx->fc_extra, wx->w_nload - 1);
+				cx->fc_extra = extra_clinks_create(
+					&cx->fc_clink, wx->w_nload - 1);
 				if (cx->fc_extra == NULL)
 					return -ENOMEM;
 				cx->fc_nr_extra = wx->w_nload - 1;
 			}
 			XXX; /* scan directory, calling c2_clink_add() */
 		} else {
+			C2_ASSERT(wx->w_obj->co_status == C2_CS_LOADING);
 			c2_clink_add(&wx->w_obj->co_chan, &cx->fc_clink);
 		}
-	} else {
+		break;
+	default:
 		C2_IMPOSSIBLE("invalid object status");
 	}
 
@@ -957,7 +986,7 @@ static void on_replied(struct c2_rpc_item *item)
 }
 
 /** Handles `object loading completed' and `object unpinned' events. */
-static bool on_object_update(struct c2_clink *link)
+static bool on_object_updated(struct c2_clink *link)
 {
 	size_t i;
 	struct c2_confc_ctx *ctx =
@@ -1167,7 +1196,7 @@ void c2_confc_ctx_init(struct c2_confc_ctx *ctx, struct c2_confc *client)
 	c2_sm_init(&ctx->fc_mach, &confc_states_conf, S_INITIAL,
 		   confc->cc_group, XXX /* *c2_addb_ctx */);
 	c2_chan_init(&ctx->fc_complete);
-	c2_clink_init(&ctx->fc_clink, on_object_update);
+	c2_clink_init(&ctx->fc_clink, on_object_updated);
 	ctx->fc_extra = NULL;
 	ctx->fc_nr_extra = 0;
 
-- 
1.8.3.2

