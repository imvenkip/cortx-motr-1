From f4780614aa5808ce28916fb8bedda9066eac0eed Mon Sep 17 00:00:00 2001
From: Anatoliy Bilenko <anatoliy_bilenko@xyratex.com>
Date: Thu, 19 Jul 2012 23:42:12 +0300
Subject: [PATCH 258/311] Updated DLD of `Configuration server Confd':

     - Minor fixes.
---
 conf/confd.c | 72 +++++++++++++++++++-----------------------------------------
 1 file changed, 23 insertions(+), 49 deletions(-)

diff --git a/conf/confd.c b/conf/confd.c
index 36ffaac..130b750 100644
--- a/conf/confd.c
+++ b/conf/confd.c
@@ -94,7 +94,7 @@
  * @code
  * struct init_fini_call subsystem[] = {
  *      ...
- *	{ &c2_confd_service_register, &c2_confd_service_unregister,
+ *	{ &c2_confd_global_init, &c2_confd_global_fini,
  *	  "confd_service" },
  *      ...
  * };
@@ -212,17 +212,10 @@
  *      edge [fontsize=9];
  *      F_INITIAL [style=filled, fillcolor=lightgrey];
  *      F_SERIALISE;
- *      F_REQ_RDLK;
  *      F_TERMINATE [style=filled, fillcolor=lightgrey];
  *      F_FAILURE [style=filled, fillcolor=lightgrey];
  *
- *      F_INITIAL -> F_REQ_RDLK [label=
- *      "c2_conf_fetch-FOP is arrived"];
- *
- *      F_REQ_RDLK -> F_REQ_RDLK [label=
- *      "!c2_long_read_lock(c2_confd::c_cache::ca_rwlock)"];
- *
- *      F_REQ_RDLK -> F_SERIALISE [label=
+ *      F_INITIAL -> F_SERIALISE [label=
  *      "c2_long_read_lock(c2_confd::c_cache::ca_rwlock)"];
  *
  *      F_SERIALISE -> F_TERMINATE [label = "success"];
@@ -233,11 +226,7 @@
  * - F_INITIAL
  *   In this phase, incoming FOM/FOP-related structures are being
  *   initialized and FOP-processing preconditions are being
- *   checked. Then fetch_next_state() is called and FOM is transited
- *   into F_REQ_RDLK.
- *
- * - F_REQ_RDLK:
- *   In this phase, an attempt is made to obtain a read lock
+ *   checked. Then, an attempt is made to obtain a read lock
  *   c2_confd::c_cache::ca_rwlock. When it's obtained then
  *   c2_long_lock logic transits FOM back into F_SERIALISE.
  *
@@ -275,17 +264,10 @@
  *      edge [fontsize=9];
  *      U_INITIAL [style=filled, fillcolor=lightgrey];
  *      U_UPDATE;
- *      U_REQ_WRLK;
  *      U_TERMINATE [style=filled, fillcolor=lightgrey];
  *      U_FAILURE [style=filled, fillcolor=lightgrey];
  *
- *      U_INITIAL -> U_REQ_WRLK [label=
- *      "c2_conf_update-FOP is arrived"];
- *
- *      U_REQ_WRLK -> U_REQ_WRLK [label=
- *      "!c2_long_write_lock(c2_confd::c_cache::ca_rwlock)"];
- *
- *      U_REQ_WRLK -> U_UPDATE [label=
+ *      U_INITIAL -> U_UPDATE [label=
  *      "c2_long_write_lock(c2_confd::c_cache::ca_rwlock)"];
  *
  *      U_UPDATE -> U_TERMINATE [label = "success"];
@@ -293,14 +275,10 @@
  *  }
  * @enddot
  *
- * - U_INITIAL
+ * - U_INITIAL:
  *   In this phase, incoming FOM/FOP-related structures are being
  *   initialized and FOP-processing preconditions are being
- *   checked. Then fetch_next_state() is called and FOM is transited
- *   into F_REQ_WRLK.
- *
- * - U_REQ_WRLK:
- *   In this phase, an attempt is made to obtain a write lock
+ *   checked. Then, an attempt is made to obtain a write lock
  *   c2_confd::c_cache::ca_rwlock. When it's obtained then
  *   c2_long_lock logic transits FOM back into U_UPDATE.
  *
@@ -350,21 +328,22 @@
  * obtained.
  *
  * The following code example shows how to perform a transition from
- * F_REQ_RDLK to F_SERIALISE and obtain a lock:
+ * F_INITIAL to F_SERIALISE and obtain a lock:
  * @code
  * static int fom_fetch_state(struct c2_fom *fom)
  * {
  *      //...
  *      struct c2_long_lock_link *link;
- * 	if (fom->fo_phase == F_REQ_RDLK) {
- * 		// initialise things
+ *	if (fom->fo_phase == F_INITIAL) {
+ *		// Initialise things.
+ *		// ...
  *		// Retreive long lock link from derived FOM object: link = ...;
- * 		// and acquire the lock
- * 		return C2_FOM_LONG_LOCK_RETURN(c2_long_read_lock(lock, 
- * 								 link, 
- * 								 F_SERIALISE));
- * 	}
- * 	//...
+ *		// and acquire the lock
+ *		return C2_FOM_LONG_LOCK_RETURN(c2_long_read_lock(lock,
+ *								 link,
+ *								 F_SERIALISE));
+ *	}
+ *	//...
  * }
  * @endcode
  * @see fom-longlock <!-- @todo fom-longlock has to be defined in future -->
@@ -396,10 +375,9 @@
  * <hr> <!------------------------------------------------------------->
  * @subsection confd-lspec-numa NUMA Optimizations
  *
- * In cases, when there are multiple request handlers, for example,
- * for different networks, several confd instances should be created,
- * one per each request handler. Each confd instance has its own copy
- * of pre-loaded configuration data-base
+ * Multiple confd instances can run in the system, but no more than
+ * one per request handler. Each confd has its own data-base back-end
+ * and its own pre-loaded copy of data-base in memory.
  *
  * <hr> <!------------------------------------------------------------->
  * @section confd-ut Unit Tests
@@ -458,7 +436,6 @@
 enum c2_confd_fetch_status {
 	F_INITIAL = FOPH_NR + 1,
 	F_SERIALISE,
-	F_REQ_RDLK,
 	F_TERMINATE,
 	F_FAILURE
 };
@@ -469,8 +446,6 @@ enum c2_confd_fetch_status {
 enum c2_confd_update_status {
 	U_INITIAL = FOPH_NR + 1,
 	U_UPDATE,
-	U_REQ_WRLK,
-	U_WORK,
 	U_TERMINATE,
 	U_FAILURE
 };
@@ -540,19 +515,18 @@ static int confd_service_fop_init(void)
 }
 
 /**
- * Registers Confd service with colibri node.
- * Colibri setup calls this function.
+ * Confd service initialisation function.
  */
-int c2_confd_service_register(void)
+int c2_confd_global_init(void)
 {
         c2_reqh_service_type_register(&c2_confd_service_type);
         return c2_confd_service_fop_init();
 }
 
 /**
- * Unregisters Confd service from colibri node.
+ * Confd service finalisation function.
  */
-void c2_confd_service_unregister(void)
+void c2_confd_global_fini(void)
 {
         c2_reqh_service_type_unregister(&c2_confd_service_type);
 	c2_confd_service_fop_fini();
-- 
1.8.3.2

