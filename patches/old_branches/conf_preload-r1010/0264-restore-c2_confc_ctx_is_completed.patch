From 24398fdd92252555f8c01d4d4f9d0876584d9ce4 Mon Sep 17 00:00:00 2001
From: "Valery V. Vorotyntsev" <valery_vorotyntsev@xyratex.com>
Date: Tue, 24 Jul 2012 20:35:13 +0300
Subject: [PATCH 264/311] restore c2_confc_ctx_is_completed()

+ Change return codes of c2_confc_readdir(). Use enum for better
  readability.
+ confc.c (ctx_invariant): Check return code (c2_sm::sm_rc) in
  final (S_TERMINAL and S_FAILURE) states.
+ confc.c: Implement c2_confc_ctx_result().

LogD #530.
RB: r/865/diff/6/?file=24469#file24469line204
---
 conf/confc.c |  41 ++++++++++-------
 conf/confc.h | 142 ++++++++++++++++++++++++++++++++++-------------------------
 2 files changed, 105 insertions(+), 78 deletions(-)

diff --git a/conf/confc.c b/conf/confc.c
index 0941c89..bbcab25 100644
--- a/conf/confc.c
+++ b/conf/confc.c
@@ -365,13 +365,16 @@ C2_BOB_DEFINE(static, &c2_confc_ctx_bob, c2_confc_ctx);
 static bool ctx_invariant(const struct c2_confc_ctx *ctx)
 {
 	const struct c2_rpc_item *item = &ctx->fc_fop.f_item;
+	const struct c2_sm       *mach = &ctx->fc_mach;
 
 	return c2_confc_ctx_bob_check(ctx) && confc_invariant(ctx->fc_confc) &&
 		item->ri_type == &request_item_type &&
 		item->ri_ops != NULL &&
 		item->ri_ops->rio_replied == on_replied &&
 		ctx->fc_clink.cl_cb == on_object_updated &&
-		c2_fop_data(ctx->fc_fop) == &ctx->fc_req;
+		c2_fop_data(ctx->fc_fop) == &ctx->fc_req &&
+		ergo(mach->sm_state == S_TERMINAL, mach->sm_rc == 0) &&
+		ergo(mach->sm_state == S_FAILURE, mach->sm_rc < 0);
 }
 
 void c2_confc_ctx_init(struct c2_confc_ctx *ctx, struct c2_confc *confc)
@@ -414,25 +417,28 @@ void c2_confc_ctx_fini(struct c2_confc_ctx *ctx)
 	group_unlock(confc);
 }
 
-struct c2_conf_obj *c2_confc_ctx_result(struct c2_confc_ctx *ctx)
+bool c2_confc_ctx_is_completed(const struct c2_confc_ctx *ctx)
 {
-	XXX;
+	C2_PRE(ctx_invariant(ctx));
+	return C2_IN(ctx->fc_mach.sm_state, (S_TERMINAL, S_FAILURE));
 }
 
 int32_t c2_confc_ctx_error(const struct c2_confc_ctx *ctx)
 {
+	C2_PRE(c2_confc_ctx_is_completed(ctx));
+	return ctx->fc_mach.sm_rc;
+}
+
+struct c2_conf_obj *c2_confc_ctx_result(struct c2_confc_ctx *ctx)
+{
+	struct c2_conf_obj *res = ctx->fc_result;
+
 	C2_PRE(ctx_invariant(ctx));
+	C2_PRE(ctx->fc_mach.sm_state == S_TERMINAL);
+	C2_PRE(res != NULL);
 
-	switch (ctx->fc_mach.sm_state) {
-	case S_FAILURE:
-		C2_ASSERT(ctx->fc_mach.sm_rc < 0);
-		return ctx->fc_mach.sm_rc;
-	case S_TERMINAL:
-		return 0;
-	default:
-		return EINPROGRESS; /* > 0 */
-	}
-	/* never reached */
+	ctx->fc_result = NULL;
+	return res;
 }
 
 /* ------------------------------------------------------------------
@@ -462,9 +468,8 @@ struct sm_waiter {
 /** Filters out intermediate states of c2_confc_ctx::fc_mach. */
 static bool sm_filter(struct c2_clink *link)
 {
-	int32_t e = c2_confc_ctx_error(&container_of(link, struct sm_waiter,
-						     w_clink)->w_ctx);
-	return e == EINPROGRESS;
+	return !c2_confc_ctx_is_completed(&container_of(link, struct sm_waiter,
+							w_clink)->w_ctx);
 }
 
 int c2__confc_open_sync(struct c2_conf_obj **result, struct c2_conf_obj *origin,
@@ -481,8 +486,10 @@ int c2__confc_open_sync(struct c2_conf_obj **result, struct c2_conf_obj *origin,
 
 	rc = c2__confc_open(&w.w_ctx, origin, path);
 	if (rc == 0) {
-		while ((rc = c2_confc_ctx_error(&w.w_ctx)) == EINPROGRESS)
+		while (!c2_confc_ctx_is_completed(&w.w_ctx))
 			c2_chan_wait(&w.w_clink);
+
+		rc = c2_confc_ctx_error(&w.w_ctx);
 		if (rc == 0)
 			*result = c2_confc_ctx_result(&w.w_ctx);
 	}
diff --git a/conf/confc.h b/conf/confc.h
index cf38c05..fe507ec 100644
--- a/conf/confc.h
+++ b/conf/confc.h
@@ -135,6 +135,9 @@ struct c2_mutex;
  * object (c2_confc_ctx_init()) and register a clink with .sm_chan
  * member of c2_confc_ctx::fc_mach.
  *
+ * c2_confc_ctx_is_completed() checks whether configuration retrieval
+ * has completed, i.e., terminated or failed.
+ *
  * c2_confc_ctx_error() returns the error status of an asynchronous
  * configuration retrieval operation. c2_confc_ctx_result() returns
  * the requested configuration object.
@@ -171,7 +174,6 @@ struct c2_mutex;
  *
  * static void sm_waiter_init(struct sm_waiter *w, struct c2_confc *confc);
  * static void sm_waiter_fini(struct sm_waiter *w);
- * static int sm_waiter_wait(struct sm_waiter *w);
  *
  * static int filesystem_open_async(struct c2_conf_filesystem **fs)
  * {
@@ -182,7 +184,10 @@ struct c2_mutex;
  *
  *         rc = c2_confc_open(&w.w_ctx, NULL, C2_CONF_BUF_STR("filesystem"));
  *         if (rc == 0) {
- *                 rc = sm_waiter_wait(&w);
+ *                 while (!c2_confc_ctx_is_completed(&w.w_ctx))
+ *                         c2_chan_wait(&w.w_clink);
+ *
+ *                 rc = c2_confc_ctx_error(&w.w_ctx);
  *                 if (rc == 0)
  *                         *fs = C2_CONF_CAST(c2_confc_ctx_result(&w.w_ctx),
  *                                            c2_conf_filesystem);
@@ -199,17 +204,17 @@ struct c2_mutex;
  * }
  *
  * // Filters out intermediate state of c2_confc_ctx::fc_mach.
- * static bool sm_waiter_filter(struct c2_clink *link)
+ * static bool sm_filter(struct c2_clink *link)
  * {
- *         int32_t e = c2_confc_ctx_error(&container_of(link, struct sm_waiter,
- *                                                      w_clink)->w_ctx);
- *         return e == EINPROGRESS;
+ *         return !c2_confc_ctx_is_completed(&container_of(link,
+ *                                                         struct sm_waiter,
+ *                                                         w_clink)->w_ctx);
  * }
  *
  * static void sm_waiter_init(struct sm_waiter *w, struct c2_confc *confc)
  * {
  *         c2_confc_ctx_init(&w->w_ctx, confc);
- *         c2_clink_init(&w->w_clink, sm_waiter_filter);
+ *         c2_clink_init(&w->w_clink, sm_filter);
  *         c2_clink_add(&w->w_ctx.fc_mach.sm_chan, &w->w_clink);
  * }
  *
@@ -219,14 +224,6 @@ struct c2_mutex;
  *         c2_clink_fini(&w->w_clink);
  *         c2_confc_ctx_fini(&w->w_ctx);
  * }
- *
- * static int sm_waiter_wait(struct sm_waiter *w)
- * {
- *         int rc;
- *         while ((rc = c2_confc_ctx_error(&w->w_ctx)) == EINPROGRESS)
- *                 c2_chan_wait(&w->w_clink);
- *         return rc;
- * }
  * @endcode
  *
  * <!---------------------------------------------------------------->
@@ -398,7 +395,6 @@ struct c2_mutex;
  * // sm_waiter_*() functions are defined in one of the recipes above.
  * static void sm_waiter_init(struct sm_waiter *w, struct c2_confc *confc);
  * static void sm_waiter_fini(struct sm_waiter *w);
- * static int sm_waiter_wait(struct sm_waiter *w);
  *
  * // Counts the number of entries in a given directory.
  * static ssize_t dir_len(struct c2_conf_dir *dir)
@@ -412,29 +408,31 @@ struct c2_mutex;
  *         c2_conf_dircur_init(&cur, dir);
  *         sm_waiter_init(&w, g_confc);
  *
- *         while (1) {
- *                 rc = c2_confc_readdir(&w.w_ctx, &cur);
- *                 if (rc == 2 || rc < 0) { // end of directory or an error
- *                         break;
- *                 } else if (rc == 1) {    // an entry is available immediately
+ *         while ((rc = c2_confc_readdir(&w.w_ctx, &cur)) > 0) {
+ *                 if (rc == C2_CONFC_DIR_NEXT) {
+ *                         // An entry is available immediately.
  *                         C2_CNT_INC(count);
  *                         continue;
- *                 } else {                 // asynchronous case
- *                         C2_ASSERT(rc == 0);
- *                         rc = sm_waiter_wait(&w);
- *                         if (rc != 0)
- *                                 break; // error
- *
- *                         entry = c2_confc_ctx_result(&w.w_ctx);
- *                         if (entry == NULL)
- *                                 break; // end of directory
- *                         else
- *                                 C2_CNT_INC(count);
- *
- *                         // Re-initialise c2_confc_ctx.
- *                         sm_waiter_fini(&w);
- *                         sm_waiter_init(&w);
  *                 }
+ *
+ *                 // Asynchronous case.
+ *                 C2_ASSERT(rc == C2_CONFC_DIR_WAIT);
+ *                 while (!c2_confc_ctx_is_completed(&w.w_ctx))
+ *                         c2_chan_wait(&w.w_clink);
+ *
+ *                 rc = c2_confc_ctx_error(&w.w_ctx);
+ *                 if (rc != 0)
+ *                         break; // error
+ *
+ *                 entry = c2_confc_ctx_result(&w.w_ctx);
+ *                 if (entry == NULL)
+ *                         break; // end of directory
+ *                 else
+ *                         C2_CNT_INC(count);
+ *
+ *                 // Re-initialise c2_confc_ctx.
+ *                 sm_waiter_fini(&w);
+ *                 sm_waiter_init(&w);
  *         }
  *
  *         sm_waiter_fini(&w);
@@ -584,7 +582,7 @@ struct c2_confc_ctx {
 	 * Pointer to the requested configuration object.
 	 *
 	 * The application should use c2_confc_ctx_result() instead of
-	 * accessing this value.
+	 * accessing this field directly.
 	 */
 	struct c2_conf_obj       *fc_result;
 	/** Magic number. */
@@ -600,21 +598,26 @@ void c2_confc_ctx_init(struct c2_confc_ctx *ctx, struct c2_confc *confc);
 void c2_confc_ctx_fini(struct c2_confc_ctx *ctx);
 
 /**
- * Returns error status of asynchronous configuration retrieval operation.
+ * Returns true iff ctx->fc_mach has terminated or failed.
  *
- * @retval EINPROGRESS  The asynchronous configuration request has not yet
- *                      completed.
- * @retval 0      The asynchronous configuration request has completed
- *                successfully.
- * @retval -Exxx  The request has completed unsuccessfully.
- *
- * c2_confc_ctx_error() can be applied to filtering out intermediate
+ * c2_confc_ctx_is_completed() can be used to filter out intermediate
  * state transitions, signaled on ctx->fc_mach.sm_chan channel.
  *
  * @see
  *   - `Filtered wake-ups' section in @ref chan
  *   - @ref confc-fspec-recipe1
  */
+bool c2_confc_ctx_is_completed(const struct c2_confc_ctx *ctx);
+
+/**
+ * Returns error status of asynchronous configuration retrieval operation.
+ *
+ * @retval 0      The asynchronous configuration request has completed
+ *                successfully.
+ * @retval -Exxx  The request has completed unsuccessfully.
+ *
+ * @pre  c2_confc_ctx_is_completed(ctx)
+ */
 int32_t c2_confc_ctx_error(const struct c2_confc_ctx *ctx);
 
 /**
@@ -627,10 +630,9 @@ int32_t c2_confc_ctx_error(const struct c2_confc_ctx *ctx);
  * c2_confc_ctx_result() sets ctx->fc_result to NULL and returns the
  * original value.
  *
- * @pre   c2_confc_ctx_error(ctx) == 0 && ctx->fc_result != NULL
+ * @pre   ctx->fc_mach.sm_state == S_TERMINAL
+ * @pre   ctx->fc_result != NULL
  * @post  ctx->fc_result == NULL
- *
- * @see c2_confc_ctx_error()
  */
 struct c2_conf_obj *c2_confc_ctx_result(struct c2_confc_ctx *ctx);
 
@@ -703,32 +705,50 @@ void c2_confc_close(struct c2_conf_obj *obj);
  * readdir
  * ------------------------------------------------------------------ */
 
+/** Symbolic names for c2_confc_readdir() return values. */
+enum c2_confc_retval {
+	/** End of directory is reached; no waiting is needed. */
+	C2_CONFC_DIREND = 0,
+	/**
+	 * The next directory is available immediately; no waiting is
+	 * needed.
+	 */
+	C2_CONFC_DIRNEXT,
+	/**
+	 * Asynchronous retrieval of configuration has been initiated.
+	 * The caller should wait.
+	 */
+	C2_CONFC_DIRWAIT
+};
+
 /**
  * Requests asynchronous retrieval of the next directory entry.
  *
  * Closes the configuration object returned by previous c2_confc_readdir*().
  *
- * @retval 0    Asynchronous retrieval of configuration has been initiated.
- * @retval 1    The next directory entry is available immediately;
- *              no waiting is needed.
- * @retval 2    End of directory is reached; no waiting is needed.
- * @retval < 0  Error.
+ * @retval C2_CONFC_DIRWAIT  Asynchronous retrieval of configuration has been
+ *                           initiated.
+ * @retval C2_CONFC_DIRNEXT  The next directory entry is available immediately,
+ *                           no waiting is needed.
+ * @retval C2_CONFC_DIREND   End of directory is reached, no waiting is needed.
+ * @retval < 0               Error.
  *
  * Entries of a directory are usually present in the configuration
  * cache.  In this common case c2_confc_readdir() can fulfil the
- * request immediately. Return values 1 and 2 let the caller know that
- * it can proceed (e.g., call c2_confc_ctx_result()) without waiting
- * for ctx->fc_mach.sm_chan channel to be signaled.
+ * request immediately. Return value C2_CONFC_DIREND or C2_CONFC_DIRNEXT
+ * let the caller know that it can proceed without waiting for
+ * ctx->fc_mach.sm_chan channel to be signaled.
  *
  * c2_confc_readdir() does not touch `ctx' argument if the returned
- * value is 1 or 2. c2_confc_ctx can be re-used in this case.
+ * value is C2_CONFC_DIREND or C2_CONFC_DIRNEXT. c2_confc_ctx can be
+ * re-used in this case.
  *
  * @note  The application must not c2_confc_close() a configuration
  *        object retrieved by c2_confc_readdir().  The object will be
  *        closed implicitly by subsequent c2_confc_readdir*() call or
  *        by c2_conf_dircur_fini().
  *
- * @see XXX TODO: Add a recipe demonstrating c2_confc_readdir() usage.
+ * @see confc-fspec-recipe4
  */
 int c2_confc_readdir(struct c2_confc_ctx *ctx, struct c2_conf_dircur *cur);
 
@@ -738,9 +758,9 @@ int c2_confc_readdir(struct c2_confc_ctx *ctx, struct c2_conf_dircur *cur);
  * Closes the configuration object returned by previous c2_confc_readdir*().
  * Increments reference counter of the returned object.
  *
- * @retval 1    *result now points to the next directory entry.
- * @retval 0    End of directory is reached.
- * @retval < 0  Error.
+ * @retval C2_CONFC_DIRNEXT  *result now points to the next directory entry.
+ * @retval C2_CONFC_DIREND   End of directory is reached.
+ * @retval < 0               Error.
  *
  * @note  The application must not c2_confc_close() the resulting
  *        configuration object.  The object will be closed implicitly
-- 
1.8.3.2

