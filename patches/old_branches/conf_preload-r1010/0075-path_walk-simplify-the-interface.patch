From a60eb4509e90a121afd778f2394bbefd9f1a2708 Mon Sep 17 00:00:00 2001
From: "Valery V. Vorotyntsev" <valery_vorotyntsev@xyratex.com>
Date: Sun, 18 Mar 2012 23:05:44 +0200
Subject: [PATCH 075/311] path_walk(): simplify the interface

Reviewed-on: http://reviewboard.clusterstor.com/r/714/
Reported-by: Nikita Danilov <nikita_danilov@xyratex.com>
---
 conf/confc.c | 74 ++++++++++++++++++++++++++++--------------------------------
 1 file changed, 35 insertions(+), 39 deletions(-)

diff --git a/conf/confc.c b/conf/confc.c
index 45e82d1..70eba34 100644
--- a/conf/confc.c
+++ b/conf/confc.c
@@ -373,48 +373,45 @@ static inline struct c2_confc_ctx * to_ctx(struct c2_sm *mach)
 }
 
 /**
+ * Follows ctx->fc_path and checks the statuses of met objects.
+ *
  * @pre   cache's sm_group is locked
  * @pre   c2_conf_path_is_valid(&ctx->fc_path, NULL)
  * @post  cache's sm_group is locked
  *
- * @retval -ENOENT  ctx->fc_path contains a key, but the corresponding
- *                  object does not exist.
+ * @retval C2_CS_READY    Path target is reachable.
+ *
+ * @retval C2_CS_MISSING  At least one of the intermediate objects or
+ *                        the target itself is C2_CS_MISSING.
+ *                        path_walk() changes statuses of such objects
+ *                        to C2_CS_LOADING and fills ctx->fc_req.
+ *
+ * @retval C2_CS_LOADING  Neither path target nor missing objects can
+ *                        be reached because of C2_CS_LOADING
+ *                        object(s) blocking the path.  path_walk()
+ *                        registers ctx->fc_clink with the channel(s)
+ *                        of loading object(s).
+ *
+ * @retval -ENOENT        ctx->fc_path contains a key, but the corresponding
+ *                        object does not exist.
+ *
+ * @see @ref confc-dld-lspec-state
  */
-static int path_walk(struct c2_confc_ctx *ctx, enum c2_conf_status *status)
+static int path_walk(struct c2_confc_ctx *ctx)
 {
-	/*
-	 * [Refer to confc state diagram in the HLD.]
-	 *
-	 * path_walk() follows ctx->fc_path and checks the statuses
-	 * of met objects.  Upon success, the function sets *status to:
-	 *
-	 * - C2_CS_READY:   path target is reachable
-	 *
-	 * - C2_CS_MISSING: At least one of the intermediate objects
-	 *                  or the target itself is C2_CS_MISSING.
-	 *                  path_walk() changes statuses of such
-	 *                  objects to C2_CS_LOADING and fills
-	 *                  ctx->fc_req.
-	 *
-	 * - C2_CS_LOADING: Neither path target nor missing objects
-	 *                  can be reached because of C2_CS_LOADING
-	 *                  object(s) blocking the path.
-	 *                  path_walk() registers ctx->fc_clink with
-	 *                  the channel(s) of loading object(s).
-	 */
 	struct c2_conf_obj *obj = ctx->fc_path.p_origin ?: g_confc.root;
 	struct c2_conf_pathcomp *comp = ctx->fc_path.p_comps;
 	size_t len = ctx->fc_path.p_len; /* number of components to go */
 	bool target_is_directory = false;
-	int ret = 0;
+	int ret;
 
 	C2_PRE(c2_mutex_is_locked(group_lock()));
 	C2_PRE(c2_conf_path_is_valid(&ctx->fc_path, NULL));
 
 	c2_mutex_lock(cache_lock());
-	*status = obj->co_status;
+	ret = obj->co_status;
 
-	for (; *status == C2_CS_READY && len > 0; --len, ++comp) {
+	for (; ret == C2_CS_READY && len > 0; --len, ++comp) {
 		const struct c2_conf_relation *rel;
 		struct c2_conf_obj *child;
 		C2_ASSERT(!comp->pc_iskey);
@@ -425,7 +422,7 @@ static int path_walk(struct c2_confc_ctx *ctx, enum c2_conf_status *status)
 
 		if (target_is_directory) {
 			if (len == 1) { /* the last component */
-				*status = list_status(XXX_descr, XXX_list);
+				ret = list_status(XXX_descr, XXX_list);
 				break;
 			}
 
@@ -451,29 +448,29 @@ static int path_walk(struct c2_confc_ctx *ctx, enum c2_conf_status *status)
 		}
 
 		obj = child;
-		*status = obj->co_status;
+		ret = obj->co_status;
 	}
 
 	/*
 	 * XXX "confc offline": all the needed configuration data is
 	 * supposed to be pre-loaded.
 	 */
-	C2_ASSERT(*status == C2_CS_READY);
+	C2_ASSERT(ret == C2_CS_READY);
 
-	if (*status == C2_CS_READY) {
+	if (ret == C2_CS_READY) {
 		C2_CNT_INC(obj->co_nrefs);
 		if (target_is_directory) {
 			XXX; /* ctx->fc_result = dir_allocate() */
 		} else {
 			ctx->fc_result = obj;
 		}
-	} else if (*status == C2_CS_MISSING) {
+	} else if (ret == C2_CS_MISSING) {
 		if (!target_is_directory) {
 			C2_ASSERT(obj->co_status == C2_CS_MISSING);
 			obj->co_status = C2_CS_LOADING;
 		}
 		request_fill(&ctx->fc_req, obj, comp, len);
-	} else if (*status == C2_CS_LOADING) {
+	} else if (ret == C2_CS_LOADING) {
 		if (target_is_directory) {
 			XXX; /* scan directory, adding clinks */
 		} else {
@@ -746,22 +743,21 @@ static void ast_fail(struct c2_sm_ast *ast, int32_t rc)
 /** Actions to perform on entering CHECK state. */
 static void check_st_in(struct c2_sm *mach)
 {
-	enum c2_conf_status status;
 	int rc;
 
 	C2_PRE(c2_mutex_is_locked(group_lock()));
 
-	rc = path_walk(to_ctx(mach), &status);
-	if (rc != 0)
+	rc = path_walk(to_ctx(mach));
+	if (rc < 0)
 		c2_sm_fail(mach, S_FAILURE, rc);
-	else if (status == C2_CS_MISSING)
+	else if (rc == C2_CS_MISSING)
 		c2_sm_state_set(mach, S_WAIT_REPLY);
-	else if (status == C2_CS_LOADING)
+	else if (rc == C2_CS_LOADING)
 		c2_sm_state_set(mach, S_WAIT_STATUS);
-	else if (status == C2_CS_READY)
+	else if (rc == C2_CS_READY)
 		c2_sm_state_set(mach, S_TERMINAL);
 	else
-		C2_IMPOSSIBLE("status is not valid");
+		C2_IMPOSSIBLE("path_walk: invalid result");
 
 	C2_POST(c2_mutex_is_locked(group_lock()));
 }
-- 
1.8.3.2

