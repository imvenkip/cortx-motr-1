From 8dfb6556a338688e80fd3867952d46c54d37ddaa Mon Sep 17 00:00:00 2001
From: "Valery V. Vorotyntsev" <valery_vorotyntsev@xyratex.com>
Date: Mon, 16 Jul 2012 13:45:42 +0300
Subject: [PATCH 243/311] confc.h: get rid of c2_confc_ctx::fc_completed
 channel

- c2_confc_ctx_is_completed(): introduce new helper function.
- confc.c: Delete completion_announce() as it is not needed any more.
- confc.h: Update @ref confc-fspec-recipe1 correspondingly.

LogD #455
RB: r/865
---
 conf/confc.c | 72 +++++++++++++++++++++++++---------------------------
 conf/confc.h | 83 +++++++++++++++++++++++++++++++++++++-----------------------
 2 files changed, 87 insertions(+), 68 deletions(-)

diff --git a/conf/confc.c b/conf/confc.c
index b9f9afa..6801c0d 100644
--- a/conf/confc.c
+++ b/conf/confc.c
@@ -36,7 +36,6 @@
  *   - @ref confc-lspec-state-wait-reply
  *   - @ref confc-lspec-state-wait-status
  *   - @ref confc-lspec-state-grow-cache
- *   - @ref confc-lspec-state-term
  * - @ref confc-lspec-walk
  * - @ref confc-lspec-grow
  * - @ref confc-lspec-thread
@@ -54,10 +53,8 @@
  *     node [fontsize=9];
  *     edge [fontsize=9];
  *     S_INITIAL  [style=filled, fillcolor=lightgrey];
- *     S_TERMINAL [style=filled, fillcolor=lightgrey,
- *                 label="{ completion_announce() }\nS_TERMINAL"];
- *     S_FAILURE  [style=filled, fillcolor=lightgrey,
- *                 label="{ completion_announce() }\nS_FAILURE"];
+ *     S_TERMINAL [style=filled, fillcolor=lightgrey, label="S_TERMINAL"];
+ *     S_FAILURE  [style=filled, fillcolor=lightgrey, label="S_FAILURE"];
  *
  *     S_CHECK [label="{ check_st_in() }\nS_CHECK"];
  *     S_WAIT_REPLY [label="{ wait_reply_st_in() }\nS_WAIT_REPLY"];
@@ -158,12 +155,6 @@
  * succeeds, grow_cache_st_in() moves the state machine to S_CHECK
  * state, otherwise --- to S_FAILURE state.
  *
- * @subsection confc-lspec-state-term S_TERMINAL, S_FAILURE
- *
- * When a state machine enters S_TERMINAL or S_FAILURE state, it
- * invokes completion_announce() callback.  This function broadcasts
- * c2_confc_ctx::fc_complete channel.
- *
  * <hr> <!------------------------------------------------------------>
  * @section confc-lspec-walk Walking the DAG
  *
@@ -412,7 +403,6 @@ void c2_confc_ctx_init(struct c2_confc_ctx *ctx, struct c2_confc *confc)
 
 	c2_mutex_unlock(group_lock(confc));
 
-	c2_chan_init(&ctx->fc_complete);
 	c2_clink_init(&ctx->fc_clink, on_object_updated);
 
 	C2_POST(ctx_invariant(ctx));
@@ -424,7 +414,6 @@ void c2_confc_ctx_fini(struct c2_confc_ctx *ctx)
 	C2_PRE(ctx_invariant(ctx));
 
 	c2_clink_fini(&ctx->fc_clink);
-	c2_chan_fini(&ctx->fc_complete);
 
 	c2_mutex_lock(group_lock(confc)); /* needed for c2_sm_fini() */
 
@@ -438,9 +427,15 @@ void c2_confc_ctx_fini(struct c2_confc_ctx *ctx)
 	c2_mutex_unlock(group_lock(confc));
 }
 
+bool c2_confc_ctx_is_completed(const struct c2_confc_ctx *ctx)
+{
+	C2_PRE(ctx_invariant(ctx));
+	return C2_IN(ctx->fc_mach.sm_state, (S_TERMINAL, S_FAILURE));
+}
+
 struct c2_conf_obj *c2_confc_ctx_result(struct c2_confc_ctx *ctx)
 {
-	C2_PRE(C2_IN(ctx->fc_mach, (S_TERMINAL, S_FAILURE)));
+	C2_PRE(c2_confc_ctx_is_completed(ctx));
 
 	XXX;
 }
@@ -468,30 +463,41 @@ int c2_confc_open(struct c2_confc_ctx *ctx, struct c2_conf_obj *origin,
 	return rc;
 }
 
+struct sm_waiter {
+	struct c2_confc_ctx w_ctx;
+	struct c2_clink     w_clink;
+};
+
+/** Filters out intermediate states of c2_confc_ctx::fc_mach. */
+static bool sm_filter(struct c2_clink *link)
+{
+	struct sm_waiter *w = container_of(link, struct sm_waiter, w_clink);
+	return !c2_confc_ctx_is_completed(&w->w_ctx);
+}
+
 int c2_confc_open_sync(struct c2_conf_obj **result, struct c2_conf_obj *origin,
                        const char *path)
 {
-	struct c2_confc_ctx ctx;
-	struct c2_clink     clink;
-	int                 rc;
+	struct sm_waiter w;
+	int              rc;
 
 	C2_PRE(origin != NULL);
 
-	c2_confc_ctx_init(&ctx, origin->co_confc);
-	c2_clink_init(&clink, NULL);
-	c2_clink_add(&ctx.fc_complete, &clink);
+	c2_confc_ctx_init(&w.w_ctx, origin->co_confc);
+	c2_clink_init(&w.w_clink, sm_filter);
+	c2_clink_add(&w.w_ctx.fc_mach.sm_chan, &w.w_clink);
 
-	rc = c2_confc_open(&ctx, origin, path);
+	rc = c2_confc_open(&w.w_ctx, origin, path);
 	if (rc == 0) {
-		c2_chan_wait(&clink);
-		*result = c2_confc_ctx_result(&ctx);
+		c2_chan_wait(&w.w_clink);
+		*result = c2_confc_ctx_result(&w.w_ctx);
 		if (*result == NULL)
-			rc = c2_confc_ctx_error(&ctx);
+			rc = c2_confc_ctx_error(&w.w_ctx);
 	}
 
-	c2_clink_del(&clink);
-	c2_clink_fini(&clink);
-	c2_confc_ctx_fini(&ctx);
+	c2_clink_del(&w.w_clink);
+	c2_clink_fini(&w.w_clink);
+	c2_confc_ctx_fini(&w.w_ctx);
 	return rc;
 }
 
@@ -528,7 +534,6 @@ int c2_confc_readdir_sync(struct c2_conf_obj **result,
 static void check_st_in(struct c2_sm *mach);         /* S_CHECK */
 static void wait_reply_st_in(struct c2_sm *mach);    /* S_WAIT_REPLY */
 static void grow_cache_st_in(struct c2_sm *mach);    /* S_GROW_CACHE */
-static void completion_announce(struct c2_sm *mach); /* S_FAILURE, S_TERMINAL */
 
 static bool check_st_invariant(const struct c2_sm *mach);    /* S_CHECK */
 static bool failure_st_invariant(const struct c2_sm *mach);  /* S_FAILURE */
@@ -579,7 +584,7 @@ static const struct c2_sm_state_descr confc_ctx_states[S_NR] = {
 	[S_FAILURE] = {
 		.sd_flags     = C2_SDF_FAILURE,
 		.sd_name      = "FAILURE",
-		.sd_in        = completion_announce,
+		.sd_in        = NULL,
 		.sd_ex        = NULL,
 		.sd_invariant = failure_st_invariant,
 		.sd_allowed   = 0
@@ -587,7 +592,7 @@ static const struct c2_sm_state_descr confc_ctx_states[S_NR] = {
 	[S_TERMINAL] = {
 		.sd_flags     = C2_SDF_TERMINAL,
 		.sd_name      = "TERMINAL",
-		.sd_in        = completion_announce,
+		.sd_in        = NULL,
 		.sd_ex        = NULL,
 		.sd_invariant = terminal_st_invariant,
 		.sd_allowed   = 0
@@ -711,13 +716,6 @@ static bool on_object_updated(struct c2_clink *link)
 	return true; /* event is consumed */
 }
 
-/** Action to perform on entering S_TERMINAL or S_FAILURE state. */
-static int completion_announce(struct c2_sm *mach)
-{
-	c2_chan_broadcast(&mach_to_ctx(mach)->fc_complete);
-	return -1;
-}
-
 static bool check_st_invariant(const struct c2_sm *mach)
 {
 	const struct c2_confc_ctx *ctx = const_mach_to_ctx(mach);
diff --git a/conf/confc.h b/conf/confc.h
index 487b3fe..7ac9886 100644
--- a/conf/confc.h
+++ b/conf/confc.h
@@ -62,9 +62,7 @@ struct c2_mutex;
  *
  * - c2_confc_ctx --- configuration retrieval context.
  *   This structure embodies data needed by a state machine to process
- *   configuration request.  Its ->fc_complete member is a channel
- *   that is signaled when the configuration retrieval operation
- *   completes.
+ *   configuration request.
  *
  * <hr> <!------------------------------------------------------------>
  * @section confc-fspec-sub Subroutines
@@ -134,10 +132,11 @@ struct c2_mutex;
  *
  * c2_confc_open() and c2_confc_readdir() are asynchronous functions.
  * Prior to calling them, the application should initialize a context
- * object (c2_confc_ctx_init()) and register a clink with
- * c2_confc_ctx::fc_complete channel.  After the clink is signaled,
- * c2_confc_ctx_result() can be used to obtain the requested
- * configuration object; c2_confc_ctx_error() returns the error code.
+ * object (c2_confc_ctx_init()) and register a clink with .sm_chan
+ * member of c2_confc_ctx::fc_mach.  When the configuration retrieval
+ * completes (c2_confc_ctx_is_completed)), c2_confc_ctx_result() can
+ * be used to obtain the requested configuration object.
+ * c2_confc_ctx_error() returns the error code.
  *
  * A caller of c2_confc_open_sync() or c2_confc_readdir_sync() will be
  * blocked while confc processes the request.
@@ -163,31 +162,44 @@ struct c2_mutex;
  *
  * struct c2_confc *confc = ...;
  *
+ * struct sm_waiter {
+ *         struct c2_confc_ctx w_ctx;
+ *         struct c2_clink     w_clink;
+ * };
+ *
+ * /// Filters out intermediate states of c2_confc_ctx::fc_mach.
+ * static bool sm_filter(struct c2_clink *link)
+ * {
+ *         struct sm_waiter *w = container_of(link, struct sm_waiter, w_clink);
+ *         return !c2_confc_ctx_is_completed(&w->w_ctx);
+ * }
+ *
  * static int filesystem_open_async(struct c2_conf_filesystem **fs)
  * {
- *         struct c2_confc_ctx ctx;
- *         struct c2_clink     clink;
- *         int                 rc;
+ *         struct sm_waiter w;
+ *         int              rc;
  *
- *         c2_confc_ctx_init(&ctx, confc);
- *         c2_clink_init(&clink, NULL);
- *         c2_clink_add(&ctx.fc_complete, &clink);
+ *         c2_confc_ctx_init(&w.w_ctx, confc);
+ *         c2_clink_init(&w.w_clink, sm_filter);
+ *         c2_clink_add(&w.w_ctx.fc_mach.sm_chan, &w.w_clink);
  *
- *         rc = c2_confc_open(&ctx, NULL, "filesystem");
+ *         rc = c2_confc_open(&w.w_ctx, NULL, "filesystem");
  *         if (rc == 0) {
  *                 struct c2_conf_obj *obj;
  *
- *                 c2_chan_wait(&clink);
- *                 obj = c2_confc_ctx_result(&ctx);
+ *                 while (!c2_confc_ctx_is_completed(&w.w_ctx))
+ *                         c2_chan_wait(&w.w_clink);
+ *
+ *                 obj = c2_confc_ctx_result(&w.w_ctx);
  *                 if (obj == NULL)
- *                         rc = c2_confc_ctx_error(&ctx);
+ *                         rc = c2_confc_ctx_error(&w.w_ctx);
  *                 else
  *                         *fs = C2_CONF_CAST(obj, c2_conf_filesystem);
  *         }
  *
- *         c2_clink_del(&clink);
- *         c2_clink_fini(&clink);
- *         c2_confc_ctx_fini(&ctx);
+ *         c2_clink_del(&w.w_clink);
+ *         c2_clink_fini(&w.w_clink);
+ *         c2_confc_ctx_fini(&w.w_ctx);
  *         return rc;
  * }
  *
@@ -445,14 +457,11 @@ enum { C2_CONFC_MAX_PATH_COMP = 16 };
 
 /** Configuration retrieval context. */
 struct c2_confc_ctx {
-	/** This channel is signaled when the retrieval operation completes. */
-	struct c2_chan           fc_complete;
-/* private: internal use only */
 	/**
 	 * Pointer to the requested configuration object.
 	 *
-	 * The value is NULL until ->fc_complete channel is signaled.
-	 * It is also NULL if configuration retrieval failed.
+	 * The value is NULL unless the retrieval operation has
+	 * completed successfully.
 	 *
 	 * @see c2_confc_ctx_result(), c2_confc_ctx_error().
 	 */
@@ -502,9 +511,22 @@ void c2_confc_ctx_init(struct c2_confc_ctx *ctx, struct c2_confc *confc);
 void c2_confc_ctx_fini(struct c2_confc_ctx *ctx);
 
 /**
+ * Returns true iff ctx->fc_mach has terminated or failed.
+ *
+ * This is a helper function that can be applied to filter out
+ * intermediate state transitions, signaled on ctx->fc_mach.sm_chan
+ * channel.
+ *
+ * @see
+ *   - `Filtered wake-ups' section in @ref chan
+ *   - @ref confc-fspec-recipe1
+ */
+bool c2_confc_ctx_is_completed(struct c2_confc_ctx *ctx);
+
+/**
  * Sets c2_confc_ctx::fc_result to NULL and returns the original value.
  *
- * @pre  C2_IN(ctx->fc_mach, (S_TERMINAL, S_FAILURE))
+ * @pre  c2_confc_ctx_is_completed(ctx)
  */
 struct c2_conf_obj *c2_confc_ctx_result(struct c2_confc_ctx *ctx);
 
@@ -526,8 +548,7 @@ static inline int32_t c2_confc_ctx_error(const struct c2_confc_ctx *ctx)
  * @param path    Path to the requested object.
  *
  * @note  The application must keep the string, pointed to by `path',
- *        intact until configuration retrieval completes (i.e., until
- *        ctx->fc_complete channel is signaled).
+ *        intact until configuration retrieval completes.
  *
  * @pre  ergo(origin != NULL, origin->co_confc == ctx->fc_confc)
  * @pre  ctx->fc_origin == NULL && ctx->fc_path is zeroed
@@ -580,9 +601,9 @@ void c2_confc_close(struct c2_conf_obj *obj);
  *
  * @retval 1    "Ready to serve": the requested directory entry is known
  *              to be C2_CS_READY, so the caller does not need to wait
- *              until ctx->fc_complete channel is signaled.
- * @retval 0    "Please wait": the caller does need to wait until
- *              ctx->fc_complete is signaled.
+ *              on ctx->fc_mach.sm_chan channel.
+ * @retval 0    "Please wait": the caller does need to wait on
+ *              ctx->fc_mach.sm_chan.
  * @retval < 0  Error.
  *
  * @note  The application must not c2_confc_close() a configuration
-- 
1.8.3.2

