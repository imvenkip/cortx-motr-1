From 1dd3835a86626a9d10be18b67dd6f3d3b58101fd Mon Sep 17 00:00:00 2001
From: "Valery V. Vorotyntsev" <valery_vorotyntsev@xyratex.com>
Date: Thu, 21 Jun 2012 02:15:24 +0300
Subject: [PATCH 203/311] conf/confc.c: rearrange the code; use ->coo_lookup()

confc.c:
- Rearrange the code so that it can be read top-to-bottom.
- Simplify path walking by using ->coo_lookup().
- Use bob_of() instead of container_of().
- Extra clinks are not needed any more.
- s/client/confc/
- path_store(): new function.
- A state machine relates to a context (c2_confc_ctx), not c2_confc
  instance.

obj.h:
- c2_conf_obj_ops::coo_lookup(): add `out' argument.

buf.h:
- Add C2_CONF_BUF_STR() initializer.

TODO:
* c2_conf_fetch::f_origin should not be a c2_conf_dir.  This
  requires a small change in path_walk().
* Revise the wording of the logical specification.1Gl
---
 conf/buf.h           |    7 +-
 conf/confc.c         | 1297 +++++++++++++++++++++-----------------------------
 conf/confc.h         |   72 +--
 conf/confc_offline.h |    1 +
 conf/map.h           |    2 +-
 conf/obj.c           |   18 +-
 conf/obj.h           |   21 +-
 conf/obj_ops.c       |    2 +-
 conf/obj_ops.h       |   10 +-
 conf/ut/confc.c      |    2 +-
 10 files changed, 624 insertions(+), 808 deletions(-)

diff --git a/conf/buf.h b/conf/buf.h
index 8789a9d..46e7c92 100644
--- a/conf/buf.h
+++ b/conf/buf.h
@@ -27,13 +27,14 @@
 #endif
 #include "lib/misc.h"        /* strlen */
 
-/**
- * C2_CONF_BUF_INIT: initializer for struct c2_conf_buf.
+/*
+ * Initializers for struct c2_conf_buf.
  *
  * c2_conf_buf is defined in onwire.ff, but C2_CONF_BUF_INIT() cannot
  * be defined there --- fop/fop2c would skip such a definition.
  */
 #define C2_CONF_BUF_INIT(size, data) { .cb_size = (size), .cb_data = (data) }
+#define C2_CONF_BUF_STR(str) { .cb_size = strlen(str), .cb_data = (str) }
 
 /** Returns true iff two buffers are equal. */
 bool c2_conf_buf_eq(const struct c2_conf_buf *x, const struct c2_conf_buf *y);
@@ -54,7 +55,7 @@ int c2_conf_buf_copy(struct c2_conf_buf *dest, const struct c2_conf_buf *src);
 static inline int c2_conf_buf_strdup(struct c2_conf_buf *dest, const char *src)
 {
 	return c2_conf_buf_copy(dest, &(const struct c2_conf_buf)
-				C2_CONF_BUF_INIT(strlen(src), src));
+				C2_CONF_BUF_STR(src));
 }
 
 #endif /* __COLIBRI_CONF_BUF_H__ */
diff --git a/conf/confc.c b/conf/confc.c
index 8647d80..63d09a4 100644
--- a/conf/confc.c
+++ b/conf/confc.c
@@ -23,7 +23,7 @@
 #endif
 #include "conf/confc.h"
 #include "conf/confc_offline.h"  /* c2_conf_parse */
-#include "lib/cdefs.h"           /* container_of, C2_HAS_TYPE, equi */
+#include "lib/cdefs.h"           /* C2_HAS_TYPE, equi */
 #include "lib/arith.h"           /* C2_CNT_INC, C2_CNT_DEC */
 
 /**
@@ -44,13 +44,12 @@
  * <hr> <!------------------------------------------------------------>
  * @section confc-lspec-state State Specification
  *
- * A confc state machine is embedded into c2_confc_ctx structure as
- * its @ref c2_confc_ctx::fc_mach "fc_mach" member.
- * c2_confc_ctx_init() initializes state machine and sets its state to
- * S_INITIAL.
+ * A state machine is embedded into c2_confc_ctx structure as its @ref
+ * c2_confc_ctx::fc_mach "fc_mach" member.  c2_confc_ctx_init()
+ * initializes the state machine and sets its state to S_INITIAL.
  *
  * @dot
- * digraph confc_states {
+ * digraph confc_ctx_states {
  *     node [fontsize=9];
  *     edge [fontsize=9];
  *     S_INITIAL  [style=filled, fillcolor=lightgrey];
@@ -101,14 +100,14 @@
  * call, moves the state machine to another state:
  *
 @verbatim
-+---------------------+------------------+
-| path_walk() returns | next confc state |
-+---------------------+------------------+
-|    C2_CS_READY      |   S_TERMINAL     |
-|    C2_CS_MISSING    |   S_WAIT_REPLY   |
-|    C2_CS_LOADING    |   S_WAIT_STATUS  |
-|         < 0         |   S_FAILURE      |
-+---------------------+------------------+
++---------------------+-----------------+
+| path_walk() returns |   next state    |
++---------------------+-----------------+
+|    C2_CS_READY      |  S_TERMINAL     |
+|    C2_CS_MISSING    |  S_WAIT_REPLY   |
+|    C2_CS_LOADING    |  S_WAIT_STATUS  |
+|         < 0         |  S_FAILURE      |
++---------------------+-----------------+
 @endverbatim
  *
  * The algorithm of path_walk() is described below (see @ref
@@ -220,7 +219,7 @@
  *      registry.
  *
  * object_enrich() compares cached object with the descriptor received
- * from the confd.  If a discrepancy is found (c2_conf_obj_mismatch()),
+ * from the confd.  If a discrepancy is found (!c2_conf_obj_match()),
  * the function
  *   - reports the discrepancy (C2_ADDB_ADD());
  *   - sets status of the cached object to C2_CS_MISSING;
@@ -239,11 +238,11 @@
  * @section confc-lspec-thread Threading and Concurrency Model
  *
  * There are as many state machines in operation as there are
- * unfinished c2_confc_*open*() requests.
+ * unfinished c2_confc_open*() requests.
  *
- * At most one state transition (c2_sm_state_descr::sd_in) can be
- * running at any given time.  Such synchronization of state
- * transitions is achieved by using c2_sm_group (c2_confc::cc_group).
+ * At most one state transition (c2_sm_state_descr::sd_in()) can be
+ * running at any given time.  Synchronization of state transitions is
+ * achieved by using c2_sm_group (c2_confc::cc_group).
  *
  * Modifications to c2_confc instance and confc cache are protected by
  * a confc lock --- c2_mutex pointed to by c2_confc::cc_lock. The
@@ -268,343 +267,14 @@
  * @{
  */
 
-static inline struct c2_mutex * group_lock(struct c2_confc_ctx *ctx)
-{
-	C2_PRE(ctx_invariant(ctx));
-	return &ctx->fc_client->cc_group->s_lock;
-}
-
-static inline struct c2_mutex * confc_lock(struct c2_confc_ctx *ctx)
-{
-	C2_PRE(ctx_invariant(ctx));
-	return ctx->fc_client->cc_lock;
-}
-
-static struct c2_confc_ctx * mach_to_ctx(struct c2_sm *mach)
-{
-	struct c2_confc_ctx *ctx =
-		container_of(mach, struct c2_confc_ctx, fc_mach);
-	C2_ASSERT(ctx_invariant(ctx));
-	return ctx;
-}
-
-static const struct c2_confc_ctx * mach_to_const_ctx(const struct c2_sm *mach)
-{
-	const struct c2_confc_ctx *ctx =
-		container_of(mach, const struct c2_confc_ctx, fc_mach);
-	C2_ASSERT(ctx_invariant(ctx));
-	return ctx;
-}
-
-static struct c2_confc_ctx * ast_to_ctx(struct c2_sm_ast *ast)
-{
-	struct c2_confc_ctx *ctx =
-		container_of(ast, struct c2_confc_ctx, fc_ast);
-	C2_ASSERT(ctx_invariant(ctx));
-	return ctx;
-}
-
-static inline struct c2_confc * registry_to_client(struct c2_conf_map *cache)
-{
-	return container_of(cache, struct c2_confc, cc_registry);
-}
-
-/** Allocates `n' clinks and attaches them to ctx->fc_clink (group head). */
-static struct c2_clink *
-extra_clinks_create(struct c2_confc_ctx *ctx, uint32_t n)
-{
-	struct c2_clink *clinks;
-	uint32_t         i;
-	C2_PRE(n > 0);
-
-	C2_ALLOC_ARR(clinks, n);
-	if (clinks != NULL) {
-		for (i = 0; i < n; ++i)
-			c2_clink_attach(clinks + i, &ctx->fc_clink,
-					on_object_updated);
-	}
-	return clinks;
-}
-
-/** Frees resources allocated for ctx->fc_extra array. */
-static void extra_clinks_destroy(struct c2_confc_ctx *ctx)
-{
-	uint32_t i;
-	C2_PRE(ctx_invariant(ctx));
-
-	if (ctx->fc_extra != NULL) {
-		for (i = 0; i < ctx->fc_nr_extra; ++i)
-			c2_clink_fini(ctx->fc_extra + i);
-		c2_free(ctx->fc_extra);
-		ctx->fc_extra = NULL;
-		ctx->fc_nr_extra = 0;
-	}
-}
-
-/** Path walk context. */
-struct walk_ctx {
-	/** Current object. */
-	struct c2_conf_obj      *w_obj;
-	/** Remaining path components. */
-	struct c2_conf_pathcomp *w_path;
-	/** Are we looking at a directory? */
-	bool                     w_atdir;
-	/** The number of C2_CS_LOADING objects in this directory. */
-	uint32_t                 w_nload;
-};
-
-static bool walk_ctx_invariant(const struct walk_ctx *wx)
-{
-	return c2_conf_path_is_valid(wx->w_obj, wx->w_path, NULL) &&
-		ergo(wx->w_atdir, wx->w_obj->co_status == C2_CS_READY &&
-		     c2_conf_pathcomp_is_last(wx->w_path));
-}
-
-/**
- * Determines the "resultant status" of the objects located along the path.
- *
- * walk() moves along the DAG of cached configuration objects,
- * starting at wx->w_obj and following wx->w_path. It stops when all
- * path components are consumed or when a stub is reached.
- *
- * Traversing a path leads to one of the following cases:
- *
- * <b>1. Stub ahead</b>
- *
- * A stub object lying on a path makes further progress impossible,
- * since relations of a stub are not trustworthy.  walk() returns
- * c2_conf_obj::co_status of this stub object.
- *
- * <b>2. Wrong key</b>
- *
- * One of path components is a key and there is no object with such
- * key in current directory.  walk() returns -ENOENT.
- *
- * <b>3. Target is a directory</b>
- *
- * It is assumed that the parent object of this directory is reachable
- * (i.e., its path predecessors are C2_CS_READY) and is C2_CS_READY.
- * Otherwise it would be `Stub ahead' case.
- *
- * walk() scans the directory, checking statuses of its objects.
- * If all of the objects are C2_CS_READY, walk() returns C2_CS_READY.
- * If some of the objects are C2_CS_MISSING, walk() changes their
- * statuses to C2_CS_LOADING and returns C2_CS_MISSING.  Otherwise
- * walk() calculates the number of C2_CS_LOADING objects, asserts that
- * this number is > 0, and returns C2_CS_LOADING.
- *
- * <b>4. Target is an object</b>
- *
- * walk() returns ->co_status of the reached target object.
- */
-static int walk(struct walk_ctx *wx)
-{
-	const struct c2_conf_relation *relation;
-	struct c2_conf_obj            *child;
-	int                            ret;
-
-	C2_PRE(walk_ctx_invariant(wx));
-
-	for (ret = wx->w_obj->co_status;
-	     ret == C2_CS_READY && !c2_conf_eop(wx->w_path); ++wx->w_path) {
-		C2_ASSERT(!wx->w_path[0].pc_iskey);
-		relation = c2_conf_downlink(wx->w_obj->co_type,
-					    wx->w_path[0].pc_u.relation);
-		C2_ASSERT(relation != NULL);
-
-		wx->w_atdir = relation->r_dir != NULL;
-		if (!wx->w_atdir) {
-			/* child = *(struct c2_conf_obj **)( */
-			/* 	(void *)wx->w_obj + relation->r_offset); */
-			child = XXX_relation_target(wx->w_obj, relation);
-		} else if (c2_conf_pathcomp_is_last(wx->w_path)) {
-			ret = list_status(XXX_descr, XXX_list, &wx->w_nload);
-			break;
-		} else { /* choose the particular object in this directory */
-			++wx->w_path;
-			C2_ASSERT(wx->w_path[0].pc_iskey);
-			/* key has "narrowed" one-to-many relation */
-			wx->w_atdir = false;
-
-			/* XXX use the objid-to-address mapping instead
-			 * of XXX_list_find() */
-			child = XXX_list_find(XXX_dir, wx->w_path[0].pc_u.key);
-			if (child == NULL)
-				return -ENOENT; /* no such key */
-		}
-
-		wx->w_obj = child;
-		ret = wx->w_obj->co_status;
-	}
-
-	C2_POST(walk_ctx_invariant(wx));
-	C2_POST(ergo(wx->w_atdir && ret == C2_CS_LOADING, wx->w_nload > 0));
-	return ret;
-}
-
-/**
- * Applies the results of walk().
- *
- * The operation depends on the value of `status' and on whether it is
- * an object or a directory reached by walk():
- *
- * <b>1. C2_CS_READY</b>
- *
- * walk_complete() assigns c2_confc_ctx::fc_result.  It also
- * increments reference counter (c2_conf_obj::co_nrefs) of the
- * requested configuration object or, in case of directory, of the
- * object this directory originates from.
- *
- * <b>2. C2_CS_MISSING</b>
- *
- * walk_complete() fills configuration fetch request
- * (c2_confc_ctx::fc_req) and sets status of the object reached by
- * walk() to C2_CS_LOADING.  Or, if a directory is reached,
- * walk_complete() C2_ASSERT()s that there are no C2_CS_MISSING
- * objects in this directory and that the number of C2_CS_LOADING
- * objects is > 0 (thus verifying that walk() did its job properly).
- *
- * <b>3. Single C2_CS_LOADING object</b>
- *
- * walk_complete() registers c2_confc_ctx::fc_clink with the channel
- * of reached object (c2_conf_obj::co_chan).
- *
- * <b>4. Directory with C2_CS_LOADING objects</b>
- *
- * Let 1 + N be the number of C2_CS_LOADING objects in this directory:
- * N = wx->w_nload - 1.
- *
- * If N > 0, then walk_complete() allocates an array of N clinks, sets
- * ->fc_extra and ->fc_nr_extra members of c2_confc_ctx, attaches
- * (c2_clink_attach()) ->fc_extra clinks to ->fc_clink, and registers
- * a group of clinks with object's channels. ->fc_clink is a "group
- * head" (see `Multiple channels' in @ref chan).
- *
- * If N = 0, then only ->fc_clink is registered (c2_clink_add()).
- */
-static int walk_complete(struct c2_confc_ctx *cx, const struct walk_ctx *wx,
-			 enum c2_conf_status status)
-{
-	C2_PRE(ctx_invariant(cx));
-	C2_PRE(walk_ctx_invariant(wx));
-	C2_PRE(c2_mutex_is_locked(group_lock(cx)));
-	C2_PRE(c2_mutex_is_locked(confc_lock(cx)));
-
-	switch (status) {
-	case C2_CS_READY:
-		if (wx->w_atdir) {
-			C2_ASSERT(wx->w_nload == 0);
-			cx->fc_result = XXX_dir_allocate();
-			if (cx->fc_result == NULL)
-				return -ENOMEM;
-		} else {
-			cx->fc_result = wx->w_obj;
-		}
-		C2_CNT_INC(wx->w_obj->co_nrefs);
-		break;
-	case C2_CS_MISSING:
-		request_fill(cx, wx->w_obj, wx->w_path);
-		if (wx->w_atdir) {
-			/* ensure list_status() did its job properly */
-			C2_ASSERT(XXX /* directory has 0 C2_CS_MISSING objects
-				       * and > 0 C2_CS_LOADING objects */);
-		} else {
-			C2_ASSERT(wx->w_obj->co_status == C2_CS_MISSING);
-			wx->w_obj->co_status = C2_CS_LOADING;
-		}
-		break;
-	case C2_CS_LOADING:
-		if (wx->w_atdir) {
-			C2_ASSERT(wx->w_nload > 0);
-			if (wx->w_nload > 1) {
-				cx->fc_extra = extra_clinks_create(
-					cx, wx->w_nload - 1);
-				if (cx->fc_extra == NULL)
-					return -ENOMEM;
-				cx->fc_nr_extra = wx->w_nload - 1;
-			}
-			XXX; /* scan directory, calling c2_clink_add() */
-		} else {
-			C2_ASSERT(wx->w_obj->co_status == C2_CS_LOADING);
-			c2_clink_add(&wx->w_obj->co_chan, &cx->fc_clink);
-		}
-		break;
-	default:
-		C2_IMPOSSIBLE("invalid object status");
-	}
-
-	C2_POST(c2_mutex_is_locked(confc_lock(cx)));
-	C2_POST(c2_mutex_is_locked(group_lock(cx)));
-	return status;
-}
-
-/**
- * Follows the path, checking statuses of met objects.
- *
- * @pre  cache's sm_group is locked
- * @post cache's sm_group is locked
- *
- * @retval C2_CS_READY    Path target is reachable.
- *
- * @retval C2_CS_MISSING  At least one of the intermediate objects or
- *                        the target itself is C2_CS_MISSING.
- *                        path_walk() changes statuses of such objects
- *                        to C2_CS_LOADING and fills ctx->fc_req.
- *
- * @retval C2_CS_LOADING  Neither path target nor missing objects can
- *                        be reached because of C2_CS_LOADING
- *                        object(s) blocking the path.  path_walk()
- *                        registers ctx->fc_clink and, optionally,
- *                        ctx->fc_extra clinks with the channel(s) of
- *                        loading object(s).
- *
- * @retval -ENOENT        ctx->fc_path contains a key, but the corresponding
- *                        object does not exist.
- *
- * @retval -ENOMEM        Insufficient memory.
- *
- * @see @ref confc-lspec-state
- */
-static int path_walk(struct c2_confc_ctx *ctx)
-{
-	int             ret;
-	struct walk_ctx wx = { .w_atdir = false, .w_nload = 0 };
-
-	C2_PRE(ctx_invariant(ctx));
-	C2_PRE(c2_mutex_is_locked(group_lock(ctx)));
-
-	wx.w_obj  = ctx->fc_origin;
-	wx.w_path = ctx->fc_path;
-
-	c2_mutex_lock(confc_lock(ctx));
-	ret = walk(&wx);
-	/*
-	 * XXX `confc offline' workaround: all the needed
-	 * configuration data is supposed to be pre-loaded.
-	 */
-	C2_ASSERT(ret == C2_CS_READY);
-	if (ret >= 0)
-		ret = walk_complete(ctx, &wx, ret);
-
-	c2_mutex_unlock(confc_lock(ctx));
-	C2_POST(c2_mutex_is_locked(group_lock(ctx)));
-	return ret;
-}
-
-static bool confc_invariant(const struct c2_confc *client)
-{
-	/* XXX add more checks */
-	return equi(client->cc_root == NULL, client->cc_group == NULL) &&
-		equi(client->cc_root == NULL, client->cc_lock == NULL);
-}
+/* ------------------------------------------------------------------
+ * c2_confc
+ * ------------------------------------------------------------------ */
 
-static bool confc_is_initialized(const struct c2_confc *client)
-{
-	C2_PRE(confc_invariant(client));
-	return client->cc_root != NULL;
-}
+static bool confc_is_initialized(const struct c2_confc *confc);
+static int cache_preload(struct c2_confc *confc, const char *conf_str);
 
-int c2_confc_init(struct c2_confc *client, const char *conf_source,
+int c2_confc_init(struct c2_confc *confc, const char *conf_source,
 		  const char *profile, struct c2_sm_group *sm_group,
 		  struct c2_mutex *lock)
 {
@@ -613,112 +283,175 @@ int c2_confc_init(struct c2_confc *client, const char *conf_source,
 	 * struct c2_conf_obj *root;
 	 *
 	 * C2_PRE(c2_mutex_is_locked(lock));
-	 * C2_PRE(!confc_is_initialized(client));
+	 * C2_PRE(!confc_is_initialized(confc));
 	 * C2_PRE(conf_source != NULL && *conf_source != 0);
 	 * C2_PRE(profile != NULL && *profile != 0);
 	 * C2_PRE(sm_group != NULL);
 	 *
 	 * c2_mutex_lock(&sm_group->s_lock);
-	 * client->cc_group = sm_group;
-	 * client->cc_lock = lock;
+	 * confc->cc_group = sm_group;
+	 * confc->cc_lock = lock;
 	 *
 	 * root = c2_conf_obj_new(C2_CO_PROFILE, &(const struct c2_conf_buf)
-	 *                        C2_CONF_BUF_INIT(strlen(profile), profile));
-	 * root->co_private = client;
-	 * c2_conf_map_init(&client->cc_registry);
-	 * c2_conf_map_add(&client->cc_registry, root);
-	 * client->cc_root = root;
+	 *                        C2_CONF_BUF_STR(profile));
+	 * root->co_confc = confc;
+	 * c2_conf_map_init(&confc->cc_registry);
+	 * c2_conf_map_add(&confc->cc_registry, root);
+	 * confc->cc_root = root;
 	 *
 	 * if (conf_source starts with "local-conf:")
-	 *     cache_preload(client, conf_source + strlen("local-conf:"));
+	 *     cache_preload(confc, conf_source + strlen("local-conf:"));
 	 * else
 	 *     XXX @todo setup confd connection;
 	 *
 	 * c2_mutex_unlock(&sm_group->s_lock);
-	 * C2_POST(equi(rc == 0, confc_is_initialized(client) &&
-	 *              client->cc_lock == lock));
+	 * C2_POST(equi(rc == 0, confc_is_initialized(confc) &&
+	 *              confc->cc_lock == lock));
 	 * return rc;
 	 */
 	XXX;
 }
 
-void c2_confc_fini(struct c2_confc *client)
+void c2_confc_fini(struct c2_confc *confc)
 {
 	/*
-	 * C2_PRE(c2_mutex_is_locked(client->cc_lock));
-	 * C2_PRE(confc_is_initialized(client));
+	 * C2_PRE(c2_mutex_is_locked(confc->cc_lock));
+	 * C2_PRE(confc_is_initialized(confc));
 	 *
-	 * c2_mutex_lock(&client->cc_group->s_lock);
+	 * c2_mutex_lock(&confc->cc_group->s_lock);
 	 *
-	 * for (obj in client->cc_registry) {
-	 *     C2_ASSERT(obj->co_nrefs == 0 &&
-	 *               obj->co_status != C2_CS_LOADING);
+	 * for (obj in confc->cc_registry) {
+	 *     C2_ASSERT(obj->co_nrefs == 0 && obj->co_status != C2_CS_LOADING);
 	 *     c2_free(obj);
 	 * }
-	 * c2_confc_map_fini(&client->cc_registry);
-	 * client->cc_root = NULL;
+	 * c2_confc_map_fini(&confc->cc_registry);
+	 * confc->cc_root = NULL;
 	 *
-	 * c2_mutex_unlock(&client->cc_group->s_lock);
-	 * client->cc_group = NULL;
-	 * client->cc_lock = NULL;
+	 * c2_mutex_unlock(&confc->cc_group->s_lock);
+	 * confc->cc_group = NULL;
+	 * confc->cc_lock = NULL;
 	 *
-	 * C2_POST(!confc_is_initialized(client));
+	 * C2_POST(!confc_is_initialized(confc));
 	 */
 	XXX;
 }
 
-int _open(struct c2_confc_ctx *ctx, struct c2_conf_obj *origin,
-	  const struct c2_conf_pathcomp *path, bool target_is_dir)
+static bool confc_invariant(const struct c2_confc *confc)
 {
-	bool isdir;
+	/* XXX add more checks */
+	return equi(confc->cc_root == NULL, confc->cc_group == NULL) &&
+		equi(confc->cc_root == NULL, confc->cc_lock == NULL);
+}
 
-	C2_PRE(confc_is_initialized(ctx->fc_client));
-	C2_PRE(ctx->fc_origin == NULL && ctx->fc_path == NULL);
+/* XXX TODO: .bt_check = confc_invariant */
+struct c2_bob_type c2_confc_bob = XXX;
 
-	if (origin == NULL)
-		origin = ctx->fc_client->cc_root;
-	C2_ASSERT(c2_conf_path_is_valid(origin, path, &isdir));
+static bool confc_is_initialized(const struct c2_confc *confc)
+{
+	C2_PRE(confc_invariant(confc));
+	return confc->cc_root != NULL;
+}
+
+/* ------------------------------------------------------------------
+ * c2_confc_ctx
+ * ------------------------------------------------------------------ */
 
-	if (isdir != target_is_dir)
-		return target_is_dir ? -ENOTDIR : -EISDIR;
+static void on_replied(struct c2_rpc_item *item);
+static bool on_object_updated(struct c2_clink *link);
 
-	ctx->fc_path = c2_conf_pathcomp_dup(path);
-	if (ctx->fc_path == NULL)
-		return -ENOMEM;
-	ctx->fc_origin = origin;
+/* XXX TODO: .bt_check = ctx_invariant */
+struct c2_bob_type c2_confc_ctx_bob = XXX;
 
-	ast_state_set(&ctx->fc_ast, S_CHECK);
-	return 0;
+/** States of c2_confc_ctx::fc_mach. */
+enum confc_ctx_state { S_INITIAL, S_CHECK, S_WAIT_REPLY, S_WAIT_STATUS,
+		       S_GROW_CACHE, S_FAILURE, S_TERMINAL, S_NR };
+
+static bool ctx_invariant(const struct c2_confc_ctx *ctx)
+{
+	const struct c2_rpc_item *item = &ctx->fc_fop.f_item;
+	return confc_is_initialized(ctx->fc_confc) &&
+		item->ri_type == &request_item_type &&
+		item->ri_ops != NULL &&
+		item->ri_ops->rio_replied == on_replied &&
+		ctx->fc_clink.cl_cb == on_object_updated &&
+		c2_fop_data(ctx->fc_fop) == &ctx->fc_req;
 }
 
-int c2__confc_open(struct c2_confc_ctx *ctx, struct c2_conf_obj *origin,
-		   const struct c2_conf_pathcomp *path)
+void c2_confc_ctx_init(struct c2_confc_ctx *ctx, struct c2_confc *confc)
 {
-	return _open(ctx, origin, path, false);
+	C2_PRE(confc_is_initialized(confc));
+
+	ctx->fc_confc = confc;
+	c2_sm_init(&ctx->fc_mach, &confc_ctx_states_conf, S_INITIAL,
+		   confc->cc_group, XXX /* *c2_addb_ctx */);
+	c2_chan_init(&ctx->fc_complete);
+	c2_clink_init(&ctx->fc_clink, on_object_updated);
+
+	C2_POST(ctx_invariant(ctx));
 }
 
-int c2__confc_open_sync(void **obj, struct c2_conf_obj *origin,
-			const struct c2_conf_pathcomp *path)
+void c2_confc_ctx_fini(struct c2_confc_ctx *ctx)
+{
+	size_t i;
+	C2_PRE(ctx_invariant(ctx));
+
+	c2_clink_fini(&ctx->fc_clink);
+	c2_chan_fini(&ctx->fc_complete);
+	c2_sm_fini(&ctx->fc_mach);
+	ctx->fc_confc = NULL;
+}
+
+struct c2_conf_obj *c2_confc_ctx_handout(struct c2_confc_ctx *ctx)
+{
+	XXX;
+}
+
+static inline struct c2_mutex *confc_lock(struct c2_confc_ctx *ctx)
+{
+	return ctx->fc_confc->cc_lock;
+}
+
+/* ------------------------------------------------------------------
+ * open/close
+ * ------------------------------------------------------------------ */
+
+static int path_store(const char *path, struct c2_conf_buf *dest, uint32_t len);
+static void ast_state_set(struct c2_sm_ast *ast, enum confc_ctx_state state);
+
+int c2_confc_open(struct c2_confc_ctx *ctx, struct c2_conf_obj *origin,
+                  const char *path)
+{
+	int rc;
+
+	C2_PRE(ctx_invariant(ctx));
+	C2_PRE(ergo(origin != NULL, origin->co_confc == ctx->fc_confc));
+	C2_PRE(ctx->fc_origin == NULL && XXX_is_zeroed(ctx->fc_path));
+
+	ctx->fc_origin = origin == NULL ? ctx->fc_confc->cc_root : origin;
+	rc = path_store(path, ctx->fc_path, ARRAY_SIZE(ctx->fc_path) - 1);
+	if (rc == 0)
+		ast_state_set(&ctx->fc_ast, S_CHECK);
+	return rc;
+}
+
+int c2_confc_open_sync(struct c2_conf_obj **result, struct c2_conf_obj *origin,
+                       const char *path)
 {
 	struct c2_confc_ctx ctx;
 	struct c2_clink     clink;
 	int                 rc;
-	struct c2_confc    *client;
 
 	C2_PRE(origin != NULL);
-	client = origin->co_private;
-	C2_PRE(XXX_bob_check(client));
-	C2_PRE(confc_is_initialized(client));
 
-	c2_confc_ctx_init(&ctx, client);
+	c2_confc_ctx_init(&ctx, origin->co_confc);
 	c2_clink_init(&clink, NULL);
 	c2_clink_add(&ctx.fc_complete, &clink);
 
-	rc = c2__confc_open(&ctx, origin, path);
+	rc = c2_confc_open(&ctx, origin, path);
 	if (rc == 0) {
 		c2_chan_wait(&clink);
-		*obj = ctx.fc_result;
-		if (*obj == NULL)
+		*result = c2_confc_ctx_handout(&ctx);
+		if (*result == NULL)
 			rc = c2_confc_error(&ctx);
 	}
 
@@ -728,171 +461,132 @@ int c2__confc_open_sync(void **obj, struct c2_conf_obj *origin,
 	return rc;
 }
 
-void c2_confc_close(void *obj)
+void c2_confc_close(struct c2_conf_obj *obj)
 {
 	if (obj != NULL) {
-		struct c2_conf_obj   *x = obj;
-		C2_ASSERT(XXX_bob_check(x));
-		const struct c2_confc *client = x->co_private;
-		C2_ASSERT(XXX_bob_check(client));
-
-		c2_mutex_lock(client->cc_lock);
-		C2_CNT_DEC(x->co_nrefs);
-		if (x->co_nrefs == 0)
-			c2_chan_broadcast(&x->co_chan);
-		c2_mutex_unlock(client->cc_lock);
+		c2_mutex_lock(obj->co_confc->cc_lock);
+		C2_CNT_DEC(obj->co_nrefs);
+		if (obj->co_nrefs == 0)
+			c2_chan_broadcast(&obj->co_chan);
+		c2_mutex_unlock(obj->co_confc->cc_lock);
 	}
 }
-
+
 /* ------------------------------------------------------------------
- * Directory operations.
+ * readdir
  * ------------------------------------------------------------------ */
 
-/** Collection of configuration objects. */
-struct c2_confc_dir {
-	/** The object owning this collection. */
-	struct c2_conf_obj       *d_parent;
-	/**
-	 * Pointer to the object that will be returned by
-	 * c2_confc_dirnext().
-	 */
-	struct c2_conf_obj       *d_cursor;
-	/** List descriptor. */
-	const struct c2_tl_descr *d_descr;
-};
-
-static int confc_dir_invariant(const struct c2_confc_dir *dir)
-{
-	XXX;
-}
-
-int c2__confc_diropen(struct c2_confc_ctx *ctx, struct c2_conf_obj *origin,
-		      const struct c2_conf_pathcomp *path)
-{
-	return _open(ctx, origin, path, true);
-}
-
-int c2__confc_diropen_sync(struct c2_confc_dir **dir,
-			   struct c2_conf_obj *origin,
-			   const struct c2_conf_pathcomp *path)
-{
-	XXX;
-}
-
-/**
- * Pointer to the "previously opened" object.
- *
- * Returns the pointer returned by the most recent
- * c2_confc_dirnext(dir) call.
- */
-static void * dir_prev_obj(const struct c2_confc_dir *dir)
-{
-	/*
-	 * Result is deduced dynamically from dir->d_descr and
-	 * dir->d_cursor.
-	 */
-	XXX;
-}
-
-const void * c2_confc_dirnext(struct c2_confc_dir *dir)
+int c2_confc_readdir(struct c2_confc_ctx *ctx, struct c2_conf_dircur *cur)
 {
-	/*
-	 * c2_confc_close() previously opened object.
-	 *
-	 * Return NULL if dir->d_cursor points to end-of-sequence.
-	 *
-	 * Otherwise, increment reference counter
-	 * (c2_conf_obj::co_nrefs) of the object pointed to by
-	 * dir->d_cursor, anvance the cursor, and return the object,
-	 * whose reference counter has been incremented.
-	 */
 	XXX;
 }
 
-void c2_confc_dirclose(struct c2_confc_dir *dir)
+int c2_confc_readdir_sync(struct c2_conf_obj **result,
+                          struct c2_conf_dircur *cur)
 {
-	/*
-	 * if (dir != NULL) {
-	 *     C2_PRE(dir->d_parent->co_nrefs > 0);
-	 *     c2_confc_close() previously opened object;
-	 *     c2_confc_close(dir->d_parent);
-	 * }
-	 */
 	XXX;
 }
-
+
 /* ------------------------------------------------------------------
- * Request-related functions.
+ * State definitions
  * ------------------------------------------------------------------ */
 
-static bool request_is_valid(const struct c2_conf_fetch *req)
-{
-	return  req->f_origin.oi_objtype < C2_CO_NR &&
-		req->f_origin.oi_objkey.cb_size > 0 &&
-		req->f_origin.oi_objkey.cb_data != NULL &&
-		equi(req->f_comps.ap_count == 0, req->f_comps.ap_elems == NULL);
-}
-
-/** Fills c2_conf_fetch structure. */
-static void
-request_fill(struct c2_conf_ctx *ctx, const struct c2_conf_obj *origin,
-	     const struct c2_conf_pathcomp *path)
-{
-	struct c2_conf_fetch *req = &ctx->fc_req;
-
-	C2_PRE(ctx_invariant(ctx));
-	C2_PRE(c2_mutex_is_locked(group_lock(ctx)));
-	C2_PRE(c2_mutex_is_locked(confc_lock(ctx)));
+static void check_st_in(struct c2_sm *mach);         /* S_CHECK */
+static void wait_reply_st_in(struct c2_sm *mach);    /* S_WAIT_REPLY */
+static void grow_cache_st_in(struct c2_sm *mach);    /* S_GROW_CACHE */
+static void completion_announce(struct c2_sm *mach); /* S_FAILURE, S_TERMINAL */
 
-	req->f_origin.oi_objtype = origin->co_type;
-	req->f_origin.oi_objkey = origin->co_key;
-	req->f_comps.ap_count = c2_conf_path_len(path);
-	req->f_comps.ap_elems = req->f_comps.ap_count == 0 ? NULL : path;
+static bool check_st_invariant(const struct c2_sm *mach);    /* S_CHECK */
+static bool failure_st_invariant(const struct c2_sm *mach);  /* S_FAILURE */
+static bool terminal_st_invariant(const struct c2_sm *mach); /* S_TERMINAL */
 
-	C2_POST(request_is_valid(req));
-}
+static const struct c2_sm_state_descr confc_ctx_states[S_NR] = {
+	[S_INITIAL] = {
+		.sd_flags     = C2_SDF_INITIAL,
+		.sd_name      = "INITIAL",
+		.sd_in        = NULL,
+		.sd_ex        = NULL,
+		.sd_invariant = NULL,
+		.sd_allowed   = 1 << S_CHECK
+	},
+	[S_CHECK] = {
+		.sd_flags     = 0,
+		.sd_name      = "CHECK",
+		.sd_in        = check_st_in,
+		.sd_ex        = NULL,
+		.sd_invariant = check_st_invariant,
+		.sd_allowed   = 1 << S_WAIT_REPLY | 1 << S_WAIT_STATUS
+			      | 1 << S_TERMINAL | 1 << S_FAILURE
+	},
+	[S_WAIT_REPLY] = {
+		.sd_flags     = 0,
+		.sd_name      = "WAIT_REPLY",
+		.sd_in        = wait_reply_st_in,
+		.sd_ex        = NULL,
+		.sd_invariant = NULL,
+		.sd_allowed   = 1 << S_GROW_CACHE | 1 << S_FAILURE
+	},
+	[S_WAIT_STATUS] = {
+		.sd_flags     = 0,
+		.sd_name      = "WAIT_STATUS",
+		.sd_in        = NULL
+		.sd_ex        = NULL,
+		.sd_invariant = NULL,
+		.sd_allowed   = 1 << S_CHECK
+	},
+	[S_GROW_CACHE] = {
+		.sd_flags     = 0,
+		.sd_name      = "GROW_CACHE",
+		.sd_in        = grow_cache_st_in,
+		.sd_ex        = NULL,
+		.sd_invariant = NULL,
+		.sd_allowed   = 1 << S_CHECK | 1 << S_FAILURE
+	},
+	[S_FAILURE] = {
+		.sd_flags     = C2_SDF_FAILURE,
+		.sd_name      = "FAILURE",
+		.sd_in        = completion_announce,
+		.sd_ex        = NULL,
+		.sd_invariant = failure_st_invariant,
+		.sd_allowed   = 0
+	},
+	[S_TERMINAL] = {
+		.sd_flags     = C2_SDF_TERMINAL,
+		.sd_name      = "TERMINAL",
+		.sd_in        = completion_announce,
+		.sd_ex        = NULL,
+		.sd_invariant = terminal_st_invariant,
+		.sd_allowed   = 0
+	}
+};
 
+static struct c2_sm_conf confc_ctx_states_conf = {
+	.scf_name      = "states of c2_confc_ctx::fc_mach",
+	.scf_nr_states = S_NR,
+	.scf_state     = confc_ctx_states
+};
+
 /* ------------------------------------------------------------------
  * State transitions.
+ *
+ * Note, that *_st_in() functions don't need to assert that the group
+ * lock is being hold.  This check is part of state machine invariant
+ * (c2_sm_invariant()), which is asserted when a state is entered (and
+ * left).
  * ------------------------------------------------------------------ */
 
-enum confc_state { S_INITIAL, S_CHECK, S_WAIT_REPLY, S_WAIT_STATUS,
-		   S_GROW_CACHE, S_FAILURE, S_TERMINAL, S_NR };
-
-static void _state_set(struct c2_sm_group *grp __attribute__((unused)),
-		       struct c2_sm_ast *ast)
-{
-	c2_sm_state_set(&ast_to_ctx(ast)->fc_mach,
-			(enum confc_state)ast->sa_datum);
-}
-
-static void _fail(struct c2_sm_group *grp __attribute__((unused)),
-		  struct c2_sm_ast *ast)
-{
-	c2_sm_fail(&ast_to_ctx(ast)->fc_mach, S_FAILURE,
-		   (int32_t)ast->sa_datum);
-}
-
-/** Posts an AST that will advance the state machine to given state. */
-static void ast_state_set(struct c2_sm_ast *ast, enum confc_state state)
-{
-	ast->sa_cb = _state_set;
-	ast->sa_datum = state;
-	c2_sm_ast_post(ast_to_ctx(ast)->fc_client->cc_group, ast);
-}
-
-/** Posts an AST that will move the state machine to S_FAILURE state. */
-static void ast_fail(struct c2_sm_ast *ast, int32_t rc)
-{
-	ast->sa_cb = _fail;
-	ast->sa_datum = rc;
-	c2_sm_ast_post(ast_to_ctx(ast)->fc_client->cc_group, ast);
-}
+static int path_walk(struct c2_confc_ctx *ctx);
+static bool request_is_valid(const struct c2_conf_fetch *req);
+static struct c2_confc_ctx *mach_to_ctx(struct c2_sm *mach);
+static const struct c2_confc_ctx *const_mach_to_ctx(const struct c2_sm *mach);
+static void ast_fail(struct c2_sm_ast *ast, int32_t rc);
+static int
+cache_grow(struct c2_conf_map *cache, const struct c2_conf_fetch_resp *resp);
 
-/** Actions to perform on entering CHECK state. */
+/** Actions to perform on entering S_CHECK state. */
 static void check_st_in(struct c2_sm *mach)
 {
-	static const int st[] = {
+	static const int next_state[] = {
 		[C2_CS_MISSING] = S_WAIT_REPLY,
 		[C2_CS_LOADING] = S_WAIT_STATUS,
 		[C2_CS_READY]   = S_TERMINAL
@@ -900,33 +594,28 @@ static void check_st_in(struct c2_sm *mach)
 	int rc;
 	struct c2_confc_ctx *ctx = mach_to_ctx(mach);
 
-	C2_PRE(c2_mutex_is_locked(group_lock(ctx)));
-
 	rc = path_walk(ctx);
 	if (rc < 0)
 		c2_sm_fail(mach, S_FAILURE, rc);
-	else if (IS_IN_ARRAY(rc, st))
-		c2_sm_state_set(mach, st[rc]);
+	else if (IS_IN_ARRAY(rc, next_state))
+		c2_sm_state_set(mach, next_state[rc]);
 	else
 		C2_IMPOSSIBLE("path_walk: invalid result");
-
-	C2_POST(c2_mutex_is_locked(group_lock(ctx)));
 }
 
-/** Actions to perform on entering WAIT_REPLY state. */
+/** Actions to perform on entering S_WAIT_REPLY state. */
 static void wait_reply_st_in(struct c2_sm *mach)
 {
 	int rc;
 	struct c2_confc_ctx *ctx = mach_to_ctx(mach);
 
 	C2_PRE(request_is_valid(ctx->fc_req));
-	C2_PRE(c2_mutex_is_locked(group_lock(ctx)));
 
 	rc = c2_rpc_post(&ctx->fc_fop.f_item);
 	C2_ASSERT(rc == 0); /* c2_rpc_post() always returns 0, but hey */
 }
 
-/** Actions to perform on entering GROW_CACHE state. */
+/** Actions to perform on entering S_GROW_CACHE state. */
 static void grow_cache_st_in(struct c2_sm *mach)
 {
 	/*
@@ -935,16 +624,15 @@ static void grow_cache_st_in(struct c2_sm *mach)
 	 * struct c2_confc_ctx       *ctx  = mach_to_ctx(mach);
 	 * struct c2_rpc_item        *item = c2_fop_to_rpc_item(&ctx->fc_fop);
 	 *
-	 * C2_PRE(c2_mutex_is_locked(group_lock(ctx)));
 	 * C2_PRE(item->ri_error == 0 && item->ri_reply != NULL);
 	 *
 	 * resp = c2_fop_data(c2_rpc_item_to_fop(item->ri_reply));
 	 * C2_ASSERT(`resp' bob_check()s);
 	 *
-	 * rc = resp->fr_rc ?: cache_grow(&ctx->fc_client->cc_registry, resp);
+	 * rc = resp->fr_rc ?: cache_grow(&ctx->fc_confc->cc_registry, resp);
 	 *
 	 * // Let rpc layer free the memory allocated for response.
-	 * c2_rpc_item_put(item->ri_reply);
+	 * c2_rpc_item_put(item->ri_reply); // XXX
 	 *
 	 * if (rc == 0)
 	 *         c2_sm_state_set(mach, S_CHECK);
@@ -954,41 +642,40 @@ static void grow_cache_st_in(struct c2_sm *mach)
 	XXX;
 }
 
+/** Action to perform on entering S_TERMINAL or S_FAILURE state. */
 static void completion_announce(struct c2_sm *mach)
 {
 	c2_chan_broadcast(&mach_to_ctx(mach)->fc_complete);
 }
 
-static bool failure_st_invariant(const struct c2_sm *mach)
+static bool check_st_invariant(const struct c2_sm *mach)
 {
-	const struct c2_confc_ctx *ctx = mach_to_const_ctx(mach);
-	return ctx->fc_result == NULL && ctx->fc_mach.sm_rc < 0;
+	const struct c2_confc_ctx *ctx = const_mach_to_ctx(mach);
+	return mach->sm_rc == 0 && ctx->fc_result == NULL &&
+		ctx_invariant(ctx);
 }
 
-static bool terminal_st_invariant(const struct c2_sm *mach)
+static bool failure_st_invariant(const struct c2_sm *mach)
 {
-	return mach->sm_rc == 0 && mach_to_const_ctx(mach)->fc_result != NULL;
+	const struct c2_confc_ctx *ctx = const_mach_to_ctx(mach);
+	return ctx->fc_result == NULL && ctx->fc_mach.sm_rc < 0;
 }
 
-static bool check_st_invariant(const struct c2_sm *mach)
+static bool terminal_st_invariant(const struct c2_sm *mach)
 {
-	const struct c2_confc_ctx *ctx = mach_to_const_ctx(mach);
-	return mach->sm_rc == 0 && ctx->fc_result == NULL &&
-		ctx_invariant(ctx) && ctx->fc_extra == NULL;
+	return mach->sm_rc == 0 && const_mach_to_ctx(mach)->fc_result != NULL;
 }
 
-/** Handles `RPC replied' event, i.e. response arrival or an error. */
+/** Handles `RPC replied' event (i.e. response arrival or an error). */
 static void on_replied(struct c2_rpc_item *item)
 {
-	struct c2_confc_ctx *ctx;
-
+	struct c2_confc_ctx *ctx = bob_of(c2_rpc_item_to_fop(item),
+					  struct c2_confc_ctx, fc_fop,
+					  &c2_confc_ctx_bob);
 	C2_PRE(item->ri_type == &request_item_type);
-	ctx = container_of(c2_rpc_item_to_fop(item), struct c2_confc_ctx,
-			   fc_fop);
-	C2_ASSERT(ctx_invariant(ctx));
 
 	if (item->ri_error == 0) {
-		c2_rpc_item_get(item->ri_reply);
+		c2_rpc_item_get(item->ri_reply); /* XXX */
 		ast_state_set(&ctx->fc_ast, S_GROW_CACHE);
 	} else {
 		ast_fail(&ctx->fc_ast, item->ri_error);
@@ -998,115 +685,235 @@ static void on_replied(struct c2_rpc_item *item)
 /** Handles `object loading completed' and `object unpinned' events. */
 static bool on_object_updated(struct c2_clink *link)
 {
-	uint32_t i;
-	struct c2_confc_ctx *ctx =
-		container_of(link->cl_group, struct c2_confc_ctx, fc_clink);
-
-	C2_PRE(ctx_invariant(ctx));
+	struct c2_confc_ctx *ctx = bob_of(link->cl_group, struct c2_confc_ctx,
+					  fc_clink, &c2_confc_ctx_bob);
 	C2_PRE(c2_mutex_is_locked(confc_lock(ctx)));
 
-	for (i = 0; i < ctx->fc_nr_extra; ++i)
-		c2_clink_del(ctx->fc_extra + i);
-	c2_clink_del(&ctx->fc_clink); /* group head is de-registered last */
-	extra_clinks_destroy(ctx);
-
+	c2_clink_del(&ctx->fc_clink);
 	ast_state_set(&ctx->fc_ast, S_CHECK);
 	return true; /* event is consumed */
 }
+
+/* ------------------------------------------------------------------
+ * Walkies.
+ *
+ *         They're "Techno Trousers". Ex-NASA. Fantastic for walkies!
+ * ------------------------------------------------------------------ */
 
-static const struct c2_sm_state_descr confc_states[S_NR] = {
-	[S_INITIAL] = {
-		.sd_flags     = C2_SDF_INITIAL,
-		.sd_name      = "INITIAL",
-		.sd_in        = NULL,
-		.sd_ex        = NULL,
-		.sd_invariant = NULL,
-		.sd_allowed   = 1 << S_CHECK
-	},
-	[S_CHECK] = {
-		.sd_flags     = 0,
-		.sd_name      = "CHECK",
-		.sd_in        = check_st_in,
-		.sd_ex        = NULL,
-		.sd_invariant = check_st_invariant,
-		.sd_allowed   = 1 << S_WAIT_REPLY | 1 << S_WAIT_STATUS
-			      | 1 << S_TERMINAL | 1 << S_FAILURE
-	},
-	[S_WAIT_REPLY] = {
-		.sd_flags     = 0,
-		.sd_name      = "WAIT_REPLY",
-		.sd_in        = wait_reply_st_in,
-		.sd_ex        = NULL,
-		.sd_invariant = NULL,
-		.sd_allowed   = 1 << S_GROW_CACHE | 1 << S_FAILURE
-	},
-	[S_WAIT_STATUS] = {
-		.sd_flags     = 0,
-		.sd_name      = "WAIT_STATUS",
-		.sd_in        = NULL
-		.sd_ex        = NULL,
-		.sd_invariant = NULL,
-		.sd_allowed   = 1 << S_CHECK
-	},
-	[S_GROW_CACHE] = {
-		.sd_flags     = 0,
-		.sd_name      = "GROW_CACHE",
-		.sd_in        = grow_cache_st_in,
-		.sd_ex        = NULL,
-		.sd_invariant = NULL,
-		.sd_allowed   = 1 << S_CHECK | 1 << S_FAILURE
-	},
-	[S_FAILURE] = {
-		.sd_flags     = C2_SDF_FAILURE,
-		.sd_name      = "FAILURE",
-		.sd_in        = completion_announce,
-		.sd_ex        = NULL,
-		.sd_invariant = failure_st_invariant,
-		.sd_allowed   = 0
-	},
-	[S_TERMINAL] = {
-		.sd_flags     = C2_SDF_TERMINAL,
-		.sd_name      = "TERMINAL",
-		.sd_in        = completion_announce,
-		.sd_ex        = NULL,
-		.sd_invariant = terminal_st_invariant,
-		.sd_allowed   = 0
+static bool group_is_locked(struct c2_confc_ctx *ctx);
+static int path_walk_complete(struct c2_confc_ctx *ctx, struct c2_conf_obj *obj,
+			      size_t ri);
+static void request_fill(struct c2_conf_ctx *ctx, const struct c2_conf_obj *org,
+			 size_t ri);
+
+/**
+ * Follows the path, checking statuses of met objects.
+ *
+ * @retval C2_CS_READY    Path target is reachable.
+ *
+ * @retval C2_CS_MISSING  At least one of the intermediate objects or
+ *                        the target itself is C2_CS_MISSING.
+ *                        path_walk() changes statuses of such objects
+ *                        to C2_CS_LOADING and fills ctx->fc_req.
+ *
+ * @retval C2_CS_LOADING  Neither path target nor missing objects can
+ *                        be reached because of C2_CS_LOADING object
+ *                        blocking the path.  path_walk() registers
+ *                        ctx->fc_clink with the channel of loading
+ *                        object.
+ *
+ * @retval -ENOENT        ctx->fc_path refers to a nonexistent object.
+ *
+ * @see @ref confc-lspec-state
+ */
+static int path_walk(struct c2_confc_ctx *ctx)
+{
+	int                 ret;
+	struct c2_conf_obj *obj;
+	size_t              ri;
+
+	C2_PRE(group_is_locked(ctx));
+	C2_PRE(ctx->fc_origin != NULL);
+
+	c2_mutex_lock(confc_lock(ctx));
+
+	for (ret = 0, obj = ctx->fc_origin, ri = 0;
+	     ret == 0 && obj->co_status == C2_CS_READY &&
+		     !XXX_is_eop(&ctx->fc_path[ri]);
+	     ++ri)
+		ret = obj->co_ops->coo_lookup(obj, &ctx->fc_path[ri], &obj);
+
+	if (ret == 0) {
+		/*
+		 * XXX Confc is operating in offline mode: all the
+		 * necessary configuration data has been pre-loaded by
+		 * this point.
+		 *
+		 * This assertion must be deleted when confd component
+		 * is operational (i.e., is landed into origin/master
+		 * and can serve confc requests).
+		 */
+		C2_ASSERT(obj->co_status == C2_CS_READY);
+
+		ret = path_walk_complete(ctx, obj, ri);
 	}
-};
 
-static struct c2_sm_conf confc_states_conf = {
-	.scf_name      = "confc states",
-	.scf_nr_states = S_NR,
-	.scf_state     = confc_states
-};
+	c2_mutex_unlock(confc_lock(ctx));
+	C2_POST(group_is_locked(ctx));
+	return ret;
+}
+
+/**
+ * Applies results of a path walk.
+ *
+ * @returns original status of the reached configuration object.
+ *
+ * @param ctx  Configuration retrieval context.
+ * @param obj  The object reached by a path walk.
+ * @param ri   The position in ctx->fc_path[] where the remaining (not
+ *             followed) path components start.
+ */
+static int
+path_walk_complete(struct c2_confc_ctx *ctx, struct c2_conf_obj *obj, size_t ri)
+{
+	C2_PRE(group_is_locked(ctx));
+	C2_PRE(c2_mutex_is_locked(confc_lock(ctx)));
+
+	switch (obj->co_status) {
+	case C2_CS_READY:
+		C2_ASSERT(XXX_is_eop(&ctx->fc_path[ri]));
+		C2_CNT_INC(obj->co_nrefs);
+		ctx->fc_result = obj;
+		return C2_CS_READY;
+
+	case C2_CS_MISSING:
+		request_fill(ctx, obj, ri);
+		obj->co_status = C2_CS_LOADING;
+		return C2_CS_MISSING;
+
+	case C2_CS_LOADING:
+		c2_clink_add(&obj->co_chan, &ctx->fc_clink);
+		return C2_CS_LOADING;
+
+	default:
+		C2_IMPOSSIBLE("Invalid object status");
+	}
+	return -1; /* never reached */
+}
+
+/* ------------------------------------------------------------------
+ * Casts to c2_confc_ctx
+ * ------------------------------------------------------------------ */
+
+static struct c2_confc_ctx *mach_to_ctx(struct c2_sm *mach)
+{
+	struct c2_confc_ctx *ctx = bob_of(mach, struct c2_confc_ctx, fc_mach,
+					  &c2_confc_ctx_bob);
+	return ctx;
+}
+
+static const struct c2_confc_ctx *const_mach_to_ctx(const struct c2_sm *mach)
+{
+	const struct c2_confc_ctx *ctx = bob_of(mach, const struct c2_confc_ctx,
+						fc_mach, &c2_confc_ctx_bob);
+	return ctx;
+}
+
+static struct c2_confc_ctx *ast_to_ctx(struct c2_sm_ast *ast)
+{
+	struct c2_confc_ctx *ctx = bob_of(ast, struct c2_confc_ctx, fc_ast,
+					  &c2_confc_ctx_bob);
+	return ctx;
+}
+
+/* ------------------------------------------------------------------
+ * AST
+ * ------------------------------------------------------------------ */
+
+static void _state_set(struct c2_sm_group *grp __attribute__((unused)),
+		       struct c2_sm_ast *ast)
+{
+	c2_sm_state_set(&ast_to_ctx(ast)->fc_mach,
+			(enum confc_ctx_state)ast->sa_datum);
+}
+
+static void _fail(struct c2_sm_group *grp __attribute__((unused)),
+		  struct c2_sm_ast *ast)
+{
+	c2_sm_fail(&ast_to_ctx(ast)->fc_mach, S_FAILURE,
+		   (int32_t)ast->sa_datum);
+}
+
+/** Posts an AST that will advance the state machine to given state. */
+static void ast_state_set(struct c2_sm_ast *ast, enum confc_ctx_state state)
+{
+	ast->sa_cb = _state_set;
+	ast->sa_datum = state;
+	c2_sm_ast_post(ast_to_ctx(ast)->fc_confc->cc_group, ast);
+}
 
+/** Posts an AST that will move the state machine to S_FAILURE state. */
+static void ast_fail(struct c2_sm_ast *ast, int32_t rc)
+{
+	ast->sa_cb = _fail;
+	ast->sa_datum = rc;
+	c2_sm_ast_post(ast_to_ctx(ast)->fc_confc->cc_group, ast);
+}
+
 /* ------------------------------------------------------------------
- * Configuration cache management.
+ * Configuration cache management
  * ------------------------------------------------------------------ */
 
+/** Adds objects, described by a configuration string, to the cache. */
+static int cache_preload(struct c2_confc *confc, const char *conf_str)
+{
+	/*
+	 * // 4096 bytes (kernel module option) / 64 = 64 bytes (per object)
+	 * static struct confx_object objs[64];
+	 * int rc;
+	 * int i;
+	 *
+	 * C2_PRE(c2_mutex_is_locked(confc->cc_lock));
+	 *
+	 * rc = c2_conf_parse(conf_str, objs, ARRAY_SIZE(objs));
+	 * for (i = rc - 1; i >= 0; --i) {
+	 *     rc = cache_add(&confc->cc_registry, objs + i);
+	 *     if (rc != 0)
+	 *         break;
+	 * }
+	 * return rc;
+	 */
+	XXX;
+}
+
+static inline struct c2_confc *registry_to_confc(struct c2_conf_map *reg)
+{
+	return bob_of(reg, struct c2_confc, cc_registry, &c2_confc_bob);
+}
+
 /**
  * Allocates new configuration object and sets its fields from the
  * on-wire data.
  *
- * @param cache  Registry of cached configuration objects.
- * @param src    Configuration object as received from confd.
+ * @param reg     Registry of cached configuration objects.
+ * @param onwire  Configuration object as received from confd.
  */
-static int cache_add(struct c2_conf_map *cache, const struct confx_object *src)
+static int cache_add(struct c2_conf_map *reg, const struct confx_object *onwire)
 {
 	/*
-	 * struct c2_conf_obj *obj;
 	 * int                 ret;
-	 * struct c2_confc    *client = registry_to_client(cache);
+	 * struct c2_conf_obj *obj;
+	 * struct c2_confc    *confc = registry_to_confc(reg);
 	 *
-	 * C2_PRE(c2_mutex_is_locked(client->cc_lock));
+	 * C2_PRE(c2_mutex_is_locked(confc->cc_lock));
 	 *
-	 * obj = c2_conf_obj_new(src->o_val.ov_type, &src->o_key);
+	 * obj = c2_conf_obj_new(onwire->o_conf.u_type, &onwire->o_id);
 	 * if (obj == NULL)
 	 *     return -ENOMEM;
-	 * obj->co_private = client;
+	 * obj->co_confc = confc;
 	 *
-	 * ret = c2_conf_obj_fill(obj, src, cache);
-	 * ret = ?: c2_conf_map_add(cache, obj);
+	 * ret = c2_conf_obj_fill(obj, onwire, reg);
+	 * ret = ?: c2_conf_map_add(reg, obj);
 	 *
 	 * if (ret != 0)
 	 *     c2_free(obj);
@@ -1117,24 +924,25 @@ static int cache_add(struct c2_conf_map *cache, const struct confx_object *src)
 
 static int object_enrich(struct c2_conf_obj *dest,
 			 const struct confx_object *src,
-			 struct c2_conf_map *cache)
+			 struct c2_conf_map *reg)
 {
 	/*
 	 * int ret;
 	 *
-	 * C2_PRE(dest->co_type == src->fo_val.v_type);
-	 * C2_PRE(c2_mutex_is_locked(registry_to_client(cache)->cc_lock));
+	 * C2_PRE(dest->co_type == src->o_conf.v_type);
+	 * C2_PRE(c2_mutex_is_locked(registry_to_confc(reg)->cc_lock));
 	 *
-	 * if (c2_conf_obj_mismatch(dest, src)) {
+	 * if (!c2_conf_obj_match(dest, src)) {
 	 *     C2_ADDB_ADD(report inconsistency);
-	 *     ret = -EPROTO;
-	 * } else if (dest->co_status == C2_CS_READY) {
-	 *     return 0; // neither change the status nor broadcast
-	 * } else {
-	 *     ret = c2_conf_obj_fill(dest, src, cache);
+	 *     return -EPROTO;
 	 * }
 	 *
-	 * obj->co_status = ret == 0 ? C2_CS_READY : C2_CS_MISSING;
+	 * if (dest->co_status == C2_CS_READY)
+	 *     return 0; // neither change the status nor broadcast
+	 *
+	 * ret = c2_conf_obj_fill(dest, src, reg);
+	 * if (ret != 0)
+	 *     obj->co_status = C2_CS_MISSING;
 	 * c2_chan_broadcast(&dest->co_chan);
 	 * return ret;
 	 */
@@ -1148,128 +956,117 @@ static int object_enrich(struct c2_conf_obj *dest,
  * @pre  resp->fr_rc == 0
  */
 static int
-cache_grow(struct c2_conf_map *cache, const struct c2_conf_fetch_resp *resp)
+cache_grow(struct c2_conf_map *reg, const struct c2_conf_fetch_resp *resp)
 {
 	/*
-	 * struct confx_object *fetched;
-	 * struct c2_conf_obj  *cached;
 	 * int                  ret;
-	 * struct c2_confc     *cli = registry_to_client(cache);
+	 * struct confx_object *onwire;
+	 * struct c2_conf_obj  *cached;
+	 * struct c2_confc     *confc = registry_to_confc(reg);
 	 *
 	 * C2_PRE(resp->fr_rc == 0);
-	 * C2_PRE(c2_mutex_is_locked(&cli->cc_group->s_lock));
+	 * C2_PRE(c2_mutex_is_locked(&confc->cc_group->s_lock));
 	 *
-	 * c2_mutex_lock(cli->cc_lock);
+	 * c2_mutex_lock(confc->cc_lock);
 	 *
-	 * for (fetched in resp->fr_data) {
-	 *     if (fetched->o_key.cb_size == 0 ||
-	 *         fetched->o_key.cb_data == NULL) {
+	 * for (onwire in resp->fr_data) {
+	 *     if (onwire->o_id.cb_size == 0 ||
+	 *         onwire->o_id.cb_data == NULL) {
 	 *         C2_ADDB_ADD(report bogus data);
 	 *         ret = -Exxx;
 	 *         break;
 	 *     }
 	 *
-	 *     cached = c2_conf_map_lookup(cache, &fetched->o_key,
-	 *                                 fetched->o_val.ov_type);
+	 *     cached = c2_conf_map_lookup(reg, &onwire->o_id,
+	 *                                 onwire->o_conf.u_type);
 	 *     if (cached == NULL)
-	 *         ret = cache_add(cache, fetched);
+	 *         ret = cache_add(reg, onwire);
 	 *     else
-	 *         ret = object_enrich(cached, fetched, cache);
+	 *         ret = object_enrich(cached, onwire, reg);
 	 *
 	 *     if (ret != 0)
 	 *         break;
 	 * }
 	 *
-	 * c2_mutex_unlock(cli->cc_lock);
+	 * c2_mutex_unlock(confc->cc_lock);
 	 * return ret;
 	 */
 	XXX;
 }
+
+/* ------------------------------------------------------------------
+ * misc
+ * ------------------------------------------------------------------ */
+
+static bool group_is_locked(struct c2_confc_ctx *ctx)
+{
+	return c2_mutex_is_locked(&ctx->fc_confc->cc_group->s_lock);
+}
 
-static int cache_preload(struct c2_confc *client, const char *conf_str)
+/**
+ * Finds position and length of each path component and stores this
+ * information in an array of c2_conf_bufs.
+ *
+ * @param path  Path string. It consists of path components separated by
+ *              slash ('/').
+ * @param dest  Array to put path components information into.
+ * @param len   Maximum number of elements to store.
+ *
+ * @note  Escape sequences are not supported. E.g., "one/two/thre\/e"
+ *        has four path components, not three.
+ *
+ * XXX @todo c2_conf_buf::cb_data and `path' are not const-compatible.
+ *     Such an assignment will result in compilation error:
+ *         dest[i]->cb_data = path + n;
+ *     Requirements: I do want `path' to be const, but I'd prefer to
+ *     avoid strdup(3)ing it.
+ */
+static int path_store(const char *path, struct c2_conf_buf *dest, uint32_t len)
 {
 	/*
-	 * // 4096 bytes (kernel module option) / 64 = 64 bytes (per object)
-	 * static struct confx_object objs[64];
-	 * int rc;
-	 * int i;
+	 * Return -ENAMETOOLONG if path has more than len components.
 	 *
-	 * C2_PRE(c2_mutex_is_locked(client->cc_lock));
-	 *
-	 * rc = c2_conf_parse(conf_str, objs, ARRAY_SIZE(objs));
-	 * for (i = rc - 1; i >= 0; --i) {
-	 *     rc = cache_add(&client->cc_registry, objs + i);
-	 *     if (rc != 0)
-	 *         break;
-	 * }
-	 * return rc;
+	 * UT:
+	 *   - trailing slash is ignored ("abc/"  --- one component);
+	 *   - multiple slashes are error ("abc//");
+	 *   - leading slash is error ("/abc").
 	 */
 	XXX;
 }
 
-/* ------------------------------------------------------------------
- * c2_confc_ctx
- * ------------------------------------------------------------------ */
-
-void c2_confc_ctx_init(struct c2_confc_ctx *ctx, struct c2_confc *client)
+static bool request_is_valid(const struct c2_conf_fetch *req)
 {
-	C2_PRE(confc_is_initialized(confc));
-
-	ctx->fc_client = confc;
-	c2_sm_init(&ctx->fc_mach, &confc_states_conf, S_INITIAL,
-		   confc->cc_group, XXX /* *c2_addb_ctx */);
-	c2_chan_init(&ctx->fc_complete);
-	c2_clink_init(&ctx->fc_clink, on_object_updated);
-	ctx->fc_extra = NULL;
-	ctx->fc_nr_extra = 0;
-
-	C2_POST(ctx_invariant(ctx));
+	return  req->f_origin.oi_type < C2_CO_NR &&
+		req->f_origin.oi_id.cb_size > 0 &&
+		req->f_origin.oi_id.cb_data != NULL &&
+		equi(req->f_path.ab_count == 0, req->f_path.ab_elems == NULL);
 }
 
-void c2_confc_ctx_fini(struct c2_confc_ctx *ctx)
+/**
+ * Fills c2_conf_fetch structure.
+ *
+ * @param ctx  Configuration retrieval context.
+ * @param org  Origin of the path being sent to confd.
+ * @param ri   The position (in ctx->fc_path[]) that starts the path
+ *             being sent to confd.
+ */
+static void
+request_fill(struct c2_conf_ctx *ctx, const struct c2_conf_obj *org, size_t ri)
 {
-	size_t i;
-	C2_PRE(ctx_invariant(ctx));
+	uint32_t              len;
+	struct c2_conf_fetch *req = &ctx->fc_req;
 
-	c2_clink_fini(&ctx->fc_clink);
-	extra_clinks_destroy(ctx);
-	c2_chan_fini(&ctx->fc_complete);
-	c2_sm_fini(&ctx->fc_mach);
-	ctx->fc_client = NULL;
-}
+	C2_PRE(ctx_invariant(ctx));
 
-static bool ctx_invariant(const struct c2_confc_ctx *ctx)
-{
-	const struct c2_rpc_item *item = &ctx->fc_fop.f_item;
-	return XXX_bob_check(ctx->fc_client) &&
-		c2_conf_path_is_valid(ctx->fc_origin, ctx->fc_path, NULL) &&
-		item->ri_type == &request_item_type &&
-		item->ri_ops != NULL &&
-		item->ri_ops->rio_replied == on_replied &&
-		c2_fop_data(ctx->fc_fop) == &ctx->fc_req &&
-		equi(ctx->fc_extra == NULL, ctx->fc_nr_extra == 0);
-}
+	req->f_origin.oi_type = org->co_type;
+	req->f_origin.oi_id = org->co_id;
 
-/* ------------------------------------------------------------------
- * misc
- * ------------------------------------------------------------------ */
+	for (len = 0; !XXX_is_eop(&ctx->fc_path[ri + len]); ++len)
+		; /* measure path length */
+	req->f_path.ab_count = len;
+	req->f_path.ab_elems = len == 0 ? NULL : &ctx->fc_path[ri];
 
-static enum c2_conf_status
-list_status(const struct c2_tl_descr *descr, const struct c2_tl *list,
-	    int *nr_loading)
-{
-	/*
-	 * if (there are C2_CS_MISSING objects) {
-	 *     change their statuses to C2_CS_LOADING;
-	 *     return C2_CS_MISSING;
-	 * } else if (there are C2_CS_LOADING objects) {
-	 *     *nr_loading = the number of C2_CS_LOADING objects;
-	 *     return C2_CS_LOADING;
-	 * } else {
-	 *     return C2_CS_READY;
-	 * }
-	 */
-	XXX;
+	C2_POST(request_is_valid(req));
 }
 
 /** @} confc_dlspec */
diff --git a/conf/confc.h b/conf/confc.h
index d863a36..ccc2b8c 100644
--- a/conf/confc.h
+++ b/conf/confc.h
@@ -61,10 +61,10 @@ struct c2_mutex;
  *   created by this confc.
  *
  * - c2_confc_ctx --- configuration retrieval context.
- *   This structure embodies data needed by a confc state machine to
- *   process configuration request.  Its ->fc_complete member is a
- *   channel that is signaled when the configuration retrieval
- *   operation completes.
+ *   This structure embodies data needed by a state machine to process
+ *   configuration request.  Its ->fc_complete member is a channel
+ *   that is signaled when the configuration retrieval operation
+ *   completes.
  *
  * <hr> <!------------------------------------------------------------>
  * @section confc-fspec-sub Subroutines
@@ -329,6 +329,11 @@ struct c2_mutex;
  * @{
  */
 
+enum {
+	C2_CONFC_MAGIX     = XXX,
+	C2_CONFC_CTX_MAGIX = XXX
+};
+
 /* ------------------------------------------------------------------
  * confc instance
  * ------------------------------------------------------------------ */
@@ -339,7 +344,10 @@ struct c2_confc {
 	struct c2_conf_map  cc_registry;
 	/** Root of the DAG of configuration objects. */
 	struct c2_conf_obj *cc_root;
-	/** Serializes confc state machines. */
+	/**
+	 * Serializes configuration retrieval state machines
+	 * (c2_confc_ctx::fc_mach).
+	 */
 	struct c2_sm_group *cc_group;
 	/**
 	 * Confc lock (aka cache lock).
@@ -348,23 +356,24 @@ struct c2_confc {
 	 * objects from concurrent modifications.  The mutex itself is
 	 * owned by an external entity (e.g., the application).
 	 *
-	 * ->cc_group ensures that there are no concurrent state
-	 * transitions. But it has no influence on the application,
-	 * which may modify configuration cache by calling
-	 * c2_confc_close() or c2_confc_fini(). Thus group lock alone
-	 * is not enough.
+	 * Rationale: while ->cc_group ensures that there are no
+	 * concurrent state transitions, it has no influence on the
+	 * application, which may modify configuration cache by
+	 * calling c2_confc_close() or c2_confc_fini().
 	 *
-	 * If both locks are needed, group lock must be acquired first.
+	 * If both group and cache locks are needed, group lock must
+	 * be acquired first.
 	 *
 	 * @see confc-lspec-thread
 	 */
 	struct c2_mutex    *cc_lock;
 };
+extern struct c2_bob_type c2_confc_bob;
 
 /**
  * Initializes configuration client.
  *
- * @param client       A confc instance to be initialized.
+ * @param confc        A confc instance to be initialized.
  * @param conf_source  End point address of configuration server (confd).
  *                     If the value is prefixed with "local-conf:", it
  *                     is a configuration string --- ASCII description
@@ -376,10 +385,10 @@ struct c2_confc {
  * @param lock         A mutex that will protect this c2_confc instance and
  *                     its configuration cache from concurrent modifications.
  *
- * @pre   c2_mutex_is_locked(lock) && client->cc_lock == NULL
- * @post  equi(retval == 0, client->cc_lock == lock)
+ * @pre   c2_mutex_is_locked(lock) && confc->cc_lock == NULL
+ * @post  equi(retval == 0, confc->cc_lock == lock)
  */
-int c2_confc_init(struct c2_confc *client, const char *conf_source,
+int c2_confc_init(struct c2_confc *confc, const char *conf_source,
 		  const char *profile, struct c2_sm_group *sm_group,
 		  struct c2_mutex *lock);
 
@@ -395,9 +404,9 @@ int c2_confc_init(struct c2_confc *client, const char *conf_source,
  *       ->fc_complete channel has not been signaled yet.
  *
  * @pre  There are no opened (pinned) configuration objects.
- * @pre  c2_mutex_is_locked(client->cc_lock)
+ * @pre  c2_mutex_is_locked(confc->cc_lock)
  */
-void c2_confc_fini(struct c2_confc *client);
+void c2_confc_fini(struct c2_confc *confc);
 
 /* ------------------------------------------------------------------
  * context
@@ -421,7 +430,7 @@ struct c2_confc_ctx {
 	 */
 	struct c2_conf_obj      *fc_result;
 	/** The confc instance this context belongs to. */
-	struct c2_confc         *fc_client;
+	struct c2_confc         *fc_confc;
 	/** Context state machine. */
 	struct c2_sm             fc_mach;
 	/**
@@ -443,25 +452,19 @@ struct c2_confc_ctx {
 	/**
 	 * Record of interest in `object loading completed' or
 	 * `object unpinned' events.
-	 *
-	 * The head of clink group comprising ->fc_extra clinks and itself.
 	 */
 	struct c2_clink          fc_clink;
-	/**
-	 * Array of additional clinks.
-	 *
-	 * This array is dynamically allocated when there are several
-	 * configuration objects to wait for.  Elements of ->fc_extra
-	 * are c2_clink_attach()ed to ->fc_clink.
-	 *
-	 * @see `Multiple channels' section in @ref chan.
-	 */
-	struct c2_clink         *fc_extra;
-	/** Number of ->fc_extra clinks. */
-	uint32_t                 fc_nr_extra;
+	/** Magic value. See C2_CONFC_CTX_MAGIX. */
+	uint64_t                 fc_magix;
 };
+extern struct c2_bob_type c2_confc_ctx_bob;
+
+/**
+ * Initializes configuration retrieval context.
+ * @pre  confc is initialized
+ */
+void c2_confc_ctx_init(struct c2_confc_ctx *ctx, struct c2_confc *confc);
 
-void c2_confc_ctx_init(struct c2_confc_ctx *ctx, struct c2_confc *client);
 void c2_confc_ctx_fini(struct c2_confc_ctx *ctx);
 
 /**
@@ -492,7 +495,8 @@ static inline int32_t c2_confc_error(const struct c2_confc_ctx *ctx)
  *        intact until configuration retrieval completes (i.e., until
  *        ctx->fc_complete channel is signaled).
  *
- * @pre  ctx->fc_client == origin->co_confc
+ * @pre  ergo(origin != NULL, origin->co_confc == ctx->fc_confc)
+ * @pre  ctx->fc_origin == NULL && ctx->fc_path is zeroed
  */
 int c2_confc_open(struct c2_confc_ctx *ctx, struct c2_conf_obj *origin,
 		  const char *path);
diff --git a/conf/confc_offline.h b/conf/confc_offline.h
index 8195f07..6f4a81d 100644
--- a/conf/confc_offline.h
+++ b/conf/confc_offline.h
@@ -140,6 +140,7 @@ struct confx_object;
  * @returns >= 0  The number of confx_objects found.
  * @returns  < 0  Error code.
  *
+ * @pre   src does not start with "local-conf:"
  * @post  retval <= n
  */
 static int c2_conf_parse(const char *src, struct confx_object dest[], size_t n);
diff --git a/conf/map.h b/conf/map.h
index 8e27b29..c35042f 100644
--- a/conf/map.h
+++ b/conf/map.h
@@ -73,7 +73,7 @@ void c2_conf_map_fini(struct c2_conf_map *map);
 /**
  * Adds new entry to the mapping.
  *
- * @pre  The mapping does not contain given object.
+ * @pre  There is no entry for given object in the mapping.
  */
 int c2_conf_map_add(struct c2_conf_map *map, const struct c2_conf_obj *obj);
 
diff --git a/conf/obj.c b/conf/obj.c
index 8e94dd3..7becb78 100644
--- a/conf/obj.c
+++ b/conf/obj.c
@@ -203,7 +203,7 @@
  * <!---------------------------------------------------------------->
  * @subsection conf-lspec-state State Specification
  *
- * - @ref confc-lspec-state "States of a confc state machine"
+ * - @ref confc-lspec-state "States of a context state machine at confc side"
  * - @ref confd-lspec-state "States of a FOM at confd side"
  * - @ref conf-fspec-obj-status
  * - @ref conf-fspec-obj-pinned
@@ -377,13 +377,13 @@
  * @{
  */
 
-struct c2_bob_type c2_conf_dir_bob;
-struct c2_bob_type c2_conf_profile_bob;
-struct c2_bob_type c2_conf_filesystem_bob;
-struct c2_bob_type c2_conf_service_bob;
-struct c2_bob_type c2_conf_node_bob;
-struct c2_bob_type c2_conf_nic_bob;
-struct c2_bob_type c2_conf_sdev_bob;
-struct c2_bob_type c2_conf_partition_bob;
+struct c2_bob_type c2_conf_dir_bob = XXX;
+struct c2_bob_type c2_conf_profile_bob = XXX;
+struct c2_bob_type c2_conf_filesystem_bob = XXX;
+struct c2_bob_type c2_conf_service_bob = XXX;
+struct c2_bob_type c2_conf_node_bob = XXX;
+struct c2_bob_type c2_conf_nic_bob = XXX;
+struct c2_bob_type c2_conf_sdev_bob = XXX;
+struct c2_bob_type c2_conf_partition_bob = XXX;
 
 /** @} conf_dlspec_obj */
diff --git a/conf/obj.h b/conf/obj.h
index 142b877..b16cb2c 100644
--- a/conf/obj.h
+++ b/conf/obj.h
@@ -383,9 +383,21 @@ struct c2_conf_dircur;
 
 /** Configuration object operations. */
 struct c2_conf_obj_ops {
-	/** Finds a child of given object. */
+	/**
+	 * Finds a child of given object.
+	 *
+	 * @param parent  The object being searched.
+	 * @param name    Name of the relation leading to a child object.
+	 *                Identifier of the child object, if parent is
+	 *                a directory.
+	 * @param out     If the function succeeds, *out will point to the
+	 *                sought-for object.
+	 *
+	 * @pre  parent->co_status == C2_CS_READY
+	 */
 	int (*coo_lookup)(struct c2_conf_obj *parent,
-			  const struct c2_conf_buf *name);
+			  const struct c2_conf_buf *name,
+			  struct c2_conf_obj **out);
 	/**
 	 * Returns the next directory entry.
 	 *
@@ -406,10 +418,11 @@ struct c2_conf_obj_ops {
 /**
  * Directory cursor.
  *
- * c2_conf_dircur is used to track position within a directory.
+ * c2_conf_dircur is used to track position within a directory
+ * (c2_conf_dir).
  */
 struct c2_conf_dircur {
-	/** Directory this cursor works with. */
+	/** Directory this cursor works upon. */
 	struct c2_conf_dir *dc_dir;
 	/**
 	 * Configuration object that has been returned (and pinned)
diff --git a/conf/obj_ops.c b/conf/obj_ops.c
index 932f2ac..5379b10 100644
--- a/conf/obj_ops.c
+++ b/conf/obj_ops.c
@@ -117,7 +117,7 @@ bool c2_conf_obj_match(const struct c2_conf_obj *cached,
 }
 
 int c2_conf_obj_fill(struct c2_conf_obj *dest, const struct confx_object *src,
-		     struct c2_conf_map *cache)
+		     struct c2_conf_map *reg)
 {
 	/*
 	 * C2_PRE(...);
diff --git a/conf/obj_ops.h b/conf/obj_ops.h
index 3be3fef..b7dd07b 100644
--- a/conf/obj_ops.h
+++ b/conf/obj_ops.h
@@ -53,10 +53,10 @@ bool c2_conf_obj_match(const struct c2_conf_obj *cached,
 /**
  * Enriches a stub with configuration data.
  *
- * @param dest   Cached configuration object (stub) to be populated with
- *               configuration data.
- * @param src    On-wire object to read the data from.
- * @param cache  Registry of cached configuration objects.
+ * @param dest  Cached configuration object (stub) to be filled with
+ *              configuration data.
+ * @param src   On-wire object to read the data from.
+ * @param reg   Registry of cached configuration objects.
  *
  * @pre   c2_mutex_is_locked(&dest->co_confc->cc_lock)
  * @pre   dest->co_status != C2_CS_READY
@@ -68,7 +68,7 @@ bool c2_conf_obj_match(const struct c2_conf_obj *cached,
  * @post  c2_mutex_is_locked(&dest->co_confc->cc_lock)
  */
 int c2_conf_obj_fill(struct c2_conf_obj *dest, const struct confx_object *src,
-		     struct c2_conf_map *cache);
+		     struct c2_conf_map *reg);
 
 /** @} conf_dfspec_objops */
 #endif /* __COLIBRI_CONF_OBJOPS_H__ */
diff --git a/conf/ut/confc.c b/conf/ut/confc.c
index 32aa827..3d74df2 100644
--- a/conf/ut/confc.c
+++ b/conf/ut/confc.c
@@ -103,7 +103,7 @@ static void test_ctx(void)
 	/* XXX ctx.fc_complete is not tested. Should it be? */
 
 	/* c2_sm_ast::sa_mach is not used; c2_sm is accessed via
-	 * container_of()->fc_mach */
+	 * bob_of()->fc_mach */
 	C2_UT_ASSERT(ctx.fc_ast.sa_mach == NULL);
 
 	C2_UT_ASSERT(c2_fop_data(&ctx->fc_fop) == &ctx->fc_req);
-- 
1.8.3.2

