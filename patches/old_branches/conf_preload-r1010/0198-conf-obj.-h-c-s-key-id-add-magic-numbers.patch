From 711b3c46230927848c322d61fdd69bb11a558814 Mon Sep 17 00:00:00 2001
From: "Valery V. Vorotyntsev" <valery_vorotyntsev@xyratex.com>
Date: Wed, 13 Jun 2012 23:34:48 +0300
Subject: [PATCH 198/311] conf/obj.{h,c}: s/key/id/; add magic numbers

Delete definitions of path and path components.  New path is much
simpler. The old definition is not applicable, and new one may
not be needed.

Use `object id' term instead of `object key'. Substitute co_key
with co_id (the corresponding changes will be continued in other
files).

Add magic number fields to configuration objects.
---
 conf/obj.c | 163 ++++++++++++++++++++++++++-----------------------------------
 conf/obj.h | 136 ++++++++++++++++++++++++++++++++++-----------------
 2 files changed, 161 insertions(+), 138 deletions(-)

diff --git a/conf/obj.c b/conf/obj.c
index 14c4a47..75febf9 100644
--- a/conf/obj.c
+++ b/conf/obj.c
@@ -43,17 +43,17 @@
  * <hr> <!------------------------------------------------------------>
  * @section conf-ovw Overview
  *
- * Configuration is part of Colibri cluster meta-data. Configuration
+ * Configuration is part of Colibri cluster meta-data.  Configuration
  * client library (confc) provides API for accessing configuration
- * data.  Confc obtains configuration from the configuration server
- * (confd) and caches this data in local memory.
+ * data.  Confc obtains configuration data from the configuration
+ * server (confd) and caches this data in local memory.
  *
  * Confd tries to obtain requested configuration data from its own
  * cache. In case of cache miss, confd loads data from the
  * configuration database and updates the cache.
  *
  * Confd is a user-space service.  Confc library is implemented in
- * user space and in the kernel.  Applications access configuration
+ * user space and in the kernel. Applications access configuration
  * data by linking with confc library and using its API.
  *
  * <hr> <!------------------------------------------------------------>
@@ -61,63 +61,42 @@
  *
  * - @b Confc (configuration client library, configuration client):
  *   a library that provides configuration consumers with API to query
- *   C2 configuration.
+ *   Colibri configuration.
  *
  * - @b Confd (configuration server): a management service that
  *   provides configuration clients with information obtained from
  *   configuration database.
  *
- * - Configuration @b consumer: any software that uses confc
- *   interfaces to access C2 configuration.  Alternative name: @b
- *   application.
+ * - Configuration @b consumer: any software that uses confc API to
+ *   access Colibri configuration.  Alternative name: @b application.
  *
  * - Configuration @b cache: configuration data stored in nodeâ€™s
- *   memory. Confc library maintains such a cache and provides
- *   configuration consumers with access to its data. Confd also uses
+ *   memory.  Confc library maintains such a cache and provides
+ *   configuration consumers with access to its data.  Confd also uses
  *   configuration cache for faster retrieval of information requested
  *   by configuration clients.
  *
  * - Configuration @b object: a data structure that contains
  *   configuration information. There are several types of
- *   configuration objects: profile, service, node, etc.
+ *   configuration objects: filesystem, service, node, etc.
  *
- * - @b Identity of a configuration object is a tuple of its type and
- *   key.
+ * - @b Identity of a configuration object is a pair of its type and
+ *   identifier.
  *
  * - Configuration object is a @b stub if its status is not equal to
- *   C2_CS_READY. Stubs contain no meaningful configuration data apart
- *   from object's type and key.
+ *   C2_CS_READY.  Stubs contain no meaningful configuration data.
+ *
+ * - A configuration object is said to be @b pinned if its reference
+ *   counter is nonzero; otherwise it is @b unpinned.
  *
  * - @b Relation: a pointer from one configuration object to another
- *   configuration object or to a collection of those.  In former case
- *   it is @b one-to-one relation, in the latter case it is @b
+ *   configuration object or to a collection of objects.  In former
+ *   case it is @b one-to-one relation, in the latter case it is @b
  *   one-to-many relation.
  *
  * - @b Downlink: a relation whose destination is located further from
  *   "profile" object than the origin.
  *
- * - @b Directory: a list of configuration objects. This term is
- *   usually used in context of path.  Alternative name: @b collection
- *   of configuration objects.
- *
- * - @b Path: a pair `{x, R}', where `x' is a configuration object and
- *   `R' is such a sequence of downlinks and object keys that:
- *     - the first element (if any) is a downlink;
- *     - a one-to-many downlink is either followed by a key or is the
- *       last element;
- *     - a key is preceded by a one-to-many downlink.
- *
- *   `x' is path @b origin, elements of `R' are path @b components.
- *
- * - <b>Path target</b>: the object or directory that a path leads to.
- *   Path target is @b reachable if all of the intermediate objects of
- *   the path are ready (C2_CS_READY) and target is either an object
- *   that is ready or a directory of ready objects.
- *
- * - A configuration object is said to be @b pinned if its reference
- *   counter is nonzero; otherwise it is @b unpinned.  Confc never
- *   invalidates pinned objects.
- *
  * <hr> <!------------------------------------------------------------>
  * @section conf-req Requirements
  *
@@ -163,9 +142,15 @@
  * <hr> <!------------------------------------------------------------>
  * @section conf-highlights Design Highlights
  *
- * - Configuration consumers should not use relations of a
- *   configuration object to access its neighbors: relations may point
- *   to unpinned objects that can be invalidated by confc.
+ * - The application should not use relations of a configuration
+ *   object to access other objects.
+ *
+ *   Rationale: relations may point to unpinned objects. Confc or
+ *   confd implementation, who owns the cache, is free to convert
+ *   unpinned objects into stubs.  The application cannot use stubs,
+ *   as those contain no valid configuration data.
+ *
+ *   @see @ref conf-fspec-obj-private
  *
  * <hr> <!------------------------------------------------------------>
  * @section conf-fspec Functional Specification
@@ -194,20 +179,20 @@
  * @subsection conf-lspec-comps Components Overview
  *
  * Every instance of confc library and confd service maintains a cache
- * of configuration information.  A cache is represented by a set of
- * dynamically allocated configuration objects, "connected" by
- * relations into a directed acyclic graph (DAG), and a registry ---
- * an in-memory database that maps object identities to memory
- * addresses of these objects.
+ * of configuration data.  Configuration cache is represented by 1) a
+ * set of dynamically allocated configuration objects, joined together
+ * by relations into a directed acyclic graph (DAG), and 2) an
+ * in-memory database -- registry -- that maps object identities to
+ * memory addresses of these objects.
  *
- * A cache can be pre-loaded from an ASCII string. See @ref
- * conf-fspec-preload.
+ * Configuration cache can be pre-loaded from an ASCII string. See
+ * @ref conf-fspec-preload.
  *
- * If a confc cache doesn't have enough data to fulfill a request of
+ * If a confc cache does not have enough data to fulfill a request of
  * configuration consumer, confc obtains the necessary data from the
  * confd and adds new configuration data to the cache.
  *
- * If a confd cache doesn't have enough data to fulfill a request of
+ * If a confd cache does not have enough data to fulfill a request of
  * confc, confd loads the necessary data from the configuration
  * database and updates the cache.
  *
@@ -223,30 +208,31 @@
  * @section conf-conformance Conformance
  *
  * - @b i.conf.confc.kernel
- *   The implementation of confc library uses "portable subset" of C2
- *   API, for which the differences between the kernel and user space
- *   are abstracted away.
+ *   The implementation of confc uses portable subset of Colibri core
+ *   API, which abstracts away the differences between kernel and
+ *   user-space code.
  * - @b i.conf.confc.user
  *   Confc library is implemented for user space.
  * - @b i.conf.cache.data-model
  *   Configuration information is organized as outlined in section 4.1
- *   of the HLD. The same data structures are used for confc and
- *   confd.  Configuration structures are kept in memory.
+ *   of the HLD. One-to-many relationships are represented by
+ *   c2_conf_dir objects.  The same data structures are used for both
+ *   confc and confd.  Configuration structures are kept in memory.
  * - @b i.conf.cache.pinning
  *   Confc "pins" configuration object by incrementing its reference
- *   counter.  c2_confc_fini() asserts (with C2_PRE()) that no objects
- *   are pinned when the cache is being destroyed.
+ *   counter.  c2_confc_fini() asserts (C2_PRE()) that no objects are
+ *   pinned when the cache is being destroyed.
  * - @b i.conf.cache.unique-objects
- *   A registry of cached objects (c2_conf_map) is used to achieve
- *   uniqueness of configuration object identities.
+ *   Uniqueness of configuration object identities is achieved by
+ *   using a registry of cached objects (c2_conf_map).
  *
  * <hr> <!------------------------------------------------------------>
  * @section conf-ut Unit Tests
  *
  * Fault Injection mechanism (lib/finject.h) will be used to test
  * handling of "rare" errors (e.g., allocation errors) and to disable
- * some of external modules' functionality (e.g., to make
- * c2_rpc_post() a noop).
+ * some of external modules' functionality (e.g., to make c2_rpc_post()
+ * a noop).
  *
  * @subsection conf-ut-common Infrastructure Test Suite
  *
@@ -256,9 +242,8 @@
  *           validity of various paths, testing success and failure of
  *           c2_conf_downlink().
  *
- *     @test Object operations will be tested. This includes
- *           allocation, comparison with on-wire representation, stub
- *           enrichment.
+ *     @test Object operations will be tested. This includes allocation,
+ *           comparison with on-wire representation, stub enrichment.
  *
  *     @test c2_conf_parse() will be tested.
  *
@@ -272,7 +257,7 @@
  *
  *     @test path_walk() will be tested.
  *
- *     @test c2_confc_*open*() and c2_confc_*close() will be tested.
+ *     @test c2_confc_open*() and c2_confc_close() will be tested.
  *
  *     @test Cache operations will be tested. This includes
  *           cache_add(), object_enrich(), cache_grow(), and
@@ -296,9 +281,9 @@
  * queries to be executed upon this data, and results that are
  * expected to be obtained by running these queries.
  *
- * `Run' step is performed by a confc application that takes generated
- * configuration and queries as input parameters and executes the
- * queries, producing output.
+ * `Run' step is performed by a confc application, whose input data
+ * are configuration and queries generated by confg. The application
+ * executes the queries, producing output.
  *
  * Actual output is compared with expected at `Compare' step.
  *
@@ -307,28 +292,29 @@
  * confg generates "configuration string" --- an ASCII string
  * introduced in @ref conf-fspec-preload.
  *
- * As soon as confd is able to read configuration database and handle
- * confc's requests, confg will need to be changed to generate
+ * @todo As soon as confd is able to read configuration database and
+ * handle confc's requests, confg will need to be changed to generate
  * configuration database.
  *
  * @subsection conf-st-queries Queries
  *
  * System tests cover three use cases (see @ref confc-fspec-recipes):
  *
- *   -# Getting [configuration] data on a filesystem.
+ *   -# Getting configuration data on a filesystem.
  *   -# Getting data on a service given its type.
  *   -# Getting list of devices used by specific service on specific node.
  *
- * Case 1 takes no input parameters (apart from profile name which
- * does not count).  Case 2 takes service type as an input parameter.
- * Case 3 takes service type and node identifier.
+ * Case 1 takes profile name as input parameter.  Case 2 --- profile
+ * name and service type.  Case 3 --- profile name, service type, and
+ * node identifier.
  *
- * A query is number of use case and values of input parameters.
+ * A query is the number of use case (1 to 3) and values of input
+ * parameters.
  *
  * @subsection conf-st-output Output
  *
  * When the confc application from `Run' step (see above) runs a
- * [configuration] query, it produces a string with textual
+ * configuration query, it produces a string with textual
  * representation of results of this query.  Sequences in such
  * representations (e.g., a list of filesystem parameters, a list of
  * partitions) should be sorted, otherwise two semantically equivalent
@@ -337,18 +323,18 @@
  * <hr> <!------------------------------------------------------------>
  * @section conf-O Analysis
  *
- * XXX
+ * @todo XXX
  *
  * <hr> <!------------------------------------------------------------>
  * @section conf-scalability Scalability
  *
  * Current design imposes no restrictions on the size of configuration
- * cache.  If a configuration database is huge and an application is
- * keen to know every aspect of cluster configuration, confc cache
- * will eventually consume all memory available.  confc will be unable
- * to allocate new objects, its state machines will end in S_FAILURE
+ * cache.  If a configuration database is huge and the application is
+ * keen to know every aspect of cluster configuration, confc cache may
+ * eventually consume all available memory.  Confc will be unable to
+ * allocate new objects, its state machines will end in S_FAILURE
  * state, and c2_confc_error() will return -ENOMEM.  The application
- * can get rid of configuration cache by issuing c2_confc_fini().
+ * may opt to get rid of configuration cache by issuing c2_confc_fini().
  *
  * @todo Implement cache eviction.
  *
@@ -374,15 +360,6 @@
  * @{
  */
 
-enum {
-	CONF_FSSVC_HEAD_MAGIC   = 0x66732f7376632020, /* "fs/svc  " */
-	CONF_NDSVC_HEAD_MAGIC   = 0x6e6f64652f737663, /* "node/svc" */
-	CONF_SERVICE_LINK_MAGIC = 0x7365727669636520  /* "service " */
-};
-
-C2_TL_DESCR_DEFINE(c2_conf_filesystem_services,
-		   "c2_conf_filesystem::cf_services", ,
-		   struct c2_conf_service, cs_filesystem_linkage, cs_magic,
-		   CONF_SERVICE_LINK_MAGIC, CONF_FSSVC_HEAD_MAGIC);
+XXX;
 
 /** @} conf_dlspec_obj */
diff --git a/conf/obj.h b/conf/obj.h
index c18488a..4adf4ff 100644
--- a/conf/obj.h
+++ b/conf/obj.h
@@ -48,8 +48,9 @@
  *
  * There are different kinds of configuration data: configuration of
  * filesystems, services, nodes, storage devices, etc.  Configuration
- * data is contained in configuration objects of which there are 7
+ * data is contained in configuration objects of which there are 8
  * types:
+ * - c2_conf_dir (a container of configuration objects),
  * - c2_conf_profile,
  * - c2_conf_filesystem,
  * - c2_conf_service,
@@ -61,28 +62,26 @@
  * Different types of configuration objects have non-overlapping sets
  * of fields (e.g., type of service is an attribute of c2_conf_service
  * object), but some fields are common to all types of objects (e.g.,
- * key of an object or its status).  Such common fields are put
- * together in c2_conf_obj structure, which is embedded into every
- * configuration object as its first field (e.g.,
- * c2_conf_filesystem::cf_obj).
+ * object's identifier or status).  Common fields are grouped into
+ * c2_conf_obj structure, which is embedded into every configuration
+ * object.
  *
  * c2_conf_obj is referred to as @em generic configuration object,
- * while c2_conf_profile, ..., c2_conf_partition are @em concrete
- * configuration objects.
+ * while c2_conf_dir, c2_conf_profile, ..., c2_conf_partition are
+ * @em concrete configuration objects.
  *
  * <hr> <!------------------------------------------------------------>
  * @section conf-fspec-obj-enum Enumerations
  *
  * - c2_conf_objtype --- numeric tag that corresponds to a type of
  *   concrete configuration objects.
- * - c2_conf_status --- readiness of the configuration data contained
- *   in an object.
+ * - c2_conf_status --- readiness of object's configuration data.
  *
  * <hr> <!------------------------------------------------------------>
  * @section conf-fspec-obj-status Configuration Object Status
  *
  * A configuration object exists in one of three states:
- *   - C2_CS_MISSING --- configuration is absent and is not being
+ *   - C2_CS_MISSING --- configuration data is absent and is not being
  *     retrieved; the object is a stub.
  *   - C2_CS_LOADING --- retrieval of configuration is in progress; the
  *     object is a stub.
@@ -91,10 +90,10 @@
  *
  * These values make up @ref c2_conf_status enumeration.
  *
- * Status field of a configuration object (c2_conf_obj::co_status) is
- * accessed and modified by the owner of this object --- confc or
- * confd.  Initial status is C2_CS_MISSING; the diagram below shows
- * how it can be changed:
+ * Status field of a configuration object -- c2_conf_obj::co_status --
+ * is accessed and modified by object's owner (confc or confd).
+ * Initial status is C2_CS_MISSING. Possible transitions are shown on
+ * the diagram below:
  *
  * @dot
  * digraph obj_status {
@@ -102,25 +101,26 @@
  *     C2_CS_LOADING -> C2_CS_MISSING [label="loading failed"];
  *     C2_CS_LOADING -> C2_CS_READY [label="loading succeeded"];
  *     C2_CS_MISSING -> C2_CS_READY [label=
- *  "configuration filled by\nsome loading operation"];
+ *  "configuration data is filled\nby some loading operation"];
  * }
  * @enddot
  *
  * <hr> <!------------------------------------------------------------>
  * @section conf-fspec-obj-pinned Pinned Objects
  *
- * If object's reference counter - c2_conf_obj::co_nrefs - is
+ * If object's reference counter -- c2_conf_obj::co_nrefs -- is
  * non-zero, the object is said to be @em pinned. Stubs cannot be
  * pinned, only C2_CS_READY objects can.  Object's reference counter
- * is used by confc library, it is not supposed to be accessed by the
+ * is used by confc library and is not supposed to be accessed by the
  * application.
  *
  * <hr> <!------------------------------------------------------------>
  * @section conf-fspec-obj-private Private Fields
  *
- * Some fields of configuration object data structures are marked as
- * private. They are used by confc and confd and should not be
- * accessed by applications.
+ * Only those fields of concrete configuration objects that follow
+ * "configuration data (for the application)" comment should ever be
+ * accessed by the application.  The rest of fields are private
+ * property of confc and confd implementations.
  *
  * @see @ref conf_dfspec_obj "Detailed Functional Specification"
  */
@@ -158,51 +158,84 @@ enum c2_conf_objtype {
 	C2_CO_NR
 };
 
+enum {
+	C2_CONF_DIR_MAGIX        = XXX,
+	C2_CONF_PROFILE_MAGIX    = XXX,
+	C2_CONF_FILESYSTEM_MAGIX = XXX,
+	C2_CONF_SERVICE_MAGIX    = XXX,
+	C2_CONF_NODE_MAGIX       = XXX,
+	C2_CONF_NIC_MAGIX        = XXX,
+	C2_CONF_SDEV_MAGIX       = XXX,
+	C2_CONF_PARTITION_MAGIX  = XXX
+};
+
 struct c2_conf_obj_ops;
 
 /**
  * Generic configuration object.
  *
- * The fields of c2_conf_obj structure are common to all configuration
- * objects.  This structure is embedded (as the first member) into
- * each concrete configuration object.
+ * The fields of struct c2_conf_obj are common to all configuration
+ * objects.  c2_conf_obj is embedded into each concrete configuration
+ * object.
  */
 struct c2_conf_obj {
-	struct c2_conf_obj     *co_parent;
-	struct c2_conf_obj_ops *co_ops;
+	/** Type of the ambient concrete configuration object. */
 	enum c2_conf_objtype    co_type;
-	struct c2_conf_buf      co_key;
+	/**
+	 * Object identifier.
+	 * This value is unique among the object of given ->co_type.
+	 */
+	struct c2_conf_buf      co_id;
 	enum c2_conf_status     co_status;
+	struct c2_conf_obj_ops *co_ops;
+	/**
+	 * Pointer to parent object.
+	 * The value is NULL for objects that have several parents
+         * (e.g., c2_conf_node).
+	 */
+	struct c2_conf_obj     *co_parent;
 	/**
 	 * Reference counter.
 	 * The object is "pinned" if this value is non-zero.
 	 */
 	uint64_t                co_nrefs;
 	/**
-	 * Channel on which "object loading completed" and "object
-	 * unpinned" events are announced.
+	 * Channel on which "configuration loading completed" and
+	 * "object unpinned" events are announced.
 	 */
 	struct c2_chan          co_chan;
 	/** This field is reserved for confc and confd implementations. */
 	const void             *co_private;
 };
 
-struct c2_conf_dircur;
+struct c2_conf_dir;
+struct c2_confc_dircur; /* XXX defined in conf/confc.h */
 
-/** Object's operation vector. */
+/** Configuration object operations. */
 struct c2_conf_obj_ops {
 	/** Finds a child of given object. */
 	int (*coo_lookup)(struct c2_conf_obj *parent,
-			  const struct c2_conf_buf *key);
-	/** Gets next directory entry (C2_CO_DIR only). */
-	int (*coo_readdir)(struct c2_conf_obj *dir,
-			   struct c2_conf_dircur *cursor,
-			   struct c2_conf_obj **dest);
+			  const struct c2_conf_buf *id);
+	/**
+	 * Returns a pointer to the next directory entry.
+	 *
+	 * @retval 1    *result now points at the next directory entry.
+	 * @retval 0    End of the directory is reached.
+	 * @retval < 0  Error.
+	 *
+	 * @pre  dir->co_type == C2_CO_DIR
+	 *
+	 * This function is used by confc implementation.
+	 */
+	int (*coo_readdir)(struct c2_conf_dir *dir,
+			   struct c2_confc_dircur *cursor,
+			   struct c2_conf_obj **result);
 };
 
-/** Directory object --- a container for configuration objects. */
+/** Directory object --- a container of configuration objects. */
 struct c2_conf_dir {
 	struct c2_conf_obj cd_obj;
+	uint64_t           cd_magix;
 	struct c2_tl       cd_items;
 };
 
@@ -210,16 +243,19 @@ struct c2_conf_filesystem;
 
 struct c2_conf_profile {
 	struct c2_conf_obj         cp_obj;
+	uint64_t                   cp_magix;
 	struct c2_conf_filesystem *cp_filesystem;
 };
 
 struct c2_conf_filesystem {
 	struct c2_conf_obj  cf_obj;
+	uint64_t            cf_magix;
 	struct c2_conf_dir *cf_services;
 /* configuration data (for the application) */
 	struct c2_fid       cf_rootfid;
 	/**
-	 * Filesystem parameters. NULL terminated array of C strings.
+	 * Filesystem parameters.
+	 * NULL terminated array of C strings.
 	 * XXX @todo Make it an array of name-value pairs (attributes).
 	 */
 	const char         *cf_params;
@@ -229,6 +265,7 @@ struct c2_conf_node;
 
 struct c2_conf_service {
 	struct c2_conf_obj       cs_obj;
+	uint64_t                 cs_magix;
 	/** The node this service is hosted at. */
 	struct c2_conf_node     *cs_node;
 	/**
@@ -236,31 +273,36 @@ struct c2_conf_service {
 	 * c2_conf_filesystem::cf_services.
 	 */
 	struct c2_tlink          cs_filesystem_linkage;
-	/** Magic for a list of services. */
-	uint64_t                 cs_magic;
 /* configuration data (for the application) */
 	enum c2_cfg_service_type cs_type;
-	/** Service end points. NULL terminated array of C strings. */
+	/**
+	 * Service end points.
+	 * NULL terminated array of C strings.
+	 */
 	const char              *cs_endpoints;
 };
 
-/** Descriptor for a tlist of filesystem's services. */
-C2_TL_DESCR_DECLARE(c2_conf_filesystem_services, extern);
-
 struct c2_conf_node {
+	/*
+	 * Note that ->cn_obj.co_parent == NULL: a node can host
+	 * several services, so there may be no single parent.
+	 */
 	struct c2_conf_obj  cn_obj;
+	uint64_t            cn_magix;
 	struct c2_conf_dir *cn_nics;
 	struct c2_conf_dir *cn_sdevs;
 /* configuration data (for the application) */
 	uint32_t            cn_memsize;
-	uint32_t            cn_nr_processors;
+	uint32_t            cn_nr_cpu;
 	uint64_t            cn_last_state;
 	uint64_t            cn_flags;
 	uint64_t            cn_pool_id;
 };
 
+/** Network interface controller. */
 struct c2_conf_nic {
 	struct c2_conf_obj ni_obj;
+	uint64_t           ni_magix;
 	/**
 	 * Linkage to ->cd_items of the c2_conf_dir hanging from
 	 * c2_conf_node::cn_nics.
@@ -274,8 +316,10 @@ struct c2_conf_nic {
 	uint64_t           ni_last_state;
 };
 
+/** Storage device. */
 struct c2_conf_sdev {
 	struct c2_conf_obj  sd_obj;
+	uint64_t            sd_magix;
 	struct c2_conf_dir *sd_partitions;
 	/**
 	 * Linkage to ->cd_items of the c2_conf_dir hanging from
@@ -283,7 +327,7 @@ struct c2_conf_sdev {
 	 */
 	struct c2_tlink     sd_linkage;
 /* configuration data (for the application) */
-	uint32_t            sd_type;
+	uint32_t            sd_iface;
 	uint32_t            sd_media;
 	uint64_t            sd_size;
 	uint64_t            sd_last_state;
@@ -291,8 +335,10 @@ struct c2_conf_sdev {
 	const char         *sd_filename;
 };
 
+/** Storage device partition. */
 struct c2_conf_partition {
 	struct c2_conf_obj pa_obj;
+	uint64_t           pa_magix;
 	/**
 	 * Linkage to ->cd_items of the c2_conf_dir hanging from
 	 * c2_conf_sdev::sd_partitions.
-- 
1.8.3.2

