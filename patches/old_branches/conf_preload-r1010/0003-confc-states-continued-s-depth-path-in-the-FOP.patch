From c1009be852472c414f770c26c81fcf1df3ed28f2 Mon Sep 17 00:00:00 2001
From: "Valery V. Vorotyntsev" <valery_vorotyntsev@xyratex.com>
Date: Thu, 9 Feb 2012 22:49:23 +0200
Subject: [PATCH 003/311] confc states continued; s/depth/path/ in the FOP

+ confc.c: Fixed bug in path_status() (former cache_path_check()):
  omit the loop if path originates at a stub object.
+ confop.ff (c2_confop_fetch): Use path instead of depth of retrieval
  in the fetch FOP.
+ confc.c (check_st_in): New function. Continue defining confc states...
---
 conf/conf.h    |   2 +-
 conf/confc.c   | 149 ++++++++++++++++++++++++++++++++++++++-------------------
 conf/confc.h   |   2 +-
 conf/confop.ff |  41 +++++++++-------
 4 files changed, 127 insertions(+), 67 deletions(-)

diff --git a/conf/conf.h b/conf/conf.h
index bbb5a3a..4bbca04 100644
--- a/conf/conf.h
+++ b/conf/conf.h
@@ -99,7 +99,7 @@ struct c2_conf_cache {
 	 * Protects this structure and the DAG of configuration
 	 * objects from concurrent writes.
 	 */
-	struct c2_mutex         cc_lock;
+	struct c2_mutex         cc_lock; /* XXX Is it needed? */
 
 	/**
 	 * Root configuration object of a confc cache.
diff --git a/conf/confc.c b/conf/confc.c
index d830b71..38eb64c 100644
--- a/conf/confc.c
+++ b/conf/confc.c
@@ -22,31 +22,44 @@
 #  include <config.h>
 #endif
 #include "conf/confc.h"
+#include "lib/cdefs.h"  /* container_of */
 
 static struct c2_conf_cache confc_cache; /*< Confc's configuration cache. */
 
 enum confc_state { S_INITIAL, S_CHECK, S_WAIT_REPLY, S_WAIT_STATUS,
 		   S_GROW_CACHE, S_FAILURE, S_TERMINAL, S_NR };
 
+static enum c2_conf_status
+list_status(const struct c2_tl_descr *descr, const struct c2_tl *list)
+{
+	XXX;
+	/*
+	 * - If all of the objects are LOADING => return LOADING.
+	 * - If MISSING objects are found => change their statuses to
+	 *   LOADING and return MISSING.
+	 * - Otherwise (all objects are READY) return READY.
+	 */
+}
+
 /**
- * @pre   c2_conf_path_invariant(path)
+ * @pre  c2_conf_path_invariant(ctx->fc__path)
  *
- * @retval -ENOENT  `path' contains a key and the corresponding object
- *                  does not exist.
+ * @retval -ENOENT  ctx->fc__path contains a key and the corresponding
+ *                  object does not exist.
  */
-int cache_path_check(struct c2_conf_cache *cache,
-		     const struct c2_conf_path *path,
-		     enum c2_conf_status *result)
+static int
+path_status(struct c2_confc_fetchctx *ctx, enum c2_conf_status *status)
 {
-	struct c2_conf_obj *obj = path->p_origin ?: &cache->cc_root->cp_obj;
-	struct c2_conf_pathcomp *comp = path->p_comps;
-	size_t nr = path->p_nr_comps; /* remaining number of components */
+	struct c2_conf_obj *obj =
+		ctx->fc__path->p_origin ?: &confc_cache->cc_root->cp_obj;
+	struct c2_conf_pathcomp *comp = ctx->fc__path->p_comps;
+	size_t nr = ctx->fc__path->p_nr_comps; /* remaining nr of components */
 	bool target_is_directory = false;
 
-	C2_ASSERT(c2_conf_path_invariant(path));
-	*result = obj->co_status;
+	C2_ASSERT(c2_conf_path_invariant(ctx->fc__path));
+	*status = obj->co_status;
 
-	for (; nr > 0; --nr, ++comp) {
+	for (; *status == C2_CS_READY && nr > 0; --nr, ++comp) {
 		const struct c2_conf_relation *rel;
 		struct c2_conf_obj *child;
 		C2_ASSERT(!comp->pc_iskey);
@@ -57,16 +70,7 @@ int cache_path_check(struct c2_conf_cache *cache,
 
 		if (target_is_directory) {
 			if (nr == 1) { /* the last path component */
-				/* XXX list_scan():
-				 * - if all of the objects are LOADING ---
-				 *   return LOADING;
-				 * - if MISSING objects are found ---
-				 *   change their statuses to LOADING
-				 *   and return MISSING;
-				 * - otherwise all objects are READY ---
-				 *   return READY.
-				 */
-				*result = list_scan(XXX);
+				*status = list_status(XXX_descr, XXX_list);
 				break;
 			}
 
@@ -82,57 +86,89 @@ int cache_path_check(struct c2_conf_cache *cache,
 			child = XXX_relation_target(obj, rel);
 		}
 
-		if (child == NULL) /* no such key */
-			return -ENOENT;
+		if (child == NULL) {
+			C2_ASSERT(comp->pc_iskey);
+			return -ENOENT; /* no such key */
+		}
 
 		obj = child;
-		*result = obj->co_status;
-		if (*result != C2_CS_READY)
-			break;
+		*status = obj->co_status;
 	}
 
-	if (*result == C2_CS_READY) {
+	if (*status == C2_CS_READY) {
 		++obj->co_nrefs;
 		if (target_is_directory) {
-			/* XXX fetchctx->fc_result = dir_allocate() */
+			XXX; /* fetchctx->fc_result = dir_allocate() */
 		} else {
-			/* XXX fetchctx->fc_result = obj */
+			fetchctx->fc_result = obj;
 		}
-	} else if (*result == C2_CS_MISSING) {
+	} else if (*status == C2_CS_MISSING) {
 		if (!target_is_directory) {
 			C2_ASSERT(obj->co_status == C2_CS_MISSING);
 			obj->co_status = C2_CS_LOADING;
 		}
 
-		/* XXX
-		 * fop->path = { .p_origin   = obj,
-		 *               .p_nr_comps = nr,
-		 *               .p_comps    = comp }
-		 */
-	} else if (*result == C2_CS_LOADING) {
+		XXX {
+			/*
+			 * Encode the following into ctx->fc__fop:
+			 *   .ff_origin.o_objtype = obj->co_objtype;
+			 *   .ff_origin.o_objkey <- obj->co_objkey;
+			 *   .ff_comps.c_nr       = nr;
+			 *   .ff_comps.c_data    <- comp.
+			 */
+		}
+	} else if (*status == C2_CS_LOADING) {
 		if (target_is_directory) {
-			/* XXX scan directory, adding clinks */
+			XXX; /* scan directory, adding clinks */
 		} else {
-			/* XXX clink_add(&obj->co_chan) */
+			XXX; /* clink_add(&obj->co_chan) */
 		}
 	} else {
-		C2_IMPOSSIBLE("XXX");
+		C2_IMPOSSIBLE("invalid object status");
 	}
 
 	return 0;
 }
 
-static void check_cb(struct c2_sm *mach)
+/** Actions to perform on entering CHECK state. */
+static void check_st_in(struct c2_sm *mach)
 {
 	int rc;
-	enum c2_conf_status result;
+	enum c2_conf_status status;
 	struct c2_confc_fetchctx *ctx =
 		container_of(mach, struct c2_confc_fetchctx, fc_mach);
 
-	rc = cache_path_check(ctx->path, &result);
-	if (rc != 0)
+	C2_PRE(c2_mutex_is_locked(&confc_cache.cc_sm_group->s_lock));
+
+	rc = path_status(ctx, &status);
+	if (rc != 0) {
+		C2_ASSERT(rc < 0);
+		ctx->fc_errno = rc;
+		c2_sm_fail(mach, S_FAILURE, rc);
+		goto end;
+	}
+
+	if (status == C2_CS_MISSING) {
 		XXX;
-	XXX;
+	} else if (status == C2_CS_LOADING) {
+		XXX;
+	} else if (status == C2_CS_READY) {
+		C2_ASSERT(ctx->fc_result != NULL && mach->sm_rc == 0
+			  && ctx->fc_errno == 0);
+		c2_sm_state_set(mach, S_TERMINAL);
+	} else {
+		C2_IMPOSSIBLE("status is not valid");
+	}
+end:
+	C2_POST(c2_mutex_is_locked(&confc_cache.cc_sm_group->s_lock));
+}
+
+static bool failure_st_invariant(const struct c2_sm *mach)
+{
+	const struct c2_confc_fetchctx *ctx =
+		container_of(mach, const struct c2_confc_fetchctx, fc_mach);
+	return ctx->fc_result == NULL && ctx->fc_mach.sm_rc < 0
+		&& ctx->fc_errno == -ctx->fc_mach.sm_rc;
 }
 
 /**
@@ -167,18 +203,35 @@ static void check_cb(struct c2_sm *mach)
  *   - WAIT_STATUS
  *
  */
-const struct c2_sm_state_descr confc_states[S_NR] = {
+static const struct c2_sm_state_descr confc_states[S_NR] = {
 	[S_INITIAL] = {
 		.sd_flags     = C2_SDF_INITIAL,
 		.sd_name      = "INITIAL",
 		.sd_in        = NULL,
 		.sd_ex        = NULL,
 		.sd_invariant = NULL,
-		.sd_allowed   = (1 << S_CHECK),
+		.sd_allowed   = (1 << S_CHECK)
 	},
+	[S_CHECK] = {
+		.sd_flags     = 0,
+		.sd_name      = "CHECK",
+		.sd_in        = check_st_in,
+		.sd_ex        = NULL,
+		.sd_invariant = NULL,
+		.sd_allowed   = (1 << S_WAIT_REPLY) | (1 << S_WAIT_STATUS)
+		| (1 << S_TERMINAL) | (1 << S_FAILURE)
+	},
+	[S_FAILURE] = {
+		.sd_flags     = C2_SDF_FAILURE,
+		.sd_name      = "FAILURE",
+		.sd_in        = NULL,
+		.sd_ex        = NULL,
+		.sd_invariant = failure_st_invariant,
+		.sd_allowed   = 0
+	}
 };
 
-struct c2_sm_conf confc_states_conf = {
+static struct c2_sm_conf confc_states_conf = {
 	.scf_name      = "confc states",
 	.scf_nr_states = S_NR,
 	.scf_state     = confc_states
diff --git a/conf/confc.h b/conf/confc.h
index 45a55bf..9c1a11c 100644
--- a/conf/confc.h
+++ b/conf/confc.h
@@ -47,7 +47,7 @@ void c2_confc_fini(void);
 struct c2_confc_fetchctx {
 	struct c2_sm fc_mach;
 	void        *fc_result;
-	int          fc_errno;
+	int          fc_errno; /* XXX Can we just use -fc_mach.sm_rc? */
 
 	/* The remaining fields (fc__*) are not supposed to be
 	 * accessed by configuration consumers. */
diff --git a/conf/confop.ff b/conf/confop.ff
index 22841dd..18843e6 100644
--- a/conf/confop.ff
+++ b/conf/confop.ff
@@ -22,7 +22,11 @@
 require "cfg/cfg"; /* C2_CFG_NAME_LEN, C2_CFG_PARAM_LEN,
 		    * C2_CFG_SERVICE_MAX_END_POINTS */
 
-/* Sequence of bytes. */
+/*
+ * Sequence of bytes.
+ *
+ * XXX Can this structure be used instead of c2_conf_bytes?
+ */
 sequence {
 	u32 fb_len;
 	u8  fb_data
@@ -30,23 +34,26 @@ sequence {
 
 /* Array of C2_CFG_NAME_LEN bytes. cfg/cfg.h puts names in such arrays. */
 sequence {
-	void n_none :C2_CFG_NAME_LEN;
-	u8   n_data
+	void fs_none :C2_CFG_NAME_LEN;
+	u8   fs_data
 } c2_confop_fixstr;
 
-/* Configuration request FOP. */
-record {
-	/*
-	 * Type of the requested configuration object.
-	 * See c2_conf_objtype for values.
-	 */
-	u32             ff_objtype;
-
-	/* Key of the requested object. */
-	c2_confop_bytes ff_objkey;
+union {
+	u8              pc_iskey;
+	u32             pc_relation :0;
+	c2_confop_bytes pc_key      :1
+} c2_confop_pathcomp;
 
-	/* Depth of retrieval. */
-	u32             ff_depth
+/* Configuration fetch request. */
+record {
+	record {
+		u32             o_objtype; /* see c2_conf_objtype for values */
+		c2_confop_bytes o_objkey
+	} ff_origin; /* configuration object the path originates from */
+	sequence {
+		u32                c_nr;
+		c2_confop_pathcomp c_data
+	} ff_comps  /* path components */
 } c2_confop_fetch;
 
 /* Configuration of a profile. */
@@ -137,9 +144,9 @@ record {
 } c2_confop_partition;
 
 record {
-	c2_confop_bytes fo_objkey;
+	c2_confop_bytes fo_key;
 	union {
-		u8                   v_objtype;
+		u8                   v_type;
 		c2_confop_profile    v_profile;
 		c2_confop_filesystem v_filesystem;
 		c2_confop_service    v_service;
-- 
1.8.3.2

