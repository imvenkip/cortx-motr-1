From 0c1e9511fac1aa63621517a00c09e17a19dac9da Mon Sep 17 00:00:00 2001
From: Anatoliy Bilenko <anatoliy_bilenko@xyratex.com>
Date: Thu, 19 Jul 2012 13:17:26 +0300
Subject: [PATCH 254/311] Updated DLD of `Configuration server Confd':

      - Fixed grammar defects;
      - Minor fixes.
---
 conf/confd.c | 118 +++++++++++++++++++++--------------------------------------
 conf/confd.h |  29 ++++-----------
 2 files changed, 49 insertions(+), 98 deletions(-)

diff --git a/conf/confd.c b/conf/confd.c
index 2ff228a..36ffaac 100644
--- a/conf/confd.c
+++ b/conf/confd.c
@@ -1,4 +1,4 @@
-/* -*- c -*- */
+/* -*- C -*- */
 /*
  * COPYRIGHT 2012 XYRATEX TECHNOLOGY LIMITED
  *
@@ -89,8 +89,8 @@
  * allocate Confd service and its internal structures in memory @ref
  * c2_confd_service_locate() is used.
  *
- * Confd service is registered in `subsystem' data structure of
- * "colibri/init.c", the following lines have to be added:
+ * Confd service type is registered in `subsystem' data structure of
+ * "colibri/init.c", the following lines are added:
  * @code
  * struct init_fini_call subsystem[] = {
  *      ...
@@ -197,10 +197,10 @@
  * <hr> <!------------------------------------------------------------>
  * @section confd-lspec-state State Specification
  *
- * Confd has not a state machine, phase processing is implemented on
- * basis of FOM of c2_conf_fetch, c2_conf_update FOPs.  After
- * corresponding FOM went through a list of FOM specific phases it
- * transited into F_INITIAL phase.
+ * Confd as a whole is not a state machine, phase processing is
+ * implemented on basis of FOM of c2_conf_fetch, c2_conf_update FOPs.
+ * After corresponding FOM went through a list of FOM specific phases
+ * it transited into F_INITIAL phase.
  *
  * The number of state machine instances correspond to the number of
  * FOPs being processed in confd.
@@ -212,17 +212,17 @@
  *      edge [fontsize=9];
  *      F_INITIAL [style=filled, fillcolor=lightgrey];
  *      F_SERIALISE;
- *      F_WAIT_RDLK;
+ *      F_REQ_RDLK;
  *      F_TERMINATE [style=filled, fillcolor=lightgrey];
  *      F_FAILURE [style=filled, fillcolor=lightgrey];
  *
- *      F_INITIAL -> F_WAIT_RDLK [label=
+ *      F_INITIAL -> F_REQ_RDLK [label=
  *      "c2_conf_fetch-FOP is arrived"];
  *
- *      F_WAIT_RDLK -> F_WAIT_RDLK [label=
+ *      F_REQ_RDLK -> F_REQ_RDLK [label=
  *      "!c2_long_read_lock(c2_confd::c_cache::ca_rwlock)"];
  *
- *      F_WAIT_RDLK -> F_SERIALISE [label=
+ *      F_REQ_RDLK -> F_SERIALISE [label=
  *      "c2_long_read_lock(c2_confd::c_cache::ca_rwlock)"];
  *
  *      F_SERIALISE -> F_TERMINATE [label = "success"];
@@ -234,13 +234,12 @@
  *   In this phase, incoming FOM/FOP-related structures are being
  *   initialized and FOP-processing preconditions are being
  *   checked. Then fetch_next_state() is called and FOM is transited
- *   into F_WAIT_RDLK.
+ *   into F_REQ_RDLK.
  *
- * - F_WAIT_RDLK:
+ * - F_REQ_RDLK:
  *   In this phase, an attempt is made to obtain a read lock
- *   c2_confd::c_cache::ca_rwlock. If it's obtained then
- *   fetch_next_state() transits FOM back into F_SERIALISE.  Otherwise
- *   FOM remains in the same phase until lock is obtained.
+ *   c2_confd::c_cache::ca_rwlock. When it's obtained then
+ *   c2_long_lock logic transits FOM back into F_SERIALISE.
  *
  * - F_SERIALISE:
  *   Current design assumes that data is pre-loaded into configuration
@@ -276,17 +275,17 @@
  *      edge [fontsize=9];
  *      U_INITIAL [style=filled, fillcolor=lightgrey];
  *      U_UPDATE;
- *      U_WAIT_WRLK;
+ *      U_REQ_WRLK;
  *      U_TERMINATE [style=filled, fillcolor=lightgrey];
  *      U_FAILURE [style=filled, fillcolor=lightgrey];
  *
- *      U_INITIAL -> U_WAIT_WRLK [label=
- *      "!c2_long_write_lock(c2_confd::c_cache::ca_rwlock)"];
+ *      U_INITIAL -> U_REQ_WRLK [label=
+ *      "c2_conf_update-FOP is arrived"];
  *
- *      U_WAIT_WRLK -> U_WAIT_WRLK [label=
+ *      U_REQ_WRLK -> U_REQ_WRLK [label=
  *      "!c2_long_write_lock(c2_confd::c_cache::ca_rwlock)"];
  *
- *      U_WAIT_WRLK -> U_UPDATE [label=
+ *      U_REQ_WRLK -> U_UPDATE [label=
  *      "c2_long_write_lock(c2_confd::c_cache::ca_rwlock)"];
  *
  *      U_UPDATE -> U_TERMINATE [label = "success"];
@@ -298,14 +297,12 @@
  *   In this phase, incoming FOM/FOP-related structures are being
  *   initialized and FOP-processing preconditions are being
  *   checked. Then fetch_next_state() is called and FOM is transited
- *   into F_WAIT_WRLK.
+ *   into F_REQ_WRLK.
  *
- * - U_WAIT_WRLK:
- *   In current phase, an attempt is made to obtain a write lock
- *   c2_confd::c_cache::ca_rwlock. In this case, update_next_state()
- *   is called and FOM is transited into U_WAIT_WRLK phase.  Otherwise
- *   configuration c2_confd::c_cache::ca_rwlock is being locked as a
- *   write lock and transited into U_UPDATE.
+ * - U_REQ_WRLK:
+ *   In this phase, an attempt is made to obtain a write lock
+ *   c2_confd::c_cache::ca_rwlock. When it's obtained then
+ *   c2_long_lock logic transits FOM back into U_UPDATE.
  *
  * - U_UPDATE:
  *   In current phase, c2_confd::c_cache::ca_rwlock lock has been
@@ -353,26 +350,21 @@
  * obtained.
  *
  * The following code example shows how to perform a transition from
- * F_WAIT_RDLK to F_SERIALISE and obtain a lock:
+ * F_REQ_RDLK to F_SERIALISE and obtain a lock:
  * @code
  * static int fom_fetch_state(struct c2_fom *fom)
  * {
- *	//...
- *	if (fom->fo_phase == F_WAIT_RDLK) {
- *		// try to obtain a lock, when it's obtained FOM is
- *		// transitted into F_SERIALISE
- *
- *		if (!c2_long_{read,write}_lock(lock, fom, F_SERIALISE))
- *			return C2_FSO_WAIT;
- *
- *		// ...
- *
- *              C2_ASSERT(c2_long_is_{read,write}_locked());
- *
- *		fom->fo_phase = F_SERIALISE;
- *		return C2_FSO_AGAIN;
- *	}
- *	//...
+ *      //...
+ *      struct c2_long_lock_link *link;
+ * 	if (fom->fo_phase == F_REQ_RDLK) {
+ * 		// initialise things
+ *		// Retreive long lock link from derived FOM object: link = ...;
+ * 		// and acquire the lock
+ * 		return C2_FOM_LONG_LOCK_RETURN(c2_long_read_lock(lock, 
+ * 								 link, 
+ * 								 F_SERIALISE));
+ * 	}
+ * 	//...
  * }
  * @endcode
  * @see fom-longlock <!-- @todo fom-longlock has to be defined in future -->
@@ -406,12 +398,8 @@
  *
  * In cases, when there are multiple request handlers, for example,
  * for different networks, several confd instances should be created,
- * one per each request handler.
- *
- * Since that the number of fetch requests is orders of magnitude
- * greater than the number of update requests the same configuration
- * cache is shared between confd instances running in different
- * localities.
+ * one per each request handler. Each confd instance has its own copy
+ * of pre-loaded configuration data-base
  *
  * <hr> <!------------------------------------------------------------->
  * @section confd-ut Unit Tests
@@ -470,7 +458,7 @@
 enum c2_confd_fetch_status {
 	F_INITIAL = FOPH_NR + 1,
 	F_SERIALISE,
-	F_WAIT_RDLK,
+	F_REQ_RDLK,
 	F_TERMINATE,
 	F_FAILURE
 };
@@ -481,35 +469,13 @@ enum c2_confd_fetch_status {
 enum c2_confd_update_status {
 	U_INITIAL = FOPH_NR + 1,
 	U_UPDATE,
-	U_WAIT_WRLK,
+	U_REQ_WRLK,
 	U_WORK,
 	U_TERMINATE,
 	U_FAILURE
 };
 
 /**
- * Confd service addb context.
- */
-static const struct c2_addb_ctx_type addb_confd = {
-	.act_name = "addb-confd"
-};
-
-enum {
-	C2_ADDB_EVENT_CONFD_INFO,
-	C2_ADDB_EVENT_CONFD_WARN,
-	C2_ADDB_EVENT_CONFD_ERR
-};
-
-C2_ADDB_EV_DEFINE(addb_confd, "addb-confd-info", C2_ADDB_EVENT_CONFD_INFO,
-		  C2_ADDB_INVAL);
-
-C2_ADDB_EV_DEFINE(addb_confd, "addb-confd-warn", C2_ADDB_EVENT_CONFD_WARN,
-		  C2_ADDB_INVAL);
-
-C2_ADDB_EV_DEFINE(addb_confd, "addb-confd-err", C2_ADDB_EVENT_CONFD_ERR,
-		  C2_ADDB_INVAL);
-
-/**
  * Allocates and initiates Confd service instance.
  *
  * @pre stype != NULL && service != NULL
@@ -619,7 +585,7 @@ static const struct c2_reqh_service_ops c2_confd_service_ops = {
  * @pre out is not initialized.
  */
 static int obj_serialize(struct c2_confd *confd,
-			 struct c2_conf_pathcomp *path,
+			 const struct c2_conf_pathcomp *path,
 			 struct c2_fop *fout)
 {
 }
diff --git a/conf/confd.h b/conf/confd.h
index 1148ea0..9a69aab 100644
--- a/conf/confd.h
+++ b/conf/confd.h
@@ -1,4 +1,4 @@
-/* -*- c -*- */
+/* -*- C -*- */
 /*
  * COPYRIGHT 2012 XYRATEX TECHNOLOGY LIMITED
  *
@@ -52,7 +52,7 @@
  * <hr> <!------------------------------------------------------------>
  * @section confd-fspec-data Data Structures
  *
- * - c2_confd --- epresents configuration service instance registered
+ * - c2_confd --- represents configuration service instance registered
  *   in request handler, stores structures to perform caching,
  *   accesses to configuration db and handles configuration data
  *   requests.
@@ -86,9 +86,6 @@
  * <!------------------------------------------------------------------>
  * @subsection confd-fspec-sub-setup Initialization and termination
  *
- * To parametrise confd, user should provide arguments through
- * environment variables.  See @ref confd-fspec-cli.
- *
  * Confd is initiated and put into operation by request handler logic,
  * after colibri is started. Confd service should be registered in
  * request handler with c2_confd_service_register() call, where it has
@@ -157,28 +154,16 @@ struct c2_confd_cache {
 	struct c2_dbenv	       *ca_db;
 	/** Registry of cached configuration objects */
 	struct c2_conf_map	ca_cache;
-	/** Tracks a number of confds using c2_confd_cache */
-	struct c2_ref		ca_ref;
 	/** Protects this structure while processing of c2_conf_fetch
 	 * and c2_conf_update FOPs */
 	struct c2_longlock	ca_rwlock;
 };
 
-/** Configuration service statistics */
+/**
+ * Configuration service statistics
+ * @todo To be defined.
+ */
 struct c2_confd_stat {
-	/** Configuration cache entries count. */
-	uint32_t cs_cache_ent_cnt;
-	/** Processed configuration requests count of configuration service. */
-	uint32_t cs_req_cnt;
-	/** Processed update requests count of configuration service. */
-	uint32_t cs_upd_cnt;
-	/** Time elapsed on configuration requests processing. */
-	c2_time_t cs_req_time;
-	/** Time elapsed on update requests processing. */
-	c2_time_t cs_upd_time;
-
-	/** Protects this structure from concurrent access */
-	struct c2_mutex	cs_lock;
 };
 
 int c2_confd_service_register(void);
@@ -199,7 +184,7 @@ struct c2_confd {
         uint64_t		rcs_magic;
 
 	struct c2_addb_ctx	c_addb;
-	struct c2_confd_cache  *c_cache;
+	struct c2_confd_cache   c_cache;
 	struct c2_confd_stat	c_stat;
 };
 
-- 
1.8.3.2

