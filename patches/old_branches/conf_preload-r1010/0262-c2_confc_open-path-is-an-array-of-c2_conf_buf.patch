From 63af3ebf5815b28757e69ed255156a445ef2ff37 Mon Sep 17 00:00:00 2001
From: "Valery V. Vorotyntsev" <valery_vorotyntsev@xyratex.com>
Date: Tue, 24 Jul 2012 00:03:05 +0300
Subject: [PATCH 262/311] c2_confc_open*(): path is an array of c2_conf_buf

Rename c2_confc_open*() to c2__confc_open*() and introduce helper
macros.

+ Change c2_confc_ctx::fc_path to be a pointer. The path itself is
  maintained by the application.
+ C2_CONF_BUF_ZERO: new initialiser.
+ c2_conf_buf_streq(): new function.
+ confc.c: path_store() is not needed any more.
---
 conf/buf.h     | 12 +-------
 conf/confc.c   | 63 +++++++++------------------------------
 conf/confc.h   | 93 ++++++++++++++++++++++++++++++++++------------------------
 conf/obj.c     | 12 +++++---
 conf/obj_ops.c | 24 +++++----------
 5 files changed, 86 insertions(+), 118 deletions(-)

diff --git a/conf/buf.h b/conf/buf.h
index 11d46dc..90afd32 100644
--- a/conf/buf.h
+++ b/conf/buf.h
@@ -35,6 +35,7 @@
  */
 #define C2_CONF_BUF_INIT(size, data) { .cb_size = (size), .cb_data = (data) }
 #define C2_CONF_BUF_STR(str) { .cb_size = strlen(str), .cb_data = (str) }
+#define C2_CONF_BUF_ZERO { .cb_size = 0, .cb_data = NULL }
 
 /** Returns true iff two buffers are equal. */
 bool c2_conf_buf_eq(const struct c2_conf_buf *x, const struct c2_conf_buf *y);
@@ -47,15 +48,4 @@ bool c2_conf_buf_eq(const struct c2_conf_buf *x, const struct c2_conf_buf *y);
  */
 int c2_conf_buf_copy(struct c2_conf_buf *dest, const struct c2_conf_buf *src);
 
-/**
- * Duplicates a string into c2_conf_buf.
- *
- * @pre  dest->cb_size == 0 && dest->cb_data == NULL
- */
-static inline int c2_conf_buf_strdup(struct c2_conf_buf *dest, const char *src)
-{
-	return c2_conf_buf_copy(dest, &(const struct c2_conf_buf)
-				C2_CONF_BUF_STR(src));
-}
-
 #endif /* __COLIBRI_CONF_BUF_H__ */
diff --git a/conf/confc.c b/conf/confc.c
index ebc6171..0941c89 100644
--- a/conf/confc.c
+++ b/conf/confc.c
@@ -278,7 +278,8 @@ static int cache_preload(struct c2_confc *confc, const char *conf_str);
 static bool confc_invariant(const struct c2_confc *confc);
 
 int c2_confc_init(struct c2_confc *confc, const char *conf_source,
-		  const char *profile, struct c2_sm_group *sm_group)
+		  const struct c2_conf_buf *profile,
+		  struct c2_sm_group *sm_group)
 {
 	/*
 	 * int rc;
@@ -286,10 +287,9 @@ int c2_confc_init(struct c2_confc *confc, const char *conf_source,
 	 *
 	 * C2_PRE(confc->cc_root == NULL && confc->cc_group == NULL);
 	 * C2_PRE(conf_source != NULL && *conf_source != 0);
-	 * C2_PRE(profile != NULL && *profile != 0);
+	 * C2_PRE(XXX_sanity_check(profile));
 	 *
-	 * root = c2_conf_obj_new(C2_CO_PROFILE, &(const struct c2_conf_buf)
-	 *                        C2_CONF_BUF_STR(profile));
+	 * root = c2_conf_obj_new(C2_CO_PROFILE, profile);
 	 * if (root == NULL)
 	 *     return -ENOMEM;
 	 * root->co_confc = confc;
@@ -439,23 +439,19 @@ int32_t c2_confc_ctx_error(const struct c2_confc_ctx *ctx)
  * open/close
  * ------------------------------------------------------------------ */
 
-static int path_store(const char *path, struct c2_conf_buf *dest, uint32_t len);
 static void ast_state_set(struct c2_sm_ast *ast, enum confc_ctx_state state);
 
-int c2_confc_open(struct c2_confc_ctx *ctx, struct c2_conf_obj *origin,
-                  const char *path)
+int c2__confc_open(struct c2_confc_ctx *ctx, struct c2_conf_obj *origin,
+		   const struct c2_conf_buf path[])
 {
-	int rc;
-
 	C2_PRE(ctx_invariant(ctx));
 	C2_PRE(ergo(origin != NULL, origin->co_confc == ctx->fc_confc));
-	C2_PRE(ctx->fc_origin == NULL && XXX_is_zeroed(ctx->fc_path));
+	C2_PRE(ctx->fc_origin == NULL && ctx->fc_path == NULL);
 
 	ctx->fc_origin = origin == NULL ? ctx->fc_confc->cc_root : origin;
-	rc = path_store(path, ctx->fc_path, ARRAY_SIZE(ctx->fc_path) - 1);
-	if (rc == 0)
-		ast_state_set(&ctx->fc_ast, S_CHECK);
-	return rc;
+	ctx->fc_path = path;
+	ast_state_set(&ctx->fc_ast, S_CHECK);
+	return 0;
 }
 
 struct sm_waiter {
@@ -471,8 +467,8 @@ static bool sm_filter(struct c2_clink *link)
 	return e == EINPROGRESS;
 }
 
-int c2_confc_open_sync(struct c2_conf_obj **result, struct c2_conf_obj *origin,
-                       const char *path)
+int c2__confc_open_sync(struct c2_conf_obj **result, struct c2_conf_obj *origin,
+			const struct c2_conf_buf path[])
 {
 	struct sm_waiter w;
 	int              rc;
@@ -483,7 +479,7 @@ int c2_confc_open_sync(struct c2_conf_obj **result, struct c2_conf_obj *origin,
 	c2_clink_init(&w.w_clink, sm_filter);
 	c2_clink_add(&w.w_ctx.fc_mach.sm_chan, &w.w_clink);
 
-	rc = c2_confc_open(&w.w_ctx, origin, path);
+	rc = c2__confc_open(&w.w_ctx, origin, path);
 	if (rc == 0) {
 		while ((rc = c2_confc_ctx_error(&w.w_ctx)) == EINPROGRESS)
 			c2_chan_wait(&w.w_clink);
@@ -810,7 +806,7 @@ static int path_walk(struct c2_confc_ctx *ctx)
  * @param ctx  Configuration retrieval context.
  * @param obj  The object reached by a path walk.
  * @param ri   The position in ctx->fc_path[] where the remaining (not
- *             followed) path components start.
+ *             visited) path components start.
  */
 static int
 path_walk_complete(struct c2_confc_ctx *ctx, struct c2_conf_obj *obj, size_t ri)
@@ -1041,37 +1037,6 @@ cache_grow(struct c2_conf_map *reg, const struct c2_conf_fetch_resp *resp)
  * misc
  * ------------------------------------------------------------------ */
 
-/**
- * Finds position and length of each path component and stores this
- * information in an array of c2_conf_bufs.
- *
- * @param path  Path string. It consists of path components separated by
- *              slash ('/').
- * @param dest  Array to put path components information into.
- * @param len   Maximum number of elements to store.
- *
- * @note  Escape sequences are not supported. E.g., "one/two/thre\/e"
- *        has four path components, not three.
- *
- * XXX @todo c2_conf_buf::cb_data and `path' are not const-compatible.
- *     Such an assignment will result in compilation error:
- *         dest[i]->cb_data = path + n;
- *     Requirements: I do want `path' to be const, but I'd prefer to
- *     avoid strdup(3)ing it.
- */
-static int path_store(const char *path, struct c2_conf_buf *dest, uint32_t len)
-{
-	/*
-	 * Return -ENAMETOOLONG if path has more than len components.
-	 *
-	 * UT:
-	 *   - trailing slash is ignored ("abc/"  --- one component);
-	 *   - multiple slashes are error ("abc//");
-	 *   - leading slash is error ("/abc").
-	 */
-	XXX;
-}
-
 static bool request_is_valid(const struct c2_conf_fetch *req)
 {
 	return  req->f_origin.oi_type < C2_CO_NR &&
diff --git a/conf/confc.h b/conf/confc.h
index 484926d..7880b8e 100644
--- a/conf/confc.h
+++ b/conf/confc.h
@@ -27,6 +27,7 @@
 #endif
 #include "conf/obj.h"
 #include "conf/map.h"        /* c2_conf_map */
+#include "conf/buf.h"        /* C2_CONF_BUF_ZERO */
 #include "sm/sm.h"           /* c2_sm, c2_sm_ast */
 #include "fop/fop.h"         /* c2_fop */
 
@@ -152,8 +153,8 @@ struct c2_mutex;
  * @section confc-fspec-recipes Recipes
  *
  * Configuration objects can be opened asynchronously (c2_confc_open())
- * or synchronously (c2_confc_open_sync()). Most of the examples below
- * use synchronous call for the sake of brevity.
+ * or synchronously (c2_confc_open_sync()). Many of the examples below
+ * use synchronous calls for the sake of brevity.
  *
  * @subsection confc-fspec-recipe1 Getting configuration data of the filesystem
  *
@@ -179,7 +180,7 @@ struct c2_mutex;
  *
  *         sm_waiter_init(&w, g_confc);
  *
- *         rc = c2_confc_open(&w.w_ctx, NULL, "filesystem");
+ *         rc = c2_confc_open(&w.w_ctx, NULL, C2_CONF_BUF_STR("filesystem"));
  *         if (rc == 0) {
  *                 rc = sm_waiter_wait(&w);
  *                 if (rc == 0)
@@ -193,7 +194,8 @@ struct c2_mutex;
  *
  * static int filesystem_open_sync(struct c2_conf_filesystem **fs)
  * {
- *         return c2_confc_open_sync(fs, confc->cc_root, "filesystem");
+ *         return c2_confc_open_sync(fs, g_confc->cc_root,
+ *                                   C2_CONF_BUF_STR("filesystem"));
  * }
  *
  * // Filters out intermediate state of c2_confc_ctx::fc_mach.
@@ -244,7 +246,8 @@ struct c2_mutex;
  *         int rc;
  *
  *         rc = c2_confc_open_sync(&dir_obj, g_confc->cc_root,
- *                                 "filesystem/services");
+ *                                 C2_CONF_BUF_STR("filesystem"),
+ *                                 C2_CONF_BUF_STR("services"));
  *         if (rc != 0)
  *                 return rc;
  *         c2_conf_dircur_init(&cur, dir_obj);
@@ -281,7 +284,8 @@ struct c2_mutex;
  *
  * // Accesses configuration data of devices used by specific service
  * // on specific node.
- * static int specific_devices_process(const char *svc_id, const char *node_id)
+ * static int specific_devices_process(const struct c2_conf_buf *svc_id,
+ *                                     const struct c2_conf_buf *node_id)
  * {
  *         struct c2_conf_obj   *dir_obj;
  *         struct c2_conf_dircur dir;
@@ -289,7 +293,8 @@ struct c2_mutex;
  *         int rc;
  *
  *         rc = c2_confc_open_sync(&dir_obj, g_confc->cc_root,
- *                                 "filesystem/services");
+ *                                 C2_CONF_BUF_STR("filesystem"),
+ *                                 C2_CONF_BUF_STR("services"));
  *         if (rc != 0)
  *                 return rc;
  *         c2_conf_dircur_init(&dir, dir_obj);
@@ -300,13 +305,14 @@ struct c2_mutex;
  *         while ((rc = c2_confc_readdir_sync(&svc_obj, &dir)) > 0) {
  *                 struct c2_conf_obj *node_obj;
  *
- *                 if (!streq(svc_obj->co_id, svc_id))
+ *                 if (!c2_conf_buf_eq(svc_obj->co_id, svc_id))
  *                         // This is not the service we are looking for.
  *                         continue;
  *
- *                 rc = c2_confc_open_sync(&node_obj, svc_obj, "node");
+ *                 rc = c2_confc_open_sync(&node_obj, svc_obj,
+ *                                         C2_CONF_BUF_STR("node"));
  *                 if (rc == 0) {
- *                         if (streq(node_obj->co_id, node_id))
+ *                         if (c2_conf_buf_eq(node_obj->co_id, node_id))
  *                                 rc = node_devices_process(node_obj);
  *                         c2_confc_close(node_obj);
  *                 }
@@ -335,7 +341,7 @@ struct c2_mutex;
  *         struct c2_conf_obj   *obj;
  *         int                   rc;
  *
- *         rc = c2_confc_open_sync(&dir_obj, node, "nics");
+ *         rc = c2_confc_open_sync(&dir_obj, node, C2_CONF_BUF_STR("nics"));
  *         if (rc != 0)
  *                 return rc;
  *         c2_conf_dircur_init(&dir, dir_obj);
@@ -358,7 +364,7 @@ struct c2_mutex;
  *         struct c2_conf_obj   *obj;
  *         int                   rc;
  *
- *         rc = c2_confc_open_sync(&dir_obj, node, "sdevs");
+ *         rc = c2_confc_open_sync(&dir_obj, node, C2_CONF_BUF_STR("sdevs"));
  *         if (rc != 0)
  *                 return rc;
  *         c2_conf_dircur_init(&dir, dir_obj);
@@ -522,7 +528,8 @@ struct c2_confc {
  *                     configuration cache.
  */
 int c2_confc_init(struct c2_confc *confc, const char *conf_source,
-		  const char *profile, struct c2_sm_group *sm_group);
+		  const struct c2_conf_buf *profile,
+		  struct c2_sm_group *sm_group);
 
 /**
  * Finalises configuration client. Destroys configuration cache,
@@ -537,20 +544,17 @@ void c2_confc_fini(struct c2_confc *confc);
  * context
  * ------------------------------------------------------------------ */
 
-/** Maximum number of path components. */
-enum { C2_CONFC_MAX_PATH_COMP = 16 };
-
 /** Configuration retrieval context. */
 struct c2_confc_ctx {
 	/** The confc instance this context belongs to. */
-	struct c2_confc     *fc_confc;
+	struct c2_confc          *fc_confc;
 	/** Context state machine. */
-	struct c2_sm         fc_mach;
+	struct c2_sm              fc_mach;
 	/**
 	 * Asynchronous system trap, used by the implementation to
 	 * schedule a transition of ->fc_mach state machine.
 	 */
-	struct c2_sm_ast     fc_ast;
+	struct c2_sm_ast          fc_ast;
 	/**
 	 * Origin of the requested path.
 	 *
@@ -559,30 +563,32 @@ struct c2_confc_ctx {
 	 * measures to pin this object for the duration of path
 	 * traversal.  See the note in @ref confc-fspec-sub-use.
 	 */
-	struct c2_conf_obj  *fc_origin;
+	struct c2_conf_obj       *fc_origin;
 	/**
 	 * Path to the object requested by the application.
-	 * End of path is marked with zeroed c2_conf_buf.
+	 *
+	 * It is responsibility of application's programmer to ensure
+	 * validity of the path until configuration request completes.
 	 */
-	struct c2_conf_buf   fc_path[C2_CONFC_MAX_PATH_COMP + 1];
+	const struct c2_conf_buf *fc_path;
 	/** Configuration fetch request being sent to confd. */
-	struct c2_conf_fetch fc_req;
+	struct c2_conf_fetch      fc_req;
 	/** Request fop. */
-	struct c2_fop        fc_fop;
+	struct c2_fop             fc_fop;
 	/**
 	 * Record of interest in `object loading completed' or
 	 * `object unpinned' events.
 	 */
-	struct c2_clink      fc_clink;
+	struct c2_clink           fc_clink;
 	/**
 	 * Pointer to the requested configuration object.
 	 *
 	 * The application should use c2_confc_ctx_result() instead of
 	 * accessing this value.
 	 */
-	struct c2_conf_obj  *fc_result;
+	struct c2_conf_obj       *fc_result;
 	/** Magic number. */
-	uint64_t             fc_magix;
+	uint64_t                  fc_magix;
 };
 
 /**
@@ -637,16 +643,23 @@ struct c2_conf_obj *c2_confc_ctx_result(struct c2_confc_ctx *ctx);
  *
  * @param ctx     Fetch context.
  * @param origin  Path origin (NULL = root configuration object).
- * @param path    Path to the requested object.
+ * @param ...     Path to the requested object. The variable arguments
+ *                are c2_conf_buf initialisers (C2_CONF_BUF_INIT(),
+ *                C2_CONF_BUF_STR()); use C2_CONF_BUF_ZERO for empty
+ *                path.
  *
- * @note  The application must keep the string, pointed to by `path',
- *        intact until configuration retrieval completes.
+ * @note  The application must keep the data, pointed to by path
+ *        arguments, intact, until configuration retrieval operation
+ *        completes.
  *
  * @pre  ergo(origin != NULL, origin->co_confc == ctx->fc_confc)
- * @pre  ctx->fc_origin == NULL && ctx->fc_path is zeroed
+ * @pre  ctx->fc_origin == NULL && ctx->fc_path == NULL
  */
-int c2_confc_open(struct c2_confc_ctx *ctx, struct c2_conf_obj *origin,
-		  const char *path);
+#define c2_confc_open(ctx, origin, ...)				       \
+	c2__confc_open((ctx), (origin), (const struct c2_conf_buf []){ \
+			__VA_ARGS__, C2_CONF_BUF_ZERO })
+int c2__confc_open(struct c2_confc_ctx *ctx, struct c2_conf_obj *origin,
+		   const struct c2_conf_buf path[]);
 
 /**
  * Opens configuration object synchronously.
@@ -661,13 +674,17 @@ int c2_confc_open(struct c2_confc_ctx *ctx, struct c2_conf_obj *origin,
  * struct c2_conf_filesystem *fs;
  * int rc;
  *
- * rc = c2_confc_open_sync(&fs, confc->cc_root, "filesystem");
+ * rc = c2_confc_open_sync(&fs, confc->cc_root, C2_CONF_BUF_STR("filesystem"));
  * @endcode
  *
  * @see c2_confc_open()
  */
-int c2_confc_open_sync(struct c2_conf_obj **result, struct c2_conf_obj *origin,
-		       const char *path);
+#define c2_confc_open_sync(result, origin, ...)             \
+	c2__confc_open_sync((result), (origin),             \
+			    (const struct c2_conf_buf []) { \
+				    __VA_ARGS__, C2_CONF_BUF_ZERO })
+int c2__confc_open_sync(struct c2_conf_obj **result, struct c2_conf_obj *origin,
+			const struct c2_conf_buf path[]);
 
 /**
  * Closes configuration object opened with c2_confc_open() or
@@ -675,8 +692,8 @@ int c2_confc_open_sync(struct c2_conf_obj **result, struct c2_conf_obj *origin,
  *
  * c2_confc_close(NULL) is a noop.
  *
- * @note  The application must not close the objects obtained via
- *        c2_confc_readdir*().
+ * @note  The application must not c2_confc_close() the objects
+ *        obtained via c2_confc_readdir*().
  *
  * @pre  ergo(obj != NULL, obj->co_nrefs > 0)
  */
diff --git a/conf/obj.c b/conf/obj.c
index caf577b..161f0bd 100644
--- a/conf/obj.c
+++ b/conf/obj.c
@@ -388,10 +388,14 @@
  * (@todo Delete this section from the DLD when the feature is landed
  * into master.)
  *
- * - Object identifiers can be expressed perfectly well with C strings,
- *   so I'm going to use `const char *' for c2_conf_obj::co_id and get
- *   rid of c2_conf_buf.  The only place where c2_conf_buf (Pascal string)
- *   might remain is conf/onwire.ff.
+ * - c2_conf_buf should be replaced with c2_buf.
+ *   This task includes:
+ *   - reordering fields of c2_buf: ->b_nob, _then_ ->b_addr;
+ *   - adding lib/buf.ff;
+ *   - C2_BASSERT()ing in lib/misc.c that the structures, generated
+ *     from lib/buf.ff, are equivalent to struct c2_buf: i.e., field
+ *     sizes and field offsets are equal, so are sizes and alignments
+ *     of the whole structures.
  */
 
 /**
diff --git a/conf/obj_ops.c b/conf/obj_ops.c
index bada2f3..fb1ffb7 100644
--- a/conf/obj_ops.c
+++ b/conf/obj_ops.c
@@ -121,18 +121,8 @@ int c2_conf_obj_fill(struct c2_conf_obj *dest, const struct confx_object *src,
  * Implementations of ->coo_{lookup,readdir}() for concrete object types
  * ------------------------------------------------------------------ */
 
-/* XXX
- *
- * Note, that signatures of *_lookup()s below differ from the
- * signature of c2_conf_obj_ops::coo_lookup: `name' argument in the
- * latter is `const struct c2_conf_buf *', not `const char *'.
- *
- * I am going to use `const char *' for c2_conf_obj::co_id.
- * See @ref conf-impl-plan.
- */
-
-static int dir_lookup(struct c2_conf_obj *parent, const char *name,
-		      struct c2_conf_obj **out)
+static int dir_lookup(struct c2_conf_obj *parent,
+		      const struct c2_conf_buf *name, struct c2_conf_obj **out)
 {
 	struct c2_conf_obj     *child;
 	struct c2_conf_profile *dir = C2_CONF_CAST(parent, c2_conf_dir);
@@ -141,7 +131,7 @@ static int dir_lookup(struct c2_conf_obj *parent, const char *name,
 
 	/*
 	 * for_each(child in dir->cd_items) {
-	 *     if (streq(child->co_id, name)) {
+	 *     if (c2_conf_buf_eq(child->co_id, name)) {
 	 *         *out = child;
 	 *         return 0;
 	 *     }
@@ -165,15 +155,17 @@ static int dir_readdir(struct c2_conf_obj **result, struct c2_conf_dircur *cur)
 	XXX;
 }
 
-static int profile_lookup(struct c2_conf_obj *parent, const char *name,
-			  struct c2_conf_obj **out)
+static int
+profile_lookup(struct c2_conf_obj *parent, const struct c2_conf_buf *name,
+	       struct c2_conf_obj **out)
 {
 	struct c2_conf_obj     *child;
 	struct c2_conf_profile *prof = C2_CONF_CAST(parent, c2_conf_profile);
 
 	C2_PRE(parent->co_status == C2_CS_READY);
 
-	if (!streq(name, "filesystem"))
+	if (!c2_conf_buf_eq(name, &(const struct c2_conf_buf)
+			    C2_CONF_BUF_STR("filesystem")))
 		return -ENOENT;
 
 	child = &prof->cp_filesystem->cf_obj;
-- 
1.8.3.2

