From ea7656d25cf2ec55528f1d88ee066907307e8d1c Mon Sep 17 00:00:00 2001
From: "Valery V. Vorotyntsev" <valery_vorotyntsev@xyratex.com>
Date: Fri, 24 Aug 2012 22:39:53 +0300
Subject: [PATCH 296/311] conf/reg.c: get rid of auxiliary objptr structure

+ c2_conf_reg_delete(): New function.

LogD #830
RB: r/981
---
 conf/obj_ops.h |  3 ++
 conf/reg.c     | 99 ++++++++++++++++++++++++----------------------------------
 conf/reg.h     | 21 ++++++++++---
 conf/ut/reg.c  | 34 +++++++++++---------
 doc/magix      |  2 +-
 5 files changed, 81 insertions(+), 78 deletions(-)

diff --git a/conf/obj_ops.h b/conf/obj_ops.h
index b79f0c4..d5e4e10 100644
--- a/conf/obj_ops.h
+++ b/conf/obj_ops.h
@@ -39,6 +39,9 @@
  * @{
  */
 
+/** Magic value of a generic configuration object (c2_conf_obj). */
+enum { C2_CONF_OBJ_MAGIC = 0x335e1f1e55ce1177 };
+
 /** Allocates and initialises configuration object of given type. */
 struct c2_conf_obj *c2_conf_obj_new(enum c2_conf_objtype type,
 				    const struct c2_conf_buf *id);
diff --git a/conf/reg.c b/conf/reg.c
index 40679b8..21cdb44 100644
--- a/conf/reg.c
+++ b/conf/reg.c
@@ -22,99 +22,82 @@
 #  include "config.h"
 #endif
 #include "conf/reg.h"
-#ifdef __KERNEL__
-#  include "conf/onwire_k.h"
-#else
-#  include "conf/onwire_u.h" /* c2_conf_buf */
-#endif
-#include "conf/buf.h"        /* c2_conf_buf_eq */
-#include "lib/memory.h"      /* C2_ALLOC_PTR */
-#include "lib/errno.h"       /* ENOMEM */
+#include "conf/obj_ops.h" /* C2_CONF_OBJ_MAGIC */
+#include "conf/onwire.h"  /* c2_conf_buf */
+#include "conf/buf.h"     /* c2_conf_buf_eq */
+#include "lib/memory.h"   /* C2_ALLOC_PTR */
+#include "lib/errno.h"    /* ENOMEM */
 
 /**
  * @defgroup conf_dlspec_reg Registry of Cached Configuration Objects
  *
  * The implementation of a registry is based on linked list data structure.
- * (Rationale: a registry is not expected to be queried frequently.)
+ * Rationale: a registry is not expected to be queried frequently.
  *
  * @see @ref conf, @ref conf-lspec
  *
  * @{
  */
 
-/** Register entry. */
-struct objptr {
-	/** Payload --- a pointer to configuration object. */
-	struct c2_conf_obj *p_obj;
-	/** Linkage to c2_conf_reg::r_ptrs list. */
-	struct c2_tlink     p_linkage;
-	/** Magic value. */
-	uint64_t            p_magic;
-};
-
-enum {
-	CONF_REG_MAGIC = 0x33fab1edfe0da177,
-	OBJPTR_MAGIC   = 0x335e1f1e55ce1177
-};
-
-C2_TL_DESCR_DEFINE(reg, "registered c2_conf_obj-s", static, struct objptr,
-		   p_linkage, p_magic, OBJPTR_MAGIC, CONF_REG_MAGIC);
-C2_TL_DEFINE(reg, static, struct objptr);
+enum { REG_MAGIC = 0x33fab1edfe0da177 };
+
+C2_TL_DESCR_DEFINE(reg, "registered c2_conf_obj-s", static, struct c2_conf_obj,
+		   co_reg_link, co_magic.generic, C2_CONF_OBJ_MAGIC, REG_MAGIC);
+C2_TL_DEFINE(reg, static, struct c2_conf_obj);
 
 void c2_conf_reg_init(struct c2_conf_reg *reg)
 {
-	reg_tlist_init(&reg->r_ptrs);
+	reg_tlist_init(&reg->r_objs);
 }
 
-void c2_conf_reg_fini(struct c2_conf_reg *reg)
+void c2_conf_reg_add(struct c2_conf_reg *reg, struct c2_conf_obj *obj)
 {
 	struct objptr *p;
+	C2_PRE(!reg_tlist_contains(&reg->r_objs, obj));
 
-	c2_tlist_for(&reg_tl, &reg->r_ptrs, p) {
-		struct c2_conf_obj *obj = p->p_obj;
-		C2_ASSERT(obj->co_nrefs == 0 &&
-			  obj->co_status != C2_CS_LOADING);
+	reg_tlink_init(obj);
+	reg_tlist_add(&reg->r_objs, obj);
+}
 
-		if (obj->co_ops->coo_fini != NULL)
-			obj->co_ops->coo_fini(obj);
+struct c2_conf_obj *c2_conf_reg_lookup(const struct c2_conf_reg *reg,
+				       enum c2_conf_objtype type,
+				       const struct c2_conf_buf *id)
+{
+	struct c2_conf_obj *obj;
 
-		reg_tlist_del(p);
-		reg_tlink_fini(p);
-		c2_free(p);
+	c2_tlist_for(&reg_tl, &reg->r_objs, obj) {
+		if (obj->co_type == type && c2_conf_buf_eq(&obj->co_id, id))
+			return obj;
 	} c2_tlist_endfor;
 
-	reg_tlist_fini(&reg->r_ptrs);
+	return NULL;
 }
 
-int c2_conf_reg_add(struct c2_conf_reg *reg, struct c2_conf_obj *obj)
+static void del(struct c2_conf_obj *obj)
 {
-	struct objptr *p;
-	C2_PRE(c2_conf_reg_lookup(reg, obj->co_type, &obj->co_id) == NULL);
+	C2_PRE(obj->co_nrefs == 0 && obj->co_status != C2_CS_LOADING);
 
-	C2_ALLOC_PTR(p);
-	if (p == NULL)
-		return -ENOMEM;
+	if (obj->co_ops->coo_fini != NULL)
+		obj->co_ops->coo_fini(obj);
 
-	p->p_obj = obj;
-	reg_tlink_init(p);
-	reg_tlist_add(&reg->r_ptrs, p);
+	reg_tlink_del_fini(obj);
+}
 
-	return 0;
+void c2_conf_reg_delete(const struct c2_conf_reg *reg, struct c2_conf_obj *obj)
+{
+	C2_PRE(reg_tlist_contains(&reg->r_objs, obj));
+	del(obj);
 }
 
-struct c2_conf_obj *c2_conf_reg_lookup(const struct c2_conf_reg *reg,
-				       enum c2_conf_objtype type,
-				       const struct c2_conf_buf *id)
+void c2_conf_reg_fini(struct c2_conf_reg *reg)
 {
-	struct objptr *p;
+	struct c2_conf_obj *obj;
 
-	c2_tlist_for(&reg_tl, &reg->r_ptrs, p) {
-		if (p->p_obj->co_type == type &&
-		    c2_conf_buf_eq(&p->p_obj->co_id, id))
-			return p->p_obj;
+	c2_tlist_for(&reg_tl, &reg->r_objs, obj) {
+		del(obj);
 	} c2_tlist_endfor;
 
-	return NULL;
+	reg_tlist_fini(&reg->r_objs);
 }
 
 /** @} conf_dlspec_reg */
diff --git a/conf/reg.h b/conf/reg.h
index e1a4e77..ab194c5 100644
--- a/conf/reg.h
+++ b/conf/reg.h
@@ -65,8 +65,10 @@
 
 /** Registry of cached configuration objects. */
 struct c2_conf_reg {
-	struct c2_tl r_ptrs;  /*< List of pointers to the objects. */
-	uint64_t     r_magic; /*< Magic value. */
+	/** List of c2_conf_obj-s, linked through c2_conf_obj::co_reg_link. */
+	struct c2_tl r_objs;
+	/** Magic value. */
+	uint64_t     r_magic;
 };
 
 /** Initialises a registry. */
@@ -75,7 +77,7 @@ void c2_conf_reg_init(struct c2_conf_reg *reg);
 /**
  * Finalises a registry.
  *
- * c2_conf_reg_fini() does c2_conf_obj_ops::coo_fini() of every
+ * c2_conf_reg_fini() calls c2_conf_obj_ops::coo_fini() on every
  * registered configuration object.
  *
  * @pre  None of the registered objects is being used by the application
@@ -86,9 +88,18 @@ void c2_conf_reg_fini(struct c2_conf_reg *reg);
 /**
  * Registers new configuration object.
  *
- * @pre  No object with obj's identity is registered in reg.
+ * @pre  obj is not registered
  */
-int c2_conf_reg_add(struct c2_conf_reg *reg, struct c2_conf_obj *obj);
+void c2_conf_reg_add(struct c2_conf_reg *reg, struct c2_conf_obj *obj);
+
+/**
+ * Removes configuration object from the registry and finalises this
+ * object with c2_conf_obj_ops::coo_fini().
+ *
+ * @pre  obj is registered
+ * @pre  obj->co_nrefs == 0 && obj->co_status != C2_CS_LOADING
+ */
+void c2_conf_reg_delete(const struct c2_conf_reg *reg, struct c2_conf_obj *obj);
 
 /**
  * Searches for a configuration object given its identity (type & id).
diff --git a/conf/ut/reg.c b/conf/ut/reg.c
index 50ae956..024a652 100644
--- a/conf/ut/reg.c
+++ b/conf/ut/reg.c
@@ -32,13 +32,19 @@ static void obj_fini(struct c2_conf_obj *obj __attribute__((unused)))
 	++g_nr_finalised;
 }
 
-static void test_add_lookup(void)
+static void test_reg(void)
 {
 	struct c2_conf_reg           reg;
+	struct c2_conf_obj          *obj;
 	size_t                       i;
 	const struct c2_conf_obj_ops ops = { .coo_fini = obj_fini };
 	struct c2_conf_obj           samples[] = {
 		{
+			.co_type = C2_CO_NODE,
+			.co_id   = C2_CONF_BUF_INITS("node"),
+			.co_ops  = &ops
+		},
+		{
 			.co_type = C2_CO_DIR,
 			.co_id   = C2_CONF_BUF_INITS("dir"),
 			.co_ops  = &ops
@@ -53,22 +59,22 @@ static void test_add_lookup(void)
 	c2_conf_reg_init(&reg);
 
 	for (i = 0; i < sizeof samples; ++i) {
-		struct c2_conf_obj *p;
-		int                 rc;
+		obj = c2_conf_reg_lookup(&reg, samples[i].co_type,
+					 &samples[i].co_id);
+		C2_UT_ASSERT(obj == NULL);
 
-		p = c2_conf_reg_lookup(&reg, samples[i].co_type,
-				       &samples[i].co_id);
-		C2_UT_ASSERT(p == NULL);
-
-		rc = c2_conf_reg_add(&reg, &samples[i]);
-		C2_UT_ASSERT(rc == 0);
-
-		p = c2_conf_reg_lookup(&reg, samples[i].co_type,
-				       &samples[i].co_id);
-		C2_UT_ASSERT(p == &samples[i]);
+		c2_conf_reg_add(&reg, &samples[i]);
+		obj = c2_conf_reg_lookup(&reg, samples[i].co_type,
+					 &samples[i].co_id);
+		C2_UT_ASSERT(obj == &samples[i]);
 	}
 
 	C2_UT_ASSERT(g_nr_finalised == 0);
+	c2_conf_reg_delete(&reg, obj);
+	C2_UT_ASSERT(g_nr_finalised == 1);
+	obj = c2_conf_reg_lookup(&reg, obj->co_type, obj->co_id);
+	C2_UT_ASSERT(obj == NULL);
+
 	c2_conf_reg_fini(&reg);
 	C2_UT_ASSERT(g_nr_finalised == sizeof samples);
 }
@@ -79,7 +85,7 @@ const struct c2_test_suite conf_reg_ut = {
 	.ts_init  = NULL,
 	.ts_fini  = NULL,
 	.ts_tests = {
-		/* { "conf-reg-add-lookup", test_add_lookup }, */
+		/* { "conf-reg", test_reg }, */
 		{ NULL, NULL }
 	}
 };
diff --git a/doc/magix b/doc/magix
index cafbbec..4904f5f 100755
--- a/doc/magix
+++ b/doc/magix
@@ -39,4 +39,4 @@ c2_long_lock         l_magix                 0b055b1e55edba55 boss blessed bass
 c2_fom_thread        lt_magix                fa151f1ab1ec0b01 falsifiable COBOL
 thr_tl               td_head_magic           dec1a551f1edcade declassified cade
 c2_conf_reg          r_magic                 33fab1edfe0da177 fabled feodal
-objptr               p_magic                 335e1f1e55ce1177 selfless cell
+c2_conf_obj          co_magic.generic        335e1f1e55ce1177 selfless cell
-- 
1.8.3.2

