From 9086eab66876ebb742b3b34d18e709a65518774a Mon Sep 17 00:00:00 2001
From: "Valery V. Vorotyntsev" <valery_vorotyntsev@xyratex.com>
Date: Thu, 1 Mar 2012 12:39:34 +0200
Subject: [PATCH 028/311] describe the logic of c2_confc_{init,fini}()

---
 conf/cache.h       |  8 ++---
 conf/confc.c       | 89 +++++++++++++++++++++++++++++++++++++++++++++++-------
 conf/confc.h       | 15 ++++++++-
 conf/obj.h         |  9 ++++--
 conf/relation.c    |  1 +
 conf/relation.h    |  3 ++
 conf/ut/confc.c    | 36 +++++++++-------------
 conf/ut/relation.c |  1 +
 8 files changed, 122 insertions(+), 40 deletions(-)

diff --git a/conf/cache.h b/conf/cache.h
index b58c812..e048a2b 100644
--- a/conf/cache.h
+++ b/conf/cache.h
@@ -21,7 +21,7 @@
 #define __COLIBRI_CONF_CACHE_H__
 
 #ifndef __C2_CONF_IMPL
-#  error "conf/cache.h is not supposed to be #included"
+#  error "conf/cache.h is not supposed to be #included by confc API users"
 #endif
 
 #include "lib/mutex.h" /* c2_mutex */
@@ -33,20 +33,20 @@ struct c2_conf_obj;
 struct c2_conf_cache {
 	/** Serializes confc state machines. */
 	struct c2_sm_group *cc_sm_group;
-
 	/**
 	 * Protects this structure and the overall configuration cache
 	 * (the DAG of configuration objects) from concurrent writes.
 	 */
 	struct c2_mutex     cc_lock;
-
+	/** Key-to-address mapping. */
+	XXX_db cc_map;
 	/**
 	 * Root configuration object.
 	 *
 	 * NULL for uninitialized confc.
 	 *
 	 * NULL for confd (single root is not applicable to confd,
-	 * because confd cache may contain several profile objects).
+	 * which may have several profile objects in its cache).
 	 */
 	struct c2_conf_obj *cc_root;
 };
diff --git a/conf/confc.c b/conf/confc.c
index 71a75b5..f91b7f1 100644
--- a/conf/confc.c
+++ b/conf/confc.c
@@ -27,7 +27,7 @@
 #include "conf/cache.h"  /* c2_conf_cache */
 
 #include "xcode/xcode.h"
-#include "lib/cdefs.h"   /* C2_EXPORTED, container_of, C2_HAS_TYPE */
+#include "lib/cdefs.h"   /* C2_EXPORTED, container_of, C2_HAS_TYPE, equi */
 #include "lib/arith.h"   /* C2_CNT_INC, C2_CNT_DEC */
 #include "lib/time.h"    /* C2_TIME_NEVER */
 #include "lib/misc.h"    /* memcpy */
@@ -155,10 +155,10 @@
  * dynamically.  Configuration cache is destroyed by c2_confc_fini().
  *
  * Besides the DAG of configuration objects, confc maintains a
- * key-to-address @b mapping --- a hash table that maps keys of
- * objects to memory addresses of these objects.  When new
- * configuration data arrives from the confd, confc consults this hash
- * table prior to adding new objects to the cache.
+ * key-to-address @b mapping --- an in-memory database that maps keys
+ * of objects to memory addresses of these objects.  When new
+ * configuration data arrives from the confd, confc consults this
+ * mapping prior to adding new objects to the cache.
  *
  * Both configuration cache and key-to-address mapping are represented
  * by c2_conf_cache structure, defined in "conf/cache.h".  This
@@ -283,7 +283,8 @@ path_walk(struct c2_confc_ctx *ctx, enum c2_conf_status *status)
 			++comp;
 			C2_ASSERT(comp->pc_iskey);
 
-			/* XXX use the hash table instead of list_find() */
+			/* XXX use the key-to-address mapping instead
+			 * of list_find() */
 			child = list_find(XXX_dir, comp->pc_u.key);
 
 			target_is_directory = false;
@@ -331,9 +332,62 @@ end:
 	return ret;
 }
 
-static inline bool confc_is_initiated(void)
+static bool confc_is_initiated(void)
 {
-	return confc_cache.cc_sm_group != NULL && confc_cache.cc_root != NULL;
+	C2_PRE(equi(confc_cache.cc_root, confc_cache.cc_sm_group));
+	return confc_cache.cc_root != NULL;
+}
+
+int c2_confc_init(const char *profile, const char *confd_addr /*XXX*/,
+		  struct c2_sm_group *sm_group)
+{
+	/*
+	 * struct c2_conf_profile *root;
+	 *
+	 * C2_PRE(!confc_is_initiated());
+	 * C2_PRE(profile != NULL && *profile != 0);
+	 * C2_PRE(sm_group != NULL);
+	 *
+	 * confc_cache.cc_sm_group = sm_group;
+	 * c2_mutex_init(&confc_cache.cc_lock);
+	 *
+	 * map_init(&confc_cache.cc_map);
+	 *
+	 * root = allocate c2_conf_profile object;
+	 * copy `profile' to root->cp_obj.co_key;
+	 * map_add(&root->cp_obj);
+	 * confc_cache.cc_root = root;
+	 *
+	 * C2_POST(confc_is_initiated());
+	 */
+	XXX;
+	/* XXX TODO: Consume `confd_addr'. */
+}
+
+void c2_confc_fini(void)
+{
+	/*
+	 * C2_PRE(confc_is_initiated());
+	 *
+	 * c2_mutex_lock(group_lock());
+	 * c2_mutex_lock(cache_lock());
+	 *
+	 * for (obj in confc_cache.cc_map) {
+	 * 	C2_ASSERT(obj->co_nrefs == 0
+	 * 		&& obj->co_status != C2_CS_LOADING);
+	 * 	c2_free(obj);
+	 * }
+	 * map_fini(&confc_cache.cc_map);
+	 * confc_cache.cc_root = NULL;
+	 *
+	 * c2_mutex_unlock(cache_lock());
+	 * c2_mutex_fini(cache_lock());
+	 * c2_mutex_unlock(group_lock());
+	 * confc_cache.cc_sm_group = NULL;
+	 *
+	 * C2_POST(!confc_is_initiated());
+	 */
+	XXX;
 }
 
 int c2_confc_open(struct c2_confc_ctx *ctx, struct c2_conf_obj *path_origin,
@@ -585,7 +639,7 @@ static void grow_cache_st_in(struct c2_sm *mach)
 	 * for (fetched in resp->ffr_data) {
 	 *     C2_ASSERT(fetched->fo_key is not empty &&
 	 *               fetched->fo_val.v_type < C2_CO_NR);
-	 *     cached = htable_lookup(fetched->fo_key, fetched->fo_val.v_type);
+	 *     cached = map_lookup(fetched->fo_key, fetched->fo_val.v_type);
 	 *     if (cached == NULL)
 	 *         rc = cache_add(fetched);
 	 *     else
@@ -765,8 +819,18 @@ static bool ctx_invariant(struct c2_confc_ctx *ctx)
 /* ------------------------------------------------------------------
  * XXX Symbols to define.
  * ------------------------------------------------------------------ */
-static struct c2_confop_obj * htable_lookup(const struct c2_conf_buf *key,
-					    uint8_t type);
+map_init();
+map_fini();
+
+/**
+ * Adds new entry to the "key-to-address" mapping.
+ *
+ * @pre  The mapping does not contain given object.
+ */
+static int map_add(const struct c2_conf_obj *obj);
+
+static struct c2_confop_obj * map_lookup(const struct c2_conf_buf *key,
+					 uint8_t type);
 
 static int cache_add(const struct c2_confop_obj *obj);
 
@@ -778,3 +842,6 @@ struct object_ops {
 };
 
 struct object_ops confc_object_ops[C2_CO_NR];
+
+/** Duplicates a string into c2_conf_buf. */
+int c2_conf_buf_strdup(struct c2_conf_buf *dest, const char *src);
diff --git a/conf/confc.h b/conf/confc.h
index 78eec61..9f00609 100644
--- a/conf/confc.h
+++ b/conf/confc.h
@@ -302,7 +302,11 @@ struct c2_confc_dir;
  * @param sm_group    State machine group to be associated with confc
  *                    configuration cache.
  *
+ * @pre  confc cache is not initiated
  * @pre  sm_group != NULL
+ * @post confc cache is initiated
+ *
+ * @note Concurrent calls to c2_confc_init() may fail.
  */
 int c2_confc_init(const char *profile, const char *confd_addr,
 		  struct c2_sm_group *sm_group);
@@ -311,7 +315,16 @@ int c2_confc_init(const char *profile, const char *confd_addr,
  * Terminates configuration client. Destroys configuration cache,
  * freeing allocated memory.
  *
+ * @note Users of confc API must be careful not to call
+ *       c2_confc_fini() while there is a configuration retrieval
+ *       operation in progress.  I.e., don't call c2_confc_fini() if
+ *       there is a thread executing c2_confc_{,dir}open_sync() or an
+ *       c2_confc_ctx has been passed to c2_confc_{,dir}open() and its
+ *       ->fc_complete channel has not been signaled yet.
+ *
+ * @pre  confc cache is initiated
  * @pre  There are no opened (pinned) configuration objects.
+ * @pre  confc cache is not initiated
  */
 void c2_confc_fini(void);
 
@@ -390,7 +403,7 @@ void * c2_confc_open_sync(struct c2_conf_obj *path_origin,
 			  const struct c2_conf_pathcomp *path,
 			  size_t path_len);
 
-/* XXX{future}
+/* XXX[future]
  * If statistics shows that synchronous variant is used more often, we
  * may want to rename the functions: use c2_confc_open_async() for
  * non-blocking function and c2_confc_open() for synchronous one.
diff --git a/conf/obj.h b/conf/obj.h
index b6d0e1b..21e0915 100644
--- a/conf/obj.h
+++ b/conf/obj.h
@@ -84,6 +84,7 @@ struct c2_conf_obj {
 struct c2_conf_filesystem;
 
 struct c2_conf_profile {
+/* private: internal use only */
 	struct c2_conf_obj         cp_obj;
 	struct c2_conf_filesystem *cp_filesystem;
 };
@@ -93,6 +94,7 @@ struct c2_conf_filesystem {
 	struct c2_fid      cf_rootfid;
 	uint64_t           cf_params[C2_CFG_PARAM_LEN];
 
+/* private: internal use only */
 	/**
 	 * Services running in this filesystem.
 	 *
@@ -109,13 +111,12 @@ struct c2_conf_service {
 	struct c2_conf_filesystem *cs_filesystem;
 	enum c2_cfg_service_type   cs_type;
 	char cs_endpoints[C2_CFG_SERVICE_MAX_END_POINTS][C2_CFG_NAME_LEN];
+/* private: internal use only */
 	struct c2_conf_node       *cs_node;
-
 	/** Linkage to c2_conf_filesystem::cf_services. */
 	struct c2_tlink            cs_filesystem_linkage;
-
 	/** Magic for a list of services. */
-	uint64_t cs_magic;
+	uint64_t                   cs_magic;
 };
 
 /** Descriptor for a tlist of filesystem's services. */
@@ -129,6 +130,7 @@ struct c2_conf_node {
 	uint64_t           cn_last_state;
 	uint64_t           cn_flags;
 	uint64_t           cn_pool_id;
+/* private: internal use only */
 	struct c2_tl       cn_nics;
 	struct c2_tl       cn_sdevs;
 };
@@ -152,6 +154,7 @@ struct c2_conf_sdev {
 	uint64_t             sd_last_state;
 	uint64_t             sd_flags;
 	char                 sd_filename[C2_CFG_NAME_LEN];
+/* private: internal use only */
 	struct c2_tl         sd_partitions;
 };
 
diff --git a/conf/relation.c b/conf/relation.c
index 07d4eb8..36536ae 100644
--- a/conf/relation.c
+++ b/conf/relation.c
@@ -21,6 +21,7 @@
 #ifdef HAVE_CONFIG_H
 #  include <config.h>
 #endif
+#define __C2_CONF_IMPL
 #include "conf/relation.h"
 
 const struct c2_conf_relation dl_profile[] = {
diff --git a/conf/relation.h b/conf/relation.h
index 55019ec..840082a 100644
--- a/conf/relation.h
+++ b/conf/relation.h
@@ -20,6 +20,9 @@
 #ifndef __COLIBRI_CONF_RELATION_H__
 #define __COLIBRI_CONF_RELATION_H__
 
+#ifndef __C2_CONF_IMPL
+#  error "conf/relation.h is not supposed to be #included by confc API users"
+#endif
 #include "conf/obj.h" /* c2_conf_objtype */
 
 /**
diff --git a/conf/ut/confc.c b/conf/ut/confc.c
index 6f596f3..f14c6ee 100644
--- a/conf/ut/confc.c
+++ b/conf/ut/confc.c
@@ -22,7 +22,6 @@
 #  include <config.h>
 #endif
 #include "conf/confc.c"
-#include <string.h>     /* strlen, memcmp */
 
 static struct c2_sm_group g_grp;
 static struct c2_thread   g_ath;
@@ -59,33 +58,28 @@ static int fini(void)
 
 static void test_init_fini(void)
 {
-	int rc;
-	struct c2_conf_obj *obj;
-	const char prof[] = "test";
-
-	rc = c2_confc_init(prof, "XXX_endpoint", &g_grp);
-	C2_UT_ASSERT(rc == -1); /* already initiated */
+	int                      rc;
+	struct c2_conf_obj      *root;
+	struct c2_sm_group       group;
+	const char               prof[] = "test";
+	const struct c2_conf_buf prof_buf = C2_CONF_BUF_INIT(sizeof prof, prof);
 
+	C2_UT_ASSERT(confc_is_initialized());
 	c2_confc_fini();
-	C2_UT_ASSERT(confc_cache.cc_sm_group == NULL);
-	C2_UT_ASSERT(!c2_mutex_is_locked(&confc_cache.cc_lock));
-	C2_UT_ASSERT(confc_cache.cc_root == NULL);
+	C2_UT_ASSERT(!confc_is_initialized());
 
-	rc = c2_confc_init(prof, "XXX_endpoint", &g_grp);
+	rc = c2_confc_init(prof, "XXX_endpoint", &group);
 	C2_UT_ASSERT(rc == 0);
-	C2_UT_ASSERT(confc_cache.cc_sm_group == &g_grp);
+	C2_UT_ASSERT(confc_is_initialized());
+	C2_UT_ASSERT(confc_cache.cc_sm_group == &group);
 	C2_UT_ASSERT(!c2_mutex_is_locked(&confc_cache.cc_lock));
 	C2_UT_ASSERT(confc_cache.cc_root != NULL);
 
-	obj = confc_cache.cc_root;
-	C2_UT_ASSERT(obj->co_status == C2_CS_MISSING);
-	C2_UT_ASSERT(obj->co_type   == C2_CO_PROFILE);
-	{
-		const struct c2_conf_buf prof_buf =
-			C2_CONF_BUF_INIT(strlen(prof, prof);
-		C2_UT_ASSERT(c2_conf_buf_eq(obj->co_key, &prof_buf));
-		C2_UT_ASSERT(/* allocated */ obj->co_key.cb_data != prof);
-	}
+	root = confc_cache.cc_root;
+	C2_UT_ASSERT(root->co_type == C2_CO_PROFILE);
+	C2_UT_ASSERT(root->co_status == C2_CS_MISSING);
+	C2_UT_ASSERT(c2_conf_buf_eq(root->co_key, &prof_buf));
+	C2_UT_ASSERT(/* allocated */ root->co_key.cb_data != prof);
 }
 
 static void test_ctx(void)
diff --git a/conf/ut/relation.c b/conf/ut/relation.c
index a342472..6ca804f 100644
--- a/conf/ut/relation.c
+++ b/conf/ut/relation.c
@@ -21,6 +21,7 @@
 #ifdef HAVE_CONFIG_H
 #  include <config.h>
 #endif
+#define __C2_CONF_IMPL
 #include "conf/relation.h"
 #include "lib/cdefs.h"     /* offsetof */
 
-- 
1.8.3.2

