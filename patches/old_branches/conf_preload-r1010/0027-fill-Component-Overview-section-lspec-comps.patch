From 950303f962e89691dab9842e34457639600582a0 Mon Sep 17 00:00:00 2001
From: "Valery V. Vorotyntsev" <valery_vorotyntsev@xyratex.com>
Date: Wed, 29 Feb 2012 16:51:04 +0200
Subject: [PATCH 027/311] fill `Component Overview' section (lspec-comps)

+ c2_confc_ctx: remove empty lines between members.  It seems to be
  a common practice to keep amount of empty lines within struct
  to the minimum.
+ s/path_follow/path_walk/ --- it sounds better this... way.
+ Doxygen c2_confc_dirclose().
---
 conf/cache.h |  4 +++-
 conf/confc.c | 54 +++++++++++++++++++++++++++++++++++++++++++++++-------
 conf/confc.h | 16 +++++++++-------
 3 files changed, 59 insertions(+), 15 deletions(-)

diff --git a/conf/cache.h b/conf/cache.h
index 99e256d..b58c812 100644
--- a/conf/cache.h
+++ b/conf/cache.h
@@ -44,7 +44,9 @@ struct c2_conf_cache {
 	 * Root configuration object.
 	 *
 	 * NULL for uninitialized confc.
-	 * NULL for confd --- confd doesn't have a single root object.
+	 *
+	 * NULL for confd (single root is not applicable to confd,
+	 * because confd cache may contain several profile objects).
 	 */
 	struct c2_conf_obj *cc_root;
 };
diff --git a/conf/confc.c b/conf/confc.c
index 71c6674..71a75b5 100644
--- a/conf/confc.c
+++ b/conf/confc.c
@@ -41,6 +41,9 @@
  * - @ref confc-dld-depends
  * - @ref confc-dld-highlights
  * - @subpage confc-dld-fspec "Functional Specification"
+ * - @ref confc-dld-lspec
+ *   - @ref confc-dld-lspec-comps
+ *   - @ref confc-dld-lspec-state
  * - XXX
  *
  * <hr> <!------------------------------------------------------------->
@@ -62,7 +65,8 @@
  *   configuration database.
  *
  * - Configuration @b consumer: any software that uses confc
- *   interfaces to access C2 configuration.
+ *   interfaces to access C2 configuration.  Alternative name: @b
+ *   application.
  *
  * - Configuration @b cache: configuration data stored in nodeâ€™s
  *   memory. Confc library maintains such a cache and provides
@@ -74,10 +78,14 @@
  *   configuration information. There are several types of
  *   configuration objects: profile, service, node, etc.
  *
+ * - Configuration object is a @b stub if its status is not equal to
+ *   C2_CS_READY. Stubs contain no meaningful configuration data apart
+ *   from object's type and key.
+ *
  * New terms:
  *
  * - @b Directory: a list of configuration objects. This term is
- *   usually used in context of path.  Alternative name --- collection
+ *   usually used in context of path.  Alternative name: @b collection
  *   of configuration objects.
  *
  * - <b>Path target</b>: the object or directory that a path leads to.
@@ -128,6 +136,38 @@
  * - Configuration consumers should not use relations of a
  *   configuration object to access its neighbors: relations may point
  *   to unpinned objects that can be invalidated by confc.
+ *
+ * <hr> <!------------------------------------------------------------->
+ * @section confc-dld-lspec Logical Specification
+ *
+ * @subsection confc-dld-lspec-comps Component Overview
+ *
+ * Confc library maintains a @b cache of configuration information,
+ * organized as a directed acyclic graph (DAG) of configuration
+ * objects.  If the cache does not have enough data to fulfill a
+ * request of a configuration consumer, confc obtains the necessary
+ * data from the configuration server (confd), and adds new
+ * configuration data to the cache.
+ *
+ * Initially, i.e., right after c2_confc_init(), confc cache contains
+ * only one object --- a stub of the root configuration object
+ * (c2_conf_profile).  Cached configuration objects are allocated
+ * dynamically.  Configuration cache is destroyed by c2_confc_fini().
+ *
+ * Besides the DAG of configuration objects, confc maintains a
+ * key-to-address @b mapping --- a hash table that maps keys of
+ * objects to memory addresses of these objects.  When new
+ * configuration data arrives from the confd, confc consults this hash
+ * table prior to adding new objects to the cache.
+ *
+ * Both configuration cache and key-to-address mapping are represented
+ * by c2_conf_cache structure, defined in "conf/cache.h".  This
+ * structure is used by confc and confd implementations; configuration
+ * consumers does not need it.
+ *
+ * @subsection confc-dld-lspec-state State Specification
+ *
+ * XXX
  */
 
 static struct c2_conf_cache confc_cache;
@@ -188,28 +228,28 @@ request_fill(struct c2_confop_fetch *req, const struct c2_conf_obj *path_org,
  *                  object does not exist.
  */
 static int
-path_follow(struct c2_confc_ctx *ctx, enum c2_conf_status *status)
+path_walk(struct c2_confc_ctx *ctx, enum c2_conf_status *status)
 {
 	/*
 	 * XXX[remove this comment after DLDINSP]
 	 *
 	 * Refer to confc state diagram in the HLD.
 	 *
-	 * path_follow() follows ctx->fc_path and checks the statuses
+	 * path_walk() follows ctx->fc_path and checks the statuses
 	 * of met objects.  Upon success, the function sets *status to:
 	 *
 	 * - C2_CS_READY:   path target is reachable
 	 *
 	 * - C2_CS_MISSING: At least one of the intermediate objects
 	 *                  or the target itself is C2_CS_MISSING.
-	 *                  path_follow() changes statuses of such
+	 *                  path_walk() changes statuses of such
 	 *                  objects to C2_CS_LOADING and fills
 	 *                  ctx->fc_req.
 	 *
 	 * - C2_CS_LOADING: Neither path target nor missing objects
 	 *                  can be reached because of C2_CS_LOADING
 	 *                  object(s) blocking the path.
-	 *                  path_follow() registers ctx->fc_clink with
+	 *                  path_walk() registers ctx->fc_clink with
 	 *                  the channel(s) of loading object(s).
 	 */
 	struct c2_conf_obj *obj = ctx->fc_path.p_origin ?: confc_cache->cc_root;
@@ -500,7 +540,7 @@ static void check_st_in(struct c2_sm *mach)
 
 	C2_PRE(c2_mutex_is_locked(group_lock()));
 
-	rc = path_follow(to_ctx(mach), &status);
+	rc = path_walk(to_ctx(mach), &status);
 	if (rc != 0)
 		c2_sm_fail(mach, S_FAILURE, rc);
 	else if (status == C2_CS_MISSING)
diff --git a/conf/confc.h b/conf/confc.h
index a9cc820..78eec61 100644
--- a/conf/confc.h
+++ b/conf/confc.h
@@ -323,29 +323,26 @@ struct c2_confc_ctx {
 	/**
 	 * Pointer to the requested configuration object or directory.
 	 *
-	 * To be casted to
+	 * To be type-casted to
 	 * - <tt>struct X *</tt>, where X is a _concrete_ configuration
 	 *   object type (c2_conf_profile, c2_conf_filesystem, etc.),
 	 *   if the field is filled by c2_confc_open() call;
 	 * - <tt>struct c2_confc_dir *</tt> when filled by
 	 *   c2_confc_diropen().
 	 *
-	 * The value is NULL until fc_complete channel is signaled.
+	 * The value is NULL until ->fc_complete channel is signaled.
 	 * It is also NULL if configuration retrieval failed (see
 	 * c2_confc_error()).
 	 */
 	void                  *fc_result;
 
 /* private: internal use only */
-
 	/** A confc state machine. */
 	struct c2_sm           fc_mach;
-
 	struct c2_sm_ast       fc_ast;
 
 	/** Path to the requested object/directory. */
 	struct c2_conf_path    fc_path;
-
 	/**
 	 * Record of interest in "object unpinned" events.
 	 *
@@ -355,7 +352,6 @@ struct c2_confc_ctx {
 
 	/** Configuration request. */
 	struct c2_confop_fetch fc_req;
-
 	/** Request fop. */
 	struct c2_fop          fc_fop;
 };
@@ -394,7 +390,7 @@ void * c2_confc_open_sync(struct c2_conf_obj *path_origin,
 			  const struct c2_conf_pathcomp *path,
 			  size_t path_len);
 
-/* XXX[future]
+/* XXX{future}
  * If statistics shows that synchronous variant is used more often, we
  * may want to rename the functions: use c2_confc_open_async() for
  * non-blocking function and c2_confc_open() for synchronous one.
@@ -458,6 +454,12 @@ struct c2_confc_dir * c2_confc_diropen_sync(struct c2_conf_obj *path_origin,
  */
 const void * c2_confc_dirnext(struct c2_confc_dir *dir);
 
+/**
+ * Closes directory opened with c2_confc_diropen() or
+ * c2_confc_diropen_sync().
+ *
+ * @note  c2_confc_dirclose(NULL) is a noop.
+ */
 void c2_confc_dirclose(struct c2_confc_dir *dir);
 
 /** @} confc_dfspec */
-- 
1.8.3.2

