From 2d279b4266c959121fc2fcd8a50708f043005117 Mon Sep 17 00:00:00 2001
From: "Valery V. Vorotyntsev" <valery_vorotyntsev@xyratex.com>
Date: Wed, 25 Apr 2012 15:11:42 +0300
Subject: [PATCH 148/311] confc.c: relocate the descriptions of walk() and
 act()

RB: r/714
---
 conf/confc.c | 211 +++++++++++++++++++++++++++++++----------------------------
 1 file changed, 112 insertions(+), 99 deletions(-)

diff --git a/conf/confc.c b/conf/confc.c
index f075206..9b83175 100644
--- a/conf/confc.c
+++ b/conf/confc.c
@@ -175,16 +175,16 @@
  * @section confc-lspec-walk Walking the DAG
  *
  * path_walk() begins with locking the cache (c2_confc::cc_lock) and
- * unlocks the cache before returning.  The function does two things
+ * unlocks the cache before returning.  The function does two things,
  * represented by subroutines:
  *   -#
  *      walk() "moves" along the DAG of cached configuration
  *      objects. It starts at the configuration object the path
  *      originates from and follows the directions specified by path
  *      components.  walk() stops when all of the path components are
- *      consumed or when a stub is reached.  It returns the "overall"
- *      status of the objects belonging the path (see below) or
- *      negative error code.
+ *      consumed or when a stub is reached.  It returns the "resultant
+ *      status" of the objects belonging the path or negative error
+ *      code.
  *   -#
  *      act() applies the results of path walking. The arguments are
  *      c2_confc_ctx, path position reached by walk(), and status
@@ -196,69 +196,6 @@
  *       are treated as failures.  path_walk() C2_ASSERT()s that the
  *       value of status returned by walk() is C2_CS_READY.
  *
- * - walk()
- *
- *   - Stub ahead
- *
- *     A stub object lying on a path makes further progress
- *     impossible, because relations of a stub are not trustworthy.
- *     walk() returns c2_conf_obj::co_status of the stub object.
- *
- *   - Wrong key
- *
- *     If one of path components is a key and there is no object with
- *     such key in current directory, then walk() returns -ENOENT.
- *
- *   - Target is a directory
- *
- *     It is assumed that the parent object of this directory is
- *     reachable (its path predecessors are C2_CS_READY) and is
- *     C2_CS_READY. If this is not the case, see `Stub ahead' stanza.
- *
- *     walk() scans the directory, checking statuses of its objects.
- *     If all of the objects are C2_CS_READY, walk() returns
- *     C2_CS_READY.  If some of the objects are C2_CS_MISSING, walk()
- *     changes their statuses to C2_CS_LOADING and returns
- *     C2_CS_MISSING.  Otherwise walk() calculates the number of
- *     C2_CS_LOADING objects, asserts that this number is > 0, and
- *     returns C2_CS_LOADING.
- *
- *   - Target is an object
- *
- *     walk() returns ->co_status of the reached target object.
- *
- * - act()
- *
- *   - C2_CS_READY
- *
- *     act() assigns c2_confc_ctx::fc_result.  It also increments
- *     reference counter (c2_conf_obj::co_nrefs) of the requested
- *     configuration object or, in case of directory, of the object
- *     the directory originates from.
- *
- *   - C2_CS_MISSING
- *
- *     act() fills configuration fetch request (c2_conf_fetch) and
- *     sets status of current object, i.e. the object reached by
- *     walk(), to C2_CS_LOADING.
- *
- *   - C2_CS_LOADING object
- *
- *     act() registers c2_confc_ctx::fc_clink with object's channel
- *     (c2_conf_obj::co_chan).
- *
- *   - Directory with C2_CS_LOADING objects
- *
- *     Let 1 + N be the number of C2_CS_LOADING objects in this
- *     directory.  If N > 0, then act() allocates array of N clinks,
- *     sets ->fc_extra and ->fc_nr_extra members of c2_confc_ctx,
- *     attaches (c2_clink_attach()) ->fc_extra clinks to ->fc_clink,
- *     and registers a group of clinks with object's channels;
- *     ->fc_clink is a "group head".  See `Multiple channels' in @ref
- *     chan.
- *
- *     If N = 0, then only ->fc_clink is registered (c2_clink_add()).
- *
  * <hr> <!------------------------------------------------------------>
  * @section confc-lspec-grow Growing the cache
  *
@@ -362,6 +299,38 @@ static inline struct c2_confc * registry_to_client(struct c2_conf_map *cache)
 	return container_of(cache, struct c2_confc, cc_registry);
 }
 
+/** Allocates `n' clinks and attaches them to ctx->fc_clink (group head). */
+static struct c2_clink *
+extra_clinks_create(struct c2_confc_ctx *ctx, uint32_t n)
+{
+	struct c2_clink *clinks;
+	uint32_t         i;
+	C2_PRE(n > 0);
+
+	C2_ALLOC_ARR(clinks, n);
+	if (clinks != NULL) {
+		for (i = 0; i < n; ++i)
+			c2_clink_attach(clinks + i, &ctx->fc_clink,
+					on_object_updated);
+	}
+	return clinks;
+}
+
+/** Frees resources allocated for ctx->fc_extra array. */
+static void extra_clinks_destroy(struct c2_confc_ctx *ctx)
+{
+	uint32_t i;
+	C2_PRE(ctx_invariant(ctx));
+
+	if (ctx->fc_extra != NULL) {
+		for (i = 0; i < ctx->fc_nr_extra; ++i)
+			c2_clink_fini(ctx->fc_extra + i);
+		c2_free(ctx->fc_extra);
+		ctx->fc_extra = NULL;
+		ctx->fc_nr_extra = 0;
+	}
+}
+
 /** Path walk context. */
 struct walk_ctx {
 	/** Current object. */
@@ -381,6 +350,43 @@ static bool walk_ctx_invariant(const struct walk_ctx *wx)
 		     c2_conf_pathcomp_is_last(wx->w_path));
 }
 
+/**
+ * Determines the "resultant status" of the objects located along the path.
+ *
+ * walk() moves along the DAG of cached configuration objects,
+ * starting at wx->w_obj and following wx->w_path. It stops when all
+ * path components are consumed or when a stub is reached.
+ *
+ * Traversing a path leads to one of the following cases:
+ *
+ * <b>1. Stub ahead</b>
+ *
+ * A stub object lying on a path makes further progress impossible,
+ * since relations of a stub are not trustworthy.  walk() returns
+ * c2_conf_obj::co_status of this stub object.
+ *
+ * <b>2. Wrong key</b>
+ *
+ * One of path components is a key and there is no object with such
+ * key in current directory.  walk() returns -ENOENT.
+ *
+ * <b>3. Target is a directory</b>
+ *
+ * It is assumed that the parent object of this directory is reachable
+ * (i.e., its path predecessors are C2_CS_READY) and is C2_CS_READY.
+ * Otherwise it would be `Stub ahead' case.
+ *
+ * walk() scans the directory, checking statuses of its objects.
+ * If all of the objects are C2_CS_READY, walk() returns C2_CS_READY.
+ * If some of the objects are C2_CS_MISSING, walk() changes their
+ * statuses to C2_CS_LOADING and returns C2_CS_MISSING.  Otherwise
+ * walk() calculates the number of C2_CS_LOADING objects, asserts that
+ * this number is > 0, and returns C2_CS_LOADING.
+ *
+ * <b>4. Target is an object</b>
+ *
+ * walk() returns ->co_status of the reached target object.
+ */
 static int walk(struct walk_ctx *wx)
 {
 	const struct c2_conf_relation *relation;
@@ -426,38 +432,45 @@ static int walk(struct walk_ctx *wx)
 	return ret;
 }
 
-/** Allocates `n' clinks and attaches them to ctx->fc_clink (group head). */
-static struct c2_clink *
-extra_clinks_create(struct c2_confc_ctx *ctx, uint32_t n)
-{
-	struct c2_clink *clinks;
-	uint32_t         i;
-	C2_PRE(n > 0);
-
-	C2_ALLOC_ARR(clinks, n);
-	if (clinks != NULL) {
-		for (i = 0; i < n; ++i)
-			c2_clink_attach(clinks + i, &ctx->fc_clink,
-					on_object_updated);
-	}
-	return clinks;
-}
-
-/** Frees resources allocated for ctx->fc_extra array. */
-static void extra_clinks_destroy(struct c2_confc_ctx *ctx)
-{
-	uint32_t i;
-	C2_PRE(ctx_invariant(ctx));
-
-	if (ctx->fc_extra != NULL) {
-		for (i = 0; i < ctx->fc_nr_extra; ++i)
-			c2_clink_fini(ctx->fc_extra + i);
-		c2_free(ctx->fc_extra);
-		ctx->fc_extra = NULL;
-		ctx->fc_nr_extra = 0;
-	}
-}
-
+/**
+ * Applies the results of walk().
+ *
+ * The operation depends on the value of `status' and on whether it is
+ * an object or a directory reached by walk():
+ *
+ * <b>1. C2_CS_READY</b>
+ *
+ * act() assigns c2_confc_ctx::fc_result.  It also increments
+ * reference counter (c2_conf_obj::co_nrefs) of the requested
+ * configuration object or, in case of directory, of the object this
+ * directory originates from.
+ *
+ * <b>2. C2_CS_MISSING</b>
+ *
+ * act() fills configuration fetch request (c2_confc_ctx::fc_req) and
+ * sets status of the object reached by walk() to C2_CS_LOADING. If a
+ * directory is reached, act() C2_ASSERT()s that there are no
+ * C2_CS_MISSING objects in this directory and that the number of
+ * C2_CS_LOADING objects is > 0.
+ *
+ * <b>3. Single C2_CS_LOADING object</b>
+ *
+ * act() registers c2_confc_ctx::fc_clink with the channel of reached
+ * object (c2_conf_obj::co_chan).
+ *
+ * <b>4. Directory with C2_CS_LOADING objects</b>
+ *
+ * Let 1 + N be the number of C2_CS_LOADING objects in this directory:
+ * N = wx->w_nload - 1.
+ *
+ * If N > 0, then act() allocates an array of N clinks, sets
+ * ->fc_extra and ->fc_nr_extra members of c2_confc_ctx, attaches
+ * (c2_clink_attach()) ->fc_extra clinks to ->fc_clink, and registers
+ * a group of clinks with object's channels. ->fc_clink is a "group
+ * head" (see `Multiple channels' in @ref chan).
+ *
+ * If N = 0, then only ->fc_clink is registered (c2_clink_add()).
+ */
 static int act(struct c2_confc_ctx *cx, const struct walk_ctx *wx,
 	       enum c2_conf_status status)
 {
-- 
1.8.3.2

