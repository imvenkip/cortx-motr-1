From 75eb822a0a503f3f2f3d1f1719eaa32f5faf6603 Mon Sep 17 00:00:00 2001
From: "Valery V. Vorotyntsev" <valery_vorotyntsev@xyratex.com>
Date: Wed, 14 Mar 2012 18:44:59 +0200
Subject: [PATCH 059/311] pseudo-code blocks: replace tabs with spaces

This replaces "lots of nasty looking" tabs, that are painted red
by ReviewBoard, with spaces.

Reviewed-on: http://reviewboard.clusterstor.com/r/714/
Reported-by: Carl Braganza <carl_braganza@xyratex.com>
References:  LogD-1.3 # 765
---
 conf/confc.h | 214 +++++++++++++++++++++++++++++------------------------------
 conf/rpc.c   |   4 +-
 2 files changed, 109 insertions(+), 109 deletions(-)

diff --git a/conf/confc.h b/conf/confc.h
index 3ad3a02..3b073e9 100644
--- a/conf/confc.h
+++ b/conf/confc.h
@@ -151,38 +151,38 @@
  *
  * static struct c2_conf_filesystem * filesystem_open_a(int32_t *errno)
  * {
- * 	struct c2_confc_ctx        ctx;
- * 	struct c2_clink            clink;
- * 	struct c2_conf_pathcomp    path[] =
- * 		{ C2_CONF_PATHCOMP_R(C2_CO_FILESYSTEM) };
- * 	struct c2_conf_filesystem *ret = NULL;
- * 	int                        rc;
- *
- * 	c2_confc_ctx_init(&ctx);
- * 	c2_clink_init(&clink, NULL)
- * 	c2_clink_add(&ctx.fc_complete, &clink);
- *
- * 	rc = c2_confc_open(&ctx, NULL, path, ARRAY_SIZE(path));
- * 	if (rc == 0) {
- * 		c2_chan_wait(&clink);
- * 		ret = ctx.fc_result;
- * 		if (ret == NULL && errno != NULL)
- * 			*errno = c2_confc_error(ctx);
- * 	} else if (errno != NULL) {
- * 		*errno = -rc;
- * 	}
- *
- * 	c2_clink_del(&clink);
- * 	c2_clink_fini(&clink);
- * 	c2_confc_ctx_fini(&ctx);
- * 	return ret;
+ *     struct c2_confc_ctx        ctx;
+ *     struct c2_clink            clink;
+ *     struct c2_conf_pathcomp    path[] =
+ *         { C2_CONF_PATHCOMP_R(C2_CO_FILESYSTEM) };
+ *     struct c2_conf_filesystem *ret = NULL;
+ *     int                        rc;
+ *
+ *     c2_confc_ctx_init(&ctx);
+ *     c2_clink_init(&clink, NULL)
+ *     c2_clink_add(&ctx.fc_complete, &clink);
+ *
+ *     rc = c2_confc_open(&ctx, NULL, path, ARRAY_SIZE(path));
+ *     if (rc == 0) {
+ *         c2_chan_wait(&clink);
+ *         ret = ctx.fc_result;
+ *         if (ret == NULL && errno != NULL)
+ *             *errno = c2_confc_error(ctx);
+ *     } else if (errno != NULL) {
+ *         *errno = -rc;
+ *     }
+ *
+ *     c2_clink_del(&clink);
+ *     c2_clink_fini(&clink);
+ *     c2_confc_ctx_fini(&ctx);
+ *     return ret;
  * }
  *
  * static struct c2_conf_filesystem * filesystem_open_s(void)
  * {
- * 	struct c2_conf_pathcomp path[] =
- * 		{ C2_CONF_PATHCOMP_R(C2_CO_FILESYSTEM) };
- * 	return c2_confc_open_sync(NULL, path, ARRAY_SIZE(path));
+ *     struct c2_conf_pathcomp path[] =
+ *         { C2_CONF_PATHCOMP_R(C2_CO_FILESYSTEM) };
+ *     return c2_confc_open_sync(NULL, path, ARRAY_SIZE(path));
  * }
  * @endcode
  *
@@ -194,25 +194,25 @@
  *
  * static int service_by_type(enum c2_cfg_service_type tos)
  * {
- * 	struct c2_confc_dir    *d;
- * 	struct c2_conf_service *svc;
- * 	struct c2_conf_pathcomp path[] = {
- * 		C2_CONF_PATHCOMP_R(C2_CO_FILESYSTEM),
- * 		C2_CONF_PATHCOMP_R(C2_CO_SERVICE)
- * 	};
- *
- * 	d = c2_confc_diropen_sync(NULL, path, ARRAY_SIZE(path));
- * 	if (d == NULL)
- * 		return -1;
- *
- * 	while ((svc = c2_confc_dirnext(d)) != NULL) {
- * 		if (svc->cs_type == tos) {
- * 			// ... Use `svc' ...
- * 		}
- * 	}
- *
- * 	c2_confc_dirclose(d);
- * 	return 0;
+ *     struct c2_confc_dir    *d;
+ *     struct c2_conf_service *svc;
+ *     struct c2_conf_pathcomp path[] = {
+ *         C2_CONF_PATHCOMP_R(C2_CO_FILESYSTEM),
+ *         C2_CONF_PATHCOMP_R(C2_CO_SERVICE)
+ *     };
+ *
+ *     d = c2_confc_diropen_sync(NULL, path, ARRAY_SIZE(path));
+ *     if (d == NULL)
+ *         return -1;
+ *
+ *     while ((svc = c2_confc_dirnext(d)) != NULL) {
+ *         if (svc->cs_type == tos) {
+ *             // ... Use `svc' ...
+ *         }
+ *     }
+ *
+ *     c2_confc_dirclose(d);
+ *     return 0;
  * }
  * @endcode
  *
@@ -223,68 +223,68 @@
  * #include "conf/obj.h" // c2_conf_service, c2_conf_node
  *
  * static int node_devices(enum c2_cfg_service_type svc_type,
- * 			const struct c2_conf_buf *node_key)
+ *                         const struct c2_conf_buf *node_key)
  * {
- * 	struct c2_confc_dir    *services;
- * 	struct c2_confc_dir    *d;
- * 	struct c2_conf_service *svc;
- * 	struct c2_conf_node    *node;
- * 	struct c2_conf_nic     *nic;
- * 	struct c2_conf_sdev    *sdev;
- * 	struct c2_conf_pathcomp path[] = {
- * 		C2_CONF_PATHCOMP_R(C2_CO_FILESYSTEM),
- * 		C2_CONF_PATHCOMP_R(C2_CO_SERVICE)
- * 	};
- * 	int ret = -1;
- *
- * 	// /fs/services
- * 	services = c2_confc_diropen_sync(NULL, path, ARRAY_SIZE(path));
- * 	if (services == NULL)
- * 		return -1;
- *
- * 	while ((svc = c2_confc_dirnext(services)) != NULL) {
- * 		if (svc->cs_type != svc_type)
- * 			continue;
- *
- * 		path->pc_u.relation = C2_CO_NODE;
- * 		node = c2_confc_open_sync(svc, path, 1); // svc/node
- * 		if (node == NULL)
- * 			goto end;
- *
- * 		if (!c2_conf_buf_eq(node->cn_obj.co_key, node_key)) {
- * 			c2_confc_close(node);
- * 			continue;
- * 		}
- *
- * 		path->pc_u.relation = C2_CO_NIC;
- * 		d = c2_confc_diropen_sync(node, path, 1); // node/nics
- * 		if (d == NULL) {
- * 			c2_confc_close(node);
- * 			goto end;
- * 		}
- * 		while ((nic = c2_confc_dirnext(d)) != NULL) {
- * 			// ... Use `nic' ...
- * 		}
- * 		c2_confc_dirclose(d);
- *
- * 		path->pc_u.relation = C2_CO_SDEV;
- * 		d = c2_confc_diropen_sync(node, path, 1); // node/sdevs
- * 		if (d == NULL) {
- * 			c2_confc_close(node);
- * 			goto end;
- * 		}
- * 		while ((sdev = c2_confc_dirnext(d)) != NULL) {
- * 			// ... Use `sdev' ...
- * 		}
- * 		c2_confc_dirclose(d);
- *
- * 		c2_confc_close(node);
- * 	}
- *
- * 	ret = 0;
+ *     struct c2_confc_dir    *services;
+ *     struct c2_confc_dir    *d;
+ *     struct c2_conf_service *svc;
+ *     struct c2_conf_node    *node;
+ *     struct c2_conf_nic     *nic;
+ *     struct c2_conf_sdev    *sdev;
+ *     struct c2_conf_pathcomp path[] = {
+ *         C2_CONF_PATHCOMP_R(C2_CO_FILESYSTEM),
+ *         C2_CONF_PATHCOMP_R(C2_CO_SERVICE)
+ *     };
+ *     int ret = -1;
+ *
+ *     // /fs/services
+ *     services = c2_confc_diropen_sync(NULL, path, ARRAY_SIZE(path));
+ *     if (services == NULL)
+ *         return -1;
+ *
+ *     while ((svc = c2_confc_dirnext(services)) != NULL) {
+ *         if (svc->cs_type != svc_type)
+ *             continue;
+ *
+ *         path->pc_u.relation = C2_CO_NODE;
+ *         node = c2_confc_open_sync(svc, path, 1); // svc/node
+ *         if (node == NULL)
+ *             goto end;
+ *
+ *         if (!c2_conf_buf_eq(node->cn_obj.co_key, node_key)) {
+ *             c2_confc_close(node);
+ *             continue;
+ *         }
+ *
+ *         path->pc_u.relation = C2_CO_NIC;
+ *         d = c2_confc_diropen_sync(node, path, 1); // node/nics
+ *         if (d == NULL) {
+ *             c2_confc_close(node);
+ *             goto end;
+ *         }
+ *         while ((nic = c2_confc_dirnext(d)) != NULL) {
+ *             // ... Use `nic' ...
+ *         }
+ *         c2_confc_dirclose(d);
+ *
+ *         path->pc_u.relation = C2_CO_SDEV;
+ *         d = c2_confc_diropen_sync(node, path, 1); // node/sdevs
+ *         if (d == NULL) {
+ *             c2_confc_close(node);
+ *             goto end;
+ *         }
+ *         while ((sdev = c2_confc_dirnext(d)) != NULL) {
+ *             // ... Use `sdev' ...
+ *         }
+ *         c2_confc_dirclose(d);
+ *
+ *         c2_confc_close(node);
+ *     }
+ *
+ *     ret = 0;
  * end:
- * 	c2_confc_dirclose(services);
- * 	return ret;
+ *     c2_confc_dirclose(services);
+ *     return ret;
  * }
  * @endcode
  *
diff --git a/conf/rpc.c b/conf/rpc.c
index d8f692f..962d8dd 100644
--- a/conf/rpc.c
+++ b/conf/rpc.c
@@ -77,8 +77,8 @@ request_encode(struct c2_rpc_item_type *item_type __attribute__((unused)),
 	/*
 	 * struct c2_xcode_ctx xtx;
 	 * struct c2_xcode_obj xobj = {
-	 * 	.xo_type = c2_conf_fetch_xc,
-	 * 	.xo_ptr  = c2_fop_data(c2_rpc_item_to_fop(item))
+	 *     .xo_type = c2_conf_fetch_xc,
+	 *     .xo_ptr  = c2_fop_data(c2_rpc_item_to_fop(item))
 	 * };
 	 *
 	 * C2_PRE(item->ri_type == &fetch_itype);
-- 
1.8.3.2

