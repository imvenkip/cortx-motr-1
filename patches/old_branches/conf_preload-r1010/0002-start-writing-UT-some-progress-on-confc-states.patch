From 3578aac00e672cc6113ef6af99a4ad941740c6b4 Mon Sep 17 00:00:00 2001
From: "Valery V. Vorotyntsev" <valery_vorotyntsev@xyratex.com>
Date: Wed, 8 Feb 2012 19:46:35 +0200
Subject: [PATCH 002/311] start writing UT; some progress on confc states

+ cache_path_check() algorithm has been completed.
+ c2_confc_open().
+ Unit tests: downlinks, c2_conf_bytes, c2_confc_fetchctx, c2_confc_open().
---
 conf/conf.c        |   8 +++
 conf/conf.h        |  18 +++++--
 conf/confc.c       |  98 ++++++++++++++++++++++--------------
 conf/confc.h       |  12 +++--
 conf/path.h        |  14 ++++--
 conf/relation.c    |  30 +++++------
 conf/ut/conf.c     |  24 +++++++--
 conf/ut/confc.c    | 142 +++++++++++++++++++++++++++++++++++++++++++++++++++++
 conf/ut/path.c     |  37 ++++++++++++++
 conf/ut/relation.c |  87 ++++++++++++++++++++++++++++++++
 10 files changed, 398 insertions(+), 72 deletions(-)
 create mode 100644 conf/ut/confc.c
 create mode 100644 conf/ut/path.c
 create mode 100644 conf/ut/relation.c

diff --git a/conf/conf.c b/conf/conf.c
index c74f490..2fee72f 100644
--- a/conf/conf.c
+++ b/conf/conf.c
@@ -22,6 +22,7 @@
 #  include <config.h>
 #endif
 #include "conf/conf.h"
+#include <string.h> /* memcmp */
 
 enum {
 	CONF_FSSVC_HEAD_MAGIC   = 0x66732f7376632020, /* "fs/svc  " */
@@ -33,3 +34,10 @@ C2_TL_DESCR_DEFINE(c2_conf_filesystem_services,
 		   "c2_conf_filesystem::cf_services", ,
 		   struct c2_conf_service, cs_filesystem_linkage, cs_magic,
 		   CONF_SERVICE_LINK_MAGIC, CONF_FSSVC_HEAD_MAGIC);
+
+bool c2_conf_bytes_eq(const struct c2_conf_bytes *s1,
+		      const struct c2_conf_bytes *s2)
+{
+	return s1->cb_len == s2->cb_len
+		&& memcmp(s1->cb_data, s2->cb_data, s1->cb_len) == 0;
+}
diff --git a/conf/conf.h b/conf/conf.h
index 4935578..bbb5a3a 100644
--- a/conf/conf.h
+++ b/conf/conf.h
@@ -52,6 +52,10 @@ struct c2_conf_bytes {
 	uint8_t *cb_data;
 };
 
+/** Returns true iff two byte sequences are equal. */
+bool c2_conf_bytes_eq(const struct c2_conf_bytes *s1,
+		      const struct c2_conf_bytes *s2);
+
 /** Status of configuration object. */
 enum c2_conf_status {
 	C2_CS_MISSING, /*< Configuration is absent; no retrieval in progress. */
@@ -88,17 +92,21 @@ struct c2_conf_profile {
 
 /** Configuration cache. */
 struct c2_conf_cache {
-	/** Root configuration object. */
-	struct c2_conf_profile cc_root;
-
 	/** Serializes confc state machines. */
-	struct c2_sm_group    *cc_sm_group;
+	struct c2_sm_group     *cc_sm_group;
 
 	/**
 	 * Protects this structure and the DAG of configuration
 	 * objects from concurrent writes.
 	 */
-	struct c2_mutex        cc_lock;
+	struct c2_mutex         cc_lock;
+
+	/**
+	 * Root configuration object of a confc cache.
+	 *
+	 * NULL for uninitialized confc. Always NULL for confd.
+	 */
+	struct c2_conf_profile *cc_root;
 };
 
 struct c2_conf_filesystem {
diff --git a/conf/confc.c b/conf/confc.c
index 9f630ea..d830b71 100644
--- a/conf/confc.c
+++ b/conf/confc.c
@@ -23,28 +23,28 @@
 #endif
 #include "conf/confc.h"
 
-static struct c2_conf_cache cache; /*< Confc's configuration cache. */
+static struct c2_conf_cache confc_cache; /*< Confc's configuration cache. */
 
-enum { S_INITIAL, S_CHECK, S_WAIT_REPLY, S_WAIT_STATUS, S_GROW_CACHE,
-       S_FAILURE, S_TERMINAL, S_NR };
+enum confc_state { S_INITIAL, S_CHECK, S_WAIT_REPLY, S_WAIT_STATUS,
+		   S_GROW_CACHE, S_FAILURE, S_TERMINAL, S_NR };
 
 /**
  * @pre   c2_conf_path_invariant(path)
- * @post  ergo(retval == 0, *result is valid status)
  *
- * @retval -ENOENT  `path' contains nonexistent key.
+ * @retval -ENOENT  `path' contains a key and the corresponding object
+ *                  does not exist.
  */
 int cache_path_check(struct c2_conf_cache *cache,
 		     const struct c2_conf_path *path,
 		     enum c2_conf_status *result)
 {
-	struct c2_conf_obj *parent = path->p_origin ?: &cache->cc_root.cp_obj;
+	struct c2_conf_obj *obj = path->p_origin ?: &cache->cc_root->cp_obj;
 	struct c2_conf_pathcomp *comp = path->p_comps;
 	size_t nr = path->p_nr_comps; /* remaining number of components */
 	bool target_is_directory = false;
 
 	C2_ASSERT(c2_conf_path_invariant(path));
-	*result = parent->co_status;
+	*result = obj->co_status;
 
 	for (; nr > 0; --nr, ++comp) {
 		const struct c2_conf_relation *rel;
@@ -57,7 +57,7 @@ int cache_path_check(struct c2_conf_cache *cache,
 
 		if (target_is_directory) {
 			if (nr == 1) { /* the last path component */
-				/* XXX directory_scan():
+				/* XXX list_scan():
 				 * - if all of the objects are LOADING ---
 				 *   return LOADING;
 				 * - if MISSING objects are found ---
@@ -66,48 +66,46 @@ int cache_path_check(struct c2_conf_cache *cache,
 				 * - otherwise all objects are READY ---
 				 *   return READY.
 				 */
-				*result = directory_scan(XXX);
+				*result = list_scan(XXX);
 				break;
 			}
 
 			--nr;
 			++comp;
 			C2_ASSERT(comp->pc_iskey);
-
-			child = XXX_find(XXX_dir, comp->pc_u.key);
-			if (child == NULL) /* no such key */
-				return -ENOENT;
-
+			/* XXX list_find() */
+			child = list_find(XXX_dir, comp->pc_u.key);
+			target_is_directory = false;
 		} else {
-			obj = *(struct c2_conf_obj **)((void *)obj + rel->r_offset);
-			C2_ASSERT(obj->co_type == rel->r_type);
-			XXX; /* check obj->co_status */
-			XXX;
+			/* child = *(struct c2_conf_obj **)((void *)obj */
+			/* 				 + rel->r_offset); */
+			child = XXX_relation_target(obj, rel);
 		}
-	}
 
-	/* C2_ASSERT(parent->co_status == C2_CS_READY); */
-	/* /\* XXX */
-	/*  * ++parent->co_nrefs; */
-	/*  * fetchctx->fc_result = parent */
-	/*  *\/ */
-	/* *result = C2_CS_READY; */
+		if (child == NULL) /* no such key */
+			return -ENOENT;
+
+		obj = child;
+		*result = obj->co_status;
+		if (*result != C2_CS_READY)
+			break;
+	}
 
 	if (*result == C2_CS_READY) {
-		++parent->co_nrefs;
+		++obj->co_nrefs;
 		if (target_is_directory) {
 			/* XXX fetchctx->fc_result = dir_allocate() */
 		} else {
-			/* XXX fetchctx->fc_result = parent */
+			/* XXX fetchctx->fc_result = obj */
 		}
 	} else if (*result == C2_CS_MISSING) {
 		if (!target_is_directory) {
-			C2_ASSERT(parent->co_status == C2_CS_MISSING);
-			parent->co_status = C2_CS_LOADING;
+			C2_ASSERT(obj->co_status == C2_CS_MISSING);
+			obj->co_status = C2_CS_LOADING;
 		}
 
 		/* XXX
-		 * fop->path = { .p_origin   = parent,
+		 * fop->path = { .p_origin   = obj,
 		 *               .p_nr_comps = nr,
 		 *               .p_comps    = comp }
 		 */
@@ -115,7 +113,7 @@ int cache_path_check(struct c2_conf_cache *cache,
 		if (target_is_directory) {
 			/* XXX scan directory, adding clinks */
 		} else {
-			/* XXX clink_add(&parent->co_chan) */
+			/* XXX clink_add(&obj->co_chan) */
 		}
 	} else {
 		C2_IMPOSSIBLE("XXX");
@@ -124,6 +122,19 @@ int cache_path_check(struct c2_conf_cache *cache,
 	return 0;
 }
 
+static void check_cb(struct c2_sm *mach)
+{
+	int rc;
+	enum c2_conf_status result;
+	struct c2_confc_fetchctx *ctx =
+		container_of(mach, struct c2_confc_fetchctx, fc_mach);
+
+	rc = cache_path_check(ctx->path, &result);
+	if (rc != 0)
+		XXX;
+	XXX;
+}
+
 /**
  * Confc states.
  *
@@ -173,15 +184,28 @@ struct c2_sm_conf confc_states_conf = {
 	.scf_state     = confc_states
 };
 
+static void state_set(struct c2_sm_group *grp __attribute__((unused)),
+		      struct c2_sm_ast *ast)
+{
+	struct c2_confc_fetchctx *ctx =
+		container_of(ast, struct c2_conf_fetchctx, fc__ast);
+	c2_sm_state_set(&ctx->fc_mach, (enum confc_state)ast->sa_datum);
+}
+
 int c2_confc_open(const struct c2_conf_path *path,
 		  struct c2_confc_fetchctx *ctx)
 {
-/*
- * - Check the precondition.
- * - Set the path (fc__path).
- * - c2_sm_group_lock(cache.cc_sm_group);
- * - c2_sm_state_set(&ctx->fc_mach, S_CHECK);
- */
+	C2_PRE(XXX_is_just_initiated(ctx));
+	C2_PRE(c2_conf_path_invariant(path));
+
+	if (c2_conf_path_is_dir(path))
+		return -EISDIR;
+
+	ctx->fc__path = path;
+	ctx->fc__ast.sa_cb    = state_set;
+	ctx->fc__ast.sa_datum = S_CHECK;
+	c2_sm_ast_post(confc_cache.cc_sm_group, &ctx->fc__ast);
+	return 0;
 }
 C2_EXPORTED(c2_confc_open);
 
diff --git a/conf/confc.h b/conf/confc.h
index 3505277..45a55bf 100644
--- a/conf/confc.h
+++ b/conf/confc.h
@@ -22,6 +22,9 @@
 
 #include "sm/sm.h" /* c2_sm, c2_sm_ast */
 
+struct c2_conf_path;
+struct c2_confc_dir;
+
 /**
  * Initiates configuration client.
  *
@@ -41,8 +44,6 @@ int c2_confc_init(const char *profile, const char *confd_addr,
  */
 void c2_confc_fini(void);
 
-struct c2_conf_path;
-
 struct c2_confc_fetchctx {
 	struct c2_sm fc_mach;
 	void        *fc_result;
@@ -63,7 +64,10 @@ struct c2_confc_fetchctx {
  * ctx->fc_mach terminates or fails.
  *
  * @pre  ctx is initiated: its state machine is in INITIAL state,
- *       results are unset, and the path is NULL.
+ *       fc_result == NULL, fc_errno == 0, fc__path == NULL.
+ * @pre  c2_conf_path_invariant(path)
+ *
+ * @retval -EISDIR  Path leads to a directory.
  */
 int c2_confc_open(const struct c2_conf_path *path,
 		  struct c2_confc_fetchctx *ctx);
@@ -85,8 +89,6 @@ void c2_confc_close(void *obj);
 int c2_confc_diropen(const struct c2_conf_path *path,
 		     struct c2_confc_fetchctx *ctx);
 
-struct c2_confc_dir;
-
 /*
  * Synchronous variant of c2_confc_diropen(). Returns a pointer to the
  * requested collection (directory) of configuration objects or NULL
diff --git a/conf/path.h b/conf/path.h
index 633115c..ad94e86 100644
--- a/conf/path.h
+++ b/conf/path.h
@@ -23,11 +23,11 @@
 #include "conf/conf.h"
 
 struct c2_conf_pathcomp {
+	bool pc_iskey;
 	union {
 		enum c2_conf_objtype relation;
 		struct c2_conf_bytes key;
 	} pc_u;
-	bool pc_iskey;
 };
 
 struct c2_conf_path {
@@ -38,11 +38,15 @@ struct c2_conf_path {
 
 /**
  * Returns true iff the path is empty or has the following properties:
- * - the first component is a relation;
- * - a directory is followed by a key or is the last component;
- * - a key is preceded by a directory (hence a key cannot follow an object);
- * - the path consists of downlinks (for those c2_conf_downlink() != NULL).
+ * - relations are downlinks (c2_conf_downlink() != NULL);
+ * - the first component is a downlink;
+ * - a one-to-many downlink is followed by a key or is the last
+ *   component;
+ * - a key is preceded by a one-to-many downlink.
  */
 bool c2_conf_path_invariant(const struct c2_conf_path *path);
 
+/** Returns true iff `path' ends with a one-to-many downlink. */
+bool c2_conf_path_is_dir(const struct c2_conf_path *path);
+
 #endif /* __COLIBRI_CONF_PATH_H__ */
diff --git a/conf/relation.c b/conf/relation.c
index ff01212..7660499 100644
--- a/conf/relation.c
+++ b/conf/relation.c
@@ -23,28 +23,28 @@
 #endif
 #include "conf/relation.h"
 
-const struct c2_conf_relation rels_profile[] = {
+const struct c2_conf_relation dl_profile[] = {
 	{
 		.r_type   = C2_CO_FILESYSTEM,
 		.r_offset = offsetof(struct c2_conf_profile, cp_filesystem),
 		.r_dir    = NULL
 	}
 };
-const struct c2_conf_relation rels_filesystem[] = {
+const struct c2_conf_relation dl_filesystem[] = {
 	{
 		.r_type   = C2_CO_SERVICE,
 		.r_offset = offsetof(struct c2_conf_filesystem, cf_services),
 		.r_dir    = c2_conf_filesystem_services_tl
 	}
 };
-const struct c2_conf_relation rels_service[] = {
+const struct c2_conf_relation dl_service[] = {
 	{
 		.r_type   = C2_CO_NODE,
 		.r_offset = offsetof(struct c2_conf_service, cs_node),
 		.r_dir    = NULL
 	}
 };
-const struct c2_conf_relation rels_node[] = {
+const struct c2_conf_relation dl_node[] = {
 	{
 		.r_type   = C2_CO_NIC,
 		.r_offset = offsetof(struct c2_conf_node, cn_nics),
@@ -56,7 +56,7 @@ const struct c2_conf_relation rels_node[] = {
 		.r_dir    = c2_conf_node_sdevs_tl
 	}
 };
-const struct c2_conf_relation rels_sdev[] = {
+const struct c2_conf_relation dl_sdev[] = {
 	{
 		.r_type   = C2_CO_PARTITION,
 		.r_offset = offsetof(struct c2_conf_sdev, sd_partitions),
@@ -68,17 +68,17 @@ const struct rels {
 	const struct c2_conf_relation *data;
 	size_t                         nr;
 } downlinks[C2_CO_NR] = {
-	[C2_CO_PROFILE]    = { .data = rels_profile,
-			       .nr   = ARRAY_SIZE(rels_profile) },
-	[C2_CO_FILESYSTEM] = { .data = rels_filesystem,
-			       .nr   = ARRAY_SIZE(rels_filesystem) },
-	[C2_CO_SERVICE]    = { .data = rels_service,
-			       .nr   = ARRAY_SIZE(rels_service) },
-	[C2_CO_NODE]       = { .data = rels_node,
-			       .nr   = ARRAY_SIZE(rels_node) },
+	[C2_CO_PROFILE]    = { .data = dl_profile,
+			       .nr   = ARRAY_SIZE(dl_profile) },
+	[C2_CO_FILESYSTEM] = { .data = dl_filesystem,
+			       .nr   = ARRAY_SIZE(dl_filesystem) },
+	[C2_CO_SERVICE]    = { .data = dl_service,
+			       .nr   = ARRAY_SIZE(dl_service) },
+	[C2_CO_NODE]       = { .data = dl_node,
+			       .nr   = ARRAY_SIZE(dl_node) },
 	[C2_CO_NIC]        = { .data = NULL, .ar_nr = 0 },
-	[C2_CO_SDEV]       = { .data = rels_sdev,
-			       .nr   = ARRAY_SIZE(rels_sdev) },
+	[C2_CO_SDEV]       = { .data = dl_sdev,
+			       .nr   = ARRAY_SIZE(dl_sdev) },
 	[C2_CO_PARTITION]  = { .data = NULL, .ar_nr = 0 }
 };
 
diff --git a/conf/ut/conf.c b/conf/ut/conf.c
index 7166255..60b22de 100644
--- a/conf/ut/conf.c
+++ b/conf/ut/conf.c
@@ -21,11 +21,25 @@
 #ifdef HAVE_CONFIG_H
 #  include <config.h>
 #endif
-#include "conf/conf.c" /* note the inclusion of _definitions_ */
+#include "conf/conf.c"
+#include <string.h>    /* strlen */
 
-/** Checks the invariant of `allowed_relations'. */
-static void relations(void)
+static void test_bytes(void)
 {
-	/* For each element of `allowed_relations' ensure that its
-	 * ->data array has no duplicates of relation::r_type. */
+	char s[] = "hello";
+	struct c2_conf_bytes a = { .cb_len = strlen(s), .cb_data = s };
+	struct c2_conf_bytes b = { .cb_len = strlen(s), .cb_data = "hello" };
+
+	C2_UT_ASSERT(a.cb_data != b.cb_data);
+	C2_UT_ASSERT(c2_conf_bytes_eq(a, b));
+	++b.cb_len;
+	C2_UT_ASSERT(!c2_conf_bytes_eq(a, b));
 }
+
+const struct c2_test_suite conf_ut = {
+	.ts_name  = "conf-ut",
+	.ts_tests = {
+		{ "bytes", test_bytes },
+		{ NULL, NULL }
+	}
+};
diff --git a/conf/ut/confc.c b/conf/ut/confc.c
new file mode 100644
index 0000000..f9b94fd
--- /dev/null
+++ b/conf/ut/confc.c
@@ -0,0 +1,142 @@
+/* -*- c -*- */
+/*
+ * COPYRIGHT 2012 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: Valery V. Vorotyntsev <valery_vorotyntsev@xyratex.com>
+ * Original creation date: 07-Feb-2012
+ */
+
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+#include "conf/confc.c"
+#include <string.h>     /* strlen */
+
+static struct c2_sm_group g_grp;
+static struct c2_thread   g_ath;
+static bool               g_more = true;
+
+static void ast_thread(int n __attribute__((unused)))
+{
+	while (g_more) {
+		c2_chan_wait(&g_grp.s_clink);
+		c2_sm_group_lock(&g_grp);   /* calls c2_sm_asts_run() */
+		c2_sm_group_unlock(&g_grp); /* ditto */
+	}
+}
+
+static int init(void)
+{
+	int rc;
+	c2_sm_group_init(&g_grp);
+	rc = C2_THREAD_INIT(&g_ath, int, NULL, ast_thread, 0, "ast_thread");
+	rc = rc ?: c2_confc_init("test-profile", "XXX_endpoint", &g_grp);
+	return rc;
+}
+
+static int fini(void)
+{
+	c2_confc_fini();
+	g_more = false;
+	c2_clink_signal(&g_grp.s_clink);
+	c2_thread_join(&g_ath);
+	c2_sm_group_fini(&g_grp);
+	return 0;
+}
+
+static void test_init_fini(void)
+{
+	int rc;
+	struct c2_conf_obj *obj;
+	const char prof[] = "test";
+
+	rc = c2_confc_init(prof, "XXX_endpoint", &g_grp);
+	C2_UT_ASSERT(rc == -1); /* already initiated */
+
+	c2_confc_fini();
+	C2_UT_ASSERT(confc_cache.cc_sm_group == NULL);
+	C2_UT_ASSERT(!c2_mutex_is_locked(&confc_cache.cc_lock));
+	C2_UT_ASSERT(confc_cache.cc_root == NULL);
+
+	rc = c2_confc_init(prof, "XXX_endpoint", &g_grp);
+	C2_UT_ASSERT(rc == 0);
+	C2_UT_ASSERT(confc_cache.cc_sm_group == &g_grp);
+	C2_UT_ASSERT(!c2_mutex_is_locked(&confc_cache.cc_lock));
+	C2_UT_ASSERT(confc_cache.cc_root != NULL);
+
+	obj = &confc_cache.cc_root->cp_obj;
+	C2_UT_ASSERT(obj->co_status == C2_CS_MISSING);
+	C2_UT_ASSERT(obj->co_type   == C2_CO_PROFILE);
+	{
+		const struct c2_conf_bytes prof_bytes = {
+			.cb_data = prof,
+			.cb_len  = strlen(prof)
+		};
+		C2_UT_ASSERT(c2_conf_bytes_eq(obj->co_key, &prof_bytes));
+		C2_UT_ASSERT(/* allocated */ obj->co_key.cb_data != prof);
+	}
+}
+
+static void test_fetchctx(void)
+{
+	struct c2_confc_fetchctx ctx;
+
+	c2_confc_fetchctx_init(&ctx);
+	C2_UT_ASSERT(ctx.fc_mach.sm_grp   == &g_grp);
+	C2_UT_ASSERT(ctx.fc_mach.sm_state == S_INITIAL);
+
+	C2_UT_ASSERT(ctx.fc_result == NULL);
+	C2_UT_ASSERT(ctx.fc_errno  == 0);
+	C2_UT_ASSERT(ctx.fc__path  == NULL);
+
+	C2_UT_ASSERT(ctx.fc__ast.sa_cb    == NULL);
+	C2_UT_ASSERT(ctx.fc__ast.sa_datum == NULL);
+	C2_UT_ASSERT(ctx.fc__ast.sa_next  == NULL);
+
+	/* c2_sm_ast::sa_mach is not used; c2_sm is accessed via
+	 * container_of()->fc_mach */
+	C2_UT_ASSERT(ctx.fc__ast.sa_mach == NULL);
+
+	/* XXX ctx.fc__fop is not checked. */
+}
+
+static void test_open(void)
+{
+	/*
+	 * - Initiate a c2_confc_fetchctx object --- ctx.
+	 *
+	 * - `path1' ends with a one-to-many downlink.
+	 *   - Assert c2_confc_open(path1, ctx) returns -EISDIR and
+	 *     does not change `ctx'.
+	 *   - Assert g_grp.s_forkq == NULL.
+	 *
+	 * - `path2' ends with a one-to-one downlink.
+	 *   - Assert c2_confc_open(path2, ctx) returns 0.
+	 *   - Assert g_grp.s_forkq != NULL. (NB a race condition)
+	 *   - Assert ctx->fc__path is equal to path2.
+	 */
+}
+
+const struct c2_test_suite confc_ut = {
+	.ts_name  = "confc-ut",
+	.ts_init  = init,
+	.fs_fini  = fini,
+	.ts_tests = {
+		{ "init/fini", test_init_fini },
+		{ "fetchctx",  test_fetchctx },
+		{ "open",      test_open },
+		{ NULL, NULL }
+	}
+};
diff --git a/conf/ut/path.c b/conf/ut/path.c
new file mode 100644
index 0000000..a89b4b0
--- /dev/null
+++ b/conf/ut/path.c
@@ -0,0 +1,37 @@
+/* -*- c -*- */
+/*
+ * COPYRIGHT 2012 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: Valery V. Vorotyntsev <valery_vorotyntsev@xyratex.com>
+ * Original creation date: 08-Feb-2012
+ */
+
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+#include "conf/path.h"
+
+static void test_path_invariant(void)
+{
+	C2_UT_FAIL("XXX not implemented");
+}
+
+const struct c2_test_suite conf_path = {
+	.ts_name  = "conf-path",
+	.ts_tests = {
+		{ "path-invariant", test_path_invariant },
+		{ NULL, NULL }
+	}
+};
diff --git a/conf/ut/relation.c b/conf/ut/relation.c
new file mode 100644
index 0000000..f1a2055
--- /dev/null
+++ b/conf/ut/relation.c
@@ -0,0 +1,87 @@
+/* -*- c -*- */
+/*
+ * COPYRIGHT 2012 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: Valery V. Vorotyntsev <valery_vorotyntsev@xyratex.com>
+ * Original creation date: 08-Feb-2012
+ */
+
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+#include "conf/relation.h"
+#include "lib/cdefs.h"     /* offsetof */
+
+static const struct c2_conf_relation * downlink(enum c2_conf_objtype src,
+						enum c2_conf_objtype tgt,
+						char *tested[C2_CO_NR])
+{
+	const struct c2_conf_relation *ret = c2_conf_downlink(src, tgt);
+	C2_UT_ASSERT(ret != NULL);
+	C2_UT_ASSERT(ret->r_type == tgt);
+	tested[src][tgt] = 1;
+	return ret;
+}
+
+static void test_downlinks(void)
+{
+	const struct c2_conf_relation *r;
+	enum c2_conf_objtype i;
+	enum c2_conf_objtype j;
+	char tested[C2_CO_NR][C2_CO_NR] = {0};
+
+	r = downlink(C2_CO_PROFILE, C2_CO_FILESYSTEM, tested);
+	C2_UT_ASSERT(r->r_offset == offsetof(struct c2_conf_profile,
+					     cp_filesystem));
+	C2_UT_ASSERT(r->r_dir == NULL);
+
+	r = downlink(C2_CO_FILESYSTEM, C2_CO_SERVICE, tested);
+	C2_UT_ASSERT(r->r_offset == offsetof(struct c2_conf_filesystem,
+					     cf_services));
+	C2_UT_ASSERT(r->r_dir == c2_conf_filesystem_services);
+
+	r = downlink(C2_CO_SERVICE, C2_CO_NODE, tested);
+	C2_UT_ASSERT(r->r_offset == offsetof(struct c2_conf_service, cs_node));
+	C2_UT_ASSERT(r->r_dir == NULL);
+
+	r = downlink(C2_CO_NODE, C2_CO_NIC, tested);
+	C2_UT_ASSERT(r->r_offset == offsetof(struct c2_conf_node, cn_nics));
+	C2_UT_ASSERT(r->r_dir == c2_conf_node_nics);
+	r = downlink(C2_CO_NODE, C2_CO_SDEV, tested);
+	C2_UT_ASSERT(r->r_offset == offsetof(struct c2_conf_node, cn_sdevs));
+	C2_UT_ASSERT(r->r_dir == c2_conf_node_sdevs);
+
+	r = downlink(C2_CO_SDEV, C2_CO_PARTITION, tested);
+	C2_UT_ASSERT(r->r_offset == offsetof(struct c2_conf_sdev,
+					     sd_partitions));
+	C2_UT_ASSERT(r->r_dir == c2_conf_sdev_partitions);
+
+	for (i = 0; i < C2_CO_NR; ++i) {
+		for (j = 0; j < C2_CO_NR; ++j) {
+			if (tested[i][j])
+				continue;
+			r = c2_conf_downlink(s, t);
+			C2_UT_ASSERT(r == NULL);
+		}
+	}
+}
+
+const struct c2_test_suite conf_path = {
+	.ts_name  = "conf-relation",
+	.ts_tests = {
+		{ "downlinks", test_downlinks },
+		{ NULL, NULL }
+	}
+};
-- 
1.8.3.2

