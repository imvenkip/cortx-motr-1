From 43d58d15d7ad7850b96e76957171209420650dc2 Mon Sep 17 00:00:00 2001
From: "Valery V. Vorotyntsev" <valery_vorotyntsev@xyratex.com>
Date: Sat, 31 Mar 2012 18:11:26 +0300
Subject: [PATCH 112/311] rearrange lspec subsections

+ fix error in the state diagram (S_FAILURE was labeled incorrectly)
---
 conf/confc.c | 212 +++++++++++++++++++++++++++++------------------------------
 1 file changed, 105 insertions(+), 107 deletions(-)

diff --git a/conf/confc.c b/conf/confc.c
index 877727a..719a8bf 100644
--- a/conf/confc.c
+++ b/conf/confc.c
@@ -152,9 +152,8 @@
  * @section confc-dld-lspec Logical Specification
  *
  * - @ref confc-dld-lspec-comps
- * - @ref confc-dld-lspec-open
- * - @ref confc-dld-lspec-walk
  * - @ref confc-dld-lspec-state
+ * - @ref confc-dld-lspec-walk
  * - @ref confc-dld-lspec-grow
  * - @ref confc-dld-lspec-thread
  *
@@ -184,19 +183,116 @@
  * the confc cache.
  *
  * <!------------------------------------------------------------------>
- * @subsection confc-dld-lspec-open Opening configuration objects/directories
+ * @subsection confc-dld-lspec-state State Specification
  *
  * c2_confc_open() and c2_confc_diropen() check validity of `path'
  * argument, copy it to c2_confc_ctx::fc_path, and post an AST to
  * c2_confc::cc_group.
  *
- * @note c2_sm_ast_post() signals group's clink. Current design of
- *       confc assumes that some external thread will respond to this
- *       event by calling c2_sm_asts_run().
+ * @note  c2_sm_ast_post() signals group's clink. Current design of
+ *        confc assumes that some external thread will respond to this
+ *        event by calling c2_sm_asts_run().
+ *
+ * When the AST, posted by c2_confc_open(), is run, it moves a state
+ * machine (c2_confc_ctx::fc_mach) to S_CHECK state.
+ *
+ * - S_CHECK
+ *
+ * When S_CHECK state is entered, check_st_in() callback is invoked.
+ * It calls path_walk() and, depending on the value returned by this
+ * call, moves the state machine to another state:
+ *
+@verbatim
++---------------------+------------------+
+| path_walk() returns | next confc state |
++---------------------+------------------+
+|    C2_CS_READY      |   S_TERMINAL     |
+|    C2_CS_MISSING    |   S_WAIT_REPLY   |
+|    C2_CS_LOADING    |   S_WAIT_STATUS  |
+|         < 0         |   S_FAILURE      |
++---------------------+------------------+
+@endverbatim
+ *
+ * The algorithm of path_walk() is described below (see @ref
+ * confc-dld-lspec-walk).
+ *
+ * - S_WAIT_REPLY
+ *
+ * When a state machine is about to enter S_WAIT_REPLY state,
+ * wait_reply_st_in() callback is executed. This callback sends
+ * configuration request (c2_confc_ctx::fc_req) to the confd, using
+ * c2_rpc_post().  (Not now; see @ref confc-offline.)
+ *
+ * A state machine remains in S_WAIT_REPLY state until a reply from
+ * confd arrives. This event triggers on_replied() callback.  If
+ * c2_rpc_item::ri_error is non-zero, on_replied() posts an AST that
+ * will eventually move the state machine to S_FAILURE state.  If
+ * ->ri_error is zero, on_replied() increments rpc item's reference
+ * counter (c2_rpc_item_get()) and posts an AST, scheduling transition
+ * to S_GROW_CACHE state.
+ *
+ * - S_WAIT_STATUS
+ *
+ * A state machine in S_WAIT_STATUS state remains idle until any of
+ * the channels (c2_conf_obj::co_chan) that clinks of c2_confc_ctx are
+ * registered with is signaled.  Such an event triggers
+ * on_object_updated() callback, which de-registers clinks (->fc_extra
+ * and ->fc-clink) and posts an AST that will eventually move the
+ * state machine to S_CHECK state.
+ *
+ * @note  Object's channel (c2_conf_obj::co_chan) is signaled
+ *        (c2_chan_broadcast()) 1) when object_enrich() completes
+ *        loading of configuration data into this object and changes
+ *        status of this object to C2_CS_READY (loading succeeded) or
+ *        C2_CS_MISSING (loading failed); 2) when the object is closed
+ *        and its number of references becomes zero.  Of these cases
+ *        only the first one is applicable to S_WAIT_STATUS state.
+ *
+ * - S_GROW_CACHE
+ *
+ * When a state machine is entering S_GROW_CACHE state,
+ * grow_cache_st_in() callback is invoked.  If the error code
+ * contained in confd's response (c2_conf_fetch_resp::fr_rc) is zero,
+ * the callback calls cache_grow() function (see @ref
+ * confc-dld-lspec-grow below).  The callback "releases" rpc item by
+ * calling c2_rpc_item_but().  If ->fr_rc == 0 and cache_grow()
+ * succeeds, grow_cache_st_in() moves the state machine to S_CHECK
+ * state, otherwise --- to S_FAILURE state.
+ *
+ * - S_TERMINAL, S_FAILURE
  *
- * When the AST, posted by c2_confc_open(), is run, it moves the state
- * machine (c2_confc_ctx::fc_mach) to S_CHECK state.  See @ref
- * confc-dld-lspec-state below.
+ * When a state machine enters S_TERMINAL or S_FAILURE state, it
+ * invokes completion_announce() callback.  This function broadcasts
+ * c2_confc_ctx::fc_complete channel.
+ *
+ * @dot
+ * digraph confd_states {
+ *     node [fontsize=11];
+ *     edge [fontsize=11];
+ *     S_INITIAL  [style=filled, fillcolor=lightgrey];
+ *     S_TERMINAL [style=filled, fillcolor=lightgrey,
+ *                 label="{ completion_announce() }\nS_TERMINAL"];
+ *     S_FAILURE  [style=filled, fillcolor=lightgrey,
+ *                 label="{ completion_announce() }\nS_FAILURE"];
+ *
+ *     S_CHECK [label="{ check_st_in() }\nS_CHECK"];
+ *     S_WAIT_REPLY [label="{ wait_reply_st_in() }\nS_WAIT_REPLY"];
+ *     S_GROW_CACHE [label="{ grow_cache_st_in() }\nS_GROW_CACHE"];
+ *
+ *     S_INITIAL -> S_CHECK;
+ *     S_CHECK -> S_TERMINAL [label="all \"needed\" obj-s\nare cached"];
+ *     S_CHECK -> S_FAILURE [label="error"];
+ *     S_CHECK -> S_WAIT_REPLY [label=
+ *   "at least one\nof the \"needed\" obj-s\nis C2_CS_MISSING\n{ set status(es) to C2_CS_LOADING;\nsend request }"];
+ *     S_WAIT_REPLY -> S_FAILURE [label="timeout\nor\nrc != 0"];
+ *     S_WAIT_REPLY -> S_GROW_CACHE [label="response received,\nrc == 0"];
+ *     S_GROW_CACHE -> S_FAILURE [label="error"];
+ *     S_GROW_CACHE -> S_CHECK [label="done"];
+ *     S_CHECK -> S_WAIT_STATUS [label=
+ *   "no C2_CS_MISSING obj-s, but\nat least one is C2_CS_LOADING\n{ c2_clink_add(&obj->co_chan) }"];
+ *     S_WAIT_STATUS -> S_CHECK [label="\"status updated\" event"];
+ * }
+ * @enddot
  *
  * <!------------------------------------------------------------------>
  * @subsection confc-dld-lspec-walk Walking the DAG
@@ -287,104 +383,6 @@
  *     If N = 0, then only ->fc_clink is registered (c2_clink_add()).
  *
  * <!------------------------------------------------------------------>
- * @subsection confc-dld-lspec-state State Specification
- *
- * - S_CHECK
- *
- * When S_CHECK state is entered, check_st_in() callback is
- * invoked. It calls path_walk() and, depending on the value returned
- * by this call, moves the state machine to another state:
- *
-@verbatim
-+---------------------+------------------+
-| path_walk() returns | next confc state |
-+---------------------+------------------+
-|         < 0         |   S_FAILURE      |
-|    C2_CS_READY      |   S_TERMINAL     |
-|    C2_CS_MISSING    |   S_WAIT_REPLY   |
-|    C2_CS_LOADING    |   S_WAIT_STATUS  |
-+---------------------+------------------+
-@endverbatim
- *
- * - S_WAIT_REPLY
- *
- * When a state machine is about to enter S_WAIT_REPLY state,
- * wait_reply_st_in() callback is executed. This callback sends
- * configuration request (c2_confc_ctx::fc_req) to the confd, using
- * c2_rpc_post().  (Not now; see @ref confc-offline.)
- *
- * A state machine remains in S_WAIT_REPLY state until a reply from
- * confd arrives. This event triggers on_replied() callback.  If
- * c2_rpc_item::ri_error is non-zero, on_replied() posts an AST that
- * will eventually move the state machine to S_FAILURE state.  If
- * ->ri_error is zero, on_replied() increments rpc item's reference
- * counter (c2_rpc_item_get()) and posts an AST, scheduling transition
- * to S_GROW_CACHE state.
- *
- * - S_WAIT_STATUS
- *
- * A state machine in S_WAIT_STATUS state remains idle until any of
- * the channels (c2_conf_obj::co_chan) that clinks of c2_confc_ctx are
- * registered with is signaled.  Such an event triggers
- * on_object_updated() callback, which de-registers clinks (->fc_extra
- * and ->fc-clink) and posts an AST that will eventually move the
- * state machine to S_CHECK state.
- *
- * @note Object's channel (c2_conf_obj::co_chan) is signaled
- *       (c2_chan_broadcast()) 1) when object_enrich() completes
- *       loading of configuration data into this object and changes
- *       status of this object to C2_CS_READY (loading succeeded) or
- *       C2_CS_MISSING (loading failed); 2) when the object is closed
- *       and its number of references becomes zero.  Of these cases
- *       only the first one is applicable to S_WAIT_STATUS state.
- *
- * - S_GROW_CACHE
- *
- * When a state machine is entering S_GROW_CACHE state,
- * grow_cache_st_in() callback is invoked.  If the error code
- * contained in confd's response (c2_conf_fetch_resp::fr_rc) is zero,
- * the callback calls cache_grow() function (see `Growing the cache'
- * below).  The callback "releases" rpc item by calling
- * c2_rpc_item_but().  If ->fr_rc == 0 and cache_grow() succeeds,
- * grow_cache_st_in() moves the state machine to S_CHECK state,
- * otherwise --- to S_FAILURE state.
- *
- * - S_TERMINAL, S_FAILURE
- *
- * When a state machine enters S_TERMINAL or S_FAILURE state, it
- * invokes completion_announce() callback.  This function broadcasts
- * c2_confc_ctx::fc_complete channel.
- *
- * @dot
- * digraph confd_states {
- *     node [fontsize=11];
- *     edge [fontsize=11];
- *     S_INITIAL  [style=filled, fillcolor=lightgrey];
- *     S_TERMINAL [style=filled, fillcolor=lightgrey,
- *                 label="{ completion_announce() }\nS_TERMINAL"];
- *     S_FAILURE  [style=filled, fillcolor=lightgrey,
- *                 label="{ completion_announce() }\nS_TERMINAL"];
- *
- *     S_CHECK [label="{ check_st_in() }\nS_CHECK"];
- *     S_WAIT_REPLY [label="{ wait_reply_st_in() }\nS_WAIT_REPLY"];
- *     S_GROW_CACHE [label="{ grow_cache_st_in() }\nS_GROW_CACHE"];
- *
- *     S_INITIAL -> S_CHECK;
- *     S_CHECK -> S_TERMINAL [label="all \"needed\" obj-s\nare cached"];
- *     S_CHECK -> S_FAILURE [label="error"];
- *     S_CHECK -> S_WAIT_REPLY [label=
- *   "at least one\nof the \"needed\" obj-s\nis C2_CS_MISSING\n{ set status(es) to C2_CS_LOADING;\nsend request }"];
- *     S_WAIT_REPLY -> S_FAILURE [label="timeout\nor\nrc != 0"];
- *     S_WAIT_REPLY -> S_GROW_CACHE [label="response received,\nrc == 0"];
- *     S_GROW_CACHE -> S_FAILURE [label="error"];
- *     S_GROW_CACHE -> S_CHECK [label="done"];
- *     S_CHECK -> S_WAIT_STATUS [label=
- *   "no C2_CS_MISSING obj-s, but\nat least one is C2_CS_LOADING\n{ clink_add(&obj->co_chan) }"];
- *     S_WAIT_STATUS -> S_CHECK [label="\"status updated\" event"];
- * }
- * @enddot
- *
- * <!------------------------------------------------------------------>
  * @subsection confc-dld-lspec-grow Growing the cache
  *
  * cache_grow() locks the cache (c2_confc::cc_lock) and unlocks before
-- 
1.8.3.2

