From 097d53e378c10c6c40c5e7f8624940d4b3d17dbb Mon Sep 17 00:00:00 2001
From: Hua Huang <hua_huang@xyratex.com>
Date: Fri, 11 Oct 2013 11:13:01 +0800
Subject: [PATCH 4/8] initial code for iterator persistence: store sw on
 storage.

---
 cm/sw.c | 124 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 cm/sw.h |  26 ++++++++++++++
 2 files changed, 150 insertions(+)

diff --git a/cm/sw.c b/cm/sw.c
index 549c4e7..311b087 100644
--- a/cm/sw.c
+++ b/cm/sw.c
@@ -24,6 +24,7 @@
 #include "lib/time.h"
 #include "lib/misc.h"
 #include "lib/memory.h"
+#include "lib/locality.h"
 
 #include "fop/fop.h"
 #include "rpc/rpc.h"
@@ -133,6 +134,129 @@ M0_INTERNAL int m0_cm_sw_remote_update(struct m0_cm *cm)
 	return rc;
 }
 
+M0_INTERNAL int m0_cm_sw_store_init(struct m0_cm *cm)
+{
+	struct m0_be_seg      *seg    = cm->cm_service.rs_reqh->rh_beseg;
+	struct m0_sm_group    *grp    = m0_locality0_get()->lo_grp;
+	struct m0_be_tx_credit cred   = M0_BE_TX_CREDIT_INIT(0, 0);
+	struct m0_be_tx        tx     = {};
+	struct m0_cm_sw       *sw;
+	char                   cm_sw_name[80];
+	int                    rc;
+
+	sprintf(cm_sw_name, "cm_sw_%llu", (unsigned long long)cm->cm_id);
+	rc = m0_be_seg_dict_lookup(seg, cm_sw_name, (void**)&sw);
+	if (rc == 0)
+		return rc;
+
+	/* Is group lock necessary? */
+	/* m0_sm_group_lock(grp); */
+	m0_be_tx_init(&tx, 0, seg->bs_domain, grp, NULL, NULL, NULL, NULL);
+	M0_BE_ALLOC_CREDIT_PTR(sw, seg, &cred);
+	m0_be_tx_prep(&tx, &cred);
+	rc = m0_be_tx_open_sync(&tx);
+
+	if (rc == 0) {
+		M0_BE_ALLOC_PTR_SYNC(sw, seg, &tx);
+		if (sw == NULL) {
+			rc = -ENOMEM;
+		} else {
+		        struct m0_cm_ag_id id_lo;
+			struct m0_cm_ag_id id_hi;
+
+			M0_SET0(&id_lo);
+			M0_SET0(&id_hi);
+			m0_cm_sw_set(sw, &id_lo, &id_hi);
+		}
+		m0_be_tx_close_sync(&tx);
+	}
+
+	m0_be_tx_fini(&tx);
+
+	if (rc == 0)
+		rc = m0_be_seg_dict_insert(seg, grp, cm_sw_name, sw);
+
+	/* m0_sm_group_unlock(grp); */
+	return rc;
+}
+
+M0_INTERNAL int m0_cm_sw_store_load(struct m0_cm *cm, struct m0_cm_sw *out)
+{
+	struct m0_be_seg *seg = cm->cm_service.rs_reqh->rh_beseg;
+	struct m0_cm_sw  *sw;
+	char              cm_sw_name[80];
+	int               rc;
+
+	sprintf(cm_sw_name, "cm_sw_%llu", (unsigned long long)cm->cm_id);
+	rc = m0_be_seg_dict_lookup(seg, cm_sw_name, (void**)&sw);
+	if (rc == 0)
+		m0_cm_sw_copy(out, sw);
+	return rc;
+}
+
+M0_INTERNAL int m0_cm_sw_store_update(struct m0_cm *cm,
+				      const struct m0_cm_sw *last)
+{
+	struct m0_be_seg      *seg    = cm->cm_service.rs_reqh->rh_beseg;
+	struct m0_sm_group    *grp    = m0_locality0_get()->lo_grp;
+	struct m0_be_tx_credit cred;
+	struct m0_be_tx        tx     = {};
+	struct m0_cm_sw       *sw;
+	char                   cm_sw_name[80];
+	int                    rc;
+
+	sprintf(cm_sw_name, "cm_sw_%llu", (unsigned long long)cm->cm_id);
+	rc = m0_be_seg_dict_lookup(seg, cm_sw_name, (void**)&sw);
+	if (rc != 0)
+		return rc;
+
+	m0_be_tx_init(&tx, 0, seg->bs_domain, grp, NULL, NULL, NULL, NULL);
+	cred = M0_BE_TX_CREDIT_TYPE(sw);
+	m0_be_tx_prep(&tx, &cred);
+	rc = m0_be_tx_open_sync(&tx);
+
+	if (rc == 0) {
+		m0_cm_sw_copy(sw, last);
+		M0_BE_TX_CAPTURE_PTR(seg, &tx, sw);
+		m0_be_tx_close_sync(&tx);
+	}
+
+	m0_be_tx_fini(&tx);
+
+	return rc;
+}
+
+M0_INTERNAL int m0_cm_sw_store_finish(struct m0_cm *cm)
+{
+	struct m0_be_seg      *seg    = cm->cm_service.rs_reqh->rh_beseg;
+	struct m0_sm_group    *grp    = m0_locality0_get()->lo_grp;
+	struct m0_be_tx_credit cred;
+	struct m0_be_tx        tx     = {};
+	struct m0_cm_sw       *sw;
+	char                   cm_sw_name[80];
+	int                    rc;
+
+	sprintf(cm_sw_name, "cm_sw_%llu", (unsigned long long)cm->cm_id);
+	rc = m0_be_seg_dict_lookup(seg, cm_sw_name, (void**)&sw);
+	if (rc != 0)
+		return rc;
+
+	m0_be_tx_init(&tx, 0, seg->bs_domain, grp, NULL, NULL, NULL, NULL);
+	M0_BE_FREE_CREDIT_PTR(sw, seg, &cred);
+	m0_be_tx_prep(&tx, &cred);
+	rc = m0_be_tx_open_sync(&tx);
+
+	if (rc == 0) {
+		M0_BE_FREE_PTR_SYNC(sw, seg, &tx);
+		m0_be_tx_close_sync(&tx);
+	}
+
+	m0_be_tx_fini(&tx);
+
+	return rc;
+}
+
+
 #undef M0_TRACE_SUBSYSTEM
 
 /** @} CMSW */
diff --git a/cm/sw.h b/cm/sw.h
index 11c1aa5..d6b8861 100644
--- a/cm/sw.h
+++ b/cm/sw.h
@@ -75,6 +75,32 @@ M0_INTERNAL int m0_cm_sw_local_update(struct m0_cm *cm);
 
 M0_INTERNAL int m0_cm_sw_remote_update(struct m0_cm *cm);
 
+
+/**
+ * Init sliding window data for this copy machine.
+ */
+M0_INTERNAL int m0_cm_sw_store_init(struct m0_cm *cm);
+
+/**
+ * Load sliding window data from persistent storage.
+ *
+ * -ENOENT is returned if no sliding window data is found on storage.
+ * The caller should call m0_cm_sw_store_init() to initialize the storage.
+ */
+M0_INTERNAL int m0_cm_sw_store_load(struct m0_cm *cm, struct m0_cm_sw *out);
+
+/**
+ * Update sliding window data to the last completed AG.
+ */
+M0_INTERNAL int m0_cm_sw_store_update(struct m0_cm *cm,
+				      const struct m0_cm_sw *last);
+
+/**
+ * Mark the cm operation as done by deleting sliding window data from storage.
+ */
+M0_INTERNAL int m0_cm_sw_store_finish(struct m0_cm *cm);
+
+
 /** @} CMSW */
 
 #endif /* __MERO_CM_SW_H__ */
-- 
1.8.3.2

