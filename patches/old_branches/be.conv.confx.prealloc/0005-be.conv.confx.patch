From c46ef805be8b32c4150de2f880dcbdae4a5f9d0e Mon Sep 17 00:00:00 2001
From: Mandar Sawant <mandar_sawant@xyratex.com>
Date: Tue, 11 Mar 2014 16:57:48 +0530
Subject: [PATCH 5/8] be.conv.confx, - Address inspection comments, fix
 m0_xcode_dup(), handle M0_XA_OPAQUE case. - Use m0_xcode_dup() to copy
 configuration object to BE segment memory.

---
 conf/confc.c     |   4 +-
 conf/confd.c     |  11 ++--
 conf/confd_fom.c |   4 +-
 conf/preload.c   | 185 +++++++++++++++++++++----------------------------------
 conf/preload.h   |   6 +-
 conf/ut/cache.c  |   6 +-
 conf/ut/db.c     |  28 ++++++---
 conf/ut/fuzz.c   |   4 +-
 xcode/xcode.c    |   5 +-
 9 files changed, 110 insertions(+), 143 deletions(-)

diff --git a/conf/confc.c b/conf/confc.c
index 578e353..c902a03 100644
--- a/conf/confc.c
+++ b/conf/confc.c
@@ -1227,11 +1227,11 @@ static int confc_cache_preload(struct m0_confc *confc, const char *local_conf)
 	M0_ENTRY();
 	M0_PRE(confc_is_locked(confc));
 
-	rc = m0_confstr_parse(local_conf, NULL, &enc);
+	rc = m0_confstr_parse(local_conf, NULL, NULL, &enc);
 	if (rc == 0) {
 		for (i = 0; i < enc->cx_nr && rc == 0; ++i)
 			rc = cached_obj_update(confc, &enc->cx_objs[i]);
-		m0_confx_free(enc, NULL);
+		m0_confx_free(enc, NULL, NULL);
 	}
 	M0_RETURN(rc);
 }
diff --git a/conf/confd.c b/conf/confd.c
index 9cdfb91..cef593b 100644
--- a/conf/confd.c
+++ b/conf/confd.c
@@ -506,7 +506,8 @@ static int file_read(const char *path, char *dest, size_t sz)
 }
 
 static int confd_cache_preload(struct m0_conf_cache *cache,
-			       struct m0_be_seg *seg, const char *dbpath)
+			       struct m0_be_seg *seg, struct m0_be_tx *tx,
+			       const char *dbpath)
 {
 	static char      buf[4096];
 	struct m0_confx *enc;
@@ -517,7 +518,7 @@ static int confd_cache_preload(struct m0_conf_cache *cache,
 	M0_PRE(m0_mutex_is_locked(cache->ca_lock));
 
 	rc = file_read(dbpath, buf, sizeof buf) ?: m0_confstr_parse(buf, seg,
-								    &enc);
+								    tx, &enc);
 	if (rc != 0)
 		M0_RETURN(rc);
 
@@ -529,7 +530,7 @@ static int confd_cache_preload(struct m0_conf_cache *cache,
 			m0_conf_obj_fill(obj, xobj, cache);
 	}
 
-	m0_confx_free(enc, seg);
+	m0_confx_free(enc, seg, tx);
 	M0_RETURN(rc);
 }
 
@@ -539,6 +540,7 @@ static int confd_allocate(struct m0_reqh_service **service,
 			  struct m0_reqh_context *rctx)
 {
 	struct m0_confd *confd;
+	struct m0_be_tx  tx;
 	int              rc;
 
 	M0_ENTRY();
@@ -557,7 +559,8 @@ static int confd_allocate(struct m0_reqh_service **service,
 	m0_conf_cache_init(&confd->d_cache, &confd->d_lock);
 
 	m0_mutex_lock(&confd->d_lock);
-	rc = confd_cache_preload(&confd->d_cache, rctx->rc_beseg, rctx->rc_confdb);
+	M0_SET0(&tx);
+	rc = confd_cache_preload(&confd->d_cache, rctx->rc_beseg, &tx, rctx->rc_confdb);
 	m0_mutex_unlock(&confd->d_lock);
 
 	if (rc == 0) {
diff --git a/conf/confd_fom.c b/conf/confd_fom.c
index 33eb30c..9678abd 100644
--- a/conf/confd_fom.c
+++ b/conf/confd_fom.c
@@ -131,7 +131,7 @@ static int conf_fetch_tick(struct m0_fom *fom)
 	confd = bob_of(fom->fo_service, struct m0_confd, d_reqh, &m0_confd_bob);
 	m0_mutex_lock(&confd->d_lock);
 	rc = confx_populate(&r->fr_data, &q->f_origin, &q->f_path,
-			    &confd->d_cache, confd->d_reqh.rs_reqh->rh_beseg);
+			    &confd->d_cache);
 	m0_mutex_unlock(&confd->d_lock);
 	if (rc != 0)
 		M0_ASSERT(r->fr_data.cx_nr == 0 && r->fr_data.cx_objs == NULL);
@@ -270,7 +270,7 @@ static int confx_populate(struct m0_confx *dest, const struct m0_fid *origin,
 	if (rc == 0)
 		M0_ASSERT(nr == 0);
 	else
-		m0_confx_free(dest, seg);
+		m0_confx_free(dest, NULL, NULL);
 	M0_RETURN(rc);
 }
 
diff --git a/conf/preload.c b/conf/preload.c
index 5bacc3a..6f9af44 100644
--- a/conf/preload.c
+++ b/conf/preload.c
@@ -72,31 +72,31 @@ static void *__confx_alloc(struct m0_xcode_cursor *ctx, size_t nob)
 	return addr;
 }
 
-M0_INTERNAL void m0_confx_free(struct m0_confx *enc, struct m0_be_seg *seg)
+M0_INTERNAL void m0_confx_free(struct m0_confx *enc, struct m0_be_seg *seg,
+			       struct m0_be_tx *tx)
 {
 	struct confx_ctx       *cctx;
 	struct m0_be_tx_credit  cred = {};
-	struct m0_be_tx         tx;
 	struct m0_sm_group     *grp = m0_locality0_get()->lo_grp;
 	int                     rc;
 
 	M0_ENTRY();
 
 	if (enc != NULL) {
-		if (seg == NULL)
+		if (seg == NULL) {
 			m0_xcode_free(&M0_XCODE_OBJ(m0_confx_xc, enc));
-		else {
+		} else {
 			cctx = container_of(enc, struct confx_ctx, cc_confx);
 			m0_be_allocator_credit(m0_be_seg_allocator(seg), M0_BAO_FREE,
 					       cctx->cc_total, 0, &cred);
 			m0_sm_group_lock(grp);
-			m0_be_tx_init(&tx, 0, seg->bs_domain, grp, NULL, NULL, NULL, NULL);
-			m0_be_tx_prep(&tx, &cred);
-			rc = m0_be_tx_open_sync(&tx);
+			m0_be_tx_init(tx, 0, seg->bs_domain, grp, NULL, NULL, NULL, NULL);
+			m0_be_tx_prep(tx, &cred);
+			rc = m0_be_tx_open_sync(tx);
 			M0_ASSERT(rc == 0);
-			M0_BE_FREE_PTR_SYNC(cctx->cc_ptr, seg, &tx);
-			m0_be_tx_close_sync(&tx);
-			m0_be_tx_fini(&tx);
+			M0_BE_FREE_PTR_SYNC(cctx->cc_ptr, seg, tx);
+			m0_be_tx_close_sync(tx);
+			m0_be_tx_fini(tx);
 			m0_sm_group_unlock(grp);
 			m0_free(cctx);
 		}
@@ -105,148 +105,103 @@ M0_INTERNAL void m0_confx_free(struct m0_confx *enc, struct m0_be_seg *seg)
 	M0_LEAVE();
 }
 
-static size_t confstr_to_obj_size(const char *s)
-{
-	int                   slen = 0;
-	uint32_t              type;
-	uint32_t              nr_confx_obj;
-	size_t                obj_size = 0;
-	static const uint32_t conf_objtype_size[M0_CO_NR] = {
-			[M0_CO_DIR]     = 0,
-			[M0_CO_PROFILE] = sizeof(struct m0_confx_profile),
-			[M0_CO_FILESYSTEM] = sizeof(struct m0_confx_filesystem),
-			[M0_CO_SERVICE] = sizeof (struct m0_confx_service),
-			[M0_CO_NODE] = sizeof (struct m0_confx_node),
-			[M0_CO_NIC] = sizeof(struct m0_confx_nic),
-			[M0_CO_SDEV] = sizeof(struct m0_confx_sdev),
-			[M0_CO_PARTITION] = sizeof(struct m0_confx_partition)
-	};
-	static const char structure[M0_XA_NR][M0_XCODE_CURSOR_NR] = {
-					/* NONE  PRE   IN POST */
-			[M0_XA_RECORD]   = { 0, '(',   0, ')' },
-			[M0_XA_UNION]    = { 0, '{',   0, '}' },
-			[M0_XA_SEQUENCE] = { 0, '[',   0, ']' },
-			[M0_XA_TYPEDEF]  = { 0,   0,   0,   0 },
-			[M0_XA_OPAQUE]   = { 0,   0,   0,   0 },
-			[M0_XA_ATOM]     = { 0,   0,   0,   0 }
-	};
-
-	/* calculate number of struct m0_confx_obj objects. */
-	if (*s != '\0' && *s == '[') {
-		s++;
-		sscanf(s, "%u\n", &nr_confx_obj);
-		obj_size += sizeof(struct m0_confx_obj) * nr_confx_obj;
-	}
-
-	while (*s != '\0') {
-		type = 0;
-		if (*s == structure[M0_XA_UNION][M0_XCODE_CURSOR_PRE]) {
-			s++;
-			/*
-			 * Extract the configuration object type in-order to
-			 * calculate and accumulate corresponding object size.
-			 */
-			sscanf(s, "%u\n", &type);
-			obj_size += conf_objtype_size[type];
-		}
-		if (*s == structure[M0_XA_SEQUENCE][M0_XCODE_CURSOR_PRE])
-			obj_size += sizeof(m0_bcount_t);
-		/* String start */
-		if (*s == '"') {
-			s++;
-			slen = 0;
-			/* String end */
-			while (*s != '"') {
-				M0_CNT_INC(slen);
-				s++;
-			}
-			obj_size += slen;
-		}
-		s++;
-	}
-
-	return obj_size;
-}
-
-static int confstr_ctx_init(struct confx_ctx *cctx, const char *s,
-			    struct m0_be_seg *seg)
+static int confstr_be_mem_alloc(struct confx_ctx *cctx, struct m0_be_seg *seg,
+				struct m0_be_tx *tx, int size)
 {
 	struct m0_be_tx_credit  cred = {};
-	struct m0_be_tx         tx;
 	struct m0_sm_group     *grp = m0_locality0_get()->lo_grp;
-	size_t                  obj_size = 0;
 	int                     rc;
 
-	obj_size = confstr_to_obj_size(s);
-	if (obj_size == 0)
-		return -ENOENT;
 	m0_be_allocator_credit(m0_be_seg_allocator(seg), M0_BAO_ALLOC,
-			       obj_size, 0, &cred);
+			       size, 0, &cred);
 	m0_sm_group_lock(grp);
-	m0_be_tx_init(&tx, 0, seg->bs_domain, grp, NULL, NULL, NULL, NULL);
-	m0_be_tx_prep(&tx, &cred);
-	rc = m0_be_tx_open_sync(&tx);
+	m0_be_tx_init(tx, 0, seg->bs_domain, grp, NULL, NULL, NULL, NULL);
+	m0_be_tx_prep(tx, &cred);
+	rc = m0_be_tx_open_sync(tx);
 	if (rc != 0) {
 		M0_ASSERT(rc == 0);
 		M0_RETURN(rc);
 	}
 	M0_BE_OP_SYNC(__op,
-		      m0_be_alloc(m0_be_seg_allocator(seg), &tx, &__op,
-				  &cctx->cc_ptr, obj_size));
+		      m0_be_alloc(m0_be_seg_allocator(seg), tx, &__op,
+				  &cctx->cc_ptr, size));
 	M0_ASSERT(cctx->cc_ptr != NULL);
-	m0_be_tx_close_sync(&tx);
-	m0_be_tx_fini(&tx);
+	m0_be_tx_close_sync(tx);
+	m0_be_tx_fini(tx);
 	m0_sm_group_unlock(grp);
 	if (cctx->cc_ptr == NULL)
 		return -ENOMEM;
-	cctx->cc_total = obj_size;
+	cctx->cc_total = size;
 	cctx->cc_used  = 0;
 
 	return 0;
 }
 
 M0_INTERNAL int m0_confstr_parse(const char *s, struct m0_be_seg *seg,
-				 struct m0_confx **out)
+				 struct m0_be_tx *tx, struct m0_confx **out)
 {
 	struct confx_ctx       *cctx = NULL;
 	struct m0_xcode_ctx     ctx;
-	struct m0_xcode_ctx    *xctx;
 	int                     rc;
+	int                     result;
 
 	M0_ENTRY();
 
 	M0_SET0(&ctx);
-	/*
-	 * Support building configuration objects in both BE segment memory as
-	 * well as main memory through xcode.
-	 */
-	if (seg != NULL) {
+	M0_ALLOC_PTR(*out);
+	if (*out == NULL)
+		return -ENOMEM;
+	m0_xcode_ctx_init(&ctx, &M0_XCODE_OBJ(m0_confx_xc, *out));
+	rc = m0_xcode_read(&ctx, s);
+	if (rc != 0) {
+		M0_LOG(M0_NOTICE, "Cannot parse configuration string:\n%s", s);
+		m0_free(*out);
+		M0_RETURN(rc);
+	}
+	if (rc == 0 && seg != NULL) {
+		struct m0_xcode_ctx *dctx;
+
 		M0_ALLOC_PTR(cctx);
-		if (cctx == NULL)
-			M0_RETURN(-ENOMEM);
-		rc = confstr_ctx_init(cctx, s, seg);
-		if (rc != 0) {
+		if (cctx == NULL) {
+			rc = -ENOMEM;
+			goto cleanup;
+		}
+		M0_SET0(&ctx);
+		m0_xcode_ctx_init(&ctx, &M0_XCODE_OBJ(m0_confx_xc, *out));
+		result = m0_xcode_length(&ctx);
+		if (result < 0) {
 			m0_free(cctx);
-			M0_RETURN(rc);
+			rc = result;
+			goto cleanup;
+		} else {
+			result += sizeof(struct m0_confx_obj) * (*out)->cx_nr;
+			rc = confstr_be_mem_alloc(cctx, seg, tx, result);
+			if (rc != 0) {
+				m0_free(cctx);
+				goto cleanup;
+			}
+			dctx = &cctx->cc_xctx;
+			M0_SET0(dctx);
+			M0_SET0(&ctx);
+			m0_xcode_ctx_init(dctx, &M0_XCODE_OBJ(m0_confx_xc,
+					  &cctx->cc_confx));
+			dctx->xcx_alloc = __confx_alloc;
+			m0_xcode_ctx_init(&ctx, &M0_XCODE_OBJ(m0_confx_xc,
+							      *out));
+			rc = m0_xcode_dup(dctx, &ctx);
+			if (rc == 0) {
+				m0_confx_free(*out, NULL, NULL);
+				*out = &cctx->cc_confx;
+			}
 		}
-		xctx = &cctx->cc_xctx;
-		M0_SET0(xctx);
-		*out = &cctx->cc_confx;
-	} else {
-		xctx = &ctx;
-		M0_ALLOC_PTR(*out);
 	}
-	if (*out == NULL)
-		return -ENOMEM;
-	m0_xcode_ctx_init(xctx, &M0_XCODE_OBJ(m0_confx_xc, *out));
-	xctx->xcx_alloc = cctx == NULL ? m0_xcode_alloc : __confx_alloc;
-	rc = m0_xcode_read(xctx, s);
+
+cleanup:
 	if (rc != 0) {
-		M0_ASSERT(rc < 0);
-		M0_LOG(M0_NOTICE, "Cannot parse configuration string:\n%s", s);
-		m0_confx_free(*out, seg);
+		m0_confx_free(*out, NULL, NULL);
 		*out = NULL;
 	}
+
 	M0_RETURN(rc);
 }
 
diff --git a/conf/preload.h b/conf/preload.h
index 37ac688..85bd7e6 100644
--- a/conf/preload.h
+++ b/conf/preload.h
@@ -23,6 +23,7 @@
 
 struct m0_confx;
 struct m0_be_seg;
+struct m0_be_tx;
 
 /**
  * @page conf-fspec-preload Pre-Loading of Configuration Cache
@@ -140,10 +141,11 @@ struct m0_be_seg;
  * @endcode
  */
 M0_INTERNAL int m0_confstr_parse(const char *s, struct m0_be_seg *seg,
-				 struct m0_confx **out);
+				 struct m0_be_tx *tx, struct m0_confx **out);
 
 /** Frees the memory, dynamically allocated by m0_confstr_parse(). */
-M0_INTERNAL void m0_confx_free(struct m0_confx *enc, struct m0_be_seg *seg);
+M0_INTERNAL void m0_confx_free(struct m0_confx *enc, struct m0_be_seg *seg,
+			       struct m0_be_tx *tx);
 
 /** @} conf_dfspec_preload */
 #endif /* __MERO_CONF_PRELOAD_H__ */
diff --git a/conf/ut/cache.c b/conf/ut/cache.c
index 5fe7b60..ff537cf 100644
--- a/conf/ut/cache.c
+++ b/conf/ut/cache.c
@@ -129,12 +129,12 @@ void test_obj_fill(void)
 	int                 rc;
 	char                buf[4096] = {0};
 
-	m0_confx_free(NULL, NULL); /* to make sure this can be done */
+	m0_confx_free(NULL, NULL, NULL); /* to make sure this can be done */
 
 	rc = m0_ut_file_read(M0_CONF_UT_PATH("conf_xc.txt"), buf, sizeof buf);
 	M0_UT_ASSERT(rc == 0);
 
-	rc = m0_confstr_parse(buf, NULL, &enc);
+	rc = m0_confstr_parse(buf, NULL, NULL, &enc);
 	M0_UT_ASSERT(rc == 0);
         M0_UT_ASSERT(enc->cx_nr == 7); /* "conf_xc.txt" describes 7 objects */
 
@@ -148,7 +148,7 @@ void test_obj_fill(void)
 	}
 	m0_mutex_unlock(&g_lock);
 
-	m0_confx_free(enc, NULL);
+	m0_confx_free(enc, NULL, NULL);
 }
 
 /* ------------------------------------------------------------------ */
diff --git a/conf/ut/db.c b/conf/ut/db.c
index 34f1ef5..f9678a9 100644
--- a/conf/ut/db.c
+++ b/conf/ut/db.c
@@ -217,39 +217,42 @@ static void conf_ut_db_fini()
 	m0_ut_backend_fini(&ut_be, &ut_seg);
 }
 
-void __confstr_parse(char *buf, uint32_t nr_objs)
+void __confstr_parse(char *buf, struct m0_be_tx *tx, uint32_t nr_objs)
 {
 	struct m0_confx *enc;
 	int              rc;
 
-	rc = m0_confstr_parse(buf, seg, &enc);
+	rc = m0_confstr_parse(buf, seg, tx, &enc);
 	M0_UT_ASSERT(rc == 0);
 	M0_UT_ASSERT(enc->cx_nr == nr_objs);
-	m0_confx_free(enc, seg);
+	m0_confx_free(enc, seg, tx);
 }
 
 void test_confstr_parse(void)
 {
-	int   rc;
-	char  buf[1024] = {0};
+	struct m0_be_tx tx;
+	char            buf[1024] = {0};
+	int             rc;
 
 	cleanup();
 
 	conf_ut_db_init();
 
+	M0_SET0(&tx);
 	rc = m0_ut_file_read(M0_CONF_UT_PATH("conf_xc.txt"), buf, sizeof buf);
 	M0_UT_ASSERT(rc == 0);
-	__confstr_parse(buf, 8);
+	__confstr_parse(buf, &tx, 8);
 	memset(buf, 0, 1024);
 	rc = m0_ut_file_read(M0_CONF_UT_PATH("conf-str.txt"), buf, sizeof buf);
 	M0_UT_ASSERT(rc == 0);
-	__confstr_parse(buf, 6);
+	__confstr_parse(buf, &tx, 6);
 	conf_ut_db_fini();
 }
 
 void test_confdb(void)
 {
 	struct m0_confx        *enc;
+	struct m0_be_tx         tx;
 	int                     i;
 	int                     j;
 	int                     hit;
@@ -275,10 +278,14 @@ void test_confdb(void)
 	rc = m0_ut_file_read(M0_CONF_UT_PATH("conf_xc.txt"), buf, sizeof buf);
 	M0_UT_ASSERT(rc == 0);
 
-	rc = m0_confstr_parse("[0]", seg, &enc);
-	M0_UT_ASSERT(rc == -ENOENT);
+	M0_SET0(&tx);
+	rc = m0_confstr_parse("[0]", seg, &tx, &enc);
+        M0_UT_ASSERT(rc == 0);
+        M0_UT_ASSERT(enc->cx_nr == 0);
+        m0_confx_free(enc, seg, &tx);
 
-	rc = m0_confstr_parse(buf, seg, &enc);
+	M0_SET0(&tx);
+	rc = m0_confstr_parse(buf, seg, &tx, &enc);
 	M0_UT_ASSERT(rc == 0);
 	M0_UT_ASSERT(enc->cx_nr == 7);
 
@@ -319,6 +326,7 @@ void test_confdb(void)
 	}
 	M0_UT_ASSERT(hit == ARRAY_SIZE(tests));
 	m0_confx_free(enc, seg);
+	m0_confx_free(enc, seg, &tx);
 	conf_ut_db_fini();
 
 	cleanup();
diff --git a/conf/ut/fuzz.c b/conf/ut/fuzz.c
index 85f1da9..d2ccc67 100644
--- a/conf/ut/fuzz.c
+++ b/conf/ut/fuzz.c
@@ -160,9 +160,9 @@ _fuzz_test(const char *conf_str, char what, char by, bool eq, size_t nr_subs,
 			if (sample == NULL)
 				continue;
 
-			rc = m0_confstr_parse(sample, NULL, &enc);
+			rc = m0_confstr_parse(sample, NULL, NULL, &enc);
 			if (unlikely(rc == 0)) {
-				m0_confx_free(enc, NULL);
+				m0_confx_free(enc, NULL, NULL);
 				++acc->nr_successes;
 			}
 			++acc->nr_total;
diff --git a/xcode/xcode.c b/xcode/xcode.c
index 2d3e266..5fd49d4 100644
--- a/xcode/xcode.c
+++ b/xcode/xcode.c
@@ -428,11 +428,9 @@ M0_INTERNAL int m0_xcode_dup(struct m0_xcode_ctx *dest,
 
 		if (sf->s_flag != M0_XCODE_CURSOR_PRE)
 			continue;
-
 		result = m0_xcode_alloc_obj(dit, dest->xcx_alloc);
 		if (result != 0)
 			return result;
-
 		if (xt->xct_aggr == M0_XA_ATOM) {
 			M0_ASSERT(dobj->xo_ptr != NULL);
 			memcpy(dobj->xo_ptr, sobj->xo_ptr, xt->xct_sizeof);
@@ -479,7 +477,8 @@ M0_INTERNAL int m0_xcode_cmp(const struct m0_xcode_obj *o0,
 		xt = s0->xo_type;
 		M0_ASSERT(xt == s1->xo_type);
 
-		if (is_xcode_cursor_at(&it0, M0_XCODE_CURSOR_PRE, M0_XA_ATOM)) {
+		if (t0->s_flag == M0_XCODE_CURSOR_PRE &&
+		    xt->xct_aggr == M0_XA_ATOM){
 			result = memcmp(s0->xo_ptr, s1->xo_ptr, xt->xct_sizeof);
 			if (result != 0)
 				return result;
-- 
1.8.3.2

