From a8aa190be5c47cf81294dfadcd0751684244c19c Mon Sep 17 00:00:00 2001
From: Mandar Sawant <mandar_sawant@xyratex.com>
Date: Wed, 12 Mar 2014 15:35:14 +0530
Subject: [PATCH 7/8] be.conv.confx, - Address inspection comments. - Move BE
 sepecific code to conf/db.[ch]

---
 conf/Kbuild.sub   |   1 +
 conf/Makefile.sub |   1 +
 conf/db.c         |  11 +++--
 conf/db.h         |  42 ++--------------
 conf/preload.c    | 140 ++++++------------------------------------------------
 5 files changed, 26 insertions(+), 169 deletions(-)

diff --git a/conf/Kbuild.sub b/conf/Kbuild.sub
index 5b4ced0..3deb795 100644
--- a/conf/Kbuild.sub
+++ b/conf/Kbuild.sub
@@ -6,6 +6,7 @@ m0mero_objects += \
                   conf/obj_ops.o \
                   conf/onwire_xc.o \
                   conf/preload.o \
+                  conf/db.o \
                   conf/objs/common.o \
                   conf/objs/dir.o \
                   conf/objs/profile.o \
diff --git a/conf/Makefile.sub b/conf/Makefile.sub
index 758020d..6d8818b 100644
--- a/conf/Makefile.sub
+++ b/conf/Makefile.sub
@@ -18,6 +18,7 @@ mero_libmero_la_SOURCES += \
                            conf/confc.c \
                            conf/confd.c \
                            conf/confd_fom.c \
+                           conf/db.c \
                            conf/fop.c \
                            conf/obj.c \
                            conf/obj_ops.c \
diff --git a/conf/db.c b/conf/db.c
index 160c28c..27ee360 100644
--- a/conf/db.c
+++ b/conf/db.c
@@ -23,9 +23,8 @@
 #include "lib/finject.h"
 
 #include "conf/db.h"
-#include "conf/onwire.h"     /* m0_confx_obj, m0_confx */
+#include "conf/onwire.h"
 #include "conf/onwire_xc.h"
-#include "conf/obj.h"        /* m0_conf_objtype */
 #include "xcode/xcode.h"
 #include "db/db.h"
 #include "be/btree.h"
@@ -34,6 +33,7 @@
 #include "lib/memory.h"      /* m0_alloc, m0_free */
 #include "lib/errno.h"       /* EINVAL */
 #include "lib/misc.h"        /* M0_SET0 */
+#include "lib/locality.h"
 
 static int confdb_objs_count(struct m0_be_btree *btree, size_t *result);
 static void confdb_table_fini(struct m0_be_seg *seg);
@@ -171,13 +171,14 @@ static int confx_obj_dup(struct m0_confx_obj **dest, struct m0_confx_obj *src,
 	if (rc == 0)
 		rc = m0_xcode_be_dup(&dest_obj, &src_obj, seg, tx);
 	*dest = dest_obj.xo_ptr;
+
 	return rc;
 }
 
-M0_INTERNAL int m0_confdb_create_credit(struct m0_be_seg *seg,
-					const struct m0_confx *conf,
-					struct m0_be_tx_credit *accum)
+M0_INTERNAL int m0_confx_to_db(struct m0_confx *conf, struct m0_be_seg *seg,
+			       struct m0_be_tx *tx, struct m0_confx **out)
 {
+<<<<<<< HEAD
 	struct m0_be_btree btree = { .bb_seg = seg };
 	int                rc = 0;
 	int                i;
diff --git a/conf/db.h b/conf/db.h
index abb23a1..246e838 100644
--- a/conf/db.h
+++ b/conf/db.h
@@ -21,48 +21,14 @@
 #ifndef __MERO_CONF_DB_H__
 #define __MERO_CONF_DB_H__
 
-#include "be/tx_credit.h"
 #include "be/seg.h"
 
 
 struct m0_confx;
-struct m0_confx_obj;
 
-/**
- * Calculates BE credits required by configuration database tables and @conf.
- */
-M0_INTERNAL int m0_confdb_create_credit(struct m0_be_seg *seg,
-					const struct m0_confx *conf,
-					struct m0_be_tx_credit *accum);
-
-/**
- * Creates configuration database, populating it with provided
- * configuration data.
- *
- * @pre  conf->cx_nr > 0
- */
-M0_INTERNAL int m0_confdb_create(struct m0_be_seg *seg, struct m0_be_tx *tx,
-                                 const struct m0_confx *conf);
-
-/**
- * Finalises in-memory configuration database.
- */
-M0_INTERNAL void m0_confdb_fini(struct m0_be_seg *seg);
-/**
- * Calculates BE credits in-order to destroy configuration database from
- * persistent store.
- */
-M0_INTERNAL int m0_confdb_destroy_credit(struct m0_be_seg *seg,
-					 struct m0_be_tx_credit *accum);
-M0_INTERNAL int m0_confdb_destroy(struct m0_be_seg *seg, struct m0_be_tx *tx);
-
-/**
- * Creates m0_confx and populates it with data read from a
- * configuration database.
- *
- * If the call succeeds, the user is responsible for freeing allocated
- * memory with m0_confx_free(*out).
- */
-M0_INTERNAL int m0_confdb_read(struct m0_be_seg *seg, struct m0_confx **out);
+M0_INTERNAL int m0_confx_to_db(struct m0_confx *conf, struct m0_be_seg *seg,
+			       struct m0_be_tx *tx, struct m0_confx **out);
+M0_INTERNAL int m0_confdb_free(struct m0_confx *enc, struct m0_be_seg *seg,
+			       struct m0_be_tx *tx);
 
 #endif /* __MERO_CONF_DB_H__ */
diff --git a/conf/preload.c b/conf/preload.c
index 4a0b3a6..ae3caa1 100644
--- a/conf/preload.c
+++ b/conf/preload.c
@@ -22,6 +22,7 @@
 #define M0_TRACE_SUBSYSTEM M0_TRACE_SUBSYS_CONF
 #include "lib/trace.h"
 
+#include "conf/db.h"
 #include "conf/preload.h"
 #include "conf/onwire.h"     /* m0_confx */
 #include "conf/onwire_xc.h"  /* m0_confx_xc */
@@ -39,104 +40,29 @@
  * Contains BE segment memory allocation details corresponding to the
  * configuration object struct confx_ctx::cc_confx.
  */
-struct confx_ctx {
-	void                *cc_ptr;
-	m0_bcount_t          cc_total;
-	m0_bcount_t          cc_used;
-	struct m0_xcode_ctx  cc_xctx;
-	struct m0_confx      cc_confx;
-};
-
-static void *__confx_alloc(struct m0_xcode_cursor *ctx, size_t nob)
-{
-	struct confx_ctx *cctx;
-	char             *addr;
-
-	cctx = container_of(container_of(ctx, struct m0_xcode_ctx, xcx_it),
-			    struct confx_ctx, cc_xctx);
-
-	M0_PRE(cctx->cc_ptr != NULL);
-	M0_PRE(cctx->cc_used + nob <= cctx->cc_total);
-
-	addr = (char *)cctx->cc_ptr + cctx->cc_used;
-	cctx->cc_used += nob;
-
-	return addr;
-}
-
 M0_INTERNAL int m0_confx_free(struct m0_confx *enc, struct m0_be_seg *seg,
 			      struct m0_be_tx *tx)
 {
-	struct confx_ctx       *cctx;
-	struct m0_be_tx_credit  cred = {};
-	struct m0_sm_group     *grp = m0_locality0_get()->lo_grp;
-	int                     rc = 0;
+	int rc = 0;
 
 	M0_ENTRY();
 
 	if (enc != NULL) {
-		if (seg == NULL) {
+		if (seg != NULL)
+			rc = m0_confdb_free(enc, seg, tx);
+		else
 			m0_xcode_free(&M0_XCODE_OBJ(m0_confx_xc, enc));
-		} else {
-			cctx = container_of(enc, struct confx_ctx, cc_confx);
-			m0_be_allocator_credit(m0_be_seg_allocator(seg), M0_BAO_FREE,
-					       cctx->cc_total, 0, &cred);
-			m0_sm_group_lock(grp);
-			m0_be_tx_init(tx, 0, seg->bs_domain, grp, NULL, NULL, NULL, NULL);
-			m0_be_tx_prep(tx, &cred);
-			rc = m0_be_tx_open_sync(tx);
-			if (rc == 0) {
-				M0_BE_FREE_PTR_SYNC(cctx->cc_ptr, seg, tx);
-				m0_be_tx_close_sync(tx);
-			}
-			m0_be_tx_fini(tx);
-			m0_sm_group_unlock(grp);
-			m0_free(cctx);
-		}
 	}
 
 	M0_RETURN(rc);
 }
 
-static int confstr_be_mem_alloc(struct confx_ctx *cctx, struct m0_be_seg *seg,
-				struct m0_be_tx *tx, int size)
-{
-	struct m0_be_tx_credit  cred = {};
-	struct m0_sm_group     *grp = m0_locality0_get()->lo_grp;
-	int                     rc;
-
-	m0_be_allocator_credit(m0_be_seg_allocator(seg), M0_BAO_ALLOC,
-			       size, 0, &cred);
-	m0_sm_group_lock(grp);
-	m0_be_tx_init(tx, 0, seg->bs_domain, grp, NULL, NULL, NULL, NULL);
-	m0_be_tx_prep(tx, &cred);
-	rc = m0_be_tx_open_sync(tx);
-	if (rc != 0) {
-		m0_be_tx_fini(tx);
-		M0_RETURN(rc);
-	}
-	M0_BE_OP_SYNC(__op,
-		      m0_be_alloc(m0_be_seg_allocator(seg), tx, &__op,
-				  &cctx->cc_ptr, size));
-	M0_ASSERT(cctx->cc_ptr != NULL);
-	m0_be_tx_close_sync(tx);
-	m0_be_tx_fini(tx);
-	m0_sm_group_unlock(grp);
-	if (cctx->cc_ptr == NULL)
-		return -ENOMEM;
-	cctx->cc_total = size;
-	cctx->cc_used  = 0;
-
-	return rc;
-}
-
 M0_INTERNAL int m0_confstr_parse(const char *s, struct m0_be_seg *seg,
 				 struct m0_be_tx *tx, struct m0_confx **out)
 {
-	struct confx_ctx       *cctx = NULL;
-	struct m0_xcode_ctx     ctx;
-	int                     rc;
-	int                     result;
+	struct m0_confx     *conf;
+	struct m0_xcode_ctx  ctx;
+	int                  rc;
 
 	M0_ENTRY();
 
@@ -152,53 +78,15 @@ M0_INTERNAL int m0_confstr_parse(const char *s, struct m0_be_seg *seg,
 		M0_RETURN(rc);
 	}
 	if (rc == 0 && seg != NULL) {
-		struct m0_xcode_ctx *dctx;
-
-		M0_ALLOC_PTR(cctx);
-		if (cctx == NULL) {
-			rc = -ENOMEM;
-			goto cleanup;
-		}
-		M0_SET0(&ctx);
-		m0_xcode_ctx_init(&ctx, &M0_XCODE_OBJ(m0_confx_xc, *out));
-		result = m0_xcode_length(&ctx);
-		if (result < 0) {
-			m0_free(cctx);
-			rc = result;
-			goto cleanup;
-		} else {
-			result += sizeof(struct m0_confx_obj) * (*out)->cx_nr;
-			rc = confstr_be_mem_alloc(cctx, seg, tx, result);
-			if (rc != 0) {
-				m0_free(cctx);
-				goto cleanup;
-			}
-			dctx = &cctx->cc_xctx;
-			M0_SET0(dctx);
-			M0_SET0(&ctx);
-			m0_xcode_ctx_init(dctx, &M0_XCODE_OBJ(m0_confx_xc,
-					  &cctx->cc_confx));
-			dctx->xcx_alloc = __confx_alloc;
-			m0_xcode_ctx_init(&ctx, &M0_XCODE_OBJ(m0_confx_xc,
-							      *out));
-			rc = m0_xcode_dup(dctx, &ctx);
-			if (rc == 0) {
-				rc = m0_confx_free(*out, NULL, NULL);
-				if (rc == 0)
-					*out = &cctx->cc_confx;
-			}
-		}
-	}
-
-cleanup:
-	if (rc != 0) {
-		rc = m0_confx_free(*out, NULL, NULL);
+		conf = *out;
+		rc = m0_confx_to_db(conf, seg, tx, out);
+		if (rc != 0)
+			*out = NULL;
+		rc = m0_confx_free(conf, NULL, NULL);
 		if (rc != 0)
 			M0_LOG(M0_NOTICE,
-			       "Cannot free configuration object, rc :\n%s %d",
+			       "Cannot free configuration object, \n%s rc: %d",
 			       s, rc);
-		else
-			*out = NULL;
 	}
 
 	M0_RETURN(rc);
-- 
1.8.3.2

