From 917427b17171043a87f56532322900bbb06330ca Mon Sep 17 00:00:00 2001
From: Yuriy Umanets <yuriy_umanets@xyratex.com>
Date: Tue, 1 Apr 2014 19:25:03 +0400
Subject: [PATCH 02/13] - moved some obf things to client

---
 cob/cob.c                    | 73 --------------------------------------------
 cob/cob.h                    |  6 ----
 fid/fid.c                    | 10 ++++++
 fid/fid.h                    |  6 ++++
 m0t1fs/linux_kernel/dir.c    | 44 +++++++++++++++-----------
 m0t1fs/linux_kernel/inode.c  |  7 +++++
 m0t1fs/linux_kernel/m0t1fs.h |  7 +++++
 m0t1fs/linux_kernel/super.c  | 52 +++++++++++++++++++++++++++++++
 mdservice/md_foms.c          |  3 ++
 mdstore/mdstore.c            |  6 ++--
 10 files changed, 115 insertions(+), 99 deletions(-)

diff --git a/cob/cob.c b/cob/cob.c
index 21349a5..5e8d38c 100644
--- a/cob/cob.c
+++ b/cob/cob.c
@@ -94,16 +94,8 @@ const struct m0_fid M0_COB_SLASH_FID = {
 	.f_key       = 2ULL
 };
 
-/**
-   Obf dir fid.
-*/
-const struct m0_fid M0_COB_OBF_FID = {
-	.f_container = 1ULL,
-	.f_key       = 4ULL
-};
 
 const char M0_COB_ROOT_NAME[] = "ROOT";
-const char M0_COB_OBF_NAME[] = ".mero";
 
 struct m0_addb_ctx m0_cob_mod_ctx;
 
@@ -784,71 +776,6 @@ M0_INTERNAL int m0_cob_domain_mkfs(struct m0_cob_domain *dom,
 		return rc;
 	}
 
-	/**
-	   Create obf dir. At this point it is normal empty directory
-	   used for accessing files via fid number in a way like this:
-	   cat "/mnt/mero/.mero/1:5". In order to provide this kind of
-	   behavior, lookup code path in mdservice/mdstore is modified.
-
-           Rationale why this is done on server side rather than do it
-           on client with creating virtual directry dentry in lookup
-           code path:
-           - client is in kernel space and is more bugs prone and not
-           easy to debug especially when dentry cache is involved;
-           - client stays unmodified and simplistic, which is good;
-           - server would need some modifications in either case;
-           - number of modifications is less in compare to client
-           side paradigm.
-
-	   @see m0_mdstore_lookup
-	 */
-	M0_SET0(&nsrec);
-
-	rc = m0_cob_alloc(dom, &cob);
-	if (rc != 0)
-		return rc;
-
-	rc = m0_cob_nskey_make(&nskey, rootfid, M0_COB_OBF_NAME,
-			       strlen(M0_COB_OBF_NAME));
-	if (rc != 0) {
-	    m0_cob_put(cob);
-	    return rc;
-	}
-
-	nsrec.cnr_omgid = 0;
-	nsrec.cnr_fid = M0_COB_OBF_FID;
-
-	nsrec.cnr_nlink = 2;
-	nsrec.cnr_size = MKFS_ROOT_SIZE;
-	nsrec.cnr_blksize = MKFS_ROOT_BLKSIZE;
-	nsrec.cnr_blocks = MKFS_ROOT_BLOCKS;
-	nsrec.cnr_atime = nsrec.cnr_mtime = nsrec.cnr_ctime =
-		m0_time_seconds(m0_time_now());
-
-	omgrec.cor_uid = 0;
-	omgrec.cor_gid = 0;
-	omgrec.cor_mode = S_IFDIR |
-			  S_IRUSR | S_IWUSR | S_IXUSR | /* rwx for owner */
-			  S_IRGRP | S_IXGRP |           /* r-x for group */
-			  S_IROTH | S_IXOTH;            /* r-x for others */
-
-	rc = m0_cob_fabrec_make(&fabrec, NULL, 0);
-	if (rc != 0) {
-		m0_cob_put(cob);
-		m0_free(nskey);
-		return rc;
-	}
-
-	rc = m0_cob_create(cob, nskey, &nsrec, fabrec, &omgrec, tx);
-	m0_cob_put(cob);
-
-	if (rc == -EEXIST)
-		rc = 0;
-	if (rc != 0) {
-		m0_free(nskey);
-		m0_free(fabrec);
-		return rc;
-	}
 	return 0;
 }
 
diff --git a/cob/cob.h b/cob/cob.h
index 0dbc53d..66cc795 100644
--- a/cob/cob.h
+++ b/cob/cob.h
@@ -222,15 +222,9 @@ struct m0_cob_domain_id;
 /* Namespace name for root cob (not exposed to user) */
 extern const char M0_COB_ROOT_NAME[];
 
-/* Namespace name for obf cob */
-extern const char M0_COB_OBF_NAME[];
-
 /* Grobal cob root fid. */
 extern const struct m0_fid M0_COB_ROOT_FID;
 
-/* Obf fid. */
-extern const struct m0_fid M0_COB_OBF_FID;
-
 /* Hierarchy root fid (exposed to user). */
 extern const struct m0_fid M0_COB_SLASH_FID;
 
diff --git a/fid/fid.c b/fid/fid.c
index 1dbc317..85bfae1 100644
--- a/fid/fid.c
+++ b/fid/fid.c
@@ -84,6 +84,16 @@ M0_INTERNAL const struct m0_fid_type *m0_fid_type_getname(const char *name)
 	return NULL;
 }
 
+/**
+   Obf dir fid.
+*/
+const struct m0_fid M0_COB_OBF_FID = {
+	.f_container = 1ULL,
+	.f_key       = 4ULL
+};
+
+const char M0_COB_OBF_NAME[] = ".mero";
+
 M0_INTERNAL bool m0_fid_is_valid(const struct m0_fid *fid)
 {
 	const struct m0_fid_type *ft = m0_fid_type_getfid(fid);
diff --git a/fid/fid.h b/fid/fid.h
index f4b8112..9b33b21 100644
--- a/fid/fid.h
+++ b/fid/fid.h
@@ -100,6 +100,12 @@ M0_INTERNAL const struct m0_fid_type *
 m0_fid_type_getfid(const struct m0_fid *fid);
 M0_INTERNAL const struct m0_fid_type *m0_fid_type_getname(const char *name);
 
+/* Namespace name for obf cob */
+extern const char M0_COB_OBF_NAME[];
+
+/* Obf fid. */
+extern const struct m0_fid M0_COB_OBF_FID;
+
 /** @} end of fid group */
 #endif /* __MERO_FID_FID_H__ */
 
diff --git a/m0t1fs/linux_kernel/dir.c b/m0t1fs/linux_kernel/dir.c
index b0a91fa..5831581 100644
--- a/m0t1fs/linux_kernel/dir.c
+++ b/m0t1fs/linux_kernel/dir.c
@@ -490,6 +490,9 @@ static int m0t1fs_readdir(struct file *f,
 	csb    = M0T1FS_SB(dir->i_sb);
 	i      = f->f_pos;
 
+	if (m0t1fs_inode_is_obf(&ci->ci_inode))
+		return M0_RC(0);
+
 	fd = f->private_data;
 	if (fd->fd_direof)
 		return M0_RC(0);
@@ -721,6 +724,7 @@ M0_INTERNAL int m0t1fs_getattr(struct vfsmount *mnt, struct dentry *dentry,
 	struct m0_fop_getattr_rep       *getattr_rep;
 	struct m0t1fs_sb                *csb;
 	struct inode                    *inode;
+	struct m0_fop_cob               *body;
 	struct m0t1fs_inode             *ci;
 	struct m0t1fs_mdop               mo;
 	int                              rc;
@@ -735,32 +739,38 @@ M0_INTERNAL int m0t1fs_getattr(struct vfsmount *mnt, struct dentry *dentry,
 
 	m0t1fs_fs_lock(csb);
 
-	M0_SET0(&mo);
-	mo.mo_attr.ca_tfid  = *m0t1fs_inode_fid(ci);
-
-	/**
-	   TODO: When we have rm locking working, this will be changed to
-	   revalidate inode with checking cached lock. If lock is cached
-	   (not canceled), which means inode did not change, then we don't
-	   have to do getattr and can just use @inode cached data.
-	 */
-	rc = m0t1fs_mds_cob_getattr(csb, &mo, &getattr_rep);
-	if (rc != 0)
-		goto out;
-
-	/** Update inode fields with data from @getattr_rep. */
-	rc = m0t1fs_inode_update(inode, &getattr_rep->g_body);
+        /** Return cached attributes for obf dir. */
+	if (!m0t1fs_inode_is_obf(&ci->ci_inode)) {
+	        M0_SET0(&mo);
+	        mo.mo_attr.ca_tfid  = *m0t1fs_inode_fid(ci);
+
+	        /**
+	          TODO: When we have dlm locking working, this will be changed to
+	          revalidate inode with checking cached lock. If lock is cached
+	          (not canceled), which means inode did not change, then we don't
+	          have to do getattr and can just use @inode cached data.
+	        */
+	        rc = m0t1fs_mds_cob_getattr(csb, &mo, &getattr_rep);
+	        if (rc != 0)
+		        goto out;
+		body = &getattr_rep->g_body;
+        } else {
+		body = &csb->csb_obf_body;
+        }
+
+	/** Update inode fields with data from @getattr_rep or cached attrs. */
+	rc = m0t1fs_inode_update(inode, body);
 	if (rc != 0)
 		goto out;
 
 	if (!m0t1fs_inode_is_root(&ci->ci_inode) &&
-	    ci->ci_layout_id != getattr_rep->g_body.b_lid) {
+	    ci->ci_layout_id != body->b_lid) {
 		/* layout for this file is changed. */
 
 		M0_ASSERT(ci->ci_layout_instance != NULL);
 		m0_layout_instance_fini(ci->ci_layout_instance);
 
-		ci->ci_layout_id = getattr_rep->g_body.b_lid;
+		ci->ci_layout_id = body->b_lid;
 		rc = m0t1fs_inode_layout_init(ci);
 		M0_ASSERT(rc == 0);
 	}
diff --git a/m0t1fs/linux_kernel/inode.c b/m0t1fs/linux_kernel/inode.c
index aebeeff..3adb573 100644
--- a/m0t1fs/linux_kernel/inode.c
+++ b/m0t1fs/linux_kernel/inode.c
@@ -58,6 +58,13 @@ M0_INTERNAL bool m0t1fs_inode_is_root(const struct inode *inode)
 			 &M0T1FS_SB(inode->i_sb)->csb_root_fid);
 }
 
+M0_INTERNAL bool m0t1fs_inode_is_obf(const struct inode *inode)
+{
+	struct m0t1fs_inode *ci = M0T1FS_I(inode);
+
+	return m0_fid_eq(m0t1fs_inode_fid(ci), &M0_COB_OBF_FID);
+}
+
 static void init_once(void *foo)
 {
 	struct m0t1fs_inode *ci = foo;
diff --git a/m0t1fs/linux_kernel/m0t1fs.h b/m0t1fs/linux_kernel/m0t1fs.h
index b2b6c93..0adfea8 100644
--- a/m0t1fs/linux_kernel/m0t1fs.h
+++ b/m0t1fs/linux_kernel/m0t1fs.h
@@ -558,6 +558,12 @@ struct m0t1fs_sb {
 
 	/** lnet tmid for client ep */
 	size_t                                  csb_tmid;
+
+        /** .mero virtual dir dentry */
+        struct dentry                          *csb_obf_dentry;
+
+        /** .mero virtual dir attributes. */
+        struct m0_fop_cob                       csb_obf_body;
 };
 
 struct m0t1fs_filedata {
@@ -642,6 +648,7 @@ M0_INTERNAL int m0t1fs_inode_cache_init(void);
 M0_INTERNAL void m0t1fs_inode_cache_fini(void);
 
 M0_INTERNAL bool m0t1fs_inode_is_root(const struct inode *inode);
+M0_INTERNAL bool m0t1fs_inode_is_obf(const struct inode *inode);
 
 M0_INTERNAL struct inode *m0t1fs_root_iget(struct super_block *sb,
 					   struct m0_fid *root_fid);
diff --git a/m0t1fs/linux_kernel/super.c b/m0t1fs/linux_kernel/super.c
index a0d02a2..6191588 100644
--- a/m0t1fs/linux_kernel/super.c
+++ b/m0t1fs/linux_kernel/super.c
@@ -1431,6 +1431,52 @@ static void m0t1fs_teardown(struct m0t1fs_sb *csb)
 	m0t1fs_net_fini(csb);
 }
 
+static int m0t1fs_obf_alloc(struct super_block *sb)
+{
+        struct inode             *obf_inode;
+        struct dentry            *obf_dentry;
+        struct m0t1fs_sb         *csb = M0T1FS_SB(sb);
+	struct m0_fop_cob        *body = &csb->csb_obf_body;
+
+        body->b_atime = body->b_ctime = body->b_mtime = m0_time_seconds(m0_time_now());
+        body->b_valid = (M0_COB_MTIME | M0_COB_CTIME | M0_COB_CTIME |
+	                 M0_COB_UID | M0_COB_GID | M0_COB_BLOCKS |
+	                 M0_COB_SIZE | M0_COB_NLINK | M0_COB_MODE);
+        body->b_blocks = 16;
+        body->b_size = 4096;
+        body->b_blksize = 4096;
+	body->b_nlink = 2;
+        body->b_mode = (S_IFDIR | S_IRUSR | S_IWUSR | S_IXUSR | /* rwx for owner */
+                        S_IRGRP | S_IXGRP |                     /* r-x for group */
+                        S_IROTH | S_IXOTH);
+
+	M0_ENTRY();
+
+        obf_dentry = d_alloc_name(sb->s_root, M0_COB_OBF_NAME);
+        if (obf_dentry == NULL)
+                M0_RETURN(-ENOMEM);
+
+        obf_inode = m0t1fs_iget(sb, &M0_COB_OBF_FID, body);
+        if (IS_ERR(obf_inode)) {
+                dput(obf_dentry);
+                M0_RETURN((int)PTR_ERR(obf_inode));
+        }
+
+        d_add(obf_dentry, obf_inode);
+        csb->csb_obf_dentry = obf_dentry;
+	M0_RETURN(0);
+}
+
+static void m0t1fs_obf_dealloc(struct super_block *sb) {
+	struct m0t1fs_sb         *csb = M0T1FS_SB(sb);
+
+	M0_ENTRY();
+        csb->csb_obf_dentry->d_inode->i_nlink = 0;
+        d_delete(csb->csb_obf_dentry);
+        dput(csb->csb_obf_dentry);
+	M0_LEAVE();
+}
+
 static int m0t1fs_root_alloc(struct super_block *sb)
 {
 	struct inode             *root_inode;
@@ -1504,6 +1550,10 @@ static int m0t1fs_fill_super(struct super_block *sb, void *data,
 	if (rc != 0)
 		goto m0t1fs_teardown;
 
+        rc = m0t1fs_obf_alloc(sb);
+        if (rc != 0)
+                goto m0t1fs_teardown;
+
 	io_bob_tlists_init();
 	M0_SET0(&iommstats);
 
@@ -1541,6 +1591,8 @@ M0_INTERNAL void m0t1fs_kill_sb(struct super_block *sb)
 
 	M0_ENTRY("csb = %p", csb);
 
+        m0t1fs_obf_dealloc(sb);
+
 	kill_anon_super(sb);
 
 	/*
diff --git a/mdservice/md_foms.c b/mdservice/md_foms.c
index 41ba44c..d72781d 100644
--- a/mdservice/md_foms.c
+++ b/mdservice/md_foms.c
@@ -1314,12 +1314,15 @@ static int m0_md_req_path_get(struct m0_mdstore *mdstore,
 			      struct m0_fid *fid,
 			      struct m0_fop_str *str)
 {
+        /** This was solely used for replicator, which is not needed right now. */
+#if 0
 	int rc;
 
 	rc = m0_mdstore_path(mdstore, fid, (char **)&str->s_buf);
 	if (rc != 0)
 		return rc;
 	str->s_len = strlen((char *)str->s_buf);
+#endif
 	return 0;
 }
 
diff --git a/mdstore/mdstore.c b/mdstore/mdstore.c
index 7c0df08..90c1cfa 100644
--- a/mdstore/mdstore.c
+++ b/mdstore/mdstore.c
@@ -946,9 +946,6 @@ M0_INTERNAL int m0_mdstore_lookup(struct m0_mdstore     *md,
 	if (pfid == NULL)
 		pfid = (struct m0_fid *)&M0_COB_ROOT_FID;
 
-	rc = m0_cob_nskey_make(&nskey, pfid, (char *)name->b_addr, name->b_nob);
-	if (rc != 0)
-		goto out;
         /*
           Check for obf case and use m0_cob_locate() to get cob by fid
           extracted from name.
@@ -962,6 +959,9 @@ M0_INTERNAL int m0_mdstore_lookup(struct m0_mdstore     *md,
                 }
                 rc = m0_mdstore_locate(md, &fid, cob, M0_MD_LOCATE_STORED);
         } else {
+	        rc = m0_cob_nskey_make(&nskey, pfid, (char *)name->b_addr, name->b_nob);
+	        if (rc != 0)
+		        goto out;
 	        flags = (M0_CA_NSKEY_FREE | M0_CA_FABREC | M0_CA_OMGREC);
 	        rc = m0_cob_lookup(&md->md_dom, nskey, flags, cob);
 	}
-- 
1.8.3.2

