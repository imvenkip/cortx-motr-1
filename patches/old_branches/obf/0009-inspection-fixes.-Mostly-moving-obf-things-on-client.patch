From 390ac59bb8da55efb96f728d81864e49798f3c23 Mon Sep 17 00:00:00 2001
From: Yuriy Umanets <yuriy_umanets@xyratex.com>
Date: Wed, 2 Apr 2014 07:24:03 +0400
Subject: [PATCH 09/13] - inspection fixes. Mostly moving obf things on client
 to separate vector of operations

---
 fid/fid.c                    |   8 +-
 fid/fid.h                    |   8 +-
 m0t1fs/linux_kernel/dir.c    | 248 ++++++++++++++++++++++++++++++++++++-------
 m0t1fs/linux_kernel/inode.c  |  17 +--
 m0t1fs/linux_kernel/m0t1fs.h |  18 +++-
 m0t1fs/linux_kernel/super.c  |   8 +-
 mdstore/mdstore.c            |  38 +++----
 7 files changed, 270 insertions(+), 75 deletions(-)

diff --git a/fid/fid.c b/fid/fid.c
index 7897936..e399447 100644
--- a/fid/fid.c
+++ b/fid/fid.c
@@ -84,19 +84,19 @@ M0_INTERNAL const struct m0_fid_type *m0_fid_type_getname(const char *name)
 	return NULL;
 }
 
-const struct m0_fid M0_VIRT_MERO_FID = {
+const struct m0_fid M0_DOT_MERO_FID = {
 	.f_container = 1ULL,
 	.f_key       = 4ULL
 };
 
-const char M0_VIRT_MERO_NAME[] = ".mero";
+const char M0_DOT_MERO_NAME[] = ".mero";
 
-const struct m0_fid M0_VIRT_OBF_FID = {
+const struct m0_fid M0_DOT_MERO_FID_FID = {
 	.f_container = 1ULL,
 	.f_key       = 5ULL
 };
 
-const char M0_VIRT_OBF_NAME[] = "fid";
+const char M0_DOT_MERO_FID_NAME[] = "fid";
 
 M0_INTERNAL bool m0_fid_is_valid(const struct m0_fid *fid)
 {
diff --git a/fid/fid.h b/fid/fid.h
index 6f9dc74..430c99c 100644
--- a/fid/fid.h
+++ b/fid/fid.h
@@ -101,16 +101,16 @@ m0_fid_type_getfid(const struct m0_fid *fid);
 M0_INTERNAL const struct m0_fid_type *m0_fid_type_getname(const char *name);
 
 /* Namespace name for virtual .mero directory */
-extern const char M0_VIRT_MERO_NAME[];
+extern const char M0_DOT_MERO_NAME[];
 
 /* Virtual .mero directory fid. */
-extern const struct m0_fid M0_VIRT_MERO_FID;
+extern const struct m0_fid M0_DOT_MERO_FID;
 
 /* Namespace name for virtual .mero/fid directory */
-extern const char M0_VIRT_OBF_NAME[];
+extern const char M0_DOT_MERO_FID_NAME[];
 
 /* Virtual .mero/fid directory fid. */
-extern const struct m0_fid M0_VIRT_OBF_FID;
+extern const struct m0_fid M0_DOT_MERO_FID_FID;
 
 /** @} end of fid group */
 #endif /* __MERO_FID_FID_H__ */
diff --git a/m0t1fs/linux_kernel/dir.c b/m0t1fs/linux_kernel/dir.c
index 24bfe90..24a1f4b 100644
--- a/m0t1fs/linux_kernel/dir.c
+++ b/m0t1fs/linux_kernel/dir.c
@@ -41,23 +41,43 @@ static int m0t1fs_create(struct inode     *dir,
 			 int               mode,
 			 struct nameidata *nd);
 
+static int m0t1fs_fid_create(struct inode     *dir,
+			     struct dentry    *dentry,
+			     int               mode,
+			     struct nameidata *nd);
+
 static struct dentry *m0t1fs_lookup(struct inode     *dir,
 				    struct dentry    *dentry,
 				    struct nameidata *nd);
 
+static struct dentry *m0t1fs_fid_lookup(struct inode     *dir,
+				        struct dentry    *dentry,
+				        struct nameidata *nd);
+
 static int m0t1fs_readdir(struct file *f,
 			  void        *dirent,
 			  filldir_t    filldir);
 
+static int m0t1fs_fid_readdir(struct file *f,
+			      void        *dirent,
+			      filldir_t    filldir);
+
 static int m0t1fs_opendir(struct inode *inode, struct file *file);
 static int m0t1fs_releasedir(struct inode *inode, struct file *file);
+static int m0t1fs_fid_opendir(struct inode *inode, struct file *file);
+static int m0t1fs_fid_releasedir(struct inode *inode, struct file *file);
 
 static int m0t1fs_unlink(struct inode *dir, struct dentry *dentry);
+static int m0t1fs_fid_unlink(struct inode *dir, struct dentry *dentry);
 static int m0t1fs_link(struct dentry *old, struct inode *dir,
 		       struct dentry *new);
+static int m0t1fs_fid_link(struct dentry *old, struct inode *dir,
+		           struct dentry *new);
 
 static int m0t1fs_mkdir(struct inode *dir, struct dentry *dentry, int mode);
+static int m0t1fs_fid_mkdir(struct inode *dir, struct dentry *dentry, int mode);
 static int m0t1fs_rmdir(struct inode *dir, struct dentry *dentry);
+static int m0t1fs_fid_rmdir(struct inode *dir, struct dentry *dentry);
 
 static int m0t1fs_component_objects_op(struct m0t1fs_inode *ci,
 				       int (*func)(struct m0t1fs_sb *csb,
@@ -96,6 +116,15 @@ const struct file_operations m0t1fs_dir_file_operations = {
 	.llseek  = generic_file_llseek, /* provided by linux kernel */
 };
 
+const struct file_operations m0t1fs_fid_dir_file_operations = {
+	.read    = generic_read_dir,    /* provided by linux kernel */
+	.open    = m0t1fs_fid_opendir,
+	.release = m0t1fs_fid_releasedir,
+	.readdir = m0t1fs_fid_readdir,
+	.fsync   = simple_fsync,	/* provided by linux kernel */
+	.llseek  = generic_file_llseek, /* provided by linux kernel */
+};
+
 const struct inode_operations m0t1fs_dir_inode_operations = {
 	.create         = m0t1fs_create,
 	.lookup         = m0t1fs_lookup,
@@ -111,6 +140,21 @@ const struct inode_operations m0t1fs_dir_inode_operations = {
         .removexattr    = m0t1fs_removexattr
 };
 
+const struct inode_operations m0t1fs_fid_dir_inode_operations = {
+	.create         = m0t1fs_fid_create,
+	.lookup         = m0t1fs_fid_lookup,
+	.unlink         = m0t1fs_fid_unlink,
+	.link           = m0t1fs_fid_link,
+	.mkdir          = m0t1fs_fid_mkdir,
+	.rmdir          = m0t1fs_fid_rmdir,
+	.setattr        = m0t1fs_fid_setattr,
+	.getattr        = m0t1fs_fid_getattr,
+        .setxattr       = m0t1fs_fid_setxattr,
+        .getxattr       = m0t1fs_fid_getxattr,
+        .listxattr      = m0t1fs_fid_listxattr,
+        .removexattr    = m0t1fs_fid_removexattr
+};
+
 static int name_mem2wire(struct m0_fop_str *tgt,
 			 const struct m0_buf *name)
 {
@@ -169,6 +213,12 @@ void m0t1fs_fid_alloc(struct m0t1fs_sb *csb, struct m0_fid *out)
 	M0_LOG(M0_DEBUG, "fid "FID_F, FID_P(out));
 }
 
+int m0t1fs_fid_setxattr(struct dentry *dentry, const char *name,
+                        const void *value, size_t size, int flags)
+{
+        return -EOPNOTSUPP;
+}
+
 int m0t1fs_setxattr(struct dentry *dentry, const char *name,
                     const void *value, size_t size, int flags)
 {
@@ -197,6 +247,12 @@ int m0t1fs_setxattr(struct dentry *dentry, const char *name,
 	return rc;
 }
 
+ssize_t m0t1fs_fid_getxattr(struct dentry *dentry, const char *name,
+                            void *buffer, size_t size)
+{
+        return -EOPNOTSUPP;
+}
+
 ssize_t m0t1fs_getxattr(struct dentry *dentry, const char *name,
                         void *buffer, size_t size)
 {
@@ -235,11 +291,21 @@ out:
 	return rc;
 }
 
+ssize_t m0t1fs_fid_listxattr(struct dentry *dentry, char *buffer, size_t size)
+{
+        return -EOPNOTSUPP;
+}
+
 ssize_t m0t1fs_listxattr(struct dentry *dentry, char *buffer, size_t size)
 {
         return -EOPNOTSUPP;
 }
 
+int m0t1fs_fid_removexattr(struct dentry *dentry, const char *name)
+{
+        return -EOPNOTSUPP;
+}
+
 int m0t1fs_removexattr(struct dentry *dentry, const char *name)
 {
 	struct m0t1fs_inode        *ci = M0T1FS_I(dentry->d_inode);
@@ -268,6 +334,14 @@ int m0t1fs_removexattr(struct dentry *dentry, const char *name)
 	return rc;
 }
 
+static int m0t1fs_fid_create(struct inode     *dir,
+			     struct dentry    *dentry,
+			     int               mode,
+			     struct nameidata *nd)
+{
+        return -EOPNOTSUPP;
+}
+
 static int m0t1fs_create(struct inode     *dir,
 			 struct dentry    *dentry,
 			 int               mode,
@@ -368,11 +442,36 @@ out:
 	return rc;
 }
 
+static int m0t1fs_fid_mkdir(struct inode *dir, struct dentry *dentry, int mode)
+{
+	return m0t1fs_fid_create(dir, dentry, mode | S_IFDIR, NULL);
+}
+
 static int m0t1fs_mkdir(struct inode *dir, struct dentry *dentry, int mode)
 {
 	return m0t1fs_create(dir, dentry, mode | S_IFDIR, NULL);
 }
 
+static struct dentry *m0t1fs_fid_lookup(struct inode     *dir,
+				        struct dentry    *dentry,
+				        struct nameidata *nd)
+{
+	struct m0_fid             fid;
+        int rc;
+
+        rc = m0_fid_sscanf((char *)dentry->d_name.name, &fid);
+        if (rc != 0) {
+		M0_LEAVE("Cannot parse fid \"%s\"", (char *)dentry->d_name.name);
+		return ERR_PTR(rc);
+        }
+        /**
+           @todo: When multi-mdservice support is added,
+           @fid will be used to figure out what mdservice
+           lookup operation should be sent to.
+        */
+        return m0t1fs_lookup(dir, dentry, nd);
+}
+
 static struct dentry *m0t1fs_lookup(struct inode     *dir,
 				    struct dentry    *dentry,
 				    struct nameidata *nd)
@@ -382,7 +481,6 @@ static struct dentry *m0t1fs_lookup(struct inode     *dir,
 	struct inode             *inode = NULL;
 	struct m0_fop_lookup_rep *rep = NULL;
 	struct m0t1fs_mdop        mo;
-	struct m0_fid             fid;
 	int rc;
 
 
@@ -400,20 +498,6 @@ static struct dentry *m0t1fs_lookup(struct inode     *dir,
 
 	m0t1fs_fs_lock(csb);
 
-        if (m0t1fs_inode_is_fid(&ci->ci_inode)) {
-	        rc = m0_fid_sscanf((char *)dentry->d_name.name, &fid);
-	        if (rc != 0) {
-			M0_LEAVE("ERROR: %d", rc);
-			m0t1fs_fs_unlock(csb);
-			return ERR_PTR(rc);
-	        }
-	        /**
-	           @todo: When multi-mdservice support is added,
-	           @fid will be used to figure out what mdservice
-	           lookup operation should be sent to.
-	        */
-	}
-
 	M0_SET0(&mo);
 	mo.mo_attr.ca_pfid = *m0t1fs_inode_fid(M0T1FS_I(dir));
 	m0_buf_init(&mo.mo_attr.ca_name, (char *)dentry->d_name.name,
@@ -447,6 +531,11 @@ struct m0_dirent *dirent_first(struct m0_fop_readdir_rep *rep)
 	return ent->d_namelen > 0 ? ent : NULL;
 }
 
+static int m0t1fs_fid_opendir(struct inode *inode, struct file *file)
+{
+        return m0t1fs_opendir(inode, file);
+}
+
 static int m0t1fs_opendir(struct inode *inode, struct file *file)
 {
 	struct m0t1fs_filedata *fd;
@@ -468,6 +557,11 @@ static int m0t1fs_opendir(struct inode *inode, struct file *file)
 	return 0;
 }
 
+static int m0t1fs_fid_releasedir(struct inode *inode, struct file *file)
+{
+        return m0t1fs_releasedir(inode, file);
+}
+
 static int m0t1fs_releasedir(struct inode *inode, struct file *file)
 {
 	struct m0t1fs_filedata *fd = file->private_data;
@@ -478,6 +572,13 @@ static int m0t1fs_releasedir(struct inode *inode, struct file *file)
 	return 0;
 }
 
+static int m0t1fs_fid_readdir(struct file *f,
+			      void        *buf,
+			      filldir_t    filldir)
+{
+        return M0_RC(0);
+}
+
 static int m0t1fs_readdir(struct file *f,
 			  void        *buf,
 			  filldir_t    filldir)
@@ -504,9 +605,6 @@ static int m0t1fs_readdir(struct file *f,
 	csb    = M0T1FS_SB(dir->i_sb);
 	i      = f->f_pos;
 
-	if (m0t1fs_inode_is_mero(&ci->ci_inode) || m0t1fs_inode_is_fid(&ci->ci_inode))
-		return M0_RC(0);
-
 	fd = f->private_data;
 	if (fd->fd_direof)
 		return M0_RC(0);
@@ -600,6 +698,12 @@ out:
 	return rc;
 }
 
+static int m0t1fs_fid_link(struct dentry *old, struct inode *dir,
+		           struct dentry *new)
+{
+        return -EOPNOTSUPP;
+}
+
 static int m0t1fs_link(struct dentry *old, struct inode *dir,
 		       struct dentry *new)
 {
@@ -645,6 +749,11 @@ out:
 	return rc;
 }
 
+static int m0t1fs_fid_unlink(struct inode *dir, struct dentry *dentry)
+{
+        return -EOPNOTSUPP;
+}
+
 static int m0t1fs_unlink(struct inode *dir, struct dentry *dentry)
 {
 	struct m0_fop_lookup_rep        *lookup_rep;
@@ -717,6 +826,11 @@ out:
 	return rc;
 }
 
+static int m0t1fs_fid_rmdir(struct inode *dir, struct dentry *dentry)
+{
+        return -EOPNOTSUPP;
+}
+
 static int m0t1fs_rmdir(struct inode *dir, struct dentry *dentry)
 {
 	int rc;
@@ -732,6 +846,68 @@ static int m0t1fs_rmdir(struct inode *dir, struct dentry *dentry)
 	return rc;
 }
 
+M0_INTERNAL int m0t1fs_fid_getattr(struct vfsmount *mnt, struct dentry *dentry,
+			           struct kstat *stat)
+{
+	struct m0t1fs_sb                *csb;
+	struct inode                    *inode;
+	struct m0_fop_cob               *body;
+	struct m0t1fs_inode             *ci;
+	int                              rc;
+
+	M0_ENTRY();
+
+	M0_LOG(M0_INFO, "Name: \"%s\"", dentry->d_name.name);
+
+	inode = dentry->d_inode;
+	csb   = M0T1FS_SB(inode->i_sb);
+	ci    = M0T1FS_I(inode);
+
+	m0t1fs_fs_lock(csb);
+
+        /* Return cached attributes for files in .mero/fid dir */
+        body = &csb->csb_virt_body;
+
+	/* Update inode fields with data from @getattr_rep or cached attrs */
+	rc = m0t1fs_inode_update(inode, body);
+	if (rc != 0)
+		goto out;
+
+	if (ci->ci_layout_id != body->b_lid) {
+		/* layout for this file is changed. */
+
+		M0_ASSERT(ci->ci_layout_instance != NULL);
+		m0_layout_instance_fini(ci->ci_layout_instance);
+
+		ci->ci_layout_id = body->b_lid;
+		rc = m0t1fs_inode_layout_init(ci);
+		M0_ASSERT(rc == 0);
+	}
+
+	/** Now its time to return inode stat data to user. */
+	stat->dev = inode->i_sb->s_dev;
+	stat->ino = inode->i_ino;
+	stat->mode = inode->i_mode;
+	stat->nlink = inode->i_nlink;
+	stat->uid = inode->i_uid;
+	stat->gid = inode->i_gid;
+	stat->rdev = inode->i_rdev;
+	stat->atime = inode->i_atime;
+	stat->mtime = inode->i_mtime;
+	stat->ctime = inode->i_ctime;
+#ifdef HAVE_INODE_BLKSIZE
+	stat->blksize = inode->i_blksize;
+#else
+	stat->blksize = 1 << inode->i_blkbits;
+#endif
+	stat->size = i_size_read(inode);
+	stat->blocks = inode->i_blocks;
+out:
+	m0t1fs_fs_unlock(csb);
+	M0_LEAVE("rc: %d", rc);
+	return rc;
+}
+
 M0_INTERNAL int m0t1fs_getattr(struct vfsmount *mnt, struct dentry *dentry,
 			       struct kstat *stat)
 {
@@ -753,24 +929,19 @@ M0_INTERNAL int m0t1fs_getattr(struct vfsmount *mnt, struct dentry *dentry,
 
 	m0t1fs_fs_lock(csb);
 
-        /** Return cached attributes for obf dir. */
-	if (!m0t1fs_inode_is_mero(&ci->ci_inode) && !m0t1fs_inode_is_fid(&ci->ci_inode)) {
-	        M0_SET0(&mo);
-	        mo.mo_attr.ca_tfid  = *m0t1fs_inode_fid(ci);
-
-	        /**
-	          TODO: When we have dlm locking working, this will be changed to
-	          revalidate inode with checking cached lock. If lock is cached
-	          (not canceled), which means inode did not change, then we don't
-	          have to do getattr and can just use @inode cached data.
-	        */
-	        rc = m0t1fs_mds_cob_getattr(csb, &mo, &getattr_rep);
-	        if (rc != 0)
-		        goto out;
-		body = &getattr_rep->g_body;
-        } else {
-		body = &csb->csb_virt_body;
-        }
+        M0_SET0(&mo);
+        mo.mo_attr.ca_tfid  = *m0t1fs_inode_fid(ci);
+
+	/**
+	   @todo When we have rm locking working, this will be changed to
+	   revalidate inode with checking cached lock. If lock is cached
+	   (not canceled), which means inode did not change, then we don't
+	   have to do getattr and can just use @inode cached data.
+	*/
+        rc = m0t1fs_mds_cob_getattr(csb, &mo, &getattr_rep);
+        if (rc != 0)
+	        goto out;
+	body = &getattr_rep->g_body;
 
 	/** Update inode fields with data from @getattr_rep or cached attrs. */
 	rc = m0t1fs_inode_update(inode, body);
@@ -840,6 +1011,11 @@ out:
 	return rc;
 }
 
+M0_INTERNAL int m0t1fs_fid_setattr(struct dentry *dentry, struct iattr *attr)
+{
+        return -EOPNOTSUPP;
+}
+
 M0_INTERNAL int m0t1fs_setattr(struct dentry *dentry, struct iattr *attr)
 {
 	struct m0_fop_setattr_rep       *setattr_rep;
diff --git a/m0t1fs/linux_kernel/inode.c b/m0t1fs/linux_kernel/inode.c
index e463766..2298416 100644
--- a/m0t1fs/linux_kernel/inode.c
+++ b/m0t1fs/linux_kernel/inode.c
@@ -58,18 +58,18 @@ M0_INTERNAL bool m0t1fs_inode_is_root(const struct inode *inode)
 			 &M0T1FS_SB(inode->i_sb)->csb_root_fid);
 }
 
-M0_INTERNAL bool m0t1fs_inode_is_mero(const struct inode *inode)
+M0_INTERNAL bool m0t1fs_inode_is_dot_mero(const struct inode *inode)
 {
 	struct m0t1fs_inode *ci = M0T1FS_I(inode);
 
-	return m0_fid_eq(m0t1fs_inode_fid(ci), &M0_VIRT_MERO_FID);
+	return m0_fid_eq(m0t1fs_inode_fid(ci), &M0_DOT_MERO_FID);
 }
 
-M0_INTERNAL bool m0t1fs_inode_is_fid(const struct inode *inode)
+M0_INTERNAL bool m0t1fs_inode_is_dot_mero_fid(const struct inode *inode)
 {
 	struct m0t1fs_inode *ci = M0T1FS_I(inode);
 
-	return m0_fid_eq(m0t1fs_inode_fid(ci), &M0_VIRT_OBF_FID);
+	return m0_fid_eq(m0t1fs_inode_fid(ci), &M0_DOT_MERO_FID_FID);
 }
 
 static void init_once(void *foo)
@@ -353,8 +353,13 @@ static int m0t1fs_inode_read(struct inode      *inode,
 		inode->i_op   = &m0t1fs_reg_inode_operations;
 		inode->i_fop  = &m0t1fs_reg_file_operations;
 	} else if (S_ISDIR(inode->i_mode)) {
-		inode->i_op   = &m0t1fs_dir_inode_operations;
-		inode->i_fop  = &m0t1fs_dir_file_operations;
+	        if (m0t1fs_inode_is_dot_mero(inode) || m0t1fs_inode_is_dot_mero_fid(inode)) {
+		        inode->i_op   = &m0t1fs_fid_dir_inode_operations;
+		        inode->i_fop  = &m0t1fs_fid_dir_file_operations;
+	        } else {
+		        inode->i_op   = &m0t1fs_dir_inode_operations;
+		        inode->i_fop  = &m0t1fs_dir_file_operations;
+		}
 	} else {
 		rc = -ENOSYS;
 	}
diff --git a/m0t1fs/linux_kernel/m0t1fs.h b/m0t1fs/linux_kernel/m0t1fs.h
index 57a5115..c3a8de0 100644
--- a/m0t1fs/linux_kernel/m0t1fs.h
+++ b/m0t1fs/linux_kernel/m0t1fs.h
@@ -617,9 +617,11 @@ static inline struct m0t1fs_inode *M0T1FS_I(const struct inode *inode)
 }
 
 extern const struct file_operations m0t1fs_dir_file_operations;
+extern const struct file_operations m0t1fs_fid_dir_file_operations;
 extern const struct file_operations m0t1fs_reg_file_operations;
 
 extern const struct inode_operations m0t1fs_dir_inode_operations;
+extern const struct inode_operations m0t1fs_fid_dir_inode_operations;
 extern const struct inode_operations m0t1fs_reg_inode_operations;
 
 /* super.c */
@@ -637,7 +639,10 @@ M0_INTERNAL bool m0t1fs_fs_is_locked(const struct m0t1fs_sb *csb);
 
 M0_INTERNAL int m0t1fs_getattr(struct vfsmount *mnt, struct dentry *de,
 			       struct kstat *stat);
+M0_INTERNAL int m0t1fs_fid_getattr(struct vfsmount *mnt, struct dentry *de,
+			           struct kstat *stat);
 M0_INTERNAL int m0t1fs_setattr(struct dentry *de, struct iattr *attr);
+M0_INTERNAL int m0t1fs_fid_setattr(struct dentry *de, struct iattr *attr);
 M0_INTERNAL int m0t1fs_inode_update(struct inode *inode,
 				    struct m0_fop_cob *body);
 
@@ -651,8 +656,8 @@ M0_INTERNAL int m0t1fs_inode_cache_init(void);
 M0_INTERNAL void m0t1fs_inode_cache_fini(void);
 
 M0_INTERNAL bool m0t1fs_inode_is_root(const struct inode *inode);
-M0_INTERNAL bool m0t1fs_inode_is_mero(const struct inode *inode);
-M0_INTERNAL bool m0t1fs_inode_is_fid(const struct inode *inode);
+M0_INTERNAL bool m0t1fs_inode_is_dot_mero(const struct inode *inode);
+M0_INTERNAL bool m0t1fs_inode_is_dot_mero_fid(const struct inode *inode);
 
 M0_INTERNAL struct inode *m0t1fs_root_iget(struct super_block *sb,
 					   struct m0_fid *root_fid);
@@ -762,13 +767,22 @@ M0_INTERNAL int m0t1fs_size_update(struct inode *inode,
 M0_INTERNAL int m0t1fs_setxattr(struct dentry *dentry, const char *name,
                                 const void *value, size_t size, int flags);
 
+M0_INTERNAL int m0t1fs_fid_setxattr(struct dentry *dentry, const char *name,
+                                    const void *value, size_t size, int flags);
+
 M0_INTERNAL ssize_t m0t1fs_getxattr(struct dentry *dentry, const char *name,
                                     void *buffer, size_t size);
 
+M0_INTERNAL ssize_t m0t1fs_fid_getxattr(struct dentry *dentry, const char *name,
+                                        void *buffer, size_t size);
+
 M0_INTERNAL int m0t1fs_removexattr(struct dentry *dentry, const char *name);
+M0_INTERNAL int m0t1fs_fid_removexattr(struct dentry *dentry, const char *name);
 
 M0_INTERNAL ssize_t m0t1fs_listxattr(struct dentry *dentry, char *buffer,
 				     size_t size);
+M0_INTERNAL ssize_t m0t1fs_fid_listxattr(struct dentry *dentry, char *buffer,
+				     size_t size);
 
 M0_INTERNAL const struct m0_fid *
 		m0t1fs_inode_fid(const struct m0t1fs_inode *ci);
diff --git a/m0t1fs/linux_kernel/super.c b/m0t1fs/linux_kernel/super.c
index 6197f76..599307c 100644
--- a/m0t1fs/linux_kernel/super.c
+++ b/m0t1fs/linux_kernel/super.c
@@ -1476,25 +1476,25 @@ static int m0t1fs_obf_alloc(struct super_block *sb)
                         S_IROTH | S_IXOTH);
 
         /* Init virtual .mero directory */
-        mero_dentry = d_alloc_name(sb->s_root, M0_VIRT_MERO_NAME);
+        mero_dentry = d_alloc_name(sb->s_root, M0_DOT_MERO_NAME);
         if (mero_dentry == NULL)
                 return M0_RC(-ENOMEM);
 
-        mero_inode = m0t1fs_iget(sb, &M0_VIRT_MERO_FID, body);
+        mero_inode = m0t1fs_iget(sb, &M0_DOT_MERO_FID, body);
         if (IS_ERR(mero_inode)) {
                 dput(mero_dentry);
                 return M0_RC((int)PTR_ERR(mero_inode));
         }
 
         /* Init virtual .mero/fid directory */
-        fid_dentry = d_alloc_name(mero_dentry, M0_VIRT_OBF_NAME);
+        fid_dentry = d_alloc_name(mero_dentry, M0_DOT_MERO_FID_NAME);
         if (fid_dentry == NULL) {
                 iput(mero_inode);
                 dput(mero_dentry);
                 return M0_RC(-ENOMEM);
         }
 
-        fid_inode = m0t1fs_iget(sb, &M0_VIRT_OBF_FID, body);
+        fid_inode = m0t1fs_iget(sb, &M0_DOT_MERO_FID_FID, body);
         if (IS_ERR(fid_inode)) {
                 dput(fid_dentry);
                 iput(mero_inode);
diff --git a/mdstore/mdstore.c b/mdstore/mdstore.c
index a5a166b..2cd6c22 100644
--- a/mdstore/mdstore.c
+++ b/mdstore/mdstore.c
@@ -223,8 +223,8 @@ M0_INTERNAL int m0_mdstore_fcreate(struct m0_mdstore     *md,
 	M0_ASSERT(pfid != NULL);
 
         /* We don't allow create in .mero and .mero/fid directory. */
-        if (m0_fid_eq(pfid, &M0_VIRT_MERO_FID) || m0_fid_eq(pfid, &M0_VIRT_OBF_FID)) {
-                rc = -EINVAL;
+        if (m0_fid_eq(pfid, &M0_DOT_MERO_FID) || m0_fid_eq(pfid, &M0_DOT_MERO_FID_FID)) {
+                rc = -EOPNOTSUPP;
                 goto out;
         }
 
@@ -308,8 +308,8 @@ M0_INTERNAL int m0_mdstore_link(struct m0_mdstore       *md,
 	M0_ASSERT(cob != NULL);
 
         /* We don't allow link in .mero and .mero/fid directory. */
-        if (m0_fid_eq(pfid, &M0_VIRT_MERO_FID) || m0_fid_eq(pfid, &M0_VIRT_OBF_FID)) {
-                rc = -EINVAL;
+        if (m0_fid_eq(pfid, &M0_DOT_MERO_FID) || m0_fid_eq(pfid, &M0_DOT_MERO_FID_FID)) {
+                rc = -EOPNOTSUPP;
                 goto out;
         }
 
@@ -416,16 +416,16 @@ M0_INTERNAL int m0_mdstore_unlink(struct m0_mdstore     *md,
 	M0_ASSERT(cob != NULL);
 
         /* We don't allow unlink in .mero and .mero/fid directories. */
-        if (m0_fid_eq(pfid, &M0_VIRT_MERO_FID) || m0_fid_eq(pfid, &M0_VIRT_OBF_FID)) {
-                rc = -EINVAL;
+        if (m0_fid_eq(pfid, &M0_DOT_MERO_FID) || m0_fid_eq(pfid, &M0_DOT_MERO_FID_FID)) {
+                rc = -EOPNOTSUPP;
                 goto out;
         }
 
         /* We don't allow to kill .mero dir. */
         if (m0_fid_eq(pfid, &M0_COB_SLASH_FID) &&
-            name->b_nob == strlen(M0_VIRT_MERO_NAME) &&
-            !strncmp((char *)name->b_addr, M0_VIRT_MERO_NAME, (int)name->b_nob)) {
-                rc = -EINVAL;
+            name->b_nob == strlen(M0_DOT_MERO_NAME) &&
+            !strncmp((char *)name->b_addr, M0_DOT_MERO_NAME, (int)name->b_nob)) {
+                rc = -EOPNOTSUPP;
                 goto out;
         }
 
@@ -598,15 +598,15 @@ M0_INTERNAL int m0_mdstore_rename(struct m0_mdstore     *md,
 	time(&now);
 
         /* We don't allow rename in/with .mero/fid directories. */
-        if (m0_fid_eq(pfid_tgt, &M0_VIRT_MERO_FID) ||
-            m0_fid_eq(pfid_tgt, &M0_VIRT_OBF_FID) ||
-            m0_fid_eq(pfid_src, &M0_VIRT_MERO_FID) ||
-            m0_fid_eq(pfid_src, &M0_VIRT_OBF_FID) ||
-            m0_fid_eq(m0_cob_fid(cob_tgt), &M0_VIRT_MERO_FID) ||
-            m0_fid_eq(m0_cob_fid(cob_tgt), &M0_VIRT_OBF_FID) ||
-            m0_fid_eq(m0_cob_fid(cob_src), &M0_VIRT_MERO_FID) ||
-            m0_fid_eq(m0_cob_fid(cob_src), &M0_VIRT_OBF_FID)) {
-                rc = -EINVAL;
+        if (m0_fid_eq(pfid_tgt, &M0_DOT_MERO_FID) ||
+            m0_fid_eq(pfid_tgt, &M0_DOT_MERO_FID_FID) ||
+            m0_fid_eq(pfid_src, &M0_DOT_MERO_FID) ||
+            m0_fid_eq(pfid_src, &M0_DOT_MERO_FID_FID) ||
+            m0_fid_eq(m0_cob_fid(cob_tgt), &M0_DOT_MERO_FID) ||
+            m0_fid_eq(m0_cob_fid(cob_tgt), &M0_DOT_MERO_FID_FID) ||
+            m0_fid_eq(m0_cob_fid(cob_src), &M0_DOT_MERO_FID) ||
+            m0_fid_eq(m0_cob_fid(cob_src), &M0_DOT_MERO_FID_FID)) {
+                rc = -EOPNOTSUPP;
                 goto out;
         }
 
@@ -957,7 +957,7 @@ M0_INTERNAL int m0_mdstore_lookup(struct m0_mdstore     *md,
           Check for obf case and use m0_cob_locate() to get cob by fid
           extracted from name.
          */
-        if (m0_fid_eq(pfid, &M0_VIRT_OBF_FID)) {
+        if (m0_fid_eq(pfid, &M0_DOT_MERO_FID_FID)) {
                 rc = m0_fid_sscanf((char *)name->b_addr, &fid);
                 if (rc != 0)
                         goto out;
-- 
1.8.3.2

