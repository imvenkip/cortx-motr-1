From e475277ef11b7b5f30896e7d60373b52256064f4 Mon Sep 17 00:00:00 2001
From: Yuriy Umanets <yuriy_umanets@xyratex.com>
Date: Wed, 26 Mar 2014 05:32:55 +0400
Subject: [PATCH 01/13] - obf code

---
 cob/cob.c                   | 76 +++++++++++++++++++++++++++++++++++++++++++++
 cob/cob.h                   |  6 ++++
 m0t1fs/linux_kernel/dir.c   |  1 +
 m0t1fs/linux_kernel/inode.c | 12 ++++++-
 m0t1fs/linux_kernel/super.c |  6 ++--
 mdstore/mdstore.c           | 74 +++++++++++++++++++++++++++++++++++++++----
 rm/rm.c                     | 26 +++++++++-------
 7 files changed, 179 insertions(+), 22 deletions(-)

diff --git a/cob/cob.c b/cob/cob.c
index a09a435..21349a5 100644
--- a/cob/cob.c
+++ b/cob/cob.c
@@ -94,7 +94,16 @@ const struct m0_fid M0_COB_SLASH_FID = {
 	.f_key       = 2ULL
 };
 
+/**
+   Obf dir fid.
+*/
+const struct m0_fid M0_COB_OBF_FID = {
+	.f_container = 1ULL,
+	.f_key       = 4ULL
+};
+
 const char M0_COB_ROOT_NAME[] = "ROOT";
+const char M0_COB_OBF_NAME[] = ".mero";
 
 struct m0_addb_ctx m0_cob_mod_ctx;
 
@@ -766,6 +775,73 @@ M0_INTERNAL int m0_cob_domain_mkfs(struct m0_cob_domain *dom,
 
 	rc = m0_cob_create(cob, nskey, &nsrec, fabrec, &omgrec, tx);
 	m0_cob_put(cob);
+
+	if (rc == -EEXIST)
+		rc = 0;
+	if (rc != 0) {
+		m0_free(nskey);
+		m0_free(fabrec);
+		return rc;
+	}
+
+	/**
+	   Create obf dir. At this point it is normal empty directory
+	   used for accessing files via fid number in a way like this:
+	   cat "/mnt/mero/.mero/1:5". In order to provide this kind of
+	   behavior, lookup code path in mdservice/mdstore is modified.
+
+           Rationale why this is done on server side rather than do it
+           on client with creating virtual directry dentry in lookup
+           code path:
+           - client is in kernel space and is more bugs prone and not
+           easy to debug especially when dentry cache is involved;
+           - client stays unmodified and simplistic, which is good;
+           - server would need some modifications in either case;
+           - number of modifications is less in compare to client
+           side paradigm.
+
+	   @see m0_mdstore_lookup
+	 */
+	M0_SET0(&nsrec);
+
+	rc = m0_cob_alloc(dom, &cob);
+	if (rc != 0)
+		return rc;
+
+	rc = m0_cob_nskey_make(&nskey, rootfid, M0_COB_OBF_NAME,
+			       strlen(M0_COB_OBF_NAME));
+	if (rc != 0) {
+	    m0_cob_put(cob);
+	    return rc;
+	}
+
+	nsrec.cnr_omgid = 0;
+	nsrec.cnr_fid = M0_COB_OBF_FID;
+
+	nsrec.cnr_nlink = 2;
+	nsrec.cnr_size = MKFS_ROOT_SIZE;
+	nsrec.cnr_blksize = MKFS_ROOT_BLKSIZE;
+	nsrec.cnr_blocks = MKFS_ROOT_BLOCKS;
+	nsrec.cnr_atime = nsrec.cnr_mtime = nsrec.cnr_ctime =
+		m0_time_seconds(m0_time_now());
+
+	omgrec.cor_uid = 0;
+	omgrec.cor_gid = 0;
+	omgrec.cor_mode = S_IFDIR |
+			  S_IRUSR | S_IWUSR | S_IXUSR | /* rwx for owner */
+			  S_IRGRP | S_IXGRP |           /* r-x for group */
+			  S_IROTH | S_IXOTH;            /* r-x for others */
+
+	rc = m0_cob_fabrec_make(&fabrec, NULL, 0);
+	if (rc != 0) {
+		m0_cob_put(cob);
+		m0_free(nskey);
+		return rc;
+	}
+
+	rc = m0_cob_create(cob, nskey, &nsrec, fabrec, &omgrec, tx);
+	m0_cob_put(cob);
+
 	if (rc == -EEXIST)
 		rc = 0;
 	if (rc != 0) {
diff --git a/cob/cob.h b/cob/cob.h
index 66cc795..0dbc53d 100644
--- a/cob/cob.h
+++ b/cob/cob.h
@@ -222,9 +222,15 @@ struct m0_cob_domain_id;
 /* Namespace name for root cob (not exposed to user) */
 extern const char M0_COB_ROOT_NAME[];
 
+/* Namespace name for obf cob */
+extern const char M0_COB_OBF_NAME[];
+
 /* Grobal cob root fid. */
 extern const struct m0_fid M0_COB_ROOT_FID;
 
+/* Obf fid. */
+extern const struct m0_fid M0_COB_OBF_FID;
+
 /* Hierarchy root fid (exposed to user). */
 extern const struct m0_fid M0_COB_SLASH_FID;
 
diff --git a/m0t1fs/linux_kernel/dir.c b/m0t1fs/linux_kernel/dir.c
index 8d63ec5..b0a91fa 100644
--- a/m0t1fs/linux_kernel/dir.c
+++ b/m0t1fs/linux_kernel/dir.c
@@ -296,6 +296,7 @@ static int m0t1fs_create(struct inode     *dir,
 	m0t1fs_fs_lock(csb);
 	ci->ci_fid = new_fid;
 
+	inode->i_ino = ci->ci_fid.f_key;
 	inode->i_mode = mode;
 	inode->i_uid = current_fsuid();
 	if (dir->i_mode & S_ISGID) {
diff --git a/m0t1fs/linux_kernel/inode.c b/m0t1fs/linux_kernel/inode.c
index 69ee9b2..aebeeff 100644
--- a/m0t1fs/linux_kernel/inode.c
+++ b/m0t1fs/linux_kernel/inode.c
@@ -389,9 +389,11 @@ M0_INTERNAL struct inode *m0t1fs_iget(struct super_block *sb,
 	}
 	if ((inode->i_state & I_NEW) != 0) {
 		/* New inode, set its fields from @body */
+	        M0_LOG(M0_DEBUG, "new inode (%p) "FID_F, inode, FID_P(fid));
 		err = m0t1fs_inode_read(inode, body);
 	} else if (!(inode->i_state & (I_FREEING | I_CLEAR))) {
 		/* Not a new inode, let's update its attributes from @body */
+	        M0_LOG(M0_DEBUG, "found inode (%p) "FID_F, inode, FID_P(fid));
 		err = m0t1fs_inode_update(inode, body);
 	}
 	if (err != 0)
@@ -447,7 +449,15 @@ M0_INTERNAL int m0t1fs_inode_layout_init(struct m0t1fs_inode *ci)
 
 	csb = M0T1FS_SB(ci->ci_inode.i_sb);
 
-	M0_ASSERT(ci->ci_layout_id != 0);
+        /* 
+         * Obf directory ".mero" is created (currently) on server in mkfs time.
+         * It has zero layout_id and should be handled by setting sb layout id.
+         *
+         * @todo: check for name or fid or whatever in order to filter out
+         * possible cases when not obf dir has zero layout id.
+         */
+        if (ci->ci_layout_id == 0)
+                ci->ci_layout_id = csb->csb_layout_id;
 	rc = m0t1fs_build_layout_instance(csb, ci->ci_layout_id,
 					  m0t1fs_inode_fid(ci), &linst);
 	if (rc == 0)
diff --git a/m0t1fs/linux_kernel/super.c b/m0t1fs/linux_kernel/super.c
index 2ad23e4..a0d02a2 100644
--- a/m0t1fs/linux_kernel/super.c
+++ b/m0t1fs/linux_kernel/super.c
@@ -285,8 +285,8 @@ static int mount_opts_validate(const struct mount_opts *mops)
 		return M0_ERR(-EINVAL, "Mandatory parameter is missing: "
 			       "profile");
 
-	if (!ergo(mops->mo_fid_start != 0, mops->mo_fid_start > 3))
-		return M0_ERR(-EINVAL, "fid_start must be greater than 3");
+	if (!ergo(mops->mo_fid_start != 0, mops->mo_fid_start > 4))
+		M0_RETERR(-EINVAL, "fid_start must be greater than 4");
 
 	return M0_RC(0);
 }
@@ -305,7 +305,7 @@ static int mount_opts_parse(char *options, struct mount_opts *dest)
 	M0_LOG(M0_INFO, "Mount options: `%s'", options);
 
 	M0_SET0(dest);
-	dest->mo_fid_start = 4;   /* Default value */
+	dest->mo_fid_start = 5;   /* Default value */
 	while ((op = strsep(&options, ",")) != NULL && *op != '\0') {
 		switch (match_token(op, m0t1fs_mntopt_tokens, args)) {
 		case M0T1FS_MNTOPT_CONFD:
diff --git a/mdstore/mdstore.c b/mdstore/mdstore.c
index c46d8cb..7c0df08 100644
--- a/mdstore/mdstore.c
+++ b/mdstore/mdstore.c
@@ -206,10 +206,10 @@ m0_mdstore_create_credit(struct m0_mdstore *md,
 }
 
 M0_INTERNAL int m0_mdstore_fcreate(struct m0_mdstore     *md,
-				  struct m0_fid         *pfid,
-				  struct m0_cob_attr    *attr,
-				  struct m0_cob        **out,
-				  struct m0_be_tx       *tx)
+				   struct m0_fid         *pfid,
+				   struct m0_cob_attr    *attr,
+				   struct m0_cob        **out,
+				   struct m0_be_tx       *tx)
 {
 	struct m0_cob         *cob;
 	struct m0_cob_nskey   *nskey;
@@ -222,6 +222,12 @@ M0_INTERNAL int m0_mdstore_fcreate(struct m0_mdstore     *md,
 	M0_ENTRY();
 	M0_ASSERT(pfid != NULL);
 
+        /* We don't allow normal fs things in obf directory. */
+        if (m0_fid_eq(pfid, &M0_COB_OBF_FID)) {
+                rc = -EINVAL;
+                goto out;
+        }
+
 	M0_SET0(&nsrec);
 	M0_SET0(&omgrec);
 
@@ -301,6 +307,12 @@ M0_INTERNAL int m0_mdstore_link(struct m0_mdstore       *md,
 	M0_ASSERT(pfid != NULL);
 	M0_ASSERT(cob != NULL);
 
+        /* We don't allow normal fs things in obf directory. */
+        if (m0_fid_eq(pfid, &M0_COB_OBF_FID)) {
+                rc = -EINVAL;
+                goto out;
+        }
+
 	time(&now);
 	M0_SET0(&nsrec);
 
@@ -403,6 +415,20 @@ M0_INTERNAL int m0_mdstore_unlink(struct m0_mdstore     *md,
 	M0_ASSERT(pfid != NULL);
 	M0_ASSERT(cob != NULL);
 
+        /* We don't allow normal fs things in obf directory. */
+        if (m0_fid_eq(pfid, &M0_COB_OBF_FID)) {
+                rc = -EINVAL;
+                goto out;
+        }
+
+        /* We don't allow to kill obf dir. */
+        if (m0_fid_eq(pfid, &M0_COB_SLASH_FID) &&
+            name->b_nob == strlen(M0_COB_OBF_NAME) &&
+            !strncmp((char *)name->b_addr, M0_COB_OBF_NAME, (int)name->b_nob)) {
+                rc = -EINVAL;
+                goto out;
+        }
+
 	M0_PRE(cob->co_nsrec.cnr_nlink > 0);
 
 	time(&now);
@@ -571,6 +597,12 @@ M0_INTERNAL int m0_mdstore_rename(struct m0_mdstore     *md,
 
 	time(&now);
 
+        /* We don't allow normal fs things in obf directory. */
+        if (m0_fid_eq(pfid_tgt, &M0_COB_OBF_FID) || m0_fid_eq(pfid_src, &M0_COB_OBF_FID)) {
+                rc = -EINVAL;
+                goto out;
+        }
+
 	/*
 	 * Let's kill existing target name.
 	 */
@@ -853,6 +885,9 @@ out:
 	return M0_RC(rc);
 }
 
+/**
+   Find cob by @fid and store its pointer to passed @cob.
+ */
 M0_INTERNAL int m0_mdstore_locate(struct m0_mdstore     *md,
 				  const struct m0_fid   *fid,
 				  struct m0_cob        **cob,
@@ -885,12 +920,25 @@ M0_INTERNAL int m0_mdstore_locate(struct m0_mdstore     *md,
 	return rc;
 }
 
+/**
+   Find cob by name and store its pointer to passed @cob.
+
+   In order to handle possible obf-like names like this:
+   (cat /mnt/mero/.mero/1:5), parent fid is checked and
+   special action is taken to extract fid components from
+   file name in obf case. Then m0_cob_locate() is used
+   to find cob by fid rather than by name.
+
+   @see m0_cob_domain_mkfs
+   @see m0_mdstore_locate
+ */
 M0_INTERNAL int m0_mdstore_lookup(struct m0_mdstore     *md,
 				  struct m0_fid         *pfid,
 				  struct m0_buf         *name,
 				  struct m0_cob        **cob)
 {
 	struct m0_cob_nskey *nskey;
+        struct m0_fid fid;
 	int flags;
 	int rc;
 
@@ -901,8 +949,22 @@ M0_INTERNAL int m0_mdstore_lookup(struct m0_mdstore     *md,
 	rc = m0_cob_nskey_make(&nskey, pfid, (char *)name->b_addr, name->b_nob);
 	if (rc != 0)
 		goto out;
-	flags = (M0_CA_NSKEY_FREE | M0_CA_FABREC | M0_CA_OMGREC);
-	rc = m0_cob_lookup(&md->md_dom, nskey, flags, cob);
+        /*
+          Check for obf case and use m0_cob_locate() to get cob by fid
+          extracted from name.
+         */
+        if (m0_fid_eq(pfid, &M0_COB_OBF_FID)) {
+                m0_fid_set(&fid, 0, 0);
+                sscanf((char *)name->b_addr, FID_F, FID_R(&fid));
+                if (!m0_fid_is_set(&fid)) {
+                        rc = -EINVAL;
+                        goto out;
+                }
+                rc = m0_mdstore_locate(md, &fid, cob, M0_MD_LOCATE_STORED);
+        } else {
+	        flags = (M0_CA_NSKEY_FREE | M0_CA_FABREC | M0_CA_OMGREC);
+	        rc = m0_cob_lookup(&md->md_dom, nskey, flags, cob);
+	}
 out:
 	return M0_RC(rc);
 }
diff --git a/rm/rm.c b/rm/rm.c
index 34f7b19..81bd491 100644
--- a/rm/rm.c
+++ b/rm/rm.c
@@ -355,12 +355,13 @@ M0_INTERNAL void m0_rm_resource_add(struct m0_rm_resource_type *rtype,
 	M0_PRE(res->r_ref == 0);
 	M0_PRE(m0_rm_resource_find(rtype, res) == NULL);
 	res->r_type = rtype;
-	res_tlink_init_at(res, &rtype->rt_resources);
-	m0_remotes_tlist_init(&res->r_remote);
+
+        res_tlink_init_at(res, &rtype->rt_resources);
+        m0_remotes_tlist_init(&res->r_remote);
+        M0_POST(res_tlist_contains(&rtype->rt_resources, res));
+        M0_CNT_INC(rtype->rt_nr_resources);
+        M0_POST(resource_type_invariant(rtype));
 	m0_rm_resource_bob_init(res);
-	M0_CNT_INC(rtype->rt_nr_resources);
-	M0_POST(res_tlist_contains(&rtype->rt_resources, res));
-	M0_POST(resource_type_invariant(rtype));
 	m0_mutex_unlock(&rtype->rt_lock);
 	M0_POST(res->r_type == rtype);
 	M0_LEAVE();
@@ -373,15 +374,16 @@ M0_INTERNAL void m0_rm_resource_del(struct m0_rm_resource *res)
 
 	M0_ENTRY("resource : %p", res);
 	m0_mutex_lock(&rtype->rt_lock);
-	M0_PRE(res_tlist_contains(&rtype->rt_resources, res));
-	M0_PRE(m0_remotes_tlist_is_empty(&res->r_remote));
-	M0_PRE(resource_type_invariant(rtype));
+        M0_PRE(res_tlist_contains(&rtype->rt_resources, res));
+        M0_PRE(m0_remotes_tlist_is_empty(&res->r_remote));
+        M0_PRE(resource_type_invariant(rtype));
+
+        res_tlink_del_fini(res);
 
-	res_tlink_del_fini(res);
-	M0_CNT_DEC(rtype->rt_nr_resources);
+        M0_CNT_DEC(rtype->rt_nr_resources);
+        M0_POST(!res_tlist_contains(&rtype->rt_resources, res));
+        M0_POST(resource_type_invariant(rtype));
 
-	M0_POST(resource_type_invariant(rtype));
-	M0_POST(!res_tlist_contains(&rtype->rt_resources, res));
 	m0_rm_resource_bob_fini(res);
 	m0_mutex_unlock(&rtype->rt_lock);
 	M0_LEAVE();
-- 
1.8.3.2

