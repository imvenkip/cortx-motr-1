From 0b1283bf551648453507395c79b8bd15ebe9151c Mon Sep 17 00:00:00 2001
From: Yuriy Umanets <yuriy_umanets@xyratex.com>
Date: Wed, 2 Apr 2014 17:29:06 +0400
Subject: [PATCH 10/13] - some more inspection fixes after second round of
 inspection

---
 cob/cob.c                                   | 17 -----------------
 cob/cob.h                                   |  9 ---------
 cob/ut/cob.c                                |  4 ++--
 fid/fid.c                                   | 23 +++++++++++++++++++++++
 fid/fid.h                                   | 16 ++++++++++++++--
 ioservice/io_service.c                      |  2 +-
 ioservice/ut/bulkio_common.c                |  2 +-
 ioservice/ut/bulkio_ut.c                    |  2 +-
 m0t1fs/linux_kernel/inode.c                 | 13 -------------
 m0t1fs/linux_kernel/m0t1fs.h                |  8 ++++++--
 m0t1fs/linux_kernel/st/m0t1fs_client_inc.sh | 17 +++++++++--------
 m0t1fs/linux_kernel/super.c                 | 26 ++++++++++++++++----------
 mdservice/md_foms.c                         |  7 ++++++-
 mdstore/mdstore.c                           | 20 ++++++++------------
 mero/setup.c                                |  2 +-
 reqh/ut/reqh_fom_ut.c                       |  2 +-
 sns/cm/iter.c                               |  2 +-
 sns/cm/repair/ut/storage.c                  |  4 ++--
 ut/ut_rpc_machine.c                         |  2 +-
 19 files changed, 93 insertions(+), 85 deletions(-)

diff --git a/cob/cob.c b/cob/cob.c
index a09a435..021ae68 100644
--- a/cob/cob.c
+++ b/cob/cob.c
@@ -78,23 +78,6 @@ struct m0_cob_tables {
 	{ .tree=&dom->cd_fileattr_omg,   .ops=&cob_omg_ops, .prefix="fo" }, \
 	{ .tree=&dom->cd_fileattr_ea,	 .ops=&cob_ea_ops,  .prefix="ea" }, \
 }
-/**
-   Storage virtual root. All cobs are placed in it.
- */
-const struct m0_fid M0_COB_ROOT_FID = {
-	.f_container = 1ULL,
-	.f_key       = 1ULL
-};
-
-/**
-   Metadata hierarchry root fid.
-*/
-const struct m0_fid M0_COB_SLASH_FID = {
-	.f_container = 1ULL,
-	.f_key       = 2ULL
-};
-
-const char M0_COB_ROOT_NAME[] = "ROOT";
 
 struct m0_addb_ctx m0_cob_mod_ctx;
 
diff --git a/cob/cob.h b/cob/cob.h
index 66cc795..beab1ea 100644
--- a/cob/cob.h
+++ b/cob/cob.h
@@ -219,15 +219,6 @@ struct m0_cob_id;
 struct m0_cob_domain;
 struct m0_cob_domain_id;
 
-/* Namespace name for root cob (not exposed to user) */
-extern const char M0_COB_ROOT_NAME[];
-
-/* Grobal cob root fid. */
-extern const struct m0_fid M0_COB_ROOT_FID;
-
-/* Hierarchy root fid (exposed to user). */
-extern const struct m0_fid M0_COB_SLASH_FID;
-
 /**
    Unique cob domain identifier.
 
diff --git a/cob/ut/cob.c b/cob/ut/cob.c
index 9c77816..c30df77 100644
--- a/cob/ut/cob.c
+++ b/cob/ut/cob.c
@@ -120,7 +120,7 @@ static void test_mkfs(void)
 	ut_tx_open(tx, &accum);
 
 	/* Create root and other structures */
-	rc = m0_cob_domain_mkfs(&dom, &M0_COB_SLASH_FID, tx);
+	rc = m0_cob_domain_mkfs(&dom, &M0_MDSERVICE_SLASH_FID, tx);
 	M0_UT_ASSERT(rc == 0);
 
 	rc = _locate(1, 2); /* slash */
@@ -395,7 +395,7 @@ static int ub_init(const char *opts M0_UNUSED)
 
 	/* Create root and other structures */
 	rc = m0_db_tx_init(&tx, &db, 0) ?:
-		m0_cob_domain_mkfs(&dom, &M0_COB_SLASH_FID, &tx);
+		m0_cob_domain_mkfs(&dom, &M0_MDSERVICE_SLASH_FID, &tx);
 	M0_ASSERT(rc == 0);
 	m0_db_tx_commit(&tx);
 
diff --git a/fid/fid.c b/fid/fid.c
index e399447..33110ef 100644
--- a/fid/fid.c
+++ b/fid/fid.c
@@ -84,6 +84,16 @@ M0_INTERNAL const struct m0_fid_type *m0_fid_type_getname(const char *name)
 	return NULL;
 }
 
+/**
+   Cob storage root. Not exposed to user.
+ */
+const struct m0_fid M0_COB_ROOT_FID = {
+	.f_container = 1ULL,
+	.f_key       = 1ULL
+};
+
+const char M0_COB_ROOT_NAME[] = "ROOT";
+
 const struct m0_fid M0_DOT_MERO_FID = {
 	.f_container = 1ULL,
 	.f_key       = 4ULL
@@ -98,6 +108,19 @@ const struct m0_fid M0_DOT_MERO_FID_FID = {
 
 const char M0_DOT_MERO_FID_NAME[] = "fid";
 
+/**
+   Namespace root fid. Exposed to user.
+*/
+const struct m0_fid M0_MDSERVICE_SLASH_FID = {
+	.f_container = 1ULL,
+	.f_key       = (1ULL << 16) - 1
+};
+
+const struct m0_fid M0_MDSERVICE_START_FID = {
+	.f_container = 1ULL,
+	.f_key       = (1ULL << 16)
+};
+
 M0_INTERNAL bool m0_fid_is_valid(const struct m0_fid *fid)
 {
 	const struct m0_fid_type *ft = m0_fid_type_getfid(fid);
diff --git a/fid/fid.h b/fid/fid.h
index 430c99c..d15de23 100644
--- a/fid/fid.h
+++ b/fid/fid.h
@@ -100,18 +100,30 @@ M0_INTERNAL const struct m0_fid_type *
 m0_fid_type_getfid(const struct m0_fid *fid);
 M0_INTERNAL const struct m0_fid_type *m0_fid_type_getname(const char *name);
 
+/* Namespace name for root cob (not exposed to user) */
+extern const char M0_COB_ROOT_NAME[];
+
+/* Grobal cob root fid. */
+extern const struct m0_fid M0_COB_ROOT_FID;
+
 /* Namespace name for virtual .mero directory */
 extern const char M0_DOT_MERO_NAME[];
 
-/* Virtual .mero directory fid. */
+/* .mero directory fid. */
 extern const struct m0_fid M0_DOT_MERO_FID;
 
 /* Namespace name for virtual .mero/fid directory */
 extern const char M0_DOT_MERO_FID_NAME[];
 
-/* Virtual .mero/fid directory fid. */
+/* .mero/fid directory fid. */
 extern const struct m0_fid M0_DOT_MERO_FID_FID;
 
+/* Hierarchy root fid (exposed to user). */
+extern const struct m0_fid M0_MDSERVICE_SLASH_FID;
+
+/* First fid that is allowed to be used by client for normal files and dirs. */
+extern const struct m0_fid M0_MDSERVICE_START_FID;
+
 /** @} end of fid group */
 #endif /* __MERO_FID_FID_H__ */
 
diff --git a/ioservice/io_service.c b/ioservice/io_service.c
index bcb678d..eba9aa5 100644
--- a/ioservice/io_service.c
+++ b/ioservice/io_service.c
@@ -553,7 +553,7 @@ M0_INTERNAL int m0_ios_cdom_get(struct m0_reqh *reqh,
 		m0_cob_tx_credit(cdom, M0_COB_OP_DOMAIN_MKFS, &tx.tx_betx_cred);
 		rc = m0_dtx_open_sync(&tx);
 		if (rc == 0) {
-			rc = m0_cob_domain_mkfs(cdom, &M0_COB_SLASH_FID,
+			rc = m0_cob_domain_mkfs(cdom, &M0_MDSERVICE_SLASH_FID,
 						&tx.tx_betx);
 			m0_dtx_done_sync(&tx);
 		}
diff --git a/ioservice/ut/bulkio_common.c b/ioservice/ut/bulkio_common.c
index 059d7a3..e0c1f04 100644
--- a/ioservice/ut/bulkio_common.c
+++ b/ioservice/ut/bulkio_common.c
@@ -163,7 +163,7 @@ void bulkio_server_stop(struct m0_rpc_server_ctx *sctx)
 static void io_fids_init(struct bulkio_params *bp)
 {
 	int i;
-	struct m0_fid gfid = M0_COB_SLASH_FID;
+	struct m0_fid gfid = M0_MDSERVICE_SLASH_FID;
 
 	M0_ASSERT(bp != NULL);
 	/* Populates fids. */
diff --git a/ioservice/ut/bulkio_ut.c b/ioservice/ut/bulkio_ut.c
index 6d0930d..b50a9a0 100644
--- a/ioservice/ut/bulkio_ut.c
+++ b/ioservice/ut/bulkio_ut.c
@@ -1085,7 +1085,7 @@ static int bulkio_stob_create_fom_tick(struct m0_fom *fom)
 	}
 
 	cc.fco_stobid = stobid;
-	cc.fco_gfid   = M0_COB_SLASH_FID;
+	cc.fco_gfid   = M0_MDSERVICE_SLASH_FID;
 	cc.fco_cfid   = rwfop->crw_gfid;
 	cc.fco_cob_idx = (uint32_t) rwfop->crw_gfid.f_key;
 
diff --git a/m0t1fs/linux_kernel/inode.c b/m0t1fs/linux_kernel/inode.c
index 2298416..6c6e154 100644
--- a/m0t1fs/linux_kernel/inode.c
+++ b/m0t1fs/linux_kernel/inode.c
@@ -408,11 +408,9 @@ M0_INTERNAL struct inode *m0t1fs_iget(struct super_block *sb,
 	}
 	if ((inode->i_state & I_NEW) != 0) {
 		/* New inode, set its fields from @body */
-	        M0_LOG(M0_DEBUG, "new inode (%p) "FID_F, inode, FID_P(fid));
 		err = m0t1fs_inode_read(inode, body);
 	} else if (!(inode->i_state & (I_FREEING | I_CLEAR))) {
 		/* Not a new inode, let's update its attributes from @body */
-	        M0_LOG(M0_DEBUG, "found inode (%p) "FID_F, inode, FID_P(fid));
 		err = m0t1fs_inode_update(inode, body);
 	}
 	if (err != 0)
@@ -468,17 +466,6 @@ M0_INTERNAL int m0t1fs_inode_layout_init(struct m0t1fs_inode *ci)
 
 	csb = M0T1FS_SB(ci->ci_inode.i_sb);
 
-        /*
-         * Obf (open by fid) directory ".mero" is created (currently) on server
-         * in mkfs time. It has zero layout_id and should be handled by setting
-         * sb layout id.
-         *
-         * @todo: check for name or fid or whatever in order to filter out
-         * possible cases when not obf dir has zero layout id.
-         */
-        if (ci->ci_layout_id == 0)
-                ci->ci_layout_id = csb->csb_layout_id;
-
 	rc = m0t1fs_build_layout_instance(csb, ci->ci_layout_id,
 					  m0t1fs_inode_fid(ci), &linst);
 	if (rc == 0)
diff --git a/m0t1fs/linux_kernel/m0t1fs.h b/m0t1fs/linux_kernel/m0t1fs.h
index c3a8de0..f423d77 100644
--- a/m0t1fs/linux_kernel/m0t1fs.h
+++ b/m0t1fs/linux_kernel/m0t1fs.h
@@ -87,8 +87,12 @@
       Client allocates fid for a file during its creation. It assigns
       <0, $fid_start> for first file, <0, $fid_start+1> for second
       and so on.
-      mdstore uses constant fid - M0_COB_SLASH_FID <1, 3> - for root.
-      Hence fid_start must be greater than 5.
+      mdstore uses constant fid - M0_MDSERVICE_SLASH_FID <1, 1> - for root.
+      Couple more are reserved for sessions and other things.
+
+      One more - for .mero dir <1, 4> and one more for .mero/fid dir <1, 5>
+      Hence fid_start must be greater than 5. See M0_DOT_MERO_FID and
+      M0_DOT_MERO_FID_FID
 
    'device' argument of mount command is ignored.
 
diff --git a/m0t1fs/linux_kernel/st/m0t1fs_client_inc.sh b/m0t1fs/linux_kernel/st/m0t1fs_client_inc.sh
index bbf8456..28a4625 100644
--- a/m0t1fs/linux_kernel/st/m0t1fs_client_inc.sh
+++ b/m0t1fs/linux_kernel/st/m0t1fs_client_inc.sh
@@ -368,18 +368,18 @@ multi_client_test()
 	local mount_dir_2=${MERO_M0T1FS_MOUNT_DIR}bb
 	local mount_dir_3=${MERO_M0T1FS_MOUNT_DIR}cc
 
-	mount_m0t1fs ${mount_dir_1} 4 $NR_DATA $NR_PARITY $POOL_WIDTH "fid_start=6" &>> $MERO_TEST_LOGFILE || {
+	mount_m0t1fs ${mount_dir_1} 4 $NR_DATA $NR_PARITY $POOL_WIDTH "fid_start=65536" &>> $MERO_TEST_LOGFILE || {
 		cat $MERO_TEST_LOGFILE
 		return 1
 	}
 	df
-	mount_m0t1fs ${mount_dir_2} 4 $NR_DATA $NR_PARITY $POOL_WIDTH "fid_start=1006" &>> $MERO_TEST_LOGFILE || {
+	mount_m0t1fs ${mount_dir_2} 4 $NR_DATA $NR_PARITY $POOL_WIDTH "fid_start=66536" &>> $MERO_TEST_LOGFILE || {
 		cat $MERO_TEST_LOGFILE
 		unmount_m0t1fs ${mount_dir_1} &>> $MERO_TEST_LOGFILE
 		return 1
 	}
 	df
-	mount_m0t1fs ${mount_dir_3} 4 $NR_DATA $NR_PARITY $POOL_WIDTH "fid_start=2006" &>> $MERO_TEST_LOGFILE || {
+	mount_m0t1fs ${mount_dir_3} 4 $NR_DATA $NR_PARITY $POOL_WIDTH "fid_start=67536" &>> $MERO_TEST_LOGFILE || {
 		cat $MERO_TEST_LOGFILE
 		unmount_m0t1fs ${mount_dir_1} &>> $MERO_TEST_LOGFILE
 		unmount_m0t1fs ${mount_dir_2} &>> $MERO_TEST_LOGFILE
@@ -409,15 +409,15 @@ multi_client_test()
 	unmount_m0t1fs ${mount_dir_2} &>> $MERO_TEST_LOGFILE
 	unmount_m0t1fs ${mount_dir_3} &>> $MERO_TEST_LOGFILE
 	echo "First round done."
-	mount_m0t1fs ${mount_dir_1} 4 $NR_DATA $NR_PARITY $POOL_WIDTH "fid_start=6" &>> $MERO_TEST_LOGFILE || {
+	mount_m0t1fs ${mount_dir_1} 4 $NR_DATA $NR_PARITY $POOL_WIDTH "fid_start=65536" &>> $MERO_TEST_LOGFILE || {
 		cat $MERO_TEST_LOGFILE
 		return 1
 	}
-	mount_m0t1fs ${mount_dir_2} 4 $NR_DATA $NR_PARITY $POOL_WIDTH "fid_start=1006" &>> $MERO_TEST_LOGFILE || {
+	mount_m0t1fs ${mount_dir_2} 4 $NR_DATA $NR_PARITY $POOL_WIDTH "fid_start=66536" &>> $MERO_TEST_LOGFILE || {
 		cat $MERO_TEST_LOGFILE
 		return 1
 	}
-	mount_m0t1fs ${mount_dir_3} 4 $NR_DATA $NR_PARITY $POOL_WIDTH "fid_start=2006" &>> $MERO_TEST_LOGFILE || {
+	mount_m0t1fs ${mount_dir_3} 4 $NR_DATA $NR_PARITY $POOL_WIDTH "fid_start=67536" &>> $MERO_TEST_LOGFILE || {
 		cat $MERO_TEST_LOGFILE
 		return 1
 	}
@@ -475,8 +475,9 @@ obf_test()
         stat $MERO_M0T1FS_MOUNT_DIR/.mero/fid || return 1
         ls -la $MERO_M0T1FS_MOUNT_DIR/.mero/fid || return 1
         touch $MERO_M0T1FS_MOUNT_DIR/file0 || return 1
-        stat $MERO_M0T1FS_MOUNT_DIR/.mero/fid/0:6 || return 1
-        ls -la $MERO_M0T1FS_MOUNT_DIR/.mero/fid/0:6 || return 1
+        # Though start_fid=65536, obf access pattern uses hex notation
+        stat $MERO_M0T1FS_MOUNT_DIR/.mero/fid/0:10000 || return 1
+        ls -la $MERO_M0T1FS_MOUNT_DIR/.mero/fid/0:10000 || return 1
 
         return 0
 }
diff --git a/m0t1fs/linux_kernel/super.c b/m0t1fs/linux_kernel/super.c
index 599307c..04c4734 100644
--- a/m0t1fs/linux_kernel/super.c
+++ b/m0t1fs/linux_kernel/super.c
@@ -285,8 +285,8 @@ static int mount_opts_validate(const struct mount_opts *mops)
 		return M0_ERR(-EINVAL, "Mandatory parameter is missing: "
 			       "profile");
 
-	if (!ergo(mops->mo_fid_start != 0, mops->mo_fid_start > 5))
-		return M0_ERR(-EINVAL, "fid_start must be greater than 5");
+	if (!ergo(mops->mo_fid_start != 0, mops->mo_fid_start > M0_MDSERVICE_START_FID.f_key - 1))
+		return M0_ERR(-EINVAL, "fid_start must be greater than %llu", M0_MDSERVICE_START_FID.f_key - 1);
 
 	return M0_RC(0);
 }
@@ -304,7 +304,7 @@ static int mount_opts_parse(char *options, struct mount_opts *dest)
 
 	M0_LOG(M0_INFO, "Mount options: `%s'", options);
 
-	*dest = (struct mount_opts){ .mo_fid_start = 6 /* default value */ };
+	*dest = (struct mount_opts){ .mo_fid_start = M0_MDSERVICE_START_FID.f_key /* default value */ };
 
 	while ((op = strsep(&options, ",")) != NULL && *op != '\0') {
 		switch (match_token(op, m0t1fs_mntopt_tokens, args)) {
@@ -1432,20 +1432,24 @@ static void m0t1fs_teardown(struct m0t1fs_sb *csb)
 	m0t1fs_net_fini(csb);
 }
 
+static void m0t1fs_dput(struct dentry *dentry)
+{
+        dentry->d_inode->i_nlink = 0;
+        d_delete(dentry);
+        dput(dentry);
+}
+
 static void m0t1fs_obf_dealloc(struct m0t1fs_sb *csb) {
 	M0_ENTRY();
+
         M0_PRE(csb != NULL);
 
 	if (csb->csb_fid_dentry != NULL) {
-                csb->csb_fid_dentry->d_inode->i_nlink = 0;
-                d_delete(csb->csb_fid_dentry);
-                dput(csb->csb_fid_dentry);
+	        m0t1fs_dput(csb->csb_fid_dentry);
                 csb->csb_fid_dentry = NULL;
         }
 	if (csb->csb_mero_dentry != NULL) {
-                csb->csb_mero_dentry->d_inode->i_nlink = 0;
-                d_delete(csb->csb_mero_dentry);
-                dput(csb->csb_mero_dentry);
+	        m0t1fs_dput(csb->csb_mero_dentry);
                 csb->csb_mero_dentry = NULL;
         }
 
@@ -1466,11 +1470,13 @@ static int m0t1fs_obf_alloc(struct super_block *sb)
         body->b_atime = body->b_ctime = body->b_mtime = m0_time_seconds(m0_time_now());
         body->b_valid = (M0_COB_MTIME | M0_COB_CTIME | M0_COB_CTIME |
 	                 M0_COB_UID | M0_COB_GID | M0_COB_BLOCKS |
-	                 M0_COB_SIZE | M0_COB_NLINK | M0_COB_MODE);
+	                 M0_COB_SIZE | M0_COB_NLINK | M0_COB_MODE |
+	                 M0_COB_LID);
         body->b_blocks = 16;
         body->b_size = 4096;
         body->b_blksize = 4096;
 	body->b_nlink = 2;
+	body->b_lid = csb->csb_layout_id;
         body->b_mode = (S_IFDIR | S_IRUSR | S_IWUSR | S_IXUSR | /* rwx for owner */
                         S_IRGRP | S_IXGRP |                     /* r-x for group */
                         S_IROTH | S_IXOTH);
diff --git a/mdservice/md_foms.c b/mdservice/md_foms.c
index d72781d..7c966b9 100644
--- a/mdservice/md_foms.c
+++ b/mdservice/md_foms.c
@@ -1314,7 +1314,12 @@ static int m0_md_req_path_get(struct m0_mdstore *mdstore,
 			      struct m0_fid *fid,
 			      struct m0_fop_str *str)
 {
-        /** This was solely used for replicator, which is not needed right now. */
+        /*
+         * This was solely used for replicator, which is not needed right now.
+         * The reason to disable this is that, m0_mdstore_path() tries to init
+         * fid's cob, which is not existing for .mero/fid directories. Later
+         * when we need this path, we will rework it different way.
+         */
 #if 0
 	int rc;
 
diff --git a/mdstore/mdstore.c b/mdstore/mdstore.c
index 2cd6c22..f569d89 100644
--- a/mdstore/mdstore.c
+++ b/mdstore/mdstore.c
@@ -223,7 +223,7 @@ M0_INTERNAL int m0_mdstore_fcreate(struct m0_mdstore     *md,
 	M0_ASSERT(pfid != NULL);
 
         /* We don't allow create in .mero and .mero/fid directory. */
-        if (m0_fid_eq(pfid, &M0_DOT_MERO_FID) || m0_fid_eq(pfid, &M0_DOT_MERO_FID_FID)) {
+        if (m0_fid_cmp(pfid, &M0_MDSERVICE_SLASH_FID) < 0) {
                 rc = -EOPNOTSUPP;
                 goto out;
         }
@@ -308,7 +308,7 @@ M0_INTERNAL int m0_mdstore_link(struct m0_mdstore       *md,
 	M0_ASSERT(cob != NULL);
 
         /* We don't allow link in .mero and .mero/fid directory. */
-        if (m0_fid_eq(pfid, &M0_DOT_MERO_FID) || m0_fid_eq(pfid, &M0_DOT_MERO_FID_FID)) {
+        if (m0_fid_cmp(pfid, &M0_MDSERVICE_SLASH_FID) < 0) {
                 rc = -EOPNOTSUPP;
                 goto out;
         }
@@ -416,13 +416,13 @@ M0_INTERNAL int m0_mdstore_unlink(struct m0_mdstore     *md,
 	M0_ASSERT(cob != NULL);
 
         /* We don't allow unlink in .mero and .mero/fid directories. */
-        if (m0_fid_eq(pfid, &M0_DOT_MERO_FID) || m0_fid_eq(pfid, &M0_DOT_MERO_FID_FID)) {
+        if (m0_fid_cmp(pfid, &M0_MDSERVICE_SLASH_FID) < 0) {
                 rc = -EOPNOTSUPP;
                 goto out;
         }
 
         /* We don't allow to kill .mero dir. */
-        if (m0_fid_eq(pfid, &M0_COB_SLASH_FID) &&
+        if (m0_fid_eq(pfid, &M0_MDSERVICE_SLASH_FID) &&
             name->b_nob == strlen(M0_DOT_MERO_NAME) &&
             !strncmp((char *)name->b_addr, M0_DOT_MERO_NAME, (int)name->b_nob)) {
                 rc = -EOPNOTSUPP;
@@ -598,14 +598,10 @@ M0_INTERNAL int m0_mdstore_rename(struct m0_mdstore     *md,
 	time(&now);
 
         /* We don't allow rename in/with .mero/fid directories. */
-        if (m0_fid_eq(pfid_tgt, &M0_DOT_MERO_FID) ||
-            m0_fid_eq(pfid_tgt, &M0_DOT_MERO_FID_FID) ||
-            m0_fid_eq(pfid_src, &M0_DOT_MERO_FID) ||
-            m0_fid_eq(pfid_src, &M0_DOT_MERO_FID_FID) ||
-            m0_fid_eq(m0_cob_fid(cob_tgt), &M0_DOT_MERO_FID) ||
-            m0_fid_eq(m0_cob_fid(cob_tgt), &M0_DOT_MERO_FID_FID) ||
-            m0_fid_eq(m0_cob_fid(cob_src), &M0_DOT_MERO_FID) ||
-            m0_fid_eq(m0_cob_fid(cob_src), &M0_DOT_MERO_FID_FID)) {
+        if (m0_fid_cmp(pfid_tgt, &M0_MDSERVICE_SLASH_FID) < 0 ||
+            m0_fid_cmp(pfid_src, &M0_MDSERVICE_SLASH_FID) < 0 ||
+            m0_fid_cmp(m0_cob_fid(cob_tgt), &M0_MDSERVICE_SLASH_FID) < 0 ||
+            m0_fid_cmp(m0_cob_fid(cob_src), &M0_MDSERVICE_SLASH_FID) < 0) {
                 rc = -EOPNOTSUPP;
                 goto out;
         }
diff --git a/mero/setup.c b/mero/setup.c
index 8bf3456..6b99e4b 100644
--- a/mero/setup.c
+++ b/mero/setup.c
@@ -1281,7 +1281,7 @@ static int cs_storage_prepare(struct m0_reqh_context *rctx)
 	m0_cob_tx_credit(dom, M0_COB_OP_DOMAIN_MKFS, &tx.tx_betx_cred);
 	rc = m0_dtx_open_sync(&tx);
 	if (rc == 0) {
-		rc = m0_cob_domain_mkfs(dom, &M0_COB_SLASH_FID, &tx.tx_betx);
+		rc = m0_cob_domain_mkfs(dom, &M0_MDSERVICE_SLASH_FID, &tx.tx_betx);
 		if (rc != 0)
 			m0_cob_domain_destroy(dom, grp);
 		m0_dtx_done_sync(&tx);
diff --git a/reqh/ut/reqh_fom_ut.c b/reqh/ut/reqh_fom_ut.c
index f0bcaed..971fb76 100644
--- a/reqh/ut/reqh_fom_ut.c
+++ b/reqh/ut/reqh_fom_ut.c
@@ -244,7 +244,7 @@ static int server_init(const char             *stob_path,
 	/* Create root session cob and other structures */
 	m0_cob_tx_credit(&srv_mdstore.md_dom, M0_COB_OP_DOMAIN_MKFS, &cred);
 	m0_ut_be_tx_begin(&tx, &ut_be, &cred);
-	rc = m0_cob_domain_mkfs(&srv_mdstore.md_dom, &M0_COB_SLASH_FID, &tx);
+	rc = m0_cob_domain_mkfs(&srv_mdstore.md_dom, &M0_MDSERVICE_SLASH_FID, &tx);
 	m0_ut_be_tx_end(&tx);
 	M0_UT_ASSERT(rc == 0);
 
diff --git a/sns/cm/iter.c b/sns/cm/iter.c
index 15599e7..2e1202e 100644
--- a/sns/cm/iter.c
+++ b/sns/cm/iter.c
@@ -392,7 +392,7 @@ static int iter_fid_next(struct m0_sns_cm_iter *it)
 	do {
 		rc = __fid_next(it, &fid_next);
 	} while (rc == 0 && (m0_fid_eq(&fid_next, &M0_COB_ROOT_FID)     ||
-			     m0_fid_eq(&fid_next, &M0_COB_SLASH_FID)));
+			     m0_fid_eq(&fid_next, &M0_MDSERVICE_SLASH_FID)));
 
 	if (rc == -ENOENT)
 		return M0_RC(-ENODATA);
diff --git a/sns/cm/repair/ut/storage.c b/sns/cm/repair/ut/storage.c
index 47f40d3..ac1259d 100644
--- a/sns/cm/repair/ut/storage.c
+++ b/sns/cm/repair/ut/storage.c
@@ -214,7 +214,7 @@ void write_post(void)
 		   &w_sag, 'e', &dummy_cp_fom_ops, reqh, 0, false, NULL);
 	w_sns_cp.sc_base.c_ops = &write_cp_dummy_ops;
 	w_sns_cp.sc_sid = sid;
-	w_sns_cp.sc_cobfid = M0_COB_SLASH_FID;
+	w_sns_cp.sc_cobfid = M0_MDSERVICE_SLASH_FID;
 	w_sag.sag_base.cag_cp_local_nr = 1;
 	w_sag.sag_fnr = 1;
 
@@ -288,7 +288,7 @@ static void read_post(void)
 	r_sag.sag_base.cag_cp_local_nr = 1;
 	r_sag.sag_fnr = 1;
 	r_sns_cp.sc_sid = sid;
-	r_sns_cp.sc_cobfid = M0_COB_SLASH_FID;
+	r_sns_cp.sc_cobfid = M0_MDSERVICE_SLASH_FID;
 	m0_fom_queue(&r_sns_cp.sc_base.c_fom, reqh);
 
         /* Wait till ast gets posted. */
diff --git a/ut/ut_rpc_machine.c b/ut/ut_rpc_machine.c
index 75b336f..7c9cf25 100644
--- a/ut/ut_rpc_machine.c
+++ b/ut/ut_rpc_machine.c
@@ -96,7 +96,7 @@ M0_INTERNAL void m0_ut_rpc_mach_init_and_add(struct m0_ut_rpc_mach_ctx *ctx)
 
 	m0_cob_tx_credit(&ctx->rmc_mdstore.md_dom, M0_COB_OP_DOMAIN_MKFS, &cred);
 	m0_ut_be_tx_begin(&tx, &ctx->rmc_ut_be, &cred);
-	rc = m0_cob_domain_mkfs(&ctx->rmc_mdstore.md_dom, &M0_COB_SLASH_FID,
+	rc = m0_cob_domain_mkfs(&ctx->rmc_mdstore.md_dom, &M0_MDSERVICE_SLASH_FID,
 				&tx);
 	m0_ut_be_tx_end(&tx);
 	M0_ASSERT(rc == 0);
-- 
1.8.3.2

