From ba622de07c743a4a725bf06143a86ee6ffc5c6b8 Mon Sep 17 00:00:00 2001
From: Yuriy Umanets <yuriy_umanets@xyratex.com>
Date: Tue, 1 Apr 2014 21:07:52 +0400
Subject: [PATCH 04/13] - added .mero/fid support

---
 fid/fid.c                    | 14 ++++++---
 fid/fid.h                    | 14 ++++++---
 m0t1fs/linux_kernel/dir.c    | 21 +++++++++++--
 m0t1fs/linux_kernel/inode.c  | 11 +++++--
 m0t1fs/linux_kernel/m0t1fs.h | 14 ++++++---
 m0t1fs/linux_kernel/super.c  | 75 +++++++++++++++++++++++++++++++-------------
 mdstore/mdstore.c            | 34 +++++++++++---------
 7 files changed, 127 insertions(+), 56 deletions(-)

diff --git a/fid/fid.c b/fid/fid.c
index 85bfae1..7897936 100644
--- a/fid/fid.c
+++ b/fid/fid.c
@@ -84,15 +84,19 @@ M0_INTERNAL const struct m0_fid_type *m0_fid_type_getname(const char *name)
 	return NULL;
 }
 
-/**
-   Obf dir fid.
-*/
-const struct m0_fid M0_COB_OBF_FID = {
+const struct m0_fid M0_VIRT_MERO_FID = {
 	.f_container = 1ULL,
 	.f_key       = 4ULL
 };
 
-const char M0_COB_OBF_NAME[] = ".mero";
+const char M0_VIRT_MERO_NAME[] = ".mero";
+
+const struct m0_fid M0_VIRT_OBF_FID = {
+	.f_container = 1ULL,
+	.f_key       = 5ULL
+};
+
+const char M0_VIRT_OBF_NAME[] = "fid";
 
 M0_INTERNAL bool m0_fid_is_valid(const struct m0_fid *fid)
 {
diff --git a/fid/fid.h b/fid/fid.h
index 9b33b21..6f9dc74 100644
--- a/fid/fid.h
+++ b/fid/fid.h
@@ -100,11 +100,17 @@ M0_INTERNAL const struct m0_fid_type *
 m0_fid_type_getfid(const struct m0_fid *fid);
 M0_INTERNAL const struct m0_fid_type *m0_fid_type_getname(const char *name);
 
-/* Namespace name for obf cob */
-extern const char M0_COB_OBF_NAME[];
+/* Namespace name for virtual .mero directory */
+extern const char M0_VIRT_MERO_NAME[];
 
-/* Obf fid. */
-extern const struct m0_fid M0_COB_OBF_FID;
+/* Virtual .mero directory fid. */
+extern const struct m0_fid M0_VIRT_MERO_FID;
+
+/* Namespace name for virtual .mero/fid directory */
+extern const char M0_VIRT_OBF_NAME[];
+
+/* Virtual .mero/fid directory fid. */
+extern const struct m0_fid M0_VIRT_OBF_FID;
 
 /** @} end of fid group */
 #endif /* __MERO_FID_FID_H__ */
diff --git a/m0t1fs/linux_kernel/dir.c b/m0t1fs/linux_kernel/dir.c
index 5831581..c6d0c81 100644
--- a/m0t1fs/linux_kernel/dir.c
+++ b/m0t1fs/linux_kernel/dir.c
@@ -383,6 +383,7 @@ static struct dentry *m0t1fs_lookup(struct inode     *dir,
 	struct inode             *inode = NULL;
 	struct m0_fop_lookup_rep *rep = NULL;
 	struct m0t1fs_mdop        mo;
+	struct m0_fid             fid;
 	int rc;
 
 
@@ -400,6 +401,20 @@ static struct dentry *m0t1fs_lookup(struct inode     *dir,
 
 	m0t1fs_fs_lock(csb);
 
+        if (m0t1fs_inode_is_fid(&ci->ci_inode)) {
+	        rc = m0_fid_sscanf((char *)dentry->d_name.name, &fid);
+	        if (rc != 0) {
+			M0_LEAVE("ERROR: %d", rc);
+			m0t1fs_fs_unlock(csb);
+			return ERR_PTR(rc);
+	        }
+	        /**
+	           @todo: When multi-mdservice support is added,
+	           @fid will be used to figure out what mdservice
+	           lookup operation should be sent to.
+	        */
+	}
+
 	M0_SET0(&mo);
 	mo.mo_attr.ca_pfid = *m0t1fs_inode_fid(M0T1FS_I(dir));
 	m0_buf_init(&mo.mo_attr.ca_name, (char *)dentry->d_name.name,
@@ -490,7 +505,7 @@ static int m0t1fs_readdir(struct file *f,
 	csb    = M0T1FS_SB(dir->i_sb);
 	i      = f->f_pos;
 
-	if (m0t1fs_inode_is_obf(&ci->ci_inode))
+	if (m0t1fs_inode_is_mero(&ci->ci_inode) || m0t1fs_inode_is_fid(&ci->ci_inode))
 		return M0_RC(0);
 
 	fd = f->private_data;
@@ -740,7 +755,7 @@ M0_INTERNAL int m0t1fs_getattr(struct vfsmount *mnt, struct dentry *dentry,
 	m0t1fs_fs_lock(csb);
 
         /** Return cached attributes for obf dir. */
-	if (!m0t1fs_inode_is_obf(&ci->ci_inode)) {
+	if (!m0t1fs_inode_is_mero(&ci->ci_inode) && !m0t1fs_inode_is_fid(&ci->ci_inode)) {
 	        M0_SET0(&mo);
 	        mo.mo_attr.ca_tfid  = *m0t1fs_inode_fid(ci);
 
@@ -755,7 +770,7 @@ M0_INTERNAL int m0t1fs_getattr(struct vfsmount *mnt, struct dentry *dentry,
 		        goto out;
 		body = &getattr_rep->g_body;
         } else {
-		body = &csb->csb_obf_body;
+		body = &csb->csb_virt_body;
         }
 
 	/** Update inode fields with data from @getattr_rep or cached attrs. */
diff --git a/m0t1fs/linux_kernel/inode.c b/m0t1fs/linux_kernel/inode.c
index 9132f08..e463766 100644
--- a/m0t1fs/linux_kernel/inode.c
+++ b/m0t1fs/linux_kernel/inode.c
@@ -58,11 +58,18 @@ M0_INTERNAL bool m0t1fs_inode_is_root(const struct inode *inode)
 			 &M0T1FS_SB(inode->i_sb)->csb_root_fid);
 }
 
-M0_INTERNAL bool m0t1fs_inode_is_obf(const struct inode *inode)
+M0_INTERNAL bool m0t1fs_inode_is_mero(const struct inode *inode)
 {
 	struct m0t1fs_inode *ci = M0T1FS_I(inode);
 
-	return m0_fid_eq(m0t1fs_inode_fid(ci), &M0_COB_OBF_FID);
+	return m0_fid_eq(m0t1fs_inode_fid(ci), &M0_VIRT_MERO_FID);
+}
+
+M0_INTERNAL bool m0t1fs_inode_is_fid(const struct inode *inode)
+{
+	struct m0t1fs_inode *ci = M0T1FS_I(inode);
+
+	return m0_fid_eq(m0t1fs_inode_fid(ci), &M0_VIRT_OBF_FID);
 }
 
 static void init_once(void *foo)
diff --git a/m0t1fs/linux_kernel/m0t1fs.h b/m0t1fs/linux_kernel/m0t1fs.h
index 0adfea8..5b83686 100644
--- a/m0t1fs/linux_kernel/m0t1fs.h
+++ b/m0t1fs/linux_kernel/m0t1fs.h
@@ -559,11 +559,14 @@ struct m0t1fs_sb {
 	/** lnet tmid for client ep */
 	size_t                                  csb_tmid;
 
-        /** .mero virtual dir dentry */
-        struct dentry                          *csb_obf_dentry;
+        /** /.mero virtual dir dentry */
+        struct dentry                          *csb_mero_dentry;
 
-        /** .mero virtual dir attributes. */
-        struct m0_fop_cob                       csb_obf_body;
+        /** /.mero/fid virtual dir dentry */
+        struct dentry                          *csb_fid_dentry;
+
+        /** virtual dirs cached attributes */
+        struct m0_fop_cob                       csb_virt_body;
 };
 
 struct m0t1fs_filedata {
@@ -648,7 +651,8 @@ M0_INTERNAL int m0t1fs_inode_cache_init(void);
 M0_INTERNAL void m0t1fs_inode_cache_fini(void);
 
 M0_INTERNAL bool m0t1fs_inode_is_root(const struct inode *inode);
-M0_INTERNAL bool m0t1fs_inode_is_obf(const struct inode *inode);
+M0_INTERNAL bool m0t1fs_inode_is_mero(const struct inode *inode);
+M0_INTERNAL bool m0t1fs_inode_is_fid(const struct inode *inode);
 
 M0_INTERNAL struct inode *m0t1fs_root_iget(struct super_block *sb,
 					   struct m0_fid *root_fid);
diff --git a/m0t1fs/linux_kernel/super.c b/m0t1fs/linux_kernel/super.c
index 5ded570..d229462 100644
--- a/m0t1fs/linux_kernel/super.c
+++ b/m0t1fs/linux_kernel/super.c
@@ -285,8 +285,8 @@ static int mount_opts_validate(const struct mount_opts *mops)
 		return M0_ERR(-EINVAL, "Mandatory parameter is missing: "
 			       "profile");
 
-	if (!ergo(mops->mo_fid_start != 0, mops->mo_fid_start > 4))
-		return M0_ERR(-EINVAL, "fid_start must be greater than 4");
+	if (!ergo(mops->mo_fid_start != 0, mops->mo_fid_start > 5))
+		return M0_ERR(-EINVAL, "fid_start must be greater than 5");
 
 	return M0_RC(0);
 }
@@ -1431,12 +1431,35 @@ static void m0t1fs_teardown(struct m0t1fs_sb *csb)
 	m0t1fs_net_fini(csb);
 }
 
+static void m0t1fs_obf_dealloc(struct super_block *sb) {
+	struct m0t1fs_sb         *csb = M0T1FS_SB(sb);
+
+	M0_ENTRY();
+
+	if (csb->csb_fid_dentry != NULL) {
+                csb->csb_fid_dentry->d_inode->i_nlink = 0;
+                d_delete(csb->csb_fid_dentry);
+                dput(csb->csb_fid_dentry);
+                csb->csb_fid_dentry = NULL;
+        }
+	if (csb->csb_mero_dentry != NULL) {
+                csb->csb_mero_dentry->d_inode->i_nlink = 0;
+                d_delete(csb->csb_mero_dentry);
+                dput(csb->csb_mero_dentry);
+                csb->csb_mero_dentry = NULL;
+        }
+
+	M0_LEAVE();
+}
+
 static int m0t1fs_obf_alloc(struct super_block *sb)
 {
-        struct inode             *obf_inode;
-        struct dentry            *obf_dentry;
+        struct inode             *mero_inode;
+        struct dentry            *mero_dentry;
+        struct inode             *fid_inode;
+        struct dentry            *fid_dentry;
         struct m0t1fs_sb         *csb = M0T1FS_SB(sb);
-	struct m0_fop_cob        *body = &csb->csb_obf_body;
+	struct m0_fop_cob        *body = &csb->csb_virt_body;
 
         body->b_atime = body->b_ctime = body->b_mtime = m0_time_seconds(m0_time_now());
         body->b_valid = (M0_COB_MTIME | M0_COB_CTIME | M0_COB_CTIME |
@@ -1452,29 +1475,37 @@ static int m0t1fs_obf_alloc(struct super_block *sb)
 
 	M0_ENTRY();
 
-        obf_dentry = d_alloc_name(sb->s_root, M0_COB_OBF_NAME);
-        if (obf_dentry == NULL)
+        /* Init virtual /.mero directory */
+        mero_dentry = d_alloc_name(sb->s_root, M0_VIRT_MERO_NAME);
+        if (mero_dentry == NULL)
                 return M0_RC(-ENOMEM);
 
-        obf_inode = m0t1fs_iget(sb, &M0_COB_OBF_FID, body);
-        if (IS_ERR(obf_inode)) {
-                dput(obf_dentry);
-                return M0_RC((int)PTR_ERR(obf_inode));
+        mero_inode = m0t1fs_iget(sb, &M0_VIRT_MERO_FID, body);
+        if (IS_ERR(mero_inode)) {
+                dput(mero_dentry);
+                return M0_RC((int)PTR_ERR(mero_inode));
         }
 
-        d_add(obf_dentry, obf_inode);
-        csb->csb_obf_dentry = obf_dentry;
-	return M0_RC(0);
-}
+        d_add(mero_dentry, mero_inode);
+        csb->csb_mero_dentry = mero_dentry;
 
-static void m0t1fs_obf_dealloc(struct super_block *sb) {
-	struct m0t1fs_sb         *csb = M0T1FS_SB(sb);
+        /* Init virtual /.mero/fid directory */
+        fid_dentry = d_alloc_name(mero_dentry, M0_VIRT_OBF_NAME);
+        if (fid_dentry == NULL) {
+                m0t1fs_obf_dealloc(sb);
+                return M0_RC(-ENOMEM);
+        }
 
-	M0_ENTRY();
-        csb->csb_obf_dentry->d_inode->i_nlink = 0;
-        d_delete(csb->csb_obf_dentry);
-        dput(csb->csb_obf_dentry);
-	M0_LEAVE();
+        fid_inode = m0t1fs_iget(sb, &M0_VIRT_OBF_FID, body);
+        if (IS_ERR(fid_inode)) {
+                dput(fid_dentry);
+                m0t1fs_obf_dealloc(sb);
+                return M0_RC((int)PTR_ERR(fid_inode));
+        }
+
+        d_add(fid_dentry, fid_inode);
+        csb->csb_fid_dentry = fid_dentry;
+	return M0_RC(0);
 }
 
 static int m0t1fs_root_alloc(struct super_block *sb)
diff --git a/mdstore/mdstore.c b/mdstore/mdstore.c
index 3f38328..a5a166b 100644
--- a/mdstore/mdstore.c
+++ b/mdstore/mdstore.c
@@ -222,8 +222,8 @@ M0_INTERNAL int m0_mdstore_fcreate(struct m0_mdstore     *md,
 	M0_ENTRY();
 	M0_ASSERT(pfid != NULL);
 
-        /* We don't allow create in obf directory. */
-        if (m0_fid_eq(pfid, &M0_COB_OBF_FID)) {
+        /* We don't allow create in .mero and .mero/fid directory. */
+        if (m0_fid_eq(pfid, &M0_VIRT_MERO_FID) || m0_fid_eq(pfid, &M0_VIRT_OBF_FID)) {
                 rc = -EINVAL;
                 goto out;
         }
@@ -307,8 +307,8 @@ M0_INTERNAL int m0_mdstore_link(struct m0_mdstore       *md,
 	M0_ASSERT(pfid != NULL);
 	M0_ASSERT(cob != NULL);
 
-        /* We don't allow link in obf directory. */
-        if (m0_fid_eq(pfid, &M0_COB_OBF_FID)) {
+        /* We don't allow link in .mero and .mero/fid directory. */
+        if (m0_fid_eq(pfid, &M0_VIRT_MERO_FID) || m0_fid_eq(pfid, &M0_VIRT_OBF_FID)) {
                 rc = -EINVAL;
                 goto out;
         }
@@ -415,16 +415,16 @@ M0_INTERNAL int m0_mdstore_unlink(struct m0_mdstore     *md,
 	M0_ASSERT(pfid != NULL);
 	M0_ASSERT(cob != NULL);
 
-        /* We don't allow unlink in obf directory. */
-        if (m0_fid_eq(pfid, &M0_COB_OBF_FID)) {
+        /* We don't allow unlink in .mero and .mero/fid directories. */
+        if (m0_fid_eq(pfid, &M0_VIRT_MERO_FID) || m0_fid_eq(pfid, &M0_VIRT_OBF_FID)) {
                 rc = -EINVAL;
                 goto out;
         }
 
-        /* We don't allow to kill obf dir. */
+        /* We don't allow to kill .mero dir. */
         if (m0_fid_eq(pfid, &M0_COB_SLASH_FID) &&
-            name->b_nob == strlen(M0_COB_OBF_NAME) &&
-            !strncmp((char *)name->b_addr, M0_COB_OBF_NAME, (int)name->b_nob)) {
+            name->b_nob == strlen(M0_VIRT_MERO_NAME) &&
+            !strncmp((char *)name->b_addr, M0_VIRT_MERO_NAME, (int)name->b_nob)) {
                 rc = -EINVAL;
                 goto out;
         }
@@ -597,11 +597,15 @@ M0_INTERNAL int m0_mdstore_rename(struct m0_mdstore     *md,
 
 	time(&now);
 
-        /* We don't allow rename in/with obf directory. */
-        if (m0_fid_eq(pfid_tgt, &M0_COB_OBF_FID) ||
-            m0_fid_eq(pfid_src, &M0_COB_OBF_FID) ||
-            m0_fid_eq(m0_cob_fid(cob_tgt), &M0_COB_OBF_FID) ||
-            m0_fid_eq(m0_cob_fid(cob_src), &M0_COB_OBF_FID)) {
+        /* We don't allow rename in/with .mero/fid directories. */
+        if (m0_fid_eq(pfid_tgt, &M0_VIRT_MERO_FID) ||
+            m0_fid_eq(pfid_tgt, &M0_VIRT_OBF_FID) ||
+            m0_fid_eq(pfid_src, &M0_VIRT_MERO_FID) ||
+            m0_fid_eq(pfid_src, &M0_VIRT_OBF_FID) ||
+            m0_fid_eq(m0_cob_fid(cob_tgt), &M0_VIRT_MERO_FID) ||
+            m0_fid_eq(m0_cob_fid(cob_tgt), &M0_VIRT_OBF_FID) ||
+            m0_fid_eq(m0_cob_fid(cob_src), &M0_VIRT_MERO_FID) ||
+            m0_fid_eq(m0_cob_fid(cob_src), &M0_VIRT_OBF_FID)) {
                 rc = -EINVAL;
                 goto out;
         }
@@ -953,7 +957,7 @@ M0_INTERNAL int m0_mdstore_lookup(struct m0_mdstore     *md,
           Check for obf case and use m0_cob_locate() to get cob by fid
           extracted from name.
          */
-        if (m0_fid_eq(pfid, &M0_COB_OBF_FID)) {
+        if (m0_fid_eq(pfid, &M0_VIRT_OBF_FID)) {
                 rc = m0_fid_sscanf((char *)name->b_addr, &fid);
                 if (rc != 0)
                         goto out;
-- 
1.8.3.2

