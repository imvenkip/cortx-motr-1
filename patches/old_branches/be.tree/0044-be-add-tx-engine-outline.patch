From 1dbd05039c7107fc9b0a208d4c46950189b7d75a Mon Sep 17 00:00:00 2001
From: Nikita Danilov <nikita_danilov@xyratex.com>
Date: Wed, 29 May 2013 16:53:33 +0300
Subject: [PATCH 044/290] be: add tx engine outline.

---
 be/tx.c | 304 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-
 be/tx.h | 121 +++++++++++++++++++++++---
 2 files changed, 411 insertions(+), 14 deletions(-)

diff --git a/be/tx.c b/be/tx.c
index e6fd384..03fe134 100644
--- a/be/tx.c
+++ b/be/tx.c
@@ -20,14 +20,314 @@
 
 
 /**
- * @addtogroup XXX
+ * @addtogroup be
  *
  * @{
  */
 
+#include "lib/misc.h"          /* m0_forall, M0_SET0 */
+#include "lib/cdefs.h"         /* ARRAY_SIZE */
+#include "lib/memory.h"
 
+#include "be/be.h"
+#include "be/tx.h"
 
-/** @} end of XXX group */
+struct m0_be_txgroup_desc {
+	uint64_t tgd_size;
+	uint64_t tgd_tx_nr;
+};
+
+struct m0_be_txgroup {
+	struct m0_tlink           tg_tx;
+	m0_bindex_t               tg_log_loc;
+	struct m0_be_txgroup_desc tg_desc;
+};
+
+struct m0_be_reg_d {
+	uint64_t rd_seg_id;
+	uint64_t rd_offset;
+	uint64_t rd_size;
+};
+
+static const struct m0_sm_conf tx_sm_conf;
+
+static enum m0_be_tx_state tx_state_get(const struct m0_be_tx *tx);
+static void                tx_state_set(struct m0_be_tx *tx,
+					enum m0_be_tx_state state);
+static m0_be_tx_engine    *tx_engine   (const struct m0_be_tx *tx);
+
+static void        tx_open_tail        (struct m0_be_tx *tx);
+static void        tx_fail             (struct m0_be_tx *tx, int errno);
+static void        tx_link             (const struct m0_be_tx *tx);
+static m0_bindex_t tx_log_loc          (const struct m0_be_tx *tx);
+static m0_bcount_t tx_log_size         (const struct m0_be_tx *tx,
+					const struct m0_be_tx_credit *cr,
+					unsigned group_no);
+static m0_bcount_t tx_prepareg_log_size(const struct m0_be_tx *tx)
+static m0_bcount_t tx_group_header_size(m0_bcount_t tx_nr);
+static m0_bcount_t tx_engine_free_space(const struct m0_be_tx_engine *eng);
+static void        tx_engine_got_space (struct m0_be_tx_engine *eng);
+
+void m0_be_tx_engine_init(struct m0_be_tx_engine *engine)
+{
+	m0_forall(i, ARRAY_SIZE(engine->te_txs),
+		  tx_tlist_init(&engine->te_txs[i]));
+	m0_rwlock_init(&engine->te_lock);
+	M0_POST(m0_be_tx_engine_invariant(engine));
+}
+
+void m0_be_tx_engine_fini(struct m0_be_tx_engine *engine)
+{
+	M0_PRE(m0_be_tx_engine_invariant(engine));
+	m0_rwlock_fini(&engine->te_lock);
+	m0_forall(i, ARRAY_SIZE(engine->te_txs),
+		  tx_tlist_fini(&engine->te_txs[i]));
+}
+
+void m0_be_tx_init(struct m0_be_tx *tx, uint64_t tid, struct m0_be *be,
+		   m0_be_tx_cb_t persistent,
+		   m0_be_tx_cb_t discarded)
+{
+	m0_sm_init(&tx->t_sm, &tx_sm_conf, M0_BTS_INIT, tx_grp);
+	tx->t_id = tx->t_key = tid;
+	tx->t_be = be;
+	tx->t_persistent = persistent;
+	tx->t_discarded  = discarded;
+	tx_tlink_init_at(tx, tx_engine(tx)->te_txs[M0_BTS_INIT]);
+	M0_POST(m0_be_tx_invariant(tx));
+}
+
+void m0_be_tx_fini(struct m0_be_tx *tx)
+{
+	M0_PRE(m0_be_tx_invariant(tx));
+	tx_tlink_del_fini(tx);
+	m0_sm_fini(&tx->t_sm);
+}
+
+void m0_be_tx_prep(struct m0_be_tx *tx, const struct m0_be_tx_credit *credit)
+{
+	M0_PRE(m0_be_tx_invariant(tx));
+	M0_PRE(tx_state(tx) == M0_BTS_INIT);
+	m0_be_tx_credit_add(&tx->t_prepared, credit);
+	M0_POST(m0_be_tx_invariant(tx));
+}
+
+void m0_be_tx_open(struct m0_be_tx *tx)
+{
+	struct m0_be_tx_engine *eng      = tx_engine(tx);
+	struct m0_be_tx_credit *prepared = &tx->t_prepared;
+	struct m0_bcount_t      log_size = tx_prepared_log_size(tx);
+
+	M0_PRE(m0_be_tx_invariant(tx));
+	M0_PRE(tx_state(tx) == M0_BTS_PREPARE);
+	M0_ALLOC_ARR(tx->t_reg_d_area, prepared->tc_reg_nr);
+	M0_ALLOC_ARR(tx->r_reg_area, prepared->tc_reg_size);
+	if (tx->t_reg_d_area != NULL && tx->r_reg_area != NULL) {
+		tx_engine_lock(eng);
+		if (tx_log_free_space(eng) >= log_size)
+			tx_open_tail(tx);
+		else
+			tx_state_set(tx, M0_BTS_OPENING);
+		tx_engine_unlock(eng);
+	} else {
+		tx_fail(tx, -ENOMEM);
+		m0_free(tx->t_reg_d_area);
+		m0_free(tx->t_reg_area);
+	}
+	M0_POST(m0_be_tx_invariant(tx));
+}
+
+void m0_be_tx_capture(struct m0_be_tx *tx, const struct m0_be_reg *reg)
+{
+	struct m0_be_tx_credit *used = &tx->t_used;
+	struct m0_be_reg_d *rd       = &tx->t_reg_d_area[used->tc_reg_nr];
+	m0_bcount_t size             = reg->br_size;
+
+	M0_PRE(m0_be_tx_invariant(tx));
+	M0_PRE(tx_state(tx) == M0_BTS_ACTIVE);
+	rd->rd_seg_id = reg->br_seg->bs_id;
+	rd->rd_offset = reg->br_addr - reg->br_seg->bs_addr;
+	rd->rd_size   = size;
+
+	memcpy(tx->t_reg_area + used->tc_tc_reg_size, reg->br_addr, size);
+	used->tc_reg_nr++;
+	used->rc_reg_size += size;
+	/**
+	 * @todo XXX assign group to transaction, add region to the group tree.
+	 */
+	M0_POST(m0_be_tx_invariant(tx));
+}
+
+void m0_be_tx_close(struct m0_be_tx *tx,
+		    void (*filler)(struct m0_be_tx *tx, void *payload,
+				   void *datum), void *datum)
+{
+	struct m0_be_tx_engine *eng = tx_engine(tx);
+	bool        new_group = tx == gr_tlist_head(&tx->t_group->tg_tx);
+	m0_bcount_t used      = tx_log_size(tx, &tx->t_used, !!new_group);
+	m0_bcount_t prepared  = tx_prepared_log_size(tx);
+
+	M0_PRE(tx_state(tx) == M0_BTS_ACTIVE);
+	tx_engine_lock(eng);
+	M0_PRE(m0_be_tx_engine_invariant(tx));
+	eng->te_inmem = tx;
+	tx_state_set(tx, M0_BTS_CLOSED);
+	M0_ASSERT(used <= prepared);
+	M0_ASSERT(eng->te_reserved + log_used >= log_prepared);
+	eng->reserved -= prepared - used;
+	tx_engine_got_space(eng);
+	M0_POST(m0_be_tx_engine_invariant(tx));
+	tx_engine_unlock(eng);
+}
+
+void m0_be_tx_credit_init(struct m0_be_tx_credit *credit)
+{
+	M0_SET0(credit);
+}
+
+void m0_be_tx_credit_add(struct m0_be_tx_credit *c0,
+			 const struct m0_be_tx_credit *c1)
+{
+	c0->tc_reg_nr   += c1->tc_reg_nr;
+	c0->tc_reg_size += c1->tc_reg_size;
+}
+
+void m0_be_tx_credit_mul(struct m0_be_tx_credit *c, m0_bcount_t k)
+{
+	c->tc_reg_nr   *= k
+	c->tc_reg_size *= k;
+}
+
+static m0_bcount_t tx_engine_free_space(const struct m0_be_tx_engine *eng)
+{
+	M0_PRE(m0_tx_engine_invariant(eng));
+	return te->te_log.lg_size -
+		tx_log_loc(te->te_inmem) - tx_log_loc(te->te_start) +
+		te->te_log.lg_reserved;
+}
+
+static void tx_engine_got_space(struct m0_be_tx_engine *eng)
+{
+	struct m0_be_tx *head;
+
+	M0_PRE(m0_be_tx_engine_invariant(eng));
+	while ((head = tx_tlist_head(&eng->te_txs[M0_BTS_OPENING])) != NULL &&
+	       tx_prepared_log_size(head) >= tx_engine_free_space(eng))
+		tx_open_tail(head);
+	M0_POST(m0_be_tx_engine_invariant(eng));
+}
+
+static void tx_state_set(struct m0_be_tx *tx, enum m0_be_tx_state state)
+{
+	M0_PRE(m0_be_tx_invariant(tx));
+	m0_sm_state_set(&tx->t_sm, state);
+	tx_link(tx);
+	M0_POST(m0_be_tx_invariant(tx));
+}
+
+static void tx_open_tail(struct m0_be_tx *tx)
+{
+	m0_bcount_t log_size = tx_prepared_log_size(tx);
+
+	M0_PRE(M0_IN(tx_state_get(tx), (M0_BTS_OPENING, M0_BTS_PREPARE)));
+	M0_PRE(tx_engine_free_space(eng) >= log_size);
+
+	eng->te_reserved += log_size;
+	tx_state_set(tx, M0_BTS_ACTIVE);
+}
+
+static void tx_fail(struct m0_be_tx *tx, int errno)
+{
+	M0_PRE(m0_be_tx_invariant(tx));
+	m0_sm_fail(&tx->t_sm, M0_BTS_FAILED, errno);
+	M0_POST(m0_be_tx_invariant(tx));
+}
+
+static enum m0_be_tx_state tx_state_get(const struct m0_be_tx *tx)
+{
+	return tx->t_sm.sm_state;
+}
+
+static void tx_link(struct m0_be_tx *tx)
+{
+	M0_PRE(m0_be_tx_invariant(tx));
+	tx_tlist_move(tx_engine(tx)->tx_txs[tx->t_state], tx);
+	M0_POST(m0_be_tx_invariant(tx));
+}
+
+static m0_bindex_t tx_log_loc(const struct m0_be_tx *tx)
+{
+	M0_PRE(tx->t_group != NULL);
+	M0_PRE(m0_be_tx_invariant(tx));
+	return tx->t_group->tg_log_loc;
+}
+
+static m0_bcount_t tx_group_header_size(m0_bcount_t tx_nr)
+{
+	return sizeof(struct tx_group_header) +
+		tx_nr * sizeof(struct tx_group_entry);
+}
+
+static m0_bcount_t tx_log_size(const struct m0_be_tx *tx,
+			       const struct m0_be_tx_credit *cr,
+			       unsigned group_nr)
+{
+	return tx_group_header_size(nr) + sizeof(struct tx_header) +
+		tx->t_payload +
+		cr->tc_reg_nr * sizeof(struct m0_be_reg_d) + cr->tc_reg_size +
+}
+
+static m0_bcount_t tx_prepareg_log_size(const struct m0_be_tx *tx)
+{
+	return tx_log_size(tx, &tx->t_prepared, 1);
+}
+
+static m0_be_tx_engine *tx_engine(const struct m0_be_tx *tx)
+{
+	return &tx->t_be.b_tx;
+}
+
+bool m0_be_tx_engine_invarint(const struct m0_be_tx_engine *engine)
+{
+	struct m0_be_log *log  = &engine->te_log;
+	struct m0_be_tx  *prev = NULL;
+	return
+		m0_forall(i, M0_BTS_NR, m0_tl_forall(tx, tx, &engine->te_txs[i],
+		     m0_be_tx_invariant(tx) &&
+		     ergo(prev != NULL,
+			  prev->t_key > tx->t_key &&
+			  ergo(prev->t_group != NULL,
+			       tx->t_group != NULL &&
+			       tx_log_loc(prev) > tx_log_loc(tx))) &&
+		     (prev = tx, true))) &&
+
+		tx_log_loc(te->te_start) <= tx_log_loc(te->te_placed) &&
+		tx_log_loc(te->te_placed) <= tx_log_loc(te->te_logged) &&
+		tx_log_loc(te->te_logged) <= tx_log_loc(te->te_submitted) &&
+		tx_log_loc(te->te_submitted) <= tx_log_loc(te->te_inmem) &&
+
+		te->te_start->t_key <= te->te_placed->t_key &&
+		te->te_placed->t_key <= te->te_logged->t_key &&
+		te->te_logged->t_key <= te->te_submitted->t_key &&
+		te->te_submitted->t_key <= te->te_inmem->t_key &&
+
+		tx_engine_free_space(te) <= te->te_log.lg_size;
+}
+
+bool m0_be_tx_invariant(const struct m0_be_tx *tx)
+{
+	enum m0_be_tx_state state = tx_state_get(tx);
+	return
+		state < M0_BTS_NR &&
+		tx_tlist_contains(tx_engine(tx)->te_txs[state], tx) &&
+		tx->t_used.tc_reg_nr <= tx->t_prepared.tc_reg_nr &&
+		tx->t_used.tc_reg_size <= tx->t_prepared.tc_reg_size &&
+		(tx->t_reg_area != NULL) == (state >= M0_BTS_ACTIVE) &&
+		(tx->t_reg_area == NULL) == (tx->t_reg_d_area == NULL) &&
+		(tx->t_group != NULL) == (state >= M0_BTS_CLOSED);
+}
+
+/** @} end of be group */
 
 
 /*
diff --git a/be/tx.h b/be/tx.h
index ca48dc9..1291c6e 100644
--- a/be/tx.h
+++ b/be/tx.h
@@ -22,38 +22,135 @@
 #ifndef __MERO_BE_TX_H__
 #define __MERO_BE_TX_H__
 
+#include "lib/rwlock.h"
+#include "lib/tlist.h"
+
 /**
  * @defgroup be
  *
+ * Transaction engine.
+ *
  * @{
  */
 
-struct m0_be_log {
-	XXX;
-};
 
+/**
+ *
+ *   transaction         log record
+ *      state               state
+ * |                    |                     |
+ * |                    |                     |
+ * | STABLE             |  record discarded   |
+ * | (updates in place) |                     |
+ * |                    |                     |
+ * +--------------------+---------------------+----> start
+ * |                    |                     |
+ * | PLACED             |  persistent         |
+ * | (updates in place  |                     |
+ * |  and in log)       |                     |
+ * |                    |                     |
+ * +--------------------+---------------------+----> placed
+ * |                    |                     |
+ * | LOGGED             |  persistent         |
+ * | (updates in log)   |                     |
+ * |                    |                     |
+ * +--------------------+---------------------+----> logged
+ * |                    |                     |
+ * | SUBMITTED          |  in flight          |
+ * | (updates in flight |                     |
+ * |  to log)           |                     |
+ * |                    |                     |
+ * +--------------------+---------------------+----> submitted
+ * |                    |                     |
+ * | CLOSED             |  in memory,         |
+ * | (groupped)         |  log location       |
+ * |                    |  assigned           |
+ * |                    |                     |
+ * +--------------------+---------------------+----> inmem
+ * |                    |                     |
+ * | ACTIVE             |  in memory,         |
+ * | (capturing         |  log space          |
+ * |  updates)          |  reserved           |
+ * |                    |                     |
+ * +--------------------+---------------------+----> prepared
+ * |                    |                     |
+ * | OPENING            |  no records         |
+ * | (waiting for log   |                     |
+ * |  space             |                     |
+ * |                    |                     |
+ * +--------------------+---------------------+
+ * |                    |                     |
+ * | PREPARE            | no records          |
+ * | (accumulating      |                     |
+ * |  credits)          |                     |
+ * +--------------------+---------------------+
+ *
+ *
+ */
 enum m0_be_tx_state {
-	XXX,
+	M0_BTS_FAILED,
+	M0_BTS_INIT,
+	M0_BTS_PREPARE,
+	M0_BTS_OPENING,
+	M0_BTS_ACTIVE,
+	M0_BTS_CLOSED,
+	M0_BTS_SUBMITTED,
+	M0_BTS_LOGGED,
+	M0_BTS_PLACED,
+	M0_BTS_STABLE,
 	M0_BTS_NR
 };
 
+struct m0_be_log {
+	struct m0_stob  *lg_stob;
+	m0_bcount_t      lg_size;
+};
+
 struct m0_be_tx_engine {
 	struct m0_tl     te_txs[M0_BTS_NR];
 	struct m0_rwlock te_lock;
+	struct m0_be_log te_log;
+
+	struct m0_be_tx *te_start;
+	struct m0_be_tx *te_placed;
+	struct m0_be_tx *te_logged;
+	struct m0_be_tx *te_submitted;
+	struct m0_be_tx *te_inmem;
+	m0_bcount_t      te_reserved;
 };
 
+bool m0_be_tx_engine_invarint(const struct m0_be_tx_engine *engine);
+
+void m0_be_tx_engine_init(struct m0_be_tx_engine *engine);
+void m0_be_tx_engine_fini(struct m0_be_tx_engine *engine);
+
 typedef void (*m0_be_tx_cb_t)(const struct m0_be_tx *tx);
 
 struct m0_be_tx {
-	enum m0_be_tx_state t_state;
-	struct m0_be       *t_be;
-	struct m0_tlink     t_linkage;
-	m0_be_tx_cb_t       t_persistent;
-	m0_be_tx_cb_t       t_discarded;
+	struct m0_sm           t_sm;
+	uint64_t               t_id;
+	uint64_t               t_key;
+	struct m0_be          *t_be;
+	struct m0_tlink        t_linkage;
+	struct m0_tlink        t_group_linkage;
+	m0_bcount_t            t_payload_size;
+	struct m0_be_tx_credit t_prepared;
+	struct m0_be_tx_credit t_used;
+	struct m0_be_reg_d    *t_reg_d_area;
+	void                  *t_reg_area;
+	struct m0_be_txgroup  *t_group;
+	m0_be_tx_cb_t          t_persistent;
+	m0_be_tx_cb_t          t_discarded;
+};
+bool m0_be_tx_invariant(const struct m0_be_tx *tx);
+
+struct m0_be_txgroup {
+	struct m0_tl tg_tx;
 };
 
-void m0_be_tx_init(struct m0_be_tx *tx, struct m0_be *be,
-		   m0_be_tx_cb_t persistent);
+void m0_be_tx_init(struct m0_be_tx *tx, uint64_t tid, struct m0_be *be,
+		   m0_be_tx_cb_t persistent,
+		   m0_be_tx_cb_t discarded);
 
 void m0_be_tx_fini(struct m0_be_tx *tx);
 
@@ -64,7 +161,7 @@ void m0_be_tx_open(struct m0_be_tx *tx);
 void m0_be_tx_capture(struct m0_be_tx *tx, const struct m0_be_reg *reg);
 
 /** XXX */
-void m0_be_tx_close(struct m0_be_tx *tx, m0_bcount_t payload_size,
+void m0_be_tx_close(struct m0_be_tx *tx,
 		    void (*filler)(struct m0_be_tx *tx, void *payload,
 				   void *datum), void *datum);
 
-- 
1.8.3.2

