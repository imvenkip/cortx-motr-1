From 7e7ac24f383d512ba1a533b13c970a32da20a6a8 Mon Sep 17 00:00:00 2001
From: "Valery V. Vorotyntsev" <valery_vorotyntsev@xyratex.com>
Date: Wed, 3 Jul 2013 18:39:09 +0300
Subject: [PATCH 271/290] be: revise tx state machine

- Abandon the approach with tx reference counters, use
  m0_be_tx::t_glob_stable flag instead.

- Remove M0_BTS_SUBMITTED and M0_BTS_LOGGED states. Keeping them
  gives no practical benefit but requires posting ASTs, which is not
  trivial in this case: a tx_group may want to post the same AST
  object twice and violate the rules of AST processing by doing so.

- Rename M0_BTS_STABLE to M0_BTS_DONE. "Stable" state does not have
  a certain place: a transaction may become stable before it is
  M0_BTS_PLACED, and local transactions (those that are not needed
  for recovery) are always "stable".

- Introduce ->sd_in() handlers for M0_BTS_PLACED and M0_BTS_DONE states.
---
 be/tx.c     | 131 +++++++++++++++++++++++-------------------------------------
 be/tx.h     |  85 ++++++++++++++++++---------------------
 be/tx_fom.c |   8 ++--
 3 files changed, 92 insertions(+), 132 deletions(-)

diff --git a/be/tx.c b/be/tx.c
index 39e680a..b422a85 100644
--- a/be/tx.c
+++ b/be/tx.c
@@ -40,13 +40,12 @@
  * @{
  */
 
-static int active_st_in(struct m0_sm *mach);
 static int placed_st_in(struct m0_sm *mach);
+static int   done_st_in(struct m0_sm *mach);
 
 M0_TL_DESCR_DEFINE(tx, "transactions", M0_INTERNAL, struct m0_be_tx,
 		   t_linkage, t_magic,
-		   M0_TRACE_TX_MAGIC,
-		   M0_TRACE_TX_LIST_MAGIC);
+		   M0_TRACE_TX_MAGIC, M0_TRACE_TX_LIST_MAGIC);
 
 M0_TL_DEFINE(tx, M0_INTERNAL, struct m0_be_tx);
 
@@ -66,31 +65,25 @@ static struct m0_sm_state_descr tx_states[M0_BTS_NR] = {
 	}
 
 	_S(M0_BTS_FAILED,  M0_SDF_FAILURE, 0),
-	_S(M0_BTS_PREPARE, M0_SDF_INITIAL, M0_BITS(M0_BTS_PREPARE,
-						   M0_BTS_OPENING,
-#if 0 /* XXX I don't think we should allow transition from PREPARE to ACTIVE.
-       * --vvv */
-						   M0_BTS_ACTIVE,
-#endif
+	_S(M0_BTS_PREPARE, M0_SDF_INITIAL, M0_BITS(M0_BTS_OPENING,
 						   M0_BTS_FAILED)),
 	_S(M0_BTS_OPENING, 0, M0_BITS(M0_BTS_ACTIVE, M0_BTS_FAILED)),
-	[M0_BTS_ACTIVE] = {
-		.sd_name      = "M0_BTS_ACTIVE",
-		.sd_in        = active_st_in,
-		.sd_invariant = tx_state_invariant,
-		.sd_alloved   = M0_BITS(M0_BTS_ACTIVE, M0_BTS_CLOSED)
-	},
-	_S(M0_BTS_CLOSED,    0, M0_BITS(M0_BTS_GROUPED)),
-	_S(M0_BTS_GROUPED,   0, M0_BITS(M0_BTS_SUBMITTED)),
-	_S(M0_BTS_SUBMITTED, 0, M0_BITS(M0_BTS_LOGGED)),
-	_S(M0_BTS_LOGGED,    0, M0_BITS(M0_BTS_PLACED)),
+	_S(M0_BTS_ACTIVE,  0, M0_BITS(M0_BTS_CLOSED)),
+	_S(M0_BTS_CLOSED,  0, M0_BITS(M0_BTS_GROUPED)),
+	_S(M0_BTS_GROUPED, 0, M0_BITS(M0_BTS_PLACED)),
 	[M0_BTS_PLACED] = {
 		.sd_name      = "M0_BTS_PLACED",
 		.sd_in        = placed_st_in,
 		.sd_invariant = tx_state_invariant,
-		.sd_alloved   = M0_BITS(M0_BTS_STABLE)
+		.sd_allowed   = M0_BITS(M0_BTS_DONE)
 	},
-	_S(M0_BTS_STABLE, M0_SDF_TERMINAL, 0)
+	[M0_BTS_DONE] = {
+		.sd_flags     = M0_SDF_TERMINAL,
+		.sd_name      = "M0_BTS_DONE",
+		.sd_in        = done_st_in,
+		.sd_invariant = tx_state_invariant,
+		.sd_allowed   = 0
+	}
 #undef _S
 };
 
@@ -110,7 +103,6 @@ static void        tx_engine_got_closed(struct m0_be_tx_engine *eng,
 static void        tx_engine_lock      (struct m0_be_tx_engine *eng);
 static void        tx_engine_unlock    (struct m0_be_tx_engine *eng);
 static bool        tx_is_locked        (const struct m0_be_tx *tx);
-static void        tx_release          (struct m0_ref *ref);
 
 M0_INTERNAL void m0_be_tx_engine_init(struct m0_be_tx_engine *engine)
 {
@@ -133,27 +125,30 @@ M0_INTERNAL void m0_be_tx_engine_fini(struct m0_be_tx_engine *engine)
 		  (tx_tlist_fini(&engine->te_txs[i]), true));
 }
 
-M0_INTERNAL void m0_be_tx_init(struct m0_be_tx *tx, uint64_t tid,
-			       struct m0_be *be, struct m0_sm_group *tx_grp,
-			       m0_be_tx_cb_t persistent,
-			       m0_be_tx_cb_t discarded,
-			       void (*filler)(struct m0_be_tx *tx,
-					      void *payload),
-			       void *datum)
+M0_INTERNAL void m0_be_tx_init(struct m0_be_tx    *tx,
+			       uint64_t            tid,
+			       struct m0_be       *be,
+			       struct m0_sm_group *sm_group,
+			       m0_be_tx_cb_t       persistent,
+			       m0_be_tx_cb_t       discarded,
+			       bool                is_part_of_global_tx,
+			       void              (*filler)(struct m0_be_tx *tx,
+							   void *payload),
+			       void               *datum)
 {
-	m0_sm_init(&tx->t_sm, &tx_sm_conf, M0_BTS_PREPARE, tx_grp);
+	m0_sm_init(&tx->t_sm, &tx_sm_conf, M0_BTS_PREPARE, sm_group);
 	tx->t_id = tid;
 	tx->t_be = be;
 
 	tx_tlink_init_at(tx, &tx_engine(tx)->te_txs[M0_BTS_PREPARE]);
 	gr_tlink_init(tx);
-	m0_ref_init(&tx->t_ref, 1, tx_release);
 
 	m0_be_tx_credit_init(&tx->t_prepared);
-	tx->t_persistent = persistent;
-	tx->t_discarded	 = discarded;
-	tx->t_filler	 = filler;
-	tx->t_datum	 = datum;
+	tx->t_persistent  = persistent;
+	tx->t_discarded   = discarded;
+	tx->t_glob_stable = !is_part_of_global_tx;
+	tx->t_filler      = filler;
+	tx->t_datum       = datum;
 
 	M0_POST(m0_be__tx_invariant(tx));
 }
@@ -422,15 +417,19 @@ m0_be_tx_timedwait(struct m0_be_tx *tx, int state, m0_time_t timeout)
 
 M0_INTERNAL void m0_be_tx_stable(struct m0_be_tx *tx)
 {
+	enum m0_be_tx_state state = m0_be__tx_state(tx);
+
 	M0_ENTRY();
 	M0_PRE(m0_be__tx_invariant(tx));
-	M0_PRE(M0_IN(m0_be__tx_state(tx), (M0_BTS_LOGGED, M0_BTS_PLACED)));
 	M0_PRE(tx_is_locked(tx));
+	M0_PRE(M0_IN(state, (M0_BTS_PLACED, M0_BTS_GROUPED)));
+	M0_PRE(!tx->t_glob_stable);
 
-	m0_be__tx_state_set(tx, M0_BTS_STABLE);
-	m0_be__tx_put(tx);
-	m0_fom_wakeup(tx_engine(tx)->te_fom);
-
+	tx->t_glob_stable = true;
+	if (state == M0_BTS_PLACED) {
+		m0_be__tx_state_set(tx, M0_BTS_DONE);
+		m0_fom_wakeup(tx_engine(tx)->te_fom);
+	}
 	M0_LEAVE();
 }
 
@@ -460,6 +459,10 @@ static void tx_engine_got_space(struct m0_be_tx_engine *eng)
 static void
 tx_engine_got_closed(struct m0_be_tx_engine *eng, struct m0_be_tx *tx)
 {
+	M0_PRE(m0_be__tx_invariant(tx));
+	M0_PRE(m0_be__tx_state(tx) == M0_BTS_CLOSED);
+	M0_PRE(tx_is_locked(tx));
+
 	struct m0_be_tx_group *gr = &eng->te_group;
 #if 0 /* Nikita's code */
 	m0_bcount_t used = tx_log_size(tx, &tx->t_used,
@@ -489,33 +492,13 @@ static void tx_open_tail(struct m0_be_tx *tx)
 {
 	m0_bcount_t log_size = tx_prepared_log_size(tx);
 
-	M0_PRE(M0_IN(m0_be__tx_state(tx), (M0_BTS_OPENING, M0_BTS_PREPARE)));
+	M0_PRE(m0_be__tx_state(tx) == M0_BTS_OPENING);
 	M0_PRE(tx_engine_free_space(tx_engine(tx)) >= log_size);
 
 	tx_engine(tx)->te_reserved += log_size;
 	m0_be__tx_state_set(tx, M0_BTS_ACTIVE);
 }
 
-M0_INTERNAL void m0_be__tx_get(struct m0_be_tx *tx)
-{
-	M0_ENTRY();
-	M0_PRE(tx_is_locked(tx));
-
-	m0_ref_get(&tx->t_ref);
-
-	M0_LEAVE();
-}
-
-M0_INTERNAL void m0_be__tx_put(struct m0_be_tx *tx)
-{
-	M0_ENTRY();
-	M0_PRE(tx_is_locked(tx));
-
-	m0_ref_put(&tx->t_ref);
-
-	M0_LEAVE();
-}
-
 M0_INTERNAL enum m0_be_tx_state m0_be__tx_state(const struct m0_be_tx *tx)
 {
 	return tx->t_sm.sm_state;
@@ -652,36 +635,22 @@ static bool tx_is_locked(const struct m0_be_tx *tx)
 	return m0_mutex_is_locked(&tx->t_sm.sm_grp->s_lock);
 }
 
-static void tx_release(struct m0_ref *ref)
-{
-	const struct m0_be_tx *tx = /* XXX TODO bob_of() */
-		container_of(ref, const struct m0_be_tx, t_ref);
-	M0_ENTRY();
-	M0_PRE(m0_be__tx_invariant(tx));
-
-	if (tx->t_discarded != NULL)
-		tx->t_discarded(tx);
-	M0_LEAVE();
-}
-
-static int active_st_in(struct m0_sm *mach)
+static int placed_st_in(struct m0_sm *mach)
 {
 	struct m0_be_tx *tx = container_of(mach, struct m0_be_tx, t_sm);
-	M0_ENTRY();
-
-	m0_be__tx_get(&tx->t_ref);
+	M0_ENTRY("t_glob_stable=%d", tx->t_glob_stable);
 
 	M0_LEAVE();
-	return -1;
+	return tx->t_glob_stable ? M0_BTS_DONE : -1;
 }
 
-static int placed_st_in(struct m0_sm *mach)
+static int done_st_in(struct m0_sm *mach)
 {
 	struct m0_be_tx *tx = container_of(mach, struct m0_be_tx, t_sm);
 	M0_ENTRY();
 
-	m0_be__tx_put(&tx->t_ref);
-
+	if (tx->t_discarded != NULL)
+		tx->t_discarded(tx);
 	M0_LEAVE();
 	return -1;
 }
diff --git a/be/tx.h b/be/tx.h
index 4e998fc..0e03cd7 100644
--- a/be/tx.h
+++ b/be/tx.h
@@ -134,17 +134,7 @@ struct m0_be_reg;
  *                        V
  *                     GROUPED
  *                        |
- *                        | log io is launched
- *                        |
- *                        V
- *                     SUBMITTED
- *                        |
- *                        | log io completes
- *                        |
- *                        V
- *                      LOGGED
- *                        |
- *                        | in-place io completes
+ *                        | log io & in-place io complete
  *                        |
  *                        V
  *                      PLACED
@@ -152,7 +142,7 @@ struct m0_be_reg;
  *                        | m0_be_tx_stable()
  *                        |
  *                        V
- *                      STABLE
+ *                      DONE
  *
  * @endverbatim
  *
@@ -166,7 +156,7 @@ struct m0_be_reg;
  *         state                state
  * |                    |                     |
  * |                    |                     |
- * | STABLE             |  record discarded   |
+ * | DONE               |  record discarded   |
  * | (updates in place) |                     |
  * |                    |                     |
  * +--------------------+---------------------+----> start
@@ -177,12 +167,12 @@ struct m0_be_reg;
  * |                    |                     |
  * +--------------------+---------------------+----> placed
  * |                    |                     |
- * | LOGGED             |  persistent         |
+ * | ``LOGGED''         |  persistent         |
  * | (updates in log)   |                     |
  * |                    |                     |
  * +--------------------+---------------------+----> logged
  * |                    |                     |
- * | SUBMITTED          |  in flight          |
+ * | ``SUBMITTED''      |  in flight          |
  * | (updates in flight |                     |
  * |  to log)           |                     |
  * |                    |                     |
@@ -263,24 +253,20 @@ enum m0_be_tx_state {
 	 */
 	M0_BTS_GROUPED,
 	/**
-	 * Transaction updates are in flight to the log.
-	 */
-	M0_BTS_SUBMITTED,
-	/**
-	 * All transaction updates made it to the log.
-	 */
-	M0_BTS_LOGGED,
-	/**
 	 * All transaction in-place updates completed.
 	 */
 	M0_BTS_PLACED,
 	/**
 	 * Transaction was declared stable by call to m0_be_tx_stable().
 	 */
-	M0_BTS_STABLE,
+	M0_BTS_DONE,
 	M0_BTS_NR
 };
 
+/*
+ * NOTE: Call-backs of this type must be asynchronous, because they can be
+ * called from state transition functions.
+ */
 typedef void (*m0_be_tx_cb_t)(const struct m0_be_tx *tx);
 
 /**
@@ -339,7 +325,6 @@ struct m0_be_tx {
 	uint64_t               t_magic;
 	struct m0_sm           t_sm;
 	struct m0_sm_ast       t_ast;
-	enum m0_be_tx_state    t_ast_datum;
 
 	/** Transaction identifier, assigned by the user. */
 	uint64_t               t_id;
@@ -348,9 +333,11 @@ struct m0_be_tx {
 	 * transaction reaches GROUPED state.
 	 */
 	uint64_t               t_lsn;
+
 	struct m0_be          *t_be;
 	/** Linkage in one of m0_be_tx_engine::te_txs[] lists. */
 	struct m0_tlink        t_linkage;
+
 	/**
 	 * The group the transaction is part of. This is non-NULL iff the
 	 * transaction is in GROUPED or later state.
@@ -358,8 +345,7 @@ struct m0_be_tx {
 	struct m0_be_tx_group *t_group;
 	/** Linkage in m0_be_tx_group::tg_txs. */
 	struct m0_tlink        t_group_linkage;
-	/** XXX DOCUMENTME */
-	struct m0_ref          t_ref;
+
 	/**
 	 * Size (in bytes) of "payload area" in the transaction log header,
 	 * reserved for user.
@@ -368,21 +354,25 @@ struct m0_be_tx {
 	 * ACTIVE state.
 	 */
 	m0_bcount_t            t_payload_size;
+
 	/** Updates prepared for at PREPARE state. */
 	struct m0_be_tx_credit t_prepared;
 	struct m0_be_reg_area  t_reg_area;
+
 	/**
 	 * True iff the transaction is the first transaction in the group. In
 	 * this case, the overhead of group (specifically, the size of group
 	 * header and group commit log) are "billed" to the transaction.
 	 */
 	bool                   t_leader;
+
 	/**
 	 * Optional call-back called when the transaction is guaranteed to
-	 * survive all further failures. This is invoked when the transaction
-	 * reaches LOGGED state.
+	 * survive all further failures. This is invoked upon log IO
+	 * completion.
 	 */
 	m0_be_tx_cb_t          t_persistent;
+
 	/**
 	 * This optional call-back is called when a stable transaction is about
 	 * to be discarded from the history.
@@ -392,6 +382,13 @@ struct m0_be_tx {
 	 * COW-ed file extents.
 	 */
 	m0_be_tx_cb_t          t_discarded;
+
+	/**
+	 * True iff the transaction is globally stable, i.e., not
+	 * needed for recovery.
+	 */
+	bool                   t_glob_stable;
+
 	/**
 	 * An optional call-back called when the transaction is being closed.
 	 *
@@ -404,6 +401,7 @@ struct m0_be_tx {
 	 * for distributed transaction management.
 	 */
 	void                 (*t_filler)(struct m0_be_tx *tx, void *payload);
+
 	/**
 	 * User-specified value, associated with the transaction. Transaction
 	 * engine doesn't interpret this value. It can be used to pass
@@ -414,13 +412,16 @@ struct m0_be_tx {
 
 M0_INTERNAL bool m0_be__tx_invariant(const struct m0_be_tx *tx);
 
-M0_INTERNAL void m0_be_tx_init(struct m0_be_tx *tx, uint64_t tid,
-			       struct m0_be *be, struct m0_sm_group *tx_grp,
-			       m0_be_tx_cb_t persistent,
-			       m0_be_tx_cb_t discarded,
-			       void (*filler)(struct m0_be_tx *tx,
-					      void *payload),
-			       void *datum);
+M0_INTERNAL void m0_be_tx_init(struct m0_be_tx    *tx,
+			       uint64_t            tid,
+			       struct m0_be       *be,
+			       struct m0_sm_group *sm_group,
+			       m0_be_tx_cb_t       persistent,
+			       m0_be_tx_cb_t       discarded,
+			       bool                is_part_of_global_tx,
+			       void              (*filler)(struct m0_be_tx *tx,
+							   void *payload),
+			       void               *datum);
 
 M0_INTERNAL void m0_be_tx_fini(struct m0_be_tx *tx);
 
@@ -445,19 +446,9 @@ M0_INTERNAL void m0_be_tx_force(struct m0_be_tx *tx);
 M0_INTERNAL int m0_be_tx_timedwait(struct m0_be_tx *tx, int state,
 				   m0_time_t timeout);
 
-/**
- * Notifies backend that the transaction is no longer needed for recovery.
- *
- * Calls tx->t_discarded() call-back, if it is set.
- */
+/** Notifies backend that the transaction is no longer needed for recovery. */
 M0_INTERNAL void m0_be_tx_stable(struct m0_be_tx *tx);
 
-/** Increments transaction's reference counter (m0_be_tx::t_ref). */
-M0_INTERNAL void m0_be__tx_get(struct m0_be_tx *tx);
-
-/** Decrements transaction's reference counter (m0_be_tx::t_ref). */
-M0_INTERNAL void m0_be__tx_put(struct m0_be_tx *tx);
-
 M0_INTERNAL void m0_be__tx_state_set(struct m0_be_tx *tx,
 				     enum m0_be_tx_state state);
 M0_INTERNAL enum m0_be_tx_state m0_be__tx_state(const struct m0_be_tx *tx);
diff --git a/be/tx_fom.c b/be/tx_fom.c
index e15c788..15cfdc5 100644
--- a/be/tx_fom.c
+++ b/be/tx_fom.c
@@ -66,10 +66,10 @@
  *   |              |          |
  *   |              v    [8]   |   [8] Gets awoken by m0_be_tx_stable().
  *   |      ,---- PLACED ---.  |       The tx_group contains transactions
- *   |      |       | ^     |  |       that are not M0_BTS_STABLE.
+ *   |      |       | ^     |  |       that are not M0_BTS_DONE.
  *   |      |   [9] | |     |  |   [9] Gets awoken by m0_be_tx_stable().
  *   |      |       | `-----'  |       All transactions of the tx_group
- *   |      |       v          |       are M0_BTS_STABLE.
+ *   |      |       v          |       are M0_BTS_DONE.
  *   |      |     STABLE ------'
  *   |      |
  *   | [10] |                     [10] XXX TODO: m0_backend_fini()?
@@ -175,7 +175,7 @@ static int tx_group_tick(struct m0_fom *fom)
 		[TGS_PLACING]    = TGS_PLACED,
 		/*
 		 * Note, that we move a tx_group from TGS_PLACED to TGS_STABLE
-		 * only if all of its transactions are M0_BTS_STABLE.
+		 * only if all of its transactions are M0_BTS_DONE.
 		 */
 		[TGS_PLACED]     = TGS_STABLE,
 		[TGS_STABLE]     = TGS_OPEN
@@ -191,7 +191,7 @@ static int tx_group_tick(struct m0_fom *fom)
 		M0_IMPOSSIBLE("XXX Not implemented");
 	} else if (state != TGS_PLACED ||
 		   m0_tl_forall(gr, tx, &gr->tg_txs,
-				m0_be__tx_state(tx) == M0_BTS_STABLE)) {
+				m0_be__tx_state(tx) == M0_BTS_DONE)) {
 		M0_LOG(M0_DEBUG, "Move to state %d", next_state[state]);
 		m0_fom_phase_set(fom, next_state[state]);
 	}
-- 
1.8.3.2

