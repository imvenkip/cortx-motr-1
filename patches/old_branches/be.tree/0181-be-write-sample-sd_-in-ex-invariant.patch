From ca27bcda12e74b8adf1877993b4099a9e161866a Mon Sep 17 00:00:00 2001
From: "Valery V. Vorotyntsev" <valery_vorotyntsev@xyratex.com>
Date: Thu, 20 Jun 2013 02:57:00 +0300
Subject: [PATCH 181/290] be: write sample ->sd_{in,ex,invariant}()

We can use m0_sm_state_descr::sd_{in,ex,invariant}() function pointers
to split the implementation of tx state machine into manageable chunks.
See group_closed_st_{in,ex,invariant}() in be/tx_fom.c.
(The more advanced example is in conf/confc.c.)

+ Refactor the code of transaction FOM.
---
 be/be.h         |   3 +-
 be/tx.h         |   4 +-
 be/tx_fom.c     | 143 +++++++++++++++++++++++++++++++++++++-------------------
 be/tx_fom.h     |   2 +-
 be/tx_service.c |  49 ++++++++++---------
 be/tx_service.h |  15 ++----
 mero/init.c     |  10 ++--
 7 files changed, 132 insertions(+), 94 deletions(-)

diff --git a/be/be.h b/be/be.h
index c41c34b..ac15291 100644
--- a/be/be.h
+++ b/be/be.h
@@ -115,8 +115,7 @@ M0_INTERNAL int m0_be_op_wait(struct m0_be_op *op);
 M0_INTERNAL int m0_be_op_tick_ret(struct m0_be_op *op, struct m0_fom *fom,
 				  int next_state);
 
-/* XXX */
-extern struct m0_be m0_be_instance;
+extern struct m0_be m0_be_instance; /* XXX FIXME: This is quite inelegant. */
 
 M0_INTERNAL void m0_be_op_init(struct m0_be_op *op);
 M0_INTERNAL void m0_be_op_fini(struct m0_be_op *op);
diff --git a/be/tx.h b/be/tx.h
index f9d7ef4..01781db 100644
--- a/be/tx.h
+++ b/be/tx.h
@@ -319,9 +319,7 @@ struct m0_be_tx_engine {
 	 */
 	m0_bcount_t           te_reserved;
 
-	/**
-	 * Pointer to fom-worker serving transaction groups
-	 */
+	/** Pointer to the FOM processing transaction groups. */
 	struct m0_fom        *te_fom;
 };
 
diff --git a/be/tx_fom.c b/be/tx_fom.c
index a2918d1..b8b125d 100644
--- a/be/tx_fom.c
+++ b/be/tx_fom.c
@@ -37,6 +37,15 @@
  * @{
  */
 
+/* ------------------------------------------------------------------
+ * State definitions
+ * ------------------------------------------------------------------ */
+
+static int  group_closed_st_in(struct m0_sm *mach);
+static void group_closed_st_ex(struct m0_sm *mach);
+static bool group_closed_st_invariant(const struct m0_sm *mach);
+static struct tx_fom *fom_to_txm(const struct m0_fom *fom);
+
 enum tx_fom_states {
 	FS_STARTED,
 	FS_FINISHED,
@@ -52,7 +61,12 @@ enum tx_fom_states {
 	FS_FAILED
 };
 
-static struct m0_sm_state_descr descr[] = {
+struct tx_fom {
+	struct m0_fom           tf_gen;
+	struct m0_be_tx_engine *tf_engine;
+};
+
+static struct m0_sm_state_descr tx_fom_states[] = {
 #define _S(name, flags, allowed)       \
 	[name] = {                     \
 		.sd_flags   = (flags), \
@@ -62,7 +76,15 @@ static struct m0_sm_state_descr descr[] = {
 
 	_S(FS_STARTED,  M0_SDF_INITIAL,  M0_BITS(FS_GROUP_CLOSED)),
 	_S(FS_FINISHED, M0_SDF_TERMINAL, 0),
-	_S(FS_GROUP_CLOSED,        0, M0_BITS(FS_SUBMITTED_TO_LOG)),
+
+	[FS_GROUP_CLOSED] = {
+		.sd_name      = "FS_GROUP_CLOSED",
+		.sd_in        = group_closed_st_in,
+		.sd_ex        = group_closed_st_ex,
+		.sd_invariant = group_closed_st_invariant,
+		.sd_allowed   = M0_BITS(FS_SUBMITTED_TO_LOG)
+	},
+
 	_S(FS_SUBMITTED_TO_LOG,    0, M0_BITS(FS_PAYLOAD_LOGGED)),
 	_S(FS_PAYLOAD_LOGGED,      0, M0_BITS(FS_GROUP_HEADER_LOGGED)),
 	_S(FS_GROUP_HEADER_LOGGED, 0, M0_BITS(FS_LOG_HEADER_LOGGED)),
@@ -77,31 +99,26 @@ static struct m0_sm_state_descr descr[] = {
 
 static struct m0_sm_conf tx_fom_conf = {
 	.scf_name      = "tx_fom states",
-	.scf_nr_states = ARRAY_SIZE(descr),
-	.scf_state     = descr
+	.scf_nr_states = ARRAY_SIZE(tx_fom_states),
+	.scf_state     = tx_fom_states
 };
 
-struct tx_fom {
-	struct m0_fom           tf_gen;
-	struct m0_be_tx_engine *tf_eng;
-};
+/* ------------------------------------------------------------------
+ * TX FOM operations
+ * ------------------------------------------------------------------ */
 
 static int tx_fom_tick(struct m0_fom *fom)
 {
-	struct tx_fom   *m  = container_of(fom, struct tx_fom, tf_gen);
-	struct m0_be_tx *tx = NULL;
-
-	M0_ENTRY();
+	struct m0_be_tx *tx = m0_fom_phase(fom) > FS_STARTED ?
+		gr_tlist_head(&fom_to_txm(fom)->tf_engine->te_group.tg_tx) :
+		NULL;
 
 	M0_LOG(M0_DEBUG, "phase = %d", m0_fom_phase(fom));
 
-	if (m0_fom_phase(fom) > FS_STARTED) /* XXX This is ugly. */
-		tx = gr_tlist_head(&m->tf_eng->te_group.tg_tx);
-
 	switch (m0_fom_phase(fom)) {
 	case FS_STARTED:
 		m0_fom_phase_set(fom, FS_GROUP_CLOSED);
-		M0_RETURN(M0_FSO_WAIT);
+		return M0_FSO_WAIT;
 
 	case FS_GROUP_CLOSED:
 	case FS_SUBMITTED_TO_LOG:
@@ -126,12 +143,12 @@ static int tx_fom_tick(struct m0_fom *fom)
 		m0_fom_phase_set(fom, FS_STABLE);
 		gr_tlist_del(tx);
 		tx_tlist_del(tx);
-		M0_RETURN(M0_FSO_WAIT);
+		return M0_FSO_WAIT;
 
 	case FS_STABLE:
 		tx_state_set(tx, M0_BTS_STABLE);
 		/* m0_fom_phase_set(fom, M0_FOM_PHASE_FINISH); */
-		M0_RETURN(M0_FSO_WAIT);
+		return M0_FSO_WAIT;
 
 	case FS_FAILED:
 	default:
@@ -139,24 +156,19 @@ static int tx_fom_tick(struct m0_fom *fom)
 	}
 
 	m0_fom_phase_set(fom, m0_fom_phase(fom) + 1);
-	M0_RETURN(M0_FSO_AGAIN);
+	return M0_FSO_AGAIN;
 }
 
 static void tx_fom_fini(struct m0_fom *fom)
 {
-	struct tx_fom *m = container_of(fom, struct tx_fom, tf_gen);
-
 	M0_ENTRY();
-	m0_free(m);
+	m0_free(fom_to_txm(fom));
 	M0_LEAVE();
 }
 
 static size_t tx_fom_home_locality(const struct m0_fom *fom)
 {
-	static size_t locality = 0; /* XXX: has locality be fixed? */
-
-	M0_PRE(fom != NULL);
-	return locality;
+	return 0; /* XXX TODO: reconsider */
 }
 
 static void tx_fom_addb_init(struct m0_fom *fom, struct m0_addb_mc *mc)
@@ -177,43 +189,42 @@ static const struct m0_fom_type_ops tx_fom_type_ops = {
 	.fto_create = NULL
 };
 
-static int tx_fom_create(struct m0_fom **out, struct m0_reqh *reqh,
-			 struct m0_be_tx_engine *eng)
+static struct m0_fom *
+tx_fom_create(struct m0_reqh *reqh, struct m0_be_tx_engine *engine)
 {
-	struct tx_fom *m;
-
-	M0_ALLOC_PTR(m);
-	if (m == NULL)
-		return -ENOMEM;
+	struct tx_fom *txm;
+	struct m0_fom *fom;
 
-	*out = &m->tf_gen;
-	m0_fom_init(*out, &tx_fom_type, &tx_fom_ops, NULL, NULL, reqh,
-		    &m0_txs_stype);
+	M0_ALLOC_PTR(txm);
+	if (txm == NULL)
+		return NULL;
 
-	/* init tx_fom fields */
-	m->tf_eng = eng;
-	eng->te_fom = &m->tf_gen;
+	fom = &txm->tf_gen;
+	m0_fom_init(fom, &tx_fom_type, &tx_fom_ops, NULL, NULL, reqh,
+		    &m0_be_txs_stype);
 
-	return 0;
+	engine->te_fom = fom;
+	txm->tf_engine = engine;
+	return fom;
 }
 
 M0_INTERNAL int
-m0_tx_processing_start(struct m0_reqh *reqh, struct m0_be_tx_engine *eng)
+m0_tx_processing_start(struct m0_reqh *reqh, struct m0_be_tx_engine *engine)
 {
 	struct m0_fom *fom;
-	int            rc;
 
 	M0_ENTRY();
 	M0_PRE(m0_reqh_state_get(reqh) == M0_REQH_ST_NORMAL);
 
-	m0_fom_type_init(&tx_fom_type, &tx_fom_type_ops, &m0_txs_stype,
+	m0_fom_type_init(&tx_fom_type, &tx_fom_type_ops, &m0_be_txs_stype,
 			 &tx_fom_conf);
 
-	rc = tx_fom_create(&fom, reqh, eng);
-	if (rc == 0)
-		m0_fom_queue(fom, reqh);
+	fom = tx_fom_create(reqh, engine);
+	if (fom == NULL)
+		M0_RETURN(-ENOMEM);
 
-	M0_RETURN(rc);
+	m0_fom_queue(fom, reqh);
+	M0_RETURN(0);
 }
 
 M0_INTERNAL void m0_tx_processing_stop(void)
@@ -222,6 +233,44 @@ M0_INTERNAL void m0_tx_processing_stop(void)
 	M0_LEAVE();
 }
 
+/* ------------------------------------------------------------------
+ * Casts
+ * ------------------------------------------------------------------ */
+
+static const struct m0_fom *sm_to_fom(const struct m0_sm *sm)
+{
+	/* XXX TODO: Use bob_of(). */
+	return container_of(sm, const struct m0_fom, fo_sm_phase);
+}
+
+static struct tx_fom *fom_to_txm(const struct m0_fom *fom)
+{
+	/* XXX TODO: Use bob_of(). */
+	return container_of(fom, struct tx_fom, tf_gen);
+}
+
+/* ------------------------------------------------------------------
+ * State transitions
+ * ------------------------------------------------------------------ */
+
+static int group_closed_st_in(struct m0_sm *mach)
+{
+	M0_LOG(M0_DEBUG, "Entering sm_state %u", mach->sm_state);
+	return -1;
+}
+
+static void group_closed_st_ex(struct m0_sm *mach)
+{
+	M0_LOG(M0_DEBUG, "Leaving sm_state %u", mach->sm_state);
+}
+
+static bool group_closed_st_invariant(const struct m0_sm *mach)
+{
+	/* XXX DELETEME */
+	return fom_to_txm(sm_to_fom(mach))->tf_engine->te_fom ==
+		sm_to_fom(mach);
+}
+
 /** @} end of be group */
 #undef M0_TRACE_SUBSYSTEM
 
diff --git a/be/tx_fom.h b/be/tx_fom.h
index 62e9c9d..451aa52 100644
--- a/be/tx_fom.h
+++ b/be/tx_fom.h
@@ -31,7 +31,7 @@ struct m0_be_tx_engine;
  */
 
 M0_INTERNAL int m0_tx_processing_start(struct m0_reqh *reqh,
-				       struct m0_be_tx_engine *eng);
+				       struct m0_be_tx_engine *engine);
 
 M0_INTERNAL void m0_tx_processing_stop(void);
 
diff --git a/be/tx_service.c b/be/tx_service.c
index dc36cb0..35502e7 100644
--- a/be/tx_service.c
+++ b/be/tx_service.c
@@ -22,14 +22,13 @@
 #define M0_TRACE_SUBSYSTEM M0_TRACE_SUBSYS_BE
 #include "lib/trace.h"
 
-#include "lib/errno.h"
-
 #undef M0_ADDB_CT_CREATE_DEFINITION
 #define M0_ADDB_CT_CREATE_DEFINITION
 #include "addb/addb.h"
 
-#include "lib/memory.h"
 #include "be/tx_service.h"
+#include "lib/errno.h"
+#include "lib/memory.h"
 
 /**
  * @addtogroup be
@@ -37,11 +36,10 @@
  */
 
 /* ------------------------------------------------------------------
- * ADDB helpers
+ * ADDB
  * ------------------------------------------------------------------ */
-enum {
-	M0_ADDB_CTXID_TX_SERVICE = 1700
-};
+
+enum { M0_ADDB_CTXID_TX_SERVICE = 1700 };
 
 M0_ADDB_CT(m0_addb_ct_tx_service, M0_ADDB_CTXID_TX_SERVICE, "hi", "low");
 
@@ -63,6 +61,12 @@ static void _addb_fini(void)
  * TX service
  * ------------------------------------------------------------------ */
 
+/** Transaction service. */
+struct tx_service {
+	struct m0_reqh_service ts_reqh;
+	struct m0_be          *ts_be;
+};
+
 static int txs_allocate(struct m0_reqh_service **out,
 			struct m0_reqh_service_type *stype,
 			struct m0_reqh_context *rctx);
@@ -71,17 +75,17 @@ static const struct m0_reqh_service_type_ops txs_stype_ops = {
 	.rsto_service_allocate = txs_allocate
 };
 
-M0_REQH_SERVICE_TYPE_DEFINE(m0_txs_stype, &txs_stype_ops, "tx-service",
+M0_REQH_SERVICE_TYPE_DEFINE(m0_be_txs_stype, &txs_stype_ops, "be-tx-service",
                             &m0_addb_ct_tx_service);
 
-M0_INTERNAL int m0_txs_register(void)
+M0_INTERNAL int m0_be_txs_register(void)
 {
-	return m0_reqh_service_type_register(&m0_txs_stype);
+	return m0_reqh_service_type_register(&m0_be_txs_stype);
 }
 
-M0_INTERNAL void m0_txs_unregister(void)
+M0_INTERNAL void m0_be_txs_unregister(void)
 {
-	m0_reqh_service_type_unregister(&m0_txs_stype);
+	m0_reqh_service_type_unregister(&m0_be_txs_stype);
 }
 
 static int  txs_start(struct m0_reqh_service *service);
@@ -96,13 +100,13 @@ static const struct m0_reqh_service_ops txs_ops = {
 
 /** Allocates and initialises transaction service. */
 static int txs_allocate(struct m0_reqh_service **service,
-			  struct m0_reqh_service_type *stype,
-			  struct m0_reqh_context *rctx)
+			struct m0_reqh_service_type *stype,
+			struct m0_reqh_context *rctx)
 {
-	struct m0_tx_service *s;
+	struct tx_service *s;
 
 	M0_ENTRY();
-	M0_PRE(stype == &m0_txs_stype);
+	M0_PRE(stype == &m0_be_txs_stype);
 
 	M0_ALLOC_PTR(s);
 	if (s == NULL)
@@ -113,21 +117,15 @@ static int txs_allocate(struct m0_reqh_service **service,
 	_addb_init();
 
 	s->ts_be = &m0_be_instance;
-
 	M0_RETURN(0);
 }
 
 /** Finalises and deallocates transaction service. */
 static void txs_fini(struct m0_reqh_service *service)
 {
-	struct m0_tx_service *s = container_of(service, struct m0_tx_service,
-					       ts_reqh);
-
-	M0_ENTRY("%p", s);
-
+	M0_ENTRY();
 	_addb_fini();
-	m0_free(s);
-
+	m0_free(container_of(service, struct tx_service, ts_reqh));
 	M0_LEAVE();
 }
 
@@ -143,9 +141,10 @@ static void txs_stop(struct m0_reqh_service *service)
 	M0_LEAVE();
 }
 
+/** @} end of be group */
 #undef M0_ADDB_CT_CREATE_DEFINITION
 #undef M0_TRACE_SUBSYSTEM
-/** @} end of be group */
+
 /*
  *  Local variables:
  *  c-indentation-style: "K&R"
diff --git a/be/tx_service.h b/be/tx_service.h
index a4b5ce3..f5a2d8a 100644
--- a/be/tx_service.h
+++ b/be/tx_service.h
@@ -17,6 +17,7 @@
  * Original author: Anatoliy Bilenko <anatoliy_bilenko@xyratex.com>
  * Original creation date: 17-Jun-2013
  */
+
 #pragma once
 #ifndef __MERO_BE_TX_SERVICE_H__
 #define __MERO_BE_TX_SERVICE_H__
@@ -29,21 +30,13 @@
  * @{
  */
 
-extern struct m0_reqh_service_type m0_txs_stype;
-
-/** Transaction service */
-struct m0_tx_service {
-	/** Generic service. */
-	struct m0_reqh_service  ts_reqh;
-	struct m0_be           *ts_be;
-};
+extern struct m0_reqh_service_type m0_be_txs_stype;
 
-M0_INTERNAL int m0_txs_register(void);
-M0_INTERNAL void m0_txs_unregister(void);
+M0_INTERNAL int m0_be_txs_register(void);
+M0_INTERNAL void m0_be_txs_unregister(void);
 
 
 /** @} end of be group */
-
 #endif /* __MERO_BE_TX_SERVICE_H__ */
 
 /*
diff --git a/mero/init.c b/mero/init.c
index 5da6c6c..68d5eac 100644
--- a/mero/init.c
+++ b/mero/init.c
@@ -54,7 +54,7 @@
 #  include "mero/linux_kernel/dummy_init_fini.h"
 #  include "net/test/initfini.h"	/* m0_net_test_init */
 #else
-#  include "be/tx_service.h"    /* m0_txs_register */
+#  include "be/tx_service.h"    /* m0_be_txs_register */
 #  include "conf/confd.h"       /* m0_confd_register */
 #  include "conf/addb.h"        /* m0_conf_addb_init */
 #  include "mdstore/mdstore.h"  /* m0_mdstore_mod_init */
@@ -144,10 +144,10 @@ struct init_fini_call subsystem[] = {
 #ifdef __KERNEL__
 	{ &m0t1fs_init,         &m0t1fs_fini,         "m0t1fs" },
 #else
-	{ &m0_txs_register,     &m0_txs_unregister,   "tx-service" },
-	{ &m0_confd_register,   &m0_confd_unregister, "confd" },
-	{ &m0_ios_register,     &m0_ios_unregister,   "ioservice" },
-	{ &m0_mds_register,     &m0_mds_unregister,   "mdservice"},
+	{ &m0_be_txs_register,  &m0_be_txs_unregister, "be-tx-service" },
+	{ &m0_confd_register,   &m0_confd_unregister,  "confd" },
+	{ &m0_ios_register,     &m0_ios_unregister,    "ioservice" },
+	{ &m0_mds_register,     &m0_mds_unregister,    "mdservice"},
 	/**
 	 * @todo Start rmservice in kernel mode.
 	 */
-- 
1.8.3.2

