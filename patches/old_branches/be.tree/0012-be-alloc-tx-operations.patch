From 09bf4b66437c04ee5db67ebb8f40249cbf3f005c Mon Sep 17 00:00:00 2001
From: "Valery V. Vorotyntsev" <valery_vorotyntsev@xyratex.com>
Date: Tue, 28 May 2013 15:00:20 +0300
Subject: [PATCH 012/290] be: alloc, tx operations

---
 be/seg.h | 154 +++++++++++++++++++++++++++++++++++++++++++++++++++++----------
 1 file changed, 130 insertions(+), 24 deletions(-)

diff --git a/be/seg.h b/be/seg.h
index 45901b8..7a00e56 100644
--- a/be/seg.h
+++ b/be/seg.h
@@ -29,7 +29,42 @@
  */
 
 struct m0_be_allocator {
-	XXX;
+	struct m0_be_seg *ba_seg;
+};
+
+int m0_be_allocator_init(struct m0_be_allocator *a, struct m0_be_seg *seg);
+
+void m0_be_allocator_fini(struct m0_be_allocator *a);
+
+int m0_be_allocator_create(struct m0_be_allocator *a);
+int m0_be_allocator_destroy(struct m0_be_allocator *a);
+
+void m0_be_alloc_credit(struct m0_be_allocator *a, m0_bcount_t size,
+			unsigned shift, struct m0_be_tx_credit *accum);
+
+void *m0_be_alloc(struct m0_be_allocator *a, struct m0_be_tx *tx,
+		  m0_bcount_t size, unsigned shift);
+
+void m0_be_free_credit(struct m0_be_allocator *a,
+		       struct m0_be_tx_credit *accum);
+
+void m0_be_free(struct m0_be_allocator *a, struct m0_be_tx *tx, void *ptr);
+
+struct m0_be_allocator_stats {
+	m0_bcount_t bas_free_space;
+};
+
+void m0_be_alloc_stats(struct m0_be_allocator *a,
+		       struct m0_be_allocator_stats *out);
+
+/* ---------------------------------------------------------------- */
+
+enum m0_be_op_state {
+	M0_BOS_INIT,
+	M0_BOS_ACTIVE,
+	M0_BOS_SUCCESS,
+	M0_BOS_FAILURE,
+	M0_BOS_NR
 };
 
 struct m0_be_op {
@@ -46,12 +81,35 @@ struct m0_be_tx_engine {
 	struct m0_rwlock te_lock;
 };
 
+typedef void (*m0_be_tx_cb_t)(const struct m0_be_tx *tx);
+
 struct m0_be_tx {
 	enum m0_be_tx_state t_state;
 	struct m0_be       *t_be;
 	struct m0_tlink     t_linkage;
+	m0_be_tx_cb_t       t_persistent;
 };
 
+void m0_be_tx_init(struct m0_be_tx *tx, struct m0_be *be,
+		   m0_be_tx_cb_t persistent);
+
+void m0_be_tx_fini(struct m0_be_tx *tx);
+
+void m0_be_tx_prep(struct m0_be_tx *tx, const struct m0_be_tx_credit *cr);
+
+void m0_be_tx_open(struct m0_be_tx *tx);
+
+void m0_be_tx_capture(struct m0_be_tx *tx, const struct m0_be_reg *reg);
+
+void m0_be_tx_close(struct m0_be_tx *tx);
+
+int m0_be_tx_timedwait(struct m0_be_tx *tx, m0_time_t timeout);
+
+/** Forces the transaction to storage. */
+void m0_be_tx_force(struct m0_be_tx *tx);
+
+/* ---------------------------------------------------------------- */
+
 struct m0_be_log {
 	XXX;
 };
@@ -91,7 +149,7 @@ struct m0_be_reg {
 
 #define M0_BE_REG(seg, addr, size) \
 	((struct m0_be_reg) {      \
-		.br_seg = (seg),   \
+		.br_seg  = (seg),  \
 		.br_size = (size), \
 		.br_addr = (addr) })
 
@@ -99,22 +157,65 @@ void m0_be_reg_get(const struct m0_be_reg *reg, struct m0_be_op *op);
 void m0_be_reg_get_fast(const struct m0_be_seg *reg);
 
 void m0_be_reg_put(const struct m0_be_reg *reg, struct m0_be_op *op);
+
+/* ---------------------------------------------------------------- */
 
 struct m0_be_list {
 	struct m0_tl      bl_list;
 	struct m0_be_seg *bl_seg;
 };
 
+void m0_be_list_init(struct m0_be_list *list, struct m0_be_seg *seg);
+void m0_be_list_fini(struct m0_be_list *list);
+
+void m0_be_list_create(struct m0_be_list *list);
+void m0_be_list_destroy(struct m0_be_list *list);
+
 void m0_be_list_get(const struct m0_be_list *list, m0_bcount_t nelems,
 		    struct m0_be_op *op);
 
 void m0_be_list_put(const struct m0_be_list *list, m0_bcount_t nelems);
 
+/**
+ * Captures (origin - left)-th .. (origin + right)-th elements of the list.
+ */
+void m0_be_list_capture(const struct m0_be_list *list, struct m0_be_tx *tx,
+			const struct m0_tlink *origin, m0_bcount_t left,
+			m0_bcount_t right);
+
+/* scope void   name ## _tlist_add(struct m0_tl *list, amb_type *amb);	\ */
+/* scope void   name ## _tlist_add_tail(struct m0_tl *list, amb_type *amb); \ */
+/* scope void   name ## _tlist_add_after(amb_type *amb, amb_type *next);	\ */
+/* scope void   name ## _tlist_add_before(amb_type *amb, amb_type *next);	\ */
+/* scope void   name ## _tlist_del(amb_type *amb);				\ */
+/* scope void   name ## _tlist_move(struct m0_tl *list, amb_type *amb);	\ */
+/* scope void   name ## _tlist_move_tail(struct m0_tl *list, amb_type *amb); \ */
+
+
+/* ---------------------------------------------------------------- */
+
 struct m0_be_btree {
-	struct m0_rwlock  bb_lock;
-	struct m0_be_seg *bb_seg;
+	struct m0_rwlock    bb_lock;
+	struct m0_be_seg   *bb_seg;
+	struct m0_be_bnode *bb_root;
 };
 
+void m0_be_btree_init(struct m0_be_btree *tree, struct m0_be_seg *seg,
+		      struct m0_be_bnode *root);
+
+void m0_be_btree_fini(struct m0_be_btree *tree);
+
+/*
+ * Use case:
+ *     m0_be_btree_init(&tree, seg, NULL);
+ *     m0_be_btree_create(&tree, tx, op);
+ */
+void m0_be_btree_create(struct m0_be_btree *tree, struct m0_be_tx *tx,
+			struct m0_be_op *op);
+
+void m0_be_btree_destroy(struct m0_be_btree *tree, struct m0_be_tx *tx,
+			 struct m0_be_op *op);
+
 struct m0_be_btree_cursor {
 	struct m0_be_btree *bc_tree;
 	struct m0_op        bc_op;
@@ -133,26 +234,6 @@ void m0_be_btree_cursor_put(struct m0_be_btree_cursor *cursor);
 
 void m0_be_btree_cursor_next(struct m0_be_btree_cursor *cursor);
 
-struct m0_be_tx_credit {
-	/**
-	 * The number of regions needed for operation representation in the
-	 * transaction.
-	 */
-	m0_bcount_t tc_reg_nr;
-
-	/** Total size of memory needed for the same. */
-	m0_bcount_t tc_reg_size;
-};
-
-void m0_be_tx_credit_init(struct m0_be_tx_credit *credit);
-
-/** c0 += c1 */
-void m0_be_tx_credit_add(struct m0_be_tx_credit *c0,
-			 const struct m0_be_tx_credit *c1);
-
-/** c *= k */
-void m0_be_tx_credit_mul(struct m0_be_tx_credit *c, m0_bcount_t k);
-
 struct m0_be_btree_anchor {
 	struct m0_be_btree *ba_tree;
 	struct m0_buf       ba_buf;
@@ -201,5 +282,30 @@ void m0_be_btree_delete(struct m0_be_btree *tree, struct m0_be_tx *tx,
 void m0_be_btree_release(struct m0_be_btree *tree,
 			 const struct m0_be_btree_anchor *anchor);
 
+struct m0_be_tx_credit {
+	/**
+	 * The number of regions needed for operation representation in the
+	 * transaction.
+	 */
+	m0_bcount_t tc_reg_nr;
+
+	/** Total size of memory needed for the same. */
+	m0_bcount_t tc_reg_size;
+};
+
+void m0_be_tx_credit_init(struct m0_be_tx_credit *credit);
+
+/** c0 += c1 */
+void m0_be_tx_credit_add(struct m0_be_tx_credit *c0,
+			 const struct m0_be_tx_credit *c1);
+
+/** c *= k */
+void m0_be_tx_credit_mul(struct m0_be_tx_credit *c, m0_bcount_t k);
+
+/* ---------------------------------------------------------------- */
+
+/** Waits for the operation to complete and returns its rc. */
+int m0_be_op_wait(struct m0_be_op *op);
+
 /** @} end of seg group */
 #endif /* __MERO_BE_SEG_H__ */
-- 
1.8.3.2

