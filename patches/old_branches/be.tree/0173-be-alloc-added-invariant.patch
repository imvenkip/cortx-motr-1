From 7e8a61331c0b658b6e56f47abb758102581fcedd Mon Sep 17 00:00:00 2001
From: Maxim Medved <Max_Medved@xyratex.com>
Date: Wed, 19 Jun 2013 05:49:17 +0300
Subject: [PATCH 173/290] be/alloc: added invariant

invariant: after m0_be_alloc() and before m0_be_free() pointer to memory
block should be inside allocator address space.
---
 be/alloc.c | 67 ++++++++++++++++++++++++++++++++++++++++----------------------
 1 file changed, 43 insertions(+), 24 deletions(-)

diff --git a/be/alloc.c b/be/alloc.c
index 9adc98d..677dde7 100644
--- a/be/alloc.c
+++ b/be/alloc.c
@@ -57,6 +57,20 @@ M0_TL_DESCR_DEFINE(chunks_free, "list of free chunks in m0_be_allocator",
 		   M0_BE_ALLOC_FREE_LINK_MAGIC, M0_BE_ALLOC_FREE_MAGIC);
 M0_TL_DEFINE(chunks_free, static, struct be_alloc_chunk);
 
+static bool be_alloc_is_mem_in_allocator(struct m0_be_allocator *a,
+					 m0_bcount_t size, const void *ptr)
+{
+	return (char *) ptr >= (char *) a->ba_h->bah_addr &&
+	       (char *) ptr + size <= ((char *) a->ba_h->bah_addr) +
+				      a->ba_h->bah_size;
+}
+
+static bool be_alloc_is_chunk_in_allocator(struct m0_be_allocator *a,
+					   const struct be_alloc_chunk *c)
+{
+	return be_alloc_is_mem_in_allocator(a, sizeof *c + c->bac_size, c);
+}
+
 static bool be_alloc_chunk_is_not_overlapping(const struct be_alloc_chunk *a,
 					      const struct be_alloc_chunk *b)
 {
@@ -84,6 +98,11 @@ static bool be_alloc_chunk_invariant(struct m0_be_allocator *a,
 	}
 
 	return c != NULL &&
+	       be_alloc_is_chunk_in_allocator(a, c) &&
+	       ergo(cnext != NULL, be_alloc_is_chunk_in_allocator(a, cnext)) &&
+	       ergo(cprev != NULL, be_alloc_is_chunk_in_allocator(a, cprev)) &&
+	       ergo(fnext != NULL, be_alloc_is_chunk_in_allocator(a, fnext)) &&
+	       ergo(fprev != NULL, be_alloc_is_chunk_in_allocator(a, fprev)) &&
 	       c->bac_magic0 == M0_BE_ALLOC_MAGIC0 &&
 	       c->bac_magic1 == M0_BE_ALLOC_MAGIC1 &&
 	       be_alloc_chunk_is_not_overlapping(cprev, c) &&
@@ -515,10 +534,13 @@ M0_INTERNAL void *m0_be_alloc(struct m0_be_allocator *a,
 	/* XXX */
 	m0_be_op_state_set(op, M0_BOS_SUCCESS);
 
+	if (c != NULL) {
+		M0_POST(!c->bac_free);
+		M0_POST(c->bac_size >= size);
+		M0_POST(m0_addr_is_aligned(&c->bac_mem, shift));
+		M0_POST(be_alloc_is_chunk_in_allocator(a, c));
+	}
 	M0_POST(m0_be_allocator__invariant(a));
-	M0_POST(ergo(c != NULL, !c->bac_free));
-	M0_POST(ergo(c != NULL, c->bac_size >= size));
-	M0_POST(ergo(c != NULL, m0_addr_is_aligned(&c->bac_mem, shift)));
 	return c == NULL ? NULL : &c->bac_mem;
 }
 
@@ -531,33 +553,30 @@ M0_INTERNAL void m0_be_free(struct m0_be_allocator *a,
 	bool		       chunks_were_merged;
 
 	M0_PRE(m0_be_allocator__invariant(a));
-	M0_PRE(ptr == NULL || (char *) ptr >= (char *) a->ba_h->bah_addr);
-	M0_PRE(ptr == NULL ||
-	       (char *) ptr < ((char *) a->ba_h->bah_addr) + a->ba_h->bah_size);
+	M0_PRE(ergo(ptr != NULL, be_alloc_is_mem_in_allocator(a, 1, ptr)));
 
 	/* XXX */
 	m0_be_op_state_set(op, M0_BOS_ACTIVE);
 
 	if (ptr != NULL) {
 		m0_mutex_lock(&a->ba_lock);
-		if (ptr != NULL) {
-			c = be_alloc_chunk_addr(ptr);
-			M0_PRE(be_alloc_chunk_invariant(a, c));
-			M0_PRE(!c->bac_free);
-			/* algorithm starts here */
-			be_alloc_chunk_mark_free(a, c);
-			prev = be_alloc_chunk_prev(a, c);
-			next = be_alloc_chunk_next(a, c);
-			chunks_were_merged = be_alloc_chunk_trymerge(a, prev,
-								     c);
-			if (chunks_were_merged)
-				c = prev;
-			be_alloc_chunk_trymerge(a, c, next);
-			/* and ends here */
-			M0_POST(c->bac_free);
-			M0_POST(c->bac_size > 0);
-			M0_POST(be_alloc_chunk_invariant(a, c));
-		}
+
+		c = be_alloc_chunk_addr(ptr);
+		M0_PRE(be_alloc_chunk_invariant(a, c));
+		M0_PRE(!c->bac_free);
+		/* algorithm starts here */
+		be_alloc_chunk_mark_free(a, c);
+		prev = be_alloc_chunk_prev(a, c);
+		next = be_alloc_chunk_next(a, c);
+		chunks_were_merged = be_alloc_chunk_trymerge(a, prev, c);
+		if (chunks_were_merged)
+			c = prev;
+		be_alloc_chunk_trymerge(a, c, next);
+		/* and ends here */
+		M0_POST(c->bac_free);
+		M0_POST(c->bac_size > 0);
+		M0_POST(be_alloc_chunk_invariant(a, c));
+
 		m0_mutex_unlock(&a->ba_lock);
 	}
 
-- 
1.8.3.2

