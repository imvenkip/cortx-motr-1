From 17fbbe9aac902410b1debb370c9ebb1391f25608 Mon Sep 17 00:00:00 2001
From: "Valery V. Vorotyntsev" <valery_vorotyntsev@xyratex.com>
Date: Tue, 28 May 2013 12:10:18 +0300
Subject: [PATCH 010/290] be: seg.h created

---
 be/seg.h | 185 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 185 insertions(+)
 create mode 100644 be/seg.h

diff --git a/be/seg.h b/be/seg.h
new file mode 100644
index 0000000..a607527
--- /dev/null
+++ b/be/seg.h
@@ -0,0 +1,185 @@
+/* -*- C -*- */
+/*
+ * COPYRIGHT 2013 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: Nikita Danilov <nikita_danilov@xyratex.com>
+ * Original creation date: 28-May-2013
+ */
+
+#pragma once
+#ifndef __MERO_BE_SEG_H__
+#define __MERO_BE_SEG_H__
+
+/**
+ * @defgroup seg
+ *
+ * @{
+ */
+
+struct m0_be_allocator {
+	XXX;
+};
+
+struct m0_be_op {
+	XXX;
+};
+
+enum m0_be_tx_state {
+	XXX,
+	M0_BTS_NR
+};
+
+struct m0_be_tx_engine {
+	struct m0_tl     te_txs[M0_BTS_NR];
+	struct m0_rwlock te_lock;
+};
+
+struct m0_be_tx {
+	enum m0_be_tx_state t_state;
+	struct m0_be       *t_be;
+	struct m0_tlink     t_linkage;
+};
+
+struct m0_be_log {
+	XXX;
+};
+
+struct m0_be {
+	struct m0_be_tx_engine b_tx;
+	struct m0_be_seg       b_seg0;
+	struct m0_be_log      *b_log;
+};
+
+struct m0_be_seg {
+	struct m0_stob        *bs_stob;
+	m0_bcount_t            bs_size;
+	void                  *bs_addr;
+	struct m0_be_allocator bs_allocator;
+	struct m0_be          *bs_be;
+};
+
+void m0_be_seg_init(struct m0_be_seg *seg, struct m0_stob *stob);
+void m0_be_seg_fini(struct m0_be_seg *seg);
+
+/** Opens existing stob, reads segment header from it, etc. */
+int m0_be_seg_open(struct m0_be_seg *seg);
+
+void m0_be_seg_close(struct m0_be_seg *seg);
+
+/** Creates segment on storage. */
+int m0_be_seg_create(struct m0_be_seg *seg);
+
+int m0_be_seg_destroy(struct m0_be_seg *seg);
+
+struct m0_be_reg {
+	struct m0_be_seg *br_seg;
+	m0_bcount_t       br_size;
+	void             *br_addr;
+};
+
+#define M0_BE_REG(seg, addr, size) \
+	((struct m0_be_reg) {      \
+		.br_seg = (seg),   \
+		.br_size = (size), \
+		.br_addr = (addr) })
+
+void m0_be_reg_get(const struct m0_be_reg *reg, struct m0_be_op *op);
+void m0_be_reg_get_fast(const struct m0_be_seg *reg);
+
+void m0_be_reg_put(const struct m0_be_reg *reg, struct m0_be_op *op);
+
+struct m0_be_list {
+	struct m0_tl      bl_list;
+	struct m0_be_seg *bl_seg;
+};
+
+void m0_be_list_get(const struct m0_be_list *list, m0_bcount_t nelems,
+		    struct m0_be_op *op);
+
+void m0_be_list_put(const struct m0_be_list *list, m0_bcount_t nelems);
+
+struct m0_be_btree {
+	struct m0_rwlock  bb_lock;
+	struct m0_be_seg *bb_seg;
+};
+
+struct m0_be_btree_cursor {
+	struct m0_be_btree *bc_tree;
+};
+
+struct m0_be_tx_credit {
+	/**
+	 * The number of regions needed for operation representation in the
+	 * transaction.
+	 */
+	m0_bcount_t tc_reg_nr;
+
+	/** Total size of memory needed for the same. */
+	m0_bcount_t tc_reg_size;
+};
+
+void m0_be_tx_credit_init(struct m0_be_tx_credit *credit);
+
+/** c0 += c1 */
+void m0_be_tx_credit_add(struct m0_be_tx_credit *c0,
+			 const struct m0_be_tx_credit *c1);
+
+/** c *= k */
+void m0_be_tx_credit_mul(struct m0_be_tx_credit *c, m0_bcount_t k);
+
+struct m0_be_btree_anchor {
+	struct m0_be_btree *ba_tree;
+	struct m0_buf       ba_buf;
+	bool                ba_write; /**< Is write lock being held? */
+};
+
+void m0_be_btree_lookup(struct m0_be_btree *tree, struct m0_be_op *op,
+			const struct m0_buf *key, struct m0_buf *dest_buf);
+
+void m0_be_btree_lookup_inplace(struct m0_be_btree *tree, struct m0_be_op *op,
+				const struct m0_buf *key,
+				struct m0_be_btree_anchor *anchor);
+
+void m0_be_btree_insert_credit(const struct m0_be_btree *tree,
+			       struct m0_be_tx_credit *accum);
+
+void m0_be_btree_insert(struct m0_be_btree *tree, struct m0_be_tx *tx,
+			struct m0_be_op *op, const struct m0_buf *key,
+			const struct m0_buf *value);
+
+void m0_be_btree_insert_inplace(struct m0_be_btree *tree, struct m0_be_tx *tx,
+				struct m0_be_op *op, const struct m0_buf *key,
+				struct m0_be_btree_anchor *anchor);
+
+void m0_be_btree_update(struct m0_be_btree *tree, struct m0_be_tx *tx,
+			struct m0_be_op *op, const struct m0_buf *key,
+			const struct m0_buf *value);
+
+void m0_be_btree_update_inplace(struct m0_be_btree *tree, struct m0_be_tx *tx,
+				struct m0_be_op *op, const struct m0_buf *key,
+				struct m0_be_btree_anchor *anchor);
+
+void m0_be_btree_delete_credit(struct m0_be_btree *tree,
+			       struct m0_be_tx_credit *accum);
+
+void m0_be_btree_delete(struct m0_be_btree *tree, struct m0_be_tx *tx,
+			struct m0_be_op *op, const struct m0_buf *key);
+
+/** Completes m0_be_btree_*_inplace() operation. */
+void m0_be_btree_release(struct m0_be_btree *tree,
+			 const struct m0_be_btree_anchor *anchor);
+
+/** @} end of seg group */
+#endif /* __MERO_BE_SEG_H__ */
-- 
1.8.3.2

