From ae36a259c1f5db8ce5ca890df81c0cc56f38c9fd Mon Sep 17 00:00:00 2001
From: Anatoliy Bilenko <anatoliy_bilenko@xyratex.com>
Date: Wed, 26 Jun 2013 15:23:54 +0300
Subject: [PATCH 232/290] tx_log: added log_open()/log_close().

---
 be/tx.c     |   2 +-
 be/tx_log.c | 159 ++++++++++++++++++++++++++++++++++++++++++------------------
 be/tx_log.h |  71 +++++++++++++++++++++++++--
 3 files changed, 179 insertions(+), 53 deletions(-)

diff --git a/be/tx.c b/be/tx.c
index cd293f8..fb90f99 100644
--- a/be/tx.c
+++ b/be/tx.c
@@ -154,7 +154,7 @@ M0_INTERNAL void m0_be_tx_engine_init(struct m0_be_tx_engine *engine)
 		  (tx_tlist_init(&engine->te_txs[i]), true));
 	m0_rwlock_init(&engine->te_lock);
 	tx_group_init(&engine->te_group);
-	log_init(&engine->te_log);
+	log_init(&engine->te_log, 1ULL << 26, 1ULL << 20, 100);
 
 	M0_POST(m0_be__tx_engine_invariant(engine));
 }
diff --git a/be/tx_log.c b/be/tx_log.c
index a6aa6be..356c9b9 100644
--- a/be/tx_log.c
+++ b/be/tx_log.c
@@ -14,66 +14,31 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Valery V. Vorotyntsev <valery_vorotyntsev@xyratex.com>
+ * Original author: Anatoliy Bilenko <anatoliy_bilenko@xyratex.com>
  * Original creation date: 17-Jun-2013
  */
 
+#define M0_TRACE_SUBSYSTEM M0_TRACE_SUBSYS_BE
+#include "lib/trace.h"
+#include "lib/misc.h" /* M0_SET0 */
+#include "lib/errno.h"
+#include "lib/memory.h"
 #include "be/tx_log.h"
 #include "be/tx.h"
 
+
 /**
  * @addtogroup be
  *
  * @{
  */
 
-struct tx_group_header {
-	uint64_t gh_lsn;
-	uint64_t gh_size;
-	uint64_t gh_tx_nr;
-	uint64_t gh_magic;
-} M0_XCA_RECORD;
-
-struct tx_group_commit_block {
-	uint64_t gc_lsn;
-	uint64_t gc_size;
-	uint64_t gc_tx_nr;
-	uint64_t gc_magic;
-} M0_XCA_RECORD;
-
-struct tx_reg_header {
-	uint64_t rh_seg_id;
-	uint64_t rh_offset;
-	uint64_t rh_size;
-	uint64_t rh_lsn;
-} M0_XCA_RECORD;
-
-struct tx_reg_sequence {
-	uint64_t              rs_nr;
-	struct tx_reg_header *rs_reg;
-} M0_XCA_SEQUENCE;
-
-struct tx_group_entry {
-	uint64_t               ge_tid;
-	uint64_t               ge_lsn;
-	struct m0_buf          ge_payload;
-	struct tx_reg_sequence ge_reg;
-} M0_XCA_RECORD;
-
-struct tx_header {
-};
-
-struct m0_be_tx_group_desc {
-	uint64_t tgd_size;
-	uint64_t tgd_tx_nr;
-};
-
 M0_INTERNAL m0_bcount_t tx_log_size(const struct m0_be_tx *tx,
 				    const struct m0_be_tx_credit *cr,
 				    bool leader)
 {
 	return (leader ? sizeof(struct tx_group_header) : 0) +
-		sizeof(struct tx_group_entry) + sizeof(struct tx_header) +
+		sizeof(struct tx_group_entry) + sizeof(struct tx_reg_header) +
 		tx->t_payload_size +
 		cr->tc_reg_nr * sizeof(struct m0_be_reg_d) + cr->tc_reg_size;
 }
@@ -94,16 +59,116 @@ M0_INTERNAL m0_bcount_t tx_group_header_size(m0_bcount_t tx_nr)
 		tx_nr * sizeof(struct tx_group_entry);
 }
 
-M0_INTERNAL void log_init(struct m0_be_log *log)
+M0_INTERNAL void log_init(struct m0_be_log *log, m0_bcount_t log_size,
+			  m0_bcount_t group_size, m0_bcount_t reg_max)
+
 {
 	*log = (struct m0_be_log) {
 		.lg_lsn         = 0ULL,
-		.lg_size        = 1ULL << 26, /* 64 MB */
-		.lg_gr_size_max = 1ULL << 20, /* 1  MB */
-		.lg_stob        = NULL /* XXX */
+		.lg_size        = log_size,
+		.lg_gr_reg_max  = reg_max,
+		.lg_gr_size_max = group_size,
 	};
 }
 
+static void iovec_free(struct m0_bufvec *bv, struct m0_indexvec *iv)
+{
+	m0_free(bv->ov_vec.v_count);
+	m0_free(bv->ov_buf);
+	m0_free(iv->iv_vec.v_count);
+	m0_free(iv->iv_index);
+}
+
+static int iovec_alloc(struct m0_bufvec *bv, struct m0_indexvec *iv,
+		       m0_bindex_t nr)
+{
+	M0_SET0(bv);
+	M0_SET0(iv);
+
+	M0_ALLOC_ARR(bv->ov_vec.v_count, nr);
+	M0_ALLOC_ARR(bv->ov_buf, nr);
+	M0_ALLOC_ARR(iv->iv_vec.v_count, nr);
+	M0_ALLOC_ARR(iv->iv_index, nr);
+
+	if (bv->ov_vec.v_count == NULL || bv->ov_buf == NULL ||
+	    iv->iv_vec.v_count == NULL || iv->iv_index == NULL) {
+		iovec_free(bv, iv);
+		return -ENOMEM;
+	}
+
+	return 0;
+}
+
+static bool log_io_completed(struct m0_clink *link)
+{
+	return true;
+}
+
+static int log_stor_open(struct m0_be_log_stor *stor)
+{
+	static struct m0_stob_id  id = { .si_bits = M0_UINT128(0x106, 0x570b) };
+	struct m0_indexvec       *iv = &stor->ls_io.si_stob;
+	struct m0_bufvec         *bv = &stor->ls_io.si_user;
+	int                       rc;
+
+	M0_ENTRY();
+	M0_PRE(stor->ls_stob->so_domain != NULL);
+	M0_PRE(stor->ls_stob->so_state  != CSS_EXISTS);
+
+	m0_clink_init(&stor->ls_clink, log_io_completed);
+	m0_stob_io_init(&stor->ls_io);
+
+	rc = iovec_alloc(bv, iv, 2);
+	if (rc != 0)
+		return rc;
+
+	rc = m0_stob_find(stor->ls_stob->so_domain, &id, &stor->ls_stob) ?:
+		m0_stob_create(stor->ls_stob, NULL);
+
+	if (rc != 0)
+		iovec_free(bv, iv);
+
+	return rc;
+}
+
+static void log_stor_close(struct m0_be_log_stor *stor)
+{
+	struct m0_indexvec *iv = &stor->ls_io.si_stob;
+	struct m0_bufvec   *bv = &stor->ls_io.si_user;
+
+	m0_clink_fini(&stor->ls_clink);
+	m0_stob_io_fini(&stor->ls_io);
+	m0_stob_put(stor->ls_stob);
+	iovec_free(bv, iv); /* XXX TODO: stob destroy ... */
+}
+
+M0_INTERNAL int log_open(struct m0_be_log *log)
+{
+	int rc;
+
+	M0_ENTRY();
+
+	M0_ALLOC_ARR(log->lg_grent_buf, log->lg_gr_size_max);
+	M0_ALLOC_ARR(log->lg_grent.ge_reg.rs_reg, log->lg_gr_reg_max);
+	if (log->lg_grent_buf == NULL || log->lg_grent.ge_reg.rs_reg == NULL)
+		goto err;
+
+	rc = log_stor_open(&log->lg_stor);
+	if (rc == 0)
+		M0_RETURN(rc);
+err:
+	m0_free(log->lg_grent_buf);
+	m0_free(log->lg_grent.ge_reg.rs_reg);
+	M0_RETURN(-ENOMEM);
+}
+
+M0_INTERNAL void log_close(struct m0_be_log *log)
+{
+	log_stor_close(&log->lg_stor);
+	m0_free(log->lg_grent.ge_reg.rs_reg);
+	m0_free(log->lg_grent_buf);
+}
+
 /** @} end of be group */
 
 /*
diff --git a/be/tx_log.h b/be/tx_log.h
index 4e85e52..5f9439f 100644
--- a/be/tx_log.h
+++ b/be/tx_log.h
@@ -23,6 +23,7 @@
 #define __MERO_BE_TX_LOG_H__
 
 #include "lib/types.h"  /* m0_bcount_t */
+#include "stob/stob.h"  /* m0_stob, m0_stob_io */
 
 struct m0_be_tx;
 struct m0_be_tx_engine;
@@ -34,6 +35,48 @@ struct m0_be_tx_credit;
  * @{
  */
 
+struct tx_group_header {
+	uint64_t gh_lsn;
+	uint64_t gh_size;
+	uint64_t gh_tx_nr;
+	uint64_t gh_magic;
+} M0_XCA_RECORD;
+
+struct tx_group_commit_block {
+	uint64_t gc_lsn;
+	uint64_t gc_size;
+	uint64_t gc_tx_nr;
+	uint64_t gc_magic;
+} M0_XCA_RECORD;
+
+struct tx_reg_header {
+	uint64_t rh_seg_id;
+	uint64_t rh_offset;
+	uint64_t rh_size;
+	uint64_t rh_lsn;
+} M0_XCA_RECORD;
+
+struct tx_reg_sequence {
+	uint64_t              rs_nr;
+	struct tx_reg_header *rs_reg;
+} M0_XCA_SEQUENCE;
+
+struct tx_group_entry {
+	uint64_t               ge_tid;
+	uint64_t               ge_lsn;
+	struct m0_buf          ge_payload;
+	struct tx_reg_sequence ge_reg;
+} M0_XCA_RECORD;
+
+struct m0_be_log_stor {
+	struct m0_stob    *ls_stob;
+	struct m0_clink    ls_clink;
+
+	struct m0_stob_io  ls_io;
+	struct m0_indexvec ls_io_iv;
+	struct m0_bufvec   ls_io_bv;
+};
+
 /**
  * This structure encapsulates internals of transactional log.
  *
@@ -59,20 +102,33 @@ struct m0_be_log {
 	 * a sequence of regions in segments, linked to each other through
 	 * header blocks.
 	 */
-	struct m0_stob  *lg_stob;
+	struct m0_be_log_stor   lg_stor;
+
 	/** Log size. */
-	m0_bcount_t      lg_size;
+	m0_bcount_t		lg_size;
 	/**
 	 * Maximal transaction group size.
 	 *
 	 * When a transaction group reaches this size, it is "closed" and new
 	 * group starts forming.
 	 */
-	m0_bcount_t      lg_gr_size_max;
+	m0_bcount_t		lg_gr_size_max;
+	/**
+	 * Maximal number of regions in group.
+	 */
+	m0_bcount_t             lg_gr_reg_max;
 	/**
 	 * lsn to be used for the next log element.
 	 */
-	m0_bindex_t      lg_lsn;
+	m0_bindex_t		lg_lsn;
+	/**
+	 * Group entry, encoded into tx log buffer.
+	 */
+	struct tx_group_entry	lg_grent;
+	/**
+	 * Group entry buffer, comitted into the log on disk.
+	 */
+	void                   *lg_grent_buf;
 };
 
 M0_INTERNAL m0_bcount_t tx_log_size(const struct m0_be_tx *tx,
@@ -82,7 +138,12 @@ M0_INTERNAL m0_bcount_t tx_log_free_space(const struct m0_be_tx_engine *eng);
 M0_INTERNAL m0_bcount_t tx_prepared_log_size(const struct m0_be_tx *tx);
 M0_INTERNAL m0_bcount_t tx_group_header_size(m0_bcount_t tx_nr);
 
-M0_INTERNAL void log_init(struct m0_be_log *log);
+M0_INTERNAL void log_init(struct m0_be_log *log, m0_bcount_t log_size,
+			  m0_bcount_t group_size, m0_bcount_t reg_max);
+
+M0_INTERNAL int  log_open(struct m0_be_log *log);
+M0_INTERNAL void log_close(struct m0_be_log *log);
+
 
 /** @} end of be group */
 #endif /* __MERO_BE_TX_LOG_H__ */
-- 
1.8.3.2

