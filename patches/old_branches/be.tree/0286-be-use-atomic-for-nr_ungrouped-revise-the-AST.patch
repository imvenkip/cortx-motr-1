From e3b9697ff30e8859369de2189019de2a7e9d4b14 Mon Sep 17 00:00:00 2001
From: "Valery V. Vorotyntsev" <valery_vorotyntsev@xyratex.com>
Date: Fri, 5 Jul 2013 02:11:20 +0300
Subject: [PATCH 286/290] be: use atomic for "nr_ungrouped"; revise the AST

---
 be/tx.c       | 57 ++++++++++++++-------------------------------------------
 be/tx.h       | 23 +++++------------------
 be/tx_fom.c   | 36 ++++++++++++++++++++++++------------
 be/tx_group.h |  9 ---------
 4 files changed, 43 insertions(+), 82 deletions(-)

diff --git a/be/tx.c b/be/tx.c
index d50c703..331fae1 100644
--- a/be/tx.c
+++ b/be/tx.c
@@ -40,10 +40,9 @@
  * @{
  */
 
-static int grouped_st_in(struct m0_sm *mach);
-static int  placed_st_in(struct m0_sm *mach);
-static int    done_st_in(struct m0_sm *mach);
-static void _tx_state_set(struct m0_sm_group *grp, struct m0_sm_ast *ast);
+static int placed_st_in(struct m0_sm *mach);
+static int   done_st_in(struct m0_sm *mach);
+static void _tx_group(struct m0_sm_group *grp, struct m0_sm_ast *ast);
 
 M0_TL_DESCR_DEFINE(tx, "transactions", M0_INTERNAL, struct m0_be_tx,
 		   t_linkage, t_magic,
@@ -73,12 +72,7 @@ static struct m0_sm_state_descr tx_states[M0_BTS_NR] = {
 	_S(M0_BTS_OPENING, 0, M0_BITS(M0_BTS_ACTIVE, M0_BTS_FAILED)),
 	_S(M0_BTS_ACTIVE,  0, M0_BITS(M0_BTS_CLOSED)),
 	_S(M0_BTS_CLOSED,  0, M0_BITS(M0_BTS_GROUPED)),
-	[M0_BTS_GROUPED] = {
-		.sd_name      = "M0_BTS_GROUPED",
-		.sd_in        = grouped_st_in,
-		.sd_invariant = tx_state_invariant,
-		.sd_allowed   = M0_BITS(M0_BTS_PLACED)
-	},
+	_S(M0_BTS_GROUPED, 0, M0_BITS(M0_BTS_PLACED)),
 	[M0_BTS_PLACED] = {
 		.sd_name      = "M0_BTS_PLACED",
 		.sd_in        = placed_st_in,
@@ -145,7 +139,7 @@ M0_INTERNAL void m0_be_tx_init(struct m0_be_tx    *tx,
 			       void               *datum)
 {
 	m0_sm_init(&tx->t_sm, &tx_sm_conf, M0_BTS_PREPARE, sm_group);
-	tx->t_ast.sa_cb = _tx_state_set;
+	tx->t_ast.sa_cb = _tx_group;
 
 	tx->t_id = tid;
 	tx->t_be = be;
@@ -523,22 +517,20 @@ static void tx_fail(struct m0_be_tx *tx, int err)
 	M0_POST(m0_be__tx_invariant(tx));
 }
 
-static void
-_tx_state_set(struct m0_sm_group *grp M0_UNUSED, struct m0_sm_ast *ast)
+static void _tx_group(struct m0_sm_group *grp M0_UNUSED, struct m0_sm_ast *ast)
 {
-	struct m0_be_tx    *tx = container_of(ast, struct m0_be_tx, t_ast);
-	enum m0_be_tx_state state = (enum m0_be_tx_state)ast->sa_datum;
+	struct m0_be_tx *tx = container_of(ast, struct m0_be_tx, t_ast);
 
 	M0_ENTRY();
-	M0_PRE(IS_IN_ARRAY(state, tx_states));
+	M0_PRE(!tx->t_group->tg_opened);
 
-	m0_be__tx_state_set(tx, state);
+	m0_be__tx_state_set(tx, M0_BTS_GROUPED);
+	m0_ref_put(ast->sa_datum);
 
 	M0_LEAVE();
 }
 
-M0_INTERNAL void
-m0_be__tx_state_post(struct m0_be_tx *tx, enum m0_be_tx_state next_state)
+M0_INTERNAL void m0_be__tx_group_post(struct m0_be_tx *tx, struct m0_ref *ref)
 {
 	/*
 	 * tx_group's fom and tx's sm may belong different sm_groups (e.g.,
@@ -560,11 +552,10 @@ m0_be__tx_state_post(struct m0_be_tx *tx, enum m0_be_tx_state next_state)
 	 * tx's sm is locked. In order to advance tx's sm, ->fo_tick()
 	 * implementation should post an AST to tx's sm_group.
 	 */
-	M0_ENTRY("next_state=%u", next_state);
-	M0_PRE(next_state == M0_BTS_GROUPED);
-	M0_PRE(tx->t_ast.sa_cb == _tx_state_set);
+	M0_ENTRY();
+	M0_PRE(tx->t_ast.sa_cb == _tx_group);
 
-	tx->t_ast.sa_datum = (void *)next_state;
+	tx->t_ast.sa_datum = ref;
 	m0_sm_ast_post(tx->t_sm.sm_grp, &tx->t_ast);
 
 	M0_LEAVE();
@@ -631,26 +622,6 @@ static struct m0_be_tx *sm_to_tx(struct m0_sm *mach)
 	return container_of(mach, struct m0_be_tx, t_sm); /* XXX bob_of() */
 }
 
-static int grouped_st_in(struct m0_sm *mach)
-{
-	struct m0_be_tx_group *gr = sm_to_tx(mach)->t_group;
-
-	M0_ENTRY();
-	M0_PRE(!gr->tg_opened);
-
-#if 0 /*XXX*/
-	m0_ref_put(&gr->tg_nr_ungrouped);
-#else
-	/* XXX TODO: Replace with m0_ref_put(). See also documentation of
-	 * m0_be_tx_group::tg_nr_ungrouped. */
-	M0_CNT_DEC(gr->tg_nr_ungrouped); /* XXX atomic! */
-	if (gr->tg_nr_ungrouped == 0)
-		m0_fom_wakeup(gr->tg_fom);
-#endif
-	M0_LEAVE();
-	return -1;
-}
-
 static int placed_st_in(struct m0_sm *mach)
 {
 	M0_ENTRY("t_glob_stable=%d", !!sm_to_tx(mach)->t_glob_stable);
diff --git a/be/tx.h b/be/tx.h
index 022b229..5a8958a 100644
--- a/be/tx.h
+++ b/be/tx.h
@@ -22,24 +22,11 @@
 #ifndef __MERO_BE_TX_H__
 #define __MERO_BE_TX_H__
 
-#include "lib/rwlock.h"
-#include "lib/tlist.h"
-#include "lib/types.h"
-#include "lib/refs.h"
-#include "sm/sm.h"
-#include "be/tx_group.h"
 #include "be/tx_log.h"
+#include "be/tx_group.h"
 #include "be/tx_regmap.h"
 
-/** @todo XXX FIXME (added by Max as a temporary fix of compilation error) */
-typedef uint64_t m0_bindex_lsn;
-
-struct m0_stob;
-struct m0_be;
-struct m0_be_tx_engine;
-struct m0_be_tx;
-struct m0_be_reg_d;
-struct m0_be_reg;
+struct m0_ref;
 
 /**
  * @defgroup be
@@ -455,10 +442,10 @@ M0_INTERNAL void m0_be__tx_state_set(struct m0_be_tx *tx,
 M0_INTERNAL enum m0_be_tx_state m0_be__tx_state(const struct m0_be_tx *tx);
 
 /**
- * Posts an AST that will advance transaction's state machine to given state.
+ * Posts an AST that will move transaction's state machine to
+ * M0_BTS_GROUPED state and decrement provided reference counter.
  */
-M0_INTERNAL void m0_be__tx_state_post(struct m0_be_tx *tx,
-				      enum m0_be_tx_state next_state);
+M0_INTERNAL void m0_be__tx_group_post(struct m0_be_tx *tx, struct m0_ref *ref);
 
 M0_TL_DESCR_DECLARE(tx, M0_EXTERN);
 M0_TL_DECLARE(tx, M0_INTERNAL, struct m0_be_tx);
diff --git a/be/tx_fom.c b/be/tx_fom.c
index 0049ab5..6705835 100644
--- a/be/tx_fom.c
+++ b/be/tx_fom.c
@@ -61,7 +61,6 @@ M0_UNUSED static void _arm_io(struct m0_be_op *op)
 }
 #endif /* XXX >>>>>>> */
 
-
 static struct tx_group_fom *tx_group_fom(const struct m0_fom *fom);
 static void tx_group_fom_fini(struct m0_fom *fom);
 
@@ -186,6 +185,11 @@ struct tx_group_fom {
 	struct m0_fom_timeout   tgf_timeout;
 	bool                    tgf_timed_out;
 	struct m0_be_op         tgf_op;
+	/**
+	 * The number of transactions that have been added to the tx_group
+	 * but have not switched to M0_BTS_GROUPED state yet.
+	 */
+	struct m0_ref           tgf_nr_ungrouped;
 	struct m0_be_tx        *tgf_tx_to_place;
 	struct m0_semaphore     tgf_started;
 };
@@ -255,22 +259,22 @@ static const struct m0_fom_type_ops tx_group_fom_type_ops = {
 static struct m0_fom *
 tx_group_fom_create(struct m0_reqh *reqh, struct m0_be_tx_engine *engine)
 {
-	struct tx_group_fom *txm;
+	struct tx_group_fom *m;
 	struct m0_fom *fom;
 
-	M0_ALLOC_PTR(txm);
-	if (txm == NULL)
+	M0_ALLOC_PTR(m);
+	if (m == NULL)
 		return NULL;
 
-	fom = &txm->tgf_gen;
+	fom = &m->tgf_gen;
 	m0_fom_init(fom, &tx_group_fom_type, &tx_group_fom_ops, NULL, NULL,
 		    reqh, &m0_be_txs_stype);
 
 	engine->te_fom = fom;
-	txm->tgf_engine = engine;
-	m0_fom_timeout_init(&txm->tgf_timeout);
-	txm->tgf_timed_out = false;
-	m0_semaphore_init(&txm->tgf_started, 0);
+	m->tgf_engine = engine;
+	m0_fom_timeout_init(&m->tgf_timeout);
+	m->tgf_timed_out = false;
+	m0_semaphore_init(&m->tgf_started, 0);
 
 	return fom;
 }
@@ -333,6 +337,13 @@ static bool add_if_grp_has_space(struct m0_be_tx_group *gr, struct m0_be_tx *tx)
 	return true; /*XXX*/
 }
 
+static void wake(struct m0_ref *ref)
+{
+	struct tx_group_fom *m = container_of(ref, struct tx_group_fom,
+					      tgf_nr_ungrouped);
+	m0_fom_wakeup(&m->tgf_gen);
+}
+
 static enum m0_fom_phase_outcome open_tick(struct m0_fom *fom)
 {
 	struct tx_group_fom    *m   = tx_group_fom(fom);
@@ -359,10 +370,11 @@ static enum m0_fom_phase_outcome open_tick(struct m0_fom *fom)
 		       !!ready_to_close, !!m->tgf_timed_out);
 
 		m->tgf_timed_out = false;
-		gr->tg_nr_ungrouped = gr_tlist_length(&gr->tg_txs);
 
+		m0_ref_init(&m->tgf_nr_ungrouped, gr_tlist_length(&gr->tg_txs),
+			    wake);
 		m0_tl_for(gr, &gr->tg_txs, tx) {
-			m0_be__tx_state_post(tx, M0_BTS_GROUPED);
+			m0_be__tx_group_post(tx, &m->tgf_nr_ungrouped);
 		} m0_tl_endfor;
 
 		tx_group_close(eng, gr);
@@ -389,7 +401,7 @@ static enum m0_fom_phase_outcome logging_tick(struct m0_fom *fom)
 	struct m0_be_op        *op  = &m->tgf_op;
 
 	M0_ENTRY();
-	M0_PRE(gr->tg_nr_ungrouped == 0);
+	M0_PRE(m0_ref_read(&m->tgf_nr_ungrouped) == 0);
 	M0_PRE(m0_tl_forall(gr, tx, &gr->tg_txs,
 			    m0_be__tx_state(tx) == M0_BTS_GROUPED));
 
diff --git a/be/tx_group.h b/be/tx_group.h
index c436071..7644510 100644
--- a/be/tx_group.h
+++ b/be/tx_group.h
@@ -67,15 +67,6 @@ struct m0_be_tx_group {
 	/** List of transactions in the group. */
 	struct m0_tl           tg_txs;
 
-	/**
-	 * The number of transactions that have been added to this group
-	 * but have not switched to M0_BTS_GROUPED state yet.
-	 *
-	 * XXX TODO: Use atomic m0_ref. ->tg_pending_count is decremented by
-	 * tx's AST callback, which may belong different m0_sm_group.
-	 */
-	uint32_t               tg_nr_ungrouped;
-
 	/** fom which processes current group */
 	struct m0_fom         *tg_fom;
 };
-- 
1.8.3.2

