From ab8d738b46150edb1956696bf8c1ec098dd92db1 Mon Sep 17 00:00:00 2001
From: "Valery V. Vorotyntsev" <valery_vorotyntsev@xyratex.com>
Date: Wed, 3 Jul 2013 02:40:09 +0300
Subject: [PATCH 269/290] be: add a reference counter to struct m0_be_tx

Add m0_be_tx::t_ref field and m0_be__tx_{get,put}() functions.

- Increment the counter when a transaction is opened (i.e., when it
  enters M0_BTS_ACTIVE state).
- Decrement the counter when a transaction becomes M0_BTS_PLACED.
- m0_be_tx_stable() decrements the counter.
- Call m0_be_tx::t_discarded when the counter reaches 0.

+ Disallow transition from M0_BTS_PREPARE to M0_BTS_ACTIVE.
---
 be/tx.c | 142 +++++++++++++++++++++++++++++++++++++++++++++++-----------------
 be/tx.h |  18 +++++---
 2 files changed, 117 insertions(+), 43 deletions(-)

diff --git a/be/tx.c b/be/tx.c
index 6b71d5f..39e680a 100644
--- a/be/tx.c
+++ b/be/tx.c
@@ -40,6 +40,9 @@
  * @{
  */
 
+static int active_st_in(struct m0_sm *mach);
+static int placed_st_in(struct m0_sm *mach);
+
 M0_TL_DESCR_DEFINE(tx, "transactions", M0_INTERNAL, struct m0_be_tx,
 		   t_linkage, t_magic,
 		   M0_TRACE_TX_MAGIC,
@@ -47,10 +50,10 @@ M0_TL_DESCR_DEFINE(tx, "transactions", M0_INTERNAL, struct m0_be_tx,
 
 M0_TL_DEFINE(tx, M0_INTERNAL, struct m0_be_tx);
 
-static bool tx_state_invariant(const struct m0_sm *sm)
+static bool tx_state_invariant(const struct m0_sm *mach)
 {
 	return m0_be__tx_invariant(
-		container_of(sm, const struct m0_be_tx, t_sm));
+		container_of(mach, const struct m0_be_tx, t_sm));
 }
 
 static struct m0_sm_state_descr tx_states[M0_BTS_NR] = {
@@ -65,16 +68,29 @@ static struct m0_sm_state_descr tx_states[M0_BTS_NR] = {
 	_S(M0_BTS_FAILED,  M0_SDF_FAILURE, 0),
 	_S(M0_BTS_PREPARE, M0_SDF_INITIAL, M0_BITS(M0_BTS_PREPARE,
 						   M0_BTS_OPENING,
+#if 0 /* XXX I don't think we should allow transition from PREPARE to ACTIVE.
+       * --vvv */
 						   M0_BTS_ACTIVE,
+#endif
 						   M0_BTS_FAILED)),
-	_S(M0_BTS_OPENING,   0, M0_BITS(M0_BTS_ACTIVE, M0_BTS_FAILED)),
-	_S(M0_BTS_ACTIVE,    0, M0_BITS(M0_BTS_ACTIVE, M0_BTS_CLOSED)),
+	_S(M0_BTS_OPENING, 0, M0_BITS(M0_BTS_ACTIVE, M0_BTS_FAILED)),
+	[M0_BTS_ACTIVE] = {
+		.sd_name      = "M0_BTS_ACTIVE",
+		.sd_in        = active_st_in,
+		.sd_invariant = tx_state_invariant,
+		.sd_alloved   = M0_BITS(M0_BTS_ACTIVE, M0_BTS_CLOSED)
+	},
 	_S(M0_BTS_CLOSED,    0, M0_BITS(M0_BTS_GROUPED)),
 	_S(M0_BTS_GROUPED,   0, M0_BITS(M0_BTS_SUBMITTED)),
 	_S(M0_BTS_SUBMITTED, 0, M0_BITS(M0_BTS_LOGGED)),
 	_S(M0_BTS_LOGGED,    0, M0_BITS(M0_BTS_PLACED)),
-	_S(M0_BTS_PLACED,    0, M0_BITS(M0_BTS_STABLE)),
-	_S(M0_BTS_STABLE,    M0_SDF_TERMINAL, 0)
+	[M0_BTS_PLACED] = {
+		.sd_name      = "M0_BTS_PLACED",
+		.sd_in        = placed_st_in,
+		.sd_invariant = tx_state_invariant,
+		.sd_alloved   = M0_BITS(M0_BTS_STABLE)
+	},
+	_S(M0_BTS_STABLE, M0_SDF_TERMINAL, 0)
 #undef _S
 };
 
@@ -94,6 +110,7 @@ static void        tx_engine_got_closed(struct m0_be_tx_engine *eng,
 static void        tx_engine_lock      (struct m0_be_tx_engine *eng);
 static void        tx_engine_unlock    (struct m0_be_tx_engine *eng);
 static bool        tx_is_locked        (const struct m0_be_tx *tx);
+static void        tx_release          (struct m0_ref *ref);
 
 M0_INTERNAL void m0_be_tx_engine_init(struct m0_be_tx_engine *engine)
 {
@@ -125,15 +142,18 @@ M0_INTERNAL void m0_be_tx_init(struct m0_be_tx *tx, uint64_t tid,
 			       void *datum)
 {
 	m0_sm_init(&tx->t_sm, &tx_sm_conf, M0_BTS_PREPARE, tx_grp);
-	tx->t_id	 = tid;
-	tx->t_be	 = be;
+	tx->t_id = tid;
+	tx->t_be = be;
+
+	tx_tlink_init_at(tx, &tx_engine(tx)->te_txs[M0_BTS_PREPARE]);
+	gr_tlink_init(tx);
+	m0_ref_init(&tx->t_ref, 1, tx_release);
+
+	m0_be_tx_credit_init(&tx->t_prepared);
 	tx->t_persistent = persistent;
 	tx->t_discarded	 = discarded;
 	tx->t_filler	 = filler;
 	tx->t_datum	 = datum;
-	m0_be_tx_credit_init(&tx->t_prepared);
-	tx_tlink_init_at(tx, &tx_engine(tx)->te_txs[M0_BTS_PREPARE]);
-	gr_tlink_init(tx);
 
 	M0_POST(m0_be__tx_invariant(tx));
 }
@@ -404,12 +424,11 @@ M0_INTERNAL void m0_be_tx_stable(struct m0_be_tx *tx)
 {
 	M0_ENTRY();
 	M0_PRE(m0_be__tx_invariant(tx));
-	M0_PRE(m0_be__tx_state(tx) == M0_BTS_PLACED);
+	M0_PRE(M0_IN(m0_be__tx_state(tx), (M0_BTS_LOGGED, M0_BTS_PLACED)));
 	M0_PRE(tx_is_locked(tx));
 
 	m0_be__tx_state_set(tx, M0_BTS_STABLE);
-	if (tx->t_discarded != NULL)
-		tx->t_discarded(tx);
+	m0_be__tx_put(tx);
 	m0_fom_wakeup(tx_engine(tx)->te_fom);
 
 	M0_LEAVE();
@@ -477,6 +496,26 @@ static void tx_open_tail(struct m0_be_tx *tx)
 	m0_be__tx_state_set(tx, M0_BTS_ACTIVE);
 }
 
+M0_INTERNAL void m0_be__tx_get(struct m0_be_tx *tx)
+{
+	M0_ENTRY();
+	M0_PRE(tx_is_locked(tx));
+
+	m0_ref_get(&tx->t_ref);
+
+	M0_LEAVE();
+}
+
+M0_INTERNAL void m0_be__tx_put(struct m0_be_tx *tx)
+{
+	M0_ENTRY();
+	M0_PRE(tx_is_locked(tx));
+
+	m0_ref_put(&tx->t_ref);
+
+	M0_LEAVE();
+}
+
 M0_INTERNAL enum m0_be_tx_state m0_be__tx_state(const struct m0_be_tx *tx)
 {
 	return tx->t_sm.sm_state;
@@ -501,6 +540,16 @@ m0_be__tx_state_set(struct m0_be_tx *tx, enum m0_be_tx_state state)
 	M0_POST(m0_be__tx_invariant(tx));
 }
 
+static void tx_fail(struct m0_be_tx *tx, int err)
+{
+	M0_PRE(m0_be__tx_invariant(tx));
+
+	m0_sm_fail(&tx->t_sm, M0_BTS_FAILED, err);
+	tx_tlist_del(tx);
+
+	M0_POST(m0_be__tx_invariant(tx));
+}
+
 static void
 _tx_state_set(struct m0_sm_group *grp M0_UNUSED, struct m0_sm_ast *ast)
 {
@@ -547,16 +596,6 @@ m0_be__tx_state_post(struct m0_be_tx *tx, enum m0_be_tx_state state)
 	M0_LEAVE();
 }
 
-static void tx_fail(struct m0_be_tx *tx, int err)
-{
-	M0_PRE(m0_be__tx_invariant(tx));
-
-	m0_sm_fail(&tx->t_sm, M0_BTS_FAILED, err);
-	tx_tlist_del(tx);
-
-	M0_POST(m0_be__tx_invariant(tx));
-}
-
 static struct m0_be_tx_engine *tx_engine(const struct m0_be_tx *tx)
 {
 	return &tx->t_be->b_tx;
@@ -575,8 +614,7 @@ static void tx_engine_unlock(struct m0_be_tx_engine *eng)
 M0_INTERNAL bool
 m0_be__tx_engine_invariant(const struct m0_be_tx_engine *engine)
 {
-	struct m0_be_tx		     *prev = NULL;
-	const struct m0_be_tx_engine *te   = engine;
+	struct m0_be_tx *prev = NULL;
 
 	return true || ( /* XXX RESTOREME */
 		m0_forall(i, M0_BTS_NR,
@@ -586,12 +624,11 @@ m0_be__tx_engine_invariant(const struct m0_be_tx_engine *engine)
 					    t->t_lsn != 0 &&
 					    prev->t_lsn > t->t_lsn) &&
 				       (prev = t, true))) &&
-		te->te_start->t_lsn <= te->te_placed->t_lsn &&
-		te->te_placed->t_lsn <= te->te_logged->t_lsn &&
-		te->te_logged->t_lsn <= te->te_submitted->t_lsn &&
-		te->te_submitted->t_lsn <= te->te_inmem->t_lsn &&
-
-		tx_engine_free_space(te) <= te->te_log.lg_size );
+		engine->te_start->t_lsn <= engine->te_placed->t_lsn &&
+		engine->te_placed->t_lsn <= engine->te_logged->t_lsn &&
+		engine->te_logged->t_lsn <= engine->te_submitted->t_lsn &&
+		engine->te_submitted->t_lsn <= engine->te_inmem->t_lsn &&
+		tx_engine_free_space(engine) <= engine->te_log.lg_size);
 }
 
 M0_INTERNAL bool m0_be__tx_invariant(const struct m0_be_tx *tx)
@@ -607,19 +644,48 @@ M0_INTERNAL bool m0_be__tx_invariant(const struct m0_be_tx *tx)
 		(tx->t_leader == (tx->t_group != NULL &&
 				  tx == gr_tlist_head(&tx->t_group->tg_txs))) &&
 		(tx->t_group != NULL) == gr_tlist_contains(&tx->t_group->tg_txs,
-							   tx)
-		);
+							   tx));
 }
 
-/**
- * Returns true iff the locality, which given transaction is associated with,
- * is locked.
- */
 static bool tx_is_locked(const struct m0_be_tx *tx)
 {
 	return m0_mutex_is_locked(&tx->t_sm.sm_grp->s_lock);
 }
 
+static void tx_release(struct m0_ref *ref)
+{
+	const struct m0_be_tx *tx = /* XXX TODO bob_of() */
+		container_of(ref, const struct m0_be_tx, t_ref);
+	M0_ENTRY();
+	M0_PRE(m0_be__tx_invariant(tx));
+
+	if (tx->t_discarded != NULL)
+		tx->t_discarded(tx);
+	M0_LEAVE();
+}
+
+static int active_st_in(struct m0_sm *mach)
+{
+	struct m0_be_tx *tx = container_of(mach, struct m0_be_tx, t_sm);
+	M0_ENTRY();
+
+	m0_be__tx_get(&tx->t_ref);
+
+	M0_LEAVE();
+	return -1;
+}
+
+static int placed_st_in(struct m0_sm *mach)
+{
+	struct m0_be_tx *tx = container_of(mach, struct m0_be_tx, t_sm);
+	M0_ENTRY();
+
+	m0_be__tx_put(&tx->t_ref);
+
+	M0_LEAVE();
+	return -1;
+}
+
 /** @} struct of be group */
 #undef M0_TRACE_SUBSYSTEM
 
diff --git a/be/tx.h b/be/tx.h
index 93356fb..4e998fc 100644
--- a/be/tx.h
+++ b/be/tx.h
@@ -351,8 +351,15 @@ struct m0_be_tx {
 	struct m0_be          *t_be;
 	/** Linkage in one of m0_be_tx_engine::te_txs[] lists. */
 	struct m0_tlink        t_linkage;
+	/**
+	 * The group the transaction is part of. This is non-NULL iff the
+	 * transaction is in GROUPED or later state.
+	 */
+	struct m0_be_tx_group *t_group;
 	/** Linkage in m0_be_tx_group::tg_txs. */
 	struct m0_tlink        t_group_linkage;
+	/** XXX DOCUMENTME */
+	struct m0_ref          t_ref;
 	/**
 	 * Size (in bytes) of "payload area" in the transaction log header,
 	 * reserved for user.
@@ -365,11 +372,6 @@ struct m0_be_tx {
 	struct m0_be_tx_credit t_prepared;
 	struct m0_be_reg_area  t_reg_area;
 	/**
-	 * The group the transaction is part of. This is non-NULL iff the
-	 * transaction is in GROUPED or later state.
-	 */
-	struct m0_be_tx_group *t_group;
-	/**
 	 * True iff the transaction is the first transaction in the group. In
 	 * this case, the overhead of group (specifically, the size of group
 	 * header and group commit log) are "billed" to the transaction.
@@ -450,6 +452,12 @@ M0_INTERNAL int m0_be_tx_timedwait(struct m0_be_tx *tx, int state,
  */
 M0_INTERNAL void m0_be_tx_stable(struct m0_be_tx *tx);
 
+/** Increments transaction's reference counter (m0_be_tx::t_ref). */
+M0_INTERNAL void m0_be__tx_get(struct m0_be_tx *tx);
+
+/** Decrements transaction's reference counter (m0_be_tx::t_ref). */
+M0_INTERNAL void m0_be__tx_put(struct m0_be_tx *tx);
+
 M0_INTERNAL void m0_be__tx_state_set(struct m0_be_tx *tx,
 				     enum m0_be_tx_state state);
 M0_INTERNAL enum m0_be_tx_state m0_be__tx_state(const struct m0_be_tx *tx);
-- 
1.8.3.2

