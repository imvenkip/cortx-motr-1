From 4395980e0b72b4bd5454dd94e76617c7c5090c9f Mon Sep 17 00:00:00 2001
From: "Valery V. Vorotyntsev" <valery_vorotyntsev@xyratex.com>
Date: Tue, 25 Jun 2013 00:04:34 +0300
Subject: [PATCH 210/290] be: minor documentation fixes in tx.[hc]

---
 be/tx.c | 14 ++++++--------
 be/tx.h |  8 ++++----
 2 files changed, 10 insertions(+), 12 deletions(-)

diff --git a/be/tx.c b/be/tx.c
index e284eff..d08ce6e 100644
--- a/be/tx.c
+++ b/be/tx.c
@@ -306,7 +306,7 @@ m0_be_tx_capture(struct m0_be_tx *tx, const struct m0_be_reg *reg)
 		oldnode = tsearch(new, &tx->t_root, &tx_reg_cmp);
 		M0_ASSERT(oldnode != NULL);
 		old = oldnode->bn_reg_d;
-		M0_ASSERT(old != prev); /* check that we are not stuck. */
+		M0_ASSERT(old != prev); /* check that we are not stuck */
 
 		/*
 		 * tsearch() returns either an existing tree element with the
@@ -315,7 +315,7 @@ m0_be_tx_capture(struct m0_be_tx *tx, const struct m0_be_reg *reg)
 		 * "new" is inserted in the tree.
 		 */
 		if (old == new) {
-			/* no intersection */
+			/* No intersection. */
 			memcpy(new->rd_buf,
 			       new->rd_reg.br_addr, new->rd_reg.br_size);
 			credit_mod(&tx->t_used, new, +1);
@@ -325,14 +325,12 @@ m0_be_tx_capture(struct m0_be_tx *tx, const struct m0_be_reg *reg)
 		tx_reg_ext(old, &eold);
 		tx_reg_ext(new, &enew);
 		if (m0_ext_is_partof(&enew, &eold)) {
-			/* new completely covers old. */
+			/* New completely covers old. */
 			credit_mod(&tx->t_used, old, -1);
 			tdelete(old, &tx->t_root, &tx_reg_cmp);
 			M0_SET0(old);
 		} else {
-			/*
-			 * New and old regions partially overlap.
-			 */
+			/* New and old regions partially overlap. */
 			m0_bcount_t oleft;
 			m0_bcount_t nleft;
 			m0_bcount_t nright;
@@ -351,7 +349,7 @@ m0_be_tx_capture(struct m0_be_tx *tx, const struct m0_be_reg *reg)
 			/*
 			 * Following cases are possible:
 			 *
-			 *    nright == 0, oleft == 0, nright > 0
+			 *    nleft > 0, nright == 0, oleft == 0
 			 *
 			 *                  nleft    common
 			 *    new:        [--------+--------]
@@ -366,7 +364,7 @@ m0_be_tx_capture(struct m0_be_tx *tx, const struct m0_be_reg *reg)
 			 *                oleft
 			 *
 			 *
-			 *    nright == 0 && nleft == 0
+			 *    nleft == 0 && nright == 0
 			 *
 			 *                           common
 			 *    new:                 [--------]
diff --git a/be/tx.h b/be/tx.h
index 79e5203..c5810ca 100644
--- a/be/tx.h
+++ b/be/tx.h
@@ -120,7 +120,7 @@ struct m0_be_reg;
  *                        V
  *                     OPENING---------->FAILED
  *                        |
- *                        | open_tail()
+ *                        | tx_open_tail()
  *                        |
  *                        V
  *                      ACTIVE------+
@@ -296,7 +296,7 @@ struct m0_be_tx_engine {
 	/** Transactional log. */
 	struct m0_be_log      te_log;
 	/**
-	 * Transactional group. (Currently the only one.)
+	 * Transactional group. (Currently there is only one.)
 	 */
 	struct m0_be_tx_group te_group;
 
@@ -311,7 +311,7 @@ struct m0_be_tx_engine {
 	struct m0_be_tx      *te_inmem;
 
 	/**
-	 * Total space reserved for transactions active transactions.
+	 * Total space reserved for active transactions.
 	 *
 	 * This space is reserved by m0_tx_open(). When a transaction closes
 	 * (m0_be_tx_close()), the difference between reserved and actually used
@@ -433,7 +433,7 @@ struct m0_be_tx {
 	/**
 	 * An optional call-back called when the transaction is being closed.
 	 *
-	 * "payload" parameter is the pointer to a m0_be_tx::t_payload-sized
+	 * "payload" parameter is the pointer to a m0_be_tx::t_payload_size-d
 	 * buffer, that will be written to the log.
 	 *
 	 * ->t_filler() can capture regions in the transaction.
-- 
1.8.3.2

