From ec3e24313d992ab4b7636fa4785e7a8d3feef9be Mon Sep 17 00:00:00 2001
From: Anatoliy Bilenko <anatoliy_bilenko@xyratex.com>
Date: Fri, 31 May 2013 20:29:45 +0300
Subject: [PATCH 084/290] be: Updated btree DLD.

---
 be/btree.h | 149 ++++++++++++++++++++++++++++++++++++++++++++++++++++---------
 1 file changed, 127 insertions(+), 22 deletions(-)

diff --git a/be/btree.h b/be/btree.h
index 8dba1b5..2701046 100644
--- a/be/btree.h
+++ b/be/btree.h
@@ -75,23 +75,41 @@ struct m0_be_btree_kv_ops {
  * Initalises internal structures of @tree and sets its root node to @root.
  * @root has to point on data lying inside @seg mapping.
  * In case when root == NULL, following m0_be_btree_create() sets tree root.
+ *
+ * @param root[in] root node of the tree stored in the m0_be_segment. If root is
+ *                 NULL following m0_be_btree_create() call will create new root
  */
 M0_INTERNAL void m0_be_btree_init(struct m0_be_btree *tree,
 				  struct m0_be_seg   *seg,
 				  const struct m0_be_btree_kv_ops *ops,
 				  struct m0_be_bnode *root);
 
+/**
+ * Finalizes in-memory structures of btree. Doesn't touch segment on the disk.
+ * @see m0_be_btree_destroy() call with does it on the disk.
+ */
 M0_INTERNAL void m0_be_btree_fini(struct m0_be_btree *tree);
 
-/*
+/**
+ * Creates btree in its segment. Operation is asynchronous. User has to rely on
+ * op::bo_sm state. When it transits into M0_BOS_SUCCESS btree is created in the
+ * segment. In case of failure op::bo_sm is transitted into M0_BOS_FAILURE.
+ *
+ * User has to use either m0_be_op_wait() or m0_be_op_tick_ret() when it's
+ * needed to know that operation is finished.
+ *
  * Use case:
  *     m0_be_btree_init(&tree, seg, NULL);
  *     m0_be_btree_create(&tree, tx, op);
+ *     M0_ASSERT(m0_be_op_wait(op) == 0); // tree is created in its segment...
  */
 M0_INTERNAL void m0_be_btree_create(struct m0_be_btree *tree,
 				    struct m0_be_tx *tx,
 				    struct m0_be_op *op);
 
+/**
+ * Destroys btree in its segment. @see m0_be_btree_create for more details.
+ */
 M0_INTERNAL void m0_be_btree_destroy(struct m0_be_btree *tree,
 				     struct m0_be_tx *tx,
 				     struct m0_be_op *op);
@@ -101,37 +119,93 @@ M0_INTERNAL void m0_be_btree_destroy(struct m0_be_btree *tree,
  * Btree manipulation interface
  * ------------------------------------------------------------------ */
 
-M0_INTERNAL void m0_be_btree_maxkey(const struct m0_be_btree *tree,
-				    struct m0_be_op *op,
-				    struct m0_buf *out);
-
-M0_INTERNAL void m0_be_btree_lookup(struct m0_be_btree *tree,
-				    struct m0_be_op *op,
-				    const struct m0_buf *key,
-				    struct m0_buf *dest_buf);
-
+/**
+ * Calculates how many internal resources of tx_engine, described by
+ * m0_be_tx_credit, is needed to perform an operation over the @tree.
+ * Function updates @accum structure which is an input for m0_be_tx_prep().
+ *
+ * @param optype operation type over the tree.
+ * @param nr     number of @optype operations.
+ */
 M0_INTERNAL void m0_be_btree_credit(const struct m0_be_btree *tree,
 				    enum m0_be_btree_op optype,
 				    m0_bcount_t nr,
 				    struct m0_be_tx_credit *accum);
 
+/**
+ * Inserts @key and @value into btree. Operation is asynchronous.
+ *
+ * Note0: interface is asynchronous and relies on op::bo_sm and tx::bt_sm.
+ * When op::bo_sm transits into M0_BOS_SUCCESS | M0_BOS_FAILURE and tx::bt_sm
+ * transits into M0_BTS_STABLE | M0_BTS_FAILED, operation is considered to be
+ * finished.
+ *
+ * Note1: When op::bo_sm state transits from M0_BOS_INIT into M0_BOS_SUCCESS
+ * then page where requested memory regions of the tree is loaded from the disk
+ * into the mmaped segment.
+ *
+ * Note2: When tx::bt_sm state transits from M0_BTS_INIT into M0_BTS_PLACED
+ * or M0_BTS_STABLE then data passed to the function in @key and @value become
+ * persistent.
+ *
+ * Note3: User has to aquire m0_be_tx_engine::te_lock before this call,
+ * m0_be_btree::bb_lock is being held inside this function.
+ */
 M0_INTERNAL void m0_be_btree_insert(struct m0_be_btree *tree,
 				    struct m0_be_tx *tx,
 				    struct m0_be_op *op,
 				    const struct m0_buf *key,
 				    const struct m0_buf *value);
 
+/**
+ * Updates @key and @value into btree. Operation is asynchronous.
+ *
+ * @see m0_be_btree_insert()
+ */
 M0_INTERNAL void m0_be_btree_update(struct m0_be_btree *tree,
 				    struct m0_be_tx *tx,
 				    struct m0_be_op *op,
 				    const struct m0_buf *key,
 				    const struct m0_buf *value);
 
+/**
+ * Deletes @key and @value into btree. Operation is asynchronous.
+ *
+ * @see m0_be_btree_insert()
+ */
 M0_INTERNAL void m0_be_btree_delete(struct m0_be_btree *tree,
 				    struct m0_be_tx *tx,
 				    struct m0_be_op *op,
 				    const struct m0_buf *key);
 
+/**
+ * Looks up for a @dest_value for the given @key.
+ *
+ * @see m0_be_btree_create() regarding @op structure "mission".
+ */
+M0_INTERNAL void m0_be_btree_lookup(struct m0_be_btree *tree,
+				    struct m0_be_op *op,
+				    const struct m0_buf *key,
+				    struct m0_buf *dest_value);
+
+/**
+ * Looks up for a maximum key value in the given @tree.
+ *
+ * @see m0_be_btree_create() regarding @op structure "mission".
+ */
+M0_INTERNAL void m0_be_btree_maxkey(const struct m0_be_btree *tree,
+				    struct m0_be_op *op,
+				    struct m0_buf *out);
+
+/**
+ * Looks up for a minimum key value in the given @tree.
+ *
+ * @see m0_be_btree_create() regarding @op structure "mission".
+ */
+M0_INTERNAL void m0_be_btree_minkey(const struct m0_be_btree *tree,
+				    struct m0_be_op *op,
+				    struct m0_buf *out);
+
 
 /* ------------------------------------------------------------------
  * Btree inplace manipulation interface
@@ -155,24 +229,56 @@ struct m0_be_btree_anchor {
 	bool          ba_write;
 };
 
-M0_INTERNAL void m0_be_btree_lookup_inplace(struct m0_be_btree *tree,
+/**
+ * XXX: this interface needs clarification...
+ */
+M0_INTERNAL void m0_be_btree_insert_inplace(struct m0_be_btree *tree,
+					    struct m0_be_tx *tx,
 					    struct m0_be_op *op,
 					    const struct m0_buf *key,
 					    struct m0_be_btree_anchor *anchor);
-
-M0_INTERNAL void m0_be_btree_insert_inplace(struct m0_be_btree *tree,
+/**
+ * Updates @value looked up by given @key in btree. Operation is asynchronous.
+ *
+ * @see m0_be_btree_insert, note0 - note2.
+ *
+ * Note3: User has to aquire m0_be_tx_engine::te_lock before this call,
+ * m0_be_btree::bb_lock is being held inside this function. To do this, user has
+ * to set @anchor::ba_write and lock will be held for write if it's true and for
+ * read otherwize.
+ *
+ * Note4: Neither given @key nor @value is copied or allocated in the tree after
+ * this call.
+ *
+ * Usage:
+ *
+ * m0_be_btree_update_inplace(tree, tx, op, key, anchor);
+ * M0_ASSERT(m0_be_op_wait(op) == 0); // wait for the completion...
+ * update(anchor->ba_value.b_addr, anchor->ba_value.b_nob);
+ * m0_be_btree_release(tree, anchor);
+ * ...
+ * m0_be_tx_close(tx);
+ */
+M0_INTERNAL void m0_be_btree_update_inplace(struct m0_be_btree *tree,
 					    struct m0_be_tx *tx,
 					    struct m0_be_op *op,
 					    const struct m0_buf *key,
 					    struct m0_be_btree_anchor *anchor);
 
-M0_INTERNAL void m0_be_btree_update_inplace(struct m0_be_btree *tree,
-					    struct m0_be_tx *tx,
+/**
+ * Looks up a value stored in the @tree by the given @key.
+ *
+ * @see m0_be_btree_update_inplace()
+ */
+M0_INTERNAL void m0_be_btree_lookup_inplace(struct m0_be_btree *tree,
 					    struct m0_be_op *op,
 					    const struct m0_buf *key,
 					    struct m0_be_btree_anchor *anchor);
 
-/** Completes m0_be_btree_*_inplace() operation. */
+/**
+ * Completes m0_be_btree_*_inplace() operation by capturing all affected
+ * regions by calling m0_be_tx_capture() and unlocking m0_be_btree::bb_lock.
+ */
 M0_INTERNAL void m0_be_btree_release(struct m0_be_btree *tree,
 				     const struct m0_be_btree_anchor *anchor);
 
@@ -211,8 +317,9 @@ M0_INTERNAL void m0_be_btree_cursor_fini(struct m0_be_btree_cursor *cursor);
  * Fills cursor internal buffers with current key and value obtained from the
  * tree. Operation may cause IO dependigly on cursor::bc_op state
  *
- * Note: interface is asynchronous and waits on cursor::bc_op::bo_sm to become
- * to transit into M0_BOS_SUCCESS.
+ * Note: interface is asynchronous and relies on cursor::bc_op::bo_sm. When it
+ * transits into M0_BOS_SUCCESS | M0_BOS_FAILURE operation is considered to be
+ * finished.
  */
 M0_INTERNAL void m0_be_btree_cursor_get(struct m0_be_btree_cursor *cursor,
 					const struct m0_buf *key);
@@ -221,8 +328,7 @@ M0_INTERNAL void m0_be_btree_cursor_get(struct m0_be_btree_cursor *cursor,
  * Fills cursor internal buffers with next key and value obtained from the
  * tree. Operation may cause IO dependigly on cursor::bc_op state
  *
- * Note: interface is asynchronous and waits on cursor::bc_op::bo_sm to become
- * to transit into M0_BOS_SUCCESS.
+ * Note: @see m0_be_btree_cursor_get note.
  */
 M0_INTERNAL void m0_be_btree_cursor_next(struct m0_be_btree_cursor *cursor);
 
@@ -230,8 +336,7 @@ M0_INTERNAL void m0_be_btree_cursor_next(struct m0_be_btree_cursor *cursor);
  * Fills cursor internal buffers with prev key and value obtained from the
  * tree. Operation may cause IO dependigly on cursor::bc_op state
  *
- * Note: interface is asynchronous and waits on cursor::bc_op::bo_sm to become
- * to transit into M0_BOS_SUCCESS.
+ * Note: @see m0_be_btree_cursor_get note.
  */
 M0_INTERNAL void m0_be_btree_cursor_prev(struct m0_be_btree_cursor *cursor);
 
-- 
1.8.3.2

