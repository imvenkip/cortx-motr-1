From 0a0254cfcc9f302623613540e3665d0eb5e48a61 Mon Sep 17 00:00:00 2001
From: Maxim Medved <Max_Medved@xyratex.com>
Date: Wed, 26 Jun 2013 16:09:39 +0300
Subject: [PATCH 235/290] be/allocator: capturing added

---
 be/alloc.c     | 331 +++++++++++++++++++++++++++++++++++++++++++++++++--------
 be/alloc.h     |   6 +-
 be/ut/helper.c |   6 +-
 3 files changed, 295 insertions(+), 48 deletions(-)

diff --git a/be/alloc.c b/be/alloc.c
index 07136ac..c41f8f2 100644
--- a/be/alloc.c
+++ b/be/alloc.c
@@ -176,6 +176,208 @@ M0_TL_DESCR_DEFINE(chunks_free, "list of free chunks in m0_be_allocator",
 		   M0_BE_ALLOC_FREE_LINK_MAGIC, M0_BE_ALLOC_FREE_MAGIC);
 M0_TL_DEFINE(chunks_free, static, struct be_alloc_chunk);
 
+static void be_alloc_chunk_capture(struct m0_be_allocator *a,
+				   struct m0_be_tx *tx,
+				   struct be_alloc_chunk *c)
+{
+	/** @todo XXX TODO FIXME temporary hack for allocator UT */
+	if (tx == NULL)
+		return;
+	if (c == NULL)
+		return;
+	M0_BE_TX_CAPTURE_PTR(a->ba_seg, tx, c);
+}
+
+static void be_alloc_head_capture(struct m0_be_allocator *a,
+				  struct m0_be_tx *tx)
+{
+	/** @todo XXX TODO FIXME temporary hack for allocator UT */
+	if (tx == NULL)
+		return;
+	M0_BE_TX_CAPTURE_PTR(a->ba_seg, tx, a->ba_h);
+}
+
+static void chunks_all_tlist_capture_around(struct m0_be_allocator *a,
+					    struct m0_be_tx *tx,
+					    struct be_alloc_chunk *c)
+{
+	struct be_alloc_chunk *cprev;
+	struct be_alloc_chunk *cnext;
+
+	cprev = chunks_all_tlist_prev(&a->ba_h->bah_chunks.bl_list, c);
+	cnext = chunks_all_tlist_next(&a->ba_h->bah_chunks.bl_list, c);
+	be_alloc_chunk_capture(a, tx, c);
+	be_alloc_chunk_capture(a, tx, cprev);
+	be_alloc_chunk_capture(a, tx, cnext);
+	be_alloc_head_capture(a, tx);
+}
+
+static void chunks_free_tlist_capture_around(struct m0_be_allocator *a,
+					     struct m0_be_tx *tx,
+					     struct be_alloc_chunk *c)
+{
+	struct be_alloc_chunk *fprev;
+	struct be_alloc_chunk *fnext;
+
+	fprev = chunks_free_tlist_prev(&a->ba_h->bah_free.bl_list, c);
+	fnext = chunks_free_tlist_next(&a->ba_h->bah_free.bl_list, c);
+	be_alloc_chunk_capture(a, tx, c);
+	be_alloc_chunk_capture(a, tx, fprev);
+	be_alloc_chunk_capture(a, tx, fnext);
+	be_alloc_head_capture(a, tx);
+}
+
+/** @todo XXX temporary wrappers for a list functions */
+static void chunks_all_tlink_init_c(struct m0_be_allocator *a,
+				    struct m0_be_tx *tx,
+				    struct be_alloc_chunk *c)
+{
+	chunks_all_tlink_init(c);
+	be_alloc_chunk_capture(a, tx, c);
+}
+
+static void chunks_free_tlink_init_c(struct m0_be_allocator *a,
+				     struct m0_be_tx *tx,
+				     struct be_alloc_chunk *c)
+{
+	chunks_free_tlink_init(c);
+	be_alloc_chunk_capture(a, tx, c);
+}
+
+static void chunks_all_tlink_fini_c(struct m0_be_allocator *a,
+				    struct m0_be_tx *tx,
+				    struct be_alloc_chunk *c)
+{
+	chunks_all_tlink_fini(c);
+	be_alloc_chunk_capture(a, tx, c);
+}
+
+static void chunks_free_tlink_fini_c(struct m0_be_allocator *a,
+				     struct m0_be_tx *tx,
+				     struct be_alloc_chunk *c)
+{
+	chunks_free_tlink_fini(c);
+	be_alloc_chunk_capture(a, tx, c);
+}
+
+static void chunks_all_tlist_del_c(struct m0_be_allocator *a,
+				   struct m0_be_tx *tx,
+				   struct be_alloc_chunk *c)
+{
+	struct be_alloc_chunk *cprev;
+	struct be_alloc_chunk *cnext;
+
+	cprev = chunks_all_tlist_prev(&a->ba_h->bah_chunks.bl_list, c);
+	cnext = chunks_all_tlist_next(&a->ba_h->bah_chunks.bl_list, c);
+	chunks_all_tlist_del(c);
+	be_alloc_chunk_capture(a, tx, c);
+	be_alloc_chunk_capture(a, tx, cprev);
+	be_alloc_chunk_capture(a, tx, cnext);
+	be_alloc_head_capture(a, tx);
+}
+
+static void chunks_free_tlist_del_c(struct m0_be_allocator *a,
+				    struct m0_be_tx *tx,
+				    struct be_alloc_chunk *c)
+{
+	struct be_alloc_chunk *fprev;
+	struct be_alloc_chunk *fnext;
+
+	fprev = chunks_free_tlist_prev(&a->ba_h->bah_free.bl_list, c);
+	fnext = chunks_free_tlist_next(&a->ba_h->bah_free.bl_list, c);
+	chunks_free_tlist_del(c);
+	be_alloc_chunk_capture(a, tx, c);
+	be_alloc_chunk_capture(a, tx, fprev);
+	be_alloc_chunk_capture(a, tx, fnext);
+	be_alloc_head_capture(a, tx);
+}
+
+static void chunks_free_tlist_add_tail_c(struct m0_be_allocator *a,
+					 struct m0_be_tx *tx,
+					 struct be_alloc_chunk *c)
+{
+	chunks_free_tlist_add_tail(&a->ba_h->bah_free.bl_list, c);
+	chunks_free_tlist_capture_around(a, tx, c);
+}
+
+static void chunks_free_tlist_add_before_c(struct m0_be_allocator *a,
+					   struct m0_be_tx *tx,
+					   struct be_alloc_chunk *next,
+					   struct be_alloc_chunk *c)
+{
+	chunks_free_tlist_add_before(next, c);
+	chunks_free_tlist_capture_around(a, tx, c);
+	chunks_free_tlist_capture_around(a, tx, next);
+}
+
+static void chunks_all_tlist_add_after_c(struct m0_be_allocator *a,
+					 struct m0_be_tx *tx,
+					 struct be_alloc_chunk *c,
+					 struct be_alloc_chunk *new)
+{
+	chunks_all_tlist_add_after(c, new);
+	chunks_all_tlist_capture_around(a, tx, c);
+	chunks_all_tlist_capture_around(a, tx, new);
+}
+
+static void chunks_free_tlist_add_after_c(struct m0_be_allocator *a,
+					  struct m0_be_tx *tx,
+					  struct be_alloc_chunk *c,
+					  struct be_alloc_chunk *new)
+{
+	chunks_free_tlist_add_after(c, new);
+	chunks_free_tlist_capture_around(a, tx, c);
+	chunks_free_tlist_capture_around(a, tx, new);
+}
+
+static void chunks_all_tlist_add_c(struct m0_be_allocator *a,
+				   struct m0_be_tx *tx,
+				   struct be_alloc_chunk *new)
+{
+	chunks_all_tlist_add(&a->ba_h->bah_chunks.bl_list, new);
+	chunks_all_tlist_capture_around(a, tx, new);
+}
+
+static void chunks_free_tlist_add_c(struct m0_be_allocator *a,
+				    struct m0_be_tx *tx,
+				    struct be_alloc_chunk *new)
+{
+	chunks_free_tlist_add(&a->ba_h->bah_free.bl_list, new);
+	chunks_free_tlist_capture_around(a, tx, new);
+}
+
+static void chunks_all_tlist_init_c(struct m0_be_allocator *a,
+				    struct m0_be_tx *tx,
+				    struct m0_tl *l)
+{
+	chunks_all_tlist_init(l);
+	be_alloc_head_capture(a, tx);
+}
+
+static void chunks_free_tlist_init_c(struct m0_be_allocator *a,
+				     struct m0_be_tx *tx,
+				     struct m0_tl *l)
+{
+	chunks_free_tlist_init(l);
+	be_alloc_head_capture(a, tx);
+}
+
+static void chunks_all_tlist_fini_c(struct m0_be_allocator *a,
+				    struct m0_be_tx *tx,
+				    struct m0_tl *l)
+{
+	chunks_all_tlist_fini(l);
+	be_alloc_head_capture(a, tx);
+}
+
+static void chunks_free_tlist_fini_c(struct m0_be_allocator *a,
+				     struct m0_be_tx *tx,
+				     struct m0_tl *l)
+{
+	chunks_free_tlist_fini(l);
+	be_alloc_head_capture(a, tx);
+}
+
 static bool be_alloc_is_mem_in_allocator(struct m0_be_allocator *a,
 					 m0_bcount_t size, const void *ptr)
 {
@@ -235,6 +437,7 @@ static bool be_alloc_chunk_invariant(struct m0_be_allocator *a,
 }
 
 static void be_alloc_chunk_init(struct m0_be_allocator *a,
+				struct m0_be_tx *tx,
 				struct be_alloc_chunk *c,
 				m0_bcount_t size, bool free)
 {
@@ -244,19 +447,20 @@ static void be_alloc_chunk_init(struct m0_be_allocator *a,
 		.bac_free   = free,
 		.bac_magic1 = M0_BE_ALLOC_MAGIC1,
 	};
-	chunks_all_tlink_init(c);
-	chunks_free_tlink_init(c);
+	chunks_all_tlink_init_c(a, tx, c);
+	chunks_free_tlink_init_c(a, tx, c);
 }
 
 static void be_alloc_chunk_del_fini(struct m0_be_allocator *a,
+				    struct m0_be_tx *tx,
 				    struct be_alloc_chunk *c)
 {
 	M0_PRE(be_alloc_chunk_invariant(a, c));
 	if (c->bac_free)
-		chunks_free_tlist_del(c);
-	chunks_all_tlist_del(c);
-	chunks_free_tlink_fini(c);
-	chunks_all_tlink_fini(c);
+		chunks_free_tlist_del_c(a, tx, c);
+	chunks_all_tlist_del_c(a, tx, c);
+	chunks_free_tlink_fini_c(a, tx, c);
+	chunks_all_tlink_fini_c(a, tx, c);
 }
 
 static struct be_alloc_chunk *be_alloc_chunk_addr(void *ptr)
@@ -285,6 +489,7 @@ static struct be_alloc_chunk *be_alloc_chunk_next(struct m0_be_allocator *a,
 }
 
 static void be_alloc_chunk_mark_free(struct m0_be_allocator *a,
+				     struct m0_be_tx *tx,
 				     struct be_alloc_chunk *c)
 {
 	struct be_alloc_chunk *next;
@@ -298,9 +503,9 @@ static void be_alloc_chunk_mark_free(struct m0_be_allocator *a,
 	}
 	c->bac_free = true;
 	if (next == NULL)
-		chunks_free_tlist_add_tail(&a->ba_h->bah_chunks.bl_list, c);
+		chunks_free_tlist_add_tail_c(a, tx, c);
 	else
-		chunks_free_tlist_add_before(next, c);
+		chunks_free_tlist_add_before_c(a, tx, next, c);
 	M0_POST(c->bac_free);
 	M0_POST(be_alloc_chunk_invariant(a, c));
 }
@@ -315,6 +520,7 @@ static uintptr_t be_alloc_chunk_after(struct m0_be_allocator *a,
 /** try to add a free chunk after the c */
 static struct be_alloc_chunk *
 be_alloc_chunk_add_after(struct m0_be_allocator *a,
+			 struct m0_be_tx *tx,
 			 struct be_alloc_chunk *c,
 			 struct be_alloc_chunk *f,
 			 uintptr_t offset,
@@ -329,19 +535,19 @@ be_alloc_chunk_add_after(struct m0_be_allocator *a,
 	new = c == NULL ? (struct be_alloc_chunk *)
 			  ((uintptr_t) a->ba_h->bah_addr + offset) :
 			  (struct be_alloc_chunk *) be_alloc_chunk_after(a, c);
-	be_alloc_chunk_init(a, new, size_total - sizeof(*new), free);
+	be_alloc_chunk_init(a, tx, new, size_total - sizeof(*new), free);
 
 	/** add chunk to m0_be_allocator_header.bac_chunks list */
 	if (c != NULL)
-		chunks_all_tlist_add_after(c, new);
+		chunks_all_tlist_add_after_c(a, tx, c, new);
 	else
-		chunks_all_tlist_add(&a->ba_h->bah_chunks.bl_list, new);
+		chunks_all_tlist_add_c(a, tx, new);
 	if (free) {
 		/** add chunk to m0_be_allocator_header.bac_free list */
 		if (f != NULL)
-			chunks_free_tlist_add_after(f, new);
+			chunks_free_tlist_add_after_c(a, tx, f, new);
 		else
-			chunks_free_tlist_add(&a->ba_h->bah_free.bl_list, new);
+			chunks_free_tlist_add_c(a, tx, new);
 	}
 	M0_POST(be_alloc_chunk_invariant(a, new));
 	M0_POST(ergo(free && f != NULL, be_alloc_chunk_invariant(a, f)));
@@ -350,7 +556,9 @@ be_alloc_chunk_add_after(struct m0_be_allocator *a,
 }
 
 static struct be_alloc_chunk *
-be_alloc_chunk_split(struct m0_be_allocator *a, struct be_alloc_chunk *c,
+be_alloc_chunk_split(struct m0_be_allocator *a,
+		     struct m0_be_tx *tx,
+		     struct be_alloc_chunk *c,
 		     uintptr_t start_new, m0_bcount_t size)
 {
 	struct be_alloc_chunk *prev;
@@ -378,7 +586,7 @@ be_alloc_chunk_split(struct m0_be_allocator *a, struct be_alloc_chunk *c,
 	M0_ASSERT(start_new <= start1);
 	M0_ASSERT(start1    <= start_next);
 
-	be_alloc_chunk_del_fini(a, c);
+	be_alloc_chunk_del_fini(a, tx, c);
 	/* c is not a valid chunk now */
 
 	if (chunk0_size <= chunk_size) {
@@ -388,13 +596,13 @@ be_alloc_chunk_split(struct m0_be_allocator *a, struct be_alloc_chunk *c,
 		else
 			; /* space before the first chunk is temporary lost */
 	} else {
-		prev_free = be_alloc_chunk_add_after(a, prev, prev_free,
+		prev_free = be_alloc_chunk_add_after(a, tx, prev, prev_free,
 						     0, chunk0_size, true);
 		prev = prev_free;
 	}
 
 	/* add the new chunk */
-	new = be_alloc_chunk_add_after(a, prev, NULL,
+	new = be_alloc_chunk_add_after(a, tx, prev, NULL,
 				       prev == NULL ? chunk0_size : 0,
 				       chunk_size + size, false);
 	M0_ASSERT(new != NULL);
@@ -403,9 +611,15 @@ be_alloc_chunk_split(struct m0_be_allocator *a, struct be_alloc_chunk *c,
 		/* no space for chunk1 */
 		new->bac_size += chunk1_size;
 	} else {
-		be_alloc_chunk_add_after(a, new, prev_free,
+		be_alloc_chunk_add_after(a, tx, new, prev_free,
 					 0, chunk1_size, true);
 	}
+	/*
+	 * XXX capture all chunks around the new in case if nearest chunks
+	 * size was changed.
+	 */
+	chunks_all_tlist_capture_around(a, tx, new);
+
 	M0_POST(!new->bac_free);
 	M0_POST(new->bac_size >= size);
 	M0_POST(be_alloc_chunk_invariant(a, new));
@@ -413,7 +627,9 @@ be_alloc_chunk_split(struct m0_be_allocator *a, struct be_alloc_chunk *c,
 }
 
 static struct be_alloc_chunk *
-be_alloc_chunk_trysplit(struct m0_be_allocator *a, struct be_alloc_chunk *c,
+be_alloc_chunk_trysplit(struct m0_be_allocator *a,
+			struct m0_be_tx *tx,
+			struct be_alloc_chunk *c,
 			m0_bcount_t size, unsigned shift)
 {
 	struct be_alloc_chunk *result = NULL;
@@ -433,7 +649,7 @@ be_alloc_chunk_trysplit(struct m0_be_allocator *a, struct be_alloc_chunk *c,
 		addr_mem  &= ~(alignment - 1);
 		/* if block fits inside free chunk */
 		result = addr_mem + size <= addr_end ?
-			 be_alloc_chunk_split(a, c, addr_mem - chunk_size,
+			 be_alloc_chunk_split(a, tx, c, addr_mem - chunk_size,
 					      size) : NULL;
 	}
 	M0_POST(ergo(result != NULL, be_alloc_chunk_invariant(a, result)));
@@ -441,6 +657,7 @@ be_alloc_chunk_trysplit(struct m0_be_allocator *a, struct be_alloc_chunk *c,
 }
 
 static bool be_alloc_chunk_trymerge(struct m0_be_allocator *al,
+				    struct m0_be_tx *tx,
 				    struct be_alloc_chunk *a,
 				    struct be_alloc_chunk *b)
 {
@@ -454,7 +671,7 @@ static bool be_alloc_chunk_trymerge(struct m0_be_allocator *al,
 	       ergo(b != NULL, chunks_free_tlink_is_in(b)));
 	if (a != NULL && b != NULL && a->bac_free && b->bac_free) {
 		b_size_total = sizeof(*b) + b->bac_size;
-		be_alloc_chunk_del_fini(al, b);
+		be_alloc_chunk_del_fini(al, tx, b);
 		a->bac_size += b_size_total;
 		chunks_were_merged = true;
 	}
@@ -464,7 +681,6 @@ static bool be_alloc_chunk_trymerge(struct m0_be_allocator *al,
 	return chunks_were_merged;
 }
 
-
 M0_INTERNAL int m0_be_allocator_init(struct m0_be_allocator *a,
 				     struct m0_be_seg *seg)
 {
@@ -509,7 +725,8 @@ M0_INTERNAL bool m0_be_allocator__invariant(struct m0_be_allocator *a)
 	return success;
 }
 
-M0_INTERNAL int m0_be_allocator_create(struct m0_be_allocator *a)
+M0_INTERNAL int m0_be_allocator_create(struct m0_be_allocator *a,
+				       struct m0_be_tx *tx)
 {
 	struct m0_be_allocator_header *h;
 	struct be_alloc_chunk	      *c;
@@ -531,16 +748,16 @@ M0_INTERNAL int m0_be_allocator_create(struct m0_be_allocator *a)
 	h->bah_addr = (void *) ((uintptr_t) a->ba_seg->bs_addr + overhead);
 
 	m0_be_list_init(&h->bah_chunks, a->ba_seg);
-	chunks_all_tlist_init(&h->bah_chunks.bl_list);
+	chunks_all_tlist_init_c(a, tx, &h->bah_chunks.bl_list);
 	m0_be_list_init(&h->bah_free, a->ba_seg);
-	chunks_free_tlist_init(&h->bah_free.bl_list);
+	chunks_free_tlist_init_c(a, tx, &h->bah_free.bl_list);
 
 	h->bah_stats = (struct m0_be_allocator_stats) {
 		.bas_free_space = free_space,
 	};
 
 	/* init main chunk */
-	c = be_alloc_chunk_add_after(a, NULL, NULL, 0, free_space, true);
+	c = be_alloc_chunk_add_after(a, tx, NULL, NULL, 0, free_space, true);
 	M0_ASSERT(c != NULL);
 
 	m0_mutex_unlock(&a->ba_lock);
@@ -551,7 +768,8 @@ M0_INTERNAL int m0_be_allocator_create(struct m0_be_allocator *a)
 	return 0;
 }
 
-M0_INTERNAL int m0_be_allocator_destroy(struct m0_be_allocator *a)
+M0_INTERNAL int m0_be_allocator_destroy(struct m0_be_allocator *a,
+					struct m0_be_tx *tx)
 {
 	struct m0_be_allocator_header *h;
 	struct be_alloc_chunk	      *c;
@@ -563,11 +781,11 @@ M0_INTERNAL int m0_be_allocator_destroy(struct m0_be_allocator *a)
 	/** @todo GET_PTR h */
 	m0_mutex_lock(&a->ba_lock);
 
-	be_alloc_chunk_del_fini(a, c);
+	be_alloc_chunk_del_fini(a, tx, c);
 
-	chunks_free_tlist_fini(&h->bah_free.bl_list);
+	chunks_free_tlist_fini_c(a, tx, &h->bah_free.bl_list);
 	m0_be_list_fini(&h->bah_free);
-	chunks_all_tlist_fini(&h->bah_chunks.bl_list);
+	chunks_all_tlist_fini_c(a, tx, &h->bah_chunks.bl_list);
 	m0_be_list_fini(&h->bah_chunks);
 
 	m0_mutex_unlock(&a->ba_lock);
@@ -584,6 +802,10 @@ M0_INTERNAL void m0_be_allocator_credit(struct m0_be_allocator *a,
 	struct m0_be_tx_credit chunk_credit;
 	struct m0_be_tx_credit mem_credit;
 	struct m0_be_tx_credit header_credit;
+	struct m0_be_tx_credit capture_around_credit;
+	struct m0_be_tx_credit chunk_add_after_credit;
+	struct m0_be_tx_credit chunk_del_fini_credit;
+	struct m0_be_tx_credit chunk_trymerge_credit;
 
 	M0_PRE(m0_be_allocator__invariant(a));
 	shift = max_check(shift, (unsigned) M0_BE_ALLOC_SHIFT_MIN);
@@ -592,26 +814,47 @@ M0_INTERNAL void m0_be_allocator_credit(struct m0_be_allocator *a,
 	header_credit = M0_BE_TX_CREDIT_TYPE(struct m0_be_allocator_header);
 	mem_credit    = M0_BE_TX_CREDIT(1, size * 2);
 
+	m0_be_tx_credit_init(&capture_around_credit);
+	m0_be_tx_credit_add(&capture_around_credit, &header_credit);
+	m0_be_tx_credit_mac(&capture_around_credit, &chunk_credit, 3);
+
+	m0_be_tx_credit_init(&chunk_add_after_credit);
+	/* be_alloc_chunk_init() x2 */
+	m0_be_tx_credit_mac(&chunk_add_after_credit, &chunk_credit, 2);
+	/* tlist_add_after x2 */
+	m0_be_tx_credit_mac(&chunk_add_after_credit, &capture_around_credit, 2);
+
+	m0_be_tx_credit_init(&chunk_del_fini_credit);
+	/* tlist_del x2 */
+	m0_be_tx_credit_mac(&chunk_add_after_credit, &capture_around_credit, 2);
+	/* tlink_fini x2 */
+	m0_be_tx_credit_mac(&chunk_add_after_credit, &chunk_credit, 2);
+
+	m0_be_tx_credit_init(&chunk_trymerge_credit);
+	m0_be_tx_credit_add(&chunk_trymerge_credit, &chunk_del_fini_credit);
+
 	/** @todo TODO XXX add list credits instead of entire header */
 	switch (optype) {
 		case M0_BAO_CREATE:
-			m0_be_tx_credit_mac(accum, &chunk_credit, 1);
-			m0_be_tx_credit_add(accum, &header_credit);
+			/* tlist_init x2 */
+			m0_be_tx_credit_mac(accum, &header_credit, 2);
+			m0_be_tx_credit_add(accum, &chunk_add_after_credit);
 			break;
 		case M0_BAO_DESTROY:
-			m0_be_tx_credit_add(accum, &header_credit);
+			m0_be_tx_credit_add(accum, &chunk_del_fini_credit);
+			/* tlist_fini x2 */
+			m0_be_tx_credit_mac(accum, &header_credit, 2);
 			break;
 		case M0_BAO_ALLOC:
-			/* see be_alloc_chunk_split() */
-			/* prev, chunk0, new, chunk1, next */
-			m0_be_tx_credit_mac(accum, &chunk_credit, 5);
+			m0_be_tx_credit_add(accum, &chunk_del_fini_credit);
+			m0_be_tx_credit_mac(accum, &chunk_add_after_credit, 3);
+			m0_be_tx_credit_add(accum, &capture_around_credit);
 			m0_be_tx_credit_add(accum, &mem_credit);
-			m0_be_tx_credit_add(accum, &header_credit);
 			break;
 		case M0_BAO_FREE:
-			/* prev of prev, prev, current, next, next of next */
-			m0_be_tx_credit_mac(accum, &chunk_credit, 5);
-			m0_be_tx_credit_add(accum, &header_credit);
+			/* be_alloc_chunk_mark_free */
+			m0_be_tx_credit_mac(accum, &capture_around_credit, 2);
+			m0_be_tx_credit_mac(accum, &chunk_trymerge_credit, 2);
 			break;
 		default:
 			M0_IMPOSSIBLE("Invalid allocator operation type");
@@ -634,7 +877,7 @@ M0_INTERNAL void *m0_be_alloc(struct m0_be_allocator *a,
 	m0_mutex_lock(&a->ba_lock);
 	/* algorithm starts here */
 	m0_tl_for(chunks_free, &a->ba_h->bah_free.bl_list, iter) {
-		c = be_alloc_chunk_trysplit(a, iter, size, shift);
+		c = be_alloc_chunk_trysplit(a, tx, iter, size, shift);
 		if (c != NULL)
 			break;
 	} m0_tl_endfor;
@@ -675,13 +918,13 @@ M0_INTERNAL void m0_be_free(struct m0_be_allocator *a,
 		M0_PRE(be_alloc_chunk_invariant(a, c));
 		M0_PRE(!c->bac_free);
 		/* algorithm starts here */
-		be_alloc_chunk_mark_free(a, c);
+		be_alloc_chunk_mark_free(a, tx, c);
 		prev = be_alloc_chunk_prev(a, c);
 		next = be_alloc_chunk_next(a, c);
-		chunks_were_merged = be_alloc_chunk_trymerge(a, prev, c);
+		chunks_were_merged = be_alloc_chunk_trymerge(a, tx, prev, c);
 		if (chunks_were_merged)
 			c = prev;
-		be_alloc_chunk_trymerge(a, c, next);
+		be_alloc_chunk_trymerge(a, tx, c, next);
 		/* and ends here */
 		M0_POST(c->bac_free);
 		M0_POST(c->bac_size > 0);
diff --git a/be/alloc.h b/be/alloc.h
index 818b680..47979fc 100644
--- a/be/alloc.h
+++ b/be/alloc.h
@@ -103,7 +103,8 @@ M0_INTERNAL bool m0_be_allocator__invariant(struct m0_be_allocator *a);
  * @see m0_be_allocator.ba_seg, m0_be_allocator_init(),
  * m0_be_allocator_header.
  */
-M0_INTERNAL int m0_be_allocator_create(struct m0_be_allocator *a);
+M0_INTERNAL int m0_be_allocator_create(struct m0_be_allocator *a,
+				       struct m0_be_tx *tx);
 
 /**
  * Destroy allocator on the segment.
@@ -111,7 +112,8 @@ M0_INTERNAL int m0_be_allocator_create(struct m0_be_allocator *a);
  * All memory allocations obtained from m0_be_alloc()
  * should be m0_be_free()'d before calling this function.
  */
-M0_INTERNAL int m0_be_allocator_destroy(struct m0_be_allocator *a);
+M0_INTERNAL int m0_be_allocator_destroy(struct m0_be_allocator *a,
+					struct m0_be_tx *tx);
 
 /**
  * Allocator operation.
diff --git a/be/ut/helper.c b/be/ut/helper.c
index 4109081..9fc5444 100644
--- a/be/ut/helper.c
+++ b/be/ut/helper.c
@@ -43,8 +43,10 @@ static struct m0_stob_id be_ut_h_stob_id = {
 
 void m0_be_ut_seg_storage_fini(void)
 {
+	/*
 	int rc = system("rm -rf " BE_UT_H_STORAGE_DIR);
 	M0_ASSERT(rc == 0);
+	*/
 }
 
 void m0_be_ut_seg_storage_init(void)
@@ -130,7 +132,7 @@ void m0_be_ut_h_init(struct m0_be_ut_h *h)
 	h->buh_a = &h->buh_seg.bs_allocator;
 	rc = m0_be_allocator_init(h->buh_a, &h->buh_seg);
 	M0_ASSERT(rc == 0);
-	rc = m0_be_allocator_create(h->buh_a);
+	rc = m0_be_allocator_create(h->buh_a, NULL);
 	M0_ASSERT(rc == 0);
 }
 
@@ -138,7 +140,7 @@ void m0_be_ut_h_fini(struct m0_be_ut_h *h)
 {
 	int rc;
 
-	rc = m0_be_allocator_destroy(h->buh_a);
+	rc = m0_be_allocator_destroy(h->buh_a, NULL);
 	M0_ASSERT(rc == 0);
 	m0_be_allocator_fini(h->buh_a);
 	m0_be_ut_seg_close_destroy(h);
-- 
1.8.3.2

