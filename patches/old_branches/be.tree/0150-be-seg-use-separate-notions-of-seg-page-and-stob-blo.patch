From aecf0d587aa091fcadd5000bd64eb04a026fa379 Mon Sep 17 00:00:00 2001
From: Alexander Gattin <alexander_gattin@xyratex.com>
Date: Thu, 13 Jun 2013 11:52:32 +0300
Subject: [PATCH 150/290] be/seg: use separate notions of seg page and stob
 block.

---
 be/seg.c | 44 ++++++++++++++++++++------------------------
 be/seg.h |  2 ++
 2 files changed, 22 insertions(+), 24 deletions(-)

diff --git a/be/seg.c b/be/seg.c
index b082f44..da4d4b3 100644
--- a/be/seg.c
+++ b/be/seg.c
@@ -44,7 +44,6 @@ static int stob_io_single_write(void *buf, m0_bcount_t bufsize,
 				struct m0_stob *stob,
 				m0_bindex_t offs, uint32_t bshift)
 {
-	size_t            bsize;
 	m0_bcount_t       wrcnt[1];    /* sectors counts */
 	m0_bindex_t       wroffs[1];   /* offsets */
 	void             *bufpk[1];  /* "packed" addresses */
@@ -52,11 +51,9 @@ static int stob_io_single_write(void *buf, m0_bcount_t bufsize,
 	struct m0_clink   clink;
 	int               rc;
 
-	bsize = 1 << bshift;
-
 	/* Set up io struct for reading. */
 	m0_stob_io_init(&io);
-	wrcnt[0]                  = (bufsize + bsize - 1) / bsize;
+	wrcnt[0]                  = (bufsize + (1 << bshift) - 1) >> bshift;
 	bufpk[0]                  = m0_stob_addr_pack(buf, bshift);
 	io.si_flags               = 0;
 	io.si_opcode              = SIO_WRITE;
@@ -151,6 +148,8 @@ m0_be_seg_init(struct m0_be_seg *seg, struct m0_stob *stob, struct m0_be *be)
 	seg->bs_be           = be;
 	seg->bs_stob         = stob;
 	seg->bs_state        = M0_BSS_INIT;
+	seg->bs_bshift       = 0;
+	seg->bs_pgshift      = 12;
 	seg->bs_pgmap        = NULL;
 	seg->bs_pgnr         = 0;
 }
@@ -178,7 +177,6 @@ static int stob_io_single_read(void *buf, m0_bcount_t bufsize,
 			       struct m0_stob *stob,
 			       m0_bindex_t offs, uint32_t bshift)
 {
-	size_t            bsize;
 	m0_bcount_t       rdcnt[1];    /* sectors counts */
 	m0_bindex_t       rdoffs[1];   /* offsets */
 	void             *rdbufpk[1];  /* "packed" addresses */
@@ -186,11 +184,9 @@ static int stob_io_single_read(void *buf, m0_bcount_t bufsize,
 	struct m0_clink   clink;
 	int               rc;
 
-	bsize = 1 << bshift;
-
 	/* Set up io struct for reading. */
 	m0_stob_io_init(&io);
-	rdcnt[0]                  = (bufsize + bsize - 1) / bsize;
+	rdcnt[0]                  = (bufsize + (1 << bshift) - 1) >> bshift;
 	rdbufpk[0]                = m0_stob_addr_pack(buf, bshift);
 	io.si_flags               = 0;
 	io.si_opcode              = SIO_READ;
@@ -198,8 +194,7 @@ static int stob_io_single_read(void *buf, m0_bcount_t bufsize,
 	io.si_user.ov_vec.v_nr    = 1;
 	io.si_user.ov_vec.v_count = rdcnt;
 	rdoffs[0]                 = (m0_bindex_t)
-				    m0_stob_addr_pack((void *)offs,
-						      bshift);
+				    m0_stob_addr_pack((void *)offs, bshift);
 	io.si_stob.iv_index       = rdoffs;
 	io.si_stob.iv_vec.v_nr    = 1;
 	io.si_stob.iv_vec.v_count = rdcnt;
@@ -221,8 +216,6 @@ static int stob_io_single_read(void *buf, m0_bcount_t bufsize,
 M0_INTERNAL int m0_be_seg_open(struct m0_be_seg *seg)
 {
 	int                   rc;
-	uint32_t              st_block_shift;
-	size_t                st_block_size;
 	struct m0_be_seg_hdr *hdrbuf;      /* seg hdr buffer */
 	m0_bcount_t           hdrblocks;   /* number of sectors */
 	void                 *seg_addr0;
@@ -231,30 +224,34 @@ M0_INTERNAL int m0_be_seg_open(struct m0_be_seg *seg)
 	void                 *p;
 
 	/* Allocate buffer for segment header. */
-	st_block_shift = seg->bs_stob->so_op->sop_block_shift(seg->bs_stob);
-	st_block_size = 1 << st_block_shift;
-	hdrblocks = (sizeof(*hdrbuf) + st_block_size - 1) / st_block_size;
-	hdrbuf = m0_alloc_aligned(hdrblocks * st_block_size, st_block_shift);
+	seg->bs_bshift = seg->bs_stob->so_op->sop_block_shift(seg->bs_stob);
+	if (seg->bs_pgshift < seg->bs_bshift) {
+		seg->bs_pgshift = seg->bs_bshift;
+	}
+	hdrblocks = (sizeof(*hdrbuf) + (1 << seg->bs_bshift) - 1) >>
+		seg->bs_bshift;
+	hdrbuf = m0_alloc_aligned(hdrblocks << seg->bs_bshift, seg->bs_pgshift);
 	if (hdrbuf == NULL)
 		return -ENOMEM;
 
 	/* Read segment header from storage. */
 	rc = stob_io_single_read(hdrbuf, sizeof(*hdrbuf), seg->bs_stob,
-				 BE_SEG_HEADER_OFFSET, st_block_shift);
+				 BE_SEG_HEADER_OFFSET, seg->bs_bshift);
 	if (rc == 0) {
 		seg_addr0 = hdrbuf->bh_addr;
 		seg_size  = hdrbuf->bh_size;
 		M0_ASSERT(seg_addr0 != NULL);
-		M0_ASSERT(m0_addr_is_aligned(seg_addr0, st_block_shift));
+		M0_ASSERT(m0_addr_is_aligned(seg_addr0, seg->bs_bshift));
 	}
 	m0_free(hdrbuf);
 	if (rc != 0)
 		return rc;
 
 	/* Allocate page map. */
-	seg->bs_pgnr = (seg_size + st_block_size - 1) / st_block_size;
+	seg->bs_pgnr = (seg_size + (1 << seg->bs_pgshift) - 1) >>
+		seg->bs_pgshift;
 	seg->bs_pgmap = m0_alloc_aligned(sizeof(m0_bcount_t) * seg->bs_pgnr,
-					 64);
+					 3);
 	if (seg->bs_pgmap == NULL)
 		return -ENOMEM;
 	for (i = 0; i < seg->bs_pgnr; i++)
@@ -269,7 +266,7 @@ M0_INTERNAL int m0_be_seg_open(struct m0_be_seg *seg)
 
 	/* Read whole segment from storage. */
 	rc = stob_io_single_read(seg_addr0, seg_size, seg->bs_stob,
-				 0, st_block_shift);
+				 0, seg->bs_bshift);
 	if (rc == 0) {
 		seg->bs_state = M0_BSS_OPENED;
 		for (i = 0; i < seg->bs_pgnr; i++)
@@ -285,10 +282,9 @@ M0_INTERNAL void m0_be_seg_close(struct m0_be_seg *seg)
 	seg->bs_state = M0_BSS_CLOSED;
 }
 
-static m0_bcount_t be_seg_pgno(const struct m0_be_seg *seg, void *addr)
+static inline m0_bcount_t be_seg_pgno(const struct m0_be_seg *seg, void *addr)
 {
-	return (addr - seg->bs_addr) /
-		(1 << seg->bs_stob->so_op->sop_block_shift(seg->bs_stob));
+	return (addr - seg->bs_addr) >> seg->bs_pgshift;
 }
 
 M0_INTERNAL void m0_be_reg_get(struct m0_be_reg *reg, struct m0_be_op *op)
diff --git a/be/seg.h b/be/seg.h
index c0b4008..14e96d4 100644
--- a/be/seg.h
+++ b/be/seg.h
@@ -51,6 +51,8 @@ struct m0_be_seg {
 	struct m0_be_allocator bs_allocator;
 	struct m0_be          *bs_be;
 	int                    bs_state;
+	uint32_t               bs_bshift;  /* STOB block shift */
+	uint32_t               bs_pgshift; /* seg page shift */
 	m0_bcount_t           *bs_pgmap;
 	m0_bcount_t            bs_pgnr;
 };
-- 
1.8.3.2

