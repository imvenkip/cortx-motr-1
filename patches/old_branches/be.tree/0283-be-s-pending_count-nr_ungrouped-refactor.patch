From 38cbc6bdd8ea66103671837be72326b7986b6f43 Mon Sep 17 00:00:00 2001
From: "Valery V. Vorotyntsev" <valery_vorotyntsev@xyratex.com>
Date: Fri, 5 Jul 2013 01:02:05 +0300
Subject: [PATCH 283/290] be: s/pending_count/nr_ungrouped/; refactor

---
 be/tx.c       |  20 +++--------
 be/tx_fom.c   | 109 ++++++++++++++++++++++------------------------------------
 be/tx_group.h |  15 ++++----
 3 files changed, 55 insertions(+), 89 deletions(-)

diff --git a/be/tx.c b/be/tx.c
index 3a71f32..d8e72bc 100644
--- a/be/tx.c
+++ b/be/tx.c
@@ -454,13 +454,11 @@ tx_engine_got_closed(struct m0_be_tx_engine *eng, struct m0_be_tx *tx)
 	M0_PRE(m0_be__tx_state(tx) == M0_BTS_CLOSED);
 	M0_PRE(tx_is_locked(tx));
 
-	/* struct m0_be_tx_group *gr = &eng->te_group; */
 #if 0 /* Nikita's code */
+	struct m0_be_tx_group *gr = &eng->te_group;
 	m0_bcount_t used = tx_log_size(tx, &tx->t_used,
 				       gr_tlist_is_empty(&gr->tg_txs));
 
-	M0_PRE(m0_be__tx_state(tx) == M0_BTS_CLOSED);
-
 	if (gr->tg_opened) {
 		if (gr->tg_used.tc_reg_size + used > eng->te_log.lg_gr_size_max)
 			tx_group_close(eng, gr);
@@ -468,16 +466,8 @@ tx_engine_got_closed(struct m0_be_tx_engine *eng, struct m0_be_tx *tx)
 			tx_group_add(eng, gr, tx);
 	}
 	/* Note, that we do nothing when the group is closed. */
-#else /* XXX: close group after every tx close, for now */
-	M0_PRE(m0_be__tx_state(tx) == M0_BTS_CLOSED);
-
-	/* XXX: commmented by ABilenko */
-	/* tx_group_init(gr); */
-	/* tx_group_add(eng, gr, tx); */
-	/* tx_group_close(eng, gr); */
-
-	M0_POST(m0_be__tx_engine_invariant(eng));
 #endif
+	M0_POST(m0_be__tx_engine_invariant(eng));
 }
 
 static void tx_open_tail(struct m0_be_tx *tx)
@@ -535,9 +525,9 @@ static void _txs_set_ready(const struct m0_be_tx *tx)
 	M0_PRE(!gr->tg_opened);
 
 	/* XXX TODO: Replace with m0_ref_put(). See also documentation of
-	 * m0_be_tx_group::tg_pending_count. */
-	M0_CNT_DEC(gr->tg_pending_count);
-	if (gr->tg_pending_count == 0)
+	 * m0_be_tx_group::tg_nr_ungrouped. */
+	M0_CNT_DEC(gr->tg_nr_ungrouped); /* XXX atomic! */
+	if (gr->tg_nr_ungrouped == 0)
 		m0_fom_wakeup(gr->tg_fom);
 }
 
diff --git a/be/tx_fom.c b/be/tx_fom.c
index 34715ff..5aa33c2 100644
--- a/be/tx_fom.c
+++ b/be/tx_fom.c
@@ -333,18 +333,18 @@ static bool add_if_grp_has_space(struct m0_be_tx_group *gr, struct m0_be_tx *tx)
 	return true; /*XXX*/
 }
 
-static enum m0_fom_phase_outcome open_tick(struct m0_fom *f)
+static enum m0_fom_phase_outcome open_tick(struct m0_fom *fom)
 {
-	struct tx_group_fom    *fom = tx_group_fom(f);
-	struct m0_be_tx_engine *eng = fom->tgf_engine;
+	struct tx_group_fom    *m   = tx_group_fom(fom);
+	struct m0_be_tx_engine *eng = m->tgf_engine;
 	struct m0_be_tx_group  *gr  = &eng->te_group;
 	struct m0_be_tx        *tx;
-	bool			ready_to_close;
+	bool                    ready_to_close;
 	bool                    one_and_more_tx_grouped;
 	int                     rc;
 
 	M0_ENTRY("gr->tg_opened: %d", !!gr->tg_opened);
-	m0_semaphore_up(&fom->tgf_started);
+	m0_semaphore_up(&m->tgf_started);
 
 	if (!gr->tg_opened && gr_tlist_is_empty(&gr->tg_txs))
 		tx_group_open(eng, gr);
@@ -354,25 +354,25 @@ static enum m0_fom_phase_outcome open_tick(struct m0_fom *f)
 			     !add_if_grp_has_space(gr, tx));
 	one_and_more_tx_grouped = !gr_tlist_is_empty(&gr->tg_txs);
 
-	if (ready_to_close || (fom->tgf_timed_out && one_and_more_tx_grouped)) {
+	if (ready_to_close || (m->tgf_timed_out && one_and_more_tx_grouped)) {
 		M0_LOG(M0_DEBUG, "group is ready to close [%d, %d]",
-		       !!ready_to_close, !!fom->tgf_timed_out);
+		       !!ready_to_close, !!m->tgf_timed_out);
 
-		fom->tgf_timed_out = false;
-		gr->tg_pending_count = gr_tlist_length(&gr->tg_txs);
+		m->tgf_timed_out = false;
+		gr->tg_nr_ungrouped = gr_tlist_length(&gr->tg_txs);
 
 		m0_tl_for(gr, &gr->tg_txs, tx) {
 			m0_be__tx_state_post(tx, M0_BTS_GROUPED);
 		} m0_tl_endfor;
 
 		tx_group_close(eng, gr);
-		m0_fom_phase_set(&fom->tgf_gen, TGS_LOGGING);
+		m0_fom_phase_set(fom, TGS_LOGGING);
 	} else {
 		/* arm timeout */
 		M0_LOG(M0_DEBUG, "arm timeout");
-		fom->tgf_timed_out = true;
-		m0_fom_timeout_init(&fom->tgf_timeout);
-		rc = m0_fom_timeout_wait_on(&fom->tgf_timeout, &fom->tgf_gen,
+		m->tgf_timed_out = true;
+		m0_fom_timeout_init(&m->tgf_timeout);
+		rc = m0_fom_timeout_wait_on(&m->tgf_timeout, fom,
 					    m0_time_from_now(2, 0)); /* 2 sec */
 		M0_ASSERT(rc == 0);
 	}
@@ -381,41 +381,39 @@ static enum m0_fom_phase_outcome open_tick(struct m0_fom *f)
 	return M0_FSO_WAIT;
 }
 
-static enum m0_fom_phase_outcome logging_tick(struct m0_fom *m)
+static enum m0_fom_phase_outcome logging_tick(struct m0_fom *fom)
 {
-	struct tx_group_fom    *fom = tx_group_fom(m);
-	struct m0_be_tx_engine *eng = fom->tgf_engine;
+	struct tx_group_fom    *m   = tx_group_fom(fom);
+	struct m0_be_tx_engine *eng = m->tgf_engine;
 	struct m0_be_tx_group  *gr  = &eng->te_group;
-	struct m0_be_op        *op  = &fom->tgf_op;
+	struct m0_be_op        *op  = &m->tgf_op;
 
 	M0_ENTRY();
-
+	M0_PRE(gr->tg_nr_ungrouped == 0);
 	M0_PRE(m0_tl_forall(gr, tx, &gr->tg_txs,
 			    m0_be__tx_state(tx) == M0_BTS_GROUPED));
-	M0_PRE(gr->tg_pending_count == 0);
 
 	m0_be_op_init(op);
-	/*
-	 * here we have to run first portion of logio
-	 */
-
-	/* XXX: max has to integrate */
 #if XXX_MOCK_IO
 	_arm_io(op);
 #else
+	/*
+	 * Launch the 1st log IO: tx_group and, when the log is wrapped,
+	 * log header.
+	 */
 	m0_be_log_payload_prepare(&eng->te_log, gr);
 	m0_be_log_submit(&eng->te_log, op, gr);
 #endif
 	M0_LEAVE();
-	return m0_be_op_tick_ret(op, &fom->tgf_gen, TGS_COMMITTING);
+	return m0_be_op_tick_ret(op, fom, TGS_COMMITTING);
 }
 
-static enum m0_fom_phase_outcome committing_tick(struct m0_fom *m)
+static enum m0_fom_phase_outcome committing_tick(struct m0_fom *fom)
 {
-	struct tx_group_fom    *fom = tx_group_fom(m);
-	struct m0_be_tx_engine *eng = fom->tgf_engine;
+	struct tx_group_fom    *m   = tx_group_fom(fom);
+	struct m0_be_tx_engine *eng = m->tgf_engine;
 	struct m0_be_tx_group  *gr  = &eng->te_group;
-	struct m0_be_op        *op  = &fom->tgf_op;
+	struct m0_be_op        *op  = &m->tgf_op;
 
 	/* XXX: on error transit to failure state, and finish system */
 	M0_PRE(m0_be_op_state(op) == M0_BOS_SUCCESS);
@@ -423,63 +421,41 @@ static enum m0_fom_phase_outcome committing_tick(struct m0_fom *m)
 	M0_ENTRY();
 
 	m0_be_op_init(op);
-	/*
-	 * here we have to run first portion of logio
-	 */
-
-	/* XXX: max has to integrate */
 #if XXX_MOCK_IO
 	_arm_io(op);
 #else
+	/*
+	 * Launch the 2nd log IO: commit block.
+	 */
 	m0_be_log_commit_block_prepare(&eng->te_log, gr);
 	m0_be_log_submit(&eng->te_log, op, gr);
 #endif
 
 	/* Next state (TGS_PLACING) uses this pointer. */
-	fom->tgf_tx_to_place = gr_tlist_head(&gr->tg_txs);
+	m->tgf_tx_to_place = gr_tlist_head(&gr->tg_txs);
 
-	M0_POST(fom->tgf_tx_to_place != NULL);
+	M0_POST(m->tgf_tx_to_place != NULL);
 	M0_LEAVE();
-	return m0_be_op_tick_ret(op, &fom->tgf_gen, TGS_PLACING);
+	return m0_be_op_tick_ret(op, fom, TGS_PLACING);
 }
 
-#if 0 /* XXX */
-static enum m0_fom_phase_outcome committing_st_ex(struct m0_fom *m)
+static enum m0_fom_phase_outcome placing_tick(struct m0_fom *fom)
 {
-	struct tx_group_fom    *fom = tx_group_fom(m);
-	struct m0_be_tx_engine *eng = fom->tgf_engine;
+	struct tx_group_fom    *m   = tx_group_fom(fom);
+	struct m0_be_tx_engine *eng = m->tgf_engine;
 	struct m0_be_tx_group  *gr  = &eng->te_group;
-	struct m0_be_tx        *tx;
-
-	M0_ENTRY();
-
-	m0_tl_for(gr, &gr->tg_txs, tx) {
-		tx->t_persistent(tx);
-	} m0_tl_endfor;
-
-	gr->tg_pending_count = gr_tlist_length(&gr->tg_txs);
-	M0_LEAVE();
-}
-#endif
-
-static enum m0_fom_phase_outcome placing_tick(struct m0_fom *m)
-{
-	struct tx_group_fom    *fom = tx_group_fom(m);
-	struct m0_be_tx_engine *eng = fom->tgf_engine;
-	struct m0_be_tx_group  *gr  = &eng->te_group;
-	struct m0_be_op        *op  = &fom->tgf_op;
+	struct m0_be_op        *op  = &m->tgf_op;
 	struct m0_be_tx        *tx;
 	struct m0_be_seg       *seg;
 	struct m0_be_reg_area  *area;
 
 	M0_ENTRY();
-	/* XXX: PRE() check that tx is working with the same segment */
 	M0_PRE(!gr_tlist_is_empty(&gr->tg_txs));
+	/* XXX TODO: M0_PRE() that tx is working with the same segment. */
 
-	tx = fom->tgf_tx_to_place;
-
+	tx = m->tgf_tx_to_place;
 	if (tx == NULL) {
-		m0_fom_phase_set(m, TGS_PLACED);
+		m0_fom_phase_set(fom, TGS_PLACED);
 
 		M0_LEAVE();
 		return M0_FSO_AGAIN;
@@ -491,12 +467,11 @@ static enum m0_fom_phase_outcome placing_tick(struct m0_fom *m)
 	m0_be_op_init(op);
 	m0_be_seg_write_simple(seg, op, area);
 
+	m->tgf_tx_to_place = gr_tlist_next(&gr->tg_txs, tx);
 	tx->t_persistent(tx);
 
-	fom->tgf_tx_to_place = gr_tlist_next(&gr->tg_txs, tx);
-
 	M0_LEAVE();
-	return m0_be_op_tick_ret(op, &fom->tgf_gen, TGS_PLACING);
+	return m0_be_op_tick_ret(op, fom, TGS_PLACING);
 }
 
 /** @} end of be group */
diff --git a/be/tx_group.h b/be/tx_group.h
index abc6c36..c436071 100644
--- a/be/tx_group.h
+++ b/be/tx_group.h
@@ -60,23 +60,24 @@ struct m0_be_tx;
  */
 struct m0_be_tx_group {
 	/** lsn of transaction group header in the log. */
-	m0_bindex_t             tg_lsn;
-	bool                    tg_opened;
+	m0_bindex_t            tg_lsn;
+	bool                   tg_opened;
 	/** Total size of all updates in all transactions in this group. */
-	struct m0_be_tx_credit  tg_used;
+	struct m0_be_tx_credit tg_used;
 	/** List of transactions in the group. */
-	struct m0_tl            tg_txs;
+	struct m0_tl           tg_txs;
 
 	/**
-	 * Counter which counts pending transactions in the group.
+	 * The number of transactions that have been added to this group
+	 * but have not switched to M0_BTS_GROUPED state yet.
 	 *
 	 * XXX TODO: Use atomic m0_ref. ->tg_pending_count is decremented by
 	 * tx's AST callback, which may belong different m0_sm_group.
 	 */
-	uint32_t                tg_pending_count;
+	uint32_t               tg_nr_ungrouped;
 
 	/** fom which processes current group */
-	struct m0_fom          *tg_fom;
+	struct m0_fom         *tg_fom;
 };
 
 M0_INTERNAL void tx_group_init(struct m0_be_tx_group *gr);
-- 
1.8.3.2

