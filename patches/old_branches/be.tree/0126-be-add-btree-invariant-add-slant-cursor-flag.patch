From e1847c71277d707f78d7acf6c77b563eb6124f69 Mon Sep 17 00:00:00 2001
From: Anatoliy Bilenko <anatoliy_bilenko@xyratex.com>
Date: Fri, 7 Jun 2013 14:54:10 +0300
Subject: [PATCH 126/290] be: add btree invariant, add slant cursor flag.

---
 be/btree.c    | 69 ++++++++++++++++++++++++++++++++++++++++++++++++++++-------
 be/btree.h    | 11 ++++++----
 be/ut/btree.c |  6 +++---
 3 files changed, 71 insertions(+), 15 deletions(-)

diff --git a/be/btree.c b/be/btree.c
index 06cc7b6..c74e278 100644
--- a/be/btree.c
+++ b/be/btree.c
@@ -118,7 +118,8 @@ static int free_btree_node(struct m0_be_bnode *node,
 			   const struct m0_be_btree *btree,
 			   struct m0_be_tx *tx);
 
-static struct node_pos get_btree_node(struct m0_be_btree *btree, void *key);
+static struct node_pos get_btree_node(struct m0_be_btree *btree, void *key,
+				      bool slant);
 
 static int delete_key_from_node(struct m0_be_btree *btree,
 				struct m0_be_tx *tx,
@@ -152,6 +153,53 @@ static void copy_key_val(struct m0_be_btree	 *btree,
 			 struct bt_key_val	 *src,
 			 struct bt_key_val	 *dst);
 
+
+/* ------------------------------------------------------------------
+ * Btree invariant implementation:
+ * - assuming that the tree is completely in memory;
+ * - checks that keys are in order;
+ * - child nodes have keys matching parent;
+ * - nodes have expected occupancy: [1..2*order-1] for root and
+ *				    [order-1..2*order-1] for leafs.
+ *
+ * Note: as far as height of practical tree will be 10-15, invariant can be
+ * written in recusieve form.
+ * ------------------------------------------------------------------ */
+enum { BTREE_INVARIANT_HEIGHT_MAX = 15 };
+
+static bool btree_node_invariant(const struct m0_be_btree *btree,
+				 const struct m0_be_bnode *node,
+				 bool root, uint32_t level)
+{
+	return
+		level < BTREE_INVARIANT_HEIGHT_MAX &&
+		/* expected occupancy */
+		ergo(root, 1 <= node->nr_active &&
+		     node->nr_active < 2*BTREE_FAN_OUT - 1) &&
+		ergo(!root, BTREE_FAN_OUT-1 <= node->nr_active &&
+		     node->nr_active < 2*BTREE_FAN_OUT - 1) &&
+		/* keys are in order */
+		m0_forall(i, node->nr_active - 1,
+			  i < 1 ? true : node->key_vals[i]->key >
+					 node->key_vals[i - 1]->key) &&
+		/* matchig parent */
+		m0_forall(i, node->nr_active, node->leaf ? true :
+			  KEY_GT(node->children[level]->key_vals[i]->key,
+				 node->key_vals[level]->key) &&
+			  btree_node_invariant(btree, node->children[level],
+					       false, level + 1));
+}
+
+
+/* ------------------------------------------------------------------
+ * b-tree internals.
+ * ------------------------------------------------------------------ */
+
+static inline bool btree_invariant(const struct m0_be_btree *btree)
+{
+	return btree_node_invariant(btree, btree->bb_root, true, 0);
+}
+
 static int node_update(struct m0_be_bnode	    *node,
 		       const struct m0_be_btree   *btree,
 		       struct m0_be_tx *tx)
@@ -877,13 +925,19 @@ static int btree_delete_key(struct m0_be_btree   *btree,
 	return 0;
 }
 
+static inline bool key_found(struct m0_be_btree *btree, const void *kv0,
+			     const void *kv1, bool slant)
+{
+	return (slant && KEY_LT(kv0, kv1)) || KEY_EQ(kv0, kv1);
+}
+
 /**
  * Function used to get the node containing the given key
  * @param btree The btree to be searched
  * @param key The the key to be searched
  * @return The node and position of the key within the node
  */
-struct node_pos get_btree_node(struct m0_be_btree *btree, void *key)
+struct node_pos get_btree_node(struct m0_be_btree *btree, void *key, bool slant)
 {
 	struct node_pos kp = { .node = NULL };
 	void *key_val = key;
@@ -894,9 +948,8 @@ struct node_pos get_btree_node(struct m0_be_btree *btree, void *key)
 
 	for (;; i = 0) {
 
-		/*  Fix the index of the key greater than or equal */
+		/*  Find the index of the key greater than or equal */
 		/*  to the key that we would like to search */
-
 		while (i < node->nr_active &&
 		       KEY_GT(key_val, node->key_vals[i]->key)) {
 			i++;
@@ -904,7 +957,7 @@ struct node_pos get_btree_node(struct m0_be_btree *btree, void *key)
 
 		/*  If we find such key return the key-value pair */
 		if (i < node->nr_active &&
-		    KEY_EQ(key_val, node->key_vals[i]->key)) {
+		    key_found(btree, key_val, node->key_vals[i]->key, slant)) {
 			kp.node = node;
 			kp.index = i;
 			return kp;
@@ -971,7 +1024,7 @@ static struct bt_key_val *btree_search(struct m0_be_btree *btree, void *key)
 {
 
 	struct bt_key_val *key_val = NULL;
-	struct node_pos kp = get_btree_node(btree, key);
+	struct node_pos kp = get_btree_node(btree, key, false);
 
 	if (kp.node) {
 		key_val = kp.node->key_vals[kp.index];
@@ -1515,7 +1568,7 @@ M0_INTERNAL void m0_be_btree_cursor_fini(struct m0_be_btree_cursor *cursor)
 }
 
 M0_INTERNAL void m0_be_btree_cursor_get(struct m0_be_btree_cursor *cur,
-					const struct m0_buf *key)
+					const struct m0_buf *key, bool slant)
 {
 	struct node_pos    last;
 	struct bt_key_val  *kv;
@@ -1536,7 +1589,7 @@ M0_INTERNAL void m0_be_btree_cursor_get(struct m0_be_btree_cursor *cur,
 	m0_rwlock_read_lock(&tree->bb_lock);
 
 	/* cursor move */
-	last = get_btree_node(cur->bc_tree, key->b_addr);
+	last = get_btree_node(cur->bc_tree, key->b_addr, slant);
 	cur->bc_last_node = last.node;
 	cur->bc_last_pos = last.index;
 
diff --git a/be/btree.h b/be/btree.h
index 52f771c..23cc4c3 100644
--- a/be/btree.h
+++ b/be/btree.h
@@ -75,11 +75,11 @@ enum m0_be_btree_op {
  */
 struct m0_be_btree_kv_ops {
 	/** Returns the key size */
-        unsigned int  (*ko_ksize)   (void *key);
+        unsigned int  (*ko_ksize)   (const void *key);
 	/** Returns the data size */
-        unsigned int  (*ko_dsize)   (void *data);
+        unsigned int  (*ko_dsize)   (const void *data);
 	/** @return 1 if key0 > key1, -1 if key0 < key2, 0 if key0 == key2 */
-        int           (*ko_compare) (void *key0, void *key1);
+        int           (*ko_compare) (const void *key0, const void *key1);
 };
 
 
@@ -350,9 +350,12 @@ M0_INTERNAL void m0_be_btree_cursor_fini(struct m0_be_btree_cursor *cursor);
  * Note: interface is asynchronous and relies on cursor::bc_op::bo_sm. When it
  * transits into M0_BOS_SUCCESS | M0_BOS_FAILURE operation is considered to be
  * finished.
+ *
+ * @param slant[in] if slant == true then cursor will return a minimum key not
+ *  less than given, otherwize it'll be set on exact key if it's possible.
  */
 M0_INTERNAL void m0_be_btree_cursor_get(struct m0_be_btree_cursor *cursor,
-					const struct m0_buf *key);
+					const struct m0_buf *key, bool slant);
 
 /**
  * Fills cursor internal buffers with next key and value obtained from the
diff --git a/be/ut/btree.c b/be/ut/btree.c
index a0497ef..0130ada 100644
--- a/be/ut/btree.c
+++ b/be/ut/btree.c
@@ -64,17 +64,17 @@ void be_fini(struct m0_be *be)
 {/* XXX */
 }
 
-static int tree_cmp(void *key0, void *key1)
+static int tree_cmp(const void *key0, const void *key1)
 {
         return strcmp(key0, key1);
 }
 
-static uint32_t tree_key_size(void *key)
+static uint32_t tree_key_size(const void *key)
 {
         return strlen(key) + 1;
 }
 
-static uint32_t tree_data_size(void *data)
+static uint32_t tree_data_size(const void *data)
 {
         return strlen(data) + 1;
 }
-- 
1.8.3.2

