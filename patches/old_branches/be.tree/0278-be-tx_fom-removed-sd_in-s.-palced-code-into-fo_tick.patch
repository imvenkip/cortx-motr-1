From 39092dd4b8ddc50ea4a7f3535473aeb5dffd71db Mon Sep 17 00:00:00 2001
From: Anatoliy Bilenko <anatoliy_bilenko@xyratex.com>
Date: Thu, 4 Jul 2013 17:59:47 +0300
Subject: [PATCH 278/290] be: tx_fom: removed sd_in()'s. palced code into
 ->fo_tick();

---
 be/tx.c       |  22 +++---
 be/tx_fom.c   | 214 ++++++++++++++++++++++++++++++----------------------------
 be/tx_group.c |   9 ++-
 be/tx_group.h |   4 +-
 be/ut/tx.c    |   7 +-
 mero/magic.h  |   6 +-
 6 files changed, 134 insertions(+), 128 deletions(-)

diff --git a/be/tx.c b/be/tx.c
index 45439ba..13bf7c0 100644
--- a/be/tx.c
+++ b/be/tx.c
@@ -45,7 +45,7 @@ static int   done_st_in(struct m0_sm *mach);
 
 M0_TL_DESCR_DEFINE(tx, "transactions", M0_INTERNAL, struct m0_be_tx,
 		   t_linkage, t_magic,
-		   M0_TRACE_TX_MAGIC, M0_TRACE_TX_LIST_MAGIC);
+		   M0_BE_TX_MAGIC, M0_BE_TX_LIST_MAGIC);
 
 M0_TL_DEFINE(tx, M0_INTERNAL, struct m0_be_tx);
 
@@ -389,7 +389,9 @@ M0_INTERNAL void m0_be_tx_close(struct m0_be_tx *tx)
 	eng->te_inmem = tx;
 	m0_be__tx_state_set(tx, M0_BTS_CLOSED);
 
-	tx_engine_got_closed(eng, tx);
+	/* XXX: ABilenko commented this */
+	/* tx_engine_got_closed(eng, tx); */
+	(void) tx_engine_got_closed;
 
 	m0_be_reg_area_used(&tx->t_reg_area, &t_used);
 	prepared = tx_prepared_log_size(tx);
@@ -463,7 +465,7 @@ tx_engine_got_closed(struct m0_be_tx_engine *eng, struct m0_be_tx *tx)
 	M0_PRE(m0_be__tx_state(tx) == M0_BTS_CLOSED);
 	M0_PRE(tx_is_locked(tx));
 
-	struct m0_be_tx_group *gr = &eng->te_group;
+	/* struct m0_be_tx_group *gr = &eng->te_group; */
 #if 0 /* Nikita's code */
 	m0_bcount_t used = tx_log_size(tx, &tx->t_used,
 				       gr_tlist_is_empty(&gr->tg_txs));
@@ -480,9 +482,10 @@ tx_engine_got_closed(struct m0_be_tx_engine *eng, struct m0_be_tx *tx)
 #else /* XXX: close group after every tx close, for now */
 	M0_PRE(m0_be__tx_state(tx) == M0_BTS_CLOSED);
 
-	tx_group_init(gr);
-	tx_group_add(eng, gr, tx);
-	tx_group_close(eng, gr);
+	/* XXX: commmented by ABilenko */
+	/* tx_group_init(gr); */
+	/* tx_group_add(eng, gr, tx); */
+	/* tx_group_close(eng, gr); */
 
 	M0_POST(m0_be__tx_engine_invariant(eng));
 #endif
@@ -536,14 +539,11 @@ static void tx_fail(struct m0_be_tx *tx, int err)
 static void _txs_set_ready(struct m0_be_tx *tx)
 {
 	struct m0_be_tx_group *gr = tx->t_group;
-	int64_t txs_to_be_ready;
 
 	M0_PRE(!gr->tg_opened);
 
-	m0_ref_get(&gr->tg_ready_count);
-
-	txs_to_be_ready = m0_ref_read(&gr->tg_ready_count);
-	if (txs_to_be_ready == gr_tlist_length(&gr->tg_txs))
+	M0_CNT_DEC(gr->tg_pending_count);
+	if (gr->tg_pending_count == 0)
 		m0_fom_wakeup(gr->tg_fom);
 }
 
diff --git a/be/tx_fom.c b/be/tx_fom.c
index a000426..2405b99 100644
--- a/be/tx_fom.c
+++ b/be/tx_fom.c
@@ -142,35 +142,27 @@ enum tx_group_state {
 	TGS_NR
 };
 
-static int        open_st_in(struct m0_sm *mach);
-static int     logging_st_in(struct m0_sm *mach);
-static int  committing_st_in(struct m0_sm *mach);
-static void committing_st_ex(struct m0_sm *mach);
-static int     placing_st_in(struct m0_sm *mach);
+static enum m0_fom_phase_outcome       open_tick(struct m0_fom *fom);
+static enum m0_fom_phase_outcome    logging_tick(struct m0_fom *fom);
+static enum m0_fom_phase_outcome committing_tick(struct m0_fom *fom);
+static enum m0_fom_phase_outcome    placing_tick(struct m0_fom *fom);
 
 static struct m0_sm_state_descr _tx_group_states[TGS_NR] = {
-#define _S(name, flags, in, allowed)  \
+#define _S(name, flags, allowed)  \
 	[name] = {                    \
 		.sd_flags   = flags,  \
 		.sd_name    = #name,  \
-		.sd_in      = in,     \
 		.sd_allowed = allowed \
 	}
 
-	_S(TGS_INIT,   M0_SDF_INITIAL,  NULL, M0_BITS(TGS_OPEN)),
-	_S(TGS_FINISH, M0_SDF_TERMINAL, NULL, 0),
-	_S(TGS_OPEN,    0, open_st_in,    M0_BITS(TGS_LOGGING, TGS_FINISH)),
-	_S(TGS_LOGGING, 0, logging_st_in, M0_BITS(TGS_COMMITTING)),
-	[TGS_COMMITTING] = {
-		.sd_flags   = 0,
-		.sd_name    = "TGS_COMMITTING",
-		.sd_in      = committing_st_in,
-		.sd_ex      = committing_st_ex,
-		.sd_allowed = M0_BITS(TGS_PLACING)
-	},
-	_S(TGS_PLACING, 0, placing_st_in, M0_BITS(TGS_PLACED)),
-	_S(TGS_PLACED,  0, NULL, M0_BITS(TGS_PLACED, TGS_STABLE, TGS_FINISH)),
-	_S(TGS_STABLE,  0, NULL, M0_BITS(TGS_OPEN))
+	_S(TGS_INIT,   M0_SDF_INITIAL, M0_BITS(TGS_OPEN)),
+	_S(TGS_FINISH, M0_SDF_TERMINAL, 0),
+	_S(TGS_OPEN,       0, M0_BITS(TGS_OPEN, TGS_LOGGING, TGS_FINISH)),
+	_S(TGS_LOGGING,    0, M0_BITS(TGS_COMMITTING)),
+	_S(TGS_COMMITTING, 0, M0_BITS(TGS_PLACING)),
+	_S(TGS_PLACING,    0, M0_BITS(TGS_PLACING, TGS_PLACED)),
+	_S(TGS_PLACED,     0, M0_BITS(TGS_PLACED, TGS_STABLE, TGS_FINISH)),
+	_S(TGS_STABLE,     0, M0_BITS(TGS_OPEN))
 #undef _S
 };
 
@@ -189,40 +181,34 @@ struct tx_group_fom {
 	struct m0_fom           tgf_gen;
 	struct m0_be_tx_engine *tgf_engine;
 	struct m0_fom_timeout   tgf_timeout;
+	bool                    tgf_timed_out;
 	struct m0_be_op         tgf_op;
+	struct m0_semaphore     tgf_started;
 };
 
 static int tx_group_tick(struct m0_fom *fom)
 {
-	static const enum tx_group_state next_state[TGS_NR] = {
-		[TGS_INIT]       = TGS_OPEN,
-		[TGS_FINISH]     = -1,
-		[TGS_OPEN]       = TGS_LOGGING,
-		[TGS_LOGGING]    = TGS_COMMITTING,
-		[TGS_COMMITTING] = TGS_PLACING,
-		[TGS_PLACING]    = TGS_PLACED,
-		/*
-		 * Note, that we move a tx_group from TGS_PLACED to TGS_STABLE
-		 * only if all of its transactions are M0_BTS_DONE.
-		 */
-		[TGS_PLACED]     = TGS_STABLE,
-		[TGS_STABLE]     = TGS_OPEN
-	};
-	const struct m0_be_tx_group *gr =
-		&tx_group_fom(fom)->tgf_engine->te_group;
-	const int                    state = m0_fom_phase(fom);
-
-	M0_ENTRY("state=%u", state);
-	M0_PRE(IS_IN_ARRAY(state, next_state));
-
-	if (state == TGS_FINISH) {
-		M0_IMPOSSIBLE("XXX Not implemented");
-	} else if (state != TGS_PLACED ||
-		   m0_tl_forall(gr, tx, &gr->tg_txs,
-				m0_be__tx_state(tx) == M0_BTS_DONE)) {
-		M0_LOG(M0_DEBUG, "Move to state %d", next_state[state]);
-		m0_fom_phase_set(fom, next_state[state]);
+	M0_ENTRY();
+
+	switch (m0_fom_phase(fom)) {
+	case TGS_INIT:
+		m0_fom_phase_set(fom, TGS_OPEN);
+		return M0_FSO_AGAIN;
+	case TGS_OPEN:
+		return open_tick(fom);
+	case TGS_LOGGING:
+		return logging_tick(fom);
+	case TGS_COMMITTING:
+		return committing_tick(fom);
+	case TGS_PLACING:
+		return placing_tick(fom);
+	case TGS_PLACED:
+	case TGS_STABLE:
+	case TGS_FINISH:
+	default:
+		M0_IMPOSSIBLE("");
 	}
+
 	M0_LEAVE();
 	return M0_FSO_WAIT;
 }
@@ -231,6 +217,8 @@ static void tx_group_fom_fini(struct m0_fom *fom)
 {
 	M0_ENTRY();
 	m0_fom_fini(fom);
+	/* XXX*/
+	/* do semaphore fini */
 	M0_LEAVE();
 }
 
@@ -274,6 +262,9 @@ tx_group_fom_create(struct m0_reqh *reqh, struct m0_be_tx_engine *engine)
 
 	engine->te_fom = fom;
 	txm->tgf_engine = engine;
+	m0_fom_timeout_init(&txm->tgf_timeout);
+	txm->tgf_timed_out = false;
+	m0_semaphore_init(&txm->tgf_started, 0);
 
 	return fom;
 }
@@ -294,18 +285,26 @@ m0_be_tx_engine_start(struct m0_be_tx_engine *engine, struct m0_reqh *reqh)
 		M0_RETURN(-ENOMEM);
 
 	m0_fom_queue(fom, reqh);
+
+	/* m0_sm_group_lock(&fom->fo_loc->fl_group); */
+	/* rc = m0_sm_timedwait(&fom->fo_sm_phase, M0_BITS(TGS_OPEN), */
+	/* 		     M0_TIME_NEVER); */
+	/* M0_ASSERT(rc == 0); */
+	/* m0_sm_group_unlock(&fom->fo_loc->fl_group); */
+	m0_semaphore_down(&tx_group_fom(fom)->tgf_started);
+
 	M0_RETURN(0);
 }
 
 /* ------------------------------------------------------------------
  * Casts
  * ------------------------------------------------------------------ */
+/* static const struct m0_fom *sm_to_fom(const struct m0_sm *sm) */
+/* { */
+/* 	/\* XXX TODO bob_of() *\/ */
+/* 	return container_of(sm, const struct m0_fom, fo_sm_phase); */
+/* } */
 
-static const struct m0_fom *sm_to_fom(const struct m0_sm *sm)
-{
-	/* XXX TODO bob_of() */
-	return container_of(sm, const struct m0_fom, fo_sm_phase);
-}
 
 static struct tx_group_fom *tx_group_fom(const struct m0_fom *fom)
 {
@@ -320,57 +319,75 @@ static struct tx_group_fom *tx_group_fom(const struct m0_fom *fom)
 /* XXX: IMPLEMENTME */
 static bool add_if_grp_has_space(struct m0_be_tx_group *gr, struct m0_be_tx *tx)
 {
+	/*
+	 * Dummy impl. Just add one tx and that's it.
+	 */
 	M0_PRE(m0_be__tx_state(tx) == M0_BTS_CLOSED);
+	gr_tlist_add(&gr->tg_txs, tx);
 	return true;
 }
 
-static int open_st_in(struct m0_sm *mach)
+static enum m0_fom_phase_outcome open_tick(struct m0_fom *f)
 {
-	struct tx_group_fom    *fom = tx_group_fom(sm_to_fom(mach));
+	struct tx_group_fom    *fom = tx_group_fom(f);
 	struct m0_be_tx_engine *eng = fom->tgf_engine;
 	struct m0_be_tx_group  *gr  = &eng->te_group;
 	struct m0_be_tx        *tx;
 	bool			ready_to_close;
+	bool                    one_and_more_tx_grouped;
 	int                     rc;
 
-	M0_ENTRY("%d", gr->tg_opened);
+	M0_ENTRY("gr->tg_opened: %d", !!gr->tg_opened);
+	m0_semaphore_up(&fom->tgf_started);
 
 	if (!gr->tg_opened)
 		if (gr_tlist_is_empty(&gr->tg_txs))
 			tx_group_open(eng, gr);
 
-	ready_to_close = m0_tl_forall(tx, tx, &eng->te_txs[M0_BTS_CLOSED],
-				      add_if_grp_has_space(gr, tx));
+	ready_to_close = !tx_tlist_is_empty(&eng->te_txs[M0_BTS_CLOSED]) &&
+		m0_tl_forall(tx, tx, &eng->te_txs[M0_BTS_CLOSED],
+			     !add_if_grp_has_space(gr, tx));
+	one_and_more_tx_grouped = !gr_tlist_is_empty(&gr->tg_txs);
+
+	if (ready_to_close || (fom->tgf_timed_out && one_and_more_tx_grouped)) {
+		M0_LOG(M0_DEBUG, "group is ready to close [%d, %d]",
+		       !!ready_to_close, !!fom->tgf_timed_out);
+
+		fom->tgf_timed_out = false;
+		gr->tg_pending_count = gr_tlist_length(&gr->tg_txs);
 
-	if (ready_to_close) {
 		m0_tl_for(gr, &gr->tg_txs, tx) {
 			m0_be__tx_state_post(tx, M0_BTS_GROUPED);
 		} m0_tl_endfor;
+
 		tx_group_close(eng, gr);
 		m0_fom_phase_set(&fom->tgf_gen, TGS_LOGGING);
 	} else {
 		/* arm timeout */
+		M0_LOG(M0_DEBUG, "arm timeout");
+		fom->tgf_timed_out = true;
 		m0_fom_timeout_init(&fom->tgf_timeout);
 		rc = m0_fom_timeout_wait_on(&fom->tgf_timeout, &fom->tgf_gen,
-					    m0_time_from_now(1, 0)); /* 1 sec */
+					    m0_time_from_now(2, 0)); /* 2 sec */
 		M0_ASSERT(rc == 0);
 	}
 
-	M0_RETURN(0);
+	M0_LEAVE();
+	return M0_FSO_WAIT;
 }
 
-static int logging_st_in(struct m0_sm *mach)
+static enum m0_fom_phase_outcome logging_tick(struct m0_fom *m)
 {
-	struct tx_group_fom    *fom = tx_group_fom(sm_to_fom(mach));
+	struct tx_group_fom    *fom = tx_group_fom(m);
 	struct m0_be_tx_engine *eng = fom->tgf_engine;
 	struct m0_be_tx_group  *gr  = &eng->te_group;
 	struct m0_be_op        *op  = &fom->tgf_op;
-	int rc;
+
+	M0_ENTRY();
 
 	M0_PRE(m0_tl_forall(gr, tx, &gr->tg_txs,
 			    m0_be__tx_state(tx) == M0_BTS_GROUPED));
-
-	M0_ENTRY();
+	M0_PRE(gr->tg_pending_count == 0);
 
 	m0_be_op_init(op);
 	/*
@@ -378,34 +395,24 @@ static int logging_st_in(struct m0_sm *mach)
 	 */
 
 	/* XXX: max has to integrate */
-#if !XXX_MOCK_IO
+#if XXX_MOCK_IO
+	_arm_io(op);
+#else
 	m0_be_log_payload_prepare(&eng->te_log, gr);
 	m0_be_log_submit(&eng->te_log, op, gr);
-#else
-	_arm_io(op);
 #endif
-	rc = m0_be_op_tick_ret(op, &fom->tgf_gen, TGS_COMMITTING);
-	M0_ASSERT(rc == M0_FSO_WAIT);
-
-	/*
-	 * XXX: here can be a race condition, because IO can be
-	 * performed immediately, and fom will have to transit
-	 * into the next state right here, without to be
-	 * awaken. So generally m0_be_op_tick_ret() has to be
-	 * called from the fom, or use sm chaining here...
-	 */
-	M0_RETURN(0);
+	M0_LEAVE();
+	return m0_be_op_tick_ret(op, &fom->tgf_gen, TGS_COMMITTING);
 }
 
-static int committing_st_in(struct m0_sm *mach)
+static enum m0_fom_phase_outcome committing_tick(struct m0_fom *m)
 {
-	struct tx_group_fom    *fom = tx_group_fom(sm_to_fom(mach));
+	struct tx_group_fom    *fom = tx_group_fom(m);
 #if !XXX_MOCK_IO
 	struct m0_be_tx_engine *eng = fom->tgf_engine;
 	struct m0_be_tx_group  *gr  = &eng->te_group;
 #endif
 	struct m0_be_op        *op  = &fom->tgf_op;
-	int rc;
 
 	/* XXX: on error transit to failure state, and finish system */
 	M0_PRE(m0_be_op_state(op) == M0_BOS_SUCCESS);
@@ -418,28 +425,21 @@ static int committing_st_in(struct m0_sm *mach)
 	 */
 
 	/* XXX: max has to integrate */
-#if !XXX_MOCK_IO
+#if XXX_MOCK_IO
+	_arm_io(op);
+#else
 	m0_be_log_commit_block_prepare(&eng->te_log, gr);
 	m0_be_log_submit(&eng->te_log, op, gr);
-#else
-	_arm_io(op);
 #endif
-	rc = m0_be_op_tick_ret(op, &fom->tgf_gen, TGS_PLACED);
-	M0_ASSERT(rc == M0_FSO_WAIT);
 
-	/*
-	 * XXX: here can be a race condition, because IO can be
-	 * performed immediately, and fom will have to transit
-	 * into the next state right here, without to be
-	 * awaken. So generally m0_be_op_tick_ret() has to be
-	 * called from the fom, or use sm chaining here...
-	 */
-	M0_RETURN(0);
+	M0_LEAVE();
+	return m0_be_op_tick_ret(op, &fom->tgf_gen, TGS_PLACED);
 }
 
-static void committing_st_ex(struct m0_sm *mach)
+#if 0 /* XXX */
+static enum m0_fom_phase_outcome committing_st_ex(struct m0_fom *m)
 {
-	struct tx_group_fom    *fom = tx_group_fom(sm_to_fom(mach));
+	struct tx_group_fom    *fom = tx_group_fom(m);
 	struct m0_be_tx_engine *eng = fom->tgf_engine;
 	struct m0_be_tx_group  *gr  = &eng->te_group;
 	struct m0_be_tx        *tx;
@@ -450,12 +450,14 @@ static void committing_st_ex(struct m0_sm *mach)
 		tx->t_persistent(tx);
 	} m0_tl_endfor;
 
+	gr->tg_pending_count = gr_tlist_length(&gr->tg_txs);
 	M0_LEAVE();
 }
+#endif
 
-static int placing_st_in(struct m0_sm *mach)
+static enum m0_fom_phase_outcome placing_tick(struct m0_fom *m)
 {
-	struct tx_group_fom    *fom = tx_group_fom(sm_to_fom(mach));
+	struct tx_group_fom    *fom = tx_group_fom(m);
 	struct m0_be_tx_engine *eng = fom->tgf_engine;
 	struct m0_be_tx_group  *gr  = &eng->te_group;
 	struct m0_be_op        *op  = &fom->tgf_op;
@@ -468,23 +470,27 @@ static int placing_st_in(struct m0_sm *mach)
 
 	/* XXX: PRE() check that tx is working with the same segment */
 	M0_PRE(!gr_tlist_is_empty(&gr->tg_txs));
+	M0_PRE(gr->tg_pending_count > 0);
+
+
+	M0_CNT_DEC(gr->tg_pending_count);
 
 	tx = gr_tlist_head(&gr->tg_txs);
 	gr_tlist_del(tx);
 	if (gr_tlist_is_empty(&gr->tg_txs))
 		m0_fom_phase_set(&fom->tgf_gen, TGS_PLACED);
 
-
 	/* perform IO */
 	area = &tx->t_reg_area;
 	seg = m0_be_regmap_first(&area->bra_map)->rd_reg.br_seg;
 	m0_be_op_init(op);
 	m0_be_seg_write_simple(seg, op, area);
 
-	rc = m0_be_op_tick_ret(op, &fom->tgf_gen, TGS_PLACED);
+	rc = m0_be_op_tick_ret(op, &fom->tgf_gen, TGS_PLACING);
 	M0_ASSERT(rc == M0_FSO_WAIT);
 
-	M0_RETURN(0);
+	M0_LEAVE();
+	return M0_FSO_WAIT;
 }
 
 /** @} end of be group */
diff --git a/be/tx_group.c b/be/tx_group.c
index f6f21d8..97f266c 100644
--- a/be/tx_group.c
+++ b/be/tx_group.c
@@ -30,8 +30,8 @@
 
 M0_TL_DESCR_DEFINE(gr, "tx group", M0_INTERNAL, struct m0_be_tx,
 		   t_group_linkage, t_magic,
-		   M0_TRACE_TX_MAGIC,
-		   M0_TRACE_TX_GROUP_LIST_MAGIC);
+		   M0_BE_TX_MAGIC,
+		   M0_BE_TX_GROUP_LIST_MAGIC);
 
 M0_TL_DEFINE(gr, M0_INTERNAL, struct m0_be_tx);
 
@@ -125,16 +125,15 @@ tx_group_close(struct m0_be_tx_engine *eng, struct m0_be_tx_group *gr)
 	/* XXX TODO ... */
 
 	gr->tg_opened = false;
-	m0_fom_wakeup(eng->te_fom);
+	/* m0_fom_wakeup(eng->te_fom); */
 }
 
 M0_INTERNAL void tx_group_open(struct m0_be_tx_engine *eng,
-				struct m0_be_tx_group *gr)
+			       struct m0_be_tx_group *gr)
 {
 	M0_PRE(gr_tlist_is_empty(&gr->tg_txs));
 	gr->tg_opened = true;
 
-	m0_ref_init(&gr->tg_ready_count, 0, NULL);
 	gr->tg_fom = eng->te_fom;
 }
 
diff --git a/be/tx_group.h b/be/tx_group.h
index 6a104e9..e9fd21e 100644
--- a/be/tx_group.h
+++ b/be/tx_group.h
@@ -67,8 +67,8 @@ struct m0_be_tx_group {
 	/** List of transactions in the group. */
 	struct m0_tl            tg_txs;
 
-	/** counter which counts ready transactions in the group */
-	struct m0_ref           tg_ready_count;
+	/** counter which counts pending transactions in the group */
+	uint32_t                tg_pending_count;
 
 	/** fom which processes current group */
 	struct m0_fom          *tg_fom;
diff --git a/be/ut/tx.c b/be/ut/tx.c
index f44268a..d0670fe 100644
--- a/be/ut/tx.c
+++ b/be/ut/tx.c
@@ -42,7 +42,6 @@ static void tx_test(struct m0_be *be)
 
 	M0_ENTRY();
 
-	m0_be_init(be);
 	m0_be_op_init(&op);
 	m0_be_tx_credit_init(&cred);
 
@@ -78,7 +77,6 @@ static void tx_test(struct m0_be *be)
 	m0_sm_group_unlock(&g_grp);
 
 	m0_be_op_fini(&op);
-	m0_be_fini(be);
 
 	M0_LEAVE();
 }
@@ -114,12 +112,15 @@ static void test_tx_svc(void)
 	reqh = m0_mero_to_rmach(&tx_svc.rsx_mero_ctx)->rm_reqh;
 	M0_UT_ASSERT(reqh != NULL);
 
+	m0_be_init(&be);
 	rc = m0_be_tx_engine_start(&be.b_tx, reqh);
 	M0_UT_ASSERT(rc == 0);
-	sleep(2); /* give reqh some time to start */
+	/* sleep(3); give reqh some time to start */
 
 	tx_test(&be);
 
+	m0_be_fini(&be);
+
 	m0_rpc_server_stop(&tx_svc);
 	M0_LEAVE();
 }
diff --git a/mero/magic.h b/mero/magic.h
index 21ff67c..8be11bc 100644
--- a/mero/magic.h
+++ b/mero/magic.h
@@ -723,11 +723,11 @@ enum m0_magic_satchel {
 
 /* BE */
 	/* m0_be_tx::t_magic (I feel good) */
-	M0_TRACE_TX_MAGIC            = 0x331fee190000d177,
+	M0_BE_TX_MAGIC            = 0x331fee190000d177,
 	/* m0_be_tx transactions list head magic (lifeless gel)  */
-	M0_TRACE_TX_LIST_MAGIC       = 0x3311FE1E556E1277,
+	M0_BE_TX_LIST_MAGIC       = 0x3311fe1e556e1277,
 	/* m0_be_tx tx group list head magic (codified bee)  */
-	M0_TRACE_TX_GROUP_LIST_MAGIC = 0x33c0d1f1edbee377,
+	M0_BE_TX_GROUP_LIST_MAGIC = 0x33c0d1f1edbee377,
 };
 
 #endif /* __MERO_MERO_MAGIC_H__ */
-- 
1.8.3.2

