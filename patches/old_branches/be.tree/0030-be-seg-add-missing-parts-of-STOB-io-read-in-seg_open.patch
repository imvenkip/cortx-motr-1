From 63beb5215d25ad7163efd15695d6162da0a37053 Mon Sep 17 00:00:00 2001
From: Alexander Gattin <alexander_gattin@xyratex.com>
Date: Wed, 29 May 2013 13:43:09 +0300
Subject: [PATCH 030/290] be/seg: add missing parts of STOB io read in
 seg_open().

---
 be/seg.c | 57 ++++++++++++++++++++++++++++++++++++++-------------------
 1 file changed, 38 insertions(+), 19 deletions(-)

diff --git a/be/seg.c b/be/seg.c
index 95a7747..8296774 100644
--- a/be/seg.c
+++ b/be/seg.c
@@ -122,36 +122,55 @@ int m0_be_seg_open(struct m0_be_seg *seg)
 #else /*XXX*/
 	struct m0_stob_io io;
 	struct m0_clink   clink;
-	int               r;
+	int               rc;
 	uint32_t          st_block_shift;
-	/* XXX: need to declare buffers/vectors etc for STOBIO */
-	m0_bcount_t       rdvec[1];
-
-	M0_PRE(seg->bs_state == M0_BSS_INIT);
-
+	size_t            st_block_size;
+	m0_bcount_t       rdcnt[1];    /* sectors counts */
+	m0_bcount_t       rdoffs[1];   /* offsets */
+	be_seg_hdr       *hdrbuf[1];   /* read buffers */
+	void             *rdbufpk[1];  /* "packed" addresses */
+	void             *seg_addr0;
+	m0_bcount_t       seg_size;
+
+	/* Allocate buffer for STOB io. */
 	st_block_shift = seg->bs_stob->so_op->sop_block_shift(seg->bs_stob);
+	st_block_size = 1 << st_block_shift;
+	rdcnt[0] = (sizeof(be_seg_hdr) + st_block_size - 1) / st_block_size;
+	rdbuf[0] = m0_alloc_aligned(rdcnt[0] * st_block_size, st_block_shift);
+	if (rdbuf[0] == NULL)
+		return -ENOMEM;
+
+	/* Set up io struct for reading. */
 	m0_stob_io_init(&io);
-	/* TODO: prepare buffer for stob IO, align etc */
-	io.si_flags  = 0;
-	io.si_opcode = SIO_READ;
-	/* io.si_user.ov_buf = ;*/
+	rdbufpk[0]                = m0_stob_addr_pack(hdrbuf[0],
+						      st_block_shift);
+	io.si_flags               = 0;
+	io.si_opcode              = SIO_READ;
+	io.si_user.ov_buf         = rdbufpk;
+	io.si_user.ov_vec.v_nr    = 1;
+	rdoffs[0]                 = 0;  /* header offset in STOB */
+	io.si_user.ov_vec.v_count = rdcnt;
+	io.si_stob.iv_vec.v_nr    = 1;
+	io.si_stob.iv_vec.v_count = rdcnt;
+	io.si_stob.iv_index       = rdoffs;
 
 	m0_clink_init(&clink, NULL);
 	m0_clink_add_lock(&io.si_wait, &clink);
-	r = m0_stob_io_launch(&io, seg->bs_stob, NULL, NULL);
-	if (r == 0) {
+	rc = m0_stob_io_launch(&io, seg->bs_stob, NULL, NULL);
+	if (rc == 0) {
 		m0_chan_wait(&clink);
-	};
+		rc = io.si_rc;
+	}
+	if (rc == 0) {
+		seg_addr0 = hdrbuf[0]->bh_addr;
+		seg_size  = hdrbuf[0]->bh_size;
+	}
+	m0_free(rdbuf[0]);
 	m0_clink_del_lock(&clink);
 	m0_clink_fini(&clink);
 	m0_stob_io_fini(&io);
-	if (r != 0)
-		return r;
+	if (rc != 0) return rc;
 
-	rc = m0_be_allocator_init(&seg->bs_allocator, seg);
-	if (rc != 0)
-		return rc;
-	seg->bs_state = M0_BSS_OPENED;
 	/* TODO: mmap an area at bh_addr of bh_size */
 	return 0;
 #endif /*XXX*/
-- 
1.8.3.2

