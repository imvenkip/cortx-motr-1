From a60a0c06c296e7df7f5a7e5815682fa62d5b6c4a Mon Sep 17 00:00:00 2001
From: Anatoliy Bilenko <anatoliy_bilenko@xyratex.com>
Date: Tue, 4 Jun 2013 19:29:33 +0300
Subject: [PATCH 101/290] be: added test_insert into btree ut.

---
 be/ut/btree.c | 56 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 56 insertions(+)

diff --git a/be/ut/btree.c b/be/ut/btree.c
index 9b014e6..880fac0 100644
--- a/be/ut/btree.c
+++ b/be/ut/btree.c
@@ -20,7 +20,9 @@
 #include "ut/ut.h"
 #include "be/tx.h"
 #include "be/be.h"
+#include "be/seg.h"
 #include "be/btree.h"
+#include "be/alloc.h"
 #include "lib/misc.h"
 
 extern void m0_be_ut_seg_create(void);
@@ -89,11 +91,13 @@ void test_create(void)
 	m0_be_btree_init(&tree, &m0_be_ut_seg, &kv_ops, NULL);
 	m0_be_btree_credit(&tree, M0_BBO_CREATE, 1, &cred);
 
+	m0_be_tx_prep(&tx, &cred);
 	m0_be_tx_open(&tx);
 	m0_be_btree_create(&tree, &tx, &op);
 	M0_UT_ASSERT(M0_IN(m0_be_op_state(&op), (M0_BOS_SUCCESS,
 						 M0_BOS_FAILURE)));
 	m0_be_tx_close(&tx);
+	M0_UT_ASSERT(m0_be_tx_timedwait(&tx, M0_TIME_NEVER) == 0);
 }
 
 void test_destroy(void)
@@ -105,18 +109,70 @@ void test_destroy(void)
  	m0_be_tx_init(&tx, tid++, &be, persistent, discarded, NULL);
 	m0_be_btree_credit(&tree, M0_BBO_DESTROY, 1, &cred);
 
+	m0_be_tx_prep(&tx, &cred);
 	m0_be_tx_open(&tx);
 	m0_be_btree_create(&tree, &tx, &op);
 	M0_UT_ASSERT(M0_IN(m0_be_op_state(&op), (M0_BOS_SUCCESS,
 						 M0_BOS_FAILURE)));
 	m0_be_tx_close(&tx);
+	M0_UT_ASSERT(m0_be_tx_timedwait(&tx, M0_TIME_NEVER) == 0);
 
 	be_op_fini(&op);
 	be_fini(&be);
 }
 
+enum {
+	INSERT_NR   = 100,
+	ALLOC_SHIFT = 1, /* XXX */
+	ALLOC_SIZE  = 8
+};
+
 void test_insert(void)
 {
+	struct m0_be_op         op;
+	struct m0_be_tx         tx;
+	struct m0_be_tx_credit  tree_cred;
+	struct m0_be_tx_credit  cred;
+	struct m0_buf           key;
+	struct m0_buf           val;
+	struct m0_be_allocator *alloc = &tree.bb_seg->bs_allocator;
+	int			i;
+
+ 	m0_be_tx_init(&tx, tid++, &be, persistent, discarded, NULL);
+	m0_be_btree_credit(&tree, M0_BBO_INSERT, INSERT_NR, &tree_cred);
+
+	m0_be_allocator_credit(alloc, M0_BAO_ALLOC, ALLOC_SIZE,
+			       ALLOC_SHIFT, &cred);
+
+	m0_be_tx_credit_mul(&cred, INSERT_NR * 2); /* 2: for 1-key and 1-val */
+	m0_be_tx_credit_add(&cred, &tree_cred);
+
+	m0_be_tx_prep(&tx, &cred);
+	m0_be_tx_open(&tx);
+
+	for (i = 0; i < INSERT_NR; ++i) {
+		m0_buf_init(&key, m0_be_alloc(alloc, &tx, ALLOC_SIZE,
+					      ALLOC_SHIFT), ALLOC_SIZE);
+		m0_buf_init(&val, m0_be_alloc(alloc, &tx, ALLOC_SIZE,
+					      ALLOC_SHIFT), ALLOC_SIZE);
+		M0_UT_ASSERT(key.b_addr != NULL);
+		M0_UT_ASSERT(val.b_addr != NULL);
+
+		sprintf(key.b_addr, "%d", i);
+		sprintf(val.b_addr, "%d", i);
+
+		m0_be_tx_capture(&tx, &M0_BE_REG(tree.bb_seg, ALLOC_SIZE,
+						 key.b_addr));
+		m0_be_tx_capture(&tx, &M0_BE_REG(tree.bb_seg, ALLOC_SIZE,
+						 val.b_addr));
+
+		m0_be_btree_insert(&tree, &tx, &op, &key, &val);
+		M0_UT_ASSERT(M0_IN(m0_be_op_state(&op), (M0_BOS_SUCCESS,
+							 M0_BOS_FAILURE)));
+	}
+
+	m0_be_tx_close(&tx);
+	M0_UT_ASSERT(m0_be_tx_timedwait(&tx, M0_TIME_NEVER) == 0);
 }
 
 void test_update(void)
-- 
1.8.3.2

