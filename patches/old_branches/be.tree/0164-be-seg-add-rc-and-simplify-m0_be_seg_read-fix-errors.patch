From a6907b511076dbefaaaa54e79704ef47bdc83f99 Mon Sep 17 00:00:00 2001
From: Alexander Gattin <alexander_gattin@xyratex.com>
Date: Tue, 18 Jun 2013 12:20:56 +0300
Subject: [PATCH 164/290] be/seg: add rc and simplify m0_be_seg_read(), fix
 errors in m0_be_seg_write().

---
 be/seg.c | 33 +++++++++++++++++++--------------
 be/seg.h |  2 +-
 2 files changed, 20 insertions(+), 15 deletions(-)

diff --git a/be/seg.c b/be/seg.c
index f23afe8..bafa063 100644
--- a/be/seg.c
+++ b/be/seg.c
@@ -223,6 +223,7 @@ M0_INTERNAL int m0_be_seg_read(struct m0_be_seg *seg,
 	struct m0_clink    *clink;
 	struct m0_indexvec *iv;
 	m0_bcount_t         i;
+	int                 rc;
 
 	M0_PRE(m0_be__seg_invariant(seg) && op != NULL);
 
@@ -259,22 +260,26 @@ M0_INTERNAL int m0_be_seg_read(struct m0_be_seg *seg,
 	}
 	/* Add clink and start STOB i/o. */
 	m0_clink_add_lock(&io->si_wait, clink);
-	op->bo_sm.sm_rc = m0_stob_io_launch(io, seg->bs_stob, NULL, NULL);
-	m0_sm_state_set(&op->bo_sm, M0_BOS_ACTIVE);
+	rc = m0_stob_io_launch(io, seg->bs_stob, NULL, NULL);
+	if (rc != 0)
+		goto fin;
+	else
+		m0_sm_state_set(&op->bo_sm, M0_BOS_ACTIVE);
+
 	/* XXX: STOB i/o is completed synchronously here. */
-	if (op->bo_sm.sm_rc == 0) {
-		m0_chan_wait(clink);
-		op->bo_sm.sm_rc = io->si_rc;
-	}
+	m0_chan_wait(clink);
+	rc = io->si_rc;
+fin:
 	m0_clink_del_lock(clink);
 	m0_clink_fini(clink);
 	m0_stob_io_fini(io);
-	if (op->bo_sm.sm_rc == 0) {
+	op->bo_sm.sm_rc = rc;
+	if (rc == 0) {
 		m0_sm_state_set(&op->bo_sm, M0_BOS_SUCCESS);
 	} else {
 		m0_sm_state_set(&op->bo_sm, M0_BOS_FAILURE);
 	}
-	return op->bo_sm.sm_rc;
+	return rc;
 }
 
 M0_INTERNAL int m0_be_seg_open(struct m0_be_seg *seg)
@@ -367,14 +372,14 @@ M0_INTERNAL int m0_be_seg_write(struct m0_be_seg *seg,
 	M0_PRE(m0_be__seg_invariant(seg) && op != NULL);
 
 	/* Set up op, clink and io structs for SEGIO write. */
-	op->bo_utype       = M0_BOP_SEGIO;
-	clink              = &op->bo_u.u_segio.si_clink;
-	io                 = &op->bo_u.u_segio.si_stobio;
+	op->bo_utype        = M0_BOP_SEGIO;
+	clink               = &op->bo_u.u_segio.si_clink;
+	io                  = &op->bo_u.u_segio.si_stobio;
 	m0_clink_init(clink, NULL);
 	m0_stob_io_init(io);
-	io->si_flags       = 0;
-	io->si_opcode      = SIO_WRITE;
-	io.si_fol_rec_part = (void *)1;
+	io->si_flags        = 0;
+	io->si_opcode       = SIO_WRITE;
+	io->si_fol_rec_part = (void *)1;
 
 	/* Allocate and fill counts, buffers and indexes arrays. */
 	rc = m0_be_seg_bufvec_build(seg, regd_tree, &io->si_stob,
diff --git a/be/seg.h b/be/seg.h
index b6405d7..2a1095b 100644
--- a/be/seg.h
+++ b/be/seg.h
@@ -103,7 +103,7 @@ M0_INTERNAL int m0_be_seg_read(struct m0_be_seg *seg,
 
 M0_INTERNAL int m0_be_seg_write(struct m0_be_seg *seg,
 				void *regd_tree,
-				struct m0_bufvec *bv);
+				struct m0_be_op *op);
 
 M0_INTERNAL int m0_be_seg_bufvec_build(struct m0_be_seg *seg,
 				       void *regd_tree,
-- 
1.8.3.2

