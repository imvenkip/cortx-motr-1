From a5a689ad74043f493d60859f73f6d00598e39164 Mon Sep 17 00:00:00 2001
From: Anatoliy Bilenko <anatoliy_bilenko@xyratex.com>
Date: Thu, 4 Jul 2013 12:09:39 +0300
Subject: [PATCH 276/290] be: tx_fom: implemented tx_fom state sd_in(),
 sd_ex().

---
 be/tx_fom.c | 129 ++++++++++++++++++++++++++++++++++++++++++++++--------------
 1 file changed, 100 insertions(+), 29 deletions(-)

diff --git a/be/tx_fom.c b/be/tx_fom.c
index 84d9141..b79e7e7 100644
--- a/be/tx_fom.c
+++ b/be/tx_fom.c
@@ -294,7 +294,8 @@ static struct tx_group_fom *tx_group_fom(const struct m0_fom *fom)
  * State transitions
  * ------------------------------------------------------------------ */
 
-static bool add_if_has_space(struct m0_be_tx_group *gr, struct m0_be_tx *tx)
+/* XXX: IMPLEMENTME */
+static bool add_if_grp_has_space(struct m0_be_tx_group *gr, struct m0_be_tx *tx)
 {
 	M0_PRE(m0_be__tx_state(tx) == M0_BTS_CLOSED);
 	return true;
@@ -311,28 +312,19 @@ static int open_st_in(struct m0_sm *mach)
 
 	M0_ENTRY("%d", gr->tg_opened);
 
-	if (!gr->tg_opened) {
+	if (!gr->tg_opened)
 		if (gr_tlist_is_empty(&gr->tg_txs))
 			tx_group_open(eng, gr);
-		else { /* all txs are grouped */
-			M0_PRE(m0_tl_forall(gr, tx, &gr->tg_txs,
-					    m0_be__tx_state(tx)
-					    == M0_BTS_GROUPED));
-			m0_fom_phase_set(&fom->tgf_gen, TGS_LOGGING);
-			/*
-			 * here we have to run first portion of logio
-			 */
-		}
-	}
 
 	ready_to_close = m0_tl_forall(tx, tx, &eng->te_txs[M0_BTS_CLOSED],
-				      add_if_has_space(gr, tx));
+				      add_if_grp_has_space(gr, tx));
 
 	if (ready_to_close) {
 		m0_tl_for(gr, &gr->tg_txs, tx) {
 			m0_be__tx_state_post(tx, M0_BTS_GROUPED);
 		} m0_tl_endfor;
 		tx_group_close(eng, gr);
+		m0_fom_phase_set(&fom->tgf_gen, TGS_LOGGING);
 	} else {
 		/* arm timeout */
 		m0_fom_timeout_init(&fom->tgf_timeout);
@@ -346,47 +338,126 @@ static int open_st_in(struct m0_sm *mach)
 
 static int logging_st_in(struct m0_sm *mach)
 {
+	struct tx_group_fom    *fom = tx_group_fom(sm_to_fom(mach));
+	struct m0_be_tx_engine *eng = fom->tgf_engine;
+	struct m0_be_tx_group  *gr  = &eng->te_group;
+	struct m0_be_op        *op  = &fom->tgf_op;
+	int rc;
+
+	M0_PRE(m0_tl_forall(gr, tx, &gr->tg_txs,
+			    m0_be__tx_state(tx) == M0_BTS_GROUPED));
+
 	M0_ENTRY();
 
-	/* XXX TODO: Initiate 1st log IO (tx_group and, when the log is
-	 * wrapped, log header). */
-	M0_IMPOSSIBLE("XXX Not implemented");
+	m0_be_op_init(op);
+	/*
+	 * here we have to run first portion of logio
+	 */
 
-	M0_LEAVE();
-	return -1;
+	/* XXX: max has to integrate */
+#if 0
+	m0_be_log_payload_prepare(&eng->te_log, gr);
+	m0_be_log_submit(&eng->te_log, op, gr);
+#endif
+	rc = m0_be_op_tick_ret(op, &fom->tgf_gen, TGS_COMMITTING);
+	M0_ASSERT(rc == M0_FSO_WAIT);
+
+	/*
+	 * XXX: here can be a race condition, because IO can be
+	 * performed immediately, and fom will have to transit
+	 * into the next state right here, without to be
+	 * awaken. So generally m0_be_op_tick_ret() has to be
+	 * called from the fom, or use sm chaining here...
+	 */
+	M0_RETURN(0);
 }
 
 static int committing_st_in(struct m0_sm *mach)
 {
+	struct tx_group_fom    *fom = tx_group_fom(sm_to_fom(mach));
+#if 0
+	struct m0_be_tx_engine *eng = fom->tgf_engine;
+	struct m0_be_tx_group  *gr  = &eng->te_group;
+#endif
+	struct m0_be_op        *op  = &fom->tgf_op;
+	int rc;
+
+	/* XXX: on error transit to failure state, and finish system */
+	M0_PRE(m0_be_op_state(op) == M0_BOS_SUCCESS);
+
 	M0_ENTRY();
 
-	/* XXX TODO: Initiate 2nd log IO (commit block). */
-	M0_IMPOSSIBLE("XXX Not implemented");
+	m0_be_op_init(op);
+	/*
+	 * here we have to run first portion of logio
+	 */
 
-	M0_LEAVE();
-	return -1;
+	/* XXX: max has to integrate */
+#if 0
+	m0_be_log_commit_block_prepare(&eng->te_log, gr);
+	m0_be_log_submit(&eng->te_log, op, gr);
+#endif
+	rc = m0_be_op_tick_ret(op, &fom->tgf_gen, TGS_PLACED);
+	M0_ASSERT(rc == M0_FSO_WAIT);
+
+	/*
+	 * XXX: here can be a race condition, because IO can be
+	 * performed immediately, and fom will have to transit
+	 * into the next state right here, without to be
+	 * awaken. So generally m0_be_op_tick_ret() has to be
+	 * called from the fom, or use sm chaining here...
+	 */
+	M0_RETURN(0);
 }
 
 static void committing_st_ex(struct m0_sm *mach)
 {
+	struct tx_group_fom    *fom = tx_group_fom(sm_to_fom(mach));
+	struct m0_be_tx_engine *eng = fom->tgf_engine;
+	struct m0_be_tx_group  *gr  = &eng->te_group;
+	struct m0_be_tx        *tx;
+
 	M0_ENTRY();
 
-	/* XXX TODO: Invoke m0_be_tx::t_persistent() for each transaction
-	 * of the tx_group. */
-	M0_IMPOSSIBLE("XXX Not implemented");
+	m0_tl_for(gr, &gr->tg_txs, tx) {
+		tx->t_persistent(tx);
+	} m0_tl_endfor;
 
 	M0_LEAVE();
 }
 
 static int placing_st_in(struct m0_sm *mach)
 {
+	struct tx_group_fom    *fom = tx_group_fom(sm_to_fom(mach));
+	struct m0_be_tx_engine *eng = fom->tgf_engine;
+	struct m0_be_tx_group  *gr  = &eng->te_group;
+	struct m0_be_op        *op  = &fom->tgf_op;
+	struct m0_be_tx        *tx;
+	struct m0_be_seg       *seg;
+	struct m0_be_reg_area  *area;
+	int rc;
+
 	M0_ENTRY();
 
-	/* XXX TODO: Initiate in-place IO. */
-	M0_IMPOSSIBLE("XXX Not implemented");
+	/* XXX: PRE() check that tx is working with the same segment */
+	M0_PRE(!gr_tlist_is_empty(&gr->tg_txs));
 
-	M0_LEAVE();
-	return -1;
+	tx = gr_tlist_head(&gr->tg_txs);
+	gr_tlist_del(tx);
+	if (gr_tlist_is_empty(&gr->tg_txs))
+		m0_fom_phase_set(&fom->tgf_gen, TGS_PLACED);
+
+
+	/* perform IO */
+	area = &tx->t_reg_area;
+	seg = m0_be_regmap_first(&area->bra_map)->rd_reg.br_seg;
+	m0_be_op_init(op);
+	m0_be_seg_write_simple(seg, op, area);
+
+	rc = m0_be_op_tick_ret(op, &fom->tgf_gen, TGS_PLACED);
+	M0_ASSERT(rc == M0_FSO_WAIT);
+
+	M0_RETURN(0);
 }
 
 /** @} end of be group */
-- 
1.8.3.2

