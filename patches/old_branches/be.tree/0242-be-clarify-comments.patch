From 608f36ccc2991b91b15082b194433abdf6554266 Mon Sep 17 00:00:00 2001
From: "Valery V. Vorotyntsev" <valery_vorotyntsev@xyratex.com>
Date: Thu, 27 Jun 2013 00:52:11 +0300
Subject: [PATCH 242/290] be: clarify comments

---
 be/tx.c       | 29 ++++++++++++++++-------------
 be/tx.h       | 12 +++++++-----
 be/tx_fom.c   |  4 ++++
 be/tx_group.c |  8 ++++++--
 4 files changed, 33 insertions(+), 20 deletions(-)

diff --git a/be/tx.c b/be/tx.c
index b1c8de9..f694e58 100644
--- a/be/tx.c
+++ b/be/tx.c
@@ -459,11 +459,10 @@ M0_INTERNAL void m0_be_tx_close(struct m0_be_tx *tx)
 
 	tx_engine_got_space(eng);
 
-	/* XXX */
-	M0_LOG(M0_DEBUG, "wakeup");
+#if 1 /* XXX DELETEME? */
+	M0_LOG(M0_DEBUG, "Posting AST to engine->te_fom's sm_group");
 	m0_fom_wakeup(eng->te_fom);
-	M0_LOG(M0_DEBUG, "awaken");
-
+#endif
 	M0_POST(m0_be__tx_engine_invariant(eng));
 	tx_engine_unlock(eng);
 }
@@ -534,13 +533,23 @@ static void tx_open_tail(struct m0_be_tx *tx)
 	tx_state_set(tx, M0_BTS_ACTIVE);
 }
 
+static enum m0_be_tx_state tx_state(const struct m0_be_tx *tx)
+{
+	return tx->t_sm.sm_state;
+}
+
 M0_INTERNAL void tx_state_set(struct m0_be_tx *tx, enum m0_be_tx_state state)
 {
 	M0_PRE(m0_be__tx_invariant(tx));
 	M0_PRE(tx_is_locked(tx));
+	M0_PRE(tx_state(tx) != state);
 
 	m0_sm_state_set(&tx->t_sm, state);
-
+	/*
+	 * XXX TODO: M0_PRE() that tx_engine is locked exclusively.
+	 * We need to introduce some kind of m0_rwlock_write_locked() for
+	 * this purpose.
+	 */
 	/* Link the transaction. */
 	tx_tlist_move(&tx_engine(tx)->te_txs[state], tx);
 
@@ -557,11 +566,6 @@ static void tx_fail(struct m0_be_tx *tx, int err)
 	M0_POST(m0_be__tx_invariant(tx));
 }
 
-static enum m0_be_tx_state tx_state(const struct m0_be_tx *tx)
-{
-	return tx->t_sm.sm_state;
-}
-
 static struct m0_be_tx_engine *tx_engine(const struct m0_be_tx *tx)
 {
 	return &tx->t_be->b_tx;
@@ -580,11 +584,10 @@ static void tx_engine_unlock(struct m0_be_tx_engine *eng)
 M0_INTERNAL bool
 m0_be__tx_engine_invariant(const struct m0_be_tx_engine *engine)
 {
-	/* struct m0_be_log	     *log  = &engine->te_log; */
 	struct m0_be_tx		     *prev = NULL;
 	const struct m0_be_tx_engine *te   = engine;
 
-	return true || ( /* XXX: passify invariant for a while */
+	return true || ( /* XXX RESTOREME */
 		m0_forall(i, M0_BTS_NR,
 			  m0_tl_forall(tx, t, &engine->te_txs[i],
 				       m0_be__tx_invariant(t) &&
@@ -604,7 +607,7 @@ M0_INTERNAL bool m0_be__tx_invariant(const struct m0_be_tx *tx)
 {
 	enum m0_be_tx_state state = tx_state(tx);
 
-	return true || ( /* XXX DELETEME */
+	return true || ( /* XXX RESTOREME */
 		state < M0_BTS_NR &&
 		tx_tlist_contains(&tx_engine(tx)->te_txs[state], tx) &&
 		(tx->t_lsn == 0) == (state < M0_BTS_GROUPED) &&
diff --git a/be/tx.h b/be/tx.h
index d74819d..0aa1db5 100644
--- a/be/tx.h
+++ b/be/tx.h
@@ -289,19 +289,21 @@ struct m0_be_tx_engine {
 	 * of these lists.
 	 */
 	struct m0_tl          te_txs[M0_BTS_NR];
-	/** Protects all fields of this struct. */
+	/**
+	 * Protects all fields of this struct.
+	 *
+	 * XXX FIXME: Current code never locks this field for reading, only
+	 * for writing (i.e., there are no m0_rwlock_read_lock() calls).
+	 */
 	struct m0_rwlock      te_lock;
 	/** Transactional log. */
 	struct m0_be_log      te_log;
-	/**
-	 * Transactional group. (Currently there is only one.)
-	 */
+	/** Transactional group. (Currently there is only one.) */
 	struct m0_be_tx_group te_group;
 
 	/*
 	 * Various interesting positions in the log. Probably not needed.
 	 */
-
 	struct m0_be_tx      *te_start;
 	struct m0_be_tx      *te_placed;
 	struct m0_be_tx      *te_logged;
diff --git a/be/tx_fom.c b/be/tx_fom.c
index 6cdf976..9f37b93 100644
--- a/be/tx_fom.c
+++ b/be/tx_fom.c
@@ -126,10 +126,12 @@ static int tx_fom_tick(struct m0_fom *fom)
 		break;
 
 	case FS_LOG_HEADER_LOGGED:
+		/* XXX FIXME: post AST */
 		tx_state_set(tx, M0_BTS_SUBMITTED);
 		break;
 
 	case FS_LOGGED:
+		/* XXX FIXME: post AST */
 		tx_state_set(tx, M0_BTS_LOGGED);
 		break;
 
@@ -154,12 +156,14 @@ static int tx_fom_tick(struct m0_fom *fom)
 		M0_ASSERT(m0_be_op_state(&fom_to_txm(fom)->tf_op) ==
 			  M0_BOS_SUCCESS);
 		m0_be_op_fini(&fom_to_txm(fom)->tf_op);
+		/* XXX FIXME: post AST */
 		tx_state_set(tx, M0_BTS_PLACED);
 		m0_be_tx_free(tx);  /* free region buffers */
 		m0_fom_phase_set(fom, FS_STABLE);
 		return M0_FSO_AGAIN;
 
 	case FS_STABLE:
+		/* XXX FIXME: post AST */
 		tx_state_set(tx, M0_BTS_STABLE);
 		gr_tlist_del(tx);
 		tx_tlist_del(tx);
diff --git a/be/tx_group.c b/be/tx_group.c
index 960df72..7c06090 100644
--- a/be/tx_group.c
+++ b/be/tx_group.c
@@ -51,7 +51,7 @@ M0_INTERNAL void tx_group_fini(struct m0_be_tx_group *gr)
 }
 
 M0_INTERNAL void tx_group_add(struct m0_be_tx_engine *eng,
-			 struct m0_be_tx_group *gr, struct m0_be_tx *tx)
+			      struct m0_be_tx_group *gr, struct m0_be_tx *tx)
 {
 
 	tx->t_group  = gr;
@@ -120,10 +120,14 @@ tx_group_close(struct m0_be_tx_engine *eng, struct m0_be_tx_group *gr)
 	 * When all group's transactions reach PLACED state, the group is
 	 * finalised.
 	 */
-	gr->tg_opened = false; /* XXX FIXME */
+
+	/* XXX TODO ... */
+
+	gr->tg_opened = false;
 }
 
 /** @} end of be group */
+
 /*
  *  Local variables:
  *  c-indentation-style: "K&R"
-- 
1.8.3.2

