From e0ba32a0cd679924b972fe0c6af138a7884ba2ec Mon Sep 17 00:00:00 2001
From: "Valery V. Vorotyntsev" <valery_vorotyntsev@xyratex.com>
Date: Tue, 25 Jun 2013 16:39:05 +0300
Subject: [PATCH 226/290] be (tx): add tx_is_locked() calls

Add "tx locality is locked" predicates to m0_be_tx_{prep,open,capture,close}().

Reviewed-by: Nikita Danilov
Reviewed-on: http://reviewboard.clusterstor.com/r/1465/
---
 be/tx.c | 33 ++++++++++++++++++++++++++-------
 1 file changed, 26 insertions(+), 7 deletions(-)

diff --git a/be/tx.c b/be/tx.c
index 5d1a14e..3977af6 100644
--- a/be/tx.c
+++ b/be/tx.c
@@ -147,6 +147,7 @@ static void        tx_engine_got_closed(struct m0_be_tx_engine *eng,
 					struct m0_be_tx *tx);
 static void        tx_engine_lock      (struct m0_be_tx_engine *eng);
 static void        tx_engine_unlock    (struct m0_be_tx_engine *eng);
+static bool        tx_is_locked        (const struct m0_be_tx *tx);
 
 M0_INTERNAL void m0_be_tx_engine_init(struct m0_be_tx_engine *engine)
 {
@@ -215,6 +216,7 @@ m0_be_tx_prep(struct m0_be_tx *tx, const struct m0_be_tx_credit *credit)
 {
 	M0_PRE(m0_be__tx_invariant(tx));
 	M0_PRE(tx_state(tx) == M0_BTS_PREPARE);
+	M0_PRE(tx_is_locked(tx));
 
 	m0_be_tx_credit_add(&tx->t_prepared, credit);
 	tx->t_payload_size = tx->t_prepared.tc_reg_size;
@@ -230,6 +232,7 @@ M0_INTERNAL void m0_be_tx_open(struct m0_be_tx *tx)
 
 	M0_PRE(m0_be__tx_invariant(tx));
 	M0_PRE(tx_state(tx) == M0_BTS_PREPARE);
+	M0_PRE(tx_is_locked(tx));
 
 	if (log_size <= min_check(eng->te_log.lg_size,
 				  eng->te_log.lg_gr_size_max)) {
@@ -292,6 +295,7 @@ m0_be_tx_capture(struct m0_be_tx *tx, const struct m0_be_reg *reg)
 
 	M0_PRE(m0_be__tx_invariant(tx));
 	M0_PRE(tx_state(tx) == M0_BTS_ACTIVE);
+	M0_PRE(tx_is_locked(tx));
 
 	new->rd_tx  = tx;
 	new->rd_idx = idx;
@@ -412,11 +416,13 @@ m0_be_tx_capture(struct m0_be_tx *tx, const struct m0_be_reg *reg)
 M0_INTERNAL void m0_be_tx_close(struct m0_be_tx *tx)
 {
 	struct m0_be_tx_engine *eng = tx_engine(tx);
-	struct m0_be_tx_credit  t_used;
+	struct m0_be_tx_credit  t_used; /* XXX See [1] below. */
 	m0_bcount_t             used;
 	m0_bcount_t             prepared;
 
 	M0_PRE(tx_state(tx) == M0_BTS_ACTIVE);
+	M0_PRE(tx_is_locked(tx));
+
 	tx_engine_lock(eng);
 	M0_PRE(m0_be__tx_engine_invariant(eng));
 
@@ -426,8 +432,13 @@ M0_INTERNAL void m0_be_tx_close(struct m0_be_tx *tx)
 	tx_engine_got_closed(eng, tx);
 
 	m0_be_reg_area_used(&tx->t_reg_area, &t_used);
-	prepared  = tx_prepared_log_size(tx);
-	used      = tx_log_size(tx, &t_used, tx->t_leader);
+	prepared = tx_prepared_log_size(tx);
+	/*
+	 * [1] XXX TODO: Ask Maxim on t_used usage: why don't we use
+	 * tx->t_used value as we used to use. (Ask myself to stop abusing
+	 * word "use".)  --vvv
+	 */
+	used = tx_log_size(tx, &t_used, tx->t_leader);
 
 	M0_ASSERT(used <= prepared);
 	M0_ASSERT(eng->te_reserved + used >= prepared);
@@ -495,10 +506,9 @@ static void tx_engine_got_closed(struct m0_be_tx_engine *eng,
 M0_INTERNAL void tx_state_set(struct m0_be_tx *tx, enum m0_be_tx_state state)
 {
 	M0_PRE(m0_be__tx_invariant(tx));
+	M0_PRE(tx_is_locked(tx));
 
-	m0_sm_group_lock(tx->t_sm.sm_grp);
 	m0_sm_state_set(&tx->t_sm, state);
-	m0_sm_group_unlock(tx->t_sm.sm_grp);
 
 	tx_link(tx);
 	M0_POST(m0_be__tx_invariant(tx));
@@ -592,8 +602,17 @@ static void tx_engine_unlock(struct m0_be_tx_engine *eng)
 	m0_rwlock_write_unlock(&eng->te_lock);
 }
 
-M0_INTERNAL int m0_be_tx_timedwait(struct m0_be_tx *tx, int state,
-				   m0_time_t timeout)
+/**
+ * Returns true iff the locality, given transaction is associated with,
+ * is locked.
+ */
+static bool tx_is_locked(const struct m0_be_tx *tx)
+{
+	return m0_mutex_is_locked(&tx->t_sm.sm_grp->s_lock);
+}
+
+M0_INTERNAL int
+m0_be_tx_timedwait(struct m0_be_tx *tx, int state, m0_time_t timeout)
 {
         m0_sm_group_lock(tx->t_sm.sm_grp);
         m0_sm_timedwait(&tx->t_sm, state, timeout);
-- 
1.8.3.2

