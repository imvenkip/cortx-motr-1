From 98baa0e18da5bc6ecbe7d925f1d5bca400798b84 Mon Sep 17 00:00:00 2001
From: Anatoliy Bilenko <anatoliy_bilenko@xyratex.com>
Date: Fri, 31 May 2013 12:15:45 +0300
Subject: [PATCH 078/290] be: btree minor cleanup.

---
 be/btree.c |  35 +++++++++++++++-
 be/btree.h | 134 +++++++++++++++++++++++++++++++++++++++----------------------
 be/seg.h   |   1 +
 3 files changed, 122 insertions(+), 48 deletions(-)

diff --git a/be/btree.c b/be/btree.c
index 472ce53..73e740d 100644
--- a/be/btree.c
+++ b/be/btree.c
@@ -14,7 +14,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Valery V. Vorotyntsev <valery_vorotyntsev@xyratex.com>
+ * Original author: Anatoliy Bilenko <Anatoliy_Bilenko@xyratex.com>
  * Original creation date: 29-May-2013
  */
 
@@ -25,6 +25,39 @@
  */
 
 #include "be/btree.h"
+#include "be/seg.h"
+
+M0_INTERNAL void m0_be_btree_init(struct m0_be_btree *tree,
+				  struct m0_be_seg   *seg,
+				  struct m0_be_bnode *root)
+{
+	M0_PRE(ergo(root != NULL, seg->bs_addr <= (void*) root &&
+		    (void*) root < seg->bs_addr + seg->bs_size));
+
+	m0_rwlock_init(&tree->bb_lock);
+	tree->bb_root = root;
+}
+
+M0_INTERNAL void m0_be_btree_fini(struct m0_be_btree *tree)
+{
+	m0_rwlock_fini(&tree->bb_lock);
+}
+
+M0_INTERNAL void m0_be_btree_create(struct m0_be_btree *tree,
+				    struct m0_be_tx *tx,
+				    struct m0_be_op *op)
+{
+
+}
+
+M0_INTERNAL void m0_be_btree_destroy(struct m0_be_btree *tree,
+				     struct m0_be_tx *tx,
+				     struct m0_be_op *op)
+{
+
+}
+
+
 
 /** @} end of be group */
 
diff --git a/be/btree.h b/be/btree.h
index 09cda3b..036f317 100644
--- a/be/btree.h
+++ b/be/btree.h
@@ -14,7 +14,7 @@
  * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
  * http://www.xyratex.com/contact
  *
- * Original author: Valery V. Vorotyntsev <valery_vorotyntsev@xyratex.com>
+ * Original author: Anatoliy Bilenko <Anatoliy_Bilenko@xyratex.com>
  * Original creation date: 29-May-2013
  */
 
@@ -42,8 +42,21 @@ struct m0_be_btree {
 	struct m0_be_bnode *bb_root;
 };
 
+enum m0_be_btree_op {
+	M0_BBO_CREATE,
+	M0_BBO_DESTROY,
+	M0_BBO_INSERT,
+	M0_BBO_DELETE,
+	M0_BBO_UPDATE
+};
+
+
+/* ------------------------------------------------------------------
+ * Btree construction interface
+ * ------------------------------------------------------------------ */
+
 M0_INTERNAL void m0_be_btree_init(struct m0_be_btree *tree,
-				  struct m0_be_seg *seg,
+				  struct m0_be_seg   *seg,
 				  struct m0_be_bnode *root);
 
 M0_INTERNAL void m0_be_btree_fini(struct m0_be_btree *tree);
@@ -61,27 +74,10 @@ M0_INTERNAL void m0_be_btree_destroy(struct m0_be_btree *tree,
 				     struct m0_be_tx *tx,
 				     struct m0_be_op *op);
 
-struct m0_be_btree_cursor {
-	struct m0_be_btree *bc_tree;
-	struct m0_be_op     bc_op;
-};
-
-M0_INTERNAL void m0_be_btree_cursor_init(struct m0_be_btree_cursor *cursor,
-					 struct m0_be_btree *tree);
-
-M0_INTERNAL void m0_be_btree_cursor_fini(struct m0_be_btree_cursor *cursor);
-
-M0_INTERNAL void m0_be_btree_cursor_get(struct m0_be_btree_cursor *cursor,
-					const struct m0_buf *key);
-
-M0_INTERNAL void m0_be_btree_cursor_put(struct m0_be_btree_cursor *cursor);
-
-M0_INTERNAL void m0_be_btree_cursor_next(struct m0_be_btree_cursor *cursor);
-
-struct m0_be_btree_anchor {
-	struct m0_buf ba_buf;
-	bool          ba_write; /**< Is write lock being held? */
-};
+
+/* ------------------------------------------------------------------
+ * Btree manipulation interface
+ * ------------------------------------------------------------------ */
 
 M0_INTERNAL void m0_be_btree_maxkey(const struct m0_be_btree *tree,
 				    struct m0_be_op *op,
@@ -92,19 +88,6 @@ M0_INTERNAL void m0_be_btree_lookup(struct m0_be_btree *tree,
 				    const struct m0_buf *key,
 				    struct m0_buf *dest_buf);
 
-M0_INTERNAL void m0_be_btree_lookup_inplace(struct m0_be_btree *tree,
-					    struct m0_be_op *op,
-					    const struct m0_buf *key,
-					    struct m0_be_btree_anchor *anchor);
-
-enum m0_be_btree_op {
-	M0_BBO_CREATE,
-	M0_BBO_DESTROY,
-	M0_BBO_INSERT,
-	M0_BBO_DELETE,
-	M0_BBO_UPDATE
-};
-
 M0_INTERNAL void m0_be_btree_credit(const struct m0_be_btree *tree,
 				    enum m0_be_btree_op optype,
 				    m0_bcount_t nr,
@@ -116,33 +99,90 @@ M0_INTERNAL void m0_be_btree_insert(struct m0_be_btree *tree,
 				    const struct m0_buf *key,
 				    const struct m0_buf *value);
 
-M0_INTERNAL void m0_be_btree_insert_inplace(struct m0_be_btree *tree,
-					    struct m0_be_tx *tx,
-					    struct m0_be_op *op,
-					    const struct m0_buf *key,
-					    struct m0_be_btree_anchor *anchor);
-
 M0_INTERNAL void m0_be_btree_update(struct m0_be_btree *tree,
 				    struct m0_be_tx *tx,
 				    struct m0_be_op *op,
 				    const struct m0_buf *key,
 				    const struct m0_buf *value);
 
-M0_INTERNAL void m0_be_btree_update_inplace(struct m0_be_btree *tree,
+M0_INTERNAL void m0_be_btree_delete(struct m0_be_btree *tree,
+				    struct m0_be_tx *tx,
+				    struct m0_be_op *op,
+				    const struct m0_buf *key);
+
+
+/* ------------------------------------------------------------------
+ * Btree inplace manipulation interface
+ * ------------------------------------------------------------------ */
+
+/**
+ * Btree anchor, used to perform btree inplace operations in which neither keys
+ * nor values are not being copied.
+ *
+ * In cases, when data in m0_be_btree_anchor::ba_value is updated,
+ * m0_be_btree_release() has to capture the region data lies in.
+ */
+struct m0_be_btree_anchor {
+	 /**
+	  * A value, accessed through m0_be_btree_lookup_inplace(),
+	  * m0_be_btree_insert_inplace(), m0_be_btree_update_inplace()
+	  */
+	struct m0_buf ba_value;
+
+	/** Is write lock being held? */
+	bool          ba_write;
+};
+
+M0_INTERNAL void m0_be_btree_lookup_inplace(struct m0_be_btree *tree,
+					    struct m0_be_op *op,
+					    const struct m0_buf *key,
+					    struct m0_be_btree_anchor *anchor);
+
+M0_INTERNAL void m0_be_btree_insert_inplace(struct m0_be_btree *tree,
 					    struct m0_be_tx *tx,
 					    struct m0_be_op *op,
 					    const struct m0_buf *key,
 					    struct m0_be_btree_anchor *anchor);
 
-M0_INTERNAL void m0_be_btree_delete(struct m0_be_btree *tree,
-				    struct m0_be_tx *tx,
-				    struct m0_be_op *op,
-				    const struct m0_buf *key);
+M0_INTERNAL void m0_be_btree_update_inplace(struct m0_be_btree *tree,
+					    struct m0_be_tx *tx,
+					    struct m0_be_op *op,
+					    const struct m0_buf *key,
+					    struct m0_be_btree_anchor *anchor);
 
 /** Completes m0_be_btree_*_inplace() operation. */
 M0_INTERNAL void m0_be_btree_release(struct m0_be_btree *tree,
 				     const struct m0_be_btree_anchor *anchor);
 
+
+/* ------------------------------------------------------------------
+ * Btree cursor interface
+ * ------------------------------------------------------------------ */
+
+/**
+ * Btree cursor.
+ *
+ * Cursor can be positioned with m0_be_btree_cursor_get() and moved with
+ * m0_be_btree_cursor_next(), m0_be_btree_cursor_prev().
+ */
+struct m0_be_btree_cursor {
+	struct m0_be_btree *bc_tree;
+	struct m0_be_op     bc_op;
+};
+
+M0_INTERNAL void m0_be_btree_cursor_init(struct m0_be_btree_cursor *cursor,
+					 struct m0_be_btree *tree);
+
+M0_INTERNAL void m0_be_btree_cursor_fini(struct m0_be_btree_cursor *cursor);
+
+M0_INTERNAL void m0_be_btree_cursor_get(struct m0_be_btree_cursor *cursor,
+					const struct m0_buf *key);
+M0_INTERNAL void m0_be_btree_cursor_next(struct m0_be_btree_cursor *cursor);
+M0_INTERNAL void m0_be_btree_cursor_prev(struct m0_be_btree_cursor *cursor);
+
+M0_INTERNAL void m0_be_btree_cursor_put(struct m0_be_btree_cursor *cursor);
+
+
 /** @} end of be group */
 #endif /* __MERO_BE_BTREE_H__ */
 
diff --git a/be/seg.h b/be/seg.h
index a422bc0..f88bc68 100644
--- a/be/seg.h
+++ b/be/seg.h
@@ -49,6 +49,7 @@ struct m0_be_seg {
 	struct m0_be          *bs_be;
 	int                    bs_state;
 };
+
 M0_INTERNAL bool m0_be_seg__invariant(const struct m0_be_seg *seg);
 
 M0_INTERNAL void m0_be_seg_init(struct m0_be_seg *seg,
-- 
1.8.3.2

