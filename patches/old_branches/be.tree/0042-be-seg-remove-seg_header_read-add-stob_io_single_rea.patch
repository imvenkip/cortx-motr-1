From d786552cc2ba979582f9705ce0c6c7c662284969 Mon Sep 17 00:00:00 2001
From: Alexander Gattin <alexander_gattin@xyratex.com>
Date: Wed, 29 May 2013 16:30:24 +0300
Subject: [PATCH 042/290] be/seg: remove seg_header_read(), add
 stob_io_single_read()

---
 be/seg.c | 124 ++++++++++++++++++++++++++++++++-------------------------------
 1 file changed, 63 insertions(+), 61 deletions(-)

diff --git a/be/seg.c b/be/seg.c
index 4c42686..b46e1e1 100644
--- a/be/seg.c
+++ b/be/seg.c
@@ -18,6 +18,7 @@
  * Original creation date: 29-May-2013
  */
 
+#include <sys/mman.h>    /* mmap */
 #include "be/seg.h"
 #include "lib/assert.h"
 #include "lib/memory.h"  /* m0_alloc_aligned */
@@ -34,10 +35,10 @@
 #define BE_SEG_DEFAULT_ADDR   ((void *)0x0708000000000000)
 #define BE_SEG_DEFAULT_OFFSET (0ULL)
 
-/* "on-disk" header for segment, stored in STOB at zero offset */
+/* "On-disk" header for segment, stored in STOB at zero offset */
 struct be_seg_hdr {
-	void       *bh_addr;
-	m0_bcount_t bh_size;
+	void       *bh_addr;  /* segment address in RAM */
+	m0_bcount_t bh_size;  /* segment size */
 };
 
 static void seg_io_prepare(struct m0_be_seg *seg, struct m0_stob_io *io)
@@ -69,33 +70,6 @@ static void seg_header_prepare(struct m0_be_seg *seg, struct m0_stob_io *io,
 	seg_io_prepare(seg, io);
 }
 
-static int seg_header_read(struct m0_be_seg *seg)
-{
-	struct be_seg_hdr *seg_hdr = (struct be_seg_hdr *)seg->bs_addr;
-	struct m0_stob_io  io;
-	struct m0_clink    clink;
-	int                rc;
-
-	m0_stob_io_init(&io);
-	io.si_opcode = SIO_READ;
-	seg_header_prepare(seg, &io, 0);
-
-	m0_clink_init(&clink, NULL);
-	m0_clink_add(&io.si_wait, &clink);
-
-	rc = m0_stob_io_launch(&io, seg->bs_stob, NULL, NULL);
-	M0_ASSERT(rc != 0); /* XXX FIXME */
-
-	m0_chan_wait(&clink);
-	m0_clink_del(&clink);
-	m0_clink_fini(&clink);
-	m0_stob_io_fini(&io);
-
-	seg->bs_size = seg_hdr->bh_size;
-
-	return io.si_rc;
-}
-
 static int seg_header_write(struct m0_be_seg *seg, m0_bcount_t size)
 {
 	struct m0_stob_io io;
@@ -159,63 +133,91 @@ bool m0_be__reg_invariant(const struct m0_be_reg *reg)
 		reg->br_addr != NULL;
 }
 
-int m0_be_seg_open(struct m0_be_seg *seg)
+static int stob_io_single_read(void *buf, m0_bcount_t bufsz,
+			       struct m0_stob *stob,
+			       m0_bcount_t offs, uint32_t pgshift)
 {
+	size_t             pgsz;
+	m0_bcount_t        rdcnt[1];    /* sectors counts */
+	m0_bcount_t        rdoffs[1];   /* offsets */
+	void              *rdbufpk[1]; /* "packed" addresses */
 	struct m0_stob_io  io;
 	struct m0_clink    clink;
 	int                rc;
-	uint32_t           st_block_shift;
-	size_t             st_block_size;
-	m0_bcount_t        rdcnt[1];    /* sectors counts */
-	m0_bcount_t        rdoffs[1];   /* offsets */
-	struct be_seg_hdr *hdrbuf[1];   /* read buffers */
-	void              *rdbufpk[1];  /* "packed" addresses */
-	void              *seg_addr0;
-	m0_bcount_t        seg_size;
 
-	/* Allocate buffer for STOB io. */
-	st_block_shift = seg->bs_stob->so_op->sop_block_shift(seg->bs_stob);
-	st_block_size = 1 << st_block_shift;
-	rdcnt[0] = (sizeof(struct be_seg_hdr) + st_block_size - 1) /
-		st_block_size;
-	hdrbuf[0] = m0_alloc_aligned(rdcnt[0] * st_block_size,
-				     st_block_shift);
-	if (hdrbuf[0] == NULL)
-		return -ENOMEM;
+       	pgsz = 1 << pgshift;
 
 	/* Set up io struct for reading. */
 	m0_stob_io_init(&io);
-	rdbufpk[0]                = m0_stob_addr_pack(hdrbuf[0],
-						      st_block_shift);
+	rdcnt[0]                  = (bufsz + pgsz - 1) / pgsz;
+	rdbufpk[0]                = m0_stob_addr_pack(buf, pgshift);
 	io.si_flags               = 0;
 	io.si_opcode              = SIO_READ;
 	io.si_user.ov_buf         = rdbufpk;
 	io.si_user.ov_vec.v_nr    = 1;
-	rdoffs[0]                 = 0;  /* header offset in STOB */
 	io.si_user.ov_vec.v_count = rdcnt;
+	rdoffs[0]                 = 0;  /* header offset in STOB */
+	io.si_stob.iv_index       = rdoffs;
 	io.si_stob.iv_vec.v_nr    = 1;
 	io.si_stob.iv_vec.v_count = rdcnt;
-	io.si_stob.iv_index       = rdoffs;
 
 	m0_clink_init(&clink, NULL);
 	m0_clink_add_lock(&io.si_wait, &clink);
-	rc = m0_stob_io_launch(&io, seg->bs_stob, NULL, NULL);
+	rc = m0_stob_io_launch(&io, stob, NULL, NULL);
 	if (rc == 0) {
 		m0_chan_wait(&clink);
 		rc = io.si_rc;
 	}
-	if (rc == 0) {
-		seg_addr0 = hdrbuf[0]->bh_addr;
-		seg_size  = hdrbuf[0]->bh_size;
-	}
-	m0_free(hdrbuf[0]);
 	m0_clink_del_lock(&clink);
 	m0_clink_fini(&clink);
 	m0_stob_io_fini(&io);
-	if (rc != 0) return rc;
 
-	/* TODO: mmap an area at bh_addr of bh_size */
-	return 0;
+	return rc;
+}
+
+int m0_be_seg_open(struct m0_be_seg *seg)
+{
+	int                rc;
+	uint32_t           st_block_shift;
+	size_t             st_block_size;
+	struct be_seg_hdr *hdrbuf;      /* seg hdr buffer */
+	m0_bcount_t        hdrblocks;   /* number of sectors */
+	void              *seg_addr0;
+	void              *p;
+	m0_bcount_t        seg_size;
+
+	/* Allocate buffer for segment header. */
+	st_block_shift = seg->bs_stob->so_op->sop_block_shift(seg->bs_stob);
+	st_block_size = 1 << st_block_shift;
+	hdrblocks = (sizeof(struct be_seg_hdr) + st_block_size - 1) /
+		st_block_size;
+	hdrbuf = m0_alloc_aligned(hdrblocks * st_block_size, st_block_shift);
+	if (hdrbuf == NULL)
+		return -ENOMEM;
+
+	/* Read segment header from storage. */
+	rc = stob_io_single_read(hdrbuf, sizeof(struct be_seg_hdr),
+				 seg->bs_stob, 0, st_block_shift);
+	if (rc == 0) {
+		seg_addr0 = hdrbuf->bh_addr;
+		seg_size  = hdrbuf->bh_size;
+		M0_ASSERT(seg_addr0 != NULL);
+		M0_ASSERT(m0_addr_is_aligned(seg_addr0, st_block_shift));
+	}
+	m0_free(hdrbuf);
+	if (rc != 0)
+		return rc;
+
+	/* mmap an area at bh_addr of bh_size. */
+	p = mmap(seg_addr0, seg_size, PROT_READ|PROT_WRITE,
+		 MAP_ANONYMOUS, -1, 0);
+	if (p == MAP_FAILED)
+		return -errno;
+
+	/* Read whole segment from storage. */
+	rc = stob_io_single_read(seg_addr0, seg_size, seg->bs_stob,
+				 0, st_block_shift);
+	return rc;
 }
 
 void m0_be_seg_close(struct m0_be_seg *seg)
-- 
1.8.3.2

