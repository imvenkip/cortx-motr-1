From 2c56f729461038c80a4cb37eac271473ecc70d92 Mon Sep 17 00:00:00 2001
From: Anatoliy Bilenko <anatoliy_bilenko@xyratex.com>
Date: Fri, 21 Jun 2013 10:10:27 +0300
Subject: [PATCH 197/290] be: m0_be_ut_seg_write() cleanup

---
 be/be.c     | 28 +++++++++++++++++++---------
 be/be.h     |  4 +++-
 be/ut/seg.c | 35 ++++++++++++++++-------------------
 mero/init.c |  1 +
 4 files changed, 39 insertions(+), 29 deletions(-)

diff --git a/be/be.c b/be/be.c
index 3a2bf17..d03d2c7 100644
--- a/be/be.c
+++ b/be/be.c
@@ -38,6 +38,7 @@
 
 /* XXX: this will be deleted from here! */
 struct m0_be m0_be_instance;
+static struct m0_sm_group be_sm_grp;
 
 static const struct m0_be_op *csm2op(const struct m0_sm *sm)
 {
@@ -100,24 +101,22 @@ M0_INTERNAL enum m0_be_op_state m0_be_op_state(struct m0_be_op *op)
 
 M0_INTERNAL void m0_be_op_init(struct m0_be_op *op)
 {
-	m0_sm_group_init(&op->bo_sm_grp);
-	m0_sm_init(&op->bo_sm, &op_states_conf, M0_BOS_INIT, &op->bo_sm_grp);
+	m0_sm_init(&op->bo_sm, &op_states_conf, M0_BOS_INIT, &be_sm_grp);
 }
 
 M0_INTERNAL void m0_be_op_fini(struct m0_be_op *op)
 {
-	m0_sm_group_lock(&op->bo_sm_grp);
+	m0_sm_group_lock(op->bo_sm.sm_grp);
 	m0_sm_fini(&op->bo_sm);
-	m0_sm_group_unlock(&op->bo_sm_grp);
-	m0_sm_group_fini(&op->bo_sm_grp);
+	m0_sm_group_unlock(op->bo_sm.sm_grp);
 }
 
 M0_INTERNAL void m0_be_op_state_set(struct m0_be_op *op,
 				    enum m0_be_op_state state)
 {
-	m0_sm_group_lock(&op->bo_sm_grp);
+	m0_sm_group_lock(op->bo_sm.sm_grp);
 	m0_sm_state_set(&op->bo_sm, state);
-	m0_sm_group_unlock(&op->bo_sm_grp);
+	m0_sm_group_unlock(op->bo_sm.sm_grp);
 }
 
 M0_INTERNAL int m0_be_op_tick_ret(struct m0_be_op *op, struct m0_fom *fom,
@@ -126,9 +125,9 @@ M0_INTERNAL int m0_be_op_tick_ret(struct m0_be_op *op, struct m0_fom *fom,
 	if (M0_IN(op->bo_sm.sm_state, (M0_BOS_SUCCESS, M0_BOS_FAILURE)))
 		return M0_FSO_AGAIN;
 
-	m0_sm_group_lock(&op->bo_sm_grp);
+	m0_sm_group_lock(op->bo_sm.sm_grp);
 	m0_fom_wait_on(fom, &op->bo_sm.sm_chan, &fom->fo_cb);
-	m0_sm_group_unlock(&op->bo_sm_grp);
+	m0_sm_group_unlock(op->bo_sm.sm_grp);
 
 	m0_fom_phase_set(fom, next_state);
 	return M0_FSO_WAIT;
@@ -144,6 +143,17 @@ M0_INTERNAL int m0_be_op_wait(struct m0_be_op *op)
         return op->bo_sm.sm_rc;
 }
 
+M0_INTERNAL int  m0_be_init(void)
+{
+	m0_sm_group_init(&be_sm_grp);
+	return 0;
+}
+
+M0_INTERNAL void m0_be_fini(void)
+{
+	m0_sm_group_fini(&be_sm_grp);
+}
+
 #undef M0_TRACE_SUBSYSTEM
 /** @} end of be group */
 
diff --git a/be/be.h b/be/be.h
index ac15291..881929b 100644
--- a/be/be.h
+++ b/be/be.h
@@ -66,7 +66,6 @@ enum m0_be_op_type {
 struct m0_be_op {
 	struct m0_sm       bo_sm;
 	struct m0_fom     *bo_fom;
-	struct m0_sm_group bo_sm_grp;	/** @todo XXX TODO remove it! */
 
 	enum m0_be_op_type bo_utype; /* bo_u type */
 	struct m0_be_op   *bo_parent_op;
@@ -122,6 +121,9 @@ M0_INTERNAL void m0_be_op_fini(struct m0_be_op *op);
 M0_INTERNAL void m0_be_op_state_set(struct m0_be_op *op,
 				    enum m0_be_op_state state);
 
+M0_INTERNAL int  m0_be_init(void);
+M0_INTERNAL void m0_be_fini(void);
+
 /** @} end of be group */
 #endif /* __MERO_BE_BE_H__ */
 
diff --git a/be/ut/seg.c b/be/ut/seg.c
index f096aea..194764d 100644
--- a/be/ut/seg.c
+++ b/be/ut/seg.c
@@ -24,6 +24,13 @@
 #include "lib/misc.h"		/* M0_BITS */
 
 static struct m0_be_ut_h be_ut_seg_h;
+static m0_bindex_t off = 256; /* slightly afther the segment header */
+static char buf[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
+static struct m0_be_reg_d area[] = {
+	{ .rd_reg = { .br_size =  8 }, .rd_buf = &buf[ 0] },
+	{ .rd_reg = { .br_size =  8 }, .rd_buf = &buf[ 8] },
+	{ .rd_reg = { .br_size = 16 }, .rd_buf = &buf[16] },
+};
 
 M0_INTERNAL void m0_be_ut_seg_init_fini(void)
 {
@@ -35,20 +42,14 @@ M0_INTERNAL void m0_be_ut_seg_init_fini(void)
 
 static void seg_write(struct m0_be_seg *seg)
 {
-	char buf[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
-	m0_bindex_t off = 256; /* slightly afther the segment header */
-	struct m0_be_reg_d area[] = {
-		{ .rd_reg = { .br_size = 8,  .br_addr = seg->bs_addr+off      },
-		  .rd_buf = &buf[0]  },
-		{ .rd_reg = { .br_size = 8,  .br_addr = seg->bs_addr+off +  8 },
-		  .rd_buf = &buf[8]  },
-		{ .rd_reg = { .br_size = 16, .br_addr = seg->bs_addr+off + 16 },
-		  .rd_buf = &buf[16] },
-	};
+	int i;
 	struct m0_be_op op;
 
 	m0_be_op_init(&op);
 
+	for (i = 0; i < ARRAY_SIZE(area); ++i)
+		area[i].rd_reg.br_addr = seg->bs_addr + off + i*8;
+
 	m0_be_seg_write_simple(seg, &op, area, ARRAY_SIZE(area));
 	m0_be_op_wait(&op);
 	M0_UT_ASSERT(m0_be_op_state(&op) == M0_BOS_SUCCESS);
@@ -72,6 +73,7 @@ M0_INTERNAL void m0_be_ut_seg_open_close(void)
 M0_INTERNAL void m0_be_ut_seg_write(void)
 {
 	int rc;
+	int i;
 
 	m0_be_ut_seg_create(&be_ut_seg_h);
 	seg_write(&be_ut_seg_h.buh_seg);
@@ -84,15 +86,10 @@ M0_INTERNAL void m0_be_ut_seg_write(void)
 	rc = m0_be_seg_open(&be_ut_seg_h.buh_seg);
 	M0_ASSERT(rc == 0);
 
-/* XXX */
-/* check here that write completed successfuly */
-/* (gdb) x/32c seg->bs_addr + 256 */
-
-/* 0x400000000100: 65 'A' 66 'B' 67 'C' 68 'D' 69 'E' 70 'F' 71 'G' 72 'H' */
-/* 0x400000000108: 73 'I' 74 'J' 75 'K' 76 'L' 77 'M' 78 'N' 79 'O' 80 'P' */
-/* 0x400000000110: 81 'Q' 82 'R' 83 'S' 84 'T' 85 'U' 86 'V' 87 'W' 88 'X' */
-/* 0x400000000118: 89 'Y' 90 'Z' 97 'a' 98 'b' 99 'c' 100 'd' 101 'e' 102 'f' */
-
+	for (i = 0; i < ARRAY_SIZE(area); ++i)
+		M0_UT_ASSERT(memcmp(area[i].rd_buf,
+				    area[i].rd_reg.br_addr,
+				    area[i].rd_reg.br_size) == 0);
 
 	m0_be_ut_seg_close_destroy(&be_ut_seg_h);
 }
diff --git a/mero/init.c b/mero/init.c
index 68d5eac..f66ec04 100644
--- a/mero/init.c
+++ b/mero/init.c
@@ -144,6 +144,7 @@ struct init_fini_call subsystem[] = {
 #ifdef __KERNEL__
 	{ &m0t1fs_init,         &m0t1fs_fini,         "m0t1fs" },
 #else
+	{ &m0_be_init,          &m0_be_fini,           "be" },
 	{ &m0_be_txs_register,  &m0_be_txs_unregister, "be-tx-service" },
 	{ &m0_confd_register,   &m0_confd_unregister,  "confd" },
 	{ &m0_ios_register,     &m0_ios_unregister,    "ioservice" },
-- 
1.8.3.2

