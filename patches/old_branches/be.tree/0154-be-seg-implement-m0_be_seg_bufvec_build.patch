From 72bd146ff3073258f8e78a028053e1a937d3e6b0 Mon Sep 17 00:00:00 2001
From: Alexander Gattin <alexander_gattin@xyratex.com>
Date: Fri, 14 Jun 2013 16:42:38 +0300
Subject: [PATCH 154/290] be/seg: implement m0_be_seg_bufvec_build().

* add heper function be_seg_blkno(),
* move m0_be_reg_d and m0_be_regdtree_node structs' declarations to
  tx_internal.h,
* implement m0_be_seg_bufvec_build().
---
 be/seg.c         | 83 ++++++++++++++++++++++++++++++++++++++++++++++++++++----
 be/seg.h         |  2 +-
 be/tx.c          | 21 ++++----------
 be/tx_internal.h | 61 +++++++++++++++++++++++++++++++++++++++++
 4 files changed, 145 insertions(+), 22 deletions(-)
 create mode 100644 be/tx_internal.h

diff --git a/be/seg.c b/be/seg.c
index 6fbec6e..98c86d2 100644
--- a/be/seg.c
+++ b/be/seg.c
@@ -22,14 +22,16 @@
 #include "be/seg.h"
 
 #include "lib/assert.h"
-#include "lib/memory.h"  /* m0_alloc_aligned */
-#include "lib/misc.h"    /* M0_IN */
+#include "lib/memory.h"      /* m0_alloc_aligned */
+#include "lib/misc.h"        /* M0_IN */
 #include "lib/errno.h"
 #include "stob/stob.h"
 
 #include "be/seg_internal.h"
+#include "be/tx_internal.h"  /* struct m0_be_regdtree_node */
 
-#include <sys/mman.h>    /* mmap */
+#include <search.h>          /* twalk */
+#include <sys/mman.h>        /* mmap */
 
 /**
  * @addtogroup be
@@ -349,6 +351,77 @@ static inline m0_bcount_t be_seg_pgno(const struct m0_be_seg *seg, void *addr)
 	return (addr - seg->bs_addr) >> seg->bs_pgshift;
 }
 
+static inline m0_bcount_t be_seg_blkno(const struct m0_be_seg *seg, void *addr)
+{
+	return (addr - seg->bs_addr) >> seg->bs_bshift;
+}
+
+M0_INTERNAL int m0_be_seg_bufvec_build(struct m0_be_seg *seg,
+				       void *regd_tree,
+				       struct m0_indexvec *iv,
+				       struct m0_bufvec *bv)
+{
+	m0_bcount_t reg_nr;
+	m0_bcount_t i;
+
+	M0_PRE(m0_be__seg_invariant(seg));
+	M0_PRE(iv != NULL && bv != NULL);
+
+	/* Count number of reg_d records in the tree. */
+	void reg_cnt(const void *p, const VISIT which, const int depth)
+	{
+		if (which == postorder || which == leaf)
+			reg_nr++;
+	}
+	reg_nr = 0;
+	twalk(regd_tree, &reg_cnt);
+
+	/* Allocate buf/index and count arrays in the provided
+	 * bufvec and indexvec stuctures. */
+	bv->ov_vec.v_nr    = reg_nr;
+	bv->ov_vec.v_count = M0_ALLOC_ARR(bv->ov_vec.v_count, reg_nr);
+	if (bv->ov_vec.v_count == NULL)
+		return -ENOMEM;
+	bv->ov_buf         = M0_ALLOC_ARR(bv->ov_buf, reg_nr);
+	if (bv->ov_buf == NULL) {
+		m0_free(bv->ov_vec.v_count);
+		return -ENOMEM;
+	}
+	iv->iv_index       = M0_ALLOC_ARR(iv->iv_index, reg_nr);
+	if (iv->iv_index == NULL) {
+		m0_free(bv->ov_buf);
+		m0_free(bv->ov_vec.v_count);
+		return -ENOMEM;
+	}
+	iv->iv_vec         = bv->ov_vec;
+
+	/* Fill count and buf/index arrays. */
+	i = 0;
+	void reg_fillvec(const void *p, const VISIT which, const int depth)
+	{
+		struct m0_be_regdtree_node *n =
+			(struct m0_be_regdtree_node *)p;
+		struct m0_be_reg_d         *r = n->bn_reg_d;
+		if (which == postorder || which == leaf) {
+			/* fill iv->iv_index[i], bv->ov_buf[i] and
+			 * iv->iv_vec.v_count[i]/bv->ov_vec.v_count[i]. */
+			m0_bcount_t b0;
+			M0_ASSERT(m0_addr_is_aligned(r->rd_buf,
+						     seg->bs_bshift));
+			b0 = be_seg_blkno(seg, r->rd_reg.br_addr);
+			bv->ov_vec.v_count[i] =
+				be_seg_blkno(seg, r->rd_reg.br_addr +
+					     r->rd_reg.br_size - 1) - b0 + 1;
+			bv->ov_buf[i] = m0_stob_addr_pack(r->rd_buf,
+							  seg->bs_bshift);
+			iv->iv_index[i] = b0;
+		}
+	}
+	twalk(regd_tree, &reg_fillvec);
+	return 0;
+}
+
+
 M0_INTERNAL void m0_be_reg_get(struct m0_be_reg *reg, struct m0_be_op *op)
 {
 	m0_bcount_t n;
@@ -426,14 +499,14 @@ M0_INTERNAL int m0_be__reg_write(struct m0_be_seg *seg, struct m0_be_op *op,
 }
 
 M0_INTERNAL int m0_be_seg_dict_lookup(struct m0_be_seg *seg, const char *name,
-					void **out)
+				      void **out)
 {
 	*out = NULL;
 	return -ENOENT;
 }
 
 M0_INTERNAL int m0_be_seg_dict_insert(struct m0_be_seg *seg, const char *name,
-					void *value)
+				      void *value)
 {
 	return 0;
 }
diff --git a/be/seg.h b/be/seg.h
index c824c3c..6ec9525 100644
--- a/be/seg.h
+++ b/be/seg.h
@@ -106,7 +106,7 @@ M0_INTERNAL int m0_be_seg_write(struct m0_be_seg *seg,
 				struct m0_bufvec *bv);
 
 M0_INTERNAL int m0_be_seg_bufvec_build(struct m0_be_seg *seg,
-				       struct m0_be_op *op,
+				       void *regd_tree,
 				       struct m0_indexvec *iv,
 				       struct m0_bufvec *bv);
 
diff --git a/be/tx.c b/be/tx.c
index 6b866a6..497e651 100644
--- a/be/tx.c
+++ b/be/tx.c
@@ -36,19 +36,13 @@
 
 #include "be/be.h"
 #include "be/tx.h"
+#include "be/tx_internal.h"    /* struct m0_be_regdtree_node */
 
 struct m0_be_tx_group_desc {
 	uint64_t tgd_size;
 	uint64_t tgd_tx_nr;
 };
 
-struct m0_be_reg_d {
-	struct m0_be_tx  *rd_tx;
-	m0_bindex_t       rd_idx;
-	struct m0_be_reg  rd_reg;
-	void             *rd_buf;
-};
-
 struct tx_group_header
 {
 };
@@ -288,11 +282,6 @@ M0_INTERNAL void m0_be_tx_open(struct m0_be_tx *tx)
 	M0_POST(m0_be__tx_invariant(tx));
 }
 
-/* Regions tree node for tsearch(). */
-struct be_regdtree_node {
-	struct m0_be_reg_d *bn_reg_d;
-};
-
 M0_INTERNAL void
 m0_be_tx_capture(struct m0_be_tx *tx, const struct m0_be_reg *reg)
 {
@@ -316,10 +305,10 @@ m0_be_tx_capture(struct m0_be_tx *tx, const struct m0_be_reg *reg)
 	 * buffers, until the new region either do not intersect any of the
 	 * old ones or is completely stuffed into old buffers. */
 	while (new->rd_reg.br_size > 0) {
-		struct m0_ext            enew;
-		struct m0_ext            eold;
-		struct m0_ext            intersection;
-		struct be_regdtree_node *oldnode;
+		struct m0_ext               enew;
+		struct m0_ext               eold;
+		struct m0_ext               intersection;
+		struct m0_be_regdtree_node *oldnode;
 
 		oldnode = tsearch(new, &tx->t_root, &tx_reg_cmp);
 		M0_ASSERT(oldnode != NULL);
diff --git a/be/tx_internal.h b/be/tx_internal.h
new file mode 100644
index 0000000..8d38b87
--- /dev/null
+++ b/be/tx_internal.h
@@ -0,0 +1,61 @@
+/* -*- C -*- */
+/*
+ * COPYRIGHT 2013 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: xrgtn <alexander_gattin@xyratex.com>
+ * Original creation date: 14-Jun-2013
+ */
+
+
+#pragma once
+
+#ifndef __MERO_BE_TX_INTERNAL_H__
+#define __MERO_BE_TX_INTERNAL_H__
+
+/**
+ * @defgroup be
+ *
+ * @{
+ */
+
+struct m0_be_reg_d {
+	struct m0_be_tx  *rd_tx;
+	m0_bindex_t       rd_idx;
+	struct m0_be_reg  rd_reg;
+	void             *rd_buf;
+};
+
+/* Regions tree node for tsearch(). */
+struct m0_be_regdtree_node {
+	struct m0_be_reg_d *bn_reg_d;
+};
+
+/** @} end of be group */
+
+#endif /* __MERO_BE_TX_INTERNAL_H__ */
+
+
+/*
+ *  Local variables:
+ *  c-indentation-style: "K&R"
+ *  c-basic-offset: 8
+ *  tab-width: 8
+ *  fill-column: 80
+ *  scroll-step: 1
+ *  End:
+ */
+/*
+ * vim: tabstop=8 shiftwidth=8 noexpandtab textwidth=80 nowrap
+ */
-- 
1.8.3.2

