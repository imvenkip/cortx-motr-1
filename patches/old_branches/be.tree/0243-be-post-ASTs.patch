From d7e5046afd9c54750d9c3b75f3ec427e8cb5299d Mon Sep 17 00:00:00 2001
From: "Valery V. Vorotyntsev" <valery_vorotyntsev@xyratex.com>
Date: Thu, 27 Jun 2013 15:22:26 +0300
Subject: [PATCH 243/290] be: post ASTs

Post ASTs from tx_fom_tick() to the sm_group of transaction's locality.

[WIP] be-tx-ut hangs on this line:
	rc = m0_be_tx_timedwait(&tx, M0_BITS(M0_BTS_PLACED), M0_TIME_NEVER);
---
 be/tx.c     | 37 +++++++++++++++++++++++++++++++------
 be/tx.h     | 19 +++++++++++++------
 be/tx_fom.c | 27 +++++++++++++++++----------
 3 files changed, 61 insertions(+), 22 deletions(-)

diff --git a/be/tx.c b/be/tx.c
index f694e58..9bf19c2 100644
--- a/be/tx.c
+++ b/be/tx.c
@@ -456,14 +456,8 @@ M0_INTERNAL void m0_be_tx_close(struct m0_be_tx *tx)
 	 * Release excessive (prepared, but not used) space back into the log.
 	 */
 	eng->te_reserved -= prepared - used;
-
 	tx_engine_got_space(eng);
 
-#if 1 /* XXX DELETEME? */
-	M0_LOG(M0_DEBUG, "Posting AST to engine->te_fom's sm_group");
-	m0_fom_wakeup(eng->te_fom);
-#endif
-	M0_POST(m0_be__tx_engine_invariant(eng));
 	tx_engine_unlock(eng);
 }
 
@@ -519,6 +513,12 @@ tx_engine_got_closed(struct m0_be_tx_engine *eng, struct m0_be_tx *tx)
 	tx_group_init(gr);
 	tx_group_add(eng, gr, tx);
 	tx_group_close(eng, gr);
+
+	M0_LOG(M0_DEBUG, "Posting \"wake up\" AST to engine->te_fom's"
+	       " sm_group");
+	m0_fom_wakeup(eng->te_fom);
+
+	M0_POST(m0_be__tx_engine_invariant(eng));
 #endif
 }
 
@@ -556,6 +556,31 @@ M0_INTERNAL void tx_state_set(struct m0_be_tx *tx, enum m0_be_tx_state state)
 	M0_POST(m0_be__tx_invariant(tx));
 }
 
+static void _state_set(struct m0_sm_group *grp M0_UNUSED, struct m0_sm_ast *ast)
+{
+	enum m0_be_tx_state state = *(enum m0_be_tx_state *)ast->sa_datum;
+	M0_ENTRY("state = %u", state);
+	M0_PRE(IS_IN_ARRAY(state, tx_states));
+
+	/* XXX TODO: bob_of() */
+	tx_state_set(container_of(ast, struct m0_be_tx, t_ast), state);
+	M0_LEAVE();
+}
+
+M0_INTERNAL void
+m0_be__tx_state_post(struct m0_be_tx *tx, enum m0_be_tx_state state)
+{
+	M0_ENTRY("state=%u", state);
+	M0_PRE(M0_IN(state, (M0_BTS_SUBMITTED, M0_BTS_LOGGED, M0_BTS_PLACED,
+			     M0_BTS_STABLE)));
+
+	tx->t_ast.sa_cb    = _state_set;
+	tx->t_ast.sa_datum = &tx->t_ast_datum;
+	tx->t_ast_datum    = state;
+	m0_sm_ast_post(tx->t_sm.sm_grp, &tx->t_ast);
+	M0_LEAVE();
+}
+
 static void tx_fail(struct m0_be_tx *tx, int err)
 {
 	M0_PRE(m0_be__tx_invariant(tx));
diff --git a/be/tx.h b/be/tx.h
index 0aa1db5..342dbd8 100644
--- a/be/tx.h
+++ b/be/tx.h
@@ -335,6 +335,9 @@ M0_INTERNAL void m0_be_tx_engine_fini(struct m0_be_tx_engine *engine);
 struct m0_be_tx {
 	uint64_t               t_magic;
 	struct m0_sm           t_sm;
+	struct m0_sm_ast       t_ast;
+	enum m0_be_tx_state    t_ast_datum;
+
 	/** Transaction identifier, assigned by the user. */
 	uint64_t               t_id;
 	/**
@@ -444,19 +447,23 @@ M0_INTERNAL void m0_be_tx_uncapture(struct m0_be_tx *tx,
 
 M0_INTERNAL void m0_be_tx_close(struct m0_be_tx *tx);
 
-M0_INTERNAL int m0_be_tx_timedwait(struct m0_be_tx *tx, int state,
-				   m0_time_t timeout);
-
 /** Forces the transaction to storage. */
 M0_INTERNAL void m0_be_tx_force(struct m0_be_tx *tx);
 
-/**
- * Notifies backend that the transaction is no longer needed for recovery.
- */
+M0_INTERNAL int m0_be_tx_timedwait(struct m0_be_tx *tx, int state,
+				   m0_time_t timeout);
+
+/** Notifies backend that the transaction is no longer needed for recovery. */
 M0_INTERNAL void m0_be_tx_stable(struct m0_be_tx *tx);
 
 M0_INTERNAL void tx_state_set(struct m0_be_tx *tx, enum m0_be_tx_state state);
 
+/**
+ * Posts an AST that will advance transaction's state machine to given state.
+ */
+M0_INTERNAL void m0_be__tx_state_post(struct m0_be_tx *tx,
+				      enum m0_be_tx_state state);
+
 M0_TL_DESCR_DECLARE(tx, M0_EXTERN);
 M0_TL_DECLARE(tx, M0_INTERNAL, struct m0_be_tx);
 
diff --git a/be/tx_fom.c b/be/tx_fom.c
index 9f37b93..6cc1e85 100644
--- a/be/tx_fom.c
+++ b/be/tx_fom.c
@@ -106,13 +106,17 @@ static struct m0_sm_conf tx_fom_conf = {
  * TX FOM operations
  * ------------------------------------------------------------------ */
 
+/*
+ * XXX RENAMEME: Proper name of this function is tx_group_fom_tick() or
+ * tx_group_tick().
+ */
 static int tx_fom_tick(struct m0_fom *fom)
 {
 	struct m0_be_tx *tx = m0_fom_phase(fom) > FS_STARTED ?
 		gr_tlist_head(&fom_to_txm(fom)->tf_engine->te_group.tg_tx) :
 		NULL;
 
-	M0_LOG(M0_DEBUG, "phase = %d", m0_fom_phase(fom));
+	M0_LOG(M0_DEBUG, "phase=%u", m0_fom_phase(fom));
 
 	switch (m0_fom_phase(fom)) {
 	case FS_STARTED:
@@ -126,13 +130,11 @@ static int tx_fom_tick(struct m0_fom *fom)
 		break;
 
 	case FS_LOG_HEADER_LOGGED:
-		/* XXX FIXME: post AST */
-		tx_state_set(tx, M0_BTS_SUBMITTED);
+		m0_be__tx_state_post(tx, M0_BTS_SUBMITTED);
 		break;
 
 	case FS_LOGGED:
-		/* XXX FIXME: post AST */
-		tx_state_set(tx, M0_BTS_LOGGED);
+		m0_be__tx_state_post(tx, M0_BTS_LOGGED);
 		break;
 
 	case FS_SUBMITTED_TO_SEG:
@@ -156,15 +158,20 @@ static int tx_fom_tick(struct m0_fom *fom)
 		M0_ASSERT(m0_be_op_state(&fom_to_txm(fom)->tf_op) ==
 			  M0_BOS_SUCCESS);
 		m0_be_op_fini(&fom_to_txm(fom)->tf_op);
-		/* XXX FIXME: post AST */
-		tx_state_set(tx, M0_BTS_PLACED);
-		m0_be_tx_free(tx);  /* free region buffers */
+		m0_be__tx_state_post(tx, M0_BTS_PLACED);
+#if 0
+		/*
+		 * XXX We can't call m0_be_tx_free() here, because tx's
+		 * locality may be unlocked.  Luckily, this call is removed
+		 * by commit 4e98260.
+		 */
+		m0_be_tx_free(tx);
+#endif
 		m0_fom_phase_set(fom, FS_STABLE);
 		return M0_FSO_AGAIN;
 
 	case FS_STABLE:
-		/* XXX FIXME: post AST */
-		tx_state_set(tx, M0_BTS_STABLE);
+		m0_be__tx_state_post(tx, M0_BTS_STABLE);
 		gr_tlist_del(tx);
 		tx_tlist_del(tx);
 
-- 
1.8.3.2

