From ab0cd530e4b6779dce126572ce349e071339fbda Mon Sep 17 00:00:00 2001
From: "Valery V. Vorotyntsev" <valery_vorotyntsev@xyratex.com>
Date: Tue, 2 Jul 2013 15:12:01 +0300
Subject: [PATCH 257/290] be: export m0_be__tx_state()

This accessor will be used by tx_group_tick(), which is defined in
another source file.
---
 be/tx.c | 24 ++++++++++++------------
 be/tx.h |  3 ++-
 2 files changed, 14 insertions(+), 13 deletions(-)

diff --git a/be/tx.c b/be/tx.c
index f937043..b196c37 100644
--- a/be/tx.c
+++ b/be/tx.c
@@ -212,7 +212,7 @@ M0_INTERNAL void
 m0_be_tx_prep(struct m0_be_tx *tx, const struct m0_be_tx_credit *credit)
 {
 	M0_PRE(m0_be__tx_invariant(tx));
-	M0_PRE(tx_state(tx) == M0_BTS_PREPARE);
+	M0_PRE(m0_be__tx_state(tx) == M0_BTS_PREPARE);
 	M0_PRE(tx_is_locked(tx));
 
 	m0_be_tx_credit_add(&tx->t_prepared, credit);
@@ -228,7 +228,7 @@ M0_INTERNAL void m0_be_tx_open(struct m0_be_tx *tx)
 	int			rc;
 
 	M0_PRE(m0_be__tx_invariant(tx));
-	M0_PRE(tx_state(tx) == M0_BTS_PREPARE);
+	M0_PRE(m0_be__tx_state(tx) == M0_BTS_PREPARE);
 	M0_PRE(tx_is_locked(tx));
 
 	if (log_size <= min_check(eng->te_log.lg_size,
@@ -261,7 +261,7 @@ m0_be_tx_capture(struct m0_be_tx *tx, const struct m0_be_reg *reg)
 	struct m0_be_reg_d     *prev = NULL;
 
 	M0_PRE(m0_be__tx_invariant(tx));
-	M0_PRE(tx_state(tx) == M0_BTS_ACTIVE);
+	M0_PRE(m0_be__tx_state(tx) == M0_BTS_ACTIVE);
 	M0_PRE(tx_is_locked(tx));
 
 	new->rd_tx  = tx;
@@ -383,7 +383,7 @@ M0_INTERNAL void
 m0_be_tx_capture(struct m0_be_tx *tx, const struct m0_be_reg *reg)
 {
 	M0_PRE(m0_be__tx_invariant(tx));
-	M0_PRE(tx_state(tx) == M0_BTS_ACTIVE);
+	M0_PRE(m0_be__tx_state(tx) == M0_BTS_ACTIVE);
 	M0_PRE(tx_is_locked(tx));
 
 	struct m0_be_reg_d new = {
@@ -402,7 +402,7 @@ M0_INTERNAL void
 m0_be_tx_uncapture(struct m0_be_tx *tx, const struct m0_be_reg *reg)
 {
 	M0_PRE(m0_be__tx_invariant(tx));
-	M0_PRE(tx_state(tx) == M0_BTS_ACTIVE);
+	M0_PRE(m0_be__tx_state(tx) == M0_BTS_ACTIVE);
 	M0_PRE(tx_is_locked(tx));
 
 	struct m0_be_reg_d rd = {
@@ -425,7 +425,7 @@ M0_INTERNAL void m0_be_tx_close(struct m0_be_tx *tx)
 	m0_bcount_t             used;
 	m0_bcount_t             prepared;
 
-	M0_PRE(tx_state(tx) == M0_BTS_ACTIVE);
+	M0_PRE(m0_be__tx_state(tx) == M0_BTS_ACTIVE);
 	M0_PRE(tx_is_locked(tx));
 
 	tx_engine_lock(eng);
@@ -491,7 +491,7 @@ tx_engine_got_closed(struct m0_be_tx_engine *eng, struct m0_be_tx *tx)
 	m0_bcount_t used = tx_log_size(tx, &tx->t_used,
 				       gr_tlist_is_empty(&gr->tg_tx));
 
-	M0_PRE(tx_state(tx) == M0_BTS_CLOSED);
+	M0_PRE(m0_be__tx_state(tx) == M0_BTS_CLOSED);
 
 	if (gr->tg_opened) {
 		if (gr->tg_used.tc_reg_size + used > eng->te_log.lg_gr_size_max)
@@ -501,7 +501,7 @@ tx_engine_got_closed(struct m0_be_tx_engine *eng, struct m0_be_tx *tx)
 	}
 	/* Note, that we do nothing when the group is closed. */
 #else /* XXX: close group after every tx close, for now */
-	M0_PRE(tx_state(tx) == M0_BTS_CLOSED);
+	M0_PRE(m0_be__tx_state(tx) == M0_BTS_CLOSED);
 
 	tx_group_init(gr);
 	tx_group_add(eng, gr, tx);
@@ -515,14 +515,14 @@ static void tx_open_tail(struct m0_be_tx *tx)
 {
 	m0_bcount_t log_size = tx_prepared_log_size(tx);
 
-	M0_PRE(M0_IN(tx_state(tx), (M0_BTS_OPENING, M0_BTS_PREPARE)));
+	M0_PRE(M0_IN(m0_be__tx_state(tx), (M0_BTS_OPENING, M0_BTS_PREPARE)));
 	M0_PRE(tx_engine_free_space(tx_engine(tx)) >= log_size);
 
 	tx_engine(tx)->te_reserved += log_size;
 	tx_state_set(tx, M0_BTS_ACTIVE);
 }
 
-static enum m0_be_tx_state tx_state(const struct m0_be_tx *tx)
+M0_INTERNAL enum m0_be_tx_state m0_be__tx_state(const struct m0_be_tx *tx)
 {
 	return tx->t_sm.sm_state;
 }
@@ -531,7 +531,7 @@ M0_INTERNAL void tx_state_set(struct m0_be_tx *tx, enum m0_be_tx_state state)
 {
 	M0_PRE(m0_be__tx_invariant(tx));
 	M0_PRE(tx_is_locked(tx));
-	M0_PRE(tx_state(tx) != state);
+	M0_PRE(m0_be__tx_state(tx) != state);
 
 	m0_sm_state_set(&tx->t_sm, state);
 	/*
@@ -640,7 +640,7 @@ m0_be__tx_engine_invariant(const struct m0_be_tx_engine *engine)
 
 M0_INTERNAL bool m0_be__tx_invariant(const struct m0_be_tx *tx)
 {
-	enum m0_be_tx_state state = tx_state(tx);
+	const enum m0_be_tx_state state = m0_be__tx_state(tx);
 
 	return true || ( /* XXX RESTOREME */
 		state < M0_BTS_NR &&
diff --git a/be/tx.h b/be/tx.h
index 6ff66ce..35bd9c7 100644
--- a/be/tx.h
+++ b/be/tx.h
@@ -302,7 +302,7 @@ struct m0_be_tx_engine {
 	struct m0_be_tx_group te_group;
 
 	/*
-	 * Various interesting positions in the log. Probably not needed.
+	 * Various interesting positions in the log. XXX Probably not needed.
 	 */
 	struct m0_be_tx      *te_start;
 	struct m0_be_tx      *te_placed;
@@ -450,6 +450,7 @@ M0_INTERNAL int m0_be_tx_timedwait(struct m0_be_tx *tx, int state,
 M0_INTERNAL void m0_be_tx_stable(struct m0_be_tx *tx);
 
 M0_INTERNAL void tx_state_set(struct m0_be_tx *tx, enum m0_be_tx_state state);
+M0_INTERNAL enum m0_be_tx_state m0_be__tx_state(const struct m0_be_tx *tx);
 
 /**
  * Posts an AST that will advance transaction's state machine to given state.
-- 
1.8.3.2

