From 8354deb399624aeb7d736a761a2471e1656e35cf Mon Sep 17 00:00:00 2001
From: Alexander Gattin <alexander_gattin@xyratex.com>
Date: Wed, 12 Jun 2013 14:55:53 +0300
Subject: [PATCH 149/290] be/seg: update op parameter in m0_be_reg_get()

---
 be/seg.c | 32 +++++++++++++++++++-------------
 1 file changed, 19 insertions(+), 13 deletions(-)

diff --git a/be/seg.c b/be/seg.c
index 10978e0..b082f44 100644
--- a/be/seg.c
+++ b/be/seg.c
@@ -88,11 +88,11 @@ static int stob_io_single_write(void *buf, m0_bcount_t bufsize,
 static int
 seg_header_create(struct m0_be_seg *seg, void *addr, m0_bcount_t size)
 {
-	uint32_t	      st_block_shift;
-	size_t		      st_block_size;
+	uint32_t              st_block_shift;
+	size_t                st_block_size;
 	struct m0_be_seg_hdr *hdrbuf;      /* seg hdr buffer */
-	m0_bcount_t	      hdrblocks;   /* number of sectors */
-	int		      rc;
+	m0_bcount_t           hdrblocks;   /* number of sectors */
+	int                   rc;
 
 	/* Allocate buffer for segment header. */
 	st_block_shift = seg->bs_stob->so_op->sop_block_shift(seg->bs_stob);
@@ -220,15 +220,15 @@ static int stob_io_single_read(void *buf, m0_bcount_t bufsize,
 
 M0_INTERNAL int m0_be_seg_open(struct m0_be_seg *seg)
 {
-	int		      rc;
-	uint32_t	      st_block_shift;
-	size_t		      st_block_size;
+	int                   rc;
+	uint32_t              st_block_shift;
+	size_t                st_block_size;
 	struct m0_be_seg_hdr *hdrbuf;      /* seg hdr buffer */
-	m0_bcount_t	      hdrblocks;   /* number of sectors */
-	void		     *seg_addr0;
-	m0_bcount_t	      seg_size;
-	m0_bcount_t	      i;
-	void		     *p;
+	m0_bcount_t           hdrblocks;   /* number of sectors */
+	void                 *seg_addr0;
+	m0_bcount_t           seg_size;
+	m0_bcount_t           i;
+	void                 *p;
 
 	/* Allocate buffer for segment header. */
 	st_block_shift = seg->bs_stob->so_op->sop_block_shift(seg->bs_stob);
@@ -295,7 +295,11 @@ M0_INTERNAL void m0_be_reg_get(struct m0_be_reg *reg, struct m0_be_op *op)
 {
 	m0_bcount_t n;
 
-	M0_PRE(m0_be__reg_invariant(reg));
+	M0_PRE(m0_be__reg_invariant(reg) && op != NULL);
+
+	op->bo_utype   = M0_BOP_REG;
+	op->bo_u.u_reg = *reg;
+	m0_sm_state_set(&op->bo_sm, M0_BOS_ACTIVE);
 
 	for (n = be_seg_pgno(reg->br_seg, reg->br_addr);
 	     n <= be_seg_pgno(reg->br_seg, reg->br_addr + reg->br_size); n++) {
@@ -303,6 +307,8 @@ M0_INTERNAL void m0_be_reg_get(struct m0_be_reg *reg, struct m0_be_op *op)
 		M0_ASSERT(reg->br_seg->bs_pgmap[n] & M0_BE_SEG_PG_PRESENT);
 		reg->br_seg->bs_pgmap[n]++;
 	}
+
+	m0_sm_state_set(&op->bo_sm, M0_BOS_SUCCESS);
 }
 
 M0_INTERNAL void m0_be_reg_get_fast(const struct m0_be_reg *reg)
-- 
1.8.3.2

