From f758b52507d88944f0ef804f47f6cb2a7ba30214 Mon Sep 17 00:00:00 2001
From: Alexander Gattin <alexander_gattin@xyratex.com>
Date: Wed, 12 Jun 2013 14:20:51 +0300
Subject: [PATCH 148/161] be/seg: implement m0_be_reg_get(), _get_fast(), put()
 and is_pinned()

Implement m0_be_reg_get(), m0_be_reg_get_fast(), m0_be_reg_put(),
m0_be__reg_is_pinned() using segment's linear page map (bs_pgmap).
---
 be/seg.c | 48 ++++++++++++++++++++++++++++++++++++++++++++----
 be/seg.h |  4 ++--
 2 files changed, 46 insertions(+), 6 deletions(-)

diff --git a/be/seg.c b/be/seg.c
index e2d83c6..10978e0 100644
--- a/be/seg.c
+++ b/be/seg.c
@@ -285,27 +285,67 @@ M0_INTERNAL void m0_be_seg_close(struct m0_be_seg *seg)
 	seg->bs_state = M0_BSS_CLOSED;
 }
 
+static m0_bcount_t be_seg_pgno(const struct m0_be_seg *seg, void *addr)
+{
+	return (addr - seg->bs_addr) /
+		(1 << seg->bs_stob->so_op->sop_block_shift(seg->bs_stob));
+}
+
 M0_INTERNAL void m0_be_reg_get(struct m0_be_reg *reg, struct m0_be_op *op)
 {
+	m0_bcount_t n;
+
 	M0_PRE(m0_be__reg_invariant(reg));
+
+	for (n = be_seg_pgno(reg->br_seg, reg->br_addr);
+	     n <= be_seg_pgno(reg->br_seg, reg->br_addr + reg->br_size); n++) {
+		/* XXX: launch stobio if page is not present. */
+		M0_ASSERT(reg->br_seg->bs_pgmap[n] & M0_BE_SEG_PG_PRESENT);
+		reg->br_seg->bs_pgmap[n]++;
+	}
 }
 
 M0_INTERNAL void m0_be_reg_get_fast(const struct m0_be_reg *reg)
 {
+	m0_bcount_t n;
+
 	M0_PRE(m0_be__reg_invariant(reg) && m0_be__reg_is_pinned(reg));
+
+	for (n = be_seg_pgno(reg->br_seg, reg->br_addr);
+	     n <= be_seg_pgno(reg->br_seg, reg->br_addr + reg->br_size); n++) {
+		M0_ASSERT(reg->br_seg->bs_pgmap[n] & M0_BE_SEG_PG_PRESENT);
+		reg->br_seg->bs_pgmap[n]++;
+	}
 }
 
 M0_INTERNAL void m0_be_reg_put(const struct m0_be_reg *reg)
 {
+	m0_bcount_t n;
+
 	M0_PRE(m0_be__reg_invariant(reg) && m0_be__reg_is_pinned(reg));
+
+	for (n = be_seg_pgno(reg->br_seg, reg->br_addr);
+	     n <= be_seg_pgno(reg->br_seg, reg->br_addr + reg->br_size); n++) {
+		M0_ASSERT(reg->br_seg->bs_pgmap[n] & M0_BE_SEG_PG_PRESENT);
+		M0_ASSERT((reg->br_seg->bs_pgmap[n] &
+			   M0_BE_SEG_PG_PIN_CNT_MASK) > 0);
+		reg->br_seg->bs_pgmap[n]--;
+	}
 }
 
 M0_INTERNAL bool m0_be__reg_is_pinned(const struct m0_be_reg *reg)
 {
-	/**
-	 * @todo To be implemented later, along with m0_be_reg_get(),
-	 *       m0_be_reg_get_fast(), and m0_be_reg_put().
-	 */
+	m0_bcount_t n;
+
+	M0_PRE(m0_be__reg_invariant(reg));
+
+	for (n = be_seg_pgno(reg->br_seg, reg->br_addr);
+	     n <= be_seg_pgno(reg->br_seg, reg->br_addr + reg->br_size); n++) {
+		if (! (reg->br_seg->bs_pgmap[n] & M0_BE_SEG_PG_PRESENT)
+		    || (reg->br_seg->bs_pgmap[n] &
+			M0_BE_SEG_PG_PIN_CNT_MASK) == 0)
+			return false;
+	}
 	return true;
 }
 
diff --git a/be/seg.h b/be/seg.h
index aac5a44..c0b4008 100644
--- a/be/seg.h
+++ b/be/seg.h
@@ -40,8 +40,8 @@ enum m0_be_seg_states {
 	M0_BSS_CLOSED,
 };
 
-#define M0_BE_SEG_PG_PRESENT      0x8000000000000000ULL
-#define M0_BE_SEG_PIN_CNT_MASK    (~M0_BE_SEG_PG_PRESENT)
+#define M0_BE_SEG_PG_PRESENT       0x8000000000000000ULL
+#define M0_BE_SEG_PG_PIN_CNT_MASK  (~M0_BE_SEG_PG_PRESENT)
 
 struct m0_be_seg {
 	uint64_t               bs_id; /* see also m0_be::b_next_segid */
-- 
1.8.3.2

