From fa2e9508433ab89b63f6581d6ac88da7b186971e Mon Sep 17 00:00:00 2001
From: Alexander Gattin <alexander_gattin@xyratex.com>
Date: Thu, 6 Jun 2013 14:05:28 +0300
Subject: [PATCH 109/161] be/list: implement m0_be_list_put()

---
 be/list.c | 33 +++++++++++++++++++++++++++++++--
 1 file changed, 31 insertions(+), 2 deletions(-)

diff --git a/be/list.c b/be/list.c
index 8c79686..8a4230f 100644
--- a/be/list.c
+++ b/be/list.c
@@ -77,9 +77,11 @@ M0_INTERNAL void m0_be_list_get(const struct m0_be_list *list,
 		   op->bo_sm.sm_grp);
 
 	for (ll = list->bl_list.t_head.l_head;
-	     ll != NULL && (void*)ll != &list->bl_list.t_head;
-	     ll = ll->ll_next) {
+	     ll != NULL && (void*)ll != &list->bl_list.t_head
+	     && nelems > 0;
+	     ll = ll->ll_next, nelems--) {
 		op->bo_u.u_list.l_llink     = ll;
+		op->bo_u.u_list.l_nelems    = nelems;
 		lreg_op->bo_u.u_reg.br_seg  = list->bl_seg;
 		lreg_op->bo_u.u_reg.br_size = list->bl_descr->
 			td_container_size;
@@ -94,6 +96,33 @@ M0_INTERNAL void m0_be_list_get(const struct m0_be_list *list,
 	m0_sm_state_set(&op->bo_sm, M0_BOS_SUCCESS);
 }
 
+M0_INTERNAL void m0_be_list_put(const struct m0_be_list *list,
+				m0_bcount_t nelems)
+{
+	struct m0_list_link *ll;
+	struct m0_list_link *prvll;
+
+	M0_PRE(list != NULL);
+	for (ll = list->bl_list.t_head.l_head;
+	     ll != NULL && (void*)ll != &list->bl_list.t_head
+	     && nelems > 0;
+	     nelems--) {
+		/* Check ll's reg before doing mem access. */
+		M0_ASSERT(m0_be__reg_is_pinned(&M0_BE_REG(list->bl_seg,
+							  list->bl_descr->
+							  td_container_size,
+							  (void *)ll -
+							  list->bl_descr->
+							  td_link_offset)));
+		prvll = ll;
+		ll = ll->ll_next; /* mem access */
+		m0_be_reg_put(&M0_BE_REG(list->bl_seg,
+					 list->bl_descr->td_container_size,
+					 (void *)ll -
+					 list->bl_descr->td_link_offset));
+	}
+}
+
 /*
  * Neither m0_be_list_init() nor m0_be_list_fini() will ever do anything.
  * We keep the interfaces for consistency.
-- 
1.8.3.2

