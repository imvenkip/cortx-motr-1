From 03929260d8e4e00bcadbb88fd2b32711743bce43 Mon Sep 17 00:00:00 2001
From: Nikita Danilov <nikita_danilov@xyratex.com>
Date: Sat, 1 Jun 2013 21:15:24 +0300
Subject: [PATCH 085/161] be: more tx.[ch] documentation.

---
 be/tx.h | 174 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++---
 1 file changed, 167 insertions(+), 7 deletions(-)

diff --git a/be/tx.h b/be/tx.h
index 3f9e97b..4cfda48 100644
--- a/be/tx.h
+++ b/be/tx.h
@@ -99,6 +99,8 @@ struct m0_be_tx_group;
  *       can set a call-back m0_be_tx::t_persistent() that is called when the
  *       transaction becomes persistent;
  *
+ *     - transactions become persistent in the same order as they close.
+ *
  * @{
  */
 
@@ -151,11 +153,14 @@ struct m0_be_tx_group;
  *
  * @endverbatim
  *
+ * A transaction goes through the states sequentially. The table below
+ * corresponds to sequence of transactions in the system history. An individual
+ * transaction, as it gets older, moves through this table bottom-up.
  *
  * @verbatim
  *
- *   transaction         log record
- *      state               state
+ *      transaction          log record
+ *         state                state
  * |                    |                     |
  * |                    |                     |
  * | STABLE             |  record discarded   |
@@ -213,45 +218,167 @@ struct m0_be_tx_group;
  *
  */
 enum m0_be_tx_state {
+	/**
+	 * Transaction failed. It cannot be used further and should be finalised
+	 * (m0_be_tx_fini()).
+	 *
+	 * Currently, the only way a transaction can reach this state is by
+	 * failing to allocate internal memory in m0_be_tx_open() call or by
+	 * growing too large (larger than the total log space) in prepare state.
+	 */
 	M0_BTS_FAILED,
+	/**
+	 * Initial state after m0_be_tx_init().
+	 */
 	M0_BTS_INIT,
+	/**
+	 * State in which transaction is being prepared to opening.
+	 *
+	 * In this state, m0_be_tx_prep() calls should be made to reserve
+	 * internal resources for the future captures. It is allowed to prepare
+	 * for more than will be actually captured: typically it is impossible
+	 * to precisely estimate updates that will be done as part of
+	 * transaction, so a user should conservatively prepare for the
+	 * worst-case.
+	 */
 	M0_BTS_PREPARE,
+	/**
+	 * In this state transaction wait for internal resource to be allocated.
+	 *
+	 * Specifically, the transaction is in this state until there is enough
+	 * free space in the log to store transaction updates.
+	 */
 	M0_BTS_OPENING,
+	/**
+	 * In this state transaction is used to capture updates.
+	 */
 	M0_BTS_ACTIVE,
+	/**
+	 * Transaction is closed, but not yet grouped.
+	 */
 	M0_BTS_CLOSED,
+	/**
+	 * Transaction is a member of transaction group.
+	 */
 	M0_BTS_GROUPED,
+	/**
+	 * Transaction updates are in flight to the log.
+	 */
 	M0_BTS_SUBMITTED,
+	/**
+	 * All transaction updates made it to the log.
+	 */
 	M0_BTS_LOGGED,
+	/**
+	 * All transaction in-place updates completed.
+	 */
 	M0_BTS_PLACED,
+	/**
+	 * Transaction was declared stable by call to m0_be_tx_stable().
+	 */
 	M0_BTS_STABLE,
 	M0_BTS_NR
 };
 
+/**
+ * This structure incapsulates internals of transactional log.
+ *
+ * Logically, a log is a circular buffer stored on persistent storage. It can be
+ * implemented as a single m0_stob (current implementation) or as a more complex
+ * growable structure scattered across multiple stobs.
+ *
+ * A position in the log is identified by a "log sequence number" (lsn), which
+ * is simply an offset in the log. lsn does not wrap back to 0 when cyclic
+ * buffer wraps around. lsn uniquely identifies a point in system history.
+ */
 struct m0_be_log {
+	/** Underlying storage. */
 	struct m0_stob  *lg_stob;
+	/** Log size. */
 	m0_bcount_t      lg_size;
+	/**
+	 * Maximal transaction group size.
+	 *
+	 * When a transaction group reaches this size, it is "closed" and new
+	 * group starts forming.
+	 */
 	m0_bcount_t      lg_gr_size_max;
 };
 
+/**
+ * Transaction group is a collection of transactions, consecutive in closing
+ * order, that are written to the log and recovered together.
+ *
+ * A new group is initially empty. It absorbs transactions as they are closed,
+ * until the group either grows larger than m0_be_log::lg_gr_size_max or grows
+ * older than XXX. At that point, the group is closed and a new group is opened
+ * up to an upper limit (XXX) on groups number (1 is a possible and reasonable
+ * such limit).
+ *
+ * Once a group is closed it constructs in memory its persistent representation,
+ * consisting of group header, sequence of transaction representations and group
+ * commit block. The memory for this representation is pre-allocated in
+ * transaction engine to avoid dead-locks. Once representation is constructed,
+ * it is written to the log in one or multiple asynchronous IOs. Before group
+ * commit block is written, all other IOs for the group must complete. After
+ * that, the commit block is written. Once commit block IO completes, it is
+ * guaranteed that the entire group is on the log. Waiting for IO completion can
+ * be eliminated by using (currently unimplemneted) barrier interface provided
+ * by m0_stob, or by placing in the commit block a strong checksum of group
+ * representation (the latter approach allows to check whether the entire group
+ * made it to the log).
+ *
+ */
 struct m0_be_tx_group {
-	m0_bindex_t  tg_lsn;
-	bool         tg_opened;
-	m0_bcount_t  tg_size;
-	void        *tg_tree;
+	/** lsn of transaction group header in the log. */
+	m0_bindex_t             tg_lsn;
+	bool                    tg_opened;
+	/** Total size of all updates in all transactions in this group. */
+	struct m0_be_tx_credit  tg_used;
+	/** Number of transactions in the group. */
+	m0_bcount_t             tg_tx_nr;
+	/**
+	 * A tree of disjoint updated memory regions in this group. This is
+	 * similar to m0_be_tx::t_tree, which see.
+	 */
+	void                   *tg_tree;
 };
 
+/**
+ * Transaction engine. Embedded in m0_be.
+ */
 struct m0_be_tx_engine {
+	/**
+	 * Per-state lists of transaction. Each non-failed transaction is in one
+	 * of these lists.
+	 */
 	struct m0_tl          te_txs[M0_BTS_NR];
+	/** Protects all fields of this struct. */
 	struct m0_rwlock      te_lock;
+	/** Transactional log. */
 	struct m0_be_log      te_log;
+	/**
+	 * Transactional group. (Currently the only one.)
+	 */
 	struct m0_be_tx_group te_group;
 
+	/*
+	 * Various interesting positions in the log. Probably not needed.
+	 */
+
 	struct m0_be_tx      *te_start;
 	struct m0_be_tx      *te_placed;
 	struct m0_be_tx      *te_logged;
 	struct m0_be_tx      *te_submitted;
 	struct m0_be_tx      *te_inmem;
 
+	/**
+	 * Total space reserved for transactions active transactions.
+	 *
+	 * This space is reserved by m0_tx_open(). When a transaction closes
+	 * (m0_be_tx_close()), the difference between reserved and actually used
+	 * space is released.
+	 */
 	m0_bcount_t           te_reserved;
 };
 
@@ -261,13 +388,38 @@ m0_be__tx_engine_invariant(const struct m0_be_tx_engine *engine);
 M0_INTERNAL void m0_be_tx_engine_init(struct m0_be_tx_engine *engine);
 M0_INTERNAL void m0_be_tx_engine_fini(struct m0_be_tx_engine *engine);
 
+/**
+ * Credit represents resources that a transaction could consume:
+ *
+ *     - for each region captured by an active transaction, contents of captured
+ *       region must be stored somewhere (to be written to the log later). That
+ *       requires memory, which must be pre-allocated before transaction
+ *       captures anything to avoid dead-locks;
+ *
+ *     - similarly, for each captured region, a fixed size region descriptor
+ *       (m0_be_reg_d) should be stored. The memory for the descriptor must be
+ *       pre-allocated;
+ *
+ *     - finally, before transaction captures anything, transaction engine must
+ *       assure that there is enough free space in the log to write
+ *       transaction's updates. The space required is proportional to total
+ *       number of regions captured by the transaction and to total size of
+ *       these regions.
+ *
+ * Hence, the user should inform the engine about amount and size of regions
+ * that the transaciton would modify. This is achieved by calling
+ * m0_be_tx_prep() (possibly multiple times), while the transaction is in
+ * PREPARE state. The calls to m0_be_tx_prep() must be conservative: it is fine
+ * to prepare for more updates that thet transaction will actually make (the
+ * latter quantity is usually impossible to know beforehand anyway), but the
+ * transaction must never capture more than it prepared.
+ */
 struct m0_be_tx_credit {
 	/**
 	 * The number of regions needed for operation representation in the
 	 * transaction.
 	 */
 	m0_bcount_t tc_reg_nr;
-
 	/** Total size of memory needed for the same. */
 	m0_bcount_t tc_reg_size;
 };
@@ -283,9 +435,17 @@ M0_INTERNAL void m0_be_tx_credit_mul(struct m0_be_tx_credit *c, m0_bcount_t k);
 
 typedef void (*m0_be_tx_cb_t)(const struct m0_be_tx *tx);
 
+/**
+ * Transaction.
+ */
 struct m0_be_tx {
 	struct m0_sm           t_sm;
+	/** Transaction identifier, assigned by the user. */
 	uint64_t               t_id;
+	/**
+	 * lsn of transaction representation in the log. Assigned when the
+	    transaction reaches GROUPED state.
+	*/
 	uint64_t               t_lsn;
 	struct m0_be          *t_be;
 	struct m0_tlink        t_linkage;
-- 
1.8.3.2

