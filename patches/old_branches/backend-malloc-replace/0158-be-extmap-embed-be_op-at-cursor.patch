From a379b861a79975c02d664b13bf7ed55f7fdb1054 Mon Sep 17 00:00:00 2001
From: Andriy Tkachuk <andriy_tkachuk@xyratex.com>
Date: Mon, 17 Jun 2013 15:46:15 +0300
Subject: [PATCH 158/161] be: extmap: embed be_op at cursor

Now, m0_emap_{extent_update,merge,split,paste}() routines
do not take op as parameter.
---
 be/extmap.c          | 96 +++++++++++++++++++++++++---------------------------
 be/extmap.h          | 39 ++++++++++-----------
 be/extmap_internal.h |  9 ++---
 be/ut/extmap.c       | 18 +++++-----
 4 files changed, 77 insertions(+), 85 deletions(-)

diff --git a/be/extmap.c b/be/extmap.c
index 235d03f..8a33c62 100644
--- a/be/extmap.c
+++ b/be/extmap.c
@@ -194,9 +194,9 @@ static void be_emap_close(struct m0_be_emap_cursor *it)
 	m0_be_btree_cursor_fini(&it->ec_cursor);
 }
 
-M0_INTERNAL struct m0_be_op *m0_be_emap_be_op_get(struct m0_be_emap_cursor *it)
+M0_INTERNAL struct m0_be_op *m0_be_emap_op_get(struct m0_be_emap_cursor *it)
 {
-	return &it->ec_cursor.bc_op;
+	return &it->ec_op;
 }
 
 static void be_emap_lookup(struct m0_be_emap *map, struct m0_be_tx *tx,
@@ -207,14 +207,14 @@ static void be_emap_lookup(struct m0_be_emap *map, struct m0_be_tx *tx,
 
 	emap_it_init(map, tx, prefix, offset, it);
 	m0_be_btree_cursor_get(&it->ec_cursor, &it->ec_keybuf, true);
-	result = m0_be_emap_be_op_get(it)->bo_sm.sm_rc;
+	result = it->ec_cursor.bc_op.bo_sm.sm_rc;
 	if (result != 0) {
 		be_emap_close(it);
 		return;
 	}
 	emap_it_open(it);
 	if (!emap_it_prefix_ok(it))
-		result = m0_be_emap_be_op_get(it)->bo_sm.sm_rc = -ESRCH;
+		result = it->ec_cursor.bc_op.bo_sm.sm_rc = -ESRCH;
 
 	M0_POST(ergo(result == 0, m0_ext_is_in(&it->ec_seg.ee_ext, offset)));
 }
@@ -224,7 +224,7 @@ static void be_emap_next(struct m0_be_emap_cursor *it)
 	m0_be_btree_cursor_next(&it->ec_cursor);
 	emap_it_open(it);
 	if (!emap_it_prefix_ok(it))
-		m0_be_emap_be_op_get(it)->bo_sm.sm_rc = -ESRCH;
+		it->ec_cursor.bc_op.bo_sm.sm_rc = -ESRCH;
 }
 
 static void be_emap_prev(struct m0_be_emap_cursor *it)
@@ -232,7 +232,7 @@ static void be_emap_prev(struct m0_be_emap_cursor *it)
 	m0_be_btree_cursor_prev(&it->ec_cursor);
 	emap_it_open(it);
 	if (!emap_it_prefix_ok(it))
-		m0_be_emap_be_op_get(it)->bo_sm.sm_rc = -ESRCH;
+		it->ec_cursor.bc_op.bo_sm.sm_rc = -ESRCH;
 }
 
 #if 0
@@ -325,9 +325,8 @@ M0_INTERNAL void m0_be_emap_prev(struct m0_be_emap_cursor *it)
 }
 
 M0_INTERNAL void m0_be_emap_extent_update(struct m0_be_emap_cursor *it,
-				       struct m0_be_tx       *tx,
-				       struct m0_be_op       *op,
-				 const struct m0_be_emap_seg    *es)
+					  struct m0_be_tx          *tx,
+				    const struct m0_be_emap_seg    *es)
 {
 	struct m0_be_op bt_op;
 
@@ -336,7 +335,7 @@ M0_INTERNAL void m0_be_emap_extent_update(struct m0_be_emap_cursor *it,
 	M0_PRE(m0_uint128_eq(&it->ec_seg.ee_pre, &es->ee_pre));
 	M0_PRE(it->ec_seg.ee_ext.e_end == es->ee_ext.e_end);
 
-	m0_sm_state_set(&op->bo_sm, M0_BOS_ACTIVE);
+	m0_sm_state_set(&it->ec_op.bo_sm, M0_BOS_ACTIVE);
 
 	it->ec_seg.ee_ext.e_start = es->ee_ext.e_start;
 	it->ec_seg.ee_val = es->ee_val;
@@ -345,23 +344,22 @@ M0_INTERNAL void m0_be_emap_extent_update(struct m0_be_emap_cursor *it,
 								&it->ec_recbuf);
 	M0_ASSERT(m0_be_op_state(&bt_op) == M0_BOS_SUCCESS);
 
-	op->bo_sm.sm_rc = bt_op.bo_sm.sm_rc;
-	m0_sm_state_set(&op->bo_sm, M0_BOS_SUCCESS);
+	it->ec_op.bo_sm.sm_rc = bt_op.bo_sm.sm_rc;
+	m0_sm_state_set(&it->ec_op.bo_sm, M0_BOS_SUCCESS);
 }
 
 M0_INTERNAL void m0_be_emap_merge(struct m0_be_emap_cursor *it,
-			       struct m0_be_tx       *tx,
-			       struct m0_be_op       *op,
-			       m0_bindex_t            delta)
+				  struct m0_be_tx          *tx,
+				  m0_bindex_t               delta)
 {
 	struct m0_be_op  bt_op;
-	struct m0_be_op *bt_it_op = m0_be_emap_be_op_get(it);
+	struct m0_be_op *bt_it_op = &it->ec_cursor.bc_op;
 
 	M0_PRE(!m0_be_emap_ext_is_last(&it->ec_seg.ee_ext));
 	M0_PRE(delta <= m0_ext_length(&it->ec_seg.ee_ext));
 	M0_INVARIANT_EX(be_emap_invariant(it));
 
-	m0_sm_state_set(&op->bo_sm, M0_BOS_ACTIVE);
+	m0_sm_state_set(&it->ec_op.bo_sm, M0_BOS_ACTIVE);
 
 	m0_be_btree_delete(&it->ec_map->em_mapping, tx, &bt_op, &it->ec_keybuf);
 	M0_ASSERT(m0_be_op_state(&bt_op) == M0_BOS_SUCCESS);
@@ -386,7 +384,7 @@ M0_INTERNAL void m0_be_emap_merge(struct m0_be_emap_cursor *it,
 		goto fail;
 	emap_it_open(it);
 	if (!emap_it_prefix_ok(it)) {
-		op->bo_sm.sm_rc = -ESRCH;
+		it->ec_op.bo_sm.sm_rc = -ESRCH;
 		goto fail;
 	}
 
@@ -396,27 +394,26 @@ M0_INTERNAL void m0_be_emap_merge(struct m0_be_emap_cursor *it,
 		goto fail;
 
 	it->ec_seg.ee_ext.e_start -= delta;
-	m0_be_emap_extent_update(it, tx, &bt_op, &it->ec_seg);
-	M0_ASSERT(m0_be_op_state(&bt_op) == M0_BOS_SUCCESS);
-	if (bt_op.bo_sm.sm_rc != 0)
+	m0_be_emap_extent_update(it, tx, &it->ec_seg);
+	M0_ASSERT(m0_be_op_state(&it->ec_op) == M0_BOS_SUCCESS);
+	if (it->ec_op.bo_sm.sm_rc != 0)
 		goto fail;
 
 	M0_ASSERT_EX(be_emap_invariant(it));
 
-	m0_sm_state_set(&op->bo_sm, M0_BOS_SUCCESS);
+	m0_sm_state_set(&it->ec_op.bo_sm, M0_BOS_SUCCESS);
 	return;
 
 fail:
-	m0_sm_state_set(&op->bo_sm, M0_BOS_FAILURE);
-	if (op->bo_sm.sm_rc == 0)
-		op->bo_sm.sm_rc = bt_op.bo_sm.sm_rc ?:
-				  bt_it_op->bo_sm.sm_rc;
+	m0_sm_state_set(&it->ec_op.bo_sm, M0_BOS_FAILURE);
+	if (it->ec_op.bo_sm.sm_rc == 0)
+		it->ec_op.bo_sm.sm_rc = bt_op.bo_sm.sm_rc ?:
+					bt_it_op->bo_sm.sm_rc;
 }
 
 static void be_emap_split(struct m0_be_emap_cursor *it,
-		       struct m0_be_tx       *tx,
-		       struct m0_be_op       *op,
-		       struct m0_indexvec    *vec, m0_bindex_t scan)
+			  struct m0_be_tx          *tx,
+			  struct m0_indexvec       *vec, m0_bindex_t scan)
 {
 	uint32_t      i;
 	m0_bcount_t   count;
@@ -426,9 +423,9 @@ static void be_emap_split(struct m0_be_emap_cursor *it,
 		.b_nob  = sizeof save_key
 	};
 	struct m0_be_op  bt_op;
-	struct m0_be_op *bt_it_op = m0_be_emap_be_op_get(it);
+	struct m0_be_op *bt_it_op = &it->ec_cursor.bc_op;
 
-	m0_sm_state_set(&op->bo_sm, M0_BOS_ACTIVE);
+	m0_sm_state_set(&it->ec_op.bo_sm, M0_BOS_ACTIVE);
 
 	m0_be_btree_delete(&it->ec_map->em_mapping, tx, &bt_op, &it->ec_keybuf);
 	M0_ASSERT(m0_be_op_state(&bt_op) == M0_BOS_SUCCESS);
@@ -444,7 +441,7 @@ static void be_emap_split(struct m0_be_emap_cursor *it,
 		goto fail;
 	emap_it_open(it);
 	if (!emap_it_prefix_ok(it)) {
-		op->bo_sm.sm_rc = -ESRCH;
+		it->ec_op.bo_sm.sm_rc = -ESRCH;
 		goto fail;
 	}
 
@@ -478,33 +475,31 @@ static void be_emap_split(struct m0_be_emap_cursor *it,
 		emap_it_open(it);
 	}
 
-	m0_sm_state_set(&op->bo_sm, M0_BOS_SUCCESS);
+	m0_sm_state_set(&it->ec_op.bo_sm, M0_BOS_SUCCESS);
 	return;
 
 fail:
-	m0_sm_state_set(&op->bo_sm, M0_BOS_FAILURE);
-	if (op->bo_sm.sm_rc == 0)
-		op->bo_sm.sm_rc = bt_op.bo_sm.sm_rc ?:
-				  bt_it_op->bo_sm.sm_rc;
+	m0_sm_state_set(&it->ec_op.bo_sm, M0_BOS_FAILURE);
+	if (it->ec_op.bo_sm.sm_rc == 0)
+		it->ec_op.bo_sm.sm_rc = bt_op.bo_sm.sm_rc ?:
+					bt_it_op->bo_sm.sm_rc;
 }
 
 M0_INTERNAL void m0_be_emap_split(struct m0_be_emap_cursor *it,
-			       struct m0_be_tx       *tx,
-			       struct m0_be_op       *op,
-			       struct m0_indexvec    *vec)
+				  struct m0_be_tx          *tx,
+				  struct m0_indexvec       *vec)
 {
 	M0_PRE(m0_vec_count(&vec->iv_vec) == m0_ext_length(&it->ec_seg.ee_ext));
 	M0_INVARIANT_EX(be_emap_invariant(it));
 
-	be_emap_split(it, tx, op, vec, it->ec_seg.ee_ext.e_start);
+	be_emap_split(it, tx, vec, it->ec_seg.ee_ext.e_start);
 	M0_ASSERT_EX(be_emap_invariant(it));
 }
 
 M0_INTERNAL void m0_be_emap_paste(struct m0_be_emap_cursor *it,
-			       struct m0_be_tx       *tx,
-			       struct m0_be_op       *op,
-			 const struct m0_ext         *ext0,
-			       uint64_t               val,
+				  struct m0_be_tx          *tx,
+			    const struct m0_ext            *ext0,
+				  uint64_t                  val,
 	void (*del)(struct m0_be_emap_seg*),
 	void (*cut_left)(struct m0_be_emap_seg*, struct m0_ext*, uint64_t),
 	void (*cut_right)(struct m0_be_emap_seg*, struct m0_ext*, uint64_t))
@@ -567,9 +562,9 @@ M0_INTERNAL void m0_be_emap_paste(struct m0_be_emap_cursor *it,
 		if (length[0] == 0 && length[2] == 0)
 			del(seg);
 
-		be_emap_split(it, tx, op, &vec, length[0] > 0 ? chunk->e_start :
+		be_emap_split(it, tx, &vec, length[0] > 0 ? chunk->e_start :
 							     ext0->e_start);
-		if (op->bo_sm.sm_rc != 0)
+		if (it->ec_op.bo_sm.sm_rc != 0)
 			break;
 
 		ext.e_start += consumed;
@@ -580,7 +575,7 @@ M0_INTERNAL void m0_be_emap_paste(struct m0_be_emap_cursor *it,
 		M0_ASSERT(!m0_be_emap_ext_is_last(&seg->ee_ext));
 	}
 
-	M0_ASSERT_EX(ergo(op->bo_sm.sm_rc == 0, be_emap_invariant(it)));
+	M0_ASSERT_EX(ergo(it->ec_op.bo_sm.sm_rc == 0, be_emap_invariant(it)));
 
 	/*
 	 * A tale of two keys.
@@ -701,9 +696,10 @@ M0_INTERNAL m0_bcount_t m0_be_emap_caret_step(const struct m0_be_emap_caret *car
 	return car->ct_it->ec_seg.ee_ext.e_end - car->ct_index;
 }
 
-M0_INTERNAL int m0_be_emap_caret_move(struct m0_be_emap_caret *car, m0_bcount_t count)
+M0_INTERNAL int m0_be_emap_caret_move(struct m0_be_emap_caret *car,
+				      m0_bcount_t count)
 {
-	struct m0_be_op *bt_it_op = m0_be_emap_be_op_get(car->ct_it);
+	struct m0_be_op *bt_it_op = &car->ct_it->ec_cursor.bc_op;
 
 	M0_ASSERT(m0_be_emap_caret_invariant(car));
 	while (count > 0 && car->ct_index < M0_BINDEX_MAX + 1) {
diff --git a/be/extmap.h b/be/extmap.h
index de0b084..b69f1ad 100644
--- a/be/extmap.h
+++ b/be/extmap.h
@@ -178,7 +178,7 @@ M0_INTERNAL bool m0_be_emap_ext_is_first(const struct m0_ext *ext);
 M0_INTERNAL struct m0_be_emap_seg *m0_be_emap_seg_get(struct m0_be_emap_cursor *it);
 
 /** Returns the back-end operation of emap cursor */
-M0_INTERNAL struct m0_be_op *m0_be_emap_be_op_get(struct m0_be_emap_cursor *it);
+M0_INTERNAL struct m0_be_op *m0_be_emap_op_get(struct m0_be_emap_cursor *it);
 
 /**
    Initialises extent map cursor to point to the segment containing given
@@ -187,7 +187,7 @@ M0_INTERNAL struct m0_be_op *m0_be_emap_be_op_get(struct m0_be_emap_cursor *it);
    All operations done through this cursor are executed in the context of given
    transaction.
 
-   Asynchronous operation, get status via m0_be_emap_be_op_get(it)->bo_sm.sm_rc.
+   Asynchronous operation, get status via m0_be_emap_op_get(it)->bo_sm.sm_rc.
 
    @pre offset <= M0_BINDEX_MAX
 
@@ -207,7 +207,7 @@ M0_INTERNAL void m0_be_emap_lookup(struct m0_be_emap        *map,
 /**
    Move cursor to the next segment in its map.
 
-   Asynchronous operation, get status via m0_be_emap_be_op_get(it)->bo_sm.sm_rc.
+   Asynchronous operation, get status via m0_be_emap_op_get(it)->bo_sm.sm_rc.
 
    @pre !m0_be_emap_ext_is_last(m0_be_emap_seg_get(it))
  */
@@ -216,7 +216,7 @@ M0_INTERNAL void m0_be_emap_next(struct m0_be_emap_cursor *it);
 /**
    Move cursor to the previous segment in its map.
 
-   Asynchronous operation, get status via m0_be_emap_be_op_get(it)->bo_sm.sm_rc.
+   Asynchronous operation, get status via m0_be_emap_op_get(it)->bo_sm.sm_rc.
 
    @pre !m0_be_emap_ext_is_first(m0_be_emap_seg_get(it))
  */
@@ -229,15 +229,14 @@ M0_INTERNAL void m0_be_emap_prev(struct m0_be_emap_cursor *it);
    Current segment's extent is shrunk by delta. If this would make it empty, the
    current segment is deleted. The next segment is expanded by delta downwards.
 
-   Asynchronous operation, get status via m0_be_emap_be_op_get(it)->bo_sm.sm_rc.
+   Asynchronous operation, get status via m0_be_emap_op_get(it)->bo_sm.sm_rc.
 
    @pre !m0_be_emap_ext_is_last(m0_be_emap_seg_get(it))
    @pre delta <= m0_ext_length(m0_be_emap_seg_get(it));
  */
 M0_INTERNAL void m0_be_emap_merge(struct m0_be_emap_cursor *it,
-			       struct m0_be_tx       *tx,
-			       struct m0_be_op       *op,
-			       m0_bindex_t            delta);
+				  struct m0_be_tx          *tx,
+				  m0_bindex_t               delta);
 
 /**
    Split the segment the cursor is current positioned at into a collection of
@@ -253,20 +252,19 @@ M0_INTERNAL void m0_be_emap_merge(struct m0_be_emap_cursor *it,
    Empty segments from vec are skipped.  On successful completion, the cursor is
    positioned on the last created segment.
 
-   Asynchronous operation, get status via m0_be_emap_be_op_get(it)->bo_sm.sm_rc.
+   Asynchronous operation, get status via m0_be_emap_op_get(it)->bo_sm.sm_rc.
 
    @pre m0_vec_count(&vec->ov_vec) == m0_ext_length(m0_be_emap_seg_get(it))
  */
 M0_INTERNAL void m0_be_emap_split(struct m0_be_emap_cursor *it,
-			       struct m0_be_tx       *tx,
-			       struct m0_be_op       *op,
-			       struct m0_indexvec    *vec);
+				  struct m0_be_tx          *tx,
+				  struct m0_indexvec       *vec);
 
 /**
    Paste segment (ext, val) into the map, deleting or truncating overlapping
    segments as necessary.
 
-   Asynchronous operation, get status via m0_be_emap_be_op_get(it)->bo_sm.sm_rc.
+   Asynchronous operation, get status via m0_be_emap_op_get(it)->bo_sm.sm_rc.
 
    @param del - this call-back is called when an existing segment is completely
    covered by a new one and has to be deleted. The segment to be deleted is
@@ -294,10 +292,9 @@ M0_INTERNAL void m0_be_emap_split(struct m0_be_emap_cursor *it,
    a part of official function contract.
  */
 M0_INTERNAL void m0_be_emap_paste(struct m0_be_emap_cursor *it,
-			       struct m0_be_tx       *tx,
-			       struct m0_be_op       *op,
-			 const struct m0_ext         *ext0,
-			       uint64_t               val,
+				  struct m0_be_tx          *tx,
+			    const struct m0_ext            *ext0,
+				  uint64_t                  val,
 	void (*del)(struct m0_be_emap_seg*),
 	void (*cut_left)(struct m0_be_emap_seg*, struct m0_ext*, uint64_t),
 	void (*cut_right)(struct m0_be_emap_seg*, struct m0_ext*, uint64_t));
@@ -309,9 +306,8 @@ M0_INTERNAL void m0_be_emap_paste(struct m0_be_emap_cursor *it,
    @pre m0_uint128_eq(&it->ec_seg.ee_pre, &es->ee_pre) == true
  */
 M0_INTERNAL void m0_be_emap_extent_update(struct m0_be_emap_cursor *it,
-				       struct m0_be_tx       *tx,
-				       struct m0_be_op       *op,
-				 const struct m0_be_emap_seg    *es);
+					  struct m0_be_tx          *tx,
+				    const struct m0_be_emap_seg    *es);
 
 /**
    Release the resources associated with the cursor.
@@ -346,7 +342,8 @@ M0_INTERNAL void m0_be_emap_caret_fini(struct m0_be_emap_caret *car);
 /**
    Move the caret.
 
-   Asynchronous operation, get status via m0_be_emap_be_op_get(it)->bo_sm.sm_rc.
+   Asynchronous operation, get status via
+   m0_be_emap_op_get(car->ct_it)->bo_sm.sm_rc.
  */
 M0_INTERNAL int m0_be_emap_caret_move(struct m0_be_emap_caret *car,
 				   m0_bcount_t           count);
diff --git a/be/extmap_internal.h b/be/extmap_internal.h
index 40efb03..82b10e7 100644
--- a/be/extmap_internal.h
+++ b/be/extmap_internal.h
@@ -98,16 +98,17 @@ struct m0_be_emap {
  */
 struct m0_be_emap_cursor {
 	/** Map this cursor is iterating through. */
-	struct m0_be_emap           *ec_map;
+	struct m0_be_emap        *ec_map;
 	/** Segment currently reached. */
-	struct m0_be_emap_seg        ec_seg;
+	struct m0_be_emap_seg     ec_seg;
 	/** Data-base cursor. */
 	struct m0_be_btree_cursor ec_cursor;
-	struct m0_be_emap_key        ec_key;
-	struct m0_be_emap_rec        ec_rec;
+	struct m0_be_emap_key     ec_key;
+	struct m0_be_emap_rec     ec_rec;
 	struct m0_buf             ec_keybuf;
 	struct m0_buf             ec_recbuf;
 	struct m0_uint128         ec_prefix;
+	struct m0_be_op           ec_op;
 };
 
 /** @} end group extmap */
diff --git a/be/ut/extmap.c b/be/ut/extmap.c
index 509b591..7474302 100644
--- a/be/ut/extmap.c
+++ b/be/ut/extmap.c
@@ -84,7 +84,7 @@ static void test_init(void)
 	m0_uint128_init(&prefix, "some random iden");
 	seg = m0_be_emap_seg_get(&it);
 
-	it_op = m0_be_emap_be_op_get(&it);
+	it_op = m0_be_emap_op_get(&it);
 }
 
 static void test_fini(void)
@@ -158,9 +158,9 @@ static void split(m0_bindex_t offset, int nr, bool commit)
 			total = 1;
 		}
 		len[ARRAY_SIZE(len) - 1] = m0_ext_length(&seg->ee_ext) - total;
-		m0_be_emap_split(&it, &tx, &op, &vec);
-		M0_ASSERT(m0_be_op_state(&op) == M0_BOS_SUCCESS);
-		M0_UT_ASSERT(op.bo_sm.sm_rc == 0);
+		m0_be_emap_split(&it, &tx, &vec);
+		M0_ASSERT(m0_be_op_state(&it.ec_op) == M0_BOS_SUCCESS);
+		M0_UT_ASSERT(it.ec_op.bo_sm.sm_rc == 0);
 	}
 	m0_be_emap_close(&it);
 	if (commit)
@@ -192,8 +192,7 @@ static void test_print(void)
 		if (m0_be_emap_ext_is_last(&seg->ee_ext))
 			break;
 		m0_be_emap_next(&it);
-		M0_ASSERT(m0_be_op_state(it_op) ==
-								M0_BOS_SUCCESS);
+		M0_ASSERT(m0_be_op_state(it_op) == M0_BOS_SUCCESS);
 		M0_UT_ASSERT(it_op->bo_sm.sm_rc == 0);
 	}
 	m0_be_emap_close(&it);
@@ -206,10 +205,9 @@ static void test_merge(void)
 	M0_UT_ASSERT(it_op->bo_sm.sm_rc == 0);
 
 	while (!m0_be_emap_ext_is_last(&seg->ee_ext)) {
-		m0_be_emap_merge(&it, &tx, &op,
-						m0_ext_length(&seg->ee_ext));
-		M0_ASSERT(m0_be_op_state(&op) == M0_BOS_SUCCESS);
-		M0_UT_ASSERT(op.bo_sm.sm_rc == 0);
+		m0_be_emap_merge(&it, &tx, m0_ext_length(&seg->ee_ext));
+		M0_ASSERT(m0_be_op_state(it_op) == M0_BOS_SUCCESS);
+		M0_UT_ASSERT(it_op->bo_sm.sm_rc == 0);
 	}
 	m0_be_emap_close(&it);
 	checkpoint();
-- 
1.8.3.2

