From c522feaca2903467c607b5f10b40f38b902ea09b Mon Sep 17 00:00:00 2001
From: Maxim Medved <Max_Medved@xyratex.com>
Date: Mon, 17 Jun 2013 18:18:53 +0300
Subject: [PATCH 160/161] be/alloc: added op to alloc UT

---
 be/alloc.c    | 15 +++++++++++----
 be/be.c       | 16 ++++++++++++++--
 be/be.h       |  3 +++
 be/ut/alloc.c | 14 ++++++++++----
 4 files changed, 38 insertions(+), 10 deletions(-)

diff --git a/be/alloc.c b/be/alloc.c
index c160730..2cae782 100644
--- a/be/alloc.c
+++ b/be/alloc.c
@@ -483,11 +483,12 @@ M0_INTERNAL void *m0_be_alloc(struct m0_be_allocator *a,
 	} m0_tl_endfor;
 	/* and ends here */
 	m0_mutex_unlock(&a->ba_lock);
-	M0_POST(m0_be_allocator__invariant(a));
 
-	/* XXX: use sm state set!!! */
-	op->bo_sm.sm_state = M0_BOS_SUCCESS;
+	/* XXX */
+	m0_be_op_state_set(op, M0_BOS_ACTIVE);
+	m0_be_op_state_set(op, M0_BOS_SUCCESS);
 
+	M0_POST(m0_be_allocator__invariant(a));
 	M0_POST(ergo(c != NULL, !c->bac_free));
 	M0_POST(ergo(c != NULL, c->bac_size >= size));
 	M0_POST(ergo(c != NULL, m0_addr_is_aligned(&c->bac_mem, shift)));
@@ -503,7 +504,7 @@ M0_INTERNAL void m0_be_free(struct m0_be_allocator *a,
 	bool		       chunks_were_merged;
 
 	if (ptr == NULL)
-		return;
+		goto done;
 
 	M0_PRE(m0_be_allocator__invariant(a));
 	m0_mutex_lock(&a->ba_lock);
@@ -525,6 +526,12 @@ M0_INTERNAL void m0_be_free(struct m0_be_allocator *a,
 		M0_POST(be_alloc_chunk_invariant(a, c));
 	}
 	m0_mutex_unlock(&a->ba_lock);
+
+done:
+	/* XXX */
+	m0_be_op_state_set(op, M0_BOS_ACTIVE);
+	m0_be_op_state_set(op, M0_BOS_SUCCESS);
+
 	M0_POST(m0_be_allocator__invariant(a));
 }
 
diff --git a/be/be.c b/be/be.c
index 162883a..7679e5c 100644
--- a/be/be.c
+++ b/be/be.c
@@ -23,6 +23,7 @@
 #include "lib/trace.h"
 #include "lib/cdefs.h" /* container_of */
 #include "lib/misc.h" /* M0_BITS */
+#include "lib/memory.h"	/* m0_alloc */
 #include "be/btree.h"
 #include "be/be.h"
 #include "sm/sm.h"
@@ -97,13 +98,24 @@ M0_INTERNAL enum m0_be_op_state m0_be_op_state(struct m0_be_op *op)
 
 M0_INTERNAL void m0_be_op_init(struct m0_be_op *op)
 {
-	static struct m0_sm_group be_grp; /*XXX*/
-	m0_sm_init(&op->bo_sm, &op_states_conf, M0_BOS_INIT, &be_grp);
+	m0_sm_group_init(&op->bo_sm_grp);
+	m0_sm_init(&op->bo_sm, &op_states_conf, M0_BOS_INIT, &op->bo_sm_grp);
 }
 
 M0_INTERNAL void m0_be_op_fini(struct m0_be_op *op)
 {
+	m0_sm_group_lock(&op->bo_sm_grp);
 	m0_sm_fini(&op->bo_sm);
+	m0_sm_group_unlock(&op->bo_sm_grp);
+	m0_sm_group_fini(&op->bo_sm_grp);
+}
+
+M0_INTERNAL void m0_be_op_state_set(struct m0_be_op *op,
+				    enum m0_be_op_state state)
+{
+	m0_sm_group_lock(&op->bo_sm_grp);
+	m0_sm_state_set(&op->bo_sm, state);
+	m0_sm_group_unlock(&op->bo_sm_grp);
 }
 
 #undef M0_TRACE_SUBSYSTEM
diff --git a/be/be.h b/be/be.h
index 3ef4fd8..d9cc7f4 100644
--- a/be/be.h
+++ b/be/be.h
@@ -67,6 +67,7 @@ struct m0_be_op;
 struct m0_be_op {
 	struct m0_sm        bo_sm;
 	struct m0_fom      *bo_fom;
+	struct m0_sm_group  bo_sm_grp;	/** @todo XXX TODO remove it! */
 
 	enum m0_be_op_type  bo_utype; /* bo_u type */
 	struct m0_be_op    *bo_parent_op;
@@ -120,6 +121,8 @@ extern struct m0_be m0_be_instance;
 
 M0_INTERNAL void m0_be_op_init(struct m0_be_op *op);
 M0_INTERNAL void m0_be_op_fini(struct m0_be_op *op);
+M0_INTERNAL void m0_be_op_state_set(struct m0_be_op *op,
+				    enum m0_be_op_state state);
 
 /** @} end of be group */
 #endif /* __MERO_BE_BE_H__ */
diff --git a/be/ut/alloc.c b/be/ut/alloc.c
index c2b0c7f..55e59f5 100644
--- a/be/ut/alloc.c
+++ b/be/ut/alloc.c
@@ -99,6 +99,7 @@ M0_INTERNAL void m0_be_ut_alloc_create_destroy(void)
 static void be_ut_alloc_thread(int index)
 {
 	struct be_ut_alloc_thread_state *ts = &be_ut_ts[index];
+	struct m0_be_op			 op;
 	unsigned int			 seed = index;
 	m0_bcount_t			 size;
 	unsigned			 shift;
@@ -110,24 +111,29 @@ static void be_ut_alloc_thread(int index)
 	for (j = 0; j < ts->ats_nr; ++j) {
 		i = rand_r(&seed) % BE_UT_ALLOC_PTR_NR;
 		p = ts->ats_ptr[i];
+		m0_be_op_init(&op);
 		if (p == NULL) {
 			size = (rand_r(&seed) % BE_UT_ALLOC_SIZE) + 1;
 			shift = rand_r(&seed) % BE_UT_ALLOC_SHIFT;
-			p = m0_be_alloc(&be_ut_allocator, NULL, NULL, /* XXX */
+			p = m0_be_alloc(&be_ut_allocator, NULL, &op, /* XXX */
 					size, shift);
 			M0_UT_ASSERT(p != NULL);
 			M0_UT_ASSERT(m0_addr_is_aligned(p, shift));
 			if (p != NULL)
 				memset(p, 0xFF, size);
 		} else {
-			m0_be_free(&be_ut_allocator, NULL, NULL, /* XXX */ p);
+			m0_be_free(&be_ut_allocator, NULL, &op, /* XXX */ p);
 			p = NULL;
 		}
+		m0_be_op_fini(&op);
 		ts->ats_ptr[i] = p;
 	}
-	for (i = 0; i < BE_UT_ALLOC_PTR_NR; ++i)
-		m0_be_free(&be_ut_allocator, NULL, NULL, /* XXX */
+	for (i = 0; i < BE_UT_ALLOC_PTR_NR; ++i) {
+		m0_be_op_init(&op);
+		m0_be_free(&be_ut_allocator, NULL, &op, /* XXX */
 			   ts->ats_ptr[i]);
+		m0_be_op_fini(&op);
+	}
 }
 
 static void be_ut_alloc_mt(int nr)
-- 
1.8.3.2

