From f9d58465ca0685ff86c7a91ecc1a30a4b0717306 Mon Sep 17 00:00:00 2001
From: Alexander Gattin <alexander_gattin@xyratex.com>
Date: Thu, 14 Mar 2013 13:15:12 +0200
Subject: [PATCH 3/4] m0t1fs/rename: fix bugs in rename() implementation

* unlink target dirent if it has an inode attached
* set old_dentry->d_inode to NULL to avoid kernel crash
  on umount
* update nlink counts of old and new parent directories
  if the object being moved is a directory
* update ctime and mtime of old and new parent directories
  after successful m0t1fs_mds_cob_rename()
---
 m0t1fs/linux_kernel/dir.c | 77 +++++++++++++++++++++++++++++++++++++++--------
 1 file changed, 64 insertions(+), 13 deletions(-)

diff --git a/m0t1fs/linux_kernel/dir.c b/m0t1fs/linux_kernel/dir.c
index 376db93..d570b54 100644
--- a/m0t1fs/linux_kernel/dir.c
+++ b/m0t1fs/linux_kernel/dir.c
@@ -904,35 +904,86 @@ out:
 static int m0t1fs_rename(struct inode *old_dir, struct dentry *old_dentry,
 			 struct inode *new_dir, struct dentry *new_dentry)
 {
-	struct m0_fop_rename_rep *rename_rep;
-	struct m0t1fs_mdop        mo;
-	struct m0t1fs_inode      *oi    = M0T1FS_I(old_dir);
-	struct m0t1fs_inode      *ni    = M0T1FS_I(new_dir);
-	struct inode             *inode = old_dentry->d_inode;
-	struct m0t1fs_inode      *mi    = M0T1FS_I(inode);
-	struct m0t1fs_sb         *msb   = M0T1FS_SB(new_dir->i_sb);
-	int                       rc;
+	struct m0_fop_rename_rep  *rename_rep;
+	struct m0_fop_setattr_rep *setattr_rep;
+	struct m0t1fs_mdop         mo;
+	struct m0t1fs_inode       *oi    = M0T1FS_I(old_dir);
+	struct m0t1fs_inode       *ni    = M0T1FS_I(new_dir);
+	struct inode              *dir;
+	struct inode              *inode = old_dentry->d_inode;
+	struct m0t1fs_inode       *mi    = M0T1FS_I(inode);
+	struct m0t1fs_sb          *msb   = M0T1FS_SB(new_dir->i_sb);
+	struct timespec            now;
+	bool                       upd_nlink;
+	int                        rc;
+	int                        rc2;
 
 	m0t1fs_fs_lock(msb);
 
+	/* Remove target dirent if it exists. */
+	if (new_dentry->d_inode) {
+		rc = S_ISDIR(new_dentry->d_inode->i_mode) ?
+			m0t1fs_rmdir(new_dir, new_dentry) :
+		       	m0t1fs_unlink(new_dir, new_dentry);
+		if (rc != 0)
+			goto out;
+	}
+
 	M0_SET0(&mo);
-	mo.mo_attr.ca_tfid  = mi->ci_fid;
-	mo.mo_attr.ca_pfid  = oi->ci_fid;
-	mo.mo_newpfid       = ni->ci_fid;
-	mo.mo_attr.ca_valid = 0;
+	now = CURRENT_TIME_SEC;  
+	mo.mo_attr.ca_tfid   = mi->ci_fid;
+	mo.mo_attr.ca_pfid   = oi->ci_fid;
+	mo.mo_newpfid        = ni->ci_fid;
+	mo.mo_attr.ca_ctime  = now.tv_sec;
+	mo.mo_attr.ca_valid  = M0_COB_CTIME; /* ext2 updates inode ctime */
+	inode->i_ctime       = now;
 	m0_buf_init(&mo.mo_attr.ca_name, (char *)old_dentry->d_name.name,
 		    old_dentry->d_name.len);
 	m0_buf_init(&mo.mo_newname, (char *)new_dentry->d_name.name,
 		    new_dentry->d_name.len);
 
+	/* Rename dirent. */
 	rc = m0t1fs_mds_cob_rename(msb, &mo, &rename_rep);
 	if (rc != 0)
 		goto out;
 
-	d_instantiate(new_dentry, inode);
+	old_dentry->d_inode = NULL;        /* Detach inode from old dirent. */
+	d_instantiate(new_dentry, inode);  /* Attach inode to new dirent. */
 	mark_inode_dirty(old_dir);
 	mark_inode_dirty(new_dir);
 
+	/* If we move directory between [different] parents, nlink changes. */
+	upd_nlink = S_ISDIR(inode->i_mode) &&
+		!m0_fid_eq(&oi->ci_fid, &ni->ci_fid);
+
+	/* Update ctime and mtime on old and new parent dirs. */
+	for (dir = old_dir; ; dir = new_dir) {
+		M0_SET0(&mo);
+		mo.mo_attr.ca_tfid  = M0T1FS_I(dir)->ci_fid;
+		mo.mo_attr.ca_ctime = now.tv_sec;
+		mo.mo_attr.ca_mtime = now.tv_sec;
+		mo.mo_attr.ca_valid = (M0_COB_CTIME | M0_COB_MTIME);
+		dir->i_ctime = dir->i_mtime = now;
+		if (upd_nlink) {
+			if (dir == old_dir) {
+				mo.mo_attr.ca_nlink = dir->i_nlink - 1;
+				drop_nlink(dir);
+			} else {
+				mo.mo_attr.ca_nlink = dir->i_nlink + 1;
+				inc_nlink(dir);
+			}
+			mo.mo_attr.ca_valid |= M0_COB_NLINK;
+		}
+		rc2 = m0t1fs_mds_cob_setattr(msb, &mo, &setattr_rep);
+		if (rc != 0) {
+			M0_LOG(M0_ERROR, "Setattr on parent dir failed"
+			       " with %d", rc);
+			rc = rc2;
+		}
+		if (dir == new_dir)
+			break;
+	}
+
 out:
 	m0t1fs_fs_unlock(msb);
 	M0_RETURN(rc);
-- 
1.8.3.2

