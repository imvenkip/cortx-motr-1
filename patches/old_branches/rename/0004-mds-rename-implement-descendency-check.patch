From 46f39edeb2f25a28d11db7eb2d02f615b64aec7b Mon Sep 17 00:00:00 2001
From: Alexander Gattin <alexander_gattin@xyratex.com>
Date: Fri, 15 Mar 2013 12:41:00 +0200
Subject: [PATCH 4/4] mds/rename: implement descendency check

---
 mdservice/md_foms.c | 53 ++++++++++++++++++++++++++++++++++++++++++++---------
 1 file changed, 44 insertions(+), 9 deletions(-)

diff --git a/mdservice/md_foms.c b/mdservice/md_foms.c
index 1e59ffc..c7af8ed 100644
--- a/mdservice/md_foms.c
+++ b/mdservice/md_foms.c
@@ -411,6 +411,11 @@ static int m0_md_tick_rename(struct m0_fom *fom)
 	struct m0_db_tx          *tx;
 	struct m0_mdstore        *md;
 	int                       rc;
+        struct m0_fop_str        *spath;
+        struct m0_fop_str        *sname;
+        struct m0_fop_str        *tpath;
+        uint8_t                  *tprest;
+	uint32_t                  rlen;
 
 	rc = m0_md_tick_generic(fom);
 	if (rc != 0)
@@ -435,16 +440,46 @@ static int m0_md_tick_rename(struct m0_fom *fom)
 	if (rc != 0)
 		goto out;
 
-	/* After m0_md_fop_init we have r_spath and r_tpath, so we can
-	 * check that target path isn't descendant of source fid. */
-	M0_LOG(M0_DEBUG, "validating rename %.*s/%.*s to %.*s/%.*s",
-	       req->r_spath.s_len, req->r_spath.s_buf,
-	       req->r_sname.s_len, req->r_sname.s_buf,
-	       req->r_tpath.s_len, req->r_tpath.s_buf,
-	       req->r_tname.s_len, req->r_tname.s_buf
+	/* After m0_md_fop_init we have r_spath and r_tpath initialized,
+	 * now it's time to verify that tpath isn't descendant of spath/sname.
+	 * XXX: Linux VFS performs descendency check before calling
+	 * m0t1fs_rename(), so doing it here is kind of redundant. */
+	spath = &req->r_spath;
+	sname = &req->r_sname;
+	tpath = &req->r_tpath;
+	M0_LOG(M0_DEBUG, "checking whether %.*s/%.*s descends from %.*s/%.*s",
+	       tpath->s_len, tpath->s_buf, req->r_tname.s_len,
+	       req->r_tname.s_buf, spath->s_len, spath->s_buf, sname->s_len,
+	       sname->s_buf
 	      );
-	/* TODO: perform the check and return -EINVAL if tpath is
-	 * descendant of "spath/sname". */
+	/* Check that tpath doesn't start with spath. */
+	if (spath->s_len > tpath->s_len
+	    || memcmp(spath->s_buf, tpath->s_buf, spath->s_len) != 0)
+		goto nondescendant;
+	/* tpath starts with spath, so check the rest of tpath. */
+	tprest = tpath->s_buf + spath->s_len;  /* rest of tpath buffer */
+	rlen = tpath->s_len - spath->s_len;   /* length of the rest */
+	/* If spath doesn't end with '/', there must be '/' after the common
+	 * (matching) part in tpath. */
+	if (spath->s_buf[spath->s_len - 1] != '/') {
+		if (rlen == 0 || *tprest != '/')
+			goto nondescendant;
+		tprest++;
+		rlen--;
+	}
+	/* Check that rest doesn't start with sname. */
+	if (sname->s_len > rlen || memcmp(sname->s_buf,
+					  tprest, rlen) != 0)
+		goto nondescendant;
+	/* Distinguish betwen cases like
+	 *     1. spath=="/a/b", sname=="c", tpath=="/a/b/ccc",
+	 *     2. spath=="/a/b", sname=="c", tpath=="/a/b/c"
+	 * and 3. spath=="/a/b", sname=="c", tpath=="/a/b/c/d". */
+	if (sname->s_len == rlen || *tprest == '/') {
+		rc = -EINVAL;
+		goto out;
+	}
+nondescendant:
 
 	body = &req->r_body;
 
-- 
1.8.3.2

