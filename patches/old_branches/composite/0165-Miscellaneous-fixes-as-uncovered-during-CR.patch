From 770258254404629771bc642da0ca3b9692bd8ffd Mon Sep 17 00:00:00 2001
From: "trupti.patil" <trupti_patil@xyratex.com>
Date: Thu, 1 Aug 2013 18:05:43 +0530
Subject: [PATCH 165/172] Miscellaneous fixes as uncovered during CR

---
 layout/composite.c          | 89 ++++++++++++++++++++++++++-------------------
 layout/composite.h          | 45 ++++++++++++++++-------
 layout/composite_internal.h | 78 ---------------------------------------
 layout/layout.c             | 57 -----------------------------
 layout/linear_enum.c        |  2 +-
 layout/list_enum.c          |  2 +-
 layout/pdclust.c            |  5 +--
 layout/ut/composite.c       |  6 +--
 layout/ut/layout.c          |  2 +
 9 files changed, 93 insertions(+), 193 deletions(-)

diff --git a/layout/composite.c b/layout/composite.c
index fb6951c..ce9fe44 100644
--- a/layout/composite.c
+++ b/layout/composite.c
@@ -114,11 +114,17 @@ enum ext_add_position {
 	ADD_AT_TAIL
 };
 
-/** Flags used for better readability. */
 enum {
-	IN_UPDATE_PATH       = true,
-	EXT_MERGE_VALIDATION = 11,  /* Some random number other than 0 and 1. */
-	EXT_DEL_VALIDATION   = 12,  /* Another random number. */
+	/** Flag used for better readability. */
+	IN_UPDATE_PATH = true,
+	/**
+	 * Number of extents required to be preallocated during an
+	 * ext_paste() operation. It is 2 * 3 + 1 that is
+	 * "max_nr_of_split_operations_those_can_take_place *
+	 * max_nr_of_extents_required_for_one_split_op +
+	 * required_for_adding_the_ultimate_extent".
+	 */
+	PREALLOCATE_NR = 7
 };
 
 /**
@@ -346,9 +352,9 @@ static int layer_add_internal(struct m0_composite_layout *cl,
 	 * M0_CLRES_HOLE state, so as to mark the layer empty.
 	 */
 	ext_tlist_init(&layer->clr_extents);
-	ext->cle_ext.e_start = 0;
-	ext->cle_ext.e_end   = M0_BINDEX_MAX + 1;
-	ext->cle_state       = M0_CLRES_HOLE;
+	ext->cle_ext.e_start  = 0;
+	ext->cle_ext.e_end    = M0_BINDEX_MAX + 1;
+	ext->cle_state        = M0_CLRES_HOLE;
 	ext_tlink_init_at_tail(ext, &layer->clr_extents);
 
 	layer->clr_cl         = &cl->cl_base;
@@ -372,6 +378,7 @@ static int layer_add(struct m0_composite_layout *cl,
 	return layer_add_internal(cl, sublayout, lr);
 }
 
+/** Finalises the extent list. */
 static void extlist_fini(struct m0_tl *extlist)
 {
 	struct m0_composite_layer_ext *ext1;
@@ -526,31 +533,12 @@ M0_INTERNAL int m0_composite_layer_add(struct m0_composite_layout *cl,
 			       "Failed to add layer",
 			       M0_LAYOUT_ADDB_LOC_COMP_LAYER_ADD,
 			       &cl->cl_base.l_addb_ctx, cl->cl_base.l_id, rc);
-
 	m0_mutex_unlock(&cl->cl_base.l_lock);
 	M0_POST(composite_invariant(cl));
 	M0_POST(ergo(rc == 0, layer->clr_idx > 0 && cl->cl_layers_nr > 1));
 	M0_RETURN(rc);
 }
 
-/** Finds a layer with the given layer index. */
-static struct m0_composite_layer *layer_find(
-					const struct m0_composite_layout *cl,
-					uint32_t layer_idx)
-{
-	struct m0_composite_layer *layer;
-
-	M0_PRE(layer_idx < cl->cl_layers_nr);
-
-	m0_tl_for(layers, &cl->cl_layers, layer) {
-		if (layer->clr_idx == layer_idx)
-			break;
-	} m0_tl_endfor;
-	M0_POST(layer_invariant(layer));
-	M0_POST(layer->clr_idx == layer_idx);
-	return layer;
-}
-
 M0_INTERNAL void m0_composite_layer_delete(struct m0_composite_layout *cl)
 {
 	struct m0_composite_layer     *layer;
@@ -559,7 +547,8 @@ M0_INTERNAL void m0_composite_layer_delete(struct m0_composite_layout *cl)
 	M0_PRE(composite_invariant(cl));
 	M0_PRE(cl->cl_layers_nr > 1);
 
-	M0_ENTRY("lid %llu, layers_nr %lu", (unsigned long long)cl->cl_base.l_id,
+	M0_ENTRY("lid %llu, layers_nr %lu",
+		 (unsigned long long)cl->cl_base.l_id,
 		 (unsigned long)cl->cl_layers_nr);
 	m0_mutex_lock(&cl->cl_base.l_lock);
 	layer = layers_tlist_tail(&cl->cl_layers); /* The top-most layer. */
@@ -571,14 +560,16 @@ M0_INTERNAL void m0_composite_layer_delete(struct m0_composite_layout *cl)
 	layer_delete(cl, layer);
 	m0_mutex_unlock(&cl->cl_base.l_lock);
 	M0_POST(composite_invariant(cl));
+	M0_LEAVE();
 }
 
 M0_INTERNAL void m0_composite_layer_delete_second_from_top(
 					struct m0_composite_layout *cl)
 {
-	struct m0_composite_layer *top;
-	struct m0_composite_layer *second;
-	uint32_t                   layers_nr;
+	struct m0_composite_layer     *top;
+	struct m0_composite_layer     *second;
+	struct m0_composite_layer_ext *ext;
+	uint32_t                       layers_nr;
 
 	M0_PRE(composite_invariant(cl));
 	M0_PRE(cl->cl_layers_nr > 2);
@@ -590,14 +581,18 @@ M0_INTERNAL void m0_composite_layer_delete_second_from_top(
 	top = layers_tlist_tail(&cl->cl_layers); /* The top-most layer. */
 	second = layers_tlist_prev(&cl->cl_layers, top);
 	M0_ASSERT(second->clr_idx == cl->cl_layers_nr - 2);
-	M0_PRE(m0_tl_forall(ext, ext1, &second->clr_extents,
-			    ext1->cle_state == M0_CLRES_HOLE));
+	ext = ext_tlist_head(&second->clr_extents);
+	M0_PRE(second->clr_extents_nr == 1 &&
+	       ext->cle_ext.e_start == 0 &&
+	       ext->cle_ext.e_end == M0_BINDEX_MAX + 1 &&
+	       ext->cle_state == M0_CLRES_HOLE);
 	layers_nr = cl->cl_layers_nr;
 	layer_delete(cl, second);
 	M0_ASSERT(top->clr_idx == layers_nr - 1);
 	top->clr_idx = layers_nr - 2;
 	m0_mutex_unlock(&cl->cl_base.l_lock);
 	M0_POST(composite_invariant(cl));
+	M0_LEAVE();
 }
 
 /** Finds a sublayout with the given lid. */
@@ -641,7 +636,7 @@ err_injected:
  *
  * Sublayout identifiers for all the layers are stored in the primary table.
  *
- * @post Memory is allocated for the array sl_id_list and it shall be freed by
+ * @post Memory is allocated for the array sl_list and it shall be freed by
  * the caller.
  */
 static int sublayout_ids_read(struct m0_composite_layout *cl,
@@ -1608,6 +1603,24 @@ static int ext_write(struct m0_composite_layout *cl,
 	M0_RETURN(rc);
 }
 
+/** Finds a layer with the given layer index. */
+static struct m0_composite_layer *layer_find(
+					const struct m0_composite_layout *cl,
+					uint32_t layer_idx)
+{
+	struct m0_composite_layer *layer;
+
+	M0_PRE(layer_idx < cl->cl_layers_nr);
+
+	m0_tl_for(layers, &cl->cl_layers, layer) {
+		if (layer->clr_idx == layer_idx)
+			break;
+	} m0_tl_endfor;
+	M0_POST(layer_invariant(layer));
+	M0_POST(layer->clr_idx == layer_idx);
+	return layer;
+}
+
 M0_INTERNAL int m0_composite_layer_update(
 				struct m0_composite_layout *cl,
 				uint32_t layer_idx,
@@ -1664,13 +1677,15 @@ static m0_bcount_t composite_bufsize(const struct m0_layout *l)
 	cl = m0_layout_to_cl(l);
 	m0_tl_for(layers, &cl->cl_layers, layer) {
 		bufsize = bufsize +
-			(layer->clr_extents_nr * sizeof(struct layer_buf_ext));
+			  (layer->clr_extents_nr *
+			   sizeof(struct m0_layer_ext_onwire));
 	} m0_tl_endfor;
 
-	return sizeof(struct m0_layout_rec) +
-		sizeof(struct m0_layout_composite_rec) +
+	return sizeof(struct m0_layout_onwire) +
 		(cl->cl_layers_nr * (sizeof l->l_id +
-				     sizeof(struct layer_header))) + bufsize;
+				     sizeof(uint32_t) /* for layer index */ +
+				     sizeof(uint32_t) /* sublayout id */)) +
+		bufsize;
 }
 
 /* DB related routines start here. */
diff --git a/layout/composite.h b/layout/composite.h
index 195d6e1..cc80613 100644
--- a/layout/composite.h
+++ b/layout/composite.h
@@ -257,6 +257,26 @@ struct m0_composite_onwire {
 M0_BASSERT(M0_IS_8ALIGNED(sizeof(struct m0_composite_onwire)));
 
 /**
+ * Composite layout type specific part of the record for the layouts table.
+ *
+ * @note This structure needs to be maintained as 8 bytes aligned.
+ */
+struct m0_layout_composite_rec {
+	/** Total number of layers in a specific composite layout. */
+	uint32_t cr_layers_nr;
+
+	/** Padding to make the structure 8 bytes aligned. */
+	uint32_t cr_pad;
+
+	/**
+	 * Composite layout type specific payload. It contains sublayout
+	 * identifiers for the cr_layers_nr number of layers.
+	 */
+	char     cr_data[0];
+};
+M0_BASSERT(M0_IS_8ALIGNED(sizeof(struct m0_layout_composite_rec)));
+
+/**
  * Composite layout instance for a particular file.
  *
  * Inode from client filesystem stores pointer to the generic layout instance.
@@ -316,8 +336,8 @@ enum {
  * @post A reference has been added to the sublayout.
  *
  * @note When this layer gets added to the DB version of the layout (through
- * the DB update made through the m0_layout_add() or the m0_layout_update() API),
- * user count for the sublayout is incremented by one.
+ * the DB update made through the m0_layout_add() or the m0_layout_update()
+ * API), user count for the sublayout is incremented by one.
  */
 M0_INTERNAL int m0_composite_layer_add(struct m0_composite_layout *cl,
 				       struct m0_layout *sublayout);
@@ -328,26 +348,26 @@ M0_INTERNAL int m0_composite_layer_add(struct m0_composite_layout *cl,
  * any non-hole extents'.
  *
  * @pre cl->cl_layers_nr > 1
- * @pre layer being the topmost layer, layer->clr_extents_nr == 1
- * @pre ext_tlist_head(&layer->clr_extents)->cle_ext.e_start == 0
- * @pre ext_tlist_head(&layer->clr_extents)->cle_ext.e_end == M0_BINDEX_MAX + 1
- * @pre ext_tlist_head(&layer->clr_extents)->cle_state == M0_CLRES_HOLE
+ * 'layer' being the topmost layer and 'ext' being the only ext from the layer,
+ * @pre layer->clr_extents_nr == 1
+ * @pre ext->cle_ext.e_start == 0
+ * @pre ext->cle_ext.e_end == M0_BINDEX_MAX + 1
+ * @pre ext->cle_state == M0_CLRES_HOLE
  *
  * @post A reference has been released from the sublayout associated with the
- *       top-most layer.
+ * top-most layer.
  *
  * @note When this layer gets deleted from the DB version of the layout (through
- *       the DB update made through the m0_layout_add() or
- *       the m0_layout_update() API), user count for the sublayout is
- *       decremented by one.
+ * the DB update made through the m0_layout_add() or the m0_layout_update()
+ * API), user count for the sublayout is decremented by one.
  */
 M0_INTERNAL void m0_composite_layer_delete(struct m0_composite_layout *cl);
 
 /**
  * Deletes 'the second from the top layer' and re-indexes the top-most layer
  * as the second from the top (now the top-most).
- * This API is to be used during flattening in cases when 'the second from the top
- * layer' becomes empty and is to be removed.
+ * This API is to be used during flattening in cases when 'the second from the
+ * top layer' becomes empty and is to be removed.
  */
 M0_INTERNAL void m0_composite_layer_delete_second_from_top(
 					struct m0_composite_layout *cl);
@@ -378,7 +398,6 @@ M0_INTERNAL int m0_composite_layer_ext_lookup(
 				struct m0_composite_layer **layer);
 
 /**
- * todo revise as per the change in the reqt
  * Adds an extent with the specified state to the specified layer of the
  * specified composite layout. This API may be used to add extents, to delete
  * those (to add with the M0_CLRES_HOLE state) or to update their state, for
diff --git a/layout/composite_internal.h b/layout/composite_internal.h
index 66d1e09..e9ffe3b 100644
--- a/layout/composite_internal.h
+++ b/layout/composite_internal.h
@@ -40,84 +40,6 @@ struct m0_composite_layer;
 M0_TL_DECLARE(layers, M0_INTERNAL, struct m0_composite_layer);
 M0_TL_DECLARE(ext, M0_INTERNAL, struct m0_composite_layer_ext);
 
-
-/**
- * Composite layout type specific part of the record for the layouts table.
- *
- * @note This structure needs to be maintained as 8 bytes aligned.
- */
-struct m0_layout_composite_rec {
-	/** Total number of layers in a specific composite layout. */
-	uint32_t cr_layers_nr;
-
-	/** Padding to make the structure 8 bytes aligned. */
-	uint32_t cr_pad;
-
-	/**
-	 * Composite layout type specific payload.
-	 * Contains sublayout identifiers for the cr_layers_nr number of
-	 * layers.
-	 */
-	char     cr_data[0];
-};
-M0_BASSERT(M0_IS_8ALIGNED(sizeof(struct m0_layout_composite_rec)));
-
-/**
- * Structure used to store header information for 'a layer of a composite
- * layout' like the number of extents in it. It is used in the buffer
- * representation of a composite layout.
- *
- * @note This structure needs to be maintained as 8 bytes aligned.
- */
-struct layer_header {
-	/** Index of this layer into its owner composite layout. */
-	uint32_t clh_idx;
-
-	/**
-	 * Number of extents belonging to the layer corresponding to this
-	 * header.
-	 */
-	uint32_t clh_extents_nr;
-
-	/**
-	 * Payload storing list of the extents (struct m0_ext) for a specific
-	 * layer.
-	 */
-	char     clh_extents[0];
-
-};
-M0_BASSERT(M0_IS_8ALIGNED(sizeof(struct layer_header)));
-
-/**
- * Structure used to store extents for 'a layer of a composite
- * layout'. It is used in the buffer representation of a composite layout.
- *
- * It is assumed that the first extent starts with the offset 0 and hence,
- * extent start offset is avoided to be stored in the buffer representation
- * of the extents.
- *
- * @note This structure needs to be maintained as 8 bytes aligned.
- */
-struct layer_buf_ext {
-	/** Extent end offset. */
-	m0_bindex_t lbe_end;
-
-	/* Extent state. */
-	uint64_t    lbe_state;
-};
-M0_BASSERT(M0_IS_8ALIGNED(sizeof(struct layer_buf_ext)));
-
-enum {
-	/**
-	 * Number of extents required to be preallocated during an
-	 * ext_paste() operation. It is 2 * 3 + 1 that is
-	 * "max_nr_of_split_operations_those_can_take_place *
-	 * max_nr_of_extents_required_for_one_split_op +
-	 * required_for_adding_the_ultimate_extent".
-	 */
-	PREALLOCATE_NR = 7
-};
-
 /** @} end group layout */
 
 /* __MERO_LAYOUT_COMPOSITE_INTERNAL_H__ */
diff --git a/layout/layout.c b/layout/layout.c
index 0083bf9..ede0bf9 100644
--- a/layout/layout.c
+++ b/layout/layout.c
@@ -1071,63 +1071,6 @@ M0_INTERNAL void m0_layout_user_count_dec(struct m0_layout *l)
 	M0_LEAVE("lid %llu", (unsigned long long)l->l_id);
 }
 
-#if 0
-M0_INTERNAL int m0_layout_decode(struct m0_layout *l,
-				 struct m0_bufvec_cursor *cur,
-				 enum m0_layout_xcode_op op,
-				 struct m0_db_tx *tx)
-{
-	struct m0_layout_rec *rec;
-	int                   rc;
-
-	M0_PRE(m0_layout__allocated_invariant(l));
-	M0_PRE(m0_mutex_is_locked(&l->l_lock));
-	M0_PRE(list_lookup(l->l_dom, l->l_id) == NULL);
-	M0_PRE(cur != NULL);
-	M0_PRE(m0_bufvec_cursor_step(cur) >= sizeof *rec);
-	M0_PRE(M0_IN(op, (M0_LXO_DB_LOOKUP, M0_LXO_BUFFER_OP)));
-	M0_PRE(ergo(op == M0_LXO_DB_LOOKUP, tx != NULL));
-
-	M0_ENTRY("lid %llu", (unsigned long long)l->l_id);
-
-	rec = m0_bufvec_cursor_addr(cur);
-	/* Move the cursor to point to the layout type specific payload. */
-	m0_bufvec_cursor_move(cur, sizeof *rec);
-	/*
-	 * It is fine if any of the layout does not contain any data in
-	 * rec->lr_data[], unless it is required by the specific layout type,
-	 * which will be caught by the respective lo_decode() implementation.
-	 * Hence, ignoring the return status of m0_bufvec_cursor_move() here.
-	 */
-
-	if (M0_FI_ENABLED("attr_err"))
-		{ rec->lr_lt_id = M0_LAYOUT_TYPE_MAX + 1; }
-	if (!IS_IN_ARRAY(rec->lr_lt_id, l->l_dom->ld_type)) {
-		m0_layout__log("m0_layout_decode", "Invalid layout type",
-			       M0_LAYOUT_ADDB_LOC_DECODE_1,
-			       &l->l_addb_ctx, l->l_id, -EPROTO);
-		return -EPROTO;
-	}
-	M0_ASSERT(rec->lr_lt_id == l->l_type->lt_id);
-
-	if (M0_FI_ENABLED("lo_decode_err"))
-		{ rc = LO_DECODE_ERR; goto err1_injected; }
-	rc = l->l_ops->lo_decode(l, cur, op, tx, rec->lr_user_count);
-err1_injected:
-	if (rc != 0)
-		m0_layout__log("m0_layout_decode", "lo_decode() failed",
-			       M0_LAYOUT_ADDB_LOC_DECODE_2, &l->l_addb_ctx,
-			       l->l_id, rc);
-
-	M0_POST(ergo(rc == 0, m0_layout__invariant(l) &&
-		     list_lookup(l->l_dom, l->l_id) == l));
-	M0_POST(ergo(rc != 0, m0_layout__allocated_invariant(l)));
-	M0_POST(m0_mutex_is_locked(&l->l_lock));
-	M0_LEAVE("lid %llu, rc %d", (unsigned long long)l->l_id, rc);
-	return rc;
-}
-#endif
-
 void m0_layout__copy_to_onwire(const struct m0_layout *l,
 			       struct m0_layout_onwire *onwire)
 {
diff --git a/layout/linear_enum.c b/layout/linear_enum.c
index 3921ac3..247ee47 100644
--- a/layout/linear_enum.c
+++ b/layout/linear_enum.c
@@ -370,7 +370,7 @@ static m0_bcount_t linear_recsize(struct m0_layout_enum *e)
 /** Implementation of leo_bufsize() for linear enumeration type. */
 static m0_bcount_t linear_bufsize(struct m0_layout_enum *e)
 {
-	return sizeof(struct m0_layout_linear_attr);
+	return sizeof(struct m0_layout_linear_enum_onwire);
 }
 
 static const struct m0_layout_enum_ops linear_enum_ops = {
diff --git a/layout/list_enum.c b/layout/list_enum.c
index 514e411..d601422 100644
--- a/layout/list_enum.c
+++ b/layout/list_enum.c
@@ -783,7 +783,7 @@ static m0_bcount_t list_bufsize(struct m0_layout_enum *e)
 
 	M0_PRE(e != NULL);
 	list_enum = enum_to_list_enum(e);
-	return sizeof(struct cob_entries_header) +
+	return sizeof(uint32_t) + /* For m0_layout_list_cobs_array::llca_nr */
 		list_enum->lle_nr * sizeof(struct m0_fid);
 }
 
diff --git a/layout/pdclust.c b/layout/pdclust.c
index 2fbb759..a9c32d1 100644
--- a/layout/pdclust.c
+++ b/layout/pdclust.c
@@ -648,11 +648,10 @@ static m0_bcount_t pdclust_bufsize(const struct m0_layout *l)
 	struct m0_layout_enum    *e;
 
 	M0_PRE(l != NULL);
+
 	stl = m0_layout_to_striped(l);
 	e = m0_striped_layout_to_enum(stl);
-	return sizeof(struct m0_layout_rec) +
-		sizeof(struct m0_layout_pdclust_rec) +
-		e->le_ops->leo_bufsize(e);
+	return sizeof(struct m0_pdclust_onwire) + e->le_ops->leo_bufsize(e);
 }
 
 /**
diff --git a/layout/ut/composite.c b/layout/ut/composite.c
index 3258acf..c28176a 100644
--- a/layout/ut/composite.c
+++ b/layout/ut/composite.c
@@ -1310,9 +1310,9 @@ static void composite_layout_compare(const struct m0_layout *l1,
 	m0_tl_for(layers, &cl1->cl_layers, layer1) {
 		/*
 		 * Can not check layer1->clr_l->l_id or layer2->clr_l->l_id
-		 * since layer1->clr_cl or layer1->clr_cl that is the composite
-		 * layout might be deleted and recreated e.g. say by reading it
-		 * from DB.
+		 * since layer1->clr_cl or layer2->clr_cl that is the composite
+		 * layouts might be deleted and recreated e.g. say by reading
+		 * those from DB.
 		 * M0_UT_ASSERT(layer1->clr_cl->l_id == cl2->cl_base.l_id);
 		 */
 		M0_UT_ASSERT(layer1->clr_sl == layer2->clr_sl);
diff --git a/layout/ut/layout.c b/layout/ut/layout.c
index 8276937..11408da 100644
--- a/layout/ut/layout.c
+++ b/layout/ut/layout.c
@@ -1165,6 +1165,8 @@ static void test_enum_operations(void)
 	M0_UT_ASSERT(rc == 0);
 }
 
+//todo Add TC for m0_layout_bufsize(). Use xcode size to verify the values.
+
 /** Tests the API m0_layout_max_recsize(). */
 static void test_max_recsize(void)
 {
-- 
1.8.3.2

