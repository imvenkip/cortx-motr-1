From b831e91fbe18ff4746da245bbaddac505665f17b Mon Sep 17 00:00:00 2001
From: "trupti.patil" <trupti_patil@xyratex.com>
Date: Thu, 14 Mar 2013 16:30:10 +0530
Subject: [PATCH 087/172] Changing layer_invariant to use m0_tl_forall()
 instead of m0_tl_for()

---
 layout/composite.c    | 38 +++++++++++++++-----------------------
 layout/ut/composite.c | 31 +++++++++++++++++++------------
 layout/ut/layout.c    | 22 ++++++++++++++++++++--
 3 files changed, 54 insertions(+), 37 deletions(-)

diff --git a/layout/composite.c b/layout/composite.c
index c622785..3d17a9d 100644
--- a/layout/composite.c
+++ b/layout/composite.c
@@ -228,33 +228,25 @@ static bool composite_invariant(const struct m0_composite_layout *cl)
 
 /**
  * Verifies that all the extents are back-to-back and that they cover
- * the entire namespace from 0 to M0_BINDEX_MAX.
+ * the entire offset namespace that is from 0 to M0_BINDEX_MAX.
  */
 static bool layer_invariant(const struct m0_composite_layer *layer)
 {
-	struct m0_composite_layer_extent *lr_ext;
-	m0_bindex_t                       addr = 0;
-	uint32_t                          i = 0;
-
-	if (layer->clr_extents_nr !=
-	    m0_composite_layer_ext_tlist_length(&layer->clr_extents))
-		return false;
+	uint32_t    i = 0;
+	m0_bindex_t addr = 0;
 
-	/*
-	 * Since assignment can not be performed in between a m0_tl_forall()
-	 * loop, it has not been used in this invariant.
-	 */
-	m0_tl_for(m0_composite_layer_ext, &layer->clr_extents, lr_ext) {
-		M0_ASSERT(lr_ext->cle_ext.e_start == addr);
-		addr = lr_ext->cle_ext.e_end;
-		if (i == 0 && lr_ext->cle_ext.e_start != 0)
-			return false;
-		if (i == layer->clr_extents_nr - 1 &&
-		    lr_ext->cle_ext.e_end != M0_BINDEX_MAX + 1)
-			return false;
-		++i;
-	} m0_tl_endfor;
-	return true;
+	return
+		layer->clr_extents_nr ==
+		m0_composite_layer_ext_tlist_length(&layer->clr_extents) &&
+		m0_tl_forall(m0_composite_layer_ext, lr_ext,
+			     &layer->clr_extents,
+			     lr_ext->cle_ext.e_start == addr &&
+			     /* Intentional '=' below. */
+			     (addr = lr_ext->cle_ext.e_end) &&
+			     ergo(i == 0, lr_ext->cle_ext.e_start == 0) &&
+			     ergo(i == layer->clr_extents_nr - 1,
+				  lr_ext->cle_ext.e_end == M0_BINDEX_MAX + 1) &&
+			     ++i);
 }
 
 static bool composite_instance_invariant(
diff --git a/layout/ut/composite.c b/layout/ut/composite.c
index e81015e..3a6cb81 100644
--- a/layout/ut/composite.c
+++ b/layout/ut/composite.c
@@ -568,6 +568,10 @@ int test_build_composite(uint64_t lid,
 		l = m0_layout_find(domain, lid);
 		M0_UT_ASSERT(l == &cl->cl_base);
 
+		/* Verify the layout object built earlier here. */
+		composite_layout_verify(l, lid, layers_nr, min_extents_nr,
+					if_contiguous_extents);
+
 		/* Reduce the reference acquired by m0_layout_find(). */
 		m0_layout_put(&cl->cl_base);
 
@@ -1837,22 +1841,27 @@ int test_lookup_composite(uint64_t lid,
 			  bool existing_test,
 			  bool failure_test)
 {
-	struct m0_layout  *l1;
-	struct m0_layout  *l1_copy;
-	struct m0_layout  *l2;
-	struct m0_layout  *l3;
-	int                rc;
+	struct m0_composite_layout *cl;
+	struct m0_layout           *l1;
+	struct m0_layout           *l1_copy;
+	struct m0_layout           *l2;
+	struct m0_layout           *l3;
+	int                         rc;
 
 	M0_UT_ASSERT(ergo(!existing_test, failure_test));
 
 	/* If existing_test is true, first add a layout object to the DB. */
 	if (existing_test) {
-		rc = test_add_composite(lid, domain, layers_nr,
-					min_extents_nr, if_contiguous_extents,
-					!LAYOUT_DESTROY, &l1,
-					!DUPLICATE_TEST, !FAILURE_TEST,
-					!LAYER_ADD_FAILURE_TEST);
+		/* Build a layout object, add layers to it, add it ot the DB. */
+		rc = composite_build_and_layers_add(lid, domain, layers_nr,
+						    min_extents_nr,
+						    if_contiguous_extents,
+						    ADD_TO_DB,
+						    !FAILURE_TEST,
+						    !LAYER_ADD_FAILURE_TEST,
+						    &cl);
 		M0_UT_ASSERT(rc == 0);
+		l1 = m0_cl_to_layout(cl);
 
 		if (!failure_test)
 			composite_layout_copy(l1, &l1_copy);
@@ -1901,7 +1910,6 @@ int test_lookup_composite(uint64_t lid,
 
 	return rc;
 }
-#endif
 
 /* Tests the API m0_layout_add(), for the COMPOSITE layout type. */
 int test_add_composite(uint64_t lid,
@@ -1987,7 +1995,6 @@ int test_add_composite(uint64_t lid,
 	return rc;
 }
 
-#ifndef __KERNEL__
 /* Tests the API m0_layout_update(), for the COMPOSITE layout type. */
 int test_update_composite(uint64_t lid,
 			  struct m0_layout_domain *domain,
diff --git a/layout/ut/layout.c b/layout/ut/layout.c
index 974e279..537f3c6 100644
--- a/layout/ut/layout.c
+++ b/layout/ut/layout.c
@@ -465,10 +465,28 @@ static void test_build(void)
 	M0_UT_ASSERT(rc == 0);
 
 	/*
+	 * Build a layout object with COMPOSITE layout type, such that no layer
+	 * is added explicitly to it, meaning with only 1 layer and destroy it.
+	 */
+	lid = 1021;
+	rc = test_build_composite(lid, &domain, 1, 10,
+				  CONTIGUOUS_EXTENTS, !FAILURE_TEST);
+	M0_UT_ASSERT(rc == 0);
+
+	/*
+	 * Build a layout object with COMPOSITE layout type, such that its
+	 * layers contain only 1 single extent and destroy it.
+	 */
+	lid = 1022;
+	rc = test_build_composite(lid, &domain, 2, 1,
+				  CONTIGUOUS_EXTENTS, !FAILURE_TEST);
+	M0_UT_ASSERT(rc == 0);
+
+	/*
 	 * Build a layout object with COMPOSITE layout type, with contiguous
 	 * extents in its layers and destroy it.
 	 */
-	lid = 1021;
+	lid = 1023;
 	rc = test_build_composite(lid, &domain, 5, 10,
 				  CONTIGUOUS_EXTENTS, !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
@@ -477,7 +495,7 @@ static void test_build(void)
 	 * Build a layout object with COMPOSITE layout type, with noncontiguous
 	 * extents in its layers and destroy it.
 	 */
-	lid = 1022;
+	lid = 1024;
 	rc = test_build_composite(lid, &domain, 5, 11,
 				  !CONTIGUOUS_EXTENTS, !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
-- 
1.8.3.2

