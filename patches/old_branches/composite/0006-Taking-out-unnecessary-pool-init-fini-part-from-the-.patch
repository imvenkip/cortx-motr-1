From e424d6eb8982bf73cc27eea94284706cd516bdba Mon Sep 17 00:00:00 2001
From: "trupti.patil" <trupti_patil@xyratex.com>
Date: Fri, 19 Oct 2012 15:14:17 +0530
Subject: [PATCH 006/172] Taking out unnecessary pool init-fini part from the
 UT

---
 layout/composite.c |  26 +++++---
 layout/ut/layout.c | 182 +++++++++++++++++++++++------------------------------
 2 files changed, 94 insertions(+), 114 deletions(-)

diff --git a/layout/composite.c b/layout/composite.c
index f9f804d..1f443a6 100644
--- a/layout/composite.c
+++ b/layout/composite.c
@@ -202,8 +202,11 @@ int c2_composite_build(struct c2_layout_domain *dom,
 
 	/*
 	 * Validate the sub-layouts list ensuring that each sub-layout is
-	 * cached and add a reference to each sub-layout. The reference added
-	 * here by c2_layout_find() will be released by composite_fini().
+	 * cached.
+	 * Add a reference to each sub-layout (done internally by
+	 * c2_layout_find()) and increment user count of each sub-layout. The
+	 * addition of reference and incrementing if user count will be undone
+	 * composite_fini().
 	 */
 	c2_tl_for(c2_sub_layout, sub_layouts, sl) {
 		C2_ASSERT(c2_layout__invariant(sl->csl_l));
@@ -213,10 +216,12 @@ int c2_composite_build(struct c2_layout_domain *dom,
 				       "sub-layout not found in cache",
 				       &c2_addb_oom, &sl->csl_l->l_addb,
 				       sl->csl_l->l_id, -EPROTO);
-			/* todo Undo ref added to some sub-layouts. */
+			/* todo Undo ref and user count added to some
+			 * sub-layouts. */
 			return -EPROTO;
 		}
 		C2_ASSERT(l == sl->csl_l);
+		c2_layout_user_count_inc(sl->csl_l);
 		++sublayouts_nr;
 	} c2_tl_endfor;
 
@@ -227,7 +232,7 @@ int c2_composite_build(struct c2_layout_domain *dom,
 		cl = bob_of(l, struct c2_composite_layout, cl_base,
 			    &composite_bob);
 		C2_ASSERT(composite_allocated_invariant(cl));
-		composite_populate(cl, sub_layouts, sublayouts_nr, 1);
+		composite_populate(cl, sub_layouts, sublayouts_nr, 0);
 		*out = cl;
 		c2_mutex_unlock(&l->l_lock);
 	} else {
@@ -242,7 +247,6 @@ int c2_composite_build(struct c2_layout_domain *dom,
 }
 
 /** Implementation of lo_fini for COMPOSITE layout type. */
-//static void composite_fini(struct c2_ref *ref) todo
 static void composite_fini(struct c2_ref *ref)
 {
 	struct c2_layout               *l;
@@ -257,7 +261,7 @@ static void composite_fini(struct c2_ref *ref)
 	c2_composite_layout_bob_fini(cl);
 
 	c2_tl_for(c2_sub_layout, cl->cl_sub_layouts, sl) {
-		//todo c2_layout_user_count_inc(sl->csl_l);
+		c2_layout_user_count_dec(sl->csl_l);
 		/*
 		 * Release the reference acquired either by c2_composite_build()
 		 * or by c2_layout_decode().
@@ -398,8 +402,9 @@ static int composite_decode(struct c2_layout *l,
 		}
 
 		/*
-		 * The reference acquired here by c2_layout_find() on each
-		 * sub-layout will be released by composite_fini().
+		 * The reference acquired here using c2_layout_find() and the
+		 * addition of user count on each  sub-layout will be undoen
+		 * by composite_fini().
 		 */
 		sl->csl_l = c2_layout_find(cl->cl_base.l_dom,
 					   sl_entry->sle_lid);
@@ -407,12 +412,13 @@ static int composite_decode(struct c2_layout *l,
 			C2_LOG(C2_ERROR, "sub-layout-lid %llu, sub-layout not "
 			       "found in the cache, rc %d",
 			       (unsigned long long)sl_entry->sle_lid, -EPROTO);
-			/* todo Undo in case ref is taken on some sub-layouts
-			 * and undo C2_ALLOC_PTR(sl) and
+			/* todo Undo in case ref is taken on some sub-layouts,
+			 * user count addition and undo C2_ALLOC_PTR(sl) and
 			 * c2_sub_layout_tlink_init_at(). */
 			return -EPROTO;
 		}
 
+		c2_layout_user_count_inc(sl->csl_l);
 		sl->csl_ext.e_start = sl_entry->sle_ext.e_start;
 		sl->csl_ext.e_end = sl_entry->sle_ext.e_end;
 		c2_sub_layout_tlink_init_at(sl, sub_layouts);
diff --git a/layout/ut/layout.c b/layout/ut/layout.c
index a387eab..5762156 100644
--- a/layout/ut/layout.c
+++ b/layout/ut/layout.c
@@ -34,7 +34,6 @@
 
 #include "lib/finject.h"
 
-#include "pool/pool.h"                   /* c2_pool_init(), c2_pool_fini() */
 #include "fid/fid.h"                     /* c2_fid_set() */
 #include "layout/layout.h"
 #include "layout/layout_internal.h"      /* LDB_MAX_INLINE_COB_ENTRIES, *_ERR */
@@ -48,7 +47,6 @@
 static struct c2_dbenv         dbenv;
 static const char              db_name[] = "ut-layout";
 static struct c2_layout_domain domain;
-static struct c2_pool          pool;
 enum c2_addb_ev_level          orig_addb_level;
 static int                     rc;
 
@@ -68,7 +66,8 @@ enum {
 	DUPLICATE_TEST           = true, /* Try to re-add a layout */
 	FAILURE_TEST             = true, /* Failure injected */
 	LAYOUT_DESTROY           = true, /* Delete layout object */
-	UNIT_SIZE                = 4096  /* For pdclust layout type */
+	UNIT_SIZE                = 4096, /* For pdclust layout type */
+	USER_COUNT_INCREMENTED   = true
 };
 
 extern struct c2_layout_type c2_pdclust_layout_type;
@@ -604,10 +603,14 @@ static int pdclust_layout_build(uint32_t enum_id,
 }
 
 /* Verifies generic part of the layout object. */
-static void l_verify(struct c2_layout *l, uint64_t lid)
+static void l_verify(struct c2_layout *l,
+		     uint64_t lid,
+		     bool if_user_count_incremented)
 {
 	C2_UT_ASSERT(l->l_id == lid);
-	C2_UT_ASSERT(c2_ref_read(&l->l_ref) >= 0); //todo Check if 1
+	C2_UT_ASSERT(c2_ref_read(&l->l_ref) >= 1);
+	C2_UT_ASSERT(ergo(if_user_count_incremented, l->l_user_count > 0));
+	C2_UT_ASSERT(ergo(!if_user_count_incremented, l->l_user_count == 0));
 	C2_UT_ASSERT(l->l_ops != NULL);
 }
 
@@ -618,10 +621,11 @@ static void l_verify(struct c2_layout *l, uint64_t lid)
 static void pdclust_l_verify(struct c2_pdclust_layout *pl,
 			     uint64_t lid,
 			     uint32_t N, uint32_t K, uint32_t P,
-			     struct c2_uint128 *seed)
+			     struct c2_uint128 *seed,
+			     bool if_user_count_incremented)
 {
 	/* Verify generic part of the layout object. */
-	l_verify(&pl->pl_base.sl_base, lid);
+	l_verify(&pl->pl_base.sl_base, lid, if_user_count_incremented);
 
 	/* Verify PDCLUST layout type specific part of the layout object. */
 	C2_UT_ASSERT(pl->pl_base.sl_base.l_type == &c2_pdclust_layout_type);
@@ -637,7 +641,8 @@ static void pdclust_layout_verify(uint32_t enum_id,
 				  struct c2_layout *l, uint64_t lid,
 				  uint32_t N, uint32_t K, uint32_t P,
 				  struct c2_uint128 *seed,
-				  uint32_t A, uint32_t B)
+				  uint32_t A, uint32_t B,
+				  bool if_user_count_incremented)
 {
 	struct c2_pdclust_layout     *pl;
 	struct c2_layout_list_enum   *list_enum;
@@ -655,7 +660,7 @@ static void pdclust_layout_verify(uint32_t enum_id,
 	 * Verify generic and PDCLUST layout type specific parts of the
 	 * layout object.
 	 */
-	pdclust_l_verify(pl, lid, N, K, P, seed);
+	pdclust_l_verify(pl, lid, N, K, P, seed, if_user_count_incremented);
 
 	/* Verify enum type specific part of the layout object. */
 	C2_UT_ASSERT(pl->pl_base.sl_enum != NULL);
@@ -729,23 +734,6 @@ static void NKP_assign(uint32_t enum_id,
 		*N = *P - (2 * (*K)) - 100;
 }
 
-/* todo Remove the pool init and fini part from this test suite. */
-static void NKP_assign_and_pool_init(uint32_t enum_id,
-				     uint32_t inline_test,
-				     uint32_t list_nr_less,
-				     uint32_t list_nr_more,
-				     uint32_t linear_nr,
-				     uint32_t *N, uint32_t *K, uint32_t *P)
-{
-	NKP_assign(enum_id, inline_test,
-		   list_nr_less, list_nr_more, linear_nr,
-		   N, K, P);
-
-	/* Initialise the pool. */
-	rc = c2_pool_init(&pool, *P);
-	C2_UT_ASSERT(rc == 0);
-}
-
 /*
  * Tests the APIs supported for enumeration object build, layout object build
  * and layout destruction that happens using c2_layout_put(). Verifies that the
@@ -769,9 +757,9 @@ static int test_build_pdclust(uint32_t enum_id, uint64_t lid,
 
 	c2_uint128_init(&seed, "buildpdclustlayo");
 
-	NKP_assign_and_pool_init(enum_id,
-				 inline_test, 9, 109, 12000,
-				 &N, &K, &P);
+	NKP_assign(enum_id,
+		   inline_test, 9, 109, 12000,
+		   &N, &K, &P);
 
 	rc = pdclust_layout_build(enum_id, lid,
 				  N, K, P, &seed,
@@ -792,7 +780,7 @@ static int test_build_pdclust(uint32_t enum_id, uint64_t lid,
 		/* Verify the layout object built earlier here. */
 		pdclust_layout_verify(enum_id, &pl->pl_base.sl_base, lid,
 				      N, K, P, &seed,
-				      10, 20);
+				      10, 20, !USER_COUNT_INCREMENTED);
 		/* Release the reference that c2_layout_find() has acquired. */
 		c2_layout_put(&pl->pl_base.sl_base);
 
@@ -801,12 +789,15 @@ static int test_build_pdclust(uint32_t enum_id, uint64_t lid,
 		C2_UT_ASSERT(list_lookup(lid) == NULL);
 	}
 
-	c2_pool_fini(&pool);
 	return rc;
 }
 
+/*
+ * Builds num_sublayouts number of sub-layouts and stores those in
+ * sub_layout_list.
+ */
 static void sub_layouts_build(uint64_t composite_lid,
-			      struct c2_tl *sub_layout_list,
+			      struct c2_tl **sub_layout_list,
 			      uint32_t num_sublayouts,
 			      c2_bindex_t end_offset)
 {
@@ -824,7 +815,11 @@ static void sub_layouts_build(uint64_t composite_lid,
 	uint32_t                        i;
 	c2_bindex_t                     delta = end_offset / num_sublayouts;
 
-	C2_UT_ASSERT(c2_sub_layout_tlist_is_empty(sub_layout_list));
+	/* Initialise a c2_tl for storing the sub-layouts to be built. */
+	C2_ALLOC_PTR(*sub_layout_list);
+	C2_UT_ASSERT(*sub_layout_list != NULL);
+	c2_sub_layout_tlist_init(*sub_layout_list);
+	C2_UT_ASSERT(c2_sub_layout_tlist_is_empty(*sub_layout_list));
 
 	c2_uint128_init(&seed, "sub_layouts_buil");
 	for (i = 0; i < num_sublayouts; ++i) {
@@ -847,8 +842,10 @@ static void sub_layouts_build(uint64_t composite_lid,
 		sub_layout->csl_ext.e_start = i * delta;
 		sub_layout->csl_ext.e_end   = sub_layout->csl_ext.e_start +
 					      delta - 1;
-		c2_sub_layout_tlink_init_at(sub_layout, sub_layout_list);
+		c2_sub_layout_tlink_init_at(sub_layout, *sub_layout_list);
 	}
+
+	C2_UT_ASSERT(!c2_sub_layout_tlist_is_empty(*sub_layout_list));
 }
 
 static void composite_layout_verify(struct c2_layout *l,
@@ -872,7 +869,7 @@ static void composite_layout_verify(struct c2_layout *l,
 	C2_UT_ASSERT(l->l_type == &c2_composite_layout_type);
 
 	cl = c2_layout_to_cl(l);
-	l_verify(l, composite_lid);
+	l_verify(l, composite_lid, !USER_COUNT_INCREMENTED);
 
 	c2_uint128_init(&seed, "sub_layouts_buil");
         c2_tl_for(c2_sub_layout, cl->cl_sub_layouts, sl) {
@@ -882,8 +879,9 @@ static void composite_layout_verify(struct c2_layout *l,
 		inline_test    = i % 5 ? LESS_THAN_INLINE : MORE_THAN_INLINE;
 		NKP_assign(enum_id, inline_test, 9, 109, 1200, &N, &K, &P);
 		pdclust_layout_verify(enum_id, sl->csl_l, sub_layout_lid,
-				      N, K, P, &seed, 10, 20);
-		//todo C2_UT_ASSERT(sl->csl_l->l_user_count == 1);
+				      N, K, P, &seed, 10, 20,
+				      USER_COUNT_INCREMENTED);
+		C2_UT_ASSERT(sl->csl_l->l_user_count == 1);
 
 		/* Verify sl->csl_ext. */
 		C2_UT_ASSERT(sl->csl_ext.e_start == i * delta);
@@ -912,14 +910,8 @@ static int composite_layout_build(uint64_t lid,
 
 	C2_UT_ASSERT(cl != NULL);
 
-	/* Initialise a c2_tl for storing the sub-layouts to be built. */
-	C2_ALLOC_PTR(sub_layout_list);
-	C2_UT_ASSERT(sub_layout_list != NULL);
-	c2_sub_layout_tlist_init(sub_layout_list);
-
 	/* Build sub-layouts. */
-	sub_layouts_build(lid, sub_layout_list, num_sublayouts, end_offset);
-	C2_UT_ASSERT(!c2_sub_layout_tlist_is_empty(sub_layout_list));
+	sub_layouts_build(lid, &sub_layout_list, num_sublayouts, end_offset);
 
 	/* Build composite layout. */
 	rc = c2_composite_build(&domain, lid, sub_layout_list, cl);
@@ -982,6 +974,7 @@ static int test_build_composite(uint64_t lid,
 		for (i = 0; i < 5; ++i) {
 			sub_layout_lid = lid * 100 + i;
 			l = c2_layout_find(&domain, sub_layout_lid);
+			C2_UT_ASSERT(l->l_user_count == 0);
 			c2_layout_put(l);
 			c2_layout_put(l);
 		}
@@ -1260,9 +1253,9 @@ static int test_decode_pdclust(uint32_t enum_id, uint64_t lid,
 	bv = (struct c2_bufvec) C2_BUFVEC_INIT_BUF(&area, &num_bytes);
 	c2_bufvec_cursor_init(&cur, &bv);
 
-	NKP_assign_and_pool_init(enum_id,
-				 inline_test, 5, 125, 1500,
-				 &N, &K, &P);
+	NKP_assign(enum_id,
+		   inline_test, 5, 125, 1500,
+		   &N, &K, &P);
 
 	rc = pdclust_layout_buf_build(enum_id, lid,
 				      N, K, P, &seed,
@@ -1288,7 +1281,7 @@ static int test_decode_pdclust(uint32_t enum_id, uint64_t lid,
 		/* Verify the layout object built by c2_layout_decode(). */
 		pdclust_layout_verify(enum_id, l, lid,
 				      N, K, P, &seed,
-				      777, 888);
+				      777, 888, !USER_COUNT_INCREMENTED);
 	}
 
 	/* Destroy the layout object. */
@@ -1302,7 +1295,6 @@ static int test_decode_pdclust(uint32_t enum_id, uint64_t lid,
 	C2_UT_ASSERT(list_lookup(lid) == NULL);
 
 	c2_free(area);
-	c2_pool_fini(&pool);
 	C2_LEAVE();
 	return rc;
 }
@@ -1325,12 +1317,7 @@ static int composite_layout_buf_build(uint64_t lid,
 	buf_build(c2_composite_layout_type.lt_id, dcur);
 
 	/* Build sub-layouts. */
-	/* todo move these 3 lines into sub_layouts_build(). */
-	C2_ALLOC_PTR(sub_layout_list);
-	C2_UT_ASSERT(sub_layout_list != NULL);
-	c2_sub_layout_tlist_init(sub_layout_list);
-	sub_layouts_build(lid, sub_layout_list, num_sublayouts, end_offset);
-	C2_UT_ASSERT(!c2_sub_layout_tlist_is_empty(sub_layout_list));
+	sub_layouts_build(lid, &sub_layout_list, num_sublayouts, end_offset);
 
 	/*
 	 * Build part of the buffer representing composite type specific part
@@ -1375,11 +1362,11 @@ static int test_decode_composite(uint64_t lid, bool failure_test)
 	C2_ENTRY();
 
 	/* Build a layout buffer. */
-	allocate_area(&area, ADDITIONAL_BYTES_DEFAULT * 4, &num_bytes); //todo
+	allocate_area(&area, ADDITIONAL_BYTES_DEFAULT, &num_bytes);
 	bv = (struct c2_bufvec) C2_BUFVEC_INIT_BUF(&area, &num_bytes);
 	c2_bufvec_cursor_init(&cur, &bv);
 
-	rc = composite_layout_buf_build(lid, 6, 600, &cur);
+	rc = composite_layout_buf_build(lid, 60, 6000, &cur);
 	C2_UT_ASSERT(rc == 0);
 
 	/* Rewind the cursor. */
@@ -1414,7 +1401,7 @@ static int test_decode_composite(uint64_t lid, bool failure_test)
 	C2_UT_ASSERT(list_lookup(lid) == NULL);
 
 	/* Delete all the sub-layouts. */
-	for (i = 0; i < 6; ++i) {
+	for (i = 0; i < 60; ++i) {
 		sub_layout_lid = lid * 100 + i;
 		l = c2_layout_find(&domain, sub_layout_lid);
 		c2_layout_put(l);
@@ -1422,7 +1409,6 @@ static int test_decode_composite(uint64_t lid, bool failure_test)
 	}
 
 	c2_free(area);
-	c2_pool_fini(&pool);
 	C2_LEAVE();
 	return rc;
 }
@@ -1680,9 +1666,9 @@ static int test_encode_pdclust(uint32_t enum_id, uint64_t lid,
 	bv = (struct c2_bufvec) C2_BUFVEC_INIT_BUF(&area, &num_bytes);
 	c2_bufvec_cursor_init(&cur, &bv);
 
-	NKP_assign_and_pool_init(enum_id,
-				 inline_test, 10, 120, 120,
-				 &N, &K, &P);
+	NKP_assign(enum_id,
+		   inline_test, 10, 120, 120,
+		   &N, &K, &P);
 
 	rc = pdclust_layout_build(enum_id, lid,
 				  N, K, P, &seed,
@@ -1714,8 +1700,6 @@ static int test_encode_pdclust(uint32_t enum_id, uint64_t lid,
 	c2_layout_put(&pl->pl_base.sl_base);
 	C2_UT_ASSERT(list_lookup(lid) == NULL);
 	c2_free(area);
-
-	c2_pool_fini(&pool);
 	C2_LEAVE();
 	return rc;
 }
@@ -1741,8 +1725,8 @@ static int test_encode_composite(uint64_t lid, bool failure_test)
 	C2_ENTRY("lid %llu", (unsigned long long)lid);
 
 	/* Build a layout object. */
-	allocate_area(&area, ADDITIONAL_BYTES_DEFAULT * 4, &num_bytes); //todo
-	rc = composite_layout_build(lid, &cl, 5, 500, failure_test);
+	allocate_area(&area, ADDITIONAL_BYTES_DEFAULT, &num_bytes);
+	rc = composite_layout_build(lid, &cl, 50, 5000, failure_test);
 	if (failure_test)
 		C2_UT_ASSERT(rc == -ENOMEM);
 	else
@@ -1784,7 +1768,7 @@ static int test_encode_composite(uint64_t lid, bool failure_test)
 	C2_UT_ASSERT(c2_layout_find(&domain, lid) == NULL);
 
 	/* Delete all the sub-layouts. */
-	for (i = 0; i < 5; ++i) {
+	for (i = 0; i < 50; ++i) {
 		sub_layout_lid = lid * 100 + i;
 		l = c2_layout_find(&domain, sub_layout_lid);
 		c2_layout_put(l);
@@ -1792,7 +1776,6 @@ static int test_encode_composite(uint64_t lid, bool failure_test)
 	}
 
 	c2_free(area);
-	c2_pool_fini(&pool);
 	C2_LEAVE();
 	return rc;
 }
@@ -2007,9 +1990,9 @@ static int test_decode_encode_pdclust(uint32_t enum_id, uint64_t lid,
 	bv1 = (struct c2_bufvec) C2_BUFVEC_INIT_BUF(&area1, &num_bytes);
 	c2_bufvec_cursor_init(&cur1, &bv1);
 
-	NKP_assign_and_pool_init(enum_id,
-				 inline_test, 3, 103, 1510,
-				 &N, &K, &P);
+	NKP_assign(enum_id,
+		   inline_test, 3, 103, 1510,
+		   &N, &K, &P);
 
 	rc = pdclust_layout_buf_build(LINEAR_ENUM_ID, lid,
 				      N, K, P, &seed,
@@ -2065,7 +2048,6 @@ static int test_decode_encode_pdclust(uint32_t enum_id, uint64_t lid,
 
 	c2_free(area1);
 	c2_free(area2);
-	c2_pool_fini(&pool);
 	C2_LEAVE();
 	return rc;
 }
@@ -2330,9 +2312,9 @@ static int test_encode_decode_pdclust(uint32_t enum_id, uint64_t lid,
 	bv = (struct c2_bufvec) C2_BUFVEC_INIT_BUF(&area, &num_bytes);
 	c2_bufvec_cursor_init(&cur, &bv);
 
-	NKP_assign_and_pool_init(enum_id,
-				 inline_test, 13, 113, 1130,
-				 &N, &K, &P);
+	NKP_assign(enum_id,
+		   inline_test, 13, 113, 1130,
+		   &N, &K, &P);
 
 	rc = pdclust_layout_build(enum_id, lid,
 				  N, K, P, &seed,
@@ -2384,7 +2366,6 @@ static int test_encode_decode_pdclust(uint32_t enum_id, uint64_t lid,
 	C2_UT_ASSERT(list_lookup(lid) == NULL);
 
 	c2_free(area);
-	c2_pool_fini(&pool);
 	C2_LEAVE();
 	return rc;
 }
@@ -2466,9 +2447,9 @@ static int test_ref_get_put_pdclust(uint32_t enum_id, uint64_t lid)
 	c2_uint128_init(&seed, "refgetputpdclust");
 
 	/* Build a layout object. */
-	NKP_assign_and_pool_init(enum_id, MORE_THAN_INLINE,
-				 10, 1212, 1212,
-				 &N, &K, &P);
+	NKP_assign(enum_id, MORE_THAN_INLINE,
+		   10, 1212, 1212,
+		   &N, &K, &P);
 
 	rc = pdclust_layout_build(LIST_ENUM_ID, lid,
 				  N, K, P, &seed,
@@ -2584,9 +2565,9 @@ static int test_enum_ops_pdclust(uint32_t enum_id, uint64_t lid,
 	/* Build a layout object. */
 	c2_uint128_init(&seed, "enumopspdclustla");
 
-	NKP_assign_and_pool_init(enum_id,
-				 inline_test, 14, 1014, 1014,
-				 &N, &K, &P);
+	NKP_assign(enum_id,
+		   inline_test, 14, 1014, 1014,
+		   &N, &K, &P);
 
 	rc = pdclust_layout_build(enum_id, lid,
 				  N, K, P, &seed,
@@ -2602,7 +2583,6 @@ static int test_enum_ops_pdclust(uint32_t enum_id, uint64_t lid,
 	c2_layout_put(&pl->pl_base.sl_base);
 	C2_UT_ASSERT(list_lookup(lid) == NULL);
 
-	c2_pool_fini(&pool);
 	C2_LEAVE();
 	return rc;
 }
@@ -2821,9 +2801,9 @@ static int test_recsize_pdclust(uint32_t enum_id, uint64_t lid,
 	c2_uint128_init(&seed, "recsizepdclustla");
 
 	/* Build a layout object. */
-	NKP_assign_and_pool_init(enum_id,
-				 inline_test, 1, 1200, 1111,
-				 &N, &K, &P);
+	NKP_assign(enum_id,
+		   inline_test, 1, 1200, 1111,
+		   &N, &K, &P);
 
 	rc = pdclust_layout_build(enum_id, lid,
 				  N, K, P, &seed,
@@ -2842,8 +2822,6 @@ static int test_recsize_pdclust(uint32_t enum_id, uint64_t lid,
 	/* Destroy the layout object. */
 	c2_layout_put(l);
 	C2_UT_ASSERT(list_lookup(lid) == NULL);
-
-	c2_pool_fini(&pool);
 	C2_LEAVE();
 	return rc;
 }
@@ -2905,9 +2883,9 @@ static int test_pdclust_instance_obj(uint32_t enum_id, uint64_t lid,
 
 	c2_uint128_init(&seed, "buildpdclustlayo");
 
-	NKP_assign_and_pool_init(enum_id,
-				 inline_test, 14, 30, 30,
-				 &N, &K, &P);
+	NKP_assign(enum_id,
+		   inline_test, 14, 30, 30,
+		   &N, &K, &P);
 
 	rc = pdclust_layout_build(enum_id, lid,
 				  N, K, P, &seed,
@@ -2960,7 +2938,6 @@ static int test_pdclust_instance_obj(uint32_t enum_id, uint64_t lid,
 	/* Delete the layout object. */
 	c2_layout_put(c2_pdl_to_layout(pl));
 	C2_UT_ASSERT(list_lookup(lid) == NULL);
-	c2_pool_fini(&pool);
 	return rc;
 }
 
@@ -3497,9 +3474,9 @@ static int test_add_pdclust(uint32_t enum_id, uint64_t lid,
 	allocate_area(&area, ADDITIONAL_BYTES_NONE, &num_bytes);
 
 	/* Build a layout object. */
-	NKP_assign_and_pool_init(enum_id,
-				 inline_test, 7, 1900, 1900,
-				 &N, &K, &P);
+	NKP_assign(enum_id,
+		   inline_test, 7, 1900, 1900,
+		   &N, &K, &P);
 
 	rc = pdclust_layout_build(enum_id, lid,
 				  N, K, P, &seed,
@@ -3550,7 +3527,6 @@ static int test_add_pdclust(uint32_t enum_id, uint64_t lid,
 		*l_obj = &pl->pl_base.sl_base;
 
 	c2_free(area);
-	c2_pool_fini(&pool);
 	C2_LEAVE("lid %llu", (unsigned long long)lid);
 	return rc;
 }
@@ -3689,9 +3665,9 @@ static int test_update_pdclust(uint32_t enum_id, uint64_t lid,
 
 	allocate_area(&area, ADDITIONAL_BYTES_NONE, &num_bytes);
 
-	NKP_assign_and_pool_init(enum_id,
-				 inline_test, 13, 123, 1230,
-				 &N, &K, &P);
+	NKP_assign(enum_id,
+		   inline_test, 13, 123, 1230,
+		   &N, &K, &P);
 
 	if (existing_test) {
 		/* Add a layout object to the DB. */
@@ -3787,7 +3763,6 @@ static int test_update_pdclust(uint32_t enum_id, uint64_t lid,
 	}
 
 	c2_free(area);
-	c2_pool_fini(&pool);
 	C2_LEAVE();
 	return rc;
 }
@@ -3904,9 +3879,9 @@ static int test_delete_pdclust(uint32_t enum_id, uint64_t lid,
 
 	allocate_area(&area, ADDITIONAL_BYTES_NONE, &num_bytes);
 
-	NKP_assign_and_pool_init(enum_id,
-				 inline_test, 12, 122, 1220,
-				 &N, &K, &P);
+	NKP_assign(enum_id,
+		   inline_test, 12, 122, 1220,
+		   &N, &K, &P);
 	if (existing_test) {
 		/* Add a layout object to the DB. */
 		rc = test_add_pdclust(enum_id, lid,
@@ -3971,7 +3946,6 @@ static int test_delete_pdclust(uint32_t enum_id, uint64_t lid,
 	}
 
 	c2_free(area);
-	c2_pool_fini(&pool);
 	C2_LEAVE();
 	return rc;
 }
-- 
1.8.3.2

