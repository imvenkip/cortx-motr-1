From 4013a1b32fd24313a6f93800f83df2e5e55cd483 Mon Sep 17 00:00:00 2001
From: "trupti.patil" <trupti_patil@xyratex.com>
Date: Mon, 22 Apr 2013 12:38:11 +0530
Subject: [PATCH 119/172] Cleanup w.r.t. taking out db part from extent ops

---
 db/extmap.c           |   9 +-
 db/extmap.h           |   7 ++
 layout/composite.c    | 258 ++++----------------------------------------------
 layout/ut/composite.c |   1 -
 4 files changed, 33 insertions(+), 242 deletions(-)

diff --git a/db/extmap.c b/db/extmap.c
index c36557f..7b4aecd 100644
--- a/db/extmap.c
+++ b/db/extmap.c
@@ -416,15 +416,18 @@ int m0_emap_paste(struct m0_emap_cursor *it, struct m0_ext *ext, uint64_t val,
 		bstart[1] = val;
 		val_orig  = seg->ee_val;
 		if (length[0] > 0) {
-			cut_left(seg, &clip, val_orig, data);
+			if (cut_left != NULL)
+				cut_left(seg, &clip, val_orig, data);
 			bstart[0] = seg->ee_val;
 		}
 		if (length[2] > 0) {
-			cut_right(seg, &clip, val_orig, data);
+			if (cut_right != NULL)
+				cut_right(seg, &clip, val_orig, data);
 			bstart[2] = seg->ee_val;
 		}
 		if (length[0] == 0 && length[2] == 0)
-			del(seg, data);
+			if (del != NULL)
+				del(seg, data);
 
 		result = emap_split_internal(it, &vec, length[0] > 0 ?
 					     chunk->e_start : ext0.e_start);
diff --git a/db/extmap.h b/db/extmap.h
index e9ce4e1..fe00042 100644
--- a/db/extmap.h
+++ b/db/extmap.h
@@ -227,6 +227,9 @@ M0_INTERNAL int m0_emap_split(struct m0_emap_cursor *iterator,
    Paste segment (ext, val) into the map, deleting or truncating overlapping
    segments as necessary.
 
+   @param data - pointer to the data that needs to be passed to the callbacks
+   when invoked. m0_emap_paste() treats this data as opaque to it.
+
    @param del - this call-back is called when an existing segment is completely
    covered by a new one and has to be deleted. The segment to be deleted is
    supplied as the call-back argument;
@@ -251,6 +254,10 @@ M0_INTERNAL int m0_emap_split(struct m0_emap_cursor *iterator,
 
    @note Call-backs are called in the order of cursor iteration, but this is not
    a part of official function contract.
+
+   @note It is possible that the user does not need to receive any callbacks
+   from m0_emap_paste() since nothing is to be performed in the context of the
+   callbacks. The callback pointers may be NULL in such cases.
  */
 int m0_emap_paste(struct m0_emap_cursor *it, struct m0_ext *ext, uint64_t val,
 		  void *data,
diff --git a/layout/composite.c b/layout/composite.c
index 91e7418..178ecd7 100644
--- a/layout/composite.c
+++ b/layout/composite.c
@@ -91,16 +91,6 @@ struct layout_prefix {
 	uint32_t lp_filler;
 };
 
-/**
- * Operation to be performed on an extent, in the context of callbacks from
- * m0_emap_paste().
- */
-enum extent_op {
-	DELETE,
-	CUT_LEFT,
-	CUT_RIGHT
-};
-
 /** Position to add a new extent at, in the list of the extents. */
 enum extent_add_position {
 	ADD_AFTER,
@@ -1871,196 +1861,28 @@ err1_injected:
 	return rc;
 }
 
-static void ext_inmem_delete(struct m0_composite_layer *layer,
-			     const struct m0_ext *ext,
-			     uint64_t old_ext_state)
-{
-	struct m0_composite_layer_extent *lr_ext;
-	struct m0_composite_layer_extent *lr_ext_to_delete;
-
-	M0_ENTRY("lid %llu, layer %lu, e_start %llu, e_end %llu, "
-		 "old_e_state %llu",
-		 (unsigned long long)layer->clr_cl->l_id,
-		 (unsigned long)layer->clr_idx,
-		 (unsigned long long)ext->e_start,
-		 (unsigned long long)ext->e_end,
-		 (unsigned long long)old_ext_state);
-
-	lr_ext_to_delete = NULL;
-	m0_tl_for(m0_composite_layer_ext, &layer->clr_extents, lr_ext) {
-		if (ext->e_start > lr_ext->cle_ext.e_end)
-			continue;
-		if (ext->e_start == lr_ext->cle_ext.e_start) {
-			M0_ASSERT(lr_ext->cle_ext.e_end == ext->e_end);
-			M0_ASSERT(lr_ext->cle_state == old_ext_state);
-			lr_ext_to_delete = lr_ext;
-			break;
-		}
-	} m0_tl_endfor;
-	/*
-	 * Since the ext is asked to be deleted, it has to be present in the
-	 * in-memory list of the extents.
-	 */
-	M0_ASSERT(lr_ext_to_delete != NULL);
-	ext_inmem_del_internal(layer, lr_ext_to_delete);
-	M0_LEAVE();
-}
-
-/** Trims the existing extent as requested. */
-static int ext_inmem_trim(struct m0_composite_layer *layer,
-			  enum extent_op extent_op,
-			  const struct m0_ext *ext_to_trim,
-			  uint64_t ext_state,
-			  const struct m0_ext *trim_reference_ext)
-{
-	struct m0_composite_layer_extent *lr_ext;
-	struct m0_composite_layer_extent *lr_ext_left;
-	struct m0_ext                     ext_left;
-	struct m0_ext                     ext_to_insert;
-	int                               rc;
-
-	M0_PRE(M0_IN(extent_op, (CUT_LEFT, CUT_RIGHT)));
-	M0_ENTRY("lid %llu, layer %lu, extent_op %d, "
-		 "ext_to_trim_start %llu, ext_to_trim_end %llu, "
-		 "ext_state %llu, "
-		 "trim_ref_ext_start %llu, trim_ref_ext_end %llu",
-		 (unsigned long long)layer->clr_cl->l_id,
-		 (unsigned long)layer->clr_idx, extent_op,
-		 (unsigned long long)ext_to_trim->e_start,
-		 (unsigned long long)ext_to_trim->e_end,
-		 (unsigned long long)ext_state,
-		 (unsigned long long)trim_reference_ext->e_start,
-		 (unsigned long long)trim_reference_ext->e_end);
-	rc = ext_inmem_find(layer, ext_to_trim, ext_state, &lr_ext);
-	if (rc == 0) {
-		M0_ASSERT(lr_ext->cle_ext.e_start <=
-			  trim_reference_ext->e_start);
-		M0_ASSERT(lr_ext->cle_ext.e_end >= trim_reference_ext->e_end);
-
-		if (extent_op == CUT_LEFT)
-			/* Retain left part of the existing extent. */
-			lr_ext->cle_ext.e_end = trim_reference_ext->e_start;
-		else
-			/* Retain right part of the existing extent. */
-			lr_ext->cle_ext.e_start = trim_reference_ext->e_end;
-	} else if (extent_op == CUT_RIGHT) {
-		/*
-		 * It is possible that CUT_LEFT has already been performed
-		 * on the same extent. So, the extent ext_to_trim does not
-		 * exist there as a whole but its left part does.
-		 */
-		M0_ASSERT(rc == -ENOENT);
-		ext_left = *ext_to_trim;
-		ext_left.e_end = trim_reference_ext->e_start;
-		rc = ext_inmem_find(layer, &ext_left, ext_state, &lr_ext_left);
-		if (rc == 0) {
-			ext_to_insert = *ext_to_trim;
-			ext_to_insert.e_start = trim_reference_ext->e_end;
-			rc = ext_inmem_add_internal(layer, NULL, NULL,
-						    &ext_to_insert, ext_state,
-						    ADD_AFTER, lr_ext_left);
-			if (rc != 0)
-				M0_LOG(M0_ERROR, "lid %llu, Extent could not "
-				       "be added to the list",
-				       (unsigned long long)layer->clr_cl->l_id);
-		}
-	} else
-		/*
-		 * Since m0_emap_paste() first sends cut_left callback and then
-		 * the cut_right callback, it is not possible that CUT_RIGHT
-		 * has been performed before CUT_LEFT.
-		 */
-		M0_ASSERT(0);
-	M0_RETURN(rc);
-}
-
-/** Struct to store the data that may be required by the callback execution. */
-struct callback_data {
-	struct m0_composite_layer *cb_layer;
-	bool                       cb_inmem_list_update;
-	int                        cb_rc; /* Callback execution status */
-};
-
-static void delete_callback(struct m0_emap_seg *seg, void *data)
-{
-	struct callback_data *cb_data = data;
-
-	M0_ENTRY("ext_start %llu, ext_end %llu",
-		 (unsigned long long)seg->ee_ext.e_start,
-		 (unsigned long long) seg->ee_ext.e_end);
-	if (cb_data->cb_inmem_list_update)
-		ext_inmem_delete(cb_data->cb_layer, &seg->ee_ext, seg->ee_val);
-	M0_LEAVE();
-}
-
-static void cut_left_callback(struct m0_emap_seg *seg, struct m0_ext *ext,
-			      uint64_t existing_ext_state, void *data)
-{
-	struct callback_data *cb_data = data;
-
-	M0_ENTRY("ext_start %llu, ext_end %llu",
-		 (unsigned long long)seg->ee_ext.e_start,
-		 (unsigned long long)seg->ee_ext.e_end);
-	if (cb_data->cb_inmem_list_update)
-		cb_data->cb_rc = cb_data->cb_rc ?:
-				 ext_inmem_trim(cb_data->cb_layer, CUT_LEFT,
-						&seg->ee_ext, seg->ee_val, ext);
-	M0_LEAVE("rc %d", cb_data->cb_rc);
-}
-
-static void cut_right_callback(struct m0_emap_seg *seg, struct m0_ext *ext,
-			       uint64_t existing_ext_state, void *data)
-{
-	struct callback_data *cb_data = data;
-
-	M0_ENTRY("ext_start %llu, ext_end %llu",
-		 (unsigned long long)seg->ee_ext.e_start,
-		 (unsigned long long)seg->ee_ext.e_end);
-	if (cb_data->cb_inmem_list_update)
-		cb_data->cb_rc = cb_data->cb_rc ?:
-				 ext_inmem_trim(cb_data->cb_layer, CUT_RIGHT,
-						&seg->ee_ext, seg->ee_val, ext);
-	M0_LEAVE("rc %d", cb_data->cb_rc);
-}
-
 static int ext_indb_write_internal(struct m0_emap_cursor *it,
 				   struct m0_composite_layer *layer,
 				   const struct m0_ext *ext,
-				   uint64_t new_ext_state,
-				   bool inmem_list_update)
+				   uint64_t new_ext_state)
 {
-	struct m0_ext        ext0 = *ext; /* A read-write copy. */
-	int                  rc;
-	struct callback_data cb_data = {
-		.cb_layer             = layer,
-		.cb_inmem_list_update = inmem_list_update,
-		.cb_rc                = 0
-	};
+	struct m0_ext ext0 = *ext; /* A read-write copy. */
+	int           rc;
 
+	M0_PRE(layer_invariant(layer));
 	M0_ENTRY("lid %llu, layer %lu, e_start %llu, e_end %llu, "
-		 "new_e_state %llu, inmem_list_update %d",
-		 (unsigned long long)layer->clr_cl->l_id,
+		 "new_e_state %llu", (unsigned long long)layer->clr_cl->l_id,
 		 (unsigned long)layer->clr_idx,
 		 (unsigned long long)ext->e_start,
 		 (unsigned long long)ext->e_end,
-		 (unsigned long long)new_ext_state, inmem_list_update ? 1 : 0);
+		 (unsigned long long)new_ext_state);
 	/*
 	 * Insert a new segment into the layer's extent map, overwriting
-	 * parts of the map, as applicable.
-	 *
-	 * Some existing segments are deleted completely, others are cut.
-	 * m0_emap_paste() invokes supplied call-backs to notify the caller
-	 * about the changes in the map. These call-backs are used to adjust
-	 * the extents in the in-memory list of the extents for the specific
-	 * layer.
-	 *
-	 * Each call-back takes a segment argument, viz. seg. seg->ee_ext is
-	 * an extent associated with the specified layer as is stored in the
-	 * on-disk extent map and seg->ee_val is the state of that extent.
+	 * parts of the map, as applicable. Some existing segments are deleted
+	 * completely, others are cut.
 	 *
 	 * Here is an example to illustrate the sequence of the operations
-	 * performed by m0_emap_paste() and how the in-memory list of the
-	 * extents is adjusted accordingly.
+	 * performed by m0_emap_paste().
 	 *
 	 * For example, a layer contains an extent list (in-memory and in-DB)
 	 * as:
@@ -2074,29 +1896,22 @@ static int ext_indb_write_internal(struct m0_emap_cursor *it,
 	 * An extent [56668023, 165602677) is asked to be added into the list.
 	 *
 	 * In such a case, multiple small operations are performed internally
-	 * by m0_emap_paste() and the callbacks are sent appropriately. In
-	 * response to those callback, the in-memory list of the extents is
-	 * adjusted accordingly by using the ext_inmem_adjust() function.
-	 *
-	 * The sequence goes as follows:
+	 * by m0_emap_paste(). The sequence goes as follows:
 	 * 1) From the extent [2200700, 56668025), its left part that is
-	 *    [2200700, 56668023) is retained, using the extent_op CUT_LEFT.
+	 *    [2200700, 56668023) is retained (cut left operation).
 	 * 2) From the extent list, the extent [56668025, 111135350) is
-	 *    deleted using the extent_op DELETE.
+	 *    deleted (delete operation).
 	 * 3) From the extent list, the extent [111135350, 165602675) is
-	 *    deleted using the extent_op DELETE.
+	 *    deleted (delete operation).
 	 * 4) From the extent [165602675, 220070000), its right part that is
-	 *    [165602677, 220070000) is retained, using the extent_op
-	 *    CUT_RIGHT.
+	 *    [165602677, 220070000) is retained (cut right operation).
 	 * 5) Finally, the complete extent [56668023, 165602677) is added.
-	 *
-	 * layer_invariant() is temporarily violated during these operations.
 	 */
 
 	if (M0_FI_ENABLED("emap_paste_err"))
 		{ rc = L_EMAP_PASTE_ERR; goto err1_injected; }
-	rc = m0_emap_paste(it, &ext0, new_ext_state, &cb_data, delete_callback,
-			   cut_left_callback, cut_right_callback);
+	rc = m0_emap_paste(it, &ext0, new_ext_state,
+			   NULL, NULL, NULL, NULL);
 err1_injected:
 	if (rc != 0)
 		m0_layout__log("ext_indb_write",
@@ -2105,32 +1920,7 @@ err1_injected:
 			       &layer->clr_cl->l_addb_ctx, layer->clr_cl->l_id,
 			       rc);
 
-	if (cb_data.cb_rc != 0)
-		M0_LOG(M0_ERROR, "lid %llu, Extent could not be adjustted "
-		       "in memory, rc %d",
-		       (unsigned long long)layer->clr_cl->l_id, cb_data.cb_rc);
-
-	rc = rc ?: cb_data.cb_rc;
-
-	if (rc == 0 && inmem_list_update) {
-		/*
-		 * Now that the deletion/trimming of the overlapping extents
-		 * from the in-memory list of the extents has been
-		 * handled above, let's add the ultimate whole extent.
-		 */
-		rc = ext_inmem_find(layer, ext, new_ext_state, NULL);
-		M0_ASSERT(rc == -ENOENT);
-		rc = ext_inmem_add(layer, ext, new_ext_state);
-		if (rc != 0)
-			M0_LOG(M0_ERROR, "lid %llu, Ultimate extent could not "
-			       "be added to memory, layer %lu, e_start %llu, "
-			       "e_end %llu",
-			       (unsigned long long)layer->clr_cl->l_id,
-			       (unsigned long)layer->clr_idx,
-			       (unsigned long long)ext->e_start,
-			       (unsigned long long)ext->e_end);
-	}
-	M0_POST(ergo(rc == 0, layer_invariant(layer)));
+	M0_POST(layer_invariant(layer));
 	M0_RETURN(rc);
 }
 
@@ -2190,8 +1980,7 @@ err1_injected:
 						    M0_CLRES_FLATTENING)));
 		rc = ext_indb_write_internal(&it, layer,
 					     &lr_ext->cle_ext,
-					     lr_ext->cle_state,
-					     !INMEM_LIST_UPDATE);
+					     lr_ext->cle_state);
 		if (rc != 0) {
 			M0_LOG(M0_ERROR, "lid %llu, layer %lu, "
 			       "failed to write extent, rc %d",
@@ -2223,7 +2012,6 @@ static int layer_indb_add(struct m0_composite_layout *cl,
 	M0_RETURN(rc);
 }
 
-//todo It shall be simple tlist and not lr_ext list
 static int extentmap_indb_read(struct m0_composite_layout *cl,
 			       uint32_t layer_idx,
 			       struct m0_db_tx *tx,
@@ -2408,11 +2196,6 @@ static int single_ext_indb_write(struct m0_composite_layout *cl,
 		.e_start = 0,
 		.e_end = M0_BINDEX_MAX + 1
 	};
-	struct callback_data  cb_data = {
-		.cb_layer             = NULL,
-		.cb_inmem_list_update = false,
-		.cb_rc                = 0
-	};
 
 	M0_ENTRY("lid %llu, layer_idx %lu",
 		 (unsigned long long)cl->cl_base.l_id,
@@ -2435,9 +2218,8 @@ err1_injected:
 	//todo Change m0_emap_paste() such that it accepts NULL cb pointers
 	if (M0_FI_ENABLED("emap_paste_err"))
 		{ rc = L_EMAP_PASTE_ERR; goto err2_injected; }
-	rc = m0_emap_paste(&it, &ext, M0_CLRES_INVALID, &cb_data,
-			   delete_callback, cut_left_callback,
-			   cut_right_callback);
+	rc = m0_emap_paste(&it, &ext, M0_CLRES_INVALID,
+			   NULL, NULL, NULL, NULL);
 err2_injected:
 	if (rc != 0)
 		m0_layout__log("single_ext_indb_write",
diff --git a/layout/ut/composite.c b/layout/ut/composite.c
index ce4f1b4..ddcf3c7 100644
--- a/layout/ut/composite.c
+++ b/layout/ut/composite.c
@@ -130,7 +130,6 @@ static void sublayouts_delete(struct m0_layout_domain *domain,
  * 4) Add test to cover the small IO use case specifically.
  * 5) Add test to cover other composite layouts being used as sublayouts.
  */
-//todo It shall be simple tlist and not lr_ext list
 static void extentlist_build(struct m0_tl *extents,
 			     uint32_t extents_nr,
 			     bool if_contiguous_extents)
-- 
1.8.3.2

