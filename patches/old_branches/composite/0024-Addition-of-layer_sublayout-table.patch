From 5f1a72aef8972fdca47f60c20b57d4e0f5f59d56 Mon Sep 17 00:00:00 2001
From: "trupti.patil" <trupti_patil@xyratex.com>
Date: Thu, 29 Nov 2012 16:51:32 +0530
Subject: [PATCH 024/172] Addition of layer_sublayout table

1) Addition of layer_sublayout table to store the sublayout id for each layer
   of each composite layout. In the layer_ext_map table, the value shall store
   state of the extents and not the sublayout id as designed earlier.
2) Trying to use c2_emap_paste() instead of c2_emap_split() to add mutliple
   extents associated with each layer. The change is stil in progress.
3) Refactoring some common code.
4) sublayouts creation is separated from the layers creation - the sublayouts
   are precreated.
---
 layout/composite.c    | 965 ++++++++++++++++++++++++++++++--------------------
 layout/composite.h    |  18 +-
 layout/list_enum.c    |   1 +
 layout/ut/composite.c | 516 ++++++++++++++++++---------
 layout/ut/layout.c    |  46 ++-
 layout/ut/layout.h    |   9 +
 6 files changed, 980 insertions(+), 575 deletions(-)

diff --git a/layout/composite.c b/layout/composite.c
index 6776e70..7305153 100644
--- a/layout/composite.c
+++ b/layout/composite.c
@@ -27,6 +27,7 @@
 #include "lib/memory.h" /* C2_ALLOC_PTR() */
 #include "lib/misc.h"   /* C2_IN() */
 #include "lib/vec.h"    /* c2_bufvec_cursor_step(), c2_bufvec_cursor_addr() */
+#include "lib/thread.h" /* LAMBDA */
 #include "lib/bob.h"
 #include "lib/finject.h"
 
@@ -59,14 +60,76 @@ C2_BOB_DEFINE(static, &composite_instance_bob, c2_composite_instance);
 #endif
 
 struct composite_schema_data {
-	/** Table to store extent maps for all the composite layouts. */
-	struct c2_emap csd_comp_layout_ext_map;
+	/**
+	 * Table to store sublayout id for all the layers of all the composite
+	 * layouts.
+	 */
+	struct c2_table csd_layer_sublayout;
+
+	/**
+	 * Table to store extent maps for all the layers of all the composite
+	 * layouts.
+	 */
+	struct c2_emap  csd_layer_ext_map;
+};
+
+/**
+ * layer_sublayout table.
+ *
+ * @note This structure needs to be maintained as 8 bytes aligned.
+ */
+struct layer_sublayout_key {
+	/** Layout id for the composite layout. */
+	uint64_t lrsmk_comp_lid;
+
+	/** Layer index. */
+	uint32_t lrsmk_layer_idx;
+
+	/** Padding to make the structure 8 bytes aligned. */
+	uint32_t lrsmk_pad;
+};
+C2_BASSERT(C2_IS_8ALIGNED(sizeof(struct layer_sublayout_key)));
+
+/**
+ * @note This structure needs to be maintained as 8 bytes aligned.
+ */
+struct layer_sublayout_rec {
+	/** Layout id for the sublayout. */
+	uint64_t lrsmr_sublayout_lid;
 };
+C2_BASSERT(C2_IS_8ALIGNED(sizeof(struct layer_sublayout_rec)));
 
 /**
- * Prefix for the comp_layout_ext_map table. The prefix helps to identify an
- * extent map for a particular composite layout, from the set of extent maps
- * for all the composite layouts.
+ * Compare layer_sublayout table keys.
+ * This is a 3WAY comparison.
+ */
+static int cl_key_cmp(struct c2_table *table,
+		      const void *key0, const void *key1)
+{
+	const struct layer_sublayout_key *k0 = key0;
+	const struct layer_sublayout_key *k1 = key1;
+
+	return C2_3WAY(k0->lrsmk_comp_lid, k1->lrsmk_comp_lid) ?:
+		C2_3WAY(k0->lrsmk_layer_idx, k1->lrsmk_layer_idx);
+}
+
+/** table_ops for layer_sublayout table. */
+static const struct c2_table_ops composite_table_ops = {
+	.to = {
+		[TO_KEY] = {
+			.max_size = sizeof(struct layer_sublayout_key)
+		},
+		[TO_REC] = {
+			.max_size = sizeof(struct layer_sublayout_rec)
+		}
+	},
+	.key_cmp = cl_key_cmp
+};
+
+/**
+ * Prefix for the layer_ext_map table. The prefix helps to identify an
+ * extent map for a particular layer of a particular composite layout, from the
+ * set of extent maps for all the layers of all the composite layouts.
  */
 struct layout_prefix {
 	/**
@@ -75,13 +138,39 @@ struct layout_prefix {
 	 */
 	uint64_t lp_l_id;
 
-	/* Index of layer from the composite layout. */
+	/** Index of layer from the composite layout. */
 	uint32_t lp_layer_idx;
 
 	/** Filler since prefix is a 128 bit field; currently un-used. */
 	uint32_t lp_filler;
 };
 
+/**
+ * Types of extents belonging to a particular layer of a particular composite
+ * layout.
+ *
+ * Value of this enum is stored along with each extent of each layer from
+ * every composite layoout.
+ */
+enum layer_extent_type {
+	/**
+	 * Normal extent associated with a particular layer. All extents with
+	 * this value belong to the layer they are associated with.
+	 */
+	LRET_VALID,
+	/**
+	 * This value is used to tag an extent that does not belong to the
+	 * layer's address-space. For example, an extent (0, C2_BINDEX_MAX + 1)
+	 * would be LRET_NONE for 'the zeroth layer that does not contain any
+	 * extents'.
+	 */
+	LRET_NONE,
+	/**
+	 * This value is used to tag a hole in the layer.
+	 */
+	LRET_HOLE
+};
+
 C2_TL_DESCR_DEFINE(c2_layer, "composite-layer-list", /* global */,
 		   struct c2_composite_layer, clr_list_linkage, clr_magic,
 		   C2_LAYOUT_COMP_SUBL_MAGIC, C2_LAYOUT_COMP_SUBL_HEAD_MAGIC);
@@ -110,6 +199,7 @@ static bool composite_invariant(const struct c2_composite_layout *cl)
 		c2_composite_layout_bob_check(cl) &&
 		c2_layout__invariant(&cl->cl_base) &&
 		cl->cl_layers != NULL &&
+		cl->cl_layers_nr > 0 &&
 		cl->cl_layers_nr == c2_layer_tlist_length(cl->cl_layers) &&
 		c2_tl_forall(c2_layer, layer, cl->cl_layers,
 			     c2_layout__invariant(layer->clr_l) &&
@@ -118,6 +208,7 @@ static bool composite_invariant(const struct c2_composite_layout *cl)
 				  layer->clr_extents == NULL) &&
 			     ergo(layer->clr_idx > 0,
 				  layer->clr_extents != NULL &&
+				  layer->clr_extents_nr > 0 &&
 			          layer->clr_extents_nr ==
 			          c2_layer_extent_tlist_length(
 							layer->clr_extents)));
@@ -184,23 +275,30 @@ static void composite_delete(struct c2_layout *l)
 	C2_LEAVE();
 }
 
+/** Adds a layer to the inmemory version of the composite layout. */
+/* todo rename to layer_in_memory_add. */
 static int layer_entry_add(struct c2_composite_layout *cl,
-			   struct c2_layout *l,
+			   struct c2_layout *sublayout,
 			   struct c2_tl *extlist,
-			   uint32_t ext_nr)
+			   uint32_t ext_nr,
+			   struct c2_composite_layer **lr)
 {
 	struct c2_composite_layer *layer;
 
 	C2_ALLOC_PTR(layer);
 	C2_ASSERT(layer != NULL); //todo handle error
 
-	layer->clr_l = l;
+	layer->clr_l = sublayout;
 	layer->clr_idx = cl->cl_layers_nr++;
-	layer->clr_extents = extlist;
 	layer->clr_extents_nr = ext_nr;
+	layer->clr_extents = extlist;
 	c2_layout_get(layer->clr_l);
 	c2_layout_user_count_inc(layer->clr_l);
 	c2_layer_tlink_init_at_tail(layer, cl->cl_layers);
+	if (lr != NULL)
+		*lr = layer;
+	C2_POST(composite_invariant(cl));
+	C2_POST(ergo(ext_nr > 0, cl->cl_layers_nr > 1));
 	return 0;
 }
 
@@ -214,7 +312,7 @@ static void composite_populate(struct c2_composite_layout *cl,
 	C2_ENTRY("lid %llu", (unsigned long long)cl->cl_base.l_id);
 	c2_layout__populate(&cl->cl_base, user_count);
 
-	rc = layer_entry_add(cl, oldlayout, NULL, 0);
+	rc = layer_entry_add(cl, oldlayout, NULL, 0, NULL);
 	C2_ASSERT(rc == 0); //todo Handle error, change ret type to int
 
 	C2_POST(composite_invariant(cl));
@@ -236,7 +334,7 @@ int c2_composite_build(struct c2_layout_domain *dom,
 
 	rc = composite_allocate(dom, lid, &l);
 	if (rc == 0) {
-		/* Here, composite_allocate() has locked l->l_lock. */
+		/* Now, composite_allocate() has locked l->l_lock. */
 		cl = bob_of(l, struct c2_composite_layout, cl_base,
 			    &composite_bob);
 		C2_ASSERT(composite_allocated_invariant(cl));
@@ -270,7 +368,7 @@ static void composite_fini(struct c2_ref *ref)
 	cl = c2_layout_to_cl(l);
 	c2_composite_layout_bob_fini(cl);
 
-	i = 0;
+	i = 0; //rm and i and use layer->clr_idx instead
 	c2_tl_for(c2_layer, cl->cl_layers, layer) {
 		if (i > 0) { /* Except for the zeroth layer. */
 			c2_tl_for(c2_layer_extent, layer->clr_extents,
@@ -282,14 +380,10 @@ static void composite_fini(struct c2_ref *ref)
 			c2_free(layer->clr_extents);
 		}
 		/*
-		 * Decrement the user count incremented either by
-		 * c2_composite_build() or by c2_composite_layer_add().
+		 * Decrement the user count incremented by layer_entry_add().
 		 */
 		c2_layout_user_count_dec(layer->clr_l);
-		/*
-		 * Release the reference acquired either by
-		 * c2_composite_build() or by c2_composite_layer_add().
-		 */
+		/* Release the reference acquired by layer_entry_add(). */
 		c2_layout_put(layer->clr_l);
 		c2_layer_tlist_del(layer);
 		c2_layer_tlink_fini(layer);
@@ -303,32 +397,6 @@ static void composite_fini(struct c2_ref *ref)
 	C2_LEAVE();
 }
 
-int c2_composite_layer_add(struct c2_composite_layout *cl,
-			   struct c2_layout *sublayout,
-			   struct c2_tl *extlist,
-			   uint32_t ext_nr)
-{
-	int rc;
-
-	C2_PRE(composite_invariant(cl));
-	C2_PRE(c2_mutex_is_locked(&cl->cl_base.l_lock));
-	C2_PRE(extlist != NULL);
-
-	C2_ENTRY();
-	if (c2_layer_extent_tlist_is_empty(extlist)) {
-		//todo ADDB, TRACE rec etc
-		return -EINVAL;
-	}
-
-	rc = layer_entry_add(cl, sublayout, extlist, ext_nr);
-	C2_ASSERT(rc == 0); //todo Handle error
-
-	//todo This op has to sync up the on-disk db
-
-	C2_LEAVE(); //todo addb record
-	return 0;
-}
-
 struct c2_composite_layout *c2_layout_to_cl(const struct c2_layout *l)
 {
 	struct c2_composite_layout *cl;
@@ -374,10 +442,15 @@ err1_injected:
 		return -ENOMEM;
 	}
 
+	rc = c2_table_init(&csd->csd_layer_sublayout, dom->ld_dbenv,
+			   "layer_sublayout", DEFAULT_DB_FLAG,
+			   &composite_table_ops);
+	C2_ASSERT(rc == 0); //todo Handle error etc.
+
 	if (C2_FI_ENABLED("emap_init_err"))
 		{ rc = -EEXIST; goto err2_injected; }
-	rc = c2_emap_init(&csd->csd_comp_layout_ext_map, dom->ld_dbenv,
-			  "comp_layout_ext_map");
+	rc = c2_emap_init(&csd->csd_layer_ext_map, dom->ld_dbenv,
+			  "layer_ext_map");
 err2_injected:
 	if (rc == 0)
 		dom->ld_type_data[lt->lt_id] = csd;
@@ -402,7 +475,8 @@ static void composite_unregister(struct c2_layout_domain *dom,
 
 	C2_ENTRY("Layout_type_id %lu", (unsigned long)lt->lt_id);
 	csd = dom->ld_type_data[lt->lt_id];
-	c2_emap_fini(&csd->csd_comp_layout_ext_map);
+	c2_table_fini(&csd->csd_layer_sublayout);
+	c2_emap_fini(&csd->csd_layer_ext_map);
 	dom->ld_type_data[lt->lt_id] = NULL;
 	c2_free(csd);
 	C2_LEAVE("Layout_type_id %lu", (unsigned long)lt->lt_id);
@@ -416,434 +490,558 @@ static c2_bcount_t composite_max_recsize(struct c2_layout_domain *dom)
 
 static void prefix_set(struct layout_prefix *prefix,
 		       uint64_t composite_lid,
-		        uint32_t layer_idx)
+		       uint32_t layer_idx)
 {
 	prefix->lp_l_id = composite_lid;
 	prefix->lp_layer_idx = layer_idx;
 	prefix->lp_filler = 0;
 }
 
-//todo look for sub-layout, sub_layout, sublayouts and similar instances and remove those. Also from the ut/composite.c.
+//todo look for the strings sub-layout, sub_layout, sublayouts and similar instances and remove those. Also from the ut/composite.c.
 
 #if 0
-static int sublayouts_read(struct c2_composite_layout *cl,
-			   struct c2_tl *sub_layouts, uint32_t *nr,
+static int layer_extent_free(struct c2_composite_layer *layer,
+			     struct c2_ext *ext)
+{
+	return 0;
+}
+
+static int seg_free(struct c2_composite_layer *layer,
+		    const struct c2_emap_seg *seg,
+		    const struct c2_ext *ext,
+		    uint64_t val)
+{
+	c2_bcount_t delta = ext->e_start - seg->ee_ext.e_start;
+	struct c2_ext tocut = {
+		.e_start = val + delta,
+		.e_end = val + delta + c2_ext_length(ext)
+	};
+	//return val < LRET_MIN ? ad_free(cl, &tocut) : 0;
+	return val == 0 ? layer_extent_free(layer, &tocut) : 0;
+}
+
+static int extent_adjust(struct c2_emap_cursor *it,
+			 struct c2_composite_layer *layer,
+			 struct c2_ext *ext
+			 /* todo seg state */)
+{
+	int rc;
+
+	C2_LOG(C2_DEBUG, "layer idx %lu, e_start %llu, e_end %llu",
+	       (unsigned long)layer->clr_idx,
+	       (unsigned long long)ext->e_start,
+	       (unsigned long long)ext->e_end);
+
+	rc = c2_emap_paste(it, ext, /* todo LRET_MIN */,
+			   LAMBDA(void, (struct c2_emap_seg *seg) {
+				/* Handle extent deletion. */
+				rc = rc ?: seg_free(layer, seg,
+				//todo optimize number of args ?
+						    &seg->ee_ext, seg->ee_val);
+			   }),
+			   LAMBDA(void, (struct c2_emap_seg *seg,
+					 struct c2_ext *ext,
+					 uint64_t val) {
+				/* Cut left. */
+				C2_ASSERT(ext->e_start > seg->ee_ext.e_start);
+				seg->ee_val = val;
+				rc = rc ?: seg_free(layer, seg, ext, val);)
+			   }),
+			   LAMBDA(void, (struct c2_emap_seg *seg,
+					 struct c2_ext *ext,
+					 uint64_t val) {
+				/* Cur right. */
+				C2_ASSERT(seg->ee_ext.e_end > ext->e_end);
+				if (val > 0) {
+					seg->ee_val = val +
+						      (ext->e_end -
+
+/*						       seg->ee_ext.e_start);
+---if 0
+//from ad.c, tune it.
+					*
+					 * Free physical sub-extent, but only
+					 * when sub-extent starts at the left
+					 * boundary of the logical extent,
+					 * because otherwise "cut left" already
+					 * freed it.
+					 *
+					if (ext->e_start ==
+					    seg->ee_ext.e_start)
+						rc = rc ?: seg_free(io, adom,
+								    seg, ext,
+								    val);
+---endif
+*/
+				} else
+					seg->ee_val = val;
+			   }));
+	C2_ASSERT(rc == 0); //todo Handle error
+	return rc;
+}
+#endif
+
+static int sublayout_id_in_db_read(struct composite_schema_data *csd,
+				   struct c2_db_tx *tx,
+				   uint64_t composite_lid,
+				   uint32_t layer_idx,
+				   uint64_t *sublayout_id)
+{
+	struct c2_db_pair          pair;
+	struct layer_sublayout_key key;
+	struct layer_sublayout_rec rec;
+	int                        rc;
+
+	key.lrsmk_comp_lid = composite_lid;
+	key.lrsmk_layer_idx = layer_idx;
+	key.lrsmk_pad = 0;
+	rec.lrsmr_sublayout_lid = 0; /* This will be overwritten. */
+	c2_db_pair_setup(&pair, &csd->csd_layer_sublayout,
+			 &key, sizeof key, &rec, sizeof rec);
+	rc = c2_table_lookup(tx, &pair);
+	C2_ASSERT(rc == 0); //todo Handle error
+	C2_ASSERT(rec.lrsmr_sublayout_lid > 0);
+	c2_db_pair_fini(&pair);
+	*sublayout_id = rec.lrsmr_sublayout_lid;
+	return rc;
+}
+
+static int sublayout_id_in_db_write(struct composite_schema_data *csd,
+				    struct c2_db_tx *tx,
+				    const struct c2_composite_layout *cl,
+				    const struct c2_composite_layer *layer)
+{
+	uint64_t                   sublayout_id;
+	struct c2_db_pair          pair;
+	struct layer_sublayout_key key;
+	struct layer_sublayout_rec rec;
+	int                        rc;
+
+	if (layer->clr_idx > 0) {
+		/*
+		 * Verify that the sublayout for the zeroth layer has already
+		 * been written to the DB. It ensures that the zeroth layer
+		 * has already been added to the DB as a part of writing the
+		 * composite layout to the DB, by using the API
+		 * c2_layout_add().
+		 */
+		rc = sublayout_id_in_db_read(csd, tx, cl->cl_base.l_id, 0,
+					     &sublayout_id);
+		if (rc != 0) {
+			/*
+			 * todo ADDB rec etc, indicating the composite layout
+			 * does not seem to be added to the DB.
+			 */
+		}
+		C2_ASSERT(rc == 0); //todo rm once handled above
+		C2_ASSERT(sublayout_id > 0);
+	}
+
+	/*
+	 * Now, proceed to write the sublayout id for the layer->clr_idx'th
+	 * layer.
+	 */
+	key.lrsmk_comp_lid = cl->cl_base.l_id;
+	key.lrsmk_layer_idx = layer->clr_idx;
+	key.lrsmk_pad = 0;
+	rec.lrsmr_sublayout_lid = layer->clr_l->l_id;
+	c2_db_pair_setup(&pair, &csd->csd_layer_sublayout,
+			 &key, sizeof key, &rec, sizeof rec);
+	rc = c2_table_insert(tx, &pair);
+	C2_ASSERT(rc == 0); //todo Handle error
+	c2_db_pair_fini(&pair);
+	return rc;
+}
+
+static int layer_in_db_add(const struct c2_composite_layout *cl,
+			   const struct c2_composite_layer *layer,
 			   struct c2_db_tx *tx)
 {
-	struct c2_composite_layer      *layer;
-	struct composite_schema_data   *csd;
-	struct c2_emap                 *emap;
-	struct c2_emap_cursor           it;
-	struct c2_emap_seg             *seg;
-	c2_bcount_t                     total;
-	struct layout_prefix            prefix;
-	uint32_t                        sublayouts_nr;//todo rm since in invar
-	int                             rc;
+	struct composite_schema_data     *csd;
+	struct c2_emap                   *emap;
+	struct c2_composite_layer_extent *extent;
+	struct c2_emap_cursor             it;
+	struct c2_emap_seg               *seg;
+	struct layout_prefix              prefix;
+	int                               rc;
+
+	C2_PRE(layer->clr_idx > 0);
+	C2_PRE(tx != NULL);
 
 	csd = cl->cl_base.l_dom->ld_type_data[c2_composite_layout_type.lt_id];
-	emap = &csd->csd_comp_layout_ext_map;
-	prefix.lp_l_id = cl->cl_base.l_id;
-	//todo set the layer id
-	prefix.lp_filler = 0; //todo Add a wrapper to set prefix
 
-	/* Set up an emap cursor. */
-	rc = c2_emap_lookup(emap, tx, (struct c2_uint128 *)&prefix, 0, &it);
-	C2_ASSERT(rc == 0); //todo handle err
+	/* Write 'the sublayout id for this layer' to the DB. */
+	rc = sublayout_id_in_db_write(csd, tx, cl, layer);
+	C2_ASSERT(rc == 0); //todo Handle
 
-	/*
-	 * Read all the layers from the emap cursor and store them in the
-	 * sub_layouts list.
+	/* Write 'the extent map for this layer' to the DB. */
+	/**
+	 * @todo In fact, there are no valid extents associated with layer 0.
+	 * So, do we need to make this extent entry with LRET_NONE state to the
+	 * layer_ext_map table?
 	 */
-	sublayouts_nr = 0;
-	total         = 0;
+	emap = &csd->csd_layer_ext_map;
+	prefix_set(&prefix, cl->cl_base.l_id, layer->clr_idx);
+	rc = c2_emap_obj_insert(emap, tx, (struct c2_uint128 *)&prefix,
+				LRET_NONE);
+	C2_ASSERT(rc == 0 || rc == -EEXIST); //todo handle err
+	if (rc == -EEXIST)
+		return rc; //ADDB rec etc.
+
+	rc = c2_emap_lookup(emap, tx, (struct c2_uint128 *)&prefix, 0, &it);
+	C2_ASSERT(rc == 0); //todo handle err
 	seg = c2_emap_seg_get(&it);
-	C2_ASSERT(c2_emap_ext_is_first(&seg->ee_ext));
+	C2_ASSERT(seg->ee_ext.e_start == 0);
+	C2_ASSERT(seg->ee_ext.e_end == C2_BINDEX_MAX + 1);
+	C2_ASSERT(seg->ee_val == LRET_NONE);
 
-	C2_LOG(C2_DEBUG, "Composite lid %llu, layer: ",
-	       (unsigned long long)cl->cl_base.l_id);
+	C2_LOG(C2_DEBUG, "layer[%lu]: sublayout_lid %llu",
+	       (unsigned long)layer->clr_idx,
+	       (unsigned long long)layer->clr_l->l_id);
 
-	while (1) {
-		seg = c2_emap_seg_get(&it);
-		C2_ALLOC_PTR(layer);
-		C2_ASSERT(layer != NULL); //todo handle error
+	c2_tl_for(c2_layer_extent, layer->clr_extents, extent) {
 #if 0
-		layer->clr_l = c2_layout_lookup(cl->cl_base.l_dom, seg->ee_val,
-					     &c2_pdclust_layout_type /* todo*/,
-					     tx,);
-		/* todo What to do if the layout is not cached?
-		 * lookup requires layout type to be stored.
-		 */
+		rc = extent_adjust(&it, &extent->cle_ext
+				   /* , seg state */);
+		C2_ASSERT(rc == 0); //todo Handle
 #endif
-		layer->clr_l = c2_layout_find(cl->cl_base.l_dom, seg->ee_val);
-		C2_ASSERT(layer->clr_l != NULL); //todo Handle err
-		c2_layout_user_count_inc(layer->clr_l); //todo Optimise code
-		C2_ASSERT(!c2_ext_is_empty(&seg->ee_ext));
-		layer->clr_ext = seg->ee_ext;
-		c2_layer_tlink_init_at_tail(layer, sub_layouts);
+	} c2_tl_endfor;
+	c2_emap_close(&it);
+
+	return rc;
+}
 
-		C2_LOG(C2_DEBUG, "Sub-layout[%lu]: lid %llu, "
-		       "e_start %llu, e_end %llu",
-		       (unsigned long)sublayouts_nr,
-		       (insigned long long)layer->clr_l->l_id,
-		       (unsigned long long)layer->clr_ext.e_start,
-		       (unsigned long long)layer->clr_ext.e_end);
+int c2_composite_layer_add(struct c2_composite_layout *cl,
+			   struct c2_layout *sublayout,
+			   struct c2_tl *extlist,
+			   uint32_t ext_nr,
+			   struct c2_db_tx *tx)
+{
+	struct c2_composite_layer *layer;
+	int                        rc;
 
-		total = total + layer->clr_ext.e_end - layer->clr_ext.e_start;
-				//todo Why + 1 is not req'd
-		++sublayouts_nr;
+	C2_PRE(composite_invariant(cl));
+	C2_PRE(c2_mutex_is_locked(&cl->cl_base.l_lock));
+	C2_PRE(c2_layout__invariant(sublayout));
+	C2_PRE(extlist != NULL);
 
-		if (c2_emap_ext_is_last(&seg->ee_ext))
-			break;
-		else
-			c2_emap_next(&it);
+	C2_ENTRY();
+	if (c2_layer_extent_tlist_is_empty(extlist) || ext_nr == 0) {
+		//todo ADDB, TRACE rec etc
+		return -EINVAL;
 	}
-	C2_ASSERT(total == C2_BCOUNT_MAX);
-	*nr = sublayouts_nr; //todo
 
-	c2_emap_close(&it);
+	rc = layer_entry_add(cl, sublayout, extlist, ext_nr, &layer);
+	C2_ASSERT(rc == 0); //todo Handle error
+	C2_ASSERT(layer->clr_idx > 0);
+
+	if (tx == NULL)
+		return rc; //todo Handle. What user space code shall do?
+
+	/*
+	 * todo If the DB is accessible (cl->cl_base.l_dom->ld_is_DB_available),
+	 * add the layer to the DB.
+	 */
+	rc = layer_in_db_add(cl, layer, tx);
+
+	C2_LEAVE(); //todo addb record
 	return rc;
 }
-#endif
-
-static const struct c2_layout_ops composite_ops;
 
-/** Implementation of lo_decode() for composite layout type. */
-static int composite_decode(struct c2_layout *l,
-			    struct c2_bufvec_cursor *cur,
-			    enum c2_layout_xcode_op op,
-			    struct c2_db_tx *tx,
-			    uint32_t user_count)
+/**
+ * Parses 'the composite layout type specific information including all the
+ * layers' from the buffer provided and adds it to the inmemory version of the
+ * composite layout.
+ */
+static int composite_layout_in_cursor_read(struct c2_composite_layout *cl,
+					   struct c2_bufvec_cursor *cur,
+					   uint32_t user_count)
 {
-	struct c2_composite_layout       *cl;
-	struct c2_layout                 *sublayout;
-	struct c2_tl                     *extents;
 	struct composite_header          *cl_header;
 	struct composite_layer_header    *layer_header;
+	struct c2_layout                 *sublayout;
 	struct c2_composite_layer_extent *extent;
 	struct c2_ext                    *ext;
+	struct c2_tl                     *extents;
 	uint32_t                          i;
 	uint32_t                          j;
 	int                               rc;
 
-	C2_PRE(c2_layout__allocated_invariant(l));
+	C2_PRE(composite_allocated_invariant(cl));
 	C2_PRE(cur != NULL);
 	C2_PRE(c2_bufvec_cursor_step(cur) >= sizeof *cl_header);
-	C2_PRE(C2_IN(op, (C2_LXO_DB_LOOKUP, C2_LXO_BUFFER_OP)));
-	C2_PRE(ergo(op == C2_LXO_DB_LOOKUP, tx != NULL));
 
-	C2_ENTRY("lid %llu", (unsigned long long)l->l_id);
-	cl = bob_of(l, struct c2_composite_layout, cl_base, &composite_bob);
-	C2_PRE(composite_allocated_invariant(cl));
+	C2_ENTRY("lid %llu", (unsigned long long)cl->cl_base.l_id);
 
 	cl_header = c2_bufvec_cursor_addr(cur);
 	c2_bufvec_cursor_move(cur, sizeof *cl_header);
 	C2_ASSERT(c2_bufvec_cursor_step(cur) >=
 		  cl_header->ch_layers_nr * sizeof *layer_header);
 
-
-	if (op == C2_LXO_BUFFER_OP) {
-		/*
-		 * Parse the layers information from the buffer pointed by
-		 * cur and add those layers to the composite layout.
+	for (i = 0; i < cl_header->ch_layers_nr; ++i) {
+		layer_header = c2_bufvec_cursor_addr(cur);
+		c2_bufvec_cursor_move(cur, sizeof *layer_header);
+		sublayout = c2_layout_find(cl->cl_base.l_dom,
+					   layer_header->clh_lid);
+		C2_ASSERT(sublayout != NULL);
+		/**
+		 * @todo Eventually, if the layout is not found in the cache,
+		 * it shall be fetched either from the DB or over the network,
+		 * as applicable. This needs the layout id to be extended to
+		 * 128 bit to store the layout type.
 		 */
-		for (i = 0; i < cl_header->ch_layers_nr; ++i) {
-			layer_header = c2_bufvec_cursor_addr(cur);
-			c2_bufvec_cursor_move(cur, sizeof *layer_header);
-			sublayout = c2_layout_find(l->l_dom,
-						   layer_header->clh_lid);
-			if (sublayout == NULL) {
-				/**
-				 * todo Handle error. Eventually the layout
-				 * should be fetched either from the DB or
-				 * over the network, as applicable.
-				 */
-			}
-			C2_ASSERT(sublayout != NULL);
-			C2_ASSERT(layer_header->clh_idx == i);
-			if (layer_header->clh_idx == 0) { /* Zeroth layer */
-				composite_populate(cl, user_count, sublayout);
-				C2_ASSERT(composite_invariant(cl));
-			} else {
-				C2_ALLOC_PTR(extents);
-				if (extents == NULL) {
-					//todo Handle error
-	#if 0 //tune
-					c2_layout__log("composite_decode",
-						       "C2_ALLOC_PTR() failed",
-						       &c2_addb_oom, &l->l_addb,
-						       l->l_id, -ENOMEM);
-					return -ENOMEM;
-	#endif
-				}
-				c2_layer_extent_tlist_init(extents);
-
-				C2_ASSERT(c2_bufvec_cursor_step(cur) >=
-					  layer_header->clh_extents_nr *
-					  sizeof *ext);
-
-				for (j = 0; j < layer_header->clh_extents_nr;
-				     ++j) {
-					C2_ALLOC_PTR(extent);
-					if (extent == NULL) {
-						//todo Handle error
-					}
-					ext = c2_bufvec_cursor_addr(cur);
-					c2_bufvec_cursor_move(cur, sizeof *ext);
-					extent->cle_ext = *ext;
-					c2_layer_extent_tlink_init_at_tail(
-								      extent,
-								      extents);
-				}
 
-				//C2_ASSERT(l->l_user_count > 0); //todo
-				rc = c2_composite_layer_add(cl, sublayout,
-						extents,
-						layer_header->clh_extents_nr);
-				C2_ASSERT(rc == 0); //todo Handle error
+		C2_ASSERT(layer_header->clh_idx == i);
+		if (layer_header->clh_idx == 0) { /* Zeroth layer */
+			composite_populate(cl, user_count, sublayout);
+			C2_ASSERT(composite_invariant(cl));
+		} else {
+			C2_ALLOC_PTR(extents);
+			if (extent == NULL) {
+				//todo Handle error
 			}
+			c2_layer_extent_tlist_init(extents);
+			C2_ASSERT(c2_bufvec_cursor_step(cur) >=
+				  layer_header->clh_extents_nr * sizeof *ext);
 
 			/*
-			 * Release the reference added by c2_layout_find().
-			 * c2_composite_layer_add() has added a reference on
-			 * this sublayout.
+			 * Read the extent list owned by this particular layer.
 			 */
-			c2_layout_put(sublayout);
+			for (j = 0; j < layer_header->clh_extents_nr; ++j) {
+				C2_ALLOC_PTR(extent);
+				if (extent == NULL) {
+					//todo Handle error
+				}
+				ext = c2_bufvec_cursor_addr(cur);
+				c2_bufvec_cursor_move(cur, sizeof *ext);
+				extent->cle_ext = *ext;
+				c2_layer_extent_tlink_init_at_tail(extent,
+								   extents);
+			}
+
+			rc = c2_composite_layer_add(cl, sublayout, extents,
+						  layer_header->clh_extents_nr,
+						  NULL);
+			C2_ASSERT(rc == 0); //todo Handle error
 		}
-	} else {
+
 		/*
-		 * Read all the layers from the layout DB and store them
-		 * in the layers list.
+		 * Release the reference added by c2_layout_find().
+		 * c2_composite_layer_add() has added a reference on this
+		 * sublayout.
 		 */
-		//rc = sublayouts_read(cl, sub_layouts, &nr, tx);
-		//C2_ASSERT(rc == 0); //todo Handle err
-		C2_ASSERT(0);
+		c2_layout_put(sublayout);
 	}
-
-	rc = 0; //todo
-	C2_POST(ergo(rc == 0, composite_invariant(cl)));
-	C2_POST(ergo(rc != 0, composite_allocated_invariant(cl)));
-	C2_LEAVE("lid %llu, rc %d", (unsigned long long)l->l_id, rc);
 	return rc;
 }
 
-static int sublayouts_write(struct c2_composite_layout *cl,
-			    enum c2_layout_xcode_op op,
-			    struct c2_db_tx *tx)
+/**
+ * Reads 'the composite layout type specific information including all the
+ * layers' from the DB and adds it to the inmemory version of the composite
+ * layout.
+ */
+static int composite_layout_in_db_read(struct c2_composite_layout *cl,
+				       struct c2_db_tx *tx,
+				       uint32_t user_count)
 {
-	struct composite_schema_data   *csd;
-	struct c2_emap                 *emap;
-	struct c2_composite_layer      *layer;
-	//struct c2_emap_cursor           it;
-	//struct c2_emap_seg             *seg;
-	//c2_bcount_t                     total;
-	struct layout_prefix            prefix;
-#if 0
-	uint32_t                        sublayouts_nr;//todo rm since in invar
-	c2_bcount_t                     len[cl->cl_nr];
-	uint64_t                        val[cl->cl_nr];
-#endif
-	int                             rc;
-#if 0
-	struct c2_indexvec vec = {
-		.iv_vec = {
-			.v_nr    = ARRAY_SIZE(len),
-			.v_count = len
-		},
-		.iv_index = val
-	};
-#endif
-
-	C2_PRE(C2_IN(op, (C2_LXO_DB_ADD, C2_LXO_DB_DELETE)));
+	struct composite_schema_data     *csd;
+	struct c2_emap                   *emap;
+	struct c2_emap_cursor             it;
+	struct layout_prefix              prefix;
+	uint64_t                          sublayout_id;
+	struct c2_layout                 *sublayout;
+	struct c2_emap_seg               *seg;
+	struct c2_tl                     *extents;
+	uint32_t                          extents_nr;
+	struct c2_composite_layer_extent *extent;
+	uint32_t                          i;
+	int                               rc;
 
+	C2_ENTRY("lid %llu", (unsigned long long)cl->cl_base.l_id);
 	csd = cl->cl_base.l_dom->ld_type_data[c2_composite_layout_type.lt_id];
-	emap = &csd->csd_comp_layout_ext_map;
 
-	if (op == C2_LXO_DB_ADD) {
-		/* todo Use c2_layer_tlist_head(cl->cl_layers) instead */
-		/*
-		 * Collect the old layout id by referring to the zeroth (bottom
-		 * most) layer from the composite layout.
-		 */
-		c2_tl_for(c2_layer, cl->cl_layers, layer) {
-			C2_ASSERT(layer->clr_idx == 0);
-			C2_ASSERT(layer->clr_extents_nr == 0);
-			C2_ASSERT(layer->clr_l->l_id > 0); /* old layout id */
-			break; /* Break after reading the zeroth layer. */
-		} c2_tl_endfor;
+	rc = sublayout_id_in_db_read(csd, tx, cl->cl_base.l_id, 0,
+				     &sublayout_id);
+	C2_ASSERT(rc == 0); /* todo Handle error */
 
-		/* Add the zeroth layer to the layout database. */
-		//todo Add a wrapper to set prefix
+	sublayout = c2_layout_find(cl->cl_base.l_dom, sublayout_id);
+	C2_ASSERT(sublayout != NULL);
+	/**
+	 * @todo Eventually, if the layout is not found in the cache,
+	 * it shall be fetched either from the DB or over the network,
+	 * as applicable. This needs the layout id to be extended to
+	 * 128 bit to store the layout type.
+	 */
 
-		prefix_set(&prefix, cl->cl_base.l_id,
-			   layer->clr_idx /* Zeroth layer */);
-#if 0
-		prefix.lp_l_id = cl->cl_base.l_id;
-		prefix.lp_layer_idx = layer->clr_idx; /* Zeroth layer. */
-		prefix.lp_filler = 0;
-#endif
-		rc = c2_emap_obj_insert(emap, tx, (struct c2_uint128 *)&prefix,
-					layer->clr_l->l_id /* old layout id */);
-		C2_ASSERT(rc == 0 || rc == -EEXIST); //todo handle err
-		if (rc == -EEXIST)
-			return rc;
+	composite_populate(cl, user_count, sublayout);
+	C2_ASSERT(composite_invariant(cl));
 
-#if 0
-		total = 0;
-		sublayouts_nr = 0;
-		C2_LOG(C2_DEBUG, "Composite lid %llu, layer: ",
-		       (unsigned long long)l->l_id);
+	/*
+	 * Release the reference added by c2_layout_find().
+	 * composite_populate() has now added a reference on this sublayout.
+	 */
+	c2_layout_put(sublayout);
 
-		c2_tl_for(c2_layer, cl->cl_layers, layer) {
-			C2_LOG(C2_DEBUG, "Sub-layout[%lu]: lid %llu, "
-			       "e_start %llu, e_end %llu",
-			       (unsigned long)sublayouts_nr,
-			       (unsigned long long)layer->clr_l->l_id,
-			       (unsigned long long)layer->clr_ext.e_start,
-			       (unsigned long long)layer->clr_ext.e_end);
-
-			len[sublayouts_nr] = layer->clr_ext.e_end -
-					     layer->clr_ext.e_start + 1;
-			val[sublayouts_nr] = layer->clr_l->l_id;
-			total              = total + len[sublayouts_nr];
-			++sublayouts_nr;
-		} c2_tl_endfor;
-		C2_ASSERT(sublayouts_nr == cl->cl_nr);
-#endif
-	}
+	/* todo Nov 28 seg->ee_val shall not be read as sublayout-id but
+	 * the sublayout-id shall be read from another table.
+	 */
 
-#if 0
-	/* Set up an emap cursor. */
-	rc = c2_emap_lookup(emap, tx, (struct c2_uint128 *)&prefix, 0, &it);
-	C2_ASSERT(rc == 0); //todo handle err
-	seg = c2_emap_seg_get(&it);
+	/* Now, proceed to read the subsequent layers from the DB. */
+	emap = &csd->csd_layer_ext_map;
+	i = 1;
+	//todo This fn shall accept layers_nr which is to be stored in the
+	//layouts table.
+	while (1) {
+		prefix_set(&prefix, cl->cl_base.l_id, i);
+		rc = c2_emap_lookup(emap, tx, (struct c2_uint128 *)&prefix,
+				    0, &it);
+		if (rc != 0) //todo Handle err
+			break;
 
-	if (op == C2_LXO_DB_ADD) {
-		C2_ASSERT(c2_emap_ext_is_first(&seg->ee_ext)); //todo rm
-		C2_ASSERT(c2_emap_ext_is_last(&seg->ee_ext)); //todo rm
-		C2_ASSERT(total == c2_ext_length(&seg->ee_ext));
+		seg = c2_emap_seg_get(&it);
+		C2_ASSERT(!c2_ext_is_empty(&seg->ee_ext));
 
-		rc = c2_emap_split(&it, &vec);
-		C2_ASSERT(rc == 0); //todo Handle
+		sublayout = c2_layout_find(cl->cl_base.l_dom, seg->ee_val);
+		C2_ASSERT(sublayout != NULL);
+		/**
+		 * @todo Eventually, if the layout is not found in the cache,
+		 * it shall be fetched either from the DB or over the network,
+		 * as applicable. This needs the layout id to be extended to
+		 * 128 bit to store the layout type.
+		 */
 
-		c2_emap_close(&it);
-	} else { /* op == C2_LXO_DB_DELETE) */
-		/* todo This should happen on input from the user. */
-		while (!c2_emap_ext_is_last(&seg->ee_ext)) {
-			rc = c2_emap_merge(&it, c2_ext_length(&seg->ee_ext));
-			C2_ASSERT(rc == 0); //todo handle err
-		}
+		C2_LOG(C2_DEBUG, "composite_lid %llu, layer[%lu]: "
+		       "sublayout_lid %llu",
+		       (unsigned long long)cl->cl_base.l_id, (unsigned long)i,
+		       (unsigned long long)sublayout->l_id);
+
+		/* Read the extents associated with this layer. */
+		C2_ALLOC_PTR(extents);
+		C2_ASSERT(extents != NULL); //todo Handle error
+		c2_layer_extent_tlist_init(extents);
+
+		C2_ASSERT(!c2_emap_ext_is_last(&seg->ee_ext)); //todo Handle
+				//error and retun -EINVAL ?
+		extents_nr = 0;
+		while (1) {
+			C2_ALLOC_PTR(extent);
+			C2_ASSERT(extent != NULL); //todo Handle error
+			extent->cle_ext = seg->ee_ext;
+			c2_layer_extent_tlink_init_at_tail(extent, extents);
+			C2_LOG(C2_DEBUG, "layer[%lu], extent[%lu] "
+			       "e_start %llu, e_end %llu",
+			       (unsigned long)i,
+			       (unsigned long)extents_nr,
+			       (unsigned long long)seg->ee_ext.e_start,
+			       (unsigned long long)seg->ee_ext.e_end);
+
+			++extents_nr;
+			if (c2_emap_ext_is_last(&seg->ee_ext))
+				break;
 
-		rc = c2_emap_obj_delete(emap, tx,
-					(struct c2_uint128 *)&prefix);
+			c2_emap_next(&it);
+			seg = c2_emap_seg_get(&it);
+			C2_ASSERT(seg != NULL);
+			C2_ASSERT(seg->ee_val == sublayout->l_id);
+		}
 		c2_emap_close(&it);
-		C2_ASSERT(rc == 0); //todo handle err
+		C2_ASSERT(!c2_layer_extent_tlist_is_empty(extents));
+
+		rc = layer_entry_add(cl, sublayout, extents, extents_nr, NULL);
+		C2_ASSERT(rc == 0); //todo Handle error
+
+		/*
+		 * Release the reference added by c2_layout_find().
+		 * layer_entry_add() has now added a reference on this
+		 * sublayout.
+		 */
+		c2_layout_put(sublayout);
+
+		++i;
 	}
-#endif
 
+	rc = 0; //todo Check
 	return rc;
 }
 
-#if 0
-static int sublayouts_write(struct c2_layout *l, //layers_write
-			    struct c2_composite_layout *cl,
+static const struct c2_layout_ops composite_ops;
+
+/** Implementation of lo_decode() for composite layout type. */
+static int composite_decode(struct c2_layout *l,
+			    struct c2_bufvec_cursor *cur,
 			    enum c2_layout_xcode_op op,
-			    struct c2_db_tx *tx)
+			    struct c2_db_tx *tx,
+			    uint32_t user_count)
 {
-	//struct c2_composite_layer      *layer;
-	struct composite_schema_data   *csd;
-	struct c2_emap                 *emap;
-	//struct c2_emap_cursor           it;
-	//struct c2_emap_seg             *seg;
-	//c2_bcount_t                     total;
-	struct layout_prefix            prefix;
-#if 0
-	uint32_t                        sublayouts_nr;//todo rm since in invar
-	c2_bcount_t                     len[cl->cl_nr];
-	uint64_t                        val[cl->cl_nr];
-	int                             rc;
-#endif
-
-#if 0
-	struct c2_indexvec vec = {
-		.iv_vec = {
-			.v_nr    = ARRAY_SIZE(len),
-			.v_count = len
-		},
-		.iv_index = val
-	};
-#endif
+	struct c2_composite_layout *cl;
+	int                         rc;
 
-	C2_PRE(C2_IN(op, (C2_LXO_DB_ADD, C2_LXO_DB_DELETE)));
+	C2_PRE(c2_layout__allocated_invariant(l));
+	C2_PRE(cur != NULL);
+	C2_PRE(C2_IN(op, (C2_LXO_DB_LOOKUP, C2_LXO_BUFFER_OP)));
+	C2_PRE(ergo(op == C2_LXO_DB_LOOKUP, tx != NULL));
 
-	csd  = l->l_dom->ld_type_data[c2_composite_layout_type.lt_id];
-	emap = &csd->csd_comp_layout_ext_map;
-	prefix.lp_l_id   = l->l_id;
-	//todo set layer id
-	prefix.lp_filler = 0; //todo Add a wrapper to set prefix
+	C2_ENTRY("lid %llu", (unsigned long long)l->l_id);
+	cl = bob_of(l, struct c2_composite_layout, cl_base, &composite_bob);
+	C2_PRE(composite_allocated_invariant(cl));
 
-	if (op == C2_LXO_DB_ADD) {
-		rc = c2_emap_obj_insert(emap, tx, (struct c2_uint128 *)&prefix,
-					0);
-		C2_ASSERT(rc == 0 || rc == -EEXIST); //todo handle err
-		if (rc == -EEXIST)
-			return rc;
+	if (op == C2_LXO_BUFFER_OP) {
+		rc = composite_layout_in_cursor_read(cl, cur, user_count);
+		C2_ASSERT(rc == 0); //todo Handle error
+	} else {
+		rc = composite_layout_in_db_read(cl, tx, user_count);
+		C2_ASSERT(rc == 0); //todo Handle err
+	}
 
-#if 0
-		total = 0;
-		sublayouts_nr = 0;
-		C2_LOG(C2_DEBUG, "Composite lid %llu, layer: ",
-		       (unsigned long long)l->l_id);
+	C2_POST(ergo(rc == 0, composite_invariant(cl)));
+	C2_POST(ergo(rc != 0, composite_allocated_invariant(cl)));
+	C2_LEAVE("lid %llu, rc %d", (unsigned long long)l->l_id, rc);
+	return rc;
+}
 
-		c2_tl_for(c2_layer, cl->cl_layers, layer) {
-			C2_LOG(C2_DEBUG, "Sub-layout[%lu]: lid %llu, "
-			       "e_start %llu, e_end %llu",
-			       (unsigned long)sublayouts_nr,
-			       (unsigned long long)layer->clr_l->l_id,
-			       (unsigned long long)layer->clr_ext.e_start,
-			       (unsigned long long)layer->clr_ext.e_end);
-
-			len[sublayouts_nr] = layer->clr_ext.e_end -
-					     layer->clr_ext.e_start + 1;
-			val[sublayouts_nr] = layer->clr_l->l_id;
-			total              = total + len[sublayouts_nr];
-			++sublayouts_nr;
-		} c2_tl_endfor;
-		C2_ASSERT(sublayouts_nr == cl->cl_nr);
-#endif
-	}
+static int composite_layout_in_db_write(struct c2_composite_layout *cl,
+					enum c2_layout_xcode_op op,
+					struct c2_db_tx *tx)
+{
+	struct composite_schema_data *csd;
+	struct c2_emap               *emap;
+	struct c2_composite_layer    *layer;
+	struct layout_prefix          prefix;
+	int                           rc;
 
-#if 0
-	/* Set up an emap cursor. */
-	rc = c2_emap_lookup(emap, tx, (struct c2_uint128 *)&prefix, 0, &it);
-	C2_ASSERT(rc == 0); //todo handle err
-	seg = c2_emap_seg_get(&it);
+	C2_PRE(C2_IN(op, (C2_LXO_DB_ADD, C2_LXO_DB_DELETE)));
+	csd = cl->cl_base.l_dom->ld_type_data[c2_composite_layout_type.lt_id];
+	emap = &csd->csd_layer_ext_map;
 
 	if (op == C2_LXO_DB_ADD) {
-		C2_ASSERT(c2_emap_ext_is_first(&seg->ee_ext)); //todo rm
-		C2_ASSERT(c2_emap_ext_is_last(&seg->ee_ext)); //todo rm
-		C2_ASSERT(total == c2_ext_length(&seg->ee_ext));
+		/*
+		 * Collect the old layout id by referring to the zeroth (bottom
+		 * most) layer from the inmemory version of the composite
+		 * layout.
+		 */
+		layer = c2_layer_tlist_head(cl->cl_layers);
+		C2_ASSERT(layer->clr_idx == 0);
+		C2_ASSERT(layer->clr_extents_nr == 0);
+		C2_ASSERT(layer->clr_l->l_id > 0); /* old layout id */
 
-		rc = c2_emap_split(&it, &vec);
+		/* Write 'the sublayout id for this layer' to the DB. */
+		rc = sublayout_id_in_db_write(csd, tx, cl, layer);
 		C2_ASSERT(rc == 0); //todo Handle
 
-		c2_emap_close(&it);
-	} else { /* op == C2_LXO_DB_DELETE) */
-		/* todo This should happen on input from the user. */
-		while (!c2_emap_ext_is_last(&seg->ee_ext)) {
-			rc = c2_emap_merge(&it, c2_ext_length(&seg->ee_ext));
-			C2_ASSERT(rc == 0); //todo handle err
-		}
-
-		rc = c2_emap_obj_delete(emap, tx,
-					(struct c2_uint128 *)&prefix);
-		c2_emap_close(&it);
-		C2_ASSERT(rc == 0); //todo handle err
+		/* Write 'the extent map for this layer' to the DB. */
+		prefix_set(&prefix, cl->cl_base.l_id, layer->clr_idx);
+		rc = c2_emap_obj_insert(emap, tx, (struct c2_uint128 *)&prefix,
+					LRET_NONE);
+		C2_ASSERT(rc == 0 || rc == -EEXIST); //todo handle err
+		if (rc == -EEXIST)
+			return rc; //ADDB rec etc.
+		C2_LOG(C2_DEBUG, "Composite_lid %llu, layer[0]: "
+		       "sublayout_lid %llu",
+		       (unsigned long long)cl->cl_base.l_id,
+		       (unsigned long long)layer->clr_l->l_id);
 	}
-#endif
-
 	return rc;
 }
-#endif
 
 /** Implementation of lo_encode() for composite layout type. */
 static int composite_encode(struct c2_layout *l,
@@ -872,6 +1070,7 @@ static int composite_encode(struct c2_layout *l,
 		/*
 		 * Read layers information from the composite layout and store
 		 * it in the buffer.
+		 * Move it into layers_in_cursor_write()
 		 */
 		C2_ASSERT(c2_bufvec_cursor_step(out) >= sizeof cl_header);
 		cl_header.ch_layers_nr = cl->cl_layers_nr;
@@ -902,7 +1101,7 @@ static int composite_encode(struct c2_layout *l,
 		/* todo */
 		rc = 0;
 	} else if (op == C2_LXO_DB_ADD || op == C2_LXO_DB_DELETE) {
-		rc = sublayouts_write(cl, op, tx);
+		rc = composite_layout_in_db_write(cl, op, tx);
 		C2_ASSERT(rc == 0 || rc == -EEXIST); //todo Handle err
 	}
 
diff --git a/layout/composite.h b/layout/composite.h
index 1be9cd2..80cd23e 100644
--- a/layout/composite.h
+++ b/layout/composite.h
@@ -67,7 +67,7 @@ struct c2_composite_layout {
  * gets added per failure.
  */
 struct c2_composite_layer {
-	/** Composite Layout this layer is part of. */
+	/** Sublayout associated with this layer. */
 	struct c2_layout *clr_l;
 
 	/**
@@ -85,7 +85,7 @@ struct c2_composite_layer {
 	uint32_t          clr_extents_nr;
 
 	/**
-	 * List of extents (struct c2_sub_layout_extent) owned by this
+	 * List of extents (struct c2_composite_layer_extent) owned by this
 	 * layer.
 	 */
 	struct c2_tl     *clr_extents;
@@ -106,19 +106,21 @@ struct c2_composite_layer {
  */
 struct c2_composite_layer_extent {
 	/** Extent being represented. */
-	struct c2_ext                   cle_ext;
+	struct c2_ext    cle_ext;
+
+	/** todo Add state of the extent ? */
 
 	/**
-	 * Magic number set while c2_sub_layout_extent object is
+	 * Magic number set while c2_composite_layer_extent object is
 	 * initialised.
 	 */
-	uint64_t                        cle_magic;
+	uint64_t         cle_magic;
 
 	/**
 	 * Linkage used for maintaining list of the extents owned by a
 	 * particular sub-layout.
 	 */
-	struct c2_tlink                 cle_list_linkage;
+	struct c2_tlink  cle_list_linkage;
 };
 
 C2_TL_DECLARE(c2_layer, extern, struct c2_composite_layer);
@@ -147,10 +149,12 @@ int c2_composite_build(struct c2_layout_domain *dom,
 		       struct c2_composite_layout **out);
 
 /** Adds a layer to the composite layout. */
+/* todo Add op as another arg? */
 int c2_composite_layer_add(struct c2_composite_layout *cl,
 			   struct c2_layout *l,
 			   struct c2_tl *extlist,
-			   uint32_t ext_nr);
+			   uint32_t ext_nr,
+			   struct c2_db_tx *tx);
 
 struct c2_composite_layout *c2_layout_to_cl(const struct c2_layout *l);
 struct c2_layout *c2_cl_to_layout(struct c2_composite_layout *cl);
diff --git a/layout/list_enum.c b/layout/list_enum.c
index 230d194..a822880 100644
--- a/layout/list_enum.c
+++ b/layout/list_enum.c
@@ -72,6 +72,7 @@ struct cob_lists_key {
 	/** Padding to make the structure 8 bytes aligned. */
 	uint32_t  clk_pad;
 };
+C2_BASSERT(C2_IS_8ALIGNED(sizeof(struct cob_lists_key)));
 
 struct cob_lists_rec {
 	/** COB identifier. */
diff --git a/layout/ut/composite.c b/layout/ut/composite.c
index d517cc7..04d7851 100644
--- a/layout/ut/composite.c
+++ b/layout/ut/composite.c
@@ -33,7 +33,7 @@ C2_TL_DESCR_DECLARE(c2_layer, extern);
 C2_TL_DESCR_DECLARE(c2_layer_extent, extern);
 static int rc;
 
-static void sublayout_build(uint64_t lid, struct c2_layout **sub_layout)
+static void sublayout_build(uint64_t lid, struct c2_layout **sublayout)
 {
 	bool                          inline_test;
 	uint32_t                      enum_id;
@@ -45,7 +45,7 @@ static void sublayout_build(uint64_t lid, struct c2_layout **sub_layout)
 	struct c2_layout_linear_enum *lin_enum;
 	struct c2_uint128             seed;
 
-	c2_uint128_init(&seed, "sub_layouts_buil");
+	c2_uint128_init(&seed, "sublayouts_build");
 	enum_id = lid % 2 ? LIST_ENUM_ID : LINEAR_ENUM_ID;
 	inline_test = lid % 5 ? LESS_THAN_INLINE : MORE_THAN_INLINE;
 	NKP_assign(enum_id, inline_test, 9, 109, 1200, &N, &K, &P);
@@ -55,7 +55,7 @@ static void sublayout_build(uint64_t lid, struct c2_layout **sub_layout)
 				  &pl, &list_enum, &lin_enum,
 				  false);
 	C2_UT_ASSERT(rc == 0);
-	*sub_layout = c2_pdl_to_layout(pl);
+	*sublayout = c2_pdl_to_layout(pl);
 }
 
 static void extentlist_build(struct c2_tl **extlist,
@@ -76,6 +76,68 @@ static void extentlist_build(struct c2_tl **extlist,
 	c2_layer_extent_tlist_init(extents);
 	C2_UT_ASSERT(c2_layer_extent_tlist_is_empty(extents));
 
+#if 0
+	C2_UT_ASSERT(min_start_offset == 0 &&
+		     approximate_end_offset == C2_BINDEX_MAX);
+	if_contiguous_extents = true;
+#endif
+
+	multiplier = if_contiguous_extents ? 1 : 2;
+	//delta = (approximate_end_offset - min_start_offset + 1) / extents_nr;
+	delta = (approximate_end_offset - min_start_offset) /
+		(extents_nr * multiplier);
+#ifndef __KERNEL__
+		printf("min_extents_nr %lu, min_start_offset %llu, "
+		       "approximate_end_offset %llu\n",
+			(unsigned long)extents_nr,
+			(unsigned long long)min_start_offset,
+			(unsigned long long)approximate_end_offset);
+#endif
+	for (i = 0; i < extents_nr; ++i) {
+		C2_ALLOC_PTR(extent);
+		C2_UT_ASSERT(extent != NULL);
+		extent->cle_ext.e_start = min_start_offset +
+					  (multiplier * i * delta);
+		extent->cle_ext.e_end = extent->cle_ext.e_start + delta - 1;
+
+/*
+		if (i == extents_nr - 1 &&
+		    extent->cle_ext.e_end != C2_BINDEX_MAX) {
+			C2_UT_ASSERT(((C2_BINDEX_MAX) -
+				      extent->cle_ext.e_end) < delta);
+			extent->cle_ext.e_end = C2_BINDEX_MAX;
+		}
+*/
+#ifndef __KERNEL__
+		printf("ext[%u]: start %llu, end %llu \n", i,
+			(unsigned long long)extent->cle_ext.e_start,
+			(unsigned long long)extent->cle_ext.e_end);
+#endif
+		c2_layer_extent_tlink_init_at_tail(extent, extents);
+	}
+	*extlist = extents;
+	C2_UT_ASSERT(!c2_layer_extent_tlist_is_empty(*extlist));
+}
+
+#if 0 //old
+static void extentlist_build(struct c2_tl **extlist,
+			     uint32_t extents_nr,
+			     c2_bindex_t min_start_offset,
+			     c2_bindex_t approximate_end_offset,
+			     bool if_contiguous_extents)
+{
+	struct c2_tl                     *extents;
+	struct c2_composite_layer_extent *extent;
+	c2_bindex_t                       delta;
+	c2_bindex_t                       multiplier;
+	uint32_t                          i;
+
+	/* Initialise a c2_tl for storing the extents. */
+	C2_ALLOC_PTR(extents);
+	C2_UT_ASSERT(extents != NULL);
+	c2_layer_extent_tlist_init(extents);
+	C2_UT_ASSERT(c2_layer_extent_tlist_is_empty(extents));
+
 	multiplier = if_contiguous_extents ? 1 : 2;
 	delta = (approximate_end_offset - min_start_offset + 1) /
 		(extents_nr * multiplier);
@@ -102,6 +164,66 @@ static void extentlist_build(struct c2_tl **extlist,
 	*extlist = extents;
 	C2_UT_ASSERT(!c2_layer_extent_tlist_is_empty(*extlist));
 }
+#endif
+
+/*
+ * For the layer_nr number of layers to be added to a composite layout,
+ * this function creates "layer_nr - 1"  number of layouts with their
+ * respective lid. One layer that is the zeroth layer is already added to the
+ * composite layout when the composite layout got created.
+ *
+ * About the layout identifiers chosen for the sublayouts:
+ * - Layout with lid "composite_lid * 100" is used as a part of the zeroth
+ *   layer (that gets added while the composite layout is created).
+ * - Layout with lid "composite_lid * 100 + layer_idx" is used as a part of
+ *   layer_idx'th layer.
+ */
+static void sublayouts_precreate(uint64_t composite_lid,
+				 uint32_t layers_nr)
+{
+	uint64_t          sublayout_lid;
+	struct c2_layout *sublayout;
+	uint32_t          i;
+
+	for (i = 1; i < layers_nr; ++i) {
+		sublayout_lid = composite_lid * 100 + i;
+		sublayout_build(sublayout_lid, &sublayout);
+	}
+}
+
+static void sublayout_delete(struct c2_layout_domain *domain,
+			     uint64_t sublayout_lid)
+{
+	struct c2_layout *sublayout;
+
+	sublayout = c2_layout_find(domain, sublayout_lid);
+	C2_UT_ASSERT(sublayout != NULL);
+	/* Release the reference acquired by c2_layout_find(). */
+	c2_layout_put(sublayout);
+	/*
+	 * Release the reference acquired during creation of the
+	 * sublayout so as to delete the sublayout.
+	 */
+	c2_layout_put(sublayout);
+	C2_UT_ASSERT(c2_layout_find(domain, sublayout_lid) == NULL);
+}
+
+/*
+ * Deletes all the sublayouts including the one used as the original layout
+ * (part of the zeroth layer).
+ */
+static void sublayouts_delete(struct c2_layout_domain *domain,
+			      uint64_t composite_lid,
+			      uint32_t layers_nr)
+{
+	uint64_t          sublayout_lid;
+	uint32_t          i;
+
+	for (i = 0; i < layers_nr; ++i) {
+		sublayout_lid = composite_lid * 100 + i;
+		sublayout_delete(domain, sublayout_lid);
+	}
+}
 
 static void composite_layout_verify(struct c2_layout *l,
 				    uint64_t composite_lid,
@@ -135,7 +257,7 @@ static void composite_layout_verify(struct c2_layout *l,
 	l_verify(l, composite_lid, !USER_COUNT_INCREMENTED);
 
 	/* Verify the composite type specific data. */
-	c2_uint128_init(&seed, "sub_layouts_buil");
+	c2_uint128_init(&seed, "sublayouts_build");
 	multiplier = if_contiguous_extents ? 1 : 2;
 
 	/* Verify the layers */
@@ -162,17 +284,37 @@ static void composite_layout_verify(struct c2_layout *l,
 
 			/* Verify the extents. */
 			j = 0;
+			delta = (approximate_end_offset - min_start_offset) /
+				(extents_nr * multiplier);
+#if 0
+
 			delta = (approximate_end_offset - min_start_offset
 				 + 1) /
 				(extents_nr * multiplier);
+			delta = (approximate_end_offset - min_start_offset) /
+				extents_nr;
+#endif
 			c2_tl_for(c2_layer_extent, layer->clr_extents,
 				  extent) {
+				/* todo Nov 27 Need to make c2...layer_add()
+				 * update the in-memory extent list.
+				 * r -t layout-ut:layout-add
+				 */
 				C2_UT_ASSERT(extent->cle_ext.e_start ==
 					     min_start_offset +
 					     (multiplier * j * delta));
 				C2_UT_ASSERT(extent->cle_ext.e_end ==
 					     extent->cle_ext.e_start +
 					     delta - 1);
+#if 0
+				if (j < extents_nr - 1)
+					C2_UT_ASSERT(extent->cle_ext.e_end ==
+						     extent->cle_ext.e_start +
+						     delta - 1);
+				else
+					C2_UT_ASSERT(extent->cle_ext.e_end ==
+						     C2_BINDEX_MAX);
+#endif
 				++j;
 			} c2_tl_endfor;
 			C2_UT_ASSERT(j == extents_nr);
@@ -182,89 +324,117 @@ static void composite_layout_verify(struct c2_layout *l,
         } c2_tl_endfor;
 }
 
-/*
- * Builds a layout object with COMPOSITE layout type and adds layers to it.
- * The 'number of extents, start offset and end offset are varied (incremented
- * by one) for each layer. Effectively, as of now, extents of one layer are
- * overlapping to the extents of another layer.
- */
-int composite_layout_build(uint64_t lid,
+/* Builds a layout object with COMPOSITE layout type. */
+static int composite_build(uint64_t lid,
 			   struct c2_layout_domain *domain,
 			   struct c2_composite_layout **cl,
-			   uint32_t layers_nr,
-			   uint32_t min_extents_nr,
-			   c2_bindex_t min_start_offset,
-			   c2_bindex_t approximate_end_offset,
-			   bool if_contiguous_extents,
 			   bool failure_test)
 {
-	struct c2_layout *sl; /* sublayout */
 	struct c2_layout *l_from_cl;
+	struct c2_layout *sublayout;
 	uint64_t          sublayout_lid;
-	struct c2_tl     *extents;
-	uint32_t          extents_nr;
-	uint32_t          i;
-
-	C2_UT_ASSERT(cl != NULL);
 
-	/*
-	 * Build one layout to be treated as the old layout (part of the zeroth
-	 * layer of the composite layout).
-	 */
+	/* Pre-create the sublayout to be used as the original layout. */
 	sublayout_lid = lid * 100;
-	sublayout_build(sublayout_lid, &sl); /* lid * 100 + i */
+	sublayout_build(sublayout_lid, &sublayout);
 
 	/* Build a composite layout. */
-	rc = c2_composite_build(domain, lid, sl, cl);
+	rc = c2_composite_build(domain, lid, sublayout, cl);
 	if (failure_test) {
 		C2_UT_ASSERT(rc == -ENOMEM);
+		sublayout_delete(domain, sublayout_lid);
 		return rc;
 	}
 	C2_UT_ASSERT(rc == 0);
 
-	/*
-	 * Release reference on the sub-layout that was obtained during its
-	 * creation. c2_composite_build() has now acquired a reference on it.
-	 */
-	c2_layout_put(sl);
-
 	/* Verify c2_cl_to_layout(). */
 	l_from_cl = c2_cl_to_layout(*cl);
 	C2_UT_ASSERT(l_from_cl == &(*cl)->cl_base);
 
 	/* Verify the composite layout object contents. */
 	composite_layout_verify(l_from_cl, lid, 1, 0, 0, 0,
-				if_contiguous_extents);
+				!CONTIGUOUS_EXTENTS);
+	return 0;
+}
+
+/*
+ * Adds layers to the provided composite layout.
+ * The 'number of extents, start offset and end offset are varied (incremented
+ * by one) for each layer. Effectively, as of now, extents of one layer are
+ * overlapping to the extents of another layer.
+ */
+static int composite_layers_add(struct c2_composite_layout *cl,
+				struct c2_db_tx *tx,
+				uint32_t layers_nr,
+				uint32_t min_extents_nr,
+				c2_bindex_t min_start_offset,
+				c2_bindex_t approximate_end_offset,
+				bool if_contiguous_extents,
+				bool failure_test /* todo Use this */)
+{
+	struct c2_layout *sl; /* todo change to sublayout */
+	uint64_t          sublayout_lid;
+	struct c2_tl     *extents;
+	uint32_t          extents_nr;
+	uint32_t          i;
+
+	/* Pre-create the sublayouts to be used for the layer 1 and above. */
+	sublayouts_precreate(cl->cl_base.l_id, layers_nr);
 
-	/* Add layers to the composite layout. */
-	c2_mutex_lock(&(*cl)->cl_base.l_lock);
+	c2_mutex_lock(&cl->cl_base.l_lock);
 	extents_nr = min_extents_nr;
 	for (i = 1; i < layers_nr; ++i, ++extents_nr) {
-		sublayout_lid = lid * 100 + i;
-		/* Build a layout to be used as a sub-layout. */
-		sublayout_build(sublayout_lid, &sl);
+		sublayout_lid = cl->cl_base.l_id * 100 + i;
+		sl = c2_layout_find(cl->cl_base.l_dom, sublayout_lid);
+		C2_UT_ASSERT(sl != NULL);
+		/* Release the reference acquired by c2_layout_find(). */
+		c2_layout_put(sl);
 
-		/* Build an extent list to be associated with the sub-layout. */
+		/* Build an extent list to be associated with the sublayout. */
 		extentlist_build(&extents, extents_nr,
 				 min_start_offset, approximate_end_offset,
 				 if_contiguous_extents);
-		rc = c2_composite_layer_add(*cl, sl, extents, extents_nr);
+		rc = c2_composite_layer_add(cl, sl, extents, extents_nr, tx);
 		C2_UT_ASSERT(rc == 0);
 
-		/*
-		 * Release reference on the sub-layout that was obtained
-		 * during its creation. c2_composite_layer_add() has now
-		 * acquired a reference on it.
-		 */
-		c2_layout_put(sl);
-
 		/* Verify the composite layout object contents. */
-		composite_layout_verify(l_from_cl, lid, i + 1, min_extents_nr,
+		composite_layout_verify(&cl->cl_base, cl->cl_base.l_id, i + 1,
+					min_extents_nr,
 					min_start_offset,
 					approximate_end_offset,
 					if_contiguous_extents);
 	}
-	c2_mutex_unlock(&(*cl)->cl_base.l_lock);
+	c2_mutex_unlock(&cl->cl_base.l_lock);
+	return rc;
+}
+
+/*
+ * Builds a layout object with COMPOSITE layout type and adds layers to it.
+ * The 'number of extents, start offset and end offset are varied (incremented
+ * by one) for each layer. Effectively, as of now, extents of one layer are
+ * overlapping to the extents of another layer.
+ */
+static int composite_build_and_layers_add(uint64_t lid,
+					  struct c2_layout_domain *domain,
+					  struct c2_db_tx *tx,
+					  struct c2_composite_layout **cl,
+					  uint32_t layers_nr,
+					  uint32_t min_extents_nr,
+					  c2_bindex_t min_start_offset,
+					  c2_bindex_t approximate_end_offset,
+					  bool if_contiguous_extents,
+					  bool failure_test)
+{
+	C2_UT_ASSERT(cl != NULL);
+
+	rc = composite_build(lid, domain, cl, !FAILURE_TEST);
+	C2_UT_ASSERT(rc == 0);
+
+	rc = composite_layers_add(*cl, tx, layers_nr, min_extents_nr,
+				  min_start_offset, approximate_end_offset,
+				  if_contiguous_extents, failure_test/* todo*/);
+	C2_UT_ASSERT(rc == 0);
+
 	return rc;
 }
 
@@ -286,11 +456,11 @@ int test_build_composite(uint64_t lid,
 	struct c2_composite_layout *cl;
 	struct c2_layout           *l;
 
-	rc = composite_layout_build(lid, domain, &cl, layers_nr,
-				    min_extents_nr, min_start_offset,
-				    approximate_end_offset,
-				    if_contiguous_extents,
-				    failure_test);
+	rc = composite_build_and_layers_add(lid, domain, NULL, &cl, layers_nr,
+					    min_extents_nr, min_start_offset,
+					    approximate_end_offset,
+					    if_contiguous_extents,
+					    failure_test);
 	if (failure_test)
 		C2_UT_ASSERT(rc == -ENOMEM);
 	else {
@@ -308,6 +478,9 @@ int test_build_composite(uint64_t lid,
 		/* Delete the composite layout object. */
 		c2_layout_put(&cl->cl_base);
 		C2_UT_ASSERT(c2_layout_find(domain, lid) == NULL);
+
+		/* Delete all the precreated sublayouts. */
+		sublayouts_delete(domain, lid, layers_nr);
 	}
 
 	return rc;
@@ -315,6 +488,7 @@ int test_build_composite(uint64_t lid,
 
 /* Builds a buffer containing serialised representation of a layout object. */
 static void composite_layout_buf_build(uint64_t composite_lid,
+				       struct c2_layout_domain *domain,
 				       uint32_t layers_nr,
 				       uint32_t min_extents_nr,
 				       c2_bindex_t min_start_offset,
@@ -324,7 +498,7 @@ static void composite_layout_buf_build(uint64_t composite_lid,
 {
 	c2_bcount_t                    nbytes;
 	uint64_t                       sublayout_lid;
-	struct c2_layout              *sub_layout;
+	struct c2_layout              *sublayout;
 	struct composite_header        cl_header;
 	struct composite_layer_header  layer_header;
 	struct c2_ext                  ext;
@@ -362,11 +536,19 @@ static void composite_layout_buf_build(uint64_t composite_lid,
 		(unsigned long long)min_start_offset,
 		(unsigned long long)approximate_end_offset);
 #endif
+
+	/* Pre-create the sublayout to be used as the original layout. */
+	sublayout_build(composite_lid * 100, &sublayout);
+	/* Pre-create the sublayouts to be used for layer 1 and above. */
+	sublayouts_precreate(composite_lid, layers_nr);
+
 	extents_nr = min_extents_nr;
-	for (i = 0; i < cl_header.ch_layers_nr; ++i) {
+	for (i = 0; i < layers_nr; ++i) {
 		sublayout_lid = composite_lid * 100 + i;
-		//todo Pre-create a few layouts
-		sublayout_build(sublayout_lid, &sub_layout);
+		sublayout = c2_layout_find(domain, sublayout_lid);
+		C2_UT_ASSERT(sublayout != NULL);
+		/* Release the reference acquired by c2_layout_find(). */
+		c2_layout_put(sublayout);
 
 		layer_header.clh_lid = sublayout_lid;
 		layer_header.clh_idx = i;
@@ -381,18 +563,31 @@ static void composite_layout_buf_build(uint64_t composite_lid,
 		if (i == 0) /* Zeroth layer does not contain any extents. */
 			continue;
 
+		delta = (approximate_end_offset - min_start_offset) /
+			(extents_nr * multiplier);
+#if 0
 		delta = (approximate_end_offset - min_start_offset + 1) /
 			(extents_nr * multiplier);
+		delta = (approximate_end_offset - min_start_offset) /
+			extents_nr;
+#endif
 #ifndef __KERNEL__
 		printf("composite_layout_buf_build(): extents_nr %lu, "
 			"delta %llu\n",
 			(unsigned long)extents_nr,
 			(unsigned long long)delta);
 #endif
+	//todo Assert everywhere applicable that extents_nr >= 2
 		for (j = 0; j < layer_header.clh_extents_nr; ++j) {
 			ext.e_start = min_start_offset +
 				      multiplier * j * delta;
 			ext.e_end = ext.e_start + delta - 1;
+#if 0
+			if (j < layer_header.clh_extents_nr - 1)
+				ext.e_end = ext.e_start + delta - 1;
+			else
+				ext.e_end = C2_BINDEX_MAX;
+#endif
 			nbytes = c2_bufvec_cursor_copyto(dcur, &ext,
 							 sizeof ext);
 			C2_ASSERT(nbytes == sizeof ext);
@@ -424,9 +619,6 @@ int test_decode_composite(uint64_t lid,
 	struct c2_bufvec_cursor  cur;
 	struct c2_layout        *l;
 	struct c2_layout_type   *lt;
-	uint64_t                 sublayout_lid;
-	struct c2_layout        *sl; /* sublayout */
-	uint32_t                 i;
 
 	C2_ENTRY();
 
@@ -434,7 +626,7 @@ int test_decode_composite(uint64_t lid,
 	allocate_area(&area, ADDITIONAL_BYTES_DEFAULT * 4, &num_bytes);
 	bv = (struct c2_bufvec) C2_BUFVEC_INIT_BUF(&area, &num_bytes);
 	c2_bufvec_cursor_init(&cur, &bv);
-	composite_layout_buf_build(lid, layers_nr, min_extents_nr,
+	composite_layout_buf_build(lid, domain, layers_nr, min_extents_nr,
 				   min_start_offset, approximate_end_offset,
 				   if_contiguous_extents, &cur);
 
@@ -472,17 +664,10 @@ int test_decode_composite(uint64_t lid,
 	C2_UT_ASSERT(list_lookup(lid) == NULL);
 
 	/*
-	 * Destroy all the sub-layouts created through
+	 * Destroy the sublayouts precreated through
 	 * composite_layout_buf_build().
 	 */
-	for (i = 0; i < layers_nr; ++i) {
-		sublayout_lid = lid * 100 + i;
-		sl = c2_layout_find(domain, sublayout_lid);
-		C2_UT_ASSERT(sl != NULL);
-		c2_layout_put(sl);
-		c2_layout_put(sl);
-		C2_UT_ASSERT(c2_layout_find(domain, sublayout_lid) == NULL);
-	}
+	sublayouts_delete(domain, lid, layers_nr);
 
 	c2_free(area);
 	C2_LEAVE();
@@ -543,14 +728,27 @@ static void composite_layout_buf_verify(uint64_t lid,
 
 		C2_UT_ASSERT(c2_bufvec_cursor_step(cur) >=
 			     layer_header->clh_extents_nr * sizeof ext);
+		delta = (approximate_end_offset - min_start_offset) /
+			(extents_nr * multiplier);
+#if 0
 		delta = (approximate_end_offset - min_start_offset + 1) /
 			(extents_nr * multiplier);
+		delta = (approximate_end_offset - min_start_offset) /
+			extents_nr;
+#endif
 		for (j = 0; j < layer_header->clh_extents_nr; ++j) {
 			ext = c2_bufvec_cursor_addr(cur);
 			c2_bufvec_cursor_move(cur, sizeof *ext);
 			C2_UT_ASSERT(ext->e_start == min_start_offset +
 						     multiplier * j * delta);
 			C2_UT_ASSERT(ext->e_end == ext->e_start + delta - 1);
+#if 0
+			if (j < layer_header->clh_extents_nr - 1)
+				C2_UT_ASSERT(ext->e_end ==
+					     ext->e_start + delta - 1);
+			else
+				C2_UT_ASSERT(ext->e_end == C2_BINDEX_MAX);
+#endif
 		}
 		++extents_nr;
 	}
@@ -575,14 +773,12 @@ int test_encode_composite(uint64_t lid,
 	C2_ENTRY("lid %llu", (unsigned long long)lid);
 
 	/* Build a layout object. */
-	rc = composite_layout_build(lid, domain, &cl, layers_nr,
-				    min_extents_nr, min_start_offset,
-				    approximate_end_offset,
-				    if_contiguous_extents, failure_test);
-	if (failure_test)
-		C2_UT_ASSERT(rc == -ENOMEM);
-	else
-		C2_UT_ASSERT(rc == 0);
+	rc = composite_build_and_layers_add(lid, domain, NULL, &cl, layers_nr,
+					    min_extents_nr, min_start_offset,
+					    approximate_end_offset,
+					    if_contiguous_extents,
+					    !FAILURE_TEST);
+	C2_UT_ASSERT(rc == 0);
 
 	/* Encode the layout object into a layout buffer. */
 	allocate_area(&area, ADDITIONAL_BYTES_DEFAULT * 10, &num_bytes);
@@ -611,6 +807,9 @@ int test_encode_composite(uint64_t lid,
 	c2_layout_put(&cl->cl_base);
 	C2_UT_ASSERT(c2_layout_find(domain, lid) == NULL);
 
+	/* Delete the sublayouts precreated through composite_build(). */
+	sublayouts_delete(domain, lid, layers_nr);
+
 	c2_free(area);
 	C2_LEAVE();
 	return rc;
@@ -695,9 +894,6 @@ int test_decode_encode_composite(uint64_t lid,
 	c2_bcount_t              num_bytes;
 	struct c2_layout        *l;
 	struct c2_layout_type   *lt;
-	uint64_t                 sublayout_lid;
-	struct c2_layout        *sl; /* sublayout */
-	uint32_t                 i;
 
 	C2_ENTRY();
 
@@ -706,7 +902,7 @@ int test_decode_encode_composite(uint64_t lid,
 	bv1 = (struct c2_bufvec) C2_BUFVEC_INIT_BUF(&area1, &num_bytes);
 	c2_bufvec_cursor_init(&cur1, &bv1);
 
-	composite_layout_buf_build(lid, layers_nr, min_extents_nr,
+	composite_layout_buf_build(lid, domain, layers_nr, min_extents_nr,
 				   min_start_offset, approximate_end_offset,
 				   if_contiguous_extents, &cur1);
 
@@ -754,17 +950,10 @@ int test_decode_encode_composite(uint64_t lid,
 	C2_UT_ASSERT(list_lookup(lid) == NULL);
 
 	/*
-	 * Destroy all the sub-layouts created through
+	 * Destroy the sublayouts precreated through
 	 * composite_layout_buf_build().
 	 */
-	for (i = 0; i < layers_nr; ++i) {
-		sublayout_lid = lid * 100 + i;
-		sl = c2_layout_find(domain, sublayout_lid);
-		C2_UT_ASSERT(sl != NULL);
-		c2_layout_put(sl);
-		c2_layout_put(sl);
-		C2_UT_ASSERT(c2_layout_find(domain, sublayout_lid) == NULL);
-	}
+	sublayouts_delete(domain, lid, layers_nr);
 
 	c2_free(area1);
 	c2_free(area2);
@@ -929,17 +1118,15 @@ int test_encode_decode_composite(uint64_t lid,
 	struct c2_layout           *l;
 	struct c2_layout           *l_copy;
 	struct c2_layout_type      *lt;
-	uint64_t                    sublayout_lid;
-	struct c2_layout           *sl; /* sublayout */
-	uint32_t                    i;
 
 	C2_ENTRY("lid %llu", (unsigned long long)lid);
 
 	/* Build a layout object. */
-	rc = composite_layout_build(lid, domain, &cl, layers_nr,
-				    min_extents_nr, min_start_offset,
-				    approximate_end_offset,
-				    if_contiguous_extents, !FAILURE_TEST);
+	rc = composite_build_and_layers_add(lid, domain, NULL, &cl, layers_nr,
+					    min_extents_nr, min_start_offset,
+					    approximate_end_offset,
+					    if_contiguous_extents,
+					    !FAILURE_TEST);
 	C2_UT_ASSERT(rc == 0);
 
 	composite_layout_copy(&cl->cl_base, &l_copy);
@@ -954,18 +1141,6 @@ int test_encode_decode_composite(uint64_t lid,
 	c2_mutex_unlock(&cl->cl_base.l_lock);
 	C2_UT_ASSERT(rc == 0);
 
-	/*
-	 * todo tempo until sublayouts are created separately in advance:
-	 * Add a reference to the sub-layouts so that don't get destroyed
-	 * while the composite layout is destroyed and are available for the
-	 * subsequent c2_layout_decode()..
-	 */
-	for (i = 0; i < layers_nr; ++i) {
-		sublayout_lid = lid * 100 + i;
-		sl = c2_layout_find(domain, sublayout_lid);
-		C2_UT_ASSERT(sl != NULL);
-	}
-
 	/* Destroy the layout. */
 	c2_layout_put(&cl->cl_base);
 	C2_UT_ASSERT(list_lookup(lid) == NULL);
@@ -998,15 +1173,8 @@ int test_encode_decode_composite(uint64_t lid,
 	c2_layout_put(l);
 	C2_UT_ASSERT(list_lookup(lid) == NULL);
 
-	/* todo tempo See above. */
-	for (i = 0; i < layers_nr; ++i) {
-		sublayout_lid = lid * 100 + i;
-		sl = c2_layout_find(domain, sublayout_lid);
-		C2_UT_ASSERT(sl != NULL);
-		c2_layout_put(sl);
-		c2_layout_put(sl);
-		C2_UT_ASSERT(c2_layout_find(domain, sublayout_lid) == NULL);
-	}
+	/* Delete the sublayouts precreated through composite_build(). */
+	sublayouts_delete(domain, lid, layers_nr);
 
 	c2_free(area);
 	C2_LEAVE();
@@ -1014,27 +1182,26 @@ int test_encode_decode_composite(uint64_t lid,
 }
 
 #ifndef __KERNEL__
-#if 0
-static int test_add_composite(uint64_t lid,
-			      bool layout_destroy, struct c2_layout **l_obj,
-			      bool duplicate_test,
-			      bool failure_test);
+#if 1
 /* Tests the API c2_layout_lookup(), for the COMPOSITE layout type. */
-static int test_lookup_composite(uint64_t lid,
-				 bool existing_test,
-				 bool failure_test)
+int test_lookup_composite(uint64_t lid,
+			  struct c2_layout_domain *domain,
+			  uint32_t layers_nr,
+			  uint32_t min_extents_nr,
+			  c2_bindex_t min_start_offset,
+			  c2_bindex_t approximate_end_offset,
+			  bool if_contiguous_extents,
+			  bool existing_test,
+			  bool failure_test)
 {
 	c2_bcount_t        num_bytes;
 	void              *area;
 	struct c2_layout  *l1;
-	//todo struct c2_layout  *l1_copy;
+	struct c2_layout  *l1_copy;
 	struct c2_layout  *l2;
 	struct c2_layout  *l3;
 	struct c2_db_pair  pair;
 	struct c2_db_tx    tx;
-	uint32_t           i; //todo rm
-	uint64_t           sublayout_lid; //todo rm
-	struct c2_layout  *l; //todo rm
 	int                rc_tmp;
 
 	C2_ENTRY();
@@ -1045,23 +1212,26 @@ static int test_lookup_composite(uint64_t lid,
 	 * DB.
 	 */
 	if (existing_test) {
-		rc = test_add_composite(lid,
+		rc = test_add_composite(lid, domain,
+					layers_nr,
+					min_extents_nr,
+					min_start_offset,
+					approximate_end_offset,
+					if_contiguous_extents,
 					!LAYOUT_DESTROY, &l1,
 					!DUPLICATE_TEST,
 					!FAILURE_TEST);
 		C2_UT_ASSERT(rc == 0);
 
-#if 0 //todo
 		if (!failure_test)
-			composite_layout_copy(enum_id, l1, &l1_copy);
-#endif
+			composite_layout_copy(l1, &l1_copy);
 
 		/*
 		 * Lookup for the layout object to verify that the same object
 		 * is returned from the memory, not requiring a lookup from the
 		 * DB.
 		 */
-		rc = c2_layout_lookup(&domain, lid, &c2_composite_layout_type,
+		rc = c2_layout_lookup(domain, lid, &c2_composite_layout_type,
 				      &tx, &pair, &l2);
 		C2_UT_ASSERT(rc == 0);
 		C2_UT_ASSERT(l2 == l1);
@@ -1078,12 +1248,12 @@ static int test_lookup_composite(uint64_t lid,
 	/* Lookup for the layout object from the DB. */
 	allocate_area(&area, ADDITIONAL_BYTES_NONE, &num_bytes);
 
-	rc = c2_db_tx_init(&tx, &dbenv, DBFLAGS);
+	rc = c2_db_tx_init(&tx, domain->ld_dbenv, DBFLAGS);
 	C2_UT_ASSERT(rc == 0);
 
 	pair_set(&pair, &lid, area, num_bytes);
 
-	rc = c2_layout_lookup(&domain, lid, &c2_composite_layout_type,
+	rc = c2_layout_lookup(domain, lid, &c2_composite_layout_type,
 			      &tx, &pair, &l3);
 	if (failure_test)
 		C2_UT_ASSERT(rc == -ENOENT || rc == -ENOMEM || rc == -EPROTO ||
@@ -1096,36 +1266,25 @@ static int test_lookup_composite(uint64_t lid,
 
 	if (existing_test && !failure_test) {
 		C2_UT_ASSERT(list_lookup(lid) == l3);
-		//todo composite_layout_compare(enum_id, l1_copy, l3, false);
-		//todo composite_layout_copy_delete(enum_id, l1_copy);
+		composite_layout_compare(l1_copy, l3, false);
+		composite_layout_copy_delete(l1_copy);
 
 		/* Destroy the layout object. */
 		c2_layout_put(l3);
 		C2_UT_ASSERT(list_lookup(lid) == NULL);
-
-		/* Delete all the sub-layouts. */
-		for (i = 0; i < 10; ++i) {
-			sublayout_lid = lid * 100 + i;
-			l = c2_layout_find(&domain, sublayout_lid);
-			C2_UT_ASSERT(l->l_user_count == 0);
-			c2_layout_put(l);
-			c2_layout_put(l);
-		}
 	}
+
+	/* Delete the sublayouts precreated through composite_build(). */
+	if (existing_test)
+		sublayouts_delete(domain, lid, layers_nr);
+
 	c2_free(area);
 	C2_LEAVE();
 	return rc;
 }
 #endif
 
-/* Nov 21 Continue from here. The layer 0 seems to be added to the DB.
- * Need to add the next layers to the DB.
- * Or first go for the lookup.
- */
-
-#if 1
 /* Tests the API c2_layout_add(), for the COMPOSITE layout type. */
-//todo Make this accept layers_nr
 int test_add_composite(uint64_t lid,
 		       struct c2_layout_domain *domain,
 		       uint32_t layers_nr,
@@ -1152,10 +1311,14 @@ int test_add_composite(uint64_t lid,
 	allocate_area(&area, ADDITIONAL_BYTES_NONE, &num_bytes);
 
 	/* Build a layout object. */
-	rc = composite_layout_build(lid, domain, &cl, layers_nr,
-				    min_extents_nr, min_start_offset,
-				    approximate_end_offset,
-				    if_contiguous_extents, failure_test);
+#if 0
+	rc = composite_build_and_layers_add(lid, domain, &cl, layers_nr,
+					    min_extents_nr, min_start_offset,
+					    approximate_end_offset,
+					    if_contiguous_extents,
+					    !FAILURE_TEST);
+#endif
+	rc = composite_build(lid, domain, &cl, !FAILURE_TEST);
 	C2_UT_ASSERT(rc == 0);
 
 	/* Add the layout object to the DB. */
@@ -1166,8 +1329,8 @@ int test_add_composite(uint64_t lid,
 
 	rc = c2_layout_add(&cl->cl_base, &tx, &pair);
 	if (failure_test)
-		C2_UT_ASSERT(rc == -ENOENT || rc == LO_ENCODE_ERR);
-		//todo check why -ENOENT err here n for pdclust
+		C2_UT_ASSERT(rc == LO_ENCODE_ERR);
+		//todo rc == -ENOENT when cursor_init error is injected
 	else
 		C2_UT_ASSERT(rc == 0);
 
@@ -1193,23 +1356,32 @@ int test_add_composite(uint64_t lid,
 		C2_UT_ASSERT(rc_tmp == 0);
 	}
 
+
+	rc = c2_db_tx_init(&tx, domain->ld_dbenv, DBFLAGS);
+	C2_UT_ASSERT(rc == 0);
+	rc = composite_layers_add(cl, &tx, layers_nr, min_extents_nr,
+				  min_start_offset, approximate_end_offset,
+				  if_contiguous_extents,
+				  !FAILURE_TEST /* todo */);
+
+	rc_tmp = c2_db_tx_commit(&tx);
+	C2_UT_ASSERT(rc_tmp == 0);
+
 	if (layout_destroy) {
 		c2_layout_put(&cl->cl_base);
 		C2_UT_ASSERT(list_lookup(lid) == NULL);
 
 		/*
-		 * The sublayouts get deleted when their last reference is
-		 * released through composite_fini().
+		 * Delete the sublayouts precreated through composite_build().
 		 */
-	}
-	else
+		sublayouts_delete(domain, lid, layers_nr);
+	} else
 		*l_obj = &cl->cl_base;
 
 	c2_free(area);
 	C2_LEAVE("lid %llu", (unsigned long long)lid);
 	return rc;
 }
-#endif
 
 #if 0
 /* Tests the API c2_layout_delete(), for the COMPOSITE layout type. */
@@ -1239,7 +1411,7 @@ static int test_delete_composite(uint64_t lid,
 		C2_UT_ASSERT(rc == 0);
 	} else {
 		/* Build a layout object. */
-		rc = composite_layout_build(lid, &cl, 10, !FAILURE_TEST);
+		rc = composite_build_and_layers_add(lid, &cl, 10, !FAILURE_TEST);
 		C2_UT_ASSERT(rc == 0);
 		l = &cl->cl_base;
 	}
@@ -1267,7 +1439,7 @@ static int test_delete_composite(uint64_t lid,
 	c2_layout_put(l);
 	C2_UT_ASSERT(list_lookup(lid) == NULL);
 
-	/* Delete all the sub-layouts. */
+	/* Delete all the sublayouts. */
 	for (i = 0; i < 10; ++i) {
 		sublayout_lid = lid * 100 + i;
 		l = c2_layout_find(&domain, sublayout_lid);
diff --git a/layout/ut/layout.c b/layout/ut/layout.c
index 949ddd4..d0789bb 100644
--- a/layout/ut/layout.c
+++ b/layout/ut/layout.c
@@ -820,6 +820,7 @@ static void test_build(void)
 	lid = 1005;
 	rc = test_build_composite(lid, &domain, 5, 100,
 				  lid * 100, lid * 100 * 100,
+				  //0, C2_BINDEX_MAX,
 				  CONTIGUOUS_EXTENTS, !FAILURE_TEST);
 	C2_UT_ASSERT(rc == 0);
 
@@ -830,6 +831,7 @@ static void test_build(void)
 	lid = 1006;
 	rc = test_build_composite(lid, &domain, 6, 100,
 				  lid * 100, lid * 100 * 100,
+				  //0, C2_BINDEX_MAX,
 				  !CONTIGUOUS_EXTENTS, !FAILURE_TEST);
 	C2_UT_ASSERT(rc == 0);
 }
@@ -1146,6 +1148,7 @@ static void test_decode(void)
 	lid = 3005;
 	rc = test_decode_composite(lid, &domain, 7, 10,
 				   lid * 100, lid * 100 * 100,
+				   //0, C2_BINDEX_MAX,
 				   CONTIGUOUS_EXTENTS, !FAILURE_TEST);
 	C2_UT_ASSERT(rc == 0);
 
@@ -1156,6 +1159,7 @@ static void test_decode(void)
 	lid = 3006;
 	rc = test_decode_composite(lid, &domain, 8, 10,
 				   lid * 100, lid * 100 * 100,
+				   //0, C2_BINDEX_MAX,
 				   !CONTIGUOUS_EXTENTS, !FAILURE_TEST);
 	C2_UT_ASSERT(rc == 0);
 }
@@ -1449,6 +1453,7 @@ static void test_encode(void)
 	lid = 5005;
 	rc = test_encode_composite(lid, &domain, 9, 25,
 				   lid * 100, lid * 100 * 100,
+				   //0, C2_BINDEX_MAX,
 				   CONTIGUOUS_EXTENTS, !FAILURE_TEST);
 	C2_UT_ASSERT(rc == 0);
 
@@ -1459,6 +1464,7 @@ static void test_encode(void)
 	lid = 5006;
 	rc = test_encode_composite(lid, &domain, 10, 25,
 				   lid * 100, lid * 100 * 100,
+				   //0, C2_BINDEX_MAX,
 				   !CONTIGUOUS_EXTENTS, !FAILURE_TEST);
 	C2_UT_ASSERT(rc == 0);
 }
@@ -1755,6 +1761,7 @@ static void test_decode_encode(void)
 	lid = 7005;
 	rc = test_decode_encode_composite(lid, &domain, 11, 21,
 					  lid * 100, lid * 10 * 100,
+					  //0, C2_BINDEX_MAX,
 					  CONTIGUOUS_EXTENTS);
 	C2_UT_ASSERT(rc == 0);
 }
@@ -1872,8 +1879,9 @@ static void pdclust_layout_copy(uint32_t enum_id,
 	C2_UT_ASSERT(l_src != NULL && l_dest != NULL);
 	C2_UT_ASSERT(enum_id == LIST_ENUM_ID || enum_id == LINEAR_ENUM_ID);
 
-	pl_src = container_of(l_src, struct c2_pdclust_layout, pl_base.sl_base);
-	pl_dest = c2_alloc(sizeof *pl_src); //todo replace by C2_ALLOC_PTR()
+	pl_src = container_of(l_src, struct c2_pdclust_layout,
+			      pl_base.sl_base);
+	C2_ALLOC_PTR(pl_dest);
 	C2_UT_ASSERT(pl_dest != NULL);
 	*l_dest = &pl_dest->pl_base.sl_base;
 
@@ -2098,6 +2106,7 @@ static void test_encode_decode(void)
 	lid = 8005;
 	rc = test_encode_decode_composite(lid, &domain, 7, 27,
 					  lid * 100, lid * 100 * 100,
+					  //0, C2_BINDEX_MAX,
 					  CONTIGUOUS_EXTENTS);
 	C2_UT_ASSERT(rc == 0);
 }
@@ -3016,23 +3025,31 @@ static void test_lookup(void)
 					     INLINE_NOT_APPLICABLE);
 	C2_UT_ASSERT(rc == 0);
 
-#if 0
 	/*
 	 * Lookup for a layout object with COMPOSITE layout type, that does not
 	 * exist in the DB.
 	 */
 	lid = 14008;
-	rc = test_lookup_composite(lid,
+	rc = test_lookup_composite(lid, &domain,
+				   7, 107,
+				   lid * 100, lid * 100 * 100,
+				   //0, C2_BINDEX_MAX,
+				   !CONTIGUOUS_EXTENTS,
 				   !EXISTING_TEST,
 				   FAILURE_TEST);
 	C2_UT_ASSERT(rc == -ENOENT);
 
+#if 1 //Nov 22 Need to preseve the sublayouts
 	/*
 	 * Add a layout object with COMPOSITE layout type. Then perform lookup
 	 * for it.
 	 */
 	lid = 14009;
-	rc = test_lookup_composite(lid,
+	rc = test_lookup_composite(lid, &domain,
+				   1, 1, /* todo 108, 2 */
+				   lid * 100, lid * 100 * 100,
+				   //0, C2_BINDEX_MAX,
+				   !CONTIGUOUS_EXTENTS,
 				   EXISTING_TEST,
 				   !FAILURE_TEST);
 	C2_UT_ASSERT(rc == 0);
@@ -3279,17 +3296,17 @@ static void test_add(void)
 			      !FAILURE_TEST);
 	C2_UT_ASSERT(rc == 0);
 
-#if 1
 	/* Add a layout object with COMPOSITE layout type. */
+	/* todo This test has mem leak of about 30 KB */
 	lid = 16005;
-	rc = test_add_composite(lid, &domain, 7, 107,
+	rc = test_add_composite(lid, &domain, 7 /* todo 7 */, 2 /* todo 107 */,
 				lid * 100, lid * 100 * 100,
+				//0, C2_BINDEX_MAX,
 				!CONTIGUOUS_EXTENTS,
 				LAYOUT_DESTROY, NULL,
 				!DUPLICATE_TEST,
 				!FAILURE_TEST);
 	C2_UT_ASSERT(rc == 0);
-#endif
 }
 
 static void test_add_failure(void)
@@ -3307,15 +3324,18 @@ static void test_add_failure(void)
 	C2_UT_ASSERT(rc == LO_ENCODE_ERR);
 
 	/*
-	 * Simulate the error that entry already exists in the layout DB with
-	 * the same layout id.
+	 * Try to add an entry with a layout id that already exists in the
+	 * layout DB.
+	 * This test is intentionally not marked as a failure test so that
+	 * c2_layout_add() is ensured to return success and the test intention
+	 * is indicated using another separate falg as DUPLICATE_TEST.
 	 */
 	lid = 17002;
 	rc = test_add_pdclust(LINEAR_ENUM_ID, lid,
 			      INLINE_NOT_APPLICABLE,
 			      LAYOUT_DESTROY, NULL,
 			      DUPLICATE_TEST,
-			      !FAILURE_TEST); // todo mark this failure test
+			      !FAILURE_TEST);
 	C2_UT_ASSERT(rc == -EEXIST);
 
 	/*
@@ -3346,8 +3366,8 @@ static void test_add_failure(void)
 
 #if 0
 	/*
-	 * Simulate the error that entry already exists in the layout DB with
-	 * the same layout id.
+	 * Try to add an entry with a layout id that already exists in the
+	 * layout DB.
 	 */
 	lid = 17005;
 	rc = test_add_composite(lid,
diff --git a/layout/ut/layout.h b/layout/ut/layout.h
index 5c95dfa..ccb503d 100644
--- a/layout/ut/layout.h
+++ b/layout/ut/layout.h
@@ -152,6 +152,15 @@ int test_encode_decode_composite(uint64_t lid,
 				 bool if_contiguous_extents);
 void pair_set(struct c2_db_pair *pair, uint64_t *lid,
               void *area, c2_bcount_t num_bytes);
+int test_lookup_composite(uint64_t lid,
+			  struct c2_layout_domain *domain,
+			  uint32_t layers_nr,
+			  uint32_t min_extents_nr,
+			  c2_bindex_t min_start_offset,
+			  c2_bindex_t approximate_end_offset,
+			  bool if_contiguous_extents,
+			  bool existing_test,
+			  bool failure_test);
 int test_add_composite(uint64_t lid,
 		       struct c2_layout_domain *domain,
 		       uint32_t sublayouts_nr,
-- 
1.8.3.2

