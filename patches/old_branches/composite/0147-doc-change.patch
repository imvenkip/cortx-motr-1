From a9ac752afcfb2af4d51d32780b9444e8f19fda8d Mon Sep 17 00:00:00 2001
From: "trupti.patil" <trupti_patil@xyratex.com>
Date: Mon, 27 May 2013 10:24:04 +0530
Subject: [PATCH 147/172] doc change

---
 layout/composite.h | 24 +++++++++---------------
 1 file changed, 9 insertions(+), 15 deletions(-)

diff --git a/layout/composite.h b/layout/composite.h
index 7f1a227..db34966 100644
--- a/layout/composite.h
+++ b/layout/composite.h
@@ -66,6 +66,15 @@
  *    (4) Recoverable data is migrated from the old server to the new one.
  *    (5) Eventually, flattening operation will convert composite layouts to
  *        new non-composite layouts.
+ *
+ * @note After the in-memory composite layout may be updated using any of the
+ * following APIs, the user needs to explicitly invoke m0_layout_update() API
+ * so as to update the DB version of the layout:
+ * - m0_composite_layer_add()
+ * - m0_composite_layer_delete()
+ * - m0_composite_layer_ext_add()
+ * - m0_composite_layer_ext_state_update()
+ * - m0_composite_layer_ext_delete()
  * @{
  */
 
@@ -271,9 +280,6 @@ enum {
  *       the DB update made through the m0_layout_add() or
  *       the m0_layout_update() API), user count for the sublayout is
  *       incremented by one.
- *
- * @note After this API has been used, the user needs to explicitly invoke
- *       m0_layout_update() API so as to update the DB version of the layout.
  */
 M0_INTERNAL int m0_composite_layer_add(struct m0_composite_layout *cl,
 				       struct m0_layout *sublayout);
@@ -294,9 +300,6 @@ M0_INTERNAL int m0_composite_layer_add(struct m0_composite_layout *cl,
  *       the DB update made through the m0_layout_add() or
  *       the m0_layout_update() API), user count for the sublayout is
  *       decremented by one.
- *
- * @note After this API has been used, the user needs to explicitly invoke
- *       m0_layout_update() API so as to update the DB version of the layout.
  */
 M0_INTERNAL void m0_composite_layer_delete(struct m0_composite_layout *cl);
 
@@ -346,9 +349,6 @@ M0_INTERNAL int m0_composite_layer_ext_lookup(
  * @todo Adding an extent with the M0_CLRES_HOLE state, in fact means deleting
  * the extent which could be performed using m0_composite_layer_ext_del() as
  * well. So, shall we continue to support ext_state = M0_CLRES_VALID here?
- *
- * @note After this API has been used, the user needs to explicitly invoke
- *       m0_layout_update() API so as to update the DB version of the layout.
  */
 M0_INTERNAL int m0_composite_layer_ext_add(
 				struct m0_composite_layout *cl,
@@ -364,9 +364,6 @@ M0_INTERNAL int m0_composite_layer_ext_add(
  * The overlapping extents can be merged if and only if they are with the state
  * M0_CLRES_HOLE or with the state same as ext_state. If this criterion is
  * not satisfied, the error -EINVAL is returned.
- *
- * @note After this API has been used, the user needs to explicitly invoke
- *       m0_layout_update() API so as to update the DB version of the layout.
  */
 M0_INTERNAL int m0_composite_layer_ext_state_update(
 				struct m0_composite_layout *cl,
@@ -384,9 +381,6 @@ M0_INTERNAL int m0_composite_layer_ext_state_update(
  * - all with mixture of some with the state M0_CLRES_HOLE and some with one
  *   single state other than M0_CLRES_HOLE.
  * If this criterion is not satisfied, the error -EINVAL is returned.
- *
- * @note After this API has been used, the user needs to explicitly invoke
- *       m0_layout_update() API so as to update the DB version of the layout.
  */
 M0_INTERNAL int m0_composite_layer_ext_delete(struct m0_composite_layout *cl,
 					      uint32_t layer_idx,
-- 
1.8.3.2

