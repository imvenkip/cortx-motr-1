From 82589cf886bd0d7fad04ff4000930607013940da Mon Sep 17 00:00:00 2001
From: "trupti.patil" <trupti_patil@xyratex.com>
Date: Wed, 24 Apr 2013 14:23:22 +0530
Subject: [PATCH 121/172] - taking out db part from
 m0_composite_layer_ext_lookup

- adding a constraint to m0_layout_update() that the layout always has to be
  existing in the db prior to m0_layout_update() being invoked for it
- updating doc at some places
---
 layout/composite.c    | 215 ++++++++++----------------------------------------
 layout/composite.h    |  44 ++++++-----
 layout/layout.h       |   6 ++
 layout/layout_db.c    |  21 +++++
 layout/layout_db.h    |  29 ++++---
 layout/ut/composite.c | 174 +++++++++++++++++++---------------------
 layout/ut/composite.h |   1 -
 layout/ut/layout.c    |  64 ++++-----------
 layout/ut/pdclust.c   | 133 +++++++++++--------------------
 layout/ut/pdclust.h   |   1 -
 10 files changed, 255 insertions(+), 433 deletions(-)

diff --git a/layout/composite.c b/layout/composite.c
index 00f6dc3..337a682 100644
--- a/layout/composite.c
+++ b/layout/composite.c
@@ -554,8 +554,7 @@ static struct m0_composite_layer *layer_find(
 	return layer;
 }
 
-//todo Change the return type to void
-M0_INTERNAL int m0_composite_layer_delete(struct m0_composite_layout *cl)
+M0_INTERNAL void m0_composite_layer_delete(struct m0_composite_layout *cl)
 {
 	struct m0_composite_layer *layer;
 
@@ -572,7 +571,6 @@ M0_INTERNAL int m0_composite_layer_delete(struct m0_composite_layout *cl)
 	layer_inmem_delete(cl, layer);
 	m0_mutex_unlock(&cl->cl_base.l_lock);
 	M0_POST(composite_invariant(cl));
-	M0_RETURN(0);
 }
 
 static struct m0_layout *layout_find(struct m0_layout_domain *dom,
@@ -858,22 +856,15 @@ static int layer_indb_delete(struct m0_composite_layout *cl,
 			     struct m0_layout *sublayout,
 			     struct m0_db_tx *tx,
 			     bool in_update_path);
-static int comp_layout_indb_read(struct m0_composite_layout *cl,
-				 struct m0_db_tx *tx,
-				 uint32_t user_count,
-				 uint32_t layers_nr,
-				 uint64_t *sublayout_id_list);
-static int comp_layout_indb_add(struct m0_composite_layout *cl,
-				struct m0_db_tx *tx);
-static int comp_layout_indb_delete(struct m0_composite_layout *cl,
-				   struct m0_db_tx *tx, bool in_update_path);
-static int ext_indb_lookup(struct m0_composite_layout *cl,
-			   m0_bindex_t offset,
-			   struct m0_db_tx *tx,
-			   struct m0_ext *ext,
-			   uint32_t *layer_idx,
-			   uint64_t *ext_state,
-			   struct m0_layout **sublayout);
+static int layers_indb_read(struct m0_composite_layout *cl,
+			    struct m0_db_tx *tx,
+			    uint32_t user_count,
+			    uint32_t layers_nr,
+			    uint64_t *sublayout_id_list);
+static int layers_indb_add(struct m0_composite_layout *cl,
+			   struct m0_db_tx *tx);
+static int layers_indb_delete(struct m0_composite_layout *cl,
+			      struct m0_db_tx *tx, bool in_update_path);
 #endif
 
 /** Implementation of lo_decode() for composite layout type. */
@@ -914,8 +905,8 @@ static int composite_decode(struct m0_layout *l,
 			       "the buffer",
 			       (unsigned long long)cl->cl_base.l_id);
 	} else {
-		rc = comp_layout_indb_read(cl, tx, user_count,
-					   layers_nr, sublayout_id_list);
+		rc = layers_indb_read(cl, tx, user_count,
+				      layers_nr, sublayout_id_list);
 		if (rc != 0)
 			M0_LOG(M0_ERROR, "lid %llu, failed to read layout from "
 			       "the DB",
@@ -1012,7 +1003,7 @@ static int composite_encode(struct m0_layout *l,
 		layers_inbuf_write(cl, out);
 		rc = 0;
 	} else if (op == M0_LXO_DB_ADD) {
-		rc = comp_layout_indb_add(cl, tx);
+		rc = layers_indb_add(cl, tx);
 		if (rc == 0) {
 			for (i = 1; i < cl->cl_layers_nr; ++i) {
 				layer = layer_find(cl, i);
@@ -1028,14 +1019,9 @@ static int composite_encode(struct m0_layout *l,
 		 * deleted from the DB and then they are added newly by
 		 * referring to the current in-memory layout.
 		 */
-		rc = comp_layout_indb_delete(cl, tx, IN_UPDATE_PATH);
-		if (rc == 0 || rc == -ENOENT) {
-			/*
-			 * It is possible that the layout did not exist in
-			 * the DB until the point it is asked to be updated
-			 * directly. Hence the later condition above. todo?
-			 */
-			rc = comp_layout_indb_add(cl, tx);
+		rc = layers_indb_delete(cl, tx, IN_UPDATE_PATH);
+		if (rc == 0) {
+			rc = layers_indb_add(cl, tx);
 			if (rc == 0) {
 				for (i = 1; i < cl->cl_layers_nr; ++i) {
 					layer = layer_find(cl, i);
@@ -1046,7 +1032,7 @@ static int composite_encode(struct m0_layout *l,
 			}
 		}
 	} else {
-		rc = comp_layout_indb_delete(cl, tx, !IN_UPDATE_PATH);
+		rc = layers_indb_delete(cl, tx, !IN_UPDATE_PATH);
 		if (rc != 0)
 			M0_LOG(M0_ERROR, "lid %llu, layout could not be "
 			       "deleted from the DB",
@@ -1224,16 +1210,12 @@ static int ext_inmem_add(struct m0_composite_layer *layer,
 	M0_RETURN(rc);
 }
 
-/**
- * Looks up for a valid extent with the given offset, starting with the
- * top-most layer in the given composite layout.
- */
-static int ext_inmem_lookup(struct m0_composite_layout *cl,
-			    m0_bindex_t offset,
-			    struct m0_ext *ext,
-			    uint32_t *layer_idx,
-			    uint64_t *ext_state,
-			    struct m0_layout **sublayout)
+M0_INTERNAL int m0_composite_layer_ext_lookup(struct m0_composite_layout *cl,
+					      m0_bindex_t offset,
+					      struct m0_ext *ext,
+					      uint32_t *layer_idx,
+					      uint64_t *ext_state,
+					      struct m0_layout **sublayout)
 {
 	struct m0_composite_layer        *layer;
 	struct m0_composite_layer_extent *lr_ext;
@@ -1241,8 +1223,14 @@ static int ext_inmem_lookup(struct m0_composite_layout *cl,
 	uint32_t                          i;
 	int                               rc;
 
+	M0_PRE(composite_invariant(cl));
+	M0_PRE(offset >= 0 && offset <= M0_BINDEX_MAX);
+	M0_PRE(ext != NULL && layer_idx != NULL && ext_state != NULL &&
+	       sublayout != NULL);
+
 	M0_ENTRY("lid %llu, offset %llu", (unsigned long long)cl->cl_base.l_id,
 		 (unsigned long long)offset);
+	m0_mutex_lock(&cl->cl_base.l_lock);
 	/* Start the lookup with the top-most layer. */
 	layer = comp_layer_tlist_tail(&cl->cl_layers);
 	M0_ASSERT(layer != NULL);
@@ -1278,55 +1266,7 @@ static int ext_inmem_lookup(struct m0_composite_layout *cl,
 	} else
 		rc = -ENOENT;
 
-	M0_LEAVE("lid %llu, offset %llu, rc %d, layer %lu, ext_state %llu",
-		 (unsigned long long)cl->cl_base.l_id,
-		 (unsigned long long)offset, rc, (unsigned long)*layer_idx,
-		 (unsigned long long)*ext_state);
-	return rc;
-}
-
-M0_INTERNAL int m0_composite_layer_ext_lookup(struct m0_composite_layout *cl,
-					      m0_bindex_t offset,
-					      struct m0_db_tx *tx,
-					      struct m0_ext *ext,
-					      uint32_t *layer_idx,
-					      uint64_t *ext_state,
-					      struct m0_layout **sublayout)
-{
-	int rc;
-
-	M0_PRE(composite_invariant(cl));
-	M0_PRE(offset >= 0 && offset <= M0_BINDEX_MAX);
-	M0_PRE(ext != NULL && layer_idx != NULL && ext_state != NULL &&
-	       sublayout != NULL);
-	M0_PRE(ergo(cl->cl_base.l_dom->ld_is_db_available, tx != NULL));
 
-	M0_ENTRY("lid %llu, offset %llu", (unsigned long long)cl->cl_base.l_id,
-		 (unsigned long long)offset);
-	m0_mutex_lock(&cl->cl_base.l_lock);
-
-	if (M0_FI_ENABLED("ext_inmem_lookup_err"))
-		{ rc = L_EXT_INMEM_LOOKUP_ERR; goto err1_injected; }
-	rc = ext_inmem_lookup(cl, offset, ext,
-			      layer_idx, ext_state, sublayout);
-err1_injected:
-	if (rc != 0 && cl->cl_base.l_dom->ld_is_db_available) {
-		/*
-		 * In the current implementation, the in-memory layout is
-		 * always necessarily up-to-date. Hence, it is not possible
-		 * to hit this exception that 'the offset is not found in the
-		 * in-memory layout and can be found in the in-DB layout'. It
-		 * will be required when a network request is supported to
-		 * fetch partial composite layout due to its possibly large
-		 * size.
-		 */
-		M0_LOG(M0_DEBUG, "lid %llu, offset %llu, rc %d, Offset not "
-		       "found in the in-memory layout. Looking up into the DB.",
-		       (unsigned long long)cl->cl_base.l_id,
-		       (unsigned long long)offset, rc);
-		rc = ext_indb_lookup(cl, offset, tx, ext,
-				     layer_idx, ext_state, sublayout);
-	}
 	m0_mutex_unlock(&cl->cl_base.l_lock);
 	M0_LEAVE("lid %llu, offset %llu, rc %d, layer %lu, ext_state %llu",
 		 (unsigned long long)cl->cl_base.l_id,
@@ -1705,7 +1645,6 @@ M0_INTERNAL int m0_composite_layer_ext_add(struct m0_composite_layout *cl,
 	M0_PRE(composite_invariant(cl));
 	M0_PRE(ext != NULL);
 	M0_PRE(!m0_ext_is_empty(ext));
-	//todo M0_PRE(M0_IN(ext_state, (M0_CLRES_VALID, M0_CLRES_FLATTENING)));
 	M0_PRE(M0_IN(ext_state, (M0_CLRES_HOLE, M0_CLRES_VALID,
 				 M0_CLRES_FLATTENING)));
 
@@ -1723,7 +1662,7 @@ M0_INTERNAL int m0_composite_layer_ext_add(struct m0_composite_layout *cl,
 		       M0_LAYOUT_ADDB_LOC_COMP_EXT_ADD,
 		       &cl->cl_base.l_addb_ctx, cl->cl_base.l_id, rc);
 	m0_mutex_unlock(&cl->cl_base.l_lock);
-	M0_POST(ergo(rc == 0, layer_invariant(layer))); //todo rc == 0 ?
+	M0_POST(layer_invariant(layer));
 	M0_POST(composite_invariant(cl));
 	M0_LEAVE("lid %llu, layer %lu, e_start %llu, e_end %llu, "
 		 "e_state %llu, rc %d", (unsigned long long)cl->cl_base.l_id,
@@ -2076,16 +2015,15 @@ static int extentmap_indb_read(struct m0_composite_layout *cl,
 	M0_RETURN(rc);
 }
 
-//todo rename layers_indb_read()
 /**
  * Reads 'the composite layout type specific information including all the
  * layers' from the DB and adds it to the in-memory layout.
  */
-static int comp_layout_indb_read(struct m0_composite_layout *cl,
-				 struct m0_db_tx *tx,
-				 uint32_t user_count,
-				 uint32_t layers_nr,
-				 uint64_t *sublayout_id_list)
+static int layers_indb_read(struct m0_composite_layout *cl,
+			    struct m0_db_tx *tx,
+			    uint32_t user_count,
+			    uint32_t layers_nr,
+			    uint64_t *sublayout_id_list)
 {
 	struct m0_layout                 *sublayout;
 	struct m0_tl                      extlist;
@@ -2146,7 +2084,7 @@ static int comp_layout_indb_read(struct m0_composite_layout *cl,
 						     EXT_MERGE_VALIDATION);
 				M0_ASSERT(rc == 0); //todo
 			} m0_tl_endfor;
-			extlist_free(&extlist); //todo Organization, simple tlist
+			extlist_free(&extlist); //todo Organization,
 		} else {
 			extlist_free(&extlist);
 			break;
@@ -2164,8 +2102,8 @@ static int comp_layout_indb_read(struct m0_composite_layout *cl,
 	M0_RETURN(rc);
 }
 
-static int comp_layout_indb_add(struct m0_composite_layout *cl,
-				struct m0_db_tx *tx)
+static int layers_indb_add(struct m0_composite_layout *cl,
+			   struct m0_db_tx *tx)
 {
 	struct m0_composite_layer *layer;
 	int                        rc;
@@ -2219,7 +2157,6 @@ err1_injected:
 		return rc;
 	}
 
-	//todo Change m0_emap_paste() such that it accepts NULL cb pointers
 	if (M0_FI_ENABLED("emap_paste_err"))
 		{ rc = L_EMAP_PASTE_ERR; goto err2_injected; }
 	rc = m0_emap_paste(&it, &ext, M0_CLRES_HOLE,
@@ -2398,8 +2335,8 @@ static int existing_layers_nr_n_sl_id_list_read(struct m0_composite_layout *cl,
  * @pre A composite layout can be deleted from the DB if and only if
  * none of its layers contain any valid extents.
  */
-static int comp_layout_indb_delete(struct m0_composite_layout *cl,
-				   struct m0_db_tx *tx, bool in_update_path)
+static int layers_indb_delete(struct m0_composite_layout *cl,
+			      struct m0_db_tx *tx, bool in_update_path)
 {
 	struct m0_composite_layer *layer;
 	struct m0_emap            *emap;
@@ -2458,78 +2395,6 @@ static int comp_layout_indb_delete(struct m0_composite_layout *cl,
 	return rc;
 }
 
-static int ext_indb_lookup(struct m0_composite_layout *cl,
-			   m0_bindex_t offset,
-			   struct m0_db_tx *tx,
-			   struct m0_ext *ext,
-			   uint32_t *layer_idx,
-			   uint64_t *ext_state,
-			   struct m0_layout **sublayout)
-{
-	struct m0_emap            *emap;
-	struct m0_emap_cursor      it;
-	struct m0_emap_seg        *seg;
-	struct m0_composite_layer *layer;
-	uint32_t                   i; /* layer idx */
-	bool                       found;
-	int                        rc;
-
-	M0_PRE(tx != NULL);
-	M0_ENTRY("lid %llu, offset %llu", (unsigned long long)cl->cl_base.l_id,
-		 (unsigned long long)offset);
-	emap = emap_from_cl(cl);
-
-	/* Start the lookup with the top-most layer. */
-	i = cl->cl_layers_nr - 1;
-	found = false;
-	while (1) {
-		rc = emap_iterator_set(cl, emap, i, offset, tx, &it);
-		if (rc != 0) {
-			M0_LEAVE("lid %llu, layer %lu, rc %d",
-				 (unsigned long long)cl->cl_base.l_id,
-				 (unsigned long)i, rc);
-			return rc;
-		}
-		seg = m0_emap_seg_get(&it);
-		m0_emap_close(&it);
-		M0_ASSERT(seg != NULL);
-		M0_ASSERT(!m0_ext_is_empty(&seg->ee_ext));
-		M0_ASSERT(M0_IN(seg->ee_val, (M0_CLRES_HOLE, M0_CLRES_VALID,
-					      M0_CLRES_FLATTENING)));
-
-		if (seg->ee_val != M0_CLRES_HOLE) {
-			found = true;
-			break;
-		}
-
-		if (i > 0)
-			--i;
-		else
-			break;
-	}
-
-	if (rc == 0) {
-		if (found == true) {
-			*ext = seg->ee_ext;
-			*layer_idx = i;
-			*ext_state = seg->ee_val;
-			layer = layer_find(cl, *layer_idx);
-			M0_ASSERT(layer != NULL);
-			*sublayout = layer->clr_sl;
-			rc = 0;
-		} else
-			rc = -ENOENT;
-	}
-
-	M0_LOG(M0_DEBUG, "lid %llu, offset %llu, rc %d, e_start %llu, "
-	       "e_end %llu, layer_idx %lu, ext_state %llu",
-	       (unsigned long long)cl->cl_base.l_id, (unsigned long long)offset,
-	       rc, (unsigned long long)seg->ee_ext.e_start,
-	       (unsigned long long)seg->ee_ext.e_end,
-	       (unsigned long)i, (unsigned long long)seg->ee_val);
-	M0_RETURN(rc);
-}
-
 M0_INTERNAL struct m0_composite_layout *m0_layout_to_cl(
 						const struct m0_layout *l)
 {
diff --git a/layout/composite.h b/layout/composite.h
index 19f7889..4bbadfa 100644
--- a/layout/composite.h
+++ b/layout/composite.h
@@ -148,12 +148,12 @@ struct m0_composite_layer {
 /**
  * State of an extent.
  *
- * State of an extent is stored (in memory and in the DB) along with each
- * extent from the extent mask and it indicates whether an extent is associated
+ * State of an extent is stored (in memory and in the DB) along with 'each
+ * extent from the extent mask'. It indicates whether an extent is associated
  * with a particular layer.
  *
- * Two back-to-back extents can be merged if and only if their states are the
- * same.
+ * Two back-to-back extents can be merged if and only if 'their states are the
+ * same' or if 'either of those or both of those are M0_CLRES_HOLE'.
  */
 enum m0_composite_layer_ext_state {
 	/**
@@ -254,10 +254,9 @@ M0_INTERNAL int m0_composite_build(struct m0_layout_domain *dom,
  * Multiple extents can be subsequently added to this layer, by explicitly
  * using the API m0_composite_layer_ext_add().
  *
- * @pre The composite layout has been added to the DB. todo mostly not req'd
- *
  * @post A reference has been added to the sublayout.
- *       When this layer gets added to the DB version of the layout (through
+ *
+ * @note When this layer gets added to the DB version of the layout (through
  *       the DB update made through the m0_layout_add() or
  *       the m0_layout_update() API), user count for the sublayout is
  *       incremented by one.
@@ -269,14 +268,19 @@ M0_INTERNAL int m0_composite_layer_add(struct m0_composite_layout *cl,
 				       struct m0_layout *sublayout);
 
 /**
- * Deletes the top-most layer from the composite layout, provided the top-most
- * layer is not the zeroth one.
+ * Deletes the top-most layer from the composite layout, provided 'the top-most
+ * layer is not the zeroth one' and that 'the top-most layer does not contain
+ * any non-hole extents'.
  *
- * @pre The top-most layer does not contain any valid extent.
+ * @pre M0_PRE(cl->cl_layers_nr > 1),
+ *      M0_PRE(m0_tl_forall(m0_composite_layer_ext, lr_ext,
+ *                          &layer->clr_extents,
+ *                          lr_ext->cle_state == M0_CLRES_HOLE));
  *
  * @post A reference has been released from the sublayout associated with the
  *       top-most layer.
- *       When this layer gets deleted from the DB version of the layout (through
+ *
+ * @note When this layer gets deleted from the DB version of the layout (through
  *       the DB update made through the m0_layout_add() or
  *       the m0_layout_update() API), user count for the sublayout is
  *       deccremented by one.
@@ -284,7 +288,7 @@ M0_INTERNAL int m0_composite_layer_add(struct m0_composite_layout *cl,
  * @note After this API has been used, the user needs to explicitly invoke
  *       m0_layout_update() API so as to update the DB version of the layout.
  */
-M0_INTERNAL int m0_composite_layer_delete(struct m0_composite_layout *cl);
+M0_INTERNAL void m0_composite_layer_delete(struct m0_composite_layout *cl);
 
 /**
  * @todo Shall we add an API that will delete 'the second from the top layer'
@@ -294,17 +298,12 @@ M0_INTERNAL int m0_composite_layer_delete(struct m0_composite_layout *cl);
 
 /**
  * Looks up for a valid extent containing the given offset, starting with the
- * top-most layer
- * - in the in-meory layout.
- * - If the offset is not found in any of the valid extents there, then looks
- *   up into the in-DB layout.
- * If such an extent is found, along with the extent, returns 'the layer
+ * top-most layer.
+ * If such an extent is found, returns the extent along with 'the layer
  * index','the state of the extent' and 'the sublayout owned by the specific
  * layer'.
  *
  * @param offset 'In' paramemer to specify the offset to be looked up.
- * @param tx 'In' paramemer to specify the transaction to be used. It shall be
- *        non-NULL if the associated layout domain has access to the DB.
  * @param ext 'Out' parameter to report back the extent the offset belongs to.
  * @param layer_idx 'Out' parameter to report back the layer the extent belongs
  *        to.
@@ -319,7 +318,6 @@ M0_INTERNAL int m0_composite_layer_delete(struct m0_composite_layout *cl);
  */
 M0_INTERNAL int m0_composite_layer_ext_lookup(struct m0_composite_layout *cl,
 					      m0_bindex_t offset,
-					      struct m0_db_tx *tx,
 					      struct m0_ext *ext,
 					      uint32_t *layer_idx,
 					      uint64_t *ext_state,
@@ -334,6 +332,12 @@ M0_INTERNAL int m0_composite_layer_ext_lookup(struct m0_composite_layout *cl,
  * M0_CLRES_HOLE or with the state same as ext_state. If this criterion is
  * not satisfied, the error -EINVAL is returned.
  *
+ * @pre M0_PRE(M0_IN(ext_state, (M0_CLRES_HOLE, M0_CLRES_VALID,
+ *                               M0_CLRES_FLATTENING)));
+ * @todo Adding an extent with the M0_CLRES_HOLE state, in fact means deleting
+ * the extent which could be performed using m0_composite_layer_ext_del() as
+ * well. So, shall we support ext_state = M0_CLRES_VALID here?
+ *
  * @note After this API has been used, the user needs to explicitly invoke
  *       m0_layout_update() API so as to update the DB version of the layout.
  */
diff --git a/layout/layout.h b/layout/layout.h
index a9eefc5..97b06f5 100644
--- a/layout/layout.h
+++ b/layout/layout.h
@@ -781,6 +781,9 @@ M0_INTERNAL void m0_layout_put(struct m0_layout *l);
  * Increments layout user count.
  * This API shall be used by the user to associate a specific layout with some
  * user of that layout, for example, while creating 'a file using that layout'.
+ *
+ * @note After this API has been used, the user needs to explicitly invoke
+ *       m0_layout_update() API so as to update the DB version of the layout.
  */
 M0_INTERNAL void m0_layout_user_count_inc(struct m0_layout *l);
 
@@ -788,6 +791,9 @@ M0_INTERNAL void m0_layout_user_count_inc(struct m0_layout *l);
  * Decrements layout user count.
  * This API shall be used by the user to dissociate a layout from some user of
  * that layout, for example, while deleting 'a file using that layout'.
+ *
+ * @note After this API has been used, the user needs to explicitly invoke
+ *       m0_layout_update() API so as to update the DB version of the layout.
  */
 M0_INTERNAL void m0_layout_user_count_dec(struct m0_layout *l);
 
diff --git a/layout/layout_db.c b/layout/layout_db.c
index 322eeb9..70e2e34 100644
--- a/layout/layout_db.c
+++ b/layout/layout_db.c
@@ -616,7 +616,28 @@ M0_INTERNAL int m0_layout_update(struct m0_layout *l,
 
 	M0_ENTRY("lid %llu", (unsigned long long)l->l_id);
 	m0_mutex_lock(&l->l_lock);
+	/*
+	 * We just need the generic layout data (and not the type specific data
+	 * as is stored in the primary table). So it does not matter even if the
+	 * record spans beyond lo_recsize(l). Hence, avoiding 'to use
+	 * m0_layout_max_recsize(l->l_dom) and then resetting back to use
+	 * lo_recsize(l)'.
+	 */ 
 	recsize = l->l_ops->lo_recsize(l);
+
+	/* First verify that the layout does exist in the DB. */
+	rc = pair_init(pair, l, tx, M0_LXO_DB_LOOKUP, recsize);
+	M0_ASSERT(rc == 0);
+	rc = m0_table_lookup(tx, pair);
+	M0_ASSERT(rc != -ENOENT);
+	if (rc != 0) {
+		m0_layout__log("m0_layout_update",
+			       "m0_table_lookup() failed",
+			       M0_LAYOUT_ADDB_LOC_UPDATE_1,
+			       &l->l_addb_ctx, l->l_id, rc);
+		M0_RETURN(rc);
+	}
+
 	rc = pair_init(pair, l, tx, M0_LXO_DB_UPDATE, recsize);
 	if (rc == 0) {
 		if (M0_FI_ENABLED("table_update_err"))
diff --git a/layout/layout_db.h b/layout/layout_db.h
index c15f205..3d064b8 100644
--- a/layout/layout_db.h
+++ b/layout/layout_db.h
@@ -157,10 +157,26 @@ M0_INTERNAL int m0_layout_add(struct m0_layout *l,
 			      struct m0_db_tx *tx, struct m0_db_pair *pair);
 
 /**
- * Updates a layout record from the DB. The only field that can be updated for
- * an existing layout in the layout DB is its user count. It is not prevented
- * through the implementation to update any other fields since it was found to
- * be costly through performance perspective.
+ * Updates a layout record from the DB.
+ *
+ * In case of a layout with the PDCLUST type, the only field that is expected
+ * to be updated for 'an existing layout in the layout DB' is its user count.
+ * It is not prevented through the implementation to update any
+ * other fields since it was considered to be costly through performance
+ * perspective.
+ *
+ * In case of a layout with the COMPOSITE type existing in the layout DB,
+ * along with user count of the layout, the layer and the extents information
+ * can be updated. For example, layers can be added/deleted, extents can be
+ * added/updated/deleted.
+ *
+ * @pre Layout exists in the DB prior to m0_layout_update() call.
+ *
+ * @note Even if the DB API m0_table_update() supports updating/adding a
+ * non-existing record, m0_layout_update() does not support updating/adding
+ * a non-existing layout. This is since some of the auxiliary tables are not
+ * written to in case of m0_layout_update() operation. For example, cob_lists
+ * table that is specific for LIST enumeration.
  *
  * @param pair A m0_db_pair sent by the caller along with having set
  * pair->dp_key.db_buf and pair->dp_rec.db_buf. This is to leave the buffer
@@ -170,11 +186,6 @@ M0_INTERNAL int m0_layout_add(struct m0_layout *l,
  * The buffer size should be large enough to contain the data that is to be
  * written specifically to the layouts table. It means it needs to be at the
  * most the size returned by m0_layout_max_recsize().
- *
- * @note Even a non-existing record can be written to the database using
- * the database update operation. In other words, not using m0_layout_add()
- * and directly using m0_layout_update() results into the layout record being
- * written to the DB.
  */
 M0_INTERNAL int m0_layout_update(struct m0_layout *l,
 				 struct m0_db_tx *tx, struct m0_db_pair *pair);
diff --git a/layout/ut/composite.c b/layout/ut/composite.c
index 0f372c3..4912442 100644
--- a/layout/ut/composite.c
+++ b/layout/ut/composite.c
@@ -481,7 +481,7 @@ static int composite_build_and_layers_add(uint64_t lid,
 					  uint32_t layers_nr,
 					  uint32_t min_extents_nr,
 					  bool if_contiguous_extents,
-					  bool is_add_to_db,
+					  bool is_add_to_db, //todo check if reqd
 					  bool failure_test,
 					  bool layer_add_failure_test,
 					  struct m0_composite_layout **cl)
@@ -1366,15 +1366,8 @@ int test_layer_ops_composite(uint64_t lid,
 	layer_extents_delete(cl, layer);
 
 	/* Now, delete the layer. */
-	rc = m0_composite_layer_delete(cl);
-	if (layer_del_failure_test) {
-		M0_UT_ASSERT(rc == L_TABLE_DEL_ERR || rc == L_EMAP_LOOKUP_ERR ||
-			     rc == L_EMAP_OBJ_DEL_ERR);
-		goto exit;
-	} else {
-		M0_UT_ASSERT(rc == 0);
-		M0_ASSERT(cl->cl_layers_nr = layers_nr - 1);
-	}
+	m0_composite_layer_delete(cl);
+	M0_ASSERT(cl->cl_layers_nr = layers_nr - 1);
 
 	/* Verify the layout. */
 	composite_layout_verify(l, lid, layers_nr - 1, min_extents_nr,
@@ -1567,7 +1560,7 @@ static int ext_op_pre(enum extent_operation eop,
 	/* Initial lookup verifying that the result is as expected. */
 	rc = 0;
 	rc_tmp = m0_composite_layer_ext_lookup(*cl, *offset_to_operate,
-					       txptr, &ext_lookup,
+					       &ext_lookup,
 					       &layer_id_lookup,
 					       ext_state_lookup,
 					       &sublayout_lookup);
@@ -1725,7 +1718,7 @@ static int ext_add(struct m0_composite_layout *cl,
 		extlist_dump(cl, cl->cl_layers_nr - 1);
 
 		rc = m0_composite_layer_ext_lookup(cl, offset_to_operate,
-						   txptr, &ext_lookup,
+						   &ext_lookup,
 						   &layer_id_lookup,
 						   &ext_state_lookup,
 						   &sublayout_lookup);
@@ -1788,7 +1781,7 @@ static int ext_update(struct m0_composite_layout *cl,
 		extlist_dump(cl, cl->cl_layers_nr - 1);
 
 		rc = m0_composite_layer_ext_lookup(cl, offset_to_operate,
-						   txptr, &ext_lookup,
+						   &ext_lookup,
 						   &layer_id_lookup,
 						   &ext_state_lookup,
 						   &sublayout_lookup);
@@ -1845,7 +1838,7 @@ static int ext_delete(struct m0_composite_layout *cl,
 				  (unsigned long long)ext_to_operate->e_end);
 		extlist_dump(cl, cl->cl_layers_nr - 1);
 
-		rc = m0_composite_layer_ext_lookup(cl, offset_to_operate, txptr,
+		rc = m0_composite_layer_ext_lookup(cl, offset_to_operate,
 						   &ext_lookup,
 						   &layer_id_lookup,
 						   &ext_state_lookup,
@@ -2187,6 +2180,7 @@ void test_layer_ext_ops_composite_failure(uint64_t base_lid,
 	M0_UT_ASSERT(ergo(domain->ld_is_db_available, base_lid == 29000));
 	M0_UT_ASSERT(ergo(!domain->ld_is_db_available, base_lid == 17000));
 
+#if 0 //todo rm
 	/*
 	 * Simulate a situation that a valid extent with the given offset is
 	 * not found in the memory but is found in the DB.
@@ -2201,6 +2195,7 @@ void test_layer_ext_ops_composite_failure(uint64_t base_lid,
 	M0_ASSERT(ergo(domain->ld_is_db_available, rc == 0));
 	M0_ASSERT(ergo(!domain->ld_is_db_available,
 		       rc == L_EXT_INMEM_LOOKUP_ERR));
+#endif
 
 #if 0 //todo enable, not working at this point
 	/*
@@ -2456,16 +2451,15 @@ int test_update_composite(uint64_t lid,
 			  uint32_t layers_nr,
 			  uint32_t min_extents_nr,
 			  bool if_contiguous_extents,
-			  bool existing_test,
 			  bool failure_test)
 {
 	m0_bcount_t                 num_bytes;
 	void                       *area;
 	struct m0_composite_layout *cl;
 	struct m0_layout           *l1;
-	struct m0_layout           *l1_copy1;
-	struct m0_layout           *l1_copy2;
-	struct m0_layout           *l2;
+	struct m0_layout           *l1_original_copy;
+	struct m0_layout           *l1_changed_copy;
+	struct m0_layout           *l_from_db;
 	struct m0_db_pair           pair;
 	struct m0_db_tx             tx;
 	struct m0_layout           *sublayout;
@@ -2490,36 +2484,37 @@ int test_update_composite(uint64_t lid,
 	M0_UT_ASSERT(rc == 0);
 	l1 = &cl->cl_base;
 
+	/* Add the layout along with its layers to the DB. */
+	rc = m0_db_tx_init(&tx, domain->ld_dbenv, DBFLAGS);
+	M0_UT_ASSERT(rc == 0);
 	allocate_area(domain, ADDITIONAL_BYTES_NONE, &num_bytes, &area);
+	pair_set(&pair, &lid, area, num_bytes);
+	rc = m0_layout_add(l1, &tx, &pair);
+	M0_UT_ASSERT(rc == 0);
+	rc = m0_db_tx_commit(&tx);
+	M0_UT_ASSERT(rc == 0);
 
-	if (existing_test) {
-		/* Add the layout along with its layers to the DB. */
-		rc = m0_db_tx_init(&tx, domain->ld_dbenv, DBFLAGS);
-		M0_UT_ASSERT(rc == 0);
-		pair_set(&pair, &lid, area, num_bytes);
-		rc = m0_layout_add(l1, &tx, &pair);
-		M0_UT_ASSERT(rc == 0);
-		rc_tmp = m0_db_tx_commit(&tx);
-		M0_UT_ASSERT(rc_tmp == 0);
-	}
+	/* Make a copy of 'the layout as has been added to the DB'. */
+	if (failure_test)
+		composite_layout_copy(l1, &l1_original_copy);
 
 	/* Verify the original user count is as expected. */
 	M0_UT_ASSERT(l1->l_user_count == 0);
 
 	/* Alter the in-memory layout. */
-	M0_UT_ASSERT(domain->ld_is_db_available == true);
-	domain_ldb_available_set(domain, false);
+	M0_UT_ASSERT(domain->ld_is_db_available == true); //todo need changes
+	domain_ldb_available_set(domain, false); //todo need changes
 
 	/* 1. Alter user count. */
 	for (i = 0; i < 100; ++i)
 		m0_layout_user_count_inc(l1);
 	M0_UT_ASSERT(l1->l_user_count == 100);
 
-	/* 2. Add an extent to its top-most layer - only in in-memory layout. */
+	/* 2. Add an extent to its top-most layer. */
 	extent_to_be_operated(cl, if_contiguous_extents, 1, 1,
 			      NON_EXISTING, &ext_to_operate);
 	rc = m0_composite_layer_ext_lookup(cl, ext_to_operate.e_start + 1,
-					   NULL, &ext_lookup, &layer_id_lookup,
+					   &ext_lookup, &layer_id_lookup,
 					   &ext_state_lookup,
 					   &sublayout_lookup);
 	M0_UT_ASSERT(rc == -ENOENT);
@@ -2527,10 +2522,11 @@ int test_update_composite(uint64_t lid,
 					&ext_to_operate, M0_CLRES_FLATTENING);
 	M0_UT_ASSERT(rc == 0);
 	rc = m0_composite_layer_ext_lookup(cl, ext_to_operate.e_start + 1,
-					   NULL, &ext_lookup, &layer_id_lookup,
+					   &ext_lookup, &layer_id_lookup,
 					   &ext_state_lookup,
 					   &sublayout_lookup);
 	M0_UT_ASSERT(rc == 0);
+	M0_UT_ASSERT(ext_state_lookup == M0_CLRES_FLATTENING);
 
 	/*
 	 * todo Ensure to lookup only in the in-DB layout to verify the
@@ -2563,15 +2559,12 @@ int test_update_composite(uint64_t lid,
 	M0_ASSERT(cl->cl_layers_nr == layers_nr + 4);
 	for (i = 0; i < 2; ++i) {
 		//todo Need to delete all the extents
-		rc = m0_composite_layer_delete(cl);
-		M0_ASSERT(rc == 0);
+		m0_composite_layer_delete(cl);
+		M0_ASSERT(cl->cl_layers_nr == ...);
 	}
 	M0_ASSERT(cl->cl_layers_nr == layers_nr + 2);
 #endif
 
-	if (failure_test)
-		composite_layout_copy(l1, &l1_copy1);
-
 	domain_ldb_available_set(domain, true);
 
 	/* Update the layout object in the DB. */
@@ -2580,74 +2573,69 @@ int test_update_composite(uint64_t lid,
 	M0_UT_ASSERT(rc == 0);
 
 	rc = m0_layout_update(l1, &tx, &pair);
-	rc_tmp = m0_db_tx_commit(&tx);
-	M0_UT_ASSERT(rc_tmp == 0);
-
 	if (failure_test) {
 		M0_UT_ASSERT(rc == LO_ENCODE_ERR || rc == L_TABLE_UPDATE_ERR ||
 			     rc == L_TABLE_INSERT_ERR ||
 			     rc == L_EMAP_LOOKUP_ERR || rc == L_EMAP_PASTE_ERR);
-
-		/* Verify that the update op has not altered the layout. */
-		composite_layout_compare(l1_copy1, l1, false);
-		composite_layout_copy_delete(l1_copy1);
-
-		/* Delete the in-memory layout. */
-		m0_layout_put(l1);
-		M0_UT_ASSERT(list_lookup(domain, lid) == NULL);
-
-		/* Delete the precreated sublayouts. */
-		sublayouts_delete(domain, lid, layers_nr + 4);
-
-		m0_free(area);
-		return rc;
+		/*
+		 * Abort the transaction. It is possible that some updates were
+		 * made and then the error was encountered. Aborting the
+		 * transaction ensures that the half way changes do not make it
+		 * into the on-disk DB.
+		 */
+		rc_tmp = m0_db_tx_abort(&tx);
+		M0_UT_ASSERT(rc_tmp == 0);
+	} else {
+		M0_UT_ASSERT(rc == 0);
+		rc_tmp = m0_db_tx_commit(&tx);
+		M0_UT_ASSERT(rc_tmp == 0);
+		composite_layout_copy(l1, &l1_changed_copy);
 	}
-	M0_UT_ASSERT(rc == 0);
-
-	/* Verify that the ext is updated right. */
-	rc = m0_db_tx_init(&tx, domain->ld_dbenv, DBFLAGS);
-	M0_UT_ASSERT(rc == 0);
-	rc = m0_composite_layer_ext_lookup(cl, ext_to_operate.e_start + 1,
-					   &tx, &ext_lookup, &layer_id_lookup,
-					   &ext_state_lookup,
-					   &sublayout_lookup);
-	M0_UT_ASSERT(rc == 0);
-	rc_tmp = m0_db_tx_commit(&tx);
-	M0_UT_ASSERT(rc_tmp == 0);
-
-	/*
-	 * Since the auxiliary tables for composite layout type are updated
-	 * with the m0_layout_update() operation, m0_layout_update() on a
-	 * layout with composite type that does not exist in the DB results
-	 * into the layout being written to the DB.
-	 */
-	composite_layout_copy(l1, &l1_copy2);
 
 	/* Delete the in-memory layout. */
 	m0_layout_put(l1);
 	M0_UT_ASSERT(list_lookup(domain, lid) == NULL);
 
-	//Verify structuring of code in this fn e.g. where shud be the
-	//check for user count, extent verification  etc.
-	/*
-	 * Lookup for the layout object from the DB to verify that it is
-	 * updated in the DB as expected.
-	 */
-	rc = layout_lookup(lid, domain, &m0_composite_layout_type,
-			   !FAILURE_TEST, &l2);
-	M0_UT_ASSERT(rc == 0);
-	M0_UT_ASSERT(l2->l_user_count == 100);
-	M0_UT_ASSERT(m0_ref_read(&l2->l_ref) == 1);
+	/* Lookup for the layout object from the DB. */
+	rc_tmp = layout_lookup(lid, domain, &m0_composite_layout_type,
+			       !FAILURE_TEST, &l_from_db);
+	M0_UT_ASSERT(rc_tmp == 0);
 
-	/*
-	 * Compare the two layouts - one created earlier here and the
-	 * one that is looked up from the DB.
-	 */
-	composite_layout_compare(l1_copy2, l2, false);
-	composite_layout_copy_delete(l1_copy2);
+	if (failure_test) {
+		/* Verify that the layout remained unchanged in the DB. */
+		composite_layout_compare(l1_original_copy, l_from_db, false);
+		composite_layout_copy_delete(l1_original_copy);
+	} else {
+		/* Verify that the user count is indeed updated. */
+		M0_UT_ASSERT(l_from_db->l_user_count == 100);
+		M0_UT_ASSERT(m0_ref_read(&l_from_db->l_ref) == 1);
+
+		composite_layout_compare(l1_changed_copy, l_from_db, false);
+		composite_layout_copy_delete(l1_changed_copy);
+
+		/*
+		 * Verify that the ext is updated right. This is actually
+		 * verified by comparing the layouts. But still to be sure.
+		 */
+		rc = m0_db_tx_init(&tx, domain->ld_dbenv, DBFLAGS);
+		M0_UT_ASSERT(rc == 0);
+		rc = m0_composite_layer_ext_lookup(cl,
+						   ext_to_operate.e_start + 1,
+						   &ext_lookup,
+						   &layer_id_lookup,
+						   &ext_state_lookup,
+						   &sublayout_lookup);
+		M0_UT_ASSERT(rc == 0);
+		M0_UT_ASSERT(layer_id_lookup == layers_nr - 1);
+		M0_UT_ASSERT(ext_state_lookup == M0_CLRES_FLATTENING);
+		rc_tmp = m0_db_tx_commit(&tx);
+		M0_UT_ASSERT(rc_tmp == 0);
+
+		//todo layer verification.
+	}
 
 	/* Delete the in-memory layout. */
-	m0_layout_put(l2);
+	m0_layout_put(l_from_db);
 	M0_UT_ASSERT(list_lookup(domain, lid) == NULL);
 
 	/* Delete the precreated sublayouts. */
diff --git a/layout/ut/composite.h b/layout/ut/composite.h
index 5d4df93..d717b03 100644
--- a/layout/ut/composite.h
+++ b/layout/ut/composite.h
@@ -135,7 +135,6 @@ int test_update_composite(uint64_t lid,
 			  uint32_t sublayouts_nr,
 			  uint32_t min_extents_nr,
 			  bool if_contiguous_extents,
-			  bool existing_test,
 			  bool failure_test);
 int test_delete_composite(uint64_t lid,
 			  struct m0_layout_domain *domain,
diff --git a/layout/ut/layout.c b/layout/ut/layout.c
index efd3a04..77cc662 100644
--- a/layout/ut/layout.c
+++ b/layout/ut/layout.c
@@ -1889,25 +1889,12 @@ static void test_update(void)
 	domain_ldb_available_set(&domain, true);
 
 	/*
-	 * Update a layout object with PDCLUST layout type and LIST enum type,
-	 * that does not exist in the DB. This results into the layout being
-	 * written newly to the DB as is done in case of m0_layout_add().
-	 * See m0_layout_update().
-	 */
-	lid = 22001;
-	rc = test_update_pdclust(lid, &domain,
-				 LIST_ENUM_ID, MORE_THAN_INLINE,
-				 !EXISTING_TEST, !FAILURE_TEST);
-	M0_UT_ASSERT(rc == 0);
-
-	/*
 	 * Update a layout object with PDCLUST layout type, LIST enum type and
 	 * with a few inline entries only.
 	 */
 	lid = 22002;
-	rc = test_update_pdclust(lid, &domain,
-				 LIST_ENUM_ID, LESS_THAN_INLINE,
-				 EXISTING_TEST, !FAILURE_TEST);
+	rc = test_update_pdclust(lid, &domain, LIST_ENUM_ID, LESS_THAN_INLINE,
+				 !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
 	/*
@@ -1916,9 +1903,8 @@ static void test_update(void)
 	 * LDB_MAX_INLINE_COB_ENTRIES.
 	 */
 	lid = 22003;
-	rc = test_update_pdclust(lid, &domain,
-				 LIST_ENUM_ID, EXACT_INLINE,
-				 EXISTING_TEST, !FAILURE_TEST);
+	rc = test_update_pdclust(lid, &domain, LIST_ENUM_ID, EXACT_INLINE,
+				 !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
 	/*
@@ -1926,9 +1912,8 @@ static void test_update(void)
 	 * type including noninline entries.
 	 */
 	lid = 22004;
-	rc = test_update_pdclust(lid, &domain,
-				 LIST_ENUM_ID, MORE_THAN_INLINE,
-				 EXISTING_TEST, !FAILURE_TEST);
+	rc = test_update_pdclust(lid, &domain, LIST_ENUM_ID, MORE_THAN_INLINE,
+				 !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
 	/*
@@ -1936,28 +1921,14 @@ static void test_update(void)
 	 * type.
 	 */
 	lid = 22005;
-	rc = test_update_pdclust(lid, &domain,
-				 LINEAR_ENUM_ID, INLINE_NOT_APPLICABLE,
-				 EXISTING_TEST, !FAILURE_TEST);
+	rc = test_update_pdclust(lid, &domain, LINEAR_ENUM_ID,
+				 INLINE_NOT_APPLICABLE, !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
-#if 0 //todo enable
-	/*
-	 * Update a layout object with COMPOSITE layout type, that does not
-	 * exist in the DB. This results into the layout being written newly
-	 * to the DB as is done in case of m0_layout_add().
-	 * See m0_layout_update().
-	 */
-	lid = 22021;
-	rc = test_update_composite(lid, &domain, 4, 15, !CONTIGUOUS_EXTENTS,
-				   !EXISTING_TEST, !FAILURE_TEST);
-	M0_UT_ASSERT(rc == 0);
-#endif
-
 	/* Update a layout object with COMPOSITE layout type. */
 	lid = 22022;
 	rc = test_update_composite(lid, &domain, 4, 15, !CONTIGUOUS_EXTENTS,
-				   EXISTING_TEST, !FAILURE_TEST);
+				   !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
 	//todo Cover other combinations for composite
@@ -1973,18 +1944,16 @@ static void test_update_failure(void)
 	/* Simulate m0_layout_encode() failure in m0_layout_update(). */
 	lid = 23001;
 	m0_fi_enable_off_n_on_m("m0_layout_encode", "lo_encode_err", 1, 1);
-	rc = test_update_pdclust(lid, &domain,
-				 LIST_ENUM_ID, MORE_THAN_INLINE,
-				 EXISTING_TEST, FAILURE_TEST);
+	rc = test_update_pdclust(lid, &domain, LIST_ENUM_ID, MORE_THAN_INLINE,
+				 FAILURE_TEST);
 	M0_UT_ASSERT(rc == LO_ENCODE_ERR);
 	m0_fi_disable("m0_layout_encode", "lo_encode_err");
 
 	/* Simulate m0_table_update() failure in m0_layout_update(). */
 	lid = 23002;
 	m0_fi_enable_once("m0_layout_update", "table_update_err");
-	rc = test_update_pdclust(lid, &domain,
-				 LINEAR_ENUM_ID, INLINE_NOT_APPLICABLE,
-				 EXISTING_TEST, FAILURE_TEST);
+	rc = test_update_pdclust(lid, &domain, LINEAR_ENUM_ID,
+				 INLINE_NOT_APPLICABLE, FAILURE_TEST);
 	M0_UT_ASSERT(rc == L_TABLE_UPDATE_ERR);
 
 	/*
@@ -1993,10 +1962,9 @@ static void test_update_failure(void)
 	 */
 	lid = 23005;
 	m0_fi_enable_off_n_on_m("emap_iterator_set", "emap_lookup_err",
-				5 /* layers_nr (extmap_indb_add()) +,
-				   * 1 (extents_indb_delete()) */, 1);
+				10, 1);
 	rc = test_update_composite(lid, &domain, 4, 7, !CONTIGUOUS_EXTENTS,
-				   EXISTING_TEST, FAILURE_TEST);
+				   FAILURE_TEST);
 	M0_UT_ASSERT(rc == L_EMAP_LOOKUP_ERR);
 	m0_fi_disable("emap_iterator_set", "emap_lookup_err");
 
@@ -2005,7 +1973,7 @@ static void test_update_failure(void)
 	m0_fi_enable_off_n_on_m("ext_indb_write_internal", "emap_paste_err",
 				16 /* layer_nr * extents_nr + 1 */, 1);
 	rc = test_update_composite(lid, &domain, 3, 5, !CONTIGUOUS_EXTENTS,
-				   EXISTING_TEST, FAILURE_TEST);
+				   FAILURE_TEST);
 	M0_UT_ASSERT(rc == L_EMAP_PASTE_ERR);
 	m0_fi_disable("ext_indb_write_internal", "emap_paste_err");
 
diff --git a/layout/ut/pdclust.c b/layout/ut/pdclust.c
index 332dafc..1484c20 100644
--- a/layout/ut/pdclust.c
+++ b/layout/ut/pdclust.c
@@ -1586,130 +1586,91 @@ int test_add_pdclust(uint64_t lid, struct m0_layout_domain *domain,
 /* Tests the API m0_layout_update(), for the PDCLUST layout type. */
 int test_update_pdclust(uint64_t lid, struct m0_layout_domain *domain,
 			uint32_t enum_id, uint32_t inline_test,
-			bool existing_test,
 			bool failure_test)
 {
 	m0_bcount_t                   num_bytes;
 	void                         *area;
 	struct m0_db_pair             pair;
 	struct m0_db_tx               tx;
-	struct m0_layout             *l1;
-	struct m0_layout             *l1_copy;
-	struct m0_layout             *l2;
+	struct m0_layout             *l;
+	struct m0_layout             *l_original_copy;
+	struct m0_layout             *l_changed_copy;
+	struct m0_layout             *l_from_db;
 	uint32_t                      i;
-	struct m0_uint128             seed;
-	uint32_t                      N;
-	uint32_t                      K;
-	uint32_t                      P;
-	struct m0_pdclust_layout     *pl;
-	struct m0_layout_list_enum   *list_enum;
-	struct m0_layout_linear_enum *lin_enum;
 	int                           rc_tmp;
 	int                           rc;
 
 	M0_UT_ASSERT(enum_id == LIST_ENUM_ID || enum_id == LINEAR_ENUM_ID);
 
-	allocate_area(domain, ADDITIONAL_BYTES_NONE, &num_bytes, &area);
-
-	NKP_assign(enum_id,
-		   inline_test, 13, 123, 1230,
-		   &N, &K, &P);
-
-	if (existing_test) {
-		/* Add a layout object to the DB. */
-		rc = test_add_pdclust(lid, domain,
-				      enum_id, inline_test,
-				      !LAYOUT_DESTROY, &l1,
-				      !DUPLICATE_TEST,
-				      !FAILURE_TEST);
-		M0_UT_ASSERT(rc == 0);
-	} else {
-		/* Build a layout object. */
-		m0_uint128_init(&seed, "updatepdclustlay");
-
-		rc = pdclust_layout_build(lid, domain, enum_id,
-					  N, K, P, &seed,
-					  10, 20,
-					  &pl, &list_enum, &lin_enum,
-					  !FAILURE_TEST);
-		M0_UT_ASSERT(rc == 0);
-		l1 = &pl->pl_base.sl_base;
-	}
+	/* Add a layout object to the DB. */
+	rc = test_add_pdclust(lid, domain, enum_id, inline_test,
+			      !LAYOUT_DESTROY, &l,
+			      !DUPLICATE_TEST, !FAILURE_TEST);
+	M0_UT_ASSERT(rc == 0);
+	if (failure_test)
+		pdclust_layout_copy(enum_id, l, &l_original_copy);
 
 	/* Verify the original user count is as expected. */
-	M0_UT_ASSERT(l1->l_user_count == 0);
+	M0_UT_ASSERT(l->l_user_count == 0);
 
 	/* Update the in-memory layout object - update its user count. */
 	for (i = 0; i < 100; ++i)
-		m0_layout_user_count_inc(l1);
-	M0_UT_ASSERT(l1->l_user_count == 100);
+		m0_layout_user_count_inc(l);
+	M0_UT_ASSERT(l->l_user_count == 100);
 
 	/* Update the layout object in the DB. */
 	rc = m0_db_tx_init(&tx, domain->ld_dbenv, DBFLAGS);
 	M0_UT_ASSERT(rc == 0);
-
+	allocate_area(domain, ADDITIONAL_BYTES_NONE, &num_bytes, &area);
 	pair_set(&pair, &lid, area, num_bytes);
 
-	rc = m0_layout_update(l1, &tx, &pair);
-	if (failure_test)
-		M0_UT_ASSERT(rc == LO_ENCODE_ERR || rc == L_TABLE_UPDATE_ERR);
-	else
-		M0_UT_ASSERT(rc == 0);
+	rc = m0_layout_update(l, &tx, &pair);
 	rc_tmp = m0_db_tx_commit(&tx);
 	M0_UT_ASSERT(rc_tmp == 0);
 
-	/*
-	 * Even a non-existing record can be written to the database using
-	 * the database update operation.
-	 * todo Mar 04 Do I need some change here - testing the update op for
-	 * a nonexisting layout?
-	 */
-	if (existing_test && !failure_test)
-		pdclust_layout_copy(enum_id, l1, &l1_copy);
+	if (failure_test)
+		M0_UT_ASSERT(rc == LO_ENCODE_ERR || rc == L_TABLE_UPDATE_ERR);
+	else {
+		M0_UT_ASSERT(rc == 0);
+		pdclust_layout_copy(enum_id, l, &l_changed_copy);
+	}
 
 	/*
-	 * Update the in-memory layout object - update its user count. This is
-	 * to verify the functioning of m0_layout_user_count_dec().
+	 * Update the in-memory layout object - update its user count.
+	 * This is to verify the functioning of
+	 * m0_layout_user_count_dec().
 	 */
 	for (i = 0; i < 50; ++i)
-		m0_layout_user_count_dec(l1);
-	M0_UT_ASSERT(l1->l_user_count == 50);
+		m0_layout_user_count_dec(l);
+	M0_UT_ASSERT(l->l_user_count == 50);
 
 	/* Delete the in-memory layout. */
-	m0_layout_put(l1);
+	m0_layout_put(l);
 	M0_UT_ASSERT(list_lookup(domain, lid) == NULL);
 
-	/*
-	 * Regarding the first condition in the if below,
-	 * Since auxiliary tables are not updated with an update operation,
-	 * m0_layout_update() on a a non-existing layout does not result
-	 * into the layout being written to the DB.
-	 * todo Shall return -EINVAL in case m0_layout_update() is invoked on a
-	 * a layout with pdclust type that does not exist in the DB.
-	 */
-	if (existing_test && !failure_test) {
-		/*
-		 * Lookup for the layout object from the DB to verify that its
-		 * user count is indeed updated.
-		 */
-		rc = layout_lookup(lid, domain, &m0_pdclust_layout_type,
-				   !FAILURE_TEST, &l2);
-		M0_UT_ASSERT(rc == 0);
-		M0_UT_ASSERT(l2->l_user_count == 100);
-		M0_UT_ASSERT(m0_ref_read(&l2->l_ref) == 1);
+	/* Lookup for the layout object from the DB. */
+	rc_tmp = layout_lookup(lid, domain, &m0_pdclust_layout_type,
+			       !FAILURE_TEST, &l_from_db);
+	M0_UT_ASSERT(rc_tmp == 0);
 
-		/*
-		 * Compare the two layouts - one created earlier here and the
-		 * one that is looked up from the DB.
-		 */
-		pdclust_layout_compare(enum_id, l1_copy, l2, false);
-		pdclust_layout_copy_delete(enum_id, l1_copy);
+	if (failure_test) {
+		/* Verify that the layout remained unchanged in the DB. */
+		pdclust_layout_compare(enum_id, l_original_copy, l_from_db,
+				       false);
+		pdclust_layout_copy_delete(enum_id, l_original_copy);
+	} else {
+		/* Verify that the user count is indeed updated. */
+		M0_UT_ASSERT(l_from_db->l_user_count == 100);
+		M0_UT_ASSERT(m0_ref_read(&l_from_db->l_ref) == 1);
 
-		/* Delete the in-memory layout. */
-		m0_layout_put(l2);
-		M0_UT_ASSERT(list_lookup(domain, lid) == NULL);
+		pdclust_layout_compare(enum_id, l_changed_copy, l_from_db,
+				       false);
+		pdclust_layout_copy_delete(enum_id, l_changed_copy);
 	}
 
+	/* Delete the in-memory layout. */
+	m0_layout_put(l_from_db);
+	M0_UT_ASSERT(list_lookup(domain, lid) == NULL);
 	m0_free(area);
 	return rc;
 }
diff --git a/layout/ut/pdclust.h b/layout/ut/pdclust.h
index a6aab7c..2be6188 100644
--- a/layout/ut/pdclust.h
+++ b/layout/ut/pdclust.h
@@ -81,7 +81,6 @@ int test_add_pdclust(uint64_t lid, struct m0_layout_domain *domain,
 		     bool failure_test);
 int test_update_pdclust(uint64_t lid, struct m0_layout_domain *domain,
 			uint32_t enum_id, uint32_t inline_test,
-			bool existing_test,
 			bool failure_test);
 int test_delete_pdclust(uint64_t lid, struct m0_layout_domain *domain,
 			uint32_t enum_id, uint32_t inline_test,
-- 
1.8.3.2

