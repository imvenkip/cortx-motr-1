From 5da2bc655956ede1be15840198cec122990a9477 Mon Sep 17 00:00:00 2001
From: "trupti.patil" <trupti_patil@xyratex.com>
Date: Thu, 13 Dec 2012 18:10:02 +0530
Subject: [PATCH 029/172] Support for various cases of addition of an extent to
 a layer.

---
 layout/composite.c    | 572 ++++++++++++++++++++++++++------------------------
 layout/composite.h    | 161 +++++++++++---
 layout/ut/composite.c | 115 ++++------
 layout/ut/layout.c    |  21 +-
 4 files changed, 483 insertions(+), 386 deletions(-)

diff --git a/layout/composite.c b/layout/composite.c
index b412f7c..659ca61 100644
--- a/layout/composite.c
+++ b/layout/composite.c
@@ -145,43 +145,6 @@ struct layout_prefix {
 	uint32_t lp_filler;
 };
 
-/**
- * State of an extent.
- *
- * Value of this enum is stored (in memory and in the DB) along with each
- * extent of each layer from every composite layoout.
- *
- * Two extents can be merged if and only if their states are the same and they
- * are back to back.
- */
-enum layer_extent_state {
-	/**
-	 * This value is used to tag an extent that does not belong to the
-	 * layer's address-space. For example, an extent (0, C2_BINDEX_MAX + 1)
-	 * would be LRET_INVALID for 'the zeroth layer that does not contain
-	 * any extents'. This relates to the implemtation of the extent map
-	 * that by default has the name-space from 0 to C2_BINDEX_MAX.
-	 *
-	 * Extents with this state are not stored in the in-memory list of the
-	 * extents.
-	 */
-	LRET_INVALID,
-
-	/**
-	 * Normal extent associated with a particular layer. All extents with
-	 * this value belong to the layer they are associated with.
-	 */
-	LRET_VALID,
-
-	/**
-	 * This value is used to tag an extent that is involved into the
-	 * ongoing layout flattening process (future).
-	 * @note This value, though not in use currently, is placed here to
-	 * illustrate the usage of this enum.
-	 */
-	LRET_VALID_FLATTENING
-};
-
 C2_TL_DESCR_DEFINE(c2_layer, "composite-layer-list", /* global */,
 		   struct c2_composite_layer, clr_list_linkage, clr_magic,
 		   C2_LAYOUT_COMP_SUBL_MAGIC, C2_LAYOUT_COMP_SUBL_HEAD_MAGIC);
@@ -229,6 +192,9 @@ static bool composite_invariant(const struct c2_composite_layout *cl)
 							layer->clr_extents)));
 }
 
+//todo Add a layer invariant that should check that extents are listed in the
+//ascending order of the offsets involved
+
 #if 0
 static bool composite_invariant(const struct c2_composite_layout *cl)
 {
@@ -410,7 +376,7 @@ static void composite_fini(struct c2_ref *ref)
 	struct c2_layout                 *l;
 	struct c2_composite_layout       *cl;
 	struct c2_composite_layer        *layer;
-	struct c2_composite_layer_extent *extent;
+	struct c2_composite_layer_extent *extent; //todo replace by lr_ext
 
 	l = container_of(ref, struct c2_layout, l_ref);
 	C2_PRE(c2_mutex_is_not_locked(&l->l_lock));
@@ -432,6 +398,9 @@ static void composite_fini(struct c2_ref *ref)
 		/*
 		 * Decrement the user count incremented by
 		 * layer_in_memory_write().
+		 * todo No, this shall not happne here byt when a layer gets
+		 * dissociated from within DB.
+		 * todo Need to add layer delete API.
 		 */
 		c2_layout_user_count_dec(layer->clr_l);
 		/*
@@ -553,86 +522,6 @@ static void prefix_set(struct layout_prefix *prefix,
 
 //todo look for the strings sub-layout, sub_layout, sublayouts and similar instances and remove those. Also from the ut/composite.c.
 
-#if 0
-static int layer_extent_free(struct c2_composite_layer *layer,
-			     struct c2_ext *ext)
-{
-	return 0;
-}
-
-static int seg_free(struct c2_composite_layer *layer,
-		    const struct c2_emap_seg *seg,
-		    const struct c2_ext *ext,
-		    uint64_t val)
-{
-	c2_bcount_t delta = ext->e_start - seg->ee_ext.e_start;
-	struct c2_ext tocut = {
-		.e_start = val + delta,
-		.e_end = val + delta + c2_ext_length(ext)
-	};
-	//return val < LRET_MIN ? ad_free(cl, &tocut) : 0;
-	return val == 0 ? layer_extent_free(layer, &tocut) : 0;
-}
-#endif
-
-#if 0
-/**
- * Handles extent deletion.
- */
-static void extent_delete(struct c2_emap_seg *seg)
-{
-	C2_ASSERT(0);
-}
-
-/**
- * Cuts left - Cuts 'an extent that is left to the extent supplied', in the
- * list of extents stored in the layer that is from the inmemory version of
- * the composite layout).
- */
-static void cut_left(struct c2_emap_seg *seg,
-		     struct c2_ext *ext,
-		     uint64_t val)
-{
-	struct c2_composite_layer_extent *extent;
-
-#if 0
-	if (c2_emap_ext_is_first(&seg->ee_ext) && val == LRET_INVALID) {
-		/*
-		 * Nothing to be done since it is the left most but invalid
-		 * segment that exists in the DB only for the sake of
-		 * implemtation of the DB version of the layer's extent map.
-		 */
-		return;
-	}
-#endif
-
-	/* Delete the previous extent by making use of _tlist_prev() */
-	//C2_ASSERT(0);
-	extent = c2_layer_extent_tlist_prev(layer->clr_extents);
-	C2_ASSERT(extent != NULL);
-}
-
-/**
- * Cuts right.
- */
-static void cut_right(struct c2_emap_seg *seg,
-		      struct c2_ext *ext,
-		      uint64_t val)
-{
-	if (c2_emap_ext_is_last(&seg->ee_ext) && val == LRET_INVALID) {
-		/*
-		 * Nothing to be done since it is the right most but invalid
-		 * segment that exists in the DB only for the sake of
-		 * implemtation of the DB version of the layer's extent map.
-		 */
-		return;
-	}
-
-	/* Delete the next extent by making use of _tlist_next() */
-	C2_ASSERT(0);
-}
-#endif
-
 /* todo */
 enum extent_op {
 	DELETE,
@@ -644,64 +533,150 @@ enum extent_op {
 
 static int extent_in_memory_add(struct c2_composite_layer *layer,
 				const struct c2_ext *ext,
-				uint64_t val)
+				enum c2_composite_layer_ext_state estate)
+{
+	struct c2_composite_layer_extent *ext_to_insert_before;
+	struct c2_composite_layer_extent *ext_to_insert_after;
+	struct c2_composite_layer_extent *extent;
+	struct c2_composite_layer_extent *extent_to_insert;
+
+	C2_PRE(estate != C2_CLRES_INVALID);
+
+	ext_to_insert_before = NULL;
+	ext_to_insert_after = NULL;
+
+	c2_tl_for(c2_layer_extent, layer->clr_extents, extent) {
+		if (ext->e_start < extent->cle_ext.e_start)
+			ext_to_insert_before = extent;
+		if (ext->e_start >= extent->cle_ext.e_end)
+			ext_to_insert_after = extent;
+		if (ext->e_start <= extent->cle_ext.e_start)
+			break; //todo Check the break condition
+	} c2_tl_endfor;
+
+	C2_ASSERT(ext_to_insert_before != NULL || ext_to_insert_after != NULL);
+
+	C2_ALLOC_PTR(extent_to_insert);
+	C2_ASSERT(extent_to_insert != NULL); //todo Handle error
+	extent_to_insert->cle_ext = *ext;
+	extent_to_insert->cle_state = estate;
+	c2_layer_extent_tlink_init(extent_to_insert);
+
+	if (ext_to_insert_after != NULL)
+		c2_layer_extent_tlist_add_after(ext_to_insert_after,
+						extent_to_insert);
+	else if (ext_to_insert_before != NULL)
+		c2_layer_extent_tlist_add_before(ext_to_insert_before,
+						 extent_to_insert);
+	++layer->clr_extents_nr;
+	return 0; //todo void ??
+}
+
+static int extent_in_memory_delete(struct c2_composite_layer *layer,
+				   const struct c2_ext *ext,
+				   enum c2_composite_layer_ext_state estate)
 {
 	struct c2_composite_layer_extent *ext1;
-	struct c2_composite_layer_extent *ext2;
 	bool                              ext1_found;
-	bool                              ext2_found;
 	struct c2_composite_layer_extent *extent;
-	struct c2_composite_layer_extent *extent_to_insert;
 
-	C2_PRE(val != LRET_INVALID);
+	C2_PRE(estate != C2_CLRES_INVALID);
 
+	/* todo refactor the code with extent_in_memory_add() */
 	ext1_found = false;
-	ext2_found = false;
-
 	c2_tl_for(c2_layer_extent, layer->clr_extents, extent) {
 		if (ext->e_start > extent->cle_ext.e_end)
 			continue;
-		if (ext->e_start >= extent->cle_ext.e_end) {
+		if (ext->e_start == extent->cle_ext.e_start) {
 			ext1 = extent;
 			ext1_found = true;
-		} else if (ext->e_start < extent->cle_ext.e_end) {
-			C2_ASSERT(ext1_found == true);
-			C2_ASSERT(extent->cle_ext.e_start >= ext->e_end);
-			ext2 = extent;
-			ext2_found = true;
+			break;
 		}
-
 		/*
 		 * todo Consider the exceptions like insufficient number of
 		 * extents in the list, etc.
 		 */
-		if (ext1_found && ext2_found)
+	} c2_tl_endfor;
+
+	if (ext1_found && ext->e_end == extent->cle_ext.e_end) {
+		C2_ASSERT(extent->cle_state == estate);
+		c2_layer_extent_tlist_del(ext1);
+		c2_layer_extent_tlink_fini(ext1);
+		c2_free(ext1);
+		--layer->clr_extents_nr;
+		return 0;
+	} else
+		return -ENOENT;
+}
+
+//todo Check probably new_state is not req'd as an arg
+static int extent_in_memory_find(struct c2_composite_layer *layer,
+				 const struct c2_ext *ext,
+				 enum c2_composite_layer_ext_state new_state,
+				 struct c2_composite_layer_extent **lr_ext)
+{
+	struct c2_composite_layer_extent *extent;
+	bool                              extent_found = false;
+
+	c2_tl_for(c2_layer_extent, layer->clr_extents, extent) {
+		if (extent->cle_ext.e_end <= ext->e_start)
+			continue;
+		else if (extent->cle_ext.e_start == ext->e_start &&
+			 extent->cle_ext.e_end == ext->e_end) {
+			C2_ASSERT(extent->cle_state == new_state);
+			extent_found = true;
 			break;
+		}
 	} c2_tl_endfor;
 
-	C2_ASSERT (ext1_found && ext2_found);
-	if (ext1_found && ext2_found) {
-		C2_ALLOC_PTR(extent_to_insert);
-		C2_ASSERT(extent_to_insert != NULL); //todo Handle error
+	if (extent_found) {
+		if (lr_ext != NULL)
+			*lr_ext = extent;
+		return 0;
+	} else
+		return -ENOENT;
+}
 
-		extent_to_insert->cle_ext = *ext;
-		c2_layer_extent_tlink_init(extent_to_insert);
-		c2_layer_extent_tlist_add_after(ext1, extent_to_insert);
-		++layer->clr_extents_nr;
+static void extent_in_memory_trim(struct c2_composite_layer *layer,
+				  enum extent_op extent_op,
+				  const struct c2_emap_seg *seg,
+				  const struct c2_ext *ext)
+{
+	struct c2_composite_layer_extent *lr_ext;
+	int                               rc;
+
+	C2_PRE(C2_IN(extent_op, (CUT_LEFT, CUT_RIGHT)));
+
+	rc = extent_in_memory_find(layer, &seg->ee_ext, seg->ee_val, &lr_ext);
+	C2_ASSERT(rc == 0);
+
+	if (extent_op == CUT_LEFT) {
+		/* Retain left part of the existing segment. */
+		C2_ASSERT(lr_ext->cle_ext.e_end > ext->e_start); // todo <= ?
+		C2_ASSERT(lr_ext->cle_ext.e_start < ext->e_start); // todo <= ?
+		lr_ext->cle_ext.e_end = ext->e_start;
+	} else { /* extent_op == CUT_RIGHT */
+		/* Retain right part of the existing segment. */
+		C2_ASSERT(lr_ext->cle_ext.e_start < ext->e_end); // todo <= ?
+		//C2_ASSERT(lr_ext->cle_ext.e_end < ext->e_end); // todo <= ?
+		//C2_ASSERT(lr_ext->cle_ext.e_start == ext->start); // todo <= ?
+		lr_ext->cle_ext.e_start = ext->e_end;
 	}
-	return 0; //todo void ??
 }
 
-/* todo rename to _in_memory_.. */
+/* todo rename to _in_memory_..   %s/extent/ext everywhere else? */
 static int ext_inmemory_adjust(struct c2_composite_layer *layer,
-			       enum extent_op extop,
+			       enum extent_op extent_op,
 			       const struct c2_emap_seg *seg,
 			       const struct c2_ext *ext,
-			       uint64_t newval)
+			       enum c2_composite_layer_ext_state new_estate)
 {
 	int rc;
 
-	C2_PRE(C2_IN(extop, (DELETE, CUT_LEFT, CUT_RIGHT)));
+	/* todo new_estate will need to be used for supporting update to extent
+	 * state. Until then, new_estate shall always be same as oldval.
+	 */
+	C2_PRE(C2_IN(extent_op, (DELETE, CUT_LEFT, CUT_RIGHT)));
 
 	C2_LOG(C2_DEBUG, "layer[%lu]: seg e_start %llu, seg e_end %llu, "
 	       "seg val %llu, e_start %llu, e_end %llu",
@@ -709,39 +684,34 @@ static int ext_inmemory_adjust(struct c2_composite_layer *layer,
 	       (unsigned long long)seg->ee_ext.e_start,
 	       (unsigned long long)seg->ee_ext.e_end,
 	       (unsigned long long)seg->ee_val,
-	       (unsigned long long)ext->e_start,
-	       (unsigned long long)ext->e_end);
+	       (ext != NULL) ? (unsigned long long)ext->e_start : 0,
+	       (ext != NULL) ? (unsigned long long)ext->e_end : 0);
 
-	//todo Shall use switch ?
-	if (extop == DELETE) {
+	/*
+	 * Extents with the state C2_CLRES_INVALID are not stored in the
+	 * in-memory list of the extents. Hence, return right away.
+	 */
+	if (seg->ee_val == C2_CLRES_INVALID)
+		return 0;
+
+	if (extent_op == DELETE) {
 		/*
 		 * The extent seg->ee_ext is replaced by some newer extent.
 		 * Hence, seg->ee_ext is asked to be deleted.
 		 */
-		if (seg->ee_val == LRET_INVALID) {
-			/*
-			 * The extent did not exist in the inmemory
-			 * list of the extents. Hence, it in fact, needs to be
-			 * added to that list, with the newer value.
-			 */
-			/* todo extent_in_memory_write(). */
-			rc = extent_in_memory_add(layer, &seg->ee_ext, newval);
-			C2_ASSERT(rc == 0); //todo handle
-			return 0;
-		} else {
-			/*
-			 * todo Find the extent from the in-memory list and
-			 * delete it.
-			 */
-		}
-	} else if (extop == CUT_LEFT) {
-
-	} else if (extop == CUT_RIGHT) {
-
+		rc = extent_in_memory_delete(layer, &seg->ee_ext, seg->ee_val);
+		C2_ASSERT(rc == 0); //todo handle
+	} else if (extent_op == CUT_LEFT) {
+		C2_PRE(new_estate == seg->ee_val);
+		extent_in_memory_trim(layer, extent_op, seg, ext);
+	} else if (extent_op == CUT_RIGHT) {
+		C2_PRE(new_estate == seg->ee_val);
+		extent_in_memory_trim(layer, extent_op, seg, ext);
 	}
 
 	return 0;
 }
+
 #endif /* __KERNEL__ */
 
 /*
@@ -750,21 +720,24 @@ static int ext_inmemory_adjust(struct c2_composite_layer *layer,
  */
 static int extent_in_db_add(struct c2_emap_cursor *it,
 			    struct c2_composite_layer *layer,
-			    struct c2_ext *ext,
-			    enum layer_extent_state ext_state,
+			    const struct c2_ext *ext_to_add,
+			    uint64_t estate,
 			    enum c2_layout_xcode_op op)
 {
-	int rc;
+#ifndef __KERNEL__
+	struct c2_ext ext;
+	int           rc_cb;
+	int           rc;
+
 	//Check about the locking
 
 	C2_PRE(C2_IN(op, (C2_LXO_DB_ADD, C2_LXO_DB_UPDATE)));
 
 	C2_LOG(C2_DEBUG, "layer idx %lu, e_start %llu, e_end %llu",
 	       (unsigned long)layer->clr_idx,
-	       (unsigned long long)ext->e_start,
-	       (unsigned long long)ext->e_end);
+	       (unsigned long long)ext_to_add->e_start,
+	       (unsigned long long)ext_to_add->e_end);
 
-#ifndef __KERNEL__
 	/* LAMBDA is not available for the kernel mode. */
 
 	/*
@@ -781,96 +754,116 @@ static int extent_in_db_add(struct c2_emap_cursor *it,
 	 * Each call-back takes a segment argument, seg. seg->ee_ext is an
 	 * extent associated with the specified layer (todo) and seg->ee_val
 	 * is the original state of the extent from the on-disk extent map.
+	 *
+	 * Here is an example to illustrate the sequence of operation performed
+	 * by c2_emap_paste() and how the in-memory list of extents is
+	 * adjustted accordingly.
+	 *
+	 * For example, a layer contains an extent list as:
+	 * ext[0]: [ 2200700,    56668025)
+	 * ext[1]: [ 56668025,  111135350)
+	 * ext[2]: [111135350,  165602675)
+	 * ext[3]: [165602675,  220070000)
+	 *
+	 * An extent [56668023, 165602677) is asked to be added into the list.
+	 *
+	 * In such a case, multiple small operations are performed internally
+	 * by c2_emap_paste() and the callbacks are sent appropriately. In
+	 * response to those callback, the in-memory list of extents is
+	 * adjusted accordingly by using the ext_inmemory_adjust() function.
+	 *
+	 * The sequence goes as follows:
+	 * 1) From the extent [2200700, 56668025), its left part that is
+	 *    [[2200700, 56668023) is retained, using the extent_op CUT_LEFT.
+	 * 2) From the extent list, the extent [56668025, 111135350) is
+	 *    deleted using the extent_op DELETE.
+	 * 3) From the extent list, the extent [111135350, 165602675) is
+	 *    deleted using the extent_op DELETE.
+	 * 4) From the extent [165602675, 220070000), its right part that is
+	 *    [165602677, 220070000) is retained, using the extent_op CUT_RIGHT.
+	 * 5) Finally, through this function itself, the complete extent
+	 *    [56668023, 165602677) is added into the in-memory list of the
+	 *    extents.
+	 *
+	 * When initial list of extents is added to some layer, the list is
+	 * expected to be non-overlapping. And in that case, the list is first
+	 * stored into the in-memory list of the extents and then it is asked
+	 * to be adjusted in the DB version of it, using c2_emap_paste here.
+	 * Thus, in that case, since the list is already up-to-date in the
+	 * in-memory version, there is nothing to be done through the calbacks
+	 * received from c2_emap_paste(). This is handled using the condition
+	 * around op.
 	 */
-	rc = c2_emap_paste(it, ext, ext_state,
-			   LAMBDA(void, (struct c2_emap_seg *seg) {
-				/* Handle extent deletion. */
-				if (op == C2_LXO_DB_UPDATE) {
-					//C2_ASSERT(seg->ee_val == LRET_VALID);
-
-					rc = ext_inmemory_adjust(layer,
-								 DELETE,
-								 seg,
-								 ext,
-								 ext_state);
-					//rc = rc ?: ext_inmemory_adjust(layer,
-					//		       seg,
-					//		       &seg->ee_ext,
-					//		       seg->ee_val);
-				}
-			   }),
-			   LAMBDA(void, (struct c2_emap_seg *seg,
-					 struct c2_ext *ext,
-					 uint64_t val) {
-				/* Cut left. */
-				if (op == C2_LXO_DB_UPDATE) {
-					//C2_ASSERT(seg->ee_val == LRET_VALID);
-					C2_ASSERT(ext->e_start >
-						  seg->ee_ext.e_start);
-					seg->ee_val = val;
-
-					rc = ext_inmemory_adjust(layer,
-								 CUT_LEFT,
-								 seg,
-								 ext,
-								 ext_state);
-					//rc = rc ?: ext_inmemory_adjust(layer,
-					//		       seg,
-					//		       &seg->ee_ext,
-					//		       seg->ee_val);
-				}
-			   }),
-			   LAMBDA(void, (struct c2_emap_seg *seg,
-					 struct c2_ext *ext,
-					 uint64_t val) {
-				/* Cur right. */
-				if (op == C2_LXO_DB_UPDATE) {
-					//C2_ASSERT(seg->ee_val == LRET_VALID);
-					C2_ASSERT(seg->ee_ext.e_end >
-						  ext->e_end);
-
-					rc = ext_inmemory_adjust(layer,
-								 CUT_RIGHT,
-								 seg,
-								 ext,
-								 ext_state);
-					//rc = rc ?: ext_inmemory_adjust(layer,
-					//		       seg,
-					//		       &seg->ee_ext,
-					//		       seg->ee_val);
-/*
-//from ad.c, tune it.
-				if (val == LRET_VALID) {
-
-						       seg->ee_ext.e_start);
-					seg->ee_val = val +
-						      (ext->e_end -
-
-					*
-					 * Free physical sub-extent, but only
-					 * when sub-extent starts at the left
-					 * boundary of the logical extent,
-					 * because otherwise "cut left" already
-					 * freed it.
-					 *
-					if (ext->e_start ==
-					    seg->ee_ext.e_start)
-						rc = rc ?: seg_free(io, adom,
-								    seg, ext,
-								    val);
-				} else
-					seg->ee_val = val;
-*/
 
-				}
-			   }));
+	ext = *ext_to_add;
+	rc_cb = 0;
+	rc = c2_emap_paste(it, &ext, estate,
+		LAMBDA(void, (struct c2_emap_seg *seg) {
+			/* Extent deletion. */
+			if (op == C2_LXO_DB_UPDATE) {
+				rc_cb = rc_cb ?: ext_inmemory_adjust(layer,
+								     DELETE,
+								     seg,
+								     NULL,
+								     estate);
+			}
+		}),
+		LAMBDA(void, (struct c2_emap_seg *seg,
+			      struct c2_ext *extent,
+			      uint64_t val) {
+			/* Cut left. */
+			if (op == C2_LXO_DB_UPDATE) {
+				//todo rm following
+				C2_ASSERT(extent->e_start == ext.e_start);
+				//C2_ASSERT(extent->e_end == ext.e_end);//fails
+				rc_cb = rc_cb ?: ext_inmemory_adjust(layer,
+								     CUT_LEFT,
+								     seg,
+								     extent,
+								     estate);
+			}
+		}),
+		LAMBDA(void, (struct c2_emap_seg *seg,
+			      struct c2_ext *extent,
+			      uint64_t val) {
+			/* Cut right. */
+			if (op == C2_LXO_DB_UPDATE) {
+				//todo rm following
+				C2_ASSERT(extent->e_start == ext.e_start);
+				//todo rm following
+				C2_ASSERT(extent->e_end == ext.e_end);
+				rc_cb = rc_cb ?: ext_inmemory_adjust(layer,
+								     CUT_RIGHT,
+								     seg,
+								     extent,
+								     estate);
+			}
+		}));
+
+	rc = rc ?: rc_cb;
 
+	if (rc == 0 && op == C2_LXO_DB_UPDATE && estate != C2_CLRES_INVALID) {
+		/*
+		 * Now that the deletion of the extents applicable from the
+		 * in-memory list of the extents has been handled through the
+		 * usage of ext_inmemory_adjust() as above, let's add the
+		 * extent to the in-memory list of the extents, if applicable.
+		 *
+		 * Extents with the state C2_CLRES_INVALID are not stored in
+		 * the in-memory list of the extents. Hence, the latter
+		 * condition above.
+		 */
+		rc = extent_in_memory_find(layer, ext_to_add, estate, NULL);
+		if (rc == -ENOENT) {
+			rc = extent_in_memory_add(layer, ext_to_add, estate);
+			C2_ASSERT(rc == 0); //todo handle
+		}
+	}
+	return rc;
 #else
 	C2_ASSERT(0);
-	rc = -EPROTO;
+	return -EPROTO;
 #endif /* __KERNEL__ */
-
-	return rc;
 }
 
 static int sublayout_id_in_db_read(struct composite_schema_data *csd,
@@ -956,7 +949,6 @@ static int extentmap_in_db_write(struct c2_composite_layout *cl,
 	struct c2_emap_cursor             it;
 	struct c2_composite_layer_extent *extent;
 	struct c2_emap_seg               *seg;
-	struct c2_ext                     ext;
 	struct layout_prefix              prefix;
 	int                               rc;
 
@@ -964,7 +956,7 @@ static int extentmap_in_db_write(struct c2_composite_layout *cl,
 	emap = &csd->csd_layer_ext_map;
 	prefix_set(&prefix, cl->cl_base.l_id, layer->clr_idx);
 	rc = c2_emap_obj_insert(emap, tx, (struct c2_uint128 *)&prefix,
-				LRET_INVALID);
+				C2_CLRES_INVALID);
 	C2_ASSERT(rc == 0); // todo || rc == -EEXIST); //todo handle err
 	if (rc == -EEXIST)
 		return rc; //todo ADDB rec etc.
@@ -977,21 +969,21 @@ static int extentmap_in_db_write(struct c2_composite_layout *cl,
 	seg = c2_emap_seg_get(&it);
 	C2_ASSERT(seg->ee_ext.e_start == 0);
 	C2_ASSERT(seg->ee_ext.e_end == C2_BINDEX_MAX + 1);
-	C2_ASSERT(seg->ee_val == LRET_INVALID);
+	C2_ASSERT(seg->ee_val == C2_CLRES_INVALID);
 
 	C2_LOG(C2_DEBUG, "layer[%lu]: sublayout_lid %llu",
 	       (unsigned long)layer->clr_idx,
 	       (unsigned long long)layer->clr_l->l_id);
 
 	c2_tl_for(c2_layer_extent, layer->clr_extents, extent) {
-		ext = extent->cle_ext;
-		rc = extent_in_db_add(&it, layer, &ext, LRET_VALID /*todo */,
-				      C2_LXO_DB_ADD);
+		C2_ASSERT(C2_IN(extent->cle_state, (C2_CLRES_VALID,
+						    C2_CLRES_FLATTENING)));
+		rc = extent_in_db_add(&it, layer, &extent->cle_ext,
+				      extent->cle_state, C2_LXO_DB_ADD);
 		C2_ASSERT(rc == 0); //todo Handle
 	} c2_tl_endfor;
 	c2_emap_close(&it);
 
-
 	return rc;
 }
 
@@ -1121,12 +1113,6 @@ static int composite_layout_in_cursor_read(struct c2_composite_layout *cl,
 			C2_ASSERT(0);
 			return -EINVAL; //todo ADDB rec etc
 		}
-		/**
-		 * @todo Eventually, if the layout is not found in the cache,
-		 * it shall be fetched either from the DB or over the network,
-		 * as applicable. This needs the layout id to be extended to
-		 * 128 bit to store the layout type.
-		 */
 
 		C2_ASSERT(layer_header->clh_idx == i);
 		if (layer_header->clh_idx == 0) { /* Zeroth layer */
@@ -1215,7 +1201,7 @@ static int extentmap_in_db_read(struct c2_emap *emap,
 		       (unsigned long long)seg->ee_ext.e_end,
 		       (unsigned long long)seg->ee_val);
 
-		if (seg->ee_val != LRET_INVALID) {
+		if (seg->ee_val != C2_CLRES_INVALID) {
 			c2_layer_extent_tlink_init_at_tail(extent, *extents);
 			++*extents_nr;
 		}
@@ -1415,7 +1401,7 @@ static int composite_layout_in_db_write(struct c2_composite_layout *cl,
 		/**
 		 * @todo In fact, there are no valid extents associated with
 		 * layer 0. So, do we need to make this extent entry with
-		 * LRET_INVALID state to the layer_ext_map table? Probably
+		 * C2_CLRES_INVALID state to the layer_ext_map table? Probably
 		 * not unless there is a chance that zeroth layer may need to
 		 * store some extents in future. Will it?
 		 */
@@ -1516,11 +1502,17 @@ static struct c2_composite_layer *layer_find(
 	return layer;
 }
 
+/*
+ * todo Verify functioning of this API. Currently in UT, all the layers
+ * contain same list of extents. So traversing layers part is not
+ * verified.
+ */
 int c2_composite_layer_ext_lookup(const struct c2_composite_layout *cl,
 				  c2_bindex_t offset,
 				  struct c2_db_tx *tx,
 				  uint32_t *layer_idx,
-				  struct c2_ext *ext)
+				  struct c2_ext *ext,
+				  struct c2_layout **sublayout)
 {
 	struct c2_emap            *emap;
 	struct c2_emap_cursor      it;
@@ -1528,6 +1520,7 @@ int c2_composite_layer_ext_lookup(const struct c2_composite_layout *cl,
 	struct layout_prefix       prefix;
 	uint32_t                   i; /* layer idx */
 	bool                       found;
+	struct c2_composite_layer *layer;
 	int                        rc;
 
 	emap = emap_from_cl(cl);
@@ -1545,13 +1538,13 @@ int c2_composite_layer_ext_lookup(const struct c2_composite_layout *cl,
 		seg = c2_emap_seg_get(&it);
 		c2_emap_close(&it);
 
-		if (seg->ee_val != LRET_INVALID) {
+		if (seg->ee_val != C2_CLRES_INVALID) {
 			found = true;
 			break;
 		}
 
 		if (i > 1)
-			i--;
+			--i;
 		else
 			break;
 	}
@@ -1559,6 +1552,9 @@ int c2_composite_layer_ext_lookup(const struct c2_composite_layout *cl,
 	if (found == true) {
 		*layer_idx = i;
 		*ext = seg->ee_ext;
+		layer = layer_find(cl, *layer_idx);
+		C2_ASSERT(layer != NULL);
+		*sublayout = layer->clr_l;
 		rc = 0;
 	} else
 		rc = -ENOENT;
@@ -1589,7 +1585,25 @@ int c2_composite_layer_ext_add(struct c2_composite_layout *cl,
 			    ext->e_start, &it);
 	C2_ASSERT(rc == 0); //todo handle err
 
-	rc = extent_in_db_add(&it, layer, ext, LRET_VALID, C2_LXO_DB_UPDATE);
+	/**
+	 * @todo In short: Break ext into multiple, based on values (extent
+	 * states) of 'multiple segments the ext may span over'.
+	 *
+	 * Details: Two extents can be merged if and only if they are
+	 * 'back-to-back' (this part is taken care of by c2_emap_paste()) and
+	 * their state is the same.
+	 *
+	 * To conform to the latter need, it is planned to check the states of
+	 * 'all the existing extents in the emap, the ext spans over'. If they
+	 * are not the same, then accordingly, multiple extent_in_db_add()
+	 * requests are generated.
+	 *
+	 * This will be implemented once this design point is agreed upon
+	 * during CINSP_PREUT.
+	 */
+
+	rc = extent_in_db_add(&it, layer, ext, C2_CLRES_VALID,
+			      C2_LXO_DB_UPDATE);
 	C2_ASSERT(rc == 0); //todo Handle
 
 	c2_emap_close(&it);
diff --git a/layout/composite.h b/layout/composite.h
index d9daf44..e9dd986 100644
--- a/layout/composite.h
+++ b/layout/composite.h
@@ -24,12 +24,29 @@
 #define __COLIBRI_LAYOUT_COMPOSITE_H__
 
 /**
- * @defgroup composite Composite Layout Type.
+ * @defgroup composite Composite Layout.
  *
- * Composite layout. Composite layout is made up of multiple sub-layouts. Each
- * sub-layout needs to be read to obtain the overall layout details providing
- * all the COB identifiers.
+ * Composite layout is made up of multiple layers.
  *
+ * Each layer except the zeroth one, costitutes of a sub-layout and a list of
+ * extents associated with that layer.
+ *
+ * Zeroth layer is a special layer which contains a sub-layout that in fact is
+ * the old layout. Zeroth layer does not contain any list of extents.
+ *
+ * By default, a composite layout is created with the zeroth layer being
+ * mandatory part of it. And typically, one layer gets added to the composite
+ * layout with each failure.
+ *
+ * Composite Layout Use Case Example - NBA
+ * 1) Revoke old layout from all the clients.
+ * 2) Send a new composite layout.
+ *    (i)  New writes are directed into new sub-layouts, extents are associated
+ *         with the new sub-layout as they are writtent to.
+ *    (ii) Reads from not-yet-migrated will be directed to old sub-layout.
+ * 4) Recoverable data is migrated from old server to new.
+ * 5) Eventually, “layout flattening” will be invoked that will convert
+ *    composite layouts to new non-composite layouts. (Future)
  * @{
  */
 
@@ -61,11 +78,7 @@ struct c2_composite_layout {
 	uint64_t          cl_magic;
 };
 
-/**
- * Layer of a composite layout.
- * There can be multiple layers in a composite layout. Typically, one layer
- * gets added per failure.
- */
+/** Layer of a composite layout. */
 struct c2_composite_layer {
 	/** Sublayout associated with this layer. */
 	struct c2_layout *clr_l;
@@ -101,26 +114,79 @@ struct c2_composite_layer {
 };
 
 /**
- * Extent that is part of 'a layer of a composite layout'. Any composite layer
- * contains list of such extents.
+ * State of an extent.
+ *
+ * Value of this enum is stored (in memory and in the DB) along with each
+ * extent of each layer from every composite layout.
+ *
+ * Two back-to-back extents can be merged if and only if their states are the
+ * same.
+ */
+enum c2_composite_layer_ext_state {
+	/**
+	 * This value is used to tag an extent that does not belong to the
+	 * layer. For example:
+	 * - an extent [0, C2_BINDEX_MAX + 1) would be with C2_CLRES_INVALID
+	 *   state for 'the zeroth layer that does not contain any extents'.
+	 * - an extent [0, X) would be with C2_CLRES_INVALID state for a
+	 *   layer 'that has a single extent [X, C2_BINDEX_MAX + 1) with
+	 *   C2_CLRES_VALID state, associated with it'.
+	 *
+	 * This relates to the implemtation of the extent map that by default
+	 * has the name-space from 0 to C2_BINDEX_MAX.
+	 *
+	 * Extents with this state are not stored in the in-memory list of the
+	 * extents.
+	 */
+	C2_CLRES_INVALID,
+
+	/**
+	 * Normal extent associated with a particular layer. All extents with
+	 * this value belong to the layer they are associated with.
+	 *
+	 * Any extent added using c2_composite_layer_ext_add(), gets added
+	 * with C2_CLRES_VALID as its default state.
+	 */
+	C2_CLRES_VALID,
+
+	/**
+	 * This value is used to tag an extent that is being operated upon by
+	 * the ongoing 'layout flattening process' (future).
+	 */
+	C2_CLRES_FLATTENING
+};
+
+
+/**
+ * Extent that is part of 'a layer of a composite layout'. Any layer except
+ * the zeroth one contains list of such extents.
+ *
+ * Some extents with the state C2_CLRES_INVALID exist in the DB version of
+ * the extents list. This relates to the implemtation of the extent map that
+ * by default has the name-space from 0 to C2_BINDEX_MAX.
+ *
+ * Such extents with the state C2_CLRES_INVALID are not stored in the in-memory
+ * version of the extents list.
+ *
  */
 struct c2_composite_layer_extent {
 	/** Extent being represented. */
-	struct c2_ext    cle_ext;
+	struct c2_ext                     cle_ext;
 
-	/** todo Add state of the extent */
+	/** State of the extent. */
+	enum c2_composite_layer_ext_state cle_state;
 
 	/**
 	 * Magic number set while c2_composite_layer_extent object is
 	 * initialised.
 	 */
-	uint64_t         cle_magic;
+	uint64_t                          cle_magic;
 
 	/**
 	 * Linkage used for maintaining list of the extents owned by a
-	 * particular sub-layout.
+	 * particular layer.
 	 */
-	struct c2_tlink  cle_list_linkage;
+	struct c2_tlink                   cle_list_linkage;
 };
 
 C2_TL_DECLARE(c2_layer, extern, struct c2_composite_layer);
@@ -128,13 +194,14 @@ C2_TL_DECLARE(c2_layer_extent, extern, struct c2_composite_layer_extent);
 
 /**
  * Allocates and builds a layout object with the composite layout type,
- * by setting its initial ref count to 1. It does not contain any layer by
- * default and the multiple layers can be added by explicitly using the API
- * c2_composite_layer_add().
+ * by setting its initial ref count to 1. It contains zeroth layer by
+ * default that points to the supplied old layout and it contains no extents.
  *
- * @pre c2_mutex_is_locked(&cl->cl_base.l_lock)
+ * Multiple layers can be subsequently added to this layout, by explicitly
+ * using the API c2_composite_layer_add().
  *
- * @post ergo(rc == 0, composite_invariant(*out) && c2_ref_read(l->l_ref) == 1)
+ * @post ergo(rc == 0, composite_invariant(*out))
+ * @post ergo(rc == 0, c2_ref_read(l->l_ref) == 1)
  *
  * @note The layout object built by this API is to be finalised by releasing
  * 'the reference on it that has been held during its creation'.
@@ -149,32 +216,68 @@ int c2_composite_build(struct c2_layout_domain *dom,
 		       struct c2_composite_layout **out);
 
 /**
- * Adds a layer to the composite layout.
+ * Adds a layer to the composite layout and updates the layout in the DB.
  *
- * @pre The Composite layout has already been added to the DB using
+ * @pre The composite layout has already been added to the DB using
  * c2_layout_add().
  */
-/* todo Add op as another arg? */
 int c2_composite_layer_add(struct c2_composite_layout *cl,
-			   struct c2_layout *l,
+			   struct c2_layout *sublayout,
 			   struct c2_tl *extlist,
 			   uint32_t ext_nr,
 			   struct c2_db_tx *tx);
 
-/** todo */
+/**
+ * Looks up for the layer that owns the extent containing the supplied
+ * offset. Also, returns the sublayout owned by the specific layer.
+ *
+ * The lookup starts with the top-most layer and goes upto the first layer.
+ * If the extent containing the offset is not found upto the first layer, then
+ * (the layer id of) the zeroth layer is returned. Zeroth layer does not
+ * have any extents associated with it.
+ *
+ * @todo This API currently directly looks up into the DB using the readily
+ * available c2_emap_lookup(). Is it ok OR it should be changed to look up
+ * into the in-memory list of the extents?
+ */
 int c2_composite_layer_ext_lookup(const struct c2_composite_layout *cl,
 				  c2_bindex_t offset,
 				  struct c2_db_tx *tx,
 				  uint32_t *layer_idx,
-				  struct c2_ext *ext);
+				  struct c2_ext *ext,
+				  struct c2_layout **sublayout);
 
-/** todo */
+/**
+ * Adds an extent to the specified layer of the specified composite layout,
+ * by right away updating the extents list in te DB.
+ *
+ * @todo The extents is added with the C2_CLRES_VALID state. Do we need to
+ * support adding the extents with supplied extent state?
+ */
 int c2_composite_layer_ext_add(struct c2_composite_layout *cl,
 			       uint32_t layer_idx,
 			       struct c2_ext *ext,
 			       struct c2_db_tx *tx);
 
-/** todo */
+/**
+ * Updates state of an extent owned by a specified layer of a specified
+ * composite layout, by right away updating it in te DB.
+ *
+ * todo Dec 13 Provide implementation
+ */
+int c2_composite_layer_ext_state_update(struct c2_composite_layout *cl,
+					uint32_t layer_idx,
+					struct c2_ext *ext,
+					struct c2_db_tx *tx);
+
+/* todo Dec 13 Check where const is applicable to the args. */
+
+/**
+ * Deletes an extent from the specified layer of the specified composite
+ * layout, by right away updating the extents list in te DB.
+ *
+ * todo Dec 13 Provide implementation
+ */
 int c2_composite_layer_ext_delete(struct c2_composite_layout *cl,
 				  uint32_t layer_idx,
 				  struct c2_ext *ext,
diff --git a/layout/ut/composite.c b/layout/ut/composite.c
index 7e864ac..0006e80 100644
--- a/layout/ut/composite.c
+++ b/layout/ut/composite.c
@@ -103,6 +103,7 @@ static void extentlist_build(struct c2_tl **extlist,
 		extent->cle_ext.e_start = min_start_offset +
 					  (multiplier * i * delta);
 		extent->cle_ext.e_end = extent->cle_ext.e_start + delta;
+		extent->cle_state = C2_CLRES_VALID;
 #ifndef __KERNEL__
 		printf("ext[%u]: start %llu, end %llu \n", i,
 			(unsigned long long)extent->cle_ext.e_start,
@@ -1360,48 +1361,6 @@ static int test_delete_composite(uint64_t lid,
 }
 #endif
 
-#if 0
-/* Dec 04 Continue to tune this one for adding extent in between-
- that either overlaps, sits in between etc.
-*/
-static void extent_to_insert(uint32_t insertion_idx,
-			     uint32_t extents_nr,
-			     c2_bindex_t min_start_offset,
-			     c2_bindex_t approximate_end_offset,
-			     bool if_contiguous_extents,
-			     struct c2_ext *ext)
-{
-	c2_bindex_t delta;
-	c2_bindex_t multiplier;
-
-	C2_PRE(insertion_idx < extents_nr - 1);
-
-	//todo extents_nr will need to be derived from min_extents_nr
-	//once I start doing extents_nr++ with each layer.
-
-	multiplier = if_contiguous_extents ? 1 : 2;
-	delta = (approximate_end_offset - min_start_offset) /
-		(extents_nr * multiplier);
-#ifndef __KERNEL__
-	printf("extent_to_insert(): insertion_idx %lu, extents_nr %lu, "
-	       "min_start_offset %llu, approximate_end_offset %llu\n",
-		(unsigned long)insertion_idx,
-		(unsigned long)extents_nr,
-		(unsigned long long)min_start_offset,
-		(unsigned long long)approximate_end_offset);
-#endif
-
-	ext->e_start = min_start_offset +
-		       (multiplier * insertion_idx * delta); //todo + delta;
-	ext->e_end = ext->e_start + delta;
-#ifndef __KERNEL__
-	printf("extent_to_insert: start %llu, end %llu \n",
-		(unsigned long long)ext->e_start,
-		(unsigned long long)ext->e_end);
-#endif
-}
-#endif
-
 static void extent_to_be_operated(const struct c2_composite_layout *cl,
 				  bool if_contiguous_extents,
 				  uint32_t layer_idx,
@@ -1416,14 +1375,11 @@ static void extent_to_be_operated(const struct c2_composite_layout *cl,
 	int                               i;
 
 	C2_UT_ASSERT(layer_idx > 0);
-#if 0
-		if (layer->clr_idx == layer_idx)
-			ext_idxth = layer->clr_ext;
-		else if (layer->clr_idx == layer_idx + 1) {
-			ext_idx_plus_oneth = layer->clr_ext;
-			break;
-		}
-#endif
+	C2_UT_ASSERT(C2_IN(kind_of_extent_to_add, (EXACT_EXISTING,
+						   NON_EXISTING,
+						   OVERLAPPING_LEFT,
+						   OVERLAPPING_RIGHT,
+						   OVERLAPPING_COMPLETE)));
 
 	/* Find the layer. */
 	layer = NULL;
@@ -1431,16 +1387,13 @@ static void extent_to_be_operated(const struct c2_composite_layout *cl,
 		if (layer->clr_idx == layer_idx)
 			break;
 	} c2_tl_endfor;
-
 	C2_UT_ASSERT(layer != NULL);
+
 	C2_UT_ASSERT(ergo(kind_of_extent_to_add == EXACT_EXISTING,
 			  extent_idx < layer->clr_extents_nr));
-	C2_UT_ASSERT(ergo(kind_of_extent_to_add == NON_EXISTING,
-		          if_contiguous_extents == false &&
-			  layer->clr_extents_nr >= 3 &&
-			  layer->clr_extents_nr >= extent_idx + 1));
-	C2_UT_ASSERT(ergo(kind_of_extent_to_add == OVERLAPPING_LEFT,
-		          if_contiguous_extents == false &&
+	/* todo Optimise the asserts. */
+	C2_UT_ASSERT(ergo(kind_of_extent_to_add != EXACT_EXISTING,
+		          //todo Dec 12 Add for NON_EXISTING if_contiguous_extents == false &&
 			  layer->clr_extents_nr >= 3 &&
 			  layer->clr_extents_nr >= extent_idx + 1));
 
@@ -1450,15 +1403,14 @@ static void extent_to_be_operated(const struct c2_composite_layout *cl,
 			ext_idxth = extent->cle_ext;
 			if (kind_of_extent_to_add == EXACT_EXISTING)
 				break;
-		}
-		else if (i == extent_idx + 1) {
+		} else if (i == extent_idx + 1) {
 			ext_idx_plus_oneth = extent->cle_ext;
 			break;
 		}
 		++i;
 	} c2_tl_endfor;
 
-	C2_UT_ASSERT(ergo(if_contiguous_extents == false,
+	C2_UT_ASSERT(ergo(!if_contiguous_extents,
 			  ext_idxth.e_end != ext_idx_plus_oneth.e_start));
 
 	if (kind_of_extent_to_add == EXACT_EXISTING)
@@ -1468,7 +1420,23 @@ static void extent_to_be_operated(const struct c2_composite_layout *cl,
 		ext->e_end = ext_idx_plus_oneth.e_start;
 	} else if (kind_of_extent_to_add == OVERLAPPING_LEFT) {
 		ext->e_start = ext_idxth.e_start;
+		ext->e_end = ext_idx_plus_oneth.e_start;
+	} else if (kind_of_extent_to_add == OVERLAPPING_RIGHT) {
+		ext->e_start = ext_idxth.e_end;
 		ext->e_end = ext_idx_plus_oneth.e_end;
+	} else if (kind_of_extent_to_add == OVERLAPPING_COMPLETE) {
+#if 1
+		ext->e_start = ext_idxth.e_start - 2;
+		ext->e_end = ext_idx_plus_oneth.e_end + 2;
+#endif
+#if 0
+		ext->e_start = ext_idxth.e_start - 1;
+		ext->e_end = ext_idx_plus_oneth.e_end + 2;
+#endif
+#if 0
+		ext->e_start = ext_idxth.e_start - 2;
+		ext->e_end = ext_idxth.e_start + 2;
+#endif
 	}
 
 #ifndef __KERNEL__
@@ -1500,6 +1468,7 @@ int test_ext_lookup_composite(uint64_t lid,
 	struct c2_ext               ext_to_lookup;
 	struct c2_ext               ext;
 	uint32_t                    layer_idx;
+	struct c2_layout           *sublayout;
 	struct c2_db_tx             tx;
 	int                         rc_tmp;
 
@@ -1524,7 +1493,7 @@ int test_ext_lookup_composite(uint64_t lid,
 	ext.e_start = 0;
 	ext.e_end = 0;
 	rc = c2_composite_layer_ext_lookup(cl, ext_to_lookup.e_start, &tx,
-					   &layer_idx, &ext);
+					   &layer_idx, &ext, &sublayout);
 
 	rc_tmp = c2_db_tx_commit(&tx);
 	C2_UT_ASSERT(rc_tmp == 0);
@@ -1533,6 +1502,7 @@ int test_ext_lookup_composite(uint64_t lid,
 		C2_UT_ASSERT(rc == 0);
 		C2_UT_ASSERT(ext_to_lookup.e_start == ext.e_start);
 		C2_UT_ASSERT(ext_to_lookup.e_end == ext.e_end);
+		C2_UT_ASSERT(sublayout->l_id == lid * 100 + layer_idx);
 	} else if (kind_of_extent_to_lookup == NON_EXISTING) {
 		C2_UT_ASSERT(rc == -ENOENT);
 		rc = 0;
@@ -1550,7 +1520,8 @@ int test_ext_lookup_composite(uint64_t lid,
 	return rc;
 }
 
-/* Lookup for the layout object from the DB. */
+/* Wrapper that looks up for the layout object from the DB. */
+/* todo Move this to layout.c. */
 static int layout_lookup(uint64_t lid,
 			 /* todo Accept lt and make it generic. */
 			 struct c2_layout_domain *domain,
@@ -1639,31 +1610,27 @@ int test_ext_add_composite(uint64_t lid,
 	/* Verify the extent list in the in-memory layout. */
 	if (kind_of_extent_to_add == EXACT_EXISTING) {
 		composite_layout_compare(l_copy_orig, l_copy_updated, false);
-	} else if (kind_of_extent_to_add == NON_EXISTING) {
+	} else {
+		C2_UT_ASSERT(C2_IN(kind_of_extent_to_add,
+				   (NON_EXISTING,
+				    NON_EXISTING,
+				    OVERLAPPING_LEFT,
+				    OVERLAPPING_RIGHT,
+				    OVERLAPPING_COMPLETE)));
 		/* The following fails as expected. */
 #if 0
 		composite_layout_compare(l_copy_orig, l_copy_updated, false);
 #endif
-	} else if (kind_of_extent_to_add == OVERLAPPING_LEFT) {
-		/* todo This shall fail. */
-		composite_layout_compare(l_copy_orig, l_copy_updated, false);
-	} else if (kind_of_extent_to_add == OVERLAPPING_RIGHT) {
-		/* todo This shall fail. */
-		composite_layout_compare(l_copy_orig, l_copy_updated, false);
-	} else if (kind_of_extent_to_add == OVERLAPPING_COMPLETE) {
-		/* todo This shall fail. */
-		composite_layout_compare(l_copy_orig, l_copy_updated, false);
 	}
 
 	/* Delete the composite layout object. */
 	c2_layout_put(&cl->cl_base);
 	C2_UT_ASSERT(c2_layout_find(domain, lid) == NULL);
 
-	/* Read the layout from the DBand compare. */
+	/* Read the layout from the DB and compare. */
 	rc = layout_lookup(lid, domain, !FAILURE_TEST, &l_from_DB);
 	C2_UT_ASSERT(rc == 0);
 
-	//composite_layout_compare(l_from_DB, l_copy_orig, false);
 	/* Following should succeed eventually. */
 	composite_layout_compare(l_from_DB, l_copy_updated, false);
 
diff --git a/layout/ut/layout.c b/layout/ut/layout.c
index 1a35db6..8b2b636 100644
--- a/layout/ut/layout.c
+++ b/layout/ut/layout.c
@@ -3859,13 +3859,14 @@ static void test_composite_layer_ops(void)
 {
 	uint64_t lid;
 
+#if 1
 	/* todo
 	 * Build a layout object with COMPOSITE layout type, with noncontiguous
 	 * extents in its layers and with the extents with the range from 0 to
 	 * C2_BINDEX_MAX and destroy it.
 	 */
 	lid = 22001;
-	rc = test_ext_lookup_composite(lid, &domain, 6, 100,
+	rc = test_ext_lookup_composite(lid, &domain, 6, 4 /* todo 100 */,
 				       lid * 100, lid * 100 * 100,
 				       !CONTIGUOUS_EXTENTS, EXACT_EXISTING,
 				       !FAILURE_TEST);
@@ -3895,16 +3896,28 @@ static void test_composite_layer_ops(void)
 				    !FAILURE_TEST);
 	C2_UT_ASSERT(rc == 0);
 
-
-	/* todo Dec 07 Continue from here. */
-#if 0
 	lid = 22005;
 	rc = test_ext_add_composite(lid, &domain, 6, 4,
 				    lid * 100, lid * 100 * 100,
 				    !CONTIGUOUS_EXTENTS, OVERLAPPING_LEFT,
 				    !FAILURE_TEST);
 	C2_UT_ASSERT(rc == 0);
+
+	lid = 22006;
+	rc = test_ext_add_composite(lid, &domain, 6, 4,
+				    lid * 100, lid * 100 * 100,
+				    !CONTIGUOUS_EXTENTS, OVERLAPPING_RIGHT,
+				    !FAILURE_TEST);
+	C2_UT_ASSERT(rc == 0);
+
 #endif
+	lid = 22007;
+	rc = test_ext_add_composite(lid, &domain, 6, 4,
+				    lid * 100, lid * 100 * 100,
+				    CONTIGUOUS_EXTENTS, OVERLAPPING_COMPLETE,
+				    !FAILURE_TEST);
+	C2_UT_ASSERT(rc == 0);
+
 
 	/* todo Shall cover the other cases of extent type to be added. */
 
-- 
1.8.3.2

