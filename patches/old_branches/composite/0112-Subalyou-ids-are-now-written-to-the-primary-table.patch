From cc824059ab007a2ae20e937e0749450469e6be5f Mon Sep 17 00:00:00 2001
From: "trupti.patil" <trupti_patil@xyratex.com>
Date: Fri, 12 Apr 2013 18:34:46 +0530
Subject: [PATCH 112/172] Subalyou ids are now written to the primary table

- Removed the need for another auxiliary table to specifically store the
  sublayout ids for all the composite layouts
---
 layout/composite.c          | 470 +++++++++++++++++++++++++++-----------------
 layout/composite_internal.h |  28 +++
 layout/layout_internal.h    |   6 +
 layout/ut/composite.c       | 190 +++++++++++-------
 layout/ut/composite.h       |   2 +-
 layout/ut/layout.c          |  38 ++--
 layout/ut/layout.h          |   1 +
 layout/ut/layout_generic.c  |  27 +++
 8 files changed, 499 insertions(+), 263 deletions(-)

diff --git a/layout/composite.c b/layout/composite.c
index a867e08..743eac0 100644
--- a/layout/composite.c
+++ b/layout/composite.c
@@ -58,12 +58,6 @@ M0_BOB_DEFINE(static, &composite_instance_bob, m0_composite_instance);
 
 struct composite_schema_data {
 	/**
-	 * Table to store the lid for all the sublayouts from all the layers
-	 * of all the composite layouts.
-	 */
-	struct m0_table csd_layer_sublayout;
-
-	/**
 	 * Table to store the extent maps for all the layers of all the
 	 * composite layouts.
 	 */
@@ -71,56 +65,6 @@ struct composite_schema_data {
 };
 
 /**
- * layer_sublayout table.
- *
- * @note These key and rec structures need to be maintained as 8 bytes aligned.
- */
-struct layer_sublayout_key {
-	/** Layout id for the composite layout. */
-	uint64_t lrsmk_comp_lid;
-
-	/** Layer index. */
-	uint32_t lrsmk_layer_idx;
-
-	/** Padding to make the structure 8 bytes aligned. */
-	uint32_t lrsmk_pad;
-};
-M0_BASSERT(M0_IS_8ALIGNED(sizeof(struct layer_sublayout_key)));
-
-struct layer_sublayout_rec {
-	/** Layout id for the sublayout. */
-	uint64_t lrsmr_sublayout_lid;
-};
-M0_BASSERT(M0_IS_8ALIGNED(sizeof(struct layer_sublayout_rec)));
-
-/**
- * Compare layer_sublayout table keys.
- * This is a 3WAY comparison.
- */
-static int cl_key_cmp(struct m0_table *table,
-		      const void *key0, const void *key1)
-{
-	const struct layer_sublayout_key *k0 = key0;
-	const struct layer_sublayout_key *k1 = key1;
-
-	return M0_3WAY(k0->lrsmk_comp_lid, k1->lrsmk_comp_lid) ?:
-		M0_3WAY(k0->lrsmk_layer_idx, k1->lrsmk_layer_idx);
-}
-
-/** table_ops for the layer_sublayout table. */
-static const struct m0_table_ops composite_table_ops = {
-	.to = {
-		[TO_KEY] = {
-			.max_size = sizeof(struct layer_sublayout_key)
-		},
-		[TO_REC] = {
-			.max_size = sizeof(struct layer_sublayout_rec)
-		}
-	},
-	.key_cmp = cl_key_cmp
-};
-
-/**
  * Prefix for the layer_emap table. The prefix helps to identify an extent map
  * for 'a particular layer of a particular composite layout', from the set of
  * the extent maps for 'all the layers of all the composite layouts'.
@@ -288,21 +232,6 @@ static int composite_register(struct m0_layout_domain *dom,
 		return -ENOMEM;
 	}
 
-	if (M0_FI_ENABLED("table_init_err"))
-		{ rc = -EEXIST; goto err2_injected; }
-	rc = m0_table_init(&csd->csd_layer_sublayout, dom->ld_dbenv,
-			   "layer_sublayout", DEFAULT_DB_FLAG,
-			   &composite_table_ops);
-err2_injected:
-	if (rc != 0) {
-		m0_layout__log("composite_register",
-			       "failed to initialise layer_sublayout table",
-			       M0_LAYOUT_ADDB_LOC_COMP_REG_2, NULL, LID_NONE,
-			       rc);
-		m0_free(csd);
-		return rc;
-	}
-
 	if (M0_FI_ENABLED("emap_init_err"))
 		{ rc = -EEXIST; goto err3_injected; }
 	rc = m0_emap_init(&csd->csd_layer_emap, dom->ld_dbenv, "layer_emap");
@@ -312,7 +241,6 @@ err3_injected:
 			       "failed to initialise layer_emap",
 			       M0_LAYOUT_ADDB_LOC_COMP_REG_3, NULL, LID_NONE,
 			       rc);
-		m0_table_fini(&csd->csd_layer_sublayout);
 		m0_free(csd);
 		return rc;
 	}
@@ -333,7 +261,6 @@ static void composite_unregister(struct m0_layout_domain *dom,
 
 	M0_ENTRY("Layout_type_id %lu", (unsigned long)lt->lt_id);
 	csd = dom->ld_type_data[lt->lt_id];
-	m0_table_fini(&csd->csd_layer_sublayout);
 	m0_emap_fini(&csd->csd_layer_emap);
 	dom->ld_type_data[lt->lt_id] = NULL;
 	m0_free(csd);
@@ -414,7 +341,8 @@ static int layer_inmem_add(struct m0_composite_layout *cl,
 		 "is_user_count_adjust %d",
 		 (unsigned long long)cl->cl_base.l_id,
 		 (unsigned long long)sublayout->l_id,
-		 extlist, (unsigned long)ext_nr, is_user_count_adjust);
+		 extlist, (unsigned long)ext_nr,
+		 is_user_count_adjust ? 1 : 0);
 
 	M0_ALLOC_PTR(layer);
 	if (layer == NULL) {
@@ -620,7 +548,9 @@ static int layer_indb_delete(struct m0_composite_layout *cl,
 			     bool in_update_path);
 static int comp_layout_indb_read(struct m0_composite_layout *cl,
 				 struct m0_db_tx *tx,
-				 uint32_t user_count);
+				 uint32_t user_count,
+				 uint32_t layers_nr,
+				 uint64_t *sublayout_id_list);
 static int comp_layout_indb_add(struct m0_composite_layout *cl,
 				struct m0_db_tx *tx);
 static int comp_layout_indb_delete(struct m0_composite_layout *cl,
@@ -664,6 +594,7 @@ static int layer_add_internal(struct m0_composite_layout *cl,
 		return rc;
 	M0_ASSERT(layer->clr_idx > 0);
 
+#if 0
 	if (cl->cl_base.l_dom->ld_is_db_available) {
 		rc = layer_indb_add(cl, layer, tx);
 		if (rc != 0) {
@@ -674,6 +605,7 @@ static int layer_add_internal(struct m0_composite_layout *cl,
 							&layer->clr_extents);
 		}
 	}
+#endif
 	M0_POST(ergo(rc == 0, layer_invariant(layer)));
 	return rc;
 }
@@ -788,6 +720,7 @@ M0_INTERNAL int m0_composite_layer_delete(struct m0_composite_layout *cl,
 		return rc;
 	}
 
+#if 0
 	if (cl->cl_base.l_dom->ld_is_db_available) {
 		rc = layer_indb_delete(cl, emap, layer, tx, !IN_UPDATE_PATH);
 		if (rc != 0) {
@@ -799,6 +732,7 @@ M0_INTERNAL int m0_composite_layer_delete(struct m0_composite_layout *cl,
 				       cl->cl_base.l_id, rc);
 		}
 	}
+#endif
 
 	layer_inmem_delete(cl, layer, EXTLIST_FREE);
 	m0_mutex_unlock(&cl->cl_base.l_lock);
@@ -890,37 +824,79 @@ static int extlist_inbuf_read(struct m0_composite_layout *cl,
 	M0_RETURN(rc);
 }
 
+static int sublayout_ids_inbuf_read(struct m0_composite_layout *cl,
+				    struct m0_bufvec_cursor *cur,
+				    uint32_t *layers_nr,
+				    uint64_t **sl_id_list)
+{
+	struct m0_layout_composite_rec *cl_rec;
+	uint64_t                       *sublayout_id_list;
+	uint64_t                       *sublayout_id;
+	uint32_t                        i;
+
+	M0_PRE(composite_allocated_invariant(cl));
+	M0_PRE(cur != NULL);
+	M0_PRE(m0_bufvec_cursor_step(cur) >= sizeof *cl_rec);
+
+	M0_ENTRY("lid %llu", (unsigned long long)cl->cl_base.l_id);
+
+	/*
+	 * Read the composite layout type specific part of the record from the
+	 * buffer.
+	 */
+	cl_rec = m0_bufvec_cursor_addr(cur);
+	m0_bufvec_cursor_move(cur, sizeof *cl_rec);
+	*layers_nr = cl_rec->cr_layers_nr;
+
+	M0_ALLOC_ARR(sublayout_id_list, *layers_nr);
+	if (sublayout_id_list == NULL) {
+		//todo
+		return -ENOMEM;
+	}
+
+	/* Read the sublayout ids from the buffer. */
+	M0_ASSERT(m0_bufvec_cursor_step(cur) >=
+		  *layers_nr * sizeof sublayout_id_list[0]);
+	for (i = 0; i < cl_rec->cr_layers_nr; ++i) {
+		sublayout_id = m0_bufvec_cursor_addr(cur);
+		m0_bufvec_cursor_move(cur, sizeof *sublayout_id);
+		sublayout_id_list[i] = *sublayout_id;
+	}
+
+	*sl_id_list = sublayout_id_list;
+	M0_LEAVE("lid %llu, layers_nr %lu",
+		 (unsigned long long)cl->cl_base.l_id,
+		 (unsigned long)*layers_nr);
+	return 0;
+}
+
+//layers_inbuf_read()
 /**
  * Parses 'the composite layout type specific information including all the
  * layers' from the buffer provided and adds it to the in-memory layout.
  */
 static int comp_layout_inbuf_read(struct m0_composite_layout *cl,
 				  struct m0_bufvec_cursor *cur,
-				  uint32_t user_count)
+				  uint32_t user_count,
+				  uint32_t layers_nr,
+				  uint64_t *sublayout_id_list)
 {
-	struct composite_header       *cl_header;
-	struct composite_layer_header *lr_header;
-	struct m0_layout              *sublayout;
-	struct m0_tl                   extlist;
-	uint32_t                       i;
-	int                            rc = 0; /* To keep the compiler happy. */
+	struct composite_layer_header  *lr_header;
+	struct m0_layout               *sublayout;
+	struct m0_tl                    extlist;
+	uint32_t                        i;
+	int                             rc = 0; /* todo To keep the compiler happy. */
 
 	M0_PRE(composite_allocated_invariant(cl));
 	M0_PRE(cur != NULL);
-	M0_PRE(m0_bufvec_cursor_step(cur) >= sizeof *cl_header);
+	M0_PRE(m0_bufvec_cursor_step(cur) >= layers_nr * sizeof *lr_header);
 
-	M0_ENTRY("lid %llu, user_count %lu",
+	M0_ENTRY("lid %llu, user_count %lu, layers_nr %lu",
 		 (unsigned long long)cl->cl_base.l_id,
-		 (unsigned long)user_count);
+		 (unsigned long)user_count, (unsigned long)layers_nr);
 
-	/* Read the composite layout header from the buffer. */
-	cl_header = m0_bufvec_cursor_addr(cur);
-	m0_bufvec_cursor_move(cur, sizeof *cl_header);
-
-	/* Read the layers from the buffer. */
-	M0_ASSERT(m0_bufvec_cursor_step(cur) >=
-		  cl_header->ch_layers_nr * sizeof *lr_header);
-	for (i = 0; i < cl_header->ch_layers_nr; ++i) {
+	/* Read the extent list associated with each layer. */
+	for (i = 0; i < layers_nr; ++i) {
 		lr_header = m0_bufvec_cursor_addr(cur);
 		m0_bufvec_cursor_move(cur, sizeof *lr_header);
 
@@ -933,13 +909,14 @@ static int comp_layout_inbuf_read(struct m0_composite_layout *cl,
 			break;
 		}
 
-		sublayout = layout_find(cl->cl_base.l_dom, lr_header->clh_slid);
+		sublayout = layout_find(cl->cl_base.l_dom,
+					sublayout_id_list[i]);
 		if (sublayout == NULL) {
 			rc = -EINVAL;
 			M0_LOG(M0_ERROR, "lid %llu, sublayout with lid %llu "
 			       "does not exist",
 			       (unsigned long long)cl->cl_base.l_id,
-			       (unsigned long long)lr_header->clh_slid);
+			       (unsigned long long)sublayout_id_list[i]);
 			break;
 		}
 
@@ -987,6 +964,7 @@ static int comp_layout_inbuf_read(struct m0_composite_layout *cl,
 		layers_inmem_delete(cl);
 		composite_populate_reverse(cl);
 	}
+	m0_free(sublayout_id_list);
 	M0_RETURN(rc);
 }
 
@@ -998,6 +976,8 @@ static int composite_decode(struct m0_layout *l,
 			    uint32_t user_count)
 {
 	struct m0_composite_layout *cl;
+	uint32_t                    layers_nr;
+	uint64_t                   *sublayout_id_list;
 	int                         rc;
 
 	M0_PRE(m0_layout__allocated_invariant(l));
@@ -1010,14 +990,18 @@ static int composite_decode(struct m0_layout *l,
 	cl = bob_of(l, struct m0_composite_layout, cl_base, &composite_bob);
 	M0_PRE(composite_allocated_invariant(cl));
 
+	rc = sublayout_ids_inbuf_read(cl, cur, &layers_nr, &sublayout_id_list);
+	M0_ASSERT(layers_nr > 0);
 	if (op == M0_LXO_BUFFER_OP) {
-		rc = comp_layout_inbuf_read(cl, cur, user_count);
+		rc = comp_layout_inbuf_read(cl, cur, user_count,
+					    layers_nr, sublayout_id_list);
 		if (rc != 0)
 			M0_LOG(M0_ERROR, "lid %llu, failed to read layout from "
 			       "the buffer",
 			       (unsigned long long)cl->cl_base.l_id);
 	} else {
-		rc = comp_layout_indb_read(cl, tx, user_count);
+		rc = comp_layout_indb_read(cl, tx, user_count,
+					   layers_nr, sublayout_id_list);
 		if (rc != 0)
 			M0_LOG(M0_ERROR, "lid %llu, failed to read layout from "
 			       "the DB",
@@ -1030,36 +1014,31 @@ static int composite_decode(struct m0_layout *l,
 	return rc;
 }
 
+//rename layers_inbuf_write
 static void comp_layout_inbuf_write(const struct m0_composite_layout *cl,
 				    struct m0_bufvec_cursor *out)
 {
 	struct m0_composite_layer        *layer;
-	struct composite_header           cl_header;
 	struct composite_layer_header     lr_header;
 	struct m0_composite_layer_extent *lr_ext;
 	m0_bcount_t                       nbytes;
 
 	M0_ENTRY("lid %llu", (unsigned long long)cl->cl_base.l_id);
-
-	/* Write composite layout header into the buffer. */
-	M0_ASSERT(m0_bufvec_cursor_step(out) >= sizeof cl_header);
-	cl_header.ch_layers_nr = cl->cl_layers_nr;
-	cl_header.ch_pad = 0;
-	nbytes = m0_bufvec_cursor_copyto(out, &cl_header, sizeof cl_header);
-	M0_ASSERT(nbytes == sizeof cl_header);
-
-	/*
-	 * Read layers information from the layout and store it in the buffer.
+	M0_PRE(m0_bufvec_cursor_step(out) >= cl->cl_layers_nr *
+	       sizeof lr_header);
+	/* todo rm
+	 * Read extent list associated with each layer from the layout and
+	 * store those in the buffer.
 	 */
-	M0_ASSERT(m0_bufvec_cursor_step(out) >= cl->cl_layers_nr *
-		  sizeof lr_header);
 	m0_tl_for(comp_layer, &cl->cl_layers, layer) {
-		lr_header.clh_slid       = layer->clr_sl->l_id;
-		lr_header.clh_idx        = layer->clr_idx;
+		/* Write the layer header. */
+		lr_header.clh_idx = layer->clr_idx;
 		lr_header.clh_extents_nr = layer->clr_extents_nr;
-		lr_header.clh_pad        = 0;
 		nbytes = m0_bufvec_cursor_copyto(out, &lr_header,
 						 sizeof lr_header);
+		/* Write the associated extent list. */
+		M0_ASSERT(m0_bufvec_cursor_step(out) >=
+			  layer->clr_extents_nr * sizeof lr_ext->cle_ext);
 		m0_tl_for(m0_composite_layer_ext, &layer->clr_extents, lr_ext) {
 			nbytes = m0_bufvec_cursor_copyto(out,
 							&lr_ext->cle_ext,
@@ -1082,10 +1061,12 @@ static int composite_encode(struct m0_layout *l,
 			    struct m0_db_tx *tx,
 			    struct m0_bufvec_cursor *out)
 {
-	struct m0_composite_layout *cl;
-	struct m0_composite_layer  *layer;
-	uint32_t                    i;
-	int                         rc;
+	struct m0_composite_layout     *cl;
+	struct m0_layout_composite_rec  cl_rec;
+	m0_bcount_t                     nbytes;
+	struct m0_composite_layer      *layer;
+	uint32_t                        i;
+	int                             rc;
 
 	M0_PRE(l != NULL);
 	M0_PRE(m0_mutex_is_locked(&l->l_lock));
@@ -1094,9 +1075,30 @@ static int composite_encode(struct m0_layout *l,
 	M0_PRE(ergo(op != M0_LXO_BUFFER_OP, tx != NULL));
 	M0_PRE(out != NULL);
 
-	M0_ENTRY("%llu", (unsigned long long)l->l_id);
-
 	cl = m0_layout_to_cl(l);
+	M0_ENTRY("lid %llu, layers_nr %lu, op %lu",
+		 (unsigned long long)l->l_id, (unsigned long)cl->cl_layers_nr,
+		 (unsigned long)op);
+
+	/*
+	 * Write the composite layout type specific part of the record into the
+	 * buffer.
+	 */
+	M0_ASSERT(m0_bufvec_cursor_step(out) >= sizeof cl_rec);
+	cl_rec.cr_layers_nr = cl->cl_layers_nr;
+	cl_rec.cr_pad = 0;
+	nbytes = m0_bufvec_cursor_copyto(out, &cl_rec, sizeof cl_rec);
+	M0_ASSERT(nbytes == sizeof cl_rec);
+
+	/* Write the sublayout identifiers in the buffer. */
+	M0_ASSERT(m0_bufvec_cursor_step(out) >=
+		  cl->cl_layers_nr * sizeof layer->clr_sl->l_id);
+	m0_tl_for(comp_layer, &cl->cl_layers, layer) {
+		nbytes = m0_bufvec_cursor_copyto(out, &layer->clr_sl->l_id,
+						 sizeof layer->clr_sl->l_id);
+		M0_ASSERT(nbytes == sizeof layer->clr_sl->l_id);
+	} m0_tl_endfor;
+
 	if (op == M0_LXO_BUFFER_OP) {
 		comp_layout_inbuf_write(cl, out);
 		rc = 0;
@@ -1125,7 +1127,7 @@ static int composite_encode(struct m0_layout *l,
 			/*
 			 * It is possible that the layout did not exist in
 			 * the DB until the point it is asked to be updated
-			 * directly.
+			 * directly. Hence the later condition above.
 			 */
 			rc = comp_layout_indb_add(cl, tx);
 			if (rc == 0) {
@@ -1224,6 +1226,7 @@ static int ext_inmem_add_internal(struct m0_composite_layer *layer,
 		l = layer->clr_cl;
 	if (extlist == NULL)
 		extlist = &layer->clr_extents;
+#if 0 //todo enable
 	M0_ENTRY("lid %llu, layer %lu , e_start %llu, e_end %llu, "
 		 "e_state %llu, add_position %lu, "
 		 "adjacent_ext_start %llu, adjacent_ext_end %llu",
@@ -1236,6 +1239,7 @@ static int ext_inmem_add_internal(struct m0_composite_layer *layer,
 		 (unsigned long long)adjacent_lr_ext->cle_ext.e_start,
 		 (adjacent_lr_ext == NULL) ? 0 :
 		 (unsigned long long)adjacent_lr_ext->cle_ext.e_end);
+#endif
 
 	M0_ALLOC_PTR(lr_ext);
 	if (lr_ext == NULL) {
@@ -1277,11 +1281,13 @@ static int ext_inmem_add(struct m0_composite_layer *layer,
 	struct m0_composite_layer_extent *lr_ext;
 	int                               rc;
 
+#if 0
 	M0_ENTRY("lid %llu, layer %lu, e_start %llu, e_end %llu, e_state %llu ",
 		 (unsigned long long)layer->clr_cl->l_id,
 		 (unsigned long)layer->clr_idx,
 		 (unsigned long long)ext->e_start,
 		 (unsigned long long)ext->e_end, (unsigned long long)ext_state);
+#endif
 	/* Figure out the position such that the list remains sorted. */
 	lr_ext_to_insert_before = NULL;
 	lr_ext_to_insert_after = NULL;
@@ -1308,7 +1314,8 @@ static int ext_inmem_add(struct m0_composite_layer *layer,
 		M0_LOG(M0_ERROR, "lid %llu, extent could not be added to "
 		       "memory",
 		       (unsigned long long)layer->clr_cl->l_id);
-	M0_RETURN(rc);
+//todo	M0_RETURN(rc);
+	return rc;
 }
 
 /**
@@ -1929,17 +1936,24 @@ M0_INTERNAL int m0_composite_layer_ext_delete(struct m0_composite_layout *cl,
 /** Implementation of lo_recsize() for COMPOSITE layout type. */
 static m0_bcount_t composite_recsize(const struct m0_layout *l)
 {
-	return sizeof(struct m0_layout_rec);
+	struct m0_composite_layout *cl;
+	m0_bcount_t                 recsize;
+
+	cl = m0_layout_to_cl(l);
+	recsize = sizeof(struct m0_layout_rec) +
+		  sizeof(struct m0_layout_composite_rec) +
+		  min_check((uint32_t)LDB_MAX_COMPOSITE_LAYERS,
+			     cl->cl_layers_nr) * sizeof l->l_id;
+	M0_POST(recsize <= m0_layout_max_recsize(l->l_dom));
+	return recsize;
 }
 
 /** Implementation of lto_max_recsize() for COMPOSITE layout type. */
 static m0_bcount_t composite_max_recsize(struct m0_layout_domain *dom)
 {
-	/*
-	 * No data specific to the composite layout type is stored in the
-	 * generic table.
-	 */
-	return 0;
+	return sizeof(struct m0_layout_composite_rec) +
+		sizeof(struct m0_layout_composite_rec) +
+		LDB_MAX_COMPOSITE_LAYERS * sizeof(uint64_t);
 }
 
 /* DB related routines start here. */
@@ -1952,6 +1966,7 @@ static void prefix_set(struct layout_prefix *prefix,
 	prefix->lp_filler = 0;
 }
 
+#if 0
 static void pair_set(struct m0_db_pair *pair,
 		     struct layer_sublayout_key *key,
 		     struct layer_sublayout_rec *rec,
@@ -1969,6 +1984,7 @@ static void pair_set(struct m0_db_pair *pair,
 	m0_db_pair_setup(pair, &csd->csd_layer_sublayout,
 			 key, sizeof *key, rec, sizeof *rec);
 }
+#endif
 
 static int emap_iterator_set(struct m0_composite_layout *cl,
 			     struct m0_emap *emap,
@@ -2324,6 +2340,7 @@ err1_injected:
 	M0_RETURN(rc);
 }
 
+#if 0
 static int sublayout_id_indb_lookup(struct m0_composite_layout *cl,
 				    uint32_t layer_idx,
 				    struct m0_db_tx *tx,
@@ -2361,7 +2378,9 @@ err1_injected:
 	M0_POST(ergo(rc == 0, *sublayout_id > 0));
 	M0_RETURN(rc);
 }
+#endif
 
+#if 0
 static int sublayout_id_indb_add(struct m0_composite_layout *cl,
 				 const struct m0_composite_layer *layer,
 				 struct m0_db_tx *tx)
@@ -2414,7 +2433,9 @@ err1_injected:
 	m0_db_pair_fini(&pair);
 	M0_RETURN(rc);
 }
+#endif
 
+#if 0
 static int sublayout_id_indb_delete(const struct m0_composite_layout *cl,
 				    const struct m0_composite_layer *layer,
 				    struct m0_db_tx *tx)
@@ -2443,6 +2464,7 @@ err1_injected:
 	m0_db_pair_fini(&pair);
 	M0_RETURN(rc);
 }
+#endif
 
 static int extmap_indb_add(struct m0_composite_layout *cl,
 			   struct m0_composite_layer *layer,
@@ -2528,10 +2550,13 @@ static int layer_indb_add(struct m0_composite_layout *cl,
 		 (unsigned long)layer->clr_idx);
 
 	/* Add 'the sublayout id for this layer' to the DB. */
+#if 0
 	rc = sublayout_id_indb_add(cl, layer, tx);
 	if (rc == 0) {
+#endif
 		/* Add 'the extent map for this layer' to the DB. */
 		rc = extmap_indb_add(cl, layer, tx);
+#if 0
 		if (rc != 0)
 			/*
 			 * If extmap_indb_add() has failed for no apparent
@@ -2540,6 +2565,7 @@ static int layer_indb_add(struct m0_composite_layout *cl,
 			 */
 			sublayout_id_indb_delete(cl, layer, tx);
 	}
+#endif
 
 	M0_POST(composite_invariant(cl));
 	M0_RETURN(rc);
@@ -2611,9 +2637,10 @@ static int extentmap_indb_read(struct m0_composite_layout *cl,
  */
 static int comp_layout_indb_read(struct m0_composite_layout *cl,
 				 struct m0_db_tx *tx,
-				 uint32_t user_count)
+				 uint32_t user_count,
+				 uint32_t layers_nr,
+				 uint64_t *sublayout_id_list)
 {
-	uint64_t                   sublayout_id;
 	struct m0_layout          *sublayout;
 	struct m0_tl               extlist;
 	uint32_t                   extents_nr;
@@ -2621,37 +2648,19 @@ static int comp_layout_indb_read(struct m0_composite_layout *cl,
 	uint32_t                   i; /* layer idx */
 	int                        rc;
 
-	M0_ENTRY("lid %llu", (unsigned long long)cl->cl_base.l_id);
-
-	i = 0;
-	while (1) {
-		/* Read 'the sublayout id for this layer' from the DB. */
-		rc = sublayout_id_indb_lookup(cl, i, tx, &sublayout_id);
-		if (rc != 0) {
-			if (rc == -ENOENT) {
-				/*
-				 * The number of layers is not known in
-				 * advance. Hence, break when the first
-				 * -ENOENT error is encountered.
-				 */
-				M0_ASSERT(i > 0);
-				rc = 0;
-			} else
-				M0_LOG(M0_ERROR, "lid %llu, layer %lu, "
-				       "sublayout id could not be read from "
-				       "the DB",
-				       (unsigned long long)cl->cl_base.l_id,
-				       (unsigned long)i);
-			break;
-		}
+	M0_ENTRY("lid %llu, layers_nr %lu",
+		 (unsigned long long)cl->cl_base.l_id,
+		 (unsigned long)layers_nr);
 
-		sublayout = layout_find(cl->cl_base.l_dom, sublayout_id);
+	for (i = 0; i < layers_nr; ++i) {
+		sublayout = layout_find(cl->cl_base.l_dom,
+					sublayout_id_list[i]);
 		if (sublayout == NULL) {
 			M0_LOG(M0_ERROR, "lid %llu, layer %lu, sublayout with "
 			       "lid %llu does not exist",
 			       (unsigned long long)cl->cl_base.l_id,
 			       (unsigned long)i,
-			       (unsigned long long)sublayout_id);
+			       (unsigned long long)sublayout_id_list[i]);
 			rc = -EINVAL;
 			break;
 		}
@@ -2689,9 +2698,8 @@ static int comp_layout_indb_read(struct m0_composite_layout *cl,
 			extlist_free(&extlist);
 			break;
 		}
-		++i;
+		//todo rm ++i;
 	}
-
 	if (rc != 0 && i > 0) {
 		/*
 		 * Undo the layer addition and the layout population done
@@ -2701,7 +2709,7 @@ static int comp_layout_indb_read(struct m0_composite_layout *cl,
 		layers_inmem_delete(cl);
 		composite_populate_reverse(cl);
 	}
-
+	m0_free(sublayout_id_list);
 	M0_RETURN(rc);
 }
 
@@ -2711,7 +2719,9 @@ static int comp_layout_indb_add(struct m0_composite_layout *cl,
 	struct m0_composite_layer *layer;
 	int                        rc;
 
-	M0_ENTRY("lid %llu", (unsigned long long)cl->cl_base.l_id);
+	M0_ENTRY("lid %llu, layers_nr %lu",
+		 (unsigned long long)cl->cl_base.l_id,
+		 (unsigned long)cl->cl_layers_nr);
 
 	/* Collect the zeroth layer from the in-memory layout. */
 	layer = comp_layer_tlist_head(&cl->cl_layers);
@@ -2751,6 +2761,36 @@ static int single_ext_indb_write(struct m0_emap_cursor *it,
 				       !INMEM_LIST_UPDATE);
 }
 
+static int single_ext_indb_write_2(struct m0_composite_layout *cl,
+				   uint32_t layer_idx, struct m0_db_tx *tx)
+{
+	struct m0_emap        *emap;
+	struct layout_prefix   prefix;
+	struct m0_emap_cursor  it;
+	struct m0_ext          ext;
+	int                    rc;
+	struct callback_data cb_data = {
+		.cb_layer             = NULL,
+		.cb_inmem_list_update = false,
+		.cb_rc                = 0
+	};
+
+	emap = emap_from_cl(cl);
+	prefix_set(&prefix, cl->cl_base.l_id, layer_idx);
+	rc = m0_emap_lookup(emap, tx, (struct m0_uint128 *)&prefix, 0, &it);
+	M0_ASSERT(rc == 0); //todo
+
+	ext.e_start = 0;
+	ext.e_end = M0_BINDEX_MAX + 1;
+
+	rc = m0_emap_paste(&it, &ext, M0_CLRES_INVALID, &cb_data,
+			   delete_callback, cut_left_callback,
+			   cut_right_callback);
+	M0_ASSERT(rc == 0); //todo
+	m0_emap_close(&it);
+	return rc;
+}
+
 static int layer_delete_verify(struct m0_composite_layout *cl,
 			       struct m0_emap *emap,
 			       struct m0_composite_layer *layer,
@@ -2907,9 +2947,11 @@ static int layer_indb_delete(struct m0_composite_layout *cl,
 	M0_ENTRY("lid %llu, in_update_path %d",
 		 (unsigned long long)cl->cl_base.l_id, in_update_path);
 
+#if 0
 	rc = sublayout_id_indb_delete(cl, layer, tx);
 	if (rc != 0)
 		return rc;
+#endif
 
 	/*
 	 * Decrement the user count of the sublayout while the layer is being
@@ -2938,7 +2980,7 @@ static int layer_indb_delete(struct m0_composite_layout *cl,
 			 * sublayout_id_indb_delete() too would fail. Hence,
 			 * ignoring its status.
 			 */
-			sublayout_id_indb_delete(cl, layer, tx);
+			//todo rm sublayout_id_indb_delete(cl, layer, tx);
 			m0_layout_user_count_inc(layer->clr_sl);
 			return rc;
 		}
@@ -2959,7 +3001,7 @@ err1_injected:
 			 * Ignoring the status of sublayout_id_indb_delete()
 			 * for the reason similar to mentioned above.
 			 */
-			sublayout_id_indb_delete(cl, layer, tx);
+			//todo rm sublayout_id_indb_delete(cl, layer, tx);
 			m0_layout_user_count_inc(layer->clr_sl);
 		return rc;
 	}
@@ -2968,38 +3010,114 @@ err1_injected:
 	return rc;
 }
 
+//todo
+static int existing_layers_nr_read(struct m0_composite_layout *cl,
+				   struct m0_db_tx * tx,
+				   uint32_t *layers_nr)
+{
+	struct m0_layout               *l = &cl->cl_base;
+	struct m0_db_pair               pair;
+	m0_bcount_t                     recsize;
+	uint64_t                        key;
+	void                           *rec;
+	struct m0_bufvec                bv;
+	struct m0_bufvec_cursor         cur;
+	struct m0_layout_composite_rec *cl_rec;
+	int                             rc;
+
+	M0_ENTRY("lid %llu", (unsigned long long)cl->cl_base.l_id);
+	*layers_nr = 0;
+
+	key = l->l_id;
+	recsize = m0_layout_max_recsize(l->l_dom);
+	rec = m0_alloc(recsize);
+	M0_ASSERT(rec != NULL);
+	m0_db_pair_setup(&pair, &l->l_dom->ld_layouts,
+			 &key, sizeof l->l_id, rec, recsize);
+	rc = m0_table_lookup(tx, &pair);
+	M0_ASSERT(rc == 0 || rc == -ENOENT);
+	if (rc == 0) {
+		/*
+		 * Set up cursor and move it to point to the layout type
+		 * specific payload.
+		 */
+		bv = (struct m0_bufvec)M0_BUFVEC_INIT_BUF(
+						&pair.dp_rec.db_buf.b_addr,
+						&recsize);
+		m0_bufvec_cursor_init(&cur, &bv);
+		m0_bufvec_cursor_move(&cur, sizeof(struct m0_layout_rec));
+		cl_rec = m0_bufvec_cursor_addr(&cur);
+		*layers_nr = cl_rec->cr_layers_nr;
+	}
+	m0_free(rec);
+	M0_LOG(M0_DEBUG, "lid %llu, rc %d, existing_layers_nr %lu",
+	       (unsigned long long)cl->cl_base.l_id, rc,
+	       (unsigned long)*layers_nr);
+	return rc;
+}
+
 static int comp_layout_indb_delete(struct m0_composite_layout *cl,
 				   struct m0_db_tx *tx, bool in_update_path)
 {
 	struct m0_composite_layer *layer;
 	struct m0_emap            *emap;
+	uint32_t                   existing_layers_nr;
+	struct layout_prefix       prefix;
+	uint32_t                   i;
 	int                        rc;
 
-	M0_ENTRY("lid %llu", (unsigned long long)cl->cl_base.l_id);
+	M0_ENTRY("lid %llu, layers_nr %lu",
+		 (unsigned long long)cl->cl_base.l_id,
+		 (unsigned long)cl->cl_layers_nr);
 	emap = emap_from_cl(cl);
 
-	/**
-	 * A composite layout can be deleted from the DB if and only if none of
-	 * its layers contain any valid extents.
-	 */
-	if (!in_update_path) {
+	if (in_update_path) {
+		//todo
+		rc = existing_layers_nr_read(cl, tx, &existing_layers_nr);
+		M0_ASSERT(rc == 0 || rc == -ENOENT);
+
+		/* todo Apr09 Now, delete the existing_layers_nr layers from
+		 * the DB. Make use of single_ext_indb_write(). Make it accept
+		 * l instead of layer*/
+		if (rc == 0) {
+			//todo Reduce the user_count of the sublayouts
+			for (i = existing_layers_nr - 1; i >= 0; --i) {
+				rc = single_ext_indb_write_2(cl, i, tx);
+				M0_ASSERT(rc == 0); //todo
+
+				prefix_set(&prefix, cl->cl_base.l_id, i);
+				rc = m0_emap_obj_delete(emap, tx,
+						(struct m0_uint128 *)&prefix);
+				M0_ASSERT(rc == 0); //todo
+				if (i == 0)
+					break;
+			}
+		} else
+			rc = 0;
+	} else {
+		/**
+		 * A composite layout can be deleted from the DB if and only if
+		 * none of its layers contain any valid extents.
+		 */
 		m0_tl_for(comp_layer, &cl->cl_layers, layer) {
 			rc = layer_delete_verify(cl, emap, layer, tx);
 			if (rc != 0)
 				return rc;
 		} m0_tl_endfor;
+
+		m0_tl_for(comp_layer, &cl->cl_layers, layer) {
+			rc = layer_indb_delete(cl, emap, layer, tx,
+					       in_update_path);
+			if (rc != 0) {
+				M0_LOG(M0_ERROR, "lid %llu, layer %lu, "
+				       "Error while deleting layer from DB ",
+				       (unsigned long long)cl->cl_base.l_id,
+				       (unsigned long)layer->clr_idx);
+				break;
+			}
+		} m0_tl_endfor;
 	}
 
-	m0_tl_for(comp_layer, &cl->cl_layers, layer) {
-		rc = layer_indb_delete(cl, emap, layer, tx, in_update_path);
-		if (rc != 0) {
-			M0_LOG(M0_ERROR, "lid %llu, layer %lu, "
-			       "Error while deleting layer from DB ",
-			       (unsigned long long)cl->cl_base.l_id,
-			       (unsigned long)layer->clr_idx);
-			break;
-		}
-	} m0_tl_endfor;
 
 	M0_ENTRY("lid %llu, rc %d", (unsigned long long)cl->cl_base.l_id, rc);
 	return rc;
diff --git a/layout/composite_internal.h b/layout/composite_internal.h
index b6275fe..6f07694 100644
--- a/layout/composite_internal.h
+++ b/layout/composite_internal.h
@@ -40,6 +40,28 @@ struct m0_composite_layer;
 M0_TL_DECLARE(comp_layer, M0_INTERNAL, struct m0_composite_layer);
 
 /**
+ * Composite layout type specific part of the record for the layouts table.
+ *
+ * @note This structure needs to be maintained as 8 bytes aligned.
+ */
+struct m0_layout_composite_rec {
+	/** Total number of layers in a specific composite layout. */
+	uint32_t cr_layers_nr;
+
+	/** Padding to make the structure 8 bytes aligned. */
+	uint32_t cr_pad;
+
+	/**
+	 * Composite layout type specific payload.
+	 * Contains sublayout identifiers for the cr_layers_nr number of
+	 * layers.
+	 */
+	char     cr_data[0];
+};
+M0_BASSERT(M0_IS_8ALIGNED(sizeof(struct m0_layout_composite_rec)));
+
+#if 0
+/**
  * Structure used to store header information for a composite layout like
  * number of layers in it. It is used in the buffer representation of a
  * composite layout.
@@ -54,6 +76,7 @@ struct composite_header {
 	uint32_t ch_pad;
 };
 M0_BASSERT(M0_IS_8ALIGNED(sizeof(struct composite_header)));
+#endif
 
 /**
  * Structure used to store header information for 'a layer of a composite
@@ -63,9 +86,12 @@ M0_BASSERT(M0_IS_8ALIGNED(sizeof(struct composite_header)));
  * @note This structure needs to be maintained as 8 bytes aligned.
  */
 struct composite_layer_header {
+#if 0
 	/** Layout id for the layout used for this layer (sublayout). */
 	uint64_t clh_slid;
+#endif
 
+	//todo Check if the following field is required
 	/** Index of this layer into its owner composite layout. */
 	uint32_t clh_idx;
 
@@ -75,8 +101,10 @@ struct composite_layer_header {
 	 */
 	uint32_t clh_extents_nr;
 
+#if 0
 	/** Padding to make the structure 8 bytes aligned. */
 	uint32_t clh_pad;
+#endif
 
 	/**
 	 * Payload storing list of the extents (struct m0_ext) for a specific
diff --git a/layout/layout_internal.h b/layout/layout_internal.h
index 6b8ec98..a85cad1 100644
--- a/layout/layout_internal.h
+++ b/layout/layout_internal.h
@@ -59,6 +59,12 @@ enum {
 	LDB_MAX_INLINE_COB_ENTRIES = 20,
 
 	/**
+	 * Maximum limit on the number of layers those can be contained
+	 * by a composite layout.
+	 */
+	LDB_MAX_COMPOSITE_LAYERS   = 16,
+
+	/**
 	 * Simulation for m0_table_init() facing error in
 	 * m0_layout_domain_init().
 	 */
diff --git a/layout/ut/composite.c b/layout/ut/composite.c
index d5899e1..8067a8a 100644
--- a/layout/ut/composite.c
+++ b/layout/ut/composite.c
@@ -521,6 +521,12 @@ static int composite_build_and_layers_add(uint64_t lid,
 
 	if (is_add_to_db) {
 		if (domain->ld_is_db_available) {
+			/*
+			 * todo Now that some layers are added, they call for
+			 * m0_layout_update() so as to update the primary
+			 * table.
+			 */
+			layout_update(&(*cl)->cl_base);
 			rc_tmp = m0_db_tx_commit(txptr);
 			M0_UT_ASSERT(rc_tmp == 0);
 		}
@@ -590,17 +596,17 @@ static void composite_layout_buf_build(uint64_t composite_lid,
 				       bool if_contiguous_extents,
 				       struct m0_bufvec_cursor *dcur)
 {
-	m0_bcount_t                    nbytes;
-	uint64_t                       sublayout_id;
-	struct m0_layout              *sublayout;
-	struct composite_header        cl_header;
-	struct composite_layer_header  layer_header;
-	struct m0_ext                  ext;
-	uint64_t                       ext_state;
-	m0_bindex_t                    delta;
-	uint32_t                       extents_nr;
-	uint32_t                       i;
-	uint32_t                       j;
+	m0_bcount_t                     nbytes;
+	uint64_t                        sublayout_id;
+	struct m0_layout               *sublayout;
+	struct m0_layout_composite_rec  cl_rec;
+	struct composite_layer_header   layer_header;
+	struct m0_ext                   ext;
+	uint64_t                        ext_state;
+	m0_bindex_t                     delta;
+	uint32_t                        extents_nr;
+	uint32_t                        i;
+	uint32_t                        j;
 
 	M0_UT_ASSERT(dcur != NULL);
 	M0_UT_ASSERT(layers_nr > 0);
@@ -612,20 +618,29 @@ static void composite_layout_buf_build(uint64_t composite_lid,
 	 * Build part of the buffer representing composite type specific part
 	 * of the layout.
 	 */
-	M0_UT_ASSERT(m0_bufvec_cursor_step(dcur) >= sizeof cl_header);
-	cl_header.ch_layers_nr = layers_nr;
-	cl_header.ch_pad = 0;
-	nbytes = m0_bufvec_cursor_copyto(dcur, &cl_header, sizeof cl_header);
-	M0_UT_ASSERT(nbytes == sizeof cl_header);
-
-	M0_UT_ASSERT(m0_bufvec_cursor_step(dcur) >= cl_header.ch_layers_nr *
-		     sizeof layer_header);
+	M0_UT_ASSERT(m0_bufvec_cursor_step(dcur) >= sizeof cl_rec);
+	cl_rec.cr_layers_nr = layers_nr;
+	cl_rec.cr_pad = 0;
+	nbytes = m0_bufvec_cursor_copyto(dcur, &cl_rec, sizeof cl_rec);
+	M0_UT_ASSERT(nbytes == sizeof cl_rec);
 
 	/* Pre-create the sublayout to be used as the original layout. */
 	sublayout_build(composite_lid * 100, domain, &sublayout);
 	/* Pre-create the sublayouts to be used for layer 1 and above. */
 	sublayouts_precreate(composite_lid, domain, layers_nr);
 
+	/* Write the sublayout identifiers in the buffer. */
+	M0_UT_ASSERT(m0_bufvec_cursor_step(dcur) >=
+		     layers_nr * sizeof sublayout_id);
+	for (i = 0; i < layers_nr; ++i) {
+		sublayout_id = composite_lid * 100 + i;
+		nbytes = m0_bufvec_cursor_copyto(dcur, &sublayout_id,
+						 sizeof sublayout_id);
+	}
+
+	/* Write the layers to the buffer. */
+	M0_UT_ASSERT(m0_bufvec_cursor_step(dcur) >=
+		     layers_nr * sizeof layer_header);
 	extents_nr = min_extents_nr;
 	for (i = 0; i < layers_nr; ++i) {
 		sublayout_id = composite_lid * 100 + i;
@@ -641,10 +656,10 @@ static void composite_layout_buf_build(uint64_t composite_lid,
 		 */
 		m0_layout_user_count_inc(sublayout);
 
-		layer_header.clh_slid = sublayout_id;
+		//todo rm layer_header.clh_slid = sublyout_id;
 		layer_header.clh_idx = i;
 		layer_header.clh_extents_nr = extents_nr;
-		layer_header.clh_pad = 0;
+		//todo rm layer_header.clh_pad = 0;
 		nbytes = m0_bufvec_cursor_copyto(dcur, &layer_header,
 						 sizeof layer_header);
 		M0_UT_ASSERT(nbytes == sizeof layer_header);
@@ -752,15 +767,16 @@ static void composite_layout_buf_verify(uint64_t lid,
 					bool if_contiguous_extents,
 					struct m0_bufvec_cursor *cur)
 {
-	uint32_t                       lt_id;
-	struct composite_header       *cl_header;
-	struct composite_layer_header *layer_header;
-	struct m0_ext                 *ext;
-	uint64_t                      *ext_state;
-	m0_bindex_t                    delta;
-	uint32_t                       extents_nr;
-	uint32_t                       i;
-	uint32_t                       j;
+	uint32_t                        lt_id;
+	struct m0_layout_composite_rec *cl_rec;
+	uint64_t                       *sublayout_id;
+	struct composite_layer_header  *layer_header;
+	struct m0_ext                  *ext;
+	uint64_t                       *ext_state;
+	m0_bindex_t                     delta;
+	uint32_t                        extents_nr;
+	uint32_t                        i;
+	uint32_t                        j;
 
 	M0_UT_ASSERT(cur != NULL);
 
@@ -769,20 +785,26 @@ static void composite_layout_buf_verify(uint64_t lid,
 	M0_UT_ASSERT(lt_id == m0_composite_layout_type.lt_id);
 
 	/* Verify COMPOSITE layout type specific part of the layout buffer. */
-	M0_UT_ASSERT(m0_bufvec_cursor_step(cur) >= sizeof *cl_header);
-	cl_header = m0_bufvec_cursor_addr(cur);
-	M0_UT_ASSERT(cl_header != NULL);
-	m0_bufvec_cursor_move(cur, sizeof *cl_header);
-	M0_UT_ASSERT(cl_header->ch_layers_nr == layers_nr);
-
-	M0_UT_ASSERT(m0_bufvec_cursor_step(cur) >= cl_header->ch_layers_nr *
-						   sizeof *layer_header);
+	M0_UT_ASSERT(m0_bufvec_cursor_step(cur) >= sizeof *cl_rec);
+	cl_rec = m0_bufvec_cursor_addr(cur);
+	M0_UT_ASSERT(cl_rec != NULL);
+	m0_bufvec_cursor_move(cur, sizeof *cl_rec);
+	M0_UT_ASSERT(cl_rec->cr_layers_nr == layers_nr);
+
+	for (i = 0; i < layers_nr; ++i) {
+		sublayout_id = m0_bufvec_cursor_addr(cur);
+		m0_bufvec_cursor_move(cur, sizeof *sublayout_id);
+		M0_UT_ASSERT(*sublayout_id == lid * 100 + i);
+	}
+
+	M0_UT_ASSERT(m0_bufvec_cursor_step(cur) >=
+		     cl_rec->cr_layers_nr * sizeof *layer_header);
 	extents_nr = min_extents_nr;
 
-	for (i = 0; i < cl_header->ch_layers_nr; ++i) {
+	for (i = 0; i < layers_nr; ++i) {
 		layer_header = m0_bufvec_cursor_addr(cur);
 		m0_bufvec_cursor_move(cur, sizeof *layer_header);
-		M0_UT_ASSERT(layer_header->clh_slid == lid * 100 + i);
+		//todo rm M0_UT_ASSERT(layer_header->clh_slid == lid * 100 + i);
 		M0_UT_ASSERT(layer_header->clh_idx == i);
 		M0_UT_ASSERT(layer_header->clh_extents_nr == extents_nr);
 		M0_UT_ASSERT(m0_bufvec_cursor_step(cur) >=
@@ -835,7 +857,8 @@ int test_encode_composite(uint64_t lid,
 	M0_UT_ASSERT(rc == 0);
 
 	/* Encode the layout object into a layout buffer. */
-	allocate_area(domain, ADDITIONAL_BYTES_DEFAULT * 10, &num_bytes, &area);
+	//todo allocate_area(domain, ADDITIONAL_BYTES_DEFAULT * 10, &num_bytes, &area);
+	allocate_area(domain, ADDITIONAL_BYTES_DEFAULT * 30, &num_bytes, &area);
 	bv = (struct m0_bufvec) M0_BUFVEC_INIT_BUF(&area, &num_bytes);
 	m0_bufvec_cursor_init(&cur, &bv);
 
@@ -871,8 +894,8 @@ int test_encode_composite(uint64_t lid,
 static void composite_layout_buf_compare(struct m0_bufvec_cursor *cur1,
 					 struct m0_bufvec_cursor *cur2)
 {
-	struct composite_header       *cl_header1;
-	struct composite_header       *cl_header2;
+	struct m0_layout_composite_rec *cl_rec1;
+	struct m0_layout_composite_rec *cl_rec2;
 	struct composite_layer_header *layer_header1;
 	struct composite_layer_header *layer_header2;
 	struct m0_ext                 *ext1;
@@ -889,30 +912,29 @@ static void composite_layout_buf_compare(struct m0_bufvec_cursor *cur1,
 	lbuf_compare(cur1, cur2);
 
 	/* Compare COMPOSITE layout type specific part of the layout buffers. */
-	M0_UT_ASSERT(m0_bufvec_cursor_step(cur1) >= sizeof *cl_header1);
-	M0_UT_ASSERT(m0_bufvec_cursor_step(cur2) >= sizeof *cl_header2);
+	M0_UT_ASSERT(m0_bufvec_cursor_step(cur1) >= sizeof *cl_rec1);
+	M0_UT_ASSERT(m0_bufvec_cursor_step(cur2) >= sizeof *cl_rec2);
 
-	cl_header1 = m0_bufvec_cursor_addr(cur1);
-	cl_header2 = m0_bufvec_cursor_addr(cur2);
+	cl_rec1 = m0_bufvec_cursor_addr(cur1);
+	cl_rec2 = m0_bufvec_cursor_addr(cur2);
 
-	m0_bufvec_cursor_move(cur1, sizeof *cl_header1);
-	m0_bufvec_cursor_move(cur2, sizeof *cl_header2);
+	m0_bufvec_cursor_move(cur1, sizeof *cl_rec1);
+	m0_bufvec_cursor_move(cur2, sizeof *cl_rec2);
 
-	M0_UT_ASSERT(cl_header1->ch_layers_nr ==
-		     cl_header2->ch_layers_nr);
+	M0_UT_ASSERT(cl_rec1->cr_layers_nr == cl_rec2->cr_layers_nr);
 
 	M0_UT_ASSERT(m0_bufvec_cursor_step(cur1) >=
-		     cl_header1->ch_layers_nr * sizeof *layer_header1);
+		     cl_rec1->cr_layers_nr * sizeof *layer_header1);
 	M0_UT_ASSERT(m0_bufvec_cursor_step(cur2) >=
-		     cl_header2->ch_layers_nr * sizeof *layer_header2);
+		     cl_rec2->cr_layers_nr * sizeof *layer_header2);
 
-	for (i = 0; i < cl_header1->ch_layers_nr; ++i) {
+	for (i = 0; i < cl_rec1->cr_layers_nr; ++i) {
 		layer_header1 = m0_bufvec_cursor_addr(cur1);
 		layer_header2 = m0_bufvec_cursor_addr(cur2);
 		m0_bufvec_cursor_move(cur1, sizeof *layer_header1);
 		m0_bufvec_cursor_move(cur2, sizeof *layer_header2);
-		M0_UT_ASSERT(layer_header1->clh_slid ==
-			     layer_header2->clh_slid);
+		/* todo rm M0_UT_ASSERT(layer_header1->clh_slid ==
+			     layer_header2->clh_slid); */
 		M0_UT_ASSERT(layer_header1->clh_idx == layer_header2->clh_idx);
 		M0_UT_ASSERT(layer_header1->clh_extents_nr ==
 			     layer_header2->clh_extents_nr);
@@ -1340,6 +1362,13 @@ int test_layer_ops_composite(uint64_t lid,
 
 	rc = composite_layers_add(cl, txptr, layers_nr, min_extents_nr,
 				  !CONTIGUOUS_EXTENTS, layer_add_failure_test);
+	/*
+	 * todo Now that some layers are added, they call for
+	 * m0_layout_update() so as to update the primary table.
+	 */
+	if (domain->ld_is_db_available)
+		layout_update(&cl->cl_base);
+
 	if (layer_add_failure_test) {
 		M0_UT_ASSERT(rc == L_TABLE_INSERT_ERR || rc == -ENOMEM ||
 			     rc == -EINVAL || rc == L_EMAP_PASTE_ERR ||
@@ -1408,17 +1437,23 @@ int test_layer_ops_composite(uint64_t lid,
 
 	/* Now, delete the layer. */
 	rc = m0_composite_layer_delete(cl, txptr);
+	//todo Check organisation of the following
+	if (domain->ld_is_db_available) {
+		rc_tmp = m0_db_tx_commit(&tx);
+		M0_UT_ASSERT(rc_tmp == 0);
+
+		/*
+		 * todo Now that some layer is deleted, it calls for
+		 * m0_layout_update() so as to update the primary table.
+		 */
+		if (domain->ld_is_db_available)
+			layout_update(&cl->cl_base);
+	}
+
 	if (layer_del_failure_test) {
 		M0_UT_ASSERT(rc == -EINVAL || rc == L_TABLE_DEL_ERR ||
 			     rc == L_EMAP_LOOKUP_ERR ||
 			     rc == L_EMAP_OBJ_DEL_ERR);
-		//todo tx_fini()  or m0_db_tx_abort(txptr); ?
-
-		//todo Check organisation of the following
-		if (domain->ld_is_db_available) {
-			rc_tmp = m0_db_tx_commit(&tx);
-			M0_UT_ASSERT(rc_tmp == 0);
-		}
 		/* Delete the composite layout object. */
 		m0_layout_put(&cl->cl_base);
 		M0_UT_ASSERT(m0_layout_find(domain, lid) == NULL);
@@ -1431,11 +1466,6 @@ int test_layer_ops_composite(uint64_t lid,
 	}
 	M0_UT_ASSERT(rc == 0);
 
-	if (domain->ld_is_db_available) {
-		rc_tmp = m0_db_tx_commit(&tx);
-		M0_UT_ASSERT(rc_tmp == 0);
-	}
-
 	M0_ASSERT(cl->cl_layers_nr = layers_nr - 1);
 	composite_layout_verify(l, lid, layers_nr - 1, min_extents_nr,
 				!CONTIGUOUS_EXTENTS);
@@ -2127,7 +2157,8 @@ static int test_ext_delete(uint64_t lid,
 		ext.e_start = ext_to_operate.e_end - 1;
 		ext.e_end = ext_to_operate.e_end;
 		rc = m0_composite_layer_ext_state_update(cl,
-							 cl->cl_layers_nr - 1,								 &ext,
+							 cl->cl_layers_nr - 1,
+							 &ext,
 							 M0_CLRES_FLATTENING,
 							 txptr);
 		M0_UT_ASSERT(rc == 0);
@@ -2325,7 +2356,8 @@ void test_layer_ext_ops_composite_failure(uint64_t base_lid,
 	 */
 	lid = base_lid + 23;
 	m0_fi_enable_off_n_on_m("emap_iterator_set", "emap_lookup_err",
-				3 /* layers_nr */, 1);
+				//todo  3 /* layers_nr */, 1);
+				4 /* layers_nr */, 1);
 	rc = test_ext_add(lid, domain, 3, 6, CONTIGUOUS_EXTENTS,
 			  EXACT_EXISTING, //todo OVRLAPPING_RIGHT as well
 			  M0_CLRES_VALID,
@@ -2390,7 +2422,7 @@ int test_lookup_composite(uint64_t lid,
 
 	/* If existing_test is true, first add a layout object to the DB. */
 	if (existing_test) {
-		/* Build a layout object, add layers to it, add it ot the DB. */
+		/* Build a layout object, add layers to it, add it to the DB. */
 		rc = composite_build_and_layers_add(lid, domain, layers_nr,
 						    min_extents_nr,
 						    if_contiguous_extents,
@@ -2417,6 +2449,13 @@ int test_lookup_composite(uint64_t lid,
 		/* Release the reference acquired by m0_layout_lookup(). */
 		m0_layout_put(l1);
 
+		/*
+		 * todo Now that some layers are added, they call for
+		 * m0_layout_update() so as to update the primary table.
+		 */
+		if (domain->ld_is_db_available)
+			layout_update(&cl->cl_base);
+
 		/* Destroy the layout object. */
 		m0_layout_put(l1);
 	}
@@ -2576,7 +2615,8 @@ int test_update_composite(uint64_t lid,
 		rc = m0_db_tx_init(&tx, domain->ld_dbenv, DBFLAGS);
 		M0_UT_ASSERT(rc == 0);
 		pair_set(&pair, &lid, area, num_bytes);
-		rc = m0_layout_add(&cl->cl_base, &tx, &pair);
+		//todo rm rc = m0_layout_add(&cl->cl_base, &tx, &pair);
+		rc = m0_layout_add(l1, &tx, &pair);
 		M0_UT_ASSERT(rc == 0);
 		rc_tmp = m0_db_tx_commit(&tx);
 		M0_UT_ASSERT(rc_tmp == 0);
@@ -2682,7 +2722,7 @@ int test_update_composite(uint64_t lid,
 
 	M0_UT_ASSERT(rc == 0);
 
-	/* verify that the ext is updated right. */
+	/* Verify that the ext is updated right. */
 	rc = m0_db_tx_init(&tx, domain->ld_dbenv, DBFLAGS);
 	M0_UT_ASSERT(rc == 0);
 	rc = m0_composite_layer_ext_lookup(cl, ext_to_operate.e_start + 1,
@@ -2708,8 +2748,8 @@ int test_update_composite(uint64_t lid,
 	//Verify structuring of code in this fn e.g. where shud be the
 	//check for user count, extent verification  etc.
 	/*
-	 * Lookup for the layout object from the DB to verify that its
-	 * user count is indeed updated.
+	 * Lookup for the layout object from the DB to verify that it is
+	 * updated in the DB as expected.
 	 */
 	rc = layout_lookup(lid, domain, &m0_composite_layout_type,
 			   !FAILURE_TEST, &l2);
diff --git a/layout/ut/composite.h b/layout/ut/composite.h
index f9081a6..59eb8df 100644
--- a/layout/ut/composite.h
+++ b/layout/ut/composite.h
@@ -85,7 +85,7 @@ enum {
 	/* End offset for the last extent from an extent map. */
 	END_OFFSET             = M0_BINDEX_MAX + 1
 };
- 
+
 int test_build_composite(uint64_t lid,
 			 struct m0_layout_domain *domain,
 			 uint32_t min_extents_nr,
diff --git a/layout/ut/layout.c b/layout/ut/layout.c
index 2d65473..3c0e7f9 100644
--- a/layout/ut/layout.c
+++ b/layout/ut/layout.c
@@ -359,10 +359,12 @@ static void test_reg_unreg_failure(void)
 	M0_UT_ASSERT(rc == -ENOMEM);
 	confirm_nothing_is_registered(&t_domain);
 
+#if 0
 	m0_fi_enable_once("composite_register", "table_init_err");
 	rc = m0_layout_type_register(&t_domain, &m0_composite_layout_type);
 	M0_UT_ASSERT(rc == -EEXIST);
 	confirm_nothing_is_registered(&t_domain);
+#endif
 
 	m0_fi_enable_once("composite_register", "emap_init_err");
 	rc = m0_layout_type_register(&t_domain, &m0_composite_layout_type);
@@ -1127,6 +1129,8 @@ static void test_max_recsize(void)
 	m0_bcount_t             max_size_from_api;
 	m0_bcount_t             max_size_calculated;
 
+	/* todo Verify for composite layout and for all layout and enum
+	 types together. */
 	/*
 	 * A layout type can be registered with only one domain at a time.
 	 * Hence, unregister all the available layout types and enum types from
@@ -1711,7 +1715,7 @@ static void test_lookup_failure(void)
 	 */
 	lid = 19026;
 	m0_fi_enable_off_n_on_m("emap_iterator_set", "emap_lookup_err",
-				4 /* layers_nr */, 1);
+				11 /* layers_nr * 2 + 1 */, 1);
 	rc = test_lookup_composite(lid, &domain, 4, 5, CONTIGUOUS_EXTENTS,
 				   EXISTING_TEST, FAILURE_TEST);
 	M0_UT_ASSERT(rc == L_EMAP_LOOKUP_ERR);
@@ -1723,12 +1727,13 @@ static void test_lookup_failure(void)
 	 */
 	lid = 19027;
 	m0_fi_enable_off_n_on_m("emap_iterator_set", "emap_lookup_err",
-				6 /* layers_nr + 2 */, 1);
+				9 /* layers_nr + 2 */, 1);
 	rc = test_lookup_composite(lid, &domain, 4, 5, CONTIGUOUS_EXTENTS,
 				   EXISTING_TEST, FAILURE_TEST);
 	M0_UT_ASSERT(rc == L_EMAP_LOOKUP_ERR);
 	m0_fi_disable("emap_iterator_set", "emap_lookup_err");
 
+#if 0 //todo rm
 	/*
 	 * Simulate sublayout id lookup error in the path of
 	 * comp_layout_indb_read().
@@ -1740,6 +1745,7 @@ static void test_lookup_failure(void)
 				   EXISTING_TEST, FAILURE_TEST);
 	M0_UT_ASSERT(rc == L_TABLE_LOOKUP_ERR);
 	m0_fi_disable("sublayout_id_indb_lookup", "table_lookup_err");
+#endif
 
 	/* Simulate sublayout find error while reading the zeroth layer. */
 	lid = 19029;
@@ -1895,6 +1901,7 @@ static void test_add_failure(void)
 				DUPLICATE_TEST, !FAILURE_TEST);
 	M0_UT_ASSERT(rc == -EEXIST);
 
+#if 0 //todo rm
 	/*
 	 * Simulate error while adding zeroth layer to the DB as a part
 	 * of the m0_layout_add() op.
@@ -1929,7 +1936,9 @@ static void test_add_failure(void)
 				LAYOUT_DESTROY, NULL,
 				!DUPLICATE_TEST, FAILURE_TEST);
 	M0_UT_ASSERT(rc == L_TABLE_LOOKUP_ERR);
+#endif
 
+#if 0
 	/*
 	 * Simulate sublayout id lookup error while adding a non-zeroth layer
 	 * to the DB as a part of the m0_layout_add() op.
@@ -1942,6 +1951,7 @@ static void test_add_failure(void)
 				!DUPLICATE_TEST, FAILURE_TEST);
 	M0_UT_ASSERT(rc == L_TABLE_LOOKUP_ERR);
 	m0_fi_disable("sublayout_id_indb_lookup", "table_lookup_err");
+#endif
 
 	/*
 	 * Simulate extmap iterator setting error while adding a zeroth
@@ -2030,6 +2040,7 @@ static void test_update(void)
 				 EXISTING_TEST, !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
+#if 0 //todo enable
 	/*
 	 * Update a layout object with COMPOSITE layout type, that does not
 	 * exist in the DB. This results into the layout being written newly
@@ -2040,6 +2051,7 @@ static void test_update(void)
 	rc = test_update_composite(lid, &domain, 4, 15, !CONTIGUOUS_EXTENTS,
 				   !EXISTING_TEST, !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
+#endif
 
 	/* Update a layout object with COMPOSITE layout type. */
 	lid = 22022;
@@ -2074,6 +2086,7 @@ static void test_update_failure(void)
 				 EXISTING_TEST, FAILURE_TEST);
 	M0_UT_ASSERT(rc == L_TABLE_UPDATE_ERR);
 
+#if 0 //todo rm
 	/*
 	 * Simulate layout add failure in the path of m0_layout_update() for
 	 * a composite type of a layout.
@@ -2097,6 +2110,7 @@ static void test_update_failure(void)
 				   EXISTING_TEST, FAILURE_TEST);
 	M0_UT_ASSERT(rc == L_TABLE_INSERT_ERR);
 	m0_fi_disable("sublayout_id_indb_add", "table_insert_err");
+#endif
 
 	/*
 	 * Simulate emap iterator setting error during extents_indb_delete()
@@ -2303,11 +2317,14 @@ static void test_layer_ops_indb(void)
 
 static void test_layer_ops_indb_failure(void)
 {
+#if 0
 	uint64_t lid;
 	int      rc;
+#endif
 
 	domain_ldb_available_set(&domain, true);
 
+#if 0
 	//todo Incorporate these tests into m0_layout_add/delete tests
 	/* Simulate sublayout id add error while adding a layer. */
 	lid = 27001;
@@ -2318,11 +2335,13 @@ static void test_layer_ops_indb_failure(void)
 				      !LAYER_DEL_FAILURE_TEST);
 	M0_UT_ASSERT(rc == L_TABLE_INSERT_ERR);
 	m0_fi_disable("sublayout_id_indb_add", "table_insert_err");
+#endif
 
+#if 0 //todo rm we do not add layer to the DB during layer add op
 	/* Simulate emap obj insert error while adding a layer. */
 	lid = 27002;
 	m0_fi_enable_off_n_on_m("extmap_indb_add", "emap_obj_insert_err",
-				1, 1);
+				2 /* todo 1 */, 1);
 	rc = test_layer_ops_composite(lid, &domain, 5, 10,
 				      LAYER_ADD_FAILURE_TEST,
 				      !LAYER_DEL_FAILURE_TEST);
@@ -2349,7 +2368,9 @@ static void test_layer_ops_indb_failure(void)
 				      !LAYER_ADD_FAILURE_TEST,
 				      LAYER_DEL_FAILURE_TEST);
 	M0_UT_ASSERT(rc == L_EMAP_OBJ_DEL_ERR);
+#endif
 
+#if 0
 	/* Simulate sublayout id delete error while deleting a layer. */
 	lid = 27022;
 	m0_fi_enable_once("sublayout_id_indb_delete", "table_del_err");
@@ -2357,22 +2378,20 @@ static void test_layer_ops_indb_failure(void)
 				      !LAYER_ADD_FAILURE_TEST,
 				      LAYER_DEL_FAILURE_TEST);
 	M0_UT_ASSERT(rc == L_TABLE_DEL_ERR);
+#endif
 
+#if 0 //todo rm we do not add layer to the DB during layer add op
 	/*
 	 * Simulate emap iterator setting error during layer_delete_verify()
 	 * that is in the path of deleting layer - for a zeroth layer.
 	 */
 	lid = 25021;
 
-#if 0 //todo works
 	m0_fi_enable_off_n_on_m("emap_iterator_set", "emap_lookup_err",
 				12 /* todo layers_nr * extents_nr + 1 */, 1);
 	rc = test_layer_ops_composite(lid, &domain, 4, 4,
 				      !LAYER_ADD_FAILURE_TEST,
 				      LAYER_DEL_FAILURE_TEST);
-#endif
-
-#if 0 //todo works
 	m0_fi_enable_off_n_on_m("emap_iterator_set", "emap_lookup_err",
 				14 /* 14 works */ /* 15 is high */
 				/* todo layers_nr (extmap_indb_add()) +
@@ -2382,9 +2401,7 @@ static void test_layer_ops_indb_failure(void)
 	rc = test_layer_ops_composite(lid, &domain, 4, 6,
 				      !LAYER_ADD_FAILURE_TEST,
 				      LAYER_DEL_FAILURE_TEST);
-#endif
 
-#if 1 //todo works
 	m0_fi_enable_off_n_on_m("emap_iterator_set", "emap_lookup_err",
 				15 /* todo layers_nr (extmap_indb_add()) +,
 			* layers_nr (extentmap_indb_read() thr' lookup +
@@ -2395,10 +2412,9 @@ static void test_layer_ops_indb_failure(void)
 	rc = test_layer_ops_composite(lid, &domain, 4, 7,
 				      !LAYER_ADD_FAILURE_TEST,
 				      LAYER_DEL_FAILURE_TEST);
-#endif
 	M0_UT_ASSERT(rc == L_EMAP_LOOKUP_ERR);
 	m0_fi_disable("emap_iterator_set", "emap_lookup_err");
-
+#endif
 	domain_ldb_available_set(&domain, false);
 }
 
diff --git a/layout/ut/layout.h b/layout/ut/layout.h
index af1b2bf..a851eb0 100644
--- a/layout/ut/layout.h
+++ b/layout/ut/layout.h
@@ -68,6 +68,7 @@ int layout_lookup(uint64_t lid, struct m0_layout_domain *domain,
 		  const struct m0_layout_type *lt,
 		  bool failure_test,
 		  struct m0_layout **layout);
+void layout_update(struct m0_layout *l);
 
 struct ghost_data {
 	uint64_t                 lid;
diff --git a/layout/ut/layout_generic.c b/layout/ut/layout_generic.c
index d83c713..4bb1569 100644
--- a/layout/ut/layout_generic.c
+++ b/layout/ut/layout_generic.c
@@ -274,6 +274,33 @@ int layout_lookup(uint64_t lid, struct m0_layout_domain *domain,
 	return rc;
 }
 
+/* Wrapper that updates the layout to the DB. */
+void layout_update(struct m0_layout *l)
+{
+	m0_bcount_t        num_bytes;
+	void              *area;
+	struct m0_db_pair  pair;
+	struct m0_db_tx    tx;
+	int                rc_tmp;
+	int                rc;
+
+	allocate_area(l->l_dom, ADDITIONAL_BYTES_NONE, &num_bytes, &area);
+
+	rc = m0_db_tx_init(&tx, l->l_dom->ld_dbenv, DBFLAGS);
+	M0_UT_ASSERT(rc == 0);
+
+	pair_set(&pair, &l->l_id, area, num_bytes);
+
+	rc = m0_layout_update(l, &tx, &pair);
+	M0_UT_ASSERT(rc == 0);
+
+	rc_tmp = m0_db_tx_commit(&tx);
+	M0_UT_ASSERT(rc_tmp == 0);
+
+	m0_free(area);
+}
+
+
 /*
  *  Local variables:
  *  c-indentation-style: "K&R"
-- 
1.8.3.2

