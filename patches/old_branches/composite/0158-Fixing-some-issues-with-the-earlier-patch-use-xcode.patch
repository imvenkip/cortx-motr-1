From 50620a1713d4fe7d1733c5551ecda88808e33d51 Mon Sep 17 00:00:00 2001
From: "trupti.patil" <trupti_patil@xyratex.com>
Date: Tue, 23 Jul 2013 18:20:20 +0530
Subject: [PATCH 158/172] Fixing some issues with the earlier patch - use xcode

---
 layout/composite.c       |  53 ++++++-------
 layout/composite.h       |   5 +-
 layout/layout.c          |  98 ++++++------------------
 layout/layout.h          |  56 +++++---------
 layout/layout_internal.h |   2 +-
 layout/list_enum.c       |  13 +++-
 layout/list_enum.h       |   7 +-
 layout/pdclust.c         |  75 +++++++++---------
 layout/pdclust.h         |  16 +---
 layout/ut/composite.c    |  58 --------------
 layout/ut/layout.c       |  61 ++++-----------
 layout/ut/pdclust.c      | 195 +++++++++++++++++------------------------------
 12 files changed, 214 insertions(+), 425 deletions(-)

diff --git a/layout/composite.c b/layout/composite.c
index 0b33ed5..3b1ec62 100644
--- a/layout/composite.c
+++ b/layout/composite.c
@@ -270,7 +270,6 @@ static int composite_allocate(struct m0_layout_domain *dom,
 					&m0_composite_layout_type,
 				&composite_ops);
 		layers_tlist_init(&cl->cl_layers);
-		cl->cl_onwire = NULL;
 		m0_mutex_lock(&cl->cl_base.l_lock);
 		*out = &cl->cl_base;
 		M0_POST(m0_layout__allocated_invariant(&cl->cl_base));
@@ -815,8 +814,9 @@ static int copy_extents_from_onwire(struct m0_layer_onwire *lr_onwire,
 	return rc; //todo
 }
 
-//todo make this part of op vector, composite_copy_from_onwire()
-static int copy_from_onwire(struct m0_composite_layout *cl)
+//todo make this part of op vector,
+static int composite_copy_from_onwire(struct m0_composite_layout *cl,
+				      const struct m0_composite_onwire *onwire)
 {
 	struct m0_layout          *sublayout;
 	struct m0_composite_layer *lr;
@@ -826,8 +826,8 @@ static int copy_from_onwire(struct m0_composite_layout *cl)
 	uint32_t                   i;
 	int                        rc;
 
-	for (i = 0; i < cl->cl_onwire->co_layers.lra_nr; ++i) {
-		lr_onwire = &cl->cl_onwire->co_layers.lra_layer[i];
+	for (i = 0; i < onwire->co_layers.lra_nr; ++i) {
+		lr_onwire = &onwire->co_layers.lra_layer[i];
 		sublayout = layout_find(cl->cl_base.l_dom,
 					lr_onwire->lro_sublayout_id);
 		if (sublayout == NULL) {
@@ -841,7 +841,7 @@ static int copy_from_onwire(struct m0_composite_layout *cl)
 		}
 		if (i == 0) { /* Zeroth layer */
 			//todo Check if user count shall be passed this way
-			user_count = cl->cl_onwire->co_base.lo_user_count;
+			user_count = onwire->co_base.lo_user_count;
 			rc = composite_populate(cl, sublayout, user_count);
 			if (rc == 0) {
 				lr = layers_tlist_head(&cl->cl_layers);
@@ -893,13 +893,12 @@ static int composite_decode(struct m0_layout *l,
 			    uint32_t user_count)
 {
 	struct m0_composite_layout *cl;
+	struct m0_composite_onwire *onwire;
 	struct m0_xcode_ctx         ctx;
 	uint32_t                    layers_nr;
 	uint64_t                   *sl_id_list;
 	int                         rc;
 
-	M0_PRE(m0_xcode_type_invariant(m0_layout_onwire_xc));
-	M0_PRE(m0_xcode_type_invariant(m0_composite_onwire_xc));
 	M0_PRE(m0_layout__allocated_invariant(l));
 	M0_PRE(m0_mutex_is_locked(&l->l_lock));
 	M0_PRE(cur != NULL);
@@ -918,17 +917,13 @@ static int composite_decode(struct m0_layout *l,
 		rc = m0_xcode_decode(&ctx);
 		M0_ASSERT(rc == 0); //todo
 		if (rc == 0) {
-			struct m0_composite_onwire *clo_top = m0_xcode_ctx_top(
-									&ctx);
-			cl->cl_onwire = clo_top;
-
+			onwire = m0_xcode_ctx_top(&ctx);
 			//todo Copy layers info from cl_onwire to cl.
-			rc = copy_from_onwire(cl);
+			rc = composite_copy_from_onwire(cl, onwire);
 			//if (rc != 0) todo
 
-			m0_xcode_free(&COMPOSITE_XCODE_OBJ(clo_top));
+			m0_xcode_free(&COMPOSITE_XCODE_OBJ(onwire));
 		}
-		*cur = ctx.xcx_buf;
 	} else {
 		rc = sublayout_ids_read(cl, cur, &layers_nr, &sl_id_list);
 		if (rc == 0) {
@@ -949,24 +944,26 @@ static int composite_decode(struct m0_layout *l,
 }
 
 //todo make this part of op vector
-static int composite_copy_to_onwire(struct m0_composite_layout *cl)
+static int composite_copy_to_onwire(const struct m0_composite_layout *cl,
+				    struct m0_composite_onwire **cl_onwire)
 {
 	struct m0_composite_layer     *layer;
 	struct m0_composite_layer_ext *ext1;
+	struct m0_composite_onwire    *onwire;
 	struct m0_layer_onwire        *lr_onwire;
 	struct m0_layer_ext_onwire    *ext_onwire;
 	uint32_t                       i;
 
-	M0_ALLOC_PTR(cl->cl_onwire);
-	M0_ASSERT(cl->cl_onwire != NULL); //todo
+	M0_ALLOC_PTR(onwire);
+	M0_ASSERT(onwire != NULL); //todo
 
-	m0_layout__copy_to_onwire(&cl->cl_base, &cl->cl_onwire->co_base);
+	m0_layout__copy_to_onwire(&cl->cl_base, &onwire->co_base);
 
-	M0_ALLOC_ARR(cl->cl_onwire->co_layers.lra_layer, cl->cl_layers_nr);
-	M0_ASSERT(cl->cl_onwire->co_layers.lra_layer!= NULL); //todo
+	M0_ALLOC_ARR(onwire->co_layers.lra_layer, cl->cl_layers_nr);
+	M0_ASSERT(onwire->co_layers.lra_layer!= NULL); //todo
 
 	m0_tl_for(layers, &cl->cl_layers, layer) {
-		lr_onwire = &cl->cl_onwire->co_layers.lra_layer[layer->clr_idx];
+		lr_onwire = &onwire->co_layers.lra_layer[layer->clr_idx];
 		lr_onwire->lro_idx = layer->clr_idx;
 		lr_onwire->lro_sublayout_id = layer->clr_sl->l_id;
 		M0_ALLOC_ARR(lr_onwire->lro_extents.lea_ext,
@@ -982,7 +979,8 @@ static int composite_copy_to_onwire(struct m0_composite_layout *cl)
 		} m0_tl_endfor;
 		lr_onwire->lro_extents.lea_nr = layer->clr_extents_nr;
 	} m0_tl_endfor;
-	cl->cl_onwire->co_layers.lra_nr = cl->cl_layers_nr;
+	onwire->co_layers.lra_nr = cl->cl_layers_nr;
+	*cl_onwire = onwire;
 	return 0; //todo
 }
 
@@ -993,6 +991,7 @@ static int composite_encode(struct m0_layout *l,
 			    struct m0_bufvec_cursor *out)
 {
 	struct m0_composite_layout     *cl;
+	struct m0_composite_onwire     *onwire;
 	struct m0_xcode_ctx             ctx;
 	struct m0_layout_composite_rec  cl_rec;
 	m0_bcount_t                     nbytes;
@@ -1011,14 +1010,16 @@ static int composite_encode(struct m0_layout *l,
 		 (unsigned long long)l->l_id, (unsigned long)cl->cl_layers_nr,
 		 (unsigned long)op);
 	if (op == M0_LXO_BUFFER_OP) {
-		rc = composite_copy_to_onwire(cl);
+		rc = composite_copy_to_onwire(cl, &onwire);
 		M0_ASSERT(rc == 0); //todo
-		m0_xcode_ctx_init(&ctx, &COMPOSITE_XCODE_OBJ(cl->cl_onwire));
+		m0_xcode_ctx_init(&ctx, &COMPOSITE_XCODE_OBJ(onwire));
 		ctx.xcx_buf = *out;
 		rc = m0_xcode_encode(&ctx);
 		M0_ASSERT(rc == 0); //todo
-		if (rc == 0)
+		if (rc == 0) {
 			*out = ctx.xcx_buf;
+			m0_xcode_free(&COMPOSITE_XCODE_OBJ(onwire));
+		}
 	} else {
 		/*
 		 * Write the composite layout type specific part of the record
diff --git a/layout/composite.h b/layout/composite.h
index 9cb25fa..c5ade27 100644
--- a/layout/composite.h
+++ b/layout/composite.h
@@ -79,7 +79,7 @@
  */
 
 /* import */
-#include "db/extmap.h"      /* struct m0_emap */
+#include "db/extmap.h"        /* struct m0_emap */
 #include "layout/layout.h"
 #include "layout/layout_xc.h" /* struct m0_layout_onwire_xc */
 
@@ -108,9 +108,6 @@ struct m0_composite_layout {
 	/** List of the layers (struct m0_composite_layer). */
 	struct m0_tl                cl_layers;
 
-	/** Onwire representation of the composite layout. */
-	struct m0_composite_onwire *cl_onwire;
-
 	/**
 	 * @note A magic number is intentionally not embedded into this
 	 * structure and instead m0_composite_layout::cl_layers::t_magic is
diff --git a/layout/layout.c b/layout/layout.c
index ac91dbb..f558276 100644
--- a/layout/layout.c
+++ b/layout/layout.c
@@ -566,16 +566,29 @@ M0_INTERNAL void m0_layout__enum_init(struct m0_layout_domain *dom,
 }
 
 /**
- * Returns m0_xcode_type of the given xcode object.
- *
- * @note Making code of this function layout type and enum type independent
- * would require to have access to the domain pointer so as to be able to access
- * the layout type and enum type arrays from the domain for the registered
- * types. The xcode objects can not be made to store the domain pointer since
- * it will interfere with the onwire/buffer representation. Hence, similar to
- * m0_layout_standard_types_register(), this function has little knowledge of
- * the standard layout types and enum types.
+ * Finalises an enum object, releases a reference on the respective enum
+ * type.
  */
+M0_INTERNAL void m0_layout__enum_fini(struct m0_layout_enum *le)
+{
+	M0_PRE(m0_layout__enum_invariant(le));
+
+	M0_ENTRY("Enum-type-id %lu", (unsigned long)le->le_type->let_id);
+	enum_type_put(le->le_type);
+	le->le_type = NULL;
+	m0_layout_enum_bob_fini(le);
+	M0_LEAVE();
+}
+
+M0_INTERNAL void m0_layout_enum_fini(struct m0_layout_enum *le)
+{
+	M0_PRE(le != NULL);
+	M0_PRE(le->le_ops != NULL);
+	M0_PRE(le->le_ops->leo_fini != NULL);
+
+	le->le_ops->leo_fini(le);
+}
+
 M0_INTERNAL int m0_layout_enum_xc_type(const struct m0_xcode_obj *obj,
 				       const struct m0_xcode_type **out)
 {
@@ -601,30 +614,6 @@ M0_INTERNAL int m0_layout_enum_xc_type(const struct m0_xcode_obj *obj,
 }
 
 /**
- * Finalises an enum object, releases a reference on the respective enum
- * type.
- */
-M0_INTERNAL void m0_layout__enum_fini(struct m0_layout_enum *le)
-{
-	M0_PRE(m0_layout__enum_invariant(le));
-
-	M0_ENTRY("Enum-type-id %lu", (unsigned long)le->le_type->let_id);
-	enum_type_put(le->le_type);
-	le->le_type = NULL;
-	m0_layout_enum_bob_fini(le);
-	M0_LEAVE();
-}
-
-M0_INTERNAL void m0_layout_enum_fini(struct m0_layout_enum *le)
-{
-	M0_PRE(le != NULL);
-	M0_PRE(le->le_ops != NULL);
-	M0_PRE(le->le_ops->leo_fini != NULL);
-
-	le->le_ops->leo_fini(le);
-}
-
-/**
  * Compare layouts table keys.
  * This is a 3WAY comparison.
  */
@@ -1184,7 +1173,7 @@ M0_INTERNAL int m0_layout_decode(struct m0_layout *l,
 		 * status of m0_bufvec_cursor_move() here.
 		 */
 		if (M0_FI_ENABLED("attr_err"))
-			{ rec->lr_lt_id = M0_LAYOUT_TYPE_MAX + 1; }
+			{ rec->lr_lt_id = M0_LAYOUT_TYPE_MAX + 2; }
 		if (!IS_IN_ARRAY(rec->lr_lt_id, l->l_dom->ld_type)) {
 			m0_layout__log("m0_layout_decode",
 				       "Invalid layout type",
@@ -1211,47 +1200,6 @@ err1_injected:
 	return rc;
 }
 
-
-#if 0
-M0_INTERNAL int m0_layout_encode(struct m0_layout *l,
-				 enum m0_layout_xcode_op op,
-				 struct m0_db_tx *tx,
-				 struct m0_bufvec_cursor *out)
-{
-	struct m0_layout_rec  rec;
-	m0_bcount_t           nbytes;
-	int                   rc;
-
-	M0_PRE(m0_layout__invariant(l));
-	M0_PRE(m0_mutex_is_locked(&l->l_lock));
-	M0_PRE(list_lookup(l->l_dom, l->l_id) == l);
-	M0_PRE(M0_IN(op, (M0_LXO_DB_ADD, M0_LXO_DB_UPDATE,
-			  M0_LXO_DB_DELETE, M0_LXO_BUFFER_OP)));
-	M0_PRE(ergo(op != M0_LXO_BUFFER_OP, tx != NULL));
-	M0_PRE(out != NULL);
-	M0_PRE(m0_bufvec_cursor_step(out) >= sizeof rec);
-
-	M0_ENTRY("lid %llu", (unsigned long long)l->l_id);
-	rec.lr_lt_id      = l->l_type->lt_id;
-	rec.lr_user_count = l->l_user_count;
-	nbytes = m0_bufvec_cursor_copyto(out, &rec, sizeof rec);
-	M0_ASSERT(nbytes == sizeof rec);
-
-	if (M0_FI_ENABLED("lo_encode_err"))
-		{ rc = LO_ENCODE_ERR; goto err1_injected; }
-	rc = l->l_ops->lo_encode(l, op, tx, out);
-err1_injected:
-	if (rc != 0)
-		m0_layout__log("m0_layout_encode", "lo_encode() failed",
-			       M0_LAYOUT_ADDB_LOC_ENCODE, &l->l_addb_ctx,
-			       l->l_id, rc);
-
-	M0_POST(m0_mutex_is_locked(&l->l_lock));
-	M0_LEAVE("lid %llu, rc %d", (unsigned long long)l->l_id, rc);
-	return rc;
-}
-#endif
-
 M0_INTERNAL int m0_layout_encode(struct m0_layout *l,
 				 enum m0_layout_xcode_op op,
 				 struct m0_db_tx *tx,
diff --git a/layout/layout.h b/layout/layout.h
index 8d34681..3242158 100644
--- a/layout/layout.h
+++ b/layout/layout.h
@@ -158,7 +158,7 @@ enum {
 	M0_LAYOUT_ENUM_TYPE_MAX = 32
 };
 
-/**
+/** todo Move this to layout_internal.h
  * Operation on a layout record, performed through either m0_layout_decode()
  * or m0_layout_encode() routines.
  * M0_LXO_BUFFER_OP indicates that m0_layout_decode()/m0_layout_encode() has
@@ -233,32 +233,18 @@ struct m0_layout_domain {
 	struct m0_mutex             ld_lock;
 };
 
-#define LAYOUT_XCODE_OBJ(ptr) M0_XCODE_OBJ(m0_layout_onwire_xc, ptr)
+//#define LAYOUT_XCODE_OBJ(ptr) M0_XCODE_OBJ(m0_layout_onwire_xc, ptr)
 
 /**
  * Part of the in-memory layout that needs to be either 'transferred over the
  * network' or 'to be written/read to/from the DB'.
  */
 struct m0_layout_onwire {
-#if 0
-	/** Layout id. */
-	uint64_t lo_id; //todo check if req'd
-#endif
-
 	/** Layout type id. */
 	uint32_t lo_lt_id;
 
 	/** Layout user count. */
 	uint32_t lo_user_count;
-
-#if 0
-	/**
-	 * Layout type specific payload.
-	 * Contains attributes specific to the applicable layout type and/or
-	 * applicable to the enumeration type, if applicable.
-	 */
-	char     lo_data[0];
-#endif
 } M0_XCA_RECORD;
 M0_BASSERT(M0_IS_8ALIGNED(sizeof(struct m0_layout_onwire)));
 
@@ -578,23 +564,12 @@ struct m0_layout_enum_ops {
 				  struct m0_db_tx *tx,
 				  struct m0_bufvec_cursor *out);
 
-#if 0
-	/** todo */
-	int         (*leo_copy_from_onwire)(struct m0_layout_domain *domain,
-					    void *enum_onwire,
-					    struct m0_layout_enum **out);
-#endif
-
 	/** todo */
 	int         (*leo_copy_to_onwire)(const struct m0_layout_enum *le,
 					  void **enum_onwire,
 					  uint32_t *let_id);
 };
 
-/** todo */
-M0_INTERNAL int m0_layout_enum_xc_type(const struct m0_xcode_obj *obj,
-				       const struct m0_xcode_type **out);
-
 /**
  * Finalises the enum object.
  * Dual to enum type specific build procedure.
@@ -607,6 +582,20 @@ M0_INTERNAL int m0_layout_enum_xc_type(const struct m0_xcode_obj *obj,
 M0_INTERNAL void m0_layout_enum_fini(struct m0_layout_enum *le);
 
 /**
+ * Returns m0_xcode_type of the given xcode object.
+ *
+ * @note Making code of this function layout type and enum type independent
+ * would require to have access to the domain pointer so as to be able to access
+ * the layout type and enum type arrays from the domain for the registered
+ * types. The xcode objects can not be made to store the domain pointer since
+ * it will interfere with the onwire/buffer representation. Hence, similar to
+ * m0_layout_standard_types_register(), this function has little knowledge of
+ * the standard layout types and enum types.
+ */
+M0_INTERNAL int m0_layout_enum_xc_type(const struct m0_xcode_obj *obj,
+				       const struct m0_xcode_type **out);
+
+/**
  * Structure specific to a layout enumeration type.
  * There is an instance of m0_layout_enum_type for each one of enumeration
  * types. For example, for LINEAR and LIST enumeration types.
@@ -744,17 +733,10 @@ M0_INTERNAL void m0_layout_instance_fini(struct m0_layout_instance *li);
  * @note This structure needs to be maintained as 8 bytes aligned.
  */
 struct m0_layout_rec {
-//todo Use m0_layout_onwire here
-	/**
-	 * Layout type id.
-	 * Value obtained from m0_layout_type::lt_id.
-	 */
+	/** Layout type id. */
 	uint32_t  lr_lt_id;
 
-	/**
-	 * Layout user count, indicating number of users for this layout.
-	 * Value obtained from m0_layout::l_user_count.
-	 */
+	/** Layout user count, indicating number of users for this layout. */
 	uint32_t  lr_user_count;
 
 	/**
@@ -1013,7 +995,7 @@ M0_INTERNAL struct m0_layout_enum *m0_layout_to_enum(const struct m0_layout *l);
 /** Returns number of objects in the enumeration. */
 M0_INTERNAL uint32_t m0_layout_enum_nr(const struct m0_layout_enum *e);
 
-/* Returns idx-th object in the enumeration. */
+/** Returns idx-th object in the enumeration. */
 M0_INTERNAL void m0_layout_enum_get(const struct m0_layout_enum *e,
 				    uint32_t idx,
 				    const struct m0_fid *gfid,
diff --git a/layout/layout_internal.h b/layout/layout_internal.h
index 60edcb9..8bf42a8 100644
--- a/layout/layout_internal.h
+++ b/layout/layout_internal.h
@@ -190,9 +190,9 @@ M0_INTERNAL void m0_layout__copy_to_onwire(const struct m0_layout *l,
 					   struct m0_layout_onwire *onwire);
 M0_INTERNAL void m0_layout__copy_from_onwire(struct m0_layout *l,
 					const struct m0_layout_onwire *onwire);
-
 M0_INTERNAL uint32_t m0_pdclust__onwire_to_let_id(
 					const struct m0_xcode_obj *obj);
+
 M0_INTERNAL void m0_layout__standard_types_xc_init(void);
 M0_INTERNAL void m0_layout__standard_types_xc_fini(void);
 M0_INTERNAL void m0_pdclust__xc_init(void);
diff --git a/layout/list_enum.c b/layout/list_enum.c
index 04483f5..ab86db1 100644
--- a/layout/list_enum.c
+++ b/layout/list_enum.c
@@ -658,11 +658,20 @@ static int list_copy_from_onwire(struct m0_layout_domain *domain,
 {
 	struct m0_layout_list_enum_onwire *onwire = enum_onwire;
 	struct m0_layout_list_enum        *e;
+	struct m0_fid                     *cob_list;
+	uint32_t                           i;
 	int                                rc;
 
 	//todo M0_LOG() etc.
-	rc = m0_list_enum_build(domain, onwire->lleo_cobs.llca_cob,
-				onwire->lleo_cobs.llca_nr, &e);
+	M0_ALLOC_ARR(cob_list, onwire->lleo_cobs.llca_nr);
+	M0_ASSERT(cob_list != NULL); //todo Handle
+
+	for (i = 0; i < onwire->lleo_cobs.llca_nr; ++i) {
+		cob_list[i] = onwire->lleo_cobs.llca_cob[i];
+	}
+	M0_ASSERT(i == onwire->lleo_cobs.llca_nr); //todo rm
+
+	rc = m0_list_enum_build(domain, cob_list, i, &e);
 	M0_ASSERT(rc == 0); //todo handle
 	*out = &e->lle_base;
 	return rc;
diff --git a/layout/list_enum.h b/layout/list_enum.h
index 254d38d..a5d8f85 100644
--- a/layout/list_enum.h
+++ b/layout/list_enum.h
@@ -34,7 +34,7 @@
 /* import */
 #include "lib/arith.h"     /* M0_IS_8ALIGNED */
 #include "db/db.h"         /* struct m0_table */
-#include "fid/fid_xc.h"    /* struct m0_fid_xc */ //todo reqd
+#include "fid/fid_xc.h"    /* struct m0_fid_xc */
 #include "layout/layout.h"
 
 struct m0_fid;
@@ -63,7 +63,7 @@ struct m0_layout_list_enum {
 	uint64_t                lle_magic;
 };
 
-//todo
+/** Array of cobs. */
 struct m0_layout_list_cobs_array {
 	uint32_t       llca_nr;
 	struct m0_fid *llca_cob;
@@ -75,7 +75,7 @@ struct m0_layout_list_cobs_array {
  * DB'.
  */
 struct m0_layout_list_enum_onwire {
-	/** Array of layers. */
+	/** Array of cobs. */
 	struct m0_layout_list_cobs_array lleo_cobs;
 } M0_XCA_RECORD;
 M0_BASSERT(M0_IS_8ALIGNED(sizeof(struct m0_layout_list_enum_onwire)));
@@ -112,7 +112,6 @@ extern struct m0_layout_enum_type m0_list_enum_type;
 
 /** @} end group list_enum */
 
-//todo July 16 Probably not req'd
 /**
  * Following structure is part of the internal implementation. It is required to
  * be accessed by the UT as well. Hence, is placed here in the header file.
diff --git a/layout/pdclust.c b/layout/pdclust.c
index 48e2e75..69b80b3 100644
--- a/layout/pdclust.c
+++ b/layout/pdclust.c
@@ -414,16 +414,17 @@ static m0_bcount_t pdclust_max_recsize(struct m0_layout_domain *dom)
 }
 
 //todo make this part of op vector
-static int pdclust_copy_from_onwire(struct m0_pdclust_layout *pl)
+static int pdclust_copy_from_onwire(struct m0_pdclust_layout *pl,
+				    const struct m0_pdclust_onwire *onwire)
 {
 	int rc;
 
-	pl->pl_attr = pl->pl_onwire->po_attr;
+	pl->pl_attr = onwire->po_attr;
 	rc = m0_layout__striped_copy_from_onwire(&pl->pl_base,
-						 pl->pl_onwire->po_let_id,
-						 pl->pl_onwire->po_enum);
+						 onwire->po_let_id,
+						 onwire->po_enum);
 	M0_ASSERT(rc == 0); //todo Handle
-	return 0;
+	return rc;
 }
 
 /** Implementation of lo_decode() for pdclust layout type. */
@@ -434,6 +435,7 @@ static int pdclust_decode(struct m0_layout *l,
 			  uint32_t user_count)
 {
 	struct m0_pdclust_layout     *pl;
+	struct m0_pdclust_onwire     *onwire;
 	struct m0_xcode_ctx           ctx;
 	struct m0_layout_pdclust_rec *pl_rec;
 	struct m0_layout_enum_type   *et;
@@ -457,17 +459,13 @@ static int pdclust_decode(struct m0_layout *l,
 		rc = m0_xcode_decode(&ctx);
 		M0_ASSERT(rc == 0); //todo
 		if (rc == 0) {
-			struct m0_pdclust_onwire *plo_top = m0_xcode_ctx_top(
-									&ctx);
-			pl->pl_onwire = plo_top;
-
-			//Copy from onwire to pl
-			rc = pdclust_copy_from_onwire(pl);
+			onwire = m0_xcode_ctx_top(&ctx);
+			//todo Copy from onwire to pl
+			rc = pdclust_copy_from_onwire(pl, onwire);
 			M0_ASSERT(rc == 0); //todo Handle
-			//todo m0_xcode_free(&PDCLUST_XCODE_OBJ(plo_top));
 			user_count = pl->pl_base.sl_base.l_user_count;
+			m0_xcode_free(&PDCLUST_XCODE_OBJ(onwire));
 		}
-		*cur = ctx.xcx_buf; //todo check what happens if not done
 	} else {
 		//todo Move to a fn ?
 		//todo Handle the following error
@@ -480,13 +478,11 @@ static int pdclust_decode(struct m0_layout *l,
 		m0_bufvec_cursor_move(cur, sizeof *pl_rec);
 
 		if (M0_FI_ENABLED("attr_err1"))
-			{ pl_rec->pr_po.po_let_id =
-				M0_LAYOUT_ENUM_TYPE_MAX - 1; }
+			{ pl_rec->pr_let_id = M0_LAYOUT_ENUM_TYPE_MAX - 1; }
 		if (M0_FI_ENABLED("attr_err2"))
-			{ pl_rec->pr_po.po_let_id =
-				M0_LAYOUT_ENUM_TYPE_MAX + 1; }
-		et = l->l_dom->ld_enum[pl_rec->pr_po.po_let_id];
-		if (!IS_IN_ARRAY(pl_rec->pr_po.po_let_id, l->l_dom->ld_enum) ||
+			{ pl_rec->pr_let_id = M0_LAYOUT_ENUM_TYPE_MAX + 1; }
+		et = l->l_dom->ld_enum[pl_rec->pr_let_id];
+		if (!IS_IN_ARRAY(pl_rec->pr_let_id, l->l_dom->ld_enum) ||
 		    et == NULL) {
 			rc = -EPROTO;
 			M0_LOG(M0_ERROR, "lid %llu, unregistered enum type, "
@@ -509,8 +505,8 @@ static int pdclust_decode(struct m0_layout *l,
 		}
 
 		if (M0_FI_ENABLED("attr_err3"))
-			{ pl_rec->pr_po.po_attr.pa_P = 1; }
-		rc = pdclust_populate(pl, &pl_rec->pr_po.po_attr, e, user_count);
+			{ pl_rec->pr_attr.pa_P = 1; }
+		rc = pdclust_populate(pl, &pl_rec->pr_attr, e, user_count);
 		if (rc != 0) {
 			/* Finalise the populated enum object. */
 			e->le_ops->leo_fini(e);
@@ -525,21 +521,23 @@ out:
 }
 
 //todo make this part of op vector
-static int pdclust_copy_to_onwire(struct m0_pdclust_layout *pl)
+static int pdclust_copy_to_onwire(const struct m0_pdclust_layout *pl,
+				  struct m0_pdclust_onwire **pl_onwire)
 {
-	uint32_t let_id;
-	int      rc;
+	struct m0_pdclust_onwire *onwire;
+	uint32_t                  let_id;
+	int                       rc;
 
-	M0_ALLOC_PTR(pl->pl_onwire);
-	M0_ASSERT(pl->pl_onwire != NULL); //todo
+	M0_ALLOC_PTR(onwire);
+	M0_ASSERT(onwire != NULL); //todo
 
-	let_id = 0; //todo tempo rm
-	pl->pl_onwire->po_attr = pl->pl_attr;
+	onwire->po_attr = pl->pl_attr;
 	rc = m0_layout__striped_copy_to_onwire(&pl->pl_base,
-					       &pl->pl_onwire->po_base,
-					       &pl->pl_onwire->po_enum, &let_id);
+					       &onwire->po_base,
+					       &onwire->po_enum, &let_id);
 	M0_ASSERT(rc == 0); //todo handle
-	pl->pl_onwire->po_let_id = let_id;
+	onwire->po_let_id = let_id;
+	*pl_onwire = onwire;
 	return rc;
 }
 
@@ -550,6 +548,7 @@ static int pdclust_encode(struct m0_layout *l,
 		          struct m0_bufvec_cursor *out)
 {
 	struct m0_pdclust_layout     *pl;
+	struct m0_pdclust_onwire     *onwire;
 	struct m0_xcode_ctx           ctx;
 	struct m0_layout_pdclust_rec  pl_rec;
 	struct m0_layout_enum        *e;
@@ -570,17 +569,19 @@ static int pdclust_encode(struct m0_layout *l,
 	M0_ENTRY("%llu", (unsigned long long)l->l_id);
 	pl = m0_layout_to_pdl(l);
 	if (op == M0_LXO_BUFFER_OP) {
-		rc = pdclust_copy_to_onwire(pl);
+		rc = pdclust_copy_to_onwire(pl, &onwire);
 		M0_ASSERT(rc == 0); //todo
-		m0_xcode_ctx_init(&ctx, &PDCLUST_XCODE_OBJ(pl->pl_onwire));
+		m0_xcode_ctx_init(&ctx, &PDCLUST_XCODE_OBJ(onwire));
 		ctx.xcx_buf = *out;
 		rc = m0_xcode_encode(&ctx);
 		M0_ASSERT(rc == 0); //todo
-		if (rc == 0)
-			*out = ctx.xcx_buf;
+		if (rc == 0) {
+			*out = ctx.xcx_buf; //todo Is this reqd?
+			m0_xcode_free(&PDCLUST_XCODE_OBJ(onwire));
+		}
 	} else {
-		pl_rec.pr_po.po_let_id = pl->pl_base.sl_enum->le_type->let_id;
-		pl_rec.pr_po.po_attr = pl->pl_attr;
+		pl_rec.pr_let_id = pl->pl_base.sl_enum->le_type->let_id;
+		pl_rec.pr_attr = pl->pl_attr;
 
 		nbytes = m0_bufvec_cursor_copyto(out, &pl_rec, sizeof pl_rec);
 		M0_ASSERT(nbytes == sizeof pl_rec);
diff --git a/layout/pdclust.h b/layout/pdclust.h
index 235e127..d129dfd 100644
--- a/layout/pdclust.h
+++ b/layout/pdclust.h
@@ -65,9 +65,9 @@
  */
 
 /* import */
-#include "lib/arith.h" /* M0_IS_8ALIGNED */
+#include "lib/arith.h"        /* M0_IS_8ALIGNED */
 #include "sns/parity_math.h"
-#include "lib/types_xc.h" //todo What is this for?
+#include "lib/types_xc.h"     /* struct m0_uint128_xc */
 #include "layout/layout.h"
 #include "layout/layout_xc.h" /* struct m0_layout_onwire_xc */
 
@@ -129,19 +129,15 @@ M0_BASSERT(M0_IS_8ALIGNED(sizeof(struct m0_pdclust_onwire)));
  * @note This structure needs to be maintained as 8 bytes aligned.
  */
 struct m0_layout_pdclust_rec {
-	//todo
-	struct m0_pdclust_onwire pr_po;
-#if 0
 	/** Layout enumeration type id. */
 	uint32_t               pr_let_id;
-
+	/** Attributes specific to PDCLUST layout type. */
 	struct m0_pdclust_attr pr_attr;
-#endif
 	/**
          * Enumeration type specific payload.
          * Contains attributes specific to the applicable enumeration type.
          */
-        char                     pr_data[0];
+        char                   pr_data[0];
 };
 M0_BASSERT(M0_IS_8ALIGNED(sizeof(struct m0_layout_pdclust_rec)));
 
@@ -174,10 +170,6 @@ struct m0_pdclust_layout {
 	 */
 	uint32_t                   pl_L;
 
-	//todo Take out the onwire structures from the layout types and instead use them as locl variables
-	/** Onwire representation of the pdclust layout. */
-	struct m0_pdclust_onwire  *pl_onwire;
-
 	uint64_t                   pl_magic;
 };
 
diff --git a/layout/ut/composite.c b/layout/ut/composite.c
index 7db1adb..4eb0d59 100644
--- a/layout/ut/composite.c
+++ b/layout/ut/composite.c
@@ -1471,64 +1471,6 @@ int test_encode_decode_composite(uint64_t lid,
 	return rc;
 }
 
-#if 0
-/** todo */
-int test_xcode_composite(uint64_t lid,
-			 struct m0_layout_domain *domain,
-			 uint32_t layers_nr,
-			 uint32_t extents_nr,
-			 bool is_contiguous_extents,
-			 bool failure_test)
-{
-	struct m0_composite_layout *cl;
-	void                       *area;
-	m0_bcount_t                 num_bytes;
-	struct m0_bufvec            bv;
-	struct m0_bufvec_cursor     cur;
-	int                         rc;
-
-	/* Build a layout object. */
-	rc = composite_build_and_layers_add(lid, domain, layers_nr, extents_nr,
-					    is_contiguous_extents,
-					    !FAILURE_TEST,
-					    !LAYER_ADD_FAILURE_TEST, &cl);
-	M0_UT_ASSERT(rc == 0);
-
-	/* Encode the layout object into a layout buffer. */
-	m0_mutex_lock(&cl->cl_base.l_lock);
-	num_bytes = m0_layout_bufsize(&cl->cl_base);
-	area = m0_alloc(num_bytes); //todo use xcode_length()
-	bv = (struct m0_bufvec) M0_BUFVEC_INIT_BUF(&area, &num_bytes);
-	m0_bufvec_cursor_init(&cur, &bv);
-
-	rc = m0_layout_encode(&cl->cl_base, M0_LXO_BUFFER_OP, NULL, &cur);
-	m0_mutex_unlock(&cl->cl_base.l_lock);
-	if (failure_test)
-		M0_UT_ASSERT(rc == LO_ENCODE_ERR);
-	else
-		M0_UT_ASSERT(rc == 0);
-
-	/* Rewind the cursor. */
-	m0_bufvec_cursor_init(&cur, &bv);
-
-	/* Verify the layout buffer produced by m0_layout_encode(). */
-	if (!failure_test)
-		composite_layout_buf_verify(lid, domain, layers_nr, extents_nr,
-					    is_contiguous_extents, &cur);
-
-	/* Delete the composite layout object. */
-	m0_layout_put(&cl->cl_base);
-	M0_UT_ASSERT(m0_layout_find(domain, lid) == NULL);
-
-	/* Delete the precreated sublayouts. */
-	sublayouts_delete(domain, lid, layers_nr);
-
-	m0_free(area);
-	return rc;
-}
-#endif
-
-
 /** Tests the APIs supported for m0_composite_instance object. */
 int test_instance_composite(uint64_t lid, struct m0_layout_domain *domain,
 			    bool failure_test)
diff --git a/layout/ut/layout.c b/layout/ut/layout.c
index 9146902..78823af 100644
--- a/layout/ut/layout.c
+++ b/layout/ut/layout.c
@@ -685,6 +685,7 @@ static void test_decode_failure(void)
 	uint64_t lid;
 
 #if 0
+	//todo Broken functionality as of now - Is this issue to be attacked as a whole - consistency of decoded structure values. But the test needs a change - induce invalid attribute while building the buffer
 	/* Simulate invalid attributes error in m0_layout_decode(). */
 	lid = 4001;
 	m0_fi_enable_once("m0_layout_decode", "attr_err");
@@ -693,6 +694,7 @@ static void test_decode_failure(void)
 				 FAILURE_TEST);
 	M0_UT_ASSERT(rc == -EPROTO);
 
+	//todo The test needs a change - induce invalid attribute while building the buffer
 	/* Simulate invalid attributes error in pdclust_decode(). */
 	lid = 4002;
 	m0_fi_enable_once("pdclust_decode", "attr_err1");
@@ -756,9 +758,9 @@ static void test_decode_failure(void)
 				 LINEAR_ENUM_ID, INLINE_NOT_APPLICABLE,
 				 FAILURE_TEST);
 	M0_UT_ASSERT(rc == -EPROTO);
-#endif
 
-#if 0 //How can we verify these around m0_xcode_decode()
+	//Not aaplicable as is since decoded layout is not verified
+	//How can we verify these around m0_xcode_decode()
 	/*
 	 * Simulate lr_header->clh_extents_nr == 0 error in
 	 * layers_inbuf_read().
@@ -781,27 +783,9 @@ static void test_decode_failure(void)
 	M0_UT_ASSERT(rc == -EINVAL);
 #endif
 
-#if 0 //This is not anymore valid for directly invoked m0_layout_decode()
-	/*
-	 * Simulate memeory error in sublayout_ids_inbuf_read() that is in the
-	 * path of composite_decode().
-	 */
-	lid = 4023;
-	m0_fi_enable_once("sublayout_ids_inbuf_read",
-			  "alloc_arr_fail/sublayout_id_list");
-	rc = test_decode_composite(lid, &domain, 5, 6,
-				   !CONTIGUOUS_EXTENTS, FAILURE_TEST);
-	M0_UT_ASSERT(rc == -ENOMEM);
-#endif
-
-	/* todo this must not be in the path of extents_inbuf_read() now that
-	 * sublayout_ids_inbuf_read() is not in the path of m0_layout_decode()
-	 * but must be in the path of copy_from_onwire() that is invoked after
-	 * m0_xcode_decode() is performed.
-	 */
 	/*
 	 * Simulate memory allocation error in the path of
-	 * extents_inbuf_read().
+	 * copy_extents_from_onwire().
 	 */
 	lid = 4024;
 	m0_fi_enable_once("ext_add", "alloc_ptr_fail/ext");
@@ -891,7 +875,7 @@ static void test_encode(void)
 	 * layers.
 	 */
 	lid = 5021;
-	rc = test_encode_composite(lid, &domain, 3, 4, /* todo 8, 25, */
+	rc = test_encode_composite(lid, &domain, 8, 25,
 				   CONTIGUOUS_EXTENTS, !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
@@ -938,7 +922,6 @@ static void test_decode_encode(void)
 {
 	uint64_t lid;
 
-#if 0
 	/*
 	 * Build a layout buffer representing a layout with PDCLUST layout type
 	 * and LIST enum type, with a few inline entries only.
@@ -991,7 +974,6 @@ static void test_decode_encode(void)
 	rc = test_decode_encode_pdclust(lid, &domain,
 					LINEAR_ENUM_ID, INLINE_NOT_APPLICABLE);
 	M0_UT_ASSERT(rc == 0);
-#endif
 
 	/*
 	 * Build a layout buffer representing a layout with COMPOSITE layout
@@ -1026,7 +1008,6 @@ static void test_encode_decode(void)
 {
 	uint64_t lid;
 
-#if 0 //todo June 26
 	/*
 	 * Build a layout object with PDCLUST layout type and LIST enum type,
 	 * with a few inline entries only.
@@ -1078,7 +1059,6 @@ static void test_encode_decode(void)
 	rc = test_encode_decode_pdclust(lid, &domain,
 					LINEAR_ENUM_ID, INLINE_NOT_APPLICABLE);
 	M0_UT_ASSERT(rc == 0);
-#endif
 
 	/*
 	 * Build a layout object with COMPOSITE layout type, with contiguous
@@ -1471,18 +1451,6 @@ static void test_layer_ext_ops_failure(void)
 	test_layer_ext_ops_composite_failure(lid, &domain);
 }
 
-#if 0 //todo
-static void test_layout_xcode(void)
-{
-	uint64_t lid = 18001;
-
-	rc = test_xcode_composite(lid, &domain, 5, 6,
-				  !CONTIGUOUS_EXTENTS, !FAILURE_TEST);
-	M0_UT_ASSERT(rc == 0);
-	test_layer_ext_ops_composite_failure(lid, &domain);
-}
-#endif
-
 #ifndef __KERNEL__
 /** Tests the API m0_layout_lookup(). */
 static void test_lookup(void)
@@ -1551,7 +1519,6 @@ static void test_lookup(void)
 				 EXISTING_TEST, !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
-#if 0 //todo Check why is it not working
 	/*
 	 * Simulate that another layout object with the same layout id is
 	 * created while the first layout object is being allocated by
@@ -1562,7 +1529,6 @@ static void test_lookup(void)
 						     LINEAR_ENUM_ID,
 						     INLINE_NOT_APPLICABLE);
 	M0_UT_ASSERT(rc == 0);
-#endif
 
 	/*
 	 * Lookup for a layout object with COMPOSITE layout type, that does not
@@ -1724,19 +1690,18 @@ static void test_lookup_failure(void)
 	M0_UT_ASSERT(rc == -ENOMEM);
 	m0_fi_disable("layer_add_internal", "alloc_ptr_fail/layer");
 
-#if 0 //todo
 	/*
 	 * Simulate memory allocation error in the path of
 	 * extents_indb_read().
 	 */
 	lid = 19024;
 	m0_fi_enable_off_n_on_m("ext_add", "alloc_ptr_fail/ext",
-				80 /* layers_nr * extents_nr * 4 */, 1);
+				//80 /* layers_nr * extents_nr * 4 */, 1);
+				16 /* todo layers_nr * extents_nr * 4 */, 1);
 	rc = test_lookup_composite(lid, &domain, 4, 5, CONTIGUOUS_EXTENTS,
 				   EXISTING_TEST, FAILURE_TEST);
 	M0_UT_ASSERT(rc == -ENOMEM);
 	m0_fi_disable("ext_add", "alloc_ptr_fail/ext");
-#endif
 
 	/*
 	 * Simulate invalid extent state error in the path of
@@ -1782,6 +1747,13 @@ static void test_lookup_failure(void)
 	M0_UT_ASSERT(rc == -EINVAL);
 	m0_fi_disable("layout_find", "layout_find_err");
 #endif
+
+	/* Simulate sublayout read error while reading a layer. */
+	lid = 19031;
+	m0_fi_enable_once("sublayout_ids_read", "alloc_arr_fail/sl_id_list");
+	rc = test_lookup_composite(lid, &domain, 4, 5, CONTIGUOUS_EXTENTS,
+				   EXISTING_TEST, FAILURE_TEST);
+	M0_UT_ASSERT(rc == -ENOMEM);
 }
 
 /** Tests the API m0_layout_add(). */
@@ -1953,7 +1925,6 @@ static void test_update(void)
 {
 	uint64_t lid;
 
-#if 0 //todo check why not working
 	/*
 	 * Update a layout object with PDCLUST layout type, LIST enum type and
 	 * with a few inline entries only.
@@ -1990,7 +1961,6 @@ static void test_update(void)
 	rc = test_update_pdclust(lid, &domain, LINEAR_ENUM_ID,
 				 INLINE_NOT_APPLICABLE, !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
-#endif
 
 	/* Update a layout object with COMPOSITE layout type. */
 	lid = 22022;
@@ -2234,7 +2204,6 @@ const struct m0_test_suite layout_ut = {
 		{ "layout-layer-ops-failure", test_layer_ops_failure },
 		{ "layout-layer-ext-ops", test_layer_ext_ops },
 		{ "layout-layer-ext-ops-failure", test_layer_ext_ops_failure },
-		//todo rm { "layout-xcode", test_layout_xcode},
 #ifndef __KERNEL__
 		{ "layout-lookup", test_lookup },
 		{ "layout-lookup-failure", test_lookup_failure },
diff --git a/layout/ut/pdclust.c b/layout/ut/pdclust.c
index 85de922..d77be8e 100644
--- a/layout/ut/pdclust.c
+++ b/layout/ut/pdclust.c
@@ -331,7 +331,37 @@ int test_build_pdclust(uint64_t lid, struct m0_layout_domain *domain,
 	return rc;
 }
 
+#if 0 //todo
+/**
+ * Builds part of the buffer representing generic and PDCLUST layout type
+ * specific parts of the layout object.
+ */
+static void pdclust_buf_build(uint32_t let_id, uint64_t lid,
+			      uint32_t N, uint32_t K, uint32_t P,
+			      struct m0_uint128 *seed,
+			      struct m0_bufvec_cursor *dcur)
+{
+	m0_bcount_t nbytes_copied;
+	struct {
+		struct m0_pdclust_attr attr;
+		uint32_t               let_id;
+	} pd_attr;
 
+	generic_buf_build(lid, m0_pdclust_layout_type.lt_id, dcur);
+
+	pd_attr.attr.pa_N         = N;
+	pd_attr.attr.pa_K         = K;
+	pd_attr.attr.pa_P         = P;
+	pd_attr.attr.pa_unit_size = UNIT_SIZE;
+	pd_attr.attr.pa_seed      = *seed;
+	pd_attr.let_id            = let_id;
+	nbytes_copied = m0_bufvec_cursor_copyto(dcur, &pd_attr,
+						sizeof pd_attr);
+	M0_UT_ASSERT(nbytes_copied == sizeof pd_attr);
+}
+#endif
+
+#if 1
 /**
  * Builds part of the buffer representing generic and PDCLUST layout type
  * specific parts of the layout object.
@@ -341,19 +371,11 @@ static void pdclust_buf_build(uint32_t let_id, uint64_t lid,
 			      struct m0_uint128 *seed,
 			      struct m0_bufvec_cursor *dcur)
 {
-	struct m0_pdclust_attr attr;
 	m0_bcount_t            nbytes_copied;
+	struct m0_pdclust_attr attr;
 
 	generic_buf_build(lid, m0_pdclust_layout_type.lt_id, dcur);
 
-#ifndef __KERNEL__ //todo rm
-	printf("pdclust_buf_build(): N %lu, K %lu, P %lu, unit_size %llu, "
-		"seed_hi %llu, seed_lo %llu, let_id %lu", (unsigned long)N,
-		(unsigned long)K, (unsigned long)P,
-		(unsigned long long)UNIT_SIZE,
-		(unsigned long long)seed->u_hi, (unsigned long long)seed->u_lo,
-		(unsigned long)let_id);
-#endif
 	attr.pa_N         = N;
 	attr.pa_K         = K;
 	attr.pa_P         = P;
@@ -365,6 +387,7 @@ static void pdclust_buf_build(uint32_t let_id, uint64_t lid,
 	nbytes_copied = m0_bufvec_cursor_copyto(dcur, &let_id, sizeof let_id);
 	M0_UT_ASSERT(nbytes_copied == sizeof let_id);
 }
+#endif
 
 /** Builds a buffer containing serialised representation of a layout object. */
 static int pdclust_layout_buf_build(uint64_t lid, uint32_t enum_id,
@@ -512,7 +535,6 @@ static void pdclust_lbuf_verify(uint32_t N, uint32_t K, uint32_t P,
 	*let_id = *enum_type_id;
 }
 
-#if 0
 /** Verifies layout buffer against the various input arguments. */
 static void pdclust_layout_buf_verify(uint64_t lid, uint32_t enum_id,
 				      uint32_t N, uint32_t K, uint32_t P,
@@ -523,7 +545,7 @@ static void pdclust_layout_buf_verify(uint64_t lid, uint32_t enum_id,
 	uint32_t                      lt_id;
 	uint32_t                      let_id;
 	uint32_t                      i;
-	struct cob_entries_header    *ce_header;
+	uint32_t                     *nr;
 	struct m0_fid                *cob_id_from_layout;
 	struct m0_fid                 cob_id_calculated;
 	struct m0_layout_linear_attr *lin_attr;
@@ -542,80 +564,7 @@ static void pdclust_layout_buf_verify(uint64_t lid, uint32_t enum_id,
 	if (enum_id == LIST_ENUM_ID) {
 		M0_UT_ASSERT(let_id == m0_list_enum_type.let_id);
 
-		M0_UT_ASSERT(m0_bufvec_cursor_step(cur) >= sizeof *ce_header);
-
-		ce_header = m0_bufvec_cursor_addr(cur);
-		M0_UT_ASSERT(ce_header != NULL);
-		m0_bufvec_cursor_move(cur, sizeof *ce_header);
-
-		M0_UT_ASSERT(ce_header->ceh_nr == P);
-		M0_UT_ASSERT(m0_bufvec_cursor_step(cur) >=
-			     ce_header->ceh_nr * sizeof *cob_id_from_layout);
-
-		for (i = 0; i < ce_header->ceh_nr; ++i) {
-			cob_id_from_layout = m0_bufvec_cursor_addr(cur);
-			M0_UT_ASSERT(cob_id_from_layout != NULL);
-
-			m0_fid_set(&cob_id_calculated, i * 100 + 1, i + 1);
-			M0_UT_ASSERT(m0_fid_eq(cob_id_from_layout,
-					       &cob_id_calculated));
-
-			m0_bufvec_cursor_move(cur, sizeof *cob_id_from_layout);
-		}
-	} else {
-		M0_UT_ASSERT(let_id == m0_linear_enum_type.let_id);
-
-		M0_UT_ASSERT(m0_bufvec_cursor_step(cur) >= sizeof *lin_attr);
-
-		lin_attr = m0_bufvec_cursor_addr(cur);
-		M0_UT_ASSERT(lin_attr->lla_nr == P);
-		M0_UT_ASSERT(lin_attr->lla_A == A);
-		M0_UT_ASSERT(lin_attr->lla_B == B);
-	}
-}
-#endif
-
-/** Verifies layout buffer against the various input arguments. */
-static void pdclust_layout_buf_verify(uint64_t lid, uint32_t enum_id,
-				      uint32_t N, uint32_t K, uint32_t P,
-				      struct m0_uint128 *seed,
-				      uint32_t A, uint32_t B,
-				      struct m0_bufvec_cursor *cur)
-{
-	uint32_t                      lt_id;
-	uint32_t                      let_id;
-	uint32_t                      i;
-	//struct cob_entries_header    *ce_header;
-	uint32_t                     *nr; //todo indent
-	struct m0_fid                *cob_id_from_layout;
-	struct m0_fid                 cob_id_calculated;
-	struct m0_layout_linear_attr *lin_attr;
-
-	M0_UT_ASSERT(enum_id == LIST_ENUM_ID || enum_id == LINEAR_ENUM_ID);
-	M0_UT_ASSERT(cur != NULL);
-
-	/* Verify generic part of the layout buffer. */
-	lbuf_verify(cur, &lt_id);
-	M0_UT_ASSERT(lt_id == m0_pdclust_layout_type.lt_id);
-
-	/* Verify PDCLUST layout type specific part of the layout buffer. */
-	pdclust_lbuf_verify(N, K, P, seed, cur, &let_id);
-
-	/* Verify enum type specific part of the layout buffer. */
-	if (enum_id == LIST_ENUM_ID) {
-		M0_UT_ASSERT(let_id == m0_list_enum_type.let_id);
-
-		//todo rm or replace by s'thing M0_UT_ASSERT(m0_bufvec_cursor_step(cur) >= sizeof *ce_header);
-#if 0
-		nr = m0_bufvec_cursor_addr(cur);
-		M0_UT_ASSERT(nr != NULL);
-		M0_UT_ASSERT(*nr == 0);
-		m0_bufvec_cursor_move(cur, sizeof *nr);
-		nr = m0_bufvec_cursor_addr(cur);
-		M0_UT_ASSERT(nr != NULL);
-		M0_UT_ASSERT(*nr == 0);
-		m0_bufvec_cursor_move(cur, sizeof *nr);
-#endif
+		M0_UT_ASSERT(m0_bufvec_cursor_step(cur) >= sizeof *nr);
 		nr = m0_bufvec_cursor_addr(cur);
 		M0_UT_ASSERT(nr != NULL);
 		m0_bufvec_cursor_move(cur, sizeof *nr);
@@ -637,7 +586,6 @@ static void pdclust_layout_buf_verify(uint64_t lid, uint32_t enum_id,
 		M0_UT_ASSERT(let_id == m0_linear_enum_type.let_id);
 
 		M0_UT_ASSERT(m0_bufvec_cursor_step(cur) >= sizeof *lin_attr);
-
 		lin_attr = m0_bufvec_cursor_addr(cur);
 		M0_UT_ASSERT(lin_attr->lla_nr == P);
 		M0_UT_ASSERT(lin_attr->lla_A == A);
@@ -645,7 +593,6 @@ static void pdclust_layout_buf_verify(uint64_t lid, uint32_t enum_id,
 	}
 }
 
-
 /** Tests the API m0_layout_encode() for PDCLUST layout type. */
 int test_encode_pdclust(uint64_t lid, struct m0_layout_domain *domain,
 			uint32_t enum_id, uint32_t inline_test,
@@ -710,28 +657,32 @@ int test_encode_pdclust(uint64_t lid, struct m0_layout_domain *domain,
 static void pdclust_lbuf_compare(struct m0_bufvec_cursor *cur1,
 				 struct m0_bufvec_cursor *cur2)
 {
-	struct m0_layout_pdclust_rec *pl_rec1;
-	struct m0_layout_pdclust_rec *pl_rec2;
-
-	M0_UT_ASSERT(m0_bufvec_cursor_step(cur1) >= sizeof *pl_rec1);
-	M0_UT_ASSERT(m0_bufvec_cursor_step(cur2) >= sizeof *pl_rec2);
-
-	pl_rec1 = m0_bufvec_cursor_addr(cur1);
-	pl_rec2 = m0_bufvec_cursor_addr(cur2);
-
-	M0_UT_ASSERT(pl_rec1->pr_po.po_attr.pa_N ==
-		     pl_rec2->pr_po.po_attr.pa_N);
-	M0_UT_ASSERT(pl_rec1->pr_po.po_attr.pa_K ==
-		     pl_rec2->pr_po.po_attr.pa_K);
-	M0_UT_ASSERT(pl_rec1->pr_po.po_attr.pa_P ==
-		     pl_rec2->pr_po.po_attr.pa_P);
-	M0_UT_ASSERT(m0_uint128_eq(&pl_rec1->pr_po.po_attr.pa_seed,
-				   &pl_rec2->pr_po.po_attr.pa_seed));
-	M0_UT_ASSERT(pl_rec1->pr_po.po_attr.pa_unit_size ==
-		     pl_rec2->pr_po.po_attr.pa_unit_size);
-
-	m0_bufvec_cursor_move(cur1, sizeof *pl_rec1);
-	m0_bufvec_cursor_move(cur2, sizeof *pl_rec2);
+	struct m0_pdclust_attr *attr1;
+	struct m0_pdclust_attr *attr2;
+	uint32_t               *let_id1;
+	uint32_t               *let_id2;
+
+	M0_UT_ASSERT(m0_bufvec_cursor_step(cur1) >= sizeof *attr1);
+	M0_UT_ASSERT(m0_bufvec_cursor_step(cur2) >= sizeof *attr2);
+
+	attr1 = m0_bufvec_cursor_addr(cur1);
+	attr2 = m0_bufvec_cursor_addr(cur2);
+
+	M0_UT_ASSERT(attr1->pa_N == attr2->pa_N);
+	M0_UT_ASSERT(attr1->pa_K == attr2->pa_K);
+	M0_UT_ASSERT(attr1->pa_P == attr2->pa_P);
+	M0_UT_ASSERT(m0_uint128_eq(&attr1->pa_seed, &attr2->pa_seed));
+	M0_UT_ASSERT(attr1->pa_unit_size == attr2->pa_unit_size);
+
+	m0_bufvec_cursor_move(cur1, sizeof *attr1);
+	m0_bufvec_cursor_move(cur2, sizeof *attr2);
+
+	let_id1 = m0_bufvec_cursor_addr(cur1);
+	let_id2 = m0_bufvec_cursor_addr(cur2);
+	M0_UT_ASSERT(*let_id1 == *let_id2);
+
+	m0_bufvec_cursor_move(cur1, sizeof *let_id1);
+	m0_bufvec_cursor_move(cur2, sizeof *let_id2);
 }
 
 /** Compares two layout buffers provided as input arguments. */
@@ -739,8 +690,8 @@ static void pdclust_layout_buf_compare(uint32_t enum_id,
 				       struct m0_bufvec_cursor *cur1,
 				       struct m0_bufvec_cursor *cur2)
 {
-	struct cob_entries_header    *ce_header1;
-	struct cob_entries_header    *ce_header2;
+	uint32_t                     *nr1;
+	uint32_t                     *nr2;
 	struct m0_fid                *cob_id1;
 	struct m0_fid                *cob_id2;
 	struct m0_layout_linear_attr *lin_attr1;
@@ -759,23 +710,21 @@ static void pdclust_layout_buf_compare(uint32_t enum_id,
 
 	/* Compare enumeration type specific part of the layout buffers. */
 	if (enum_id == LIST_ENUM_ID) {
-		M0_UT_ASSERT(m0_bufvec_cursor_step(cur1) >= sizeof *ce_header1);
-		M0_UT_ASSERT(m0_bufvec_cursor_step(cur2) >= sizeof *ce_header2);
-
-		ce_header1 = m0_bufvec_cursor_addr(cur1);
-		ce_header2 = m0_bufvec_cursor_addr(cur2);
-
-		m0_bufvec_cursor_move(cur1, sizeof *ce_header1);
-		m0_bufvec_cursor_move(cur2, sizeof *ce_header2);
+		M0_UT_ASSERT(m0_bufvec_cursor_step(cur1) >= sizeof *nr1);
+		M0_UT_ASSERT(m0_bufvec_cursor_step(cur2) >= sizeof *nr2);
 
-		M0_UT_ASSERT(ce_header1->ceh_nr == ce_header2->ceh_nr);
+		nr1 = m0_bufvec_cursor_addr(cur1);
+		nr2 = m0_bufvec_cursor_addr(cur2);
+		M0_UT_ASSERT(*nr1 == *nr2);
+		m0_bufvec_cursor_move(cur1, sizeof *nr1);
+		m0_bufvec_cursor_move(cur2, sizeof *nr2);
 
 		M0_UT_ASSERT(m0_bufvec_cursor_step(cur1) >=
-			     ce_header1->ceh_nr * sizeof *cob_id1);
+			     *nr1 * sizeof *cob_id1);
 		M0_UT_ASSERT(m0_bufvec_cursor_step(cur2) >=
-			     ce_header2->ceh_nr * sizeof *cob_id2);
+			     *nr2 * sizeof *cob_id2);
 
-		for (i = 0; i < ce_header1->ceh_nr; ++i) {
+		for (i = 0; i < *nr1; ++i) {
 			cob_id1 = m0_bufvec_cursor_addr(cur1);
 			cob_id2 = m0_bufvec_cursor_addr(cur2);
 
-- 
1.8.3.2

