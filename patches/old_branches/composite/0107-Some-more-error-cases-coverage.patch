From 14dceef6f1bc7323ac4daf3d0923d17ba3cab677 Mon Sep 17 00:00:00 2001
From: "trupti.patil" <trupti_patil@xyratex.com>
Date: Tue, 2 Apr 2013 18:32:08 +0530
Subject: [PATCH 107/172] Some more error cases coverage

---
 layout/composite.c       | 43 ++++++++++++++++++++-------
 layout/layout_internal.h | 16 ++++++++--
 layout/ut/composite.c    | 76 +++++++++++++++++++++++++++++++++++++++++-------
 layout/ut/layout.c       | 32 ++++++++++++++++++++
 4 files changed, 144 insertions(+), 23 deletions(-)

diff --git a/layout/composite.c b/layout/composite.c
index a01494c..a65a6d3 100644
--- a/layout/composite.c
+++ b/layout/composite.c
@@ -1399,16 +1399,21 @@ M0_INTERNAL int m0_composite_layer_ext_lookup(struct m0_composite_layout *cl,
 	M0_ENTRY("lid %llu, offset %llu", (unsigned long long)cl->cl_base.l_id,
 		 (unsigned long long)offset);
 	m0_mutex_lock(&cl->cl_base.l_lock);
+
+	if (M0_FI_ENABLED("ext_inmem_lookup_err"))
+		{ rc = L_EXT_INMEM_LOOKUP_ERR; goto err1_injected; }
 	rc = ext_inmem_lookup(cl, offset, ext,
 			      layer_idx, ext_state, sublayout);
+err1_injected:
 	if (rc != 0 && cl->cl_base.l_dom->ld_is_db_available) {
 		/*
-		 * In the current implemetation, the in-memory layout is
+		 * In the current implementation, the in-memory layout is
 		 * always necessarily up-to-date. Hence, it is not possible
 		 * to hit this exception that 'the offset is not found in the
 		 * in-memory layout and can be found in the in-DB layout'. It
 		 * will be required when a network request is supported to
-		 * fetch partial composite layout due to its large size.
+		 * fetch partial composite layout due to its possibly large
+		 * size.
 		 */
 		M0_LOG(M0_DEBUG, "lid %llu, offset %llu, rc %d, Offset not "
 		       "found in the in-memory layout. Looking up into the DB.",
@@ -2140,6 +2145,8 @@ static int ext_indb_write_internal(struct m0_emap_cursor *it,
 	 */
 
 	rc_cb = 0;
+	if (M0_FI_ENABLED("emap_paste_err"))
+		{ rc = L_EMAP_PASTE_ERR; goto err1_injected; }
 	rc = m0_emap_paste(it, &ext0, new_ext_state,
 		LAMBDA(void, (struct m0_emap_seg *seg) {
 			/* Extent deletion. */
@@ -2163,7 +2170,7 @@ static int ext_indb_write_internal(struct m0_emap_cursor *it,
 								  CUT_RIGHT,
 								  seg, extent);
 		}));
-
+err1_injected:
 	if (rc != 0)
 		m0_layout__log("ext_indb_write",
 			       "failed to paste an extent into emap",
@@ -2781,6 +2788,8 @@ static int layer_delete_verify(struct m0_composite_layout *cl,
 	M0_ENTRY("lid %llu, layer %lu", (unsigned long long)cl->cl_base.l_id,
 		 (unsigned long)layer->clr_idx);
 
+	if (M0_FI_ENABLED("layer_with_valid_ext_err")) { goto err1_injected; }
+
 	/* In-memory layer verification. */
 	m0_tl_for(m0_composite_layer_ext, &layer->clr_extents, lr_ext) {
 		if (lr_ext->cle_state != M0_CLRES_INVALID) {
@@ -2798,6 +2807,19 @@ static int layer_delete_verify(struct m0_composite_layout *cl,
 		}
 	} m0_tl_endfor;
 
+	/*
+	 * In the current implementation, the in-memory layout is always
+	 * necessarily up-to-date. Hence, it is not possible to hit the
+	 * exception that 'the in-memory layer does not contain any valid
+	 * extents but the in-db layer does.
+	 * In future, a network request will be supported to fetch partial
+	 * composite layout due to its possibly large size. If it is planned
+	 * that in any case, a layer is fetched as a whole or not, then this
+	 * exception will not be hit even in the future. In that case, the
+	 * condition "if (seg->ee_val != M0_CLRES_INVALID)" below shall not
+	 * be handled but instead shall be converted into an assert.
+	 */
+err1_injected:
 	rc = 0;
 	/* In-DB layer verification. */
 	if (cl->cl_base.l_dom->ld_is_db_available) {
@@ -2885,13 +2907,14 @@ static int extents_indb_delete(struct m0_composite_layout *cl,
 		m0_emap_next(&it);
 		seg = m0_emap_seg_get(&it);
 	}
-	M0_ASSERT(seg->ee_ext.e_end == M0_BINDEX_MAX + 1);
-
-	/*
-	 * Combine all the invalid extents into one, by adding an invalid
-	 * extent with the complete offset space.
-	 */
-	rc = single_ext_indb_write(&it, layer);
+	if (rc == 0) {
+		M0_ASSERT(seg->ee_ext.e_end == M0_BINDEX_MAX + 1);
+		/*
+		 * Combine all the invalid extents into one, by adding an
+		 * invalid extent with the complete offset space.
+		 */
+		rc = single_ext_indb_write(&it, layer);
+	}
 	m0_emap_close(&it);
 	M0_RETURN(rc);
 }
diff --git a/layout/layout_internal.h b/layout/layout_internal.h
index cffe285..6b8ec98 100644
--- a/layout/layout_internal.h
+++ b/layout/layout_internal.h
@@ -119,16 +119,28 @@ enum {
 	L_EMAP_LOOKUP_ERR          = -510,
 
 	/**
+	 * Simulation for m0_emap_paste() facing error e.g. while
+	 * adding a layer to a composite type of a layout.
+	 */
+	L_EMAP_PASTE_ERR           = -511,
+
+	/**
 	 * Simulation for m0_emap_obj_insert() facing error e.g. while
 	 * adding a layer to a composite type of a layout.
 	 */
-	L_EMAP_OBJ_INSERT_ERR      = -511,
+	L_EMAP_OBJ_INSERT_ERR      = -512,
 
 	/**
 	 * Simulation for m0_emap_obj_delete() facing error e.g. while
 	 * deleting a layer from a composite type of a layout.
 	 */
-	L_EMAP_OBJ_DEL_ERR         = -512
+	L_EMAP_OBJ_DEL_ERR         = -513,
+
+	/**
+	 * Simulation of a valid ext not being found in memory so as to enforce
+	 * ext lokup into the the DB.
+	 */
+	L_EXT_INMEM_LOOKUP_ERR     = -514
 };
 
 /** ADDB context for the layout module. */
diff --git a/layout/ut/composite.c b/layout/ut/composite.c
index fca8e28..1260eb9 100644
--- a/layout/ut/composite.c
+++ b/layout/ut/composite.c
@@ -438,6 +438,7 @@ static int composite_layers_add(struct m0_composite_layout *cl,
 		if (layer_add_failure_test) {
 			M0_UT_ASSERT(rc == L_TABLE_INSERT_ERR ||
 				     rc == -ENOMEM || rc == -EINVAL ||
+				     rc == L_EMAP_PASTE_ERR ||
 				     rc == L_EMAP_OBJ_INSERT_ERR);
 			M0_UT_ASSERT(cl->cl_layers_nr == i);
 			extentlist_free(&extents);
@@ -1362,7 +1363,8 @@ int test_layer_ops_composite(uint64_t lid,
 				  !CONTIGUOUS_EXTENTS, layer_add_failure_test);
 	if (layer_add_failure_test) {
 		M0_UT_ASSERT(rc == L_TABLE_INSERT_ERR || rc == -ENOMEM ||
-			     rc == -EINVAL || rc == L_EMAP_OBJ_INSERT_ERR);
+			     rc == -EINVAL || rc == L_EMAP_PASTE_ERR ||
+			     rc == L_EMAP_OBJ_INSERT_ERR);
 		//todo tx_fini()  or m0_db_tx_abort(txptr); ?
 		//todo Check organisation of the following
 		if (domain->ld_is_db_available) {
@@ -1668,11 +1670,25 @@ static int ext_op_pre(enum extent_operation eop,
 					       ext_state_lookup,
 					       &sublayout_lookup);
 	//todo Check if the following cond shud be based on failure_test
+#if 1
 	if (extent_kind == NON_EXISTING || (extent_kind == OVERLAPPING_LEFT &&
-					    !if_contiguous_extents)) {
-		M0_UT_ASSERT(rc_tmp == -ENOENT);
+	    !if_contiguous_extents)) {
+		//todo check if the later cond below is reqd
+		M0_UT_ASSERT(rc_tmp == -ENOENT || rc_tmp == L_EMAP_LOOKUP_ERR);
+		if (eop == EXTENT_LOOKUP)
+			rc = rc_tmp;
+	} else if (failure_test && eop == EXTENT_LOOKUP) {
+		M0_UT_ASSERT(rc_tmp == L_EXT_INMEM_LOOKUP_ERR);
+		rc = rc_tmp;
+#endif
+#if 0
+	if (failure_test) {
+		M0_UT_ASSERT(rc_tmp == -ENOENT ||
+			     rc_tmp == L_EMAP_LOOKUP_ERR ||
+			     rc_tmp == L_EXT_INMEM_LOOKUP_ERR);
 		if (eop == EXTENT_LOOKUP)
 			rc = rc_tmp;
+#endif
 	} else {
 		M0_UT_ASSERT(rc_tmp == 0);
 		M0_UT_ASSERT(layer_id_lookup == (*cl)->cl_layers_nr - 1);
@@ -1973,7 +1989,8 @@ static int test_ext_lookup(uint64_t lid,
 			failure_test, &cl, &ext_to_operate, &offset_to_operate,
 			&ext_state_lookup, &l_copy_orig);
 	if (failure_test)
-		M0_UT_ASSERT(rc == -ENOENT);
+		M0_UT_ASSERT(rc == -ENOENT || rc == L_EXT_INMEM_LOOKUP_ERR ||
+			     rc == L_EMAP_LOOKUP_ERR);
 	else
 		M0_UT_ASSERT(rc == 0);
 
@@ -2218,6 +2235,8 @@ void test_layer_ext_ops_composite(uint64_t base_lid,
 {
 	int rc;
 
+	//todo base_lid usage, make it consistent with the failure case
+
 	/* Test cases for extent lookup. */
 	rc = ext_ops(base_lid, domain, EXTENT_LOOKUP);
 	M0_UT_ASSERT(rc == 0);
@@ -2247,10 +2266,40 @@ void test_layer_ext_ops_composite(uint64_t base_lid,
 	M0_UT_ASSERT(rc == 0);
 }
 
-void test_layer_ext_ops_composite_failure(uint64_t lid,
+void test_layer_ext_ops_composite_failure(uint64_t base_lid,
 					  struct m0_layout_domain *domain)
 {
-	int rc;
+	uint64_t lid;
+	int      rc;
+
+	/*
+	 * Simulate a situation that a valid extent with the given offset is
+	 * not found in the memory but is found in the DB.
+	 */
+	lid = base_lid;
+	m0_fi_enable_once("m0_composite_layer_ext_lookup",
+			  "ext_inmem_lookup_err");
+	rc = test_ext_lookup(lid, domain, 3, 4,
+			     CONTIGUOUS_EXTENTS, EXACT_EXISTING,
+			     domain->ld_is_db_available ?
+				!FAILURE_TEST : FAILURE_TEST);
+	M0_ASSERT(ergo(domain->ld_is_db_available, rc == 0));
+	M0_ASSERT(ergo(!domain->ld_is_db_available,
+		       rc == L_EXT_INMEM_LOOKUP_ERR));
+
+	/*
+	 * Simulate a situation that a valid extent with the given offset is
+	 * not found in the memory and while attempting to look into the DB,
+	 * emap lookup error is encountered.
+	 */
+	lid = base_lid + 1;
+	m0_fi_enable_off_n_on_m("emap_iterator_set", "emap_lookup_err",
+				5 /* todo layers_nr */, 1);
+	rc = test_ext_lookup(lid, domain, 3, 4,
+			     !CONTIGUOUS_EXTENTS, NON_EXISTING, FAILURE_TEST);
+	M0_ASSERT(ergo(domain->ld_is_db_available, rc == L_EMAP_LOOKUP_ERR));
+	M0_ASSERT(ergo(!domain->ld_is_db_available, rc == -ENOENT));
+	m0_fi_disable("emap_iterator_set", "emap_lookup_err");
 
 	//todo Make ext_ops() accept state so that all extent_kinds can be tested for such failure
 	/*
@@ -2258,13 +2307,15 @@ void test_layer_ext_ops_composite_failure(uint64_t lid,
 	 * the M0_CLRES_FLATTENING state that overlaps with an existing extent
 	 * with the M0_CLRES_VALID state.
 	 */
+	lid = base_lid + 21;
 	rc = test_ext_add(lid, domain, 2, 6, CONTIGUOUS_EXTENTS, EXACT_EXISTING,
 			  M0_CLRES_FLATTENING, FAILURE_TEST);
 	M0_ASSERT(rc == -EINVAL);
 
 	/* Simulate memory allocation error in the path of ext_inmem_add(). */
+	lid = base_lid + 22;
 	m0_fi_enable_once("ext_inmem_add_internal", "mem_err");
-	rc = test_ext_add(lid + 1, domain, 3, 6,
+	rc = test_ext_add(lid, domain, 3, 6,
 			  !CONTIGUOUS_EXTENTS, OVERLAPPING_LEFT,
 			  M0_CLRES_VALID, FAILURE_TEST);
 	M0_ASSERT(rc == -ENOMEM);
@@ -2273,9 +2324,10 @@ void test_layer_ext_ops_composite_failure(uint64_t lid,
 	 * Simulate extmap iterator setting error while trying to add an
 	 * extent.
 	 */
+	lid = base_lid + 23;
 	m0_fi_enable_off_n_on_m("emap_iterator_set", "emap_lookup_err",
 				3 /* layers_nr */, 1);
-	rc = test_ext_add(lid + 2, domain, 3, 6, CONTIGUOUS_EXTENTS,
+	rc = test_ext_add(lid, domain, 3, 6, CONTIGUOUS_EXTENTS,
 			  EXACT_EXISTING, //todo OVRLAPPING_RIGHT as well
 			  M0_CLRES_VALID,
 			  domain->ld_is_db_available ?
@@ -2290,7 +2342,8 @@ void test_layer_ext_ops_composite_failure(uint64_t lid,
 	 * two existing extents - one with the M0_CLRES_INVALID state and the
 	 * other with M0_CLRES_VALID state..
 	 */
-	rc = test_ext_state_update(lid + 21, domain, 3, 6, !CONTIGUOUS_EXTENTS,
+	lid = base_lid + 41;
+	rc = test_ext_state_update(lid, domain, 3, 6, !CONTIGUOUS_EXTENTS,
 				   OVERLAPPING_LEFT, M0_CLRES_FLATTENING,
 				   FAILURE_TEST);
 	M0_ASSERT(rc == -EINVAL);
@@ -2300,8 +2353,9 @@ void test_layer_ext_ops_composite_failure(uint64_t lid,
 	 * that overlaps with multiple extents while at least two of those are
 	 * with two different states other than M0_CLRES_INVALID.
 	 */
+	lid = base_lid + 61;
 	m0_fi_enable_once("test_ext_delete", "ext_del_validation_err");
-	rc = test_ext_delete(lid + 41, domain, 2, 6, !CONTIGUOUS_EXTENTS,
+	rc = test_ext_delete(lid, domain, 2, 6, !CONTIGUOUS_EXTENTS,
 			     OVERLAPPING_COMPLETE, FAILURE_TEST);
 	M0_ASSERT(rc == -EINVAL);
 }
@@ -2600,7 +2654,7 @@ int test_update_composite(uint64_t lid,
 	if (failure_test) {
 		M0_UT_ASSERT(rc == LO_ENCODE_ERR || rc == L_TABLE_UPDATE_ERR ||
 			     rc == L_TABLE_INSERT_ERR ||
-			     rc == L_EMAP_LOOKUP_ERR);
+			     rc == L_EMAP_LOOKUP_ERR || rc == L_EMAP_PASTE_ERR);
 
 		/*
 		 * todo In this case, verify that the update op has not altered
diff --git a/layout/ut/layout.c b/layout/ut/layout.c
index 083b50a..b9632d5 100644
--- a/layout/ut/layout.c
+++ b/layout/ut/layout.c
@@ -1402,6 +1402,19 @@ static void test_layer_ops_inmem_failure(void)
 				      !LAYER_ADD_FAILURE_TEST,
 				      LAYER_DEL_FAILURE_TEST);
 	M0_UT_ASSERT(rc == -EINVAL);
+
+	/*
+	 * Try to delete a layer with having some valid extents associated with
+	 * it. But this time, invoke the in-DB layer verification.
+	 * The error case fo in-memory layer verification is tested directly
+	 * through test_layer_ops_composite().
+	 */
+	lid = 15022;
+	m0_fi_enable_once("layer_delete_verify", "layer_with_valid_ext_err");
+	rc = test_layer_ops_composite(lid, &domain, 1, 5,
+				      !LAYER_ADD_FAILURE_TEST,
+				      LAYER_DEL_FAILURE_TEST);
+	M0_UT_ASSERT(rc == -EINVAL);
 }
 
 static void test_layer_ext_ops_inmem(void)
@@ -2095,6 +2108,15 @@ static void test_update_failure(void)
 	M0_UT_ASSERT(rc == L_EMAP_LOOKUP_ERR);
 	m0_fi_disable("emap_iterator_set", "emap_lookup_err");
 
+	/* Simulate emap paste error while adding a non-zeroth layer. */
+	lid = 23006;
+	m0_fi_enable_off_n_on_m("ext_indb_write_internal", "emap_paste_err",
+				16 /* layer_nr * extents_nr + 1 */, 1);
+	rc = test_update_composite(lid, &domain, 3, 5, !CONTIGUOUS_EXTENTS,
+				   EXISTING_TEST, FAILURE_TEST);
+	M0_UT_ASSERT(rc == L_EMAP_PASTE_ERR);
+	m0_fi_disable("ext_indb_write_internal", "emap_paste_err");
+
 	domain_ldb_available_set(&domain, false);
 }
 
@@ -2304,6 +2326,16 @@ static void test_layer_ops_indb_failure(void)
 	M0_UT_ASSERT(rc == L_EMAP_OBJ_INSERT_ERR);
 	m0_fi_disable("extmap_indb_add", "emap_obj_insert_err");
 
+	/* Simulate emap paste error while adding a non-zeroth layer. */
+	lid = 27003;
+	m0_fi_enable_off_n_on_m("ext_indb_write_internal", "emap_paste_err",
+				5 /* extents_nr */, 1);
+	rc = test_layer_ops_composite(lid, &domain, 3, 4,
+				      LAYER_ADD_FAILURE_TEST,
+				      !LAYER_DEL_FAILURE_TEST);
+	M0_UT_ASSERT(rc == L_EMAP_PASTE_ERR);
+	m0_fi_disable("ext_indb_write_internal", "emap_paste_err");
+
 	/* todo Following errors are happening for the zeroth layers. Make
 	 * sure they are covered for the non-zeroth and the somewhat last
 	 * layer. */
-- 
1.8.3.2

