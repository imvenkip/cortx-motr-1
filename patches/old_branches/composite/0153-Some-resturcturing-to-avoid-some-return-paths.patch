From d96415c5450e928e30a54f82c9e7513ad254e04a Mon Sep 17 00:00:00 2001
From: "trupti.patil" <trupti_patil@xyratex.com>
Date: Fri, 14 Jun 2013 18:53:10 +0530
Subject: [PATCH 153/172] Some resturcturing to avoid some return paths

---
 layout/composite.c          | 379 +++++++++++++++++++++-----------------------
 layout/composite_internal.h |  11 ++
 layout/layout_internal.h    |   9 --
 layout/ut/layout.c          |  10 +-
 4 files changed, 201 insertions(+), 208 deletions(-)

diff --git a/layout/composite.c b/layout/composite.c
index 4d64b87..f40bb14 100644
--- a/layout/composite.c
+++ b/layout/composite.c
@@ -123,9 +123,9 @@ enum {
  * Structure used to store extents preallocated during ext_paste() operation.
  */
 struct preallocated_extents {
-		struct m0_composite_layer_extent *ext[PREALLOCATE_NR];
-		bool                              is_used[PREALLOCATE_NR];
-		uint32_t                          max_used;
+	struct m0_composite_layer_extent *ext[PREALLOCATE_NR];
+	bool                              is_used[PREALLOCATE_NR];
+	uint32_t                          max_used;
 };
 
 /**
@@ -197,27 +197,28 @@ static int composite_register(struct m0_layout_domain *dom,
 
 	M0_ENTRY("Layout_type_id %lu", (unsigned long)lt->lt_id);
 	M0_ALLOC_PTR(csd);
-	if (csd == NULL) {
+	if (csd != NULL) {
+		if (M0_FI_ENABLED("emap_init_err"))
+			{ rc = -EEXIST; goto err_injected; }
+		rc = m0_emap_init(&csd->csd_layer_emap, dom->ld_dbenv,
+				 "layer_emap");
+err_injected:
+		if (rc == 0)
+			dom->ld_type_data[lt->lt_id] = csd;
+		else {
+			m0_layout__log("composite_register",
+				       "failed to initialise layer_emap",
+				       M0_LAYOUT_ADDB_LOC_COMP_REG_2, NULL,
+				       LID_NONE, rc);
+			m0_free(csd);
+		}
+	} else {
+		rc = -ENOMEM;
 		m0_layout__log("composite_register",
 			       "failed to allocate schema data",
 			       M0_LAYOUT_ADDB_LOC_COMP_REG_1, NULL, LID_NONE,
-			       -ENOMEM);
-		return -ENOMEM;
-	}
-
-	if (M0_FI_ENABLED("emap_init_err"))
-		{ rc = -EEXIST; goto err3_injected; }
-	rc = m0_emap_init(&csd->csd_layer_emap, dom->ld_dbenv, "layer_emap");
-err3_injected:
-	if (rc != 0) {
-		m0_layout__log("composite_register",
-			       "failed to initialise layer_emap",
-			       M0_LAYOUT_ADDB_LOC_COMP_REG_2, NULL, LID_NONE,
 			       rc);
-		m0_free(csd);
-		return rc;
 	}
-	dom->ld_type_data[lt->lt_id] = csd;
 	M0_RETURN(rc);
 }
 
@@ -252,24 +253,24 @@ static int composite_allocate(struct m0_layout_domain *dom,
 
 	M0_ENTRY("lid %llu", (unsigned long long)lid);
 	M0_ALLOC_PTR(cl);
-	if (cl == NULL) {
+	if (cl != NULL) {
+		m0_layout__init(&cl->cl_base, dom, lid,
+				(struct m0_layout_type *)
+					&m0_composite_layout_type,
+				&composite_ops);
+		layers_tlist_init(&cl->cl_layers);
+		m0_mutex_lock(&cl->cl_base.l_lock);
+		*out = &cl->cl_base;
+		M0_POST(m0_layout__allocated_invariant(&cl->cl_base));
+		M0_POST(cl->cl_layers_nr == 0);
+		M0_RETURN(0);
+	} else {
 		m0_layout__log("composite_allocate",
 			       "failed to allocate composite layout",
 			       M0_LAYOUT_ADDB_LOC_COMP_ALLOC, NULL, lid,
 			      -ENOMEM);
-		return -ENOMEM;
+		M0_RETURN(-ENOMEM);
 	}
-
-	m0_layout__init(&cl->cl_base, dom, lid,
-			(struct m0_layout_type *)&m0_composite_layout_type,
-			&composite_ops);
-	layers_tlist_init(&cl->cl_layers);
-	m0_mutex_lock(&cl->cl_base.l_lock);
-
-	*out = &cl->cl_base;
-	M0_POST(m0_layout__allocated_invariant(&cl->cl_base));
-	M0_POST(cl->cl_layers_nr == 0);
-	M0_RETURN(0);
 }
 
 /** Implementation of lo_delete for COMPOSITE layout type. */
@@ -297,7 +298,7 @@ static int layer_add_internal(struct m0_composite_layout *cl,
 			      struct m0_composite_layer **lr)
 {
 	struct m0_composite_layer        *layer;
-	struct m0_composite_layer_extent *ext1;
+	struct m0_composite_layer_extent *ext;
 
 	/* Zeroth layer is getting added. */
 	M0_PRE(ergo(cl->cl_layers_nr == 0,
@@ -331,8 +332,8 @@ static int layer_add_internal(struct m0_composite_layout *cl,
 	 * Add one single extent, mapping the whole offset space and with the
 	 * M0_CLRES_HOLE state, thus marking the layer empty.
 	 */
-	M0_ALLOC_PTR(ext1);
-	if (ext1 == NULL) {
+	M0_ALLOC_PTR(ext);
+	if (ext == NULL) {
 		m0_layout__log("layer_add_internal",
 			       "failed to allocate layer extent",
 			       M0_LAYOUT_ADDB_LOC_COMP_LAYER_EXT_ALLOC,
@@ -343,10 +344,10 @@ static int layer_add_internal(struct m0_composite_layout *cl,
 		m0_free(layer);
 		M0_RETURN(-ENOMEM);
 	}
-	ext1->cle_ext.e_start = 0;
-	ext1->cle_ext.e_end   = M0_BINDEX_MAX + 1;
-	ext1->cle_state       = M0_CLRES_HOLE;
-	ext_tlink_init_at_tail(ext1, &layer->clr_extents);
+	ext->cle_ext.e_start = 0;
+	ext->cle_ext.e_end   = M0_BINDEX_MAX + 1;
+	ext->cle_state       = M0_CLRES_HOLE;
+	ext_tlink_init_at_tail(ext, &layer->clr_extents);
 
 	layers_tlink_init_at_tail(layer, &cl->cl_layers);
 	M0_CNT_INC(cl->cl_layers_nr);
@@ -413,18 +414,19 @@ static int composite_populate(struct m0_composite_layout *cl,
 		M0_ASSERT(layer->clr_idx == 0);
 		m0_layout__populate(&cl->cl_base, user_count);
 	}
-
 	M0_POST(ergo(rc == 0, composite_invariant(cl)));
 	M0_POST(m0_mutex_is_locked(&cl->cl_base.l_lock));
 	M0_RETURN(rc);
 }
 
-/** Required only in case of error handling. */
+/**
+ * Does the reverse of what is done by composite_populate().
+ * Required only in case of error handling.
+ */
 static void composite_populate_reverse(struct m0_composite_layout *cl)
 {
 	M0_PRE(cl->cl_layers_nr == 0);
 	M0_PRE(layers_tlist_is_empty(&cl->cl_layers));
-
 	m0_layout__populate_reverse(&cl->cl_base);
 }
 
@@ -494,7 +496,6 @@ static void composite_fini(struct m0_ref *ref)
 	cl = m0_layout_to_cl(l);
 	layers_inmem_delete(cl);
 	layers_tlist_fini(&cl->cl_layers);
-
 	m0_layout__fini(&cl->cl_base);
 	m0_free(cl);
 	M0_LEAVE();
@@ -517,13 +518,12 @@ M0_INTERNAL int m0_composite_layer_add(struct m0_composite_layout *cl,
 	m0_mutex_lock(&cl->cl_base.l_lock);
 	M0_PRE(cl->cl_layers_nr < M0_COMPOSITE_LAYERS_MAX);
 	rc = layer_add(cl, sublayout, &layer);
-	if (rc != 0) {
+	if (rc != 0)
 		m0_layout__log("m0_composite_layer_add",
 			       "Failed to add layer",
 			       M0_LAYOUT_ADDB_LOC_COMP_LAYER_ADD,
 			       &cl->cl_base.l_addb_ctx, cl->cl_base.l_id, rc);
 
-	}
 	m0_mutex_unlock(&cl->cl_base.l_lock);
 	M0_POST(composite_invariant(cl));
 	M0_POST(ergo(rc == 0, layer->clr_idx > 0 && cl->cl_layers_nr > 1));
@@ -538,11 +538,11 @@ static struct m0_composite_layer *layer_find(
 	struct m0_composite_layer *layer = NULL;
 
 	M0_PRE(layer_idx < cl->cl_layers_nr);
+
 	m0_tl_for(layers, &cl->cl_layers, layer) {
 		if (layer->clr_idx == layer_idx)
 			break;
 	} m0_tl_endfor;
-
 	M0_POST(layer->clr_idx == layer_idx);
 	M0_POST(layer_invariant(layer));
 	return layer;
@@ -567,14 +567,14 @@ M0_INTERNAL void m0_composite_layer_delete(struct m0_composite_layout *cl)
 	M0_POST(composite_invariant(cl));
 }
 
-/** Finds a layout with the given lid. */
+/** Finds a sublayout with the given lid. */
 static struct m0_layout *layout_find(struct m0_layout_domain *dom,
 				     uint64_t lid)
 {
 	struct m0_layout *sublayout;
 
 	if (M0_FI_ENABLED("layout_find_err"))
-		{ sublayout = NULL; goto err1_injected; }
+		{ sublayout = NULL; goto err_injected; }
 	sublayout = m0_layout_find(dom, lid);
 	/**
 	 * @todo Eventually, if the sublayout is not found in the cache, it
@@ -588,7 +588,7 @@ static struct m0_layout *layout_find(struct m0_layout_domain *dom,
 	 *
 	 * Until the time the above changes are implemented, the user shall
 	 * ensure that the sublayouts are cached prior to 'creating a composite
-	 * layout and adding layers to it' and also prior to attempting decode
+	 * layout and adding layers to it' and also, prior to attempting decode
 	 * for a composite layout. The following assert ensures the same.
 	 *
 	 * Remove the following assert once the above mentioned changes
@@ -598,7 +598,7 @@ static struct m0_layout *layout_find(struct m0_layout_domain *dom,
 	 * 'the composite layout type support to getattr'.
 	 */
 	M0_ASSERT(sublayout != NULL);
-err1_injected:
+err_injected:
 	return sublayout;
 }
 
@@ -651,14 +651,13 @@ static int sublayout_ids_inbuf_read(struct m0_composite_layout *cl,
 		m0_bufvec_cursor_move(cur, sizeof *sublayout_id);
 		sublayout_id_list[i] = *sublayout_id;
 	}
-
 	*sl_id_list = sublayout_id_list;
 	M0_POST(*layers_nr > 0);
 	M0_RETURN(0);
 }
 
 static void ext_del(struct m0_composite_layer *layer,
-		    struct m0_composite_layer_extent *ext1);
+		    struct m0_composite_layer_extent *ext);
 static int ext_add(struct m0_tl *extlist,
 		   struct m0_layout *l,
 		   const struct m0_ext *e,
@@ -667,7 +666,7 @@ static int ext_add(struct m0_tl *extlist,
 		   struct m0_composite_layer_extent *adjacent);
 
 /*
- * Reads all the extents associated with each layer for a composite layout,
+ * Reads all the extents associated with the provided layer by reading those
  * from the buffer provided and stores those in the layer.
  *
  * Extents are stored in the auxiliary table for the composite layout viz.
@@ -677,7 +676,7 @@ static int extents_inbuf_read(struct m0_composite_layout *cl,
 			      struct m0_composite_layer *layer,
 			      struct m0_bufvec_cursor *cur)
 {
-	struct m0_composite_layer_extent *ext1;
+	struct m0_composite_layer_extent *ext;
 	struct layer_header              *header;
 	struct layer_buf_ext             *buf_ext;
 	uint32_t                          i;
@@ -689,27 +688,29 @@ static int extents_inbuf_read(struct m0_composite_layout *cl,
 		 (unsigned long)layer->clr_idx);
 	/*
 	 * Delete the single extent added by default when the layer got added.
-	 * Then serially add the the extents read from the buffer. Do not need
-	 * any verification since the overlapping was checked before the
-	 * layout was encoded.
 	 */
-	ext1 = ext_tlist_head(&layer->clr_extents);
-	M0_ASSERT(ext1->cle_ext.e_start == 0 &&
-		  ext1->cle_ext.e_end == M0_BINDEX_MAX + 1);
-	ext_del(layer, ext1);
+	ext = ext_tlist_head(&layer->clr_extents);
+	M0_ASSERT(ext->cle_ext.e_start == 0 &&
+		  ext->cle_ext.e_end == M0_BINDEX_MAX + 1);
+	ext_del(layer, ext);
 
 	header = m0_bufvec_cursor_addr(cur);
 	m0_bufvec_cursor_move(cur, sizeof *header);
 	M0_ASSERT(header->clh_idx == layer->clr_idx);
 	if (header->clh_extents_nr == 0) {
-		M0_LOG(M0_ERROR, "lid %llu, layer %lu, No extent is present "
-		       "in the buffer", (unsigned long long)cl->cl_base.l_id,
+		M0_LOG(M0_ERROR, "lid %llu, layer %lu, No extents present in "
+		       "the buffer", (unsigned long long)cl->cl_base.l_id,
 		       (unsigned long)layer->clr_idx);
-		return -EINVAL;
+		M0_RETURN(-EINVAL);
 	}
 
-	M0_PRE(m0_bufvec_cursor_step(cur) >=
-	       header->clh_extents_nr * sizeof *buf_ext);
+	/*
+	 * Serially add the the extents read from the buffer. Do not need any
+	 * verification since the overlapping was checked before the layout was
+	 * encoded.
+	 */
+	M0_ASSERT(m0_bufvec_cursor_step(cur) >=
+		  header->clh_extents_nr * sizeof *buf_ext);
 	for (i = 0; i < header->clh_extents_nr; ++i) {
 		buf_ext = m0_bufvec_cursor_addr(cur);
 		m0_bufvec_cursor_move(cur, sizeof *buf_ext);
@@ -717,11 +718,12 @@ static int extents_inbuf_read(struct m0_composite_layout *cl,
 		if (m0_ext_is_empty(&buf_ext->lbe_ext) ||
 		    !M0_IN(buf_ext->lbe_state, (M0_CLRES_HOLE, M0_CLRES_VALID,
 						M0_CLRES_FLATTENING))) {
+			rc = -EINVAL;
 			M0_LOG(M0_ERROR, "lid %llu, layer %lu, Invalid extent "
 			       "found in the buffer",
 			       (unsigned long long)cl->cl_base.l_id,
 			       (unsigned long)layer->clr_idx);
-			return -EINVAL;
+			break;
 		}
 		rc = ext_add(&layer->clr_extents, &cl->cl_base,
 			     &buf_ext->lbe_ext, buf_ext->lbe_state,
@@ -731,17 +733,17 @@ static int extents_inbuf_read(struct m0_composite_layout *cl,
 			       "not be added to the list",
 			       (unsigned long long)cl->cl_base.l_id,
 			       (unsigned long)layer->clr_idx);
-			return rc;
+			break;
 		}
 	}
 	layer->clr_extents_nr = ext_tlist_length(&layer->clr_extents);
-	M0_POST(composite_invariant(cl));
+	M0_POST(ergo(rc == 0, composite_invariant(cl)));
 	M0_RETURN(rc);
 }
 
 /*
  * Layout DB related functions are defined towards the end of this file.
- * Hence some of those are forward declared here.
+ * Hence, some of those are forward declared here.
  */
 static int layers_indb_add(struct m0_composite_layout *cl,
 			   struct m0_db_tx *tx);
@@ -791,7 +793,6 @@ static int layers_read(struct m0_composite_layout *cl,
 			       (unsigned long long)sublayout_id_list[i]);
 			break;
 		}
-
 		if (i == 0) { /* Zeroth layer */
 			rc = composite_populate(cl, sublayout, user_count);
 			if (rc == 0) {
@@ -865,17 +866,17 @@ static int composite_decode(struct m0_layout *l,
 	M0_PRE(layers_tlist_is_empty(&cl->cl_layers));
 
 	rc = sublayout_ids_inbuf_read(cl, cur, &layers_nr, &sublayout_id_list);
-	if (rc != 0) {
+	if (rc == 0) {
+		/*
+		 * Read layers either from the buffer or from the DB, as
+		 * applicable.
+		 */
+		rc = layers_read(cl, cur, op, tx, user_count, layers_nr,
+				 sublayout_id_list);
+		m0_free(sublayout_id_list);
+	} else
 		M0_LOG(M0_ERROR, "lid %llu, failed to read sublayout id list "
-		       "from the buffer",
-		       (unsigned long long)cl->cl_base.l_id);
-		return rc;
-	}
-
-	/* Read layers either from the buffer or from the DB, as applicable. */
-	rc = layers_read(cl, cur, op, tx, user_count, layers_nr,
-			 sublayout_id_list);
-	m0_free(sublayout_id_list);
+		       "from the buffer", (unsigned long long)cl->cl_base.l_id);
 	M0_POST(ergo(rc == 0, composite_invariant(cl)));
 	M0_POST(ergo(rc != 0 && cl->cl_layers_nr > 0,
 		     composite_invariant(cl)));
@@ -1007,7 +1008,6 @@ static int ext_find(struct m0_composite_layer *layer,
 {
 	struct m0_composite_layer_extent *ext1;
 	bool                              ext_encountered;
-	int                               rc;
 
 	M0_ENTRY("lid %llu, layer %lu, e_start %llu, e_end %llu, "
 		 "expected_e_state %llu",
@@ -1025,15 +1025,13 @@ static int ext_find(struct m0_composite_layer *layer,
 			break;
 		}
 	} m0_tl_endfor;
-
 	if (ext_encountered) {
 		M0_ASSERT(ext1->cle_state == expected_state);
-		rc = 0;
 		if (ext != NULL)
 			*ext = ext1;
+		M0_RETURN(0);
 	} else
-		rc = -ENOENT;
-	M0_RETURN(rc);
+		M0_RETURN(-ENOENT);
 }
 
 /**
@@ -1046,20 +1044,20 @@ static void ext_add_internal(struct m0_tl *extlist,
 			     enum m0_composite_layer_ext_state state,
 			     uint32_t add_position,
 			     struct m0_composite_layer_extent *adjacent,
-			     struct m0_composite_layer_extent *ext1)
+			     struct m0_composite_layer_extent *ext)
 {
 	M0_PRE(extlist != NULL);
 	M0_PRE(m0_layout__invariant(l));
 	M0_PRE(!m0_ext_is_empty(e));
 	M0_PRE(M0_IN(state, (M0_CLRES_HOLE, M0_CLRES_VALID,
-				 M0_CLRES_FLATTENING)));
+			     M0_CLRES_FLATTENING)));
 	M0_PRE(M0_IN(add_position, (ADD_AFTER, ADD_BEFORE, ADD_AT_START,
 				    ADD_AT_TAIL)));
 	M0_PRE(ergo(M0_IN(add_position, (ADD_AFTER, ADD_BEFORE)),
 		    adjacent != NULL && ext_tlink_is_in(adjacent)));
-	M0_PRE(ergo(add_position == ADD_AT_START || add_position == ADD_AT_TAIL,
+	M0_PRE(ergo(M0_IN(add_position, (ADD_AT_START, ADD_AT_TAIL)),
 		    adjacent == NULL));
-	M0_PRE(ext1 != NULL);
+	M0_PRE(ext != NULL);
 
 	M0_ENTRY("lid %llu, e_start %llu, e_end %llu, e_state %llu, "
 		 "add_position %lu, adj_ext_start %llu, adj_ext_end %llu",
@@ -1070,22 +1068,23 @@ static void ext_add_internal(struct m0_tl *extlist,
 		 (unsigned long long)adjacent->cle_ext.e_start,
 		 (adjacent == NULL) ? 0 :
 		 (unsigned long long)adjacent->cle_ext.e_end);
-
-	ext1->cle_ext = *e;
-	ext1->cle_state = state;
+	ext->cle_ext = *e;
+	ext->cle_state = state;
 	if (M0_IN(add_position, (ADD_AFTER, ADD_BEFORE))) {
-		ext_tlink_init(ext1);
+		ext_tlink_init(ext);
 		if (add_position == ADD_AFTER)
-			ext_tlist_add_after(adjacent, ext1);
+			ext_tlist_add_after(adjacent, ext);
 		else
-			ext_tlist_add_before(adjacent, ext1);
+			ext_tlist_add_before(adjacent, ext);
 	} else if (add_position == ADD_AT_START)
-		ext_tlink_init_at(ext1, extlist);
+		ext_tlink_init_at(ext, extlist);
 	else
-		ext_tlink_init_at_tail(ext1, extlist);
+		ext_tlink_init_at_tail(ext, extlist);
 }
 
-/** Adds an extent to the provided extent list, at the provided position. */
+/**
+ * Allocates an extent and adds it to the provided extent list, at the provided  * position.
+ */
 static int ext_add(struct m0_tl *extlist,
 		   struct m0_layout *l,
 		   const struct m0_ext *e,
@@ -1093,17 +1092,17 @@ static int ext_add(struct m0_tl *extlist,
 		   uint32_t add_position,
 		   struct m0_composite_layer_extent *adjacent)
 {
-	struct m0_composite_layer_extent *ext1;
+	struct m0_composite_layer_extent *ext;
 
-	M0_ALLOC_PTR(ext1);
-	if (ext1 == NULL) {
+	M0_ALLOC_PTR(ext);
+	if (ext == NULL) {
 		m0_layout__log("ext_add", "failed to allocate composite extent",
 			       M0_LAYOUT_ADDB_LOC_COMP_EXT_ADD_INTERNAL,
 			       &l->l_addb_ctx, l->l_id, -ENOMEM);
 		M0_RETURN(-ENOMEM);
 	}
 	ext_add_internal(extlist, l, e, state, add_position,
-			 adjacent, ext1);
+			 adjacent, ext);
 	M0_RETURN(0);
 }
 
@@ -1169,26 +1168,27 @@ M0_INTERNAL int m0_composite_layer_ext_lookup(
 
 /** Deletes an extent from the extent list associated with the given layer. */
 static void ext_del(struct m0_composite_layer *layer,
-		    struct m0_composite_layer_extent *ext1)
+		    struct m0_composite_layer_extent *ext)
 {
 	M0_LOG(M0_DEBUG, "lid %llu, layer %lu, e_start %llu, e_end %llu, "
 	       "e_state %llu", (unsigned long long)layer->clr_cl->l_id,
 	       (unsigned long)layer->clr_idx,
-	       (unsigned long long)ext1->cle_ext.e_start,
-	       (unsigned long long)ext1->cle_ext.e_end,
-	       (unsigned long long)ext1->cle_state);
-	ext_tlist_del(ext1);
-	ext_tlink_fini(ext1);
-	m0_free(ext1);
+	       (unsigned long long)ext->cle_ext.e_start,
+	       (unsigned long long)ext->cle_ext.e_end,
+	       (unsigned long long)ext->cle_state);
+	ext_tlist_del(ext);
+	ext_tlink_fini(ext);
+	m0_free(ext);
 	M0_CNT_DEC(layer->clr_extents_nr);
 }
 
 /**
- * Splits an existing extent as required when an overlapping extent is to be
- * added.
+ * Splits an existing extent as requested by using the vec.
+ * An extent is asked to be split when some partially overlapping extent is to
+ * be added.
  */
 static void ext_split(struct m0_composite_layer *layer,
-		      struct m0_composite_layer_extent *ext1,
+		      struct m0_composite_layer_extent *ext,
 		      struct m0_indexvec *vec,
 		      m0_bindex_t scan,
 		      struct preallocated_extents *prealloc)
@@ -1197,7 +1197,7 @@ static void ext_split(struct m0_composite_layer *layer,
 	m0_bcount_t   len;
 	uint32_t      i;
 
-	M0_PRE(ext_tlink_is_in(ext1));
+	M0_PRE(ext_tlink_is_in(ext));
 	M0_PRE(vec->iv_vec.v_nr == 3);
 	M0_PRE(vec->iv_vec.v_count[0] != 0 || vec->iv_vec.v_count[1] != 0 ||
 	       vec->iv_vec.v_count[2] != 0);
@@ -1213,13 +1213,13 @@ static void ext_split(struct m0_composite_layer *layer,
 			e.e_start = scan;
 			e.e_end = scan = scan + len;
 			ext_add_internal(&layer->clr_extents, layer->clr_cl, &e,
-					 vec->iv_index[i], ADD_BEFORE, ext1,
+					 vec->iv_index[i], ADD_BEFORE, ext,
 					 prealloc->ext[prealloc->max_used]);
 			prealloc->is_used[prealloc->max_used++] = true;
 			M0_CNT_INC(layer->clr_extents_nr);
 		}
 	}
-	ext_del(layer, ext1);
+	ext_del(layer, ext);
 	M0_LEAVE();
 }
 
@@ -1314,7 +1314,7 @@ static int ext_paste(struct m0_composite_layout *cl,
 		     struct m0_composite_layer_extent *target)
 {
 	struct preallocated_extents       prealloc;
-	struct m0_composite_layer_extent *ext1;
+	struct m0_composite_layer_extent *ext;
 	struct m0_composite_layer_extent *next;
 	struct m0_composite_layer_extent *delete; /* Ext to delete */
 	struct m0_composite_layer_extent *prev;
@@ -1328,6 +1328,11 @@ static int ext_paste(struct m0_composite_layout *cl,
 	chunk = &target->cle_ext;
 	M0_PRE(m0_ext_is_in(chunk, e->e_start));
 
+	M0_ENTRY("lid %llu, layer %lu, e_start %llu, e_end %llu, e_state %llu",
+		 (unsigned long long)layer->clr_cl->l_id,
+		 (unsigned long)layer->clr_idx,
+		 (unsigned long long)e->e_start, (unsigned long long)e->e_end,
+		 (unsigned long long)new_state);
 	/*
 	 * It could have been possible that part of the overlapping extent was
 	 * changed and then error encountered while allocating memory for some
@@ -1350,8 +1355,8 @@ static int ext_paste(struct m0_composite_layout *cl,
 			m0_free(prealloc.ext[j]);
 		M0_RETURN(rc);
 	}
-	prealloc.max_used = 0;
 
+	prealloc.max_used = 0;
 	is_ultimate_ext_add = false;
 	prev = ext_tlist_prev(&layer->clr_extents, target);
 	while (!m0_ext_is_empty(&e0)) {
@@ -1395,7 +1400,7 @@ static int ext_paste(struct m0_composite_layout *cl,
 		}
 
 		/*
-		 * ext_split() may replace the current node, that is target,
+		 * ext_split() may replace the current node, that is 'target',
 		 * with multiple smaller segments. Hence, store the next node
 		 * before invoking ext_split().
 		 */
@@ -1427,8 +1432,7 @@ static int ext_paste(struct m0_composite_layout *cl,
 	 * has been handled above, let's add the ultimate whole extent.
 	 */
 	if (is_ultimate_ext_add) {
-		M0_ASSERT(ext_find(layer, e, new_state, &ext1) ==
-			  -ENOENT);
+		M0_ASSERT(ext_find(layer, e, new_state, &ext) == -ENOENT);
 		if (e->e_start == 0) {
 			M0_ASSERT(prev == NULL);
 			ext_add_internal(&layer->clr_extents, &cl->cl_base,
@@ -1437,7 +1441,7 @@ static int ext_paste(struct m0_composite_layout *cl,
 		} else {
 			M0_ASSERT(prev != NULL);
 			M0_ASSERT(ext_find(layer, &prev->cle_ext,
-					   prev->cle_state, &ext1) == 0);
+					   prev->cle_state, &ext) == 0);
 			if (prev->cle_ext.e_end < e->e_start)
 				/*
 				 * It is possible that as a result of some
@@ -1448,7 +1452,7 @@ static int ext_paste(struct m0_composite_layout *cl,
 						      prev);
 			ext_add_internal(&layer->clr_extents, &cl->cl_base,
 					 e, new_state, ADD_AFTER, prev,
-				       prealloc.ext[prealloc.max_used]);
+					 prealloc.ext[prealloc.max_used]);
 		}
 		prealloc.is_used[prealloc.max_used++] = true;
 		M0_CNT_INC(layer->clr_extents_nr);
@@ -1479,21 +1483,21 @@ static int ext_write(struct m0_composite_layout *cl,
 	M0_PRE(!m0_ext_is_empty(e));
 
 	lid = cl->cl_base.l_id;
+	M0_ENTRY("lid %llu, layer %lu, e_start %llu, e_end %llu, e_state %llu",
+		 (unsigned long long)lid,
+		 (unsigned long)layer->clr_idx,
+		 (unsigned long long)e->e_start, (unsigned long long)e->e_end,
+		 (unsigned long long)new_state);
 	/* Validate the 'ext' and find the nearest extent from the list. */
 	rc = ext_validate(cl, layer, e, new_state, ext_validation_kind,
 			  &target);
 	if (rc != 0)
-		return rc;
+		M0_RETURN(rc);
 	M0_ASSERT(target != NULL);
+	M0_LOG(M0_DEBUG, "target_start %llu, target_end %llu",
+	       (unsigned long long)target->cle_ext.e_start,
+	       (unsigned long long)target->cle_ext.e_end);
 
-	M0_ENTRY("lid %llu, layer %lu, e_start %llu, e_end %llu, e_state %llu "
-		 "target_start %llu, target_end %llu",
-		 (unsigned long long)layer->clr_cl->l_id,
-		 (unsigned long)layer->clr_idx,
-		 (unsigned long long)e->e_start, (unsigned long long)e->e_end,
-		 (unsigned long long)new_state,
-		 (unsigned long long)target->cle_ext.e_start,
-		 (unsigned long long)target->cle_ext.e_end);
 	if (m0_ext_equal(&target->cle_ext, e)) {
 		target->cle_state = new_state;
 		M0_RETURN(0);
@@ -1629,6 +1633,7 @@ static m0_bcount_t composite_bufsize(const struct m0_layout *l)
 				     sizeof(struct layer_header))) + bufsize;
 }
 
+/* DB related routines start here. */
 /** Implementation of lto_max_recsize() for COMPOSITE layout type. */
 static m0_bcount_t composite_max_recsize(struct m0_layout_domain *dom)
 {
@@ -1637,7 +1642,6 @@ static m0_bcount_t composite_max_recsize(struct m0_layout_domain *dom)
 		M0_COMPOSITE_LAYERS_MAX * sizeof(uint64_t);
 }
 
-/* DB related routines start here. */
 /** Sets prefix with the given lid and layer id. */
 static void prefix_set(struct layout_prefix *prefix,
 		       uint64_t composite_lid,
@@ -1661,17 +1665,14 @@ static int emap_iterator_set(struct m0_composite_layout *cl,
 
 	prefix_set(&prefix, cl->cl_base.l_id, layer_idx);
 	if (M0_FI_ENABLED("emap_lookup_err"))
-		{ rc = L_EMAP_LOOKUP_ERR; goto err1_injected; }
+		{ rc = L_EMAP_LOOKUP_ERR; goto err_injected; }
 	rc = m0_emap_lookup(emap, tx, (struct m0_uint128 *)&prefix, offset, it);
-err1_injected:
-	if (rc != 0) {
+err_injected:
+	if (rc != 0)
 		m0_layout__log("emap_iterator_set",
 			       "failed to lookup into layer_emap",
 			       M0_LAYOUT_ADDB_LOC_COMP_EMAP_IT_SET,
 			       &cl->cl_base.l_addb_ctx, cl->cl_base.l_id, rc);
-		return rc;
-	}
-
 	return rc;
 }
 
@@ -1688,11 +1689,10 @@ static int ext_indb_write(struct m0_emap_cursor *it,
 	int           rc;
 
 	M0_PRE(layer_invariant(layer));
-	M0_ENTRY("lid %llu, layer %lu, e_start %llu, e_end %llu, "
-		 "new_e_state %llu", (unsigned long long)layer->clr_cl->l_id,
+	M0_ENTRY("lid %llu, layer %lu, e_start %llu, e_end %llu, e_state %llu",
+		 (unsigned long long)layer->clr_cl->l_id,
 		 (unsigned long)layer->clr_idx, (unsigned long long)e->e_start,
-		 (unsigned long long)e->e_end,
-		 (unsigned long long)new_state);
+		 (unsigned long long)e->e_end, (unsigned long long)new_state);
 	/*
 	 * Insert a new segment into the layer's extent map, overwriting
 	 * parts of the map, as applicable. Some existing segments are deleted
@@ -1723,18 +1723,16 @@ static int ext_indb_write(struct m0_emap_cursor *it,
 	 *    [165602677, 220070000) is retained (cut right operation).
 	 * 5) Finally, the complete extent [56668023, 165602677) is added.
 	 */
-
 	if (M0_FI_ENABLED("emap_paste_err"))
-		{ rc = L_EMAP_PASTE_ERR; goto err1_injected; }
+		{ rc = L_EMAP_PASTE_ERR; goto err_injected; }
 	rc = m0_emap_paste(it, &e0, new_state, NULL, NULL, NULL, NULL);
-err1_injected:
+err_injected:
 	if (rc != 0)
 		m0_layout__log("ext_indb_write",
 			       "failed to paste an extent into emap",
 			       M0_LAYOUT_ADDB_LOC_COMP_EXT_PASTE_2,
 			       &layer->clr_cl->l_addb_ctx, layer->clr_cl->l_id,
 			       rc);
-
 	M0_POST(layer_invariant(layer));
 	M0_RETURN(rc);
 }
@@ -1765,38 +1763,35 @@ static int extents_indb_add(struct m0_composite_layout *cl,
 	emap = emap_from_cl(cl);
 	prefix_set(&prefix, cl->cl_base.l_id, layer->clr_idx);
 	if (M0_FI_ENABLED("emap_obj_insert_err"))
-		{ rc = L_EMAP_OBJ_INSERT_ERR; goto err1_injected; }
+		{ rc = L_EMAP_OBJ_INSERT_ERR; goto err_injected; }
 	rc = m0_emap_obj_insert(emap, tx, (struct m0_uint128 *)&prefix,
 				M0_CLRES_HOLE);
-err1_injected:
-	if (rc != 0) {
+err_injected:
+	if (rc == 0) {
+		rc = emap_iterator_set(cl, emap, layer->clr_idx, 0, tx, &it);
+		if (rc != 0)
+			m0_emap_obj_delete(emap, tx,
+					   (struct m0_uint128 *)&prefix);
+			/*
+			 * If m0_emap_lookup() has failed for no apparent
+			 * reason, it is likely that m0_emap_obj_delete() too
+			 * would fail. Hence, ignoring its status.
+			 */
+	} else
 		m0_layout__log("extents_indb_add",
 			       "failed to insert into layer_emap",
 			       M0_LAYOUT_ADDB_LOC_COMP_LAYER_EMAP_ADD,
 			       &cl->cl_base.l_addb_ctx, cl->cl_base.l_id, rc);
-		return rc;
-	}
-
-	rc = emap_iterator_set(cl, emap, layer->clr_idx, 0, tx, &it);
-	if (rc != 0) {
-		m0_emap_obj_delete(emap, tx, (struct m0_uint128 *)&prefix);
-		/*
-		 * If m0_emap_lookup() has failed for no apparent reason, it is
-		 * likely that m0_emap_obj_delete() too would fail. Hence,
-		 * ignoring its status.
-		 */
+	if (rc != 0)
 		M0_RETURN(rc);
-	}
 
 	seg = m0_emap_seg_get(&it);
 	M0_ASSERT(seg->ee_ext.e_start == 0);
 	M0_ASSERT(seg->ee_ext.e_end == M0_BINDEX_MAX + 1);
 	M0_ASSERT(seg->ee_val == M0_CLRES_HOLE);
-
 	m0_tl_for(ext, &layer->clr_extents, ext1) {
-		M0_ASSERT(M0_IN(ext1->cle_state, (M0_CLRES_HOLE,
-						    M0_CLRES_VALID,
-						    M0_CLRES_FLATTENING)));
+		M0_ASSERT(M0_IN(ext1->cle_state, (M0_CLRES_HOLE, M0_CLRES_VALID,
+						  M0_CLRES_FLATTENING)));
 		rc = ext_indb_write(&it, layer, &ext1->cle_ext,
 				    ext1->cle_state);
 		if (rc != 0) {
@@ -1817,7 +1812,7 @@ static int extents_indb_read(struct m0_composite_layout *cl,
 			     struct m0_db_tx *tx)
 {
 	struct m0_layout                 *l;
-	struct m0_composite_layer_extent *ext1;
+	struct m0_composite_layer_extent *ext;
 	struct m0_emap                   *emap;
 	struct m0_emap_cursor             it;
 	struct m0_emap_seg               *seg;
@@ -1827,13 +1822,13 @@ static int extents_indb_read(struct m0_composite_layout *cl,
 		 (unsigned long)layer->clr_idx);
 	/*
 	 * Delete the single extent added by default when the layer got added.
-	 * Then sequentially, add the extents as read from the buffer.
 	 */
-	ext1 = ext_tlist_head(&layer->clr_extents);
-	M0_ASSERT(ext1->cle_ext.e_start == 0 &&
-		  ext1->cle_ext.e_end == M0_BINDEX_MAX + 1);
-	ext_del(layer, ext1);
+	ext = ext_tlist_head(&layer->clr_extents);
+	M0_ASSERT(ext->cle_ext.e_start == 0 &&
+		  ext->cle_ext.e_end == M0_BINDEX_MAX + 1);
+	ext_del(layer, ext);
 
+	/* Now, sequentially, add the extents as read from the buffer. */
 	l = &cl->cl_base;
 	emap = emap_from_cl(cl);
 	rc = emap_iterator_set(cl, emap, layer->clr_idx, 0, tx, &it);
@@ -1852,7 +1847,7 @@ static int extents_indb_read(struct m0_composite_layout *cl,
 			m0_layout__log("extents_indb_read",
 				       "Invalid extent found in the DB",
 				       M0_LAYOUT_ADDB_LOC_COMP_EMAP_READ,
-				       &l->l_addb_ctx, l->l_id, -ENOMEM);
+				       &l->l_addb_ctx, l->l_id, rc);
 			break;
 		}
 
@@ -1930,13 +1925,12 @@ err1_injected:
 			       "failed to lookup into layer_emap",
 			       M0_LAYOUT_ADDB_LOC_COMP_EMAP_LOOKUP,
 			       &cl->cl_base.l_addb_ctx, cl->cl_base.l_id, rc);
-		return rc;
+		M0_RETURN(rc);
 	}
 
 	if (M0_FI_ENABLED("emap_paste_err"))
 		{ rc = L_EMAP_PASTE_ERR; goto err2_injected; }
-	rc = m0_emap_paste(&it, &e, M0_CLRES_HOLE,
-			   NULL, NULL, NULL, NULL);
+	rc = m0_emap_paste(&it, &e, M0_CLRES_HOLE, NULL, NULL, NULL, NULL);
 err2_injected:
 	if (rc != 0)
 		m0_layout__log("single_ext_indb_write",
@@ -1963,7 +1957,6 @@ static int layer_indb_delete_verify(struct m0_composite_layout *cl,
 	M0_ENTRY("lid %llu, layer_idx %lu",
 		 (unsigned long long)cl->cl_base.l_id,
 		 (unsigned long)layer_idx);
-	rc = 0;
 	rc = emap_iterator_set(cl, emap, layer_idx, 0, tx, &it);
 	if (rc != 0)
 		M0_RETURN(rc);
@@ -2053,9 +2046,9 @@ static int layer_indb_delete(struct m0_composite_layout *cl,
 
 	prefix_set(&prefix, cl->cl_base.l_id, layer_idx);
 	if (M0_FI_ENABLED("emap_obj_del_err"))
-		{ rc = L_EMAP_OBJ_DEL_ERR; goto err1_injected; }
+		{ rc = L_EMAP_OBJ_DEL_ERR; goto err_injected; }
 	rc = m0_emap_obj_delete(emap, tx, (struct m0_uint128 *)&prefix);
-err1_injected:
+err_injected:
 	if (rc == 0) {
 		rc = sublayout_user_count_dec(cl, sublayout_id, sublayout,
 					      in_update_path);
@@ -2121,7 +2114,7 @@ static int old_layers_nr_n_sl_id_list_read(struct m0_composite_layout *cl,
 	M0_LOG(M0_DEBUG, "lid %llu, rc %d, old_layers_nr %lu",
 	       (unsigned long long)cl->cl_base.l_id, rc,
 	       (unsigned long)*layers_nr);
-	return rc;
+	M0_RETURN(rc);
 }
 
 /**
@@ -2150,15 +2143,12 @@ static int layers_indb_delete(struct m0_composite_layout *cl,
 		 (unsigned long long)cl->cl_base.l_id,
 		 (unsigned long)cl->cl_layers_nr);
 	emap = emap_from_cl(cl);
-
 	if (in_update_path) {
-		rc = old_layers_nr_n_sl_id_list_read(cl, tx,
-						     &old_layers_nr,
+		rc = old_layers_nr_n_sl_id_list_read(cl, tx, &old_layers_nr,
 						     &old_sl_id_list);
 		if (rc == 0) {
 			for (i = old_layers_nr - 1; i >= 0; --i) {
-				rc = layer_indb_delete(cl, i,
-						       old_sl_id_list[i],
+				rc = layer_indb_delete(cl, i, old_sl_id_list[i],
 						       NULL, tx,
 						       in_update_path);
 				if (i == 0 || rc != 0)
@@ -2230,20 +2220,21 @@ static int composite_instance_build(struct m0_layout *l,
 		 (unsigned long long)fid->f_container,
 		 (unsigned long long)fid->f_key);
 	M0_ALLOC_PTR(ci);
-	if (ci == NULL) {
+	if (ci != NULL) {
+		m0_layout__instance_init(&ci->ci_base, fid, l,
+					 &composite_instance_ops);
+		m0_composite_instance_bob_init(ci);
+		*out = &ci->ci_base;
+		M0_POST(composite_instance_invariant(ci));
+		M0_POST(m0_ref_read(&l->l_ref) > 1);
+		M0_RETURN(0);
+	} else {
 		m0_layout__log("composite_instance_build",
 			       "failed to allocate composite instance",
 			       M0_LAYOUT_ADDB_LOC_COMP_INST_BUILD,
 			       &l->l_addb_ctx, l->l_id, -ENOMEM);
-		return -ENOMEM;
+		M0_RETURN(-ENOMEM);
 	}
-	m0_layout__instance_init(&ci->ci_base, fid, l,
-				 &composite_instance_ops);
-	m0_composite_instance_bob_init(ci);
-	*out = &ci->ci_base;
-	M0_POST(composite_instance_invariant(ci));
-	M0_POST(m0_ref_read(&l->l_ref) > 1);
-	M0_RETURN(0);
 }
 
 /** Implementation of lio_fini(). */
diff --git a/layout/composite_internal.h b/layout/composite_internal.h
index 6effe90..3b3d2ba 100644
--- a/layout/composite_internal.h
+++ b/layout/composite_internal.h
@@ -103,6 +103,17 @@ struct layer_buf_ext {
 };
 M0_BASSERT(M0_IS_8ALIGNED(sizeof(struct layer_buf_ext)));
 
+enum {
+	/**
+	 * Number of extents required to be preallocated during an
+	 * ext_paste() operation. It is 2 * 3 + 1 that is
+	 * "max_nr_of_split_operations_those_can_take_place *
+	 * max_nr_of_extents_required_for_one_split_op +
+	 * required_for_adding_the_ultimate_extent".
+	 */
+	PREALLOCATE_NR = 7
+};
+
 /** @} end group layout */
 
 /* __MERO_LAYOUT_COMPOSITE_INTERNAL_H__ */
diff --git a/layout/layout_internal.h b/layout/layout_internal.h
index 23d1690..a1ddb03 100644
--- a/layout/layout_internal.h
+++ b/layout/layout_internal.h
@@ -52,15 +52,6 @@ enum {
 	DEFAULT_DB_FLAG            = 0,
 
 	/**
-	 * Number of extents required to be preallocated during an
-	 * ext_paste() operation. It is 2 * 3 + 1 that is
-	 * "max_nr_of_split_operations_those_can_take_place *
-	 *  max_nr_of_extents_required_for_one_split_op +
-	 *  required_for_adding_the_ultimate_extent".
-	 */
-	PREALLOCATE_NR             = 7,
-
-	/**
 	 * Simulation for m0_table_init() facing error in
 	 * m0_layout_domain_init().
 	 */
diff --git a/layout/ut/layout.c b/layout/ut/layout.c
index 0cabfd1..3972d50 100644
--- a/layout/ut/layout.c
+++ b/layout/ut/layout.c
@@ -604,11 +604,11 @@ static void test_build_failure(void)
 	M0_UT_ASSERT(rc == -ENOMEM);
 
 	/*
-	 * Simulate ext1 memory allocation failure in the first invokation of
+	 * Simulate ext memory allocation failure in the first invokation of
 	 * layer_add_internal() that is in the path of m0_composite_build().
 	 */
 	lid = 2023;
-	m0_fi_enable_once("layer_add_internal", "alloc_ptr_fail/ext1");
+	m0_fi_enable_once("layer_add_internal", "alloc_ptr_fail/ext");
 	rc = test_build_composite(lid, &domain, 5, !CONTIGUOUS_EXTENTS,
 				  FAILURE_TEST);
 	M0_UT_ASSERT(rc == -ENOMEM);
@@ -792,7 +792,7 @@ static void test_decode_failure(void)
 	 * extents_inbuf_read().
 	 */
 	lid = 4024;
-	m0_fi_enable_once("ext_add", "alloc_ptr_fail/ext1");
+	m0_fi_enable_once("ext_add", "alloc_ptr_fail/ext");
 	rc = test_decode_composite(lid, &domain, 5, 6,
 				   !CONTIGUOUS_EXTENTS, FAILURE_TEST);
 	M0_UT_ASSERT(rc == -ENOMEM);
@@ -1707,12 +1707,12 @@ static void test_lookup_failure(void)
 	 * extents_indb_read().
 	 */
 	lid = 19024;
-	m0_fi_enable_off_n_on_m("ext_add", "alloc_ptr_fail/ext1",
+	m0_fi_enable_off_n_on_m("ext_add", "alloc_ptr_fail/ext",
 				80 /* layers_nr * extents_nr * 4 */, 1);
 	rc = test_lookup_composite(lid, &domain, 4, 5, CONTIGUOUS_EXTENTS,
 				   EXISTING_TEST, FAILURE_TEST);
 	M0_UT_ASSERT(rc == -ENOMEM);
-	m0_fi_disable("ext_add", "alloc_ptr_fail/ext1");
+	m0_fi_disable("ext_add", "alloc_ptr_fail/ext");
 #endif
 
 	/*
-- 
1.8.3.2

