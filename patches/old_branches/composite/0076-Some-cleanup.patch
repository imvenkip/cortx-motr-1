From 5dcf522efa45323ee512a7ee1a8e93175052457b Mon Sep 17 00:00:00 2001
From: "trupti.patil" <trupti_patil@xyratex.com>
Date: Fri, 8 Mar 2013 10:20:03 +0530
Subject: [PATCH 076/172] Some cleanup

---
 layout/composite.c | 93 +++++++++++++++++-------------------------------------
 1 file changed, 29 insertions(+), 64 deletions(-)

diff --git a/layout/composite.c b/layout/composite.c
index 5022549..de6fabd 100644
--- a/layout/composite.c
+++ b/layout/composite.c
@@ -586,6 +586,10 @@ static void composite_fini(struct m0_ref *ref)
 	M0_LEAVE();
 }
 
+/*
+ * Layout DB related functions are defined towards the end of this file.
+ * Hence some of those are forward declared here.
+ */
 static int ext_inmem_add_internal(struct m0_composite_layer *layer,
 				  struct m0_layout *l,
 				  struct m0_tl *extlist,
@@ -826,9 +830,11 @@ static int extlist_inbuf_read(struct m0_composite_layout *cl,
 	uint32_t       i;
 	int            rc;
 
-	M0_ENTRY("lid %llu", (unsigned long long)cl->cl_base.l_id);
 	M0_PRE(m0_bufvec_cursor_step(cur) >= extents_nr * sizeof *ext);
 
+	M0_ENTRY("lid %llu, extents_nr %lu",
+		 (unsigned long long)cl->cl_base.l_id,
+		 (unsigned long)extents_nr);
 	m0_composite_layer_ext_tlist_init(extlist);
 	rc = 0;
 	for (i = 0; i < extents_nr; ++i) {
@@ -897,7 +903,7 @@ static int comp_layout_inbuf_read(struct m0_composite_layout *cl,
 
 		if (lr_header->clh_extents_nr == 0) {
 			M0_LOG(M0_ERROR, "lid %llu, layer %lu, No extent is "
-			       "associated in the buffer",
+			       "present in the buffer",
 			       (unsigned long long)cl->cl_base.l_id,
 			       (unsigned long)i);
 			return -EINVAL;
@@ -1071,7 +1077,7 @@ static int composite_encode(struct m0_layout *l,
 		 * then the layout is asked to be updated in the DB at a later
 		 * point. For this reason, as a part of the layout update for
 		 * a composite layout, all the existing layers and their
-		 * extents are first deleted and then are added newly by
+		 * extents are first deleted and then they are added newly by
 		 * referring to the current in-memory layout.
 		 */
 		rc = comp_layout_indb_delete(cl, tx, IN_UPDATE_PATH);
@@ -1105,7 +1111,7 @@ static int composite_encode(struct m0_layout *l,
 
 /**
  * Check if the exact provided extent with the exact provided state is present
- * in the list of the extents.
+ * in the list of the extents associated with the specified layer.
  */
 static int ext_inmem_find(struct m0_composite_layer *layer,
 			  const struct m0_ext *ext,
@@ -1238,6 +1244,7 @@ static int ext_inmem_add(struct m0_composite_layer *layer,
 		 (unsigned long)layer->clr_idx,
 		 (unsigned long long)ext->e_start,
 		 (unsigned long long)ext->e_end, (unsigned long long)ext_state);
+	/* Figure out the position such that the list remains sorted. */
 	lr_ext_to_insert_before = NULL;
 	lr_ext_to_insert_after = NULL;
 	m0_tl_for(m0_composite_layer_ext, &layer->clr_extents, lr_ext) {
@@ -1356,8 +1363,10 @@ M0_INTERNAL int m0_composite_layer_ext_lookup(struct m0_composite_layout *cl,
 		/*
 		 * In the current implemetation, the in-memory layout is
 		 * always necessarily up-to-date. Hence, it is not possible
-		 * to hit this exception. It will be required when a network
-		 * request is supported to fetch partial composite layout.
+		 * to hit this exception that 'the offset is not found in the
+		 * in-memory layout and can be found in the in-DB layout'. It
+		 * will be required when a network request is supported to
+		 * fetch partial composite layout due to its large size.
 		 */
 		M0_LOG(M0_DEBUG, "lid %llu, offset %llu, rc %d, Offset not "
 		       "found in the in-memory layout. Looking up into the DB.",
@@ -1433,7 +1442,7 @@ static int ext_split_internal(struct m0_composite_layer *layer,
 
 /**
  * Validates the overlapping extents to ensure that they can be merged or
- * deleted and find the nearest extent from the list so as to start inserting
+ * deleted and finds the nearest extent from the list so as to start inserting
  * the newer extent into it.
  *
  * Overlapping extents can be merged if and only if they are with
@@ -1442,8 +1451,8 @@ static int ext_split_internal(struct m0_composite_layer *layer,
  * Overlapping extents can be deleted if and only if they are:
  * - all with the state M0_CLRES_INVALID OR
  * - all with only one state other than M0_CLRES_INVALID OR
- * - all with mixture of some with the state M0_CLRES_INVALID and some with one
- *   single state other than M0_CLRES_INVALID.
+ * - all with the mixture of some with the state M0_CLRES_INVALID and some with
+ *   one single state other than M0_CLRES_INVALID.
  */
 static int ext_inmem_validate(struct m0_composite_layout *cl,
 			      struct m0_composite_layer *layer,
@@ -1496,9 +1505,8 @@ static int ext_inmem_validate(struct m0_composite_layout *cl,
 			}
 		} else { /* ext_validation_kind == EXT_DEL_VALIDATION */
 			if (lr_ext->cle_state != M0_CLRES_INVALID &&
-			     (first_noninvalid_state !=
-			      M0_CLRES_INVALID && lr_ext->cle_state !=
-			      first_noninvalid_state)) {
+			     (first_noninvalid_state != M0_CLRES_INVALID &&
+			      lr_ext->cle_state !=first_noninvalid_state)) {
 				rc = -EINVAL;
 				M0_LOG(M0_ERROR, "lid %llu, layer %lu, "
 				       "Overlapping extent can not be deleted "
@@ -1508,8 +1516,7 @@ static int ext_inmem_validate(struct m0_composite_layout *cl,
 				       "existing_e_end %llu, "
 				       "existing_state %llu, "
 				       "first_non_invalid_state %llu",
-				       (unsigned long long)
-						layer->clr_cl->l_id,
+				       (unsigned long long) layer->clr_cl->l_id,
 				       (unsigned long)layer->clr_idx,
 				       (unsigned long long)ext->e_start,
 				       (unsigned long long)ext->e_end,
@@ -1534,7 +1541,7 @@ static int ext_inmem_validate(struct m0_composite_layout *cl,
 }
 
 /**
- * Pastes an extent with the specified state into the in-memory extent list
+ * Pastes an extent with the specified state into 'the in-memory extent list
  * associated with the specified layer'. It internally deletes or truncates
  * the overlappping extents as necessary.
  */
@@ -1602,19 +1609,20 @@ static int ext_inmem_write(struct m0_composite_layout *cl,
 	M0_ASSERT(m0_ext_is_in(chunk, ext->e_start));
 
 	/*
-	 * Iterate over existing extents overlapping with the new one,
+	 * Iterate over the existing extents overlapping with the new one,
 	 * calculating for each, what parts have to be deleted and what remains.
 	 *
 	 * In the worst case, an existing extent can split into three parts.
 	 *
 	 * Note that the "whole" new extent is inserted after all the
-	 * iterations of the following loop complete (see length[1]
-	 * assignment), thus violating the layer invariant until that point
-	 * (the extent mask is "porous" during that time).
+	 * iterations of the following loop complete (see length[1] and
+	 * is_ultimate_ext_add flag assignment), thus violating the layer
+	 * invariant until that point (the extent mask is "porous" during that
+	 * time).
 	 *
-	 * This logic for extent addition has been inherited from
+	 * This logic for the extent addition has been inherited from
 	 * m0_emap_paste() that has been exercised for some time now and is
-	 * understood to be efficient! To look at an example illustrating the
+	 * understood to be highly efficient! For an example illustrating the
 	 * functioning of m0_emap_paste(), see the note added in
 	 * ext_indb_write().
 	 */
@@ -1680,49 +1688,6 @@ static int ext_inmem_write(struct m0_composite_layout *cl,
 			M0_ASSERT(lr_ext_next != NULL);
 		}
 
-#if 0 //todo See why this msg is giving syntax error
-		M0_LOG(M0_DEBUG, "lid %llu, layer %lu, \n"
-		       "\te_start %llu, e_end %llu, \n"
-		       "\tlr_ext_to_insert_into_start %llu, \n"
-		       "\tlr_ext_to_insert_into_end %llu, \n"
-		       "\tchunk_start %llu, chunk_end %llu, \n"
-		       "\tclip_start %llu, clip_end %llu, \n"
-		       "\tsplit_reqd %d, \n"
-		       "\t\tlength[0] %llu, bstart[0] %llu, \n"
-		       "\t\tlength[1] %llu, bstart[1] %llu, \n"
-		       "\t\tlength[2] %llu, bstart[2] %llu, \n"
-		       "\tdelete_reqd %d, \n"
-		       "\t\text_to_del_start %llu, ext_to_del_end %llu, \n"
-		       "\tnext_start %llu, next_end %llu, \n",
-		       (unsigned long long)layer->clr_cl->l_id,
-		       (unsigned long)layer->clr_idx,
-		       (unsigned long long)ext0.e_start,
-		       (unsigned long long)ext0.e_end,
-		       (unsigned long long)
-				lr_ext_to_insert_into->cle_ext.e_start,
-		       (unsigned long long)lr_ext_to_insert_into->cle_ext.e_end,
-		       (unsigned long long)chunk->e_start,
-		       (unsigned long long)chunk->e_end,
-		       (unsigned long long)clip.e_start,
-		       (unsigned long long)clip.e_end,
-		       split_required,
-		       (unsigned long long)length[0],
-		       (unsigned long long)bstart[0],
-		       (unsigned long long)length[1],
-		       (unsigned long long)bstart[1],
-		       (unsigned long long)length[2],
-		       (unsigned long long)bstart[2],
-		       delete_required,
-		       lr_ext_to_del == NULL ? 0 :
-		       (unsigned long long)lr_ext_to_del->cle_ext.e_start,
-		       lr_ext_to_del == NULL ? 0 :
-		       (unsigned long long)lr_ext_to_del->cle_ext.e_end,
-		       lr_ext_next == NULL ? 0 :
-		       (unsigned long long)lr_ext_next->cle_ext.e_start,
-		       lr_ext_next == NULL ? 0 :
-		       (unsigned long long)lr_ext_next->cle_ext.e_end);
-#endif
-
 		if (split_required) {
 			rc = ext_split_internal(layer, lr_ext_to_insert_into,
 						&vec,
-- 
1.8.3.2

