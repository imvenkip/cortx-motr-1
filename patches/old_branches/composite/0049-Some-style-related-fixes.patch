From c68b7fde093efd9269effe941957fdd80b08659c Mon Sep 17 00:00:00 2001
From: "trupti.patil" <trupti_patil@xyratex.com>
Date: Mon, 14 Jan 2013 17:30:59 +0530
Subject: [PATCH 049/172] Some style related fixes

---
 layout/composite.c   | 241 +++++++++++++++++++++++++++------------------------
 layout/composite.h   |   3 +
 layout/layout_addb.h |   2 +
 layout/pdclust.h     |   3 +
 4 files changed, 138 insertions(+), 111 deletions(-)

diff --git a/layout/composite.c b/layout/composite.c
index 19f236c..d37307b 100644
--- a/layout/composite.c
+++ b/layout/composite.c
@@ -69,7 +69,7 @@ struct composite_schema_data {
 	 * Table to store extent maps for all the layers of all the composite
 	 * layouts.
 	 */
-	struct m0_emap  csd_layer_ext_map;
+	struct m0_emap  csd_layer_emap;
 };
 
 /**
@@ -124,9 +124,9 @@ static const struct m0_table_ops composite_table_ops = {
 };
 
 /**
- * Prefix for the layer_ext_map table. The prefix helps to identify an
- * extent map for a particular layer of a particular composite layout, from the
- * set of extent maps for all the layers of all the composite layouts.
+ * Prefix for the layer_emap table. The prefix helps to identify an extent map
+ * for a particular layer of a particular composite layout, from the set of
+ * extent maps for all the layers of all the composite layouts.
  */
 struct layout_prefix {
 	/**
@@ -263,12 +263,11 @@ err2_injected:
 
 	if (M0_FI_ENABLED("emap_init_err"))
 		{ rc = -EEXIST; goto err3_injected; }
-	rc = m0_emap_init(&csd->csd_layer_ext_map, dom->ld_dbenv,
-			  "layer_ext_map");
+	rc = m0_emap_init(&csd->csd_layer_emap, dom->ld_dbenv, "layer_emap");
 err3_injected:
 	if (rc != 0) {
 		m0_layout__log("composite_register",
-			       "failed to initialise layer_ext_map",
+			       "failed to initialise layer_emap",
 			       M0_LAYOUT_ADDB_LOC_COMP_REG_3, NULL, LID_NONE,
 			       rc);
 		m0_table_fini(&csd->csd_layer_sublayout);
@@ -293,7 +292,7 @@ static void composite_unregister(struct m0_layout_domain *dom,
 	M0_ENTRY("Layout_type_id %lu", (unsigned long)lt->lt_id);
 	csd = dom->ld_type_data[lt->lt_id];
 	m0_table_fini(&csd->csd_layer_sublayout);
-	m0_emap_fini(&csd->csd_layer_ext_map);
+	m0_emap_fini(&csd->csd_layer_emap);
 	dom->ld_type_data[lt->lt_id] = NULL;
 	m0_free(csd);
 	M0_LEAVE("Layout_type_id %lu", (unsigned long)lt->lt_id);
@@ -430,10 +429,10 @@ static void layer_in_memory_delete(struct m0_composite_layout *cl,
 		 (unsigned long long)cl->cl_base.l_id,
 		 (unsigned long)layer->clr_idx);
 
+	M0_CNT_DEC(cl->cl_layers_nr);
 	comp_layer_tlink_del_fini(layer);
 	m0_layout_user_count_dec(layer->clr_l);
 	m0_layout_put(layer->clr_l);
-	M0_CNT_DEC(cl->cl_layers_nr);
 	M0_POST(composite_invariant(cl));
 	M0_POST(layer->clr_idx == cl->cl_layers_nr);
 	M0_LEAVE();
@@ -510,9 +509,9 @@ static void extlist_free(struct m0_tl *extlist)
 /** Implementation of lo_fini for COMPOSITE layout type. */
 static void composite_fini(struct m0_ref *ref)
 {
-	struct m0_layout                 *l;
-	struct m0_composite_layout       *cl;
-	struct m0_composite_layer        *layer;
+	struct m0_layout           *l;
+	struct m0_composite_layout *cl;
+	struct m0_composite_layer  *layer;
 
 	l = container_of(ref, struct m0_layout, l_ref);
 	M0_PRE(m0_mutex_is_not_locked(&l->l_lock));
@@ -524,10 +523,14 @@ static void composite_fini(struct m0_ref *ref)
 	m0_tl_for(comp_layer, cl->cl_layers, layer) {
 		if (layer->clr_idx > 0) /* Except for the zeroth layer. */
 			extlist_free(layer->clr_extents);
+		comp_layer_tlink_del_fini(layer);
 		/* Release the reference acquired by layer_in_memory_add(). */
 		m0_layout_put(layer->clr_l);
-		comp_layer_tlist_del(layer);
-		comp_layer_tlink_fini(layer);
+		/*
+		 * The user count for the sublayout associated with this
+		 * particular layer gets decremented when the composite
+		 * layout gets deleted from the DB.
+		 */
 		m0_free(layer);
 	} m0_tl_endfor;
 	comp_layer_tlist_fini(cl->cl_layers);
@@ -535,7 +538,7 @@ static void composite_fini(struct m0_ref *ref)
 
 	m0_layout__fini(&cl->cl_base);
 	m0_free(cl);
-	M0_LEAVE();
+	M0_LEAVE("lid %llu", (unsigned long long)l->l_id);
 }
 
 M0_INTERNAL struct m0_composite_layout *m0_layout_to_cl(
@@ -555,7 +558,7 @@ M0_INTERNAL struct m0_layout *m0_cl_to_layout(struct m0_composite_layout *cl)
 }
 
 M0_INTERNAL struct m0_composite_instance *m0_layout_instance_to_ci(
-				const struct m0_layout_instance *li)
+					const struct m0_layout_instance *li)
 {
 	struct m0_composite_instance *ci;
 	ci = bob_of(li, struct m0_composite_instance, ci_base,
@@ -657,6 +660,7 @@ static int ext_in_memory_delete(struct m0_composite_layer *layer,
 	struct m0_composite_layer_extent *lr_ext;
 	struct m0_composite_layer_extent *lr_ext_to_delete;
 	bool                              lr_ext_to_delete_found;
+	int                               rc;
 
 	M0_ENTRY("lid %llu, layer %lu, e_start %llu, e_end %llu, "
 		 "old_e_state %llu",
@@ -683,9 +687,10 @@ static int ext_in_memory_delete(struct m0_composite_layer *layer,
 		m0_composite_layer_ext_tlink_fini(lr_ext_to_delete);
 		m0_free(lr_ext_to_delete);
 		M0_CNT_DEC(layer->clr_extents_nr);
-		M0_RETURN(0);
+		rc = 0;
 	} else
-		M0_RETURN(-ENOENT);
+		rc = -ENOENT;
+	M0_RETURN(rc);
 }
 
 static int ext_in_memory_find(struct m0_composite_layer *layer,
@@ -789,17 +794,14 @@ static int ext_in_memory_adjust(struct m0_composite_layer *layer,
 	if (seg->ee_val == M0_CLRES_INVALID)
 		M0_RETURN(0);
 
-	if (extent_op == DELETE) {
+	if (extent_op == DELETE)
 		/*
 		 * The extent seg->ee_ext is replaced by some newer extent.
 		 * Hence, seg->ee_ext is asked to be deleted.
 		 */
 		rc = ext_in_memory_delete(layer, &seg->ee_ext, seg->ee_val);
-	} else {
-		M0_ASSERT(M0_IN(extent_op, (CUT_LEFT, CUT_RIGHT)));
+	else
 		rc = ext_in_memory_trim(layer, extent_op, seg, ext);
-	}
-
 	M0_RETURN(rc);
 }
 #endif /* __KERNEL__ */
@@ -812,7 +814,7 @@ static int ext_in_memory_adjust(struct m0_composite_layer *layer,
  */
 static int ext_in_db_write(struct m0_emap_cursor *it,
 			   struct m0_composite_layer *layer,
-			   const struct m0_ext *ext_to_add,
+			   const struct m0_ext *ext_to_operate,
 			   uint64_t new_ext_state,
 			   bool in_memory_list_update)
 {
@@ -826,8 +828,8 @@ static int ext_in_db_write(struct m0_emap_cursor *it,
 		 "in_memory_list_update %d",
 		 (unsigned long long)layer->clr_l->l_id,
 		 (unsigned long)layer->clr_idx,
-		 (unsigned long long)ext_to_add->e_start,
-		 (unsigned long long)ext_to_add->e_end,
+		 (unsigned long long)ext_to_operate->e_start,
+		 (unsigned long long)ext_to_operate->e_end,
 		 (unsigned long long)new_ext_state,
 		 in_memory_list_update ? 1 : 0);
 
@@ -862,7 +864,7 @@ static int ext_in_db_write(struct m0_emap_cursor *it,
 	 *
 	 * In such a case, multiple small operations are performed internally
 	 * by m0_emap_paste() and the callbacks are sent appropriately. In
-	 * response to those callback, the in-memory list of extents is
+	 * response to those callback, the in-memory list of the extents is
 	 * adjusted accordingly by using the ext_in_memory_adjust() function.
 	 *
 	 * The sequence goes as follows:
@@ -882,14 +884,14 @@ static int ext_in_db_write(struct m0_emap_cursor *it,
 	 * When initial list of the extents is added to some layer, the list is
 	 * expected to be non-overlapping. And in that case, the list is first
 	 * stored into the in-memory list of the extents and then it is asked
-	 * to be adjusted in the DB version of it, using m0_emap_paste here.
+	 * to be adjusted in the DB version of it, using m0_emap_paste() here.
 	 * Thus, in that case, since the list is already up-to-date in the
 	 * in-memory version, there is nothing to be done through the calbacks
 	 * received from m0_emap_paste(). This is handled using the condition
-	 * around op.
+	 * around in_memory_list_update.
 	 */
 
-	ext = *ext_to_add;
+	ext = *ext_to_operate;
 	rc_cb = 0;
 	rc = m0_emap_paste(it, &ext, new_ext_state,
 		LAMBDA(void, (struct m0_emap_seg *seg) {
@@ -938,10 +940,10 @@ static int ext_in_db_write(struct m0_emap_cursor *it,
 		 * the in-memory list of the extents. Hence, the latter
 		 * condition above.
 		 */
-		rc = ext_in_memory_find(layer, ext_to_add, new_ext_state,
+		rc = ext_in_memory_find(layer, ext_to_operate, new_ext_state,
 					NULL);
 		if (rc == -ENOENT)
-			rc = ext_in_memory_add(layer, ext_to_add,
+			rc = ext_in_memory_add(layer, ext_to_operate,
 					       new_ext_state);
 	}
 	M0_RETURN(rc);
@@ -963,10 +965,8 @@ static int sublayout_id_in_db_read(struct m0_composite_layout *cl,
 	struct layer_sublayout_rec    rec;
 	int                           rc;
 
-	M0_ENTRY("lid %llu, layer %lu, sublayout_id %llu",
-		 (unsigned long long)cl->cl_base.l_id,
-		 (unsigned long)layer_idx,
-		 (unsigned long long)sublayout_id);
+	M0_ENTRY("lid %llu, layer %lu", (unsigned long long)cl->cl_base.l_id,
+		 (unsigned long)layer_idx);
 
 	csd = cl->cl_base.l_dom->ld_type_data[m0_composite_layout_type.lt_id];
 
@@ -1089,7 +1089,7 @@ static struct m0_emap *emap_from_cl(const struct m0_composite_layout *cl)
 	struct composite_schema_data *csd;
 
 	csd = cl->cl_base.l_dom->ld_type_data[m0_composite_layout_type.lt_id];
-	return &csd->csd_layer_ext_map;
+	return &csd->csd_layer_emap;
 }
 
 static int extmap_in_db_add(struct m0_composite_layout *cl,
@@ -1103,10 +1103,8 @@ static int extmap_in_db_add(struct m0_composite_layout *cl,
 	struct layout_prefix              prefix;
 	int                               rc;
 
-	M0_ENTRY("lid %llu, layer %lu, sublayout_id %llu",
-		 (unsigned long long)cl->cl_base.l_id,
-		 (unsigned long)layer->clr_idx,
-		 (unsigned long long)layer->clr_l->l_id);
+	M0_ENTRY("lid %llu, layer %lu", (unsigned long long)cl->cl_base.l_id,
+		 (unsigned long)layer->clr_idx);
 
 	emap = emap_from_cl(cl);
 	prefix_set(&prefix, cl->cl_base.l_id, layer->clr_idx);
@@ -1114,7 +1112,7 @@ static int extmap_in_db_add(struct m0_composite_layout *cl,
 				M0_CLRES_INVALID);
 	if (rc != 0) {
 		m0_layout__log("extmap_in_db_add",
-			       "failed to insert into layer_ext_map",
+			       "failed to insert into layer_emap",
 			       M0_LAYOUT_ADDB_LOC_COMP_LAYER_EMAP_ADD_1,
 			       &cl->cl_base.l_addb_ctx, cl->cl_base.l_id,
 			       rc);
@@ -1124,7 +1122,7 @@ static int extmap_in_db_add(struct m0_composite_layout *cl,
 	rc = m0_emap_lookup(emap, tx, (struct m0_uint128 *)&prefix, 0, &it);
 	if (rc != 0) {
 		m0_layout__log("extmap_in_db_add",
-			       "failed to lookup into layer_ext_map",
+			       "failed to lookup into layer_emap",
 			       M0_LAYOUT_ADDB_LOC_COMP_LAYER_EMAP_ADD_2,
 			       &cl->cl_base.l_addb_ctx, cl->cl_base.l_id,
 			       rc);
@@ -1168,12 +1166,14 @@ static int layer_in_db_add(struct m0_composite_layout *cl,
 	int rc;
 
 	M0_PRE(composite_invariant(cl));
-	/* Zeroth layer is already written through m0_layout_add(). */
+	/*
+	 * Zeroth layer is already written through comp_layout_in_db_add()
+	 * while adding the composite layout to the DB using m0_layout_add().
+	 */
 	M0_PRE(layer->clr_idx > 0);
 	M0_PRE(tx != NULL);
 
-	M0_ENTRY("lid %llu, layer %lu",
-		 (unsigned long long)cl->cl_base.l_id,
+	M0_ENTRY("lid %llu, layer %lu", (unsigned long long)cl->cl_base.l_id,
 		 (unsigned long)layer->clr_idx);
 
 	/* Add 'the sublayout id for this layer' to the DB. */
@@ -1230,7 +1230,7 @@ M0_INTERNAL int m0_composite_layer_add(struct m0_composite_layout *cl,
 	/*
 	 * The following fault injection point helps testing encode decode
 	 * operations on 'an in-memory composite layout with having some
-	 * layers added to it', without having dependency on the DB.
+	 * layers added to it', but without having dependency on the DB.
 	 */
 	if (M0_FI_ENABLED("skip_DB_sync")) { goto DB_sync_skipped; }
 
@@ -1256,19 +1256,19 @@ static struct m0_layout *layout_find(struct m0_layout_domain *dom,
 
 	sublayout = m0_layout_find(dom, lid);
 	/**
-	 * @todo Eventually, if the layout is not found in the cache, it shall
-	 * be fetched either from the DB or over the network, as applicable.
-	 * This needs:
+	 * @todo Eventually, if the sublayout is not found in the cache, it
+	 * shall be fetched either from the DB or over the network, as
+	 * applicable.
+	 * This requiress:
 	 * - The m0_layout_domain to include flags indicating is_db_available
 	 *   and is_network_available.
 	 * - The layout id to be extended to 128 bit to store the layout type,
 	 *   so that the DB lookup can be performed for it.
 	 *
-	 * Until the time above changes are implemented (through the task
-	 * "getattr changes for layout", lined up next to the current one),
-	 * the user shall ensure that the sublayouts are cached prior to
-	 * 'creating a composite layout and adding layers to it'. The following
-	 * assert ensures the same.
+	 * Until the time above changes are implemented (through a task lined
+	 * up next to the current one), the user shall ensure that the
+	 * sublayouts are cached prior to 'creating a composite layout and
+	 * adding layers to it'. The following assert ensures the same.
 	 *
 	 * Remove the following assert once the above mentioned changes
 	 * are implemented.
@@ -1289,8 +1289,8 @@ static int extlist_in_buf_read(struct m0_composite_layout *cl,
 	uint32_t                          i;
 
 	M0_ENTRY("lid %llu", (unsigned long long)cl->cl_base.l_id);
+	M0_PRE(m0_bufvec_cursor_step(cur) >= extents_nr * sizeof *ext);
 
-	/* Read the extent list owned by the specified layer. */
 	M0_ALLOC_PTR(extlist);
 	if (extlist == NULL) {
 		m0_layout__log("extlist_in_buf_read",
@@ -1302,7 +1302,6 @@ static int extlist_in_buf_read(struct m0_composite_layout *cl,
 	}
 	m0_composite_layer_ext_tlist_init(extlist);
 
-	M0_ASSERT(m0_bufvec_cursor_step(cur) >= extents_nr * sizeof *ext);
 	for (i = 0; i < extents_nr; ++i) {
 		M0_ALLOC_PTR(lr_ext);
 		if (lr_ext == NULL) {
@@ -1318,6 +1317,19 @@ static int extlist_in_buf_read(struct m0_composite_layout *cl,
 		m0_bufvec_cursor_move(cur, sizeof *ext);
 		ext_state = m0_bufvec_cursor_addr(cur);
 		m0_bufvec_cursor_move(cur, sizeof *ext_state);
+
+		if (m0_ext_is_empty(ext) ||
+		    !M0_IN(*ext_state, (M0_CLRES_VALID,
+				        M0_CLRES_FLATTENING))) {
+			m0_layout__log("extlist_in_buf_read",
+				       "Invalid extent found in the buffer",
+				       M0_LAYOUT_ADDB_LOC_COMP_ELIST_READ_3,
+				       &cl->cl_base.l_addb_ctx,
+				       cl->cl_base.l_id, -ENOMEM);
+			m0_free(lr_ext);
+			extlist_free(extlist);
+			return -EINVAL;
+		}
 		lr_ext->cle_ext = *ext;
 		lr_ext->cle_state = *ext_state;
 		m0_composite_layer_ext_tlink_init_at_tail(lr_ext, extlist);
@@ -1359,8 +1371,7 @@ static int comp_layout_in_buf_read(struct m0_composite_layout *cl,
 	for (i = 0; i < cl_header->ch_layers_nr; ++i) {
 		lr_header = m0_bufvec_cursor_addr(cur);
 		m0_bufvec_cursor_move(cur, sizeof *lr_header);
-		sublayout = layout_find(cl->cl_base.l_dom,
-					lr_header->clh_lid);
+		sublayout = layout_find(cl->cl_base.l_dom, lr_header->clh_lid);
 		if (sublayout == NULL) {
 			M0_LOG(M0_ERROR, "lid %llu, sublayout with lid %llu "
 			       "does not exist",
@@ -1391,7 +1402,7 @@ static int comp_layout_in_buf_read(struct m0_composite_layout *cl,
 		m0_layout_put(sublayout);
 
 		if (rc != 0)
-			M0_RETURN(rc);
+			break;
 	}
 	M0_RETURN(rc);
 }
@@ -1409,8 +1420,7 @@ static int extentmap_in_db_read(struct m0_composite_layout *cl,
 	struct m0_composite_layer_extent *lr_ext;
 	int                               rc;
 
-	M0_ENTRY("lid %llu, layer %lu",
-		 (unsigned long long)cl->cl_base.l_id,
+	M0_ENTRY("lid %llu, layer %lu", (unsigned long long)cl->cl_base.l_id,
 		 (unsigned long)layer_idx);
 
 	emap = emap_from_cl(cl);
@@ -1418,7 +1428,7 @@ static int extentmap_in_db_read(struct m0_composite_layout *cl,
 	rc = m0_emap_lookup(emap, tx, (struct m0_uint128 *)&prefix, 0, &it);
 	if (rc != 0) {
 		m0_layout__log("extentmap_in_db_read",
-			       "failed to lookup into layer_ext_map",
+			       "failed to lookup into layer_emap",
 			       M0_LAYOUT_ADDB_LOC_COMP_EMAP_READ_1,
 			       &cl->cl_base.l_addb_ctx, cl->cl_base.l_id, rc);
 		return rc;
@@ -1440,15 +1450,23 @@ static int extentmap_in_db_read(struct m0_composite_layout *cl,
 	seg = m0_emap_seg_get(&it);
 	while (1) {
 		M0_ASSERT(seg != NULL);
-		M0_ASSERT(!m0_ext_is_empty(&seg->ee_ext));
-		M0_ASSERT(M0_IN(seg->ee_val, (M0_CLRES_INVALID,
-					      M0_CLRES_VALID,
-					      M0_CLRES_FLATTENING)));
+		if (m0_ext_is_empty(&seg->ee_ext) ||
+		    !M0_IN(seg->ee_val, (M0_CLRES_INVALID, M0_CLRES_VALID,
+					 M0_CLRES_FLATTENING))) {
+			m0_layout__log("extentmap_in_db_read",
+				       "Invalid extent found in the DB",
+				       M0_LAYOUT_ADDB_LOC_COMP_EMAP_READ_3,
+				       &cl->cl_base.l_addb_ctx,
+				       cl->cl_base.l_id, -ENOMEM);
+			extlist_free(*extlist);
+			m0_emap_close(&it);
+			return -EINVAL;
+		}
 		M0_ALLOC_PTR(lr_ext);
 		if (lr_ext == NULL) {
 			m0_layout__log("extentmap_in_db_read",
 				       "failed to allocate composite extent",
-				       M0_LAYOUT_ADDB_LOC_COMP_EMAP_READ_3,
+				       M0_LAYOUT_ADDB_LOC_COMP_EMAP_READ_4,
 				       &cl->cl_base.l_addb_ctx,
 				       cl->cl_base.l_id, -ENOMEM);
 			extlist_free(*extlist);
@@ -1459,29 +1477,26 @@ static int extentmap_in_db_read(struct m0_composite_layout *cl,
 		lr_ext->cle_state = seg->ee_val;
 		M0_LOG(M0_DEBUG, "layer[%lu], extent[%lu] "
 		       "e_start %llu, e_end %llu, seg_val %llu",
-		       (unsigned long)layer_idx,
-		       (unsigned long)*extents_nr,
+		       (unsigned long)layer_idx, (unsigned long)*extents_nr,
 		       (unsigned long long)seg->ee_ext.e_start,
 		       (unsigned long long)seg->ee_ext.e_end,
 		       (unsigned long long)seg->ee_val);
 
-		if (seg->ee_val != M0_CLRES_INVALID) {
+		if (lr_ext->cle_state != M0_CLRES_INVALID) {
 			m0_composite_layer_ext_tlink_init_at_tail(lr_ext,
 								  *extlist);
 			M0_CNT_INC(*extents_nr);
 		}
 		if (m0_emap_ext_is_last(&seg->ee_ext))
 			break;
-
 		m0_emap_next(&it);
 		seg = m0_emap_seg_get(&it);
 	}
-
 	m0_emap_close(&it);
 
 	M0_POST(ergo(*extents_nr > 0,
 		     !m0_composite_layer_ext_tlist_is_empty(*extlist)));
-	return rc;
+	M0_RETURN(rc);
 }
 
 /* Reads layers from the DB, starting from the layer with index as 1. */
@@ -1498,23 +1513,25 @@ static int layers_in_db_read(struct m0_composite_layout *cl,
 
 	M0_ENTRY("lid %llu", (unsigned long long)cl->cl_base.l_id);
 
-	//todo Optimise the number of return statements
 	i = 1;
 	while (1) {
 		/* Read 'the sublayout id for this layer' from the DB. */
 		rc = sublayout_id_in_db_read(cl, i, tx, &sublayout_id);
-		if (rc == -ENOENT) {
-			/*
-			 * The number of layers is not known in advance. So,
-			 * break when the first -ENOENT error is encountered.
-			 */
-			M0_RETURN(0);
-		} else if (rc != 0) {
-			M0_LOG(M0_ERROR, "lid %llu, layer %lu, sublayout id "
-			       "could not be read from DB",
-			       (unsigned long long)cl->cl_base.l_id,
-			       (unsigned long)i);
-			return rc;
+		if (rc != 0) {
+			if (rc == -ENOENT)
+				/*
+				 * The number of layers is not known in
+				 * advance. Hence, break when the first
+				 * -ENOENT error is encountered.
+				 */
+				rc = 0;
+			else
+				M0_LOG(M0_ERROR, "lid %llu, layer %lu, "
+				       "sublayout id could not be read from "
+				       "the DB",
+				       (unsigned long long)cl->cl_base.l_id,
+				       (unsigned long)i);
+			break;
 		}
 
 		sublayout = layout_find(cl->cl_base.l_dom, sublayout_id);
@@ -1524,7 +1541,8 @@ static int layers_in_db_read(struct m0_composite_layout *cl,
 			       (unsigned long long)cl->cl_base.l_id,
 			       (unsigned long)i,
 			       (unsigned long long)sublayout_id);
-			return -EINVAL;
+			rc = -EINVAL;
+			break;
 		}
 
 		/* Read 'the extent map for this layer' from the DB. */
@@ -1536,7 +1554,7 @@ static int layers_in_db_read(struct m0_composite_layout *cl,
 			       (unsigned long)i);
 			/* Release the reference added by m0_layout_find(). */
 			m0_layout_put(sublayout);
-			return rc;
+			break;
 		}
 
 		/* Now, write the layer to the in-memory layout. */
@@ -1549,7 +1567,7 @@ static int layers_in_db_read(struct m0_composite_layout *cl,
 			       (unsigned long)i);
 			/* Release the reference added by m0_layout_find(). */
 			m0_layout_put(sublayout);
-			return rc;
+			break;
 		}
 		M0_ASSERT(layer->clr_idx > 0);
 
@@ -1558,6 +1576,7 @@ static int layers_in_db_read(struct m0_composite_layout *cl,
 		 * layer_in_memory_add() has now added a reference on this
 		 * sublayout.
 		 */
+		M0_ASSERT(rc ==0);
 		m0_layout_put(sublayout);
 
 		++i;
@@ -1580,7 +1599,6 @@ static int comp_layout_in_db_read(struct m0_composite_layout *cl,
 
 	M0_ENTRY("lid %llu", (unsigned long long)cl->cl_base.l_id);
 
-	//todo Optimise no of return statements
 	rc = sublayout_id_in_db_read(cl, 0, tx, &sublayout_id);
 	if (rc != 0) {
 		M0_LOG(M0_ERROR, "lid %llu, layer 0, sublayout id could not "
@@ -1747,7 +1765,7 @@ static void comp_layout_in_buf_write(const struct m0_composite_layout *cl,
 	 * it in the buffer.
 	 */
 	M0_ASSERT(m0_bufvec_cursor_step(out) >= cl->cl_layers_nr *
-						sizeof lr_header);
+		  sizeof lr_header);
 	m0_tl_for(comp_layer, cl->cl_layers, layer) {
 		lr_header.clh_lid = layer->clr_l->l_id;
 		lr_header.clh_idx = layer->clr_idx;
@@ -1759,13 +1777,13 @@ static void comp_layout_in_buf_write(const struct m0_composite_layout *cl,
 			continue;
 		m0_tl_for(m0_composite_layer_ext, layer->clr_extents, lr_ext) {
 			nbytes = m0_bufvec_cursor_copyto(out,
-						&lr_ext->cle_ext,
-						sizeof lr_ext->cle_ext);
+							&lr_ext->cle_ext,
+							sizeof lr_ext->cle_ext);
 			M0_ASSERT(nbytes == sizeof lr_ext->cle_ext);
 
 			nbytes = m0_bufvec_cursor_copyto(out,
-						&lr_ext->cle_state,
-						sizeof(lr_ext->cle_state));
+						     &lr_ext->cle_state,
+						     sizeof(lr_ext->cle_state));
 			M0_ASSERT(nbytes == sizeof(lr_ext->cle_state));
 		} m0_tl_endfor;
 	} m0_tl_endfor;
@@ -1864,8 +1882,7 @@ M0_INTERNAL int m0_composite_layer_ext_lookup(struct m0_composite_layout *cl,
 	int                        rc;
 
 	M0_PRE(composite_invariant(cl));
-	M0_ENTRY("lid %llu, offset %llu",
-		 (unsigned long long)cl->cl_base.l_id,
+	M0_ENTRY("lid %llu, offset %llu", (unsigned long long)cl->cl_base.l_id,
 		 (unsigned long long)offset);
 	m0_mutex_lock(&cl->cl_base.l_lock);
 	emap = emap_from_cl(cl);
@@ -1873,14 +1890,13 @@ M0_INTERNAL int m0_composite_layer_ext_lookup(struct m0_composite_layout *cl,
 	/* Start the lookup with the top-most layer. */
 	i = cl->cl_layers_nr - 1;
 	found = false;
-
 	while (1) {
 		prefix_set(&prefix, cl->cl_base.l_id, i);
 		rc = m0_emap_lookup(emap, tx, (struct m0_uint128 *)&prefix,
 				    offset, &it);
 		if (rc != 0) {
 			m0_layout__log("m0_composite_layer_ext_lookup",
-				       "failed to lookup into layer_ext_map",
+				       "failed to lookup into layer_emap",
 				       M0_LAYOUT_ADDB_LOC_COMP_EXT_LOOKUP,
 				       &cl->cl_base.l_addb_ctx,
 				       cl->cl_base.l_id, rc);
@@ -1891,6 +1907,11 @@ M0_INTERNAL int m0_composite_layer_ext_lookup(struct m0_composite_layout *cl,
 		seg = m0_emap_seg_get(&it);
 		m0_emap_close(&it);
 		M0_ASSERT(seg != NULL);
+		/*
+		 * todo If this function continues to lookup directly from the
+		 * DB, then the following two conditions shall not be asserted
+		 * against, but shall be handled.
+		 */
 		M0_ASSERT(!m0_ext_is_empty(&seg->ee_ext));
 		M0_ASSERT(M0_IN(seg->ee_val, (M0_CLRES_INVALID,
 					      M0_CLRES_VALID,
@@ -1953,7 +1974,7 @@ M0_INTERNAL int m0_composite_layer_ext_add(struct m0_composite_layout *cl,
 			    ext->e_start, &it);
 	if (rc != 0) {
 		m0_layout__log("m0_composite_layer_ext_add",
-			       "failed to lookup into layer_ext_map",
+			       "failed to lookup into layer_emap",
 			       M0_LAYOUT_ADDB_LOC_COMP_EXT_ADD_1,
 			       &cl->cl_base.l_addb_ctx, cl->cl_base.l_id, rc);
 		m0_mutex_unlock(&cl->cl_base.l_lock);
@@ -2015,8 +2036,7 @@ M0_INTERNAL int m0_composite_layer_ext_state_update(
 	M0_ENTRY("lid %llu, layer %lu, e_start %llu, e_end %llu, e_state %llu",
 		 (unsigned long long)cl->cl_base.l_id,
 		 (unsigned long)layer_idx, (unsigned long long)ext->e_start,
-		 (unsigned long long)ext->e_end,
-		 (unsigned long long)ext_state);
+		 (unsigned long long)ext->e_end, (unsigned long long)ext_state);
 
 	m0_mutex_lock(&cl->cl_base.l_lock);
 	layer = layer_find(cl, layer_idx);
@@ -2026,7 +2046,7 @@ M0_INTERNAL int m0_composite_layer_ext_state_update(
 			    ext->e_start, &it);
 	if (rc != 0) {
 		m0_layout__log("m0_composite_layer_ext_state_update",
-			       "failed to lookup into layer_ext_map",
+			       "failed to lookup into layer_emap",
 			       M0_LAYOUT_ADDB_LOC_COMP_EXT_UPDATE_1,
 			       &cl->cl_base.l_addb_ctx, cl->cl_base.l_id, rc);
 		m0_mutex_unlock(&cl->cl_base.l_lock);
@@ -2038,8 +2058,7 @@ M0_INTERNAL int m0_composite_layer_ext_state_update(
 	 * can not be performed on a non-existing extent.
 	 */
 	seg = m0_emap_seg_get(&it);
-	M0_ASSERT(M0_IN(seg->ee_val, (M0_CLRES_INVALID,
-				      M0_CLRES_VALID,
+	M0_ASSERT(M0_IN(seg->ee_val, (M0_CLRES_INVALID, M0_CLRES_VALID,
 				      M0_CLRES_FLATTENING)));
 	if (seg->ee_ext.e_start != ext->e_start ||
 	    seg->ee_ext.e_end != ext->e_end ||
@@ -2113,7 +2132,7 @@ M0_INTERNAL int m0_composite_layer_ext_delete(struct m0_composite_layout *cl,
 			    ext->e_start, &it);
 	if (rc != 0) {
 		m0_layout__log("m0_composite_layer_ext_delete",
-			       "failed to lookup into layer_ext_map",
+			       "failed to lookup into layer_emap",
 			       M0_LAYOUT_ADDB_LOC_COMP_EXT_DEL_1,
 			       &cl->cl_base.l_addb_ctx, cl->cl_base.l_id, rc);
 		m0_mutex_unlock(&cl->cl_base.l_lock);
@@ -2160,10 +2179,10 @@ M0_INTERNAL void composite_instance_fini(struct m0_layout_instance *li);
 /**
  * Implementation of lo_instance_build().
  *
- * Allocates and builds a composite layout instance using the
- * supplied layout 'l' that is necessarily of the type composite. It acquires
- * an additional reference on that layout.
- * @pre composite_invariant(pl)
+ * Allocates and builds a composite layout instance using the supplied layout
+ * 'l' that is necessarily of the type composite. It acquires an additional
+ * reference on that layout.
+ * @pre composite_invariant(cl)
  * @post ergo(rc == 0, composite_instance_invariant(*out) &&
  *            m0_ref_read(&l->l_ref) > 1))
  */
diff --git a/layout/composite.h b/layout/composite.h
index 29e05ae..4229c5f 100644
--- a/layout/composite.h
+++ b/layout/composite.h
@@ -213,6 +213,9 @@ struct m0_composite_instance {
  *
  * In short:
  * Dual to m0_layout_put() when it is the last reference being released.
+ *
+ * @note Until the time layout is integrated with RM, it is the responsibilty
+ * of the user to ensure that the lid is unique.
  */
 M0_INTERNAL int m0_composite_build(struct m0_layout_domain *dom,
 				   uint64_t lid,
diff --git a/layout/layout_addb.h b/layout/layout_addb.h
index 827b34d..c37f73c 100644
--- a/layout/layout_addb.h
+++ b/layout/layout_addb.h
@@ -102,9 +102,11 @@ enum {
 	M0_LAYOUT_ADDB_LOC_COMP_LAYER_ADD_3        = 282,
 	M0_LAYOUT_ADDB_LOC_COMP_ELIST_READ_1       = 290,
 	M0_LAYOUT_ADDB_LOC_COMP_ELIST_READ_2       = 291,
+	M0_LAYOUT_ADDB_LOC_COMP_ELIST_READ_3       = 292,
 	M0_LAYOUT_ADDB_LOC_COMP_EMAP_READ_1        = 300,
 	M0_LAYOUT_ADDB_LOC_COMP_EMAP_READ_2        = 301,
 	M0_LAYOUT_ADDB_LOC_COMP_EMAP_READ_3        = 302,
+	M0_LAYOUT_ADDB_LOC_COMP_EMAP_READ_4        = 303,
 	M0_LAYOUT_ADDB_LOC_COMP_EXT_LOOKUP         = 310,
 	M0_LAYOUT_ADDB_LOC_COMP_EXT_ADD_1          = 320,
 	M0_LAYOUT_ADDB_LOC_COMP_EXT_ADD_2          = 321,
diff --git a/layout/pdclust.h b/layout/pdclust.h
index 9b3f5e6..4617646 100644
--- a/layout/pdclust.h
+++ b/layout/pdclust.h
@@ -257,6 +257,9 @@ struct m0_pdclust_tgt_addr {
  *
  * In short:
  * Dual to m0_layout_put() when it is the last reference being released.
+ *
+ * @note Until the time layout is integrated with RM, it is the responsibilty
+ * of the user to ensure that the lid is unique.
  */
 M0_INTERNAL int m0_pdclust_build(struct m0_layout_domain *dom,
 				 uint64_t lid,
-- 
1.8.3.2

