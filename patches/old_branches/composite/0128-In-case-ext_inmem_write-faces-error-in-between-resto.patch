From afc27f13f9c4070e9d53e21ec58b6a4f469573e9 Mon Sep 17 00:00:00 2001
From: "trupti.patil" <trupti_patil@xyratex.com>
Date: Thu, 2 May 2013 12:27:53 +0530
Subject: [PATCH 128/172] In case ext_inmem_write() faces error in between,
 restore the original extlist.

This requires making a copy of the original extent list before it is attempted
to be manipulated.
---
 layout/composite.c         | 133 ++++++++++------
 layout/ut/composite.c      | 388 +++++++++++++--------------------------------
 layout/ut/layout.c         |  19 ++-
 layout/ut/layout.h         |   4 +-
 layout/ut/layout_generic.c |  34 +++-
 layout/ut/pdclust.c        |   8 +-
 layout/ut/pdclust.h        |   2 +-
 7 files changed, 244 insertions(+), 344 deletions(-)

diff --git a/layout/composite.c b/layout/composite.c
index d0744b8..efe4d5a 100644
--- a/layout/composite.c
+++ b/layout/composite.c
@@ -101,8 +101,9 @@ enum extent_add_position {
 /** Flags used for better readability. */
 enum {
 	IN_UPDATE_PATH       = true,
-	EXT_MERGE_VALIDATION = 11, /* Some random number other than 0 and 1. */
-	EXT_DEL_VALIDATION   = 12  /* Another random number. */
+	EXT_MERGE_VALIDATION = 11,  /* Some random number other than 0 and 1. */
+	EXT_DEL_VALIDATION   = 12,  /* Another random number. */
+	EXTLIST_FINI         = true /* Finalise the extlist while freeing it */
 };
 
 M0_TL_DESCR_DEFINE(comp_layer, "composite-layer-list",
@@ -362,7 +363,7 @@ static int layer_inmem_add(struct m0_composite_layout *cl,
 	M0_RETURN(0);
 }
 
-static void extlist_free(struct m0_tl *extlist)
+static void extlist_free(struct m0_tl *extlist, bool is_fini)
 {
 	struct m0_composite_layer_extent *lr_ext;
 
@@ -370,7 +371,8 @@ static void extlist_free(struct m0_tl *extlist)
 		m0_composite_layer_ext_tlink_del_fini(lr_ext);
 		m0_free(lr_ext);
 	} m0_tl_endfor;
-	m0_composite_layer_ext_tlist_fini(extlist);
+	if (is_fini)
+		m0_composite_layer_ext_tlist_fini(extlist);
 }
 
 /** Deletes the top-most layer from the in-memory layout. */
@@ -383,7 +385,7 @@ static void layer_inmem_delete(struct m0_composite_layout *cl,
 	comp_layer_tlink_del_fini(layer);
 	M0_CNT_DEC(cl->cl_layers_nr);
 	m0_layout_put(layer->clr_sl);
-	extlist_free(&layer->clr_extents);
+	extlist_free(&layer->clr_extents, EXTLIST_FINI);
 	M0_POST(layer->clr_idx == cl->cl_layers_nr);
 	m0_free(layer);
 	M0_LEAVE("lid %llu", (unsigned long long)cl->cl_base.l_id);
@@ -658,7 +660,8 @@ static int sublayout_ids_inbuf_read(struct m0_composite_layout *cl,
 static void ext_inmem_del(struct m0_composite_layer *layer,
 			  struct m0_composite_layer_extent *lr_ext);
 static int ext_inmem_add_internal(
-			struct m0_composite_layer *layer,
+			struct m0_tl *extlist,
+			struct m0_layout *l,
 			const struct m0_ext *ext,
 			enum m0_composite_layer_ext_state ext_state,
 			uint32_t add_position,
@@ -723,7 +726,8 @@ static int extents_inbuf_read(struct m0_composite_layout *cl,
 				       cl->cl_base.l_id, -ENOMEM);
 			return -EINVAL;
 		}
-		rc = ext_inmem_add_internal(layer, &buf_ext->lbe_ext,
+		rc = ext_inmem_add_internal(&layer->clr_extents, &cl->cl_base,
+					    &buf_ext->lbe_ext,
 					    buf_ext->lbe_state,
 					    ADD_AT_TAIL, NULL);
 		if (rc != 0) {
@@ -733,6 +737,8 @@ static int extents_inbuf_read(struct m0_composite_layout *cl,
 			return rc;
 		}
 	}
+	layer->clr_extents_nr =  m0_composite_layer_ext_tlist_length(
+							&layer->clr_extents);
 	M0_POST(composite_invariant(cl));
 	M0_RETURN(rc);
 }
@@ -1044,21 +1050,19 @@ static int ext_inmem_find(struct m0_composite_layer *layer,
 	M0_RETURN(rc);
 }
 
-/**
- * Adds an extent to the extent list associated with the provided layer,
- * while position ot add at has been supplied.
- */
+/** Adds an extent to the provided extent list, at the provided position. */
 static int ext_inmem_add_internal(
-			struct m0_composite_layer *layer,
+			struct m0_tl *extlist,
+			struct m0_layout *l,
 			const struct m0_ext *ext,
 			enum m0_composite_layer_ext_state ext_state,
 			uint32_t add_position,
 			struct m0_composite_layer_extent *adjacent_lr_ext)
 {
 	struct m0_composite_layer_extent *lr_ext;
-	struct m0_layout                 *l;
 
-	M0_PRE(layer != NULL);
+	M0_PRE(extlist != NULL);
+	M0_PRE(m0_layout__invariant(l));
 	M0_PRE(!m0_ext_is_empty(ext));
 	M0_PRE(M0_IN(ext_state, (M0_CLRES_HOLE, M0_CLRES_VALID,
 				 M0_CLRES_FLATTENING)));
@@ -1068,12 +1072,10 @@ static int ext_inmem_add_internal(
 		    m0_composite_layer_ext_tlink_is_in(adjacent_lr_ext)));
 	M0_PRE(ergo(add_position == ADD_AT_TAIL, adjacent_lr_ext == NULL));
 
-	l = layer->clr_cl;
-	M0_ENTRY("lid %llu, layer %lu , e_start %llu, e_end %llu, "
+	M0_ENTRY("lid %llu, e_start %llu, e_end %llu, "
 		 "e_state %llu, add_position %lu, "
 		 "adjacent_ext_start %llu, adjacent_ext_end %llu",
 		 (unsigned long long)l->l_id,
-		 (layer == NULL) ? 0 : (unsigned long)layer->clr_idx,
 		 (unsigned long long)ext->e_start,
 		 (unsigned long long)ext->e_end, (unsigned long long)ext_state,
 		 (unsigned long)add_position,
@@ -1102,14 +1104,12 @@ static int ext_inmem_add_internal(
 			m0_composite_layer_ext_tlist_add_before(adjacent_lr_ext,
 								lr_ext);
 	} else
-		m0_composite_layer_ext_tlink_init_at_tail(lr_ext,
-							  &layer->clr_extents);
+		m0_composite_layer_ext_tlink_init_at_tail(lr_ext, extlist);
 
-	if (layer != NULL)
-		M0_CNT_INC(layer->clr_extents_nr);
 	M0_RETURN(0);
 }
 
+
 /**
  * Finds a position to add at and adds the extent to the extent list associated
  * with the provided layer.
@@ -1144,15 +1144,22 @@ static int ext_inmem_add(struct m0_composite_layer *layer,
 	} m0_tl_endfor;
 
 	if (lr_ext_to_insert_after != NULL)
-		rc = ext_inmem_add_internal(layer, ext, ext_state, ADD_AFTER,
+		rc = ext_inmem_add_internal(&layer->clr_extents,
+					    layer->clr_cl, ext, ext_state,
+					    ADD_AFTER,
 					    lr_ext_to_insert_after);
 	else if (lr_ext_to_insert_before != NULL)
-		rc = ext_inmem_add_internal(layer, ext, ext_state, ADD_BEFORE,
+		rc = ext_inmem_add_internal(&layer->clr_extents,
+					    layer->clr_cl, ext, ext_state,
+					    ADD_BEFORE,
 					    lr_ext_to_insert_before);
 	else
-		rc = ext_inmem_add_internal(layer, ext, ext_state, ADD_AT_TAIL,
-					    NULL);
-	if (rc != 0)
+		rc = ext_inmem_add_internal(&layer->clr_extents,
+					    layer->clr_cl, ext, ext_state,
+					    ADD_AT_TAIL, NULL);
+	if (rc == 0)
+		M0_CNT_INC(layer->clr_extents_nr);
+	else
 		M0_LOG(M0_ERROR, "lid %llu, extent could not be added to "
 		       "memory", (unsigned long long)layer->clr_cl->l_id);
 	M0_RETURN(rc);
@@ -1270,10 +1277,13 @@ static int ext_split_internal(struct m0_composite_layer *layer,
 		if (len != 0) {
 			ext.e_start = scan;
 			ext.e_end = scan = scan + len;
-			rc = ext_inmem_add_internal(layer, &ext,
+			rc = ext_inmem_add_internal(&layer->clr_extents,
+						    layer->clr_cl, &ext,
 						    vec->iv_index[i],
 						    ADD_BEFORE, lr_ext);
-			if (rc != 0) {
+			if (rc == 0)
+				M0_CNT_INC(layer->clr_extents_nr);
+			else {
 				M0_LOG(M0_ERROR, "lid %llu, Extent could not "
 				       "be added to memory",
 				       (unsigned long long)
@@ -1396,6 +1406,7 @@ static int ext_inmem_write(struct m0_composite_layout *cl,
 			   enum m0_composite_layer_ext_state new_ext_state,
 			   uint32_t ext_validation_kind)
 {
+	uint64_t                          lid;
 	struct m0_composite_layer_extent *lr_ext;
 	struct m0_composite_layer_extent *lr_ext_next;
 	struct m0_composite_layer_extent *lr_ext_to_del;
@@ -1403,12 +1414,14 @@ static int ext_inmem_write(struct m0_composite_layout *cl,
 	struct m0_ext                    *chunk;
 	struct m0_ext                     ext0 = *ext; /* A read-write copy. */
 	bool                              is_ultimate_ext_add;
+	struct m0_tl                      extents_copy;
 	int                               rc;
 	int                               rc1;
 
 	M0_PRE(composite_invariant(cl));
 	M0_PRE(!m0_ext_is_empty(ext));
 
+	lid = cl->cl_base.l_id;
 	/* Validate the 'ext' and find the nearest extent from the list. */
 	rc = ext_inmem_validate(cl, layer, ext, new_ext_state,
 			        ext_validation_kind, &lr_ext_to_insert_into);
@@ -1432,8 +1445,7 @@ static int ext_inmem_write(struct m0_composite_layout *cl,
 	    lr_ext_to_insert_into->cle_state == new_ext_state) {
 		/* The exact extent already exists. So, nothing to be done. */
 		rc = 0;
-		M0_LEAVE("lid %llu, layer %lu, rc %d",
-			 (unsigned long long)cl->cl_base.l_id,
+		M0_LEAVE("lid %llu, layer %lu, rc %d", (unsigned long long)lid,
 			 (unsigned long)layer->clr_idx, rc);
 		return rc;
 	}
@@ -1444,8 +1456,7 @@ static int ext_inmem_write(struct m0_composite_layout *cl,
 		/* The exact extent already exists but with different state. */
 		lr_ext_to_insert_into->cle_state = new_ext_state;
 		rc = 0;
-		M0_LEAVE("lid %llu, layer %lu, rc %d",
-			 (unsigned long long)cl->cl_base.l_id,
+		M0_LEAVE("lid %llu, layer %lu, rc %d", (unsigned long long)lid,
 			 (unsigned long)layer->clr_idx, rc);
 		return rc;
 	}
@@ -1454,6 +1465,27 @@ static int ext_inmem_write(struct m0_composite_layout *cl,
 	M0_ASSERT(m0_ext_is_in(chunk, ext->e_start));
 
 	/*
+	 * It is possible that part of the overlapping extent has been changed
+	 * and then some error encounters. In such a case, it is required
+	 * to restore the original extent list. Hence, make a copy of the
+	 * original extent list.
+	 */
+	m0_composite_layer_ext_tlist_init(&extents_copy);
+	m0_tl_for(m0_composite_layer_ext, &layer->clr_extents, lr_ext) {
+		rc = ext_inmem_add_internal(&extents_copy, &cl->cl_base,
+					    &lr_ext->cle_ext,
+					    lr_ext->cle_state, ADD_AT_TAIL,
+					    NULL);
+		if (rc != 0) {
+			extlist_free(&extents_copy, EXTLIST_FINI);
+			M0_LEAVE("lid %llu, layer %lu, rc %d",
+				 (unsigned long long)lid,
+				 (unsigned long)layer->clr_idx, rc);
+			return rc;
+		}
+	} m0_tl_endfor;
+
+	/*
 	 * Iterate over the existing extents overlapping with the new one,
 	 * calculating for each, what parts have to be deleted and what remains.
 	 *
@@ -1471,7 +1503,6 @@ static int ext_inmem_write(struct m0_composite_layout *cl,
 	 * functioning of m0_emap_paste()', see the note added in
 	 * ext_indb_write().
 	 */
-
 	is_ultimate_ext_add = false;
 	while (!m0_ext_is_empty(&ext0)) {
 		m0_bcount_t    length[3];
@@ -1568,21 +1599,21 @@ static int ext_inmem_write(struct m0_composite_layout *cl,
 	}
 
 	if (rc == 0) {
+		/* The extent has to be present in the list, at this time. */
 		rc1 = ext_inmem_find(layer, ext, new_ext_state, &lr_ext);
 		M0_POST(rc1 == 0);
-		/*
-		 * In case this function ext_inmem_write() has come across
-		 * errors other than -EINVAL, e.g. -ENOMEM, then it is unlikely
-		 * that we will be able to restore the original extent list
-		 * even if we might have kept track of it. Hence, it is not
-		 * attempted to restore the original extent list in case of
-		 * failure, thus sacrificing the layer_invariant() and in turn
-		 * the composite_invariant() in that case.
-		 */
-		M0_POST(composite_invariant(cl));
+		extlist_free(&extents_copy, EXTLIST_FINI);
+	} else {
+		/* Restore the original extent list. */
+		extlist_free(&layer->clr_extents, !EXTLIST_FINI);
+		m0_tlist_splice(&m0_composite_layer_ext_tl,
+			        &layer->clr_extents, &extents_copy);
+		layer->clr_extents_nr = m0_composite_layer_ext_tlist_length(
+							&layer->clr_extents);
+		M0_ASSERT(layer->clr_extents_nr > 0);
 	}
-	M0_LEAVE("lid %llu, layer %lu, rc %d",
-		 (unsigned long long)cl->cl_base.l_id,
+	M0_POST(composite_invariant(cl));
+	M0_LEAVE("lid %llu, layer %lu, rc %d", (unsigned long long)lid,
 		 (unsigned long)layer->clr_idx, rc);
 	return rc;
 }
@@ -1903,6 +1934,7 @@ static int extents_indb_read(struct m0_composite_layout *cl,
 			     struct m0_composite_layer *layer,
 			     struct m0_db_tx *tx)
 {
+	struct m0_layout                 *l;
 	struct m0_composite_layer_extent *lr_ext;
 	struct m0_emap                   *emap;
 	struct m0_emap_cursor             it;
@@ -1921,11 +1953,12 @@ static int extents_indb_read(struct m0_composite_layout *cl,
 		 lr_ext->cle_ext.e_end == M0_BINDEX_MAX + 1);
 	ext_inmem_del(layer, lr_ext);
 
+	l = &cl->cl_base;
 	emap = emap_from_cl(cl);
 	rc = emap_iterator_set(cl, emap, layer->clr_idx, 0, tx, &it);
 	if (rc != 0) {
 		M0_LEAVE("lid %llu, layer %lu, rc %d",
-			 (unsigned long long)cl->cl_base.l_id,
+			 (unsigned long long)l->l_id,
 			 (unsigned long)layer->clr_idx, rc);
 		return rc;
 	}
@@ -1941,12 +1974,12 @@ static int extents_indb_read(struct m0_composite_layout *cl,
 			m0_layout__log("extents_indb_read",
 				       "Invalid extent found in the DB",
 				       M0_LAYOUT_ADDB_LOC_COMP_EMAP_READ_3,
-				       &cl->cl_base.l_addb_ctx,
-				       cl->cl_base.l_id, -ENOMEM);
+				       &l->l_addb_ctx, l->l_id, -ENOMEM);
 			break;
 		}
 
-		rc = ext_inmem_add_internal(layer, &seg->ee_ext, seg->ee_val,
+		rc = ext_inmem_add_internal(&layer->clr_extents, l,
+					    &seg->ee_ext, seg->ee_val,
 					    ADD_AT_TAIL, NULL);
 		if (rc != 0)
 			break;
@@ -1956,6 +1989,8 @@ static int extents_indb_read(struct m0_composite_layout *cl,
 		m0_emap_next(&it);
 		seg = m0_emap_seg_get(&it);
 	}
+	layer->clr_extents_nr =  m0_composite_layer_ext_tlist_length(
+							&layer->clr_extents);
 	m0_emap_close(&it);
 	M0_RETURN(rc);
 }
diff --git a/layout/ut/composite.c b/layout/ut/composite.c
index d2a2bfc..fc6843f 100644
--- a/layout/ut/composite.c
+++ b/layout/ut/composite.c
@@ -64,7 +64,7 @@ static void sublayout_build(uint64_t lid, struct m0_layout_domain *domain,
 }
 
 /*
- * For the layer_nr number of layers to be added to a composite layout,
+ * For the 'layers_nr number of layers' to be added to a composite layout,
  * this function creates "layer_nr - 1" number of layouts with their
  * respective lid. One layer that is the zeroth layer is already added to the
  * composite layout when the composite layout got created.
@@ -132,7 +132,7 @@ static void sublayouts_delete(struct m0_layout_domain *domain,
  */
 static void extentlist_build(struct m0_tl *extents,
 			     uint32_t extents_nr,
-			     bool if_contiguous_extents)
+			     bool is_contiguous_extents)
 {
 	struct m0_composite_layer_extent *lr_ext;
 	m0_bindex_t                       delta;
@@ -156,7 +156,7 @@ static void extentlist_build(struct m0_tl *extents,
 		else
 			lr_ext->cle_ext.e_end = lr_ext->cle_ext.e_start + delta;
 
-		if (if_contiguous_extents || i % 2 == 0)
+		if (is_contiguous_extents || i % 2 == 0)
 			lr_ext->cle_state = M0_CLRES_VALID;
 		else
 			/* Make every alternate extent a hole. */
@@ -182,7 +182,8 @@ static void composite_layout_verify(struct m0_layout *l,
 				    uint64_t composite_lid,
 				    uint32_t layers_nr,
 				    uint32_t min_extents_nr,
-				    bool if_contiguous_extents)
+				    bool is_contiguous_extents,
+				    bool is_user_count_incremented)
 {
 	bool                              inline_test;
 	uint64_t                          sublayout_id;
@@ -204,7 +205,7 @@ static void composite_layout_verify(struct m0_layout *l,
 
 	/* Verify the generic layout data. */
 	cl = m0_layout_to_cl(l);
-	l_verify(l, composite_lid, !USER_COUNT_INCREMENTED);
+	l_verify(l, composite_lid, is_user_count_incremented);
 
 	/* Verify the composite type specific data. */
 	m0_uint128_init(&seed, "sublayouts_build");
@@ -224,10 +225,7 @@ static void composite_layout_verify(struct m0_layout *l,
 		pdclust_layout_verify(layer->clr_sl, sublayout_id, enum_id,
 				      N, K, P, &seed, 10, 20,
 				      !USER_COUNT_INCREMENTED);
-		// todo check l_verify() for a comment
-		//M0_UT_ASSERT(layer->clr_sl->l_user_count == 0);
 		M0_UT_ASSERT(layer->clr_idx == i);
-
 		M0_UT_ASSERT(layer->clr_extents_nr == extents_nr);
 
 		/* Verify the extents. */
@@ -239,7 +237,7 @@ static void composite_layout_verify(struct m0_layout *l,
 			M0_UT_ASSERT(lr_ext->cle_ext.e_end ==
 				     lr_ext->cle_ext.e_start + delta ||
 				     lr_ext->cle_ext.e_end == END_OFFSET);
-			if (if_contiguous_extents || j % 2 == 0)
+			if (is_contiguous_extents || j % 2 == 0)
 				M0_UT_ASSERT(lr_ext->cle_state ==
 					     M0_CLRES_VALID);
 			else
@@ -248,7 +246,7 @@ static void composite_layout_verify(struct m0_layout *l,
 			++j;
 		} m0_tl_endfor;
 		M0_UT_ASSERT(j == extents_nr);
-		//todo Enable once m0_emap_paste works  ++extents_nr;
+		//todo ++extents_nr;
 		++i;
         } m0_tl_endfor;
 }
@@ -346,7 +344,7 @@ static void composite_dump(const struct m0_composite_layout *cl)
 static int composite_build(uint64_t lid,
 			   struct m0_layout_domain *domain,
 			   uint32_t extents_nr,
-			   bool if_contiguous_extents,
+			   bool is_contiguous_extents,
 			   bool failure_test,
 			   struct m0_composite_layout **cl)
 {
@@ -362,7 +360,7 @@ static int composite_build(uint64_t lid,
 	sublayout_build(sublayout_id, domain, &sublayout);
 
 	/* Build an extent list to be associated with the sublayout. */
-	extentlist_build(&extents, extents_nr, if_contiguous_extents);
+	extentlist_build(&extents, extents_nr, is_contiguous_extents);
 
 	/* Build a composite layout. */
 	rc = m0_composite_build(domain, lid, sublayout, cl);
@@ -386,7 +384,8 @@ static int composite_build(uint64_t lid,
 
 		/* Verify the composite layout object contents. */
 		composite_layout_verify(l_from_cl, lid, 1, extents_nr,
-					if_contiguous_extents);
+					is_contiguous_extents,
+					!USER_COUNT_INCREMENTED);
 	}
 	extentlist_free(&extents);
 	return rc;
@@ -399,10 +398,9 @@ static int composite_build(uint64_t lid,
  * of another layer.
  */
 static int composite_layers_add(struct m0_composite_layout *cl,
-				struct m0_db_tx *tx,
 				uint32_t layers_nr,
 				uint32_t min_extents_nr,
-				bool if_contiguous_extents,
+				bool is_contiguous_extents,
 				bool layer_add_failure_test)
 {
 	uint64_t                          sublayout_id;
@@ -429,11 +427,12 @@ static int composite_layers_add(struct m0_composite_layout *cl,
 		m0_layout_put(sublayout);
 
 		/* Build an extent list to be associated with the sublayout. */
-		extentlist_build(&extents, extents_nr, if_contiguous_extents);
+		extentlist_build(&extents, extents_nr, is_contiguous_extents);
 
 		M0_UT_ASSERT(cl->cl_layers_nr == i);
 		rc = m0_composite_layer_add(cl, sublayout);
 		if (layer_add_failure_test) {
+			//todo optimise the err list
 			M0_UT_ASSERT(rc == L_TABLE_INSERT_ERR ||
 				     rc == -ENOMEM || rc == -EINVAL ||
 				     rc == L_EMAP_PASTE_ERR ||
@@ -446,15 +445,6 @@ static int composite_layers_add(struct m0_composite_layout *cl,
 			M0_UT_ASSERT(cl->cl_layers_nr == i + 1);
 		}
 
-		/* todo This is temporarily here. Need to restructure such that
-		 * extents are added outside this fn.
-		 *
-		 * Now that the layer is added, update the layout in
-		 * the DB.
-		 */
-		if (tx != NULL)
-			layout_update(&cl->cl_base);
-
 		m0_tl_for(m0_composite_layer_ext, &extents, lr_ext) {
 			rc = m0_composite_layer_ext_add(cl, i,
 							&lr_ext->cle_ext,
@@ -465,7 +455,8 @@ static int composite_layers_add(struct m0_composite_layout *cl,
 
 		/* Verify the composite layout object contents. */
 		composite_layout_verify(&cl->cl_base, cl->cl_base.l_id, i + 1,
-					min_extents_nr, if_contiguous_extents);
+					min_extents_nr, is_contiguous_extents,
+					!USER_COUNT_INCREMENTED);
 	}
 	return rc;
 }
@@ -480,66 +471,33 @@ static int composite_build_and_layers_add(uint64_t lid,
 					  struct m0_layout_domain *domain,
 					  uint32_t layers_nr,
 					  uint32_t min_extents_nr,
-					  bool if_contiguous_extents,
-					  bool is_add_to_db, //todo check if reqd
+					  bool is_contiguous_extents,
 					  bool failure_test,
 					  bool layer_add_failure_test,
 					  struct m0_composite_layout **cl)
 {
-	m0_bcount_t        num_bytes;
-	void              *area;
-	struct m0_db_pair  pair;
-	struct m0_db_tx    tx;
-	struct m0_db_tx   *txptr;
-	int                rc_tmp;
-	int                rc;
+	int rc;
 
 	rc = composite_build(lid, domain, min_extents_nr,
-			     if_contiguous_extents, failure_test, cl);
+			     is_contiguous_extents, failure_test, cl);
 	if (failure_test) {
 		M0_UT_ASSERT(rc == -ENOMEM);
 		return rc;
-	}
-	M0_UT_ASSERT(rc == 0);
-
-	if (is_add_to_db) {
-		allocate_area(domain, ADDITIONAL_BYTES_NONE, &num_bytes,
-			      &area);
-		rc = m0_db_tx_init(&tx, domain->ld_dbenv, DBFLAGS);
+	} else {
 		M0_UT_ASSERT(rc == 0);
-		pair_set(&pair, &lid, area, num_bytes);
-		rc = m0_layout_add(&(*cl)->cl_base, &tx, &pair);
+
+		rc = composite_layers_add(*cl, layers_nr, min_extents_nr,
+					  is_contiguous_extents,
+					  layer_add_failure_test);
 		if (layer_add_failure_test)
-			M0_UT_ASSERT(rc == LO_ENCODE_ERR ||
-				     rc == L_TABLE_INSERT_ERR);
+			//todo rm M0_UT_ASSERT(rc == L_TABLE_INSERT_ERR || rc == -ENOMEM);
+			M0_UT_ASSERT(rc == -ENOMEM);
 		else
 			M0_UT_ASSERT(rc == 0);
-		m0_free(area);
-		txptr = &tx;
-	} else {
-		txptr = NULL;
-	}
-
-	rc = composite_layers_add(*cl, txptr, layers_nr, min_extents_nr,
-				  if_contiguous_extents,
-				  layer_add_failure_test);
-	if (layer_add_failure_test)
-		M0_UT_ASSERT(rc == L_TABLE_INSERT_ERR || rc == -ENOMEM);
-	else
-		M0_UT_ASSERT(rc == 0);
-
-	if (is_add_to_db) {
-		/*
-		 * Now that some layers are added, update the layout in
-		 * the DB.
-		 */
-		layout_update(&(*cl)->cl_base);
-		rc_tmp = m0_db_tx_commit(txptr);
-		M0_UT_ASSERT(rc_tmp == 0);
-	}
 #if 0
-	composite_dump(*cl);
+		composite_dump(*cl);
 #endif
+	}
 	return rc;
 }
 
@@ -552,14 +510,14 @@ static int composite_build_and_layers_add(uint64_t lid,
 int test_build_composite(uint64_t lid,
 			 struct m0_layout_domain *domain,
 			 uint32_t extents_nr,
-			 bool if_contiguous_extents,
+			 bool is_contiguous_extents,
 			 bool failure_test)
 {
 	struct m0_composite_layout *cl;
 	struct m0_layout           *l;
 	int                         rc;
 
-	rc = composite_build(lid, domain, extents_nr, if_contiguous_extents,
+	rc = composite_build(lid, domain, extents_nr, is_contiguous_extents,
 			     failure_test, &cl);
 	if (failure_test)
 		M0_UT_ASSERT(rc == -ENOMEM || rc == -EINVAL);
@@ -574,7 +532,8 @@ int test_build_composite(uint64_t lid,
 
 		/* Verify the layout object built earlier here. */
 		composite_layout_verify(l, lid, 1, extents_nr,
-					if_contiguous_extents);
+					is_contiguous_extents,
+					!USER_COUNT_INCREMENTED);
 
 		/* Reduce the reference acquired by m0_layout_find(). */
 		m0_layout_put(&cl->cl_base);
@@ -594,7 +553,7 @@ static void composite_layout_buf_build(uint64_t composite_lid,
 				       struct m0_layout_domain *domain,
 				       uint32_t layers_nr,
 				       uint32_t min_extents_nr,
-				       bool if_contiguous_extents,
+				       bool is_contiguous_extents,
 				       struct m0_bufvec_cursor *dcur)
 {
 	m0_bcount_t                     nbytes;
@@ -666,7 +625,7 @@ static void composite_layout_buf_build(uint64_t composite_lid,
 				(j == lr_header.clh_extents_nr - 1) ?
 				END_OFFSET : buf_ext.lbe_ext.e_start + delta;
 			buf_ext.lbe_state =
-				(if_contiguous_extents || j % 2 == 0) ?
+				(is_contiguous_extents || j % 2 == 0) ?
 				M0_CLRES_VALID : M0_CLRES_HOLE;
 
 			if (M0_FI_ENABLED("invalid_ext_state_err"))
@@ -676,7 +635,7 @@ static void composite_layout_buf_build(uint64_t composite_lid,
 							 sizeof buf_ext);
 			M0_UT_ASSERT(nbytes == sizeof buf_ext);
 		}
-		//todo enable once m0_emap_paste() works ++extents_nr;
+		//todo ++extents_nr;
 	}
 }
 
@@ -685,7 +644,7 @@ int test_decode_composite(uint64_t lid,
 			  struct m0_layout_domain *domain,
 			  uint32_t layers_nr,
 			  uint32_t min_extents_nr,
-			  bool if_contiguous_extents,
+			  bool is_contiguous_extents,
 			  bool failure_test)
 {
 	void                    *area;
@@ -701,7 +660,7 @@ int test_decode_composite(uint64_t lid,
 	bv = (struct m0_bufvec) M0_BUFVEC_INIT_BUF(&area, &num_bytes);
 	m0_bufvec_cursor_init(&cur, &bv);
 	composite_layout_buf_build(lid, domain, layers_nr, min_extents_nr,
-				   if_contiguous_extents, &cur);
+				   is_contiguous_extents, &cur);
 
 	/* Rewind the cursor. */
 	m0_bufvec_cursor_init(&cur, &bv);
@@ -720,7 +679,8 @@ int test_decode_composite(uint64_t lid,
 
 		/* Verify the layout object built by m0_layout_decode(). */
 		composite_layout_verify(l, lid, layers_nr, min_extents_nr,
-					if_contiguous_extents);
+					is_contiguous_extents,
+					!USER_COUNT_INCREMENTED);
 	}
 
 	/* Destroy the layout object. */
@@ -749,7 +709,7 @@ static void composite_layout_buf_verify(uint64_t lid,
 					struct m0_layout_domain *domain,
 					uint32_t layers_nr,
 					uint32_t min_extents_nr,
-					bool if_contiguous_extents,
+					bool is_contiguous_extents,
 					struct m0_bufvec_cursor *cur)
 {
 	uint32_t                        lt_id;
@@ -807,12 +767,12 @@ static void composite_layout_buf_verify(uint64_t lid,
 
 			ext_state = m0_bufvec_cursor_addr(cur);
 			m0_bufvec_cursor_move(cur, sizeof *ext_state);
-			if (if_contiguous_extents || j % 2 == 0)
+			if (is_contiguous_extents || j % 2 == 0)
 				M0_UT_ASSERT(*ext_state == M0_CLRES_VALID);
 			else
 				M0_UT_ASSERT(*ext_state == M0_CLRES_HOLE);
 		}
-		//todo enable once m0_emap_paste works ++extents_nr;
+		//todo ++extents_nr;
 	}
 }
 
@@ -821,7 +781,7 @@ int test_encode_composite(uint64_t lid,
 			  struct m0_layout_domain *domain,
 			  uint32_t layers_nr,
 			  uint32_t min_extents_nr,
-			  bool if_contiguous_extents,
+			  bool is_contiguous_extents,
 			  bool failure_test)
 {
 	struct m0_composite_layout *cl;
@@ -834,8 +794,7 @@ int test_encode_composite(uint64_t lid,
 	/* Build a layout object. */
 	rc = composite_build_and_layers_add(lid, domain, layers_nr,
 					    min_extents_nr,
-					    if_contiguous_extents,
-					    !ADD_TO_DB,
+					    is_contiguous_extents,
 					    !FAILURE_TEST,
 					    !LAYER_ADD_FAILURE_TEST, &cl);
 	M0_UT_ASSERT(rc == 0);
@@ -860,7 +819,7 @@ int test_encode_composite(uint64_t lid,
 	if (!failure_test)
 		composite_layout_buf_verify(lid, domain, layers_nr,
 					    min_extents_nr,
-					    if_contiguous_extents, &cur);
+					    is_contiguous_extents, &cur);
 
 	/* Delete the composite layout object. */
 	m0_layout_put(&cl->cl_base);
@@ -947,7 +906,7 @@ int test_decode_encode_composite(uint64_t lid,
 				 struct m0_layout_domain *domain,
 				 uint32_t layers_nr,
 				 uint32_t min_extents_nr,
-				 bool if_contiguous_extents)
+				 bool is_contiguous_extents)
 {
 	void                    *area1;
 	struct m0_bufvec         bv1;
@@ -966,7 +925,7 @@ int test_decode_encode_composite(uint64_t lid,
 	m0_bufvec_cursor_init(&cur1, &bv1);
 
 	composite_layout_buf_build(lid, domain, layers_nr, min_extents_nr,
-				   if_contiguous_extents, &cur1);
+				   is_contiguous_extents, &cur1);
 
 	/* Rewind the cursor. */
 	m0_bufvec_cursor_init(&cur1, &bv1);
@@ -1155,7 +1114,7 @@ int test_encode_decode_composite(uint64_t lid,
 				 struct m0_layout_domain *domain,
 				 uint32_t layers_nr,
 				 uint32_t min_extents_nr,
-				 bool if_contiguous_extents)
+				 bool is_contiguous_extents)
 {
 	struct m0_composite_layout *cl;
 	void                       *area;
@@ -1170,8 +1129,7 @@ int test_encode_decode_composite(uint64_t lid,
 	/* Build a layout object. */
 	rc = composite_build_and_layers_add(lid, domain, layers_nr,
 					    min_extents_nr,
-					    if_contiguous_extents,
-					    !ADD_TO_DB,
+					    is_contiguous_extents,
 					    !FAILURE_TEST,
 					    !LAYER_ADD_FAILURE_TEST, &cl);
 	M0_UT_ASSERT(rc == 0);
@@ -1242,7 +1200,6 @@ int test_instance_composite(uint64_t lid, struct m0_layout_domain *domain,
 	layers_nr = 5;
 	rc = composite_build_and_layers_add(lid, domain, layers_nr, 8,
 					    CONTIGUOUS_EXTENTS,
-					    !ADD_TO_DB,
 					    !FAILURE_TEST,
 					    !LAYER_ADD_FAILURE_TEST, &cl);
 	M0_UT_ASSERT(rc == 0);
@@ -1314,13 +1271,13 @@ int test_layer_ops_composite(uint64_t lid,
 
 	/* Build a layout with the default layer 'layer 0'. */
 	rc = composite_build_and_layers_add(lid, domain, 1, min_extents_nr,
-					    !CONTIGUOUS_EXTENTS, false,
+					    !CONTIGUOUS_EXTENTS,
 					    !FAILURE_TEST,
 					    !LAYER_ADD_FAILURE_TEST, &cl);
 	M0_UT_ASSERT(rc == 0);
 
 	/* Now, add layers to the layout. */
-	rc = composite_layers_add(cl, NULL, layers_nr, min_extents_nr,
+	rc = composite_layers_add(cl, layers_nr, min_extents_nr,
 				  !CONTIGUOUS_EXTENTS, layer_add_failure_test);
 
 	if (layer_add_failure_test) {
@@ -1336,7 +1293,7 @@ int test_layer_ops_composite(uint64_t lid,
 	/* Verify the layout. */
 	l = m0_cl_to_layout(cl);
 	composite_layout_verify(l, lid, layers_nr, min_extents_nr,
-				!CONTIGUOUS_EXTENTS);
+				!CONTIGUOUS_EXTENTS, !USER_COUNT_INCREMENTED);
 
 	/* Delete all the extents associated with the top-most layer. */
 	layer = layer_find(cl, cl->cl_layers_nr - 1);
@@ -1348,7 +1305,7 @@ int test_layer_ops_composite(uint64_t lid,
 
 	/* Verify the layout. */
 	composite_layout_verify(l, lid, layers_nr - 1, min_extents_nr,
-				!CONTIGUOUS_EXTENTS);
+				!CONTIGUOUS_EXTENTS, !USER_COUNT_INCREMENTED);
 exit:
 	/* Delete the composite layout object. */
 	m0_layout_put(&cl->cl_base);
@@ -1361,7 +1318,7 @@ exit:
 
 /** Depending upon 'the kind of the extent', define the extent. */
 static void extent_to_be_operated(const struct m0_composite_layout *cl,
-				  bool if_contiguous_extents,
+				  bool is_contiguous_extents,
 				  uint32_t layer_idx,
 				  uint64_t extent_idx,
 				  enum kind_of_extent extent_kind,
@@ -1384,7 +1341,7 @@ static void extent_to_be_operated(const struct m0_composite_layout *cl,
 	M0_UT_ASSERT(ergo(extent_kind == EXACT_EXISTING,
 			  extent_idx < layer->clr_extents_nr));
 	M0_UT_ASSERT(ergo(extent_kind == NON_EXISTING,
-			  if_contiguous_extents == false));
+			  is_contiguous_extents == false));
 	M0_UT_ASSERT(ergo(extent_kind != EXACT_EXISTING,
 			  layer->clr_extents_nr >= 3 &&
 			  layer->clr_extents_nr >= extent_idx + 1));
@@ -1405,14 +1362,14 @@ static void extent_to_be_operated(const struct m0_composite_layout *cl,
 	M0_UT_ASSERT(ext_idxth.e_end == ext_idx_plus_oneth.e_start);
 
 	if (extent_kind == EXACT_EXISTING) {
-		if (if_contiguous_extents)
+		if (is_contiguous_extents)
 			*ext = ext_idxth;
 		else {
 			*ext = ((i - 1) % 2 == 0) ?
 				ext_idxth : ext_idx_plus_oneth;
 		}
 	} else if (extent_kind == NON_EXISTING) {
-		M0_UT_ASSERT(!if_contiguous_extents);
+		M0_UT_ASSERT(!is_contiguous_extents);
 		*ext = ((i - 1) % 2 == 0) ? ext_idx_plus_oneth : ext_idxth;
 	} else if (extent_kind == OVERLAPPING_LEFT) {
 		ext->e_start = ext_idxth.e_start;
@@ -1421,7 +1378,7 @@ static void extent_to_be_operated(const struct m0_composite_layout *cl,
 		ext->e_start = ext_idxth.e_end - 1;
 		ext->e_end = ext_idx_plus_oneth.e_end;
 	} else if (extent_kind == OVERLAPPING_COMPLETE) {
-		if (if_contiguous_extents) {
+		if (is_contiguous_extents) {
 			ext->e_start = ext_idxth.e_start - 1;
 			ext->e_end = ext_idxth.e_end + 1;
 		} else {
@@ -1434,7 +1391,7 @@ static void extent_to_be_operated(const struct m0_composite_layout *cl,
 			}
 		}
 	} else if (extent_kind == CONTAINED_WITHIN) {
-		if (if_contiguous_extents) {
+		if (is_contiguous_extents) {
 			ext->e_start = ext_idxth.e_start + 2;
 			ext->e_end = ext_idxth.e_end - 2;
 		} else {
@@ -1467,39 +1424,34 @@ static int ext_op_pre(enum extent_operation eop,
 		      struct m0_layout_domain *domain,
 		      uint32_t layers_nr,
 		      uint32_t min_extents_nr,
-		      bool if_contiguous_extents,
+		      bool is_contiguous_extents,
 		      enum kind_of_extent extent_kind,
 		      uint64_t ext_state,
 		      bool failure_test,
 		      struct m0_composite_layout **cl,
 		      struct m0_ext *ext_to_operate,
 		      m0_bindex_t *offset_to_operate,
-			//todo check if the following is req'd
 		      enum m0_composite_layer_ext_state *ext_state_lookup,
 		      struct m0_layout **l_copy_orig)
 {
-	bool              is_add_to_db;
-	struct m0_db_tx  *txptr;
 	uint32_t          layer_id_lookup;
 	struct m0_ext     ext_lookup;
 	struct m0_layout *sublayout_lookup;
-	struct m0_db_tx   tx;
 	int               rc_tmp;
 	int               rc;
 
 	M0_UT_ASSERT(M0_IN(eop, (EXTENT_LOOKUP, EXTENT_ADD, EXTENT_UPDATE,
 				 EXTENT_DELETE)));
 
-	is_add_to_db = false;
 	rc = composite_build_and_layers_add(lid, domain,
 					    layers_nr, min_extents_nr,
-					    if_contiguous_extents,
-					    is_add_to_db, !FAILURE_TEST,
+					    is_contiguous_extents,
+					    !FAILURE_TEST,
 					    !LAYER_ADD_FAILURE_TEST, cl);
 	M0_UT_ASSERT(rc == 0);
 
 	/* Define an extent to be operated. */
-	extent_to_be_operated(*cl, if_contiguous_extents, 1, 1,
+	extent_to_be_operated(*cl, is_contiguous_extents, 1, 1,
 			      extent_kind, ext_to_operate);
 
 	/* Define the offset to be operated. */
@@ -1511,11 +1463,11 @@ static int ext_op_pre(enum extent_operation eop,
 	else {
 		M0_UT_ASSERT(extent_kind == OVERLAPPING_RIGHT ||
 			     extent_kind == SECOND_HALF);
-		if (extent_kind == OVERLAPPING_RIGHT || if_contiguous_extents)
+		if (extent_kind == OVERLAPPING_RIGHT || is_contiguous_extents)
 			*offset_to_operate = ext_to_operate->e_end - 1;
 		else {
 			M0_UT_ASSERT(extent_kind == SECOND_HALF);
-			M0_UT_ASSERT(!if_contiguous_extents);
+			M0_UT_ASSERT(!is_contiguous_extents);
 			if (min_extents_nr % 2 == 0)
 				*offset_to_operate =
 					 ext_to_operate->e_start + 1;
@@ -1524,13 +1476,6 @@ static int ext_op_pre(enum extent_operation eop,
 		}
 	}
 
-	if (is_add_to_db) {
-		rc = m0_db_tx_init(&tx, domain->ld_dbenv, DBFLAGS);
-		M0_UT_ASSERT(rc == 0);
-		txptr = &tx;
-	} else
-		txptr = NULL;
-
 	if (eop == EXTENT_LOOKUP)
 		my_console_printf("\nextlist_dump before ext LOOKUP with "
 				  "ext_kind %u, offset %llu\n", extent_kind,
@@ -1568,7 +1513,7 @@ static int ext_op_pre(enum extent_operation eop,
 	//todo Check if the following cond shud be based on failure_test
 #if 1
 	if (extent_kind == NON_EXISTING ||
-	    (extent_kind == OVERLAPPING_LEFT && !if_contiguous_extents)) {
+	    (extent_kind == OVERLAPPING_LEFT && !is_contiguous_extents)) {
 		//todo check if the later cond below is reqd
 		M0_UT_ASSERT(rc_tmp == -ENOENT || rc_tmp == L_EMAP_LOOKUP_ERR);
 		if (eop == EXTENT_LOOKUP)
@@ -1601,11 +1546,6 @@ static int ext_op_pre(enum extent_operation eop,
 			M0_UT_ASSERT(ext_lookup.e_end > *offset_to_operate);
 		}
 	}
-	if (is_add_to_db) {
-		rc_tmp = m0_db_tx_commit(&tx);
-		M0_UT_ASSERT(rc_tmp == 0);
-	}
-
 	composite_layout_copy(m0_cl_to_layout(*cl), l_copy_orig);
 	return rc;
 }
@@ -1696,6 +1636,7 @@ static int ext_add(struct m0_composite_layout *cl,
 	rc = m0_composite_layer_ext_add(cl, cl->cl_layers_nr - 1,
 					ext_to_operate, ext_state);
 	if (failure_test) {
+		//todo optimise the error list
 		M0_UT_ASSERT(rc == -EINVAL || rc == -ENOMEM ||
 			     rc == L_EMAP_LOOKUP_ERR);
 		my_console_printf("ext ADD failed, rc %d\n", rc);
@@ -1772,7 +1713,7 @@ static int ext_delete(struct m0_composite_layout *cl,
 		      struct m0_layout *l_copy_orig,
 		      struct m0_layout_domain *domain,
 		      enum kind_of_extent extent_kind,
-		      bool if_contiguous_extents,
+		      bool is_contiguous_extents,
 		      struct m0_ext *ext_to_operate,
 		      m0_bindex_t offset_to_operate,
 		      bool failure_test)
@@ -1805,7 +1746,7 @@ static int ext_delete(struct m0_composite_layout *cl,
 						   &sublayout_lookup);
 		if (extent_kind == NON_EXISTING ||
 		    (extent_kind == OVERLAPPING_LEFT &&
-		     !if_contiguous_extents)) {
+		     !is_contiguous_extents)) {
 			M0_UT_ASSERT(rc == -ENOENT);
 			rc = 0;
 		} else {
@@ -1820,7 +1761,7 @@ static int test_ext_lookup(uint64_t lid,
 			   struct m0_layout_domain *domain,
 			   uint32_t layers_nr,
 			   uint32_t min_extents_nr,
-			   bool if_contiguous_extents,
+			   bool is_contiguous_extents,
 			   enum kind_of_extent extent_kind,
 			   bool failure_test)
 {
@@ -1832,7 +1773,7 @@ static int test_ext_lookup(uint64_t lid,
 	int                                rc;
 
 	rc = ext_op_pre(EXTENT_LOOKUP, lid, domain, layers_nr, min_extents_nr,
-			if_contiguous_extents, extent_kind,
+			is_contiguous_extents, extent_kind,
 			M0_CLRES_HOLE, /* todo */
 			failure_test, &cl, &ext_to_operate, &offset_to_operate,
 			&ext_state_lookup, &l_copy_orig);
@@ -1859,7 +1800,7 @@ static int test_ext_add(uint64_t lid,
 			struct m0_layout_domain *domain,
 			uint32_t layers_nr,
 			uint32_t min_extents_nr,
-			bool if_contiguous_extents,
+			bool is_contiguous_extents,
 			enum kind_of_extent extent_kind,
 			uint64_t ext_state,
 			bool failure_test)
@@ -1873,14 +1814,13 @@ static int test_ext_add(uint64_t lid,
 	int                                rc;
 
 	rc = ext_op_pre(EXTENT_ADD, lid, domain, layers_nr, min_extents_nr,
-			if_contiguous_extents, extent_kind, ext_state,
+			is_contiguous_extents, extent_kind, ext_state,
 			failure_test, &cl, &ext_to_operate, &offset_to_operate,
 			&ext_state_lookup, &l_copy_orig);
 	M0_UT_ASSERT(rc == 0);
 
-	rc = ext_add(cl, l_copy_orig, domain, extent_kind,
-		     &ext_to_operate, offset_to_operate, ext_state,
-		     failure_test);
+	rc = ext_add(cl, l_copy_orig, domain, extent_kind, &ext_to_operate,
+		     offset_to_operate, ext_state, failure_test);
 	if (failure_test) {
 		M0_UT_ASSERT(rc == -EINVAL || rc == -ENOMEM ||
 			     rc == L_EMAP_LOOKUP_ERR);
@@ -1900,7 +1840,7 @@ static int test_ext_state_update(uint64_t lid,
 				 struct m0_layout_domain *domain,
 				 uint32_t layers_nr,
 				 uint32_t min_extents_nr,
-				 bool if_contiguous_extents,
+				 bool is_contiguous_extents,
 				 enum kind_of_extent extent_kind,
 				 uint64_t ext_state,
 				 bool failure_test)
@@ -1913,7 +1853,7 @@ static int test_ext_state_update(uint64_t lid,
 	int                                rc;
 
 	rc = ext_op_pre(EXTENT_UPDATE, lid, domain, layers_nr, min_extents_nr,
-			if_contiguous_extents, extent_kind, ext_state,
+			is_contiguous_extents, extent_kind, ext_state,
 			failure_test, &cl, &ext_to_operate, &offset_to_operate,
 			&ext_state_lookup, &l_copy_orig);
 	M0_ASSERT(rc == 0);
@@ -1932,41 +1872,11 @@ static int test_ext_state_update(uint64_t lid,
 	return rc;
 }
 
-#if 0
-//todo Make use of this where applicable
-static void tx_init(struct m0_layout_domain *domain,
-		    struct m0_db_tx *tx,
-		    struct m0_db_tx **txptr)
-{
-	int rc;
-
-	if (domain->ld_is_db_available) {
-		rc = m0_db_tx_init(tx, domain->ld_dbenv, DBFLAGS);
-		M0_UT_ASSERT(rc == 0);
-		*txptr = tx;
-	} else
-		*txptr = NULL;
-}
-
-//todo Make use of this where applicable
-static void tx_commit(struct m0_layout_domain *domain,
-		    struct m0_db_tx *txptr)
-{
-	int rc;
-
-	if (domain->ld_is_db_available) {
-		rc = m0_db_tx_commit(txptr);
-		M0_UT_ASSERT(rc == 0);
-	} else
-		M0_UT_ASSERT(txptr == NULL);
-}
-#endif
-
 static int test_ext_delete(uint64_t lid,
 			   struct m0_layout_domain *domain,
 			   uint32_t layers_nr,
 			   uint32_t min_extents_nr,
-			   bool if_contiguous_extents,
+			   bool is_contiguous_extents,
 			   enum kind_of_extent extent_kind,
 			   bool failure_test)
 {
@@ -1981,7 +1891,7 @@ static int test_ext_delete(uint64_t lid,
 	int                                rc;
 
 	rc = ext_op_pre(EXTENT_DELETE, lid, domain, layers_nr, min_extents_nr,
-			if_contiguous_extents, extent_kind, M0_CLRES_HOLE,
+			is_contiguous_extents, extent_kind, M0_CLRES_HOLE,
 			failure_test, &cl, &ext_to_operate, &offset_to_operate,
 			&ext_state_lookup, &l_copy_orig);
 	M0_ASSERT(rc == 0);
@@ -2003,7 +1913,7 @@ static int test_ext_delete(uint64_t lid,
 	}
 
 	rc = ext_delete(cl, l_copy_orig, domain, extent_kind,
-			if_contiguous_extents, &ext_to_operate,
+			is_contiguous_extents, &ext_to_operate,
 			offset_to_operate, failure_test);
 	if (failure_test)
 		M0_ASSERT(rc == -ENOENT || rc == -EINVAL);
@@ -2113,7 +2023,7 @@ void test_layer_ext_ops_composite(uint64_t base_lid,
 	M0_UT_ASSERT(rc == 0);
 
 	//todo Update extent to have the flattening state
-	//todo Make ext_ops() accept state and pass falttening state this time
+	//todo Make ext_ops() accept state and pass flattening state this time
 	lid = base_lid + 121;
 	rc = ext_ops(lid, domain, EXTENT_UPDATE);
 	M0_UT_ASSERT(rc == 0);
@@ -2129,38 +2039,6 @@ void test_layer_ext_ops_composite_failure(uint64_t base_lid,
 {
 	uint64_t lid;
 	int      rc;
-#if 0 //todo rm
-	/*
-	 * Simulate a situation that a valid extent with the given offset is
-	 * not found in the memory but is found in the DB.
-	 */
-	lid = base_lid;
-	m0_fi_enable_once("m0_composite_layer_ext_lookup",
-			  "ext_inmem_lookup_err");
-	rc = test_ext_lookup(lid, domain, 3, 4,
-			     CONTIGUOUS_EXTENTS, EXACT_EXISTING,
-			     domain->ld_is_db_available ?
-				!FAILURE_TEST : FAILURE_TEST);
-	M0_ASSERT(ergo(domain->ld_is_db_available, rc == 0));
-	M0_ASSERT(ergo(!domain->ld_is_db_available,
-		       rc == L_EXT_INMEM_LOOKUP_ERR));
-#endif
-
-#if 0 //todo enable, not working at this point
-	/*
-	 * Simulate a situation that a valid extent with the given offset is
-	 * not found in the memory and while attempting to look into the DB,
-	 * emap lookup error is encountered.
-	 */
-	lid = base_lid + 1;
-	m0_fi_enable_off_n_on_m("emap_iterator_set", "emap_lookup_err",
-				5 /* todo layers_nr */, 1);
-	rc = test_ext_lookup(lid, domain, 3, 4,
-			     !CONTIGUOUS_EXTENTS, NON_EXISTING, FAILURE_TEST);
-	M0_ASSERT(ergo(domain->ld_is_db_available, rc == L_EMAP_LOOKUP_ERR));
-	M0_ASSERT(ergo(!domain->ld_is_db_available, rc == -ENOENT));
-	m0_fi_disable("emap_iterator_set", "emap_lookup_err");
-#endif
 
 	//todo Make ext_ops() accept state so that all extent_kinds can be tested for such failure
 	/*
@@ -2173,48 +2051,19 @@ void test_layer_ext_ops_composite_failure(uint64_t base_lid,
 			  M0_CLRES_FLATTENING, FAILURE_TEST);
 	M0_ASSERT(rc == -EINVAL);
 
-#if 0 //todo Not working, need to analyse
-	/* Simulate memory allocation error in the path of ext_inmem_add(). */
+	/*
+	 * Simulate memory allocation error in the path of ext_inmem_add().
+	 * This test exercises restoring the original extent list due to
+	 * encountering error while adding one of the overlapping extents.
+	 */
 	lid = base_lid + 22;
 	m0_fi_enable_off_n_on_m("ext_inmem_add_internal",
-				"alloc_ptr_fail/lr_ext", 32, 1);
-	//m0_fi_enable_once("ext_inmem_add_internal", "alloc_ptr_fail/lr_ext");
+				"alloc_ptr_fail/lr_ext", 82, 1);
 	rc = test_ext_add(lid, domain, 3, 6,
 			  !CONTIGUOUS_EXTENTS, OVERLAPPING_LEFT,
 			  M0_CLRES_VALID, FAILURE_TEST);
 	M0_ASSERT(rc == -ENOMEM);
 	m0_fi_disable("ext_inmem_add_internal", "alloc_ptr_fail/lr_ext");
-#endif
-
-#if 0 //todo Not working, need to analyse
-	/*
-	 * Simulate extmap iterator setting error while trying to add an
-	 * extent.
-	 */
-	lid = base_lid + 23;
-	m0_fi_enable_off_n_on_m("emap_iterator_set", "emap_lookup_err",
-				4 /* layers_nr + 1 */, 1);
-	rc = test_ext_add(lid, domain, 3, 6, CONTIGUOUS_EXTENTS,
-			  EXACT_EXISTING, //todo OVRLAPPING_RIGHT as well
-			  M0_CLRES_VALID,
-			  domain->ld_is_db_available ?
-				FAILURE_TEST : !FAILURE_TEST);
-	M0_UT_ASSERT(ergo(domain->ld_is_db_available, rc == L_EMAP_LOOKUP_ERR));
-	M0_UT_ASSERT(ergo(!domain->ld_is_db_available, rc == 0));
-	m0_fi_disable("emap_iterator_set", "emap_lookup_err");
-#endif
-
-#if 0 //todo Not working, need to analyse
-	/*
-	 * Simulate m0_emap_paste()'s callback facing error in the path of
-	 * adding an extent to some layer.
-	 */
-	lid = base_lid + 24;
-	m0_fi_enable_once("ext_inmem_add_internal", "alloc_ptr_fail/lr_ext");
-	rc = test_ext_add(lid, domain, 3, 6, CONTIGUOUS_EXTENTS,
-			  CONTAINED_WITHIN, M0_CLRES_VALID, FAILURE_TEST);
-	M0_UT_ASSERT(rc == -ENOMEM);
-#endif
 
 	/*
 	 * Simulate extent validation error by trying to update an extent with
@@ -2246,7 +2095,7 @@ int test_lookup_composite(uint64_t lid,
 			  struct m0_layout_domain *domain,
 			  uint32_t layers_nr,
 			  uint32_t min_extents_nr,
-			  bool if_contiguous_extents,
+			  bool is_contiguous_extents,
 			  bool existing_test,
 			  bool failure_test)
 {
@@ -2264,8 +2113,7 @@ int test_lookup_composite(uint64_t lid,
 		/* Build a layout object, add layers to it, add it to the DB. */
 		rc = composite_build_and_layers_add(lid, domain, layers_nr,
 						    min_extents_nr,
-						    if_contiguous_extents,
-						    ADD_TO_DB,
+						    is_contiguous_extents,
 						    !FAILURE_TEST,
 						    !LAYER_ADD_FAILURE_TEST,
 						    &cl);
@@ -2275,6 +2123,9 @@ int test_lookup_composite(uint64_t lid,
 		if (!failure_test)
 			composite_layout_copy(l1, &l1_copy);
 
+		/* Add the layout to hte DB. */
+		layout_add(&cl->cl_base);
+
 		/* todo check if shud be after layout_update()
 		 * Lookup for the layout object to verify that the same object
 		 * is returned from the memory, not requiring a lookup from the
@@ -2329,7 +2180,7 @@ int test_add_composite(uint64_t lid,
 		       struct m0_layout_domain *domain,
 		       uint32_t layers_nr,
 		       uint32_t min_extents_nr,
-		       bool if_contiguous_extents,
+		       bool is_contiguous_extents,
 		       bool duplicate_test,
 		       bool failure_test)
 {
@@ -2347,11 +2198,12 @@ int test_add_composite(uint64_t lid,
 	/* Build a layout object and add layers to it only in memory. */
 	rc = composite_build_and_layers_add(lid, domain, layers_nr,
 					    min_extents_nr,
-					    if_contiguous_extents, !ADD_TO_DB,
+					    is_contiguous_extents,
 					    !FAILURE_TEST,
 					    !LAYER_ADD_FAILURE_TEST, &cl);
 	M0_UT_ASSERT(rc == 0);
 
+	//todo Use layout_add() below
 	/* Add the layout object to the DB. */
 	rc = m0_db_tx_init(&tx, domain->ld_dbenv, DBFLAGS);
 	M0_UT_ASSERT(rc == 0);
@@ -2399,7 +2251,7 @@ int test_update_composite(uint64_t lid,
 			  struct m0_layout_domain *domain,
 			  uint32_t layers_nr,
 			  uint32_t min_extents_nr,
-			  bool if_contiguous_extents,
+			  bool is_contiguous_extents,
 			  bool failure_test)
 {
 	m0_bcount_t                 num_bytes;
@@ -2426,22 +2278,14 @@ int test_update_composite(uint64_t lid,
 	/* Build a layout object and add layers to it only in memory. */
 	rc = composite_build_and_layers_add(lid, domain, layers_nr,
 					    min_extents_nr,
-					    if_contiguous_extents,
-					    !ADD_TO_DB,
+					    is_contiguous_extents,
 					    !FAILURE_TEST,
 					    !LAYER_ADD_FAILURE_TEST, &cl);
 	M0_UT_ASSERT(rc == 0);
 	l1 = &cl->cl_base;
 
 	/* Add the layout along with its layers to the DB. */
-	rc = m0_db_tx_init(&tx, domain->ld_dbenv, DBFLAGS);
-	M0_UT_ASSERT(rc == 0);
-	allocate_area(domain, ADDITIONAL_BYTES_NONE, &num_bytes, &area);
-	pair_set(&pair, &lid, area, num_bytes);
-	rc = m0_layout_add(l1, &tx, &pair);
-	M0_UT_ASSERT(rc == 0);
-	rc = m0_db_tx_commit(&tx);
-	M0_UT_ASSERT(rc == 0);
+	layout_add(&cl->cl_base);
 
 	/* Make a copy of 'the layout as has been added to the DB'. */
 	if (failure_test)
@@ -2456,7 +2300,7 @@ int test_update_composite(uint64_t lid,
 	M0_UT_ASSERT(l1->l_user_count == 100);
 
 	/* 2. Add an extent to its top-most layer. */
-	extent_to_be_operated(cl, if_contiguous_extents, 1, 1,
+	extent_to_be_operated(cl, is_contiguous_extents, 1, 1,
 			      NON_EXISTING, &ext_to_operate);
 	rc = m0_composite_layer_ext_lookup(cl, ext_to_operate.e_start + 1,
 					   &ext_lookup, &layer_id_lookup,
@@ -2473,26 +2317,13 @@ int test_update_composite(uint64_t lid,
 	M0_UT_ASSERT(rc == 0);
 	M0_UT_ASSERT(ext_state_lookup == M0_CLRES_FLATTENING);
 
-	/*
-	 * todo Ensure to lookup only in the in-DB layout to verify the
-	 * error. Need to add a fault point for that into
-	 * m0_composite_layer_ext_lookup()
-	 */
-#if 0
-	rc = m0_composite_layer_ext_lookup(cl, ext_to_operate.e_start + 1,
-					   NULL, &ext_lookup, &layer_id_lookup,
-					   &ext_state_lookup,
-					   &sublayout_lookup);
-	M0_UT_ASSERT(rc == -ENOENT);
-#endif
-
 	/* 3. Add layers to it. */
 	M0_ASSERT(cl->cl_layers_nr == layers_nr);
 	for (i = 0; i < 4; ++i) {
 		sublayout_id = cl->cl_base.l_id * 100 + cl->cl_layers_nr;
 		sublayout_build(sublayout_id, domain, &sublayout);
 		extentlist_build(&extents, min_extents_nr,
-				 if_contiguous_extents);
+				 is_contiguous_extents);
 		rc = m0_composite_layer_add(cl, sublayout);
 		extentlist_free(&extents);
 		M0_ASSERT(rc == 0);
@@ -2511,6 +2342,7 @@ int test_update_composite(uint64_t lid,
 #endif
 
 	/* Update the layout object in the DB. */
+	allocate_area(domain, ADDITIONAL_BYTES_NONE, &num_bytes, &area);
 	pair_set(&pair, &lid, area, num_bytes);
 	rc = m0_db_tx_init(&tx, domain->ld_dbenv, DBFLAGS);
 	M0_UT_ASSERT(rc == 0);
@@ -2560,8 +2392,7 @@ int test_update_composite(uint64_t lid,
 		 * Verify that the ext is updated right. This is actually
 		 * verified by comparing the layouts. But still to be sure.
 		 */
-		rc = m0_db_tx_init(&tx, domain->ld_dbenv, DBFLAGS);
-		M0_UT_ASSERT(rc == 0);
+		cl = m0_layout_to_cl(l_from_db);
 		rc = m0_composite_layer_ext_lookup(cl,
 						   ext_to_operate.e_start + 1,
 						   &ext_lookup,
@@ -2571,8 +2402,6 @@ int test_update_composite(uint64_t lid,
 		M0_UT_ASSERT(rc == 0);
 		M0_UT_ASSERT(layer_id_lookup == layers_nr - 1);
 		M0_UT_ASSERT(ext_state_lookup == M0_CLRES_FLATTENING);
-		rc_tmp = m0_db_tx_commit(&tx);
-		M0_UT_ASSERT(rc_tmp == 0);
 
 		//todo layer verification.
 	}
@@ -2593,7 +2422,7 @@ int test_delete_composite(uint64_t lid,
 			  struct m0_layout_domain *domain,
 			  uint32_t layers_nr,
 			  uint32_t min_extents_nr,
-			  bool if_contiguous_extents,
+			  bool is_contiguous_extents,
 			  bool failure_test)
 {
 	m0_bcount_t                 num_bytes;
@@ -2611,20 +2440,19 @@ int test_delete_composite(uint64_t lid,
 	/* Build a layout object, add layers to it, add it to the DB. */
 	rc = composite_build_and_layers_add(lid, domain, layers_nr,
 					    min_extents_nr,
-					    if_contiguous_extents,
-					    ADD_TO_DB,
+					    is_contiguous_extents,
 					    !FAILURE_TEST,
 					    !LAYER_ADD_FAILURE_TEST, &cl);
 	M0_UT_ASSERT(rc == 0);
 
+	/* Add the layout to hte DB. */
+	layout_add(&cl->cl_base);
+
 	/* Delete all the extents associated with the composite layout. */
 	m0_tl_for(comp_layer, &cl->cl_layers, layer) {
 		layer_extents_delete(cl, layer);
 	} m0_tl_endfor;
 
-	/* Now that the extents are deleted, update the layout in the DB. */
-	layout_update(&cl->cl_base);
-
 	/*
 	 * Verify the user count of the sublayouts to be 1 since the user
 	 * count has been incremented by one with every layer addition.
diff --git a/layout/ut/layout.c b/layout/ut/layout.c
index 1492e03..be2edc9 100644
--- a/layout/ut/layout.c
+++ b/layout/ut/layout.c
@@ -1665,7 +1665,7 @@ static void test_lookup_failure(void)
 	lid = 19024;
 	m0_fi_enable_off_n_on_m("ext_inmem_add_internal",
 				"alloc_ptr_fail/lr_ext",
-				40 /* layers_nr * extents_nr * 2 */, 1);
+				80 /* layers_nr * extents_nr * 4 */, 1);
 	rc = test_lookup_composite(lid, &domain, 4, 5, CONTIGUOUS_EXTENTS,
 				   EXISTING_TEST, FAILURE_TEST);
 	M0_UT_ASSERT(rc == -ENOMEM);
@@ -1685,7 +1685,7 @@ static void test_lookup_failure(void)
 	//todo zeroth layer?
 	lid = 19026;
 	m0_fi_enable_off_n_on_m("emap_iterator_set", "emap_lookup_err",
-				16 /* layers_nr * 3 + 4 */, 1);
+				5 /* layers_nr * 3 + 4 */, 1);
 	rc = test_lookup_composite(lid, &domain, 4, 5, CONTIGUOUS_EXTENTS,
 				   EXISTING_TEST, FAILURE_TEST);
 	M0_UT_ASSERT(rc == L_EMAP_LOOKUP_ERR);
@@ -1700,7 +1700,7 @@ static void test_lookup_failure(void)
 	/* Simulate sublayout find error while reading a layer. */
 	//todo zeroth layer?
 	lid = 19029;
-	m0_fi_enable_off_n_on_m("layout_find", "layout_find_err", 12, 1);
+	m0_fi_enable_off_n_on_m("layout_find", "layout_find_err", 3, 1);
 	rc = test_lookup_composite(lid, &domain, 4, 5, CONTIGUOUS_EXTENTS,
 				   EXISTING_TEST, FAILURE_TEST);
 	M0_UT_ASSERT(rc == -EINVAL);
@@ -2101,11 +2101,22 @@ static void test_delete_failure(void)
 	 */
 	lid = 25021;
 	m0_fi_enable_off_n_on_m("emap_iterator_set", "emap_lookup_err",
-				20 /* layers_nr + 1 */, 1);
+				5 /* layers_nr + 1 */, 1);
 	rc = test_delete_composite(lid, &domain, 4, 10,
 				   CONTIGUOUS_EXTENTS, FAILURE_TEST);
 	M0_UT_ASSERT(rc == L_EMAP_LOOKUP_ERR);
 	m0_fi_disable("emap_iterator_set", "emap_lookup_err");
+
+#if 0 //todo
+	/* Simulate layer deletion error while deleting emap from the DB. */
+	lid = 25022;
+	m0_fi_enable_off_n_on_m("layer_indb_delete", "emap_obj_del_err",
+				16 /* layers_nr todo */, 1);
+	rc = test_delete_composite(lid, &domain, 4, 10,
+				   CONTIGUOUS_EXTENTS, FAILURE_TEST);
+	M0_UT_ASSERT(rc == L_EMAP_OBJ_DEL_ERR);
+	m0_fi_disable("layer_indb_delete", "emap_obj_del_err");
+#endif
 }
 
 /**
diff --git a/layout/ut/layout.h b/layout/ut/layout.h
index a851eb0..a5c859d 100644
--- a/layout/ut/layout.h
+++ b/layout/ut/layout.h
@@ -37,7 +37,6 @@ enum {
 	EXISTING_TEST            = true, /* Add a layout to the DB */
 	DUPLICATE_TEST           = true, /* Try to re-add a layout */
 	FAILURE_TEST             = true, /* Failure injected */
-	ADD_TO_DB                = true, /* Add layout/layer/ext to the DB */
 	LAYOUT_DESTROY           = true, /* Delete layout object */
 	UNIT_SIZE                = 4096, /* For pdclust layout type */
 	USER_COUNT_INCREMENTED   = true, /* For verification of user count */
@@ -49,7 +48,7 @@ void allocate_area(struct m0_layout_domain *domain,
 		   m0_bcount_t *num_bytes,
 		   void **area);
 void l_verify(struct m0_layout *l, uint64_t lid,
-	      bool if_user_count_incremented);
+	      bool is_user_count_incremented);
 void lbuf_verify(struct m0_bufvec_cursor *cur, uint32_t *lt_id);
 void lbuf_compare(struct m0_bufvec_cursor *cur1,
 		  struct m0_bufvec_cursor *cur2);
@@ -68,6 +67,7 @@ int layout_lookup(uint64_t lid, struct m0_layout_domain *domain,
 		  const struct m0_layout_type *lt,
 		  bool failure_test,
 		  struct m0_layout **layout);
+void layout_add(struct m0_layout *l);
 void layout_update(struct m0_layout *l);
 
 struct ghost_data {
diff --git a/layout/ut/layout_generic.c b/layout/ut/layout_generic.c
index 0ff27d5..ccf9517 100644
--- a/layout/ut/layout_generic.c
+++ b/layout/ut/layout_generic.c
@@ -45,16 +45,16 @@ struct m0_layout *list_lookup(struct m0_layout_domain *domain, uint64_t lid)
 
 /* Verifies generic part of the layout object. */
 void l_verify(struct m0_layout *l, uint64_t lid,
-	      bool if_user_count_incremented)
+	      bool is_user_count_incremented)
 {
 	M0_UT_ASSERT(l->l_id == lid);
 	M0_UT_ASSERT(m0_ref_read(&l->l_ref) >= 1);
-	M0_UT_ASSERT(ergo(if_user_count_incremented, l->l_user_count > 0));
+	M0_UT_ASSERT(ergo(is_user_count_incremented, l->l_user_count > 0));
 	/* todo Disabling for now since user count of the sublayout for the
 	 * zeroth layer is incremented when layout is added to the DB during
 	 * its creation through the test_lookup_composite().
-	M0_UT_ASSERT(ergo(!if_user_count_incremented, l->l_user_count == 0));
-	*/
+	 */
+	M0_UT_ASSERT(ergo(!is_user_count_incremented, l->l_user_count == 0));
 	M0_UT_ASSERT(l->l_ops != NULL);
 }
 
@@ -278,6 +278,32 @@ int layout_lookup(uint64_t lid, struct m0_layout_domain *domain,
 	return rc;
 }
 
+/* Wrapper that adds the layout to the DB. */
+void layout_add(struct m0_layout *l)
+{
+	m0_bcount_t        num_bytes;
+	void              *area;
+	struct m0_db_pair  pair;
+	struct m0_db_tx    tx;
+	int                rc_tmp;
+	int                rc;
+
+	allocate_area(l->l_dom, ADDITIONAL_BYTES_NONE, &num_bytes, &area);
+
+	rc = m0_db_tx_init(&tx, l->l_dom->ld_dbenv, DBFLAGS);
+	M0_UT_ASSERT(rc == 0);
+
+	pair_set(&pair, &l->l_id, area, num_bytes);
+
+	rc = m0_layout_add(l, &tx, &pair);
+	M0_UT_ASSERT(rc == 0);
+
+	rc_tmp = m0_db_tx_commit(&tx);
+	M0_UT_ASSERT(rc_tmp == 0);
+
+	m0_free(area);
+}
+
 /* Wrapper that updates the layout to the DB. */
 void layout_update(struct m0_layout *l)
 {
diff --git a/layout/ut/pdclust.c b/layout/ut/pdclust.c
index 1484c20..e103829 100644
--- a/layout/ut/pdclust.c
+++ b/layout/ut/pdclust.c
@@ -166,10 +166,10 @@ static void pdclust_l_verify(struct m0_pdclust_layout *pl,
 			     uint64_t lid,
 			     uint32_t N, uint32_t K, uint32_t P,
 			     struct m0_uint128 *seed,
-			     bool if_user_count_incremented)
+			     bool is_user_count_incremented)
 {
 	/* Verify generic part of the layout object. */
-	l_verify(&pl->pl_base.sl_base, lid, if_user_count_incremented);
+	l_verify(&pl->pl_base.sl_base, lid, is_user_count_incremented);
 
 	/* Verify PDCLUST layout type specific part of the layout object. */
 	M0_UT_ASSERT(pl->pl_base.sl_base.l_type == &m0_pdclust_layout_type);
@@ -185,7 +185,7 @@ void pdclust_layout_verify(struct m0_layout *l, uint64_t lid, uint32_t enum_id,
 			   uint32_t N, uint32_t K, uint32_t P,
 			   struct m0_uint128 *seed,
 			   uint32_t A, uint32_t B,
-			   bool if_user_count_incremented)
+			   bool is_user_count_incremented)
 {
 	struct m0_pdclust_layout     *pl;
 	struct m0_layout_list_enum   *list_enum;
@@ -203,7 +203,7 @@ void pdclust_layout_verify(struct m0_layout *l, uint64_t lid, uint32_t enum_id,
 	 * Verify generic and PDCLUST layout type specific parts of the
 	 * layout object.
 	 */
-	pdclust_l_verify(pl, lid, N, K, P, seed, if_user_count_incremented);
+	pdclust_l_verify(pl, lid, N, K, P, seed, is_user_count_incremented);
 
 	/* Verify enum type specific part of the layout object. */
 	M0_UT_ASSERT(pl->pl_base.sl_enum != NULL);
diff --git a/layout/ut/pdclust.h b/layout/ut/pdclust.h
index 2be6188..2d8e89b 100644
--- a/layout/ut/pdclust.h
+++ b/layout/ut/pdclust.h
@@ -43,7 +43,7 @@ void pdclust_layout_verify(struct m0_layout *l, uint64_t lid, uint32_t enum_id,
 			   uint32_t N, uint32_t K, uint32_t P,
 			   struct m0_uint128 *seed,
 			   uint32_t A, uint32_t B,
-			   bool if_user_count_incremented);
+			   bool is_user_count_incremented);
 
 int test_build_pdclust(uint64_t lid, struct m0_layout_domain *domain,
 		       uint32_t enum_id, uint32_t inline_test,
-- 
1.8.3.2

