From 040faaa069124af6d382cccdffb9b1d9e47ab4c6 Mon Sep 17 00:00:00 2001
From: "trupti.patil" <trupti_patil@xyratex.com>
Date: Thu, 21 Mar 2013 18:04:01 +0530
Subject: [PATCH 096/172] Coverage of some more error cases.

---
 layout/composite.c    | 163 +++++++++++++++++++++++++++-----------------------
 layout/ut/composite.c |   8 +--
 layout/ut/layout.c    |  27 +++++++++
 3 files changed, 119 insertions(+), 79 deletions(-)

diff --git a/layout/composite.c b/layout/composite.c
index cc5cd13..f9eff84 100644
--- a/layout/composite.c
+++ b/layout/composite.c
@@ -452,8 +452,9 @@ err1_injected:
 	if (is_user_count_adjust)
 		m0_layout_user_count_inc(layer->clr_sl);
 	comp_layer_tlink_init_at_tail(layer, &cl->cl_layers);
-	*lr = layer;
-	M0_POST(layer_invariant(*lr));
+	if (lr != NULL)
+		*lr = layer;
+	M0_POST(layer_invariant(layer));
 	M0_POST(composite_invariant(cl));
 	M0_LEAVE("lid %llu, layer %lu", (unsigned long long)cl->cl_base.l_id,
 		 (unsigned long)layer->clr_idx);
@@ -566,10 +567,10 @@ M0_INTERNAL int m0_composite_build(struct m0_layout_domain *dom,
 	return rc;
 }
 
-static void layers_delete(struct m0_composite_layout *cl)
+static void layers_inmem_delete(struct m0_composite_layout *cl)
 {
-	struct m0_composite_layer  *layer;
-	struct m0_composite_layer  *layer_prev;
+	struct m0_composite_layer *layer;
+	struct m0_composite_layer *layer_prev;
 	/*
 	 * Start deleting layers from the top-most layer so that the check from
 	 * layer_inmem_delete() that 'it is the top-most layer being
@@ -594,7 +595,7 @@ static void composite_fini(struct m0_ref *ref)
 
 	M0_ENTRY("lid %llu", (unsigned long long)l->l_id);
 	cl = m0_layout_to_cl(l);
-	layers_delete(cl);
+	layers_inmem_delete(cl);
 	comp_layer_tlist_fini(&cl->cl_layers);
 
 	m0_composite_layout_bob_fini(cl);
@@ -926,19 +927,22 @@ static int comp_layout_inbuf_read(struct m0_composite_layout *cl,
 		m0_bufvec_cursor_move(cur, sizeof *lr_header);
 
 		if (lr_header->clh_extents_nr == 0) {
+			rc = -EINVAL;
 			M0_LOG(M0_ERROR, "lid %llu, layer %lu, No extent is "
 			       "present in the buffer",
 			       (unsigned long long)cl->cl_base.l_id,
 			       (unsigned long)i);
-			return -EINVAL;
+			break;
 		}
+
 		sublayout = layout_find(cl->cl_base.l_dom, lr_header->clh_slid);
 		if (sublayout == NULL) {
+			rc = -EINVAL;
 			M0_LOG(M0_ERROR, "lid %llu, sublayout with lid %llu "
 			       "does not exist",
 			       (unsigned long long)cl->cl_base.l_id,
 			       (unsigned long long)lr_header->clh_slid);
-			return -EINVAL;
+			break;
 		}
 
 		M0_ASSERT(lr_header->clh_idx == i);
@@ -951,7 +955,7 @@ static int comp_layout_inbuf_read(struct m0_composite_layout *cl,
 			       (unsigned long)i);
 			/* Release the reference added by m0_layout_find(). */
 			m0_layout_put(sublayout);
-			return rc;
+			break;
 		}
 
 		if (lr_header->clh_idx == 0) /* Zeroth layer */
@@ -960,9 +964,9 @@ static int comp_layout_inbuf_read(struct m0_composite_layout *cl,
 						user_count,
 						!USER_COUNT_ADJUST);
 		else
-			rc = layer_add_internal(cl, sublayout, &extlist,
-						lr_header->clh_extents_nr,
-						NULL, !USER_COUNT_ADJUST);
+			rc = layer_inmem_add(cl, sublayout, &extlist,
+					     lr_header->clh_extents_nr,
+					     !USER_COUNT_ADJUST, NULL);
 		/*
 		 * Release the reference added by m0_layout_find(). In case of
 		 * success, m0_composite_layer_add() has added a reference on
@@ -970,8 +974,20 @@ static int comp_layout_inbuf_read(struct m0_composite_layout *cl,
 		 */
 		m0_layout_put(sublayout);
 
-		if (rc != 0)
+		if (rc != 0) {
+			extlist_free(&extlist);
 			break;
+		}
+	}
+	if (rc != 0 && lr_header->clh_idx > 0) {
+		/*
+		 * Undo the layer addition and the layout population done
+		 * through the earlier iterations of the loop above.
+		 */
+		M0_ASSERT(comp_layer_tlist_length(&cl->cl_layers) ==
+			  lr_header->clh_idx);
+		layers_inmem_delete(cl);
+		composite_populate_reverse(cl);
 	}
 	M0_RETURN(rc);
 }
@@ -999,13 +1015,13 @@ static int composite_decode(struct m0_layout *l,
 	if (op == M0_LXO_BUFFER_OP) {
 		rc = comp_layout_inbuf_read(cl, cur, user_count);
 		if (rc != 0)
-			M0_LOG(M0_ERROR, "lid %llu, failed to read layout from"
+			M0_LOG(M0_ERROR, "lid %llu, failed to read layout from "
 			       "the buffer",
 			       (unsigned long long)cl->cl_base.l_id);
 	} else {
 		rc = comp_layout_indb_read(cl, tx, user_count);
 		if (rc != 0)
-			M0_LOG(M0_ERROR, "lid %llu, failed to read layout from"
+			M0_LOG(M0_ERROR, "lid %llu, failed to read layout from "
 			       "the DB",
 			       (unsigned long long)cl->cl_base.l_id);
 	}
@@ -1168,12 +1184,10 @@ static int ext_inmem_find(struct m0_composite_layer *layer,
 	} m0_tl_endfor;
 
 	if (ext_encountered) {
-		if (lr_ext->cle_state == expected_ext_state) {
-			rc = 0;
-			if (lr_ext_out != NULL)
-				*lr_ext_out = lr_ext;
-		} else
-			rc = -EINVAL; /* Internal, just to help debugging. */
+		M0_ASSERT(lr_ext->cle_state == expected_ext_state);
+		rc = 0;
+		if (lr_ext_out != NULL)
+			*lr_ext_out = lr_ext;
 	} else
 		rc = -ENOENT;
 
@@ -1283,6 +1297,8 @@ static int ext_inmem_add(struct m0_composite_layer *layer,
 		if (ext->e_start <= lr_ext->cle_ext.e_start)
 			break;
 	} m0_tl_endfor;
+	M0_ASSERT(lr_ext_to_insert_after != NULL ||
+		  lr_ext_to_insert_before != NULL);
 
 	if (lr_ext_to_insert_after != NULL)
 		rc = ext_inmem_add_internal(layer, NULL, NULL,
@@ -1292,12 +1308,6 @@ static int ext_inmem_add(struct m0_composite_layer *layer,
 		rc = ext_inmem_add_internal(layer, NULL, NULL,
 					    ext, ext_state, ADD_BEFORE,
 					    lr_ext_to_insert_before);
-	else {
-		M0_ASSERT(ext->e_start == 0 && ext->e_end == M0_BINDEX_MAX + 1);
-		rc = ext_inmem_add_internal(layer, NULL, NULL,
-					    ext, ext_state, ADD_AT_TAIL, NULL);
-	}
-
 	if (rc != 0)
 		M0_LOG(M0_ERROR, "lid %llu, extent could not be added to "
 		       "memory",
@@ -1529,7 +1539,7 @@ static int ext_inmem_validate(struct m0_composite_layout *cl,
 				       (unsigned long long)
 						lr_ext->cle_ext.e_end,
 				       (unsigned long long)lr_ext->cle_state);
-				return rc;
+				break;
 			}
 		} else { /* ext_validation_kind == EXT_DEL_VALIDATION */
 			if (lr_ext->cle_state != M0_CLRES_INVALID &&
@@ -1561,11 +1571,11 @@ static int ext_inmem_validate(struct m0_composite_layout *cl,
 			    first_noninvalid_state == M0_CLRES_INVALID)
 				first_noninvalid_state = lr_ext->cle_state;
 			if (rc != 0)
-				return rc;
+				break;
 		}
 	} m0_tl_endfor;
 
-	return 0;
+	M0_RETURN(rc);
 }
 
 /**
@@ -1967,8 +1977,11 @@ static int emap_iterator_set(struct m0_composite_layout *cl,
 
 	emap = emap_from_cl(cl);
 	prefix_set(&prefix, cl->cl_base.l_id, layer_idx);
+	if (M0_FI_ENABLED("emap_lookup_err"))
+		{ rc = L_EMAP_LOOKUP_ERR; goto err1_injected; }
 	rc = m0_emap_lookup(emap, tx, (struct m0_uint128 *)&prefix,
 			    ext->e_start, it);
+err1_injected:
 	if (rc != 0) {
 		m0_layout__log("emap_iterator_set",
 			       "failed to lookup into layer_emap",
@@ -2516,8 +2529,7 @@ err1_injected:
 			       "failed to write extent, rc %d",
 			       (unsigned long long)cl->cl_base.l_id,
 			       (unsigned long)layer->clr_idx, rc);
-			m0_emap_close(&it);
-			return rc;
+			break;
 		}
 	} m0_tl_endfor;
 
@@ -2573,7 +2585,7 @@ static int extentmap_indb_read(struct m0_composite_layout *cl,
 	emap = emap_from_cl(cl);
 	prefix_set(&prefix, cl->cl_base.l_id, layer_idx);
 	if (M0_FI_ENABLED("emap_lookup_err"))
-		{ rc = L_EMAP_LOOKUP_ERR; goto err1_injected; } 
+		{ rc = L_EMAP_LOOKUP_ERR; goto err1_injected; }
 	rc = m0_emap_lookup(emap, tx, (struct m0_uint128 *)&prefix, 0, &it);
 err1_injected:
 	if (rc != 0) {
@@ -2584,6 +2596,7 @@ err1_injected:
 		return rc;
 	}
 
+	rc = 0;
 	m0_composite_layer_ext_tlist_init(extlist);
 	*extents_nr = 0;
 	seg = m0_emap_seg_get(&it);
@@ -2594,22 +2607,20 @@ err1_injected:
 		if (m0_ext_is_empty(&seg->ee_ext) ||
 		    !M0_IN(seg->ee_val, (M0_CLRES_INVALID, M0_CLRES_VALID,
 					 M0_CLRES_FLATTENING))) {
+			rc = -EINVAL;
 			m0_layout__log("extentmap_indb_read",
 				       "Invalid extent found in the DB",
 				       M0_LAYOUT_ADDB_LOC_COMP_EMAP_READ_3,
 				       &cl->cl_base.l_addb_ctx,
 				       cl->cl_base.l_id, -ENOMEM);
-			m0_emap_close(&it);
-			return -EINVAL;
+			break;
 		}
 
 		rc = ext_inmem_add_internal(NULL, &cl->cl_base, extlist,
 					    &seg->ee_ext, seg->ee_val,
 					    ADD_AT_TAIL, NULL);
-		if (rc != 0) {
-			m0_emap_close(&it);
-			return rc;
-		}
+		if (rc != 0)
+			break;
 
 		if (m0_emap_ext_is_last(&seg->ee_ext))
 			break;
@@ -2617,8 +2628,10 @@ err1_injected:
 		seg = m0_emap_seg_get(&it);
 	}
 	m0_emap_close(&it);
-	*extents_nr = m0_composite_layer_ext_tlist_length(extlist);
-	M0_POST(*extents_nr > 0);
+	if (rc == 0) {
+		*extents_nr = m0_composite_layer_ext_tlist_length(extlist);
+		M0_POST(*extents_nr > 0);
+	}
 	M0_RETURN(rc);
 }
 
@@ -2694,25 +2707,18 @@ static int comp_layout_indb_read(struct m0_composite_layout *cl,
 			rc = layer_inmem_add(cl, sublayout, &extents,
 					     extents_nr,
 					     !USER_COUNT_ADJUST, &layer);
-		if (rc != 0) {
-			M0_LOG(M0_ERROR, "lid %llu, layer %lu could not be "
-			       "written to the layout",
-			       (unsigned long long)cl->cl_base.l_id,
-			       (unsigned long)i);
-			extlist_free(&extents);
-			/* Release the reference added by m0_layout_find(). */
-			m0_layout_put(sublayout);
-			break;
-		}
-
 		/*
 		 * Release the reference added by m0_layout_find().
-		 * composite_populate() or layer_inmem_add() has now added a
-		 * reference on this sublayout.
+		 * In case of success, composite_populate() or
+		 * layer_inmem_add() has now added a reference on this
+		 * sublayout.
 		 */
-		M0_ASSERT(rc == 0);
 		m0_layout_put(sublayout);
 
+		if (rc != 0) {
+			extlist_free(&extents);
+			break;
+		}
 		++i;
 	}
 
@@ -2722,7 +2728,7 @@ static int comp_layout_indb_read(struct m0_composite_layout *cl,
 		 * through the earlier iterations of the loop above.
 		 */
 		M0_ASSERT(comp_layer_tlist_length(&cl->cl_layers) == i);
-		layers_delete(cl);
+		layers_inmem_delete(cl);
 		composite_populate_reverse(cl);
 	}
 
@@ -2786,6 +2792,9 @@ static int layer_delete_verify(struct m0_composite_layout *cl,
 	struct m0_emap_seg               *seg;
 	int                               rc;
 
+	M0_ENTRY("lid %llu, layer %lu", (unsigned long long)cl->cl_base.l_id,
+		 (unsigned long)layer->clr_idx);
+
 	/* In-memory layer verification. */
 	m0_tl_for(m0_composite_layer_ext, &layer->clr_extents, lr_ext) {
 		if (lr_ext->cle_state != M0_CLRES_INVALID) {
@@ -2799,7 +2808,7 @@ static int layer_delete_verify(struct m0_composite_layout *cl,
 					lr_ext->cle_ext.e_start,
 			       (unsigned long long)
 					lr_ext->cle_ext.e_end);
-			return -EINVAL;
+			M0_RETURN(-EINVAL);
 		}
 	} m0_tl_endfor;
 
@@ -2822,6 +2831,7 @@ static int layer_delete_verify(struct m0_composite_layout *cl,
 			M0_ASSERT(seg != NULL);
 			M0_ASSERT(!m0_ext_is_empty(&seg->ee_ext));
 			if (seg->ee_val != M0_CLRES_INVALID) {
+				rc = -EINVAL;
 				M0_LOG(M0_ERROR, "lid %llu, layout can not be "
 				       "deleted since in-db layer %lu "
 				       "still contains at least one valid "
@@ -2832,21 +2842,22 @@ static int layer_delete_verify(struct m0_composite_layout *cl,
 						lr_ext->cle_ext.e_start,
 				       (unsigned long long)
 						lr_ext->cle_ext.e_end);
-				return -EINVAL;
+				break;
 			}
 			if (m0_emap_ext_is_last(&seg->ee_ext))
 				break;
 			m0_emap_next(&it);
 			seg = m0_emap_seg_get(&it);
 		}
-		/*
-		 * Combine all the invalid extents into one, by adding an
-		 * invalid extent with the complete offset space.
-		 */
-		rc = single_ext_indb_write(&it, layer);
+		if (rc == 0)
+			/*
+			 * Combine all the invalid extents into one, by adding
+			 * an invalid extent with the complete offset space.
+			 */
+			rc = single_ext_indb_write(&it, layer);
 		m0_emap_close(&it);
 	}
-	return rc;
+	M0_RETURN(rc);
 }
 
 static int extents_indb_delete(struct m0_composite_layout *cl,
@@ -3051,7 +3062,7 @@ static int ext_indb_lookup(struct m0_composite_layout *cl,
 				       M0_LAYOUT_ADDB_LOC_COMP_EXT_LOOKUP,
 				       &cl->cl_base.l_addb_ctx,
 				       cl->cl_base.l_id, rc);
-			return rc;
+			break;
 		}
 
 		seg = m0_emap_seg_get(&it);
@@ -3072,16 +3083,18 @@ static int ext_indb_lookup(struct m0_composite_layout *cl,
 			break;
 	}
 
-	if (found == true) {
-		*ext = seg->ee_ext;
-		*layer_idx = i;
-		*ext_state = seg->ee_val;
-		layer = layer_find(cl, *layer_idx);
-		M0_ASSERT(layer != NULL);
-		*sublayout = layer->clr_sl;
-		rc = 0;
-	} else
-		rc = -ENOENT;
+	if (rc == 0) {
+		if (found == true) {
+			*ext = seg->ee_ext;
+			*layer_idx = i;
+			*ext_state = seg->ee_val;
+			layer = layer_find(cl, *layer_idx);
+			M0_ASSERT(layer != NULL);
+			*sublayout = layer->clr_sl;
+			rc = 0;
+		} else
+			rc = -ENOENT;
+	}
 
 	M0_LOG(M0_DEBUG, "lid %llu, offset %llu, rc %d, e_start %llu, "
 	       "e_end %llu, layer_idx %lu, ext_state %llu",
diff --git a/layout/ut/composite.c b/layout/ut/composite.c
index 8c2c6e6..14c8ef5 100644
--- a/layout/ut/composite.c
+++ b/layout/ut/composite.c
@@ -2396,6 +2396,8 @@ int test_lookup_composite(uint64_t lid,
 	return rc;
 }
 
+/* todo this test shall not require layer_add_failure_test. layer failure
+is covered in layer ops test. */
 /* Tests the API m0_layout_add(), for the COMPOSITE layout type. */
 int test_add_composite(uint64_t lid,
 		       struct m0_layout_domain *domain,
@@ -2426,8 +2428,7 @@ int test_add_composite(uint64_t lid,
 	/* Build a layout object and add layers to it only in memory. */
 	rc = composite_build_and_layers_add(lid, domain, layers_nr,
 					    min_extents_nr,
-					    if_contiguous_extents,
-					    !ADD_TO_DB,
+					    if_contiguous_extents, !ADD_TO_DB,
 					    !FAILURE_TEST,
 					    !LAYER_ADD_FAILURE_TEST, &cl);
 	M0_UT_ASSERT(rc == 0);
@@ -2440,8 +2441,7 @@ int test_add_composite(uint64_t lid,
 
 	rc = m0_layout_add(&cl->cl_base, &tx, &pair);
 	if (failure_test)
-		M0_UT_ASSERT(rc == LO_ENCODE_ERR);
-		//todo rc == -ENOENT when cursor_init error is injected
+		M0_UT_ASSERT(rc == LO_ENCODE_ERR || rc == L_EMAP_LOOKUP_ERR);
 	else if (layer_add_failure_test)
 		M0_UT_ASSERT(rc == L_TABLE_INSERT_ERR);
 	else
diff --git a/layout/ut/layout.c b/layout/ut/layout.c
index 6c4c367..89953cc 100644
--- a/layout/ut/layout.c
+++ b/layout/ut/layout.c
@@ -782,6 +782,24 @@ static void test_decode_failure(void)
 	M0_UT_ASSERT(rc == -ENOMEM);
 
 	/* todo layer_add failure for zeroth and the next layer? */
+
+	/*
+	 * Simulate memory allocation failure for zeroth layer addition that is
+	 * in the path of composite_populate()
+	 */
+	lid = 4024;
+	m0_fi_enable_once("layer_inmem_add", "mem_err");
+	rc = test_decode_composite(lid, &domain, 5, 6,
+				   !CONTIGUOUS_EXTENTS, FAILURE_TEST);
+	M0_UT_ASSERT(rc == -ENOMEM);
+
+	/* Simulate memory allocation failure for the first layer addition. */
+	lid = 4025;
+	m0_fi_enable_off_n_on_m("layer_inmem_add", "mem_err", 1, 1);
+	rc = test_decode_composite(lid, &domain, 5, 6,
+				   !CONTIGUOUS_EXTENTS, FAILURE_TEST);
+	M0_UT_ASSERT(rc == -ENOMEM);
+	m0_fi_disable("layer_inmem_add", "mem_err");
 }
 
 /* Tests the API m0_layout_encode(). */
@@ -1491,6 +1509,15 @@ static void test_lookup(void)
 				   EXISTING_TEST, !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
+	/*
+	 * Add a layout object with COMPOSITE layout type and with only one
+	 * extent. Then perform lookup for it.
+	 */
+	lid = 18024;
+	rc = test_lookup_composite(lid, &domain, 5, 1, CONTIGUOUS_EXTENTS,
+				   EXISTING_TEST, !FAILURE_TEST);
+	M0_UT_ASSERT(rc == 0);
+
 	domain_ldb_available_set(&domain, false);
 }
 
-- 
1.8.3.2

