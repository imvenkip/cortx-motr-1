From cecf8a4622e4c8c0bc4c52dc6d52c4fc2de769b9 Mon Sep 17 00:00:00 2001
From: "trupti.patil" <trupti_patil@xyratex.com>
Date: Thu, 14 Feb 2013 15:46:59 +0530
Subject: [PATCH 064/172] Added support for in-mem lokkup of ext, in UT - dump
 extlist

---
 layout/composite.c    | 400 +++++++++++++++++++++++++++++++-------------------
 layout/ut/composite.c | 211 +++++++++++++++++++-------
 layout/ut/layout.c    | 121 ++++++++-------
 3 files changed, 463 insertions(+), 269 deletions(-)

diff --git a/layout/composite.c b/layout/composite.c
index 1160b21..7ee1c31 100644
--- a/layout/composite.c
+++ b/layout/composite.c
@@ -187,9 +187,8 @@ static bool composite_invariant(const struct m0_composite_layout *cl)
 							layer->clr_extents));
 }
 
-/* todo Make consistent use of _in_mem_, _in_memory_, _in_db_ */
 /**
- * Verifies that all the extents are back to back and that they cover
+ * Verifies that all the extents are back-to-back and that they cover
  * the entire namespace from 0 to M0_BINDEX_MAX.
  */
 static bool layer_invariant(const struct m0_composite_layer *layer)
@@ -367,11 +366,11 @@ static void composite_delete(struct m0_layout *l)
 }
 
 /** Adds a layer to the in-memory layout. */
-static int layer_in_memory_add(struct m0_composite_layout *cl,
-			       struct m0_layout *sublayout,
-			       struct m0_tl *extlist,
-			       uint32_t ext_nr,
-			       struct m0_composite_layer **lr)
+static int layer_in_mem_add(struct m0_composite_layout *cl,
+			    struct m0_layout *sublayout,
+			    struct m0_tl *extlist,
+			    uint32_t ext_nr,
+			    struct m0_composite_layer **lr)
 {
 	struct m0_composite_layer *layer;
 
@@ -387,7 +386,7 @@ static int layer_in_memory_add(struct m0_composite_layout *cl,
 		 extlist, (unsigned long)ext_nr);
 	M0_ALLOC_PTR(layer);
 	if (layer == NULL) {
-		m0_layout__log("layer_in_memory_add",
+		m0_layout__log("layer_in_mem_add",
 			       "failed to allocate composite layer",
 			       M0_LAYOUT_ADDB_LOC_COMP_LAYER_ALLOC,
 			       &cl->cl_base.l_addb_ctx, cl->cl_base.l_id,
@@ -432,8 +431,8 @@ static void extlist_free(struct m0_tl *extlist)
  * to the DB that has been added to the in-memory layout. Hence, it is assumed
  * that it is the top-most layer that is getting deleted.
  */
-static void layer_in_memory_delete(struct m0_composite_layout *cl,
-				   struct m0_composite_layer *layer)
+static void layer_in_mem_delete(struct m0_composite_layout *cl,
+				struct m0_composite_layer *layer)
 {
 	M0_PRE(layer->clr_idx == cl->cl_layers_nr - 1);
 
@@ -467,7 +466,7 @@ static int composite_populate(struct m0_composite_layout *cl,
 	M0_ENTRY("lid %llu", (unsigned long long)cl->cl_base.l_id);
 	m0_layout__populate(&cl->cl_base, user_count);
 
-	rc = layer_in_memory_add(cl, sublayout, extlist, ext_nr, &layer);
+	rc = layer_in_mem_add(cl, sublayout, extlist, ext_nr, &layer);
 	M0_ASSERT(layer->clr_idx == 0);
 
 	M0_POST(ergo(rc == 0, composite_invariant(cl)));
@@ -528,7 +527,7 @@ static void composite_fini(struct m0_ref *ref)
 	m0_tl_for(comp_layer, &cl->cl_layers, layer) {
 		extlist_free(layer->clr_extents);
 		comp_layer_tlink_del_fini(layer);
-		/* Release the reference acquired by layer_in_memory_add(). */
+		/* Release the reference acquired by layer_in_mem_add(). */
 		m0_layout_put(layer->clr_l);
 		/*
 		 * The user count for 'the sublayout associated with this
@@ -593,7 +592,7 @@ enum extent_op {
 };
 
 /** Position to add a new extent at, in the list of the extents. */
-//todo Make use of this enum in ext_add_internal()
+//todo Make use of this enum in ext_in_mem_add_internal()
 enum extent_add_position {
 	ADD_AFTER,
 	ADD_BEFORE,
@@ -609,10 +608,10 @@ static void prefix_set(struct layout_prefix *prefix,
 	prefix->lp_filler = 0;
 }
 
-static int ext_in_memory_find(struct m0_composite_layer *layer,
-			      const struct m0_ext *ext,
-			      uint64_t expected_ext_state,
-			      struct m0_composite_layer_extent **lr_ext_out)
+static int ext_in_mem_find(struct m0_composite_layer *layer,
+			   const struct m0_ext *ext,
+			   uint64_t expected_ext_state,
+			   struct m0_composite_layer_extent **lr_ext_out)
 {
 	struct m0_composite_layer_extent *lr_ext;
 	bool                              ext_found;
@@ -644,9 +643,9 @@ static int ext_in_memory_find(struct m0_composite_layer *layer,
 		rc = 0;
 		if (lr_ext_out != NULL)
 			*lr_ext_out = lr_ext;
-#ifdef __KERNEL__
-		M0_ENTRY("lid %llu, layer %lu, e_start %llu, e_end %llu, "
-			 "expected_e_state %llu, actual_e_state %llu",
+#ifndef __KERNEL__
+		printf("lid %llu, layer %lu, e_start %llu, e_end %llu, \n"
+			 "\t expected_e_state %llu, actual_e_state %llu \n",
 			 (unsigned long long)layer->clr_l->l_id,
 			 (unsigned long)layer->clr_idx,
 			 (unsigned long long)ext->e_start,
@@ -666,11 +665,12 @@ static int ext_in_memory_find(struct m0_composite_layer *layer,
 //to Use this fn where applicable to avoid code duplication e.g. in
 //extlist_in_buf_read() but this adds before and not at tail. So, a flag will
 //be required
-static int ext_add_internal(struct m0_composite_layer *layer,
-			    struct m0_composite_layer_extent *adjacent_lr_ext,
-			    const struct m0_ext *ext,
-			    uint64_t ext_state,
-			    bool is_add_after)
+static int ext_in_mem_add_internal(struct m0_composite_layer *layer,
+				   struct m0_composite_layer_extent *
+								adjacent_lr_ext,
+				   const struct m0_ext *ext,
+				   uint64_t ext_state,
+				   bool is_add_after)
 {
 	struct m0_composite_layer_extent *lr_ext1;
 	//struct m0_composite_layer_extent *lr_ext2; //todo rm
@@ -679,14 +679,14 @@ static int ext_add_internal(struct m0_composite_layer *layer,
 	M0_PRE(m0_composite_layer_ext_tlink_is_in(adjacent_lr_ext));
 	M0_PRE(!m0_ext_is_empty(ext));
 #if 0 //todo rm
-	rc = ext_in_memory_find(layer, &adjacent_lr_ext->cle_ext,
-				adjacent_lr_ext->cle_state, &lr_ext2);
+	rc = ext_in_mem_find(layer, &adjacent_lr_ext->cle_ext,
+			     adjacent_lr_ext->cle_state, &lr_ext2);
 	M0_ASSERT(rc == 0);
 #endif
 
 	//todo M0_ENTRY()
 #ifndef __KERNEL__
-	printf("ext_add_internal(1): adjacent_lr_ext_start %llu, "
+	printf("ext_in_mem_add_internal(1): adjacent_lr_ext_start %llu, "
 		"adjacent_lr_ext_end %llu, "
 		"e_start %llu, e_end %llu, ext %p\n",
 		(unsigned long long)adjacent_lr_ext->cle_ext.e_start,
@@ -719,11 +719,11 @@ static int ext_add_internal(struct m0_composite_layer *layer,
 	return 0;
 }
 
-static void ext_del_internal(struct m0_composite_layer *layer,
-			     struct m0_composite_layer_extent *lr_ext)
+static void ext_in_mem_del_internal(struct m0_composite_layer *layer,
+				    struct m0_composite_layer_extent *lr_ext)
 {
 #ifndef __KERNEL__
-	printf("ext_del_internal(): lid %llu, layer %lu, \n"
+	printf("ext_in_mem_del_internal(): lid %llu, layer %lu, \n"
 		"\te_start %llu, e_end %llu, \n",
 		 (unsigned long long)layer->clr_l->l_id,
 		 (unsigned long)layer->clr_idx,
@@ -742,9 +742,9 @@ static void ext_del_internal(struct m0_composite_layer *layer,
  * m0_emap_paste(), it is confirmed that the extent is non-overlapping
  * with any of the other extents in the extent list.
  */
-static int ext_in_memory_add(struct m0_composite_layer *layer,
-			     const struct m0_ext *ext,
-			     uint64_t ext_state)
+static int ext_in_mem_add(struct m0_composite_layer *layer,
+			  const struct m0_ext *ext,
+			  uint64_t ext_state)
 {
 	struct m0_composite_layer_extent *ext_to_insert_before;
 	struct m0_composite_layer_extent *ext_to_insert_after;
@@ -761,7 +761,7 @@ static int ext_in_memory_add(struct m0_composite_layer *layer,
 		 ext);
 
 #ifndef __KERNEL__
-	printf("ext_in_memory_add(1): lid %llu, layer %lu, "
+	printf("ext_in_mem_add(1): lid %llu, layer %lu, "
 		"e_start %llu, e_end %llu, e_state %llu, ext %p\n",
 		 (unsigned long long)layer->clr_l->l_id,
 		 (unsigned long)layer->clr_idx,
@@ -784,7 +784,7 @@ static int ext_in_memory_add(struct m0_composite_layer *layer,
 	M0_ASSERT(ext_to_insert_before != NULL || ext_to_insert_after != NULL);
 
 #ifndef __KERNEL__
-	printf("ext_in_memory_add(2): lid %llu, layer %lu, "
+	printf("ext_in_mem_add(2): lid %llu, layer %lu, "
 		"e_start %llu, e_end %llu, "
 		"e_state %llu, "
 		"ext_to_insert_after %p, ext_to_insert_before %p\n",
@@ -795,9 +795,8 @@ static int ext_in_memory_add(struct m0_composite_layer *layer,
 		 (unsigned long long)ext_state,
 		 ext_to_insert_after, ext_to_insert_before);
 #endif
-	M0_LOG(M0_DEBUG, "ext_in_memory_add(2): lid %llu, layer %lu, "
-		"e_start %llu, e_end %llu, "
-		"e_state %llu, "
+	M0_LOG(M0_DEBUG, "ext_in_mem_add(2): lid %llu, layer %lu, "
+		"e_start %llu, e_end %llu, e_state %llu, "
 		"ext_to_insert_after %p, ext_to_insert_before %p",
 		 (unsigned long long)layer->clr_l->l_id,
 		 (unsigned long)layer->clr_idx,
@@ -807,22 +806,22 @@ static int ext_in_memory_add(struct m0_composite_layer *layer,
 		 ext_to_insert_after, ext_to_insert_before);
 
 	if (ext_to_insert_after != NULL)
-		rc = ext_add_internal(layer, ext_to_insert_after, ext,
-				      ext_state, true);
+		rc = ext_in_mem_add_internal(layer, ext_to_insert_after,
+					     ext, ext_state, true);
 	else if (ext_to_insert_before != NULL)
-		rc = ext_add_internal(layer, ext_to_insert_before, ext,
-				      ext_state, false);
+		rc = ext_in_mem_add_internal(layer, ext_to_insert_before,
+						ext, ext_state, false);
 	M0_ASSERT(rc == 0); //handle
 	M0_RETURN(0);
 }
 
 #ifndef __KERNEL__
 /** Trims the existing extent as requested. */
-static int ext_in_memory_trim(struct m0_composite_layer *layer,
-			      enum extent_op extent_op,
-			      const struct m0_ext *ext_to_trim,
-			      uint64_t ext_state,
-			      const struct m0_ext *trim_reference_ext)
+static int ext_in_mem_trim(struct m0_composite_layer *layer,
+			   enum extent_op extent_op,
+			   const struct m0_ext *ext_to_trim,
+			   uint64_t ext_state,
+			   const struct m0_ext *trim_reference_ext)
 {
 	struct m0_composite_layer_extent *lr_ext;
 	int                               rc;
@@ -841,7 +840,7 @@ static int ext_in_memory_trim(struct m0_composite_layer *layer,
 		 (unsigned long long)trim_reference_ext->e_end);
 
 #ifndef __KERNEL__
-	printf("ext_in_memory_trim(): lid %llu, layer %lu, extent_op %d, "
+	printf("ext_in_mem_trim(): lid %llu, layer %lu, extent_op %d, "
 		 "ext_to_trim_start %llu, ext_to_trim_end %llu, "
 		 "ext_state %llu, "
 		 "trim_ref_ext_start %llu, trim_ref_ext_end %llu\n",
@@ -854,7 +853,7 @@ static int ext_in_memory_trim(struct m0_composite_layer *layer,
 		 (unsigned long long)trim_reference_ext->e_end);
 #endif
 
-	rc = ext_in_memory_find(layer, ext_to_trim, ext_state, &lr_ext);
+	rc = ext_in_mem_find(layer, ext_to_trim, ext_state, &lr_ext);
 	M0_ASSERT(rc == 0); //todo rm
 	if (rc == 0) {
 		M0_ASSERT(lr_ext->cle_ext.e_start <=
@@ -871,9 +870,9 @@ static int ext_in_memory_trim(struct m0_composite_layer *layer,
 	M0_RETURN(rc);
 }
 
-static int ext_in_memory_delete(struct m0_composite_layer *layer,
-				const struct m0_ext *ext,
-				uint64_t old_ext_state)
+static int ext_in_mem_delete(struct m0_composite_layer *layer,
+			     const struct m0_ext *ext,
+			     uint64_t old_ext_state)
 {
 	struct m0_composite_layer_extent *lr_ext;
 	struct m0_composite_layer_extent *lr_ext_to_delete;
@@ -882,7 +881,7 @@ static int ext_in_memory_delete(struct m0_composite_layer *layer,
 
 	//todo rm M0_PRE(old_ext_state != M0_CLRES_INVALID);
 #ifndef __KERNEL__
-	printf("ext_in_memory_delete(): lid %llu, layer %lu, "
+	printf("ext_in_mem_delete(): lid %llu, layer %lu, "
 		"e_start %llu, e_end %llu, old_e_state %llu, ext %p\n",
 		 (unsigned long long)layer->clr_l->l_id,
 		 (unsigned long)layer->clr_idx,
@@ -923,24 +922,24 @@ static int ext_in_memory_delete(struct m0_composite_layer *layer,
 
 	if (lr_ext_to_delete_found && ext->e_end == lr_ext->cle_ext.e_end) {
 		M0_ASSERT(lr_ext_to_delete->cle_state == old_ext_state);
-		ext_del_internal(layer, lr_ext_to_delete);
+		ext_in_mem_del_internal(layer, lr_ext_to_delete);
 		rc = 0;
 	} else
 		rc = -ENOENT;
 	M0_RETURN(rc);
 }
 
-static int ext_in_memory_adjust(struct m0_composite_layer *layer,
-				enum extent_op extent_op,
-				const struct m0_emap_seg *seg,
-				const struct m0_ext *ext)
+static int ext_in_mem_adjust(struct m0_composite_layer *layer,
+			     enum extent_op extent_op,
+			     const struct m0_emap_seg *seg,
+			     const struct m0_ext *ext)
 {
 	int rc;
 
 	M0_PRE(M0_IN(extent_op, (DELETE, CUT_LEFT, CUT_RIGHT)));
 
 #ifndef __KERNEL__
-	printf("ext_in_memory_adjust(): lid %llu, layer %lu, extent_op %d, "
+	printf("ext_in_mem_adjust(): lid %llu, layer %lu, extent_op %d, "
 		 "seg_e_start %llu, seg_e_end %llu, seg_val %llu, "
 		 "e_start %llu, e_end %llu, ext %p\n",
 		 (unsigned long long)layer->clr_l->l_id,
@@ -963,24 +962,15 @@ static int ext_in_memory_adjust(struct m0_composite_layer *layer,
 		 (ext != NULL) ? (unsigned long long)ext->e_start : 0,
 		 (ext != NULL) ? (unsigned long long)ext->e_end : 0);
 
-#if 0 //todo Feb 12
-	/*
-	 * Extents with the state M0_CLRES_INVALID are not stored in the
-	 * in-memory list of the extents. Hence, return right away.
-	 */
-	if (seg->ee_val == M0_CLRES_INVALID)
-		M0_RETURN(0);
-#endif
-
 	if (extent_op == DELETE)
 		/*
 		 * The extent seg->ee_ext is replaced by some newer extent.
 		 * Hence, seg->ee_ext is asked to be deleted.
 		 */
-		rc = ext_in_memory_delete(layer, &seg->ee_ext, seg->ee_val);
+		rc = ext_in_mem_delete(layer, &seg->ee_ext, seg->ee_val);
 	else
-		rc = ext_in_memory_trim(layer, extent_op, &seg->ee_ext,
-					seg->ee_val, ext);
+		rc = ext_in_mem_trim(layer, extent_op, &seg->ee_ext,
+				     seg->ee_val, ext);
 	M0_RETURN(rc);
 }
 #endif /* __KERNEL__ */
@@ -990,7 +980,7 @@ static int ext_in_memory_adjust(struct m0_composite_layer *layer,
  * associated with the specified layer'. With the help of m0_emap_paste(),
  * it deletes or truncates the overlappping extents as necessary.
  *
- * @param in_memory_list_update This flag indicates if the in-memory list of
+ * @param in_mem_list_update This flag indicates if the in-memory list of
  * the extents is to be updated in the context of the callbacks received from
  * m0_emap_paste().
  * - In case of initial addition of the extents into the on-disk extent map
@@ -1004,7 +994,7 @@ static int ext_in_db_write(struct m0_emap_cursor *it,
 			   struct m0_composite_layer *layer,
 			   const struct m0_ext *ext_to_operate,
 			   uint64_t new_ext_state,
-			   bool in_memory_list_update)
+			   bool in_mem_list_update)
 {
 
 	/* LAMBDA is not defined for the kernel space. */
@@ -1015,13 +1005,13 @@ static int ext_in_db_write(struct m0_emap_cursor *it,
 
 	M0_ENTRY("lid %llu, layer %lu, "
 		 "e_start %llu, e_end %llu, new_e_state %llu, "
-		 "in_memory_list_update %d, ext_to_operate %p",
+		 "in_mem_list_update %d, ext_to_operate %p",
 		 (unsigned long long)layer->clr_l->l_id,
 		 (unsigned long)layer->clr_idx,
 		 (unsigned long long)ext_to_operate->e_start,
 		 (unsigned long long)ext_to_operate->e_end,
 		 (unsigned long long)new_ext_state,
-		 in_memory_list_update ? 1 : 0, ext_to_operate);
+		 in_mem_list_update ? 1 : 0, ext_to_operate);
 	M0_PRE(layer_invariant(layer));
 
 	/*
@@ -1056,7 +1046,7 @@ static int ext_in_db_write(struct m0_emap_cursor *it,
 	 * In such a case, multiple small operations are performed internally
 	 * by m0_emap_paste() and the callbacks are sent appropriately. In
 	 * response to those callback, the in-memory list of the extents is
-	 * adjusted accordingly by using the ext_in_memory_adjust() function.
+	 * adjusted accordingly by using the ext_in_mem_adjust() function.
 	 *
 	 * The sequence goes as follows:
 	 * 1) From the extent [2200700, 56668025), its left part that is
@@ -1077,51 +1067,51 @@ static int ext_in_db_write(struct m0_emap_cursor *it,
 #ifndef __KERNEL__
 	printf("ext_in_db_write(): lid %llu, layer %lu, "
 		 "e_start %llu, e_end %llu, new_e_state %llu, "
-		 "in_memory_list_update %d, ext_to_operate %p, ext %p\n",
+		 "in_mem_list_update %d, ext_to_operate %p, ext %p\n",
 		 (unsigned long long)layer->clr_l->l_id,
 		 (unsigned long)layer->clr_idx,
 		 (unsigned long long)ext_to_operate->e_start,
 		 (unsigned long long)ext_to_operate->e_end,
 		 (unsigned long long)new_ext_state,
-		 in_memory_list_update ? 1 : 0, ext_to_operate, &ext);
+		 in_mem_list_update ? 1 : 0, ext_to_operate, &ext);
 #endif
 	rc_cb = 0;
 	rc = m0_emap_paste(it, &ext, new_ext_state,
 		LAMBDA(void, (struct m0_emap_seg *seg) {
 			/* Extent deletion. */
-			if (in_memory_list_update) {
-				rc_cb = rc_cb ?: ext_in_memory_adjust(layer,
-								      DELETE,
-								      seg,
-								      NULL);
+			if (in_mem_list_update) {
+				rc_cb = rc_cb ?: ext_in_mem_adjust(layer,
+								   DELETE,
+								   seg,
+								   NULL);
 			}
 		}),
 		LAMBDA(void, (struct m0_emap_seg *seg,
 			      struct m0_ext *extent,
 			      uint64_t val) {
 			/* Cut left. */
-			if (in_memory_list_update) {
-				rc_cb = rc_cb ?: ext_in_memory_adjust(layer,
-								      CUT_LEFT,
-								      seg,
-								      extent);
+			if (in_mem_list_update) {
+				rc_cb = rc_cb ?: ext_in_mem_adjust(layer,
+								   CUT_LEFT,
+								   seg,
+								   extent);
 			}
 		}),
 		LAMBDA(void, (struct m0_emap_seg *seg,
 			      struct m0_ext *extent,
 			      uint64_t val) {
 			/* Cut right. */
-			if (in_memory_list_update) {
-				rc_cb = rc_cb ?: ext_in_memory_adjust(layer,
-								      CUT_RIGHT,
-								      seg,
-								      extent);
+			if (in_mem_list_update) {
+				rc_cb = rc_cb ?: ext_in_mem_adjust(layer,
+								   CUT_RIGHT,
+								   seg,
+								   extent);
 			}
 		}));
 
 	rc = rc ?: rc_cb;
 
-	if (rc == 0 && in_memory_list_update) {
+	if (rc == 0 && in_mem_list_update) {
 		/*
 		 * Now that the deletion/trimming of the overlapping extents
 		 * from the in-memory list of the extents has been
@@ -1131,11 +1121,11 @@ static int ext_in_db_write(struct m0_emap_cursor *it,
 		 * todo Handle the case that there may be existing INVALID ext.
 		 * Refer to ext_in_mem_write().
 		 */
-		rc = ext_in_memory_find(layer, ext_to_operate, new_ext_state,
-					NULL);
+		rc = ext_in_mem_find(layer, ext_to_operate, new_ext_state,
+				     NULL);
 		if (rc == -ENOENT)
-			rc = ext_in_memory_add(layer, ext_to_operate,
-					       new_ext_state);
+			rc = ext_in_mem_add(layer, ext_to_operate,
+					    new_ext_state);
 	}
 	M0_RETURN(rc);
 #else
@@ -1415,7 +1405,7 @@ M0_INTERNAL int m0_composite_layer_add(struct m0_composite_layout *cl,
 		return -EINVAL;
 	}
 
-	rc = layer_in_memory_add(cl, sublayout, extlist, ext_nr, &layer);
+	rc = layer_in_mem_add(cl, sublayout, extlist, ext_nr, &layer);
 	if (rc != 0) {
 		m0_layout__log("m0_composite_layer_add",
 			       "failed to write layer in memory",
@@ -1441,7 +1431,7 @@ M0_INTERNAL int m0_composite_layer_add(struct m0_composite_layout *cl,
 			       "failed to write layer in DB",
 			       M0_LAYOUT_ADDB_LOC_COMP_LAYER_ADD_3,
 			       &cl->cl_base.l_addb_ctx, cl->cl_base.l_id, rc);
-		layer_in_memory_delete(cl, layer);
+		layer_in_mem_delete(cl, layer);
 	}
 
 DB_sync_skipped:
@@ -1770,8 +1760,8 @@ static int comp_layout_in_db_read(struct m0_composite_layout *cl,
 						extents_nr, user_count);
 		else
 			/* Now, write the layer to the in-memory layout. */
-			rc = layer_in_memory_add(cl, sublayout, extents,
-						 extents_nr, &layer);
+			rc = layer_in_mem_add(cl, sublayout, extents,
+					      extents_nr, &layer);
 		if (rc != 0) {
 			M0_LOG(M0_ERROR, "lid %llu, layer %lu could not be "
 			       "written to the layout",
@@ -1784,7 +1774,7 @@ static int comp_layout_in_db_read(struct m0_composite_layout *cl,
 
 		/*
 		 * Release the reference added by m0_layout_find().
-		 * layer_in_memory_add() has now added a reference on this
+		 * layer_in_mem_add() has now added a reference on this
 		 * sublayout.
 		 */
 		M0_ASSERT(rc == 0);
@@ -2020,38 +2010,91 @@ static struct m0_composite_layer *layer_find(
 	return layer;
 }
 
-/*
- * todo Verify functioning of this API. Currently in UT, all the layers
- * contain same list of extents. So traversing layers part is not being
- * verified.
- */
-M0_INTERNAL int m0_composite_layer_ext_lookup(struct m0_composite_layout *cl,
-					      m0_bindex_t offset,
-					      struct m0_db_tx *tx,
-					      uint32_t *layer_idx,
-					      struct m0_ext *ext,
-					      uint64_t *ext_state,
-					      struct m0_layout **sublayout)
+static int ext_in_mem_lookup(struct m0_composite_layout *cl,
+			     m0_bindex_t offset,
+			     uint32_t *layer_idx,
+			     struct m0_ext *ext,
+			     uint64_t *ext_state,
+			     struct m0_layout **sublayout)
+{
+	struct m0_composite_layer        *layer;
+	struct m0_composite_layer_extent *lr_ext;
+	bool                              found;
+	uint32_t                          i;
+	int                               rc;
+
+	M0_ENTRY("lid %llu, offset %llu", (unsigned long long)cl->cl_base.l_id,
+		 (unsigned long long)offset);
+#ifndef __KERNEL__
+	printf("ext_in_mem_lookup(): lid %llu, offset %llu\n",
+		 (unsigned long long)cl->cl_base.l_id,
+		 (unsigned long long)offset);
+#endif
+
+	/* Start the lookup with the top-most layer. */
+	i = cl->cl_layers_nr - 1;
+	found = false;
+
+	m0_tl_for(comp_layer, &cl->cl_layers, layer) {
+		M0_ASSERT(layer->clr_idx == i);
+		m0_tl_for(m0_composite_layer_ext, layer->clr_extents, lr_ext) {
+			if (offset > lr_ext->cle_ext.e_start)
+				continue;
+			else if (offset < lr_ext->cle_ext.e_end &&
+				 lr_ext->cle_state != M0_CLRES_INVALID) {
+				M0_ASSERT(offset >= lr_ext->cle_ext.e_start);
+				found = true;
+				break;
+			}
+		} m0_tl_endfor;
+	} m0_tl_endfor;
+
+	if (found == true) {
+		*layer_idx = i;
+		*ext = lr_ext->cle_ext;
+		*ext_state = lr_ext->cle_state;
+		layer = layer_find(cl, *layer_idx);
+		M0_ASSERT(layer != NULL);
+		*sublayout = layer->clr_l;
+		rc = 0;
+	} else
+		rc = -ENOENT;
+
+#ifndef __KERNEL__
+	printf("ext_in_mem_lookup(): lid %llu, offset %llu, "
+		"rc %d, layer_id %lu\n",
+		(unsigned long long)cl->cl_base.l_id,
+		(unsigned long long)offset, rc, (unsigned long)*layer_idx);
+#endif
+	M0_RETURN(rc);
+}
+
+static int ext_in_db_lookup(struct m0_composite_layout *cl,
+			    m0_bindex_t offset,
+			    struct m0_db_tx *tx,
+			    uint32_t *layer_idx,
+			    struct m0_ext *ext,
+			    uint64_t *ext_state,
+			    struct m0_layout **sublayout)
 {
 	struct m0_emap            *emap;
 	struct m0_emap_cursor      it;
 	struct m0_emap_seg        *seg;
 	struct layout_prefix       prefix;
+	struct m0_composite_layer *layer;
 	uint32_t                   i; /* layer idx */
 	bool                       found;
-	struct m0_composite_layer *layer;
 	int                        rc;
 
-	M0_PRE(composite_invariant(cl));
+	M0_PRE(tx != NULL);
 	M0_ENTRY("lid %llu, offset %llu", (unsigned long long)cl->cl_base.l_id,
 		 (unsigned long long)offset);
 #ifndef __KERNEL__
-	printf("m0_composite_layer_ext_lookup(): lid %llu, offset %llu\n",
+	printf("ext_in_db_lookup(): lid %llu, offset %llu\n",
 		 (unsigned long long)cl->cl_base.l_id,
 		 (unsigned long long)offset);
 #endif
 
-	m0_mutex_lock(&cl->cl_base.l_lock);
 	emap = emap_from_cl(cl);
 
 	/* Start the lookup with the top-most layer. */
@@ -2105,6 +2148,53 @@ M0_INTERNAL int m0_composite_layer_ext_lookup(struct m0_composite_layout *cl,
 	} else
 		rc = -ENOENT;
 
+#ifndef __KERNEL__
+	printf("ext_in_db_lookup(): lid %llu, offset %llu, "
+		"rc %d, layer_id %lu\n",
+		(unsigned long long)cl->cl_base.l_id,
+		(unsigned long long)offset, rc, (unsigned long)*layer_idx);
+#endif
+	M0_RETURN(rc);
+}
+
+/*
+ * todo Verify functioning of this API. Currently in UT, all the layers
+ * contain same list of extents. So traversing layers part is not being
+ * verified.
+ */
+M0_INTERNAL int m0_composite_layer_ext_lookup(struct m0_composite_layout *cl,
+					      m0_bindex_t offset,
+					      struct m0_db_tx *tx,
+					      uint32_t *layer_idx,
+					      struct m0_ext *ext,
+					      uint64_t *ext_state,
+					      struct m0_layout **sublayout)
+{
+	int rc;
+
+	M0_PRE(composite_invariant(cl));
+	M0_PRE(offset >= 0 && offset <= M0_BINDEX_MAX);
+	M0_PRE(ext != NULL && ext_state != NULL && sublayout != NULL);
+	/* todo M0_PRE(ergo(cl->cl_base.l_dom->ld_do_i_have_DB, tx != NULL)); */
+
+	M0_ENTRY("lid %llu, offset %llu", (unsigned long long)cl->cl_base.l_id,
+		 (unsigned long long)offset);
+#ifndef __KERNEL__
+	printf("m0_composite_layer_ext_lookup(): lid %llu, offset %llu\n",
+		 (unsigned long long)cl->cl_base.l_id,
+		 (unsigned long long)offset);
+#endif
+
+	m0_mutex_lock(&cl->cl_base.l_lock);
+
+	if (tx == NULL)
+		rc = ext_in_mem_lookup(cl, offset, layer_idx,
+				       ext, ext_state, sublayout);
+	else
+		rc = ext_in_db_lookup(cl, offset, tx, layer_idx,
+				      ext, ext_state, sublayout);
+	M0_ASSERT(rc == 0 || rc == -ENOENT); //todo Handle, log etc
+
 	m0_mutex_unlock(&cl->cl_base.l_lock);
 	M0_LEAVE("lid %llu, offset %llu, rc %d, layer_id %lu",
 		 (unsigned long long)cl->cl_base.l_id,
@@ -2115,6 +2205,7 @@ M0_INTERNAL int m0_composite_layer_ext_lookup(struct m0_composite_layout *cl,
 		(unsigned long long)cl->cl_base.l_id,
 		(unsigned long long)offset, rc, (unsigned long)*layer_idx);
 #endif
+	M0_PRE(composite_invariant(cl));
 	return rc;
 }
 
@@ -2138,8 +2229,8 @@ static int ext_split_internal(struct m0_composite_layer *layer,
 
 
 #if 1 //todo rm
-	rc = ext_in_memory_find(layer, &lr_ext->cle_ext, lr_ext->cle_state,
-				&lr_ext1);
+	rc = ext_in_mem_find(layer, &lr_ext->cle_ext, lr_ext->cle_state,
+			     &lr_ext1);
 	M0_ASSERT(rc == 0);
 	M0_ASSERT(lr_ext == lr_ext1);
 #endif
@@ -2149,8 +2240,8 @@ static int ext_split_internal(struct m0_composite_layer *layer,
 		if (len != 0) {
 			ext.e_start = scan;
 			ext.e_end = scan = scan + len;
-			rc = ext_add_internal(layer, lr_ext, &ext,
-					      vec->iv_index[i], false);
+			rc = ext_in_mem_add_internal(layer, lr_ext, &ext,
+						     vec->iv_index[i], false);
 			M0_ASSERT(rc == 0); //todo Handle
 			//todo If i==0, check if the ext shall be merged with th prior one
 			if (rc != 0)
@@ -2158,7 +2249,7 @@ static int ext_split_internal(struct m0_composite_layer *layer,
 		}
 	}
 
-	ext_del_internal(layer, lr_ext);
+	ext_in_mem_del_internal(layer, lr_ext);
 	return rc;
 }
 
@@ -2370,7 +2461,7 @@ static int ext_in_mem_write(struct m0_composite_layout *cl,
 			rc = 0; //todo check if req'd
 
 		if (delete_required == true)
-			ext_del_internal(layer, lr_ext_to_del);
+			ext_in_mem_del_internal(layer, lr_ext_to_del);
 
 		ext->e_start += consumed;
 		M0_ASSERT(ext->e_start <= ext->e_end);
@@ -2394,34 +2485,36 @@ static int ext_in_mem_write(struct m0_composite_layout *cl,
 		 * Shall query for the extent and its state and if it is inval
 		 * then add the ext
 		 * OR
-		 * change ext_in_memory_find() such that it returns ENOENT
+		 * change ext_in_mem_find() such that it returns ENOENT
 		 * if the ext is with the inval state
 		 */
-		rc = ext_in_memory_find(layer, &ext0, M0_CLRES_INVALID,
-					&lr_ext_to_del1);
+		rc = ext_in_mem_find(layer, &ext0, M0_CLRES_INVALID,
+				     &lr_ext_to_del1);
 		// todo Feb 11 if (rc == -ENOENT) {
 		if (rc == 0) {
 			lr_ext_to_del1->cle_state = ext_state;
 #if 0
 			if (ext_state != M0_CLRES_INVALID) {
-				/* todo Refactor usage of ext_add_internal() so
-				 * that don't have to pass the adjacent ext
+				/* todo Refactor usage of
+				 * ext_in_mem_add_internal() so that
+				 * don't have to pass the adjacent ext
 				 */
 				/* todo Latest, don't add and then delete, just
 				 * change state of the existing ext.
 				 */
-				rc = ext_in_memory_add(layer, &ext0, ext_state);
+				rc = ext_in_mem_add(layer, &ext0, ext_state);
 				M0_ASSERT(rc == 0);
-				ext_del_internal(layer, lr_ext_to_del1);
+				ext_in_mem_del_internal(layer,
+							lr_ext_to_del1);
 				M0_ASSERT(rc == 0);
 			}
 #endif
 		} else {
-			rc1 = ext_in_memory_find(layer, &ext0, ext_state,
-						 &lr_ext_to_del1);
+			rc1 = ext_in_mem_find(layer, &ext0, ext_state,
+					      &lr_ext_to_del1);
 			M0_ASSERT(rc1 == -ENOENT); //todo correct?
 			if (rc1 == -ENOENT) {
-				rc = ext_in_memory_add(layer, &ext0, ext_state);
+				rc = ext_in_mem_add(layer, &ext0, ext_state);
 				M0_ASSERT(rc == 0);
 			}
 		}
@@ -2432,11 +2525,11 @@ static int ext_in_mem_write(struct m0_composite_layout *cl,
 	return rc;
 }
 
-static int ext_in_mem_and_DB_write(struct m0_composite_layout *cl,
-				   struct m0_composite_layer *layer,
-				   const struct m0_ext *ext,
-				   uint64_t new_state,
-				   struct m0_db_tx *tx)
+static int ext_in_mem_n_DB_write(struct m0_composite_layout *cl,
+				 struct m0_composite_layer *layer,
+				 const struct m0_ext *ext,
+				 uint64_t new_state,
+				 struct m0_db_tx *tx)
 {
 	struct m0_emap        *emap;
 	struct m0_emap_cursor  it;
@@ -2444,7 +2537,7 @@ static int ext_in_mem_and_DB_write(struct m0_composite_layout *cl,
 	int                    rc;
 
 #ifndef __KERNEL__
-	printf("ext_in_mem_and_DB_write(): lid %llu, layer %lu, e_start %llu, "
+	printf("ext_in_mem_n_DB_write(): lid %llu, layer %lu, e_start %llu, "
 		"e_end %llu, e_state %llu, ext %p\n",
 		 (unsigned long long)layer->clr_l->l_id,
 		 (unsigned long)layer->clr_idx,
@@ -2467,7 +2560,7 @@ static int ext_in_mem_and_DB_write(struct m0_composite_layout *cl,
 	rc = m0_emap_lookup(emap, tx, (struct m0_uint128 *)&prefix,
 			    ext->e_start, &it);
 	if (rc != 0) {
-		m0_layout__log("ext_in_mem_and_DB_write",
+		m0_layout__log("ext_in_mem_n_DB_write",
 			       "failed to lookup into layer_emap",
 			       M0_LAYOUT_ADDB_LOC_COMP_EXT_ADD_1,
 			       &cl->cl_base.l_addb_ctx, cl->cl_base.l_id, rc);
@@ -2494,7 +2587,7 @@ static int ext_in_mem_and_DB_write(struct m0_composite_layout *cl,
 
 	rc = ext_in_db_write(&it, layer, ext, new_state, true);
 	if (rc != 0)
-		m0_layout__log("ext_in_mem_and_DB_write",
+		m0_layout__log("ext_in_mem_n_DB_write",
 			       "failed to write extent in DB",
 			       M0_LAYOUT_ADDB_LOC_COMP_EXT_ADD_2,
 			       &cl->cl_base.l_addb_ctx, cl->cl_base.l_id, rc);
@@ -2510,13 +2603,12 @@ M0_INTERNAL int m0_composite_layer_ext_add(struct m0_composite_layout *cl,
 					   struct m0_db_tx *tx)
 {
 	struct m0_composite_layer *layer;
-	struct m0_ext              ext1 = *ext; //todo May considering making such copy in ext_in_mem_write() and ext_in_mem_and_DB_write()
+	struct m0_ext              ext1 = *ext; //todo May considering making such copy in ext_in_mem_write() and ext_in_mem_n_DB_write()
 	int                        rc;
 
 	M0_PRE(composite_invariant(cl));
 	M0_PRE(ext != NULL);
-	/* todo change this to s'thing like
-	M0_PRE(ergo(cl->cl_base.l_dom->ld_do_i_have_DB, tx != NULL)); */
+	/* todo M0_PRE(ergo(cl->cl_base.l_dom->ld_do_i_have_DB, tx != NULL)); */
 	M0_ENTRY("lid %llu, layer %lu, e_start %llu, e_end %llu",
 		 (unsigned long long)cl->cl_base.l_id,
 		 (unsigned long)layer_idx, (unsigned long long)ext->e_start,
@@ -2536,11 +2628,11 @@ M0_INTERNAL int m0_composite_layer_ext_add(struct m0_composite_layout *cl,
 	if (tx == NULL)
 		rc = ext_in_mem_write(cl, layer, &ext1, M0_CLRES_VALID);
 	else
-		rc = ext_in_mem_and_DB_write(cl, layer, ext, M0_CLRES_VALID,
-					     tx);
+		rc = ext_in_mem_n_DB_write(cl, layer, ext, M0_CLRES_VALID, tx);
 
 	m0_mutex_unlock(&cl->cl_base.l_lock);
 	M0_POST(layer_invariant(layer));
+	M0_POST(composite_invariant(cl));
 	M0_RETURN(rc);
 }
 
@@ -2653,14 +2745,13 @@ M0_INTERNAL int m0_composite_layer_ext_delete(struct m0_composite_layout *cl,
 					      struct m0_db_tx *tx)
 {
 	struct m0_composite_layer *layer;
-	//todo May consider making such copy in ext_in_mem_write() and ext_in_mem_and_DB_write() instead of doing it here. Check its usage properly
+	//todo May consider making such copy in ext_in_mem_write() and ext_in_mem_n_DB_write() instead of doing it here. Check its usage properly
 	struct m0_ext              ext1 = *ext;
 	int                        rc;
 
 	M0_PRE(composite_invariant(cl));
 	M0_PRE(ext != NULL);
-	/* todo change this to s'thing like
-	M0_PRE(ergo(cl->cl_base.l_dom->ld_do_i_have_DB, tx != NULL)); */
+	/* todo M0_PRE(ergo(cl->cl_base.l_dom->ld_do_i_have_DB, tx != NULL)); */
 	M0_ENTRY("lid %llu, layer %lu, e_start %llu, e_end %llu, ext %p",
 		 (unsigned long long)cl->cl_base.l_id,
 		 (unsigned long)layer_idx, (unsigned long long)ext->e_start,
@@ -2683,11 +2774,12 @@ M0_INTERNAL int m0_composite_layer_ext_delete(struct m0_composite_layout *cl,
 	if (tx == NULL)
 		rc = ext_in_mem_write(cl, layer, &ext1, M0_CLRES_INVALID);
 	else
-		rc = ext_in_mem_and_DB_write(cl, layer, ext, M0_CLRES_INVALID,
-					     tx);
+		rc = ext_in_mem_n_DB_write(cl, layer, ext, M0_CLRES_INVALID,
+					   tx);
 
 	m0_mutex_unlock(&cl->cl_base.l_lock);
 	M0_POST(layer_invariant(layer));
+	M0_POST(composite_invariant(cl));
 #ifndef __KERNEL__
 	printf("m0_composite_layer_ext_delete(2): lid %llu, layer %lu, "
 		"e_start %llu, e_end %llu, ext %p\n",
diff --git a/layout/ut/composite.c b/layout/ut/composite.c
index e7e5257..369e594 100644
--- a/layout/ut/composite.c
+++ b/layout/ut/composite.c
@@ -22,6 +22,7 @@
 #include "lib/memory.h"             /* M0_ALLOC_PTR() */
 #include "lib/misc.h"               /* M0_IN() */
 #include "lib/finject.h" //todo Check if req'd
+#include "lib/trace.h"              /* m0_console_printf() */
 
 #include "layout/layout.h"
 #include "layout/layout_internal.h" /* *_ERR */
@@ -147,7 +148,7 @@ static void extentlist_build(struct m0_tl **extlist,
 	m0_composite_layer_ext_tlist_init(extents);
 	M0_UT_ASSERT(m0_composite_layer_ext_tlist_is_empty(extents));
 
-#if 1
+#if 0
 #ifndef __KERNEL__
 	printf("extents_nr %lu, min_start_offset %llu, "
 	       "approximate_end_offset %llu\n",
@@ -172,7 +173,7 @@ static void extentlist_build(struct m0_tl **extlist,
 			/* Make every alternate extent INVALID. */
 			extent->cle_state = M0_CLRES_INVALID;
 
-#if 1
+#if 0
 #ifndef __KERNEL__
 	printf("ext[%u]: start %llu, end %llu, state %llu \n", i,
 		(unsigned long long)extent->cle_ext.e_start,
@@ -266,6 +267,144 @@ static void composite_layout_verify(struct m0_layout *l,
         } m0_tl_endfor;
 }
 
+static struct m0_composite_layer *layer_find(
+					const struct m0_composite_layout *cl,
+					uint32_t layer_idx)
+{
+	struct m0_composite_layer *layer = NULL;
+
+	M0_PRE(layer_idx < cl->cl_layers_nr);
+
+	m0_tl_for(comp_layer, &cl->cl_layers, layer) {
+		if (layer->clr_idx == layer_idx)
+			break;
+	} m0_tl_endfor;
+
+	M0_ASSERT(layer != NULL);
+	return layer;
+}
+
+#if 0
+//todo Feb 13 Use my_console_printf() wherever applicable
+static bool is_my_console_printf_enabled = true;
+static void my_console_printf(const char *fmt, ...)
+{
+	/*
+	 * Mero guideline (?) says:
+	 *        In general UT should produce no output, but if they need to,
+	 *        it should be some "temporary" debugging output.
+	 *
+	 * In case of the composite layout, specifically involving extent
+	 * lists/masks, it is very often that we will need
+	 * such temporary debugging output to be available to help:
+	 * - Understanding the code
+	 * - Debug known issues if any with the steps to reproduce being known
+	 * - Debug issues during future enhancements
+	 *
+	 * So, this function my_console_printf() provides a facility
+	 * - To have such temporary debugging messages unavailable by default.
+	 * - When required, these messages can be compiled in by making a
+	 *   change at a single location.
+	 *
+	 * The change required to make the debugging messaged available is:
+	 * - Setting the value of is_my_console_printf_enabled as 'true'.
+	 */
+
+	if (is_my_console_printf_enabled) {
+		va_list ap;
+
+		va_start(ap, fmt);
+		m0_console_printf(fmt, va_arg(ap, char *));
+		va_end(ap);
+	}
+}
+#endif
+
+static void extlist_dump(const struct m0_composite_layout *cl,
+			 uint32_t layer_idx)
+{
+	struct m0_composite_layer        *layer;
+	struct m0_composite_layer_extent *lr_ext;
+	uint32_t                          i = 0;
+
+	layer = layer_find(cl, layer_idx);
+#ifndef __KERNEL__
+        printf("extlist_dump(): lid %llu, layer %lu: \n",
+	       (unsigned long long)cl->cl_base.l_id,
+	       (unsigned long)layer_idx);
+        m0_tl_for(m0_composite_layer_ext, layer->clr_extents, lr_ext) {
+                printf("\text[%lu]: start %llu, end %llu, state %llu \n",
+                       (unsigned long)i,
+                       (unsigned long long)lr_ext->cle_ext.e_start,
+                       (unsigned long long)lr_ext->cle_ext.e_end,
+                       (unsigned long long)lr_ext->cle_state);
+		++i;
+        } m0_tl_endfor;
+#else
+	printk("extlist_dump(): lid %llu, layer %lu: \n",
+	       (unsigned long long)cl->cl_base.l_id,
+	       (unsigned long)layer_idx);
+        m0_tl_for(m0_composite_layer_ext, layer->clr_extents, lr_ext) {
+                printk("\text[%lu]: start %llu, end %llu, state %llu \n",
+                       (unsigned long)i,
+                       (unsigned long long)lr_ext->cle_ext.e_start,
+                       (unsigned long long)lr_ext->cle_ext.e_end,
+                       (unsigned long long)lr_ext->cle_state);
+		++i;
+        } m0_tl_endfor;
+#endif
+
+#if 0
+	/*
+	 * todo Something is wrong with the following that the start value
+	 * is printed with value of i. Even the state is being printed
+	 * wrong for some extents.
+	 */
+	my_console_printf("extlist_dump(): lid %llu, layer %lu: \n ",
+			  (unsigned long long)cl->cl_base.l_id,
+			  (unsigned long)layer_idx);
+	i = 0;
+	m0_tl_for(m0_composite_layer_ext, layer->clr_extents, lr_ext) {
+		my_console_printf("\t ext[%lu]: start %llu, end %llu, "
+				  "state %llu \n",
+				  (unsigned long)i,
+				  (unsigned long long)lr_ext->cle_ext.e_start,
+				  (unsigned long long)lr_ext->cle_ext.e_end,
+				  (unsigned long long)lr_ext->cle_state);
+		++i;
+	} m0_tl_endfor;
+
+#endif
+}
+
+static void composite_dump(const struct m0_composite_layout *cl)
+{
+	struct m0_composite_layer *layer;
+
+#ifndef __KERNEL__
+	printf("composite_dump(): lid %llu, layers_nr %lu: \n ",
+	       (unsigned long long)cl->cl_base.l_id,
+	       (unsigned long)cl->cl_layers_nr);
+#else
+	printk("composite_dump(): lid %llu, layers_nr %lu: \n ",
+	       (unsigned long long)cl->cl_base.l_id,
+	       (unsigned long)cl->cl_layers_nr);
+#endif
+
+#if 0
+	/*
+	 * todo Something is wrong with the following that the layers_nr value
+	 * is printed with value of lid.
+	 */
+	my_console_printf("composite_dump(): lid %llu, layers_nr %lu: \n ",
+			  (unsigned long long)cl->cl_base.l_id,
+			  (unsigned long)cl->cl_layers_nr);
+#endif
+	m0_tl_for(comp_layer, &cl->cl_layers, layer) {
+		extlist_dump(cl, layer->clr_idx);
+	} m0_tl_endfor;
+}
+
 /* Builds a layout object with COMPOSITE layout type. */
 static int composite_build(uint64_t lid,
 			   struct m0_layout_domain *domain,
@@ -404,6 +543,8 @@ static int composite_build_and_layers_add(uint64_t lid,
 		M0_UT_ASSERT(rc == L_TABLE_INSERT_ERR);
 	else
 		M0_UT_ASSERT(rc == 0);
+
+	composite_dump(*cl);
 	return rc;
 }
 
@@ -567,6 +708,11 @@ static void extent_to_be_operated(const struct m0_composite_layout *cl,
 		ext->e_end = ext_idxth.e_end - 2;
 	}
 
+	/* todo
+	my_console_printf("extent_to_be_operated: start %llu, end %llu \n",
+		(unsigned long long)ext->e_start,
+		(unsigned long long)ext->e_end);
+	*/
 #if 1
 #ifndef __KERNEL__
 	printf("extent_to_be_operated: start %llu, end %llu \n",
@@ -576,47 +722,6 @@ static void extent_to_be_operated(const struct m0_composite_layout *cl,
 #endif
 }
 
-#ifndef __KERNEL__
-static struct m0_composite_layer *layer_find(
-					const struct m0_composite_layout *cl,
-					uint32_t layer_idx)
-{
-	struct m0_composite_layer *layer = NULL;
-
-	M0_PRE(layer_idx < cl->cl_layers_nr);
-
-	m0_tl_for(comp_layer, &cl->cl_layers, layer) {
-		if (layer->clr_idx == layer_idx)
-			break;
-	} m0_tl_endfor;
-
-	M0_ASSERT(layer != NULL);
-	return layer;
-}
-#endif
-
-static void extlist_dump(const struct m0_composite_layout *cl,
-			 uint32_t layer_idx)
-{
-#ifndef __KERNEL__
-	struct m0_composite_layer        *layer;
-	struct m0_composite_layer_extent *lr_ext;
-	uint32_t                          i = 0;
-
-	layer = layer_find(cl, layer_idx);
-
-
-	printf("extlist_dump(): layer %lu: \n", (unsigned long)layer_idx);
-	m0_tl_for(m0_composite_layer_ext, layer->clr_extents, lr_ext) {
-		printf("\text[%lu]: start %llu, end %llu, state %llu \n",
-			(unsigned long)i,
-			(unsigned long long)lr_ext->cle_ext.e_start,
-			(unsigned long long)lr_ext->cle_ext.e_end,
-			(unsigned long long)lr_ext->cle_state);
-	} m0_tl_endfor;
-#endif
-}
-
 static void extent_to_be_operated(const struct m0_composite_layout *cl,
 				  bool if_contiguous_extents,
 				  uint32_t layer_idx,
@@ -1709,16 +1814,16 @@ int test_delete_composite(uint64_t lid,
 	return rc;
 }
 
-int ext_operate(enum extent_operation eop,
-		uint64_t lid,
-		struct m0_layout_domain *domain,
-		uint32_t layers_nr,
-		uint32_t min_extents_nr,
-		m0_bindex_t min_start_offset,
-		m0_bindex_t approximate_end_offset,
-		bool if_contiguous_extents,
-		uint32_t kind_of_extent_to_operate,
-		bool failure_test)
+static int ext_operate(enum extent_operation eop,
+		       uint64_t lid,
+		       struct m0_layout_domain *domain,
+		       uint32_t layers_nr,
+		       uint32_t min_extents_nr,
+		       m0_bindex_t min_start_offset,
+		       m0_bindex_t approximate_end_offset,
+		       bool if_contiguous_extents,
+		       uint32_t kind_of_extent_to_operate,
+		       bool failure_test)
 {
 	struct m0_layout           *l;
 	struct m0_layout           *l_copy_orig;
diff --git a/layout/ut/layout.c b/layout/ut/layout.c
index b40c2c1..552140f 100644
--- a/layout/ut/layout.c
+++ b/layout/ut/layout.c
@@ -467,7 +467,7 @@ static void test_build(void)
 	 * extents in its layers and destroy it.
 	 */
 	lid = 1021;
-	rc = test_build_composite(lid, &domain, 5, 100,
+	rc = test_build_composite(lid, &domain, 5, 10,
 				  lid * 100, lid * 100 * 100,
 				  CONTIGUOUS_EXTENTS, !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
@@ -477,7 +477,7 @@ static void test_build(void)
 	 * extents in its layers and destroy it.
 	 */
 	lid = 1022;
-	rc = test_build_composite(lid, &domain, 6, 100,
+	rc = test_build_composite(lid, &domain, 5, 11,
 				  lid * 100, lid * 100 * 100,
 				  !CONTIGUOUS_EXTENTS, !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
@@ -488,7 +488,7 @@ static void test_build(void)
 	 * M0_BINDEX_MAX and destroy it.
 	 */
 	lid = 1023;
-	rc = test_build_composite(lid, &domain, 6, 100,
+	rc = test_build_composite(lid, &domain, 5, 12,
 				  0, M0_BINDEX_MAX,
 				  !CONTIGUOUS_EXTENTS, !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
@@ -497,7 +497,7 @@ static void test_build(void)
 
 	/* todo tempo */
 	lid = 1025;
-	rc = test_layer_op_inmem_composite(lid, &domain, 6, 6, //todo 100,
+	rc = test_layer_op_inmem_composite(lid, &domain, 6, 6,
 					   lid * 100, lid * 100 * 100,
 					   CONTIGUOUS_EXTENTS,
 					   EXACT_EXISTING,
@@ -505,7 +505,7 @@ static void test_build(void)
 	M0_UT_ASSERT(rc == 0);
 
 	lid = 1026;
-	rc = test_layer_op_inmem_composite(lid, &domain, 6, 6, //todo 100,
+	rc = test_layer_op_inmem_composite(lid, &domain, 6, 6,
 					   lid * 100, lid * 100 * 100,
 					   !CONTIGUOUS_EXTENTS,
 					   EXACT_EXISTING,
@@ -513,7 +513,7 @@ static void test_build(void)
 	M0_UT_ASSERT(rc == 0);
 
 	lid = 1027;
-	rc = test_layer_op_inmem_composite(lid, &domain, 6, 6, //todo 100,
+	rc = test_layer_op_inmem_composite(lid, &domain, 6, 7,
 					   lid * 100, lid * 100 * 100,
 					   !CONTIGUOUS_EXTENTS,
 					   OVERLAPPING_LEFT,
@@ -521,7 +521,7 @@ static void test_build(void)
 	M0_UT_ASSERT(rc == 0);
 
 	lid = 1028;
-	rc = test_layer_op_inmem_composite(lid, &domain, 6, 6, //todo 100,
+	rc = test_layer_op_inmem_composite(lid, &domain, 6, 8,
 					   lid * 100, lid * 100 * 100,
 					   CONTIGUOUS_EXTENTS,
 					   OVERLAPPING_LEFT,
@@ -529,7 +529,7 @@ static void test_build(void)
 	M0_UT_ASSERT(rc == 0);
 
 	lid = 1029;
-	rc = test_layer_op_inmem_composite(lid, &domain, 6, 6, //todo 100,
+	rc = test_layer_op_inmem_composite(lid, &domain, 6, 8,
 					   lid * 100, lid * 100 * 100,
 					   !CONTIGUOUS_EXTENTS,
 					   OVERLAPPING_RIGHT,
@@ -537,7 +537,7 @@ static void test_build(void)
 	M0_UT_ASSERT(rc == 0);
 
 	lid = 1030;
-	rc = test_layer_op_inmem_composite(lid, &domain, 6, 6, //todo 100,
+	rc = test_layer_op_inmem_composite(lid, &domain, 4, 8,
 					   lid * 100, lid * 100 * 100,
 					   CONTIGUOUS_EXTENTS,
 					   OVERLAPPING_RIGHT,
@@ -545,7 +545,7 @@ static void test_build(void)
 	M0_UT_ASSERT(rc == 0);
 
 	lid = 1031; //todo
-	rc = test_layer_op_inmem_composite(lid, &domain, 6, 6, //todo 100,
+	rc = test_layer_op_inmem_composite(lid, &domain, 4, 9,
 					   lid * 100, lid * 100 * 100,
 					   CONTIGUOUS_EXTENTS,
 					   CONTAINED_WITHIN,
@@ -707,7 +707,6 @@ static void test_decode(void)
 				   !CONTIGUOUS_EXTENTS, !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
-	//todo ? 0, M0_BINDEX_MAX,
 	m0_fi_disable("m0_composite_layer_add", "skip_DB_sync");
 }
 
@@ -838,7 +837,7 @@ static void test_encode(void)
 	 * layers.
 	 */
 	lid = 5005;
-	rc = test_encode_composite(lid, &domain, 9, 25,
+	rc = test_encode_composite(lid, &domain, 8, 25,
 				   lid * 100, lid * 100 * 100,
 				   CONTIGUOUS_EXTENTS, !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
@@ -848,13 +847,11 @@ static void test_encode(void)
 	 * layers.
 	 */
 	lid = 5006;
-	rc = test_encode_composite(lid, &domain, 10, 25,
+	rc = test_encode_composite(lid, &domain, 9, 25,
 				   lid * 100, lid * 100 * 100,
 				   !CONTIGUOUS_EXTENTS, !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
-	//todo ? 0, M0_BINDEX_MAX,
-
 	m0_fi_disable("m0_composite_layer_add", "skip_DB_sync");
 }
 
@@ -951,7 +948,7 @@ static void test_decode_encode(void)
 	 * buffer.
 	 */
 	lid = 7005;
-	rc = test_decode_encode_composite(lid, &domain, 5, 4, //todo 11, 21
+	rc = test_decode_encode_composite(lid, &domain, 5, 10,
 					  lid * 100, lid * 10 * 100,
 					  CONTIGUOUS_EXTENTS);
 	M0_UT_ASSERT(rc == 0);
@@ -1437,7 +1434,7 @@ static void test_lookup(void)
 	 */
 	lid = 14008;
 	rc = test_lookup_composite(lid, &domain,
-				   7, 107,
+				   7, 30,
 				   lid * 100, lid * 100 * 100,
 				   !CONTIGUOUS_EXTENTS,
 				   !EXISTING_TEST,
@@ -1450,7 +1447,7 @@ static void test_lookup(void)
 	 */
 	lid = 14009;
 	rc = test_lookup_composite(lid, &domain,
-				   2, 2, /* 10, 108, */ /* 2, 5, */
+				   2, 30,
 				   lid * 100, lid * 100 * 100,
 				   !CONTIGUOUS_EXTENTS,
 				   EXISTING_TEST,
@@ -1463,7 +1460,7 @@ static void test_lookup(void)
 	 */
 	lid = 14010;
 	rc = test_lookup_composite(lid, &domain,
-				   /* todo 10, 108 */ 2, 5,
+				   5, 5,
 				   lid * 100, lid * 100 * 100,
 				   CONTIGUOUS_EXTENTS,
 				   EXISTING_TEST,
@@ -1474,10 +1471,11 @@ static void test_lookup(void)
 	 * Add a layout object with COMPOSITE layout type and with the extents
 	 * ranging over the complete namespace (0 to M0_BINDEX_MAX). Then
 	 * perform lookup for it.
+	 * todo Take out such cases with M0_BINDEX_MAX range.
 	 */
 	lid = 14011;
 	rc = test_lookup_composite(lid, &domain,
-				   2, 5, /* todo 10, 108, */
+				   20, 5,
 				   0, M0_BINDEX_MAX,
 				   CONTIGUOUS_EXTENTS,
 				   EXISTING_TEST,
@@ -1632,9 +1630,8 @@ static void test_add(void)
 	M0_UT_ASSERT(rc == 0);
 
 	/* Add a layout object with COMPOSITE layout type. */
-	/* todo This test has mem leak of about 30 KB */
 	lid = 16005;
-	rc = test_add_composite(lid, &domain, 7, 5, /* todo 7, 107 */
+	rc = test_add_composite(lid, &domain, 7, 50,
 				lid * 100, lid * 100 * 100,
 				!CONTIGUOUS_EXTENTS,
 				LAYOUT_DESTROY, NULL,
@@ -1645,7 +1642,7 @@ static void test_add(void)
 
 	/* Add a layout object with COMPOSITE layout type. */
 	lid = 16006;
-	rc = test_add_composite(lid, &domain, 7, 5, /* todo 7, 107 */
+	rc = test_add_composite(lid, &domain, 5, 25,
 				0, M0_BINDEX_MAX,
 				!CONTIGUOUS_EXTENTS,
 				LAYOUT_DESTROY, NULL,
@@ -1720,7 +1717,7 @@ static void test_add_failure(void)
 	 * DUPLICATE_TEST.
 	 */
 	lid = 17005;
-	rc = test_add_composite(lid, &domain, 7, 5, /* todo 7, 107 */
+	rc = test_add_composite(lid, &domain, 4, 15,
 				lid * 100, lid * 100 * 100,
 				CONTIGUOUS_EXTENTS,
 				LAYOUT_DESTROY, NULL,
@@ -1738,7 +1735,7 @@ static void test_add_failure(void)
 	m0_fi_enable_off_n_on_m("sublayout_id_in_db_add", "table_insert_err",
 				1, 1);
 	lid = 17006;
-	rc = test_add_composite(lid, &domain, 7, 5, /* todo 7, 107 */
+	rc = test_add_composite(lid, &domain, 4, 15,
 				lid * 100, lid * 100 * 100,
 				!CONTIGUOUS_EXTENTS,
 				LAYOUT_DESTROY, NULL,
@@ -1891,7 +1888,7 @@ static void test_delete(void)
 
 	/* Delete a layout object with COMPOSITE layout type. */
 	lid = 20005;
-	rc = test_delete_composite(lid, &domain, 7, 5, /* todo 7, 107 */
+	rc = test_delete_composite(lid, &domain, 4, 10,
 				   lid * 100, lid * 100 * 100,
 				   CONTIGUOUS_EXTENTS,
 				   !FAILURE_TEST);
@@ -1970,56 +1967,56 @@ static void test_composite_layer_ops(void)
 
 	/* Test cases for extent lookup. */
 	lid = 22001;
-	rc = test_ext_lookup_composite(lid, &domain, 6, 4, /* todo 100, */
+	rc = test_ext_lookup_composite(lid, &domain, 3, 4,
 				       lid * 100, lid * 100 * 100,
 				       !CONTIGUOUS_EXTENTS, NON_EXISTING,
 				       !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
 	lid = 22002;
-	rc = test_ext_lookup_composite(lid, &domain, 6, 4 /* todo 100 */,
+	rc = test_ext_lookup_composite(lid, &domain, 3, 8,
 				       lid * 100, lid * 100 * 100,
 				       CONTIGUOUS_EXTENTS, EXACT_EXISTING,
 				       !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
 	lid = 22003;
-	rc = test_ext_lookup_composite(lid, &domain, 6, 4 /* todo 100 */,
+	rc = test_ext_lookup_composite(lid, &domain, 3, 10,
 				       lid * 100, lid * 100 * 100,
 				       !CONTIGUOUS_EXTENTS, EXACT_EXISTING,
 				       !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
 	lid = 22004;
-	rc = test_ext_lookup_composite(lid, &domain, 6, 4, /* todo 100, */
+	rc = test_ext_lookup_composite(lid, &domain, 3, 10,
 				       lid * 100, lid * 100 * 100,
 				       CONTIGUOUS_EXTENTS, OVERLAPPING_LEFT,
 				       !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
 	lid = 22005;
-	rc = test_ext_lookup_composite(lid, &domain, 6, 4, /* todo 100, */
+	rc = test_ext_lookup_composite(lid, &domain, 3, 10,
 				       lid * 100, lid * 100 * 100,
 				       !CONTIGUOUS_EXTENTS, OVERLAPPING_LEFT,
 				       !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
 	lid = 22006;
-	rc = test_ext_lookup_composite(lid, &domain, 6, 4, /* todo 100, */
+	rc = test_ext_lookup_composite(lid, &domain, 3, 10,
 				       lid * 100, lid * 100 * 100,
 				       CONTIGUOUS_EXTENTS, OVERLAPPING_RIGHT,
 				       !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
 	lid = 22007;
-	rc = test_ext_lookup_composite(lid, &domain, 6, 4, /* todo 100, */
+	rc = test_ext_lookup_composite(lid, &domain, 4, 10,
 				       lid * 100, lid * 100 * 100,
 				       !CONTIGUOUS_EXTENTS, OVERLAPPING_RIGHT,
 				       !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
 	lid = 22008;
-	rc = test_ext_lookup_composite(lid, &domain, 6, 4, /* todo 100, */
+	rc = test_ext_lookup_composite(lid, &domain, 4, 12,
 				       lid * 100, lid * 100 * 100,
 				       CONTIGUOUS_EXTENTS,
 				       OVERLAPPING_COMPLETE,
@@ -2027,7 +2024,7 @@ static void test_composite_layer_ops(void)
 	M0_UT_ASSERT(rc == 0);
 
 	lid = 22009;
-	rc = test_ext_lookup_composite(lid, &domain, 6, 4, /* todo 100, */
+	rc = test_ext_lookup_composite(lid, &domain, 4, 12,
 				       lid * 100, lid * 100 * 100,
 				       !CONTIGUOUS_EXTENTS,
 				       OVERLAPPING_COMPLETE,
@@ -2036,63 +2033,63 @@ static void test_composite_layer_ops(void)
 
 	/* Test cases for extent addition. */
 	lid = 22021;
-	rc = test_ext_add_composite(lid, &domain, 6, 4,
+	rc = test_ext_add_composite(lid, &domain, 4, 12,
 				    lid * 100, lid * 100 * 100,
 				    !CONTIGUOUS_EXTENTS, NON_EXISTING,
 				    !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
 	lid = 22022;
-	rc = test_ext_add_composite(lid, &domain, 6, 4,
+	rc = test_ext_add_composite(lid, &domain, 4, 12,
 				    lid * 100, lid * 100 * 100,
 				    CONTIGUOUS_EXTENTS, EXACT_EXISTING,
 				    !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
 	lid = 22023;
-	rc = test_ext_add_composite(lid, &domain, 6, 4,
+	rc = test_ext_add_composite(lid, &domain, 4, 12,
 				    lid * 100, lid * 100 * 100,
 				    !CONTIGUOUS_EXTENTS, EXACT_EXISTING,
 				    !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
 	lid = 22024;
-	rc = test_ext_add_composite(lid, &domain, 6, 4,
+	rc = test_ext_add_composite(lid, &domain, 4, 12,
 				    lid * 100, lid * 100 * 100,
 				    CONTIGUOUS_EXTENTS, OVERLAPPING_LEFT,
 				    !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
 	lid = 22025;
-	rc = test_ext_add_composite(lid, &domain, 6, 4,
+	rc = test_ext_add_composite(lid, &domain, 4, 12,
 				    lid * 100, lid * 100 * 100,
 				    !CONTIGUOUS_EXTENTS, OVERLAPPING_LEFT,
 				    !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
 	lid = 22026;
-	rc = test_ext_add_composite(lid, &domain, 6, 4,
+	rc = test_ext_add_composite(lid, &domain, 4, 13,
 				    lid * 100, lid * 100 * 100,
 				    CONTIGUOUS_EXTENTS, OVERLAPPING_RIGHT,
 				    !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
 	lid = 22027;
-	rc = test_ext_add_composite(lid, &domain, 6, 4,
+	rc = test_ext_add_composite(lid, &domain, 4, 13,
 				    lid * 100, lid * 100 * 100,
 				    CONTIGUOUS_EXTENTS, OVERLAPPING_RIGHT,
 				    !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
 	lid = 22028;
-	rc = test_ext_add_composite(lid, &domain, 6, 4,
+	rc = test_ext_add_composite(lid, &domain, 4, 13,
 				    lid * 100, lid * 100 * 100,
 				    CONTIGUOUS_EXTENTS, OVERLAPPING_COMPLETE,
 				    !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
 	lid = 22029;
-	rc = test_ext_add_composite(lid, &domain, 6, 4,
+	rc = test_ext_add_composite(lid, &domain, 4, 13,
 				    lid * 100, lid * 100 * 100,
 				    !CONTIGUOUS_EXTENTS, OVERLAPPING_COMPLETE,
 				    !FAILURE_TEST);
@@ -2100,7 +2097,7 @@ static void test_composite_layer_ops(void)
 
 	/* Test cases for extent updation. */
 	lid = 22041;
-	rc = test_ext_state_update_composite(lid, &domain, 6, 4,
+	rc = test_ext_state_update_composite(lid, &domain, 6, 13,
 					     lid * 100, lid * 100 * 100,
 					     !CONTIGUOUS_EXTENTS,
 					     NON_EXISTING,
@@ -2108,7 +2105,7 @@ static void test_composite_layer_ops(void)
 	M0_UT_ASSERT(rc == 0);
 
 	lid = 22042;
-	rc = test_ext_state_update_composite(lid, &domain, 6, 4,
+	rc = test_ext_state_update_composite(lid, &domain, 6, 14,
 					     lid * 100, lid * 100 * 100,
 					     CONTIGUOUS_EXTENTS,
 					     EXACT_EXISTING,
@@ -2116,7 +2113,7 @@ static void test_composite_layer_ops(void)
 	M0_UT_ASSERT(rc == 0);
 
 	lid = 22043;
-	rc = test_ext_state_update_composite(lid, &domain, 6, 4,
+	rc = test_ext_state_update_composite(lid, &domain, 6, 14,
 					     lid * 100, lid * 100 * 100,
 					     !CONTIGUOUS_EXTENTS,
 					     EXACT_EXISTING,
@@ -2124,7 +2121,7 @@ static void test_composite_layer_ops(void)
 	M0_UT_ASSERT(rc == 0);
 
 	lid = 22044;
-	rc = test_ext_state_update_composite(lid, &domain, 6, 4,
+	rc = test_ext_state_update_composite(lid, &domain, 6, 14,
 					     lid * 100, lid * 100 * 100,
 					     CONTIGUOUS_EXTENTS,
 					     OVERLAPPING_LEFT,
@@ -2132,7 +2129,7 @@ static void test_composite_layer_ops(void)
 	M0_UT_ASSERT(rc == 0);
 
 	lid = 22045;
-	rc = test_ext_state_update_composite(lid, &domain, 6, 4,
+	rc = test_ext_state_update_composite(lid, &domain, 6, 14,
 					     lid * 100, lid * 100 * 100,
 					     !CONTIGUOUS_EXTENTS,
 					     OVERLAPPING_LEFT,
@@ -2140,7 +2137,7 @@ static void test_composite_layer_ops(void)
 	M0_UT_ASSERT(rc == 0);
 
 	lid = 22046;
-	rc = test_ext_state_update_composite(lid, &domain, 6, 4,
+	rc = test_ext_state_update_composite(lid, &domain, 6, 14,
 					     lid * 100, lid * 100 * 100,
 					     CONTIGUOUS_EXTENTS,
 					     OVERLAPPING_RIGHT,
@@ -2148,7 +2145,7 @@ static void test_composite_layer_ops(void)
 	M0_UT_ASSERT(rc == 0);
 
 	lid = 22047;
-	rc = test_ext_state_update_composite(lid, &domain, 6, 4,
+	rc = test_ext_state_update_composite(lid, &domain, 6, 15,
 					     lid * 100, lid * 100 * 100,
 					     !CONTIGUOUS_EXTENTS,
 					     OVERLAPPING_RIGHT,
@@ -2156,7 +2153,7 @@ static void test_composite_layer_ops(void)
 	M0_UT_ASSERT(rc == 0);
 
 	lid = 22048;
-	rc = test_ext_state_update_composite(lid, &domain, 6, 4,
+	rc = test_ext_state_update_composite(lid, &domain, 6, 15,
 					     lid * 100, lid * 100 * 100,
 					     CONTIGUOUS_EXTENTS,
 					     OVERLAPPING_COMPLETE,
@@ -2164,7 +2161,7 @@ static void test_composite_layer_ops(void)
 	M0_UT_ASSERT(rc == 0);
 
 	lid = 22049;
-	rc = test_ext_state_update_composite(lid, &domain, 6, 4,
+	rc = test_ext_state_update_composite(lid, &domain, 6, 15,
 					     lid * 100, lid * 100 * 100,
 					     !CONTIGUOUS_EXTENTS,
 					     OVERLAPPING_COMPLETE,
@@ -2174,7 +2171,7 @@ static void test_composite_layer_ops(void)
 	/* Test cases for extent deletion. */
 #if 1 //todo m0_composite_layer_ext_delete() shall handle EINVAL case
 	lid = 22061;
-	rc = test_ext_delete_composite(lid, &domain, 6, 4,
+	rc = test_ext_delete_composite(lid, &domain, 4, 15,
 				       lid * 100, lid * 100 * 100,
 				       !CONTIGUOUS_EXTENTS, NON_EXISTING,
 				       !FAILURE_TEST);
@@ -2182,49 +2179,49 @@ static void test_composite_layer_ops(void)
 #endif
 
 	lid = 22062;
-	rc = test_ext_delete_composite(lid, &domain, 6, 4,
+	rc = test_ext_delete_composite(lid, &domain, 4, 15,
 				       lid * 100, lid * 100 * 100,
 				       CONTIGUOUS_EXTENTS, EXACT_EXISTING,
 				       !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
 	lid = 22063;
-	rc = test_ext_delete_composite(lid, &domain, 6, 4,
+	rc = test_ext_delete_composite(lid, &domain, 4, 16,
 				       lid * 100, lid * 100 * 100,
 				       !CONTIGUOUS_EXTENTS, EXACT_EXISTING,
 				       !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
 	lid = 22064;
-	rc = test_ext_delete_composite(lid, &domain, 6, 4,
+	rc = test_ext_delete_composite(lid, &domain, 4, 16,
 				       lid * 100, lid * 100 * 100,
 				       CONTIGUOUS_EXTENTS, OVERLAPPING_LEFT,
 				       !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
 	lid = 22065;
-	rc = test_ext_delete_composite(lid, &domain, 6, 4,
+	rc = test_ext_delete_composite(lid, &domain, 4, 16,
 				       lid * 100, lid * 100 * 100,
 				       !CONTIGUOUS_EXTENTS, OVERLAPPING_LEFT,
 				       !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
 	lid = 22066;
-	rc = test_ext_delete_composite(lid, &domain, 6, 4,
+	rc = test_ext_delete_composite(lid, &domain, 4, 16,
 				       lid * 100, lid * 100 * 100,
 				       CONTIGUOUS_EXTENTS, OVERLAPPING_RIGHT,
 				       !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
 	lid = 22067;
-	rc = test_ext_delete_composite(lid, &domain, 6, 4,
+	rc = test_ext_delete_composite(lid, &domain, 4, 16,
 				       lid * 100, lid * 100 * 100,
 				       !CONTIGUOUS_EXTENTS, OVERLAPPING_RIGHT,
 				       !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
 	lid = 22068;
-	rc = test_ext_delete_composite(lid, &domain, 6, 4,
+	rc = test_ext_delete_composite(lid, &domain, 4, 16,
 				       lid * 100, lid * 100 * 100,
 				       CONTIGUOUS_EXTENTS,
 				       OVERLAPPING_COMPLETE,
@@ -2232,7 +2229,7 @@ static void test_composite_layer_ops(void)
 	M0_UT_ASSERT(rc == 0);
 
 	lid = 22069;
-	rc = test_ext_delete_composite(lid, &domain, 6, 4,
+	rc = test_ext_delete_composite(lid, &domain, 4, 17,
 				       lid * 100, lid * 100 * 100,
 				       !CONTIGUOUS_EXTENTS,
 				       OVERLAPPING_COMPLETE,
-- 
1.8.3.2

