From b64d8bd695b43db6b4bae0be93e1e7c9f9994203 Mon Sep 17 00:00:00 2001
From: "trupti.patil" <trupti_patil@xyratex.com>
Date: Thu, 8 Aug 2013 18:00:00 +0530
Subject: [PATCH 170/172] From UT, taking out stuff related to
 CONTIGUOUS_EXTENTS

- Now, since ext gets merged with the adjacent ones if their states are the
  same. Hence extents can not be contiguous when they have same states.
---
 layout/ut/composite.c | 785 ++++++++++++++------------------------------------
 layout/ut/composite.h |  29 +-
 layout/ut/layout.c    | 248 ++++------------
 3 files changed, 281 insertions(+), 781 deletions(-)

diff --git a/layout/ut/composite.c b/layout/ut/composite.c
index 04e854a..377dd1e 100644
--- a/layout/ut/composite.c
+++ b/layout/ut/composite.c
@@ -44,13 +44,13 @@ static int composite_layout_build(uint64_t lid,
 				  struct m0_composite_layout **cl);
 
 /**
- * Builds a layout with pdclust or composite layout types alternatively.
+ * Builds a layout with pdclust or composite type of sub-layouts alternatively.
  *
  * Since the sublayout id is formed as composite_lid * 100 + layer_idx,
  * the layer 0 gets pdclust type of a sublayout and the 1st layer gets
  * composite type of a sublayout.
  */
-static int sublayout_build(uint64_t sublayout_id,
+static int sublayout_build(uint64_t sl_id,
 			   struct m0_layout_domain *domain,
 			   struct m0_layout **sublayout)
 {
@@ -66,21 +66,20 @@ static int sublayout_build(uint64_t sublayout_id,
 	struct m0_composite_layout   *cl;
 	int                           rc;
 
-	if (sublayout_id % 2 == 0) {
+	if (sl_id % 2 == 0) {
 		m0_uint128_init(&seed, "sublayouts_build");
-		enum_id = sublayout_id % 2 ? LIST_ENUM_ID : LINEAR_ENUM_ID;
-		inline_test = sublayout_id % 5 ?
+		enum_id = sl_id % 2 ? LIST_ENUM_ID : LINEAR_ENUM_ID;
+		inline_test = sl_id % 5 ?
 			LESS_THAN_INLINE : MORE_THAN_INLINE;
 		NKP_assign(enum_id, inline_test, 9, 109, 1200, &N, &K, &P);
-		rc = pdclust_layout_build(sublayout_id, domain, enum_id,
+		rc = pdclust_layout_build(sl_id, domain, enum_id,
 					  N, K, P, &seed, 10, 20,
 					  &pl, &list_enum, &lin_enum,
 					  !FAILURE_TEST);
 		M0_UT_ASSERT(rc == 0);
 		*sublayout = m0_pdl_to_layout(pl);
 	} else {
-		rc = composite_layout_build(sublayout_id, domain,
-					    !FAILURE_TEST, &cl);
+		rc = composite_layout_build(sl_id, domain, !FAILURE_TEST, &cl);
 		M0_UT_ASSERT(rc == 0);
 		*sublayout = m0_cl_to_layout(cl);
 	}
@@ -103,33 +102,33 @@ static void sublayouts_precreate(uint64_t composite_lid,
 				 struct m0_layout_domain *domain,
 				 uint32_t layers_nr)
 {
-	uint64_t          sublayout_id;
-	struct m0_layout *sublayout;
+	uint64_t          sl_id;
+	struct m0_layout *sl;
 	uint32_t          i;
 	int               rc;
 
 	for (i = 1; i < layers_nr; ++i) {
-		sublayout_id = composite_lid * 100 + i;
-		rc = sublayout_build(sublayout_id, domain, &sublayout);
+		sl_id = composite_lid * 100 + i;
+		rc = sublayout_build(sl_id, domain, &sl);
 		M0_UT_ASSERT(rc == 0);
 	}
 }
 
 static void sublayout_delete(struct m0_layout_domain *domain,
-			     uint64_t sublayout_id)
+			     uint64_t sl_id)
 {
-	struct m0_layout *sublayout;
+	struct m0_layout *sl;
 
-	sublayout = m0_layout_find(domain, sublayout_id);
-	M0_UT_ASSERT(sublayout != NULL);
+	sl = m0_layout_find(domain, sl_id);
+	M0_UT_ASSERT(sl != NULL);
 	/* Release the reference acquired by m0_layout_find(). */
-	m0_layout_put(sublayout);
+	m0_layout_put(sl);
 	/*
 	 * Release the reference acquired during creation of the
 	 * sublayout so as to delete the sublayout.
 	 */
-	m0_layout_put(sublayout);
-	M0_UT_ASSERT(m0_layout_find(domain, sublayout_id) == NULL);
+	m0_layout_put(sl);
+	M0_UT_ASSERT(m0_layout_find(domain, sl_id) == NULL);
 }
 
 /**
@@ -140,28 +139,25 @@ static void sublayouts_delete(struct m0_layout_domain *domain,
 			      uint64_t composite_lid,
 			      uint32_t layers_nr)
 {
-	uint64_t sublayout_id;
+	uint64_t sl_id;
 	uint32_t i;
 
 	for (i = 0; i < layers_nr; ++i) {
-		sublayout_id = composite_lid * 100 + i;
-		sublayout_delete(domain, sublayout_id);
+		sl_id = composite_lid * 100 + i;
+		sublayout_delete(domain, sl_id);
 		/*
 		 * Alternate sublayouts are of the kind composite. So, for
 		 * those composite sublayouts, sublayout from each of their
 		 * zeroth layer has to be deleted.
 		 */
 		if (i % 2 != 0) {
-			sublayout_id = (composite_lid * 100 + i) * 100;
-			sublayout_delete(domain, sublayout_id);
+			sl_id = (composite_lid * 100 + i) * 100;
+			sublayout_delete(domain, sl_id);
 		}
 	}
 }
 
-//todo Rename to extlist_... everywhere applicable
-static void extentlist_build(struct m0_tl *extents,
-			     uint32_t extents_nr,
-			     bool is_contiguous_extents)
+static void extlist_build(struct m0_tl *extents, uint32_t extents_nr)
 {
 	struct m0_composite_layer_ext *lr_ext;
 	m0_bindex_t                    delta;
@@ -181,19 +177,17 @@ static void extentlist_build(struct m0_tl *extents,
 			lr_ext->cle_ext.e_end = END_OFFSET;
 		else
 			lr_ext->cle_ext.e_end = lr_ext->cle_ext.e_start + delta;
-
-		if (is_contiguous_extents || i % 2 == 0)
+		/* Make every alternate extent a hole. */
+		if (i % 2 == 0)
 			lr_ext->cle_state = M0_CLRES_VALID;
 		else
-			/* Make every alternate extent a hole. */
 			lr_ext->cle_state = M0_CLRES_HOLE;
-
 		ext_tlink_init_at_tail(lr_ext, extents);
 	}
 	M0_UT_ASSERT(!ext_tlist_is_empty(extents));
 }
 
-static void extentlist_free(struct m0_tl *extlist)
+static void extlist_free(struct m0_tl *extlist)
 {
 	struct m0_composite_layer_ext *lr_ext;
 
@@ -204,8 +198,8 @@ static void extentlist_free(struct m0_tl *extlist)
 	ext_tlist_fini(extlist);
 }
 
-static void pdclust_sublayout_verify(struct m0_layout *sublayout,
-				     uint64_t sublayout_id)
+static void pdclust_sublayout_verify(struct m0_layout *sl,
+				     uint64_t sl_id)
 {
 	struct m0_uint128 seed;
 	uint32_t          enum_id;
@@ -215,12 +209,11 @@ static void pdclust_sublayout_verify(struct m0_layout *sublayout,
 	bool              inline_test;
 
 	m0_uint128_init(&seed, "sublayouts_build");
-	enum_id = sublayout_id % 2 ? LIST_ENUM_ID : LINEAR_ENUM_ID;
-	inline_test = sublayout_id % 5 ? LESS_THAN_INLINE : MORE_THAN_INLINE;
+	enum_id = sl_id % 2 ? LIST_ENUM_ID : LINEAR_ENUM_ID;
+	inline_test = sl_id % 5 ? LESS_THAN_INLINE : MORE_THAN_INLINE;
 	NKP_assign(enum_id, inline_test, 9, 109, 1200, &N, &K, &P);
-	pdclust_layout_verify(sublayout, sublayout_id,
-			      enum_id, N, K, P, &seed, 10, 20,
-			      !USER_COUNT_INCREMENTED);
+	pdclust_layout_verify(sl, sl_id, enum_id, N, K, P, &seed,
+			      10, 20, !USER_COUNT_INCREMENTED);
 
 }
 
@@ -229,12 +222,11 @@ static void composite_layout_verify(struct m0_layout *l,
 				    uint32_t layers_nr,
 				    bool is_extlist_associated,
 				    uint32_t extents_nr,
-				    bool is_contiguous_extents,
 				    bool is_sec_from_top_deleted,
 				    bool is_user_count_incremented)
 {
 	struct m0_composite_layout    *cl;
-	uint64_t                       sublayout_id;
+	uint64_t                       sl_id;
 	struct m0_composite_layer     *layer;
 	m0_bindex_t                    delta;
 	struct m0_composite_layer_ext *lr_ext;
@@ -261,19 +253,18 @@ static void composite_layout_verify(struct m0_layout *l,
 		if (layer->clr_idx < layers_nr - 1 ||
 		    (layer->clr_idx == layers_nr - 1 &&
 		     !is_sec_from_top_deleted))
-			sublayout_id = composite_lid * 100 + i;
+			sl_id = composite_lid * 100 + i;
 		else
 			/* Second-from-top has become the top-most layer now. */
-			sublayout_id = composite_lid * 100 + i + 1;
+			sl_id = composite_lid * 100 + i + 1;
 		if (((layer->clr_idx < layers_nr - 1 ||
 		      !is_sec_from_top_deleted) && layer->clr_idx % 2 == 0) ||
 		     (layer->clr_idx == layers_nr - 1 &&
 		      is_sec_from_top_deleted && layer->clr_idx % 2 != 0))
-			pdclust_sublayout_verify(layer->clr_sl, sublayout_id);
+			pdclust_sublayout_verify(layer->clr_sl, sl_id);
 		else
-			composite_layout_verify(layer->clr_sl, sublayout_id, 1,
+			composite_layout_verify(layer->clr_sl, sl_id, 1,
 						!EXTLIST_ASSOCIATED, 1,
-						CONTIGUOUS_EXTENTS,
 						!SEC_FROM_TOP_DELETED,
 						!USER_COUNT_INCREMENTED);
 		M0_UT_ASSERT(layer->clr_extents_nr == extents_nr);
@@ -289,7 +280,7 @@ static void composite_layout_verify(struct m0_layout *l,
 					     lr_ext->cle_ext.e_start + delta ||
 					     lr_ext->cle_ext.e_end ==
 					     END_OFFSET);
-				if (is_contiguous_extents || j % 2 == 0)
+				if (j % 2 == 0)
 					M0_UT_ASSERT(lr_ext->cle_state ==
 						     M0_CLRES_VALID);
 				else
@@ -400,7 +391,6 @@ static void composite_dump(const struct m0_composite_layout *cl)
 static int extlist_associate(struct m0_composite_layout *cl,
 			     uint32_t layer_id,
 			     uint32_t extents_nr,
-			     bool is_contiguous_extents,
 			     bool failure_test)
 {
 	struct m0_layout              *l_from_cl;
@@ -409,12 +399,8 @@ static int extlist_associate(struct m0_composite_layout *cl,
 	int                            rc;
 
 	/* Build an extent list and associate it with the sublayout. */
-	extentlist_build(&extents, extents_nr, is_contiguous_extents);
+	extlist_build(&extents, extents_nr);
 	m0_tl_for(ext, &extents, lr_ext) {
-#if 0 //todo rm
-		rc = m0_composite_layer_ext_add(cl, layer_id, &lr_ext->cle_ext,
-						lr_ext->cle_state);
-#endif
 		rc = m0_composite_layer_update(cl, layer_id, &lr_ext->cle_ext,
 					       lr_ext->cle_state);
 		M0_UT_ASSERT(rc == 0);
@@ -424,9 +410,8 @@ static int extlist_associate(struct m0_composite_layout *cl,
 	l_from_cl = m0_cl_to_layout(cl);
 	composite_layout_verify(l_from_cl, l_from_cl->l_id, cl->cl_layers_nr,
 				EXTLIST_ASSOCIATED, extents_nr,
-				is_contiguous_extents, !SEC_FROM_TOP_DELETED,
-				!USER_COUNT_INCREMENTED);
-	extentlist_free(&extents);
+				!SEC_FROM_TOP_DELETED, !USER_COUNT_INCREMENTED);
+	extlist_free(&extents);
 	return rc;
 }
 
@@ -436,21 +421,21 @@ static int composite_layout_build(uint64_t lid,
 				  bool failure_test,
 				  struct m0_composite_layout **cl)
 {
-	struct m0_layout *sublayout;
-	uint64_t          sublayout_id;
+	struct m0_layout *sl;
+	uint64_t          sl_id;
 	struct m0_layout *l_from_cl;
 	int               rc;
 
 	/* Pre-create the sublayout to be used as the original layout. */
-	sublayout_id = lid * 100;
-	rc = sublayout_build(sublayout_id, domain, &sublayout);
+	sl_id = lid * 100;
+	rc = sublayout_build(sl_id, domain, &sl);
 	M0_UT_ASSERT(rc == 0);
 
 	/* Build a composite layout. */
-	rc = m0_composite_build(domain, lid, sublayout, cl);
+	rc = m0_composite_build(domain, lid, sl, cl);
 	if (failure_test) {
 		M0_UT_ASSERT(rc == -ENOMEM);
-		sublayout_delete(domain, sublayout_id);
+		sublayout_delete(domain, sl_id);
 	} else {
 		M0_UT_ASSERT(rc == 0);
 
@@ -460,8 +445,7 @@ static int composite_layout_build(uint64_t lid,
 
 		/* Verify the composite layout object contents. */
 		composite_layout_verify(l_from_cl, lid, 1, !EXTLIST_ASSOCIATED,
-					1, CONTIGUOUS_EXTENTS,
-					!SEC_FROM_TOP_DELETED,
+					1, !SEC_FROM_TOP_DELETED,
 					!USER_COUNT_INCREMENTED);
 	}
 	return rc;
@@ -476,13 +460,12 @@ static int composite_layout_build(uint64_t lid,
 static int layers_add(struct m0_composite_layout *cl,
 		      uint32_t layers_nr,
 		      uint32_t extents_nr,
-		      bool is_contiguous_extents,
 		      bool layer_add_failure_test)
 {
-	uint64_t                          sublayout_id;
-	struct m0_layout                 *sublayout;
-	uint32_t                          i;
-	int                               rc;
+	uint64_t          sl_id;
+	struct m0_layout *sl;
+	uint32_t          i;
+	int               rc;
 
 	M0_UT_ASSERT(cl->cl_layers_nr >= 1);
 	if (layers_nr == 1)
@@ -492,14 +475,14 @@ static int layers_add(struct m0_composite_layout *cl,
 	sublayouts_precreate(cl->cl_base.l_id, cl->cl_base.l_dom, layers_nr);
 
 	for (i = 1; i < layers_nr; ++i) {
-		sublayout_id = cl->cl_base.l_id * 100 + i;
-		sublayout = m0_layout_find(cl->cl_base.l_dom, sublayout_id);
-		M0_UT_ASSERT(sublayout != NULL);
+		sl_id = cl->cl_base.l_id * 100 + i;
+		sl = m0_layout_find(cl->cl_base.l_dom, sl_id);
+		M0_UT_ASSERT(sl != NULL);
 		/* Release the reference acquired by m0_layout_find(). */
-		m0_layout_put(sublayout);
+		m0_layout_put(sl);
 
 		M0_UT_ASSERT(cl->cl_layers_nr == i);
-		rc = m0_composite_layer_add(cl, sublayout);
+		rc = m0_composite_layer_add(cl, sl);
 		if (layer_add_failure_test) {
 			M0_UT_ASSERT(rc == -ENOMEM || rc == -EINVAL);
 			M0_UT_ASSERT(cl->cl_layers_nr == i);
@@ -511,13 +494,12 @@ static int layers_add(struct m0_composite_layout *cl,
 
 		/* Associate an extent list to the layer added above. */
 		rc = extlist_associate(cl, cl->cl_layers_nr - 1, extents_nr,
-				       is_contiguous_extents, !FAILURE_TEST);
+				       !FAILURE_TEST);
 		M0_UT_ASSERT(rc == 0);
 
 		/* Verify the composite layout object contents. */
 		composite_layout_verify(&cl->cl_base, cl->cl_base.l_id, i + 1,
 					EXTLIST_ASSOCIATED, extents_nr,
-					is_contiguous_extents,
 					!SEC_FROM_TOP_DELETED,
 					!USER_COUNT_INCREMENTED);
 	}
@@ -534,7 +516,6 @@ static int composite_build_and_layers_add(uint64_t lid,
 					  struct m0_layout_domain *domain,
 					  uint32_t layers_nr,
 					  uint32_t extents_nr,
-					  bool is_contiguous_extents,
 					  bool failure_test,
 					  bool layer_add_failure_test,
 					  struct m0_composite_layout **cl)
@@ -551,12 +532,11 @@ static int composite_build_and_layers_add(uint64_t lid,
 		l = &(*cl)->cl_base;
 
 		/* Associate an extent list to the zeroth layer. */
-		rc = extlist_associate(*cl, 0, extents_nr,
-				       is_contiguous_extents, failure_test);
+		rc = extlist_associate(*cl, 0, extents_nr, failure_test);
 		M0_UT_ASSERT(rc == 0);
 
 		rc = layers_add(*cl, layers_nr, extents_nr,
-				is_contiguous_extents, layer_add_failure_test);
+				layer_add_failure_test);
 		if (layer_add_failure_test)
 			M0_UT_ASSERT(rc == -ENOMEM);
 		else {
@@ -564,7 +544,6 @@ static int composite_build_and_layers_add(uint64_t lid,
 			composite_layout_verify(l, l->l_id, (*cl)->cl_layers_nr,
 						EXTLIST_ASSOCIATED,
 						extents_nr,
-						is_contiguous_extents,
 						!SEC_FROM_TOP_DELETED,
 						!USER_COUNT_INCREMENTED);
 		}
@@ -584,7 +563,6 @@ static int composite_build_and_layers_add(uint64_t lid,
 int test_build_composite(uint64_t lid,
 			 struct m0_layout_domain *domain,
 			 uint32_t extents_nr,
-			 bool is_contiguous_extents,
 			 bool failure_test)
 {
 	struct m0_composite_layout *cl;
@@ -607,14 +585,12 @@ int test_build_composite(uint64_t lid,
 		m0_layout_put(&cl->cl_base);
 
 		/* Verify the layout object built earlier here. */
-		composite_layout_verify(l, lid, 1, !EXTLIST_ASSOCIATED,
-					1, is_contiguous_extents,
+		composite_layout_verify(l, lid, 1, !EXTLIST_ASSOCIATED, 1,
 					!SEC_FROM_TOP_DELETED,
 					!USER_COUNT_INCREMENTED);
 
 		/* Associate an extent list to the zeroth layer. */
-		rc = extlist_associate(cl, 0, extents_nr,
-				       is_contiguous_extents, failure_test);
+		rc = extlist_associate(cl, 0, extents_nr, failure_test);
 		M0_UT_ASSERT(rc == 0);
 
 		/*
@@ -622,8 +598,7 @@ int test_build_composite(uint64_t lid,
 		 * the zeroth layer.
 		 */
 		composite_layout_verify(l, lid, 1, EXTLIST_ASSOCIATED,
-					extents_nr, is_contiguous_extents,
-					!SEC_FROM_TOP_DELETED,
+					extents_nr, !SEC_FROM_TOP_DELETED,
 					!USER_COUNT_INCREMENTED);
 
 		/* Delete the composite layout object. */
@@ -636,118 +611,22 @@ int test_build_composite(uint64_t lid,
 	return rc;
 }
 
-#if 0
 /** Builds a buffer containing serialised representation of a layout object. */
 static void composite_layout_buf_build(uint64_t composite_lid,
 				       struct m0_layout_domain *domain,
 				       uint32_t layers_nr,
 				       uint32_t extents_nr,
-				       bool is_contiguous_extents,
 				       struct m0_bufvec_cursor *dcur)
 {
-	m0_bcount_t                     nbytes;
-	uint64_t                        sublayout_id;
-	struct m0_layout               *sublayout;
-	struct m0_layout_composite_rec  cl_rec;
-	struct layer_header             header;
-	struct m0_layer_ext_onwire      buf_ext; //todo rename to ext
-	m0_bindex_t                     delta;
-	m0_bindex_t                     start;
-	uint32_t                        i;
-	uint32_t                        j;
-	int                             rc;
-
-	M0_UT_ASSERT(dcur != NULL);
-	M0_UT_ASSERT(layers_nr > 0);
-
-	/* Build part of the buffer representing generic part of the layout. */
-	generic_buf_build(composite_lid, m0_composite_layout_type.lt_id, dcur);
-
-	/*
-	 * Build part of the buffer representing composite type specific part
-	 * of the layout.
-	 */
-	M0_UT_ASSERT(m0_bufvec_cursor_step(dcur) >= sizeof cl_rec);
-	cl_rec.cr_layers_nr = layers_nr;
-	cl_rec.cr_pad = 0;
-	nbytes = m0_bufvec_cursor_copyto(dcur, &cl_rec, sizeof cl_rec);
-	M0_UT_ASSERT(nbytes == sizeof cl_rec);
-
-	/* Pre-create the sublayout to be used for the zeroth layer. */
-	rc = sublayout_build(composite_lid * 100, domain, &sublayout);
-	M0_UT_ASSERT(rc == 0);
-	/* Pre-create the sublayouts to be used for layer 1 and above. */
-	sublayouts_precreate(composite_lid, domain, layers_nr);
-
-	/* Write the sublayout ids in the buffer. */
-	M0_UT_ASSERT(m0_bufvec_cursor_step(dcur) >=
-		     layers_nr * sizeof sublayout_id);
-	for (i = 0; i < layers_nr; ++i) {
-		sublayout_id = composite_lid * 100 + i;
-		nbytes = m0_bufvec_cursor_copyto(dcur, &sublayout_id,
-						 sizeof sublayout_id);
-	}
-
-	/* Write the layers to the buffer. */
-	M0_UT_ASSERT(m0_bufvec_cursor_step(dcur) >=
-		     layers_nr * sizeof header);
-	for (i = 0; i < layers_nr; ++i) {
-		sublayout_id = composite_lid * 100 + i;
-		sublayout = m0_layout_find(domain, sublayout_id);
-		M0_UT_ASSERT(sublayout != NULL);
-		/* Release the reference acquired by m0_layout_find(). */
-		m0_layout_put(sublayout);
-
-		header.clh_idx = i;
-		header.clh_extents_nr = extents_nr;
-		nbytes = m0_bufvec_cursor_copyto(dcur, &header,
-						 sizeof header);
-		M0_UT_ASSERT(nbytes == sizeof header);
-
-		if (extents_nr == 0) /* Possible only in error conditions. */
-			continue;
-
-		start = 0;
-		delta = (END_OFFSET - START_OFFSET) / extents_nr;
-		for (j = 0; j < header.clh_extents_nr; ++j) {
-			buf_ext.leo_end =
-				(j == header.clh_extents_nr - 1) ?
-				END_OFFSET : start + delta;
-			buf_ext.leo_state =
-				(is_contiguous_extents || j % 2 == 0) ?
-				M0_CLRES_VALID : M0_CLRES_HOLE;
-
-			if (M0_FI_ENABLED("invalid_state_err"))
-				buf_ext.leo_state = 111;
-
-			nbytes = m0_bufvec_cursor_copyto(dcur, &buf_ext,
-							 sizeof buf_ext);
-			M0_UT_ASSERT(nbytes == sizeof buf_ext);
-			start = buf_ext.leo_end;
-		}
-	}
-}
-#endif
-
-/** Builds a buffer containing serialised representation of a layout object. */
-static void composite_layout_buf_build(uint64_t composite_lid,
-				       struct m0_layout_domain *domain,
-				       uint32_t layers_nr,
-				       uint32_t extents_nr,
-				       bool is_contiguous_extents,
-				       struct m0_bufvec_cursor *dcur)
-{
-	m0_bcount_t                     nbytes;
-	uint64_t                        sublayout_id;
-	struct m0_layout               *sublayout;
-	//struct m0_layout_composite_rec  cl_rec;
-	//struct layer_header             header;
-	struct m0_layer_ext_onwire      buf_ext; //todo rename to ext
-	m0_bindex_t                     delta;
-	m0_bindex_t                     start;
-	uint32_t                        i;
-	uint32_t                        j;
-	int                             rc;
+	m0_bcount_t                 nbytes;
+	uint64_t                    sl_id;
+	struct m0_layout           *sl;
+	struct m0_layer_ext_onwire  ext;
+	m0_bindex_t                 delta;
+	m0_bindex_t                 start;
+	uint32_t                    i;
+	uint32_t                    j;
+	int                         rc;
 
 	M0_UT_ASSERT(dcur != NULL);
 	M0_UT_ASSERT(layers_nr > 0);
@@ -759,60 +638,29 @@ static void composite_layout_buf_build(uint64_t composite_lid,
 	 * Build part of the buffer representing composite type specific part
 	 * of the layout.
 	 */
-#if 0
-	M0_UT_ASSERT(m0_bufvec_cursor_step(dcur) >= sizeof cl_rec);
-	cl_rec.cr_layers_nr = layers_nr;
-	cl_rec.cr_pad = 0;
-	nbytes = m0_bufvec_cursor_copyto(dcur, &cl_rec, sizeof cl_rec);
-	M0_UT_ASSERT(nbytes == sizeof cl_rec);
-#endif
 	nbytes = m0_bufvec_cursor_copyto(dcur, &layers_nr, sizeof layers_nr);
 	M0_UT_ASSERT(nbytes == sizeof layers_nr);
 
 	/* Pre-create the sublayout to be used for the zeroth layer. */
-	rc = sublayout_build(composite_lid * 100, domain, &sublayout);
+	rc = sublayout_build(composite_lid * 100, domain, &sl);
 	M0_UT_ASSERT(rc == 0);
 	/* Pre-create the sublayouts to be used for layer 1 and above. */
 	sublayouts_precreate(composite_lid, domain, layers_nr);
 
-#if 0
-	/* Write the sublayout ids in the buffer. */
-	M0_UT_ASSERT(m0_bufvec_cursor_step(dcur) >=
-		     layers_nr * sizeof sublayout_id);
-	for (i = 0; i < layers_nr; ++i) {
-		sublayout_id = composite_lid * 100 + i;
-		nbytes = m0_bufvec_cursor_copyto(dcur, &sublayout_id,
-						 sizeof sublayout_id);
-	}
-#endif
-
 	/* Write the layers to the buffer. */
-#if 0
 	M0_UT_ASSERT(m0_bufvec_cursor_step(dcur) >=
-		     layers_nr * sizeof header);
-#endif
-	M0_UT_ASSERT(m0_bufvec_cursor_step(dcur) >=
-		     layers_nr * (sizeof i + sizeof sublayout_id));
+		     layers_nr * (sizeof i + sizeof sl_id + sizeof extents_nr));
 	for (i = 0; i < layers_nr; ++i) {
-		sublayout_id = composite_lid * 100 + i;
-		sublayout = m0_layout_find(domain, sublayout_id);
-		M0_UT_ASSERT(sublayout != NULL);
+		sl_id = composite_lid * 100 + i;
+		sl = m0_layout_find(domain, sl_id);
+		M0_UT_ASSERT(sl != NULL);
 		/* Release the reference acquired by m0_layout_find(). */
-		m0_layout_put(sublayout);
-
-#if 0
-		header.clh_idx = i;
-		header.clh_extents_nr = extents_nr;
-		nbytes = m0_bufvec_cursor_copyto(dcur, &header,
-						 sizeof header);
-		M0_UT_ASSERT(nbytes == sizeof header);
-#endif
+		m0_layout_put(sl);
 
 		nbytes = m0_bufvec_cursor_copyto(dcur, &i, sizeof i);
 		M0_UT_ASSERT(nbytes == sizeof i);
-		nbytes = m0_bufvec_cursor_copyto(dcur, &sublayout_id,
-						 sizeof sublayout_id);
-		M0_UT_ASSERT(nbytes == sizeof sublayout_id);
+		nbytes = m0_bufvec_cursor_copyto(dcur, &sl_id, sizeof sl_id);
+		M0_UT_ASSERT(nbytes == sizeof sl_id);
 
 		if (extents_nr == 0) /* Possible only in error conditions. */
 			continue;
@@ -824,19 +672,17 @@ static void composite_layout_buf_build(uint64_t composite_lid,
 		start = 0;
 		delta = (END_OFFSET - START_OFFSET) / extents_nr;
 		for (j = 0; j < extents_nr; ++j) {
-			buf_ext.leo_end =
-				(j == extents_nr - 1) ?
-				END_OFFSET : start + delta;
-			buf_ext.leo_state =
-				(is_contiguous_extents || j % 2 == 0) ?
-				M0_CLRES_VALID : M0_CLRES_HOLE;
+			ext.leo_end = j == extents_nr - 1 ?
+				      END_OFFSET : start + delta;
+			ext.leo_state = j % 2 == 0 ?
+					M0_CLRES_VALID : M0_CLRES_HOLE;
 
 			if (M0_FI_ENABLED("invalid_state_err"))
-				buf_ext.leo_state = 111;
-			nbytes = m0_bufvec_cursor_copyto(dcur, &buf_ext,
-							 sizeof buf_ext);
-			M0_UT_ASSERT(nbytes == sizeof buf_ext);
-			start = buf_ext.leo_end;
+				ext.leo_state = 111;
+			nbytes = m0_bufvec_cursor_copyto(dcur, &ext,
+							 sizeof ext);
+			M0_UT_ASSERT(nbytes == sizeof ext);
+			start = ext.leo_end;
 		}
 	}
 }
@@ -846,7 +692,6 @@ int test_decode_composite(uint64_t lid,
 			  struct m0_layout_domain *domain,
 			  uint32_t layers_nr,
 			  uint32_t extents_nr,
-			  bool is_contiguous_extents,
 			  bool failure_test)
 {
 	void                    *area;
@@ -861,8 +706,7 @@ int test_decode_composite(uint64_t lid,
 	allocate_area(domain, ADDITIONAL_BYTES_DEFAULT, &num_bytes, &area);
 	bv = (struct m0_bufvec) M0_BUFVEC_INIT_BUF(&area, &num_bytes);
 	m0_bufvec_cursor_init(&cur, &bv);
-	composite_layout_buf_build(lid, domain, layers_nr, extents_nr,
-				   is_contiguous_extents, &cur);
+	composite_layout_buf_build(lid, domain, layers_nr, extents_nr, &cur);
 
 	/* Rewind the cursor. */
 	m0_bufvec_cursor_init(&cur, &bv);
@@ -882,8 +726,7 @@ int test_decode_composite(uint64_t lid,
 
 		/* Verify the layout object built by m0_layout_decode(). */
 		composite_layout_verify(l, lid, layers_nr, EXTLIST_ASSOCIATED,
-					extents_nr, is_contiguous_extents,
-					!SEC_FROM_TOP_DELETED,
+					extents_nr, !SEC_FROM_TOP_DELETED,
 					USER_COUNT_INCREMENTED);
 	}
 
@@ -913,33 +756,19 @@ static void composite_layout_buf_verify(uint64_t lid,
 					struct m0_layout_domain *domain,
 					uint32_t layers_nr,
 					uint32_t extents_nr,
-					bool is_contiguous_extents,
 					bool is_user_count_incremented,
 					struct m0_bufvec_cursor *cur)
 {
-	uint32_t                        lt_id; //todo indent
-	uint32_t                       *layers_nr1;
-	//struct m0_layout_composite_rec *cl_rec;
-	//uint64_t                       *sublayout_id;
-	//struct layer_header            *header;
-	struct m0_layer_ext_onwire     *ext;
-	m0_bindex_t                     start;
-	m0_bindex_t                     delta;
-	uint32_t                        i;
-	uint32_t                        j;
-#if 0
-	/* todo reorganise this, with proper name, location etc */
-	struct lr_header { //todo use this struct in buf_build
-		uint32_t h_idx;
-		uint64_t h_sublayout_id;
-		uint32_t h_extents_nr;
-	};
-	struct lr_header               *header;
-#endif
-
-	uint32_t *layer_idx;
-	uint64_t *sublayout_id;
-	uint32_t *extents_nr1; //todo indent
+	uint32_t                    lt_id;
+	uint32_t                   *lr_nr1;
+	struct m0_layer_ext_onwire *ext;
+	m0_bindex_t                 start;
+	m0_bindex_t                 delta;
+	uint32_t                    i;
+	uint32_t                    j;
+	uint32_t                   *layer_idx;
+	uint64_t                   *sl_id;
+	uint32_t                   *ext_nr1;
 
 	M0_UT_ASSERT(cur != NULL);
 
@@ -948,91 +777,39 @@ static void composite_layout_buf_verify(uint64_t lid,
 	M0_UT_ASSERT(lt_id == m0_composite_layout_type.lt_id);
 
 	/* Verify COMPOSITE layout type specific part of the layout buffer. */
-#if 0
-	M0_UT_ASSERT(m0_bufvec_cursor_step(cur) >= sizeof *cl_rec);
-	cl_rec = m0_bufvec_cursor_addr(cur);
-	M0_UT_ASSERT(cl_rec != NULL);
-	m0_bufvec_cursor_move(cur, sizeof *cl_rec);
-	M0_UT_ASSERT(cl_rec->cr_layers_nr == layers_nr);
-#endif
-
-	layers_nr1 = m0_bufvec_cursor_addr(cur);
-	m0_bufvec_cursor_move(cur, sizeof *layers_nr1);
-	M0_UT_ASSERT(*layers_nr1 == layers_nr);
-	//todo M0_UT_ASSERT(m0_bufvec_cursor_step(cur) >= layers_nr * sizeof *header);
-#if 0
-	M0_UT_ASSERT(m0_bufvec_cursor_step(cur) >=
-		     cl_rec->cr_layers_nr * sizeof *header);
-#endif
-
+	lr_nr1 = m0_bufvec_cursor_addr(cur);
+	m0_bufvec_cursor_move(cur, sizeof *lr_nr1);
+	M0_UT_ASSERT(*lr_nr1 == layers_nr);
+	M0_UT_ASSERT(m0_bufvec_cursor_step(cur) >= layers_nr *
+		     (sizeof *layer_idx + sizeof *sl_id + sizeof *ext_nr1 ));
 	for (i = 0; i < layers_nr; ++i) {
-#if 0
-		sublayout_id = m0_bufvec_cursor_addr(cur);
-		m0_bufvec_cursor_move(cur, sizeof *sublayout_id);
-		M0_UT_ASSERT(*sublayout_id == lid * 100 + i);
-#endif
 		layer_idx = m0_bufvec_cursor_addr(cur);
 		m0_bufvec_cursor_move(cur, sizeof *layer_idx);
 		M0_UT_ASSERT(*layer_idx == i);
 
-		sublayout_id = m0_bufvec_cursor_addr(cur);
-		m0_bufvec_cursor_move(cur, sizeof *sublayout_id);
-		M0_UT_ASSERT(*sublayout_id == lid * 100 + i);
+		sl_id = m0_bufvec_cursor_addr(cur);
+		m0_bufvec_cursor_move(cur, sizeof *sl_id);
+		M0_UT_ASSERT(*sl_id == lid * 100 + i);
 
-		extents_nr1 = m0_bufvec_cursor_addr(cur);
-		m0_bufvec_cursor_move(cur, sizeof *extents_nr1);
-		M0_UT_ASSERT(*extents_nr1 == extents_nr);
-#if 0
-		M0_UT_ASSERT(header->h_sublayout_id == lid * 100 + i);
-		M0_UT_ASSERT(header->h_extents_nr == extents_nr);
-		M0_UT_ASSERT(m0_bufvec_cursor_step(cur) >=
-			     header->h_extents_nr * sizeof ext);
-#endif
+		ext_nr1 = m0_bufvec_cursor_addr(cur);
+		m0_bufvec_cursor_move(cur, sizeof *ext_nr1);
+		M0_UT_ASSERT(*ext_nr1 == extents_nr);
 		delta = (END_OFFSET - START_OFFSET) / extents_nr;
 		start = 0;
-		//todo for (j = 0; j < header->h_extents_nr; ++j) {
 		for (j = 0; j < extents_nr; ++j) {
 			ext = m0_bufvec_cursor_addr(cur);
 			m0_bufvec_cursor_move(cur, sizeof *ext);
-			//if (j == header->h_extents_nr - 1)
 			if (j == extents_nr - 1)
 				M0_UT_ASSERT(ext->leo_end == END_OFFSET);
 			else
 				M0_UT_ASSERT(ext->leo_end == start + delta);
-			if (is_contiguous_extents || j % 2 == 0)
+			if (j % 2 == 0)
 				M0_UT_ASSERT(ext->leo_state == M0_CLRES_VALID);
 			else
 				M0_UT_ASSERT(ext->leo_state == M0_CLRES_HOLE);
 			start = ext->leo_end;
 		}
-
 	}
-
-#if 0
-	for (i = 0; i < layers_nr; ++i) {
-		header = m0_bufvec_cursor_addr(cur);
-		m0_bufvec_cursor_move(cur, sizeof *header);
-		M0_UT_ASSERT(header->clh_idx == i);
-		M0_UT_ASSERT(header->clh_extents_nr == extents_nr);
-		M0_UT_ASSERT(m0_bufvec_cursor_step(cur) >=
-			     header->clh_extents_nr * sizeof ext);
-		delta = (END_OFFSET - START_OFFSET) / extents_nr;
-		start = 0;
-		for (j = 0; j < header->clh_extents_nr; ++j) {
-			ext = m0_bufvec_cursor_addr(cur);
-			m0_bufvec_cursor_move(cur, sizeof *ext);
-			if (j == header->clh_extents_nr - 1)
-				M0_UT_ASSERT(ext->leo_end == END_OFFSET);
-			else
-				M0_UT_ASSERT(ext->leo_end == start + delta);
-			if (is_contiguous_extents || j % 2 == 0)
-				M0_UT_ASSERT(ext->leo_state == M0_CLRES_VALID);
-			else
-				M0_UT_ASSERT(ext->leo_state == M0_CLRES_HOLE);
-			start = ext->leo_end;
-		}
-	}
-#endif
 }
 
 /** Tests the API m0_layout_encode() for COMPOSITE layout type. */
@@ -1040,7 +817,6 @@ int test_encode_composite(uint64_t lid,
 			  struct m0_layout_domain *domain,
 			  uint32_t layers_nr,
 			  uint32_t extents_nr,
-			  bool is_contiguous_extents,
 			  bool failure_test)
 {
 	struct m0_composite_layout *cl;
@@ -1052,7 +828,6 @@ int test_encode_composite(uint64_t lid,
 
 	/* Build a layout object. */
 	rc = composite_build_and_layers_add(lid, domain, layers_nr, extents_nr,
-					    is_contiguous_extents,
 					    !FAILURE_TEST,
 					    !LAYER_ADD_FAILURE_TEST, &cl);
 	M0_UT_ASSERT(rc == 0);
@@ -1080,7 +855,6 @@ int test_encode_composite(uint64_t lid,
 	/* Verify the layout buffer produced by m0_layout_encode(). */
 	if (!failure_test)
 		composite_layout_buf_verify(lid, domain, layers_nr, extents_nr,
-					    is_contiguous_extents,
 					    USER_COUNT_INCREMENTED, &cur);
 
 	/* Delete the composite layout object. */
@@ -1098,29 +872,18 @@ int test_encode_composite(uint64_t lid,
 static void composite_layout_buf_compare(struct m0_bufvec_cursor *cur1,
 					 struct m0_bufvec_cursor *cur2)
 {
-#if 0
-	struct m0_layout_composite_rec *cl_rec1;
-	struct m0_layout_composite_rec *cl_rec2;
-	struct layer_header            *header1;
-	struct layer_header            *header2;
-	struct m0_ext                  *ext1;
-	struct m0_ext                  *ext2;
-	uint64_t                       *state1;
-	uint64_t                       *state2;
-#endif
-
-	uint32_t *layers_nr1;
-	uint32_t *layers_nr2;
-	uint32_t *layer_idx1;
-	uint32_t *layer_idx2;
-	uint64_t *sublayout_id1;
-	uint64_t *sublayout_id2;
-	uint32_t *extents_nr1;
-	uint32_t *extents_nr2; //todo indent
-	struct m0_layer_ext_onwire           *ext1; //todo indent
-	struct m0_layer_ext_onwire           *ext2;
-	uint32_t                        i;
-	uint32_t                        j;
+	struct m0_layer_ext_onwire *ext1;
+	struct m0_layer_ext_onwire *ext2;
+	uint32_t                   *lr_nr1;
+	uint32_t                   *lr_nr2;
+	uint32_t                   *lr_idx1;
+	uint32_t                   *lr_idx2;
+	uint64_t                   *sl_id1;
+	uint64_t                   *sl_id2;
+	uint32_t                   *ext_nr1;
+	uint32_t                   *ext_nr2;
+	uint32_t                    i;
+	uint32_t                    j;
 
 	M0_UT_ASSERT(cur1 != NULL);
 	M0_UT_ASSERT(cur2 != NULL);
@@ -1129,70 +892,49 @@ static void composite_layout_buf_compare(struct m0_bufvec_cursor *cur1,
 	lbuf_compare(cur1, cur2);
 
 	/* Compare COMPOSITE layout type specific part of the layout buffers. */
-#if 0
-	M0_UT_ASSERT(m0_bufvec_cursor_step(cur1) >= sizeof *cl_rec1);
-	M0_UT_ASSERT(m0_bufvec_cursor_step(cur2) >= sizeof *cl_rec2);
-
-	cl_rec1 = m0_bufvec_cursor_addr(cur1);
-	cl_rec2 = m0_bufvec_cursor_addr(cur2);
-
-	m0_bufvec_cursor_move(cur1, sizeof *cl_rec1);
-	m0_bufvec_cursor_move(cur2, sizeof *cl_rec2);
-
-	M0_UT_ASSERT(cl_rec1->cr_layers_nr == cl_rec2->cr_layers_nr);
-
-	M0_UT_ASSERT(m0_bufvec_cursor_step(cur1) >=
-		     cl_rec1->cr_layers_nr * sizeof *header1);
-	M0_UT_ASSERT(m0_bufvec_cursor_step(cur2) >=
-		     cl_rec2->cr_layers_nr * sizeof *header2);
-#endif
-
-	layers_nr1 = m0_bufvec_cursor_addr(cur1);
-	layers_nr2 = m0_bufvec_cursor_addr(cur2);
-	m0_bufvec_cursor_move(cur1, sizeof *layers_nr1);
-	m0_bufvec_cursor_move(cur2, sizeof *layers_nr2);
-	M0_UT_ASSERT(*layers_nr1 == *layers_nr2);
-#if 0
-	M0_UT_ASSERT(m0_bufvec_cursor_step(cur1) >=
-		     cl_rec1->cr_layers_nr * sizeof *header1);
-	M0_UT_ASSERT(m0_bufvec_cursor_step(cur2) >=
-		     cl_rec2->cr_layers_nr * sizeof *header2);
-#endif
-
-	for (i = 0; i < *layers_nr1; ++i) {
-		layer_idx1 = m0_bufvec_cursor_addr(cur1);
-		layer_idx2 = m0_bufvec_cursor_addr(cur2);
-		m0_bufvec_cursor_move(cur1, sizeof *layer_idx1);
-		m0_bufvec_cursor_move(cur2, sizeof *layer_idx2);
-		M0_UT_ASSERT(*layer_idx1 == *layer_idx2);
-
-		sublayout_id1 = m0_bufvec_cursor_addr(cur1);
-		sublayout_id2 = m0_bufvec_cursor_addr(cur2);
-		m0_bufvec_cursor_move(cur1, sizeof *sublayout_id1);
-		m0_bufvec_cursor_move(cur2, sizeof *sublayout_id2);
-		M0_UT_ASSERT(*sublayout_id1 == *sublayout_id2);
-
-		extents_nr1 = m0_bufvec_cursor_addr(cur1);
-		extents_nr2 = m0_bufvec_cursor_addr(cur2);
-		m0_bufvec_cursor_move(cur1, sizeof *extents_nr1);
-		m0_bufvec_cursor_move(cur2, sizeof *extents_nr2);
-		M0_UT_ASSERT(*extents_nr1 == *extents_nr2);
-
-		for (j = 0; j < *extents_nr1; ++j) {
+	M0_UT_ASSERT(m0_bufvec_cursor_step(cur1) >= sizeof *lr_nr1);
+	M0_UT_ASSERT(m0_bufvec_cursor_step(cur2) >= sizeof *lr_nr2);
+	lr_nr1 = m0_bufvec_cursor_addr(cur1);
+	lr_nr2 = m0_bufvec_cursor_addr(cur2);
+	m0_bufvec_cursor_move(cur1, sizeof *lr_nr1);
+	m0_bufvec_cursor_move(cur2, sizeof *lr_nr2);
+	M0_UT_ASSERT(*lr_nr1 == *lr_nr2);
+
+	M0_UT_ASSERT(m0_bufvec_cursor_step(cur1) >= *lr_nr1 *
+		     (sizeof *lr_idx1 + sizeof *sl_id1 + sizeof *ext_nr1));
+	M0_UT_ASSERT(m0_bufvec_cursor_step(cur2) >= *lr_nr2 *
+		     (sizeof *lr_idx2 + sizeof *sl_id2 + sizeof *ext_nr2));
+
+	for (i = 0; i < *lr_nr1; ++i) {
+		lr_idx1 = m0_bufvec_cursor_addr(cur1);
+		lr_idx2 = m0_bufvec_cursor_addr(cur2);
+		m0_bufvec_cursor_move(cur1, sizeof *lr_idx1);
+		m0_bufvec_cursor_move(cur2, sizeof *lr_idx2);
+		M0_UT_ASSERT(*lr_idx1 == *lr_idx2);
+
+		sl_id1 = m0_bufvec_cursor_addr(cur1);
+		sl_id2 = m0_bufvec_cursor_addr(cur2);
+		m0_bufvec_cursor_move(cur1, sizeof *sl_id1);
+		m0_bufvec_cursor_move(cur2, sizeof *sl_id2);
+		M0_UT_ASSERT(*sl_id1 == *sl_id2);
+
+		ext_nr1 = m0_bufvec_cursor_addr(cur1);
+		ext_nr2 = m0_bufvec_cursor_addr(cur2);
+		m0_bufvec_cursor_move(cur1, sizeof *ext_nr1);
+		m0_bufvec_cursor_move(cur2, sizeof *ext_nr2);
+		M0_UT_ASSERT(*ext_nr1 == *ext_nr2);
+
+		M0_UT_ASSERT(m0_bufvec_cursor_step(cur1) >=
+			     *ext_nr1 * sizeof *ext1);
+		M0_UT_ASSERT(m0_bufvec_cursor_step(cur2) >=
+			     *ext_nr2 * sizeof *ext2);
+		for (j = 0; j < *ext_nr1; ++j) {
 			ext1 = m0_bufvec_cursor_addr(cur1);
 			ext2 = m0_bufvec_cursor_addr(cur2);
 			m0_bufvec_cursor_move(cur1, sizeof *ext1);
 			m0_bufvec_cursor_move(cur2, sizeof *ext2);
 			M0_UT_ASSERT(ext1->leo_end == ext2->leo_end);
 			M0_UT_ASSERT(ext1->leo_state == ext2->leo_state);
-
-#if 0
-			state1 = m0_bufvec_cursor_addr(cur1);
-			state2 = m0_bufvec_cursor_addr(cur2);
-			m0_bufvec_cursor_move(cur1, sizeof *state1);
-			m0_bufvec_cursor_move(cur2, sizeof *state2);
-			M0_UT_ASSERT(*state1 == *state2);
-#endif
 		}
 	}
 }
@@ -1204,8 +946,7 @@ static void composite_layout_buf_compare(struct m0_bufvec_cursor *cur1,
 int test_decode_encode_composite(uint64_t lid,
 				 struct m0_layout_domain *domain,
 				 uint32_t layers_nr,
-				 uint32_t extents_nr,
-				 bool is_contiguous_extents)
+				 uint32_t extents_nr)
 {
 	void                    *area1;
 	struct m0_bufvec         bv1;
@@ -1222,8 +963,7 @@ int test_decode_encode_composite(uint64_t lid,
 	allocate_area(domain, ADDITIONAL_BYTES_DEFAULT, &num_bytes, &area1);
 	bv1 = (struct m0_bufvec) M0_BUFVEC_INIT_BUF(&area1, &num_bytes);
 	m0_bufvec_cursor_init(&cur1, &bv1);
-	composite_layout_buf_build(lid, domain, layers_nr, extents_nr,
-				   is_contiguous_extents, &cur1);
+	composite_layout_buf_build(lid, domain, layers_nr, extents_nr, &cur1);
 
 	/* Rewind the cursor. */
 	m0_bufvec_cursor_init(&cur1, &bv1);
@@ -1406,8 +1146,7 @@ static void composite_layout_copy_delete(struct m0_layout *l)
 int test_encode_decode_composite(uint64_t lid,
 				 struct m0_layout_domain *domain,
 				 uint32_t layers_nr,
-				 uint32_t extents_nr,
-				 bool is_contiguous_extents)
+				 uint32_t extents_nr)
 {
 	struct m0_composite_layout *cl;
 	void                       *area;
@@ -1421,7 +1160,6 @@ int test_encode_decode_composite(uint64_t lid,
 
 	/* Build a layout object. */
 	rc = composite_build_and_layers_add(lid, domain, layers_nr, extents_nr,
-					    is_contiguous_extents,
 					    !FAILURE_TEST,
 					    !LAYER_ADD_FAILURE_TEST, &cl);
 	M0_UT_ASSERT(rc == 0);
@@ -1493,8 +1231,6 @@ int test_instance_composite(uint64_t lid, struct m0_layout_domain *domain,
 
 	layers_nr = 5;
 	rc = composite_build_and_layers_add(lid, domain, layers_nr, 8,
-					    //todo Jul 25 CONTIGUOUS_EXTENTS,
-					    !CONTIGUOUS_EXTENTS,
 					    !FAILURE_TEST,
 					    !LAYER_ADD_FAILURE_TEST, &cl);
 	M0_UT_ASSERT(rc == 0);
@@ -1546,10 +1282,8 @@ static void layer_extents_delete(struct m0_composite_layout *cl,
 		 * lr_ext is going to get deleted. Hence, make a copy.
 		 */
 		ext = lr_ext->cle_ext;
-		//todo rm rc = m0_composite_layer_ext_delete(cl, layer->clr_idx, &ext);
 		rc = m0_composite_layer_update(cl, layer->clr_idx,
-					       &lr_ext->cle_ext,
-					       M0_CLRES_HOLE);
+					       &lr_ext->cle_ext, M0_CLRES_HOLE);
 		M0_UT_ASSERT(rc == 0);
 	} m0_tl_endfor;
 }
@@ -1572,13 +1306,11 @@ int test_layer_ops_composite(uint64_t lid,
 	M0_UT_ASSERT(rc == 0);
 
 	/* Associate an extent list to the zeroth layer. */
-	rc = extlist_associate(cl, 0, extents_nr, !CONTIGUOUS_EXTENTS,
-			       !FAILURE_TEST);
+	rc = extlist_associate(cl, 0, extents_nr, !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
 	/* Now, add layers to the layout. */
-	rc = layers_add(cl, layers_nr, extents_nr, !CONTIGUOUS_EXTENTS,
-			layer_add_failure_test);
+	rc = layers_add(cl, layers_nr, extents_nr, layer_add_failure_test);
 
 	if (layer_add_failure_test) {
 		M0_UT_ASSERT(rc == -ENOMEM || rc == -EINVAL);
@@ -1591,8 +1323,8 @@ int test_layer_ops_composite(uint64_t lid,
 	/* Verify the layout. */
 	l = m0_cl_to_layout(cl);
 	composite_layout_verify(l, lid, layers_nr, EXTLIST_ASSOCIATED,
-				extents_nr, !CONTIGUOUS_EXTENTS,
-				!SEC_FROM_TOP_DELETED, !USER_COUNT_INCREMENTED);
+				extents_nr, !SEC_FROM_TOP_DELETED,
+				!USER_COUNT_INCREMENTED);
 
 	/* Delete all the extents associated with the top-most layer. */
 	layer = layer_find(cl, cl->cl_layers_nr - 1);
@@ -1604,8 +1336,8 @@ int test_layer_ops_composite(uint64_t lid,
 
 	/* Verify the layout. */
 	composite_layout_verify(l, lid, layers_nr - 1, EXTLIST_ASSOCIATED,
-				extents_nr, !CONTIGUOUS_EXTENTS,
-				!SEC_FROM_TOP_DELETED, !USER_COUNT_INCREMENTED);
+				extents_nr, !SEC_FROM_TOP_DELETED,
+				!USER_COUNT_INCREMENTED);
 	if (layers_nr < 3) /* Skip the second-from-top layer deletion */
 		goto exit;
 
@@ -1619,8 +1351,8 @@ int test_layer_ops_composite(uint64_t lid,
 
 	/* Verify the layout. */
 	composite_layout_verify(l, lid, layers_nr - 2, EXTLIST_ASSOCIATED,
-				extents_nr, !CONTIGUOUS_EXTENTS,
-				SEC_FROM_TOP_DELETED, !USER_COUNT_INCREMENTED);
+				extents_nr, SEC_FROM_TOP_DELETED,
+				!USER_COUNT_INCREMENTED);
 exit:
 	/* Delete the composite layout object. */
 	m0_layout_put(&cl->cl_base);
@@ -1633,7 +1365,6 @@ exit:
 
 /** Depending upon 'the kind of the extent', define the extent. */
 static void extent_to_be_operated(const struct m0_composite_layout *cl,
-				  bool is_contiguous_extents,
 				  uint32_t layer_idx,
 				  uint64_t extent_idx,
 				  enum kind_of_extent extent_kind,
@@ -1655,8 +1386,6 @@ static void extent_to_be_operated(const struct m0_composite_layout *cl,
 	layer = layer_find(cl, layer_idx);
 	M0_UT_ASSERT(ergo(extent_kind == EXACT_EXISTING,
 			  extent_idx < layer->clr_extents_nr));
-	M0_UT_ASSERT(ergo(extent_kind == NON_EXISTING,
-			  is_contiguous_extents == false));
 	M0_UT_ASSERT(ergo(extent_kind != EXACT_EXISTING,
 			  layer->clr_extents_nr >= 3 &&
 			  layer->clr_extents_nr >= extent_idx + 1));
@@ -1677,14 +1406,9 @@ static void extent_to_be_operated(const struct m0_composite_layout *cl,
 	M0_UT_ASSERT(ext_idxth.e_end == ext_idx_plus_oneth.e_start);
 
 	if (extent_kind == EXACT_EXISTING) {
-		if (is_contiguous_extents)
-			*ext = ext_idxth;
-		else {
-			*ext = ((i - 1) % 2 == 0) ?
-				ext_idxth : ext_idx_plus_oneth;
-		}
+		*ext = ((i - 1) % 2 == 0) ?
+			ext_idxth : ext_idx_plus_oneth;
 	} else if (extent_kind == NON_EXISTING) {
-		M0_UT_ASSERT(!is_contiguous_extents);
 		*ext = ((i - 1) % 2 == 0) ? ext_idx_plus_oneth : ext_idxth;
 	} else if (extent_kind == OVERLAPPING_LEFT) {
 		ext->e_start = ext_idxth.e_start;
@@ -1693,33 +1417,23 @@ static void extent_to_be_operated(const struct m0_composite_layout *cl,
 		ext->e_start = ext_idxth.e_end - 1;
 		ext->e_end = ext_idx_plus_oneth.e_end;
 	} else if (extent_kind == OVERLAPPING_COMPLETE) {
-		if (is_contiguous_extents) {
+		if ((i - 1) % 2 == 0) {
 			ext->e_start = ext_idxth.e_start - 1;
 			ext->e_end = ext_idxth.e_end + 1;
 		} else {
-			if ((i - 1) % 2 == 0) {
-				ext->e_start = ext_idxth.e_start - 1;
-				ext->e_end = ext_idxth.e_end + 1;
-			} else {
-				ext->e_start = ext_idx_plus_oneth.e_start - 1;
-				ext->e_end = ext_idx_plus_oneth.e_end + 1;
-			}
+			ext->e_start = ext_idx_plus_oneth.e_start - 1;
+			ext->e_end = ext_idx_plus_oneth.e_end + 1;
 		}
 	} else if (extent_kind == OVERLAPPING_MULTIPLE) {
 		ext->e_start = ext_idxth.e_start - 1;
 		ext->e_end = ext_idx_plus_oneth.e_end + 1;
 	} else if (extent_kind == CONTAINED_WITHIN) {
-		if (is_contiguous_extents) {
+		if ((i - 1) % 2 == 0) {
 			ext->e_start = ext_idxth.e_start + 2;
 			ext->e_end = ext_idxth.e_end - 2;
 		} else {
-			if ((i - 1) % 2 == 0) {
-				ext->e_start = ext_idxth.e_start + 2;
-				ext->e_end = ext_idxth.e_end - 2;
-			} else {
-				ext->e_start = ext_idx_plus_oneth.e_start + 2;
-				ext->e_end = ext_idx_plus_oneth.e_end - 2;
-			}
+			ext->e_start = ext_idx_plus_oneth.e_start + 2;
+			ext->e_end = ext_idx_plus_oneth.e_end - 2;
 		}
 	} else if (extent_kind == WHOLE_OFFSET_SPACE) {
 		ext->e_start = 0;
@@ -1742,7 +1456,6 @@ static int ext_op_pre(enum extent_operation eop,
 		      struct m0_layout_domain *domain,
 		      uint32_t layers_nr,
 		      uint32_t extents_nr,
-		      bool is_contiguous_extents,
 		      enum kind_of_extent extent_kind,
 		      uint64_t state,
 		      bool failure_test,
@@ -1762,14 +1475,12 @@ static int ext_op_pre(enum extent_operation eop,
 
 	/* Build a layout and add layers to it. */
 	rc = composite_build_and_layers_add(lid, domain, layers_nr, extents_nr,
-					    is_contiguous_extents,
 					    !FAILURE_TEST,
 					    !LAYER_ADD_FAILURE_TEST, cl);
 	M0_UT_ASSERT(rc == 0);
 
 	/* Define an extent to be operated. */
-	extent_to_be_operated(*cl, is_contiguous_extents, 1, 1,
-			      extent_kind, ext_to_operate);
+	extent_to_be_operated(*cl, 1, 1, extent_kind, ext_to_operate);
 
 	/* Define the offset to be operated. */
 	if (M0_IN(extent_kind, (NON_EXISTING, EXACT_EXISTING,
@@ -1781,12 +1492,11 @@ static int ext_op_pre(enum extent_operation eop,
 		M0_UT_ASSERT(extent_kind == OVERLAPPING_RIGHT ||
 			     extent_kind == OVERLAPPING_MULTIPLE ||
 			     extent_kind == SECOND_HALF);
-		if (extent_kind == OVERLAPPING_RIGHT || is_contiguous_extents)
+		if (extent_kind == OVERLAPPING_RIGHT)
 			*offset_to_operate = ext_to_operate->e_end - 1;
 		else {
 			M0_UT_ASSERT(extent_kind == SECOND_HALF ||
 				     extent_kind == OVERLAPPING_MULTIPLE);
-			M0_UT_ASSERT(!is_contiguous_extents);
 			if (extents_nr % 2 == 0)
 				*offset_to_operate =
 					 ext_to_operate->e_start;
@@ -1827,8 +1537,7 @@ static int ext_op_pre(enum extent_operation eop,
 	rc_tmp = m0_composite_layer_ext_lookup(*cl, *offset_to_operate,
 					       &ext_lookup, state_lookup,
 					       &layer);
-	if (extent_kind == NON_EXISTING ||
-	    (extent_kind == OVERLAPPING_LEFT && !is_contiguous_extents)) {
+	if (extent_kind == NON_EXISTING || (extent_kind == OVERLAPPING_LEFT)) {
 		M0_UT_ASSERT(rc_tmp == -ENOENT);
 		if (eop == EXTENT_LOOKUP) {
 			M0_UT_ASSERT(failure_test);
@@ -1913,10 +1622,6 @@ static int ext_add(struct m0_composite_layout *cl,
 	int                                rc;
 
 	/* Add the extent. */
-#if 0 //todo rm
-	rc = m0_composite_layer_ext_add(cl, cl->cl_layers_nr - 1,
-					ext_to_operate, state);
-#endif
 	rc = m0_composite_layer_update(cl, cl->cl_layers_nr - 1,
 				       ext_to_operate, state);
 	if (failure_test) {
@@ -1961,10 +1666,6 @@ static int ext_update(struct m0_composite_layout *cl,
 	struct m0_composite_layer         *layer;
 	int                                rc;
 
-#if 0 //todo rm
-	rc = m0_composite_layer_ext_state_update(cl, cl->cl_layers_nr - 1,
-						 ext_to_operate, state);
-#endif
 	rc = m0_composite_layer_update(cl, cl->cl_layers_nr - 1,
 				       ext_to_operate, state);
 	if (failure_test) {
@@ -1994,7 +1695,6 @@ static int ext_delete(struct m0_composite_layout *cl,
 		      struct m0_layout *l_copy_orig,
 		      struct m0_layout_domain *domain,
 		      enum kind_of_extent extent_kind,
-		      bool is_contiguous_extents,
 		      struct m0_ext *ext_to_operate,
 		      m0_bindex_t offset_to_operate,
 		      bool failure_test)
@@ -2005,10 +1705,6 @@ static int ext_delete(struct m0_composite_layout *cl,
 	int                                rc;
 
 	/* Delete the extent. */
-#if 0
-	rc = m0_composite_layer_ext_delete(cl, cl->cl_layers_nr - 1,
-					   ext_to_operate);
-#endif
 	rc = m0_composite_layer_update(cl, cl->cl_layers_nr - 1,
 				       ext_to_operate, M0_CLRES_HOLE);
 	if (failure_test) {
@@ -2027,8 +1723,7 @@ static int ext_delete(struct m0_composite_layout *cl,
 						   &ext_lookup, &state_lookup,
 						   &layer);
 		if (extent_kind == NON_EXISTING ||
-		    (extent_kind == OVERLAPPING_LEFT &&
-		     !is_contiguous_extents)) {
+		    extent_kind == OVERLAPPING_LEFT) {
 			M0_UT_ASSERT(rc == -ENOENT);
 			rc = 0;
 		} else {
@@ -2043,7 +1738,6 @@ static int test_ext_lookup(uint64_t lid,
 			   struct m0_layout_domain *domain,
 			   uint32_t layers_nr,
 			   uint32_t extents_nr,
-			   bool is_contiguous_extents,
 			   enum kind_of_extent extent_kind,
 			   bool failure_test)
 {
@@ -2055,8 +1749,7 @@ static int test_ext_lookup(uint64_t lid,
 	int                                rc;
 
 	rc = ext_op_pre(EXTENT_LOOKUP, lid, domain, layers_nr, extents_nr,
-			is_contiguous_extents, extent_kind,
-			M0_CLRES_HOLE, /* todo */
+			extent_kind, M0_CLRES_HOLE, /* todo */
 			failure_test, &cl, &ext_to_operate, &offset_to_operate,
 			&state_lookup, &l_copy_orig);
 	if (failure_test)
@@ -2102,9 +1795,7 @@ int test_ext_lookup_depth(uint64_t lid,
 
 	my_console_printf("\ntest_ext_lookup_depth:");
 	rc = ext_op_pre(EXTENT_LOOKUP, lid, domain, layers_nr, extents_nr,
-			//todo Jul 25 CONTIGUOUS_EXTENTS, EXACT_EXISTING,
-			!CONTIGUOUS_EXTENTS, EXACT_EXISTING,
-			M0_CLRES_HOLE, /* todo */
+			EXACT_EXISTING, M0_CLRES_HOLE, /* todo */
 			!FAILURE_TEST, &cl, &ext_to_operate, &offset_to_operate,
 			&state_lookup, &l_copy_orig);
 	M0_UT_ASSERT(rc == 0);
@@ -2118,9 +1809,6 @@ int test_ext_lookup_depth(uint64_t lid,
 	 */
 	i = cl->cl_layers_nr - 1;
 	while (1) {
-#if 0 //todo rm
-		rc = m0_composite_layer_ext_delete(cl, i, &ext_to_operate);
-#endif
 		rc = m0_composite_layer_update(cl, i, &ext_to_operate,
 					       M0_CLRES_HOLE);
 		M0_UT_ASSERT(rc == 0);
@@ -2154,7 +1842,6 @@ static int test_ext_add(uint64_t lid,
 			struct m0_layout_domain *domain,
 			uint32_t layers_nr,
 			uint32_t extents_nr,
-			bool is_contiguous_extents,
 			enum kind_of_extent extent_kind,
 			uint64_t state,
 			bool failure_test)
@@ -2167,9 +1854,8 @@ static int test_ext_add(uint64_t lid,
 	int                                rc;
 
 	rc = ext_op_pre(EXTENT_ADD, lid, domain, layers_nr, extents_nr,
-			is_contiguous_extents, extent_kind, state,
-			failure_test, &cl, &ext_to_operate, &offset_to_operate,
-			&state_lookup, &l_copy_orig);
+			extent_kind, state, failure_test, &cl, &ext_to_operate,
+			&offset_to_operate, &state_lookup, &l_copy_orig);
 	M0_UT_ASSERT(rc == 0);
 
 	rc = ext_add(cl, l_copy_orig, domain, extent_kind, &ext_to_operate,
@@ -2188,7 +1874,6 @@ static int test_ext_state_update(uint64_t lid,
 				 struct m0_layout_domain *domain,
 				 uint32_t layers_nr,
 				 uint32_t extents_nr,
-				 bool is_contiguous_extents,
 				 enum kind_of_extent extent_kind,
 				 uint64_t state,
 				 bool failure_test)
@@ -2201,9 +1886,8 @@ static int test_ext_state_update(uint64_t lid,
 	int                                rc;
 
 	rc = ext_op_pre(EXTENT_UPDATE, lid, domain, layers_nr, extents_nr,
-			is_contiguous_extents, extent_kind, state,
-			failure_test, &cl, &ext_to_operate, &offset_to_operate,
-			&state_lookup, &l_copy_orig);
+			extent_kind, state, failure_test, &cl, &ext_to_operate,
+			&offset_to_operate, &state_lookup, &l_copy_orig);
 	M0_UT_ASSERT(rc == 0);
 
 	rc = ext_update(cl, l_copy_orig, domain, extent_kind, &ext_to_operate,
@@ -2222,7 +1906,6 @@ static int test_ext_delete(uint64_t lid,
 			   struct m0_layout_domain *domain,
 			   uint32_t layers_nr,
 			   uint32_t extents_nr,
-			   bool is_contiguous_extents,
 			   enum kind_of_extent extent_kind,
 			   bool failure_test)
 {
@@ -2235,21 +1918,15 @@ static int test_ext_delete(uint64_t lid,
 	int                                rc;
 
 	rc = ext_op_pre(EXTENT_DELETE, lid, domain, layers_nr, extents_nr,
-			is_contiguous_extents, extent_kind, M0_CLRES_HOLE,
-			failure_test, &cl, &ext_to_operate, &offset_to_operate,
-			&state_lookup, &l_copy_orig);
+			extent_kind, M0_CLRES_HOLE, failure_test, &cl,
+			&ext_to_operate, &offset_to_operate, &state_lookup,
+			&l_copy_orig);
 	M0_UT_ASSERT(rc == 0);
 
 	if (M0_FI_ENABLED("ext_del_validation_err")) {
 		M0_UT_ASSERT(extent_kind == OVERLAPPING_COMPLETE);
 		ext.e_start = ext_to_operate.e_end - 1;
 		ext.e_end = ext_to_operate.e_end;
-#if 0
-		rc = m0_composite_layer_ext_state_update(cl,
-							 cl->cl_layers_nr - 1,
-							 &ext,
-							 M0_CLRES_FLATTENING);
-#endif
 		rc = m0_composite_layer_update(cl, cl->cl_layers_nr - 1, &ext,
 					       M0_CLRES_FLATTENING);
 		M0_UT_ASSERT(rc == 0);
@@ -2258,8 +1935,7 @@ static int test_ext_delete(uint64_t lid,
 		composite_layout_copy(&cl->cl_base, &l_copy_orig);
 	}
 
-	rc = ext_delete(cl, l_copy_orig, domain, extent_kind,
-			is_contiguous_extents, &ext_to_operate,
+	rc = ext_delete(cl, l_copy_orig, domain, extent_kind, &ext_to_operate,
 			offset_to_operate, failure_test);
 	if (failure_test)
 		M0_UT_ASSERT(rc == -ENOENT || rc == -EINVAL);
@@ -2273,60 +1949,43 @@ static int test_ext_delete(uint64_t lid,
 
 /**
  * Iterates over various extent kinds to perform a particular extent operation
- * on each of those extent kinds, once with CONTIGUOUS_EXTENTS and then
- * with !CONTIGUOUS_EXTENTS.
+ * on each of those extent kinds.
  */
 static int ext_ops(uint64_t base_lid,
 		   struct m0_layout_domain *domain,
 		   enum extent_operation eop)
 {
 	uint64_t            lid;
-	bool                is_contiguous;
-	enum kind_of_extent extent_kind;
-	enum kind_of_extent extent_kind_it; /* For iterating over ext kinds. */
+	enum kind_of_extent extent_kind; /* For iterating over ext kinds. */
 	bool                failure_test;
 	uint32_t            i;
 	int                 rc;
 
 	M0_UT_ASSERT(M0_IN(eop, (EXTENT_LOOKUP, EXTENT_ADD, EXTENT_UPDATE,
 				 EXTENT_DELETE)));
-	extent_kind_it = NON_EXISTING;
-	for (i = 0; i < KIND_OF_EXTENT_NR * 2; ++i) {
+	extent_kind = NON_EXISTING;
+	for (i = 0; i < KIND_OF_EXTENT_NR; ++i, ++extent_kind) {
 		lid = base_lid + i;
-		//todo Jul 25 is_contiguous = i % 2 ? false : true;
-		is_contiguous = false;
-		extent_kind = extent_kind_it;
 		failure_test = false;
 
-		if (i != 0 && i % 2)
-			++extent_kind_it;
-
-		if (is_contiguous == true && extent_kind == NON_EXISTING)
-			/* Not a valid combination. */
-			continue;
-
 		if (eop == EXTENT_LOOKUP) {
 			if (extent_kind == NON_EXISTING ||
-			    (extent_kind == OVERLAPPING_LEFT && !is_contiguous))
+			    extent_kind == OVERLAPPING_LEFT)
 				failure_test = true;
-			rc = test_ext_lookup(lid, domain, 3, 4,
-					     is_contiguous, extent_kind,
+			rc = test_ext_lookup(lid, domain, 3, 4, extent_kind,
 					     failure_test);
 		} else if (eop == EXTENT_ADD)
-			rc = test_ext_add(lid, domain, 4, 7,
-					  is_contiguous, extent_kind,
+			rc = test_ext_add(lid, domain, 4, 7, extent_kind,
 					  M0_CLRES_VALID, !FAILURE_TEST);
 		else if (eop == EXTENT_UPDATE)
 			rc = test_ext_state_update(lid, domain, 5, 4,
-						   is_contiguous, extent_kind,
-						   M0_CLRES_VALID,
+						   extent_kind, M0_CLRES_VALID,
 						   !FAILURE_TEST);
 			/* todo For failure test, use M0_CLRES_FLATTENING. And
 			 * in that case, the only success case is
 			 * !CONTIGUOUS_EXTENTS, NON_EXISTING. */
 		else if (eop == EXTENT_DELETE)
-			rc = test_ext_delete(lid, domain, 4, 4,
-					     is_contiguous, extent_kind,
+			rc = test_ext_delete(lid, domain, 4, 4, extent_kind,
 					     !FAILURE_TEST);
 		if (failure_test)
 			M0_UT_ASSERT(rc != 0);
@@ -2356,8 +2015,8 @@ void test_layer_ext_ops_composite(uint64_t base_lid,
 	//todo Add extent with the flattening state
 	//todo Cover other cases with the flattening state addition
 	lid = base_lid + 60;
-	rc = test_ext_add(lid, domain, 4, 6, !CONTIGUOUS_EXTENTS, NON_EXISTING,
-			  M0_CLRES_FLATTENING, !FAILURE_TEST);
+	rc = test_ext_add(lid, domain, 4, 6, NON_EXISTING, M0_CLRES_FLATTENING,
+			 !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
 	/* Test cases for extent updation. */
@@ -2498,7 +2157,6 @@ int test_lookup_composite(uint64_t lid,
 			  struct m0_layout_domain *domain,
 			  uint32_t layers_nr,
 			  uint32_t extents_nr,
-			  bool is_contiguous_extents,
 			  bool existing_test,
 			  bool failure_test)
 {
@@ -2516,7 +2174,6 @@ int test_lookup_composite(uint64_t lid,
 		/* Build a layout object, add layers to it, add it to the DB. */
 		rc = composite_build_and_layers_add(lid, domain, layers_nr,
 						    extents_nr,
-						    is_contiguous_extents,
 						    !FAILURE_TEST,
 						    !LAYER_ADD_FAILURE_TEST,
 						    &cl);
@@ -2584,7 +2241,6 @@ int test_add_composite(uint64_t lid,
 		       struct m0_layout_domain *domain,
 		       uint32_t layers_nr,
 		       uint32_t extents_nr,
-		       bool is_contiguous_extents,
 		       bool duplicate_test,
 		       bool failure_test)
 {
@@ -2598,9 +2254,7 @@ int test_add_composite(uint64_t lid,
 	M0_UT_ASSERT(ergo(duplicate_test, !failure_test));
 
 	/* Build a layout object and add layers to it. */
-	rc = composite_build_and_layers_add(lid, domain, layers_nr,
-					    extents_nr,
-					    is_contiguous_extents,
+	rc = composite_build_and_layers_add(lid, domain, layers_nr, extents_nr,
 					    !FAILURE_TEST,
 					    !LAYER_ADD_FAILURE_TEST, &cl);
 	M0_UT_ASSERT(rc == 0);
@@ -2678,7 +2332,6 @@ int test_update_composite(uint64_t lid,
 			  struct m0_layout_domain *domain,
 			  uint32_t layers_nr,
 			  uint32_t extents_nr,
-			  bool is_contiguous_extents,
 			  bool failure_test)
 {
 	struct m0_composite_layout        *cl;
@@ -2686,8 +2339,8 @@ int test_update_composite(uint64_t lid,
 	struct m0_layout                  *l1_original_copy;
 	struct m0_layout                  *l1_changed_copy;
 	struct m0_layout                  *l_from_db;
-	struct m0_layout                  *sublayout;
-	uint64_t                           sublayout_id;
+	struct m0_layout                  *sl;
+	uint64_t                           sl_id;
 	struct m0_ext                      ext_to_operate;
 	struct m0_ext                      ext_lookup;
 	enum m0_composite_layer_ext_state  state_lookup;
@@ -2700,7 +2353,6 @@ int test_update_composite(uint64_t lid,
 
 	/* Build a layout object and add layers to it only in memory. */
 	rc = composite_build_and_layers_add(lid, domain, layers_nr, extents_nr,
-					    is_contiguous_extents,
 					    !FAILURE_TEST,
 					    !LAYER_ADD_FAILURE_TEST, &cl);
 	M0_UT_ASSERT(rc == 0);
@@ -2727,16 +2379,11 @@ int test_update_composite(uint64_t lid,
 	 * 2. Add an extent to its top-most layer by first verifying that
 	 *    the lookup returns ENOENT error for it.
 	 */
-	extent_to_be_operated(cl, is_contiguous_extents, 1, 1,
-			      NON_EXISTING, &ext_to_operate);
+	extent_to_be_operated(cl, 1, 1, NON_EXISTING, &ext_to_operate);
 	rc = m0_composite_layer_ext_lookup(cl, ext_to_operate.e_start + 1,
 					   &ext_lookup, &state_lookup,
 					   &layer);
 	M0_UT_ASSERT(rc == -ENOENT);
-#if 0 //todo rm
-	rc = m0_composite_layer_ext_add(cl, cl->cl_layers_nr - 1,
-					&ext_to_operate, M0_CLRES_FLATTENING);
-#endif
 	rc = m0_composite_layer_update(cl, cl->cl_layers_nr - 1,
 				       &ext_to_operate, M0_CLRES_FLATTENING);
 	M0_UT_ASSERT(rc == 0);
@@ -2749,10 +2396,10 @@ int test_update_composite(uint64_t lid,
 	/* 3. Add layers to it. */
 	M0_UT_ASSERT(cl->cl_layers_nr == layers_nr);
 	for (i = 0; i < layers_to_add_nr; ++i) {
-		sublayout_id = (cl->cl_base.l_id * 100) + cl->cl_layers_nr;
-		rc = sublayout_build(sublayout_id, domain, &sublayout);
+		sl_id = (cl->cl_base.l_id * 100) + cl->cl_layers_nr;
+		rc = sublayout_build(sl_id, domain, &sl);
 		M0_UT_ASSERT(rc == 0);
-		rc = m0_composite_layer_add(cl, sublayout);
+		rc = m0_composite_layer_add(cl, sl);
 		M0_UT_ASSERT(rc == 0);
 	}
 	M0_UT_ASSERT(cl->cl_layers_nr == layers_nr + layers_to_add_nr);
@@ -2834,7 +2481,6 @@ int test_delete_composite(uint64_t lid,
 			  struct m0_layout_domain *domain,
 			  uint32_t layers_nr,
 			  uint32_t extents_nr,
-			  bool is_contiguous_extents,
 			  bool failure_test)
 {
 	struct m0_composite_layout *cl;
@@ -2845,7 +2491,6 @@ int test_delete_composite(uint64_t lid,
 
 	/* Build a layout object, add layers to it, add it to the DB. */
 	rc = composite_build_and_layers_add(lid, domain, layers_nr, extents_nr,
-					    is_contiguous_extents,
 					    !FAILURE_TEST,
 					    !LAYER_ADD_FAILURE_TEST, &cl);
 	M0_UT_ASSERT(rc == 0);
diff --git a/layout/ut/composite.h b/layout/ut/composite.h
index cd33ab8..b497d2d 100644
--- a/layout/ut/composite.h
+++ b/layout/ut/composite.h
@@ -24,9 +24,9 @@
 #define __MERO_LAYOUT_UT_COMPOSITE_H__
 
 /**
- * Kind of the extent that 'is to be looked up from the extent list' or 'is to
- * be added/updated/deleted to/from the extent list' for a particular layer
- * from a particular composite layout.
+ * This is regarding the 'kind of the extent' that 'is to be looked up from the
+ * extent list' or 'is to be added/updated/deleted to/from the extent list' for
+ * a particular layer from a particular composite layout.
  *
  * Assume that an extent list is as below:
  * ext[0]: [                   0,  2635249153387078802), state 1
@@ -75,16 +75,6 @@ enum extent_operation {
 };
 
 enum {
-	/**
-	 * Extent list associated with a layer is built with contiguous valid
-	 * extents.
-	 */
-	CONTIGUOUS_EXTENTS     = true,
-	/**
-	 * Some layouts are formed as composite type of layouts along with some
-	 * as pdclust type of layouts.
-	 */
-	COMPOSITE_SUBLAYOUTS   = true,
 	/** Failure injected for layer add op */
         LAYER_ADD_FAILURE_TEST = true,
 	/** Failure injected for layer del op */
@@ -102,30 +92,25 @@ enum {
 int test_build_composite(uint64_t lid,
 			 struct m0_layout_domain *domain,
 			 uint32_t extents_nr,
-			 bool is_contiguous_extents,
 			 bool failure_test);
 int test_decode_composite(uint64_t lid,
 			  struct m0_layout_domain *domain,
 			  uint32_t sublayouts_nr,
 			  uint32_t extents_nr,
-			  bool is_contiguous_extents,
 			  bool failure_test);
 int test_encode_composite(uint64_t lid,
 			  struct m0_layout_domain *domain,
 			  uint32_t sublayouts_nr,
 			  uint32_t extents_nr,
-			  bool is_contiguous_extents,
 			  bool failure_test);
 int test_decode_encode_composite(uint64_t lid,
 				 struct m0_layout_domain *domain,
 				 uint32_t sublayouts_nr,
-				 uint32_t extents_nr,
-				 bool is_contiguous_extents);
+				 uint32_t extents_nr);
 int test_encode_decode_composite(uint64_t lid,
 				 struct m0_layout_domain *domain,
 				 uint32_t sublayouts_nr,
-				 uint32_t extents_nr,
-				 bool is_contiguous_extents);
+				 uint32_t extents_nr);
 int test_instance_composite(uint64_t lid,
 			    struct m0_layout_domain *domain,
 			    bool failure_test);
@@ -133,27 +118,23 @@ int test_lookup_composite(uint64_t lid,
 			  struct m0_layout_domain *domain,
 			  uint32_t layers_nr,
 			  uint32_t extents_nr,
-			  bool is_contiguous_extents,
 			  bool existing_test,
 			  bool failure_test);
 int test_add_composite(uint64_t lid,
 		       struct m0_layout_domain *domain,
 		       uint32_t sublayouts_nr,
 		       uint32_t extents_nr,
-		       bool is_contiguous_extents,
 		       bool duplicate_test,
 		       bool failure_test);
 int test_update_composite(uint64_t lid,
 			  struct m0_layout_domain *domain,
 			  uint32_t sublayouts_nr,
 			  uint32_t extents_nr,
-			  bool is_contiguous_extents,
 			  bool failure_test);
 int test_delete_composite(uint64_t lid,
 			  struct m0_layout_domain *domain,
 			  uint32_t sublayouts_nr,
 			  uint32_t extents_nr,
-			  bool is_contiguous_extents,
 			  bool failure_test);
 int test_layer_ops_composite(uint64_t lid,
 			     struct m0_layout_domain *domain,
diff --git a/layout/ut/layout.c b/layout/ut/layout.c
index ff403c9..6127f00 100644
--- a/layout/ut/layout.c
+++ b/layout/ut/layout.c
@@ -471,25 +471,13 @@ static void test_build(void)
 				!FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
-#if 0 //todo jul 25
-	/*
-	 * Build a layout object with COMPOSITE layout type, associate some
-	 * contiguous extents to its zeroth layer and then destroy the layout.
-	 */
-	lid = 1021;
-	rc = test_build_composite(lid, &domain, 5, CONTIGUOUS_EXTENTS,
-				  !FAILURE_TEST);
-	M0_UT_ASSERT(rc == 0);
-#endif
-
 	/*
 	 * Build a layout object with COMPOSITE layout type, associate some
 	 * noncontiguous extents to its zeroth layer and then destroy the
 	 * layout.
 	 */
 	lid = 1022;
-	rc = test_build_composite(lid, &domain, 10, !CONTIGUOUS_EXTENTS,
-				  !FAILURE_TEST);
+	rc = test_build_composite(lid, &domain, 10, !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
 	/*
@@ -497,8 +485,7 @@ static void test_build(void)
 	 * single extent to its zeroth layer and then destory the layout.
 	 */
 	lid = 1023;
-	rc = test_build_composite(lid, &domain, 1, CONTIGUOUS_EXTENTS,
-				  !FAILURE_TEST);
+	rc = test_build_composite(lid, &domain, 1, !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 }
 
@@ -591,8 +578,7 @@ static void test_build_failure(void)
 	 */
 	lid = 2021;
 	m0_fi_enable_once("composite_allocate", "alloc_ptr_fail/cl");
-	rc = test_build_composite(lid, &domain, 5, !CONTIGUOUS_EXTENTS,
-				  FAILURE_TEST);
+	rc = test_build_composite(lid, &domain, 5, FAILURE_TEST);
 	M0_UT_ASSERT(rc == -ENOMEM);
 
 	/*
@@ -601,8 +587,7 @@ static void test_build_failure(void)
 	 */
 	lid = 2022;
 	m0_fi_enable_once("layer_add_internal", "alloc_ptr_fail/layer");
-	rc = test_build_composite(lid, &domain, 5, !CONTIGUOUS_EXTENTS,
-				  FAILURE_TEST);
+	rc = test_build_composite(lid, &domain, 5, FAILURE_TEST);
 	M0_UT_ASSERT(rc == -ENOMEM);
 
 	/*
@@ -611,8 +596,7 @@ static void test_build_failure(void)
 	 */
 	lid = 2023;
 	m0_fi_enable_once("layer_add_internal", "alloc_ptr_fail/ext");
-	rc = test_build_composite(lid, &domain, 5, !CONTIGUOUS_EXTENTS,
-				  FAILURE_TEST);
+	rc = test_build_composite(lid, &domain, 5, FAILURE_TEST);
 	M0_UT_ASSERT(rc == -ENOMEM);
 }
 
@@ -662,24 +646,12 @@ static void test_decode(void)
 				 !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
-#if 0 //todo jul 25
-	/*
-	 * Decode a layout object with COMPOSITE layout type and with
-	 * contiguous extents in its layers.
-	 */
-	lid = 3021;
-	rc = test_decode_composite(lid, &domain, 7, 10,
-				   CONTIGUOUS_EXTENTS, !FAILURE_TEST);
-	M0_UT_ASSERT(rc == 0);
-#endif
-
 	/*
 	 * Decode a layout object with COMPOSITE layout type and with
 	 * noncontiguous extents in its layers.
 	 */
 	lid = 3022;
-	rc = test_decode_composite(lid, &domain, 8, 9,
-				   !CONTIGUOUS_EXTENTS, !FAILURE_TEST);
+	rc = test_decode_composite(lid, &domain, 8, 9, !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 }
 
@@ -768,8 +740,7 @@ static void test_decode_failure(void)
 	 * layers_inbuf_read().
 	 */
 	lid = 4021;
-	rc = test_decode_composite(lid, &domain, 2, 0,
-				   !CONTIGUOUS_EXTENTS, FAILURE_TEST);
+	rc = test_decode_composite(lid, &domain, 2, 0, FAILURE_TEST);
 	M0_UT_ASSERT(rc == -EINVAL);
 
 	/*
@@ -780,8 +751,7 @@ static void test_decode_failure(void)
 	lid = 4022;
 	m0_fi_enable_once("composite_layout_buf_build",
 			  "invalid_state_err");
-	rc = test_decode_composite(lid, &domain, 5, 6,
-				   !CONTIGUOUS_EXTENTS, FAILURE_TEST);
+	rc = test_decode_composite(lid, &domain, 5, 6, FAILURE_TEST);
 	M0_UT_ASSERT(rc == -EINVAL);
 #endif
 
@@ -791,8 +761,7 @@ static void test_decode_failure(void)
 	 */
 	lid = 4024;
 	m0_fi_enable_once("ext_add", "alloc_ptr_fail/ext");
-	rc = test_decode_composite(lid, &domain, 5, 6,
-				   !CONTIGUOUS_EXTENTS, FAILURE_TEST);
+	rc = test_decode_composite(lid, &domain, 5, 6, FAILURE_TEST);
 	M0_UT_ASSERT(rc == -ENOMEM);
 
 	/*
@@ -802,8 +771,7 @@ static void test_decode_failure(void)
 	lid = 4025;
 	m0_fi_enable_off_n_on_m("layer_add_internal", "alloc_ptr_fail/layer",
 				2, 1);
-	rc = test_decode_composite(lid, &domain, 5, 6,
-				   !CONTIGUOUS_EXTENTS, FAILURE_TEST);
+	rc = test_decode_composite(lid, &domain, 5, 6, FAILURE_TEST);
 	M0_UT_ASSERT(rc == -ENOMEM);
 	m0_fi_disable("layer_add_internal", "alloc_ptr_fail/layer");
 
@@ -811,23 +779,20 @@ static void test_decode_failure(void)
 	lid = 4026;
 	m0_fi_enable_off_n_on_m("layer_add_internal", "alloc_ptr_fail/layer",
 				3, 1);
-	rc = test_decode_composite(lid, &domain, 5, 6,
-				   !CONTIGUOUS_EXTENTS, FAILURE_TEST);
+	rc = test_decode_composite(lid, &domain, 5, 6, FAILURE_TEST);
 	M0_UT_ASSERT(rc == -ENOMEM);
 	m0_fi_disable("layer_add_internal", "alloc_ptr_fail/layer");
 
 	/* Simulate sublayout find error while reading the zeroth layer. */
 	lid = 4027;
 	m0_fi_enable_once("layout_find", "layout_find_err");
-	rc = test_decode_composite(lid, &domain, 5, 6,
-				   !CONTIGUOUS_EXTENTS, FAILURE_TEST);
+	rc = test_decode_composite(lid, &domain, 5, 6, FAILURE_TEST);
 	M0_UT_ASSERT(rc == -EINVAL);
 
 	/* Simulate sublayout find error while reading a non-zeroth layer. */
 	lid = 4028;
 	m0_fi_enable_off_n_on_m("layout_find", "layout_find_err", 2, 1);
-	rc = test_decode_composite(lid, &domain, 5, 6,
-				   !CONTIGUOUS_EXTENTS, FAILURE_TEST);
+	rc = test_decode_composite(lid, &domain, 5, 6, FAILURE_TEST);
 	m0_fi_disable("layout_find", "layout_find_err");
 	M0_UT_ASSERT(rc == -EINVAL);
 }
@@ -871,24 +836,12 @@ static void test_encode(void)
 				 INLINE_NOT_APPLICABLE, !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
-#if 0 //todo jul 25
-	/*
-	 * Encode for COMPOSITE layout type with contiguous extents in its
-	 * layers.
-	 */
-	lid = 5021;
-	rc = test_encode_composite(lid, &domain, 8, 25,
-				   CONTIGUOUS_EXTENTS, !FAILURE_TEST);
-	M0_UT_ASSERT(rc == 0);
-#endif
-
 	/*
 	 * Encode for COMPOSITE layout type with noncontiguous extents in its
 	 * layers.
 	 */
 	lid = 5022;
-	rc = test_encode_composite(lid, &domain, 9, 25,
-				   !CONTIGUOUS_EXTENTS, !FAILURE_TEST);
+	rc = test_encode_composite(lid, &domain, 9, 25, !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 }
 
@@ -915,8 +868,7 @@ static void test_encode_failure(void)
 	/* Simulate m0_layout_encode() failure. */
 	lid = 6021;
 	m0_fi_enable_once("m0_layout_encode", "lo_encode_err");
-	rc = test_encode_composite(lid, &domain, 4, 5,
-				   !CONTIGUOUS_EXTENTS, FAILURE_TEST);
+	rc = test_encode_composite(lid, &domain, 4, 5, FAILURE_TEST);
 	M0_UT_ASSERT(rc == LO_ENCODE_ERR);
 }
 
@@ -978,22 +930,6 @@ static void test_decode_encode(void)
 					LINEAR_ENUM_ID, INLINE_NOT_APPLICABLE);
 	M0_UT_ASSERT(rc == 0);
 
-
-#if 0 //todo jul 25
-	/*
-	 * Build a layout buffer representing a layout with COMPOSITE layout
-	 * type, with contiguous extents.
-	 * Decode it into a layout object. Then encode that layout object again
-	 * into another layout buffer.
-	 * Then, compare the original layout buffer with the encoded layout
-	 * buffer.
-	 */
-	lid = 7021;
-	rc = test_decode_encode_composite(lid, &domain, 5, 10,
-					  CONTIGUOUS_EXTENTS);
-	M0_UT_ASSERT(rc == 0);
-#endif
-
 	/*
 	 * Build a layout buffer representing a layout with COMPOSITE layout
 	 * type, with noncontiguous extents.
@@ -1003,8 +939,7 @@ static void test_decode_encode(void)
 	 * buffer.
 	 */
 	lid = 7022;
-	rc = test_decode_encode_composite(lid, &domain, 6, 11,
-					  !CONTIGUOUS_EXTENTS);
+	rc = test_decode_encode_composite(lid, &domain, 6, 11);
 	M0_UT_ASSERT(rc == 0);
 
 }
@@ -1062,24 +997,9 @@ static void test_encode_decode(void)
 	 * object.
 	 */
 	lid = 8004;
-	rc = test_encode_decode_pdclust(lid, &domain,
-					LINEAR_ENUM_ID, INLINE_NOT_APPLICABLE);
-	M0_UT_ASSERT(rc == 0);
-
-#if 0 //todo jul 25
-	/*
-	 * Build a layout object with COMPOSITE layout type, with contiguous
-	 * extents.
-	 * Encode it into a layout buffer. Then decode that layout buffer again
-	 * into another layout object.
-	 * Now, compare the original layout object with the decoded layout
-	 * object.
-	 */
-	lid = 8021;
-	rc = test_encode_decode_composite(lid, &domain, 7, 27,
-					  CONTIGUOUS_EXTENTS);
+	rc = test_encode_decode_pdclust(lid, &domain, LINEAR_ENUM_ID,
+					INLINE_NOT_APPLICABLE);
 	M0_UT_ASSERT(rc == 0);
-#endif
 
 	/*
 	 * Build a layout object with COMPOSITE layout type, with noncontiguous
@@ -1090,8 +1010,7 @@ static void test_encode_decode(void)
 	 * object.
 	 */
 	lid = 8022;
-	rc = test_encode_decode_composite(lid, &domain, 8, 28,
-					  !CONTIGUOUS_EXTENTS);
+	rc = test_encode_decode_composite(lid, &domain, 8, 28);
 	M0_UT_ASSERT(rc == 0);
 }
 
@@ -1545,28 +1464,17 @@ static void test_lookup(void)
 	 * exist in the DB.
 	 */
 	lid = 18021;
-	rc = test_lookup_composite(lid, &domain, 7, 5, !CONTIGUOUS_EXTENTS,
-				   !EXISTING_TEST, FAILURE_TEST);
+	rc = test_lookup_composite(lid, &domain, 7, 5, !EXISTING_TEST,
+				   FAILURE_TEST);
 	M0_UT_ASSERT(rc == -ENOENT);
 
-#if 0 //todo jul 25
-	/*
-	 * Add a layout object with COMPOSITE layout type and with contiguous
-	 * extents. Then perform lookup for it.
-	 */
-	lid = 18022;
-	rc = test_lookup_composite(lid, &domain, 5, 30, CONTIGUOUS_EXTENTS,
-				   EXISTING_TEST, !FAILURE_TEST);
-	M0_UT_ASSERT(rc == 0);
-#endif
-
 	/*
 	 * Add a layout object with COMPOSITE layout type and with
 	 * non-contiguous extents. Then perform lookup for it.
 	 */
 	lid = 18023;
-	rc = test_lookup_composite(lid, &domain, 2, 30, !CONTIGUOUS_EXTENTS,
-				   EXISTING_TEST, !FAILURE_TEST);
+	rc = test_lookup_composite(lid, &domain, 2, 30, EXISTING_TEST,
+				   !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
 	/*
@@ -1574,8 +1482,8 @@ static void test_lookup(void)
 	 * extent. Then perform lookup for it.
 	 */
 	lid = 18024;
-	rc = test_lookup_composite(lid, &domain, 5, 1, CONTIGUOUS_EXTENTS,
-				   EXISTING_TEST, !FAILURE_TEST);
+	rc = test_lookup_composite(lid, &domain, 5, 1, EXISTING_TEST,
+				   !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 }
 
@@ -1672,8 +1580,8 @@ static void test_lookup_failure(void)
 	lid = 19021;
 	m0_fi_enable_off_n_on_m("layer_add_internal", "alloc_ptr_fail/layer",
 				6 /* layers_nr + composite_sublayouts nr */, 1);
-	rc = test_lookup_composite(lid, &domain, 4, 5, !CONTIGUOUS_EXTENTS,
-				   EXISTING_TEST, FAILURE_TEST);
+	rc = test_lookup_composite(lid, &domain, 4, 5, EXISTING_TEST,
+				   FAILURE_TEST);
 	M0_UT_ASSERT(rc == -ENOMEM);
 	m0_fi_disable("layer_add_internal", "alloc_ptr_fail/layer");
 
@@ -1685,8 +1593,8 @@ static void test_lookup_failure(void)
 	m0_fi_enable_off_n_on_m("layer_add_internal", "alloc_ptr_fail/layer",
 				7 /* layers_nr + 1 + composite_sublayouts nr */,
 				1);
-	rc = test_lookup_composite(lid, &domain, 4, 5, !CONTIGUOUS_EXTENTS,
-				   EXISTING_TEST, FAILURE_TEST);
+	rc = test_lookup_composite(lid, &domain, 4, 5, EXISTING_TEST,
+				   FAILURE_TEST);
 	M0_UT_ASSERT(rc == -ENOMEM);
 	m0_fi_disable("layer_add_internal", "alloc_ptr_fail/layer");
 
@@ -1697,8 +1605,8 @@ static void test_lookup_failure(void)
 	lid = 19023;
 	m0_fi_enable_off_n_on_m("layer_add_internal", "alloc_ptr_fail/layer",
 				7 /* 2 * layers_nr - 1) */, 1);
-	rc = test_lookup_composite(lid, &domain, 4, 5, !CONTIGUOUS_EXTENTS,
-				   EXISTING_TEST, FAILURE_TEST);
+	rc = test_lookup_composite(lid, &domain, 4, 5, EXISTING_TEST,
+				   FAILURE_TEST);
 	M0_UT_ASSERT(rc == -ENOMEM);
 	m0_fi_disable("layer_add_internal", "alloc_ptr_fail/layer");
 
@@ -1710,8 +1618,8 @@ static void test_lookup_failure(void)
 	m0_fi_enable_off_n_on_m("ext_add", "alloc_ptr_fail/ext",
 				//80 /* layers_nr * extents_nr * 4 */, 1);
 				16 /* todo layers_nr * extents_nr * 4 */, 1);
-	rc = test_lookup_composite(lid, &domain, 4, 5, !CONTIGUOUS_EXTENTS,
-				   EXISTING_TEST, FAILURE_TEST);
+	rc = test_lookup_composite(lid, &domain, 4, 5, EXISTING_TEST,
+				   FAILURE_TEST);
 	M0_UT_ASSERT(rc == -ENOMEM);
 	m0_fi_disable("ext_add", "alloc_ptr_fail/ext");
 
@@ -1721,8 +1629,8 @@ static void test_lookup_failure(void)
 	 */
 	lid = 19025;
 	m0_fi_enable_once("extents_indb_read", "invalid_state_err");
-	rc = test_lookup_composite(lid, &domain, 4, 5, !CONTIGUOUS_EXTENTS,
-				   EXISTING_TEST, FAILURE_TEST);
+	rc = test_lookup_composite(lid, &domain, 4, 5, EXISTING_TEST,
+				   FAILURE_TEST);
 	M0_UT_ASSERT(rc == -EINVAL);
 
 	/* Simulate emap lookup error in the path of extents_indb_read(). */
@@ -1730,8 +1638,8 @@ static void test_lookup_failure(void)
 	lid = 19026;
 	m0_fi_enable_off_n_on_m("emap_iterator_set", "emap_lookup_err",
 				5 /* layers_nr + 1 */, 1);
-	rc = test_lookup_composite(lid, &domain, 4, 5, !CONTIGUOUS_EXTENTS,
-				   EXISTING_TEST, FAILURE_TEST);
+	rc = test_lookup_composite(lid, &domain, 4, 5, EXISTING_TEST,
+				   FAILURE_TEST);
 	M0_UT_ASSERT(rc == L_EMAP_LOOKUP_ERR);
 	m0_fi_disable("emap_iterator_set", "emap_lookup_err");
 
@@ -1745,24 +1653,24 @@ static void test_lookup_failure(void)
 	//todo zeroth layer?
 	lid = 19029;
 	m0_fi_enable_off_n_on_m("layout_find", "layout_find_err", 3, 1);
-	rc = test_lookup_composite(lid, &domain, 4, 5, !CONTIGUOUS_EXTENTS,
-				   EXISTING_TEST, FAILURE_TEST);
+	rc = test_lookup_composite(lid, &domain, 4, 5, EXISTING_TEST,
+				   FAILURE_TEST);
 	M0_UT_ASSERT(rc == -EINVAL);
 	m0_fi_disable("layout_find", "layout_find_err");
 
 	/* Simulate sublayout find error while reading a non-zeroth layer. */
 	lid = 19030;
 	m0_fi_enable_off_n_on_m("layout_find", "layout_find_err", 2, 1);
-	rc = test_lookup_composite(lid, &domain, 4, 5, !CONTIGUOUS_EXTENTS,
-				   EXISTING_TEST, FAILURE_TEST);
+	rc = test_lookup_composite(lid, &domain, 4, 5, EXISTING_TEST,
+				   FAILURE_TEST);
 	M0_UT_ASSERT(rc == -EINVAL);
 	m0_fi_disable("layout_find", "layout_find_err");
 
 	/* Simulate sublayout read error while reading a layer. */
 	lid = 19031;
 	m0_fi_enable_once("sublayout_ids_read", "alloc_arr_fail/sl_id_list");
-	rc = test_lookup_composite(lid, &domain, 4, 5, !CONTIGUOUS_EXTENTS,
-				   EXISTING_TEST, FAILURE_TEST);
+	rc = test_lookup_composite(lid, &domain, 4, 5, EXISTING_TEST,
+				   FAILURE_TEST);
 	M0_UT_ASSERT(rc == -ENOMEM);
 }
 
@@ -1813,24 +1721,13 @@ static void test_add(void)
 			      !DUPLICATE_TEST, !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
-#if 0 //todo jul 25
-	/*
-	 * Add a layout object with COMPOSITE layout type, with contiguous
-	 * extents.
-	 */
-	lid = 20021;
-	rc = test_add_composite(lid, &domain, 5, 25, CONTIGUOUS_EXTENTS,
-				!DUPLICATE_TEST, !FAILURE_TEST);
-	M0_UT_ASSERT(rc == 0);
-#endif
-
 	/*
 	 * Add a layout object with COMPOSITE layout type, with noncontiguous
 	 * extents.
 	 */
 	lid = 20022;
-	rc = test_add_composite(lid, &domain, 7, 50, !CONTIGUOUS_EXTENTS,
-				!DUPLICATE_TEST, !FAILURE_TEST);
+	rc = test_add_composite(lid, &domain, 7, 50, !DUPLICATE_TEST,
+				!FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 }
 
@@ -1895,9 +1792,8 @@ static void test_add_failure(void)
 	 * DUPLICATE_TEST.
 	 */
 	lid = 21021;
-	//todo jul 25 rc = test_add_composite(lid, &domain, 4, 15, CONTIGUOUS_EXTENTS,
-	rc = test_add_composite(lid, &domain, 4, 15, !CONTIGUOUS_EXTENTS,
-				DUPLICATE_TEST, !FAILURE_TEST);
+	rc = test_add_composite(lid, &domain, 4, 15, DUPLICATE_TEST,
+				!FAILURE_TEST);
 	M0_UT_ASSERT(rc == -EEXIST);
 
 	/*
@@ -1906,8 +1802,8 @@ static void test_add_failure(void)
 	 */
 	lid = 21026;
 	m0_fi_enable_once("emap_iterator_set", "emap_lookup_err");
-	rc = test_add_composite(lid, &domain, 4, 15, !CONTIGUOUS_EXTENTS,
-				!DUPLICATE_TEST, FAILURE_TEST);
+	rc = test_add_composite(lid, &domain, 4, 15, !DUPLICATE_TEST,
+				FAILURE_TEST);
 	M0_UT_ASSERT(rc == L_EMAP_LOOKUP_ERR);
 
 	/*
@@ -1917,8 +1813,8 @@ static void test_add_failure(void)
 	lid = 21027;
 	m0_fi_enable_off_n_on_m("emap_iterator_set", "emap_lookup_err",
 				3 /* layers_nr - 1 */, 1);
-	rc = test_add_composite(lid, &domain, 4, 15, !CONTIGUOUS_EXTENTS,
-				!DUPLICATE_TEST, FAILURE_TEST);
+	rc = test_add_composite(lid, &domain, 4, 15, !DUPLICATE_TEST,
+				FAILURE_TEST);
 	M0_UT_ASSERT(rc == L_EMAP_LOOKUP_ERR);
 	m0_fi_disable("emap_iterator_set", "emap_lookup_err");
 
@@ -1928,8 +1824,8 @@ static void test_add_failure(void)
 	 */
 	lid = 21028;
 	m0_fi_enable_once("extents_indb_add", "emap_obj_insert_err");
-	rc = test_add_composite(lid, &domain, 4, 15, !CONTIGUOUS_EXTENTS,
-				!DUPLICATE_TEST, FAILURE_TEST);
+	rc = test_add_composite(lid, &domain, 4, 15, !DUPLICATE_TEST,
+				FAILURE_TEST);
 	M0_UT_ASSERT(rc == L_EMAP_OBJ_INSERT_ERR);
 }
 
@@ -1977,8 +1873,7 @@ static void test_update(void)
 
 	/* Update a layout object with COMPOSITE layout type. */
 	lid = 22022;
-	rc = test_update_composite(lid, &domain, 4, 15, !CONTIGUOUS_EXTENTS,
-				   !FAILURE_TEST);
+	rc = test_update_composite(lid, &domain, 4, 15, !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 }
 
@@ -2007,8 +1902,7 @@ static void test_update_failure(void)
 	 */
 	lid = 23003;
 	m0_fi_enable_once("single_ext_indb_write", "emap_lookup_err");
-	rc = test_update_composite(lid, &domain, 4, 7, !CONTIGUOUS_EXTENTS,
-				   FAILURE_TEST);
+	rc = test_update_composite(lid, &domain, 4, 7, FAILURE_TEST);
 	M0_UT_ASSERT(rc == L_EMAP_LOOKUP_ERR);
 
 	/*
@@ -2017,16 +1911,14 @@ static void test_update_failure(void)
 	 */
 	lid = 23004;
 	m0_fi_enable_once("single_ext_indb_write", "emap_paste_err");
-	rc = test_update_composite(lid, &domain, 4, 7, !CONTIGUOUS_EXTENTS,
-				   FAILURE_TEST);
+	rc = test_update_composite(lid, &domain, 4, 7, FAILURE_TEST);
 	M0_UT_ASSERT(rc == L_EMAP_PASTE_ERR);
 
 	/* Simulate emap paste error while adding a non-zeroth layer. */
 	lid = 23005;
 	m0_fi_enable_off_n_on_m("ext_indb_write", "emap_paste_err",
 				16 /* layer_nr * extents_nr + 1 */, 1);
-	rc = test_update_composite(lid, &domain, 3, 5, !CONTIGUOUS_EXTENTS,
-				   FAILURE_TEST);
+	rc = test_update_composite(lid, &domain, 3, 5, FAILURE_TEST);
 	M0_UT_ASSERT(rc == L_EMAP_PASTE_ERR);
 	m0_fi_disable("ext_indb_write", "emap_paste_err");
 
@@ -2036,8 +1928,7 @@ static void test_update_failure(void)
 	 */
 	lid = 25006;
 	m0_fi_enable_once("layout_find", "layout_find_err");
-	rc = test_update_composite(lid, &domain, 3, 5, !CONTIGUOUS_EXTENTS,
-				   FAILURE_TEST);
+	rc = test_update_composite(lid, &domain, 3, 5, FAILURE_TEST);
 	M0_UT_ASSERT(rc == -EINVAL);
 }
 
@@ -2087,24 +1978,12 @@ static void test_delete(void)
 				 EXISTING_TEST, !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
-#if 0 //todo jul 25i
-	/*
-	 * Delete a layout object with COMPOSITE layout type, contiguous
-	 * extents.
-	 */
-	lid = 24021;
-	rc = test_delete_composite(lid, &domain, 4, 10,
-				   CONTIGUOUS_EXTENTS, !FAILURE_TEST);
-	M0_UT_ASSERT(rc == 0);
-#endif
-
 	/*
 	 * Delete a layout object with COMPOSITE layout type, noncontiguous
 	 * extents.
 	 */
 	lid = 24022;
-	rc = test_delete_composite(lid, &domain, 4, 10,
-				   !CONTIGUOUS_EXTENTS, !FAILURE_TEST);
+	rc = test_delete_composite(lid, &domain, 4, 10, !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 }
 
@@ -2173,20 +2052,15 @@ static void test_delete_failure(void)
 	lid = 25021;
 	m0_fi_enable_off_n_on_m("emap_iterator_set", "emap_lookup_err",
 				9 /* layers_nr * 2 + 1 */, 1);
-	rc = test_delete_composite(lid, &domain, 4, 10,
-				   //todo jul 25 CONTIGUOUS_EXTENTS, FAILURE_TEST);
-				   !CONTIGUOUS_EXTENTS, FAILURE_TEST);
+	rc = test_delete_composite(lid, &domain, 4, 10, FAILURE_TEST);
 	M0_UT_ASSERT(rc == L_EMAP_LOOKUP_ERR);
 	m0_fi_disable("emap_iterator_set", "emap_lookup_err");
 
 	/* Simulate layer deletion error while deleting emap from the DB. */
 	lid = 25022;
-	//todo rm m0_fi_enable_once("layer_indb_delete", "emap_obj_del_err");
 	m0_fi_enable_off_n_on_m("layer_indb_delete", "emap_obj_del_err",
 				4 /* layers_nr */, 1);
-	rc = test_delete_composite(lid, &domain, 4, 10,
-				   //todo jul 25 CONTIGUOUS_EXTENTS, FAILURE_TEST);
-				   !CONTIGUOUS_EXTENTS, FAILURE_TEST);
+	rc = test_delete_composite(lid, &domain, 4, 10, FAILURE_TEST);
 	M0_UT_ASSERT(rc == L_EMAP_OBJ_DEL_ERR);
 	m0_fi_disable("layer_indb_delete", "emap_obj_del_err");
 }
-- 
1.8.3.2

