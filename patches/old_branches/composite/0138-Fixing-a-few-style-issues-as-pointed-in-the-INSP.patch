From dea65bd2d9223d6e673c8ec739076d0eddc0e6ec Mon Sep 17 00:00:00 2001
From: "trupti.patil" <trupti_patil@xyratex.com>
Date: Mon, 20 May 2013 12:04:17 +0530
Subject: [PATCH 138/172] Fixing a few style issues as pointed in the INSP

---
 db/extmap.c           |  4 ----
 layout/composite.c    | 10 ++++------
 layout/composite.h    | 13 ++++++-------
 layout/ut/composite.c |  3 ++-
 4 files changed, 12 insertions(+), 18 deletions(-)

diff --git a/db/extmap.c b/db/extmap.c
index 7b4aecd..1b95afa 100644
--- a/db/extmap.c
+++ b/db/extmap.c
@@ -17,10 +17,6 @@
  * Original creation date: 08/13/2010
  */
 
-#if 0
-#include <stdio.h>       /* printf */
-#endif
-
 #include "lib/vec.h"
 #include "lib/errno.h"
 #include "lib/arith.h"   /* M0_3WAY */
diff --git a/layout/composite.c b/layout/composite.c
index d5b27e1..131b17f 100644
--- a/layout/composite.c
+++ b/layout/composite.c
@@ -27,7 +27,6 @@
 #include "lib/memory.h" /* M0_ALLOC_PTR() */
 #include "lib/misc.h"   /* M0_IN() */
 #include "lib/vec.h"    /* m0_bufvec_cursor_step(), m0_bufvec_cursor_addr() */
-#include "lib/thread.h" /* LAMBDA */
 #include "lib/bob.h"
 #include "lib/finject.h"
 
@@ -1418,7 +1417,6 @@ static int ext_inmem_write(struct m0_composite_layout *cl,
 	bool                              is_ultimate_ext_add;
 	struct m0_tl                      extents_copy;
 	int                               rc;
-	int                               rc1;
 
 	M0_PRE(composite_invariant(cl));
 	M0_PRE(!m0_ext_is_empty(ext));
@@ -1593,15 +1591,15 @@ static int ext_inmem_write(struct m0_composite_layout *cl,
 	 * has been handled above, let's add the ultimate whole extent.
 	 */
 	if (rc == 0 && is_ultimate_ext_add) {
-		rc1 = ext_inmem_find(layer, ext, new_ext_state, &lr_ext);
-		M0_ASSERT(rc1 == -ENOENT);
+		M0_ASSERT(ext_inmem_find(layer, ext, new_ext_state, &lr_ext) ==
+			  -ENOENT);
 		rc = ext_inmem_add(layer, ext, new_ext_state);
 	}
 
 	if (rc == 0) {
 		/* The extent has to be present in the list, at this time. */
-		rc1 = ext_inmem_find(layer, ext, new_ext_state, &lr_ext);
-		M0_POST(rc1 == 0);
+		M0_POST(ext_inmem_find(layer, ext, new_ext_state, &lr_ext) ==
+		        0);
 		extlist_free(&extents_copy, EXTLIST_FINI);
 	} else {
 		/* Restore the original extent list. */
diff --git a/layout/composite.h b/layout/composite.h
index 16e9753..f7a7815 100644
--- a/layout/composite.h
+++ b/layout/composite.h
@@ -281,10 +281,9 @@ M0_INTERNAL int m0_composite_layer_add(struct m0_composite_layout *cl,
  * layer is not the zeroth one' and that 'the top-most layer does not contain
  * any non-hole extents'.
  *
- * @pre M0_PRE(cl->cl_layers_nr > 1),
- *      M0_PRE(m0_tl_forall(m0_composite_layer_ext, lr_ext,
- *                          &layer->clr_extents,
- *                          lr_ext->cle_state == M0_CLRES_HOLE));
+ * @pre cl->cl_layers_nr > 1
+ * @pre m0_tl_forall(m0_composite_layer_ext, lr_ext, &layer->clr_extents,
+ *                   lr_ext->cle_state == M0_CLRES_HOLE));
  *
  * @post A reference has been released from the sublayout associated with the
  *       top-most layer.
@@ -292,7 +291,7 @@ M0_INTERNAL int m0_composite_layer_add(struct m0_composite_layout *cl,
  * @note When this layer gets deleted from the DB version of the layout (through
  *       the DB update made through the m0_layout_add() or
  *       the m0_layout_update() API), user count for the sublayout is
- *       deccremented by one.
+ *       decremented by one.
  *
  * @note After this API has been used, the user needs to explicitly invoke
  *       m0_layout_update() API so as to update the DB version of the layout.
@@ -343,8 +342,8 @@ M0_INTERNAL int m0_composite_layer_ext_lookup(
  * M0_CLRES_HOLE or with the state same as ext_state. If this criterion is
  * not satisfied, the error -EINVAL is returned.
  *
- * @pre M0_PRE(M0_IN(ext_state, (M0_CLRES_HOLE, M0_CLRES_VALID,
- *                               M0_CLRES_FLATTENING)));
+ * @pre M0_IN(ext_state, (M0_CLRES_HOLE, M0_CLRES_VALID, M0_CLRES_FLATTENING))
+ *
  * @todo Adding an extent with the M0_CLRES_HOLE state, in fact means deleting
  * the extent which could be performed using m0_composite_layer_ext_del() as
  * well. So, shall we continue to support ext_state = M0_CLRES_VALID here?
diff --git a/layout/ut/composite.c b/layout/ut/composite.c
index c6a8e65..a30a71a 100644
--- a/layout/ut/composite.c
+++ b/layout/ut/composite.c
@@ -1873,7 +1873,8 @@ int test_ext_lookup_depth(uint64_t lid,
 		M0_UT_ASSERT(rc == 0);
 
 		rc = m0_composite_layer_ext_lookup(cl, offset_to_operate,
-						   &ext_lookup, &layer_id_lookup,
+						   &ext_lookup,
+						   &layer_id_lookup,
 						   &ext_state_lookup,
 						   &sublayout_lookup);
 		if (i > 0) {
-- 
1.8.3.2

