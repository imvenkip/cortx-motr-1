From 589054f61abb44b8b813f47305de3347e1b6ed94 Mon Sep 17 00:00:00 2001
From: "trupti.patil" <trupti_patil@xyratex.com>
Date: Tue, 28 May 2013 16:02:53 +0530
Subject: [PATCH 150/172] Miscellaneous fixes pointed by the INSP

---
 layout/composite.c    | 76 +++++++++++++++++++--------------------------------
 layout/ut/composite.c | 25 ++++++-----------
 2 files changed, 36 insertions(+), 65 deletions(-)

diff --git a/layout/composite.c b/layout/composite.c
index 56efee0..ff20e5b 100644
--- a/layout/composite.c
+++ b/layout/composite.c
@@ -1039,8 +1039,7 @@ static int ext_find(struct m0_composite_layer *layer,
 	m0_tl_for(ext, &layer->clr_extents, lr_ext) {
 		if (lr_ext->cle_ext.e_end <= ext->e_start)
 			continue;
-		else if (lr_ext->cle_ext.e_start == ext->e_start &&
-			 lr_ext->cle_ext.e_end == ext->e_end) {
+		else if (m0_ext_equal(&lr_ext->cle_ext, ext)) {
 			ext_encountered = true;
 			break;
 		}
@@ -1333,7 +1332,7 @@ static int ext_paste(struct m0_composite_layout *cl,
 		     struct m0_composite_layer *layer,
 		     const struct m0_ext *ext,
 		     enum m0_composite_layer_ext_state new_ext_state,
-		     struct m0_composite_layer_extent *lr_ext_to_insert_into)
+		     struct m0_composite_layer_extent *target)
 {
 	struct preallocated_extents       prealloc;
 	struct m0_composite_layer_extent *lr_ext;
@@ -1347,7 +1346,7 @@ static int ext_paste(struct m0_composite_layout *cl,
 	uint32_t                          j;
 	int                               rc = 0;
 
-	chunk = &lr_ext_to_insert_into->cle_ext;
+	chunk = &target->cle_ext;
 	M0_PRE(m0_ext_is_in(chunk, ext->e_start));
 
 	/*
@@ -1375,7 +1374,7 @@ static int ext_paste(struct m0_composite_layout *cl,
 	prealloc.max_used = 0;
 
 	is_ultimate_ext_add = false;
-	prev = ext_tlist_prev(&layer->clr_extents, lr_ext_to_insert_into);
+	prev = ext_tlist_prev(&layer->clr_extents, target);
 	while (!m0_ext_is_empty(&ext0)) {
 		m0_bcount_t    length[3];
 		uint64_t       bstart[3] = { 0 };
@@ -1401,7 +1400,7 @@ static int ext_paste(struct m0_composite_layout *cl,
 		length[2] = chunk->e_end - clip.e_end;
 
 		/* Original ext state. */
-		bstart[0] = bstart[2] = lr_ext_to_insert_into->cle_state;
+		bstart[0] = bstart[2] = target->cle_state;
 		/* New ext state. */
 		bstart[1] = new_ext_state;
 
@@ -1411,7 +1410,7 @@ static int ext_paste(struct m0_composite_layout *cl,
 		if (length[0] == 0 && length[2] == 0) {
 			split_required = false;
 			delete_required = true;
-			lr_ext_to_del = lr_ext_to_insert_into;
+			lr_ext_to_del = target;
 			if (length[1] != 0) {
 				M0_ASSERT(length[1] == m0_ext_length(ext));
 				is_ultimate_ext_add = true;
@@ -1419,15 +1418,13 @@ static int ext_paste(struct m0_composite_layout *cl,
 		}
 
 		/*
-		 * ext_split() may replace the current node, that is
-		 * lr_ext_to_insert_into, with multiple smaller segments. Hence,
-		 * store the next node before invoking ext_split().
+		 * ext_split() may replace the current node, that is target,
+		 * with multiple smaller segments. Hence, store the next node
+		 * before invoking ext_split().
 		 */
-		lr_ext_next = ext_tlist_next(&layer->clr_extents,
-					     lr_ext_to_insert_into);
+		lr_ext_next = ext_tlist_next(&layer->clr_extents, target);
 		if (split_required) {
-			ext_split(layer, lr_ext_to_insert_into, &vec,
-				  length[0] > 0 ?
+			ext_split(layer, target, &vec, length[0] > 0 ?
 				  chunk->e_start : ext->e_start, &prealloc);
 		}
 		if (delete_required)
@@ -1437,13 +1434,13 @@ static int ext_paste(struct m0_composite_layout *cl,
 		M0_ASSERT(ext0.e_start <= ext0.e_end);
 		if (!m0_ext_is_empty(&ext0)) {
 			/*
-			 * If ext0 is not yet empty, lr_ext_to_insert_into
-			 * should not be the last element of the list.
+			 * If ext0 is not yet empty, target should not be the
+			 * last element of the list.
 			 */
 			M0_ASSERT(lr_ext_next != NULL);
 
-			lr_ext_to_insert_into = lr_ext_next;
-			chunk = &lr_ext_to_insert_into->cle_ext;
+			target = lr_ext_next;
+			chunk = &target->cle_ext;
 		}
 	}
 	M0_ASSERT(m0_ext_is_empty(&ext0));
@@ -1498,8 +1495,7 @@ static int ext_write(struct m0_composite_layout *cl,
 		     uint32_t ext_validation_kind)
 {
 	uint64_t                          lid;
-	struct m0_composite_layer_extent *lr_ext;
-	struct m0_composite_layer_extent *lr_ext_to_insert_into;
+	struct m0_composite_layer_extent *target;
 	int                               rc;
 
 	M0_PRE(composite_invariant(cl));
@@ -1508,45 +1504,29 @@ static int ext_write(struct m0_composite_layout *cl,
 	lid = cl->cl_base.l_id;
 	/* Validate the 'ext' and find the nearest extent from the list. */
 	rc = ext_validate(cl, layer, ext, new_ext_state, ext_validation_kind,
-			  &lr_ext_to_insert_into);
+			  &target);
 	if (rc != 0)
 		return rc;
-	M0_ASSERT(lr_ext_to_insert_into != NULL);
+	M0_ASSERT(target != NULL);
 
 	M0_ENTRY("lid %llu, layer %lu, e_start %llu, e_end %llu, e_state %llu "
-		 "lr_ext_to_insert_into_start %llu, "
-		 "lr_ext_to_insert_into_end %llu",
+		 "target_start %llu, target_end %llu",
 		 (unsigned long long)layer->clr_cl->l_id,
 		 (unsigned long)layer->clr_idx,
 		 (unsigned long long)ext->e_start,
 		 (unsigned long long)ext->e_end,
 		 (unsigned long long)new_ext_state,
-		 (unsigned long long)lr_ext_to_insert_into->cle_ext.e_start,
-		 (unsigned long long)lr_ext_to_insert_into->cle_ext.e_end);
-	if (lr_ext_to_insert_into->cle_ext.e_start == ext->e_start &&
-	    lr_ext_to_insert_into->cle_ext.e_end == ext->e_end &&
-	    lr_ext_to_insert_into->cle_state == new_ext_state) {
-		/* The exact extent already exists. So, nothing to be done. */
-		rc = 0;
-		M0_LEAVE("lid %llu, layer %lu, rc %d", (unsigned long long)lid,
-			 (unsigned long)layer->clr_idx, rc);
-		return rc;
+		 (unsigned long long)target->cle_ext.e_start,
+		 (unsigned long long)target->cle_ext.e_end);
+	if (m0_ext_equal(&target->cle_ext, ext)) {
+		target->cle_state = new_ext_state;
+		M0_LEAVE("lid %llu, layer %lu, rc 0", (unsigned long long)lid,
+			 (unsigned long)layer->clr_idx);
+		return 0;
 	}
-	if (lr_ext_to_insert_into->cle_ext.e_start == ext->e_start &&
-	    lr_ext_to_insert_into->cle_ext.e_end == ext->e_end &&
-	    lr_ext_to_insert_into->cle_state != new_ext_state) {
-		/* The exact extent already exists but with different state. */
-		lr_ext_to_insert_into->cle_state = new_ext_state;
-		rc = 0;
-		M0_LEAVE("lid %llu, layer %lu, rc %d", (unsigned long long)lid,
-			 (unsigned long)layer->clr_idx, rc);
-		return rc;
-	}
-
-	rc = ext_paste(cl, layer, ext, new_ext_state, lr_ext_to_insert_into);
+	rc = ext_paste(cl, layer, ext, new_ext_state, target);
 	/* In case of success, the extent has to be present in the list. */
-	M0_POST(ergo(rc == 0,
-		     ext_find(layer, ext, new_ext_state, &lr_ext) == 0));
+	M0_POST(ergo(rc == 0, ext_find(layer, ext, new_ext_state, NULL) == 0));
 	M0_POST(composite_invariant(cl));
 	M0_LEAVE("lid %llu, layer %lu, rc %d", (unsigned long long)lid,
 		 (unsigned long)layer->clr_idx, rc);
diff --git a/layout/ut/composite.c b/layout/ut/composite.c
index 587f0aa..904676c 100644
--- a/layout/ut/composite.c
+++ b/layout/ut/composite.c
@@ -942,15 +942,12 @@ static void composite_layout_buf_compare(struct m0_bufvec_cursor *cur1,
 			ext2 = m0_bufvec_cursor_addr(cur2);
 			m0_bufvec_cursor_move(cur1, sizeof *ext1);
 			m0_bufvec_cursor_move(cur2, sizeof *ext2);
-
-			M0_UT_ASSERT(ext1->e_start == ext2->e_start);
-			M0_UT_ASSERT(ext1->e_end == ext2->e_end);
+			M0_UT_ASSERT(m0_ext_equal(ext1, ext2));
 
 			ext_state1 = m0_bufvec_cursor_addr(cur1);
 			ext_state2 = m0_bufvec_cursor_addr(cur2);
 			m0_bufvec_cursor_move(cur1, sizeof *ext_state1);
 			m0_bufvec_cursor_move(cur2, sizeof *ext_state2);
-
 			M0_UT_ASSERT(*ext_state1 == *ext_state2);
 		}
 	}
@@ -1077,10 +1074,8 @@ static void composite_layout_compare(const struct m0_layout *l1,
 		M0_UT_ASSERT(layer1->clr_extents_nr == layer2->clr_extents_nr);
 		lr_ext2 = ext_tlist_head(&layer2->clr_extents);
 		m0_tl_for(ext, &layer1->clr_extents, lr_ext1) {
-			M0_UT_ASSERT(lr_ext1->cle_ext.e_start ==
-				     lr_ext2->cle_ext.e_start);
-			M0_UT_ASSERT(lr_ext1->cle_ext.e_end ==
-				     lr_ext2->cle_ext.e_end);
+			M0_UT_ASSERT(m0_ext_equal(&lr_ext1->cle_ext,
+						  &lr_ext2->cle_ext));
 			M0_UT_ASSERT(lr_ext1->cle_state == lr_ext2->cle_state);
 			lr_ext2 = ext_tlist_next(&layer2->clr_extents, lr_ext2);
 		} m0_tl_endfor;
@@ -1576,12 +1571,9 @@ static int ext_op_pre(enum extent_operation eop,
 		}
 	} else {
 		M0_UT_ASSERT(rc_tmp == 0);
-		if (extent_kind == EXACT_EXISTING) {
-			//todo use m0_ext_equal()
-			M0_UT_ASSERT(ext_to_operate->e_start ==
-				     ext_lookup.e_start &&
-				     ext_to_operate->e_end == ext_lookup.e_end);
-		} else {
+		if (extent_kind == EXACT_EXISTING)
+			M0_UT_ASSERT(m0_ext_equal(ext_to_operate, &ext_lookup));
+		else {
 			M0_UT_ASSERT(ext_lookup.e_start <= *offset_to_operate);
 			M0_UT_ASSERT(ext_lookup.e_end > *offset_to_operate);
 		}
@@ -1856,9 +1848,8 @@ int test_ext_lookup_depth(uint64_t lid,
 						   &ext_state_lookup, &layer);
 		if (i > 0) {
 			M0_UT_ASSERT(rc == 0);
-			M0_UT_ASSERT(ext_to_operate.e_start ==
-				     ext_lookup.e_start &&
-				     ext_to_operate.e_end == ext_lookup.e_end);
+			M0_UT_ASSERT(m0_ext_equal(&ext_to_operate,
+						  &ext_lookup));
 			M0_UT_ASSERT(ext_state_lookup == M0_CLRES_VALID);
 			M0_UT_ASSERT(layer->clr_idx == i - 1);
 			M0_UT_ASSERT(layer->clr_sl->l_id ==
-- 
1.8.3.2

