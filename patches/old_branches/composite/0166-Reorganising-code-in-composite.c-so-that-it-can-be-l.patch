From 0f311d8f5b9fef60a2014e270789e130e955119a Mon Sep 17 00:00:00 2001
From: "trupti.patil" <trupti_patil@xyratex.com>
Date: Fri, 2 Aug 2013 18:07:23 +0530
Subject: [PATCH 166/172] Reorganising code in composite.c so that it can be
 logically followed

---
 layout/composite.c | 1099 +++++++++++++++++++++++++++-------------------------
 1 file changed, 576 insertions(+), 523 deletions(-)

diff --git a/layout/composite.c b/layout/composite.c
index ce9fe44..5b11fc4 100644
--- a/layout/composite.c
+++ b/layout/composite.c
@@ -630,68 +630,52 @@ err_injected:
 	return sublayout;
 }
 
-/**
- * Reads the sublayout identifiers for all the layers for a composite layout,
- * from a buffer provided and stores those in the sl_id_list array.
- *
- * Sublayout identifiers for all the layers are stored in the primary table.
- *
- * @post Memory is allocated for the array sl_list and it shall be freed by
- * the caller.
- */
-static int sublayout_ids_read(struct m0_composite_layout *cl,
-			      struct m0_bufvec_cursor *cur,
-			      uint32_t *layers_nr,
-			      uint64_t **sl_list)
-{
-	struct m0_layout_composite_rec *cl_rec;
-	uint64_t                       *sl_id_list;
-	uint64_t                       *sublayout_id;
-	uint32_t                        i;
-
-	M0_PRE(cur != NULL);
-	M0_PRE(m0_bufvec_cursor_step(cur) >= sizeof *cl_rec);
-
-	M0_ENTRY("lid %llu", (unsigned long long)cl->cl_base.l_id);
-	/*
-	 * Read the composite layout type specific part of the record from the
-	 * buffer.
-	 */
-	cl_rec = m0_bufvec_cursor_addr(cur);
-	m0_bufvec_cursor_move(cur, sizeof *cl_rec);
-	*layers_nr = cl_rec->cr_layers_nr;
-
-	M0_ALLOC_ARR(sl_id_list, *layers_nr);
-	if (sl_id_list == NULL) {
-		m0_layout__log("sublayout_ids_read",
-			       "failed to allocate sl_id_list",
-			       M0_LAYOUT_ADDB_LOC_COMP_SUBLAYOUT_READ,
-			       &cl->cl_base.l_addb_ctx, cl->cl_base.l_id,
-			       -ENOMEM);
-		M0_RETURN(-ENOMEM);
-	}
-
-	/* Read the sublayout ids from the buffer. */
-	M0_ASSERT(m0_bufvec_cursor_step(cur) >=
-		  *layers_nr * sizeof sl_id_list[0]);
-	for (i = 0; i < cl_rec->cr_layers_nr; ++i) {
-		sublayout_id = m0_bufvec_cursor_addr(cur);
-		m0_bufvec_cursor_move(cur, sizeof *sublayout_id);
-		sl_id_list[i] = *sublayout_id;
-	}
-	*sl_list = sl_id_list;
-	M0_POST(*layers_nr > 0);
-	M0_RETURN(0);
-}
-
-static void ext_del(struct m0_composite_layer *layer,
-		    struct m0_composite_layer_ext *ext);
+static int composite_copy_from_onwire(struct m0_composite_layout *cl,
+				      const struct m0_composite_onwire *onwire);
+static int copy_extents_from_onwire(struct m0_layer_onwire *lr_onwire,
+				    struct m0_composite_layer *lr);
+static int composite_copy_to_onwire(struct m0_composite_layout *cl,
+				    struct m0_composite_onwire **cl_onwire);
 static int ext_add(struct m0_tl *extlist,
 		   struct m0_layout *l,
 		   const struct m0_ext *e,
 		   enum m0_composite_layer_ext_state state,
 		   uint32_t add_position,
 		   struct m0_composite_layer_ext *adjacent);
+static void ext_add_internal(struct m0_tl *extlist,
+			     struct m0_layout *l,
+			     const struct m0_ext *e,
+			     enum m0_composite_layer_ext_state state,
+			     uint32_t add_position,
+			     struct m0_composite_layer_ext *adjacent,
+			     struct m0_composite_layer_ext *ext);
+static void ext_del(struct m0_composite_layer *layer,
+		    struct m0_composite_layer_ext *ext);
+static void single_ext_del(struct m0_composite_layer *lr);
+static int ext_write(struct m0_composite_layout *cl,
+		     struct m0_composite_layer *layer,
+		     const struct m0_ext *e,
+		     enum m0_composite_layer_ext_state new_state);
+static int ext_paste(struct m0_composite_layout *cl,
+		     struct m0_composite_layer *layer,
+		     const struct m0_ext *e,
+		     enum m0_composite_layer_ext_state new_state,
+		     struct m0_composite_layer_ext *target);
+static int ext_merge(struct m0_composite_layout *cl,
+		     struct m0_composite_layer *layer,
+		     const struct m0_ext *e,
+		     enum m0_composite_layer_ext_state state);
+static void merge(struct m0_composite_layer *layer,
+		  struct m0_composite_layer_ext *ext1,
+		  struct m0_composite_layer_ext *ext2);
+static void ext_split(struct m0_composite_layer *layer,
+		      struct m0_composite_layer_ext *ext,
+		      struct m0_indexvec *vec,
+		      m0_bindex_t scan,
+		      struct preallocated_extents *prealloc);
+static struct m0_composite_layer *layer_find(
+					const struct m0_composite_layout *cl,
+					uint32_t layer_idx);
 
 /*
  * Layout DB related functions are defined towards the end of this file.
@@ -704,123 +688,77 @@ static int layers_indb_delete(struct m0_composite_layout *cl,
 static int extents_indb_read(struct m0_composite_layout *cl,
 			     struct m0_composite_layer *layer,
 			     struct m0_db_tx *tx);
-
-/** Reads layers from the DB. */
+static int sublayout_ids_read(struct m0_composite_layout *cl,
+			      struct m0_bufvec_cursor *cur,
+			      uint32_t *layers_nr,
+			      uint64_t **sl_list);
 static int layers_indb_read(struct m0_composite_layout *cl,
 			    struct m0_db_tx *tx,
 			    uint32_t user_count,
 			    uint32_t layers_nr,
-			    uint64_t *sl_id_list)
+			    uint64_t *sl_id_list);
+
+/** Implementation of lo_decode() for composite layout type. */
+static int composite_decode(struct m0_layout *l,
+			    struct m0_bufvec_cursor *cur,
+			    enum m0_layout_xcode_op op,
+			    struct m0_db_tx *tx,
+			    uint32_t user_count)
 {
-	struct m0_layout          *sublayout;
-	struct m0_composite_layer *layer;
-	bool                       populate_done = false;
-	uint32_t                   i;
-	int                        rc = 0;
+	struct m0_composite_layout *cl;
+	struct m0_composite_onwire *onwire;
+	struct m0_xcode_ctx         ctx;
+	uint32_t                    layers_nr;
+	uint64_t                   *sl_id_list;
+	int                         rc;
 
-	M0_PRE(m0_layout__allocated_invariant(&cl->cl_base));
-	M0_PRE(m0_mutex_is_locked(&cl->cl_base.l_lock));
+	M0_PRE(m0_layout__allocated_invariant(l));
+	M0_PRE(m0_mutex_is_locked(&l->l_lock));
+	M0_PRE(cur != NULL);
+	M0_PRE(M0_IN(op, (M0_LXO_DB_LOOKUP, M0_LXO_BUFFER_OP)));
+	M0_PRE(ergo(op == M0_LXO_DB_LOOKUP, tx != NULL));
+
+	M0_ENTRY("lid %llu", (unsigned long long)l->l_id);
+	cl = bob_of(l, struct m0_composite_layout, cl_base, &composite_bob);
 	M0_PRE(cl->cl_layers_nr == 0);
 	M0_PRE(layers_tlist_is_empty(&cl->cl_layers));
-	M0_PRE(tx != NULL);
 
-	M0_ENTRY("lid %llu, user_count %lu, layers_nr %lu",
-		 (unsigned long long)cl->cl_base.l_id,
-		 (unsigned long)user_count, (unsigned long)layers_nr);
-	for (i = 0; i < layers_nr; ++i) {
-		sublayout = layout_find(cl->cl_base.l_dom, sl_id_list[i]);
-		if (sublayout == NULL) {
-			rc = -EINVAL;
-			M0_LOG(M0_ERROR, "lid %llu, layer %lu, sublayout with "
-			       "lid %llu does not exist",
-			       (unsigned long long)cl->cl_base.l_id,
-			       (unsigned long)i,
-			       (unsigned long long)sl_id_list[i]);
-			break;
-		}
-		if (i == 0) { /* Zeroth layer */
-			rc = composite_populate(cl, sublayout, user_count);
-			if (rc == 0) {
-				layer = layers_tlist_head(&cl->cl_layers);
-				populate_done = true;
-			}
+	if (op == M0_LXO_BUFFER_OP) {
+		m0_xcode_ctx_init(&ctx, &COMPOSITE_XCODE_OBJ(NULL));
+		ctx.xcx_buf = *cur;
+		ctx.xcx_alloc = m0_xcode_alloc;
+		rc = m0_xcode_decode(&ctx);
+		if (rc == 0) {
+			onwire = m0_xcode_ctx_top(&ctx);
+			rc = composite_copy_from_onwire(cl, onwire);
+			m0_xcode_free(&COMPOSITE_XCODE_OBJ(onwire));
 		} else
-			rc = layer_add(cl, sublayout, &layer);
+			m0_layout__log("composite_decode",
+				       "m0_xcode_decode() failed",
+				       M0_LAYOUT_ADDB_LOC_COMP_DECODE,
+				       &l->l_addb_ctx, l->l_id, rc);
+	} else {
 		/*
-		 * Release the reference added by m0_layout_find(). In case of
-		 * success, layer_add() has added a reference on this
-		 * sublayout.
+		 * Read the composite layout type specific part of the record
+		 * from the buffer as read from the primary table.
 		 */
-		m0_layout_put(sublayout);
-
+		rc = sublayout_ids_read(cl, cur, &layers_nr, &sl_id_list);
 		if (rc == 0) {
-			rc = extents_indb_read(cl, layer, tx);
-			if (rc != 0) {
-				M0_LOG(M0_ERROR, "lid %llu, layer %lu, Error "
-				       "while reading extent list",
-				       (unsigned long long)cl->cl_base.l_id,
-				       (unsigned long)i);
-				break;
-			}
+			rc = layers_indb_read(cl, tx, user_count, layers_nr,
+					      sl_id_list);
+			m0_free(sl_id_list);
 		} else
-			break;
-	}
-	if (rc != 0) {
-		/*
-		 * Undo the layer addition and the layout population done
-		 * through the earlier iterations of the loop above.
-		 */
-		layers_inmem_delete(cl);
-		if (populate_done)
-			composite_populate_reverse(cl);
-		M0_POST(m0_layout__allocated_invariant(&cl->cl_base));
+			M0_LOG(M0_ERROR, "lid %llu, failed to read sublayout "
+			       "id list from the buffer",
+			       (unsigned long long)cl->cl_base.l_id);
 	}
-	M0_POST(ergo(rc == 0, composite_invariant(cl) &&
-		     cl->cl_layers_nr > 0));
+	M0_POST(ergo(rc == 0, composite_invariant(cl)));
 	M0_POST(ergo(rc != 0, m0_layout__allocated_invariant(&cl->cl_base) &&
 		     cl->cl_layers_nr == 0));
 	M0_POST(m0_mutex_is_locked(&cl->cl_base.l_lock));
 	M0_RETURN(rc);
 }
 
-/**
- * Deletes the single extent added by default when the layer got added.
- */
-static void single_ext_del(struct m0_composite_layer *lr)
-{
-	struct m0_composite_layer_ext *ext;
-
-	ext = ext_tlist_head(&lr->clr_extents);
-	M0_ASSERT(ext->cle_ext.e_start == 0 &&
-		  ext->cle_ext.e_end == M0_BINDEX_MAX + 1);
-	ext_del(lr, ext);
-}
-
-static int copy_extents_from_onwire(struct m0_layer_onwire *lr_onwire,
-				    struct m0_composite_layer *lr)
-{
-	struct m0_ext                  e;
-	struct m0_layer_ext_onwire    *ext_onwire;
-	m0_bindex_t                    scan = 0;
-	uint32_t                       i;
-	int                            rc;
-
-	M0_ENTRY();
-	single_ext_del(lr);
-	for (i = 0; i < lr_onwire->lro_extents.lea_nr; ++i) {
-		ext_onwire = &lr_onwire->lro_extents.lea_ext[i];
-		e.e_start = scan;
-		e.e_end = ext_onwire->leo_end;
-		scan = ext_onwire->leo_end;
-		rc = ext_add(&lr->clr_extents, lr->clr_cl, &e,
-			     ext_onwire->leo_state, ADD_AT_TAIL, NULL);
-		if (rc != 0)
-			break;
-	}
-	lr->clr_extents_nr = ext_tlist_length(&lr->clr_extents);
-	M0_RETURN(rc);
-}
-
 static int composite_copy_from_onwire(struct m0_composite_layout *cl,
 				      const struct m0_composite_onwire *onwire)
 {
@@ -890,118 +828,112 @@ static int composite_copy_from_onwire(struct m0_composite_layout *cl,
 	M0_RETURN(rc);
 }
 
-/** Implementation of lo_decode() for composite layout type. */
-static int composite_decode(struct m0_layout *l,
-			    struct m0_bufvec_cursor *cur,
-			    enum m0_layout_xcode_op op,
-			    struct m0_db_tx *tx,
-			    uint32_t user_count)
+static int copy_extents_from_onwire(struct m0_layer_onwire *lr_onwire,
+				    struct m0_composite_layer *lr)
 {
-	struct m0_composite_layout *cl;
-	struct m0_composite_onwire *onwire;
-	struct m0_xcode_ctx         ctx;
-	uint32_t                    layers_nr;
-	uint64_t                   *sl_id_list;
-	int                         rc;
-
-	M0_PRE(m0_layout__allocated_invariant(l));
-	M0_PRE(m0_mutex_is_locked(&l->l_lock));
-	M0_PRE(cur != NULL);
-	M0_PRE(M0_IN(op, (M0_LXO_DB_LOOKUP, M0_LXO_BUFFER_OP)));
-	M0_PRE(ergo(op == M0_LXO_DB_LOOKUP, tx != NULL));
-
-	M0_ENTRY("lid %llu", (unsigned long long)l->l_id);
-	cl = bob_of(l, struct m0_composite_layout, cl_base, &composite_bob);
-	M0_PRE(cl->cl_layers_nr == 0);
-	M0_PRE(layers_tlist_is_empty(&cl->cl_layers));
+	struct m0_ext                  e;
+	struct m0_layer_ext_onwire    *ext_onwire;
+	m0_bindex_t                    scan = 0;
+	uint32_t                       i;
+	int                            rc;
 
-	if (op == M0_LXO_BUFFER_OP) {
-		m0_xcode_ctx_init(&ctx, &COMPOSITE_XCODE_OBJ(NULL));
-		ctx.xcx_buf = *cur;
-		ctx.xcx_alloc = m0_xcode_alloc;
-		rc = m0_xcode_decode(&ctx);
-		if (rc == 0) {
-			onwire = m0_xcode_ctx_top(&ctx);
-			rc = composite_copy_from_onwire(cl, onwire);
-			m0_xcode_free(&COMPOSITE_XCODE_OBJ(onwire));
-		} else
-			m0_layout__log("composite_decode",
-				       "m0_xcode_decode() failed",
-				       M0_LAYOUT_ADDB_LOC_COMP_DECODE,
-				       &l->l_addb_ctx, l->l_id, rc);
-	} else {
-		rc = sublayout_ids_read(cl, cur, &layers_nr, &sl_id_list);
-		if (rc == 0) {
-			/* Read layers either from the DB. */
-			rc = layers_indb_read(cl, tx, user_count, layers_nr,
-					      sl_id_list);
-			m0_free(sl_id_list);
-		} else
-			M0_LOG(M0_ERROR, "lid %llu, failed to read sublayout "
-			       "id list from the buffer",
-			       (unsigned long long)cl->cl_base.l_id);
+	M0_ENTRY();
+	single_ext_del(lr);
+	for (i = 0; i < lr_onwire->lro_extents.lea_nr; ++i) {
+		ext_onwire = &lr_onwire->lro_extents.lea_ext[i];
+		e.e_start = scan;
+		e.e_end = ext_onwire->leo_end;
+		scan = ext_onwire->leo_end;
+		rc = ext_add(&lr->clr_extents, lr->clr_cl, &e,
+			     ext_onwire->leo_state, ADD_AT_TAIL, NULL);
+		if (rc != 0)
+			break;
 	}
-	M0_POST(ergo(rc == 0, composite_invariant(cl)));
-	M0_POST(ergo(rc != 0, m0_layout__allocated_invariant(&cl->cl_base) &&
-		     cl->cl_layers_nr == 0));
-	M0_POST(m0_mutex_is_locked(&cl->cl_base.l_lock));
+	lr->clr_extents_nr = ext_tlist_length(&lr->clr_extents);
 	M0_RETURN(rc);
 }
 
-/** Copies fields from in-memory structure to the onwire structure. */
-static int composite_copy_to_onwire(struct m0_composite_layout *cl,
-				    struct m0_composite_onwire **cl_onwire)
+/** Deletes the single extent added by default when the layer got added. */
+static void single_ext_del(struct m0_composite_layer *lr)
 {
-	struct m0_layout              *l = &cl->cl_base;
-	struct m0_composite_layer     *layer;
-	struct m0_composite_layer_ext *ext1;
-	struct m0_composite_onwire    *onwire;
-	struct m0_layer_onwire        *lr_onwire;
-	struct m0_layer_ext_onwire    *ext_onwire;
-	uint32_t                       i;
-	int                            rc = 0;
+	struct m0_composite_layer_ext *ext;
 
-	M0_ENTRY("lid %llu", (unsigned long long)l->l_id);
-	M0_ALLOC_PTR(onwire);
-	if (onwire != NULL) {
-		M0_ALLOC_ARR(onwire->co_layers.lra_layer, cl->cl_layers_nr);
-		if (onwire->co_layers.lra_layer == NULL)
-			rc = -ENOMEM;
-	} else
-		rc = -ENOMEM;
-	if (rc == -ENOMEM)
-		goto out;
+	ext = ext_tlist_head(&lr->clr_extents);
+	M0_ASSERT(ext->cle_ext.e_start == 0 &&
+		  ext->cle_ext.e_end == M0_BINDEX_MAX + 1);
+	ext_del(lr, ext);
+}
 
-	m0_layout__copy_to_onwire(&cl->cl_base, &onwire->co_base);
-	m0_tl_for(layers, &cl->cl_layers, layer) {
-		lr_onwire = &onwire->co_layers.lra_layer[layer->clr_idx];
-		lr_onwire->lro_idx = layer->clr_idx;
-		lr_onwire->lro_sublayout_id = layer->clr_sl->l_id;
-		M0_ALLOC_ARR(lr_onwire->lro_extents.lea_ext,
-			     layer->clr_extents_nr);
-		if(lr_onwire->lro_extents.lea_ext == NULL) {
-			rc = -ENOMEM;
-			goto out;
-		}
-		i = 0;
-		m0_tl_for(ext, &layer->clr_extents, ext1) {
-			ext_onwire = &lr_onwire->lro_extents.lea_ext[i];
-			ext_onwire->leo_end = ext1->cle_ext.e_end;
-			ext_onwire->leo_state = ext1->cle_state;
-			++i;
-		} m0_tl_endfor;
-		lr_onwire->lro_extents.lea_nr = layer->clr_extents_nr;
-	} m0_tl_endfor;
-	onwire->co_layers.lra_nr = cl->cl_layers_nr;
-	*cl_onwire = onwire;
-out:
-	if (rc != 0) {
-		M0_ASSERT(rc == -ENOMEM);
-		m0_layout__log("composite_copy_to_onwire", "M0_ALLOC() failed",
-			       M0_LAYOUT_ADDB_LOC_COMP_ENC_1,
-			       &l->l_addb_ctx, l->l_id, rc);
+/**
+ * Allocates an extent and adds it to the provided extent list, at the provided  * position.
+ */
+static int ext_add(struct m0_tl *extlist,
+		   struct m0_layout *l,
+		   const struct m0_ext *e,
+		   enum m0_composite_layer_ext_state state,
+		   uint32_t add_position,
+		   struct m0_composite_layer_ext *adjacent)
+{
+	struct m0_composite_layer_ext *ext;
+
+	M0_ALLOC_PTR(ext);
+	if (ext == NULL) {
+		m0_layout__log("ext_add", "failed to allocate composite extent",
+			       M0_LAYOUT_ADDB_LOC_COMP_EXT_ADD_INTERNAL,
+			       &l->l_addb_ctx, l->l_id, -ENOMEM);
+		M0_RETURN(-ENOMEM);
 	}
-	M0_RETURN(rc);
+	ext_add_internal(extlist, l, e, state, add_position,
+			 adjacent, ext);
+	M0_RETURN(0);
+}
+
+/**
+ * Adds an extent to the provided extent list, at the provided position and
+ * using the pre-allocated extent.
+ */
+static void ext_add_internal(struct m0_tl *extlist,
+			     struct m0_layout *l,
+			     const struct m0_ext *e,
+			     enum m0_composite_layer_ext_state state,
+			     uint32_t add_position,
+			     struct m0_composite_layer_ext *adjacent,
+			     struct m0_composite_layer_ext *ext)
+{
+	M0_PRE(extlist != NULL);
+	M0_PRE(m0_layout__invariant(l));
+	M0_PRE(!m0_ext_is_empty(e));
+	M0_PRE(M0_IN(state, (M0_CLRES_HOLE, M0_CLRES_VALID,
+			     M0_CLRES_FLATTENING)));
+	M0_PRE(M0_IN(add_position, (ADD_AFTER, ADD_BEFORE, ADD_AT_START,
+				    ADD_AT_TAIL)));
+	M0_PRE(ergo(M0_IN(add_position, (ADD_AFTER, ADD_BEFORE)),
+		    adjacent != NULL && ext_tlink_is_in(adjacent)));
+	M0_PRE(ergo(M0_IN(add_position, (ADD_AT_START, ADD_AT_TAIL)),
+		    adjacent == NULL));
+	M0_PRE(ext != NULL);
+
+	M0_ENTRY("lid %llu, e_start %llu, e_end %llu, e_state %llu, "
+		 "add_position %lu, adj_ext_start %llu, adj_ext_end %llu",
+		 (unsigned long long)l->l_id, (unsigned long long)e->e_start,
+		 (unsigned long long)e->e_end, (unsigned long long)state,
+		 (unsigned long)add_position,
+		 (adjacent == NULL) ? 0 :
+		 (unsigned long long)adjacent->cle_ext.e_start,
+		 (adjacent == NULL) ? 0 :
+		 (unsigned long long)adjacent->cle_ext.e_end);
+	ext->cle_ext = *e;
+	ext->cle_state = state;
+	if (M0_IN(add_position, (ADD_AFTER, ADD_BEFORE))) {
+		ext_tlink_init(ext);
+		if (add_position == ADD_AFTER)
+			ext_tlist_add_after(adjacent, ext);
+		else
+			ext_tlist_add_before(adjacent, ext);
+	} else if (add_position == ADD_AT_START)
+		ext_tlink_init_at(ext, extlist);
+	else
+		ext_tlink_init_at_tail(ext, extlist);
 }
 
 /** Implementation of lo_encode() for composite layout type. */
@@ -1048,7 +980,7 @@ static int composite_encode(struct m0_layout *l,
 		 * Write the composite layout type specific part of the record
 		 * into the buffer.
 		 */
-		M0_ASSERT(m0_bufvec_cursor_step(out) >= sizeof cl_rec);
+		M0_ASSERT(m0_bufvec_cursor_step(out) >= sizeof cl_rec); //todo
 		cl_rec.cr_layers_nr = cl->cl_layers_nr;
 		cl_rec.cr_pad = 0;
 		nbytes = m0_bufvec_cursor_copyto(out, &cl_rec, sizeof cl_rec);
@@ -1056,12 +988,11 @@ static int composite_encode(struct m0_layout *l,
 
 		/* Write the sublayout identifiers in the buffer. */
 		M0_ASSERT(m0_bufvec_cursor_step(out) >=
-			  cl->cl_layers_nr * sizeof layer->clr_sl->l_id);
+			  cl->cl_layers_nr * sizeof layer->clr_sl->l_id); //todo
 		m0_tl_for(layers, &cl->cl_layers, layer) {
 			nbytes = m0_bufvec_cursor_copyto(out,
-							 &layer->clr_sl->l_id,
-							 sizeof
-							 layer->clr_sl->l_id);
+						&layer->clr_sl->l_id,
+						sizeof layer->clr_sl->l_id);
 			M0_ASSERT(nbytes == sizeof layer->clr_sl->l_id);
 		} m0_tl_endfor;
 		if (op == M0_LXO_DB_ADD) {
@@ -1102,6 +1033,62 @@ static int composite_encode(struct m0_layout *l,
 	M0_RETURN(rc);
 }
 
+/** Copies fields from in-memory structure to the onwire structure. */
+static int composite_copy_to_onwire(struct m0_composite_layout *cl,
+				    struct m0_composite_onwire **cl_onwire)
+{
+	struct m0_layout              *l = &cl->cl_base;
+	struct m0_composite_layer     *layer;
+	struct m0_composite_layer_ext *ext1;
+	struct m0_composite_onwire    *onwire;
+	struct m0_layer_onwire        *lr_onwire;
+	struct m0_layer_ext_onwire    *ext_onwire;
+	uint32_t                       i;
+	int                            rc = 0;
+
+	M0_ENTRY("lid %llu", (unsigned long long)l->l_id);
+	M0_ALLOC_PTR(onwire);
+	if (onwire != NULL) {
+		M0_ALLOC_ARR(onwire->co_layers.lra_layer, cl->cl_layers_nr);
+		if (onwire->co_layers.lra_layer == NULL)
+			rc = -ENOMEM;
+	} else
+		rc = -ENOMEM;
+	if (rc == -ENOMEM)
+		goto out;
+
+	m0_layout__copy_to_onwire(&cl->cl_base, &onwire->co_base);
+	m0_tl_for(layers, &cl->cl_layers, layer) {
+		lr_onwire = &onwire->co_layers.lra_layer[layer->clr_idx];
+		lr_onwire->lro_idx = layer->clr_idx;
+		lr_onwire->lro_sublayout_id = layer->clr_sl->l_id;
+		M0_ALLOC_ARR(lr_onwire->lro_extents.lea_ext,
+			     layer->clr_extents_nr);
+		if(lr_onwire->lro_extents.lea_ext == NULL) {
+			rc = -ENOMEM;
+			goto out;
+		}
+		i = 0;
+		m0_tl_for(ext, &layer->clr_extents, ext1) {
+			ext_onwire = &lr_onwire->lro_extents.lea_ext[i];
+			ext_onwire->leo_end = ext1->cle_ext.e_end;
+			ext_onwire->leo_state = ext1->cle_state;
+			++i;
+		} m0_tl_endfor;
+		lr_onwire->lro_extents.lea_nr = layer->clr_extents_nr;
+	} m0_tl_endfor;
+	onwire->co_layers.lra_nr = cl->cl_layers_nr;
+	*cl_onwire = onwire;
+out:
+	if (rc != 0) {
+		M0_ASSERT(rc == -ENOMEM);
+		m0_layout__log("composite_copy_to_onwire", "M0_ALLOC() failed",
+			       M0_LAYOUT_ADDB_LOC_COMP_ENC_1,
+			       &l->l_addb_ctx, l->l_id, rc);
+	}
+	M0_RETURN(rc);
+}
+
 /**
  * Checks if the exact provided extent with the exact provided state is present
  * in the list of the extents associated with the specified layer.
@@ -1136,79 +1123,7 @@ static int ext_find(struct m0_composite_layer *layer,
 			*ext = ext1;
 		M0_RETURN(0);
 	} else
-		M0_RETURN(-ENOENT);
-}
-
-/**
- * Adds an extent to the provided extent list, at the provided position and
- * using the pre-allocated extent.
- */
-static void ext_add_internal(struct m0_tl *extlist,
-			     struct m0_layout *l,
-			     const struct m0_ext *e,
-			     enum m0_composite_layer_ext_state state,
-			     uint32_t add_position,
-			     struct m0_composite_layer_ext *adjacent,
-			     struct m0_composite_layer_ext *ext)
-{
-	M0_PRE(extlist != NULL);
-	M0_PRE(m0_layout__invariant(l));
-	M0_PRE(!m0_ext_is_empty(e));
-	M0_PRE(M0_IN(state, (M0_CLRES_HOLE, M0_CLRES_VALID,
-			     M0_CLRES_FLATTENING)));
-	M0_PRE(M0_IN(add_position, (ADD_AFTER, ADD_BEFORE, ADD_AT_START,
-				    ADD_AT_TAIL)));
-	M0_PRE(ergo(M0_IN(add_position, (ADD_AFTER, ADD_BEFORE)),
-		    adjacent != NULL && ext_tlink_is_in(adjacent)));
-	M0_PRE(ergo(M0_IN(add_position, (ADD_AT_START, ADD_AT_TAIL)),
-		    adjacent == NULL));
-	M0_PRE(ext != NULL);
-
-	M0_ENTRY("lid %llu, e_start %llu, e_end %llu, e_state %llu, "
-		 "add_position %lu, adj_ext_start %llu, adj_ext_end %llu",
-		 (unsigned long long)l->l_id, (unsigned long long)e->e_start,
-		 (unsigned long long)e->e_end, (unsigned long long)state,
-		 (unsigned long)add_position,
-		 (adjacent == NULL) ? 0 :
-		 (unsigned long long)adjacent->cle_ext.e_start,
-		 (adjacent == NULL) ? 0 :
-		 (unsigned long long)adjacent->cle_ext.e_end);
-	ext->cle_ext = *e;
-	ext->cle_state = state;
-	if (M0_IN(add_position, (ADD_AFTER, ADD_BEFORE))) {
-		ext_tlink_init(ext);
-		if (add_position == ADD_AFTER)
-			ext_tlist_add_after(adjacent, ext);
-		else
-			ext_tlist_add_before(adjacent, ext);
-	} else if (add_position == ADD_AT_START)
-		ext_tlink_init_at(ext, extlist);
-	else
-		ext_tlink_init_at_tail(ext, extlist);
-}
-
-/**
- * Allocates an extent and adds it to the provided extent list, at the provided  * position.
- */
-static int ext_add(struct m0_tl *extlist,
-		   struct m0_layout *l,
-		   const struct m0_ext *e,
-		   enum m0_composite_layer_ext_state state,
-		   uint32_t add_position,
-		   struct m0_composite_layer_ext *adjacent)
-{
-	struct m0_composite_layer_ext *ext;
-
-	M0_ALLOC_PTR(ext);
-	if (ext == NULL) {
-		m0_layout__log("ext_add", "failed to allocate composite extent",
-			       M0_LAYOUT_ADDB_LOC_COMP_EXT_ADD_INTERNAL,
-			       &l->l_addb_ctx, l->l_id, -ENOMEM);
-		M0_RETURN(-ENOMEM);
-	}
-	ext_add_internal(extlist, l, e, state, add_position,
-			 adjacent, ext);
-	M0_RETURN(0);
+		M0_RETURN(-ENOENT);
 }
 
 M0_INTERNAL int m0_composite_layer_ext_lookup(
@@ -1271,60 +1186,108 @@ M0_INTERNAL int m0_composite_layer_ext_lookup(
 	M0_RETURN(rc);
 }
 
-/** Deletes an extent from the extent list associated with the given layer. */
-static void ext_del(struct m0_composite_layer *layer,
-		    struct m0_composite_layer_ext *ext)
+M0_INTERNAL int m0_composite_layer_update(
+				struct m0_composite_layout *cl,
+				uint32_t layer_idx,
+				const struct m0_ext *e,
+				enum m0_composite_layer_ext_state state)
 {
-	M0_LOG(M0_DEBUG, "lid %llu, layer %lu, e_start %llu, e_end %llu, "
-	       "e_state %llu", (unsigned long long)layer->clr_cl->l_id,
-	       (unsigned long)layer->clr_idx,
-	       (unsigned long long)ext->cle_ext.e_start,
-	       (unsigned long long)ext->cle_ext.e_end,
-	       (unsigned long long)ext->cle_state);
-	ext_tlink_del_fini(ext);
-	m0_free(ext);
-	M0_CNT_DEC(layer->clr_extents_nr);
+	struct m0_composite_layer *layer;
+	int                        rc;
+
+	M0_PRE(composite_invariant(cl));
+	M0_PRE(e != NULL);
+	M0_PRE(!m0_ext_is_empty(e));
+	M0_PRE(M0_IN(state, (M0_CLRES_HOLE, M0_CLRES_VALID,
+			     M0_CLRES_FLATTENING)));
+
+	M0_ENTRY("lid %llu, layer %lu, e_start %llu, e_end %llu, e_state %llu",
+		 (unsigned long long)cl->cl_base.l_id,
+		 (unsigned long)layer_idx, (unsigned long long)e->e_start,
+		 (unsigned long long)e->e_end, (unsigned long long)state);
+	m0_mutex_lock(&cl->cl_base.l_lock);
+	layer = layer_find(cl, layer_idx);
+	rc = ext_write(cl, layer, e, state);
+	if (rc != 0)
+		m0_layout__log("m0_composite_layer_update",
+			       "failed to add extent",
+			       M0_LAYOUT_ADDB_LOC_COMP_EXT_ADD,
+			       &cl->cl_base.l_addb_ctx, cl->cl_base.l_id, rc);
+	m0_mutex_unlock(&cl->cl_base.l_lock);
+	M0_POST(composite_invariant(cl));
+	M0_RETURN(rc);
+}
+
+/** Finds a layer with the given layer index. */
+static struct m0_composite_layer *layer_find(
+					const struct m0_composite_layout *cl,
+					uint32_t layer_idx)
+{
+	struct m0_composite_layer *layer;
+
+	M0_PRE(layer_idx < cl->cl_layers_nr);
+
+	m0_tl_for(layers, &cl->cl_layers, layer) {
+		if (layer->clr_idx == layer_idx)
+			break;
+	} m0_tl_endfor;
+	M0_POST(layer_invariant(layer));
+	M0_POST(layer->clr_idx == layer_idx);
+	return layer;
 }
 
 /**
- * Splits an existing extent as requested by using the vec.
- * An extent is asked to be split when some partially overlapping extent is to
- * be added.
+ * Writes an extent with the specified state into 'the in-memory extent list
+ * associated with the specified layer'. It internally deletes or truncates
+ * the overlappping extents as necessary.
  */
-static void ext_split(struct m0_composite_layer *layer,
-		      struct m0_composite_layer_ext *ext,
-		      struct m0_indexvec *vec,
-		      m0_bindex_t scan,
-		      struct preallocated_extents *prealloc)
+static int ext_write(struct m0_composite_layout *cl,
+		     struct m0_composite_layer *layer,
+		     const struct m0_ext *e,
+		     enum m0_composite_layer_ext_state new_state)
 {
-	struct m0_ext e;
-	m0_bcount_t   len;
-	uint32_t      i;
+	uint64_t                       lid;
+	struct m0_composite_layer_ext *ext1;
+	struct m0_composite_layer_ext *nearest;
+	int                            rc;
 
-	M0_PRE(ext_tlink_is_in(ext));
-	M0_PRE(vec->iv_vec.v_nr == 3);
-	M0_PRE(vec->iv_vec.v_count[0] != 0 || vec->iv_vec.v_count[1] != 0 ||
-	       vec->iv_vec.v_count[2] != 0);
+	M0_PRE(composite_invariant(cl));
+	M0_PRE(!m0_ext_is_empty(e));
 
-	M0_ENTRY("lid %llu, len0 %llu, len1 %llu, len2 %llu\n",
-		 (unsigned long long)layer->clr_cl->l_id,
-		 (unsigned long long)vec->iv_vec.v_count[0],
-		 (unsigned long long)vec->iv_vec.v_count[1],
-		 (unsigned long long)vec->iv_vec.v_count[2]);
-	for (i = 0; i < vec->iv_vec.v_nr; ++i) {
-		len = vec->iv_vec.v_count[i];
-		if (len != 0) {
-			e.e_start = scan;
-			e.e_end = scan = scan + len;
-			ext_add_internal(&layer->clr_extents, layer->clr_cl, &e,
-					 vec->iv_index[i], ADD_BEFORE, ext,
-					 prealloc->ext[prealloc->max_used]);
-			prealloc->is_used[prealloc->max_used++] = true;
-			M0_CNT_INC(layer->clr_extents_nr);
-		}
+	lid = cl->cl_base.l_id;
+	M0_ENTRY("lid %llu, layer %lu, e_start %llu, e_end %llu, e_state %llu",
+		 (unsigned long long)lid,
+		 (unsigned long)layer->clr_idx,
+		 (unsigned long long)e->e_start, (unsigned long long)e->e_end,
+		 (unsigned long long)new_state);
+	/* Find nearest extent from the list. */
+	nearest = NULL;
+	m0_tl_for(ext, &layer->clr_extents, ext1) {
+		if (e->e_start >= ext1->cle_ext.e_start)
+			nearest = ext1;
+		if (e->e_start < ext1->cle_ext.e_end)
+			break;
+	} m0_tl_endfor;
+	M0_ASSERT(nearest != NULL);
+	M0_LOG(M0_DEBUG, "nearest_start %llu, nearest_end %llu",
+	       (unsigned long long)nearest->cle_ext.e_start,
+	       (unsigned long long)nearest->cle_ext.e_end);
+	if (m0_ext_equal(&nearest->cle_ext, e)) {
+		nearest->cle_state = new_state;
+		rc = 0;
+	} else
+		rc = ext_paste(cl, layer, e, new_state, nearest);
+	if (rc == 0) {
+		/* Now, the exact extent has to be present in the list. */
+		M0_ASSERT(ext_find(layer, e, new_state, NULL) == 0);
+		/*
+		 * Merge the extent with the adjacent ones if their states are
+		 * the same.
+		 */
+		rc = ext_merge(cl, layer, e, new_state);
 	}
-	ext_del(layer, ext);
-	M0_LEAVE();
+	M0_POST(ergo(rc == 0, composite_invariant(cl)));
+	M0_RETURN(rc);
 }
 
 /**
@@ -1501,170 +1464,108 @@ static int ext_paste(struct m0_composite_layout *cl,
 	M0_RETURN(rc);
 }
 
-/** Merges ext1->cle_ext into ext2->cle_ext and deletes ext1. */
-static void merge(struct m0_composite_layer *layer,
-		  struct m0_composite_layer_ext *ext1,
-		  struct m0_composite_layer_ext *ext2)
-{
-	M0_LOG(M0_DEBUG, "lid %llu, layer %lu, Merging "
-	       "ext1 [%20llu, %20llu), ext 2 [%20llu, %20llu]",
-	       (unsigned long long)layer->clr_cl->l_id,
-	       (unsigned long)layer->clr_idx,
-	       (unsigned long long)ext1->cle_ext.e_start,
-	       (unsigned long long)ext1->cle_ext.e_end,
-	       (unsigned long long)ext2->cle_ext.e_start,
-	       (unsigned long long)ext2->cle_ext.e_end);
-	ext2->cle_ext.e_start = ext1->cle_ext.e_start;
-	ext_tlink_del_fini(ext1);
-	m0_free(ext1);
-	M0_CNT_DEC(layer->clr_extents_nr);
-}
-
-/**
- * Merges extent 'e' with the adjacent extents if they have the same state as
- * that of 'e'.
- * This fixes the layer invariant that might have been violated after the
- * execution of ext_paste().
- */
-static int ext_merge(struct m0_composite_layout *cl,
-		     struct m0_composite_layer *layer,
-		     const struct m0_ext *e,
-		     enum m0_composite_layer_ext_state state)
-{
-	struct m0_composite_layer_ext *ext;
-	struct m0_composite_layer_ext *prev;
-	struct m0_composite_layer_ext *next;
-	int                            rc;
-
-	M0_ENTRY();
-	rc = ext_find(layer, e, state, &ext);
-	M0_PRE(rc == 0);
-
-	prev = ext_tlist_prev(&layer->clr_extents, ext);
-	if (prev != NULL && prev->cle_state == state)
-		merge(layer, prev, ext);
-	next = ext_tlist_next(&layer->clr_extents, ext);
-	if (next != NULL && next->cle_state == state)
-		merge(layer, ext, next);
-	M0_RETURN(rc);
-}
-
 /**
- * Writes an extent with the specified state into 'the in-memory extent list
- * associated with the specified layer'. It internally deletes or truncates
- * the overlappping extents as necessary.
+ * Splits an existing extent as requested by using the vec.
+ * An extent is asked to be split when some partially overlapping extent is to
+ * be added.
  */
-static int ext_write(struct m0_composite_layout *cl,
-		     struct m0_composite_layer *layer,
-		     const struct m0_ext *e,
-		     enum m0_composite_layer_ext_state new_state)
+static void ext_split(struct m0_composite_layer *layer,
+		      struct m0_composite_layer_ext *ext,
+		      struct m0_indexvec *vec,
+		      m0_bindex_t scan,
+		      struct preallocated_extents *prealloc)
 {
-	uint64_t                       lid;
-	struct m0_composite_layer_ext *ext1;
-	struct m0_composite_layer_ext *nearest;
-	int                            rc;
+	struct m0_ext e;
+	m0_bcount_t   len;
+	uint32_t      i;
 
-	M0_PRE(composite_invariant(cl));
-	M0_PRE(!m0_ext_is_empty(e));
+	M0_PRE(ext_tlink_is_in(ext));
+	M0_PRE(vec->iv_vec.v_nr == 3);
+	M0_PRE(vec->iv_vec.v_count[0] != 0 || vec->iv_vec.v_count[1] != 0 ||
+	       vec->iv_vec.v_count[2] != 0);
 
-	lid = cl->cl_base.l_id;
-	M0_ENTRY("lid %llu, layer %lu, e_start %llu, e_end %llu, e_state %llu",
-		 (unsigned long long)lid,
-		 (unsigned long)layer->clr_idx,
-		 (unsigned long long)e->e_start, (unsigned long long)e->e_end,
-		 (unsigned long long)new_state);
-	/* Find nearest extent from the list. */
-	nearest = NULL;
-	m0_tl_for(ext, &layer->clr_extents, ext1) {
-		if (e->e_start >= ext1->cle_ext.e_start)
-			nearest = ext1;
-		if (e->e_start < ext1->cle_ext.e_end)
-			break;
-	} m0_tl_endfor;
-	M0_ASSERT(nearest != NULL);
-	M0_LOG(M0_DEBUG, "nearest_start %llu, nearest_end %llu",
-	       (unsigned long long)nearest->cle_ext.e_start,
-	       (unsigned long long)nearest->cle_ext.e_end);
-	if (m0_ext_equal(&nearest->cle_ext, e)) {
-		nearest->cle_state = new_state;
-		rc = 0;
-	} else
-		rc = ext_paste(cl, layer, e, new_state, nearest);
-	if (rc == 0) {
-		/* Now, the exact extent has to be present in the list. */
-		M0_ASSERT(ext_find(layer, e, new_state, NULL) == 0);
-		/*
-		 * Merge the extent with the adjacent ones if their states are
-		 * the same.
-		 */
-		rc = ext_merge(cl, layer, e, new_state);
+	M0_ENTRY("lid %llu, len0 %llu, len1 %llu, len2 %llu\n",
+		 (unsigned long long)layer->clr_cl->l_id,
+		 (unsigned long long)vec->iv_vec.v_count[0],
+		 (unsigned long long)vec->iv_vec.v_count[1],
+		 (unsigned long long)vec->iv_vec.v_count[2]);
+	for (i = 0; i < vec->iv_vec.v_nr; ++i) {
+		len = vec->iv_vec.v_count[i];
+		if (len != 0) {
+			e.e_start = scan;
+			e.e_end = scan = scan + len;
+			ext_add_internal(&layer->clr_extents, layer->clr_cl, &e,
+					 vec->iv_index[i], ADD_BEFORE, ext,
+					 prealloc->ext[prealloc->max_used]);
+			prealloc->is_used[prealloc->max_used++] = true;
+			M0_CNT_INC(layer->clr_extents_nr);
+		}
 	}
-	M0_POST(ergo(rc == 0, composite_invariant(cl)));
-	M0_RETURN(rc);
+	ext_del(layer, ext);
+	M0_LEAVE();
 }
 
-/** Finds a layer with the given layer index. */
-static struct m0_composite_layer *layer_find(
-					const struct m0_composite_layout *cl,
-					uint32_t layer_idx)
+/** Deletes an extent from the extent list associated with the given layer. */
+static void ext_del(struct m0_composite_layer *layer,
+		    struct m0_composite_layer_ext *ext)
 {
-	struct m0_composite_layer *layer;
-
-	M0_PRE(layer_idx < cl->cl_layers_nr);
-
-	m0_tl_for(layers, &cl->cl_layers, layer) {
-		if (layer->clr_idx == layer_idx)
-			break;
-	} m0_tl_endfor;
-	M0_POST(layer_invariant(layer));
-	M0_POST(layer->clr_idx == layer_idx);
-	return layer;
+	M0_LOG(M0_DEBUG, "lid %llu, layer %lu, e_start %llu, e_end %llu, "
+	       "e_state %llu", (unsigned long long)layer->clr_cl->l_id,
+	       (unsigned long)layer->clr_idx,
+	       (unsigned long long)ext->cle_ext.e_start,
+	       (unsigned long long)ext->cle_ext.e_end,
+	       (unsigned long long)ext->cle_state);
+	ext_tlink_del_fini(ext);
+	m0_free(ext);
+	M0_CNT_DEC(layer->clr_extents_nr);
 }
 
-M0_INTERNAL int m0_composite_layer_update(
-				struct m0_composite_layout *cl,
-				uint32_t layer_idx,
-				const struct m0_ext *e,
-				enum m0_composite_layer_ext_state state)
+/**
+ * Merges extent 'e' with the adjacent extents if they have the same state as
+ * that of 'e'.
+ * This fixes the layer invariant that might have been violated after the
+ * execution of ext_paste().
+ */
+static int ext_merge(struct m0_composite_layout *cl,
+		     struct m0_composite_layer *layer,
+		     const struct m0_ext *e,
+		     enum m0_composite_layer_ext_state state)
 {
-	struct m0_composite_layer *layer;
-	int                        rc;
+	struct m0_composite_layer_ext *ext;
+	struct m0_composite_layer_ext *prev;
+	struct m0_composite_layer_ext *next;
+	int                            rc;
 
-	M0_PRE(composite_invariant(cl));
-	M0_PRE(e != NULL);
-	M0_PRE(!m0_ext_is_empty(e));
-	M0_PRE(M0_IN(state, (M0_CLRES_HOLE, M0_CLRES_VALID,
-			     M0_CLRES_FLATTENING)));
+	M0_ENTRY();
+	rc = ext_find(layer, e, state, &ext);
+	M0_PRE(rc == 0);
 
-	M0_ENTRY("lid %llu, layer %lu, e_start %llu, e_end %llu, e_state %llu",
-		 (unsigned long long)cl->cl_base.l_id,
-		 (unsigned long)layer_idx, (unsigned long long)e->e_start,
-		 (unsigned long long)e->e_end, (unsigned long long)state);
-	m0_mutex_lock(&cl->cl_base.l_lock);
-	layer = layer_find(cl, layer_idx);
-	rc = ext_write(cl, layer, e, state);
-	if (rc != 0)
-		m0_layout__log("m0_composite_layer_update",
-			       "failed to add extent",
-			       M0_LAYOUT_ADDB_LOC_COMP_EXT_ADD,
-			       &cl->cl_base.l_addb_ctx, cl->cl_base.l_id, rc);
-	m0_mutex_unlock(&cl->cl_base.l_lock);
-	M0_POST(composite_invariant(cl));
+	prev = ext_tlist_prev(&layer->clr_extents, ext);
+	if (prev != NULL && prev->cle_state == state)
+		merge(layer, prev, ext);
+	next = ext_tlist_next(&layer->clr_extents, ext);
+	if (next != NULL && next->cle_state == state)
+		merge(layer, ext, next);
 	M0_RETURN(rc);
 }
 
-/** Implementation of lo_recsize() for COMPOSITE layout type. */
-static m0_bcount_t composite_recsize(const struct m0_layout *l)
+/** Merges ext1->cle_ext into ext2->cle_ext and deletes ext1. */
+static void merge(struct m0_composite_layer *layer,
+		  struct m0_composite_layer_ext *ext1,
+		  struct m0_composite_layer_ext *ext2)
 {
-	struct m0_composite_layout *cl;
-	m0_bcount_t                 recsize;
-
-	cl = m0_layout_to_cl(l);
-	recsize = sizeof(struct m0_layout_rec) +
-		  sizeof(struct m0_layout_composite_rec) +
-		  cl->cl_layers_nr * sizeof l->l_id;
-	M0_POST(recsize <= m0_layout_max_recsize(l->l_dom));
-	return recsize;
+	M0_LOG(M0_DEBUG, "lid %llu, layer %lu, Merging "
+	       "ext1 [%20llu, %20llu), ext 2 [%20llu, %20llu]",
+	       (unsigned long long)layer->clr_cl->l_id,
+	       (unsigned long)layer->clr_idx,
+	       (unsigned long long)ext1->cle_ext.e_start,
+	       (unsigned long long)ext1->cle_ext.e_end,
+	       (unsigned long long)ext2->cle_ext.e_start,
+	       (unsigned long long)ext2->cle_ext.e_end);
+	ext2->cle_ext.e_start = ext1->cle_ext.e_start;
+	ext_tlink_del_fini(ext1);
+	m0_free(ext1);
+	M0_CNT_DEC(layer->clr_extents_nr);
 }
 
 /** Implementation of lo_bufsize() for COMPOSITE layout type. */
@@ -1689,6 +1590,20 @@ static m0_bcount_t composite_bufsize(const struct m0_layout *l)
 }
 
 /* DB related routines start here. */
+/** Implementation of lo_recsize() for COMPOSITE layout type. */
+static m0_bcount_t composite_recsize(const struct m0_layout *l)
+{
+	struct m0_composite_layout *cl;
+	m0_bcount_t                 recsize;
+
+	cl = m0_layout_to_cl(l);
+	recsize = sizeof(struct m0_layout_rec) +
+		  sizeof(struct m0_layout_composite_rec) +
+		  cl->cl_layers_nr * sizeof l->l_id;
+	M0_POST(recsize <= m0_layout_max_recsize(l->l_dom));
+	return recsize;
+}
+
 /** Implementation of lto_max_recsize() for COMPOSITE layout type. */
 static m0_bcount_t composite_max_recsize(struct m0_layout_domain *dom)
 {
@@ -2116,6 +2031,65 @@ err_injected:
 }
 
 /**
+ * Reads the sublayout identifiers for all the layers for a composite layout,
+ * from a buffer provided and stores those in the sl_id_list array.
+ *
+ * Sublayout identifiers for all the layers are stored in the primary table.
+ *
+ * @post Memory is allocated for the array sl_list and it shall be freed by
+ * the caller.
+ */
+static int sublayout_ids_read(struct m0_composite_layout *cl,
+			      struct m0_bufvec_cursor *cur,
+			      uint32_t *layers_nr,
+			      uint64_t **sl_list)
+{
+	struct m0_layout_composite_rec *cl_rec;
+	uint64_t                       *sl_id_list;
+	uint64_t                       *sublayout_id;
+	uint32_t                        i;
+	int                             rc = 0;
+
+	M0_PRE(cur != NULL);
+
+	M0_ENTRY("lid %llu", (unsigned long long)cl->cl_base.l_id);
+	if (m0_bufvec_cursor_step(cur) < sizeof *cl_rec) {
+		rc = -EPROTO;
+		goto out;
+	}
+	cl_rec = m0_bufvec_cursor_addr(cur);
+	m0_bufvec_cursor_move(cur, sizeof *cl_rec);
+	*layers_nr = cl_rec->cr_layers_nr;
+	M0_ALLOC_ARR(sl_id_list, *layers_nr);
+	if (sl_id_list == NULL) {
+		rc = -ENOMEM;
+		m0_layout__log("sublayout_ids_read",
+			       "failed to allocate sl_id_list",
+			       M0_LAYOUT_ADDB_LOC_COMP_SUBLAYOUT_READ,
+			       &cl->cl_base.l_addb_ctx, cl->cl_base.l_id, rc);
+		goto out;
+	}
+	/* Read the sublayout ids from the buffer. */
+	if (m0_bufvec_cursor_step(cur) < *layers_nr * sizeof sl_id_list[0]) {
+		rc = -EPROTO;
+		goto out;
+	}
+	for (i = 0; i < cl_rec->cr_layers_nr; ++i) {
+		sublayout_id = m0_bufvec_cursor_addr(cur);
+		m0_bufvec_cursor_move(cur, sizeof *sublayout_id);
+		sl_id_list[i] = *sublayout_id;
+	}
+	*sl_list = sl_id_list;
+out:
+	if (rc == -EPROTO)
+		M0_LOG(M0_ERROR, "lid %llu, Invalid buf size, rc %d",
+		       (unsigned long long)cl->cl_base.l_id, rc);
+	M0_POST(ergo(rc == 0, *layers_nr > 0));
+	M0_RETURN(rc);
+}
+
+
+/**
  * Finds out number of existing layers and the associated sublayout id list
  * for the given layout. This information is stored in the primary table.
  *
@@ -2223,6 +2197,85 @@ static int layers_indb_delete(struct m0_composite_layout *cl,
 	M0_RETURN(rc);
 }
 
+/** Reads layers from the DB. */
+static int layers_indb_read(struct m0_composite_layout *cl,
+			    struct m0_db_tx *tx,
+			    uint32_t user_count,
+			    uint32_t layers_nr,
+			    uint64_t *sl_id_list)
+{
+	struct m0_layout          *sublayout;
+	struct m0_composite_layer *layer;
+	bool                       populate_done = false;
+	uint32_t                   i;
+	int                        rc = 0;
+
+	M0_PRE(m0_layout__allocated_invariant(&cl->cl_base));
+	M0_PRE(m0_mutex_is_locked(&cl->cl_base.l_lock));
+	M0_PRE(cl->cl_layers_nr == 0);
+	M0_PRE(layers_tlist_is_empty(&cl->cl_layers));
+	M0_PRE(tx != NULL);
+
+	M0_ENTRY("lid %llu, user_count %lu, layers_nr %lu",
+		 (unsigned long long)cl->cl_base.l_id,
+		 (unsigned long)user_count, (unsigned long)layers_nr);
+	for (i = 0; i < layers_nr; ++i) {
+		sublayout = layout_find(cl->cl_base.l_dom, sl_id_list[i]);
+		if (sublayout == NULL) {
+			rc = -EINVAL;
+			M0_LOG(M0_ERROR, "lid %llu, layer %lu, sublayout with "
+			       "lid %llu does not exist",
+			       (unsigned long long)cl->cl_base.l_id,
+			       (unsigned long)i,
+			       (unsigned long long)sl_id_list[i]);
+			break;
+		}
+		if (i == 0) { /* Zeroth layer */
+			rc = composite_populate(cl, sublayout, user_count);
+			if (rc == 0) {
+				layer = layers_tlist_head(&cl->cl_layers);
+				populate_done = true;
+			}
+		} else
+			rc = layer_add(cl, sublayout, &layer);
+		/*
+		 * Release the reference added by m0_layout_find(). In case of
+		 * success, layer_add() has added a reference on this
+		 * sublayout.
+		 */
+		m0_layout_put(sublayout);
+
+		if (rc == 0) {
+			rc = extents_indb_read(cl, layer, tx);
+			if (rc != 0) {
+				M0_LOG(M0_ERROR, "lid %llu, layer %lu, Error "
+				       "while reading extent list",
+				       (unsigned long long)cl->cl_base.l_id,
+				       (unsigned long)i);
+				break;
+			}
+		} else
+			break;
+	}
+	if (rc != 0) {
+		/*
+		 * Undo the layer addition and the layout population done
+		 * through the earlier iterations of the loop above.
+		 */
+		layers_inmem_delete(cl);
+		if (populate_done)
+			composite_populate_reverse(cl);
+		M0_POST(m0_layout__allocated_invariant(&cl->cl_base));
+	}
+	M0_POST(ergo(rc == 0, composite_invariant(cl) &&
+		     cl->cl_layers_nr > 0));
+	M0_POST(ergo(rc != 0, m0_layout__allocated_invariant(&cl->cl_base) &&
+		     cl->cl_layers_nr == 0));
+	M0_POST(m0_mutex_is_locked(&cl->cl_base.l_lock));
+	M0_RETURN(rc);
+}
+
+
 M0_INTERNAL struct m0_composite_layout *m0_layout_to_cl(
 						const struct m0_layout *l)
 {
-- 
1.8.3.2

