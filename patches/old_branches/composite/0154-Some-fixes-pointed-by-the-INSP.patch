From 1f7c8391ceb91aa7713234b647cc06b2d4934533 Mon Sep 17 00:00:00 2001
From: "trupti.patil" <trupti_patil@xyratex.com>
Date: Mon, 17 Jun 2013 15:45:40 +0530
Subject: [PATCH 154/172] Some fixes pointed by the INSP

---
 db/extmap.h          |   2 +-
 layout/composite.c   | 114 +++++++++++++++++++++------------------------------
 layout/layout.h      |  13 ++++--
 layout/layout_addb.h |  35 ++++++++--------
 4 files changed, 75 insertions(+), 89 deletions(-)

diff --git a/db/extmap.h b/db/extmap.h
index fe00042..fe59e45 100644
--- a/db/extmap.h
+++ b/db/extmap.h
@@ -263,7 +263,7 @@ int m0_emap_paste(struct m0_emap_cursor *it, struct m0_ext *ext, uint64_t val,
 		  void *data,
 		  void (*del)(struct m0_emap_seg *, void *),
 		  void (*cut_left)(struct m0_emap_seg *, struct m0_ext *,
-				   uint64_t, void *data),
+				   uint64_t, void *),
 		  void (*cut_right)(struct m0_emap_seg *, struct m0_ext *,
 				    uint64_t, void *));
 
diff --git a/layout/composite.c b/layout/composite.c
index f40bb14..731a68b 100644
--- a/layout/composite.c
+++ b/layout/composite.c
@@ -37,8 +37,6 @@
 #include "layout/composite.h"
 #include "layout/composite_internal.h"
 
-extern struct m0_addb_ctx layout_global_ctx;
-
 M0_TL_DESCR_DEFINE(layers, "composite-layer-list",
 		   M0_INTERNAL, struct m0_composite_layer,
 		   clr_linkage, clr_extents.t_magic,
@@ -70,16 +68,17 @@ M0_BOB_DEFINE(static, &composite_instance_bob, m0_composite_instance);
 
 struct composite_schema_data {
 	/**
-	 * Table to store the extent maps for all the layers of all the
+	 * Extent map to store the extent masks for all the layers of all the
 	 * composite layouts.
 	 */
 	struct m0_emap  csd_layer_emap;
 };
 
 /**
- * Prefix for the layer_emap table. The prefix helps to identify an extent map
- * for 'a particular layer of a particular composite layout', from the set of
- * the extent maps for 'all the layers of all the composite layouts'.
+ * Prefix for composite_schema_data::csd_layer_emap. The prefix helps to
+ * identify an extent mask for 'a particular layer of a particular composite
+ * layout', from the set of the extent masks for 'all the layers of all the
+ * composite layouts'.
  */
 struct layout_prefix {
 	/**
@@ -116,7 +115,6 @@ enum {
 	IN_UPDATE_PATH       = true,
 	EXT_MERGE_VALIDATION = 11,  /* Some random number other than 0 and 1. */
 	EXT_DEL_VALIDATION   = 12,  /* Another random number. */
-	EXTLIST_FINI         = true /* Finalise the extlist while freeing it */
 };
 
 /**
@@ -134,7 +132,6 @@ struct preallocated_extents {
  */
 static bool layer_invariant(const struct m0_composite_layer *layer)
 {
-	uint32_t    i = 0;
 	m0_bindex_t addr = 0;
 
 	return
@@ -143,14 +140,14 @@ static bool layer_invariant(const struct m0_composite_layer *layer)
 		_0C(layer->clr_extents_nr ==
 		    ext_tlist_length(&layer->clr_extents)) &&
 		m0_tl_forall(ext, ext1, &layer->clr_extents,
+			     _0C(!m0_ext_is_empty(&ext1->cle_ext)) &&
 			     _0C(ext1->cle_ext.e_start == addr) &&
 			     /* Intentional '=' below. */
-			     (addr = ext1->cle_ext.e_end) &&
-			     _0C(ergo(i == 0, ext1->cle_ext.e_start == 0)) &&
-			     _0C(ergo(i == layer->clr_extents_nr - 1,
-				      ext1->cle_ext.e_end ==
-				      M0_BINDEX_MAX + 1)) &&
-			     ++i);
+			     (addr = ext1->cle_ext.e_end)) &&
+		_0C(ext_tlist_head(&layer->clr_extents)->cle_ext.e_start ==
+		    0) &&
+		_0C(ext_tlist_tail(&layer->clr_extents)->cle_ext.e_end ==
+		    M0_BINDEX_MAX + 1);
 }
 
 static bool composite_invariant(const struct m0_composite_layout *cl)
@@ -207,7 +204,7 @@ err_injected:
 			dom->ld_type_data[lt->lt_id] = csd;
 		else {
 			m0_layout__log("composite_register",
-				       "failed to initialise layer_emap",
+				       "failed to initialise extent map",
 				       M0_LAYOUT_ADDB_LOC_COMP_REG_2, NULL,
 				       LID_NONE, rc);
 			m0_free(csd);
@@ -262,6 +259,7 @@ static int composite_allocate(struct m0_layout_domain *dom,
 		m0_mutex_lock(&cl->cl_base.l_lock);
 		*out = &cl->cl_base;
 		M0_POST(m0_layout__allocated_invariant(&cl->cl_base));
+		M0_POST(m0_mutex_is_locked(&cl->cl_base.l_lock));
 		M0_POST(cl->cl_layers_nr == 0);
 		M0_RETURN(0);
 	} else {
@@ -312,45 +310,33 @@ static int layer_add_internal(struct m0_composite_layout *cl,
 		 (unsigned long long)cl->cl_base.l_id,
 		 (unsigned long long)sublayout->l_id);
 	M0_ALLOC_PTR(layer);
-	if (layer == NULL) {
+	M0_ALLOC_PTR(ext);
+	if (layer == NULL || ext == NULL) {
+		m0_free(layer);
+		m0_free(ext);
 		m0_layout__log("layer_add_internal",
-			       "failed to allocate composite layer",
-			       M0_LAYOUT_ADDB_LOC_COMP_LAYER_ALLOC,
+			       "failed to allocate composite layer or ext",
+			       M0_LAYOUT_ADDB_LOC_COMP_LAYER_EXT_ALLOC,
 			       &cl->cl_base.l_addb_ctx, cl->cl_base.l_id,
 			       -ENOMEM);
 		M0_RETURN(-ENOMEM);
 	}
-
-	layer->clr_cl         = &cl->cl_base;
-	layer->clr_sl         = sublayout;
-	layer->clr_idx        = cl->cl_layers_nr;
-	layer->clr_extents_nr = 1;
-	ext_tlist_init(&layer->clr_extents);
-	m0_layout_get(layer->clr_sl); /* Add a reference to the sublayout. */
-
 	/*
 	 * Add one single extent, mapping the whole offset space and with the
-	 * M0_CLRES_HOLE state, thus marking the layer empty.
+	 * M0_CLRES_HOLE state, so as to mark the layer empty.
 	 */
-	M0_ALLOC_PTR(ext);
-	if (ext == NULL) {
-		m0_layout__log("layer_add_internal",
-			       "failed to allocate layer extent",
-			       M0_LAYOUT_ADDB_LOC_COMP_LAYER_EXT_ALLOC,
-			       &cl->cl_base.l_addb_ctx, cl->cl_base.l_id,
-			       -ENOMEM);
-		m0_layout_put(layer->clr_sl);
-		ext_tlist_fini(&layer->clr_extents);
-		m0_free(layer);
-		M0_RETURN(-ENOMEM);
-	}
+	ext_tlist_init(&layer->clr_extents);
 	ext->cle_ext.e_start = 0;
 	ext->cle_ext.e_end   = M0_BINDEX_MAX + 1;
 	ext->cle_state       = M0_CLRES_HOLE;
 	ext_tlink_init_at_tail(ext, &layer->clr_extents);
 
+	layer->clr_cl         = &cl->cl_base;
+	layer->clr_sl         = sublayout;
+	layer->clr_idx        = cl->cl_layers_nr++;
+	layer->clr_extents_nr = 1;
+	m0_layout_get(layer->clr_sl); /* Add a reference to the sublayout. */
 	layers_tlink_init_at_tail(layer, &cl->cl_layers);
-	M0_CNT_INC(cl->cl_layers_nr);
 
 	*lr = layer;
 	M0_POST(composite_invariant(cl));
@@ -366,7 +352,7 @@ static int layer_add(struct m0_composite_layout *cl,
 	return layer_add_internal(cl, sublayout, lr);
 }
 
-static void extlist_free(struct m0_tl *extlist, bool is_fini)
+static void extlist_fini(struct m0_tl *extlist)
 {
 	struct m0_composite_layer_extent *ext1;
 
@@ -374,8 +360,7 @@ static void extlist_free(struct m0_tl *extlist, bool is_fini)
 		ext_tlink_del_fini(ext1);
 		m0_free(ext1);
 	} m0_tl_endfor;
-	if (is_fini)
-		ext_tlist_fini(extlist);
+	ext_tlist_fini(extlist);
 }
 
 /** Deletes the top-most layer from the in-memory layout. */
@@ -388,7 +373,7 @@ static void layer_delete(struct m0_composite_layout *cl,
 	layers_tlink_del_fini(layer);
 	M0_CNT_DEC(cl->cl_layers_nr);
 	m0_layout_put(layer->clr_sl);
-	extlist_free(&layer->clr_extents, EXTLIST_FINI);
+	extlist_fini(&layer->clr_extents);
 	M0_POST(layer->clr_idx == cl->cl_layers_nr);
 	m0_free(layer);
 	M0_LEAVE();
@@ -469,18 +454,16 @@ M0_INTERNAL int m0_composite_build(struct m0_layout_domain *dom,
 static void layers_inmem_delete(struct m0_composite_layout *cl)
 {
 	struct m0_composite_layer *layer;
-	struct m0_composite_layer *layer_prev;
+
 	/*
 	 * Start deleting layers from the top-most layer so that the check from
 	 * layer_delete() that 'it is the top-most layer being deleted'
 	 * remains intact.
 	 */
-	layer = layers_tlist_tail(&cl->cl_layers);
-	while (layer != NULL) {
-		layer_prev = layers_tlist_prev(&cl->cl_layers, layer);
+	while ((layer = layers_tlist_tail(&cl->cl_layers)) != NULL)
 		layer_delete(cl, layer);
-		layer = layer_prev;
-	}
+	M0_POST(cl->cl_layers_nr == 0);
+	M0_POST(layers_tlist_is_empty(&cl->cl_layers));
 }
 
 /** Implementation of lo_fini for COMPOSITE layout type. */
@@ -535,7 +518,7 @@ static struct m0_composite_layer *layer_find(
 					const struct m0_composite_layout *cl,
 					uint32_t layer_idx)
 {
-	struct m0_composite_layer *layer = NULL;
+	struct m0_composite_layer *layer;
 
 	M0_PRE(layer_idx < cl->cl_layers_nr);
 
@@ -543,8 +526,8 @@ static struct m0_composite_layer *layer_find(
 		if (layer->clr_idx == layer_idx)
 			break;
 	} m0_tl_endfor;
-	M0_POST(layer->clr_idx == layer_idx);
 	M0_POST(layer_invariant(layer));
+	M0_POST(layer->clr_idx == layer_idx);
 	return layer;
 }
 
@@ -559,7 +542,7 @@ M0_INTERNAL void m0_composite_layer_delete(struct m0_composite_layout *cl)
 		 (unsigned long long)cl->cl_base.l_id,
 		 (unsigned long)cl->cl_layers_nr);
 	m0_mutex_lock(&cl->cl_base.l_lock);
-	layer = layer_find(cl, cl->cl_layers_nr - 1);
+	layer = layers_tlist_tail(&cl->cl_layers); /* The top-most layer. */
 	M0_PRE(m0_tl_forall(ext, ext1, &layer->clr_extents,
 			    ext1->cle_state == M0_CLRES_HOLE));
 	layer_delete(cl, layer);
@@ -665,12 +648,12 @@ static int ext_add(struct m0_tl *extlist,
 		   uint32_t add_position,
 		   struct m0_composite_layer_extent *adjacent);
 
-/*
+/**
  * Reads all the extents associated with the provided layer by reading those
  * from the buffer provided and stores those in the layer.
  *
- * Extents are stored in the auxiliary table for the composite layout viz.
- * "layer_emap".
+ * Extents are stored in the auxiliary table for the composite layout that is
+ * composite_schema_data::csd_layer_emap.
  */
 static int extents_inbuf_read(struct m0_composite_layout *cl,
 			      struct m0_composite_layer *layer,
@@ -823,21 +806,18 @@ static int layers_read(struct m0_composite_layout *cl,
 		} else
 			break;
 	}
-
 	if (rc != 0) {
 		/*
 		 * Undo the layer addition and the layout population done
 		 * through the earlier iterations of the loop above.
 		 */
-		if (layers_tlist_length(&cl->cl_layers) > 0)
-			layers_inmem_delete(cl);
+		layers_inmem_delete(cl);
 		if (populate_done)
 			composite_populate_reverse(cl);
-		M0_POST(cl->cl_layers_nr == 0);
-		M0_POST(layers_tlist_is_empty(&cl->cl_layers));
 		M0_POST(m0_layout__allocated_invariant(&cl->cl_base));
-	} else
-		M0_POST(composite_invariant(cl));
+	}
+	M0_POST(ergo(rc == 0, composite_invariant(cl) &&
+		     cl->cl_layers_nr > 0));
 	M0_POST(m0_mutex_is_locked(&cl->cl_base.l_lock));
 	M0_RETURN(rc);
 }
@@ -1670,7 +1650,7 @@ static int emap_iterator_set(struct m0_composite_layout *cl,
 err_injected:
 	if (rc != 0)
 		m0_layout__log("emap_iterator_set",
-			       "failed to lookup into layer_emap",
+			       "failed to lookup into extent map",
 			       M0_LAYOUT_ADDB_LOC_COMP_EMAP_IT_SET,
 			       &cl->cl_base.l_addb_ctx, cl->cl_base.l_id, rc);
 	return rc;
@@ -1779,7 +1759,7 @@ err_injected:
 			 */
 	} else
 		m0_layout__log("extents_indb_add",
-			       "failed to insert into layer_emap",
+			       "failed to insert into extent map",
 			       M0_LAYOUT_ADDB_LOC_COMP_LAYER_EMAP_ADD,
 			       &cl->cl_base.l_addb_ctx, cl->cl_base.l_id, rc);
 	if (rc != 0)
@@ -1922,7 +1902,7 @@ static int single_ext_indb_write(struct m0_composite_layout *cl,
 err1_injected:
 	if (rc != 0) {
 		m0_layout__log("single_ext_indb_write",
-			       "failed to lookup into layer_emap",
+			       "failed to lookup into extent map",
 			       M0_LAYOUT_ADDB_LOC_COMP_EMAP_LOOKUP,
 			       &cl->cl_base.l_addb_ctx, cl->cl_base.l_id, rc);
 		M0_RETURN(rc);
@@ -2061,7 +2041,7 @@ err_injected:
 				       cl->cl_base.l_id, rc);
 	} else
 		m0_layout__log("layer_indb_delete",
-			       "failed to delete from layer_emap",
+			       "failed to delete from extent map",
 			       M0_LAYOUT_ADDB_LOC_COMP_LAYER_INDB_DEL_2,
 			       &cl->cl_base.l_addb_ctx, cl->cl_base.l_id, rc);
 	M0_RETURN(rc);
diff --git a/layout/layout.h b/layout/layout.h
index ffa7fd7..9388077 100644
--- a/layout/layout.h
+++ b/layout/layout.h
@@ -267,6 +267,11 @@ struct m0_layout_ops {
 	 * method explicitly. It is called implicitly when the last reference
 	 * on the layout object is released.
 	 * @see m0_layout_put().
+	 *
+	 * lo_fini() is called only after it is ensured that the layout can not
+	 * be found by any other thread. Hence, the layout is not required to
+	 * be locked.
+	 * @pre m0_mutex_is_not_locked(&l->l_lock)
 	 */
 	void        (*lo_fini)(struct m0_ref *ref);
 
@@ -278,6 +283,8 @@ struct m0_layout_ops {
 	 * not be populated for some reason. In the other regular cases, dual
 	 * to the sequence of "lto_allocate() followed by the type specific
 	 * populate operation" is lo_fini().
+	 *
+	 * @pre m0_mutex_is_locked(&l->l_lock)
 	 */
 	void        (*lo_delete)(struct m0_layout *l);
 
@@ -415,9 +422,9 @@ struct m0_layout_type_ops {
 	 * Allocates an instance of some layout-type specific data-type
 	 * which embeds m0_layout and stores the resultant m0_layout object
 	 * in the parameter out.
-	 * @post ergo(result == 0, *out != NULL &&
-	 *                        (*out)->l_ops != NULL &&
-	 *                         m0_mutex_is_locked(&l->l_lock))
+	 * @post *out != NULL
+	 * @post (*out)->l_ops != NULL
+	 * @post m0_mutex_is_locked(&l->l_lock))
 	 */
 	int         (*lto_allocate)(struct m0_layout_domain *dom,
 				    uint64_t lid,
diff --git a/layout/layout_addb.h b/layout/layout_addb.h
index ce60df0..7ff5be5 100644
--- a/layout/layout_addb.h
+++ b/layout/layout_addb.h
@@ -88,24 +88,23 @@ enum {
 	M0_LAYOUT_ADDB_LOC_COMP_REG_1              = 200,
 	M0_LAYOUT_ADDB_LOC_COMP_REG_2              = 201,
 	M0_LAYOUT_ADDB_LOC_COMP_ALLOC              = 210,
-	M0_LAYOUT_ADDB_LOC_COMP_LAYER_ALLOC        = 220,
-	M0_LAYOUT_ADDB_LOC_COMP_LAYER_EXT_ALLOC    = 230,
-	M0_LAYOUT_ADDB_LOC_COMP_LAYER_ADD          = 240,
-	M0_LAYOUT_ADDB_LOC_COMP_SUBLAYOUT_READ     = 250,
-	M0_LAYOUT_ADDB_LOC_COMP_EXT_ADD_INTERNAL   = 260,
-	M0_LAYOUT_ADDB_LOC_COMP_EXT_ADD            = 270,
-	M0_LAYOUT_ADDB_LOC_COMP_EXT_UPDATE         = 280,
-	M0_LAYOUT_ADDB_LOC_COMP_EXT_DELETE         = 290,
-	M0_LAYOUT_ADDB_LOC_COMP_EXT_PASTE_1        = 300,
-	M0_LAYOUT_ADDB_LOC_COMP_EXT_PASTE_2        = 301,
-	M0_LAYOUT_ADDB_LOC_COMP_EXT_PASTE_3        = 302,
-	M0_LAYOUT_ADDB_LOC_COMP_LAYER_EMAP_ADD     = 310,
-	M0_LAYOUT_ADDB_LOC_COMP_EMAP_LOOKUP        = 320,
-	M0_LAYOUT_ADDB_LOC_COMP_EMAP_READ          = 330,
-	M0_LAYOUT_ADDB_LOC_COMP_LAYER_INDB_DEL_1   = 340,
-	M0_LAYOUT_ADDB_LOC_COMP_LAYER_INDB_DEL_2   = 341,
-	M0_LAYOUT_ADDB_LOC_COMP_EMAP_IT_SET        = 350,
-	M0_LAYOUT_ADDB_LOC_COMP_INST_BUILD         = 360,
+	M0_LAYOUT_ADDB_LOC_COMP_LAYER_EXT_ALLOC    = 220,
+	M0_LAYOUT_ADDB_LOC_COMP_LAYER_ADD          = 230,
+	M0_LAYOUT_ADDB_LOC_COMP_SUBLAYOUT_READ     = 240,
+	M0_LAYOUT_ADDB_LOC_COMP_EXT_ADD_INTERNAL   = 250,
+	M0_LAYOUT_ADDB_LOC_COMP_EXT_ADD            = 260,
+	M0_LAYOUT_ADDB_LOC_COMP_EXT_UPDATE         = 270,
+	M0_LAYOUT_ADDB_LOC_COMP_EXT_DELETE         = 280,
+	M0_LAYOUT_ADDB_LOC_COMP_EXT_PASTE_1        = 290,
+	M0_LAYOUT_ADDB_LOC_COMP_EXT_PASTE_2        = 291,
+	M0_LAYOUT_ADDB_LOC_COMP_EXT_PASTE_3        = 292,
+	M0_LAYOUT_ADDB_LOC_COMP_LAYER_EMAP_ADD     = 300,
+	M0_LAYOUT_ADDB_LOC_COMP_EMAP_LOOKUP        = 310,
+	M0_LAYOUT_ADDB_LOC_COMP_EMAP_READ          = 320,
+	M0_LAYOUT_ADDB_LOC_COMP_LAYER_INDB_DEL_1   = 330,
+	M0_LAYOUT_ADDB_LOC_COMP_LAYER_INDB_DEL_2   = 331,
+	M0_LAYOUT_ADDB_LOC_COMP_EMAP_IT_SET        = 340,
+	M0_LAYOUT_ADDB_LOC_COMP_INST_BUILD         = 350,
 
 	M0_LAYOUT_ADDB_LOC_NR
 };
-- 
1.8.3.2

