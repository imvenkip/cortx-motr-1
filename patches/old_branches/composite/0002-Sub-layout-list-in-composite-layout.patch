From 7df507dcefaace7b926773d73e6f5d73342a34f3 Mon Sep 17 00:00:00 2001
From: "trupti.patil" <trupti_patil@xyratex.com>
Date: Fri, 12 Oct 2012 23:59:11 +0530
Subject: [PATCH 002/172] Sub-layout list in composite layout

- Support for storing sub-layouts in an in-memory representation of a
  composite layout.
---
 colibri/magic.h    |  12 +++
 layout/composite.c | 218 ++++++++++++++++++++++++++++++++++++++++++++++++++---
 layout/composite.h |  54 +++++++++++--
 layout/ut/layout.c | 179 +++++++++++++++++++++++++++++++++++++++----
 4 files changed, 429 insertions(+), 34 deletions(-)

diff --git a/colibri/magic.h b/colibri/magic.h
index 7b8edf0..b06f1a6 100755
--- a/colibri/magic.h
+++ b/colibri/magic.h
@@ -246,6 +246,18 @@ enum c2_magic_satchel {
 	/* c2_layout_linear_enum::lla_magic (boldface blob) */
 	C2_LAYOUT_LINEAR_ENUM_MAGIC = 0x33b01dfaceb10b77,
 
+	/* c2_composite_layout::cl_magic (balolo access) */
+	C2_LAYOUT_COMPOSITE_MAGIC = 0x33ba1010acce5577,
+
+	/* c2_composite_instance::ci_magic (blob saleable) */
+	C2_LAYOUT_COMPOSITE_INSTANCE_MAGIC = 0x33b10b5a1eab1e77,
+
+	/* c2_composite_sub_layout::csl_magic (zodiac zoisia) */
+	C2_LAYOUT_COMP_SUBL_MAGIC = 0x3320d1ac20151a77,
+
+	/* todo sub_layout_tlist::head_magic (ss solidified) */
+	C2_LAYOUT_COMP_SUBL_HEAD_MAGIC = 0x33555011d1f1ed77,
+
 /* Net */
 	/* c2_net_domain::nd_magix (acidic access) */
 	C2_NET_DOMAIN_MAGIC = 0x33ac1d1cacce5577,
diff --git a/layout/composite.c b/layout/composite.c
index 626db2f..ba0a2ee 100644
--- a/layout/composite.c
+++ b/layout/composite.c
@@ -23,11 +23,41 @@
  * @{
  */
 
+#include "lib/errno.h"
 #include "lib/memory.h" /* C2_ALLOC_PTR() */
+#include "lib/misc.h"   /* C2_IN() */
+#include "lib/vec.h"    /* c2_bufvec_cursor_step(), c2_bufvec_cursor_addr() */
+#include "lib/bob.h"
+#include "lib/finject.h"
+
+#define C2_TRACE_SUBSYSTEM C2_TRACE_SUBSYS_LAYOUT
+#include "lib/trace.h"
 
 #include "layout/layout_internal.h"
 #include "layout/composite.h"
 
+extern struct c2_addb_ctx layout_global_ctx;
+
+static const struct c2_bob_type composite_bob = {
+	.bt_name         = "composite",
+	.bt_magix_offset = offsetof(struct c2_composite_layout, cl_magic),
+	.bt_magix        = C2_LAYOUT_COMPOSITE_MAGIC,
+	.bt_check        = NULL
+};
+
+C2_BOB_DEFINE(static, &composite_bob, c2_composite_layout);
+
+#if 0
+static const struct c2_bob_type composite_instance_bob = {
+	.bt_name         = "composite_instance",
+	.bt_magix_offset = offsetof(struct c2_composite_instance, ci_magic),
+	.bt_magix        = C2_LAYOUT_COMPOSITE_INSTANCE_MAGIC,
+	.bt_check        = NULL
+};
+
+C2_BOB_DEFINE(static, &composite_instance_bob, c2_composite_instance);
+#endif
+
 struct composite_schema_data {
 	/** Table to store extent maps for all the composite layouts. */
 	struct c2_emap csd_comp_layout_ext_map;
@@ -48,35 +78,199 @@ struct layout_prefix {
 	uint64_t lp_filler;
 };
 
+#if 1
+C2_TL_DESCR_DEFINE(c2_sub_layout, "sub-layout-list", ,
+		   struct c2_composite_sub_layout, csl_list_linkage, csl_magic,
+		   C2_LAYOUT_COMP_SUBL_MAGIC, C2_LAYOUT_COMP_SUBL_HEAD_MAGIC);
+C2_TL_DEFINE(c2_sub_layout, /* global */, struct c2_composite_sub_layout);
+#endif
+
+static bool composite_allocated_invariant(const struct c2_composite_layout *cl)
+{
+	return
+		cl != NULL &&
+		c2_layout__allocated_invariant(&cl->cl_base) &&
+		c2_mutex_is_locked(&cl->cl_base.l_lock) &&
+		cl->cl_sub_layouts == NULL;
+}
+
+static bool composite_invariant(const struct c2_composite_layout *cl)
+{
+	return
+		c2_composite_layout_bob_check(cl) &&
+		c2_layout__invariant(&cl->cl_base) &&
+		cl->cl_sub_layouts != NULL &&
+		!c2_sub_layout_tlist_is_empty(cl->cl_sub_layouts) &&
+		c2_tl_forall(c2_sub_layout, sl, cl->cl_sub_layouts,
+			     c2_layout__invariant(sl->csl_l));
+}
+
+static const struct c2_layout_ops composite_ops;
+/* Implementation of lto_allocate for COMPOSITE layout type. */
+static int composite_allocate(struct c2_layout_domain *dom,
+			      uint64_t lid,
+			      struct c2_layout **out)
+{
+	struct c2_composite_layout *cl;
+
+	C2_PRE(c2_layout__domain_invariant(dom));
+	C2_PRE(lid > 0);
+	C2_PRE(out != NULL);
+
+	C2_ENTRY("lid %llu", (unsigned long long)lid);
+
+	if (C2_FI_ENABLED("mem_err")) { cl = NULL; goto err1_injected; }
+	C2_ALLOC_PTR(cl);
+err1_injected:
+	if (cl == NULL) {
+		c2_layout__log("composite_allocate", "C2_ALLOC_PTR() failed",
+			       &c2_addb_oom, &layout_global_ctx, lid, -ENOMEM);
+		return -ENOMEM;
+	}
+
+	c2_layout__init(&cl->cl_base, dom, lid,
+			(struct c2_layout_type *)&c2_composite_layout_type,
+			&composite_ops);
+	c2_composite_layout_bob_init(cl);
+	c2_mutex_lock(&cl->cl_base.l_lock);
+
+	*out = &cl->cl_base;
+	C2_POST(composite_allocated_invariant(cl));
+	C2_POST(c2_mutex_is_locked(&(*out)->l_lock));
+	C2_LEAVE("lid %llu, cl pointer %p", (unsigned long long)lid, cl);
+	return 0;
+}
+
+/** Implementation of lo_delete for COMPOSITE layout type. */
+static void composite_delete(struct c2_layout *l)
+{
+	struct c2_composite_layout *cl;
+
+	cl = bob_of(l, struct c2_composite_layout,
+		    cl_base, &composite_bob);
+	C2_PRE(composite_allocated_invariant(cl));
+	C2_PRE(c2_mutex_is_locked(&l->l_lock));
+
+	C2_ENTRY("lid %llu", (unsigned long long)l->l_id);
+	c2_mutex_unlock(&l->l_lock);
+	c2_composite_layout_bob_fini(cl);
+	c2_layout__delete(&cl->cl_base);
+	c2_free(cl);
+	C2_LEAVE();
+}
+
+//todo Check if the return type should be int or make it void
+static int composite_populate(struct c2_composite_layout *cl,
+			      struct c2_tl *sub_layouts,
+			      uint32_t user_count)
+{
+	/* todo Oct12 Continue form here. */
+	struct c2_composite_sub_layout *sl;
+
+	C2_PRE(composite_allocated_invariant(cl));
+	C2_PRE(c2_mutex_is_locked(&cl->cl_base.l_lock));
+	C2_PRE(sub_layouts != NULL);
+
+	C2_ENTRY("lid %llu", (unsigned long long)cl->cl_base.l_id);
+
+	c2_layout__populate(&cl->cl_base, user_count);
+	/* Add reference to each of the sub-layouts. */
+	c2_tl_for(c2_sub_layout, sub_layouts, sl) {
+		C2_ASSERT(c2_layout__invariant(sl->csl_l));
+		c2_layout_get(sl->csl_l);
+	} c2_tl_endfor;
+	cl->cl_sub_layouts = sub_layouts;
+
+	C2_POST(composite_invariant(cl));
+	C2_POST(c2_mutex_is_locked(&cl->cl_base.l_lock));
+	C2_LEAVE("lid %llu", (unsigned long long)cl->cl_base.l_id);
+	return 0;
+}
+
+
 /*
  * @post A composite type of layout object is created. User is expected to
  * add a reference on the layout object as required and is expected to release
  * the reference when done with the usage. The layout is finalised when it is
  * the last reference being released.
  */
-void c2_composite_build(struct c2_layout_domain *dom,
-			uint64_t lid,
-			struct c2_tl *sub_layouts,
-			struct c2_composite_layout **out)
+int c2_composite_build(struct c2_layout_domain *dom,
+		       uint64_t lid,
+		       struct c2_tl *sub_layouts,
+		       struct c2_composite_layout **out)
 {
+	struct c2_layout           *l;
+	struct c2_composite_layout *cl;
+	int                         rc;
+
+	C2_PRE(out != NULL);
+	C2_PRE(!c2_sub_layout_tlist_is_empty(sub_layouts));
+
+	C2_ENTRY("domain %p, lid %llu", dom,(unsigned long long)lid);
+	rc = composite_allocate(dom, lid, &l);
+	if (rc == 0) {
+		/* Here composite_allocate() has locked l->l_lock. */
+		cl = bob_of(l, struct c2_composite_layout, cl_base,
+			    &composite_bob);
+		C2_ASSERT(composite_allocated_invariant(cl));
+
+		rc = composite_populate(cl, sub_layouts, 1);
+		if (rc == 0) {
+			*out = cl;
+			c2_mutex_unlock(&l->l_lock);
+		} else
+			composite_delete(l);
+	}
+
+	C2_POST(ergo(rc == 0, composite_invariant(*out) &&
+			      c2_mutex_is_not_locked(&l->l_lock)));
+	C2_LEAVE("domain %p, lid %llu, cl %p, rc %d",
+		 dom, (unsigned long long)lid, *out, rc);
+	return rc;
 }
 
 /** Implementation of lo_fini for COMPOSITE layout type. */
+//static void composite_fini(struct c2_ref *ref) todo
 static void composite_fini(struct c2_layout *l)
 {
+	struct c2_composite_layout     *cl;
+	struct c2_composite_sub_layout *sl;
+
+	//l = container_of(ref, struct c2_layout, l_ref); todo
+	C2_PRE(c2_mutex_is_not_locked(&l->l_lock));
+
+	C2_ENTRY("lid %llu", (unsigned long long)l->l_id);
+	cl = c2_layout_to_cl(l);
+	c2_composite_layout_bob_fini(cl);
+
+	c2_tl_for(c2_sub_layout, cl->cl_sub_layouts, sl) {
+		/* Release the reference acquired by composite_populate(). */
+		c2_layout_put(sl->csl_l);
+		c2_sub_layout_tlist_del(sl);
+		c2_sub_layout_tlink_fini(sl);
+		c2_free(sl);
+	} c2_tl_endfor;
+	c2_sub_layout_tlist_fini(cl->cl_sub_layouts);
+	c2_free(cl->cl_sub_layouts);
+
+	c2_layout__fini(&cl->cl_base);
+	c2_free(cl);
+	C2_LEAVE();
 }
 
-/* Implementation of lto_allocate for COMPOSITE layout type. */
-static int composite_allocate(struct c2_layout_domain *dom,
-			      uint64_t lid,
-			      struct c2_layout **out)
+struct c2_composite_layout *c2_layout_to_cl(const struct c2_layout *l)
 {
-	return 0;
+	struct c2_composite_layout *cl;
+
+	cl = bob_of(l, struct c2_composite_layout, cl_base, &composite_bob);
+	C2_POST(composite_invariant(cl));
+	return cl;
 }
 
-/** Implementation of lo_delete for COMPOSITE layout type. */
-static void composite_delete(struct c2_layout *l)
+struct c2_layout *c2_cl_to_layout(struct c2_composite_layout *cl)
 {
+	C2_PRE(composite_invariant(cl));
+	return &cl->cl_base;
 }
 
 /** Implementation of lo_recsize() for COMPOSITE layout type. */
@@ -234,7 +428,7 @@ static const struct c2_layout_type_ops composite_type_ops = {
 	.lto_allocate    = composite_allocate
 };
 
-const struct c2_layout_type c2_composite_layout_type = {
+struct c2_layout_type c2_composite_layout_type = {
 	.lt_name      = "composite",
 	.lt_id        = 1,
 	.lt_ref_count = 0,
diff --git a/layout/composite.h b/layout/composite.h
index 94dfcfe..c1ea51b 100644
--- a/layout/composite.h
+++ b/layout/composite.h
@@ -34,6 +34,7 @@
  */
 
 /* import */
+#include "colibri/magic.h"
 #include "db/extmap.h"	    /* struct c2_emap */
 #include "layout/layout.h"
 
@@ -47,16 +48,55 @@ struct c2_composite_layout {
 	/** Super class. */
 	struct c2_layout  cl_base;
 
-	/** List of sub-layouts owned by this composite layout. */
-	struct c2_tl      cl_sub_layouts;
+	/* Number of sub-layouts in this composite layout. */
+	uint32_t          cl_nr;
+
+	/** List of of sub-layouts owned by this composite layout. */
+	struct c2_tl     *cl_sub_layouts;
+
+	uint64_t          cl_magic;
+};
+
+/**
+ * todo
+ */
+struct c2_composite_sub_layout {
+	/* Layout for a specific segment pointed by csl_extent. */
+	struct c2_layout *csl_l;
+
+	/* Segment of an object todo */
+	struct c2_ext     csl_ext;
+
+	/** Magic number todo. */
+	uint64_t          csl_magic;
+
+	/**
+	 * Linkage used for maintaining list of the sub-layouts owned by a
+	 * particular composite layout.
+	 */
+	struct c2_tlink   csl_list_linkage;
+
+	/* todo Oct 11: Continue from here. */
 };
 
-void c2_composite_build(struct c2_layout_domain *dom,
-			uint64_t lid,
-			struct c2_tl *sub_layouts,
-			struct c2_composite_layout **out);
+#if 0
+C2_TL_DESCR_DEFINE(c2_sub_layout, "sub-layout-list", static,
+		   struct c2_composite_sub_layout, csl_list_linkage, csl_magic,
+		   C2_LAYOUT_COMP_SUBL_MAGIC, C2_LAYOUT_COMP_SUBL_HEAD_MAGIC);
+C2_TL_DEFINE(c2_sub_layout, , struct c2_composite_sub_layout);
+#endif
+
+C2_TL_DECLARE(c2_sub_layout, extern, struct c2_composite_sub_layout);
+
+int c2_composite_build(struct c2_layout_domain *dom,
+		       uint64_t lid,
+		       struct c2_tl *sub_layouts,
+		       struct c2_composite_layout **out);
+
+struct c2_composite_layout *c2_layout_to_cl(const struct c2_layout *l);
+struct c2_layout *c2_cl_to_layout(struct c2_composite_layout *cl);
 
-extern const struct c2_layout_type c2_composite_layout_type;
+extern struct c2_layout_type c2_composite_layout_type;
 
 /** @} end group composite */
 
diff --git a/layout/ut/layout.c b/layout/ut/layout.c
index 4cf2038..6d51c52 100644
--- a/layout/ut/layout.c
+++ b/layout/ut/layout.c
@@ -40,6 +40,7 @@
 #include "layout/layout_internal.h"      /* LDB_MAX_INLINE_COB_ENTRIES, *_ERR */
 #include "layout/layout_db.h"
 #include "layout/pdclust.h"
+#include "layout/composite.h"
 #include "layout/list_enum.h"
 #include "layout/linear_enum.h"
 #include "layout/ut/ldemo_internal.c"    /* layout_demo() */
@@ -358,7 +359,7 @@ static void test_reg_unreg(void)
 	 * this function.
 	 */
 	rc = c2_layout_standard_types_register(&domain);
-	C2_ASSERT(rc == 0);
+	C2_UT_ASSERT(rc == 0);
 
 	C2_LEAVE();
 }
@@ -467,7 +468,7 @@ static void test_reg_unreg_failure(void)
 	 * this function.
 	 */
 	rc = c2_layout_standard_types_register(&domain);
-	C2_ASSERT(rc == 0);
+	C2_UT_ASSERT(rc == 0);
 
 	C2_LEAVE();
 }
@@ -672,12 +673,12 @@ static void pdclust_layout_verify(uint32_t enum_id,
 	}
 }
 
-static void NKP_assign_and_pool_init(uint32_t enum_id,
-				     uint32_t inline_test,
-				     uint32_t list_nr_less,
-				     uint32_t list_nr_more,
-				     uint32_t linear_nr,
-				     uint32_t *N, uint32_t *K, uint32_t *P)
+static void NKP_assign(uint32_t enum_id,
+		       uint32_t inline_test,
+		       uint32_t list_nr_less,
+		       uint32_t list_nr_more,
+		       uint32_t linear_nr,
+		       uint32_t *N, uint32_t *K, uint32_t *P)
 {
 	C2_UT_ASSERT(ergo(enum_id == LIST_ENUM_ID,
 			  list_nr_less < LDB_MAX_INLINE_COB_ENTRIES &&
@@ -695,11 +696,10 @@ static void NKP_assign_and_pool_init(uint32_t enum_id,
 			*P = list_nr_more;
 			break;
 		default:
-			C2_ASSERT(0);
+			C2_UT_ASSERT(0);
 		}
-	} else {
+	} else
 		*P = linear_nr;
-	}
 
 	if (*P <= 20)
 		*K = 1;
@@ -722,10 +722,22 @@ static void NKP_assign_and_pool_init(uint32_t enum_id,
 		*N = *P - (2 * (*K)) - 12;
 	else
 		*N = *P - (2 * (*K)) - 100;
+}
+
+static void NKP_assign_and_pool_init(uint32_t enum_id,
+				     uint32_t inline_test,
+				     uint32_t list_nr_less,
+				     uint32_t list_nr_more,
+				     uint32_t linear_nr,
+				     uint32_t *N, uint32_t *K, uint32_t *P)
+{
+	NKP_assign(enum_id, inline_test,
+		   list_nr_less, list_nr_more, linear_nr,
+		   N, K, P);
 
 	/* Initialise the pool. */
 	rc = c2_pool_init(&pool, *P);
-	C2_ASSERT(rc == 0);
+	C2_UT_ASSERT(rc == 0);
 }
 
 /*
@@ -792,6 +804,138 @@ static int test_build_pdclust(uint32_t enum_id, uint64_t lid,
 	return rc;
 }
 
+static void sub_layouts_build(uint64_t composite_lid,
+			      struct c2_tl *sub_layout_list,
+			      uint32_t num_sublayouts,
+			      c2_bindex_t end_offset)
+{
+	uint32_t                        lid;
+	uint32_t                        enum_id;
+	bool                            inline_test;
+	struct c2_uint128               seed;
+	uint32_t                        N;
+	uint32_t                        K;
+	uint32_t                        P;
+	struct c2_pdclust_layout       *pl;
+	struct c2_layout_list_enum     *list_enum;
+	struct c2_layout_linear_enum   *lin_enum;
+	struct c2_composite_sub_layout *sub_layout;
+	uint32_t                        i;
+	c2_bindex_t                     delta = end_offset / num_sublayouts;
+
+	C2_UT_ASSERT(c2_sub_layout_tlist_is_empty(sub_layout_list));
+
+	c2_uint128_init(&seed, "sub_layouts_buil");
+	for (i = 0; i < num_sublayouts; ++i) {
+		lid = composite_lid * 100 + i;
+		enum_id = i % 2 ? LIST_ENUM_ID : LINEAR_ENUM_ID;
+		inline_test = i % 5 ? LESS_THAN_INLINE : MORE_THAN_INLINE;
+		NKP_assign(enum_id, inline_test, 9, 109, 1200, &N, &K, &P);
+		rc = pdclust_layout_build(enum_id, lid,
+					  N, K, P, &seed,
+					  10, 20,
+					  &pl, &list_enum, &lin_enum,
+					  false /* failure_test todo */ );
+		C2_UT_ASSERT(rc == 0);
+
+		C2_ALLOC_PTR(sub_layout);
+		C2_UT_ASSERT(sub_layout != NULL);
+		sub_layout->csl_l = c2_pdl_to_layout(pl);
+		sub_layout->csl_ext.e_start = i * delta;
+		sub_layout->csl_ext.e_end = sub_layout->csl_ext.e_start +
+					    delta - 1;
+		c2_sub_layout_tlink_init_at(sub_layout, sub_layout_list);
+	}
+}
+
+/*
+ * Builds a layout object with COMPOSITE layout type, by first building some
+ * sub-layouts.
+ */
+static int composite_layout_build(uint64_t lid,
+				  struct c2_composite_layout **cl,
+				  uint32_t num_sublayouts,
+				  c2_bindex_t end_offset,
+				  bool failure_test)
+{
+	struct c2_layout *l;
+	struct c2_layout *l_from_cl;
+	struct c2_tl     *sub_layout_list;
+	uint32_t          sub_layout_lid;
+	uint32_t          i;
+
+	C2_UT_ASSERT(cl != NULL);
+
+	/* Initialise a c2_tl for storing the sub-layouts to be built. */
+	C2_ALLOC_PTR(sub_layout_list);
+	C2_UT_ASSERT(sub_layout_list != NULL);
+	c2_sub_layout_tlist_init(sub_layout_list);
+
+	/* Build sub-layouts. */
+	sub_layouts_build(lid, sub_layout_list, num_sublayouts, end_offset);
+	C2_UT_ASSERT(!c2_sub_layout_tlist_is_empty(sub_layout_list));
+
+	/* Build composite layout. */
+	rc = c2_composite_build(&domain, lid, sub_layout_list, cl);
+	if (failure_test)
+		C2_UT_ASSERT(rc == -ENOMEM);
+	else {
+		C2_UT_ASSERT(rc == 0);
+
+		/*
+		 * Verify that c2_layout_find() returns the same object by
+		 * reading it from the memory.
+		 */
+		l = c2_layout_find(&domain, lid);
+		C2_UT_ASSERT(l == &(*cl)->cl_base);
+
+		/* Reduce the reference acquired by c2_layout_find(). */
+		c2_layout_put(&(*cl)->cl_base);
+
+		/* Verify c2_composite_to_layout(). */
+		l_from_cl = c2_cl_to_layout(*cl);
+		C2_UT_ASSERT(l_from_cl == &(*cl)->cl_base);
+
+		/* Verify the composite layout object contents. */
+		//todo composite_layout_verify(&cl->cl_base, lid);
+
+		/* Delete the layout object by reducing its last reference. */
+		c2_layout_put(&(*cl)->cl_base);
+		C2_UT_ASSERT(list_lookup(lid) == NULL);
+		C2_UT_ASSERT(c2_layout_find(&domain, lid) == NULL);
+	}
+
+	/* Delete all the sub-layouts. */
+	for (i = 0; i < num_sublayouts; ++i) {
+		sub_layout_lid = lid * 100 + i;
+		l = c2_layout_find(&domain, sub_layout_lid);
+		c2_layout_put(l);
+		c2_layout_put(l);
+	}
+
+	return rc;
+}
+
+/* todo Comment
+ * Tests the APIs supported for layout object build and layout destruction
+ * that happens using c2_layout_put(). Verifies that the newly built layout
+ * object is added to the list of layout objects maintained in the domain
+ * object and that c2_layout_find() returns the same object.
+ */
+static int test_build_composite(uint64_t lid,
+				bool failure_test)
+{
+	struct c2_composite_layout *cl;
+
+	rc = composite_layout_build(lid, &cl, 5, 500, failure_test);
+	if (failure_test)
+		C2_UT_ASSERT(rc == -ENOMEM);
+	else
+		C2_UT_ASSERT(rc == 0);
+
+	return rc;
+}
+
 /*
  * Tests the APIs supported for enumeration object build, layout object build
  * and layout dstruction that happens using c2_layout_put().
@@ -836,6 +980,11 @@ static void test_build(void)
 	rc = test_build_pdclust(LINEAR_ENUM_ID, lid, INLINE_NOT_APPLICABLE,
 				!FAILURE_TEST);
 	C2_UT_ASSERT(rc == 0);
+
+	/* todo Comment */
+	lid = 1005;
+	rc = test_build_composite(lid, !FAILURE_TEST);
+	C2_UT_ASSERT(rc == 0);
 }
 
 static void test_build_failure(void)
@@ -1609,7 +1758,7 @@ static int test_decode_encode_pdclust(uint32_t enum_id, uint64_t lid,
 
 	lt = &c2_pdclust_layout_type;
 	rc = lt->lt_ops->lto_allocate(&domain, lid, &l);
-	C2_ASSERT(c2_layout__allocated_invariant(l));
+	C2_UT_ASSERT(c2_layout__allocated_invariant(l));
 
 	/* Decode the layout buffer into a layout object. */
 	rc = c2_layout_decode(l, &cur1, C2_LXO_BUFFER_OP, NULL);
@@ -1944,7 +2093,7 @@ static int test_encode_decode_pdclust(uint32_t enum_id, uint64_t lid,
 
 	lt = &c2_pdclust_layout_type;
 	rc = lt->lt_ops->lto_allocate(&domain, lid, &l);
-	C2_ASSERT(c2_layout__allocated_invariant(l));
+	C2_UT_ASSERT(c2_layout__allocated_invariant(l));
 
 	/*
 	 * Decode the layout buffer produced by c2_layout_encode() into another
@@ -2337,7 +2486,7 @@ static void test_max_recsize(void)
 	 * this function.
 	 */
 	rc = c2_layout_standard_types_register(&domain);
-	C2_ASSERT(rc == 0);
+	C2_UT_ASSERT(rc == 0);
 
 	C2_LEAVE();
 }
-- 
1.8.3.2

