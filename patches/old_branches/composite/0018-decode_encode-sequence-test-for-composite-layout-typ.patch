From 2904ca22edf3d301303ad10703f1d4880bf096dc Mon Sep 17 00:00:00 2001
From: "trupti.patil" <trupti_patil@xyratex.com>
Date: Fri, 9 Nov 2012 16:29:29 +0530
Subject: [PATCH 018/172] decode_encode sequence test for composite layout type

---
 layout/composite.c    |   3 +
 layout/composite.h    |   2 +-
 layout/ut/composite.c | 225 ++++++++++++++++++++++++++++++++++++++++++++++++--
 layout/ut/layout.c    |  22 ++++-
 layout/ut/layout.h    |  13 ++-
 5 files changed, 252 insertions(+), 13 deletions(-)

diff --git a/layout/composite.c b/layout/composite.c
index 7cee3cc..5e1a3b7 100644
--- a/layout/composite.c
+++ b/layout/composite.c
@@ -542,6 +542,9 @@ static int composite_decode(struct c2_layout *l,
 				 */
 			}
 			C2_ASSERT(sublayout != NULL);
+			C2_ASSERT(c2_bufvec_cursor_step(cur) >=
+				  sl_header->slh_extents_nr * sizeof *ext);
+
 			for (j = 0; j < sl_header->slh_extents_nr; ++j) {
 				C2_ALLOC_PTR(sl_ext);
 				if (sl_ext == NULL) {
diff --git a/layout/composite.h b/layout/composite.h
index 69d958f..505d4de 100644
--- a/layout/composite.h
+++ b/layout/composite.h
@@ -204,7 +204,7 @@ struct sub_layout_entry {
 	/**
 	 * Payload storing list of extents (struct c2_ext) for the specific
 	 * sublayout.
-	*/
+	 */
 	char     sle_cobs[0];
 };
 C2_BASSERT(C2_IS_8ALIGNED(sizeof(struct sub_layout_entry)));
diff --git a/layout/ut/composite.c b/layout/ut/composite.c
index 9b5cc30..c36b14c 100644
--- a/layout/ut/composite.c
+++ b/layout/ut/composite.c
@@ -360,7 +360,7 @@ static void composite_layout_buf_build(uint64_t composite_lid,
 #endif
 		for (j = 0; j < sl_header.slh_extents_nr; ++j) {
 			ext.e_start = min_start_offset +
-				      (multiplier * j * delta);
+				      multiplier * j * delta;
 			ext.e_end = ext.e_start + delta - 1;
 			nbytes = c2_bufvec_cursor_copyto(dcur, &ext,
 							 sizeof ext);
@@ -457,6 +457,64 @@ int test_decode_composite(uint64_t lid,
 	return rc;
 }
 
+/* Verifies layout buffer against the various input arguments. */
+static void composite_layout_buf_verify(uint64_t lid,
+					struct c2_layout_domain *domain,
+					uint32_t sublayouts_nr,
+					uint32_t min_extents_nr,
+					c2_bindex_t min_start_offset,
+					c2_bindex_t approximate_end_offset,
+					bool if_contiguous_extents,
+					struct c2_bufvec_cursor *cur)
+{
+	uint32_t                  lt_id;
+	struct composite_header  *cl_header;
+	struct sub_layout_header *sl_header;
+	struct c2_ext            *ext;
+	c2_bindex_t               delta;
+	c2_bindex_t               multiplier;
+	uint32_t                  extents_nr;
+	uint32_t                  i;
+	uint32_t                  j;
+
+	C2_UT_ASSERT(cur != NULL);
+
+	/* Verify generic part of the layout buffer. */
+	lbuf_verify(cur, &lt_id);
+	C2_UT_ASSERT(lt_id == c2_composite_layout_type.lt_id);
+
+	/* Verify COMPOSITE layout type specific part of the layout buffer. */
+	C2_UT_ASSERT(c2_bufvec_cursor_step(cur) >= sizeof *cl_header);
+	cl_header = c2_bufvec_cursor_addr(cur);
+	C2_UT_ASSERT(cl_header != NULL);
+	c2_bufvec_cursor_move(cur, sizeof *cl_header);
+	C2_UT_ASSERT(cl_header->ch_sublayouts_nr == sublayouts_nr);
+
+	C2_UT_ASSERT(c2_bufvec_cursor_step(cur) >= cl_header->ch_sublayouts_nr *
+						   sizeof *sl_header);
+	multiplier = if_contiguous_extents ? 1 : 2;
+	extents_nr = min_extents_nr;
+
+	for (i = 0; i < cl_header->ch_sublayouts_nr; ++i, ++extents_nr) {
+		sl_header = c2_bufvec_cursor_addr(cur);
+		c2_bufvec_cursor_move(cur, sizeof *sl_header);
+		C2_UT_ASSERT(sl_header->slh_lid == lid * 100 + i);
+		C2_UT_ASSERT(sl_header->slh_extents_nr == extents_nr);
+
+		C2_UT_ASSERT(c2_bufvec_cursor_step(cur) >=
+			     sl_header->slh_extents_nr * sizeof ext);
+		delta = (approximate_end_offset - min_start_offset + 1) /
+			(extents_nr * multiplier);
+		for (j = 0; j < sl_header->slh_extents_nr; ++j) {
+			ext = c2_bufvec_cursor_addr(cur);
+			c2_bufvec_cursor_move(cur, sizeof *ext);
+			C2_UT_ASSERT(ext->e_start == min_start_offset +
+						     multiplier * j * delta);
+			C2_UT_ASSERT(ext->e_end == ext->e_start + delta - 1);
+		}
+	}
+}
+
 /* Tests the API c2_layout_encode() for COMPOSITE layout type. */
 int test_encode_composite(uint64_t lid,
 			  struct c2_layout_domain *domain,
@@ -500,11 +558,12 @@ int test_encode_composite(uint64_t lid,
 	/* Rewind the cursor. */
 	c2_bufvec_cursor_init(&cur, &bv);
 
-#if 0
-	/* todo Verify the layout buffer produced by c2_layout_encode(). */
+	/* Verify the layout buffer produced by c2_layout_encode(). */
 	if (!failure_test)
-		composite_layout_buf_verify(lid, sublayouts_nr, &cur);
-#endif
+		composite_layout_buf_verify(lid, domain, sublayouts_nr,
+					    min_extents_nr, min_start_offset,
+					    approximate_end_offset,
+					    if_contiguous_extents, &cur);
 
 	/* Delete the composite layout object. */
 	c2_layout_put(&cl->cl_base);
@@ -515,6 +574,162 @@ int test_encode_composite(uint64_t lid,
 	return rc;
 }
 
+/* Compares two layout buffers provided as input arguments. */
+static void composite_layout_buf_compare(struct c2_bufvec_cursor *cur1,
+					 struct c2_bufvec_cursor *cur2)
+{
+	struct composite_header  *cl_header1;
+	struct composite_header  *cl_header2;
+	struct sub_layout_header *sl_header1;
+	struct sub_layout_header *sl_header2;
+	struct c2_ext            *ext1;
+	struct c2_ext            *ext2;
+	uint32_t                  i;
+	uint32_t                  j;
+
+	C2_UT_ASSERT(cur1 != NULL);
+	C2_UT_ASSERT(cur2 != NULL);
+
+	/* Compare generic part of the layout buffers. */
+	lbuf_compare(cur1, cur2);
+
+	/* Compare COMPOSITE layout type specific part of the layout buffers. */
+
+	C2_UT_ASSERT(c2_bufvec_cursor_step(cur1) >= sizeof *cl_header1);
+	C2_UT_ASSERT(c2_bufvec_cursor_step(cur2) >= sizeof *cl_header2);
+
+	cl_header1 = c2_bufvec_cursor_addr(cur1);
+	cl_header2 = c2_bufvec_cursor_addr(cur2);
+
+	c2_bufvec_cursor_move(cur1, sizeof *cl_header1);
+	c2_bufvec_cursor_move(cur2, sizeof *cl_header2);
+
+	C2_UT_ASSERT(cl_header1->ch_sublayouts_nr ==
+		     cl_header2->ch_sublayouts_nr);
+
+	C2_UT_ASSERT(c2_bufvec_cursor_step(cur1) >=
+		     cl_header1->ch_sublayouts_nr * sizeof *sl_header1);
+	C2_UT_ASSERT(c2_bufvec_cursor_step(cur2) >=
+		     cl_header2->ch_sublayouts_nr * sizeof *sl_header2);
+
+	for (i = 0; i < cl_header1->ch_sublayouts_nr; ++i) {
+		sl_header1 = c2_bufvec_cursor_addr(cur1);
+		sl_header2 = c2_bufvec_cursor_addr(cur2);
+		c2_bufvec_cursor_move(cur1, sizeof *sl_header1);
+		c2_bufvec_cursor_move(cur2, sizeof *sl_header2);
+		C2_UT_ASSERT(sl_header1->slh_extents_nr ==
+			     sl_header2->slh_extents_nr);
+
+		for (j = 0; j < sl_header1->slh_extents_nr; ++j) {
+			ext1 = c2_bufvec_cursor_addr(cur1);
+			ext2 = c2_bufvec_cursor_addr(cur2);
+			c2_bufvec_cursor_move(cur1, sizeof *ext1);
+			c2_bufvec_cursor_move(cur2, sizeof *ext2);
+
+			C2_UT_ASSERT(ext1->e_start == ext2->e_start);
+			C2_UT_ASSERT(ext1->e_end == ext2->e_end);
+		}
+	}
+}
+
+/*
+ * Tests the API sequence c2_layout_decode() followed by c2_layout_encode(),
+ * for the COMPOSITE layout type.
+ */
+int test_decode_encode_composite(uint64_t lid,
+				 struct c2_layout_domain *domain,
+				 uint32_t sublayouts_nr,
+				 uint32_t min_extents_nr,
+				 c2_bindex_t min_start_offset,
+				 c2_bindex_t approximate_end_offset,
+				 bool if_contiguous_extents)
+{
+	void                    *area1;
+	struct c2_bufvec         bv1;
+	struct c2_bufvec_cursor  cur1;
+	void                    *area2;
+	struct c2_bufvec         bv2;
+	struct c2_bufvec_cursor  cur2;
+	c2_bcount_t              num_bytes;
+	struct c2_layout        *l;
+	struct c2_layout_type   *lt;
+	uint64_t                 sublayout_lid;
+	struct c2_layout        *sl;
+	uint32_t                 i;
+
+	C2_ENTRY();
+
+	/* Build a layout buffer. */
+	allocate_area(&area1, ADDITIONAL_BYTES_DEFAULT * 4, &num_bytes);
+	bv1 = (struct c2_bufvec) C2_BUFVEC_INIT_BUF(&area1, &num_bytes);
+	c2_bufvec_cursor_init(&cur1, &bv1);
+
+	composite_layout_buf_build(lid, sublayouts_nr, min_extents_nr,
+				   min_start_offset, approximate_end_offset,
+				   if_contiguous_extents, &cur1);
+
+	/* Rewind the cursor. */
+	c2_bufvec_cursor_init(&cur1, &bv1);
+
+	lt = &c2_composite_layout_type;
+	rc = lt->lt_ops->lto_allocate(domain, lid, &l);
+	C2_UT_ASSERT(c2_layout__allocated_invariant(l));
+
+	/* Decode the layout buffer into a layout object. */
+	rc = c2_layout_decode(l, &cur1, C2_LXO_BUFFER_OP, NULL);
+	C2_UT_ASSERT(rc == 0);
+
+	/* Unlock the layout, locked by lto_allocate() */
+	c2_mutex_unlock(&l->l_lock);
+
+	/* Rewind the cursor. */
+	c2_bufvec_cursor_init(&cur1, &bv1);
+
+	/*
+	 * Encode the layout object produced by c2_layout_decode() into
+	 * another layout buffer.
+	 */
+	allocate_area(&area2, ADDITIONAL_BYTES_DEFAULT * 4, &num_bytes);
+	bv2 = (struct c2_bufvec) C2_BUFVEC_INIT_BUF(&area2, &num_bytes);
+	c2_bufvec_cursor_init(&cur2, &bv2);
+
+	c2_mutex_lock(&l->l_lock);
+	rc = c2_layout_encode(l, C2_LXO_BUFFER_OP, NULL, &cur2);
+	c2_mutex_unlock(&l->l_lock);
+	C2_UT_ASSERT(rc == 0);
+
+	/* Rewind the cursor. */
+	c2_bufvec_cursor_init(&cur2, &bv2);
+
+	/*
+	 * Compare the two layout buffers - one created earlier here and
+	 * the one that is produced by c2_layout_encode().
+	 */
+	composite_layout_buf_compare(&cur1, &cur2);
+
+	/* Destroy the layout. */
+	c2_layout_put(l);
+	C2_UT_ASSERT(list_lookup(lid) == NULL);
+
+	/*
+	 * Destroy all the sub-layouts created through
+	 * composite_layout_buf_build().
+	 */
+	for (i = 0; i < sublayouts_nr; ++i) {
+		sublayout_lid = lid * 100 + i;
+		sl = c2_layout_find(domain, sublayout_lid);
+		C2_UT_ASSERT(sl != NULL);
+		c2_layout_put(sl);
+		c2_layout_put(sl);
+		C2_UT_ASSERT(c2_layout_find(domain, sublayout_lid) == NULL);
+	}
+
+	c2_free(area1);
+	c2_free(area2);
+	C2_LEAVE();
+	return rc;
+}
+
 #if 0 //todo Tune it for composite
 /* Copies contents of one layout object to the other. */
 static void pdclust_layout_copy(uint32_t enum_id,
diff --git a/layout/ut/layout.c b/layout/ut/layout.c
index f80b49e..e6e7816 100644
--- a/layout/ut/layout.c
+++ b/layout/ut/layout.c
@@ -1233,7 +1233,7 @@ static void test_decode_failure(void)
  * Verifies part of the layout buffer representing generic part of the layout
  * object.
  */
-static void lbuf_verify(struct c2_bufvec_cursor *cur, uint32_t *lt_id)
+void lbuf_verify(struct c2_bufvec_cursor *cur, uint32_t *lt_id)
 {
 	struct c2_layout_rec *rec;
 
@@ -1484,10 +1484,9 @@ static void test_encode_failure(void)
 	C2_UT_ASSERT(rc == LO_ENCODE_ERR);
 }
 
-
 /* Compares generic part of the layout buffers. */
-static void lbuf_compare(struct c2_bufvec_cursor *cur1,
-			 struct c2_bufvec_cursor *cur2)
+void lbuf_compare(struct c2_bufvec_cursor *cur1,
+		  struct c2_bufvec_cursor *cur2)
 {
 	struct c2_layout_rec *rec1;
 	struct c2_layout_rec *rec2;
@@ -1642,6 +1641,7 @@ static int test_decode_encode_pdclust(uint32_t enum_id, uint64_t lid,
 
 	lt = &c2_pdclust_layout_type;
 	rc = lt->lt_ops->lto_allocate(&domain, lid, &l);
+	C2_UT_ASSERT(rc == 0);
 	C2_UT_ASSERT(c2_layout__allocated_invariant(l));
 
 	/* Decode the layout buffer into a layout object. */
@@ -1745,6 +1745,20 @@ static void test_decode_encode(void)
 	rc = test_decode_encode_pdclust(LINEAR_ENUM_ID, lid,
 					INLINE_NOT_APPLICABLE);
 	C2_UT_ASSERT(rc == 0);
+
+	/*
+	 * Build a layout buffer representing a layout with COMPOSITE layout
+	 * type.
+	 * Decode it into a layout object. Then encode that layout object again
+	 * into another layout buffer.
+	 * Then, compare the original layout buffer with the encoded layout
+	 * buffer.
+	 */
+	lid = 7005;
+	rc = test_decode_encode_composite(lid, &domain, 11, 21,
+					  lid * 100, lid * 10 * 100,
+					  CONTIGUOUS_EXTENTS);
+	C2_UT_ASSERT(rc == 0);
 }
 
 /*
diff --git a/layout/ut/layout.h b/layout/ut/layout.h
index 353fb77..23d4019 100644
--- a/layout/ut/layout.h
+++ b/layout/ut/layout.h
@@ -75,10 +75,10 @@ void l_verify(struct c2_layout *l,
 	      uint64_t lid,
 	      bool if_user_count_incremented);
 
-//void lbuf_verify(struct c2_bufvec_cursor *cur, uint32_t *lt_id);
+void lbuf_verify(struct c2_bufvec_cursor *cur, uint32_t *lt_id);
 
-//void lbuf_compare(struct c2_bufvec_cursor *cur1,
-//			 struct c2_bufvec_cursor *cur2);
+void lbuf_compare(struct c2_bufvec_cursor *cur1,
+		  struct c2_bufvec_cursor *cur2);
 
 void generic_buf_build(uint32_t lt_id, struct c2_bufvec_cursor *dcur);
 struct c2_layout *list_lookup(uint64_t lid);
@@ -131,6 +131,13 @@ int test_encode_composite(uint64_t lid,
 			  c2_bindex_t approximate_end_offset,
 			  bool if_contiguous_extents,
 			  bool failure_test);
+int test_decode_encode_composite(uint64_t lid,
+				 struct c2_layout_domain *domain,
+				 uint32_t sublayouts_nr,
+				 uint32_t min_extents_nr,
+				 c2_bindex_t min_start_offset,
+				 c2_bindex_t approximate_end_offset,
+				 bool if_contiguous_extents);
 
 /* __COLIBRI_LAYOUT_LAYOUT_H__ */
 #endif
-- 
1.8.3.2

