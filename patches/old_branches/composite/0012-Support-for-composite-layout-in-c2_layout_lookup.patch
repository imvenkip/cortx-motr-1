From f865d48a2c94021ae706df52bdd7fbc5b42cc6bd Mon Sep 17 00:00:00 2001
From: "trupti.patil" <trupti_patil@xyratex.com>
Date: Mon, 29 Oct 2012 23:54:25 +0530
Subject: [PATCH 012/172] Support for composite layout in c2_layout_lookup()

---
 layout/composite.c | 269 ++++++++++++++++++++++++++++++++++++-----------------
 layout/ut/layout.c | 237 +++++++++++++++++++++++++++++++++++++++++++++-
 2 files changed, 419 insertions(+), 87 deletions(-)

diff --git a/layout/composite.c b/layout/composite.c
index 30737bb..48b861a 100644
--- a/layout/composite.c
+++ b/layout/composite.c
@@ -366,6 +366,93 @@ static c2_bcount_t composite_max_recsize(struct c2_layout_domain *dom)
 	return 0;
 }
 
+static int sublayouts_read(struct c2_composite_layout *cl,
+			   struct c2_tl *sub_layouts, uint32_t *nr,
+			   struct c2_db_tx *tx)
+{
+	struct c2_composite_sub_layout *sl;
+	struct composite_schema_data   *csd;
+	struct c2_emap                 *emap;
+	struct c2_emap_cursor           it;
+	struct c2_emap_seg             *seg;
+	c2_bcount_t                     total;
+	struct layout_prefix            prefix;
+	uint32_t                        sublayouts_nr;//todo rm since in invar
+	int                             rc;
+
+#if 0
+	struct c2_indexvec vec = {
+		.iv_vec = {
+			.v_nr    = ARRAY_SIZE(len),
+			.v_count = len
+		},
+		.iv_index = val
+	};
+#endif
+
+	csd  = cl->cl_base.l_dom->ld_type_data[c2_composite_layout_type.lt_id];
+	emap = &csd->csd_comp_layout_ext_map;
+	prefix.lp_l_id   = cl->cl_base.l_id;
+	prefix.lp_filler = 0; //todo Add a wrapper to set prefix
+
+	/* Set up an emap cursor. */
+	rc = c2_emap_lookup(emap, tx, (struct c2_uint128 *)&prefix, 0, &it);
+	C2_ASSERT(rc == 0); //todo handle err
+
+	/*
+	 * Read all the sub-layouts from the emap and store them in the
+	 * sub_layouts list.
+	 */
+	sublayouts_nr = 0;
+	total         = 0;
+	seg = c2_emap_seg_get(&it);
+	C2_ASSERT(c2_emap_ext_is_first(&seg->ee_ext));
+
+	C2_LOG(C2_DEBUG, "Composite lid %llu, sub-layouts: ",
+	       (unsigned long long)cl->cl_base.l_id);
+
+	while (1) {
+		seg = c2_emap_seg_get(&it);
+		C2_ALLOC_PTR(sl);
+		C2_ASSERT(sl != NULL); //todo handle error
+#if 0
+		sl->csl_l = c2_layout_lookup(cl->cl_base.l_dom, seg->ee_val,
+					     &c2_pdclust_layout_type /* todo*/,
+					     tx,);
+		/* todo What to do if the layout is not cached?
+		 * lookup requires layout type to be stored.
+		 */
+#endif
+		sl->csl_l = c2_layout_find(cl->cl_base.l_dom, seg->ee_val);
+		C2_ASSERT(sl->csl_l != NULL); //todo Handle err
+		c2_layout_user_count_inc(sl->csl_l); //todo Optimise
+		C2_ASSERT(!c2_ext_is_empty(&seg->ee_ext));
+		sl->csl_ext = seg->ee_ext;
+		c2_sub_layout_tlink_init_at_tail(sl, sub_layouts);
+
+		C2_LOG(C2_DEBUG, "Sub-layout[%lu]: lid %llu, "
+		       "e_start %llu, e_end %llu",
+		       (unsigned long)sublayouts_nr,
+		       (unsigned long long)sl->csl_l->l_id,
+		       (unsigned long long)sl->csl_ext.e_start,
+		       (unsigned long long)sl->csl_ext.e_end);
+
+		total = total + sl->csl_ext.e_end - sl->csl_ext.e_start;
+				//todo Why + 1 is not req'd
+		++sublayouts_nr;
+
+		if (c2_emap_ext_is_last(&seg->ee_ext))
+			break;
+		else
+			c2_emap_next(&it);
+	}
+	C2_ASSERT(total == C2_BCOUNT_MAX);
+	*nr = sublayouts_nr; //todo
+
+	c2_emap_close(&it);
+	return rc;
+}
+
 static const struct c2_layout_ops composite_ops;
 
 /** Implementation of lo_decode() for composite layout type. */
@@ -373,13 +460,14 @@ static int composite_decode(struct c2_layout *l,
 			    struct c2_bufvec_cursor *cur,
 			    enum c2_layout_xcode_op op,
 			    struct c2_db_tx *tx,
-			    uint32_t ref_count)
+			    uint32_t user_count)
 {
 	struct c2_composite_layout     *cl;
 	struct c2_composite_sub_layout *sl;
 	struct c2_tl                   *sub_layouts;
 	struct sub_layouts_header      *sl_header;
 	struct sub_layout_entry        *sl_entry;
+	uint32_t                        nr;
 	uint32_t                        i;
 	int                             rc;
 
@@ -405,46 +493,54 @@ static int composite_decode(struct c2_layout *l,
 			       l->l_id, -ENOMEM);
 		return -ENOMEM;
 	}
-
 	c2_sub_layout_tlist_init(sub_layouts);
-	for (i = 0; i < sl_header->slh_nr; ++i) {
-		sl_entry = c2_bufvec_cursor_addr(cur);
-		c2_bufvec_cursor_move(cur, sizeof *sl_entry);
-
-		C2_ALLOC_PTR(sl);
-		if (sl == NULL) {
-			c2_layout__log("composite_decode",
-				       "C2_ALLOC_PTR() failed",
-				       &c2_addb_oom, &l->l_addb,
-				       l->l_id, -ENOMEM);
-			return -ENOMEM;
-		}
 
-		/*
-		 * The reference acquired here using c2_layout_find() and the
-		 * addition of user count on each sub-layout will be undoen
-		 * by composite_fini().
-		 */
-		sl->csl_l = c2_layout_find(cl->cl_base.l_dom,
-					   sl_entry->sle_lid);
-		if (sl->csl_l == NULL) {
-			C2_LOG(C2_ERROR, "sub-layout-lid %llu, sub-layout not "
-			       "found in the cache, rc %d",
-			       (unsigned long long)sl_entry->sle_lid, -EPROTO);
-			/* todo Undo in case ref is taken on some sub-layouts,
-			 * user count addition and undo C2_ALLOC_PTR(sl) and
-			 * c2_sub_layout_tlink_init_at(). */
-			return -EPROTO;
+	if (op == C2_LXO_BUFFER_OP) {
+		for (i = 0; i < sl_header->slh_nr; ++i) {
+			sl_entry = c2_bufvec_cursor_addr(cur);
+			c2_bufvec_cursor_move(cur, sizeof *sl_entry);
+
+			C2_ALLOC_PTR(sl);
+			if (sl == NULL) {
+				c2_layout__log("composite_decode",
+					       "C2_ALLOC_PTR() failed",
+					       &c2_addb_oom, &l->l_addb,
+					       l->l_id, -ENOMEM);
+				return -ENOMEM;
+			}
+
+			/*
+			 * The reference acquired here using c2_layout_find()
+			 * and the addition of user count on each sub-layout
+			 * will be undone by composite_fini().
+			 */
+			sl->csl_l = c2_layout_find(cl->cl_base.l_dom,
+						   sl_entry->sle_lid);
+			if (sl->csl_l == NULL) {
+				C2_LOG(C2_ERROR, "sub-layout-lid %llu, "
+				       "sub-layout not found in the cache, "
+				       "rc %d",
+				       (unsigned long long)sl_entry->sle_lid,
+				       -EPROTO);
+				/* todo Undo in case ref is taken on some
+				 * sub-layouts, user count addition and undo
+				 * C2_ALLOC_PTR(sl) and
+				 * c2_sub_layout_tlink_init_at(). */
+				return -EPROTO;
+			}
+
+			c2_layout_user_count_inc(sl->csl_l);
+			sl->csl_ext = sl_entry->sle_ext;
+			c2_sub_layout_tlink_init_at(sl, sub_layouts);
 		}
-
-		c2_layout_user_count_inc(sl->csl_l);
-		sl->csl_ext.e_start = sl_entry->sle_ext.e_start;
-		sl->csl_ext.e_end = sl_entry->sle_ext.e_end;
-		c2_sub_layout_tlink_init_at(sl, sub_layouts);
+		C2_ASSERT(i == sl_header->slh_nr);
+		nr = sl_header->slh_nr; //todo Optimize code
+	} else {
+		rc = sublayouts_read(cl, sub_layouts, &nr, tx);
+		C2_ASSERT(rc == 0); //todo Handle err
 	}
-	C2_ASSERT(i == sl_header->slh_nr);
 
-	composite_populate(cl, sub_layouts, sl_header->slh_nr, ref_count);
+	composite_populate(cl, sub_layouts, nr, user_count);
 #if 0
 	if (op == C2_LXO_DB_LOOKUP) {
 		Read all the segments from the comp_layout_ext_map table,
@@ -473,10 +569,8 @@ static int sublayouts_write(struct c2_layout *l,
 	struct c2_emap                 *emap;
 	struct c2_emap_cursor           it;
 	struct c2_emap_seg             *seg;
-	c2_bcount_t                     seg_len;
 	c2_bcount_t                     total;
 	struct layout_prefix            prefix;
-	struct c2_uint128              *prefix_addr;
 	uint32_t                        sublayouts_nr;//todo rm since in invar
 	c2_bcount_t                     len[cl->cl_nr];
 	uint64_t                        val[cl->cl_nr];
@@ -491,56 +585,70 @@ static int sublayouts_write(struct c2_layout *l,
 	};
 
 	C2_PRE(C2_IN(op, (C2_LXO_DB_ADD, C2_LXO_DB_DELETE)));
-	C2_PRE(op == C2_LXO_DB_ADD); //todo handling add to start with
 
 	csd  = l->l_dom->ld_type_data[c2_composite_layout_type.lt_id];
 	emap = &csd->csd_comp_layout_ext_map;
-
 	prefix.lp_l_id = l->l_id;
-	prefix_addr = (struct c2_uint128 *)&prefix;
+	prefix.lp_filler = 0; //todo Add a wrapper to set prefix
 
-	if (op == C2_LXO_DB_ADD)
-		rc = c2_emap_obj_insert(emap, tx, prefix_addr, 0);
-	C2_ASSERT(rc == 0); //todo handle err
+	if (op == C2_LXO_DB_ADD) {
+		rc = c2_emap_obj_insert(emap, tx, (struct c2_uint128 *)&prefix,
+					0);
+		C2_ASSERT(rc == 0 || rc == -EEXIST); //todo handle err
+		if (rc == -EEXIST)
+			return rc;
 
-	rc = c2_emap_lookup(emap, tx, prefix_addr, 0 /* todo check */, &it);
-	C2_ASSERT(rc == 0); //todo handle err
-	seg = c2_emap_seg_get(&it);
-	C2_ASSERT(c2_emap_ext_is_first(&seg->ee_ext));
-	C2_ASSERT(c2_emap_ext_is_last(&seg->ee_ext));
-	seg_len = c2_ext_length(&seg->ee_ext);
-
-	total = 0;
-	sublayouts_nr = 0;
-	C2_LOG(C2_DEBUG, "Composite lid %llu, sub-layouts: ",
-	       (unsigned long long)l->l_id);
+		total = 0;
+		sublayouts_nr = 0;
+		C2_LOG(C2_DEBUG, "Composite lid %llu, sub-layouts: ",
+		       (unsigned long long)l->l_id);
 
-	c2_tl_for(c2_sub_layout, cl->cl_sub_layouts, sl) {
-		C2_LOG(C2_DEBUG, "Sub-layout[%lu]: lid %llu, e_start %llu, "
-		       "e_end %llu", (unsigned long)sublayouts_nr,
-		       (unsigned long long)sl->csl_l->l_id,
-		       (unsigned long long)sl->csl_ext.e_start,
-		       (unsigned long long)sl->csl_ext.e_end);
+		c2_tl_for(c2_sub_layout, cl->cl_sub_layouts, sl) {
+			C2_LOG(C2_DEBUG, "Sub-layout[%lu]: lid %llu, "
+			       "e_start %llu, e_end %llu",
+			       (unsigned long)sublayouts_nr,
+			       (unsigned long long)sl->csl_l->l_id,
+			       (unsigned long long)sl->csl_ext.e_start,
+			       (unsigned long long)sl->csl_ext.e_end);
+
+			len[sublayouts_nr] = sl->csl_ext.e_end -
+					     sl->csl_ext.e_start + 1;
+			val[sublayouts_nr] = sl->csl_l->l_id;
+			total = total + len[sublayouts_nr];
+			++sublayouts_nr;
+		} c2_tl_endfor;
+		C2_ASSERT(sublayouts_nr == cl->cl_nr);
+	}
 
-		len[sublayouts_nr] = sl->csl_ext.e_end -
-				     sl->csl_ext.e_start + 1;
-		val[sublayouts_nr] = sl->csl_l->l_id;
-		total = total + len[sublayouts_nr];
-		++sublayouts_nr;
-	} c2_tl_endfor;
+	/* Set up an emap cursor. */
+	rc = c2_emap_lookup(emap, tx, (struct c2_uint128 *)&prefix, 0, &it);
+	C2_ASSERT(rc == 0); //todo handle err
+	seg = c2_emap_seg_get(&it);
 
-	C2_ASSERT(sublayouts_nr == cl->cl_nr);
-	C2_ASSERT(total == seg_len);
+	if (op == C2_LXO_DB_ADD) {
+		C2_ASSERT(c2_emap_ext_is_first(&seg->ee_ext)); //todo rm
+		C2_ASSERT(c2_emap_ext_is_last(&seg->ee_ext)); //todo rm
+		C2_ASSERT(total == c2_ext_length(&seg->ee_ext));
 
-	if (op == C2_LXO_DB_ADD)
 		rc = c2_emap_split(&it, &vec);
-	C2_ASSERT(rc == 0); //todo Handle
+		C2_ASSERT(rc == 0); //todo Handle
+
+		c2_emap_close(&it);
+	} else { /* op == C2_LXO_DB_DELETE) */
+		/* todo This should happen on input from the user. */
+		while (!c2_emap_ext_is_last(&seg->ee_ext)) {
+			rc = c2_emap_merge(&it, c2_ext_length(&seg->ee_ext));
+			C2_ASSERT(rc == 0); //todo handle err
+		}
+
+		rc = c2_emap_obj_delete(emap, tx,
+					(struct c2_uint128 *)&prefix);
+		c2_emap_close(&it);
+		rc = c2_emap_obj_delete(emap, tx,
+					(struct c2_uint128 *)&prefix);
+		C2_ASSERT(rc == 0); //todo handle err
+	}
 
-	c2_emap_close(&it);
-#if 0
-	else
-		rc = c2_emap_obj_delete(emap, tx, prefix_addr);
-#endif
 	return rc;
 }
 
@@ -589,16 +697,11 @@ static int composite_encode(struct c2_layout *l,
 		C2_ASSERT(sublayouts_nr == cl->cl_nr);
 		rc = 0;
 	} else if (op == C2_LXO_DB_UPDATE) {
-		/*
-		 * The auxiliary table viz. comp_layout_ext_map is not to be
-		 * modified for an update operation.
-		 */
+		/* todo */
 		rc = 0;
 	} else if (op == C2_LXO_DB_ADD || op == C2_LXO_DB_DELETE) {
 		rc = sublayouts_write(l, cl, op, tx);
-		if (rc != 0) {
-			// todo
-		}
+		C2_ASSERT(rc == 0 || rc == -EEXIST); //todo Handle err
 	}
 
 	C2_LEAVE("lid %llu, rc %d", (unsigned long long)l->l_id, rc);
diff --git a/layout/ut/layout.c b/layout/ut/layout.c
index 1cc13f4..e54498d 100644
--- a/layout/ut/layout.c
+++ b/layout/ut/layout.c
@@ -796,9 +796,11 @@ static int test_build_pdclust(uint32_t enum_id, uint64_t lid,
  * Builds num_sublayouts number of sub-layouts and stores those in
  * sub_layout_list.
  */
+#if 0 //todo rm
 #ifndef __KERNEL__
 #include <stdlib.h>      /* printf() */ //todo
 #endif
+#endif
 static void sub_layouts_build(uint64_t composite_lid,
 			      struct c2_tl **sub_layout_list,
 			      uint32_t num_sublayouts)
@@ -860,6 +862,7 @@ static void sub_layouts_build(uint64_t composite_lid,
 		where               = sl->csl_ext.e_end + 1;
 		c2_sub_layout_tlink_init_at_tail(sl, *sub_layout_list);
 
+#if 0 //todo rm
 #ifndef __KERNEL__
 		printf("sl_lid %llu, e_start %llu, e_end %llu, "
 			"total %llu, where %llu \n",
@@ -869,6 +872,7 @@ static void sub_layouts_build(uint64_t composite_lid,
 			(unsigned long long)total,
 			(unsigned long long)where);
 #endif
+#endif
 	}
 
 	/*
@@ -877,6 +881,7 @@ static void sub_layouts_build(uint64_t composite_lid,
 	 */
 	sl->csl_ext.e_end = C2_BINDEX_MAX;
 	total = total - delta + sl->csl_ext.e_end - sl->csl_ext.e_start;
+#if 0 //todo rm
 #ifndef __KERNEL__
 		printf("Revised last segment\n sl_lid %llu, "
 			"e_start %llu, e_end %llu, "
@@ -887,6 +892,7 @@ static void sub_layouts_build(uint64_t composite_lid,
 			(unsigned long long)total,
 			(unsigned long long)where);
 #endif
+#endif
 	C2_UT_ASSERT(total == C2_BINDEX_MAX);
 	C2_UT_ASSERT(!c2_sub_layout_tlist_is_empty(*sub_layout_list));
 }
@@ -928,6 +934,7 @@ static void composite_layout_verify(struct c2_layout *l,
 				      USER_COUNT_INCREMENTED);
 		C2_UT_ASSERT(sl->csl_l->l_user_count == 1);
 
+#if 0 //todo rm
 #ifndef __KERNEL__
 		printf("sl_lid %llu, e_start %llu, e_end %llu, "
 			"delta %llu, where %llu \n",
@@ -937,6 +944,7 @@ static void composite_layout_verify(struct c2_layout *l,
 			(unsigned long long)delta,
 			(unsigned long long)where);
 #endif
+#endif
 
 		/* Verify sl->csl_ext. */
 		C2_UT_ASSERT(sl->csl_ext.e_start == where);
@@ -1024,7 +1032,6 @@ static int test_build_composite(uint64_t lid,
 		 */
 		c2_layout_put(&cl->cl_base);
 		C2_UT_ASSERT(list_lookup(lid) == NULL);
-		C2_UT_ASSERT(c2_layout_find(&domain, lid) == NULL);
 
 		/* Delete all the sub-layouts. */
 		for (i = 0; i < 5; ++i) {
@@ -3147,7 +3154,6 @@ static int test_lookup_pdclust(uint32_t enum_id, uint64_t lid,
 	}
 
 	C2_UT_ASSERT(list_lookup(lid) == NULL);
-	C2_UT_ASSERT(c2_layout_find(&domain, lid) == NULL);
 
 	/* Lookup for the layout object from the DB. */
 	allocate_area(&area, ADDITIONAL_BYTES_NONE, &num_bytes);
@@ -3314,6 +3320,109 @@ static int test_lookup_with_ghost_creation(uint32_t enum_id, uint64_t lid,
 	return rc;
 }
 
+static int test_add_composite(uint64_t lid,
+			      bool layout_destroy, struct c2_layout **l_obj,
+			      bool duplicate_test,
+			      bool failure_test);
+/* Tests the API c2_layout_lookup(), for the COMPOSITE layout type. */
+static int test_lookup_composite(uint64_t lid,
+				 bool existing_test,
+				 bool failure_test)
+{
+	c2_bcount_t        num_bytes;
+	void              *area;
+	struct c2_layout  *l1;
+	//todo struct c2_layout  *l1_copy;
+	struct c2_layout  *l2;
+	struct c2_layout  *l3;
+	struct c2_db_pair  pair;
+	struct c2_db_tx    tx;
+	uint32_t           i; //todo rm
+	uint64_t           sublayout_lid; //todo rm
+	struct c2_layout  *l; //todo rm
+	int                rc_tmp;
+
+	C2_ENTRY();
+	C2_UT_ASSERT(ergo(!existing_test, failure_test));
+
+	/*
+	 * If existing_test is true, then first add a layout object to the
+	 * DB.
+	 */
+	if (existing_test) {
+		rc = test_add_composite(lid,
+					!LAYOUT_DESTROY, &l1,
+					!DUPLICATE_TEST,
+					!FAILURE_TEST);
+		C2_UT_ASSERT(rc == 0);
+
+#if 0 //todo
+		if (!failure_test)
+			composite_layout_copy(enum_id, l1, &l1_copy);
+#endif
+
+		/*
+		 * Lookup for the layout object to verify that the same object
+		 * is returned from the memory, not requiring a lookup from the
+		 * DB.
+		 */
+		rc = c2_layout_lookup(&domain, lid, &c2_composite_layout_type,
+				      &tx, &pair, &l2);
+		C2_UT_ASSERT(rc == 0);
+		C2_UT_ASSERT(l2 == l1);
+
+		/* Release the reference acquired by c2_layout_lookup(). */
+		c2_layout_put(l1);
+
+		/* Destroy the layout object. */
+		c2_layout_put(l1);
+	}
+
+	C2_UT_ASSERT(list_lookup(lid) == NULL);
+
+	/* Lookup for the layout object from the DB. */
+	allocate_area(&area, ADDITIONAL_BYTES_NONE, &num_bytes);
+
+	rc = c2_db_tx_init(&tx, &dbenv, DBFLAGS);
+	C2_UT_ASSERT(rc == 0);
+
+	pair_set(&pair, &lid, area, num_bytes);
+
+	rc = c2_layout_lookup(&domain, lid, &c2_composite_layout_type,
+			      &tx, &pair, &l3);
+	if (failure_test)
+		C2_UT_ASSERT(rc == -ENOENT || rc == -ENOMEM || rc == -EPROTO ||
+			     rc == LO_DECODE_ERR);
+	else
+		C2_UT_ASSERT(rc == 0);
+
+	rc_tmp = c2_db_tx_commit(&tx);
+	C2_UT_ASSERT(rc_tmp == 0);
+
+	if (existing_test && !failure_test) {
+		C2_UT_ASSERT(list_lookup(lid) == l3);
+		//todo composite_layout_compare(enum_id, l1_copy, l3, false);
+		//todo composite_layout_copy_delete(enum_id, l1_copy);
+
+		/* Destroy the layout object. */
+		c2_layout_put(l3);
+		C2_UT_ASSERT(list_lookup(lid) == NULL);
+
+		/* Delete all the sub-layouts. */
+		for (i = 0; i < 10; ++i) {
+			sublayout_lid = lid * 100 + i;
+			l = c2_layout_find(&domain, sublayout_lid);
+			//C2_UT_ASSERT(c2_ref_read(&l->l_ref) == 0); //todo
+				// Check, elsewhere it says l_user_count
+			c2_layout_put(l);
+			c2_layout_put(l);
+		}
+	}
+	c2_free(area);
+	C2_LEAVE();
+	return rc;
+}
+
 /* Tests the API c2_layout_lookup(). */
 static void test_lookup(void)
 {
@@ -3396,6 +3505,26 @@ static void test_lookup(void)
 	rc = test_lookup_with_ghost_creation(LINEAR_ENUM_ID, lid,
 					     INLINE_NOT_APPLICABLE);
 	C2_UT_ASSERT(rc == 0);
+
+	/*
+	 * Lookup for a layout object with COMPOSITE layout type, that does not
+	 * exist in the DB.
+	 */
+	lid = 14008;
+	rc = test_lookup_composite(lid,
+				   !EXISTING_TEST,
+				   FAILURE_TEST);
+	C2_UT_ASSERT(rc == -ENOENT);
+
+	/*
+	 * Add a layout object with COMPOSITE layout type. Then perform lookup
+	 * for it.
+	 */
+	lid = 14009;
+	rc = test_lookup_composite(lid,
+				   EXISTING_TEST,
+				   !FAILURE_TEST);
+	C2_UT_ASSERT(rc == 0);
 }
 
 /* Tests the API c2_layout_lookup(). */
@@ -3588,6 +3717,7 @@ static int test_add_pdclust(uint32_t enum_id, uint64_t lid,
 }
 
 /* Tests the API c2_layout_add(), for the COMPOSITE layout type. */
+//todo Make this accept num_sublayouts
 static int test_add_composite(uint64_t lid,
 			      bool layout_destroy, struct c2_layout **l_obj,
 			      bool duplicate_test,
@@ -3745,14 +3875,14 @@ static void test_add_failure(void)
 
 	/*
 	 * Simulate the error that entry already exists in the layout DB with
-	 * the dame layout id.
+	 * the same layout id.
 	 */
 	lid = 17002;
 	rc = test_add_pdclust(LINEAR_ENUM_ID, lid,
 			      INLINE_NOT_APPLICABLE,
 			      LAYOUT_DESTROY, NULL,
 			      DUPLICATE_TEST,
-			      !FAILURE_TEST);
+			      !FAILURE_TEST); // todo mark this failure test
 	C2_UT_ASSERT(rc == -EEXIST);
 
 	/*
@@ -3781,6 +3911,16 @@ static void test_add_failure(void)
 			      FAILURE_TEST);
 	C2_UT_ASSERT(rc == -ENOENT);
 
+	/*
+	 * Simulate the error that entry already exists in the layout DB with
+	 * the same layout id.
+	 */
+	lid = 17005;
+	rc = test_add_composite(lid,
+				LAYOUT_DESTROY, NULL,
+				DUPLICATE_TEST,
+				!FAILURE_TEST);
+	C2_UT_ASSERT(rc == -EEXIST);
 }
 
 /* Tests the API c2_layout_update(), for the PDCLUST layout type. */
@@ -4096,6 +4236,86 @@ static int test_delete_pdclust(uint32_t enum_id, uint64_t lid,
 	return rc;
 }
 
+#if 0
+/* Tests the API c2_layout_delete(), for the COMPOSITE layout type. */
+static int test_delete_composite(uint64_t lid,
+				 bool existing_test,
+				 uint32_t failure_test)
+{
+	c2_bcount_t                   num_bytes;
+	void                         *area;
+	struct c2_db_pair             pair;
+	struct c2_db_tx               tx;
+	struct c2_layout             *l;
+	struct c2_composite_layout   *cl;
+	int                           rc_tmp;
+
+	C2_ENTRY("lid %llu", (unsigned long long)lid);
+	allocate_area(&area, ADDITIONAL_BYTES_NONE, &num_bytes);
+
+	if (existing_test) {
+		/* Add a layout object to the DB. */
+		rc = test_add_composite(lid,
+					!LAYOUT_DESTROY, &l,
+					!DUPLICATE_TEST,
+					!FAILURE_TEST);
+		C2_UT_ASSERT(rc == 0);
+	} else {
+		/* Build a layout object. */
+		rc = composite_layout_build(lid, &cl, 15, !FAILURE_TEST);
+		C2_UT_ASSERT(rc == 0);
+		l = &cl->cl_base;
+	}
+
+	if (C2_FI_ENABLED("nonzero_user_count_err"))
+		c2_layout_user_count_inc(l);
+
+	/* Delete the layout object from the DB. */
+	pair_set(&pair, &lid, area, num_bytes);
+
+	rc = c2_db_tx_init(&tx, &dbenv, DBFLAGS);
+	C2_UT_ASSERT(rc == 0);
+
+	rc = c2_layout_delete(l, &tx, &pair);
+	if (failure_test)
+		C2_UT_ASSERT(rc == -ENOENT || rc == -ENOMEM ||
+			     rc == -EPROTO || rc == LO_ENCODE_ERR);
+	else
+		C2_UT_ASSERT(rc == 0);
+
+	rc_tmp = c2_db_tx_commit(&tx);
+	C2_UT_ASSERT(rc_tmp == 0);
+
+	/* Destroy the layout object. */
+	c2_layout_put(l);
+	C2_UT_ASSERT(list_lookup(lid) == NULL);
+
+	if (!failure_test) {
+		/*
+		 * Lookup for the layout object from the DB, to verify that it
+		 * does not exist there and that the lookup results into
+		 * ENOENT error.
+		 */
+		rc = c2_db_tx_init(&tx, &dbenv, DBFLAGS);
+		C2_UT_ASSERT(rc == 0);
+
+		pair_set(&pair, &lid, area, num_bytes);
+
+		rc_tmp = c2_layout_lookup(&domain, lid,
+					  &c2_composite_layout_type,
+					  &tx, &pair, &l);
+		C2_UT_ASSERT(rc_tmp == -ENOENT);
+
+		rc_tmp = c2_db_tx_commit(&tx);
+		C2_UT_ASSERT(rc_tmp == 0);
+	}
+
+	c2_free(area);
+	C2_LEAVE();
+	return rc;
+}
+#endif
+
 /* Tests the API c2_layout_delete(). */
 static void test_delete(void)
 {
@@ -4145,6 +4365,15 @@ static void test_delete(void)
 				 INLINE_NOT_APPLICABLE,
 				 !FAILURE_TEST);
 	C2_UT_ASSERT(rc == 0);
+
+	/* Delete a layout object with COMPOSITE layout type. */
+#if 0 //todo
+	lid = 20005;
+	rc = test_delete_composite(lid,
+				   EXISTING_TEST,
+				   !FAILURE_TEST);
+	C2_UT_ASSERT(rc == 0);
+#endif
 }
 
 static void test_delete_failure(void)
-- 
1.8.3.2

