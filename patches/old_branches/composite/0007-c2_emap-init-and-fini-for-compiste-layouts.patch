From ee718b0c92b944aa4e4be2396ddc76d56a0d5b1f Mon Sep 17 00:00:00 2001
From: "trupti.patil" <trupti_patil@xyratex.com>
Date: Mon, 22 Oct 2012 17:06:26 +0530
Subject: [PATCH 007/172] c2_emap init and fini for compiste layouts

---
 build_kernel_modules/Makefile.in |  4 +--
 db/extmap.c                      | 21 ++++++++-----
 layout/composite.c               | 67 +++++++++++++++++++++++++---------------
 layout/composite.h               |  2 +-
 layout/list_enum.c               | 12 +++----
 5 files changed, 65 insertions(+), 41 deletions(-)

diff --git a/build_kernel_modules/Makefile.in b/build_kernel_modules/Makefile.in
index e3cd198..1c41519 100644
--- a/build_kernel_modules/Makefile.in
+++ b/build_kernel_modules/Makefile.in
@@ -91,7 +91,7 @@ cob_SOURCES                     := cob.c
 
 colibri_SOURCES                 := init.c
 
-db_SOURCES                      := db_common.c
+db_SOURCES                      := db_common.c extmap.c
 
 db_linux_kernel_SOURCES         := db.c
 
@@ -122,7 +122,7 @@ lib_SOURCES                     := bitstring.c getopts.c vec.c list.c queue.c  \
 				   refs.c time.c bitmap.c chan.c misc.c buf.c  \
 				   cond.c thread.c tlist.c bob.c trace.c       \
 				   finject.c vec_xc.c vec.c buf_xc.c buf.c     \
-				   c2lib.c cookie.c
+				   c2lib.c cookie.c ext.c
 
 lib_HEADERS                     := vec.h vec_xc.h buf.h buf_xc.h
 
diff --git a/db/extmap.c b/db/extmap.c
index def190a..85ab4e5 100644
--- a/db/extmap.c
+++ b/db/extmap.c
@@ -17,9 +17,9 @@
  * Original creation date: 08/13/2010
  */
 
-#include <stdio.h>     /* asprintf */
-#include <stdlib.h>
-#include <string.h>
+#ifndef __KERNEL__
+#include <stdlib.h>      /* printf() */ //todo replace printf by C2_LOG
+#endif
 
 #include "lib/vec.h"
 #include "lib/errno.h"
@@ -70,13 +70,16 @@
    @{
  */
 
-/*
+
+#if 0
+#ifndef __KERNEL__
 static void key_print(const struct c2_emap_key *k)
 {
 	printf("%08lx.%08lx:%08lx", k->ek_prefix.u_hi, k->ek_prefix.u_lo,
 	       k->ek_offset);
 }
-*/
+#endif
+#endif
 
 static int emap_cmp(struct c2_table *table,
 		    const void *key0, const void *key1)
@@ -84,7 +87,9 @@ static int emap_cmp(struct c2_table *table,
 	const struct c2_emap_key *a0 = key0;
 	const struct c2_emap_key *a1 = key1;
 
-/*	static const char compare[] = "<=>";
+#if 0
+#ifndef __KERNEL__
+	static const char compare[] = "<=>";
 
 	key_print(a0);
 	printf(" %c ", compare[(c2_uint128_cmp(&a0->ek_prefix,
@@ -92,7 +97,9 @@ static int emap_cmp(struct c2_table *table,
 				  C2_3WAY(a0->ek_offset,
 					  a1->ek_offset)) + 1]);
 	key_print(a1);
-	printf("\n"); */
+	printf("\n");
+#endif
+#endif
 	return c2_uint128_cmp(&a0->ek_prefix, &a1->ek_prefix) ?:
 		C2_3WAY(a0->ek_offset, a1->ek_offset);
 }
diff --git a/layout/composite.c b/layout/composite.c
index 1f443a6..b3c7837 100644
--- a/layout/composite.c
+++ b/layout/composite.c
@@ -300,45 +300,62 @@ static c2_bcount_t composite_recsize(const struct c2_layout *l)
 	return 0;
 }
 
-/**
- * Implementation of lto_register for COMPOSITE layout type.
- *
- * Initialises table specifically required for COMPOSITE layout type.
- */
+/** Implementation of lto_register for COMPOSITE layout type. */
 static int composite_register(struct c2_layout_domain *dom,
 			      const struct c2_layout_type *lt)
 {
-	/*
-	@code
 	struct composite_schema_data *csd;
+	int                           rc;
 
-	C2_ALLOC_PTR(csd);
+	C2_PRE(c2_layout__domain_invariant(dom));
+	C2_PRE(lt != NULL);
+	C2_PRE(IS_IN_ARRAY(lt->lt_id, dom->ld_type));
+	C2_PRE(dom->ld_type_data[lt->lt_id] == NULL);
 
-	Initialise csd->csd_comp_layout_ext_map table.
+	C2_ENTRY("Layout_type_id %lu", (unsigned long)lt->lt_id);
 
-	dom->ld_type_data[lt->lt_id] = csd;
-	@endcode
-	*/
-	return 0;
+	if (C2_FI_ENABLED("mem_err")) { csd = NULL; goto err1_injected; }
+	C2_ALLOC_PTR(csd);
+err1_injected:
+	if (csd == NULL) {
+		c2_layout__log("composite_register", "C2_ALLOC_PTR() failed",
+			       &c2_addb_oom, &layout_global_ctx, LID_NONE,
+			       -ENOMEM);
+		return -ENOMEM;
+	}
+
+	if (C2_FI_ENABLED("emap_init_err"))
+		{ rc = -EEXIST; goto err2_injected; }
+	rc = c2_emap_init(&csd->csd_comp_layout_ext_map, dom->ld_dbenv,
+			  "comp_layout_ext_map");
+err2_injected:
+	if (rc == 0)
+		dom->ld_type_data[lt->lt_id] = csd;
+	else {
+		c2_layout__log("composite_register", "c2_emap_init() failed",
+			       &c2_addb_func_fail, &layout_global_ctx,
+			       LID_NONE, rc);
+		c2_free(csd);
+	}
+	C2_LEAVE("Layout_type_id %lu, rc %d", (unsigned long)lt->lt_id, rc);
+	return rc;
 }
 
-/**
- * Implementation of lto_unregister for COMPOSITE layout type.
- *
- * Finalises table specifically required for COMPOSITE layout type.
- */
+/** Implementation of lto_unregister for COMPOSITE layout type. */
 static void composite_unregister(struct c2_layout_domain *dom,
 				 const struct c2_layout_type *lt)
 {
-	/*
-	@code
-	Finalise
-	dom->ld_type_data[lt->lt_id]->csd_comp_layout_ext_map
-	table.
+	struct composite_schema_data *csd;
+
+	C2_PRE(c2_layout__domain_invariant(dom));
+	C2_PRE(lt != NULL);
 
+	C2_ENTRY("Layout_type_id %lu", (unsigned long)lt->lt_id);
+	csd = dom->ld_type_data[lt->lt_id];
+	c2_emap_fini(&csd->csd_comp_layout_ext_map);
 	dom->ld_type_data[lt->lt_id] = NULL;
-	@endcode
-	*/
+	c2_free(csd);
+	C2_LEAVE("Layout_type_id %lu", (unsigned long)lt->lt_id);
 }
 
 /** Implementation of lto_max_recsize() for COMPOSITE layout type. */
diff --git a/layout/composite.h b/layout/composite.h
index 88eaecb..aefec7c 100644
--- a/layout/composite.h
+++ b/layout/composite.h
@@ -34,8 +34,8 @@
  */
 
 /* import */
+#include "db/extmap.h"      /* struct c2_emap */
 #include "colibri/magic.h"
-#include "db/extmap.h"	    /* struct c2_emap */
 #include "layout/layout.h"
 
 /* export */
diff --git a/layout/list_enum.c b/layout/list_enum.c
index a134622..230d194 100644
--- a/layout/list_enum.c
+++ b/layout/list_enum.c
@@ -267,7 +267,7 @@ static int list_register(struct c2_layout_domain *dom,
 	C2_PRE(c2_layout__domain_invariant(dom));
 	C2_PRE(et != NULL);
 	C2_PRE(IS_IN_ARRAY(et->let_id, dom->ld_enum));
-	C2_PRE(dom->ld_type_data[et->let_id] == NULL);
+	C2_PRE(dom->ld_enum_data[et->let_id] == NULL);
 
 	C2_ENTRY("Enum_type_id %lu", (unsigned long)et->let_id);
 
@@ -287,7 +287,7 @@ err1_injected:
 			   "cob_lists", DEFAULT_DB_FLAG, &cob_lists_table_ops);
 err2_injected:
 	if (rc == 0)
-		dom->ld_type_data[et->let_id] = lsd;
+		dom->ld_enum_data[et->let_id] = lsd;
 	else {
 		c2_layout__log("list_register", "c2_table_init() failed",
 			       &c2_addb_func_fail, &layout_global_ctx,
@@ -308,9 +308,9 @@ static void list_unregister(struct c2_layout_domain *dom,
 	C2_PRE(et != NULL);
 
 	C2_ENTRY("Enum_type_id %lu", (unsigned long)et->let_id);
-	lsd = dom->ld_type_data[et->let_id];
+	lsd = dom->ld_enum_data[et->let_id];
 	c2_table_fini(&lsd->lsd_cob_lists);
-	dom->ld_type_data[et->let_id] = NULL;
+	dom->ld_enum_data[et->let_id] = NULL;
 	c2_free(lsd);
 	C2_LEAVE("Enum_type_id %lu", (unsigned long)et->let_id);
 }
@@ -340,7 +340,7 @@ static int noninline_read(struct c2_fid *cob_list,
 		 (unsigned long long)stl->sl_base.l_id,
 		 (unsigned long)idx_start,
 		 (unsigned long)idx_end);
-	lsd = stl->sl_base.l_dom->ld_type_data[c2_list_enum_type.let_id];
+	lsd = stl->sl_base.l_dom->ld_enum_data[c2_list_enum_type.let_id];
 	C2_ASSERT(lsd != NULL);
 
 	if (C2_FI_ENABLED("cursor_init_err"))
@@ -509,7 +509,7 @@ static int noninline_write(const struct c2_layout_enum *e,
 		 (unsigned long)idx_start,
 		 (unsigned long)list_enum->lle_nr);
 	cob_list = list_enum->lle_list_of_cobs;
-	lsd = e->le_sl->sl_base.l_dom->ld_type_data[c2_list_enum_type.let_id];
+	lsd = e->le_sl->sl_base.l_dom->ld_enum_data[c2_list_enum_type.let_id];
 	C2_ASSERT(lsd != NULL);
 
 	if (C2_FI_ENABLED("cursor_init_err"))
-- 
1.8.3.2

