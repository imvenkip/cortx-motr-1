From adfbe01b784902b3c6059063fecade633e8fd14d Mon Sep 17 00:00:00 2001
From: "trupti.patil" <trupti_patil@xyratex.com>
Date: Fri, 26 Apr 2013 18:18:07 +0530
Subject: [PATCH 123/172] Including layer_invarinat() in composite_invariant()

Some code optimizations
addition of some extent kinds in the UT
---
 layout/composite.c          | 696 +++++++++++++++++---------------------------
 layout/composite.h          |  38 +--
 layout/composite_internal.h |  48 ++-
 layout/ut/composite.c       | 270 +++++++++--------
 layout/ut/composite.h       |   3 +
 layout/ut/layout.c          |  14 +-
 6 files changed, 467 insertions(+), 602 deletions(-)

diff --git a/layout/composite.c b/layout/composite.c
index 0ade807..76fd146 100644
--- a/layout/composite.c
+++ b/layout/composite.c
@@ -130,26 +130,6 @@ static bool composite_allocated_invariant(const struct m0_composite_layout *cl)
 		_0C(comp_layer_tlist_is_empty(&cl->cl_layers));
 }
 
-static bool composite_invariant(const struct m0_composite_layout *cl)
-{
-	/* Used to verify that the layers are sequentially ordered. */
-	uint32_t i = 0;
-
-	return
-		_0C(m0_composite_layout_bob_check(cl)) &&
-		m0_layout__invariant(&cl->cl_base) &&
-		_0C(cl->cl_layers_nr ==
-		    comp_layer_tlist_length(&cl->cl_layers)) &&
-		m0_tl_forall(comp_layer, layer, &cl->cl_layers,
-			     _0C(layer->clr_cl == &cl->cl_base) &&
-			     m0_layout__invariant(layer->clr_sl) &&
-			     _0C(layer->clr_idx == i++) &&
-			     _0C(layer->clr_extents_nr > 0) &&
-			     _0C(layer->clr_extents_nr ==
-				 m0_composite_layer_ext_tlist_length(
-							&layer->clr_extents)));
-}
-
 /**
  * Verifies that all the extents are back-to-back and that they cover
  * the entire offset namespace that is from 0 to M0_BINDEX_MAX.
@@ -160,6 +140,8 @@ static bool layer_invariant(const struct m0_composite_layer *layer)
 	m0_bindex_t addr = 0;
 
 	return
+		m0_layout__invariant(layer->clr_sl) &&
+		_0C(layer->clr_extents_nr > 0) &&
 		_0C(layer->clr_extents_nr ==
 		    m0_composite_layer_ext_tlist_length(&layer->clr_extents)) &&
 		m0_tl_forall(m0_composite_layer_ext, lr_ext,
@@ -174,6 +156,22 @@ static bool layer_invariant(const struct m0_composite_layer *layer)
 			     ++i);
 }
 
+static bool composite_invariant(const struct m0_composite_layout *cl)
+{
+	/* Used to verify that the layers are sequentially ordered. */
+	uint32_t i = 0;
+
+	return
+		_0C(m0_composite_layout_bob_check(cl)) &&
+		m0_layout__invariant(&cl->cl_base) &&
+		_0C(cl->cl_layers_nr ==
+		    comp_layer_tlist_length(&cl->cl_layers)) &&
+		m0_tl_forall(comp_layer, layer, &cl->cl_layers,
+			     _0C(layer->clr_cl == &cl->cl_base) &&
+			     _0C(layer->clr_idx == i++) &&
+			     layer_invariant(layer));
+}
+
 static bool composite_instance_invariant(
 				const struct m0_composite_instance *ci)
 {
@@ -357,7 +355,6 @@ static int layer_inmem_add(struct m0_composite_layout *cl,
 	M0_CNT_INC(cl->cl_layers_nr);
 
 	*lr = layer;
-	M0_POST(layer_invariant(layer));
 	M0_POST(composite_invariant(cl));
 	M0_LEAVE("lid %llu, layer %lu", (unsigned long long)cl->cl_base.l_id,
 		 (unsigned long)layer->clr_idx);
@@ -380,17 +377,14 @@ static void layer_inmem_delete(struct m0_composite_layout *cl,
 			       struct m0_composite_layer *layer)
 {
 	M0_PRE(layer->clr_idx == cl->cl_layers_nr - 1);
-
 	M0_ENTRY("lid %llu, layer %lu", (unsigned long long)cl->cl_base.l_id,
 		 (unsigned long)layer->clr_idx);
-
 	comp_layer_tlink_del_fini(layer);
 	M0_CNT_DEC(cl->cl_layers_nr);
 	m0_layout_put(layer->clr_sl);
 	extlist_free(&layer->clr_extents);
 	M0_POST(layer->clr_idx == cl->cl_layers_nr);
 	m0_free(layer);
-	M0_POST(composite_invariant(cl));
 	M0_LEAVE("lid %llu", (unsigned long long)cl->cl_base.l_id);
 }
 
@@ -657,18 +651,14 @@ static int sublayout_ids_inbuf_read(struct m0_composite_layout *cl,
 	return 0;
 }
 
-//todo loc
-static int ext_inmem_add_internal(struct m0_composite_layer *layer,
-				  struct m0_layout *l,
-				  struct m0_tl *extlist,
-				  const struct m0_ext *ext,
-				  uint64_t ext_state,
-				  uint32_t add_position,
-				  struct m0_composite_layer_extent *
-							adjacent_lr_ext);
-
-static void ext_inmem_del_internal(struct m0_composite_layer *layer,
-				   struct m0_composite_layer_extent *lr_ext);
+static int ext_inmem_add_internal(
+			struct m0_composite_layer *layer,
+			const struct m0_ext *ext,
+			enum m0_composite_layer_ext_state ext_state,
+			uint32_t add_position,
+			struct m0_composite_layer_extent *adjacent_lr_ext);
+static void ext_inmem_del(struct m0_composite_layer *layer,
+			  struct m0_composite_layer_extent *lr_ext);
 
 /*
  * Extent lists are stored in the auxiliary table for the composite layout viz.
@@ -680,20 +670,17 @@ static void ext_inmem_del_internal(struct m0_composite_layer *layer,
  */
 static int extlist_inbuf_read(struct m0_composite_layout *cl,
 			      struct m0_composite_layer *layer,
-			      struct m0_bufvec_cursor *cur,
-			      uint32_t extents_nr)
+			      struct m0_bufvec_cursor *cur)
 {
 	struct m0_composite_layer_extent *lr_ext;
-	struct m0_ext                    *ext;
-	uint64_t                         *ext_state;
+	struct layer_header              *lr_header;
+	struct layer_buf_ext             *buf_ext;
 	uint32_t                          i;
 	int                               rc = 0;
 
-	M0_PRE(m0_bufvec_cursor_step(cur) >= extents_nr * sizeof *ext);
-
-	M0_ENTRY("lid %llu, extents_nr %lu",
-		 (unsigned long long)cl->cl_base.l_id,
-		 (unsigned long)extents_nr);
+	M0_PRE(composite_invariant(cl));
+	M0_ENTRY("lid %llu, layer %lu", (unsigned long long)cl->cl_base.l_id,
+		 (unsigned long)layer->clr_idx);
 	/*
 	 * Delete the single extent added by default when the layer got added.
 	 * Then serially add the the extents read from the buffer. Do not need
@@ -703,97 +690,98 @@ static int extlist_inbuf_read(struct m0_composite_layout *cl,
 	lr_ext = m0_composite_layer_ext_tlist_head(&layer->clr_extents);
 	M0_ASSERT(lr_ext->cle_ext.e_start == 0 &&
 		  lr_ext->cle_ext.e_end == M0_BINDEX_MAX + 1);
-	ext_inmem_del_internal(layer, lr_ext);
+	ext_inmem_del(layer, lr_ext);
+
+	lr_header = m0_bufvec_cursor_addr(cur);
+	m0_bufvec_cursor_move(cur, sizeof *lr_header);
+	M0_ASSERT(lr_header->clh_idx == layer->clr_idx);
+	if (lr_header->clh_extents_nr == 0) {
+		M0_LOG(M0_ERROR, "lid %llu, layer %lu, No extent is "
+		       "present in the buffer",
+		       (unsigned long long)cl->cl_base.l_id,
+		       (unsigned long)layer->clr_idx);
+		return -EINVAL;;
+	}
 
-	for (i = 0; i < extents_nr; ++i) {
-		ext = m0_bufvec_cursor_addr(cur);
-		m0_bufvec_cursor_move(cur, sizeof *ext);
-		ext_state = m0_bufvec_cursor_addr(cur);
-		m0_bufvec_cursor_move(cur, sizeof *ext_state);
+	M0_PRE(m0_bufvec_cursor_step(cur) >=
+	       lr_header->clh_extents_nr * sizeof *buf_ext);
 
-		if (m0_ext_is_empty(ext) ||
-		    !M0_IN(*ext_state, (M0_CLRES_HOLE, M0_CLRES_VALID,
-				        M0_CLRES_FLATTENING))) {
+	for (i = 0; i < lr_header->clh_extents_nr; ++i) {
+		buf_ext = m0_bufvec_cursor_addr(cur);
+		m0_bufvec_cursor_move(cur, sizeof *buf_ext);
+
+		if (m0_ext_is_empty(&buf_ext->lbe_ext) ||
+		    !M0_IN(buf_ext->lbe_state, (M0_CLRES_HOLE, M0_CLRES_VALID,
+						M0_CLRES_FLATTENING))) {
 			m0_layout__log("extlist_inbuf_read",
 				       "Invalid extent found in the buffer",
 				       M0_LAYOUT_ADDB_LOC_COMP_ELIST_READ_2,
 				       &cl->cl_base.l_addb_ctx,
 				       cl->cl_base.l_id, -ENOMEM);
-			extlist_free(&layer->clr_extents);
 			return -EINVAL;
 		}
-		rc = ext_inmem_add_internal(layer, NULL, NULL,
-					    ext, *ext_state,
+		rc = ext_inmem_add_internal(layer, &buf_ext->lbe_ext,
+					    buf_ext->lbe_state,
 					    ADD_AT_TAIL, NULL);
 		if (rc != 0) {
 			M0_LOG(M0_ERROR, "lid %llu, Extent could not be "
 			       "added to the list",
 			       (unsigned long long)cl->cl_base.l_id);
-			//todo extlist_free(extlist);
 			return rc;
 		}
 	}
-	M0_POST(layer_invariant(layer));
-	M0_POST(composite_invariant(cl)); //todo tempo
+	M0_POST(composite_invariant(cl));
 	M0_RETURN(rc);
 }
 
 static int ext_inmem_write(struct m0_composite_layout *cl,
 			   struct m0_composite_layer *layer,
 			   const struct m0_ext *ext,
-			   uint64_t new_ext_state,
+			   enum m0_composite_layer_ext_state new_ext_state,
 			   uint32_t ext_validation_kind);
-/**
- * Parses 'the composite layout type specific information including all the
- * layers' from the buffer provided and adds it to the in-memory layout.
- */
-static int layers_inbuf_read(struct m0_composite_layout *cl,
-			     struct m0_bufvec_cursor *cur,
-			     uint32_t user_count,
-			     uint32_t layers_nr,
-			     uint64_t *sublayout_id_list)
+static int extlist_indb_read(struct m0_composite_layout *cl,
+			     struct m0_composite_layer *layer,
+			     struct m0_db_tx *tx);
+
+static int layers_read(struct m0_composite_layout *cl,
+		       struct m0_bufvec_cursor *cur,
+		       enum m0_layout_xcode_op op,
+		       struct m0_db_tx *tx,
+		       uint32_t user_count,
+		       uint32_t layers_nr,
+		       uint64_t *sublayout_id_list)
 {
-	struct composite_layer_header *lr_header;
-	struct m0_layout              *sublayout;
-	struct m0_composite_layer     *layer;
-	bool                           populate_done = false;
-	int                            rc = 0;
-	uint32_t                       i;
+	struct m0_layout          *sublayout;
+	struct m0_composite_layer *layer;
+	bool                       populate_done = false;
+	uint32_t                   i;
+	int                        rc = 0;
 
 	M0_PRE(composite_allocated_invariant(cl));
 	M0_PRE(cur != NULL);
-	M0_PRE(m0_bufvec_cursor_step(cur) >= layers_nr * sizeof *lr_header);
+	M0_PRE(m0_bufvec_cursor_step(cur) >=
+	       layers_nr * sizeof(struct layer_header));
+	M0_PRE(M0_IN(op, (M0_LXO_DB_LOOKUP, M0_LXO_BUFFER_OP)));
+	M0_PRE(ergo(op == M0_LXO_DB_LOOKUP, tx != NULL));
 
 	M0_ENTRY("lid %llu, user_count %lu, layers_nr %lu",
 		 (unsigned long long)cl->cl_base.l_id,
 		 (unsigned long)user_count, (unsigned long)layers_nr);
 
-	/* Read the extent list associated with each layer. */
 	for (i = 0; i < layers_nr; ++i) {
-		lr_header = m0_bufvec_cursor_addr(cur);
-		m0_bufvec_cursor_move(cur, sizeof *lr_header);
-		M0_ASSERT(lr_header->clh_idx == i);
-		if (lr_header->clh_extents_nr == 0) {
-			rc = -EINVAL;
-			M0_LOG(M0_ERROR, "lid %llu, layer %lu, No extent is "
-			       "present in the buffer",
-			       (unsigned long long)cl->cl_base.l_id,
-			       (unsigned long)i);
-			break;
-		}
-
 		sublayout = layout_find(cl->cl_base.l_dom,
 					sublayout_id_list[i]);
 		if (sublayout == NULL) {
 			rc = -EINVAL;
-			M0_LOG(M0_ERROR, "lid %llu, sublayout with lid %llu "
-			       "does not exist",
+			M0_LOG(M0_ERROR, "lid %llu, layer %lu, sublayout with "
+			       "lid %llu does not exist",
 			       (unsigned long long)cl->cl_base.l_id,
+			       (unsigned long)i,
 			       (unsigned long long)sublayout_id_list[i]);
 			break;
 		}
 
-		if (lr_header->clh_idx == 0) { /* Zeroth layer */
+		if (i == 0) { /* Zeroth layer */
 			rc = composite_populate(cl, sublayout, user_count);
 			if (rc == 0) {
 				layer = comp_layer_tlist_head(&cl->cl_layers);
@@ -809,11 +797,13 @@ static int layers_inbuf_read(struct m0_composite_layout *cl,
 		m0_layout_put(sublayout);
 
 		if (rc == 0) {
-			rc = extlist_inbuf_read(cl, layer, cur,
-						lr_header->clh_extents_nr);
+			if (op == M0_LXO_BUFFER_OP)
+				rc = extlist_inbuf_read(cl, layer, cur);
+			else
+				rc = extlist_indb_read(cl, layer, tx);
 			if (rc != 0) {
 				M0_LOG(M0_ERROR, "lid %llu, layer %lu, Error "
-				       "while reading extlist from the buffer",
+				       "while reading extent list",
 				       (unsigned long long)cl->cl_base.l_id,
 				       (unsigned long)i);
 				break;
@@ -837,31 +827,6 @@ static int layers_inbuf_read(struct m0_composite_layout *cl,
 	M0_RETURN(rc);
 }
 
-#if 1 //todo loc
-/*
- * Layout DB related functions are defined towards the end of this file.
- * Hence some of those are forward declared here.
- */
-static int layer_indb_add(struct m0_composite_layout *cl,
-			  struct m0_composite_layer *layer,
-			  struct m0_db_tx *tx);
-static int layer_indb_delete(struct m0_composite_layout *cl,
-			     uint32_t layer_idx,
-			     uint64_t sublayout_id,
-			     struct m0_layout *sublayout,
-			     struct m0_db_tx *tx,
-			     bool in_update_path);
-static int layers_indb_read(struct m0_composite_layout *cl,
-			    struct m0_db_tx *tx,
-			    uint32_t user_count,
-			    uint32_t layers_nr,
-			    uint64_t *sublayout_id_list);
-static int layers_indb_add(struct m0_composite_layout *cl,
-			   struct m0_db_tx *tx);
-static int layers_indb_delete(struct m0_composite_layout *cl,
-			      struct m0_db_tx *tx, bool in_update_path);
-#endif
-
 /** Implementation of lo_decode() for composite layout type. */
 static int composite_decode(struct m0_layout *l,
 			    struct m0_bufvec_cursor *cur,
@@ -891,22 +856,10 @@ static int composite_decode(struct m0_layout *l,
 		       (unsigned long long)cl->cl_base.l_id);
 		return rc;
 	}
-	M0_ASSERT(layers_nr > 0);
-	if (op == M0_LXO_BUFFER_OP) {
-		rc = layers_inbuf_read(cl, cur, user_count,
-				       layers_nr, sublayout_id_list);
-		if (rc != 0)
-			M0_LOG(M0_ERROR, "lid %llu, failed to read layout from "
-			       "the buffer",
-			       (unsigned long long)cl->cl_base.l_id);
-	} else {
-		rc = layers_indb_read(cl, tx, user_count,
-				      layers_nr, sublayout_id_list);
-		if (rc != 0)
-			M0_LOG(M0_ERROR, "lid %llu, failed to read layout from "
-			       "the DB",
-			       (unsigned long long)cl->cl_base.l_id);
-	}
+
+	/* Read layers either from the buffer or from the DB, as applicable. */
+	rc = layers_read(cl, cur, op, tx, user_count, layers_nr,
+			 sublayout_id_list);
 	m0_free(sublayout_id_list);
 	M0_POST(ergo(rc == 0, composite_invariant(cl)));
 	M0_POST(ergo(rc != 0 && cl->cl_layers_nr == 0,
@@ -921,8 +874,9 @@ static void layers_inbuf_write(const struct m0_composite_layout *cl,
 			       struct m0_bufvec_cursor *out)
 {
 	struct m0_composite_layer        *layer;
-	struct composite_layer_header     lr_header;
+	struct layer_header               lr_header;
 	struct m0_composite_layer_extent *lr_ext;
+	struct layer_buf_ext              buf_ext;
 	m0_bcount_t                       nbytes;
 
 	M0_ENTRY("lid %llu", (unsigned long long)cl->cl_base.l_id);
@@ -938,21 +892,27 @@ static void layers_inbuf_write(const struct m0_composite_layout *cl,
 		M0_ASSERT(m0_bufvec_cursor_step(out) >=
 			  layer->clr_extents_nr * sizeof lr_ext->cle_ext);
 		m0_tl_for(m0_composite_layer_ext, &layer->clr_extents, lr_ext) {
+			buf_ext.lbe_ext = lr_ext->cle_ext;
+			buf_ext.lbe_state = lr_ext->cle_state;
 			nbytes = m0_bufvec_cursor_copyto(out,
-							&lr_ext->cle_ext,
-							sizeof lr_ext->cle_ext);
-			M0_ASSERT(nbytes == sizeof lr_ext->cle_ext);
-
-			nbytes = m0_bufvec_cursor_copyto(out,
-						     &lr_ext->cle_state,
-						     sizeof(lr_ext->cle_state));
-			M0_ASSERT(nbytes == sizeof(lr_ext->cle_state));
+							 &buf_ext,
+							 sizeof buf_ext);
+			M0_ASSERT(nbytes == sizeof buf_ext);
 		} m0_tl_endfor;
 	} m0_tl_endfor;
 
 	M0_LEAVE("lid %llu", (unsigned long long)cl->cl_base.l_id);
 }
 
+/*
+ * Layout DB related functions are defined towards the end of this file.
+ * Hence some of those are forward declared here.
+ */
+static int layers_indb_add(struct m0_composite_layout *cl,
+			   struct m0_db_tx *tx);
+static int layers_indb_delete(struct m0_composite_layout *cl,
+			      struct m0_db_tx *tx, bool in_update_path);
+
 /** Implementation of lo_encode() for composite layout type. */
 static int composite_encode(struct m0_layout *l,
 			    enum m0_layout_xcode_op op,
@@ -963,7 +923,6 @@ static int composite_encode(struct m0_layout *l,
 	struct m0_layout_composite_rec  cl_rec;
 	m0_bcount_t                     nbytes;
 	struct m0_composite_layer      *layer;
-	uint32_t                        i;
 	int                             rc;
 
 	M0_PRE(l != NULL);
@@ -1002,14 +961,10 @@ static int composite_encode(struct m0_layout *l,
 		rc = 0;
 	} else if (op == M0_LXO_DB_ADD) {
 		rc = layers_indb_add(cl, tx);
-		if (rc == 0) {
-			for (i = 1; i < cl->cl_layers_nr; ++i) {
-				layer = layer_find(cl, i);
-				rc = layer_indb_add(cl, layer, tx);
-				if (rc != 0)
-					break;
-			}
-		}
+		if (rc != 0)
+			M0_LOG(M0_ERROR, "lid %llu, layout could not be "
+			       "added to the DB",
+			       (unsigned long long)cl->cl_base.l_id);
 	} else if (op == M0_LXO_DB_UPDATE) {
 		/*
 		 * As a part of the layout update for a composite layout, all
@@ -1020,14 +975,14 @@ static int composite_encode(struct m0_layout *l,
 		rc = layers_indb_delete(cl, tx, IN_UPDATE_PATH);
 		if (rc == 0) {
 			rc = layers_indb_add(cl, tx);
-			if (rc == 0) {
-				for (i = 1; i < cl->cl_layers_nr; ++i) {
-					layer = layer_find(cl, i);
-					rc = layer_indb_add(cl, layer, tx);
-					if (rc != 0)
-						break;
-				}
-			}
+			if (rc != 0)
+				M0_LOG(M0_ERROR, "lid %llu, layout could not "
+				       "be updated to the DB",
+				       (unsigned long long)cl->cl_base.l_id);
+		} else {
+			M0_LOG(M0_ERROR, "lid %llu, existing layout could not "
+			       "be deleted from the DB so as to update it",
+			       (unsigned long long)cl->cl_base.l_id);
 		}
 	} else {
 		rc = layers_indb_delete(cl, tx, !IN_UPDATE_PATH);
@@ -1047,7 +1002,7 @@ static int composite_encode(struct m0_layout *l,
  */
 static int ext_inmem_find(struct m0_composite_layer *layer,
 			  const struct m0_ext *ext,
-			  uint64_t expected_ext_state,
+			  enum m0_composite_layer_ext_state expected_ext_state,
 			  struct m0_composite_layer_extent **lr_ext_out)
 {
 	struct m0_composite_layer_extent *lr_ext;
@@ -1090,19 +1045,17 @@ static int ext_inmem_find(struct m0_composite_layer *layer,
  * If the layer is not provided (in cases where layer is yet to be created),
  * then adds the extent directly to the extlist provided.
  */
-static int ext_inmem_add_internal(struct m0_composite_layer *layer,
-				  struct m0_layout *l,
-				  struct m0_tl *extlist, //todo check if reqd
-				  const struct m0_ext *ext,
-				  uint64_t ext_state,
-				  uint32_t add_position,
-				  struct m0_composite_layer_extent *
-							adjacent_lr_ext)
+static int ext_inmem_add_internal(
+			struct m0_composite_layer *layer,
+			const struct m0_ext *ext,
+			enum m0_composite_layer_ext_state ext_state,
+			uint32_t add_position,
+			struct m0_composite_layer_extent *adjacent_lr_ext)
 {
 	struct m0_composite_layer_extent *lr_ext;
+	struct m0_layout                 *l;
 
-	M0_PRE(ergo(layer == NULL, l != NULL && extlist != NULL));
-	M0_PRE(ergo(layer != NULL, l == NULL && extlist == NULL));
+	M0_PRE(layer != NULL);
 	M0_PRE(!m0_ext_is_empty(ext));
 	M0_PRE(M0_IN(ext_state, (M0_CLRES_HOLE, M0_CLRES_VALID,
 				 M0_CLRES_FLATTENING)));
@@ -1112,10 +1065,7 @@ static int ext_inmem_add_internal(struct m0_composite_layer *layer,
 		    m0_composite_layer_ext_tlink_is_in(adjacent_lr_ext)));
 	M0_PRE(ergo(add_position == ADD_AT_TAIL, adjacent_lr_ext == NULL));
 
-	if (l == NULL)
-		l = layer->clr_cl;
-	if (extlist == NULL)
-		extlist = &layer->clr_extents;
+	l = layer->clr_cl;
 	M0_ENTRY("lid %llu, layer %lu , e_start %llu, e_end %llu, "
 		 "e_state %llu, add_position %lu, "
 		 "adjacent_ext_start %llu, adjacent_ext_end %llu",
@@ -1149,7 +1099,8 @@ static int ext_inmem_add_internal(struct m0_composite_layer *layer,
 			m0_composite_layer_ext_tlist_add_before(adjacent_lr_ext,
 								lr_ext);
 	} else
-		m0_composite_layer_ext_tlink_init_at_tail(lr_ext, extlist);
+		m0_composite_layer_ext_tlink_init_at_tail(lr_ext,
+							  &layer->clr_extents);
 
 	if (layer != NULL)
 		M0_CNT_INC(layer->clr_extents_nr);
@@ -1162,7 +1113,7 @@ static int ext_inmem_add_internal(struct m0_composite_layer *layer,
  */
 static int ext_inmem_add(struct m0_composite_layer *layer,
 			 const struct m0_ext *ext,
-			 uint64_t ext_state)
+			 enum m0_composite_layer_ext_state ext_state)
 {
 	struct m0_composite_layer_extent *lr_ext_to_insert_before;
 	struct m0_composite_layer_extent *lr_ext_to_insert_after;
@@ -1185,35 +1136,29 @@ static int ext_inmem_add(struct m0_composite_layer *layer,
 		if (ext->e_start <= lr_ext->cle_ext.e_start)
 			break;
 	} m0_tl_endfor;
-#if 0 //todo rm
-	M0_ASSERT(lr_ext_to_insert_after != NULL ||
-		  lr_ext_to_insert_before != NULL);
-#endif
 
 	if (lr_ext_to_insert_after != NULL)
-		rc = ext_inmem_add_internal(layer, NULL, NULL,
-					    ext, ext_state, ADD_AFTER,
+		rc = ext_inmem_add_internal(layer, ext, ext_state, ADD_AFTER,
 					    lr_ext_to_insert_after);
 	else if (lr_ext_to_insert_before != NULL)
-		rc = ext_inmem_add_internal(layer, NULL, NULL,
-					    ext, ext_state, ADD_BEFORE,
+		rc = ext_inmem_add_internal(layer, ext, ext_state, ADD_BEFORE,
 					    lr_ext_to_insert_before);
 	else
-		rc = ext_inmem_add_internal(layer, NULL, NULL,
-					    ext, ext_state, ADD_AT_TAIL, NULL);
+		rc = ext_inmem_add_internal(layer, ext, ext_state, ADD_AT_TAIL,
+					    NULL);
 	if (rc != 0)
 		M0_LOG(M0_ERROR, "lid %llu, extent could not be added to "
-		       "memory",
-		       (unsigned long long)layer->clr_cl->l_id);
+		       "memory", (unsigned long long)layer->clr_cl->l_id);
 	M0_RETURN(rc);
 }
 
-M0_INTERNAL int m0_composite_layer_ext_lookup(struct m0_composite_layout *cl,
-					      m0_bindex_t offset,
-					      struct m0_ext *ext,
-					      uint32_t *layer_idx,
-					      uint64_t *ext_state,
-					      struct m0_layout **sublayout)
+M0_INTERNAL int m0_composite_layer_ext_lookup(
+				struct m0_composite_layout *cl,
+				m0_bindex_t offset,
+				struct m0_ext *ext,
+				uint32_t *layer_idx,
+				enum m0_composite_layer_ext_state *ext_state,
+				struct m0_layout **sublayout)
 {
 	struct m0_composite_layer        *layer;
 	struct m0_composite_layer_extent *lr_ext;
@@ -1274,8 +1219,8 @@ M0_INTERNAL int m0_composite_layer_ext_lookup(struct m0_composite_layout *cl,
 	return rc;
 }
 
-static void ext_inmem_del_internal(struct m0_composite_layer *layer,
-				   struct m0_composite_layer_extent *lr_ext)
+static void ext_inmem_del(struct m0_composite_layer *layer,
+			  struct m0_composite_layer_extent *lr_ext)
 {
 	M0_LOG(M0_DEBUG, "lid %llu, layer %lu, e_start %llu, e_end %llu, "
 	       "e_state %llu", (unsigned long long)layer->clr_cl->l_id,
@@ -1314,8 +1259,8 @@ static int ext_split_internal(struct m0_composite_layer *layer,
 		if (len != 0) {
 			ext.e_start = scan;
 			ext.e_end = scan = scan + len;
-			rc = ext_inmem_add_internal(layer, NULL, NULL,
-						    &ext, vec->iv_index[i],
+			rc = ext_inmem_add_internal(layer, &ext,
+						    vec->iv_index[i],
 						    ADD_BEFORE, lr_ext);
 			if (rc != 0) {
 				M0_LOG(M0_ERROR, "lid %llu, Extent could not "
@@ -1326,7 +1271,7 @@ static int ext_split_internal(struct m0_composite_layer *layer,
 			}
 		}
 	}
-	ext_inmem_del_internal(layer, lr_ext);
+	ext_inmem_del(layer, lr_ext);
 	M0_RETURN(rc);
 }
 
@@ -1437,7 +1382,7 @@ static int ext_inmem_validate(struct m0_composite_layout *cl,
 static int ext_inmem_write(struct m0_composite_layout *cl,
 			   struct m0_composite_layer *layer,
 			   const struct m0_ext *ext,
-			   uint64_t new_ext_state,
+			   enum m0_composite_layer_ext_state new_ext_state,
 			   uint32_t ext_validation_kind)
 {
 	struct m0_composite_layer_extent *lr_ext;
@@ -1450,7 +1395,7 @@ static int ext_inmem_write(struct m0_composite_layout *cl,
 	int                               rc;
 	int                               rc1;
 
-	M0_PRE(layer_invariant(layer));
+	M0_PRE(composite_invariant(cl));
 	M0_PRE(!m0_ext_is_empty(ext));
 
 	/* Validate the 'ext' and find the nearest extent from the list. */
@@ -1511,15 +1456,15 @@ static int ext_inmem_write(struct m0_composite_layout *cl,
 	 *
 	 * This logic for the extent addition has been inherited from
 	 * m0_emap_paste() that has been exercised for some time now and is
-	 * understood to be highly efficient! For an example illustrating the
-	 * functioning of m0_emap_paste(), see the note added in
-	 * ext_indb_write_internal().
+	 * understood to be highly efficient! For 'an example illustrating the
+	 * functioning of m0_emap_paste()', see the note added in
+	 * ext_indb_write().
 	 */
 
 	is_ultimate_ext_add = false;
 	while (!m0_ext_is_empty(&ext0)) {
 		m0_bcount_t    length[3];
-		m0_bindex_t    bstart[3] = { 0 };
+		uint64_t       bstart[3] = { 0 };
 		m0_bcount_t    consumed;
 		struct m0_ext  clip;
 		bool           split_required;
@@ -1560,14 +1505,13 @@ static int ext_inmem_write(struct m0_composite_layout *cl,
 		}
 
 		/*
-		 * ext_split_internal() may replace the current node that is
+		 * ext_split_internal() may replace the current node, that is
 		 * lr_ext_to_insert_into, with multiple smaller segments. Hence,
 		 * store the next node before invoking ext_split_internal().
 		 */
 		lr_ext_next = m0_composite_layer_ext_tlist_next(
 							&layer->clr_extents,
 							lr_ext_to_insert_into);
-
 		if (split_required) {
 			rc = ext_split_internal(layer, lr_ext_to_insert_into,
 						&vec,
@@ -1583,7 +1527,7 @@ static int ext_inmem_write(struct m0_composite_layout *cl,
 			rc = 0;
 
 		if (delete_required)
-			ext_inmem_del_internal(layer, lr_ext_to_del);
+			ext_inmem_del(layer, lr_ext_to_del);
 
 		ext0.e_start += consumed;
 		M0_ASSERT(ext0.e_start <= ext0.e_end);
@@ -1624,7 +1568,7 @@ static int ext_inmem_write(struct m0_composite_layout *cl,
 		 * failure, thus sacrificing the layer_invariant() and in turn
 		 * the composite_invariant() in that case.
 		 */
-		M0_POST(layer_invariant(layer));
+		M0_POST(composite_invariant(cl));
 	}
 	M0_LEAVE("lid %llu, layer %lu, rc %d",
 		 (unsigned long long)cl->cl_base.l_id,
@@ -1632,10 +1576,11 @@ static int ext_inmem_write(struct m0_composite_layout *cl,
 	return rc;
 }
 
-M0_INTERNAL int m0_composite_layer_ext_add(struct m0_composite_layout *cl,
-					   uint32_t layer_idx,
-					   const struct m0_ext *ext,
-					   uint64_t ext_state)
+M0_INTERNAL int m0_composite_layer_ext_add(
+				struct m0_composite_layout *cl,
+				uint32_t layer_idx,
+				const struct m0_ext *ext,
+				enum m0_composite_layer_ext_state ext_state)
 {
 	struct m0_composite_layer *layer;
 	int                        rc;
@@ -1655,12 +1600,11 @@ M0_INTERNAL int m0_composite_layer_ext_add(struct m0_composite_layout *cl,
 	layer = layer_find(cl, layer_idx);
 	rc = ext_inmem_write(cl, layer, ext, ext_state, EXT_MERGE_VALIDATION);
 	if (rc != 0)
-	m0_layout__log("m0_composite_layer_ext_add",
-		       "failed to add extent",
-		       M0_LAYOUT_ADDB_LOC_COMP_EXT_ADD,
-		       &cl->cl_base.l_addb_ctx, cl->cl_base.l_id, rc);
+		m0_layout__log("m0_composite_layer_ext_add",
+			       "failed to add extent",
+			       M0_LAYOUT_ADDB_LOC_COMP_EXT_ADD,
+			       &cl->cl_base.l_addb_ctx, cl->cl_base.l_id, rc);
 	m0_mutex_unlock(&cl->cl_base.l_lock);
-	M0_POST(layer_invariant(layer));
 	M0_POST(composite_invariant(cl));
 	M0_LEAVE("lid %llu, layer %lu, e_start %llu, e_end %llu, "
 		 "e_state %llu, rc %d", (unsigned long long)cl->cl_base.l_id,
@@ -1671,10 +1615,10 @@ M0_INTERNAL int m0_composite_layer_ext_add(struct m0_composite_layout *cl,
 }
 
 M0_INTERNAL int m0_composite_layer_ext_state_update(
-					struct m0_composite_layout *cl,
-					uint32_t layer_idx,
-					const struct m0_ext *ext,
-					uint64_t new_state)
+				struct m0_composite_layout *cl,
+				uint32_t layer_idx,
+				const struct m0_ext *ext,
+				enum m0_composite_layer_ext_state new_state)
 {
 	struct m0_composite_layer *layer;
 	int                        rc;
@@ -1690,15 +1634,13 @@ M0_INTERNAL int m0_composite_layer_ext_state_update(
 		 (unsigned long long)ext->e_end, (unsigned long long)new_state);
 	m0_mutex_lock(&cl->cl_base.l_lock);
 	layer = layer_find(cl, layer_idx);
-	rc = ext_inmem_write(cl, layer, ext, new_state,
-			     EXT_MERGE_VALIDATION);
+	rc = ext_inmem_write(cl, layer, ext, new_state, EXT_MERGE_VALIDATION);
 	if (rc != 0)
 		m0_layout__log("m0_composite_layer_ext_state_update",
 			       "failed to update extent state",
 			       M0_LAYOUT_ADDB_LOC_COMP_EXT_UPDATE,
 			       &cl->cl_base.l_addb_ctx, cl->cl_base.l_id, rc);
 	m0_mutex_unlock(&cl->cl_base.l_lock);
-	M0_POST(layer_invariant(layer));
 	M0_POST(composite_invariant(cl));
 	M0_LEAVE("lid %llu, layer %lu, e_start %llu, e_end %llu, "
 		 "e_state %llu, rc %d",
@@ -1734,7 +1676,6 @@ M0_INTERNAL int m0_composite_layer_ext_delete(struct m0_composite_layout *cl,
 			       M0_LAYOUT_ADDB_LOC_COMP_EXT_DELETE,
 			       &cl->cl_base.l_addb_ctx, cl->cl_base.l_id, rc);
 	m0_mutex_unlock(&cl->cl_base.l_lock);
-	M0_POST(layer_invariant(layer));
 	M0_POST(composite_invariant(cl));
 	M0_LEAVE("lid %llu, layer %lu, e_start %llu, e_end %llu, rc %d",
 		 (unsigned long long)cl->cl_base.l_id,
@@ -1802,10 +1743,10 @@ err1_injected:
 	return rc;
 }
 
-static int ext_indb_write_internal(struct m0_emap_cursor *it,
-				   struct m0_composite_layer *layer,
-				   const struct m0_ext *ext,
-				   uint64_t new_ext_state)
+static int ext_indb_write(struct m0_emap_cursor *it,
+			  struct m0_composite_layer *layer,
+			  const struct m0_ext *ext,
+			  uint64_t new_ext_state)
 {
 	struct m0_ext ext0 = *ext; /* A read-write copy. */
 	int           rc;
@@ -1825,8 +1766,7 @@ static int ext_indb_write_internal(struct m0_emap_cursor *it,
 	 * Here is an example to illustrate the sequence of the operations
 	 * performed by m0_emap_paste().
 	 *
-	 * For example, a layer contains an extent list (in-memory and in-DB)
-	 * as:
+	 * For example, a layer contains an extent list as:
 	 * ext[0]: [        0,        2200700)
 	 * ext[1]: [  2200700,       56668025)
 	 * ext[2]: [ 56668025,      111135350)
@@ -1874,9 +1814,9 @@ static struct m0_emap *emap_from_cl(const struct m0_composite_layout *cl)
 	return &csd->csd_layer_emap;
 }
 
-static int extmap_indb_add(struct m0_composite_layout *cl,
-			   struct m0_composite_layer *layer,
-			   struct m0_db_tx *tx)
+static int extents_indb_add(struct m0_composite_layout *cl,
+			    struct m0_composite_layer *layer,
+			    struct m0_db_tx *tx)
 {
 	struct m0_emap                   *emap;
 	struct m0_emap_cursor             it;
@@ -1896,11 +1836,10 @@ static int extmap_indb_add(struct m0_composite_layout *cl,
 				M0_CLRES_HOLE);
 err1_injected:
 	if (rc != 0) {
-		m0_layout__log("extmap_indb_add",
+		m0_layout__log("extents_indb_add",
 			       "failed to insert into layer_emap",
 			       M0_LAYOUT_ADDB_LOC_COMP_LAYER_EMAP_ADD_1,
-			       &cl->cl_base.l_addb_ctx, cl->cl_base.l_id,
-			       rc);
+			       &cl->cl_base.l_addb_ctx, cl->cl_base.l_id, rc);
 		return rc;
 	}
 
@@ -1912,7 +1851,6 @@ err1_injected:
 		 * likely that m0_emap_obj_delete() too would fail. Hence,
 		 * ignoring its status.
 		 */
-
 		M0_LEAVE("lid %llu, layer %lu, rc %d",
 			 (unsigned long long)cl->cl_base.l_id,
 			 (unsigned long)layer->clr_idx, rc);
@@ -1928,9 +1866,8 @@ err1_injected:
 		M0_ASSERT(M0_IN(lr_ext->cle_state, (M0_CLRES_HOLE,
 						    M0_CLRES_VALID,
 						    M0_CLRES_FLATTENING)));
-		rc = ext_indb_write_internal(&it, layer,
-					     &lr_ext->cle_ext,
-					     lr_ext->cle_state);
+		rc = ext_indb_write(&it, layer, &lr_ext->cle_ext,
+				    lr_ext->cle_state);
 		if (rc != 0) {
 			M0_LOG(M0_ERROR, "lid %llu, layer %lu, "
 			       "failed to write extent, rc %d",
@@ -1944,48 +1881,38 @@ err1_injected:
 	M0_RETURN(rc);
 }
 
-static int layer_indb_add(struct m0_composite_layout *cl,
-			  struct m0_composite_layer *layer,
-			  struct m0_db_tx *tx)
+/** Reads extent map from the DB ...todo */
+static int extlist_indb_read(struct m0_composite_layout *cl,
+			     struct m0_composite_layer *layer,
+			     struct m0_db_tx *tx)
 {
-	int rc;
+	struct m0_composite_layer_extent *lr_ext;
+	struct m0_emap                   *emap;
+	struct m0_emap_cursor             it;
+	struct m0_emap_seg               *seg;
+	int                               rc;
 
-	M0_PRE(composite_invariant(cl));
-	M0_PRE(tx != NULL);
 	M0_ENTRY("lid %llu, layer %lu", (unsigned long long)cl->cl_base.l_id,
 		 (unsigned long)layer->clr_idx);
-	/* Add 'the extent map for this layer' to the DB. */
-	rc = extmap_indb_add(cl, layer, tx);
-	if (rc == 0)
-		m0_layout_user_count_inc(layer->clr_sl);
-	M0_POST(composite_invariant(cl));
-	M0_RETURN(rc);
-}
 
-static int extentmap_indb_read(struct m0_composite_layout *cl,
-			       uint32_t layer_idx,
-			       struct m0_db_tx *tx,
-			       struct m0_tl *extlist,
-			       uint32_t *extents_nr)
-{
-	struct m0_emap        *emap;
-	struct m0_emap_cursor  it;
-	struct m0_emap_seg    *seg;
-	int                    rc;
-
-	M0_ENTRY("lid %llu, layer %lu", (unsigned long long)cl->cl_base.l_id,
-		 (unsigned long)layer_idx);
+	/*
+	 * Delete the single extent added by default when the layer got added.
+	 * Then serially add the the extents as read from the buffer.
+	 */
+	lr_ext = m0_composite_layer_ext_tlist_head(&layer->clr_extents);
+	M0_ASSERT(lr_ext->cle_ext.e_start == 0 &&
+		 lr_ext->cle_ext.e_end == M0_BINDEX_MAX + 1);
+	ext_inmem_del(layer, lr_ext);
 
 	emap = emap_from_cl(cl);
-	rc = emap_iterator_set(cl, emap, layer_idx, 0, tx, &it);
+	rc = emap_iterator_set(cl, emap, layer->clr_idx, 0, tx, &it);
 	if (rc != 0) {
 		M0_LEAVE("lid %llu, layer %lu, rc %d",
 			 (unsigned long long)cl->cl_base.l_id,
-			 (unsigned long)layer_idx, rc);
+			 (unsigned long)layer->clr_idx, rc);
 		return rc;
 	}
 	seg = m0_emap_seg_get(&it);
-	m0_composite_layer_ext_tlist_init(extlist);
 	while (1) {
 		M0_ASSERT(seg != NULL);
 		if (M0_FI_ENABLED("invalid_ext_state_err"))
@@ -1994,7 +1921,7 @@ static int extentmap_indb_read(struct m0_composite_layout *cl,
 		    !M0_IN(seg->ee_val, (M0_CLRES_HOLE, M0_CLRES_VALID,
 					 M0_CLRES_FLATTENING))) {
 			rc = -EINVAL;
-			m0_layout__log("extentmap_indb_read",
+			m0_layout__log("extlist_indb_read",
 				       "Invalid extent found in the DB",
 				       M0_LAYOUT_ADDB_LOC_COMP_EMAP_READ_3,
 				       &cl->cl_base.l_addb_ctx,
@@ -2002,8 +1929,7 @@ static int extentmap_indb_read(struct m0_composite_layout *cl,
 			break;
 		}
 
-		rc = ext_inmem_add_internal(NULL, &cl->cl_base, extlist,
-					    &seg->ee_ext, seg->ee_val,
+		rc = ext_inmem_add_internal(layer, &seg->ee_ext, seg->ee_val,
 					    ADD_AT_TAIL, NULL);
 		if (rc != 0)
 			break;
@@ -2014,98 +1940,6 @@ static int extentmap_indb_read(struct m0_composite_layout *cl,
 		seg = m0_emap_seg_get(&it);
 	}
 	m0_emap_close(&it);
-
-	if (rc == 0) {
-		*extents_nr = m0_composite_layer_ext_tlist_length(extlist);
-		M0_POST(*extents_nr > 0);
-	}
-	M0_RETURN(rc);
-}
-
-/**
- * Reads 'the composite layout type specific information including all the
- * layers' from the DB and adds it to the in-memory layout.
- */
-static int layers_indb_read(struct m0_composite_layout *cl,
-			    struct m0_db_tx *tx,
-			    uint32_t user_count,
-			    uint32_t layers_nr,
-			    uint64_t *sublayout_id_list)
-{
-	struct m0_layout                 *sublayout;
-	struct m0_tl                      extlist;
-	uint32_t                          extents_nr;
-	struct m0_composite_layer_extent *lr_ext;
-	struct m0_composite_layer        *layer;
-	uint32_t                          i; /* layer idx */
-	int                               rc;
-
-	M0_ENTRY("lid %llu, layers_nr %lu",
-		 (unsigned long long)cl->cl_base.l_id,
-		 (unsigned long)layers_nr);
-
-	for (i = 0; i < layers_nr; ++i) {
-		sublayout = layout_find(cl->cl_base.l_dom,
-					sublayout_id_list[i]);
-		if (sublayout == NULL) {
-			M0_LOG(M0_ERROR, "lid %llu, layer %lu, sublayout with "
-			       "lid %llu does not exist",
-			       (unsigned long long)cl->cl_base.l_id,
-			       (unsigned long)i,
-			       (unsigned long long)sublayout_id_list[i]);
-			rc = -EINVAL;
-			break;
-		}
-
-		/* Read 'the extent map for this layer' from the DB. */
-		rc = extentmap_indb_read(cl, i, tx, &extlist, &extents_nr);
-		if (rc != 0) {
-			M0_LOG(M0_ERROR, "lid %llu, layer %lu, extentmap could"
-			       "not be read from the DB",
-			       (unsigned long long)cl->cl_base.l_id,
-			       (unsigned long)i);
-			/* Release the reference added by m0_layout_find(). */
-			m0_layout_put(sublayout);
-			break;
-		}
-
-		if (i == 0) {
-			rc = composite_populate(cl, sublayout, user_count);
-			layer = comp_layer_tlist_head(&cl->cl_layers);
-		} else
-			/* Now, write the layer to the in-memory layout. */
-			rc = layer_inmem_add(cl, sublayout, &layer);
-		/*
-		 * Release the reference added by m0_layout_find().
-		 * In case of success, composite_populate() or
-		 * layer_inmem_add() has now added a reference on this
-		 * sublayout.
-		 */
-		m0_layout_put(sublayout);
-
-		if (rc == 0) {
-			m0_tl_for(m0_composite_layer_ext, &extlist, lr_ext) {
-				rc = ext_inmem_write(cl, layer,
-						     &lr_ext->cle_ext,
-						     lr_ext->cle_state,
-						     EXT_MERGE_VALIDATION);
-				M0_ASSERT(rc == 0); //todo
-			} m0_tl_endfor;
-			extlist_free(&extlist); //todo Organization,
-		} else {
-			extlist_free(&extlist);
-			break;
-		}
-	}
-	if (rc != 0 && i > 0) {
-		/*
-		 * Undo the layer addition and the layout population done
-		 * through the earlier iterations of the loop above.
-		 */
-		M0_ASSERT(comp_layer_tlist_length(&cl->cl_layers) == i);
-		layers_inmem_delete(cl);
-		composite_populate_reverse(cl);
-	}
 	M0_RETURN(rc);
 }
 
@@ -2118,12 +1952,17 @@ static int layers_indb_add(struct m0_composite_layout *cl,
 	M0_ENTRY("lid %llu, layers_nr %lu",
 		 (unsigned long long)cl->cl_base.l_id,
 		 (unsigned long)cl->cl_layers_nr);
-
-	/* Collect the zeroth layer from the in-memory layout. */
 	layer = comp_layer_tlist_head(&cl->cl_layers);
 	M0_ASSERT(layer->clr_idx == 0);
+	m0_tl_for(comp_layer, &cl->cl_layers, layer) {
+		/* Add 'the extent map for this layer' to the DB. */
+		rc = extents_indb_add(cl, layer, tx);
+		if (rc == 0)
+			m0_layout_user_count_inc(layer->clr_sl);
+		else
+			break;
 
-	rc = layer_indb_add(cl, layer, tx);
+	} m0_tl_endfor;
 	M0_LEAVE("lid %llu, rc %d", (unsigned long long)cl->cl_base.l_id, rc);
 	return rc;
 }
@@ -2132,7 +1971,12 @@ static int layers_indb_add(struct m0_composite_layout *cl,
  * Adds a single extent spanning the whole offset space.
  * m0_emap_obj_delete() requires that the map consists of only one single
  * extent. Hence, this function is used in the situations where the map is to
- * be deleted and may contain multiple extents with M0_CLRES_HOLE state.
+ * be deleted and may contain multiple extents:
+ * - with M0_CLRES_HOLE state when the layer is to be completely deleted from
+ *   the DB OR
+ * - with varying states when the layer is to be updated as a part of the
+ *   layout update operation requiring to first delete the existing layout from
+ *   the DB.
  */
 static int single_ext_indb_write(struct m0_composite_layout *cl,
 				 uint32_t layer_idx, struct m0_db_tx *tx)
@@ -2178,9 +2022,9 @@ err2_injected:
 	M0_RETURN(rc);
 }
 
-/*
- * todo check if the in db verification is very costly and if it can be merged
- * with s'thing else.
+/**
+ * This is a check for an error that a layer that is asked to be deleted has
+ * some valid extents associated with it in its DB version.
  */
 static int layer_indb_delete_verify(struct m0_composite_layout *cl,
 				    struct m0_emap *emap,
@@ -2194,19 +2038,6 @@ static int layer_indb_delete_verify(struct m0_composite_layout *cl,
 	M0_ENTRY("lid %llu, layer_idx %lu",
 		 (unsigned long long)cl->cl_base.l_id,
 		 (unsigned long)layer_idx);
-
-	/* todo check
-	 * In the current implementation, the in-memory layout is always
-	 * necessarily up-to-date. Hence, it is not possible to hit the
-	 * exception that 'the in-memory layer does not contain any valid
-	 * extents but the in-db layer does.
-	 * In future, a network request will be supported to fetch partial
-	 * composite layout due to its possibly large size. If it is planned
-	 * that in any case, a layer is fetched as a whole or not, then this
-	 * exception will not be hit even in the future. In that case, the
-	 * condition "if (seg->ee_val != M0_CLRES_HOLE)" below shall not
-	 * be handled but instead shall be converted into an assert.
-	 */
 	rc = 0;
 	rc = emap_iterator_set(cl, emap, layer_idx, 0, tx, &it);
 	if (rc != 0) {
@@ -2220,7 +2051,16 @@ static int layer_indb_delete_verify(struct m0_composite_layout *cl,
 	while (1) {
 		M0_ASSERT(seg != NULL);
 		M0_ASSERT(!m0_ext_is_empty(&seg->ee_ext));
-		M0_ASSERT(seg->ee_val == M0_CLRES_HOLE);
+		if(seg->ee_val != M0_CLRES_HOLE) {
+			M0_LOG(M0_ERROR, "lid %llu, layer_idx %lu, at least "
+			       "one valid extent is associated with the layer "
+			       "e_start %llu, e_end %llu, e_state %llu",
+			       (unsigned long long)cl->cl_base.l_id,
+			       (unsigned long)layer_idx,
+			       (unsigned long long)seg->ee_ext.e_start,
+			       (unsigned long long)seg->ee_ext.e_end,
+			       (unsigned long long)seg->ee_val);
+		}
 		if (m0_emap_ext_is_last(&seg->ee_ext))
 			break;
 		m0_emap_next(&it);
@@ -2230,6 +2070,35 @@ static int layer_indb_delete_verify(struct m0_composite_layout *cl,
 	M0_RETURN(rc);
 }
 
+static int sublayout_user_count_dec(const struct m0_composite_layout *cl,
+				    uint64_t sublayout_id,
+				    struct m0_layout *sublayout,
+				    bool in_update_path)
+{
+	M0_PRE(sublayout_id > 0);
+	M0_PRE(ergo(in_update_path, sublayout == NULL));
+	M0_PRE(ergo(!in_update_path, sublayout != NULL));
+
+	M0_ENTRY("lid %llu, sublayout_id %llu",
+		 (unsigned long long)cl->cl_base.l_id,
+		 (unsigned long long)sublayout_id);
+	if (in_update_path) {
+		sublayout = layout_find(cl->cl_base.l_dom, sublayout_id);
+		if (sublayout == NULL) {
+			M0_LOG(M0_ERROR, "lid %llu, sublayout with lid %llu "
+			       "does not exist",
+			       (unsigned long long)cl->cl_base.l_id,
+			       (unsigned long long)sublayout_id);
+			M0_RETURN(-EINVAL);
+		}
+	}
+	m0_layout_user_count_dec(sublayout);
+	if (in_update_path)
+		/* Release the reference added by m0_layout_find(). */
+		m0_layout_put(sublayout);
+	M0_RETURN(0);
+}
+
 static int layer_indb_delete(struct m0_composite_layout *cl,
 			     uint32_t layer_idx,
 			     uint64_t sublayout_id,
@@ -2249,24 +2118,15 @@ static int layer_indb_delete(struct m0_composite_layout *cl,
 		 (unsigned long long)cl->cl_base.l_id,
 		 (unsigned long)layer_idx, in_update_path ? 1 : 0);
 	emap = emap_from_cl(cl);
-	if (in_update_path) {
-		sublayout = layout_find(cl->cl_base.l_dom, sublayout_id);
-		if (sublayout == NULL) {
-			rc = -EINVAL;
-			M0_LOG(M0_ERROR, "lid %llu, sublayout with lid %llu "
-			       "does not exist",
-			       (unsigned long long)cl->cl_base.l_id,
-			       (unsigned long long)sublayout_id);
-			M0_RETURN(-EINVAL);
-		}
-	} else {
+	if (!in_update_path) {
 		rc = layer_indb_delete_verify(cl, emap, layer_idx, tx);
 		if (rc != 0)
 			M0_RETURN(rc);
 	}
 
 	rc = single_ext_indb_write(cl, layer_idx, tx);
-	M0_ASSERT(rc == 0); //todo
+	if (rc != 0)
+		M0_RETURN(rc);
 
 	prefix_set(&prefix, cl->cl_base.l_id, layer_idx);
 	if (M0_FI_ENABLED("emap_obj_del_err"))
@@ -2274,25 +2134,20 @@ static int layer_indb_delete(struct m0_composite_layout *cl,
 	rc = m0_emap_obj_delete(emap, tx, (struct m0_uint128 *)&prefix);
 err1_injected:
 	if (rc == 0) {
-		/* Decrement the user count of the sublayout. */
-		m0_layout_user_count_dec(sublayout);
-
-		if (in_update_path)
-			/* Release the reference added by m0_layout_find(). */
-			m0_layout_put(sublayout);
+		rc = sublayout_user_count_dec(cl, sublayout_id, sublayout,
+					      in_update_path);
+		M0_ASSERT(rc == 0);
 	} else
 		m0_layout__log("layer_indb_delete",
 			       "failed to delete from layer_emap",
 			       M0_LAYOUT_ADDB_LOC_COMP_LAYER_INDB_DEL,
-			       &cl->cl_base.l_addb_ctx,
-			       cl->cl_base.l_id, rc);
-	M0_ENTRY("lid %llu, layer_idx %lu, rc %d",
+			       &cl->cl_base.l_addb_ctx, cl->cl_base.l_id, rc);
+	M0_LEAVE("lid %llu, layer_idx %lu, rc %d",
 		 (unsigned long long)cl->cl_base.l_id,
 		 (unsigned long)layer_idx, rc);
 	return rc;
 }
 
-//todo
 static int existing_layers_nr_n_sl_id_list_read(struct m0_composite_layout *cl,
 						struct m0_db_tx * tx,
 						uint32_t *layers_nr,
@@ -2307,6 +2162,8 @@ static int existing_layers_nr_n_sl_id_list_read(struct m0_composite_layout *cl,
 	struct m0_bufvec_cursor  cur;
 	int                      rc;
 
+	M0_PRE(composite_invariant(cl));
+
 	M0_ENTRY("lid %llu", (unsigned long long)cl->cl_base.l_id);
 	key = l->l_id;
 	recsize = m0_layout_max_recsize(l->l_dom);
@@ -2315,7 +2172,6 @@ static int existing_layers_nr_n_sl_id_list_read(struct m0_composite_layout *cl,
 	m0_db_pair_setup(&pair, &l->l_dom->ld_layouts,
 			 &key, sizeof l->l_id, rec, recsize);
 	rc = m0_table_lookup(tx, &pair);
-	M0_ASSERT(rc == 0 || rc == -ENOENT);
 	if (rc == 0) {
 		/*
 		 * Set up cursor and move it to point to the layout type
@@ -2327,9 +2183,9 @@ static int existing_layers_nr_n_sl_id_list_read(struct m0_composite_layout *cl,
 		m0_bufvec_cursor_init(&cur, &bv);
 		m0_bufvec_cursor_move(&cur, sizeof(struct m0_layout_rec));
 		rc = sublayout_ids_inbuf_read(cl, &cur, layers_nr, sl_id_list);
-		M0_ASSERT(rc == 0); //todo
 	}
 	m0_free(rec);
+	M0_POST(composite_invariant(cl));
 	M0_LOG(M0_DEBUG, "lid %llu, rc %d, existing_layers_nr %lu",
 	       (unsigned long long)cl->cl_base.l_id, rc,
 	       (unsigned long)*layers_nr);
@@ -2350,6 +2206,7 @@ static int layers_indb_delete(struct m0_composite_layout *cl,
 	uint32_t                   i;
 	int                        rc;
 
+	M0_PRE(composite_invariant(cl));
 	M0_PRE(ergo(!in_update_path,
 		     m0_tl_forall(comp_layer, lr, &cl->cl_layers,
 				  m0_tl_forall(m0_composite_layer_ext, lr_ext,
@@ -2362,24 +2219,20 @@ static int layers_indb_delete(struct m0_composite_layout *cl,
 	emap = emap_from_cl(cl);
 
 	if (in_update_path) {
-		//todo
 		rc = existing_layers_nr_n_sl_id_list_read(cl, tx,
 							  &existing_layers_nr,
 							  &existing_sl_id_list);
-		M0_ASSERT(rc == 0 || rc == -ENOENT); //todo
 		if (rc == 0) {
 			for (i = existing_layers_nr - 1; i >= 0; --i) {
 				rc = layer_indb_delete(cl, i,
 						       existing_sl_id_list[i],
 						       NULL, tx,
 						       in_update_path);
-				M0_ASSERT(rc == 0 || rc == -ENOENT); //todo
-				if (i == 0)
+				if (i == 0 || rc != 0)
 					break;
 			}
 			m0_free(existing_sl_id_list);
-		} else
-			rc = 0;
+		}
 	} else {
 		m0_tl_for(comp_layer, &cl->cl_layers, layer) {
 			rc = layer_indb_delete(cl, layer->clr_idx,
@@ -2396,6 +2249,7 @@ static int layers_indb_delete(struct m0_composite_layout *cl,
 		} m0_tl_endfor;
 	}
 
+	M0_POST(composite_invariant(cl));
 	M0_LEAVE("lid %llu, rc %d", (unsigned long long)cl->cl_base.l_id, rc);
 	return rc;
 }
diff --git a/layout/composite.h b/layout/composite.h
index 4bbadfa..0d8ffbb 100644
--- a/layout/composite.h
+++ b/layout/composite.h
@@ -188,19 +188,19 @@ enum m0_composite_layer_ext_state {
  */
 struct m0_composite_layer_extent {
 	/** Extent being represented. */
-	struct m0_ext    cle_ext;
+	struct m0_ext                     cle_ext;
 
 	/** State of the extent. */
-	uint64_t         cle_state;
+	enum m0_composite_layer_ext_state cle_state;
 
 	/** Magic number set while adding an entry to the list of extents. */
-	uint64_t         cle_magic;
+	uint64_t                          cle_magic;
 
 	/**
 	 * Linkage used for maintaining the extent list, associated with a
 	 * particular layer.
 	 */
-	struct m0_tlink  cle_linkage;
+	struct m0_tlink                   cle_linkage;
 };
 
 /**
@@ -316,12 +316,13 @@ M0_INTERNAL void m0_composite_layer_delete(struct m0_composite_layout *cl);
  * layer. If an extent containing the offset is not found upto the bottom-most
  * layer, then the error ENOENT is returned.
  */
-M0_INTERNAL int m0_composite_layer_ext_lookup(struct m0_composite_layout *cl,
-					      m0_bindex_t offset,
-					      struct m0_ext *ext,
-					      uint32_t *layer_idx,
-					      uint64_t *ext_state,
-					      struct m0_layout **sublayout);
+M0_INTERNAL int m0_composite_layer_ext_lookup(
+				struct m0_composite_layout *cl,
+				m0_bindex_t offset,
+				struct m0_ext *ext,
+				uint32_t *layer_idx,
+				enum m0_composite_layer_ext_state *ext_state,
+				struct m0_layout **sublayout);
 
 /**
  * Adds an extent with the specified state to the specified layer of the
@@ -341,10 +342,11 @@ M0_INTERNAL int m0_composite_layer_ext_lookup(struct m0_composite_layout *cl,
  * @note After this API has been used, the user needs to explicitly invoke
  *       m0_layout_update() API so as to update the DB version of the layout.
  */
-M0_INTERNAL int m0_composite_layer_ext_add(struct m0_composite_layout *cl,
-					   uint32_t layer_idx,
-					   const struct m0_ext *ext,
-					   uint64_t ext_state);
+M0_INTERNAL int m0_composite_layer_ext_add(
+				struct m0_composite_layout *cl,
+				uint32_t layer_idx,
+				const struct m0_ext *ext,
+				enum m0_composite_layer_ext_state ext_state);
 
 /**
  * Updates state of an extent owned by a specified layer of a specified
@@ -359,10 +361,10 @@ M0_INTERNAL int m0_composite_layer_ext_add(struct m0_composite_layout *cl,
  *       m0_layout_update() API so as to update the DB version of the layout.
  */
 M0_INTERNAL int m0_composite_layer_ext_state_update(
-						struct m0_composite_layout *cl,
-						uint32_t layer_idx,
-						const struct m0_ext *ext,
-						uint64_t ext_state);
+				struct m0_composite_layout *cl,
+				uint32_t layer_idx,
+				const struct m0_ext *ext,
+				enum m0_composite_layer_ext_state new_state);
 
 /**
  * Deletes an extent from the specified layer of the specified composite
diff --git a/layout/composite_internal.h b/layout/composite_internal.h
index 6f07694..d875190 100644
--- a/layout/composite_internal.h
+++ b/layout/composite_internal.h
@@ -60,24 +60,6 @@ struct m0_layout_composite_rec {
 };
 M0_BASSERT(M0_IS_8ALIGNED(sizeof(struct m0_layout_composite_rec)));
 
-#if 0
-/**
- * Structure used to store header information for a composite layout like
- * number of layers in it. It is used in the buffer representation of a
- * composite layout.
- *
- * @note This structure needs to be maintained as 8 bytes aligned.
- */
-struct composite_header {
-	/** Total number of layers in a specific composite layout. */
-	uint32_t ch_layers_nr;
-
-	/** Padding to make the structure 8 bytes aligned. */
-	uint32_t ch_pad;
-};
-M0_BASSERT(M0_IS_8ALIGNED(sizeof(struct composite_header)));
-#endif
-
 /**
  * Structure used to store header information for 'a layer of a composite
  * layout' like the number of extents in it. It is used in the buffer
@@ -85,13 +67,7 @@ M0_BASSERT(M0_IS_8ALIGNED(sizeof(struct composite_header)));
  *
  * @note This structure needs to be maintained as 8 bytes aligned.
  */
-struct composite_layer_header {
-#if 0
-	/** Layout id for the layout used for this layer (sublayout). */
-	uint64_t clh_slid;
-#endif
-
-	//todo Check if the following field is required
+struct layer_header {
 	/** Index of this layer into its owner composite layout. */
 	uint32_t clh_idx;
 
@@ -101,11 +77,6 @@ struct composite_layer_header {
 	 */
 	uint32_t clh_extents_nr;
 
-#if 0
-	/** Padding to make the structure 8 bytes aligned. */
-	uint32_t clh_pad;
-#endif
-
 	/**
 	 * Payload storing list of the extents (struct m0_ext) for a specific
 	 * layer.
@@ -113,7 +84,22 @@ struct composite_layer_header {
 	char     clh_extents[0];
 
 };
-M0_BASSERT(M0_IS_8ALIGNED(sizeof(struct composite_layer_header)));
+M0_BASSERT(M0_IS_8ALIGNED(sizeof(struct layer_header)));
+
+/**
+ * Structure used to store extents for 'a layer of a composite
+ * layout'. It is used in the buffer representation of a composite layout.
+ *
+ * @note This structure needs to be maintained as 8 bytes aligned.
+ */
+struct layer_buf_ext {
+	/** Extent. */
+	struct m0_ext lbe_ext;
+
+	/* Extent state. */
+	uint64_t      lbe_state;
+};
+M0_BASSERT(M0_IS_8ALIGNED(sizeof(struct layer_buf_ext)));
 
 /** @} end group layout */
 
diff --git a/layout/ut/composite.c b/layout/ut/composite.c
index 4912442..3534a8d 100644
--- a/layout/ut/composite.c
+++ b/layout/ut/composite.c
@@ -507,23 +507,22 @@ static int composite_build_and_layers_add(uint64_t lid,
 	M0_UT_ASSERT(rc == 0);
 
 	if (is_add_to_db) {
-		if (domain->ld_is_db_available) {
-			allocate_area(domain, ADDITIONAL_BYTES_NONE, &num_bytes,
-				      &area);
-			rc = m0_db_tx_init(&tx, domain->ld_dbenv, DBFLAGS);
+		M0_UT_ASSERT(domain->ld_is_db_available); //todo tempo
+		allocate_area(domain, ADDITIONAL_BYTES_NONE, &num_bytes,
+			      &area);
+		rc = m0_db_tx_init(&tx, domain->ld_dbenv, DBFLAGS);
+		M0_UT_ASSERT(rc == 0);
+		pair_set(&pair, &lid, area, num_bytes);
+		rc = m0_layout_add(&(*cl)->cl_base, &tx, &pair);
+		if (layer_add_failure_test)
+			M0_UT_ASSERT(rc == LO_ENCODE_ERR ||
+				     rc == L_TABLE_INSERT_ERR);
+		else
 			M0_UT_ASSERT(rc == 0);
-			pair_set(&pair, &lid, area, num_bytes);
-			rc = m0_layout_add(&(*cl)->cl_base, &tx, &pair);
-			if (layer_add_failure_test)
-				M0_UT_ASSERT(rc == LO_ENCODE_ERR ||
-					     rc == L_TABLE_INSERT_ERR);
-			else
-				M0_UT_ASSERT(rc == 0);
-			m0_free(area);
-			txptr = &tx;
-		} else
-			txptr = NULL;
+		m0_free(area);
+		txptr = &tx;
 	} else {
+		M0_UT_ASSERT(!domain->ld_is_db_available); //todo tempo
 		txptr = NULL;
 #ifndef __KERNEL__
 		if (domain->ld_is_db_available) {
@@ -621,9 +620,8 @@ static void composite_layout_buf_build(uint64_t composite_lid,
 	uint64_t                        sublayout_id;
 	struct m0_layout               *sublayout;
 	struct m0_layout_composite_rec  cl_rec;
-	struct composite_layer_header   layer_header;
-	struct m0_ext                   ext;
-	uint64_t                        ext_state;
+	struct layer_header             lr_header;
+	struct layer_buf_ext            buf_ext;
 	m0_bindex_t                     delta;
 	uint32_t                        extents_nr;
 	uint32_t                        i;
@@ -661,7 +659,7 @@ static void composite_layout_buf_build(uint64_t composite_lid,
 
 	/* Write the layers to the buffer. */
 	M0_UT_ASSERT(m0_bufvec_cursor_step(dcur) >=
-		     layers_nr * sizeof layer_header);
+		     layers_nr * sizeof lr_header);
 	extents_nr = min_extents_nr;
 	for (i = 0; i < layers_nr; ++i) {
 		sublayout_id = composite_lid * 100 + i;
@@ -670,34 +668,32 @@ static void composite_layout_buf_build(uint64_t composite_lid,
 		/* Release the reference acquired by m0_layout_find(). */
 		m0_layout_put(sublayout);
 
-		layer_header.clh_idx = i;
-		layer_header.clh_extents_nr = extents_nr;
-		nbytes = m0_bufvec_cursor_copyto(dcur, &layer_header,
-						 sizeof layer_header);
-		M0_UT_ASSERT(nbytes == sizeof layer_header);
+		lr_header.clh_idx = i;
+		lr_header.clh_extents_nr = extents_nr;
+		nbytes = m0_bufvec_cursor_copyto(dcur, &lr_header,
+						 sizeof lr_header);
+		M0_UT_ASSERT(nbytes == sizeof lr_header);
 
 		if (extents_nr == 0) /* Possible only in error condition. */
 			continue;
 
 		delta = (END_OFFSET - START_OFFSET) / extents_nr;
 		//todo Assert everywhere applicable that extents_nr >= 2
-		for (j = 0; j < layer_header.clh_extents_nr; ++j) {
-			ext.e_start = START_OFFSET + j * delta;
-			ext.e_end = (j == layer_header.clh_extents_nr - 1) ?
-				END_OFFSET : ext.e_start + delta;
-			nbytes = m0_bufvec_cursor_copyto(dcur, &ext,
-							 sizeof ext);
-			M0_UT_ASSERT(nbytes == sizeof ext);
-
-			ext_state = (if_contiguous_extents || j % 2 == 0) ?
+		for (j = 0; j < lr_header.clh_extents_nr; ++j) {
+			buf_ext.lbe_ext.e_start = START_OFFSET + j * delta;
+			buf_ext.lbe_ext.e_end =
+				(j == lr_header.clh_extents_nr - 1) ?
+				END_OFFSET : buf_ext.lbe_ext.e_start + delta;
+			buf_ext.lbe_state =
+				(if_contiguous_extents || j % 2 == 0) ?
 				M0_CLRES_VALID : M0_CLRES_HOLE;
 
 			if (M0_FI_ENABLED("invalid_ext_state_err"))
-				ext_state = 111;
+				buf_ext.lbe_state = 111;
 
-			nbytes = m0_bufvec_cursor_copyto(dcur, &ext_state,
-							 sizeof ext_state);
-			M0_UT_ASSERT(nbytes == sizeof ext_state);
+			nbytes = m0_bufvec_cursor_copyto(dcur, &buf_ext,
+							 sizeof buf_ext);
+			M0_UT_ASSERT(nbytes == sizeof buf_ext);
 		}
 		//todo enable once m0_emap_paste() works ++extents_nr;
 	}
@@ -778,7 +774,7 @@ static void composite_layout_buf_verify(uint64_t lid,
 	uint32_t                        lt_id;
 	struct m0_layout_composite_rec *cl_rec;
 	uint64_t                       *sublayout_id;
-	struct composite_layer_header  *layer_header;
+	struct layer_header            *lr_header;
 	struct m0_ext                  *ext;
 	uint64_t                       *ext_state;
 	m0_bindex_t                     delta;
@@ -806,23 +802,23 @@ static void composite_layout_buf_verify(uint64_t lid,
 	}
 
 	M0_UT_ASSERT(m0_bufvec_cursor_step(cur) >=
-		     cl_rec->cr_layers_nr * sizeof *layer_header);
+		     cl_rec->cr_layers_nr * sizeof *lr_header);
 	extents_nr = min_extents_nr;
 
 	for (i = 0; i < layers_nr; ++i) {
-		layer_header = m0_bufvec_cursor_addr(cur);
-		m0_bufvec_cursor_move(cur, sizeof *layer_header);
-		M0_UT_ASSERT(layer_header->clh_idx == i);
-		M0_UT_ASSERT(layer_header->clh_extents_nr == extents_nr);
+		lr_header = m0_bufvec_cursor_addr(cur);
+		m0_bufvec_cursor_move(cur, sizeof *lr_header);
+		M0_UT_ASSERT(lr_header->clh_idx == i);
+		M0_UT_ASSERT(lr_header->clh_extents_nr == extents_nr);
 		M0_UT_ASSERT(m0_bufvec_cursor_step(cur) >=
-			     layer_header->clh_extents_nr * sizeof ext);
+			     lr_header->clh_extents_nr * sizeof ext);
 		delta = (END_OFFSET - START_OFFSET) / extents_nr;
-		for (j = 0; j < layer_header->clh_extents_nr; ++j) {
+		for (j = 0; j < lr_header->clh_extents_nr; ++j) {
 			ext = m0_bufvec_cursor_addr(cur);
 			m0_bufvec_cursor_move(cur, sizeof *ext);
 			M0_UT_ASSERT(ext->e_start ==
 				     START_OFFSET + j * delta);
-			if (j == layer_header->clh_extents_nr - 1)
+			if (j == lr_header->clh_extents_nr - 1)
 				M0_UT_ASSERT(ext->e_end == END_OFFSET);
 			else
 				M0_UT_ASSERT(ext->e_end ==
@@ -902,14 +898,14 @@ static void composite_layout_buf_compare(struct m0_bufvec_cursor *cur1,
 {
 	struct m0_layout_composite_rec *cl_rec1;
 	struct m0_layout_composite_rec *cl_rec2;
-	struct composite_layer_header *layer_header1;
-	struct composite_layer_header *layer_header2;
-	struct m0_ext                 *ext1;
-	struct m0_ext                 *ext2;
-	uint64_t                      *ext_state1;
-	uint64_t                      *ext_state2;
-	uint32_t                       i;
-	uint32_t                       j;
+	struct layer_header            *lr_header1;
+	struct layer_header            *lr_header2;
+	struct m0_ext                  *ext1;
+	struct m0_ext                  *ext2;
+	uint64_t                       *ext_state1;
+	uint64_t                       *ext_state2;
+	uint32_t                        i;
+	uint32_t                        j;
 
 	M0_UT_ASSERT(cur1 != NULL);
 	M0_UT_ASSERT(cur2 != NULL);
@@ -930,20 +926,20 @@ static void composite_layout_buf_compare(struct m0_bufvec_cursor *cur1,
 	M0_UT_ASSERT(cl_rec1->cr_layers_nr == cl_rec2->cr_layers_nr);
 
 	M0_UT_ASSERT(m0_bufvec_cursor_step(cur1) >=
-		     cl_rec1->cr_layers_nr * sizeof *layer_header1);
+		     cl_rec1->cr_layers_nr * sizeof *lr_header1);
 	M0_UT_ASSERT(m0_bufvec_cursor_step(cur2) >=
-		     cl_rec2->cr_layers_nr * sizeof *layer_header2);
+		     cl_rec2->cr_layers_nr * sizeof *lr_header2);
 
 	for (i = 0; i < cl_rec1->cr_layers_nr; ++i) {
-		layer_header1 = m0_bufvec_cursor_addr(cur1);
-		layer_header2 = m0_bufvec_cursor_addr(cur2);
-		m0_bufvec_cursor_move(cur1, sizeof *layer_header1);
-		m0_bufvec_cursor_move(cur2, sizeof *layer_header2);
-		M0_UT_ASSERT(layer_header1->clh_idx == layer_header2->clh_idx);
-		M0_UT_ASSERT(layer_header1->clh_extents_nr ==
-			     layer_header2->clh_extents_nr);
-
-		for (j = 0; j < layer_header1->clh_extents_nr; ++j) {
+		lr_header1 = m0_bufvec_cursor_addr(cur1);
+		lr_header2 = m0_bufvec_cursor_addr(cur2);
+		m0_bufvec_cursor_move(cur1, sizeof *lr_header1);
+		m0_bufvec_cursor_move(cur2, sizeof *lr_header2);
+		M0_UT_ASSERT(lr_header1->clh_idx == lr_header2->clh_idx);
+		M0_UT_ASSERT(lr_header1->clh_extents_nr ==
+			     lr_header2->clh_extents_nr);
+
+		for (j = 0; j < lr_header1->clh_extents_nr; ++j) {
 			ext1 = m0_bufvec_cursor_addr(cur1);
 			ext2 = m0_bufvec_cursor_addr(cur2);
 			m0_bufvec_cursor_move(cur1, sizeof *ext1);
@@ -1400,7 +1396,9 @@ static void extent_to_be_operated(const struct m0_composite_layout *cl,
 	M0_UT_ASSERT(M0_IN(extent_kind, (EXACT_EXISTING, NON_EXISTING,
 					 OVERLAPPING_LEFT, OVERLAPPING_RIGHT,
 					 OVERLAPPING_COMPLETE,
-					 CONTAINED_WITHIN)));
+					 CONTAINED_WITHIN,
+					 WHOLE_OFFSET_SPACE, FIRST_HALF,
+					 SECOND_HALF)));
 	layer = layer_find(cl, layer_idx);
 	M0_UT_ASSERT(ergo(extent_kind == EXACT_EXISTING,
 			  extent_idx < layer->clr_extents_nr));
@@ -1467,6 +1465,15 @@ static void extent_to_be_operated(const struct m0_composite_layout *cl,
 				ext->e_end = ext_idx_plus_oneth.e_end - 2;
 			}
 		}
+	} else if (extent_kind == WHOLE_OFFSET_SPACE) {
+		ext->e_start = 0;
+		ext->e_end = M0_BINDEX_MAX + 1;
+	} else if (extent_kind == FIRST_HALF) {
+		ext->e_start = 0;
+		ext->e_end = M0_BINDEX_MAX / 2;
+	} else if (extent_kind == SECOND_HALF) {
+		ext->e_start = M0_BINDEX_MAX / 2;
+		ext->e_end = M0_BINDEX_MAX + 1;
 	}
 }
 
@@ -1486,7 +1493,8 @@ static int ext_op_pre(enum extent_operation eop,
 		      struct m0_composite_layout **cl,
 		      struct m0_ext *ext_to_operate,
 		      m0_bindex_t *offset_to_operate,
-		      uint64_t *ext_state_lookup,
+			//todo check if the following is req'd
+		      enum m0_composite_layer_ext_state *ext_state_lookup,
 		      struct m0_layout **l_copy_orig)
 {
 	bool              is_add_to_db;
@@ -1516,11 +1524,23 @@ static int ext_op_pre(enum extent_operation eop,
 	/* Define the offset to be operated. */
 	if (M0_IN(extent_kind, (NON_EXISTING, EXACT_EXISTING,
 				OVERLAPPING_LEFT, OVERLAPPING_COMPLETE,
-				CONTAINED_WITHIN)))
+				CONTAINED_WITHIN, WHOLE_OFFSET_SPACE,
+				FIRST_HALF)))
 		*offset_to_operate = ext_to_operate->e_start + 1;
 	else {
-		M0_UT_ASSERT(extent_kind == OVERLAPPING_RIGHT);
-		*offset_to_operate = ext_to_operate->e_end - 1;
+		M0_UT_ASSERT(extent_kind == OVERLAPPING_RIGHT ||
+			     extent_kind == SECOND_HALF);
+		if (extent_kind == OVERLAPPING_RIGHT || if_contiguous_extents)
+			*offset_to_operate = ext_to_operate->e_end - 1;
+		else {
+			M0_UT_ASSERT(extent_kind == SECOND_HALF);
+			M0_UT_ASSERT(!if_contiguous_extents);
+			if (min_extents_nr % 2 == 0)
+				*offset_to_operate =
+					 ext_to_operate->e_start + 1;
+			else
+				*offset_to_operate = ext_to_operate->e_end - 1;
+		}
 	}
 
 	if (domain->ld_is_db_available) {
@@ -1681,17 +1701,17 @@ static int ext_add(struct m0_composite_layout *cl,
 		   enum kind_of_extent extent_kind,
 		   struct m0_ext *ext_to_operate,
 		   m0_bindex_t offset_to_operate,
-		   uint64_t ext_state,
+		   enum m0_composite_layer_ext_state ext_state,
 		   bool failure_test)
 {
-	struct m0_db_tx   tx;
-	struct m0_db_tx  *txptr;
-	uint32_t          layer_id_lookup;
-	struct m0_ext     ext_lookup;
-	uint64_t          ext_state_lookup;
-	struct m0_layout *sublayout_lookup;
-	int               rc_tmp;
-	int               rc;
+	struct m0_db_tx                    tx;
+	struct m0_db_tx                   *txptr;
+	uint32_t                           layer_id_lookup;
+	struct m0_ext                      ext_lookup;
+	enum m0_composite_layer_ext_state  ext_state_lookup;
+	struct m0_layout                  *sublayout_lookup;
+	int                                rc_tmp;
+	int                                rc;
 
 	if (domain->ld_is_db_available) {
 		rc = m0_db_tx_init(&tx, domain->ld_dbenv, DBFLAGS);
@@ -1745,17 +1765,17 @@ static int ext_update(struct m0_composite_layout *cl,
 		      enum kind_of_extent extent_kind,
 		      struct m0_ext *ext_to_operate,
 		      m0_bindex_t offset_to_operate,
-		      uint64_t ext_state,
+		      enum m0_composite_layer_ext_state ext_state,
 		      bool failure_test)
 {
-	struct m0_db_tx   tx;
-	struct m0_db_tx  *txptr;
-	uint32_t          layer_id_lookup;
-	struct m0_ext     ext_lookup;
-	uint64_t          ext_state_lookup;
-	struct m0_layout *sublayout_lookup;
-	int               rc_tmp;
-	int               rc;
+	struct m0_db_tx                    tx;
+	struct m0_db_tx                   *txptr;
+	uint32_t                           layer_id_lookup;
+	struct m0_ext                      ext_lookup;
+	enum m0_composite_layer_ext_state  ext_state_lookup;
+	struct m0_layout                  *sublayout_lookup;
+	int                                rc_tmp;
+	int                                rc;
 
 	//todo Factor out this common code and tx commit code
 	if (domain->ld_is_db_available) {
@@ -1806,14 +1826,14 @@ static int ext_delete(struct m0_composite_layout *cl,
 		      m0_bindex_t offset_to_operate,
 		      bool failure_test)
 {
-	struct m0_db_tx   tx;
-	struct m0_db_tx  *txptr;
-	uint32_t          layer_id_lookup;
-	struct m0_ext     ext_lookup;
-	uint64_t          ext_state_lookup;
-	struct m0_layout *sublayout_lookup;
-	int               rc_tmp;
-	int               rc;
+	struct m0_db_tx                    tx;
+	struct m0_db_tx                   *txptr;
+	uint32_t                           layer_id_lookup;
+	struct m0_ext                      ext_lookup;
+	enum m0_composite_layer_ext_state  ext_state_lookup;
+	struct m0_layout                  *sublayout_lookup;
+	int                                rc_tmp;
+	int                                rc;
 
 	//todo Factor out this common code and tx commit code
 	if (domain->ld_is_db_available) {
@@ -1870,12 +1890,12 @@ static int test_ext_lookup(uint64_t lid,
 			   enum kind_of_extent extent_kind,
 			   bool failure_test)
 {
-	struct m0_layout           *l_copy_orig;
-	struct m0_composite_layout *cl;
-	struct m0_ext               ext_to_operate;
-	m0_bindex_t                 offset_to_operate;
-	uint64_t                    ext_state_lookup;
-	int                         rc;
+	struct m0_layout                  *l_copy_orig;
+	struct m0_composite_layout        *cl;
+	struct m0_ext                      ext_to_operate;
+	m0_bindex_t                        offset_to_operate;
+	enum m0_composite_layer_ext_state  ext_state_lookup;
+	int                                rc;
 
 	rc = ext_op_pre(EXTENT_LOOKUP, lid, domain, layers_nr, min_extents_nr,
 			if_contiguous_extents, extent_kind,
@@ -1910,13 +1930,13 @@ static int test_ext_add(uint64_t lid,
 			uint64_t ext_state,
 			bool failure_test)
 {
-	struct m0_layout           *l_copy_orig;
-	struct m0_composite_layout *cl;
-	struct m0_ext               ext_to_operate;
-	m0_bindex_t                 offset_to_operate;
-	uint64_t                    ext_state_lookup;
-	bool                        layout_compare = LAYOUTS_COMPARE;
-	int                         rc;
+	struct m0_layout                  *l_copy_orig;
+	struct m0_composite_layout        *cl;
+	struct m0_ext                      ext_to_operate;
+	m0_bindex_t                        offset_to_operate;
+	enum m0_composite_layer_ext_state  ext_state_lookup;
+	bool                               layout_compare = LAYOUTS_COMPARE;
+	int                                rc;
 
 	rc = ext_op_pre(EXTENT_ADD, lid, domain, layers_nr, min_extents_nr,
 			if_contiguous_extents, extent_kind, ext_state,
@@ -1951,12 +1971,12 @@ static int test_ext_state_update(uint64_t lid,
 				 uint64_t ext_state,
 				 bool failure_test)
 {
-	struct m0_layout           *l_copy_orig;
-	struct m0_composite_layout *cl;
-	struct m0_ext               ext_to_operate;
-	m0_bindex_t                 offset_to_operate;
-	uint64_t                    ext_state_lookup;
-	int                         rc;
+	struct m0_layout                  *l_copy_orig;
+	struct m0_composite_layout        *cl;
+	struct m0_ext                      ext_to_operate;
+	m0_bindex_t                        offset_to_operate;
+	enum m0_composite_layer_ext_state  ext_state_lookup;
+	int                                rc;
 
 	rc = ext_op_pre(EXTENT_UPDATE, lid, domain, layers_nr, min_extents_nr,
 			if_contiguous_extents, extent_kind, ext_state,
@@ -2014,15 +2034,15 @@ static int test_ext_delete(uint64_t lid,
 			   enum kind_of_extent extent_kind,
 			   bool failure_test)
 {
-	struct m0_layout           *l_copy_orig;
-	struct m0_composite_layout *cl;
-	struct m0_ext               ext_to_operate;
-	m0_bindex_t                 offset_to_operate;
-	uint64_t                    ext_state_lookup;
-	struct m0_db_tx             tx;
-	struct m0_db_tx            *txptr;
-	struct m0_ext               ext;
-	int                         rc;
+	struct m0_layout                  *l_copy_orig;
+	struct m0_composite_layout        *cl;
+	struct m0_ext                      ext_to_operate;
+	m0_bindex_t                        offset_to_operate;
+	enum m0_composite_layer_ext_state  ext_state_lookup;
+	struct m0_db_tx                    tx;
+	struct m0_db_tx                   *txptr;
+	struct m0_ext                      ext;
+	int                                rc;
 
 	rc = ext_op_pre(EXTENT_DELETE, lid, domain, layers_nr, min_extents_nr,
 			if_contiguous_extents, extent_kind, M0_CLRES_HOLE,
@@ -2468,7 +2488,7 @@ int test_update_composite(uint64_t lid,
 	struct m0_ext               ext_to_operate;
 	uint32_t                    layer_id_lookup;
 	struct m0_ext               ext_lookup;
-	uint64_t                    ext_state_lookup;
+	enum m0_composite_layer_ext_state  ext_state_lookup; //todo indent
 	struct m0_layout           *sublayout_lookup;
 	uint32_t                    i;
 	int                         rc_tmp;
diff --git a/layout/ut/composite.h b/layout/ut/composite.h
index d717b03..ae53e64 100644
--- a/layout/ut/composite.h
+++ b/layout/ut/composite.h
@@ -54,6 +54,9 @@ enum kind_of_extent {
 	OVERLAPPING_COMPLETE  = 4,
 	CONTAINED_WITHIN      = 5,
 	//todo Add OVERLAPPING_MULTIPLE
+	WHOLE_OFFSET_SPACE    = 6,
+	FIRST_HALF            = 7,
+	SECOND_HALF           = 8,
 
 	KIND_OF_EXTENT_NR
 };
diff --git a/layout/ut/layout.c b/layout/ut/layout.c
index d4616c6..c91a28e 100644
--- a/layout/ut/layout.c
+++ b/layout/ut/layout.c
@@ -1656,7 +1656,7 @@ static void test_lookup_failure(void)
 #if 0 //todo enable, not working at this point
 	/*
 	 * Simulate memory allocation error in the path of
-	 * extentmap_indb_read().
+	 * extlist_indb_read().
 	 */
 	lid = 19024;
 	m0_fi_enable_once("ext_inmem_add_internal", "alloc_ptr_fail/lr_ext");
@@ -1667,10 +1667,10 @@ static void test_lookup_failure(void)
 
 	/*
 	 * Simulate invalid extent state error in the path of
-	 * extentmap_indb_read().
+	 * extlist_indb_read().
 	 */
 	lid = 19025;
-	m0_fi_enable_once("extentmap_indb_read", "invalid_ext_state_err");
+	m0_fi_enable_once("extlist_indb_read", "invalid_ext_state_err");
 	rc = test_lookup_composite(lid, &domain, 4, 5, CONTIGUOUS_EXTENTS,
 				   EXISTING_TEST, FAILURE_TEST);
 	M0_UT_ASSERT(rc == -EINVAL);
@@ -1678,7 +1678,7 @@ static void test_lookup_failure(void)
 #if 0
 	/* todo Enable the following. Checked upto 17 and it is not working. */
 	/*
-	 * Simulate emap lookup error in the path of extentmap_indb_read() for
+	 * Simulate emap lookup error in the path of extlist_indb_read() for
 	 * zeroth layer.
 	 */
 	lid = 19026;
@@ -1693,7 +1693,7 @@ static void test_lookup_failure(void)
 #if 0
 	/* todo Enable the following. */
 	/*
-	 * Simulate emap lookup error in the path of extentmap_indb_read() for
+	 * Simulate emap lookup error in the path of extlist_indb_read() for
 	 * non-zeroth layer.
 	 */
 	lid = 19027;
@@ -1970,12 +1970,12 @@ static void test_update_failure(void)
 
 	/* Simulate emap paste error while adding a non-zeroth layer. */
 	lid = 23006;
-	m0_fi_enable_off_n_on_m("ext_indb_write_internal", "emap_paste_err",
+	m0_fi_enable_off_n_on_m("ext_indb_write", "emap_paste_err",
 				16 /* layer_nr * extents_nr + 1 */, 1);
 	rc = test_update_composite(lid, &domain, 3, 5, !CONTIGUOUS_EXTENTS,
 				   FAILURE_TEST);
 	M0_UT_ASSERT(rc == L_EMAP_PASTE_ERR);
-	m0_fi_disable("ext_indb_write_internal", "emap_paste_err");
+	m0_fi_disable("ext_indb_write", "emap_paste_err");
 
 	domain_ldb_available_set(&domain, false);
 }
-- 
1.8.3.2

