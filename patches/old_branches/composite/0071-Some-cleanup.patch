From 1b39da5637ddeb2e642aa0bd51b3a12ecf3b321b Mon Sep 17 00:00:00 2001
From: "trupti.patil" <trupti_patil@xyratex.com>
Date: Mon, 4 Mar 2013 12:04:37 +0530
Subject: [PATCH 071/172] Some cleanup

---
 layout/composite.c | 443 +++++++++++++----------------------------------------
 layout/composite.h |   2 +-
 lib/ext.c          |   8 +
 3 files changed, 118 insertions(+), 335 deletions(-)

diff --git a/layout/composite.c b/layout/composite.c
index 5aef51b..d7c178d 100644
--- a/layout/composite.c
+++ b/layout/composite.c
@@ -947,7 +947,6 @@ static int composite_encode(struct m0_layout *l,
 	return rc;
 }
 
-//todo Change this just to return the existing state and not assert on it
 /**
  * Check if the exact provided extent with the exact provided state is present
  * in the list of the extents.
@@ -958,7 +957,7 @@ static int ext_inmem_find(struct m0_composite_layer *layer,
 			  struct m0_composite_layer_extent **lr_ext_out)
 {
 	struct m0_composite_layer_extent *lr_ext;
-	bool                              ext_found;
+	bool                              ext_encountered;
 	int                               rc;
 
 	M0_ENTRY("lid %llu, layer %lu, e_start %llu, e_end %llu, "
@@ -969,36 +968,24 @@ static int ext_inmem_find(struct m0_composite_layer *layer,
 		 (unsigned long long)ext->e_end,
 		 (unsigned long long)expected_ext_state);
 
-	ext_found = false;
+	ext_encountered = false;
 	m0_tl_for(m0_composite_layer_ext, layer->clr_extents, lr_ext) {
 		if (lr_ext->cle_ext.e_end <= ext->e_start)
 			continue;
 		else if (lr_ext->cle_ext.e_start == ext->e_start &&
 			 lr_ext->cle_ext.e_end == ext->e_end) {
-			M0_ASSERT(lr_ext->cle_state == expected_ext_state);
-			if (lr_ext->cle_state == expected_ext_state) {
-				ext_found = true;
-				break;
-			}
+			ext_encountered = true;
+			break;
 		}
 	} m0_tl_endfor;
 
-	if (ext_found) {
-		rc = 0;
-		if (lr_ext_out != NULL)
-			*lr_ext_out = lr_ext;
-#if 0
-#ifndef __KERNEL__
-		printf("lid %llu, layer %lu, e_start %llu, e_end %llu, \n"
-			 "\t expected_e_state %llu, actual_e_state %llu \n",
-			 (unsigned long long)layer->clr_cl->l_id,
-			 (unsigned long)layer->clr_idx,
-			 (unsigned long long)ext->e_start,
-			 (unsigned long long)ext->e_end,
-			 (unsigned long long)expected_ext_state,
-			 (unsigned long long)lr_ext->cle_state);
-#endif
-#endif
+	if (ext_encountered) {
+		if (lr_ext->cle_state == expected_ext_state) {
+			rc = 0;
+			if (lr_ext_out != NULL)
+				*lr_ext_out = lr_ext;
+		} else
+			rc = -EINVAL; /* Internal, just to help debugging. */
 	} else
 		rc = -ENOENT;
 
@@ -1035,7 +1022,9 @@ static int ext_inmem_add_internal(struct m0_composite_layer *layer,
 
 	if (l == NULL)
 		l = layer->clr_cl;
-	M0_ENTRY("lid %llu, layer_idx %lu , e_start %llu, e_end %llu, "
+	if (extlist == NULL)
+		extlist = layer->clr_extents;
+	M0_ENTRY("lid %llu, layer %lu , e_start %llu, e_end %llu, "
 		 "e_state %llu, add_position %lu, "
 		 "adjacent_ext_start %llu, adjacent_ext_end %llu",
 		 (unsigned long long)l->l_id,
@@ -1048,23 +1037,6 @@ static int ext_inmem_add_internal(struct m0_composite_layer *layer,
 		 (adjacent_lr_ext == NULL) ? 0 :
 		 (unsigned long long)adjacent_lr_ext->cle_ext.e_end);
 
-#if 0
-#ifndef __KERNEL__
-	//todo Make this M0_DEBUG, not M0_ENTRY
-	printf("ext_inmem_add_internal(1): e_start %llu, e_end %llu, ext %p, "
-		"adjacent_lr_ext_start %llu, adjacent_lr_ext_end %llu \n",
-		(unsigned long long)ext->e_start,
-		(unsigned long long)ext->e_end, ext,
-		(adjacent_lr_ext == NULL) ? 0 :
-		(unsigned long long)adjacent_lr_ext->cle_ext.e_start,
-		(adjacent_lr_ext == NULL) ? 0 :
-		(unsigned long long)adjacent_lr_ext->cle_ext.e_end);
-#endif
-#endif
-
-	if (extlist == NULL)
-		extlist = layer->clr_extents;
-
 	M0_ALLOC_PTR(lr_ext);
 	if (lr_ext == NULL) {
 		m0_layout__log("ext_inmem_add_internal",
@@ -1110,17 +1082,6 @@ static int ext_inmem_add(struct m0_composite_layer *layer,
 		 (unsigned long)layer->clr_idx,
 		 (unsigned long long)ext->e_start,
 		 (unsigned long long)ext->e_end, (unsigned long long)ext_state);
-#if 0
-#ifndef __KERNEL__
-	printf("ext_inmem_add(): lid %llu, layer %lu, "
-		"e_start %llu, e_end %llu, e_state %llu\n",
-		 (unsigned long long)layer->clr_cl->l_id,
-		 (unsigned long)layer->clr_idx,
-		 (unsigned long long)ext->e_start,
-		 (unsigned long long)ext->e_end, (unsigned long long)ext_state);
-#endif
-#endif
-
 	lr_ext_to_insert_before = NULL;
 	lr_ext_to_insert_after = NULL;
 	m0_tl_for(m0_composite_layer_ext, layer->clr_extents, lr_ext) {
@@ -1184,14 +1145,6 @@ static int ext_inmem_lookup(struct m0_composite_layout *cl,
 
 	M0_ENTRY("lid %llu, offset %llu", (unsigned long long)cl->cl_base.l_id,
 		 (unsigned long long)offset);
-#if 0
-#ifndef __KERNEL__
-	printf("ext_inmem_lookup(): lid %llu, offset %llu\n",
-		 (unsigned long long)cl->cl_base.l_id,
-		 (unsigned long long)offset);
-#endif
-#endif
-
 	/* Start the lookup with the top-most layer. */
 	layer = comp_layer_tlist_tail(&cl->cl_layers);
 	M0_ASSERT(layer != NULL);
@@ -1228,16 +1181,7 @@ static int ext_inmem_lookup(struct m0_composite_layout *cl,
 	} else
 		rc = -ENOENT;
 
-#if 0
-#ifndef __KERNEL__
-	printf("ext_inmem_lookup(): lid %llu, offset %llu, "
-		"rc %d, layer_id %lu, ext_state %llu\n",
-		(unsigned long long)cl->cl_base.l_id,
-		(unsigned long long)offset, rc, (unsigned long)*layer_idx,
-		(unsigned long long)(*ext_state));
-#endif
-#endif
-	M0_LEAVE("lid %llu, offset %llu, rc %d, layer_id %lu, ext_state %llu",
+	M0_LEAVE("lid %llu, offset %llu, rc %d, layer %lu, ext_state %llu",
 		 (unsigned long long)cl->cl_base.l_id,
 		 (unsigned long long)offset, rc, (unsigned long)*layer_idx,
 		 (unsigned long long)*ext_state);
@@ -1262,14 +1206,6 @@ M0_INTERNAL int m0_composite_layer_ext_lookup(struct m0_composite_layout *cl,
 
 	M0_ENTRY("lid %llu, offset %llu", (unsigned long long)cl->cl_base.l_id,
 		 (unsigned long long)offset);
-#if 0
-#ifndef __KERNEL__
-	printf("m0_composite_layer_ext_lookup(): lid %llu, offset %llu\n",
-		 (unsigned long long)cl->cl_base.l_id,
-		 (unsigned long long)offset);
-#endif
-#endif
-
 	m0_mutex_lock(&cl->cl_base.l_lock);
 	if (!cl->cl_base.l_dom->ld_is_db_available)
 		rc = ext_inmem_lookup(cl, offset, ext,
@@ -1278,16 +1214,7 @@ M0_INTERNAL int m0_composite_layer_ext_lookup(struct m0_composite_layout *cl,
 		rc = ext_indb_lookup(cl, offset, tx, ext,
 				     layer_idx, ext_state, sublayout);
 	m0_mutex_unlock(&cl->cl_base.l_lock);
-#if 0
-#ifndef __KERNEL__
-	printf("m0_composite_layer_ext_lookup(): lid %llu, offset %llu, "
-		"rc %d, layer_id %lu, ext_state %llu\n",
-		(unsigned long long)cl->cl_base.l_id,
-		(unsigned long long)offset, rc, (unsigned long)*layer_idx,
-		(unsigned long long)*ext_state);
-#endif
-#endif
-	M0_LEAVE("lid %llu, offset %llu, rc %d, layer_id %lu, ext_state %llu",
+	M0_LEAVE("lid %llu, offset %llu, rc %d, layer %lu, ext_state %llu",
 		 (unsigned long long)cl->cl_base.l_id,
 		 (unsigned long long)offset, rc, (unsigned long)*layer_idx,
 		 (unsigned long long)*ext_state);
@@ -1298,23 +1225,12 @@ M0_INTERNAL int m0_composite_layer_ext_lookup(struct m0_composite_layout *cl,
 static void ext_inmem_del_internal(struct m0_composite_layer *layer,
 				   struct m0_composite_layer_extent *lr_ext)
 {
-	M0_LOG(M0_DEBUG, "lid %llu, layer_idx %lu, e_start %llu, e_end %llu, "
+	M0_LOG(M0_DEBUG, "lid %llu, layer %lu, e_start %llu, e_end %llu, "
 	       "e_state %llu", (unsigned long long)layer->clr_cl->l_id,
 	       (unsigned long)layer->clr_idx,
 	       (unsigned long long)lr_ext->cle_ext.e_start,
 	       (unsigned long long)lr_ext->cle_ext.e_end,
 	       (unsigned long long)lr_ext->cle_state);
-
-#if 0
-#ifndef __KERNEL__
-	printf("ext_inmem_del_internal(): lid %llu, layer %lu, \n"
-		"\te_start %llu, e_end %llu, \n",
-		 (unsigned long long)layer->clr_cl->l_id,
-		 (unsigned long)layer->clr_idx,
-		 (unsigned long long)lr_ext->cle_ext.e_start,
-		 (unsigned long long)lr_ext->cle_ext.e_end);
-#endif
-#endif
 	m0_composite_layer_ext_tlist_del(lr_ext);
 	m0_composite_layer_ext_tlink_fini(lr_ext);
 	m0_free(lr_ext);
@@ -1341,15 +1257,6 @@ static int ext_split_internal(struct m0_composite_layer *layer,
 		 (unsigned long long)vec->iv_vec.v_count[0],
 		 (unsigned long long)vec->iv_vec.v_count[1],
 		 (unsigned long long)vec->iv_vec.v_count[2]);
-#if 0
-#ifndef __KERNEL__
-	printf("ext_split_internal(): len0 %llu, len1 %llu, len2 %llu\n",
-		(unsigned long long)vec->iv_vec.v_count[0],
-		(unsigned long long)vec->iv_vec.v_count[1],
-		(unsigned long long)vec->iv_vec.v_count[2]);
-#endif
-#endif
-
 	for (i = 0; i < vec->iv_vec.v_nr; ++i) {
 		len = vec->iv_vec.v_count[i];
 		if (len != 0) {
@@ -1373,98 +1280,98 @@ static int ext_split_internal(struct m0_composite_layer *layer,
 
 /**
  * Validates the overlapping extents to ensure that they can be merged or
- * deleted.
+ * deleted and find the nearest extent from the list so as to start inserting
+ * the newer extent into it.
  *
  * Overlapping extents can be merged if and only if they are with
  * the state M0_CLRES_INVALID or with the state same as ext_state.
  *
- * Overlapping extents can be deleted if and only if ... todo
+ * Overlapping extents can be deleted if and only if they are either with the
+ * the state M0_CLRES_INVALID or with only one single state other than
+ * M0_CLRES_INVALID.
  */
 static int ext_inmem_validate(struct m0_composite_layout *cl,
 			      struct m0_composite_layer *layer,
 			      const struct m0_ext *ext,
 			      uint64_t new_ext_state,
-			      uint32_t ext_validation_kind)
+			      uint32_t ext_validation_kind,
+			      struct m0_composite_layer_extent
+					**lr_ext_nearest)
 {
 	struct m0_composite_layer_extent *lr_ext;
-	struct m0_ext                     interesection;
 	uint64_t                          first_noninvalid_state;
 	int                               rc;
 
+	M0_PRE(M0_IN(ext_validation_kind, (EXT_MERGE_VALIDATION,
+					   EXT_DEL_VALIDATION)));
+
+	rc = 0;
+	*lr_ext_nearest = NULL;
 	first_noninvalid_state = M0_CLRES_INVALID;
 	m0_tl_for(m0_composite_layer_ext, layer->clr_extents, lr_ext) {
-		m0_ext_intersection(ext, &lr_ext->cle_ext, &interesection);
-		if (!m0_ext_is_empty(&interesection)) {
-			/* Overlapping extent. todo add fn in ext.c */
-			if (ext_validation_kind == EXT_MERGE_VALIDATION) {
-				if (lr_ext->cle_state != M0_CLRES_INVALID &&
-				    lr_ext->cle_state != new_ext_state) {
-					rc = -EINVAL;
-					M0_LOG(M0_ERROR, "lid %llu, layer %lu, "
-					       "Overlapping extent can not be "
-					       "merged since the state is not "
-					       "the same, e_start %llu, "
-					       "e_end %llu, e_state %llu, "
-					       "existing_e_start %llu, "
-					       "existing_e_end %llu, "
-					       "existing_state %llu",
-					       (unsigned long long)
-							layer->clr_cl->l_id,
-					       (unsigned long)layer->clr_idx,
-					       (unsigned long long)ext->e_start,
-					       (unsigned long long)ext->e_end,
-					       (unsigned long long)
-							new_ext_state,
-					       (unsigned long long)
-							lr_ext->cle_ext.e_start,
-					       (unsigned long long)
-							lr_ext->cle_ext.e_end,
-					       (unsigned long long)
-							lr_ext->cle_state);
-					return rc;
-				}
-			} else {
-				M0_ASSERT(ext_validation_kind ==
-					  EXT_DEL_VALIDATION);
-				if (lr_ext->cle_state != M0_CLRES_INVALID &&
-				     (first_noninvalid_state !=
-				      M0_CLRES_INVALID && lr_ext->cle_state !=
-				      first_noninvalid_state)) {
-					rc = -EINVAL;
-					M0_LOG(M0_ERROR, "lid %llu, layer %lu, "
-					       "Overlapping extent can not be "
-					       "deleted since the states "
-					       "differ, e_start %llu, "
-					       "e_end %llu, e_state %llu, "
-					       "existing_e_start %llu, "
-					       "existing_e_end %llu, "
-					       "existing_state %llu, "
-					       "first_non_invalid_state %llu",
-					       (unsigned long long)
-							layer->clr_cl->l_id,
-					       (unsigned long)layer->clr_idx,
-					       (unsigned long long)ext->e_start,
-					       (unsigned long long)ext->e_end,
-					       (unsigned long long)
-							new_ext_state,
-					       (unsigned long long)
-							lr_ext->cle_ext.e_start,
-					       (unsigned long long)
-							lr_ext->cle_ext.e_end,
-					       (unsigned long long)
-							lr_ext->cle_state,
-					       (unsigned long long)
-							first_noninvalid_state);
-					//todo check loc of the following chk
-					if (lr_ext->cle_state !=
-					    M0_CLRES_INVALID &&
-					    first_noninvalid_state ==
-					    M0_CLRES_INVALID)
-						first_noninvalid_state =
-							lr_ext->cle_state;
-					return rc;
-				}
+		/* Nearest extent from the list. */
+		if (ext->e_start >= lr_ext->cle_ext.e_start)
+			*lr_ext_nearest = lr_ext;
+
+		if (!m0_ext_are_overlapping(ext, &lr_ext->cle_ext))
+			continue;
+		/* For overlapping extents. */
+		if (ext_validation_kind == EXT_MERGE_VALIDATION) {
+			if (lr_ext->cle_state != M0_CLRES_INVALID &&
+			    lr_ext->cle_state != new_ext_state) {
+				rc = -EINVAL;
+				M0_LOG(M0_ERROR, "lid %llu, layer %lu, "
+				       "Overlapping extent can not be merged "
+				       "since the state is not the same, "
+				       "e_start %llu, e_end %llu, "
+				       "e_state %llu, existing_e_start %llu, "
+				       "existing_e_end %llu, "
+				       "existing_state %llu",
+				       (unsigned long long) layer->clr_cl->l_id,
+				       (unsigned long)layer->clr_idx,
+				       (unsigned long long)ext->e_start,
+				       (unsigned long long)ext->e_end,
+				       (unsigned long long)new_ext_state,
+				       (unsigned long long)
+						lr_ext->cle_ext.e_start,
+				       (unsigned long long)
+						lr_ext->cle_ext.e_end,
+				       (unsigned long long)lr_ext->cle_state);
+				return rc;
+			}
+		} else { /* ext_validation_kind == EXT_DEL_VALIDATION */
+			if (lr_ext->cle_state != M0_CLRES_INVALID &&
+			     (first_noninvalid_state !=
+			      M0_CLRES_INVALID && lr_ext->cle_state !=
+			      first_noninvalid_state)) {
+				rc = -EINVAL;
+				M0_LOG(M0_ERROR, "lid %llu, layer %lu, "
+				       "Overlapping extent can not be deleted "
+				       "since the states differ, e_start %llu, "
+				       "e_end %llu, e_state %llu, "
+				       "existing_e_start %llu, "
+				       "existing_e_end %llu, "
+				       "existing_state %llu, "
+				       "first_non_invalid_state %llu",
+				       (unsigned long long)
+						layer->clr_cl->l_id,
+				       (unsigned long)layer->clr_idx,
+				       (unsigned long long)ext->e_start,
+				       (unsigned long long)ext->e_end,
+				       (unsigned long long)new_ext_state,
+				       (unsigned long long)
+						lr_ext->cle_ext.e_start,
+				       (unsigned long long)
+						lr_ext->cle_ext.e_end,
+				       (unsigned long long)lr_ext->cle_state,
+				       (unsigned long long)
+						first_noninvalid_state);
 			}
+			if (lr_ext->cle_state != M0_CLRES_INVALID &&
+			    first_noninvalid_state == M0_CLRES_INVALID)
+				first_noninvalid_state = lr_ext->cle_state;
+			if (rc != 0)
+				return rc;
 		}
 	} m0_tl_endfor;
 
@@ -1495,35 +1402,13 @@ static int ext_inmem_write(struct m0_composite_layout *cl,
 	M0_PRE(layer_invariant(layer));
 	M0_PRE(!m0_ext_is_empty(ext));
 
+	/* Validate the 'ext' and find the nearest extent from the list. */
 	rc = ext_inmem_validate(cl, layer, ext, new_ext_state,
-			        ext_validation_kind);
+			        ext_validation_kind, &lr_ext_to_insert_into);
 	if (rc != 0)
 		return rc;
-
-	/* Find the first nearest in-memory extent. */
-	//todo Merge this into ext_inmem_validate()
-	lr_ext_to_insert_into = NULL;
-	m0_tl_for(m0_composite_layer_ext, layer->clr_extents, lr_ext) {
-		if (ext->e_start >= lr_ext->cle_ext.e_start)
-			lr_ext_to_insert_into = lr_ext;
-	} m0_tl_endfor;
 	M0_ASSERT(lr_ext_to_insert_into != NULL);
 
-#if 0
-#ifndef __KERNEL__
-	printf("ext_inmem_write(1): lid %llu, layer %lu, \n"
-		"\te_start %llu, e_end %llu, e_state %llu, \n"
-		"\tlr_ext_to_insert_into_start %llu, \n "
-		"\tlr_ext_to_insert_into_end %llu\n",
-		 (unsigned long long)layer->clr_cl->l_id,
-		 (unsigned long)layer->clr_idx,
-		 (unsigned long long)ext->e_start,
-		 (unsigned long long)ext->e_end,
-		 (unsigned long long)new_ext_state,
-		 (unsigned long long)lr_ext_to_insert_into->cle_ext.e_start,
-		 (unsigned long long)lr_ext_to_insert_into->cle_ext.e_end);
-#endif
-#endif
 	M0_ENTRY("lid %llu, layer %lu, e_start %llu, e_end %llu, e_state %llu "
 		 "lr_ext_to_insert_into_start %llu, "
 		 "lr_ext_to_insert_into_end %llu",
@@ -1716,7 +1601,6 @@ static int ext_inmem_write(struct m0_composite_layout *cl,
 		}
 	}
 
-	//todo Check the rc properly
 	/*
 	 * Now that the deletion/trimming of the overlapping extents
 	 * has been handled above, let's add the ultimate whole extent.
@@ -1760,17 +1644,6 @@ M0_INTERNAL int m0_composite_layer_ext_add(struct m0_composite_layout *cl,
 		 (unsigned long)layer_idx, (unsigned long long)ext->e_start,
 		 (unsigned long long)ext->e_end,
 		 (unsigned long long)ext_state);
-#if 0
-#ifndef __KERNEL__
-	printf("m0_composite_layer_ext_add(): lid %llu, layer %lu \n"
-		"\te_start %llu, e_end %llu, e_state %llu \n",
-		 (unsigned long long)cl->cl_base.l_id,
-		 (unsigned long)layer_idx, (unsigned long long)ext->e_start,
-		 (unsigned long long)ext->e_end,
-		 (unsigned long long)ext_state);
-#endif
-#endif
-
 	m0_mutex_lock(&cl->cl_base.l_lock);
 	layer = layer_find(cl, layer_idx);
 
@@ -1817,16 +1690,6 @@ M0_INTERNAL int m0_composite_layer_ext_state_update(
 		 (unsigned long long)cl->cl_base.l_id,
 		 (unsigned long)layer_idx, (unsigned long long)ext->e_start,
 		 (unsigned long long)ext->e_end, (unsigned long long)new_state);
-#if 0
-#ifndef __KERNEL__
-	printf("m0_composite_layer_ext_state_update(): lid %llu, layer %lu, "
-		"e_start %llu, e_end %llu, e_state %llu\n",
-		 (unsigned long long)cl->cl_base.l_id,
-		 (unsigned long)layer_idx, (unsigned long long)ext->e_start,
-		 (unsigned long long)ext->e_end, (unsigned long long)new_state);
-#endif
-#endif
-
 	m0_mutex_lock(&cl->cl_base.l_lock);
 	layer = layer_find(cl, layer_idx);
 
@@ -1871,16 +1734,6 @@ M0_INTERNAL int m0_composite_layer_ext_delete(struct m0_composite_layout *cl,
 		 (unsigned long long)cl->cl_base.l_id,
 		 (unsigned long)layer_idx, (unsigned long long)ext->e_start,
 		 (unsigned long long)ext->e_end, ext);
-#if 0
-#ifndef __KERNEL__
-	printf("m0_composite_layer_ext_delete(1): lid %llu, layer %lu, "
-		"e_start %llu, e_end %llu, ext %p\n",
-		 (unsigned long long)cl->cl_base.l_id,
-		 (unsigned long)layer_idx, (unsigned long long)ext->e_start,
-		 (unsigned long long)ext->e_end, ext);
-#endif
-#endif
-
 	m0_mutex_lock(&cl->cl_base.l_lock);
 	layer = layer_find(cl, layer_idx);
 
@@ -1903,15 +1756,6 @@ M0_INTERNAL int m0_composite_layer_ext_delete(struct m0_composite_layout *cl,
 		 (unsigned long long)cl->cl_base.l_id,
 		 (unsigned long)layer_idx, (unsigned long long)ext->e_start,
 		 (unsigned long long)ext->e_end, rc);
-#if 0
-#ifndef __KERNEL__
-	printf("m0_composite_layer_ext_delete(2): lid %llu, layer %lu, "
-		"e_start %llu, e_end %llu, ext %p\n",
-		 (unsigned long long)cl->cl_base.l_id,
-		 (unsigned long)layer_idx, (unsigned long long)ext->e_start,
-		 (unsigned long long)ext->e_end, ext);
-#endif
-#endif
 	return rc;
 }
 
@@ -1961,18 +1805,6 @@ static int ext_inmem_delete(struct m0_composite_layer *layer,
 	bool                              lr_ext_to_delete_found;
 	int                               rc;
 
-#if 0
-#ifndef __KERNEL__
-	printf("ext_inmem_delete(): lid %llu, layer %lu, "
-		"e_start %llu, e_end %llu, old_e_state %llu, ext %p\n",
-		 (unsigned long long)layer->clr_cl->l_id,
-		 (unsigned long)layer->clr_idx,
-		 (unsigned long long)ext->e_start,
-		 (unsigned long long)ext->e_end,
-		 (unsigned long long)old_ext_state, ext);
-#endif
-#endif
-
 	M0_ENTRY("lid %llu, layer %lu, e_start %llu, e_end %llu, "
 		 "old_e_state %llu",
 		 (unsigned long long)layer->clr_cl->l_id,
@@ -2037,23 +1869,6 @@ static int ext_inmem_trim(struct m0_composite_layer *layer,
 		 (unsigned long long)ext_state,
 		 (unsigned long long)trim_reference_ext->e_start,
 		 (unsigned long long)trim_reference_ext->e_end);
-
-#if 0
-#ifndef __KERNEL__
-	printf("ext_inmem_trim(): lid %llu, layer %lu, extent_op %d, "
-		 "ext_to_trim_start %llu, ext_to_trim_end %llu, "
-		 "ext_state %llu, "
-		 "trim_ref_ext_start %llu, trim_ref_ext_end %llu\n",
-		 (unsigned long long)layer->clr_cl->l_id,
-		 (unsigned long)layer->clr_idx, extent_op,
-		 (unsigned long long)ext_to_trim->e_start,
-		 (unsigned long long)ext_to_trim->e_end,
-		 (unsigned long long)ext_state,
-		 (unsigned long long)trim_reference_ext->e_start,
-		 (unsigned long long)trim_reference_ext->e_end);
-#endif
-#endif
-
 	rc = ext_inmem_find(layer, ext_to_trim, ext_state, &lr_ext);
 	if (rc == 0) {
 		M0_ASSERT(lr_ext->cle_ext.e_start <=
@@ -2068,24 +1883,20 @@ static int ext_inmem_trim(struct m0_composite_layer *layer,
 			lr_ext->cle_ext.e_start = trim_reference_ext->e_end;
 	} else if (extent_op == CUT_RIGHT) {
 		/*
-		 * It is possible that CUT_LEFT has already been
-		 * performed on the same extent. So, the extent
-		 * ext_to_trim does not exist there as a whole but its
-		 * left part does.
+		 * It is possible that CUT_LEFT has already been performed
+		 * on the same extent. So, the extent ext_to_trim does not
+		 * exist there as a whole but its left part does.
 		 */
+		M0_ASSERT(rc == -ENOENT);
 		ext_left = *ext_to_trim;
 		ext_left.e_end = trim_reference_ext->e_start;
-		rc = ext_inmem_find(layer, &ext_left, ext_state,
-				    &lr_ext_left);
+		rc = ext_inmem_find(layer, &ext_left, ext_state, &lr_ext_left);
 		if (rc == 0) {
 			ext_to_insert = *ext_to_trim;
-			ext_to_insert.e_start =
-					trim_reference_ext->e_end;
+			ext_to_insert.e_start = trim_reference_ext->e_end;
 			rc = ext_inmem_add_internal(layer, NULL, NULL,
-						    &ext_to_insert,
-						    ext_state,
-						    ADD_AFTER,
-						    lr_ext_left);
+						    &ext_to_insert, ext_state,
+						    ADD_AFTER, lr_ext_left);
 			if (rc != 0)
 				M0_LOG(M0_ERROR, "lid %llu, Extent could not "
 				       "be added to the list",
@@ -2109,22 +1920,6 @@ static int ext_inmem_adjust(struct m0_composite_layer *layer,
 	int rc;
 
 	M0_PRE(M0_IN(extent_op, (DELETE, CUT_LEFT, CUT_RIGHT)));
-
-#if 0
-#ifndef __KERNEL__
-	printf("ext_inmem_adjust(): lid %llu, layer %lu, extent_op %d, "
-		 "seg_e_start %llu, seg_e_end %llu, seg_val %llu, "
-		 "e_start %llu, e_end %llu, ext %p\n",
-		 (unsigned long long)layer->clr_cl->l_id,
-		 (unsigned long)layer->clr_idx, extent_op,
-		 (unsigned long long)seg->ee_ext.e_start,
-		 (unsigned long long)seg->ee_ext.e_end,
-		 (unsigned long long)seg->ee_val,
-		 (ext != NULL) ? (unsigned long long)ext->e_start : 0,
-		 (ext != NULL) ? (unsigned long long)ext->e_end : 0, ext);
-#endif
-#endif
-
 	M0_ENTRY("lid %llu, layer %lu, extent_op %d, "
 		 "seg_e_start %llu, seg_e_end %llu, seg_val %llu, "
 		 "e_start %llu, e_end %llu",
@@ -2211,8 +2006,9 @@ static int ext_indb_write(struct m0_composite_layout *cl,
 			  struct m0_db_tx *tx,
 			  uint32_t ext_validation_kind)
 {
-	struct m0_emap_cursor it;
-	int                   rc;
+	struct m0_composite_layer_extent *lr_ext_nearest;
+	struct m0_emap_cursor             it;
+	int                               rc;
 
 	M0_PRE(layer_invariant(layer));
 	M0_PRE(tx != NULL);
@@ -2227,7 +2023,8 @@ static int ext_indb_write(struct m0_composite_layout *cl,
 
 	//In the DB path, just assert on the right overlapping states
 	rc = ext_inmem_validate(cl, layer, ext, new_ext_state,
-			        ext_validation_kind);
+			        ext_validation_kind,
+				&lr_ext_nearest /* Ignored in this case. */);
 	if (rc != 0)
 		M0_RETURN(rc);
 
@@ -2259,14 +2056,13 @@ static int ext_indb_write_internal(struct m0_emap_cursor *it,
 	int                   rc;
 
 	M0_ENTRY("lid %llu, layer %lu, e_start %llu, e_end %llu, "
-		 "new_e_state %llu, in_mem_list_update %d, ext %p",
+		 "new_e_state %llu, in_mem_list_update %d",
 		 (unsigned long long)layer->clr_cl->l_id,
 		 (unsigned long)layer->clr_idx,
 		 (unsigned long long)ext->e_start,
 		 (unsigned long long)ext->e_end,
 		 (unsigned long long)new_ext_state,
-		 in_mem_list_update ? 1 : 0, ext);
-
+		 in_mem_list_update ? 1 : 0);
 	/*
 	 * Insert a new segment into the layer's extent map, overwriting
 	 * parts of the map, as applicable.
@@ -2316,19 +2112,6 @@ static int ext_indb_write_internal(struct m0_emap_cursor *it,
 	 * layer_invariant() is temporarily violated during these operations.
 	 */
 
-#if 0
-#ifndef __KERNEL__
-	printf("ext_indb_write(): lid %llu, layer %lu, "
-		 "e_start %llu, e_end %llu, new_e_state %llu, "
-		 "in_mem_list_update %d, ext %p, ext %p\n",
-		 (unsigned long long)layer->clr_cl->l_id,
-		 (unsigned long)layer->clr_idx,
-		 (unsigned long long)ext->e_start,
-		 (unsigned long long)ext->e_end,
-		 (unsigned long long)new_ext_state,
-		 in_mem_list_update ? 1 : 0, ext, &ext);
-#endif
-#endif
 	rc_cb = 0;
 	rc = m0_emap_paste(it, &ext0, new_ext_state,
 		LAMBDA(void, (struct m0_emap_seg *seg) {
@@ -2934,14 +2717,6 @@ static int ext_indb_lookup(struct m0_composite_layout *cl,
 	M0_PRE(tx != NULL);
 	M0_ENTRY("lid %llu, offset %llu", (unsigned long long)cl->cl_base.l_id,
 		 (unsigned long long)offset);
-#if 0
-#ifndef __KERNEL__
-	printf("ext_indb_lookup(): lid %llu, offset %llu\n",
-		 (unsigned long long)cl->cl_base.l_id,
-		 (unsigned long long)offset);
-#endif
-#endif
-
 	emap = emap_from_cl(cl);
 
 	/* Start the lookup with the top-most layer. */
diff --git a/layout/composite.h b/layout/composite.h
index 36ef91c..f542a9a 100644
--- a/layout/composite.h
+++ b/layout/composite.h
@@ -366,7 +366,7 @@ M0_INTERNAL struct m0_composite_instance *m0_layout_instance_to_ci(
 extern struct m0_layout_type m0_composite_layout_type;
 
 /**
- * @todo Consolidated list of todo items
+ * @todo Consolidated list of the todo items
  * (Some of these items are mentioned inline too where they are applicable.
  * This list is for mainitaining a consolidated view as what all is to be
  * covered during the next task.)
diff --git a/lib/ext.c b/lib/ext.c
index 1337e8d..5cef8c3 100644
--- a/lib/ext.c
+++ b/lib/ext.c
@@ -37,6 +37,14 @@ M0_INTERNAL bool m0_ext_is_in(const struct m0_ext *ext, m0_bindex_t index)
 	return ext->e_start <= index && index < ext->e_end;
 }
 
+M0_INTERNAL bool m0_ext_are_overlapping(const struct m0_ext *e0,
+					const struct m0_ext *e1)
+{
+	struct m0_ext interesection;
+	m0_ext_intersection(e0, e1, &interesection);
+	return !m0_ext_is_empty(&interesection);
+}
+
 M0_INTERNAL bool m0_ext_is_partof(const struct m0_ext *super,
 				  const struct m0_ext *sub)
 {
-- 
1.8.3.2

