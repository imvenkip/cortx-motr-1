From 5ae914d9b98f6cda85a01bc6e3c21d5d56445831 Mon Sep 17 00:00:00 2001
From: "trupti.patil" <trupti_patil@xyratex.com>
Date: Fri, 7 Dec 2012 19:01:59 +0530
Subject: [PATCH 028/172] Partial support for extent lookup and addition in a
 layer

---
 layout/composite.c    | 306 +++++++++++++++++++++++++++++++++++++++++-----
 layout/composite.h    |  21 +++-
 layout/ut/composite.c | 329 +++++++++++++++++++++++++++++++++++++++++++++++++-
 layout/ut/layout.c    |  56 +++++++++
 layout/ut/layout.h    |  31 +++++
 5 files changed, 703 insertions(+), 40 deletions(-)

diff --git a/layout/composite.c b/layout/composite.c
index 86c9e77..b412f7c 100644
--- a/layout/composite.c
+++ b/layout/composite.c
@@ -633,12 +633,76 @@ static void cut_right(struct c2_emap_seg *seg,
 }
 #endif
 
+/* todo */
+enum extent_op {
+	DELETE,
+	CUT_LEFT,
+	CUT_RIGHT
+};
+
 #ifndef __KERNEL__
-static int ext_inmemory_adjust(const struct c2_composite_layer *layer,
+
+static int extent_in_memory_add(struct c2_composite_layer *layer,
+				const struct c2_ext *ext,
+				uint64_t val)
+{
+	struct c2_composite_layer_extent *ext1;
+	struct c2_composite_layer_extent *ext2;
+	bool                              ext1_found;
+	bool                              ext2_found;
+	struct c2_composite_layer_extent *extent;
+	struct c2_composite_layer_extent *extent_to_insert;
+
+	C2_PRE(val != LRET_INVALID);
+
+	ext1_found = false;
+	ext2_found = false;
+
+	c2_tl_for(c2_layer_extent, layer->clr_extents, extent) {
+		if (ext->e_start > extent->cle_ext.e_end)
+			continue;
+		if (ext->e_start >= extent->cle_ext.e_end) {
+			ext1 = extent;
+			ext1_found = true;
+		} else if (ext->e_start < extent->cle_ext.e_end) {
+			C2_ASSERT(ext1_found == true);
+			C2_ASSERT(extent->cle_ext.e_start >= ext->e_end);
+			ext2 = extent;
+			ext2_found = true;
+		}
+
+		/*
+		 * todo Consider the exceptions like insufficient number of
+		 * extents in the list, etc.
+		 */
+		if (ext1_found && ext2_found)
+			break;
+	} c2_tl_endfor;
+
+	C2_ASSERT (ext1_found && ext2_found);
+	if (ext1_found && ext2_found) {
+		C2_ALLOC_PTR(extent_to_insert);
+		C2_ASSERT(extent_to_insert != NULL); //todo Handle error
+
+		extent_to_insert->cle_ext = *ext;
+		c2_layer_extent_tlink_init(extent_to_insert);
+		c2_layer_extent_tlist_add_after(ext1, extent_to_insert);
+		++layer->clr_extents_nr;
+	}
+	return 0; //todo void ??
+}
+
+/* todo rename to _in_memory_.. */
+static int ext_inmemory_adjust(struct c2_composite_layer *layer,
+			       enum extent_op extop,
 			       const struct c2_emap_seg *seg,
 			       const struct c2_ext *ext,
-			       uint64_t val)
+			       uint64_t newval)
 {
+	int rc;
+
+	C2_PRE(C2_IN(extop, (DELETE, CUT_LEFT, CUT_RIGHT)));
+
 	C2_LOG(C2_DEBUG, "layer[%lu]: seg e_start %llu, seg e_end %llu, "
 	       "seg val %llu, e_start %llu, e_end %llu",
 	       (unsigned long)layer->clr_idx,
@@ -648,26 +712,58 @@ static int ext_inmemory_adjust(const struct c2_composite_layer *layer,
 	       (unsigned long long)ext->e_start,
 	       (unsigned long long)ext->e_end);
 
+	//todo Shall use switch ?
+	if (extop == DELETE) {
+		/*
+		 * The extent seg->ee_ext is replaced by some newer extent.
+		 * Hence, seg->ee_ext is asked to be deleted.
+		 */
+		if (seg->ee_val == LRET_INVALID) {
+			/*
+			 * The extent did not exist in the inmemory
+			 * list of the extents. Hence, it in fact, needs to be
+			 * added to that list, with the newer value.
+			 */
+			/* todo extent_in_memory_write(). */
+			rc = extent_in_memory_add(layer, &seg->ee_ext, newval);
+			C2_ASSERT(rc == 0); //todo handle
+			return 0;
+		} else {
+			/*
+			 * todo Find the extent from the in-memory list and
+			 * delete it.
+			 */
+		}
+	} else if (extop == CUT_LEFT) {
+
+	} else if (extop == CUT_RIGHT) {
+
+	}
+
 	return 0;
 }
 #endif /* __KERNEL__ */
 
-static int extent_add(struct c2_emap_cursor *it,
-		      const struct c2_composite_layer *layer,
-		      struct c2_ext *ext
-		      /* todo seg state */)
+/*
+ * todo Check the naming - "add and update" individually as applicable AND
+ * "write" to indicate add OR update.
+ */
+static int extent_in_db_add(struct c2_emap_cursor *it,
+			    struct c2_composite_layer *layer,
+			    struct c2_ext *ext,
+			    enum layer_extent_state ext_state,
+			    enum c2_layout_xcode_op op)
 {
 	int rc;
 	//Check about the locking
 
+	C2_PRE(C2_IN(op, (C2_LXO_DB_ADD, C2_LXO_DB_UPDATE)));
+
 	C2_LOG(C2_DEBUG, "layer idx %lu, e_start %llu, e_end %llu",
 	       (unsigned long)layer->clr_idx,
 	       (unsigned long long)ext->e_start,
 	       (unsigned long long)ext->e_end);
-	/*
-	 * todo seg->ee_val shall not be read as sublayout-id but
-	 * the sublayout-id shall be read from another table.
-	 */
+
 #ifndef __KERNEL__
 	/* LAMBDA is not available for the kernel mode. */
 
@@ -680,42 +776,68 @@ static int extent_add(struct c2_emap_cursor *it,
 	 * the changes in the map.
 	 *
 	 * Call-backs are used to adjust the extents in the in-memory list of
-	 * extents for the specific layer.
+	 * the extents for the specified layer.
 	 *
 	 * Each call-back takes a segment argument, seg. seg->ee_ext is an
 	 * extent associated with the specified layer (todo) and seg->ee_val
-	 * is the state of the extent.
+	 * is the original state of the extent from the on-disk extent map.
 	 */
-	rc = c2_emap_paste(it, ext, LRET_VALID,
+	rc = c2_emap_paste(it, ext, ext_state,
 			   LAMBDA(void, (struct c2_emap_seg *seg) {
 				/* Handle extent deletion. */
-					//todo optimize number of args ?
-				rc = rc ?: ext_inmemory_adjust(layer,
-							       seg,
-							       &seg->ee_ext,
-							       seg->ee_val);
+				if (op == C2_LXO_DB_UPDATE) {
+					//C2_ASSERT(seg->ee_val == LRET_VALID);
+
+					rc = ext_inmemory_adjust(layer,
+								 DELETE,
+								 seg,
+								 ext,
+								 ext_state);
+					//rc = rc ?: ext_inmemory_adjust(layer,
+					//		       seg,
+					//		       &seg->ee_ext,
+					//		       seg->ee_val);
+				}
 			   }),
 			   LAMBDA(void, (struct c2_emap_seg *seg,
 					 struct c2_ext *ext,
 					 uint64_t val) {
 				/* Cut left. */
-				C2_ASSERT(ext->e_start > seg->ee_ext.e_start);
-				seg->ee_val = val;
-				rc = rc ?: ext_inmemory_adjust(layer,
-							       seg,
-							       &seg->ee_ext,
-							       seg->ee_val);
+				if (op == C2_LXO_DB_UPDATE) {
+					//C2_ASSERT(seg->ee_val == LRET_VALID);
+					C2_ASSERT(ext->e_start >
+						  seg->ee_ext.e_start);
+					seg->ee_val = val;
+
+					rc = ext_inmemory_adjust(layer,
+								 CUT_LEFT,
+								 seg,
+								 ext,
+								 ext_state);
+					//rc = rc ?: ext_inmemory_adjust(layer,
+					//		       seg,
+					//		       &seg->ee_ext,
+					//		       seg->ee_val);
+				}
 			   }),
 			   LAMBDA(void, (struct c2_emap_seg *seg,
 					 struct c2_ext *ext,
 					 uint64_t val) {
 				/* Cur right. */
-				C2_ASSERT(seg->ee_ext.e_end > ext->e_end);
-
-				rc = rc ?: ext_inmemory_adjust(layer,
-							       seg,
-							       &seg->ee_ext,
-							       seg->ee_val);
+				if (op == C2_LXO_DB_UPDATE) {
+					//C2_ASSERT(seg->ee_val == LRET_VALID);
+					C2_ASSERT(seg->ee_ext.e_end >
+						  ext->e_end);
+
+					rc = ext_inmemory_adjust(layer,
+								 CUT_RIGHT,
+								 seg,
+								 ext,
+								 ext_state);
+					//rc = rc ?: ext_inmemory_adjust(layer,
+					//		       seg,
+					//		       &seg->ee_ext,
+					//		       seg->ee_val);
 /*
 //from ad.c, tune it.
 				if (val == LRET_VALID) {
@@ -739,6 +861,8 @@ static int extent_add(struct c2_emap_cursor *it,
 				} else
 					seg->ee_val = val;
 */
+
+				}
 			   }));
 
 #else
@@ -823,7 +947,7 @@ static int sublayout_id_in_db_write(struct composite_schema_data *csd,
 }
 
 static int extentmap_in_db_write(struct c2_composite_layout *cl,
-				 const struct c2_composite_layer *layer,
+				 struct c2_composite_layer *layer,
 				 bool if_extents_associated,
 				 struct c2_db_tx *tx)
 {
@@ -861,7 +985,8 @@ static int extentmap_in_db_write(struct c2_composite_layout *cl,
 
 	c2_tl_for(c2_layer_extent, layer->clr_extents, extent) {
 		ext = extent->cle_ext;
-		rc = extent_add(&it, layer, &ext);
+		rc = extent_in_db_add(&it, layer, &ext, LRET_VALID /*todo */,
+				      C2_LXO_DB_ADD);
 		C2_ASSERT(rc == 0); //todo Handle
 	} c2_tl_endfor;
 	c2_emap_close(&it);
@@ -871,7 +996,7 @@ static int extentmap_in_db_write(struct c2_composite_layout *cl,
 }
 
 static int layer_in_db_write(struct c2_composite_layout *cl,
-			     const struct c2_composite_layer *layer,
+			     struct c2_composite_layer *layer,
 			     struct c2_db_tx *tx)
 {
 	struct composite_schema_data *csd;
@@ -1364,6 +1489,121 @@ static int composite_encode(struct c2_layout *l,
 	return rc;
 }
 
+/* todo Use wherever applicable. */
+static struct c2_emap *emap_from_cl(const struct c2_composite_layout *cl)
+{
+	struct composite_schema_data *csd;
+
+	csd = cl->cl_base.l_dom->ld_type_data[c2_composite_layout_type.lt_id];
+	return &csd->csd_layer_ext_map;
+}
+
+static struct c2_composite_layer *layer_find(
+					const struct c2_composite_layout *cl,
+					uint32_t layer_idx)
+{
+	struct c2_composite_layer *layer;
+
+	C2_PRE(layer_idx < cl->cl_layers_nr);
+
+	layer = NULL;
+	c2_tl_for(c2_layer, cl->cl_layers, layer) {
+		if (layer->clr_idx == layer_idx)
+			break;
+	} c2_tl_endfor;
+
+	C2_POST(layer != NULL);
+	return layer;
+}
+
+int c2_composite_layer_ext_lookup(const struct c2_composite_layout *cl,
+				  c2_bindex_t offset,
+				  struct c2_db_tx *tx,
+				  uint32_t *layer_idx,
+				  struct c2_ext *ext)
+{
+	struct c2_emap            *emap;
+	struct c2_emap_cursor      it;
+	struct c2_emap_seg        *seg;
+	struct layout_prefix       prefix;
+	uint32_t                   i; /* layer idx */
+	bool                       found;
+	int                        rc;
+
+	emap = emap_from_cl(cl);
+
+	/* Start the lookup with the top-most layer. */
+	i = cl->cl_layers_nr - 1;
+	found = false;
+
+	while (1) {
+		prefix_set(&prefix, cl->cl_base.l_id, i);
+		rc = c2_emap_lookup(emap, tx, (struct c2_uint128 *)&prefix,
+				    offset, &it);
+		C2_ASSERT(rc == 0); //todo handle err
+
+		seg = c2_emap_seg_get(&it);
+		c2_emap_close(&it);
+
+		if (seg->ee_val != LRET_INVALID) {
+			found = true;
+			break;
+		}
+
+		if (i > 1)
+			i--;
+		else
+			break;
+	}
+
+	if (found == true) {
+		*layer_idx = i;
+		*ext = seg->ee_ext;
+		rc = 0;
+	} else
+		rc = -ENOENT;
+
+	return rc;
+}
+
+/* todo Handle extent updation and val updation. */
+int c2_composite_layer_ext_add(struct c2_composite_layout *cl,
+			       uint32_t layer_idx,
+			       struct c2_ext *ext,
+			       struct c2_db_tx *tx)
+{
+	struct composite_schema_data *csd;
+	struct c2_emap               *emap;
+	struct c2_emap_cursor         it;
+	struct c2_composite_layer    *layer;
+	struct layout_prefix          prefix;
+	int                           rc;
+
+	layer = layer_find(cl, layer_idx);
+	C2_ASSERT(layer != NULL);
+
+	csd = cl->cl_base.l_dom->ld_type_data[c2_composite_layout_type.lt_id];
+	emap = &csd->csd_layer_ext_map;
+	prefix_set(&prefix, cl->cl_base.l_id, layer->clr_idx);
+	rc = c2_emap_lookup(emap, tx, (struct c2_uint128 *)&prefix,
+			    ext->e_start, &it);
+	C2_ASSERT(rc == 0); //todo handle err
+
+	rc = extent_in_db_add(&it, layer, ext, LRET_VALID, C2_LXO_DB_UPDATE);
+	C2_ASSERT(rc == 0); //todo Handle
+
+	c2_emap_close(&it);
+	return rc;
+}
+
+int c2_composite_layer_ext_delete(struct c2_composite_layout *cl,
+				  uint32_t layer_idx,
+				  struct c2_ext *ext,
+				  struct c2_db_tx *tx)
+{
+	return 0;
+}
+
 static const struct c2_layout_ops composite_ops = {
 	.lo_fini           = composite_fini,
 	.lo_delete         = composite_delete,
diff --git a/layout/composite.h b/layout/composite.h
index 8716f05..d9daf44 100644
--- a/layout/composite.h
+++ b/layout/composite.h
@@ -108,7 +108,7 @@ struct c2_composite_layer_extent {
 	/** Extent being represented. */
 	struct c2_ext    cle_ext;
 
-	/** todo Add state of the extent ? */
+	/** todo Add state of the extent */
 
 	/**
 	 * Magic number set while c2_composite_layer_extent object is
@@ -161,6 +161,25 @@ int c2_composite_layer_add(struct c2_composite_layout *cl,
 			   uint32_t ext_nr,
 			   struct c2_db_tx *tx);
 
+/** todo */
+int c2_composite_layer_ext_lookup(const struct c2_composite_layout *cl,
+				  c2_bindex_t offset,
+				  struct c2_db_tx *tx,
+				  uint32_t *layer_idx,
+				  struct c2_ext *ext);
+
+/** todo */
+int c2_composite_layer_ext_add(struct c2_composite_layout *cl,
+			       uint32_t layer_idx,
+			       struct c2_ext *ext,
+			       struct c2_db_tx *tx);
+
+/** todo */
+int c2_composite_layer_ext_delete(struct c2_composite_layout *cl,
+				  uint32_t layer_idx,
+				  struct c2_ext *ext,
+				  struct c2_db_tx *tx);
+
 struct c2_composite_layout *c2_layout_to_cl(const struct c2_layout *l);
 struct c2_layout *c2_cl_to_layout(struct c2_composite_layout *cl);
 
diff --git a/layout/ut/composite.c b/layout/ut/composite.c
index 4c6457a..7e864ac 100644
--- a/layout/ut/composite.c
+++ b/layout/ut/composite.c
@@ -1111,15 +1111,12 @@ int test_lookup_composite(uint64_t lid,
 	 * If existing_test is true, then first add a layout object to the DB.
 	 */
 	if (existing_test) {
-		rc = test_add_composite(lid, domain,
-					layers_nr,
-					min_extents_nr,
-					min_start_offset,
+		rc = test_add_composite(lid, domain, layers_nr,
+					min_extents_nr, min_start_offset,
 					approximate_end_offset,
 					if_contiguous_extents,
 					!LAYOUT_DESTROY, &l1,
-					!DUPLICATE_TEST,
-					!FAILURE_TEST);
+					!DUPLICATE_TEST, !FAILURE_TEST);
 		C2_UT_ASSERT(rc == 0);
 
 		if (!failure_test)
@@ -1362,6 +1359,326 @@ static int test_delete_composite(uint64_t lid,
 	return rc;
 }
 #endif
+
+#if 0
+/* Dec 04 Continue to tune this one for adding extent in between-
+ that either overlaps, sits in between etc.
+*/
+static void extent_to_insert(uint32_t insertion_idx,
+			     uint32_t extents_nr,
+			     c2_bindex_t min_start_offset,
+			     c2_bindex_t approximate_end_offset,
+			     bool if_contiguous_extents,
+			     struct c2_ext *ext)
+{
+	c2_bindex_t delta;
+	c2_bindex_t multiplier;
+
+	C2_PRE(insertion_idx < extents_nr - 1);
+
+	//todo extents_nr will need to be derived from min_extents_nr
+	//once I start doing extents_nr++ with each layer.
+
+	multiplier = if_contiguous_extents ? 1 : 2;
+	delta = (approximate_end_offset - min_start_offset) /
+		(extents_nr * multiplier);
+#ifndef __KERNEL__
+	printf("extent_to_insert(): insertion_idx %lu, extents_nr %lu, "
+	       "min_start_offset %llu, approximate_end_offset %llu\n",
+		(unsigned long)insertion_idx,
+		(unsigned long)extents_nr,
+		(unsigned long long)min_start_offset,
+		(unsigned long long)approximate_end_offset);
+#endif
+
+	ext->e_start = min_start_offset +
+		       (multiplier * insertion_idx * delta); //todo + delta;
+	ext->e_end = ext->e_start + delta;
+#ifndef __KERNEL__
+	printf("extent_to_insert: start %llu, end %llu \n",
+		(unsigned long long)ext->e_start,
+		(unsigned long long)ext->e_end);
+#endif
+}
+#endif
+
+static void extent_to_be_operated(const struct c2_composite_layout *cl,
+				  bool if_contiguous_extents,
+				  uint32_t layer_idx,
+				  uint64_t extent_idx,
+				  uint32_t kind_of_extent_to_add,
+				  struct c2_ext *ext)
+{
+	struct c2_composite_layer        *layer;
+	struct c2_composite_layer_extent *extent;
+	struct c2_ext                     ext_idxth;
+	struct c2_ext                     ext_idx_plus_oneth;
+	int                               i;
+
+	C2_UT_ASSERT(layer_idx > 0);
+#if 0
+		if (layer->clr_idx == layer_idx)
+			ext_idxth = layer->clr_ext;
+		else if (layer->clr_idx == layer_idx + 1) {
+			ext_idx_plus_oneth = layer->clr_ext;
+			break;
+		}
+#endif
+
+	/* Find the layer. */
+	layer = NULL;
+	c2_tl_for(c2_layer, cl->cl_layers, layer) {
+		if (layer->clr_idx == layer_idx)
+			break;
+	} c2_tl_endfor;
+
+	C2_UT_ASSERT(layer != NULL);
+	C2_UT_ASSERT(ergo(kind_of_extent_to_add == EXACT_EXISTING,
+			  extent_idx < layer->clr_extents_nr));
+	C2_UT_ASSERT(ergo(kind_of_extent_to_add == NON_EXISTING,
+		          if_contiguous_extents == false &&
+			  layer->clr_extents_nr >= 3 &&
+			  layer->clr_extents_nr >= extent_idx + 1));
+	C2_UT_ASSERT(ergo(kind_of_extent_to_add == OVERLAPPING_LEFT,
+		          if_contiguous_extents == false &&
+			  layer->clr_extents_nr >= 3 &&
+			  layer->clr_extents_nr >= extent_idx + 1));
+
+	i = 0;
+	c2_tl_for(c2_layer_extent, layer->clr_extents, extent) {
+		if (i == extent_idx) {
+			ext_idxth = extent->cle_ext;
+			if (kind_of_extent_to_add == EXACT_EXISTING)
+				break;
+		}
+		else if (i == extent_idx + 1) {
+			ext_idx_plus_oneth = extent->cle_ext;
+			break;
+		}
+		++i;
+	} c2_tl_endfor;
+
+	C2_UT_ASSERT(ergo(if_contiguous_extents == false,
+			  ext_idxth.e_end != ext_idx_plus_oneth.e_start));
+
+	if (kind_of_extent_to_add == EXACT_EXISTING)
+		*ext = ext_idxth;
+	else if (kind_of_extent_to_add == NON_EXISTING) {
+		ext->e_start = ext_idxth.e_end;
+		ext->e_end = ext_idx_plus_oneth.e_start;
+	} else if (kind_of_extent_to_add == OVERLAPPING_LEFT) {
+		ext->e_start = ext_idxth.e_start;
+		ext->e_end = ext_idx_plus_oneth.e_end;
+	}
+
+#ifndef __KERNEL__
+	printf("extent_to_be_operated: start %llu, end %llu \n",
+		(unsigned long long)ext->e_start,
+		(unsigned long long)ext->e_end);
+#endif
+
+}
+
+/* todo
+ * Tests the APIs supported for layout object build and layout destruction
+ * that happens using c2_layout_put(). Verifies that the newly built layout
+ * object is added to the list of layout objects maintained in the domain
+ * object and that c2_layout_find() returns the same object.
+ */
+int test_ext_lookup_composite(uint64_t lid,
+			      struct c2_layout_domain *domain,
+			      uint32_t layers_nr,
+			      uint32_t min_extents_nr,
+			      c2_bindex_t min_start_offset,
+			      c2_bindex_t approximate_end_offset,
+			      bool if_contiguous_extents,
+			      uint32_t kind_of_extent_to_lookup,
+			      bool failure_test)
+{
+	struct c2_layout           *l;
+	struct c2_composite_layout *cl;
+	struct c2_ext               ext_to_lookup;
+	struct c2_ext               ext;
+	uint32_t                    layer_idx;
+	struct c2_db_tx             tx;
+	int                         rc_tmp;
+
+	rc = test_add_composite(lid, domain, layers_nr,
+				min_extents_nr, min_start_offset,
+				approximate_end_offset,
+				if_contiguous_extents,
+				!LAYOUT_DESTROY, &l,
+				!DUPLICATE_TEST, !FAILURE_TEST);
+	C2_UT_ASSERT(rc == 0);
+	cl = c2_layout_to_cl(l);
+
+	/* Define an extent to be looked up. */
+	extent_to_be_operated(cl, if_contiguous_extents, 1, 1,
+			      kind_of_extent_to_lookup, &ext_to_lookup);
+
+	/* Lookup for the extent. */
+	rc = c2_db_tx_init(&tx, domain->ld_dbenv, DBFLAGS);
+	C2_UT_ASSERT(rc == 0);
+
+	//Dec 05 Continue from here.
+	ext.e_start = 0;
+	ext.e_end = 0;
+	rc = c2_composite_layer_ext_lookup(cl, ext_to_lookup.e_start, &tx,
+					   &layer_idx, &ext);
+
+	rc_tmp = c2_db_tx_commit(&tx);
+	C2_UT_ASSERT(rc_tmp == 0);
+
+	if (kind_of_extent_to_lookup == EXACT_EXISTING) {
+		C2_UT_ASSERT(rc == 0);
+		C2_UT_ASSERT(ext_to_lookup.e_start == ext.e_start);
+		C2_UT_ASSERT(ext_to_lookup.e_end == ext.e_end);
+	} else if (kind_of_extent_to_lookup == NON_EXISTING) {
+		C2_UT_ASSERT(rc == -ENOENT);
+		rc = 0;
+	}
+
+	//todo Cover the other cases with kind_of_extent_to_add
+
+	/* Delete the composite layout object. */
+	c2_layout_put(&cl->cl_base);
+	C2_UT_ASSERT(c2_layout_find(domain, lid) == NULL);
+
+	/* Delete all the precreated sublayouts. */
+	sublayouts_delete(domain, lid, layers_nr);
+
+	return rc;
+}
+
+/* Lookup for the layout object from the DB. */
+static int layout_lookup(uint64_t lid,
+			 /* todo Accept lt and make it generic. */
+			 struct c2_layout_domain *domain,
+			 bool failure_test,
+			 struct c2_layout **layout)
+{
+	struct c2_layout  *l;
+	c2_bcount_t        num_bytes;
+	void              *area;
+	struct c2_db_pair  pair;
+	struct c2_db_tx    tx;
+	int                rc_tmp;
+
+	allocate_area(&area, ADDITIONAL_BYTES_NONE, &num_bytes);
+
+	rc = c2_db_tx_init(&tx, domain->ld_dbenv, DBFLAGS);
+	C2_UT_ASSERT(rc == 0);
+
+	pair_set(&pair, &lid, area, num_bytes);
+
+	rc = c2_layout_lookup(domain, lid, &c2_composite_layout_type,
+			      /* todo &c2_pdclust_layout_type, */
+			      &tx, &pair, &l);
+	if (failure_test)
+		C2_UT_ASSERT(rc == -ENOENT || rc == -ENOMEM || rc == -EPROTO ||
+			     rc == LO_DECODE_ERR);
+	else
+		C2_UT_ASSERT(rc == 0);
+
+	rc_tmp = c2_db_tx_commit(&tx);
+	C2_UT_ASSERT(rc_tmp == 0);
+
+	c2_free(area);
+
+	if (rc == 0)
+		*layout = l;
+	return rc;
+}
+
+/* todo */
+int test_ext_add_composite(uint64_t lid,
+			   struct c2_layout_domain *domain,
+			   uint32_t layers_nr,
+			   uint32_t min_extents_nr,
+			   c2_bindex_t min_start_offset,
+			   c2_bindex_t approximate_end_offset,
+			   bool if_contiguous_extents,
+			   uint32_t kind_of_extent_to_add,
+			   bool failure_test)
+{
+	struct c2_layout           *l;
+	struct c2_layout           *l_copy_orig;
+	struct c2_layout           *l_copy_updated;
+	struct c2_layout           *l_from_DB;
+	struct c2_composite_layout *cl;
+	struct c2_ext               ext_to_add;
+	struct c2_db_tx             tx;
+	int                         rc_tmp;
+
+	rc = test_add_composite(lid, domain,
+				layers_nr, min_extents_nr, min_start_offset,
+				approximate_end_offset, if_contiguous_extents,
+				!LAYOUT_DESTROY, &l,
+				!DUPLICATE_TEST, !FAILURE_TEST);
+	C2_UT_ASSERT(rc == 0);
+	composite_layout_copy(l, &l_copy_orig);
+	cl = c2_layout_to_cl(l);
+
+	/* Define an extent to be inserted. */
+	extent_to_be_operated(cl, if_contiguous_extents, 1, 1,
+			      kind_of_extent_to_add, &ext_to_add);
+
+	/* Insert the extent. */
+	rc = c2_db_tx_init(&tx, domain->ld_dbenv, DBFLAGS);
+	C2_UT_ASSERT(rc == 0);
+
+	rc = c2_composite_layer_ext_add(cl, 1, &ext_to_add, &tx);
+	C2_UT_ASSERT(rc == 0);
+
+	rc_tmp = c2_db_tx_commit(&tx);
+	C2_UT_ASSERT(rc_tmp == 0);
+
+	composite_layout_copy(l, &l_copy_updated);
+
+	/* todo Optimize this code once it is functioning. */
+	/* Verify the extent list in the in-memory layout. */
+	if (kind_of_extent_to_add == EXACT_EXISTING) {
+		composite_layout_compare(l_copy_orig, l_copy_updated, false);
+	} else if (kind_of_extent_to_add == NON_EXISTING) {
+		/* The following fails as expected. */
+#if 0
+		composite_layout_compare(l_copy_orig, l_copy_updated, false);
+#endif
+	} else if (kind_of_extent_to_add == OVERLAPPING_LEFT) {
+		/* todo This shall fail. */
+		composite_layout_compare(l_copy_orig, l_copy_updated, false);
+	} else if (kind_of_extent_to_add == OVERLAPPING_RIGHT) {
+		/* todo This shall fail. */
+		composite_layout_compare(l_copy_orig, l_copy_updated, false);
+	} else if (kind_of_extent_to_add == OVERLAPPING_COMPLETE) {
+		/* todo This shall fail. */
+		composite_layout_compare(l_copy_orig, l_copy_updated, false);
+	}
+
+	/* Delete the composite layout object. */
+	c2_layout_put(&cl->cl_base);
+	C2_UT_ASSERT(c2_layout_find(domain, lid) == NULL);
+
+	/* Read the layout from the DBand compare. */
+	rc = layout_lookup(lid, domain, !FAILURE_TEST, &l_from_DB);
+	C2_UT_ASSERT(rc == 0);
+
+	//composite_layout_compare(l_from_DB, l_copy_orig, false);
+	/* Following should succeed eventually. */
+	composite_layout_compare(l_from_DB, l_copy_updated, false);
+
+	/* Release the reference incremented by c2_layout_lookup(). */
+	c2_layout_put(l_from_DB);
+
+	composite_layout_copy_delete(l_copy_orig);
+	composite_layout_copy_delete(l_copy_updated);
+
+	/* Delete all the precreated sublayouts. */
+	sublayouts_delete(domain, lid, layers_nr);
+
+	return rc;
+}
+
 #endif /* __KERNEL__ */
 
 /*
diff --git a/layout/ut/layout.c b/layout/ut/layout.c
index 0c3f2dc..1a35db6 100644
--- a/layout/ut/layout.c
+++ b/layout/ut/layout.c
@@ -3855,6 +3855,61 @@ static void test_delete_failure(void)
 	C2_UT_ASSERT(rc == -EPROTO);
 }
 
+static void test_composite_layer_ops(void)
+{
+	uint64_t lid;
+
+	/* todo
+	 * Build a layout object with COMPOSITE layout type, with noncontiguous
+	 * extents in its layers and with the extents with the range from 0 to
+	 * C2_BINDEX_MAX and destroy it.
+	 */
+	lid = 22001;
+	rc = test_ext_lookup_composite(lid, &domain, 6, 100,
+				       lid * 100, lid * 100 * 100,
+				       !CONTIGUOUS_EXTENTS, EXACT_EXISTING,
+				       !FAILURE_TEST);
+	C2_UT_ASSERT(rc == 0);
+
+	lid = 22002;
+	rc = test_ext_lookup_composite(lid, &domain, 6, 4, /* todo 100, */
+				       lid * 100, lid * 100 * 100,
+				       !CONTIGUOUS_EXTENTS, NON_EXISTING,
+				       !FAILURE_TEST);
+	C2_UT_ASSERT(rc == 0);
+
+	/* todo Shall cover the other cases of extent type to be looked up. */
+
+	lid = 22003;
+	rc = test_ext_add_composite(lid, &domain, 6, 4,
+				    lid * 100, lid * 100 * 100,
+				    !CONTIGUOUS_EXTENTS, EXACT_EXISTING,
+				    !FAILURE_TEST);
+	C2_UT_ASSERT(rc == 0);
+
+	/* todo The following seem to have added to the mem leak. */
+	lid = 22004;
+	rc = test_ext_add_composite(lid, &domain, 6, 4,
+				    lid * 100, lid * 100 * 100,
+				    !CONTIGUOUS_EXTENTS, NON_EXISTING,
+				    !FAILURE_TEST);
+	C2_UT_ASSERT(rc == 0);
+
+
+	/* todo Dec 07 Continue from here. */
+#if 0
+	lid = 22005;
+	rc = test_ext_add_composite(lid, &domain, 6, 4,
+				    lid * 100, lid * 100 * 100,
+				    !CONTIGUOUS_EXTENTS, OVERLAPPING_LEFT,
+				    !FAILURE_TEST);
+	C2_UT_ASSERT(rc == 0);
+#endif
+
+	/* todo Shall cover the other cases of extent type to be added. */
+
+}
+
 #endif /* __KERNEL__ */
 
 const struct c2_test_suite layout_ut = {
@@ -3894,6 +3949,7 @@ const struct c2_test_suite layout_ut = {
 		{ "layout-update-failure", test_update_failure },
 		{ "layout-delete", test_delete },
 		{ "layout-delete-failure", test_delete_failure },
+		{ "layout-composite-layer-ops", test_composite_layer_ops },
 #endif
 		{ NULL, NULL }
 	}
diff --git a/layout/ut/layout.h b/layout/ut/layout.h
index ccb503d..4dad196 100644
--- a/layout/ut/layout.h
+++ b/layout/ut/layout.h
@@ -62,6 +62,19 @@ enum {
 	CONTIGUOUS_EXTENTS       = true  /* For extents of a sub-layout */
 };
 
+/*
+ * Kind of the extent that 'is to be looked up from the extent list' or 'is to
+ * be added to extent list' for a particular layer from a particular composite
+ * layout.
+ */
+enum {
+	NON_EXISTING,
+	EXACT_EXISTING,
+	OVERLAPPING_LEFT,
+	OVERLAPPING_RIGHT,
+	OVERLAPPING_COMPLETE
+};
+
 extern struct c2_layout_type c2_pdclust_layout_type;
 extern struct c2_layout_type c2_composite_layout_type;
 extern struct c2_layout_enum_type c2_list_enum_type;
@@ -171,6 +184,24 @@ int test_add_composite(uint64_t lid,
 		       bool layout_destroy, struct c2_layout **l_obj,
 		       bool duplicate_test,
 		       bool failure_test);
+int test_ext_lookup_composite(uint64_t lid,
+			      struct c2_layout_domain *domain,
+			      uint32_t layers_nr,
+			      uint32_t min_extents_nr,
+			      c2_bindex_t min_start_offset,
+			      c2_bindex_t approximate_end_offset,
+			      bool if_contiguous_extents,
+			      uint32_t kind_of_extent_to_lookup,
+			      bool failure_test);
+int test_ext_add_composite(uint64_t lid,
+			   struct c2_layout_domain *domain,
+			   uint32_t layers_nr,
+			   uint32_t min_extents_nr,
+			   c2_bindex_t min_start_offset,
+			   c2_bindex_t approximate_end_offset,
+			   bool if_contiguous_extents,
+			   uint32_t kind_of_extent_to_add,
+			   bool failure_test);
 
 /* __COLIBRI_LAYOUT_LAYOUT_H__ */
 #endif
-- 
1.8.3.2

