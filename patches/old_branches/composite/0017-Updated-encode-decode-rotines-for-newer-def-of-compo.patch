From 8a3bfe2e8b3bc91c69f535f24e19ba249e791372 Mon Sep 17 00:00:00 2001
From: "trupti.patil" <trupti_patil@xyratex.com>
Date: Fri, 9 Nov 2012 11:55:55 +0530
Subject: [PATCH 017/172] Updated encode decode rotines for newer def of
 composite layout

---
 layout/composite.c    | 170 ++++++++++++++++----------------
 layout/composite.h    |  64 +++++++++---
 layout/layout.c       |   2 +-
 layout/ut/composite.c | 263 ++++++++++++++++++++++++++++++++------------------
 layout/ut/layout.c    |  79 ++++++++++++---
 layout/ut/layout.h    |  20 ++++
 6 files changed, 394 insertions(+), 204 deletions(-)

diff --git a/layout/composite.c b/layout/composite.c
index 4ca9574..7cee3cc 100644
--- a/layout/composite.c
+++ b/layout/composite.c
@@ -109,7 +109,10 @@ static bool composite_invariant(const struct c2_composite_layout *cl)
 		cl->cl_sublayouts_nr ==
 			c2_sub_layout_tlist_length(cl->cl_sub_layouts) &&
 		c2_tl_forall(c2_sub_layout, sl, cl->cl_sub_layouts,
-			     c2_layout__invariant(sl->csl_l));
+			     c2_layout__invariant(sl->csl_l) &&
+			     sl->csl_extents != NULL &&
+			     sl->csl_extents_nr ==
+			     c2_layout_extent_tlist_length(sl->csl_extents));
 }
 
 static const struct c2_layout_ops composite_ops;
@@ -209,7 +212,7 @@ int c2_composite_build(struct c2_layout_domain *dom,
 
 	rc = composite_allocate(dom, lid, &l);
 	if (rc == 0) {
-		/* Here composite_allocate() has locked l->l_lock. */
+		/* Here, composite_allocate() has locked l->l_lock. */
 		cl = bob_of(l, struct c2_composite_layout, cl_base,
 			    &composite_bob);
 		C2_ASSERT(composite_allocated_invariant(cl));
@@ -249,7 +252,10 @@ static void composite_fini(struct c2_ref *ref)
 			c2_free(sl_ext);
 		} c2_tl_endfor;
 		c2_free(sl->csl_extents);
-
+		/*
+		 * Decrement the user count incremented by
+		 * c2_composite_layer_add().
+		 */
 		c2_layout_user_count_dec(sl->csl_l);
 		/*
 		 * Release the reference acquired by c2_composite_layer_add().
@@ -280,7 +286,7 @@ int c2_composite_layer_add(struct c2_composite_layout *cl,
 
 	C2_ENTRY();
 	if (c2_layout_extent_tlist_is_empty(extlist)) {
-		//todo Handle error
+		//todo ADDB, TRACE rec etc
 		return -EINVAL;
 	}
 
@@ -291,6 +297,7 @@ int c2_composite_layer_add(struct c2_composite_layout *cl,
 
 	sl->csl_l = l;
 	sl->csl_extents = extlist;
+	sl->csl_extents_nr = ext_nr;
 	c2_layout_get(sl->csl_l);
 	c2_layout_user_count_inc(sl->csl_l);
 	c2_sub_layout_tlink_init_at_tail(sl, cl->cl_sub_layouts);
@@ -476,19 +483,19 @@ static int composite_decode(struct c2_layout *l,
 			    uint32_t user_count)
 {
 	struct c2_composite_layout     *cl;
-	struct c2_composite_sub_layout *sl;
-	struct c2_ext                  *ext_list;
-	struct c2_tl                   *extlist = NULL;
-	//struct c2_tl                   *sub_layouts;
-	struct sub_layouts_header      *sl_header;
-	struct sub_layout_entry        *sl_entry;
-	uint32_t                        nr;
+	struct c2_layout               *sublayout;
+	struct c2_tl                   *extents;
+	struct composite_header        *cl_header;
+	struct sub_layout_header       *sl_header;
+	struct c2_sub_layout_extent    *sl_ext;
+	struct c2_ext                  *ext;
 	uint32_t                        i;
+	uint32_t                        j;
 	int                             rc;
 
 	C2_PRE(c2_layout__allocated_invariant(l));
 	C2_PRE(cur != NULL);
-	C2_PRE(c2_bufvec_cursor_step(cur) >= sizeof *sl_header);
+	C2_PRE(c2_bufvec_cursor_step(cur) >= sizeof *cl_header);
 	C2_PRE(C2_IN(op, (C2_LXO_DB_LOOKUP, C2_LXO_BUFFER_OP)));
 	C2_PRE(ergo(op == C2_LXO_DB_LOOKUP, tx != NULL));
 
@@ -496,71 +503,69 @@ static int composite_decode(struct c2_layout *l,
 	cl = bob_of(l, struct c2_composite_layout, cl_base, &composite_bob);
 	C2_PRE(composite_allocated_invariant(cl));
 
-	sl_header = c2_bufvec_cursor_addr(cur);
-	c2_bufvec_cursor_move(cur, sizeof *sl_header);
-	C2_ASSERT(c2_bufvec_cursor_step(cur) >= sl_header->slh_sublayouts_nr *
-						sizeof *sl_entry);
+	cl_header = c2_bufvec_cursor_addr(cur);
+	c2_bufvec_cursor_move(cur, sizeof *cl_header);
+	C2_ASSERT(c2_bufvec_cursor_step(cur) >=
+		  cl_header->ch_sublayouts_nr * sizeof *sl_header);
 
-#if 0
-	C2_ALLOC_PTR(sub_layouts);
-	if (sub_layouts == NULL) {
-		c2_layout__log("composite_decode", "C2_ALLOC_PTR() failed",
-			       &c2_addb_oom, &l->l_addb,
-			       l->l_id, -ENOMEM);
-		return -ENOMEM;
-	}
-	c2_sub_layout_tlist_init(sub_layouts);
-#endif
+	composite_populate(cl, user_count);
+	C2_ASSERT(composite_invariant(cl));
 
 	if (op == C2_LXO_BUFFER_OP) {
 		/*
 		 * Parse the sub-layout information from the buffer pointed by
-		 * cur and store it in the sub_layouts list.
+		 * cur and add those sub-layouts to the composite layout.
 		 */
-
-		C2_ALLOC_ARR(ext_list, sl_header->slh_sublayouts_nr);
-		for (i = 0; i < sl_header->slh_sublayouts_nr; ++i) {
-			sl_entry = c2_bufvec_cursor_addr(cur);
-			c2_bufvec_cursor_move(cur, sizeof *sl_entry);
-
-			C2_ALLOC_PTR(sl);
-			if (sl == NULL) {
+		for (i = 0; i < cl_header->ch_sublayouts_nr; ++i) {
+			C2_ALLOC_PTR(extents);
+			if (extents == NULL) {
+				//todo Handle error
+#if 0 //tune
 				c2_layout__log("composite_decode",
 					       "C2_ALLOC_PTR() failed",
 					       &c2_addb_oom, &l->l_addb,
 					       l->l_id, -ENOMEM);
 				return -ENOMEM;
+#endif
+			}
+			c2_layout_extent_tlist_init(extents);
+
+			sl_header = c2_bufvec_cursor_addr(cur);
+			c2_bufvec_cursor_move(cur, sizeof *sl_header);
+			sublayout = c2_layout_find(l->l_dom,
+						   sl_header->slh_lid);
+			if (sublayout == NULL) {
+				/**
+				 * todo Handle error. Eventually the layout
+				 * should be fetched either from the DB or
+				 * over the network, as applicable.
+				 */
 			}
+			C2_ASSERT(sublayout != NULL);
+			for (j = 0; j < sl_header->slh_extents_nr; ++j) {
+				C2_ALLOC_PTR(sl_ext);
+				if (sl_ext == NULL) {
+					//todo Handle error
+				}
+				ext = c2_bufvec_cursor_addr(cur);
+				c2_bufvec_cursor_move(cur, sizeof *ext);
+				sl_ext->sle_ext = *ext;
+				c2_layout_extent_tlink_init_at_tail(sl_ext,
+								    extents);
+			}
+
+			//C2_ASSERT(l->l_user_count > 0); //todo
+			rc = c2_composite_layer_add(cl, sublayout, extents,
+						    sl_header->slh_extents_nr);
+			C2_ASSERT(rc == 0); //todo Handle error
 
 			/*
-			 * The reference acquired here using c2_layout_find()
-			 * and the addition of user count on each sub-layout
-			 * will be undone by composite_fini().
+			 * Release the reference added by c2_layout_find().
+			 * c2_composite_layer_add() has added a reference on
+			 * this sublayout.
 			 */
-			sl->csl_l = c2_layout_find(cl->cl_base.l_dom,
-						   sl_entry->sle_lid);
-			if (sl->csl_l == NULL) {
-				C2_LOG(C2_ERROR, "sub-layout-lid %llu, "
-				       "sub-layout not found in the cache, "
-				       "rc %d",
-				       (unsigned long long)sl_entry->sle_lid,
-				       -EPROTO);
-				/* todo Undo in case ref is taken on some
-				 * sub-layouts, user count addition and undo
-				 * C2_ALLOC_PTR(sl) and
-				 * c2_sub_layout_tlink_init_at(). */
-				return -EPROTO;
-			}
-
-			c2_layout_user_count_inc(sl->csl_l);
-			//todo ext_list[i] = sl_entry->sle_ext;
-			//c2_sub_layout_tlink_init_at(sl, sub_layouts);
+			c2_layout_put(sublayout);
 		}
-		C2_ASSERT(i == sl_header->slh_sublayouts_nr);
-		nr = sl_header->slh_sublayouts_nr; //todo Optimize code
-		rc = c2_composite_layer_add(cl, sl->csl_l, extlist,
-				/* todo */ sl_header->slh_sublayouts_nr);
-		C2_ASSERT(rc == 0); //todo Handle error
 	} else {
 		/*
 		 * Read all the sub-layouts from the layout DB and store them
@@ -571,7 +576,6 @@ static int composite_decode(struct c2_layout *l,
 		C2_ASSERT(0);
 	}
 
-	composite_populate(cl, /* sub_layouts, nr, */ user_count);
 	rc = 0; //todo
 	C2_POST(ergo(rc == 0, composite_invariant(cl)));
 	C2_POST(ergo(rc != 0, composite_allocated_invariant(cl)));
@@ -680,11 +684,9 @@ static int composite_encode(struct c2_layout *l,
 {
 	struct c2_composite_layout     *cl;
 	struct c2_composite_sub_layout *sl;
-	struct sub_layouts_header       sl_header;
-	struct sub_layout_entry         sl_entry;
-	uint32_t                        sublayouts_nr;//todo since in invar
+	struct composite_header         cl_header;
+	struct sub_layout_header        sl_header;
 	struct c2_sub_layout_extent    *sl_ext;
-	struct c2_ext                   ext;
 	c2_bcount_t                     nbytes;
 	int                             rc;
 
@@ -698,29 +700,29 @@ static int composite_encode(struct c2_layout *l,
 
 	cl = c2_layout_to_cl(l);
 	if (op == C2_LXO_BUFFER_OP) {
-		C2_ASSERT(c2_bufvec_cursor_step(out) >= sizeof sl_header);
-		sl_header.slh_sublayouts_nr = cl->cl_sublayouts_nr;
-		nbytes = c2_bufvec_cursor_copyto(out, &sl_header,
-						 sizeof sl_header);
-		C2_ASSERT(nbytes == sizeof sl_header);
+		/*
+		 * Read sub-layout information from the composite layout viz.
+		 * cl and store it in the buffer.
+		 */
+		C2_ASSERT(c2_bufvec_cursor_step(out) >= sizeof cl_header);
+		cl_header.ch_sublayouts_nr = cl->cl_sublayouts_nr;
+		nbytes = c2_bufvec_cursor_copyto(out, &cl_header,
+						 sizeof cl_header);
+		C2_ASSERT(nbytes == sizeof cl_header);
 		C2_ASSERT(c2_bufvec_cursor_step(out) >= cl->cl_sublayouts_nr *
-							sizeof sl_entry);
-		sublayouts_nr = 0;
+							sizeof sl_header);
 		c2_tl_for(c2_sub_layout, cl->cl_sub_layouts, sl) {
-			sl_entry.sle_lid        = sl->csl_l->l_id;
-			sl_entry.sle_extents_nr = sl->csl_extents_nr;
-			nbytes = c2_bufvec_cursor_copyto(out, &sl_entry,
-							 sizeof sl_entry);
+			sl_header.slh_lid = sl->csl_l->l_id;
+			sl_header.slh_extents_nr = sl->csl_extents_nr;
+			nbytes = c2_bufvec_cursor_copyto(out, &sl_header,
+							 sizeof sl_header);
 			c2_tl_for(c2_layout_extent, sl->csl_extents, sl_ext) {
-				ext = sl_ext->sle_ext;
-				nbytes = c2_bufvec_cursor_copyto(out, &ext,
-								 sizeof ext);
-				C2_ASSERT(nbytes == sizeof sl_entry);
+				nbytes = c2_bufvec_cursor_copyto(out,
+							&sl_ext->sle_ext,
+							sizeof sl_ext->sle_ext);
+				C2_ASSERT(nbytes == sizeof sl_ext->sle_ext);
 			} c2_tl_endfor;
-			//todo Verify number of extents.
-			++sublayouts_nr;
 		} c2_tl_endfor;
-		C2_ASSERT(sublayouts_nr == cl->cl_sublayouts_nr);
 		rc = 0;
 	} else if (op == C2_LXO_DB_UPDATE) {
 		/* todo */
diff --git a/layout/composite.h b/layout/composite.h
index be292ff..69d958f 100644
--- a/layout/composite.h
+++ b/layout/composite.h
@@ -61,7 +61,8 @@ struct c2_composite_layout {
 };
 
 /**
- * todo
+ * todo Desc
+ * todo Rename this to c2_composite_layer
  */
 struct c2_composite_sub_layout {
 	/** Layout this sub-layout is part of. todo Check if req'd */
@@ -143,38 +144,71 @@ struct c2_layout *c2_cl_to_layout(struct c2_composite_layout *cl);
 extern struct c2_layout_type c2_composite_layout_type;
 
 /**
- * Following structure is a part of the internal implementation. It is required
- * to be accessed by the UT as well. Hence, is placed here in the header file.
- *
- * Structure used to store number of sub-layouts in a buffer.
+ * Following structures are a part of the internal implementation. They are
+ * required to be accessed by the UT as well. Hence, they are placed here in
+ * the header file.
+ */
+
+/**
+ * Structure used to store header information for a composite layout like
+ * number of sub-layouts from the buffer representing the composite layout.
  *
  * @note This structure needs to be maintained as 8 bytes aligned.
- * todo BASSERT
  */
-struct sub_layouts_header {
+struct composite_header {
 	/** Total number of sub-layouts in a specific composite layout. */
-	uint32_t slh_sublayouts_nr;
+	uint32_t ch_sublayouts_nr;
 
 	/** Padding to make the structure 8 bytes aligned. */
-	uint32_t slh_pad;
+	uint32_t ch_pad;
 };
+C2_BASSERT(C2_IS_8ALIGNED(sizeof(struct composite_header)));
 
 /**
- * Following structure is a part of the internal implementation. It is required
- * to be accessed by the UT as well. Hence, is placed here in the header file.
+ * Structure used to store header information for a sub-layout like number of
+ * extents of the sub-layout from the buffer representing the composite layout.
  *
- * Structure used to store information about sub-layouts in a buffer.
+ * @note This structure needs to be maintained as 8 bytes aligned.
+ */
+struct sub_layout_header { //todo composite_layer_header
+	/** Layout id for the sub-layout. */
+	uint64_t slh_lid;
+
+	/** Number of extents belonging to this sub-layout. */
+	uint32_t slh_extents_nr;
+
+	/** Padding to make the structure 8 bytes aligned. */
+	uint32_t slh_pad;
+
+        /**
+         * Payload storing list of slh_extents_nr number of extents
+	 * (struct c2_ext) for a specific sublayout.
+         */
+	char     slh_extents[0];
+
+};
+C2_BASSERT(C2_IS_8ALIGNED(sizeof(struct sub_layout_header)));
+
+#if 0
+/**
+ * Structure used to store information about a sub-layout from the buffer
+ * representing the composite layout.
  *
  * @note This structure needs to be maintained as 8 bytes aligned.
  * todo BASSERT
  */
 struct sub_layout_entry {
 	/** Layout id for the sub-layout. */
-	uint64_t       sle_lid;
+	//todo Remove if not must to have uint64_t sle_lid;
 
-	/** Number of extents belonging to this sub-layout. */
-	uint32_t       sle_extents_nr;
+	/**
+	 * Payload storing list of extents (struct c2_ext) for the specific
+	 * sublayout.
+	*/
+	char     sle_cobs[0];
 };
+C2_BASSERT(C2_IS_8ALIGNED(sizeof(struct sub_layout_entry)));
+#endif
 
 /** @} end group composite */
 
diff --git a/layout/layout.c b/layout/layout.c
index 28ec47f..d58adbf 100644
--- a/layout/layout.c
+++ b/layout/layout.c
@@ -931,7 +931,7 @@ struct c2_layout *c2_layout_find(struct c2_layout_domain *dom, uint64_t lid)
 	struct c2_layout *l;
 
 	C2_PRE(c2_layout__domain_invariant(dom));
-	C2_PRE(lid != LID_NONE);
+	C2_PRE(lid > 0);
 
 	C2_ENTRY("lid %llu", (unsigned long long)lid);
 	c2_mutex_lock(&dom->ld_lock);
diff --git a/layout/ut/composite.c b/layout/ut/composite.c
index a1202f5..9b5cc30 100644
--- a/layout/ut/composite.c
+++ b/layout/ut/composite.c
@@ -58,11 +58,10 @@ static void sublayout_build(uint64_t lid, struct c2_layout **sub_layout)
 	*sub_layout = c2_pdl_to_layout(pl);
 }
 
-static void extentlist_build(uint64_t sublayout_lid, //todo not req'd ?
-			     struct c2_tl **extlist,
+static void extentlist_build(struct c2_tl **extlist,
 			     uint32_t extents_nr,
-			     c2_bindex_t min_offset,
-			     c2_bindex_t max_offset,
+			     c2_bindex_t min_start_offset,
+			     c2_bindex_t approximate_end_offset,
 			     bool if_contiguous_extents)
 {
 	struct c2_tl                *extents;
@@ -78,17 +77,19 @@ static void extentlist_build(uint64_t sublayout_lid, //todo not req'd ?
 	C2_UT_ASSERT(c2_layout_extent_tlist_is_empty(extents));
 
 	multiplier = if_contiguous_extents ? 1 : 2;
-	delta = (max_offset - min_offset + 1) / (extents_nr * multiplier);
+	delta = (approximate_end_offset - min_start_offset + 1) /
+		(extents_nr * multiplier);
 #ifndef __KERNEL__
-		printf("extents_nr %lu, min_offset %llu, max_offset %llu \n",
+		printf("min_extents_nr %lu, min_start_offset %llu, "
+		       "approximate_end_offset %llu\n",
 			(unsigned long)extents_nr,
-			(unsigned long long)min_offset,
-			(unsigned long long)max_offset);
+			(unsigned long long)min_start_offset,
+			(unsigned long long)approximate_end_offset);
 #endif
 	for (i = 0; i < extents_nr; ++i) {
 		C2_ALLOC_PTR(sl_ext);
 		C2_UT_ASSERT(sl_ext != NULL);
-		sl_ext->sle_ext.e_start = min_offset +
+		sl_ext->sle_ext.e_start = min_start_offset +
 					  (multiplier * i * delta);
 		sl_ext->sle_ext.e_end = sl_ext->sle_ext.e_start + delta - 1;
 #ifndef __KERNEL__
@@ -104,8 +105,10 @@ static void extentlist_build(uint64_t sublayout_lid, //todo not req'd ?
 
 static void composite_layout_verify(struct c2_layout *l,
 				    uint64_t composite_lid,
-				    uint32_t num_sublayouts,
-				    uint32_t extents_nr,
+				    uint32_t sublayouts_nr,
+				    uint32_t min_extents_nr,
+				    c2_bindex_t min_start_offset,
+				    c2_bindex_t approximate_end_offset,
 				    bool if_contiguous_extents)
 {
 	bool                            inline_test;
@@ -120,21 +123,24 @@ static void composite_layout_verify(struct c2_layout *l,
 	c2_bindex_t			delta;
 	c2_bindex_t                     multiplier;
 	struct c2_sub_layout_extent    *sl_ext;
-	c2_bindex_t                     min_offset;
-	c2_bindex_t                     max_offset;
+	uint32_t                        extents_nr;
 	uint32_t                        i;
 	uint32_t                        j;
 
 	C2_UT_ASSERT(l != NULL);
 	C2_UT_ASSERT(l->l_type == &c2_composite_layout_type);
 
+	/* Verify the generic layout data. */
 	cl = c2_layout_to_cl(l);
 	l_verify(l, composite_lid, !USER_COUNT_INCREMENTED);
 
+	/* Verify the composite type specific data. */
 	c2_uint128_init(&seed, "sub_layouts_buil");
 	multiplier = if_contiguous_extents ? 1 : 2;
 
+	/* Verify the layers */
 	i = 0;
+	extents_nr = min_extents_nr;
         c2_tl_for(c2_sub_layout, cl->cl_sub_layouts, sl) {
 		/* Verify the sub-layout. */
 		sublayout_lid = composite_lid * 100 + i;
@@ -147,33 +153,41 @@ static void composite_layout_verify(struct c2_layout *l,
 				      USER_COUNT_INCREMENTED);
 		C2_UT_ASSERT(sl->csl_l->l_user_count == 1);
 
-		/* Verify sl->csl_ext. */
+		C2_UT_ASSERT(sl->csl_extents_nr == extents_nr);
+
+		/* Verify the extents. */
 		j = 0;
-		min_offset = sublayout_lid;
-		max_offset = min_offset * 100;
-		delta = (max_offset - min_offset + 1) /
+		delta = (approximate_end_offset - min_start_offset + 1) /
 			(extents_nr * multiplier);
 		c2_tl_for(c2_layout_extent, sl->csl_extents, sl_ext) {
-			C2_UT_ASSERT(sl_ext->sle_ext.e_start == min_offset +
-						(multiplier * j * delta));
+			C2_UT_ASSERT(sl_ext->sle_ext.e_start ==
+				     min_start_offset +
+				     (multiplier * j * delta));
 			C2_UT_ASSERT(sl_ext->sle_ext.e_end ==
 				     sl_ext->sle_ext.e_start + delta - 1);
 			++j;
 		} c2_tl_endfor;
-		C2_UT_ASSERT(j == extents_nr); 
+		C2_UT_ASSERT(j == extents_nr);
 		++i;
+		++extents_nr;
         } c2_tl_endfor;
-	C2_UT_ASSERT(i == num_sublayouts);
+	C2_UT_ASSERT(i == sublayouts_nr);
 }
 
 /*
- * Builds a layout object with COMPOSITE layout type and adds sub-layouts
- * to it.
+ * Builds a layout object with COMPOSITE layout type and adds layers to it.
+ * The 'number of extents, start offset and end offset are varied (incremented
+ * by one) for each layer. Effectively, as of now, extents of one layer are
+ * overlapping to the extents of another layer.
  */
 int composite_layout_build(uint64_t lid,
 			   struct c2_layout_domain *domain,
 			   struct c2_composite_layout **cl,
-			   uint32_t num_sublayouts,
+			   uint32_t sublayouts_nr,
+			   uint32_t min_extents_nr,
+			   c2_bindex_t min_start_offset,
+			   c2_bindex_t approximate_end_offset,
+			   bool if_contiguous_extents,
 			   bool failure_test)
 {
 	struct c2_layout *sl;
@@ -198,23 +212,20 @@ int composite_layout_build(uint64_t lid,
 	C2_UT_ASSERT(l_from_cl == &(*cl)->cl_base);
 
 	/* Verify the composite layout object contents. */
-	composite_layout_verify(l_from_cl, lid, 0, 0, CONTIGUOUS_EXTENTS);
+	composite_layout_verify(l_from_cl, lid, 0, 0, 0, 0,
+				if_contiguous_extents);
 
 	/* Add sub-layouts. */
-	for (i = 0; i < num_sublayouts; ++i) {
+	extents_nr = min_extents_nr;
+	for (i = 0; i < sublayouts_nr; ++i, ++extents_nr) {
 		sublayout_lid = lid * 100 + i;
 		/* Build a layout to be used as a sub-layout. */
 		sublayout_build(lid * 100 + i, &sl); /* lid * 100 + i */
 
 		/* Build extent list to be owned by the sub-layout. */
-		extents_nr = 100;
-		extentlist_build(sublayout_lid, &extents, extents_nr,
-				 sublayout_lid, sublayout_lid * 100,
-				 CONTIGUOUS_EXTENTS);
-		//todo min_offset and max_offset (extents_nr and if_cont_ext)
-		//shud be accepted as args to this fn
-		// so that they can be used to test the boundary conditions.
-
+		extentlist_build(&extents, extents_nr,
+				 min_start_offset, approximate_end_offset,
+				 if_contiguous_extents);
 		rc = c2_composite_layer_add(*cl, sl, extents, extents_nr);
 		C2_UT_ASSERT(rc == 0);
 
@@ -226,8 +237,10 @@ int composite_layout_build(uint64_t lid,
 		c2_layout_put(sl);
 
 		/* Verify the composite layout object contents. */
-		composite_layout_verify(l_from_cl, lid, i + 1, extents_nr,
-					CONTIGUOUS_EXTENTS);
+		composite_layout_verify(l_from_cl, lid, i + 1, min_extents_nr,
+					min_start_offset,
+					approximate_end_offset,
+					if_contiguous_extents);
 	}
 	return rc;
 }
@@ -240,12 +253,21 @@ int composite_layout_build(uint64_t lid,
  */
 int test_build_composite(uint64_t lid,
 			 struct c2_layout_domain *domain,
+			 uint32_t sublayouts_nr,
+			 uint32_t min_extents_nr,
+			 c2_bindex_t min_start_offset,
+			 c2_bindex_t approximate_end_offset,
+			 bool if_contiguous_extents,
 			 bool failure_test)
 {
 	struct c2_composite_layout *cl;
 	struct c2_layout           *l;
 
-	rc = composite_layout_build(lid, domain, &cl, 5, failure_test);
+	rc = composite_layout_build(lid, domain, &cl, sublayouts_nr,
+				    min_extents_nr, min_start_offset,
+				    approximate_end_offset,
+				    if_contiguous_extents,
+				    failure_test);
 	if (failure_test)
 		C2_UT_ASSERT(rc == -ENOMEM);
 	else {
@@ -268,59 +290,101 @@ int test_build_composite(uint64_t lid,
 	return rc;
 }
 
-#if 0
 /* Builds a buffer containing serialised representation of a layout object. */
-static int composite_layout_buf_build(uint64_t lid,
-				      uint32_t num_sublayouts,
-				      c2_bindex_t end_offset,
-				      struct c2_bufvec_cursor *dcur)
+static void composite_layout_buf_build(uint64_t composite_lid,
+				       uint32_t sublayouts_nr,
+				       uint32_t min_extents_nr,
+				       c2_bindex_t min_start_offset,
+				       c2_bindex_t approximate_end_offset,
+				       bool if_contiguous_extents,
+				       struct c2_bufvec_cursor *dcur)
 {
-	c2_bcount_t                     nbytes;
-	struct c2_tl                   *sub_layout_list;
-	struct c2_composite_sub_layout *sl;
-	struct sub_layouts_header       sl_header;
-	struct sub_layout_entry         sl_entry;
+	c2_bcount_t               nbytes;
+	uint64_t                  sublayout_lid;
+	struct c2_layout         *sub_layout;
+	struct composite_header   cl_header;
+	struct sub_layout_header  sl_header;
+	struct c2_ext             ext;
+	c2_bindex_t               delta;
+	c2_bindex_t               multiplier;
+	uint32_t                  extents_nr;
+	uint32_t                  i;
+	uint32_t                  j;
 
 	C2_UT_ASSERT(dcur != NULL);
+	C2_UT_ASSERT(sublayouts_nr > 0);
 
 	/* Build part of the buffer representing generic part of the layout. */
-	buf_build(c2_composite_layout_type.lt_id, dcur);
-
-	/* Build sub-layouts. */
-	sub_layouts_build(lid, &sub_layout_list, num_sublayouts);
+	generic_buf_build(c2_composite_layout_type.lt_id, dcur);
 
 	/*
 	 * Build part of the buffer representing composite type specific part
 	 * of the layout.
 	 */
-	sl_header.slh_sublayouts_nr = num_sublayouts;
-	C2_ASSERT(c2_bufvec_cursor_step(dcur) >= sizeof sl_header);
-	nbytes = c2_bufvec_cursor_copyto(dcur, &sl_header, sizeof sl_header);
-	C2_ASSERT(nbytes == sizeof sl_header);
-
-	C2_ASSERT(c2_bufvec_cursor_step(dcur) >= sl_header.slh_sublayouts_nr *
-						 sizeof sl_entry);
-	c2_tl_for(c2_sub_layout, sub_layout_list, sl) {
-		sl_entry.sle_lid         = sl->csl_l->l_id;
-		sl_entry.sle_ext.e_start = sl->csl_ext.e_start;
-		sl_entry.sle_ext.e_end   = sl->csl_ext.e_end;
-		nbytes = c2_bufvec_cursor_copyto(dcur, &sl_entry,
-						 sizeof sl_entry);
-		C2_ASSERT(nbytes == sizeof sl_entry);
-		c2_sub_layout_tlist_del(sl);
-		c2_sub_layout_tlink_fini(sl);
-		c2_free(sl);
-	} c2_tl_endfor;
-
-        c2_sub_layout_tlist_fini(sub_layout_list);
-        c2_free(sub_layout_list);
-	return 0;
-}
+	C2_ASSERT(c2_bufvec_cursor_step(dcur) >= sizeof cl_header);
+	cl_header.ch_sublayouts_nr = sublayouts_nr;
+	nbytes = c2_bufvec_cursor_copyto(dcur, &cl_header, sizeof cl_header);
+	C2_ASSERT(nbytes == sizeof cl_header);
+
+	C2_ASSERT(c2_bufvec_cursor_step(dcur) >= cl_header.ch_sublayouts_nr *
+						 sizeof sl_header);
+	multiplier = if_contiguous_extents ? 1 : 2;
+
+#ifndef __KERNEL__
+	printf("composite_layout_buf_build(): lid %llu, "
+		"min_extents_nr %lu, min_start_offset %llu, "
+		"approximate_end_offset %llu\n",
+		(unsigned long long)composite_lid,
+		(unsigned long)min_extents_nr,
+		(unsigned long long)min_start_offset,
+		(unsigned long long)approximate_end_offset);
 #endif
+	extents_nr = min_extents_nr;
+	for (i = 0; i < cl_header.ch_sublayouts_nr; ++i, ++extents_nr) {
+		sublayout_lid = composite_lid * 100 + i;
+		//todo Pre-create a few layouts
+		sublayout_build(sublayout_lid, &sub_layout);
+		sl_header.slh_lid = sublayout_lid;
+		sl_header.slh_extents_nr = extents_nr;
+		nbytes = c2_bufvec_cursor_copyto(dcur, &sl_header,
+						 sizeof sl_header);
+		C2_ASSERT(nbytes == sizeof sl_header);
+
+		delta = (approximate_end_offset - min_start_offset + 1) /
+			(extents_nr * multiplier);
+#ifndef __KERNEL__
+		printf("composite_layout_buf_build(): extents_nr %lu, "
+			"delta %llu\n",
+			(unsigned long)extents_nr,
+			(unsigned long long)delta);
+#endif
+		for (j = 0; j < sl_header.slh_extents_nr; ++j) {
+			ext.e_start = min_start_offset +
+				      (multiplier * j * delta);
+			ext.e_end = ext.e_start + delta - 1;
+			nbytes = c2_bufvec_cursor_copyto(dcur, &ext,
+							 sizeof ext);
+			C2_ASSERT(nbytes == sizeof ext);
+#ifndef __KERNEL__
+			printf("layer[%lu]:extent[%lu]: e_start %llu, "
+				"e_end %llu \n",
+				(unsigned long)i, (unsigned long)j,
+				(unsigned long long)ext.e_start,
+				(unsigned long long)ext.e_end);
+#endif
+		}
+	}
+}
 
-#if 0
 /* Tests the API c2_layout_decode() for COMPOSITE layout type. */
-static int test_decode_composite(uint64_t lid, bool failure_test)
+int test_decode_composite(uint64_t lid,
+			  struct c2_layout_domain *domain,
+			  uint32_t sublayouts_nr,
+			  uint32_t min_extents_nr,
+			  c2_bindex_t min_start_offset,
+			  c2_bindex_t approximate_end_offset,
+			  bool if_contiguous_extents,
+			  bool failure_test)
 {
 	void                    *area;
 	c2_bcount_t              num_bytes;
@@ -329,23 +393,24 @@ static int test_decode_composite(uint64_t lid, bool failure_test)
 	struct c2_layout        *l;
 	struct c2_layout_type   *lt;
 	uint64_t                 sublayout_lid;
+	struct c2_layout        *sl;
 	uint32_t                 i;
 
 	C2_ENTRY();
 
 	/* Build a layout buffer. */
-	allocate_area(&area, ADDITIONAL_BYTES_DEFAULT, &num_bytes);
+	allocate_area(&area, ADDITIONAL_BYTES_DEFAULT * 4, &num_bytes);
 	bv = (struct c2_bufvec) C2_BUFVEC_INIT_BUF(&area, &num_bytes);
 	c2_bufvec_cursor_init(&cur, &bv);
-
-	rc = composite_layout_buf_build(lid, 60, 6000, &cur);
-	C2_UT_ASSERT(rc == 0);
+	composite_layout_buf_build(lid, sublayouts_nr, min_extents_nr,
+				   min_start_offset, approximate_end_offset,
+				   if_contiguous_extents, &cur);
 
 	/* Rewind the cursor. */
 	c2_bufvec_cursor_init(&cur, &bv);
 
 	lt = &c2_composite_layout_type;
-	rc = lt->lt_ops->lto_allocate(&domain, lid, &l);
+	rc = lt->lt_ops->lto_allocate(domain, lid, &l);
 	C2_UT_ASSERT(rc == 0);
 
 	/* Decode the layout buffer into a layout object. */
@@ -355,10 +420,12 @@ static int test_decode_composite(uint64_t lid, bool failure_test)
 	else {
 		C2_UT_ASSERT(rc == 0);
 		C2_UT_ASSERT(list_lookup(lid) == l);
-#if 0
+
 		/* Verify the layout object built by c2_layout_decode(). */
-		composite_layout_verify(l, lid, 6);
-#endif
+		composite_layout_verify(l, lid, sublayouts_nr, min_extents_nr,
+					min_start_offset,
+					approximate_end_offset,
+					if_contiguous_extents);
 	}
 
 	/* Destroy the layout object. */
@@ -372,23 +439,32 @@ static int test_decode_composite(uint64_t lid, bool failure_test)
 	}
 	C2_UT_ASSERT(list_lookup(lid) == NULL);
 
-	/* Delete all the sub-layouts. */
-	for (i = 0; i < 60; ++i) {
+	/*
+	 * Destroy all the sub-layouts created through
+	 * composite_layout_buf_build().
+	 */
+	for (i = 0; i < sublayouts_nr; ++i) {
 		sublayout_lid = lid * 100 + i;
-		l = c2_layout_find(&domain, sublayout_lid);
-		c2_layout_put(l);
-		c2_layout_put(l);
+		sl = c2_layout_find(domain, sublayout_lid);
+		C2_UT_ASSERT(sl != NULL);
+		c2_layout_put(sl);
+		c2_layout_put(sl);
+		C2_UT_ASSERT(c2_layout_find(domain, sublayout_lid) == NULL);
 	}
 
 	c2_free(area);
 	C2_LEAVE();
 	return rc;
 }
-#endif
 
 /* Tests the API c2_layout_encode() for COMPOSITE layout type. */
 int test_encode_composite(uint64_t lid,
 			  struct c2_layout_domain *domain,
+			  uint32_t sublayouts_nr,
+			  uint32_t min_extents_nr,
+			  c2_bindex_t min_start_offset,
+			  c2_bindex_t approximate_end_offset,
+			  bool if_contiguous_extents,
 			  bool failure_test)
 {
 	struct c2_composite_layout   *cl;
@@ -399,7 +475,10 @@ int test_encode_composite(uint64_t lid,
 	C2_ENTRY("lid %llu", (unsigned long long)lid);
 
 	/* Build a layout object. */
-	rc = composite_layout_build(lid, domain, &cl, 12, failure_test);
+	rc = composite_layout_build(lid, domain, &cl, sublayouts_nr,
+				    min_extents_nr, min_start_offset,
+				    approximate_end_offset,
+				    if_contiguous_extents, failure_test);
 	if (failure_test)
 		C2_UT_ASSERT(rc == -ENOMEM);
 	else
@@ -635,7 +714,7 @@ static int test_lookup_composite(uint64_t lid,
 
 #if 0
 /* Tests the API c2_layout_add(), for the COMPOSITE layout type. */
-//todo Make this accept num_sublayouts
+//todo Make this accept sublayouts_nr
 static int test_add_composite(uint64_t lid,
 			      bool layout_destroy, struct c2_layout **l_obj,
 			      bool duplicate_test,
diff --git a/layout/ut/layout.c b/layout/ut/layout.c
index 6b35fee..f80b49e 100644
--- a/layout/ut/layout.c
+++ b/layout/ut/layout.c
@@ -450,7 +450,7 @@ static void test_reg_unreg_failure(void)
 	C2_LEAVE();
 }
 
-static struct c2_layout *list_lookup(uint64_t lid)
+struct c2_layout *list_lookup(uint64_t lid)
 {
 	struct c2_layout *l;
 
@@ -813,9 +813,24 @@ static void test_build(void)
 				!FAILURE_TEST);
 	C2_UT_ASSERT(rc == 0);
 
-	/* Build a layout object with COMPOSITE layout type and destroy it. */
+	/*
+	 * Build a layout object with COMPOSITE layout type, with contiguous
+	 * extents in its layers and destroy it.
+	 */
 	lid = 1005;
-	rc = test_build_composite(lid, &domain, !FAILURE_TEST);
+	rc = test_build_composite(lid, &domain, 5, 100,
+				  lid * 100, lid * 100 * 100,
+				  CONTIGUOUS_EXTENTS, !FAILURE_TEST);
+	C2_UT_ASSERT(rc == 0);
+
+	/*
+	 * Build a layout object with COMPOSITE layout type, with noncontiguous
+	 * extents in its layers and destroy it.
+	 */
+	lid = 1006;
+	rc = test_build_composite(lid, &domain, 6, 100,
+				  lid * 100, lid * 100 * 100,
+				  !CONTIGUOUS_EXTENTS, !FAILURE_TEST);
 	C2_UT_ASSERT(rc == 0);
 }
 
@@ -895,9 +910,8 @@ static void test_build_failure(void)
 	C2_UT_ASSERT(rc == -EPROTO);
 }
 
-
 /* Builds part of the buffer representing generic part of the layout object. */
-static void buf_build(uint32_t lt_id, struct c2_bufvec_cursor *dcur)
+void generic_buf_build(uint32_t lt_id, struct c2_bufvec_cursor *dcur)
 {
 	struct c2_layout_rec rec;
 	c2_bcount_t          nbytes_copied;
@@ -921,7 +935,7 @@ static void pdclust_buf_build(uint32_t let_id, uint64_t lid,
 	struct c2_layout_pdclust_rec pl_rec;
 	c2_bcount_t                  nbytes_copied;
 
-	buf_build(c2_pdclust_layout_type.lt_id, dcur);
+	generic_buf_build(c2_pdclust_layout_type.lt_id, dcur);
 
 	pl_rec.pr_let_id            = let_id;
 	pl_rec.pr_attr.pa_N         = N;
@@ -1126,12 +1140,25 @@ static void test_decode(void)
 				 !FAILURE_TEST);
 	C2_UT_ASSERT(rc == 0);
 
-#if 0
-	/* Decode a layout object with COMPOSITE layout type. */
+	/*
+	 * Decode a layout object with COMPOSITE layout type and with
+	 * contiguous extents in its layers.
+	 */
 	lid = 3005;
-	rc = test_decode_composite(lid, !FAILURE_TEST);
+	rc = test_decode_composite(lid, &domain, 7, 10,
+				   lid * 100, lid * 100 * 100,
+				   CONTIGUOUS_EXTENTS, !FAILURE_TEST);
+	C2_UT_ASSERT(rc == 0);
+
+	/*
+	 * Decode a layout object with COMPOSITE layout type and with
+	 * noncontiguous extents in its layers.
+	 */
+	lid = 3006;
+	rc = test_decode_composite(lid, &domain, 8, 10,
+				   lid * 100, lid * 100 * 100,
+				   !CONTIGUOUS_EXTENTS, !FAILURE_TEST);
 	C2_UT_ASSERT(rc == 0);
-#endif
 }
 
 static void test_decode_failure(void)
@@ -1416,9 +1443,24 @@ static void test_encode(void)
 				 !FAILURE_TEST);
 	C2_UT_ASSERT(rc == 0);
 
-	/* Encode for COMPOSITE layout type. */
+	/*
+	 * Encode for COMPOSITE layout type with contiguous extents in its
+	 * layers.
+	 */
 	lid = 5005;
-	rc = test_encode_composite(lid, &domain, !FAILURE_TEST);
+	rc = test_encode_composite(lid, &domain, 9, 25,
+				   lid * 100, lid * 100 * 100,
+				   CONTIGUOUS_EXTENTS, !FAILURE_TEST);
+	C2_UT_ASSERT(rc == 0);
+
+	/*
+	 * Encode for COMPOSITE layout type with contiguous extents in its
+	 * layers.
+	 */
+	lid = 5006;
+	rc = test_encode_composite(lid, &domain, 10, 25,
+				   lid * 100, lid * 100 * 100,
+				   !CONTIGUOUS_EXTENTS, !FAILURE_TEST);
 	C2_UT_ASSERT(rc == 0);
 }
 
@@ -2019,6 +2061,19 @@ static void test_encode_decode(void)
 	rc = test_encode_decode_pdclust(LINEAR_ENUM_ID, lid,
 					INLINE_NOT_APPLICABLE);
 	C2_UT_ASSERT(rc == 0);
+
+#if 0
+	/*
+	 * Build a layout object with COMPOSITE layout type. Encode it into a
+	 * layout buffer. Then decode that layout buffer again into another
+	 * layout object.
+	 * Now, compare the original layout object with the decoded layout
+	 * object.
+	 */
+	lid = 8005;
+	rc = test_encode_decode_composite(lid, &domain);
+	C2_UT_ASSERT(rc == 0);
+#endif
 }
 
 /*
diff --git a/layout/ut/layout.h b/layout/ut/layout.h
index 727e80b..353fb77 100644
--- a/layout/ut/layout.h
+++ b/layout/ut/layout.h
@@ -80,6 +80,8 @@ void l_verify(struct c2_layout *l,
 //void lbuf_compare(struct c2_bufvec_cursor *cur1,
 //			 struct c2_bufvec_cursor *cur2);
 
+void generic_buf_build(uint32_t lt_id, struct c2_bufvec_cursor *dcur);
+struct c2_layout *list_lookup(uint64_t lid);
 
 void NKP_assign(uint32_t enum_id,
 		uint32_t inline_test,
@@ -107,9 +109,27 @@ void pdclust_layout_verify(uint32_t enum_id,
 
 int test_build_composite(uint64_t lid,
 			 struct c2_layout_domain *domain,
+			 uint32_t sublayouts_nr,
+			 uint32_t min_extents_nr,
+			 c2_bindex_t min_start_offset,
+			 c2_bindex_t approximate_end_address,
+			 bool if_contiguous_extents,
 			 bool failure_test);
+int test_decode_composite(uint64_t lid,
+			  struct c2_layout_domain *domain,
+			  uint32_t sublayouts_nr,
+			  uint32_t min_extents_nr,
+			  c2_bindex_t min_start_offset,
+			  c2_bindex_t approximate_end_offset,
+			  bool if_contiguous_extents,
+			  bool failure_test);
 int test_encode_composite(uint64_t lid,
 			  struct c2_layout_domain *domain,
+			  uint32_t sublayouts_nr,
+			  uint32_t min_extents_nr,
+			  c2_bindex_t min_start_offset,
+			  c2_bindex_t approximate_end_offset,
+			  bool if_contiguous_extents,
 			  bool failure_test);
 
 /* __COLIBRI_LAYOUT_LAYOUT_H__ */
-- 
1.8.3.2

