From 0121f270cb7a370927149ea4cd7da7e5a52a8c6a Mon Sep 17 00:00:00 2001
From: "trupti.patil" <trupti_patil@xyratex.com>
Date: Fri, 19 Apr 2013 15:25:42 +0530
Subject: [PATCH 117/172] layer ops do not update the DB anymore

---
 layout/composite.c    | 127 +++++++++-----------------------------------
 layout/composite.h    |  42 +++++++--------
 layout/ut/composite.c | 144 ++++++++------------------------------------------
 layout/ut/layout.c    |  99 ----------------------------------
 4 files changed, 67 insertions(+), 345 deletions(-)

diff --git a/layout/composite.c b/layout/composite.c
index 60e38de..d9d3baa 100644
--- a/layout/composite.c
+++ b/layout/composite.c
@@ -314,8 +314,6 @@ static void composite_delete(struct m0_layout *l)
 /** Adds a layer to the in-memory layout. */
 static int layer_inmem_add(struct m0_composite_layout *cl,
 			   struct m0_layout *sublayout,
-			   const struct m0_tl *extlist,
-			   uint32_t ext_nr,
 			   struct m0_composite_layer **lr)
 {
 	struct m0_composite_layer        *layer;
@@ -325,12 +323,10 @@ static int layer_inmem_add(struct m0_composite_layout *cl,
 	M0_PRE(ergo(cl->cl_layers_nr == 0, composite_allocated_invariant(cl)));
 	/* Layer beyond zeroth is getting added. */
 	M0_PRE(ergo(cl->cl_layers_nr > 0, composite_invariant(cl)));
-	M0_PRE(extlist != NULL && ext_nr > 0);
 
-	M0_ENTRY("lid %llu, sublayout_id %llu, extlist %p, ext_nr %lu",
+	M0_ENTRY("lid %llu, sublayout_id %llu",
 		 (unsigned long long)cl->cl_base.l_id,
-		 (unsigned long long)sublayout->l_id,
-		 extlist, (unsigned long)ext_nr);
+		 (unsigned long long)sublayout->l_id);
 
 	M0_ALLOC_PTR(layer);
 	if (layer == NULL) {
@@ -345,12 +341,14 @@ static int layer_inmem_add(struct m0_composite_layout *cl,
 	layer->clr_cl         = &cl->cl_base;
 	layer->clr_sl         = sublayout;
 	layer->clr_idx        = cl->cl_layers_nr;
-	//layer->clr_extents_nr = ext_nr; //todo rm
 	layer->clr_extents_nr = 1;
 	m0_composite_layer_ext_tlist_init(&layer->clr_extents);
-#if 0
-	m0_composite_layer_ext_tlist_splice(&layer->clr_extents, extlist);
-#endif
+	m0_layout_get(layer->clr_sl); /* Add a reference to the sublayout. */
+
+	/*
+	 * Add one single extent with invalid state and mapping the whole
+	 * offset space.
+	 */
 	M0_ALLOC_PTR(lr_ext);
 	M0_ASSERT(lr_ext != NULL); //todo
 	lr_ext->cle_ext.e_start = 0;
@@ -358,12 +356,10 @@ static int layer_inmem_add(struct m0_composite_layout *cl,
 	lr_ext->cle_state       = M0_CLRES_INVALID;
 	m0_composite_layer_ext_tlink_init_at_tail(lr_ext, &layer->clr_extents);
 
-	m0_layout_get(layer->clr_sl); /* Add a reference to the sublayout. */
+	comp_layer_tlink_init_at_tail(layer, &cl->cl_layers);
 	M0_CNT_INC(cl->cl_layers_nr);
 
-	comp_layer_tlink_init_at_tail(layer, &cl->cl_layers);
-	if (lr != NULL)
-		*lr = layer;
+	*lr = layer;
 	M0_POST(layer_invariant(layer));
 	M0_POST(composite_invariant(cl));
 	M0_LEAVE("lid %llu, layer %lu", (unsigned long long)cl->cl_base.l_id,
@@ -418,7 +414,7 @@ static int composite_populate(struct m0_composite_layout *cl,
 	M0_PRE(m0_layout__invariant(sublayout));
 	M0_ENTRY("lid %llu", (unsigned long long)cl->cl_base.l_id);
 
-	rc = layer_inmem_add(cl, sublayout, extlist, ext_nr, &layer);
+	rc = layer_inmem_add(cl, sublayout, &layer);
 	if (rc == 0) {
 		M0_ASSERT(layer->clr_idx == 0);
 		m0_layout__populate(&cl->cl_base, user_count);
@@ -442,7 +438,7 @@ static void composite_populate_reverse(struct m0_composite_layout *cl)
 M0_INTERNAL int m0_composite_build(struct m0_layout_domain *dom,
 				   uint64_t lid,
 				   struct m0_layout *sublayout,
-				   struct m0_tl *extlist,
+				   struct m0_tl *extlist, //todo take out
 				   uint32_t ext_nr,
 				   struct m0_composite_layout **out)
 {
@@ -556,63 +552,23 @@ static int ext_indb_write(struct m0_composite_layout *cl,
 			  uint64_t new_ext_state,
 			  struct m0_db_tx *tx,
 			  uint32_t ext_validation_kind);
-/**
- * Adds a layer to the in-memory layout and if the layout DB is available,
- * adds it to the in-DB layout as well.
- */
-static int layer_add_internal(struct m0_composite_layout *cl,
-			      struct m0_layout *sublayout,
-			      struct m0_tl *extlist,
-			      uint32_t ext_nr,
-			      struct m0_db_tx *tx)
-{
-	struct m0_composite_layer *layer;
-	int                        rc;
-
-	M0_PRE(m0_mutex_is_locked(&cl->cl_base.l_lock));
-	rc = layer_inmem_add(cl, sublayout, extlist, ext_nr, &layer);
-	if (rc != 0)
-		return rc;
-	M0_ASSERT(layer->clr_idx > 0);
-
-#if 0 //todo Check if it is required to support this
-	if (cl->cl_base.l_dom->ld_is_db_available) {
-		rc = layer_indb_add(cl, layer, tx);
-		if (rc != 0) {
-			layer_inmem_delete(cl, layer, !EXTLIST_FREE);
-			/* Restore the extlist. */
-			m0_composite_layer_ext_tlist_init(extlist);
-			m0_composite_layer_ext_tlist_splice(extlist,
-							&layer->clr_extents);
-		}
-	}
-#endif
-	M0_POST(ergo(rc == 0, layer_invariant(layer)));
-	return rc;
-}
 
 M0_INTERNAL int m0_composite_layer_add(struct m0_composite_layout *cl,
-				       struct m0_layout *sublayout,
-				       struct m0_tl *extlist,
-				       uint32_t ext_nr,
-				       struct m0_db_tx *tx)
+				       struct m0_layout *sublayout)
 {
-	int rc;
+	struct m0_composite_layer *layer;
+	int                        rc;
 
 	M0_PRE(composite_invariant(cl));
+	M0_PRE(cl->cl_layers_nr >= 1);
 	M0_PRE(m0_layout__invariant(sublayout));
-	M0_PRE(extlist != NULL);
-	M0_PRE(!m0_composite_layer_ext_tlist_is_empty(extlist));
-	M0_PRE(ext_nr > 0);
-	M0_PRE(ergo(cl->cl_base.l_dom->ld_is_db_available, tx != NULL));
 
-	M0_ENTRY("lid %llu, sublayout_id %llu, extlist %p, ext_nr %ld, tx %p",
+	M0_ENTRY("lid %llu, sublayout_id %llu",
 		 (unsigned long long)cl->cl_base.l_id,
-		 (unsigned long long)sublayout->l_id,
-		 extlist, (unsigned long)ext_nr, tx);
+		 (unsigned long long)sublayout->l_id);
 
 	m0_mutex_lock(&cl->cl_base.l_lock);
-	rc = layer_add_internal(cl, sublayout, extlist, ext_nr, tx);
+	rc = layer_inmem_add(cl, sublayout, &layer);
 	if (rc != 0) {
 		m0_layout__log("m0_composite_layer_add",
 			       "Failed to add layer",
@@ -622,8 +578,7 @@ M0_INTERNAL int m0_composite_layer_add(struct m0_composite_layout *cl,
 	}
 	m0_mutex_unlock(&cl->cl_base.l_lock);
 	M0_POST(composite_invariant(cl));
-	M0_POST(ergo(rc == 0, cl->cl_layers_nr > 1));
-	M0_POST(ergo(rc != 0, cl->cl_layers_nr == 1));
+	M0_POST(ergo(rc == 0, layer->clr_idx > 0 && cl->cl_layers_nr > 1));
 	M0_LEAVE("lid %llu, rc %d", (unsigned long long)cl->cl_base.l_id, rc);
 	return rc;
 }
@@ -654,47 +609,25 @@ static struct m0_composite_layer *layer_find(
 	return layer;
 }
 
-M0_INTERNAL int m0_composite_layer_delete(struct m0_composite_layout *cl,
-					  struct m0_db_tx *tx)
+//todo Change the return type to void
+M0_INTERNAL int m0_composite_layer_delete(struct m0_composite_layout *cl)
 {
 	struct m0_composite_layer *layer;
-#if 0 //todo Check if it is required to support this
-	struct m0_emap            *emap;
-	int                        rc;
-#endif
 
 	M0_PRE(composite_invariant(cl));
 	M0_PRE(cl->cl_layers_nr > 1);
-	M0_PRE(ergo(cl->cl_base.l_dom->ld_is_db_available, tx != NULL));
-	M0_ENTRY("lid %llu, layers_nr %lu, tx %p",
+	M0_ENTRY("lid %llu, layers_nr %lu",
 		 (unsigned long long)cl->cl_base.l_id,
-		 (unsigned long)cl->cl_layers_nr, tx);
+		 (unsigned long)cl->cl_layers_nr);
 
 	m0_mutex_lock(&cl->cl_base.l_lock);
 	layer = layer_find(cl, cl->cl_layers_nr - 1);
 	M0_PRE(m0_tl_forall(m0_composite_layer_ext, lr_ext, &layer->clr_extents,
 			    lr_ext->cle_state == M0_CLRES_INVALID));
 
-#if 0 //todo Check if it is required to support this
-	if (cl->cl_base.l_dom->ld_is_db_available) {
-		rc = layer_indb_delete(cl, emap, layer->clr_idx,
-				       layer->clr_sl->l_id, tx,
-				       !IN_UPDATE_PATH);
-		if (rc != 0) {
-			m0_layout__log("m0_composite_layer_delete",
-				       "Failed to delete the top-most layer "
-				       "from DB",
-				       M0_LAYOUT_ADDB_LOC_COMP_LAYER_DEL_3,
-				       &cl->cl_base.l_addb_ctx,
-				       cl->cl_base.l_id, rc);
-		}
-	}
-#endif
-
 	layer_inmem_delete(cl, layer, EXTLIST_FREE);
 	m0_mutex_unlock(&cl->cl_base.l_lock);
 	M0_POST(composite_invariant(cl));
-	//todo M0_RETURN(rc);
 	M0_RETURN(0);
 }
 
@@ -912,8 +845,7 @@ static int layers_inbuf_read(struct m0_composite_layout *cl,
 						user_count);
 			layer = comp_layer_tlist_head(&cl->cl_layers);
 		} else
-			rc = layer_inmem_add(cl, sublayout, &extlist,
-					     lr_header->clh_extents_nr, &layer);
+			rc = layer_inmem_add(cl, sublayout, &layer);
 		/*
 		 * Release the reference added by m0_layout_find(). In case of
 		 * success, m0_composite_layer_add() has added a reference on
@@ -923,12 +855,6 @@ static int layers_inbuf_read(struct m0_composite_layout *cl,
 
 		if (rc == 0) {
 			m0_tl_for(m0_composite_layer_ext, &extlist, lr_ext) {
-#if 0 //following does not work due to the locking requirement
-				rc = m0_composite_layer_ext_add(cl, i,
-							&lr_ext->cle_ext,
-							lr_ext->cle_state,
-							NULL);
-#endif
 				rc = ext_inmem_write(cl, layer,
 						     &lr_ext->cle_ext,
 						     lr_ext->cle_state,
@@ -2514,8 +2440,7 @@ static int comp_layout_indb_read(struct m0_composite_layout *cl,
 			layer = comp_layer_tlist_head(&cl->cl_layers);
 		} else
 			/* Now, write the layer to the in-memory layout. */
-			rc = layer_inmem_add(cl, sublayout, &extlist,
-					     extents_nr, &layer);
+			rc = layer_inmem_add(cl, sublayout, &layer);
 		/*
 		 * Release the reference added by m0_layout_find().
 		 * In case of success, composite_populate() or
diff --git a/layout/composite.h b/layout/composite.h
index 508c68e..03c7a1c 100644
--- a/layout/composite.h
+++ b/layout/composite.h
@@ -255,40 +255,38 @@ M0_INTERNAL int m0_composite_build(struct m0_layout_domain *dom,
 
 /**
  * Adds a layer to the composite layout.
- * If the layout DB is available, adds the layer information to the DB.
  *
- * @pre The composite layout has been added to the DB.
+ * @pre The composite layout has been added to the DB. todo
  *
- * @param extlist The extent mask to be associated with the layer being added.
- *        This extlist is to be generated by the user using the
- *        m0_composite_layer_ext_tlist and the related interfaces. This list is
- *        internally spliced together with the m0_composite_layer::clr_extents
- *        which is an empty list to start with. In case m0_composite_layer_add()
- *        returns success, user shall not free the nodes added to the extlist.
- *        They are implicitly freed when the layer is freed.
- * @param tx Pointer to the transaction to be used. It shall be non-NULL if
- *        the associated layout domain has access to the DB.
+ * @post A reference has been added to the sublayout.
+ *       When this layer gets added to the DB version of the layout (through
+ *       the DB update made through the m0_layout_add() or
+ *       the m0_layout_update() API), user count for the sublayout is
+ *       incremented by one.
+ *
+ * @note After this API has been used, the user needs to explicitly invoke
+ *       m0_layout_update() API so as to update the DB version of the layout.
  */
 M0_INTERNAL int m0_composite_layer_add(struct m0_composite_layout *cl,
-				       struct m0_layout *sublayout,
-				       struct m0_tl *extlist,
-				       uint32_t ext_nr,
-				       struct m0_db_tx *tx);
+				       struct m0_layout *sublayout);
 
 /**
- * Deletes the top-most layer from the composite layout provided the top-most
+ * Deletes the top-most layer from the composite layout, provided the top-most
  * layer is not the zeroth one.
- * If the layout DB is available, updates the layer information in the DB.
  *
  * @pre The top-most layer does not contain any valid extent.
  *
- * @param tx Pointer to the transaction to be used. It shall be non-NULL if
- *        the associated layout domain has access to the DB.
+ * @post A reference has been released from the sublayout associated with the
+ *       top-most layer.
+ *       When this layer gets deleted from the DB version of the layout (through
+ *       the DB update made through the m0_layout_add() or
+ *       the m0_layout_update() API), user count for the sublayout is
+ *       deccremented by one.
  *
- * In case the top-most layer is the zeroth one, the error -EINVAL is returned.
+ * @note After this API has been used, the user needs to explicitly invoke
+ *       m0_layout_update() API so as to update the DB version of the layout.
  */
-M0_INTERNAL int m0_composite_layer_delete(struct m0_composite_layout *cl,
-					  struct m0_db_tx *tx);
+M0_INTERNAL int m0_composite_layer_delete(struct m0_composite_layout *cl);
 
 /**
  * @todo Shall we add an API that will delete 'the second from the top layer'
diff --git a/layout/ut/composite.c b/layout/ut/composite.c
index 7b81fea..6787878 100644
--- a/layout/ut/composite.c
+++ b/layout/ut/composite.c
@@ -435,8 +435,7 @@ static int composite_layers_add(struct m0_composite_layout *cl,
 		extentlist_build(&extents, extents_nr, if_contiguous_extents);
 
 		M0_UT_ASSERT(cl->cl_layers_nr == i);
-		rc = m0_composite_layer_add(cl, sublayout, &extents,
-					    extents_nr, tx);
+		rc = m0_composite_layer_add(cl, sublayout);
 		if (layer_add_failure_test) {
 			M0_UT_ASSERT(rc == L_TABLE_INSERT_ERR ||
 				     rc == -ENOMEM || rc == -EINVAL ||
@@ -1341,161 +1340,61 @@ int test_layer_ops_composite(uint64_t lid,
 			     bool layer_del_failure_test)
 {
 	struct m0_layout           *l;
-	struct m0_layout           *l_copy_orig;
-	struct m0_layout           *l_copy_updated;
 	struct m0_composite_layout *cl;
-	struct m0_db_tx            *txptr;
-	struct m0_db_tx             tx;
-	struct m0_layout           *l_from_DB;
 	struct m0_composite_layer  *layer;
-	int                         rc_tmp;
 	int                         rc;
 
-	/*
-	 * Build a layout with the default layer 'layer 0', add it to the DB
-	 * if applicable.
-	 */
-	rc = composite_build_and_layers_add(lid, domain,
-					    1, min_extents_nr,
-					    !CONTIGUOUS_EXTENTS,
-					    domain->ld_is_db_available ?
-								true : false,
+	/* Build a layout with the default layer 'layer 0'. */
+	rc = composite_build_and_layers_add(lid, domain, 1, min_extents_nr,
+					    !CONTIGUOUS_EXTENTS, false,
 					    !FAILURE_TEST,
 					    !LAYER_ADD_FAILURE_TEST, &cl);
 	M0_UT_ASSERT(rc == 0);
 
 	/* Now, add layers to the layout. */
-	if (domain->ld_is_db_available) {
-		rc = m0_db_tx_init(&tx, domain->ld_dbenv, DBFLAGS);
-		M0_UT_ASSERT(rc == 0);
-		txptr = &tx;
-	} else
-		txptr = NULL;
-
-	rc = composite_layers_add(cl, txptr, layers_nr, min_extents_nr,
+	rc = composite_layers_add(cl, NULL, layers_nr, min_extents_nr,
 				  !CONTIGUOUS_EXTENTS, layer_add_failure_test);
 
-	/*
-	 * Now that some layers are added, update the layout in
-	 * the DB.
-	 */
-	if (domain->ld_is_db_available)
-		layout_update(&cl->cl_base);
-
 	if (layer_add_failure_test) {
 		M0_UT_ASSERT(rc == L_TABLE_INSERT_ERR || rc == -ENOMEM ||
 			     rc == -EINVAL || rc == L_EMAP_PASTE_ERR ||
 			     rc == L_EMAP_OBJ_INSERT_ERR);
-		//todo Check organisation of the following
-		if (domain->ld_is_db_available) {
-			rc_tmp = m0_db_tx_commit(&tx);
-			M0_UT_ASSERT(rc_tmp == 0);
-		}
-
-		/* Delete the composite layout object. */
-		m0_layout_put(&cl->cl_base);
-		M0_UT_ASSERT(m0_layout_find(domain, lid) == NULL);
-
-		/* Delete the precreated sublayouts. */
-		sublayouts_delete(domain, lid, layers_nr);
-		return rc;
+		goto exit;
+	} else {
+		M0_UT_ASSERT(rc == 0);
+		M0_ASSERT(cl->cl_layers_nr == layers_nr);
 	}
-	M0_UT_ASSERT(rc == 0);
-	M0_ASSERT(cl->cl_layers_nr == layers_nr);
-	l = m0_cl_to_layout(cl);
 
 	/* Verify the layout. */
+	l = m0_cl_to_layout(cl);
 	composite_layout_verify(l, lid, layers_nr, min_extents_nr,
 				!CONTIGUOUS_EXTENTS);
-	composite_layout_copy(l, &l_copy_orig);
-
-	if (domain->ld_is_db_available) {
-		/* Delete the composite layout object from the memory. */
-		m0_layout_put(&cl->cl_base);
-		M0_UT_ASSERT(m0_layout_find(domain, lid) == NULL);
-
-		/* Read the layout from the DB and compare. */
-		l_from_DB = NULL;
-		rc = layout_lookup(lid, domain, &m0_composite_layout_type,
-				   !FAILURE_TEST, &l_from_DB);
-		M0_UT_ASSERT(rc == 0);
-		composite_layout_compare(l_from_DB, l_copy_orig, false);
-
-		/*
-		 * Restore 'l' and 'cl' since the earlier layout from the memory
-		 * has been deleted.
-		 */
-		l = l_from_DB;
-		cl = m0_layout_to_cl(l_from_DB);
-
-		/*
-		 * There is only one reference on this layout that is added by
-		 * incremented by m0_layout_lookup(). Hence, it is not to be
-		 * released.
-		 */
-	}
 
-	/* Delete all the extents associated with the layer. */
+	/* Delete all the extents associated with the top-most layer. */
 	layer = layer_find(cl, cl->cl_layers_nr - 1);
-	layer_extents_delete(cl, layer, txptr);
+	layer_extents_delete(cl, layer, NULL);
 
 	/* Now, delete the layer. */
-	rc = m0_composite_layer_delete(cl, txptr);
-	//todo Check organisation of the following
-	if (domain->ld_is_db_available) {
-		rc_tmp = m0_db_tx_commit(&tx);
-		M0_UT_ASSERT(rc_tmp == 0);
-		/*
-		 * Now that some layers are deleted, update the layout in
-		 * the DB.
-		 */
-		if (domain->ld_is_db_available)
-			layout_update(&cl->cl_base);
-	}
-
+	rc = m0_composite_layer_delete(cl);
 	if (layer_del_failure_test) {
 		M0_UT_ASSERT(rc == L_TABLE_DEL_ERR || rc == L_EMAP_LOOKUP_ERR ||
 			     rc == L_EMAP_OBJ_DEL_ERR);
-		/* Delete the composite layout object. */
-		m0_layout_put(&cl->cl_base);
-		M0_UT_ASSERT(m0_layout_find(domain, lid) == NULL);
-
-		/* Delete the precreated sublayouts. */
-		sublayouts_delete(domain, lid, layers_nr);
-
-		composite_layout_copy_delete(l_copy_orig);
-		return rc;
+		goto exit;
+	} else {
+		M0_UT_ASSERT(rc == 0);
+		M0_ASSERT(cl->cl_layers_nr = layers_nr - 1);
 	}
-	M0_UT_ASSERT(rc == 0);
 
-	M0_ASSERT(cl->cl_layers_nr = layers_nr - 1);
+	/* Verify the layout. */
 	composite_layout_verify(l, lid, layers_nr - 1, min_extents_nr,
 				!CONTIGUOUS_EXTENTS);
-	composite_layout_copy(l, &l_copy_updated);
-
+exit:
 	/* Delete the composite layout object. */
 	m0_layout_put(&cl->cl_base);
 	M0_UT_ASSERT(m0_layout_find(domain, lid) == NULL);
 
-	if (domain->ld_is_db_available) {
-		/* Read the layout from the DB and compare. */
-		l_from_DB = NULL;
-		rc = layout_lookup(lid, domain, &m0_composite_layout_type,
-				   !FAILURE_TEST, &l_from_DB);
-		M0_UT_ASSERT(rc == 0);
-		composite_layout_compare(l_from_DB, l_copy_updated, false);
-
-		/* Release the reference incremented by m0_layout_lookup(). */
-		m0_layout_put(l_from_DB);
-	} else
-		rc = 0;
-
-	composite_layout_copy_delete(l_copy_orig);
-	composite_layout_copy_delete(l_copy_updated);
-
 	/* Delete all the precreated sublayouts. */
 	sublayouts_delete(domain, lid, layers_nr);
-
 	return rc;
 }
 
@@ -2670,8 +2569,7 @@ int test_update_composite(uint64_t lid,
 		sublayout_build(sublayout_id, domain, &sublayout);
 		extentlist_build(&extents, min_extents_nr,
 				 if_contiguous_extents);
-		rc = m0_composite_layer_add(cl, sublayout, &extents,
-					    min_extents_nr, NULL);
+		rc = m0_composite_layer_add(cl, sublayout);
 		extentlist_free(&extents);
 		M0_ASSERT(rc == 0);
 	}
@@ -2682,7 +2580,7 @@ int test_update_composite(uint64_t lid,
 	M0_ASSERT(cl->cl_layers_nr == layers_nr + 4);
 	for (i = 0; i < 2; ++i) {
 		//todo Need to delete all the extents
-		rc = m0_composite_layer_delete(cl, NULL);
+		rc = m0_composite_layer_delete(cl);
 		M0_ASSERT(rc == 0);
 	}
 	M0_ASSERT(cl->cl_layers_nr == layers_nr + 2);
diff --git a/layout/ut/layout.c b/layout/ut/layout.c
index 08c85be..a16e469 100644
--- a/layout/ut/layout.c
+++ b/layout/ut/layout.c
@@ -2174,102 +2174,6 @@ void domain_ldb_available_set(struct m0_layout_domain *domain, bool val)
 	domain->ld_is_db_available = val;
 }
 
-static void test_layer_ops_indb(void)
-{
-	uint64_t lid;
-	int      rc;
-
-	domain_ldb_available_set(&domain, true);
-
-	lid = 26001;
-	rc = test_layer_ops_composite(lid, &domain, 5, 10,
-				      !LAYER_ADD_FAILURE_TEST,
-				      !LAYER_DEL_FAILURE_TEST);
-	M0_ASSERT(rc == 0);
-
-	domain_ldb_available_set(&domain, false);
-}
-
-static void test_layer_ops_indb_failure(void)
-{
-#if 0
-	uint64_t lid;
-	int      rc;
-#endif
-
-	domain_ldb_available_set(&domain, true);
-
-#if 0 //todo rm if we do not add layer to the DB during layer add op
-	/* Simulate emap obj insert error while adding a layer. */
-	lid = 27002;
-	m0_fi_enable_off_n_on_m("extmap_indb_add", "emap_obj_insert_err",
-				2 /* todo 1 */, 1);
-	rc = test_layer_ops_composite(lid, &domain, 5, 10,
-				      LAYER_ADD_FAILURE_TEST,
-				      !LAYER_DEL_FAILURE_TEST);
-	M0_UT_ASSERT(rc == L_EMAP_OBJ_INSERT_ERR);
-	m0_fi_disable("extmap_indb_add", "emap_obj_insert_err");
-
-	/* Simulate emap paste error while adding a non-zeroth layer. */
-	lid = 27003;
-	m0_fi_enable_off_n_on_m("ext_indb_write_internal", "emap_paste_err",
-				5 /* extents_nr */, 1);
-	rc = test_layer_ops_composite(lid, &domain, 3, 4,
-				      LAYER_ADD_FAILURE_TEST,
-				      !LAYER_DEL_FAILURE_TEST);
-	M0_UT_ASSERT(rc == L_EMAP_PASTE_ERR);
-	m0_fi_disable("ext_indb_write_internal", "emap_paste_err");
-
-	/* todo Following errors are happening for the zeroth layers. Make
-	 * sure they are covered for the non-zeroth and the somewhat last
-	 * layer. */
-	/* Simulate emap obj delete error while deleting a layer. */
-	lid = 27021;
-	m0_fi_enable_once("layer_indb_delete", "emap_obj_del_err");
-	rc = test_layer_ops_composite(lid, &domain, 5, 5,
-				      !LAYER_ADD_FAILURE_TEST,
-				      LAYER_DEL_FAILURE_TEST);
-	M0_UT_ASSERT(rc == L_EMAP_OBJ_DEL_ERR);
-#endif
-
-#if 0 //todo rm we do not add layer to the DB during layer add op
-	/*
-	 * Simulate emap iterator setting error during layer_delete_verify()
-	 * that is in the path of deleting layer - for a zeroth layer.
-	 */
-	lid = 25021;
-
-	m0_fi_enable_off_n_on_m("emap_iterator_set", "emap_lookup_err",
-				12 /* todo layers_nr * extents_nr + 1 */, 1);
-	rc = test_layer_ops_composite(lid, &domain, 4, 4,
-				      !LAYER_ADD_FAILURE_TEST,
-				      LAYER_DEL_FAILURE_TEST);
-	m0_fi_enable_off_n_on_m("emap_iterator_set", "emap_lookup_err",
-				14 /* 14 works */ /* 15 is high */
-				/* todo layers_nr (extmap_indb_add()) +
-				 * layers_nr (extentmap_indb_read() thr' lookup)
-				 * + 1 (layer_delete_verify) */,
-				1);
-	rc = test_layer_ops_composite(lid, &domain, 4, 6,
-				      !LAYER_ADD_FAILURE_TEST,
-				      LAYER_DEL_FAILURE_TEST);
-
-	m0_fi_enable_off_n_on_m("emap_iterator_set", "emap_lookup_err",
-				15 /* todo layers_nr (extmap_indb_add()) +,
-			* layers_nr (extentmap_indb_read() thr' lookup +
-			* + 1 (layer_delete_verify() failure case)
-			* + extents_nr (ext_indb_write() thr ext deletion +
-			* 1 (layer_delete_verify()) */,
-				1);
-	rc = test_layer_ops_composite(lid, &domain, 4, 7,
-				      !LAYER_ADD_FAILURE_TEST,
-				      LAYER_DEL_FAILURE_TEST);
-	M0_UT_ASSERT(rc == L_EMAP_LOOKUP_ERR);
-	m0_fi_disable("emap_iterator_set", "emap_lookup_err");
-#endif
-	domain_ldb_available_set(&domain, false);
-}
-
 static void test_layer_ext_ops_indb(void)
 {
 	uint64_t lid;
@@ -2338,9 +2242,6 @@ const struct m0_test_suite layout_ut = {
 		{ "layout-update-failure", test_update_failure },
 		{ "layout-delete", test_delete },
 		{ "layout-delete-failure", test_delete_failure },
-		{ "layout-layer-ops-indb", test_layer_ops_indb },
-		{ "layout-layer-ops-indb-failure",
-			test_layer_ops_indb_failure },
 		{ "layout-layer-ext-ops-indb", test_layer_ext_ops_indb },
 		{ "layout-layer-ext-ops-indb-failure",
 			test_layer_ext_ops_indb_failure },
-- 
1.8.3.2

