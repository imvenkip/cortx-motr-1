From 4db9b7254c68d274c987110abfdfc79e511539c9 Mon Sep 17 00:00:00 2001
From: "trupti.patil" <trupti_patil@xyratex.com>
Date: Thu, 4 Apr 2013 11:13:07 +0530
Subject: [PATCH 109/172] Avoiding LAMBDA usage in composite.c by adding one
 void ptr to m0_emap_paste()

---
 db/extmap.c           |  13 ++-
 db/extmap.h           |   7 +-
 layout/composite.c    | 310 +++++++++++++++++++++++---------------------------
 layout/ut/composite.c |  59 +++++-----
 layout/ut/composite.h |  16 ++-
 stob/ad.c             |   8 +-
 6 files changed, 202 insertions(+), 211 deletions(-)

diff --git a/db/extmap.c b/db/extmap.c
index df86b96..c36557f 100644
--- a/db/extmap.c
+++ b/db/extmap.c
@@ -359,11 +359,12 @@ M0_INTERNAL int m0_emap_split(struct m0_emap_cursor *it,
 }
 
 int m0_emap_paste(struct m0_emap_cursor *it, struct m0_ext *ext, uint64_t val,
-		  void (*del)(struct m0_emap_seg *),
+		  void *data,
+		  void (*del)(struct m0_emap_seg *, void *),
 		  void (*cut_left)(struct m0_emap_seg *, struct m0_ext *,
-				   uint64_t),
+				   uint64_t, void *),
 		  void (*cut_right)(struct m0_emap_seg *, struct m0_ext *,
-				    uint64_t))
+				    uint64_t, void *))
 {
 	int                    result   = 0;
 	uint64_t               val_orig;
@@ -415,15 +416,15 @@ int m0_emap_paste(struct m0_emap_cursor *it, struct m0_ext *ext, uint64_t val,
 		bstart[1] = val;
 		val_orig  = seg->ee_val;
 		if (length[0] > 0) {
-			cut_left(seg, &clip, val_orig);
+			cut_left(seg, &clip, val_orig, data);
 			bstart[0] = seg->ee_val;
 		}
 		if (length[2] > 0) {
-			cut_right(seg, &clip, val_orig);
+			cut_right(seg, &clip, val_orig, data);
 			bstart[2] = seg->ee_val;
 		}
 		if (length[0] == 0 && length[2] == 0)
-			del(seg);
+			del(seg, data);
 
 		result = emap_split_internal(it, &vec, length[0] > 0 ?
 					     chunk->e_start : ext0.e_start);
diff --git a/db/extmap.h b/db/extmap.h
index acb5129..e9ce4e1 100644
--- a/db/extmap.h
+++ b/db/extmap.h
@@ -253,11 +253,12 @@ M0_INTERNAL int m0_emap_split(struct m0_emap_cursor *iterator,
    a part of official function contract.
  */
 int m0_emap_paste(struct m0_emap_cursor *it, struct m0_ext *ext, uint64_t val,
-		  void (*del)(struct m0_emap_seg *),
+		  void *data,
+		  void (*del)(struct m0_emap_seg *, void *),
 		  void (*cut_left)(struct m0_emap_seg *, struct m0_ext *,
-				   uint64_t),
+				   uint64_t, void *data),
 		  void (*cut_right)(struct m0_emap_seg *, struct m0_ext *,
-				    uint64_t));
+				    uint64_t, void *));
 
 /**
    Merge a part of the segment the cursor is currently positioned at with the
diff --git a/layout/composite.c b/layout/composite.c
index 77d7ee7..722990e 100644
--- a/layout/composite.c
+++ b/layout/composite.c
@@ -2000,20 +2000,14 @@ static int ext_indb_write_internal(struct m0_emap_cursor *it,
 				   struct m0_composite_layer *layer,
 				   const struct m0_ext *ext,
 				   uint64_t new_ext_state,
-				   bool in_mem_list_update);
-#ifndef __KERNEL__
-static int ext_inmem_adjust(struct m0_composite_layer *layer,
-			    enum extent_op extent_op,
-			    const struct m0_emap_seg *seg,
-			    const struct m0_ext *ext);
-#endif
+				   bool inmem_list_update);
 
 /**
  * Pastes an extent with the specified state into the on-disk extent map
  * associated with the specified layer'. With the help of m0_emap_paste(),
  * it deletes or truncates the overlappping extents as necessary.
  *
- * @param in_mem_list_update This flag indicates if the in-memory list of
+ * @param inmem_list_update This flag indicates if the in-memory list of
  * the extents is to be updated in the context of the callbacks received from
  * m0_emap_paste().
  * - In case of initial addition of the extents into the on-disk extent map
@@ -2067,143 +2061,6 @@ static int ext_indb_write(struct m0_composite_layout *cl,
 	M0_RETURN(rc);
 }
 
-static int ext_indb_write_internal(struct m0_emap_cursor *it,
-				   struct m0_composite_layer *layer,
-				   const struct m0_ext *ext,
-				   uint64_t new_ext_state,
-				   bool in_mem_list_update)
-{
-	/* LAMBDA is not defined for the kernel space. */
-#ifndef __KERNEL__
-	struct m0_ext         ext0 = *ext; /* A read-write copy. */
-	int                   rc_cb;
-	int                   rc;
-
-	M0_ENTRY("lid %llu, layer %lu, e_start %llu, e_end %llu, "
-		 "new_e_state %llu, in_mem_list_update %d",
-		 (unsigned long long)layer->clr_cl->l_id,
-		 (unsigned long)layer->clr_idx,
-		 (unsigned long long)ext->e_start,
-		 (unsigned long long)ext->e_end,
-		 (unsigned long long)new_ext_state,
-		 in_mem_list_update ? 1 : 0);
-	/*
-	 * Insert a new segment into the layer's extent map, overwriting
-	 * parts of the map, as applicable.
-	 *
-	 * Some existing segments are deleted completely, others are cut.
-	 * m0_emap_paste() invokes supplied call-backs to notify the caller
-	 * about the changes in the map. These call-backs are used to adjust
-	 * the extents in the in-memory list of the extents for the specific
-	 * layer.
-	 *
-	 * Each call-back takes a segment argument, viz. seg. seg->ee_ext is
-	 * an extent associated with the specified layer as is stored in the
-	 * on-disk extent map and seg->ee_val is the state of that extent.
-	 *
-	 * Here is an example to illustrate the sequence of the operations
-	 * performed by m0_emap_paste() and how the in-memory list of the
-	 * extents is adjusted accordingly.
-	 *
-	 * For example, a layer contains an extent list (in-memory and in-DB)
-	 * as:
-	 * ext[0]: [        0,        2200700)
-	 * ext[1]: [  2200700,       56668025)
-	 * ext[2]: [ 56668025,      111135350)
-	 * ext[3]: [111135350,      165602675)
-	 * ext[4]: [165602675,      220070000)
-	 * ext[5]: [220070000,  M0_BINDEX_MAX)
-	 *
-	 * An extent [56668023, 165602677) is asked to be added into the list.
-	 *
-	 * In such a case, multiple small operations are performed internally
-	 * by m0_emap_paste() and the callbacks are sent appropriately. In
-	 * response to those callback, the in-memory list of the extents is
-	 * adjusted accordingly by using the ext_inmem_adjust() function.
-	 *
-	 * The sequence goes as follows:
-	 * 1) From the extent [2200700, 56668025), its left part that is
-	 *    [2200700, 56668023) is retained, using the extent_op CUT_LEFT.
-	 * 2) From the extent list, the extent [56668025, 111135350) is
-	 *    deleted using the extent_op DELETE.
-	 * 3) From the extent list, the extent [111135350, 165602675) is
-	 *    deleted using the extent_op DELETE.
-	 * 4) From the extent [165602675, 220070000), its right part that is
-	 *    [165602677, 220070000) is retained, using the extent_op
-	 *    CUT_RIGHT.
-	 * 5) Finally, the complete extent [56668023, 165602677) is added.
-	 *
-	 * layer_invariant() is temporarily violated during these operations.
-	 */
-
-	rc_cb = 0;
-	if (M0_FI_ENABLED("emap_paste_err"))
-		{ rc = L_EMAP_PASTE_ERR; goto err1_injected; }
-	rc = m0_emap_paste(it, &ext0, new_ext_state,
-		LAMBDA(void, (struct m0_emap_seg *seg) {
-			/* Extent deletion. */
-			if (in_mem_list_update)
-				rc_cb = rc_cb ?: ext_inmem_adjust(layer, DELETE,
-								  seg, NULL);
-		}),
-		LAMBDA(void, (struct m0_emap_seg *seg,
-			      struct m0_ext *extent, uint64_t val) {
-			/* Cut left - Retain left part. */
-			if (in_mem_list_update)
-				rc_cb = rc_cb ?: ext_inmem_adjust(layer,
-								  CUT_LEFT,
-								  seg, extent);
-		}),
-		LAMBDA(void, (struct m0_emap_seg *seg,
-			      struct m0_ext *extent, uint64_t val) {
-			/* Cut right - Retain right part. */
-			if (in_mem_list_update)
-				rc_cb = rc_cb ?: ext_inmem_adjust(layer,
-								  CUT_RIGHT,
-								  seg, extent);
-		}));
-err1_injected:
-	if (rc != 0)
-		m0_layout__log("ext_indb_write",
-			       "failed to paste an extent into emap",
-			       M0_LAYOUT_ADDB_LOC_COMP_EXT_PASTE,
-			       &layer->clr_cl->l_addb_ctx, layer->clr_cl->l_id,
-			       rc);
-
-	if (rc_cb != 0)
-		M0_LOG(M0_ERROR, "lid %llu, Extent could not be adjustted "
-		       "in memory", (unsigned long long)layer->clr_cl->l_id);
-
-	rc = rc ?: rc_cb;
-
-	if (rc == 0 && in_mem_list_update) {
-		/*
-		 * Now that the deletion/trimming of the overlapping extents
-		 * from the in-memory list of the extents has been
-		 * handled above, let's add the ultimate whole extent.
-		 */
-		rc = ext_inmem_find(layer, ext, new_ext_state, NULL);
-		M0_ASSERT(rc == -ENOENT);
-		rc = ext_inmem_add(layer, ext, new_ext_state);
-		if (rc != 0)
-			M0_LOG(M0_ERROR, "lid %llu, Ultimate extent could not "
-			       "be added to memory, layer %lu, e_start %llu, "
-			       "e_end %llu",
-			       (unsigned long long)layer->clr_cl->l_id,
-			       (unsigned long)layer->clr_idx,
-			       (unsigned long long)ext->e_start,
-			       (unsigned long long)ext->e_end);
-	}
-	M0_POST(ergo(rc == 0, layer_invariant(layer)));
-	M0_RETURN(rc);
-#else
-	/* This function is not expected to be invoked in the kernel mode. */
-	M0_ASSERT(0);
-	return -EPROTO;
-#endif /* __KERNEL__ */
-}
-
-#ifndef __KERNEL__
 static void ext_inmem_delete(struct m0_composite_layer *layer,
 			     const struct m0_ext *ext,
 			     uint64_t old_ext_state)
@@ -2307,38 +2164,153 @@ static int ext_inmem_trim(struct m0_composite_layer *layer,
 	M0_RETURN(rc);
 }
 
-static int ext_inmem_adjust(struct m0_composite_layer *layer,
-			    enum extent_op extent_op,
-			    const struct m0_emap_seg *seg,
-			    const struct m0_ext *ext)
+/** Struct to store the data that may be required by the callback execution. */
+struct callback_data {
+	struct m0_composite_layer *cb_layer;
+	bool                       cb_inmem_list_update;
+	int                        cb_rc; /* Callback execution status */
+};
+
+static void delete_callback(struct m0_emap_seg *seg, void *data)
 {
-	int rc;
+	struct callback_data *cb_data = data;
 
-	M0_PRE(M0_IN(extent_op, (DELETE, CUT_LEFT, CUT_RIGHT)));
-	M0_ENTRY("lid %llu, layer %lu, extent_op %d, "
-		 "seg_e_start %llu, seg_e_end %llu, seg_val %llu, "
-		 "e_start %llu, e_end %llu",
+	if (cb_data->cb_inmem_list_update)
+		ext_inmem_delete(cb_data->cb_layer, &seg->ee_ext, seg->ee_val);
+}
+
+static void cut_left_callback(struct m0_emap_seg *seg, struct m0_ext *ext,
+			      uint64_t existing_ext_state, void *data)
+{
+	struct callback_data *cb_data = data;
+
+	if (cb_data->cb_inmem_list_update)
+		cb_data->cb_rc ?: ext_inmem_trim(cb_data->cb_layer, CUT_LEFT,
+						 &seg->ee_ext, seg->ee_val,
+						 ext);
+}
+
+static void cut_right_callback(struct m0_emap_seg *seg, struct m0_ext *ext,
+			       uint64_t existing_ext_state, void *data)
+{
+	struct callback_data *cb_data = data;
+
+	if (cb_data->cb_inmem_list_update)
+		cb_data->cb_rc ?: ext_inmem_trim(cb_data->cb_layer, CUT_RIGHT,
+						 &seg->ee_ext, seg->ee_val,
+						 ext);
+}
+
+static int ext_indb_write_internal(struct m0_emap_cursor *it,
+				   struct m0_composite_layer *layer,
+				   const struct m0_ext *ext,
+				   uint64_t new_ext_state,
+				   bool inmem_list_update)
+{
+	struct m0_ext        ext0 = *ext; /* A read-write copy. */
+	int                  rc;
+	struct callback_data cb_data = {
+		.cb_layer             = layer,
+		.cb_inmem_list_update = inmem_list_update,
+		.cb_rc                = 0
+	};
+
+	M0_ENTRY("lid %llu, layer %lu, e_start %llu, e_end %llu, "
+		 "new_e_state %llu, inmem_list_update %d",
 		 (unsigned long long)layer->clr_cl->l_id,
-		 (unsigned long)layer->clr_idx, extent_op,
-		 (unsigned long long)seg->ee_ext.e_start,
-		 (unsigned long long)seg->ee_ext.e_end,
-		 (unsigned long long)seg->ee_val,
-		 (ext != NULL) ? (unsigned long long)ext->e_start : 0,
-		 (ext != NULL) ? (unsigned long long)ext->e_end : 0);
+		 (unsigned long)layer->clr_idx,
+		 (unsigned long long)ext->e_start,
+		 (unsigned long long)ext->e_end,
+		 (unsigned long long)new_ext_state, inmem_list_update ? 1 : 0);
+	/*
+	 * Insert a new segment into the layer's extent map, overwriting
+	 * parts of the map, as applicable.
+	 *
+	 * Some existing segments are deleted completely, others are cut.
+	 * m0_emap_paste() invokes supplied call-backs to notify the caller
+	 * about the changes in the map. These call-backs are used to adjust
+	 * the extents in the in-memory list of the extents for the specific
+	 * layer.
+	 *
+	 * Each call-back takes a segment argument, viz. seg. seg->ee_ext is
+	 * an extent associated with the specified layer as is stored in the
+	 * on-disk extent map and seg->ee_val is the state of that extent.
+	 *
+	 * Here is an example to illustrate the sequence of the operations
+	 * performed by m0_emap_paste() and how the in-memory list of the
+	 * extents is adjusted accordingly.
+	 *
+	 * For example, a layer contains an extent list (in-memory and in-DB)
+	 * as:
+	 * ext[0]: [        0,        2200700)
+	 * ext[1]: [  2200700,       56668025)
+	 * ext[2]: [ 56668025,      111135350)
+	 * ext[3]: [111135350,      165602675)
+	 * ext[4]: [165602675,      220070000)
+	 * ext[5]: [220070000,  M0_BINDEX_MAX)
+	 *
+	 * An extent [56668023, 165602677) is asked to be added into the list.
+	 *
+	 * In such a case, multiple small operations are performed internally
+	 * by m0_emap_paste() and the callbacks are sent appropriately. In
+	 * response to those callback, the in-memory list of the extents is
+	 * adjusted accordingly by using the ext_inmem_adjust() function.
+	 *
+	 * The sequence goes as follows:
+	 * 1) From the extent [2200700, 56668025), its left part that is
+	 *    [2200700, 56668023) is retained, using the extent_op CUT_LEFT.
+	 * 2) From the extent list, the extent [56668025, 111135350) is
+	 *    deleted using the extent_op DELETE.
+	 * 3) From the extent list, the extent [111135350, 165602675) is
+	 *    deleted using the extent_op DELETE.
+	 * 4) From the extent [165602675, 220070000), its right part that is
+	 *    [165602677, 220070000) is retained, using the extent_op
+	 *    CUT_RIGHT.
+	 * 5) Finally, the complete extent [56668023, 165602677) is added.
+	 *
+	 * layer_invariant() is temporarily violated during these operations.
+	 */
+
+	if (M0_FI_ENABLED("emap_paste_err"))
+		{ rc = L_EMAP_PASTE_ERR; goto err1_injected; }
+	rc = m0_emap_paste(it, &ext0, new_ext_state, &cb_data, delete_callback,
+			   cut_left_callback, cut_right_callback);
+err1_injected:
+	if (rc != 0)
+		m0_layout__log("ext_indb_write",
+			       "failed to paste an extent into emap",
+			       M0_LAYOUT_ADDB_LOC_COMP_EXT_PASTE,
+			       &layer->clr_cl->l_addb_ctx, layer->clr_cl->l_id,
+			       rc);
+
+	if (cb_data.cb_rc != 0)
+		M0_LOG(M0_ERROR, "lid %llu, Extent could not be adjustted "
+		       "in memory, rc %d",
+		       (unsigned long long)layer->clr_cl->l_id, cb_data.cb_rc);
+
+	rc = rc ?: cb_data.cb_rc;
 
-	if (extent_op == DELETE) {
+	if (rc == 0 && inmem_list_update) {
 		/*
-		 * The extent seg->ee_ext is replaced by some newer extent.
-		 * Hence, seg->ee_ext is asked to be deleted.
+		 * Now that the deletion/trimming of the overlapping extents
+		 * from the in-memory list of the extents has been
+		 * handled above, let's add the ultimate whole extent.
 		 */
-		ext_inmem_delete(layer, &seg->ee_ext, seg->ee_val);
-		rc = 0;
-	} else
-		rc = ext_inmem_trim(layer, extent_op, &seg->ee_ext,
-				    seg->ee_val, ext);
+		rc = ext_inmem_find(layer, ext, new_ext_state, NULL);
+		M0_ASSERT(rc == -ENOENT);
+		rc = ext_inmem_add(layer, ext, new_ext_state);
+		if (rc != 0)
+			M0_LOG(M0_ERROR, "lid %llu, Ultimate extent could not "
+			       "be added to memory, layer %lu, e_start %llu, "
+			       "e_end %llu",
+			       (unsigned long long)layer->clr_cl->l_id,
+			       (unsigned long)layer->clr_idx,
+			       (unsigned long long)ext->e_start,
+			       (unsigned long long)ext->e_end);
+	}
+	M0_POST(ergo(rc == 0, layer_invariant(layer)));
 	M0_RETURN(rc);
 }
-#endif /* __KERNEL__ */
 
 static int sublayout_id_indb_lookup(struct m0_composite_layout *cl,
 				    uint32_t layer_idx,
diff --git a/layout/ut/composite.c b/layout/ut/composite.c
index 6d6af7b..62ecba1 100644
--- a/layout/ut/composite.c
+++ b/layout/ut/composite.c
@@ -1581,16 +1581,9 @@ static void extent_to_be_operated(const struct m0_composite_layout *cl,
 	}
 }
 
-enum extent_operation {
-	EXTENT_LOOKUP,
-	EXTENT_ADD,
-	EXTENT_UPDATE,
-	EXTENT_DELETE
-};
-
 /**
- * Prepares for extent operation by creating a layout and by figuring out the
- * the extent and the offset to operate upon.
+ * Prepares for extent operation by creating a layout and by figuring out 'the
+ * extent and the offset to operate upon'.
  */
 static int ext_op_pre(enum extent_operation eop,
 		      uint64_t lid,
@@ -1649,14 +1642,27 @@ static int ext_op_pre(enum extent_operation eop,
 		txptr = NULL;
 
 	if (eop == EXTENT_LOOKUP)
-		my_console_printf("\nextlist dump before ext LOOKUP with "
+		my_console_printf("\nextlist_dump before ext LOOKUP with "
 				  "ext_kind %u, offset %llu\n", extent_kind,
 				  (unsigned long long)*offset_to_operate);
+	else if (eop == EXTENT_ADD)
+		my_console_printf("\nextlist_dump before ext ADD with "
+				  "ext_kind %u, \n\t ext [%llu, %llu), "
+				  "e_state %llu\n", extent_kind,
+				  (unsigned long long)ext_to_operate->e_start,
+				  (unsigned long long)ext_to_operate->e_end,
+				  (unsigned long long)ext_state);
+	else if (eop == EXTENT_UPDATE)
+		my_console_printf("\nextlist_dump before ext STATE_UPDATE with "
+				  "ext_kind %u, \n\t ext [%llu, %llu), "
+				  "e_state %llu\n", extent_kind,
+				  (unsigned long long)ext_to_operate->e_start,
+				  (unsigned long long)ext_to_operate->e_end,
+				  (unsigned long long)ext_state);
 	else
-		my_console_printf("\nextlist dump before ext "
-				  "ADD/STATE_UPDATE/DELETE with ext_kind %u,\n"
-				  "\text [%llu, %llu), e_state %llu\n",
-				  extent_kind,
+		my_console_printf("\nextlist_dump before ext DELETE with "
+				  "ext_kind %u, \n\t ext [%llu, %llu), "
+				  "e_state %llu\n", extent_kind,
 				  (unsigned long long)ext_to_operate->e_start,
 				  (unsigned long long)ext_to_operate->e_end,
 				  (unsigned long long)ext_state);
@@ -1811,11 +1817,11 @@ static int ext_add(struct m0_composite_layout *cl,
 	if (failure_test) {
 		M0_UT_ASSERT(rc == -EINVAL || rc == -ENOMEM ||
 			     rc == L_EMAP_LOOKUP_ERR);
-		//todo print rc
+		my_console_printf("ext ADD failed, rc %d\n", rc);
 	} else {
 		M0_UT_ASSERT(rc == 0);
-		my_console_printf("extlist dump after ext ADD with "
-				  "ext_kind, %u\n \text [%llu, %llu), "
+		my_console_printf("extlist_dump after ext ADD with "
+				  "ext_kind %u, \n\t ext [%llu, %llu), "
 				  "ext_state %llu\n", extent_kind,
 				  (unsigned long long)ext_to_operate->e_start,
 				  (unsigned long long)ext_to_operate->e_end,
@@ -1873,13 +1879,13 @@ static int ext_update(struct m0_composite_layout *cl,
 	rc = m0_composite_layer_ext_state_update(cl, cl->cl_layers_nr - 1,
 						 ext_to_operate, ext_state,
 						 txptr);
-	if (failure_test)
+	if (failure_test) {
 		M0_UT_ASSERT(rc == -EINVAL);
-		//todo print rc
-	else {
+		my_console_printf("ext STATE_UPDATE failed, rc %d\n", rc);
+	} else {
 		M0_UT_ASSERT(rc == 0);
-		my_console_printf("extlist dump after ext UPDATE with "
-				  "ext_kind %u\n, \text [%llu, %llu), "
+		my_console_printf("extlist_dump after ext STATE_UPDATE with "
+				  "ext_kind %u, \n\t ext [%llu, %llu), "
 				  "ext_state %llu\n", extent_kind,
 				  (unsigned long long)ext_to_operate->e_start,
 				  (unsigned long long)ext_to_operate->e_end,
@@ -1932,13 +1938,14 @@ static int ext_delete(struct m0_composite_layout *cl,
 	/* Delete the extent. */
 	rc = m0_composite_layer_ext_delete(cl, cl->cl_layers_nr - 1,
 					   ext_to_operate, txptr);
-	if (failure_test)
+	if (failure_test) {
 		M0_UT_ASSERT(rc == -ENOENT || rc == -EINVAL);
-	else {
+		my_console_printf("ext DELETE failed, rc %d\n", rc);
+	} else {
 		M0_UT_ASSERT(rc == 0);
 		//todo cover err cases and in failure cases, print rc
-		my_console_printf("extlist dump after ext DELETE with "
-				  "ext_kind %u\n, \text [%llu, %llu) \n",
+		my_console_printf("extlist_dump after ext DELETE with "
+				  "ext_kind %u, \n\t ext [%llu, %llu) \n",
 				  extent_kind,
 				  (unsigned long long)ext_to_operate->e_start,
 				  (unsigned long long)ext_to_operate->e_end);
diff --git a/layout/ut/composite.h b/layout/ut/composite.h
index f20f4ac..dd1216d 100644
--- a/layout/ut/composite.h
+++ b/layout/ut/composite.h
@@ -23,10 +23,10 @@
 #ifndef __MERO_LAYOUT_UT_COMPOSITE_H__
 #define __MERO_LAYOUT_UT_COMPOSITE_H__
 
-/*
+/**
  * Kind of the extent that 'is to be looked up from the extent list' or 'is to
- * be added to extent list' for a particular layer from a particular composite
- * layout.
+ * be added/updated/deleted to/from the extent list' for a particular layer
+ * from a particular composite layout.
  *
  * For example: //todo
  */
@@ -42,6 +42,16 @@ enum kind_of_extent {
 	KIND_OF_EXTENT_NR
 };
 
+/**
+ * Extent operations those can be performed on a layer from a composite layout.
+ */
+enum extent_operation {
+	EXTENT_LOOKUP,
+	EXTENT_ADD,
+	EXTENT_UPDATE,
+	EXTENT_DELETE
+};
+
 int test_build_composite(uint64_t lid,
 			 struct m0_layout_domain *domain,
 			 uint32_t min_extents_nr,
diff --git a/stob/ad.c b/stob/ad.c
index 27e0746..50ac5fc 100644
--- a/stob/ad.c
+++ b/stob/ad.c
@@ -1020,14 +1020,14 @@ static int ad_write_map_ext(struct m0_stob_io *io, struct ad_domain *adom,
 	 * of the corresponding physical extent.
 	 */
 	result = m0_emap_paste
-		(&it, &todo, ext->e_start,
-	 LAMBDA(void, (struct m0_emap_seg *seg) {
+		(&it, &todo, ext->e_start, NULL,
+	 LAMBDA(void, (struct m0_emap_seg *seg, void *data) {
 			 /* handle extent deletion. */
 			 rc = rc ?: seg_free(io, adom, seg,
 					     &seg->ee_ext, seg->ee_val);
 		 }),
 	 LAMBDA(void, (struct m0_emap_seg *seg, struct m0_ext *ext,
-		       uint64_t val) {
+		       uint64_t val, void *data) {
 			/* cut left */
 			M0_ASSERT(ext->e_start > seg->ee_ext.e_start);
 
@@ -1035,7 +1035,7 @@ static int ad_write_map_ext(struct m0_stob_io *io, struct ad_domain *adom,
 			rc = rc ?: seg_free(io, adom, seg, ext, val);
 		}),
 	 LAMBDA(void, (struct m0_emap_seg *seg, struct m0_ext *ext,
-		       uint64_t val) {
+		       uint64_t val, void *data) {
 			/* cut right */
 			M0_ASSERT(seg->ee_ext.e_end > ext->e_end);
 			if (val < AET_MIN) {
-- 
1.8.3.2

