From 2ab9f7d4851953a99c1e5274d9288dcc525ef267 Mon Sep 17 00:00:00 2001
From: "trupti.patil" <trupti_patil@xyratex.com>
Date: Wed, 16 Jan 2013 14:49:35 +0530
Subject: [PATCH 053/172] Fixing a few memory leaks

---
 layout/composite.c    | 88 +++++++++++++++++++++++++++++----------------------
 layout/ut/composite.c | 12 +++++++
 2 files changed, 63 insertions(+), 37 deletions(-)

diff --git a/layout/composite.c b/layout/composite.c
index eb90a97..4854fbe 100644
--- a/layout/composite.c
+++ b/layout/composite.c
@@ -359,6 +359,7 @@ static void composite_delete(struct m0_layout *l)
 	m0_composite_layout_bob_fini(cl);
 	m0_layout__delete(&cl->cl_base);
 	comp_layer_tlist_fini(cl->cl_layers);
+	m0_free(cl->cl_layers);
 	m0_free(cl);
 	M0_LEAVE();
 }
@@ -412,6 +413,19 @@ static int layer_in_memory_add(struct m0_composite_layout *cl,
 	return 0;
 }
 
+static void extlist_free(struct m0_tl *extlist)
+{
+	struct m0_composite_layer_extent *lr_ext;
+
+	m0_tl_for(m0_composite_layer_ext, extlist, lr_ext) {
+		m0_composite_layer_ext_tlist_del(lr_ext);
+		m0_composite_layer_ext_tlink_fini(lr_ext);
+		m0_free(lr_ext);
+	} m0_tl_endfor;
+	m0_composite_layer_ext_tlist_fini(extlist);
+	m0_free(extlist);
+}
+
 /**
  * Deletes a layer from the in-memory layout.
  *
@@ -433,8 +447,11 @@ static void layer_in_memory_delete(struct m0_composite_layout *cl,
 	comp_layer_tlink_del_fini(layer);
 	m0_layout_user_count_dec(layer->clr_l);
 	m0_layout_put(layer->clr_l);
-	M0_POST(composite_invariant(cl));
+	if (layer->clr_idx > 0) /* Except for the zeroth layer. */
+		extlist_free(layer->clr_extents);
 	M0_POST(layer->clr_idx == cl->cl_layers_nr);
+	m0_free(layer);
+	M0_POST(composite_invariant(cl));
 	M0_LEAVE();
 }
 
@@ -493,19 +510,6 @@ M0_INTERNAL int m0_composite_build(struct m0_layout_domain *dom,
 	return rc;
 }
 
-static void extlist_free(struct m0_tl *extlist)
-{
-	struct m0_composite_layer_extent *lr_ext;
-
-	m0_tl_for(m0_composite_layer_ext, extlist, lr_ext) {
-		m0_composite_layer_ext_tlist_del(lr_ext);
-		m0_composite_layer_ext_tlink_fini(lr_ext);
-		m0_free(lr_ext);
-	} m0_tl_endfor;
-	m0_composite_layer_ext_tlist_fini(extlist);
-	m0_free(extlist);
-}
-
 /** Implementation of lo_fini for COMPOSITE layout type. */
 static void composite_fini(struct m0_ref *ref)
 {
@@ -538,7 +542,7 @@ static void composite_fini(struct m0_ref *ref)
 
 	m0_layout__fini(&cl->cl_base);
 	m0_free(cl);
-	M0_LEAVE("lid %llu", (unsigned long long)l->l_id);
+	M0_LEAVE();
 }
 
 M0_INTERNAL struct m0_composite_layout *m0_layout_to_cl(
@@ -977,7 +981,14 @@ static int sublayout_id_in_db_read(struct m0_composite_layout *cl,
 	m0_db_pair_setup(&pair, &csd->csd_layer_sublayout,
 			 &key, sizeof key, &rec, sizeof rec);
 	rc = m0_table_lookup(tx, &pair);
-	if (rc != 0)
+	if (rc != 0 && rc != -ENOENT)
+		/**
+		 * The later condition is since the number of layers is not
+		 * known in advance while reading the layers from the DB.
+		 * Reference layers_in_db_read().
+		 * @todo If the number of layers is written to the primary
+		 * table, then get rid of the later condition here.
+		 */
 		m0_layout__log("sublayout_id_in_db_read",
 			       "failed to lookup into layer_sublayout table",
 			       M0_LAYOUT_ADDB_LOC_COMP_SUBLAYOUT_READ,
@@ -1462,27 +1473,30 @@ static int extentmap_in_db_read(struct m0_composite_layout *cl,
 			m0_emap_close(&it);
 			return -EINVAL;
 		}
-		M0_ALLOC_PTR(lr_ext);
-		if (lr_ext == NULL) {
-			m0_layout__log("extentmap_in_db_read",
-				       "failed to allocate composite extent",
-				       M0_LAYOUT_ADDB_LOC_COMP_EMAP_READ_4,
-				       &cl->cl_base.l_addb_ctx,
-				       cl->cl_base.l_id, -ENOMEM);
-			extlist_free(*extlist);
-			m0_emap_close(&it);
-			return -ENOMEM;
-		}
-		lr_ext->cle_ext = seg->ee_ext;
-		lr_ext->cle_state = seg->ee_val;
-		M0_LOG(M0_DEBUG, "layer[%lu], extent[%lu] "
-		       "e_start %llu, e_end %llu, seg_val %llu",
-		       (unsigned long)layer_idx, (unsigned long)*extents_nr,
-		       (unsigned long long)seg->ee_ext.e_start,
-		       (unsigned long long)seg->ee_ext.e_end,
-		       (unsigned long long)seg->ee_val);
-
-		if (lr_ext->cle_state != M0_CLRES_INVALID) {
+
+		if (seg->ee_val != M0_CLRES_INVALID) {
+			M0_ALLOC_PTR(lr_ext);
+			if (lr_ext == NULL) {
+				m0_layout__log("extentmap_in_db_read",
+					"failed to allocate composite "
+					"extent",
+					M0_LAYOUT_ADDB_LOC_COMP_EMAP_READ_4,
+					&cl->cl_base.l_addb_ctx,
+					cl->cl_base.l_id, -ENOMEM);
+				extlist_free(*extlist);
+				m0_emap_close(&it);
+				return -ENOMEM;
+			}
+			lr_ext->cle_ext = seg->ee_ext;
+			lr_ext->cle_state = seg->ee_val;
+			M0_LOG(M0_DEBUG, "layer[%lu], extent[%lu] "
+			       "e_start %llu, e_end %llu, seg_val %llu",
+			       (unsigned long)layer_idx,
+			       (unsigned long)*extents_nr,
+			       (unsigned long long)seg->ee_ext.e_start,
+			       (unsigned long long)seg->ee_ext.e_end,
+			       (unsigned long long)seg->ee_val);
+
 			m0_composite_layer_ext_tlink_init_at_tail(lr_ext,
 								  *extlist);
 			M0_CNT_INC(*extents_nr);
diff --git a/layout/ut/composite.c b/layout/ut/composite.c
index 255e6a3..22e62ca 100644
--- a/layout/ut/composite.c
+++ b/layout/ut/composite.c
@@ -157,6 +157,7 @@ static void extentlist_build(struct m0_tl **extlist,
 	multiplier = if_contiguous_extents ? 1 : 2;
 	delta = (approximate_end_offset - min_start_offset) /
 		(extents_nr * multiplier);
+#if 0
 #ifndef __KERNEL__
 		printf("extents_nr %lu, min_start_offset %llu, "
 		       "approximate_end_offset %llu\n",
@@ -164,6 +165,7 @@ static void extentlist_build(struct m0_tl **extlist,
 			(unsigned long long)min_start_offset,
 			(unsigned long long)approximate_end_offset);
 #endif
+#endif
 	for (i = 0; i < extents_nr; ++i) {
 		M0_ALLOC_PTR(extent);
 		M0_UT_ASSERT(extent != NULL);
@@ -171,11 +173,13 @@ static void extentlist_build(struct m0_tl **extlist,
 					  (multiplier * i * delta);
 		extent->cle_ext.e_end = extent->cle_ext.e_start + delta;
 		extent->cle_state = M0_CLRES_VALID;
+#if 0
 #ifndef __KERNEL__
 		printf("ext[%u]: start %llu, end %llu \n", i,
 			(unsigned long long)extent->cle_ext.e_start,
 			(unsigned long long)extent->cle_ext.e_end);
 #endif
+#endif
 		m0_composite_layer_ext_tlink_init_at_tail(extent, extents);
 	}
 	*extlist = extents;
@@ -473,6 +477,7 @@ static void composite_layout_buf_build(uint64_t composite_lid,
 						 sizeof layer_header);
 	multiplier = if_contiguous_extents ? 1 : 2;
 
+#if 0
 #ifndef __KERNEL__
 	printf("composite_layout_buf_build(): lid %llu, "
 		"min_extents_nr %lu, min_start_offset %llu, "
@@ -482,6 +487,7 @@ static void composite_layout_buf_build(uint64_t composite_lid,
 		(unsigned long long)min_start_offset,
 		(unsigned long long)approximate_end_offset);
 #endif
+#endif
 
 	/* Pre-create the sublayout to be used as the original layout. */
 	sublayout_build(composite_lid * 100, domain, &sublayout);
@@ -511,12 +517,14 @@ static void composite_layout_buf_build(uint64_t composite_lid,
 
 		delta = (approximate_end_offset - min_start_offset) /
 			(extents_nr * multiplier);
+#if 0
 #ifndef __KERNEL__
 		printf("composite_layout_buf_build(): extents_nr %lu, "
 			"delta %llu\n",
 			(unsigned long)extents_nr,
 			(unsigned long long)delta);
 #endif
+#endif
 		//todo Assert everywhere applicable that extents_nr >= 2
 		for (j = 0; j < layer_header.clh_extents_nr; ++j) {
 			ext.e_start = min_start_offset +
@@ -530,6 +538,7 @@ static void composite_layout_buf_build(uint64_t composite_lid,
 			nbytes = m0_bufvec_cursor_copyto(dcur, &ext_state,
 							 sizeof ext_state);
 			M0_ASSERT(nbytes == sizeof ext_state);
+#if 0
 #ifndef __KERNEL__
 			printf("layer[%lu]:extent[%lu]: e_start %llu, "
 				"e_end %llu \n",
@@ -537,6 +546,7 @@ static void composite_layout_buf_build(uint64_t composite_lid,
 				(unsigned long long)ext.e_start,
 				(unsigned long long)ext.e_end);
 #endif
+#endif
 		}
 		//todo enable once m0_emap_paste() works ++extents_nr;
 	}
@@ -1551,11 +1561,13 @@ static void extent_to_be_operated(const struct m0_composite_layout *cl,
 		ext->e_end = ext_idx_plus_oneth.e_end + 1;
 	}
 
+#if 0
 #ifndef __KERNEL__
 	printf("extent_to_be_operated: start %llu, end %llu \n",
 		(unsigned long long)ext->e_start,
 		(unsigned long long)ext->e_end);
 #endif
+#endif
 
 }
 
-- 
1.8.3.2

