From a4a335e9a3df4f443c902f8a15220d731a6e4b70 Mon Sep 17 00:00:00 2001
From: "trupti.patil" <trupti_patil@xyratex.com>
Date: Thu, 1 Aug 2013 12:14:43 +0530
Subject: [PATCH 164/172] Some documentation fixes

---
 layout/composite.c   | 15 ++++++-----
 layout/composite.h   | 36 +++++++++++++-------------
 layout/layout.h      | 47 ++++++++++++++-------------------
 layout/linear_enum.c |  2 --
 layout/linear_enum.h |  4 +--
 layout/list_enum.c   |  2 --
 layout/list_enum.h   |  4 +--
 layout/pdclust.c     |  2 +-
 layout/pdclust.h     | 73 ++++++++++++++++++++++++++--------------------------
 9 files changed, 88 insertions(+), 97 deletions(-)

diff --git a/layout/composite.c b/layout/composite.c
index dd0faf4..fb6951c 100644
--- a/layout/composite.c
+++ b/layout/composite.c
@@ -553,18 +553,21 @@ static struct m0_composite_layer *layer_find(
 
 M0_INTERNAL void m0_composite_layer_delete(struct m0_composite_layout *cl)
 {
-	struct m0_composite_layer *layer;
+	struct m0_composite_layer     *layer;
+	struct m0_composite_layer_ext *ext;
 
 	M0_PRE(composite_invariant(cl));
 	M0_PRE(cl->cl_layers_nr > 1);
 
-	M0_ENTRY("lid %llu, layers_nr %lu",
-		 (unsigned long long)cl->cl_base.l_id,
+	M0_ENTRY("lid %llu, layers_nr %lu", (unsigned long long)cl->cl_base.l_id,
 		 (unsigned long)cl->cl_layers_nr);
 	m0_mutex_lock(&cl->cl_base.l_lock);
 	layer = layers_tlist_tail(&cl->cl_layers); /* The top-most layer. */
-	M0_PRE(m0_tl_forall(ext, ext1, &layer->clr_extents,
-			    ext1->cle_state == M0_CLRES_HOLE));
+	ext = ext_tlist_head(&layer->clr_extents);
+	M0_PRE(layer->clr_extents_nr == 1 &&
+	       ext->cle_ext.e_start == 0 &&
+	       ext->cle_ext.e_end == M0_BINDEX_MAX + 1 &&
+	       ext->cle_state == M0_CLRES_HOLE);
 	layer_delete(cl, layer);
 	m0_mutex_unlock(&cl->cl_base.l_lock);
 	M0_POST(composite_invariant(cl));
@@ -1628,7 +1631,7 @@ M0_INTERNAL int m0_composite_layer_update(
 	layer = layer_find(cl, layer_idx);
 	rc = ext_write(cl, layer, e, state);
 	if (rc != 0)
-		m0_layout__log("m0_composite_layer_ext_add",
+		m0_layout__log("m0_composite_layer_update",
 			       "failed to add extent",
 			       M0_LAYOUT_ADDB_LOC_COMP_EXT_ADD,
 			       &cl->cl_base.l_addb_ctx, cl->cl_base.l_id, rc);
diff --git a/layout/composite.h b/layout/composite.h
index c25aa33..195d6e1 100644
--- a/layout/composite.h
+++ b/layout/composite.h
@@ -72,9 +72,7 @@
  * so as to update the DB version of the layout:
  * - m0_composite_layer_add()
  * - m0_composite_layer_delete()
- * - m0_composite_layer_ext_add()
- * - m0_composite_layer_ext_state_update()
- * - m0_composite_layer_ext_delete()
+ * - m0_composite_layer_update()
  * @{
  */
 
@@ -247,8 +245,8 @@ struct m0_layers_array {
 M0_BASSERT(M0_IS_8ALIGNED(sizeof(struct m0_layers_array)));
 
 /**
- * Part of the 'in-memory composite layout' that needs to be transferred over
- * the network.
+ * Representation of the part of the 'in-memory composite layout' that needs to
+ * be transferred over the network.
  */
 struct m0_composite_onwire {
 	/** Super class. */
@@ -312,15 +310,14 @@ enum {
  * Adds a layer to the composite layout.
  *
  * Multiple extents can be subsequently added to this layer, by explicitly
- * using the API m0_composite_layer_ext_add().
+ * using the API m0_composite_layer_update().
  *
  * @pre cl->cl_layers_nr < M0_COMPOSITE_LAYERS_MAX
  * @post A reference has been added to the sublayout.
  *
  * @note When this layer gets added to the DB version of the layout (through
- *       the DB update made through the m0_layout_add() or
- *       the m0_layout_update() API), user count for the sublayout is
- *       incremented by one.
+ * the DB update made through the m0_layout_add() or the m0_layout_update() API),
+ * user count for the sublayout is incremented by one.
  */
 M0_INTERNAL int m0_composite_layer_add(struct m0_composite_layout *cl,
 				       struct m0_layout *sublayout);
@@ -331,8 +328,10 @@ M0_INTERNAL int m0_composite_layer_add(struct m0_composite_layout *cl,
  * any non-hole extents'.
  *
  * @pre cl->cl_layers_nr > 1
- * @pre m0_tl_forall(m0_composite_layer_ext, ext, &layer->clr_extents,
- *                   ext->cle_state == M0_CLRES_HOLE));
+ * @pre layer being the topmost layer, layer->clr_extents_nr == 1
+ * @pre ext_tlist_head(&layer->clr_extents)->cle_ext.e_start == 0
+ * @pre ext_tlist_head(&layer->clr_extents)->cle_ext.e_end == M0_BINDEX_MAX + 1
+ * @pre ext_tlist_head(&layer->clr_extents)->cle_state == M0_CLRES_HOLE
  *
  * @post A reference has been released from the sublayout associated with the
  *       top-most layer.
@@ -347,8 +346,8 @@ M0_INTERNAL void m0_composite_layer_delete(struct m0_composite_layout *cl);
 /**
  * Deletes 'the second from the top layer' and re-indexes the top-most layer
  * as the second from the top (now the top-most).
- * To be used during flattening in cases when 'the second from the top layer'
- * becomes empty and is to be removed.
+ * This API is to be used during flattening in cases when 'the second from the top
+ * layer' becomes empty and is to be removed.
  */
 M0_INTERNAL void m0_composite_layer_delete_second_from_top(
 					struct m0_composite_layout *cl);
@@ -365,7 +364,7 @@ M0_INTERNAL void m0_composite_layer_delete_second_from_top(
  * @param ext_state 'Out' parameter to report back the state of the extent
  *        being returned.
  * @param layer 'Out' parameter to report back the layer the extent belongs
- *        to. It can be used to refer to the layer_idx and the sublayout.
+ *        to. It can be used to refer to the layer index and the sublayout.
  *
  * The lookup starts with the top-most layer and goes upto the bottom-most
  * layer. If an extent containing the offset is not found upto the bottom-most
@@ -381,12 +380,13 @@ M0_INTERNAL int m0_composite_layer_ext_lookup(
 /**
  * todo revise as per the change in the reqt
  * Adds an extent with the specified state to the specified layer of the
- * specified composite layout.
+ * specified composite layout. This API may be used to add extents, to delete
+ * those (to add with the M0_CLRES_HOLE state) or to update their state, for
+ * example, to change state from M0_CLRES_VALID to M0_CLRES_FLATTENING.
  *
  * It internally overwrites or truncates the overlapping extents as necessary.
- * The overlapping extents can be merged if and only if they are with the state
- * M0_CLRES_HOLE or with the state same as ext_state. If this criterion is
- * not satisfied, the error -EINVAL is returned.
+ * It internally merges the extent with the adjacent ones if the state of the
+ * adjacent extents is same as that is provided by 'ext_state'.
  *
  * @pre M0_IN(ext_state, (M0_CLRES_HOLE, M0_CLRES_VALID, M0_CLRES_FLATTENING))
  */
diff --git a/layout/layout.h b/layout/layout.h
index 5cf871f..9f08c74 100644
--- a/layout/layout.h
+++ b/layout/layout.h
@@ -216,10 +216,10 @@ struct m0_layout_domain {
 
 	/**
 	 * @todo Add two flags viz. ld_is_db_available and ld_is_nw_available
-	 * to indicate if the DB is available and it the network is available
-	 * to the domain, respectively. An assumption is that either of
-	 * ld_is_db_available and ld_is_network_available can be false at any
-	 * point in time but not both of them.
+	 * to indicate 'if the DB is available' and 'if the network is
+	 * available' to the domain, respectively. An assumption is that either
+	 * of ld_is_db_available and ld_is_network_available can be false at
+	 * any point in time but not both of them.
 	 *
 	 * This item will be cleared with the subsequent task to add
 	 * 'the composite layout type support to getattr'.
@@ -233,7 +233,8 @@ struct m0_layout_domain {
 };
 
 /**
- * Part of the in-memory layout that needs to be transferred over the network.
+ * Representation of part of the 'in-memory layout' that needs to be
+ * transferred over the network.
  */
 struct m0_layout_onwire {
 	/** Layout type id. */
@@ -519,38 +520,28 @@ struct m0_layout_enum_ops {
 	void        (*leo_delete)(struct m0_layout_enum *e);
 
 	/**
-	 * Continues building the in-memory layout object, the enum part of it
-	 * specifically, either from the buffer or from the DB.
+	 * Continues building the in-memory layout object, specifically the
+	 * enum part of it, by referring to its representation stored in the DB.
 	 *
-	 * @param op This enum parameter indicates what if a DB operation is
-	 *           to be performed on the layout record and it could be
-	 *           LOOKUP if at all. If it is BUFFER_OP, then the layout is
-	 *           decoded from its representation received through the
-	 *           buffer.
-	 * @pre M0_IN(op, (M0_LXO_DB_LOOKUP, M0_LXO_BUFFER_OP))
-	 * @pre ergo(op == M0_LXO_DB_LOOKUP, tx != NULL)
+	 * @pre tx != NULL
 	 * @post The cursor cur is advanced by the size of the data that is
 	 * read from it.
 	 */
 	int         (*leo_decode)(struct m0_layout_enum *e,
 				  struct m0_bufvec_cursor *cur,
-				  enum m0_layout_xcode_op op,
 				  struct m0_db_tx *tx,
 				  struct m0_striped_layout *stl);
 
 	/**
-	 * Continues to use the in-memory layout object, the enum part of it
-	 * specifically and either 'stores it in the Layout DB' or 'converts
-	 * it to a buffer'.
+	 * Continues to use the in-memory layout object, specifically the enum
+	 * part of it and either stores it in the Layout DB.
 	 *
 	 * @param op This enum parameter indicates what is the DB operation to
-	 *           be performed on the layout record if at all and it could
-	 *           be one of ADD/UPDATE/DELETE. If it is BUFFER_OP, then the
-	 *           layout is converted into a buffer.
+	 *           be performed on the layout record and it could be one of
+	 *           ADD/UPDATE/DELETE.
 	 *
-	 * @pre M0_IN(op, (M0_LXO_DB_ADD, M0_LXO_DB_UPDATE,
-	 *                 M0_LXO_DB_DELETE, M0_LXO_BUFFER_OP))
-	 * @pre ergo(op != M0_LXO_BUFFER_OP, tx != NULL)
+	 * @pre M0_IN(op, (M0_LXO_DB_ADD, M0_LXO_DB_UPDATE, M0_LXO_DB_DELETE))
+	 * @pre tx != NULL
 	 */
 	int         (*leo_encode)(const struct m0_layout_enum *le,
 				  enum m0_layout_xcode_op op,
@@ -594,7 +585,7 @@ M0_INTERNAL int m0_layout_enum_xc_type(const struct m0_xcode_obj *obj,
 
 /**
  * Structure specific to a layout enumeration type.
- * There is an instance of m0_layout_enum_type for each one of enumeration
+ * There is an instance of m0_layout_enum_type for each one of the enumeration
  * types. For example, for LINEAR and LIST enumeration types.
  * Any enumeration type can be registered with only one domain, at a time.
  */
@@ -697,8 +688,8 @@ struct m0_layout_instance_ops {
 	 * Returns enum object embedded in the layout referred by
 	 * the layout instance.
 	 */
-	struct m0_layout_enum *
-		(*lio_to_enum)(const struct m0_layout_instance *li);
+	struct m0_layout_enum *(*lio_to_enum)(
+					const struct m0_layout_instance *li);
 };
 
 /**
@@ -945,7 +936,7 @@ M0_INTERNAL int m0_layout_decode(struct m0_layout *l,
  * - m0_layout__invariant(l)
  * - m0_mutex_is_locked(&l->l_lock)
  * @post
- * - If op is is either for M0_LXO_DB_<ADD|UPDATE|DELETE>, the respective DB
+ * - If op is either for M0_LXO_DB_<ADD|UPDATE|DELETE>, the respective DB
  *   operation is continued.
  * - If op is M0_LXO_BUFFER_OP, the buffer contains the serialised
  *   representation of the whole layout.
diff --git a/layout/linear_enum.c b/layout/linear_enum.c
index b475f9a..3921ac3 100644
--- a/layout/linear_enum.c
+++ b/layout/linear_enum.c
@@ -218,7 +218,6 @@ static m0_bcount_t linear_max_recsize(void)
 /** Implementation of leo_decode() for linear enumeration type. */
 static int linear_decode(struct m0_layout_enum *e,
 			 struct m0_bufvec_cursor *cur,
-			 enum m0_layout_xcode_op op,
 			 struct m0_db_tx *tx,
 			 struct m0_striped_layout *stl)
 {
@@ -228,7 +227,6 @@ static int linear_decode(struct m0_layout_enum *e,
 
 	M0_PRE(e != NULL);
 	M0_PRE(cur != NULL);
-	M0_PRE(op == M0_LXO_DB_LOOKUP);
 	M0_PRE(tx != NULL);
 	M0_PRE(m0_layout__striped_allocated_invariant(stl));
 
diff --git a/layout/linear_enum.h b/layout/linear_enum.h
index d7ac9f1..7df2bb0 100644
--- a/layout/linear_enum.h
+++ b/layout/linear_enum.h
@@ -72,8 +72,8 @@ struct m0_layout_linear_enum {
 };
 
 /**
- * Part of the 'in-memory linear enum' that needs to be transferred over the
- * network.
+ * Representation of the part of the 'in-memory linear enum' that needs to be
+ * transferred over the network.
  */
 struct m0_layout_linear_enum_onwire {
 	struct m0_layout_linear_attr lleo_attr;
diff --git a/layout/list_enum.c b/layout/list_enum.c
index f0f6fd3..514e411 100644
--- a/layout/list_enum.c
+++ b/layout/list_enum.c
@@ -402,7 +402,6 @@ out:
 /** Implementation of leo_decode() for LIST enumeration type. */
 static int list_decode(struct m0_layout_enum *e,
 		       struct m0_bufvec_cursor *cur,
-		       enum m0_layout_xcode_op op,
 		       struct m0_db_tx *tx,
 		       struct m0_striped_layout *stl)
 {
@@ -418,7 +417,6 @@ static int list_decode(struct m0_layout_enum *e,
 
 	M0_PRE(e != NULL);
 	M0_PRE(cur != NULL);
-	M0_PRE(op == M0_LXO_DB_LOOKUP);
 	M0_PRE(tx != NULL);
 	M0_PRE(m0_layout__striped_allocated_invariant(stl));
 
diff --git a/layout/list_enum.h b/layout/list_enum.h
index 84045d4..93976be 100644
--- a/layout/list_enum.h
+++ b/layout/list_enum.h
@@ -70,8 +70,8 @@ struct m0_layout_list_cobs_array {
 } M0_XCA_SEQUENCE;
 
 /**
- * Part of the 'in-memory list enum' that needs to be transferred over the
- * network.
+ * Representation of the part of the 'in-memory list enum' that needs to be
+ * transferred over the network.
  */
 struct m0_layout_list_enum_onwire {
 	/** Array of cobs. */
diff --git a/layout/pdclust.c b/layout/pdclust.c
index d2a2271..2fbb759 100644
--- a/layout/pdclust.c
+++ b/layout/pdclust.c
@@ -497,7 +497,7 @@ static int pdclust_decode(struct m0_layout *l,
 			       "rc %d", (unsigned long long)l->l_id, rc);
 			goto out;
 		}
-		rc = e->le_ops->leo_decode(e, cur, op, tx, &pl->pl_base);
+		rc = e->le_ops->leo_decode(e, cur, tx, &pl->pl_base);
 		if (rc != 0) {
 			/* Finalise the allocated enum object. */
 			e->le_ops->leo_delete(e);
diff --git a/layout/pdclust.h b/layout/pdclust.h
index d748f1d..18f5bd2 100644
--- a/layout/pdclust.h
+++ b/layout/pdclust.h
@@ -66,8 +66,8 @@
 
 /* import */
 #include "lib/arith.h"        /* M0_IS_8ALIGNED */
-#include "sns/parity_math.h"
 #include "lib/types_xc.h"     /* struct m0_uint128_xc */
+#include "sns/parity_math.h"
 #include "layout/layout.h"
 #include "layout/layout_xc.h" /* struct m0_layout_onwire_xc */
 
@@ -117,8 +117,40 @@ struct m0_pdclust_attr {
 M0_BASSERT(M0_IS_8ALIGNED(sizeof(struct m0_pdclust_attr)));
 
 /**
- * Part of the 'in-memory pdclust layout' that needs to be transferred over the
- * network.
+ * Extension of the generic m0_striped_layout for the parity de-clustered
+ * layout type.
+ *
+ * @invariant pdl->pl_C * (pdl->pl_attr.pa_N + 2 * pdl->pl_attr.pa_K) ==
+ *            pdl->pl_L * pdl->pl_attr.pa_P
+ * @invariant pdl->pl_base.sl_enum->le_ops->leo_nr(pdl->pl_base.sl_enum) ==
+ *            pdl->pl_attr.pa_P
+ *
+ * Concurrency control: All the direct and indirect members of the struct
+ * m0_pdclust_layout are protected by the single lock viz.
+ * m0_pdclust_layout::pl_base::l_lock.
+ */
+struct m0_pdclust_layout {
+	/** Super class */
+	struct m0_striped_layout   pl_base;
+	/** Parity de-clustering layout attributes. */
+	struct m0_pdclust_attr     pl_attr;
+	/**
+	 * Number of parity groups in a tile.
+	 * @see m0_pdclust_layout::pl_L
+	 */
+	uint32_t                   pl_C;
+	/**
+	 * Number of "frame rows" in a tile. L * P == C * (N + 2 * K).
+	 * @see m0_pdclust_layout::pl_C
+	 */
+	uint32_t                   pl_L;
+
+	uint64_t                   pl_magic;
+};
+
+/**
+ * Representation of the part of the 'in-memory pdclust layout' that needs to
+ * be transferred over the network.
  */
 struct m0_pdclust_onwire {
 	/** Super class. */
@@ -129,7 +161,8 @@ struct m0_pdclust_onwire {
 	uint32_t                po_let_id;
 	/**
 	 * Pointer to onwire enum object. For example it may be pointer to
-	 * m0_layout_list_onwire or m0_layout_linear_enum_onwire object.
+	 * m0_layout_list_enum_onwire_xc or
+	 * m0_layout_linear_enum_onwire_xc object.
 	 */
 	void                   *po_enum M0_XCA_OPAQUE("m0_layout_enum_xc_type");
 } M0_XCA_RECORD;
@@ -154,38 +187,6 @@ struct m0_layout_pdclust_rec {
 M0_BASSERT(M0_IS_8ALIGNED(sizeof(struct m0_layout_pdclust_rec)));
 
 /**
- * Extension of the generic m0_striped_layout for the parity de-clustered
- * layout type.
- *
- * @invariant pdl->pl_C * (pdl->pl_attr.pa_N + 2 * pdl->pl_attr.pa_K) ==
- *            pdl->pl_L * pdl->pl_attr.pa_P
- * @invariant pdl->pl_base.sl_enum->le_ops->leo_nr(pdl->pl_base.sl_enum) ==
- *            pdl->pl_attr.pa_P
- *
- * Concurrency control: All the direct and indirect members of the struct
- * m0_pdclust_layout are protected by the single lock viz.
- * m0_pdclust_layout::pl_base::l_lock.
- */
-struct m0_pdclust_layout {
-	/** Super class */
-	struct m0_striped_layout   pl_base;
-	/** Parity de-clustering layout attributes. */
-	struct m0_pdclust_attr     pl_attr;
-	/**
-	 * Number of parity groups in a tile.
-	 * @see m0_pdclust_layout::pl_L
-	 */
-	uint32_t                   pl_C;
-	/**
-	 * Number of "frame rows" in a tile. L * P == C * (N + 2 * K).
-	 * @see m0_pdclust_layout::pl_C
-	 */
-	uint32_t                   pl_L;
-
-	uint64_t                   pl_magic;
-};
-
-/**
  * Parity de-clustered layout instance for a particular file.
  *
  * This structure contains information necessary to execute IO against a
-- 
1.8.3.2

