From 058362fe54a1440c5a4838cf369993ff5e75e98b Mon Sep 17 00:00:00 2001
From: "trupti.patil" <trupti_patil@xyratex.com>
Date: Wed, 7 Nov 2012 00:06:58 +0530
Subject: [PATCH 016/172] Changes to compisite build as per newer def of
 composite layout

1) Changes to c2_composite_layout_build(0 as per the newer definition of the
   composite layout - each sublayout maps to a list of extents, as against
   the earlier definition that had each sub-layout map to one single extent.
2) Addition of layout.h and composite.c files to layout/ut directory.
   compisite.c is used for test cases specific to composite layout type.
---
 build_kernel_modules/Makefile.in |   2 +-
 colibri/magic.h                  |  10 +-
 layout/composite.c               | 181 +++++----
 layout/composite.h               |  70 +++-
 layout/layout.c                  |   2 +-
 layout/ut/Makefile.sub           |   6 +-
 layout/ut/composite.c            | 821 +++++++++++++++++++++++++++++++++++++++
 layout/ut/layout.c               | 801 +++-----------------------------------
 layout/ut/layout.h               | 126 ++++++
 9 files changed, 1178 insertions(+), 841 deletions(-)
 create mode 100644 layout/ut/composite.c
 create mode 100644 layout/ut/layout.h

diff --git a/build_kernel_modules/Makefile.in b/build_kernel_modules/Makefile.in
index 1c41519..cd5b19c 100644
--- a/build_kernel_modules/Makefile.in
+++ b/build_kernel_modules/Makefile.in
@@ -116,7 +116,7 @@ ioservice_ut_SOURCES            := bulkio_client.c
 layout_SOURCES                  := layout.c layout_db.c pdclust.c composite.c \
                                    list_enum.c linear_enum.c
 
-layout_ut_SOURCES               := layout.c
+layout_ut_SOURCES               := layout.c composite.c
 
 lib_SOURCES                     := bitstring.c getopts.c vec.c list.c queue.c  \
 				   refs.c time.c bitmap.c chan.c misc.c buf.c  \
diff --git a/colibri/magic.h b/colibri/magic.h
index 8097f49..50ff0c2 100755
--- a/colibri/magic.h
+++ b/colibri/magic.h
@@ -277,7 +277,7 @@ enum c2_magic_satchel {
 	/* c2_layout_enum::le_magic (ideal follies) */
 	C2_LAYOUT_ENUM_MAGIC = 0x331dea1f0111e577,
 
-	/* layout_tlist::head_magic (biddable blad) */
+	/* c2_layout_tlist::head_magic (biddable blad) */
 	C2_LAYOUT_HEAD_MAGIC = 0x33b1ddab1eb1ad77,
 
 	/* c2_layout_instance::li_magic (cicilial cell) */
@@ -304,9 +304,15 @@ enum c2_magic_satchel {
 	/* c2_composite_sub_layout::csl_magic (zodiac zoisia) */
 	C2_LAYOUT_COMP_SUBL_MAGIC = 0x3320d1ac20151a77,
 
-	/* todo sub_layout_tlist::head_magic (ss solidified) */
+	/* c2_sub_layout_tlist::head_magic (ss solidified) */
 	C2_LAYOUT_COMP_SUBL_HEAD_MAGIC = 0x33555011d1f1ed77,
 
+	/* c2_sub_layout_extent::sle_magic (add addable ad) */
+	C2_LAYOUT_EXTENT_MAGIC = 0x33addaddab1ead77,
+
+	/* c2_layout_extent::head_magic (addable addle) */
+	C2_LAYOUT_EXTENT_HEAD_MAGIC = 0x33addab1eadd1e77,
+
 /* Net */
 	/* c2_net_domain::nd_magix (acidic access) */
 	C2_NET_DOMAIN_MAGIC = 0x33ac1d1cacce5577,
diff --git a/layout/composite.c b/layout/composite.c
index 834273f..4ca9574 100644
--- a/layout/composite.c
+++ b/layout/composite.c
@@ -84,14 +84,20 @@ C2_TL_DESCR_DEFINE(c2_sub_layout, "sub-layout-list", /* global */,
 		   C2_LAYOUT_COMP_SUBL_MAGIC, C2_LAYOUT_COMP_SUBL_HEAD_MAGIC);
 C2_TL_DEFINE(c2_sub_layout, /* global */, struct c2_composite_sub_layout);
 
+C2_TL_DESCR_DEFINE(c2_layout_extent, "layout-extent-list", /* global */,
+		   struct c2_sub_layout_extent, sle_list_linkage, sle_magic,
+		   C2_LAYOUT_EXTENT_MAGIC, C2_LAYOUT_EXTENT_HEAD_MAGIC);
+C2_TL_DEFINE(c2_layout_extent, /* global */, struct c2_sub_layout_extent);
+
 static bool composite_allocated_invariant(const struct c2_composite_layout *cl)
 {
 	return
 		cl != NULL &&
 		c2_layout__allocated_invariant(&cl->cl_base) &&
 		c2_mutex_is_locked(&cl->cl_base.l_lock) &&
-		cl->cl_sub_layouts == NULL &&
-		cl->cl_nr == 0;
+		cl->cl_sub_layouts != NULL &&
+		c2_sub_layout_tlist_is_empty(cl->cl_sub_layouts) &&
+		cl->cl_sublayouts_nr == 0;
 }
 
 static bool composite_invariant(const struct c2_composite_layout *cl)
@@ -100,9 +106,8 @@ static bool composite_invariant(const struct c2_composite_layout *cl)
 		c2_composite_layout_bob_check(cl) &&
 		c2_layout__invariant(&cl->cl_base) &&
 		cl->cl_sub_layouts != NULL &&
-		!c2_sub_layout_tlist_is_empty(cl->cl_sub_layouts) &&
-		cl->cl_nr > 1 && /* There have to be at least 2 sub-layouts */
-		cl->cl_nr == c2_sub_layout_tlist_length(cl->cl_sub_layouts) &&
+		cl->cl_sublayouts_nr ==
+			c2_sub_layout_tlist_length(cl->cl_sub_layouts) &&
 		c2_tl_forall(c2_sub_layout, sl, cl->cl_sub_layouts,
 			     c2_layout__invariant(sl->csl_l));
 }
@@ -130,6 +135,14 @@ err1_injected:
 		return -ENOMEM;
 	}
 
+	C2_ALLOC_PTR(cl->cl_sub_layouts);
+	if (cl->cl_sub_layouts == NULL) {
+		c2_layout__log("composite_allocate", "C2_ALLOC_PTR() failed",
+			       &c2_addb_oom, &layout_global_ctx, lid, -ENOMEM);
+		return -ENOMEM;
+	}
+	c2_sub_layout_tlist_init(cl->cl_sub_layouts);
+
 	c2_layout__init(&cl->cl_base, dom, lid,
 			(struct c2_layout_type *)&c2_composite_layout_type,
 			&composite_ops);
@@ -155,13 +168,14 @@ static void composite_delete(struct c2_layout *l)
 	c2_mutex_unlock(&l->l_lock);
 	c2_composite_layout_bob_fini(cl);
 	c2_layout__delete(&cl->cl_base);
+	c2_sub_layout_tlist_fini(cl->cl_sub_layouts);
 	c2_free(cl);
 	C2_LEAVE();
 }
 
 static void composite_populate(struct c2_composite_layout *cl,
-			       struct c2_tl *sub_layouts,
-			       uint32_t sublayouts_nr,
+			   //    struct c2_tl *sub_layouts,
+			     //  uint32_t sublayouts_nr,
 			       uint32_t user_count)
 {
 	C2_PRE(composite_allocated_invariant(cl));
@@ -172,74 +186,38 @@ static void composite_populate(struct c2_composite_layout *cl,
 
 	C2_ENTRY("lid %llu", (unsigned long long)cl->cl_base.l_id);
 	c2_layout__populate(&cl->cl_base, user_count);
+	/*
 	cl->cl_sub_layouts = sub_layouts;
 	cl->cl_nr = sublayouts_nr;
+	*/
 
 	C2_POST(composite_invariant(cl));
 	C2_POST(c2_mutex_is_locked(&cl->cl_base.l_lock));
 	C2_LEAVE("lid %llu", (unsigned long long)cl->cl_base.l_id);
 }
 
-/*
- * @post A composite type of layout object is created. User is expected to
- * add a reference on the layout object as required and is expected to release
- * the reference when done with the usage. The layout is finalised when it is
- * the last reference being released.
- */
 int c2_composite_build(struct c2_layout_domain *dom,
 		       uint64_t lid,
-		       struct c2_tl *sub_layouts,
 		       struct c2_composite_layout **out)
 {
 	struct c2_layout               *l;
 	struct c2_composite_layout     *cl;
-	struct c2_composite_sub_layout *sl;
-	uint32_t                        sublayouts_nr;
 	int                             rc;
 
 	C2_PRE(out != NULL);
-	C2_PRE(!c2_sub_layout_tlist_is_empty(sub_layouts));
-
 	C2_ENTRY("domain %p, lid %llu", dom,(unsigned long long)lid);
 
-	/*
-	 * Validate the sub-layouts list ensuring that each sub-layout is
-	 * cached.
-	 * Add a reference to each sub-layout (done internally by
-	 * c2_layout_find()) and increment user count of each sub-layout. The
-	 * addition of reference and incrementing if user count will be undone
-	 * composite_fini().
-	 */
-	sublayouts_nr = 0;
-	c2_tl_for(c2_sub_layout, sub_layouts, sl) {
-		C2_ASSERT(c2_layout__invariant(sl->csl_l));
-		l = c2_layout_find(dom, sl->csl_l->l_id);
-		if (l == NULL) {
-			c2_layout__log("c2_composite_build",
-				       "sub-layout not found in cache",
-				       &c2_addb_oom, &sl->csl_l->l_addb,
-				       sl->csl_l->l_id, -EPROTO);
-			/* todo Undo ref and user count added to some
-			 * sub-layouts. */
-			return -EPROTO;
-		}
-		C2_ASSERT(l == sl->csl_l);
-		c2_layout_user_count_inc(sl->csl_l);
-		++sublayouts_nr;
-	} c2_tl_endfor;
-
-	l = NULL;
 	rc = composite_allocate(dom, lid, &l);
 	if (rc == 0) {
 		/* Here composite_allocate() has locked l->l_lock. */
 		cl = bob_of(l, struct c2_composite_layout, cl_base,
 			    &composite_bob);
 		C2_ASSERT(composite_allocated_invariant(cl));
-		composite_populate(cl, sub_layouts, sublayouts_nr, 0);
+		composite_populate(cl, 0);
 		*out = cl;
 		c2_mutex_unlock(&l->l_lock);
 	} else {
-		/* todo Undo ref added to sub-layouts, etc. */
+		//todo Handle error
 	}
 
 	C2_POST(ergo(rc == 0, composite_invariant(*out) &&
@@ -255,6 +233,7 @@ static void composite_fini(struct c2_ref *ref)
 	struct c2_layout               *l;
 	struct c2_composite_layout     *cl;
 	struct c2_composite_sub_layout *sl;
+	struct c2_sub_layout_extent    *sl_ext;
 
 	l = container_of(ref, struct c2_layout, l_ref);
 	C2_PRE(c2_mutex_is_not_locked(&l->l_lock));
@@ -264,10 +243,16 @@ static void composite_fini(struct c2_ref *ref)
 	c2_composite_layout_bob_fini(cl);
 
 	c2_tl_for(c2_sub_layout, cl->cl_sub_layouts, sl) {
+		c2_tl_for(c2_layout_extent, sl->csl_extents, sl_ext) {
+			c2_layout_extent_tlist_del(sl_ext);
+			c2_layout_extent_tlink_fini(sl_ext);
+			c2_free(sl_ext);
+		} c2_tl_endfor;
+		c2_free(sl->csl_extents);
+
 		c2_layout_user_count_dec(sl->csl_l);
 		/*
-		 * Release the reference acquired either by c2_composite_build()
-		 * or by c2_layout_decode().
+		 * Release the reference acquired by c2_composite_layer_add().
 		 */
 		c2_layout_put(sl->csl_l);
 		c2_sub_layout_tlist_del(sl);
@@ -282,6 +267,41 @@ static void composite_fini(struct c2_ref *ref)
 	C2_LEAVE();
 }
 
+int c2_composite_layer_add(struct c2_composite_layout *cl,
+			   struct c2_layout *l,
+			   struct c2_tl *extlist,
+			   uint32_t ext_nr)
+{
+	struct c2_composite_sub_layout *sl;
+
+	C2_PRE(composite_invariant(cl));
+	C2_PRE(c2_layout__invariant(l));
+	C2_PRE(extlist != NULL);
+
+	C2_ENTRY();
+	if (c2_layout_extent_tlist_is_empty(extlist)) {
+		//todo Handle error
+		return -EINVAL;
+	}
+
+	//todo Lock cl, l as appropriate
+
+	C2_ALLOC_PTR(sl);
+	C2_ASSERT(sl != NULL); //todo handle error
+
+	sl->csl_l = l;
+	sl->csl_extents = extlist;
+	c2_layout_get(sl->csl_l);
+	c2_layout_user_count_inc(sl->csl_l);
+	c2_sub_layout_tlink_init_at_tail(sl, cl->cl_sub_layouts);
+	++cl->cl_sublayouts_nr;
+
+	//todo This op has to sync up the on-disk db
+
+	C2_LEAVE(); //todo addb record
+	return 0;
+}
+
 struct c2_composite_layout *c2_layout_to_cl(const struct c2_layout *l)
 {
 	struct c2_composite_layout *cl;
@@ -367,6 +387,7 @@ static c2_bcount_t composite_max_recsize(struct c2_layout_domain *dom)
 	return 0;
 }
 
+#if 0
 static int sublayouts_read(struct c2_composite_layout *cl,
 			   struct c2_tl *sub_layouts, uint32_t *nr,
 			   struct c2_db_tx *tx)
@@ -424,7 +445,7 @@ static int sublayouts_read(struct c2_composite_layout *cl,
 		C2_LOG(C2_DEBUG, "Sub-layout[%lu]: lid %llu, "
 		       "e_start %llu, e_end %llu",
 		       (unsigned long)sublayouts_nr,
-		       (unsigned long long)sl->csl_l->l_id,
+		       (insigned long long)sl->csl_l->l_id,
 		       (unsigned long long)sl->csl_ext.e_start,
 		       (unsigned long long)sl->csl_ext.e_end);
 
@@ -443,6 +464,7 @@ static int sublayouts_read(struct c2_composite_layout *cl,
 	c2_emap_close(&it);
 	return rc;
 }
+#endif
 
 static const struct c2_layout_ops composite_ops;
 
@@ -455,7 +477,9 @@ static int composite_decode(struct c2_layout *l,
 {
 	struct c2_composite_layout     *cl;
 	struct c2_composite_sub_layout *sl;
-	struct c2_tl                   *sub_layouts;
+	struct c2_ext                  *ext_list;
+	struct c2_tl                   *extlist = NULL;
+	//struct c2_tl                   *sub_layouts;
 	struct sub_layouts_header      *sl_header;
 	struct sub_layout_entry        *sl_entry;
 	uint32_t                        nr;
@@ -474,9 +498,10 @@ static int composite_decode(struct c2_layout *l,
 
 	sl_header = c2_bufvec_cursor_addr(cur);
 	c2_bufvec_cursor_move(cur, sizeof *sl_header);
-	C2_ASSERT(c2_bufvec_cursor_step(cur) >= sl_header->slh_nr *
+	C2_ASSERT(c2_bufvec_cursor_step(cur) >= sl_header->slh_sublayouts_nr *
 						sizeof *sl_entry);
 
+#if 0
 	C2_ALLOC_PTR(sub_layouts);
 	if (sub_layouts == NULL) {
 		c2_layout__log("composite_decode", "C2_ALLOC_PTR() failed",
@@ -485,13 +510,16 @@ static int composite_decode(struct c2_layout *l,
 		return -ENOMEM;
 	}
 	c2_sub_layout_tlist_init(sub_layouts);
+#endif
 
 	if (op == C2_LXO_BUFFER_OP) {
 		/*
 		 * Parse the sub-layout information from the buffer pointed by
 		 * cur and store it in the sub_layouts list.
 		 */
-		for (i = 0; i < sl_header->slh_nr; ++i) {
+
+		C2_ALLOC_ARR(ext_list, sl_header->slh_sublayouts_nr);
+		for (i = 0; i < sl_header->slh_sublayouts_nr; ++i) {
 			sl_entry = c2_bufvec_cursor_addr(cur);
 			c2_bufvec_cursor_move(cur, sizeof *sl_entry);
 
@@ -525,21 +553,25 @@ static int composite_decode(struct c2_layout *l,
 			}
 
 			c2_layout_user_count_inc(sl->csl_l);
-			sl->csl_ext = sl_entry->sle_ext;
-			c2_sub_layout_tlink_init_at(sl, sub_layouts);
+			//todo ext_list[i] = sl_entry->sle_ext;
+			//c2_sub_layout_tlink_init_at(sl, sub_layouts);
 		}
-		C2_ASSERT(i == sl_header->slh_nr);
-		nr = sl_header->slh_nr; //todo Optimize code
+		C2_ASSERT(i == sl_header->slh_sublayouts_nr);
+		nr = sl_header->slh_sublayouts_nr; //todo Optimize code
+		rc = c2_composite_layer_add(cl, sl->csl_l, extlist,
+				/* todo */ sl_header->slh_sublayouts_nr);
+		C2_ASSERT(rc == 0); //todo Handle error
 	} else {
 		/*
 		 * Read all the sub-layouts from the layout DB and store them
 		 * in the sub_layouts list.
 		 */
-		rc = sublayouts_read(cl, sub_layouts, &nr, tx);
-		C2_ASSERT(rc == 0); //todo Handle err
+		//rc = sublayouts_read(cl, sub_layouts, &nr, tx);
+		//C2_ASSERT(rc == 0); //todo Handle err
+		C2_ASSERT(0);
 	}
 
-	composite_populate(cl, sub_layouts, nr, user_count);
+	composite_populate(cl, /* sub_layouts, nr, */ user_count);
 	rc = 0; //todo
 	C2_POST(ergo(rc == 0, composite_invariant(cl)));
 	C2_POST(ergo(rc != 0, composite_allocated_invariant(cl)));
@@ -547,6 +579,7 @@ static int composite_decode(struct c2_layout *l,
 	return rc;
 }
 
+#if 0
 static int sublayouts_write(struct c2_layout *l,
 			    struct c2_composite_layout *cl,
 			    enum c2_layout_xcode_op op,
@@ -637,6 +670,7 @@ static int sublayouts_write(struct c2_layout *l,
 
 	return rc;
 }
+#endif
 
 /** Implementation of lo_encode() for composite layout type. */
 static int composite_encode(struct c2_layout *l,
@@ -649,6 +683,8 @@ static int composite_encode(struct c2_layout *l,
 	struct sub_layouts_header       sl_header;
 	struct sub_layout_entry         sl_entry;
 	uint32_t                        sublayouts_nr;//todo since in invar
+	struct c2_sub_layout_extent    *sl_ext;
+	struct c2_ext                   ext;
 	c2_bcount_t                     nbytes;
 	int                             rc;
 
@@ -663,31 +699,36 @@ static int composite_encode(struct c2_layout *l,
 	cl = c2_layout_to_cl(l);
 	if (op == C2_LXO_BUFFER_OP) {
 		C2_ASSERT(c2_bufvec_cursor_step(out) >= sizeof sl_header);
-		sl_header.slh_nr = cl->cl_nr;
+		sl_header.slh_sublayouts_nr = cl->cl_sublayouts_nr;
 		nbytes = c2_bufvec_cursor_copyto(out, &sl_header,
 						 sizeof sl_header);
 		C2_ASSERT(nbytes == sizeof sl_header);
-		C2_ASSERT(c2_bufvec_cursor_step(out) >= cl->cl_nr *
+		C2_ASSERT(c2_bufvec_cursor_step(out) >= cl->cl_sublayouts_nr *
 							sizeof sl_entry);
 		sublayouts_nr = 0;
 		c2_tl_for(c2_sub_layout, cl->cl_sub_layouts, sl) {
-			sl_entry.sle_lid         = sl->csl_l->l_id;
-			sl_entry.sle_ext.e_start = sl->csl_ext.e_start;
-			sl_entry.sle_ext.e_end   = sl->csl_ext.e_end;
+			sl_entry.sle_lid        = sl->csl_l->l_id;
+			sl_entry.sle_extents_nr = sl->csl_extents_nr;
 			nbytes = c2_bufvec_cursor_copyto(out, &sl_entry,
 							 sizeof sl_entry);
-			C2_ASSERT(nbytes == sizeof sl_entry);
-
+			c2_tl_for(c2_layout_extent, sl->csl_extents, sl_ext) {
+				ext = sl_ext->sle_ext;
+				nbytes = c2_bufvec_cursor_copyto(out, &ext,
+								 sizeof ext);
+				C2_ASSERT(nbytes == sizeof sl_entry);
+			} c2_tl_endfor;
+			//todo Verify number of extents.
 			++sublayouts_nr;
 		} c2_tl_endfor;
-		C2_ASSERT(sublayouts_nr == cl->cl_nr);
+		C2_ASSERT(sublayouts_nr == cl->cl_sublayouts_nr);
 		rc = 0;
 	} else if (op == C2_LXO_DB_UPDATE) {
 		/* todo */
 		rc = 0;
 	} else if (op == C2_LXO_DB_ADD || op == C2_LXO_DB_DELETE) {
-		rc = sublayouts_write(l, cl, op, tx);
-		C2_ASSERT(rc == 0 || rc == -EEXIST); //todo Handle err
+		//todo rc = sublayouts_write(l, cl, op, tx);
+		//C2_ASSERT(rc == 0 || rc == -EEXIST); //todo Handle err
+		C2_ASSERT(0);
 	}
 
 	C2_LEAVE("lid %llu, rc %d", (unsigned long long)l->l_id, rc);
diff --git a/layout/composite.h b/layout/composite.h
index 387aa25..be292ff 100644
--- a/layout/composite.h
+++ b/layout/composite.h
@@ -49,7 +49,7 @@ struct c2_composite_layout {
 	struct c2_layout  cl_base;
 
 	/* Number of sub-layouts in this composite layout. */
-	uint32_t          cl_nr;
+	uint32_t          cl_sublayouts_nr;
 
 	/**
 	 * List of of sub-layouts (struct c2_composite_sub_layout) owned by
@@ -64,17 +64,22 @@ struct c2_composite_layout {
  * todo
  */
 struct c2_composite_sub_layout {
-	/** Layout for a specific segment pointed by csl_extent. */
+	/** Layout this sub-layout is part of. todo Check if req'd */
 	struct c2_layout *csl_l;
 
-	/** Segment of an object todo */
-	/*
-	 * todo Shall struct c2_indexvec be used in struct c2_composite_layout
-	 * instead to store segement info for all the sub-layouts?
+	/** Number of extents in this sub-layout. todo Check if req'd */
+	uint32_t          csl_extents_nr;
+
+	/**
+	 * List of extents (struct c2_sub_layout_extent) owned by this
+	 * sub-layout.
 	 */
-	struct c2_ext     csl_ext;
+	struct c2_tl     *csl_extents;
 
-	/** Magic number todo. */
+	/**
+	 * Magic number set while c2_composite_sub_layout object is
+	 * initialised.
+	 */
 	uint64_t          csl_magic;
 
 	/**
@@ -84,16 +89,34 @@ struct c2_composite_sub_layout {
 	struct c2_tlink   csl_list_linkage;
 };
 
+struct c2_sub_layout_extent {
+	/** Extent being represented. */
+	struct c2_ext                   sle_ext;
+
+	/**
+	 * Magic number set while c2_sub_layout_extent object is
+	 * initialised.
+	 */
+	uint64_t                        sle_magic;
+
+	/**
+	 * Linkage used for maintaining list of the extents owned by a
+	 * particular sub-layout.
+	 */
+	struct c2_tlink                 sle_list_linkage;
+};
+
 C2_TL_DECLARE(c2_sub_layout, extern, struct c2_composite_sub_layout);
+C2_TL_DECLARE(c2_layout_extent, extern, struct c2_sub_layout_extent);
 
-/**
+/** todo Update...
  * Allocates and builds a layout object with the composite layout type,
  * by setting its intial ref count to 1.
  * @post ergo(rc == 0, pdclust_invariant(*out))
  * @post ergo(rc == 0, c2_ref_read(l->l_ref) == 1)
  *
  * @param sub_layouts This is a list of sublayouts spanning over namespace
- * of all the 64-bit unsigned numbers from 0 to C2_BINDEX_MAX.
+ * of all the 64-bit unsigned numbers from 0 to C2_BINDEX_MAX. todo
  *
  * @note The layout object built by this API is to be finalised by releasing
  * 'the reference on it that has been held during its creation'.
@@ -104,44 +127,53 @@ C2_TL_DECLARE(c2_sub_layout, extern, struct c2_composite_sub_layout);
  */
 int c2_composite_build(struct c2_layout_domain *dom,
 		       uint64_t lid,
-		       struct c2_tl *sub_layouts,
 		       struct c2_composite_layout **out);
 
+/**
+ * todo
+ */
+int c2_composite_layer_add(struct c2_composite_layout *cl,
+			   struct c2_layout *l,
+			   struct c2_tl *extlist,
+			   uint32_t ext_nr);
+
 struct c2_composite_layout *c2_layout_to_cl(const struct c2_layout *l);
 struct c2_layout *c2_cl_to_layout(struct c2_composite_layout *cl);
 
 extern struct c2_layout_type c2_composite_layout_type;
 
 /**
- * Following structure is part of the internal implementation. It is required
+ * Following structure is a part of the internal implementation. It is required
  * to be accessed by the UT as well. Hence, is placed here in the header file.
  *
- * Structure used to store number of sub-layouts.
- * @todo Do we want this number to be bound ?
+ * Structure used to store number of sub-layouts in a buffer.
  *
  * @note This structure needs to be maintained as 8 bytes aligned.
  * todo BASSERT
  */
 struct sub_layouts_header {
 	/** Total number of sub-layouts in a specific composite layout. */
-	uint32_t slh_nr;
+	uint32_t slh_sublayouts_nr;
 
 	/** Padding to make the structure 8 bytes aligned. */
 	uint32_t slh_pad;
 };
 
 /**
- * Following structure is part of the internal implementation. It is required
+ * Following structure is a part of the internal implementation. It is required
  * to be accessed by the UT as well. Hence, is placed here in the header file.
  *
- * todo
+ * Structure used to store information about sub-layouts in a buffer.
+ *
+ * @note This structure needs to be maintained as 8 bytes aligned.
+ * todo BASSERT
  */
 struct sub_layout_entry {
 	/** Layout id for the sub-layout. */
 	uint64_t       sle_lid;
 
-	/** Extent describing the segment the sub-layout is for. */
-	struct c2_ext  sle_ext;
+	/** Number of extents belonging to this sub-layout. */
+	uint32_t       sle_extents_nr;
 };
 
 /** @} end group composite */
diff --git a/layout/layout.c b/layout/layout.c
index e89e311..28ec47f 100644
--- a/layout/layout.c
+++ b/layout/layout.c
@@ -320,7 +320,7 @@ struct c2_layout *c2_layout__list_lookup(const struct c2_layout_domain *dom,
 	return l;
 }
 
-/* Used for assertions. */
+/** This function is used for assertions. */
 static struct c2_layout *list_lookup(struct c2_layout_domain *dom,
 				     uint64_t lid)
 {
diff --git a/layout/ut/Makefile.sub b/layout/ut/Makefile.sub
index 38a6d6e..006134f 100644
--- a/layout/ut/Makefile.sub
+++ b/layout/ut/Makefile.sub
@@ -1,3 +1,5 @@
-ut_libcolibri_ut_la_SOURCES += layout/ut/layout.c
+ut_libcolibri_ut_la_SOURCES += layout/ut/layout.c \
+                               layout/ut/layout.h \
+                               layout/ut/composite.c
 
-EXTRA_DIST += layout/ut/ldemo_internal.c
+EXTRA_DIST += layout/ut/layout.h layout/ut/ldemo_internal.c
diff --git a/layout/ut/composite.c b/layout/ut/composite.c
new file mode 100644
index 0000000..a1202f5
--- /dev/null
+++ b/layout/ut/composite.c
@@ -0,0 +1,821 @@
+/* -*- C -*- */
+/*
+ * COPYRIGHT 2012 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: Trupti Patil <trupti_patil@xyratex.com>
+ * Original creation date: 11/05/2012
+ */
+
+#define C2_TRACE_SUBSYSTEM C2_TRACE_SUBSYS_LAYOUT
+#include "lib/trace.h"              /* C2_LOG */
+#include "lib/ut.h"                 /* C2_UT_ASSERT() */
+
+#include "layout/layout.h"
+#include "layout/layout_internal.h" /* LDB_MAX_INLINE_COB_ENTRIES, *_ERR */
+#include "layout/layout_db.h"
+#include "layout/pdclust.h"         /* c2_pdl_to_layout() */
+#include "layout/composite.h"
+#include "layout/ut/layout.h"
+
+C2_TL_DESCR_DECLARE(c2_sub_layout, extern);
+C2_TL_DESCR_DECLARE(c2_layout_extent, extern);
+static int rc;
+
+static void sublayout_build(uint64_t lid, struct c2_layout **sub_layout)
+{
+	bool                          inline_test;
+	uint32_t                      enum_id;
+	uint32_t                      N;
+	uint32_t                      K;
+	uint32_t                      P;
+	struct c2_pdclust_layout     *pl;
+	struct c2_layout_list_enum   *list_enum;
+	struct c2_layout_linear_enum *lin_enum;
+	struct c2_uint128             seed;
+
+	c2_uint128_init(&seed, "sub_layouts_buil");
+	enum_id = lid % 2 ? LIST_ENUM_ID : LINEAR_ENUM_ID;
+	inline_test = lid % 5 ? LESS_THAN_INLINE : MORE_THAN_INLINE;
+	NKP_assign(enum_id, inline_test, 9, 109, 1200, &N, &K, &P);
+	rc = pdclust_layout_build(enum_id, lid,
+				  N, K, P, &seed,
+				  10, 20,
+				  &pl, &list_enum, &lin_enum,
+				  false);
+	C2_UT_ASSERT(rc == 0);
+	*sub_layout = c2_pdl_to_layout(pl);
+}
+
+static void extentlist_build(uint64_t sublayout_lid, //todo not req'd ?
+			     struct c2_tl **extlist,
+			     uint32_t extents_nr,
+			     c2_bindex_t min_offset,
+			     c2_bindex_t max_offset,
+			     bool if_contiguous_extents)
+{
+	struct c2_tl                *extents;
+	struct c2_sub_layout_extent *sl_ext;
+	c2_bindex_t                  delta;
+	c2_bindex_t                  multiplier;
+	uint32_t                     i;
+
+	/* Initialise a c2_tl for storing the extents. */
+	C2_ALLOC_PTR(extents);
+	C2_UT_ASSERT(extents != NULL);
+	c2_layout_extent_tlist_init(extents);
+	C2_UT_ASSERT(c2_layout_extent_tlist_is_empty(extents));
+
+	multiplier = if_contiguous_extents ? 1 : 2;
+	delta = (max_offset - min_offset + 1) / (extents_nr * multiplier);
+#ifndef __KERNEL__
+		printf("extents_nr %lu, min_offset %llu, max_offset %llu \n",
+			(unsigned long)extents_nr,
+			(unsigned long long)min_offset,
+			(unsigned long long)max_offset);
+#endif
+	for (i = 0; i < extents_nr; ++i) {
+		C2_ALLOC_PTR(sl_ext);
+		C2_UT_ASSERT(sl_ext != NULL);
+		sl_ext->sle_ext.e_start = min_offset +
+					  (multiplier * i * delta);
+		sl_ext->sle_ext.e_end = sl_ext->sle_ext.e_start + delta - 1;
+#ifndef __KERNEL__
+		printf("ext[%u]: start %llu, end %llu \n", i,
+			(unsigned long long)sl_ext->sle_ext.e_start,
+			(unsigned long long)sl_ext->sle_ext.e_end);
+#endif
+		c2_layout_extent_tlink_init_at_tail(sl_ext, extents);
+	}
+	*extlist = extents;
+	C2_UT_ASSERT(!c2_layout_extent_tlist_is_empty(*extlist));
+}
+
+static void composite_layout_verify(struct c2_layout *l,
+				    uint64_t composite_lid,
+				    uint32_t num_sublayouts,
+				    uint32_t extents_nr,
+				    bool if_contiguous_extents)
+{
+	bool                            inline_test;
+	uint64_t                        sublayout_lid;
+	struct c2_composite_layout     *cl;
+	struct c2_composite_sub_layout *sl;
+	struct c2_uint128               seed;
+	uint32_t                        enum_id;
+	uint32_t                        N;
+	uint32_t                        K;
+	uint32_t                        P;
+	c2_bindex_t			delta;
+	c2_bindex_t                     multiplier;
+	struct c2_sub_layout_extent    *sl_ext;
+	c2_bindex_t                     min_offset;
+	c2_bindex_t                     max_offset;
+	uint32_t                        i;
+	uint32_t                        j;
+
+	C2_UT_ASSERT(l != NULL);
+	C2_UT_ASSERT(l->l_type == &c2_composite_layout_type);
+
+	cl = c2_layout_to_cl(l);
+	l_verify(l, composite_lid, !USER_COUNT_INCREMENTED);
+
+	c2_uint128_init(&seed, "sub_layouts_buil");
+	multiplier = if_contiguous_extents ? 1 : 2;
+
+	i = 0;
+        c2_tl_for(c2_sub_layout, cl->cl_sub_layouts, sl) {
+		/* Verify the sub-layout. */
+		sublayout_lid = composite_lid * 100 + i;
+		enum_id = sublayout_lid % 2 ? LIST_ENUM_ID : LINEAR_ENUM_ID;
+		inline_test = sublayout_lid % 5 ? LESS_THAN_INLINE :
+						  MORE_THAN_INLINE;
+		NKP_assign(enum_id, inline_test, 9, 109, 1200, &N, &K, &P);
+		pdclust_layout_verify(enum_id, sl->csl_l, sublayout_lid,
+				      N, K, P, &seed, 10, 20,
+				      USER_COUNT_INCREMENTED);
+		C2_UT_ASSERT(sl->csl_l->l_user_count == 1);
+
+		/* Verify sl->csl_ext. */
+		j = 0;
+		min_offset = sublayout_lid;
+		max_offset = min_offset * 100;
+		delta = (max_offset - min_offset + 1) /
+			(extents_nr * multiplier);
+		c2_tl_for(c2_layout_extent, sl->csl_extents, sl_ext) {
+			C2_UT_ASSERT(sl_ext->sle_ext.e_start == min_offset +
+						(multiplier * j * delta));
+			C2_UT_ASSERT(sl_ext->sle_ext.e_end ==
+				     sl_ext->sle_ext.e_start + delta - 1);
+			++j;
+		} c2_tl_endfor;
+		C2_UT_ASSERT(j == extents_nr); 
+		++i;
+        } c2_tl_endfor;
+	C2_UT_ASSERT(i == num_sublayouts);
+}
+
+/*
+ * Builds a layout object with COMPOSITE layout type and adds sub-layouts
+ * to it.
+ */
+int composite_layout_build(uint64_t lid,
+			   struct c2_layout_domain *domain,
+			   struct c2_composite_layout **cl,
+			   uint32_t num_sublayouts,
+			   bool failure_test)
+{
+	struct c2_layout *sl;
+	struct c2_layout *l_from_cl;
+	uint64_t          sublayout_lid;
+	struct c2_tl     *extents;
+	uint32_t          extents_nr;
+	uint32_t          i;
+
+	C2_UT_ASSERT(cl != NULL);
+
+	/* Build a composite layout. */
+	rc = c2_composite_build(domain, lid, cl);
+	if (failure_test) {
+		C2_UT_ASSERT(rc == -ENOMEM);
+		return rc;
+	}
+	C2_UT_ASSERT(rc == 0);
+
+	/* Verify c2_cl_to_layout(). */
+	l_from_cl = c2_cl_to_layout(*cl);
+	C2_UT_ASSERT(l_from_cl == &(*cl)->cl_base);
+
+	/* Verify the composite layout object contents. */
+	composite_layout_verify(l_from_cl, lid, 0, 0, CONTIGUOUS_EXTENTS);
+
+	/* Add sub-layouts. */
+	for (i = 0; i < num_sublayouts; ++i) {
+		sublayout_lid = lid * 100 + i;
+		/* Build a layout to be used as a sub-layout. */
+		sublayout_build(lid * 100 + i, &sl); /* lid * 100 + i */
+
+		/* Build extent list to be owned by the sub-layout. */
+		extents_nr = 100;
+		extentlist_build(sublayout_lid, &extents, extents_nr,
+				 sublayout_lid, sublayout_lid * 100,
+				 CONTIGUOUS_EXTENTS);
+		//todo min_offset and max_offset (extents_nr and if_cont_ext)
+		//shud be accepted as args to this fn
+		// so that they can be used to test the boundary conditions.
+
+		rc = c2_composite_layer_add(*cl, sl, extents, extents_nr);
+		C2_UT_ASSERT(rc == 0);
+
+		/*
+		 * Release reference on the sub-layout that was obtained
+		 * during its creation. c2_composite_layer_add() has now
+		 * acquired a reference on it.
+		 */
+		c2_layout_put(sl);
+
+		/* Verify the composite layout object contents. */
+		composite_layout_verify(l_from_cl, lid, i + 1, extents_nr,
+					CONTIGUOUS_EXTENTS);
+	}
+	return rc;
+}
+
+/*
+ * Tests the APIs supported for layout object build and layout destruction
+ * that happens using c2_layout_put(). Verifies that the newly built layout
+ * object is added to the list of layout objects maintained in the domain
+ * object and that c2_layout_find() returns the same object.
+ */
+int test_build_composite(uint64_t lid,
+			 struct c2_layout_domain *domain,
+			 bool failure_test)
+{
+	struct c2_composite_layout *cl;
+	struct c2_layout           *l;
+
+	rc = composite_layout_build(lid, domain, &cl, 5, failure_test);
+	if (failure_test)
+		C2_UT_ASSERT(rc == -ENOMEM);
+	else {
+		C2_UT_ASSERT(rc == 0);
+		/*
+		 * Verify that c2_layout_find() returns the same object by
+		 * reading it from the memory.
+		 */
+		l = c2_layout_find(domain, lid);
+		C2_UT_ASSERT(l == &cl->cl_base);
+
+		/* Reduce the reference acquired by c2_layout_find(). */
+		c2_layout_put(&cl->cl_base);
+
+		/* Delete the composite layout object. */
+		c2_layout_put(&cl->cl_base);
+		C2_UT_ASSERT(c2_layout_find(domain, lid) == NULL);
+	}
+
+	return rc;
+}
+
+#if 0
+/* Builds a buffer containing serialised representation of a layout object. */
+static int composite_layout_buf_build(uint64_t lid,
+				      uint32_t num_sublayouts,
+				      c2_bindex_t end_offset,
+				      struct c2_bufvec_cursor *dcur)
+{
+	c2_bcount_t                     nbytes;
+	struct c2_tl                   *sub_layout_list;
+	struct c2_composite_sub_layout *sl;
+	struct sub_layouts_header       sl_header;
+	struct sub_layout_entry         sl_entry;
+
+	C2_UT_ASSERT(dcur != NULL);
+
+	/* Build part of the buffer representing generic part of the layout. */
+	buf_build(c2_composite_layout_type.lt_id, dcur);
+
+	/* Build sub-layouts. */
+	sub_layouts_build(lid, &sub_layout_list, num_sublayouts);
+
+	/*
+	 * Build part of the buffer representing composite type specific part
+	 * of the layout.
+	 */
+	sl_header.slh_sublayouts_nr = num_sublayouts;
+	C2_ASSERT(c2_bufvec_cursor_step(dcur) >= sizeof sl_header);
+	nbytes = c2_bufvec_cursor_copyto(dcur, &sl_header, sizeof sl_header);
+	C2_ASSERT(nbytes == sizeof sl_header);
+
+	C2_ASSERT(c2_bufvec_cursor_step(dcur) >= sl_header.slh_sublayouts_nr *
+						 sizeof sl_entry);
+	c2_tl_for(c2_sub_layout, sub_layout_list, sl) {
+		sl_entry.sle_lid         = sl->csl_l->l_id;
+		sl_entry.sle_ext.e_start = sl->csl_ext.e_start;
+		sl_entry.sle_ext.e_end   = sl->csl_ext.e_end;
+		nbytes = c2_bufvec_cursor_copyto(dcur, &sl_entry,
+						 sizeof sl_entry);
+		C2_ASSERT(nbytes == sizeof sl_entry);
+		c2_sub_layout_tlist_del(sl);
+		c2_sub_layout_tlink_fini(sl);
+		c2_free(sl);
+	} c2_tl_endfor;
+
+        c2_sub_layout_tlist_fini(sub_layout_list);
+        c2_free(sub_layout_list);
+	return 0;
+}
+#endif
+
+#if 0
+/* Tests the API c2_layout_decode() for COMPOSITE layout type. */
+static int test_decode_composite(uint64_t lid, bool failure_test)
+{
+	void                    *area;
+	c2_bcount_t              num_bytes;
+	struct c2_bufvec         bv;
+	struct c2_bufvec_cursor  cur;
+	struct c2_layout        *l;
+	struct c2_layout_type   *lt;
+	uint64_t                 sublayout_lid;
+	uint32_t                 i;
+
+	C2_ENTRY();
+
+	/* Build a layout buffer. */
+	allocate_area(&area, ADDITIONAL_BYTES_DEFAULT, &num_bytes);
+	bv = (struct c2_bufvec) C2_BUFVEC_INIT_BUF(&area, &num_bytes);
+	c2_bufvec_cursor_init(&cur, &bv);
+
+	rc = composite_layout_buf_build(lid, 60, 6000, &cur);
+	C2_UT_ASSERT(rc == 0);
+
+	/* Rewind the cursor. */
+	c2_bufvec_cursor_init(&cur, &bv);
+
+	lt = &c2_composite_layout_type;
+	rc = lt->lt_ops->lto_allocate(&domain, lid, &l);
+	C2_UT_ASSERT(rc == 0);
+
+	/* Decode the layout buffer into a layout object. */
+	rc = c2_layout_decode(l, &cur, C2_LXO_BUFFER_OP, NULL);
+	if (failure_test)
+		C2_UT_ASSERT(rc == -ENOMEM);
+	else {
+		C2_UT_ASSERT(rc == 0);
+		C2_UT_ASSERT(list_lookup(lid) == l);
+#if 0
+		/* Verify the layout object built by c2_layout_decode(). */
+		composite_layout_verify(l, lid, 6);
+#endif
+	}
+
+	/* Destroy the layout object. */
+	if (failure_test)
+		l->l_ops->lo_delete(l);
+	else {
+		/* Unlock the layout, locked by lto_allocate() */
+		c2_mutex_unlock(&l->l_lock);
+		/* Delete the composite layout object. */
+		c2_layout_put(l);
+	}
+	C2_UT_ASSERT(list_lookup(lid) == NULL);
+
+	/* Delete all the sub-layouts. */
+	for (i = 0; i < 60; ++i) {
+		sublayout_lid = lid * 100 + i;
+		l = c2_layout_find(&domain, sublayout_lid);
+		c2_layout_put(l);
+		c2_layout_put(l);
+	}
+
+	c2_free(area);
+	C2_LEAVE();
+	return rc;
+}
+#endif
+
+/* Tests the API c2_layout_encode() for COMPOSITE layout type. */
+int test_encode_composite(uint64_t lid,
+			  struct c2_layout_domain *domain,
+			  bool failure_test)
+{
+	struct c2_composite_layout   *cl;
+	void                         *area;
+	c2_bcount_t                   num_bytes;
+	struct c2_bufvec              bv;
+	struct c2_bufvec_cursor       cur;
+	C2_ENTRY("lid %llu", (unsigned long long)lid);
+
+	/* Build a layout object. */
+	rc = composite_layout_build(lid, domain, &cl, 12, failure_test);
+	if (failure_test)
+		C2_UT_ASSERT(rc == -ENOMEM);
+	else
+		C2_UT_ASSERT(rc == 0);
+
+	/* Encode the layout object into a layout buffer. */
+	allocate_area(&area, ADDITIONAL_BYTES_DEFAULT * 10, &num_bytes);
+	bv = (struct c2_bufvec) C2_BUFVEC_INIT_BUF(&area, &num_bytes);
+	c2_bufvec_cursor_init(&cur, &bv);
+
+	c2_mutex_lock(&cl->cl_base.l_lock);
+	rc = c2_layout_encode(&cl->cl_base, C2_LXO_BUFFER_OP, NULL, &cur);
+	c2_mutex_unlock(&cl->cl_base.l_lock);
+	if (failure_test)
+		C2_UT_ASSERT(rc == LO_ENCODE_ERR);
+	else
+		C2_UT_ASSERT(rc == 0);
+
+	/* Rewind the cursor. */
+	c2_bufvec_cursor_init(&cur, &bv);
+
+#if 0
+	/* todo Verify the layout buffer produced by c2_layout_encode(). */
+	if (!failure_test)
+		composite_layout_buf_verify(lid, sublayouts_nr, &cur);
+#endif
+
+	/* Delete the composite layout object. */
+	c2_layout_put(&cl->cl_base);
+	C2_UT_ASSERT(c2_layout_find(domain, lid) == NULL);
+
+	c2_free(area);
+	C2_LEAVE();
+	return rc;
+}
+
+#if 0 //todo Tune it for composite
+/* Copies contents of one layout object to the other. */
+static void pdclust_layout_copy(uint32_t enum_id,
+				const struct c2_layout *l_src,
+				struct c2_layout **l_dest)
+{
+	struct c2_pdclust_layout     *pl_src;
+	struct c2_pdclust_layout     *pl_dest;
+	struct c2_layout_list_enum   *list_src;
+	struct c2_layout_list_enum   *list_dest;
+	struct c2_layout_linear_enum *lin_src;
+	struct c2_layout_linear_enum *lin_dest;
+	uint32_t                      i;
+
+	C2_UT_ASSERT(l_src != NULL && l_dest != NULL);
+	C2_UT_ASSERT(enum_id == LIST_ENUM_ID || enum_id == LINEAR_ENUM_ID);
+
+	pl_src = container_of(l_src, struct c2_pdclust_layout, pl_base.sl_base);
+	pl_dest = c2_alloc(sizeof *pl_src);
+	C2_UT_ASSERT(pl_dest != NULL);
+	*l_dest = &pl_dest->pl_base.sl_base;
+
+	/* Copy generic part of the layout object. */
+	(*l_dest)->l_id         = l_src->l_id;
+	(*l_dest)->l_type       = l_src->l_type;
+	(*l_dest)->l_dom        = l_src->l_dom;
+	(*l_dest)->l_user_count = l_src->l_user_count;
+	(*l_dest)->l_ops        = l_src->l_ops;
+	c2_ref_init(&(*l_dest)->l_ref, 1, l_src->l_ops->lo_fini);
+
+	/* Copy PDCLUST layout type specific part of the layout objects. */
+	pl_dest->pl_attr = pl_src->pl_attr;
+
+	/* Copy enumeration type specific part of the layout objects. */
+	if (enum_id == LIST_ENUM_ID) {
+		list_src = container_of(pl_src->pl_base.sl_enum,
+					struct c2_layout_list_enum, lle_base);
+		list_dest = c2_alloc(sizeof *list_src);
+		C2_UT_ASSERT(list_src != NULL);
+
+		list_dest->lle_nr = list_src->lle_nr;
+		C2_ALLOC_ARR(list_dest->lle_list_of_cobs, list_dest->lle_nr);
+
+		for (i = 0; i < list_src->lle_nr; ++i)
+			list_dest->lle_list_of_cobs[i] =
+					       list_src->lle_list_of_cobs[i];
+
+		pl_dest->pl_base.sl_enum = &list_dest->lle_base;
+	} else { /* LINEAR_ENUM_ID */
+		lin_src = container_of(pl_src->pl_base.sl_enum,
+				       struct c2_layout_linear_enum, lle_base);
+		lin_dest = c2_alloc(sizeof *lin_src);
+		C2_UT_ASSERT(lin_src != NULL);
+
+		lin_dest->lle_attr = lin_src->lle_attr;
+		pl_dest->pl_base.sl_enum = &lin_dest->lle_base;
+	}
+
+	/* Copy enumeration specific part of the layout objects. */
+	pl_dest->pl_base.sl_enum->le_type = pl_src->pl_base.sl_enum->le_type;
+	pl_dest->pl_base.sl_enum->le_ops = pl_src->pl_base.sl_enum->le_ops;
+	pl_dest->pl_base.sl_enum->le_sl = &pl_dest->pl_base;
+
+	pdclust_layout_compare(enum_id, &pl_src->pl_base.sl_base,
+			       &pl_dest->pl_base.sl_base, false);
+}
+
+static void pdclust_layout_copy_delete(uint32_t enum_id, struct c2_layout *l)
+{
+	struct c2_pdclust_layout     *pl;
+	struct c2_layout_list_enum   *list_enum;
+	struct c2_layout_linear_enum *lin_enum;
+
+	C2_UT_ASSERT(l != NULL);
+	C2_UT_ASSERT(enum_id == LIST_ENUM_ID || enum_id == LINEAR_ENUM_ID);
+
+	pl = container_of(l, struct c2_pdclust_layout, pl_base.sl_base);
+	if (enum_id == LIST_ENUM_ID) {
+		list_enum = container_of(pl->pl_base.sl_enum,
+					struct c2_layout_list_enum, lle_base);
+		c2_free(list_enum->lle_list_of_cobs);
+		c2_free(list_enum);
+	} else { /* LINEAR_ENUM_ID */
+		lin_enum = container_of(pl->pl_base.sl_enum,
+				        struct c2_layout_linear_enum, lle_base);
+		c2_free(lin_enum);
+	}
+
+	c2_free(pl);
+}
+#endif
+
+#ifndef __KERNEL__
+#if 0
+static int test_add_composite(uint64_t lid,
+			      bool layout_destroy, struct c2_layout **l_obj,
+			      bool duplicate_test,
+			      bool failure_test);
+/* Tests the API c2_layout_lookup(), for the COMPOSITE layout type. */
+static int test_lookup_composite(uint64_t lid,
+				 bool existing_test,
+				 bool failure_test)
+{
+	c2_bcount_t        num_bytes;
+	void              *area;
+	struct c2_layout  *l1;
+	//todo struct c2_layout  *l1_copy;
+	struct c2_layout  *l2;
+	struct c2_layout  *l3;
+	struct c2_db_pair  pair;
+	struct c2_db_tx    tx;
+	uint32_t           i; //todo rm
+	uint64_t           sublayout_lid; //todo rm
+	struct c2_layout  *l; //todo rm
+	int                rc_tmp;
+
+	C2_ENTRY();
+	C2_UT_ASSERT(ergo(!existing_test, failure_test));
+
+	/*
+	 * If existing_test is true, then first add a layout object to the
+	 * DB.
+	 */
+	if (existing_test) {
+		rc = test_add_composite(lid,
+					!LAYOUT_DESTROY, &l1,
+					!DUPLICATE_TEST,
+					!FAILURE_TEST);
+		C2_UT_ASSERT(rc == 0);
+
+#if 0 //todo
+		if (!failure_test)
+			composite_layout_copy(enum_id, l1, &l1_copy);
+#endif
+
+		/*
+		 * Lookup for the layout object to verify that the same object
+		 * is returned from the memory, not requiring a lookup from the
+		 * DB.
+		 */
+		rc = c2_layout_lookup(&domain, lid, &c2_composite_layout_type,
+				      &tx, &pair, &l2);
+		C2_UT_ASSERT(rc == 0);
+		C2_UT_ASSERT(l2 == l1);
+
+		/* Release the reference acquired by c2_layout_lookup(). */
+		c2_layout_put(l1);
+
+		/* Destroy the layout object. */
+		c2_layout_put(l1);
+	}
+
+	C2_UT_ASSERT(list_lookup(lid) == NULL);
+
+	/* Lookup for the layout object from the DB. */
+	allocate_area(&area, ADDITIONAL_BYTES_NONE, &num_bytes);
+
+	rc = c2_db_tx_init(&tx, &dbenv, DBFLAGS);
+	C2_UT_ASSERT(rc == 0);
+
+	pair_set(&pair, &lid, area, num_bytes);
+
+	rc = c2_layout_lookup(&domain, lid, &c2_composite_layout_type,
+			      &tx, &pair, &l3);
+	if (failure_test)
+		C2_UT_ASSERT(rc == -ENOENT || rc == -ENOMEM || rc == -EPROTO ||
+			     rc == LO_DECODE_ERR);
+	else
+		C2_UT_ASSERT(rc == 0);
+
+	rc_tmp = c2_db_tx_commit(&tx);
+	C2_UT_ASSERT(rc_tmp == 0);
+
+	if (existing_test && !failure_test) {
+		C2_UT_ASSERT(list_lookup(lid) == l3);
+		//todo composite_layout_compare(enum_id, l1_copy, l3, false);
+		//todo composite_layout_copy_delete(enum_id, l1_copy);
+
+		/* Destroy the layout object. */
+		c2_layout_put(l3);
+		C2_UT_ASSERT(list_lookup(lid) == NULL);
+
+		/* Delete all the sub-layouts. */
+		for (i = 0; i < 10; ++i) {
+			sublayout_lid = lid * 100 + i;
+			l = c2_layout_find(&domain, sublayout_lid);
+			C2_UT_ASSERT(l->l_user_count == 0);
+			c2_layout_put(l);
+			c2_layout_put(l);
+		}
+	}
+	c2_free(area);
+	C2_LEAVE();
+	return rc;
+}
+#endif
+
+#if 0
+/* Tests the API c2_layout_add(), for the COMPOSITE layout type. */
+//todo Make this accept num_sublayouts
+static int test_add_composite(uint64_t lid,
+			      bool layout_destroy, struct c2_layout **l_obj,
+			      bool duplicate_test,
+			      bool failure_test)
+{
+	c2_bcount_t                   num_bytes;
+	void                         *area;
+	struct c2_composite_layout   *cl;
+	struct c2_db_pair             pair;
+	struct c2_db_tx               tx;
+	struct c2_layout             *l;
+	uint64_t                      sublayout_lid;
+	uint32_t                      i;
+	int                           rc_tmp;
+
+	C2_ENTRY("lid %llu", (unsigned long long)lid);
+	C2_UT_ASSERT(ergo(layout_destroy, l_obj == NULL));
+	C2_UT_ASSERT(ergo(!layout_destroy, l_obj != NULL));
+	C2_UT_ASSERT(ergo(duplicate_test, !failure_test));
+
+	allocate_area(&area, ADDITIONAL_BYTES_NONE, &num_bytes);
+
+	/* Build a layout object. */
+	rc = composite_layout_build(lid, &cl, 10, failure_test);
+	C2_UT_ASSERT(rc == 0);
+
+	/* Add the layout object to the DB. */
+	rc = c2_db_tx_init(&tx, &dbenv, DBFLAGS);
+	C2_UT_ASSERT(rc == 0);
+
+	pair_set(&pair, &lid, area, num_bytes);
+
+	rc = c2_layout_add(&cl->cl_base, &tx, &pair);
+	if (failure_test)
+		C2_UT_ASSERT(rc == -ENOENT || rc == LO_ENCODE_ERR);
+		//todo check why -ENOENT err here n for pdclust
+	else
+		C2_UT_ASSERT(rc == 0);
+
+	rc_tmp = c2_db_tx_commit(&tx);
+	C2_UT_ASSERT(rc_tmp == 0);
+
+	C2_UT_ASSERT(list_lookup(lid) == &cl->cl_base);
+
+	/*
+	 * If duplicate_test is true, again try to add the same layout object
+	 * to the DB, to verify that it results into EEXIST error.
+	 */
+	if (duplicate_test) {
+		rc = c2_db_tx_init(&tx, &dbenv, DBFLAGS);
+		C2_UT_ASSERT(rc == 0);
+
+		pair_set(&pair, &lid, area, num_bytes);
+
+		rc = c2_layout_add(&cl->cl_base, &tx, &pair);
+		C2_UT_ASSERT(rc == -EEXIST);
+
+		rc_tmp = c2_db_tx_commit(&tx);
+		C2_UT_ASSERT(rc_tmp == 0);
+	}
+
+	if (layout_destroy) {
+		c2_layout_put(&cl->cl_base);
+		C2_UT_ASSERT(list_lookup(lid) == NULL);
+
+		/* Delete all the sub-layouts. */
+		for (i = 0; i < 10; ++i) {
+			sublayout_lid = lid * 100 + i;
+			l = c2_layout_find(&domain, sublayout_lid);
+			c2_layout_put(l);
+			c2_layout_put(l);
+		}
+	}
+	else
+		*l_obj = &cl->cl_base;
+
+	c2_free(area);
+	C2_LEAVE("lid %llu", (unsigned long long)lid);
+	return rc;
+}
+#endif
+
+#if 0
+/* Tests the API c2_layout_delete(), for the COMPOSITE layout type. */
+static int test_delete_composite(uint64_t lid,
+				 bool existing_test,
+				 uint32_t failure_test)
+{
+	c2_bcount_t                   num_bytes;
+	void                         *area;
+	struct c2_db_pair             pair;
+	struct c2_db_tx               tx;
+	struct c2_layout             *l;
+	struct c2_composite_layout   *cl;
+	uint32_t                      sublayout_lid;
+	uint32_t                      i;
+	int                           rc_tmp;
+
+	C2_ENTRY("lid %llu", (unsigned long long)lid);
+	allocate_area(&area, ADDITIONAL_BYTES_NONE, &num_bytes);
+
+	if (existing_test) {
+		/* Add a layout object to the DB. */
+		rc = test_add_composite(lid,
+					!LAYOUT_DESTROY, &l,
+					!DUPLICATE_TEST,
+					!FAILURE_TEST);
+		C2_UT_ASSERT(rc == 0);
+	} else {
+		/* Build a layout object. */
+		rc = composite_layout_build(lid, &cl, 10, !FAILURE_TEST);
+		C2_UT_ASSERT(rc == 0);
+		l = &cl->cl_base;
+	}
+
+	if (C2_FI_ENABLED("nonzero_user_count_err"))
+		c2_layout_user_count_inc(l);
+
+	/* Delete the layout object from the DB. */
+	pair_set(&pair, &lid, area, num_bytes);
+
+	rc = c2_db_tx_init(&tx, &dbenv, DBFLAGS);
+	C2_UT_ASSERT(rc == 0);
+
+	rc = c2_layout_delete(l, &tx, &pair);
+	if (failure_test)
+		C2_UT_ASSERT(rc == -ENOENT || rc == -ENOMEM ||
+			     rc == -EPROTO || rc == LO_ENCODE_ERR);
+	else
+		C2_UT_ASSERT(rc == 0);
+
+	rc_tmp = c2_db_tx_commit(&tx);
+	C2_UT_ASSERT(rc_tmp == 0);
+
+	/* Destroy the layout object. */
+	c2_layout_put(l);
+	C2_UT_ASSERT(list_lookup(lid) == NULL);
+
+	/* Delete all the sub-layouts. */
+	for (i = 0; i < 10; ++i) {
+		sublayout_lid = lid * 100 + i;
+		l = c2_layout_find(&domain, sublayout_lid);
+		C2_UT_ASSERT(l->l_user_count == 0);
+		c2_layout_put(l);
+		c2_layout_put(l);
+	}
+
+	if (!failure_test) {
+		/*
+		 * Lookup for the layout object from the DB, to verify that it
+		 * does not exist there and that the lookup results into
+		 * ENOENT error.
+		 */
+		rc = c2_db_tx_init(&tx, &dbenv, DBFLAGS);
+		C2_UT_ASSERT(rc == 0);
+
+		pair_set(&pair, &lid, area, num_bytes);
+
+		rc_tmp = c2_layout_lookup(&domain, lid,
+					  &c2_composite_layout_type,
+					  &tx, &pair, &l);
+		C2_UT_ASSERT(rc_tmp == -ENOENT);
+
+		rc_tmp = c2_db_tx_commit(&tx);
+		C2_UT_ASSERT(rc_tmp == 0);
+	}
+
+	c2_free(area);
+	C2_LEAVE();
+	return rc;
+}
+#endif
+#endif /* __KERNEL__ */
+
+/*
+ *  Local variables:
+ *  c-indentation-style: "K&R"
+ *  c-basic-offset: 8
+ *  tab-width: 8
+ *  fill-column: 80
+ *  scroll-step: 1
+ *  End:
+ */
diff --git a/layout/ut/layout.c b/layout/ut/layout.c
index 9d571f1..6b35fee 100644
--- a/layout/ut/layout.c
+++ b/layout/ut/layout.c
@@ -39,10 +39,11 @@
 #include "layout/layout_internal.h"      /* LDB_MAX_INLINE_COB_ENTRIES, *_ERR */
 #include "layout/layout_db.h"
 #include "layout/pdclust.h"
-#include "layout/composite.h"
+#include "layout/composite.h" //todo Check header inclusions
 #include "layout/list_enum.h"
 #include "layout/linear_enum.h"
 #include "layout/ut/ldemo_internal.c"    /* layout_demo() */
+#include "layout/ut/layout.h"
 
 static struct c2_dbenv         dbenv;
 static const char              db_name[] = "ut-layout";
@@ -50,31 +51,6 @@ static struct c2_layout_domain domain;
 enum c2_addb_ev_level          orig_addb_level;
 static int                     rc;
 
-C2_TL_DESCR_DECLARE(c2_sub_layout, extern);
-
-enum {
-	DBFLAGS                  = 0,    /* Flag used for dbenv and tx init */
-	LIST_ENUM_ID             = 0x4C495354, /* "LIST" */
-	LINEAR_ENUM_ID           = 0x4C494E45, /* "LINE" */
-	ADDITIONAL_BYTES_NONE    = 0,    /* For buffer initialisation */
-	ADDITIONAL_BYTES_DEFAULT = 2048, /* For buffer initialisation */
-	INLINE_NOT_APPLICABLE    = 0,    /* For list enumeration */
-	LESS_THAN_INLINE         = 1,    /* For list enumeration */
-	EXACT_INLINE             = 2,    /* For list enumeration */
-	MORE_THAN_INLINE         = 3,    /* For list enumeration */
-	EXISTING_TEST            = true, /* Add a layout to the DB */
-	DUPLICATE_TEST           = true, /* Try to re-add a layout */
-	FAILURE_TEST             = true, /* Failure injected */
-	LAYOUT_DESTROY           = true, /* Delete layout object */
-	UNIT_SIZE                = 4096, /* For pdclust layout type */
-	USER_COUNT_INCREMENTED   = true
-};
-
-extern struct c2_layout_type c2_pdclust_layout_type;
-extern struct c2_layout_type c2_composite_layout_type;
-extern struct c2_layout_enum_type c2_list_enum_type;
-extern struct c2_layout_enum_type c2_linear_enum_type;
-
 static int test_init(void)
 {
 	/*
@@ -526,15 +502,15 @@ static int pdclust_l_build(uint64_t lid, uint32_t N, uint32_t K, uint32_t P,
  * Builds a layout object with PDCLUST layout type, by first building an
  * enumeration object with the specified enumeration type.
  */
-static int pdclust_layout_build(uint32_t enum_id,
-				uint64_t lid,
-				uint32_t N, uint32_t K, uint32_t P,
-				struct c2_uint128 *seed,
-				uint32_t A, uint32_t B,
-				struct c2_pdclust_layout **pl,
-				struct c2_layout_list_enum **list_enum,
-				struct c2_layout_linear_enum **lin_enum,
-				bool failure_test)
+int pdclust_layout_build(uint32_t enum_id,
+			 uint64_t lid,
+			 uint32_t N, uint32_t K, uint32_t P,
+			 struct c2_uint128 *seed,
+			 uint32_t A, uint32_t B,
+			 struct c2_pdclust_layout **pl,
+			 struct c2_layout_list_enum **list_enum,
+			 struct c2_layout_linear_enum **lin_enum,
+			 bool failure_test)
 {
 	struct c2_fid                *cob_list = NULL; /* to keep gcc happy. */
 	int                           i;
@@ -603,9 +579,9 @@ static int pdclust_layout_build(uint32_t enum_id,
 }
 
 /* Verifies generic part of the layout object. */
-static void l_verify(struct c2_layout *l,
-		     uint64_t lid,
-		     bool if_user_count_incremented)
+void l_verify(struct c2_layout *l,
+	      uint64_t lid,
+	      bool if_user_count_incremented)
 {
 	C2_UT_ASSERT(l->l_id == lid);
 	C2_UT_ASSERT(c2_ref_read(&l->l_ref) >= 1);
@@ -637,12 +613,12 @@ static void pdclust_l_verify(struct c2_pdclust_layout *pl,
 }
 
 /* Verifies the layout object against the various input arguments. */
-static void pdclust_layout_verify(uint32_t enum_id,
-				  struct c2_layout *l, uint64_t lid,
-				  uint32_t N, uint32_t K, uint32_t P,
-				  struct c2_uint128 *seed,
-				  uint32_t A, uint32_t B,
-				  bool if_user_count_incremented)
+void pdclust_layout_verify(uint32_t enum_id,
+			   struct c2_layout *l, uint64_t lid,
+			   uint32_t N, uint32_t K, uint32_t P,
+			   struct c2_uint128 *seed,
+			   uint32_t A, uint32_t B,
+			   bool if_user_count_incremented)
 {
 	struct c2_pdclust_layout     *pl;
 	struct c2_layout_list_enum   *list_enum;
@@ -683,12 +659,12 @@ static void pdclust_layout_verify(uint32_t enum_id,
 	}
 }
 
-static void NKP_assign(uint32_t enum_id,
-		       uint32_t inline_test,
-		       uint32_t list_nr_less,
-		       uint32_t list_nr_more,
-		       uint32_t linear_nr,
-		       uint32_t *N, uint32_t *K, uint32_t *P)
+void NKP_assign(uint32_t enum_id,
+		uint32_t inline_test,
+		uint32_t list_nr_less,
+		uint32_t list_nr_more,
+		uint32_t linear_nr,
+		uint32_t *N, uint32_t *K, uint32_t *P)
 {
 	C2_UT_ASSERT(ergo(enum_id == LIST_ENUM_ID,
 			  list_nr_less < LDB_MAX_INLINE_COB_ENTRIES &&
@@ -793,219 +769,6 @@ static int test_build_pdclust(uint32_t enum_id, uint64_t lid,
 }
 
 /*
- * Builds num_sublayouts number of sub-layouts and stores those in
- * sub_layout_list.
- */
-static void sub_layouts_build(uint64_t composite_lid,
-			      struct c2_tl **sub_layout_list,
-			      uint32_t num_sublayouts)
-{
-	bool                            inline_test;
-	uint32_t                        sublayout_lid;
-	uint32_t                        enum_id;
-	uint32_t                        N;
-	uint32_t                        K;
-	uint32_t                        P;
-	struct c2_pdclust_layout       *pl;
-	struct c2_layout_list_enum     *list_enum;
-	struct c2_layout_linear_enum   *lin_enum;
-	struct c2_composite_sub_layout *sl;
-	struct c2_uint128               seed;
-	c2_bindex_t                     delta;
-	c2_bindex_t                     where;
-	c2_bindex_t                     total;
-	uint32_t                        i;
-
-	/* Initialise a c2_tl for storing the sub-layouts to be built. */
-	C2_ALLOC_PTR(*sub_layout_list);
-	C2_UT_ASSERT(*sub_layout_list != NULL);
-	c2_sub_layout_tlist_init(*sub_layout_list);
-	C2_UT_ASSERT(c2_sub_layout_tlist_is_empty(*sub_layout_list));
-
-	/*
-	 * The name-space of an extent map is 'a set of all the 64-bit
-	 * unsigned numbers from 0 to C2_BINDEX_MAX'. Let's spread that
-	 * namespace over the number of sub-layouts.
-	 */
-	c2_uint128_init(&seed, "sub_layouts_buil");
-	delta = C2_BINDEX_MAX / num_sublayouts;
-	where = 0;
-	total = 0;
-	for (i = 0; i < num_sublayouts; ++i) {
-		/* Build a sub-layout. */
-		sublayout_lid = composite_lid * 100 + i;
-		enum_id = i % 2 ? LIST_ENUM_ID : LINEAR_ENUM_ID;
-		inline_test = i % 5 ? LESS_THAN_INLINE : MORE_THAN_INLINE;
-		NKP_assign(enum_id, inline_test, 9, 109, 1200, &N, &K, &P);
-		rc = pdclust_layout_build(enum_id, sublayout_lid,
-					  N, K, P, &seed,
-					  10, 20,
-					  &pl, &list_enum, &lin_enum,
-					  false);
-		C2_UT_ASSERT(rc == 0);
-
-		/*
-		 * Add the sub-layout to the sub-layout-list by associating it
-		 * with a particular segment.
-		 */
-		C2_ALLOC_PTR(sl);
-		C2_UT_ASSERT(sl != NULL);
-		sl->csl_l           = c2_pdl_to_layout(pl);
-		sl->csl_ext.e_start = where;
-		sl->csl_ext.e_end   = sl->csl_ext.e_start + delta - 1;
-		total               = total + delta;
-		where               = sl->csl_ext.e_end + 1;
-		c2_sub_layout_tlink_init_at_tail(sl, *sub_layout_list);
-	}
-
-	/*
-	 * C2_BINDEX_MAX is not necessarily multiple of delta. Hence, adjust
-	 * the end offset for the last sub-layout.
-	 */
-	sl->csl_ext.e_end = C2_BINDEX_MAX;
-	total = total - delta + sl->csl_ext.e_end - sl->csl_ext.e_start;
-	C2_UT_ASSERT(total == C2_BINDEX_MAX);
-	C2_UT_ASSERT(!c2_sub_layout_tlist_is_empty(*sub_layout_list));
-}
-
-static void composite_layout_verify(struct c2_layout *l,
-				    uint64_t composite_lid,
-				    uint32_t num_sublayouts)
-{
-	bool                            inline_test;
-	uint64_t                        sublayout_lid;
-	struct c2_composite_layout     *cl;
-	struct c2_composite_sub_layout *sl;
-	struct c2_uint128               seed;
-	uint32_t                        enum_id;
-	uint32_t                        N;
-	uint32_t                        K;
-	uint32_t                        P;
-	uint32_t                        i;
-	c2_bindex_t                     delta = C2_BINDEX_MAX / num_sublayouts;
-	c2_bindex_t                     where;
-
-	C2_UT_ASSERT(l != NULL);
-	C2_UT_ASSERT(l->l_type == &c2_composite_layout_type);
-
-	cl = c2_layout_to_cl(l);
-	l_verify(l, composite_lid, !USER_COUNT_INCREMENTED);
-
-	c2_uint128_init(&seed, "sub_layouts_buil");
-	i = 0;
-	where = 0;
-        c2_tl_for(c2_sub_layout, cl->cl_sub_layouts, sl) {
-		/* Verify the sub-layout. */
-		sublayout_lid = composite_lid * 100 + i;
-		enum_id        = i % 2 ? LIST_ENUM_ID : LINEAR_ENUM_ID;
-		inline_test    = i % 5 ? LESS_THAN_INLINE : MORE_THAN_INLINE;
-		NKP_assign(enum_id, inline_test, 9, 109, 1200, &N, &K, &P);
-		pdclust_layout_verify(enum_id, sl->csl_l, sublayout_lid,
-				      N, K, P, &seed, 10, 20,
-				      USER_COUNT_INCREMENTED);
-		C2_UT_ASSERT(sl->csl_l->l_user_count == 1);
-
-		/* Verify sl->csl_ext. */
-		C2_UT_ASSERT(sl->csl_ext.e_start == where);
-		if (i == num_sublayouts - 1)
-			C2_UT_ASSERT(sl->csl_ext.e_end == C2_BINDEX_MAX);
-		else
-			C2_UT_ASSERT(sl->csl_ext.e_end == sl->csl_ext.e_start +
-							  delta - 1);
-		where = sl->csl_ext.e_end + 1;
-		++i;
-        } c2_tl_endfor;
-	C2_UT_ASSERT(i == num_sublayouts);
-}
-
-/*
- * Builds a layout object with COMPOSITE layout type, by first building some
- * sub-layouts.
- */
-static int composite_layout_build(uint64_t lid,
-				  struct c2_composite_layout **cl,
-				  uint32_t num_sublayouts,
-				  bool failure_test)
-{
-
-	struct c2_layout *l;
-	struct c2_layout *l_from_cl;
-	struct c2_tl     *sub_layout_list;
-
-	C2_UT_ASSERT(cl != NULL);
-
-	/* Build sub-layouts. */
-	sub_layouts_build(lid, &sub_layout_list, num_sublayouts);
-
-	/* Build composite layout. */
-	rc = c2_composite_build(&domain, lid, sub_layout_list, cl);
-	if (failure_test)
-		C2_UT_ASSERT(rc == -ENOMEM);
-	else {
-		C2_UT_ASSERT(rc == 0);
-
-		/*
-		 * Verify that c2_layout_find() returns the same object by
-		 * reading it from the memory.
-		 */
-		l = c2_layout_find(&domain, lid);
-		C2_UT_ASSERT(l == &(*cl)->cl_base);
-
-		/* Reduce the reference acquired by c2_layout_find(). */
-		c2_layout_put(&(*cl)->cl_base);
-
-		/* Verify c2_composite_to_layout(). */
-		l_from_cl = c2_cl_to_layout(*cl);
-		C2_UT_ASSERT(l_from_cl == &(*cl)->cl_base);
-
-		/* Verify the composite layout object contents. */
-		composite_layout_verify(l_from_cl, lid, num_sublayouts);
-	}
-
-	return rc;
-}
-
-/*
- * Tests the APIs supported for layout object build and layout destruction
- * that happens using c2_layout_put(). Verifies that the newly built layout
- * object is added to the list of layout objects maintained in the domain
- * object and that c2_layout_find() returns the same object.
- */
-static int test_build_composite(uint64_t lid,
-				bool failure_test)
-{
-	struct c2_composite_layout *cl;
-	struct c2_layout           *l;
-	uint32_t                    sublayout_lid;
-	uint32_t                    i;
-
-	rc = composite_layout_build(lid, &cl, 5, failure_test);
-	if (failure_test)
-		C2_UT_ASSERT(rc == -ENOMEM);
-	else {
-		C2_UT_ASSERT(rc == 0);
-
-		/*
-		 * Delete the composite layout object by reducing its last
-		 * reference.
-		 */
-		c2_layout_put(&cl->cl_base);
-		C2_UT_ASSERT(list_lookup(lid) == NULL);
-
-		/* Delete all the sub-layouts. */
-		for (i = 0; i < 5; ++i) {
-			sublayout_lid = lid * 100 + i;
-			l = c2_layout_find(&domain, sublayout_lid);
-			C2_UT_ASSERT(l->l_user_count == 0);
-			c2_layout_put(l);
-			c2_layout_put(l);
-		}
-	}
-
-	return rc;
-}
-
-/*
  * Tests the APIs supported for enumeration object build, layout object build
  * and layout destruction that happens using c2_layout_put().
  */
@@ -1052,7 +815,7 @@ static void test_build(void)
 
 	/* Build a layout object with COMPOSITE layout type and destroy it. */
 	lid = 1005;
-	rc = test_build_composite(lid, !FAILURE_TEST);
+	rc = test_build_composite(lid, &domain, !FAILURE_TEST);
 	C2_UT_ASSERT(rc == 0);
 }
 
@@ -1233,9 +996,9 @@ static int pdclust_layout_buf_build(uint32_t enum_id, uint64_t lid,
  * c2_layout_decode()' (and not while invoking Layout DB APIs like
  * c2_layout_add() etc).
  */
-static void allocate_area(void **area,
-			  c2_bcount_t additional_bytes,
-			  c2_bcount_t *num_bytes)
+void allocate_area(void **area,
+		   c2_bcount_t additional_bytes,
+		   c2_bcount_t *num_bytes)
 {
 	C2_UT_ASSERT(area != NULL);
 
@@ -1321,120 +1084,6 @@ static int test_decode_pdclust(uint32_t enum_id, uint64_t lid,
 	return rc;
 }
 
-/* Builds a buffer containing serialised representation of a layout object. */
-static int composite_layout_buf_build(uint64_t lid,
-				      uint32_t num_sublayouts,
-				      c2_bindex_t end_offset,
-				      struct c2_bufvec_cursor *dcur)
-{
-	c2_bcount_t                     nbytes;
-	struct c2_tl                   *sub_layout_list;
-	struct c2_composite_sub_layout *sl;
-	struct sub_layouts_header       sl_header;
-	struct sub_layout_entry         sl_entry;
-
-	C2_UT_ASSERT(dcur != NULL);
-
-	/* Build part of the buffer representing generic part of the layout. */
-	buf_build(c2_composite_layout_type.lt_id, dcur);
-
-	/* Build sub-layouts. */
-	sub_layouts_build(lid, &sub_layout_list, num_sublayouts);
-
-	/*
-	 * Build part of the buffer representing composite type specific part
-	 * of the layout.
-	 */
-	sl_header.slh_nr = num_sublayouts;
-	C2_ASSERT(c2_bufvec_cursor_step(dcur) >= sizeof sl_header);
-	nbytes = c2_bufvec_cursor_copyto(dcur, &sl_header, sizeof sl_header);
-	C2_ASSERT(nbytes == sizeof sl_header);
-
-	C2_ASSERT(c2_bufvec_cursor_step(dcur) >= sl_header.slh_nr *
-						 sizeof sl_entry);
-	c2_tl_for(c2_sub_layout, sub_layout_list, sl) {
-		sl_entry.sle_lid         = sl->csl_l->l_id;
-		sl_entry.sle_ext.e_start = sl->csl_ext.e_start;
-		sl_entry.sle_ext.e_end   = sl->csl_ext.e_end;
-		nbytes = c2_bufvec_cursor_copyto(dcur, &sl_entry,
-						 sizeof sl_entry);
-		C2_ASSERT(nbytes == sizeof sl_entry);
-		c2_sub_layout_tlist_del(sl);
-		c2_sub_layout_tlink_fini(sl);
-		c2_free(sl);
-	} c2_tl_endfor;
-
-        c2_sub_layout_tlist_fini(sub_layout_list);
-        c2_free(sub_layout_list);
-	return 0;
-}
-
-/* Tests the API c2_layout_decode() for COMPOSITE layout type. */
-static int test_decode_composite(uint64_t lid, bool failure_test)
-{
-	void                    *area;
-	c2_bcount_t              num_bytes;
-	struct c2_bufvec         bv;
-	struct c2_bufvec_cursor  cur;
-	struct c2_layout        *l;
-	struct c2_layout_type   *lt;
-	uint64_t                 sublayout_lid;
-	uint32_t                 i;
-
-	C2_ENTRY();
-
-	/* Build a layout buffer. */
-	allocate_area(&area, ADDITIONAL_BYTES_DEFAULT, &num_bytes);
-	bv = (struct c2_bufvec) C2_BUFVEC_INIT_BUF(&area, &num_bytes);
-	c2_bufvec_cursor_init(&cur, &bv);
-
-	rc = composite_layout_buf_build(lid, 60, 6000, &cur);
-	C2_UT_ASSERT(rc == 0);
-
-	/* Rewind the cursor. */
-	c2_bufvec_cursor_init(&cur, &bv);
-
-	lt = &c2_composite_layout_type;
-	rc = lt->lt_ops->lto_allocate(&domain, lid, &l);
-	C2_UT_ASSERT(rc == 0);
-
-	/* Decode the layout buffer into a layout object. */
-	rc = c2_layout_decode(l, &cur, C2_LXO_BUFFER_OP, NULL);
-	if (failure_test)
-		C2_UT_ASSERT(rc == -ENOMEM);
-	else {
-		C2_UT_ASSERT(rc == 0);
-		C2_UT_ASSERT(list_lookup(lid) == l);
-#if 0
-		/* Verify the layout object built by c2_layout_decode(). */
-		composite_layout_verify(l, lid, 6);
-#endif
-	}
-
-	/* Destroy the layout object. */
-	if (failure_test)
-		l->l_ops->lo_delete(l);
-	else {
-		/* Unlock the layout, locked by lto_allocate() */
-		c2_mutex_unlock(&l->l_lock);
-		/* Delete the composite layout. */
-		c2_layout_put(l);
-	}
-	C2_UT_ASSERT(list_lookup(lid) == NULL);
-
-	/* Delete all the sub-layouts. */
-	for (i = 0; i < 60; ++i) {
-		sublayout_lid = lid * 100 + i;
-		l = c2_layout_find(&domain, sublayout_lid);
-		c2_layout_put(l);
-		c2_layout_put(l);
-	}
-
-	c2_free(area);
-	C2_LEAVE();
-	return rc;
-}
-
 /* Tests the API c2_layout_decode(). */
 static void test_decode(void)
 {
@@ -1477,10 +1126,12 @@ static void test_decode(void)
 				 !FAILURE_TEST);
 	C2_UT_ASSERT(rc == 0);
 
+#if 0
 	/* Decode a layout object with COMPOSITE layout type. */
 	lid = 3005;
 	rc = test_decode_composite(lid, !FAILURE_TEST);
 	C2_UT_ASSERT(rc == 0);
+#endif
 }
 
 static void test_decode_failure(void)
@@ -1680,14 +1331,6 @@ static int test_encode_pdclust(uint32_t enum_id, uint64_t lid,
 	c2_uint128_init(&seed, "encodepdclustlay");
 
 	/* Build a layout object. */
-	if (enum_id == LIST_ENUM_ID)
-		allocate_area(&area, ADDITIONAL_BYTES_DEFAULT, &num_bytes);
-	else
-		allocate_area(&area, ADDITIONAL_BYTES_NONE, &num_bytes);
-
-	bv = (struct c2_bufvec) C2_BUFVEC_INIT_BUF(&area, &num_bytes);
-	c2_bufvec_cursor_init(&cur, &bv);
-
 	NKP_assign(enum_id,
 		   inline_test, 10, 120, 120,
 		   &N, &K, &P);
@@ -1700,6 +1343,13 @@ static int test_encode_pdclust(uint32_t enum_id, uint64_t lid,
 	C2_UT_ASSERT(rc == 0);
 
 	/* Encode the layout object into a layout buffer. */
+	if (enum_id == LIST_ENUM_ID)
+		allocate_area(&area, ADDITIONAL_BYTES_DEFAULT, &num_bytes);
+	else
+		allocate_area(&area, ADDITIONAL_BYTES_NONE, &num_bytes);
+	bv = (struct c2_bufvec) C2_BUFVEC_INIT_BUF(&area, &num_bytes);
+	c2_bufvec_cursor_init(&cur, &bv);
+
 	c2_mutex_lock(&pl->pl_base.sl_base.l_lock);
 	rc  = c2_layout_encode(&pl->pl_base.sl_base, C2_LXO_BUFFER_OP,
 			       NULL, &cur);
@@ -1726,80 +1376,6 @@ static int test_encode_pdclust(uint32_t enum_id, uint64_t lid,
 	return rc;
 }
 
-/* Tests the API c2_layout_encode() for COMPOSITE layout type. */
-static int test_encode_composite(uint64_t lid, bool failure_test)
-{
-	struct c2_composite_layout   *cl;
-	void                         *area;
-	c2_bcount_t                   num_bytes;
-	struct c2_bufvec              bv;
-	struct c2_bufvec_cursor       cur;
-	uint64_t                      sublayout_lid;
-	struct c2_layout             *l;
-	uint32_t                      i;
-#if 0
-	struct c2_uint128             seed;
-	uint32_t                      N;
-	uint32_t                      K;
-	uint32_t                      P;
-#endif
-
-	C2_ENTRY("lid %llu", (unsigned long long)lid);
-
-	/* Build a layout object. */
-	allocate_area(&area, ADDITIONAL_BYTES_DEFAULT, &num_bytes);
-	rc = composite_layout_build(lid, &cl, 50, failure_test);
-	if (failure_test)
-		C2_UT_ASSERT(rc == -ENOMEM);
-	else
-		C2_UT_ASSERT(rc == 0);
-
-	bv = (struct c2_bufvec) C2_BUFVEC_INIT_BUF(&area, &num_bytes);
-	c2_bufvec_cursor_init(&cur, &bv);
-
-	/* Encode the layout object into a layout buffer. */
-	c2_mutex_lock(&cl->cl_base.l_lock);
-	rc  = c2_layout_encode(&cl->cl_base, C2_LXO_BUFFER_OP, NULL, &cur);
-	c2_mutex_unlock(&cl->cl_base.l_lock);
-	if (failure_test)
-		C2_UT_ASSERT(rc == LO_ENCODE_ERR);
-	else
-		C2_UT_ASSERT(rc == 0);
-
-	/* Rewind the cursor. */
-	c2_bufvec_cursor_init(&cur, &bv);
-
-#if 0
-	/* todo Verify the layout buffer produced by c2_layout_encode(). */
-	if (!failure_test)
-		composite_layout_buf_verify(lid, sublayouts_nr, &cur);
-#endif
-
-	/*
-	 * todo Add a routine to combine deletion of comp layout and all its
-	 * sub-layouts.
-	 */
-
-	/*
-	 * Delete the composite layout object by reducing its last
-	 * reference.
-	 */
-	c2_layout_put(&cl->cl_base);
-	C2_UT_ASSERT(c2_layout_find(&domain, lid) == NULL);
-
-	/* Delete all the sub-layouts. */
-	for (i = 0; i < 50; ++i) {
-		sublayout_lid = lid * 100 + i;
-		l = c2_layout_find(&domain, sublayout_lid);
-		c2_layout_put(l);
-		c2_layout_put(l);
-	}
-
-	c2_free(area);
-	C2_LEAVE();
-	return rc;
-}
-
 /* Tests the API c2_layout_encode(). */
 static void test_encode(void)
 {
@@ -1842,7 +1418,7 @@ static void test_encode(void)
 
 	/* Encode for COMPOSITE layout type. */
 	lid = 5005;
-	rc = test_encode_composite(lid, !FAILURE_TEST);
+	rc = test_encode_composite(lid, &domain, !FAILURE_TEST);
 	C2_UT_ASSERT(rc == 0);
 }
 
@@ -2324,14 +1900,6 @@ static int test_encode_decode_pdclust(uint32_t enum_id, uint64_t lid,
 	c2_uint128_init(&seed, "encodedecodepdcl");
 
 	/* Build a layout object. */
-	if (enum_id == LIST_ENUM_ID)
-		allocate_area(&area, ADDITIONAL_BYTES_DEFAULT, &num_bytes);
-	else
-		allocate_area(&area, ADDITIONAL_BYTES_NONE, &num_bytes);
-
-	bv = (struct c2_bufvec) C2_BUFVEC_INIT_BUF(&area, &num_bytes);
-	c2_bufvec_cursor_init(&cur, &bv);
-
 	NKP_assign(enum_id,
 		   inline_test, 13, 113, 1130,
 		   &N, &K, &P);
@@ -2347,6 +1915,13 @@ static int test_encode_decode_pdclust(uint32_t enum_id, uint64_t lid,
 	C2_UT_ASSERT(l_copy != NULL);
 
 	/* Encode the layout object into a layout buffer. */
+	if (enum_id == LIST_ENUM_ID)
+		allocate_area(&area, ADDITIONAL_BYTES_DEFAULT, &num_bytes);
+	else
+		allocate_area(&area, ADDITIONAL_BYTES_NONE, &num_bytes);
+	bv = (struct c2_bufvec) C2_BUFVEC_INIT_BUF(&area, &num_bytes);
+	c2_bufvec_cursor_init(&cur, &bv);
+
 	c2_mutex_lock(&pl->pl_base.sl_base.l_lock);
 	rc = c2_layout_encode(&pl->pl_base.sl_base, C2_LXO_BUFFER_OP,
 			      NULL, &cur);
@@ -3277,108 +2852,6 @@ static int test_lookup_with_ghost_creation(uint32_t enum_id, uint64_t lid,
 	return rc;
 }
 
-static int test_add_composite(uint64_t lid,
-			      bool layout_destroy, struct c2_layout **l_obj,
-			      bool duplicate_test,
-			      bool failure_test);
-/* Tests the API c2_layout_lookup(), for the COMPOSITE layout type. */
-static int test_lookup_composite(uint64_t lid,
-				 bool existing_test,
-				 bool failure_test)
-{
-	c2_bcount_t        num_bytes;
-	void              *area;
-	struct c2_layout  *l1;
-	//todo struct c2_layout  *l1_copy;
-	struct c2_layout  *l2;
-	struct c2_layout  *l3;
-	struct c2_db_pair  pair;
-	struct c2_db_tx    tx;
-	uint32_t           i; //todo rm
-	uint64_t           sublayout_lid; //todo rm
-	struct c2_layout  *l; //todo rm
-	int                rc_tmp;
-
-	C2_ENTRY();
-	C2_UT_ASSERT(ergo(!existing_test, failure_test));
-
-	/*
-	 * If existing_test is true, then first add a layout object to the
-	 * DB.
-	 */
-	if (existing_test) {
-		rc = test_add_composite(lid,
-					!LAYOUT_DESTROY, &l1,
-					!DUPLICATE_TEST,
-					!FAILURE_TEST);
-		C2_UT_ASSERT(rc == 0);
-
-#if 0 //todo
-		if (!failure_test)
-			composite_layout_copy(enum_id, l1, &l1_copy);
-#endif
-
-		/*
-		 * Lookup for the layout object to verify that the same object
-		 * is returned from the memory, not requiring a lookup from the
-		 * DB.
-		 */
-		rc = c2_layout_lookup(&domain, lid, &c2_composite_layout_type,
-				      &tx, &pair, &l2);
-		C2_UT_ASSERT(rc == 0);
-		C2_UT_ASSERT(l2 == l1);
-
-		/* Release the reference acquired by c2_layout_lookup(). */
-		c2_layout_put(l1);
-
-		/* Destroy the layout object. */
-		c2_layout_put(l1);
-	}
-
-	C2_UT_ASSERT(list_lookup(lid) == NULL);
-
-	/* Lookup for the layout object from the DB. */
-	allocate_area(&area, ADDITIONAL_BYTES_NONE, &num_bytes);
-
-	rc = c2_db_tx_init(&tx, &dbenv, DBFLAGS);
-	C2_UT_ASSERT(rc == 0);
-
-	pair_set(&pair, &lid, area, num_bytes);
-
-	rc = c2_layout_lookup(&domain, lid, &c2_composite_layout_type,
-			      &tx, &pair, &l3);
-	if (failure_test)
-		C2_UT_ASSERT(rc == -ENOENT || rc == -ENOMEM || rc == -EPROTO ||
-			     rc == LO_DECODE_ERR);
-	else
-		C2_UT_ASSERT(rc == 0);
-
-	rc_tmp = c2_db_tx_commit(&tx);
-	C2_UT_ASSERT(rc_tmp == 0);
-
-	if (existing_test && !failure_test) {
-		C2_UT_ASSERT(list_lookup(lid) == l3);
-		//todo composite_layout_compare(enum_id, l1_copy, l3, false);
-		//todo composite_layout_copy_delete(enum_id, l1_copy);
-
-		/* Destroy the layout object. */
-		c2_layout_put(l3);
-		C2_UT_ASSERT(list_lookup(lid) == NULL);
-
-		/* Delete all the sub-layouts. */
-		for (i = 0; i < 10; ++i) {
-			sublayout_lid = lid * 100 + i;
-			l = c2_layout_find(&domain, sublayout_lid);
-			C2_UT_ASSERT(l->l_user_count == 0);
-			c2_layout_put(l);
-			c2_layout_put(l);
-		}
-	}
-	c2_free(area);
-	C2_LEAVE();
-	return rc;
-}
-
 /* Tests the API c2_layout_lookup(). */
 static void test_lookup(void)
 {
@@ -3462,6 +2935,7 @@ static void test_lookup(void)
 					     INLINE_NOT_APPLICABLE);
 	C2_UT_ASSERT(rc == 0);
 
+#if 0
 	/*
 	 * Lookup for a layout object with COMPOSITE layout type, that does not
 	 * exist in the DB.
@@ -3481,6 +2955,7 @@ static void test_lookup(void)
 				   EXISTING_TEST,
 				   !FAILURE_TEST);
 	C2_UT_ASSERT(rc == 0);
+#endif
 }
 
 /* Tests the API c2_layout_lookup(). */
@@ -3672,89 +3147,6 @@ static int test_add_pdclust(uint32_t enum_id, uint64_t lid,
 	return rc;
 }
 
-/* Tests the API c2_layout_add(), for the COMPOSITE layout type. */
-//todo Make this accept num_sublayouts
-static int test_add_composite(uint64_t lid,
-			      bool layout_destroy, struct c2_layout **l_obj,
-			      bool duplicate_test,
-			      bool failure_test)
-{
-	c2_bcount_t                   num_bytes;
-	void                         *area;
-	struct c2_composite_layout   *cl;
-	struct c2_db_pair             pair;
-	struct c2_db_tx               tx;
-	struct c2_layout             *l;
-	uint64_t                      sublayout_lid;
-	uint32_t                      i;
-	int                           rc_tmp;
-
-	C2_ENTRY("lid %llu", (unsigned long long)lid);
-	C2_UT_ASSERT(ergo(layout_destroy, l_obj == NULL));
-	C2_UT_ASSERT(ergo(!layout_destroy, l_obj != NULL));
-	C2_UT_ASSERT(ergo(duplicate_test, !failure_test));
-
-	allocate_area(&area, ADDITIONAL_BYTES_NONE, &num_bytes);
-
-	/* Build a layout object. */
-	rc = composite_layout_build(lid, &cl, 10, failure_test);
-	C2_UT_ASSERT(rc == 0);
-
-	/* Add the layout object to the DB. */
-	rc = c2_db_tx_init(&tx, &dbenv, DBFLAGS);
-	C2_UT_ASSERT(rc == 0);
-
-	pair_set(&pair, &lid, area, num_bytes);
-
-	rc = c2_layout_add(&cl->cl_base, &tx, &pair);
-	if (failure_test)
-		C2_UT_ASSERT(rc == -ENOENT || rc == LO_ENCODE_ERR);
-		//todo check why -ENOENT err here n for pdclust
-	else
-		C2_UT_ASSERT(rc == 0);
-
-	rc_tmp = c2_db_tx_commit(&tx);
-	C2_UT_ASSERT(rc_tmp == 0);
-
-	C2_UT_ASSERT(list_lookup(lid) == &cl->cl_base);
-
-	/*
-	 * If duplicate_test is true, again try to add the same layout object
-	 * to the DB, to verify that it results into EEXIST error.
-	 */
-	if (duplicate_test) {
-		rc = c2_db_tx_init(&tx, &dbenv, DBFLAGS);
-		C2_UT_ASSERT(rc == 0);
-
-		pair_set(&pair, &lid, area, num_bytes);
-
-		rc = c2_layout_add(&cl->cl_base, &tx, &pair);
-		C2_UT_ASSERT(rc == -EEXIST);
-
-		rc_tmp = c2_db_tx_commit(&tx);
-		C2_UT_ASSERT(rc_tmp == 0);
-	}
-
-	if (layout_destroy) {
-		c2_layout_put(&cl->cl_base);
-		C2_UT_ASSERT(list_lookup(lid) == NULL);
-
-		/* Delete all the sub-layouts. */
-		for (i = 0; i < 10; ++i) {
-			sublayout_lid = lid * 100 + i;
-			l = c2_layout_find(&domain, sublayout_lid);
-			c2_layout_put(l);
-			c2_layout_put(l);
-		}
-	}
-	else
-		*l_obj = &cl->cl_base;
-
-	c2_free(area);
-	C2_LEAVE("lid %llu", (unsigned long long)lid);
-	return rc;
-}
-
 /* Tests the API c2_layout_add(). */
 static void test_add(void)
 {
@@ -3806,6 +3198,7 @@ static void test_add(void)
 			      !FAILURE_TEST);
 	C2_UT_ASSERT(rc == 0);
 
+#if 0
 	/* Add a layout object with COMPOSITE layout type. */
 	lid = 16005;
 	rc = test_add_composite(lid,
@@ -3813,6 +3206,7 @@ static void test_add(void)
 				!DUPLICATE_TEST,
 				!FAILURE_TEST);
 	C2_UT_ASSERT(rc == 0);
+#endif
 }
 
 static void test_add_failure(void)
@@ -3867,6 +3261,7 @@ static void test_add_failure(void)
 			      FAILURE_TEST);
 	C2_UT_ASSERT(rc == -ENOENT);
 
+#if 0
 	/*
 	 * Simulate the error that entry already exists in the layout DB with
 	 * the same layout id.
@@ -3877,6 +3272,7 @@ static void test_add_failure(void)
 				DUPLICATE_TEST,
 				!FAILURE_TEST);
 	C2_UT_ASSERT(rc == -EEXIST);
+#endif
 }
 
 /* Tests the API c2_layout_update(), for the PDCLUST layout type. */
@@ -4192,95 +3588,6 @@ static int test_delete_pdclust(uint32_t enum_id, uint64_t lid,
 	return rc;
 }
 
-/* Tests the API c2_layout_delete(), for the COMPOSITE layout type. */
-static int test_delete_composite(uint64_t lid,
-				 bool existing_test,
-				 uint32_t failure_test)
-{
-	c2_bcount_t                   num_bytes;
-	void                         *area;
-	struct c2_db_pair             pair;
-	struct c2_db_tx               tx;
-	struct c2_layout             *l;
-	struct c2_composite_layout   *cl;
-	uint32_t                      sublayout_lid;
-	uint32_t                      i;
-	int                           rc_tmp;
-
-	C2_ENTRY("lid %llu", (unsigned long long)lid);
-	allocate_area(&area, ADDITIONAL_BYTES_NONE, &num_bytes);
-
-	if (existing_test) {
-		/* Add a layout object to the DB. */
-		rc = test_add_composite(lid,
-					!LAYOUT_DESTROY, &l,
-					!DUPLICATE_TEST,
-					!FAILURE_TEST);
-		C2_UT_ASSERT(rc == 0);
-	} else {
-		/* Build a layout object. */
-		rc = composite_layout_build(lid, &cl, 10, !FAILURE_TEST);
-		C2_UT_ASSERT(rc == 0);
-		l = &cl->cl_base;
-	}
-
-	if (C2_FI_ENABLED("nonzero_user_count_err"))
-		c2_layout_user_count_inc(l);
-
-	/* Delete the layout object from the DB. */
-	pair_set(&pair, &lid, area, num_bytes);
-
-	rc = c2_db_tx_init(&tx, &dbenv, DBFLAGS);
-	C2_UT_ASSERT(rc == 0);
-
-	rc = c2_layout_delete(l, &tx, &pair);
-	if (failure_test)
-		C2_UT_ASSERT(rc == -ENOENT || rc == -ENOMEM ||
-			     rc == -EPROTO || rc == LO_ENCODE_ERR);
-	else
-		C2_UT_ASSERT(rc == 0);
-
-	rc_tmp = c2_db_tx_commit(&tx);
-	C2_UT_ASSERT(rc_tmp == 0);
-
-	/* Destroy the layout object. */
-	c2_layout_put(l);
-	C2_UT_ASSERT(list_lookup(lid) == NULL);
-
-	/* Delete all the sub-layouts. */
-	for (i = 0; i < 10; ++i) {
-		sublayout_lid = lid * 100 + i;
-		l = c2_layout_find(&domain, sublayout_lid);
-		C2_UT_ASSERT(l->l_user_count == 0);
-		c2_layout_put(l);
-		c2_layout_put(l);
-	}
-
-	if (!failure_test) {
-		/*
-		 * Lookup for the layout object from the DB, to verify that it
-		 * does not exist there and that the lookup results into
-		 * ENOENT error.
-		 */
-		rc = c2_db_tx_init(&tx, &dbenv, DBFLAGS);
-		C2_UT_ASSERT(rc == 0);
-
-		pair_set(&pair, &lid, area, num_bytes);
-
-		rc_tmp = c2_layout_lookup(&domain, lid,
-					  &c2_composite_layout_type,
-					  &tx, &pair, &l);
-		C2_UT_ASSERT(rc_tmp == -ENOENT);
-
-		rc_tmp = c2_db_tx_commit(&tx);
-		C2_UT_ASSERT(rc_tmp == 0);
-	}
-
-	c2_free(area);
-	C2_LEAVE();
-	return rc;
-}
-
 /* Tests the API c2_layout_delete(). */
 static void test_delete(void)
 {
@@ -4332,11 +3639,13 @@ static void test_delete(void)
 	C2_UT_ASSERT(rc == 0);
 
 	/* Delete a layout object with COMPOSITE layout type. */
+#if 0
 	lid = 20005;
 	rc = test_delete_composite(lid,
 				   EXISTING_TEST,
 				   !FAILURE_TEST);
 	C2_UT_ASSERT(rc == 0);
+#endif
 }
 
 static void test_delete_failure(void)
diff --git a/layout/ut/layout.h b/layout/ut/layout.h
new file mode 100644
index 0000000..727e80b
--- /dev/null
+++ b/layout/ut/layout.h
@@ -0,0 +1,126 @@
+/* -*- C -*- */
+/*
+ * COPYRIGHT 2012 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: Trupti Patil <trupti_patil@xyratex.com>
+ * Original creation date: 11/01/2012
+ */
+
+#pragma once
+
+#ifndef __COLIBRI_LAYOUT_UT_LAYOUT_H__
+#define __COLIBRI_LAYOUT_UT_LAYOUT_H__
+
+#include "lib/ut.h"
+#include "lib/ub.h"
+#include "lib/memory.h"
+#include "lib/misc.h"                    /* C2_SET0 */
+#include "lib/bitstring.h"
+#include "lib/vec.h"
+
+#define C2_TRACE_SUBSYSTEM C2_TRACE_SUBSYS_LAYOUT
+#include "lib/trace.h"                   /* C2_LOG */
+
+#ifdef __KERNEL__
+# include "c2t1fs/linux_kernel/c2t1fs.h" /* c2t1fs_globals */
+#endif
+
+#include "lib/finject.h"
+
+struct c2_layout_list_enum;
+struct c2_layout_linear_enum;
+struct c2_pdclust_layout;
+
+enum {
+	DBFLAGS                  = 0,    /* Flag used for dbenv and tx init */
+	LIST_ENUM_ID             = 0x4C495354, /* "LIST" */
+	LINEAR_ENUM_ID           = 0x4C494E45, /* "LINE" */
+	ADDITIONAL_BYTES_NONE    = 0,    /* For buffer initialisation */
+	ADDITIONAL_BYTES_DEFAULT = 2048, /* For buffer initialisation */
+	INLINE_NOT_APPLICABLE    = 0,    /* For list enumeration */
+	LESS_THAN_INLINE         = 1,    /* For list enumeration */
+	EXACT_INLINE             = 2,    /* For list enumeration */
+	MORE_THAN_INLINE         = 3,    /* For list enumeration */
+	EXISTING_TEST            = true, /* Add a layout to the DB */
+	DUPLICATE_TEST           = true, /* Try to re-add a layout */
+	FAILURE_TEST             = true, /* Failure injected */
+	LAYOUT_DESTROY           = true, /* Delete layout object */
+	UNIT_SIZE                = 4096, /* For pdclust layout type */
+	USER_COUNT_INCREMENTED   = true, /* For verification of user count */
+	CONTIGUOUS_EXTENTS       = true  /* For extents of a sub-layout */
+};
+
+extern struct c2_layout_type c2_pdclust_layout_type;
+extern struct c2_layout_type c2_composite_layout_type;
+extern struct c2_layout_enum_type c2_list_enum_type;
+extern struct c2_layout_enum_type c2_linear_enum_type;
+
+void allocate_area(void **area,
+		   c2_bcount_t additional_bytes,
+		   c2_bcount_t *num_bytes);
+
+void l_verify(struct c2_layout *l,
+	      uint64_t lid,
+	      bool if_user_count_incremented);
+
+//void lbuf_verify(struct c2_bufvec_cursor *cur, uint32_t *lt_id);
+
+//void lbuf_compare(struct c2_bufvec_cursor *cur1,
+//			 struct c2_bufvec_cursor *cur2);
+
+
+void NKP_assign(uint32_t enum_id,
+		uint32_t inline_test,
+		uint32_t list_nr_less,
+		uint32_t list_nr_more,
+		uint32_t linear_nr,
+		uint32_t *N, uint32_t *K, uint32_t *P);
+
+int pdclust_layout_build(uint32_t enum_id,
+			 uint64_t lid,
+			 uint32_t N, uint32_t K, uint32_t P,
+			 struct c2_uint128 *seed,
+			 uint32_t A, uint32_t B,
+			 struct c2_pdclust_layout **pl,
+			 struct c2_layout_list_enum **list_enum,
+			 struct c2_layout_linear_enum **lin_enum,
+			 bool failure_test);
+
+void pdclust_layout_verify(uint32_t enum_id,
+			   struct c2_layout *l, uint64_t lid,
+			   uint32_t N, uint32_t K, uint32_t P,
+			   struct c2_uint128 *seed,
+			   uint32_t A, uint32_t B,
+			   bool if_user_count_incremented);
+
+int test_build_composite(uint64_t lid,
+			 struct c2_layout_domain *domain,
+			 bool failure_test);
+int test_encode_composite(uint64_t lid,
+			  struct c2_layout_domain *domain,
+			  bool failure_test);
+
+/* __COLIBRI_LAYOUT_LAYOUT_H__ */
+#endif
+
+/*
+ *  Local variables:
+ *  c-indentation-style: "K&R"
+ *  c-basic-offset: 8
+ *  tab-width: 8
+ *  fill-column: 80
+ *  scroll-step: 1
+ *  End:
+ */
-- 
1.8.3.2

