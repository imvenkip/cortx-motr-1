From 4e32a592fe4eba7a5541cb0346853cd61c162fde Mon Sep 17 00:00:00 2001
From: "trupti.patil" <trupti_patil@xyratex.com>
Date: Tue, 5 Mar 2013 17:56:42 +0530
Subject: [PATCH 072/172] Support for updating auxiliary table in case layout
 update op

---
 layout/composite.c    | 309 +++++++++++++++++++++++++++++++++++++++-----------
 layout/layout_addb.h  |  11 +-
 layout/ut/composite.c | 201 +++++++++++++++++++++++++++++++-
 layout/ut/composite.h |   9 ++
 layout/ut/layout.c    |  33 +++++-
 layout/ut/layout.h    |   1 +
 layout/ut/pdclust.c   |  16 ++-
 7 files changed, 500 insertions(+), 80 deletions(-)

diff --git a/layout/composite.c b/layout/composite.c
index d7c178d..bef6ce4 100644
--- a/layout/composite.c
+++ b/layout/composite.c
@@ -162,6 +162,7 @@ enum extent_add_position {
 /** Flags used for better readability. */
 enum {
 	INMEM_LIST_UPDATE    = true,
+	IN_UPDATE_PATH       = true,
 	EXT_MERGE_VALIDATION = 11,
 	EXT_DEL_VALIDATION   = 12
 };
@@ -488,12 +489,11 @@ static int composite_populate(struct m0_composite_layout *cl,
 
 	M0_PRE(composite_allocated_invariant(cl));
 	M0_PRE(m0_layout__invariant(sublayout));
-
 	M0_ENTRY("lid %llu", (unsigned long long)cl->cl_base.l_id);
-	m0_layout__populate(&cl->cl_base, user_count);
 
 	rc = layer_inmem_add(cl, sublayout, extlist, ext_nr, &layer);
 	M0_ASSERT(layer->clr_idx == 0);
+	m0_layout__populate(&cl->cl_base, user_count);
 
 	M0_POST(ergo(rc == 0, composite_invariant(cl)));
 	M0_POST(ergo(rc != 0, composite_allocated_invariant(cl)));
@@ -586,7 +586,7 @@ static int comp_layout_indb_read(struct m0_composite_layout *cl,
 static int comp_layout_indb_add(struct m0_composite_layout *cl,
 				struct m0_db_tx *tx);
 static int comp_layout_indb_delete(struct m0_composite_layout *cl,
-				   struct m0_db_tx *tx);
+				   struct m0_db_tx *tx, bool in_update_path);
 static int ext_indb_lookup(struct m0_composite_layout *cl,
 			   m0_bindex_t offset,
 			   struct m0_db_tx *tx,
@@ -601,17 +601,39 @@ static int ext_indb_write(struct m0_composite_layout *cl,
 			  struct m0_db_tx *tx,
 			  uint32_t ext_validation_kind);
 
+static int layer_add_internal(struct m0_composite_layout *cl,
+			      struct m0_layout *sublayout,
+			      struct m0_tl *extlist,
+			      uint32_t ext_nr,
+			      struct m0_db_tx *tx)
+{
+	struct m0_composite_layer *layer;
+	int                        rc;
+
+	M0_PRE(m0_mutex_is_locked(&cl->cl_base.l_lock));
+	rc = layer_inmem_add(cl, sublayout, extlist, ext_nr, &layer);
+	if (rc != 0)
+		return rc;
+	M0_ASSERT(layer->clr_idx > 0);
+
+	if (cl->cl_base.l_dom->ld_is_db_available) {
+		rc = layer_indb_add(cl, layer, tx);
+		if (rc != 0)
+			layer_inmem_delete(cl, layer);
+	}
+	M0_POST(ergo(rc == 0, layer_invariant(layer)));
+	return rc;
+}
+
 M0_INTERNAL int m0_composite_layer_add(struct m0_composite_layout *cl,
 				       struct m0_layout *sublayout,
 				       struct m0_tl *extlist,
 				       uint32_t ext_nr,
 				       struct m0_db_tx *tx)
 {
-	struct m0_composite_layer *layer;
-	int                        rc;
+	int rc;
 
 	M0_PRE(composite_invariant(cl));
-	M0_PRE(m0_mutex_is_locked(&cl->cl_base.l_lock));
 	M0_PRE(m0_layout__invariant(sublayout));
 	M0_PRE(extlist != NULL);
 	M0_PRE(ergo(cl->cl_base.l_dom->ld_is_db_available, tx != NULL));
@@ -621,38 +643,26 @@ M0_INTERNAL int m0_composite_layer_add(struct m0_composite_layout *cl,
 		 (unsigned long long)sublayout->l_id,
 		 extlist, (unsigned long)ext_nr, tx);
 
+	m0_mutex_lock(&cl->cl_base.l_lock);
 	if (m0_composite_layer_ext_tlist_is_empty(extlist) || ext_nr == 0) {
 		m0_layout__log("m0_composite_layer_add",
 			       "Invalid list of extents",
 			       M0_LAYOUT_ADDB_LOC_COMP_LAYER_ADD_1,
 			       &cl->cl_base.l_addb_ctx, cl->cl_base.l_id,
 			       -EINVAL);
+		m0_mutex_unlock(&cl->cl_base.l_lock);
 		return -EINVAL;
 	}
 
-	rc = layer_inmem_add(cl, sublayout, extlist, ext_nr, &layer);
+	rc = layer_add_internal(cl, sublayout, extlist, ext_nr, tx);
 	if (rc != 0) {
 		m0_layout__log("m0_composite_layer_add",
-			       "failed to write layer in memory",
+			       "Failed to add layer",
 			       M0_LAYOUT_ADDB_LOC_COMP_LAYER_ADD_2,
 			       &cl->cl_base.l_addb_ctx, cl->cl_base.l_id, rc);
-		return rc;
-	}
-	M0_ASSERT(layer->clr_idx > 0);
 
-	if (cl->cl_base.l_dom->ld_is_db_available) {
-		rc = layer_indb_add(cl, layer, tx);
-		if (rc != 0) {
-			m0_layout__log("m0_composite_layer_add",
-				       "failed to write layer in DB",
-				       M0_LAYOUT_ADDB_LOC_COMP_LAYER_ADD_3,
-				       &cl->cl_base.l_addb_ctx,
-				       cl->cl_base.l_id, rc);
-			layer_inmem_delete(cl, layer);
-		}
 	}
-
-	M0_POST(ergo(rc == 0, layer_invariant(layer)));
+	m0_mutex_unlock(&cl->cl_base.l_lock);
 	M0_POST(composite_invariant(cl));
 	M0_RETURN(rc);
 }
@@ -778,6 +788,14 @@ static int comp_layout_inbuf_read(struct m0_composite_layout *cl,
 	for (i = 0; i < cl_header->ch_layers_nr; ++i) {
 		lr_header = m0_bufvec_cursor_addr(cur);
 		m0_bufvec_cursor_move(cur, sizeof *lr_header);
+
+		if (lr_header->clh_extents_nr == 0) {
+			M0_LOG(M0_ERROR, "lid %llu, layer %lu, No extent is "
+			       "associated in the buffer",
+			       (unsigned long long)cl->cl_base.l_id,
+			       (unsigned long)i);
+			return -EINVAL;
+		}
 		sublayout = layout_find(cl->cl_base.l_dom, lr_header->clh_slid);
 		if (sublayout == NULL) {
 			M0_LOG(M0_ERROR, "lid %llu, sublayout with lid %llu "
@@ -790,17 +808,22 @@ static int comp_layout_inbuf_read(struct m0_composite_layout *cl,
 		M0_ASSERT(lr_header->clh_idx == i);
 		rc = extlist_inbuf_read(cl, cur, lr_header->clh_extents_nr,
 					&extlist);
-		M0_ASSERT(rc == 0);
+		if (rc != 0) {
+			M0_LOG(M0_ERROR, "lid %llu, layer %lu, Error while "
+			       "reading extlist from the buf",
+			       (unsigned long long)cl->cl_base.l_id,
+			       (unsigned long)i);
+			return rc;
+		}
 
 		if (lr_header->clh_idx == 0) /* Zeroth layer */
 			rc = composite_populate(cl, sublayout, extlist,
 						lr_header->clh_extents_nr,
 						user_count);
 		else
-			rc = m0_composite_layer_add(cl, sublayout,
-						    extlist,
-						    lr_header->clh_extents_nr,
-						    NULL);
+			rc = layer_add_internal(cl, sublayout, extlist,
+						lr_header->clh_extents_nr,
+						NULL);
 		/*
 		 * Release the reference added by m0_layout_find(). In case of
 		 * success, m0_composite_layer_add() has added a reference on
@@ -900,6 +923,22 @@ static void comp_layout_inbuf_write(const struct m0_composite_layout *cl,
 	M0_LEAVE("lid %llu", (unsigned long long)cl->cl_base.l_id);
 }
 
+static struct m0_composite_layer *layer_find(
+					const struct m0_composite_layout *cl,
+					uint32_t layer_idx)
+{
+	struct m0_composite_layer *layer = NULL;
+
+	M0_PRE(layer_idx < cl->cl_layers_nr);
+	m0_tl_for(comp_layer, &cl->cl_layers, layer) {
+		if (layer->clr_idx == layer_idx)
+			break;
+	} m0_tl_endfor;
+
+	M0_POST(layer->clr_idx == layer_idx && layer_invariant(layer));
+	return layer;
+}
+
 /** Implementation of lo_encode() for composite layout type. */
 static int composite_encode(struct m0_layout *l,
 			    enum m0_layout_xcode_op op,
@@ -907,6 +946,8 @@ static int composite_encode(struct m0_layout *l,
 			    struct m0_bufvec_cursor *out)
 {
 	struct m0_composite_layout *cl;
+	struct m0_composite_layer  *layer;
+	uint32_t                    i;
 	int                         rc;
 
 	M0_PRE(l != NULL);
@@ -924,19 +965,43 @@ static int composite_encode(struct m0_layout *l,
 		rc = 0;
 	} else if (op == M0_LXO_DB_ADD) {
 		rc = comp_layout_indb_add(cl, tx);
-		if (rc != 0)
-			M0_LOG(M0_ERROR, "lid %llu, layout could not be "
-			       "added to the DB",
-			       (unsigned long long)cl->cl_base.l_id);
+		if (rc == 0) {
+			for (i = 1; i < cl->cl_layers_nr; ++i) {
+				layer = layer_find(cl, i);
+				rc = layer_indb_add(cl, layer, tx);
+				if (rc != 0)
+					break;
+			}
+		}
 	} else if (op == M0_LXO_DB_UPDATE) {
-		//todo Update needs to be supported
 		/*
-		 * The auxiliary tables are not to be modified for a layout
-		 * update operation.
+		 * To a composite layout, layers and extents can be added,
+		 * deleted by the client to whom the DB is not accessible and
+		 * then the layout is asked to be updated in the DB at a later
+		 * point. For this reason, as a part of the layout update for
+		 * a composite layout, all the existing layers and their
+		 * extents are first deleted and then are added newly by
+		 * referring to the current in-memory layout.
 		 */
-		rc = 0;
+		rc = comp_layout_indb_delete(cl, tx, IN_UPDATE_PATH);
+		if (rc == 0 || rc == -ENOENT) {
+			/*
+			 * It is possible that the layout did not exist in
+			 * the DB until the point it is asked to be updated
+			 * directly.
+			 */
+			rc = comp_layout_indb_add(cl, tx);
+			if (rc == 0) {
+				for (i = 1; i < cl->cl_layers_nr; ++i) {
+					layer = layer_find(cl, i);
+					rc = layer_indb_add(cl, layer, tx);
+					if (rc != 0)
+						break;
+				}
+			}
+		}
 	} else {
-		rc = comp_layout_indb_delete(cl, tx);
+		rc = comp_layout_indb_delete(cl, tx, !IN_UPDATE_PATH);
 		if (rc != 0)
 			M0_LOG(M0_ERROR, "lid %llu, layout could not be "
 			       "deleted from the DB",
@@ -1092,8 +1157,6 @@ static int ext_inmem_add(struct m0_composite_layer *layer,
 		if (ext->e_start <= lr_ext->cle_ext.e_start)
 			break;
 	} m0_tl_endfor;
-	M0_ASSERT(lr_ext_to_insert_before != NULL ||
-		  lr_ext_to_insert_after != NULL);
 
 	if (lr_ext_to_insert_after != NULL)
 		rc = ext_inmem_add_internal(layer, NULL, NULL,
@@ -1103,6 +1166,12 @@ static int ext_inmem_add(struct m0_composite_layer *layer,
 		rc = ext_inmem_add_internal(layer, NULL, NULL,
 					    ext, ext_state, ADD_BEFORE,
 					    lr_ext_to_insert_before);
+	else {
+		M0_ASSERT(ext->e_start == 0 && ext->e_end == M0_BINDEX_MAX + 1);
+		rc = ext_inmem_add_internal(layer, NULL, NULL,
+					    ext, ext_state, ADD_AT_TAIL, NULL);
+	}
+
 	if (rc != 0)
 		M0_LOG(M0_ERROR, "lid %llu, extent could not be added to "
 		       "memory",
@@ -1110,22 +1179,6 @@ static int ext_inmem_add(struct m0_composite_layer *layer,
 	M0_RETURN(rc);
 }
 
-static struct m0_composite_layer *layer_find(
-					const struct m0_composite_layout *cl,
-					uint32_t layer_idx)
-{
-	struct m0_composite_layer *layer = NULL;
-
-	M0_PRE(layer_idx < cl->cl_layers_nr);
-	m0_tl_for(comp_layer, &cl->cl_layers, layer) {
-		if (layer->clr_idx == layer_idx)
-			break;
-	} m0_tl_endfor;
-
-	M0_POST(layer->clr_idx == layer_idx && layer_invariant(layer));
-	return layer;
-}
-
 /**
  * Looks up for a valid extent with the given offset, starting with the
  * top-most layer in the given composite layout.
@@ -1972,7 +2025,6 @@ static int emap_iterator_set(struct m0_composite_layout *cl,
 			       "failed to lookup into layer_emap",
 			       M0_LAYOUT_ADDB_LOC_COMP_EMAP_IT_SET,
 			       &cl->cl_base.l_addb_ctx, cl->cl_base.l_id, rc);
-		m0_mutex_unlock(&cl->cl_base.l_lock);
 		return rc;
 	}
 
@@ -2606,8 +2658,32 @@ static int comp_layout_indb_add(struct m0_composite_layout *cl,
 	return rc;
 }
 
-static int comp_layout_indb_delete(struct m0_composite_layout *cl,
-				   struct m0_db_tx *tx)
+static int single_ext_indb_write(struct m0_emap_cursor *it,
+				 struct m0_composite_layer *layer)
+{
+	struct m0_ext ext;
+	int           rc;
+
+	while (!m0_emap_ext_is_first(&it->ec_seg.ee_ext)) {
+		rc = m0_emap_prev(it);
+		if (rc != 0) {
+			m0_layout__log("single_ext_indb_write",
+				       "failed to lookup into layer_emap",
+				       M0_LAYOUT_ADDB_LOC_COMP_EXT_WRITE,
+				       &layer->clr_cl->l_addb_ctx,
+				       layer->clr_cl->l_id, rc);
+			break;
+		}
+	}
+	ext.e_start = 0;
+	ext.e_end = M0_BINDEX_MAX + 1;
+	rc = ext_indb_write_internal(it, layer, &ext, M0_CLRES_INVALID,
+				     !INMEM_LIST_UPDATE);
+	return rc;
+}
+
+static int delete_verify(struct m0_composite_layout *cl,
+			 struct m0_db_tx *tx)
 {
 	struct m0_composite_layer        *layer;
 	struct m0_composite_layer_extent *lr_ext;
@@ -2617,14 +2693,8 @@ static int comp_layout_indb_delete(struct m0_composite_layout *cl,
 	struct m0_emap_seg               *seg;
 	int                               rc;
 
-	M0_ENTRY("lid %llu", (unsigned long long)cl->cl_base.l_id);
-
 	emap = emap_from_cl(cl);
 
-	/*
-	 * A composite layout can be deleted from the DB if and only if none of
-	 * its layers contain any valid extents.
-	 */
 	m0_tl_for(comp_layer, &cl->cl_layers, layer) {
 		/* In-memory layer verification. */
 		m0_tl_for(m0_composite_layer_ext, layer->clr_extents, lr_ext) {
@@ -2677,11 +2747,119 @@ static int comp_layout_indb_delete(struct m0_composite_layout *cl,
 			m0_emap_next(&it);
 			seg = m0_emap_seg_get(&it);
 		}
+		/*
+		 * Combine all the invalid extents into one, by adding an
+		 * invalid extent with the complete offset space.
+		 */
+		rc = single_ext_indb_write(&it, layer);
 		m0_emap_close(&it);
+		if (rc != 0)
+			break;
 	} m0_tl_endfor;
+	return rc;
+}
+
+static int extents_indb_delete(struct m0_composite_layout *cl,
+			       struct m0_db_tx *tx,
+			       struct m0_composite_layer *layer)
+{
+	struct m0_emap        *emap;
+	struct m0_emap_cursor  it;
+	struct m0_emap_seg    *seg;
+	struct layout_prefix   prefix;
+	int                    rc;
+
+	M0_ENTRY("lid %llu, layer %lu", (unsigned long long)cl->cl_base.l_id,
+		 (unsigned long)layer->clr_idx);
+
+	emap = emap_from_cl(cl);
+	prefix_set(&prefix, cl->cl_base.l_id, layer->clr_idx);
+	rc = m0_emap_lookup(emap, tx, (struct m0_uint128 *)&prefix, 0, &it);
+	if (rc != 0) {
+		m0_layout__log("extents_indb_delete",
+			       "failed to lookup into layer_emap",
+			       M0_LAYOUT_ADDB_LOC_COMP_LAYER_EMAP_ADD_2,
+			       &cl->cl_base.l_addb_ctx, cl->cl_base.l_id,
+			       rc);
+		return rc;
+	}
+
+	seg = m0_emap_seg_get(&it);
+	M0_ASSERT(seg->ee_ext.e_start == 0);
+	while (1) {
+		if (seg->ee_val != M0_CLRES_INVALID) {
+			rc = ext_indb_write_internal(&it, layer,
+						     &seg->ee_ext,
+						     M0_CLRES_INVALID,
+						     !INMEM_LIST_UPDATE);
+			if (rc != 0) {
+				M0_LOG(M0_ERROR, "lid %llu, layer %lu, "
+				       "failed to delete extent, rc %d",
+				       (unsigned long long)cl->cl_base.l_id,
+				       (unsigned long)layer->clr_idx, rc);
+				break;
+			}
+		}
+		if (m0_emap_ext_is_last(&seg->ee_ext))
+			break;
+		m0_emap_next(&it);
+		seg = m0_emap_seg_get(&it);
+	}
+	M0_ASSERT(seg->ee_ext.e_end == M0_BINDEX_MAX + 1);
+
+	/*
+	 * Combine all the invalid extents into one, by adding an
+	 * invalid extent with the complete offset space.
+	 */
+	rc = single_ext_indb_write(&it, layer);
+	m0_emap_close(&it);
+	M0_RETURN(rc);
+}
+
+static int comp_layout_indb_delete(struct m0_composite_layout *cl,
+				   struct m0_db_tx *tx, bool in_update_path)
+{
+	struct m0_composite_layer *layer;
+	struct m0_emap            *emap;
+	struct layout_prefix       prefix;
+	int                        rc;
+
+	M0_ENTRY("lid %llu", (unsigned long long)cl->cl_base.l_id);
+	emap = emap_from_cl(cl);
+
+	/**
+	 * A composite layout can be deleted from the DB if and only if none of
+	 * its layers contain any valid extents.
+	 */
+	if (!in_update_path) {
+		rc = delete_verify(cl, tx);
+		if (rc != 0)
+			return rc;
+	}
 
-	rc = 0; /* To keep the compiler happy. */
 	m0_tl_for(comp_layer, &cl->cl_layers, layer) {
+		if (in_update_path) {
+			rc = extents_indb_delete(cl, tx, layer);
+			if (rc != 0) {
+				M0_LOG(M0_ERROR, "lid %llu, layer %lu, "
+				       "Error while deleting extents from DB ",
+				       (unsigned long long)cl->cl_base.l_id,
+				       (unsigned long)layer->clr_idx);
+				return rc;
+			}
+		}
+
+		prefix_set(&prefix, cl->cl_base.l_id, layer->clr_idx);
+		rc = m0_emap_obj_delete(emap, tx, (struct m0_uint128 *)&prefix);
+		if (rc != 0) {
+			m0_layout__log("comp_layout_indb_delete",
+				       "failed to delete from layer_emap",
+				       M0_LAYOUT_ADDB_LOC_COMP_LAYER_EMAP_DEL,
+				       &cl->cl_base.l_addb_ctx,
+				       cl->cl_base.l_id, rc);
+			break;
+		}
+
 		rc = sublayout_id_indb_delete(cl, layer, tx);
 		if (rc != 0)
 			break;
@@ -2732,7 +2910,6 @@ static int ext_indb_lookup(struct m0_composite_layout *cl,
 				       M0_LAYOUT_ADDB_LOC_COMP_EXT_LOOKUP,
 				       &cl->cl_base.l_addb_ctx,
 				       cl->cl_base.l_id, rc);
-			m0_mutex_unlock(&cl->cl_base.l_lock);
 			return rc;
 		}
 
diff --git a/layout/layout_addb.h b/layout/layout_addb.h
index 8b49041..dfcca93 100644
--- a/layout/layout_addb.h
+++ b/layout/layout_addb.h
@@ -92,7 +92,6 @@ enum {
 	M0_LAYOUT_ADDB_LOC_COMP_LAYER_ALLOC        = 220,
 	M0_LAYOUT_ADDB_LOC_COMP_LAYER_ADD_1        = 230,
 	M0_LAYOUT_ADDB_LOC_COMP_LAYER_ADD_2        = 231,
-	M0_LAYOUT_ADDB_LOC_COMP_LAYER_ADD_3        = 232,
 	M0_LAYOUT_ADDB_LOC_COMP_ELIST_READ_1       = 240,
 	M0_LAYOUT_ADDB_LOC_COMP_ELIST_READ_2       = 241,
 	M0_LAYOUT_ADDB_LOC_COMP_EXT_ADD_INTERNAL   = 250,
@@ -108,10 +107,12 @@ enum {
 	M0_LAYOUT_ADDB_LOC_COMP_EMAP_READ_1        = 440,
 	M0_LAYOUT_ADDB_LOC_COMP_EMAP_READ_2        = 441,
 	M0_LAYOUT_ADDB_LOC_COMP_EMAP_READ_3        = 442,
-	M0_LAYOUT_ADDB_LOC_COMP_LAYOUT_DEL         = 450,
-	M0_LAYOUT_ADDB_LOC_COMP_EXT_LOOKUP         = 460,
-	M0_LAYOUT_ADDB_LOC_COMP_EMAP_IT_SET        = 470,
-	M0_LAYOUT_ADDB_LOC_COMP_INST_BUILD         = 480,
+	M0_LAYOUT_ADDB_LOC_COMP_EXT_WRITE          = 450,
+	M0_LAYOUT_ADDB_LOC_COMP_LAYOUT_DEL         = 460,
+	M0_LAYOUT_ADDB_LOC_COMP_LAYER_EMAP_DEL     = 470,
+	M0_LAYOUT_ADDB_LOC_COMP_EXT_LOOKUP         = 480,
+	M0_LAYOUT_ADDB_LOC_COMP_EMAP_IT_SET        = 490,
+	M0_LAYOUT_ADDB_LOC_COMP_INST_BUILD         = 500,
 
 	M0_LAYOUT_ADDB_LOC_NR
 };
diff --git a/layout/ut/composite.c b/layout/ut/composite.c
index 5de798b..7d8f38a 100644
--- a/layout/ut/composite.c
+++ b/layout/ut/composite.c
@@ -385,6 +385,7 @@ static int composite_build(uint64_t lid,
 	return 0;
 }
 
+//todo layout add now adds the layers as well. Make related changes to UT
 /*
  * Adds layers to the provided composite layout.
  * The 'number of extents, start offset and end offset are varied (incremented
@@ -410,7 +411,6 @@ static int composite_layers_add(struct m0_composite_layout *cl,
 	/* Pre-create the sublayouts to be used for the layer 1 and above. */
 	sublayouts_precreate(cl->cl_base.l_id, cl->cl_base.l_dom, layers_nr);
 
-	m0_mutex_lock(&cl->cl_base.l_lock);
 	extents_nr = min_extents_nr;
 	for (i = 1; i < layers_nr; ++i /*, todo ++extents_nr */) {
 		sublayout_id = cl->cl_base.l_id * 100 + i;
@@ -441,7 +441,6 @@ static int composite_layers_add(struct m0_composite_layout *cl,
 					approximate_end_offset,
 					if_contiguous_extents);
 	}
-	m0_mutex_unlock(&cl->cl_base.l_lock);
 	return rc;
 }
 
@@ -1911,6 +1910,203 @@ int test_add_composite(uint64_t lid,
 }
 
 #ifndef __KERNEL__
+/* Tests the API m0_layout_update(), for the COMPOSITE layout type. */
+int test_update_composite(uint64_t lid,
+			  struct m0_layout_domain *domain,
+			  uint32_t layers_nr,
+			  uint32_t min_extents_nr,
+			  m0_bindex_t min_start_offset,
+			  m0_bindex_t approximate_end_offset,
+			  bool if_contiguous_extents,
+			  bool existing_test,
+			  bool failure_test)
+{
+	m0_bcount_t                       num_bytes;
+	void                             *area;
+	struct m0_composite_layout       *cl;
+	struct m0_layout                 *l1;
+	struct m0_layout                 *l1_copy;
+	struct m0_layout                 *l2;
+	//struct m0_layout                 *l_lookup;
+	struct m0_db_pair                 pair;
+	struct m0_db_tx                   tx;
+	//struct m0_composite_layer        *layer;
+	//struct m0_composite_layer_extent *lr_ext;
+	struct m0_ext                     ext_to_operate;
+	uint32_t                          layer_id_lookup;
+	struct m0_ext                     ext_lookup;
+	uint64_t                          ext_state_lookup;
+	struct m0_layout                 *sublayout_lookup;
+	uint32_t                          i;
+	int                               rc_tmp;
+	int                               rc;
+
+	allocate_area(domain, ADDITIONAL_BYTES_NONE, &num_bytes, &area);
+
+	/* Build a layout object. */
+	rc = composite_build(lid, domain, min_extents_nr,
+			     min_start_offset, approximate_end_offset,
+			     if_contiguous_extents, &cl, !FAILURE_TEST);
+	M0_UT_ASSERT(rc == 0);
+	M0_UT_ASSERT(list_lookup(domain, lid) == &cl->cl_base);
+
+	if (existing_test) {
+		/* Add the layout object to the DB. */
+		rc = m0_db_tx_init(&tx, domain->ld_dbenv, DBFLAGS);
+		M0_UT_ASSERT(rc == 0);
+		pair_set(&pair, &lid, area, num_bytes);
+		rc = m0_layout_add(&cl->cl_base, &tx, &pair);
+		if (failure_test)
+			M0_UT_ASSERT(rc == LO_ENCODE_ERR);
+			//todo rc == -ENOENT when cursor_init error is injected
+		else
+			M0_UT_ASSERT(rc == 0);
+		rc_tmp = m0_db_tx_commit(&tx);
+		M0_UT_ASSERT(rc_tmp == 0);
+
+		//todo See how to exercise having added a few layers to the cl
+		//without writing those in the DB.
+		/* Add layers to the composite layout. */
+		rc = m0_db_tx_init(&tx, domain->ld_dbenv, DBFLAGS);
+		M0_UT_ASSERT(rc == 0);
+		rc = composite_layers_add(cl, &tx, layers_nr, min_extents_nr,
+					  min_start_offset,
+					  approximate_end_offset,
+					  if_contiguous_extents,
+					  !LAYER_ADD_FAILURE_TEST);
+		M0_UT_ASSERT(rc == 0);
+		rc_tmp = m0_db_tx_commit(&tx);
+		M0_UT_ASSERT(rc_tmp == 0);
+	} else {
+		/* Add layers only in memory. */
+		M0_UT_ASSERT(domain->ld_is_db_available == true);
+		domain_ldb_available_set(domain, false);
+		rc = composite_layers_add(cl, NULL, layers_nr, min_extents_nr,
+					  min_start_offset,
+					  approximate_end_offset,
+					  if_contiguous_extents,
+					  !LAYER_ADD_FAILURE_TEST);
+		M0_UT_ASSERT(rc == 0);
+		domain_ldb_available_set(domain, true);
+	}
+
+	l1 = &cl->cl_base;
+
+	/* Verify the original user count is as expected. */
+	M0_UT_ASSERT(l1->l_user_count == 0);
+
+	/* Alter the in-memory layout object. */
+	/* 1. Alter its user count. */
+	for (i = 0; i < 100; ++i)
+		m0_layout_user_count_inc(l1);
+	M0_UT_ASSERT(l1->l_user_count == 100);
+
+	/* 2. Add an extent to its top-most layer - only in memory. */
+	M0_UT_ASSERT(domain->ld_is_db_available == true);
+	domain_ldb_available_set(domain, false);
+	extent_to_be_operated(cl, if_contiguous_extents, 1, 1,
+			      NON_EXISTING, &ext_to_operate);
+	rc = m0_composite_layer_ext_lookup(cl, ext_to_operate.e_start + 1,
+					   NULL, &ext_lookup, &layer_id_lookup,
+					   &ext_state_lookup,
+					   &sublayout_lookup);
+	M0_UT_ASSERT(rc == -ENOENT);
+	rc = m0_composite_layer_ext_add(cl, cl->cl_layers_nr - 1,
+					&ext_to_operate, M0_CLRES_FLATTENING,
+					NULL);
+	M0_UT_ASSERT(rc == 0);
+	rc = m0_composite_layer_ext_lookup(cl, ext_to_operate.e_start + 1,
+					   NULL, &ext_lookup, &layer_id_lookup,
+					   &ext_state_lookup,
+					   &sublayout_lookup);
+	M0_UT_ASSERT(rc == 0);
+	domain_ldb_available_set(domain, true);
+
+	rc = m0_db_tx_init(&tx, domain->ld_dbenv, DBFLAGS);
+	M0_UT_ASSERT(rc == 0);
+	rc = m0_composite_layer_ext_lookup(cl, ext_to_operate.e_start + 1,
+					   &tx, &ext_lookup, &layer_id_lookup,
+					   &ext_state_lookup,
+					   &sublayout_lookup);
+	M0_UT_ASSERT(rc == -ENOENT);
+	rc_tmp = m0_db_tx_commit(&tx);
+	M0_UT_ASSERT(rc_tmp == 0);
+
+	/* 3. Add a layer to it. */
+	//todo
+
+	/* 4. Delete a layer from it. */
+	//todo
+
+	/* Update the layout object in the DB. */
+	pair_set(&pair, &lid, area, num_bytes);
+	rc = m0_db_tx_init(&tx, domain->ld_dbenv, DBFLAGS);
+	M0_UT_ASSERT(rc == 0);
+
+	rc = m0_layout_update(l1, &tx, &pair);
+	if (failure_test)
+		M0_UT_ASSERT(rc == LO_ENCODE_ERR || rc == L_TABLE_UPDATE_ERR);
+	else
+		M0_UT_ASSERT(rc == 0);
+	rc_tmp = m0_db_tx_commit(&tx);
+	M0_UT_ASSERT(rc_tmp == 0);
+
+	/* verify that the ext is updated right. */
+	rc = m0_db_tx_init(&tx, domain->ld_dbenv, DBFLAGS);
+	M0_UT_ASSERT(rc == 0);
+	rc = m0_composite_layer_ext_lookup(cl, ext_to_operate.e_start + 1,
+					   &tx, &ext_lookup, &layer_id_lookup,
+					   &ext_state_lookup,
+					   &sublayout_lookup);
+	M0_UT_ASSERT(rc == 0);
+	rc_tmp = m0_db_tx_commit(&tx);
+	M0_UT_ASSERT(rc_tmp == 0);
+
+	/*
+	 * Since the auxiliary tables for composite layout type are updated
+	 * with the m0_layout_update() operation, m0_layout_update() on a
+	 * layout with composite type that does not exist in the DB results
+	 * into the layout being written to the DB.
+	 */
+	if (!failure_test)
+		composite_layout_copy(l1, &l1_copy);
+
+	/* Delete the in-memory layout. */
+	m0_layout_put(l1);
+	M0_UT_ASSERT(list_lookup(domain, lid) == NULL);
+
+	if (!failure_test) {
+		//Verify structuring of code in this fn e.g. where shud be the
+		//check for user count, extent verification  etc.
+		/*
+		 * Lookup for the layout object from the DB to verify that its
+		 * user count is indeed updated.
+		 */
+		rc = layout_lookup(lid, domain, &m0_composite_layout_type,
+				   !FAILURE_TEST, &l2);
+		M0_UT_ASSERT(rc == 0);
+		M0_UT_ASSERT(l2->l_user_count == 100);
+		M0_UT_ASSERT(m0_ref_read(&l2->l_ref) == 1);
+
+		/*
+		 * Compare the two layouts - one created earlier here and the
+		 * one that is looked up from the DB.
+		 */
+		composite_layout_compare(l1_copy, l2, false);
+		composite_layout_copy_delete(l1_copy);
+
+		/* Delete the in-memory layout. */
+		m0_layout_put(l2);
+		M0_UT_ASSERT(list_lookup(domain, lid) == NULL);
+	}
+
+	/* Delete the precreated sublayouts. */
+	sublayouts_delete(domain, lid, layers_nr);
+
+	m0_free(area);
+	return rc;
+}
+
 /* Tests the API m0_layout_delete(), for the COMPOSITE layout type. */
 int test_delete_composite(uint64_t lid,
 			  struct m0_layout_domain *domain,
@@ -1981,6 +2177,7 @@ int test_delete_composite(uint64_t lid,
 	/* Delete all the extents associated with the composite layout. */
 	rc = m0_db_tx_init(&tx, domain->ld_dbenv, DBFLAGS);
 	M0_UT_ASSERT(rc == 0);
+
 	m0_tl_for(comp_layer, &cl->cl_layers, layer) {
 		m0_tl_for(m0_composite_layer_ext, layer->clr_extents, lr_ext) {
 			/*
diff --git a/layout/ut/composite.h b/layout/ut/composite.h
index ea80323..2f7949d 100644
--- a/layout/ut/composite.h
+++ b/layout/ut/composite.h
@@ -100,6 +100,15 @@ int test_add_composite(uint64_t lid,
 		       bool duplicate_test,
 		       bool failure_test,
 		       bool layer_add_failure_test);
+int test_update_composite(uint64_t lid,
+			  struct m0_layout_domain *domain,
+			  uint32_t sublayouts_nr,
+			  uint32_t min_extents_nr,
+			  m0_bindex_t min_start_offset,
+			  m0_bindex_t approximate_end_offset,
+			  bool if_contiguous_extents,
+			  bool existing_test,
+			  bool failure_test);
 int test_delete_composite(uint64_t lid,
 			  struct m0_layout_domain *domain,
 			  uint32_t sublayouts_nr,
diff --git a/layout/ut/layout.c b/layout/ut/layout.c
index 10cbd26..5dc137c 100644
--- a/layout/ut/layout.c
+++ b/layout/ut/layout.c
@@ -1761,7 +1761,7 @@ static void test_composite_layer_ext_ops_inmem(void)
  *   need to be registered back at some other point (see test_init() for
  *   reference).
  */
-static void domain_ldb_available_set(struct m0_layout_domain *domain, bool val)
+void domain_ldb_available_set(struct m0_layout_domain *domain, bool val)
 {
 	domain->ld_is_db_available = val;
 }
@@ -2199,9 +2199,10 @@ static void test_update(void)
 	domain_ldb_available_set(&domain, true);
 
 	/*
-	 * Try to update a layout object with PDCLUST layout type and LIST enum
-	 * type, that does not exist in the DB to verify that the operation
-	 * fails with the error ENOENT.
+	 * Update a layout object with PDCLUST layout type and LIST enum type,
+	 * that does not exist in the DB. This results into the layout being
+	 * written newly to the DB as is done in case of m0_layout_add().
+	 * See m0_layout_update().
 	 */
 	lid = 20001;
 	rc = test_update_pdclust(lid, &domain,
@@ -2256,6 +2257,30 @@ static void test_update(void)
 	M0_UT_ASSERT(rc == 0);
 
 	//todo test_update_composite
+#if 1
+	/*
+	 * Update a layout object with COMPOSITE layout type, that does not
+	 * exist in the DB. This results into the layout being written newly
+	 * to the DB as is done in case of m0_layout_add().
+	 * See m0_layout_update().
+	 */
+	lid = 20006;
+	rc = test_update_composite(lid, &domain, 4, 15,
+				   lid * 100, lid * 100 * 100,
+				   !CONTIGUOUS_EXTENTS,
+				   !EXISTING_TEST,
+				   !FAILURE_TEST);
+	M0_UT_ASSERT(rc == 0);
+
+	/* Update a layout object with COMPOSITE layout type. */
+	lid = 20007;
+	rc = test_update_composite(lid, &domain, 4, 15,
+				   lid * 100, lid * 100 * 100,
+				   !CONTIGUOUS_EXTENTS,
+				   EXISTING_TEST,
+				   !FAILURE_TEST);
+	M0_UT_ASSERT(rc == 0);
+#endif
 
 	domain_ldb_available_set(&domain, false);
 }
diff --git a/layout/ut/layout.h b/layout/ut/layout.h
index acd5f02..bde6939 100644
--- a/layout/ut/layout.h
+++ b/layout/ut/layout.h
@@ -44,6 +44,7 @@ enum {
 	CONTIGUOUS_EXTENTS       = true  /* For extents of a sub-layout */
 };
 
+void domain_ldb_available_set(struct m0_layout_domain *domain, bool val);
 void allocate_area(struct m0_layout_domain *domain,
 		   m0_bcount_t additional_bytes,
 		   m0_bcount_t *num_bytes,
diff --git a/layout/ut/pdclust.c b/layout/ut/pdclust.c
index ec45a80..2b472ae 100644
--- a/layout/ut/pdclust.c
+++ b/layout/ut/pdclust.c
@@ -1655,16 +1655,18 @@ int test_update_pdclust(uint64_t lid, struct m0_layout_domain *domain,
 		M0_UT_ASSERT(rc == LO_ENCODE_ERR || rc == L_TABLE_UPDATE_ERR);
 	else
 		M0_UT_ASSERT(rc == 0);
+	rc_tmp = m0_db_tx_commit(&tx);
+	M0_UT_ASSERT(rc_tmp == 0);
+
 	/*
 	 * Even a non-existing record can be written to the database using
 	 * the database update operation.
+	 * todo Mar 04 Do I need some change here - testing the update op for
+	 * a nonexisting layout?
 	 */
 	if (existing_test && !failure_test)
 		pdclust_layout_copy(enum_id, l1, &l1_copy);
 
-	rc_tmp = m0_db_tx_commit(&tx);
-	M0_UT_ASSERT(rc_tmp == 0);
-
 	/*
 	 * Update the in-memory layout object - update its user count. This is
 	 * to verify the functioning of m0_layout_user_count_dec().
@@ -1677,6 +1679,14 @@ int test_update_pdclust(uint64_t lid, struct m0_layout_domain *domain,
 	m0_layout_put(l1);
 	M0_UT_ASSERT(list_lookup(domain, lid) == NULL);
 
+	/*
+	 * Regarding the first condition in the if below,
+	 * Since auxiliary tables are not updated with an update operation,
+	 * m0_layout_update() on a a non-existing layout does not result
+	 * into the layout being written to the DB.
+	 * todo Shall return -EINVAL in case m0_layout_update() is invoked on a
+	 * a layout with pdclust type that does not exist in the DB.
+	 */
 	if (existing_test && !failure_test) {
 		/*
 		 * Lookup for the layout object from the DB to verify that its
-- 
1.8.3.2

