From e2f9aa29fadd1e6323d3048e3a46dbaf9bf72a51 Mon Sep 17 00:00:00 2001
From: "trupti.patil" <trupti_patil@xyratex.com>
Date: Fri, 22 Feb 2013 01:24:13 +0530
Subject: [PATCH 068/172] Code optimizations, reorg for logical reading
 sequence

---
 layout/composite.c    | 3818 ++++++++++++++++++++++++-------------------------
 layout/composite.h    |   14 +-
 layout/ut/composite.c |   19 +-
 layout/ut/layout.c    |    4 +-
 4 files changed, 1925 insertions(+), 1930 deletions(-)

diff --git a/layout/composite.c b/layout/composite.c
index 83a27f0..174d251 100644
--- a/layout/composite.c
+++ b/layout/composite.c
@@ -142,6 +142,29 @@ struct layout_prefix {
 	uint32_t lp_filler;
 };
 
+/**
+ * Operation to be performed on an extent, in the context of callbacks from
+ * m0_emap_paste().
+ */
+enum extent_op {
+	DELETE,
+	CUT_LEFT,
+	CUT_RIGHT
+};
+
+/** Position to add a new extent at, in the list of the extents. */
+enum extent_add_position {
+	ADD_AFTER,
+	ADD_BEFORE,
+	ADD_AT_TAIL
+};
+
+/** Flags used for better readability. */
+enum {
+	EXT_VALIDATE       = true,
+	INMEM_LIST_UPDATE  = true
+};
+
 M0_TL_DESCR_DEFINE(comp_layer, "composite-layer-list",
 		   M0_INTERNAL, struct m0_composite_layer,
 		   clr_linkage, clr_magic,
@@ -165,12 +188,11 @@ static bool composite_allocated_invariant(const struct m0_composite_layout *cl)
 		m0_mutex_is_locked(&cl->cl_base.l_lock) &&
 		cl->cl_layers_nr == 0 &&
 		comp_layer_tlist_is_empty(&cl->cl_layers);
-
 }
 
 static bool composite_invariant(const struct m0_composite_layout *cl)
 {
-	/* To verify that the layers are sequentially ordered. */
+	/* Used to verify that the layers are sequentially ordered. */
 	uint32_t i = 0;
 
 	return
@@ -203,8 +225,8 @@ static bool layer_invariant(const struct m0_composite_layer *layer)
 		return false;
 
 	/*
-	 * Since assignment can not be performed in a m0_tl_forall() loop,
-	 * it has not been used in this invariant.
+	 * Since assignment can not be performed in between a m0_tl_forall()
+	 * loop, it has not been used in this invariant.
 	 */
 	m0_tl_for(m0_composite_layer_ext, layer->clr_extents, lr_ext) {
 		M0_ASSERT(lr_ext->cle_ext.e_start == addr);
@@ -366,11 +388,11 @@ static void composite_delete(struct m0_layout *l)
 }
 
 /** Adds a layer to the in-memory layout. */
-static int layer_in_mem_add(struct m0_composite_layout *cl,
-			    struct m0_layout *sublayout,
-			    struct m0_tl *extlist,
-			    uint32_t ext_nr,
-			    struct m0_composite_layer **lr)
+static int layer_inmem_add(struct m0_composite_layout *cl,
+			   struct m0_layout *sublayout,
+			   struct m0_tl *extlist,
+			   uint32_t ext_nr,
+			   struct m0_composite_layer **lr)
 {
 	struct m0_composite_layer *layer;
 
@@ -386,7 +408,7 @@ static int layer_in_mem_add(struct m0_composite_layout *cl,
 		 extlist, (unsigned long)ext_nr);
 	M0_ALLOC_PTR(layer);
 	if (layer == NULL) {
-		m0_layout__log("layer_in_mem_add",
+		m0_layout__log("layer_inmem_add",
 			       "failed to allocate composite layer",
 			       M0_LAYOUT_ADDB_LOC_COMP_LAYER_ALLOC,
 			       &cl->cl_base.l_addb_ctx, cl->cl_base.l_id,
@@ -431,8 +453,8 @@ static void extlist_free(struct m0_tl *extlist)
  * to the DB that has been added to the in-memory layout. Hence, it is assumed
  * that it is the top-most layer that is getting deleted.
  */
-static void layer_in_mem_delete(struct m0_composite_layout *cl,
-				struct m0_composite_layer *layer)
+static void layer_inmem_delete(struct m0_composite_layout *cl,
+			       struct m0_composite_layer *layer)
 {
 	M0_PRE(layer->clr_idx == cl->cl_layers_nr - 1);
 
@@ -466,7 +488,7 @@ static int composite_populate(struct m0_composite_layout *cl,
 	M0_ENTRY("lid %llu", (unsigned long long)cl->cl_base.l_id);
 	m0_layout__populate(&cl->cl_base, user_count);
 
-	rc = layer_in_mem_add(cl, sublayout, extlist, ext_nr, &layer);
+	rc = layer_inmem_add(cl, sublayout, extlist, ext_nr, &layer);
 	M0_ASSERT(layer->clr_idx == 0);
 
 	M0_POST(ergo(rc == 0, composite_invariant(cl)));
@@ -527,7 +549,7 @@ static void composite_fini(struct m0_ref *ref)
 	m0_tl_for(comp_layer, &cl->cl_layers, layer) {
 		extlist_free(layer->clr_extents);
 		comp_layer_tlink_del_fini(layer);
-		/* Release the reference acquired by layer_in_mem_add(). */
+		/* Release the reference acquired by layer_inmem_add(). */
 		m0_layout_put(layer->clr_l);
 		/*
 		 * The user count for 'the sublayout associated with this
@@ -543,1999 +565,2167 @@ static void composite_fini(struct m0_ref *ref)
 	M0_LEAVE();
 }
 
-M0_INTERNAL struct m0_composite_layout *m0_layout_to_cl(
-						const struct m0_layout *l)
-{
-	struct m0_composite_layout *cl;
-
-	cl = bob_of(l, struct m0_composite_layout, cl_base, &composite_bob);
-	M0_POST(composite_invariant(cl));
-	return cl;
-}
-
-M0_INTERNAL struct m0_layout *m0_cl_to_layout(struct m0_composite_layout *cl)
-{
-	M0_PRE(composite_invariant(cl));
-	return &cl->cl_base;
-}
-
-/** Implementation of lo_recsize() for COMPOSITE layout type. */
-static m0_bcount_t composite_recsize(const struct m0_layout *l)
-{
-	return sizeof(struct m0_layout_rec);
-}
+static int layer_indb_add(struct m0_composite_layout *cl,
+			  struct m0_composite_layer *layer,
+			  struct m0_db_tx *tx);
 
-/** Implementation of lto_max_recsize() for COMPOSITE layout type. */
-static m0_bcount_t composite_max_recsize(struct m0_layout_domain *dom)
+M0_INTERNAL int m0_composite_layer_add(struct m0_composite_layout *cl,
+				       struct m0_layout *sublayout,
+				       struct m0_tl *extlist,
+				       uint32_t ext_nr,
+				       struct m0_db_tx *tx)
 {
-	return 0;
-}
-
-/**
- * Operation to be performed on an extent, in the context of callbacks from
- * m0_emap_paste().
- */
-enum extent_op {
-	DELETE,
-	CUT_LEFT,
-	CUT_RIGHT
-};
+	struct m0_composite_layer *layer;
+	int                        rc;
 
-/** Position to add a new extent at, in the list of the extents. */
-enum extent_add_position {
-	ADD_AFTER,
-	ADD_BEFORE,
-	ADD_AT_TAIL
-};
+	M0_PRE(composite_invariant(cl));
+	M0_PRE(m0_mutex_is_locked(&cl->cl_base.l_lock));
+	M0_PRE(m0_layout__invariant(sublayout));
+	M0_PRE(extlist != NULL);
+	M0_PRE(ergo(cl->cl_base.l_dom->ld_is_db_available, tx != NULL));
 
-static void prefix_set(struct layout_prefix *prefix,
-		       uint64_t composite_lid,
-		       uint32_t layer_idx)
-{
-	prefix->lp_l_id = composite_lid;
-	prefix->lp_layer_idx = layer_idx;
-	prefix->lp_filler = 0;
-}
+	M0_ENTRY("lid %llu, sublayout_id %llu, extlist %p, ext_nr %ld, tx %p",
+		 (unsigned long long)cl->cl_base.l_id,
+		 (unsigned long long)sublayout->l_id,
+		 extlist, (unsigned long)ext_nr, tx);
 
-static int ext_in_mem_find(struct m0_composite_layer *layer,
-			   const struct m0_ext *ext,
-			   uint64_t expected_ext_state,
-			   struct m0_composite_layer_extent **lr_ext_out)
-{
-	struct m0_composite_layer_extent *lr_ext;
-	bool                              ext_found;
-	int                               rc;
+	if (m0_composite_layer_ext_tlist_is_empty(extlist) || ext_nr == 0) {
+		m0_layout__log("m0_composite_layer_add",
+			       "Invalid list of extents",
+			       M0_LAYOUT_ADDB_LOC_COMP_LAYER_ADD_1,
+			       &cl->cl_base.l_addb_ctx, cl->cl_base.l_id,
+			       -EINVAL);
+		return -EINVAL;
+	}
 
-	M0_ENTRY("lid %llu, layer %lu, e_start %llu, e_end %llu, "
-		 "expected_e_state %llu",
-		 (unsigned long long)layer->clr_l->l_id,
-		 (unsigned long)layer->clr_idx,
-		 (unsigned long long)ext->e_start,
-		 (unsigned long long)ext->e_end,
-		 (unsigned long long)expected_ext_state);
+	rc = layer_inmem_add(cl, sublayout, extlist, ext_nr, &layer);
+	if (rc != 0) {
+		m0_layout__log("m0_composite_layer_add",
+			       "failed to write layer in memory",
+			       M0_LAYOUT_ADDB_LOC_COMP_LAYER_ADD_2,
+			       &cl->cl_base.l_addb_ctx, cl->cl_base.l_id, rc);
+		return rc;
+	}
+	M0_ASSERT(layer->clr_idx > 0);
 
-	ext_found = false;
-	m0_tl_for(m0_composite_layer_ext, layer->clr_extents, lr_ext) {
-		if (lr_ext->cle_ext.e_end <= ext->e_start)
-			continue;
-		else if (lr_ext->cle_ext.e_start == ext->e_start &&
-			 lr_ext->cle_ext.e_end == ext->e_end) {
-			M0_ASSERT(lr_ext->cle_state == expected_ext_state);
-			if (lr_ext->cle_state == expected_ext_state) {
-				ext_found = true;
-				break;
-			}
+	if (cl->cl_base.l_dom->ld_is_db_available) {
+		rc = layer_indb_add(cl, layer, tx);
+		if (rc != 0) {
+			m0_layout__log("m0_composite_layer_add",
+				       "failed to write layer in DB",
+				       M0_LAYOUT_ADDB_LOC_COMP_LAYER_ADD_3,
+				       &cl->cl_base.l_addb_ctx,
+				       cl->cl_base.l_id, rc);
+			layer_inmem_delete(cl, layer);
 		}
-	} m0_tl_endfor;
-
-	if (ext_found) {
-		rc = 0;
-		if (lr_ext_out != NULL)
-			*lr_ext_out = lr_ext;
-#ifndef __KERNEL__
-		printf("lid %llu, layer %lu, e_start %llu, e_end %llu, \n"
-			 "\t expected_e_state %llu, actual_e_state %llu \n",
-			 (unsigned long long)layer->clr_l->l_id,
-			 (unsigned long)layer->clr_idx,
-			 (unsigned long long)ext->e_start,
-			 (unsigned long long)ext->e_end,
-			 (unsigned long long)expected_ext_state,
-			 (unsigned long long)lr_ext->cle_state);
-#endif
-	} else
-		rc = -ENOENT;
+	}
 
+	M0_POST(ergo(rc == 0, layer_invariant(layer)));
+	M0_POST(composite_invariant(cl));
 	M0_RETURN(rc);
 }
 
-static int ext_in_mem_add_internal(struct m0_composite_layer *layer,
-				   struct m0_layout *l,
-				   struct m0_tl *extlist,
-				   const struct m0_ext *ext,
-				   uint64_t ext_state,
-				   uint32_t add_position,
-				   struct m0_composite_layer_extent *
-							adjacent_lr_ext)
+static struct m0_layout *layout_find(struct m0_layout_domain *dom,
+				     uint64_t lid)
 {
-	struct m0_composite_layer_extent *lr_ext;
+	struct m0_layout *sublayout;
 
-	/*
-	 * If the layer is yet to be created, then add directly to the
-	 * extlist provided.
+	sublayout = m0_layout_find(dom, lid);
+	/**
+	 * @todo Eventually, if the sublayout is not found in the cache, it
+	 * shall be fetched either from the DB or over the network, as
+	 * applicable.
+	 * This requiress:
+	 * - The m0_layout_domain to include the flag indicating if the network
+	 *   is available viz. ld_is_network_available along with the flag
+	 *   ld_is_db_available that is being added through the current patch.
+	 * - The layout id to be extended to 128 bit to store the layout type,
+	 *   so that the DB lookup can be performed for it.
+	 *
+	 * Until the time the above changes are implemented (through a task
+	 * lined up next to the current one), the user shall ensure that the
+	 * sublayouts are cached prior to 'creating a composite layout and
+	 * adding layers to it'. The following assert ensures the same.
+	 *
+	 * Remove the following assert once the above mentioned changes
+	 * are implemented.
 	 */
-	M0_PRE(ergo(layer == NULL, l != NULL && extlist != NULL));
-	M0_PRE(ergo(layer != NULL, l == NULL && extlist == NULL));
-	M0_PRE(!m0_ext_is_empty(ext));
-	M0_PRE(M0_IN(ext_state, (M0_CLRES_INVALID, M0_CLRES_VALID,
-				 M0_CLRES_FLATTENING)));
-	M0_PRE(M0_IN(add_position, (ADD_AFTER, ADD_BEFORE, ADD_AT_TAIL)));
-	M0_PRE(ergo(M0_IN(add_position, (ADD_AFTER, ADD_BEFORE)),
-		    adjacent_lr_ext != NULL &&
-		    m0_composite_layer_ext_tlink_is_in(adjacent_lr_ext)));
-	M0_PRE(ergo(add_position == ADD_AT_TAIL, adjacent_lr_ext == NULL));
+	M0_ASSERT(sublayout != NULL);
+	return sublayout;
+}
 
-#if 0
-#ifndef __KERNEL__
-	//todo Make this M0_DEBUG, not M0_ENTRY
-	printf("ext_in_mem_add_internal(1): e_start %llu, e_end %llu, ext %p, "
-		"adjacent_lr_ext_start %llu, adjacent_lr_ext_end %llu \n",
-		(unsigned long long)ext->e_start,
-		(unsigned long long)ext->e_end, ext,
-		(adjacent_lr_ext == NULL) ? 0 :
-		(unsigned long long)adjacent_lr_ext->cle_ext.e_start,
-		(adjacent_lr_ext == NULL) ? 0 :
-		(unsigned long long)adjacent_lr_ext->cle_ext.e_end);
-#endif
-#endif
+static int ext_inmem_add_internal(struct m0_composite_layer *layer,
+				  struct m0_layout *l,
+				  struct m0_tl *extlist,
+				  const struct m0_ext *ext,
+				  uint64_t ext_state,
+				  uint32_t add_position,
+				  struct m0_composite_layer_extent *
+							adjacent_lr_ext);
+static int comp_layout_indb_read(struct m0_composite_layout *cl,
+				 struct m0_db_tx *tx,
+				 uint32_t user_count);
+static int comp_layout_indb_add(struct m0_composite_layout *cl,
+				struct m0_db_tx *tx);
+static int comp_layout_indb_delete(struct m0_composite_layout *cl,
+				   struct m0_db_tx *tx);
+static int ext_indb_lookup(struct m0_composite_layout *cl,
+			   m0_bindex_t offset,
+			   struct m0_db_tx *tx,
+			   struct m0_ext *ext,
+			   uint32_t *layer_idx,
+			   uint64_t *ext_state,
+			   struct m0_layout **sublayout);
+static int emap_iterator_set(struct m0_composite_layout *cl,
+			     uint32_t layer_idx,
+			     const struct m0_ext *ext,
+			     struct m0_db_tx *tx,
+			     bool ext_validate,
+			     struct m0_emap_cursor *it);
+static int ext_indb_write(struct m0_emap_cursor *it,
+			  struct m0_composite_layer *layer,
+			  const struct m0_ext *ext,
+			  uint64_t new_ext_state,
+			  bool in_mem_list_update);
 
-	if (extlist == NULL)
-		extlist = layer->clr_extents;
-	if (l == NULL)
-		l = layer->clr_l;
+static int extlist_inbuf_read(struct m0_composite_layout *cl,
+			      struct m0_bufvec_cursor *cur,
+			      uint32_t extents_nr,
+			      struct m0_tl **extents)
+{
+	struct m0_tl  *extlist;
+	struct m0_ext *ext;
+	uint64_t      *ext_state;
+	uint32_t       i;
+	int            rc;
 
-	M0_ALLOC_PTR(lr_ext);
-	if (lr_ext == NULL) {
-		m0_layout__log("extlist_in_buf_read",
-			       "failed to allocate composite extent",
-			       M0_LAYOUT_ADDB_LOC_COMP_ELIST_READ_2,
-			       &l->l_addb_ctx, l->l_id, -ENOMEM);
+	M0_ENTRY("lid %llu", (unsigned long long)cl->cl_base.l_id);
+	M0_PRE(m0_bufvec_cursor_step(cur) >= extents_nr * sizeof *ext);
+
+	M0_ALLOC_PTR(extlist);
+	if (extlist == NULL) {
+		m0_layout__log("extlist_inbuf_read",
+			       "failed to allocate composite extent list",
+			       M0_LAYOUT_ADDB_LOC_COMP_ELIST_READ_1,
+			       &cl->cl_base.l_addb_ctx, cl->cl_base.l_id,
+			       -ENOMEM);
 		return -ENOMEM;
 	}
-	lr_ext->cle_ext = *ext;
-	lr_ext->cle_state = ext_state;
+	m0_composite_layer_ext_tlist_init(extlist);
 
-	if (M0_IN(add_position, (ADD_AFTER, ADD_BEFORE))) {
-		m0_composite_layer_ext_tlink_init(lr_ext);
-		if (add_position == ADD_AFTER)
-			m0_composite_layer_ext_tlist_add_after(adjacent_lr_ext,
-							       lr_ext);
-		else
-			m0_composite_layer_ext_tlist_add_before(adjacent_lr_ext,
-								lr_ext);
-	} else
-		m0_composite_layer_ext_tlink_init_at_tail(lr_ext, extlist);
+	rc = 0;
+	for (i = 0; i < extents_nr; ++i) {
+		ext = m0_bufvec_cursor_addr(cur);
+		m0_bufvec_cursor_move(cur, sizeof *ext);
+		ext_state = m0_bufvec_cursor_addr(cur);
+		m0_bufvec_cursor_move(cur, sizeof *ext_state);
 
-	if (layer != NULL)
-		M0_CNT_INC(layer->clr_extents_nr);
-	return 0;
-}
-
-static void ext_in_mem_del_internal(struct m0_composite_layer *layer,
-				    struct m0_composite_layer_extent *lr_ext)
-{
-#ifndef __KERNEL__
-	printf("ext_in_mem_del_internal(): lid %llu, layer %lu, \n"
-		"\te_start %llu, e_end %llu, \n",
-		 (unsigned long long)layer->clr_l->l_id,
-		 (unsigned long)layer->clr_idx,
-		 (unsigned long long)lr_ext->cle_ext.e_start,
-		 (unsigned long long)lr_ext->cle_ext.e_end);
-#endif
-	m0_composite_layer_ext_tlist_del(lr_ext);
-	m0_composite_layer_ext_tlink_fini(lr_ext);
-	m0_free(lr_ext);
-	M0_CNT_DEC(layer->clr_extents_nr);
+		if (m0_ext_is_empty(ext) ||
+		    !M0_IN(*ext_state, (M0_CLRES_INVALID,
+					M0_CLRES_VALID,
+				        M0_CLRES_FLATTENING))) {
+			m0_layout__log("extlist_inbuf_read",
+				       "Invalid extent found in the buffer",
+				       M0_LAYOUT_ADDB_LOC_COMP_ELIST_READ_3,
+				       &cl->cl_base.l_addb_ctx,
+				       cl->cl_base.l_id, -ENOMEM);
+			extlist_free(extlist);
+			return -EINVAL;
+		}
+		rc = ext_inmem_add_internal(NULL, &cl->cl_base, extlist,
+					    ext, *ext_state,
+					    ADD_AT_TAIL, NULL);
+		M0_ASSERT(rc == 0); //todo rm
+		if (rc != 0) {
+			//todo M0_LOG
+			extlist_free(extlist);
+			return rc;
+		}
+	}
+	*extents = extlist;
+	M0_RETURN(rc);
 }
 
-//todo check placement of this and a few of the following functions
 /**
- * @pre Since this function is used in the context of the callback from
- * m0_emap_paste(), it is confirmed that the extent is non-overlapping
- * with any of the other extents in the extent list.
+ * Parses 'the composite layout type specific information including all the
+ * layers' from the buffer provided and adds it to the in-memory layout.
  */
-static int ext_in_mem_add(struct m0_composite_layer *layer,
-			  const struct m0_ext *ext,
-			  uint64_t ext_state)
+static int comp_layout_inbuf_read(struct m0_composite_layout *cl,
+				  struct m0_bufvec_cursor *cur,
+				  uint32_t user_count)
 {
-	struct m0_composite_layer_extent *ext_to_insert_before;
-	struct m0_composite_layer_extent *ext_to_insert_after;
-	struct m0_composite_layer_extent *lr_ext;
-	int                               rc;
+	struct composite_header       *cl_header;
+	struct composite_layer_header *lr_header;
+	struct m0_layout              *sublayout;
+	struct m0_tl                  *extlist;
+	uint32_t                       i;
+	int                            rc = 0; /* To keep the compiler happy. */
 
-	M0_ENTRY("lid %llu, layer %lu, e_start %llu, e_end %llu, "
-		 "e_state %llu, ext %p ",
-		 (unsigned long long)layer->clr_l->l_id,
-		 (unsigned long)layer->clr_idx,
-		 (unsigned long long)ext->e_start,
-		 (unsigned long long)ext->e_end,
-		 (unsigned long long)ext_state,
-		 ext);
+	M0_PRE(composite_allocated_invariant(cl));
+	M0_PRE(cur != NULL);
+	M0_PRE(m0_bufvec_cursor_step(cur) >= sizeof *cl_header);
 
-#ifndef __KERNEL__
-	printf("ext_in_mem_add(1): lid %llu, layer %lu, "
-		"e_start %llu, e_end %llu, e_state %llu, ext %p\n",
-		 (unsigned long long)layer->clr_l->l_id,
-		 (unsigned long)layer->clr_idx,
-		 (unsigned long long)ext->e_start,
-		 (unsigned long long)ext->e_end,
-		 (unsigned long long)ext_state,
-		 ext);
-#endif
+	M0_ENTRY("lid %llu, user_count %lu",
+		 (unsigned long long)cl->cl_base.l_id,
+		 (unsigned long)user_count);
 
-	ext_to_insert_before = NULL;
-	ext_to_insert_after = NULL;
-	m0_tl_for(m0_composite_layer_ext, layer->clr_extents, lr_ext) {
-		if (ext->e_start < lr_ext->cle_ext.e_start)
-			ext_to_insert_before = lr_ext;
-		if (ext->e_start >= lr_ext->cle_ext.e_end)
-			ext_to_insert_after = lr_ext;
-		if (ext->e_start <= lr_ext->cle_ext.e_start)
-			break;
-	} m0_tl_endfor;
-	M0_ASSERT(ext_to_insert_before != NULL || ext_to_insert_after != NULL);
+	/* Read the composite layout header from the buffer. */
+	cl_header = m0_bufvec_cursor_addr(cur);
+	m0_bufvec_cursor_move(cur, sizeof *cl_header);
 
-#ifndef __KERNEL__
-	printf("ext_in_mem_add(2): lid %llu, layer %lu, "
-		"e_start %llu, e_end %llu, "
-		"e_state %llu, "
-		"ext_to_insert_after %p, ext_to_insert_before %p\n",
-		 (unsigned long long)layer->clr_l->l_id,
-		 (unsigned long)layer->clr_idx,
-		 (unsigned long long)ext->e_start,
-		 (unsigned long long)ext->e_end,
-		 (unsigned long long)ext_state,
-		 ext_to_insert_after, ext_to_insert_before);
-#endif
-	M0_LOG(M0_DEBUG, "ext_in_mem_add(2): lid %llu, layer %lu, "
-		"e_start %llu, e_end %llu, e_state %llu, "
-		"ext_to_insert_after %p, ext_to_insert_before %p",
-		 (unsigned long long)layer->clr_l->l_id,
-		 (unsigned long)layer->clr_idx,
-		 (unsigned long long)ext->e_start,
-		 (unsigned long long)ext->e_end,
-		 (unsigned long long)ext_state,
-		 ext_to_insert_after, ext_to_insert_before);
+	/* Read the layers from the buffer. */
+	M0_ASSERT(m0_bufvec_cursor_step(cur) >=
+		  cl_header->ch_layers_nr * sizeof *lr_header);
+	for (i = 0; i < cl_header->ch_layers_nr; ++i) {
+		lr_header = m0_bufvec_cursor_addr(cur);
+		m0_bufvec_cursor_move(cur, sizeof *lr_header);
+		sublayout = layout_find(cl->cl_base.l_dom, lr_header->clh_lid);
+		if (sublayout == NULL) {
+			M0_LOG(M0_ERROR, "lid %llu, sublayout with lid %llu "
+			       "does not exist",
+			       (unsigned long long)cl->cl_base.l_id,
+			       (unsigned long long)lr_header->clh_lid);
+			return -EINVAL;
+		}
 
-	if (ext_to_insert_after != NULL)
-		rc = ext_in_mem_add_internal(layer, NULL, NULL,
-					     ext, ext_state, ADD_AFTER,
-					     ext_to_insert_after);
-	else if (ext_to_insert_before != NULL)
-		rc = ext_in_mem_add_internal(layer, NULL, NULL,
-					     ext, ext_state, ADD_BEFORE,
-					     ext_to_insert_before);
-	M0_ASSERT(rc == 0); //handle
+		M0_ASSERT(lr_header->clh_idx == i);
+		rc = extlist_inbuf_read(cl, cur, lr_header->clh_extents_nr,
+					&extlist);
+		M0_ASSERT(rc == 0);
+
+		if (lr_header->clh_idx == 0) /* Zeroth layer */
+			rc = composite_populate(cl, sublayout, extlist,
+						lr_header->clh_extents_nr,
+						user_count);
+		else
+			rc = m0_composite_layer_add(cl, sublayout,
+						    extlist,
+						    lr_header->clh_extents_nr,
+						    NULL);
+		/*
+		 * Release the reference added by m0_layout_find(). In case of
+		 * success, m0_composite_layer_add() has added a reference on
+		 * this sublayout.
+		 */
+		m0_layout_put(sublayout);
+
+		if (rc != 0)
+			break;
+	}
 	M0_RETURN(rc);
 }
 
-#ifndef __KERNEL__
-/** Trims the existing extent as requested. */
-static int ext_in_mem_trim(struct m0_composite_layer *layer,
-			   enum extent_op extent_op,
-			   const struct m0_ext *ext_to_trim,
-			   uint64_t ext_state,
-			   const struct m0_ext *trim_reference_ext)
+/** Implementation of lo_decode() for composite layout type. */
+static int composite_decode(struct m0_layout *l,
+			    struct m0_bufvec_cursor *cur,
+			    enum m0_layout_xcode_op op,
+			    struct m0_db_tx *tx,
+			    uint32_t user_count)
 {
-	struct m0_composite_layer_extent *lr_ext;
-	int                               rc;
-
-	M0_PRE(M0_IN(extent_op, (CUT_LEFT, CUT_RIGHT)));
-	M0_ENTRY("lid %llu, layer %lu, extent_op %d, "
-		 "ext_to_trim_start %llu, ext_to_trim_end %llu, "
-		 "ext_state %llu, "
-		 "trim_ref_ext_start %llu, trim_ref_ext_end %llu",
-		 (unsigned long long)layer->clr_l->l_id,
-		 (unsigned long)layer->clr_idx, extent_op,
-		 (unsigned long long)ext_to_trim->e_start,
-		 (unsigned long long)ext_to_trim->e_end,
-		 (unsigned long long)ext_state,
-		 (unsigned long long)trim_reference_ext->e_start,
-		 (unsigned long long)trim_reference_ext->e_end);
+	struct m0_composite_layout *cl;
+	int                         rc;
 
-#ifndef __KERNEL__
-	printf("ext_in_mem_trim(): lid %llu, layer %lu, extent_op %d, "
-		 "ext_to_trim_start %llu, ext_to_trim_end %llu, "
-		 "ext_state %llu, "
-		 "trim_ref_ext_start %llu, trim_ref_ext_end %llu\n",
-		 (unsigned long long)layer->clr_l->l_id,
-		 (unsigned long)layer->clr_idx, extent_op,
-		 (unsigned long long)ext_to_trim->e_start,
-		 (unsigned long long)ext_to_trim->e_end,
-		 (unsigned long long)ext_state,
-		 (unsigned long long)trim_reference_ext->e_start,
-		 (unsigned long long)trim_reference_ext->e_end);
-#endif
+	M0_PRE(m0_layout__allocated_invariant(l));
+	M0_PRE(m0_mutex_is_locked(&l->l_lock));
+	M0_PRE(cur != NULL);
+	M0_PRE(M0_IN(op, (M0_LXO_DB_LOOKUP, M0_LXO_BUFFER_OP)));
+	M0_PRE(ergo(op == M0_LXO_DB_LOOKUP, tx != NULL));
 
-	rc = ext_in_mem_find(layer, ext_to_trim, ext_state, &lr_ext);
-	M0_ASSERT(rc == 0); //todo rm
-	if (rc == 0) {
-		M0_ASSERT(lr_ext->cle_ext.e_start <=
-			  trim_reference_ext->e_start);
-		M0_ASSERT(lr_ext->cle_ext.e_end >= trim_reference_ext->e_end);
+	M0_ENTRY("lid %llu", (unsigned long long)l->l_id);
+	cl = bob_of(l, struct m0_composite_layout, cl_base, &composite_bob);
+	M0_PRE(composite_allocated_invariant(cl));
 
-		if (extent_op == CUT_LEFT)
-			/* Retain left part of the existing extent. */
-			lr_ext->cle_ext.e_end = trim_reference_ext->e_start;
-		else
-			/* Retain right part of the existing extent. */
-			lr_ext->cle_ext.e_start = trim_reference_ext->e_end;
+	if (op == M0_LXO_BUFFER_OP) {
+		rc = comp_layout_inbuf_read(cl, cur, user_count);
+		if (rc != 0)
+			M0_LOG(M0_ERROR, "lid %llu, failed to read layout from"
+			       "the buffer",
+			       (unsigned long long)cl->cl_base.l_id);
+	} else {
+		rc = comp_layout_indb_read(cl, tx, user_count);
+		if (rc != 0)
+			M0_LOG(M0_ERROR, "lid %llu, failed to read layout from"
+			       "the DB",
+			       (unsigned long long)cl->cl_base.l_id);
 	}
-	M0_RETURN(rc);
+
+	M0_POST(ergo(rc == 0, composite_invariant(cl)));
+	M0_POST(ergo(rc != 0, composite_allocated_invariant(cl)));
+	M0_LEAVE("lid %llu, rc %d", (unsigned long long)l->l_id, rc);
+	return rc;
 }
 
-static int ext_in_mem_delete(struct m0_composite_layer *layer,
-			     const struct m0_ext *ext,
-			     uint64_t old_ext_state)
+static void comp_layout_inbuf_write(const struct m0_composite_layout *cl,
+				    struct m0_bufvec_cursor *out)
 {
+	struct m0_composite_layer        *layer;
+	struct composite_header           cl_header;
+	struct composite_layer_header     lr_header;
 	struct m0_composite_layer_extent *lr_ext;
-	struct m0_composite_layer_extent *lr_ext_to_delete;
-	bool                              lr_ext_to_delete_found;
-	int                               rc;
+	m0_bcount_t                       nbytes;
 
-	//todo rm M0_PRE(old_ext_state != M0_CLRES_INVALID);
-#ifndef __KERNEL__
-	printf("ext_in_mem_delete(): lid %llu, layer %lu, "
-		"e_start %llu, e_end %llu, old_e_state %llu, ext %p\n",
-		 (unsigned long long)layer->clr_l->l_id,
-		 (unsigned long)layer->clr_idx,
-		 (unsigned long long)ext->e_start,
-		 (unsigned long long)ext->e_end,
-		 (unsigned long long)old_ext_state, ext);
-#endif
+	M0_ENTRY("lid %llu", (unsigned long long)cl->cl_base.l_id);
 
-	M0_ENTRY("lid %llu, layer %lu, e_start %llu, e_end %llu, "
-		 "old_e_state %llu",
-		 (unsigned long long)layer->clr_l->l_id,
-		 (unsigned long)layer->clr_idx,
-		 (unsigned long long)ext->e_start,
-		 (unsigned long long)ext->e_end,
-		 (unsigned long long)old_ext_state);
+	/* Write composite layout header into the buffer. */
+	M0_ASSERT(m0_bufvec_cursor_step(out) >= sizeof cl_header);
+	cl_header.ch_layers_nr = cl->cl_layers_nr;
+	cl_header.ch_pad = 0;
+	nbytes = m0_bufvec_cursor_copyto(out, &cl_header, sizeof cl_header);
+	M0_ASSERT(nbytes == sizeof cl_header);
 
-	lr_ext_to_delete_found = false;
-	m0_tl_for(m0_composite_layer_ext, layer->clr_extents, lr_ext) {
-		if (ext->e_start > lr_ext->cle_ext.e_end)
-			continue;
-		if (ext->e_start == lr_ext->cle_ext.e_start) {
-			if (ext->e_end == lr_ext->cle_ext.e_end) {
-				lr_ext_to_delete = lr_ext;
-				lr_ext_to_delete_found = true;
-				break;
-			} else
-				/*
-				 * It is only during the process of an extent
-				 * getting added by splitting some existing
-				 * extent, when there could be two extents
-				 * starting with the same offset. So, this
-				 * continue is to find that other exact
-				 * matching extent.
-				 */
-				continue;
-		}
+	/*
+	 * Read layers information from the composite layout and store
+	 * it in the buffer.
+	 */
+	M0_ASSERT(m0_bufvec_cursor_step(out) >= cl->cl_layers_nr *
+		  sizeof lr_header);
+	m0_tl_for(comp_layer, &cl->cl_layers, layer) {
+		lr_header.clh_lid        = layer->clr_l->l_id;
+		lr_header.clh_idx        = layer->clr_idx;
+		lr_header.clh_extents_nr = layer->clr_extents_nr;
+		lr_header.clh_pad        = 0;
+		nbytes = m0_bufvec_cursor_copyto(out, &lr_header,
+						 sizeof lr_header);
+		m0_tl_for(m0_composite_layer_ext, layer->clr_extents, lr_ext) {
+			nbytes = m0_bufvec_cursor_copyto(out,
+							&lr_ext->cle_ext,
+							sizeof lr_ext->cle_ext);
+			M0_ASSERT(nbytes == sizeof lr_ext->cle_ext);
+
+			nbytes = m0_bufvec_cursor_copyto(out,
+						     &lr_ext->cle_state,
+						     sizeof(lr_ext->cle_state));
+			M0_ASSERT(nbytes == sizeof(lr_ext->cle_state));
+		} m0_tl_endfor;
 	} m0_tl_endfor;
 
-	if (lr_ext_to_delete_found && ext->e_end == lr_ext->cle_ext.e_end) {
-		M0_ASSERT(lr_ext_to_delete->cle_state == old_ext_state);
-		ext_in_mem_del_internal(layer, lr_ext_to_delete);
-		rc = 0;
-	} else
-		rc = -ENOENT;
-	M0_RETURN(rc);
+	M0_LEAVE("lid %llu", (unsigned long long)cl->cl_base.l_id);
 }
 
-static int ext_in_mem_adjust(struct m0_composite_layer *layer,
-			     enum extent_op extent_op,
-			     const struct m0_emap_seg *seg,
-			     const struct m0_ext *ext)
+/** Implementation of lo_encode() for composite layout type. */
+static int composite_encode(struct m0_layout *l,
+			    enum m0_layout_xcode_op op,
+			    struct m0_db_tx *tx,
+			    struct m0_bufvec_cursor *out)
 {
-	int rc;
-
-	M0_PRE(M0_IN(extent_op, (DELETE, CUT_LEFT, CUT_RIGHT)));
+	struct m0_composite_layout *cl;
+	int                         rc;
 
-#ifndef __KERNEL__
-	printf("ext_in_mem_adjust(): lid %llu, layer %lu, extent_op %d, "
-		 "seg_e_start %llu, seg_e_end %llu, seg_val %llu, "
-		 "e_start %llu, e_end %llu, ext %p\n",
-		 (unsigned long long)layer->clr_l->l_id,
-		 (unsigned long)layer->clr_idx, extent_op,
-		 (unsigned long long)seg->ee_ext.e_start,
-		 (unsigned long long)seg->ee_ext.e_end,
-		 (unsigned long long)seg->ee_val,
-		 (ext != NULL) ? (unsigned long long)ext->e_start : 0,
-		 (ext != NULL) ? (unsigned long long)ext->e_end : 0, ext);
-#endif
+	M0_PRE(l != NULL);
+	M0_PRE(m0_mutex_is_locked(&l->l_lock));
+	M0_PRE(M0_IN(op, (M0_LXO_DB_ADD, M0_LXO_DB_UPDATE,
+			  M0_LXO_DB_DELETE, M0_LXO_BUFFER_OP)));
+	M0_PRE(ergo(op != M0_LXO_BUFFER_OP, tx != NULL));
+	M0_PRE(out != NULL);
 
-	M0_ENTRY("lid %llu, layer %lu, extent_op %d, "
-		 "seg_e_start %llu, seg_e_end %llu, seg_val %llu, "
-		 "e_start %llu, e_end %llu",
-		 (unsigned long long)layer->clr_l->l_id,
-		 (unsigned long)layer->clr_idx, extent_op,
-		 (unsigned long long)seg->ee_ext.e_start,
-		 (unsigned long long)seg->ee_ext.e_end,
-		 (unsigned long long)seg->ee_val,
-		 (ext != NULL) ? (unsigned long long)ext->e_start : 0,
-		 (ext != NULL) ? (unsigned long long)ext->e_end : 0);
+	M0_ENTRY("%llu", (unsigned long long)l->l_id);
 
-	if (extent_op == DELETE)
+	cl = m0_layout_to_cl(l);
+	if (op == M0_LXO_BUFFER_OP) {
+		comp_layout_inbuf_write(cl, out);
+		rc = 0;
+	} else if (op == M0_LXO_DB_ADD) {
+		rc = comp_layout_indb_add(cl, tx);
+		if (rc != 0)
+			M0_LOG(M0_ERROR, "lid %llu, layout could not be "
+			       "added to the DB",
+			       (unsigned long long)cl->cl_base.l_id);
+	} else if (op == M0_LXO_DB_UPDATE) {
+		//todo Update needs to be supported
 		/*
-		 * The extent seg->ee_ext is replaced by some newer extent.
-		 * Hence, seg->ee_ext is asked to be deleted.
+		 * The auxiliary tables are not to be modified for a layout
+		 * update operation.
 		 */
-		rc = ext_in_mem_delete(layer, &seg->ee_ext, seg->ee_val);
-	else
-		rc = ext_in_mem_trim(layer, extent_op, &seg->ee_ext,
-				     seg->ee_val, ext);
-	M0_RETURN(rc);
+		rc = 0;
+	} else {
+		rc = comp_layout_indb_delete(cl, tx);
+		if (rc != 0)
+			M0_LOG(M0_ERROR, "lid %llu, layout could not be "
+			       "deleted from the DB",
+			       (unsigned long long)cl->cl_base.l_id);
+	}
+
+	M0_LEAVE("lid %llu, rc %d", (unsigned long long)l->l_id, rc);
+	return rc;
 }
-#endif /* __KERNEL__ */
 
 /**
- * Pastes an extent with the specified state into the on-disk extent map
- * associated with the specified layer'. With the help of m0_emap_paste(),
- * it deletes or truncates the overlappping extents as necessary.
- *
- * @param in_mem_list_update This flag indicates if the in-memory list of
- * the extents is to be updated in the context of the callbacks received from
- * m0_emap_paste().
- * - In case of initial addition of the extents into the on-disk extent map
- *   while a layer is getting added, the in-memory list is already up-to-date
- *   as what is to be written to the DB.
- * - In case an extent is to be added explicitly, after a layer has been added,
- *   then the in-memory list of the extents needs to be updated.
+ * Check if the exact provided extent with the exact provided state is present
+ * in the list of the extents.
  */
-static int ext_in_db_write(struct m0_emap_cursor *it,
-			   struct m0_composite_layer *layer,
-			   const struct m0_ext *ext_to_operate,
-			   uint64_t new_ext_state,
-			   bool in_mem_list_update)
+static int ext_inmem_find(struct m0_composite_layer *layer,
+			  const struct m0_ext *ext,
+			  uint64_t expected_ext_state,
+			  struct m0_composite_layer_extent **lr_ext_out)
 {
+	struct m0_composite_layer_extent *lr_ext;
+	bool                              ext_found;
+	int                               rc;
 
-	/* LAMBDA is not defined for the kernel space. */
-#ifndef __KERNEL__
-	struct m0_ext ext;
-	int           rc_cb;
-	int           rc;
-
-	M0_ENTRY("lid %llu, layer %lu, "
-		 "e_start %llu, e_end %llu, new_e_state %llu, "
-		 "in_mem_list_update %d, ext_to_operate %p",
+	M0_ENTRY("lid %llu, layer %lu, e_start %llu, e_end %llu, "
+		 "expected_e_state %llu",
 		 (unsigned long long)layer->clr_l->l_id,
 		 (unsigned long)layer->clr_idx,
-		 (unsigned long long)ext_to_operate->e_start,
-		 (unsigned long long)ext_to_operate->e_end,
-		 (unsigned long long)new_ext_state,
-		 in_mem_list_update ? 1 : 0, ext_to_operate);
-	M0_PRE(layer_invariant(layer));
+		 (unsigned long long)ext->e_start,
+		 (unsigned long long)ext->e_end,
+		 (unsigned long long)expected_ext_state);
 
-	/*
-	 * Insert a new segment into the layer's extent map, overwriting
-	 * parts of the map, as applicable.
-	 *
-	 * Some existing segments are deleted completely, others are cut.
-	 * m0_emap_paste() invokes supplied call-backs to notify the caller
-	 * about the changes in the map. These call-backs are used to adjust
-	 * the extents in the in-memory list of the extents for the specific
-	 * layer.
-	 *
-	 * Each call-back takes a segment argument, viz. seg. seg->ee_ext is
-	 * an extent associated with the specified layer as is stored in the
-	 * on-disk extent map and seg->ee_val is the state of that extent.
-	 *
-	 * Here is an example to illustrate the sequence of the operations
-	 * performed by m0_emap_paste() and how the in-memory list of the
-	 * extents is adjusted accordingly.
-	 *
-	 * For example, a layer contains an extent list (in-memory and in-DB)
-	 * as:
-	 * ext[0]: [0,                2200700)
-	 * ext[1]: [2200700,         56668025)
-	 * ext[2]: [56668025,       111135350)
-	 * ext[3]: [111135350,      165602675)
-	 * ext[4]: [165602675,      220070000)
-	 * ext[5]: [220070000,  M0_BINDEX_MAX)
-	 *
-	 * An extent [56668023, 165602677) is asked to be added into the list.
-	 *
-	 * In such a case, multiple small operations are performed internally
-	 * by m0_emap_paste() and the callbacks are sent appropriately. In
-	 * response to those callback, the in-memory list of the extents is
-	 * adjusted accordingly by using the ext_in_mem_adjust() function.
-	 *
-	 * The sequence goes as follows:
-	 * 1) From the extent [2200700, 56668025), its left part that is
-	 *    [2200700, 56668023) is retained, using the extent_op CUT_RIGHT.
-	 * 2) From the extent list, the extent [56668025, 111135350) is
-	 *    deleted using the extent_op DELETE.
-	 * 3) From the extent list, the extent [111135350, 165602675) is
-	 *    deleted using the extent_op DELETE.
-	 * 4) From the extent [165602675, 220070000), its right part that is
-	 *    [165602677, 220070000) is retained, using the extent_op
-	 *    CUT_LEFT.
-	 * 5) Finally, the complete extent [56668023, 165602677) is added.
-	 *
-	 * layer_invariant() is temporarily violated during these operations.
-	 */
+	ext_found = false;
+	m0_tl_for(m0_composite_layer_ext, layer->clr_extents, lr_ext) {
+		if (lr_ext->cle_ext.e_end <= ext->e_start)
+			continue;
+		else if (lr_ext->cle_ext.e_start == ext->e_start &&
+			 lr_ext->cle_ext.e_end == ext->e_end) {
+			M0_ASSERT(lr_ext->cle_state == expected_ext_state);
+			if (lr_ext->cle_state == expected_ext_state) {
+				ext_found = true;
+				break;
+			}
+		}
+	} m0_tl_endfor;
 
-	ext = *ext_to_operate; /* A copy for read-write. */
-#if 0
+	if (ext_found) {
+		rc = 0;
+		if (lr_ext_out != NULL)
+			*lr_ext_out = lr_ext;
 #ifndef __KERNEL__
-	printf("ext_in_db_write(): lid %llu, layer %lu, "
-		 "e_start %llu, e_end %llu, new_e_state %llu, "
-		 "in_mem_list_update %d, ext_to_operate %p, ext %p\n",
-		 (unsigned long long)layer->clr_l->l_id,
-		 (unsigned long)layer->clr_idx,
-		 (unsigned long long)ext_to_operate->e_start,
-		 (unsigned long long)ext_to_operate->e_end,
-		 (unsigned long long)new_ext_state,
-		 in_mem_list_update ? 1 : 0, ext_to_operate, &ext);
-#endif
+		printf("lid %llu, layer %lu, e_start %llu, e_end %llu, \n"
+			 "\t expected_e_state %llu, actual_e_state %llu \n",
+			 (unsigned long long)layer->clr_l->l_id,
+			 (unsigned long)layer->clr_idx,
+			 (unsigned long long)ext->e_start,
+			 (unsigned long long)ext->e_end,
+			 (unsigned long long)expected_ext_state,
+			 (unsigned long long)lr_ext->cle_state);
 #endif
-	rc_cb = 0;
-	rc = m0_emap_paste(it, &ext, new_ext_state,
-		LAMBDA(void, (struct m0_emap_seg *seg) {
-			/* Extent deletion. */
-			if (in_mem_list_update) {
-				rc_cb = rc_cb ?: ext_in_mem_adjust(layer,
-								   DELETE,
-								   seg,
-								   NULL);
-			}
-		}),
-		LAMBDA(void, (struct m0_emap_seg *seg,
-			      struct m0_ext *extent,
-			      uint64_t val) {
-			/* Cut left. */
-			if (in_mem_list_update) {
-				rc_cb = rc_cb ?: ext_in_mem_adjust(layer,
-								   CUT_LEFT,
-								   seg,
-								   extent);
-			}
-		}),
-		LAMBDA(void, (struct m0_emap_seg *seg,
-			      struct m0_ext *extent,
-			      uint64_t val) {
-			/* Cut right. */
-			if (in_mem_list_update) {
-				rc_cb = rc_cb ?: ext_in_mem_adjust(layer,
-								   CUT_RIGHT,
-								   seg,
-								   extent);
-			}
-		}));
-
-	//todo If rc != 0, add m0_layout__log here.
-
-	rc = rc ?: rc_cb;
+	} else
+		rc = -ENOENT;
 
-	if (rc == 0 && in_mem_list_update) {
-		/*
-		 * Now that the deletion/trimming of the overlapping extents
-		 * from the in-memory list of the extents has been
-		 * handled above, let's add the ultimate whole extent.
-		 */
-		/*
-		 * todo Handle the case that there may be existing INVALID ext.
-		 * Refer to ext_in_mem_write().
-		 */
-		rc = ext_in_mem_find(layer, ext_to_operate, new_ext_state,
-				     NULL);
-		if (rc == -ENOENT)
-			rc = ext_in_mem_add(layer, ext_to_operate,
-					    new_ext_state);
-	}
 	M0_RETURN(rc);
-#else
-	/* This function is not expected to be invoked in the kernel mode. */
-	M0_ASSERT(0);
-	return -EPROTO;
-#endif /* __KERNEL__ */
-
-	M0_POST(layer_invariant(layer));
 }
 
-static void pair_set(struct m0_db_pair *pair,
-		     struct layer_sublayout_key *key,
-		     struct layer_sublayout_rec *rec,
-		     const struct m0_composite_layout *cl,
-		     uint32_t layer_idx,
-		     uint64_t sublayout_id)
+/**
+ * If the layer is provided, then add an extent to the extent list associated
+ * with the provided layer.
+ * If the layer is not provided (in cases where layer is yet to be created),
+ * then add the extent directly to the extlist provided.
+ */
+static int ext_inmem_add_internal(struct m0_composite_layer *layer,
+				  struct m0_layout *l,
+				  struct m0_tl *extlist,
+				  const struct m0_ext *ext,
+				  uint64_t ext_state,
+				  uint32_t add_position,
+				  struct m0_composite_layer_extent *
+							adjacent_lr_ext)
 {
-	struct composite_schema_data *csd;
+	struct m0_composite_layer_extent *lr_ext;
 
-	key->lrsmk_comp_lid      = cl->cl_base.l_id;
-	key->lrsmk_layer_idx     = layer_idx;
-	key->lrsmk_pad           = 0;
-	rec->lrsmr_sublayout_lid = sublayout_id;
-	csd = cl->cl_base.l_dom->ld_type_data[m0_composite_layout_type.lt_id];
-	m0_db_pair_setup(pair, &csd->csd_layer_sublayout,
-			 key, sizeof *key, rec, sizeof *rec);
-}
+	M0_PRE(ergo(layer == NULL, l != NULL && extlist != NULL));
+	M0_PRE(ergo(layer != NULL, l == NULL && extlist == NULL));
+	M0_PRE(!m0_ext_is_empty(ext));
+	M0_PRE(M0_IN(ext_state, (M0_CLRES_INVALID, M0_CLRES_VALID,
+				 M0_CLRES_FLATTENING)));
+	M0_PRE(M0_IN(add_position, (ADD_AFTER, ADD_BEFORE, ADD_AT_TAIL)));
+	M0_PRE(ergo(M0_IN(add_position, (ADD_AFTER, ADD_BEFORE)),
+		    adjacent_lr_ext != NULL &&
+		    m0_composite_layer_ext_tlink_is_in(adjacent_lr_ext)));
+	M0_PRE(ergo(add_position == ADD_AT_TAIL, adjacent_lr_ext == NULL));
 
-static int sublayout_id_in_db_lookup(struct m0_composite_layout *cl,
-				     uint32_t layer_idx,
-				     struct m0_db_tx *tx,
-				     uint64_t *sublayout_id)
-{
-	struct m0_db_pair           pair;
-	struct layer_sublayout_key  key;
-	struct layer_sublayout_rec  rec;
-	int                         rc;
+#if 1
+#ifndef __KERNEL__
+	//todo Make this M0_DEBUG, not M0_ENTRY
+	printf("ext_inmem_add_internal(1): e_start %llu, e_end %llu, ext %p, "
+		"adjacent_lr_ext_start %llu, adjacent_lr_ext_end %llu \n",
+		(unsigned long long)ext->e_start,
+		(unsigned long long)ext->e_end, ext,
+		(adjacent_lr_ext == NULL) ? 0 :
+		(unsigned long long)adjacent_lr_ext->cle_ext.e_start,
+		(adjacent_lr_ext == NULL) ? 0 :
+		(unsigned long long)adjacent_lr_ext->cle_ext.e_end);
+#endif
+#endif
 
-	M0_ENTRY("lid %llu, layer %lu, sublayout_id %llu",
-		 (unsigned long long)cl->cl_base.l_id,
-		 (unsigned long)layer_idx,
-		 (unsigned long long)*sublayout_id);
+	if (extlist == NULL)
+		extlist = layer->clr_extents;
+	if (l == NULL)
+		l = layer->clr_l;
 
-	pair_set(&pair, &key, &rec, cl, layer_idx,
-		 0 /* To be overwritten with the lookup */);
-	rc = m0_table_lookup(tx, &pair);
-	if (rc != 0 && rc != -ENOENT)
-		/**
-		 * The later condition is since the number of layers is not
-		 * known in advance while reading the layers from the DB.
-		 * Reference layers_in_db_read().
-		 * @todo If the number of layers is written to the primary
-		 * table, then get rid of the later condition here.
-		 */
-		m0_layout__log("sublayout_id_in_db_lookup",
-			       "failed to lookup into layer_sublayout table",
-			       M0_LAYOUT_ADDB_LOC_COMP_SUBLAYOUT_READ,
-			       &cl->cl_base.l_addb_ctx, cl->cl_base.l_id, rc);
-	else
-		*sublayout_id = rec.lrsmr_sublayout_lid;
-	m0_db_pair_fini(&pair);
+	M0_ALLOC_PTR(lr_ext);
+	if (lr_ext == NULL) {
+		m0_layout__log("extlist_inbuf_read",
+			       "failed to allocate composite extent",
+			       M0_LAYOUT_ADDB_LOC_COMP_ELIST_READ_2,
+			       &l->l_addb_ctx, l->l_id, -ENOMEM);
+		return -ENOMEM;
+	}
+	lr_ext->cle_ext = *ext;
+	lr_ext->cle_state = ext_state;
 
-	M0_POST(ergo(rc == 0, *sublayout_id > 0));
-	M0_RETURN(rc);
+	if (M0_IN(add_position, (ADD_AFTER, ADD_BEFORE))) {
+		m0_composite_layer_ext_tlink_init(lr_ext);
+		if (add_position == ADD_AFTER)
+			m0_composite_layer_ext_tlist_add_after(adjacent_lr_ext,
+							       lr_ext);
+		else
+			m0_composite_layer_ext_tlist_add_before(adjacent_lr_ext,
+								lr_ext);
+	} else
+		m0_composite_layer_ext_tlink_init_at_tail(lr_ext, extlist);
+
+	if (layer != NULL)
+		M0_CNT_INC(layer->clr_extents_nr);
+	return 0;
 }
 
-static int sublayout_id_in_db_add(struct m0_composite_layout *cl,
-				  const struct m0_composite_layer *layer,
-				  struct m0_db_tx *tx)
+/**
+ * @pre The caller has confirmed that the extent 'ext' is non-overlapping
+ * with any of the other extents in the extent list.
+ */
+static int ext_inmem_add(struct m0_composite_layer *layer,
+			 const struct m0_ext *ext,
+			 uint64_t ext_state)
 {
-	uint64_t                    sublayout_id;
-	struct m0_db_pair           pair;
-	struct layer_sublayout_key  key;
-	struct layer_sublayout_rec  rec;
-	int                         rc;
+	struct m0_composite_layer_extent *ext_to_insert_before;
+	struct m0_composite_layer_extent *ext_to_insert_after;
+	struct m0_composite_layer_extent *lr_ext;
+	int                               rc;
 
-	M0_ENTRY("lid %llu, layer %lu, sublayout_id %llu",
-		 (unsigned long long)cl->cl_base.l_id,
+	M0_ENTRY("lid %llu, layer %lu, e_start %llu, e_end %llu, "
+		 "e_state %llu, ext %p ",
+		 (unsigned long long)layer->clr_l->l_id,
 		 (unsigned long)layer->clr_idx,
-		 (unsigned long long)layer->clr_l->l_id);
-
-	if (layer->clr_idx > 0) {
-		/*
-		 * Verify that the sublayout for the zeroth layer has already
-		 * been written to the DB. It ensures that the zeroth layer
-		 * has already been added to the DB as a part of writing the
-		 * composite layout to the DB, by using the API
-		 * m0_layout_add().
-		 */
-		rc = sublayout_id_in_db_lookup(cl, 0, tx, &sublayout_id);
-		if (rc != 0) {
-			M0_LOG(M0_ERROR, "lid %llu, The composite layout does "
-			       "not seem to be added to DB, prior to adding "
-			       "the layer %lu",
-			       (unsigned long long)cl->cl_base.l_id,
-			       (unsigned long)layer->clr_idx);
-			return rc;
-		}
-	}
-
-	/*
-	 * Now, proceed to write the sublayout id for the layer->clr_idx'th
-	 * layer.
-	 */
-	pair_set(&pair, &key, &rec, cl, layer->clr_idx, layer->clr_l->l_id);
-	if (M0_FI_ENABLED("table_insert_err"))
-		{ rc = L_TABLE_INSERT_ERR; goto err1_injected; }
-	rc = m0_table_insert(tx, &pair);
-err1_injected:
-	if (rc != 0)
-		m0_layout__log("sublayout_id_in_db_add",
-			       "failed to insert into layer_sublayout table",
-			       M0_LAYOUT_ADDB_LOC_COMP_SUBLAYOUT_ADD,
-			       &layer->clr_l->l_addb_ctx, layer->clr_l->l_id,
-			       rc);
-	m0_db_pair_fini(&pair);
-	M0_RETURN(rc);
-}
+		 (unsigned long long)ext->e_start,
+		 (unsigned long long)ext->e_end,
+		 (unsigned long long)ext_state,
+		 ext);
 
-static int sublayout_id_in_db_delete(const struct m0_composite_layout *cl,
-				     const struct m0_composite_layer *layer,
-				     struct m0_db_tx *tx)
-{
-	struct m0_db_pair             pair;
-	struct layer_sublayout_key    key;
-	struct layer_sublayout_rec    rec;
-	int                           rc;
+	ext_to_insert_before = NULL;
+	ext_to_insert_after = NULL;
+	m0_tl_for(m0_composite_layer_ext, layer->clr_extents, lr_ext) {
+		if (ext->e_start < lr_ext->cle_ext.e_start)
+			ext_to_insert_before = lr_ext;
+		if (ext->e_start >= lr_ext->cle_ext.e_end)
+			ext_to_insert_after = lr_ext;
+		if (ext->e_start <= lr_ext->cle_ext.e_start)
+			break;
+	} m0_tl_endfor;
+	M0_ASSERT(ext_to_insert_before != NULL || ext_to_insert_after != NULL);
 
-	M0_ENTRY("lid %llu, layer %lu, sublayout_id %llu",
-		 (unsigned long long)cl->cl_base.l_id,
+#ifndef __KERNEL__
+	printf("ext_inmem_add(): lid %llu, layer %lu, "
+		"e_start %llu, e_end %llu, "
+		"e_state %llu, "
+		"ext_to_insert_after %p, ext_to_insert_before %p\n",
+		 (unsigned long long)layer->clr_l->l_id,
 		 (unsigned long)layer->clr_idx,
-		 (unsigned long long)layer->clr_l->l_id);
+		 (unsigned long long)ext->e_start,
+		 (unsigned long long)ext->e_end,
+		 (unsigned long long)ext_state,
+		 ext_to_insert_after, ext_to_insert_before);
+#endif
+	M0_LOG(M0_DEBUG, "ext_inmem_add(): lid %llu, layer %lu, "
+		"e_start %llu, e_end %llu, e_state %llu, "
+		"ext_to_insert_after %p, ext_to_insert_before %p",
+		 (unsigned long long)layer->clr_l->l_id,
+		 (unsigned long)layer->clr_idx,
+		 (unsigned long long)ext->e_start,
+		 (unsigned long long)ext->e_end,
+		 (unsigned long long)ext_state,
+		 ext_to_insert_after, ext_to_insert_before);
 
-	pair_set(&pair, &key, &rec, cl, layer->clr_idx, 0 /* Ignored */);
-	rc = m0_table_delete(tx, &pair);
-	if (rc != 0)
-		m0_layout__log("sublayout_id_in_db_delete",
-			       "failed to delete from layer_sublayout table",
-			       M0_LAYOUT_ADDB_LOC_COMP_SUBLAYOUT_DEL,
-			       &layer->clr_l->l_addb_ctx, layer->clr_l->l_id,
-			       rc);
-	m0_db_pair_fini(&pair);
+	if (ext_to_insert_after != NULL)
+		rc = ext_inmem_add_internal(layer, NULL, NULL,
+					    ext, ext_state, ADD_AFTER,
+					    ext_to_insert_after);
+	else if (ext_to_insert_before != NULL)
+		rc = ext_inmem_add_internal(layer, NULL, NULL,
+					    ext, ext_state, ADD_BEFORE,
+					    ext_to_insert_before);
+	M0_ASSERT(rc == 0); //handle
 	M0_RETURN(rc);
 }
 
-static struct m0_emap *emap_from_cl(const struct m0_composite_layout *cl)
+static struct m0_composite_layer *layer_find(
+					const struct m0_composite_layout *cl,
+					uint32_t layer_idx)
 {
-	struct composite_schema_data *csd;
+	struct m0_composite_layer *layer;
 
-	csd = cl->cl_base.l_dom->ld_type_data[m0_composite_layout_type.lt_id];
-	M0_ASSERT(csd != NULL);
-	return &csd->csd_layer_emap;
-}
+	M0_PRE(layer_idx < cl->cl_layers_nr);
 
-enum {
-	EXT_VALIDATE       = true,
-	IN_MEM_LIST_UPDATE = true
-};
+	layer = NULL;
+	m0_tl_for(comp_layer, &cl->cl_layers, layer) {
+		if (layer->clr_idx == layer_idx)
+			break;
+	} m0_tl_endfor;
+
+	M0_POST(layer != NULL && layer_invariant(layer));
+	return layer;
+}
 
-static int extmap_in_db_add(struct m0_composite_layout *cl,
-			    struct m0_composite_layer *layer,
-			    struct m0_db_tx *tx)
+/**
+ * Looks up for a valid extent with the given offset, starting with the
+ * top-most layer in the given composite layout.
+ */
+static int ext_inmem_lookup(struct m0_composite_layout *cl,
+			    m0_bindex_t offset,
+			    struct m0_ext *ext,
+			    uint32_t *layer_idx,
+			    uint64_t *ext_state,
+			    struct m0_layout **sublayout)
 {
-	struct m0_emap                   *emap;
-	struct m0_emap_cursor             it;
+	struct m0_composite_layer        *layer;
 	struct m0_composite_layer_extent *lr_ext;
-	struct m0_emap_seg               *seg;
-	struct layout_prefix              prefix;
+	bool                              found;
+	uint32_t                          i;
 	int                               rc;
 
-	M0_ENTRY("lid %llu, layer %lu", (unsigned long long)cl->cl_base.l_id,
-		 (unsigned long)layer->clr_idx);
+	M0_ENTRY("lid %llu, offset %llu", (unsigned long long)cl->cl_base.l_id,
+		 (unsigned long long)offset);
+#ifndef __KERNEL__
+	printf("ext_inmem_lookup(): lid %llu, offset %llu\n",
+		 (unsigned long long)cl->cl_base.l_id,
+		 (unsigned long long)offset);
+#endif
 
-	emap = emap_from_cl(cl);
-	prefix_set(&prefix, cl->cl_base.l_id, layer->clr_idx);
-	rc = m0_emap_obj_insert(emap, tx, (struct m0_uint128 *)&prefix,
-				M0_CLRES_INVALID);
-	if (rc != 0) {
-		m0_layout__log("extmap_in_db_add",
-			       "failed to insert into layer_emap",
-			       M0_LAYOUT_ADDB_LOC_COMP_LAYER_EMAP_ADD_1,
-			       &cl->cl_base.l_addb_ctx, cl->cl_base.l_id,
-			       rc);
-		return rc;
-	}
 
-	rc = m0_emap_lookup(emap, tx, (struct m0_uint128 *)&prefix, 0, &it);
-	if (rc != 0) {
-		m0_layout__log("extmap_in_db_add",
-			       "failed to lookup into layer_emap",
-			       M0_LAYOUT_ADDB_LOC_COMP_LAYER_EMAP_ADD_2,
-			       &cl->cl_base.l_addb_ctx, cl->cl_base.l_id,
-			       rc);
-		m0_emap_obj_delete(emap, tx, (struct m0_uint128 *)&prefix);
-		/*
-		 * If m0_emap_lookup() has failed for no apparent reason, it is
-		 * likely that m0_emap_obj_delete() too would fail. Hence,
-		 * ignoring its status.
-		 */
-		return rc;
-	}
+	/* Start the lookup with the top-most layer. */
+	layer = comp_layer_tlist_tail(&cl->cl_layers);
+	M0_ASSERT(layer != NULL);
+	i = cl->cl_layers_nr - 1;
+	found = false;
 
-	seg = m0_emap_seg_get(&it);
-	M0_ASSERT(seg->ee_ext.e_start == 0);
-	M0_ASSERT(seg->ee_ext.e_end == M0_BINDEX_MAX + 1);
-	M0_ASSERT(seg->ee_val == M0_CLRES_INVALID);
+	while (layer != NULL) {
+		M0_ASSERT(layer->clr_idx == i);
+		m0_tl_for(m0_composite_layer_ext, layer->clr_extents, lr_ext) {
+			if (offset >= lr_ext->cle_ext.e_end)
+				continue;
+			else {
+				M0_ASSERT(offset >= lr_ext->cle_ext.e_start);
+				M0_ASSERT(offset < lr_ext->cle_ext.e_end);
+				if (lr_ext->cle_state != M0_CLRES_INVALID)
+					found = true;
+				break;
+			}
+		} m0_tl_endfor;
+		if (found)
+			break;
+		layer = comp_layer_tlist_prev(&cl->cl_layers, layer);
+		--i;
+	}
 
-	m0_tl_for(m0_composite_layer_ext, layer->clr_extents, lr_ext) {
-		M0_ASSERT(M0_IN(lr_ext->cle_state, (M0_CLRES_INVALID,
-						    M0_CLRES_VALID,
-						    M0_CLRES_FLATTENING)));
-		rc = ext_in_db_write(&it, layer,
-				     &lr_ext->cle_ext, lr_ext->cle_state,
-				     !IN_MEM_LIST_UPDATE);
-		if (rc != 0) {
-			M0_LOG(M0_ERROR, "lid %llu, layer %lu, "
-			       "failed to write extent, rc %d",
-			       (unsigned long long)cl->cl_base.l_id,
-			       (unsigned long)layer->clr_idx, rc);
-			m0_emap_close(&it);
-			return rc;
-		}
-	} m0_tl_endfor;
+	if (found == true) {
+		*layer_idx = layer->clr_idx;
+		*ext = lr_ext->cle_ext;
+		*ext_state = lr_ext->cle_state;
+		layer = layer_find(cl, *layer_idx);
+		M0_ASSERT(layer != NULL);
+		*sublayout = layer->clr_l;
+		rc = 0;
+	} else
+		rc = -ENOENT;
 
-	m0_emap_close(&it);
+#ifndef __KERNEL__
+	printf("ext_inmem_lookup(): lid %llu, offset %llu, "
+		"rc %d, layer_id %lu\n",
+		(unsigned long long)cl->cl_base.l_id,
+		(unsigned long long)offset, rc, (unsigned long)*layer_idx);
+#endif
 	M0_RETURN(rc);
 }
 
-static int layer_in_db_add(struct m0_composite_layout *cl,
-			   struct m0_composite_layer *layer,
-			   struct m0_db_tx *tx)
+M0_INTERNAL int m0_composite_layer_ext_lookup(struct m0_composite_layout *cl,
+					      m0_bindex_t offset,
+					      struct m0_db_tx *tx,
+					      struct m0_ext *ext,
+					      uint32_t *layer_idx,
+					      uint64_t *ext_state,
+					      struct m0_layout **sublayout)
 {
 	int rc;
 
 	M0_PRE(composite_invariant(cl));
-	/*
-	 * Zeroth layer is already written through comp_layout_in_db_add()
-	 * while adding the composite layout to the DB using m0_layout_add().
-	 */
-	M0_PRE(layer->clr_idx > 0);
-	M0_PRE(tx != NULL);
+	M0_PRE(offset >= 0 && offset <= M0_BINDEX_MAX);
+	M0_PRE(ext != NULL && layer_idx != NULL && ext_state != NULL &&
+	       sublayout != NULL);
+	M0_PRE(ergo(cl->cl_base.l_dom->ld_is_db_available, tx != NULL));
 
-	M0_ENTRY("lid %llu, layer %lu", (unsigned long long)cl->cl_base.l_id,
-		 (unsigned long)layer->clr_idx);
+	M0_ENTRY("lid %llu, offset %llu", (unsigned long long)cl->cl_base.l_id,
+		 (unsigned long long)offset);
+#ifndef __KERNEL__
+	printf("m0_composite_layer_ext_lookup(): lid %llu, offset %llu\n",
+		 (unsigned long long)cl->cl_base.l_id,
+		 (unsigned long long)offset);
+#endif
 
-	/* Add 'the sublayout id for this layer' to the DB. */
-	rc = sublayout_id_in_db_add(cl, layer, tx);
-	if (rc != 0)
-		M0_RETURN(rc);
+	m0_mutex_lock(&cl->cl_base.l_lock);
 
-	/* Add 'the extent map for this layer' to the DB. */
-	rc = extmap_in_db_add(cl, layer, tx);
+	if (!cl->cl_base.l_dom->ld_is_db_available)
+		rc = ext_inmem_lookup(cl, offset, ext,
+				      layer_idx, ext_state, sublayout);
+	else
+		rc = ext_indb_lookup(cl, offset, tx, ext,
+				     layer_idx, ext_state, sublayout);
+	M0_ASSERT(rc == 0 || rc == -ENOENT); //todo Handle, log etc
 
-	M0_POST(ergo(rc == 0, composite_invariant(cl)));
-	M0_RETURN(rc);
+	m0_mutex_unlock(&cl->cl_base.l_lock);
+	M0_LEAVE("lid %llu, offset %llu, rc %d, layer_id %lu",
+		 (unsigned long long)cl->cl_base.l_id,
+		 (unsigned long long)offset, rc, (unsigned long)*layer_idx);
+#ifndef __KERNEL__
+	printf("m0_composite_layer_ext_lookup(): lid %llu, offset %llu, "
+		"rc %d, layer_id %lu\n",
+		(unsigned long long)cl->cl_base.l_id,
+		(unsigned long long)offset, rc, (unsigned long)*layer_idx);
+#endif
+	M0_PRE(composite_invariant(cl));
+	return rc;
 }
 
-M0_INTERNAL int m0_composite_layer_add(struct m0_composite_layout *cl,
-				       struct m0_layout *sublayout,
-				       struct m0_tl *extlist,
-				       uint32_t ext_nr,
-				       struct m0_db_tx *tx)
+static void ext_inmem_del_internal(struct m0_composite_layer *layer,
+				   struct m0_composite_layer_extent *lr_ext)
 {
-	struct m0_composite_layer *layer;
-	int                        rc;
+#ifndef __KERNEL__
+	printf("ext_inmem_del_internal(): lid %llu, layer %lu, \n"
+		"\te_start %llu, e_end %llu, \n",
+		 (unsigned long long)layer->clr_l->l_id,
+		 (unsigned long)layer->clr_idx,
+		 (unsigned long long)lr_ext->cle_ext.e_start,
+		 (unsigned long long)lr_ext->cle_ext.e_end);
+#endif
+	m0_composite_layer_ext_tlist_del(lr_ext);
+	m0_composite_layer_ext_tlink_fini(lr_ext);
+	m0_free(lr_ext);
+	M0_CNT_DEC(layer->clr_extents_nr);
+}
 
-	M0_PRE(composite_invariant(cl));
-	M0_PRE(m0_mutex_is_locked(&cl->cl_base.l_lock));
-	M0_PRE(m0_layout__invariant(sublayout));
-	M0_PRE(extlist != NULL);
-	M0_PRE(ergo(cl->cl_base.l_dom->ld_is_db_available, tx != NULL));
+static int ext_split_internal(struct m0_composite_layer *layer,
+			      struct m0_composite_layer_extent *lr_ext,
+			      struct m0_indexvec *vec,
+			      m0_bindex_t scan)
+{
+	struct m0_ext ext;
+	m0_bcount_t   len;
+	uint32_t      i;
+	int           rc;
 
-	M0_ENTRY("lid %llu, sublayout_id %llu, extlist %p, ext_nr %ld, tx %p",
-		 (unsigned long long)cl->cl_base.l_id,
-		 (unsigned long long)sublayout->l_id,
-		 extlist, (unsigned long)ext_nr, tx);
+	M0_PRE(m0_composite_layer_ext_tlink_is_in(lr_ext));
 
-	if (m0_composite_layer_ext_tlist_is_empty(extlist) || ext_nr == 0) {
-		m0_layout__log("m0_composite_layer_add",
-			       "Invalid list of extents",
-			       M0_LAYOUT_ADDB_LOC_COMP_LAYER_ADD_1,
-			       &cl->cl_base.l_addb_ctx, cl->cl_base.l_id,
-			       -EINVAL);
-		return -EINVAL;
-	}
+#ifndef __KERNEL__
+	printf("ext_split_internal(): len0 %llu, len1 %llu, len2 %llu\n",
+		(unsigned long long)vec->iv_vec.v_count[0],
+		(unsigned long long)vec->iv_vec.v_count[1],
+		(unsigned long long)vec->iv_vec.v_count[2]);
+#endif
 
-	rc = layer_in_mem_add(cl, sublayout, extlist, ext_nr, &layer);
-	if (rc != 0) {
-		m0_layout__log("m0_composite_layer_add",
-			       "failed to write layer in memory",
-			       M0_LAYOUT_ADDB_LOC_COMP_LAYER_ADD_2,
-			       &cl->cl_base.l_addb_ctx, cl->cl_base.l_id, rc);
-		return rc;
+	rc = -EINVAL; /* Just to ensure that this gets overwritten. */
+	for (i = 0; i < vec->iv_vec.v_nr; ++i) {
+		len = vec->iv_vec.v_count[i];
+		if (len != 0) {
+			ext.e_start = scan;
+			ext.e_end = scan = scan + len;
+			rc = ext_inmem_add_internal(layer, NULL, NULL,
+						    &ext, vec->iv_index[i],
+						    ADD_BEFORE, lr_ext);
+			M0_ASSERT(rc == 0); //todo Handle
+			if (rc != 0)
+				break;
+		}
 	}
-	M0_ASSERT(layer->clr_idx > 0);
+	ext_inmem_del_internal(layer, lr_ext);
+	return rc;
+}
 
-	if (cl->cl_base.l_dom->ld_is_db_available) {
-		rc = layer_in_db_add(cl, layer, tx);
-		if (rc != 0) {
-			m0_layout__log("m0_composite_layer_add",
-				       "failed to write layer in DB",
-				       M0_LAYOUT_ADDB_LOC_COMP_LAYER_ADD_3,
+static int ext_inmem_write(struct m0_composite_layout *cl,
+			   struct m0_composite_layer *layer,
+			   const struct m0_ext *ext,
+			   uint64_t ext_state,
+			   bool ext_validate)
+{
+	struct m0_composite_layer_extent *lr_ext;
+	struct m0_composite_layer_extent *lr_ext_next;
+	struct m0_composite_layer_extent *lr_ext_to_del;
+	struct m0_composite_layer_extent *ext_to_insert_into;
+	struct m0_ext                    *chunk;
+	struct m0_ext                     ext0 = *ext; /* A read-write copy. */
+	bool                              is_ultimate_ext_add;
+	int                               rc;
+	int                               rc1;
+
+	M0_PRE(layer_invariant(layer));
+	M0_PRE(!m0_ext_is_empty(ext));
+	M0_ENTRY("lid %llu, layer %lu, e_start %llu, e_end %llu, e_state %llu",
+		 (unsigned long long)layer->clr_l->l_id,
+		 (unsigned long)layer->clr_idx,
+		 (unsigned long long)ext->e_start,
+		 (unsigned long long)ext->e_end,
+		 (unsigned long long)ext_state);
+
+	/* Find the first nearest in-memory extent. */
+	ext_to_insert_into = NULL;
+	m0_tl_for(m0_composite_layer_ext, layer->clr_extents, lr_ext) {
+		if (ext->e_start >= lr_ext->cle_ext.e_start)
+			ext_to_insert_into = lr_ext;
+	} m0_tl_endfor;
+	M0_ASSERT(ext_to_insert_into != NULL);
+#ifndef __KERNEL__
+	printf("ext_inmem_write(1): lid %llu, layer %lu, \n"
+		"\te_start %llu, e_end %llu, e_state %llu, \n"
+		"\text_to_insert_into_start %llu, \n "
+		"\text_to_insert_into_end %llu\n",
+		 (unsigned long long)layer->clr_l->l_id,
+		 (unsigned long)layer->clr_idx,
+		 (unsigned long long)ext->e_start,
+		 (unsigned long long)ext->e_end,
+		 (unsigned long long)ext_state,
+		 (unsigned long long)ext_to_insert_into->cle_ext.e_start,
+		 (unsigned long long)ext_to_insert_into->cle_ext.e_end);
+#endif
+
+	if (ext_validate) {
+		M0_ASSERT(M0_IN(ext_to_insert_into->cle_state,
+				(M0_CLRES_INVALID, M0_CLRES_VALID,
+				 M0_CLRES_FLATTENING)));
+		if (ext_to_insert_into->cle_ext.e_start != ext->e_start ||
+		    ext_to_insert_into->cle_ext.e_end != ext->e_end ||
+		    ext_to_insert_into->cle_state == M0_CLRES_INVALID) {
+			rc = -EINVAL;
+			//todo M0_LOG?
+			m0_layout__log("ext_inmem_write",
+				       "A non-existing extent can not be "
+				       "updated or deleted",
+				       M0_LAYOUT_ADDB_LOC_COMP_EXT_UPDATE_2, //todo
 				       &cl->cl_base.l_addb_ctx,
 				       cl->cl_base.l_id, rc);
-			layer_in_mem_delete(cl, layer);
+			return rc;
 		}
 	}
 
-	M0_POST(ergo(rc == 0, layer_invariant(layer)));
-	M0_POST(composite_invariant(cl));
-	M0_RETURN(rc);
-}
-
-static struct m0_layout *layout_find(struct m0_layout_domain *dom,
-				     uint64_t lid)
-{
-	struct m0_layout *sublayout;
+	if (ext_to_insert_into->cle_ext.e_start == ext->e_start &&
+	    ext_to_insert_into->cle_ext.e_end == ext->e_end &&
+	    ext_to_insert_into->cle_state == ext_state)
+		/* The exact extent already exists. So, nothing to be done. */
+		M0_RETURN(0);
 
-	sublayout = m0_layout_find(dom, lid);
-	/**
-	 * @todo Eventually, if the sublayout is not found in the cache, it
-	 * shall be fetched either from the DB or over the network, as
-	 * applicable.
-	 * This requiress:
-	 * - The m0_layout_domain to include the flag indicating if the network
-	 *   is available viz. ld_is_network_available along with the flag
-	 *   ld_is_db_available that is being added through the current patch.
-	 * - The layout id to be extended to 128 bit to store the layout type,
-	 *   so that the DB lookup can be performed for it.
+	if (ext_to_insert_into->cle_ext.e_start == ext->e_start &&
+	    ext_to_insert_into->cle_ext.e_end == ext->e_end &&
+	    ext_to_insert_into->cle_state != ext_state) {
+		ext_to_insert_into->cle_state = ext_state;
+		/* The exact extent already exists but with different state. */
+		M0_RETURN(0);
+	}
+
+	chunk = &ext_to_insert_into->cle_ext;
+	M0_ASSERT(m0_ext_is_in(chunk, ext->e_start));
+
+	/*
+	 * Iterate over existing extents overlapping with the new one,
+	 * calculating for each, what parts have to be deleted and what remains.
 	 *
-	 * Until the time the above changes are implemented (through a task
-	 * lined up next to the current one), the user shall ensure that the
-	 * sublayouts are cached prior to 'creating a composite layout and
-	 * adding layers to it'. The following assert ensures the same.
+	 * In the worst case, an existing extent can split into three
+	 * parts.
 	 *
-	 * Remove the following assert once the above mentioned changes
-	 * are implemented.
+	 * Note that the "whole" new segment is inserted after all the
+	 * iterations of the following loop complete (see length[1]
+	 * assignment), thus violating the layer invariant until that point
+	 * (the map is "porous" during that time).
+	 *
+	 * This logic for extent addition has been inherited from
+	 * m0_emap_paste() that has been exercised for some time now and is
+	 * understood to be concrete! To look at an example illustrating the
+	 * functioning of m0_emap_paste(), see the note added in
+	 * ext_indb_write().
 	 */
-	M0_ASSERT(sublayout != NULL);
-	return sublayout;
-}
 
-static int extlist_in_buf_read(struct m0_composite_layout *cl,
-			       struct m0_bufvec_cursor *cur,
-			       uint32_t extents_nr,
-			       struct m0_tl **extents)
-{
-	struct m0_tl  *extlist;
-	struct m0_ext *ext;
-	uint64_t      *ext_state;
-	uint32_t       i;
-	int            rc;
+	is_ultimate_ext_add = false;
+	while (!m0_ext_is_empty(&ext0)) {
+		m0_bcount_t    length[3];
+		m0_bindex_t    bstart[3] = { 0 };
+		m0_bcount_t    consumed;
+		struct m0_ext  clip;
+		bool           split_required;
+		bool           delete_required;
+		struct m0_indexvec vec = {
+			.iv_vec = {
+				.v_nr    = 3,
+				.v_count = length
+			},
+			.iv_index = bstart
+		};
 
-	M0_ENTRY("lid %llu", (unsigned long long)cl->cl_base.l_id);
-	M0_PRE(m0_bufvec_cursor_step(cur) >= extents_nr * sizeof *ext);
+		m0_ext_intersection(&ext0, chunk, &clip);
+		M0_ASSERT(clip.e_start == ext0.e_start);
+		consumed = m0_ext_length(&clip);
+		M0_ASSERT(consumed > 0);
 
-	M0_ALLOC_PTR(extlist);
-	if (extlist == NULL) {
-		m0_layout__log("extlist_in_buf_read",
-			       "failed to allocate composite extent list",
-			       M0_LAYOUT_ADDB_LOC_COMP_ELIST_READ_1,
-			       &cl->cl_base.l_addb_ctx, cl->cl_base.l_id,
-			       -ENOMEM);
-		return -ENOMEM;
-	}
-	m0_composite_layer_ext_tlist_init(extlist);
+		length[0] = clip.e_start - chunk->e_start;
+		length[1] = clip.e_end == ext0.e_end ? m0_ext_length(ext) : 0;
+		length[2] = chunk->e_end - clip.e_end;
 
-	rc = 0;
-	for (i = 0; i < extents_nr; ++i) {
-		ext = m0_bufvec_cursor_addr(cur);
-		m0_bufvec_cursor_move(cur, sizeof *ext);
-		ext_state = m0_bufvec_cursor_addr(cur);
-		m0_bufvec_cursor_move(cur, sizeof *ext_state);
+		/* Original ext state. */
+		bstart[0] = bstart[2] = ext_to_insert_into->cle_state;
+		/* New ext state. */
+		bstart[1] = ext_state;
 
-		if (m0_ext_is_empty(ext) ||
-		    !M0_IN(*ext_state, (M0_CLRES_INVALID,
-					M0_CLRES_VALID,
-				        M0_CLRES_FLATTENING))) {
-			m0_layout__log("extlist_in_buf_read",
-				       "Invalid extent found in the buffer",
-				       M0_LAYOUT_ADDB_LOC_COMP_ELIST_READ_3,
-				       &cl->cl_base.l_addb_ctx,
-				       cl->cl_base.l_id, -ENOMEM);
-			extlist_free(extlist);
-			return -EINVAL;
-		}
-		rc = ext_in_mem_add_internal(NULL, &cl->cl_base, extlist,
-					     ext, *ext_state,
-					     ADD_AT_TAIL, NULL);
-		M0_ASSERT(rc == 0); //todo rm
-		if (rc != 0) {
-			//todo M0_LOG
-			extlist_free(extlist);
-			return rc;
+#ifndef __KERNEL__
+	printf("ext_inmem_write(2): lid %llu, layer %lu \n"
+		"\te_start %llu, e_end %llu \n"
+		"\text_to_insert_into_start %llu, \n"
+		"\text_to_insert_into_end %llu\n"
+		"\tchunk_start %llu, chunk_end %llu\n "
+		"\tclip_start %llu, clip_end %llu \n"
+		"\tlength[0] %llu, bstart[0] %llu \n"
+		"\tlength[1] %llu, bstart[1] %llu \n"
+		"\tlength[2] %llu, bstart[2] %llu \n",
+		(unsigned long long)layer->clr_l->l_id,
+		(unsigned long)layer->clr_idx,
+		(unsigned long long)ext0.e_start,
+		(unsigned long long)ext0.e_end,
+		(unsigned long long)ext_to_insert_into->cle_ext.e_start,
+		(unsigned long long)ext_to_insert_into->cle_ext.e_end,
+		(unsigned long long)chunk->e_start,
+		(unsigned long long)chunk->e_end,
+		(unsigned long long)clip.e_start,
+		(unsigned long long)clip.e_end,
+		(unsigned long long)length[0], (unsigned long long)bstart[0],
+		(unsigned long long)length[1], (unsigned long long)bstart[1],
+		(unsigned long long)length[2], (unsigned long long)bstart[2]);
+#endif
+
+		split_required  = true;
+		delete_required = false;
+		lr_ext_to_del   = NULL;
+		if (length[0] == 0 && length[2] == 0) {
+			split_required = false;
+			delete_required = true;
+			lr_ext_to_del = ext_to_insert_into;
+			if (length[1] != 0) {
+				M0_ASSERT(length[1] == m0_ext_length(ext));
+				is_ultimate_ext_add = true;
+			}
 		}
-	}
-	*extents = extlist;
-	M0_RETURN(rc);
-}
 
-/**
- * Parses 'the composite layout type specific information including all the
- * layers' from the buffer provided and adds it to the in-memory layout.
- */
-static int comp_layout_in_buf_read(struct m0_composite_layout *cl,
-				   struct m0_bufvec_cursor *cur,
-				   uint32_t user_count)
-{
-	struct composite_header       *cl_header;
-	struct composite_layer_header *lr_header;
-	struct m0_layout              *sublayout;
-	struct m0_tl                  *extlist;
-	uint32_t                       i;
-	int                            rc = 0; /* To keep the compiler happy. */
+		/*
+		 * ext_split_internal() may replace the current node that is
+		 * ext_to_insert_into, with multiple smaller segments. Hence,
+		 * store the next node before invoking ext_split_internal().
+		 */
+		lr_ext_next = NULL;
+		if (!m0_ext_is_empty(&ext0)) {
+			lr_ext_next = m0_composite_layer_ext_tlist_next(
+                                                        layer->clr_extents,
+                                                        ext_to_insert_into);
 
-	M0_PRE(composite_allocated_invariant(cl));
-	M0_PRE(cur != NULL);
-	M0_PRE(m0_bufvec_cursor_step(cur) >= sizeof *cl_header);
+			/*
+			 * If ext0 is not yet empty, ext_to_insert_into should
+			 * not be the last element of the list.
+			 */
+			M0_ASSERT(lr_ext_next != NULL);
+		}
 
-	M0_ENTRY("lid %llu, user_count %lu",
-		 (unsigned long long)cl->cl_base.l_id,
-		 (unsigned long)user_count);
+#ifndef __KERNEL__
+		printf("ext_inmem_write(4): lid %llu, layer %lu, \n"
+			"\te_start %llu, e_end %llu, \n"
+			"\text_to_del_start %llu, ext_to_del_end %llu \n"
+			"\tdelete_reqd %d, split_reqd %d \n"
+			"\tnext_start %llu, next_end %llu \n",
+			(unsigned long long)layer->clr_l->l_id,
+			(unsigned long)layer->clr_idx,
+			(unsigned long long)ext0.e_start,
+			(unsigned long long)ext0.e_end,
+			lr_ext_to_del == NULL ? 0 :
+			(unsigned long long)lr_ext_to_del->cle_ext.e_start,
+			lr_ext_to_del == NULL ? 0 :
+			(unsigned long long)lr_ext_to_del->cle_ext.e_end,
+			delete_required, split_required,
+			lr_ext_next == NULL ? 0 :
+			(unsigned long long)lr_ext_next->cle_ext.e_start,
+			lr_ext_next == NULL ? 0 :
+			(unsigned long long)lr_ext_next->cle_ext.e_end);
+#endif
 
-	/* Read the composite layout header from the buffer. */
-	cl_header = m0_bufvec_cursor_addr(cur);
-	m0_bufvec_cursor_move(cur, sizeof *cl_header);
+		if (split_required) {
+			rc = ext_split_internal(layer, ext_to_insert_into,
+						&vec,
+						length[0] > 0 ?
+						chunk->e_start : ext->e_start);
+			if (rc != 0) //todo trace msg
+				break;
+		} else
+			rc = 0;
 
-	/* Read the layers from the buffer. */
-	M0_ASSERT(m0_bufvec_cursor_step(cur) >=
-		  cl_header->ch_layers_nr * sizeof *lr_header);
-	for (i = 0; i < cl_header->ch_layers_nr; ++i) {
-		lr_header = m0_bufvec_cursor_addr(cur);
-		m0_bufvec_cursor_move(cur, sizeof *lr_header);
-		sublayout = layout_find(cl->cl_base.l_dom, lr_header->clh_lid);
-		if (sublayout == NULL) {
-			M0_LOG(M0_ERROR, "lid %llu, sublayout with lid %llu "
-			       "does not exist",
-			       (unsigned long long)cl->cl_base.l_id,
-			       (unsigned long long)lr_header->clh_lid);
-			return -EINVAL;
+		if (delete_required)
+			ext_inmem_del_internal(layer, lr_ext_to_del);
+
+		ext0.e_start += consumed;
+		M0_ASSERT(ext0.e_start <= ext0.e_end);
+		if (!m0_ext_is_empty(&ext0)) {
+			ext_to_insert_into = lr_ext_next;
+			chunk = &ext_to_insert_into->cle_ext;
+			if (ext_to_insert_into == NULL)
+				break;
 		}
+	}
 
-		M0_ASSERT(lr_header->clh_idx == i);
-		rc = extlist_in_buf_read(cl, cur,
-					 lr_header->clh_extents_nr,
-					 &extlist);
-		M0_ASSERT(rc == 0);
+	// Feb22 Continue from here
+	//todo Check the rc properly
+	/*
+	 * Now that the deletion/trimming of the overlapping extents
+	 * has been handled above, let's add the ultimate whole extent.
+	 */
+	if (rc == 0 && is_ultimate_ext_add) {
+		rc1 = ext_inmem_find(layer, ext, ext_state, &lr_ext);
+		M0_ASSERT(rc1 == -ENOENT);
 
-		if (lr_header->clh_idx == 0) /* Zeroth layer */
-			rc = composite_populate(cl, sublayout, extlist,
-						lr_header->clh_extents_nr,
-						user_count);
-		else
-			rc = m0_composite_layer_add(cl, sublayout,
-						    extlist,
-						    lr_header->clh_extents_nr,
-						    NULL);
-		/*
-		 * Release the reference added by m0_layout_find(). In case of
-		 * success, m0_composite_layer_add() has added a reference on
-		 * this sublayout.
-		 */
-		m0_layout_put(sublayout);
+		rc = ext_inmem_add(layer, ext, ext_state);
+		M0_ASSERT(rc == 0);
+	}
 
-		if (rc != 0)
-			break;
+	if (rc == 0) {
+		rc1 = ext_inmem_find(layer, ext, ext_state, &lr_ext);
+		M0_POST(rc1 == 0);
 	}
-	M0_RETURN(rc);
+	M0_POST(layer_invariant(layer));
+	return rc;
 }
 
-static int extentmap_in_db_read(struct m0_composite_layout *cl,
-				uint32_t layer_idx,
-				struct m0_db_tx *tx,
-				struct m0_tl **extlist,
-				uint32_t *extents_nr)
+// todo this one shall accept new_state which shall never be INVALID
+M0_INTERNAL int m0_composite_layer_ext_add(struct m0_composite_layout *cl,
+					   uint32_t layer_idx,
+					   const struct m0_ext *ext,
+					   struct m0_db_tx *tx)
 {
-	struct m0_emap        *emap;
-	struct m0_emap_cursor  it;
-	struct layout_prefix   prefix;
-	struct m0_emap_seg    *seg;
-	int                    rc;
-
-	M0_ENTRY("lid %llu, layer %lu", (unsigned long long)cl->cl_base.l_id,
-		 (unsigned long)layer_idx);
+	struct m0_composite_layer *layer;
+	struct m0_emap_cursor      it;
+	int                        rc;
 
-	emap = emap_from_cl(cl);
-	prefix_set(&prefix, cl->cl_base.l_id, layer_idx);
-	rc = m0_emap_lookup(emap, tx, (struct m0_uint128 *)&prefix, 0, &it);
-	if (rc != 0) {
-		m0_layout__log("extentmap_in_db_read",
-			       "failed to lookup into layer_emap",
-			       M0_LAYOUT_ADDB_LOC_COMP_EMAP_READ_1,
-			       &cl->cl_base.l_addb_ctx, cl->cl_base.l_id, rc);
-		return rc;
-	}
+	M0_PRE(composite_invariant(cl));
+	M0_PRE(ext != NULL);
+	/* todo
+	 * M0_PRE(M0_IN(new_state, (M0_CLRES_VALID, M0_CLRES_FLATTENING))); */
+	M0_PRE(ergo(cl->cl_base.l_dom->ld_is_db_available, tx != NULL));
 
-	M0_ALLOC_PTR(*extlist);
-	if (*extlist == NULL) {
-		m0_layout__log("extentmap_in_db_read",
-			       "failed to allocate composite extent list",
-			       M0_LAYOUT_ADDB_LOC_COMP_EMAP_READ_2,
-			       &cl->cl_base.l_addb_ctx, cl->cl_base.l_id,
-			       -ENOMEM);
-		m0_emap_close(&it);
-		return -ENOMEM;
-	}
-	m0_composite_layer_ext_tlist_init(*extlist);
+	M0_ENTRY("lid %llu, layer %lu, e_start %llu, e_end %llu",
+		 (unsigned long long)cl->cl_base.l_id,
+		 (unsigned long)layer_idx, (unsigned long long)ext->e_start,
+		 (unsigned long long)ext->e_end);
+#ifndef __KERNEL__
+	printf("m0_composite_layer_ext_add(): lid %llu, layer %lu \n"
+		"\te_start %llu, e_end %llu \n",
+		 (unsigned long long)cl->cl_base.l_id,
+		 (unsigned long)layer_idx, (unsigned long long)ext->e_start,
+		 (unsigned long long)ext->e_end);
+#endif
 
-	*extents_nr = 0;
-	seg = m0_emap_seg_get(&it);
-	while (1) {
-		M0_ASSERT(seg != NULL);
-		if (m0_ext_is_empty(&seg->ee_ext) ||
-		    !M0_IN(seg->ee_val, (M0_CLRES_INVALID, M0_CLRES_VALID,
-					 M0_CLRES_FLATTENING))) {
-			m0_layout__log("extentmap_in_db_read",
-				       "Invalid extent found in the DB",
-				       M0_LAYOUT_ADDB_LOC_COMP_EMAP_READ_3,
-				       &cl->cl_base.l_addb_ctx,
-				       cl->cl_base.l_id, -ENOMEM);
-			extlist_free(*extlist);
+	m0_mutex_lock(&cl->cl_base.l_lock);
+	layer = layer_find(cl, layer_idx);
+
+	if (!cl->cl_base.l_dom->ld_is_db_available)
+		rc = ext_inmem_write(cl, layer, ext, M0_CLRES_VALID,
+				     !EXT_VALIDATE);
+	else {
+		rc = emap_iterator_set(cl, layer_idx, ext, tx,
+				       !EXT_VALIDATE, &it);
+		M0_ASSERT(rc == 0 || rc == -EINVAL); //todo Handle
+
+		if (rc == 0) {
+			//todo Check the following comment
+			/**
+			 * @todo In short: Break ext into multiple, based on
+			 * values (extent states) of 'multiple segments the
+			 * ext may span over'.
+			 *
+			 * Details: Two extents can be merged if and only if
+			 * they are 'back-to-back' (this part is taken care of
+			 * by  m0_emap_paste()) and their state is the same.
+			 *
+			 * To conform to the latter need, it is planned to
+			 * check the states of 'all the existing extents in
+			 * the emap, the ext spans over'. If they are not the
+			 * same, then accordingly, multiple ext_indb_write()
+			 * requests are generated.
+			 *
+			 * This will be implemented once this design point is
+			 * agreed upon during CINSP_PREUT.
+			 */
+
+			rc = ext_indb_write(&it, layer, ext, //new_state,
+					    M0_CLRES_VALID,
+					    INMEM_LIST_UPDATE);
+			if (rc != 0)
+				m0_layout__log("m0_composite_layer_ext_add",
+					       "failed to write extent",
+					       M0_LAYOUT_ADDB_LOC_COMP_EXT_UPDATE_3, //todo
+					       &cl->cl_base.l_addb_ctx,
+					       cl->cl_base.l_id, rc);
 			m0_emap_close(&it);
-			return -EINVAL;
 		}
+	}
 
-		rc = ext_in_mem_add_internal(NULL, &cl->cl_base, *extlist,
-					     &seg->ee_ext, seg->ee_val,
-					     ADD_AT_TAIL, NULL);
-		if (rc != 0) {
-			//todo M0_LOG
-			extlist_free(*extlist);
+	m0_mutex_unlock(&cl->cl_base.l_lock);
+	M0_POST(layer_invariant(layer));
+	M0_POST(composite_invariant(cl));
+	M0_LEAVE("lid %llu, layer %lu, e_start %llu, e_end %llu, rc %d",
+		 (unsigned long long)cl->cl_base.l_id,
+		 (unsigned long)layer_idx, (unsigned long long)ext->e_start,
+		 (unsigned long long)ext->e_end, rc);
+	return rc;
+}
+
+M0_INTERNAL int m0_composite_layer_ext_state_update(
+					struct m0_composite_layout *cl,
+					uint32_t layer_idx,
+					const struct m0_ext *ext,
+					uint64_t new_state,
+					struct m0_db_tx *tx)
+{
+	struct m0_composite_layer *layer;
+	struct m0_emap_cursor      it;
+	int                        rc;
+
+	M0_PRE(composite_invariant(cl));
+	M0_PRE(ext != NULL);
+	M0_PRE(M0_IN(new_state, (M0_CLRES_VALID, M0_CLRES_FLATTENING)));
+	M0_PRE(ergo(cl->cl_base.l_dom->ld_is_db_available, tx != NULL));
+
+	M0_ENTRY("lid %llu, layer %lu, e_start %llu, e_end %llu, e_state %llu",
+		 (unsigned long long)cl->cl_base.l_id,
+		 (unsigned long)layer_idx, (unsigned long long)ext->e_start,
+		 (unsigned long long)ext->e_end, (unsigned long long)new_state);
+#ifndef __KERNEL__
+	printf("m0_composite_layer_ext_state_update(): lid %llu, layer %lu, "
+		"e_start %llu, e_end %llu, e_state %llu\n",
+		 (unsigned long long)cl->cl_base.l_id,
+		 (unsigned long)layer_idx, (unsigned long long)ext->e_start,
+		 (unsigned long long)ext->e_end, (unsigned long long)new_state);
+#endif
+
+	m0_mutex_lock(&cl->cl_base.l_lock);
+	layer = layer_find(cl, layer_idx);
+
+	if (!cl->cl_base.l_dom->ld_is_db_available) {
+		rc = ext_inmem_write(cl, layer, ext, new_state, EXT_VALIDATE);
+	} else {
+		rc = emap_iterator_set(cl, layer_idx, ext, tx,
+				       EXT_VALIDATE, &it);
+		M0_ASSERT(rc == 0 || rc == -EINVAL); //todo Handle
+
+		if (rc == 0) {
+			rc = ext_indb_write(&it, layer, ext, new_state,
+					    INMEM_LIST_UPDATE);
+			if (rc != 0)
+				//todo Make this M0_LOG??
+				m0_layout__log("m0_composite_layer_ext_state_update",
+					       "failed to write extent",
+					       M0_LAYOUT_ADDB_LOC_COMP_EXT_UPDATE_3, //todo
+					       &cl->cl_base.l_addb_ctx,
+					       cl->cl_base.l_id, rc);
 			m0_emap_close(&it);
-			return rc;
 		}
-		*extents_nr = m0_composite_layer_ext_tlist_length(*extlist);
+	}
+	m0_mutex_unlock(&cl->cl_base.l_lock);
+	M0_POST(layer_invariant(layer));
+	M0_POST(composite_invariant(cl));
+	M0_LEAVE("lid %llu, layer %lu, e_start %llu, e_end %llu, "
+		 "e_state %llu, rc %d",
+		 (unsigned long long)cl->cl_base.l_id,
+		 (unsigned long)layer_idx, (unsigned long long)ext->e_start,
+		 (unsigned long long)ext->e_end,
+		 (unsigned long long)new_state, rc);
+	return rc;
+}
 
-		if (m0_emap_ext_is_last(&seg->ee_ext))
-			break;
-		m0_emap_next(&it);
-		seg = m0_emap_seg_get(&it);
+M0_INTERNAL int m0_composite_layer_ext_delete(struct m0_composite_layout *cl,
+					      uint32_t layer_idx,
+					      const struct m0_ext *ext,
+					      struct m0_db_tx *tx)
+{
+	struct m0_composite_layer *layer;
+	struct m0_emap_cursor      it;
+	int                        rc;
+
+	M0_PRE(composite_invariant(cl));
+	M0_PRE(ext != NULL);
+	M0_PRE(ergo(cl->cl_base.l_dom->ld_is_db_available, tx != NULL));
+
+	M0_ENTRY("lid %llu, layer %lu, e_start %llu, e_end %llu, ext %p",
+		 (unsigned long long)cl->cl_base.l_id,
+		 (unsigned long)layer_idx, (unsigned long long)ext->e_start,
+		 (unsigned long long)ext->e_end, ext);
+#ifndef __KERNEL__
+	printf("m0_composite_layer_ext_delete(1): lid %llu, layer %lu, "
+		"e_start %llu, e_end %llu, ext %p\n",
+		 (unsigned long long)cl->cl_base.l_id,
+		 (unsigned long)layer_idx, (unsigned long long)ext->e_start,
+		 (unsigned long long)ext->e_end, ext);
+#endif
+
+	m0_mutex_lock(&cl->cl_base.l_lock);
+	layer = layer_find(cl, layer_idx);
+
+	if (!cl->cl_base.l_dom->ld_is_db_available)
+		rc = ext_inmem_write(cl, layer, ext, M0_CLRES_INVALID,
+				     EXT_VALIDATE);
+	else {
+		rc = emap_iterator_set(cl, layer_idx, ext, tx,
+				       EXT_VALIDATE, &it);
+		M0_ASSERT(rc == 0 || rc == -EINVAL); //todo Handle
+
+		if (rc == 0) {
+			rc = ext_indb_write(&it, layer, ext, M0_CLRES_INVALID,
+					    INMEM_LIST_UPDATE);
+			if (rc != 0)
+				m0_layout__log("m0_composite_layer_ext_delete",
+					       "failed to write extent",
+					       M0_LAYOUT_ADDB_LOC_COMP_EXT_UPDATE_3, //todo
+					       &cl->cl_base.l_addb_ctx,
+					       cl->cl_base.l_id, rc);
+			m0_emap_close(&it);
+		}
 	}
-	m0_emap_close(&it);
 
-	M0_POST(*extents_nr > 0);
-	M0_RETURN(rc);
+	m0_mutex_unlock(&cl->cl_base.l_lock);
+	M0_POST(layer_invariant(layer));
+	M0_POST(composite_invariant(cl));
+	M0_LEAVE("lid %llu, layer %lu, e_start %llu, e_end %llu, rc %d",
+		 (unsigned long long)cl->cl_base.l_id,
+		 (unsigned long)layer_idx, (unsigned long long)ext->e_start,
+		 (unsigned long long)ext->e_end, rc);
+#ifndef __KERNEL__
+	printf("m0_composite_layer_ext_delete(2): lid %llu, layer %lu, "
+		"e_start %llu, e_end %llu, ext %p\n",
+		 (unsigned long long)cl->cl_base.l_id,
+		 (unsigned long)layer_idx, (unsigned long long)ext->e_start,
+		 (unsigned long long)ext->e_end, ext);
+#endif
+	return rc;
 }
 
+
+
+
+
+
+
+
 /**
- * Reads 'the composite layout type specific information including all the
- * layers' from the DB and adds it to the in-memory layout.
+ * @todo It is now understood that the recsize related APIs and functions,
+ * specifically their organization and documentation about their purpose have
+ * become a little bit confusing. Their cleanup will be taken up as a part of
+ * the subsequent task that is 'adding composite layout type support to
+ * getattr'. With the addition of m0_layout_size() to be made with this
+ * subsequent task may possibly rule out the need to expose the API
+ * m0_layout_max_recsize().
  */
-static int comp_layout_in_db_read(struct m0_composite_layout *cl,
-				  struct m0_db_tx *tx,
-				  uint32_t user_count)
+
+/** Implementation of lo_recsize() for COMPOSITE layout type. */
+static m0_bcount_t composite_recsize(const struct m0_layout *l)
 {
-	uint64_t                   sublayout_id;
-	struct m0_layout          *sublayout;
-	struct m0_tl              *extents;
-	uint32_t                   extents_nr;
-	struct m0_composite_layer *layer;
-	uint32_t                   i; /* layer idx */
-	int                        rc;
+	return sizeof(struct m0_layout_rec);
+}
 
-	M0_ENTRY("lid %llu", (unsigned long long)cl->cl_base.l_id);
+/** Implementation of lto_max_recsize() for COMPOSITE layout type. */
+static m0_bcount_t composite_max_recsize(struct m0_layout_domain *dom)
+{
+	/*
+	 * No data specific to the composite layout type is stored in the
+	 * generic table.
+	 */
+	return 0;
+}
 
-	i = 0;
-	while (1) {
-		/* Read 'the sublayout id for this layer' from the DB. */
-		rc = sublayout_id_in_db_lookup(cl, i, tx, &sublayout_id);
-		if (rc != 0) {
-			M0_ASSERT(i > 0);
-			if (rc == -ENOENT)
+static void prefix_set(struct layout_prefix *prefix,
+		       uint64_t composite_lid,
+		       uint32_t layer_idx)
+{
+	prefix->lp_l_id = composite_lid;
+	prefix->lp_layer_idx = layer_idx;
+	prefix->lp_filler = 0;
+}
+
+#ifndef __KERNEL__
+static int ext_inmem_delete(struct m0_composite_layer *layer,
+			    const struct m0_ext *ext,
+			    uint64_t old_ext_state)
+{
+	struct m0_composite_layer_extent *lr_ext;
+	struct m0_composite_layer_extent *lr_ext_to_delete;
+	bool                              lr_ext_to_delete_found;
+	int                               rc;
+
+	//todo rm M0_PRE(old_ext_state != M0_CLRES_INVALID);
+#ifndef __KERNEL__
+	printf("ext_inmem_delete(): lid %llu, layer %lu, "
+		"e_start %llu, e_end %llu, old_e_state %llu, ext %p\n",
+		 (unsigned long long)layer->clr_l->l_id,
+		 (unsigned long)layer->clr_idx,
+		 (unsigned long long)ext->e_start,
+		 (unsigned long long)ext->e_end,
+		 (unsigned long long)old_ext_state, ext);
+#endif
+
+	M0_ENTRY("lid %llu, layer %lu, e_start %llu, e_end %llu, "
+		 "old_e_state %llu",
+		 (unsigned long long)layer->clr_l->l_id,
+		 (unsigned long)layer->clr_idx,
+		 (unsigned long long)ext->e_start,
+		 (unsigned long long)ext->e_end,
+		 (unsigned long long)old_ext_state);
+
+	lr_ext_to_delete_found = false;
+	m0_tl_for(m0_composite_layer_ext, layer->clr_extents, lr_ext) {
+		if (ext->e_start > lr_ext->cle_ext.e_end)
+			continue;
+		if (ext->e_start == lr_ext->cle_ext.e_start) {
+			if (ext->e_end == lr_ext->cle_ext.e_end) {
+				lr_ext_to_delete = lr_ext;
+				lr_ext_to_delete_found = true;
+				break;
+			} else
 				/*
-				 * The number of layers is not known in
-				 * advance. Hence, break when the first
-				 * -ENOENT error is encountered.
+				 * It is only during the process of an extent
+				 * getting added by splitting some existing
+				 * extent, when there could be two extents
+				 * starting with the same offset. So, this
+				 * continue is to find that other exact
+				 * matching extent.
 				 */
-				rc = 0;
-			else
-				M0_LOG(M0_ERROR, "lid %llu, layer %lu, "
-				       "sublayout id could not be read from "
-				       "the DB",
-				       (unsigned long long)cl->cl_base.l_id,
-				       (unsigned long)i);
-			break;
+				continue;
 		}
+	} m0_tl_endfor;
 
-		sublayout = layout_find(cl->cl_base.l_dom, sublayout_id);
-		if (sublayout == NULL) {
-			M0_LOG(M0_ERROR, "lid %llu, layer %lu, sublayout with "
-			       "lid %llu does not exist",
-			       (unsigned long long)cl->cl_base.l_id,
-			       (unsigned long)i,
-			       (unsigned long long)sublayout_id);
-			rc = -EINVAL;
-			break;
-		}
+	if (lr_ext_to_delete_found && ext->e_end == lr_ext->cle_ext.e_end) {
+		M0_ASSERT(lr_ext_to_delete->cle_state == old_ext_state);
+		ext_inmem_del_internal(layer, lr_ext_to_delete);
+		rc = 0;
+	} else
+		rc = -ENOENT;
+	M0_RETURN(rc);
+}
 
-		/* Read 'the extent map for this layer' from the DB. */
-		rc = extentmap_in_db_read(cl, i, tx, &extents, &extents_nr);
-		if (rc != 0) {
-			M0_LOG(M0_ERROR, "lid %llu, layer %lu, extentmap could"
-			       "not be read from the DB",
-			       (unsigned long long)cl->cl_base.l_id,
-			       (unsigned long)i);
-			/* Release the reference added by m0_layout_find(). */
-			m0_layout_put(sublayout);
-			break;
-		}
+/** Trims the existing extent as requested. */
+static int ext_inmem_trim(struct m0_composite_layer *layer,
+			  enum extent_op extent_op,
+			  const struct m0_ext *ext_to_trim,
+			  uint64_t ext_state,
+			  const struct m0_ext *trim_reference_ext)
+{
+	struct m0_composite_layer_extent *lr_ext;
+	int                               rc;
 
-		if (i == 0)
-			rc = composite_populate(cl, sublayout, extents,
-						extents_nr, user_count);
-		else
-			/* Now, write the layer to the in-memory layout. */
-			rc = layer_in_mem_add(cl, sublayout, extents,
-					      extents_nr, &layer);
-		if (rc != 0) {
-			M0_LOG(M0_ERROR, "lid %llu, layer %lu could not be "
-			       "written to the layout",
-			       (unsigned long long)cl->cl_base.l_id,
-			       (unsigned long)i);
-			/* Release the reference added by m0_layout_find(). */
-			m0_layout_put(sublayout);
-			break;
-		}
+	M0_PRE(M0_IN(extent_op, (CUT_LEFT, CUT_RIGHT)));
+	M0_ENTRY("lid %llu, layer %lu, extent_op %d, "
+		 "ext_to_trim_start %llu, ext_to_trim_end %llu, "
+		 "ext_state %llu, "
+		 "trim_ref_ext_start %llu, trim_ref_ext_end %llu",
+		 (unsigned long long)layer->clr_l->l_id,
+		 (unsigned long)layer->clr_idx, extent_op,
+		 (unsigned long long)ext_to_trim->e_start,
+		 (unsigned long long)ext_to_trim->e_end,
+		 (unsigned long long)ext_state,
+		 (unsigned long long)trim_reference_ext->e_start,
+		 (unsigned long long)trim_reference_ext->e_end);
 
-		/*
-		 * Release the reference added by m0_layout_find().
-		 * layer_in_mem_add() has now added a reference on this
-		 * sublayout.
-		 */
-		M0_ASSERT(rc == 0);
-		m0_layout_put(sublayout);
+#ifndef __KERNEL__
+	printf("ext_inmem_trim(): lid %llu, layer %lu, extent_op %d, "
+		 "ext_to_trim_start %llu, ext_to_trim_end %llu, "
+		 "ext_state %llu, "
+		 "trim_ref_ext_start %llu, trim_ref_ext_end %llu\n",
+		 (unsigned long long)layer->clr_l->l_id,
+		 (unsigned long)layer->clr_idx, extent_op,
+		 (unsigned long long)ext_to_trim->e_start,
+		 (unsigned long long)ext_to_trim->e_end,
+		 (unsigned long long)ext_state,
+		 (unsigned long long)trim_reference_ext->e_start,
+		 (unsigned long long)trim_reference_ext->e_end);
+#endif
 
-		++i;
-	}
+	rc = ext_inmem_find(layer, ext_to_trim, ext_state, &lr_ext);
+	M0_ASSERT(rc == 0); //todo rm
+	if (rc == 0) {
+		M0_ASSERT(lr_ext->cle_ext.e_start <=
+			  trim_reference_ext->e_start);
+		M0_ASSERT(lr_ext->cle_ext.e_end >= trim_reference_ext->e_end);
 
+		if (extent_op == CUT_LEFT)
+			/* Retain left part of the existing extent. */
+			lr_ext->cle_ext.e_end = trim_reference_ext->e_start;
+		else
+			/* Retain right part of the existing extent. */
+			lr_ext->cle_ext.e_start = trim_reference_ext->e_end;
+	}
 	M0_RETURN(rc);
 }
 
-static const struct m0_layout_ops composite_ops;
-
-/** Implementation of lo_decode() for composite layout type. */
-static int composite_decode(struct m0_layout *l,
-			    struct m0_bufvec_cursor *cur,
-			    enum m0_layout_xcode_op op,
-			    struct m0_db_tx *tx,
-			    uint32_t user_count)
+static int ext_inmem_adjust(struct m0_composite_layer *layer,
+			    enum extent_op extent_op,
+			    const struct m0_emap_seg *seg,
+			    const struct m0_ext *ext)
 {
-	struct m0_composite_layout *cl;
-	int                         rc;
+	int rc;
 
-	M0_PRE(m0_layout__allocated_invariant(l));
-	M0_PRE(m0_mutex_is_locked(&l->l_lock));
-	M0_PRE(cur != NULL);
-	M0_PRE(M0_IN(op, (M0_LXO_DB_LOOKUP, M0_LXO_BUFFER_OP)));
-	M0_PRE(ergo(op == M0_LXO_DB_LOOKUP, tx != NULL));
+	M0_PRE(M0_IN(extent_op, (DELETE, CUT_LEFT, CUT_RIGHT)));
 
-	M0_ENTRY("lid %llu", (unsigned long long)l->l_id);
-	cl = bob_of(l, struct m0_composite_layout, cl_base, &composite_bob);
-	M0_PRE(composite_allocated_invariant(cl));
+#ifndef __KERNEL__
+	printf("ext_inmem_adjust(): lid %llu, layer %lu, extent_op %d, "
+		 "seg_e_start %llu, seg_e_end %llu, seg_val %llu, "
+		 "e_start %llu, e_end %llu, ext %p\n",
+		 (unsigned long long)layer->clr_l->l_id,
+		 (unsigned long)layer->clr_idx, extent_op,
+		 (unsigned long long)seg->ee_ext.e_start,
+		 (unsigned long long)seg->ee_ext.e_end,
+		 (unsigned long long)seg->ee_val,
+		 (ext != NULL) ? (unsigned long long)ext->e_start : 0,
+		 (ext != NULL) ? (unsigned long long)ext->e_end : 0, ext);
+#endif
 
-	if (op == M0_LXO_BUFFER_OP) {
-		rc = comp_layout_in_buf_read(cl, cur, user_count);
-		if (rc != 0)
-			M0_LOG(M0_ERROR, "lid %llu, failed to read layout from"
-			       "the buffer",
-			       (unsigned long long)cl->cl_base.l_id);
-	} else {
-		rc = comp_layout_in_db_read(cl, tx, user_count);
-		if (rc != 0)
-			M0_LOG(M0_ERROR, "lid %llu, failed to read layout from"
-			       "the DB",
-			       (unsigned long long)cl->cl_base.l_id);
-	}
+	M0_ENTRY("lid %llu, layer %lu, extent_op %d, "
+		 "seg_e_start %llu, seg_e_end %llu, seg_val %llu, "
+		 "e_start %llu, e_end %llu",
+		 (unsigned long long)layer->clr_l->l_id,
+		 (unsigned long)layer->clr_idx, extent_op,
+		 (unsigned long long)seg->ee_ext.e_start,
+		 (unsigned long long)seg->ee_ext.e_end,
+		 (unsigned long long)seg->ee_val,
+		 (ext != NULL) ? (unsigned long long)ext->e_start : 0,
+		 (ext != NULL) ? (unsigned long long)ext->e_end : 0);
 
-	M0_POST(ergo(rc == 0, composite_invariant(cl)));
-	M0_POST(ergo(rc != 0, composite_allocated_invariant(cl)));
-	M0_LEAVE("lid %llu, rc %d", (unsigned long long)l->l_id, rc);
-	return rc;
+	if (extent_op == DELETE)
+		/*
+		 * The extent seg->ee_ext is replaced by some newer extent.
+		 * Hence, seg->ee_ext is asked to be deleted.
+		 */
+		rc = ext_inmem_delete(layer, &seg->ee_ext, seg->ee_val);
+	else
+		rc = ext_inmem_trim(layer, extent_op, &seg->ee_ext,
+				    seg->ee_val, ext);
+	M0_RETURN(rc);
 }
+#endif /* __KERNEL__ */
 
-static int comp_layout_in_db_add(struct m0_composite_layout *cl,
-				 struct m0_db_tx *tx)
+/**
+ * Pastes an extent with the specified state into the on-disk extent map
+ * associated with the specified layer'. With the help of m0_emap_paste(),
+ * it deletes or truncates the overlappping extents as necessary.
+ *
+ * @param in_mem_list_update This flag indicates if the in-memory list of
+ * the extents is to be updated in the context of the callbacks received from
+ * m0_emap_paste().
+ * - In case of initial addition of the extents into the on-disk extent map
+ *   while a layer is getting added, the in-memory list is already up-to-date
+ *   as what is to be written to the DB.
+ * - In case an extent is to be added explicitly, after a layer has been added,
+ *   then the in-memory list of the extents needs to be updated.
+ */
+static int ext_indb_write(struct m0_emap_cursor *it,
+			  struct m0_composite_layer *layer,
+			  const struct m0_ext *ext,
+			  uint64_t new_ext_state,
+			  bool in_mem_list_update)
 {
-	struct m0_composite_layer *layer;
-	int                        rc;
 
-	M0_ENTRY("lid %llu", (unsigned long long)cl->cl_base.l_id);
-
-	/* Collect the zeroth layer from the in-memory layout. */
-	layer = comp_layer_tlist_head(&cl->cl_layers);
-	M0_ASSERT(layer->clr_idx == 0);
-	rc = sublayout_id_in_db_add(cl, layer, tx);
-	if (rc == 0) {
-		/* Add 'the extent map for this layer' to the DB. */
-		rc = extmap_in_db_add(cl, layer, tx);
-		if (rc != 0)
-			/*
-			 * If extmap_in_db_add() has failed for no apparent
-			 * reason, it is likely that sublayout_id_in_db_delete()
-			 * would fail. Hence, ignoring its return status.
-			 */
-			sublayout_id_in_db_delete(cl, layer, tx);
-	}
-
-	M0_LEAVE("lid %llu, rc %d", (unsigned long long)cl->cl_base.l_id, rc);
-	return rc;
-}
-
-static int comp_layout_in_db_delete(struct m0_composite_layout *cl,
-				    struct m0_db_tx *tx)
-{
-	struct m0_composite_layer        *layer;
-	struct m0_composite_layer_extent *lr_ext;
-	int                               rc;
+	/* LAMBDA is not defined for the kernel space. */
+#ifndef __KERNEL__
+	struct m0_ext ext0 = *ext; /* A read-write copy. */
+	int           rc_cb;
+	int           rc;
 
-	M0_ENTRY("lid %llu", (unsigned long long)cl->cl_base.l_id);
+	M0_ENTRY("lid %llu, layer %lu, e_start %llu, e_end %llu, "
+		 "new_e_state %llu, in_mem_list_update %d, ext %p",
+		 (unsigned long long)layer->clr_l->l_id,
+		 (unsigned long)layer->clr_idx,
+		 (unsigned long long)ext->e_start,
+		 (unsigned long long)ext->e_end,
+		 (unsigned long long)new_ext_state,
+		 in_mem_list_update ? 1 : 0, ext);
+	M0_PRE(layer_invariant(layer));
 
 	/*
-	 * A composite layout can be deleted from the DB if and only if none of
-	 * its layers contain any valid extents.
+	 * Insert a new segment into the layer's extent map, overwriting
+	 * parts of the map, as applicable.
+	 *
+	 * Some existing segments are deleted completely, others are cut.
+	 * m0_emap_paste() invokes supplied call-backs to notify the caller
+	 * about the changes in the map. These call-backs are used to adjust
+	 * the extents in the in-memory list of the extents for the specific
+	 * layer.
+	 *
+	 * Each call-back takes a segment argument, viz. seg. seg->ee_ext is
+	 * an extent associated with the specified layer as is stored in the
+	 * on-disk extent map and seg->ee_val is the state of that extent.
+	 *
+	 * Here is an example to illustrate the sequence of the operations
+	 * performed by m0_emap_paste() and how the in-memory list of the
+	 * extents is adjusted accordingly.
+	 *
+	 * For example, a layer contains an extent list (in-memory and in-DB)
+	 * as:
+	 * ext[0]: [        0,        2200700)
+	 * ext[1]: [  2200700,       56668025)
+	 * ext[2]: [ 56668025,      111135350)
+	 * ext[3]: [111135350,      165602675)
+	 * ext[4]: [165602675,      220070000)
+	 * ext[5]: [220070000,  M0_BINDEX_MAX)
+	 *
+	 * An extent [56668023, 165602677) is asked to be added into the list.
+	 *
+	 * In such a case, multiple small operations are performed internally
+	 * by m0_emap_paste() and the callbacks are sent appropriately. In
+	 * response to those callback, the in-memory list of the extents is
+	 * adjusted accordingly by using the ext_inmem_adjust() function.
+	 *
+	 * The sequence goes as follows:
+	 * 1) From the extent [2200700, 56668025), its left part that is
+	 *    [2200700, 56668023) is retained, using the extent_op CUT_RIGHT.
+	 * 2) From the extent list, the extent [56668025, 111135350) is
+	 *    deleted using the extent_op DELETE.
+	 * 3) From the extent list, the extent [111135350, 165602675) is
+	 *    deleted using the extent_op DELETE.
+	 * 4) From the extent [165602675, 220070000), its right part that is
+	 *    [165602677, 220070000) is retained, using the extent_op
+	 *    CUT_LEFT.
+	 * 5) Finally, the complete extent [56668023, 165602677) is added.
+	 *
+	 * layer_invariant() is temporarily violated during these operations.
 	 */
-	m0_tl_for(comp_layer, &cl->cl_layers, layer) {
-		m0_tl_for(m0_composite_layer_ext, layer->clr_extents, lr_ext) {
-			if (lr_ext->cle_state != M0_CLRES_INVALID) {
-				M0_LOG(M0_ERROR, "lid %llu, layout can not be "
-				       "deleted since layer %lu still "
-				       "contains at least one valid extent",
-				       (unsigned long long)cl->cl_base.l_id,
-				       (unsigned long)layer->clr_idx);
-				return -EINVAL;;
+
+#if 0
+#ifndef __KERNEL__
+	printf("ext_indb_write(): lid %llu, layer %lu, "
+		 "e_start %llu, e_end %llu, new_e_state %llu, "
+		 "in_mem_list_update %d, ext %p, ext %p\n",
+		 (unsigned long long)layer->clr_l->l_id,
+		 (unsigned long)layer->clr_idx,
+		 (unsigned long long)ext->e_start,
+		 (unsigned long long)ext->e_end,
+		 (unsigned long long)new_ext_state,
+		 in_mem_list_update ? 1 : 0, ext, &ext);
+#endif
+#endif
+	rc_cb = 0;
+	rc = m0_emap_paste(it, &ext0, new_ext_state,
+		LAMBDA(void, (struct m0_emap_seg *seg) {
+			/* Extent deletion. */
+			if (in_mem_list_update) {
+				rc_cb = rc_cb ?: ext_inmem_adjust(layer, DELETE,
+								  seg, NULL);
 			}
-		} m0_tl_endfor;
-	} m0_tl_endfor;
+		}),
+		LAMBDA(void, (struct m0_emap_seg *seg,
+			      struct m0_ext *extent, uint64_t val) {
+			/* Cut left. */
+			if (in_mem_list_update) {
+				rc_cb = rc_cb ?: ext_inmem_adjust(layer,
+								  CUT_LEFT,
+								  seg, extent);
+			}
+		}),
+		LAMBDA(void, (struct m0_emap_seg *seg,
+			      struct m0_ext *extent, uint64_t val) {
+			/* Cut right. */
+			if (in_mem_list_update) {
+				rc_cb = rc_cb ?: ext_inmem_adjust(layer,
+								  CUT_RIGHT,
+								  seg, extent);
+			}
+		}));
 
-	rc = 0; /* To keep the compiler happy. */
-	m0_tl_for(comp_layer, &cl->cl_layers, layer) {
-		rc = sublayout_id_in_db_delete(cl, layer, tx);
-		if (rc != 0)
-			break;
+	//todo If rc != 0, add m0_layout__log here.
 
+	rc = rc ?: rc_cb;
+
+	if (rc == 0 && in_mem_list_update) {
 		/*
-		 * Decrement the user count incremented while adding the
-		 * layer to the composite layout.
+		 * Now that the deletion/trimming of the overlapping extents
+		 * from the in-memory list of the extents has been
+		 * handled above, let's add the ultimate whole extent.
 		 */
-		m0_layout_user_count_dec(layer->clr_l);
-	} m0_tl_endfor;
+		/*
+		 * todo Handle the case that there may be existing INVALID ext.
+		 * Refer to ext_inmem_write().
+		 */
+		rc = ext_inmem_find(layer, ext, new_ext_state, NULL);
+		if (rc == -ENOENT)
+			rc = ext_inmem_add(layer, ext, new_ext_state);
+	}
+	M0_RETURN(rc);
+#else
+	/* This function is not expected to be invoked in the kernel mode. */
+	M0_ASSERT(0);
+	return -EPROTO;
+#endif /* __KERNEL__ */
 
-	M0_ENTRY("lid %llu, rc %d", (unsigned long long)cl->cl_base.l_id, rc);
-	return rc;
+	M0_POST(layer_invariant(layer));
 }
 
-static void comp_layout_in_buf_write(const struct m0_composite_layout *cl,
-				     struct m0_bufvec_cursor *out)
+static void pair_set(struct m0_db_pair *pair,
+		     struct layer_sublayout_key *key,
+		     struct layer_sublayout_rec *rec,
+		     const struct m0_composite_layout *cl,
+		     uint32_t layer_idx,
+		     uint64_t sublayout_id)
 {
-	struct m0_composite_layer        *layer;
-	struct composite_header           cl_header;
-	struct composite_layer_header     lr_header;
-	struct m0_composite_layer_extent *lr_ext;
-	m0_bcount_t                       nbytes;
+	struct composite_schema_data *csd;
 
-	M0_ENTRY("lid %llu", (unsigned long long)cl->cl_base.l_id);
+	key->lrsmk_comp_lid      = cl->cl_base.l_id;
+	key->lrsmk_layer_idx     = layer_idx;
+	key->lrsmk_pad           = 0;
+	rec->lrsmr_sublayout_lid = sublayout_id;
+	csd = cl->cl_base.l_dom->ld_type_data[m0_composite_layout_type.lt_id];
+	m0_db_pair_setup(pair, &csd->csd_layer_sublayout,
+			 key, sizeof *key, rec, sizeof *rec);
+}
 
-	/* Write composite layout header into the buffer. */
-	M0_ASSERT(m0_bufvec_cursor_step(out) >= sizeof cl_header);
-	cl_header.ch_layers_nr = cl->cl_layers_nr;
-	cl_header.ch_pad = 0;
-	nbytes = m0_bufvec_cursor_copyto(out, &cl_header, sizeof cl_header);
-	M0_ASSERT(nbytes == sizeof cl_header);
+static int sublayout_id_indb_lookup(struct m0_composite_layout *cl,
+				    uint32_t layer_idx,
+				    struct m0_db_tx *tx,
+				    uint64_t *sublayout_id)
+{
+	struct m0_db_pair           pair;
+	struct layer_sublayout_key  key;
+	struct layer_sublayout_rec  rec;
+	int                         rc;
 
-	/*
-	 * Read layers information from the composite layout and store
-	 * it in the buffer.
-	 */
-	M0_ASSERT(m0_bufvec_cursor_step(out) >= cl->cl_layers_nr *
-		  sizeof lr_header);
-	m0_tl_for(comp_layer, &cl->cl_layers, layer) {
-		lr_header.clh_lid        = layer->clr_l->l_id;
-		lr_header.clh_idx        = layer->clr_idx;
-		lr_header.clh_extents_nr = layer->clr_extents_nr;
-		lr_header.clh_pad        = 0;
-		nbytes = m0_bufvec_cursor_copyto(out, &lr_header,
-						 sizeof lr_header);
-		m0_tl_for(m0_composite_layer_ext, layer->clr_extents, lr_ext) {
-			nbytes = m0_bufvec_cursor_copyto(out,
-							&lr_ext->cle_ext,
-							sizeof lr_ext->cle_ext);
-			M0_ASSERT(nbytes == sizeof lr_ext->cle_ext);
+	M0_ENTRY("lid %llu, layer %lu, sublayout_id %llu",
+		 (unsigned long long)cl->cl_base.l_id,
+		 (unsigned long)layer_idx,
+		 (unsigned long long)*sublayout_id);
 
-			nbytes = m0_bufvec_cursor_copyto(out,
-						     &lr_ext->cle_state,
-						     sizeof(lr_ext->cle_state));
-			M0_ASSERT(nbytes == sizeof(lr_ext->cle_state));
-		} m0_tl_endfor;
-	} m0_tl_endfor;
+	pair_set(&pair, &key, &rec, cl, layer_idx,
+		 0 /* To be overwritten with the lookup */);
+	rc = m0_table_lookup(tx, &pair);
+	if (rc != 0 && rc != -ENOENT)
+		/**
+		 * The later condition is since the number of layers is not
+		 * known in advance while reading the layers from the DB.
+		 * Reference layers_indb_read().
+		 * @todo If the number of layers is written to the primary
+		 * table, then get rid of the later condition here.
+		 */
+		m0_layout__log("sublayout_id_indb_lookup",
+			       "failed to lookup into layer_sublayout table",
+			       M0_LAYOUT_ADDB_LOC_COMP_SUBLAYOUT_READ,
+			       &cl->cl_base.l_addb_ctx, cl->cl_base.l_id, rc);
+	else
+		*sublayout_id = rec.lrsmr_sublayout_lid;
+	m0_db_pair_fini(&pair);
 
-	M0_LEAVE("lid %llu", (unsigned long long)cl->cl_base.l_id);
+	M0_POST(ergo(rc == 0, *sublayout_id > 0));
+	M0_RETURN(rc);
 }
 
-/** Implementation of lo_encode() for composite layout type. */
-static int composite_encode(struct m0_layout *l,
-			    enum m0_layout_xcode_op op,
-			    struct m0_db_tx *tx,
-			    struct m0_bufvec_cursor *out)
+static int sublayout_id_indb_add(struct m0_composite_layout *cl,
+				 const struct m0_composite_layer *layer,
+				 struct m0_db_tx *tx)
 {
-	struct m0_composite_layout *cl;
+	uint64_t                    sublayout_id;
+	struct m0_db_pair           pair;
+	struct layer_sublayout_key  key;
+	struct layer_sublayout_rec  rec;
 	int                         rc;
 
-	M0_PRE(l != NULL);
-	M0_PRE(m0_mutex_is_locked(&l->l_lock));
-	M0_PRE(M0_IN(op, (M0_LXO_DB_ADD, M0_LXO_DB_UPDATE,
-			  M0_LXO_DB_DELETE, M0_LXO_BUFFER_OP)));
-	M0_PRE(ergo(op != M0_LXO_BUFFER_OP, tx != NULL));
-	M0_PRE(out != NULL);
-
-	M0_ENTRY("%llu", (unsigned long long)l->l_id);
+	M0_ENTRY("lid %llu, layer %lu, sublayout_id %llu",
+		 (unsigned long long)cl->cl_base.l_id,
+		 (unsigned long)layer->clr_idx,
+		 (unsigned long long)layer->clr_l->l_id);
 
-	cl = m0_layout_to_cl(l);
-	if (op == M0_LXO_BUFFER_OP) {
-		comp_layout_in_buf_write(cl, out);
-		rc = 0;
-	} else if (op == M0_LXO_DB_ADD) {
-		rc = comp_layout_in_db_add(cl, tx);
-		if (rc != 0)
-			M0_LOG(M0_ERROR, "lid %llu, layout could not be "
-			       "added to the DB",
-			       (unsigned long long)cl->cl_base.l_id);
-	} else if (op == M0_LXO_DB_UPDATE) {
+	if (layer->clr_idx > 0) {
 		/*
-		 * The auxiliary tables are not to be modified for a layout
-		 * update operation.
+		 * Verify that the sublayout for the zeroth layer has already
+		 * been written to the DB. It ensures that the zeroth layer
+		 * has already been added to the DB as a part of writing the
+		 * composite layout to the DB, by using the API
+		 * m0_layout_add().
 		 */
-		rc = 0;
-	} else {
-		rc = comp_layout_in_db_delete(cl, tx);
-		if (rc != 0)
-			M0_LOG(M0_ERROR, "lid %llu, layout could not be "
-			       "deleted from the DB",
-			       (unsigned long long)cl->cl_base.l_id);
+		rc = sublayout_id_indb_lookup(cl, 0, tx, &sublayout_id);
+		if (rc != 0) {
+			M0_LOG(M0_ERROR, "lid %llu, The composite layout does "
+			       "not seem to be added to DB, prior to adding "
+			       "the layer %lu",
+			       (unsigned long long)cl->cl_base.l_id,
+			       (unsigned long)layer->clr_idx);
+			return rc;
+		}
 	}
 
-	M0_LEAVE("lid %llu, rc %d", (unsigned long long)l->l_id, rc);
-	return rc;
+	/*
+	 * Now, proceed to write the sublayout id for the layer->clr_idx'th
+	 * layer.
+	 */
+	pair_set(&pair, &key, &rec, cl, layer->clr_idx, layer->clr_l->l_id);
+	if (M0_FI_ENABLED("table_insert_err"))
+		{ rc = L_TABLE_INSERT_ERR; goto err1_injected; }
+	rc = m0_table_insert(tx, &pair);
+err1_injected:
+	if (rc != 0)
+		m0_layout__log("sublayout_id_indb_add",
+			       "failed to insert into layer_sublayout table",
+			       M0_LAYOUT_ADDB_LOC_COMP_SUBLAYOUT_ADD,
+			       &layer->clr_l->l_addb_ctx, layer->clr_l->l_id,
+			       rc);
+	m0_db_pair_fini(&pair);
+	M0_RETURN(rc);
 }
 
-static struct m0_composite_layer *layer_find(
-					const struct m0_composite_layout *cl,
-					uint32_t layer_idx)
+static int sublayout_id_indb_delete(const struct m0_composite_layout *cl,
+				    const struct m0_composite_layer *layer,
+				    struct m0_db_tx *tx)
 {
-	struct m0_composite_layer *layer;
+	struct m0_db_pair             pair;
+	struct layer_sublayout_key    key;
+	struct layer_sublayout_rec    rec;
+	int                           rc;
 
-	M0_PRE(layer_idx < cl->cl_layers_nr);
+	M0_ENTRY("lid %llu, layer %lu, sublayout_id %llu",
+		 (unsigned long long)cl->cl_base.l_id,
+		 (unsigned long)layer->clr_idx,
+		 (unsigned long long)layer->clr_l->l_id);
 
-	layer = NULL;
-	m0_tl_for(comp_layer, &cl->cl_layers, layer) {
-		if (layer->clr_idx == layer_idx)
-			break;
-	} m0_tl_endfor;
+	pair_set(&pair, &key, &rec, cl, layer->clr_idx, 0 /* Ignored */);
+	rc = m0_table_delete(tx, &pair);
+	if (rc != 0)
+		m0_layout__log("sublayout_id_indb_delete",
+			       "failed to delete from layer_sublayout table",
+			       M0_LAYOUT_ADDB_LOC_COMP_SUBLAYOUT_DEL,
+			       &layer->clr_l->l_addb_ctx, layer->clr_l->l_id,
+			       rc);
+	m0_db_pair_fini(&pair);
+	M0_RETURN(rc);
+}
 
-	M0_POST(layer != NULL && layer_invariant(layer));
-	return layer;
+static struct m0_emap *emap_from_cl(const struct m0_composite_layout *cl)
+{
+	struct composite_schema_data *csd;
+
+	csd = cl->cl_base.l_dom->ld_type_data[m0_composite_layout_type.lt_id];
+	M0_ASSERT(csd != NULL);
+	return &csd->csd_layer_emap;
 }
 
-static int ext_in_mem_lookup(struct m0_composite_layout *cl,
-			     m0_bindex_t offset,
-			     uint32_t *layer_idx,
-			     struct m0_ext *ext,
-			     uint64_t *ext_state,
-			     struct m0_layout **sublayout)
+static int extmap_indb_add(struct m0_composite_layout *cl,
+			   struct m0_composite_layer *layer,
+			   struct m0_db_tx *tx)
 {
-	struct m0_composite_layer        *layer;
+	struct m0_emap                   *emap;
+	struct m0_emap_cursor             it;
 	struct m0_composite_layer_extent *lr_ext;
-	bool                              found;
-	uint32_t                          i;
+	struct m0_emap_seg               *seg;
+	struct layout_prefix              prefix;
 	int                               rc;
 
-	M0_ENTRY("lid %llu, offset %llu", (unsigned long long)cl->cl_base.l_id,
-		 (unsigned long long)offset);
-#ifndef __KERNEL__
-	printf("ext_in_mem_lookup(): lid %llu, offset %llu\n",
-		 (unsigned long long)cl->cl_base.l_id,
-		 (unsigned long long)offset);
-#endif
+	M0_ENTRY("lid %llu, layer %lu", (unsigned long long)cl->cl_base.l_id,
+		 (unsigned long)layer->clr_idx);
 
-	/* Start the lookup with the top-most layer. */
-	i = cl->cl_layers_nr - 1;
-	found = false;
+	emap = emap_from_cl(cl);
+	prefix_set(&prefix, cl->cl_base.l_id, layer->clr_idx);
+	rc = m0_emap_obj_insert(emap, tx, (struct m0_uint128 *)&prefix,
+				M0_CLRES_INVALID);
+	if (rc != 0) {
+		m0_layout__log("extmap_indb_add",
+			       "failed to insert into layer_emap",
+			       M0_LAYOUT_ADDB_LOC_COMP_LAYER_EMAP_ADD_1,
+			       &cl->cl_base.l_addb_ctx, cl->cl_base.l_id,
+			       rc);
+		return rc;
+	}
 
-#if 0
-	m0_tl_for(comp_layer, &cl->cl_layers, layer) {
-		M0_ASSERT(layer->clr_idx == i);
-		m0_tl_for(m0_composite_layer_ext, layer->clr_extents, lr_ext) {
-			if (offset > lr_ext->cle_ext.e_start)
-				continue;
-			else if (offset < lr_ext->cle_ext.e_end &&
-				 lr_ext->cle_state != M0_CLRES_INVALID) {
-				M0_ASSERT(offset >= lr_ext->cle_ext.e_start);
-				found = true;
-				break;
-			}
-		} m0_tl_endfor;
+	rc = m0_emap_lookup(emap, tx, (struct m0_uint128 *)&prefix, 0, &it);
+	if (rc != 0) {
+		m0_layout__log("extmap_indb_add",
+			       "failed to lookup into layer_emap",
+			       M0_LAYOUT_ADDB_LOC_COMP_LAYER_EMAP_ADD_2,
+			       &cl->cl_base.l_addb_ctx, cl->cl_base.l_id,
+			       rc);
+		m0_emap_obj_delete(emap, tx, (struct m0_uint128 *)&prefix);
+		/*
+		 * If m0_emap_lookup() has failed for no apparent reason, it is
+		 * likely that m0_emap_obj_delete() too would fail. Hence,
+		 * ignoring its status.
+		 */
+		return rc;
+	}
+
+	seg = m0_emap_seg_get(&it);
+	M0_ASSERT(seg->ee_ext.e_start == 0);
+	M0_ASSERT(seg->ee_ext.e_end == M0_BINDEX_MAX + 1);
+	M0_ASSERT(seg->ee_val == M0_CLRES_INVALID);
+
+	m0_tl_for(m0_composite_layer_ext, layer->clr_extents, lr_ext) {
+		M0_ASSERT(M0_IN(lr_ext->cle_state, (M0_CLRES_INVALID,
+						    M0_CLRES_VALID,
+						    M0_CLRES_FLATTENING)));
+		rc = ext_indb_write(&it, layer,
+				    &lr_ext->cle_ext, lr_ext->cle_state,
+				    !INMEM_LIST_UPDATE);
+		if (rc != 0) {
+			M0_LOG(M0_ERROR, "lid %llu, layer %lu, "
+			       "failed to write extent, rc %d",
+			       (unsigned long long)cl->cl_base.l_id,
+			       (unsigned long)layer->clr_idx, rc);
+			m0_emap_close(&it);
+			return rc;
+		}
 	} m0_tl_endfor;
-#endif
 
-	layer = comp_layer_tlist_tail(&cl->cl_layers);
-	M0_ASSERT(layer != NULL);
-	while (layer != NULL) {
-		M0_ASSERT(layer->clr_idx == i);
-		m0_tl_for(m0_composite_layer_ext, layer->clr_extents, lr_ext) {
-			if (offset >= lr_ext->cle_ext.e_end)
-				continue;
-			else {
-				M0_ASSERT(offset >= lr_ext->cle_ext.e_start);
-				M0_ASSERT(offset < lr_ext->cle_ext.e_end);
-				if (lr_ext->cle_state != M0_CLRES_INVALID)
-					found = true;
-				break;
-			}
-		} m0_tl_endfor;
-		if (found)
-			break;
-		layer = comp_layer_tlist_prev(&cl->cl_layers, layer);
-		--i;
-	}
+	m0_emap_close(&it);
+	M0_RETURN(rc);
+}
+
+static int layer_indb_add(struct m0_composite_layout *cl,
+			  struct m0_composite_layer *layer,
+			  struct m0_db_tx *tx)
+{
+	int rc;
+
+	M0_PRE(composite_invariant(cl));
+	/*
+	 * Zeroth layer is already written through comp_layout_indb_add()
+	 * while adding the composite layout to the DB using m0_layout_add().
+	 */
+	M0_PRE(layer->clr_idx > 0);
+	M0_PRE(tx != NULL);
+
+	M0_ENTRY("lid %llu, layer %lu", (unsigned long long)cl->cl_base.l_id,
+		 (unsigned long)layer->clr_idx);
 
-	if (found == true) {
-		*layer_idx = i;
-		*ext = lr_ext->cle_ext;
-		*ext_state = lr_ext->cle_state;
-		layer = layer_find(cl, *layer_idx);
-		M0_ASSERT(layer != NULL);
-		*sublayout = layer->clr_l;
-		rc = 0;
-	} else
-		rc = -ENOENT;
+	/* Add 'the sublayout id for this layer' to the DB. */
+	rc = sublayout_id_indb_add(cl, layer, tx);
+	if (rc != 0)
+		M0_RETURN(rc);
 
-#ifndef __KERNEL__
-	printf("ext_in_mem_lookup(): lid %llu, offset %llu, "
-		"rc %d, layer_id %lu\n",
-		(unsigned long long)cl->cl_base.l_id,
-		(unsigned long long)offset, rc, (unsigned long)*layer_idx);
-#endif
+	/* Add 'the extent map for this layer' to the DB. */
+	rc = extmap_indb_add(cl, layer, tx);
+
+	M0_POST(ergo(rc == 0, composite_invariant(cl)));
 	M0_RETURN(rc);
 }
 
-static int ext_in_db_lookup(struct m0_composite_layout *cl,
-			    m0_bindex_t offset,
-			    struct m0_db_tx *tx,
-			    uint32_t *layer_idx,
-			    struct m0_ext *ext,
-			    uint64_t *ext_state,
-			    struct m0_layout **sublayout)
+static int extentmap_indb_read(struct m0_composite_layout *cl,
+			       uint32_t layer_idx,
+			       struct m0_db_tx *tx,
+			       struct m0_tl **extlist,
+			       uint32_t *extents_nr)
 {
-	struct m0_emap            *emap;
-	struct m0_emap_cursor      it;
-	struct m0_emap_seg        *seg;
-	struct layout_prefix       prefix;
-	struct m0_composite_layer *layer;
-	uint32_t                   i; /* layer idx */
-	bool                       found;
-	int                        rc;
+	struct m0_emap        *emap;
+	struct m0_emap_cursor  it;
+	struct layout_prefix   prefix;
+	struct m0_emap_seg    *seg;
+	int                    rc;
 
-	M0_PRE(tx != NULL);
-	M0_ENTRY("lid %llu, offset %llu", (unsigned long long)cl->cl_base.l_id,
-		 (unsigned long long)offset);
-#ifndef __KERNEL__
-	printf("ext_in_db_lookup(): lid %llu, offset %llu\n",
-		 (unsigned long long)cl->cl_base.l_id,
-		 (unsigned long long)offset);
-#endif
+	M0_ENTRY("lid %llu, layer %lu", (unsigned long long)cl->cl_base.l_id,
+		 (unsigned long)layer_idx);
 
 	emap = emap_from_cl(cl);
+	prefix_set(&prefix, cl->cl_base.l_id, layer_idx);
+	rc = m0_emap_lookup(emap, tx, (struct m0_uint128 *)&prefix, 0, &it);
+	if (rc != 0) {
+		m0_layout__log("extentmap_indb_read",
+			       "failed to lookup into layer_emap",
+			       M0_LAYOUT_ADDB_LOC_COMP_EMAP_READ_1,
+			       &cl->cl_base.l_addb_ctx, cl->cl_base.l_id, rc);
+		return rc;
+	}
 
-	/* Start the lookup with the top-most layer. */
-	i = cl->cl_layers_nr - 1;
-	found = false;
+	M0_ALLOC_PTR(*extlist);
+	if (*extlist == NULL) {
+		m0_layout__log("extentmap_indb_read",
+			       "failed to allocate composite extent list",
+			       M0_LAYOUT_ADDB_LOC_COMP_EMAP_READ_2,
+			       &cl->cl_base.l_addb_ctx, cl->cl_base.l_id,
+			       -ENOMEM);
+		m0_emap_close(&it);
+		return -ENOMEM;
+	}
+	m0_composite_layer_ext_tlist_init(*extlist);
+
+	*extents_nr = 0;
+	seg = m0_emap_seg_get(&it);
 	while (1) {
-		prefix_set(&prefix, cl->cl_base.l_id, i);
-		rc = m0_emap_lookup(emap, tx, (struct m0_uint128 *)&prefix,
-				    offset, &it);
-		if (rc != 0) {
-			m0_layout__log("m0_composite_layer_ext_lookup",
-				       "failed to lookup into layer_emap",
-				       M0_LAYOUT_ADDB_LOC_COMP_EXT_LOOKUP,
+		M0_ASSERT(seg != NULL);
+		if (m0_ext_is_empty(&seg->ee_ext) ||
+		    !M0_IN(seg->ee_val, (M0_CLRES_INVALID, M0_CLRES_VALID,
+					 M0_CLRES_FLATTENING))) {
+			m0_layout__log("extentmap_indb_read",
+				       "Invalid extent found in the DB",
+				       M0_LAYOUT_ADDB_LOC_COMP_EMAP_READ_3,
 				       &cl->cl_base.l_addb_ctx,
-				       cl->cl_base.l_id, rc);
-			m0_mutex_unlock(&cl->cl_base.l_lock);
-			return rc;
+				       cl->cl_base.l_id, -ENOMEM);
+			extlist_free(*extlist);
+			m0_emap_close(&it);
+			return -EINVAL;
 		}
 
-		seg = m0_emap_seg_get(&it);
-		m0_emap_close(&it);
-		M0_ASSERT(seg != NULL);
-		M0_ASSERT(!m0_ext_is_empty(&seg->ee_ext));
-		M0_ASSERT(M0_IN(seg->ee_val, (M0_CLRES_INVALID, M0_CLRES_VALID,
-					      M0_CLRES_FLATTENING)));
-
-		if (seg->ee_val != M0_CLRES_INVALID) {
-			found = true;
-			break;
+		rc = ext_inmem_add_internal(NULL, &cl->cl_base, *extlist,
+					    &seg->ee_ext, seg->ee_val,
+					    ADD_AT_TAIL, NULL);
+		if (rc != 0) {
+			//todo M0_LOG
+			extlist_free(*extlist);
+			m0_emap_close(&it);
+			return rc;
 		}
+		*extents_nr = m0_composite_layer_ext_tlist_length(*extlist);
 
-		if (i > 0)
-			--i;
-		else
+		if (m0_emap_ext_is_last(&seg->ee_ext))
 			break;
+		m0_emap_next(&it);
+		seg = m0_emap_seg_get(&it);
 	}
+	m0_emap_close(&it);
 
-	if (found == true) {
-		*layer_idx = i;
-		*ext = seg->ee_ext;
-		*ext_state = seg->ee_val;
-		layer = layer_find(cl, *layer_idx);
-		M0_ASSERT(layer != NULL);
-		*sublayout = layer->clr_l;
-		rc = 0;
-	} else
-		rc = -ENOENT;
-
-#ifndef __KERNEL__
-	printf("ext_in_db_lookup(): lid %llu, offset %llu, "
-		"rc %d, layer_id %lu\n",
-		(unsigned long long)cl->cl_base.l_id,
-		(unsigned long long)offset, rc, (unsigned long)*layer_idx);
-#endif
+	M0_POST(*extents_nr > 0);
 	M0_RETURN(rc);
 }
 
-/*
- * todo Verify functioning of this API. Currently in UT, all the layers
- * contain same list of extents. So traversing layers part is not being
- * verified.
+/**
+ * Reads 'the composite layout type specific information including all the
+ * layers' from the DB and adds it to the in-memory layout.
  */
-M0_INTERNAL int m0_composite_layer_ext_lookup(struct m0_composite_layout *cl,
-					      m0_bindex_t offset,
-					      struct m0_db_tx *tx,
-					      uint32_t *layer_idx,
-					      struct m0_ext *ext,
-					      uint64_t *ext_state,
-					      struct m0_layout **sublayout)
+static int comp_layout_indb_read(struct m0_composite_layout *cl,
+				 struct m0_db_tx *tx,
+				 uint32_t user_count)
 {
-	int rc;
+	uint64_t                   sublayout_id;
+	struct m0_layout          *sublayout;
+	struct m0_tl              *extents;
+	uint32_t                   extents_nr;
+	struct m0_composite_layer *layer;
+	uint32_t                   i; /* layer idx */
+	int                        rc;
 
-	M0_PRE(composite_invariant(cl));
-	M0_PRE(offset >= 0 && offset <= M0_BINDEX_MAX);
-	M0_PRE(ext != NULL && ext_state != NULL && sublayout != NULL);
-	M0_PRE(ergo(cl->cl_base.l_dom->ld_is_db_available, tx != NULL));
+	M0_ENTRY("lid %llu", (unsigned long long)cl->cl_base.l_id);
 
-	M0_ENTRY("lid %llu, offset %llu", (unsigned long long)cl->cl_base.l_id,
-		 (unsigned long long)offset);
-#ifndef __KERNEL__
-	printf("m0_composite_layer_ext_lookup(): lid %llu, offset %llu\n",
-		 (unsigned long long)cl->cl_base.l_id,
-		 (unsigned long long)offset);
-#endif
+	i = 0;
+	while (1) {
+		/* Read 'the sublayout id for this layer' from the DB. */
+		rc = sublayout_id_indb_lookup(cl, i, tx, &sublayout_id);
+		if (rc != 0) {
+			M0_ASSERT(i > 0);
+			if (rc == -ENOENT)
+				/*
+				 * The number of layers is not known in
+				 * advance. Hence, break when the first
+				 * -ENOENT error is encountered.
+				 */
+				rc = 0;
+			else
+				M0_LOG(M0_ERROR, "lid %llu, layer %lu, "
+				       "sublayout id could not be read from "
+				       "the DB",
+				       (unsigned long long)cl->cl_base.l_id,
+				       (unsigned long)i);
+			break;
+		}
 
-	m0_mutex_lock(&cl->cl_base.l_lock);
+		sublayout = layout_find(cl->cl_base.l_dom, sublayout_id);
+		if (sublayout == NULL) {
+			M0_LOG(M0_ERROR, "lid %llu, layer %lu, sublayout with "
+			       "lid %llu does not exist",
+			       (unsigned long long)cl->cl_base.l_id,
+			       (unsigned long)i,
+			       (unsigned long long)sublayout_id);
+			rc = -EINVAL;
+			break;
+		}
 
-	if (!cl->cl_base.l_dom->ld_is_db_available)
-		rc = ext_in_mem_lookup(cl, offset, layer_idx,
-				       ext, ext_state, sublayout);
-	else
-		rc = ext_in_db_lookup(cl, offset, tx, layer_idx,
-				      ext, ext_state, sublayout);
-	M0_ASSERT(rc == 0 || rc == -ENOENT); //todo Handle, log etc
+		/* Read 'the extent map for this layer' from the DB. */
+		rc = extentmap_indb_read(cl, i, tx, &extents, &extents_nr);
+		if (rc != 0) {
+			M0_LOG(M0_ERROR, "lid %llu, layer %lu, extentmap could"
+			       "not be read from the DB",
+			       (unsigned long long)cl->cl_base.l_id,
+			       (unsigned long)i);
+			/* Release the reference added by m0_layout_find(). */
+			m0_layout_put(sublayout);
+			break;
+		}
+
+		if (i == 0)
+			rc = composite_populate(cl, sublayout, extents,
+						extents_nr, user_count);
+		else
+			/* Now, write the layer to the in-memory layout. */
+			rc = layer_inmem_add(cl, sublayout, extents,
+					     extents_nr, &layer);
+		if (rc != 0) {
+			M0_LOG(M0_ERROR, "lid %llu, layer %lu could not be "
+			       "written to the layout",
+			       (unsigned long long)cl->cl_base.l_id,
+			       (unsigned long)i);
+			/* Release the reference added by m0_layout_find(). */
+			m0_layout_put(sublayout);
+			break;
+		}
+
+		/*
+		 * Release the reference added by m0_layout_find().
+		 * layer_inmem_add() has now added a reference on this
+		 * sublayout.
+		 */
+		M0_ASSERT(rc == 0);
+		m0_layout_put(sublayout);
+
+		++i;
+	}
 
-	m0_mutex_unlock(&cl->cl_base.l_lock);
-	M0_LEAVE("lid %llu, offset %llu, rc %d, layer_id %lu",
-		 (unsigned long long)cl->cl_base.l_id,
-		 (unsigned long long)offset, rc, (unsigned long)*layer_idx);
-#ifndef __KERNEL__
-	printf("m0_composite_layer_ext_lookup(): lid %llu, offset %llu, "
-		"rc %d, layer_id %lu\n",
-		(unsigned long long)cl->cl_base.l_id,
-		(unsigned long long)offset, rc, (unsigned long)*layer_idx);
-#endif
-	M0_PRE(composite_invariant(cl));
-	return rc;
+	M0_RETURN(rc);
 }
 
-static int ext_split_internal(struct m0_composite_layer *layer,
-			      struct m0_composite_layer_extent *lr_ext,
-			      struct m0_indexvec *vec,
-			      m0_bindex_t scan)
+static int comp_layout_indb_add(struct m0_composite_layout *cl,
+				struct m0_db_tx *tx)
 {
-	struct m0_ext                     ext;
-	m0_bcount_t                       len;
-	uint32_t                          i;
-	int                               rc;
-
-	M0_PRE(m0_composite_layer_ext_tlink_is_in(lr_ext));
+	struct m0_composite_layer *layer;
+	int                        rc;
 
-#ifndef __KERNEL__
-	printf("ext_split_internal(): len0 %llu, len1 %llu, len2 %llu\n",
-		(unsigned long long)vec->iv_vec.v_count[0],
-		(unsigned long long)vec->iv_vec.v_count[1],
-		(unsigned long long)vec->iv_vec.v_count[2]);
-#endif
+	M0_ENTRY("lid %llu", (unsigned long long)cl->cl_base.l_id);
 
-	for (i = 0; i < vec->iv_vec.v_nr; ++i) {
-		len = vec->iv_vec.v_count[i];
-		if (len != 0) {
-			ext.e_start = scan;
-			ext.e_end = scan = scan + len;
-			rc = ext_in_mem_add_internal(layer, NULL, NULL,
-						     &ext, vec->iv_index[i],
-						     ADD_BEFORE, lr_ext);
-			M0_ASSERT(rc == 0); //todo Handle
-			//todo If i==0, check if the ext shall be merged with th prior one
-			if (rc != 0)
-				break;
-		}
+	/* Collect the zeroth layer from the in-memory layout. */
+	layer = comp_layer_tlist_head(&cl->cl_layers);
+	M0_ASSERT(layer->clr_idx == 0);
+	rc = sublayout_id_indb_add(cl, layer, tx);
+	if (rc == 0) {
+		/* Add 'the extent map for this layer' to the DB. */
+		rc = extmap_indb_add(cl, layer, tx);
+		if (rc != 0)
+			/*
+			 * If extmap_indb_add() has failed for no apparent
+			 * reason, it is likely that sublayout_id_indb_delete()
+			 * would fail. Hence, ignoring its return status.
+			 */
+			sublayout_id_indb_delete(cl, layer, tx);
 	}
 
-	ext_in_mem_del_internal(layer, lr_ext);
+	M0_LEAVE("lid %llu, rc %d", (unsigned long long)cl->cl_base.l_id, rc);
 	return rc;
 }
 
-static int ext_in_mem_write(struct m0_composite_layout *cl,
-			    struct m0_composite_layer *layer,
-			    const struct m0_ext *ext,
-			    uint64_t ext_state,
-			    bool ext_validate)
+static int comp_layout_indb_delete(struct m0_composite_layout *cl,
+				   struct m0_db_tx *tx)
 {
+	struct m0_composite_layer        *layer;
 	struct m0_composite_layer_extent *lr_ext;
-	struct m0_composite_layer_extent *next_lr_ext;
-	struct m0_composite_layer_extent *lr_ext_to_del;
-	struct m0_composite_layer_extent *lr_ext_to_del1; //todo rm
-	struct m0_composite_layer_extent *ext_to_insert_into;
-	uint64_t                          ext_state_orig;
-	struct m0_ext                    *chunk;
-	struct m0_ext                     ext0 = *ext; /* A read-write copy. */
-	uint32_t                          i; //todo rm
 	int                               rc;
-	int                               rc1;
-
-	M0_PRE(layer_invariant(layer));
-	M0_PRE(!m0_ext_is_empty(ext));
-	M0_ENTRY("lid %llu, layer %lu, e_start %llu, e_end %llu, e_state %llu",
-		 (unsigned long long)layer->clr_l->l_id,
-		 (unsigned long)layer->clr_idx,
-		 (unsigned long long)ext->e_start,
-		 (unsigned long long)ext->e_end,
-		 (unsigned long long)ext_state);
-
-	/* Find the first nearest in-memory extent. */
-	ext_to_insert_into = NULL;
-	m0_tl_for(m0_composite_layer_ext, layer->clr_extents, lr_ext) {
-		if (ext->e_start >= lr_ext->cle_ext.e_start)
-			ext_to_insert_into = lr_ext;
-	} m0_tl_endfor;
-	M0_ASSERT(ext_to_insert_into != NULL);
-#ifndef __KERNEL__
-	printf("ext_in_mem_write(1): lid %llu, layer %lu, \n"
-		"\te_start %llu, e_end %llu, e_state %llu, \n"
-		"\text_to_insert_into_start %llu, \n "
-		"\text_to_insert_into_end %llu\n",
-		 (unsigned long long)layer->clr_l->l_id,
-		 (unsigned long)layer->clr_idx,
-		 (unsigned long long)ext->e_start,
-		 (unsigned long long)ext->e_end,
-		 (unsigned long long)ext_state,
-		 (unsigned long long)ext_to_insert_into->cle_ext.e_start,
-		 (unsigned long long)ext_to_insert_into->cle_ext.e_end);
-#endif
-
-	if (ext_validate) {
-		M0_ASSERT(M0_IN(ext_to_insert_into->cle_state,
-				(M0_CLRES_INVALID, M0_CLRES_VALID,
-				 M0_CLRES_FLATTENING)));
-		if (ext_to_insert_into->cle_ext.e_start != ext->e_start ||
-		    ext_to_insert_into->cle_ext.e_end != ext->e_end ||
-		    ext_to_insert_into->cle_state == M0_CLRES_INVALID) {
-			rc = -EINVAL;
-			//todo M0_LOG?
-			m0_layout__log("ext_in_mem_write",
-				       "A non-existing extent can not be "
-				       "updated or deleted",
-				       M0_LAYOUT_ADDB_LOC_COMP_EXT_UPDATE_2, //todo
-				       &cl->cl_base.l_addb_ctx,
-				       cl->cl_base.l_id, rc);
-			return rc;
-		}
-	}
-
-	if (ext_to_insert_into->cle_ext.e_start == ext->e_start &&
-	    ext_to_insert_into->cle_ext.e_end == ext->e_end &&
-	    ext_to_insert_into->cle_state == ext_state)
-		/* The exact extent already exists. */
-		M0_RETURN(0);
 
-	/* todo check if chunk shall not be a pointer. */
-	chunk = &ext_to_insert_into->cle_ext;
-	M0_ASSERT(m0_ext_is_in(chunk, ext->e_start));
-	M0_ASSERT(layer_invariant(layer));
+	M0_ENTRY("lid %llu", (unsigned long long)cl->cl_base.l_id);
 
 	/*
-	 * Iterate over existing extent overlapping with the new one,
-	 * calculating for each, what parts have to be deleted and what remains.
-	 *
-	 * In the worst case, an existing extent can split into three
-	 * parts. Generally, some of these parts can be empty.
-	 *
-	 * Note that the _whole_ new segment is inserted on the last iteration
-	 * of the loop below (see length[1] assignment), thus violating the map
-	 * invariant until the loop exits (the map is "porous" during that
-	 * time).
+	 * A composite layout can be deleted from the DB if and only if none of
+	 * its layers contain any valid extents.
 	 */
+	m0_tl_for(comp_layer, &cl->cl_layers, layer) {
+		m0_tl_for(m0_composite_layer_ext, layer->clr_extents, lr_ext) {
+			if (lr_ext->cle_state != M0_CLRES_INVALID) {
+				M0_LOG(M0_ERROR, "lid %llu, layout can not be "
+				       "deleted since layer %lu still "
+				       "contains at least one valid extent",
+				       (unsigned long long)cl->cl_base.l_id,
+				       (unsigned long)layer->clr_idx);
+				return -EINVAL;;
+			}
+		} m0_tl_endfor;
+	} m0_tl_endfor;
 
-	i = 0;
-	while (!m0_ext_is_empty(&ext0)) {
-		m0_bcount_t    length[3];
-		m0_bindex_t    bstart[3] = { 0 };
-		m0_bcount_t    consumed;
-		struct m0_ext  clip;
-		bool           split_required;
-		bool           delete_required;
-#if 1 //todo Probably don't need it to be a vector
-		struct m0_indexvec vec = {
-			.iv_vec = {
-				.v_nr    = 3,
-				.v_count = length
-			},
-			.iv_index = bstart
-		};
-#endif
-
-		m0_ext_intersection(&ext0, chunk, &clip);
-		M0_ASSERT(clip.e_start == ext0.e_start);
-		consumed = m0_ext_length(&clip);
-		M0_ASSERT(consumed > 0);
-
-		length[0] = clip.e_start - chunk->e_start;
-		length[1] = clip.e_end == ext0.e_end ? m0_ext_length(ext) : 0;
-		length[2] = chunk->e_end - clip.e_end;
-
-		bstart[0] = ext_state;
-		ext_state_orig = ext_to_insert_into->cle_state;
-
-		if (length[0] > 0)
-			bstart[0] = ext_state_orig;
-		if (length[2] > 0)
-			bstart[2] = ext_state_orig;
-#ifndef __KERNEL__
-	printf("ext_in_mem_write(2): i %lu, lid %llu, layer %lu \n"
-		"\te_start %llu, e_end %llu \n"
-		"\text_to_insert_into_start %llu, \n"
-		"\text_to_insert_into_end %llu\n"
-		"\tchunk_start %llu, chunk_end %llu\n "
-		"\tclip_start %llu, clip_end %llu \n"
-		"\tlength[0] %llu, bstart[0], %llu \n"
-		"\tlength[1] %llu, bstart[1],%llu \n"
-		"\tlength[2] %llu, bstart[2] %llu \n",
-		(unsigned long)i, (unsigned long long)layer->clr_l->l_id,
-		(unsigned long)layer->clr_idx,
-		(unsigned long long)ext0.e_start,
-		(unsigned long long)ext0.e_end,
-		(unsigned long long)ext_to_insert_into->cle_ext.e_start,
-		(unsigned long long)ext_to_insert_into->cle_ext.e_end,
-		(unsigned long long)chunk->e_start,
-		(unsigned long long)chunk->e_end,
-		(unsigned long long)clip.e_start,
-		(unsigned long long)clip.e_end,
-		(unsigned long long)length[0], (unsigned long long)bstart[0],
-		(unsigned long long)length[1], (unsigned long long)bstart[1],
-		(unsigned long long)length[2], (unsigned long long)bstart[2]);
-#endif
-
-		split_required  = true;
-		delete_required = false;
-		lr_ext_to_del   = NULL;
-		next_lr_ext     = NULL;
-		if (length[0] == 0 && length[2] == 0) {
-			delete_required = true;
-			lr_ext_to_del = ext_to_insert_into;
+	/* todo Confirm check similar to the above for indb extent list per layer */
 
-			if (length[1] == 0)
-				split_required = false;
-			else if (ext_to_insert_into->cle_ext.e_start ==
-				 ext0.e_start &&
-				 ext_to_insert_into->cle_ext.e_end ==
-				 ext0.e_end) {
-				split_required = false;
-				/* todo This is not correct, why?
-				M0_ASSERT(length[1] ==
-					  m0_ext_length(&ext0));
-				*/
-			}
-		}
+	rc = 0; /* To keep the compiler happy. */
+	m0_tl_for(comp_layer, &cl->cl_layers, layer) {
+		rc = sublayout_id_indb_delete(cl, layer, tx);
+		if (rc != 0)
+			break;
 
 		/*
-		 * ext_split_internal() may replace the current node that is
-		 * ext_to_insert_into, with multiple smaller segments. Hence,
-		 * store the next node before invoking ext_split_internal().
+		 * Decrement the user count incremented while adding the
+		 * layer to the composite layout.
 		 */
-		if (!m0_ext_is_empty(&ext0)) {
-			next_lr_ext = m0_composite_layer_ext_tlist_next(
-                                                        layer->clr_extents,
-                                                        ext_to_insert_into);
+		m0_layout_user_count_dec(layer->clr_l);
+	} m0_tl_endfor;
 
-			/*
-			 * If ext is not yet empty, ext_to_insert_into should
-			 * not be the last element of the list.
-			 */
-			M0_ASSERT(next_lr_ext != NULL);
-		}
+	M0_ENTRY("lid %llu, rc %d", (unsigned long long)cl->cl_base.l_id, rc);
+	return rc;
+}
 
+static int ext_indb_lookup(struct m0_composite_layout *cl,
+			   m0_bindex_t offset,
+			   struct m0_db_tx *tx,
+			   struct m0_ext *ext,
+			   uint32_t *layer_idx,
+			   uint64_t *ext_state,
+			   struct m0_layout **sublayout)
+{
+	struct m0_emap            *emap;
+	struct m0_emap_cursor      it;
+	struct m0_emap_seg        *seg;
+	struct layout_prefix       prefix;
+	struct m0_composite_layer *layer;
+	uint32_t                   i; /* layer idx */
+	bool                       found;
+	int                        rc;
+
+	M0_PRE(tx != NULL);
+	M0_ENTRY("lid %llu, offset %llu", (unsigned long long)cl->cl_base.l_id,
+		 (unsigned long long)offset);
 #ifndef __KERNEL__
-		printf("ext_in_mem_write(4): i %lu, lid %llu, layer %lu, \n"
-			"\te_start %llu, e_end %llu, \n"
-			"\text_to_del_start %llu, ext_to_del_end %llu \n"
-			"\tdelete_reqd %d, split_reqd %d \n"
-			"\tnext_start %llu, next_end %llu \n",
-			(unsigned long)i,
-			(unsigned long long)layer->clr_l->l_id,
-			(unsigned long)layer->clr_idx,
-			(unsigned long long)ext0.e_start,
-			(unsigned long long)ext0.e_end,
-			lr_ext_to_del == NULL ? 0 :
-			(unsigned long long)lr_ext_to_del->cle_ext.e_start,
-			lr_ext_to_del == NULL ? 0 :
-			(unsigned long long)lr_ext_to_del->cle_ext.e_end,
-			delete_required, split_required,
-			next_lr_ext == NULL ? 0 :
-			(unsigned long long)next_lr_ext->cle_ext.e_start,
-			next_lr_ext == NULL ? 0 :
-			(unsigned long long)next_lr_ext->cle_ext.e_end);
+	printf("ext_indb_lookup(): lid %llu, offset %llu\n",
+		 (unsigned long long)cl->cl_base.l_id,
+		 (unsigned long long)offset);
 #endif
 
-		if (split_required) {
-			rc = ext_split_internal(layer, ext_to_insert_into,
-						&vec,
-						length[0] > 0 ?
-						chunk->e_start : ext->e_start);
-			if (rc != 0) //todo trace msg
-				break;
-		} else
-			rc = 0; //todo check if req'd
+	emap = emap_from_cl(cl);
+
+	/* Start the lookup with the top-most layer. */
+	i = cl->cl_layers_nr - 1;
+	found = false;
+	while (1) {
+		prefix_set(&prefix, cl->cl_base.l_id, i);
+		rc = m0_emap_lookup(emap, tx, (struct m0_uint128 *)&prefix,
+				    offset, &it);
+		if (rc != 0) {
+			m0_layout__log("m0_composite_layer_ext_lookup",
+				       "failed to lookup into layer_emap",
+				       M0_LAYOUT_ADDB_LOC_COMP_EXT_LOOKUP,
+				       &cl->cl_base.l_addb_ctx,
+				       cl->cl_base.l_id, rc);
+			m0_mutex_unlock(&cl->cl_base.l_lock);
+			return rc;
+		}
 
-		if (delete_required == true)
-			ext_in_mem_del_internal(layer, lr_ext_to_del);
+		seg = m0_emap_seg_get(&it);
+		m0_emap_close(&it);
+		M0_ASSERT(seg != NULL);
+		M0_ASSERT(!m0_ext_is_empty(&seg->ee_ext));
+		M0_ASSERT(M0_IN(seg->ee_val, (M0_CLRES_INVALID, M0_CLRES_VALID,
+					      M0_CLRES_FLATTENING)));
 
-		ext0.e_start += consumed;
-		M0_ASSERT(ext0.e_start <= ext0.e_end);
-		if (!m0_ext_is_empty(&ext0)) {
-			ext_to_insert_into = next_lr_ext;
-			chunk = &ext_to_insert_into->cle_ext;
-			if (ext_to_insert_into == NULL)
-				break;
+		if (seg->ee_val != M0_CLRES_INVALID) {
+			found = true;
+			break;
 		}
 
-		++i;
+		if (i > 0)
+			--i;
+		else
+			break;
 	}
 
-	if (rc == 0) {
-		/*
-		 * Now that the deletion/trimming of the overlapping extents
-		 * has been handled above, let's add the ultimate whole extent.
-		 */
-		/*
-		 * This is not exactly right.
-		 * Shall query for the extent and its state and if it is inval
-		 * then add the ext
-		 * OR
-		 * change ext_in_mem_find() such that it returns ENOENT
-		 * if the ext is with the inval state
-		 */
-		rc = ext_in_mem_find(layer, ext, M0_CLRES_INVALID,
-				     &lr_ext_to_del1);
-		// todo Feb 11 if (rc == -ENOENT) {
-		if (rc == 0) {
-			lr_ext_to_del1->cle_state = ext_state;
-#if 0
-			if (ext_state != M0_CLRES_INVALID) {
-				/* todo Refactor usage of
-				 * ext_in_mem_add_internal() so that
-				 * don't have to pass the adjacent ext
-				 */
-				/* todo Latest, don't add and then delete, just
-				 * change state of the existing ext.
-				 */
-				rc = ext_in_mem_add(layer, ext, ext_state);
-				M0_ASSERT(rc == 0);
-				ext_in_mem_del_internal(layer,
-							lr_ext_to_del1);
-				M0_ASSERT(rc == 0);
-			}
-#endif
-		} else {
-			rc1 = ext_in_mem_find(layer, ext, ext_state,
-					      &lr_ext_to_del1);
-			M0_ASSERT(rc1 == -ENOENT); //todo correct?
-			if (rc1 == -ENOENT) {
-				rc = ext_in_mem_add(layer, ext, ext_state);
-				M0_ASSERT(rc == 0);
-			}
-		}
-	}
+	if (found == true) {
+		*ext = seg->ee_ext;
+		*layer_idx = i;
+		*ext_state = seg->ee_val;
+		layer = layer_find(cl, *layer_idx);
+		M0_ASSERT(layer != NULL);
+		*sublayout = layer->clr_l;
+		rc = 0;
+	} else
+		rc = -ENOENT;
 
-	M0_POST(layer_invariant(layer));
-	return rc;
+#ifndef __KERNEL__
+	printf("ext_indb_lookup(): lid %llu, offset %llu, "
+		"rc %d, layer_id %lu\n",
+		(unsigned long long)cl->cl_base.l_id,
+		(unsigned long long)offset, rc, (unsigned long)*layer_idx);
+#endif
+	M0_RETURN(rc);
 }
 
 static int emap_iterator_set(struct m0_composite_layout *cl,
@@ -2591,216 +2781,20 @@ static int emap_iterator_set(struct m0_composite_layout *cl,
 	return rc;
 }
 
-// todo this one shall accept new_state which shall never be INVALID
-M0_INTERNAL int m0_composite_layer_ext_add(struct m0_composite_layout *cl,
-					   uint32_t layer_idx,
-					   const struct m0_ext *ext,
-					   struct m0_db_tx *tx)
-{
-	struct m0_composite_layer *layer;
-	struct m0_emap_cursor      it;
-	int                        rc;
-
-	M0_PRE(composite_invariant(cl));
-	M0_PRE(ext != NULL);
-	/* todo
-	 * M0_PRE(M0_IN(new_state, (M0_CLRES_VALID, M0_CLRES_FLATTENING))); */
-	M0_PRE(ergo(cl->cl_base.l_dom->ld_is_db_available, tx != NULL));
-
-	M0_ENTRY("lid %llu, layer %lu, e_start %llu, e_end %llu",
-		 (unsigned long long)cl->cl_base.l_id,
-		 (unsigned long)layer_idx, (unsigned long long)ext->e_start,
-		 (unsigned long long)ext->e_end);
-#ifndef __KERNEL__
-	printf("m0_composite_layer_ext_add(): lid %llu, layer %lu \n"
-		"\te_start %llu, e_end %llu \n",
-		 (unsigned long long)cl->cl_base.l_id,
-		 (unsigned long)layer_idx, (unsigned long long)ext->e_start,
-		 (unsigned long long)ext->e_end);
-#endif
-
-	m0_mutex_lock(&cl->cl_base.l_lock);
-	layer = layer_find(cl, layer_idx);
-
-	if (!cl->cl_base.l_dom->ld_is_db_available)
-		rc = ext_in_mem_write(cl, layer, ext, M0_CLRES_VALID,
-				      !EXT_VALIDATE);
-	else {
-		rc = emap_iterator_set(cl, layer_idx, ext, tx,
-				       !EXT_VALIDATE, &it);
-		M0_ASSERT(rc == 0 || rc == -EINVAL); //todo Handle
-
-		if (rc == 0) {
-			//todo Check the following comment
-			/**
-			 * @todo In short: Break ext into multiple, based on
-			 * values (extent states) of 'multiple segments the
-			 * ext may span over'.
-			 *
-			 * Details: Two extents can be merged if and only if
-			 * they are 'back-to-back' (this part is taken care of
-			 * by  m0_emap_paste()) and their state is the same.
-			 *
-			 * To conform to the latter need, it is planned to
-			 * check the states of 'all the existing extents in
-			 * the emap, the ext spans over'. If they are not the
-			 * same, then accordingly, multiple ext_in_db_write()
-			 * requests are generated.
-			 *
-			 * This will be implemented once this design point is
-			 * agreed upon during CINSP_PREUT.
-			 */
-
-			rc = ext_in_db_write(&it, layer, ext, //new_state,
-					     M0_CLRES_VALID,
-					     IN_MEM_LIST_UPDATE);
-			if (rc != 0)
-				m0_layout__log("m0_composite_layer_ext_add",
-					       "failed to write extent",
-					       M0_LAYOUT_ADDB_LOC_COMP_EXT_UPDATE_3, //todo
-					       &cl->cl_base.l_addb_ctx,
-					       cl->cl_base.l_id, rc);
-			m0_emap_close(&it);
-		}
-	}
-
-	m0_mutex_unlock(&cl->cl_base.l_lock);
-	M0_POST(layer_invariant(layer));
-	M0_POST(composite_invariant(cl));
-	M0_LEAVE("lid %llu, layer %lu, e_start %llu, e_end %llu, rc %d",
-		 (unsigned long long)cl->cl_base.l_id,
-		 (unsigned long)layer_idx, (unsigned long long)ext->e_start,
-		 (unsigned long long)ext->e_end, rc);
-	return rc;
-}
-
-M0_INTERNAL int m0_composite_layer_ext_state_update(
-					struct m0_composite_layout *cl,
-					uint32_t layer_idx,
-					const struct m0_ext *ext,
-					uint64_t new_state,
-					struct m0_db_tx *tx)
+M0_INTERNAL struct m0_composite_layout *m0_layout_to_cl(
+						const struct m0_layout *l)
 {
-	struct m0_composite_layer *layer;
-	struct m0_emap_cursor      it;
-	int                        rc;
-
-	M0_PRE(composite_invariant(cl));
-	M0_PRE(ext != NULL);
-	M0_PRE(M0_IN(new_state, (M0_CLRES_VALID, M0_CLRES_FLATTENING)));
-	M0_PRE(ergo(cl->cl_base.l_dom->ld_is_db_available, tx != NULL));
-
-	M0_ENTRY("lid %llu, layer %lu, e_start %llu, e_end %llu, e_state %llu",
-		 (unsigned long long)cl->cl_base.l_id,
-		 (unsigned long)layer_idx, (unsigned long long)ext->e_start,
-		 (unsigned long long)ext->e_end, (unsigned long long)new_state);
-#ifndef __KERNEL__
-	printf("m0_composite_layer_ext_state_update(): lid %llu, layer %lu, "
-		"e_start %llu, e_end %llu, e_state %llu\n",
-		 (unsigned long long)cl->cl_base.l_id,
-		 (unsigned long)layer_idx, (unsigned long long)ext->e_start,
-		 (unsigned long long)ext->e_end, (unsigned long long)new_state);
-#endif
-
-	m0_mutex_lock(&cl->cl_base.l_lock);
-	layer = layer_find(cl, layer_idx);
-
-	if (!cl->cl_base.l_dom->ld_is_db_available) {
-		rc = ext_in_mem_write(cl, layer, ext, new_state, EXT_VALIDATE);
-	} else {
-		rc = emap_iterator_set(cl, layer_idx, ext, tx,
-				       EXT_VALIDATE, &it);
-		M0_ASSERT(rc == 0 || rc == -EINVAL); //todo Handle
+	struct m0_composite_layout *cl;
 
-		if (rc == 0) {
-			rc = ext_in_db_write(&it, layer, ext, new_state,
-					     IN_MEM_LIST_UPDATE);
-			if (rc != 0)
-				//todo Make this M0_LOG??
-				m0_layout__log("m0_composite_layer_ext_state_update",
-					       "failed to write extent",
-					       M0_LAYOUT_ADDB_LOC_COMP_EXT_UPDATE_3, //todo
-					       &cl->cl_base.l_addb_ctx,
-					       cl->cl_base.l_id, rc);
-			m0_emap_close(&it);
-		}
-	}
-	m0_mutex_unlock(&cl->cl_base.l_lock);
-	M0_POST(layer_invariant(layer));
+	cl = bob_of(l, struct m0_composite_layout, cl_base, &composite_bob);
 	M0_POST(composite_invariant(cl));
-	M0_LEAVE("lid %llu, layer %lu, e_start %llu, e_end %llu, "
-		 "e_state %llu, rc %d",
-		 (unsigned long long)cl->cl_base.l_id,
-		 (unsigned long)layer_idx, (unsigned long long)ext->e_start,
-		 (unsigned long long)ext->e_end,
-		 (unsigned long long)new_state, rc);
-	return rc;
+	return cl;
 }
 
-M0_INTERNAL int m0_composite_layer_ext_delete(struct m0_composite_layout *cl,
-					      uint32_t layer_idx,
-					      const struct m0_ext *ext,
-					      struct m0_db_tx *tx)
+M0_INTERNAL struct m0_layout *m0_cl_to_layout(struct m0_composite_layout *cl)
 {
-	struct m0_composite_layer *layer;
-	struct m0_emap_cursor      it;
-	int                        rc;
-
 	M0_PRE(composite_invariant(cl));
-	M0_PRE(ext != NULL);
-	M0_PRE(ergo(cl->cl_base.l_dom->ld_is_db_available, tx != NULL));
-
-	M0_ENTRY("lid %llu, layer %lu, e_start %llu, e_end %llu, ext %p",
-		 (unsigned long long)cl->cl_base.l_id,
-		 (unsigned long)layer_idx, (unsigned long long)ext->e_start,
-		 (unsigned long long)ext->e_end, ext);
-#ifndef __KERNEL__
-	printf("m0_composite_layer_ext_delete(1): lid %llu, layer %lu, "
-		"e_start %llu, e_end %llu, ext %p\n",
-		 (unsigned long long)cl->cl_base.l_id,
-		 (unsigned long)layer_idx, (unsigned long long)ext->e_start,
-		 (unsigned long long)ext->e_end, ext);
-#endif
-
-	m0_mutex_lock(&cl->cl_base.l_lock);
-	layer = layer_find(cl, layer_idx);
-
-	if (!cl->cl_base.l_dom->ld_is_db_available)
-		rc = ext_in_mem_write(cl, layer, ext, M0_CLRES_INVALID,
-				      EXT_VALIDATE);
-	else {
-		rc = emap_iterator_set(cl, layer_idx, ext, tx,
-				       EXT_VALIDATE, &it);
-		M0_ASSERT(rc == 0 || rc == -EINVAL); //todo Handle
-
-		if (rc == 0) {
-			rc = ext_in_db_write(&it, layer, ext, M0_CLRES_INVALID,
-					     IN_MEM_LIST_UPDATE);
-			if (rc != 0)
-				m0_layout__log("m0_composite_layer_ext_delete",
-					       "failed to write extent",
-					       M0_LAYOUT_ADDB_LOC_COMP_EXT_UPDATE_3, //todo
-					       &cl->cl_base.l_addb_ctx,
-					       cl->cl_base.l_id, rc);
-			m0_emap_close(&it);
-		}
-	}
-
-	m0_mutex_unlock(&cl->cl_base.l_lock);
-	M0_POST(layer_invariant(layer));
-	M0_POST(composite_invariant(cl));
-	M0_LEAVE("lid %llu, layer %lu, e_start %llu, e_end %llu, rc %d",
-		 (unsigned long long)cl->cl_base.l_id,
-		 (unsigned long)layer_idx, (unsigned long long)ext->e_start,
-		 (unsigned long long)ext->e_end, rc);
-#ifndef __KERNEL__
-	printf("m0_composite_layer_ext_delete(2): lid %llu, layer %lu, "
-		"e_start %llu, e_end %llu, ext %p\n",
-		 (unsigned long long)cl->cl_base.l_id,
-		 (unsigned long)layer_idx, (unsigned long long)ext->e_start,
-		 (unsigned long long)ext->e_end, ext);
-#endif
-	return rc;
+	return &cl->cl_base;
 }
 
 static const struct m0_layout_instance_ops composite_instance_ops;
diff --git a/layout/composite.h b/layout/composite.h
index 155d9d9..e555a1c 100644
--- a/layout/composite.h
+++ b/layout/composite.h
@@ -286,9 +286,11 @@ M0_INTERNAL int m0_composite_layer_delete(struct m0_composite_layout *cl,
 //todo Support m0_composite_layer_ext_find() to lookup only in-memory.
 
 /**
- * Looks up for the layer that owns the extent containing the supplied
- * offset. Also, returns 'the state of the extent' and 'the sublayout owned by
- * the specific layer'.
+ * Looks up for a valid extent with the given offset, starting with the
+ * top-most layer.
+ * If such an extent is found, along with the extent, returns 'the layer
+ * index','the state of the extent' and 'the sublayout owned by the specific
+ * layer'.
  *
  * @param offset 'In' paramemer to specify the offset to be looked up.
  * @param layer_idx 'Out' parameter to report back the layer the extent belongs
@@ -308,8 +310,8 @@ M0_INTERNAL int m0_composite_layer_delete(struct m0_composite_layout *cl,
 M0_INTERNAL int m0_composite_layer_ext_lookup(struct m0_composite_layout *cl,
 					      m0_bindex_t offset,
 					      struct m0_db_tx *tx,
-					      uint32_t *layer_idx,
 					      struct m0_ext *ext,
+					      uint32_t *layer_idx,
 					      uint64_t *ext_state,
 					      struct m0_layout **sublayout);
 
@@ -367,8 +369,8 @@ extern struct m0_layout_type m0_composite_layout_type;
 /**
  * @todo
  * 1) The network request for 'data that fits within the limits and otherwise'
- *    will be taken care of during the subsequent task of  changes to getattr
- *    to support the composite layout type.
+ *    will be taken care of during the subsequent task that is 'adding
+ *    composite layout type support to getattr'.
  * 2) Addition of m0_layout_size() API and cleanup around recsize related
  *    APIs which seem unncessary to be exposed.
  * 3)
diff --git a/layout/ut/composite.c b/layout/ut/composite.c
index 7ce55be..9d0e87c 100644
--- a/layout/ut/composite.c
+++ b/layout/ut/composite.c
@@ -1639,8 +1639,8 @@ static int ext_operate(enum extent_operation eop,
 	extlist_dump(cl, cl->cl_layers_nr - 1); //todo
 	/* Initial lookup verifying that the result is as expected. */
 	rc = m0_composite_layer_ext_lookup(cl, offset_to_operate,
-					   txptr, &layer_id_lookup,
-					   &ext_lookup,
+					   txptr, &ext_lookup,
+					   &layer_id_lookup,
 					   &ext_state_lookup,
 					   &sublayout_lookup);
 	if (kind_of_extent_to_operate == NON_EXISTING ||
@@ -1676,8 +1676,8 @@ static int ext_operate(enum extent_operation eop,
 		extlist_dump(cl, cl->cl_layers_nr - 1); //todo
 
 		rc = m0_composite_layer_ext_lookup(cl, offset_to_operate,
-						   txptr, &layer_id_lookup,
-						   &ext_lookup,
+						   txptr, &ext_lookup,
+						   &layer_id_lookup,
 						   &ext_state_lookup,
 						   &sublayout_lookup);
 		M0_UT_ASSERT(rc == 0);
@@ -1702,8 +1702,8 @@ static int ext_operate(enum extent_operation eop,
 
 		rc = m0_composite_layer_ext_lookup(cl,
 						   offset_to_operate,
-						   txptr, &layer_id_lookup,
-						   &ext_lookup,
+						   txptr, &ext_lookup,
+						   &layer_id_lookup,
 						   &ext_state_lookup,
 						   &sublayout_lookup);
 		if (kind_of_extent_to_operate == EXACT_EXISTING) {
@@ -1739,10 +1739,9 @@ static int ext_operate(enum extent_operation eop,
 			M0_UT_ASSERT(rc == -EINVAL);
 		extlist_dump(cl, cl->cl_layers_nr - 1); //todo
 
-		rc = m0_composite_layer_ext_lookup(cl,
-						   offset_to_operate,
-						   txptr, &layer_id_lookup,
-						   &ext_lookup,
+		rc = m0_composite_layer_ext_lookup(cl, offset_to_operate,
+						   txptr, &ext_lookup,
+						   &layer_id_lookup,
 						   &ext_state_lookup,
 						   &sublayout_lookup);
 
diff --git a/layout/ut/layout.c b/layout/ut/layout.c
index d1ff38c..3926f2f 100644
--- a/layout/ut/layout.c
+++ b/layout/ut/layout.c
@@ -1979,7 +1979,7 @@ static void test_add_failure(void)
 	 * gets deleted.
 	 */
 
-	m0_fi_enable_off_n_on_m("sublayout_id_in_db_add", "table_insert_err",
+	m0_fi_enable_off_n_on_m("sublayout_id_indb_add", "table_insert_err",
 				1, 1);
 	lid = 19022;
 	rc = test_add_composite(lid, &domain, 4, 15,
@@ -1990,7 +1990,7 @@ static void test_add_failure(void)
 				!FAILURE_TEST,
 				LAYER_ADD_FAILURE_TEST);
 	M0_UT_ASSERT(rc == L_TABLE_INSERT_ERR);
-	m0_fi_disable("sublayout_id_in_db_add", "table_insert_err");
+	m0_fi_disable("sublayout_id_indb_add", "table_insert_err");
 
 	domain_ldb_available_set(&domain, false);
 }
-- 
1.8.3.2

