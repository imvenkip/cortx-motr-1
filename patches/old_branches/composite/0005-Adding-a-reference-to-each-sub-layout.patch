From 1c8b7fc5ca8eeec7a57d39571936f8b340b11ffb Mon Sep 17 00:00:00 2001
From: "trupti.patil" <trupti_patil@xyratex.com>
Date: Thu, 18 Oct 2012 13:08:48 +0530
Subject: [PATCH 005/172] Adding a reference to each sub-layout

- Adding a reference to each sub-layout while creating a composite layout.
---
 layout/composite.c | 119 +++++++++++++++++++++-------------
 layout/ut/layout.c | 184 ++++++++++++++++++++++++++---------------------------
 2 files changed, 166 insertions(+), 137 deletions(-)

diff --git a/layout/composite.c b/layout/composite.c
index e944b73..1b7145f 100644
--- a/layout/composite.c
+++ b/layout/composite.c
@@ -157,35 +157,24 @@ static void composite_delete(struct c2_layout *l)
 	C2_LEAVE();
 }
 
-static int composite_populate(struct c2_composite_layout *cl,
-			      struct c2_tl *sub_layouts,
-			      uint32_t user_count)
+static void composite_populate(struct c2_composite_layout *cl,
+			       struct c2_tl *sub_layouts, uint32_t sublayouts_nr,
+			       uint32_t user_count)
 {
-	struct c2_composite_sub_layout *sl;
-	uint32_t                        nr = 0;
-
 	C2_PRE(composite_allocated_invariant(cl));
-	C2_PRE(sub_layouts != NULL);
+	/*
+	 * The sub-layout list has been validated by the caller and a reference
+	 * has been added on each sub-layout.
+	 */
 
 	C2_ENTRY("lid %llu", (unsigned long long)cl->cl_base.l_id);
-
 	c2_layout__populate(&cl->cl_base, user_count);
-
-	/* todo Validate the sub layout list received as input and ... */
-	/* Add a reference to each of the sub-layouts. */
-	c2_tl_for(c2_sub_layout, sub_layouts, sl) {
-		C2_ASSERT(c2_layout__invariant(sl->csl_l));
-		c2_layout_get(sl->csl_l); //todo check
-		//todo c2_layout_user_count_inc(sl->csl_l);
-		++nr;
-	} c2_tl_endfor;
 	cl->cl_sub_layouts = sub_layouts;
-	cl->cl_nr = nr;
+	cl->cl_nr = sublayouts_nr;
 
 	C2_POST(composite_invariant(cl));
 	C2_POST(c2_mutex_is_locked(&cl->cl_base.l_lock));
 	C2_LEAVE("lid %llu", (unsigned long long)cl->cl_base.l_id);
-	return 0;
 }
 
 /*
@@ -199,27 +188,49 @@ int c2_composite_build(struct c2_layout_domain *dom,
 		       struct c2_tl *sub_layouts,
 		       struct c2_composite_layout **out)
 {
-	struct c2_layout           *l;
-	struct c2_composite_layout *cl;
-	int                         rc;
+	struct c2_layout               *l;
+	struct c2_composite_layout     *cl;
+	struct c2_composite_sub_layout *sl;
+	uint32_t                        sublayouts_nr = 0;
+	int                             rc;
 
 	C2_PRE(out != NULL);
 	C2_PRE(!c2_sub_layout_tlist_is_empty(sub_layouts));
 
 	C2_ENTRY("domain %p, lid %llu", dom,(unsigned long long)lid);
+
+	/*
+	 * Validate the sub-layouts list ensuring that each sub-layout is
+	 * cached and add a reference to each sub-layout. The reference added
+	 * here by c2_layout_find() will be released by composite_fini().
+	 */
+	c2_tl_for(c2_sub_layout, sub_layouts, sl) {
+		C2_ASSERT(c2_layout__invariant(sl->csl_l));
+		l = c2_layout_find(dom, sl->csl_l->l_id);
+		if (l == NULL) {
+			c2_layout__log("c2_composite_build",
+				       "sub-layout not found in cache",
+				       &c2_addb_oom, &sl->csl_l->l_addb,
+				       sl->csl_l->l_id, -EPROTO);
+			/* todo Undo ref added to some sub-layouts. */
+			return -EPROTO;
+		}
+		C2_ASSERT(l == sl->csl_l);
+		++sublayouts_nr;
+	} c2_tl_endfor;
+
+	l = NULL;
 	rc = composite_allocate(dom, lid, &l);
 	if (rc == 0) {
 		/* Here composite_allocate() has locked l->l_lock. */
 		cl = bob_of(l, struct c2_composite_layout, cl_base,
 			    &composite_bob);
 		C2_ASSERT(composite_allocated_invariant(cl));
-
-		rc = composite_populate(cl, sub_layouts, 1);
-		if (rc == 0) {
-			*out = cl;
-			c2_mutex_unlock(&l->l_lock);
-		} else
-			composite_delete(l);
+		composite_populate(cl, sub_layouts, sublayouts_nr, 1);
+		*out = cl;
+		c2_mutex_unlock(&l->l_lock);
+	} else {
+		/* todo Undo ref added to sub-layouts, etc. */
 	}
 
 	C2_POST(ergo(rc == 0, composite_invariant(*out) &&
@@ -245,7 +256,10 @@ static void composite_fini(struct c2_layout *l)
 
 	c2_tl_for(c2_sub_layout, cl->cl_sub_layouts, sl) {
 		//todo c2_layout_user_count_inc(sl->csl_l);
-		/* Release the reference acquired by composite_populate(). */
+		/*
+		 * Release the reference acquired either by c2_composite_build()
+		 * or by c2_layout_decode().
+		 */
 		c2_layout_put(sl->csl_l);
 		c2_sub_layout_tlist_del(sl);
 		c2_sub_layout_tlink_fini(sl);
@@ -360,7 +374,13 @@ static int composite_decode(struct c2_layout *l,
 						sizeof *sl_entry);
 
 	C2_ALLOC_PTR(sub_layouts);
-	/* todo Handle error */
+	if (sub_layouts == NULL) {
+		c2_layout__log("composite_decode", "C2_ALLOC_PTR() failed",
+			       &c2_addb_oom, &l->l_addb,
+			       l->l_id, -ENOMEM);
+		return -ENOMEM;
+	}
+
 	c2_sub_layout_tlist_init(sub_layouts);
 	for (i = 0; i < sl_header->slh_nr; ++i) {
 		sl_entry = c2_bufvec_cursor_addr(cur);
@@ -370,17 +390,26 @@ static int composite_decode(struct c2_layout *l,
 		if (sl == NULL) {
 			c2_layout__log("composite_decode",
 				       "C2_ALLOC_PTR() failed",
-				       &c2_addb_oom, &layout_global_ctx,
+				       &c2_addb_oom, &l->l_addb,
 				       l->l_id, -ENOMEM);
 			return -ENOMEM;
 		}
 
-		/* todo c2_layout_find ?? */
+		/*
+		 * The reference acquired here by c2_layout_find() on each
+		 * sub-layout will be released by composite_fini().
+		 */
 		sl->csl_l = c2_layout_find(cl->cl_base.l_dom,
 					   sl_entry->sle_lid);
-		C2_ASSERT(sl->csl_l != NULL);
-		C2_CNT_DEC(sl->csl_l->l_ref);
-		//todo Check the above and handle error.
+		if (sl->csl_l == NULL) {
+			C2_LOG(C2_ERROR, "sub-layout-lid %llu, sub-layout not "
+			       "found in the cache, rc %d",
+			       (unsigned long long)sl_entry->sle_lid, -EPROTO);
+			/* todo Undo in case ref is taken on some sub-layouts
+			 * and undo C2_ALLOC_PTR(sl) and
+			 * c2_sub_layout_tlink_init_at(). */
+			return -EPROTO;
+		}
 
 		sl->csl_ext.e_start = sl_entry->sle_ext.e_start;
 		sl->csl_ext.e_end = sl_entry->sle_ext.e_end;
@@ -388,10 +417,7 @@ static int composite_decode(struct c2_layout *l,
 	}
 	C2_ASSERT(i == sl_header->slh_nr);
 
-	rc = composite_populate(cl, sub_layouts, ref_count);
-	if (rc != 0) {
-		/* todo Handle error. */
-	}
+	composite_populate(cl, sub_layouts, sl_header->slh_nr, ref_count);
 #if 0
 	if (op == C2_LXO_DB_LOOKUP) {
 		Read all the segments from the comp_layout_ext_map table,
@@ -403,8 +429,11 @@ static int composite_decode(struct c2_layout *l,
 		cur and store it in cl->cl_sub_layouts.
 	}
 #endif
-	rc = 0;
-	return rc; //todo C2_POST etc
+	rc = 0; //todo
+	C2_POST(ergo(rc == 0, composite_invariant(cl)));
+	C2_POST(ergo(rc != 0, composite_allocated_invariant(cl)));
+	C2_LEAVE("lid %llu, rc %d", (unsigned long long)l->l_id, rc);
+	return rc;
 }
 
 /** Implementation of lo_encode() for composite layout type. */
@@ -417,7 +446,7 @@ static int composite_encode(struct c2_layout *l,
 	struct c2_composite_sub_layout *sl;
 	struct sub_layouts_header       sl_header;
 	struct sub_layout_entry         sl_entry;
-	uint32_t                        num_sublayouts = 0;
+	uint32_t                        sublayouts_nr = 0;
 	c2_bcount_t                     nbytes;
 
 	C2_PRE(l != NULL);
@@ -442,9 +471,9 @@ static int composite_encode(struct c2_layout *l,
 			nbytes = c2_bufvec_cursor_copyto(out, &sl_entry,
 							 sizeof sl_entry);
 			C2_ASSERT(nbytes == sizeof sl_entry);
-			++num_sublayouts;
+			++sublayouts_nr;
 		} c2_tl_endfor;
-		C2_ASSERT(num_sublayouts == cl->cl_nr);
+		C2_ASSERT(sublayouts_nr == cl->cl_nr);
 	}
 
 	/*
diff --git a/layout/ut/layout.c b/layout/ut/layout.c
index 3177280..9551417 100644
--- a/layout/ut/layout.c
+++ b/layout/ut/layout.c
@@ -1047,7 +1047,7 @@ static void test_build_failure(void)
 	 * Simulate memory allocation failure in pdclust_allocate() that is
 	 * in the path of c2_pdclust_build().
 	 */
-	lid = 1005;
+	lid = 2001;
 	c2_fi_enable_once("pdclust_allocate", "mem_err");
 	rc = test_build_pdclust(LIST_ENUM_ID, lid, MORE_THAN_INLINE,
 				FAILURE_TEST);
@@ -1057,7 +1057,7 @@ static void test_build_failure(void)
 	 * Simulate memory allocation failure in pdclust_allocate() that is
 	 * in the path of c2_pdclust_build().
 	 */
-	lid = 1006;
+	lid = 2002;
 	c2_fi_enable_once("pdclust_allocate", "mem_err");
 	rc = test_build_pdclust(LINEAR_ENUM_ID, lid, INLINE_NOT_APPLICABLE,
 				FAILURE_TEST);
@@ -1067,7 +1067,7 @@ static void test_build_failure(void)
 	 * Simulate invalid attributes error in pdclust_populate() that is
 	 * in the path of c2_pdclust_build().
 	 */
-	lid = 1007;
+	lid = 2003;
 	c2_fi_enable_once("pdclust_l_build", "attr_err");
 	rc = test_build_pdclust(LIST_ENUM_ID, lid, MORE_THAN_INLINE,
 				FAILURE_TEST);
@@ -1077,7 +1077,7 @@ static void test_build_failure(void)
 	 * Simulate memory allocation failure in linear_allocate() that is
 	 * in the path of c2_pdclust_build().
 	 */
-	lid = 1008;
+	lid = 2004;
 	c2_fi_enable_once("list_allocate", "mem_err");
 	rc = test_build_pdclust(LIST_ENUM_ID, lid, MORE_THAN_INLINE,
 				FAILURE_TEST);
@@ -1087,28 +1087,28 @@ static void test_build_failure(void)
 	 * Simulate memory allocation failure in linear_allocate() that is
 	 * in the path of c2_pdclust_build().
 	 */
-	lid = 1009;
+	lid = 2005;
 	c2_fi_enable_once("linear_allocate", "mem_err");
 	rc = test_build_pdclust(LINEAR_ENUM_ID, lid, INLINE_NOT_APPLICABLE,
 				FAILURE_TEST);
 	C2_UT_ASSERT(rc == -ENOMEM);
 
 	/* Simulate attributes invalid error in c2_list_enum_build(). */
-	lid = 1010;
+	lid = 2006;
 	c2_fi_enable_once("pdclust_layout_build", "list_attr_err");
 	rc = test_build_pdclust(LIST_ENUM_ID, lid, MORE_THAN_INLINE,
 				FAILURE_TEST);
 	C2_UT_ASSERT(rc == -EPROTO);
 
 	/* Simulate attributes invalid error in c2_linear_enum_build(). */
-	lid = 1011;
+	lid = 2007;
 	c2_fi_enable_once("pdclust_layout_build", "lin_attr_err");
 	rc = test_build_pdclust(LINEAR_ENUM_ID, lid, INLINE_NOT_APPLICABLE,
 				FAILURE_TEST);
 	C2_UT_ASSERT(rc == -EPROTO);
 
 	/* Simulate fid invalid error in c2_list_enum_build(). */
-	lid = 1012;
+	lid = 2008;
 	c2_fi_enable_once("c2_list_enum_build", "fid_invalid_err");
 	rc = test_build_pdclust(LIST_ENUM_ID, lid, MORE_THAN_INLINE,
 				FAILURE_TEST);
@@ -1434,7 +1434,7 @@ static void test_decode(void)
 	 * Decode a layout object with PDCLUST layout type, LIST enum type
 	 * with a few inline entries only.
 	 */
-	lid = 2001;
+	lid = 3001;
 	rc = test_decode_pdclust(LIST_ENUM_ID, lid, LESS_THAN_INLINE,
 				 !FAILURE_TEST);
 	C2_UT_ASSERT(rc == 0);
@@ -1444,7 +1444,7 @@ static void test_decode(void)
 	 * with a number of inline entries exactly equal to
 	 * LDB_MAX_INLINE_COB_ENTRIES and then destroy it.
 	 */
-	lid = 2002;
+	lid = 3002;
 	rc = test_decode_pdclust(LIST_ENUM_ID, lid, EXACT_INLINE,
 				 !FAILURE_TEST);
 	C2_UT_ASSERT(rc == 0);
@@ -1453,7 +1453,7 @@ static void test_decode(void)
 	 * Decode a layout object with PDCLUST layout type, LIST enum type
 	 * including noninline entries and then destroy it.
 	 */
-	lid = 2003;
+	lid = 3003;
 	rc = test_decode_pdclust(LIST_ENUM_ID, lid, MORE_THAN_INLINE,
 				 !FAILURE_TEST);
 	C2_UT_ASSERT(rc == 0);
@@ -1462,13 +1462,13 @@ static void test_decode(void)
 	 * Decode a layout object with PDCLUST layout type and LINEAR enum
 	 * type.
 	 */
-	lid = 2004;
+	lid = 3004;
 	rc = test_decode_pdclust(LINEAR_ENUM_ID, lid, INLINE_NOT_APPLICABLE,
 				 !FAILURE_TEST);
 	C2_UT_ASSERT(rc == 0);
 
 	/* Decode a layout object with COMPOSITE layout type. */
-	lid = 2005; //todo
+	lid = 3005;
 	rc = test_decode_composite(lid, !FAILURE_TEST);
 	C2_UT_ASSERT(rc == 0);
 }
@@ -1478,63 +1478,63 @@ static void test_decode_failure(void)
 	uint64_t lid;
 
 	/* Simulate invalid attributes error in c2_layout_decode(). */
-	lid = 2005;
+	lid = 4001;
 	c2_fi_enable_once("c2_layout_decode", "attr_err");
 	rc = test_decode_pdclust(LIST_ENUM_ID, lid, MORE_THAN_INLINE,
 				 FAILURE_TEST);
 	C2_UT_ASSERT(rc == -EPROTO);
 
 	/* Simulate invalid attributes error in pdclust_decode(). */
-	lid = 2006;
+	lid = 4002;
 	c2_fi_enable_once("pdclust_decode", "attr_err1");
 	rc = test_decode_pdclust(LIST_ENUM_ID, lid, MORE_THAN_INLINE,
 				 FAILURE_TEST);
 	C2_UT_ASSERT(rc == -EPROTO);
 
 	/* Simulate invalid attributes error in pdclust_decode(). */
-	lid = 2007;
+	lid = 4003;
 	c2_fi_enable_once("pdclust_decode", "attr_err2");
 	rc = test_decode_pdclust(LIST_ENUM_ID, lid, MORE_THAN_INLINE,
 				 FAILURE_TEST);
 	C2_UT_ASSERT(rc == -EPROTO);
 
 	/* Simulate invalid attributes error in list_populate(). */
-	lid = 2008;
+	lid = 4004;
 	c2_fi_enable_once("list_decode", "attr_err");
 	rc = test_decode_pdclust(LIST_ENUM_ID, lid, MORE_THAN_INLINE,
 				 FAILURE_TEST);
 	C2_UT_ASSERT(rc == -EPROTO);
 
 	/* Simulate invalid attributes error in linear_populate(). */
-	lid = 2009;
+	lid = 4005;
 	c2_fi_enable_once("linear_decode", "attr_err");
 	rc = test_decode_pdclust(LINEAR_ENUM_ID, lid, INLINE_NOT_APPLICABLE,
 				 FAILURE_TEST);
 	C2_UT_ASSERT(rc == -EPROTO);
 
 	/* Simulate memory allocation failure in list_decode(). */
-	lid = 2010;
+	lid = 4006;
 	c2_fi_enable_once("list_decode", "mem_err");
 	rc = test_decode_pdclust(LIST_ENUM_ID, lid, MORE_THAN_INLINE,
 				 FAILURE_TEST);
 	C2_UT_ASSERT(rc == -ENOMEM);
 
 	/* Simulate fid invalid error in list_decode(). */
-	lid = 2011;
+	lid = 4007;
 	c2_fi_enable_once("list_decode", "fid_invalid_err");
 	rc = test_decode_pdclust(LIST_ENUM_ID, lid, MORE_THAN_INLINE,
 				 FAILURE_TEST);
 	C2_UT_ASSERT(rc == -EPROTO);
 
 	/* Simulate leto_allocate() failure in pdclust_decode(). */
-	lid = 2012;
+	lid = 4008;
 	c2_fi_enable_once("linear_allocate", "mem_err");
 	rc = test_decode_pdclust(LINEAR_ENUM_ID, lid, INLINE_NOT_APPLICABLE,
 				 FAILURE_TEST);
 	C2_UT_ASSERT(rc == -ENOMEM);
 
 	/* Simulate pdclust_populate() failure in pdclust_decode(). */
-	lid = 2013;
+	lid = 4009;
 	c2_fi_enable_once("pdclust_decode", "attr_err3");
 	rc = test_decode_pdclust(LINEAR_ENUM_ID, lid, INLINE_NOT_APPLICABLE,
 				 FAILURE_TEST);
@@ -1801,7 +1801,7 @@ static void test_encode(void)
 	 * Encode for PDCLUST layout type and LIST enumeration type,
 	 * with a few inline entries only.
 	 */
-	lid = 3001;
+	lid = 5001;
 	rc = test_encode_pdclust(LIST_ENUM_ID, lid, LESS_THAN_INLINE,
 				 !FAILURE_TEST);
 	C2_UT_ASSERT(rc == 0);
@@ -1811,7 +1811,7 @@ static void test_encode(void)
 	 * with a number of inline entries exactly equal to
 	 * LDB_MAX_INLINE_COB_ENTRIES.
 	 */
-	lid = 3002;
+	lid = 5002;
 	rc = test_encode_pdclust(LIST_ENUM_ID, lid, EXACT_INLINE,
 				 !FAILURE_TEST);
 	C2_UT_ASSERT(rc == 0);
@@ -1820,19 +1820,19 @@ static void test_encode(void)
 	 * Encode for PDCLUST layout type and LIST enumeration type,
 	 * including noninline entries and then destroy it.
 	 */
-	lid = 3003;
+	lid = 5003;
 	rc = test_encode_pdclust(LIST_ENUM_ID, lid, MORE_THAN_INLINE,
 				 !FAILURE_TEST);
 	C2_UT_ASSERT(rc == 0);
 
 	/* Encode for PDCLUST layout type and LINEAR enumeration type. */
-	lid = 3004;
+	lid = 5004;
 	rc = test_encode_pdclust(LINEAR_ENUM_ID, lid, INLINE_NOT_APPLICABLE,
 				 !FAILURE_TEST);
 	C2_UT_ASSERT(rc == 0);
 
 	/* Encode for COMPOSITE layout type. */
-	lid = 3005; //todo
+	lid = 5005;
 	rc = test_encode_composite(lid, !FAILURE_TEST);
 	C2_UT_ASSERT(rc == 0);
 }
@@ -1843,14 +1843,14 @@ static void test_encode_failure(void)
 	int      rc;
 
 	/* Simulate c2_layout_encode() failure. */
-	lid = 3005;
+	lid = 6001;
 	c2_fi_enable_once("c2_layout_encode", "lo_encode_err");
 	rc = test_encode_pdclust(LIST_ENUM_ID, lid, MORE_THAN_INLINE,
 				 FAILURE_TEST);
 	C2_UT_ASSERT(rc == LO_ENCODE_ERR);
 
 	/* Simulate c2_layout_encode() failure. */
-	lid = 3006;
+	lid = 6002;
 	c2_fi_enable_once("c2_layout_encode", "lo_encode_err");
 	rc = test_encode_pdclust(LINEAR_ENUM_ID, lid, INLINE_NOT_APPLICABLE,
 				 FAILURE_TEST);
@@ -2076,7 +2076,7 @@ static void test_decode_encode(void)
 	 * Then, compare the original layout buffer with the encoded layout
 	 * buffer.
 	 */
-	lid = 4001;
+	lid = 7001;
 	rc = test_decode_encode_pdclust(LIST_ENUM_ID, lid, LESS_THAN_INLINE);
 	C2_UT_ASSERT(rc == 0);
 
@@ -2089,7 +2089,7 @@ static void test_decode_encode(void)
 	 * Then, compare the original layout buffer with the encoded layout
 	 * buffer.
 	 */
-	lid = 4002;
+	lid = 7002;
 	rc = test_decode_encode_pdclust(LIST_ENUM_ID, lid, EXACT_INLINE);
 	C2_UT_ASSERT(rc == 0);
 
@@ -2101,7 +2101,7 @@ static void test_decode_encode(void)
 	 * Then, compare the original layout buffer with the encoded layout
 	 * buffer.
 	 */
-	lid = 4003;
+	lid = 7003;
 	rc = test_decode_encode_pdclust(LIST_ENUM_ID, lid, MORE_THAN_INLINE);
 	C2_UT_ASSERT(rc == 0);
 
@@ -2113,7 +2113,7 @@ static void test_decode_encode(void)
 	 * Then, compare the original layout buffer with the encoded layout
 	 * buffer.
 	 */
-	lid = 4004;
+	lid = 7004;
 	rc = test_decode_encode_pdclust(LINEAR_ENUM_ID, lid,
 					INLINE_NOT_APPLICABLE);
 	C2_UT_ASSERT(rc == 0);
@@ -2393,7 +2393,7 @@ static void test_encode_decode(void)
 	 * Then, compare the original layout object with the decoded layout
 	 * object.
 	 */
-	lid = 5001;
+	lid = 8001;
 	rc = test_encode_decode_pdclust(LIST_ENUM_ID, lid, LESS_THAN_INLINE);
 	C2_UT_ASSERT(rc == 0);
 
@@ -2406,7 +2406,7 @@ static void test_encode_decode(void)
 	 * Then, compare the original layout object with the decoded layout
 	 * object.
 	 */
-	lid = 5002;
+	lid = 8002;
 	rc = test_encode_decode_pdclust(LIST_ENUM_ID, lid, EXACT_INLINE);
 	C2_UT_ASSERT(rc == 0);
 
@@ -2418,7 +2418,7 @@ static void test_encode_decode(void)
 	 * Then, compare the original layout object with the decoded layout
 	 * object.
 	 */
-	lid = 5003;
+	lid = 8003;
 	rc = test_encode_decode_pdclust(LIST_ENUM_ID, lid, MORE_THAN_INLINE);
 	C2_UT_ASSERT(rc == 0);
 
@@ -2429,7 +2429,7 @@ static void test_encode_decode(void)
 	 * Now, compare the original layout object with the decoded layout
 	 * object.
 	 */
-	lid = 5004;
+	lid = 8004;
 	rc = test_encode_decode_pdclust(LINEAR_ENUM_ID, lid,
 					INLINE_NOT_APPLICABLE);
 	C2_UT_ASSERT(rc == 0);
@@ -2499,7 +2499,7 @@ static void test_ref_get_put(void)
 	 * Reference get and put operations for PDCLUST layout type and LIST
 	 * enumeration type.
 	 */
-	lid = 6001;
+	lid = 9001;
 	rc = test_ref_get_put_pdclust(LIST_ENUM_ID, lid);
 	C2_UT_ASSERT(rc == 0);
 
@@ -2507,7 +2507,7 @@ static void test_ref_get_put(void)
 	 * Reference get and put operations for PDCLUST layout type and LINEAR
 	 * enumeration type.
 	 */
-	lid = 6002;
+	lid = 9002;
 	rc = test_ref_get_put_pdclust(LINEAR_ENUM_ID, lid);
 	C2_UT_ASSERT(rc == 0);
 }
@@ -2608,7 +2608,7 @@ static void test_enum_operations(void)
 	 * with a few inline entries only.
 	 * And then verify its enum ops.
 	 */
-	lid = 7001;
+	lid = 10001;
 	rc = test_enum_ops_pdclust(LIST_ENUM_ID, lid, LESS_THAN_INLINE);
 	C2_UT_ASSERT(rc == 0);
 
@@ -2618,7 +2618,7 @@ static void test_enum_operations(void)
 	 * LDB_MAX_INLINE_COB_ENTRIES.
 	 * And then verify its enum ops.
 	 */
-	lid = 7002;
+	lid = 10002;
 	rc = test_enum_ops_pdclust(LIST_ENUM_ID, lid, EXACT_INLINE);
 	C2_UT_ASSERT(rc == 0);
 
@@ -2627,7 +2627,7 @@ static void test_enum_operations(void)
 	 * including noninline entries.
 	 * And then verify its enum ops.
 	 */
-	lid = 7003;
+	lid = 10003;
 	rc = test_enum_ops_pdclust(LIST_ENUM_ID, lid, MORE_THAN_INLINE);
 	C2_UT_ASSERT(rc == 0);
 
@@ -2635,7 +2635,7 @@ static void test_enum_operations(void)
 	 * Decode a layout with PDCLUST layout type and LINEAR enum type.
 	 * And then verify its enum ops.
 	 */
-	lid = 7004;
+	lid = 10004;
 	rc = test_enum_ops_pdclust(LINEAR_ENUM_ID, lid, INLINE_NOT_APPLICABLE);
 	C2_UT_ASSERT(rc == 0);
 }
@@ -2849,7 +2849,7 @@ static void test_recsize(void)
 	 * lo_recsize() for PDCLUST layout type and LIST enumeration type,
 	 * with a few inline entries only.
 	 */
-	lid = 8001;
+	lid = 11001;
 	rc = test_recsize_pdclust(LIST_ENUM_ID, lid, LESS_THAN_INLINE);
 	C2_UT_ASSERT(rc == 0);
 
@@ -2858,7 +2858,7 @@ static void test_recsize(void)
 	 * with a number of inline entries exactly equal to
 	 * LDB_MAX_INLINE_COB_ENTRIES
 	 */
-	lid = 8002;
+	lid = 11002;
 	rc = test_recsize_pdclust(LIST_ENUM_ID, lid, EXACT_INLINE);
 	C2_UT_ASSERT(rc == 0);
 
@@ -2866,12 +2866,12 @@ static void test_recsize(void)
 	 * lo_recsize() for PDCLUST layout type and LIST enumeration type
 	 * including noninline entries.
 	 */
-	lid = 8003;
+	lid = 11003;
 	rc = test_recsize_pdclust(LIST_ENUM_ID, lid, MORE_THAN_INLINE);
 	C2_UT_ASSERT(rc == 0);
 
 	/* lo_recsize() for PDCLUST layout type and LINEAR enumeration type. */
-	lid = 8004;
+	lid = 11004;
 	rc = test_recsize_pdclust(LINEAR_ENUM_ID, lid, INLINE_NOT_APPLICABLE);
 	C2_UT_ASSERT(rc == 0);
 }
@@ -2966,7 +2966,7 @@ static void test_pdclust_instance(void)
 	 * Build a layout object with PDCLUST layout type, LIST enum type
 	 * with a few inline entries only and then destroy it.
 	 */
-	lid = 9001;
+	lid = 12001;
 	rc = test_pdclust_instance_obj(LIST_ENUM_ID, lid, LESS_THAN_INLINE,
 				       !FAILURE_TEST);
 	C2_UT_ASSERT(rc == 0);
@@ -2976,7 +2976,7 @@ static void test_pdclust_instance(void)
 	 * with a number of inline entries exactly equal to
 	 * LDB_MAX_INLINE_COB_ENTRIES and then destroy it.
 	 */
-	lid = 9002;
+	lid = 12002;
 	rc = test_pdclust_instance_obj(LIST_ENUM_ID, lid, EXACT_INLINE,
 				       !FAILURE_TEST);
 	C2_UT_ASSERT(rc == 0);
@@ -2985,7 +2985,7 @@ static void test_pdclust_instance(void)
 	 * Build a layout object with PDCLUST layout type, LIST enum type
 	 * including noninline entries and then destroy it.
 	 */
-	lid = 9003;
+	lid = 12003;
 	rc = test_pdclust_instance_obj(LIST_ENUM_ID, lid, MORE_THAN_INLINE,
 				       !FAILURE_TEST);
 	C2_UT_ASSERT(rc == 0);
@@ -2994,7 +2994,7 @@ static void test_pdclust_instance(void)
 	 * Build a layout object with PDCLUST layout type and LINEAR enum
 	 * type and then destroy it.
 	 */
-	lid = 9004;
+	lid = 12004;
 	rc = test_pdclust_instance_obj(LINEAR_ENUM_ID, lid,
 				       INLINE_NOT_APPLICABLE,
 				       !FAILURE_TEST);
@@ -3006,14 +3006,14 @@ static void test_pdclust_instance_failure(void)
 	uint64_t lid;
 
 	/* Simulate memory allocation error in c2_pdclust_instance_build(). */
-	lid = 9005;
+	lid = 13001;
 	c2_fi_enable_once("pdclust_instance_build", "mem_err1");
 	rc = test_pdclust_instance_obj(LIST_ENUM_ID, lid, LESS_THAN_INLINE,
 				       FAILURE_TEST);
 	C2_UT_ASSERT(rc == -ENOMEM);
 
 	/* Simulate memory allocation error in c2_pdclust_instance_build(). */
-	lid = 9006;
+	lid = 13002;
 	c2_fi_enable_once("pdclust_instance_build", "mem_err2");
 	rc = test_pdclust_instance_obj(LINEAR_ENUM_ID, lid,
 				      INLINE_NOT_APPLICABLE,
@@ -3024,7 +3024,7 @@ static void test_pdclust_instance_failure(void)
 	 * Simulate c2_parity_math_init() error in
 	 * c2_pdclust_instance_build().
 	 */
-	lid = 9007;
+	lid = 13003;
 	c2_fi_enable_once("pdclust_instance_build", "parity_math_err");
 	rc = test_pdclust_instance_obj(LINEAR_ENUM_ID, lid,
 				      INLINE_NOT_APPLICABLE,
@@ -3284,7 +3284,7 @@ static void test_lookup(void)
 	 * Lookup for a layout object with LIST enum type, that does not
 	 * exist in the DB.
 	 */
-	lid = 10001;
+	lid = 14001;
 	rc = test_lookup_pdclust(LIST_ENUM_ID, lid,
 				 !EXISTING_TEST,
 				 MORE_THAN_INLINE,
@@ -3295,7 +3295,7 @@ static void test_lookup(void)
 	 * Add a layout object with PDCLUST layout type, LIST enum type and
 	 * with a few inline entries only. Then perform lookup for it.
 	 */
-	lid = 10002;
+	lid = 14002;
 	rc = test_lookup_pdclust(LIST_ENUM_ID, lid,
 				 EXISTING_TEST,
 				 LESS_THAN_INLINE,
@@ -3307,7 +3307,7 @@ static void test_lookup(void)
 	 * with a number of inline entries exactly equal to
 	 * LDB_MAX_INLINE_COB_ENTRIES. Then perform lookup for it.
 	 */
-	lid = 10003;
+	lid = 14003;
 	rc = test_lookup_pdclust(LIST_ENUM_ID, lid,
 				 EXISTING_TEST,
 				 EXACT_INLINE,
@@ -3319,7 +3319,7 @@ static void test_lookup(void)
 	 * including noninline entries.
 	 * Then perform lookup for it.
 	 */
-	lid = 10004;
+	lid = 14004;
 	rc = test_lookup_pdclust(LIST_ENUM_ID, lid,
 				 EXISTING_TEST,
 				 MORE_THAN_INLINE,
@@ -3330,7 +3330,7 @@ static void test_lookup(void)
 	 * Now that a few entries are added into the DB, once again, lookup
 	 * for a layout object that does not exist in the DB.
 	 */
-	lid = 10005;
+	lid = 14005;
 	rc = test_lookup_pdclust(LIST_ENUM_ID, lid,
 				 !EXISTING_TEST,
 				 MORE_THAN_INLINE,
@@ -3341,7 +3341,7 @@ static void test_lookup(void)
 	 * Add a layout object with PDCLUST layout type and LINEAR enum type.
 	 * Then perform lookup for it.
 	 */
-	lid = 10006;
+	lid = 14006;
 	rc = test_lookup_pdclust(LINEAR_ENUM_ID, lid,
 				 EXISTING_TEST,
 				 INLINE_NOT_APPLICABLE,
@@ -3353,7 +3353,7 @@ static void test_lookup(void)
 	 * created while the first layout object is being allocated by
 	 * c2_layout_lookup() with having the domain lock released.
 	 */
-	lid = 10007;
+	lid = 14007;
 	rc = test_lookup_with_ghost_creation(LINEAR_ENUM_ID, lid,
 					     INLINE_NOT_APPLICABLE);
 	C2_UT_ASSERT(rc == 0);
@@ -3373,7 +3373,7 @@ static void test_lookup_failure(void)
 	 * Lookup for a layout object with LIST enum type, that does not
 	 * exist in the DB.
 	 */
-	lid = 10008;
+	lid = 15001;
 	rc = test_lookup_pdclust(LIST_ENUM_ID, lid,
 				 !EXISTING_TEST,
 				 MORE_THAN_INLINE,
@@ -3384,7 +3384,7 @@ static void test_lookup_failure(void)
 	 * Lookup for a layout object with LINEAR enum type, that does not
 	 * exist in the DB.
 	 */
-	lid = 10009;
+	lid = 15002;
 	rc = test_lookup_pdclust(LINEAR_ENUM_ID, lid,
 				 !EXISTING_TEST,
 				 INLINE_NOT_APPLICABLE,
@@ -3392,7 +3392,7 @@ static void test_lookup_failure(void)
 	C2_UT_ASSERT(rc == -ENOENT);
 
 	/* Simulate pdclust_allocate() failure in c2_layout_lookup(). */
-	lid = 10010;
+	lid = 15003;
 	c2_fi_enable_off_n_on_m("pdclust_allocate", "mem_err", 1, 1);
 	rc = test_lookup_pdclust(LINEAR_ENUM_ID, lid,
 				 EXISTING_TEST,
@@ -3402,7 +3402,7 @@ static void test_lookup_failure(void)
 	c2_fi_disable("pdclust_allocate", "mem_err");
 
 	/* Simulate c2_layout_decode() failure in c2_layout_lookup(). */
-	lid = 10011;
+	lid = 15004;
 	c2_fi_enable_once("c2_layout_decode", "lo_decode_err");
 	rc = test_lookup_pdclust(LINEAR_ENUM_ID, lid,
 				 EXISTING_TEST,
@@ -3417,7 +3417,7 @@ static void test_lookup_failure(void)
 		.lt_domain   = NULL,
 		.lt_ops      = NULL
 	};
-	lid = 10012;
+	lid = 15005;
 	rc = c2_layout_lookup(&domain, lid, &test_layout_type, &tx, &pair, &l);
 	C2_UT_ASSERT(rc == -EPROTO);
 
@@ -3425,7 +3425,7 @@ static void test_lookup_failure(void)
 	 * Simulate cursor init error in noninline_read() that is in the path
 	 * of list_decode() that is in the path of c2_layout_decode().
 	 */
-	lid = 10013;
+	lid = 15006;
 	c2_fi_enable_once("noninline_read", "cursor_init_err");
 	rc = test_lookup_pdclust(LIST_ENUM_ID, lid,
 				 EXISTING_TEST,
@@ -3437,7 +3437,7 @@ static void test_lookup_failure(void)
 	 * Simulate cursor get error in noninline_read() that is in the path
 	 * of list_decode() that is in the path of c2_layout_decode().
 	 */
-	lid = 10014;
+	lid = 15007;
 	c2_fi_enable_once("noninline_read", "cursor_get_err");
 	rc = test_lookup_pdclust(LIST_ENUM_ID, lid,
 				 EXISTING_TEST,
@@ -3449,7 +3449,7 @@ static void test_lookup_failure(void)
 	 * Simulate invalid fid error in noninline_read() that is in the path
 	 * of list_decode() that is in the path of c2_layout_decode().
 	 */
-	lid = 10015;
+	lid = 15008;
 	c2_fi_enable_once("noninline_read", "invalid_fid_err");
 	rc = test_lookup_pdclust(LIST_ENUM_ID, lid,
 				 EXISTING_TEST,
@@ -3558,7 +3558,7 @@ static void test_add(void)
 	 * Add a layout object with PDCLUST layout type, LIST enum type and
 	 * with a few inline entries only.
 	 */
-	lid = 11001;
+	lid = 16001;
 	rc = test_add_pdclust(LIST_ENUM_ID, lid,
 			      LESS_THAN_INLINE,
 			      LAYOUT_DESTROY, NULL,
@@ -3571,7 +3571,7 @@ static void test_add(void)
 	 * with a number of inline entries exactly equal to
 	 * LDB_MAX_INLINE_COB_ENTRIES.
 	 */
-	lid = 11002;
+	lid = 16002;
 	rc = test_add_pdclust(LIST_ENUM_ID, lid,
 			      EXACT_INLINE,
 			      LAYOUT_DESTROY, NULL,
@@ -3583,7 +3583,7 @@ static void test_add(void)
 	 * Add a layout object with PDCLUST layout type and LIST enum type
 	 * including noninline entries.
 	 */
-	lid = 11003;
+	lid = 16003;
 	rc = test_add_pdclust(LIST_ENUM_ID, lid,
 			      MORE_THAN_INLINE,
 			      LAYOUT_DESTROY, NULL,
@@ -3592,7 +3592,7 @@ static void test_add(void)
 	C2_UT_ASSERT(rc == 0);
 
 	/* Add a layout object with PDCLUST layout type and LINEAR enum type. */
-	lid = 11004;
+	lid = 16004;
 	rc = test_add_pdclust(LINEAR_ENUM_ID, lid,
 			      INLINE_NOT_APPLICABLE,
 			      LAYOUT_DESTROY, NULL,
@@ -3606,7 +3606,7 @@ static void test_add_failure(void)
 	uint64_t lid;
 
 	/* Simulate c2_layout_encode() failure in c2_layout_add(). */
-	lid = 11005;
+	lid = 17001;
 	c2_fi_enable_once("c2_layout_encode", "lo_encode_err");
 	rc = test_add_pdclust(LIST_ENUM_ID, lid,
 			      MORE_THAN_INLINE,
@@ -3619,7 +3619,7 @@ static void test_add_failure(void)
 	 * Simulate the error that entry already exists in the layout DB with
 	 * the dame layout id.
 	 */
-	lid = 11006;
+	lid = 17002;
 	rc = test_add_pdclust(LINEAR_ENUM_ID, lid,
 			      INLINE_NOT_APPLICABLE,
 			      LAYOUT_DESTROY, NULL,
@@ -3631,7 +3631,7 @@ static void test_add_failure(void)
 	 * Simulate cursor init failure in noninline_write() that is in the
 	 * path of list_encode() which is in the path of c2_layout_encode().
 	 */
-	lid = 11007;
+	lid = 17003;
 	c2_fi_enable_once("noninline_write", "cursor_init_err");
 	rc = test_add_pdclust(LIST_ENUM_ID, lid,
 			      MORE_THAN_INLINE,
@@ -3644,7 +3644,7 @@ static void test_add_failure(void)
 	 * Simulate cursor add failure in noninline_write() that is in the
 	 * path of list_encode() which is in the path of c2_layout_encode().
 	 */
-	lid = 11008;
+	lid = 17004;
 	c2_fi_enable_once("noninline_write", "cursor_add_err");
 	rc = test_add_pdclust(LIST_ENUM_ID, lid,
 			      MORE_THAN_INLINE,
@@ -3797,7 +3797,7 @@ static void test_update(void)
 	 * type, that does not exist in the DB to verify that the operation
 	 * fails with the error ENOENT.
 	 */
-	lid = 12001;
+	lid = 18001;
 	rc = test_update_pdclust(LIST_ENUM_ID, lid,
 				 !EXISTING_TEST,
 				 MORE_THAN_INLINE,
@@ -3808,7 +3808,7 @@ static void test_update(void)
 	 * Update a layout object with PDCLUST layout type, LIST enum type and
 	 * with a few inline entries only.
 	 */
-	lid = 12002;
+	lid = 18002;
 	rc = test_update_pdclust(LIST_ENUM_ID, lid,
 				 EXISTING_TEST,
 				 LESS_THAN_INLINE,
@@ -3820,7 +3820,7 @@ static void test_update(void)
 	 * with number of inline entries exactly equal to
 	 * LDB_MAX_INLINE_COB_ENTRIES.
 	 */
-	lid = 12003;
+	lid = 18003;
 	rc = test_update_pdclust(LIST_ENUM_ID, lid,
 				 EXISTING_TEST,
 				 EXACT_INLINE,
@@ -3831,7 +3831,7 @@ static void test_update(void)
 	 * Update a layout object with PDCLUST layout type and LIST enum
 	 * type including noninline entries.
 	 */
-	lid = 12004;
+	lid = 18004;
 	rc = test_update_pdclust(LIST_ENUM_ID, lid,
 				 EXISTING_TEST,
 				 MORE_THAN_INLINE,
@@ -3842,7 +3842,7 @@ static void test_update(void)
 	 * Update a layout object with PDCLUST layout type and LINEAR enum
 	 * type.
 	 */
-	lid = 12005;
+	lid = 18005;
 	rc = test_update_pdclust(LINEAR_ENUM_ID, lid,
 				 EXISTING_TEST,
 				 INLINE_NOT_APPLICABLE,
@@ -3855,7 +3855,7 @@ static void test_update_failure(void)
 	uint64_t lid;
 
 	/* Simulate c2_layout_encode() failure in c2_layout_update(). */
-	lid = 12006;
+	lid = 19001;
 	c2_fi_enable_off_n_on_m("c2_layout_encode", "lo_encode_err", 1, 1);
 	rc = test_update_pdclust(LIST_ENUM_ID, lid,
 				 EXISTING_TEST,
@@ -3865,7 +3865,7 @@ static void test_update_failure(void)
 	c2_fi_disable("c2_layout_encode", "lo_encode_err");
 
 	/* Simulate c2_table_update() failure in c2_layout_update(). */
-	lid = 12007;
+	lid = 19002;
 	c2_fi_enable_once("c2_layout_update", "table_update_err");
 	rc = test_update_pdclust(LINEAR_ENUM_ID, lid,
 				 EXISTING_TEST,
@@ -3977,7 +3977,7 @@ static void test_delete(void)
 	 * Delete a layout object with PDCLUST layout type, LIST enum type and
 	 * with a few inline entries only.
 	 */
-	lid = 13001;
+	lid = 20001;
 	rc = test_delete_pdclust(LIST_ENUM_ID, lid,
 				 EXISTING_TEST,
 				 LESS_THAN_INLINE,
@@ -3989,7 +3989,7 @@ static void test_delete(void)
 	 * with a number of inline entries exactly equal to
 	 * LDB_MAX_INLINE_COB_ENTRIES.
 	 */
-	lid = 13002;
+	lid = 20002;
 	rc = test_delete_pdclust(LIST_ENUM_ID, lid,
 				 EXISTING_TEST,
 				 EXACT_INLINE,
@@ -4000,7 +4000,7 @@ static void test_delete(void)
 	 * Delete a layout object with PDCLUST layout type and LIST enum
 	 * type including noninline entries.
 	 */
-	lid = 13003;
+	lid = 20003;
 	rc = test_delete_pdclust(LIST_ENUM_ID, lid,
 				 EXISTING_TEST,
 				 MORE_THAN_INLINE,
@@ -4011,7 +4011,7 @@ static void test_delete(void)
 	 * Delete a layout object with PDCLUST layout type and LINEAR enum
 	 * type.
 	 */
-	lid = 13004;
+	lid = 20004;
 	rc = test_delete_pdclust(LINEAR_ENUM_ID, lid,
 				 EXISTING_TEST,
 				 INLINE_NOT_APPLICABLE,
@@ -4024,7 +4024,7 @@ static void test_delete_failure(void)
 	uint64_t lid;
 
 	/* Simulate c2_layout_encode() failure in c2_layout_delete(). */
-	lid = 13005;
+	lid = 21001;
 	c2_fi_enable_off_n_on_m("c2_layout_encode", "lo_encode_err", 1, 1);
 	rc = test_delete_pdclust(LINEAR_ENUM_ID, lid,
 				 EXISTING_TEST,
@@ -4038,7 +4038,7 @@ static void test_delete_failure(void)
 	 * enum type, that does not exist in the DB, to verify that it results
 	 * into the error ENOENT.
 	 */
-	lid = 13006;
+	lid = 21002;
 	rc = test_delete_pdclust(LINEAR_ENUM_ID, lid,
 				 !EXISTING_TEST,
 				 INLINE_NOT_APPLICABLE,
@@ -4049,7 +4049,7 @@ static void test_delete_failure(void)
 	 * Simulate cursor get failure in noninline_write() that is in the
 	 * path of list_encode() which is in the path of c2_layout_encode().
 	 */
-	lid = 13007;
+	lid = 21003;
 	c2_fi_enable_once("noninline_write", "cursor_get_err");
 	rc = test_delete_pdclust(LIST_ENUM_ID, lid,
 				 EXISTING_TEST,
@@ -4061,7 +4061,7 @@ static void test_delete_failure(void)
 	 * Simulate cursor delete failure in noninline_write() that is in the
 	 * path of list_encode() which is in the path of c2_layout_encode().
 	 */
-	lid = 13008;
+	lid = 21004;
 	c2_fi_enable_once("noninline_write", "cursor_del_err");
 	rc = test_delete_pdclust(LIST_ENUM_ID, lid,
 				 EXISTING_TEST,
-- 
1.8.3.2

