From ce71a43ba4a6c0886c0539ef21e80d7ad1bc2935 Mon Sep 17 00:00:00 2001
From: Hua Huang <hua_huang@xyratex.com>
Date: Tue, 20 Nov 2012 16:42:26 +0800
Subject: [PATCH 09/10] 1. added more pool machine unit tests for state
 transition and spare spare slot. 2. fix the spare slot array max index

---
 pool/pool.c       |   4 +-
 pool/ut/test_pm.c | 343 +++++++++++++++++++++++++++++++++++++++++++++++++++++-
 2 files changed, 342 insertions(+), 5 deletions(-)

diff --git a/pool/pool.c b/pool/pool.c
index cf1b46a..c29d1f9 100644
--- a/pool/pool.c
+++ b/pool/pool.c
@@ -457,7 +457,7 @@ int c2_poolmach_sns_repair_spare_query(struct c2_poolmach *pm,
 	int      rc;
 	C2_PRE(pm != NULL && spare_slot_out != NULL);
 
-	if (device_index >= pm->pm_state.pst_max_device_failures)
+	if (device_index >= pm->pm_state.pst_nr_devices)
 		return -EINVAL;
 
 	rc = -ENOENT;
@@ -493,7 +493,7 @@ int c2_poolmach_sns_rebalance_spare_query(struct c2_poolmach *pm,
 	int      rc;
 	C2_PRE(pm != NULL && spare_slot_out != NULL);
 
-	if (device_index >= pm->pm_state.pst_max_device_failures)
+	if (device_index >= pm->pm_state.pst_nr_devices)
 		return -EINVAL;
 
 	rc = -ENOENT;
diff --git a/pool/ut/test_pm.c b/pool/ut/test_pm.c
index 9efe65c..dcb106d 100644
--- a/pool/ut/test_pm.c
+++ b/pool/ut/test_pm.c
@@ -370,14 +370,351 @@ static void pm_test_transit(void)
 	c2_poolmach_fini(&pm);
 }
 
+static void pm_test_spare_slot(void)
+{
+	struct c2_poolmach    pm;
+	int                   rc;
+	struct c2_pool_event  event;
+	enum c2_pool_nd_state state_out;
+	enum c2_pool_nd_state target_state;
+	enum c2_pool_nd_state state;
+	uint32_t              spare_slot;
+
+	C2_SET0(&pm);
+	rc = c2_poolmach_init(&pm, NULL, 1, 10, 1, 2);
+	C2_UT_ASSERT(rc == 0);
+
+	event.pe_type  = C2_POOL_DEVICE;
+	event.pe_index = 1;
+
+
+	/* FAILED */
+	target_state = C2_PNDS_FAILED;
+	event.pe_state = target_state;
+	rc = c2_poolmach_state_transit(&pm, &event);
+	C2_UT_ASSERT(rc == 0);
+	rc = c2_poolmach_device_state(&pm, 1, &state_out);
+	C2_UT_ASSERT(rc == 0);
+	C2_UT_ASSERT(state_out == target_state);
+
+	rc = c2_poolmach_device_state(&pm, 10, &state_out);
+	C2_UT_ASSERT(rc == -EINVAL);
+	rc = c2_poolmach_device_state(&pm, 100, &state_out);
+	C2_UT_ASSERT(rc == -EINVAL);
+
+	for (state = C2_PNDS_ONLINE; state < C2_PNDS_NR; state++) {
+		if (state == C2_PNDS_SNS_REPAIRING)
+			continue;
+		/* transit to other state other than the above one is invalid */
+		event.pe_state = state;
+		rc = c2_poolmach_state_transit(&pm, &event);
+		C2_UT_ASSERT(rc == -EINVAL);
+	}
+
+	rc = c2_poolmach_device_state(&pm, 1, &state_out);
+	C2_UT_ASSERT(rc == 0);
+	C2_UT_ASSERT(state_out == target_state);
+
+
+	/* transit to SNS_REPAIRING */
+	target_state = C2_PNDS_SNS_REPAIRING;
+	event.pe_state = target_state;
+	rc = c2_poolmach_state_transit(&pm, &event);
+	C2_UT_ASSERT(rc == 0);
+	rc = c2_poolmach_device_state(&pm, 1, &state_out);
+	C2_UT_ASSERT(rc == 0);
+	C2_UT_ASSERT(state_out == target_state);
+	/* the first spare slot is used by device 1 */
+	rc = c2_poolmach_sns_repair_spare_query(&pm, 1, &spare_slot);
+	C2_UT_ASSERT(rc == 0);
+	C2_UT_ASSERT(spare_slot == 0);
+	/* no spare slot is used by device 2 */
+	rc = c2_poolmach_sns_repair_spare_query(&pm, 2, &spare_slot);
+	C2_UT_ASSERT(rc == -ENOENT);
+	for (state = C2_PNDS_ONLINE; state < C2_PNDS_NR; state++) {
+		if (state == C2_PNDS_SNS_REPAIRED)
+			continue;
+		/* transit to other state other than the above one is invalid */
+		event.pe_state = state;
+		rc = c2_poolmach_state_transit(&pm, &event);
+		C2_UT_ASSERT(rc == -EINVAL);
+	}
+
+
+	/* transit to SNS_REPAIRED */
+	target_state = C2_PNDS_SNS_REPAIRED;
+	event.pe_state = target_state;
+	rc = c2_poolmach_state_transit(&pm, &event);
+	C2_UT_ASSERT(rc == 0);
+	rc = c2_poolmach_device_state(&pm, 1, &state_out);
+	C2_UT_ASSERT(rc == 0);
+	C2_UT_ASSERT(state_out == target_state);
+	/* the first spare slot is used by device 1 */
+	rc = c2_poolmach_sns_repair_spare_query(&pm, 1, &spare_slot);
+	C2_UT_ASSERT(rc == 0);
+	C2_UT_ASSERT(spare_slot == 0);
+	/* no spare slot is used by device 2 */
+	rc = c2_poolmach_sns_repair_spare_query(&pm, 2, &spare_slot);
+	C2_UT_ASSERT(rc == -ENOENT);
+	for (state = C2_PNDS_ONLINE; state < C2_PNDS_NR; state++) {
+		if (state == C2_PNDS_SNS_REBALANCING)
+			continue;
+		/* transit to other state other than the above one is invalid */
+		event.pe_state = state;
+		rc = c2_poolmach_state_transit(&pm, &event);
+		C2_UT_ASSERT(rc == -EINVAL);
+	}
+
+
+	/* transit to SNS_REBALANCING */
+	target_state = C2_PNDS_SNS_REBALANCING;
+	event.pe_state = target_state;
+	rc = c2_poolmach_state_transit(&pm, &event);
+	C2_UT_ASSERT(rc == 0);
+	rc = c2_poolmach_device_state(&pm, 1, &state_out);
+	C2_UT_ASSERT(rc == 0);
+	C2_UT_ASSERT(state_out == target_state);
+	/* the first spare slot is used by device 1 */
+	rc = c2_poolmach_sns_rebalance_spare_query(&pm, 1, &spare_slot);
+	C2_UT_ASSERT(rc == 0);
+	C2_UT_ASSERT(spare_slot == 0);
+	for (state = C2_PNDS_ONLINE; state < C2_PNDS_NR; state++) {
+		if (state == C2_PNDS_SNS_REBALANCED)
+			continue;
+		/* transit to other state other than the above one is invalid */
+		event.pe_state = state;
+		rc = c2_poolmach_state_transit(&pm, &event);
+		C2_UT_ASSERT(rc == -EINVAL);
+	}
+
+
+	/* transit to SNS_REBALANCED */
+	target_state = C2_PNDS_SNS_REBALANCED;
+	event.pe_state = target_state;
+	rc = c2_poolmach_state_transit(&pm, &event);
+	C2_UT_ASSERT(rc == 0);
+	rc = c2_poolmach_device_state(&pm, 1, &state_out);
+	C2_UT_ASSERT(rc == 0);
+	C2_UT_ASSERT(state_out == target_state);
+	/* the first spare slot is used by device 1 */
+	rc = c2_poolmach_sns_rebalance_spare_query(&pm, 1, &spare_slot);
+	C2_UT_ASSERT(rc == 0);
+	C2_UT_ASSERT(spare_slot == 0);
+	for (state = C2_PNDS_ONLINE; state < C2_PNDS_NR; state++) {
+		if (state == C2_PNDS_ONLINE)
+			continue;
+		/* transit to other state other than the above one is invalid */
+		event.pe_state = state;
+		rc = c2_poolmach_state_transit(&pm, &event);
+		C2_UT_ASSERT(rc == -EINVAL);
+	}
+
+	/* transit to ONLINE */
+	target_state = C2_PNDS_ONLINE;
+	event.pe_state = target_state;
+	rc = c2_poolmach_state_transit(&pm, &event);
+	C2_UT_ASSERT(rc == 0);
+	rc = c2_poolmach_device_state(&pm, 1, &state_out);
+	C2_UT_ASSERT(rc == 0);
+	C2_UT_ASSERT(state_out == target_state);
+	/* the first spare slot is not used any more */
+	rc = c2_poolmach_sns_repair_spare_query(&pm, 1, &spare_slot);
+	C2_UT_ASSERT(rc == -ENOENT);
+
+	/* finally */
+	c2_poolmach_fini(&pm);
+}
+
+
+static void pm_test_multi_fail(void)
+{
+	struct c2_poolmach    pm;
+	int                   rc;
+	struct c2_pool_event  event;
+	enum c2_pool_nd_state state_out;
+	enum c2_pool_nd_state target_state;
+	uint32_t              spare_slot;
+
+	C2_SET0(&pm);
+	rc = c2_poolmach_init(&pm, NULL, 1, 10, 1, 3);
+	C2_UT_ASSERT(rc == 0);
+
+	event.pe_type  = C2_POOL_DEVICE;
+
+
+	/* device 1 FAILED */
+	event.pe_index = 1;
+	target_state = C2_PNDS_FAILED;
+	event.pe_state = target_state;
+	rc = c2_poolmach_state_transit(&pm, &event);
+	C2_UT_ASSERT(rc == 0);
+	rc = c2_poolmach_device_state(&pm, 1, &state_out);
+	C2_UT_ASSERT(rc == 0);
+	C2_UT_ASSERT(state_out == target_state);
+
+	/* device 2 FAILED */
+	event.pe_index = 2;
+	target_state = C2_PNDS_FAILED;
+	event.pe_state = target_state;
+	rc = c2_poolmach_state_transit(&pm, &event);
+	C2_UT_ASSERT(rc == 0);
+	rc = c2_poolmach_device_state(&pm, 2, &state_out);
+	C2_UT_ASSERT(rc == 0);
+	C2_UT_ASSERT(state_out == target_state);
+
+	/* transit device 1 to SNS_REPAIRING */
+	event.pe_index = 1;
+	target_state = C2_PNDS_SNS_REPAIRING;
+	event.pe_state = target_state;
+	rc = c2_poolmach_state_transit(&pm, &event);
+	C2_UT_ASSERT(rc == 0);
+	/* the first spare slot is used by device 1 */
+	rc = c2_poolmach_sns_repair_spare_query(&pm, 1, &spare_slot);
+	C2_UT_ASSERT(rc == 0);
+	C2_UT_ASSERT(spare_slot == 0);
+
+	/* transit device 2 to SNS_REPAIRING */
+	event.pe_index = 2;
+	target_state = C2_PNDS_SNS_REPAIRING;
+	event.pe_state = target_state;
+	rc = c2_poolmach_state_transit(&pm, &event);
+	C2_UT_ASSERT(rc == 0);
+	/* the second spare slot is used by device 2 */
+	rc = c2_poolmach_sns_repair_spare_query(&pm, 2, &spare_slot);
+	C2_UT_ASSERT(rc == 0);
+	C2_UT_ASSERT(spare_slot == 1);
+
+
+	/* transit device 1 to SNS_REPAIRED */
+	event.pe_index = 1;
+	target_state = C2_PNDS_SNS_REPAIRED;
+	event.pe_state = target_state;
+	rc = c2_poolmach_state_transit(&pm, &event);
+	C2_UT_ASSERT(rc == 0);
+	/* the first spare slot is used by device 1 */
+	rc = c2_poolmach_sns_repair_spare_query(&pm, 1, &spare_slot);
+	C2_UT_ASSERT(rc == 0);
+	C2_UT_ASSERT(spare_slot == 0);
+
+	/* transit device 2 to SNS_REPAIRED */
+	event.pe_index = 2;
+	target_state = C2_PNDS_SNS_REPAIRED;
+	event.pe_state = target_state;
+	rc = c2_poolmach_state_transit(&pm, &event);
+	C2_UT_ASSERT(rc == 0);
+	/* the second spare slot is used by device 2 */
+	rc = c2_poolmach_sns_repair_spare_query(&pm, 2, &spare_slot);
+	C2_UT_ASSERT(rc == 0);
+	C2_UT_ASSERT(spare_slot == 1);
+
+
+	/* transit device 1 to SNS_REBALANCING */
+	event.pe_index = 1;
+	target_state = C2_PNDS_SNS_REBALANCING;
+	event.pe_state = target_state;
+	rc = c2_poolmach_state_transit(&pm, &event);
+	C2_UT_ASSERT(rc == 0);
+	/* the first spare slot is used by device 1 */
+	rc = c2_poolmach_sns_rebalance_spare_query(&pm, 1, &spare_slot);
+	C2_UT_ASSERT(rc == 0);
+	C2_UT_ASSERT(spare_slot == 0);
+
+	/* transit device 2 to SNS_REBALANCING */
+	event.pe_index = 2;
+	target_state = C2_PNDS_SNS_REBALANCING;
+	event.pe_state = target_state;
+	rc = c2_poolmach_state_transit(&pm, &event);
+	C2_UT_ASSERT(rc == 0);
+	/* the second spare slot is used by device 2 */
+	rc = c2_poolmach_sns_rebalance_spare_query(&pm, 2, &spare_slot);
+	C2_UT_ASSERT(rc == 0);
+	C2_UT_ASSERT(spare_slot == 1);
+
+
+	/* transit device 1 to SNS_REBALANCED */
+	event.pe_index = 1;
+	target_state = C2_PNDS_SNS_REBALANCED;
+	event.pe_state = target_state;
+	rc = c2_poolmach_state_transit(&pm, &event);
+	C2_UT_ASSERT(rc == 0);
+	/* the first spare slot is used by device 1 */
+	rc = c2_poolmach_sns_rebalance_spare_query(&pm, 1, &spare_slot);
+	C2_UT_ASSERT(rc == 0);
+	C2_UT_ASSERT(spare_slot == 0);
+
+	/* transit device 2 to SNS_REBALANCED */
+	event.pe_index = 2;
+	target_state = C2_PNDS_SNS_REBALANCED;
+	event.pe_state = target_state;
+	rc = c2_poolmach_state_transit(&pm, &event);
+	C2_UT_ASSERT(rc == 0);
+	/* the second spare slot is used by device 2 */
+	rc = c2_poolmach_sns_rebalance_spare_query(&pm, 2, &spare_slot);
+	C2_UT_ASSERT(rc == 0);
+	C2_UT_ASSERT(spare_slot == 1);
+
+	/* transit device 2 to ONLINE */
+	event.pe_index = 2;
+	target_state = C2_PNDS_ONLINE;
+	event.pe_state = target_state;
+	rc = c2_poolmach_state_transit(&pm, &event);
+	C2_UT_ASSERT(rc == 0);
+	rc = c2_poolmach_sns_repair_spare_query(&pm, 2, &spare_slot);
+	C2_UT_ASSERT(rc == -ENOENT);
+
+	/* transit device 3 to FAILED */
+	event.pe_index = 3;
+	target_state = C2_PNDS_FAILED;
+	event.pe_state = target_state;
+	rc = c2_poolmach_state_transit(&pm, &event);
+	C2_UT_ASSERT(rc == 0);
+	target_state = C2_PNDS_SNS_REPAIRING;
+	event.pe_state = target_state;
+	rc = c2_poolmach_state_transit(&pm, &event);
+	C2_UT_ASSERT(rc == 0);
+	rc = c2_poolmach_sns_repair_spare_query(&pm, 3, &spare_slot);
+	C2_UT_ASSERT(rc == 0);
+	C2_UT_ASSERT(spare_slot == 1);
+
+	/* transit device 1 to ONLINE */
+	event.pe_index = 1;
+	target_state = C2_PNDS_ONLINE;
+	event.pe_state = target_state;
+	rc = c2_poolmach_state_transit(&pm, &event);
+	C2_UT_ASSERT(rc == 0);
+	rc = c2_poolmach_sns_repair_spare_query(&pm, 1, &spare_slot);
+	C2_UT_ASSERT(rc == -ENOENT);
+
+	/* transit device 4 to FAILED */
+	event.pe_index = 4;
+	target_state = C2_PNDS_FAILED;
+	event.pe_state = target_state;
+	rc = c2_poolmach_state_transit(&pm, &event);
+	C2_UT_ASSERT(rc == 0);
+	target_state = C2_PNDS_SNS_REPAIRING;
+	event.pe_state = target_state;
+	rc = c2_poolmach_state_transit(&pm, &event);
+	C2_UT_ASSERT(rc == 0);
+	rc = c2_poolmach_sns_repair_spare_query(&pm, 4, &spare_slot);
+	C2_UT_ASSERT(rc == 0);
+	C2_UT_ASSERT(spare_slot == 0);
+
+
+	/* finally */
+	c2_poolmach_fini(&pm);
+}
+
+
 const struct c2_test_suite poolmach_ut = {
 	.ts_name = "poolmach-ut",
 	.ts_init = NULL,
 	.ts_fini = NULL,
 	.ts_tests = {
-		{ "pm_test init & fini",   pm_test_init_fini},
-		{ "pm_test state transit", pm_test_transit  },
-		{ NULL,                    NULL             }
+		{ "pm_test init & fini",   pm_test_init_fini },
+		{ "pm_test state transit", pm_test_transit   },
+		{ "pm_test spare slot",    pm_test_spare_slot},
+		{ "pm_test multi fail",    pm_test_multi_fail},
+		{ NULL,                    NULL              }
 	}
 };
 C2_EXPORTED(poolmach_ut);
-- 
1.8.3.2

