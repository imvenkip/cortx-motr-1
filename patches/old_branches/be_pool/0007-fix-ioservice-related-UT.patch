From 3ce81ff7ffd0e17bd6deecad6f44431d370d2a06 Mon Sep 17 00:00:00 2001
From: Hua Huang <hua_huang@xyratex.com>
Date: Fri, 20 Dec 2013 21:28:18 +0800
Subject: [PATCH 07/11] fix ioservice related UT.

---
 ioservice/io_device.c    |  9 ++++++++-
 ioservice/ut/bulkio_ut.c | 21 +++++++++++++++------
 ioservice/ut/cob_foms.c  | 29 +++++++++++++++++++----------
 3 files changed, 42 insertions(+), 17 deletions(-)

diff --git a/ioservice/io_device.c b/ioservice/io_device.c
index f5e3038..fc638c5 100644
--- a/ioservice/io_device.c
+++ b/ioservice/io_device.c
@@ -237,6 +237,7 @@
 #include "reqh/reqh_service.h"
 #include "ioservice/io_fops.h"
 #include "mero/setup.h"
+#include "lib/locality.h"
 
 /**
    @addtogroup io_calls_params_dldDFS
@@ -254,6 +255,7 @@ M0_INTERNAL int m0_ios_poolmach_init(struct m0_reqh_service *service)
 	int                 rc;
 	struct m0_poolmach *poolmach;
 	struct m0_reqh     *reqh = service->rs_reqh;
+	struct m0_sm_group *grp  = m0_locality0_get()->lo_grp;
 
 	M0_PRE(service != NULL);
 	M0_PRE(service->rs_reqh_ctx != NULL);
@@ -268,11 +270,16 @@ M0_INTERNAL int m0_ios_poolmach_init(struct m0_reqh_service *service)
 	}
 
 	/* TODO configuration information is needed here. */
-	rc = m0_poolmach_init(poolmach, reqh->rh_beseg, NULL, reqh->rh_dtm,
+
+	/* We are not using reqh->rh_sm_grp here, otherwise deadlock */
+	m0_sm_group_lock(grp);
+	rc = m0_poolmach_init(poolmach, reqh->rh_beseg, grp,
+			      reqh->rh_dtm,
 			      PM_DEFAULT_NR_NODES,
 			      service->rs_reqh_ctx->rc_mero->cc_pool_width,
 			      PM_DEFAULT_MAX_NODE_FAILURES,
 			      PM_DEFAULT_MAX_DEV_FAILURES);
+	m0_sm_group_unlock(grp);
 	if (rc != 0) {
 		m0_free(poolmach);
 		goto out;
diff --git a/ioservice/ut/bulkio_ut.c b/ioservice/ut/bulkio_ut.c
index 5ce5853..f882b0d 100644
--- a/ioservice/ut/bulkio_ut.c
+++ b/ioservice/ut/bulkio_ut.c
@@ -1668,8 +1668,10 @@ static void bulkio_server_read_write_fv_mismatch(void)
 	struct m0_fop		   *rfop;
 	struct m0_fop_cob_rw_reply *rw_reply;
 	int			    rc;
-	struct m0_db_tx             tx;
 	struct m0_fop_cob_rw	   *rw;
+	struct m0_be_tx_credit      cred = {};
+	struct m0_be_tx             tx;
+	struct m0_sm_group         *grp  = m0_locality0_get()->lo_grp;
 
 	event.pe_type  = M0_POOL_DEVICE;
 	event.pe_index = 1;
@@ -1678,15 +1680,22 @@ static void bulkio_server_read_write_fv_mismatch(void)
 	reqh = m0_cs_reqh_get(&bp->bp_sctx->rsx_mero_ctx, "ioservice");
 	M0_UT_ASSERT(reqh != NULL);
 
-	rc = m0_db_tx_init(&tx, reqh->rh_dbenv, 0);
-	M0_UT_ASSERT(rc == 0);
-
 	pm = m0_ios_poolmach_get(reqh);
 	M0_UT_ASSERT(pm != NULL);
 
-	rc = m0_poolmach_state_transit(pm, &event, NULL);
+	m0_sm_group_lock(grp);
+	m0_be_tx_init(&tx, 0,reqh->rh_beseg->bs_domain, grp,
+			      NULL, NULL, NULL, NULL);
+	m0_poolmach_store_credit(pm, &cred);
+
+	m0_be_tx_prep(&tx, &cred);
+	rc = m0_be_tx_open_sync(&tx);
+	M0_ASSERT(rc == 0);
+	rc = m0_poolmach_state_transit(pm, &event, &tx);
+	m0_be_tx_close_sync(&tx);
+	m0_be_tx_fini(&tx);
 	M0_UT_ASSERT(rc == 0);
-	m0_db_tx_commit(&tx);
+	m0_sm_group_unlock(grp);
 
 	/* This is just a test to detect failure vector mismatch on server
 	 * side. No need to prepare a full write request, e.g. buffer.
diff --git a/ioservice/ut/cob_foms.c b/ioservice/ut/cob_foms.c
index 2ed8584..5f1abb2 100644
--- a/ioservice/ut/cob_foms.c
+++ b/ioservice/ut/cob_foms.c
@@ -1124,11 +1124,13 @@ static void cob_delete_api_test(void)
 
 static void cobfoms_fv_updates(void)
 {
-	struct m0_reqh      *reqh;
-	struct m0_poolmach  *pm;
-	struct m0_pool_event event;
-	struct m0_db_tx      tx;
-	int rc;
+	struct m0_reqh        *reqh;
+	struct m0_poolmach    *pm;
+	struct m0_pool_event   event;
+	struct m0_be_tx_credit cred = {};
+	struct m0_be_tx        tx;
+	struct m0_sm_group    *grp  = m0_locality0_get()->lo_grp;
+	int                    rc;
 
 	event.pe_type  = M0_POOL_DEVICE;
 	event.pe_index = 1;
@@ -1137,15 +1139,22 @@ static void cobfoms_fv_updates(void)
 	reqh = m0_cs_reqh_get(&cut->cu_sctx.rsx_mero_ctx, "ioservice");
 	M0_UT_ASSERT(reqh != NULL);
 
-	rc = m0_db_tx_init(&tx, reqh->rh_dbenv, 0);
-	M0_UT_ASSERT(rc == 0);
-
 	pm = m0_ios_poolmach_get(reqh);
 	M0_UT_ASSERT(pm != NULL);
 
-	rc = m0_poolmach_state_transit(pm, &event, NULL);
+	m0_sm_group_lock(grp);
+	m0_be_tx_init(&tx, 0,reqh->rh_beseg->bs_domain, grp,
+			      NULL, NULL, NULL, NULL);
+	m0_poolmach_store_credit(pm, &cred);
+
+	m0_be_tx_prep(&tx, &cred);
+	rc = m0_be_tx_open_sync(&tx);
+	M0_ASSERT(rc == 0);
+	rc = m0_poolmach_state_transit(pm, &event, &tx);
+	m0_be_tx_close_sync(&tx);
+	m0_be_tx_fini(&tx);
 	M0_UT_ASSERT(rc == 0);
-	m0_db_tx_commit(&tx);
+	m0_sm_group_unlock(grp);
 
 	cobfoms_send_internal(&m0_fop_cob_create_fopt, &m0_fop_cob_delete_fopt,
 			      M0_IOP_ERROR_FAILURE_VECTOR_VER_MISMATCH,
-- 
1.8.3.2

