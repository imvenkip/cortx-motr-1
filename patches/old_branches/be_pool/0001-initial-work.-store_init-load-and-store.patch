From 8e9bb2d9ddd7c5dbf985d911ae9235b27c4f3268 Mon Sep 17 00:00:00 2001
From: Hua Huang <hua_huang@xyratex.com>
Date: Thu, 12 Dec 2013 20:48:27 +0800
Subject: [PATCH 01/11] initial work. store_init(), load(), and store().

---
 be/alloc.h                    |   9 +
 be/tx.h                       |   2 +
 ioservice/io_device.c         |   2 +-
 ioservice/ut/bulkio_ut.c      |   2 +-
 ioservice/ut/cob_foms.c       |   2 +-
 m0t1fs/linux_kernel/super.c   |   2 +-
 m0t1fs/linux_kernel/ut/file.c |   2 +-
 pool/pool.c                   |  35 +--
 pool/pool.h                   |  43 ++--
 pool/pool_foms.c              |   2 +-
 pool/pool_store.c             | 527 ++++++++++++++++--------------------------
 pool/ut/test_pm.c             |  74 +++---
 sns/cm/cm.c                   |   2 +-
 sns/cm/repair/ut/cm.c         |   2 +-
 14 files changed, 285 insertions(+), 421 deletions(-)

diff --git a/be/alloc.h b/be/alloc.h
index dd74b85..8f96da8 100644
--- a/be/alloc.h
+++ b/be/alloc.h
@@ -272,6 +272,15 @@ M0_INTERNAL void m0_be_alloc_stats(struct m0_be_allocator *a,
 		m0_be_allocator_credit(m0_be_seg_allocator(seg),	\
 				       M0_BAO_FREE, sizeof *(ptr), 0, (accum))
 
+#define M0_BE_ALLOC_CREDIT_ARR(arr, nr, seg, accum)				\
+		m0_be_allocator_credit(m0_be_seg_allocator(seg),	\
+				       M0_BAO_ALLOC, (nr) * sizeof((arr)[0]), 0, (accum))
+
+#define M0_BE_FREE_CREDIT_ARR(arr, nr, seg, accum)				\
+		m0_be_allocator_credit(m0_be_seg_allocator(seg),	\
+				       M0_BAO_FREE, (nr) * sizeof((arr)[0]), 0, (accum))
+
+
 /** @} end of be group */
 #endif /* __MERO_BE_ALLOC_H__ */
 /*
diff --git a/be/tx.h b/be/tx.h
index 34319f0..d605c85 100644
--- a/be/tx.h
+++ b/be/tx.h
@@ -375,6 +375,8 @@ M0_INTERNAL void m0_be_tx_uncapture(struct m0_be_tx *tx,
 /* XXX change to (tx, seg, ptr) */
 #define M0_BE_TX_CAPTURE_PTR(seg, tx, ptr) \
 	m0_be_tx_capture((tx), &M0_BE_REG((seg), sizeof *(ptr), (ptr)))
+#define M0_BE_TX_CAPTURE_ARR(seg, tx, arr, nr) \
+	m0_be_tx_capture((tx), &M0_BE_REG((seg), (nr) * sizeof((arr)[0]), (arr)))
 
 M0_INTERNAL void m0_be_tx_close(struct m0_be_tx *tx);
 
diff --git a/ioservice/io_device.c b/ioservice/io_device.c
index ca52edb..f5e3038 100644
--- a/ioservice/io_device.c
+++ b/ioservice/io_device.c
@@ -268,7 +268,7 @@ M0_INTERNAL int m0_ios_poolmach_init(struct m0_reqh_service *service)
 	}
 
 	/* TODO configuration information is needed here. */
-	rc = m0_poolmach_init(poolmach, reqh->rh_dbenv, reqh->rh_dtm,
+	rc = m0_poolmach_init(poolmach, reqh->rh_beseg, NULL, reqh->rh_dtm,
 			      PM_DEFAULT_NR_NODES,
 			      service->rs_reqh_ctx->rc_mero->cc_pool_width,
 			      PM_DEFAULT_MAX_NODE_FAILURES,
diff --git a/ioservice/ut/bulkio_ut.c b/ioservice/ut/bulkio_ut.c
index b66fbd7..5ce5853 100644
--- a/ioservice/ut/bulkio_ut.c
+++ b/ioservice/ut/bulkio_ut.c
@@ -1684,7 +1684,7 @@ static void bulkio_server_read_write_fv_mismatch(void)
 	pm = m0_ios_poolmach_get(reqh);
 	M0_UT_ASSERT(pm != NULL);
 
-	rc = m0_poolmach_state_transit(pm, &event, &tx);
+	rc = m0_poolmach_state_transit(pm, &event, NULL);
 	M0_UT_ASSERT(rc == 0);
 	m0_db_tx_commit(&tx);
 
diff --git a/ioservice/ut/cob_foms.c b/ioservice/ut/cob_foms.c
index 238dc79..2ed8584 100644
--- a/ioservice/ut/cob_foms.c
+++ b/ioservice/ut/cob_foms.c
@@ -1143,7 +1143,7 @@ static void cobfoms_fv_updates(void)
 	pm = m0_ios_poolmach_get(reqh);
 	M0_UT_ASSERT(pm != NULL);
 
-	rc = m0_poolmach_state_transit(pm, &event, &tx);
+	rc = m0_poolmach_state_transit(pm, &event, NULL);
 	M0_UT_ASSERT(rc == 0);
 	m0_db_tx_commit(&tx);
 
diff --git a/m0t1fs/linux_kernel/super.c b/m0t1fs/linux_kernel/super.c
index cf016ca..45d28f0 100644
--- a/m0t1fs/linux_kernel/super.c
+++ b/m0t1fs/linux_kernel/super.c
@@ -715,7 +715,7 @@ static int m0t1fs_poolmach_create(struct m0_poolmach **out, uint32_t pool_width,
 	if (m == NULL)
 		return -ENOMEM;
 
-	rc = m0_poolmach_init(m, NULL, NULL, NR_NODES, pool_width,
+	rc = m0_poolmach_init(m, NULL, NULL, NULL, NR_NODES, pool_width,
 			      MAX_NODE_FAILURES, nr_parity_units);
 	if (rc == 0)
 		*out = m;
diff --git a/m0t1fs/linux_kernel/ut/file.c b/m0t1fs/linux_kernel/ut/file.c
index f72fa5c..70e0cb3 100644
--- a/m0t1fs/linux_kernel/ut/file.c
+++ b/m0t1fs/linux_kernel/ut/file.c
@@ -158,7 +158,7 @@ static int file_io_ut_init(void)
 	M0_SET0(&poolmach);
 	csb.csb_pool.po_mach = &poolmach;
 
-	rc = m0_poolmach_init(csb.csb_pool.po_mach, NULL, NULL,
+	rc = m0_poolmach_init(csb.csb_pool.po_mach, NULL, NULL, NULL,
 			      1, LAY_P, 1, LAY_K);
 	M0_ASSERT(rc == 0);
 
diff --git a/pool/pool.c b/pool/pool.c
index fd3f62b..301eca1 100644
--- a/pool/pool.c
+++ b/pool/pool.c
@@ -186,16 +186,17 @@
 
 /* Import following interfaces which are defined in pool/pool_store.c */
 M0_INTERNAL int m0_poolmach_store_init(struct m0_poolmach *pm,
-				       struct m0_dbenv    *dbenv,
+				       struct m0_be_seg   *be_seg,
+				       struct m0_sm_group *sm_grp,
 				       struct m0_dtm      *dtm,
 				       uint32_t            nr_nodes,
 				       uint32_t            nr_devices,
 				       uint32_t            max_node_failures,
 				       uint32_t            max_device_failures);
 M0_INTERNAL int m0_poolmach_store(struct m0_poolmach *pm,
-				  struct m0_db_tx    *tx);
+				  struct m0_be_tx    *tx);
 M0_INTERNAL int m0_poolmach_event_store(struct m0_poolmach *pm,
-					struct m0_db_tx    *tx,
+					struct m0_be_tx    *tx,
 					struct m0_pool_event_link *event_link);
 
 M0_TL_DESCR_DEFINE(poolmach_events, "pool machine events list", M0_INTERNAL,
@@ -264,12 +265,13 @@ M0_INTERNAL bool m0_poolmach_version_before(const struct m0_pool_version_numbers
 }
 
 M0_INTERNAL int m0_poolmach_init(struct m0_poolmach *pm,
-				 struct m0_dbenv *dbenv,
-				 struct m0_dtm *dtm,
-				 uint32_t nr_nodes,
-				 uint32_t nr_devices,
-				 uint32_t max_node_failures,
-				 uint32_t max_device_failures)
+				 struct m0_be_seg   *be_seg,
+				 struct m0_sm_group *sm_grp,
+				 struct m0_dtm      *dtm,
+				 uint32_t            nr_nodes,
+				 uint32_t            nr_devices,
+				 uint32_t            max_node_failures,
+				 uint32_t            max_device_failures)
 {
 	uint32_t i;
 	int      rc = 0;
@@ -319,14 +321,15 @@ M0_INTERNAL int m0_poolmach_init(struct m0_poolmach *pm,
 	}
 	poolmach_events_tlist_init(&pm->pm_state.pst_events_list);
 	m0_rwlock_init(&pm->pm_lock);
-	if (dbenv != NULL) {
+	if (be_seg != NULL) {
 		/* On client, dbenv is NULL */
-		rc = m0_poolmach_store_init(pm, dbenv, dtm, nr_nodes,
+		rc = m0_poolmach_store_init(pm, be_seg, sm_grp, dtm, nr_nodes,
 					    nr_devices, max_node_failures,
 					    max_device_failures);
 	}
 	if (rc == 0) {
-		pm->pm_dbenv = dbenv;
+		pm->pm_be_seg = be_seg;
+		pm->pm_sm_grp = sm_grp;
 		pm->pm_is_initialised = true;
 	} else
 		m0_poolmach_fini(pm);
@@ -353,9 +356,7 @@ M0_INTERNAL void m0_poolmach_fini(struct m0_poolmach *pm)
 	m0_free(pm->pm_state.pst_nodes_array);
 	m0_rwlock_write_unlock(&pm->pm_lock);
 
-	if (pm->pm_dbenv != NULL) {
-		m0_table_fini(&pm->pm_table);
-		m0_table_fini(&pm->pm_events_table);
+	if (pm->pm_be_seg != NULL) {
 	}
 	pm->pm_is_initialised = false;
 	m0_rwlock_fini(&pm->pm_lock);
@@ -380,7 +381,7 @@ M0_INTERNAL void m0_poolmach_fini(struct m0_poolmach *pm)
  */
 M0_INTERNAL int m0_poolmach_state_transit(struct m0_poolmach   *pm,
 					  struct m0_pool_event *event,
-					  struct m0_db_tx      *tx)
+					  struct m0_be_tx      *tx)
 {
 	struct m0_poolmach_state   *pm_state;
 	struct m0_pool_spare_usage *spare_array;
@@ -533,7 +534,7 @@ M0_INTERNAL int m0_poolmach_state_transit(struct m0_poolmach   *pm,
 		;
 	}
 
-	if (pm->pm_dbenv != NULL) {
+	if (pm->pm_be_seg != NULL) {
 		/* This poolmach is on server. Update to persistent storage. */
 		M0_ASSERT(tx != NULL);
 		rc = m0_poolmach_store(pm, tx);
diff --git a/pool/pool.h b/pool/pool.h
index f29c1d0..dc3c285 100644
--- a/pool/pool.h
+++ b/pool/pool.h
@@ -293,18 +293,10 @@ struct m0_poolmach {
 	/** struct m0_persistent_sm  pm_mach; */
 	struct m0_poolmach_state pm_state;
 
-	/**
-	 * the db table to store poolmach state.
-	 */
-	struct m0_table          pm_table;
+	/** the be_seg. if this is NULL, the poolmach is on client. */
+	struct m0_be_seg        *pm_be_seg;
 
-	/**
-	 * events stored here.
-	 */
-	struct m0_table          pm_events_table;
-
-	/** the dbenv. if this is NULL, the poolmach is on client. */
-	struct m0_dbenv         *pm_dbenv;
+	struct m0_sm_group      *pm_sm_grp;
 
 	/** this pool machine initialized or not */
 	bool                     pm_is_initialised;
@@ -313,18 +305,16 @@ struct m0_poolmach {
 	struct m0_rwlock         pm_lock;
 };
 
-M0_INTERNAL bool m0_poolmach_version_equal(const struct m0_pool_version_numbers
-					   *v1,
-					   const struct m0_pool_version_numbers
-					   *v2);
+M0_INTERNAL bool
+m0_poolmach_version_equal(const struct m0_pool_version_numbers *v1,
+			  const struct m0_pool_version_numbers *v2);
 /**
  * Pool Machine version numbers are incremented upon event.
  * v1 before v2 means v2's version number is greater than v1's.
  */
-M0_INTERNAL bool m0_poolmach_version_before(const struct m0_pool_version_numbers
-					    *v1,
-					    const struct m0_pool_version_numbers
-					    *v2);
+M0_INTERNAL bool
+m0_poolmach_version_before(const struct m0_pool_version_numbers *v1,
+			   const struct m0_pool_version_numbers *v2);
 /**
  * Initialises the pool machine.
  *
@@ -332,12 +322,13 @@ M0_INTERNAL bool m0_poolmach_version_before(const struct m0_pool_version_numbers
  * call, it will initialise the persistent data.
  */
 M0_INTERNAL int m0_poolmach_init(struct m0_poolmach *pm,
-				 struct m0_dbenv *dbenv,
-				 struct m0_dtm *dtm,
-				 uint32_t nr_nodes,
-				 uint32_t nr_devices,
-				 uint32_t max_node_failures,
-				 uint32_t max_device_failures);
+				 struct m0_be_seg   *be_seg,
+				 struct m0_sm_group *sm_grp,
+				 struct m0_dtm      *dtm,
+				 uint32_t            nr_nodes,
+				 uint32_t            nr_devices,
+				 uint32_t            max_node_failures,
+				 uint32_t            max_device_failures);
 
 /**
  * Finalises the pool machine.
@@ -353,7 +344,7 @@ M0_INTERNAL void m0_poolmach_fini(struct m0_poolmach *pm);
  */
 M0_INTERNAL int m0_poolmach_state_transit(struct m0_poolmach   *pm,
 					  struct m0_pool_event *event,
-					  struct m0_db_tx      *tx);
+					  struct m0_be_tx      *tx);
 
 /**
  * Query the state changes between the "from" and "to" version.
diff --git a/pool/pool_foms.c b/pool/pool_foms.c
index 0d57ade..0ee3bbf 100644
--- a/pool/pool_foms.c
+++ b/pool/pool_foms.c
@@ -132,7 +132,7 @@ static int poolmach_fom_tick(struct m0_fom *fom)
 		     pme.pe_index = set_fop->fps_dev_info.fpi_dev[i].fpd_index;
 		     pme.pe_state = set_fop->fps_dev_info.fpi_dev[i].fpd_state;
 		     rc = m0_poolmach_state_transit(poolmach, &pme,
-				     &fom->fo_tx.tx_dbtx);
+				     &fom->fo_tx.tx_betx);
 		     if (rc != 0)
 			     break;
 		}
diff --git a/pool/pool_store.c b/pool/pool_store.c
index 52e0505..0f38718 100644
--- a/pool/pool_store.c
+++ b/pool/pool_store.c
@@ -26,6 +26,7 @@
 #include "pool/pool.h"
 #include "lib/misc.h"
 #include "lib/uuid.h"
+#include "be/be.h"
 
 /**
    @addtogroup pool
@@ -61,389 +62,247 @@ struct m0_pool_event_rec {
 	struct m0_pool_event           per_event;
 };
 
-static const struct m0_table_ops m0_poolmach_events_table_ops = {
-	.to = {
-		[TO_KEY] = {
-			.max_size = sizeof (struct m0_pool_version_numbers)
-			},
-		[TO_REC] = {
-			.max_size = sizeof (struct m0_pool_event_rec)
-			}
-	},
-	.key_cmp = NULL
-};
-
-static const struct m0_table_ops m0_poolmach_store_ops = {
-	.to = {
-		[TO_KEY] = {
-			.max_size = sizeof (uint64_t)
-			},
-		[TO_REC] = {
-			 /* XXX: Hack!!! For big values of pool width.
-			    Will be removed by pool/ conversion.
-			  */
-			.max_size = 4096
-			/* .max_size = ~0 */
-			}
-	},
-	.key_cmp = NULL
-};
-
-/** key for poolmach state */
-static uint64_t poolmach_state_key = 1ULL;
-
-/** key for device state array record */
-static uint64_t poolmach_device_state_key = 2ULL;
-
-/** key for node state array record */
-static uint64_t poolmach_node_state_key = 3ULL;
+#ifndef __KERNEL__
 
-/** key for spare space slot array record */
-static uint64_t poolmach_spare_key = 4ULL;
-
-static int load_from_db(struct m0_table *table,
-			struct m0_db_tx *tx,
-			void            *key,
-			int             size_of_key,
-			void            *rec,
-			int             size_of_rec)
+static void m0_poolmach_events_load(struct m0_poolmach *pm,
+				    struct m0_poolmach_state *pm_state_on_disk)
 {
-	struct m0_db_pair pair;
-	int               rc;
-
-	m0_db_pair_setup(&pair, table,
-			 key, size_of_key,
-			 rec, size_of_rec);
-
-	rc = m0_table_lookup(tx, &pair);
-	m0_db_pair_release(&pair);
-	m0_db_pair_fini(&pair);
-	return rc;
+	struct m0_tl *dst_head = &pm->pm_state.pst_events_list;
+	struct m0_tl *src_head = &pm_state_on_disk->pst_events_list;
+	struct m0_pool_event_link *scan;
+	struct m0_pool_event_link *new;
+
+	m0_tl_for(poolmach_events, src_head, scan) {
+		m0_poolmach_event_dump(&scan->pel_event);
+		m0_poolmach_version_dump(&scan->pel_new_version);
+		M0_ALLOC_PTR(new);
+		M0_ASSERT(new != NULL);
+
+		new->pel_event = scan->pel_event;
+		new->pel_new_version = scan->pel_new_version;
+		poolmach_events_tlink_init_at_tail(new, dst_head);
+	} m0_tl_endfor;
 }
 
-static int store_into_db(struct m0_table *table,
-			 struct m0_db_tx *tx,
-			 void            *key,
-			 int              size_of_key,
-			 void            *rec,
-			 int              size_of_rec)
-{
-	struct m0_db_pair pair;
-	int               rc;
-
-	m0_db_pair_setup(&pair, table,
-			 key, size_of_key,
-			 rec, size_of_rec);
-
-	rc = m0_table_update(tx, &pair);
-	m0_db_pair_release(&pair);
-	m0_db_pair_fini(&pair);
-	return rc;
-}
-
-static int m0_poolmach_events_load(struct m0_poolmach *pm,
-			           struct m0_db_tx    *tx)
-{
-	struct m0_db_pair              pair;
-	struct m0_pool_version_numbers event_key = {
-					.pvn_version = {
-						[PVE_READ]  = 0ULL,
-						[PVE_WRITE] = 0ULL
-					}
-				       };
-	struct m0_pool_event_rec       event_rec;
-	struct m0_db_cursor            cursor;
-	struct m0_pool_event_link      *event_link;
-	int                            rc;
-
-	M0_ENTRY();
-
-	rc = m0_db_cursor_init(&cursor, &pm->pm_events_table, tx, 0);
-	if (rc != 0)
-		M0_RETURN(rc);
-
-	m0_db_pair_setup(&pair, &pm->pm_events_table, &event_key, sizeof event_key,
-			 &event_rec, sizeof event_rec);
-	rc = m0_db_cursor_get(&cursor, &pair);
-	if (rc == -ENOENT) {
-		rc = 0;
-		goto out;
-	}
-	do {
-		M0_ALLOC_PTR(event_link);
-		if (event_link == NULL) {
-			rc = -ENOMEM;
-			goto out;
-		}
-
-		event_link->pel_event = event_rec.per_event;
-		event_link->pel_new_version = event_key;
-		poolmach_events_tlink_init_at_tail(event_link,
-					 &pm->pm_state.pst_events_list);
-		rc = m0_db_cursor_next(&cursor, &pair);
-	} while (rc == 0);
-
-out:
-	m0_db_pair_release(&pair);
-	m0_db_pair_fini(&pair);
-	m0_db_cursor_fini(&cursor);
-	M0_RETURN(rc);
-}
 
 M0_INTERNAL int m0_poolmach_event_store(struct m0_poolmach *pm,
-					struct m0_db_tx    *tx,
+					struct m0_be_tx *tx,
 					struct m0_pool_event_link *event_link)
 {
-	struct m0_pool_version_numbers event_key;
-	struct m0_pool_event_rec       event_rec;
-	int                            rc;
-
-	event_key = event_link->pel_new_version;
-	event_rec.per_event = event_link->pel_event;
+	int              rc = 0;
 
-	rc = store_into_db(&pm->pm_events_table, tx,
-			   &event_key, sizeof (event_key),
-			   &event_rec, sizeof (event_rec));
+	tx = NULL;
 	return rc;
 }
 
 
 /**
- * Store all pool machine state into db.
+ * Store all pool machine state and events into db.
  *
  * Existing records are overwritten.
  */
 M0_INTERNAL int m0_poolmach_store(struct m0_poolmach *pm,
-				  struct m0_db_tx    *tx)
+				  struct m0_be_tx *tx)
 {
-	uint32_t                        nr_nodes;
-	uint32_t                        nr_devices;
-	uint32_t                        max_node_failures;
-	uint32_t                        max_device_failures;
-	struct m0_poolmach_state_rec    poolmach_rec;
-	struct m0_poolnode_rec         *poolnode_rec;
-	struct m0_pooldev_rec          *pooldev_rec;
-	struct m0_pool_spare_usage_rec *pool_spare_usage_rec;
-	uint32_t                        i;
-	int                             rc;
-
-	nr_nodes            = pm->pm_state.pst_nr_nodes;
-	nr_devices          = pm->pm_state.pst_nr_devices;
-	max_node_failures   = pm->pm_state.pst_max_node_failures;
-	max_device_failures = pm->pm_state.pst_max_device_failures;
-
-	M0_ALLOC_ARR(poolnode_rec, nr_nodes);
-	M0_ALLOC_ARR(pooldev_rec, nr_devices);
-	M0_ALLOC_ARR(pool_spare_usage_rec, max_device_failures);
-	if (poolnode_rec == NULL ||
-	    pooldev_rec == NULL ||
-	    pool_spare_usage_rec == NULL) {
-		rc = -ENOMEM;
-		goto out_free;
-	}
-
-	poolmach_rec.psr_version = pm->pm_state.pst_version;
-	poolmach_rec.psr_nr_nodes = nr_nodes;
-	poolmach_rec.psr_nr_devices = nr_devices;
-	poolmach_rec.psr_max_node_failures = max_node_failures;
-	poolmach_rec.psr_max_device_failures = max_device_failures;
-	rc = store_into_db(&pm->pm_table, tx,
-			   &poolmach_state_key, sizeof poolmach_state_key,
-			   &poolmach_rec, sizeof poolmach_rec);
-	if (rc != 0)
-		goto out_free;
+	struct m0_poolmach_state *src = &pm->pm_state;
+	struct m0_poolmach_state *dest;
+	const char               *poolmach_name = "poolmach_state";
+	int                       rc = 0;
+	M0_ENTRY();
 
-	for (i = 0; i < nr_nodes; i++) {
-		poolnode_rec[i].pn_state =
-				pm->pm_state.pst_nodes_array[i].pn_state;
-		/* @todo retrieve uuid: poolnode_rec[i].pn_node_id = uuid */
-	}
-	rc = store_into_db(&pm->pm_table, tx,
-			   &poolmach_node_state_key,
-			   sizeof poolmach_node_state_key,
-			   poolnode_rec,
-			   nr_nodes * sizeof (*poolnode_rec));
+	rc = m0_be_seg_dict_lookup(pm->pm_be_seg, poolmach_name, (void**)&dest);
 	if (rc != 0)
-		goto out_free;
-
-
-	for (i = 0; i < nr_devices; i++) {
-		pooldev_rec[i].pd_state =
-				pm->pm_state.pst_devices_array[i].pd_state;
-		/* @todo pooldev_rec[i].pd_node_id = uuid */
-		/* @todo pooldev_rec[i].pd_dev_id = uuid */
+		return rc;
+	
+	if (dest->pst_nr_nodes != src->pst_nr_nodes ||
+	    dest->pst_nr_devices != src->pst_nr_devices ||
+	    dest->pst_max_node_failures != src->pst_max_node_failures ||
+	    dest->pst_max_device_failures != src->pst_max_device_failures) {
+		M0_LOG(M0_FATAL, "Invalid pool configuration. Using stale pool "
+				 "info? On-disk pool param: %u:%u:%u:%u, "
+				 "Requested pool param: %u:%u:%u:%u",
+				 dest->pst_nr_nodes,
+				 dest->pst_nr_devices,
+				 dest->pst_max_node_failures,
+				 dest->pst_max_device_failures,
+				 src->pst_nr_nodes,
+				 src->pst_nr_devices,
+				 src->pst_max_node_failures,
+				 src->pst_max_device_failures);
+		return -EINVAL;
 	}
-	rc = store_into_db(&pm->pm_table, tx,
-			   &poolmach_device_state_key,
-			   sizeof poolmach_device_state_key,
-			   pooldev_rec,
-			   nr_devices * sizeof (*pooldev_rec));
-	if (rc != 0)
-		goto out_free;
 
-	for (i = 0; i < max_device_failures; i++) {
-		pool_spare_usage_rec[i].psu_device_index =
-			pm->pm_state.pst_spare_usage_array[i].psu_device_index;
-		pool_spare_usage_rec[i].psu_device_state =
-			pm->pm_state.pst_spare_usage_array[i].psu_device_state;
-	}
-	rc = store_into_db(&pm->pm_table, tx,
-			   &poolmach_spare_key,
-			   sizeof poolmach_spare_key,
-			   pool_spare_usage_rec,
-			   max_device_failures * sizeof (*pool_spare_usage_rec));
-
-out_free:
-	m0_free(poolnode_rec);
-	m0_free(pooldev_rec);
-	m0_free(pool_spare_usage_rec);
+	dest->pst_version             = src->pst_version;
+	dest->pst_nr_nodes            = src->pst_nr_nodes;
+	dest->pst_nr_devices          = src->pst_nr_devices;
+	dest->pst_max_node_failures   = src->pst_max_node_failures;
+	dest->pst_max_device_failures = src->pst_max_device_failures;
+	memcpy(dest->pst_nodes_array, src->pst_nodes_array,
+	       sizeof(struct m0_poolnode) * src->pst_nr_nodes);
+	memcpy(dest->pst_devices_array, src->pst_devices_array,
+	       sizeof(struct m0_pooldev) * src->pst_nr_devices);
+	memcpy(dest->pst_spare_usage_array, src->pst_spare_usage_array,
+	       sizeof(struct m0_pool_spare_usage)*src->pst_max_device_failures);
 	return rc;
 }
 
-static int m0_poolmach_load(struct m0_poolmach *pm,
-			    struct m0_dbenv    *dbenv,
-			    struct m0_db_tx    *tx,
-			    uint32_t            nr_nodes,
-			    uint32_t            nr_devices,
-			    uint32_t            max_node_failures,
-			    uint32_t            max_device_failures)
+static int m0_poolmach_load(struct m0_poolmach       *pm,
+			    struct m0_poolmach_state *pm_state_on_disk,
+			    uint32_t                  nr_nodes,
+			    uint32_t                  nr_devices,
+			    uint32_t                  max_node_failures,
+			    uint32_t                  max_device_failures)
 {
-	struct m0_poolmach_state_rec    poolmach_rec;
-	struct m0_poolnode_rec         *poolnode_rec;
-	struct m0_pooldev_rec          *pooldev_rec;
-	struct m0_pool_spare_usage_rec *pool_spare_usage_rec;
-	uint32_t                        i;
-	int                             rc;
-
-	M0_ALLOC_ARR(poolnode_rec, nr_nodes);
-	M0_ALLOC_ARR(pooldev_rec, nr_devices + 1);
-	M0_ALLOC_ARR(pool_spare_usage_rec, max_device_failures);
-	if (poolnode_rec == NULL ||
-	    pooldev_rec == NULL ||
-	    pool_spare_usage_rec == NULL) {
-		/* m0_free(NULL) is OK */
-		rc = -ENOMEM;
-		goto out_free;
-	}
-
-	rc = load_from_db(&pm->pm_table, tx,
-			  &poolmach_state_key, sizeof poolmach_state_key,
-			  &poolmach_rec, sizeof poolmach_rec);
-	if (rc != 0)
-		goto out_free;
-
-	if (poolmach_rec.psr_nr_nodes != nr_nodes ||
-	    poolmach_rec.psr_nr_devices != nr_devices + 1 ||
-	    poolmach_rec.psr_max_node_failures != max_node_failures ||
-	    poolmach_rec.psr_max_device_failures != max_device_failures) {
-		M0_LOG(M0_ERROR, "Pool Machine persistent state doesn't match");
-		rc = -ESTALE;
-		goto out_free;
-	}
-	pm->pm_state.pst_version = poolmach_rec.psr_version;
-
-	rc = load_from_db(&pm->pm_table, tx,
-			  &poolmach_node_state_key,
-			  sizeof poolmach_node_state_key,
-			  poolnode_rec,
-			  nr_nodes * sizeof (*poolnode_rec));
-	if (rc != 0)
-		goto out_free;
-
-	rc = load_from_db(&pm->pm_table, tx,
-			  &poolmach_device_state_key,
-			  sizeof poolmach_device_state_key,
-			  pooldev_rec,
-			  (nr_devices + 1) * sizeof (*pooldev_rec));
-	if (rc != 0)
-		goto out_free;
-
-	rc = load_from_db(&pm->pm_table, tx,
-			  &poolmach_spare_key,
-			  sizeof poolmach_spare_key,
-			  pool_spare_usage_rec,
-			  max_device_failures * sizeof (*pool_spare_usage_rec));
-	if (rc != 0)
-		goto out_free;
-
-	for (i = 0; i < nr_nodes; i++) {
-		pm->pm_state.pst_nodes_array[i].pn_state =
-						poolnode_rec[i].pn_state;
-	}
-
-	for (i = 0; i < nr_devices; i++) {
-		pm->pm_state.pst_devices_array[i].pd_state =
-						pooldev_rec[i].pd_state;
-	}
-
-	for (i = 0; i < max_device_failures; i++) {
-		pm->pm_state.pst_spare_usage_array[i].psu_device_index =
-				pool_spare_usage_rec[i].psu_device_index;
-		pm->pm_state.pst_spare_usage_array[i].psu_device_state =
-				pool_spare_usage_rec[i].psu_device_state;
+	struct m0_poolmach_state *dest = &pm->pm_state;
+	int rc = 0;
+	
+	if (pm_state_on_disk->pst_nr_nodes != nr_nodes ||
+	    pm_state_on_disk->pst_nr_devices != nr_devices ||
+	    pm_state_on_disk->pst_max_node_failures != max_node_failures ||
+	    pm_state_on_disk->pst_max_device_failures != max_device_failures) {
+		M0_LOG(M0_FATAL, "Invalid pool configuration. Using stale pool "
+				 "info? On-disk pool param: %u:%u:%u:%u, "
+				 "Requested pool param: %u:%u:%u:%u",
+				 pm_state_on_disk->pst_nr_nodes,
+				 pm_state_on_disk->pst_nr_devices,
+				 pm_state_on_disk->pst_max_node_failures,
+				 pm_state_on_disk->pst_max_device_failures,
+				 nr_nodes,
+				 nr_devices,
+				 max_node_failures,
+				 max_device_failures);
+		return -EINVAL;
 	}
 
-	rc = m0_poolmach_events_load(pm, tx);
-out_free:
-	m0_free(poolnode_rec);
-	m0_free(pooldev_rec);
-	m0_free(pool_spare_usage_rec);
+	dest->pst_version             = pm_state_on_disk->pst_version;
+	dest->pst_nr_nodes            = pm_state_on_disk->pst_nr_nodes;
+	dest->pst_nr_devices          = pm_state_on_disk->pst_nr_devices;
+	dest->pst_max_node_failures   = pm_state_on_disk->pst_max_node_failures;
+	dest->pst_max_device_failures = pm_state_on_disk->pst_max_device_failures;
+	memcpy(dest->pst_nodes_array, pm_state_on_disk->pst_nodes_array,
+	       sizeof(struct m0_poolnode) * nr_nodes);
+	memcpy(dest->pst_devices_array, pm_state_on_disk->pst_devices_array,
+	       sizeof(struct m0_pooldev) * nr_devices);
+	memcpy(dest->pst_spare_usage_array, pm_state_on_disk->pst_spare_usage_array,
+	       sizeof(struct m0_pool_spare_usage) * max_device_failures);
+	m0_poolmach_events_load(pm, pm_state_on_disk);
 	return rc;
 }
 
 M0_INTERNAL int m0_poolmach_store_init(struct m0_poolmach *pm,
-				       struct m0_dbenv    *dbenv,
+				       struct m0_be_seg   *be_seg,
+				       struct m0_sm_group *sm_grp,
 				       struct m0_dtm      *dtm,
 				       uint32_t            nr_nodes,
 				       uint32_t            nr_devices,
 				       uint32_t            max_node_failures,
 				       uint32_t            max_device_failures)
 {
-	struct m0_db_tx                 init_tx;
-	int                             rc;
+	struct m0_be_tx_credit      cred = {};
+	struct m0_be_tx            *tx;
+	struct m0_poolmach_state   *pm_state_on_disk;
+	struct m0_poolnode         *nodes_array;
+	struct m0_pooldev          *devices_array;
+	struct m0_pool_spare_usage *spare_usage_array;
+	const char                 *poolmach_name = "poolmach_state";
+	int                         rc;
 
 	M0_PRE(!pm->pm_is_initialised);
-	M0_PRE(dbenv != NULL);
+	M0_PRE(be_seg != NULL);
 	M0_ENTRY();
 
-	rc = m0_table_init(&pm->pm_table, dbenv,
-			   "poolmach_persistent_state", 0,
-			   &m0_poolmach_store_ops);
-	if (rc != 0)
-		M0_RETURN(rc);
-
-	rc = m0_table_init(&pm->pm_events_table, dbenv,
-			   "poolmach_events", 0,
-			   &m0_poolmach_events_table_ops);
-	if (rc != 0) {
-		m0_table_fini(&pm->pm_table);
-		M0_RETURN(rc);
-	}
+	M0_ALLOC_PTR(tx);
+	if (tx == NULL)
+		return -ENOMEM;
 
-	rc = m0_db_tx_init(&init_tx, dbenv, 0);
-	if (rc != 0) {
-		m0_table_fini(&pm->pm_table);
-		m0_table_fini(&pm->pm_events_table);
-		M0_RETURN(rc);
-	}
+	rc = m0_be_seg_dict_lookup(be_seg, poolmach_name, (void**)&pm_state_on_disk);
+	if (rc == 0) {
+		rc = m0_poolmach_load(pm, pm_state_on_disk, nr_nodes, nr_devices,
+				      max_node_failures, max_device_failures);
+		goto out;
+	} else if (rc != -ENOENT)
+		goto out;
 
-	rc = m0_poolmach_load(pm, dbenv, &init_tx, nr_nodes, nr_devices,
-			      max_node_failures, max_device_failures);
-	if (rc == -ENOENT) {
-		rc = m0_poolmach_store(pm, &init_tx);
-	}
-	if (rc == 0)
-		rc = m0_db_tx_commit(&init_tx);
-	else
-		m0_db_tx_abort(&init_tx);
-
-	if (rc != 0) {
-		m0_table_fini(&pm->pm_table);
-		m0_table_fini(&pm->pm_events_table);
+	/* Not found from disk. Let's allocate and insert it */
+	m0_sm_group_lock(sm_grp);
+	m0_be_tx_init(tx, 0, be_seg->bs_domain, sm_grp, NULL, NULL, NULL, NULL);
+	M0_BE_ALLOC_CREDIT_PTR(pm_state_on_disk, be_seg, &cred);
+	M0_BE_ALLOC_CREDIT_ARR(nodes_array, nr_nodes, be_seg, &cred);
+	M0_BE_ALLOC_CREDIT_ARR(devices_array, nr_devices, be_seg, &cred);
+	M0_BE_ALLOC_CREDIT_ARR(spare_usage_array, max_device_failures, be_seg, &cred);
+	m0_be_seg_dict_insert_credit(be_seg, poolmach_name, &cred);
+	m0_be_tx_prep(tx, &cred);
+	rc = m0_be_tx_open_sync(tx);
+	if (rc == 0) {
+		M0_BE_ALLOC_PTR_SYNC(pm_state_on_disk, be_seg, tx);
+		M0_BE_ALLOC_ARR_SYNC(nodes_array, nr_nodes, be_seg, tx);
+		M0_BE_ALLOC_ARR_SYNC(devices_array, nr_devices, be_seg, tx);
+		M0_BE_ALLOC_ARR_SYNC(spare_usage_array, max_device_failures, be_seg, tx);
+		M0_ASSERT(pm_state_on_disk != NULL);
+		M0_ASSERT(nodes_array != NULL);
+		M0_ASSERT(devices_array != NULL);
+		M0_ASSERT(spare_usage_array != NULL);
+
+		rc = m0_be_seg_dict_insert(be_seg, tx, poolmach_name,
+					   pm_state_on_disk);
+		M0_ASSERT(rc == 0);
+		*pm_state_on_disk = pm->pm_state;
+		pm_state_on_disk->pst_nodes_array = nodes_array;
+		pm_state_on_disk->pst_devices_array = devices_array;
+		pm_state_on_disk->pst_spare_usage_array = spare_usage_array;
+		poolmach_events_tlist_init(&pm_state_on_disk->pst_events_list);
+		memcpy(nodes_array, pm->pm_state.pst_nodes_array,
+		       sizeof(nodes_array) * nr_nodes);
+		memcpy(devices_array, pm->pm_state.pst_devices_array,
+		       sizeof(devices_array) * nr_devices);
+		memcpy(spare_usage_array, pm->pm_state.pst_spare_usage_array,
+		       sizeof(spare_usage_array) * max_device_failures);
+
+		M0_BE_TX_CAPTURE_PTR(be_seg, tx, pm_state_on_disk);
+		M0_BE_TX_CAPTURE_ARR(be_seg, tx, nodes_array, nr_nodes);
+		M0_BE_TX_CAPTURE_ARR(be_seg, tx, devices_array, nr_devices);
+		M0_BE_TX_CAPTURE_ARR(be_seg, tx, spare_usage_array, max_device_failures);
+		m0_be_tx_close_sync(tx);
 	}
+
+	m0_be_tx_fini(tx);
+	m0_sm_group_unlock(sm_grp);
+
+out:
+	m0_free(tx);
 	return rc;
 }
 
+#else
+
+M0_INTERNAL int m0_poolmach_event_store(struct m0_poolmach *pm,
+					struct m0_be_tx *tx,
+					struct m0_pool_event_link *event_link)
+{
+	return 0;
+}
+
+
+M0_INTERNAL int m0_poolmach_store(struct m0_poolmach *pm,
+				  struct m0_be_tx *tx)
+{
+	return 0;
+}
+
+M0_INTERNAL int m0_poolmach_store_init(struct m0_poolmach *pm,
+				       struct m0_be_seg   *be_seg,
+				       struct m0_sm_group *sm_grp,
+				       struct m0_dtm      *dtm,
+				       uint32_t            nr_nodes,
+				       uint32_t            nr_devices,
+				       uint32_t            max_node_failures,
+				       uint32_t            max_device_failures)
+{
+	return 0;
+}
+
+#endif
+
 #undef M0_TRACE_SUBSYSTEM
 /** @} end group pool */
 
diff --git a/pool/ut/test_pm.c b/pool/ut/test_pm.c
index d4c716a..790d4ea 100644
--- a/pool/ut/test_pm.c
+++ b/pool/ut/test_pm.c
@@ -30,6 +30,8 @@ enum {
 	PM_TEST_DEFAULT_MAX_NODE_FAILURE   = 1
 };
 static struct m0_dbenv dbenv;
+static struct m0_be_seg beseg;
+struct m0_sm_group     *sm_grp = NULL;
 static struct m0_db_tx tx;
 
 static void pm_test_init_fini(void)
@@ -40,7 +42,7 @@ static void pm_test_init_fini(void)
 	rc = m0_dbenv_init(&dbenv, "pm_testing", 0);
 	M0_ASSERT(rc == 0);
 	M0_SET0(&pm);
-	rc = m0_poolmach_init(&pm, &dbenv, NULL, PM_TEST_DEFAULT_NODE_NUMBER,
+	rc = m0_poolmach_init(&pm, &beseg, sm_grp, NULL, PM_TEST_DEFAULT_NODE_NUMBER,
 					 PM_TEST_DEFAULT_DEVICE_NUMBER,
 					 PM_TEST_DEFAULT_MAX_NODE_FAILURE,
 					 PM_TEST_DEFAULT_MAX_DEVICE_FAILURE);
@@ -70,7 +72,7 @@ static void pm_test_transit(void)
 	rc = m0_db_tx_init(&tx, &dbenv, 0);
 	M0_UT_ASSERT(rc == 0);
 	M0_SET0(&pm);
-	rc = m0_poolmach_init(&pm, &dbenv, NULL, PM_TEST_DEFAULT_NODE_NUMBER,
+	rc = m0_poolmach_init(&pm, &beseg, sm_grp, NULL, PM_TEST_DEFAULT_NODE_NUMBER,
 					 PM_TEST_DEFAULT_DEVICE_NUMBER,
 					 PM_TEST_DEFAULT_MAX_NODE_FAILURE,
 					 PM_TEST_DEFAULT_MAX_DEVICE_FAILURE);
@@ -91,13 +93,13 @@ static void pm_test_transit(void)
 	events[0].pe_type  = M0_POOL_DEVICE;
 	events[0].pe_index = 1;
 	events[0].pe_state = M0_PNDS_FAILED;
-	rc = m0_poolmach_state_transit(&pm, &events[0], &tx);
+	rc = m0_poolmach_state_transit(&pm, &events[0], NULL);
 	M0_UT_ASSERT(rc == 0);
 
 	events[1].pe_type  = M0_POOL_DEVICE;
 	events[1].pe_index = 3;
 	events[1].pe_state = M0_PNDS_OFFLINE;
-	rc = m0_poolmach_state_transit(&pm, &events[1], &tx);
+	rc = m0_poolmach_state_transit(&pm, &events[1], NULL);
 	M0_UT_ASSERT(rc == 0);
 
 	rc = m0_poolmach_current_version_get(&pm, &v1);
@@ -106,13 +108,13 @@ static void pm_test_transit(void)
 	events[2].pe_type  = M0_POOL_DEVICE;
 	events[2].pe_index = 3;
 	events[2].pe_state = M0_PNDS_ONLINE;
-	rc = m0_poolmach_state_transit(&pm, &events[2], &tx);
+	rc = m0_poolmach_state_transit(&pm, &events[2], NULL);
 	M0_UT_ASSERT(rc == 0);
 
 	events[3].pe_type  = M0_POOL_NODE;
 	events[3].pe_index = 0;
 	events[3].pe_state = M0_PNDS_OFFLINE;
-	rc = m0_poolmach_state_transit(&pm, &events[3], &tx);
+	rc = m0_poolmach_state_transit(&pm, &events[3], NULL);
 	M0_UT_ASSERT(rc == 0);
 
 	rc = m0_poolmach_current_version_get(&pm, &v2);
@@ -328,28 +330,28 @@ static void pm_test_transit(void)
 	e_invalid.pe_type  = M0_POOL_NODE + 5;
 	e_invalid.pe_index = 0;
 	e_invalid.pe_state = M0_PNDS_OFFLINE;
-	rc = m0_poolmach_state_transit(&pm, &e_invalid, &tx);
+	rc = m0_poolmach_state_transit(&pm, &e_invalid, NULL);
 	M0_UT_ASSERT(rc == -EINVAL);
 
 	/* invalid event. case 2: invalid index */
 	e_invalid.pe_type  = M0_POOL_NODE;
 	e_invalid.pe_index = 100;
 	e_invalid.pe_state = M0_PNDS_OFFLINE;
-	rc = m0_poolmach_state_transit(&pm, &e_invalid, &tx);
+	rc = m0_poolmach_state_transit(&pm, &e_invalid, NULL);
 	M0_UT_ASSERT(rc == -EINVAL);
 
 	/* invalid event. case 3: invalid state */
 	e_invalid.pe_type  = M0_POOL_NODE;
 	e_invalid.pe_index = 0;
 	e_invalid.pe_state = M0_PNDS_SNS_REBALANCING + 1;
-	rc = m0_poolmach_state_transit(&pm, &e_invalid, &tx);
+	rc = m0_poolmach_state_transit(&pm, &e_invalid, NULL);
 	M0_UT_ASSERT(rc == -EINVAL);
 
 	/* invalid event. case 4: invalid state */
 	e_invalid.pe_type  = M0_POOL_DEVICE;
 	e_invalid.pe_index = 0;
 	e_invalid.pe_state = M0_PNDS_NR;
-	rc = m0_poolmach_state_transit(&pm, &e_invalid, &tx);
+	rc = m0_poolmach_state_transit(&pm, &e_invalid, NULL);
 	M0_UT_ASSERT(rc == -EINVAL);
 
 	/* finally */
@@ -373,7 +375,7 @@ static void pm_test_spare_slot(void)
 	rc = m0_db_tx_init(&tx, &dbenv, 0);
 	M0_UT_ASSERT(rc == 0);
 	M0_SET0(&pm);
-	rc = m0_poolmach_init(&pm, &dbenv, NULL, PM_TEST_DEFAULT_NODE_NUMBER,
+	rc = m0_poolmach_init(&pm, &beseg, sm_grp, NULL, PM_TEST_DEFAULT_NODE_NUMBER,
 					 PM_TEST_DEFAULT_DEVICE_NUMBER,
 					 PM_TEST_DEFAULT_MAX_NODE_FAILURE,
 					 2 /* two spare device */);
@@ -386,7 +388,7 @@ static void pm_test_spare_slot(void)
 	/* FAILED */
 	target_state = M0_PNDS_FAILED;
 	event.pe_state = target_state;
-	rc = m0_poolmach_state_transit(&pm, &event, &tx);
+	rc = m0_poolmach_state_transit(&pm, &event, NULL);
 	M0_UT_ASSERT(rc == 0);
 	rc = m0_poolmach_device_state(&pm, 1, &state_out);
 	M0_UT_ASSERT(rc == 0);
@@ -406,7 +408,7 @@ static void pm_test_spare_slot(void)
 			continue;
 		/* transit to other state other than the above one is invalid */
 		event.pe_state = state;
-		rc = m0_poolmach_state_transit(&pm, &event, &tx);
+		rc = m0_poolmach_state_transit(&pm, &event, NULL);
 		M0_UT_ASSERT(rc == -EINVAL);
 	}
 
@@ -418,7 +420,7 @@ static void pm_test_spare_slot(void)
 	/* transit to SNS_REPAIRING */
 	target_state = M0_PNDS_SNS_REPAIRING;
 	event.pe_state = target_state;
-	rc = m0_poolmach_state_transit(&pm, &event, &tx);
+	rc = m0_poolmach_state_transit(&pm, &event, NULL);
 	M0_UT_ASSERT(rc == 0);
 	rc = m0_poolmach_device_state(&pm, 1, &state_out);
 	M0_UT_ASSERT(rc == 0);
@@ -435,7 +437,7 @@ static void pm_test_spare_slot(void)
 			continue;
 		/* transit to other state other than the above one is invalid */
 		event.pe_state = state;
-		rc = m0_poolmach_state_transit(&pm, &event, &tx);
+		rc = m0_poolmach_state_transit(&pm, &event, NULL);
 		M0_UT_ASSERT(rc == -EINVAL);
 	}
 
@@ -443,7 +445,7 @@ static void pm_test_spare_slot(void)
 	/* transit to SNS_REPAIRED */
 	target_state = M0_PNDS_SNS_REPAIRED;
 	event.pe_state = target_state;
-	rc = m0_poolmach_state_transit(&pm, &event, &tx);
+	rc = m0_poolmach_state_transit(&pm, &event, NULL);
 	M0_UT_ASSERT(rc == 0);
 	rc = m0_poolmach_device_state(&pm, 1, &state_out);
 	M0_UT_ASSERT(rc == 0);
@@ -460,7 +462,7 @@ static void pm_test_spare_slot(void)
 			continue;
 		/* transit to other state other than the above one is invalid */
 		event.pe_state = state;
-		rc = m0_poolmach_state_transit(&pm, &event, &tx);
+		rc = m0_poolmach_state_transit(&pm, &event, NULL);
 		M0_UT_ASSERT(rc == -EINVAL);
 	}
 
@@ -468,7 +470,7 @@ static void pm_test_spare_slot(void)
 	/* transit to SNS_REBALANCING */
 	target_state = M0_PNDS_SNS_REBALANCING;
 	event.pe_state = target_state;
-	rc = m0_poolmach_state_transit(&pm, &event, &tx);
+	rc = m0_poolmach_state_transit(&pm, &event, NULL);
 	M0_UT_ASSERT(rc == 0);
 	rc = m0_poolmach_device_state(&pm, 1, &state_out);
 	M0_UT_ASSERT(rc == 0);
@@ -482,14 +484,14 @@ static void pm_test_spare_slot(void)
 			continue;
 		/* transit to other state other than the above one is invalid */
 		event.pe_state = state;
-		rc = m0_poolmach_state_transit(&pm, &event, &tx);
+		rc = m0_poolmach_state_transit(&pm, &event, NULL);
 		M0_UT_ASSERT(rc == -EINVAL);
 	}
 
 	/* transit to ONLINE */
 	target_state = M0_PNDS_ONLINE;
 	event.pe_state = target_state;
-	rc = m0_poolmach_state_transit(&pm, &event, &tx);
+	rc = m0_poolmach_state_transit(&pm, &event, NULL);
 	M0_UT_ASSERT(rc == 0);
 	rc = m0_poolmach_device_state(&pm, 1, &state_out);
 	M0_UT_ASSERT(rc == 0);
@@ -518,7 +520,7 @@ static void pm_test_multi_fail(void)
 	rc = m0_db_tx_init(&tx, &dbenv, 0);
 	M0_UT_ASSERT(rc == 0);
 	M0_SET0(&pm);
-	rc = m0_poolmach_init(&pm, &dbenv, NULL, PM_TEST_DEFAULT_NODE_NUMBER,
+	rc = m0_poolmach_init(&pm, &beseg, sm_grp, NULL, PM_TEST_DEFAULT_NODE_NUMBER,
 					 PM_TEST_DEFAULT_DEVICE_NUMBER,
 					 PM_TEST_DEFAULT_MAX_NODE_FAILURE,
 					 3 /*three spare device */);
@@ -531,7 +533,7 @@ static void pm_test_multi_fail(void)
 	event.pe_index = 1;
 	target_state = M0_PNDS_FAILED;
 	event.pe_state = target_state;
-	rc = m0_poolmach_state_transit(&pm, &event, &tx);
+	rc = m0_poolmach_state_transit(&pm, &event, NULL);
 	M0_UT_ASSERT(rc == 0);
 	rc = m0_poolmach_device_state(&pm, 1, &state_out);
 	M0_UT_ASSERT(rc == 0);
@@ -541,7 +543,7 @@ static void pm_test_multi_fail(void)
 	event.pe_index = 2;
 	target_state = M0_PNDS_FAILED;
 	event.pe_state = target_state;
-	rc = m0_poolmach_state_transit(&pm, &event, &tx);
+	rc = m0_poolmach_state_transit(&pm, &event, NULL);
 	M0_UT_ASSERT(rc == 0);
 	rc = m0_poolmach_device_state(&pm, 2, &state_out);
 	M0_UT_ASSERT(rc == 0);
@@ -551,7 +553,7 @@ static void pm_test_multi_fail(void)
 	event.pe_index = 1;
 	target_state = M0_PNDS_SNS_REPAIRING;
 	event.pe_state = target_state;
-	rc = m0_poolmach_state_transit(&pm, &event, &tx);
+	rc = m0_poolmach_state_transit(&pm, &event, NULL);
 	M0_UT_ASSERT(rc == 0);
 	/* the first spare slot is used by device 1 */
 	rc = m0_poolmach_sns_repair_spare_query(&pm, 1, &spare_slot);
@@ -562,7 +564,7 @@ static void pm_test_multi_fail(void)
 	event.pe_index = 2;
 	target_state = M0_PNDS_SNS_REPAIRING;
 	event.pe_state = target_state;
-	rc = m0_poolmach_state_transit(&pm, &event, &tx);
+	rc = m0_poolmach_state_transit(&pm, &event, NULL);
 	M0_UT_ASSERT(rc == 0);
 	/* the second spare slot is used by device 2 */
 	rc = m0_poolmach_sns_repair_spare_query(&pm, 2, &spare_slot);
@@ -574,7 +576,7 @@ static void pm_test_multi_fail(void)
 	event.pe_index = 1;
 	target_state = M0_PNDS_SNS_REPAIRED;
 	event.pe_state = target_state;
-	rc = m0_poolmach_state_transit(&pm, &event, &tx);
+	rc = m0_poolmach_state_transit(&pm, &event, NULL);
 	M0_UT_ASSERT(rc == 0);
 	/* the first spare slot is used by device 1 */
 	rc = m0_poolmach_sns_repair_spare_query(&pm, 1, &spare_slot);
@@ -585,7 +587,7 @@ static void pm_test_multi_fail(void)
 	event.pe_index = 2;
 	target_state = M0_PNDS_SNS_REPAIRED;
 	event.pe_state = target_state;
-	rc = m0_poolmach_state_transit(&pm, &event, &tx);
+	rc = m0_poolmach_state_transit(&pm, &event, NULL);
 	M0_UT_ASSERT(rc == 0);
 	/* the second spare slot is used by device 2 */
 	rc = m0_poolmach_sns_repair_spare_query(&pm, 2, &spare_slot);
@@ -597,7 +599,7 @@ static void pm_test_multi_fail(void)
 	event.pe_index = 1;
 	target_state = M0_PNDS_SNS_REBALANCING;
 	event.pe_state = target_state;
-	rc = m0_poolmach_state_transit(&pm, &event, &tx);
+	rc = m0_poolmach_state_transit(&pm, &event, NULL);
 	M0_UT_ASSERT(rc == 0);
 	/* the first spare slot is used by device 1 */
 	rc = m0_poolmach_sns_rebalance_spare_query(&pm, 1, &spare_slot);
@@ -608,7 +610,7 @@ static void pm_test_multi_fail(void)
 	event.pe_index = 2;
 	target_state = M0_PNDS_SNS_REBALANCING;
 	event.pe_state = target_state;
-	rc = m0_poolmach_state_transit(&pm, &event, &tx);
+	rc = m0_poolmach_state_transit(&pm, &event, NULL);
 	M0_UT_ASSERT(rc == 0);
 	/* the second spare slot is used by device 2 */
 	rc = m0_poolmach_sns_rebalance_spare_query(&pm, 2, &spare_slot);
@@ -620,7 +622,7 @@ static void pm_test_multi_fail(void)
 	event.pe_index = 2;
 	target_state = M0_PNDS_ONLINE;
 	event.pe_state = target_state;
-	rc = m0_poolmach_state_transit(&pm, &event, &tx);
+	rc = m0_poolmach_state_transit(&pm, &event, NULL);
 	M0_UT_ASSERT(rc == 0);
 	rc = m0_poolmach_sns_repair_spare_query(&pm, 2, &spare_slot);
 	M0_UT_ASSERT(rc == -ENOENT);
@@ -629,11 +631,11 @@ static void pm_test_multi_fail(void)
 	event.pe_index = 3;
 	target_state = M0_PNDS_FAILED;
 	event.pe_state = target_state;
-	rc = m0_poolmach_state_transit(&pm, &event, &tx);
+	rc = m0_poolmach_state_transit(&pm, &event, NULL);
 	M0_UT_ASSERT(rc == 0);
 	target_state = M0_PNDS_SNS_REPAIRING;
 	event.pe_state = target_state;
-	rc = m0_poolmach_state_transit(&pm, &event, &tx);
+	rc = m0_poolmach_state_transit(&pm, &event, NULL);
 	M0_UT_ASSERT(rc == 0);
 	rc = m0_poolmach_sns_repair_spare_query(&pm, 3, &spare_slot);
 	M0_UT_ASSERT(rc == 0);
@@ -643,7 +645,7 @@ static void pm_test_multi_fail(void)
 	event.pe_index = 1;
 	target_state = M0_PNDS_ONLINE;
 	event.pe_state = target_state;
-	rc = m0_poolmach_state_transit(&pm, &event, &tx);
+	rc = m0_poolmach_state_transit(&pm, &event, NULL);
 	M0_UT_ASSERT(rc == 0);
 	rc = m0_poolmach_sns_repair_spare_query(&pm, 1, &spare_slot);
 	M0_UT_ASSERT(rc == -ENOENT);
@@ -652,11 +654,11 @@ static void pm_test_multi_fail(void)
 	event.pe_index = 4;
 	target_state = M0_PNDS_FAILED;
 	event.pe_state = target_state;
-	rc = m0_poolmach_state_transit(&pm, &event, &tx);
+	rc = m0_poolmach_state_transit(&pm, &event, NULL);
 	M0_UT_ASSERT(rc == 0);
 	target_state = M0_PNDS_SNS_REPAIRING;
 	event.pe_state = target_state;
-	rc = m0_poolmach_state_transit(&pm, &event, &tx);
+	rc = m0_poolmach_state_transit(&pm, &event, NULL);
 	M0_UT_ASSERT(rc == 0);
 	rc = m0_poolmach_sns_repair_spare_query(&pm, 4, &spare_slot);
 	M0_UT_ASSERT(rc == 0);
@@ -677,7 +679,7 @@ static void pm_test_load_from_persistent_storage(void)
 	rc = m0_dbenv_init(&dbenv, "pm_test_multi_fail", 0);
 	M0_ASSERT(rc == 0);
 	M0_SET0(&pm);
-	rc = m0_poolmach_init(&pm, &dbenv, NULL, PM_TEST_DEFAULT_NODE_NUMBER,
+	rc = m0_poolmach_init(&pm, &beseg, sm_grp, NULL, PM_TEST_DEFAULT_NODE_NUMBER,
 					 PM_TEST_DEFAULT_DEVICE_NUMBER,
 					 PM_TEST_DEFAULT_MAX_NODE_FAILURE,
 					 3);
diff --git a/sns/cm/cm.c b/sns/cm/cm.c
index 075c5d8..a2c1488 100644
--- a/sns/cm/cm.c
+++ b/sns/cm/cm.c
@@ -560,7 +560,7 @@ M0_INTERNAL int m0_sns_cm_pm_event_post(struct m0_sns_cm *scm,
 			pme.pe_index = dev_id;
 			pme.pe_state = state;
 			rc = m0_poolmach_state_transit(scm->sc_base.cm_pm, &pme,
-						       &tx);
+						       NULL);
 			m0_db_tx_commit(&tx);
 			if (rc != 0)
 				break;
diff --git a/sns/cm/repair/ut/cm.c b/sns/cm/repair/ut/cm.c
index 0e5dc30..e8426bb 100644
--- a/sns/cm/repair/ut/cm.c
+++ b/sns/cm/repair/ut/cm.c
@@ -97,7 +97,7 @@ static void pool_mach_transit(struct m0_poolmach *pm, uint64_t fd,
         rc = m0_db_tx_init(&tx, scm->sc_it.si_dbenv, 0);
 	M0_UT_ASSERT(rc == 0);
 	rc = m0_poolmach_state_transit(cm->cm_pm, &pme,
-				       &tx);
+				       NULL);
 	M0_UT_ASSERT(rc == 0);
 	m0_db_tx_commit(&tx);
 }
-- 
1.8.3.2

