From 3e04201fc1becde5dbdee5907e8c75356a4aacb1 Mon Sep 17 00:00:00 2001
From: Hua Huang <hua_huang@xyratex.com>
Date: Fri, 13 Dec 2013 19:29:57 +0800
Subject: [PATCH 02/11] combine store() and store_event(). new interface for
 credit.

---
 pool/pool.c       | 14 +++++---------
 pool/pool_store.c | 58 +++++++++++++++++++++++++++++++++++++++++--------------
 2 files changed, 48 insertions(+), 24 deletions(-)

diff --git a/pool/pool.c b/pool/pool.c
index 301eca1..e4fcd8c 100644
--- a/pool/pool.c
+++ b/pool/pool.c
@@ -193,11 +193,9 @@ M0_INTERNAL int m0_poolmach_store_init(struct m0_poolmach *pm,
 				       uint32_t            nr_devices,
 				       uint32_t            max_node_failures,
 				       uint32_t            max_device_failures);
-M0_INTERNAL int m0_poolmach_store(struct m0_poolmach *pm,
-				  struct m0_be_tx    *tx);
-M0_INTERNAL int m0_poolmach_event_store(struct m0_poolmach *pm,
-					struct m0_be_tx    *tx,
-					struct m0_pool_event_link *event_link);
+M0_INTERNAL int m0_poolmach_store(struct m0_poolmach        *pm,
+				  struct m0_be_tx           *tx,
+				  struct m0_pool_event_link *event_link);
 
 M0_TL_DESCR_DEFINE(poolmach_events, "pool machine events list", M0_INTERNAL,
                    struct m0_pool_event_link, pel_linkage, pel_magic,
@@ -322,7 +320,7 @@ M0_INTERNAL int m0_poolmach_init(struct m0_poolmach *pm,
 	poolmach_events_tlist_init(&pm->pm_state.pst_events_list);
 	m0_rwlock_init(&pm->pm_lock);
 	if (be_seg != NULL) {
-		/* On client, dbenv is NULL */
+		/* On client, be_seg is NULL. On server,  be_seg must be valid*/
 		rc = m0_poolmach_store_init(pm, be_seg, sm_grp, dtm, nr_nodes,
 					    nr_devices, max_node_failures,
 					    max_device_failures);
@@ -537,9 +535,7 @@ M0_INTERNAL int m0_poolmach_state_transit(struct m0_poolmach   *pm,
 	if (pm->pm_be_seg != NULL) {
 		/* This poolmach is on server. Update to persistent storage. */
 		M0_ASSERT(tx != NULL);
-		rc = m0_poolmach_store(pm, tx);
-		if (rc == 0)
-			rc = m0_poolmach_event_store(pm, tx, event_link);
+		rc = m0_poolmach_store(pm, tx, event_link);
 	}
 
 out_unlock:
diff --git a/pool/pool_store.c b/pool/pool_store.c
index 0f38718..7d4a37f 100644
--- a/pool/pool_store.c
+++ b/pool/pool_store.c
@@ -85,29 +85,42 @@ static void m0_poolmach_events_load(struct m0_poolmach *pm,
 }
 
 
-M0_INTERNAL int m0_poolmach_event_store(struct m0_poolmach *pm,
-					struct m0_be_tx *tx,
-					struct m0_pool_event_link *event_link)
+M0_INTERNAL void m0_poolmach_store_credit(struct m0_poolmach        *pm,
+					  struct m0_be_tx           *tx,
+					  struct m0_be_tx_credit *accum)
 {
-	int              rc = 0;
-
-	tx = NULL;
-	return rc;
+	struct m0_pool_event_link *event_link;
+
+	m0_be_tx_credit_add(accum, &M0_BE_TX_CREDIT_TYPE(pm->pm_state));
+	m0_be_tx_credit_add(accum,
+			    &M0_BE_TX_CREDIT(pm->pm_state.pst_nr_nodes,
+				sizeof (*pm->pm_state.pst_nodes_array)));
+	m0_be_tx_credit_add(accum,
+			    &M0_BE_TX_CREDIT(pm->pm_state.pst_nr_devices,
+				sizeof (*pm->pm_state.pst_devices_array)));
+	m0_be_tx_credit_add(accum,
+			&M0_BE_TX_CREDIT(pm->pm_state.pst_max_device_failures,
+				sizeof (*pm->pm_state.pst_spare_usage_array)));
+	M0_BE_ALLOC_CREDIT_PTR(event_link, pm->pm_be_seg, accum);
+	m0_be_tx_credit_add(accum, &M0_BE_TX_CREDIT_TYPE(*event_link));
+	m0_be_tx_credit_add(accum, &M0_BE_TX_CREDIT_TYPE(struct m0_tlink));
+	m0_be_tx_credit_add(accum, &M0_BE_TX_CREDIT_TYPE(struct m0_tlink));
 }
-
-
+	
 /**
  * Store all pool machine state and events into db.
  *
  * Existing records are overwritten.
  */
-M0_INTERNAL int m0_poolmach_store(struct m0_poolmach *pm,
-				  struct m0_be_tx *tx)
+M0_INTERNAL int m0_poolmach_store(struct m0_poolmach        *pm,
+				  struct m0_be_tx           *tx,
+				  struct m0_pool_event_link *event_link)
 {
-	struct m0_poolmach_state *src = &pm->pm_state;
-	struct m0_poolmach_state *dest;
-	const char               *poolmach_name = "poolmach_state";
-	int                       rc = 0;
+	struct m0_poolmach_state  *src = &pm->pm_state;
+	struct m0_poolmach_state  *dest;
+	const char                *poolmach_name = "poolmach_state";
+	struct m0_pool_event_link *new_link;
+	int                        rc = 0;
 	M0_ENTRY();
 
 	rc = m0_be_seg_dict_lookup(pm->pm_be_seg, poolmach_name, (void**)&dest);
@@ -131,6 +144,9 @@ M0_INTERNAL int m0_poolmach_store(struct m0_poolmach *pm,
 				 src->pst_max_device_failures);
 		return -EINVAL;
 	}
+	M0_BE_ALLOC_PTR_SYNC(new_link, pm->pm_be_seg, tx);
+	if (new_link == NULL)
+		return -ENOMEM;
 
 	dest->pst_version             = src->pst_version;
 	dest->pst_nr_nodes            = src->pst_nr_nodes;
@@ -143,6 +159,18 @@ M0_INTERNAL int m0_poolmach_store(struct m0_poolmach *pm,
 	       sizeof(struct m0_pooldev) * src->pst_nr_devices);
 	memcpy(dest->pst_spare_usage_array, src->pst_spare_usage_array,
 	       sizeof(struct m0_pool_spare_usage)*src->pst_max_device_failures);
+
+	*new_link = *event_link;
+	poolmach_events_tlink_init_at_tail(new_link, &dest->pst_events_list);
+
+
+	M0_BE_TX_CAPTURE_PTR(pm->pm_be_seg, tx, dest);
+	M0_BE_TX_CAPTURE_ARR(pm->pm_be_seg, tx, dest->pst_nodes_array, dest->pst_nr_nodes);
+	M0_BE_TX_CAPTURE_ARR(pm->pm_be_seg, tx, dest->pst_devices_array, dest->pst_nr_devices);
+	M0_BE_TX_CAPTURE_ARR(pm->pm_be_seg, tx, dest->pst_spare_usage_array, dest->pst_max_device_failures);
+	M0_BE_TX_CAPTURE_PTR(pm->pm_be_seg, tx, new_link);
+	M0_BE_TX_CAPTURE_PTR(pm->pm_be_seg, tx, new_link->pel_linkage.t_link.ll_prev);
+	M0_BE_TX_CAPTURE_PTR(pm->pm_be_seg, tx, new_link->pel_linkage.t_link.ll_next);
 	return rc;
 }
 
-- 
1.8.3.2

