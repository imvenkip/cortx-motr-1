From 908b9fdd4cc05ea00618efbde6429e1a45534a3f Mon Sep 17 00:00:00 2001
From: Rohan Puri <rohan_puri@xyratex.com>
Date: Fri, 25 Oct 2013 09:27:37 +0530
Subject: [PATCH 110/121] Changes summary : - 1. FIXED BUG: - mutex in
 addb_monitoring_ctx is used to protect only its tlist member &    not its
 other members (like stats connection object), since these other members are  
  always accessed by one thread only, the fix was to remove mutex_lock/unlock
 while    accessing these other members.

These changes are part of round 1 review addb-monitoring-infrastructure
at link http://reviewboard.clusterstor.com/r/1544/
---
 addb/addb_monitor.c | 24 +++---------------------
 1 file changed, 3 insertions(+), 21 deletions(-)

diff --git a/addb/addb_monitor.c b/addb/addb_monitor.c
index 001ada8..cf5ccaa 100644
--- a/addb/addb_monitor.c
+++ b/addb/addb_monitor.c
@@ -212,35 +212,22 @@ M0_INTERNAL int m0_addb_monitor_stats_svc_conn_init(struct m0_reqh *reqh)
 		M0_RETURN(0);
 	}
 
-	m0_mutex_lock(&mon_ctx->amc_mutex);
 	STATS_ALLOC_PTR(mon_ctx->amc_stats_conn, &m0_addb_monitors_mod_ctx,
 			SVC_CONN_ESTABLISH_2);
-	if (mon_ctx->amc_stats_conn == NULL) {
-		m0_mutex_unlock(&mon_ctx->amc_mutex);
+	if (mon_ctx->amc_stats_conn == NULL)
 		M0_RETURN(-ENOMEM);
-	}
-	/**
-	 * Need to release monitoring ctx mutex here to avoid deadlock due to
-	 * same thread acguiring this mutex twice(once above here in this
-	 * function & in addb_mon_rpc_client_connect())  without releasing it
-	 * the first time.
-	 */
-	m0_mutex_unlock(&mon_ctx->amc_mutex);
 	rc = addb_mon_rpc_client_connect(mon_ctx->amc_stats_conn,
 					 rmach,
 					 stats_svc_ep,
 					 ADDB_STATS_MAX_RPCS_IN_FLIGHT);
 
-	m0_mutex_lock(&mon_ctx->amc_mutex);
 	if (rc != 0) {
 		STATS_ADDB_FUNCFAIL(rc, SVC_CONN_ESTABLISH_3,
 				    &m0_addb_monitors_mod_ctx);
 		m0_free(mon_ctx->amc_stats_conn);
-		m0_mutex_unlock(&mon_ctx->amc_mutex);
 		M0_RETURN(rc);
 	}
 	mon_ctx->amc_stats_ep = stats_svc_ep;
-	m0_mutex_unlock(&mon_ctx->amc_mutex);
 	return rc;
 }
 #endif
@@ -255,16 +242,11 @@ M0_INTERNAL void m0_addb_monitor_setup(struct m0_reqh     *reqh,
 
 	mon_ctx = &reqh->rh_addb_monitoring_ctx;
 
-	m0_mutex_lock(&mon_ctx->amc_mutex);
-	if (mon_ctx->amc_stats_ep != NULL)
-		goto out;
-	else {
-		/** Only assign stats ep for the first mentioned conf object */
+	/** Only assign stats ep for the first mentioned conf object */
+	if (mon_ctx->amc_stats_ep == NULL) {
 		mon_ctx->amc_stats_ep      = ep;
 		mon_ctx->amc_stats_conn    = conn;
 	}
-out:
-	m0_mutex_unlock(&mon_ctx->amc_mutex);
 }
 
 M0_INTERNAL int m0_addb_monitors_init(struct m0_reqh *reqh)
-- 
1.8.3.2

