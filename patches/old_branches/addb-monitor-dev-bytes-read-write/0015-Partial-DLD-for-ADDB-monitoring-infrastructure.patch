From 42198cbd299d37db7afe98ec08c7fa4f950cd2f9 Mon Sep 17 00:00:00 2001
From: Rohan Puri <rohan_puri@xyratex.com>
Date: Thu, 11 Jul 2013 17:44:48 +0530
Subject: [PATCH 015/121] Partial DLD for ADDB monitoring infrastructure.
 Periodic posting of addb stats summary record infrastructure.

---
 addb/Makefile.sub            |  20 ++-
 addb/addb.c                  |   4 +-
 addb/addb_monitor.c          | 322 +++++++++++++++++++++++++++++++++++++++++++
 addb/addb_monitor.h          | 204 +++++++++++++++++++++++++++
 addb/addb_monitor_wire.h     |  13 +-
 addb/addb_rec.c              |  22 ++-
 addb/user_space/addb_pfom.c  |  12 +-
 addb/user_space/addb_svc.c   |  14 +-
 addb/user_space/addb_svc.h   |   1 +
 m0t1fs/linux_kernel/m0t1fs.c |  10 +-
 m0t1fs/m0t1fs_addb.h         |   2 +
 mero/magic.h                 |   6 +
 12 files changed, 614 insertions(+), 16 deletions(-)
 create mode 100644 addb/addb_monitor.c
 create mode 100644 addb/addb_monitor.h

diff --git a/addb/Makefile.sub b/addb/Makefile.sub
index 51d9a6d..9ced396 100644
--- a/addb/Makefile.sub
+++ b/addb/Makefile.sub
@@ -2,6 +2,9 @@ nobase_mero_include_HEADERS += addb/addb.h \
                                addb/addb_fops.h \
                                addb/addb_fops_xc.h \
                                addb/addb_macros.h \
+			       addb/addb_monitor.h \
+			       addb/addb_monitor_wire.h \
+			       addb/addb_monitor_wire_xc.h \
                                addb/addb_pvt.h \
                                addb/addb_wire.h \
                                addb/addb_wire_xc.h \
@@ -11,7 +14,8 @@ nobase_mero_include_HEADERS += addb/addb.h \
 mero_libmero_la_SOURCES  += addb/addb.c \
                             addb/addb_wire_xc.c
 
-XC_FILES   += addb/addb_wire_xc.h \
+XC_FILES   += addb/addb_monitor_wire_xc.h \
+	      addb/addb_wire_xc.h \
 	      addb/addb_fops_xc.h
 
 EXTRA_DIST += addb/addb_counter.c \
@@ -21,6 +25,8 @@ EXTRA_DIST += addb/addb_counter.c \
               addb/addb_fops.c \
               addb/addb_fops_xc.c \
               addb/addb_mc.c \
+	      addb/addb_monitor.c \
+	      addb/addb_monitor_wire_xc.c \
               addb/addbmc.dia \
               addb/addbmc.png \
               addb/addb_rec.c \
@@ -35,5 +41,15 @@ EXTRA_DIST += addb/addb_counter.c \
               addb/user_space/addb_svc.c \
               addb/user_space/uctx.c
 
-addb/addb.c: addb/addb_fops_xc.h \
+CLEANFILES += addb/addb_fops_xc.c \
+	      addb/addb_fops_xc.h \
+	      addb/addb_fops.gccxml \
+	      addb/addb_monitor_wire_xc.c \
+	      addb/addb_monitor_wire_xc.h \
+              addb/addb_wire_xc.c \
+              addb/addb_wire_xc.h \
+              addb/addb_wire.gccxml
+
+addb/addb.c: addb/addb_monitor_wire_xc.h \
+	     addb/addb_fops_xc.h \
              addb/addb_wire_xc.h
diff --git a/addb/addb.c b/addb/addb.c
index e403d4b..feaa937 100644
--- a/addb/addb.c
+++ b/addb/addb.c
@@ -707,7 +707,8 @@ Plan</a> for details.
 
 #include "addb/addb_wire_xc.h"
 #include "addb/addb_fops_xc.h"
-
+#include "addb/addb_monitor.h"
+#include "addb/addb_monitor_wire_xc.h"
 struct m0_uint128 m0_node_uuid; /* globally visible uuid */
 
 /**
@@ -779,6 +780,7 @@ static int addb_node_uuid_init(void)
 #include "addb/user_space/addb_retrieval.c"
 #endif
 #include "addb/addb_fops.c"
+#include "addb/addb_monitor.c"
 
 #ifndef __KERNEL__
 static void addb_register_kernel_ctx_and_rec_types(void)
diff --git a/addb/addb_monitor.c b/addb/addb_monitor.c
new file mode 100644
index 0000000..600931d
--- /dev/null
+++ b/addb/addb_monitor.c
@@ -0,0 +1,322 @@
+/* -*- C -*- */
+/*
+ * COPYRIGHT 2012 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: Rohan Puri <rohan_puri@xyratex.com>
+ * Original creation: 06/14/2013
+ */
+
+/**
+   <!-- 06/13/2013 -->
+   @page ADDB-MON-INFRA-DLD ADDB monitoring infrastructure  Detailed Design
+
+   Refer to the @ref ADDB-DLD "ADDB Detailed Design"
+   for the ADDB design requirements.
+
+   - @ref ADDB-MON-INFRA-DLD-ovw
+   - @ref ADDB-MON-INFRA-DLD-def
+   - @ref ADDB-MON-INFRA-DLD-req
+   - @ref ADDB-MON-INFRA-DLD-highlights
+   - @subpage ADDB-MON-INFRA-DLD-fspec "Functional Specification" <!-- Note @subpage -->
+   - @ref ADDB-MON-INFRA-DLD-lspec
+      - @ref ADDB-MON-INFRA-DLD-lspec-usage
+      - @ref ADDB-MON-INFRA-DLD-lspec-rec
+      - @ref ADDB-MON-INFRA-DLD-lspec-thread
+   - @ref ADDB-MON-INFRA-ut
+   - @ref ADDB-MON-INFRA-ref
+
+   <hr>
+   @section ADDB-MON-INFRA-DLD-ovw Overview
+   This design describes the ADDB monitoring infrastructure data structures,
+   posting of summary ADDB records from inside monitors.
+
+   <hr>
+   @section ADDB-MON-INFRA-DLD-def Definitions
+   @see @ref ADDB-MON-INFRA-DLD-ref-HLD "[0]" for definitions that apply to
+   this design.
+
+   <hr>
+   @section ADDB-MON-INFRA-DLD-req Requirments
+
+   The following requirements are fully described in
+   @ref ADDB-MON-INFRA-DLD-ref-HLD "[0]":
+   - @b r.addb.monitor.add.runtime
+   - @b r.addb.monitor.remove.runtime
+   - @b r.addb.monitor.summary.generate-addb-records
+   - @b r.addb.monitor.summary.deliver-addb-records-to-stats-service
+   - @b r.addb.monitor.summary.deliver-addb-records-to-local-HA
+   - @b r.addb.monitor.summary.deliver-addb-records-to-addb-service
+   - @b r.addb.monitor.nesting
+   - @b r.addb.monitor.stats-service
+   - @b r.addb.monitor.stats-service.state
+   - @b r.addb.monitor.stats-service.query
+   - @b r.addb.monitor.stats-service.single-instance
+
+   <hr>
+   @section ADDB-MON-INFRA-DLD-highlights Design Highlights
+
+   This design closely follows that described in
+   @ref ADDB-MON-INFRA-DLD-ref-HLD "[0]"
+
+   An ADDB monitoring infrastructure provides infrastructure to define, add,
+   remove ADDD monitors.
+
+   <hr>
+   @section ADDB-MON-INFRA-DLD-lspec Logical Specification
+   - @ref ADDB-MON-INFRA-DLD-lspec-comps
+   - @ref ADDB-MON-INFRA-DLD-lspec-rec
+   - @ref ADDB-DLD-CNTR-lspec-sm_counter
+   - @ref ADDB-DLD-CNTR-lspec-thread
+
+   @subsection ADDB-MON-INFRA-DLD-lspec-comps ADDB Monitor infrastructure Overview
+
+   ADDB monitors are objects used to monitor any parameter (node or mero) &
+   generate ADDB summary records that are then sent to stats service.
+
+		Global ADDB monitors list
+             ____    ____    ____          ____
+	    |mon1|->|mon2|->|mon3|-... -> |monn|
+	    |____|  |____|  |____|        |____|
+
+
+	addb_rec_1
+	addb_rec_2                   ____
+	addb_rec_3----------------->|monx|->Generate ADDB summary record &
+	    .                       |____| post ast
+	    .
+	    .
+	addb_rec_n
+
+	When rpc worker thread run asts -> Post ADDB summary records to
+	stats & addb service.
+
+   @subsection ADDB-MON-INFRA-DLD-lspec-thread Threading and Concurrency Model
+
+   ADDB monitors run in the context of the thread that posted ADDB records.
+   These monitors generate summary ADDB records, but do not post them, instead
+   the posting is deferred to the rpc worker thread that runs periodically.
+ */
+
+/**
+   @addtogroup addb_pvt
+   @see @ref addb "Analysis and Data-Base API"
+   @{
+ */
+#include "addb/addb_monitor.h"
+
+struct m0_addb_monitor_global_ctx monitor_global_ctx;
+
+M0_TL_DESCR_DEFINE(addb_mon, "addb monitors list", M0_INTERNAL,
+		   struct m0_addb_monitor, am_linkage, am_magic,
+		   M0_ADDB_MONITOR_LIST_LINK_MAGIC,
+		   M0_ADDB_MONITOR_LIST_HEAD_MAGIC);
+
+M0_TL_DEFINE(addb_mon, M0_INTERNAL, struct m0_addb_monitor);
+
+M0_INTERNAL int m0_addb_monitor_subsys_init(const struct m0_reqh *reqh,
+					    const char           *endpoint)
+{
+	M0_PRE(reqh != NULL);
+	M0_PRE(endpoint != NULL);
+
+	addb_mon_tlist_init(&monitor_global_ctx.amgc_list);
+
+	monitor_global_ctx.amgc_reqh = reqh;
+	/*
+	 * @todo: Establish connection with stats service
+	 */
+	return 0;
+}
+
+M0_INTERNAL int m0_addb_monitor_init(struct m0_addb_monitor *monitor,
+			  void (*am_watch) (const struct m0_addb_rec *rec,
+					    const struct m0_reqh     *reqh),
+			  struct m0_addb_sum_rec * (*am_sum_get)
+					   (const struct m0_reqh *reqh),
+			  int (*am_sum_set) (const struct m0_reqh *reqh))
+{
+	int rc = 0;
+
+	M0_PRE(monitor != NULL);
+	M0_PRE(am_watch != NULL);
+	M0_PRE(((am_sum_get != NULL) && (am_sum_set != NULL)) ||
+	       ((am_sum_get == NULL) && (am_sum_set == NULL)));
+
+	monitor->am_watch = am_watch;
+
+	if (am_sum_get != NULL) {
+		monitor->am_sum_get = am_sum_get;
+		monitor->am_sum_set = am_sum_set;
+		rc = monitor->am_sum_set(monitor_global_ctx.amgc_reqh);
+		if (rc != 0)
+			M0_RETURN(rc);
+	}
+
+	addb_mon_tlink_init(monitor);
+
+	M0_RETURN(rc);
+}
+
+static void addb_monitor_fini(struct m0_addb_monitor *monitor)
+{
+	M0_PRE(monitor != NULL);
+
+	monitor->am_watch = NULL;
+	monitor->am_sum_get = NULL;
+	monitor->am_sum_set = NULL;
+	addb_mon_tlink_fini(monitor);
+}
+
+static bool addb_monitor_invariant(struct m0_addb_monitor *monitor)
+{
+	return true;
+}
+
+M0_INTERNAL void m0_addb_monitor_add(struct m0_addb_monitor *monitor)
+{
+	M0_PRE(addb_monitor_invariant(monitor));
+
+	addb_mon_tlist_add_tail(&monitor_global_ctx.amgc_list, monitor);
+}
+
+M0_INTERNAL void m0_addb_monitor_del(struct m0_addb_monitor *monitor)
+{
+	M0_PRE(monitor != NULL);
+
+	addb_mon_tlist_del(monitor);
+
+	if (monitor->am_sum_get != NULL) {
+		m0_free(monitor->am_sum_get(monitor_global_ctx.amgc_reqh));
+	}
+	addb_monitor_fini(monitor);
+}
+
+M0_INTERNAL void m0_addb_monitor_subsys_fini(void)
+{
+	struct m0_addb_monitor *mon;
+
+	m0_tl_for(addb_mon, &monitor_global_ctx.amgc_list, mon) {
+		m0_addb_monitor_del(mon);
+	} m0_tl_endfor;
+
+	addb_mon_tlist_fini(&monitor_global_ctx.amgc_list);
+	/* @todo: Close connection with stats service and do related cleanup */
+	monitor_global_ctx.amgc_reqh = NULL;
+}
+
+#define ADDB_SUM_REC_ON_WIRE_LEN(sum) 0
+
+M0_INTERNAL int m0_addb_post_summaries(void)
+{
+	const struct m0_addb_monitor *mon;
+	const struct m0_reqh         *reqh = monitor_global_ctx.amgc_reqh;
+	uint16_t		      dirtied_mon_cnt = 0;
+	struct m0_addb_sum_rec_fop   *sum_recs_fop;
+	struct m0_addb_sum_rec_fop_data *sum_rec;
+	int                           i = 0;
+
+	M0_ALLOC_PTR(sum_recs_fop);
+
+	if (sum_recs_fop == NULL)
+		M0_RETURN(-ENOMEM);
+
+	m0_tl_for(addb_mon, &monitor_global_ctx.amgc_list, mon) {
+		if (mon->am_sum_get != NULL) {
+			struct m0_addb_sum_rec *sum = mon->am_sum_get(reqh);
+			m0_mutex_lock(&sum->asr_mutex);
+			if (sum->asr_dirty == true)
+				++dirtied_mon_cnt;
+			m0_mutex_unlock(&sum->asr_mutex);
+		}
+	} m0_tl_endfor;
+
+	if (dirtied_mon_cnt == 0)
+		M0_RETURN(0);
+
+	M0_ALLOC_ARR(sum_recs_fop->asrf_recs, dirtied_mon_cnt);
+
+	if (sum_recs_fop->asrf_recs == NULL)
+		M0_RETURN(-ENOMEM);
+
+	m0_tl_for(addb_mon, &monitor_global_ctx.amgc_list, mon) {
+		if (mon->am_sum_get != NULL) {
+			struct m0_addb_sum_rec *sum = mon->am_sum_get(reqh);
+			struct m0_addb_sum_rec_wire  *addb_sum_rec_on_wire;
+			size_t                        len;
+
+			len = ADDB_SUM_REC_ON_WIRE_LEN(sum);
+
+			addb_sum_rec_on_wire = m0_alloc(len);
+
+			if (addb_sum_rec_on_wire == NULL) {
+				m0_free(sum_recs_fop->asrf_recs);
+				m0_free(sum_recs_fop);
+				M0_RETURN(-ENOMEM);
+			}
+
+			m0_mutex_lock(&sum->asr_mutex);
+			if (sum->asr_dirty == true) {
+				/**
+				 * @note: There can be a case wherein, when
+				 * we compute dirtied_mon_cnt value by first
+				 * mon list traversal and when we reach here,
+				 * no of addb sum recs which are dirty can be
+				 * more than dirtied_mon_cnt, but we have
+				 * allocated space for only dirtied_mon_cnt
+				 * pointers of m0_addb_sum_rec, hence we break
+				 * here. The m0_addb_sum_recs which are dirtied
+				 * in this small window, would be sent during
+				 * next periodic call to this function.
+				 */
+				if (i == dirtied_mon_cnt)
+					break;
+				sum_rec = &(sum_recs_fop->asrf_recs[i++]);
+
+				/**
+				 * @note: We need to make a copy of monitor's
+				 * m0_addb_sum_rec::asr_rec since,we cannot send
+				 * the former as a fop as its content can change
+				 * during the process of creation of fop to its
+				 * sending to stats service. We can avoid that
+				 * by taking some global lock until the fop is sent
+				 * but this is avoided to make the lock granularity
+				 * small, just to copying it. Also, on-wire summary
+				 * record would be few bytes and all dirtied would
+				 * be dirtied_mon * sizeof(each on-wire sum rec)
+				 * would be approximately some KBs.
+				 */
+				memcpy(addb_sum_rec_on_wire, sum->asr_rec, len); 
+				sum_rec->asrfd_data = addb_sum_rec_on_wire;
+			}
+			m0_mutex_unlock(&sum->asr_mutex);
+		}
+	} m0_tl_endfor;
+
+	/**
+	 * @todo: Send this on-wire fop data by creating and sending a fop
+	 * to stats service.
+	 */
+	M0_RETURN(0);
+}
+
+/*
+ *  Local variables:
+ *  c-indentation-style: "K&R"
+ *  c-basic-offset: 8
+ *  tab-width: 8
+ *  fill-column: 80
+ *  scroll-step: 1
+ *  End:
+ */
diff --git a/addb/addb_monitor.h b/addb/addb_monitor.h
new file mode 100644
index 0000000..13843d8
--- /dev/null
+++ b/addb/addb_monitor.h
@@ -0,0 +1,204 @@
+/* -*- C -*- */
+/*
+ * COPYRIGHT 2013 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: Rohan Puri <rohan_puri@xyratex.com>
+ * Original creation date: 06/14/2013
+ */
+
+#pragma once
+
+#ifndef __MERO_ADDB_ADDB_MONITOR_H__
+#define __MERO_ADDB_ADDB_MONITOR_H__
+
+#include "addb/addb.h"
+#include "lib/vec.h"
+#include "lib/bitmap.h"
+#include "reqh/reqh.h"
+
+/**
+   @page ADDB-MON-INFRA-DLD-fspec Functional Specification
+   - @ref ADDB-MON-INFRA-DLD-fspec-ds
+   - @ref ADDB-MON-INFRA-DLD-fspec-sub
+   - @ref ADDB-MON-INFRA-DLD-fspec-cli
+   - @ref ADDB-MON-INFRA-DLD-fspec-usecases
+     - @ref ADDB-MON-INFRA-DLD-fspec-uc-TSMC
+     - @ref ADDB-MON-INFRA-DLD-fspec-uc-PSMC
+     - @ref ADDB-MON-INFRA-DLD-fspec-uc-AWKMC
+     - @ref ADDB-MON-INFRA-DLD-fspec-uc-reg
+     - @ref ADDB-MON-INFRA-DLD-fspec-uc-mod-ctx
+     - @ref ADDB-MON-INFRA-DLD-fspec-uc-post
+     - @ref ADDB-MON-INFRA-DLD-fspec-uc-cntr
+     - @ref ADDB-MON-INFRA-DLD-fspec-uc-read
+   - Detailed functional specifications:
+     - @ref addb "Analysis and Diagnostics Data-Base API"
+     - @ref addb_pvt "ADDB Internal Interfaces"
+
+   <hr>
+   @section ADDB-DLD-fspec-ds Data Structures
+
+   The following data structures are involved in an ADDB monitoring
+   infrastructure:
+   - m0_addb_monitor
+   - m0_addb_monitor_global_ctx
+   - m0_addb_sum_rec
+
+   <hr>
+   @section ADDB-DLD-fspec-sub Subroutines and Macros
+
+   Interfaces needed for ADDB monitoring infrastructure
+   - m0_addb_monitor_subsystem_init()
+   - m0_addb_monitor_add()
+   - m0_addb_monitor_delete()
+   - m0_addb_monitor_subsystem_fini()
+   - m0_addb_post_summaries()
+
+   <hr>
+   @section ADDB-DLD-fspec-usecases Recipes
+   - @ref ADDB-DLD-fspec-uc-create_monitor
+   - @ref ADDB-DLD-fspec-uc-PSMC
+   - @ref ADDB-DLD-fspec-uc-AWKMC
+   - @ref ADDB-DLD-fspec-uc-reg
+   - @ref ADDB-DLD-fspec-uc-post
+   - @ref ADDB-DLD-fspec-uc-cntr
+   - @ref ADDB-DLD-fspec-uc-read
+
+   @subsection ADDB-DLD-fspec-uc-create_monitor Create monitor
+
+   Series of steps
+*/
+
+#include "addb/addb_monitor_wire.h"
+#include "rpc/conn.h"
+
+struct m0_addb_monitor;
+
+M0_TL_DESCR_DECLARE(addb_mon, M0_EXTERN);
+//M0_TL_DELARE(addb_mon, M0_INTERNAL, struct m0_addb_monitor);
+
+struct m0_addb_sum_rec {
+	/**
+	 * If this is updated then asr_dirty: true
+	 * asr_dirty:false on sending this summary record to stats service
+	 */
+	bool                         asr_dirty;
+	struct m0_tlink              asr_linkage;
+	/* This lock serializes access to this structure */
+	struct m0_mutex              asr_mutex;
+	/* ADDB on-wire summary record */
+	struct m0_addb_sum_rec_wire *asr_rec;
+};
+
+struct m0_addb_monitor {
+	/**
+	 * Linkage to global monitors list in
+	 * m0_addb_monitor_global_ctx:amgc_list
+	 */
+	struct m0_tlink  am_linkage;
+	/**
+	 * Any processing specific to monitor is done here
+	 * includes, updates to the m0_addb_sum_rec data updation.
+	 */
+	void           (*am_watch) (const struct m0_addb_rec *rec,
+				    const struct m0_reqh     *reqh);
+	/* Returns m0_addb_sum_rec, if any for this monitor. */
+	struct m0_addb_sum_rec *(*am_sum_get) (const struct m0_reqh *reqh);
+	/**
+	 * Set the monitor specific m0_addb_sum_rec, if any
+	 * in the reqh's locker structure
+	 */
+	int           (*am_sum_set) (const struct m0_reqh *reqh);
+	/* Magic needed for monitor's tlist */
+	uint64_t        am_magic;
+};
+
+struct stats_conn {
+	struct m0_rpc_conn    sc_conn;
+	struct m0_rpc_session sc_session;
+	bool                  sc_connected;
+};
+
+struct m0_addb_monitor_global_ctx {
+	/* List of active monitors */
+	struct m0_tl                       amgc_list;
+	/* Stats service endpoint */
+	struct cs_endpoint_and_xprt       *amgc_ex;
+	/* Stats service connection related thing */
+	struct stats_conn                  amgc_stats_conn;
+	const struct m0_reqh              *amgc_reqh;
+};
+
+/**
+ * Initialize ADDB monitoring sub-system
+ * @param mach RPC machine
+ * @param endpoint endpoint where stats service runs
+ * @pre reqh != NULL
+ * @pre endpoint != NULL
+ * @post m0_addb_monitor_global_ctx:amgc_list initialized
+ * @post m0_addb_monitor_global_ctx:amgc_ex != NULL
+ */
+M0_INTERNAL int m0_addb_monitor_subsys_init(const struct m0_reqh *reqh,
+					    const char           *endpoint);
+
+/**
+ * Allocate monitor & assign the monitoring specific function
+ * @param monitor ADDB monitor object
+ * @pre monitor != NULL
+ * @pre (*am_watch) () != NULL
+ * @post *monitor != NULL
+ * @post monitor:am_watch == @param (*am_watch) ()
+ * @post monitor:am_sum_set == @param (*am_sum_set) ()
+ * @post monitor:am_sum_get == @param (*am_sum_get) ()
+ */
+M0_INTERNAL int m0_addb_monitor_init(struct m0_addb_monitor *monitor,
+			   void (*am_watch) (const struct m0_addb_rec *rec,
+					     const struct m0_reqh     *reqh),
+	struct m0_addb_sum_rec * (*am_sum_get) (const struct m0_reqh *reqh),
+			   int (*am_sum_set) (const struct m0_reqh *reqh));
+
+/**
+ * Add a particular monitor with the ADDB monitoring sub-system
+ * @param monitor ADDB monitor to register
+ */
+M0_INTERNAL void m0_addb_monitor_add(struct m0_addb_monitor *monitor);
+
+/**
+ * Delete a particular monitor from the ADDB monitoring sub-system
+ * @param monitor ADDB monitor to unregister
+ */
+M0_INTERNAL void m0_addb_monitor_del(struct m0_addb_monitor *monitor);
+
+/**
+ * Cleanup the ADDB monitoring sub-system
+ */
+M0_INTERNAL void m0_addb_monitor_subsys_fini(void);
+
+/**
+ * This sends all the dirtied addb summary records for the added monitors
+ * to the stats service as a fop.
+ */
+M0_INTERNAL int m0_addb_post_summaries(void);
+
+#endif /* __MERO_ADDB_ADDB_MONITOR_H__ */
+
+/*
+ *  Local variables:
+ *  c-indentation-style: "K&R"
+ *  c-basic-offset: 8
+ *  tab-width: 8
+ *  fill-column: 80
+ *  scroll-step: 1
+ *  End:
+ */
diff --git a/addb/addb_monitor_wire.h b/addb/addb_monitor_wire.h
index 63e8b07..5120bd2 100644
--- a/addb/addb_monitor_wire.h
+++ b/addb/addb_monitor_wire.h
@@ -45,11 +45,20 @@ struct m0_addb_sum_rec_seq {
 
 struct m0_addb_sum_rec_wire {
 	/** This is addb_rec_type:art_id for this ADDB summary record */
-	uint32_t               asrw_id;
+	uint32_t                   asrw_id;
 	/* ADDB summary record data encoded in sequence form */
-	struct m0_addb_sum_req asrw_rec;
+	struct m0_addb_sum_rec_seq asrw_rec;
 } M0_XCA_RECORD;
 
+struct m0_addb_sum_rec_fop_data {
+	struct m0_addb_sum_rec_wire *asrfd_data M0_XCA_OPAQUE("m0_addb_sum_rec_wire_xc_type");
+} M0_XCA_RECORD;
+
+struct m0_addb_sum_rec_fop {
+	uint32_t asrf_nr;
+	struct m0_addb_sum_rec_fop_data *asrf_recs;
+} M0_XCA_SEQUENCE;
+
 #endif /* __MERO_ADDB_ADDB_MONITOR_WIRE_H__ */
 
 /*
diff --git a/addb/addb_rec.c b/addb/addb_rec.c
index 98d8d9e..ba55098 100644
--- a/addb/addb_rec.c
+++ b/addb/addb_rec.c
@@ -27,6 +27,8 @@
    @{
  */
 
+extern struct m0_addb_monitor_global_ctx monitor_global_ctx;
+
 struct addb_rec_post_ut_data {
 	struct m0_addb_ctx       **cv;
 	size_t                     cv_nr;
@@ -65,13 +67,14 @@ static void addb_rec_post(struct m0_addb_mc *mc,
 			  uint64_t *fields,
 			  size_t fields_nr)
 {
-	struct m0_addb_rec *rec;
-	size_t              len;
-	size_t              ctxid_seq_data_size;
-	size_t              bytes_nr;
-	int                 i;
-	uint64_t           *dp;
-	char               *p;
+	struct m0_addb_monitor *mon;
+	struct m0_addb_rec     *rec;
+	size_t                  len;
+	size_t                  ctxid_seq_data_size;
+	size_t                  bytes_nr;
+	int                     i;
+	uint64_t               *dp;
+	char                   *p;
 
 	M0_PRE(m0_addb_mc_has_evmgr(mc));
 
@@ -147,6 +150,11 @@ static void addb_rec_post(struct m0_addb_mc *mc,
 	 * the thread.
 	 */
 	mc->am_evmgr->evm_post(mc, rec);
+
+	/* Invoke all the monitor's filters */
+	m0_tl_for(addb_mon, &monitor_global_ctx.amgc_list, mon) {
+		mon->am_watch(rec, monitor_global_ctx.amgc_reqh);
+	} m0_tl_endfor;
 }
 
 #ifndef __KERNEL__
diff --git a/addb/user_space/addb_pfom.c b/addb/user_space/addb_pfom.c
index eeeb902..b340012 100644
--- a/addb/user_space/addb_pfom.c
+++ b/addb/user_space/addb_pfom.c
@@ -206,7 +206,7 @@ static int addb_pfom_fo_tick(struct m0_fom *fom)
 	struct m0_reqh_service *rsvc = &svc->as_reqhs;
 	int                     rc = M0_FSO_AGAIN;
 	m0_time_t               now;
-
+	int                     err;
 	M0_ENTRY();
 
 	switch (m0_fom_phase(fom)) {
@@ -249,6 +249,16 @@ static int addb_pfom_fo_tick(struct m0_fom *fom)
 	case ADDB_PFOM_PHASE_POST:
 		M0_LOG(M0_DEBUG, "post");
 		m0_reqh_stats_post_addb(reqh);
+
+		err = m0_addb_post_summaries();
+
+		/**
+		 * In case of summaries posting failure, just log error.
+		 * We do not terminate the fom.
+		 */
+		if (err != 0)
+			M0_LOG(M0_ERROR, "addb summary posting failed");
+
 		if (reqh->rh_addb_mc.am_sink->rs_skulk != NULL)
 			(*reqh->rh_addb_mc.am_sink->rs_skulk)
 				(&reqh->rh_addb_mc);
diff --git a/addb/user_space/addb_svc.c b/addb/user_space/addb_svc.c
index e288ca0..81a31ab 100644
--- a/addb/user_space/addb_svc.c
+++ b/addb/user_space/addb_svc.c
@@ -50,7 +50,6 @@
    - @subpage ADDB-DLD-SVC-pstats "Periodic Posting of Statistics"
 
  */
-
 
 /* This file is designed to be included by addb/addb.c */
 
@@ -99,9 +98,21 @@ static bool addb_svc_invariant(const struct addb_svc *svc)
 static int addb_svc_rso_start(struct m0_reqh_service *service)
 {
 	struct addb_svc *svc;
+	int              rc;
 
 	M0_LOG(M0_DEBUG, "starting");
 	M0_PRE(m0_reqh_service_state_get(service) == M0_RST_STARTING);
+
+	/* @todo: Pass correct stats service endpoint */
+	rc = m0_addb_monitor_subsys_init(service->rs_reqh,
+					 "REPLACE-ME");
+	/**
+	 * On monitoring subsystem initialization failure, we just
+	 * log and not terminate the addb service.
+	 */
+	if (rc != 0)
+		M0_LOG(M0_ERROR, "addb monitoring subsystem initialization");
+
 	svc = bob_of(service, struct addb_svc, as_reqhs, &addb_svc_bob);
 	if (addb_svc_start_pfom)
 		addb_pfom_start(svc);
@@ -182,6 +193,7 @@ static int addb_svc_rsto_service_allocate(struct m0_reqh_service **service,
 	m0_cond_init(&svc->as_cond, &(*service)->rs_mutex);
 	addb_svc_bob_init(svc);
 
+
 	M0_POST(addb_svc_invariant(svc));
 
 	return 0;
diff --git a/addb/user_space/addb_svc.h b/addb/user_space/addb_svc.h
index 63af08b..3c2ff76 100644
--- a/addb/user_space/addb_svc.h
+++ b/addb/user_space/addb_svc.h
@@ -26,6 +26,7 @@
 
 #include "reqh/reqh.h"
 #include "reqh/reqh_service.h"
+#include "mero/setup.h"
 
 /**
    @defgroup addb_svc_pvt ADDB Service Internal Interfaces
diff --git a/m0t1fs/linux_kernel/m0t1fs.c b/m0t1fs/linux_kernel/m0t1fs.c
index 48f2c09..4839e4b 100644
--- a/m0t1fs/linux_kernel/m0t1fs.c
+++ b/m0t1fs/linux_kernel/m0t1fs.c
@@ -139,10 +139,15 @@ M0_INTERNAL int m0t1fs_init(void)
 	if (rc != 0)
 		goto net_fini;
 
-	rc = m0t1fs_layout_init();
+	/* @todo: Need to give proper stats service endpoint */
+	rc = m0_addb_monitor_subsys_init(&m0t1fs_globals.g_reqh, "REPLACE-ME");
 	if (rc != 0)
 		goto rpc_fini;
 
+	rc = m0t1fs_layout_init();
+	if (rc != 0)
+		goto mon_fini;
+
 	rc = register_filesystem(&m0t1fs_fs_type);
 	if (rc != 0)
 		goto layout_fini;
@@ -152,7 +157,8 @@ M0_INTERNAL int m0t1fs_init(void)
 
 layout_fini:
 	m0t1fs_layout_fini();
-
+mon_fini:
+	m0_addb_monitor_subsys_fini();
 rpc_fini:
 	m0t1fs_rpc_fini();
 net_fini:
diff --git a/m0t1fs/m0t1fs_addb.h b/m0t1fs/m0t1fs_addb.h
index 5afc877..f9f892f 100644
--- a/m0t1fs/m0t1fs_addb.h
+++ b/m0t1fs/m0t1fs_addb.h
@@ -23,6 +23,8 @@
 #define __MERO_M0T1FS_M0T1FS_ADDB_H__
 
 #include "addb/addb.h"
+#include "addb/addb_monitor.h"
+
 /*
  ******************************************************************************
  * Kernel client ADDB context types.
diff --git a/mero/magic.h b/mero/magic.h
index 0790272..9f6ebde 100644
--- a/mero/magic.h
+++ b/mero/magic.h
@@ -114,6 +114,12 @@ enum m0_magic_satchel {
 	/* rpcsink item source list head (addb safe sloe) */
 	M0_ADDB_RPCSINK_IS_HEAD_MAGIC =0x33addb5afe510e77,
 
+	/* ADDB monitor list's head (addb hellhole) */
+	M0_ADDB_MONITOR_LIST_HEAD_MAGIC = 0x33addb3704773477,
+
+	/* ADDB monitor (addb shoebill*/
+	M0_ADDB_MONITOR_LIST_LINK_MAGIC = 0x33addb7719304577,
+
 /* balloc */
 	/* m0_balloc_super_block::bsb_magic (blessed baloc) */
 	M0_BALLOC_SB_MAGIC = 0x33b1e55edba10c77,
-- 
1.8.3.2

