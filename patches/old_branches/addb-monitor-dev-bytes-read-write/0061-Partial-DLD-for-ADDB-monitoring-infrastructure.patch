From 2a0cab4ae6cdb438ef6b2faf73a6c340018b63d1 Mon Sep 17 00:00:00 2001
From: Rohan Puri <rohan_puri@xyratex.com>
Date: Thu, 11 Jul 2013 17:44:48 +0530
Subject: [PATCH 061/121] Partial DLD for ADDB monitoring infrastructure.
 Periodic posting of addb stats summary record infrastructure.

---
 addb/Makefile.sub            |   6 +-
 addb/addb_monitor.c          | 420 +++++++++++++++++++------------------------
 addb/addb_monitor.h          | 266 ++++++++-------------------
 addb/addb_monitor_wire.h     |  13 +-
 addb/addb_pfom.c             |   3 +-
 addb/addb_rec.c              |  20 +--
 addb/addb_svc.c              |  12 ++
 m0t1fs/linux_kernel/m0t1fs.c |   9 +-
 m0t1fs/m0t1fs_addb.h         |   3 -
 mero/magic.h                 |   2 +-
 10 files changed, 296 insertions(+), 458 deletions(-)

diff --git a/addb/Makefile.sub b/addb/Makefile.sub
index c059894..958e3d8 100644
--- a/addb/Makefile.sub
+++ b/addb/Makefile.sub
@@ -14,9 +14,9 @@ nobase_mero_include_HEADERS += addb/addb.h \
 mero_libmero_la_SOURCES  += addb/addb.c \
                             addb/addb_wire_xc.c
 
-XC_FILES   += addb/addb_wire_xc.h \
-	      addb/addb_monitor_wire_xc.h \
-              addb/addb_fops_xc.h
+XC_FILES   += addb/addb_monitor_wire_xc.h \
+	      addb/addb_wire_xc.h \
+	      addb/addb_fops_xc.h
 
 EXTRA_DIST += addb/addb_counter.c \
               addb/addb_ct.c \
diff --git a/addb/addb_monitor.c b/addb/addb_monitor.c
index 02b5488..600931d 100644
--- a/addb/addb_monitor.c
+++ b/addb/addb_monitor.c
@@ -31,61 +31,60 @@
    - @ref ADDB-MON-INFRA-DLD-highlights
    - @subpage ADDB-MON-INFRA-DLD-fspec "Functional Specification" <!-- Note @subpage -->
    - @ref ADDB-MON-INFRA-DLD-lspec
-      - @ref ADDB-MON-INFRA-DLD-lspec-comps
+      - @ref ADDB-MON-INFRA-DLD-lspec-usage
+      - @ref ADDB-MON-INFRA-DLD-lspec-rec
       - @ref ADDB-MON-INFRA-DLD-lspec-thread
-      - @ref ADDB-MON-INFRA-DLD-lspec-state
-      - @ref ADDB-MON-INFRA-DLD-lspec-numa
    - @ref ADDB-MON-INFRA-ut
-   - @ref ADDB-MON-INFRA-it
-   - @ref ADDB-MON-INFRA-st
-   - @ref ADDB-MON-INFRA-O
    - @ref ADDB-MON-INFRA-ref
 
    <hr>
    @section ADDB-MON-INFRA-DLD-ovw Overview
-   This design describes the ADDB monitoring infrastructure along with posting
-   of addb summary records to stats service.
+   This design describes the ADDB monitoring infrastructure data structures,
+   posting of summary ADDB records from inside monitors.
 
    <hr>
    @section ADDB-MON-INFRA-DLD-def Definitions
-   - <b> Summary ADDB records</b> These are summary records that are generated
-   by ADDB monitor for a particular statistic metric.
-   - <b> ADDB monitor</b> These are objects present on every node in the cluster
-   (client or server), they generate summary records.
+   @see @ref ADDB-MON-INFRA-DLD-ref-HLD "[0]" for definitions that apply to
+   this design.
 
    <hr>
    @section ADDB-MON-INFRA-DLD-req Requirments
 
    The following requirements are fully described in
+   @ref ADDB-MON-INFRA-DLD-ref-HLD "[0]":
+   - @b r.addb.monitor.add.runtime
    - @b r.addb.monitor.remove.runtime
-   - @b r.addb.monitor.summary.post-stats-records
-   - @b r.addb.monitor.summary.post-stats-addb-records
-   - @b @todo r.addb.monitor.summary.post-exception-records
+   - @b r.addb.monitor.summary.generate-addb-records
+   - @b r.addb.monitor.summary.deliver-addb-records-to-stats-service
+   - @b r.addb.monitor.summary.deliver-addb-records-to-local-HA
+   - @b r.addb.monitor.summary.deliver-addb-records-to-addb-service
    - @b r.addb.monitor.nesting
+   - @b r.addb.monitor.stats-service
+   - @b r.addb.monitor.stats-service.state
+   - @b r.addb.monitor.stats-service.query
+   - @b r.addb.monitor.stats-service.single-instance
 
    <hr>
    @section ADDB-MON-INFRA-DLD-highlights Design Highlights
 
+   This design closely follows that described in
+   @ref ADDB-MON-INFRA-DLD-ref-HLD "[0]"
+
+   An ADDB monitoring infrastructure provides infrastructure to define, add,
+   remove ADDD monitors.
+
    <hr>
    @section ADDB-MON-INFRA-DLD-lspec Logical Specification
    - @ref ADDB-MON-INFRA-DLD-lspec-comps
+   - @ref ADDB-MON-INFRA-DLD-lspec-rec
+   - @ref ADDB-DLD-CNTR-lspec-sm_counter
    - @ref ADDB-DLD-CNTR-lspec-thread
-   - @ref ADDB-DLD-CNTR-lspec-state
-   - @ref ADDB-DLD-CNTR-lspec-numa
 
    @subsection ADDB-MON-INFRA-DLD-lspec-comps ADDB Monitor infrastructure Overview
 
-   ADDB monitors are filters which monitor the type/s of addb records they are
-   interested in. They generate & maintain summary data from this monitoring.
-   This summary data structure is monitor specific and is stored using request
-   handlers locker data structure.
-   This summary data is sent periodically to the stats service through a fop &
-   also as addb records to the addb service if present on client or to the addb
-   stob if present on server. This is done through enhancing the
-   functionality of addb pfom @ref ADDB-DLD-SVC-pstats on both the server as
-   well as the client.
-
-   @verbatim
+   ADDB monitors are objects used to monitor any parameter (node or mero) &
+   generate ADDB summary records that are then sent to stats service.
+
 		Global ADDB monitors list
              ____    ____    ____          ____
 	    |mon1|->|mon2|->|mon3|-... -> |monn|
@@ -93,65 +92,32 @@
 
 
 	addb_rec_1
-	addb_rec_2 monitor stream    ____
-	addb_rec_3----------------->|monx|->Generate/Update ADDB summary record
-	    .      of addb recs     |____|
+	addb_rec_2                   ____
+	addb_rec_3----------------->|monx|->Generate ADDB summary record &
+	    .                       |____| post ast
 	    .
 	    .
 	addb_rec_n
 
-   @endverbatim
-
-	Periodically running fom will send all the addb summary records for
-	all the monitors to the stats service & post the summary data as addb
-	summary records on the globally available addb machine.
+	When rpc worker thread run asts -> Post ADDB summary records to
+	stats & addb service.
 
    @subsection ADDB-MON-INFRA-DLD-lspec-thread Threading and Concurrency Model
 
-   ADDB monitors update addb summary data by processing the addb records. Also,
-   ADDB stats posting fom periodically reads this addb summary data for
-   each monitor and sends this data to stats service. Hence,
-   need to synchronize amongst these two accesses of addb summary data. This
-   is achieved by adding m0_mutex to m0_addb_sum_rec structure.
-
-   @subsection ADDB-MON-INFRA-DLD-lspec-state FOM states for sending stats fop
-
-   On the mero server (m0d), addb pfom's ADDB_PFOM_PHASE_POST state does this.
-   For the mero client (m0t1fs), there would be a simple fom that would do this.
-
-   @subsection ADDB-MON-INFRA-DLD-lspec-numa NUMA optimizations
-   These foms that post stats summary records are executed in the same locality.
-
-
-   @section ADDB-MON-INFRA-ut Unit Tests
-   -# Test init, add, delete a particular monitor in user-space
-           & verify the summary data.
-   -# Test init, add, delete a particular monitor in kernel-space
-           & verify the summary data.
-
-   @section ADDB-MON-INFRA-it Integration Tests
-   Verify the summary records sent to stats service from a node.
-
-   @section ADDB-MON-INFRA-st
-   Add real monitor for fom rate, check the fom rate by querying
-   the stats service and verify the data.
-
-   @section ADDB-MON-INFRA-O Analysis
-   Monitor related information (list of monitors, their specific data)
-   are all kept in memory. Monitor implementors are advised to take
-   locks on monitor specific data viz. m0_addb_sum_rec:asr_mutex
-   only when they require data consistency.
-
-
-   @section ADDB-MON-INFRA-ref
-   - <a href="https://docs.google.com/a/xyratex.com/document/d/
-14uPeE0mNkRu3oF32Ys_EnpvSZtGWbf8hviPHTBTOXso/edit">
-   HLD of ADDB Monitoring</a>
-
-*/
+   ADDB monitors run in the context of the thread that posted ADDB records.
+   These monitors generate summary ADDB records, but do not post them, instead
+   the posting is deferred to the rpc worker thread that runs periodically.
+ */
 
+/**
+   @addtogroup addb_pvt
+   @see @ref addb "Analysis and Data-Base API"
+   @{
+ */
 #include "addb/addb_monitor.h"
 
+struct m0_addb_monitor_global_ctx monitor_global_ctx;
+
 M0_TL_DESCR_DEFINE(addb_mon, "addb monitors list", M0_INTERNAL,
 		   struct m0_addb_monitor, am_linkage, am_magic,
 		   M0_ADDB_MONITOR_LIST_LINK_MAGIC,
@@ -159,212 +125,190 @@ M0_TL_DESCR_DEFINE(addb_mon, "addb monitors list", M0_INTERNAL,
 
 M0_TL_DEFINE(addb_mon, M0_INTERNAL, struct m0_addb_monitor);
 
-M0_INTERNAL int m0_addb_monitors_init(struct m0_reqh *reqh,
-				      const char     *endpoint)
+M0_INTERNAL int m0_addb_monitor_subsys_init(const struct m0_reqh *reqh,
+					    const char           *endpoint)
 {
-	int rc = 0;
-
 	M0_PRE(reqh != NULL);
 	M0_PRE(endpoint != NULL);
 
-	addb_mon_tlist_init(&reqh->rh_addb_monitoring_ctx.amc_list);
-	m0_mutex_init(&reqh->rh_addb_monitoring_ctx.amc_mutex);
+	addb_mon_tlist_init(&monitor_global_ctx.amgc_list);
+
+	monitor_global_ctx.amgc_reqh = reqh;
 	/*
 	 * @todo: Establish connection with stats service
 	 */
-	return rc;
+	return 0;
 }
 
-M0_INTERNAL bool m0_addb_monitor_invariant(struct m0_addb_monitor *mon)
+M0_INTERNAL int m0_addb_monitor_init(struct m0_addb_monitor *monitor,
+			  void (*am_watch) (const struct m0_addb_rec *rec,
+					    const struct m0_reqh     *reqh),
+			  struct m0_addb_sum_rec * (*am_sum_get)
+					   (const struct m0_reqh *reqh),
+			  int (*am_sum_set) (const struct m0_reqh *reqh))
 {
-	return mon != NULL && mon->am_ops != NULL;
-}
+	int rc = 0;
 
-M0_INTERNAL void m0_addb_monitor_init(struct m0_addb_monitor           *monitor,
-				      const struct m0_addb_monitor_ops *mon_ops)
-{
 	M0_PRE(monitor != NULL);
-	M0_PRE(mon_ops != NULL);
+	M0_PRE(am_watch != NULL);
+	M0_PRE(((am_sum_get != NULL) && (am_sum_set != NULL)) ||
+	       ((am_sum_get == NULL) && (am_sum_set == NULL)));
+
+	monitor->am_watch = am_watch;
+
+	if (am_sum_get != NULL) {
+		monitor->am_sum_get = am_sum_get;
+		monitor->am_sum_set = am_sum_set;
+		rc = monitor->am_sum_set(monitor_global_ctx.amgc_reqh);
+		if (rc != 0)
+			M0_RETURN(rc);
+	}
 
-	monitor->am_ops = mon_ops;
 	addb_mon_tlink_init(monitor);
-}
 
-M0_INTERNAL void m0_addb_monitor_sum_rec_init(struct m0_addb_sum_rec        *sum_rec,
-					      const struct m0_addb_rec_type *rtype,
-					      uint64_t                      *mon_data,
-					      size_t                         nr)
-{
-	/** @todo: need to implement */
+	M0_RETURN(rc);
 }
 
-M0_INTERNAL void m0_addb_monitor_fini(struct m0_addb_monitor *monitor)
+static void addb_monitor_fini(struct m0_addb_monitor *monitor)
 {
-	M0_PRE(m0_addb_monitor_invariant(monitor));
+	M0_PRE(monitor != NULL);
 
-	monitor->am_ops = NULL;
+	monitor->am_watch = NULL;
+	monitor->am_sum_get = NULL;
+	monitor->am_sum_set = NULL;
 	addb_mon_tlink_fini(monitor);
 }
 
-M0_INTERNAL void m0_addb_monitor_add(struct m0_reqh         *reqh,
-				     struct m0_addb_monitor *monitor)
+static bool addb_monitor_invariant(struct m0_addb_monitor *monitor)
 {
-	M0_PRE(m0_addb_monitor_invariant(monitor));
-
-	m0_mutex_lock(&reqh->rh_addb_monitoring_ctx.amc_mutex);
-	addb_mon_tlist_add_tail(&reqh->rh_addb_monitoring_ctx.amc_list, monitor);
-	m0_mutex_unlock(&reqh->rh_addb_monitoring_ctx.amc_mutex);
+	return true;
 }
 
-M0_INTERNAL void m0_addb_monitor_del(struct m0_reqh         *reqh,
-				     struct m0_addb_monitor *monitor)
+M0_INTERNAL void m0_addb_monitor_add(struct m0_addb_monitor *monitor)
 {
-	struct m0_reqh_service *svc;
-	struct addb_svc        *addb_svc;
+	M0_PRE(addb_monitor_invariant(monitor));
 
-	M0_PRE(m0_addb_monitor_invariant(monitor));
+	addb_mon_tlist_add_tail(&monitor_global_ctx.amgc_list, monitor);
+}
 
-	svc = m0_reqh_service_find(&m0_addb_svc_type, reqh);
-	M0_ASSERT(svc != NULL);
-	addb_svc = bob_of(svc, struct addb_svc, as_reqhs, &addb_svc_bob);
+M0_INTERNAL void m0_addb_monitor_del(struct m0_addb_monitor *monitor)
+{
+	M0_PRE(monitor != NULL);
 
-	m0_mutex_lock(&reqh->rh_addb_monitoring_ctx.amc_mutex);
-	if (addb_svc->as_pfom.pf_mon == monitor) {
-		addb_svc->as_pfom.pf_mon = NULL;
-	}
 	addb_mon_tlist_del(monitor);
-	m0_mutex_unlock(&reqh->rh_addb_monitoring_ctx.amc_mutex);
+
+	if (monitor->am_sum_get != NULL) {
+		m0_free(monitor->am_sum_get(monitor_global_ctx.amgc_reqh));
+	}
+	addb_monitor_fini(monitor);
 }
 
-M0_INTERNAL void m0_addb_monitors_fini(struct m0_reqh *reqh)
+M0_INTERNAL void m0_addb_monitor_subsys_fini(void)
 {
 	struct m0_addb_monitor *mon;
 
-	m0_mutex_lock(&reqh->rh_addb_monitoring_ctx.amc_mutex);
-	m0_tl_for(addb_mon, &reqh->rh_addb_monitoring_ctx.amc_list, mon) {
-		m0_addb_monitor_del(reqh, mon);
-		m0_addb_monitor_fini(mon);
+	m0_tl_for(addb_mon, &monitor_global_ctx.amgc_list, mon) {
+		m0_addb_monitor_del(mon);
 	} m0_tl_endfor;
-	m0_mutex_unlock(&reqh->rh_addb_monitoring_ctx.amc_mutex);
 
-	addb_mon_tlist_fini(&reqh->rh_addb_monitoring_ctx.amc_list);
-	m0_mutex_fini(&reqh->rh_addb_monitoring_ctx.amc_mutex);
-	/** @todo: Close connection with stats service and do related cleanup */
+	addb_mon_tlist_fini(&monitor_global_ctx.amgc_list);
+	/* @todo: Close connection with stats service and do related cleanup */
+	monitor_global_ctx.amgc_reqh = NULL;
 }
 
-#define SUM_SIZE(sum) (sum->asr_rec.asrw_rec.au64s_nr * sizeof(uint64_t))
-
-enum {
-	/**
-	 * How many records to send in one fop
-	 */
-	BATCH = 1024,
-	/**
-	 * Maximal number of records (dirty or clean) scanned in one
-	 * invocation of m0_addb_monitor_summaries_post(). This limits
-	 * processor consumption.
-	 */
-	SCANNED_LIMIT = 16 * 1024,
-	/**
-	 * Maximal number of fops that can be sent in one invocation of
-	 * m0_addb_monitor_summaries_post().
-	 */
-	SENT_LIMIT = 3
-};
-
-static void addb_mon_fop_free(struct m0_addb_sum_rec_fop *fop, uint32_t fop_nr)
-{
-	M0_PRE(fop != NULL);
-
-	if (fop->asrf_recs != NULL) {
-		int i;
-
-		for (i = 0; i < fop_nr; ++i)
-			m0_free(fop->asrf_recs[i].asrw_rec.au64s_data);
-		m0_free(fop->asrf_recs);
-	}
-	m0_free(fop);
-}
+#define ADDB_SUM_REC_ON_WIRE_LEN(sum) 0
 
-M0_INTERNAL int m0_addb_monitor_summaries_post(struct m0_reqh *reqh,
-					      struct addb_post_fom *fom)
+M0_INTERNAL int m0_addb_post_summaries(void)
 {
-	struct m0_tl                *mon_list;
-	/* Continue scanning from the place we left last time */
-	struct m0_addb_monitor      *mon    = fom->pf_mon;
-	struct m0_addb_sum_rec_fop  *fop =  NULL;
-	uint32_t                     fop_nr =  0;
-	uint32_t                     used    = 0;
-	uint32_t                     scanned = 0;
-	uint32_t                     sent    = 0;
-	uint32_t                     result  = 0;
-
-	M0_PRE(reqh != NULL);
-
-	mon_list = &reqh->rh_addb_monitoring_ctx.amc_list;
-	m0_mutex_lock(&reqh->rh_addb_monitoring_ctx.amc_mutex);
-	while (scanned < SCANNED_LIMIT && sent < SENT_LIMIT) {
-		struct m0_addb_sum_rec      *sum;
-		struct m0_addb_sum_rec_wire *rec;
-		void                        *data;
-
-		/* end of list reached, wrap around or the list is empty */
-		if (mon == NULL) {
-			mon = addb_mon_tlist_head(mon_list);
-			if (mon == NULL ||
-			/* if the entire list was scanned and not a single
-			 * dirty record found, stop. */
-			    (scanned > 0 && fop == NULL))
-				break;
-		}
-		++scanned;
-		sum = mon->am_ops->amo_sum_rec(mon, reqh);
-		mon = addb_mon_tlist_next(mon_list, mon);
-		if (sum == NULL || !sum->asr_dirty)
-			continue;
-		++fop_nr;
-		if (fop == NULL) {
-			M0_ALLOC_PTR(fop);
-			if (fop != NULL)
-				M0_ALLOC_ARR(fop->asrf_recs, BATCH);
+	const struct m0_addb_monitor *mon;
+	const struct m0_reqh         *reqh = monitor_global_ctx.amgc_reqh;
+	uint16_t		      dirtied_mon_cnt = 0;
+	struct m0_addb_sum_rec_fop   *sum_recs_fop;
+	struct m0_addb_sum_rec_fop_data *sum_rec;
+	int                           i = 0;
+
+	M0_ALLOC_PTR(sum_recs_fop);
+
+	if (sum_recs_fop == NULL)
+		M0_RETURN(-ENOMEM);
+
+	m0_tl_for(addb_mon, &monitor_global_ctx.amgc_list, mon) {
+		if (mon->am_sum_get != NULL) {
+			struct m0_addb_sum_rec *sum = mon->am_sum_get(reqh);
+			m0_mutex_lock(&sum->asr_mutex);
+			if (sum->asr_dirty == true)
+				++dirtied_mon_cnt;
+			m0_mutex_unlock(&sum->asr_mutex);
 		}
-		data = m0_alloc(SUM_SIZE(sum));
-		if (fop == NULL || fop->asrf_recs == NULL || data == NULL) {
-			result = -ENOMEM;
-			addb_mon_fop_free(fop, fop_nr);
-			break;
-		}
-		rec = &fop->asrf_recs[used++];
-		rec->asrw_id = sum->asr_rec.asrw_id;
-		rec->asrw_rec.au64s_nr = sum->asr_rec.asrw_rec.au64s_nr;
-		rec->asrw_rec.au64s_data = data;
-		m0_mutex_lock(&sum->asr_mutex);
-		memcpy(rec->asrw_rec.au64s_data,
-		       sum->asr_rec.asrw_rec.au64s_data, SUM_SIZE(sum));
-		sum->asr_dirty = false;
-		m0_mutex_unlock(&sum->asr_mutex);
-		if (used == BATCH) {
-			fop->asrf_nr = BATCH;
-			/**
-			 * @todo: Implement send_fop(fop).
-			 * @todo: Finalize the fop after its sent through
-			 * the network.
-			 */
-			used   = 0;
-			fop    = NULL;
-			fop_nr = 0;
-			++sent;
+	} m0_tl_endfor;
+
+	if (dirtied_mon_cnt == 0)
+		M0_RETURN(0);
+
+	M0_ALLOC_ARR(sum_recs_fop->asrf_recs, dirtied_mon_cnt);
+
+	if (sum_recs_fop->asrf_recs == NULL)
+		M0_RETURN(-ENOMEM);
+
+	m0_tl_for(addb_mon, &monitor_global_ctx.amgc_list, mon) {
+		if (mon->am_sum_get != NULL) {
+			struct m0_addb_sum_rec *sum = mon->am_sum_get(reqh);
+			struct m0_addb_sum_rec_wire  *addb_sum_rec_on_wire;
+			size_t                        len;
+
+			len = ADDB_SUM_REC_ON_WIRE_LEN(sum);
+
+			addb_sum_rec_on_wire = m0_alloc(len);
+
+			if (addb_sum_rec_on_wire == NULL) {
+				m0_free(sum_recs_fop->asrf_recs);
+				m0_free(sum_recs_fop);
+				M0_RETURN(-ENOMEM);
+			}
+
+			m0_mutex_lock(&sum->asr_mutex);
+			if (sum->asr_dirty == true) {
+				/**
+				 * @note: There can be a case wherein, when
+				 * we compute dirtied_mon_cnt value by first
+				 * mon list traversal and when we reach here,
+				 * no of addb sum recs which are dirty can be
+				 * more than dirtied_mon_cnt, but we have
+				 * allocated space for only dirtied_mon_cnt
+				 * pointers of m0_addb_sum_rec, hence we break
+				 * here. The m0_addb_sum_recs which are dirtied
+				 * in this small window, would be sent during
+				 * next periodic call to this function.
+				 */
+				if (i == dirtied_mon_cnt)
+					break;
+				sum_rec = &(sum_recs_fop->asrf_recs[i++]);
+
+				/**
+				 * @note: We need to make a copy of monitor's
+				 * m0_addb_sum_rec::asr_rec since,we cannot send
+				 * the former as a fop as its content can change
+				 * during the process of creation of fop to its
+				 * sending to stats service. We can avoid that
+				 * by taking some global lock until the fop is sent
+				 * but this is avoided to make the lock granularity
+				 * small, just to copying it. Also, on-wire summary
+				 * record would be few bytes and all dirtied would
+				 * be dirtied_mon * sizeof(each on-wire sum rec)
+				 * would be approximately some KBs.
+				 */
+				memcpy(addb_sum_rec_on_wire, sum->asr_rec, len); 
+				sum_rec->asrfd_data = addb_sum_rec_on_wire;
+			}
+			m0_mutex_unlock(&sum->asr_mutex);
 		}
-	}
-	if (fop != NULL) {
-		/** @todo: Send fop. */
-	}
-	m0_mutex_unlock(&reqh->rh_addb_monitoring_ctx.amc_mutex);
-	fom->pf_mon = mon;
+	} m0_tl_endfor;
+
 	/**
-	 * @todo: Post on global machine too.
+	 * @todo: Send this on-wire fop data by creating and sending a fop
+	 * to stats service.
 	 */
-	return result;
+	M0_RETURN(0);
 }
 
 /*
diff --git a/addb/addb_monitor.h b/addb/addb_monitor.h
index 5e6c70c..13843d8 100644
--- a/addb/addb_monitor.h
+++ b/addb/addb_monitor.h
@@ -26,7 +26,7 @@
 #include "addb/addb.h"
 #include "lib/vec.h"
 #include "lib/bitmap.h"
-#include "rpc/session.h"
+#include "reqh/reqh.h"
 
 /**
    @page ADDB-MON-INFRA-DLD-fspec Functional Specification
@@ -34,7 +34,14 @@
    - @ref ADDB-MON-INFRA-DLD-fspec-sub
    - @ref ADDB-MON-INFRA-DLD-fspec-cli
    - @ref ADDB-MON-INFRA-DLD-fspec-usecases
-     - @ref ADDB-MON-INFRA-DLD-fspec-uc-IAAM
+     - @ref ADDB-MON-INFRA-DLD-fspec-uc-TSMC
+     - @ref ADDB-MON-INFRA-DLD-fspec-uc-PSMC
+     - @ref ADDB-MON-INFRA-DLD-fspec-uc-AWKMC
+     - @ref ADDB-MON-INFRA-DLD-fspec-uc-reg
+     - @ref ADDB-MON-INFRA-DLD-fspec-uc-mod-ctx
+     - @ref ADDB-MON-INFRA-DLD-fspec-uc-post
+     - @ref ADDB-MON-INFRA-DLD-fspec-uc-cntr
+     - @ref ADDB-MON-INFRA-DLD-fspec-uc-read
    - Detailed functional specifications:
      - @ref addb "Analysis and Diagnostics Data-Base API"
      - @ref addb_pvt "ADDB Internal Interfaces"
@@ -44,202 +51,93 @@
 
    The following data structures are involved in an ADDB monitoring
    infrastructure:
-   - m0_addb_monitoring_ctx
    - m0_addb_monitor
+   - m0_addb_monitor_global_ctx
    - m0_addb_sum_rec
 
    <hr>
    @section ADDB-DLD-fspec-sub Subroutines and Macros
 
    Interfaces needed for ADDB monitoring infrastructure
-   - m0_addb_monitors_init()
+   - m0_addb_monitor_subsystem_init()
    - m0_addb_monitor_add()
-   - m0_addb_monitor_del()
-   - m0_addb_monitors_fini()
-   - m0_addb_monitor_summaries_post()
+   - m0_addb_monitor_delete()
+   - m0_addb_monitor_subsystem_fini()
+   - m0_addb_post_summaries()
 
    <hr>
    @section ADDB-DLD-fspec-usecases Recipes
-   - @ref ADDB-DLD-fspec-uc-IAAM
+   - @ref ADDB-DLD-fspec-uc-create_monitor
+   - @ref ADDB-DLD-fspec-uc-PSMC
+   - @ref ADDB-DLD-fspec-uc-AWKMC
+   - @ref ADDB-DLD-fspec-uc-reg
+   - @ref ADDB-DLD-fspec-uc-post
+   - @ref ADDB-DLD-fspec-uc-cntr
+   - @ref ADDB-DLD-fspec-uc-read
 
-   @subsection ADDB-DLD-fspec-uc-IAAM Init & Add monitor
+   @subsection ADDB-DLD-fspec-uc-create_monitor Create monitor
 
-   This shows the series of steps that needs to be taken
-   for creating, initializing & adding the monitor into mero system.
-
-   @code
-	// 1. Add monitor to the structure that is to be monitored
-	//    or dynamically allocate them as mentioned in step 7.
-	//    Define key field to locate m0_addb_sum_rec for this monitor.
-	struct m0_xyz_module_struct {
-		.
-		.
-		.
-		struct m0_addb_monitor xms_mon;
-		uint32_t               xms_key;
-	};
-
-	Lets consider we have a variable available to access an instance
-	of struct m0_xyz_module_struct, viz. xyz_module_var.
-
-	// 2. Define the ADDB summary record type.
-	M0_ADDB_RT_DP(m0_addb_xyz, M0_ADDB_XYZ, "xyz_parm");
-
-	// 3. Define a new monitor specific stats data
-	// NOTE: The fields should be only uint64_t
-	struct xyz {
-		uint64_t x_parm;
-	};
-	Its upto the monitor implementer where to define a global variable for
-	this xyz or to embed it any top level structure. If dynamic
-	allocation is needed, it should be done as mentioned in step 7.
-
-	For this eq. lets consider it part of struct m0_xyz_module_struct
-	mentioned in step 1.
-	struct m0_xyz_module_struct {
-		.
-		.
-		.
-		struct xyz xms_xyz;
-	};
-	NOTE: fields of this struct should match in total number as well as
-	the meaning to the ADDB summary record type defined in 2 (serial order
-	should be maintained while defining the structure).
-
-	// 4. Define monitor operation amo_sum_rec
-	struct m0_add_sum_rec *xyz_amo_sum_rec(const struct m0_addb_monitor *mon,
-					       struct m0_reqh             *reqh)
-	{
-		return m0_reqh_lockers_get(reqh, xyz_key);
-	}
-
-	// 5. Define monitor operations amo_watch()
-	void xyz_amo_watch(struct m0_addb_monitor *monitor,
-			   struct m0_addb_rec *rec, struct m0_reqh *reqh)
-	{
-		// for addb rec of type X
-		struct m0_addb_sum_rec *xyz = reqh_lockers_get(reqh, xyz_key);
-
-		// NOTE: Locking is optional, use only when monitor implementor
-		// specifically wants to synchronize access to summary data.
-		m0_mutex_lock(&xyz->asr_mutex);
-		// update data
-		xyz->asr_dirty = true;
-		m0_mutex_unlock(&xyz->asr_mutex);
-	}
-
-	// 6. Define monitor ops struct and set these operations as initializers
-	const struct m0_addb_monitor_ops mon_ops = {
-		.amo_watch = xyz_amo_watch,
-		.amo_sum_rec = xyz_amo_sum_rec
-	};
-
-	// 7. Define monitor entry's init function
-	int xyz_ame_init(void)
-	{
-		//1. Dynamically allocate monitor(optional)
-		//2. Dynamically allocate instance of monitor specific data
-		//   here struct xyz (optional)
-		//3. Dynamically allocate instance of struct m0_addb_sum_rec
-		//4. Initialize monitor
-		//5. Initialize summary record (m0_addb_sum_rec)
-		//6. Add monitor to mero system
-		struct m0_addb_sum_rec *rec;
-		M0_ALLOC_PTR(rec);
-
-		m0_addb_monitor_init(&xyz_module_var.xms_mon, mon_ops);
-
-		m0_addb_monitor_sum_rec_init(rec, &m0_addb_xyz,
-					     &xyz_module_var.xms_xyz,
-					     sizeof(xyz_module_var.xms_xyz));
-		m0_addb_monitor_add(&xyz_module_var.xms_mon);
-	}
-
-	// 8. Define monitor entry's fini function
-	void xyz_ame_fini(void)
-	{
-		//1. Remove monitor from mero system
-		//2. Free summary record (m0_addb_sum_rec)
-		//3. Finalize monitor
-		//4. Free instance of monitor specific data (over here struct
-		//   xyz instance) (optional)
-		//5. Free monitor (optional)
-
-		m0_addb_monitor_del(&xyz_module_var.xms_mon);
-		m0_free(&xyz_module_var.xms_mon->am_ops->amo_sum_rec);
-		m0_addb_monitor_fini(&xyz_module_var.xms_mon);
-	}
-
-   @endcode
+   Series of steps
 */
 
 #include "addb/addb_monitor_wire.h"
 #include "rpc/conn.h"
 
-struct m0_reqh;
 struct m0_addb_monitor;
-struct addb_post_fom;
 
 M0_TL_DESCR_DECLARE(addb_mon, M0_EXTERN);
+//M0_TL_DELARE(addb_mon, M0_INTERNAL, struct m0_addb_monitor);
 
 struct m0_addb_sum_rec {
 	/**
-	 * This flag is true iff the record contains data still
-	 * not sent to the stats service.
+	 * If this is updated then asr_dirty: true
+	 * asr_dirty:false on sending this summary record to stats service
 	 */
 	bool                         asr_dirty;
-	/** This lock serializes access to this structure */
+	struct m0_tlink              asr_linkage;
+	/* This lock serializes access to this structure */
 	struct m0_mutex              asr_mutex;
-	/**
-	 * ADDB in-memory summary record
-	 * m0_addb_sum_rec_wire::asrw_rec::au64s_data is monitor
-	 * specific data
-	 */
-	struct m0_addb_sum_rec_wire  asr_rec;
+	/* ADDB on-wire summary record */
+	struct m0_addb_sum_rec_wire *asr_rec;
 };
 
-struct m0_addb_monitor_ops {
+struct m0_addb_monitor {
 	/**
-	 * This method is called on each addb record.
+	 * Linkage to global monitors list in
+	 * m0_addb_monitor_global_ctx:amgc_list
 	 */
-	void                    (*amo_watch) (const struct m0_addb_monitor *mon,
-					      const struct m0_addb_rec     *rec,
-					      const struct m0_reqh         *r);
-	/** Returns m0_addb_sum_rec, if any for this monitor. */
-	struct m0_addb_sum_rec *(*amo_sum_rec) (const struct m0_addb_monitor *m,
-					        const struct m0_reqh         *r);
-};
-
-struct m0_addb_monitor {
+	struct m0_tlink  am_linkage;
 	/**
-	 * Linkage to monitors list per reqh
-	 * reqh::m0_addb_monitoring_ctx::amc_list
+	 * Any processing specific to monitor is done here
+	 * includes, updates to the m0_addb_sum_rec data updation.
 	 */
-	struct m0_tlink                   am_linkage;
-	/** ADDB monitor operations vector */
-	const struct m0_addb_monitor_ops *am_ops;
+	void           (*am_watch) (const struct m0_addb_rec *rec,
+				    const struct m0_reqh     *reqh);
+	/* Returns m0_addb_sum_rec, if any for this monitor. */
+	struct m0_addb_sum_rec *(*am_sum_get) (const struct m0_reqh *reqh);
+	/**
+	 * Set the monitor specific m0_addb_sum_rec, if any
+	 * in the reqh's locker structure
+	 */
+	int           (*am_sum_set) (const struct m0_reqh *reqh);
 	/* Magic needed for monitor's tlist */
-	uint64_t                          am_magic;
+	uint64_t        am_magic;
 };
 
-/**
- * Monitor invariant
- */
-M0_INTERNAL bool m0_addb_monitor_invariant(struct m0_addb_monitor *mon);
+struct stats_conn {
+	struct m0_rpc_conn    sc_conn;
+	struct m0_rpc_session sc_session;
+	bool                  sc_connected;
+};
 
-/**
- * Monitoring sub-system collective information
- * object.
- */
-struct m0_addb_monitoring_ctx {
+struct m0_addb_monitor_global_ctx {
 	/* List of active monitors */
-	struct m0_tl                       amc_list;
-	/* Mutex to protect amc_list */
-	struct m0_mutex                    amc_mutex;
+	struct m0_tl                       amgc_list;
 	/* Stats service endpoint */
-	struct cs_endpoint_and_xprt       *amc_ex;
-	struct m0_rpc_conn                 amc_stats_conn;
-	struct m0_rpc_session              amc_stats_session;
+	struct cs_endpoint_and_xprt       *amgc_ex;
+	/* Stats service connection related thing */
+	struct stats_conn                  amgc_stats_conn;
+	const struct m0_reqh              *amgc_reqh;
 };
 
 /**
@@ -248,66 +146,50 @@ struct m0_addb_monitoring_ctx {
  * @param endpoint endpoint where stats service runs
  * @pre reqh != NULL
  * @pre endpoint != NULL
- * @post reqh::rh_addb_monitoring_ctx:amg_list initialized
+ * @post m0_addb_monitor_global_ctx:amgc_list initialized
+ * @post m0_addb_monitor_global_ctx:amgc_ex != NULL
  */
-M0_INTERNAL int m0_addb_monitors_init(struct m0_reqh *reqh,
-				      const char     *endpoint);
+M0_INTERNAL int m0_addb_monitor_subsys_init(const struct m0_reqh *reqh,
+					    const char           *endpoint);
 
 /**
- * Initialize ADDB monitor
+ * Allocate monitor & assign the monitoring specific function
  * @param monitor ADDB monitor object
  * @pre monitor != NULL
  * @pre (*am_watch) () != NULL
- * @pre rtype != NULL && m0_addb_rec_type_lookup(rtype->art_id) != NULL
  * @post *monitor != NULL
+ * @post monitor:am_watch == @param (*am_watch) ()
+ * @post monitor:am_sum_set == @param (*am_sum_set) ()
+ * @post monitor:am_sum_get == @param (*am_sum_get) ()
  */
-M0_INTERNAL void m0_addb_monitor_init(struct m0_addb_monitor           *monitor,
-				      const struct m0_addb_monitor_ops *mon_ops);
+M0_INTERNAL int m0_addb_monitor_init(struct m0_addb_monitor *monitor,
+			   void (*am_watch) (const struct m0_addb_rec *rec,
+					     const struct m0_reqh     *reqh),
+	struct m0_addb_sum_rec * (*am_sum_get) (const struct m0_reqh *reqh),
+			   int (*am_sum_set) (const struct m0_reqh *reqh));
 
 /**
- * Init m0_addb_sum_rec (Generic summary record structure)
- * @param sum_rec ADDB summary record to init
- * @param rtype   ADDB record type that this monitor would produce
- * @param mon_data uint64_t array of monitor specific data
- * @param nr No of uint64_t words.
- */
-M0_INTERNAL void m0_addb_sum_rec_init(struct m0_addb_sum_rec        *sum_rec,
-				      const struct m0_addb_rec_type *rtype,
-				      uint64_t                      *mon_data,
-				      size_t                         nr);
-/**
  * Add a particular monitor with the ADDB monitoring sub-system
- * @param reqh Request handler
  * @param monitor ADDB monitor to register
  */
-M0_INTERNAL void m0_addb_monitor_add(struct m0_reqh *reqh,
-				     struct m0_addb_monitor *monitor);
+M0_INTERNAL void m0_addb_monitor_add(struct m0_addb_monitor *monitor);
 
 /**
  * Delete a particular monitor from the ADDB monitoring sub-system
- * @param reqh Request handler
  * @param monitor ADDB monitor to unregister
  */
-M0_INTERNAL void m0_addb_monitor_del(struct m0_reqh *reqh,
-		                     struct m0_addb_monitor *monitor);
-
-/**
- * Finalize monitor
- * @param  monitor ADDB monitor to finalize
- */
-M0_INTERNAL void m0_addb_monitor_fini(struct m0_addb_monitor *monitor);
+M0_INTERNAL void m0_addb_monitor_del(struct m0_addb_monitor *monitor);
 
 /**
  * Cleanup the ADDB monitoring sub-system
  */
-M0_INTERNAL void m0_addb_monitors_fini(struct m0_reqh *reqh);
+M0_INTERNAL void m0_addb_monitor_subsys_fini(void);
 
 /**
  * This sends all the dirtied addb summary records for the added monitors
  * to the stats service as a fop.
  */
-M0_INTERNAL int m0_addb_monitor_summaries_post(struct m0_reqh       *reqh,
-					       struct addb_post_fom *fom);
+M0_INTERNAL int m0_addb_post_summaries(void);
 
 #endif /* __MERO_ADDB_ADDB_MONITOR_H__ */
 
diff --git a/addb/addb_monitor_wire.h b/addb/addb_monitor_wire.h
index 63e8b07..5120bd2 100644
--- a/addb/addb_monitor_wire.h
+++ b/addb/addb_monitor_wire.h
@@ -45,11 +45,20 @@ struct m0_addb_sum_rec_seq {
 
 struct m0_addb_sum_rec_wire {
 	/** This is addb_rec_type:art_id for this ADDB summary record */
-	uint32_t               asrw_id;
+	uint32_t                   asrw_id;
 	/* ADDB summary record data encoded in sequence form */
-	struct m0_addb_sum_req asrw_rec;
+	struct m0_addb_sum_rec_seq asrw_rec;
 } M0_XCA_RECORD;
 
+struct m0_addb_sum_rec_fop_data {
+	struct m0_addb_sum_rec_wire *asrfd_data M0_XCA_OPAQUE("m0_addb_sum_rec_wire_xc_type");
+} M0_XCA_RECORD;
+
+struct m0_addb_sum_rec_fop {
+	uint32_t asrf_nr;
+	struct m0_addb_sum_rec_fop_data *asrf_recs;
+} M0_XCA_SEQUENCE;
+
 #endif /* __MERO_ADDB_ADDB_MONITOR_WIRE_H__ */
 
 /*
diff --git a/addb/addb_pfom.c b/addb/addb_pfom.c
index b8d80d4..b340012 100644
--- a/addb/addb_pfom.c
+++ b/addb/addb_pfom.c
@@ -250,8 +250,7 @@ static int addb_pfom_fo_tick(struct m0_fom *fom)
 		M0_LOG(M0_DEBUG, "post");
 		m0_reqh_stats_post_addb(reqh);
 
-		err = m0_addb_monitor_summaries_post(svc->as_reqhs.rs_reqh,
-						     pfom);
+		err = m0_addb_post_summaries();
 
 		/**
 		 * In case of summaries posting failure, just log error.
diff --git a/addb/addb_rec.c b/addb/addb_rec.c
index 82cce73..30ddb4b 100644
--- a/addb/addb_rec.c
+++ b/addb/addb_rec.c
@@ -152,22 +152,10 @@ static void addb_rec_post(struct m0_addb_mc *mc,
 	 */
 	mc->am_evmgr->evm_post(mc, rec);
 
-	/**
-	 * This conditional traversing is required, since for many UTs
-	 * we do not have reqh and so we do not want to traverse.
-	 * @todo: Find a way to remove this condition and instead assert
-	 * on not NULL.
-	 */
-	if (mc->am_reqh != NULL) {
-		/* Invoke all the monitor's filters */
-		m0_mutex_lock(&mc->am_reqh->rh_addb_monitoring_ctx.amc_mutex);
-		m0_tl_for(addb_mon,
-			  &mc->am_reqh->rh_addb_monitoring_ctx.amc_list, mon) {
-			M0_ASSERT(m0_addb_monitor_invariant(mon));
-			mon->am_ops->amo_watch(mon, rec, mc->am_reqh);
-		} m0_tl_endfor;
-		m0_mutex_unlock(&mc->am_reqh->rh_addb_monitoring_ctx.amc_mutex);
-	}
+	/* Invoke all the monitor's filters */
+	m0_tl_for(addb_mon, &monitor_global_ctx.amgc_list, mon) {
+		mon->am_watch(rec, monitor_global_ctx.amgc_reqh);
+	} m0_tl_endfor;
 }
 
 #ifndef __KERNEL__
diff --git a/addb/addb_svc.c b/addb/addb_svc.c
index 9c4af4b..75f0d5c 100644
--- a/addb/addb_svc.c
+++ b/addb/addb_svc.c
@@ -98,10 +98,21 @@ static bool addb_svc_invariant(const struct addb_svc *svc)
 static int addb_svc_rso_start(struct m0_reqh_service *service)
 {
 	struct addb_svc *svc;
+	int              rc;
 
 	M0_LOG(M0_DEBUG, "starting");
 	M0_PRE(m0_reqh_service_state_get(service) == M0_RST_STARTING);
 
+	/* @todo: Pass correct stats service endpoint */
+	rc = m0_addb_monitor_subsys_init(service->rs_reqh,
+					 "REPLACE-ME");
+	/**
+	 * On monitoring subsystem initialization failure, we just
+	 * log and not terminate the addb service.
+	 */
+	if (rc != 0)
+		M0_LOG(M0_ERROR, "addb monitoring subsystem initialization");
+
 	svc = bob_of(service, struct addb_svc, as_reqhs, &addb_svc_bob);
 	if (addb_svc_start_pfom)
 		addb_pfom_start(svc);
@@ -182,6 +193,7 @@ static int addb_svc_rsto_service_allocate(struct m0_reqh_service **service,
 	m0_cond_init(&svc->as_cond, &(*service)->rs_mutex);
 	addb_svc_bob_init(svc);
 
+
 	M0_POST(addb_svc_invariant(svc));
 
 	return 0;
diff --git a/m0t1fs/linux_kernel/m0t1fs.c b/m0t1fs/linux_kernel/m0t1fs.c
index ee1b57f..eb4713f 100644
--- a/m0t1fs/linux_kernel/m0t1fs.c
+++ b/m0t1fs/linux_kernel/m0t1fs.c
@@ -139,10 +139,15 @@ M0_INTERNAL int m0t1fs_init(void)
 	if (rc != 0)
 		goto net_fini;
 
-	rc = m0t1fs_layout_init();
+	/* @todo: Need to give proper stats service endpoint */
+	rc = m0_addb_monitor_subsys_init(&m0t1fs_globals.g_reqh, "REPLACE-ME");
 	if (rc != 0)
 		goto rpc_fini;
 
+	rc = m0t1fs_layout_init();
+	if (rc != 0)
+		goto mon_fini;
+
 	rc = register_filesystem(&m0t1fs_fs_type);
 	if (rc != 0)
 		goto layout_fini;
@@ -152,6 +157,8 @@ M0_INTERNAL int m0t1fs_init(void)
 
 layout_fini:
 	m0t1fs_layout_fini();
+mon_fini:
+	m0_addb_monitor_subsys_fini();
 rpc_fini:
 	m0t1fs_rpc_fini();
 net_fini:
diff --git a/m0t1fs/m0t1fs_addb.h b/m0t1fs/m0t1fs_addb.h
index c071310..cb6bc3d 100644
--- a/m0t1fs/m0t1fs_addb.h
+++ b/m0t1fs/m0t1fs_addb.h
@@ -24,9 +24,6 @@
 
 #include "addb/addb.h"
 #include "addb/addb_monitor.h"
-#ifdef __KERNEL__
-#include "fop/fom_simple.h"
-#endif
 
 /*
  ******************************************************************************
diff --git a/mero/magic.h b/mero/magic.h
index 74a6481..3c74651 100644
--- a/mero/magic.h
+++ b/mero/magic.h
@@ -117,7 +117,7 @@ enum m0_magic_satchel {
 	/* ADDB monitor list's head (addb hellhole) */
 	M0_ADDB_MONITOR_LIST_HEAD_MAGIC = 0x33addb3704773477,
 
-	/* ADDB monitor (addb shoebill) */
+	/* ADDB monitor (addb shoebill)*/
 	M0_ADDB_MONITOR_LIST_LINK_MAGIC = 0x33addb7719304577,
 
 /* balloc */
-- 
1.8.3.2

