From c8f74411838b1ef619b262d80c925ffb5b021338 Mon Sep 17 00:00:00 2001
From: Rohan Puri <rohan_puri@xyratex.com>
Date: Thu, 24 Oct 2013 19:06:04 +0530
Subject: [PATCH 108/121] Changes summary : - 1. Add one more new case for UT
 of addb monitor infrastructure.    - Check that the fop does not gets sent
 (by validating that the      stats are not updated at stats service), when
 there is memory      allocation failure in m0_addb_monitor_summaries_post().
 This is done      using Fault Injection. 2. This UT does not require rpcsink
 configuration, removed not-needed code    related to this.

These changes are part of round 1 review of addb-monitor-infrastructure
at link http://reviewboard.clusterstor.com/r/1544/
---
 addb/addb_monitor.c         |  5 +++
 addb/ut/addb_ut.c           |  4 +-
 addb/ut/addb_ut_mon_infra.c | 90 ++++++++++++++++++++++++---------------------
 3 files changed, 56 insertions(+), 43 deletions(-)

diff --git a/addb/addb_monitor.c b/addb/addb_monitor.c
index b9eb383..5a3056f 100644
--- a/addb/addb_monitor.c
+++ b/addb/addb_monitor.c
@@ -520,7 +520,12 @@ M0_INTERNAL int m0_addb_monitor_summaries_post(struct m0_reqh       *reqh,
 				M0_ALLOC_ARR(fop->suf_stats.sf_stats,
 					     stats_batch);
 		}
+		if (M0_FI_ENABLED("mem_err")) {
+			data = NULL;
+			goto err1_injected;
+		}
 		data = m0_alloc(SUM_SIZE(sum));
+err1_injected:
 		if (fop == NULL || fop->suf_stats.sf_stats == NULL ||
 		    data == NULL) {
 			result = -ENOMEM;
diff --git a/addb/ut/addb_ut.c b/addb/ut/addb_ut.c
index 7d23fc3..be8da44 100644
--- a/addb/ut/addb_ut.c
+++ b/addb/ut/addb_ut.c
@@ -111,12 +111,12 @@ const struct m0_test_suite m0_addb_ut = {
 		{ "addb-rpc-sink",	     addb_ut_rpcsink_test },
 		{ "addb-smcntr",             addb_ut_smcntr_test },
 #ifndef __KERNEL__
+		{ "addb-fom",                addb_ut_fom_test },
+		{ "addb-mon-infra",          addb_ut_mon_infra_test },
 		{ "addb-rpc-sink-shutdown",  addb_ut_rpcsink_shutdown_test },
 		{ "addb-stobsink-search",    addb_ut_stobsink_search },
 		{ "addb-stob-post-retrieve", addb_ut_stob },
 		{ "addb-svc",                addb_ut_svc_test },
-		{ "addb-fom",                addb_ut_fom_test },
-		{ "addb-mon-infra",          addb_ut_mon_infra_test },
 #endif
 		{ NULL, NULL }
         }
diff --git a/addb/ut/addb_ut_mon_infra.c b/addb/ut/addb_ut_mon_infra.c
index 2070338..633aa12 100644
--- a/addb/ut/addb_ut_mon_infra.c
+++ b/addb/ut/addb_ut_mon_infra.c
@@ -38,9 +38,9 @@ struct m0_addb_monitor  ut_mon[UT_ADDB_MONS_NR];
 uint32_t                ut_mon_data_key[UT_ADDB_MONS_NR];
 struct m0_reqh         *ut_srv_reqh;
 uint32_t                stats_id[UT_ADDB_MONS_NR];
-struct m0_addb_ctx        *cv[4] = { NULL, &m0_addb_proc_ctx,
+struct m0_addb_ctx     *cv[4] = { NULL, &m0_addb_proc_ctx,
 				     &m0_addb_node_ctx, NULL };
-struct stats_svc          *stats_srv;
+struct stats_svc       *stats_srv;
 
 struct ut_monitor_sum_data1 {
 	uint64_t umsd_field1;
@@ -200,6 +200,7 @@ const struct m0_addb_monitor_ops ut_mon_ops = {
 enum {
 	MON_TEST_1 = 1,
 	MON_TEST_2 = 2,
+	MON_TEST_3 = 3,
 };
 
 static void addb_ut_mon_init(struct m0_addb_rec_type *rtype, int idx,
@@ -282,16 +283,21 @@ static void addb_post_record(struct m0_addb_mc *mc, int idx,
 	}
 }
 
-static void addb_ut_mon_verify_stats_data(struct stats_svc *stats_srv, int idx)
+static void addb_ut_mon_verify_stats_data(struct stats_svc *stats_srv, int idx,
+					  int test_no)
 {
 	struct m0_stats *stats;
 	int              i;
 
 	stats = m0_stats_get(&stats_srv->ss_stats, stats_id[idx]);
 	M0_UT_ASSERT(stats != NULL);
-	for (i = 0; i < idx; ++i)
+	for (i = 0; i < idx; ++i) {
+		if (test_no == MON_TEST_3)
+		M0_UT_ASSERT(stats->s_sum.ss_data.au64s_data[i] == 0);
+		else
 		M0_UT_ASSERT(stats->s_sum.ss_data.au64s_data[i]
 			     == ((i + 1) * 10));
+	}
 }
 
 static void clear_stats(struct stats_svc *stats_srv, int idx)
@@ -325,7 +331,7 @@ static void mon_test_1(void)
 		addb_post_record(&ut_srv_reqh->rh_addb_mc, i, cv);
 	m0_nanosleep(m0_time(0, 2 * 1000 * 1000 * 100), NULL);
 	for (i = 1; i < UT_ADDB_MONS_NR; ++i) {
-		addb_ut_mon_verify_stats_data(stats_srv, i);
+		addb_ut_mon_verify_stats_data(stats_srv, i, MON_TEST_1);
 		addb_ut_mon_fini(i);
 	}
 }
@@ -333,11 +339,6 @@ static void mon_test_1(void)
 static void mon_test_2(void)
 {
 	int i;
-	int default_batch = stats_batch;
-
-	m0_mutex_lock(&ut_srv_reqh->rh_addb_monitoring_ctx.amc_mutex);
-	stats_batch = 5;
-	m0_mutex_unlock(&ut_srv_reqh->rh_addb_monitoring_ctx.amc_mutex);
 
 	for (i = 1; i < UT_ADDB_MONS_NR; ++i) {
 		addb_ut_mon_init(DPRT_P(i), i, MON_TEST_2);
@@ -346,24 +347,36 @@ static void mon_test_2(void)
 		addb_post_record(&ut_srv_reqh->rh_addb_mc, i, cv);
 	m0_nanosleep(m0_time(0, 4 * 1000 * 1000 * 100), NULL);
 	for (i = 1; i < UT_ADDB_MONS_NR; ++i) {
-		addb_ut_mon_verify_stats_data(stats_srv, i);
+		addb_ut_mon_verify_stats_data(stats_srv, i, MON_TEST_2);
+		addb_ut_mon_fini(i);
+	}
+}
+
+static void mon_test_3(void)
+{
+	int i;
+
+	for (i = 1; i < UT_ADDB_MONS_NR; ++i) {
+		addb_ut_mon_init(DPRT_P(i), i, MON_TEST_3);
+	}
+	for (i = 1; i < UT_ADDB_MONS_NR; ++i)
+		addb_post_record(&ut_srv_reqh->rh_addb_mc, i, cv);
+	m0_nanosleep(m0_time(0, 4 * 1000 * 1000 * 100), NULL);
+	for (i = 1; i < UT_ADDB_MONS_NR; ++i) {
+		addb_ut_mon_verify_stats_data(stats_srv, i, MON_TEST_3);
 		addb_ut_mon_fini(i);
 	}
-	/* Reset to default */
-	m0_mutex_lock(&ut_srv_reqh->rh_addb_monitoring_ctx.amc_mutex);
-	stats_batch = default_batch;
-	m0_mutex_unlock(&ut_srv_reqh->rh_addb_monitoring_ctx.amc_mutex);
 }
 
 static void addb_ut_mon_infra_test(void)
 {
 	struct m0_reqh_service    *reqh_srv;
-	struct rpcsink            *rsink;
 	m0_time_t                  temp_time;
-	uint32_t		   rec_count;
-	int                        rc;
 	int                        i;
+	int                        default_batch = stats_batch;
 
+	/* Do not need to collect any data */
+	addb_rec_post_ut_data_enabled = false;
 	temp_time = addb_pfom_period;
 	addb_pfom_period = M0_MKTIME(0, 1 * 1000 * 1000 * 100);
 	sctx.rsx_argv = addb_mon_infra_server_argv;
@@ -374,32 +387,12 @@ static void addb_ut_mon_infra_test(void)
 	M0_UT_ASSERT(reqh_srv != NULL);
 	stats_srv = container_of(reqh_srv, struct stats_svc, ss_reqhs);
 
-	m0_addb_mc_init(&mc);
-	rc = m0_addb_mc_configure_rpc_sink(&mc, &cctx.rcx_rpc_machine, NULL,
-					   UT_ADDB_MON_TS_INIT_PAGES,
-					   UT_ADDB_MON_TS_MAX_PAGES,
-					   UT_ADDB_MON_TS_PAGE_SIZE);
-	M0_UT_ASSERT(rc == 0);
-	M0_UT_ASSERT(m0_addb_mc_has_rpc_sink(&mc));
-
-	rsink = rpcsink_from_mc(&mc);
-	M0_UT_ASSERT(rsink != NULL);
-	M0_UT_ASSERT(rsink->rs_ts.at_pages.ov_vec.v_nr ==
-		     UT_ADDB_MON_TS_INIT_PAGES);
-	M0_UT_ASSERT(rsink->rs_ts.at_max_pages ==
-		     UT_ADDB_MON_TS_MAX_PAGES);
-	M0_UT_ASSERT(rsink->rs_ts.at_page_size ==
-		     UT_ADDB_MON_TS_PAGE_SIZE);
-
-	rec_count = rec_queue_tlist_length(&rsink->rs_ts.at_rec_queue);
-	M0_UT_ASSERT(rec_count == 0);
-
-	m0_addb_mc_configure_pt_evmgr(&mc);
 	m0__addb_ut_ct0.act_magic = 0;
 	m0__addb_ut_ct0.act_id = addb_ct_max_id + 1;
 	m0_addb_ctx_type_register(&m0__addb_ut_ct0);
 
-	M0_ADDB_CTX_INIT(&mc, &ctx, &m0__addb_ut_ct0, &m0_addb_proc_ctx);
+	M0_ADDB_CTX_INIT(&ut_srv_reqh->rh_addb_mc, &ctx, &m0__addb_ut_ct0,
+			 &m0_addb_proc_ctx);
 	cv[0] = &ctx;
 
 	mon_test_1();
@@ -407,9 +400,24 @@ static void addb_ut_mon_infra_test(void)
 		((struct ut_monitor_sum_data1 *)MON_DATA(i))->umsd_field1 = 0;
 		clear_stats(stats_srv, i);
 	}
+
+	m0_mutex_lock(&ut_srv_reqh->rh_addb_monitoring_ctx.amc_mutex);
+	stats_batch = 5;
+	m0_mutex_unlock(&ut_srv_reqh->rh_addb_monitoring_ctx.amc_mutex);
+
 	mon_test_2();
+	for (i = 1; i < UT_ADDB_MONS_NR; ++i) {
+		((struct ut_monitor_sum_data1 *)MON_DATA(i))->umsd_field1 = 0;
+		clear_stats(stats_srv, i);
+	}
+	m0_fi_enable("m0_addb_monitor_summaries_post", "mem_err");
+	mon_test_3();
+
+	/* Reset to default */
+	m0_mutex_lock(&ut_srv_reqh->rh_addb_monitoring_ctx.amc_mutex);
+	stats_batch = default_batch;
+	m0_mutex_unlock(&ut_srv_reqh->rh_addb_monitoring_ctx.amc_mutex);
 
-	m0_addb_mc_fini(&mc);
 	stop_rpc_client_and_server();
 
 	/* Reset to default */
-- 
1.8.3.2

