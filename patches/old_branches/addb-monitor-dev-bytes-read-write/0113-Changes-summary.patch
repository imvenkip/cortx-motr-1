From c8816a39a3790c6f6cbe13b4c63875be3427288e Mon Sep 17 00:00:00 2001
From: Rohan Puri <rohan_puri@xyratex.com>
Date: Mon, 28 Oct 2013 15:36:03 +0530
Subject: [PATCH 113/121] Changes summary : - 1. Remove duplicate stats ep NULL
 check in stats_conn_init(). 2. Some Style fixes. 3. Code reorganization to
 remove duplicate code in UT. 4. Remove unnecessary mutex lock in
 sum_rec_fini(). 5. Make NULL check for stats conn, instead of stats ep.

These changes are part of round 2 review addb-monitoring-infrastructure
at link http://reviewboard.clusterstor.com/r/1544/
---
 addb/addb_monitor.c         | 44 ++++++++++++++--------------------
 addb/addb_pfom.c            |  2 +-
 addb/ut/addb_ut_mon_infra.c | 57 ++++++++++++++++++++++++++++-----------------
 m0t1fs/linux_kernel/super.c |  2 +-
 mero/setup.c                |  3 ++-
 stats/stats_addb.h          |  2 --
 6 files changed, 57 insertions(+), 53 deletions(-)

diff --git a/addb/addb_monitor.c b/addb/addb_monitor.c
index 41c99f7..c4190b5 100644
--- a/addb/addb_monitor.c
+++ b/addb/addb_monitor.c
@@ -206,14 +206,8 @@ M0_INTERNAL int m0_addb_monitor_stats_svc_conn_init(struct m0_reqh *reqh)
 
 	stats_svc_ep = mero->cc_stats_svc_epx.ex_endpoint;
 
-	if (stats_svc_ep == NULL) {
-		STATS_ADDB_FUNCFAIL(0, SVC_CONN_ESTABLISH_1,
-				    &m0_addb_monitors_mod_ctx);
-		M0_RETURN(0);
-	}
-
 	STATS_ALLOC_PTR(mon_ctx->amc_stats_conn, &m0_addb_monitors_mod_ctx,
-			SVC_CONN_ESTABLISH_2);
+			SVC_CONN_ESTABLISH_1);
 	if (mon_ctx->amc_stats_conn == NULL)
 		M0_RETURN(-ENOMEM);
 	rc = addb_mon_rpc_client_connect(mon_ctx->amc_stats_conn,
@@ -222,7 +216,7 @@ M0_INTERNAL int m0_addb_monitor_stats_svc_conn_init(struct m0_reqh *reqh)
 					 ADDB_STATS_MAX_RPCS_IN_FLIGHT);
 
 	if (rc != 0) {
-		STATS_ADDB_FUNCFAIL(rc, SVC_CONN_ESTABLISH_3,
+		STATS_ADDB_FUNCFAIL(rc, SVC_CONN_ESTABLISH_2,
 				    &m0_addb_monitors_mod_ctx);
 		m0_free(mon_ctx->amc_stats_conn);
 		M0_RETURN(rc);
@@ -286,29 +280,27 @@ M0_INTERNAL void m0_addb_monitor_init(struct m0_addb_monitor           *monitor,
 	addb_mon_tlink_init(monitor);
 }
 
-M0_INTERNAL void m0_addb_monitor_sum_rec_init(struct m0_addb_sum_rec        *sum_rec,
-					      const struct m0_addb_rec_type *rtype,
-					      uint64_t                      *mon_data,
+M0_INTERNAL void m0_addb_monitor_sum_rec_init(struct m0_addb_sum_rec        *rec,
+					      const struct m0_addb_rec_type *rt,
+					      uint64_t                      *md,
 					      size_t                         nr)
 {
-	M0_PRE(sum_rec != NULL && rtype != NULL && mon_data != NULL &&
+	M0_PRE(rec != NULL && rt != NULL && md != NULL &&
 	       nr > 0);
 
-	m0_mutex_init(&sum_rec->asr_mutex);
-	sum_rec->asr_rec.ss_id              = rtype->art_id;
-	sum_rec->asr_rec.ss_data.au64s_nr   = nr;
-	sum_rec->asr_rec.ss_data.au64s_data = mon_data;
+	m0_mutex_init(&rec->asr_mutex);
+	rec->asr_rec.ss_id              = rt->art_id;
+	rec->asr_rec.ss_data.au64s_nr   = nr;
+	rec->asr_rec.ss_data.au64s_data = md;
 }
 
 M0_INTERNAL void m0_addb_monitor_sum_rec_fini(struct m0_addb_sum_rec *sum_rec)
 {
 	M0_PRE(sum_rec != NULL);
 
-	m0_mutex_lock(&sum_rec->asr_mutex);
 	sum_rec->asr_rec.ss_id              = M0_STATS_ID_UNDEFINED;
 	sum_rec->asr_rec.ss_data.au64s_nr   = 0;
 	sum_rec->asr_rec.ss_data.au64s_data = NULL;
-	m0_mutex_unlock(&sum_rec->asr_mutex);
 
 	m0_mutex_fini(&sum_rec->asr_mutex);
 }
@@ -365,8 +357,8 @@ M0_INTERNAL void m0_addb_monitor_stats_svc_conn_fini(struct m0_reqh *reqh)
 	if (rc != 0)
 		STATS_ADDB_FUNCFAIL(rc, SVC_CONN_FINI_2,
 				    &m0_addb_monitors_mod_ctx);
-	mon_ctx->amc_stats_conn    = NULL;
-	mon_ctx->amc_stats_ep      = NULL;
+	mon_ctx->amc_stats_conn = NULL;
+	mon_ctx->amc_stats_ep   = NULL;
 }
 #endif
 
@@ -443,13 +435,13 @@ static int addb_monitor_stats_fop_send(struct m0_stats_update_fop *fop_data,
 	m0_fop_init(stats_update_fop, &m0_fop_stats_update_fopt,
 		    (void *) fop_data, addb_monitor_stats_fop_release);
 
-	item                     = &stats_update_fop->f_item;
-	item->ri_prio            = M0_RPC_ITEM_PRIO_MIN;
+	item             = &stats_update_fop->f_item;
+	item->ri_prio    = M0_RPC_ITEM_PRIO_MIN;
 	/**
 	 * @todo: Need to check what should be optimal value for
 	 * item deadline. Should be done during performance optimization.
 	 */
-	item->ri_deadline        = 0;
+	item->ri_deadline = 0;
 
 	rc = m0_rpc_oneway_item_post(conn, item);
 	m0_fop_put(stats_update_fop);
@@ -481,9 +473,9 @@ M0_INTERNAL int m0_addb_monitor_summaries_post(struct m0_reqh       *reqh,
 
 	m0_mutex_lock(&reqh->rh_addb_monitoring_ctx.amc_mutex);
 	while (scanned < SCANNED_LIMIT && sent < SENT_LIMIT) {
-		struct m0_addb_sum_rec      *sum;
-		struct m0_stats_sum         *rec;
-		void                        *data;
+		struct m0_addb_sum_rec *sum;
+		struct m0_stats_sum    *rec;
+		void                   *data;
 
 		/* end of list reached, wrap around or the list is empty */
 		if (mon == NULL) {
diff --git a/addb/addb_pfom.c b/addb/addb_pfom.c
index 95612a4..ac18c5d 100644
--- a/addb/addb_pfom.c
+++ b/addb/addb_pfom.c
@@ -250,7 +250,7 @@ static int addb_pfom_fo_tick(struct m0_fom *fom)
 		M0_LOG(M0_DEBUG, "post");
 		m0_reqh_stats_post_addb(reqh);
 
-		if (reqh->rh_addb_monitoring_ctx.amc_stats_ep != NULL)
+		if (reqh->rh_addb_monitoring_ctx.amc_stats_conn != NULL)
 			err = m0_addb_monitor_summaries_post(reqh, pfom);
 		/**
 		 * In case of summaries posting failure, just log error.
diff --git a/addb/ut/addb_ut_mon_infra.c b/addb/ut/addb_ut_mon_infra.c
index 633aa12..05b06d6 100644
--- a/addb/ut/addb_ut_mon_infra.c
+++ b/addb/ut/addb_ut_mon_infra.c
@@ -311,6 +311,19 @@ static void clear_stats(struct stats_svc *stats_srv, int idx)
 		stats->s_sum.ss_data.au64s_data[i] = 0;
 }
 
+static void mon_test(int test_no)
+{
+	int i;
+
+	for (i = 1; i < UT_ADDB_MONS_NR; ++i)
+		addb_post_record(&ut_srv_reqh->rh_addb_mc, i, cv);
+	m0_nanosleep(m0_time(0, 4 * 1000 * 1000 * 100), NULL);
+	for (i = 1; i < UT_ADDB_MONS_NR; ++i) {
+		addb_ut_mon_verify_stats_data(stats_srv, i, test_no);
+		addb_ut_mon_fini(i);
+	}
+}
+
 static void mon_test_1(void)
 {
 	struct m0_addb_rec_type   *dp;
@@ -326,14 +339,7 @@ static void mon_test_1(void)
 		m0_addb_rec_type_register(dp);
 		addb_ut_mon_init(DPRT_P(i), i, MON_TEST_1);
 	}
-
-	for (i = 1; i < UT_ADDB_MONS_NR; ++i)
-		addb_post_record(&ut_srv_reqh->rh_addb_mc, i, cv);
-	m0_nanosleep(m0_time(0, 2 * 1000 * 1000 * 100), NULL);
-	for (i = 1; i < UT_ADDB_MONS_NR; ++i) {
-		addb_ut_mon_verify_stats_data(stats_srv, i, MON_TEST_1);
-		addb_ut_mon_fini(i);
-	}
+	mon_test(MON_TEST_1);
 }
 
 static void mon_test_2(void)
@@ -343,13 +349,7 @@ static void mon_test_2(void)
 	for (i = 1; i < UT_ADDB_MONS_NR; ++i) {
 		addb_ut_mon_init(DPRT_P(i), i, MON_TEST_2);
 	}
-	for (i = 1; i < UT_ADDB_MONS_NR; ++i)
-		addb_post_record(&ut_srv_reqh->rh_addb_mc, i, cv);
-	m0_nanosleep(m0_time(0, 4 * 1000 * 1000 * 100), NULL);
-	for (i = 1; i < UT_ADDB_MONS_NR; ++i) {
-		addb_ut_mon_verify_stats_data(stats_srv, i, MON_TEST_2);
-		addb_ut_mon_fini(i);
-	}
+	mon_test(MON_TEST_2);
 }
 
 static void mon_test_3(void)
@@ -359,13 +359,7 @@ static void mon_test_3(void)
 	for (i = 1; i < UT_ADDB_MONS_NR; ++i) {
 		addb_ut_mon_init(DPRT_P(i), i, MON_TEST_3);
 	}
-	for (i = 1; i < UT_ADDB_MONS_NR; ++i)
-		addb_post_record(&ut_srv_reqh->rh_addb_mc, i, cv);
-	m0_nanosleep(m0_time(0, 4 * 1000 * 1000 * 100), NULL);
-	for (i = 1; i < UT_ADDB_MONS_NR; ++i) {
-		addb_ut_mon_verify_stats_data(stats_srv, i, MON_TEST_3);
-		addb_ut_mon_fini(i);
-	}
+	mon_test(MON_TEST_3);
 }
 
 static void addb_ut_mon_infra_test(void)
@@ -395,6 +389,15 @@ static void addb_ut_mon_infra_test(void)
 			 &m0_addb_proc_ctx);
 	cv[0] = &ctx;
 
+	/**
+	 * End to End test :-
+	 * Create 9 different addb monitors add them to the system, post
+	 * 9 different addb records where each one is monitored by its
+	 * corresponding added monitor, generate summary records, verify
+	 * that they are communicated to stats service by traversing stats list
+	 * on stats service ep.
+	 * This test sends only one fop.
+	 */
 	mon_test_1();
 	for (i = 1; i < UT_ADDB_MONS_NR; ++i) {
 		((struct ut_monitor_sum_data1 *)MON_DATA(i))->umsd_field1 = 0;
@@ -405,12 +408,22 @@ static void addb_ut_mon_infra_test(void)
 	stats_batch = 5;
 	m0_mutex_unlock(&ut_srv_reqh->rh_addb_monitoring_ctx.amc_mutex);
 
+	/**
+	 * Add/remove monitors dynamically.
+	 * This test sends 2 fops covering both fop sending cases of
+	 * m0_addb_monitor_summaries_post()
+	 */
 	mon_test_2();
 	for (i = 1; i < UT_ADDB_MONS_NR; ++i) {
 		((struct ut_monitor_sum_data1 *)MON_DATA(i))->umsd_field1 = 0;
 		clear_stats(stats_srv, i);
 	}
 	m0_fi_enable("m0_addb_monitor_summaries_post", "mem_err");
+
+	/**
+	 * This test checks for memory failure case, where no fop
+	 * gets sent.
+	 */
 	mon_test_3();
 
 	/* Reset to default */
diff --git a/m0t1fs/linux_kernel/super.c b/m0t1fs/linux_kernel/super.c
index 31b8a82..0cc785d 100644
--- a/m0t1fs/linux_kernel/super.c
+++ b/m0t1fs/linux_kernel/super.c
@@ -989,7 +989,7 @@ static int m0t1fs_setup(struct m0t1fs_sb *csb, const struct mount_opts *mops)
 		m0_addb_monitor_setup(reqh, &ctx->sc_conn, ep_addr);
 		M0_LOG(M0_DEBUG, "Stats service connected");
 	} else
-		M0_LOG(M0_WARN, "Stats service ep not specified");
+		M0_LOG(M0_WARN, "Stats service not connected");
 	m0_confc_close(fs);
 	if (rc != 0)
 		goto end;
diff --git a/mero/setup.c b/mero/setup.c
index e8affbd..2d98ad2 100644
--- a/mero/setup.c
+++ b/mero/setup.c
@@ -1515,7 +1515,7 @@ static void cs_request_handler_stop(struct m0_reqh_context *rctx)
 	M0_ENTRY();
 
 	reqh = &rctx->rc_reqh;
-	if (reqh->rh_addb_monitoring_ctx.amc_stats_ep != NULL)
+	if (reqh->rh_addb_monitoring_ctx.amc_stats_conn != NULL)
 		m0_addb_monitor_stats_svc_conn_fini(reqh);
 	if (m0_reqh_state_get(reqh) == M0_REQH_ST_NORMAL)
 		m0_reqh_shutdown(reqh);
@@ -2218,6 +2218,7 @@ int m0_cs_start(struct m0_mero *cctx)
 	 * @todo: stats connection initialization should be done
 	 * in addb pfom, currently not being done due to some initialization
 	 * ordering issues.
+	 * RB link :- http://reviewboard.clusterstor.com/r/1544
 	 */
 	if (cctx->cc_stats_svc_epx.ex_endpoint != NULL)
 		cs_addb_monitor_stats_svc_conn_init(cctx);
diff --git a/stats/stats_addb.h b/stats/stats_addb.h
index fa6238a..f9b7a51 100644
--- a/stats/stats_addb.h
+++ b/stats/stats_addb.h
@@ -69,8 +69,6 @@ M0_ALLOC_PTR_ADDB(ptr, &m0_addb_gmc, M0_STATS_ADDB_LOC_##loc, ctx)
 enum {
 	M0_STATS_ADDB_LOC_SVC_CONN_ESTABLISH_1 = 10,
 	M0_STATS_ADDB_LOC_SVC_CONN_ESTABLISH_2 = 11,
-	M0_STATS_ADDB_LOC_SVC_CONN_ESTABLISH_3 = 12,
-	M0_STATS_ADDB_LOC_SVC_CONN_ESTABLISH_4 = 13,
 	M0_STATS_ADDB_LOC_SVC_CONN_FINI_1      = 20,
 	M0_STATS_ADDB_LOC_SVC_CONN_FINI_2      = 21,
 };
-- 
1.8.3.2

