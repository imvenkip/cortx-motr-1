From 8801467cf1f10652f031f4f7db7c0d947ad0b6de Mon Sep 17 00:00:00 2001
From: Andriy Tkachuk <andriy_tkachuk@xyratex.com>
Date: Mon, 16 Dec 2013 23:12:41 +0200
Subject: [PATCH 6/7] stob/linux_adieu: short read fixed

Short read case was not handled properly in vectored aio.
---
 stob/linux_adieu.c | 29 +++++++++++++++++++++++------
 1 file changed, 23 insertions(+), 6 deletions(-)

diff --git a/stob/linux_adieu.c b/stob/linux_adieu.c
index 80ffc3f..bbc13a9 100644
--- a/stob/linux_adieu.c
+++ b/stob/linux_adieu.c
@@ -100,6 +100,7 @@
  */
 struct ioq_qev {
 	struct iocb           iq_iocb;
+	m0_bcount_t           iq_nbytes;
 	/** Linkage to a per-domain admission queue
 	    (linux_domain::ioq_queue). */
 	struct m0_queue_link  iq_linkage;
@@ -216,7 +217,6 @@ static int linux_stob_io_launch(struct m0_stob_io *io)
 	uint32_t              frags = 0;
 	uint32_t              chunks; /* contiguous stob chunks */
 	m0_bcount_t           frag_size;
-	m0_bcount_t           total_size = 0;
 	int                   result = 0;
 	int                   i;
 	bool                  eosrc;
@@ -263,6 +263,7 @@ static int linux_stob_io_launch(struct m0_stob_io *io)
 		m0_bindex_t  off = io->si_stob.iv_index[dst.vc_seg] +
 				   dst.vc_offset;
 		m0_bindex_t  prev_off = ~0;
+		m0_bcount_t  chunk_size = 0;
 
 		qev->iq_io = io;
 		m0_queue_link_init(&qev->iq_linkage);
@@ -309,7 +310,7 @@ static int linux_stob_io_launch(struct m0_stob_io *io)
 			iov->iov_base = m0_stob_addr_open(buf,
 						LINUX_DOM_BSHIFT(ldom));
 			iov->iov_len  = frag_size << LINUX_DOM_BSHIFT(ldom);
-			total_size += frag_size;
+			chunk_size += frag_size;
 
 			m0_vec_cursor_move(&src, frag_size);
 			m0_vec_cursor_move(&dst, frag_size);
@@ -318,9 +319,10 @@ static int linux_stob_io_launch(struct m0_stob_io *io)
 		M0_LOG(M0_DEBUG, "["U128X_F"] %2d: frags=%d op=%d off=%lx sz=%lx",
 		       U128_P(&io->si_obj->so_id.si_bits),
 		       (int)(qev - lio->si_qev), i, io->si_opcode,
-		       (unsigned long)off, (unsigned long)total_size);
+		       (unsigned long)off, (unsigned long)chunk_size);
 		if (result == 0) {
 			iocb->u.c.nbytes = i;
+			qev->iq_nbytes = chunk_size << LINUX_DOM_BSHIFT(ldom);
 
 			ioq_queue_lock(ldom);
 			ioq_queue_put(ldom, qev);
@@ -469,10 +471,25 @@ static void ioq_complete(struct linux_domain *ldom, struct ioq_qev *qev,
 	M0_ASSERT(done < lio->si_nr);
 
 	/* short read. */
-	if (io->si_opcode == SIO_READ && res >= 0 && res < iocb->u.c.nbytes) {
+	M0_LOG(M0_DEBUG, "res=%lx nbytes=%lx", (unsigned long)res,
+					(unsigned long)qev->iq_nbytes);
+	if (io->si_opcode == SIO_READ && res >= 0 && res < qev->iq_nbytes) {
 		/* fill the rest of the user buffer with zeroes. */
-		memset(iocb->u.c.buf + res, 0, iocb->u.c.nbytes - res);
-		res = iocb->u.c.nbytes;
+		struct iovec *iov = iocb->u.c.buf;
+		int i;
+
+		for (i = 0; i < iocb->u.c.nbytes; ++i) {
+			if (iov->iov_len < res)
+				res -= iov->iov_len;
+			else if (res == 0)
+				memset(iov->iov_base, 0, iov->iov_len);
+			else {
+				memset(iov->iov_base + res, 0,
+							iov->iov_len - res);
+				res = 0;
+			}
+		}
+		res = qev->iq_nbytes;
 	}
 
 	if (res > 0) {
-- 
1.8.3.2

