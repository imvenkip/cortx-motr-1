From 9de549a92cf5370cf637cbf36fe4c8d60e22bd56 Mon Sep 17 00:00:00 2001
From: Andriy Tkachuk <andriy_tkachuk@xyratex.com>
Date: Wed, 11 Dec 2013 13:51:47 +0200
Subject: [PATCH 3/7] ioservice: fops leak fixed

I/O fops were not freed. As result, rpc items also were
not freed and were accumulated at rpc slots, that consumed
memory and affected the throughput after writing few GB
of data.

I/O fops are created (allocated and inited) and at the
m0_fop_item_type_default_decode() called from item_decode().
At the time of creation the reference count value of the
fop is 1 (one). Then the fop goes to m0_io_fom_cob_rw_create()
where the correspondent fom is created. In m0_fom_init()
we call m0_fop_get() for the fop increasing the counter
to 2 (two).

After the fop processing completes, we call m0_fop_put()
for the fop at the m0_fom_fini() decrementing its reference
counter to 1. And that's it - no one else was calling
m0_fop_put() for the fop anymore so it could be freed.
As result, the fops were getting stuck in m0d with theirs
rpc items in the slots.

Now, we call m0_fop_put() immediately after m0_fom_init()
so the fop is freed automatically on m0_fom_fini().

References: https://jira.xyratex.com/browse/MERO-75
---
 ioservice/io_foms.c | 1 +
 1 file changed, 1 insertion(+)

diff --git a/ioservice/io_foms.c b/ioservice/io_foms.c
index 9e6996c..9312116 100644
--- a/ioservice/io_foms.c
+++ b/ioservice/io_foms.c
@@ -1073,6 +1073,7 @@ static int m0_io_fom_cob_rw_create(struct m0_fop *fop, struct m0_fom **out,
 		    &ops, fop, rep_fop, reqh,
 		    fop->f_type->ft_fom_type.ft_rstype);
 	m0_fop_put(rep_fop);
+	m0_fop_put(fop);
 
 	fom_obj->fcrw_fom_start_time = m0_time_now();
 	fom_obj->fcrw_stob = NULL;
-- 
1.8.3.2

