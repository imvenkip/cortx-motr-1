From 69de0eca1db9005d52f5691fc9beec48d2a02f51 Mon Sep 17 00:00:00 2001
From: Andriy Tkachuk <andriy_tkachuk@xyratex.com>
Date: Wed, 11 Dec 2013 13:49:18 +0200
Subject: [PATCH 2/7] rpc: misordered item handling fixed

Misordered item handling had bugs and was not covered by
UT. This patch fixes this.

Misordered items appear when we free io fops. By now, io
fops were not freed - that's why we did not see this issue
before.
---
 rpc/frmops.c       |  8 +++++---
 rpc/session_fops.c |  2 +-
 rpc/slot.c         | 13 +++++++++----
 rpc/ut/item.c      | 24 +++++++++++++++++++++---
 4 files changed, 36 insertions(+), 11 deletions(-)

diff --git a/rpc/frmops.c b/rpc/frmops.c
index 9763e75..d0df901 100644
--- a/rpc/frmops.c
+++ b/rpc/frmops.c
@@ -427,11 +427,12 @@ static void item_done(struct m0_rpc_item *item, unsigned long rc)
 		rc = 0;
 		item->ri_error = 0;
 	}
-	if (rc == 0)
-		item_sent(item);
+
 	item->ri_error = item->ri_error ?: rc;
 	if (item->ri_error != 0)
 		m0_rpc_item_failed(item, item->ri_error);
+	else
+		item_sent(item);
 
 	M0_LEAVE();
 }
@@ -443,7 +444,8 @@ static void item_sent(struct m0_rpc_item *item)
 
 	M0_ENTRY("item: %p", item);
 
-	M0_PRE(M0_IN(item->ri_error, (0, -ETIMEDOUT)) &&
+	M0_PRE(ergo(m0_rpc_item_is_request(item),
+	            M0_IN(item->ri_error, (0, -ETIMEDOUT))) &&
 	       item->ri_sm.sm_state == M0_RPC_ITEM_SENDING);
 
 	m0_rpc_item_change_state(item, M0_RPC_ITEM_SENT);
diff --git a/rpc/session_fops.c b/rpc/session_fops.c
index 774c5ab..996383c 100644
--- a/rpc/session_fops.c
+++ b/rpc/session_fops.c
@@ -211,7 +211,7 @@ M0_INTERNAL int m0_rpc_session_fop_init(void)
 			 .name      = "No-op",
 			 .opcode    = M0_RPC_NOOP_OPCODE,
 			 .xt        = m0_rpc_fop_noop_xc,
-			 .rpc_flags = M0_RPC_ITEM_TYPE_REQUEST,
+			 .rpc_flags = M0_RPC_ITEM_TYPE_REPLY,
 			 .fop_ops   = &m0_rpc_fop_noop_ops,
 			 .svc_type  = &m0_rpc_service_type);
 }
diff --git a/rpc/slot.c b/rpc/slot.c
index a893e43..5b7aa45 100644
--- a/rpc/slot.c
+++ b/rpc/slot.c
@@ -113,12 +113,12 @@ M0_INTERNAL bool m0_rpc_slot_invariant(const struct m0_rpc_slot *slot)
 		 * the version number of slot is advanced
 		 */
 		ok = m0_rpc_item_is_update(item1) ?
-			_0C(v1->vn_vc + 1 == v2->vn_vc) :
-			_0C(v1->vn_vc == v2->vn_vc);
+			_0C(v1->vn_vc < v2->vn_vc) :
+			_0C(v1->vn_vc <= v2->vn_vc);
 		if (!ok)
 			return false;
 
-		ok = _0C(item_xid(item1, 0) + 1 == item_xid(item2, 0));
+		ok = _0C(item_xid(item1, 0) < item_xid(item2, 0));
 		if (!ok)
 			return false;
 
@@ -454,9 +454,11 @@ static void misordered_item_received(struct m0_rpc_slot *slot,
 	if (fop != NULL) {
 		reply = &fop->f_item;
 		reply->ri_session = item->ri_session;
+		reply->ri_rmachine = item->ri_rmachine;
 		reply->ri_error   = -EBADR;
 		reply->ri_slot_refs[0] = item->ri_slot_refs[0];
 		slot_item_tlink_init(reply);
+		m0_rpc_item_sm_init(reply, M0_RPC_ITEM_OUTGOING);
 
 		slot->sl_ops->so_reply_consume(item, reply);
 	}
@@ -473,6 +475,9 @@ M0_INTERNAL int m0_rpc_slot_item_apply(struct m0_rpc_slot *slot,
 	M0_ASSERT(m0_rpc_slot_invariant(slot));
 	M0_PRE(m0_rpc_machine_is_locked(slot_get_rpc_machine(slot)));
 
+	if (M0_FI_ENABLED("misorder_item"))
+		item->ri_slot_refs[0].sr_ow.osr_xid += 5;
+
 	if (item_xid(item, 0) == slot->sl_xid) {
 		/* valid in sequence */
 		__slot_item_add(slot, item);
@@ -494,7 +499,7 @@ static void duplicate_item_received(struct m0_rpc_slot *slot,
 	struct m0_rpc_item *req;
 
 	M0_ENTRY("slot: %p item: %p", slot, item);
-	/* item is a duplicate request. Find originial. */
+	/* item is a duplicate request. Find original. */
 	req = item_find(slot, item_xid(item, 0));
 	if (req == NULL) {
 		misordered_item_received(slot, item);
diff --git a/rpc/ut/item.c b/rpc/ut/item.c
index f4df3f3..17a1d48 100644
--- a/rpc/ut/item.c
+++ b/rpc/ut/item.c
@@ -30,6 +30,8 @@
 #include "rpc/ut/rpc_test_fops.h"
 #include "rpc/rpc_internal.h"
 
+enum { MILLISEC = 1000 * 1000 };
+
 static int __test(void);
 static void __test_timeout(m0_time_t deadline,
 			   m0_time_t timeout);
@@ -95,7 +97,6 @@ static void test_simple_transitions(void)
 static void test_timeout(void)
 {
 	int rc;
-	enum { MILLISEC = 1000 * 1000 };
 
 	/* Test2.1: Request item times out before reply reaches to sender.
 		    Delayed reply is then dropped.
@@ -250,9 +251,26 @@ static void test_resend(void)
 	M0_UT_ASSERT(item->ri_nr_sent == 3);
 	M0_UT_ASSERT(item->ri_reply != NULL);
 	M0_UT_ASSERT(chk_state(item, M0_RPC_ITEM_REPLIED));
-	m0_fop_put(fop);
 	M0_LOG(M0_DEBUG, "TEST:3.4:END");
 
+	M0_LOG(M0_DEBUG, "TEST:3.4.1:START");
+	/* CONTINUES TO USE fop/item FROM PREVIOUS TEST-CASE. */
+	/* Emulate misordered item.
+	 */
+	m0_fi_enable_once("m0_rpc_slot_item_apply", "misorder_item");
+	item->ri_nr_sent_max = 1;
+	item->ri_resend_interval = m0_time(0, 100 * MILLISEC);
+	item->ri_deadline = m0_time_from_now(1, 0);
+	m0_rpc_machine_lock(item->ri_rmachine);
+	m0_rpc_item_send(item);
+	m0_rpc_machine_unlock(item->ri_rmachine);
+	rc = m0_rpc_item_wait_for_reply(item, M0_TIME_NEVER);
+	M0_UT_ASSERT(rc == -ETIMEDOUT);
+	M0_UT_ASSERT(item->ri_error == -ETIMEDOUT);
+	M0_UT_ASSERT(chk_state(item, M0_RPC_ITEM_FAILED));
+	m0_fop_put(fop);
+	M0_LOG(M0_DEBUG, "TEST:3.4.1:END");
+
 	/* Test: INITIALISED -> FAILED transition when m0_rpc_post()
 		 fails to start item timer.
 	 */
@@ -487,7 +505,7 @@ static void test_bound_items(void)
 	   delivered in order.
 
 	   The test posts 100 request items on slot0 of session. Each fop
-	   carries its sequence number. Reciever simply copies the sequence
+	   carries its sequence number. Receiver simply copies the sequence
 	   number in reply fop. RPC is instructed to invoke
 	   bound_item_replied_cb() upon receiving reply to any of the request
 	   items. The callback ensures that the sequence number in
-- 
1.8.3.2

