From ddaf90412da308357e3ff6f30cee70a1d0312de2 Mon Sep 17 00:00:00 2001
From: Andriy Tkachuk <andriy_tkachuk@xyratex.com>
Date: Thu, 12 Dec 2013 20:29:56 +0200
Subject: [PATCH 4/7] stob/linux: vectored aio support added

We did not use vectored (i.e. scatter/gather) aio.
As result, most of our disk IO was performed by 4K
pages (got == 1 in most of the times at ioq_thread()).

Now, we use vectored aio.

References: http://reviewboard.clusterstor.com/r/1587
---
 stob/linux_adieu.c | 90 +++++++++++++++++++++++++++++++++++-------------------
 1 file changed, 59 insertions(+), 31 deletions(-)

diff --git a/stob/linux_adieu.c b/stob/linux_adieu.c
index e5e7f0b..9b85078 100644
--- a/stob/linux_adieu.c
+++ b/stob/linux_adieu.c
@@ -17,6 +17,9 @@
  * Original creation date: 05/21/2010
  */
 
+#include <limits.h>
+#include <sys/uio.h>
+
 #include "lib/misc.h"   /* M0_SET0 */
 #include "lib/errno.h"
 #include "lib/memory.h"
@@ -178,6 +181,8 @@ M0_INTERNAL int linux_stob_io_init(struct m0_stob *stob, struct m0_stob_io *io)
 
 static void linux_stob_io_release(struct linux_stob_io *lio)
 {
+	if (lio->si_qev != NULL)
+		m0_free(lio->si_qev->iq_iocb.u.c.buf);
 	m0_free(lio->si_qev);
 	lio->si_qev = NULL;
 }
@@ -204,6 +209,8 @@ static int linux_stob_io_launch(struct m0_stob_io *io)
 	struct linux_stob    *lstob  = stob2linux(io->si_obj);
 	struct linux_domain  *ldom   = domain2linux(io->si_obj->so_domain);
 	struct linux_stob_io *lio    = io->si_stob_private;
+	struct ioq_qev       *qev;
+	struct iovec         *iov;
 	struct m0_vec_cursor  src;
 	struct m0_vec_cursor  dst;
 	uint32_t              frags = 0;
@@ -236,16 +243,47 @@ static int linux_stob_io_launch(struct m0_stob_io *io)
 	m0_vec_cursor_init(&src, &io->si_user.ov_vec);
 	m0_vec_cursor_init(&dst, &io->si_stob.iv_vec);
 
-	lio->si_nr = frags;
+	lio->si_nr = frags / IOV_MAX + 1;
 	m0_atomic64_set(&lio->si_done, 0);
 	m0_atomic64_set(&lio->si_bdone, 0);
-	M0_ALLOC_ARR(lio->si_qev, frags);
+	M0_ALLOC_ARR(lio->si_qev, lio->si_nr);
+	M0_ALLOC_ARR(iov, frags);
+	qev = lio->si_qev;
+	if (qev == NULL || iov == NULL) {
+		M0_STOB_OOM(LAD_STOB_IO_LAUNCH_2);
+		result = -ENOMEM;
+	}
 
-	if (lio->si_qev != NULL) {
-		for (i = 0; i < frags; ++i) {
+	while (result == 0) {
+		struct iocb *iocb;
+
+		M0_ASSERT(qev - lio->si_qev < lio->si_nr);
+
+		qev->iq_io = io;
+		m0_queue_link_init(&qev->iq_linkage);
+
+		iocb = &qev->iq_iocb;
+		iocb->u.c.buf = iov;
+		iocb->aio_fildes = lstob->sl_fd;
+		iocb->u.c.nbytes = min32u(frags, IOV_MAX);
+		iocb->u.c.offset =
+			io->si_stob.iv_index[dst.vc_seg] + dst.vc_offset;
+
+		switch (io->si_opcode) {
+		case SIO_READ:
+			iocb->aio_lio_opcode = IO_CMD_PREADV;
+			break;
+		case SIO_WRITE:
+			iocb->aio_lio_opcode = IO_CMD_PWRITEV;
+			break;
+		default:
+			M0_ASSERT(0);
+		}
+
+		for (i = 0; i < iocb->u.c.nbytes; ++i) {
 			void        *buf;
 			m0_bindex_t  off;
-			struct iocb *iocb;
+			m0_bindex_t  old_off = ~0;
 
 			frag_size = min_check(m0_vec_cursor_step(&src),
 					      m0_vec_cursor_step(&dst));
@@ -258,49 +296,38 @@ static int linux_stob_io_launch(struct m0_stob_io *io)
 
 			buf = io->si_user.ov_buf[src.vc_seg] + src.vc_offset;
 			off = io->si_stob.iv_index[dst.vc_seg] + dst.vc_offset;
+			if (old_off != ~0)
+				M0_ASSERT(old_off + frag_size == off);
+			old_off = off;
 
-			iocb = &lio->si_qev[i].iq_iocb;
-			M0_SET0(iocb);
-
-			iocb->aio_fildes = lstob->sl_fd;
-			iocb->u.c.buf    = m0_stob_addr_open(buf,
+			iov->iov_base = m0_stob_addr_open(buf,
 						LINUX_DOM_BSHIFT(ldom));
-			iocb->u.c.nbytes = frag_size << LINUX_DOM_BSHIFT(ldom);
-			iocb->u.c.offset = off       << LINUX_DOM_BSHIFT(ldom);
+			iov->iov_len  = frag_size << LINUX_DOM_BSHIFT(ldom);
 			total_size += frag_size;
 
-			switch (io->si_opcode) {
-			case SIO_READ:
-				iocb->aio_lio_opcode = IO_CMD_PREAD;
-				break;
-			case SIO_WRITE:
-				iocb->aio_lio_opcode = IO_CMD_PWRITE;
-				break;
-			default:
-				M0_ASSERT(0);
-			}
-
 			m0_vec_cursor_move(&src, frag_size);
 			m0_vec_cursor_move(&dst, frag_size);
-			lio->si_qev[i].iq_io = io;
-			m0_queue_link_init(&lio->si_qev[i].iq_linkage);
+			++iov;
 		}
 		M0_LOG(M0_DEBUG, "frags=%d op=%d sz=%lu",
 		       i, io->si_opcode, (unsigned long)total_size);
 		if (result == 0) {
 			ioq_queue_lock(ldom);
-			for (i = 0; i < frags; ++i)
-				ioq_queue_put(ldom, &lio->si_qev[i]);
+			ioq_queue_put(ldom, qev);
 			ioq_queue_unlock(ldom);
-			ioq_queue_submit(ldom);
+
+			frags -= i;
+			if (frags == 0)
+				break;
+			++qev;
 		}
-	} else {
-		M0_STOB_OOM(LAD_STOB_IO_LAUNCH_2);
-		result = -ENOMEM;
 	}
 
 	if (result != 0)
 		linux_stob_io_release(lio);
+	else
+		ioq_queue_submit(ldom);
+
 	return result;
 }
 
@@ -492,6 +519,7 @@ static void ioq_thread(struct linux_domain *ldom)
 		ioq_timeout = ioq_timeout_default;
 		got = raw_io_getevents(ldom->ioq_ctx, 1, ARRAY_SIZE(evout),
 				       evout, &ioq_timeout);
+		M0_LOG(M0_DEBUG, "got=%d", got);
 		if (got > 0) {
 			avail = m0_atomic64_add_return(&ldom->ioq_avail, got);
 			M0_ASSERT(avail <= IOQ_RING_SIZE);
-- 
1.8.3.2

