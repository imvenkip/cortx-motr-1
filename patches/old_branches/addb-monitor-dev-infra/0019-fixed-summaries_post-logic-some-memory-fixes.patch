From af588adff29e01f8552ada1eb20fb3f6d29d527d Mon Sep 17 00:00:00 2001
From: Rohan Puri <rohan_puri@xyratex.com>
Date: Wed, 28 Aug 2013 16:44:04 +0530
Subject: [PATCH 019/107] fixed summaries_post() logic & some memory fixes

---
 addb/addb_monitor.c | 168 ++++++++++++++++++++++++++++++++--------------------
 1 file changed, 105 insertions(+), 63 deletions(-)

diff --git a/addb/addb_monitor.c b/addb/addb_monitor.c
index 0e15c80..01e1f6f 100644
--- a/addb/addb_monitor.c
+++ b/addb/addb_monitor.c
@@ -244,97 +244,139 @@ M0_INTERNAL void m0_addb_monitors_fini(struct m0_reqh *reqh)
 #define SUM_SIZE(sum) (sum->asr_rec.asrw_rec.au64s_nr * sizeof(uint64_t))
 
 enum {
+	START = 1,
 	BATCH = 1024
 };
 
+static uint32_t mon_list_get_dirtied_count(struct m0_reqh *reqh,
+				           struct m0_tl *mon_list,
+					   uint32_t where)
+{
+	struct m0_addb_monitor *mon;
+	struct m0_addb_sum_rec *sum_rec =  NULL;
+	int                     i = 0;
+	uint32_t                dirtied_count = 0;
+
+	M0_PRE(where <addb_mon_tlist_length(mon_list));
+
+	m0_tl_for(addb_mon, mon_list, mon) {
+		++i;
+		if (i < where)
+			continue;
+		sum_rec = mon->am_ops->amo_sum_rec(mon, reqh);
+		if (sum_rec && sum_rec->asr_dirty)
+			++dirtied_count;
+	}m0_tl_endfor;
+
+	M0_RETURN(dirtied_count);
+}
+
 M0_INTERNAL int m0_addb_monitor_summaries_post(struct m0_reqh *reqh)
 {
 	struct m0_addb_monitor       *mon;
 	struct m0_addb_sum_rec_fop   *sum_recs_fop;
 	uint32_t		      dirtied_mon_cnt;
 	uint32_t                      fop_mon_cnt = 0;
+	uint32_t                      dirtied_scanned = 0;
 	uint32_t                      scanned = 0;
 	struct m0_tl                 *mon_list;
 	int                           i = 0;
+	int                           idx = 0;
 	int                           rc = 0;
 
 	M0_PRE(reqh != NULL);
 
 	mon_list = &reqh->rh_addb_monitoring_ctx.amc_list;
-	do {
-		dirtied_mon_cnt = 0;
-		m0_tl_for(addb_mon, mon_list, mon) {
-			if (mon->am_ops->amo_sum_rec != NULL) {
-				struct m0_addb_sum_rec *sum =
+	dirtied_mon_cnt = mon_list_get_dirtied_count(reqh, mon_list, START);
+	if (dirtied_mon_cnt == 0)
+		M0_RETURN(rc);
+
+	M0_ALLOC_PTR(sum_recs_fop);
+	if (sum_recs_fop == NULL) {
+		rc = -ENOMEM;
+		M0_RETURN(rc);
+	}
+	fop_mon_cnt = min32u(dirtied_mon_cnt, BATCH);
+	M0_ALLOC_ARR(sum_recs_fop->asrf_recs, fop_mon_cnt);
+	if (sum_recs_fop->asrf_recs == NULL) {
+		rc = -ENOMEM;
+		m0_free(sum_recs_fop);
+		M0_RETURN(rc);
+	}
+
+	m0_tl_for(addb_mon, &reqh->rh_addb_monitoring_ctx.amc_list,
+			mon) {
+		struct m0_addb_sum_rec_wire  *sum_rec;
+		struct m0_addb_sum_rec       *sum =
 					mon->am_ops->amo_sum_rec(mon, reqh);
-				if (sum->asr_dirty)
-					++dirtied_mon_cnt;
-			}
-		} m0_tl_endfor;
-		if (dirtied_mon_cnt == 0)
-			break;
-		M0_ALLOC_PTR(sum_recs_fop);
-		if (sum_recs_fop == NULL) {
-			rc = -ENOMEM;
-			M0_RETURN(rc);
-		}
-		fop_mon_cnt = min32u(dirtied_mon_cnt, BATCH);
-		M0_ALLOC_ARR(sum_recs_fop->asrf_recs, fop_mon_cnt);
-		if (sum_recs_fop->asrf_recs == NULL) {
-			rc = -ENOMEM;
-			M0_RETURN(rc);
-		}
 
-		for(i = 0; i < fop_mon_cnt; ++i) {
-			struct m0_addb_sum_rec_wire  *sum_rec;
-			struct m0_addb_sum_rec       *sum =
-				mon->am_ops->amo_sum_rec(mon, reqh);
-
-			mon = addb_mon_tlist_head(mon_list);
-			addb_mon_tlist_move_tail(mon_list, mon);
-			++scanned;
-			if (!sum->asr_dirty ||
-			    mon->am_ops->amo_sum_rec == NULL)
-				continue;
-			m0_mutex_lock(&sum->asr_mutex);
-			sum_rec = &sum_recs_fop->asrf_recs[i++];
-			sum_rec->asrw_rec.au64s_data =
-				m0_alloc(SUM_SIZE(sum));
-
-			if (sum_rec->asrw_rec.au64s_data == NULL) {
+		++scanned;
+		if (sum == NULL || !sum->asr_dirty)
+			continue;
+		if (dirtied_scanned == fop_mon_cnt) {
+			sum_recs_fop->asrf_nr = fop_mon_cnt;
+			/**
+			 * @todo: Create & Send fop to stats service.
+			 */
+
+			/* Cleanup */
+			for (i = 0; i < fop_mon_cnt; ++i)
+				m0_free(sum_recs_fop->asrf_recs[i].asrw_rec.au64s_data);
+			m0_free(sum_recs_fop->asrf_recs);
+			dirtied_scanned = 0;
+			dirtied_mon_cnt = mon_list_get_dirtied_count(reqh,
+								     mon_list,
+								     scanned);
+			if (dirtied_mon_cnt == 0)
+				break;
+
+			/* Recalculate data for remaining records */
+			fop_mon_cnt = min32u(dirtied_mon_cnt, BATCH);
+			M0_ALLOC_ARR(sum_recs_fop->asrf_recs, fop_mon_cnt);
+			if (sum_recs_fop->asrf_recs == NULL) {
 				rc = -ENOMEM;
-				goto mem_fail;
+				break;
 			}
-			sum_rec->asrw_id = sum->asr_rec.asrw_id;
-			sum_rec->asrw_rec.au64s_nr =
-				sum->asr_rec.asrw_rec.au64s_nr;
-			memcpy(sum_rec->asrw_rec.au64s_data,
-					sum->asr_rec.asrw_rec.au64s_data,
-					SUM_SIZE(sum));
-			sum->asr_dirty = false;
+			idx = 0;
+			continue;
+		}
+		++dirtied_scanned;
+		m0_mutex_lock(&sum->asr_mutex);
+		sum_rec = &sum_recs_fop->asrf_recs[idx++];
+		sum_rec->asrw_rec.au64s_data =
+			m0_alloc(SUM_SIZE(sum));
+
+		if (sum_rec->asrw_rec.au64s_data == NULL) {
+			/** Restore idx's correct value */
+			--idx;
+			/**
+			 * Reduce the fop_mon_cnt by one, since
+			 * we will not be able to send this sum_rec
+			 * due to memory allocation failure.
+			 */
+			--fop_mon_cnt;
+			--dirtied_scanned;
 			m0_mutex_unlock(&sum->asr_mutex);
+			/**
+			 * Continue to process other elements of the list.
+			 */
+			continue;
 		}
+		sum_rec->asrw_id = sum->asr_rec.asrw_id;
+		sum_rec->asrw_rec.au64s_nr =
+			sum->asr_rec.asrw_rec.au64s_nr;
+		memcpy(sum_rec->asrw_rec.au64s_data,
+				sum->asr_rec.asrw_rec.au64s_data,
+				SUM_SIZE(sum));
+		sum->asr_dirty = false;
+		m0_mutex_unlock(&sum->asr_mutex);
+	}m0_tl_endfor;
+
 
-	/**
-	 * @todo: Send this on-wire fop data by creating and sending a fop
-	 * to stats service.
-	 */
-		for (i = 0; i < fop_mon_cnt; ++i)
-			m0_free(sum_recs_fop->asrf_recs[i].asrw_rec.au64s_data);
-		m0_free(sum_recs_fop->asrf_recs);
-		m0_free(sum_recs_fop);
-	} while (scanned < addb_mon_tlist_length(mon_list));
 	/**
 	 * @todo: Post on global machine too.
 	 */
-	M0_RETURN(rc);
-
-mem_fail:
-	while (--i >= 0)
-		m0_free(sum_recs_fop->asrf_recs[i].asrw_rec.au64s_data);
-	m0_free(sum_recs_fop->asrf_recs);
 	m0_free(sum_recs_fop);
-
 	M0_RETURN(rc);
 }
 
-- 
1.8.3.2

