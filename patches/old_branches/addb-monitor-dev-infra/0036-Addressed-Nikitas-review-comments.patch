From c6588f9ca0dc151ca34932ad8453db8c695cc30b Mon Sep 17 00:00:00 2001
From: Rohan Puri <rohan_puri@xyratex.com>
Date: Tue, 20 Aug 2013 16:25:54 +0530
Subject: [PATCH 036/107] Addressed Nikitas review comments

---
 addb/addb.h                     |   3 +
 addb/addb_mc.c                  |   2 +
 addb/addb_monitor.c             | 160 ++++++++++++++--------------------------
 addb/addb_monitor.h             |  87 ++++++++--------------
 addb/addb_rec.c                 |   5 +-
 addb/addb_rpcsink.c             |   6 ++
 addb/user_space/addb_pfom.c     |   2 +-
 addb/user_space/addb_stobsink.c |   6 ++
 addb/user_space/addb_svc.c      |  11 ---
 addb/ut/addb_ut_fom.c           |   2 +-
 addb/ut/addb_ut_rpcsink.c       |  10 +--
 addb/ut/addb_ut_stobsink.c      |  11 ++-
 doc/dld-index.c                 |   1 +
 m0t1fs/linux_kernel/m0t1fs.c    |  21 ++----
 m0t1fs/linux_kernel/super.c     |   1 +
 mero/setup.c                    |  16 ++--
 mero/setup.h                    |   3 +
 reqh/reqh.c                     |   8 ++
 reqh/reqh.h                     |  48 +++++++-----
 19 files changed, 177 insertions(+), 226 deletions(-)

diff --git a/addb/addb.h b/addb/addb.h
index 810b1fb..13be84f 100644
--- a/addb/addb.h
+++ b/addb/addb.h
@@ -797,6 +797,7 @@ struct m0_addb_mc {
 	uint64_t                   am_magic;
 	struct m0_addb_mc_evmgr   *am_evmgr;  /* required */
 	struct m0_addb_mc_recsink *am_sink;   /* optional */
+	struct m0_reqh            *am_reqh;   /* required */
 };
 
 /**
@@ -923,6 +924,7 @@ enum {
  */
 M0_INTERNAL int m0_addb_mc_configure_rpc_sink(struct m0_addb_mc     *mc,
 					      struct m0_rpc_machine *rm,
+					      struct m0_reqh        *reqh,
 					      uint32_t               npgs_init,
 					      uint32_t               npgs_max,
 					      m0_bcount_t            pg_size);
@@ -965,6 +967,7 @@ M0_INTERNAL void m0_addb_mc_rpc_sink_source_del(struct m0_rpc_item_source *src);
    @pre segment_size > 0 && max_stob_size >= segment_size && rel_timeout > 0
  */
 M0_INTERNAL int m0_addb_mc_configure_stob_sink(struct m0_addb_mc *mc,
+					       struct m0_reqh    *reqh,
 					       struct m0_stob    *stob,
 					       m0_bcount_t        segment_size,
 					       m0_bcount_t        max_stob_size,
diff --git a/addb/addb_mc.c b/addb/addb_mc.c
index 5e45bea..74d7f1a 100644
--- a/addb/addb_mc.c
+++ b/addb/addb_mc.c
@@ -53,6 +53,7 @@ M0_INTERNAL void m0_addb_mc_init(struct m0_addb_mc *mc)
 {
 	mc->am_evmgr = NULL;
 	mc->am_sink  = NULL;
+	mc->am_reqh  = NULL;
 	mc->am_magic = M0_ADDB_MC_MAGIC;
 }
 
@@ -78,6 +79,7 @@ M0_INTERNAL void m0_addb_mc_fini(struct m0_addb_mc *mc)
 		(*sink->rs_put)(mc, sink);
 	}
 	mc->am_magic = 0;
+	mc->am_reqh = NULL;
 	M0_POST(!m0_addb_mc_is_initialized(mc));
 }
 
diff --git a/addb/addb_monitor.c b/addb/addb_monitor.c
index 58d0c93..9ea314b 100644
--- a/addb/addb_monitor.c
+++ b/addb/addb_monitor.c
@@ -44,8 +44,7 @@
    <hr>
    @section ADDB-MON-INFRA-DLD-ovw Overview
    This design describes the ADDB monitoring infrastructure along with posting
-   of addb summary records to stats service & addb service(if from client else
-   on sinks them to addb stobs on server).
+   of addb summary records to stats service.
 
    <hr>
    @section ADDB-MON-INFRA-DLD-def Definitions
@@ -87,7 +86,7 @@
    use of a simple fom on the client. This simple fom has the same states &
    state transitions as of the addb pfom.
 
-
+   @verbatim
 		Global ADDB monitors list
              ____    ____    ____          ____
 	    |mon1|->|mon2|->|mon3|-... -> |monn|
@@ -102,6 +101,8 @@
 	    .
 	addb_rec_n
 
+   @endverbatim
+
 	Periodically running fom will send all the addb summary records for
 	all the monitors to the stats service & post the summary data as addb
 	summary records on the globally available addb machine.
@@ -152,8 +153,6 @@
 
 #include "addb/addb_monitor.h"
 
-struct m0_addb_monitor_global_ctx monitor_global_ctx;
-
 M0_TL_DESCR_DEFINE(addb_mon, "addb monitors list", M0_INTERNAL,
 		   struct m0_addb_monitor, am_linkage, am_magic,
 		   M0_ADDB_MONITOR_LIST_LINK_MAGIC,
@@ -168,49 +167,24 @@ struct addb_monitor_entry {
 	bool         status;
 };
 
-/**
- * List of all monitor entries
- * @todo: Only monitor entry's status "ON/OFF" should come from conf
- */
-struct addb_monitor_entry monitors[] = {
-	{ NULL, NULL, NULL, false}
-};
-
-M0_INTERNAL int m0_addb_monitor_subsys_init(const struct m0_reqh *reqh,
-					    const char           *endpoint)
+M0_INTERNAL int m0_addb_monitors_init(struct m0_reqh *reqh,
+				      const char     *endpoint)
 {
 	int rc = 0;
-	int i;
 
 	M0_PRE(reqh != NULL);
 	M0_PRE(endpoint != NULL);
 
-	addb_mon_tlist_init(&monitor_global_ctx.amgc_list);
-
-	monitor_global_ctx.amgc_reqh = reqh;
-
+	addb_mon_tlist_init(&reqh->rh_addb_monitoring_ctx.amc_list);
 	/*
 	 * @todo: Establish connection with stats service
 	 */
-
-	for (i = 0; i < ARRAY_SIZE(monitors); ++i) {
-		if (monitors[i].status == true)
-			rc = monitors[i].ame_init();
-			if (rc != 0)
-				goto fail;
-	}
-
-fail:
-	while (--i >= 0)
-		if (monitors[i].ame_fini != NULL)
-			monitors[i].ame_fini();
-
 	return rc;
 }
 
 M0_INTERNAL bool m0_addb_monitor_invariant(struct m0_addb_monitor *mon)
 {
-	return (mon != NULL && mon->am_ops != NULL);
+	return mon != NULL && mon->am_ops != NULL;
 }
 
 M0_INTERNAL void m0_addb_monitor_init(struct m0_addb_monitor           *monitor,
@@ -220,15 +194,13 @@ M0_INTERNAL void m0_addb_monitor_init(struct m0_addb_monitor           *monitor,
 	M0_PRE(mon_ops != NULL);
 
 	monitor->am_ops = mon_ops;
-
 	addb_mon_tlink_init(monitor);
-
 }
 
-M0_INTERNAL void m0_addb_sum_rec_init(struct m0_addb_sum_rec        *sum_rec,
-				      const struct m0_addb_rec_type *rtype,
-				      uint64_t                      *mon_data,
-				      size_t                         nr)
+M0_INTERNAL void m0_addb_monitor_sum_rec_init(struct m0_addb_sum_rec        *sum_rec,
+					      const struct m0_addb_rec_type *rtype,
+					      uint64_t                      *mon_data,
+					      size_t                         nr)
 {
 	/** @todo: need to implement */
 }
@@ -241,11 +213,12 @@ M0_INTERNAL void m0_addb_monitor_fini(struct m0_addb_monitor *monitor)
 	addb_mon_tlink_fini(monitor);
 }
 
-M0_INTERNAL void m0_addb_monitor_add(struct m0_addb_monitor *monitor)
+M0_INTERNAL void m0_addb_monitor_add(struct m0_reqh         *reqh,
+				     struct m0_addb_monitor *monitor)
 {
 	M0_PRE(m0_addb_monitor_invariant(monitor));
 
-	addb_mon_tlist_add_tail(&monitor_global_ctx.amgc_list, monitor);
+	addb_mon_tlist_add_tail(&reqh->rh_addb_monitoring_ctx.amc_list, monitor);
 }
 
 M0_INTERNAL void m0_addb_monitor_del(struct m0_addb_monitor *monitor)
@@ -255,44 +228,39 @@ M0_INTERNAL void m0_addb_monitor_del(struct m0_addb_monitor *monitor)
 	addb_mon_tlist_del(monitor);
 }
 
-M0_INTERNAL void m0_addb_monitor_subsys_fini(void)
+M0_INTERNAL void m0_addb_monitors_fini(struct m0_reqh *reqh)
 {
 	struct m0_addb_monitor *mon;
 
-	m0_tl_for(addb_mon, &monitor_global_ctx.amgc_list, mon) {
+	m0_tl_for(addb_mon, &reqh->rh_addb_monitoring_ctx.amc_list, mon) {
 		m0_addb_monitor_del(mon);
 		m0_addb_monitor_fini(mon);
 	} m0_tl_endfor;
 
-	addb_mon_tlist_fini(&monitor_global_ctx.amgc_list);
+	addb_mon_tlist_fini(&reqh->rh_addb_monitoring_ctx.amc_list);
 	/** @todo: Close connection with stats service and do related cleanup */
-	monitor_global_ctx.amgc_reqh = NULL;
 }
 
 #define SUM_SIZE(sum) (sum->asr_rec.asrw_rec.au64s_nr * sizeof(uint64_t))
 
-M0_INTERNAL int m0_addb_monitor_post_summaries(void)
+enum {
+	BATCH = 1024
+};
+
+M0_INTERNAL int m0_addb_monitor_summaries_post(struct m0_reqh *reqh)
 {
-	const struct m0_addb_monitor *mon;
-	const struct m0_reqh         *reqh = monitor_global_ctx.amgc_reqh;
-	uint16_t		      dirtied_mon_cnt = 0;
+	struct m0_addb_monitor       *mon;
 	struct m0_addb_sum_rec_fop   *sum_recs_fop;
+	uint32_t		      dirtied_mon_cnt = 0;
 	int                           i = 0;
 	int                           rc = 0;
-	uint32_t                      fop_len = 0;
-
-	M0_ALLOC_PTR(sum_recs_fop);
-
-	if (sum_recs_fop == NULL) {
-		rc = -ENOMEM;
-		M0_RETURN(rc);
-	}
+	uint32_t                      fop_mon_cnt = 0;
 
-	m0_tl_for(addb_mon, &monitor_global_ctx.amgc_list, mon) {
+	m0_tl_for(addb_mon, &reqh->rh_addb_monitoring_ctx.amc_list, mon) {
 		if (mon->am_ops->amo_sum_rec != NULL) {
 			struct m0_addb_sum_rec *sum = mon->am_ops->amo_sum_rec(mon,
 						                      reqh);
-			if (sum->asr_dirty == true)
+			if (sum->asr_dirty)
 				++dirtied_mon_cnt;
 		}
 	} m0_tl_endfor;
@@ -300,62 +268,43 @@ M0_INTERNAL int m0_addb_monitor_post_summaries(void)
 	if (dirtied_mon_cnt == 0)
 		M0_RETURN(rc);
 
-	M0_ALLOC_ARR(sum_recs_fop->asrf_recs, dirtied_mon_cnt);
-
-	fop_len += sizeof(sum_recs_fop->asrf_recs[0]) * dirtied_mon_cnt;
-
-	if (sum_recs_fop->asrf_recs == NULL) {
-		rc = -ENOMEM;
-		M0_RETURN(rc);
-	}
+	do {
+		M0_ALLOC_PTR(sum_recs_fop);
+		if (sum_recs_fop == NULL) {
+			rc = -ENOMEM;
+			M0_RETURN(rc);
+		}
+		fop_mon_cnt = min32u(dirtied_mon_cnt, BATCH);
+		M0_ALLOC_ARR(sum_recs_fop->asrf_recs, fop_mon_cnt);
+		if (sum_recs_fop->asrf_recs == NULL) {
+			rc = -ENOMEM;
+			M0_RETURN(rc);
+		}
 
-	m0_tl_for(addb_mon, &monitor_global_ctx.amgc_list, mon) {
-		if (mon->am_ops->amo_sum_rec != NULL) {
+		for( i = 0; i < fop_mon_cnt; ++i) {
 			struct m0_addb_sum_rec_wire  *sum_rec;
 			struct m0_addb_sum_rec       *sum =
 				mon->am_ops->amo_sum_rec(mon, reqh);
 
-			m0_mutex_lock(&sum->asr_mutex);
-			if (sum->asr_dirty == true) {
-				/**
-				 * @note: There can be a case wherein, when
-				 * we compute dirtied_mon_cnt value by first
-				 * mon list traversal and when we reach here,
-				 * no of addb sum recs which are dirty can be
-				 * more than dirtied_mon_cnt, but we have
-				 * allocated space for only dirtied_mon_cnt
-				 * pointers of m0_addb_sum_rec, hence we break
-				 * here. The m0_addb_sum_recs which are dirtied
-				 * in this small window, would be sent during
-				 * next periodic call to this function.
-				 */
-				if (i == dirtied_mon_cnt) {
-					m0_mutex_unlock(&sum->asr_mutex);
-					break;
-				}
-
-				sum_rec = &(sum_recs_fop->asrf_recs[i++]);
-
-				/**
-				 * @todo: Need to check this with max fop
-				 * size that can be sent and take action
-				 * accordingly.
-				 */
-				fop_len += SUM_SIZE(sum);
+			mon = addb_mon_tlist_head(&reqh->rh_addb_monitoring_ctx.amc_list);
+			addb_mon_tlist_move_tail(&reqh->rh_addb_monitoring_ctx.amc_list,
+						 mon);
+			if (mon->am_ops->amo_sum_rec == NULL)
+				continue;
 
+			m0_mutex_lock(&sum->asr_mutex);
+			if (sum->asr_dirty) {
+				sum_rec = &sum_recs_fop->asrf_recs[i++];
 				sum_rec->asrw_rec.au64s_data =
 					m0_alloc(SUM_SIZE(sum));
 
-
 				if (sum_rec->asrw_rec.au64s_data == NULL) {
 					rc = -ENOMEM;
 					goto mem_fail;
 				}
-
 				sum_rec->asrw_id = sum->asr_rec.asrw_id;
 				sum_rec->asrw_rec.au64s_nr =
 					sum->asr_rec.asrw_rec.au64s_nr;
-
 				memcpy(sum_rec->asrw_rec.au64s_data,
 				       sum->asr_rec.asrw_rec.au64s_data,
 				       SUM_SIZE(sum));
@@ -363,22 +312,25 @@ M0_INTERNAL int m0_addb_monitor_post_summaries(void)
 			sum->asr_dirty = false;
 			m0_mutex_unlock(&sum->asr_mutex);
 		}
-	} m0_tl_endfor;
 
 	/**
 	 * @todo: Send this on-wire fop data by creating and sending a fop
 	 * to stats service.
 	 */
-
+		for (i = 0; i < fop_mon_cnt; ++i)
+			m0_free(sum_recs_fop->asrf_recs[i].asrw_rec.au64s_data);
+		m0_free(sum_recs_fop->asrf_recs);
+		m0_free(sum_recs_fop);
+		dirtied_mon_cnt -= fop_mon_cnt;
+	} while (dirtied_mon_cnt > 0);
 	/**
 	 * @todo: Post on global machine too.
 	 */
 	M0_RETURN(rc);
 
 mem_fail:
-	while ( --i >= 0)
+	while (--i >= 0)
 		m0_free(sum_recs_fop->asrf_recs[i].asrw_rec.au64s_data);
-
 	m0_free(sum_recs_fop->asrf_recs);
 	m0_free(sum_recs_fop);
 
diff --git a/addb/addb_monitor.h b/addb/addb_monitor.h
index 38eb6ec..1fca29f 100644
--- a/addb/addb_monitor.h
+++ b/addb/addb_monitor.h
@@ -26,7 +26,7 @@
 #include "addb/addb.h"
 #include "lib/vec.h"
 #include "lib/bitmap.h"
-#include "reqh/reqh.h"
+#include "rpc/session.h"
 
 /**
    @page ADDB-MON-INFRA-DLD-fspec Functional Specification
@@ -44,7 +44,7 @@
 
    The following data structures are involved in an ADDB monitoring
    infrastructure:
-   - m0_addb_monitor_global_ctx
+   - m0_addb_monitoring_ctx
    - m0_addb_monitor
    - m0_addb_sum_rec
 
@@ -52,11 +52,11 @@
    @section ADDB-DLD-fspec-sub Subroutines and Macros
 
    Interfaces needed for ADDB monitoring infrastructure
-   - m0_addb_monitor_subsys_init()
+   - m0_addb_monitors_init()
    - m0_addb_monitor_add()
    - m0_addb_monitor_del()
-   - m0_addb_monitor_subsys_fini()
-   - m0_addb_monitor_post_summaries()
+   - m0_addb_monitors_fini()
+   - m0_addb_monitor_summaries_post()
 
    <hr>
    @section ADDB-DLD-fspec-usecases Recipes
@@ -70,11 +70,13 @@
    @code
 	// 1. Add monitor to the structure that is to be monitored
 	//    or dynamically allocate them as mentioned in step 7.
+	//    Define key field to locate m0_addb_sum_rec for this monitor.
 	struct m0_xyz_module_struct {
 		.
 		.
 		.
 		struct m0_addb_monitor xms_mon;
+		uint32_t               xms_key;
 	};
 
 	Lets consider we have a variable available to access an instance
@@ -104,16 +106,9 @@
 	the meaning to the ADDB summary record type defined in 2 (serial order
 	should be maintained while defining the structure).
 
-	// 4. Define key to locate m0_addb_sum_rec for this monitor.
-
-	// This can be either global or can be embedded in module specific
-	// top level structure. For eg. can be as a sibling along with
-	// m0_addb_monitor.
-	uint32_t xyz_key;
-
 	// 4. Define monitor operation amo_sum_rec
-	struct m0_add_sum_rec * xyz_amo_sum_rec(const struct m0_addb_monitor *mon,
-						const struct m0_reqh *reqh)
+	struct m0_add_sum_rec *xyz_amo_sum_rec(const struct m0_addb_monitor *mon,
+					       struct m0_reqh             *reqh)
 	{
 		return m0_reqh_lockers_get(reqh, xyz_key);
 	}
@@ -129,7 +124,7 @@
 		// specifically wants to synchronize access to summary data.
 		m0_mutex_lock(&xyz->asr_mutex);
 		// update data
-		// set the dirty flag
+		xyz->asr_dirty = true;
 		m0_mutex_unlock(&xyz->asr_mutex);
 	}
 
@@ -175,31 +170,21 @@
 		m0_addb_monitor_fini(&xyz_module_var.xms_mon);
 	}
 
-	// 9. Add these monitor entry's init/fini to monitor entry's array.
-	struct addb_monitor_entry monitors[] = {
-		.
-		.
-		.
-		{ xyz_ame_init, xyz_ame_fini, "xyz_mon", true },
-		.
-		.
-		.
-	};
-
    @endcode
 */
 
 #include "addb/addb_monitor_wire.h"
 #include "rpc/conn.h"
 
+struct m0_reqh;
 struct m0_addb_monitor;
 
 M0_TL_DESCR_DECLARE(addb_mon, M0_EXTERN);
 
 struct m0_addb_sum_rec {
 	/**
-	 * If this is updated then asr_dirty: true
-	 * asr_dirty:false on sending this summary record to stats service
+	 * This flag is true iff the record contains data still
+	 * not sent to the stats service. 
 	 */
 	bool                         asr_dirty;
 	/** This lock serializes access to this structure */
@@ -214,12 +199,7 @@ struct m0_addb_sum_rec {
 
 struct m0_addb_monitor_ops {
 	/**
-	 * Any processing specific to monitor is done here
-	 * includes, updates to the m0_addb_sum_rec.
-	 *
-	 * NOTE: This update to m0_addb_sum_rec requires
-	 * m0_addb_sum_rec::asr_mutex lock to be held only iff
-	 * monitor implementor wants to synchronize access to it.
+	 * This method is called on each addb record. 
 	 */
 	void                    (*amo_watch) (const struct m0_addb_monitor *mon,
 					      const struct m0_addb_rec     *rec,
@@ -231,8 +211,8 @@ struct m0_addb_monitor_ops {
 
 struct m0_addb_monitor {
 	/**
-	 * Linkage to global monitors list in
-	 * m0_addb_monitor_global_ctx:amgc_list
+	 * Linkage to monitors list per reqh
+	 * reqh::m0_addb_monitoring_ctx::amc_list
 	 */
 	struct m0_tlink                   am_linkage;
 	/** ADDB monitor operations vector */
@@ -246,24 +226,17 @@ struct m0_addb_monitor {
  */
 M0_INTERNAL bool m0_addb_monitor_invariant(struct m0_addb_monitor *mon);
 
-struct stats_conn {
-	struct m0_rpc_conn    sc_conn;
-	struct m0_rpc_session sc_session;
-	bool                  sc_connected;
-};
-
 /**
  * Monitoring sub-system collective information
  * object.
  */
-struct m0_addb_monitor_global_ctx {
+struct m0_addb_monitoring_ctx {
 	/* List of active monitors */
-	struct m0_tl                       amgc_list;
+	struct m0_tl                       amc_list;
 	/* Stats service endpoint */
-	struct cs_endpoint_and_xprt       *amgc_ex;
-	/* Stats service connection related thing */
-	struct stats_conn                  amgc_stats_conn;
-	const struct m0_reqh              *amgc_reqh;
+	struct cs_endpoint_and_xprt       *amc_ex;
+	struct m0_rpc_conn                 amc_stats_conn;
+	struct m0_rpc_session              amc_stats_session;
 };
 
 /**
@@ -272,12 +245,10 @@ struct m0_addb_monitor_global_ctx {
  * @param endpoint endpoint where stats service runs
  * @pre reqh != NULL
  * @pre endpoint != NULL
- * @post m0_addb_monitor_global_ctx:amgc_list initialized
- * @post m0_addb_monitor_global_ctx:amgc_ex != NULL
- * @todo: Replace substring "subsys" with some other appropriate name
+ * @post reqh::rh_addb_monitoring_ctx:amg_list initialized
  */
-M0_INTERNAL int m0_addb_monitor_subsys_init(const struct m0_reqh *reqh,
-					    const char           *endpoint);
+M0_INTERNAL int m0_addb_monitors_init(struct m0_reqh *reqh,
+				      const char     *endpoint);
 
 /**
  * Initialize ADDB monitor
@@ -305,7 +276,8 @@ M0_INTERNAL void m0_addb_sum_rec_init(struct m0_addb_sum_rec        *sum_rec,
  * Add a particular monitor with the ADDB monitoring sub-system
  * @param monitor ADDB monitor to register
  */
-M0_INTERNAL void m0_addb_monitor_add(struct m0_addb_monitor *monitor);
+M0_INTERNAL void m0_addb_monitor_add(struct m0_reqh *reqh,
+				     struct m0_addb_monitor *monitor);
 
 /**
  * Delete a particular monitor from the ADDB monitoring sub-system
@@ -315,21 +287,20 @@ M0_INTERNAL void m0_addb_monitor_del(struct m0_addb_monitor *monitor);
 
 /**
  * Finalize monitor
- * @param  monitro ADDB monitor to finalize
+ * @param  monitor ADDB monitor to finalize
  */
 M0_INTERNAL void m0_addb_monitor_fini(struct m0_addb_monitor *monitor);
 
 /**
  * Cleanup the ADDB monitoring sub-system
- * @todo: Replace substring "subsys" with some other appropriate name
  */
-M0_INTERNAL void m0_addb_monitor_subsys_fini(void);
+M0_INTERNAL void m0_addb_monitors_fini(struct m0_reqh *reqh);
 
 /**
  * This sends all the dirtied addb summary records for the added monitors
  * to the stats service as a fop.
  */
-M0_INTERNAL int m0_addb_monitor_post_summaries(void);
+M0_INTERNAL int m0_addb_monitor_summaries_post(struct m0_reqh *reqh);
 
 #endif /* __MERO_ADDB_ADDB_MONITOR_H__ */
 
diff --git a/addb/addb_rec.c b/addb/addb_rec.c
index 4185132..4374944 100644
--- a/addb/addb_rec.c
+++ b/addb/addb_rec.c
@@ -21,6 +21,7 @@
 /* This file is designed to be included by addb/addb.c */
 
 #include "rpc/rpc_helpers.h" /* m0_xcode_what */
+#include "reqh/reqh.h"
 
 /**
    @addtogroup addb_pvt
@@ -149,9 +150,9 @@ static void addb_rec_post(struct m0_addb_mc *mc,
 	mc->am_evmgr->evm_post(mc, rec);
 
 	/* Invoke all the monitor's filters */
-	m0_tl_for(addb_mon, &monitor_global_ctx.amgc_list, mon) {
+	m0_tl_for(addb_mon, &mc->am_reqh->rh_addb_monitoring_ctx.amc_list, mon) {
 		M0_ASSERT(m0_addb_monitor_invariant(mon));
-		mon->am_ops->amo_watch(mon, rec, monitor_global_ctx.amgc_reqh);
+		mon->am_ops->amo_watch(mon, rec, mc->am_reqh);
 	} m0_tl_endfor;
 }
 
diff --git a/addb/addb_rpcsink.c b/addb/addb_rpcsink.c
index f46f382..5c2d298 100644
--- a/addb/addb_rpcsink.c
+++ b/addb/addb_rpcsink.c
@@ -819,6 +819,7 @@ static const struct m0_addb_mc_recsink rpcsink_ops = {
 M0_INTERNAL int
 m0_addb_mc_configure_rpc_sink(struct m0_addb_mc     *mc,
 			      struct m0_rpc_machine *rm,
+			      struct m0_reqh        *reqh,
 			      uint32_t               npgs_init,
 			      uint32_t		     npgs_max,
 			      m0_bcount_t	     pg_size)
@@ -830,6 +831,10 @@ m0_addb_mc_configure_rpc_sink(struct m0_addb_mc     *mc,
 	M0_PRE(m0_addb_mc_is_initialized(mc));
 	M0_PRE(!m0_addb_mc_has_recsink(mc));
 	M0_PRE(rm != NULL);
+	/**
+	 * @todo: Uncomment this statement
+	M0_PRE(reqh != NULL);
+	*/
 
 	if (M0_FI_ENABLED("rsink_allocation_failed"))
 		{ rsink = NULL; goto rsink_allocation_failed; }
@@ -857,6 +862,7 @@ addb_ts_init_failed:
 	rsink->rs_mc   = mc;
 	rsink->rs_sink = rpcsink_ops;
 	mc->am_sink    = &rsink->rs_sink;
+	mc->am_reqh    = reqh;
 
 	/*
 	 * Register rpcsink item source to all outgoing
diff --git a/addb/user_space/addb_pfom.c b/addb/user_space/addb_pfom.c
index 2b67f4b..60c50a2 100644
--- a/addb/user_space/addb_pfom.c
+++ b/addb/user_space/addb_pfom.c
@@ -250,7 +250,7 @@ static int addb_pfom_fo_tick(struct m0_fom *fom)
 		M0_LOG(M0_DEBUG, "post");
 		m0_reqh_stats_post_addb(reqh);
 
-		err = m0_addb_monitor_post_summaries();
+		err = m0_addb_monitor_summaries_post(svc->as_reqhs.rs_reqh);
 
 		/**
 		 * In case of summaries posting failure, just log error.
diff --git a/addb/user_space/addb_stobsink.c b/addb/user_space/addb_stobsink.c
index e170b94..4866095 100644
--- a/addb/user_space/addb_stobsink.c
+++ b/addb/user_space/addb_stobsink.c
@@ -1111,6 +1111,7 @@ static const struct m0_addb_mc_recsink stobsink_ops = {
 
 /* public interface */
 M0_INTERNAL int m0_addb_mc_configure_stob_sink(struct m0_addb_mc *mc,
+					       struct m0_reqh    *reqh,
 					       struct m0_stob    *stob,
 					       m0_bcount_t        segment_size,
 					       m0_bcount_t        stob_size,
@@ -1125,6 +1126,10 @@ M0_INTERNAL int m0_addb_mc_configure_stob_sink(struct m0_addb_mc *mc,
 	M0_PRE(stob != NULL && segment_size > 0 && stob_size >= segment_size);
 	M0_PRE(segment_size < INT32_MAX);
 	M0_PRE(timeout > 0);
+	/**
+	 * @todo: Uncomment this statement
+	M0_PRE(reqh != NULL);
+	*/
 
 	M0_ALLOC_PTR(sink);
 	if (sink == NULL)
@@ -1164,6 +1169,7 @@ M0_INTERNAL int m0_addb_mc_configure_stob_sink(struct m0_addb_mc *mc,
 	m0_stob_get(stob);
 	sink->ss_sync = false;
 	mc->am_sink = &sink->ss_sink;
+	mc->am_reqh = reqh;
 	M0_POST(stobsink_invariant(sink));
 	return 0;
 fail:
diff --git a/addb/user_space/addb_svc.c b/addb/user_space/addb_svc.c
index 7ab422c..b79ca38 100644
--- a/addb/user_space/addb_svc.c
+++ b/addb/user_space/addb_svc.c
@@ -98,21 +98,10 @@ static bool addb_svc_invariant(const struct addb_svc *svc)
 static int addb_svc_rso_start(struct m0_reqh_service *service)
 {
 	struct addb_svc *svc;
-	int              rc;
 
 	M0_LOG(M0_DEBUG, "starting");
 	M0_PRE(m0_reqh_service_state_get(service) == M0_RST_STARTING);
 
-	/* @todo: Pass correct stats service endpoint */
-	rc = m0_addb_monitor_subsys_init(service->rs_reqh,
-					 "REPLACE-ME");
-	/**
-	 * On monitoring subsystem initialization failure, we just
-	 * log and not terminate the addb service.
-	 */
-	if (rc != 0)
-		M0_LOG(M0_ERROR, "addb monitoring subsystem initialization");
-
 	svc = bob_of(service, struct addb_svc, as_reqhs, &addb_svc_bob);
 	if (addb_svc_start_pfom)
 		addb_pfom_start(svc);
diff --git a/addb/ut/addb_ut_fom.c b/addb/ut/addb_ut_fom.c
index 744e1b7..10f4524 100644
--- a/addb/ut/addb_ut_fom.c
+++ b/addb/ut/addb_ut_fom.c
@@ -146,7 +146,7 @@ static void addb_ut_fom_test(void)
 	start_rpc_client_and_server();
 	m0_addb_mc_init(&mc);
 
-	rc = m0_addb_mc_configure_rpc_sink(&mc, &cctx.rcx_rpc_machine,
+	rc = m0_addb_mc_configure_rpc_sink(&mc, &cctx.rcx_rpc_machine, NULL,
 					   UT_ADDB_FOM_TS_INIT_PAGES,
 					   UT_ADDB_FOM_TS_MAX_PAGES,
 					   UT_ADDB_FOM_TS_PAGE_SIZE);
diff --git a/addb/ut/addb_ut_rpcsink.c b/addb/ut/addb_ut_rpcsink.c
index ee20d8b..d763672 100644
--- a/addb/ut/addb_ut_rpcsink.c
+++ b/addb/ut/addb_ut_rpcsink.c
@@ -104,7 +104,7 @@ static void addb_ut_rpcsink_test(void)
 	 */
 	m0_fi_enable_once("m0_addb_mc_configure_rpc_sink",
 			  "rsink_allocation_failed");
-	rc = m0_addb_mc_configure_rpc_sink(&mc, &rm,
+	rc = m0_addb_mc_configure_rpc_sink(&mc, &rm, NULL,
 					   ADDB_UT_RPCSINK_TS_INIT_PAGES,
 					   ADDB_UT_RPCSINK_TS_MAX_PAGES,
 					   ADDB_UT_RPCSINK_TS_PAGE_SIZE);
@@ -117,7 +117,7 @@ static void addb_ut_rpcsink_test(void)
 	 */
 	m0_fi_enable_once("m0_addb_mc_configure_rpc_sink",
 			  "addb_ts_init_failed");
-	rc = m0_addb_mc_configure_rpc_sink(&mc, &rm,
+	rc = m0_addb_mc_configure_rpc_sink(&mc, &rm, NULL,
 					   ADDB_UT_RPCSINK_TS_INIT_PAGES,
 					   ADDB_UT_RPCSINK_TS_MAX_PAGES,
 					   ADDB_UT_RPCSINK_TS_PAGE_SIZE);
@@ -130,7 +130,7 @@ static void addb_ut_rpcsink_test(void)
 	 */
 	m0_fi_enable_once("m0_addb_mc_configure_rpc_sink",
 			  "item_source_registration_failed");
-	rc = m0_addb_mc_configure_rpc_sink(&mc, &rm,
+	rc = m0_addb_mc_configure_rpc_sink(&mc, &rm, NULL,
 					   ADDB_UT_RPCSINK_TS_INIT_PAGES,
 					   ADDB_UT_RPCSINK_TS_MAX_PAGES,
 					   ADDB_UT_RPCSINK_TS_PAGE_SIZE);
@@ -143,7 +143,7 @@ static void addb_ut_rpcsink_test(void)
 	 */
 	m0_fi_enable_once("m0_addb_mc_configure_rpc_sink",
 			  "skip_item_source_registration");
-	rc = m0_addb_mc_configure_rpc_sink(&mc, &rm,
+	rc = m0_addb_mc_configure_rpc_sink(&mc, &rm, NULL,
 					   ADDB_UT_RPCSINK_TS_INIT_PAGES,
 					   ADDB_UT_RPCSINK_TS_MAX_PAGES,
 					   ADDB_UT_RPCSINK_TS_PAGE_SIZE);
@@ -375,7 +375,7 @@ static void addb_ut_rpcsink_shutdown_test(void)
 	start_rpc_client_and_server();
 	m0_addb_mc_init(&mc);
 
-	rc = m0_addb_mc_configure_rpc_sink(&mc, &cctx.rcx_rpc_machine,
+	rc = m0_addb_mc_configure_rpc_sink(&mc, &cctx.rcx_rpc_machine, NULL,
 					   ADDB_UT_RPCSINK_TS_INIT_PAGES,
 					   ADDB_UT_RPCSINK_TS_MAX_PAGES,
 					   ADDB_UT_RPCSINK_TS_PAGE_SIZE);
diff --git a/addb/ut/addb_ut_stobsink.c b/addb/ut/addb_ut_stobsink.c
index d5db1d1..e3f08a8 100644
--- a/addb/ut/addb_ut_stobsink.c
+++ b/addb/ut/addb_ut_stobsink.c
@@ -316,7 +316,7 @@ static void addb_ut_stobsink_search(void)
 	stobsink_search_idx = 0;
 	stobsink_seg_nr = sz;
 	stob_size = STOBSINK_SEGMENT_SIZE * sz + 1; /* +1: check seg rounding */
-	rc = m0_addb_mc_configure_stob_sink(&mc, stob, STOBSINK_SEGMENT_SIZE,
+	rc = m0_addb_mc_configure_stob_sink(&mc, NULL, stob, STOBSINK_SEGMENT_SIZE,
 					    stob_size, timeout);
 	M0_UT_ASSERT(rc == 0);
 	sink = stobsink_from_mc(&mc);
@@ -775,7 +775,8 @@ static void addb_ut_stob(void)
 
 	m0_addb_mc_init(&mc);
 	stob_size = STOBSINK_SEGMENT_SIZE * STOBSINK_SMALL_SEG_NR;
-	rc = m0_addb_mc_configure_stob_sink(&mc, stob, STOBSINK_SEGMENT_SIZE,
+	rc = m0_addb_mc_configure_stob_sink(&mc, NULL, stob,
+					    STOBSINK_SEGMENT_SIZE,
 					    stob_size, timeout);
 	M0_UT_ASSERT(rc == 0);
 	sink = stobsink_from_mc(&mc);
@@ -807,7 +808,8 @@ static void addb_ut_stob(void)
 
 	/* Test: re-open stob, detects 1 segment, sets seq and offset */
 	m0_addb_mc_init(&mc);
-	rc = m0_addb_mc_configure_stob_sink(&mc, stob, STOBSINK_SEGMENT_SIZE,
+	rc = m0_addb_mc_configure_stob_sink(&mc, NULL, stob,
+					    STOBSINK_SEGMENT_SIZE,
 					    stob_size, timeout);
 	M0_UT_ASSERT(rc == 0);
 	sink = stobsink_from_mc(&mc);
@@ -967,7 +969,8 @@ static void addb_ut_stob(void)
 	m0_addb_mc_fini(&mc);
 	M0_UT_ASSERT(m0_atomic64_get(&stob->so_ref) == 2);
 	m0_addb_mc_init(&mc);
-	rc = m0_addb_mc_configure_stob_sink(&mc, stob, STOBSINK_SEGMENT_SIZE,
+	rc = m0_addb_mc_configure_stob_sink(&mc, NULL, stob,
+					    STOBSINK_SEGMENT_SIZE,
 					    stob_size, timeout);
 	M0_UT_ASSERT(rc == 0);
 	sink = stobsink_from_mc(&mc);
diff --git a/doc/dld-index.c b/doc/dld-index.c
index 9e0f0b3..a18f121 100644
--- a/doc/dld-index.c
+++ b/doc/dld-index.c
@@ -7,6 +7,7 @@
 Detailed designs, ordered alphabetically by title:
 
 - @subpage ADDB-DLD "ADDB detailed design specification"  <!-- addb/addb.c -->
+- @subpage ADDB-MON-INFRA-DLD "ADDB monitoring infrastructure  Detailed Design" <!-- addb/addb_monitor.c -->
 - @subpage NetRQProvDLD "Auto-Provisioning of Receive Message Queue Buffers DLD" <!-- net/tm_provision.c -->
 - @subpage CMDLD "Copy Machine DLD" <!-- cm/cm.c -->
 - @subpage CPDLD "Copy Packet DLD"  <!-- cm/cp.c -->
diff --git a/m0t1fs/linux_kernel/m0t1fs.c b/m0t1fs/linux_kernel/m0t1fs.c
index 2be56e4..97a8c63 100644
--- a/m0t1fs/linux_kernel/m0t1fs.c
+++ b/m0t1fs/linux_kernel/m0t1fs.c
@@ -158,18 +158,13 @@ M0_INTERNAL int m0t1fs_init(void)
 	if (rc != 0)
 		goto net_fini;
 
-	/* @todo: Need to give proper stats service endpoint */
-	rc = m0_addb_monitor_subsys_init(&m0t1fs_globals.g_reqh, "REPLACE-ME");
-	if (rc != 0)
-		goto rpc_fini;
-
 	M0_FOM_SIMPLE_POST(&mam_pfom.pf_fom, &m0t1fs_globals.g_reqh,
 			   &m0t1fs_addb_monitor_pfom_tick,
 			   &mam_pfom, 1);
 
 	rc = m0t1fs_layout_init();
 	if (rc != 0)
-		goto mon_fini;
+		goto rpc_fini;
 
 	rc = register_filesystem(&m0t1fs_fs_type);
 	if (rc != 0)
@@ -180,8 +175,6 @@ M0_INTERNAL int m0t1fs_init(void)
 
 layout_fini:
 	m0t1fs_layout_fini();
-mon_fini:
-	m0_addb_monitor_subsys_fini();
 rpc_fini:
 	m0t1fs_rpc_fini();
 net_fini:
@@ -291,11 +284,13 @@ static int m0t1fs_rpc_init(void)
 		goto dbenv_fini;
 
 	rc = M0_REQH_INIT(reqh,
-			  .rhia_dtm       = (void*)1,
-			  .rhia_db        = dbenv,
-			  .rhia_mdstore   = (void*)1,
-			  .rhia_fol       = fol,
-			  .rhia_svc       = (void*)1);
+			  .rhia_dtm          = (void*)1,
+			  .rhia_db           = dbenv,
+			  .rhia_mdstore      = (void*)1,
+			  .rhia_fol          = fol,
+			  .rhia_svc          = (void*)1,
+			  /** @todo replace with stats service endpoint */
+			  .rhia_stats_svc_ep = "REPLACE-ME");
 	if (rc != 0)
 		goto cob_dom_fini;
 	rc = m0_rpc_machine_init(rpc_machine, cob_dom, ndom, laddr, reqh,
diff --git a/m0t1fs/linux_kernel/super.c b/m0t1fs/linux_kernel/super.c
index 581f087..15fda4b 100644
--- a/m0t1fs/linux_kernel/super.c
+++ b/m0t1fs/linux_kernel/super.c
@@ -603,6 +603,7 @@ static int configure_addb_rpc_sink(struct m0_addb_mc *addb_mc)
 	if (!m0_addb_mc_has_rpc_sink(addb_mc)) {
 		int rc = m0_addb_mc_configure_rpc_sink(addb_mc,
 						&m0t1fs_globals.g_rpc_machine,
+						&m0t1fs_globals.g_reqh,
 						M0_ADDB_RPCSINK_TS_INIT_PAGES,
 						M0_ADDB_RPCSINK_TS_MAX_PAGES,
 						M0_ADDB_RPCSINK_TS_PAGE_SIZE);
diff --git a/mero/setup.c b/mero/setup.c
index e2acc21..0e60084 100644
--- a/mero/setup.c
+++ b/mero/setup.c
@@ -1301,7 +1301,7 @@ static void cs_addb_storage_fini(struct cs_addb_stob *addb_stob)
  */
 static int cs_request_handler_start(struct m0_reqh_context *rctx)
 {
-	int                 rc;
+	int rc;
 
 	/** @todo Pass in a parent ADDB context for the db. Ideally should
 	    be same parent as that of the reqh.
@@ -1371,12 +1371,14 @@ static int cs_request_handler_start(struct m0_reqh_context *rctx)
 	}
 
 	rc = M0_REQH_INIT(&rctx->rc_reqh,
-			  .rhia_dtm       = NULL,
-			  .rhia_db        = &rctx->rc_db,
-			  .rhia_mdstore   = &rctx->rc_mdstore,
-			  .rhia_fol       = &rctx->rc_fol,
-			  .rhia_svc       = NULL,
-			  .rhia_addb_stob = rctx->rc_addb_stob.cas_stob);
+			  .rhia_dtm          = NULL,
+			  .rhia_db           = &rctx->rc_db,
+			  .rhia_mdstore      = &rctx->rc_mdstore,
+			  .rhia_fol          = &rctx->rc_fol,
+			  .rhia_svc          = NULL,
+			  .rhia_addb_stob    = rctx->rc_addb_stob.cas_stob,
+			  /** @todo: Replace with stats service endpoint */
+			  .rhia_stats_svc_ep = "REPLACE-ME");
 	if (rc == 0) {
 		rctx->rc_state = RC_INITIALISED;
 		return 0;
diff --git a/mero/setup.h b/mero/setup.h
index 2129215..8c7c2fd 100644
--- a/mero/setup.h
+++ b/mero/setup.h
@@ -252,6 +252,9 @@ struct m0_mero {
 	/** mdservice endpoint */
 	struct cs_endpoint_and_xprt cc_mds_epx;
 
+	/** stats service endpoint */
+	struct cs_endpoint_and_xprt cc_stats_svc_epx;
+
 	/** list of ioservice end points */
 	struct m0_tl                cc_ios_eps;
 
diff --git a/reqh/reqh.c b/reqh/reqh.c
index 11f66b5..81aef3b 100644
--- a/reqh/reqh.c
+++ b/reqh/reqh.c
@@ -163,6 +163,12 @@ M0_INTERNAL int m0_reqh_init(struct m0_reqh *reqh,
 
 	m0_addb_mc_init(&reqh->rh_addb_mc);
 
+	if (reqh_args->rhia_stats_svc_ep)
+		result = m0_addb_monitors_init(reqh,
+					       reqh_args->rhia_stats_svc_ep);
+	if (result != 0)
+		return result;
+
 	/** @todo Currently passing dbenv to this api, the duty of the
 	    thread doing the io is to create/use a local/embedded m0_dtx
 	    and do m0_db_tx_init() of its m0_db_tx member and then do the
@@ -181,6 +187,7 @@ M0_INTERNAL int m0_reqh_init(struct m0_reqh *reqh,
 		m0_time_t   addb_stob_timeout = M0_MKTIME(300, 0); /* 5 mins */
 
 		result = m0_addb_mc_configure_stob_sink(&reqh->rh_addb_mc,
+						reqh,
 						reqh_args->rhia_addb_stob,
 						addb_stob_seg_size,
 						addb_stob_size,
@@ -237,6 +244,7 @@ M0_INTERNAL void m0_reqh_fini(struct m0_reqh *reqh)
 	m0_sm_group_unlock(&reqh->rh_sm_grp);
 	m0_sm_group_fini(&reqh->rh_sm_grp);
 	m0_addb_ctx_fini(&reqh->rh_addb_ctx);
+	m0_addb_monitors_fini(reqh);
 	m0_addb_mc_fini(&reqh->rh_addb_mc);
         m0_fom_domain_fini(&reqh->rh_fom_dom);
         m0_reqh_svc_tlist_fini(&reqh->rh_services);
diff --git a/reqh/reqh.h b/reqh/reqh.h
index e8790b3..218ea80 100644
--- a/reqh/reqh.h
+++ b/reqh/reqh.h
@@ -32,6 +32,7 @@
 #include "fop/fom.h"
 #include "layout/layout.h"
 #include "ha/epoch.h"
+#include "addb/addb_monitor.h"
 
 /**
    @defgroup reqh Request handler
@@ -95,10 +96,10 @@ enum m0_reqh_states {
  */
 struct m0_reqh {
 	/** Request handler magic. */
-	uint64_t                 rh_magic;
+	uint64_t                      rh_magic;
 
 	/** State machine. */
-	struct m0_sm             rh_sm;
+	struct m0_sm                  rh_sm;
 
 	/**
 	   State machine group.
@@ -107,31 +108,31 @@ struct m0_reqh {
 	   waiters of significant events.
 	   @todo Replace rh_mutex and rh_sd_signal
 	 */
-	struct m0_sm_group       rh_sm_grp;
+	struct m0_sm_group            rh_sm_grp;
 
-	struct m0_dtm		*rh_dtm;
+	struct m0_dtm		     *rh_dtm;
 
 	/** Database environment for this request handler. */
-	struct m0_dbenv         *rh_dbenv;
+	struct m0_dbenv              *rh_dbenv;
 
 	/** Mdstore for this request handler. */
-	struct m0_mdstore       *rh_mdstore;
+	struct m0_mdstore            *rh_mdstore;
 
 	/** Fol pointer for this request handler. */
-	struct m0_fol		*rh_fol;
+	struct m0_fol		     *rh_fol;
 
 	/** Fom domain for this request handler. */
-	struct m0_fom_domain	 rh_fom_dom;
+	struct m0_fom_domain	      rh_fom_dom;
 
         /**
 	    Services registered with this request handler.
 
 	    @see m0_reqh_service::rs_linkage
 	 */
-        struct m0_tl             rh_services;
+        struct m0_tl                  rh_services;
 
 	/** Pointer to the management service */
-	struct m0_reqh_service  *rh_mgmt_svc;
+	struct m0_reqh_service       *rh_mgmt_svc;
 
         /**
 	    RPC machines running in this request handler.
@@ -140,37 +141,42 @@ struct m0_reqh {
 
 	    @see m0_rpc_machine::rm_rh_linkage
 	 */
-        struct m0_tl             rh_rpc_machines;
+        struct m0_tl                  rh_rpc_machines;
 
 	/** provides protected access to reqh members. */
-	struct m0_rwlock         rh_rwlock;
+	struct m0_rwlock              rh_rwlock;
 
 	/**
 	   Private, fully configured, ADDB machine for the request handler.
 	   The first such machine created is used to configure the global
 	   machine, ::m0_addb_gmc.
 	 */
-	struct m0_addb_mc        rh_addb_mc;
+	struct m0_addb_mc             rh_addb_mc;
 
-	struct m0_addb_ctx       rh_addb_ctx;
+	struct m0_addb_ctx            rh_addb_ctx;
+
+	/**
+	 * ADDB monitoring context maintained per request handler.
+	 */
+	struct m0_addb_monitoring_ctx rh_addb_monitoring_ctx;
 
 	/**
 	    Channel to wait on for reqh shutdown or FOM termination.
 	    @deprecated Replace with rh_sm_grp
 	 */
-	struct m0_chan           rh_sd_signal;
-	struct m0_mutex          rh_mutex; /**< protect rh_sd_signal chan */
+	struct m0_chan                rh_sd_signal;
+	struct m0_mutex               rh_mutex; /**< protect rh_sd_signal chan */
 
 	/** Local service consuming reply. */
-	struct m0_local_service *rh_svc;
+	struct m0_local_service      *rh_svc;
 
 	/**
 	 * Layout domain for this request handler.
 	 */
-	struct m0_layout_domain  rh_ldom;
+	struct m0_layout_domain       rh_ldom;
 
 	/** HA domain which stores the epoch. */
-	struct m0_ha_domain      rh_hadom;
+	struct m0_ha_domain           rh_hadom;
 
 	/**
 	    Lockers to store private data
@@ -179,7 +185,7 @@ struct m0_reqh {
 	    at the end of structure.
 	    refer <http://gcc.gnu.org/onlinedocs/gcc/Zero-Length.html>
 	 */
-	struct m0_reqh_lockers   rh_lockers;
+	struct m0_reqh_lockers        rh_lockers;
 };
 
 /**
@@ -197,6 +203,8 @@ struct m0_reqh_init_args {
 	    @see cs_addb_storage_init()
 	  */
 	struct m0_stob          *rhia_addb_stob;
+	/** Stats service endpoint */
+	const char              *rhia_stats_svc_ep;
 };
 
 /**
-- 
1.8.3.2

